{
  "module_name": "augmented_raw_syscalls.bpf.c",
  "hash_id": "5d82ae7ac571abd895a4aece0822bbef5dfe1bd09ff2edf2add6f13afc5c0698",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/bpf_skel/augmented_raw_syscalls.bpf.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <linux/limits.h>\n\n \n#define is_power_of_2(n) (n != 0 && ((n & (n - 1)) == 0))\n\n#define MAX_CPUS  4096\n\n\n#ifndef bool\ntypedef char bool;\n#endif\ntypedef int pid_t;\ntypedef long long int __s64;\ntypedef __s64 time64_t;\n\nstruct timespec64 {\n\ttime64_t\ttv_sec;\n\tlong int\ttv_nsec;\n};\n\n \nstruct __augmented_syscalls__ {\n\t__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n\t__type(key, int);\n\t__type(value, __u32);\n\t__uint(max_entries, MAX_CPUS);\n} __augmented_syscalls__ SEC(\".maps\");\n\n \nstruct syscalls_sys_enter {\n\t__uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n\t__type(key, __u32);\n\t__type(value, __u32);\n\t__uint(max_entries, 512);\n} syscalls_sys_enter SEC(\".maps\");\n\n \nstruct syscalls_sys_exit {\n\t__uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n\t__type(key, __u32);\n\t__type(value, __u32);\n\t__uint(max_entries, 512);\n} syscalls_sys_exit SEC(\".maps\");\n\nstruct syscall_enter_args {\n\tunsigned long long common_tp_fields;\n\tlong\t\t   syscall_nr;\n\tunsigned long\t   args[6];\n};\n\nstruct syscall_exit_args {\n\tunsigned long long common_tp_fields;\n\tlong\t\t   syscall_nr;\n\tlong\t\t   ret;\n};\n\nstruct augmented_arg {\n\tunsigned int\tsize;\n\tint\t\terr;\n\tchar\t\tvalue[PATH_MAX];\n};\n\nstruct pids_filtered {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, pid_t);\n\t__type(value, bool);\n\t__uint(max_entries, 64);\n} pids_filtered SEC(\".maps\");\n\n \n#define SS_MAXSIZE   128      \n\ntypedef unsigned short sa_family_t;\n\n \nstruct sockaddr_storage {\n\tunion {\n\t\tstruct {\n\t\t\tsa_family_t    ss_family;  \n\t\t\t \n\t\t\tchar __data[SS_MAXSIZE - sizeof(unsigned short)];\n\t\t\t\t \n\t\t\t\t \n\t\t};\n\t\tvoid *__align;  \n\t};\n};\n\nstruct augmented_args_payload {\n       struct syscall_enter_args args;\n       union {\n\t\tstruct {\n\t\t\tstruct augmented_arg arg, arg2;\n\t\t};\n\t\tstruct sockaddr_storage saddr;\n\t\tchar   __data[sizeof(struct augmented_arg)];\n\t};\n};\n\n\nstruct augmented_args_tmp {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\t__type(key, int);\n\t__type(value, struct augmented_args_payload);\n\t__uint(max_entries, 1);\n} augmented_args_tmp SEC(\".maps\");\n\nstatic inline struct augmented_args_payload *augmented_args_payload(void)\n{\n\tint key = 0;\n\treturn bpf_map_lookup_elem(&augmented_args_tmp, &key);\n}\n\nstatic inline int augmented__output(void *ctx, struct augmented_args_payload *args, int len)\n{\n\t \n\treturn bpf_perf_event_output(ctx, &__augmented_syscalls__, BPF_F_CURRENT_CPU, args, len);\n}\n\nstatic inline\nunsigned int augmented_arg__read_str(struct augmented_arg *augmented_arg, const void *arg, unsigned int arg_len)\n{\n\tunsigned int augmented_len = sizeof(*augmented_arg);\n\tint string_len = bpf_probe_read_user_str(&augmented_arg->value, arg_len, arg);\n\n\taugmented_arg->size = augmented_arg->err = 0;\n\t \n\tif (string_len > 0) {\n\t\taugmented_len -= sizeof(augmented_arg->value) - string_len;\n\t\t_Static_assert(is_power_of_2(sizeof(augmented_arg->value)), \"sizeof(augmented_arg->value) needs to be a power of two\");\n\t\taugmented_len &= sizeof(augmented_arg->value) - 1;\n\t\taugmented_arg->size = string_len;\n\t} else {\n\t\t \n\t\taugmented_arg->err = string_len;\n\t\taugmented_len = offsetof(struct augmented_arg, value);\n\t}\n\n\treturn augmented_len;\n}\n\nSEC(\"tp/raw_syscalls/sys_enter\")\nint syscall_unaugmented(struct syscall_enter_args *args)\n{\n\treturn 1;\n}\n\n \nSEC(\"tp/syscalls/sys_enter_connect\")\nint sys_enter_connect(struct syscall_enter_args *args)\n{\n\tstruct augmented_args_payload *augmented_args = augmented_args_payload();\n\tconst void *sockaddr_arg = (const void *)args->args[1];\n\tunsigned int socklen = args->args[2];\n\tunsigned int len = sizeof(augmented_args->args);\n\n        if (augmented_args == NULL)\n                return 1;  \n\n\t_Static_assert(is_power_of_2(sizeof(augmented_args->saddr)), \"sizeof(augmented_args->saddr) needs to be a power of two\");\n\tsocklen &= sizeof(augmented_args->saddr) - 1;\n\n\tbpf_probe_read_user(&augmented_args->saddr, socklen, sockaddr_arg);\n\n\treturn augmented__output(args, augmented_args, len + socklen);\n}\n\nSEC(\"tp/syscalls/sys_enter_sendto\")\nint sys_enter_sendto(struct syscall_enter_args *args)\n{\n\tstruct augmented_args_payload *augmented_args = augmented_args_payload();\n\tconst void *sockaddr_arg = (const void *)args->args[4];\n\tunsigned int socklen = args->args[5];\n\tunsigned int len = sizeof(augmented_args->args);\n\n        if (augmented_args == NULL)\n                return 1;  \n\n\tsocklen &= sizeof(augmented_args->saddr) - 1;\n\n\tbpf_probe_read_user(&augmented_args->saddr, socklen, sockaddr_arg);\n\n\treturn augmented__output(args, augmented_args, len + socklen);\n}\n\nSEC(\"tp/syscalls/sys_enter_open\")\nint sys_enter_open(struct syscall_enter_args *args)\n{\n\tstruct augmented_args_payload *augmented_args = augmented_args_payload();\n\tconst void *filename_arg = (const void *)args->args[0];\n\tunsigned int len = sizeof(augmented_args->args);\n\n        if (augmented_args == NULL)\n                return 1;  \n\n\tlen += augmented_arg__read_str(&augmented_args->arg, filename_arg, sizeof(augmented_args->arg.value));\n\n\treturn augmented__output(args, augmented_args, len);\n}\n\nSEC(\"tp/syscalls/sys_enter_openat\")\nint sys_enter_openat(struct syscall_enter_args *args)\n{\n\tstruct augmented_args_payload *augmented_args = augmented_args_payload();\n\tconst void *filename_arg = (const void *)args->args[1];\n\tunsigned int len = sizeof(augmented_args->args);\n\n        if (augmented_args == NULL)\n                return 1;  \n\n\tlen += augmented_arg__read_str(&augmented_args->arg, filename_arg, sizeof(augmented_args->arg.value));\n\n\treturn augmented__output(args, augmented_args, len);\n}\n\nSEC(\"tp/syscalls/sys_enter_rename\")\nint sys_enter_rename(struct syscall_enter_args *args)\n{\n\tstruct augmented_args_payload *augmented_args = augmented_args_payload();\n\tconst void *oldpath_arg = (const void *)args->args[0],\n\t\t   *newpath_arg = (const void *)args->args[1];\n\tunsigned int len = sizeof(augmented_args->args), oldpath_len;\n\n        if (augmented_args == NULL)\n                return 1;  \n\n\toldpath_len = augmented_arg__read_str(&augmented_args->arg, oldpath_arg, sizeof(augmented_args->arg.value));\n\tlen += oldpath_len + augmented_arg__read_str((void *)(&augmented_args->arg) + oldpath_len, newpath_arg, sizeof(augmented_args->arg.value));\n\n\treturn augmented__output(args, augmented_args, len);\n}\n\nSEC(\"tp/syscalls/sys_enter_renameat\")\nint sys_enter_renameat(struct syscall_enter_args *args)\n{\n\tstruct augmented_args_payload *augmented_args = augmented_args_payload();\n\tconst void *oldpath_arg = (const void *)args->args[1],\n\t\t   *newpath_arg = (const void *)args->args[3];\n\tunsigned int len = sizeof(augmented_args->args), oldpath_len;\n\n        if (augmented_args == NULL)\n                return 1;  \n\n\toldpath_len = augmented_arg__read_str(&augmented_args->arg, oldpath_arg, sizeof(augmented_args->arg.value));\n\tlen += oldpath_len + augmented_arg__read_str((void *)(&augmented_args->arg) + oldpath_len, newpath_arg, sizeof(augmented_args->arg.value));\n\n\treturn augmented__output(args, augmented_args, len);\n}\n\n#define PERF_ATTR_SIZE_VER0     64       \n\n \nstruct perf_event_attr_size {\n        __u32                   type;\n         \n        __u32                   size;\n};\n\nSEC(\"tp/syscalls/sys_enter_perf_event_open\")\nint sys_enter_perf_event_open(struct syscall_enter_args *args)\n{\n\tstruct augmented_args_payload *augmented_args = augmented_args_payload();\n\tconst struct perf_event_attr_size *attr = (const struct perf_event_attr_size *)args->args[0], *attr_read;\n\tunsigned int len = sizeof(augmented_args->args);\n\n        if (augmented_args == NULL)\n\t\tgoto failure;\n\n\tif (bpf_probe_read_user(&augmented_args->__data, sizeof(*attr), attr) < 0)\n\t\tgoto failure;\n\n\tattr_read = (const struct perf_event_attr_size *)augmented_args->__data;\n\n\t__u32 size = attr_read->size;\n\n\tif (!size)\n\t\tsize = PERF_ATTR_SIZE_VER0;\n\n\tif (size > sizeof(augmented_args->__data))\n                goto failure;\n\n\t \n\tif (bpf_probe_read_user(&augmented_args->__data, size, attr) < 0)\n\t\tgoto failure;\n\n\treturn augmented__output(args, augmented_args, len + size);\nfailure:\n\treturn 1;  \n}\n\nSEC(\"tp/syscalls/sys_enter_clock_nanosleep\")\nint sys_enter_clock_nanosleep(struct syscall_enter_args *args)\n{\n\tstruct augmented_args_payload *augmented_args = augmented_args_payload();\n\tconst void *rqtp_arg = (const void *)args->args[2];\n\tunsigned int len = sizeof(augmented_args->args);\n\t__u32 size = sizeof(struct timespec64);\n\n        if (augmented_args == NULL)\n\t\tgoto failure;\n\n\tif (size > sizeof(augmented_args->__data))\n                goto failure;\n\n\tbpf_probe_read_user(&augmented_args->__data, size, rqtp_arg);\n\n\treturn augmented__output(args, augmented_args, len + size);\nfailure:\n\treturn 1;  \n}\n\nstatic pid_t getpid(void)\n{\n\treturn bpf_get_current_pid_tgid();\n}\n\nstatic bool pid_filter__has(struct pids_filtered *pids, pid_t pid)\n{\n\treturn bpf_map_lookup_elem(pids, &pid) != NULL;\n}\n\nSEC(\"tp/raw_syscalls/sys_enter\")\nint sys_enter(struct syscall_enter_args *args)\n{\n\tstruct augmented_args_payload *augmented_args;\n\t \n\n\tif (pid_filter__has(&pids_filtered, getpid()))\n\t\treturn 0;\n\n\taugmented_args = augmented_args_payload();\n\tif (augmented_args == NULL)\n\t\treturn 1;\n\n\tbpf_probe_read_kernel(&augmented_args->args, sizeof(augmented_args->args), args);\n\n\t \n\tbpf_tail_call(args, &syscalls_sys_enter, augmented_args->args.syscall_nr);\n\n\t\n\treturn 0;\n}\n\nSEC(\"tp/raw_syscalls/sys_exit\")\nint sys_exit(struct syscall_exit_args *args)\n{\n\tstruct syscall_exit_args exit_args;\n\n\tif (pid_filter__has(&pids_filtered, getpid()))\n\t\treturn 0;\n\n\tbpf_probe_read_kernel(&exit_args, sizeof(exit_args), args);\n\t \n\tbpf_tail_call(args, &syscalls_sys_exit, exit_args.syscall_nr);\n\t \n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}