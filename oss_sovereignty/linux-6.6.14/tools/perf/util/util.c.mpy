{
  "module_name": "util.c",
  "hash_id": "d209f9eb26e34c712f5a2cfba7255afb0bb9906799a8f2949e6fc8cb39e6ee34",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/util.c",
  "human_readable_source": "\n#include \"util.h\"\n#include \"debug.h\"\n#include \"event.h\"\n#include <api/fs/fs.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n#include <linux/capability.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/time64.h>\n#include <linux/overflow.h>\n#include <unistd.h>\n#include \"cap.h\"\n#include \"strlist.h\"\n#include \"string2.h\"\n\n \n\nconst char *input_name;\n\nbool perf_singlethreaded = true;\n\nvoid perf_set_singlethreaded(void)\n{\n\tperf_singlethreaded = true;\n}\n\nvoid perf_set_multithreaded(void)\n{\n\tperf_singlethreaded = false;\n}\n\nint sysctl_perf_event_max_stack = PERF_MAX_STACK_DEPTH;\nint sysctl_perf_event_max_contexts_per_stack = PERF_MAX_CONTEXTS_PER_STACK;\n\nint sysctl__max_stack(void)\n{\n\tint value;\n\n\tif (sysctl__read_int(\"kernel/perf_event_max_stack\", &value) == 0)\n\t\tsysctl_perf_event_max_stack = value;\n\n\tif (sysctl__read_int(\"kernel/perf_event_max_contexts_per_stack\", &value) == 0)\n\t\tsysctl_perf_event_max_contexts_per_stack = value;\n\n\treturn sysctl_perf_event_max_stack;\n}\n\nbool sysctl__nmi_watchdog_enabled(void)\n{\n\tstatic bool cached;\n\tstatic bool nmi_watchdog;\n\tint value;\n\n\tif (cached)\n\t\treturn nmi_watchdog;\n\n\tif (sysctl__read_int(\"kernel/nmi_watchdog\", &value) < 0)\n\t\treturn false;\n\n\tnmi_watchdog = (value > 0) ? true : false;\n\tcached = true;\n\n\treturn nmi_watchdog;\n}\n\nbool test_attr__enabled;\n\nbool perf_host  = true;\nbool perf_guest = false;\n\nvoid event_attr_init(struct perf_event_attr *attr)\n{\n\tif (!perf_host)\n\t\tattr->exclude_host  = 1;\n\tif (!perf_guest)\n\t\tattr->exclude_guest = 1;\n\t \n\tattr->size = sizeof(*attr);\n}\n\nint mkdir_p(char *path, mode_t mode)\n{\n\tstruct stat st;\n\tint err;\n\tchar *d = path;\n\n\tif (*d != '/')\n\t\treturn -1;\n\n\tif (stat(path, &st) == 0)\n\t\treturn 0;\n\n\twhile (*++d == '/');\n\n\twhile ((d = strchr(d, '/'))) {\n\t\t*d = '\\0';\n\t\terr = stat(path, &st) && mkdir(path, mode);\n\t\t*d++ = '/';\n\t\tif (err)\n\t\t\treturn -1;\n\t\twhile (*d == '/')\n\t\t\t++d;\n\t}\n\treturn (stat(path, &st) && mkdir(path, mode)) ? -1 : 0;\n}\n\nstatic bool match_pat(char *file, const char **pat)\n{\n\tint i = 0;\n\n\tif (!pat)\n\t\treturn true;\n\n\twhile (pat[i]) {\n\t\tif (strglobmatch(file, pat[i]))\n\t\t\treturn true;\n\n\t\ti++;\n\t}\n\n\treturn false;\n}\n\n \nstatic int rm_rf_depth_pat(const char *path, int depth, const char **pat)\n{\n\tDIR *dir;\n\tint ret;\n\tstruct dirent *d;\n\tchar namebuf[PATH_MAX];\n\tstruct stat statbuf;\n\n\t \n\tret = lstat(path, &statbuf);\n\tif (ret)\n\t\treturn 0;\n\n\t \n\tif (!(statbuf.st_mode & S_IFDIR))\n\t\treturn unlink(path);\n\n\t \n\tdir = opendir(path);\n\tif (dir == NULL)\n\t\treturn -1;\n\n\twhile ((d = readdir(dir)) != NULL && !ret) {\n\n\t\tif (!strcmp(d->d_name, \".\") || !strcmp(d->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (!match_pat(d->d_name, pat)) {\n\t\t\tret =  -2;\n\t\t\tbreak;\n\t\t}\n\n\t\tscnprintf(namebuf, sizeof(namebuf), \"%s/%s\",\n\t\t\t  path, d->d_name);\n\n\t\t \n\t\tret = lstat(namebuf, &statbuf);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"stat failed: %s\\n\", namebuf);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (S_ISDIR(statbuf.st_mode))\n\t\t\tret = depth ? rm_rf_depth_pat(namebuf, depth - 1, pat) : 0;\n\t\telse\n\t\t\tret = unlink(namebuf);\n\t}\n\tclosedir(dir);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn rmdir(path);\n}\n\nstatic int rm_rf_a_kcore_dir(const char *path, const char *name)\n{\n\tchar kcore_dir_path[PATH_MAX];\n\tconst char *pat[] = {\n\t\t\"kcore\",\n\t\t\"kallsyms\",\n\t\t\"modules\",\n\t\tNULL,\n\t};\n\n\tsnprintf(kcore_dir_path, sizeof(kcore_dir_path), \"%s/%s\", path, name);\n\n\treturn rm_rf_depth_pat(kcore_dir_path, 0, pat);\n}\n\nstatic bool kcore_dir_filter(const char *name __maybe_unused, struct dirent *d)\n{\n\tconst char *pat[] = {\n\t\t\"kcore_dir\",\n\t\t\"kcore_dir__[1-9]*\",\n\t\tNULL,\n\t};\n\n\treturn match_pat(d->d_name, pat);\n}\n\nstatic int rm_rf_kcore_dir(const char *path)\n{\n\tstruct strlist *kcore_dirs;\n\tstruct str_node *nd;\n\tint ret;\n\n\tkcore_dirs = lsdir(path, kcore_dir_filter);\n\n\tif (!kcore_dirs)\n\t\treturn 0;\n\n\tstrlist__for_each_entry(nd, kcore_dirs) {\n\t\tret = rm_rf_a_kcore_dir(path, nd->s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tstrlist__delete(kcore_dirs);\n\n\treturn 0;\n}\n\nint rm_rf_perf_data(const char *path)\n{\n\tconst char *pat[] = {\n\t\t\"data\",\n\t\t\"data.*\",\n\t\tNULL,\n\t};\n\n\trm_rf_kcore_dir(path);\n\n\treturn rm_rf_depth_pat(path, 0, pat);\n}\n\nint rm_rf(const char *path)\n{\n\treturn rm_rf_depth_pat(path, INT_MAX, NULL);\n}\n\n \nbool lsdir_no_dot_filter(const char *name __maybe_unused, struct dirent *d)\n{\n\treturn d->d_name[0] != '.';\n}\n\n \nstruct strlist *lsdir(const char *name,\n\t\t      bool (*filter)(const char *, struct dirent *))\n{\n\tstruct strlist *list = NULL;\n\tDIR *dir;\n\tstruct dirent *d;\n\n\tdir = opendir(name);\n\tif (!dir)\n\t\treturn NULL;\n\n\tlist = strlist__new(NULL, NULL);\n\tif (!list) {\n\t\terrno = ENOMEM;\n\t\tgoto out;\n\t}\n\n\twhile ((d = readdir(dir)) != NULL) {\n\t\tif (!filter || filter(name, d))\n\t\t\tstrlist__add(list, d->d_name);\n\t}\n\nout:\n\tclosedir(dir);\n\treturn list;\n}\n\nsize_t hex_width(u64 v)\n{\n\tsize_t n = 1;\n\n\twhile ((v >>= 4))\n\t\t++n;\n\n\treturn n;\n}\n\nint perf_event_paranoid(void)\n{\n\tint value;\n\n\tif (sysctl__read_int(\"kernel/perf_event_paranoid\", &value))\n\t\treturn INT_MAX;\n\n\treturn value;\n}\n\nbool perf_event_paranoid_check(int max_level)\n{\n\treturn perf_cap__capable(CAP_SYS_ADMIN) ||\n\t\t\tperf_cap__capable(CAP_PERFMON) ||\n\t\t\tperf_event_paranoid() <= max_level;\n}\n\nstatic int\nfetch_ubuntu_kernel_version(unsigned int *puint)\n{\n\tssize_t len;\n\tsize_t line_len = 0;\n\tchar *ptr, *line = NULL;\n\tint version, patchlevel, sublevel, err;\n\tFILE *vsig;\n\n\tif (!puint)\n\t\treturn 0;\n\n\tvsig = fopen(\"/proc/version_signature\", \"r\");\n\tif (!vsig) {\n\t\tpr_debug(\"Open /proc/version_signature failed: %s\\n\",\n\t\t\t strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlen = getline(&line, &line_len, vsig);\n\tfclose(vsig);\n\terr = -1;\n\tif (len <= 0) {\n\t\tpr_debug(\"Reading from /proc/version_signature failed: %s\\n\",\n\t\t\t strerror(errno));\n\t\tgoto errout;\n\t}\n\n\tptr = strrchr(line, ' ');\n\tif (!ptr) {\n\t\tpr_debug(\"Parsing /proc/version_signature failed: %s\\n\", line);\n\t\tgoto errout;\n\t}\n\n\terr = sscanf(ptr + 1, \"%d.%d.%d\",\n\t\t     &version, &patchlevel, &sublevel);\n\tif (err != 3) {\n\t\tpr_debug(\"Unable to get kernel version from /proc/version_signature '%s'\\n\",\n\t\t\t line);\n\t\tgoto errout;\n\t}\n\n\t*puint = (version << 16) + (patchlevel << 8) + sublevel;\n\terr = 0;\nerrout:\n\tfree(line);\n\treturn err;\n}\n\nint\nfetch_kernel_version(unsigned int *puint, char *str,\n\t\t     size_t str_size)\n{\n\tstruct utsname utsname;\n\tint version, patchlevel, sublevel, err;\n\tbool int_ver_ready = false;\n\n\tif (access(\"/proc/version_signature\", R_OK) == 0)\n\t\tif (!fetch_ubuntu_kernel_version(puint))\n\t\t\tint_ver_ready = true;\n\n\tif (uname(&utsname))\n\t\treturn -1;\n\n\tif (str && str_size) {\n\t\tstrncpy(str, utsname.release, str_size);\n\t\tstr[str_size - 1] = '\\0';\n\t}\n\n\tif (!puint || int_ver_ready)\n\t\treturn 0;\n\n\terr = sscanf(utsname.release, \"%d.%d.%d\",\n\t\t     &version, &patchlevel, &sublevel);\n\n\tif (err != 3) {\n\t\tpr_debug(\"Unable to get kernel version from uname '%s'\\n\",\n\t\t\t utsname.release);\n\t\treturn -1;\n\t}\n\n\t*puint = (version << 16) + (patchlevel << 8) + sublevel;\n\treturn 0;\n}\n\nint perf_tip(char **strp, const char *dirpath)\n{\n\tstruct strlist *tips;\n\tstruct str_node *node;\n\tstruct strlist_config conf = {\n\t\t.dirname = dirpath,\n\t\t.file_only = true,\n\t};\n\tint ret = 0;\n\n\t*strp = NULL;\n\ttips = strlist__new(\"tips.txt\", &conf);\n\tif (tips == NULL)\n\t\treturn -errno;\n\n\tif (strlist__nr_entries(tips) == 0)\n\t\tgoto out;\n\n\tnode = strlist__entry(tips, random() % strlist__nr_entries(tips));\n\tif (asprintf(strp, \"Tip: %s\", node->s) < 0)\n\t\tret = -ENOMEM;\n\nout:\n\tstrlist__delete(tips);\n\n\treturn ret;\n}\n\nchar *perf_exe(char *buf, int len)\n{\n\tint n = readlink(\"/proc/self/exe\", buf, len);\n\tif (n > 0) {\n\t\tbuf[n] = 0;\n\t\treturn buf;\n\t}\n\treturn strcpy(buf, \"perf\");\n}\n\nvoid perf_debuginfod_setup(struct perf_debuginfod *di)\n{\n\t \n\tif (!di->set)\n\t\tsetenv(\"DEBUGINFOD_URLS\", \"\", 1);\n\telse if (di->urls && strcmp(di->urls, \"system\"))\n\t\tsetenv(\"DEBUGINFOD_URLS\", di->urls, 1);\n\n\tpr_debug(\"DEBUGINFOD_URLS=%s\\n\", getenv(\"DEBUGINFOD_URLS\"));\n\n#ifndef HAVE_DEBUGINFOD_SUPPORT\n\tif (di->set)\n\t\tpr_warning(\"WARNING: debuginfod support requested, but perf is not built with it\\n\");\n#endif\n}\n\n \nchar *filename_with_chroot(int pid, const char *filename)\n{\n\tchar buf[PATH_MAX];\n\tchar proc_root[32];\n\tchar *new_name = NULL;\n\tint ret;\n\n\tscnprintf(proc_root, sizeof(proc_root), \"/proc/%d/root\", pid);\n\tret = readlink(proc_root, buf, sizeof(buf) - 1);\n\tif (ret <= 0)\n\t\treturn NULL;\n\n\t \n\tbuf[ret] = '\\0';\n\n\tif (!strcmp(buf, \"/\"))\n\t\treturn NULL;\n\n\tif (strstr(buf, \"(deleted)\"))\n\t\treturn NULL;\n\n\tif (asprintf(&new_name, \"%s/%s\", buf, filename) < 0)\n\t\treturn NULL;\n\n\treturn new_name;\n}\n\n \nint do_realloc_array_as_needed(void **arr, size_t *arr_sz, size_t x, size_t msz, const void *init_val)\n{\n\tsize_t new_sz = *arr_sz;\n\tvoid *new_arr;\n\tsize_t i;\n\n\tif (!new_sz)\n\t\tnew_sz = msz >= 64 ? 1 : roundup(64, msz);  \n\twhile (x >= new_sz) {\n\t\tif (check_mul_overflow(new_sz, (size_t)2, &new_sz))\n\t\t\treturn -ENOMEM;\n\t}\n\tif (new_sz == *arr_sz)\n\t\treturn 0;\n\tnew_arr = calloc(new_sz, msz);\n\tif (!new_arr)\n\t\treturn -ENOMEM;\n\tif (*arr_sz)\n\t\tmemcpy(new_arr, *arr, *arr_sz * msz);\n\tif (init_val) {\n\t\tfor (i = *arr_sz; i < new_sz; i++)\n\t\t\tmemcpy(new_arr + (i * msz), init_val, msz);\n\t}\n\t*arr = new_arr;\n\t*arr_sz = new_sz;\n\treturn 0;\n}\n\n#ifndef HAVE_SCHED_GETCPU_SUPPORT\nint sched_getcpu(void)\n{\n#ifdef __NR_getcpu\n\tunsigned int cpu;\n\tint err = syscall(__NR_getcpu, &cpu, NULL, NULL);\n\n\tif (!err)\n\t\treturn cpu;\n#else\n\terrno = ENOSYS;\n#endif\n\treturn -1;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}