{
  "module_name": "expr.c",
  "hash_id": "23b6d2c5f6d87a456f9a36b7a72f9d29026ad3383c66095e238d6f62e09e2d62",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/expr.c",
  "human_readable_source": "\n#include <stdbool.h>\n#include <assert.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"metricgroup.h\"\n#include \"cpumap.h\"\n#include \"cputopo.h\"\n#include \"debug.h\"\n#include \"evlist.h\"\n#include \"expr.h\"\n#include <util/expr-bison.h>\n#include <util/expr-flex.h>\n#include \"util/hashmap.h\"\n#include \"util/header.h\"\n#include \"util/pmu.h\"\n#include \"smt.h\"\n#include \"tsc.h\"\n#include <api/fs/fs.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/zalloc.h>\n#include <ctype.h>\n#include <math.h>\n#include \"pmu.h\"\n\n#ifdef PARSER_DEBUG\nextern int expr_debug;\n#endif\n\nstruct expr_id_data {\n\tunion {\n\t\tstruct {\n\t\t\tdouble val;\n\t\t\tint source_count;\n\t\t} val;\n\t\tstruct {\n\t\t\tdouble val;\n\t\t\tconst char *metric_name;\n\t\t\tconst char *metric_expr;\n\t\t} ref;\n\t};\n\n\tenum {\n\t\t \n\t\tEXPR_ID_DATA__VALUE,\n\t\t \n\t\tEXPR_ID_DATA__REF,\n\t\t \n\t\tEXPR_ID_DATA__REF_VALUE,\n\t} kind;\n};\n\nstatic size_t key_hash(long key, void *ctx __maybe_unused)\n{\n\tconst char *str = (const char *)key;\n\tsize_t hash = 0;\n\n\twhile (*str != '\\0') {\n\t\thash *= 31;\n\t\thash += *str;\n\t\tstr++;\n\t}\n\treturn hash;\n}\n\nstatic bool key_equal(long key1, long key2, void *ctx __maybe_unused)\n{\n\treturn !strcmp((const char *)key1, (const char *)key2);\n}\n\nstruct hashmap *ids__new(void)\n{\n\tstruct hashmap *hash;\n\n\thash = hashmap__new(key_hash, key_equal, NULL);\n\tif (IS_ERR(hash))\n\t\treturn NULL;\n\treturn hash;\n}\n\nvoid ids__free(struct hashmap *ids)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\n\tif (ids == NULL)\n\t\treturn;\n\n\thashmap__for_each_entry(ids, cur, bkt) {\n\t\tzfree(&cur->pkey);\n\t\tzfree(&cur->pvalue);\n\t}\n\n\thashmap__free(ids);\n}\n\nint ids__insert(struct hashmap *ids, const char *id)\n{\n\tstruct expr_id_data *data_ptr = NULL, *old_data = NULL;\n\tchar *old_key = NULL;\n\tint ret;\n\n\tret = hashmap__set(ids, id, data_ptr, &old_key, &old_data);\n\tif (ret)\n\t\tfree(data_ptr);\n\tfree(old_key);\n\tfree(old_data);\n\treturn ret;\n}\n\nstruct hashmap *ids__union(struct hashmap *ids1, struct hashmap *ids2)\n{\n\tsize_t bkt;\n\tstruct hashmap_entry *cur;\n\tint ret;\n\tstruct expr_id_data *old_data = NULL;\n\tchar *old_key = NULL;\n\n\tif (!ids1)\n\t\treturn ids2;\n\n\tif (!ids2)\n\t\treturn ids1;\n\n\tif (hashmap__size(ids1) <  hashmap__size(ids2)) {\n\t\tstruct hashmap *tmp = ids1;\n\n\t\tids1 = ids2;\n\t\tids2 = tmp;\n\t}\n\thashmap__for_each_entry(ids2, cur, bkt) {\n\t\tret = hashmap__set(ids1, cur->key, cur->value, &old_key, &old_data);\n\t\tfree(old_key);\n\t\tfree(old_data);\n\n\t\tif (ret) {\n\t\t\thashmap__free(ids1);\n\t\t\thashmap__free(ids2);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\thashmap__free(ids2);\n\treturn ids1;\n}\n\n \nint expr__add_id(struct expr_parse_ctx *ctx, const char *id)\n{\n\treturn ids__insert(ctx->ids, id);\n}\n\n \nint expr__add_id_val(struct expr_parse_ctx *ctx, const char *id, double val)\n{\n\treturn expr__add_id_val_source_count(ctx, id, val,  1);\n}\n\n \nint expr__add_id_val_source_count(struct expr_parse_ctx *ctx, const char *id,\n\t\t\t\t  double val, int source_count)\n{\n\tstruct expr_id_data *data_ptr = NULL, *old_data = NULL;\n\tchar *old_key = NULL;\n\tint ret;\n\n\tdata_ptr = malloc(sizeof(*data_ptr));\n\tif (!data_ptr)\n\t\treturn -ENOMEM;\n\tdata_ptr->val.val = val;\n\tdata_ptr->val.source_count = source_count;\n\tdata_ptr->kind = EXPR_ID_DATA__VALUE;\n\n\tret = hashmap__set(ctx->ids, id, data_ptr, &old_key, &old_data);\n\tif (ret)\n\t\tfree(data_ptr);\n\tfree(old_key);\n\tfree(old_data);\n\treturn ret;\n}\n\nint expr__add_ref(struct expr_parse_ctx *ctx, struct metric_ref *ref)\n{\n\tstruct expr_id_data *data_ptr = NULL, *old_data = NULL;\n\tchar *old_key = NULL;\n\tchar *name;\n\tint ret;\n\n\tdata_ptr = zalloc(sizeof(*data_ptr));\n\tif (!data_ptr)\n\t\treturn -ENOMEM;\n\n\tname = strdup(ref->metric_name);\n\tif (!name) {\n\t\tfree(data_ptr);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdata_ptr->ref.metric_name = ref->metric_name;\n\tdata_ptr->ref.metric_expr = ref->metric_expr;\n\tdata_ptr->kind = EXPR_ID_DATA__REF;\n\n\tret = hashmap__set(ctx->ids, name, data_ptr, &old_key, &old_data);\n\tif (ret)\n\t\tfree(data_ptr);\n\n\tpr_debug2(\"adding ref metric %s: %s\\n\",\n\t\t  ref->metric_name, ref->metric_expr);\n\n\tfree(old_key);\n\tfree(old_data);\n\treturn ret;\n}\n\nint expr__get_id(struct expr_parse_ctx *ctx, const char *id,\n\t\t struct expr_id_data **data)\n{\n\treturn hashmap__find(ctx->ids, id, data) ? 0 : -1;\n}\n\nbool expr__subset_of_ids(struct expr_parse_ctx *haystack,\n\t\t\t struct expr_parse_ctx *needles)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\tstruct expr_id_data *data;\n\n\thashmap__for_each_entry(needles->ids, cur, bkt) {\n\t\tif (expr__get_id(haystack, cur->pkey, &data))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nint expr__resolve_id(struct expr_parse_ctx *ctx, const char *id,\n\t\t     struct expr_id_data **datap)\n{\n\tstruct expr_id_data *data;\n\n\tif (expr__get_id(ctx, id, datap) || !*datap) {\n\t\tpr_debug(\"%s not found\\n\", id);\n\t\treturn -1;\n\t}\n\n\tdata = *datap;\n\n\tswitch (data->kind) {\n\tcase EXPR_ID_DATA__VALUE:\n\t\tpr_debug2(\"lookup(%s): val %f\\n\", id, data->val.val);\n\t\tbreak;\n\tcase EXPR_ID_DATA__REF:\n\t\tpr_debug2(\"lookup(%s): ref metric name %s\\n\", id,\n\t\t\tdata->ref.metric_name);\n\t\tpr_debug(\"processing metric: %s ENTRY\\n\", id);\n\t\tdata->kind = EXPR_ID_DATA__REF_VALUE;\n\t\tif (expr__parse(&data->ref.val, ctx, data->ref.metric_expr)) {\n\t\t\tpr_debug(\"%s failed to count\\n\", id);\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\"processing metric: %s EXIT: %f\\n\", id, data->ref.val);\n\t\tbreak;\n\tcase EXPR_ID_DATA__REF_VALUE:\n\t\tpr_debug2(\"lookup(%s): ref val %f metric name %s\\n\", id,\n\t\t\tdata->ref.val, data->ref.metric_name);\n\t\tbreak;\n\tdefault:\n\t\tassert(0);   \n\t}\n\n\treturn 0;\n}\n\nvoid expr__del_id(struct expr_parse_ctx *ctx, const char *id)\n{\n\tstruct expr_id_data *old_val = NULL;\n\tchar *old_key = NULL;\n\n\thashmap__delete(ctx->ids, id, &old_key, &old_val);\n\tfree(old_key);\n\tfree(old_val);\n}\n\nstruct expr_parse_ctx *expr__ctx_new(void)\n{\n\tstruct expr_parse_ctx *ctx;\n\n\tctx = malloc(sizeof(struct expr_parse_ctx));\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx->ids = hashmap__new(key_hash, key_equal, NULL);\n\tif (IS_ERR(ctx->ids)) {\n\t\tfree(ctx);\n\t\treturn NULL;\n\t}\n\tctx->sctx.user_requested_cpu_list = NULL;\n\tctx->sctx.runtime = 0;\n\tctx->sctx.system_wide = false;\n\n\treturn ctx;\n}\n\nvoid expr__ctx_clear(struct expr_parse_ctx *ctx)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\n\thashmap__for_each_entry(ctx->ids, cur, bkt) {\n\t\tzfree(&cur->pkey);\n\t\tzfree(&cur->pvalue);\n\t}\n\thashmap__clear(ctx->ids);\n}\n\nvoid expr__ctx_free(struct expr_parse_ctx *ctx)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\n\tif (!ctx)\n\t\treturn;\n\n\tzfree(&ctx->sctx.user_requested_cpu_list);\n\thashmap__for_each_entry(ctx->ids, cur, bkt) {\n\t\tzfree(&cur->pkey);\n\t\tzfree(&cur->pvalue);\n\t}\n\thashmap__free(ctx->ids);\n\tfree(ctx);\n}\n\nstatic int\n__expr__parse(double *val, struct expr_parse_ctx *ctx, const char *expr,\n\t      bool compute_ids)\n{\n\tYY_BUFFER_STATE buffer;\n\tvoid *scanner;\n\tint ret;\n\n\tpr_debug2(\"parsing metric: %s\\n\", expr);\n\n\tret = expr_lex_init_extra(&ctx->sctx, &scanner);\n\tif (ret)\n\t\treturn ret;\n\n\tbuffer = expr__scan_string(expr, scanner);\n\n#ifdef PARSER_DEBUG\n\texpr_debug = 1;\n\texpr_set_debug(1, scanner);\n#endif\n\n\tret = expr_parse(val, ctx, compute_ids, scanner);\n\n\texpr__flush_buffer(buffer, scanner);\n\texpr__delete_buffer(buffer, scanner);\n\texpr_lex_destroy(scanner);\n\treturn ret;\n}\n\nint expr__parse(double *final_val, struct expr_parse_ctx *ctx,\n\t\tconst char *expr)\n{\n\treturn __expr__parse(final_val, ctx, expr,  false) ? -1 : 0;\n}\n\nint expr__find_ids(const char *expr, const char *one,\n\t\t   struct expr_parse_ctx *ctx)\n{\n\tint ret = __expr__parse(NULL, ctx, expr,  true);\n\n\tif (one)\n\t\texpr__del_id(ctx, one);\n\n\treturn ret;\n}\n\ndouble expr_id_data__value(const struct expr_id_data *data)\n{\n\tif (data->kind == EXPR_ID_DATA__VALUE)\n\t\treturn data->val.val;\n\tassert(data->kind == EXPR_ID_DATA__REF_VALUE);\n\treturn data->ref.val;\n}\n\ndouble expr_id_data__source_count(const struct expr_id_data *data)\n{\n\tassert(data->kind == EXPR_ID_DATA__VALUE);\n\treturn data->val.source_count;\n}\n\n#if !defined(__i386__) && !defined(__x86_64__)\ndouble arch_get_tsc_freq(void)\n{\n\treturn 0.0;\n}\n#endif\n\nstatic double has_pmem(void)\n{\n\tstatic bool has_pmem, cached;\n\tconst char *sysfs = sysfs__mountpoint();\n\tchar path[PATH_MAX];\n\n\tif (!cached) {\n\t\tsnprintf(path, sizeof(path), \"%s/firmware/acpi/tables/NFIT\", sysfs);\n\t\thas_pmem = access(path, F_OK) == 0;\n\t\tcached = true;\n\t}\n\treturn has_pmem ? 1.0 : 0.0;\n}\n\ndouble expr__get_literal(const char *literal, const struct expr_scanner_ctx *ctx)\n{\n\tconst struct cpu_topology *topology;\n\tdouble result = NAN;\n\n\tif (!strcmp(\"#num_cpus\", literal)) {\n\t\tresult = cpu__max_present_cpu().cpu;\n\t\tgoto out;\n\t}\n\tif (!strcmp(\"#num_cpus_online\", literal)) {\n\t\tstruct perf_cpu_map *online = cpu_map__online();\n\n\t\tif (online)\n\t\t\tresult = perf_cpu_map__nr(online);\n\t\tgoto out;\n\t}\n\n\tif (!strcasecmp(\"#system_tsc_freq\", literal)) {\n\t\tresult = arch_get_tsc_freq();\n\t\tgoto out;\n\t}\n\n\t \n\tif (!strcasecmp(\"#smt_on\", literal)) {\n\t\tresult = smt_on() ? 1.0 : 0.0;\n\t\tgoto out;\n\t}\n\tif (!strcmp(\"#core_wide\", literal)) {\n\t\tresult = core_wide(ctx->system_wide, ctx->user_requested_cpu_list)\n\t\t\t? 1.0 : 0.0;\n\t\tgoto out;\n\t}\n\tif (!strcmp(\"#num_packages\", literal)) {\n\t\ttopology = online_topology();\n\t\tresult = topology->package_cpus_lists;\n\t\tgoto out;\n\t}\n\tif (!strcmp(\"#num_dies\", literal)) {\n\t\ttopology = online_topology();\n\t\tresult = topology->die_cpus_lists;\n\t\tgoto out;\n\t}\n\tif (!strcmp(\"#num_cores\", literal)) {\n\t\ttopology = online_topology();\n\t\tresult = topology->core_cpus_lists;\n\t\tgoto out;\n\t}\n\tif (!strcmp(\"#slots\", literal)) {\n\t\tresult = perf_pmu__cpu_slots_per_cycle();\n\t\tgoto out;\n\t}\n\tif (!strcmp(\"#has_pmem\", literal)) {\n\t\tresult = has_pmem();\n\t\tgoto out;\n\t}\n\n\tpr_err(\"Unrecognized literal '%s'\", literal);\nout:\n\tpr_debug2(\"literal: %s = %f\\n\", literal, result);\n\treturn result;\n}\n\n \ndouble expr__has_event(const struct expr_parse_ctx *ctx, bool compute_ids, const char *id)\n{\n\tstruct evlist *tmp;\n\tdouble ret;\n\n\tif (hashmap__find(ctx->ids, id,  NULL))\n\t\treturn 1.0;\n\n\tif (!compute_ids)\n\t\treturn 0.0;\n\n\ttmp = evlist__new();\n\tif (!tmp)\n\t\treturn NAN;\n\tret = parse_event(tmp, id) ? 0 : 1;\n\tevlist__delete(tmp);\n\treturn ret;\n}\n\ndouble expr__strcmp_cpuid_str(const struct expr_parse_ctx *ctx __maybe_unused,\n\t\t       bool compute_ids __maybe_unused, const char *test_id)\n{\n\tdouble ret;\n\tstruct perf_pmu *pmu = pmu__find_core_pmu();\n\tchar *cpuid = perf_pmu__getcpuid(pmu);\n\n\tif (!cpuid)\n\t\treturn NAN;\n\n\tret = !strcmp_cpuid_str(test_id, cpuid);\n\n\tfree(cpuid);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}