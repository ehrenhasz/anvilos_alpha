{
  "module_name": "kwork.h",
  "hash_id": "cceae0ee80d408b01cc64e0e419cb342fb8e6fbf10212fe482b09a4b1bb4d49b",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/kwork.h",
  "human_readable_source": "#ifndef PERF_UTIL_KWORK_H\n#define PERF_UTIL_KWORK_H\n\n#include \"util/tool.h\"\n#include \"util/time-utils.h\"\n\n#include <linux/bitmap.h>\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstruct perf_sample;\nstruct perf_session;\n\nenum kwork_class_type {\n\tKWORK_CLASS_IRQ,\n\tKWORK_CLASS_SOFTIRQ,\n\tKWORK_CLASS_WORKQUEUE,\n\tKWORK_CLASS_MAX,\n};\n\nenum kwork_report_type {\n\tKWORK_REPORT_RUNTIME,\n\tKWORK_REPORT_LATENCY,\n\tKWORK_REPORT_TIMEHIST,\n};\n\nenum kwork_trace_type {\n\tKWORK_TRACE_RAISE,\n\tKWORK_TRACE_ENTRY,\n\tKWORK_TRACE_EXIT,\n\tKWORK_TRACE_MAX,\n};\n\n \n\nstruct kwork_atom {\n\tstruct list_head list;\n\tu64 time;\n\tstruct kwork_atom *prev;\n\n\tvoid *page_addr;\n\tunsigned long bit_inpage;\n};\n\n#define NR_ATOM_PER_PAGE 128\nstruct kwork_atom_page {\n\tstruct list_head list;\n\tstruct kwork_atom atoms[NR_ATOM_PER_PAGE];\n\tDECLARE_BITMAP(bitmap, NR_ATOM_PER_PAGE);\n};\n\nstruct kwork_class;\nstruct kwork_work {\n\t \n\tstruct rb_node node;\n\tstruct kwork_class *class;\n\n\t \n\tu64 id;\n\tint cpu;\n\tchar *name;\n\n\t \n\tu64 nr_atoms;\n\tstruct list_head atom_list[KWORK_TRACE_MAX];\n\n\t \n\tu64 max_runtime;\n\tu64 max_runtime_start;\n\tu64 max_runtime_end;\n\tu64 total_runtime;\n\n\t \n\tu64 max_latency;\n\tu64 max_latency_start;\n\tu64 max_latency_end;\n\tu64 total_latency;\n};\n\nstruct kwork_class {\n\tstruct list_head list;\n\tconst char *name;\n\tenum kwork_class_type type;\n\n\tunsigned int nr_tracepoints;\n\tconst struct evsel_str_handler *tp_handlers;\n\n\tstruct rb_root_cached work_root;\n\n\tint (*class_init)(struct kwork_class *class,\n\t\t\t  struct perf_session *session);\n\n\tvoid (*work_init)(struct kwork_class *class,\n\t\t\t  struct kwork_work *work,\n\t\t\t  struct evsel *evsel,\n\t\t\t  struct perf_sample *sample,\n\t\t\t  struct machine *machine);\n\n\tvoid (*work_name)(struct kwork_work *work,\n\t\t\t  char *buf, int len);\n};\n\nstruct perf_kwork;\nstruct trace_kwork_handler {\n\tint (*raise_event)(struct perf_kwork *kwork,\n\t\t\t   struct kwork_class *class, struct evsel *evsel,\n\t\t\t   struct perf_sample *sample, struct machine *machine);\n\n\tint (*entry_event)(struct perf_kwork *kwork,\n\t\t\t   struct kwork_class *class, struct evsel *evsel,\n\t\t\t   struct perf_sample *sample, struct machine *machine);\n\n\tint (*exit_event)(struct perf_kwork *kwork,\n\t\t\t  struct kwork_class *class, struct evsel *evsel,\n\t\t\t  struct perf_sample *sample, struct machine *machine);\n};\n\nstruct perf_kwork {\n\t \n\tstruct perf_tool tool;\n\tstruct list_head class_list;\n\tstruct list_head atom_page_list;\n\tstruct list_head sort_list, cmp_id;\n\tstruct rb_root_cached sorted_work_root;\n\tconst struct trace_kwork_handler *tp_handler;\n\n\t \n\tconst char *profile_name;\n\n\tconst char *cpu_list;\n\tDECLARE_BITMAP(cpu_bitmap, MAX_NR_CPUS);\n\n\tconst char *time_str;\n\tstruct perf_time_interval ptime;\n\n\t \n\tbool force;\n\tconst char *event_list_str;\n\tenum kwork_report_type report;\n\n\t \n\tbool summary;\n\tconst char *sort_order;\n\tbool show_callchain;\n\tunsigned int max_stack;\n\tbool use_bpf;\n\n\t \n\tu64 timestart;\n\tu64 timeend;\n\n\tunsigned long nr_events;\n\tunsigned long nr_lost_chunks;\n\tunsigned long nr_lost_events;\n\n\tu64 all_runtime;\n\tu64 all_count;\n\tu64 nr_skipped_events[KWORK_TRACE_MAX + 1];\n};\n\nstruct kwork_work *perf_kwork_add_work(struct perf_kwork *kwork,\n\t\t\t\t       struct kwork_class *class,\n\t\t\t\t       struct kwork_work *key);\n\n#ifdef HAVE_BPF_SKEL\n\nint perf_kwork__trace_prepare_bpf(struct perf_kwork *kwork);\nint perf_kwork__report_read_bpf(struct perf_kwork *kwork);\nvoid perf_kwork__report_cleanup_bpf(void);\n\nvoid perf_kwork__trace_start(void);\nvoid perf_kwork__trace_finish(void);\n\n#else   \n\nstatic inline int\nperf_kwork__trace_prepare_bpf(struct perf_kwork *kwork __maybe_unused)\n{\n\treturn -1;\n}\n\nstatic inline int\nperf_kwork__report_read_bpf(struct perf_kwork *kwork __maybe_unused)\n{\n\treturn -1;\n}\n\nstatic inline void perf_kwork__report_cleanup_bpf(void) {}\n\nstatic inline void perf_kwork__trace_start(void) {}\nstatic inline void perf_kwork__trace_finish(void) {}\n\n#endif   \n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}