{
  "module_name": "block-info.c",
  "hash_id": "87c7ea14b6ad074effa452ef66fa1e4585d261511c00727579122975c6e3aa48",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/block-info.c",
  "human_readable_source": "\n#include <stdlib.h>\n#include <string.h>\n#include <linux/zalloc.h>\n#include \"block-info.h\"\n#include \"sort.h\"\n#include \"annotate.h\"\n#include \"symbol.h\"\n#include \"dso.h\"\n#include \"map.h\"\n#include \"srcline.h\"\n#include \"evlist.h\"\n#include \"hist.h\"\n#include \"ui/browsers/hists.h\"\n\nstatic struct block_header_column {\n\tconst char *name;\n\tint width;\n} block_columns[PERF_HPP_REPORT__BLOCK_MAX_INDEX] = {\n\t[PERF_HPP_REPORT__BLOCK_TOTAL_CYCLES_PCT] = {\n\t\t.name = \"Sampled Cycles%\",\n\t\t.width = 15,\n\t},\n\t[PERF_HPP_REPORT__BLOCK_LBR_CYCLES] = {\n\t\t.name = \"Sampled Cycles\",\n\t\t.width = 14,\n\t},\n\t[PERF_HPP_REPORT__BLOCK_CYCLES_PCT] = {\n\t\t.name = \"Avg Cycles%\",\n\t\t.width = 11,\n\t},\n\t[PERF_HPP_REPORT__BLOCK_AVG_CYCLES] = {\n\t\t.name = \"Avg Cycles\",\n\t\t.width = 10,\n\t},\n\t[PERF_HPP_REPORT__BLOCK_RANGE] = {\n\t\t.name = \"[Program Block Range]\",\n\t\t.width = 70,\n\t},\n\t[PERF_HPP_REPORT__BLOCK_DSO] = {\n\t\t.name = \"Shared Object\",\n\t\t.width = 20,\n\t}\n};\n\nstruct block_info *block_info__get(struct block_info *bi)\n{\n\tif (bi)\n\t\trefcount_inc(&bi->refcnt);\n\treturn bi;\n}\n\nvoid block_info__put(struct block_info *bi)\n{\n\tif (bi && refcount_dec_and_test(&bi->refcnt))\n\t\tfree(bi);\n}\n\nstruct block_info *block_info__new(void)\n{\n\tstruct block_info *bi = zalloc(sizeof(*bi));\n\n\tif (bi)\n\t\trefcount_set(&bi->refcnt, 1);\n\treturn bi;\n}\n\nint64_t __block_info__cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct block_info *bi_l = left->block_info;\n\tstruct block_info *bi_r = right->block_info;\n\tint cmp;\n\n\tif (!bi_l->sym || !bi_r->sym) {\n\t\tif (!bi_l->sym && !bi_r->sym)\n\t\t\treturn -1;\n\t\telse if (!bi_l->sym)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\tcmp = strcmp(bi_l->sym->name, bi_r->sym->name);\n\tif (cmp)\n\t\treturn cmp;\n\n\tif (bi_l->start != bi_r->start)\n\t\treturn (int64_t)(bi_r->start - bi_l->start);\n\n\treturn (int64_t)(bi_r->end - bi_l->end);\n}\n\nint64_t block_info__cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\tstruct hist_entry *left, struct hist_entry *right)\n{\n\treturn __block_info__cmp(left, right);\n}\n\nstatic void init_block_info(struct block_info *bi, struct symbol *sym,\n\t\t\t    struct cyc_hist *ch, int offset,\n\t\t\t    u64 total_cycles)\n{\n\tbi->sym = sym;\n\tbi->start = ch->start;\n\tbi->end = offset;\n\tbi->cycles = ch->cycles;\n\tbi->cycles_aggr = ch->cycles_aggr;\n\tbi->num = ch->num;\n\tbi->num_aggr = ch->num_aggr;\n\tbi->total_cycles = total_cycles;\n\n\tmemcpy(bi->cycles_spark, ch->cycles_spark,\n\t       NUM_SPARKS * sizeof(u64));\n}\n\nint block_info__process_sym(struct hist_entry *he, struct block_hist *bh,\n\t\t\t    u64 *block_cycles_aggr, u64 total_cycles)\n{\n\tstruct annotation *notes;\n\tstruct cyc_hist *ch;\n\tstatic struct addr_location al;\n\tu64 cycles = 0;\n\n\tif (!he->ms.map || !he->ms.sym)\n\t\treturn 0;\n\n\tmemset(&al, 0, sizeof(al));\n\tal.map = he->ms.map;\n\tal.sym = he->ms.sym;\n\n\tnotes = symbol__annotation(he->ms.sym);\n\tif (!notes || !notes->src || !notes->src->cycles_hist)\n\t\treturn 0;\n\tch = notes->src->cycles_hist;\n\tfor (unsigned int i = 0; i < symbol__size(he->ms.sym); i++) {\n\t\tif (ch[i].num_aggr) {\n\t\t\tstruct block_info *bi;\n\t\t\tstruct hist_entry *he_block;\n\n\t\t\tbi = block_info__new();\n\t\t\tif (!bi)\n\t\t\t\treturn -1;\n\n\t\t\tinit_block_info(bi, he->ms.sym, &ch[i], i,\n\t\t\t\t\ttotal_cycles);\n\t\t\tcycles += bi->cycles_aggr / bi->num_aggr;\n\n\t\t\the_block = hists__add_entry_block(&bh->block_hists,\n\t\t\t\t\t\t\t  &al, bi);\n\t\t\tif (!he_block) {\n\t\t\t\tblock_info__put(bi);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (block_cycles_aggr)\n\t\t*block_cycles_aggr += cycles;\n\n\treturn 0;\n}\n\nstatic int block_column_header(struct perf_hpp_fmt *fmt,\n\t\t\t       struct perf_hpp *hpp,\n\t\t\t       struct hists *hists __maybe_unused,\n\t\t\t       int line __maybe_unused,\n\t\t\t       int *span __maybe_unused)\n{\n\tstruct block_fmt *block_fmt = container_of(fmt, struct block_fmt, fmt);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", block_fmt->width,\n\t\t\t block_fmt->header);\n}\n\nstatic int block_column_width(struct perf_hpp_fmt *fmt,\n\t\t\t      struct perf_hpp *hpp __maybe_unused,\n\t\t\t      struct hists *hists __maybe_unused)\n{\n\tstruct block_fmt *block_fmt = container_of(fmt, struct block_fmt, fmt);\n\n\treturn block_fmt->width;\n}\n\nstatic int color_pct(struct perf_hpp *hpp, int width, double pct)\n{\n#ifdef HAVE_SLANG_SUPPORT\n\tif (use_browser) {\n\t\treturn __hpp__slsmg_color_printf(hpp, \"%*.2f%%\",\n\t\t\t\t\t\t width - 1, pct);\n\t}\n#endif\n\treturn hpp_color_scnprintf(hpp, \"%*.2f%%\", width - 1, pct);\n}\n\nstatic int block_total_cycles_pct_entry(struct perf_hpp_fmt *fmt,\n\t\t\t\t\tstruct perf_hpp *hpp,\n\t\t\t\t\tstruct hist_entry *he)\n{\n\tstruct block_fmt *block_fmt = container_of(fmt, struct block_fmt, fmt);\n\tstruct block_info *bi = he->block_info;\n\tdouble ratio = 0.0;\n\n\tif (block_fmt->total_cycles)\n\t\tratio = (double)bi->cycles_aggr / (double)block_fmt->total_cycles;\n\n\treturn color_pct(hpp, block_fmt->width, 100.0 * ratio);\n}\n\nstatic int64_t block_total_cycles_pct_sort(struct perf_hpp_fmt *fmt,\n\t\t\t\t\t   struct hist_entry *left,\n\t\t\t\t\t   struct hist_entry *right)\n{\n\tstruct block_fmt *block_fmt = container_of(fmt, struct block_fmt, fmt);\n\tstruct block_info *bi_l = left->block_info;\n\tstruct block_info *bi_r = right->block_info;\n\tdouble l, r;\n\n\tif (block_fmt->total_cycles) {\n\t\tl = ((double)bi_l->cycles_aggr /\n\t\t\t(double)block_fmt->total_cycles) * 100000.0;\n\t\tr = ((double)bi_r->cycles_aggr /\n\t\t\t(double)block_fmt->total_cycles) * 100000.0;\n\t\treturn (int64_t)l - (int64_t)r;\n\t}\n\n\treturn 0;\n}\n\nstatic void cycles_string(u64 cycles, char *buf, int size)\n{\n\tif (cycles >= 1000000)\n\t\tscnprintf(buf, size, \"%.1fM\", (double)cycles / 1000000.0);\n\telse if (cycles >= 1000)\n\t\tscnprintf(buf, size, \"%.1fK\", (double)cycles / 1000.0);\n\telse\n\t\tscnprintf(buf, size, \"%1d\", cycles);\n}\n\nstatic int block_cycles_lbr_entry(struct perf_hpp_fmt *fmt,\n\t\t\t\t  struct perf_hpp *hpp, struct hist_entry *he)\n{\n\tstruct block_fmt *block_fmt = container_of(fmt, struct block_fmt, fmt);\n\tstruct block_info *bi = he->block_info;\n\tchar cycles_buf[16];\n\n\tcycles_string(bi->cycles_aggr, cycles_buf, sizeof(cycles_buf));\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", block_fmt->width,\n\t\t\t cycles_buf);\n}\n\nstatic int block_cycles_pct_entry(struct perf_hpp_fmt *fmt,\n\t\t\t\t  struct perf_hpp *hpp, struct hist_entry *he)\n{\n\tstruct block_fmt *block_fmt = container_of(fmt, struct block_fmt, fmt);\n\tstruct block_info *bi = he->block_info;\n\tdouble ratio = 0.0;\n\tu64 avg;\n\n\tif (block_fmt->block_cycles && bi->num_aggr) {\n\t\tavg = bi->cycles_aggr / bi->num_aggr;\n\t\tratio = (double)avg / (double)block_fmt->block_cycles;\n\t}\n\n\treturn color_pct(hpp, block_fmt->width, 100.0 * ratio);\n}\n\nstatic int block_avg_cycles_entry(struct perf_hpp_fmt *fmt,\n\t\t\t\t  struct perf_hpp *hpp,\n\t\t\t\t  struct hist_entry *he)\n{\n\tstruct block_fmt *block_fmt = container_of(fmt, struct block_fmt, fmt);\n\tstruct block_info *bi = he->block_info;\n\tchar cycles_buf[16];\n\n\tcycles_string(bi->cycles_aggr / bi->num_aggr, cycles_buf,\n\t\t      sizeof(cycles_buf));\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", block_fmt->width,\n\t\t\t cycles_buf);\n}\n\nstatic int block_range_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t     struct hist_entry *he)\n{\n\tstruct block_fmt *block_fmt = container_of(fmt, struct block_fmt, fmt);\n\tstruct block_info *bi = he->block_info;\n\tchar buf[128];\n\tchar *start_line, *end_line;\n\n\tsymbol_conf.disable_add2line_warn = true;\n\n\tstart_line = map__srcline(he->ms.map, bi->sym->start + bi->start,\n\t\t\t\t  he->ms.sym);\n\n\tend_line = map__srcline(he->ms.map, bi->sym->start + bi->end,\n\t\t\t\the->ms.sym);\n\n\tif (start_line != SRCLINE_UNKNOWN &&\n\t    end_line != SRCLINE_UNKNOWN) {\n\t\tscnprintf(buf, sizeof(buf), \"[%s -> %s]\",\n\t\t\t  start_line, end_line);\n\t} else {\n\t\tscnprintf(buf, sizeof(buf), \"[%7lx -> %7lx]\",\n\t\t\t  bi->start, bi->end);\n\t}\n\n\tzfree_srcline(&start_line);\n\tzfree_srcline(&end_line);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", block_fmt->width, buf);\n}\n\nstatic int block_dso_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t   struct hist_entry *he)\n{\n\tstruct block_fmt *block_fmt = container_of(fmt, struct block_fmt, fmt);\n\tstruct map *map = he->ms.map;\n\n\tif (map && map__dso(map)) {\n\t\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", block_fmt->width,\n\t\t\t\t map__dso(map)->short_name);\n\t}\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", block_fmt->width,\n\t\t\t \"[unknown]\");\n}\n\nstatic void init_block_header(struct block_fmt *block_fmt)\n{\n\tstruct perf_hpp_fmt *fmt = &block_fmt->fmt;\n\n\tBUG_ON(block_fmt->idx >= PERF_HPP_REPORT__BLOCK_MAX_INDEX);\n\n\tblock_fmt->header = block_columns[block_fmt->idx].name;\n\tblock_fmt->width = block_columns[block_fmt->idx].width;\n\n\tfmt->header = block_column_header;\n\tfmt->width = block_column_width;\n}\n\nstatic void hpp_register(struct block_fmt *block_fmt, int idx,\n\t\t\t struct perf_hpp_list *hpp_list)\n{\n\tstruct perf_hpp_fmt *fmt = &block_fmt->fmt;\n\n\tblock_fmt->idx = idx;\n\tINIT_LIST_HEAD(&fmt->list);\n\tINIT_LIST_HEAD(&fmt->sort_list);\n\n\tswitch (idx) {\n\tcase PERF_HPP_REPORT__BLOCK_TOTAL_CYCLES_PCT:\n\t\tfmt->color = block_total_cycles_pct_entry;\n\t\tfmt->cmp = block_info__cmp;\n\t\tfmt->sort = block_total_cycles_pct_sort;\n\t\tbreak;\n\tcase PERF_HPP_REPORT__BLOCK_LBR_CYCLES:\n\t\tfmt->entry = block_cycles_lbr_entry;\n\t\tbreak;\n\tcase PERF_HPP_REPORT__BLOCK_CYCLES_PCT:\n\t\tfmt->color = block_cycles_pct_entry;\n\t\tbreak;\n\tcase PERF_HPP_REPORT__BLOCK_AVG_CYCLES:\n\t\tfmt->entry = block_avg_cycles_entry;\n\t\tbreak;\n\tcase PERF_HPP_REPORT__BLOCK_RANGE:\n\t\tfmt->entry = block_range_entry;\n\t\tbreak;\n\tcase PERF_HPP_REPORT__BLOCK_DSO:\n\t\tfmt->entry = block_dso_entry;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tinit_block_header(block_fmt);\n\tperf_hpp_list__column_register(hpp_list, fmt);\n}\n\nstatic void register_block_columns(struct perf_hpp_list *hpp_list,\n\t\t\t\t   struct block_fmt *block_fmts,\n\t\t\t\t   int *block_hpps, int nr_hpps)\n{\n\tfor (int i = 0; i < nr_hpps; i++)\n\t\thpp_register(&block_fmts[i], block_hpps[i], hpp_list);\n}\n\nstatic void init_block_hist(struct block_hist *bh, struct block_fmt *block_fmts,\n\t\t\t    int *block_hpps, int nr_hpps)\n{\n\t__hists__init(&bh->block_hists, &bh->block_list);\n\tperf_hpp_list__init(&bh->block_list);\n\tbh->block_list.nr_header_lines = 1;\n\n\tregister_block_columns(&bh->block_list, block_fmts,\n\t\t\t       block_hpps, nr_hpps);\n\n\t \n\tperf_hpp_list__register_sort_field(&bh->block_list, &block_fmts[0].fmt);\n}\n\nstatic int process_block_report(struct hists *hists,\n\t\t\t\tstruct block_report *block_report,\n\t\t\t\tu64 total_cycles, int *block_hpps,\n\t\t\t\tint nr_hpps)\n{\n\tstruct rb_node *next = rb_first_cached(&hists->entries);\n\tstruct block_hist *bh = &block_report->hist;\n\tstruct hist_entry *he;\n\n\tif (nr_hpps > PERF_HPP_REPORT__BLOCK_MAX_INDEX)\n\t\treturn -1;\n\n\tblock_report->nr_fmts = nr_hpps;\n\tinit_block_hist(bh, block_report->fmts, block_hpps, nr_hpps);\n\n\twhile (next) {\n\t\the = rb_entry(next, struct hist_entry, rb_node);\n\t\tblock_info__process_sym(he, bh, &block_report->cycles,\n\t\t\t\t\ttotal_cycles);\n\t\tnext = rb_next(&he->rb_node);\n\t}\n\n\tfor (int i = 0; i < nr_hpps; i++) {\n\t\tblock_report->fmts[i].total_cycles = total_cycles;\n\t\tblock_report->fmts[i].block_cycles = block_report->cycles;\n\t}\n\n\thists__output_resort(&bh->block_hists, NULL);\n\treturn 0;\n}\n\nstruct block_report *block_info__create_report(struct evlist *evlist,\n\t\t\t\t\t       u64 total_cycles,\n\t\t\t\t\t       int *block_hpps, int nr_hpps,\n\t\t\t\t\t       int *nr_reps)\n{\n\tstruct block_report *block_reports;\n\tint nr_hists = evlist->core.nr_entries, i = 0;\n\tstruct evsel *pos;\n\n\tblock_reports = calloc(nr_hists, sizeof(struct block_report));\n\tif (!block_reports)\n\t\treturn NULL;\n\n\tevlist__for_each_entry(evlist, pos) {\n\t\tstruct hists *hists = evsel__hists(pos);\n\n\t\tprocess_block_report(hists, &block_reports[i], total_cycles,\n\t\t\t\t     block_hpps, nr_hpps);\n\t\ti++;\n\t}\n\n\t*nr_reps = nr_hists;\n\treturn block_reports;\n}\n\nvoid block_info__free_report(struct block_report *reps, int nr_reps)\n{\n\tfor (int i = 0; i < nr_reps; i++)\n\t\thists__delete_entries(&reps[i].hist.block_hists);\n\n\tfree(reps);\n}\n\nint report__browse_block_hists(struct block_hist *bh, float min_percent,\n\t\t\t       struct evsel *evsel, struct perf_env *env,\n\t\t\t       struct annotation_options *annotation_opts)\n{\n\tint ret;\n\n\tswitch (use_browser) {\n\tcase 0:\n\t\tsymbol_conf.report_individual_block = true;\n\t\thists__fprintf(&bh->block_hists, true, 0, 0, min_percent,\n\t\t\t       stdout, true);\n\t\treturn 0;\n\tcase 1:\n\t\tsymbol_conf.report_individual_block = true;\n\t\tret = block_hists_tui_browse(bh, evsel, min_percent,\n\t\t\t\t\t     env, annotation_opts);\n\t\treturn ret;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nfloat block_info__total_cycles_percent(struct hist_entry *he)\n{\n\tstruct block_info *bi = he->block_info;\n\n\tif (bi->total_cycles)\n\t\treturn bi->cycles * 100.0 / bi->total_cycles;\n\n\treturn 0.0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}