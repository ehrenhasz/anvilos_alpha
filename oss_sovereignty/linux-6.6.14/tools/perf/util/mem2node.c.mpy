{
  "module_name": "mem2node.c",
  "hash_id": "5e53b9deed3c8776fb84b255826a83f9687ac7125c833203229cb9a6ee69627f",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/mem2node.c",
  "human_readable_source": "#include <errno.h>\n#include <inttypes.h>\n#include <asm/bug.h>\n#include <linux/bitmap.h>\n#include <linux/kernel.h>\n#include <linux/zalloc.h>\n#include \"debug.h\"\n#include \"env.h\"\n#include \"mem2node.h\"\n\nstruct phys_entry {\n\tstruct rb_node\trb_node;\n\tu64\tstart;\n\tu64\tend;\n\tu64\tnode;\n};\n\nstatic void phys_entry__insert(struct phys_entry *entry, struct rb_root *root)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct phys_entry *e;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\te = rb_entry(parent, struct phys_entry, rb_node);\n\n\t\tif (entry->start < e->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&entry->rb_node, parent, p);\n\trb_insert_color(&entry->rb_node, root);\n}\n\nstatic void\nphys_entry__init(struct phys_entry *entry, u64 start, u64 bsize, u64 node)\n{\n\tentry->start = start;\n\tentry->end   = start + bsize;\n\tentry->node  = node;\n\tRB_CLEAR_NODE(&entry->rb_node);\n}\n\nint mem2node__init(struct mem2node *map, struct perf_env *env)\n{\n\tstruct memory_node *n, *nodes = &env->memory_nodes[0];\n\tstruct phys_entry *entries, *tmp_entries;\n\tu64 bsize = env->memory_bsize;\n\tint i, j = 0, max = 0;\n\n\tmemset(map, 0x0, sizeof(*map));\n\tmap->root = RB_ROOT;\n\n\tfor (i = 0; i < env->nr_memory_nodes; i++) {\n\t\tn = &nodes[i];\n\t\tmax += bitmap_weight(n->set, n->size);\n\t}\n\n\tentries = zalloc(sizeof(*entries) * max);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < env->nr_memory_nodes; i++) {\n\t\tu64 bit;\n\n\t\tn = &nodes[i];\n\n\t\tfor (bit = 0; bit < n->size; bit++) {\n\t\t\tu64 start;\n\n\t\t\tif (!test_bit(bit, n->set))\n\t\t\t\tcontinue;\n\n\t\t\tstart = bit * bsize;\n\n\t\t\t \n\t\t\tif (j > 0) {\n\t\t\t\tstruct phys_entry *prev = &entries[j - 1];\n\n\t\t\t\tif ((prev->end == start) &&\n\t\t\t\t    (prev->node == n->node)) {\n\t\t\t\t\tprev->end += bsize;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tphys_entry__init(&entries[j++], start, bsize, n->node);\n\t\t}\n\t}\n\n\t \n\ttmp_entries = realloc(entries, sizeof(*entries) * j);\n\tif (tmp_entries ||\n\t    WARN_ONCE(j == 0, \"No memory nodes, is CONFIG_MEMORY_HOTPLUG enabled?\\n\"))\n\t\tentries = tmp_entries;\n\n\tfor (i = 0; i < j; i++) {\n\t\tpr_debug(\"mem2node %03\" PRIu64 \" [0x%016\" PRIx64 \"-0x%016\" PRIx64 \"]\\n\",\n\t\t\t entries[i].node, entries[i].start, entries[i].end);\n\n\t\tphys_entry__insert(&entries[i], &map->root);\n\t}\n\n\tmap->entries = entries;\n\treturn 0;\n}\n\nvoid mem2node__exit(struct mem2node *map)\n{\n\tzfree(&map->entries);\n}\n\nint mem2node__node(struct mem2node *map, u64 addr)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct phys_entry *entry;\n\n\tp = &map->root.rb_node;\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct phys_entry, rb_node);\n\t\tif (addr < entry->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (addr >= entry->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tentry = NULL;\nout:\n\treturn entry ? (int) entry->node : -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}