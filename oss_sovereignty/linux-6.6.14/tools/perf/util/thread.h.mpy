{
  "module_name": "thread.h",
  "hash_id": "b5c4fb4182b07b6914c66dba95b6dabf282ef57c1b627c0d02ed0942c8c9d6ad",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/thread.h",
  "human_readable_source": " \n#ifndef __PERF_THREAD_H\n#define __PERF_THREAD_H\n\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include \"srccode.h\"\n#include \"symbol_conf.h\"\n#include <strlist.h>\n#include <intlist.h>\n#include \"rwsem.h\"\n#include \"event.h\"\n#include \"callchain.h\"\n#include <internal/rc_check.h>\n\nstruct addr_location;\nstruct map;\nstruct perf_record_namespaces;\nstruct thread_stack;\nstruct unwind_libunwind_ops;\n\nstruct lbr_stitch {\n\tstruct list_head\t\tlists;\n\tstruct list_head\t\tfree_lists;\n\tstruct perf_sample\t\tprev_sample;\n\tstruct callchain_cursor_node\t*prev_lbr_cursor;\n};\n\nstruct thread_rb_node {\n\tstruct rb_node rb_node;\n\tstruct thread *thread;\n};\n\nDECLARE_RC_STRUCT(thread) {\n\tstruct maps\t\t*maps;\n\tpid_t\t\t\tpid_;  \n\tpid_t\t\t\ttid;\n\tpid_t\t\t\tppid;\n\tint\t\t\tcpu;\n\tint\t\t\tguest_cpu;  \n\trefcount_t\t\trefcnt;\n\tbool\t\t\tcomm_set;\n\tint\t\t\tcomm_len;\n\tstruct list_head\tnamespaces_list;\n\tstruct rw_semaphore\tnamespaces_lock;\n\tstruct list_head\tcomm_list;\n\tstruct rw_semaphore\tcomm_lock;\n\tu64\t\t\tdb_id;\n\n\tvoid\t\t\t*priv;\n\tstruct thread_stack\t*ts;\n\tstruct nsinfo\t\t*nsinfo;\n\tstruct srccode_state\tsrccode_state;\n\tbool\t\t\tfilter;\n\tint\t\t\tfilter_entry_depth;\n\n\t \n\tbool\t\t\tlbr_stitch_enable;\n\tstruct lbr_stitch\t*lbr_stitch;\n};\n\nstruct machine;\nstruct namespaces;\nstruct comm;\n\nstruct thread *thread__new(pid_t pid, pid_t tid);\nint thread__init_maps(struct thread *thread, struct machine *machine);\nvoid thread__delete(struct thread *thread);\n\nvoid thread__set_priv_destructor(void (*destructor)(void *priv));\n\nstruct thread *thread__get(struct thread *thread);\nvoid thread__put(struct thread *thread);\n\nstatic inline void __thread__zput(struct thread **thread)\n{\n\tthread__put(*thread);\n\t*thread = NULL;\n}\n\n#define thread__zput(thread) __thread__zput(&thread)\n\nstruct namespaces *thread__namespaces(struct thread *thread);\nint thread__set_namespaces(struct thread *thread, u64 timestamp,\n\t\t\t   struct perf_record_namespaces *event);\n\nint __thread__set_comm(struct thread *thread, const char *comm, u64 timestamp,\n\t\t       bool exec);\nstatic inline int thread__set_comm(struct thread *thread, const char *comm,\n\t\t\t\t   u64 timestamp)\n{\n\treturn __thread__set_comm(thread, comm, timestamp, false);\n}\n\nint thread__set_comm_from_proc(struct thread *thread);\n\nint thread__comm_len(struct thread *thread);\nstruct comm *thread__comm(struct thread *thread);\nstruct comm *thread__exec_comm(struct thread *thread);\nconst char *thread__comm_str(struct thread *thread);\nint thread__insert_map(struct thread *thread, struct map *map);\nint thread__fork(struct thread *thread, struct thread *parent, u64 timestamp, bool do_maps_clone);\nsize_t thread__fprintf(struct thread *thread, FILE *fp);\n\nstruct thread *thread__main_thread(struct machine *machine, struct thread *thread);\n\nstruct map *thread__find_map(struct thread *thread, u8 cpumode, u64 addr,\n\t\t\t     struct addr_location *al);\nstruct map *thread__find_map_fb(struct thread *thread, u8 cpumode, u64 addr,\n\t\t\t\tstruct addr_location *al);\n\nstruct symbol *thread__find_symbol(struct thread *thread, u8 cpumode,\n\t\t\t\t   u64 addr, struct addr_location *al);\nstruct symbol *thread__find_symbol_fb(struct thread *thread, u8 cpumode,\n\t\t\t\t      u64 addr, struct addr_location *al);\n\nvoid thread__find_cpumode_addr_location(struct thread *thread, u64 addr,\n\t\t\t\t\tstruct addr_location *al);\n\nint thread__memcpy(struct thread *thread, struct machine *machine,\n\t\t   void *buf, u64 ip, int len, bool *is64bit);\n\nstatic inline struct maps *thread__maps(struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->maps;\n}\n\nstatic inline void thread__set_maps(struct thread *thread, struct maps *maps)\n{\n\tRC_CHK_ACCESS(thread)->maps = maps;\n}\n\nstatic inline pid_t thread__pid(const struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->pid_;\n}\n\nstatic inline void thread__set_pid(struct thread *thread, pid_t pid_)\n{\n\tRC_CHK_ACCESS(thread)->pid_ = pid_;\n}\n\nstatic inline pid_t thread__tid(const struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->tid;\n}\n\nstatic inline void thread__set_tid(struct thread *thread, pid_t tid)\n{\n\tRC_CHK_ACCESS(thread)->tid = tid;\n}\n\nstatic inline pid_t thread__ppid(const struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->ppid;\n}\n\nstatic inline void thread__set_ppid(struct thread *thread, pid_t ppid)\n{\n\tRC_CHK_ACCESS(thread)->ppid = ppid;\n}\n\nstatic inline int thread__cpu(const struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->cpu;\n}\n\nstatic inline void thread__set_cpu(struct thread *thread, int cpu)\n{\n\tRC_CHK_ACCESS(thread)->cpu = cpu;\n}\n\nstatic inline int thread__guest_cpu(const struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->guest_cpu;\n}\n\nstatic inline void thread__set_guest_cpu(struct thread *thread, int guest_cpu)\n{\n\tRC_CHK_ACCESS(thread)->guest_cpu = guest_cpu;\n}\n\nstatic inline refcount_t *thread__refcnt(struct thread *thread)\n{\n\treturn &RC_CHK_ACCESS(thread)->refcnt;\n}\n\nstatic inline bool thread__comm_set(const struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->comm_set;\n}\n\nstatic inline void thread__set_comm_set(struct thread *thread, bool set)\n{\n\tRC_CHK_ACCESS(thread)->comm_set = set;\n}\n\nstatic inline int thread__var_comm_len(const struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->comm_len;\n}\n\nstatic inline void thread__set_comm_len(struct thread *thread, int len)\n{\n\tRC_CHK_ACCESS(thread)->comm_len = len;\n}\n\nstatic inline struct list_head *thread__namespaces_list(struct thread *thread)\n{\n\treturn &RC_CHK_ACCESS(thread)->namespaces_list;\n}\n\nstatic inline int thread__namespaces_list_empty(const struct thread *thread)\n{\n\treturn list_empty(&RC_CHK_ACCESS(thread)->namespaces_list);\n}\n\nstatic inline struct rw_semaphore *thread__namespaces_lock(struct thread *thread)\n{\n\treturn &RC_CHK_ACCESS(thread)->namespaces_lock;\n}\n\nstatic inline struct list_head *thread__comm_list(struct thread *thread)\n{\n\treturn &RC_CHK_ACCESS(thread)->comm_list;\n}\n\nstatic inline struct rw_semaphore *thread__comm_lock(struct thread *thread)\n{\n\treturn &RC_CHK_ACCESS(thread)->comm_lock;\n}\n\nstatic inline u64 thread__db_id(const struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->db_id;\n}\n\nstatic inline void thread__set_db_id(struct thread *thread, u64 db_id)\n{\n\tRC_CHK_ACCESS(thread)->db_id = db_id;\n}\n\nstatic inline void *thread__priv(struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->priv;\n}\n\nstatic inline void thread__set_priv(struct thread *thread, void *p)\n{\n\tRC_CHK_ACCESS(thread)->priv = p;\n}\n\nstatic inline struct thread_stack *thread__ts(struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->ts;\n}\n\nstatic inline void thread__set_ts(struct thread *thread, struct thread_stack *ts)\n{\n\tRC_CHK_ACCESS(thread)->ts = ts;\n}\n\nstatic inline struct nsinfo *thread__nsinfo(struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->nsinfo;\n}\n\nstatic inline struct srccode_state *thread__srccode_state(struct thread *thread)\n{\n\treturn &RC_CHK_ACCESS(thread)->srccode_state;\n}\n\nstatic inline bool thread__filter(const struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->filter;\n}\n\nstatic inline void thread__set_filter(struct thread *thread, bool filter)\n{\n\tRC_CHK_ACCESS(thread)->filter = filter;\n}\n\nstatic inline int thread__filter_entry_depth(const struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->filter_entry_depth;\n}\n\nstatic inline void thread__set_filter_entry_depth(struct thread *thread, int depth)\n{\n\tRC_CHK_ACCESS(thread)->filter_entry_depth = depth;\n}\n\nstatic inline bool thread__lbr_stitch_enable(const struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->lbr_stitch_enable;\n}\n\nstatic inline void thread__set_lbr_stitch_enable(struct thread *thread, bool en)\n{\n\tRC_CHK_ACCESS(thread)->lbr_stitch_enable = en;\n}\n\nstatic inline struct lbr_stitch\t*thread__lbr_stitch(struct thread *thread)\n{\n\treturn RC_CHK_ACCESS(thread)->lbr_stitch;\n}\n\nstatic inline void thread__set_lbr_stitch(struct thread *thread, struct lbr_stitch *lbrs)\n{\n\tRC_CHK_ACCESS(thread)->lbr_stitch = lbrs;\n}\n\nstatic inline bool thread__is_filtered(struct thread *thread)\n{\n\tif (symbol_conf.comm_list &&\n\t    !strlist__has_entry(symbol_conf.comm_list, thread__comm_str(thread))) {\n\t\treturn true;\n\t}\n\n\tif (symbol_conf.pid_list &&\n\t    !intlist__has_entry(symbol_conf.pid_list, thread__pid(thread))) {\n\t\treturn true;\n\t}\n\n\tif (symbol_conf.tid_list &&\n\t    !intlist__has_entry(symbol_conf.tid_list, thread__tid(thread))) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid thread__free_stitch_list(struct thread *thread);\n\nvoid thread__resolve(struct thread *thread, struct addr_location *al,\n\t\t     struct perf_sample *sample);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}