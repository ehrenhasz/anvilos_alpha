{
  "module_name": "pfm.c",
  "hash_id": "c53d50303cc3d18d2d3beb055c3af5011d14e02ffeefa63a8aa1c822103b3698",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/pfm.c",
  "human_readable_source": "\n \n#include \"util/cpumap.h\"\n#include \"util/debug.h\"\n#include \"util/event.h\"\n#include \"util/evlist.h\"\n#include \"util/evsel.h\"\n#include \"util/parse-events.h\"\n#include \"util/pmus.h\"\n#include \"util/pfm.h\"\n#include \"util/strbuf.h\"\n#include \"util/thread_map.h\"\n\n#include <string.h>\n#include <linux/kernel.h>\n#include <perfmon/pfmlib_perf_event.h>\n\nstatic void libpfm_initialize(void)\n{\n\tint ret;\n\n\tret = pfm_initialize();\n\tif (ret != PFM_SUCCESS) {\n\t\tui__warning(\"libpfm failed to initialize: %s\\n\",\n\t\t\tpfm_strerror(ret));\n\t}\n}\n\nint parse_libpfm_events_option(const struct option *opt, const char *str,\n\t\t\tint unset __maybe_unused)\n{\n\tstruct evlist *evlist = *(struct evlist **)opt->value;\n\tstruct perf_event_attr attr;\n\tstruct perf_pmu *pmu;\n\tstruct evsel *evsel, *grp_leader = NULL;\n\tchar *p, *q, *p_orig;\n\tconst char *sep;\n\tint grp_evt = -1;\n\tint ret;\n\n\tlibpfm_initialize();\n\n\tp_orig = p = strdup(str);\n\tif (!p)\n\t\treturn -1;\n\t \n\tperf_pmus__scan(NULL);\n\n\tfor (q = p; strsep(&p, \",{}\"); q = p) {\n\t\tsep = p ? str + (p - p_orig - 1) : \"\";\n\t\tif (*sep == '{') {\n\t\t\tif (grp_evt > -1) {\n\t\t\t\tui__error(\n\t\t\t\t\t\"nested event groups not supported\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgrp_evt++;\n\t\t}\n\n\t\t \n\t\tif (*q == '\\0') {\n\t\t\tif (*sep == '}') {\n\t\t\t\tif (grp_evt < 0) {\n\t\t\t\t\tui__error(\"cannot close a non-existing event group\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tgrp_evt--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemset(&attr, 0, sizeof(attr));\n\t\tevent_attr_init(&attr);\n\n\t\tret = pfm_get_perf_event_encoding(q, PFM_PLM0|PFM_PLM3,\n\t\t\t\t\t\t&attr, NULL, NULL);\n\n\t\tif (ret != PFM_SUCCESS) {\n\t\t\tui__error(\"failed to parse event %s : %s\\n\", str,\n\t\t\t\t  pfm_strerror(ret));\n\t\t\tgoto error;\n\t\t}\n\n\t\tpmu = perf_pmus__find_by_type((unsigned int)attr.type);\n\t\tevsel = parse_events__add_event(evlist->core.nr_entries,\n\t\t\t\t\t\t&attr, q,  NULL,\n\t\t\t\t\t\tpmu);\n\t\tif (evsel == NULL)\n\t\t\tgoto error;\n\n\t\tevsel->is_libpfm_event = true;\n\n\t\tevlist__add(evlist, evsel);\n\n\t\tif (grp_evt == 0)\n\t\t\tgrp_leader = evsel;\n\n\t\tif (grp_evt > -1) {\n\t\t\tevsel__set_leader(evsel, grp_leader);\n\t\t\tgrp_leader->core.nr_members++;\n\t\t\tgrp_evt++;\n\t\t}\n\n\t\tif (*sep == '}') {\n\t\t\tif (grp_evt < 0) {\n\t\t\t\tui__error(\n\t\t\t\t   \"cannot close a non-existing event group\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgrp_leader = NULL;\n\t\t\tgrp_evt = -1;\n\t\t}\n\t}\n\tfree(p_orig);\n\treturn 0;\nerror:\n\tfree(p_orig);\n\treturn -1;\n}\n\nstatic bool is_libpfm_event_supported(const char *name, struct perf_cpu_map *cpus,\n\t\t\t\t      struct perf_thread_map *threads)\n{\n\tstruct perf_pmu *pmu;\n\tstruct evsel *evsel;\n\tstruct perf_event_attr attr = {};\n\tbool result = true;\n\tint ret;\n\n\tret = pfm_get_perf_event_encoding(name, PFM_PLM0|PFM_PLM3,\n\t\t\t\t\t  &attr, NULL, NULL);\n\tif (ret != PFM_SUCCESS)\n\t\treturn false;\n\n\tpmu = perf_pmus__find_by_type((unsigned int)attr.type);\n\tevsel = parse_events__add_event(0, &attr, name,  NULL, pmu);\n\tif (evsel == NULL)\n\t\treturn false;\n\n\tevsel->is_libpfm_event = true;\n\n\tif (evsel__open(evsel, cpus, threads) < 0)\n\t\tresult = false;\n\n\tevsel__close(evsel);\n\tevsel__delete(evsel);\n\n\treturn result;\n}\n\nstatic const char *srcs[PFM_ATTR_CTRL_MAX] = {\n\t[PFM_ATTR_CTRL_UNKNOWN] = \"???\",\n\t[PFM_ATTR_CTRL_PMU] = \"PMU\",\n\t[PFM_ATTR_CTRL_PERF_EVENT] = \"perf_event\",\n};\n\nstatic void\nprint_attr_flags(struct strbuf *buf, const pfm_event_attr_info_t *info)\n{\n\tif (info->is_dfl)\n\t\tstrbuf_addf(buf, \"[default] \");\n\n\tif (info->is_precise)\n\t\tstrbuf_addf(buf, \"[precise] \");\n}\n\nstatic void\nprint_libpfm_event(const struct print_callbacks *print_cb, void *print_state,\n\t\tconst pfm_pmu_info_t *pinfo, const pfm_event_info_t *info,\n\t\tstruct strbuf *buf)\n{\n\tint j, ret;\n\tchar topic[80], name[80];\n\tstruct perf_cpu_map *cpus = perf_cpu_map__empty_new(1);\n\tstruct perf_thread_map *threads = thread_map__new_by_tid(0);\n\n\tstrbuf_setlen(buf, 0);\n\tsnprintf(topic, sizeof(topic), \"pfm %s\", pinfo->name);\n\n\tsnprintf(name, sizeof(name), \"%s::%s\", pinfo->name, info->name);\n\tstrbuf_addf(buf, \"Code: 0x%\"PRIx64\"\\n\", info->code);\n\n\tpfm_for_each_event_attr(j, info) {\n\t\tpfm_event_attr_info_t ainfo;\n\t\tconst char *src;\n\n\t\tainfo.size = sizeof(ainfo);\n\t\tret = pfm_get_event_attr_info(info->idx, j, PFM_OS_PERF_EVENT_EXT, &ainfo);\n\t\tif (ret != PFM_SUCCESS)\n\t\t\tcontinue;\n\n\t\tif (ainfo.ctrl >= PFM_ATTR_CTRL_MAX)\n\t\t\tainfo.ctrl = PFM_ATTR_CTRL_UNKNOWN;\n\n\t\tsrc = srcs[ainfo.ctrl];\n\t\tswitch (ainfo.type) {\n\t\tcase PFM_ATTR_UMASK:  \n\t\t\tbreak;\n\t\tcase PFM_ATTR_MOD_BOOL:\n\t\t\tstrbuf_addf(buf, \" Modif: %s: [%s] : %s (boolean)\\n\", src,\n\t\t\t\t    ainfo.name, ainfo.desc);\n\t\t\tbreak;\n\t\tcase PFM_ATTR_MOD_INTEGER:\n\t\t\tstrbuf_addf(buf, \" Modif: %s: [%s] : %s (integer)\\n\", src,\n\t\t\t\t    ainfo.name, ainfo.desc);\n\t\t\tbreak;\n\t\tcase PFM_ATTR_NONE:\n\t\tcase PFM_ATTR_RAW_UMASK:\n\t\tcase PFM_ATTR_MAX:\n\t\tdefault:\n\t\t\tstrbuf_addf(buf, \" Attr: %s: [%s] : %s\\n\", src,\n\t\t\t\t    ainfo.name, ainfo.desc);\n\t\t}\n\t}\n\n\tif (is_libpfm_event_supported(name, cpus, threads)) {\n\t\tprint_cb->print_event(print_state, pinfo->name, topic,\n\t\t\t\t      name, info->equiv,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL, \"PFM event\",\n\t\t\t\t      info->desc,  NULL,\n\t\t\t\t       buf->buf);\n\t}\n\n\tpfm_for_each_event_attr(j, info) {\n\t\tpfm_event_attr_info_t ainfo;\n\t\tconst char *src;\n\n\t\tstrbuf_setlen(buf, 0);\n\n\t\tainfo.size = sizeof(ainfo);\n\t\tret = pfm_get_event_attr_info(info->idx, j, PFM_OS_PERF_EVENT_EXT, &ainfo);\n\t\tif (ret != PFM_SUCCESS)\n\t\t\tcontinue;\n\n\t\tif (ainfo.ctrl >= PFM_ATTR_CTRL_MAX)\n\t\t\tainfo.ctrl = PFM_ATTR_CTRL_UNKNOWN;\n\n\t\tsrc = srcs[ainfo.ctrl];\n\t\tif (ainfo.type == PFM_ATTR_UMASK) {\n\t\t\tstrbuf_addf(buf, \"Umask: 0x%02\"PRIx64\" : %s: \",\n\t\t\t\tainfo.code, src);\n\t\t\tprint_attr_flags(buf, &ainfo);\n\t\t\tsnprintf(name, sizeof(name), \"%s::%s:%s\",\n\t\t\t\t pinfo->name, info->name, ainfo.name);\n\n\t\t\tif (!is_libpfm_event_supported(name, cpus, threads))\n\t\t\t\tcontinue;\n\n\t\t\tprint_cb->print_event(print_state,\n\t\t\t\t\tpinfo->name,\n\t\t\t\t\ttopic,\n\t\t\t\t\tname,  NULL,\n\t\t\t\t\t NULL,\n\t\t\t\t\t NULL, \"PFM event\",\n\t\t\t\t\tainfo.desc,  NULL,\n\t\t\t\t\t buf->buf);\n\t\t}\n\t}\n\n\tperf_cpu_map__put(cpus);\n\tperf_thread_map__put(threads);\n}\n\nvoid print_libpfm_events(const struct print_callbacks *print_cb, void *print_state)\n{\n\tpfm_event_info_t info;\n\tpfm_pmu_info_t pinfo;\n\tint p, ret;\n\tstruct strbuf storage;\n\n\tlibpfm_initialize();\n\n\t \n\tinfo.size  = sizeof(info);\n\tpinfo.size = sizeof(pinfo);\n\n\tstrbuf_init(&storage, 2048);\n\n\tpfm_for_all_pmus(p) {\n\t\tret = pfm_get_pmu_info(p, &pinfo);\n\t\tif (ret != PFM_SUCCESS)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!pinfo.is_present)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (pinfo.pmu == PFM_PMU_PERF_EVENT)\n\t\t\tcontinue;\n\n\t\tfor (int i = pinfo.first_event; i != -1; i = pfm_get_event_next(i)) {\n\t\t\tret = pfm_get_event_info(i, PFM_OS_PERF_EVENT_EXT,\n\t\t\t\t\t\t&info);\n\t\t\tif (ret != PFM_SUCCESS)\n\t\t\t\tcontinue;\n\n\t\t\tprint_libpfm_event(print_cb, print_state, &pinfo, &info, &storage);\n\t\t}\n\t}\n\tstrbuf_release(&storage);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}