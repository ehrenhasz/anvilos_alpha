{
  "module_name": "unwind-libunwind-local.c",
  "hash_id": "9610d0af00e7d1aa3bb4d67e92bb0d1d7fec9b411e374ea1dae01ed86e6b6235",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/unwind-libunwind-local.c",
  "human_readable_source": "\n \n\n#include <elf.h>\n#include <errno.h>\n#include <gelf.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <linux/list.h>\n#include <linux/zalloc.h>\n#ifndef REMOTE_UNWIND_LIBUNWIND\n#include <libunwind.h>\n#include <libunwind-ptrace.h>\n#endif\n#include \"callchain.h\"\n#include \"thread.h\"\n#include \"session.h\"\n#include \"perf_regs.h\"\n#include \"unwind.h\"\n#include \"map.h\"\n#include \"symbol.h\"\n#include \"debug.h\"\n#include \"asm/bug.h\"\n#include \"dso.h\"\n\nextern int\nUNW_OBJ(dwarf_search_unwind_table) (unw_addr_space_t as,\n\t\t\t\t    unw_word_t ip,\n\t\t\t\t    unw_dyn_info_t *di,\n\t\t\t\t    unw_proc_info_t *pi,\n\t\t\t\t    int need_unwind_info, void *arg);\n\n#define dwarf_search_unwind_table UNW_OBJ(dwarf_search_unwind_table)\n\nextern int\nUNW_OBJ(dwarf_find_debug_frame) (int found, unw_dyn_info_t *di_debug,\n\t\t\t\t unw_word_t ip,\n\t\t\t\t unw_word_t segbase,\n\t\t\t\t const char *obj_name, unw_word_t start,\n\t\t\t\t unw_word_t end);\n\n#define dwarf_find_debug_frame UNW_OBJ(dwarf_find_debug_frame)\n\n#define DW_EH_PE_FORMAT_MASK\t0x0f\t \n#define DW_EH_PE_APPL_MASK\t0x70\t \n\n \n#define DW_EH_PE_omit\t\t0xff\n#define DW_EH_PE_ptr\t\t0x00\t \n#define DW_EH_PE_udata4\t\t0x03\t \n#define DW_EH_PE_udata8\t\t0x04\t \n#define DW_EH_PE_sdata4\t\t0x0b\t \n#define DW_EH_PE_sdata8\t\t0x0c\t \n\n \n#define DW_EH_PE_absptr\t\t0x00\t \n#define DW_EH_PE_pcrel\t\t0x10\t \n\n \n#define DW_EH_PE_funcrel\t0x40\t \n#define DW_EH_PE_aligned\t0x50\t \n\n \n\nstruct unwind_info {\n\tstruct perf_sample\t*sample;\n\tstruct machine\t\t*machine;\n\tstruct thread\t\t*thread;\n\tbool\t\t\t best_effort;\n};\n\n#define dw_read(ptr, type, end) ({\t\\\n\ttype *__p = (type *) ptr;\t\\\n\ttype  __v;\t\t\t\\\n\tif ((__p + 1) > (type *) end)\t\\\n\t\treturn -EINVAL;\t\t\\\n\t__v = *__p++;\t\t\t\\\n\tptr = (typeof(ptr)) __p;\t\\\n\t__v;\t\t\t\t\\\n\t})\n\nstatic int __dw_read_encoded_value(u8 **p, u8 *end, u64 *val,\n\t\t\t\t   u8 encoding)\n{\n\tu8 *cur = *p;\n\t*val = 0;\n\n\tswitch (encoding) {\n\tcase DW_EH_PE_omit:\n\t\t*val = 0;\n\t\tgoto out;\n\tcase DW_EH_PE_ptr:\n\t\t*val = dw_read(cur, unsigned long, end);\n\t\tgoto out;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (encoding & DW_EH_PE_APPL_MASK) {\n\tcase DW_EH_PE_absptr:\n\t\tbreak;\n\tcase DW_EH_PE_pcrel:\n\t\t*val = (unsigned long) cur;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((encoding & 0x07) == 0x00)\n\t\tencoding |= DW_EH_PE_udata4;\n\n\tswitch (encoding & DW_EH_PE_FORMAT_MASK) {\n\tcase DW_EH_PE_sdata4:\n\t\t*val += dw_read(cur, s32, end);\n\t\tbreak;\n\tcase DW_EH_PE_udata4:\n\t\t*val += dw_read(cur, u32, end);\n\t\tbreak;\n\tcase DW_EH_PE_sdata8:\n\t\t*val += dw_read(cur, s64, end);\n\t\tbreak;\n\tcase DW_EH_PE_udata8:\n\t\t*val += dw_read(cur, u64, end);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n out:\n\t*p = cur;\n\treturn 0;\n}\n\n#define dw_read_encoded_value(ptr, end, enc) ({\t\t\t\\\n\tu64 __v;\t\t\t\t\t\t\\\n\tif (__dw_read_encoded_value(&ptr, end, &__v, enc)) {\t\\\n\t\treturn -EINVAL;                                 \\\n\t}                                                       \\\n\t__v;                                                    \\\n\t})\n\nstatic int elf_section_address_and_offset(int fd, const char *name, u64 *address, u64 *offset)\n{\n\tElf *elf;\n\tGElf_Ehdr ehdr;\n\tGElf_Shdr shdr;\n\tint ret = -1;\n\n\telf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tif (elf == NULL)\n\t\treturn -1;\n\n\tif (gelf_getehdr(elf, &ehdr) == NULL)\n\t\tgoto out_err;\n\n\tif (!elf_section_by_name(elf, &ehdr, &shdr, name, NULL))\n\t\tgoto out_err;\n\n\t*address = shdr.sh_addr;\n\t*offset = shdr.sh_offset;\n\tret = 0;\nout_err:\n\telf_end(elf);\n\treturn ret;\n}\n\n#ifndef NO_LIBUNWIND_DEBUG_FRAME\nstatic u64 elf_section_offset(int fd, const char *name)\n{\n\tu64 address, offset = 0;\n\n\tif (elf_section_address_and_offset(fd, name, &address, &offset))\n\t\treturn 0;\n\n\treturn offset;\n}\n#endif\n\nstatic u64 elf_base_address(int fd)\n{\n\tElf *elf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tGElf_Phdr phdr;\n\tu64 retval = 0;\n\tsize_t i, phdrnum = 0;\n\n\tif (elf == NULL)\n\t\treturn 0;\n\t(void)elf_getphdrnum(elf, &phdrnum);\n\t \n\tfor (i = 0; i < phdrnum; i++) {\n\t\tif (gelf_getphdr(elf, i, &phdr) && phdr.p_type == PT_LOAD) {\n\t\t\tretval = phdr.p_vaddr & -getpagesize();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\telf_end(elf);\n\treturn retval;\n}\n\n#ifndef NO_LIBUNWIND_DEBUG_FRAME\nstatic int elf_is_exec(int fd, const char *name)\n{\n\tElf *elf;\n\tGElf_Ehdr ehdr;\n\tint retval = 0;\n\n\telf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tif (elf == NULL)\n\t\treturn 0;\n\tif (gelf_getehdr(elf, &ehdr) == NULL)\n\t\tgoto out;\n\n\tretval = (ehdr.e_type == ET_EXEC);\n\nout:\n\telf_end(elf);\n\tpr_debug(\"unwind: elf_is_exec(%s): %d\\n\", name, retval);\n\treturn retval;\n}\n#endif\n\nstruct table_entry {\n\tu32 start_ip_offset;\n\tu32 fde_offset;\n};\n\nstruct eh_frame_hdr {\n\tunsigned char version;\n\tunsigned char eh_frame_ptr_enc;\n\tunsigned char fde_count_enc;\n\tunsigned char table_enc;\n\n\t \n\n\t \n\tu64 enc[2];\n\n\t \n\tchar data[];\n} __packed;\n\nstatic int unwind_spec_ehframe(struct dso *dso, struct machine *machine,\n\t\t\t       u64 offset, u64 *table_data_offset, u64 *fde_count)\n{\n\tstruct eh_frame_hdr hdr;\n\tu8 *enc = (u8 *) &hdr.enc;\n\tu8 *end = (u8 *) &hdr.data;\n\tssize_t r;\n\n\tr = dso__data_read_offset(dso, machine, offset,\n\t\t\t\t  (u8 *) &hdr, sizeof(hdr));\n\tif (r != sizeof(hdr))\n\t\treturn -EINVAL;\n\n\t \n\tdw_read_encoded_value(enc, end, hdr.eh_frame_ptr_enc);\n\n\t*fde_count  = dw_read_encoded_value(enc, end, hdr.fde_count_enc);\n\t*table_data_offset = enc - (u8 *) &hdr;\n\treturn 0;\n}\n\nstatic int read_unwind_spec_eh_frame(struct dso *dso, struct unwind_info *ui,\n\t\t\t\t     u64 *table_data, u64 *segbase,\n\t\t\t\t     u64 *fde_count)\n{\n\tstruct map_rb_node *map_node;\n\tu64 base_addr = UINT64_MAX;\n\tint ret, fd;\n\n\tif (dso->data.eh_frame_hdr_offset == 0) {\n\t\tfd = dso__data_get_fd(dso, ui->machine);\n\t\tif (fd < 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tret = elf_section_address_and_offset(fd, \".eh_frame_hdr\",\n\t\t\t\t\t\t     &dso->data.eh_frame_hdr_addr,\n\t\t\t\t\t\t     &dso->data.eh_frame_hdr_offset);\n\t\tdso->data.elf_base_addr = elf_base_address(fd);\n\t\tdso__data_put_fd(dso);\n\t\tif (ret || dso->data.eh_frame_hdr_offset == 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmaps__for_each_entry(thread__maps(ui->thread), map_node) {\n\t\tstruct map *map = map_node->map;\n\t\tu64 start = map__start(map) - map__pgoff(map);\n\n\t\tif (map__dso(map) == dso && start < base_addr)\n\t\t\tbase_addr = start;\n\t}\n\tbase_addr -= dso->data.elf_base_addr;\n\t \n\t*segbase = base_addr + dso->data.eh_frame_hdr_addr;\n\tret = unwind_spec_ehframe(dso, ui->machine, dso->data.eh_frame_hdr_offset,\n\t\t\t\t   table_data, fde_count);\n\tif (ret)\n\t\treturn ret;\n\t \n\t*table_data += *segbase;\n\treturn 0;\n}\n\n#ifndef NO_LIBUNWIND_DEBUG_FRAME\nstatic int read_unwind_spec_debug_frame(struct dso *dso,\n\t\t\t\t\tstruct machine *machine, u64 *offset)\n{\n\tint fd;\n\tu64 ofs = dso->data.debug_frame_offset;\n\n\t \n\tif (ofs == 0) {\n\t\tfd = dso__data_get_fd(dso, machine);\n\t\tif (fd >= 0) {\n\t\t\tofs = elf_section_offset(fd, \".debug_frame\");\n\t\t\tdso__data_put_fd(dso);\n\t\t}\n\n\t\tif (ofs <= 0) {\n\t\t\tfd = open(dso->symsrc_filename, O_RDONLY);\n\t\t\tif (fd >= 0) {\n\t\t\t\tofs = elf_section_offset(fd, \".debug_frame\");\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t}\n\n\t\tif (ofs <= 0) {\n\t\t\tchar *debuglink = malloc(PATH_MAX);\n\t\t\tint ret = 0;\n\n\t\t\tret = dso__read_binary_type_filename(\n\t\t\t\tdso, DSO_BINARY_TYPE__DEBUGLINK,\n\t\t\t\tmachine->root_dir, debuglink, PATH_MAX);\n\t\t\tif (!ret) {\n\t\t\t\tfd = open(debuglink, O_RDONLY);\n\t\t\t\tif (fd >= 0) {\n\t\t\t\t\tofs = elf_section_offset(fd,\n\t\t\t\t\t\t\t\".debug_frame\");\n\t\t\t\t\tclose(fd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ofs > 0) {\n\t\t\t\tif (dso->symsrc_filename != NULL) {\n\t\t\t\t\tpr_warning(\n\t\t\t\t\t\t\"%s: overwrite symsrc(%s,%s)\\n\",\n\t\t\t\t\t\t\t__func__,\n\t\t\t\t\t\t\tdso->symsrc_filename,\n\t\t\t\t\t\t\tdebuglink);\n\t\t\t\t\tzfree(&dso->symsrc_filename);\n\t\t\t\t}\n\t\t\t\tdso->symsrc_filename = debuglink;\n\t\t\t} else {\n\t\t\t\tfree(debuglink);\n\t\t\t}\n\t\t}\n\n\t\tdso->data.debug_frame_offset = ofs;\n\t}\n\n\t*offset = ofs;\n\tif (*offset)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n#endif\n\nstatic struct map *find_map(unw_word_t ip, struct unwind_info *ui)\n{\n\tstruct addr_location al;\n\tstruct map *ret;\n\n\taddr_location__init(&al);\n\tthread__find_map(ui->thread, PERF_RECORD_MISC_USER, ip, &al);\n\tret = map__get(al.map);\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\nstatic int\nfind_proc_info(unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,\n\t       int need_unwind_info, void *arg)\n{\n\tstruct unwind_info *ui = arg;\n\tstruct map *map;\n\tstruct dso *dso;\n\tunw_dyn_info_t di;\n\tu64 table_data, segbase, fde_count;\n\tint ret = -EINVAL;\n\n\tmap = find_map(ip, ui);\n\tif (!map)\n\t\treturn -EINVAL;\n\n\tdso = map__dso(map);\n\tif (!dso) {\n\t\tmap__put(map);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"unwind: find_proc_info dso %s\\n\", dso->name);\n\n\t \n\tif (!read_unwind_spec_eh_frame(dso, ui, &table_data, &segbase, &fde_count)) {\n\t\tmemset(&di, 0, sizeof(di));\n\t\tdi.format   = UNW_INFO_FORMAT_REMOTE_TABLE;\n\t\tdi.start_ip = map__start(map);\n\t\tdi.end_ip   = map__end(map);\n\t\tdi.u.rti.segbase    = segbase;\n\t\tdi.u.rti.table_data = table_data;\n\t\tdi.u.rti.table_len  = fde_count * sizeof(struct table_entry)\n\t\t\t\t      / sizeof(unw_word_t);\n\t\tret = dwarf_search_unwind_table(as, ip, &di, pi,\n\t\t\t\t\t\tneed_unwind_info, arg);\n\t}\n\n#ifndef NO_LIBUNWIND_DEBUG_FRAME\n\t \n\tif (ret < 0 &&\n\t    !read_unwind_spec_debug_frame(dso, ui->machine, &segbase)) {\n\t\tint fd = dso__data_get_fd(dso, ui->machine);\n\t\tint is_exec = elf_is_exec(fd, dso->name);\n\t\tu64 start = map__start(map);\n\t\tunw_word_t base = is_exec ? 0 : start;\n\t\tconst char *symfile;\n\n\t\tif (fd >= 0)\n\t\t\tdso__data_put_fd(dso);\n\n\t\tsymfile = dso->symsrc_filename ?: dso->name;\n\n\t\tmemset(&di, 0, sizeof(di));\n\t\tif (dwarf_find_debug_frame(0, &di, ip, base, symfile, start, map__end(map)))\n\t\t\tret = dwarf_search_unwind_table(as, ip, &di, pi,\n\t\t\t\t\t\t\tneed_unwind_info, arg);\n\t}\n#endif\n\tmap__put(map);\n\treturn ret;\n}\n\nstatic int access_fpreg(unw_addr_space_t __maybe_unused as,\n\t\t\tunw_regnum_t __maybe_unused num,\n\t\t\tunw_fpreg_t __maybe_unused *val,\n\t\t\tint __maybe_unused __write,\n\t\t\tvoid __maybe_unused *arg)\n{\n\tpr_err(\"unwind: access_fpreg unsupported\\n\");\n\treturn -UNW_EINVAL;\n}\n\nstatic int get_dyn_info_list_addr(unw_addr_space_t __maybe_unused as,\n\t\t\t\t  unw_word_t __maybe_unused *dil_addr,\n\t\t\t\t  void __maybe_unused *arg)\n{\n\treturn -UNW_ENOINFO;\n}\n\nstatic int resume(unw_addr_space_t __maybe_unused as,\n\t\t  unw_cursor_t __maybe_unused *cu,\n\t\t  void __maybe_unused *arg)\n{\n\tpr_err(\"unwind: resume unsupported\\n\");\n\treturn -UNW_EINVAL;\n}\n\nstatic int\nget_proc_name(unw_addr_space_t __maybe_unused as,\n\t      unw_word_t __maybe_unused addr,\n\t\tchar __maybe_unused *bufp, size_t __maybe_unused buf_len,\n\t\tunw_word_t __maybe_unused *offp, void __maybe_unused *arg)\n{\n\tpr_err(\"unwind: get_proc_name unsupported\\n\");\n\treturn -UNW_EINVAL;\n}\n\nstatic int access_dso_mem(struct unwind_info *ui, unw_word_t addr,\n\t\t\t  unw_word_t *data)\n{\n\tstruct map *map;\n\tstruct dso *dso;\n\tssize_t size;\n\n\tmap = find_map(addr, ui);\n\tif (!map) {\n\t\tpr_debug(\"unwind: no map for %lx\\n\", (unsigned long)addr);\n\t\treturn -1;\n\t}\n\n\tdso = map__dso(map);\n\n\tif (!dso) {\n\t\tmap__put(map);\n\t\treturn -1;\n\t}\n\n\tsize = dso__data_read_addr(dso, map, ui->machine,\n\t\t\t\t   addr, (u8 *) data, sizeof(*data));\n\tmap__put(map);\n\treturn !(size == sizeof(*data));\n}\n\nstatic int access_mem(unw_addr_space_t __maybe_unused as,\n\t\t      unw_word_t addr, unw_word_t *valp,\n\t\t      int __write, void *arg)\n{\n\tstruct unwind_info *ui = arg;\n\tconst char *arch = perf_env__arch(ui->machine->env);\n\tstruct stack_dump *stack = &ui->sample->user_stack;\n\tu64 start, end;\n\tint offset;\n\tint ret;\n\n\t \n\tif (__write || !stack || !ui->sample->user_regs.regs) {\n\t\t*valp = 0;\n\t\treturn 0;\n\t}\n\n\tret = perf_reg_value(&start, &ui->sample->user_regs,\n\t\t\t     perf_arch_reg_sp(arch));\n\tif (ret)\n\t\treturn ret;\n\n\tend = start + stack->size;\n\n\t \n\tif (addr + sizeof(unw_word_t) < addr)\n\t\treturn -EINVAL;\n\n\tif (addr < start || addr + sizeof(unw_word_t) >= end) {\n\t\tret = access_dso_mem(ui, addr, valp);\n\t\tif (ret) {\n\t\t\tpr_debug(\"unwind: access_mem %p not inside range\"\n\t\t\t\t \" 0x%\" PRIx64 \"-0x%\" PRIx64 \"\\n\",\n\t\t\t\t (void *) (uintptr_t) addr, start, end);\n\t\t\t*valp = 0;\n\t\t\treturn ret;\n\t\t}\n\t\treturn 0;\n\t}\n\n\toffset = addr - start;\n\t*valp  = *(unw_word_t *)&stack->data[offset];\n\tpr_debug(\"unwind: access_mem addr %p val %lx, offset %d\\n\",\n\t\t (void *) (uintptr_t) addr, (unsigned long)*valp, offset);\n\treturn 0;\n}\n\nstatic int access_reg(unw_addr_space_t __maybe_unused as,\n\t\t      unw_regnum_t regnum, unw_word_t *valp,\n\t\t      int __write, void *arg)\n{\n\tstruct unwind_info *ui = arg;\n\tint id, ret;\n\tu64 val;\n\n\t \n\tif (__write) {\n\t\tpr_err(\"unwind: access_reg w %d\\n\", regnum);\n\t\treturn 0;\n\t}\n\n\tif (!ui->sample->user_regs.regs) {\n\t\t*valp = 0;\n\t\treturn 0;\n\t}\n\n\tid = LIBUNWIND__ARCH_REG_ID(regnum);\n\tif (id < 0)\n\t\treturn -EINVAL;\n\n\tret = perf_reg_value(&val, &ui->sample->user_regs, id);\n\tif (ret) {\n\t\tif (!ui->best_effort)\n\t\t\tpr_err(\"unwind: can't read reg %d\\n\", regnum);\n\t\treturn ret;\n\t}\n\n\t*valp = (unw_word_t) val;\n\tpr_debug(\"unwind: reg %d, val %lx\\n\", regnum, (unsigned long)*valp);\n\treturn 0;\n}\n\nstatic void put_unwind_info(unw_addr_space_t __maybe_unused as,\n\t\t\t    unw_proc_info_t *pi __maybe_unused,\n\t\t\t    void *arg __maybe_unused)\n{\n\tpr_debug(\"unwind: put_unwind_info called\\n\");\n}\n\nstatic int entry(u64 ip, struct thread *thread,\n\t\t unwind_entry_cb_t cb, void *arg)\n{\n\tstruct unwind_entry e;\n\tstruct addr_location al;\n\tint ret;\n\n\taddr_location__init(&al);\n\te.ms.sym = thread__find_symbol(thread, PERF_RECORD_MISC_USER, ip, &al);\n\te.ip     = ip;\n\te.ms.map = al.map;\n\te.ms.maps = al.maps;\n\n\tpr_debug(\"unwind: %s:ip = 0x%\" PRIx64 \" (0x%\" PRIx64 \")\\n\",\n\t\t al.sym ? al.sym->name : \"''\",\n\t\t ip,\n\t\t al.map ? map__map_ip(al.map, ip) : (u64) 0);\n\n\tret = cb(&e, arg);\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\nstatic void display_error(int err)\n{\n\tswitch (err) {\n\tcase UNW_EINVAL:\n\t\tpr_err(\"unwind: Only supports local.\\n\");\n\t\tbreak;\n\tcase UNW_EUNSPEC:\n\t\tpr_err(\"unwind: Unspecified error.\\n\");\n\t\tbreak;\n\tcase UNW_EBADREG:\n\t\tpr_err(\"unwind: Register unavailable.\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic unw_accessors_t accessors = {\n\t.find_proc_info\t\t= find_proc_info,\n\t.put_unwind_info\t= put_unwind_info,\n\t.get_dyn_info_list_addr\t= get_dyn_info_list_addr,\n\t.access_mem\t\t= access_mem,\n\t.access_reg\t\t= access_reg,\n\t.access_fpreg\t\t= access_fpreg,\n\t.resume\t\t\t= resume,\n\t.get_proc_name\t\t= get_proc_name,\n};\n\nstatic int _unwind__prepare_access(struct maps *maps)\n{\n\tvoid *addr_space = unw_create_addr_space(&accessors, 0);\n\n\tRC_CHK_ACCESS(maps)->addr_space = addr_space;\n\tif (!addr_space) {\n\t\tpr_err(\"unwind: Can't create unwind address space.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tunw_set_caching_policy(addr_space, UNW_CACHE_GLOBAL);\n\treturn 0;\n}\n\nstatic void _unwind__flush_access(struct maps *maps)\n{\n\tunw_flush_cache(maps__addr_space(maps), 0, 0);\n}\n\nstatic void _unwind__finish_access(struct maps *maps)\n{\n\tunw_destroy_addr_space(maps__addr_space(maps));\n}\n\nstatic int get_entries(struct unwind_info *ui, unwind_entry_cb_t cb,\n\t\t       void *arg, int max_stack)\n{\n\tconst char *arch = perf_env__arch(ui->machine->env);\n\tu64 val;\n\tunw_word_t ips[max_stack];\n\tunw_addr_space_t addr_space;\n\tunw_cursor_t c;\n\tint ret, i = 0;\n\n\tret = perf_reg_value(&val, &ui->sample->user_regs,\n\t\t\t     perf_arch_reg_ip(arch));\n\tif (ret)\n\t\treturn ret;\n\n\tips[i++] = (unw_word_t) val;\n\n\t \n\tif (max_stack - 1 > 0) {\n\t\tWARN_ONCE(!ui->thread, \"WARNING: ui->thread is NULL\");\n\t\taddr_space = maps__addr_space(thread__maps(ui->thread));\n\n\t\tif (addr_space == NULL)\n\t\t\treturn -1;\n\n\t\tret = unw_init_remote(&c, addr_space, ui);\n\t\tif (ret && !ui->best_effort)\n\t\t\tdisplay_error(ret);\n\n\t\twhile (!ret && (unw_step(&c) > 0) && i < max_stack) {\n\t\t\tunw_get_reg(&c, UNW_REG_IP, &ips[i]);\n\n\t\t\t \n\t\t\tif (unw_is_signal_frame(&c) <= 0)\n\t\t\t\t--ips[i];\n\n\t\t\t++i;\n\t\t}\n\n\t\tmax_stack = i;\n\t}\n\n\t \n\tfor (i = 0; i < max_stack && !ret; i++) {\n\t\tint j = i;\n\n\t\tif (callchain_param.order == ORDER_CALLER)\n\t\t\tj = max_stack - i - 1;\n\t\tret = ips[j] ? entry(ips[j], ui->thread, cb, arg) : 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int _unwind__get_entries(unwind_entry_cb_t cb, void *arg,\n\t\t\tstruct thread *thread,\n\t\t\tstruct perf_sample *data, int max_stack,\n\t\t\tbool best_effort)\n{\n\tstruct unwind_info ui = {\n\t\t.sample       = data,\n\t\t.thread       = thread,\n\t\t.machine      = maps__machine(thread__maps(thread)),\n\t\t.best_effort  = best_effort\n\t};\n\n\tif (!data->user_regs.regs)\n\t\treturn -EINVAL;\n\n\tif (max_stack <= 0)\n\t\treturn -EINVAL;\n\n\treturn get_entries(&ui, cb, arg, max_stack);\n}\n\nstatic struct unwind_libunwind_ops\n_unwind_libunwind_ops = {\n\t.prepare_access = _unwind__prepare_access,\n\t.flush_access   = _unwind__flush_access,\n\t.finish_access  = _unwind__finish_access,\n\t.get_entries    = _unwind__get_entries,\n};\n\n#ifndef REMOTE_UNWIND_LIBUNWIND\nstruct unwind_libunwind_ops *\nlocal_unwind_libunwind_ops = &_unwind_libunwind_ops;\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}