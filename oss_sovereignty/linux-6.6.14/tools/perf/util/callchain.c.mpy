{
  "module_name": "callchain.c",
  "hash_id": "1b066061f1be4e1fe52a379df9e7d27f0d438feedc29842fc88cfa926c5ae865",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/callchain.c",
  "human_readable_source": "\n \n\n#include <inttypes.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <errno.h>\n#include <math.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n\n#include \"asm/bug.h\"\n\n#include \"debug.h\"\n#include \"dso.h\"\n#include \"event.h\"\n#include \"hist.h\"\n#include \"sort.h\"\n#include \"machine.h\"\n#include \"map.h\"\n#include \"callchain.h\"\n#include \"branch.h\"\n#include \"symbol.h\"\n#include \"util.h\"\n#include \"../perf.h\"\n\n#define CALLCHAIN_PARAM_DEFAULT\t\t\t\\\n\t.mode\t\t= CHAIN_GRAPH_ABS,\t\\\n\t.min_percent\t= 0.5,\t\t\t\\\n\t.order\t\t= ORDER_CALLEE,\t\t\\\n\t.key\t\t= CCKEY_FUNCTION,\t\\\n\t.value\t\t= CCVAL_PERCENT,\t\\\n\nstruct callchain_param callchain_param = {\n\tCALLCHAIN_PARAM_DEFAULT\n};\n\n \nbool dwarf_callchain_users;\n\nstruct callchain_param callchain_param_default = {\n\tCALLCHAIN_PARAM_DEFAULT\n};\n\n \nstatic pthread_key_t callchain_cursor;\n\nint parse_callchain_record_opt(const char *arg, struct callchain_param *param)\n{\n\treturn parse_callchain_record(arg, param);\n}\n\nstatic int parse_callchain_mode(const char *value)\n{\n\tif (!strncmp(value, \"graph\", strlen(value))) {\n\t\tcallchain_param.mode = CHAIN_GRAPH_ABS;\n\t\treturn 0;\n\t}\n\tif (!strncmp(value, \"flat\", strlen(value))) {\n\t\tcallchain_param.mode = CHAIN_FLAT;\n\t\treturn 0;\n\t}\n\tif (!strncmp(value, \"fractal\", strlen(value))) {\n\t\tcallchain_param.mode = CHAIN_GRAPH_REL;\n\t\treturn 0;\n\t}\n\tif (!strncmp(value, \"folded\", strlen(value))) {\n\t\tcallchain_param.mode = CHAIN_FOLDED;\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int parse_callchain_order(const char *value)\n{\n\tif (!strncmp(value, \"caller\", strlen(value))) {\n\t\tcallchain_param.order = ORDER_CALLER;\n\t\tcallchain_param.order_set = true;\n\t\treturn 0;\n\t}\n\tif (!strncmp(value, \"callee\", strlen(value))) {\n\t\tcallchain_param.order = ORDER_CALLEE;\n\t\tcallchain_param.order_set = true;\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int parse_callchain_sort_key(const char *value)\n{\n\tif (!strncmp(value, \"function\", strlen(value))) {\n\t\tcallchain_param.key = CCKEY_FUNCTION;\n\t\treturn 0;\n\t}\n\tif (!strncmp(value, \"address\", strlen(value))) {\n\t\tcallchain_param.key = CCKEY_ADDRESS;\n\t\treturn 0;\n\t}\n\tif (!strncmp(value, \"srcline\", strlen(value))) {\n\t\tcallchain_param.key = CCKEY_SRCLINE;\n\t\treturn 0;\n\t}\n\tif (!strncmp(value, \"branch\", strlen(value))) {\n\t\tcallchain_param.branch_callstack = 1;\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int parse_callchain_value(const char *value)\n{\n\tif (!strncmp(value, \"percent\", strlen(value))) {\n\t\tcallchain_param.value = CCVAL_PERCENT;\n\t\treturn 0;\n\t}\n\tif (!strncmp(value, \"period\", strlen(value))) {\n\t\tcallchain_param.value = CCVAL_PERIOD;\n\t\treturn 0;\n\t}\n\tif (!strncmp(value, \"count\", strlen(value))) {\n\t\tcallchain_param.value = CCVAL_COUNT;\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int get_stack_size(const char *str, unsigned long *_size)\n{\n\tchar *endptr;\n\tunsigned long size;\n\tunsigned long max_size = round_down(USHRT_MAX, sizeof(u64));\n\n\tsize = strtoul(str, &endptr, 0);\n\n\tdo {\n\t\tif (*endptr)\n\t\t\tbreak;\n\n\t\tsize = round_up(size, sizeof(u64));\n\t\tif (!size || size > max_size)\n\t\t\tbreak;\n\n\t\t*_size = size;\n\t\treturn 0;\n\n\t} while (0);\n\n\tpr_err(\"callchain: Incorrect stack dump size (max %ld): %s\\n\",\n\t       max_size, str);\n\treturn -1;\n}\n\nstatic int\n__parse_callchain_report_opt(const char *arg, bool allow_record_opt)\n{\n\tchar *tok;\n\tchar *endptr, *saveptr = NULL;\n\tbool minpcnt_set = false;\n\tbool record_opt_set = false;\n\tbool try_stack_size = false;\n\n\tcallchain_param.enabled = true;\n\tsymbol_conf.use_callchain = true;\n\n\tif (!arg)\n\t\treturn 0;\n\n\twhile ((tok = strtok_r((char *)arg, \",\", &saveptr)) != NULL) {\n\t\tif (!strncmp(tok, \"none\", strlen(tok))) {\n\t\t\tcallchain_param.mode = CHAIN_NONE;\n\t\t\tcallchain_param.enabled = false;\n\t\t\tsymbol_conf.use_callchain = false;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!parse_callchain_mode(tok) ||\n\t\t    !parse_callchain_order(tok) ||\n\t\t    !parse_callchain_sort_key(tok) ||\n\t\t    !parse_callchain_value(tok)) {\n\t\t\t \n\t\t\ttry_stack_size = false;\n\t\t\tgoto next;\n\t\t} else if (allow_record_opt && !record_opt_set) {\n\t\t\tif (parse_callchain_record(tok, &callchain_param))\n\t\t\t\tgoto try_numbers;\n\n\t\t\t \n\t\t\tif (callchain_param.record_mode == CALLCHAIN_DWARF)\n\t\t\t\ttry_stack_size = true;\n\n\t\t\trecord_opt_set = true;\n\t\t\tgoto next;\n\t\t}\n\ntry_numbers:\n\t\tif (try_stack_size) {\n\t\t\tunsigned long size = 0;\n\n\t\t\tif (get_stack_size(tok, &size) < 0)\n\t\t\t\treturn -1;\n\t\t\tcallchain_param.dump_size = size;\n\t\t\ttry_stack_size = false;\n\t\t} else if (!minpcnt_set) {\n\t\t\t \n\t\t\tcallchain_param.min_percent = strtod(tok, &endptr);\n\t\t\tif (tok == endptr)\n\t\t\t\treturn -1;\n\t\t\tminpcnt_set = true;\n\t\t} else {\n\t\t\t \n\t\t\tcallchain_param.print_limit = strtoul(tok, &endptr, 0);\n\t\t\tif (tok == endptr)\n\t\t\t\treturn -1;\n\t\t}\nnext:\n\t\targ = NULL;\n\t}\n\n\tif (callchain_register_param(&callchain_param) < 0) {\n\t\tpr_err(\"Can't register callchain params\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint parse_callchain_report_opt(const char *arg)\n{\n\treturn __parse_callchain_report_opt(arg, false);\n}\n\nint parse_callchain_top_opt(const char *arg)\n{\n\treturn __parse_callchain_report_opt(arg, true);\n}\n\nint parse_callchain_record(const char *arg, struct callchain_param *param)\n{\n\tchar *tok, *name, *saveptr = NULL;\n\tchar *buf;\n\tint ret = -1;\n\n\t \n\tbuf = malloc(strlen(arg) + 1);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tstrcpy(buf, arg);\n\n\ttok = strtok_r((char *)buf, \",\", &saveptr);\n\tname = tok ? : (char *)buf;\n\n\tdo {\n\t\t \n\t\tif (!strncmp(name, \"fp\", sizeof(\"fp\"))) {\n\t\t\tret = 0;\n\t\t\tparam->record_mode = CALLCHAIN_FP;\n\n\t\t\ttok = strtok_r(NULL, \",\", &saveptr);\n\t\t\tif (tok) {\n\t\t\t\tunsigned long size;\n\n\t\t\t\tsize = strtoul(tok, &name, 0);\n\t\t\t\tif (size < (unsigned) sysctl__max_stack())\n\t\t\t\t\tparam->max_stack = size;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\t} else if (!strncmp(name, \"dwarf\", sizeof(\"dwarf\"))) {\n\t\t\tconst unsigned long default_stack_dump_size = 8192;\n\n\t\t\tret = 0;\n\t\t\tparam->record_mode = CALLCHAIN_DWARF;\n\t\t\tparam->dump_size = default_stack_dump_size;\n\t\t\tdwarf_callchain_users = true;\n\n\t\t\ttok = strtok_r(NULL, \",\", &saveptr);\n\t\t\tif (tok) {\n\t\t\t\tunsigned long size = 0;\n\n\t\t\t\tret = get_stack_size(tok, &size);\n\t\t\t\tparam->dump_size = size;\n\t\t\t}\n\t\t} else if (!strncmp(name, \"lbr\", sizeof(\"lbr\"))) {\n\t\t\tif (!strtok_r(NULL, \",\", &saveptr)) {\n\t\t\t\tparam->record_mode = CALLCHAIN_LBR;\n\t\t\t\tret = 0;\n\t\t\t} else\n\t\t\t\tpr_err(\"callchain: No more arguments \"\n\t\t\t\t\t\"needed for --call-graph lbr\\n\");\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpr_err(\"callchain: Unknown --call-graph option \"\n\t\t\t       \"value: %s\\n\", arg);\n\t\t\tbreak;\n\t\t}\n\n\t} while (0);\n\n\tfree(buf);\n\treturn ret;\n}\n\nint perf_callchain_config(const char *var, const char *value)\n{\n\tchar *endptr;\n\n\tif (!strstarts(var, \"call-graph.\"))\n\t\treturn 0;\n\tvar += sizeof(\"call-graph.\") - 1;\n\n\tif (!strcmp(var, \"record-mode\"))\n\t\treturn parse_callchain_record_opt(value, &callchain_param);\n\tif (!strcmp(var, \"dump-size\")) {\n\t\tunsigned long size = 0;\n\t\tint ret;\n\n\t\tret = get_stack_size(value, &size);\n\t\tcallchain_param.dump_size = size;\n\n\t\treturn ret;\n\t}\n\tif (!strcmp(var, \"print-type\")){\n\t\tint ret;\n\t\tret = parse_callchain_mode(value);\n\t\tif (ret == -1)\n\t\t\tpr_err(\"Invalid callchain mode: %s\\n\", value);\n\t\treturn ret;\n\t}\n\tif (!strcmp(var, \"order\")){\n\t\tint ret;\n\t\tret = parse_callchain_order(value);\n\t\tif (ret == -1)\n\t\t\tpr_err(\"Invalid callchain order: %s\\n\", value);\n\t\treturn ret;\n\t}\n\tif (!strcmp(var, \"sort-key\")){\n\t\tint ret;\n\t\tret = parse_callchain_sort_key(value);\n\t\tif (ret == -1)\n\t\t\tpr_err(\"Invalid callchain sort key: %s\\n\", value);\n\t\treturn ret;\n\t}\n\tif (!strcmp(var, \"threshold\")) {\n\t\tcallchain_param.min_percent = strtod(value, &endptr);\n\t\tif (value == endptr) {\n\t\t\tpr_err(\"Invalid callchain threshold: %s\\n\", value);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!strcmp(var, \"print-limit\")) {\n\t\tcallchain_param.print_limit = strtod(value, &endptr);\n\t\tif (value == endptr) {\n\t\t\tpr_err(\"Invalid callchain print limit: %s\\n\", value);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\nrb_insert_callchain(struct rb_root *root, struct callchain_node *chain,\n\t\t    enum chain_mode mode)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct callchain_node *rnode;\n\tu64 chain_cumul = callchain_cumul_hits(chain);\n\n\twhile (*p) {\n\t\tu64 rnode_cumul;\n\n\t\tparent = *p;\n\t\trnode = rb_entry(parent, struct callchain_node, rb_node);\n\t\trnode_cumul = callchain_cumul_hits(rnode);\n\n\t\tswitch (mode) {\n\t\tcase CHAIN_FLAT:\n\t\tcase CHAIN_FOLDED:\n\t\t\tif (rnode->hit < chain->hit)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\tbreak;\n\t\tcase CHAIN_GRAPH_ABS:  \n\t\tcase CHAIN_GRAPH_REL:\n\t\t\tif (rnode_cumul < chain_cumul)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\tbreak;\n\t\tcase CHAIN_NONE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trb_link_node(&chain->rb_node, parent, p);\n\trb_insert_color(&chain->rb_node, root);\n}\n\nstatic void\n__sort_chain_flat(struct rb_root *rb_root, struct callchain_node *node,\n\t\t  u64 min_hit)\n{\n\tstruct rb_node *n;\n\tstruct callchain_node *child;\n\n\tn = rb_first(&node->rb_root_in);\n\twhile (n) {\n\t\tchild = rb_entry(n, struct callchain_node, rb_node_in);\n\t\tn = rb_next(n);\n\n\t\t__sort_chain_flat(rb_root, child, min_hit);\n\t}\n\n\tif (node->hit && node->hit >= min_hit)\n\t\trb_insert_callchain(rb_root, node, CHAIN_FLAT);\n}\n\n \nstatic void\nsort_chain_flat(struct rb_root *rb_root, struct callchain_root *root,\n\t\tu64 min_hit, struct callchain_param *param __maybe_unused)\n{\n\t*rb_root = RB_ROOT;\n\t__sort_chain_flat(rb_root, &root->node, min_hit);\n}\n\nstatic void __sort_chain_graph_abs(struct callchain_node *node,\n\t\t\t\t   u64 min_hit)\n{\n\tstruct rb_node *n;\n\tstruct callchain_node *child;\n\n\tnode->rb_root = RB_ROOT;\n\tn = rb_first(&node->rb_root_in);\n\n\twhile (n) {\n\t\tchild = rb_entry(n, struct callchain_node, rb_node_in);\n\t\tn = rb_next(n);\n\n\t\t__sort_chain_graph_abs(child, min_hit);\n\t\tif (callchain_cumul_hits(child) >= min_hit)\n\t\t\trb_insert_callchain(&node->rb_root, child,\n\t\t\t\t\t    CHAIN_GRAPH_ABS);\n\t}\n}\n\nstatic void\nsort_chain_graph_abs(struct rb_root *rb_root, struct callchain_root *chain_root,\n\t\t     u64 min_hit, struct callchain_param *param __maybe_unused)\n{\n\t__sort_chain_graph_abs(&chain_root->node, min_hit);\n\trb_root->rb_node = chain_root->node.rb_root.rb_node;\n}\n\nstatic void __sort_chain_graph_rel(struct callchain_node *node,\n\t\t\t\t   double min_percent)\n{\n\tstruct rb_node *n;\n\tstruct callchain_node *child;\n\tu64 min_hit;\n\n\tnode->rb_root = RB_ROOT;\n\tmin_hit = ceil(node->children_hit * min_percent);\n\n\tn = rb_first(&node->rb_root_in);\n\twhile (n) {\n\t\tchild = rb_entry(n, struct callchain_node, rb_node_in);\n\t\tn = rb_next(n);\n\n\t\t__sort_chain_graph_rel(child, min_percent);\n\t\tif (callchain_cumul_hits(child) >= min_hit)\n\t\t\trb_insert_callchain(&node->rb_root, child,\n\t\t\t\t\t    CHAIN_GRAPH_REL);\n\t}\n}\n\nstatic void\nsort_chain_graph_rel(struct rb_root *rb_root, struct callchain_root *chain_root,\n\t\t     u64 min_hit __maybe_unused, struct callchain_param *param)\n{\n\t__sort_chain_graph_rel(&chain_root->node, param->min_percent / 100.0);\n\trb_root->rb_node = chain_root->node.rb_root.rb_node;\n}\n\nint callchain_register_param(struct callchain_param *param)\n{\n\tswitch (param->mode) {\n\tcase CHAIN_GRAPH_ABS:\n\t\tparam->sort = sort_chain_graph_abs;\n\t\tbreak;\n\tcase CHAIN_GRAPH_REL:\n\t\tparam->sort = sort_chain_graph_rel;\n\t\tbreak;\n\tcase CHAIN_FLAT:\n\tcase CHAIN_FOLDED:\n\t\tparam->sort = sort_chain_flat;\n\t\tbreak;\n\tcase CHAIN_NONE:\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic struct callchain_node *\ncreate_child(struct callchain_node *parent, bool inherit_children)\n{\n\tstruct callchain_node *new;\n\n\tnew = zalloc(sizeof(*new));\n\tif (!new) {\n\t\tperror(\"not enough memory to create child for code path tree\");\n\t\treturn NULL;\n\t}\n\tnew->parent = parent;\n\tINIT_LIST_HEAD(&new->val);\n\tINIT_LIST_HEAD(&new->parent_val);\n\n\tif (inherit_children) {\n\t\tstruct rb_node *n;\n\t\tstruct callchain_node *child;\n\n\t\tnew->rb_root_in = parent->rb_root_in;\n\t\tparent->rb_root_in = RB_ROOT;\n\n\t\tn = rb_first(&new->rb_root_in);\n\t\twhile (n) {\n\t\t\tchild = rb_entry(n, struct callchain_node, rb_node_in);\n\t\t\tchild->parent = new;\n\t\t\tn = rb_next(n);\n\t\t}\n\n\t\t \n\t\trb_link_node(&new->rb_node_in, NULL, &parent->rb_root_in.rb_node);\n\t\trb_insert_color(&new->rb_node_in, &parent->rb_root_in);\n\t}\n\n\treturn new;\n}\n\n\n \nstatic int\nfill_node(struct callchain_node *node, struct callchain_cursor *cursor)\n{\n\tstruct callchain_cursor_node *cursor_node;\n\n\tnode->val_nr = cursor->nr - cursor->pos;\n\tif (!node->val_nr)\n\t\tpr_warning(\"Warning: empty node in callchain tree\\n\");\n\n\tcursor_node = callchain_cursor_current(cursor);\n\n\twhile (cursor_node) {\n\t\tstruct callchain_list *call;\n\n\t\tcall = zalloc(sizeof(*call));\n\t\tif (!call) {\n\t\t\tperror(\"not enough memory for the code path tree\");\n\t\t\treturn -1;\n\t\t}\n\t\tcall->ip = cursor_node->ip;\n\t\tcall->ms = cursor_node->ms;\n\t\tcall->ms.map = map__get(call->ms.map);\n\t\tcall->ms.maps = maps__get(call->ms.maps);\n\t\tcall->srcline = cursor_node->srcline;\n\n\t\tif (cursor_node->branch) {\n\t\t\tcall->branch_count = 1;\n\n\t\t\tif (cursor_node->branch_from) {\n\t\t\t\t \n\t\t\t\tcall->brtype_stat.branch_to = true;\n\n\t\t\t\tif (cursor_node->branch_flags.predicted)\n\t\t\t\t\tcall->predicted_count = 1;\n\n\t\t\t\tif (cursor_node->branch_flags.abort)\n\t\t\t\t\tcall->abort_count = 1;\n\n\t\t\t\tbranch_type_count(&call->brtype_stat,\n\t\t\t\t\t\t  &cursor_node->branch_flags,\n\t\t\t\t\t\t  cursor_node->branch_from,\n\t\t\t\t\t\t  cursor_node->ip);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tcall->brtype_stat.branch_to = false;\n\t\t\t\tcall->cycles_count =\n\t\t\t\t\tcursor_node->branch_flags.cycles;\n\t\t\t\tcall->iter_count = cursor_node->nr_loop_iter;\n\t\t\t\tcall->iter_cycles = cursor_node->iter_cycles;\n\t\t\t}\n\t\t}\n\n\t\tlist_add_tail(&call->list, &node->val);\n\n\t\tcallchain_cursor_advance(cursor);\n\t\tcursor_node = callchain_cursor_current(cursor);\n\t}\n\treturn 0;\n}\n\nstatic struct callchain_node *\nadd_child(struct callchain_node *parent,\n\t  struct callchain_cursor *cursor,\n\t  u64 period)\n{\n\tstruct callchain_node *new;\n\n\tnew = create_child(parent, false);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tif (fill_node(new, cursor) < 0) {\n\t\tstruct callchain_list *call, *tmp;\n\n\t\tlist_for_each_entry_safe(call, tmp, &new->val, list) {\n\t\t\tlist_del_init(&call->list);\n\t\t\tmap__zput(call->ms.map);\n\t\t\tmaps__zput(call->ms.maps);\n\t\t\tfree(call);\n\t\t}\n\t\tfree(new);\n\t\treturn NULL;\n\t}\n\n\tnew->children_hit = 0;\n\tnew->hit = period;\n\tnew->children_count = 0;\n\tnew->count = 1;\n\treturn new;\n}\n\nenum match_result {\n\tMATCH_ERROR  = -1,\n\tMATCH_EQ,\n\tMATCH_LT,\n\tMATCH_GT,\n};\n\nstatic enum match_result match_chain_strings(const char *left,\n\t\t\t\t\t     const char *right)\n{\n\tenum match_result ret = MATCH_EQ;\n\tint cmp;\n\n\tif (left && right)\n\t\tcmp = strcmp(left, right);\n\telse if (!left && right)\n\t\tcmp = 1;\n\telse if (left && !right)\n\t\tcmp = -1;\n\telse\n\t\treturn MATCH_ERROR;\n\n\tif (cmp != 0)\n\t\tret = cmp < 0 ? MATCH_LT : MATCH_GT;\n\n\treturn ret;\n}\n\n \nstatic enum match_result match_chain_dso_addresses(struct map *left_map, u64 left_ip,\n\t\t\t\t\t\t   struct map *right_map, u64 right_ip)\n{\n\tstruct dso *left_dso = left_map ? map__dso(left_map) : NULL;\n\tstruct dso *right_dso = right_map ? map__dso(right_map) : NULL;\n\n\tif (left_dso != right_dso)\n\t\treturn left_dso < right_dso ? MATCH_LT : MATCH_GT;\n\n\tif (left_ip != right_ip)\n \t\treturn left_ip < right_ip ? MATCH_LT : MATCH_GT;\n\n\treturn MATCH_EQ;\n}\n\nstatic enum match_result match_chain(struct callchain_cursor_node *node,\n\t\t\t\t     struct callchain_list *cnode)\n{\n\tenum match_result match = MATCH_ERROR;\n\n\tswitch (callchain_param.key) {\n\tcase CCKEY_SRCLINE:\n\t\tmatch = match_chain_strings(cnode->srcline, node->srcline);\n\t\tif (match != MATCH_ERROR)\n\t\t\tbreak;\n\t\t \n\t\tfallthrough;\n\tcase CCKEY_FUNCTION:\n\t\tif (node->ms.sym && cnode->ms.sym) {\n\t\t\t \n\t\t\tif (cnode->ms.sym->inlined || node->ms.sym->inlined) {\n\t\t\t\tmatch = match_chain_strings(cnode->ms.sym->name,\n\t\t\t\t\t\t\t    node->ms.sym->name);\n\t\t\t\tif (match != MATCH_ERROR)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmatch = match_chain_dso_addresses(cnode->ms.map, cnode->ms.sym->start,\n\t\t\t\t\t\t\t\t  node->ms.map, node->ms.sym->start);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tfallthrough;\n\tcase CCKEY_ADDRESS:\n\tdefault:\n\t\tmatch = match_chain_dso_addresses(cnode->ms.map, cnode->ip, node->ms.map, node->ip);\n\t\tbreak;\n\t}\n\n\tif (match == MATCH_EQ && node->branch) {\n\t\tcnode->branch_count++;\n\n\t\tif (node->branch_from) {\n\t\t\t \n\t\t\tcnode->brtype_stat.branch_to = true;\n\n\t\t\tif (node->branch_flags.predicted)\n\t\t\t\tcnode->predicted_count++;\n\n\t\t\tif (node->branch_flags.abort)\n\t\t\t\tcnode->abort_count++;\n\n\t\t\tbranch_type_count(&cnode->brtype_stat,\n\t\t\t\t\t  &node->branch_flags,\n\t\t\t\t\t  node->branch_from,\n\t\t\t\t\t  node->ip);\n\t\t} else {\n\t\t\t \n\t\t\tcnode->brtype_stat.branch_to = false;\n\t\t\tcnode->cycles_count += node->branch_flags.cycles;\n\t\t\tcnode->iter_count += node->nr_loop_iter;\n\t\t\tcnode->iter_cycles += node->iter_cycles;\n\t\t\tcnode->from_count++;\n\t\t}\n\t}\n\n\treturn match;\n}\n\n \nstatic int\nsplit_add_child(struct callchain_node *parent,\n\t\tstruct callchain_cursor *cursor,\n\t\tstruct callchain_list *to_split,\n\t\tu64 idx_parents, u64 idx_local, u64 period)\n{\n\tstruct callchain_node *new;\n\tstruct list_head *old_tail;\n\tunsigned int idx_total = idx_parents + idx_local;\n\n\t \n\tnew = create_child(parent, true);\n\tif (new == NULL)\n\t\treturn -1;\n\n\t \n\told_tail = parent->val.prev;\n\tlist_del_range(&to_split->list, old_tail);\n\tnew->val.next = &to_split->list;\n\tnew->val.prev = old_tail;\n\tto_split->list.prev = &new->val;\n\told_tail->next = &new->val;\n\n\t \n\tnew->hit = parent->hit;\n\tnew->children_hit = parent->children_hit;\n\tparent->children_hit = callchain_cumul_hits(new);\n\tnew->val_nr = parent->val_nr - idx_local;\n\tparent->val_nr = idx_local;\n\tnew->count = parent->count;\n\tnew->children_count = parent->children_count;\n\tparent->children_count = callchain_cumul_counts(new);\n\n\t \n\tif (idx_total < cursor->nr) {\n\t\tstruct callchain_node *first;\n\t\tstruct callchain_list *cnode;\n\t\tstruct callchain_cursor_node *node;\n\t\tstruct rb_node *p, **pp;\n\n\t\tparent->hit = 0;\n\t\tparent->children_hit += period;\n\t\tparent->count = 0;\n\t\tparent->children_count += 1;\n\n\t\tnode = callchain_cursor_current(cursor);\n\t\tnew = add_child(parent, cursor, period);\n\t\tif (new == NULL)\n\t\t\treturn -1;\n\n\t\t \n\t\tp = parent->rb_root_in.rb_node;\n\t\tfirst = rb_entry(p, struct callchain_node, rb_node_in);\n\t\tcnode = list_first_entry(&first->val, struct callchain_list,\n\t\t\t\t\t list);\n\n\t\tif (match_chain(node, cnode) == MATCH_LT)\n\t\t\tpp = &p->rb_left;\n\t\telse\n\t\t\tpp = &p->rb_right;\n\n\t\trb_link_node(&new->rb_node_in, p, pp);\n\t\trb_insert_color(&new->rb_node_in, &parent->rb_root_in);\n\t} else {\n\t\tparent->hit = period;\n\t\tparent->count = 1;\n\t}\n\treturn 0;\n}\n\nstatic enum match_result\nappend_chain(struct callchain_node *root,\n\t     struct callchain_cursor *cursor,\n\t     u64 period);\n\nstatic int\nappend_chain_children(struct callchain_node *root,\n\t\t      struct callchain_cursor *cursor,\n\t\t      u64 period)\n{\n\tstruct callchain_node *rnode;\n\tstruct callchain_cursor_node *node;\n\tstruct rb_node **p = &root->rb_root_in.rb_node;\n\tstruct rb_node *parent = NULL;\n\n\tnode = callchain_cursor_current(cursor);\n\tif (!node)\n\t\treturn -1;\n\n\t \n\twhile (*p) {\n\t\tenum match_result ret;\n\n\t\tparent = *p;\n\t\trnode = rb_entry(parent, struct callchain_node, rb_node_in);\n\n\t\t \n\t\tret = append_chain(rnode, cursor, period);\n\t\tif (ret == MATCH_EQ)\n\t\t\tgoto inc_children_hit;\n\t\tif (ret == MATCH_ERROR)\n\t\t\treturn -1;\n\n\t\tif (ret == MATCH_LT)\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\t}\n\t \n\trnode = add_child(root, cursor, period);\n\tif (rnode == NULL)\n\t\treturn -1;\n\n\trb_link_node(&rnode->rb_node_in, parent, p);\n\trb_insert_color(&rnode->rb_node_in, &root->rb_root_in);\n\ninc_children_hit:\n\troot->children_hit += period;\n\troot->children_count++;\n\treturn 0;\n}\n\nstatic enum match_result\nappend_chain(struct callchain_node *root,\n\t     struct callchain_cursor *cursor,\n\t     u64 period)\n{\n\tstruct callchain_list *cnode;\n\tu64 start = cursor->pos;\n\tbool found = false;\n\tu64 matches;\n\tenum match_result cmp = MATCH_ERROR;\n\n\t \n\tlist_for_each_entry(cnode, &root->val, list) {\n\t\tstruct callchain_cursor_node *node;\n\n\t\tnode = callchain_cursor_current(cursor);\n\t\tif (!node)\n\t\t\tbreak;\n\n\t\tcmp = match_chain(node, cnode);\n\t\tif (cmp != MATCH_EQ)\n\t\t\tbreak;\n\n\t\tfound = true;\n\n\t\tcallchain_cursor_advance(cursor);\n\t}\n\n\t \n\tif (!found) {\n\t\tWARN_ONCE(cmp == MATCH_ERROR, \"Chain comparison error\\n\");\n\t\treturn cmp;\n\t}\n\n\tmatches = cursor->pos - start;\n\n\t \n\tif (matches < root->val_nr) {\n\t\tif (split_add_child(root, cursor, cnode, start, matches,\n\t\t\t\t    period) < 0)\n\t\t\treturn MATCH_ERROR;\n\n\t\treturn MATCH_EQ;\n\t}\n\n\t \n\tif (matches == root->val_nr && cursor->pos == cursor->nr) {\n\t\troot->hit += period;\n\t\troot->count++;\n\t\treturn MATCH_EQ;\n\t}\n\n\t \n\tif (append_chain_children(root, cursor, period) < 0)\n\t\treturn MATCH_ERROR;\n\n\treturn MATCH_EQ;\n}\n\nint callchain_append(struct callchain_root *root,\n\t\t     struct callchain_cursor *cursor,\n\t\t     u64 period)\n{\n\tif (cursor == NULL)\n\t\treturn -1;\n\n\tif (!cursor->nr)\n\t\treturn 0;\n\n\tcallchain_cursor_commit(cursor);\n\n\tif (append_chain_children(&root->node, cursor, period) < 0)\n\t\treturn -1;\n\n\tif (cursor->nr > root->max_depth)\n\t\troot->max_depth = cursor->nr;\n\n\treturn 0;\n}\n\nstatic int\nmerge_chain_branch(struct callchain_cursor *cursor,\n\t\t   struct callchain_node *dst, struct callchain_node *src)\n{\n\tstruct callchain_cursor_node **old_last = cursor->last;\n\tstruct callchain_node *child;\n\tstruct callchain_list *list, *next_list;\n\tstruct rb_node *n;\n\tint old_pos = cursor->nr;\n\tint err = 0;\n\n\tlist_for_each_entry_safe(list, next_list, &src->val, list) {\n\t\tstruct map_symbol ms = {\n\t\t\t.maps = maps__get(list->ms.maps),\n\t\t\t.map = map__get(list->ms.map),\n\t\t};\n\t\tcallchain_cursor_append(cursor, list->ip, &ms, false, NULL, 0, 0, 0, list->srcline);\n\t\tlist_del_init(&list->list);\n\t\tmap__zput(ms.map);\n\t\tmaps__zput(ms.maps);\n\t\tmap__zput(list->ms.map);\n\t\tmaps__zput(list->ms.maps);\n\t\tfree(list);\n\t}\n\n\tif (src->hit) {\n\t\tcallchain_cursor_commit(cursor);\n\t\tif (append_chain_children(dst, cursor, src->hit) < 0)\n\t\t\treturn -1;\n\t}\n\n\tn = rb_first(&src->rb_root_in);\n\twhile (n) {\n\t\tchild = container_of(n, struct callchain_node, rb_node_in);\n\t\tn = rb_next(n);\n\t\trb_erase(&child->rb_node_in, &src->rb_root_in);\n\n\t\terr = merge_chain_branch(cursor, dst, child);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tfree(child);\n\t}\n\n\tcursor->nr = old_pos;\n\tcursor->last = old_last;\n\n\treturn err;\n}\n\nint callchain_merge(struct callchain_cursor *cursor,\n\t\t    struct callchain_root *dst, struct callchain_root *src)\n{\n\treturn merge_chain_branch(cursor, &dst->node, &src->node);\n}\n\nint callchain_cursor_append(struct callchain_cursor *cursor,\n\t\t\t    u64 ip, struct map_symbol *ms,\n\t\t\t    bool branch, struct branch_flags *flags,\n\t\t\t    int nr_loop_iter, u64 iter_cycles, u64 branch_from,\n\t\t\t    const char *srcline)\n{\n\tstruct callchain_cursor_node *node = *cursor->last;\n\n\tif (!node) {\n\t\tnode = calloc(1, sizeof(*node));\n\t\tif (!node)\n\t\t\treturn -ENOMEM;\n\n\t\t*cursor->last = node;\n\t}\n\n\tnode->ip = ip;\n\tmaps__zput(node->ms.maps);\n\tmap__zput(node->ms.map);\n\tnode->ms = *ms;\n\tnode->ms.maps = maps__get(ms->maps);\n\tnode->ms.map = map__get(ms->map);\n\tnode->branch = branch;\n\tnode->nr_loop_iter = nr_loop_iter;\n\tnode->iter_cycles = iter_cycles;\n\tnode->srcline = srcline;\n\n\tif (flags)\n\t\tmemcpy(&node->branch_flags, flags,\n\t\t\tsizeof(struct branch_flags));\n\n\tnode->branch_from = branch_from;\n\tcursor->nr++;\n\n\tcursor->last = &node->next;\n\n\treturn 0;\n}\n\nint sample__resolve_callchain(struct perf_sample *sample,\n\t\t\t      struct callchain_cursor *cursor, struct symbol **parent,\n\t\t\t      struct evsel *evsel, struct addr_location *al,\n\t\t\t      int max_stack)\n{\n\tif (sample->callchain == NULL && !symbol_conf.show_branchflag_count)\n\t\treturn 0;\n\n\tif (symbol_conf.use_callchain || symbol_conf.cumulate_callchain ||\n\t    perf_hpp_list.parent || symbol_conf.show_branchflag_count) {\n\t\treturn thread__resolve_callchain(al->thread, cursor, evsel, sample,\n\t\t\t\t\t\t parent, al, max_stack);\n\t}\n\treturn 0;\n}\n\nint hist_entry__append_callchain(struct hist_entry *he, struct perf_sample *sample)\n{\n\tif ((!symbol_conf.use_callchain || sample->callchain == NULL) &&\n\t\t!symbol_conf.show_branchflag_count)\n\t\treturn 0;\n\treturn callchain_append(he->callchain, get_tls_callchain_cursor(), sample->period);\n}\n\nint fill_callchain_info(struct addr_location *al, struct callchain_cursor_node *node,\n\t\t\tbool hide_unresolved)\n{\n\tstruct machine *machine = maps__machine(node->ms.maps);\n\n\tmaps__put(al->maps);\n\tal->maps = maps__get(node->ms.maps);\n\tmap__put(al->map);\n\tal->map = map__get(node->ms.map);\n\tal->sym = node->ms.sym;\n\tal->srcline = node->srcline;\n\tal->addr = node->ip;\n\n\tif (al->sym == NULL) {\n\t\tif (hide_unresolved)\n\t\t\treturn 0;\n\t\tif (al->map == NULL)\n\t\t\tgoto out;\n\t}\n\tif (RC_CHK_ACCESS(al->maps) == RC_CHK_ACCESS(machine__kernel_maps(machine))) {\n\t\tif (machine__is_host(machine)) {\n\t\t\tal->cpumode = PERF_RECORD_MISC_KERNEL;\n\t\t\tal->level = 'k';\n\t\t} else {\n\t\t\tal->cpumode = PERF_RECORD_MISC_GUEST_KERNEL;\n\t\t\tal->level = 'g';\n\t\t}\n\t} else {\n\t\tif (machine__is_host(machine)) {\n\t\t\tal->cpumode = PERF_RECORD_MISC_USER;\n\t\t\tal->level = '.';\n\t\t} else if (perf_guest) {\n\t\t\tal->cpumode = PERF_RECORD_MISC_GUEST_USER;\n\t\t\tal->level = 'u';\n\t\t} else {\n\t\t\tal->cpumode = PERF_RECORD_MISC_HYPERVISOR;\n\t\t\tal->level = 'H';\n\t\t}\n\t}\n\nout:\n\treturn 1;\n}\n\nchar *callchain_list__sym_name(struct callchain_list *cl,\n\t\t\t       char *bf, size_t bfsize, bool show_dso)\n{\n\tbool show_addr = callchain_param.key == CCKEY_ADDRESS;\n\tbool show_srcline = show_addr || callchain_param.key == CCKEY_SRCLINE;\n\tint printed;\n\n\tif (cl->ms.sym) {\n\t\tconst char *inlined = cl->ms.sym->inlined ? \" (inlined)\" : \"\";\n\n\t\tif (show_srcline && cl->srcline)\n\t\t\tprinted = scnprintf(bf, bfsize, \"%s %s%s\",\n\t\t\t\t\t    cl->ms.sym->name, cl->srcline,\n\t\t\t\t\t    inlined);\n\t\telse\n\t\t\tprinted = scnprintf(bf, bfsize, \"%s%s\",\n\t\t\t\t\t    cl->ms.sym->name, inlined);\n\t} else\n\t\tprinted = scnprintf(bf, bfsize, \"%#\" PRIx64, cl->ip);\n\n\tif (show_dso)\n\t\tscnprintf(bf + printed, bfsize - printed, \" %s\",\n\t\t\t  cl->ms.map ?\n\t\t\t  map__dso(cl->ms.map)->short_name :\n\t\t\t  \"unknown\");\n\n\treturn bf;\n}\n\nchar *callchain_node__scnprintf_value(struct callchain_node *node,\n\t\t\t\t      char *bf, size_t bfsize, u64 total)\n{\n\tdouble percent = 0.0;\n\tu64 period = callchain_cumul_hits(node);\n\tunsigned count = callchain_cumul_counts(node);\n\n\tif (callchain_param.mode == CHAIN_FOLDED) {\n\t\tperiod = node->hit;\n\t\tcount = node->count;\n\t}\n\n\tswitch (callchain_param.value) {\n\tcase CCVAL_PERIOD:\n\t\tscnprintf(bf, bfsize, \"%\"PRIu64, period);\n\t\tbreak;\n\tcase CCVAL_COUNT:\n\t\tscnprintf(bf, bfsize, \"%u\", count);\n\t\tbreak;\n\tcase CCVAL_PERCENT:\n\tdefault:\n\t\tif (total)\n\t\t\tpercent = period * 100.0 / total;\n\t\tscnprintf(bf, bfsize, \"%.2f%%\", percent);\n\t\tbreak;\n\t}\n\treturn bf;\n}\n\nint callchain_node__fprintf_value(struct callchain_node *node,\n\t\t\t\t FILE *fp, u64 total)\n{\n\tdouble percent = 0.0;\n\tu64 period = callchain_cumul_hits(node);\n\tunsigned count = callchain_cumul_counts(node);\n\n\tif (callchain_param.mode == CHAIN_FOLDED) {\n\t\tperiod = node->hit;\n\t\tcount = node->count;\n\t}\n\n\tswitch (callchain_param.value) {\n\tcase CCVAL_PERIOD:\n\t\treturn fprintf(fp, \"%\"PRIu64, period);\n\tcase CCVAL_COUNT:\n\t\treturn fprintf(fp, \"%u\", count);\n\tcase CCVAL_PERCENT:\n\tdefault:\n\t\tif (total)\n\t\t\tpercent = period * 100.0 / total;\n\t\treturn percent_color_fprintf(fp, \"%.2f%%\", percent);\n\t}\n\treturn 0;\n}\n\nstatic void callchain_counts_value(struct callchain_node *node,\n\t\t\t\t   u64 *branch_count, u64 *predicted_count,\n\t\t\t\t   u64 *abort_count, u64 *cycles_count)\n{\n\tstruct callchain_list *clist;\n\n\tlist_for_each_entry(clist, &node->val, list) {\n\t\tif (branch_count)\n\t\t\t*branch_count += clist->branch_count;\n\n\t\tif (predicted_count)\n\t\t\t*predicted_count += clist->predicted_count;\n\n\t\tif (abort_count)\n\t\t\t*abort_count += clist->abort_count;\n\n\t\tif (cycles_count)\n\t\t\t*cycles_count += clist->cycles_count;\n\t}\n}\n\nstatic int callchain_node_branch_counts_cumul(struct callchain_node *node,\n\t\t\t\t\t      u64 *branch_count,\n\t\t\t\t\t      u64 *predicted_count,\n\t\t\t\t\t      u64 *abort_count,\n\t\t\t\t\t      u64 *cycles_count)\n{\n\tstruct callchain_node *child;\n\tstruct rb_node *n;\n\n\tn = rb_first(&node->rb_root_in);\n\twhile (n) {\n\t\tchild = rb_entry(n, struct callchain_node, rb_node_in);\n\t\tn = rb_next(n);\n\n\t\tcallchain_node_branch_counts_cumul(child, branch_count,\n\t\t\t\t\t\t   predicted_count,\n\t\t\t\t\t\t   abort_count,\n\t\t\t\t\t\t   cycles_count);\n\n\t\tcallchain_counts_value(child, branch_count,\n\t\t\t\t       predicted_count, abort_count,\n\t\t\t\t       cycles_count);\n\t}\n\n\treturn 0;\n}\n\nint callchain_branch_counts(struct callchain_root *root,\n\t\t\t    u64 *branch_count, u64 *predicted_count,\n\t\t\t    u64 *abort_count, u64 *cycles_count)\n{\n\tif (branch_count)\n\t\t*branch_count = 0;\n\n\tif (predicted_count)\n\t\t*predicted_count = 0;\n\n\tif (abort_count)\n\t\t*abort_count = 0;\n\n\tif (cycles_count)\n\t\t*cycles_count = 0;\n\n\treturn callchain_node_branch_counts_cumul(&root->node,\n\t\t\t\t\t\t  branch_count,\n\t\t\t\t\t\t  predicted_count,\n\t\t\t\t\t\t  abort_count,\n\t\t\t\t\t\t  cycles_count);\n}\n\nstatic int count_pri64_printf(int idx, const char *str, u64 value, char *bf, int bfsize)\n{\n\treturn scnprintf(bf, bfsize, \"%s%s:%\" PRId64 \"\", (idx) ? \" \" : \" (\", str, value);\n}\n\nstatic int count_float_printf(int idx, const char *str, float value,\n\t\t\t      char *bf, int bfsize, float threshold)\n{\n\tif (threshold != 0.0 && value < threshold)\n\t\treturn 0;\n\n\treturn scnprintf(bf, bfsize, \"%s%s:%.1f%%\", (idx) ? \" \" : \" (\", str, value);\n}\n\nstatic int branch_to_str(char *bf, int bfsize,\n\t\t\t u64 branch_count, u64 predicted_count,\n\t\t\t u64 abort_count,\n\t\t\t struct branch_type_stat *brtype_stat)\n{\n\tint printed, i = 0;\n\n\tprinted = branch_type_str(brtype_stat, bf, bfsize);\n\tif (printed)\n\t\ti++;\n\n\tif (predicted_count < branch_count) {\n\t\tprinted += count_float_printf(i++, \"predicted\",\n\t\t\t\tpredicted_count * 100.0 / branch_count,\n\t\t\t\tbf + printed, bfsize - printed, 0.0);\n\t}\n\n\tif (abort_count) {\n\t\tprinted += count_float_printf(i++, \"abort\",\n\t\t\t\tabort_count * 100.0 / branch_count,\n\t\t\t\tbf + printed, bfsize - printed, 0.1);\n\t}\n\n\tif (i)\n\t\tprinted += scnprintf(bf + printed, bfsize - printed, \")\");\n\n\treturn printed;\n}\n\nstatic int branch_from_str(char *bf, int bfsize,\n\t\t\t   u64 branch_count,\n\t\t\t   u64 cycles_count, u64 iter_count,\n\t\t\t   u64 iter_cycles, u64 from_count)\n{\n\tint printed = 0, i = 0;\n\tu64 cycles, v = 0;\n\n\tcycles = cycles_count / branch_count;\n\tif (cycles) {\n\t\tprinted += count_pri64_printf(i++, \"cycles\",\n\t\t\t\tcycles,\n\t\t\t\tbf + printed, bfsize - printed);\n\t}\n\n\tif (iter_count && from_count) {\n\t\tv = iter_count / from_count;\n\t\tif (v) {\n\t\t\tprinted += count_pri64_printf(i++, \"iter\",\n\t\t\t\t\tv, bf + printed, bfsize - printed);\n\n\t\t\tprinted += count_pri64_printf(i++, \"avg_cycles\",\n\t\t\t\t\titer_cycles / iter_count,\n\t\t\t\t\tbf + printed, bfsize - printed);\n\t\t}\n\t}\n\n\tif (i)\n\t\tprinted += scnprintf(bf + printed, bfsize - printed, \")\");\n\n\treturn printed;\n}\n\nstatic int counts_str_build(char *bf, int bfsize,\n\t\t\t     u64 branch_count, u64 predicted_count,\n\t\t\t     u64 abort_count, u64 cycles_count,\n\t\t\t     u64 iter_count, u64 iter_cycles,\n\t\t\t     u64 from_count,\n\t\t\t     struct branch_type_stat *brtype_stat)\n{\n\tint printed;\n\n\tif (branch_count == 0)\n\t\treturn scnprintf(bf, bfsize, \" (calltrace)\");\n\n\tif (brtype_stat->branch_to) {\n\t\tprinted = branch_to_str(bf, bfsize, branch_count,\n\t\t\t\tpredicted_count, abort_count, brtype_stat);\n\t} else {\n\t\tprinted = branch_from_str(bf, bfsize, branch_count,\n\t\t\t\tcycles_count, iter_count, iter_cycles,\n\t\t\t\tfrom_count);\n\t}\n\n\tif (!printed)\n\t\tbf[0] = 0;\n\n\treturn printed;\n}\n\nstatic int callchain_counts_printf(FILE *fp, char *bf, int bfsize,\n\t\t\t\t   u64 branch_count, u64 predicted_count,\n\t\t\t\t   u64 abort_count, u64 cycles_count,\n\t\t\t\t   u64 iter_count, u64 iter_cycles,\n\t\t\t\t   u64 from_count,\n\t\t\t\t   struct branch_type_stat *brtype_stat)\n{\n\tchar str[256];\n\n\tcounts_str_build(str, sizeof(str), branch_count,\n\t\t\t predicted_count, abort_count, cycles_count,\n\t\t\t iter_count, iter_cycles, from_count, brtype_stat);\n\n\tif (fp)\n\t\treturn fprintf(fp, \"%s\", str);\n\n\treturn scnprintf(bf, bfsize, \"%s\", str);\n}\n\nint callchain_list_counts__printf_value(struct callchain_list *clist,\n\t\t\t\t\tFILE *fp, char *bf, int bfsize)\n{\n\tu64 branch_count, predicted_count;\n\tu64 abort_count, cycles_count;\n\tu64 iter_count, iter_cycles;\n\tu64 from_count;\n\n\tbranch_count = clist->branch_count;\n\tpredicted_count = clist->predicted_count;\n\tabort_count = clist->abort_count;\n\tcycles_count = clist->cycles_count;\n\titer_count = clist->iter_count;\n\titer_cycles = clist->iter_cycles;\n\tfrom_count = clist->from_count;\n\n\treturn callchain_counts_printf(fp, bf, bfsize, branch_count,\n\t\t\t\t       predicted_count, abort_count,\n\t\t\t\t       cycles_count, iter_count, iter_cycles,\n\t\t\t\t       from_count, &clist->brtype_stat);\n}\n\nstatic void free_callchain_node(struct callchain_node *node)\n{\n\tstruct callchain_list *list, *tmp;\n\tstruct callchain_node *child;\n\tstruct rb_node *n;\n\n\tlist_for_each_entry_safe(list, tmp, &node->parent_val, list) {\n\t\tlist_del_init(&list->list);\n\t\tmap__zput(list->ms.map);\n\t\tmaps__zput(list->ms.maps);\n\t\tfree(list);\n\t}\n\n\tlist_for_each_entry_safe(list, tmp, &node->val, list) {\n\t\tlist_del_init(&list->list);\n\t\tmap__zput(list->ms.map);\n\t\tmaps__zput(list->ms.maps);\n\t\tfree(list);\n\t}\n\n\tn = rb_first(&node->rb_root_in);\n\twhile (n) {\n\t\tchild = container_of(n, struct callchain_node, rb_node_in);\n\t\tn = rb_next(n);\n\t\trb_erase(&child->rb_node_in, &node->rb_root_in);\n\n\t\tfree_callchain_node(child);\n\t\tfree(child);\n\t}\n}\n\nvoid free_callchain(struct callchain_root *root)\n{\n\tif (!symbol_conf.use_callchain)\n\t\treturn;\n\n\tfree_callchain_node(&root->node);\n}\n\nstatic u64 decay_callchain_node(struct callchain_node *node)\n{\n\tstruct callchain_node *child;\n\tstruct rb_node *n;\n\tu64 child_hits = 0;\n\n\tn = rb_first(&node->rb_root_in);\n\twhile (n) {\n\t\tchild = container_of(n, struct callchain_node, rb_node_in);\n\n\t\tchild_hits += decay_callchain_node(child);\n\t\tn = rb_next(n);\n\t}\n\n\tnode->hit = (node->hit * 7) / 8;\n\tnode->children_hit = child_hits;\n\n\treturn node->hit;\n}\n\nvoid decay_callchain(struct callchain_root *root)\n{\n\tif (!symbol_conf.use_callchain)\n\t\treturn;\n\n\tdecay_callchain_node(&root->node);\n}\n\nint callchain_node__make_parent_list(struct callchain_node *node)\n{\n\tstruct callchain_node *parent = node->parent;\n\tstruct callchain_list *chain, *new;\n\tLIST_HEAD(head);\n\n\twhile (parent) {\n\t\tlist_for_each_entry_reverse(chain, &parent->val, list) {\n\t\t\tnew = malloc(sizeof(*new));\n\t\t\tif (new == NULL)\n\t\t\t\tgoto out;\n\t\t\t*new = *chain;\n\t\t\tnew->has_children = false;\n\t\t\tnew->ms.map = map__get(new->ms.map);\n\t\t\tlist_add_tail(&new->list, &head);\n\t\t}\n\t\tparent = parent->parent;\n\t}\n\n\tlist_for_each_entry_safe_reverse(chain, new, &head, list)\n\t\tlist_move_tail(&chain->list, &node->parent_val);\n\n\tif (!list_empty(&node->parent_val)) {\n\t\tchain = list_first_entry(&node->parent_val, struct callchain_list, list);\n\t\tchain->has_children = rb_prev(&node->rb_node) || rb_next(&node->rb_node);\n\n\t\tchain = list_first_entry(&node->val, struct callchain_list, list);\n\t\tchain->has_children = false;\n\t}\n\treturn 0;\n\nout:\n\tlist_for_each_entry_safe(chain, new, &head, list) {\n\t\tlist_del_init(&chain->list);\n\t\tmap__zput(chain->ms.map);\n\t\tmaps__zput(chain->ms.maps);\n\t\tfree(chain);\n\t}\n\treturn -ENOMEM;\n}\n\nstatic void callchain_cursor__delete(void *vcursor)\n{\n\tstruct callchain_cursor *cursor = vcursor;\n\tstruct callchain_cursor_node *node, *next;\n\n\tcallchain_cursor_reset(cursor);\n\tfor (node = cursor->first; node != NULL; node = next) {\n\t\tnext = node->next;\n\t\tfree(node);\n\t}\n\tfree(cursor);\n}\n\nstatic void init_callchain_cursor_key(void)\n{\n\tif (pthread_key_create(&callchain_cursor, callchain_cursor__delete)) {\n\t\tpr_err(\"callchain cursor creation failed\");\n\t\tabort();\n\t}\n}\n\nstruct callchain_cursor *get_tls_callchain_cursor(void)\n{\n\tstatic pthread_once_t once_control = PTHREAD_ONCE_INIT;\n\tstruct callchain_cursor *cursor;\n\n\tpthread_once(&once_control, init_callchain_cursor_key);\n\tcursor = pthread_getspecific(callchain_cursor);\n\tif (!cursor) {\n\t\tcursor = zalloc(sizeof(*cursor));\n\t\tif (!cursor)\n\t\t\tpr_debug3(\"%s: not enough memory\\n\", __func__);\n\t\tpthread_setspecific(callchain_cursor, cursor);\n\t}\n\treturn cursor;\n}\n\nint callchain_cursor__copy(struct callchain_cursor *dst,\n\t\t\t   struct callchain_cursor *src)\n{\n\tint rc = 0;\n\n\tcallchain_cursor_reset(dst);\n\tcallchain_cursor_commit(src);\n\n\twhile (true) {\n\t\tstruct callchain_cursor_node *node;\n\n\t\tnode = callchain_cursor_current(src);\n\t\tif (node == NULL)\n\t\t\tbreak;\n\n\t\trc = callchain_cursor_append(dst, node->ip, &node->ms,\n\t\t\t\t\t     node->branch, &node->branch_flags,\n\t\t\t\t\t     node->nr_loop_iter,\n\t\t\t\t\t     node->iter_cycles,\n\t\t\t\t\t     node->branch_from, node->srcline);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tcallchain_cursor_advance(src);\n\t}\n\n\treturn rc;\n}\n\n \nvoid callchain_cursor_reset(struct callchain_cursor *cursor)\n{\n\tstruct callchain_cursor_node *node;\n\n\tcursor->nr = 0;\n\tcursor->last = &cursor->first;\n\n\tfor (node = cursor->first; node != NULL; node = node->next) {\n\t\tmap__zput(node->ms.map);\n\t\tmaps__zput(node->ms.maps);\n\t}\n}\n\nvoid callchain_param_setup(u64 sample_type, const char *arch)\n{\n\tif (symbol_conf.use_callchain || symbol_conf.cumulate_callchain) {\n\t\tif ((sample_type & PERF_SAMPLE_REGS_USER) &&\n\t\t    (sample_type & PERF_SAMPLE_STACK_USER)) {\n\t\t\tcallchain_param.record_mode = CALLCHAIN_DWARF;\n\t\t\tdwarf_callchain_users = true;\n\t\t} else if (sample_type & PERF_SAMPLE_BRANCH_STACK)\n\t\t\tcallchain_param.record_mode = CALLCHAIN_LBR;\n\t\telse\n\t\t\tcallchain_param.record_mode = CALLCHAIN_FP;\n\t}\n\n\t \n\tif (callchain_param.record_mode == CALLCHAIN_FP && !strcmp(arch, \"arm64\"))\n\t\tdwarf_callchain_users = true;\n}\n\nstatic bool chain_match(struct callchain_list *base_chain,\n\t\t\tstruct callchain_list *pair_chain)\n{\n\tenum match_result match;\n\n\tmatch = match_chain_strings(base_chain->srcline,\n\t\t\t\t    pair_chain->srcline);\n\tif (match != MATCH_ERROR)\n\t\treturn match == MATCH_EQ;\n\n\tmatch = match_chain_dso_addresses(base_chain->ms.map,\n\t\t\t\t\t  base_chain->ip,\n\t\t\t\t\t  pair_chain->ms.map,\n\t\t\t\t\t  pair_chain->ip);\n\n\treturn match == MATCH_EQ;\n}\n\nbool callchain_cnode_matched(struct callchain_node *base_cnode,\n\t\t\t     struct callchain_node *pair_cnode)\n{\n\tstruct callchain_list *base_chain, *pair_chain;\n\tbool match = false;\n\n\tpair_chain = list_first_entry(&pair_cnode->val,\n\t\t\t\t      struct callchain_list,\n\t\t\t\t      list);\n\n\tlist_for_each_entry(base_chain, &base_cnode->val, list) {\n\t\tif (&pair_chain->list == &pair_cnode->val)\n\t\t\treturn false;\n\n\t\tif (!base_chain->srcline || !pair_chain->srcline) {\n\t\t\tpair_chain = list_next_entry(pair_chain, list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = chain_match(base_chain, pair_chain);\n\t\tif (!match)\n\t\t\treturn false;\n\n\t\tpair_chain = list_next_entry(pair_chain, list);\n\t}\n\n\t \n\tif (pair_chain && (&pair_chain->list != &pair_cnode->val))\n\t\treturn false;\n\n\treturn match;\n}\n\nstatic u64 count_callchain_hits(struct hist_entry *he)\n{\n\tstruct rb_root *root = &he->sorted_chain;\n\tstruct rb_node *rb_node = rb_first(root);\n\tstruct callchain_node *node;\n\tu64 chain_hits = 0;\n\n\twhile (rb_node) {\n\t\tnode = rb_entry(rb_node, struct callchain_node, rb_node);\n\t\tchain_hits += node->hit;\n\t\trb_node = rb_next(rb_node);\n\t}\n\n\treturn chain_hits;\n}\n\nu64 callchain_total_hits(struct hists *hists)\n{\n\tstruct rb_node *next = rb_first_cached(&hists->entries);\n\tu64 chain_hits = 0;\n\n\twhile (next) {\n\t\tstruct hist_entry *he = rb_entry(next, struct hist_entry,\n\t\t\t\t\t\t rb_node);\n\n\t\tchain_hits += count_callchain_hits(he);\n\t\tnext = rb_next(&he->rb_node);\n\t}\n\n\treturn chain_hits;\n}\n\ns64 callchain_avg_cycles(struct callchain_node *cnode)\n{\n\tstruct callchain_list *chain;\n\ts64 cycles = 0;\n\n\tlist_for_each_entry(chain, &cnode->val, list) {\n\t\tif (chain->srcline && chain->branch_count)\n\t\t\tcycles += chain->cycles_count / chain->branch_count;\n\t}\n\n\treturn cycles;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}