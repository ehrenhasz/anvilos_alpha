{
  "module_name": "bpf-filter.c",
  "hash_id": "513a7f13c19e827705153b6461ded55dccc824e7aeb6ddf2bc825b8bf0818e79",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/bpf-filter.c",
  "human_readable_source": " \n#include <stdlib.h>\n\n#include <bpf/bpf.h>\n#include <linux/err.h>\n#include <internal/xyarray.h>\n\n#include \"util/debug.h\"\n#include \"util/evsel.h\"\n\n#include \"util/bpf-filter.h\"\n#include <util/bpf-filter-flex.h>\n#include <util/bpf-filter-bison.h>\n\n#include \"bpf_skel/sample-filter.h\"\n#include \"bpf_skel/sample_filter.skel.h\"\n\n#define FD(e, x, y) (*(int *)xyarray__entry(e->core.fd, x, y))\n\n#define __PERF_SAMPLE_TYPE(st, opt)\t{ st, #st, opt }\n#define PERF_SAMPLE_TYPE(_st, opt)\t__PERF_SAMPLE_TYPE(PERF_SAMPLE_##_st, opt)\n\nstatic const struct perf_sample_info {\n\tu64 type;\n\tconst char *name;\n\tconst char *option;\n} sample_table[] = {\n\t \n\tPERF_SAMPLE_TYPE(IP, NULL),\n\tPERF_SAMPLE_TYPE(TID, NULL),\n\tPERF_SAMPLE_TYPE(PERIOD, NULL),\n\t \n\tPERF_SAMPLE_TYPE(ID, \"--sample-identifier\"),\n\tPERF_SAMPLE_TYPE(CPU, \"--sample-cpu\"),\n\tPERF_SAMPLE_TYPE(TIME, \"-T\"),\n\t \n\tPERF_SAMPLE_TYPE(ADDR, \"-d\"),\n\tPERF_SAMPLE_TYPE(DATA_SRC, \"-d\"),\n\tPERF_SAMPLE_TYPE(PHYS_ADDR, \"--phys-data\"),\n\tPERF_SAMPLE_TYPE(WEIGHT, \"-W\"),\n\tPERF_SAMPLE_TYPE(WEIGHT_STRUCT, \"-W\"),\n\tPERF_SAMPLE_TYPE(TRANSACTION, \"--transaction\"),\n\tPERF_SAMPLE_TYPE(CODE_PAGE_SIZE, \"--code-page-size\"),\n\tPERF_SAMPLE_TYPE(DATA_PAGE_SIZE, \"--data-page-size\"),\n};\n\nstatic const struct perf_sample_info *get_sample_info(u64 flags)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sample_table); i++) {\n\t\tif (sample_table[i].type == flags)\n\t\t\treturn &sample_table[i];\n\t}\n\treturn NULL;\n}\n\nstatic int check_sample_flags(struct evsel *evsel, struct perf_bpf_filter_expr *expr)\n{\n\tconst struct perf_sample_info *info;\n\n\tif (evsel->core.attr.sample_type & expr->sample_flags)\n\t\treturn 0;\n\n\tif (expr->op == PBF_OP_GROUP_BEGIN) {\n\t\tstruct perf_bpf_filter_expr *group;\n\n\t\tlist_for_each_entry(group, &expr->groups, list) {\n\t\t\tif (check_sample_flags(evsel, group) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tinfo = get_sample_info(expr->sample_flags);\n\tif (info == NULL) {\n\t\tpr_err(\"Error: %s event does not have sample flags %lx\\n\",\n\t\t       evsel__name(evsel), expr->sample_flags);\n\t\treturn -1;\n\t}\n\n\tpr_err(\"Error: %s event does not have %s\\n\", evsel__name(evsel), info->name);\n\tif (info->option)\n\t\tpr_err(\" Hint: please add %s option to perf record\\n\", info->option);\n\treturn -1;\n}\n\nint perf_bpf_filter__prepare(struct evsel *evsel)\n{\n\tint i, x, y, fd;\n\tstruct sample_filter_bpf *skel;\n\tstruct bpf_program *prog;\n\tstruct bpf_link *link;\n\tstruct perf_bpf_filter_expr *expr;\n\n\tskel = sample_filter_bpf__open_and_load();\n\tif (!skel) {\n\t\tpr_err(\"Failed to load perf sample-filter BPF skeleton\\n\");\n\t\treturn -1;\n\t}\n\n\ti = 0;\n\tfd = bpf_map__fd(skel->maps.filters);\n\tlist_for_each_entry(expr, &evsel->bpf_filters, list) {\n\t\tstruct perf_bpf_filter_entry entry = {\n\t\t\t.op = expr->op,\n\t\t\t.part = expr->part,\n\t\t\t.flags = expr->sample_flags,\n\t\t\t.value = expr->val,\n\t\t};\n\n\t\tif (check_sample_flags(evsel, expr) < 0)\n\t\t\treturn -1;\n\n\t\tbpf_map_update_elem(fd, &i, &entry, BPF_ANY);\n\t\ti++;\n\n\t\tif (expr->op == PBF_OP_GROUP_BEGIN) {\n\t\t\tstruct perf_bpf_filter_expr *group;\n\n\t\t\tlist_for_each_entry(group, &expr->groups, list) {\n\t\t\t\tstruct perf_bpf_filter_entry group_entry = {\n\t\t\t\t\t.op = group->op,\n\t\t\t\t\t.part = group->part,\n\t\t\t\t\t.flags = group->sample_flags,\n\t\t\t\t\t.value = group->val,\n\t\t\t\t};\n\t\t\t\tbpf_map_update_elem(fd, &i, &group_entry, BPF_ANY);\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tmemset(&entry, 0, sizeof(entry));\n\t\t\tentry.op = PBF_OP_GROUP_END;\n\t\t\tbpf_map_update_elem(fd, &i, &entry, BPF_ANY);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (i > MAX_FILTERS) {\n\t\tpr_err(\"Too many filters: %d (max = %d)\\n\", i, MAX_FILTERS);\n\t\treturn -1;\n\t}\n\tprog = skel->progs.perf_sample_filter;\n\tfor (x = 0; x < xyarray__max_x(evsel->core.fd); x++) {\n\t\tfor (y = 0; y < xyarray__max_y(evsel->core.fd); y++) {\n\t\t\tlink = bpf_program__attach_perf_event(prog, FD(evsel, x, y));\n\t\t\tif (IS_ERR(link)) {\n\t\t\t\tpr_err(\"Failed to attach perf sample-filter program\\n\");\n\t\t\t\treturn PTR_ERR(link);\n\t\t\t}\n\t\t}\n\t}\n\tevsel->bpf_skel = skel;\n\treturn 0;\n}\n\nint perf_bpf_filter__destroy(struct evsel *evsel)\n{\n\tstruct perf_bpf_filter_expr *expr, *tmp;\n\n\tlist_for_each_entry_safe(expr, tmp, &evsel->bpf_filters, list) {\n\t\tlist_del(&expr->list);\n\t\tfree(expr);\n\t}\n\tsample_filter_bpf__destroy(evsel->bpf_skel);\n\treturn 0;\n}\n\nu64 perf_bpf_filter__lost_count(struct evsel *evsel)\n{\n\tstruct sample_filter_bpf *skel = evsel->bpf_skel;\n\n\treturn skel ? skel->bss->dropped : 0;\n}\n\nstruct perf_bpf_filter_expr *perf_bpf_filter_expr__new(unsigned long sample_flags, int part,\n\t\t\t\t\t\t       enum perf_bpf_filter_op op,\n\t\t\t\t\t\t       unsigned long val)\n{\n\tstruct perf_bpf_filter_expr *expr;\n\n\texpr = malloc(sizeof(*expr));\n\tif (expr != NULL) {\n\t\texpr->sample_flags = sample_flags;\n\t\texpr->part = part;\n\t\texpr->op = op;\n\t\texpr->val = val;\n\t\tINIT_LIST_HEAD(&expr->groups);\n\t}\n\treturn expr;\n}\n\nint perf_bpf_filter__parse(struct list_head *expr_head, const char *str)\n{\n\tYY_BUFFER_STATE buffer;\n\tint ret;\n\n\tbuffer = perf_bpf_filter__scan_string(str);\n\n\tret = perf_bpf_filter_parse(expr_head);\n\n\tperf_bpf_filter__flush_buffer(buffer);\n\tperf_bpf_filter__delete_buffer(buffer);\n\tperf_bpf_filter_lex_destroy();\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}