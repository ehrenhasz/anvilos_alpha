{
  "module_name": "probe-event.c",
  "hash_id": "1c7fab3010dd3ccb1495e029d0e8b810bf472d2000b0136e067a43df1050868e",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/probe-event.c",
  "human_readable_source": "\n \n\n#include <inttypes.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <elf.h>\n\n#include \"build-id.h\"\n#include \"event.h\"\n#include \"namespaces.h\"\n#include \"strlist.h\"\n#include \"strfilter.h\"\n#include \"debug.h\"\n#include \"dso.h\"\n#include \"color.h\"\n#include \"map.h\"\n#include \"maps.h\"\n#include \"mutex.h\"\n#include \"symbol.h\"\n#include <api/fs/fs.h>\n#include \"trace-event.h\"\t \n#include \"probe-event.h\"\n#include \"probe-finder.h\"\n#include \"probe-file.h\"\n#include \"session.h\"\n#include \"string2.h\"\n#include \"strbuf.h\"\n\n#include <subcmd/pager.h>\n#include <linux/ctype.h>\n#include <linux/zalloc.h>\n\n#ifdef HAVE_DEBUGINFOD_SUPPORT\n#include <elfutils/debuginfod.h>\n#endif\n\n#define PERFPROBE_GROUP \"probe\"\n\nbool probe_event_dry_run;\t \nstruct probe_conf probe_conf = { .magic_num = DEFAULT_PROBE_MAGIC_NUM };\n\nstatic char *synthesize_perf_probe_point(struct perf_probe_point *pp);\n\n#define semantic_error(msg ...) pr_err(\"Semantic error :\" msg)\n\nint e_snprintf(char *str, size_t size, const char *format, ...)\n{\n\tint ret;\n\tva_list ap;\n\tva_start(ap, format);\n\tret = vsnprintf(str, size, format, ap);\n\tva_end(ap);\n\tif (ret >= (int)size)\n\t\tret = -E2BIG;\n\treturn ret;\n}\n\nstatic struct machine *host_machine;\n\n \nint init_probe_symbol_maps(bool user_only)\n{\n\tint ret;\n\n\tsymbol_conf.allow_aliases = true;\n\tret = symbol__init(NULL);\n\tif (ret < 0) {\n\t\tpr_debug(\"Failed to init symbol map.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (host_machine || user_only)\t \n\t\treturn 0;\n\n\tif (symbol_conf.vmlinux_name)\n\t\tpr_debug(\"Use vmlinux: %s\\n\", symbol_conf.vmlinux_name);\n\n\thost_machine = machine__new_host();\n\tif (!host_machine) {\n\t\tpr_debug(\"machine__new_host() failed.\\n\");\n\t\tsymbol__exit();\n\t\tret = -1;\n\t}\nout:\n\tif (ret < 0)\n\t\tpr_warning(\"Failed to init vmlinux path.\\n\");\n\treturn ret;\n}\n\nvoid exit_probe_symbol_maps(void)\n{\n\tmachine__delete(host_machine);\n\thost_machine = NULL;\n\tsymbol__exit();\n}\n\nstatic struct ref_reloc_sym *kernel_get_ref_reloc_sym(struct map **pmap)\n{\n\tstruct kmap *kmap;\n\tstruct map *map = machine__kernel_map(host_machine);\n\n\tif (map__load(map) < 0)\n\t\treturn NULL;\n\n\tkmap = map__kmap(map);\n\tif (!kmap)\n\t\treturn NULL;\n\n\tif (pmap)\n\t\t*pmap = map;\n\n\treturn kmap->ref_reloc_sym;\n}\n\nstatic int kernel_get_symbol_address_by_name(const char *name, u64 *addr,\n\t\t\t\t\t     bool reloc, bool reladdr)\n{\n\tstruct ref_reloc_sym *reloc_sym;\n\tstruct symbol *sym;\n\tstruct map *map;\n\n\t \n\treloc_sym = kernel_get_ref_reloc_sym(&map);\n\tif (reloc_sym && strcmp(name, reloc_sym->name) == 0)\n\t\t*addr = (!map__reloc(map) || reloc) ? reloc_sym->addr :\n\t\t\treloc_sym->unrelocated_addr;\n\telse {\n\t\tsym = machine__find_kernel_symbol_by_name(host_machine, name, &map);\n\t\tif (!sym)\n\t\t\treturn -ENOENT;\n\t\t*addr = map__unmap_ip(map, sym->start) -\n\t\t\t((reloc) ? 0 : map__reloc(map)) -\n\t\t\t((reladdr) ? map__start(map) : 0);\n\t}\n\treturn 0;\n}\n\nstatic struct map *kernel_get_module_map(const char *module)\n{\n\tstruct maps *maps = machine__kernel_maps(host_machine);\n\tstruct map_rb_node *pos;\n\n\t \n\tif (module && strchr(module, '/'))\n\t\treturn dso__new_map(module);\n\n\tif (!module) {\n\t\tstruct map *map = machine__kernel_map(host_machine);\n\n\t\treturn map__get(map);\n\t}\n\n\tmaps__for_each_entry(maps, pos) {\n\t\t \n\t\tstruct dso *dso = map__dso(pos->map);\n\t\tconst char *short_name = dso->short_name;\n\t\tu16 short_name_len =  dso->short_name_len;\n\n\t\tif (strncmp(short_name + 1, module,\n\t\t\t    short_name_len - 2) == 0 &&\n\t\t    module[short_name_len - 2] == '\\0') {\n\t\t\treturn map__get(pos->map);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstruct map *get_target_map(const char *target, struct nsinfo *nsi, bool user)\n{\n\t \n\tif (user) {\n\t\tstruct map *map;\n\t\tstruct dso *dso;\n\n\t\tmap = dso__new_map(target);\n\t\tdso = map ? map__dso(map) : NULL;\n\t\tif (dso) {\n\t\t\tmutex_lock(&dso->lock);\n\t\t\tnsinfo__put(dso->nsinfo);\n\t\t\tdso->nsinfo = nsinfo__get(nsi);\n\t\t\tmutex_unlock(&dso->lock);\n\t\t}\n\t\treturn map;\n\t} else {\n\t\treturn kernel_get_module_map(target);\n\t}\n}\n\nstatic int convert_exec_to_group(const char *exec, char **result)\n{\n\tchar *ptr1, *ptr2, *exec_copy;\n\tchar buf[64];\n\tint ret;\n\n\texec_copy = strdup(exec);\n\tif (!exec_copy)\n\t\treturn -ENOMEM;\n\n\tptr1 = basename(exec_copy);\n\tif (!ptr1) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (ptr2 = ptr1; *ptr2 != '\\0'; ptr2++) {\n\t\tif (!isalnum(*ptr2) && *ptr2 != '_') {\n\t\t\t*ptr2 = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = e_snprintf(buf, 64, \"%s_%s\", PERFPROBE_GROUP, ptr1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*result = strdup(buf);\n\tret = *result ? 0 : -ENOMEM;\n\nout:\n\tfree(exec_copy);\n\treturn ret;\n}\n\nstatic void clear_perf_probe_point(struct perf_probe_point *pp)\n{\n\tzfree(&pp->file);\n\tzfree(&pp->function);\n\tzfree(&pp->lazy_line);\n}\n\nstatic void clear_probe_trace_events(struct probe_trace_event *tevs, int ntevs)\n{\n\tint i;\n\n\tfor (i = 0; i < ntevs; i++)\n\t\tclear_probe_trace_event(tevs + i);\n}\n\nstatic bool kprobe_blacklist__listed(u64 address);\nstatic bool kprobe_warn_out_range(const char *symbol, u64 address)\n{\n\tstruct map *map;\n\tbool ret = false;\n\n\tmap = kernel_get_module_map(NULL);\n\tif (map) {\n\t\tret = address <= map__start(map) || map__end(map) < address;\n\t\tif (ret)\n\t\t\tpr_warning(\"%s is out of .text, skip it.\\n\", symbol);\n\t\tmap__put(map);\n\t}\n\tif (!ret && kprobe_blacklist__listed(address)) {\n\t\tpr_warning(\"%s is blacklisted function, skip it.\\n\", symbol);\n\t\tret = true;\n\t}\n\n\treturn ret;\n}\n\n \nstatic char *find_module_name(const char *module)\n{\n\tint fd;\n\tElf *elf;\n\tGElf_Ehdr ehdr;\n\tGElf_Shdr shdr;\n\tElf_Data *data;\n\tElf_Scn *sec;\n\tchar *mod_name = NULL;\n\tint name_offset;\n\n\tfd = open(module, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\telf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tif (elf == NULL)\n\t\tgoto elf_err;\n\n\tif (gelf_getehdr(elf, &ehdr) == NULL)\n\t\tgoto ret_err;\n\n\tsec = elf_section_by_name(elf, &ehdr, &shdr,\n\t\t\t\".gnu.linkonce.this_module\", NULL);\n\tif (!sec)\n\t\tgoto ret_err;\n\n\tdata = elf_getdata(sec, NULL);\n\tif (!data || !data->d_buf)\n\t\tgoto ret_err;\n\n\t \n\tif (ehdr.e_ident[EI_CLASS] == ELFCLASS32)\n\t\tname_offset = 12;\n\telse\t \n\t\tname_offset = 24;\n\n\tmod_name = strdup((char *)data->d_buf + name_offset);\n\nret_err:\n\telf_end(elf);\nelf_err:\n\tclose(fd);\n\treturn mod_name;\n}\n\n#ifdef HAVE_DWARF_SUPPORT\n\nstatic int kernel_get_module_dso(const char *module, struct dso **pdso)\n{\n\tstruct dso *dso;\n\tstruct map *map;\n\tconst char *vmlinux_name;\n\tint ret = 0;\n\n\tif (module) {\n\t\tchar module_name[128];\n\n\t\tsnprintf(module_name, sizeof(module_name), \"[%s]\", module);\n\t\tmap = maps__find_by_name(machine__kernel_maps(host_machine), module_name);\n\t\tif (map) {\n\t\t\tdso = map__dso(map);\n\t\t\tgoto found;\n\t\t}\n\t\tpr_debug(\"Failed to find module %s.\\n\", module);\n\t\treturn -ENOENT;\n\t}\n\n\tmap = machine__kernel_map(host_machine);\n\tdso = map__dso(map);\n\tif (!dso->has_build_id)\n\t\tdso__read_running_kernel_build_id(dso, host_machine);\n\n\tvmlinux_name = symbol_conf.vmlinux_name;\n\tdso->load_errno = 0;\n\tif (vmlinux_name)\n\t\tret = dso__load_vmlinux(dso, map, vmlinux_name, false);\n\telse\n\t\tret = dso__load_vmlinux_path(dso, map);\nfound:\n\t*pdso = dso;\n\treturn ret;\n}\n\n \nstatic int find_alternative_probe_point(struct debuginfo *dinfo,\n\t\t\t\t\tstruct perf_probe_point *pp,\n\t\t\t\t\tstruct perf_probe_point *result,\n\t\t\t\t\tconst char *target, struct nsinfo *nsi,\n\t\t\t\t\tbool uprobes)\n{\n\tstruct map *map = NULL;\n\tstruct symbol *sym;\n\tu64 address = 0;\n\tint ret = -ENOENT;\n\tsize_t idx;\n\n\t \n\tif (!pp->function || pp->file)\n\t\treturn -ENOTSUP;\n\n\tmap = get_target_map(target, nsi, uprobes);\n\tif (!map)\n\t\treturn -EINVAL;\n\n\t \n\tmap__for_each_symbol_by_name(map, pp->function, sym, idx) {\n\t\tif (uprobes) {\n\t\t\taddress = sym->start;\n\t\t\tif (sym->type == STT_GNU_IFUNC)\n\t\t\t\tpr_warning(\"Warning: The probe function (%s) is a GNU indirect function.\\n\"\n\t\t\t\t\t   \"Consider identifying the final function used at run time and set the probe directly on that.\\n\",\n\t\t\t\t\t   pp->function);\n\t\t} else\n\t\t\taddress = map__unmap_ip(map, sym->start) - map__reloc(map);\n\t\tbreak;\n\t}\n\tif (!address) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tpr_debug(\"Symbol %s address found : %\" PRIx64 \"\\n\",\n\t\t\tpp->function, address);\n\n\tret = debuginfo__find_probe_point(dinfo, address, result);\n\tif (ret <= 0)\n\t\tret = (!ret) ? -ENOENT : ret;\n\telse {\n\t\tresult->offset += pp->offset;\n\t\tresult->line += pp->line;\n\t\tresult->retprobe = pp->retprobe;\n\t\tret = 0;\n\t}\n\nout:\n\tmap__put(map);\n\treturn ret;\n\n}\n\nstatic int get_alternative_probe_event(struct debuginfo *dinfo,\n\t\t\t\t       struct perf_probe_event *pev,\n\t\t\t\t       struct perf_probe_point *tmp)\n{\n\tint ret;\n\n\tmemcpy(tmp, &pev->point, sizeof(*tmp));\n\tmemset(&pev->point, 0, sizeof(pev->point));\n\tret = find_alternative_probe_point(dinfo, tmp, &pev->point, pev->target,\n\t\t\t\t\t   pev->nsi, pev->uprobes);\n\tif (ret < 0)\n\t\tmemcpy(&pev->point, tmp, sizeof(*tmp));\n\n\treturn ret;\n}\n\nstatic int get_alternative_line_range(struct debuginfo *dinfo,\n\t\t\t\t      struct line_range *lr,\n\t\t\t\t      const char *target, bool user)\n{\n\tstruct perf_probe_point pp = { .function = lr->function,\n\t\t\t\t       .file = lr->file,\n\t\t\t\t       .line = lr->start };\n\tstruct perf_probe_point result;\n\tint ret, len = 0;\n\n\tmemset(&result, 0, sizeof(result));\n\n\tif (lr->end != INT_MAX)\n\t\tlen = lr->end - lr->start;\n\tret = find_alternative_probe_point(dinfo, &pp, &result,\n\t\t\t\t\t   target, NULL, user);\n\tif (!ret) {\n\t\tlr->function = result.function;\n\t\tlr->file = result.file;\n\t\tlr->start = result.line;\n\t\tif (lr->end != INT_MAX)\n\t\t\tlr->end = lr->start + len;\n\t\tclear_perf_probe_point(&pp);\n\t}\n\treturn ret;\n}\n\n#ifdef HAVE_DEBUGINFOD_SUPPORT\nstatic struct debuginfo *open_from_debuginfod(struct dso *dso, struct nsinfo *nsi,\n\t\t\t\t\t      bool silent)\n{\n\tdebuginfod_client *c = debuginfod_begin();\n\tchar sbuild_id[SBUILD_ID_SIZE + 1];\n\tstruct debuginfo *ret = NULL;\n\tstruct nscookie nsc;\n\tchar *path;\n\tint fd;\n\n\tif (!c)\n\t\treturn NULL;\n\n\tbuild_id__sprintf(&dso->bid, sbuild_id);\n\tfd = debuginfod_find_debuginfo(c, (const unsigned char *)sbuild_id,\n\t\t\t\t\t0, &path);\n\tif (fd >= 0)\n\t\tclose(fd);\n\tdebuginfod_end(c);\n\tif (fd < 0) {\n\t\tif (!silent)\n\t\t\tpr_debug(\"Failed to find debuginfo in debuginfod.\\n\");\n\t\treturn NULL;\n\t}\n\tif (!silent)\n\t\tpr_debug(\"Load debuginfo from debuginfod (%s)\\n\", path);\n\n\tnsinfo__mountns_enter(nsi, &nsc);\n\tret = debuginfo__new((const char *)path);\n\tnsinfo__mountns_exit(&nsc);\n\treturn ret;\n}\n#else\nstatic inline\nstruct debuginfo *open_from_debuginfod(struct dso *dso __maybe_unused,\n\t\t\t\t       struct nsinfo *nsi __maybe_unused,\n\t\t\t\t       bool silent __maybe_unused)\n{\n\treturn NULL;\n}\n#endif\n\n \nstatic struct debuginfo *open_debuginfo(const char *module, struct nsinfo *nsi,\n\t\t\t\t\tbool silent)\n{\n\tconst char *path = module;\n\tchar reason[STRERR_BUFSIZE];\n\tstruct debuginfo *ret = NULL;\n\tstruct dso *dso = NULL;\n\tstruct nscookie nsc;\n\tint err;\n\n\tif (!module || !strchr(module, '/')) {\n\t\terr = kernel_get_module_dso(module, &dso);\n\t\tif (err < 0) {\n\t\t\tif (!dso || dso->load_errno == 0) {\n\t\t\t\tif (!str_error_r(-err, reason, STRERR_BUFSIZE))\n\t\t\t\t\tstrcpy(reason, \"(unknown)\");\n\t\t\t} else\n\t\t\t\tdso__strerror_load(dso, reason, STRERR_BUFSIZE);\n\t\t\tif (dso)\n\t\t\t\tret = open_from_debuginfod(dso, nsi, silent);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (!silent) {\n\t\t\t\tif (module)\n\t\t\t\t\tpr_err(\"Module %s is not loaded, please specify its full path name.\\n\", module);\n\t\t\t\telse\n\t\t\t\t\tpr_err(\"Failed to find the path for the kernel: %s\\n\", reason);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tpath = dso->long_name;\n\t}\n\tnsinfo__mountns_enter(nsi, &nsc);\n\tret = debuginfo__new(path);\n\tif (!ret && !silent) {\n\t\tpr_warning(\"The %s file has no debug information.\\n\", path);\n\t\tif (!module || !strtailcmp(path, \".ko\"))\n\t\t\tpr_warning(\"Rebuild with CONFIG_DEBUG_INFO=y, \");\n\t\telse\n\t\t\tpr_warning(\"Rebuild with -g, \");\n\t\tpr_warning(\"or install an appropriate debuginfo package.\\n\");\n\t}\n\tnsinfo__mountns_exit(&nsc);\n\treturn ret;\n}\n\n \nstatic struct debuginfo *debuginfo_cache;\nstatic char *debuginfo_cache_path;\n\nstatic struct debuginfo *debuginfo_cache__open(const char *module, bool silent)\n{\n\tconst char *path = module;\n\n\t \n\tif (!module)\n\t\tpath = \"kernel\";\n\n\tif (debuginfo_cache_path && !strcmp(debuginfo_cache_path, path))\n\t\tgoto out;\n\n\t \n\tfree(debuginfo_cache_path);\n\tdebuginfo_cache_path = strdup(path);\n\tif (!debuginfo_cache_path) {\n\t\tdebuginfo__delete(debuginfo_cache);\n\t\tdebuginfo_cache = NULL;\n\t\tgoto out;\n\t}\n\n\tdebuginfo_cache = open_debuginfo(module, NULL, silent);\n\tif (!debuginfo_cache)\n\t\tzfree(&debuginfo_cache_path);\nout:\n\treturn debuginfo_cache;\n}\n\nstatic void debuginfo_cache__exit(void)\n{\n\tdebuginfo__delete(debuginfo_cache);\n\tdebuginfo_cache = NULL;\n\tzfree(&debuginfo_cache_path);\n}\n\n\nstatic int get_text_start_address(const char *exec, u64 *address,\n\t\t\t\t  struct nsinfo *nsi)\n{\n\tElf *elf;\n\tGElf_Ehdr ehdr;\n\tGElf_Shdr shdr;\n\tint fd, ret = -ENOENT;\n\tstruct nscookie nsc;\n\n\tnsinfo__mountns_enter(nsi, &nsc);\n\tfd = open(exec, O_RDONLY);\n\tnsinfo__mountns_exit(&nsc);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\telf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tif (elf == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out_close;\n\t}\n\n\tif (gelf_getehdr(elf, &ehdr) == NULL)\n\t\tgoto out;\n\n\tif (!elf_section_by_name(elf, &ehdr, &shdr, \".text\", NULL))\n\t\tgoto out;\n\n\t*address = shdr.sh_addr - shdr.sh_offset;\n\tret = 0;\nout:\n\telf_end(elf);\nout_close:\n\tclose(fd);\n\n\treturn ret;\n}\n\n \nstatic int find_perf_probe_point_from_dwarf(struct probe_trace_point *tp,\n\t\t\t\t\t    struct perf_probe_point *pp,\n\t\t\t\t\t    bool is_kprobe)\n{\n\tstruct debuginfo *dinfo = NULL;\n\tu64 stext = 0;\n\tu64 addr = tp->address;\n\tint ret = -ENOENT;\n\n\t \n\tif (!is_kprobe) {\n\t\tif (!addr) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tret = get_text_start_address(tp->module, &stext, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\taddr += stext;\n\t} else if (tp->symbol) {\n\t\t \n\t\tret = kernel_get_symbol_address_by_name(tp->symbol, &addr,\n\t\t\t\t\t\t\tfalse, !!tp->module);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t\taddr += tp->offset;\n\t}\n\n\tpr_debug(\"try to find information at %\" PRIx64 \" in %s\\n\", addr,\n\t\t tp->module ? : \"kernel\");\n\n\tdinfo = debuginfo_cache__open(tp->module, verbose <= 0);\n\tif (dinfo)\n\t\tret = debuginfo__find_probe_point(dinfo, addr, pp);\n\telse\n\t\tret = -ENOENT;\n\n\tif (ret > 0) {\n\t\tpp->retprobe = tp->retprobe;\n\t\treturn 0;\n\t}\nerror:\n\tpr_debug(\"Failed to find corresponding probes from debuginfo.\\n\");\n\treturn ret ? : -ENOENT;\n}\n\n \nstatic int post_process_probe_trace_point(struct probe_trace_point *tp,\n\t\t\t\t\t   struct map *map, u64 offs)\n{\n\tstruct symbol *sym;\n\tu64 addr = tp->address - offs;\n\n\tsym = map__find_symbol(map, addr);\n\tif (!sym) {\n\t\t \n\t\treturn (symbol_conf.ignore_vmlinux_buildid) ? 0 : -ENOENT;\n\t}\n\n\tif (strcmp(sym->name, tp->symbol)) {\n\t\t \n\t\tif (!tp->realname)\n\t\t\ttp->realname = tp->symbol;\n\t\telse\n\t\t\tfree(tp->symbol);\n\t\ttp->symbol = strdup(sym->name);\n\t\tif (!tp->symbol)\n\t\t\treturn -ENOMEM;\n\t}\n\ttp->offset = addr - sym->start;\n\ttp->address -= offs;\n\n\treturn 0;\n}\n\n \nstatic int\npost_process_offline_probe_trace_events(struct probe_trace_event *tevs,\n\t\t\t\t\tint ntevs, const char *pathname)\n{\n\tstruct map *map;\n\tu64 stext = 0;\n\tint i, ret = 0;\n\n\t \n\tmap = dso__new_map(pathname);\n\tif (!map || get_text_start_address(pathname, &stext, NULL) < 0) {\n\t\tpr_warning(\"Failed to get ELF symbols for %s\\n\", pathname);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ntevs; i++) {\n\t\tret = post_process_probe_trace_point(&tevs[i].point,\n\t\t\t\t\t\t     map, stext);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tmap__put(map);\n\n\treturn ret;\n}\n\nstatic int add_exec_to_probe_trace_events(struct probe_trace_event *tevs,\n\t\t\t\t\t  int ntevs, const char *exec,\n\t\t\t\t\t  struct nsinfo *nsi)\n{\n\tint i, ret = 0;\n\tu64 stext = 0;\n\n\tif (!exec)\n\t\treturn 0;\n\n\tret = get_text_start_address(exec, &stext, nsi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ntevs && ret >= 0; i++) {\n\t\t \n\t\ttevs[i].point.address -= stext;\n\t\ttevs[i].point.module = strdup(exec);\n\t\tif (!tevs[i].point.module) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\ttevs[i].uprobes = true;\n\t}\n\n\treturn ret;\n}\n\nstatic int\npost_process_module_probe_trace_events(struct probe_trace_event *tevs,\n\t\t\t\t       int ntevs, const char *module,\n\t\t\t\t       struct debuginfo *dinfo)\n{\n\tDwarf_Addr text_offs = 0;\n\tint i, ret = 0;\n\tchar *mod_name = NULL;\n\tstruct map *map;\n\n\tif (!module)\n\t\treturn 0;\n\n\tmap = get_target_map(module, NULL, false);\n\tif (!map || debuginfo__get_text_offset(dinfo, &text_offs, true) < 0) {\n\t\tpr_warning(\"Failed to get ELF symbols for %s\\n\", module);\n\t\treturn -EINVAL;\n\t}\n\n\tmod_name = find_module_name(module);\n\tfor (i = 0; i < ntevs; i++) {\n\t\tret = post_process_probe_trace_point(&tevs[i].point,\n\t\t\t\t\t\tmap, text_offs);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\ttevs[i].point.module =\n\t\t\tstrdup(mod_name ? mod_name : module);\n\t\tif (!tevs[i].point.module) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(mod_name);\n\tmap__put(map);\n\n\treturn ret;\n}\n\nstatic int\npost_process_kernel_probe_trace_events(struct probe_trace_event *tevs,\n\t\t\t\t       int ntevs)\n{\n\tstruct ref_reloc_sym *reloc_sym;\n\tstruct map *map;\n\tchar *tmp;\n\tint i, skipped = 0;\n\n\t \n\tif (symbol_conf.ignore_vmlinux_buildid)\n\t\treturn post_process_offline_probe_trace_events(tevs, ntevs,\n\t\t\t\t\t\tsymbol_conf.vmlinux_name);\n\n\treloc_sym = kernel_get_ref_reloc_sym(&map);\n\tif (!reloc_sym) {\n\t\tpr_warning(\"Relocated base symbol is not found! \"\n\t\t\t   \"Check /proc/sys/kernel/kptr_restrict\\n\"\n\t\t\t   \"and /proc/sys/kernel/perf_event_paranoid. \"\n\t\t\t   \"Or run as privileged perf user.\\n\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ntevs; i++) {\n\t\tif (!tevs[i].point.address)\n\t\t\tcontinue;\n\t\tif (tevs[i].point.retprobe && !kretprobe_offset_is_supported())\n\t\t\tcontinue;\n\t\t \n\t\tif (kprobe_warn_out_range(tevs[i].point.symbol,\n\t\t\tmap__objdump_2mem(map, tevs[i].point.address))) {\n\t\t\ttmp = NULL;\n\t\t\tskipped++;\n\t\t} else {\n\t\t\ttmp = strdup(reloc_sym->name);\n\t\t\tif (!tmp)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\t \n\t\tif (!tevs[i].point.realname)\n\t\t\ttevs[i].point.realname = tevs[i].point.symbol;\n\t\telse\n\t\t\tfree(tevs[i].point.symbol);\n\t\ttevs[i].point.symbol = tmp;\n\t\ttevs[i].point.offset = tevs[i].point.address -\n\t\t\t(map__reloc(map) ? reloc_sym->unrelocated_addr :\n\t\t\t\t      reloc_sym->addr);\n\t}\n\treturn skipped;\n}\n\nvoid __weak\narch__post_process_probe_trace_events(struct perf_probe_event *pev __maybe_unused,\n\t\t\t\t      int ntevs __maybe_unused)\n{\n}\n\n \nstatic int post_process_probe_trace_events(struct perf_probe_event *pev,\n\t\t\t\t\t   struct probe_trace_event *tevs,\n\t\t\t\t\t   int ntevs, const char *module,\n\t\t\t\t\t   bool uprobe, struct debuginfo *dinfo)\n{\n\tint ret;\n\n\tif (uprobe)\n\t\tret = add_exec_to_probe_trace_events(tevs, ntevs, module,\n\t\t\t\t\t\t     pev->nsi);\n\telse if (module)\n\t\t \n\t\tret = post_process_module_probe_trace_events(tevs, ntevs,\n\t\t\t\t\t\t\t     module, dinfo);\n\telse\n\t\tret = post_process_kernel_probe_trace_events(tevs, ntevs);\n\n\tif (ret >= 0)\n\t\tarch__post_process_probe_trace_events(pev, ntevs);\n\n\treturn ret;\n}\n\n \nstatic int try_to_find_probe_trace_events(struct perf_probe_event *pev,\n\t\t\t\t\t  struct probe_trace_event **tevs)\n{\n\tbool need_dwarf = perf_probe_event_need_dwarf(pev);\n\tstruct perf_probe_point tmp;\n\tstruct debuginfo *dinfo;\n\tint ntevs, ret = 0;\n\n\t \n\tif (pev->point.retprobe)\n\t\treturn 0;\n\n\tdinfo = open_debuginfo(pev->target, pev->nsi, !need_dwarf);\n\tif (!dinfo) {\n\t\tif (need_dwarf)\n\t\t\treturn -ENODATA;\n\t\tpr_debug(\"Could not open debuginfo. Try to use symbols.\\n\");\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"Try to find probe point from debuginfo.\\n\");\n\t \n\tntevs = debuginfo__find_trace_events(dinfo, pev, tevs);\n\n\tif (ntevs == 0)\t{   \n\t\tret = get_alternative_probe_event(dinfo, pev, &tmp);\n\t\tif (!ret) {\n\t\t\tntevs = debuginfo__find_trace_events(dinfo, pev, tevs);\n\t\t\t \n\t\t\tclear_perf_probe_point(&pev->point);\n\t\t\tmemcpy(&pev->point, &tmp, sizeof(tmp));\n\t\t}\n\t}\n\n\tif (ntevs > 0) {\t \n\t\tpr_debug(\"Found %d probe_trace_events.\\n\", ntevs);\n\t\tret = post_process_probe_trace_events(pev, *tevs, ntevs,\n\t\t\t\t\tpev->target, pev->uprobes, dinfo);\n\t\tif (ret < 0 || ret == ntevs) {\n\t\t\tpr_debug(\"Post processing failed or all events are skipped. (%d)\\n\", ret);\n\t\t\tclear_probe_trace_events(*tevs, ntevs);\n\t\t\tzfree(tevs);\n\t\t\tntevs = 0;\n\t\t}\n\t}\n\n\tdebuginfo__delete(dinfo);\n\n\tif (ntevs == 0)\t{\t \n\t\tchar *probe_point = synthesize_perf_probe_point(&pev->point);\n\t\tpr_warning(\"Probe point '%s' not found.\\n\", probe_point);\n\t\tfree(probe_point);\n\t\treturn -ENODEV;\n\t} else if (ntevs < 0) {\n\t\t \n\t\tpr_debug(\"An error occurred in debuginfo analysis (%d).\\n\", ntevs);\n\t\tif (ntevs == -EBADF)\n\t\t\tpr_warning(\"Warning: No dwarf info found in the vmlinux - \"\n\t\t\t\t\"please rebuild kernel with CONFIG_DEBUG_INFO=y.\\n\");\n\t\tif (!need_dwarf) {\n\t\t\tpr_debug(\"Trying to use symbols.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn ntevs;\n}\n\n#define LINEBUF_SIZE 256\n#define NR_ADDITIONAL_LINES 2\n\nstatic int __show_one_line(FILE *fp, int l, bool skip, bool show_num)\n{\n\tchar buf[LINEBUF_SIZE], sbuf[STRERR_BUFSIZE];\n\tconst char *color = show_num ? \"\" : PERF_COLOR_BLUE;\n\tconst char *prefix = NULL;\n\n\tdo {\n\t\tif (fgets(buf, LINEBUF_SIZE, fp) == NULL)\n\t\t\tgoto error;\n\t\tif (skip)\n\t\t\tcontinue;\n\t\tif (!prefix) {\n\t\t\tprefix = show_num ? \"%7d  \" : \"         \";\n\t\t\tcolor_fprintf(stdout, color, prefix, l);\n\t\t}\n\t\tcolor_fprintf(stdout, color, \"%s\", buf);\n\n\t} while (strchr(buf, '\\n') == NULL);\n\n\treturn 1;\nerror:\n\tif (ferror(fp)) {\n\t\tpr_warning(\"File read error: %s\\n\",\n\t\t\t   str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int _show_one_line(FILE *fp, int l, bool skip, bool show_num)\n{\n\tint rv = __show_one_line(fp, l, skip, show_num);\n\tif (rv == 0) {\n\t\tpr_warning(\"Source file is shorter than expected.\\n\");\n\t\trv = -1;\n\t}\n\treturn rv;\n}\n\n#define show_one_line_with_num(f,l)\t_show_one_line(f,l,false,true)\n#define show_one_line(f,l)\t\t_show_one_line(f,l,false,false)\n#define skip_one_line(f,l)\t\t_show_one_line(f,l,true,false)\n#define show_one_line_or_eof(f,l)\t__show_one_line(f,l,false,false)\n\n \nstatic int __show_line_range(struct line_range *lr, const char *module,\n\t\t\t     bool user)\n{\n\tstruct build_id bid;\n\tint l = 1;\n\tstruct int_node *ln;\n\tstruct debuginfo *dinfo;\n\tFILE *fp;\n\tint ret;\n\tchar *tmp;\n\tchar sbuf[STRERR_BUFSIZE];\n\tchar sbuild_id[SBUILD_ID_SIZE] = \"\";\n\n\t \n\tdinfo = open_debuginfo(module, NULL, false);\n\tif (!dinfo)\n\t\treturn -ENOENT;\n\n\tret = debuginfo__find_line_range(dinfo, lr);\n\tif (!ret) {\t \n\t\tret = get_alternative_line_range(dinfo, lr, module, user);\n\t\tif (!ret)\n\t\t\tret = debuginfo__find_line_range(dinfo, lr);\n\t}\n\tif (dinfo->build_id) {\n\t\tbuild_id__init(&bid, dinfo->build_id, BUILD_ID_SIZE);\n\t\tbuild_id__sprintf(&bid, sbuild_id);\n\t}\n\tdebuginfo__delete(dinfo);\n\tif (ret == 0 || ret == -ENOENT) {\n\t\tpr_warning(\"Specified source line is not found.\\n\");\n\t\treturn -ENOENT;\n\t} else if (ret < 0) {\n\t\tpr_warning(\"Debuginfo analysis failed.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\ttmp = lr->path;\n\tret = find_source_path(tmp, sbuild_id, lr->comp_dir, &lr->path);\n\n\t \n\tif (tmp != lr->path)\n\t\tfree(tmp);\n\n\tif (ret < 0) {\n\t\tpr_warning(\"Failed to find source file path.\\n\");\n\t\treturn ret;\n\t}\n\n\tsetup_pager();\n\n\tif (lr->function)\n\t\tfprintf(stdout, \"<%s@%s:%d>\\n\", lr->function, lr->path,\n\t\t\tlr->start - lr->offset);\n\telse\n\t\tfprintf(stdout, \"<%s:%d>\\n\", lr->path, lr->start);\n\n\tfp = fopen(lr->path, \"r\");\n\tif (fp == NULL) {\n\t\tpr_warning(\"Failed to open %s: %s\\n\", lr->path,\n\t\t\t   str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\treturn -errno;\n\t}\n\t \n\twhile (l < lr->start) {\n\t\tret = skip_one_line(fp, l++);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t}\n\n\tintlist__for_each_entry(ln, lr->line_list) {\n\t\tfor (; ln->i > (unsigned long)l; l++) {\n\t\t\tret = show_one_line(fp, l - lr->offset);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto end;\n\t\t}\n\t\tret = show_one_line_with_num(fp, l++ - lr->offset);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t}\n\n\tif (lr->end == INT_MAX)\n\t\tlr->end = l + NR_ADDITIONAL_LINES;\n\twhile (l <= lr->end) {\n\t\tret = show_one_line_or_eof(fp, l++ - lr->offset);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t}\nend:\n\tfclose(fp);\n\treturn ret;\n}\n\nint show_line_range(struct line_range *lr, const char *module,\n\t\t    struct nsinfo *nsi, bool user)\n{\n\tint ret;\n\tstruct nscookie nsc;\n\n\tret = init_probe_symbol_maps(user);\n\tif (ret < 0)\n\t\treturn ret;\n\tnsinfo__mountns_enter(nsi, &nsc);\n\tret = __show_line_range(lr, module, user);\n\tnsinfo__mountns_exit(&nsc);\n\texit_probe_symbol_maps();\n\n\treturn ret;\n}\n\nstatic int show_available_vars_at(struct debuginfo *dinfo,\n\t\t\t\t  struct perf_probe_event *pev,\n\t\t\t\t  struct strfilter *_filter)\n{\n\tchar *buf;\n\tint ret, i, nvars;\n\tstruct str_node *node;\n\tstruct variable_list *vls = NULL, *vl;\n\tstruct perf_probe_point tmp;\n\tconst char *var;\n\n\tbuf = synthesize_perf_probe_point(&pev->point);\n\tif (!buf)\n\t\treturn -EINVAL;\n\tpr_debug(\"Searching variables at %s\\n\", buf);\n\n\tret = debuginfo__find_available_vars_at(dinfo, pev, &vls);\n\tif (!ret) {   \n\t\tret = get_alternative_probe_event(dinfo, pev, &tmp);\n\t\tif (!ret) {\n\t\t\tret = debuginfo__find_available_vars_at(dinfo, pev,\n\t\t\t\t\t\t\t\t&vls);\n\t\t\t \n\t\t\tclear_perf_probe_point(&tmp);\n\t\t}\n\t}\n\tif (ret <= 0) {\n\t\tif (ret == 0 || ret == -ENOENT) {\n\t\t\tpr_err(\"Failed to find the address of %s\\n\", buf);\n\t\t\tret = -ENOENT;\n\t\t} else\n\t\t\tpr_warning(\"Debuginfo analysis failed.\\n\");\n\t\tgoto end;\n\t}\n\n\t \n\tfprintf(stdout, \"Available variables at %s\\n\", buf);\n\tfor (i = 0; i < ret; i++) {\n\t\tvl = &vls[i];\n\t\t \n\t\tfprintf(stdout, \"\\t@<%s+%lu>\\n\", vl->point.symbol,\n\t\t\tvl->point.offset);\n\t\tzfree(&vl->point.symbol);\n\t\tnvars = 0;\n\t\tif (vl->vars) {\n\t\t\tstrlist__for_each_entry(node, vl->vars) {\n\t\t\t\tvar = strchr(node->s, '\\t') + 1;\n\t\t\t\tif (strfilter__compare(_filter, var)) {\n\t\t\t\t\tfprintf(stdout, \"\\t\\t%s\\n\", node->s);\n\t\t\t\t\tnvars++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrlist__delete(vl->vars);\n\t\t}\n\t\tif (nvars == 0)\n\t\t\tfprintf(stdout, \"\\t\\t(No matched variables)\\n\");\n\t}\n\tfree(vls);\nend:\n\tfree(buf);\n\treturn ret;\n}\n\n \nint show_available_vars(struct perf_probe_event *pevs, int npevs,\n\t\t\tstruct strfilter *_filter)\n{\n\tint i, ret = 0;\n\tstruct debuginfo *dinfo;\n\n\tret = init_probe_symbol_maps(pevs->uprobes);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdinfo = open_debuginfo(pevs->target, pevs->nsi, false);\n\tif (!dinfo) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tsetup_pager();\n\n\tfor (i = 0; i < npevs && ret >= 0; i++)\n\t\tret = show_available_vars_at(dinfo, &pevs[i], _filter);\n\n\tdebuginfo__delete(dinfo);\nout:\n\texit_probe_symbol_maps();\n\treturn ret;\n}\n\n#else\t \n\nstatic void debuginfo_cache__exit(void)\n{\n}\n\nstatic int\nfind_perf_probe_point_from_dwarf(struct probe_trace_point *tp __maybe_unused,\n\t\t\t\t struct perf_probe_point *pp __maybe_unused,\n\t\t\t\t bool is_kprobe __maybe_unused)\n{\n\treturn -ENOSYS;\n}\n\nstatic int try_to_find_probe_trace_events(struct perf_probe_event *pev,\n\t\t\t\tstruct probe_trace_event **tevs __maybe_unused)\n{\n\tif (perf_probe_event_need_dwarf(pev)) {\n\t\tpr_warning(\"Debuginfo-analysis is not supported.\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nint show_line_range(struct line_range *lr __maybe_unused,\n\t\t    const char *module __maybe_unused,\n\t\t    struct nsinfo *nsi __maybe_unused,\n\t\t    bool user __maybe_unused)\n{\n\tpr_warning(\"Debuginfo-analysis is not supported.\\n\");\n\treturn -ENOSYS;\n}\n\nint show_available_vars(struct perf_probe_event *pevs __maybe_unused,\n\t\t\tint npevs __maybe_unused,\n\t\t\tstruct strfilter *filter __maybe_unused)\n{\n\tpr_warning(\"Debuginfo-analysis is not supported.\\n\");\n\treturn -ENOSYS;\n}\n#endif\n\nvoid line_range__clear(struct line_range *lr)\n{\n\tzfree(&lr->function);\n\tzfree(&lr->file);\n\tzfree(&lr->path);\n\tzfree(&lr->comp_dir);\n\tintlist__delete(lr->line_list);\n}\n\nint line_range__init(struct line_range *lr)\n{\n\tmemset(lr, 0, sizeof(*lr));\n\tlr->line_list = intlist__new(NULL);\n\tif (!lr->line_list)\n\t\treturn -ENOMEM;\n\telse\n\t\treturn 0;\n}\n\nstatic int parse_line_num(char **ptr, int *val, const char *what)\n{\n\tconst char *start = *ptr;\n\n\terrno = 0;\n\t*val = strtol(*ptr, ptr, 0);\n\tif (errno || *ptr == start) {\n\t\tsemantic_error(\"'%s' is not a valid number.\\n\", what);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic bool is_c_func_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nint parse_line_range_desc(const char *arg, struct line_range *lr)\n{\n\tchar *range, *file, *name = strdup(arg);\n\tint err;\n\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tlr->start = 0;\n\tlr->end = INT_MAX;\n\n\trange = strchr(name, ':');\n\tif (range) {\n\t\t*range++ = '\\0';\n\n\t\terr = parse_line_num(&range, &lr->start, \"start line\");\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tif (*range == '+' || *range == '-') {\n\t\t\tconst char c = *range++;\n\n\t\t\terr = parse_line_num(&range, &lr->end, \"end line\");\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tif (c == '+') {\n\t\t\t\tlr->end += lr->start;\n\t\t\t\t \n\t\t\t\tlr->end--;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"Line range is %d to %d\\n\", lr->start, lr->end);\n\n\t\terr = -EINVAL;\n\t\tif (lr->start > lr->end) {\n\t\t\tsemantic_error(\"Start line must be smaller\"\n\t\t\t\t       \" than end line.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (*range != '\\0') {\n\t\t\tsemantic_error(\"Tailing with invalid str '%s'.\\n\", range);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tfile = strchr(name, '@');\n\tif (file) {\n\t\t*file = '\\0';\n\t\tlr->file = strdup(++file);\n\t\tif (lr->file == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tlr->function = name;\n\t} else if (strchr(name, '/') || strchr(name, '.'))\n\t\tlr->file = name;\n\telse if (is_c_func_name(name)) \n\t\tlr->function = name;\n\telse {\t \n\t\tsemantic_error(\"'%s' is not a valid function name.\\n\", name);\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tfree(name);\n\treturn err;\n}\n\nstatic int parse_perf_probe_event_name(char **arg, struct perf_probe_event *pev)\n{\n\tchar *ptr;\n\n\tptr = strpbrk_esc(*arg, \":\");\n\tif (ptr) {\n\t\t*ptr = '\\0';\n\t\tif (!pev->sdt && !is_c_func_name(*arg))\n\t\t\tgoto ng_name;\n\t\tpev->group = strdup_esc(*arg);\n\t\tif (!pev->group)\n\t\t\treturn -ENOMEM;\n\t\t*arg = ptr + 1;\n\t} else\n\t\tpev->group = NULL;\n\n\tpev->event = strdup_esc(*arg);\n\tif (pev->event == NULL)\n\t\treturn -ENOMEM;\n\n\tif (!pev->sdt && !is_c_func_name(pev->event)) {\n\t\tzfree(&pev->event);\nng_name:\n\t\tzfree(&pev->group);\n\t\tsemantic_error(\"%s is bad for event name -it must \"\n\t\t\t       \"follow C symbol-naming rule.\\n\", *arg);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int parse_perf_probe_point(char *arg, struct perf_probe_event *pev)\n{\n\tstruct perf_probe_point *pp = &pev->point;\n\tchar *ptr, *tmp;\n\tchar c, nc = 0;\n\tbool file_spec = false;\n\tint ret;\n\n\t \n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tif (is_sdt_event(arg)) {\n\t\tpev->sdt = true;\n\t\tif (arg[0] == '%')\n\t\t\targ++;\n\t}\n\n\tptr = strpbrk_esc(arg, \";=@+%\");\n\tif (pev->sdt) {\n\t\tif (ptr) {\n\t\t\tif (*ptr != '@') {\n\t\t\t\tsemantic_error(\"%s must be an SDT name.\\n\",\n\t\t\t\t\t       arg);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\ttmp = build_id_cache__complement(ptr + 1);\n\t\t\tif (tmp) {\n\t\t\t\tpev->target = build_id_cache__origname(tmp);\n\t\t\t\tfree(tmp);\n\t\t\t} else\n\t\t\t\tpev->target = strdup_esc(ptr + 1);\n\t\t\tif (!pev->target)\n\t\t\t\treturn -ENOMEM;\n\t\t\t*ptr = '\\0';\n\t\t}\n\t\tret = parse_perf_probe_event_name(&arg, pev);\n\t\tif (ret == 0) {\n\t\t\tif (asprintf(&pev->point.function, \"%%%s\", pev->event) < 0)\n\t\t\t\tret = -errno;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (ptr && *ptr == '=') {\t \n\t\t*ptr = '\\0';\n\t\ttmp = ptr + 1;\n\t\tret = parse_perf_probe_event_name(&arg, pev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\targ = tmp;\n\t}\n\n\t \n\tif (!strpbrk_esc(arg, \"+@%\")) {\n\t\tptr = strpbrk_esc(arg, \";:\");\n\t\t \n\t\tif (ptr && memchr(arg, '.', ptr - arg))\n\t\t\tfile_spec = true;\n\t}\n\n\tptr = strpbrk_esc(arg, \";:+@%\");\n\tif (ptr) {\n\t\tnc = *ptr;\n\t\t*ptr++ = '\\0';\n\t}\n\n\tif (arg[0] == '\\0')\n\t\ttmp = NULL;\n\telse {\n\t\ttmp = strdup_esc(arg);\n\t\tif (tmp == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (file_spec)\n\t\tpp->file = tmp;\n\telse {\n\t\tpp->function = tmp;\n\n\t\t \n\t\tif (tmp && !strncmp(tmp, \"0x\", 2)) {\n\t\t\tpp->abs_address = strtoull(pp->function, &tmp, 0);\n\t\t\tif (*tmp != '\\0') {\n\t\t\t\tsemantic_error(\"Invalid absolute address.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\twhile (ptr) {\n\t\targ = ptr;\n\t\tc = nc;\n\t\tif (c == ';') {\t \n\t\t\tpp->lazy_line = strdup(arg);  \n\t\t\tif (pp->lazy_line == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tptr = strpbrk_esc(arg, \";:+@%\");\n\t\tif (ptr) {\n\t\t\tnc = *ptr;\n\t\t\t*ptr++ = '\\0';\n\t\t}\n\t\tswitch (c) {\n\t\tcase ':':\t \n\t\t\tpp->line = strtoul(arg, &tmp, 0);\n\t\t\tif (*tmp != '\\0') {\n\t\t\t\tsemantic_error(\"There is non-digit char\"\n\t\t\t\t\t       \" in line number.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '+':\t \n\t\t\tpp->offset = strtoul(arg, &tmp, 0);\n\t\t\tif (*tmp != '\\0') {\n\t\t\t\tsemantic_error(\"There is non-digit character\"\n\t\t\t\t\t\t\" in offset.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '@':\t \n\t\t\tif (pp->file) {\n\t\t\t\tsemantic_error(\"SRC@SRC is not allowed.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpp->file = strdup_esc(arg);\n\t\t\tif (pp->file == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\t\tcase '%':\t \n\t\t\tif (strcmp(arg, \"return\") == 0) {\n\t\t\t\tpp->retprobe = 1;\n\t\t\t} else {\t \n\t\t\t\tsemantic_error(\"%%%s is not supported.\\n\", arg);\n\t\t\t\treturn -ENOTSUP;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\t \n\t\t\tpr_err(\"This program has a bug at %s:%d.\\n\",\n\t\t\t\t__FILE__, __LINE__);\n\t\t\treturn -ENOTSUP;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (pp->lazy_line && pp->line) {\n\t\tsemantic_error(\"Lazy pattern can't be used with\"\n\t\t\t       \" line number.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pp->lazy_line && pp->offset) {\n\t\tsemantic_error(\"Lazy pattern can't be used with offset.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pp->line && pp->offset) {\n\t\tsemantic_error(\"Offset can't be used with line number.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pp->line && !pp->lazy_line && pp->file && !pp->function) {\n\t\tsemantic_error(\"File always requires line number or \"\n\t\t\t       \"lazy pattern.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pp->offset && !pp->function) {\n\t\tsemantic_error(\"Offset requires an entry function.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((pp->offset || pp->line || pp->lazy_line) && pp->retprobe) {\n\t\tsemantic_error(\"Offset/Line/Lazy pattern can't be used with \"\n\t\t\t       \"return probe.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"symbol:%s file:%s line:%d offset:%lu return:%d lazy:%s\\n\",\n\t\t pp->function, pp->file, pp->line, pp->offset, pp->retprobe,\n\t\t pp->lazy_line);\n\treturn 0;\n}\n\n \nstatic int parse_perf_probe_arg(char *str, struct perf_probe_arg *arg)\n{\n\tchar *tmp, *goodname;\n\tstruct perf_probe_arg_field **fieldp;\n\n\tpr_debug(\"parsing arg: %s into \", str);\n\n\ttmp = strchr(str, '=');\n\tif (tmp) {\n\t\targ->name = strndup(str, tmp - str);\n\t\tif (arg->name == NULL)\n\t\t\treturn -ENOMEM;\n\t\tpr_debug(\"name:%s \", arg->name);\n\t\tstr = tmp + 1;\n\t}\n\n\ttmp = strchr(str, '@');\n\tif (tmp && tmp != str && !strcmp(tmp + 1, \"user\")) {  \n\t\tif (!user_access_is_supported()) {\n\t\t\tsemantic_error(\"ftrace does not support user access\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*tmp = '\\0';\n\t\targ->user_access = true;\n\t\tpr_debug(\"user_access \");\n\t}\n\n\ttmp = strchr(str, ':');\n\tif (tmp) {\t \n\t\t*tmp = '\\0';\n\t\targ->type = strdup(tmp + 1);\n\t\tif (arg->type == NULL)\n\t\t\treturn -ENOMEM;\n\t\tpr_debug(\"type:%s \", arg->type);\n\t}\n\n\ttmp = strpbrk(str, \"-.[\");\n\tif (!is_c_varname(str) || !tmp) {\n\t\t \n\t\targ->var = strdup(str);\n\t\tif (arg->var == NULL)\n\t\t\treturn -ENOMEM;\n\t\tpr_debug(\"%s\\n\", arg->var);\n\t\treturn 0;\n\t}\n\n\t \n\targ->var = strndup(str, tmp - str);\n\tif (arg->var == NULL)\n\t\treturn -ENOMEM;\n\tgoodname = arg->var;\n\tpr_debug(\"%s, \", arg->var);\n\tfieldp = &arg->field;\n\n\tdo {\n\t\t*fieldp = zalloc(sizeof(struct perf_probe_arg_field));\n\t\tif (*fieldp == NULL)\n\t\t\treturn -ENOMEM;\n\t\tif (*tmp == '[') {\t \n\t\t\tstr = tmp;\n\t\t\t(*fieldp)->index = strtol(str + 1, &tmp, 0);\n\t\t\t(*fieldp)->ref = true;\n\t\t\tif (*tmp != ']' || tmp == str + 1) {\n\t\t\t\tsemantic_error(\"Array index must be a\"\n\t\t\t\t\t\t\" number.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttmp++;\n\t\t\tif (*tmp == '\\0')\n\t\t\t\ttmp = NULL;\n\t\t} else {\t\t \n\t\t\tif (*tmp == '.') {\n\t\t\t\tstr = tmp + 1;\n\t\t\t\t(*fieldp)->ref = false;\n\t\t\t} else if (tmp[1] == '>') {\n\t\t\t\tstr = tmp + 2;\n\t\t\t\t(*fieldp)->ref = true;\n\t\t\t} else {\n\t\t\t\tsemantic_error(\"Argument parse error: %s\\n\",\n\t\t\t\t\t       str);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttmp = strpbrk(str, \"-.[\");\n\t\t}\n\t\tif (tmp) {\n\t\t\t(*fieldp)->name = strndup(str, tmp - str);\n\t\t\tif ((*fieldp)->name == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (*str != '[')\n\t\t\t\tgoodname = (*fieldp)->name;\n\t\t\tpr_debug(\"%s(%d), \", (*fieldp)->name, (*fieldp)->ref);\n\t\t\tfieldp = &(*fieldp)->next;\n\t\t}\n\t} while (tmp);\n\t(*fieldp)->name = strdup(str);\n\tif ((*fieldp)->name == NULL)\n\t\treturn -ENOMEM;\n\tif (*str != '[')\n\t\tgoodname = (*fieldp)->name;\n\tpr_debug(\"%s(%d)\\n\", (*fieldp)->name, (*fieldp)->ref);\n\n\t \n\tif (!arg->name) {\n\t\targ->name = strdup(goodname);\n\t\tif (arg->name == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nint parse_perf_probe_command(const char *cmd, struct perf_probe_event *pev)\n{\n\tchar **argv;\n\tint argc, i, ret = 0;\n\n\targv = argv_split(cmd, &argc);\n\tif (!argv) {\n\t\tpr_debug(\"Failed to split arguments.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (argc - 1 > MAX_PROBE_ARGS) {\n\t\tsemantic_error(\"Too many probe arguments (%d).\\n\", argc - 1);\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\t \n\tret = parse_perf_probe_point(argv[0], pev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (!pev->event && pev->point.function && pev->point.line\n\t\t\t&& !pev->point.lazy_line && !pev->point.offset) {\n\t\tif (asprintf(&pev->event, \"%s_L%d\", pev->point.function,\n\t\t\tpev->point.line) < 0) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tpev->nargs = argc - 1;\n\tpev->args = zalloc(sizeof(struct perf_probe_arg) * pev->nargs);\n\tif (pev->args == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < pev->nargs && ret >= 0; i++) {\n\t\tret = parse_perf_probe_arg(argv[i + 1], &pev->args[i]);\n\t\tif (ret >= 0 &&\n\t\t    is_c_varname(pev->args[i].var) && pev->point.retprobe) {\n\t\t\tsemantic_error(\"You can't specify local variable for\"\n\t\t\t\t       \" kretprobe.\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\nout:\n\targv_free(argv);\n\n\treturn ret;\n}\n\n \nbool perf_probe_with_var(struct perf_probe_event *pev)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < pev->nargs; i++)\n\t\tif (is_c_varname(pev->args[i].var)              ||\n\t\t    !strcmp(pev->args[i].var, PROBE_ARG_PARAMS) ||\n\t\t    !strcmp(pev->args[i].var, PROBE_ARG_VARS))\n\t\t\treturn true;\n\treturn false;\n}\n\n \nbool perf_probe_event_need_dwarf(struct perf_probe_event *pev)\n{\n\tif (pev->point.file || pev->point.line || pev->point.lazy_line)\n\t\treturn true;\n\n\tif (perf_probe_with_var(pev))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint parse_probe_trace_command(const char *cmd, struct probe_trace_event *tev)\n{\n\tstruct probe_trace_point *tp = &tev->point;\n\tchar pr;\n\tchar *p;\n\tchar *argv0_str = NULL, *fmt, *fmt1_str, *fmt2_str, *fmt3_str;\n\tint ret, i, argc;\n\tchar **argv;\n\n\tpr_debug(\"Parsing probe_events: %s\\n\", cmd);\n\targv = argv_split(cmd, &argc);\n\tif (!argv) {\n\t\tpr_debug(\"Failed to split arguments.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (argc < 2) {\n\t\tsemantic_error(\"Too few probe arguments.\\n\");\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\n\t \n\targv0_str = strdup(argv[0]);\n\tif (argv0_str == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfmt1_str = strtok_r(argv0_str, \":\", &fmt);\n\tfmt2_str = strtok_r(NULL, \"/\", &fmt);\n\tfmt3_str = strtok_r(NULL, \" \\t\", &fmt);\n\tif (fmt1_str == NULL || fmt2_str == NULL || fmt3_str == NULL) {\n\t\tsemantic_error(\"Failed to parse event name: %s\\n\", argv[0]);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tpr = fmt1_str[0];\n\ttev->group = strdup(fmt2_str);\n\ttev->event = strdup(fmt3_str);\n\tif (tev->group == NULL || tev->event == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpr_debug(\"Group:%s Event:%s probe:%c\\n\", tev->group, tev->event, pr);\n\n\ttp->retprobe = (pr == 'r');\n\n\t \n\tp = strchr(argv[1], ':');\n\tif (p) {\n\t\ttp->module = strndup(argv[1], p - argv[1]);\n\t\tif (!tp->module) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttev->uprobes = (tp->module[0] == '/');\n\t\tp++;\n\t} else\n\t\tp = argv[1];\n\tfmt1_str = strtok_r(p, \"+\", &fmt);\n\t \n\tif (fmt1_str[0] == '0')\t{\n\t\t \n\t\tif (strcmp(fmt1_str, \"0x\") == 0) {\n\t\t\tif (!argv[2] || strcmp(argv[2], \"(null)\")) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttp->address = 0;\n\n\t\t\tfree(argv[2]);\n\t\t\tfor (i = 2; argv[i + 1] != NULL; i++)\n\t\t\t\targv[i] = argv[i + 1];\n\n\t\t\targv[i] = NULL;\n\t\t\targc -= 1;\n\t\t} else\n\t\t\ttp->address = strtoull(fmt1_str, NULL, 0);\n\t} else {\n\t\t \n\t\ttp->symbol = strdup(fmt1_str);\n\t\tif (tp->symbol == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfmt2_str = strtok_r(NULL, \"\", &fmt);\n\t\tif (fmt2_str == NULL)\n\t\t\ttp->offset = 0;\n\t\telse\n\t\t\ttp->offset = strtoul(fmt2_str, NULL, 10);\n\t}\n\n\tif (tev->uprobes) {\n\t\tfmt2_str = strchr(p, '(');\n\t\tif (fmt2_str)\n\t\t\ttp->ref_ctr_offset = strtoul(fmt2_str + 1, NULL, 0);\n\t}\n\n\ttev->nargs = argc - 2;\n\ttev->args = zalloc(sizeof(struct probe_trace_arg) * tev->nargs);\n\tif (tev->args == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < tev->nargs; i++) {\n\t\tp = strchr(argv[i + 2], '=');\n\t\tif (p)\t \n\t\t\t*p++ = '\\0';\n\t\telse\n\t\t\tp = argv[i + 2];\n\t\ttev->args[i].name = strdup(argv[i + 2]);\n\t\t \n\t\ttev->args[i].value = strdup(p);\n\t\tif (tev->args[i].name == NULL || tev->args[i].value == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\nout:\n\tfree(argv0_str);\n\targv_free(argv);\n\treturn ret;\n}\n\n \nchar *synthesize_perf_probe_arg(struct perf_probe_arg *pa)\n{\n\tstruct perf_probe_arg_field *field = pa->field;\n\tstruct strbuf buf;\n\tchar *ret = NULL;\n\tint err;\n\n\tif (strbuf_init(&buf, 64) < 0)\n\t\treturn NULL;\n\n\tif (pa->name && pa->var)\n\t\terr = strbuf_addf(&buf, \"%s=%s\", pa->name, pa->var);\n\telse\n\t\terr = strbuf_addstr(&buf, pa->name ?: pa->var);\n\tif (err)\n\t\tgoto out;\n\n\twhile (field) {\n\t\tif (field->name[0] == '[')\n\t\t\terr = strbuf_addstr(&buf, field->name);\n\t\telse\n\t\t\terr = strbuf_addf(&buf, \"%s%s\", field->ref ? \"->\" : \".\",\n\t\t\t\t\t  field->name);\n\t\tfield = field->next;\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (pa->type)\n\t\tif (strbuf_addf(&buf, \":%s\", pa->type) < 0)\n\t\t\tgoto out;\n\n\tret = strbuf_detach(&buf, NULL);\nout:\n\tstrbuf_release(&buf);\n\treturn ret;\n}\n\n \nstatic char *synthesize_perf_probe_point(struct perf_probe_point *pp)\n{\n\tstruct strbuf buf;\n\tchar *tmp, *ret = NULL;\n\tint len, err = 0;\n\n\tif (strbuf_init(&buf, 64) < 0)\n\t\treturn NULL;\n\n\tif (pp->function) {\n\t\tif (strbuf_addstr(&buf, pp->function) < 0)\n\t\t\tgoto out;\n\t\tif (pp->offset)\n\t\t\terr = strbuf_addf(&buf, \"+%lu\", pp->offset);\n\t\telse if (pp->line)\n\t\t\terr = strbuf_addf(&buf, \":%d\", pp->line);\n\t\telse if (pp->retprobe)\n\t\t\terr = strbuf_addstr(&buf, \"%return\");\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (pp->file) {\n\t\ttmp = pp->file;\n\t\tlen = strlen(tmp);\n\t\tif (len > 30) {\n\t\t\ttmp = strchr(pp->file + len - 30, '/');\n\t\t\ttmp = tmp ? tmp + 1 : pp->file + len - 30;\n\t\t}\n\t\terr = strbuf_addf(&buf, \"@%s\", tmp);\n\t\tif (!err && !pp->function && pp->line)\n\t\t\terr = strbuf_addf(&buf, \":%d\", pp->line);\n\t}\n\tif (!err)\n\t\tret = strbuf_detach(&buf, NULL);\nout:\n\tstrbuf_release(&buf);\n\treturn ret;\n}\n\nchar *synthesize_perf_probe_command(struct perf_probe_event *pev)\n{\n\tstruct strbuf buf;\n\tchar *tmp, *ret = NULL;\n\tint i;\n\n\tif (strbuf_init(&buf, 64))\n\t\treturn NULL;\n\tif (pev->event)\n\t\tif (strbuf_addf(&buf, \"%s:%s=\", pev->group ?: PERFPROBE_GROUP,\n\t\t\t\tpev->event) < 0)\n\t\t\tgoto out;\n\n\ttmp = synthesize_perf_probe_point(&pev->point);\n\tif (!tmp || strbuf_addstr(&buf, tmp) < 0) {\n\t\tfree(tmp);\n\t\tgoto out;\n\t}\n\tfree(tmp);\n\n\tfor (i = 0; i < pev->nargs; i++) {\n\t\ttmp = synthesize_perf_probe_arg(pev->args + i);\n\t\tif (!tmp || strbuf_addf(&buf, \" %s\", tmp) < 0) {\n\t\t\tfree(tmp);\n\t\t\tgoto out;\n\t\t}\n\t\tfree(tmp);\n\t}\n\n\tret = strbuf_detach(&buf, NULL);\nout:\n\tstrbuf_release(&buf);\n\treturn ret;\n}\n\nstatic int __synthesize_probe_trace_arg_ref(struct probe_trace_arg_ref *ref,\n\t\t\t\t\t    struct strbuf *buf, int depth)\n{\n\tint err;\n\tif (ref->next) {\n\t\tdepth = __synthesize_probe_trace_arg_ref(ref->next, buf,\n\t\t\t\t\t\t\t depth + 1);\n\t\tif (depth < 0)\n\t\t\treturn depth;\n\t}\n\tif (ref->user_access)\n\t\terr = strbuf_addf(buf, \"%s%ld(\", \"+u\", ref->offset);\n\telse\n\t\terr = strbuf_addf(buf, \"%+ld(\", ref->offset);\n\treturn (err < 0) ? err : depth;\n}\n\nstatic int synthesize_probe_trace_arg(struct probe_trace_arg *arg,\n\t\t\t\t      struct strbuf *buf)\n{\n\tstruct probe_trace_arg_ref *ref = arg->ref;\n\tint depth = 0, err;\n\n\t \n\tif (arg->name)\n\t\terr = strbuf_addf(buf, \" %s=\", arg->name);\n\telse\n\t\terr = strbuf_addch(buf, ' ');\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (arg->value[0] == '@' && arg->ref)\n\t\t\tref = ref->next;\n\n\t \n\tif (ref) {\n\t\tdepth = __synthesize_probe_trace_arg_ref(ref, buf, 1);\n\t\tif (depth < 0)\n\t\t\treturn depth;\n\t}\n\n\t \n\tif (arg->value[0] == '@' && arg->ref)\n\t\terr = strbuf_addf(buf, \"%s%+ld\", arg->value, arg->ref->offset);\n\telse\n\t\terr = strbuf_addstr(buf, arg->value);\n\n\t \n\twhile (!err && depth--)\n\t\terr = strbuf_addch(buf, ')');\n\n\t \n\tif (!err && arg->type)\n\t\terr = strbuf_addf(buf, \":%s\", arg->type);\n\n\treturn err;\n}\n\nstatic int\nsynthesize_probe_trace_args(struct probe_trace_event *tev, struct strbuf *buf)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < tev->nargs && ret >= 0; i++)\n\t\tret = synthesize_probe_trace_arg(&tev->args[i], buf);\n\n\treturn ret;\n}\n\nstatic int\nsynthesize_uprobe_trace_def(struct probe_trace_point *tp, struct strbuf *buf)\n{\n\tint err;\n\n\t \n\tif (!tp->module)\n\t\treturn -EINVAL;\n\t \n\tif (!tp->address && (!tp->symbol || strcmp(tp->symbol, \"0x0\")))\n\t\treturn -EINVAL;\n\n\t \n\terr = strbuf_addf(buf, \"%s:0x%\" PRIx64, tp->module, tp->address);\n\n\tif (err >= 0 && tp->ref_ctr_offset) {\n\t\tif (!uprobe_ref_ctr_is_supported())\n\t\t\treturn -EINVAL;\n\t\terr = strbuf_addf(buf, \"(0x%lx)\", tp->ref_ctr_offset);\n\t}\n\treturn err >= 0 ? 0 : err;\n}\n\nstatic int\nsynthesize_kprobe_trace_def(struct probe_trace_point *tp, struct strbuf *buf)\n{\n\tif (!strncmp(tp->symbol, \"0x\", 2)) {\n\t\t \n\t\treturn strbuf_addf(buf, \"%s%s0x%\" PRIx64, tp->module ?: \"\",\n\t\t\t\t  tp->module ? \":\" : \"\", tp->address);\n\t} else {\n\t\treturn strbuf_addf(buf, \"%s%s%s+%lu\", tp->module ?: \"\",\n\t\t\t\ttp->module ? \":\" : \"\", tp->symbol, tp->offset);\n\t}\n}\n\nchar *synthesize_probe_trace_command(struct probe_trace_event *tev)\n{\n\tstruct probe_trace_point *tp = &tev->point;\n\tstruct strbuf buf;\n\tchar *ret = NULL;\n\tint err;\n\n\tif (strbuf_init(&buf, 32) < 0)\n\t\treturn NULL;\n\n\tif (strbuf_addf(&buf, \"%c:%s/%s \", tp->retprobe ? 'r' : 'p',\n\t\t\ttev->group, tev->event) < 0)\n\t\tgoto error;\n\n\tif (tev->uprobes)\n\t\terr = synthesize_uprobe_trace_def(tp, &buf);\n\telse\n\t\terr = synthesize_kprobe_trace_def(tp, &buf);\n\n\tif (err >= 0)\n\t\terr = synthesize_probe_trace_args(tev, &buf);\n\n\tif (err >= 0)\n\t\tret = strbuf_detach(&buf, NULL);\nerror:\n\tstrbuf_release(&buf);\n\treturn ret;\n}\n\nstatic int find_perf_probe_point_from_map(struct probe_trace_point *tp,\n\t\t\t\t\t  struct perf_probe_point *pp,\n\t\t\t\t\t  bool is_kprobe)\n{\n\tstruct symbol *sym = NULL;\n\tstruct map *map = NULL;\n\tu64 addr = tp->address;\n\tint ret = -ENOENT;\n\n\tif (!is_kprobe) {\n\t\tmap = dso__new_map(tp->module);\n\t\tif (!map)\n\t\t\tgoto out;\n\t\tsym = map__find_symbol(map, addr);\n\t} else {\n\t\tif (tp->symbol && !addr) {\n\t\t\tif (kernel_get_symbol_address_by_name(tp->symbol,\n\t\t\t\t\t\t&addr, true, false) < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (addr) {\n\t\t\taddr += tp->offset;\n\t\t\tsym = machine__find_kernel_symbol(host_machine, addr, &map);\n\t\t}\n\t}\n\n\tif (!sym)\n\t\tgoto out;\n\n\tpp->retprobe = tp->retprobe;\n\tpp->offset = addr - map__unmap_ip(map, sym->start);\n\tpp->function = strdup(sym->name);\n\tret = pp->function ? 0 : -ENOMEM;\n\nout:\n\tif (map && !is_kprobe) {\n\t\tmap__put(map);\n\t}\n\n\treturn ret;\n}\n\nstatic int convert_to_perf_probe_point(struct probe_trace_point *tp,\n\t\t\t\t       struct perf_probe_point *pp,\n\t\t\t\t       bool is_kprobe)\n{\n\tchar buf[128];\n\tint ret;\n\n\tret = find_perf_probe_point_from_dwarf(tp, pp, is_kprobe);\n\tif (!ret)\n\t\treturn 0;\n\tret = find_perf_probe_point_from_map(tp, pp, is_kprobe);\n\tif (!ret)\n\t\treturn 0;\n\n\tpr_debug(\"Failed to find probe point from both of dwarf and map.\\n\");\n\n\tif (tp->symbol) {\n\t\tpp->function = strdup(tp->symbol);\n\t\tpp->offset = tp->offset;\n\t} else {\n\t\tret = e_snprintf(buf, 128, \"0x%\" PRIx64, tp->address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpp->function = strdup(buf);\n\t\tpp->offset = 0;\n\t}\n\tif (pp->function == NULL)\n\t\treturn -ENOMEM;\n\n\tpp->retprobe = tp->retprobe;\n\n\treturn 0;\n}\n\nstatic int convert_to_perf_probe_event(struct probe_trace_event *tev,\n\t\t\t       struct perf_probe_event *pev, bool is_kprobe)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint i, ret;\n\n\t \n\tpev->event = strdup(tev->event);\n\tpev->group = strdup(tev->group);\n\tif (pev->event == NULL || pev->group == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tret = convert_to_perf_probe_point(&tev->point, &pev->point, is_kprobe);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpev->nargs = tev->nargs;\n\tpev->args = zalloc(sizeof(struct perf_probe_arg) * pev->nargs);\n\tif (pev->args == NULL)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < tev->nargs && ret >= 0; i++) {\n\t\tif (tev->args[i].name)\n\t\t\tpev->args[i].name = strdup(tev->args[i].name);\n\t\telse {\n\t\t\tif ((ret = strbuf_init(&buf, 32)) < 0)\n\t\t\t\tgoto error;\n\t\t\tret = synthesize_probe_trace_arg(&tev->args[i], &buf);\n\t\t\tpev->args[i].name = strbuf_detach(&buf, NULL);\n\t\t}\n\t\tif (pev->args[i].name == NULL && ret >= 0)\n\t\t\tret = -ENOMEM;\n\t}\nerror:\n\tif (ret < 0)\n\t\tclear_perf_probe_event(pev);\n\n\treturn ret;\n}\n\nvoid clear_perf_probe_event(struct perf_probe_event *pev)\n{\n\tstruct perf_probe_arg_field *field, *next;\n\tint i;\n\n\tzfree(&pev->event);\n\tzfree(&pev->group);\n\tzfree(&pev->target);\n\tclear_perf_probe_point(&pev->point);\n\n\tfor (i = 0; i < pev->nargs; i++) {\n\t\tzfree(&pev->args[i].name);\n\t\tzfree(&pev->args[i].var);\n\t\tzfree(&pev->args[i].type);\n\t\tfield = pev->args[i].field;\n\t\twhile (field) {\n\t\t\tnext = field->next;\n\t\t\tzfree(&field->name);\n\t\t\tfree(field);\n\t\t\tfield = next;\n\t\t}\n\t}\n\tpev->nargs = 0;\n\tzfree(&pev->args);\n}\n\n#define strdup_or_goto(str, label)\t\\\n({ char *__p = NULL; if (str && !(__p = strdup(str))) goto label; __p; })\n\nstatic int perf_probe_point__copy(struct perf_probe_point *dst,\n\t\t\t\t  struct perf_probe_point *src)\n{\n\tdst->file = strdup_or_goto(src->file, out_err);\n\tdst->function = strdup_or_goto(src->function, out_err);\n\tdst->lazy_line = strdup_or_goto(src->lazy_line, out_err);\n\tdst->line = src->line;\n\tdst->retprobe = src->retprobe;\n\tdst->offset = src->offset;\n\treturn 0;\n\nout_err:\n\tclear_perf_probe_point(dst);\n\treturn -ENOMEM;\n}\n\nstatic int perf_probe_arg__copy(struct perf_probe_arg *dst,\n\t\t\t\tstruct perf_probe_arg *src)\n{\n\tstruct perf_probe_arg_field *field, **ppfield;\n\n\tdst->name = strdup_or_goto(src->name, out_err);\n\tdst->var = strdup_or_goto(src->var, out_err);\n\tdst->type = strdup_or_goto(src->type, out_err);\n\n\tfield = src->field;\n\tppfield = &(dst->field);\n\twhile (field) {\n\t\t*ppfield = zalloc(sizeof(*field));\n\t\tif (!*ppfield)\n\t\t\tgoto out_err;\n\t\t(*ppfield)->name = strdup_or_goto(field->name, out_err);\n\t\t(*ppfield)->index = field->index;\n\t\t(*ppfield)->ref = field->ref;\n\t\tfield = field->next;\n\t\tppfield = &((*ppfield)->next);\n\t}\n\treturn 0;\nout_err:\n\treturn -ENOMEM;\n}\n\nint perf_probe_event__copy(struct perf_probe_event *dst,\n\t\t\t   struct perf_probe_event *src)\n{\n\tint i;\n\n\tdst->event = strdup_or_goto(src->event, out_err);\n\tdst->group = strdup_or_goto(src->group, out_err);\n\tdst->target = strdup_or_goto(src->target, out_err);\n\tdst->uprobes = src->uprobes;\n\n\tif (perf_probe_point__copy(&dst->point, &src->point) < 0)\n\t\tgoto out_err;\n\n\tdst->args = zalloc(sizeof(struct perf_probe_arg) * src->nargs);\n\tif (!dst->args)\n\t\tgoto out_err;\n\tdst->nargs = src->nargs;\n\n\tfor (i = 0; i < src->nargs; i++)\n\t\tif (perf_probe_arg__copy(&dst->args[i], &src->args[i]) < 0)\n\t\t\tgoto out_err;\n\treturn 0;\n\nout_err:\n\tclear_perf_probe_event(dst);\n\treturn -ENOMEM;\n}\n\nvoid clear_probe_trace_event(struct probe_trace_event *tev)\n{\n\tstruct probe_trace_arg_ref *ref, *next;\n\tint i;\n\n\tzfree(&tev->event);\n\tzfree(&tev->group);\n\tzfree(&tev->point.symbol);\n\tzfree(&tev->point.realname);\n\tzfree(&tev->point.module);\n\tfor (i = 0; i < tev->nargs; i++) {\n\t\tzfree(&tev->args[i].name);\n\t\tzfree(&tev->args[i].value);\n\t\tzfree(&tev->args[i].type);\n\t\tref = tev->args[i].ref;\n\t\twhile (ref) {\n\t\t\tnext = ref->next;\n\t\t\tfree(ref);\n\t\t\tref = next;\n\t\t}\n\t}\n\tzfree(&tev->args);\n\ttev->nargs = 0;\n}\n\nstruct kprobe_blacklist_node {\n\tstruct list_head list;\n\tu64 start;\n\tu64 end;\n\tchar *symbol;\n};\n\nstatic void kprobe_blacklist__delete(struct list_head *blacklist)\n{\n\tstruct kprobe_blacklist_node *node;\n\n\twhile (!list_empty(blacklist)) {\n\t\tnode = list_first_entry(blacklist,\n\t\t\t\t\tstruct kprobe_blacklist_node, list);\n\t\tlist_del_init(&node->list);\n\t\tzfree(&node->symbol);\n\t\tfree(node);\n\t}\n}\n\nstatic int kprobe_blacklist__load(struct list_head *blacklist)\n{\n\tstruct kprobe_blacklist_node *node;\n\tconst char *__debugfs = debugfs__mountpoint();\n\tchar buf[PATH_MAX], *p;\n\tFILE *fp;\n\tint ret;\n\n\tif (__debugfs == NULL)\n\t\treturn -ENOTSUP;\n\n\tret = e_snprintf(buf, PATH_MAX, \"%s/kprobes/blacklist\", __debugfs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfp = fopen(buf, \"r\");\n\tif (!fp)\n\t\treturn -errno;\n\n\tret = 0;\n\twhile (fgets(buf, PATH_MAX, fp)) {\n\t\tnode = zalloc(sizeof(*node));\n\t\tif (!node) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tINIT_LIST_HEAD(&node->list);\n\t\tlist_add_tail(&node->list, blacklist);\n\t\tif (sscanf(buf, \"0x%\" PRIx64 \"-0x%\" PRIx64, &node->start, &node->end) != 2) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tp = strchr(buf, '\\t');\n\t\tif (p) {\n\t\t\tp++;\n\t\t\tif (p[strlen(p) - 1] == '\\n')\n\t\t\t\tp[strlen(p) - 1] = '\\0';\n\t\t} else\n\t\t\tp = (char *)\"unknown\";\n\t\tnode->symbol = strdup(p);\n\t\tif (!node->symbol) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tpr_debug2(\"Blacklist: 0x%\" PRIx64 \"-0x%\" PRIx64 \", %s\\n\",\n\t\t\t  node->start, node->end, node->symbol);\n\t\tret++;\n\t}\n\tif (ret < 0)\n\t\tkprobe_blacklist__delete(blacklist);\n\tfclose(fp);\n\n\treturn ret;\n}\n\nstatic struct kprobe_blacklist_node *\nkprobe_blacklist__find_by_address(struct list_head *blacklist, u64 address)\n{\n\tstruct kprobe_blacklist_node *node;\n\n\tlist_for_each_entry(node, blacklist, list) {\n\t\tif (node->start <= address && address < node->end)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void kprobe_blacklist__init(void)\n{\n\tif (!list_empty(&kprobe_blacklist))\n\t\treturn;\n\n\tif (kprobe_blacklist__load(&kprobe_blacklist) < 0)\n\t\tpr_debug(\"No kprobe blacklist support, ignored\\n\");\n}\n\nstatic void kprobe_blacklist__release(void)\n{\n\tkprobe_blacklist__delete(&kprobe_blacklist);\n}\n\nstatic bool kprobe_blacklist__listed(u64 address)\n{\n\treturn !!kprobe_blacklist__find_by_address(&kprobe_blacklist, address);\n}\n\nstatic int perf_probe_event__sprintf(const char *group, const char *event,\n\t\t\t\t     struct perf_probe_event *pev,\n\t\t\t\t     const char *module,\n\t\t\t\t     struct strbuf *result)\n{\n\tint i, ret;\n\tchar *buf;\n\n\tif (asprintf(&buf, \"%s:%s\", group, event) < 0)\n\t\treturn -errno;\n\tret = strbuf_addf(result, \"  %-20s (on \", buf);\n\tfree(buf);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbuf = synthesize_perf_probe_point(&pev->point);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = strbuf_addstr(result, buf);\n\tfree(buf);\n\n\tif (!ret && module)\n\t\tret = strbuf_addf(result, \" in %s\", module);\n\n\tif (!ret && pev->nargs > 0) {\n\t\tret = strbuf_add(result, \" with\", 5);\n\t\tfor (i = 0; !ret && i < pev->nargs; i++) {\n\t\t\tbuf = synthesize_perf_probe_arg(&pev->args[i]);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tret = strbuf_addf(result, \" %s\", buf);\n\t\t\tfree(buf);\n\t\t}\n\t}\n\tif (!ret)\n\t\tret = strbuf_addch(result, ')');\n\n\treturn ret;\n}\n\n \nint show_perf_probe_event(const char *group, const char *event,\n\t\t\t  struct perf_probe_event *pev,\n\t\t\t  const char *module, bool use_stdout)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint ret;\n\n\tret = perf_probe_event__sprintf(group, event, pev, module, &buf);\n\tif (ret >= 0) {\n\t\tif (use_stdout)\n\t\t\tprintf(\"%s\\n\", buf.buf);\n\t\telse\n\t\t\tpr_info(\"%s\\n\", buf.buf);\n\t}\n\tstrbuf_release(&buf);\n\n\treturn ret;\n}\n\nstatic bool filter_probe_trace_event(struct probe_trace_event *tev,\n\t\t\t\t     struct strfilter *filter)\n{\n\tchar tmp[128];\n\n\t \n\tif (strfilter__compare(filter, tev->event))\n\t\treturn true;\n\n\t \n\tif (e_snprintf(tmp, 128, \"%s:%s\", tev->group, tev->event) < 0)\n\t\treturn false;\n\treturn strfilter__compare(filter, tmp);\n}\n\nstatic int __show_perf_probe_events(int fd, bool is_kprobe,\n\t\t\t\t    struct strfilter *filter)\n{\n\tint ret = 0;\n\tstruct probe_trace_event tev;\n\tstruct perf_probe_event pev;\n\tstruct strlist *rawlist;\n\tstruct str_node *ent;\n\n\tmemset(&tev, 0, sizeof(tev));\n\tmemset(&pev, 0, sizeof(pev));\n\n\trawlist = probe_file__get_rawlist(fd);\n\tif (!rawlist)\n\t\treturn -ENOMEM;\n\n\tstrlist__for_each_entry(ent, rawlist) {\n\t\tret = parse_probe_trace_command(ent->s, &tev);\n\t\tif (ret >= 0) {\n\t\t\tif (!filter_probe_trace_event(&tev, filter))\n\t\t\t\tgoto next;\n\t\t\tret = convert_to_perf_probe_event(&tev, &pev,\n\t\t\t\t\t\t\t\tis_kprobe);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto next;\n\t\t\tret = show_perf_probe_event(pev.group, pev.event,\n\t\t\t\t\t\t    &pev, tev.point.module,\n\t\t\t\t\t\t    true);\n\t\t}\nnext:\n\t\tclear_perf_probe_event(&pev);\n\t\tclear_probe_trace_event(&tev);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tstrlist__delete(rawlist);\n\t \n\tdebuginfo_cache__exit();\n\n\treturn ret;\n}\n\n \nint show_perf_probe_events(struct strfilter *filter)\n{\n\tint kp_fd, up_fd, ret;\n\n\tsetup_pager();\n\n\tif (probe_conf.cache)\n\t\treturn probe_cache__show_all_caches(filter);\n\n\tret = init_probe_symbol_maps(false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = probe_file__open_both(&kp_fd, &up_fd, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (kp_fd >= 0)\n\t\tret = __show_perf_probe_events(kp_fd, true, filter);\n\tif (up_fd >= 0 && ret >= 0)\n\t\tret = __show_perf_probe_events(up_fd, false, filter);\n\tif (kp_fd > 0)\n\t\tclose(kp_fd);\n\tif (up_fd > 0)\n\t\tclose(up_fd);\n\texit_probe_symbol_maps();\n\n\treturn ret;\n}\n\nstatic int get_new_event_name(char *buf, size_t len, const char *base,\n\t\t\t      struct strlist *namelist, bool ret_event,\n\t\t\t      bool allow_suffix)\n{\n\tint i, ret;\n\tchar *p, *nbase;\n\n\tif (*base == '.')\n\t\tbase++;\n\tnbase = strdup(base);\n\tif (!nbase)\n\t\treturn -ENOMEM;\n\n\t \n\tp = strpbrk(nbase, \".@\");\n\tif (p && p != nbase)\n\t\t*p = '\\0';\n\n\t \n\tret = e_snprintf(buf, len, \"%s%s\", nbase, ret_event ? \"__return\" : \"\");\n\tif (ret < 0) {\n\t\tpr_debug(\"snprintf() failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (!strlist__has_entry(namelist, buf))\n\t\tgoto out;\n\n\tif (!allow_suffix) {\n\t\tpr_warning(\"Error: event \\\"%s\\\" already exists.\\n\"\n\t\t\t   \" Hint: Remove existing event by 'perf probe -d'\\n\"\n\t\t\t   \"       or force duplicates by 'perf probe -f'\\n\"\n\t\t\t   \"       or set 'force=yes' in BPF source.\\n\",\n\t\t\t   buf);\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 1; i < MAX_EVENT_INDEX; i++) {\n\t\tret = e_snprintf(buf, len, \"%s_%d\", nbase, i);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"snprintf() failed: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!strlist__has_entry(namelist, buf))\n\t\t\tbreak;\n\t}\n\tif (i == MAX_EVENT_INDEX) {\n\t\tpr_warning(\"Too many events are on the same function.\\n\");\n\t\tret = -ERANGE;\n\t}\n\nout:\n\tfree(nbase);\n\n\t \n\tif (ret >= 0 && !is_c_func_name(buf)) {\n\t\tpr_warning(\"Internal error: \\\"%s\\\" is an invalid event name.\\n\",\n\t\t\t   buf);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void warn_uprobe_event_compat(struct probe_trace_event *tev)\n{\n\tint i;\n\tchar *buf = synthesize_probe_trace_command(tev);\n\tstruct probe_trace_point *tp = &tev->point;\n\n\tif (tp->ref_ctr_offset && !uprobe_ref_ctr_is_supported()) {\n\t\tpr_warning(\"A semaphore is associated with %s:%s and \"\n\t\t\t   \"seems your kernel doesn't support it.\\n\",\n\t\t\t   tev->group, tev->event);\n\t}\n\n\t \n\tif (!tev->uprobes || tev->nargs == 0 || !buf)\n\t\tgoto out;\n\n\tfor (i = 0; i < tev->nargs; i++) {\n\t\tif (strchr(tev->args[i].value, '@')) {\n\t\t\tpr_warning(\"%s accesses a variable by symbol name, but that is not supported for user application probe.\\n\",\n\t\t\t\t   tev->args[i].value);\n\t\t\tbreak;\n\t\t}\n\t\tif (strglobmatch(tev->args[i].value, \"[$+-]*\")) {\n\t\t\tpr_warning(\"Please upgrade your kernel to at least 3.14 to have access to feature %s\\n\",\n\t\t\t\t   tev->args[i].value);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tfree(buf);\n}\n\n \nstatic int probe_trace_event__set_name(struct probe_trace_event *tev,\n\t\t\t\t       struct perf_probe_event *pev,\n\t\t\t\t       struct strlist *namelist,\n\t\t\t\t       bool allow_suffix)\n{\n\tconst char *event, *group;\n\tchar buf[64];\n\tint ret;\n\n\t \n\tif (pev->event && !pev->sdt)\n\t\tevent = pev->event;\n\telse if (tev->event)\n\t\tevent = tev->event;\n\telse {\n\t\t \n\t\tif (pev->point.function &&\n\t\t\t(strncmp(pev->point.function, \"0x\", 2) != 0) &&\n\t\t\t!strisglob(pev->point.function))\n\t\t\tevent = pev->point.function;\n\t\telse\n\t\t\tevent = tev->point.realname;\n\t}\n\tif (pev->group && !pev->sdt)\n\t\tgroup = pev->group;\n\telse if (tev->group)\n\t\tgroup = tev->group;\n\telse\n\t\tgroup = PERFPROBE_GROUP;\n\n\t \n\tret = get_new_event_name(buf, 64, event, namelist,\n\t\t\t\t tev->point.retprobe, allow_suffix);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tevent = buf;\n\n\ttev->event = strdup(event);\n\ttev->group = strdup(group);\n\tif (tev->event == NULL || tev->group == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!multiprobe_event_is_supported())\n\t\tstrlist__add(namelist, event);\n\treturn 0;\n}\n\nstatic int __open_probe_file_and_namelist(bool uprobe,\n\t\t\t\t\t  struct strlist **namelist)\n{\n\tint fd;\n\n\tfd = probe_file__open(PF_FL_RW | (uprobe ? PF_FL_UPROBE : 0));\n\tif (fd < 0)\n\t\treturn fd;\n\n\t \n\t*namelist = probe_file__get_namelist(fd);\n\tif (!(*namelist)) {\n\t\tpr_debug(\"Failed to get current event list.\\n\");\n\t\tclose(fd);\n\t\treturn -ENOMEM;\n\t}\n\treturn fd;\n}\n\nstatic int __add_probe_trace_events(struct perf_probe_event *pev,\n\t\t\t\t     struct probe_trace_event *tevs,\n\t\t\t\t     int ntevs, bool allow_suffix)\n{\n\tint i, fd[2] = {-1, -1}, up, ret;\n\tstruct probe_trace_event *tev = NULL;\n\tstruct probe_cache *cache = NULL;\n\tstruct strlist *namelist[2] = {NULL, NULL};\n\tstruct nscookie nsc;\n\n\tup = pev->uprobes ? 1 : 0;\n\tfd[up] = __open_probe_file_and_namelist(up, &namelist[up]);\n\tif (fd[up] < 0)\n\t\treturn fd[up];\n\n\tret = 0;\n\tfor (i = 0; i < ntevs; i++) {\n\t\ttev = &tevs[i];\n\t\tup = tev->uprobes ? 1 : 0;\n\t\tif (fd[up] == -1) {\t \n\t\t\tfd[up] = __open_probe_file_and_namelist(up,\n\t\t\t\t\t\t\t\t&namelist[up]);\n\t\t\tif (fd[up] < 0)\n\t\t\t\tgoto close_out;\n\t\t}\n\t\t \n\t\tif (!tev->point.symbol && !pev->uprobes)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = probe_trace_event__set_name(tev, pev, namelist[up],\n\t\t\t\t\t\t  allow_suffix);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tnsinfo__mountns_enter(pev->nsi, &nsc);\n\t\tret = probe_file__add_event(fd[up], tev);\n\t\tnsinfo__mountns_exit(&nsc);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tallow_suffix = true;\n\t}\n\tif (ret == -EINVAL && pev->uprobes)\n\t\twarn_uprobe_event_compat(tev);\n\tif (ret == 0 && probe_conf.cache) {\n\t\tcache = probe_cache__new(pev->target, pev->nsi);\n\t\tif (!cache ||\n\t\t    probe_cache__add_entry(cache, pev, tevs, ntevs) < 0 ||\n\t\t    probe_cache__commit(cache) < 0)\n\t\t\tpr_warning(\"Failed to add event to probe cache\\n\");\n\t\tprobe_cache__delete(cache);\n\t}\n\nclose_out:\n\tfor (up = 0; up < 2; up++) {\n\t\tstrlist__delete(namelist[up]);\n\t\tif (fd[up] >= 0)\n\t\t\tclose(fd[up]);\n\t}\n\treturn ret;\n}\n\nstatic int find_probe_functions(struct map *map, char *name,\n\t\t\t\tstruct symbol **syms)\n{\n\tint found = 0;\n\tstruct symbol *sym;\n\tstruct rb_node *tmp;\n\tconst char *norm, *ver;\n\tchar *buf = NULL;\n\tbool cut_version = true;\n\n\tif (map__load(map) < 0)\n\t\treturn -EACCES;\t \n\n\t \n\tif (strchr(name, '@'))\n\t\tcut_version = false;\n\n\tmap__for_each_symbol(map, sym, tmp) {\n\t\tnorm = arch__normalize_symbol_name(sym->name);\n\t\tif (!norm)\n\t\t\tcontinue;\n\n\t\tif (cut_version) {\n\t\t\t \n\t\t\tver = strchr(norm, '@');\n\t\t\tif (ver) {\n\t\t\t\tbuf = strndup(norm, ver - norm);\n\t\t\t\tif (!buf)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tnorm = buf;\n\t\t\t}\n\t\t}\n\n\t\tif (strglobmatch(norm, name)) {\n\t\t\tfound++;\n\t\t\tif (syms && found < probe_conf.max_probes)\n\t\t\t\tsyms[found - 1] = sym;\n\t\t}\n\t\tif (buf)\n\t\t\tzfree(&buf);\n\t}\n\n\treturn found;\n}\n\nvoid __weak arch__fix_tev_from_maps(struct perf_probe_event *pev __maybe_unused,\n\t\t\t\tstruct probe_trace_event *tev __maybe_unused,\n\t\t\t\tstruct map *map __maybe_unused,\n\t\t\t\tstruct symbol *sym __maybe_unused) { }\n\n\nstatic void pr_kallsyms_access_error(void)\n{\n\tpr_err(\"Please ensure you can read the /proc/kallsyms symbol addresses.\\n\"\n\t       \"If /proc/sys/kernel/kptr_restrict is '2', you can not read\\n\"\n\t       \"kernel symbol addresses even if you are a superuser. Please change\\n\"\n\t       \"it to '1'. If kptr_restrict is '1', the superuser can read the\\n\"\n\t       \"symbol addresses.\\n\"\n\t       \"In that case, please run this command again with sudo.\\n\");\n}\n\n \nstatic int find_probe_trace_events_from_map(struct perf_probe_event *pev,\n\t\t\t\t\t    struct probe_trace_event **tevs)\n{\n\tstruct map *map = NULL;\n\tstruct ref_reloc_sym *reloc_sym = NULL;\n\tstruct symbol *sym;\n\tstruct symbol **syms = NULL;\n\tstruct probe_trace_event *tev;\n\tstruct perf_probe_point *pp = &pev->point;\n\tstruct probe_trace_point *tp;\n\tint num_matched_functions;\n\tint ret, i, j, skipped = 0;\n\tchar *mod_name;\n\n\tmap = get_target_map(pev->target, pev->nsi, pev->uprobes);\n\tif (!map) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsyms = malloc(sizeof(struct symbol *) * probe_conf.max_probes);\n\tif (!syms) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tnum_matched_functions = find_probe_functions(map, pp->function, syms);\n\tif (num_matched_functions <= 0) {\n\t\tif (num_matched_functions == -EACCES) {\n\t\t\tpr_err(\"Failed to load symbols from %s\\n\",\n\t\t\t       pev->target ?: \"/proc/kallsyms\");\n\t\t\tif (pev->target)\n\t\t\t\tpr_err(\"Please ensure the file is not stripped.\\n\");\n\t\t\telse\n\t\t\t\tpr_kallsyms_access_error();\n\t\t} else\n\t\t\tpr_err(\"Failed to find symbol %s in %s\\n\", pp->function,\n\t\t\t\tpev->target ? : \"kernel\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t} else if (num_matched_functions > probe_conf.max_probes) {\n\t\tpr_err(\"Too many functions matched in %s\\n\",\n\t\t\tpev->target ? : \"kernel\");\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!pev->uprobes && !pev->target &&\n\t\t\t(!pp->retprobe || kretprobe_offset_is_supported())) {\n\t\treloc_sym = kernel_get_ref_reloc_sym(NULL);\n\t\tif (!reloc_sym) {\n\t\t\tpr_warning(\"Relocated base symbol is not found! \"\n\t\t\t\t   \"Check /proc/sys/kernel/kptr_restrict\\n\"\n\t\t\t\t   \"and /proc/sys/kernel/perf_event_paranoid. \"\n\t\t\t\t   \"Or run as privileged perf user.\\n\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\t*tevs = zalloc(sizeof(*tev) * num_matched_functions);\n\tif (!*tevs) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\n\tfor (j = 0; j < num_matched_functions; j++) {\n\t\tsym = syms[j];\n\n\t\tif (sym->type != STT_FUNC)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (i = 0; i < j; i++)\n\t\t\tif (sym->start == syms[i]->start) {\n\t\t\t\tpr_debug(\"Found duplicated symbol %s @ %\" PRIx64 \"\\n\",\n\t\t\t\t\t sym->name, sym->start);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i != j)\n\t\t\tcontinue;\n\n\t\ttev = (*tevs) + ret;\n\t\ttp = &tev->point;\n\t\tif (ret == num_matched_functions) {\n\t\t\tpr_warning(\"Too many symbols are listed. Skip it.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret++;\n\n\t\tif (pp->offset > sym->end - sym->start) {\n\t\t\tpr_warning(\"Offset %ld is bigger than the size of %s\\n\",\n\t\t\t\t   pp->offset, sym->name);\n\t\t\tret = -ENOENT;\n\t\t\tgoto err_out;\n\t\t}\n\t\t \n\t\ttp->address = map__unmap_ip(map, sym->start) + pp->offset;\n\n\t\t \n\t\tif (!pev->uprobes && !pev->target &&\n\t\t    kprobe_warn_out_range(sym->name, tp->address)) {\n\t\t\ttp->symbol = NULL;\t \n\t\t\tskipped++;\n\t\t} else if (reloc_sym) {\n\t\t\ttp->symbol = strdup_or_goto(reloc_sym->name, nomem_out);\n\t\t\ttp->offset = tp->address - reloc_sym->addr;\n\t\t} else {\n\t\t\ttp->symbol = strdup_or_goto(sym->name, nomem_out);\n\t\t\ttp->offset = pp->offset;\n\t\t}\n\t\ttp->realname = strdup_or_goto(sym->name, nomem_out);\n\n\t\ttp->retprobe = pp->retprobe;\n\t\tif (pev->target) {\n\t\t\tif (pev->uprobes) {\n\t\t\t\ttev->point.module = strdup_or_goto(pev->target,\n\t\t\t\t\t\t\t\t   nomem_out);\n\t\t\t} else {\n\t\t\t\tmod_name = find_module_name(pev->target);\n\t\t\t\ttev->point.module =\n\t\t\t\t\tstrdup(mod_name ? mod_name : pev->target);\n\t\t\t\tfree(mod_name);\n\t\t\t\tif (!tev->point.module)\n\t\t\t\t\tgoto nomem_out;\n\t\t\t}\n\t\t}\n\t\ttev->uprobes = pev->uprobes;\n\t\ttev->nargs = pev->nargs;\n\t\tif (tev->nargs) {\n\t\t\ttev->args = zalloc(sizeof(struct probe_trace_arg) *\n\t\t\t\t\t   tev->nargs);\n\t\t\tif (tev->args == NULL)\n\t\t\t\tgoto nomem_out;\n\t\t}\n\t\tfor (i = 0; i < tev->nargs; i++) {\n\t\t\tif (pev->args[i].name)\n\t\t\t\ttev->args[i].name =\n\t\t\t\t\tstrdup_or_goto(pev->args[i].name,\n\t\t\t\t\t\t\tnomem_out);\n\n\t\t\ttev->args[i].value = strdup_or_goto(pev->args[i].var,\n\t\t\t\t\t\t\t    nomem_out);\n\t\t\tif (pev->args[i].type)\n\t\t\t\ttev->args[i].type =\n\t\t\t\t\tstrdup_or_goto(pev->args[i].type,\n\t\t\t\t\t\t\tnomem_out);\n\t\t}\n\t\tarch__fix_tev_from_maps(pev, tev, map, sym);\n\t}\n\tif (ret == skipped) {\n\t\tret = -ENOENT;\n\t\tgoto err_out;\n\t}\n\nout:\n\tmap__put(map);\n\tfree(syms);\n\treturn ret;\n\nnomem_out:\n\tret = -ENOMEM;\nerr_out:\n\tclear_probe_trace_events(*tevs, num_matched_functions);\n\tzfree(tevs);\n\tgoto out;\n}\n\nstatic int try_to_find_absolute_address(struct perf_probe_event *pev,\n\t\t\t\t\tstruct probe_trace_event **tevs)\n{\n\tstruct perf_probe_point *pp = &pev->point;\n\tstruct probe_trace_event *tev;\n\tstruct probe_trace_point *tp;\n\tint i, err;\n\n\tif (!(pev->point.function && !strncmp(pev->point.function, \"0x\", 2)))\n\t\treturn -EINVAL;\n\tif (perf_probe_event_need_dwarf(pev))\n\t\treturn -EINVAL;\n\n\t \n\t*tevs = zalloc(sizeof(*tev));\n\tif (!*tevs)\n\t\treturn -ENOMEM;\n\n\ttev = *tevs;\n\ttp = &tev->point;\n\n\t \n\ttp->address = pev->point.abs_address;\n\ttp->retprobe = pp->retprobe;\n\ttev->uprobes = pev->uprobes;\n\n\terr = -ENOMEM;\n\t \n\tif (asprintf(&tp->symbol, \"0x%\" PRIx64, tp->address) < 0)\n\t\tgoto errout;\n\n\t \n\tif ((!tev->uprobes) &&\n\t    (kprobe_warn_out_range(tev->point.symbol,\n\t\t\t\t   tev->point.address))) {\n\t\terr = -EACCES;\n\t\tgoto errout;\n\t}\n\n\tif (asprintf(&tp->realname, \"abs_%\" PRIx64, tp->address) < 0)\n\t\tgoto errout;\n\n\tif (pev->target) {\n\t\ttp->module = strdup(pev->target);\n\t\tif (!tp->module)\n\t\t\tgoto errout;\n\t}\n\n\tif (tev->group) {\n\t\ttev->group = strdup(pev->group);\n\t\tif (!tev->group)\n\t\t\tgoto errout;\n\t}\n\n\tif (pev->event) {\n\t\ttev->event = strdup(pev->event);\n\t\tif (!tev->event)\n\t\t\tgoto errout;\n\t}\n\n\ttev->nargs = pev->nargs;\n\ttev->args = zalloc(sizeof(struct probe_trace_arg) * tev->nargs);\n\tif (!tev->args)\n\t\tgoto errout;\n\n\tfor (i = 0; i < tev->nargs; i++)\n\t\tcopy_to_probe_trace_arg(&tev->args[i], &pev->args[i]);\n\n\treturn 1;\n\nerrout:\n\tclear_probe_trace_events(*tevs, 1);\n\t*tevs = NULL;\n\treturn err;\n}\n\n \nstatic void *memcat(void *a, size_t sz_a, void *b, size_t sz_b)\n{\n\tvoid *ret;\n\n\tret = malloc(sz_a + sz_b);\n\tif (ret) {\n\t\tmemcpy(ret, a, sz_a);\n\t\tmemcpy(ret + sz_a, b, sz_b);\n\t}\n\treturn ret;\n}\n\nstatic int\nconcat_probe_trace_events(struct probe_trace_event **tevs, int *ntevs,\n\t\t\t  struct probe_trace_event **tevs2, int ntevs2)\n{\n\tstruct probe_trace_event *new_tevs;\n\tint ret = 0;\n\n\tif (*ntevs == 0) {\n\t\t*tevs = *tevs2;\n\t\t*ntevs = ntevs2;\n\t\t*tevs2 = NULL;\n\t\treturn 0;\n\t}\n\n\tif (*ntevs + ntevs2 > probe_conf.max_probes)\n\t\tret = -E2BIG;\n\telse {\n\t\t \n\t\tnew_tevs = memcat(*tevs, (*ntevs) * sizeof(**tevs),\n\t\t\t\t  *tevs2, ntevs2 * sizeof(**tevs2));\n\t\tif (!new_tevs)\n\t\t\tret = -ENOMEM;\n\t\telse {\n\t\t\tfree(*tevs);\n\t\t\t*tevs = new_tevs;\n\t\t\t*ntevs += ntevs2;\n\t\t}\n\t}\n\tif (ret < 0)\n\t\tclear_probe_trace_events(*tevs2, ntevs2);\n\tzfree(tevs2);\n\n\treturn ret;\n}\n\n \nstatic int find_cached_events(struct perf_probe_event *pev,\n\t\t\t      struct probe_trace_event **tevs,\n\t\t\t      const char *target)\n{\n\tstruct probe_cache *cache;\n\tstruct probe_cache_entry *entry;\n\tstruct probe_trace_event *tmp_tevs = NULL;\n\tint ntevs = 0;\n\tint ret = 0;\n\n\tcache = probe_cache__new(target, pev->nsi);\n\t \n\tif (!cache)\n\t\treturn 0;\n\n\tfor_each_probe_cache_entry(entry, cache) {\n\t\t \n\t\tif (!entry->pev.event || !entry->pev.group)\n\t\t\tcontinue;\n\t\tif ((!pev->group || strglobmatch(entry->pev.group, pev->group)) &&\n\t\t    strglobmatch(entry->pev.event, pev->event)) {\n\t\t\tret = probe_cache_entry__get_event(entry, &tmp_tevs);\n\t\t\tif (ret > 0)\n\t\t\t\tret = concat_probe_trace_events(tevs, &ntevs,\n\t\t\t\t\t\t\t\t&tmp_tevs, ret);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprobe_cache__delete(cache);\n\tif (ret < 0) {\n\t\tclear_probe_trace_events(*tevs, ntevs);\n\t\tzfree(tevs);\n\t} else {\n\t\tret = ntevs;\n\t\tif (ntevs > 0 && target && target[0] == '/')\n\t\t\tpev->uprobes = true;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int find_cached_events_all(struct perf_probe_event *pev,\n\t\t\t\t   struct probe_trace_event **tevs)\n{\n\tstruct probe_trace_event *tmp_tevs = NULL;\n\tstruct strlist *bidlist;\n\tstruct str_node *nd;\n\tchar *pathname;\n\tint ntevs = 0;\n\tint ret;\n\n\t \n\tbidlist = build_id_cache__list_all(true);\n\tif (!bidlist) {\n\t\tret = -errno;\n\t\tpr_debug(\"Failed to get buildids: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = 0;\n\tstrlist__for_each_entry(nd, bidlist) {\n\t\tpathname = build_id_cache__origname(nd->s);\n\t\tret = find_cached_events(pev, &tmp_tevs, pathname);\n\t\t \n\t\tif (ret > 0)\n\t\t\tret = concat_probe_trace_events(tevs, &ntevs,\n\t\t\t\t\t\t\t&tmp_tevs, ret);\n\t\tfree(pathname);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tstrlist__delete(bidlist);\n\n\tif (ret < 0) {\n\t\tclear_probe_trace_events(*tevs, ntevs);\n\t\tzfree(tevs);\n\t} else\n\t\tret = ntevs;\n\n\treturn ret;\n}\n\nstatic int find_probe_trace_events_from_cache(struct perf_probe_event *pev,\n\t\t\t\t\t      struct probe_trace_event **tevs)\n{\n\tstruct probe_cache *cache;\n\tstruct probe_cache_entry *entry;\n\tstruct probe_trace_event *tev;\n\tstruct str_node *node;\n\tint ret, i;\n\n\tif (pev->sdt) {\n\t\t \n\t\tif (!pev->target)\n\t\t\treturn find_cached_events_all(pev, tevs);\n\t\telse\n\t\t\treturn find_cached_events(pev, tevs, pev->target);\n\t}\n\tcache = probe_cache__new(pev->target, pev->nsi);\n\tif (!cache)\n\t\treturn 0;\n\n\tentry = probe_cache__find(cache, pev);\n\tif (!entry) {\n\t\t \n\t\tret = pev->sdt ? -ENOENT : 0;\n\t\tgoto out;\n\t}\n\n\tret = strlist__nr_entries(entry->tevlist);\n\tif (ret > probe_conf.max_probes) {\n\t\tpr_debug(\"Too many entries matched in the cache of %s\\n\",\n\t\t\t pev->target ? : \"kernel\");\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\t*tevs = zalloc(ret * sizeof(*tev));\n\tif (!*tevs) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ti = 0;\n\tstrlist__for_each_entry(node, entry->tevlist) {\n\t\ttev = &(*tevs)[i++];\n\t\tret = parse_probe_trace_command(node->s, tev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t \n\t\ttev->uprobes = pev->uprobes;\n\t}\n\tret = i;\n\nout:\n\tprobe_cache__delete(cache);\n\treturn ret;\n}\n\nstatic int convert_to_probe_trace_events(struct perf_probe_event *pev,\n\t\t\t\t\t struct probe_trace_event **tevs)\n{\n\tint ret;\n\n\tif (!pev->group && !pev->sdt) {\n\t\t \n\t\tif (!pev->uprobes) {\n\t\t\tpev->group = strdup(PERFPROBE_GROUP);\n\t\t\tret = pev->group ? 0 : -ENOMEM;\n\t\t} else\n\t\t\tret = convert_exec_to_group(pev->target, &pev->group);\n\t\tif (ret != 0) {\n\t\t\tpr_warning(\"Failed to make a group name.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = try_to_find_absolute_address(pev, tevs);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t \n\tret = find_probe_trace_events_from_cache(pev, tevs);\n\tif (ret > 0 || pev->sdt)\t \n\t\treturn ret == 0 ? -ENOENT : ret;  \n\n\t \n\tret = try_to_find_probe_trace_events(pev, tevs);\n\tif (ret != 0)\n\t\treturn ret;\t \n\n\treturn find_probe_trace_events_from_map(pev, tevs);\n}\n\nint convert_perf_probe_events(struct perf_probe_event *pevs, int npevs)\n{\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < npevs; i++) {\n\t\t \n\t\tif (!pevs[i].uprobes)\n\t\t\tkprobe_blacklist__init();\n\t\t \n\t\tret  = convert_to_probe_trace_events(&pevs[i], &pevs[i].tevs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpevs[i].ntevs = ret;\n\t}\n\t \n\tkprobe_blacklist__release();\n\n\treturn 0;\n}\n\nstatic int show_probe_trace_event(struct probe_trace_event *tev)\n{\n\tchar *buf = synthesize_probe_trace_command(tev);\n\n\tif (!buf) {\n\t\tpr_debug(\"Failed to synthesize probe trace event.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tprintf(\"%s\\n\", buf);\n\tfree(buf);\n\n\treturn 0;\n}\n\nint show_probe_trace_events(struct perf_probe_event *pevs, int npevs)\n{\n\tstruct strlist *namelist = strlist__new(NULL, NULL);\n\tstruct probe_trace_event *tev;\n\tstruct perf_probe_event *pev;\n\tint i, j, ret = 0;\n\n\tif (!namelist)\n\t\treturn -ENOMEM;\n\n\tfor (j = 0; j < npevs && !ret; j++) {\n\t\tpev = &pevs[j];\n\t\tfor (i = 0; i < pev->ntevs && !ret; i++) {\n\t\t\ttev = &pev->tevs[i];\n\t\t\t \n\t\t\tif (!tev->point.symbol && !pev->uprobes)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tret = probe_trace_event__set_name(tev, pev,\n\t\t\t\t\t\t\t  namelist, true);\n\t\t\tif (!ret)\n\t\t\t\tret = show_probe_trace_event(tev);\n\t\t}\n\t}\n\tstrlist__delete(namelist);\n\n\treturn ret;\n}\n\nstatic int show_bootconfig_event(struct probe_trace_event *tev)\n{\n\tstruct probe_trace_point *tp = &tev->point;\n\tstruct strbuf buf;\n\tchar *ret = NULL;\n\tint err;\n\n\tif (strbuf_init(&buf, 32) < 0)\n\t\treturn -ENOMEM;\n\n\terr = synthesize_kprobe_trace_def(tp, &buf);\n\tif (err >= 0)\n\t\terr = synthesize_probe_trace_args(tev, &buf);\n\tif (err >= 0)\n\t\tret = strbuf_detach(&buf, NULL);\n\tstrbuf_release(&buf);\n\n\tif (ret) {\n\t\tprintf(\"'%s'\", ret);\n\t\tfree(ret);\n\t}\n\n\treturn err;\n}\n\nint show_bootconfig_events(struct perf_probe_event *pevs, int npevs)\n{\n\tstruct strlist *namelist = strlist__new(NULL, NULL);\n\tstruct probe_trace_event *tev;\n\tstruct perf_probe_event *pev;\n\tchar *cur_name = NULL;\n\tint i, j, ret = 0;\n\n\tif (!namelist)\n\t\treturn -ENOMEM;\n\n\tfor (j = 0; j < npevs && !ret; j++) {\n\t\tpev = &pevs[j];\n\t\tif (pev->group && strcmp(pev->group, \"probe\"))\n\t\t\tpr_warning(\"WARN: Group name %s is ignored\\n\", pev->group);\n\t\tif (pev->uprobes) {\n\t\t\tpr_warning(\"ERROR: Bootconfig doesn't support uprobes\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < pev->ntevs && !ret; i++) {\n\t\t\ttev = &pev->tevs[i];\n\t\t\t \n\t\t\tif (!tev->point.symbol && !pev->uprobes)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tret = probe_trace_event__set_name(tev, pev,\n\t\t\t\t\t\t\t  namelist, true);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (!cur_name || strcmp(cur_name, tev->event)) {\n\t\t\t\tprintf(\"%sftrace.event.kprobes.%s.probe = \",\n\t\t\t\t\tcur_name ? \"\\n\" : \"\", tev->event);\n\t\t\t\tcur_name = tev->event;\n\t\t\t} else\n\t\t\t\tprintf(\", \");\n\t\t\tret = show_bootconfig_event(tev);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\tstrlist__delete(namelist);\n\n\treturn ret;\n}\n\nint apply_perf_probe_events(struct perf_probe_event *pevs, int npevs)\n{\n\tint i, ret = 0;\n\n\t \n\tfor (i = 0; i < npevs; i++) {\n\t\tret = __add_probe_trace_events(&pevs[i], pevs[i].tevs,\n\t\t\t\t\t       pevs[i].ntevs,\n\t\t\t\t\t       probe_conf.force_add);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nvoid cleanup_perf_probe_events(struct perf_probe_event *pevs, int npevs)\n{\n\tint i, j;\n\tstruct perf_probe_event *pev;\n\n\t \n\tfor (i = 0; i < npevs; i++) {\n\t\tpev = &pevs[i];\n\t\tfor (j = 0; j < pevs[i].ntevs; j++)\n\t\t\tclear_probe_trace_event(&pevs[i].tevs[j]);\n\t\tzfree(&pevs[i].tevs);\n\t\tpevs[i].ntevs = 0;\n\t\tnsinfo__zput(pev->nsi);\n\t\tclear_perf_probe_event(&pevs[i]);\n\t}\n}\n\nint add_perf_probe_events(struct perf_probe_event *pevs, int npevs)\n{\n\tint ret;\n\n\tret = init_probe_symbol_maps(pevs->uprobes);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = convert_perf_probe_events(pevs, npevs);\n\tif (ret == 0)\n\t\tret = apply_perf_probe_events(pevs, npevs);\n\n\tcleanup_perf_probe_events(pevs, npevs);\n\n\texit_probe_symbol_maps();\n\treturn ret;\n}\n\nint del_perf_probe_events(struct strfilter *filter)\n{\n\tint ret, ret2, ufd = -1, kfd = -1;\n\tchar *str = strfilter__string(filter);\n\n\tif (!str)\n\t\treturn -EINVAL;\n\n\t \n\tret = probe_file__open_both(&kfd, &ufd, PF_FL_RW);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = probe_file__del_events(kfd, filter);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto error;\n\n\tret2 = probe_file__del_events(ufd, filter);\n\tif (ret2 < 0 && ret2 != -ENOENT) {\n\t\tret = ret2;\n\t\tgoto error;\n\t}\n\tret = 0;\n\nerror:\n\tif (kfd >= 0)\n\t\tclose(kfd);\n\tif (ufd >= 0)\n\t\tclose(ufd);\nout:\n\tfree(str);\n\n\treturn ret;\n}\n\nint show_available_funcs(const char *target, struct nsinfo *nsi,\n\t\t\t struct strfilter *_filter, bool user)\n{\n\tstruct map *map;\n\tstruct dso *dso;\n\tint ret;\n\n\tret = init_probe_symbol_maps(user);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmap = get_target_map(target, nsi, user);\n\tif (!map) {\n\t\tpr_err(\"Failed to get a map for %s\\n\", (target) ? : \"kernel\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = map__load(map);\n\tif (ret) {\n\t\tif (ret == -2) {\n\t\t\tchar *str = strfilter__string(_filter);\n\t\t\tpr_err(\"Failed to find symbols matched to \\\"%s\\\"\\n\",\n\t\t\t       str);\n\t\t\tfree(str);\n\t\t} else\n\t\t\tpr_err(\"Failed to load symbols in %s\\n\",\n\t\t\t       (target) ? : \"kernel\");\n\t\tgoto end;\n\t}\n\tdso = map__dso(map);\n\tdso__sort_by_name(dso);\n\n\t \n\tsetup_pager();\n\n\tfor (size_t i = 0; i < dso->symbol_names_len; i++) {\n\t\tstruct symbol *pos = dso->symbol_names[i];\n\n\t\tif (strfilter__compare(_filter, pos->name))\n\t\t\tprintf(\"%s\\n\", pos->name);\n\t}\nend:\n\tmap__put(map);\n\texit_probe_symbol_maps();\n\n\treturn ret;\n}\n\nint copy_to_probe_trace_arg(struct probe_trace_arg *tvar,\n\t\t\t    struct perf_probe_arg *pvar)\n{\n\ttvar->value = strdup(pvar->var);\n\tif (tvar->value == NULL)\n\t\treturn -ENOMEM;\n\tif (pvar->type) {\n\t\ttvar->type = strdup(pvar->type);\n\t\tif (tvar->type == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (pvar->name) {\n\t\ttvar->name = strdup(pvar->name);\n\t\tif (tvar->name == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\ttvar->name = NULL;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}