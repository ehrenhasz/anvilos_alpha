{
  "module_name": "stat-display.c",
  "hash_id": "b1a86b2cdb1ca8bc76a7a3ca43ed725e574fd6cabe2301ac5d65db9614cb46a0",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/stat-display.c",
  "human_readable_source": "#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <linux/string.h>\n#include <linux/time64.h>\n#include <math.h>\n#include <perf/cpumap.h>\n#include \"color.h\"\n#include \"counts.h\"\n#include \"evlist.h\"\n#include \"evsel.h\"\n#include \"stat.h\"\n#include \"top.h\"\n#include \"thread_map.h\"\n#include \"cpumap.h\"\n#include \"string2.h\"\n#include <linux/ctype.h>\n#include \"cgroup.h\"\n#include <api/fs/fs.h>\n#include \"util.h\"\n#include \"iostat.h\"\n#include \"pmu.h\"\n#include \"pmus.h\"\n\n#define CNTR_NOT_SUPPORTED\t\"<not supported>\"\n#define CNTR_NOT_COUNTED\t\"<not counted>\"\n\n#define MGROUP_LEN   50\n#define METRIC_LEN   38\n#define EVNAME_LEN   32\n#define COUNTS_LEN   18\n#define INTERVAL_LEN 16\n#define CGROUP_LEN   16\n#define COMM_LEN     16\n#define PID_LEN       7\n#define CPUS_LEN      4\n\nstatic int aggr_header_lens[] = {\n\t[AGGR_CORE] \t= 18,\n\t[AGGR_CACHE]\t= 22,\n\t[AGGR_DIE] \t= 12,\n\t[AGGR_SOCKET] \t= 6,\n\t[AGGR_NODE] \t= 6,\n\t[AGGR_NONE] \t= 6,\n\t[AGGR_THREAD] \t= 16,\n\t[AGGR_GLOBAL] \t= 0,\n};\n\nstatic const char *aggr_header_csv[] = {\n\t[AGGR_CORE] \t= \t\"core,cpus,\",\n\t[AGGR_CACHE]\t= \t\"cache,cpus,\",\n\t[AGGR_DIE] \t= \t\"die,cpus,\",\n\t[AGGR_SOCKET] \t= \t\"socket,cpus,\",\n\t[AGGR_NONE] \t= \t\"cpu,\",\n\t[AGGR_THREAD] \t= \t\"comm-pid,\",\n\t[AGGR_NODE] \t= \t\"node,\",\n\t[AGGR_GLOBAL] \t=\t\"\"\n};\n\nstatic const char *aggr_header_std[] = {\n\t[AGGR_CORE] \t= \t\"core\",\n\t[AGGR_CACHE] \t= \t\"cache\",\n\t[AGGR_DIE] \t= \t\"die\",\n\t[AGGR_SOCKET] \t= \t\"socket\",\n\t[AGGR_NONE] \t= \t\"cpu\",\n\t[AGGR_THREAD] \t= \t\"comm-pid\",\n\t[AGGR_NODE] \t= \t\"node\",\n\t[AGGR_GLOBAL] \t=\t\"\"\n};\n\nstatic void print_running_std(struct perf_stat_config *config, u64 run, u64 ena)\n{\n\tif (run != ena)\n\t\tfprintf(config->output, \"  (%.2f%%)\", 100.0 * run / ena);\n}\n\nstatic void print_running_csv(struct perf_stat_config *config, u64 run, u64 ena)\n{\n\tdouble enabled_percent = 100;\n\n\tif (run != ena)\n\t\tenabled_percent = 100 * run / ena;\n\tfprintf(config->output, \"%s%\" PRIu64 \"%s%.2f\",\n\t\tconfig->csv_sep, run, config->csv_sep, enabled_percent);\n}\n\nstatic void print_running_json(struct perf_stat_config *config, u64 run, u64 ena)\n{\n\tdouble enabled_percent = 100;\n\n\tif (run != ena)\n\t\tenabled_percent = 100 * run / ena;\n\tfprintf(config->output, \"\\\"event-runtime\\\" : %\" PRIu64 \", \\\"pcnt-running\\\" : %.2f, \",\n\t\trun, enabled_percent);\n}\n\nstatic void print_running(struct perf_stat_config *config,\n\t\t\t  u64 run, u64 ena, bool before_metric)\n{\n\tif (config->json_output) {\n\t\tif (before_metric)\n\t\t\tprint_running_json(config, run, ena);\n\t} else if (config->csv_output) {\n\t\tif (before_metric)\n\t\t\tprint_running_csv(config, run, ena);\n\t} else {\n\t\tif (!before_metric)\n\t\t\tprint_running_std(config, run, ena);\n\t}\n}\n\nstatic void print_noise_pct_std(struct perf_stat_config *config,\n\t\t\t\tdouble pct)\n{\n\tif (pct)\n\t\tfprintf(config->output, \"  ( +-%6.2f%% )\", pct);\n}\n\nstatic void print_noise_pct_csv(struct perf_stat_config *config,\n\t\t\t\tdouble pct)\n{\n\tfprintf(config->output, \"%s%.2f%%\", config->csv_sep, pct);\n}\n\nstatic void print_noise_pct_json(struct perf_stat_config *config,\n\t\t\t\t double pct)\n{\n\tfprintf(config->output, \"\\\"variance\\\" : %.2f, \", pct);\n}\n\nstatic void print_noise_pct(struct perf_stat_config *config,\n\t\t\t    double total, double avg, bool before_metric)\n{\n\tdouble pct = rel_stddev_stats(total, avg);\n\n\tif (config->json_output) {\n\t\tif (before_metric)\n\t\t\tprint_noise_pct_json(config, pct);\n\t} else if (config->csv_output) {\n\t\tif (before_metric)\n\t\t\tprint_noise_pct_csv(config, pct);\n\t} else {\n\t\tif (!before_metric)\n\t\t\tprint_noise_pct_std(config, pct);\n\t}\n}\n\nstatic void print_noise(struct perf_stat_config *config,\n\t\t\tstruct evsel *evsel, double avg, bool before_metric)\n{\n\tstruct perf_stat_evsel *ps;\n\n\tif (config->run_count == 1)\n\t\treturn;\n\n\tps = evsel->stats;\n\tprint_noise_pct(config, stddev_stats(&ps->res_stats), avg, before_metric);\n}\n\nstatic void print_cgroup_std(struct perf_stat_config *config, const char *cgrp_name)\n{\n\tfprintf(config->output, \" %-*s\", CGROUP_LEN, cgrp_name);\n}\n\nstatic void print_cgroup_csv(struct perf_stat_config *config, const char *cgrp_name)\n{\n\tfprintf(config->output, \"%s%s\", config->csv_sep, cgrp_name);\n}\n\nstatic void print_cgroup_json(struct perf_stat_config *config, const char *cgrp_name)\n{\n\tfprintf(config->output, \"\\\"cgroup\\\" : \\\"%s\\\", \", cgrp_name);\n}\n\nstatic void print_cgroup(struct perf_stat_config *config, struct cgroup *cgrp)\n{\n\tif (nr_cgroups || config->cgroup_list) {\n\t\tconst char *cgrp_name = cgrp ? cgrp->name  : \"\";\n\n\t\tif (config->json_output)\n\t\t\tprint_cgroup_json(config, cgrp_name);\n\t\telse if (config->csv_output)\n\t\t\tprint_cgroup_csv(config, cgrp_name);\n\t\telse\n\t\t\tprint_cgroup_std(config, cgrp_name);\n\t}\n}\n\nstatic void print_aggr_id_std(struct perf_stat_config *config,\n\t\t\t      struct evsel *evsel, struct aggr_cpu_id id, int aggr_nr)\n{\n\tFILE *output = config->output;\n\tint idx = config->aggr_mode;\n\tchar buf[128];\n\n\tswitch (config->aggr_mode) {\n\tcase AGGR_CORE:\n\t\tsnprintf(buf, sizeof(buf), \"S%d-D%d-C%d\", id.socket, id.die, id.core);\n\t\tbreak;\n\tcase AGGR_CACHE:\n\t\tsnprintf(buf, sizeof(buf), \"S%d-D%d-L%d-ID%d\",\n\t\t\t id.socket, id.die, id.cache_lvl, id.cache);\n\t\tbreak;\n\tcase AGGR_DIE:\n\t\tsnprintf(buf, sizeof(buf), \"S%d-D%d\", id.socket, id.die);\n\t\tbreak;\n\tcase AGGR_SOCKET:\n\t\tsnprintf(buf, sizeof(buf), \"S%d\", id.socket);\n\t\tbreak;\n\tcase AGGR_NODE:\n\t\tsnprintf(buf, sizeof(buf), \"N%d\", id.node);\n\t\tbreak;\n\tcase AGGR_NONE:\n\t\tif (evsel->percore && !config->percore_show_thread) {\n\t\t\tsnprintf(buf, sizeof(buf), \"S%d-D%d-C%d \",\n\t\t\t\tid.socket, id.die, id.core);\n\t\t\tfprintf(output, \"%-*s \",\n\t\t\t\taggr_header_lens[AGGR_CORE], buf);\n\t\t} else if (id.cpu.cpu > -1) {\n\t\t\tfprintf(output, \"CPU%-*d \",\n\t\t\t\taggr_header_lens[AGGR_NONE] - 3, id.cpu.cpu);\n\t\t}\n\t\treturn;\n\tcase AGGR_THREAD:\n\t\tfprintf(output, \"%*s-%-*d \",\n\t\t\tCOMM_LEN, perf_thread_map__comm(evsel->core.threads, id.thread_idx),\n\t\t\tPID_LEN, perf_thread_map__pid(evsel->core.threads, id.thread_idx));\n\t\treturn;\n\tcase AGGR_GLOBAL:\n\tcase AGGR_UNSET:\n\tcase AGGR_MAX:\n\tdefault:\n\t\treturn;\n\t}\n\n\tfprintf(output, \"%-*s %*d \", aggr_header_lens[idx], buf, 4, aggr_nr);\n}\n\nstatic void print_aggr_id_csv(struct perf_stat_config *config,\n\t\t\t      struct evsel *evsel, struct aggr_cpu_id id, int aggr_nr)\n{\n\tFILE *output = config->output;\n\tconst char *sep = config->csv_sep;\n\n\tswitch (config->aggr_mode) {\n\tcase AGGR_CORE:\n\t\tfprintf(output, \"S%d-D%d-C%d%s%d%s\",\n\t\t\tid.socket, id.die, id.core, sep, aggr_nr, sep);\n\t\tbreak;\n\tcase AGGR_CACHE:\n\t\tfprintf(config->output, \"S%d-D%d-L%d-ID%d%s%d%s\",\n\t\t\tid.socket, id.die, id.cache_lvl, id.cache, sep, aggr_nr, sep);\n\t\tbreak;\n\tcase AGGR_DIE:\n\t\tfprintf(output, \"S%d-D%d%s%d%s\",\n\t\t\tid.socket, id.die, sep, aggr_nr, sep);\n\t\tbreak;\n\tcase AGGR_SOCKET:\n\t\tfprintf(output, \"S%d%s%d%s\",\n\t\t\tid.socket, sep, aggr_nr, sep);\n\t\tbreak;\n\tcase AGGR_NODE:\n\t\tfprintf(output, \"N%d%s%d%s\",\n\t\t\tid.node, sep, aggr_nr, sep);\n\t\tbreak;\n\tcase AGGR_NONE:\n\t\tif (evsel->percore && !config->percore_show_thread) {\n\t\t\tfprintf(output, \"S%d-D%d-C%d%s\",\n\t\t\t\tid.socket, id.die, id.core, sep);\n\t\t} else if (id.cpu.cpu > -1) {\n\t\t\tfprintf(output, \"CPU%d%s\",\n\t\t\t\tid.cpu.cpu, sep);\n\t\t}\n\t\tbreak;\n\tcase AGGR_THREAD:\n\t\tfprintf(output, \"%s-%d%s\",\n\t\t\tperf_thread_map__comm(evsel->core.threads, id.thread_idx),\n\t\t\tperf_thread_map__pid(evsel->core.threads, id.thread_idx),\n\t\t\tsep);\n\t\tbreak;\n\tcase AGGR_GLOBAL:\n\tcase AGGR_UNSET:\n\tcase AGGR_MAX:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void print_aggr_id_json(struct perf_stat_config *config,\n\t\t\t       struct evsel *evsel, struct aggr_cpu_id id, int aggr_nr)\n{\n\tFILE *output = config->output;\n\n\tswitch (config->aggr_mode) {\n\tcase AGGR_CORE:\n\t\tfprintf(output, \"\\\"core\\\" : \\\"S%d-D%d-C%d\\\", \\\"aggregate-number\\\" : %d, \",\n\t\t\tid.socket, id.die, id.core, aggr_nr);\n\t\tbreak;\n\tcase AGGR_CACHE:\n\t\tfprintf(output, \"\\\"cache\\\" : \\\"S%d-D%d-L%d-ID%d\\\", \\\"aggregate-number\\\" : %d, \",\n\t\t\tid.socket, id.die, id.cache_lvl, id.cache, aggr_nr);\n\t\tbreak;\n\tcase AGGR_DIE:\n\t\tfprintf(output, \"\\\"die\\\" : \\\"S%d-D%d\\\", \\\"aggregate-number\\\" : %d, \",\n\t\t\tid.socket, id.die, aggr_nr);\n\t\tbreak;\n\tcase AGGR_SOCKET:\n\t\tfprintf(output, \"\\\"socket\\\" : \\\"S%d\\\", \\\"aggregate-number\\\" : %d, \",\n\t\t\tid.socket, aggr_nr);\n\t\tbreak;\n\tcase AGGR_NODE:\n\t\tfprintf(output, \"\\\"node\\\" : \\\"N%d\\\", \\\"aggregate-number\\\" : %d, \",\n\t\t\tid.node, aggr_nr);\n\t\tbreak;\n\tcase AGGR_NONE:\n\t\tif (evsel->percore && !config->percore_show_thread) {\n\t\t\tfprintf(output, \"\\\"core\\\" : \\\"S%d-D%d-C%d\\\"\",\n\t\t\t\tid.socket, id.die, id.core);\n\t\t} else if (id.cpu.cpu > -1) {\n\t\t\tfprintf(output, \"\\\"cpu\\\" : \\\"%d\\\", \",\n\t\t\t\tid.cpu.cpu);\n\t\t}\n\t\tbreak;\n\tcase AGGR_THREAD:\n\t\tfprintf(output, \"\\\"thread\\\" : \\\"%s-%d\\\", \",\n\t\t\tperf_thread_map__comm(evsel->core.threads, id.thread_idx),\n\t\t\tperf_thread_map__pid(evsel->core.threads, id.thread_idx));\n\t\tbreak;\n\tcase AGGR_GLOBAL:\n\tcase AGGR_UNSET:\n\tcase AGGR_MAX:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void aggr_printout(struct perf_stat_config *config,\n\t\t\t  struct evsel *evsel, struct aggr_cpu_id id, int aggr_nr)\n{\n\tif (config->json_output)\n\t\tprint_aggr_id_json(config, evsel, id, aggr_nr);\n\telse if (config->csv_output)\n\t\tprint_aggr_id_csv(config, evsel, id, aggr_nr);\n\telse\n\t\tprint_aggr_id_std(config, evsel, id, aggr_nr);\n}\n\nstruct outstate {\n\tFILE *fh;\n\tbool newline;\n\tbool first;\n\tconst char *prefix;\n\tint  nfields;\n\tint  aggr_nr;\n\tstruct aggr_cpu_id id;\n\tstruct evsel *evsel;\n\tstruct cgroup *cgrp;\n};\n\nstatic void new_line_std(struct perf_stat_config *config __maybe_unused,\n\t\t\t void *ctx)\n{\n\tstruct outstate *os = ctx;\n\n\tos->newline = true;\n}\n\nstatic inline void __new_line_std_csv(struct perf_stat_config *config,\n\t\t\t\t      struct outstate *os)\n{\n\tfputc('\\n', os->fh);\n\tif (os->prefix)\n\t\tfputs(os->prefix, os->fh);\n\taggr_printout(config, os->evsel, os->id, os->aggr_nr);\n}\n\nstatic inline void __new_line_std(struct outstate *os)\n{\n\tfprintf(os->fh, \"                                                 \");\n}\n\nstatic void do_new_line_std(struct perf_stat_config *config,\n\t\t\t    struct outstate *os)\n{\n\t__new_line_std_csv(config, os);\n\tif (config->aggr_mode == AGGR_NONE)\n\t\tfprintf(os->fh, \"        \");\n\t__new_line_std(os);\n}\n\nstatic void print_metric_std(struct perf_stat_config *config,\n\t\t\t     void *ctx, const char *color, const char *fmt,\n\t\t\t     const char *unit, double val)\n{\n\tstruct outstate *os = ctx;\n\tFILE *out = os->fh;\n\tint n;\n\tbool newline = os->newline;\n\n\tos->newline = false;\n\n\tif (unit == NULL || fmt == NULL) {\n\t\tfprintf(out, \"%-*s\", METRIC_LEN, \"\");\n\t\treturn;\n\t}\n\n\tif (newline)\n\t\tdo_new_line_std(config, os);\n\n\tn = fprintf(out, \" # \");\n\tif (color)\n\t\tn += color_fprintf(out, color, fmt, val);\n\telse\n\t\tn += fprintf(out, fmt, val);\n\tfprintf(out, \" %-*s\", METRIC_LEN - n - 1, unit);\n}\n\nstatic void new_line_csv(struct perf_stat_config *config, void *ctx)\n{\n\tstruct outstate *os = ctx;\n\tint i;\n\n\t__new_line_std_csv(config, os);\n\tfor (i = 0; i < os->nfields; i++)\n\t\tfputs(config->csv_sep, os->fh);\n}\n\nstatic void print_metric_csv(struct perf_stat_config *config __maybe_unused,\n\t\t\t     void *ctx,\n\t\t\t     const char *color __maybe_unused,\n\t\t\t     const char *fmt, const char *unit, double val)\n{\n\tstruct outstate *os = ctx;\n\tFILE *out = os->fh;\n\tchar buf[64], *vals, *ends;\n\n\tif (unit == NULL || fmt == NULL) {\n\t\tfprintf(out, \"%s%s\", config->csv_sep, config->csv_sep);\n\t\treturn;\n\t}\n\tsnprintf(buf, sizeof(buf), fmt, val);\n\tends = vals = skip_spaces(buf);\n\twhile (isdigit(*ends) || *ends == '.')\n\t\tends++;\n\t*ends = 0;\n\tfprintf(out, \"%s%s%s%s\", config->csv_sep, vals, config->csv_sep, skip_spaces(unit));\n}\n\nstatic void print_metric_json(struct perf_stat_config *config __maybe_unused,\n\t\t\t     void *ctx,\n\t\t\t     const char *color __maybe_unused,\n\t\t\t     const char *fmt __maybe_unused,\n\t\t\t     const char *unit, double val)\n{\n\tstruct outstate *os = ctx;\n\tFILE *out = os->fh;\n\n\tfprintf(out, \"\\\"metric-value\\\" : \\\"%f\\\", \", val);\n\tfprintf(out, \"\\\"metric-unit\\\" : \\\"%s\\\"\", unit);\n\tif (!config->metric_only)\n\t\tfprintf(out, \"}\");\n}\n\nstatic void new_line_json(struct perf_stat_config *config, void *ctx)\n{\n\tstruct outstate *os = ctx;\n\n\tfputs(\"\\n{\", os->fh);\n\tif (os->prefix)\n\t\tfprintf(os->fh, \"%s\", os->prefix);\n\taggr_printout(config, os->evsel, os->id, os->aggr_nr);\n}\n\nstatic void print_metricgroup_header_json(struct perf_stat_config *config,\n\t\t\t\t\t  void *ctx,\n\t\t\t\t\t  const char *metricgroup_name)\n{\n\tif (!metricgroup_name)\n\t\treturn;\n\n\tfprintf(config->output, \"\\\"metricgroup\\\" : \\\"%s\\\"}\", metricgroup_name);\n\tnew_line_json(config, ctx);\n}\n\nstatic void print_metricgroup_header_csv(struct perf_stat_config *config,\n\t\t\t\t\t void *ctx,\n\t\t\t\t\t const char *metricgroup_name)\n{\n\tstruct outstate *os = ctx;\n\tint i;\n\n\tif (!metricgroup_name) {\n\t\t \n\t\tfor (i = 0; i < os->nfields - 2; i++)\n\t\t\tfputs(config->csv_sep, os->fh);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < os->nfields; i++)\n\t\tfputs(config->csv_sep, os->fh);\n\tfprintf(config->output, \"%s\", metricgroup_name);\n\tnew_line_csv(config, ctx);\n}\n\nstatic void print_metricgroup_header_std(struct perf_stat_config *config,\n\t\t\t\t\t void *ctx,\n\t\t\t\t\t const char *metricgroup_name)\n{\n\tstruct outstate *os = ctx;\n\tint n;\n\n\tif (!metricgroup_name) {\n\t\t__new_line_std(os);\n\t\treturn;\n\t}\n\n\tn = fprintf(config->output, \" %*s\", EVNAME_LEN, metricgroup_name);\n\n\tfprintf(config->output, \"%*s\", MGROUP_LEN - n - 1, \"\");\n}\n\n \n\nstatic bool valid_only_metric(const char *unit)\n{\n\tif (!unit)\n\t\treturn false;\n\tif (strstr(unit, \"/sec\") ||\n\t    strstr(unit, \"CPUs utilized\"))\n\t\treturn false;\n\treturn true;\n}\n\nstatic const char *fixunit(char *buf, struct evsel *evsel,\n\t\t\t   const char *unit)\n{\n\tif (!strncmp(unit, \"of all\", 6)) {\n\t\tsnprintf(buf, 1024, \"%s %s\", evsel__name(evsel),\n\t\t\t unit);\n\t\treturn buf;\n\t}\n\treturn unit;\n}\n\nstatic void print_metric_only(struct perf_stat_config *config,\n\t\t\t      void *ctx, const char *color, const char *fmt,\n\t\t\t      const char *unit, double val)\n{\n\tstruct outstate *os = ctx;\n\tFILE *out = os->fh;\n\tchar buf[1024], str[1024];\n\tunsigned mlen = config->metric_only_len;\n\n\tif (!valid_only_metric(unit))\n\t\treturn;\n\tunit = fixunit(buf, os->evsel, unit);\n\tif (mlen < strlen(unit))\n\t\tmlen = strlen(unit) + 1;\n\n\tif (color)\n\t\tmlen += strlen(color) + sizeof(PERF_COLOR_RESET) - 1;\n\n\tcolor_snprintf(str, sizeof(str), color ?: \"\", fmt, val);\n\tfprintf(out, \"%*s \", mlen, str);\n\tos->first = false;\n}\n\nstatic void print_metric_only_csv(struct perf_stat_config *config __maybe_unused,\n\t\t\t\t  void *ctx, const char *color __maybe_unused,\n\t\t\t\t  const char *fmt,\n\t\t\t\t  const char *unit, double val)\n{\n\tstruct outstate *os = ctx;\n\tFILE *out = os->fh;\n\tchar buf[64], *vals, *ends;\n\tchar tbuf[1024];\n\n\tif (!valid_only_metric(unit))\n\t\treturn;\n\tunit = fixunit(tbuf, os->evsel, unit);\n\tsnprintf(buf, sizeof(buf), fmt ?: \"\", val);\n\tends = vals = skip_spaces(buf);\n\twhile (isdigit(*ends) || *ends == '.')\n\t\tends++;\n\t*ends = 0;\n\tfprintf(out, \"%s%s\", vals, config->csv_sep);\n\tos->first = false;\n}\n\nstatic void print_metric_only_json(struct perf_stat_config *config __maybe_unused,\n\t\t\t\t  void *ctx, const char *color __maybe_unused,\n\t\t\t\t  const char *fmt,\n\t\t\t\t  const char *unit, double val)\n{\n\tstruct outstate *os = ctx;\n\tFILE *out = os->fh;\n\tchar buf[64], *vals, *ends;\n\tchar tbuf[1024];\n\n\tif (!valid_only_metric(unit))\n\t\treturn;\n\tunit = fixunit(tbuf, os->evsel, unit);\n\tsnprintf(buf, sizeof(buf), fmt ?: \"\", val);\n\tends = vals = skip_spaces(buf);\n\twhile (isdigit(*ends) || *ends == '.')\n\t\tends++;\n\t*ends = 0;\n\tif (!unit[0] || !vals[0])\n\t\treturn;\n\tfprintf(out, \"%s\\\"%s\\\" : \\\"%s\\\"\", os->first ? \"\" : \", \", unit, vals);\n\tos->first = false;\n}\n\nstatic void new_line_metric(struct perf_stat_config *config __maybe_unused,\n\t\t\t    void *ctx __maybe_unused)\n{\n}\n\nstatic void print_metric_header(struct perf_stat_config *config,\n\t\t\t\tvoid *ctx, const char *color __maybe_unused,\n\t\t\t\tconst char *fmt __maybe_unused,\n\t\t\t\tconst char *unit, double val __maybe_unused)\n{\n\tstruct outstate *os = ctx;\n\tchar tbuf[1024];\n\n\t \n\tif (config->iostat_run &&\n\t    os->evsel->priv != os->evsel->evlist->selected->priv)\n\t\treturn;\n\n\tif (os->evsel->cgrp != os->cgrp)\n\t\treturn;\n\n\tif (!valid_only_metric(unit))\n\t\treturn;\n\tunit = fixunit(tbuf, os->evsel, unit);\n\n\tif (config->json_output)\n\t\treturn;\n\telse if (config->csv_output)\n\t\tfprintf(os->fh, \"%s%s\", unit, config->csv_sep);\n\telse\n\t\tfprintf(os->fh, \"%*s \", config->metric_only_len, unit);\n}\n\nstatic void print_counter_value_std(struct perf_stat_config *config,\n\t\t\t\t    struct evsel *evsel, double avg, bool ok)\n{\n\tFILE *output = config->output;\n\tdouble sc =  evsel->scale;\n\tconst char *fmt;\n\tconst char *bad_count = evsel->supported ? CNTR_NOT_COUNTED : CNTR_NOT_SUPPORTED;\n\n\tif (config->big_num)\n\t\tfmt = floor(sc) != sc ? \"%'*.2f \" : \"%'*.0f \";\n\telse\n\t\tfmt = floor(sc) != sc ? \"%*.2f \" : \"%*.0f \";\n\n\tif (ok)\n\t\tfprintf(output, fmt, COUNTS_LEN, avg);\n\telse\n\t\tfprintf(output, \"%*s \", COUNTS_LEN, bad_count);\n\n\tif (evsel->unit)\n\t\tfprintf(output, \"%-*s \", config->unit_width, evsel->unit);\n\n\tfprintf(output, \"%-*s\", EVNAME_LEN, evsel__name(evsel));\n}\n\nstatic void print_counter_value_csv(struct perf_stat_config *config,\n\t\t\t\t    struct evsel *evsel, double avg, bool ok)\n{\n\tFILE *output = config->output;\n\tdouble sc =  evsel->scale;\n\tconst char *sep = config->csv_sep;\n\tconst char *fmt = floor(sc) != sc ? \"%.2f%s\" : \"%.0f%s\";\n\tconst char *bad_count = evsel->supported ? CNTR_NOT_COUNTED : CNTR_NOT_SUPPORTED;\n\n\tif (ok)\n\t\tfprintf(output, fmt, avg, sep);\n\telse\n\t\tfprintf(output, \"%s%s\", bad_count, sep);\n\n\tif (evsel->unit)\n\t\tfprintf(output, \"%s%s\", evsel->unit, sep);\n\n\tfprintf(output, \"%s\", evsel__name(evsel));\n}\n\nstatic void print_counter_value_json(struct perf_stat_config *config,\n\t\t\t\t     struct evsel *evsel, double avg, bool ok)\n{\n\tFILE *output = config->output;\n\tconst char *bad_count = evsel->supported ? CNTR_NOT_COUNTED : CNTR_NOT_SUPPORTED;\n\n\tif (ok)\n\t\tfprintf(output, \"\\\"counter-value\\\" : \\\"%f\\\", \", avg);\n\telse\n\t\tfprintf(output, \"\\\"counter-value\\\" : \\\"%s\\\", \", bad_count);\n\n\tif (evsel->unit)\n\t\tfprintf(output, \"\\\"unit\\\" : \\\"%s\\\", \", evsel->unit);\n\n\tfprintf(output, \"\\\"event\\\" : \\\"%s\\\", \", evsel__name(evsel));\n}\n\nstatic void print_counter_value(struct perf_stat_config *config,\n\t\t\t\tstruct evsel *evsel, double avg, bool ok)\n{\n\tif (config->json_output)\n\t\tprint_counter_value_json(config, evsel, avg, ok);\n\telse if (config->csv_output)\n\t\tprint_counter_value_csv(config, evsel, avg, ok);\n\telse\n\t\tprint_counter_value_std(config, evsel, avg, ok);\n}\n\nstatic void abs_printout(struct perf_stat_config *config,\n\t\t\t struct aggr_cpu_id id, int aggr_nr,\n\t\t\t struct evsel *evsel, double avg, bool ok)\n{\n\taggr_printout(config, evsel, id, aggr_nr);\n\tprint_counter_value(config, evsel, avg, ok);\n\tprint_cgroup(config, evsel->cgrp);\n}\n\nstatic bool is_mixed_hw_group(struct evsel *counter)\n{\n\tstruct evlist *evlist = counter->evlist;\n\tu32 pmu_type = counter->core.attr.type;\n\tstruct evsel *pos;\n\n\tif (counter->core.nr_members < 2)\n\t\treturn false;\n\n\tevlist__for_each_entry(evlist, pos) {\n\t\t \n\t\tif (pos->core.attr.type == PERF_TYPE_SOFTWARE)\n\t\t\tcontinue;\n\t\tif (pmu_type == PERF_TYPE_SOFTWARE) {\n\t\t\tpmu_type = pos->core.attr.type;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pmu_type != pos->core.attr.type)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool evlist__has_hybrid(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tif (perf_pmus__num_core_pmus() == 1)\n\t\treturn false;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.is_pmu_core)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void printout(struct perf_stat_config *config, struct outstate *os,\n\t\t     double uval, u64 run, u64 ena, double noise, int aggr_idx)\n{\n\tstruct perf_stat_output_ctx out;\n\tprint_metric_t pm;\n\tnew_line_t nl;\n\tprint_metricgroup_header_t pmh;\n\tbool ok = true;\n\tstruct evsel *counter = os->evsel;\n\n\tif (config->csv_output) {\n\t\tpm = config->metric_only ? print_metric_only_csv : print_metric_csv;\n\t\tnl = config->metric_only ? new_line_metric : new_line_csv;\n\t\tpmh = print_metricgroup_header_csv;\n\t\tos->nfields = 4 + (counter->cgrp ? 1 : 0);\n\t} else if (config->json_output) {\n\t\tpm = config->metric_only ? print_metric_only_json : print_metric_json;\n\t\tnl = config->metric_only ? new_line_metric : new_line_json;\n\t\tpmh = print_metricgroup_header_json;\n\t} else {\n\t\tpm = config->metric_only ? print_metric_only : print_metric_std;\n\t\tnl = config->metric_only ? new_line_metric : new_line_std;\n\t\tpmh = print_metricgroup_header_std;\n\t}\n\n\tif (run == 0 || ena == 0 || counter->counts->scaled == -1) {\n\t\tif (config->metric_only) {\n\t\t\tpm(config, os, NULL, \"\", \"\", 0);\n\t\t\treturn;\n\t\t}\n\n\t\tok = false;\n\n\t\tif (counter->supported) {\n\t\t\tif (!evlist__has_hybrid(counter->evlist)) {\n\t\t\t\tconfig->print_free_counters_hint = 1;\n\t\t\t\tif (is_mixed_hw_group(counter))\n\t\t\t\t\tconfig->print_mixed_hw_group_error = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tout.print_metric = pm;\n\tout.new_line = nl;\n\tout.print_metricgroup_header = pmh;\n\tout.ctx = os;\n\tout.force_header = false;\n\n\tif (!config->metric_only && !counter->default_metricgroup) {\n\t\tabs_printout(config, os->id, os->aggr_nr, counter, uval, ok);\n\n\t\tprint_noise(config, counter, noise,  true);\n\t\tprint_running(config, run, ena,  true);\n\t}\n\n\tif (ok) {\n\t\tif (!config->metric_only && counter->default_metricgroup) {\n\t\t\tvoid *from = NULL;\n\n\t\t\taggr_printout(config, os->evsel, os->id, os->aggr_nr);\n\t\t\t \n\t\t\tdo {\n\t\t\t\tint num = 0;\n\n\t\t\t\t \n\t\t\t\tif (from) {\n\t\t\t\t\tif (config->json_output)\n\t\t\t\t\t\tnew_line_json(config, (void *)os);\n\t\t\t\t\telse\n\t\t\t\t\t\t__new_line_std_csv(config, os);\n\t\t\t\t}\n\n\t\t\t\tprint_noise(config, counter, noise,  true);\n\t\t\t\tprint_running(config, run, ena,  true);\n\t\t\t\tfrom = perf_stat__print_shadow_stats_metricgroup(config, counter, aggr_idx,\n\t\t\t\t\t\t\t\t\t\t &num, from, &out,\n\t\t\t\t\t\t\t\t\t\t &config->metric_events);\n\t\t\t} while (from != NULL);\n\t\t} else\n\t\t\tperf_stat__print_shadow_stats(config, counter, uval, aggr_idx,\n\t\t\t\t\t\t      &out, &config->metric_events);\n\t} else {\n\t\tpm(config, os,  NULL,  NULL,  \"\",  0);\n\t}\n\n\tif (!config->metric_only) {\n\t\tprint_noise(config, counter, noise,  false);\n\t\tprint_running(config, run, ena,  false);\n\t}\n}\n\nstatic void uniquify_event_name(struct evsel *counter)\n{\n\tchar *new_name;\n\tchar *config;\n\tint ret = 0;\n\n\tif (counter->uniquified_name || counter->use_config_name ||\n\t    !counter->pmu_name || !strncmp(evsel__name(counter), counter->pmu_name,\n\t\t\t\t\t   strlen(counter->pmu_name)))\n\t\treturn;\n\n\tconfig = strchr(counter->name, '/');\n\tif (config) {\n\t\tif (asprintf(&new_name,\n\t\t\t     \"%s%s\", counter->pmu_name, config) > 0) {\n\t\t\tfree(counter->name);\n\t\t\tcounter->name = new_name;\n\t\t}\n\t} else {\n\t\tif (evsel__is_hybrid(counter)) {\n\t\t\tret = asprintf(&new_name, \"%s/%s/\",\n\t\t\t\t       counter->pmu_name, counter->name);\n\t\t} else {\n\t\t\tret = asprintf(&new_name, \"%s [%s]\",\n\t\t\t\t       counter->name, counter->pmu_name);\n\t\t}\n\n\t\tif (ret) {\n\t\t\tfree(counter->name);\n\t\t\tcounter->name = new_name;\n\t\t}\n\t}\n\n\tcounter->uniquified_name = true;\n}\n\nstatic bool hybrid_uniquify(struct evsel *evsel, struct perf_stat_config *config)\n{\n\treturn evsel__is_hybrid(evsel) && !config->hybrid_merge;\n}\n\nstatic void uniquify_counter(struct perf_stat_config *config, struct evsel *counter)\n{\n\tif (config->no_merge || hybrid_uniquify(counter, config))\n\t\tuniquify_event_name(counter);\n}\n\n \nstatic bool should_skip_zero_counter(struct perf_stat_config *config,\n\t\t\t\t     struct evsel *counter,\n\t\t\t\t     const struct aggr_cpu_id *id)\n{\n\tstruct perf_cpu cpu;\n\tint idx;\n\n\t \n\tif (config->aggr_mode == AGGR_THREAD && config->system_wide)\n\t\treturn true;\n\n\t \n\tif (evsel__is_tool(counter))\n\t\treturn true;\n\n\t \n\tif (!counter->pmu || !counter->pmu->is_uncore)\n\t\treturn false;\n\n\tperf_cpu_map__for_each_cpu(cpu, idx, counter->pmu->cpus) {\n\t\tstruct aggr_cpu_id own_id = config->aggr_get_id(config, cpu);\n\n\t\tif (aggr_cpu_id__equal(id, &own_id))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void print_counter_aggrdata(struct perf_stat_config *config,\n\t\t\t\t   struct evsel *counter, int aggr_idx,\n\t\t\t\t   struct outstate *os)\n{\n\tFILE *output = config->output;\n\tu64 ena, run, val;\n\tdouble uval;\n\tstruct perf_stat_evsel *ps = counter->stats;\n\tstruct perf_stat_aggr *aggr = &ps->aggr[aggr_idx];\n\tstruct aggr_cpu_id id = config->aggr_map->map[aggr_idx];\n\tdouble avg = aggr->counts.val;\n\tbool metric_only = config->metric_only;\n\n\tos->id = id;\n\tos->aggr_nr = aggr->nr;\n\tos->evsel = counter;\n\n\t \n\tif (counter->merged_stat)\n\t\treturn;\n\n\tuniquify_counter(config, counter);\n\n\tval = aggr->counts.val;\n\tena = aggr->counts.ena;\n\trun = aggr->counts.run;\n\n\tif (perf_stat__skip_metric_event(counter, &config->metric_events, ena, run))\n\t\treturn;\n\n\tif (val == 0 && should_skip_zero_counter(config, counter, &id))\n\t\treturn;\n\n\tif (!metric_only) {\n\t\tif (config->json_output)\n\t\t\tfputc('{', output);\n\t\tif (os->prefix)\n\t\t\tfprintf(output, \"%s\", os->prefix);\n\t\telse if (config->summary && config->csv_output &&\n\t\t\t !config->no_csv_summary && !config->interval)\n\t\t\tfprintf(output, \"%s%s\", \"summary\", config->csv_sep);\n\t}\n\n\tuval = val * counter->scale;\n\n\tprintout(config, os, uval, run, ena, avg, aggr_idx);\n\n\tif (!metric_only)\n\t\tfputc('\\n', output);\n}\n\nstatic void print_metric_begin(struct perf_stat_config *config,\n\t\t\t       struct evlist *evlist,\n\t\t\t       struct outstate *os, int aggr_idx)\n{\n\tstruct perf_stat_aggr *aggr;\n\tstruct aggr_cpu_id id;\n\tstruct evsel *evsel;\n\n\tos->first = true;\n\tif (!config->metric_only)\n\t\treturn;\n\n\tif (config->json_output)\n\t\tfputc('{', config->output);\n\tif (os->prefix)\n\t\tfprintf(config->output, \"%s\", os->prefix);\n\n\tevsel = evlist__first(evlist);\n\tid = config->aggr_map->map[aggr_idx];\n\taggr = &evsel->stats->aggr[aggr_idx];\n\taggr_printout(config, evsel, id, aggr->nr);\n\n\tprint_cgroup(config, os->cgrp ? : evsel->cgrp);\n}\n\nstatic void print_metric_end(struct perf_stat_config *config, struct outstate *os)\n{\n\tFILE *output = config->output;\n\n\tif (!config->metric_only)\n\t\treturn;\n\n\tif (config->json_output) {\n\t\tif (os->first)\n\t\t\tfputs(\"\\\"metric-value\\\" : \\\"none\\\"\", output);\n\t\tfputc('}', output);\n\t}\n\tfputc('\\n', output);\n}\n\nstatic void print_aggr(struct perf_stat_config *config,\n\t\t       struct evlist *evlist,\n\t\t       struct outstate *os)\n{\n\tstruct evsel *counter;\n\tint aggr_idx;\n\n\tif (!config->aggr_map || !config->aggr_get_id)\n\t\treturn;\n\n\t \n\tcpu_aggr_map__for_each_idx(aggr_idx, config->aggr_map) {\n\t\tprint_metric_begin(config, evlist, os, aggr_idx);\n\n\t\tevlist__for_each_entry(evlist, counter) {\n\t\t\tprint_counter_aggrdata(config, counter, aggr_idx, os);\n\t\t}\n\t\tprint_metric_end(config, os);\n\t}\n}\n\nstatic void print_aggr_cgroup(struct perf_stat_config *config,\n\t\t\t      struct evlist *evlist,\n\t\t\t      struct outstate *os)\n{\n\tstruct evsel *counter, *evsel;\n\tint aggr_idx;\n\n\tif (!config->aggr_map || !config->aggr_get_id)\n\t\treturn;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (os->cgrp == evsel->cgrp)\n\t\t\tcontinue;\n\n\t\tos->cgrp = evsel->cgrp;\n\n\t\tcpu_aggr_map__for_each_idx(aggr_idx, config->aggr_map) {\n\t\t\tprint_metric_begin(config, evlist, os, aggr_idx);\n\n\t\t\tevlist__for_each_entry(evlist, counter) {\n\t\t\t\tif (counter->cgrp != os->cgrp)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tprint_counter_aggrdata(config, counter, aggr_idx, os);\n\t\t\t}\n\t\t\tprint_metric_end(config, os);\n\t\t}\n\t}\n}\n\nstatic void print_counter(struct perf_stat_config *config,\n\t\t\t  struct evsel *counter, struct outstate *os)\n{\n\tint aggr_idx;\n\n\t \n\tif (!config->aggr_map)\n\t\treturn;\n\n\tcpu_aggr_map__for_each_idx(aggr_idx, config->aggr_map) {\n\t\tprint_counter_aggrdata(config, counter, aggr_idx, os);\n\t}\n}\n\nstatic void print_no_aggr_metric(struct perf_stat_config *config,\n\t\t\t\t struct evlist *evlist,\n\t\t\t\t struct outstate *os)\n{\n\tint all_idx;\n\tstruct perf_cpu cpu;\n\n\tperf_cpu_map__for_each_cpu(cpu, all_idx, evlist->core.user_requested_cpus) {\n\t\tstruct evsel *counter;\n\t\tbool first = true;\n\n\t\tevlist__for_each_entry(evlist, counter) {\n\t\t\tu64 ena, run, val;\n\t\t\tdouble uval;\n\t\t\tstruct perf_stat_evsel *ps = counter->stats;\n\t\t\tint aggr_idx = perf_cpu_map__idx(evsel__cpus(counter), cpu);\n\n\t\t\tif (aggr_idx < 0)\n\t\t\t\tcontinue;\n\n\t\t\tos->evsel = counter;\n\t\t\tos->id = aggr_cpu_id__cpu(cpu,  NULL);\n\t\t\tif (first) {\n\t\t\t\tprint_metric_begin(config, evlist, os, aggr_idx);\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tval = ps->aggr[aggr_idx].counts.val;\n\t\t\tena = ps->aggr[aggr_idx].counts.ena;\n\t\t\trun = ps->aggr[aggr_idx].counts.run;\n\n\t\t\tuval = val * counter->scale;\n\t\t\tprintout(config, os, uval, run, ena, 1.0, aggr_idx);\n\t\t}\n\t\tif (!first)\n\t\t\tprint_metric_end(config, os);\n\t}\n}\n\nstatic void print_metric_headers_std(struct perf_stat_config *config,\n\t\t\t\t     bool no_indent)\n{\n\tfputc(' ', config->output);\n\n\tif (!no_indent) {\n\t\tint len = aggr_header_lens[config->aggr_mode];\n\n\t\tif (nr_cgroups || config->cgroup_list)\n\t\t\tlen += CGROUP_LEN + 1;\n\n\t\tfprintf(config->output, \"%*s\", len, \"\");\n\t}\n}\n\nstatic void print_metric_headers_csv(struct perf_stat_config *config,\n\t\t\t\t     bool no_indent __maybe_unused)\n{\n\tif (config->interval)\n\t\tfputs(\"time,\", config->output);\n\tif (!config->iostat_run)\n\t\tfputs(aggr_header_csv[config->aggr_mode], config->output);\n}\n\nstatic void print_metric_headers_json(struct perf_stat_config *config __maybe_unused,\n\t\t\t\t      bool no_indent __maybe_unused)\n{\n}\n\nstatic void print_metric_headers(struct perf_stat_config *config,\n\t\t\t\t struct evlist *evlist, bool no_indent)\n{\n\tstruct evsel *counter;\n\tstruct outstate os = {\n\t\t.fh = config->output\n\t};\n\tstruct perf_stat_output_ctx out = {\n\t\t.ctx = &os,\n\t\t.print_metric = print_metric_header,\n\t\t.new_line = new_line_metric,\n\t\t.force_header = true,\n\t};\n\n\tif (config->json_output)\n\t\tprint_metric_headers_json(config, no_indent);\n\telse if (config->csv_output)\n\t\tprint_metric_headers_csv(config, no_indent);\n\telse\n\t\tprint_metric_headers_std(config, no_indent);\n\n\tif (config->iostat_run)\n\t\tiostat_print_header_prefix(config);\n\n\tif (config->cgroup_list)\n\t\tos.cgrp = evlist__first(evlist)->cgrp;\n\n\t \n\tevlist__for_each_entry(evlist, counter) {\n\t\tos.evsel = counter;\n\n\t\tperf_stat__print_shadow_stats(config, counter, 0,\n\t\t\t\t\t      0,\n\t\t\t\t\t      &out,\n\t\t\t\t\t      &config->metric_events);\n\t}\n\n\tif (!config->json_output)\n\t\tfputc('\\n', config->output);\n}\n\nstatic void prepare_interval(struct perf_stat_config *config,\n\t\t\t     char *prefix, size_t len, struct timespec *ts)\n{\n\tif (config->iostat_run)\n\t\treturn;\n\n\tif (config->json_output)\n\t\tscnprintf(prefix, len, \"\\\"interval\\\" : %lu.%09lu, \",\n\t\t\t  (unsigned long) ts->tv_sec, ts->tv_nsec);\n\telse if (config->csv_output)\n\t\tscnprintf(prefix, len, \"%lu.%09lu%s\",\n\t\t\t  (unsigned long) ts->tv_sec, ts->tv_nsec, config->csv_sep);\n\telse\n\t\tscnprintf(prefix, len, \"%6lu.%09lu \",\n\t\t\t  (unsigned long) ts->tv_sec, ts->tv_nsec);\n}\n\nstatic void print_header_interval_std(struct perf_stat_config *config,\n\t\t\t\t      struct target *_target __maybe_unused,\n\t\t\t\t      struct evlist *evlist,\n\t\t\t\t      int argc __maybe_unused,\n\t\t\t\t      const char **argv __maybe_unused)\n{\n\tFILE *output = config->output;\n\n\tswitch (config->aggr_mode) {\n\tcase AGGR_NODE:\n\tcase AGGR_SOCKET:\n\tcase AGGR_DIE:\n\tcase AGGR_CACHE:\n\tcase AGGR_CORE:\n\t\tfprintf(output, \"#%*s %-*s cpus\",\n\t\t\tINTERVAL_LEN - 1, \"time\",\n\t\t\taggr_header_lens[config->aggr_mode],\n\t\t\taggr_header_std[config->aggr_mode]);\n\t\tbreak;\n\tcase AGGR_NONE:\n\t\tfprintf(output, \"#%*s %-*s\",\n\t\t\tINTERVAL_LEN - 1, \"time\",\n\t\t\taggr_header_lens[config->aggr_mode],\n\t\t\taggr_header_std[config->aggr_mode]);\n\t\tbreak;\n\tcase AGGR_THREAD:\n\t\tfprintf(output, \"#%*s %*s-%-*s\",\n\t\t\tINTERVAL_LEN - 1, \"time\",\n\t\t\tCOMM_LEN, \"comm\", PID_LEN, \"pid\");\n\t\tbreak;\n\tcase AGGR_GLOBAL:\n\tdefault:\n\t\tif (!config->iostat_run)\n\t\t\tfprintf(output, \"#%*s\",\n\t\t\t\tINTERVAL_LEN - 1, \"time\");\n\tcase AGGR_UNSET:\n\tcase AGGR_MAX:\n\t\tbreak;\n\t}\n\n\tif (config->metric_only)\n\t\tprint_metric_headers(config, evlist, true);\n\telse\n\t\tfprintf(output, \" %*s %*s events\\n\",\n\t\t\tCOUNTS_LEN, \"counts\", config->unit_width, \"unit\");\n}\n\nstatic void print_header_std(struct perf_stat_config *config,\n\t\t\t     struct target *_target, struct evlist *evlist,\n\t\t\t     int argc, const char **argv)\n{\n\tFILE *output = config->output;\n\tint i;\n\n\tfprintf(output, \"\\n\");\n\tfprintf(output, \" Performance counter stats for \");\n\tif (_target->bpf_str)\n\t\tfprintf(output, \"\\'BPF program(s) %s\", _target->bpf_str);\n\telse if (_target->system_wide)\n\t\tfprintf(output, \"\\'system wide\");\n\telse if (_target->cpu_list)\n\t\tfprintf(output, \"\\'CPU(s) %s\", _target->cpu_list);\n\telse if (!target__has_task(_target)) {\n\t\tfprintf(output, \"\\'%s\", argv ? argv[0] : \"pipe\");\n\t\tfor (i = 1; argv && (i < argc); i++)\n\t\t\tfprintf(output, \" %s\", argv[i]);\n\t} else if (_target->pid)\n\t\tfprintf(output, \"process id \\'%s\", _target->pid);\n\telse\n\t\tfprintf(output, \"thread id \\'%s\", _target->tid);\n\n\tfprintf(output, \"\\'\");\n\tif (config->run_count > 1)\n\t\tfprintf(output, \" (%d runs)\", config->run_count);\n\tfprintf(output, \":\\n\\n\");\n\n\tif (config->metric_only)\n\t\tprint_metric_headers(config, evlist, false);\n}\n\nstatic void print_header_csv(struct perf_stat_config *config,\n\t\t\t     struct target *_target __maybe_unused,\n\t\t\t     struct evlist *evlist,\n\t\t\t     int argc __maybe_unused,\n\t\t\t     const char **argv __maybe_unused)\n{\n\tif (config->metric_only)\n\t\tprint_metric_headers(config, evlist, true);\n}\nstatic void print_header_json(struct perf_stat_config *config,\n\t\t\t      struct target *_target __maybe_unused,\n\t\t\t      struct evlist *evlist,\n\t\t\t      int argc __maybe_unused,\n\t\t\t      const char **argv __maybe_unused)\n{\n\tif (config->metric_only)\n\t\tprint_metric_headers(config, evlist, true);\n}\n\nstatic void print_header(struct perf_stat_config *config,\n\t\t\t struct target *_target,\n\t\t\t struct evlist *evlist,\n\t\t\t int argc, const char **argv)\n{\n\tstatic int num_print_iv;\n\n\tfflush(stdout);\n\n\tif (config->interval_clear)\n\t\tputs(CONSOLE_CLEAR);\n\n\tif (num_print_iv == 0 || config->interval_clear) {\n\t\tif (config->json_output)\n\t\t\tprint_header_json(config, _target, evlist, argc, argv);\n\t\telse if (config->csv_output)\n\t\t\tprint_header_csv(config, _target, evlist, argc, argv);\n\t\telse if (config->interval)\n\t\t\tprint_header_interval_std(config, _target, evlist, argc, argv);\n\t\telse\n\t\t\tprint_header_std(config, _target, evlist, argc, argv);\n\t}\n\n\tif (num_print_iv++ == 25)\n\t\tnum_print_iv = 0;\n}\n\nstatic int get_precision(double num)\n{\n\tif (num > 1)\n\t\treturn 0;\n\n\treturn lround(ceil(-log10(num)));\n}\n\nstatic void print_table(struct perf_stat_config *config,\n\t\t\tFILE *output, int precision, double avg)\n{\n\tchar tmp[64];\n\tint idx, indent = 0;\n\n\tscnprintf(tmp, 64, \" %17.*f\", precision, avg);\n\twhile (tmp[indent] == ' ')\n\t\tindent++;\n\n\tfprintf(output, \"%*s# Table of individual measurements:\\n\", indent, \"\");\n\n\tfor (idx = 0; idx < config->run_count; idx++) {\n\t\tdouble run = (double) config->walltime_run[idx] / NSEC_PER_SEC;\n\t\tint h, n = 1 + abs((int) (100.0 * (run - avg)/run) / 5);\n\n\t\tfprintf(output, \" %17.*f (%+.*f) \",\n\t\t\tprecision, run, precision, run - avg);\n\n\t\tfor (h = 0; h < n; h++)\n\t\t\tfprintf(output, \"#\");\n\n\t\tfprintf(output, \"\\n\");\n\t}\n\n\tfprintf(output, \"\\n%*s# Final result:\\n\", indent, \"\");\n}\n\nstatic double timeval2double(struct timeval *t)\n{\n\treturn t->tv_sec + (double) t->tv_usec/USEC_PER_SEC;\n}\n\nstatic void print_footer(struct perf_stat_config *config)\n{\n\tdouble avg = avg_stats(config->walltime_nsecs_stats) / NSEC_PER_SEC;\n\tFILE *output = config->output;\n\n\tif (config->interval || config->csv_output || config->json_output)\n\t\treturn;\n\n\tif (!config->null_run)\n\t\tfprintf(output, \"\\n\");\n\n\tif (config->run_count == 1) {\n\t\tfprintf(output, \" %17.9f seconds time elapsed\", avg);\n\n\t\tif (config->ru_display) {\n\t\t\tdouble ru_utime = timeval2double(&config->ru_data.ru_utime);\n\t\t\tdouble ru_stime = timeval2double(&config->ru_data.ru_stime);\n\n\t\t\tfprintf(output, \"\\n\\n\");\n\t\t\tfprintf(output, \" %17.9f seconds user\\n\", ru_utime);\n\t\t\tfprintf(output, \" %17.9f seconds sys\\n\", ru_stime);\n\t\t}\n\t} else {\n\t\tdouble sd = stddev_stats(config->walltime_nsecs_stats) / NSEC_PER_SEC;\n\t\t \n\t\tint precision = get_precision(sd) + 2;\n\n\t\tif (config->walltime_run_table)\n\t\t\tprint_table(config, output, precision, avg);\n\n\t\tfprintf(output, \" %17.*f +- %.*f seconds time elapsed\",\n\t\t\tprecision, avg, precision, sd);\n\n\t\tprint_noise_pct(config, sd, avg,  false);\n\t}\n\tfprintf(output, \"\\n\\n\");\n\n\tif (config->print_free_counters_hint && sysctl__nmi_watchdog_enabled())\n\t\tfprintf(output,\n\"Some events weren't counted. Try disabling the NMI watchdog:\\n\"\n\"\techo 0 > /proc/sys/kernel/nmi_watchdog\\n\"\n\"\tperf stat ...\\n\"\n\"\techo 1 > /proc/sys/kernel/nmi_watchdog\\n\");\n\n\tif (config->print_mixed_hw_group_error)\n\t\tfprintf(output,\n\t\t\t\"The events in group usually have to be from \"\n\t\t\t\"the same PMU. Try reorganizing the group.\\n\");\n}\n\nstatic void print_percore(struct perf_stat_config *config,\n\t\t\t  struct evsel *counter, struct outstate *os)\n{\n\tbool metric_only = config->metric_only;\n\tFILE *output = config->output;\n\tstruct cpu_aggr_map *core_map;\n\tint aggr_idx, core_map_len = 0;\n\n\tif (!config->aggr_map || !config->aggr_get_id)\n\t\treturn;\n\n\tif (config->percore_show_thread)\n\t\treturn print_counter(config, counter, os);\n\n\t \n\tcore_map = cpu_aggr_map__empty_new(config->aggr_map->nr);\n\tif (core_map == NULL) {\n\t\tfprintf(output, \"Cannot allocate per-core aggr map for display\\n\");\n\t\treturn;\n\t}\n\n\tcpu_aggr_map__for_each_idx(aggr_idx, config->aggr_map) {\n\t\tstruct perf_cpu curr_cpu = config->aggr_map->map[aggr_idx].cpu;\n\t\tstruct aggr_cpu_id core_id = aggr_cpu_id__core(curr_cpu, NULL);\n\t\tbool found = false;\n\n\t\tfor (int i = 0; i < core_map_len; i++) {\n\t\t\tif (aggr_cpu_id__equal(&core_map->map[i], &core_id)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\tprint_counter_aggrdata(config, counter, aggr_idx, os);\n\n\t\tcore_map->map[core_map_len++] = core_id;\n\t}\n\tfree(core_map);\n\n\tif (metric_only)\n\t\tfputc('\\n', output);\n}\n\nstatic void print_cgroup_counter(struct perf_stat_config *config, struct evlist *evlist,\n\t\t\t\t struct outstate *os)\n{\n\tstruct evsel *counter;\n\n\tevlist__for_each_entry(evlist, counter) {\n\t\tif (os->cgrp != counter->cgrp) {\n\t\t\tif (os->cgrp != NULL)\n\t\t\t\tprint_metric_end(config, os);\n\n\t\t\tos->cgrp = counter->cgrp;\n\t\t\tprint_metric_begin(config, evlist, os,  0);\n\t\t}\n\n\t\tprint_counter(config, counter, os);\n\t}\n\tif (os->cgrp)\n\t\tprint_metric_end(config, os);\n}\n\nvoid evlist__print_counters(struct evlist *evlist, struct perf_stat_config *config,\n\t\t\t    struct target *_target, struct timespec *ts,\n\t\t\t    int argc, const char **argv)\n{\n\tbool metric_only = config->metric_only;\n\tint interval = config->interval;\n\tstruct evsel *counter;\n\tchar buf[64];\n\tstruct outstate os = {\n\t\t.fh = config->output,\n\t\t.first = true,\n\t};\n\n\tif (config->iostat_run)\n\t\tevlist->selected = evlist__first(evlist);\n\n\tif (interval) {\n\t\tos.prefix = buf;\n\t\tprepare_interval(config, buf, sizeof(buf), ts);\n\t}\n\n\tprint_header(config, _target, evlist, argc, argv);\n\n\tswitch (config->aggr_mode) {\n\tcase AGGR_CORE:\n\tcase AGGR_CACHE:\n\tcase AGGR_DIE:\n\tcase AGGR_SOCKET:\n\tcase AGGR_NODE:\n\t\tif (config->cgroup_list)\n\t\t\tprint_aggr_cgroup(config, evlist, &os);\n\t\telse\n\t\t\tprint_aggr(config, evlist, &os);\n\t\tbreak;\n\tcase AGGR_THREAD:\n\tcase AGGR_GLOBAL:\n\t\tif (config->iostat_run) {\n\t\t\tiostat_print_counters(evlist, config, ts, buf,\n\t\t\t\t\t      (iostat_print_counter_t)print_counter, &os);\n\t\t} else if (config->cgroup_list) {\n\t\t\tprint_cgroup_counter(config, evlist, &os);\n\t\t} else {\n\t\t\tprint_metric_begin(config, evlist, &os,  0);\n\t\t\tevlist__for_each_entry(evlist, counter) {\n\t\t\t\tprint_counter(config, counter, &os);\n\t\t\t}\n\t\t\tprint_metric_end(config, &os);\n\t\t}\n\t\tbreak;\n\tcase AGGR_NONE:\n\t\tif (metric_only)\n\t\t\tprint_no_aggr_metric(config, evlist, &os);\n\t\telse {\n\t\t\tevlist__for_each_entry(evlist, counter) {\n\t\t\t\tif (counter->percore)\n\t\t\t\t\tprint_percore(config, counter, &os);\n\t\t\t\telse\n\t\t\t\t\tprint_counter(config, counter, &os);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase AGGR_MAX:\n\tcase AGGR_UNSET:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tprint_footer(config);\n\n\tfflush(config->output);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}