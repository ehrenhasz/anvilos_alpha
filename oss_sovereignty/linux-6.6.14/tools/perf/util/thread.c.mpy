{
  "module_name": "thread.c",
  "hash_id": "0dac7f4c95184a7de58fb9c6655930e9d00caff365761d768cc74d5187164202",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/thread.c",
  "human_readable_source": "\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <linux/kernel.h>\n#include <linux/zalloc.h>\n#include \"dso.h\"\n#include \"session.h\"\n#include \"thread.h\"\n#include \"thread-stack.h\"\n#include \"debug.h\"\n#include \"namespaces.h\"\n#include \"comm.h\"\n#include \"map.h\"\n#include \"symbol.h\"\n#include \"unwind.h\"\n#include \"callchain.h\"\n\n#include <api/fs/fs.h>\n\nint thread__init_maps(struct thread *thread, struct machine *machine)\n{\n\tpid_t pid = thread__pid(thread);\n\n\tif (pid == thread__tid(thread) || pid == -1) {\n\t\tthread__set_maps(thread, maps__new(machine));\n\t} else {\n\t\tstruct thread *leader = __machine__findnew_thread(machine, pid, pid);\n\n\t\tif (leader) {\n\t\t\tthread__set_maps(thread, maps__get(thread__maps(leader)));\n\t\t\tthread__put(leader);\n\t\t}\n\t}\n\n\treturn thread__maps(thread) ? 0 : -1;\n}\n\nstruct thread *thread__new(pid_t pid, pid_t tid)\n{\n\tchar *comm_str;\n\tstruct comm *comm;\n\tRC_STRUCT(thread) *_thread = zalloc(sizeof(*_thread));\n\tstruct thread *thread;\n\n\tif (ADD_RC_CHK(thread, _thread) != NULL) {\n\t\tthread__set_pid(thread, pid);\n\t\tthread__set_tid(thread, tid);\n\t\tthread__set_ppid(thread, -1);\n\t\tthread__set_cpu(thread, -1);\n\t\tthread__set_guest_cpu(thread, -1);\n\t\tthread__set_lbr_stitch_enable(thread, false);\n\t\tINIT_LIST_HEAD(thread__namespaces_list(thread));\n\t\tINIT_LIST_HEAD(thread__comm_list(thread));\n\t\tinit_rwsem(thread__namespaces_lock(thread));\n\t\tinit_rwsem(thread__comm_lock(thread));\n\n\t\tcomm_str = malloc(32);\n\t\tif (!comm_str)\n\t\t\tgoto err_thread;\n\n\t\tsnprintf(comm_str, 32, \":%d\", tid);\n\t\tcomm = comm__new(comm_str, 0, false);\n\t\tfree(comm_str);\n\t\tif (!comm)\n\t\t\tgoto err_thread;\n\n\t\tlist_add(&comm->list, thread__comm_list(thread));\n\t\trefcount_set(thread__refcnt(thread), 1);\n\t\t \n\t\tRC_CHK_ACCESS(thread)->nsinfo = nsinfo__new(pid);\n\t\tsrccode_state_init(thread__srccode_state(thread));\n\t}\n\n\treturn thread;\n\nerr_thread:\n\tfree(thread);\n\treturn NULL;\n}\n\nstatic void (*thread__priv_destructor)(void *priv);\n\nvoid thread__set_priv_destructor(void (*destructor)(void *priv))\n{\n\tassert(thread__priv_destructor == NULL);\n\n\tthread__priv_destructor = destructor;\n}\n\nvoid thread__delete(struct thread *thread)\n{\n\tstruct namespaces *namespaces, *tmp_namespaces;\n\tstruct comm *comm, *tmp_comm;\n\n\tthread_stack__free(thread);\n\n\tif (thread__maps(thread)) {\n\t\tmaps__put(thread__maps(thread));\n\t\tthread__set_maps(thread, NULL);\n\t}\n\tdown_write(thread__namespaces_lock(thread));\n\tlist_for_each_entry_safe(namespaces, tmp_namespaces,\n\t\t\t\t thread__namespaces_list(thread), list) {\n\t\tlist_del_init(&namespaces->list);\n\t\tnamespaces__free(namespaces);\n\t}\n\tup_write(thread__namespaces_lock(thread));\n\n\tdown_write(thread__comm_lock(thread));\n\tlist_for_each_entry_safe(comm, tmp_comm, thread__comm_list(thread), list) {\n\t\tlist_del_init(&comm->list);\n\t\tcomm__free(comm);\n\t}\n\tup_write(thread__comm_lock(thread));\n\n\tnsinfo__zput(RC_CHK_ACCESS(thread)->nsinfo);\n\tsrccode_state_free(thread__srccode_state(thread));\n\n\texit_rwsem(thread__namespaces_lock(thread));\n\texit_rwsem(thread__comm_lock(thread));\n\tthread__free_stitch_list(thread);\n\n\tif (thread__priv_destructor)\n\t\tthread__priv_destructor(thread__priv(thread));\n\n\tRC_CHK_FREE(thread);\n}\n\nstruct thread *thread__get(struct thread *thread)\n{\n\tstruct thread *result;\n\n\tif (RC_CHK_GET(result, thread))\n\t\trefcount_inc(thread__refcnt(thread));\n\n\treturn result;\n}\n\nvoid thread__put(struct thread *thread)\n{\n\tif (thread && refcount_dec_and_test(thread__refcnt(thread)))\n\t\tthread__delete(thread);\n\telse\n\t\tRC_CHK_PUT(thread);\n}\n\nstatic struct namespaces *__thread__namespaces(struct thread *thread)\n{\n\tif (list_empty(thread__namespaces_list(thread)))\n\t\treturn NULL;\n\n\treturn list_first_entry(thread__namespaces_list(thread), struct namespaces, list);\n}\n\nstruct namespaces *thread__namespaces(struct thread *thread)\n{\n\tstruct namespaces *ns;\n\n\tdown_read(thread__namespaces_lock(thread));\n\tns = __thread__namespaces(thread);\n\tup_read(thread__namespaces_lock(thread));\n\n\treturn ns;\n}\n\nstatic int __thread__set_namespaces(struct thread *thread, u64 timestamp,\n\t\t\t\t    struct perf_record_namespaces *event)\n{\n\tstruct namespaces *new, *curr = __thread__namespaces(thread);\n\n\tnew = namespaces__new(event);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tlist_add(&new->list, thread__namespaces_list(thread));\n\n\tif (timestamp && curr) {\n\t\t \n\t\tcurr = list_next_entry(new, list);\n\t\tcurr->end_time = timestamp;\n\t}\n\n\treturn 0;\n}\n\nint thread__set_namespaces(struct thread *thread, u64 timestamp,\n\t\t\t   struct perf_record_namespaces *event)\n{\n\tint ret;\n\n\tdown_write(thread__namespaces_lock(thread));\n\tret = __thread__set_namespaces(thread, timestamp, event);\n\tup_write(thread__namespaces_lock(thread));\n\treturn ret;\n}\n\nstruct comm *thread__comm(struct thread *thread)\n{\n\tif (list_empty(thread__comm_list(thread)))\n\t\treturn NULL;\n\n\treturn list_first_entry(thread__comm_list(thread), struct comm, list);\n}\n\nstruct comm *thread__exec_comm(struct thread *thread)\n{\n\tstruct comm *comm, *last = NULL, *second_last = NULL;\n\n\tlist_for_each_entry(comm, thread__comm_list(thread), list) {\n\t\tif (comm->exec)\n\t\t\treturn comm;\n\t\tsecond_last = last;\n\t\tlast = comm;\n\t}\n\n\t \n\tif (second_last && !last->start && thread__pid(thread) == thread__tid(thread))\n\t\treturn second_last;\n\n\treturn last;\n}\n\nstatic int ____thread__set_comm(struct thread *thread, const char *str,\n\t\t\t\tu64 timestamp, bool exec)\n{\n\tstruct comm *new, *curr = thread__comm(thread);\n\n\t \n\tif (!thread__comm_set(thread)) {\n\t\tint err = comm__override(curr, str, timestamp, exec);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tnew = comm__new(str, timestamp, exec);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&new->list, thread__comm_list(thread));\n\n\t\tif (exec)\n\t\t\tunwind__flush_access(thread__maps(thread));\n\t}\n\n\tthread__set_comm_set(thread, true);\n\n\treturn 0;\n}\n\nint __thread__set_comm(struct thread *thread, const char *str, u64 timestamp,\n\t\t       bool exec)\n{\n\tint ret;\n\n\tdown_write(thread__comm_lock(thread));\n\tret = ____thread__set_comm(thread, str, timestamp, exec);\n\tup_write(thread__comm_lock(thread));\n\treturn ret;\n}\n\nint thread__set_comm_from_proc(struct thread *thread)\n{\n\tchar path[64];\n\tchar *comm = NULL;\n\tsize_t sz;\n\tint err = -1;\n\n\tif (!(snprintf(path, sizeof(path), \"%d/task/%d/comm\",\n\t\t       thread__pid(thread), thread__tid(thread)) >= (int)sizeof(path)) &&\n\t    procfs__read_str(path, &comm, &sz) == 0) {\n\t\tcomm[sz - 1] = '\\0';\n\t\terr = thread__set_comm(thread, comm, 0);\n\t}\n\n\treturn err;\n}\n\nstatic const char *__thread__comm_str(struct thread *thread)\n{\n\tconst struct comm *comm = thread__comm(thread);\n\n\tif (!comm)\n\t\treturn NULL;\n\n\treturn comm__str(comm);\n}\n\nconst char *thread__comm_str(struct thread *thread)\n{\n\tconst char *str;\n\n\tdown_read(thread__comm_lock(thread));\n\tstr = __thread__comm_str(thread);\n\tup_read(thread__comm_lock(thread));\n\n\treturn str;\n}\n\nstatic int __thread__comm_len(struct thread *thread, const char *comm)\n{\n\tif (!comm)\n\t\treturn 0;\n\tthread__set_comm_len(thread, strlen(comm));\n\n\treturn thread__var_comm_len(thread);\n}\n\n \nint thread__comm_len(struct thread *thread)\n{\n\tint comm_len = thread__var_comm_len(thread);\n\n\tif (!comm_len) {\n\t\tconst char *comm;\n\n\t\tdown_read(thread__comm_lock(thread));\n\t\tcomm = __thread__comm_str(thread);\n\t\tcomm_len = __thread__comm_len(thread, comm);\n\t\tup_read(thread__comm_lock(thread));\n\t}\n\n\treturn comm_len;\n}\n\nsize_t thread__fprintf(struct thread *thread, FILE *fp)\n{\n\treturn fprintf(fp, \"Thread %d %s\\n\", thread__tid(thread), thread__comm_str(thread)) +\n\t       maps__fprintf(thread__maps(thread), fp);\n}\n\nint thread__insert_map(struct thread *thread, struct map *map)\n{\n\tint ret;\n\n\tret = unwind__prepare_access(thread__maps(thread), map, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tmaps__fixup_overlappings(thread__maps(thread), map, stderr);\n\treturn maps__insert(thread__maps(thread), map);\n}\n\nstatic int __thread__prepare_access(struct thread *thread)\n{\n\tbool initialized = false;\n\tint err = 0;\n\tstruct maps *maps = thread__maps(thread);\n\tstruct map_rb_node *rb_node;\n\n\tdown_read(maps__lock(maps));\n\n\tmaps__for_each_entry(maps, rb_node) {\n\t\terr = unwind__prepare_access(thread__maps(thread), rb_node->map, &initialized);\n\t\tif (err || initialized)\n\t\t\tbreak;\n\t}\n\n\tup_read(maps__lock(maps));\n\n\treturn err;\n}\n\nstatic int thread__prepare_access(struct thread *thread)\n{\n\tint err = 0;\n\n\tif (dwarf_callchain_users)\n\t\terr = __thread__prepare_access(thread);\n\n\treturn err;\n}\n\nstatic int thread__clone_maps(struct thread *thread, struct thread *parent, bool do_maps_clone)\n{\n\t \n\tif (thread__pid(thread) == thread__pid(parent))\n\t\treturn thread__prepare_access(thread);\n\n\tif (thread__maps(thread) == thread__maps(parent)) {\n\t\tpr_debug(\"broken map groups on thread %d/%d parent %d/%d\\n\",\n\t\t\t thread__pid(thread), thread__tid(thread),\n\t\t\t thread__pid(parent), thread__tid(parent));\n\t\treturn 0;\n\t}\n\t \n\treturn do_maps_clone ? maps__clone(thread, thread__maps(parent)) : 0;\n}\n\nint thread__fork(struct thread *thread, struct thread *parent, u64 timestamp, bool do_maps_clone)\n{\n\tif (thread__comm_set(parent)) {\n\t\tconst char *comm = thread__comm_str(parent);\n\t\tint err;\n\t\tif (!comm)\n\t\t\treturn -ENOMEM;\n\t\terr = thread__set_comm(thread, comm, timestamp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tthread__set_ppid(thread, thread__tid(parent));\n\treturn thread__clone_maps(thread, parent, do_maps_clone);\n}\n\nvoid thread__find_cpumode_addr_location(struct thread *thread, u64 addr,\n\t\t\t\t\tstruct addr_location *al)\n{\n\tsize_t i;\n\tconst u8 cpumodes[] = {\n\t\tPERF_RECORD_MISC_USER,\n\t\tPERF_RECORD_MISC_KERNEL,\n\t\tPERF_RECORD_MISC_GUEST_USER,\n\t\tPERF_RECORD_MISC_GUEST_KERNEL\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(cpumodes); i++) {\n\t\tthread__find_symbol(thread, cpumodes[i], addr, al);\n\t\tif (al->map)\n\t\t\tbreak;\n\t}\n}\n\nstruct thread *thread__main_thread(struct machine *machine, struct thread *thread)\n{\n\tif (thread__pid(thread) == thread__tid(thread))\n\t\treturn thread__get(thread);\n\n\tif (thread__pid(thread) == -1)\n\t\treturn NULL;\n\n\treturn machine__find_thread(machine, thread__pid(thread), thread__pid(thread));\n}\n\nint thread__memcpy(struct thread *thread, struct machine *machine,\n\t\t   void *buf, u64 ip, int len, bool *is64bit)\n{\n\tu8 cpumode = PERF_RECORD_MISC_USER;\n\tstruct addr_location al;\n\tstruct dso *dso;\n\tlong offset;\n\n\tif (machine__kernel_ip(machine, ip))\n\t\tcpumode = PERF_RECORD_MISC_KERNEL;\n\n\taddr_location__init(&al);\n\tif (!thread__find_map(thread, cpumode, ip, &al)) {\n\t\taddr_location__exit(&al);\n\t\treturn -1;\n\t}\n\n\tdso = map__dso(al.map);\n\n\tif (!dso || dso->data.status == DSO_DATA_STATUS_ERROR || map__load(al.map) < 0) {\n\t\taddr_location__exit(&al);\n\t\treturn -1;\n\t}\n\n\toffset = map__map_ip(al.map, ip);\n\tif (is64bit)\n\t\t*is64bit = dso->is_64_bit;\n\n\taddr_location__exit(&al);\n\n\treturn dso__data_read_offset(dso, machine, offset, buf, len);\n}\n\nvoid thread__free_stitch_list(struct thread *thread)\n{\n\tstruct lbr_stitch *lbr_stitch = thread__lbr_stitch(thread);\n\tstruct stitch_list *pos, *tmp;\n\n\tif (!lbr_stitch)\n\t\treturn;\n\n\tlist_for_each_entry_safe(pos, tmp, &lbr_stitch->lists, node) {\n\t\tlist_del_init(&pos->node);\n\t\tfree(pos);\n\t}\n\n\tlist_for_each_entry_safe(pos, tmp, &lbr_stitch->free_lists, node) {\n\t\tlist_del_init(&pos->node);\n\t\tfree(pos);\n\t}\n\n\tzfree(&lbr_stitch->prev_lbr_cursor);\n\tfree(thread__lbr_stitch(thread));\n\tthread__set_lbr_stitch(thread, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}