{
  "module_name": "trace-event-perl.c",
  "hash_id": "c4dedd7a64fb634f3fee42f2e2d3996e2ba89f01e47650607d53ca67305d2132",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/scripting-engines/trace-event-perl.c",
  "human_readable_source": " \n\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <linux/bitmap.h>\n#include <linux/time64.h>\n#include <traceevent/event-parse.h>\n\n#include <stdbool.h>\n \n#define HAS_BOOL\n#include <EXTERN.h>\n#include <perl.h>\n\n#include \"../callchain.h\"\n#include \"../dso.h\"\n#include \"../machine.h\"\n#include \"../map.h\"\n#include \"../symbol.h\"\n#include \"../thread.h\"\n#include \"../event.h\"\n#include \"../trace-event.h\"\n#include \"../evsel.h\"\n#include \"../debug.h\"\n\nvoid boot_Perf__Trace__Context(pTHX_ CV *cv);\nvoid boot_DynaLoader(pTHX_ CV *cv);\ntypedef PerlInterpreter * INTERP;\n\nvoid xs_init(pTHX);\n\nvoid xs_init(pTHX)\n{\n\tconst char *file = __FILE__;\n\tdXSUB_SYS;\n\n\tnewXS(\"Perf::Trace::Context::bootstrap\", boot_Perf__Trace__Context,\n\t      file);\n\tnewXS(\"DynaLoader::boot_DynaLoader\", boot_DynaLoader, file);\n}\n\nINTERP my_perl;\n\n#define TRACE_EVENT_TYPE_MAX\t\t\t\t\\\n\t((1 << (sizeof(unsigned short) * 8)) - 1)\n\nextern struct scripting_context *scripting_context;\n\nstatic char *cur_field_name;\nstatic int zero_flag_atom;\n\nstatic void define_symbolic_value(const char *ev_name,\n\t\t\t\t  const char *field_name,\n\t\t\t\t  const char *field_value,\n\t\t\t\t  const char *field_str)\n{\n\tunsigned long long value;\n\tdSP;\n\n\tvalue = eval_flag(field_value);\n\n\tENTER;\n\tSAVETMPS;\n\tPUSHMARK(SP);\n\n\tXPUSHs(sv_2mortal(newSVpv(ev_name, 0)));\n\tXPUSHs(sv_2mortal(newSVpv(field_name, 0)));\n\tXPUSHs(sv_2mortal(newSVuv(value)));\n\tXPUSHs(sv_2mortal(newSVpv(field_str, 0)));\n\n\tPUTBACK;\n\tif (get_cv(\"main::define_symbolic_value\", 0))\n\t\tcall_pv(\"main::define_symbolic_value\", G_SCALAR);\n\tSPAGAIN;\n\tPUTBACK;\n\tFREETMPS;\n\tLEAVE;\n}\n\nstatic void define_symbolic_values(struct tep_print_flag_sym *field,\n\t\t\t\t   const char *ev_name,\n\t\t\t\t   const char *field_name)\n{\n\tdefine_symbolic_value(ev_name, field_name, field->value, field->str);\n\tif (field->next)\n\t\tdefine_symbolic_values(field->next, ev_name, field_name);\n}\n\nstatic void define_symbolic_field(const char *ev_name,\n\t\t\t\t  const char *field_name)\n{\n\tdSP;\n\n\tENTER;\n\tSAVETMPS;\n\tPUSHMARK(SP);\n\n\tXPUSHs(sv_2mortal(newSVpv(ev_name, 0)));\n\tXPUSHs(sv_2mortal(newSVpv(field_name, 0)));\n\n\tPUTBACK;\n\tif (get_cv(\"main::define_symbolic_field\", 0))\n\t\tcall_pv(\"main::define_symbolic_field\", G_SCALAR);\n\tSPAGAIN;\n\tPUTBACK;\n\tFREETMPS;\n\tLEAVE;\n}\n\nstatic void define_flag_value(const char *ev_name,\n\t\t\t      const char *field_name,\n\t\t\t      const char *field_value,\n\t\t\t      const char *field_str)\n{\n\tunsigned long long value;\n\tdSP;\n\n\tvalue = eval_flag(field_value);\n\n\tENTER;\n\tSAVETMPS;\n\tPUSHMARK(SP);\n\n\tXPUSHs(sv_2mortal(newSVpv(ev_name, 0)));\n\tXPUSHs(sv_2mortal(newSVpv(field_name, 0)));\n\tXPUSHs(sv_2mortal(newSVuv(value)));\n\tXPUSHs(sv_2mortal(newSVpv(field_str, 0)));\n\n\tPUTBACK;\n\tif (get_cv(\"main::define_flag_value\", 0))\n\t\tcall_pv(\"main::define_flag_value\", G_SCALAR);\n\tSPAGAIN;\n\tPUTBACK;\n\tFREETMPS;\n\tLEAVE;\n}\n\nstatic void define_flag_values(struct tep_print_flag_sym *field,\n\t\t\t       const char *ev_name,\n\t\t\t       const char *field_name)\n{\n\tdefine_flag_value(ev_name, field_name, field->value, field->str);\n\tif (field->next)\n\t\tdefine_flag_values(field->next, ev_name, field_name);\n}\n\nstatic void define_flag_field(const char *ev_name,\n\t\t\t      const char *field_name,\n\t\t\t      const char *delim)\n{\n\tdSP;\n\n\tENTER;\n\tSAVETMPS;\n\tPUSHMARK(SP);\n\n\tXPUSHs(sv_2mortal(newSVpv(ev_name, 0)));\n\tXPUSHs(sv_2mortal(newSVpv(field_name, 0)));\n\tXPUSHs(sv_2mortal(newSVpv(delim, 0)));\n\n\tPUTBACK;\n\tif (get_cv(\"main::define_flag_field\", 0))\n\t\tcall_pv(\"main::define_flag_field\", G_SCALAR);\n\tSPAGAIN;\n\tPUTBACK;\n\tFREETMPS;\n\tLEAVE;\n}\n\nstatic void define_event_symbols(struct tep_event *event,\n\t\t\t\t const char *ev_name,\n\t\t\t\t struct tep_print_arg *args)\n{\n\tif (args == NULL)\n\t\treturn;\n\n\tswitch (args->type) {\n\tcase TEP_PRINT_NULL:\n\t\tbreak;\n\tcase TEP_PRINT_ATOM:\n\t\tdefine_flag_value(ev_name, cur_field_name, \"0\",\n\t\t\t\t  args->atom.atom);\n\t\tzero_flag_atom = 0;\n\t\tbreak;\n\tcase TEP_PRINT_FIELD:\n\t\tfree(cur_field_name);\n\t\tcur_field_name = strdup(args->field.name);\n\t\tbreak;\n\tcase TEP_PRINT_FLAGS:\n\t\tdefine_event_symbols(event, ev_name, args->flags.field);\n\t\tdefine_flag_field(ev_name, cur_field_name, args->flags.delim);\n\t\tdefine_flag_values(args->flags.flags, ev_name, cur_field_name);\n\t\tbreak;\n\tcase TEP_PRINT_SYMBOL:\n\t\tdefine_event_symbols(event, ev_name, args->symbol.field);\n\t\tdefine_symbolic_field(ev_name, cur_field_name);\n\t\tdefine_symbolic_values(args->symbol.symbols, ev_name,\n\t\t\t\t       cur_field_name);\n\t\tbreak;\n\tcase TEP_PRINT_HEX:\n\tcase TEP_PRINT_HEX_STR:\n\t\tdefine_event_symbols(event, ev_name, args->hex.field);\n\t\tdefine_event_symbols(event, ev_name, args->hex.size);\n\t\tbreak;\n\tcase TEP_PRINT_INT_ARRAY:\n\t\tdefine_event_symbols(event, ev_name, args->int_array.field);\n\t\tdefine_event_symbols(event, ev_name, args->int_array.count);\n\t\tdefine_event_symbols(event, ev_name, args->int_array.el_size);\n\t\tbreak;\n\tcase TEP_PRINT_BSTRING:\n\tcase TEP_PRINT_DYNAMIC_ARRAY:\n\tcase TEP_PRINT_DYNAMIC_ARRAY_LEN:\n\tcase TEP_PRINT_STRING:\n\tcase TEP_PRINT_BITMASK:\n\t\tbreak;\n\tcase TEP_PRINT_TYPE:\n\t\tdefine_event_symbols(event, ev_name, args->typecast.item);\n\t\tbreak;\n\tcase TEP_PRINT_OP:\n\t\tif (strcmp(args->op.op, \":\") == 0)\n\t\t\tzero_flag_atom = 1;\n\t\tdefine_event_symbols(event, ev_name, args->op.left);\n\t\tdefine_event_symbols(event, ev_name, args->op.right);\n\t\tbreak;\n\tcase TEP_PRINT_FUNC:\n\tdefault:\n\t\tpr_err(\"Unsupported print arg type\\n\");\n\t\t \n\t\treturn;\n\t}\n\n\tif (args->next)\n\t\tdefine_event_symbols(event, ev_name, args->next);\n}\n\nstatic SV *perl_process_callchain(struct perf_sample *sample,\n\t\t\t\t  struct evsel *evsel,\n\t\t\t\t  struct addr_location *al)\n{\n\tstruct callchain_cursor *cursor;\n\tAV *list;\n\n\tlist = newAV();\n\tif (!list)\n\t\tgoto exit;\n\n\tif (!symbol_conf.use_callchain || !sample->callchain)\n\t\tgoto exit;\n\n\tcursor = get_tls_callchain_cursor();\n\n\tif (thread__resolve_callchain(al->thread, cursor, evsel,\n\t\t\t\t      sample, NULL, NULL, scripting_max_stack) != 0) {\n\t\tpr_err(\"Failed to resolve callchain. Skipping\\n\");\n\t\tgoto exit;\n\t}\n\tcallchain_cursor_commit(cursor);\n\n\n\twhile (1) {\n\t\tHV *elem;\n\t\tstruct callchain_cursor_node *node;\n\t\tnode = callchain_cursor_current(cursor);\n\t\tif (!node)\n\t\t\tbreak;\n\n\t\telem = newHV();\n\t\tif (!elem)\n\t\t\tgoto exit;\n\n\t\tif (!hv_stores(elem, \"ip\", newSVuv(node->ip))) {\n\t\t\thv_undef(elem);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (node->ms.sym) {\n\t\t\tHV *sym = newHV();\n\t\t\tif (!sym) {\n\t\t\t\thv_undef(elem);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (!hv_stores(sym, \"start\",   newSVuv(node->ms.sym->start)) ||\n\t\t\t    !hv_stores(sym, \"end\",     newSVuv(node->ms.sym->end)) ||\n\t\t\t    !hv_stores(sym, \"binding\", newSVuv(node->ms.sym->binding)) ||\n\t\t\t    !hv_stores(sym, \"name\",    newSVpvn(node->ms.sym->name,\n\t\t\t\t\t\t\t\tnode->ms.sym->namelen)) ||\n\t\t\t    !hv_stores(elem, \"sym\",    newRV_noinc((SV*)sym))) {\n\t\t\t\thv_undef(sym);\n\t\t\t\thv_undef(elem);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif (node->ms.map) {\n\t\t\tstruct map *map = node->ms.map;\n\t\t\tstruct dso *dso = map ? map__dso(map) : NULL;\n\t\t\tconst char *dsoname = \"[unknown]\";\n\n\t\t\tif (dso) {\n\t\t\t\tif (symbol_conf.show_kernel_path && dso->long_name)\n\t\t\t\t\tdsoname = dso->long_name;\n\t\t\t\telse\n\t\t\t\t\tdsoname = dso->name;\n\t\t\t}\n\t\t\tif (!hv_stores(elem, \"dso\", newSVpv(dsoname,0))) {\n\t\t\t\thv_undef(elem);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tcallchain_cursor_advance(cursor);\n\t\tav_push(list, newRV_noinc((SV*)elem));\n\t}\n\nexit:\n\treturn newRV_noinc((SV*)list);\n}\n\nstatic void perl_process_tracepoint(struct perf_sample *sample,\n\t\t\t\t    struct evsel *evsel,\n\t\t\t\t    struct addr_location *al)\n{\n\tstruct thread *thread = al->thread;\n\tstruct tep_event *event = evsel->tp_format;\n\tstruct tep_format_field *field;\n\tstatic char handler[256];\n\tunsigned long long val;\n\tunsigned long s, ns;\n\tint pid;\n\tint cpu = sample->cpu;\n\tvoid *data = sample->raw_data;\n\tunsigned long long nsecs = sample->time;\n\tconst char *comm = thread__comm_str(thread);\n\tDECLARE_BITMAP(events_defined, TRACE_EVENT_TYPE_MAX);\n\n\tbitmap_zero(events_defined, TRACE_EVENT_TYPE_MAX);\n\tdSP;\n\n\tif (evsel->core.attr.type != PERF_TYPE_TRACEPOINT)\n\t\treturn;\n\n\tif (!event) {\n\t\tpr_debug(\"ug! no event found for type %\" PRIu64, (u64)evsel->core.attr.config);\n\t\treturn;\n\t}\n\n\tpid = raw_field_value(event, \"common_pid\", data);\n\n\tsprintf(handler, \"%s::%s\", event->system, event->name);\n\n\tif (!__test_and_set_bit(event->id, events_defined))\n\t\tdefine_event_symbols(event, handler, event->print_fmt.args);\n\n\ts = nsecs / NSEC_PER_SEC;\n\tns = nsecs - s * NSEC_PER_SEC;\n\n\tENTER;\n\tSAVETMPS;\n\tPUSHMARK(SP);\n\n\tXPUSHs(sv_2mortal(newSVpv(handler, 0)));\n\tXPUSHs(sv_2mortal(newSViv(PTR2IV(scripting_context))));\n\tXPUSHs(sv_2mortal(newSVuv(cpu)));\n\tXPUSHs(sv_2mortal(newSVuv(s)));\n\tXPUSHs(sv_2mortal(newSVuv(ns)));\n\tXPUSHs(sv_2mortal(newSViv(pid)));\n\tXPUSHs(sv_2mortal(newSVpv(comm, 0)));\n\tXPUSHs(sv_2mortal(perl_process_callchain(sample, evsel, al)));\n\n\t \n\n\tfor (field = event->format.fields; field; field = field->next) {\n\t\tif (field->flags & TEP_FIELD_IS_STRING) {\n\t\t\tint offset;\n\t\t\tif (field->flags & TEP_FIELD_IS_DYNAMIC) {\n\t\t\t\toffset = *(int *)(data + field->offset);\n\t\t\t\toffset &= 0xffff;\n\t\t\t\tif (tep_field_is_relative(field->flags))\n\t\t\t\t\toffset += field->offset + field->size;\n\t\t\t} else\n\t\t\t\toffset = field->offset;\n\t\t\tXPUSHs(sv_2mortal(newSVpv((char *)data + offset, 0)));\n\t\t} else {  \n\t\t\tval = read_size(event, data + field->offset,\n\t\t\t\t\tfield->size);\n\t\t\tif (field->flags & TEP_FIELD_IS_SIGNED) {\n\t\t\t\tXPUSHs(sv_2mortal(newSViv(val)));\n\t\t\t} else {\n\t\t\t\tXPUSHs(sv_2mortal(newSVuv(val)));\n\t\t\t}\n\t\t}\n\t}\n\n\tPUTBACK;\n\n\tif (get_cv(handler, 0))\n\t\tcall_pv(handler, G_SCALAR);\n\telse if (get_cv(\"main::trace_unhandled\", 0)) {\n\t\tXPUSHs(sv_2mortal(newSVpv(handler, 0)));\n\t\tXPUSHs(sv_2mortal(newSViv(PTR2IV(scripting_context))));\n\t\tXPUSHs(sv_2mortal(newSVuv(cpu)));\n\t\tXPUSHs(sv_2mortal(newSVuv(nsecs)));\n\t\tXPUSHs(sv_2mortal(newSViv(pid)));\n\t\tXPUSHs(sv_2mortal(newSVpv(comm, 0)));\n\t\tXPUSHs(sv_2mortal(perl_process_callchain(sample, evsel, al)));\n\t\tcall_pv(\"main::trace_unhandled\", G_SCALAR);\n\t}\n\tSPAGAIN;\n\tPUTBACK;\n\tFREETMPS;\n\tLEAVE;\n}\n\nstatic void perl_process_event_generic(union perf_event *event,\n\t\t\t\t       struct perf_sample *sample,\n\t\t\t\t       struct evsel *evsel)\n{\n\tdSP;\n\n\tif (!get_cv(\"process_event\", 0))\n\t\treturn;\n\n\tENTER;\n\tSAVETMPS;\n\tPUSHMARK(SP);\n\tXPUSHs(sv_2mortal(newSVpvn((const char *)event, event->header.size)));\n\tXPUSHs(sv_2mortal(newSVpvn((const char *)&evsel->core.attr, sizeof(evsel->core.attr))));\n\tXPUSHs(sv_2mortal(newSVpvn((const char *)sample, sizeof(*sample))));\n\tXPUSHs(sv_2mortal(newSVpvn((const char *)sample->raw_data, sample->raw_size)));\n\tPUTBACK;\n\tcall_pv(\"process_event\", G_SCALAR);\n\tSPAGAIN;\n\tPUTBACK;\n\tFREETMPS;\n\tLEAVE;\n}\n\nstatic void perl_process_event(union perf_event *event,\n\t\t\t       struct perf_sample *sample,\n\t\t\t       struct evsel *evsel,\n\t\t\t       struct addr_location *al,\n\t\t\t       struct addr_location *addr_al)\n{\n\tscripting_context__update(scripting_context, event, sample, evsel, al, addr_al);\n\tperl_process_tracepoint(sample, evsel, al);\n\tperl_process_event_generic(event, sample, evsel);\n}\n\nstatic void run_start_sub(void)\n{\n\tdSP;  \n\tPUSHMARK(SP);\n\n\tif (get_cv(\"main::trace_begin\", 0))\n\t\tcall_pv(\"main::trace_begin\", G_DISCARD | G_NOARGS);\n}\n\n \nstatic int perl_start_script(const char *script, int argc, const char **argv,\n\t\t\t     struct perf_session *session)\n{\n\tconst char **command_line;\n\tint i, err = 0;\n\n\tscripting_context->session = session;\n\n\tcommand_line = malloc((argc + 2) * sizeof(const char *));\n\tcommand_line[0] = \"\";\n\tcommand_line[1] = script;\n\tfor (i = 2; i < argc + 2; i++)\n\t\tcommand_line[i] = argv[i - 2];\n\n\tmy_perl = perl_alloc();\n\tperl_construct(my_perl);\n\n\tif (perl_parse(my_perl, xs_init, argc + 2, (char **)command_line,\n\t\t       (char **)NULL)) {\n\t\terr = -1;\n\t\tgoto error;\n\t}\n\n\tif (perl_run(my_perl)) {\n\t\terr = -1;\n\t\tgoto error;\n\t}\n\n\tif (SvTRUE(ERRSV)) {\n\t\terr = -1;\n\t\tgoto error;\n\t}\n\n\trun_start_sub();\n\n\tfree(command_line);\n\treturn 0;\nerror:\n\tperl_free(my_perl);\n\tfree(command_line);\n\n\treturn err;\n}\n\nstatic int perl_flush_script(void)\n{\n\treturn 0;\n}\n\n \nstatic int perl_stop_script(void)\n{\n\tdSP;  \n\tPUSHMARK(SP);\n\n\tif (get_cv(\"main::trace_end\", 0))\n\t\tcall_pv(\"main::trace_end\", G_DISCARD | G_NOARGS);\n\n\tperl_destruct(my_perl);\n\tperl_free(my_perl);\n\n\treturn 0;\n}\n\nstatic int perl_generate_script(struct tep_handle *pevent, const char *outfile)\n{\n\tint i, not_first, count, nr_events;\n\tstruct tep_event **all_events;\n\tstruct tep_event *event = NULL;\n\tstruct tep_format_field *f;\n\tchar fname[PATH_MAX];\n\tFILE *ofp;\n\n\tsprintf(fname, \"%s.pl\", outfile);\n\tofp = fopen(fname, \"w\");\n\tif (ofp == NULL) {\n\t\tfprintf(stderr, \"couldn't open %s\\n\", fname);\n\t\treturn -1;\n\t}\n\n\tfprintf(ofp, \"# perf script event handlers, \"\n\t\t\"generated by perf script -g perl\\n\");\n\n\tfprintf(ofp, \"# Licensed under the terms of the GNU GPL\"\n\t\t\" License version 2\\n\\n\");\n\n\tfprintf(ofp, \"# The common_* event handler fields are the most useful \"\n\t\t\"fields common to\\n\");\n\n\tfprintf(ofp, \"# all events.  They don't necessarily correspond to \"\n\t\t\"the 'common_*' fields\\n\");\n\n\tfprintf(ofp, \"# in the format files.  Those fields not available as \"\n\t\t\"handler params can\\n\");\n\n\tfprintf(ofp, \"# be retrieved using Perl functions of the form \"\n\t\t\"common_*($context).\\n\");\n\n\tfprintf(ofp, \"# See Context.pm for the list of available \"\n\t\t\"functions.\\n\\n\");\n\n\tfprintf(ofp, \"use lib \\\"$ENV{'PERF_EXEC_PATH'}/scripts/perl/\"\n\t\t\"Perf-Trace-Util/lib\\\";\\n\");\n\n\tfprintf(ofp, \"use lib \\\"./Perf-Trace-Util/lib\\\";\\n\");\n\tfprintf(ofp, \"use Perf::Trace::Core;\\n\");\n\tfprintf(ofp, \"use Perf::Trace::Context;\\n\");\n\tfprintf(ofp, \"use Perf::Trace::Util;\\n\\n\");\n\n\tfprintf(ofp, \"sub trace_begin\\n{\\n\\t# optional\\n}\\n\\n\");\n\tfprintf(ofp, \"sub trace_end\\n{\\n\\t# optional\\n}\\n\");\n\n\n\tfprintf(ofp, \"\\n\\\nsub print_backtrace\\n\\\n{\\n\\\n\tmy $callchain = shift;\\n\\\n\tfor my $node (@$callchain)\\n\\\n\t{\\n\\\n\t\tif(exists $node->{sym})\\n\\\n\t\t{\\n\\\n\t\t\tprintf( \\\"\\\\t[\\\\%%x] \\\\%%s\\\\n\\\", $node->{ip}, $node->{sym}{name});\\n\\\n\t\t}\\n\\\n\t\telse\\n\\\n\t\t{\\n\\\n\t\t\tprintf( \\\"\\\\t[\\\\%%x]\\\\n\\\", $node{ip});\\n\\\n\t\t}\\n\\\n\t}\\n\\\n}\\n\\n\\\n\");\n\n\tnr_events = tep_get_events_count(pevent);\n\tall_events = tep_list_events(pevent, TEP_EVENT_SORT_ID);\n\n\tfor (i = 0; all_events && i < nr_events; i++) {\n\t\tevent = all_events[i];\n\t\tfprintf(ofp, \"sub %s::%s\\n{\\n\", event->system, event->name);\n\t\tfprintf(ofp, \"\\tmy (\");\n\n\t\tfprintf(ofp, \"$event_name, \");\n\t\tfprintf(ofp, \"$context, \");\n\t\tfprintf(ofp, \"$common_cpu, \");\n\t\tfprintf(ofp, \"$common_secs, \");\n\t\tfprintf(ofp, \"$common_nsecs,\\n\");\n\t\tfprintf(ofp, \"\\t    $common_pid, \");\n\t\tfprintf(ofp, \"$common_comm, \");\n\t\tfprintf(ofp, \"$common_callchain,\\n\\t    \");\n\n\t\tnot_first = 0;\n\t\tcount = 0;\n\n\t\tfor (f = event->format.fields; f; f = f->next) {\n\t\t\tif (not_first++)\n\t\t\t\tfprintf(ofp, \", \");\n\t\t\tif (++count % 5 == 0)\n\t\t\t\tfprintf(ofp, \"\\n\\t    \");\n\n\t\t\tfprintf(ofp, \"$%s\", f->name);\n\t\t}\n\t\tfprintf(ofp, \") = @_;\\n\\n\");\n\n\t\tfprintf(ofp, \"\\tprint_header($event_name, $common_cpu, \"\n\t\t\t\"$common_secs, $common_nsecs,\\n\\t             \"\n\t\t\t\"$common_pid, $common_comm, $common_callchain);\\n\\n\");\n\n\t\tfprintf(ofp, \"\\tprintf(\\\"\");\n\n\t\tnot_first = 0;\n\t\tcount = 0;\n\n\t\tfor (f = event->format.fields; f; f = f->next) {\n\t\t\tif (not_first++)\n\t\t\t\tfprintf(ofp, \", \");\n\t\t\tif (count && count % 4 == 0) {\n\t\t\t\tfprintf(ofp, \"\\\".\\n\\t       \\\"\");\n\t\t\t}\n\t\t\tcount++;\n\n\t\t\tfprintf(ofp, \"%s=\", f->name);\n\t\t\tif (f->flags & TEP_FIELD_IS_STRING ||\n\t\t\t    f->flags & TEP_FIELD_IS_FLAG ||\n\t\t\t    f->flags & TEP_FIELD_IS_SYMBOLIC)\n\t\t\t\tfprintf(ofp, \"%%s\");\n\t\t\telse if (f->flags & TEP_FIELD_IS_SIGNED)\n\t\t\t\tfprintf(ofp, \"%%d\");\n\t\t\telse\n\t\t\t\tfprintf(ofp, \"%%u\");\n\t\t}\n\n\t\tfprintf(ofp, \"\\\\n\\\",\\n\\t       \");\n\n\t\tnot_first = 0;\n\t\tcount = 0;\n\n\t\tfor (f = event->format.fields; f; f = f->next) {\n\t\t\tif (not_first++)\n\t\t\t\tfprintf(ofp, \", \");\n\n\t\t\tif (++count % 5 == 0)\n\t\t\t\tfprintf(ofp, \"\\n\\t       \");\n\n\t\t\tif (f->flags & TEP_FIELD_IS_FLAG) {\n\t\t\t\tif ((count - 1) % 5 != 0) {\n\t\t\t\t\tfprintf(ofp, \"\\n\\t       \");\n\t\t\t\t\tcount = 4;\n\t\t\t\t}\n\t\t\t\tfprintf(ofp, \"flag_str(\\\"\");\n\t\t\t\tfprintf(ofp, \"%s::%s\\\", \", event->system,\n\t\t\t\t\tevent->name);\n\t\t\t\tfprintf(ofp, \"\\\"%s\\\", $%s)\", f->name,\n\t\t\t\t\tf->name);\n\t\t\t} else if (f->flags & TEP_FIELD_IS_SYMBOLIC) {\n\t\t\t\tif ((count - 1) % 5 != 0) {\n\t\t\t\t\tfprintf(ofp, \"\\n\\t       \");\n\t\t\t\t\tcount = 4;\n\t\t\t\t}\n\t\t\t\tfprintf(ofp, \"symbol_str(\\\"\");\n\t\t\t\tfprintf(ofp, \"%s::%s\\\", \", event->system,\n\t\t\t\t\tevent->name);\n\t\t\t\tfprintf(ofp, \"\\\"%s\\\", $%s)\", f->name,\n\t\t\t\t\tf->name);\n\t\t\t} else\n\t\t\t\tfprintf(ofp, \"$%s\", f->name);\n\t\t}\n\n\t\tfprintf(ofp, \");\\n\\n\");\n\n\t\tfprintf(ofp, \"\\tprint_backtrace($common_callchain);\\n\");\n\n\t\tfprintf(ofp, \"}\\n\\n\");\n\t}\n\n\tfprintf(ofp, \"sub trace_unhandled\\n{\\n\\tmy ($event_name, $context, \"\n\t\t\"$common_cpu, $common_secs, $common_nsecs,\\n\\t    \"\n\t\t\"$common_pid, $common_comm, $common_callchain) = @_;\\n\\n\");\n\n\tfprintf(ofp, \"\\tprint_header($event_name, $common_cpu, \"\n\t\t\"$common_secs, $common_nsecs,\\n\\t             $common_pid, \"\n\t\t\"$common_comm, $common_callchain);\\n\");\n\tfprintf(ofp, \"\\tprint_backtrace($common_callchain);\\n\");\n\tfprintf(ofp, \"}\\n\\n\");\n\n\tfprintf(ofp, \"sub print_header\\n{\\n\"\n\t\t\"\\tmy ($event_name, $cpu, $secs, $nsecs, $pid, $comm) = @_;\\n\\n\"\n\t\t\"\\tprintf(\\\"%%-20s %%5u %%05u.%%09u %%8u %%-20s \\\",\\n\\t       \"\n\t\t\"$event_name, $cpu, $secs, $nsecs, $pid, $comm);\\n}\\n\");\n\n\tfprintf(ofp,\n\t\t\"\\n# Packed byte string args of process_event():\\n\"\n\t\t\"#\\n\"\n\t\t\"# $event:\\tunion perf_event\\tutil/event.h\\n\"\n\t\t\"# $attr:\\tstruct perf_event_attr\\tlinux/perf_event.h\\n\"\n\t\t\"# $sample:\\tstruct perf_sample\\tutil/event.h\\n\"\n\t\t\"# $raw_data:\\tperf_sample->raw_data\\tutil/event.h\\n\"\n\t\t\"\\n\"\n\t\t\"sub process_event\\n\"\n\t\t\"{\\n\"\n\t\t\"\\tmy ($event, $attr, $sample, $raw_data) = @_;\\n\"\n\t\t\"\\n\"\n\t\t\"\\tmy @event\\t= unpack(\\\"LSS\\\", $event);\\n\"\n\t\t\"\\tmy @attr\\t= unpack(\\\"LLQQQQQLLQQ\\\", $attr);\\n\"\n\t\t\"\\tmy @sample\\t= unpack(\\\"QLLQQQQQLL\\\", $sample);\\n\"\n\t\t\"\\tmy @raw_data\\t= unpack(\\\"C*\\\", $raw_data);\\n\"\n\t\t\"\\n\"\n\t\t\"\\tuse Data::Dumper;\\n\"\n\t\t\"\\tprint Dumper \\\\@event, \\\\@attr, \\\\@sample, \\\\@raw_data;\\n\"\n\t\t\"}\\n\");\n\n\tfclose(ofp);\n\n\tfprintf(stderr, \"generated Perl script: %s\\n\", fname);\n\n\treturn 0;\n}\n\nstruct scripting_ops perl_scripting_ops = {\n\t.name = \"Perl\",\n\t.dirname = \"perl\",\n\t.start_script = perl_start_script,\n\t.flush_script = perl_flush_script,\n\t.stop_script = perl_stop_script,\n\t.process_event = perl_process_event,\n\t.generate_script = perl_generate_script,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}