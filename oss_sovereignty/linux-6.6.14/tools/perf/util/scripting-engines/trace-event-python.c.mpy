{
  "module_name": "trace-event-python.c",
  "hash_id": "5009d1dee1a02996d37a3775647d44185d0c5c0522de11e1f4b9e599a989b3a8",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/scripting-engines/trace-event-python.c",
  "human_readable_source": " \n\n#include <Python.h>\n\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <errno.h>\n#include <linux/bitmap.h>\n#include <linux/compiler.h>\n#include <linux/time64.h>\n#ifdef HAVE_LIBTRACEEVENT\n#include <traceevent/event-parse.h>\n#endif\n\n#include \"../build-id.h\"\n#include \"../counts.h\"\n#include \"../debug.h\"\n#include \"../dso.h\"\n#include \"../callchain.h\"\n#include \"../env.h\"\n#include \"../evsel.h\"\n#include \"../event.h\"\n#include \"../thread.h\"\n#include \"../comm.h\"\n#include \"../machine.h\"\n#include \"../db-export.h\"\n#include \"../thread-stack.h\"\n#include \"../trace-event.h\"\n#include \"../call-path.h\"\n#include \"map.h\"\n#include \"symbol.h\"\n#include \"thread_map.h\"\n#include \"print_binary.h\"\n#include \"stat.h\"\n#include \"mem-events.h\"\n#include \"util/perf_regs.h\"\n\n#if PY_MAJOR_VERSION < 3\n#define _PyUnicode_FromString(arg) \\\n  PyString_FromString(arg)\n#define _PyUnicode_FromStringAndSize(arg1, arg2) \\\n  PyString_FromStringAndSize((arg1), (arg2))\n#define _PyBytes_FromStringAndSize(arg1, arg2) \\\n  PyString_FromStringAndSize((arg1), (arg2))\n#define _PyLong_FromLong(arg) \\\n  PyInt_FromLong(arg)\n#define _PyLong_AsLong(arg) \\\n  PyInt_AsLong(arg)\n#define _PyCapsule_New(arg1, arg2, arg3) \\\n  PyCObject_FromVoidPtr((arg1), (arg2))\n\nPyMODINIT_FUNC initperf_trace_context(void);\n#else\n#define _PyUnicode_FromString(arg) \\\n  PyUnicode_FromString(arg)\n#define _PyUnicode_FromStringAndSize(arg1, arg2) \\\n  PyUnicode_FromStringAndSize((arg1), (arg2))\n#define _PyBytes_FromStringAndSize(arg1, arg2) \\\n  PyBytes_FromStringAndSize((arg1), (arg2))\n#define _PyLong_FromLong(arg) \\\n  PyLong_FromLong(arg)\n#define _PyLong_AsLong(arg) \\\n  PyLong_AsLong(arg)\n#define _PyCapsule_New(arg1, arg2, arg3) \\\n  PyCapsule_New((arg1), (arg2), (arg3))\n\nPyMODINIT_FUNC PyInit_perf_trace_context(void);\n#endif\n\n#ifdef HAVE_LIBTRACEEVENT\n#define TRACE_EVENT_TYPE_MAX\t\t\t\t\\\n\t((1 << (sizeof(unsigned short) * 8)) - 1)\n\n#define N_COMMON_FIELDS\t7\n\nstatic char *cur_field_name;\nstatic int zero_flag_atom;\n#endif\n\n#define MAX_FIELDS\t64\n\nextern struct scripting_context *scripting_context;\n\nstatic PyObject *main_module, *main_dict;\n\nstruct tables {\n\tstruct db_export\tdbe;\n\tPyObject\t\t*evsel_handler;\n\tPyObject\t\t*machine_handler;\n\tPyObject\t\t*thread_handler;\n\tPyObject\t\t*comm_handler;\n\tPyObject\t\t*comm_thread_handler;\n\tPyObject\t\t*dso_handler;\n\tPyObject\t\t*symbol_handler;\n\tPyObject\t\t*branch_type_handler;\n\tPyObject\t\t*sample_handler;\n\tPyObject\t\t*call_path_handler;\n\tPyObject\t\t*call_return_handler;\n\tPyObject\t\t*synth_handler;\n\tPyObject\t\t*context_switch_handler;\n\tbool\t\t\tdb_export_mode;\n};\n\nstatic struct tables tables_global;\n\nstatic void handler_call_die(const char *handler_name) __noreturn;\nstatic void handler_call_die(const char *handler_name)\n{\n\tPyErr_Print();\n\tPy_FatalError(\"problem in Python trace event handler\");\n\t\n\t\n\tabort();\n}\n\n \nstatic void pydict_set_item_string_decref(PyObject *dict, const char *key, PyObject *val)\n{\n\tPyDict_SetItemString(dict, key, val);\n\tPy_DECREF(val);\n}\n\nstatic PyObject *get_handler(const char *handler_name)\n{\n\tPyObject *handler;\n\n\thandler = PyDict_GetItemString(main_dict, handler_name);\n\tif (handler && !PyCallable_Check(handler))\n\t\treturn NULL;\n\treturn handler;\n}\n\nstatic void call_object(PyObject *handler, PyObject *args, const char *die_msg)\n{\n\tPyObject *retval;\n\n\tretval = PyObject_CallObject(handler, args);\n\tif (retval == NULL)\n\t\thandler_call_die(die_msg);\n\tPy_DECREF(retval);\n}\n\nstatic void try_call_object(const char *handler_name, PyObject *args)\n{\n\tPyObject *handler;\n\n\thandler = get_handler(handler_name);\n\tif (handler)\n\t\tcall_object(handler, args, handler_name);\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nstatic int get_argument_count(PyObject *handler)\n{\n\tint arg_count = 0;\n\n\t \n\tPyObject *code_obj = PyObject_GetAttrString(handler,\n\t\t\"func_code\");\n\tif (PyErr_Occurred()) {\n\t\tPyErr_Clear();\n\t\tcode_obj = PyObject_GetAttrString(handler,\n\t\t\t\"__code__\");\n\t}\n\tPyErr_Clear();\n\tif (code_obj) {\n\t\tPyObject *arg_count_obj = PyObject_GetAttrString(code_obj,\n\t\t\t\"co_argcount\");\n\t\tif (arg_count_obj) {\n\t\t\targ_count = (int) _PyLong_AsLong(arg_count_obj);\n\t\t\tPy_DECREF(arg_count_obj);\n\t\t}\n\t\tPy_DECREF(code_obj);\n\t}\n\treturn arg_count;\n}\n\nstatic void define_value(enum tep_print_arg_type field_type,\n\t\t\t const char *ev_name,\n\t\t\t const char *field_name,\n\t\t\t const char *field_value,\n\t\t\t const char *field_str)\n{\n\tconst char *handler_name = \"define_flag_value\";\n\tPyObject *t;\n\tunsigned long long value;\n\tunsigned n = 0;\n\n\tif (field_type == TEP_PRINT_SYMBOL)\n\t\thandler_name = \"define_symbolic_value\";\n\n\tt = PyTuple_New(4);\n\tif (!t)\n\t\tPy_FatalError(\"couldn't create Python tuple\");\n\n\tvalue = eval_flag(field_value);\n\n\tPyTuple_SetItem(t, n++, _PyUnicode_FromString(ev_name));\n\tPyTuple_SetItem(t, n++, _PyUnicode_FromString(field_name));\n\tPyTuple_SetItem(t, n++, _PyLong_FromLong(value));\n\tPyTuple_SetItem(t, n++, _PyUnicode_FromString(field_str));\n\n\ttry_call_object(handler_name, t);\n\n\tPy_DECREF(t);\n}\n\nstatic void define_values(enum tep_print_arg_type field_type,\n\t\t\t  struct tep_print_flag_sym *field,\n\t\t\t  const char *ev_name,\n\t\t\t  const char *field_name)\n{\n\tdefine_value(field_type, ev_name, field_name, field->value,\n\t\t     field->str);\n\n\tif (field->next)\n\t\tdefine_values(field_type, field->next, ev_name, field_name);\n}\n\nstatic void define_field(enum tep_print_arg_type field_type,\n\t\t\t const char *ev_name,\n\t\t\t const char *field_name,\n\t\t\t const char *delim)\n{\n\tconst char *handler_name = \"define_flag_field\";\n\tPyObject *t;\n\tunsigned n = 0;\n\n\tif (field_type == TEP_PRINT_SYMBOL)\n\t\thandler_name = \"define_symbolic_field\";\n\n\tif (field_type == TEP_PRINT_FLAGS)\n\t\tt = PyTuple_New(3);\n\telse\n\t\tt = PyTuple_New(2);\n\tif (!t)\n\t\tPy_FatalError(\"couldn't create Python tuple\");\n\n\tPyTuple_SetItem(t, n++, _PyUnicode_FromString(ev_name));\n\tPyTuple_SetItem(t, n++, _PyUnicode_FromString(field_name));\n\tif (field_type == TEP_PRINT_FLAGS)\n\t\tPyTuple_SetItem(t, n++, _PyUnicode_FromString(delim));\n\n\ttry_call_object(handler_name, t);\n\n\tPy_DECREF(t);\n}\n\nstatic void define_event_symbols(struct tep_event *event,\n\t\t\t\t const char *ev_name,\n\t\t\t\t struct tep_print_arg *args)\n{\n\tif (args == NULL)\n\t\treturn;\n\n\tswitch (args->type) {\n\tcase TEP_PRINT_NULL:\n\t\tbreak;\n\tcase TEP_PRINT_ATOM:\n\t\tdefine_value(TEP_PRINT_FLAGS, ev_name, cur_field_name, \"0\",\n\t\t\t     args->atom.atom);\n\t\tzero_flag_atom = 0;\n\t\tbreak;\n\tcase TEP_PRINT_FIELD:\n\t\tfree(cur_field_name);\n\t\tcur_field_name = strdup(args->field.name);\n\t\tbreak;\n\tcase TEP_PRINT_FLAGS:\n\t\tdefine_event_symbols(event, ev_name, args->flags.field);\n\t\tdefine_field(TEP_PRINT_FLAGS, ev_name, cur_field_name,\n\t\t\t     args->flags.delim);\n\t\tdefine_values(TEP_PRINT_FLAGS, args->flags.flags, ev_name,\n\t\t\t      cur_field_name);\n\t\tbreak;\n\tcase TEP_PRINT_SYMBOL:\n\t\tdefine_event_symbols(event, ev_name, args->symbol.field);\n\t\tdefine_field(TEP_PRINT_SYMBOL, ev_name, cur_field_name, NULL);\n\t\tdefine_values(TEP_PRINT_SYMBOL, args->symbol.symbols, ev_name,\n\t\t\t      cur_field_name);\n\t\tbreak;\n\tcase TEP_PRINT_HEX:\n\tcase TEP_PRINT_HEX_STR:\n\t\tdefine_event_symbols(event, ev_name, args->hex.field);\n\t\tdefine_event_symbols(event, ev_name, args->hex.size);\n\t\tbreak;\n\tcase TEP_PRINT_INT_ARRAY:\n\t\tdefine_event_symbols(event, ev_name, args->int_array.field);\n\t\tdefine_event_symbols(event, ev_name, args->int_array.count);\n\t\tdefine_event_symbols(event, ev_name, args->int_array.el_size);\n\t\tbreak;\n\tcase TEP_PRINT_STRING:\n\t\tbreak;\n\tcase TEP_PRINT_TYPE:\n\t\tdefine_event_symbols(event, ev_name, args->typecast.item);\n\t\tbreak;\n\tcase TEP_PRINT_OP:\n\t\tif (strcmp(args->op.op, \":\") == 0)\n\t\t\tzero_flag_atom = 1;\n\t\tdefine_event_symbols(event, ev_name, args->op.left);\n\t\tdefine_event_symbols(event, ev_name, args->op.right);\n\t\tbreak;\n\tdefault:\n\t\t \n\tcase TEP_PRINT_BSTRING:\n\tcase TEP_PRINT_DYNAMIC_ARRAY:\n\tcase TEP_PRINT_DYNAMIC_ARRAY_LEN:\n\tcase TEP_PRINT_FUNC:\n\tcase TEP_PRINT_BITMASK:\n\t\t \n\t\treturn;\n\t}\n\n\tif (args->next)\n\t\tdefine_event_symbols(event, ev_name, args->next);\n}\n\nstatic PyObject *get_field_numeric_entry(struct tep_event *event,\n\t\tstruct tep_format_field *field, void *data)\n{\n\tbool is_array = field->flags & TEP_FIELD_IS_ARRAY;\n\tPyObject *obj = NULL, *list = NULL;\n\tunsigned long long val;\n\tunsigned int item_size, n_items, i;\n\n\tif (is_array) {\n\t\tlist = PyList_New(field->arraylen);\n\t\titem_size = field->size / field->arraylen;\n\t\tn_items = field->arraylen;\n\t} else {\n\t\titem_size = field->size;\n\t\tn_items = 1;\n\t}\n\n\tfor (i = 0; i < n_items; i++) {\n\n\t\tval = read_size(event, data + field->offset + i * item_size,\n\t\t\t\titem_size);\n\t\tif (field->flags & TEP_FIELD_IS_SIGNED) {\n\t\t\tif ((long long)val >= LONG_MIN &&\n\t\t\t\t\t(long long)val <= LONG_MAX)\n\t\t\t\tobj = _PyLong_FromLong(val);\n\t\t\telse\n\t\t\t\tobj = PyLong_FromLongLong(val);\n\t\t} else {\n\t\t\tif (val <= LONG_MAX)\n\t\t\t\tobj = _PyLong_FromLong(val);\n\t\t\telse\n\t\t\t\tobj = PyLong_FromUnsignedLongLong(val);\n\t\t}\n\t\tif (is_array)\n\t\t\tPyList_SET_ITEM(list, i, obj);\n\t}\n\tif (is_array)\n\t\tobj = list;\n\treturn obj;\n}\n#endif\n\nstatic const char *get_dsoname(struct map *map)\n{\n\tconst char *dsoname = \"[unknown]\";\n\tstruct dso *dso = map ? map__dso(map) : NULL;\n\n\tif (dso) {\n\t\tif (symbol_conf.show_kernel_path && dso->long_name)\n\t\t\tdsoname = dso->long_name;\n\t\telse\n\t\t\tdsoname = dso->name;\n\t}\n\n\treturn dsoname;\n}\n\nstatic unsigned long get_offset(struct symbol *sym, struct addr_location *al)\n{\n\tunsigned long offset;\n\n\tif (al->addr < sym->end)\n\t\toffset = al->addr - sym->start;\n\telse\n\t\toffset = al->addr - map__start(al->map) - sym->start;\n\n\treturn offset;\n}\n\nstatic PyObject *python_process_callchain(struct perf_sample *sample,\n\t\t\t\t\t struct evsel *evsel,\n\t\t\t\t\t struct addr_location *al)\n{\n\tPyObject *pylist;\n\tstruct callchain_cursor *cursor;\n\n\tpylist = PyList_New(0);\n\tif (!pylist)\n\t\tPy_FatalError(\"couldn't create Python list\");\n\n\tif (!symbol_conf.use_callchain || !sample->callchain)\n\t\tgoto exit;\n\n\tcursor = get_tls_callchain_cursor();\n\tif (thread__resolve_callchain(al->thread, cursor, evsel,\n\t\t\t\t      sample, NULL, NULL,\n\t\t\t\t      scripting_max_stack) != 0) {\n\t\tpr_err(\"Failed to resolve callchain. Skipping\\n\");\n\t\tgoto exit;\n\t}\n\tcallchain_cursor_commit(cursor);\n\n\n\twhile (1) {\n\t\tPyObject *pyelem;\n\t\tstruct callchain_cursor_node *node;\n\t\tnode = callchain_cursor_current(cursor);\n\t\tif (!node)\n\t\t\tbreak;\n\n\t\tpyelem = PyDict_New();\n\t\tif (!pyelem)\n\t\t\tPy_FatalError(\"couldn't create Python dictionary\");\n\n\n\t\tpydict_set_item_string_decref(pyelem, \"ip\",\n\t\t\t\tPyLong_FromUnsignedLongLong(node->ip));\n\n\t\tif (node->ms.sym) {\n\t\t\tPyObject *pysym  = PyDict_New();\n\t\t\tif (!pysym)\n\t\t\t\tPy_FatalError(\"couldn't create Python dictionary\");\n\t\t\tpydict_set_item_string_decref(pysym, \"start\",\n\t\t\t\t\tPyLong_FromUnsignedLongLong(node->ms.sym->start));\n\t\t\tpydict_set_item_string_decref(pysym, \"end\",\n\t\t\t\t\tPyLong_FromUnsignedLongLong(node->ms.sym->end));\n\t\t\tpydict_set_item_string_decref(pysym, \"binding\",\n\t\t\t\t\t_PyLong_FromLong(node->ms.sym->binding));\n\t\t\tpydict_set_item_string_decref(pysym, \"name\",\n\t\t\t\t\t_PyUnicode_FromStringAndSize(node->ms.sym->name,\n\t\t\t\t\t\t\tnode->ms.sym->namelen));\n\t\t\tpydict_set_item_string_decref(pyelem, \"sym\", pysym);\n\n\t\t\tif (node->ms.map) {\n\t\t\t\tstruct map *map = node->ms.map;\n\t\t\t\tstruct addr_location node_al;\n\t\t\t\tunsigned long offset;\n\n\t\t\t\taddr_location__init(&node_al);\n\t\t\t\tnode_al.addr = map__map_ip(map, node->ip);\n\t\t\t\tnode_al.map  = map__get(map);\n\t\t\t\toffset = get_offset(node->ms.sym, &node_al);\n\t\t\t\taddr_location__exit(&node_al);\n\n\t\t\t\tpydict_set_item_string_decref(\n\t\t\t\t\tpyelem, \"sym_off\",\n\t\t\t\t\tPyLong_FromUnsignedLongLong(offset));\n\t\t\t}\n\t\t\tif (node->srcline && strcmp(\":0\", node->srcline)) {\n\t\t\t\tpydict_set_item_string_decref(\n\t\t\t\t\tpyelem, \"sym_srcline\",\n\t\t\t\t\t_PyUnicode_FromString(node->srcline));\n\t\t\t}\n\t\t}\n\n\t\tif (node->ms.map) {\n\t\t\tconst char *dsoname = get_dsoname(node->ms.map);\n\n\t\t\tpydict_set_item_string_decref(pyelem, \"dso\",\n\t\t\t\t\t_PyUnicode_FromString(dsoname));\n\t\t}\n\n\t\tcallchain_cursor_advance(cursor);\n\t\tPyList_Append(pylist, pyelem);\n\t\tPy_DECREF(pyelem);\n\t}\n\nexit:\n\treturn pylist;\n}\n\nstatic PyObject *python_process_brstack(struct perf_sample *sample,\n\t\t\t\t\tstruct thread *thread)\n{\n\tstruct branch_stack *br = sample->branch_stack;\n\tstruct branch_entry *entries = perf_sample__branch_entries(sample);\n\tPyObject *pylist;\n\tu64 i;\n\n\tpylist = PyList_New(0);\n\tif (!pylist)\n\t\tPy_FatalError(\"couldn't create Python list\");\n\n\tif (!(br && br->nr))\n\t\tgoto exit;\n\n\tfor (i = 0; i < br->nr; i++) {\n\t\tPyObject *pyelem;\n\t\tstruct addr_location al;\n\t\tconst char *dsoname;\n\n\t\tpyelem = PyDict_New();\n\t\tif (!pyelem)\n\t\t\tPy_FatalError(\"couldn't create Python dictionary\");\n\n\t\tpydict_set_item_string_decref(pyelem, \"from\",\n\t\t    PyLong_FromUnsignedLongLong(entries[i].from));\n\t\tpydict_set_item_string_decref(pyelem, \"to\",\n\t\t    PyLong_FromUnsignedLongLong(entries[i].to));\n\t\tpydict_set_item_string_decref(pyelem, \"mispred\",\n\t\t    PyBool_FromLong(entries[i].flags.mispred));\n\t\tpydict_set_item_string_decref(pyelem, \"predicted\",\n\t\t    PyBool_FromLong(entries[i].flags.predicted));\n\t\tpydict_set_item_string_decref(pyelem, \"in_tx\",\n\t\t    PyBool_FromLong(entries[i].flags.in_tx));\n\t\tpydict_set_item_string_decref(pyelem, \"abort\",\n\t\t    PyBool_FromLong(entries[i].flags.abort));\n\t\tpydict_set_item_string_decref(pyelem, \"cycles\",\n\t\t    PyLong_FromUnsignedLongLong(entries[i].flags.cycles));\n\n\t\taddr_location__init(&al);\n\t\tthread__find_map_fb(thread, sample->cpumode,\n\t\t\t\t    entries[i].from, &al);\n\t\tdsoname = get_dsoname(al.map);\n\t\tpydict_set_item_string_decref(pyelem, \"from_dsoname\",\n\t\t\t\t\t      _PyUnicode_FromString(dsoname));\n\n\t\tthread__find_map_fb(thread, sample->cpumode,\n\t\t\t\t    entries[i].to, &al);\n\t\tdsoname = get_dsoname(al.map);\n\t\tpydict_set_item_string_decref(pyelem, \"to_dsoname\",\n\t\t\t\t\t      _PyUnicode_FromString(dsoname));\n\n\t\taddr_location__exit(&al);\n\t\tPyList_Append(pylist, pyelem);\n\t\tPy_DECREF(pyelem);\n\t}\n\nexit:\n\treturn pylist;\n}\n\nstatic int get_symoff(struct symbol *sym, struct addr_location *al,\n\t\t      bool print_off, char *bf, int size)\n{\n\tunsigned long offset;\n\n\tif (!sym || !sym->name[0])\n\t\treturn scnprintf(bf, size, \"%s\", \"[unknown]\");\n\n\tif (!print_off)\n\t\treturn scnprintf(bf, size, \"%s\", sym->name);\n\n\toffset = get_offset(sym, al);\n\n\treturn scnprintf(bf, size, \"%s+0x%x\", sym->name, offset);\n}\n\nstatic int get_br_mspred(struct branch_flags *flags, char *bf, int size)\n{\n\tif (!flags->mispred  && !flags->predicted)\n\t\treturn scnprintf(bf, size, \"%s\", \"-\");\n\n\tif (flags->mispred)\n\t\treturn scnprintf(bf, size, \"%s\", \"M\");\n\n\treturn scnprintf(bf, size, \"%s\", \"P\");\n}\n\nstatic PyObject *python_process_brstacksym(struct perf_sample *sample,\n\t\t\t\t\t   struct thread *thread)\n{\n\tstruct branch_stack *br = sample->branch_stack;\n\tstruct branch_entry *entries = perf_sample__branch_entries(sample);\n\tPyObject *pylist;\n\tu64 i;\n\tchar bf[512];\n\n\tpylist = PyList_New(0);\n\tif (!pylist)\n\t\tPy_FatalError(\"couldn't create Python list\");\n\n\tif (!(br && br->nr))\n\t\tgoto exit;\n\n\tfor (i = 0; i < br->nr; i++) {\n\t\tPyObject *pyelem;\n\t\tstruct addr_location al;\n\n\t\taddr_location__init(&al);\n\t\tpyelem = PyDict_New();\n\t\tif (!pyelem)\n\t\t\tPy_FatalError(\"couldn't create Python dictionary\");\n\n\t\tthread__find_symbol_fb(thread, sample->cpumode,\n\t\t\t\t       entries[i].from, &al);\n\t\tget_symoff(al.sym, &al, true, bf, sizeof(bf));\n\t\tpydict_set_item_string_decref(pyelem, \"from\",\n\t\t\t\t\t      _PyUnicode_FromString(bf));\n\n\t\tthread__find_symbol_fb(thread, sample->cpumode,\n\t\t\t\t       entries[i].to, &al);\n\t\tget_symoff(al.sym, &al, true, bf, sizeof(bf));\n\t\tpydict_set_item_string_decref(pyelem, \"to\",\n\t\t\t\t\t      _PyUnicode_FromString(bf));\n\n\t\tget_br_mspred(&entries[i].flags, bf, sizeof(bf));\n\t\tpydict_set_item_string_decref(pyelem, \"pred\",\n\t\t\t\t\t      _PyUnicode_FromString(bf));\n\n\t\tif (entries[i].flags.in_tx) {\n\t\t\tpydict_set_item_string_decref(pyelem, \"in_tx\",\n\t\t\t\t\t      _PyUnicode_FromString(\"X\"));\n\t\t} else {\n\t\t\tpydict_set_item_string_decref(pyelem, \"in_tx\",\n\t\t\t\t\t      _PyUnicode_FromString(\"-\"));\n\t\t}\n\n\t\tif (entries[i].flags.abort) {\n\t\t\tpydict_set_item_string_decref(pyelem, \"abort\",\n\t\t\t\t\t      _PyUnicode_FromString(\"A\"));\n\t\t} else {\n\t\t\tpydict_set_item_string_decref(pyelem, \"abort\",\n\t\t\t\t\t      _PyUnicode_FromString(\"-\"));\n\t\t}\n\n\t\tPyList_Append(pylist, pyelem);\n\t\tPy_DECREF(pyelem);\n\t\taddr_location__exit(&al);\n\t}\n\nexit:\n\treturn pylist;\n}\n\nstatic PyObject *get_sample_value_as_tuple(struct sample_read_value *value,\n\t\t\t\t\t   u64 read_format)\n{\n\tPyObject *t;\n\n\tt = PyTuple_New(3);\n\tif (!t)\n\t\tPy_FatalError(\"couldn't create Python tuple\");\n\tPyTuple_SetItem(t, 0, PyLong_FromUnsignedLongLong(value->id));\n\tPyTuple_SetItem(t, 1, PyLong_FromUnsignedLongLong(value->value));\n\tif (read_format & PERF_FORMAT_LOST)\n\t\tPyTuple_SetItem(t, 2, PyLong_FromUnsignedLongLong(value->lost));\n\n\treturn t;\n}\n\nstatic void set_sample_read_in_dict(PyObject *dict_sample,\n\t\t\t\t\t struct perf_sample *sample,\n\t\t\t\t\t struct evsel *evsel)\n{\n\tu64 read_format = evsel->core.attr.read_format;\n\tPyObject *values;\n\tunsigned int i;\n\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED) {\n\t\tpydict_set_item_string_decref(dict_sample, \"time_enabled\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->read.time_enabled));\n\t}\n\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING) {\n\t\tpydict_set_item_string_decref(dict_sample, \"time_running\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->read.time_running));\n\t}\n\n\tif (read_format & PERF_FORMAT_GROUP)\n\t\tvalues = PyList_New(sample->read.group.nr);\n\telse\n\t\tvalues = PyList_New(1);\n\n\tif (!values)\n\t\tPy_FatalError(\"couldn't create Python list\");\n\n\tif (read_format & PERF_FORMAT_GROUP) {\n\t\tstruct sample_read_value *v = sample->read.group.values;\n\n\t\ti = 0;\n\t\tsample_read_group__for_each(v, sample->read.group.nr, read_format) {\n\t\t\tPyObject *t = get_sample_value_as_tuple(v, read_format);\n\t\t\tPyList_SET_ITEM(values, i, t);\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\tPyObject *t = get_sample_value_as_tuple(&sample->read.one,\n\t\t\t\t\t\t\tread_format);\n\t\tPyList_SET_ITEM(values, 0, t);\n\t}\n\tpydict_set_item_string_decref(dict_sample, \"values\", values);\n}\n\nstatic void set_sample_datasrc_in_dict(PyObject *dict,\n\t\t\t\t       struct perf_sample *sample)\n{\n\tstruct mem_info mi = { .data_src.val = sample->data_src };\n\tchar decode[100];\n\n\tpydict_set_item_string_decref(dict, \"datasrc\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->data_src));\n\n\tperf_script__meminfo_scnprintf(decode, 100, &mi);\n\n\tpydict_set_item_string_decref(dict, \"datasrc_decode\",\n\t\t\t_PyUnicode_FromString(decode));\n}\n\nstatic void regs_map(struct regs_dump *regs, uint64_t mask, const char *arch, char *bf, int size)\n{\n\tunsigned int i = 0, r;\n\tint printed = 0;\n\n\tbf[0] = 0;\n\n\tif (size <= 0)\n\t\treturn;\n\n\tif (!regs || !regs->regs)\n\t\treturn;\n\n\tfor_each_set_bit(r, (unsigned long *) &mask, sizeof(mask) * 8) {\n\t\tu64 val = regs->regs[i++];\n\n\t\tprinted += scnprintf(bf + printed, size - printed,\n\t\t\t\t     \"%5s:0x%\" PRIx64 \" \",\n\t\t\t\t     perf_reg_name(r, arch), val);\n\t}\n}\n\nstatic void set_regs_in_dict(PyObject *dict,\n\t\t\t     struct perf_sample *sample,\n\t\t\t     struct evsel *evsel)\n{\n\tstruct perf_event_attr *attr = &evsel->core.attr;\n\tconst char *arch = perf_env__arch(evsel__env(evsel));\n\n\t \n\tint size = __sw_hweight64(attr->sample_regs_intr) * 28;\n\tchar *bf = malloc(size);\n\n\tregs_map(&sample->intr_regs, attr->sample_regs_intr, arch, bf, size);\n\n\tpydict_set_item_string_decref(dict, \"iregs\",\n\t\t\t_PyUnicode_FromString(bf));\n\n\tregs_map(&sample->user_regs, attr->sample_regs_user, arch, bf, size);\n\n\tpydict_set_item_string_decref(dict, \"uregs\",\n\t\t\t_PyUnicode_FromString(bf));\n\tfree(bf);\n}\n\nstatic void set_sym_in_dict(PyObject *dict, struct addr_location *al,\n\t\t\t    const char *dso_field, const char *dso_bid_field,\n\t\t\t    const char *dso_map_start, const char *dso_map_end,\n\t\t\t    const char *sym_field, const char *symoff_field)\n{\n\tchar sbuild_id[SBUILD_ID_SIZE];\n\n\tif (al->map) {\n\t\tstruct dso *dso = map__dso(al->map);\n\n\t\tpydict_set_item_string_decref(dict, dso_field, _PyUnicode_FromString(dso->name));\n\t\tbuild_id__sprintf(&dso->bid, sbuild_id);\n\t\tpydict_set_item_string_decref(dict, dso_bid_field,\n\t\t\t_PyUnicode_FromString(sbuild_id));\n\t\tpydict_set_item_string_decref(dict, dso_map_start,\n\t\t\tPyLong_FromUnsignedLong(map__start(al->map)));\n\t\tpydict_set_item_string_decref(dict, dso_map_end,\n\t\t\tPyLong_FromUnsignedLong(map__end(al->map)));\n\t}\n\tif (al->sym) {\n\t\tpydict_set_item_string_decref(dict, sym_field,\n\t\t\t_PyUnicode_FromString(al->sym->name));\n\t\tpydict_set_item_string_decref(dict, symoff_field,\n\t\t\tPyLong_FromUnsignedLong(get_offset(al->sym, al)));\n\t}\n}\n\nstatic void set_sample_flags(PyObject *dict, u32 flags)\n{\n\tconst char *ch = PERF_IP_FLAG_CHARS;\n\tchar *p, str[33];\n\n\tfor (p = str; *ch; ch++, flags >>= 1) {\n\t\tif (flags & 1)\n\t\t\t*p++ = *ch;\n\t}\n\t*p = 0;\n\tpydict_set_item_string_decref(dict, \"flags\", _PyUnicode_FromString(str));\n}\n\nstatic void python_process_sample_flags(struct perf_sample *sample, PyObject *dict_sample)\n{\n\tchar flags_disp[SAMPLE_FLAGS_BUF_SIZE];\n\n\tset_sample_flags(dict_sample, sample->flags);\n\tperf_sample__sprintf_flags(sample->flags, flags_disp, sizeof(flags_disp));\n\tpydict_set_item_string_decref(dict_sample, \"flags_disp\",\n\t\t_PyUnicode_FromString(flags_disp));\n}\n\nstatic PyObject *get_perf_sample_dict(struct perf_sample *sample,\n\t\t\t\t\t struct evsel *evsel,\n\t\t\t\t\t struct addr_location *al,\n\t\t\t\t\t struct addr_location *addr_al,\n\t\t\t\t\t PyObject *callchain)\n{\n\tPyObject *dict, *dict_sample, *brstack, *brstacksym;\n\n\tdict = PyDict_New();\n\tif (!dict)\n\t\tPy_FatalError(\"couldn't create Python dictionary\");\n\n\tdict_sample = PyDict_New();\n\tif (!dict_sample)\n\t\tPy_FatalError(\"couldn't create Python dictionary\");\n\n\tpydict_set_item_string_decref(dict, \"ev_name\", _PyUnicode_FromString(evsel__name(evsel)));\n\tpydict_set_item_string_decref(dict, \"attr\", _PyBytes_FromStringAndSize((const char *)&evsel->core.attr, sizeof(evsel->core.attr)));\n\n\tpydict_set_item_string_decref(dict_sample, \"pid\",\n\t\t\t_PyLong_FromLong(sample->pid));\n\tpydict_set_item_string_decref(dict_sample, \"tid\",\n\t\t\t_PyLong_FromLong(sample->tid));\n\tpydict_set_item_string_decref(dict_sample, \"cpu\",\n\t\t\t_PyLong_FromLong(sample->cpu));\n\tpydict_set_item_string_decref(dict_sample, \"ip\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->ip));\n\tpydict_set_item_string_decref(dict_sample, \"time\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->time));\n\tpydict_set_item_string_decref(dict_sample, \"period\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->period));\n\tpydict_set_item_string_decref(dict_sample, \"phys_addr\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->phys_addr));\n\tpydict_set_item_string_decref(dict_sample, \"addr\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->addr));\n\tset_sample_read_in_dict(dict_sample, sample, evsel);\n\tpydict_set_item_string_decref(dict_sample, \"weight\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->weight));\n\tpydict_set_item_string_decref(dict_sample, \"transaction\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->transaction));\n\tset_sample_datasrc_in_dict(dict_sample, sample);\n\tpydict_set_item_string_decref(dict, \"sample\", dict_sample);\n\n\tpydict_set_item_string_decref(dict, \"raw_buf\", _PyBytes_FromStringAndSize(\n\t\t\t(const char *)sample->raw_data, sample->raw_size));\n\tpydict_set_item_string_decref(dict, \"comm\",\n\t\t\t_PyUnicode_FromString(thread__comm_str(al->thread)));\n\tset_sym_in_dict(dict, al, \"dso\", \"dso_bid\", \"dso_map_start\", \"dso_map_end\",\n\t\t\t\"symbol\", \"symoff\");\n\n\tpydict_set_item_string_decref(dict, \"callchain\", callchain);\n\n\tbrstack = python_process_brstack(sample, al->thread);\n\tpydict_set_item_string_decref(dict, \"brstack\", brstack);\n\n\tbrstacksym = python_process_brstacksym(sample, al->thread);\n\tpydict_set_item_string_decref(dict, \"brstacksym\", brstacksym);\n\n\tif (sample->machine_pid) {\n\t\tpydict_set_item_string_decref(dict_sample, \"machine_pid\",\n\t\t\t\t_PyLong_FromLong(sample->machine_pid));\n\t\tpydict_set_item_string_decref(dict_sample, \"vcpu\",\n\t\t\t\t_PyLong_FromLong(sample->vcpu));\n\t}\n\n\tpydict_set_item_string_decref(dict_sample, \"cpumode\",\n\t\t\t_PyLong_FromLong((unsigned long)sample->cpumode));\n\n\tif (addr_al) {\n\t\tpydict_set_item_string_decref(dict_sample, \"addr_correlates_sym\",\n\t\t\tPyBool_FromLong(1));\n\t\tset_sym_in_dict(dict_sample, addr_al, \"addr_dso\", \"addr_dso_bid\",\n\t\t\t\t\"addr_dso_map_start\", \"addr_dso_map_end\",\n\t\t\t\t\"addr_symbol\", \"addr_symoff\");\n\t}\n\n\tif (sample->flags)\n\t\tpython_process_sample_flags(sample, dict_sample);\n\n\t \n\tif (sample->insn_cnt && sample->cyc_cnt) {\n\t\tpydict_set_item_string_decref(dict_sample, \"insn_cnt\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->insn_cnt));\n\t\tpydict_set_item_string_decref(dict_sample, \"cyc_cnt\",\n\t\t\tPyLong_FromUnsignedLongLong(sample->cyc_cnt));\n\t}\n\n\tset_regs_in_dict(dict, sample, evsel);\n\n\treturn dict;\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nstatic void python_process_tracepoint(struct perf_sample *sample,\n\t\t\t\t      struct evsel *evsel,\n\t\t\t\t      struct addr_location *al,\n\t\t\t\t      struct addr_location *addr_al)\n{\n\tstruct tep_event *event = evsel->tp_format;\n\tPyObject *handler, *context, *t, *obj = NULL, *callchain;\n\tPyObject *dict = NULL, *all_entries_dict = NULL;\n\tstatic char handler_name[256];\n\tstruct tep_format_field *field;\n\tunsigned long s, ns;\n\tunsigned n = 0;\n\tint pid;\n\tint cpu = sample->cpu;\n\tvoid *data = sample->raw_data;\n\tunsigned long long nsecs = sample->time;\n\tconst char *comm = thread__comm_str(al->thread);\n\tconst char *default_handler_name = \"trace_unhandled\";\n\tDECLARE_BITMAP(events_defined, TRACE_EVENT_TYPE_MAX);\n\n\tbitmap_zero(events_defined, TRACE_EVENT_TYPE_MAX);\n\n\tif (!event) {\n\t\tsnprintf(handler_name, sizeof(handler_name),\n\t\t\t \"ug! no event found for type %\" PRIu64, (u64)evsel->core.attr.config);\n\t\tPy_FatalError(handler_name);\n\t}\n\n\tpid = raw_field_value(event, \"common_pid\", data);\n\n\tsprintf(handler_name, \"%s__%s\", event->system, event->name);\n\n\tif (!__test_and_set_bit(event->id, events_defined))\n\t\tdefine_event_symbols(event, handler_name, event->print_fmt.args);\n\n\thandler = get_handler(handler_name);\n\tif (!handler) {\n\t\thandler = get_handler(default_handler_name);\n\t\tif (!handler)\n\t\t\treturn;\n\t\tdict = PyDict_New();\n\t\tif (!dict)\n\t\t\tPy_FatalError(\"couldn't create Python dict\");\n\t}\n\n\tt = PyTuple_New(MAX_FIELDS);\n\tif (!t)\n\t\tPy_FatalError(\"couldn't create Python tuple\");\n\n\n\ts = nsecs / NSEC_PER_SEC;\n\tns = nsecs - s * NSEC_PER_SEC;\n\n\tcontext = _PyCapsule_New(scripting_context, NULL, NULL);\n\n\tPyTuple_SetItem(t, n++, _PyUnicode_FromString(handler_name));\n\tPyTuple_SetItem(t, n++, context);\n\n\t \n\tcallchain = python_process_callchain(sample, evsel, al);\n\t \n\tPy_INCREF(callchain);\n\n\tif (!dict) {\n\t\tPyTuple_SetItem(t, n++, _PyLong_FromLong(cpu));\n\t\tPyTuple_SetItem(t, n++, _PyLong_FromLong(s));\n\t\tPyTuple_SetItem(t, n++, _PyLong_FromLong(ns));\n\t\tPyTuple_SetItem(t, n++, _PyLong_FromLong(pid));\n\t\tPyTuple_SetItem(t, n++, _PyUnicode_FromString(comm));\n\t\tPyTuple_SetItem(t, n++, callchain);\n\t} else {\n\t\tpydict_set_item_string_decref(dict, \"common_cpu\", _PyLong_FromLong(cpu));\n\t\tpydict_set_item_string_decref(dict, \"common_s\", _PyLong_FromLong(s));\n\t\tpydict_set_item_string_decref(dict, \"common_ns\", _PyLong_FromLong(ns));\n\t\tpydict_set_item_string_decref(dict, \"common_pid\", _PyLong_FromLong(pid));\n\t\tpydict_set_item_string_decref(dict, \"common_comm\", _PyUnicode_FromString(comm));\n\t\tpydict_set_item_string_decref(dict, \"common_callchain\", callchain);\n\t}\n\tfor (field = event->format.fields; field; field = field->next) {\n\t\tunsigned int offset, len;\n\t\tunsigned long long val;\n\n\t\tif (field->flags & TEP_FIELD_IS_ARRAY) {\n\t\t\toffset = field->offset;\n\t\t\tlen    = field->size;\n\t\t\tif (field->flags & TEP_FIELD_IS_DYNAMIC) {\n\t\t\t\tval     = tep_read_number(scripting_context->pevent,\n\t\t\t\t\t\t\t  data + offset, len);\n\t\t\t\toffset  = val;\n\t\t\t\tlen     = offset >> 16;\n\t\t\t\toffset &= 0xffff;\n\t\t\t\tif (tep_field_is_relative(field->flags))\n\t\t\t\t\toffset += field->offset + field->size;\n\t\t\t}\n\t\t\tif (field->flags & TEP_FIELD_IS_STRING &&\n\t\t\t    is_printable_array(data + offset, len)) {\n\t\t\t\tobj = _PyUnicode_FromString((char *) data + offset);\n\t\t\t} else {\n\t\t\t\tobj = PyByteArray_FromStringAndSize((const char *) data + offset, len);\n\t\t\t\tfield->flags &= ~TEP_FIELD_IS_STRING;\n\t\t\t}\n\t\t} else {  \n\t\t\tobj = get_field_numeric_entry(event, field, data);\n\t\t}\n\t\tif (!dict)\n\t\t\tPyTuple_SetItem(t, n++, obj);\n\t\telse\n\t\t\tpydict_set_item_string_decref(dict, field->name, obj);\n\n\t}\n\n\tif (dict)\n\t\tPyTuple_SetItem(t, n++, dict);\n\n\tif (get_argument_count(handler) == (int) n + 1) {\n\t\tall_entries_dict = get_perf_sample_dict(sample, evsel, al, addr_al,\n\t\t\tcallchain);\n\t\tPyTuple_SetItem(t, n++,\tall_entries_dict);\n\t} else {\n\t\tPy_DECREF(callchain);\n\t}\n\n\tif (_PyTuple_Resize(&t, n) == -1)\n\t\tPy_FatalError(\"error resizing Python tuple\");\n\n\tif (!dict)\n\t\tcall_object(handler, t, handler_name);\n\telse\n\t\tcall_object(handler, t, default_handler_name);\n\n\tPy_DECREF(t);\n}\n#else\nstatic void python_process_tracepoint(struct perf_sample *sample __maybe_unused,\n\t\t\t\t      struct evsel *evsel __maybe_unused,\n\t\t\t\t      struct addr_location *al __maybe_unused,\n\t\t\t\t      struct addr_location *addr_al __maybe_unused)\n{\n\tfprintf(stderr, \"Tracepoint events are not supported because \"\n\t\t\t\"perf is not linked with libtraceevent.\\n\");\n}\n#endif\n\nstatic PyObject *tuple_new(unsigned int sz)\n{\n\tPyObject *t;\n\n\tt = PyTuple_New(sz);\n\tif (!t)\n\t\tPy_FatalError(\"couldn't create Python tuple\");\n\treturn t;\n}\n\nstatic int tuple_set_s64(PyObject *t, unsigned int pos, s64 val)\n{\n#if BITS_PER_LONG == 64\n\treturn PyTuple_SetItem(t, pos, _PyLong_FromLong(val));\n#endif\n#if BITS_PER_LONG == 32\n\treturn PyTuple_SetItem(t, pos, PyLong_FromLongLong(val));\n#endif\n}\n\n \n#define tuple_set_d64 tuple_set_s64\n\nstatic int tuple_set_u64(PyObject *t, unsigned int pos, u64 val)\n{\n#if BITS_PER_LONG == 64\n\treturn PyTuple_SetItem(t, pos, PyLong_FromUnsignedLong(val));\n#endif\n#if BITS_PER_LONG == 32\n\treturn PyTuple_SetItem(t, pos, PyLong_FromUnsignedLongLong(val));\n#endif\n}\n\nstatic int tuple_set_u32(PyObject *t, unsigned int pos, u32 val)\n{\n\treturn PyTuple_SetItem(t, pos, PyLong_FromUnsignedLong(val));\n}\n\nstatic int tuple_set_s32(PyObject *t, unsigned int pos, s32 val)\n{\n\treturn PyTuple_SetItem(t, pos, _PyLong_FromLong(val));\n}\n\nstatic int tuple_set_bool(PyObject *t, unsigned int pos, bool val)\n{\n\treturn PyTuple_SetItem(t, pos, PyBool_FromLong(val));\n}\n\nstatic int tuple_set_string(PyObject *t, unsigned int pos, const char *s)\n{\n\treturn PyTuple_SetItem(t, pos, _PyUnicode_FromString(s));\n}\n\nstatic int tuple_set_bytes(PyObject *t, unsigned int pos, void *bytes,\n\t\t\t   unsigned int sz)\n{\n\treturn PyTuple_SetItem(t, pos, _PyBytes_FromStringAndSize(bytes, sz));\n}\n\nstatic int python_export_evsel(struct db_export *dbe, struct evsel *evsel)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tPyObject *t;\n\n\tt = tuple_new(2);\n\n\ttuple_set_d64(t, 0, evsel->db_id);\n\ttuple_set_string(t, 1, evsel__name(evsel));\n\n\tcall_object(tables->evsel_handler, t, \"evsel_table\");\n\n\tPy_DECREF(t);\n\n\treturn 0;\n}\n\nstatic int python_export_machine(struct db_export *dbe,\n\t\t\t\t struct machine *machine)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tPyObject *t;\n\n\tt = tuple_new(3);\n\n\ttuple_set_d64(t, 0, machine->db_id);\n\ttuple_set_s32(t, 1, machine->pid);\n\ttuple_set_string(t, 2, machine->root_dir ? machine->root_dir : \"\");\n\n\tcall_object(tables->machine_handler, t, \"machine_table\");\n\n\tPy_DECREF(t);\n\n\treturn 0;\n}\n\nstatic int python_export_thread(struct db_export *dbe, struct thread *thread,\n\t\t\t\tu64 main_thread_db_id, struct machine *machine)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tPyObject *t;\n\n\tt = tuple_new(5);\n\n\ttuple_set_d64(t, 0, thread__db_id(thread));\n\ttuple_set_d64(t, 1, machine->db_id);\n\ttuple_set_d64(t, 2, main_thread_db_id);\n\ttuple_set_s32(t, 3, thread__pid(thread));\n\ttuple_set_s32(t, 4, thread__tid(thread));\n\n\tcall_object(tables->thread_handler, t, \"thread_table\");\n\n\tPy_DECREF(t);\n\n\treturn 0;\n}\n\nstatic int python_export_comm(struct db_export *dbe, struct comm *comm,\n\t\t\t      struct thread *thread)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tPyObject *t;\n\n\tt = tuple_new(5);\n\n\ttuple_set_d64(t, 0, comm->db_id);\n\ttuple_set_string(t, 1, comm__str(comm));\n\ttuple_set_d64(t, 2, thread__db_id(thread));\n\ttuple_set_d64(t, 3, comm->start);\n\ttuple_set_s32(t, 4, comm->exec);\n\n\tcall_object(tables->comm_handler, t, \"comm_table\");\n\n\tPy_DECREF(t);\n\n\treturn 0;\n}\n\nstatic int python_export_comm_thread(struct db_export *dbe, u64 db_id,\n\t\t\t\t     struct comm *comm, struct thread *thread)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tPyObject *t;\n\n\tt = tuple_new(3);\n\n\ttuple_set_d64(t, 0, db_id);\n\ttuple_set_d64(t, 1, comm->db_id);\n\ttuple_set_d64(t, 2, thread__db_id(thread));\n\n\tcall_object(tables->comm_thread_handler, t, \"comm_thread_table\");\n\n\tPy_DECREF(t);\n\n\treturn 0;\n}\n\nstatic int python_export_dso(struct db_export *dbe, struct dso *dso,\n\t\t\t     struct machine *machine)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tchar sbuild_id[SBUILD_ID_SIZE];\n\tPyObject *t;\n\n\tbuild_id__sprintf(&dso->bid, sbuild_id);\n\n\tt = tuple_new(5);\n\n\ttuple_set_d64(t, 0, dso->db_id);\n\ttuple_set_d64(t, 1, machine->db_id);\n\ttuple_set_string(t, 2, dso->short_name);\n\ttuple_set_string(t, 3, dso->long_name);\n\ttuple_set_string(t, 4, sbuild_id);\n\n\tcall_object(tables->dso_handler, t, \"dso_table\");\n\n\tPy_DECREF(t);\n\n\treturn 0;\n}\n\nstatic int python_export_symbol(struct db_export *dbe, struct symbol *sym,\n\t\t\t\tstruct dso *dso)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tu64 *sym_db_id = symbol__priv(sym);\n\tPyObject *t;\n\n\tt = tuple_new(6);\n\n\ttuple_set_d64(t, 0, *sym_db_id);\n\ttuple_set_d64(t, 1, dso->db_id);\n\ttuple_set_d64(t, 2, sym->start);\n\ttuple_set_d64(t, 3, sym->end);\n\ttuple_set_s32(t, 4, sym->binding);\n\ttuple_set_string(t, 5, sym->name);\n\n\tcall_object(tables->symbol_handler, t, \"symbol_table\");\n\n\tPy_DECREF(t);\n\n\treturn 0;\n}\n\nstatic int python_export_branch_type(struct db_export *dbe, u32 branch_type,\n\t\t\t\t     const char *name)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tPyObject *t;\n\n\tt = tuple_new(2);\n\n\ttuple_set_s32(t, 0, branch_type);\n\ttuple_set_string(t, 1, name);\n\n\tcall_object(tables->branch_type_handler, t, \"branch_type_table\");\n\n\tPy_DECREF(t);\n\n\treturn 0;\n}\n\nstatic void python_export_sample_table(struct db_export *dbe,\n\t\t\t\t       struct export_sample *es)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tPyObject *t;\n\n\tt = tuple_new(25);\n\n\ttuple_set_d64(t, 0, es->db_id);\n\ttuple_set_d64(t, 1, es->evsel->db_id);\n\ttuple_set_d64(t, 2, maps__machine(es->al->maps)->db_id);\n\ttuple_set_d64(t, 3, thread__db_id(es->al->thread));\n\ttuple_set_d64(t, 4, es->comm_db_id);\n\ttuple_set_d64(t, 5, es->dso_db_id);\n\ttuple_set_d64(t, 6, es->sym_db_id);\n\ttuple_set_d64(t, 7, es->offset);\n\ttuple_set_d64(t, 8, es->sample->ip);\n\ttuple_set_d64(t, 9, es->sample->time);\n\ttuple_set_s32(t, 10, es->sample->cpu);\n\ttuple_set_d64(t, 11, es->addr_dso_db_id);\n\ttuple_set_d64(t, 12, es->addr_sym_db_id);\n\ttuple_set_d64(t, 13, es->addr_offset);\n\ttuple_set_d64(t, 14, es->sample->addr);\n\ttuple_set_d64(t, 15, es->sample->period);\n\ttuple_set_d64(t, 16, es->sample->weight);\n\ttuple_set_d64(t, 17, es->sample->transaction);\n\ttuple_set_d64(t, 18, es->sample->data_src);\n\ttuple_set_s32(t, 19, es->sample->flags & PERF_BRANCH_MASK);\n\ttuple_set_s32(t, 20, !!(es->sample->flags & PERF_IP_FLAG_IN_TX));\n\ttuple_set_d64(t, 21, es->call_path_id);\n\ttuple_set_d64(t, 22, es->sample->insn_cnt);\n\ttuple_set_d64(t, 23, es->sample->cyc_cnt);\n\ttuple_set_s32(t, 24, es->sample->flags);\n\n\tcall_object(tables->sample_handler, t, \"sample_table\");\n\n\tPy_DECREF(t);\n}\n\nstatic void python_export_synth(struct db_export *dbe, struct export_sample *es)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tPyObject *t;\n\n\tt = tuple_new(3);\n\n\ttuple_set_d64(t, 0, es->db_id);\n\ttuple_set_d64(t, 1, es->evsel->core.attr.config);\n\ttuple_set_bytes(t, 2, es->sample->raw_data, es->sample->raw_size);\n\n\tcall_object(tables->synth_handler, t, \"synth_data\");\n\n\tPy_DECREF(t);\n}\n\nstatic int python_export_sample(struct db_export *dbe,\n\t\t\t\tstruct export_sample *es)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\n\tpython_export_sample_table(dbe, es);\n\n\tif (es->evsel->core.attr.type == PERF_TYPE_SYNTH && tables->synth_handler)\n\t\tpython_export_synth(dbe, es);\n\n\treturn 0;\n}\n\nstatic int python_export_call_path(struct db_export *dbe, struct call_path *cp)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tPyObject *t;\n\tu64 parent_db_id, sym_db_id;\n\n\tparent_db_id = cp->parent ? cp->parent->db_id : 0;\n\tsym_db_id = cp->sym ? *(u64 *)symbol__priv(cp->sym) : 0;\n\n\tt = tuple_new(4);\n\n\ttuple_set_d64(t, 0, cp->db_id);\n\ttuple_set_d64(t, 1, parent_db_id);\n\ttuple_set_d64(t, 2, sym_db_id);\n\ttuple_set_d64(t, 3, cp->ip);\n\n\tcall_object(tables->call_path_handler, t, \"call_path_table\");\n\n\tPy_DECREF(t);\n\n\treturn 0;\n}\n\nstatic int python_export_call_return(struct db_export *dbe,\n\t\t\t\t     struct call_return *cr)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tu64 comm_db_id = cr->comm ? cr->comm->db_id : 0;\n\tPyObject *t;\n\n\tt = tuple_new(14);\n\n\ttuple_set_d64(t, 0, cr->db_id);\n\ttuple_set_d64(t, 1, thread__db_id(cr->thread));\n\ttuple_set_d64(t, 2, comm_db_id);\n\ttuple_set_d64(t, 3, cr->cp->db_id);\n\ttuple_set_d64(t, 4, cr->call_time);\n\ttuple_set_d64(t, 5, cr->return_time);\n\ttuple_set_d64(t, 6, cr->branch_count);\n\ttuple_set_d64(t, 7, cr->call_ref);\n\ttuple_set_d64(t, 8, cr->return_ref);\n\ttuple_set_d64(t, 9, cr->cp->parent->db_id);\n\ttuple_set_s32(t, 10, cr->flags);\n\ttuple_set_d64(t, 11, cr->parent_db_id);\n\ttuple_set_d64(t, 12, cr->insn_count);\n\ttuple_set_d64(t, 13, cr->cyc_count);\n\n\tcall_object(tables->call_return_handler, t, \"call_return_table\");\n\n\tPy_DECREF(t);\n\n\treturn 0;\n}\n\nstatic int python_export_context_switch(struct db_export *dbe, u64 db_id,\n\t\t\t\t\tstruct machine *machine,\n\t\t\t\t\tstruct perf_sample *sample,\n\t\t\t\t\tu64 th_out_id, u64 comm_out_id,\n\t\t\t\t\tu64 th_in_id, u64 comm_in_id, int flags)\n{\n\tstruct tables *tables = container_of(dbe, struct tables, dbe);\n\tPyObject *t;\n\n\tt = tuple_new(9);\n\n\ttuple_set_d64(t, 0, db_id);\n\ttuple_set_d64(t, 1, machine->db_id);\n\ttuple_set_d64(t, 2, sample->time);\n\ttuple_set_s32(t, 3, sample->cpu);\n\ttuple_set_d64(t, 4, th_out_id);\n\ttuple_set_d64(t, 5, comm_out_id);\n\ttuple_set_d64(t, 6, th_in_id);\n\ttuple_set_d64(t, 7, comm_in_id);\n\ttuple_set_s32(t, 8, flags);\n\n\tcall_object(tables->context_switch_handler, t, \"context_switch\");\n\n\tPy_DECREF(t);\n\n\treturn 0;\n}\n\nstatic int python_process_call_return(struct call_return *cr, u64 *parent_db_id,\n\t\t\t\t      void *data)\n{\n\tstruct db_export *dbe = data;\n\n\treturn db_export__call_return(dbe, cr, parent_db_id);\n}\n\nstatic void python_process_general_event(struct perf_sample *sample,\n\t\t\t\t\t struct evsel *evsel,\n\t\t\t\t\t struct addr_location *al,\n\t\t\t\t\t struct addr_location *addr_al)\n{\n\tPyObject *handler, *t, *dict, *callchain;\n\tstatic char handler_name[64];\n\tunsigned n = 0;\n\n\tsnprintf(handler_name, sizeof(handler_name), \"%s\", \"process_event\");\n\n\thandler = get_handler(handler_name);\n\tif (!handler)\n\t\treturn;\n\n\t \n\tt = PyTuple_New(MAX_FIELDS);\n\tif (!t)\n\t\tPy_FatalError(\"couldn't create Python tuple\");\n\n\t \n\tcallchain = python_process_callchain(sample, evsel, al);\n\tdict = get_perf_sample_dict(sample, evsel, al, addr_al, callchain);\n\n\tPyTuple_SetItem(t, n++, dict);\n\tif (_PyTuple_Resize(&t, n) == -1)\n\t\tPy_FatalError(\"error resizing Python tuple\");\n\n\tcall_object(handler, t, handler_name);\n\n\tPy_DECREF(t);\n}\n\nstatic void python_process_event(union perf_event *event,\n\t\t\t\t struct perf_sample *sample,\n\t\t\t\t struct evsel *evsel,\n\t\t\t\t struct addr_location *al,\n\t\t\t\t struct addr_location *addr_al)\n{\n\tstruct tables *tables = &tables_global;\n\n\tscripting_context__update(scripting_context, event, sample, evsel, al, addr_al);\n\n\tswitch (evsel->core.attr.type) {\n\tcase PERF_TYPE_TRACEPOINT:\n\t\tpython_process_tracepoint(sample, evsel, al, addr_al);\n\t\tbreak;\n\t \n\tdefault:\n\t\tif (tables->db_export_mode)\n\t\t\tdb_export__sample(&tables->dbe, event, sample, evsel, al, addr_al);\n\t\telse\n\t\t\tpython_process_general_event(sample, evsel, al, addr_al);\n\t}\n}\n\nstatic void python_process_throttle(union perf_event *event,\n\t\t\t\t    struct perf_sample *sample,\n\t\t\t\t    struct machine *machine)\n{\n\tconst char *handler_name;\n\tPyObject *handler, *t;\n\n\tif (event->header.type == PERF_RECORD_THROTTLE)\n\t\thandler_name = \"throttle\";\n\telse\n\t\thandler_name = \"unthrottle\";\n\thandler = get_handler(handler_name);\n\tif (!handler)\n\t\treturn;\n\n\tt = tuple_new(6);\n\tif (!t)\n\t\treturn;\n\n\ttuple_set_u64(t, 0, event->throttle.time);\n\ttuple_set_u64(t, 1, event->throttle.id);\n\ttuple_set_u64(t, 2, event->throttle.stream_id);\n\ttuple_set_s32(t, 3, sample->cpu);\n\ttuple_set_s32(t, 4, sample->pid);\n\ttuple_set_s32(t, 5, sample->tid);\n\n\tcall_object(handler, t, handler_name);\n\n\tPy_DECREF(t);\n}\n\nstatic void python_do_process_switch(union perf_event *event,\n\t\t\t\t     struct perf_sample *sample,\n\t\t\t\t     struct machine *machine)\n{\n\tconst char *handler_name = \"context_switch\";\n\tbool out = event->header.misc & PERF_RECORD_MISC_SWITCH_OUT;\n\tbool out_preempt = out && (event->header.misc & PERF_RECORD_MISC_SWITCH_OUT_PREEMPT);\n\tpid_t np_pid = -1, np_tid = -1;\n\tPyObject *handler, *t;\n\n\thandler = get_handler(handler_name);\n\tif (!handler)\n\t\treturn;\n\n\tif (event->header.type == PERF_RECORD_SWITCH_CPU_WIDE) {\n\t\tnp_pid = event->context_switch.next_prev_pid;\n\t\tnp_tid = event->context_switch.next_prev_tid;\n\t}\n\n\tt = tuple_new(11);\n\tif (!t)\n\t\treturn;\n\n\ttuple_set_u64(t, 0, sample->time);\n\ttuple_set_s32(t, 1, sample->cpu);\n\ttuple_set_s32(t, 2, sample->pid);\n\ttuple_set_s32(t, 3, sample->tid);\n\ttuple_set_s32(t, 4, np_pid);\n\ttuple_set_s32(t, 5, np_tid);\n\ttuple_set_s32(t, 6, machine->pid);\n\ttuple_set_bool(t, 7, out);\n\ttuple_set_bool(t, 8, out_preempt);\n\ttuple_set_s32(t, 9, sample->machine_pid);\n\ttuple_set_s32(t, 10, sample->vcpu);\n\n\tcall_object(handler, t, handler_name);\n\n\tPy_DECREF(t);\n}\n\nstatic void python_process_switch(union perf_event *event,\n\t\t\t\t  struct perf_sample *sample,\n\t\t\t\t  struct machine *machine)\n{\n\tstruct tables *tables = &tables_global;\n\n\tif (tables->db_export_mode)\n\t\tdb_export__switch(&tables->dbe, event, sample, machine);\n\telse\n\t\tpython_do_process_switch(event, sample, machine);\n}\n\nstatic void python_process_auxtrace_error(struct perf_session *session __maybe_unused,\n\t\t\t\t\t  union perf_event *event)\n{\n\tstruct perf_record_auxtrace_error *e = &event->auxtrace_error;\n\tu8 cpumode = e->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\n\tconst char *handler_name = \"auxtrace_error\";\n\tunsigned long long tm = e->time;\n\tconst char *msg = e->msg;\n\tPyObject *handler, *t;\n\n\thandler = get_handler(handler_name);\n\tif (!handler)\n\t\treturn;\n\n\tif (!e->fmt) {\n\t\ttm = 0;\n\t\tmsg = (const char *)&e->time;\n\t}\n\n\tt = tuple_new(11);\n\n\ttuple_set_u32(t, 0, e->type);\n\ttuple_set_u32(t, 1, e->code);\n\ttuple_set_s32(t, 2, e->cpu);\n\ttuple_set_s32(t, 3, e->pid);\n\ttuple_set_s32(t, 4, e->tid);\n\ttuple_set_u64(t, 5, e->ip);\n\ttuple_set_u64(t, 6, tm);\n\ttuple_set_string(t, 7, msg);\n\ttuple_set_u32(t, 8, cpumode);\n\ttuple_set_s32(t, 9, e->machine_pid);\n\ttuple_set_s32(t, 10, e->vcpu);\n\n\tcall_object(handler, t, handler_name);\n\n\tPy_DECREF(t);\n}\n\nstatic void get_handler_name(char *str, size_t size,\n\t\t\t     struct evsel *evsel)\n{\n\tchar *p = str;\n\n\tscnprintf(str, size, \"stat__%s\", evsel__name(evsel));\n\n\twhile ((p = strchr(p, ':'))) {\n\t\t*p = '_';\n\t\tp++;\n\t}\n}\n\nstatic void\nprocess_stat(struct evsel *counter, struct perf_cpu cpu, int thread, u64 tstamp,\n\t     struct perf_counts_values *count)\n{\n\tPyObject *handler, *t;\n\tstatic char handler_name[256];\n\tint n = 0;\n\n\tt = PyTuple_New(MAX_FIELDS);\n\tif (!t)\n\t\tPy_FatalError(\"couldn't create Python tuple\");\n\n\tget_handler_name(handler_name, sizeof(handler_name),\n\t\t\t counter);\n\n\thandler = get_handler(handler_name);\n\tif (!handler) {\n\t\tpr_debug(\"can't find python handler %s\\n\", handler_name);\n\t\treturn;\n\t}\n\n\tPyTuple_SetItem(t, n++, _PyLong_FromLong(cpu.cpu));\n\tPyTuple_SetItem(t, n++, _PyLong_FromLong(thread));\n\n\ttuple_set_u64(t, n++, tstamp);\n\ttuple_set_u64(t, n++, count->val);\n\ttuple_set_u64(t, n++, count->ena);\n\ttuple_set_u64(t, n++, count->run);\n\n\tif (_PyTuple_Resize(&t, n) == -1)\n\t\tPy_FatalError(\"error resizing Python tuple\");\n\n\tcall_object(handler, t, handler_name);\n\n\tPy_DECREF(t);\n}\n\nstatic void python_process_stat(struct perf_stat_config *config,\n\t\t\t\tstruct evsel *counter, u64 tstamp)\n{\n\tstruct perf_thread_map *threads = counter->core.threads;\n\tstruct perf_cpu_map *cpus = counter->core.cpus;\n\tint cpu, thread;\n\n\tfor (thread = 0; thread < perf_thread_map__nr(threads); thread++) {\n\t\tfor (cpu = 0; cpu < perf_cpu_map__nr(cpus); cpu++) {\n\t\t\tprocess_stat(counter, perf_cpu_map__cpu(cpus, cpu),\n\t\t\t\t     perf_thread_map__pid(threads, thread), tstamp,\n\t\t\t\t     perf_counts(counter->counts, cpu, thread));\n\t\t}\n\t}\n}\n\nstatic void python_process_stat_interval(u64 tstamp)\n{\n\tPyObject *handler, *t;\n\tstatic const char handler_name[] = \"stat__interval\";\n\tint n = 0;\n\n\tt = PyTuple_New(MAX_FIELDS);\n\tif (!t)\n\t\tPy_FatalError(\"couldn't create Python tuple\");\n\n\thandler = get_handler(handler_name);\n\tif (!handler) {\n\t\tpr_debug(\"can't find python handler %s\\n\", handler_name);\n\t\treturn;\n\t}\n\n\ttuple_set_u64(t, n++, tstamp);\n\n\tif (_PyTuple_Resize(&t, n) == -1)\n\t\tPy_FatalError(\"error resizing Python tuple\");\n\n\tcall_object(handler, t, handler_name);\n\n\tPy_DECREF(t);\n}\n\nstatic int perf_script_context_init(void)\n{\n\tPyObject *perf_script_context;\n\tPyObject *perf_trace_context;\n\tPyObject *dict;\n\tint ret;\n\n\tperf_trace_context = PyImport_AddModule(\"perf_trace_context\");\n\tif (!perf_trace_context)\n\t\treturn -1;\n\tdict = PyModule_GetDict(perf_trace_context);\n\tif (!dict)\n\t\treturn -1;\n\n\tperf_script_context = _PyCapsule_New(scripting_context, NULL, NULL);\n\tif (!perf_script_context)\n\t\treturn -1;\n\n\tret = PyDict_SetItemString(dict, \"perf_script_context\", perf_script_context);\n\tif (!ret)\n\t\tret = PyDict_SetItemString(main_dict, \"perf_script_context\", perf_script_context);\n\tPy_DECREF(perf_script_context);\n\treturn ret;\n}\n\nstatic int run_start_sub(void)\n{\n\tmain_module = PyImport_AddModule(\"__main__\");\n\tif (main_module == NULL)\n\t\treturn -1;\n\tPy_INCREF(main_module);\n\n\tmain_dict = PyModule_GetDict(main_module);\n\tif (main_dict == NULL)\n\t\tgoto error;\n\tPy_INCREF(main_dict);\n\n\tif (perf_script_context_init())\n\t\tgoto error;\n\n\ttry_call_object(\"trace_begin\", NULL);\n\n\treturn 0;\n\nerror:\n\tPy_XDECREF(main_dict);\n\tPy_XDECREF(main_module);\n\treturn -1;\n}\n\n#define SET_TABLE_HANDLER_(name, handler_name, table_name) do {\t\t\\\n\ttables->handler_name = get_handler(#table_name);\t\t\\\n\tif (tables->handler_name)\t\t\t\t\t\\\n\t\ttables->dbe.export_ ## name = python_export_ ## name;\t\\\n} while (0)\n\n#define SET_TABLE_HANDLER(name) \\\n\tSET_TABLE_HANDLER_(name, name ## _handler, name ## _table)\n\nstatic void set_table_handlers(struct tables *tables)\n{\n\tconst char *perf_db_export_mode = \"perf_db_export_mode\";\n\tconst char *perf_db_export_calls = \"perf_db_export_calls\";\n\tconst char *perf_db_export_callchains = \"perf_db_export_callchains\";\n\tPyObject *db_export_mode, *db_export_calls, *db_export_callchains;\n\tbool export_calls = false;\n\tbool export_callchains = false;\n\tint ret;\n\n\tmemset(tables, 0, sizeof(struct tables));\n\tif (db_export__init(&tables->dbe))\n\t\tPy_FatalError(\"failed to initialize export\");\n\n\tdb_export_mode = PyDict_GetItemString(main_dict, perf_db_export_mode);\n\tif (!db_export_mode)\n\t\treturn;\n\n\tret = PyObject_IsTrue(db_export_mode);\n\tif (ret == -1)\n\t\thandler_call_die(perf_db_export_mode);\n\tif (!ret)\n\t\treturn;\n\n\t \n\ttables->dbe.crp = NULL;\n\tdb_export_calls = PyDict_GetItemString(main_dict, perf_db_export_calls);\n\tif (db_export_calls) {\n\t\tret = PyObject_IsTrue(db_export_calls);\n\t\tif (ret == -1)\n\t\t\thandler_call_die(perf_db_export_calls);\n\t\texport_calls = !!ret;\n\t}\n\n\tif (export_calls) {\n\t\ttables->dbe.crp =\n\t\t\tcall_return_processor__new(python_process_call_return,\n\t\t\t\t\t\t   &tables->dbe);\n\t\tif (!tables->dbe.crp)\n\t\t\tPy_FatalError(\"failed to create calls processor\");\n\t}\n\n\t \n\ttables->dbe.cpr = NULL;\n\tdb_export_callchains = PyDict_GetItemString(main_dict,\n\t\t\t\t\t\t    perf_db_export_callchains);\n\tif (db_export_callchains) {\n\t\tret = PyObject_IsTrue(db_export_callchains);\n\t\tif (ret == -1)\n\t\t\thandler_call_die(perf_db_export_callchains);\n\t\texport_callchains = !!ret;\n\t}\n\n\tif (export_callchains) {\n\t\t \n\t\tif (tables->dbe.crp)\n\t\t\ttables->dbe.cpr = tables->dbe.crp->cpr;\n\t\telse\n\t\t\ttables->dbe.cpr = call_path_root__new();\n\n\t\tif (!tables->dbe.cpr)\n\t\t\tPy_FatalError(\"failed to create call path root\");\n\t}\n\n\ttables->db_export_mode = true;\n\t \n\tsymbol_conf.priv_size = sizeof(u64);\n\n\tSET_TABLE_HANDLER(evsel);\n\tSET_TABLE_HANDLER(machine);\n\tSET_TABLE_HANDLER(thread);\n\tSET_TABLE_HANDLER(comm);\n\tSET_TABLE_HANDLER(comm_thread);\n\tSET_TABLE_HANDLER(dso);\n\tSET_TABLE_HANDLER(symbol);\n\tSET_TABLE_HANDLER(branch_type);\n\tSET_TABLE_HANDLER(sample);\n\tSET_TABLE_HANDLER(call_path);\n\tSET_TABLE_HANDLER(call_return);\n\tSET_TABLE_HANDLER(context_switch);\n\n\t \n\ttables->synth_handler = get_handler(\"synth_data\");\n}\n\n#if PY_MAJOR_VERSION < 3\nstatic void _free_command_line(const char **command_line, int num)\n{\n\tfree(command_line);\n}\n#else\nstatic void _free_command_line(wchar_t **command_line, int num)\n{\n\tint i;\n\tfor (i = 0; i < num; i++)\n\t\tPyMem_RawFree(command_line[i]);\n\tfree(command_line);\n}\n#endif\n\n\n \nstatic int python_start_script(const char *script, int argc, const char **argv,\n\t\t\t       struct perf_session *session)\n{\n\tstruct tables *tables = &tables_global;\n#if PY_MAJOR_VERSION < 3\n\tconst char **command_line;\n#else\n\twchar_t **command_line;\n#endif\n\t \n\tchar buf[PATH_MAX], name[19] = \"perf_trace_context\";\n\tint i, err = 0;\n\tFILE *fp;\n\n\tscripting_context->session = session;\n#if PY_MAJOR_VERSION < 3\n\tcommand_line = malloc((argc + 1) * sizeof(const char *));\n\tcommand_line[0] = script;\n\tfor (i = 1; i < argc + 1; i++)\n\t\tcommand_line[i] = argv[i - 1];\n\tPyImport_AppendInittab(name, initperf_trace_context);\n#else\n\tcommand_line = malloc((argc + 1) * sizeof(wchar_t *));\n\tcommand_line[0] = Py_DecodeLocale(script, NULL);\n\tfor (i = 1; i < argc + 1; i++)\n\t\tcommand_line[i] = Py_DecodeLocale(argv[i - 1], NULL);\n\tPyImport_AppendInittab(name, PyInit_perf_trace_context);\n#endif\n\tPy_Initialize();\n\n#if PY_MAJOR_VERSION < 3\n\tPySys_SetArgv(argc + 1, (char **)command_line);\n#else\n\tPySys_SetArgv(argc + 1, command_line);\n#endif\n\n\tfp = fopen(script, \"r\");\n\tif (!fp) {\n\t\tsprintf(buf, \"Can't open python script \\\"%s\\\"\", script);\n\t\tperror(buf);\n\t\terr = -1;\n\t\tgoto error;\n\t}\n\n\terr = PyRun_SimpleFile(fp, script);\n\tif (err) {\n\t\tfprintf(stderr, \"Error running python script %s\\n\", script);\n\t\tgoto error;\n\t}\n\n\terr = run_start_sub();\n\tif (err) {\n\t\tfprintf(stderr, \"Error starting python script %s\\n\", script);\n\t\tgoto error;\n\t}\n\n\tset_table_handlers(tables);\n\n\tif (tables->db_export_mode) {\n\t\terr = db_export__branch_types(&tables->dbe);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\t_free_command_line(command_line, argc + 1);\n\n\treturn err;\nerror:\n\tPy_Finalize();\n\t_free_command_line(command_line, argc + 1);\n\n\treturn err;\n}\n\nstatic int python_flush_script(void)\n{\n\treturn 0;\n}\n\n \nstatic int python_stop_script(void)\n{\n\tstruct tables *tables = &tables_global;\n\n\ttry_call_object(\"trace_end\", NULL);\n\n\tdb_export__exit(&tables->dbe);\n\n\tPy_XDECREF(main_dict);\n\tPy_XDECREF(main_module);\n\tPy_Finalize();\n\n\treturn 0;\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nstatic int python_generate_script(struct tep_handle *pevent, const char *outfile)\n{\n\tint i, not_first, count, nr_events;\n\tstruct tep_event **all_events;\n\tstruct tep_event *event = NULL;\n\tstruct tep_format_field *f;\n\tchar fname[PATH_MAX];\n\tFILE *ofp;\n\n\tsprintf(fname, \"%s.py\", outfile);\n\tofp = fopen(fname, \"w\");\n\tif (ofp == NULL) {\n\t\tfprintf(stderr, \"couldn't open %s\\n\", fname);\n\t\treturn -1;\n\t}\n\tfprintf(ofp, \"# perf script event handlers, \"\n\t\t\"generated by perf script -g python\\n\");\n\n\tfprintf(ofp, \"# Licensed under the terms of the GNU GPL\"\n\t\t\" License version 2\\n\\n\");\n\n\tfprintf(ofp, \"# The common_* event handler fields are the most useful \"\n\t\t\"fields common to\\n\");\n\n\tfprintf(ofp, \"# all events.  They don't necessarily correspond to \"\n\t\t\"the 'common_*' fields\\n\");\n\n\tfprintf(ofp, \"# in the format files.  Those fields not available as \"\n\t\t\"handler params can\\n\");\n\n\tfprintf(ofp, \"# be retrieved using Python functions of the form \"\n\t\t\"common_*(context).\\n\");\n\n\tfprintf(ofp, \"# See the perf-script-python Documentation for the list \"\n\t\t\"of available functions.\\n\\n\");\n\n\tfprintf(ofp, \"from __future__ import print_function\\n\\n\");\n\tfprintf(ofp, \"import os\\n\");\n\tfprintf(ofp, \"import sys\\n\\n\");\n\n\tfprintf(ofp, \"sys.path.append(os.environ['PERF_EXEC_PATH'] + \\\\\\n\");\n\tfprintf(ofp, \"\\t'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\\n\");\n\tfprintf(ofp, \"\\nfrom perf_trace_context import *\\n\");\n\tfprintf(ofp, \"from Core import *\\n\\n\\n\");\n\n\tfprintf(ofp, \"def trace_begin():\\n\");\n\tfprintf(ofp, \"\\tprint(\\\"in trace_begin\\\")\\n\\n\");\n\n\tfprintf(ofp, \"def trace_end():\\n\");\n\tfprintf(ofp, \"\\tprint(\\\"in trace_end\\\")\\n\\n\");\n\n\tnr_events = tep_get_events_count(pevent);\n\tall_events = tep_list_events(pevent, TEP_EVENT_SORT_ID);\n\n\tfor (i = 0; all_events && i < nr_events; i++) {\n\t\tevent = all_events[i];\n\t\tfprintf(ofp, \"def %s__%s(\", event->system, event->name);\n\t\tfprintf(ofp, \"event_name, \");\n\t\tfprintf(ofp, \"context, \");\n\t\tfprintf(ofp, \"common_cpu,\\n\");\n\t\tfprintf(ofp, \"\\tcommon_secs, \");\n\t\tfprintf(ofp, \"common_nsecs, \");\n\t\tfprintf(ofp, \"common_pid, \");\n\t\tfprintf(ofp, \"common_comm,\\n\\t\");\n\t\tfprintf(ofp, \"common_callchain, \");\n\n\t\tnot_first = 0;\n\t\tcount = 0;\n\n\t\tfor (f = event->format.fields; f; f = f->next) {\n\t\t\tif (not_first++)\n\t\t\t\tfprintf(ofp, \", \");\n\t\t\tif (++count % 5 == 0)\n\t\t\t\tfprintf(ofp, \"\\n\\t\");\n\n\t\t\tfprintf(ofp, \"%s\", f->name);\n\t\t}\n\t\tif (not_first++)\n\t\t\tfprintf(ofp, \", \");\n\t\tif (++count % 5 == 0)\n\t\t\tfprintf(ofp, \"\\n\\t\\t\");\n\t\tfprintf(ofp, \"perf_sample_dict\");\n\n\t\tfprintf(ofp, \"):\\n\");\n\n\t\tfprintf(ofp, \"\\t\\tprint_header(event_name, common_cpu, \"\n\t\t\t\"common_secs, common_nsecs,\\n\\t\\t\\t\"\n\t\t\t\"common_pid, common_comm)\\n\\n\");\n\n\t\tfprintf(ofp, \"\\t\\tprint(\\\"\");\n\n\t\tnot_first = 0;\n\t\tcount = 0;\n\n\t\tfor (f = event->format.fields; f; f = f->next) {\n\t\t\tif (not_first++)\n\t\t\t\tfprintf(ofp, \", \");\n\t\t\tif (count && count % 3 == 0) {\n\t\t\t\tfprintf(ofp, \"\\\" \\\\\\n\\t\\t\\\"\");\n\t\t\t}\n\t\t\tcount++;\n\n\t\t\tfprintf(ofp, \"%s=\", f->name);\n\t\t\tif (f->flags & TEP_FIELD_IS_STRING ||\n\t\t\t    f->flags & TEP_FIELD_IS_FLAG ||\n\t\t\t    f->flags & TEP_FIELD_IS_ARRAY ||\n\t\t\t    f->flags & TEP_FIELD_IS_SYMBOLIC)\n\t\t\t\tfprintf(ofp, \"%%s\");\n\t\t\telse if (f->flags & TEP_FIELD_IS_SIGNED)\n\t\t\t\tfprintf(ofp, \"%%d\");\n\t\t\telse\n\t\t\t\tfprintf(ofp, \"%%u\");\n\t\t}\n\n\t\tfprintf(ofp, \"\\\" %% \\\\\\n\\t\\t(\");\n\n\t\tnot_first = 0;\n\t\tcount = 0;\n\n\t\tfor (f = event->format.fields; f; f = f->next) {\n\t\t\tif (not_first++)\n\t\t\t\tfprintf(ofp, \", \");\n\n\t\t\tif (++count % 5 == 0)\n\t\t\t\tfprintf(ofp, \"\\n\\t\\t\");\n\n\t\t\tif (f->flags & TEP_FIELD_IS_FLAG) {\n\t\t\t\tif ((count - 1) % 5 != 0) {\n\t\t\t\t\tfprintf(ofp, \"\\n\\t\\t\");\n\t\t\t\t\tcount = 4;\n\t\t\t\t}\n\t\t\t\tfprintf(ofp, \"flag_str(\\\"\");\n\t\t\t\tfprintf(ofp, \"%s__%s\\\", \", event->system,\n\t\t\t\t\tevent->name);\n\t\t\t\tfprintf(ofp, \"\\\"%s\\\", %s)\", f->name,\n\t\t\t\t\tf->name);\n\t\t\t} else if (f->flags & TEP_FIELD_IS_SYMBOLIC) {\n\t\t\t\tif ((count - 1) % 5 != 0) {\n\t\t\t\t\tfprintf(ofp, \"\\n\\t\\t\");\n\t\t\t\t\tcount = 4;\n\t\t\t\t}\n\t\t\t\tfprintf(ofp, \"symbol_str(\\\"\");\n\t\t\t\tfprintf(ofp, \"%s__%s\\\", \", event->system,\n\t\t\t\t\tevent->name);\n\t\t\t\tfprintf(ofp, \"\\\"%s\\\", %s)\", f->name,\n\t\t\t\t\tf->name);\n\t\t\t} else\n\t\t\t\tfprintf(ofp, \"%s\", f->name);\n\t\t}\n\n\t\tfprintf(ofp, \"))\\n\\n\");\n\n\t\tfprintf(ofp, \"\\t\\tprint('Sample: {'+\"\n\t\t\t\"get_dict_as_string(perf_sample_dict['sample'], ', ')+'}')\\n\\n\");\n\n\t\tfprintf(ofp, \"\\t\\tfor node in common_callchain:\");\n\t\tfprintf(ofp, \"\\n\\t\\t\\tif 'sym' in node:\");\n\t\tfprintf(ofp, \"\\n\\t\\t\\t\\tprint(\\\"\\t[%%x] %%s%%s%%s%%s\\\" %% (\");\n\t\tfprintf(ofp, \"\\n\\t\\t\\t\\t\\tnode['ip'], node['sym']['name'],\");\n\t\tfprintf(ofp, \"\\n\\t\\t\\t\\t\\t\\\"+0x{:x}\\\".format(node['sym_off']) if 'sym_off' in node else \\\"\\\",\");\n\t\tfprintf(ofp, \"\\n\\t\\t\\t\\t\\t\\\" ({})\\\".format(node['dso'])  if 'dso' in node else \\\"\\\",\");\n\t\tfprintf(ofp, \"\\n\\t\\t\\t\\t\\t\\\" \\\" + node['sym_srcline'] if 'sym_srcline' in node else \\\"\\\"))\");\n\t\tfprintf(ofp, \"\\n\\t\\t\\telse:\");\n\t\tfprintf(ofp, \"\\n\\t\\t\\t\\tprint(\\\"\\t[%%x]\\\" %% (node['ip']))\\n\\n\");\n\t\tfprintf(ofp, \"\\t\\tprint()\\n\\n\");\n\n\t}\n\n\tfprintf(ofp, \"def trace_unhandled(event_name, context, \"\n\t\t\"event_fields_dict, perf_sample_dict):\\n\");\n\n\tfprintf(ofp, \"\\t\\tprint(get_dict_as_string(event_fields_dict))\\n\");\n\tfprintf(ofp, \"\\t\\tprint('Sample: {'+\"\n\t\t\"get_dict_as_string(perf_sample_dict['sample'], ', ')+'}')\\n\\n\");\n\n\tfprintf(ofp, \"def print_header(\"\n\t\t\"event_name, cpu, secs, nsecs, pid, comm):\\n\"\n\t\t\"\\tprint(\\\"%%-20s %%5u %%05u.%%09u %%8u %%-20s \\\" %% \\\\\\n\\t\"\n\t\t\"(event_name, cpu, secs, nsecs, pid, comm), end=\\\"\\\")\\n\\n\");\n\n\tfprintf(ofp, \"def get_dict_as_string(a_dict, delimiter=' '):\\n\"\n\t\t\"\\treturn delimiter.join\"\n\t\t\"(['%%s=%%s'%%(k,str(v))for k,v in sorted(a_dict.items())])\\n\");\n\n\tfclose(ofp);\n\n\tfprintf(stderr, \"generated Python script: %s\\n\", fname);\n\n\treturn 0;\n}\n#else\nstatic int python_generate_script(struct tep_handle *pevent __maybe_unused,\n\t\t\t\t  const char *outfile __maybe_unused)\n{\n\tfprintf(stderr, \"Generating Python perf-script is not supported.\"\n\t\t\"  Install libtraceevent and rebuild perf to enable it.\\n\"\n\t\t\"For example:\\n  # apt install libtraceevent-dev (ubuntu)\"\n\t\t\"\\n  # yum install libtraceevent-devel (Fedora)\"\n\t\t\"\\n  etc.\\n\");\n\treturn -1;\n}\n#endif\n\nstruct scripting_ops python_scripting_ops = {\n\t.name\t\t\t= \"Python\",\n\t.dirname\t\t= \"python\",\n\t.start_script\t\t= python_start_script,\n\t.flush_script\t\t= python_flush_script,\n\t.stop_script\t\t= python_stop_script,\n\t.process_event\t\t= python_process_event,\n\t.process_switch\t\t= python_process_switch,\n\t.process_auxtrace_error\t= python_process_auxtrace_error,\n\t.process_stat\t\t= python_process_stat,\n\t.process_stat_interval\t= python_process_stat_interval,\n\t.process_throttle\t= python_process_throttle,\n\t.generate_script\t= python_generate_script,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}