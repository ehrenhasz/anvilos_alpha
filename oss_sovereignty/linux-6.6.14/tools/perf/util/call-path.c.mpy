{
  "module_name": "call-path.c",
  "hash_id": "2c46a973677ee436af2878df2be66ca29ac14150e92b7e0ede4af9d4b22267c1",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/call-path.c",
  "human_readable_source": "\n \n\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/zalloc.h>\n#include <stdlib.h>\n\n#include \"call-path.h\"\n\nstatic void call_path__init(struct call_path *cp, struct call_path *parent,\n\t\t\t    struct symbol *sym, u64 ip, bool in_kernel)\n{\n\tcp->parent = parent;\n\tcp->sym = sym;\n\tcp->ip = sym ? 0 : ip;\n\tcp->db_id = 0;\n\tcp->in_kernel = in_kernel;\n\tRB_CLEAR_NODE(&cp->rb_node);\n\tcp->children = RB_ROOT;\n}\n\nstruct call_path_root *call_path_root__new(void)\n{\n\tstruct call_path_root *cpr;\n\n\tcpr = zalloc(sizeof(struct call_path_root));\n\tif (!cpr)\n\t\treturn NULL;\n\tcall_path__init(&cpr->call_path, NULL, NULL, 0, false);\n\tINIT_LIST_HEAD(&cpr->blocks);\n\treturn cpr;\n}\n\nvoid call_path_root__free(struct call_path_root *cpr)\n{\n\tstruct call_path_block *pos, *n;\n\n\tlist_for_each_entry_safe(pos, n, &cpr->blocks, node) {\n\t\tlist_del_init(&pos->node);\n\t\tfree(pos);\n\t}\n\tfree(cpr);\n}\n\nstatic struct call_path *call_path__new(struct call_path_root *cpr,\n\t\t\t\t\tstruct call_path *parent,\n\t\t\t\t\tstruct symbol *sym, u64 ip,\n\t\t\t\t\tbool in_kernel)\n{\n\tstruct call_path_block *cpb;\n\tstruct call_path *cp;\n\tsize_t n;\n\n\tif (cpr->next < cpr->sz) {\n\t\tcpb = list_last_entry(&cpr->blocks, struct call_path_block,\n\t\t\t\t      node);\n\t} else {\n\t\tcpb = zalloc(sizeof(struct call_path_block));\n\t\tif (!cpb)\n\t\t\treturn NULL;\n\t\tlist_add_tail(&cpb->node, &cpr->blocks);\n\t\tcpr->sz += CALL_PATH_BLOCK_SIZE;\n\t}\n\n\tn = cpr->next++ & CALL_PATH_BLOCK_MASK;\n\tcp = &cpb->cp[n];\n\n\tcall_path__init(cp, parent, sym, ip, in_kernel);\n\n\treturn cp;\n}\n\nstruct call_path *call_path__findnew(struct call_path_root *cpr,\n\t\t\t\t     struct call_path *parent,\n\t\t\t\t     struct symbol *sym, u64 ip, u64 ks)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *node_parent = NULL;\n\tstruct call_path *cp;\n\tbool in_kernel = ip >= ks;\n\n\tif (sym)\n\t\tip = 0;\n\n\tif (!parent)\n\t\treturn call_path__new(cpr, parent, sym, ip, in_kernel);\n\n\tp = &parent->children.rb_node;\n\twhile (*p != NULL) {\n\t\tnode_parent = *p;\n\t\tcp = rb_entry(node_parent, struct call_path, rb_node);\n\n\t\tif (cp->sym == sym && cp->ip == ip)\n\t\t\treturn cp;\n\n\t\tif (sym < cp->sym || (sym == cp->sym && ip < cp->ip))\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tcp = call_path__new(cpr, parent, sym, ip, in_kernel);\n\tif (!cp)\n\t\treturn NULL;\n\n\trb_link_node(&cp->rb_node, node_parent, p);\n\trb_insert_color(&cp->rb_node, &parent->children);\n\n\treturn cp;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}