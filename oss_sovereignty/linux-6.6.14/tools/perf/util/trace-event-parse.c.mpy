{
  "module_name": "trace-event-parse.c",
  "hash_id": "e48c19f517756f4ae34f581b4cd11f389269076bea348d31353ee34428b4abc1",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/trace-event-parse.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"debug.h\"\n#include \"trace-event.h\"\n\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <traceevent/event-parse.h>\n\nstatic int get_common_field(struct scripting_context *context,\n\t\t\t    int *offset, int *size, const char *type)\n{\n\tstruct tep_handle *pevent = context->pevent;\n\tstruct tep_event *event;\n\tstruct tep_format_field *field;\n\n\tif (!*size) {\n\n\t\tevent = tep_get_first_event(pevent);\n\t\tif (!event)\n\t\t\treturn 0;\n\n\t\tfield = tep_find_common_field(event, type);\n\t\tif (!field)\n\t\t\treturn 0;\n\t\t*offset = field->offset;\n\t\t*size = field->size;\n\t}\n\n\treturn tep_read_number(pevent, context->event_data + *offset, *size);\n}\n\nint common_lock_depth(struct scripting_context *context)\n{\n\tstatic int offset;\n\tstatic int size;\n\tint ret;\n\n\tret = get_common_field(context, &size, &offset,\n\t\t\t       \"common_lock_depth\");\n\tif (ret < 0)\n\t\treturn -1;\n\n\treturn ret;\n}\n\nint common_flags(struct scripting_context *context)\n{\n\tstatic int offset;\n\tstatic int size;\n\tint ret;\n\n\tret = get_common_field(context, &size, &offset,\n\t\t\t       \"common_flags\");\n\tif (ret < 0)\n\t\treturn -1;\n\n\treturn ret;\n}\n\nint common_pc(struct scripting_context *context)\n{\n\tstatic int offset;\n\tstatic int size;\n\tint ret;\n\n\tret = get_common_field(context, &size, &offset,\n\t\t\t       \"common_preempt_count\");\n\tif (ret < 0)\n\t\treturn -1;\n\n\treturn ret;\n}\n\nunsigned long long\nraw_field_value(struct tep_event *event, const char *name, void *data)\n{\n\tstruct tep_format_field *field;\n\tunsigned long long val;\n\n\tfield = tep_find_any_field(event, name);\n\tif (!field)\n\t\treturn 0ULL;\n\n\ttep_read_number_field(field, data, &val);\n\n\treturn val;\n}\n\nunsigned long long read_size(struct tep_event *event, void *ptr, int size)\n{\n\treturn tep_read_number(event->tep, ptr, size);\n}\n\nvoid event_format__fprintf(struct tep_event *event,\n\t\t\t   int cpu, void *data, int size, FILE *fp)\n{\n\tstruct tep_record record;\n\tstruct trace_seq s;\n\n\tmemset(&record, 0, sizeof(record));\n\trecord.cpu = cpu;\n\trecord.size = size;\n\trecord.data = data;\n\n\ttrace_seq_init(&s);\n\ttep_print_event(event->tep, &s, &record, \"%s\", TEP_PRINT_INFO);\n\ttrace_seq_do_fprintf(&s, fp);\n\ttrace_seq_destroy(&s);\n}\n\nvoid event_format__print(struct tep_event *event,\n\t\t\t int cpu, void *data, int size)\n{\n\treturn event_format__fprintf(event, cpu, data, size, stdout);\n}\n\nvoid parse_ftrace_printk(struct tep_handle *pevent,\n\t\t\t char *file, unsigned int size __maybe_unused)\n{\n\tunsigned long long addr;\n\tchar *printk;\n\tchar *line;\n\tchar *next = NULL;\n\tchar *addr_str;\n\tchar *fmt = NULL;\n\n\tline = strtok_r(file, \"\\n\", &next);\n\twhile (line) {\n\t\taddr_str = strtok_r(line, \":\", &fmt);\n\t\tif (!addr_str) {\n\t\t\tpr_warning(\"printk format with empty entry\");\n\t\t\tbreak;\n\t\t}\n\t\taddr = strtoull(addr_str, NULL, 16);\n\t\t \n\t\tprintk = strdup(fmt+1);\n\t\tline = strtok_r(NULL, \"\\n\", &next);\n\t\ttep_register_print_string(pevent, printk, addr);\n\t\tfree(printk);\n\t}\n}\n\nvoid parse_saved_cmdline(struct tep_handle *pevent,\n\t\t\t char *file, unsigned int size __maybe_unused)\n{\n\tchar comm[17];  \n\tchar *line;\n\tchar *next = NULL;\n\tint pid;\n\n\tline = strtok_r(file, \"\\n\", &next);\n\twhile (line) {\n\t\tif (sscanf(line, \"%d %16s\", &pid, comm) == 2)\n\t\t\ttep_register_comm(pevent, comm, pid);\n\t\tline = strtok_r(NULL, \"\\n\", &next);\n\t}\n}\n\nint parse_ftrace_file(struct tep_handle *pevent, char *buf, unsigned long size)\n{\n\treturn tep_parse_event(pevent, buf, size, \"ftrace\");\n}\n\nint parse_event_file(struct tep_handle *pevent,\n\t\t     char *buf, unsigned long size, char *sys)\n{\n\treturn tep_parse_event(pevent, buf, size, sys);\n}\n\nstruct flag {\n\tconst char *name;\n\tunsigned long long value;\n};\n\nstatic const struct flag flags[] = {\n\t{ \"HI_SOFTIRQ\", 0 },\n\t{ \"TIMER_SOFTIRQ\", 1 },\n\t{ \"NET_TX_SOFTIRQ\", 2 },\n\t{ \"NET_RX_SOFTIRQ\", 3 },\n\t{ \"BLOCK_SOFTIRQ\", 4 },\n\t{ \"IRQ_POLL_SOFTIRQ\", 5 },\n\t{ \"TASKLET_SOFTIRQ\", 6 },\n\t{ \"SCHED_SOFTIRQ\", 7 },\n\t{ \"HRTIMER_SOFTIRQ\", 8 },\n\t{ \"RCU_SOFTIRQ\", 9 },\n\n\t{ \"HRTIMER_NORESTART\", 0 },\n\t{ \"HRTIMER_RESTART\", 1 },\n};\n\nunsigned long long eval_flag(const char *flag)\n{\n\tint i;\n\n\t \n\tif (isdigit(flag[0]))\n\t\treturn strtoull(flag, NULL, 0);\n\n\tfor (i = 0; i < (int)(ARRAY_SIZE(flags)); i++)\n\t\tif (strcmp(flags[i].name, flag) == 0)\n\t\t\treturn flags[i].value;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}