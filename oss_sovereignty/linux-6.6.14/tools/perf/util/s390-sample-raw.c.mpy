{
  "module_name": "s390-sample-raw.c",
  "hash_id": "a82f111ff560bb5f8e38218c9a2f9381e94dee877b00e7bbe470984a5ab6898a",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/s390-sample-raw.c",
  "human_readable_source": "\n \n\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <inttypes.h>\n\n#include <sys/stat.h>\n#include <linux/compiler.h>\n#include <asm/byteorder.h>\n\n#include \"debug.h\"\n#include \"session.h\"\n#include \"evlist.h\"\n#include \"color.h\"\n#include \"sample-raw.h\"\n#include \"s390-cpumcf-kernel.h\"\n#include \"util/pmu.h\"\n#include \"util/sample.h\"\n\nstatic size_t ctrset_size(struct cf_ctrset_entry *set)\n{\n\treturn sizeof(*set) + set->ctr * sizeof(u64);\n}\n\nstatic bool ctrset_valid(struct cf_ctrset_entry *set)\n{\n\treturn set->def == S390_CPUMCF_DIAG_DEF;\n}\n\n \nstatic bool s390_cpumcfdg_testctr(struct perf_sample *sample)\n{\n\tsize_t len = sample->raw_size, offset = 0;\n\tunsigned char *buf = sample->raw_data;\n\tstruct cf_trailer_entry *te;\n\tstruct cf_ctrset_entry *cep, ce;\n\n\tif (!len)\n\t\treturn false;\n\twhile (offset < len) {\n\t\tcep = (struct cf_ctrset_entry *)(buf + offset);\n\t\tce.def = be16_to_cpu(cep->def);\n\t\tce.set = be16_to_cpu(cep->set);\n\t\tce.ctr = be16_to_cpu(cep->ctr);\n\t\tce.res1 = be16_to_cpu(cep->res1);\n\n\t\tif (!ctrset_valid(&ce) || offset + ctrset_size(&ce) > len) {\n\t\t\t \n\t\t\tif (len - offset - sizeof(*te) == 4)\n\t\t\t\tbreak;\n\t\t\tpr_err(\"Invalid counter set entry at %zd\\n\", offset);\n\t\t\treturn false;\n\t\t}\n\t\toffset += ctrset_size(&ce);\n\t}\n\treturn true;\n}\n\n \nstatic void s390_cpumcfdg_dumptrail(const char *color, size_t offset,\n\t\t\t\t    struct cf_trailer_entry *tep)\n{\n\tstruct cf_trailer_entry  te;\n\n\tte.flags = be64_to_cpu(tep->flags);\n\tte.cfvn = be16_to_cpu(tep->cfvn);\n\tte.csvn = be16_to_cpu(tep->csvn);\n\tte.cpu_speed = be32_to_cpu(tep->cpu_speed);\n\tte.timestamp = be64_to_cpu(tep->timestamp);\n\tte.progusage1 = be64_to_cpu(tep->progusage1);\n\tte.progusage2 = be64_to_cpu(tep->progusage2);\n\tte.progusage3 = be64_to_cpu(tep->progusage3);\n\tte.tod_base = be64_to_cpu(tep->tod_base);\n\tte.mach_type = be16_to_cpu(tep->mach_type);\n\tte.res1 = be16_to_cpu(tep->res1);\n\tte.res2 = be32_to_cpu(tep->res2);\n\n\tcolor_fprintf(stdout, color, \"    [%#08zx] Trailer:%c%c%c%c%c\"\n\t\t      \" Cfvn:%d Csvn:%d Speed:%d TOD:%#llx\\n\",\n\t\t      offset, te.clock_base ? 'T' : ' ',\n\t\t      te.speed ? 'S' : ' ', te.mtda ? 'M' : ' ',\n\t\t      te.caca ? 'C' : ' ', te.lcda ? 'L' : ' ',\n\t\t      te.cfvn, te.csvn, te.cpu_speed, te.timestamp);\n\tcolor_fprintf(stdout, color, \"\\t\\t1:%lx 2:%lx 3:%lx TOD-Base:%#llx\"\n\t\t      \" Type:%x\\n\\n\",\n\t\t      te.progusage1, te.progusage2, te.progusage3,\n\t\t      te.tod_base, te.mach_type);\n}\n\n \nstatic int get_counterset_start(int setnr)\n{\n\tswitch (setnr) {\n\tcase CPUMF_CTR_SET_BASIC:\t\t \n\t\treturn 0;\n\tcase CPUMF_CTR_SET_USER:\t\t \n\t\treturn 32;\n\tcase CPUMF_CTR_SET_CRYPTO:\t\t \n\t\treturn 64;\n\tcase CPUMF_CTR_SET_EXT:\t\t\t \n\t\treturn 128;\n\tcase CPUMF_CTR_SET_MT_DIAG:\t\t \n\t\treturn 448;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstruct get_counter_name_data {\n\tint wanted;\n\tchar *result;\n};\n\nstatic int get_counter_name_callback(void *vdata, struct pmu_event_info *info)\n{\n\tstruct get_counter_name_data *data = vdata;\n\tint rc, event_nr;\n\tconst char *event_str;\n\n\tif (info->str == NULL)\n\t\treturn 0;\n\n\tevent_str = strstr(info->str, \"event=\");\n\tif (!event_str)\n\t\treturn 0;\n\n\trc = sscanf(event_str, \"event=%x\", &event_nr);\n\tif (rc == 1 && event_nr == data->wanted) {\n\t\tdata->result = strdup(info->name);\n\t\treturn 1;  \n\t}\n\treturn 0;\n}\n\n \nstatic char *get_counter_name(int set, int nr, struct perf_pmu *pmu)\n{\n\tstruct get_counter_name_data data = {\n\t\t.wanted = get_counterset_start(set) + nr,\n\t\t.result = NULL,\n\t};\n\n\tif (!pmu)\n\t\treturn NULL;\n\n\tperf_pmu__for_each_event(pmu,   true,\n\t\t\t\t &data, get_counter_name_callback);\n\treturn data.result;\n}\n\nstatic void s390_cpumcfdg_dump(struct perf_pmu *pmu, struct perf_sample *sample)\n{\n\tsize_t i, len = sample->raw_size, offset = 0;\n\tunsigned char *buf = sample->raw_data;\n\tconst char *color = PERF_COLOR_BLUE;\n\tstruct cf_ctrset_entry *cep, ce;\n\tu64 *p;\n\n\twhile (offset < len) {\n\t\tcep = (struct cf_ctrset_entry *)(buf + offset);\n\n\t\tce.def = be16_to_cpu(cep->def);\n\t\tce.set = be16_to_cpu(cep->set);\n\t\tce.ctr = be16_to_cpu(cep->ctr);\n\t\tce.res1 = be16_to_cpu(cep->res1);\n\n\t\tif (!ctrset_valid(&ce)) {\t \n\t\t\ts390_cpumcfdg_dumptrail(color, offset,\n\t\t\t\t\t\t(struct cf_trailer_entry *)cep);\n\t\t\treturn;\n\t\t}\n\n\t\tcolor_fprintf(stdout, color, \"    [%#08zx] Counterset:%d\"\n\t\t\t      \" Counters:%d\\n\", offset, ce.set, ce.ctr);\n\t\tfor (i = 0, p = (u64 *)(cep + 1); i < ce.ctr; ++i, ++p) {\n\t\t\tchar *ev_name = get_counter_name(ce.set, i, pmu);\n\n\t\t\tcolor_fprintf(stdout, color,\n\t\t\t\t      \"\\tCounter:%03d %s Value:%#018lx\\n\", i,\n\t\t\t\t      ev_name ?: \"<unknown>\", be64_to_cpu(*p));\n\t\t\tfree(ev_name);\n\t\t}\n\t\toffset += ctrset_size(&ce);\n\t}\n}\n\n \nvoid evlist__s390_sample_raw(struct evlist *evlist, union perf_event *event, struct perf_sample *sample)\n{\n\tstruct evsel *evsel;\n\n\tif (event->header.type != PERF_RECORD_SAMPLE)\n\t\treturn;\n\n\tevsel = evlist__event2evsel(evlist, event);\n\tif (evsel == NULL ||\n\t    evsel->core.attr.config != PERF_EVENT_CPUM_CF_DIAG)\n\t\treturn;\n\n\t \n\tif (!s390_cpumcfdg_testctr(sample)) {\n\t\tpr_err(\"Invalid counter set data encountered\\n\");\n\t\treturn;\n\t}\n\ts390_cpumcfdg_dump(evsel->pmu, sample);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}