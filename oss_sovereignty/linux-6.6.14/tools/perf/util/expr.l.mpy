{
  "module_name": "expr.l",
  "hash_id": "e56287ee732521a666dcc1393846bf1fe8a8ed95870fa20d3823188414af91db",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/expr.l",
  "human_readable_source": "%option prefix=\"expr_\"\n%option reentrant\n%option bison-bridge\n\n%{\n#include <linux/compiler.h>\n#include \"expr.h\"\n#include \"expr-bison.h\"\n#include <math.h>\n\nchar *expr_get_text(yyscan_t yyscanner);\nYYSTYPE *expr_get_lval(yyscan_t yyscanner);\n\nstatic double __value(YYSTYPE *yylval, char *str, int token)\n{\n\tdouble num;\n\n\terrno = 0;\n\tnum = strtod(str, NULL);\n\tif (errno)\n\t\treturn EXPR_ERROR;\n\n\tyylval->num = num;\n\treturn token;\n}\n\nstatic int value(yyscan_t scanner)\n{\n\tYYSTYPE *yylval = expr_get_lval(scanner);\n\tchar *text = expr_get_text(scanner);\n\n\treturn __value(yylval, text, NUMBER);\n}\n\n/*\n * Allow @ instead of / to be able to specify pmu/event/ without\n * conflicts with normal division.\n */\nstatic char *normalize(char *str, int runtime)\n{\n\tchar *ret = str;\n\tchar *dst = str;\n\n\twhile (*str) {\n\t\tif (*str == '\\\\') {\n\t\t\t*dst++ = *++str;\n\t\t\tif (!*str)\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (*str == '?') {\n\t\t\tchar *paramval;\n\t\t\tint i = 0;\n\t\t\tint size = asprintf(&paramval, \"%d\", runtime);\n\n\t\t\tif (size < 0)\n\t\t\t\t*dst++ = '0';\n\t\t\telse {\n\t\t\t\twhile (i < size)\n\t\t\t\t\t*dst++ = paramval[i++];\n\t\t\t\tfree(paramval);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\t*dst++ = *str;\n\t\tstr++;\n\t}\n\n\t*dst = 0x0;\n\treturn ret;\n}\n\nstatic int str(yyscan_t scanner, int token, int runtime)\n{\n\tYYSTYPE *yylval = expr_get_lval(scanner);\n\tchar *text = expr_get_text(scanner);\n\n\tyylval->str = normalize(strdup(text), runtime);\n\tif (!yylval->str)\n\t\treturn EXPR_ERROR;\n\n\tyylval->str = normalize(yylval->str, runtime);\n\treturn token;\n}\n\nstatic int literal(yyscan_t scanner, const struct expr_scanner_ctx *sctx)\n{\n\tYYSTYPE *yylval = expr_get_lval(scanner);\n\n\tyylval->num = expr__get_literal(expr_get_text(scanner), sctx);\n\tif (isnan(yylval->num)) {\n\t\tif (!sctx->is_test)\n\t\t\treturn EXPR_ERROR;\n\t\tyylval->num = 1;\n\t}\n\treturn LITERAL;\n}\n%}\n\nnumber\t\t([0-9]+\\.?[0-9]*|[0-9]*\\.?[0-9]+)(e-?[0-9]+)?\n\nsch\t\t[-,=]\nspec\t\t\\\\{sch}\nsym\t\t[0-9a-zA-Z_\\.:@?]+\nsymbol\t\t({spec}|{sym})+\nliteral\t\t#[0-9a-zA-Z_\\.\\-]+\n\n%%\n\tstruct expr_scanner_ctx *sctx = expr_get_extra(yyscanner);\n\nd_ratio\t\t{ return D_RATIO; }\nmax\t\t{ return MAX; }\nmin\t\t{ return MIN; }\nif\t\t{ return IF; }\nelse\t\t{ return ELSE; }\nsource_count\t{ return SOURCE_COUNT; }\nhas_event\t{ return HAS_EVENT; }\nstrcmp_cpuid_str\t{ return STRCMP_CPUID_STR; }\n{literal}\t{ return literal(yyscanner, sctx); }\n{number}\t{ return value(yyscanner); }\n{symbol}\t{ return str(yyscanner, ID, sctx->runtime); }\n\"|\"\t\t{ return '|'; }\n\"^\"\t\t{ return '^'; }\n\"&\"\t\t{ return '&'; }\n\"<\"\t\t{ return '<'; }\n\">\"\t\t{ return '>'; }\n\"-\"\t\t{ return '-'; }\n\"+\"\t\t{ return '+'; }\n\"*\"\t\t{ return '*'; }\n\"/\"\t\t{ return '/'; }\n\"%\"\t\t{ return '%'; }\n\"(\"\t\t{ return '('; }\n\")\"\t\t{ return ')'; }\n\",\"\t\t{ return ','; }\n.\t\t{ }\n%%\n\nint expr_wrap(void *scanner __maybe_unused)\n{\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}