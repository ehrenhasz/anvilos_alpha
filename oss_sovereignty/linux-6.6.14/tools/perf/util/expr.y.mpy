{
  "module_name": "expr.y",
  "hash_id": "4cfe1a978edd2e5f45868abc64c5c66f7c28bef365226d5076340c24ad035e30",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/expr.y",
  "human_readable_source": "/* Simple expression parser */\n%{\n#define YYDEBUG 1\n#include <assert.h>\n#include <math.h>\n#include <stdlib.h>\n#include \"util/debug.h\"\n#define IN_EXPR_Y 1\n#include \"expr.h\"\n#include \"expr-bison.h\"\nint expr_lex(YYSTYPE * yylval_param , void *yyscanner);\n%}\n\n%define api.pure full\n\n%parse-param { double *final_val }\n%parse-param { struct expr_parse_ctx *ctx }\n%parse-param { bool compute_ids }\n%parse-param {void *scanner}\n%lex-param {void* scanner}\n\n%union {\n\tdouble\t num;\n\tchar\t*str;\n\tstruct ids {\n\t\t/*\n\t\t * When creating ids, holds the working set of event ids. NULL\n\t\t * implies the set is empty.\n\t\t */\n\t\tstruct hashmap *ids;\n\t\t/*\n\t\t * The metric value. When not creating ids this is the value\n\t\t * read from a counter, a constant or some computed value. When\n\t\t * creating ids the value is either a constant or BOTTOM. NAN is\n\t\t * used as the special BOTTOM value, representing a \"set of all\n\t\t * values\" case.\n\t\t */\n\t\tdouble val;\n\t} ids;\n}\n\n%token ID NUMBER MIN MAX IF ELSE LITERAL D_RATIO SOURCE_COUNT HAS_EVENT STRCMP_CPUID_STR EXPR_ERROR\n%left MIN MAX IF\n%left '|'\n%left '^'\n%left '&'\n%left '<' '>'\n%left '-' '+'\n%left '*' '/' '%'\n%left NEG NOT\n%type <num> NUMBER LITERAL\n%type <str> ID\n%destructor { free ($$); } <str>\n%type <ids> expr if_expr\n%destructor { ids__free($$.ids); } <ids>\n\n%{\nstatic void expr_error(double *final_val __maybe_unused,\n\t\t       struct expr_parse_ctx *ctx __maybe_unused,\n\t\t       bool compute_ids __maybe_unused,\n\t\t       void *scanner __maybe_unused,\n\t\t       const char *s)\n{\n\tpr_debug(\"%s\\n\", s);\n}\n\n/*\n * During compute ids, the special \"bottom\" value uses NAN to represent the set\n * of all values. NAN is selected as it isn't a useful constant value.\n */\n#define BOTTOM NAN\n\n/* During computing ids, does val represent a constant (non-BOTTOM) value? */\nstatic bool is_const(double val)\n{\n\treturn isfinite(val);\n}\n\nstatic struct ids union_expr(struct ids ids1, struct ids ids2)\n{\n\tstruct ids result = {\n\t\t.val = BOTTOM,\n\t\t.ids = ids__union(ids1.ids, ids2.ids),\n\t};\n\treturn result;\n}\n\nstatic struct ids handle_id(struct expr_parse_ctx *ctx, char *id,\n\t\t\t    bool compute_ids, bool source_count)\n{\n\tstruct ids result;\n\n\tif (!compute_ids) {\n\t\t/*\n\t\t * Compute the event's value from ID. If the ID isn't known then\n\t\t * it isn't used to compute the formula so set to NAN.\n\t\t */\n\t\tstruct expr_id_data *data;\n\n\t\tresult.val = NAN;\n\t\tif (expr__resolve_id(ctx, id, &data) == 0) {\n\t\t\tresult.val = source_count\n\t\t\t\t? expr_id_data__source_count(data)\n\t\t\t\t: expr_id_data__value(data);\n\t\t}\n\t\tresult.ids = NULL;\n\t\tfree(id);\n\t} else {\n\t\t/*\n\t\t * Set the value to BOTTOM to show that any value is possible\n\t\t * when the event is computed. Create a set of just the ID.\n\t\t */\n\t\tresult.val = BOTTOM;\n\t\tresult.ids = ids__new();\n\t\tif (!result.ids || ids__insert(result.ids, id)) {\n\t\t\tpr_err(\"Error creating IDs for '%s'\", id);\n\t\t\tfree(id);\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n * If we're not computing ids or $1 and $3 are constants, compute the new\n * constant value using OP. Its invariant that there are no ids.  If computing\n * ids for non-constants union the set of IDs that must be computed.\n */\n#define BINARY_OP(RESULT, OP, LHS, RHS)\t\t\t\t\t\\\n\tif (!compute_ids || (is_const(LHS.val) && is_const(RHS.val))) { \\\n\t\tassert(LHS.ids == NULL);\t\t\t\t\\\n\t\tassert(RHS.ids == NULL);\t\t\t\t\\\n\t\tif (isnan(LHS.val) || isnan(RHS.val)) {\t\t\t\\\n\t\t\tRESULT.val = NAN;\t\t\t\t\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\tRESULT.val = LHS.val OP RHS.val;\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tRESULT.ids = NULL;\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t        RESULT = union_expr(LHS, RHS);\t\t\t\t\\\n\t}\n\n%}\n%%\n\nstart: if_expr\n{\n\tif (compute_ids)\n\t\tctx->ids = ids__union($1.ids, ctx->ids);\n\n\tif (final_val)\n\t\t*final_val = $1.val;\n}\n;\n\nif_expr: expr IF expr ELSE if_expr\n{\n\tif (fpclassify($3.val) == FP_ZERO) {\n\t\t/*\n\t\t * The IF expression evaluated to 0 so treat as false, take the\n\t\t * ELSE and discard everything else.\n\t\t */\n\t\t$$.val = $5.val;\n\t\t$$.ids = $5.ids;\n\t\tids__free($1.ids);\n\t\tids__free($3.ids);\n\t} else if (!compute_ids || is_const($3.val)) {\n\t\t/*\n\t\t * If ids aren't computed then treat the expression as true. If\n\t\t * ids are being computed and the IF expr is a non-zero\n\t\t * constant, then also evaluate the true case.\n\t\t */\n\t\t$$.val = $1.val;\n\t\t$$.ids = $1.ids;\n\t\tids__free($3.ids);\n\t\tids__free($5.ids);\n\t} else if ($1.val == $5.val) {\n\t\t/*\n\t\t * LHS == RHS, so both are an identical constant. No need to\n\t\t * evaluate any events.\n\t\t */\n\t\t$$.val = $1.val;\n\t\t$$.ids = NULL;\n\t\tids__free($1.ids);\n\t\tids__free($3.ids);\n\t\tids__free($5.ids);\n\t} else {\n\t\t/*\n\t\t * Value is either the LHS or RHS and we need the IF expression\n\t\t * to compute it.\n\t\t */\n\t\t$$ = union_expr($1, union_expr($3, $5));\n\t}\n}\n| expr\n;\n\nexpr: NUMBER\n{\n\t$$.val = $1;\n\t$$.ids = NULL;\n}\n| ID\t\t\t\t{ $$ = handle_id(ctx, $1, compute_ids, /*source_count=*/false); }\n| SOURCE_COUNT '(' ID ')'\t{ $$ = handle_id(ctx, $3, compute_ids, /*source_count=*/true); }\n| HAS_EVENT '(' ID ')'\n{\n\t$$.val = expr__has_event(ctx, compute_ids, $3);\n\t$$.ids = NULL;\n\tfree($3);\n}\n| STRCMP_CPUID_STR '(' ID ')'\n{\n\t$$.val = expr__strcmp_cpuid_str(ctx, compute_ids, $3);\n\t$$.ids = NULL;\n\tfree($3);\n}\n| expr '|' expr\n{\n\tif (is_const($1.val) && is_const($3.val)) {\n\t\tassert($1.ids == NULL);\n\t\tassert($3.ids == NULL);\n\t\t$$.ids = NULL;\n\t\t$$.val = (fpclassify($1.val) == FP_ZERO && fpclassify($3.val) == FP_ZERO) ? 0 : 1;\n\t} else if (is_const($1.val)) {\n\t\tassert($1.ids == NULL);\n\t\tif (fpclassify($1.val) == FP_ZERO) {\n\t\t\t$$ = $3;\n\t\t} else {\n\t\t\t$$.val = 1;\n\t\t\t$$.ids = NULL;\n\t\t\tids__free($3.ids);\n\t\t}\n\t} else if (is_const($3.val)) {\n\t\tassert($3.ids == NULL);\n\t\tif (fpclassify($3.val) == FP_ZERO) {\n\t\t\t$$ = $1;\n\t\t} else {\n\t\t\t$$.val = 1;\n\t\t\t$$.ids = NULL;\n\t\t\tids__free($1.ids);\n\t\t}\n\t} else {\n\t\t$$ = union_expr($1, $3);\n\t}\n}\n| expr '&' expr\n{\n\tif (is_const($1.val) && is_const($3.val)) {\n\t\tassert($1.ids == NULL);\n\t\tassert($3.ids == NULL);\n\t\t$$.val = (fpclassify($1.val) != FP_ZERO && fpclassify($3.val) != FP_ZERO) ? 1 : 0;\n\t\t$$.ids = NULL;\n\t} else if (is_const($1.val)) {\n\t\tassert($1.ids == NULL);\n\t\tif (fpclassify($1.val) != FP_ZERO) {\n\t\t\t$$ = $3;\n\t\t} else {\n\t\t\t$$.val = 0;\n\t\t\t$$.ids = NULL;\n\t\t\tids__free($3.ids);\n\t\t}\n\t} else if (is_const($3.val)) {\n\t\tassert($3.ids == NULL);\n\t\tif (fpclassify($3.val) != FP_ZERO) {\n\t\t\t$$ = $1;\n\t\t} else {\n\t\t\t$$.val = 0;\n\t\t\t$$.ids = NULL;\n\t\t\tids__free($1.ids);\n\t\t}\n\t} else {\n\t\t$$ = union_expr($1, $3);\n\t}\n}\n| expr '^' expr\n{\n\tif (is_const($1.val) && is_const($3.val)) {\n\t\tassert($1.ids == NULL);\n\t\tassert($3.ids == NULL);\n\t\t$$.val = (fpclassify($1.val) == FP_ZERO) != (fpclassify($3.val) == FP_ZERO) ? 1 : 0;\n\t\t$$.ids = NULL;\n\t} else {\n\t\t$$ = union_expr($1, $3);\n\t}\n}\n| expr '<' expr { BINARY_OP($$, <, $1, $3); }\n| expr '>' expr { BINARY_OP($$, >, $1, $3); }\n| expr '+' expr { BINARY_OP($$, +, $1, $3); }\n| expr '-' expr { BINARY_OP($$, -, $1, $3); }\n| expr '*' expr { BINARY_OP($$, *, $1, $3); }\n| expr '/' expr\n{\n\tif (fpclassify($3.val) == FP_ZERO) {\n\t\tpr_debug(\"division by zero\\n\");\n\t\tassert($3.ids == NULL);\n\t\tif (compute_ids)\n\t\t\tids__free($1.ids);\n\t\t$$.val = NAN;\n\t\t$$.ids = NULL;\n\t} else if (!compute_ids || (is_const($1.val) && is_const($3.val))) {\n\t\tassert($1.ids == NULL);\n\t\tassert($3.ids == NULL);\n\t\t$$.val = $1.val / $3.val;\n\t\t$$.ids = NULL;\n\t} else {\n\t\t/* LHS and/or RHS need computing from event IDs so union. */\n\t\t$$ = union_expr($1, $3);\n\t}\n}\n| expr '%' expr\n{\n\tif (fpclassify($3.val) == FP_ZERO) {\n\t\tpr_debug(\"division by zero\\n\");\n\t\tYYABORT;\n\t} else if (!compute_ids || (is_const($1.val) && is_const($3.val))) {\n\t\tassert($1.ids == NULL);\n\t\tassert($3.ids == NULL);\n\t\t$$.val = (long)$1.val % (long)$3.val;\n\t\t$$.ids = NULL;\n\t} else {\n\t\t/* LHS and/or RHS need computing from event IDs so union. */\n\t\t$$ = union_expr($1, $3);\n\t}\n}\n| D_RATIO '(' expr ',' expr ')'\n{\n\tif (fpclassify($5.val) == FP_ZERO) {\n\t\t/*\n\t\t * Division by constant zero always yields zero and no events\n\t\t * are necessary.\n\t\t */\n\t\tassert($5.ids == NULL);\n\t\t$$.val = 0.0;\n\t\t$$.ids = NULL;\n\t\tids__free($3.ids);\n\t} else if (!compute_ids || (is_const($3.val) && is_const($5.val))) {\n\t\tassert($3.ids == NULL);\n\t\tassert($5.ids == NULL);\n\t\t$$.val = $3.val / $5.val;\n\t\t$$.ids = NULL;\n\t} else {\n\t\t/* LHS and/or RHS need computing from event IDs so union. */\n\t\t$$ = union_expr($3, $5);\n\t}\n}\n| '-' expr %prec NEG\n{\n\t$$.val = -$2.val;\n\t$$.ids = $2.ids;\n}\n| '(' if_expr ')'\n{\n\t$$ = $2;\n}\n| MIN '(' expr ',' expr ')'\n{\n\tif (!compute_ids) {\n\t\t$$.val = $3.val < $5.val ? $3.val : $5.val;\n\t\t$$.ids = NULL;\n\t} else {\n\t\t$$ = union_expr($3, $5);\n\t}\n}\n| MAX '(' expr ',' expr ')'\n{\n\tif (!compute_ids) {\n\t\t$$.val = $3.val > $5.val ? $3.val : $5.val;\n\t\t$$.ids = NULL;\n\t} else {\n\t\t$$ = union_expr($3, $5);\n\t}\n}\n| LITERAL\n{\n\t$$.val = $1;\n\t$$.ids = NULL;\n}\n;\n\n%%\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}