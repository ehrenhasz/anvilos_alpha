{
  "module_name": "maps.h",
  "hash_id": "d10ffc80004e9f83d73910f1d8d0cd69d4c25542bd40319ff2d6268733bc06d7",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/maps.h",
  "human_readable_source": " \n#ifndef __PERF_MAPS_H\n#define __PERF_MAPS_H\n\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <linux/types.h>\n#include \"rwsem.h\"\n#include <internal/rc_check.h>\n\nstruct ref_reloc_sym;\nstruct machine;\nstruct map;\nstruct maps;\nstruct thread;\n\nstruct map_rb_node {\n\tstruct rb_node rb_node;\n\tstruct map *map;\n};\n\nstruct map_rb_node *maps__first(struct maps *maps);\nstruct map_rb_node *map_rb_node__next(struct map_rb_node *node);\nstruct map_rb_node *maps__find_node(struct maps *maps, struct map *map);\nstruct map *maps__find(struct maps *maps, u64 addr);\n\n#define maps__for_each_entry(maps, map) \\\n\tfor (map = maps__first(maps); map; map = map_rb_node__next(map))\n\n#define maps__for_each_entry_safe(maps, map, next) \\\n\tfor (map = maps__first(maps), next = map_rb_node__next(map); map; \\\n\t     map = next, next = map_rb_node__next(map))\n\nDECLARE_RC_STRUCT(maps) {\n\tstruct rb_root      entries;\n\tstruct rw_semaphore lock;\n\tstruct machine\t *machine;\n\tstruct map\t *last_search_by_name;\n\tstruct map\t **maps_by_name;\n\trefcount_t\t refcnt;\n\tunsigned int\t nr_maps;\n\tunsigned int\t nr_maps_allocated;\n#ifdef HAVE_LIBUNWIND_SUPPORT\n\tvoid\t\t\t\t*addr_space;\n\tconst struct unwind_libunwind_ops *unwind_libunwind_ops;\n#endif\n};\n\n#define KMAP_NAME_LEN 256\n\nstruct kmap {\n\tstruct ref_reloc_sym *ref_reloc_sym;\n\tstruct maps\t     *kmaps;\n\tchar\t\t     name[KMAP_NAME_LEN];\n};\n\nstruct maps *maps__new(struct machine *machine);\nbool maps__empty(struct maps *maps);\nint maps__clone(struct thread *thread, struct maps *parent);\n\nstruct maps *maps__get(struct maps *maps);\nvoid maps__put(struct maps *maps);\n\nstatic inline void __maps__zput(struct maps **map)\n{\n\tmaps__put(*map);\n\t*map = NULL;\n}\n\n#define maps__zput(map) __maps__zput(&map)\n\nstatic inline struct rb_root *maps__entries(struct maps *maps)\n{\n\treturn &RC_CHK_ACCESS(maps)->entries;\n}\n\nstatic inline struct machine *maps__machine(struct maps *maps)\n{\n\treturn RC_CHK_ACCESS(maps)->machine;\n}\n\nstatic inline struct rw_semaphore *maps__lock(struct maps *maps)\n{\n\treturn &RC_CHK_ACCESS(maps)->lock;\n}\n\nstatic inline struct map **maps__maps_by_name(struct maps *maps)\n{\n\treturn RC_CHK_ACCESS(maps)->maps_by_name;\n}\n\nstatic inline unsigned int maps__nr_maps(const struct maps *maps)\n{\n\treturn RC_CHK_ACCESS(maps)->nr_maps;\n}\n\nstatic inline refcount_t *maps__refcnt(struct maps *maps)\n{\n\treturn &RC_CHK_ACCESS(maps)->refcnt;\n}\n\n#ifdef HAVE_LIBUNWIND_SUPPORT\nstatic inline void *maps__addr_space(struct maps *maps)\n{\n\treturn RC_CHK_ACCESS(maps)->addr_space;\n}\n\nstatic inline const struct unwind_libunwind_ops *maps__unwind_libunwind_ops(const struct maps *maps)\n{\n\treturn RC_CHK_ACCESS(maps)->unwind_libunwind_ops;\n}\n#endif\n\nsize_t maps__fprintf(struct maps *maps, FILE *fp);\n\nint maps__insert(struct maps *maps, struct map *map);\nvoid maps__remove(struct maps *maps, struct map *map);\n\nstruct symbol *maps__find_symbol(struct maps *maps, u64 addr, struct map **mapp);\nstruct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name, struct map **mapp);\n\nstruct addr_map_symbol;\n\nint maps__find_ams(struct maps *maps, struct addr_map_symbol *ams);\n\nint maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp);\n\nstruct map *maps__find_by_name(struct maps *maps, const char *name);\n\nint maps__merge_in(struct maps *kmaps, struct map *new_map);\n\nvoid __maps__sort_by_name(struct maps *maps);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}