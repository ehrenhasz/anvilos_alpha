{
  "module_name": "config.c",
  "hash_id": "edf0f0baa4804d920deb77368df9116725c74098bcdbfbcc151f2d6c7f8bd53a",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/config.c",
  "human_readable_source": "\n \n#include <errno.h>\n#include <sys/param.h>\n#include \"cache.h\"\n#include \"callchain.h\"\n#include <subcmd/exec-cmd.h>\n#include \"util/event.h\"   \n#include \"util/hist.h\"   \n#include \"util/stat.h\"   \n#include \"util/evsel.h\"   \n#include \"util/srcline.h\"   \n#include \"build-id.h\"\n#include \"debug.h\"\n#include \"config.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <linux/ctype.h>\n\n#define MAXNAME (256)\n\n#define DEBUG_CACHE_DIR \".debug\"\n\n\nchar buildid_dir[MAXPATHLEN];  \n\nstatic FILE *config_file;\nstatic const char *config_file_name;\nstatic int config_linenr;\nstatic int config_file_eof;\nstatic struct perf_config_set *config_set;\n\nconst char *config_exclusive_filename;\n\nstatic int get_next_char(void)\n{\n\tint c;\n\tFILE *f;\n\n\tc = '\\n';\n\tif ((f = config_file) != NULL) {\n\t\tc = fgetc(f);\n\t\tif (c == '\\r') {\n\t\t\t \n\t\t\tc = fgetc(f);\n\t\t\tif (c != '\\n') {\n\t\t\t\tungetc(c, f);\n\t\t\t\tc = '\\r';\n\t\t\t}\n\t\t}\n\t\tif (c == '\\n')\n\t\t\tconfig_linenr++;\n\t\tif (c == EOF) {\n\t\t\tconfig_file_eof = 1;\n\t\t\tc = '\\n';\n\t\t}\n\t}\n\treturn c;\n}\n\nstatic char *parse_value(void)\n{\n\tstatic char value[1024];\n\tint quote = 0, comment = 0, space = 0;\n\tsize_t len = 0;\n\n\tfor (;;) {\n\t\tint c = get_next_char();\n\n\t\tif (len >= sizeof(value) - 1)\n\t\t\treturn NULL;\n\t\tif (c == '\\n') {\n\t\t\tif (quote)\n\t\t\t\treturn NULL;\n\t\t\tvalue[len] = 0;\n\t\t\treturn value;\n\t\t}\n\t\tif (comment)\n\t\t\tcontinue;\n\t\tif (isspace(c) && !quote) {\n\t\t\tspace = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!quote) {\n\t\t\tif (c == ';' || c == '#') {\n\t\t\t\tcomment = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (space) {\n\t\t\tif (len)\n\t\t\t\tvalue[len++] = ' ';\n\t\t\tspace = 0;\n\t\t}\n\t\tif (c == '\\\\') {\n\t\t\tc = get_next_char();\n\t\t\tswitch (c) {\n\t\t\tcase '\\n':\n\t\t\t\tcontinue;\n\t\t\tcase 't':\n\t\t\t\tc = '\\t';\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tc = '\\b';\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = '\\n';\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase '\\\\': case '\"':\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tdefault:\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tvalue[len++] = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == '\"') {\n\t\t\tquote = 1-quote;\n\t\t\tcontinue;\n\t\t}\n\t\tvalue[len++] = c;\n\t}\n}\n\nstatic inline int iskeychar(int c)\n{\n\treturn isalnum(c) || c == '-' || c == '_';\n}\n\nstatic int get_value(config_fn_t fn, void *data, char *name, unsigned int len)\n{\n\tint c;\n\tchar *value;\n\n\t \n\tfor (;;) {\n\t\tc = get_next_char();\n\t\tif (config_file_eof)\n\t\t\tbreak;\n\t\tif (!iskeychar(c))\n\t\t\tbreak;\n\t\tname[len++] = c;\n\t\tif (len >= MAXNAME)\n\t\t\treturn -1;\n\t}\n\tname[len] = 0;\n\twhile (c == ' ' || c == '\\t')\n\t\tc = get_next_char();\n\n\tvalue = NULL;\n\tif (c != '\\n') {\n\t\tif (c != '=')\n\t\t\treturn -1;\n\t\tvalue = parse_value();\n\t\tif (!value)\n\t\t\treturn -1;\n\t}\n\treturn fn(name, value, data);\n}\n\nstatic int get_extended_base_var(char *name, int baselen, int c)\n{\n\tdo {\n\t\tif (c == '\\n')\n\t\t\treturn -1;\n\t\tc = get_next_char();\n\t} while (isspace(c));\n\n\t \n\tif (c != '\"')\n\t\treturn -1;\n\tname[baselen++] = '.';\n\n\tfor (;;) {\n\t\tint ch = get_next_char();\n\n\t\tif (ch == '\\n')\n\t\t\treturn -1;\n\t\tif (ch == '\"')\n\t\t\tbreak;\n\t\tif (ch == '\\\\') {\n\t\t\tch = get_next_char();\n\t\t\tif (ch == '\\n')\n\t\t\t\treturn -1;\n\t\t}\n\t\tname[baselen++] = ch;\n\t\tif (baselen > MAXNAME / 2)\n\t\t\treturn -1;\n\t}\n\n\t \n\tif (get_next_char() != ']')\n\t\treturn -1;\n\treturn baselen;\n}\n\nstatic int get_base_var(char *name)\n{\n\tint baselen = 0;\n\n\tfor (;;) {\n\t\tint c = get_next_char();\n\t\tif (config_file_eof)\n\t\t\treturn -1;\n\t\tif (c == ']')\n\t\t\treturn baselen;\n\t\tif (isspace(c))\n\t\t\treturn get_extended_base_var(name, baselen, c);\n\t\tif (!iskeychar(c) && c != '.')\n\t\t\treturn -1;\n\t\tif (baselen > MAXNAME / 2)\n\t\t\treturn -1;\n\t\tname[baselen++] = tolower(c);\n\t}\n}\n\nstatic int perf_parse_file(config_fn_t fn, void *data)\n{\n\tint comment = 0;\n\tint baselen = 0;\n\tstatic char var[MAXNAME];\n\n\t \n\tstatic const unsigned char *utf8_bom = (unsigned char *) \"\\xef\\xbb\\xbf\";\n\tconst unsigned char *bomptr = utf8_bom;\n\n\tfor (;;) {\n\t\tint line, c = get_next_char();\n\n\t\tif (bomptr && *bomptr) {\n\t\t\t \n\t\t\tif ((unsigned char) c == *bomptr) {\n\t\t\t\tbomptr++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (bomptr != utf8_bom)\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tbomptr = NULL;\n\t\t\t}\n\t\t}\n\t\tif (c == '\\n') {\n\t\t\tif (config_file_eof)\n\t\t\t\treturn 0;\n\t\t\tcomment = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (comment || isspace(c))\n\t\t\tcontinue;\n\t\tif (c == '#' || c == ';') {\n\t\t\tcomment = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == '[') {\n\t\t\tbaselen = get_base_var(var);\n\t\t\tif (baselen <= 0)\n\t\t\t\tbreak;\n\t\t\tvar[baselen++] = '.';\n\t\t\tvar[baselen] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!isalpha(c))\n\t\t\tbreak;\n\t\tvar[baselen] = tolower(c);\n\n\t\t \n\t\tline = config_linenr;\n\t\tif (get_value(fn, data, var, baselen+1) < 0) {\n\t\t\tconfig_linenr = line;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpr_err(\"bad config file line %d in %s\\n\", config_linenr, config_file_name);\n\treturn -1;\n}\n\nstatic int parse_unit_factor(const char *end, unsigned long *val)\n{\n\tif (!*end)\n\t\treturn 1;\n\telse if (!strcasecmp(end, \"k\")) {\n\t\t*val *= 1024;\n\t\treturn 1;\n\t}\n\telse if (!strcasecmp(end, \"m\")) {\n\t\t*val *= 1024 * 1024;\n\t\treturn 1;\n\t}\n\telse if (!strcasecmp(end, \"g\")) {\n\t\t*val *= 1024 * 1024 * 1024;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int perf_parse_llong(const char *value, long long *ret)\n{\n\tif (value && *value) {\n\t\tchar *end;\n\t\tlong long val = strtoll(value, &end, 0);\n\t\tunsigned long factor = 1;\n\n\t\tif (!parse_unit_factor(end, &factor))\n\t\t\treturn 0;\n\t\t*ret = val * factor;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int perf_parse_long(const char *value, long *ret)\n{\n\tif (value && *value) {\n\t\tchar *end;\n\t\tlong val = strtol(value, &end, 0);\n\t\tunsigned long factor = 1;\n\t\tif (!parse_unit_factor(end, &factor))\n\t\t\treturn 0;\n\t\t*ret = val * factor;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void bad_config(const char *name)\n{\n\tif (config_file_name)\n\t\tpr_warning(\"bad config value for '%s' in %s, ignoring...\\n\", name, config_file_name);\n\telse\n\t\tpr_warning(\"bad config value for '%s', ignoring...\\n\", name);\n}\n\nint perf_config_u64(u64 *dest, const char *name, const char *value)\n{\n\tlong long ret = 0;\n\n\tif (!perf_parse_llong(value, &ret)) {\n\t\tbad_config(name);\n\t\treturn -1;\n\t}\n\n\t*dest = ret;\n\treturn 0;\n}\n\nint perf_config_int(int *dest, const char *name, const char *value)\n{\n\tlong ret = 0;\n\tif (!perf_parse_long(value, &ret)) {\n\t\tbad_config(name);\n\t\treturn -1;\n\t}\n\t*dest = ret;\n\treturn 0;\n}\n\nint perf_config_u8(u8 *dest, const char *name, const char *value)\n{\n\tlong ret = 0;\n\n\tif (!perf_parse_long(value, &ret)) {\n\t\tbad_config(name);\n\t\treturn -1;\n\t}\n\t*dest = ret;\n\treturn 0;\n}\n\nstatic int perf_config_bool_or_int(const char *name, const char *value, int *is_bool)\n{\n\tint ret;\n\n\t*is_bool = 1;\n\tif (!value)\n\t\treturn 1;\n\tif (!*value)\n\t\treturn 0;\n\tif (!strcasecmp(value, \"true\") || !strcasecmp(value, \"yes\") || !strcasecmp(value, \"on\"))\n\t\treturn 1;\n\tif (!strcasecmp(value, \"false\") || !strcasecmp(value, \"no\") || !strcasecmp(value, \"off\"))\n\t\treturn 0;\n\t*is_bool = 0;\n\treturn perf_config_int(&ret, name, value) < 0 ? -1 : ret;\n}\n\nint perf_config_bool(const char *name, const char *value)\n{\n\tint discard;\n\treturn !!perf_config_bool_or_int(name, value, &discard);\n}\n\nstatic const char *perf_config_dirname(const char *name, const char *value)\n{\n\tif (!name)\n\t\treturn NULL;\n\treturn value;\n}\n\nstatic int perf_buildid_config(const char *var, const char *value)\n{\n\t \n\tif (!strcmp(var, \"buildid.dir\")) {\n\t\tconst char *dir = perf_config_dirname(var, value);\n\n\t\tif (!dir) {\n\t\t\tpr_err(\"Invalid buildid directory!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrncpy(buildid_dir, dir, MAXPATHLEN-1);\n\t\tbuildid_dir[MAXPATHLEN-1] = '\\0';\n\t}\n\n\treturn 0;\n}\n\nstatic int perf_default_core_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"core.proc-map-timeout\"))\n\t\tproc_map_timeout = strtoul(value, NULL, 10);\n\n\tif (!strcmp(var, \"core.addr2line-timeout\"))\n\t\taddr2line_timeout_ms = strtoul(value, NULL, 10);\n\n\t \n\treturn 0;\n}\n\nstatic int perf_ui_config(const char *var, const char *value)\n{\n\t \n\tif (!strcmp(var, \"ui.show-headers\"))\n\t\tsymbol_conf.show_hist_headers = perf_config_bool(var, value);\n\n\treturn 0;\n}\n\nstatic int perf_stat_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"stat.big-num\"))\n\t\tperf_stat__set_big_num(perf_config_bool(var, value));\n\n\tif (!strcmp(var, \"stat.no-csv-summary\"))\n\t\tperf_stat__set_no_csv_summary(perf_config_bool(var, value));\n\n\tif (!strcmp(var, \"stat.bpf-counter-events\"))\n\t\tevsel__bpf_counter_events = strdup(value);\n\n\t \n\treturn 0;\n}\n\nint perf_default_config(const char *var, const char *value,\n\t\t\tvoid *dummy __maybe_unused)\n{\n\tif (strstarts(var, \"core.\"))\n\t\treturn perf_default_core_config(var, value);\n\n\tif (strstarts(var, \"hist.\"))\n\t\treturn perf_hist_config(var, value);\n\n\tif (strstarts(var, \"ui.\"))\n\t\treturn perf_ui_config(var, value);\n\n\tif (strstarts(var, \"call-graph.\"))\n\t\treturn perf_callchain_config(var, value);\n\n\tif (strstarts(var, \"buildid.\"))\n\t\treturn perf_buildid_config(var, value);\n\n\tif (strstarts(var, \"stat.\"))\n\t\treturn perf_stat_config(var, value);\n\n\t \n\treturn 0;\n}\n\nstatic int perf_config_from_file(config_fn_t fn, const char *filename, void *data)\n{\n\tint ret;\n\tFILE *f = fopen(filename, \"r\");\n\n\tret = -1;\n\tif (f) {\n\t\tconfig_file = f;\n\t\tconfig_file_name = filename;\n\t\tconfig_linenr = 1;\n\t\tconfig_file_eof = 0;\n\t\tret = perf_parse_file(fn, data);\n\t\tfclose(f);\n\t\tconfig_file_name = NULL;\n\t}\n\treturn ret;\n}\n\nconst char *perf_etc_perfconfig(void)\n{\n\tstatic const char *system_wide;\n\tif (!system_wide)\n\t\tsystem_wide = system_path(ETC_PERFCONFIG);\n\treturn system_wide;\n}\n\nstatic int perf_env_bool(const char *k, int def)\n{\n\tconst char *v = getenv(k);\n\treturn v ? perf_config_bool(k, v) : def;\n}\n\nint perf_config_system(void)\n{\n\treturn !perf_env_bool(\"PERF_CONFIG_NOSYSTEM\", 0);\n}\n\nint perf_config_global(void)\n{\n\treturn !perf_env_bool(\"PERF_CONFIG_NOGLOBAL\", 0);\n}\n\nstatic char *home_perfconfig(void)\n{\n\tconst char *home = NULL;\n\tchar *config;\n\tstruct stat st;\n\tchar path[PATH_MAX];\n\n\thome = getenv(\"HOME\");\n\n\t \n\tif (!home || !*home || !perf_config_global())\n\t\treturn NULL;\n\n\tconfig = strdup(mkpath(path, sizeof(path), \"%s/.perfconfig\", home));\n\tif (config == NULL) {\n\t\tpr_warning(\"Not enough memory to process %s/.perfconfig, ignoring it.\\n\", home);\n\t\treturn NULL;\n\t}\n\n\tif (stat(config, &st) < 0)\n\t\tgoto out_free;\n\n\tif (st.st_uid && (st.st_uid != geteuid())) {\n\t\tpr_warning(\"File %s not owned by current user or root, ignoring it.\\n\", config);\n\t\tgoto out_free;\n\t}\n\n\tif (st.st_size)\n\t\treturn config;\n\nout_free:\n\tfree(config);\n\treturn NULL;\n}\n\nconst char *perf_home_perfconfig(void)\n{\n\tstatic const char *config;\n\tstatic bool failed;\n\n\tif (failed || config)\n\t\treturn config;\n\n\tconfig = home_perfconfig();\n\tif (!config)\n\t\tfailed = true;\n\n\treturn config;\n}\n\nstatic struct perf_config_section *find_section(struct list_head *sections,\n\t\t\t\t\t\tconst char *section_name)\n{\n\tstruct perf_config_section *section;\n\n\tlist_for_each_entry(section, sections, node)\n\t\tif (!strcmp(section->name, section_name))\n\t\t\treturn section;\n\n\treturn NULL;\n}\n\nstatic struct perf_config_item *find_config_item(const char *name,\n\t\t\t\t\t\t struct perf_config_section *section)\n{\n\tstruct perf_config_item *item;\n\n\tlist_for_each_entry(item, &section->items, node)\n\t\tif (!strcmp(item->name, name))\n\t\t\treturn item;\n\n\treturn NULL;\n}\n\nstatic struct perf_config_section *add_section(struct list_head *sections,\n\t\t\t\t\t       const char *section_name)\n{\n\tstruct perf_config_section *section = zalloc(sizeof(*section));\n\n\tif (!section)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&section->items);\n\tsection->name = strdup(section_name);\n\tif (!section->name) {\n\t\tpr_debug(\"%s: strdup failed\\n\", __func__);\n\t\tfree(section);\n\t\treturn NULL;\n\t}\n\n\tlist_add_tail(&section->node, sections);\n\treturn section;\n}\n\nstatic struct perf_config_item *add_config_item(struct perf_config_section *section,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct perf_config_item *item = zalloc(sizeof(*item));\n\n\tif (!item)\n\t\treturn NULL;\n\n\titem->name = strdup(name);\n\tif (!item->name) {\n\t\tpr_debug(\"%s: strdup failed\\n\", __func__);\n\t\tfree(item);\n\t\treturn NULL;\n\t}\n\n\tlist_add_tail(&item->node, &section->items);\n\treturn item;\n}\n\nstatic int set_value(struct perf_config_item *item, const char *value)\n{\n\tchar *val = strdup(value);\n\n\tif (!val)\n\t\treturn -1;\n\n\tzfree(&item->value);\n\titem->value = val;\n\treturn 0;\n}\n\nstatic int collect_config(const char *var, const char *value,\n\t\t\t  void *perf_config_set)\n{\n\tint ret = -1;\n\tchar *ptr, *key;\n\tchar *section_name, *name;\n\tstruct perf_config_section *section = NULL;\n\tstruct perf_config_item *item = NULL;\n\tstruct perf_config_set *set = perf_config_set;\n\tstruct list_head *sections;\n\n\tif (set == NULL)\n\t\treturn -1;\n\n\tsections = &set->sections;\n\tkey = ptr = strdup(var);\n\tif (!key) {\n\t\tpr_debug(\"%s: strdup failed\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tsection_name = strsep(&ptr, \".\");\n\tname = ptr;\n\tif (name == NULL || value == NULL)\n\t\tgoto out_free;\n\n\tsection = find_section(sections, section_name);\n\tif (!section) {\n\t\tsection = add_section(sections, section_name);\n\t\tif (!section)\n\t\t\tgoto out_free;\n\t}\n\n\titem = find_config_item(name, section);\n\tif (!item) {\n\t\titem = add_config_item(section, name);\n\t\tif (!item)\n\t\t\tgoto out_free;\n\t}\n\n\t \n\tif (strcmp(config_file_name, perf_etc_perfconfig()) == 0) {\n\t\tsection->from_system_config = true;\n\t\titem->from_system_config = true;\n\t} else {\n\t\tsection->from_system_config = false;\n\t\titem->from_system_config = false;\n\t}\n\n\tret = set_value(item, value);\n\nout_free:\n\tfree(key);\n\treturn ret;\n}\n\nint perf_config_set__collect(struct perf_config_set *set, const char *file_name,\n\t\t\t     const char *var, const char *value)\n{\n\tconfig_file_name = file_name;\n\treturn collect_config(var, value, set);\n}\n\nstatic int perf_config_set__init(struct perf_config_set *set)\n{\n\tint ret = -1;\n\n\t \n\tif (config_exclusive_filename)\n\t\treturn perf_config_from_file(collect_config, config_exclusive_filename, set);\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\n\t\tif (perf_config_from_file(collect_config, perf_etc_perfconfig(), set) < 0)\n\t\t\tgoto out;\n\t}\n\tif (perf_config_global() && perf_home_perfconfig()) {\n\t\tif (perf_config_from_file(collect_config, perf_home_perfconfig(), set) < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nstruct perf_config_set *perf_config_set__new(void)\n{\n\tstruct perf_config_set *set = zalloc(sizeof(*set));\n\n\tif (set) {\n\t\tINIT_LIST_HEAD(&set->sections);\n\t\tperf_config_set__init(set);\n\t}\n\n\treturn set;\n}\n\nstruct perf_config_set *perf_config_set__load_file(const char *file)\n{\n\tstruct perf_config_set *set = zalloc(sizeof(*set));\n\n\tif (set) {\n\t\tINIT_LIST_HEAD(&set->sections);\n\t\tperf_config_from_file(collect_config, file, set);\n\t}\n\n\treturn set;\n}\n\nstatic int perf_config__init(void)\n{\n\tif (config_set == NULL)\n\t\tconfig_set = perf_config_set__new();\n\n\treturn config_set == NULL;\n}\n\nint perf_config_set(struct perf_config_set *set,\n\t\t    config_fn_t fn, void *data)\n{\n\tint ret = 0;\n\tchar key[BUFSIZ];\n\tstruct perf_config_section *section;\n\tstruct perf_config_item *item;\n\n\tperf_config_set__for_each_entry(set, section, item) {\n\t\tchar *value = item->value;\n\n\t\tif (value) {\n\t\t\tscnprintf(key, sizeof(key), \"%s.%s\",\n\t\t\t\t  section->name, item->name);\n\t\t\tret = fn(key, value, data);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"Error in the given config file: wrong config key-value pair %s=%s\\n\",\n\t\t\t\t       key, value);\n\t\t\t\t \n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\nint perf_config(config_fn_t fn, void *data)\n{\n\tif (config_set == NULL && perf_config__init())\n\t\treturn -1;\n\n\treturn perf_config_set(config_set, fn, data);\n}\n\nvoid perf_config__exit(void)\n{\n\tperf_config_set__delete(config_set);\n\tconfig_set = NULL;\n}\n\nvoid perf_config__refresh(void)\n{\n\tperf_config__exit();\n\tperf_config__init();\n}\n\nstatic void perf_config_item__delete(struct perf_config_item *item)\n{\n\tzfree(&item->name);\n\tzfree(&item->value);\n\tfree(item);\n}\n\nstatic void perf_config_section__purge(struct perf_config_section *section)\n{\n\tstruct perf_config_item *item, *tmp;\n\n\tlist_for_each_entry_safe(item, tmp, &section->items, node) {\n\t\tlist_del_init(&item->node);\n\t\tperf_config_item__delete(item);\n\t}\n}\n\nstatic void perf_config_section__delete(struct perf_config_section *section)\n{\n\tperf_config_section__purge(section);\n\tzfree(&section->name);\n\tfree(section);\n}\n\nstatic void perf_config_set__purge(struct perf_config_set *set)\n{\n\tstruct perf_config_section *section, *tmp;\n\n\tlist_for_each_entry_safe(section, tmp, &set->sections, node) {\n\t\tlist_del_init(&section->node);\n\t\tperf_config_section__delete(section);\n\t}\n}\n\nvoid perf_config_set__delete(struct perf_config_set *set)\n{\n\tif (set == NULL)\n\t\treturn;\n\n\tperf_config_set__purge(set);\n\tfree(set);\n}\n\n \nint config_error_nonbool(const char *var)\n{\n\tpr_err(\"Missing value for '%s'\", var);\n\treturn -1;\n}\n\nvoid set_buildid_dir(const char *dir)\n{\n\tif (dir)\n\t\tscnprintf(buildid_dir, MAXPATHLEN, \"%s\", dir);\n\n\t \n\tif (buildid_dir[0] == '\\0') {\n\t\tchar *home = getenv(\"HOME\");\n\n\t\tif (home) {\n\t\t\tsnprintf(buildid_dir, MAXPATHLEN, \"%s/%s\",\n\t\t\t\t home, DEBUG_CACHE_DIR);\n\t\t} else {\n\t\t\tstrncpy(buildid_dir, DEBUG_CACHE_DIR, MAXPATHLEN-1);\n\t\t}\n\t\tbuildid_dir[MAXPATHLEN-1] = '\\0';\n\t}\n\t \n\tsetenv(\"PERF_BUILDID_DIR\", buildid_dir, 1);\n}\n\nstruct perf_config_scan_data {\n\tconst char *name;\n\tconst char *fmt;\n\tva_list args;\n\tint ret;\n};\n\nstatic int perf_config_scan_cb(const char *var, const char *value, void *data)\n{\n\tstruct perf_config_scan_data *d = data;\n\n\tif (!strcmp(var, d->name))\n\t\td->ret = vsscanf(value, d->fmt, d->args);\n\n\treturn 0;\n}\n\nint perf_config_scan(const char *name, const char *fmt, ...)\n{\n\tstruct perf_config_scan_data d = {\n\t\t.name = name,\n\t\t.fmt = fmt,\n\t};\n\n\tva_start(d.args, fmt);\n\tperf_config(perf_config_scan_cb, &d);\n\tva_end(d.args);\n\n\treturn d.ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}