{
  "module_name": "strbuf.c",
  "hash_id": "bbba24fd68f4860dc61a26f9b20a08ab918c3de64e439a70a5fc5d57114d59ff",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/strbuf.c",
  "human_readable_source": "\n#include \"cache.h\"\n#include \"debug.h\"\n#include \"strbuf.h\"\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n \nchar strbuf_slopbuf[1];\n\nint strbuf_init(struct strbuf *sb, ssize_t hint)\n{\n\tsb->alloc = sb->len = 0;\n\tsb->buf = strbuf_slopbuf;\n\tif (hint)\n\t\treturn strbuf_grow(sb, hint);\n\treturn 0;\n}\n\nvoid strbuf_release(struct strbuf *sb)\n{\n\tif (sb->alloc) {\n\t\tzfree(&sb->buf);\n\t\tstrbuf_init(sb, 0);\n\t}\n}\n\nchar *strbuf_detach(struct strbuf *sb, size_t *sz)\n{\n\tchar *res = sb->alloc ? sb->buf : NULL;\n\tif (sz)\n\t\t*sz = sb->len;\n\tstrbuf_init(sb, 0);\n\treturn res;\n}\n\nint strbuf_grow(struct strbuf *sb, size_t extra)\n{\n\tchar *buf;\n\tsize_t nr = sb->len + extra + 1;\n\n\tif (nr < sb->alloc)\n\t\treturn 0;\n\n\tif (nr <= sb->len)\n\t\treturn -E2BIG;\n\n\tif (alloc_nr(sb->alloc) > nr)\n\t\tnr = alloc_nr(sb->alloc);\n\n\t \n\tbuf = realloc(sb->alloc ? sb->buf : NULL, nr * sizeof(*buf));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsb->buf = buf;\n\tsb->alloc = nr;\n\treturn 0;\n}\n\nint strbuf_addch(struct strbuf *sb, int c)\n{\n\tint ret = strbuf_grow(sb, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tsb->buf[sb->len++] = c;\n\tsb->buf[sb->len] = '\\0';\n\treturn 0;\n}\n\nint strbuf_add(struct strbuf *sb, const void *data, size_t len)\n{\n\tint ret = strbuf_grow(sb, len);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(sb->buf + sb->len, data, len);\n\treturn strbuf_setlen(sb, sb->len + len);\n}\n\nstatic int strbuf_addv(struct strbuf *sb, const char *fmt, va_list ap)\n{\n\tint len, ret;\n\tva_list ap_saved;\n\n\tif (!strbuf_avail(sb)) {\n\t\tret = strbuf_grow(sb, 64);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tva_copy(ap_saved, ap);\n\tlen = vsnprintf(sb->buf + sb->len, sb->alloc - sb->len, fmt, ap);\n\tif (len < 0) {\n\t\tva_end(ap_saved);\n\t\treturn len;\n\t}\n\tif (len > strbuf_avail(sb)) {\n\t\tret = strbuf_grow(sb, len);\n\t\tif (ret) {\n\t\t\tva_end(ap_saved);\n\t\t\treturn ret;\n\t\t}\n\t\tlen = vsnprintf(sb->buf + sb->len, sb->alloc - sb->len, fmt, ap_saved);\n\t\tif (len > strbuf_avail(sb)) {\n\t\t\tpr_debug(\"this should not happen, your vsnprintf is broken\");\n\t\t\tva_end(ap_saved);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tva_end(ap_saved);\n\treturn strbuf_setlen(sb, sb->len + len);\n}\n\nint strbuf_addf(struct strbuf *sb, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = strbuf_addv(sb, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\nssize_t strbuf_read(struct strbuf *sb, int fd, ssize_t hint)\n{\n\tsize_t oldlen = sb->len;\n\tsize_t oldalloc = sb->alloc;\n\tint ret;\n\n\tret = strbuf_grow(sb, hint ? hint : 8192);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (;;) {\n\t\tssize_t cnt;\n\n\t\tcnt = read(fd, sb->buf + sb->len, sb->alloc - sb->len - 1);\n\t\tif (cnt < 0) {\n\t\t\tif (oldalloc == 0)\n\t\t\t\tstrbuf_release(sb);\n\t\t\telse\n\t\t\t\tstrbuf_setlen(sb, oldlen);\n\t\t\treturn cnt;\n\t\t}\n\t\tif (!cnt)\n\t\t\tbreak;\n\t\tsb->len += cnt;\n\t\tret = strbuf_grow(sb, 8192);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsb->buf[sb->len] = '\\0';\n\treturn sb->len - oldlen;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}