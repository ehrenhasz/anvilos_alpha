{
  "module_name": "tsc.c",
  "hash_id": "f94badf2dccc15a61d5ca73df0108a726d7772f1a2a2e81f2d19f8c650440b70",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/tsc.c",
  "human_readable_source": "\n#include <errno.h>\n#include <inttypes.h>\n#include <string.h>\n\n#include <linux/compiler.h>\n#include <linux/perf_event.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#include <asm/barrier.h>\n\n#include \"event.h\"\n#include \"synthetic-events.h\"\n#include \"debug.h\"\n#include \"tsc.h\"\n\nu64 perf_time_to_tsc(u64 ns, struct perf_tsc_conversion *tc)\n{\n\tu64 t, quot, rem;\n\n\tt = ns - tc->time_zero;\n\tquot = t / tc->time_mult;\n\trem  = t % tc->time_mult;\n\treturn (quot << tc->time_shift) +\n\t       (rem << tc->time_shift) / tc->time_mult;\n}\n\nu64 tsc_to_perf_time(u64 cyc, struct perf_tsc_conversion *tc)\n{\n\tu64 quot, rem;\n\n\tif (tc->cap_user_time_short)\n\t\tcyc = tc->time_cycles +\n\t\t\t((cyc - tc->time_cycles) & tc->time_mask);\n\n\tquot = cyc >> tc->time_shift;\n\trem  = cyc & (((u64)1 << tc->time_shift) - 1);\n\treturn tc->time_zero + quot * tc->time_mult +\n\t       ((rem * tc->time_mult) >> tc->time_shift);\n}\n\nint perf_read_tsc_conversion(const struct perf_event_mmap_page *pc,\n\t\t\t     struct perf_tsc_conversion *tc)\n{\n\tu32 seq;\n\tint i = 0;\n\n\twhile (1) {\n\t\tseq = pc->lock;\n\t\trmb();\n\t\ttc->time_mult = pc->time_mult;\n\t\ttc->time_shift = pc->time_shift;\n\t\ttc->time_zero = pc->time_zero;\n\t\ttc->time_cycles = pc->time_cycles;\n\t\ttc->time_mask = pc->time_mask;\n\t\ttc->cap_user_time_zero = pc->cap_user_time_zero;\n\t\ttc->cap_user_time_short\t= pc->cap_user_time_short;\n\t\trmb();\n\t\tif (pc->lock == seq && !(seq & 1))\n\t\t\tbreak;\n\t\tif (++i > 10000) {\n\t\t\tpr_debug(\"failed to get perf_event_mmap_page lock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!tc->cap_user_time_zero)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nint perf_event__synth_time_conv(const struct perf_event_mmap_page *pc,\n\t\t\t\tstruct perf_tool *tool,\n\t\t\t\tperf_event__handler_t process,\n\t\t\t\tstruct machine *machine)\n{\n\tunion perf_event event = {\n\t\t.time_conv = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_TIME_CONV,\n\t\t\t\t.size = sizeof(struct perf_record_time_conv),\n\t\t\t},\n\t\t},\n\t};\n\tstruct perf_tsc_conversion tc;\n\tint err;\n\n\tif (!pc)\n\t\treturn 0;\n\terr = perf_read_tsc_conversion(pc, &tc);\n\tif (err == -EOPNOTSUPP)\n\t\treturn 0;\n\tif (err)\n\t\treturn err;\n\n\tpr_debug2(\"Synthesizing TSC conversion information\\n\");\n\n\tevent.time_conv.time_mult  = tc.time_mult;\n\tevent.time_conv.time_shift = tc.time_shift;\n\tevent.time_conv.time_zero  = tc.time_zero;\n\tevent.time_conv.time_cycles = tc.time_cycles;\n\tevent.time_conv.time_mask = tc.time_mask;\n\tevent.time_conv.cap_user_time_zero = tc.cap_user_time_zero;\n\tevent.time_conv.cap_user_time_short = tc.cap_user_time_short;\n\n\treturn process(tool, &event, NULL, machine);\n}\n\nu64 __weak rdtsc(void)\n{\n\treturn 0;\n}\n\nsize_t perf_event__fprintf_time_conv(union perf_event *event, FILE *fp)\n{\n\tstruct perf_record_time_conv *tc = (struct perf_record_time_conv *)event;\n\tsize_t ret;\n\n\tret  = fprintf(fp, \"\\n... Time Shift      %\" PRI_lu64 \"\\n\", tc->time_shift);\n\tret += fprintf(fp, \"... Time Muliplier  %\" PRI_lu64 \"\\n\", tc->time_mult);\n\tret += fprintf(fp, \"... Time Zero       %\" PRI_lu64 \"\\n\", tc->time_zero);\n\n\t \n\tif (event_contains(*tc, time_cycles)) {\n\t\tret += fprintf(fp, \"... Time Cycles     %\" PRI_lu64 \"\\n\",\n\t\t\t       tc->time_cycles);\n\t\tret += fprintf(fp, \"... Time Mask       %#\" PRI_lx64 \"\\n\",\n\t\t\t       tc->time_mask);\n\t\tret += fprintf(fp, \"... Cap Time Zero   %\" PRId32 \"\\n\",\n\t\t\t       tc->cap_user_time_zero);\n\t\tret += fprintf(fp, \"... Cap Time Short  %\" PRId32 \"\\n\",\n\t\t\t       tc->cap_user_time_short);\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}