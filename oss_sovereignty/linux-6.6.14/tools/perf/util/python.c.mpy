{
  "module_name": "python.c",
  "hash_id": "ea1c8305b908b67f62ad215e6586defc73228bc1511b148e8da11d6502f576dc",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/python.c",
  "human_readable_source": "\n#include <Python.h>\n#include <structmember.h>\n#include <inttypes.h>\n#include <poll.h>\n#include <linux/err.h>\n#include <perf/cpumap.h>\n#ifdef HAVE_LIBTRACEEVENT\n#include <traceevent/event-parse.h>\n#endif\n#include <perf/mmap.h>\n#include \"evlist.h\"\n#include \"callchain.h\"\n#include \"evsel.h\"\n#include \"event.h\"\n#include \"print_binary.h\"\n#include \"thread_map.h\"\n#include \"trace-event.h\"\n#include \"mmap.h\"\n#include \"stat.h\"\n#include \"metricgroup.h\"\n#include \"util/bpf-filter.h\"\n#include \"util/env.h\"\n#include \"util/pmu.h\"\n#include \"util/pmus.h\"\n#include <internal/lib.h>\n#include \"util.h\"\n\n#if PY_MAJOR_VERSION < 3\n#define _PyUnicode_FromString(arg) \\\n  PyString_FromString(arg)\n#define _PyUnicode_AsString(arg) \\\n  PyString_AsString(arg)\n#define _PyUnicode_FromFormat(...) \\\n  PyString_FromFormat(__VA_ARGS__)\n#define _PyLong_FromLong(arg) \\\n  PyInt_FromLong(arg)\n\n#else\n\n#define _PyUnicode_FromString(arg) \\\n  PyUnicode_FromString(arg)\n#define _PyUnicode_FromFormat(...) \\\n  PyUnicode_FromFormat(__VA_ARGS__)\n#define _PyLong_FromLong(arg) \\\n  PyLong_FromLong(arg)\n#endif\n\n#ifndef Py_TYPE\n#define Py_TYPE(ob) (((PyObject*)(ob))->ob_type)\n#endif\n\n \nint parse_event(struct evlist *evlist __maybe_unused, const char *str __maybe_unused)\n{\n\treturn 0;\n}\n\n \nstruct callchain_param callchain_param;\n\nint parse_callchain_record(const char *arg __maybe_unused,\n\t\t\t   struct callchain_param *param __maybe_unused)\n{\n\treturn 0;\n}\n\n \nstruct perf_env perf_env;\n\nconst char *perf_env__cpuid(struct perf_env *env __maybe_unused)\n{\n\treturn NULL;\n}\n\n \nconst char *perf_env__arch(struct perf_env *env __maybe_unused)\n{\n\treturn NULL;\n}\n\n \nstruct perf_pmu *evsel__find_pmu(const struct evsel *evsel __maybe_unused)\n{\n\treturn NULL;\n}\n\nint perf_pmu__scan_file(struct perf_pmu *pmu, const char *name, const char *fmt, ...)\n{\n\treturn EOF;\n}\n\nint perf_pmus__num_core_pmus(void)\n{\n\treturn 1;\n}\n\nbool evsel__is_aux_event(const struct evsel *evsel __maybe_unused)\n{\n\treturn false;\n}\n\nbool perf_pmus__supports_extended_type(void)\n{\n\treturn false;\n}\n\n \nint metricgroup__copy_metric_events(struct evlist *evlist, struct cgroup *cgrp,\n\t\t\t\t    struct rblist *new_metric_events,\n\t\t\t\t    struct rblist *old_metric_events)\n{\n\treturn 0;\n}\n\n \nchar *tracepoint_id_to_name(u64 config)\n{\n\treturn NULL;\n}\n\n \nvoid bpf_counter__destroy(struct evsel *evsel);\nint bpf_counter__install_pe(struct evsel *evsel, int cpu, int fd);\nint bpf_counter__disable(struct evsel *evsel);\n\nvoid bpf_counter__destroy(struct evsel *evsel __maybe_unused)\n{\n}\n\nint bpf_counter__install_pe(struct evsel *evsel __maybe_unused, int cpu __maybe_unused, int fd __maybe_unused)\n{\n\treturn 0;\n}\n\nint bpf_counter__disable(struct evsel *evsel __maybe_unused)\n{\n\treturn 0;\n}\n\n\n#ifdef HAVE_BPF_SKEL\nint perf_bpf_filter__prepare(struct evsel *evsel __maybe_unused)\n{\n\treturn 0;\n}\n\nint perf_bpf_filter__destroy(struct evsel *evsel __maybe_unused)\n{\n\treturn 0;\n}\n#endif\n\n \nint verbose;\nint debug_peo_args;\n\nint eprintf(int level, int var, const char *fmt, ...);\n\nint eprintf(int level, int var, const char *fmt, ...)\n{\n\tva_list args;\n\tint ret = 0;\n\n\tif (var >= level) {\n\t\tva_start(args, fmt);\n\t\tret = vfprintf(stderr, fmt, args);\n\t\tva_end(args);\n\t}\n\n\treturn ret;\n}\n\n \n#ifndef PyVarObject_HEAD_INIT\n# define PyVarObject_HEAD_INIT(type, size) PyObject_HEAD_INIT(type) size,\n#endif\n\n#if PY_MAJOR_VERSION < 3\nPyMODINIT_FUNC initperf(void);\n#else\nPyMODINIT_FUNC PyInit_perf(void);\n#endif\n\n#define member_def(type, member, ptype, help) \\\n\t{ #member, ptype, \\\n\t  offsetof(struct pyrf_event, event) + offsetof(struct type, member), \\\n\t  0, help }\n\n#define sample_member_def(name, member, ptype, help) \\\n\t{ #name, ptype, \\\n\t  offsetof(struct pyrf_event, sample) + offsetof(struct perf_sample, member), \\\n\t  0, help }\n\nstruct pyrf_event {\n\tPyObject_HEAD\n\tstruct evsel *evsel;\n\tstruct perf_sample sample;\n\tunion perf_event   event;\n};\n\n#define sample_members \\\n\tsample_member_def(sample_ip, ip, T_ULONGLONG, \"event type\"),\t\t\t \\\n\tsample_member_def(sample_pid, pid, T_INT, \"event pid\"),\t\t\t \\\n\tsample_member_def(sample_tid, tid, T_INT, \"event tid\"),\t\t\t \\\n\tsample_member_def(sample_time, time, T_ULONGLONG, \"event timestamp\"),\t\t \\\n\tsample_member_def(sample_addr, addr, T_ULONGLONG, \"event addr\"),\t\t \\\n\tsample_member_def(sample_id, id, T_ULONGLONG, \"event id\"),\t\t\t \\\n\tsample_member_def(sample_stream_id, stream_id, T_ULONGLONG, \"event stream id\"), \\\n\tsample_member_def(sample_period, period, T_ULONGLONG, \"event period\"),\t\t \\\n\tsample_member_def(sample_cpu, cpu, T_UINT, \"event cpu\"),\n\nstatic char pyrf_mmap_event__doc[] = PyDoc_STR(\"perf mmap event object.\");\n\nstatic PyMemberDef pyrf_mmap_event__members[] = {\n\tsample_members\n\tmember_def(perf_event_header, type, T_UINT, \"event type\"),\n\tmember_def(perf_event_header, misc, T_UINT, \"event misc\"),\n\tmember_def(perf_record_mmap, pid, T_UINT, \"event pid\"),\n\tmember_def(perf_record_mmap, tid, T_UINT, \"event tid\"),\n\tmember_def(perf_record_mmap, start, T_ULONGLONG, \"start of the map\"),\n\tmember_def(perf_record_mmap, len, T_ULONGLONG, \"map length\"),\n\tmember_def(perf_record_mmap, pgoff, T_ULONGLONG, \"page offset\"),\n\tmember_def(perf_record_mmap, filename, T_STRING_INPLACE, \"backing store\"),\n\t{ .name = NULL, },\n};\n\nstatic PyObject *pyrf_mmap_event__repr(struct pyrf_event *pevent)\n{\n\tPyObject *ret;\n\tchar *s;\n\n\tif (asprintf(&s, \"{ type: mmap, pid: %u, tid: %u, start: %#\" PRI_lx64 \", \"\n\t\t\t \"length: %#\" PRI_lx64 \", offset: %#\" PRI_lx64 \", \"\n\t\t\t \"filename: %s }\",\n\t\t     pevent->event.mmap.pid, pevent->event.mmap.tid,\n\t\t     pevent->event.mmap.start, pevent->event.mmap.len,\n\t\t     pevent->event.mmap.pgoff, pevent->event.mmap.filename) < 0) {\n\t\tret = PyErr_NoMemory();\n\t} else {\n\t\tret = _PyUnicode_FromString(s);\n\t\tfree(s);\n\t}\n\treturn ret;\n}\n\nstatic PyTypeObject pyrf_mmap_event__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.mmap_event\",\n\t.tp_basicsize\t= sizeof(struct pyrf_event),\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_doc\t\t= pyrf_mmap_event__doc,\n\t.tp_members\t= pyrf_mmap_event__members,\n\t.tp_repr\t= (reprfunc)pyrf_mmap_event__repr,\n};\n\nstatic char pyrf_task_event__doc[] = PyDoc_STR(\"perf task (fork/exit) event object.\");\n\nstatic PyMemberDef pyrf_task_event__members[] = {\n\tsample_members\n\tmember_def(perf_event_header, type, T_UINT, \"event type\"),\n\tmember_def(perf_record_fork, pid, T_UINT, \"event pid\"),\n\tmember_def(perf_record_fork, ppid, T_UINT, \"event ppid\"),\n\tmember_def(perf_record_fork, tid, T_UINT, \"event tid\"),\n\tmember_def(perf_record_fork, ptid, T_UINT, \"event ptid\"),\n\tmember_def(perf_record_fork, time, T_ULONGLONG, \"timestamp\"),\n\t{ .name = NULL, },\n};\n\nstatic PyObject *pyrf_task_event__repr(struct pyrf_event *pevent)\n{\n\treturn _PyUnicode_FromFormat(\"{ type: %s, pid: %u, ppid: %u, tid: %u, \"\n\t\t\t\t   \"ptid: %u, time: %\" PRI_lu64 \"}\",\n\t\t\t\t   pevent->event.header.type == PERF_RECORD_FORK ? \"fork\" : \"exit\",\n\t\t\t\t   pevent->event.fork.pid,\n\t\t\t\t   pevent->event.fork.ppid,\n\t\t\t\t   pevent->event.fork.tid,\n\t\t\t\t   pevent->event.fork.ptid,\n\t\t\t\t   pevent->event.fork.time);\n}\n\nstatic PyTypeObject pyrf_task_event__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.task_event\",\n\t.tp_basicsize\t= sizeof(struct pyrf_event),\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_doc\t\t= pyrf_task_event__doc,\n\t.tp_members\t= pyrf_task_event__members,\n\t.tp_repr\t= (reprfunc)pyrf_task_event__repr,\n};\n\nstatic char pyrf_comm_event__doc[] = PyDoc_STR(\"perf comm event object.\");\n\nstatic PyMemberDef pyrf_comm_event__members[] = {\n\tsample_members\n\tmember_def(perf_event_header, type, T_UINT, \"event type\"),\n\tmember_def(perf_record_comm, pid, T_UINT, \"event pid\"),\n\tmember_def(perf_record_comm, tid, T_UINT, \"event tid\"),\n\tmember_def(perf_record_comm, comm, T_STRING_INPLACE, \"process name\"),\n\t{ .name = NULL, },\n};\n\nstatic PyObject *pyrf_comm_event__repr(struct pyrf_event *pevent)\n{\n\treturn _PyUnicode_FromFormat(\"{ type: comm, pid: %u, tid: %u, comm: %s }\",\n\t\t\t\t   pevent->event.comm.pid,\n\t\t\t\t   pevent->event.comm.tid,\n\t\t\t\t   pevent->event.comm.comm);\n}\n\nstatic PyTypeObject pyrf_comm_event__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.comm_event\",\n\t.tp_basicsize\t= sizeof(struct pyrf_event),\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_doc\t\t= pyrf_comm_event__doc,\n\t.tp_members\t= pyrf_comm_event__members,\n\t.tp_repr\t= (reprfunc)pyrf_comm_event__repr,\n};\n\nstatic char pyrf_throttle_event__doc[] = PyDoc_STR(\"perf throttle event object.\");\n\nstatic PyMemberDef pyrf_throttle_event__members[] = {\n\tsample_members\n\tmember_def(perf_event_header, type, T_UINT, \"event type\"),\n\tmember_def(perf_record_throttle, time, T_ULONGLONG, \"timestamp\"),\n\tmember_def(perf_record_throttle, id, T_ULONGLONG, \"event id\"),\n\tmember_def(perf_record_throttle, stream_id, T_ULONGLONG, \"event stream id\"),\n\t{ .name = NULL, },\n};\n\nstatic PyObject *pyrf_throttle_event__repr(struct pyrf_event *pevent)\n{\n\tstruct perf_record_throttle *te = (struct perf_record_throttle *)(&pevent->event.header + 1);\n\n\treturn _PyUnicode_FromFormat(\"{ type: %sthrottle, time: %\" PRI_lu64 \", id: %\" PRI_lu64\n\t\t\t\t   \", stream_id: %\" PRI_lu64 \" }\",\n\t\t\t\t   pevent->event.header.type == PERF_RECORD_THROTTLE ? \"\" : \"un\",\n\t\t\t\t   te->time, te->id, te->stream_id);\n}\n\nstatic PyTypeObject pyrf_throttle_event__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.throttle_event\",\n\t.tp_basicsize\t= sizeof(struct pyrf_event),\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_doc\t\t= pyrf_throttle_event__doc,\n\t.tp_members\t= pyrf_throttle_event__members,\n\t.tp_repr\t= (reprfunc)pyrf_throttle_event__repr,\n};\n\nstatic char pyrf_lost_event__doc[] = PyDoc_STR(\"perf lost event object.\");\n\nstatic PyMemberDef pyrf_lost_event__members[] = {\n\tsample_members\n\tmember_def(perf_record_lost, id, T_ULONGLONG, \"event id\"),\n\tmember_def(perf_record_lost, lost, T_ULONGLONG, \"number of lost events\"),\n\t{ .name = NULL, },\n};\n\nstatic PyObject *pyrf_lost_event__repr(struct pyrf_event *pevent)\n{\n\tPyObject *ret;\n\tchar *s;\n\n\tif (asprintf(&s, \"{ type: lost, id: %#\" PRI_lx64 \", \"\n\t\t\t \"lost: %#\" PRI_lx64 \" }\",\n\t\t     pevent->event.lost.id, pevent->event.lost.lost) < 0) {\n\t\tret = PyErr_NoMemory();\n\t} else {\n\t\tret = _PyUnicode_FromString(s);\n\t\tfree(s);\n\t}\n\treturn ret;\n}\n\nstatic PyTypeObject pyrf_lost_event__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.lost_event\",\n\t.tp_basicsize\t= sizeof(struct pyrf_event),\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_doc\t\t= pyrf_lost_event__doc,\n\t.tp_members\t= pyrf_lost_event__members,\n\t.tp_repr\t= (reprfunc)pyrf_lost_event__repr,\n};\n\nstatic char pyrf_read_event__doc[] = PyDoc_STR(\"perf read event object.\");\n\nstatic PyMemberDef pyrf_read_event__members[] = {\n\tsample_members\n\tmember_def(perf_record_read, pid, T_UINT, \"event pid\"),\n\tmember_def(perf_record_read, tid, T_UINT, \"event tid\"),\n\t{ .name = NULL, },\n};\n\nstatic PyObject *pyrf_read_event__repr(struct pyrf_event *pevent)\n{\n\treturn _PyUnicode_FromFormat(\"{ type: read, pid: %u, tid: %u }\",\n\t\t\t\t   pevent->event.read.pid,\n\t\t\t\t   pevent->event.read.tid);\n\t \n}\n\nstatic PyTypeObject pyrf_read_event__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.read_event\",\n\t.tp_basicsize\t= sizeof(struct pyrf_event),\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_doc\t\t= pyrf_read_event__doc,\n\t.tp_members\t= pyrf_read_event__members,\n\t.tp_repr\t= (reprfunc)pyrf_read_event__repr,\n};\n\nstatic char pyrf_sample_event__doc[] = PyDoc_STR(\"perf sample event object.\");\n\nstatic PyMemberDef pyrf_sample_event__members[] = {\n\tsample_members\n\tmember_def(perf_event_header, type, T_UINT, \"event type\"),\n\t{ .name = NULL, },\n};\n\nstatic PyObject *pyrf_sample_event__repr(struct pyrf_event *pevent)\n{\n\tPyObject *ret;\n\tchar *s;\n\n\tif (asprintf(&s, \"{ type: sample }\") < 0) {\n\t\tret = PyErr_NoMemory();\n\t} else {\n\t\tret = _PyUnicode_FromString(s);\n\t\tfree(s);\n\t}\n\treturn ret;\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nstatic bool is_tracepoint(struct pyrf_event *pevent)\n{\n\treturn pevent->evsel->core.attr.type == PERF_TYPE_TRACEPOINT;\n}\n\nstatic PyObject*\ntracepoint_field(struct pyrf_event *pe, struct tep_format_field *field)\n{\n\tstruct tep_handle *pevent = field->event->tep;\n\tvoid *data = pe->sample.raw_data;\n\tPyObject *ret = NULL;\n\tunsigned long long val;\n\tunsigned int offset, len;\n\n\tif (field->flags & TEP_FIELD_IS_ARRAY) {\n\t\toffset = field->offset;\n\t\tlen    = field->size;\n\t\tif (field->flags & TEP_FIELD_IS_DYNAMIC) {\n\t\t\tval     = tep_read_number(pevent, data + offset, len);\n\t\t\toffset  = val;\n\t\t\tlen     = offset >> 16;\n\t\t\toffset &= 0xffff;\n\t\t\tif (tep_field_is_relative(field->flags))\n\t\t\t\toffset += field->offset + field->size;\n\t\t}\n\t\tif (field->flags & TEP_FIELD_IS_STRING &&\n\t\t    is_printable_array(data + offset, len)) {\n\t\t\tret = _PyUnicode_FromString((char *)data + offset);\n\t\t} else {\n\t\t\tret = PyByteArray_FromStringAndSize((const char *) data + offset, len);\n\t\t\tfield->flags &= ~TEP_FIELD_IS_STRING;\n\t\t}\n\t} else {\n\t\tval = tep_read_number(pevent, data + field->offset,\n\t\t\t\t      field->size);\n\t\tif (field->flags & TEP_FIELD_IS_POINTER)\n\t\t\tret = PyLong_FromUnsignedLong((unsigned long) val);\n\t\telse if (field->flags & TEP_FIELD_IS_SIGNED)\n\t\t\tret = PyLong_FromLong((long) val);\n\t\telse\n\t\t\tret = PyLong_FromUnsignedLong((unsigned long) val);\n\t}\n\n\treturn ret;\n}\n\nstatic PyObject*\nget_tracepoint_field(struct pyrf_event *pevent, PyObject *attr_name)\n{\n\tconst char *str = _PyUnicode_AsString(PyObject_Str(attr_name));\n\tstruct evsel *evsel = pevent->evsel;\n\tstruct tep_format_field *field;\n\n\tif (!evsel->tp_format) {\n\t\tstruct tep_event *tp_format;\n\n\t\ttp_format = trace_event__tp_format_id(evsel->core.attr.config);\n\t\tif (IS_ERR_OR_NULL(tp_format))\n\t\t\treturn NULL;\n\n\t\tevsel->tp_format = tp_format;\n\t}\n\n\tfield = tep_find_any_field(evsel->tp_format, str);\n\tif (!field)\n\t\treturn NULL;\n\n\treturn tracepoint_field(pevent, field);\n}\n#endif  \n\nstatic PyObject*\npyrf_sample_event__getattro(struct pyrf_event *pevent, PyObject *attr_name)\n{\n\tPyObject *obj = NULL;\n\n#ifdef HAVE_LIBTRACEEVENT\n\tif (is_tracepoint(pevent))\n\t\tobj = get_tracepoint_field(pevent, attr_name);\n#endif\n\n\treturn obj ?: PyObject_GenericGetAttr((PyObject *) pevent, attr_name);\n}\n\nstatic PyTypeObject pyrf_sample_event__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.sample_event\",\n\t.tp_basicsize\t= sizeof(struct pyrf_event),\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_doc\t\t= pyrf_sample_event__doc,\n\t.tp_members\t= pyrf_sample_event__members,\n\t.tp_repr\t= (reprfunc)pyrf_sample_event__repr,\n\t.tp_getattro\t= (getattrofunc) pyrf_sample_event__getattro,\n};\n\nstatic char pyrf_context_switch_event__doc[] = PyDoc_STR(\"perf context_switch event object.\");\n\nstatic PyMemberDef pyrf_context_switch_event__members[] = {\n\tsample_members\n\tmember_def(perf_event_header, type, T_UINT, \"event type\"),\n\tmember_def(perf_record_switch, next_prev_pid, T_UINT, \"next/prev pid\"),\n\tmember_def(perf_record_switch, next_prev_tid, T_UINT, \"next/prev tid\"),\n\t{ .name = NULL, },\n};\n\nstatic PyObject *pyrf_context_switch_event__repr(struct pyrf_event *pevent)\n{\n\tPyObject *ret;\n\tchar *s;\n\n\tif (asprintf(&s, \"{ type: context_switch, next_prev_pid: %u, next_prev_tid: %u, switch_out: %u }\",\n\t\t     pevent->event.context_switch.next_prev_pid,\n\t\t     pevent->event.context_switch.next_prev_tid,\n\t\t     !!(pevent->event.header.misc & PERF_RECORD_MISC_SWITCH_OUT)) < 0) {\n\t\tret = PyErr_NoMemory();\n\t} else {\n\t\tret = _PyUnicode_FromString(s);\n\t\tfree(s);\n\t}\n\treturn ret;\n}\n\nstatic PyTypeObject pyrf_context_switch_event__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.context_switch_event\",\n\t.tp_basicsize\t= sizeof(struct pyrf_event),\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_doc\t\t= pyrf_context_switch_event__doc,\n\t.tp_members\t= pyrf_context_switch_event__members,\n\t.tp_repr\t= (reprfunc)pyrf_context_switch_event__repr,\n};\n\nstatic int pyrf_event__setup_types(void)\n{\n\tint err;\n\tpyrf_mmap_event__type.tp_new =\n\tpyrf_task_event__type.tp_new =\n\tpyrf_comm_event__type.tp_new =\n\tpyrf_lost_event__type.tp_new =\n\tpyrf_read_event__type.tp_new =\n\tpyrf_sample_event__type.tp_new =\n\tpyrf_context_switch_event__type.tp_new =\n\tpyrf_throttle_event__type.tp_new = PyType_GenericNew;\n\terr = PyType_Ready(&pyrf_mmap_event__type);\n\tif (err < 0)\n\t\tgoto out;\n\terr = PyType_Ready(&pyrf_lost_event__type);\n\tif (err < 0)\n\t\tgoto out;\n\terr = PyType_Ready(&pyrf_task_event__type);\n\tif (err < 0)\n\t\tgoto out;\n\terr = PyType_Ready(&pyrf_comm_event__type);\n\tif (err < 0)\n\t\tgoto out;\n\terr = PyType_Ready(&pyrf_throttle_event__type);\n\tif (err < 0)\n\t\tgoto out;\n\terr = PyType_Ready(&pyrf_read_event__type);\n\tif (err < 0)\n\t\tgoto out;\n\terr = PyType_Ready(&pyrf_sample_event__type);\n\tif (err < 0)\n\t\tgoto out;\n\terr = PyType_Ready(&pyrf_context_switch_event__type);\n\tif (err < 0)\n\t\tgoto out;\nout:\n\treturn err;\n}\n\nstatic PyTypeObject *pyrf_event__type[] = {\n\t[PERF_RECORD_MMAP]\t = &pyrf_mmap_event__type,\n\t[PERF_RECORD_LOST]\t = &pyrf_lost_event__type,\n\t[PERF_RECORD_COMM]\t = &pyrf_comm_event__type,\n\t[PERF_RECORD_EXIT]\t = &pyrf_task_event__type,\n\t[PERF_RECORD_THROTTLE]\t = &pyrf_throttle_event__type,\n\t[PERF_RECORD_UNTHROTTLE] = &pyrf_throttle_event__type,\n\t[PERF_RECORD_FORK]\t = &pyrf_task_event__type,\n\t[PERF_RECORD_READ]\t = &pyrf_read_event__type,\n\t[PERF_RECORD_SAMPLE]\t = &pyrf_sample_event__type,\n\t[PERF_RECORD_SWITCH]\t = &pyrf_context_switch_event__type,\n\t[PERF_RECORD_SWITCH_CPU_WIDE]  = &pyrf_context_switch_event__type,\n};\n\nstatic PyObject *pyrf_event__new(union perf_event *event)\n{\n\tstruct pyrf_event *pevent;\n\tPyTypeObject *ptype;\n\n\tif ((event->header.type < PERF_RECORD_MMAP ||\n\t     event->header.type > PERF_RECORD_SAMPLE) &&\n\t    !(event->header.type == PERF_RECORD_SWITCH ||\n\t      event->header.type == PERF_RECORD_SWITCH_CPU_WIDE))\n\t\treturn NULL;\n\n\tptype = pyrf_event__type[event->header.type];\n\tpevent = PyObject_New(struct pyrf_event, ptype);\n\tif (pevent != NULL)\n\t\tmemcpy(&pevent->event, event, event->header.size);\n\treturn (PyObject *)pevent;\n}\n\nstruct pyrf_cpu_map {\n\tPyObject_HEAD\n\n\tstruct perf_cpu_map *cpus;\n};\n\nstatic int pyrf_cpu_map__init(struct pyrf_cpu_map *pcpus,\n\t\t\t      PyObject *args, PyObject *kwargs)\n{\n\tstatic char *kwlist[] = { \"cpustr\", NULL };\n\tchar *cpustr = NULL;\n\n\tif (!PyArg_ParseTupleAndKeywords(args, kwargs, \"|s\",\n\t\t\t\t\t kwlist, &cpustr))\n\t\treturn -1;\n\n\tpcpus->cpus = perf_cpu_map__new(cpustr);\n\tif (pcpus->cpus == NULL)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void pyrf_cpu_map__delete(struct pyrf_cpu_map *pcpus)\n{\n\tperf_cpu_map__put(pcpus->cpus);\n\tPy_TYPE(pcpus)->tp_free((PyObject*)pcpus);\n}\n\nstatic Py_ssize_t pyrf_cpu_map__length(PyObject *obj)\n{\n\tstruct pyrf_cpu_map *pcpus = (void *)obj;\n\n\treturn perf_cpu_map__nr(pcpus->cpus);\n}\n\nstatic PyObject *pyrf_cpu_map__item(PyObject *obj, Py_ssize_t i)\n{\n\tstruct pyrf_cpu_map *pcpus = (void *)obj;\n\n\tif (i >= perf_cpu_map__nr(pcpus->cpus))\n\t\treturn NULL;\n\n\treturn Py_BuildValue(\"i\", perf_cpu_map__cpu(pcpus->cpus, i).cpu);\n}\n\nstatic PySequenceMethods pyrf_cpu_map__sequence_methods = {\n\t.sq_length = pyrf_cpu_map__length,\n\t.sq_item   = pyrf_cpu_map__item,\n};\n\nstatic char pyrf_cpu_map__doc[] = PyDoc_STR(\"cpu map object.\");\n\nstatic PyTypeObject pyrf_cpu_map__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.cpu_map\",\n\t.tp_basicsize\t= sizeof(struct pyrf_cpu_map),\n\t.tp_dealloc\t= (destructor)pyrf_cpu_map__delete,\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_doc\t\t= pyrf_cpu_map__doc,\n\t.tp_as_sequence\t= &pyrf_cpu_map__sequence_methods,\n\t.tp_init\t= (initproc)pyrf_cpu_map__init,\n};\n\nstatic int pyrf_cpu_map__setup_types(void)\n{\n\tpyrf_cpu_map__type.tp_new = PyType_GenericNew;\n\treturn PyType_Ready(&pyrf_cpu_map__type);\n}\n\nstruct pyrf_thread_map {\n\tPyObject_HEAD\n\n\tstruct perf_thread_map *threads;\n};\n\nstatic int pyrf_thread_map__init(struct pyrf_thread_map *pthreads,\n\t\t\t\t PyObject *args, PyObject *kwargs)\n{\n\tstatic char *kwlist[] = { \"pid\", \"tid\", \"uid\", NULL };\n\tint pid = -1, tid = -1, uid = UINT_MAX;\n\n\tif (!PyArg_ParseTupleAndKeywords(args, kwargs, \"|iii\",\n\t\t\t\t\t kwlist, &pid, &tid, &uid))\n\t\treturn -1;\n\n\tpthreads->threads = thread_map__new(pid, tid, uid);\n\tif (pthreads->threads == NULL)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void pyrf_thread_map__delete(struct pyrf_thread_map *pthreads)\n{\n\tperf_thread_map__put(pthreads->threads);\n\tPy_TYPE(pthreads)->tp_free((PyObject*)pthreads);\n}\n\nstatic Py_ssize_t pyrf_thread_map__length(PyObject *obj)\n{\n\tstruct pyrf_thread_map *pthreads = (void *)obj;\n\n\treturn perf_thread_map__nr(pthreads->threads);\n}\n\nstatic PyObject *pyrf_thread_map__item(PyObject *obj, Py_ssize_t i)\n{\n\tstruct pyrf_thread_map *pthreads = (void *)obj;\n\n\tif (i >= perf_thread_map__nr(pthreads->threads))\n\t\treturn NULL;\n\n\treturn Py_BuildValue(\"i\", perf_thread_map__pid(pthreads->threads, i));\n}\n\nstatic PySequenceMethods pyrf_thread_map__sequence_methods = {\n\t.sq_length = pyrf_thread_map__length,\n\t.sq_item   = pyrf_thread_map__item,\n};\n\nstatic char pyrf_thread_map__doc[] = PyDoc_STR(\"thread map object.\");\n\nstatic PyTypeObject pyrf_thread_map__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.thread_map\",\n\t.tp_basicsize\t= sizeof(struct pyrf_thread_map),\n\t.tp_dealloc\t= (destructor)pyrf_thread_map__delete,\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_doc\t\t= pyrf_thread_map__doc,\n\t.tp_as_sequence\t= &pyrf_thread_map__sequence_methods,\n\t.tp_init\t= (initproc)pyrf_thread_map__init,\n};\n\nstatic int pyrf_thread_map__setup_types(void)\n{\n\tpyrf_thread_map__type.tp_new = PyType_GenericNew;\n\treturn PyType_Ready(&pyrf_thread_map__type);\n}\n\nstruct pyrf_evsel {\n\tPyObject_HEAD\n\n\tstruct evsel evsel;\n};\n\nstatic int pyrf_evsel__init(struct pyrf_evsel *pevsel,\n\t\t\t    PyObject *args, PyObject *kwargs)\n{\n\tstruct perf_event_attr attr = {\n\t\t.type = PERF_TYPE_HARDWARE,\n\t\t.config = PERF_COUNT_HW_CPU_CYCLES,\n\t\t.sample_type = PERF_SAMPLE_PERIOD | PERF_SAMPLE_TID,\n\t};\n\tstatic char *kwlist[] = {\n\t\t\"type\",\n\t\t\"config\",\n\t\t\"sample_freq\",\n\t\t\"sample_period\",\n\t\t\"sample_type\",\n\t\t\"read_format\",\n\t\t\"disabled\",\n\t\t\"inherit\",\n\t\t\"pinned\",\n\t\t\"exclusive\",\n\t\t\"exclude_user\",\n\t\t\"exclude_kernel\",\n\t\t\"exclude_hv\",\n\t\t\"exclude_idle\",\n\t\t\"mmap\",\n\t\t\"context_switch\",\n\t\t\"comm\",\n\t\t\"freq\",\n\t\t\"inherit_stat\",\n\t\t\"enable_on_exec\",\n\t\t\"task\",\n\t\t\"watermark\",\n\t\t\"precise_ip\",\n\t\t\"mmap_data\",\n\t\t\"sample_id_all\",\n\t\t\"wakeup_events\",\n\t\t\"bp_type\",\n\t\t\"bp_addr\",\n\t\t\"bp_len\",\n\t\t NULL\n\t};\n\tu64 sample_period = 0;\n\tu32 disabled = 0,\n\t    inherit = 0,\n\t    pinned = 0,\n\t    exclusive = 0,\n\t    exclude_user = 0,\n\t    exclude_kernel = 0,\n\t    exclude_hv = 0,\n\t    exclude_idle = 0,\n\t    mmap = 0,\n\t    context_switch = 0,\n\t    comm = 0,\n\t    freq = 1,\n\t    inherit_stat = 0,\n\t    enable_on_exec = 0,\n\t    task = 0,\n\t    watermark = 0,\n\t    precise_ip = 0,\n\t    mmap_data = 0,\n\t    sample_id_all = 1;\n\tint idx = 0;\n\n\tif (!PyArg_ParseTupleAndKeywords(args, kwargs,\n\t\t\t\t\t \"|iKiKKiiiiiiiiiiiiiiiiiiiiiiKK\", kwlist,\n\t\t\t\t\t &attr.type, &attr.config, &attr.sample_freq,\n\t\t\t\t\t &sample_period, &attr.sample_type,\n\t\t\t\t\t &attr.read_format, &disabled, &inherit,\n\t\t\t\t\t &pinned, &exclusive, &exclude_user,\n\t\t\t\t\t &exclude_kernel, &exclude_hv, &exclude_idle,\n\t\t\t\t\t &mmap, &context_switch, &comm, &freq, &inherit_stat,\n\t\t\t\t\t &enable_on_exec, &task, &watermark,\n\t\t\t\t\t &precise_ip, &mmap_data, &sample_id_all,\n\t\t\t\t\t &attr.wakeup_events, &attr.bp_type,\n\t\t\t\t\t &attr.bp_addr, &attr.bp_len, &idx))\n\t\treturn -1;\n\n\t \n\tif (sample_period != 0) {\n\t\tif (attr.sample_freq != 0)\n\t\t\treturn -1;  \n\t\tattr.sample_period = sample_period;\n\t}\n\n\t \n\tattr.disabled\t    = disabled;\n\tattr.inherit\t    = inherit;\n\tattr.pinned\t    = pinned;\n\tattr.exclusive\t    = exclusive;\n\tattr.exclude_user   = exclude_user;\n\tattr.exclude_kernel = exclude_kernel;\n\tattr.exclude_hv\t    = exclude_hv;\n\tattr.exclude_idle   = exclude_idle;\n\tattr.mmap\t    = mmap;\n\tattr.context_switch = context_switch;\n\tattr.comm\t    = comm;\n\tattr.freq\t    = freq;\n\tattr.inherit_stat   = inherit_stat;\n\tattr.enable_on_exec = enable_on_exec;\n\tattr.task\t    = task;\n\tattr.watermark\t    = watermark;\n\tattr.precise_ip\t    = precise_ip;\n\tattr.mmap_data\t    = mmap_data;\n\tattr.sample_id_all  = sample_id_all;\n\tattr.size\t    = sizeof(attr);\n\n\tevsel__init(&pevsel->evsel, &attr, idx);\n\treturn 0;\n}\n\nstatic void pyrf_evsel__delete(struct pyrf_evsel *pevsel)\n{\n\tevsel__exit(&pevsel->evsel);\n\tPy_TYPE(pevsel)->tp_free((PyObject*)pevsel);\n}\n\nstatic PyObject *pyrf_evsel__open(struct pyrf_evsel *pevsel,\n\t\t\t\t  PyObject *args, PyObject *kwargs)\n{\n\tstruct evsel *evsel = &pevsel->evsel;\n\tstruct perf_cpu_map *cpus = NULL;\n\tstruct perf_thread_map *threads = NULL;\n\tPyObject *pcpus = NULL, *pthreads = NULL;\n\tint group = 0, inherit = 0;\n\tstatic char *kwlist[] = { \"cpus\", \"threads\", \"group\", \"inherit\", NULL };\n\n\tif (!PyArg_ParseTupleAndKeywords(args, kwargs, \"|OOii\", kwlist,\n\t\t\t\t\t &pcpus, &pthreads, &group, &inherit))\n\t\treturn NULL;\n\n\tif (pthreads != NULL)\n\t\tthreads = ((struct pyrf_thread_map *)pthreads)->threads;\n\n\tif (pcpus != NULL)\n\t\tcpus = ((struct pyrf_cpu_map *)pcpus)->cpus;\n\n\tevsel->core.attr.inherit = inherit;\n\t \n\tif (evsel__open(evsel, cpus, threads) < 0) {\n\t\tPyErr_SetFromErrno(PyExc_OSError);\n\t\treturn NULL;\n\t}\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nstatic PyMethodDef pyrf_evsel__methods[] = {\n\t{\n\t\t.ml_name  = \"open\",\n\t\t.ml_meth  = (PyCFunction)pyrf_evsel__open,\n\t\t.ml_flags = METH_VARARGS | METH_KEYWORDS,\n\t\t.ml_doc\t  = PyDoc_STR(\"open the event selector file descriptor table.\")\n\t},\n\t{ .ml_name = NULL, }\n};\n\nstatic char pyrf_evsel__doc[] = PyDoc_STR(\"perf event selector list object.\");\n\nstatic PyTypeObject pyrf_evsel__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.evsel\",\n\t.tp_basicsize\t= sizeof(struct pyrf_evsel),\n\t.tp_dealloc\t= (destructor)pyrf_evsel__delete,\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_doc\t\t= pyrf_evsel__doc,\n\t.tp_methods\t= pyrf_evsel__methods,\n\t.tp_init\t= (initproc)pyrf_evsel__init,\n};\n\nstatic int pyrf_evsel__setup_types(void)\n{\n\tpyrf_evsel__type.tp_new = PyType_GenericNew;\n\treturn PyType_Ready(&pyrf_evsel__type);\n}\n\nstruct pyrf_evlist {\n\tPyObject_HEAD\n\n\tstruct evlist evlist;\n};\n\nstatic int pyrf_evlist__init(struct pyrf_evlist *pevlist,\n\t\t\t     PyObject *args, PyObject *kwargs __maybe_unused)\n{\n\tPyObject *pcpus = NULL, *pthreads = NULL;\n\tstruct perf_cpu_map *cpus;\n\tstruct perf_thread_map *threads;\n\n\tif (!PyArg_ParseTuple(args, \"OO\", &pcpus, &pthreads))\n\t\treturn -1;\n\n\tthreads = ((struct pyrf_thread_map *)pthreads)->threads;\n\tcpus = ((struct pyrf_cpu_map *)pcpus)->cpus;\n\tevlist__init(&pevlist->evlist, cpus, threads);\n\treturn 0;\n}\n\nstatic void pyrf_evlist__delete(struct pyrf_evlist *pevlist)\n{\n\tevlist__exit(&pevlist->evlist);\n\tPy_TYPE(pevlist)->tp_free((PyObject*)pevlist);\n}\n\nstatic PyObject *pyrf_evlist__mmap(struct pyrf_evlist *pevlist,\n\t\t\t\t   PyObject *args, PyObject *kwargs)\n{\n\tstruct evlist *evlist = &pevlist->evlist;\n\tstatic char *kwlist[] = { \"pages\", \"overwrite\", NULL };\n\tint pages = 128, overwrite = false;\n\n\tif (!PyArg_ParseTupleAndKeywords(args, kwargs, \"|ii\", kwlist,\n\t\t\t\t\t &pages, &overwrite))\n\t\treturn NULL;\n\n\tif (evlist__mmap(evlist, pages) < 0) {\n\t\tPyErr_SetFromErrno(PyExc_OSError);\n\t\treturn NULL;\n\t}\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nstatic PyObject *pyrf_evlist__poll(struct pyrf_evlist *pevlist,\n\t\t\t\t   PyObject *args, PyObject *kwargs)\n{\n\tstruct evlist *evlist = &pevlist->evlist;\n\tstatic char *kwlist[] = { \"timeout\", NULL };\n\tint timeout = -1, n;\n\n\tif (!PyArg_ParseTupleAndKeywords(args, kwargs, \"|i\", kwlist, &timeout))\n\t\treturn NULL;\n\n\tn = evlist__poll(evlist, timeout);\n\tif (n < 0) {\n\t\tPyErr_SetFromErrno(PyExc_OSError);\n\t\treturn NULL;\n\t}\n\n\treturn Py_BuildValue(\"i\", n);\n}\n\nstatic PyObject *pyrf_evlist__get_pollfd(struct pyrf_evlist *pevlist,\n\t\t\t\t\t PyObject *args __maybe_unused,\n\t\t\t\t\t PyObject *kwargs __maybe_unused)\n{\n\tstruct evlist *evlist = &pevlist->evlist;\n        PyObject *list = PyList_New(0);\n\tint i;\n\n\tfor (i = 0; i < evlist->core.pollfd.nr; ++i) {\n\t\tPyObject *file;\n#if PY_MAJOR_VERSION < 3\n\t\tFILE *fp = fdopen(evlist->core.pollfd.entries[i].fd, \"r\");\n\n\t\tif (fp == NULL)\n\t\t\tgoto free_list;\n\n\t\tfile = PyFile_FromFile(fp, \"perf\", \"r\", NULL);\n#else\n\t\tfile = PyFile_FromFd(evlist->core.pollfd.entries[i].fd, \"perf\", \"r\", -1,\n\t\t\t\t     NULL, NULL, NULL, 0);\n#endif\n\t\tif (file == NULL)\n\t\t\tgoto free_list;\n\n\t\tif (PyList_Append(list, file) != 0) {\n\t\t\tPy_DECREF(file);\n\t\t\tgoto free_list;\n\t\t}\n\n\t\tPy_DECREF(file);\n\t}\n\n\treturn list;\nfree_list:\n\treturn PyErr_NoMemory();\n}\n\n\nstatic PyObject *pyrf_evlist__add(struct pyrf_evlist *pevlist,\n\t\t\t\t  PyObject *args,\n\t\t\t\t  PyObject *kwargs __maybe_unused)\n{\n\tstruct evlist *evlist = &pevlist->evlist;\n\tPyObject *pevsel;\n\tstruct evsel *evsel;\n\n\tif (!PyArg_ParseTuple(args, \"O\", &pevsel))\n\t\treturn NULL;\n\n\tPy_INCREF(pevsel);\n\tevsel = &((struct pyrf_evsel *)pevsel)->evsel;\n\tevsel->core.idx = evlist->core.nr_entries;\n\tevlist__add(evlist, evsel);\n\n\treturn Py_BuildValue(\"i\", evlist->core.nr_entries);\n}\n\nstatic struct mmap *get_md(struct evlist *evlist, int cpu)\n{\n\tint i;\n\n\tfor (i = 0; i < evlist->core.nr_mmaps; i++) {\n\t\tstruct mmap *md = &evlist->mmap[i];\n\n\t\tif (md->core.cpu.cpu == cpu)\n\t\t\treturn md;\n\t}\n\n\treturn NULL;\n}\n\nstatic PyObject *pyrf_evlist__read_on_cpu(struct pyrf_evlist *pevlist,\n\t\t\t\t\t  PyObject *args, PyObject *kwargs)\n{\n\tstruct evlist *evlist = &pevlist->evlist;\n\tunion perf_event *event;\n\tint sample_id_all = 1, cpu;\n\tstatic char *kwlist[] = { \"cpu\", \"sample_id_all\", NULL };\n\tstruct mmap *md;\n\tint err;\n\n\tif (!PyArg_ParseTupleAndKeywords(args, kwargs, \"i|i\", kwlist,\n\t\t\t\t\t &cpu, &sample_id_all))\n\t\treturn NULL;\n\n\tmd = get_md(evlist, cpu);\n\tif (!md)\n\t\treturn NULL;\n\n\tif (perf_mmap__read_init(&md->core) < 0)\n\t\tgoto end;\n\n\tevent = perf_mmap__read_event(&md->core);\n\tif (event != NULL) {\n\t\tPyObject *pyevent = pyrf_event__new(event);\n\t\tstruct pyrf_event *pevent = (struct pyrf_event *)pyevent;\n\t\tstruct evsel *evsel;\n\n\t\tif (pyevent == NULL)\n\t\t\treturn PyErr_NoMemory();\n\n\t\tevsel = evlist__event2evsel(evlist, event);\n\t\tif (!evsel) {\n\t\t\tPy_INCREF(Py_None);\n\t\t\treturn Py_None;\n\t\t}\n\n\t\tpevent->evsel = evsel;\n\n\t\terr = evsel__parse_sample(evsel, event, &pevent->sample);\n\n\t\t \n\t\tperf_mmap__consume(&md->core);\n\n\t\tif (err)\n\t\t\treturn PyErr_Format(PyExc_OSError,\n\t\t\t\t\t    \"perf: can't parse sample, err=%d\", err);\n\t\treturn pyevent;\n\t}\nend:\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nstatic PyObject *pyrf_evlist__open(struct pyrf_evlist *pevlist,\n\t\t\t\t   PyObject *args, PyObject *kwargs)\n{\n\tstruct evlist *evlist = &pevlist->evlist;\n\n\tif (evlist__open(evlist) < 0) {\n\t\tPyErr_SetFromErrno(PyExc_OSError);\n\t\treturn NULL;\n\t}\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nstatic PyMethodDef pyrf_evlist__methods[] = {\n\t{\n\t\t.ml_name  = \"mmap\",\n\t\t.ml_meth  = (PyCFunction)pyrf_evlist__mmap,\n\t\t.ml_flags = METH_VARARGS | METH_KEYWORDS,\n\t\t.ml_doc\t  = PyDoc_STR(\"mmap the file descriptor table.\")\n\t},\n\t{\n\t\t.ml_name  = \"open\",\n\t\t.ml_meth  = (PyCFunction)pyrf_evlist__open,\n\t\t.ml_flags = METH_VARARGS | METH_KEYWORDS,\n\t\t.ml_doc\t  = PyDoc_STR(\"open the file descriptors.\")\n\t},\n\t{\n\t\t.ml_name  = \"poll\",\n\t\t.ml_meth  = (PyCFunction)pyrf_evlist__poll,\n\t\t.ml_flags = METH_VARARGS | METH_KEYWORDS,\n\t\t.ml_doc\t  = PyDoc_STR(\"poll the file descriptor table.\")\n\t},\n\t{\n\t\t.ml_name  = \"get_pollfd\",\n\t\t.ml_meth  = (PyCFunction)pyrf_evlist__get_pollfd,\n\t\t.ml_flags = METH_VARARGS | METH_KEYWORDS,\n\t\t.ml_doc\t  = PyDoc_STR(\"get the poll file descriptor table.\")\n\t},\n\t{\n\t\t.ml_name  = \"add\",\n\t\t.ml_meth  = (PyCFunction)pyrf_evlist__add,\n\t\t.ml_flags = METH_VARARGS | METH_KEYWORDS,\n\t\t.ml_doc\t  = PyDoc_STR(\"adds an event selector to the list.\")\n\t},\n\t{\n\t\t.ml_name  = \"read_on_cpu\",\n\t\t.ml_meth  = (PyCFunction)pyrf_evlist__read_on_cpu,\n\t\t.ml_flags = METH_VARARGS | METH_KEYWORDS,\n\t\t.ml_doc\t  = PyDoc_STR(\"reads an event.\")\n\t},\n\t{ .ml_name = NULL, }\n};\n\nstatic Py_ssize_t pyrf_evlist__length(PyObject *obj)\n{\n\tstruct pyrf_evlist *pevlist = (void *)obj;\n\n\treturn pevlist->evlist.core.nr_entries;\n}\n\nstatic PyObject *pyrf_evlist__item(PyObject *obj, Py_ssize_t i)\n{\n\tstruct pyrf_evlist *pevlist = (void *)obj;\n\tstruct evsel *pos;\n\n\tif (i >= pevlist->evlist.core.nr_entries)\n\t\treturn NULL;\n\n\tevlist__for_each_entry(&pevlist->evlist, pos) {\n\t\tif (i-- == 0)\n\t\t\tbreak;\n\t}\n\n\treturn Py_BuildValue(\"O\", container_of(pos, struct pyrf_evsel, evsel));\n}\n\nstatic PySequenceMethods pyrf_evlist__sequence_methods = {\n\t.sq_length = pyrf_evlist__length,\n\t.sq_item   = pyrf_evlist__item,\n};\n\nstatic char pyrf_evlist__doc[] = PyDoc_STR(\"perf event selector list object.\");\n\nstatic PyTypeObject pyrf_evlist__type = {\n\tPyVarObject_HEAD_INIT(NULL, 0)\n\t.tp_name\t= \"perf.evlist\",\n\t.tp_basicsize\t= sizeof(struct pyrf_evlist),\n\t.tp_dealloc\t= (destructor)pyrf_evlist__delete,\n\t.tp_flags\t= Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,\n\t.tp_as_sequence\t= &pyrf_evlist__sequence_methods,\n\t.tp_doc\t\t= pyrf_evlist__doc,\n\t.tp_methods\t= pyrf_evlist__methods,\n\t.tp_init\t= (initproc)pyrf_evlist__init,\n};\n\nstatic int pyrf_evlist__setup_types(void)\n{\n\tpyrf_evlist__type.tp_new = PyType_GenericNew;\n\treturn PyType_Ready(&pyrf_evlist__type);\n}\n\n#define PERF_CONST(name) { #name, PERF_##name }\n\nstatic struct {\n\tconst char *name;\n\tint\t    value;\n} perf__constants[] = {\n\tPERF_CONST(TYPE_HARDWARE),\n\tPERF_CONST(TYPE_SOFTWARE),\n\tPERF_CONST(TYPE_TRACEPOINT),\n\tPERF_CONST(TYPE_HW_CACHE),\n\tPERF_CONST(TYPE_RAW),\n\tPERF_CONST(TYPE_BREAKPOINT),\n\n\tPERF_CONST(COUNT_HW_CPU_CYCLES),\n\tPERF_CONST(COUNT_HW_INSTRUCTIONS),\n\tPERF_CONST(COUNT_HW_CACHE_REFERENCES),\n\tPERF_CONST(COUNT_HW_CACHE_MISSES),\n\tPERF_CONST(COUNT_HW_BRANCH_INSTRUCTIONS),\n\tPERF_CONST(COUNT_HW_BRANCH_MISSES),\n\tPERF_CONST(COUNT_HW_BUS_CYCLES),\n\tPERF_CONST(COUNT_HW_CACHE_L1D),\n\tPERF_CONST(COUNT_HW_CACHE_L1I),\n\tPERF_CONST(COUNT_HW_CACHE_LL),\n\tPERF_CONST(COUNT_HW_CACHE_DTLB),\n\tPERF_CONST(COUNT_HW_CACHE_ITLB),\n\tPERF_CONST(COUNT_HW_CACHE_BPU),\n\tPERF_CONST(COUNT_HW_CACHE_OP_READ),\n\tPERF_CONST(COUNT_HW_CACHE_OP_WRITE),\n\tPERF_CONST(COUNT_HW_CACHE_OP_PREFETCH),\n\tPERF_CONST(COUNT_HW_CACHE_RESULT_ACCESS),\n\tPERF_CONST(COUNT_HW_CACHE_RESULT_MISS),\n\n\tPERF_CONST(COUNT_HW_STALLED_CYCLES_FRONTEND),\n\tPERF_CONST(COUNT_HW_STALLED_CYCLES_BACKEND),\n\n\tPERF_CONST(COUNT_SW_CPU_CLOCK),\n\tPERF_CONST(COUNT_SW_TASK_CLOCK),\n\tPERF_CONST(COUNT_SW_PAGE_FAULTS),\n\tPERF_CONST(COUNT_SW_CONTEXT_SWITCHES),\n\tPERF_CONST(COUNT_SW_CPU_MIGRATIONS),\n\tPERF_CONST(COUNT_SW_PAGE_FAULTS_MIN),\n\tPERF_CONST(COUNT_SW_PAGE_FAULTS_MAJ),\n\tPERF_CONST(COUNT_SW_ALIGNMENT_FAULTS),\n\tPERF_CONST(COUNT_SW_EMULATION_FAULTS),\n\tPERF_CONST(COUNT_SW_DUMMY),\n\n\tPERF_CONST(SAMPLE_IP),\n\tPERF_CONST(SAMPLE_TID),\n\tPERF_CONST(SAMPLE_TIME),\n\tPERF_CONST(SAMPLE_ADDR),\n\tPERF_CONST(SAMPLE_READ),\n\tPERF_CONST(SAMPLE_CALLCHAIN),\n\tPERF_CONST(SAMPLE_ID),\n\tPERF_CONST(SAMPLE_CPU),\n\tPERF_CONST(SAMPLE_PERIOD),\n\tPERF_CONST(SAMPLE_STREAM_ID),\n\tPERF_CONST(SAMPLE_RAW),\n\n\tPERF_CONST(FORMAT_TOTAL_TIME_ENABLED),\n\tPERF_CONST(FORMAT_TOTAL_TIME_RUNNING),\n\tPERF_CONST(FORMAT_ID),\n\tPERF_CONST(FORMAT_GROUP),\n\n\tPERF_CONST(RECORD_MMAP),\n\tPERF_CONST(RECORD_LOST),\n\tPERF_CONST(RECORD_COMM),\n\tPERF_CONST(RECORD_EXIT),\n\tPERF_CONST(RECORD_THROTTLE),\n\tPERF_CONST(RECORD_UNTHROTTLE),\n\tPERF_CONST(RECORD_FORK),\n\tPERF_CONST(RECORD_READ),\n\tPERF_CONST(RECORD_SAMPLE),\n\tPERF_CONST(RECORD_MMAP2),\n\tPERF_CONST(RECORD_AUX),\n\tPERF_CONST(RECORD_ITRACE_START),\n\tPERF_CONST(RECORD_LOST_SAMPLES),\n\tPERF_CONST(RECORD_SWITCH),\n\tPERF_CONST(RECORD_SWITCH_CPU_WIDE),\n\n\tPERF_CONST(RECORD_MISC_SWITCH_OUT),\n\t{ .name = NULL, },\n};\n\nstatic PyObject *pyrf__tracepoint(struct pyrf_evsel *pevsel,\n\t\t\t\t  PyObject *args, PyObject *kwargs)\n{\n#ifndef HAVE_LIBTRACEEVENT\n\treturn NULL;\n#else\n\tstruct tep_event *tp_format;\n\tstatic char *kwlist[] = { \"sys\", \"name\", NULL };\n\tchar *sys  = NULL;\n\tchar *name = NULL;\n\n\tif (!PyArg_ParseTupleAndKeywords(args, kwargs, \"|ss\", kwlist,\n\t\t\t\t\t &sys, &name))\n\t\treturn NULL;\n\n\ttp_format = trace_event__tp_format(sys, name);\n\tif (IS_ERR(tp_format))\n\t\treturn _PyLong_FromLong(-1);\n\n\treturn _PyLong_FromLong(tp_format->id);\n#endif \n}\n\nstatic PyMethodDef perf__methods[] = {\n\t{\n\t\t.ml_name  = \"tracepoint\",\n\t\t.ml_meth  = (PyCFunction) pyrf__tracepoint,\n\t\t.ml_flags = METH_VARARGS | METH_KEYWORDS,\n\t\t.ml_doc\t  = PyDoc_STR(\"Get tracepoint config.\")\n\t},\n\t{ .ml_name = NULL, }\n};\n\n#if PY_MAJOR_VERSION < 3\nPyMODINIT_FUNC initperf(void)\n#else\nPyMODINIT_FUNC PyInit_perf(void)\n#endif\n{\n\tPyObject *obj;\n\tint i;\n\tPyObject *dict;\n#if PY_MAJOR_VERSION < 3\n\tPyObject *module = Py_InitModule(\"perf\", perf__methods);\n#else\n\tstatic struct PyModuleDef moduledef = {\n\t\tPyModuleDef_HEAD_INIT,\n\t\t\"perf\",\t\t\t \n\t\t\"\",\t\t\t \n\t\t-1,\t\t\t \n\t\tperf__methods,\t\t \n\t\tNULL,\t\t\t \n\t\tNULL,\t\t\t \n\t\tNULL,\t\t\t \n\t\tNULL,\t\t\t \n\t};\n\tPyObject *module = PyModule_Create(&moduledef);\n#endif\n\n\tif (module == NULL ||\n\t    pyrf_event__setup_types() < 0 ||\n\t    pyrf_evlist__setup_types() < 0 ||\n\t    pyrf_evsel__setup_types() < 0 ||\n\t    pyrf_thread_map__setup_types() < 0 ||\n\t    pyrf_cpu_map__setup_types() < 0)\n#if PY_MAJOR_VERSION < 3\n\t\treturn;\n#else\n\t\treturn module;\n#endif\n\n\t \n\tpage_size = sysconf(_SC_PAGE_SIZE);\n\n\tPy_INCREF(&pyrf_evlist__type);\n\tPyModule_AddObject(module, \"evlist\", (PyObject*)&pyrf_evlist__type);\n\n\tPy_INCREF(&pyrf_evsel__type);\n\tPyModule_AddObject(module, \"evsel\", (PyObject*)&pyrf_evsel__type);\n\n\tPy_INCREF(&pyrf_mmap_event__type);\n\tPyModule_AddObject(module, \"mmap_event\", (PyObject *)&pyrf_mmap_event__type);\n\n\tPy_INCREF(&pyrf_lost_event__type);\n\tPyModule_AddObject(module, \"lost_event\", (PyObject *)&pyrf_lost_event__type);\n\n\tPy_INCREF(&pyrf_comm_event__type);\n\tPyModule_AddObject(module, \"comm_event\", (PyObject *)&pyrf_comm_event__type);\n\n\tPy_INCREF(&pyrf_task_event__type);\n\tPyModule_AddObject(module, \"task_event\", (PyObject *)&pyrf_task_event__type);\n\n\tPy_INCREF(&pyrf_throttle_event__type);\n\tPyModule_AddObject(module, \"throttle_event\", (PyObject *)&pyrf_throttle_event__type);\n\n\tPy_INCREF(&pyrf_task_event__type);\n\tPyModule_AddObject(module, \"task_event\", (PyObject *)&pyrf_task_event__type);\n\n\tPy_INCREF(&pyrf_read_event__type);\n\tPyModule_AddObject(module, \"read_event\", (PyObject *)&pyrf_read_event__type);\n\n\tPy_INCREF(&pyrf_sample_event__type);\n\tPyModule_AddObject(module, \"sample_event\", (PyObject *)&pyrf_sample_event__type);\n\n\tPy_INCREF(&pyrf_context_switch_event__type);\n\tPyModule_AddObject(module, \"switch_event\", (PyObject *)&pyrf_context_switch_event__type);\n\n\tPy_INCREF(&pyrf_thread_map__type);\n\tPyModule_AddObject(module, \"thread_map\", (PyObject*)&pyrf_thread_map__type);\n\n\tPy_INCREF(&pyrf_cpu_map__type);\n\tPyModule_AddObject(module, \"cpu_map\", (PyObject*)&pyrf_cpu_map__type);\n\n\tdict = PyModule_GetDict(module);\n\tif (dict == NULL)\n\t\tgoto error;\n\n\tfor (i = 0; perf__constants[i].name != NULL; i++) {\n\t\tobj = _PyLong_FromLong(perf__constants[i].value);\n\t\tif (obj == NULL)\n\t\t\tgoto error;\n\t\tPyDict_SetItemString(dict, perf__constants[i].name, obj);\n\t\tPy_DECREF(obj);\n\t}\n\nerror:\n\tif (PyErr_Occurred())\n\t\tPyErr_SetString(PyExc_ImportError, \"perf: Init failed!\");\n#if PY_MAJOR_VERSION >= 3\n\treturn module;\n#endif\n}\n\n \nvoid test_attr__open(struct perf_event_attr *attr, pid_t pid, struct perf_cpu cpu,\n                     int fd, int group_fd, unsigned long flags)\n{\n}\n\nvoid evlist__free_stats(struct evlist *evlist)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}