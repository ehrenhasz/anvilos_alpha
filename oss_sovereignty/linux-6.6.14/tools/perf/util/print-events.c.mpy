{
  "module_name": "print-events.c",
  "hash_id": "77f7f2cdd8f656f8cf938d48d6c86c4b0ac7ad7788e97fb2a4f0707ca998ae83",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/print-events.c",
  "human_readable_source": "\n#include <dirent.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <unistd.h>\n\n#include <api/fs/tracing_path.h>\n#include <linux/stddef.h>\n#include <linux/perf_event.h>\n#include <linux/zalloc.h>\n#include <subcmd/pager.h>\n\n#include \"build-id.h\"\n#include \"debug.h\"\n#include \"evsel.h\"\n#include \"metricgroup.h\"\n#include \"parse-events.h\"\n#include \"pmu.h\"\n#include \"pmus.h\"\n#include \"print-events.h\"\n#include \"probe-file.h\"\n#include \"string2.h\"\n#include \"strlist.h\"\n#include \"tracepoint.h\"\n#include \"pfm.h\"\n#include \"thread_map.h\"\n\n#define MAX_NAME_LEN 100\n\n \nstatic const char * const event_type_descriptors[] = {\n\t\"Hardware event\",\n\t\"Software event\",\n\t\"Tracepoint event\",\n\t\"Hardware cache event\",\n\t\"Raw hardware event descriptor\",\n\t\"Hardware breakpoint\",\n};\n\nstatic const struct event_symbol event_symbols_tool[PERF_TOOL_MAX] = {\n\t[PERF_TOOL_DURATION_TIME] = {\n\t\t.symbol = \"duration_time\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_TOOL_USER_TIME] = {\n\t\t.symbol = \"user_time\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_TOOL_SYSTEM_TIME] = {\n\t\t.symbol = \"system_time\",\n\t\t.alias  = \"\",\n\t},\n};\n\n \nvoid print_tracepoint_events(const struct print_callbacks *print_cb __maybe_unused, void *print_state __maybe_unused)\n{\n\tchar *events_path = get_tracing_file(\"events\");\n\tint events_fd = open(events_path, O_PATH);\n\n\tput_tracing_file(events_path);\n\tif (events_fd < 0) {\n\t\tprintf(\"Error: failed to open tracing events directory\\n\");\n\t\treturn;\n\t}\n\n#ifdef HAVE_SCANDIRAT_SUPPORT\n{\n\tstruct dirent **sys_namelist = NULL;\n\tint sys_items = tracing_events__scandir_alphasort(&sys_namelist);\n\n\tfor (int i = 0; i < sys_items; i++) {\n\t\tstruct dirent *sys_dirent = sys_namelist[i];\n\t\tstruct dirent **evt_namelist = NULL;\n\t\tint dir_fd;\n\t\tint evt_items;\n\n\t\tif (sys_dirent->d_type != DT_DIR ||\n\t\t    !strcmp(sys_dirent->d_name, \".\") ||\n\t\t    !strcmp(sys_dirent->d_name, \"..\"))\n\t\t\tgoto next_sys;\n\n\t\tdir_fd = openat(events_fd, sys_dirent->d_name, O_PATH);\n\t\tif (dir_fd < 0)\n\t\t\tgoto next_sys;\n\n\t\tevt_items = scandirat(events_fd, sys_dirent->d_name, &evt_namelist, NULL, alphasort);\n\t\tfor (int j = 0; j < evt_items; j++) {\n\t\t\tstruct dirent *evt_dirent = evt_namelist[j];\n\t\t\tchar evt_path[MAXPATHLEN];\n\t\t\tint evt_fd;\n\n\t\t\tif (evt_dirent->d_type != DT_DIR ||\n\t\t\t    !strcmp(evt_dirent->d_name, \".\") ||\n\t\t\t    !strcmp(evt_dirent->d_name, \"..\"))\n\t\t\t\tgoto next_evt;\n\n\t\t\tsnprintf(evt_path, sizeof(evt_path), \"%s/id\", evt_dirent->d_name);\n\t\t\tevt_fd = openat(dir_fd, evt_path, O_RDONLY);\n\t\t\tif (evt_fd < 0)\n\t\t\t\tgoto next_evt;\n\t\t\tclose(evt_fd);\n\n\t\t\tsnprintf(evt_path, MAXPATHLEN, \"%s:%s\",\n\t\t\t\t sys_dirent->d_name, evt_dirent->d_name);\n\t\t\tprint_cb->print_event(print_state,\n\t\t\t\t\t NULL,\n\t\t\t\t\t NULL,\n\t\t\t\t\tevt_path,\n\t\t\t\t\t NULL,\n\t\t\t\t\t NULL,\n\t\t\t\t\t false,\n\t\t\t\t\t\"Tracepoint event\",\n\t\t\t\t\t NULL,\n\t\t\t\t\t NULL,\n\t\t\t\t\t NULL);\nnext_evt:\n\t\t\tfree(evt_namelist[j]);\n\t\t}\n\t\tclose(dir_fd);\n\t\tfree(evt_namelist);\nnext_sys:\n\t\tfree(sys_namelist[i]);\n\t}\n\n\tfree(sys_namelist);\n}\n#else\n\tprintf(\"\\nWARNING: Your libc doesn't have the scandirat function, please ask its maintainers to implement it.\\n\"\n\t       \"         As a rough fallback, please do 'ls %s' to see the available tracepoint events.\\n\", events_path);\n#endif\n\tclose(events_fd);\n}\n\nvoid print_sdt_events(const struct print_callbacks *print_cb, void *print_state)\n{\n\tstruct strlist *bidlist, *sdtlist;\n\tstruct str_node *bid_nd, *sdt_name, *next_sdt_name;\n\tconst char *last_sdt_name = NULL;\n\n\t \n\tsdtlist = strlist__new(NULL, NULL);\n\tif (!sdtlist) {\n\t\tpr_debug(\"Failed to allocate new strlist for SDT\\n\");\n\t\treturn;\n\t}\n\tbidlist = build_id_cache__list_all(true);\n\tif (!bidlist) {\n\t\tpr_debug(\"Failed to get buildids: %d\\n\", errno);\n\t\treturn;\n\t}\n\tstrlist__for_each_entry(bid_nd, bidlist) {\n\t\tstruct probe_cache *pcache;\n\t\tstruct probe_cache_entry *ent;\n\n\t\tpcache = probe_cache__new(bid_nd->s, NULL);\n\t\tif (!pcache)\n\t\t\tcontinue;\n\t\tlist_for_each_entry(ent, &pcache->entries, node) {\n\t\t\tchar buf[1024];\n\n\t\t\tsnprintf(buf, sizeof(buf), \"%s:%s@%s\",\n\t\t\t\t ent->pev.group, ent->pev.event, bid_nd->s);\n\t\t\tstrlist__add(sdtlist, buf);\n\t\t}\n\t\tprobe_cache__delete(pcache);\n\t}\n\tstrlist__delete(bidlist);\n\n\tstrlist__for_each_entry(sdt_name, sdtlist) {\n\t\tbool show_detail = false;\n\t\tchar *bid = strchr(sdt_name->s, '@');\n\t\tchar *evt_name = NULL;\n\n\t\tif (bid)\n\t\t\t*(bid++) = '\\0';\n\n\t\tif (last_sdt_name && !strcmp(last_sdt_name, sdt_name->s)) {\n\t\t\tshow_detail = true;\n\t\t} else {\n\t\t\tnext_sdt_name = strlist__next(sdt_name);\n\t\t\tif (next_sdt_name) {\n\t\t\t\tchar *bid2 = strchr(next_sdt_name->s, '@');\n\n\t\t\t\tif (bid2)\n\t\t\t\t\t*bid2 = '\\0';\n\t\t\t\tif (strcmp(sdt_name->s, next_sdt_name->s) == 0)\n\t\t\t\t\tshow_detail = true;\n\t\t\t\tif (bid2)\n\t\t\t\t\t*bid2 = '@';\n\t\t\t}\n\t\t}\n\t\tlast_sdt_name = sdt_name->s;\n\n\t\tif (show_detail) {\n\t\t\tchar *path = build_id_cache__origname(bid);\n\n\t\t\tif (path) {\n\t\t\t\tif (asprintf(&evt_name, \"%s@%s(%.12s)\", sdt_name->s, path, bid) < 0)\n\t\t\t\t\tevt_name = NULL;\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t}\n\t\tprint_cb->print_event(print_state,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\tevt_name ?: sdt_name->s,\n\t\t\t\t NULL,\n\t\t\t\t false,\n\t\t\t\t NULL,\n\t\t\t\t\"SDT event\",\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL);\n\n\t\tfree(evt_name);\n\t}\n\tstrlist__delete(sdtlist);\n}\n\nbool is_event_supported(u8 type, u64 config)\n{\n\tbool ret = true;\n\tint open_return;\n\tstruct evsel *evsel;\n\tstruct perf_event_attr attr = {\n\t\t.type = type,\n\t\t.config = config,\n\t\t.disabled = 1,\n\t};\n\tstruct perf_thread_map *tmap = thread_map__new_by_tid(0);\n\n\tif (tmap == NULL)\n\t\treturn false;\n\n\tevsel = evsel__new(&attr);\n\tif (evsel) {\n\t\topen_return = evsel__open(evsel, NULL, tmap);\n\t\tret = open_return >= 0;\n\n\t\tif (open_return == -EACCES) {\n\t\t\t \n\t\t\tevsel->core.attr.exclude_kernel = 1;\n\t\t\tret = evsel__open(evsel, NULL, tmap) >= 0;\n\t\t}\n\t\tevsel__delete(evsel);\n\t}\n\n\tperf_thread_map__put(tmap);\n\treturn ret;\n}\n\nint print_hwcache_events(const struct print_callbacks *print_cb, void *print_state)\n{\n\tstruct perf_pmu *pmu = NULL;\n\tconst char *event_type_descriptor = event_type_descriptors[PERF_TYPE_HW_CACHE];\n\n\t \n\twhile ((pmu = perf_pmus__scan_core(pmu)) != NULL) {\n\t\tif (pmu->is_uncore || pmu->type == PERF_TYPE_SOFTWARE)\n\t\t\tcontinue;\n\n\t\tfor (int type = 0; type < PERF_COUNT_HW_CACHE_MAX; type++) {\n\t\t\tfor (int op = 0; op < PERF_COUNT_HW_CACHE_OP_MAX; op++) {\n\t\t\t\t \n\t\t\t\tif (!evsel__is_cache_op_valid(type, op))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (int res = 0; res < PERF_COUNT_HW_CACHE_RESULT_MAX; res++) {\n\t\t\t\t\tchar name[64];\n\t\t\t\t\tchar alias_name[128];\n\t\t\t\t\t__u64 config;\n\t\t\t\t\tint ret;\n\n\t\t\t\t\t__evsel__hw_cache_type_op_res_name(type, op, res,\n\t\t\t\t\t\t\t\t\tname, sizeof(name));\n\n\t\t\t\t\tret = parse_events__decode_legacy_cache(name, pmu->type,\n\t\t\t\t\t\t\t\t\t\t&config);\n\t\t\t\t\tif (ret || !is_event_supported(PERF_TYPE_HW_CACHE, config))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tsnprintf(alias_name, sizeof(alias_name), \"%s/%s/\",\n\t\t\t\t\t\t pmu->name, name);\n\t\t\t\t\tprint_cb->print_event(print_state,\n\t\t\t\t\t\t\t\"cache\",\n\t\t\t\t\t\t\tpmu->name,\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\talias_name,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t false,\n\t\t\t\t\t\t\tevent_type_descriptor,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid print_tool_events(const struct print_callbacks *print_cb, void *print_state)\n{\n\t \n\tfor (int i = 1; i < PERF_TOOL_MAX; ++i) {\n\t\tprint_cb->print_event(print_state,\n\t\t\t\t\"tool\",\n\t\t\t\t NULL,\n\t\t\t\tevent_symbols_tool[i].symbol,\n\t\t\t\tevent_symbols_tool[i].alias,\n\t\t\t\t NULL,\n\t\t\t\t false,\n\t\t\t\t\"Tool event\",\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL);\n\t}\n}\n\nvoid print_symbol_events(const struct print_callbacks *print_cb, void *print_state,\n\t\t\t unsigned int type, const struct event_symbol *syms,\n\t\t\t unsigned int max)\n{\n\tstruct strlist *evt_name_list = strlist__new(NULL, NULL);\n\tstruct str_node *nd;\n\n\tif (!evt_name_list) {\n\t\tpr_debug(\"Failed to allocate new strlist for symbol events\\n\");\n\t\treturn;\n\t}\n\tfor (unsigned int i = 0; i < max; i++) {\n\t\t \n\t\tif (syms[i].symbol == NULL)\n\t\t\tcontinue;\n\n\t\tif (!is_event_supported(type, i))\n\t\t\tcontinue;\n\n\t\tif (strlen(syms[i].alias)) {\n\t\t\tchar name[MAX_NAME_LEN];\n\n\t\t\tsnprintf(name, MAX_NAME_LEN, \"%s OR %s\", syms[i].symbol, syms[i].alias);\n\t\t\tstrlist__add(evt_name_list, name);\n\t\t} else\n\t\t\tstrlist__add(evt_name_list, syms[i].symbol);\n\t}\n\n\tstrlist__for_each_entry(nd, evt_name_list) {\n\t\tchar *alias = strstr(nd->s, \" OR \");\n\n\t\tif (alias) {\n\t\t\t*alias = '\\0';\n\t\t\talias += 4;\n\t\t}\n\t\tprint_cb->print_event(print_state,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\tnd->s,\n\t\t\t\talias,\n\t\t\t\t NULL,\n\t\t\t\t false,\n\t\t\t\tevent_type_descriptors[type],\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL);\n\t}\n\tstrlist__delete(evt_name_list);\n}\n\n \nvoid print_events(const struct print_callbacks *print_cb, void *print_state)\n{\n\tprint_symbol_events(print_cb, print_state, PERF_TYPE_HARDWARE,\n\t\t\tevent_symbols_hw, PERF_COUNT_HW_MAX);\n\tprint_symbol_events(print_cb, print_state, PERF_TYPE_SOFTWARE,\n\t\t\tevent_symbols_sw, PERF_COUNT_SW_MAX);\n\n\tprint_tool_events(print_cb, print_state);\n\n\tprint_hwcache_events(print_cb, print_state);\n\n\tperf_pmus__print_pmu_events(print_cb, print_state);\n\n\tprint_cb->print_event(print_state,\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t\"rNNN\",\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t false,\n\t\t\tevent_type_descriptors[PERF_TYPE_RAW],\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t NULL);\n\n\tprint_cb->print_event(print_state,\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t\"cpu/t1=v1[,t2=v2,t3 ...]/modifier\",\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t false,\n\t\t\tevent_type_descriptors[PERF_TYPE_RAW],\n\t\t\t\"(see 'man perf-list' on how to encode it)\",\n\t\t\t NULL,\n\t\t\t NULL);\n\n\tprint_cb->print_event(print_state,\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t\"mem:<addr>[/len][:access]\",\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t false,\n\t\t\tevent_type_descriptors[PERF_TYPE_BREAKPOINT],\n\t\t\t NULL,\n\t\t\t NULL,\n\t\t\t NULL);\n\n\tprint_tracepoint_events(print_cb, print_state);\n\n\tprint_sdt_events(print_cb, print_state);\n\n\tmetricgroup__print(print_cb, print_state);\n\n\tprint_libpfm_events(print_cb, print_state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}