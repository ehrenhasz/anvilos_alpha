{
  "module_name": "cputopo.c",
  "hash_id": "6304ac129e06181ff22775aa6604ffc88d147a1b831e28d469d60cb7665b6ce1",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/cputopo.c",
  "human_readable_source": "\n#include <sys/param.h>\n#include <sys/utsname.h>\n#include <inttypes.h>\n#include <stdlib.h>\n#include <string.h>\n#include <api/fs/fs.h>\n#include <linux/zalloc.h>\n#include <perf/cpumap.h>\n\n#include \"cputopo.h\"\n#include \"cpumap.h\"\n#include \"debug.h\"\n#include \"env.h\"\n#include \"pmu.h\"\n#include \"pmus.h\"\n\n#define PACKAGE_CPUS_FMT \\\n\t\"%s/devices/system/cpu/cpu%d/topology/package_cpus_list\"\n#define PACKAGE_CPUS_FMT_OLD \\\n\t\"%s/devices/system/cpu/cpu%d/topology/core_siblings_list\"\n#define DIE_CPUS_FMT \\\n\t\"%s/devices/system/cpu/cpu%d/topology/die_cpus_list\"\n#define CORE_CPUS_FMT \\\n\t\"%s/devices/system/cpu/cpu%d/topology/core_cpus_list\"\n#define CORE_CPUS_FMT_OLD \\\n\t\"%s/devices/system/cpu/cpu%d/topology/thread_siblings_list\"\n#define NODE_ONLINE_FMT \\\n\t\"%s/devices/system/node/online\"\n#define NODE_MEMINFO_FMT \\\n\t\"%s/devices/system/node/node%d/meminfo\"\n#define NODE_CPULIST_FMT \\\n\t\"%s/devices/system/node/node%d/cpulist\"\n\nstatic int build_cpu_topology(struct cpu_topology *tp, int cpu)\n{\n\tFILE *fp;\n\tchar filename[MAXPATHLEN];\n\tchar *buf = NULL, *p;\n\tsize_t len = 0;\n\tssize_t sret;\n\tu32 i = 0;\n\tint ret = -1;\n\n\tscnprintf(filename, MAXPATHLEN, PACKAGE_CPUS_FMT,\n\t\t  sysfs__mountpoint(), cpu);\n\tif (access(filename, F_OK) == -1) {\n\t\tscnprintf(filename, MAXPATHLEN, PACKAGE_CPUS_FMT_OLD,\n\t\t\tsysfs__mountpoint(), cpu);\n\t}\n\tfp = fopen(filename, \"r\");\n\tif (!fp)\n\t\tgoto try_dies;\n\n\tsret = getline(&buf, &len, fp);\n\tfclose(fp);\n\tif (sret <= 0)\n\t\tgoto try_dies;\n\n\tp = strchr(buf, '\\n');\n\tif (p)\n\t\t*p = '\\0';\n\n\tfor (i = 0; i < tp->package_cpus_lists; i++) {\n\t\tif (!strcmp(buf, tp->package_cpus_list[i]))\n\t\t\tbreak;\n\t}\n\tif (i == tp->package_cpus_lists) {\n\t\ttp->package_cpus_list[i] = buf;\n\t\ttp->package_cpus_lists++;\n\t\tbuf = NULL;\n\t\tlen = 0;\n\t}\n\tret = 0;\n\ntry_dies:\n\tif (!tp->die_cpus_list)\n\t\tgoto try_threads;\n\n\tscnprintf(filename, MAXPATHLEN, DIE_CPUS_FMT,\n\t\t  sysfs__mountpoint(), cpu);\n\tfp = fopen(filename, \"r\");\n\tif (!fp)\n\t\tgoto try_threads;\n\n\tsret = getline(&buf, &len, fp);\n\tfclose(fp);\n\tif (sret <= 0)\n\t\tgoto try_threads;\n\n\tp = strchr(buf, '\\n');\n\tif (p)\n\t\t*p = '\\0';\n\n\tfor (i = 0; i < tp->die_cpus_lists; i++) {\n\t\tif (!strcmp(buf, tp->die_cpus_list[i]))\n\t\t\tbreak;\n\t}\n\tif (i == tp->die_cpus_lists) {\n\t\ttp->die_cpus_list[i] = buf;\n\t\ttp->die_cpus_lists++;\n\t\tbuf = NULL;\n\t\tlen = 0;\n\t}\n\tret = 0;\n\ntry_threads:\n\tscnprintf(filename, MAXPATHLEN, CORE_CPUS_FMT,\n\t\t  sysfs__mountpoint(), cpu);\n\tif (access(filename, F_OK) == -1) {\n\t\tscnprintf(filename, MAXPATHLEN, CORE_CPUS_FMT_OLD,\n\t\t\t  sysfs__mountpoint(), cpu);\n\t}\n\tfp = fopen(filename, \"r\");\n\tif (!fp)\n\t\tgoto done;\n\n\tif (getline(&buf, &len, fp) <= 0)\n\t\tgoto done;\n\n\tp = strchr(buf, '\\n');\n\tif (p)\n\t\t*p = '\\0';\n\n\tfor (i = 0; i < tp->core_cpus_lists; i++) {\n\t\tif (!strcmp(buf, tp->core_cpus_list[i]))\n\t\t\tbreak;\n\t}\n\tif (i == tp->core_cpus_lists) {\n\t\ttp->core_cpus_list[i] = buf;\n\t\ttp->core_cpus_lists++;\n\t\tbuf = NULL;\n\t}\n\tret = 0;\ndone:\n\tif (fp)\n\t\tfclose(fp);\n\tfree(buf);\n\treturn ret;\n}\n\nvoid cpu_topology__delete(struct cpu_topology *tp)\n{\n\tu32 i;\n\n\tif (!tp)\n\t\treturn;\n\n\tfor (i = 0 ; i < tp->package_cpus_lists; i++)\n\t\tzfree(&tp->package_cpus_list[i]);\n\n\tfor (i = 0 ; i < tp->die_cpus_lists; i++)\n\t\tzfree(&tp->die_cpus_list[i]);\n\n\tfor (i = 0 ; i < tp->core_cpus_lists; i++)\n\t\tzfree(&tp->core_cpus_list[i]);\n\n\tfree(tp);\n}\n\nbool cpu_topology__smt_on(const struct cpu_topology *topology)\n{\n\tfor (u32 i = 0; i < topology->core_cpus_lists; i++) {\n\t\tconst char *cpu_list = topology->core_cpus_list[i];\n\n\t\t \n\t\tif (strchr(cpu_list, ',') || strchr(cpu_list, '-'))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool cpu_topology__core_wide(const struct cpu_topology *topology,\n\t\t\t     const char *user_requested_cpu_list)\n{\n\tstruct perf_cpu_map *user_requested_cpus;\n\n\t \n\tif (!user_requested_cpu_list)\n\t\treturn true;\n\n\tuser_requested_cpus = perf_cpu_map__new(user_requested_cpu_list);\n\t \n\tfor (u32 i = 0; i < topology->core_cpus_lists; i++) {\n\t\tconst char *core_cpu_list = topology->core_cpus_list[i];\n\t\tstruct perf_cpu_map *core_cpus = perf_cpu_map__new(core_cpu_list);\n\t\tstruct perf_cpu cpu;\n\t\tint idx;\n\t\tbool has_first, first = true;\n\n\t\tperf_cpu_map__for_each_cpu(cpu, idx, core_cpus) {\n\t\t\tif (first) {\n\t\t\t\thas_first = perf_cpu_map__has(user_requested_cpus, cpu);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (perf_cpu_map__has(user_requested_cpus, cpu) != has_first) {\n\t\t\t\t\tperf_cpu_map__put(core_cpus);\n\t\t\t\t\tperf_cpu_map__put(user_requested_cpus);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tperf_cpu_map__put(core_cpus);\n\t}\n\tperf_cpu_map__put(user_requested_cpus);\n\treturn true;\n}\n\nstatic bool has_die_topology(void)\n{\n\tchar filename[MAXPATHLEN];\n\tstruct utsname uts;\n\n\tif (uname(&uts) < 0)\n\t\treturn false;\n\n\tif (strncmp(uts.machine, \"x86_64\", 6) &&\n\t    strncmp(uts.machine, \"s390x\", 5))\n\t\treturn false;\n\n\tscnprintf(filename, MAXPATHLEN, DIE_CPUS_FMT,\n\t\t  sysfs__mountpoint(), 0);\n\tif (access(filename, F_OK) == -1)\n\t\treturn false;\n\n\treturn true;\n}\n\nconst struct cpu_topology *online_topology(void)\n{\n\tstatic const struct cpu_topology *topology;\n\n\tif (!topology) {\n\t\ttopology = cpu_topology__new();\n\t\tif (!topology) {\n\t\t\tpr_err(\"Error creating CPU topology\");\n\t\t\tabort();\n\t\t}\n\t}\n\treturn topology;\n}\n\nstruct cpu_topology *cpu_topology__new(void)\n{\n\tstruct cpu_topology *tp = NULL;\n\tvoid *addr;\n\tu32 nr, i, nr_addr;\n\tsize_t sz;\n\tlong ncpus;\n\tint ret = -1;\n\tstruct perf_cpu_map *map;\n\tbool has_die = has_die_topology();\n\n\tncpus = cpu__max_present_cpu().cpu;\n\n\t \n\tmap = perf_cpu_map__new(NULL);\n\tif (map == NULL) {\n\t\tpr_debug(\"failed to get system cpumap\\n\");\n\t\treturn NULL;\n\t}\n\n\tnr = (u32)(ncpus & UINT_MAX);\n\n\tsz = nr * sizeof(char *);\n\tif (has_die)\n\t\tnr_addr = 3;\n\telse\n\t\tnr_addr = 2;\n\taddr = calloc(1, sizeof(*tp) + nr_addr * sz);\n\tif (!addr)\n\t\tgoto out_free;\n\n\ttp = addr;\n\taddr += sizeof(*tp);\n\ttp->package_cpus_list = addr;\n\taddr += sz;\n\tif (has_die) {\n\t\ttp->die_cpus_list = addr;\n\t\taddr += sz;\n\t}\n\ttp->core_cpus_list = addr;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (!perf_cpu_map__has(map, (struct perf_cpu){ .cpu = i }))\n\t\t\tcontinue;\n\n\t\tret = build_cpu_topology(tp, i);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\nout_free:\n\tperf_cpu_map__put(map);\n\tif (ret) {\n\t\tcpu_topology__delete(tp);\n\t\ttp = NULL;\n\t}\n\treturn tp;\n}\n\nstatic int load_numa_node(struct numa_topology_node *node, int nr)\n{\n\tchar str[MAXPATHLEN];\n\tchar field[32];\n\tchar *buf = NULL, *p;\n\tsize_t len = 0;\n\tint ret = -1;\n\tFILE *fp;\n\tu64 mem;\n\n\tnode->node = (u32) nr;\n\n\tscnprintf(str, MAXPATHLEN, NODE_MEMINFO_FMT,\n\t\t  sysfs__mountpoint(), nr);\n\tfp = fopen(str, \"r\");\n\tif (!fp)\n\t\treturn -1;\n\n\twhile (getline(&buf, &len, fp) > 0) {\n\t\t \n\t\tif (!strchr(buf, ':'))\n\t\t\tcontinue;\n\t\tif (sscanf(buf, \"%*s %*d %31s %\"PRIu64, field, &mem) != 2)\n\t\t\tgoto err;\n\t\tif (!strcmp(field, \"MemTotal:\"))\n\t\t\tnode->mem_total = mem;\n\t\tif (!strcmp(field, \"MemFree:\"))\n\t\t\tnode->mem_free = mem;\n\t\tif (node->mem_total && node->mem_free)\n\t\t\tbreak;\n\t}\n\n\tfclose(fp);\n\tfp = NULL;\n\n\tscnprintf(str, MAXPATHLEN, NODE_CPULIST_FMT,\n\t\t  sysfs__mountpoint(), nr);\n\n\tfp = fopen(str, \"r\");\n\tif (!fp)\n\t\treturn -1;\n\n\tif (getline(&buf, &len, fp) <= 0)\n\t\tgoto err;\n\n\tp = strchr(buf, '\\n');\n\tif (p)\n\t\t*p = '\\0';\n\n\tnode->cpus = buf;\n\tfclose(fp);\n\treturn 0;\n\nerr:\n\tfree(buf);\n\tif (fp)\n\t\tfclose(fp);\n\treturn ret;\n}\n\nstruct numa_topology *numa_topology__new(void)\n{\n\tstruct perf_cpu_map *node_map = NULL;\n\tstruct numa_topology *tp = NULL;\n\tchar path[MAXPATHLEN];\n\tchar *buf = NULL;\n\tsize_t len = 0;\n\tu32 nr, i;\n\tFILE *fp;\n\tchar *c;\n\n\tscnprintf(path, MAXPATHLEN, NODE_ONLINE_FMT,\n\t\t  sysfs__mountpoint());\n\n\tfp = fopen(path, \"r\");\n\tif (!fp)\n\t\treturn NULL;\n\n\tif (getline(&buf, &len, fp) <= 0)\n\t\tgoto out;\n\n\tc = strchr(buf, '\\n');\n\tif (c)\n\t\t*c = '\\0';\n\n\tnode_map = perf_cpu_map__new(buf);\n\tif (!node_map)\n\t\tgoto out;\n\n\tnr = (u32) perf_cpu_map__nr(node_map);\n\n\ttp = zalloc(sizeof(*tp) + sizeof(tp->nodes[0])*nr);\n\tif (!tp)\n\t\tgoto out;\n\n\ttp->nr = nr;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (load_numa_node(&tp->nodes[i], perf_cpu_map__cpu(node_map, i).cpu)) {\n\t\t\tnuma_topology__delete(tp);\n\t\t\ttp = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tfree(buf);\n\tfclose(fp);\n\tperf_cpu_map__put(node_map);\n\treturn tp;\n}\n\nvoid numa_topology__delete(struct numa_topology *tp)\n{\n\tu32 i;\n\n\tfor (i = 0; i < tp->nr; i++)\n\t\tzfree(&tp->nodes[i].cpus);\n\n\tfree(tp);\n}\n\nstatic int load_hybrid_node(struct hybrid_topology_node *node,\n\t\t\t    struct perf_pmu *pmu)\n{\n\tchar *buf = NULL, *p;\n\tFILE *fp;\n\tsize_t len = 0;\n\n\tnode->pmu_name = strdup(pmu->name);\n\tif (!node->pmu_name)\n\t\treturn -1;\n\n\tfp = perf_pmu__open_file(pmu, \"cpus\");\n\tif (!fp)\n\t\tgoto err;\n\n\tif (getline(&buf, &len, fp) <= 0) {\n\t\tfclose(fp);\n\t\tgoto err;\n\t}\n\n\tp = strchr(buf, '\\n');\n\tif (p)\n\t\t*p = '\\0';\n\n\tfclose(fp);\n\tnode->cpus = buf;\n\treturn 0;\n\nerr:\n\tzfree(&node->pmu_name);\n\tfree(buf);\n\treturn -1;\n}\n\nstruct hybrid_topology *hybrid_topology__new(void)\n{\n\tstruct perf_pmu *pmu = NULL;\n\tstruct hybrid_topology *tp = NULL;\n\tint nr = perf_pmus__num_core_pmus(), i = 0;\n\n\tif (nr <= 1)\n\t\treturn NULL;\n\n\ttp = zalloc(sizeof(*tp) + sizeof(tp->nodes[0]) * nr);\n\tif (!tp)\n\t\treturn NULL;\n\n\ttp->nr = nr;\n\twhile ((pmu = perf_pmus__scan_core(pmu)) != NULL) {\n\t\tif (load_hybrid_node(&tp->nodes[i], pmu)) {\n\t\t\thybrid_topology__delete(tp);\n\t\t\treturn NULL;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn tp;\n}\n\nvoid hybrid_topology__delete(struct hybrid_topology *tp)\n{\n\tu32 i;\n\n\tfor (i = 0; i < tp->nr; i++) {\n\t\tzfree(&tp->nodes[i].pmu_name);\n\t\tzfree(&tp->nodes[i].cpus);\n\t}\n\n\tfree(tp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}