{
  "module_name": "cgroup.c",
  "hash_id": "41b077c0208536971025eec39904dd71eb584ce54cf9f6b591612e683cd84b74",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/cgroup.c",
  "human_readable_source": "\n#include <subcmd/parse-options.h>\n#include \"evsel.h\"\n#include \"cgroup.h\"\n#include \"evlist.h\"\n#include \"rblist.h\"\n#include \"metricgroup.h\"\n#include \"stat.h\"\n#include <linux/zalloc.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/statfs.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <api/fs/fs.h>\n#include <ftw.h>\n#include <regex.h>\n\nint nr_cgroups;\nbool cgrp_event_expanded;\n\n \nstruct cgroup_name {\n\tstruct list_head list;\n\tbool used;\n\tchar name[];\n};\nstatic LIST_HEAD(cgroup_list);\n\nstatic int open_cgroup(const char *name)\n{\n\tchar path[PATH_MAX + 1];\n\tchar mnt[PATH_MAX + 1];\n\tint fd;\n\n\n\tif (cgroupfs_find_mountpoint(mnt, PATH_MAX + 1, \"perf_event\"))\n\t\treturn -1;\n\n\tscnprintf(path, PATH_MAX, \"%s/%s\", mnt, name);\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\tfprintf(stderr, \"no access to cgroup %s\\n\", path);\n\n\treturn fd;\n}\n\n#ifdef HAVE_FILE_HANDLE\nint read_cgroup_id(struct cgroup *cgrp)\n{\n\tchar path[PATH_MAX + 1];\n\tchar mnt[PATH_MAX + 1];\n\tstruct {\n\t\tstruct file_handle fh;\n\t\tuint64_t cgroup_id;\n\t} handle;\n\tint mount_id;\n\n\tif (cgroupfs_find_mountpoint(mnt, PATH_MAX + 1, \"perf_event\"))\n\t\treturn -1;\n\n\tscnprintf(path, PATH_MAX, \"%s/%s\", mnt, cgrp->name);\n\n\thandle.fh.handle_bytes = sizeof(handle.cgroup_id);\n\tif (name_to_handle_at(AT_FDCWD, path, &handle.fh, &mount_id, 0) < 0)\n\t\treturn -1;\n\n\tcgrp->id = handle.cgroup_id;\n\treturn 0;\n}\n#endif   \n\n#ifndef CGROUP2_SUPER_MAGIC\n#define CGROUP2_SUPER_MAGIC  0x63677270\n#endif\n\nint cgroup_is_v2(const char *subsys)\n{\n\tchar mnt[PATH_MAX + 1];\n\tstruct statfs stbuf;\n\n\tif (cgroupfs_find_mountpoint(mnt, PATH_MAX + 1, subsys))\n\t\treturn -1;\n\n\tif (statfs(mnt, &stbuf) < 0)\n\t\treturn -1;\n\n\treturn (stbuf.f_type == CGROUP2_SUPER_MAGIC);\n}\n\nstatic struct cgroup *evlist__find_cgroup(struct evlist *evlist, const char *str)\n{\n\tstruct evsel *counter;\n\t \n\tevlist__for_each_entry(evlist, counter) {\n\t\tif (!counter->cgrp)\n\t\t\tcontinue;\n\t\tif (!strcmp(counter->cgrp->name, str))\n\t\t\treturn cgroup__get(counter->cgrp);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct cgroup *cgroup__new(const char *name, bool do_open)\n{\n\tstruct cgroup *cgroup = zalloc(sizeof(*cgroup));\n\n\tif (cgroup != NULL) {\n\t\trefcount_set(&cgroup->refcnt, 1);\n\n\t\tcgroup->name = strdup(name);\n\t\tif (!cgroup->name)\n\t\t\tgoto out_err;\n\n\t\tif (do_open) {\n\t\t\tcgroup->fd = open_cgroup(name);\n\t\t\tif (cgroup->fd == -1)\n\t\t\t\tgoto out_free_name;\n\t\t} else {\n\t\t\tcgroup->fd = -1;\n\t\t}\n\t}\n\n\treturn cgroup;\n\nout_free_name:\n\tzfree(&cgroup->name);\nout_err:\n\tfree(cgroup);\n\treturn NULL;\n}\n\nstruct cgroup *evlist__findnew_cgroup(struct evlist *evlist, const char *name)\n{\n\tstruct cgroup *cgroup = evlist__find_cgroup(evlist, name);\n\n\treturn cgroup ?: cgroup__new(name, true);\n}\n\nstatic int add_cgroup(struct evlist *evlist, const char *str)\n{\n\tstruct evsel *counter;\n\tstruct cgroup *cgrp = evlist__findnew_cgroup(evlist, str);\n\tint n;\n\n\tif (!cgrp)\n\t\treturn -1;\n\t \n\tn = 0;\n\tevlist__for_each_entry(evlist, counter) {\n\t\tif (n == nr_cgroups)\n\t\t\tgoto found;\n\t\tn++;\n\t}\n\n\tcgroup__put(cgrp);\n\treturn -1;\nfound:\n\tcounter->cgrp = cgrp;\n\treturn 0;\n}\n\nstatic void cgroup__delete(struct cgroup *cgroup)\n{\n\tif (cgroup->fd >= 0)\n\t\tclose(cgroup->fd);\n\tzfree(&cgroup->name);\n\tfree(cgroup);\n}\n\nvoid cgroup__put(struct cgroup *cgrp)\n{\n\tif (cgrp && refcount_dec_and_test(&cgrp->refcnt)) {\n\t\tcgroup__delete(cgrp);\n\t}\n}\n\nstruct cgroup *cgroup__get(struct cgroup *cgroup)\n{\n       if (cgroup)\n\t\trefcount_inc(&cgroup->refcnt);\n       return cgroup;\n}\n\nstatic void evsel__set_default_cgroup(struct evsel *evsel, struct cgroup *cgroup)\n{\n\tif (evsel->cgrp == NULL)\n\t\tevsel->cgrp = cgroup__get(cgroup);\n}\n\nvoid evlist__set_default_cgroup(struct evlist *evlist, struct cgroup *cgroup)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel)\n\t\tevsel__set_default_cgroup(evsel, cgroup);\n}\n\n \nstatic int add_cgroup_name(const char *fpath, const struct stat *sb __maybe_unused,\n\t\t\t   int typeflag, struct FTW *ftwbuf __maybe_unused)\n{\n\tstruct cgroup_name *cn;\n\n\tif (typeflag != FTW_D)\n\t\treturn 0;\n\n\tcn = malloc(sizeof(*cn) + strlen(fpath) + 1);\n\tif (cn == NULL)\n\t\treturn -1;\n\n\tcn->used = false;\n\tstrcpy(cn->name, fpath);\n\n\tlist_add_tail(&cn->list, &cgroup_list);\n\treturn 0;\n}\n\nstatic int check_and_add_cgroup_name(const char *fpath)\n{\n\tstruct cgroup_name *cn;\n\n\tlist_for_each_entry(cn, &cgroup_list, list) {\n\t\tif (!strcmp(cn->name, fpath))\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn add_cgroup_name(fpath, NULL, FTW_D, NULL);\n}\n\nstatic void release_cgroup_list(void)\n{\n\tstruct cgroup_name *cn;\n\n\twhile (!list_empty(&cgroup_list)) {\n\t\tcn = list_first_entry(&cgroup_list, struct cgroup_name, list);\n\t\tlist_del(&cn->list);\n\t\tfree(cn);\n\t}\n}\n\n \nstatic int list_cgroups(const char *str)\n{\n\tconst char *p, *e, *eos = str + strlen(str);\n\tstruct cgroup_name *cn;\n\tchar *s;\n\n\t \n\tfor (;;) {\n\t\tp = strchr(str, ',');\n\t\te = p ? p : eos;\n\n\t\tif (e - str) {\n\t\t\tint ret;\n\n\t\t\ts = strndup(str, e - str);\n\t\t\tif (!s)\n\t\t\t\treturn -1;\n\n\t\t\tret = check_and_add_cgroup_name(s);\n\t\t\tfree(s);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (check_and_add_cgroup_name(\"/\") < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!p)\n\t\t\tbreak;\n\t\tstr = p+1;\n\t}\n\n\t \n\tlist_for_each_entry(cn, &cgroup_list, list)\n\t\tcn->used = true;\n\n\treturn 0;\n}\n\n \nstatic int match_cgroups(const char *str)\n{\n\tchar mnt[PATH_MAX];\n\tconst char *p, *e, *eos = str + strlen(str);\n\tstruct cgroup_name *cn;\n\tregex_t reg;\n\tint prefix_len;\n\tchar *s;\n\n\tif (cgroupfs_find_mountpoint(mnt, sizeof(mnt), \"perf_event\"))\n\t\treturn -1;\n\n\t \n\tprefix_len = strlen(mnt);\n\n\t \n\tif (nftw(mnt, add_cgroup_name, 20, 0) < 0)\n\t\treturn -1;\n\n\tfor (;;) {\n\t\tp = strchr(str, ',');\n\t\te = p ? p : eos;\n\n\t\t \n\t\tif (e - str) {\n\t\t\t \n\t\t\ts = strndup(str, e - str);\n\t\t\tif (!s)\n\t\t\t\treturn -1;\n\t\t\tif (regcomp(&reg, s, REG_NOSUB)) {\n\t\t\t\tfree(s);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_for_each_entry(cn, &cgroup_list, list) {\n\t\t\t\tchar *name = cn->name + prefix_len;\n\n\t\t\t\tif (name[0] == '/' && name[1])\n\t\t\t\t\tname++;\n\t\t\t\tif (!regexec(&reg, name, 0, NULL, 0))\n\t\t\t\t\tcn->used = true;\n\t\t\t}\n\t\t\tregfree(&reg);\n\t\t\tfree(s);\n\t\t} else {\n\t\t\t \n\t\t\tcn = list_first_entry(&cgroup_list, struct cgroup_name,\n\t\t\t\t\t      list);\n\t\t\tcn->used = true;\n\t\t}\n\n\t\tif (!p)\n\t\t\tbreak;\n\t\tstr = p+1;\n\t}\n\treturn prefix_len;\n}\n\nint parse_cgroups(const struct option *opt, const char *str,\n\t\t  int unset __maybe_unused)\n{\n\tstruct evlist *evlist = *(struct evlist **)opt->value;\n\tstruct evsel *counter;\n\tstruct cgroup *cgrp = NULL;\n\tconst char *p, *e, *eos = str + strlen(str);\n\tchar *s;\n\tint ret, i;\n\n\tif (list_empty(&evlist->core.entries)) {\n\t\tfprintf(stderr, \"must define events before cgroups\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (;;) {\n\t\tp = strchr(str, ',');\n\t\te = p ? p : eos;\n\n\t\t \n\t\tif (e - str) {\n\t\t\t \n\t\t\ts = strndup(str, e - str);\n\t\t\tif (!s)\n\t\t\t\treturn -1;\n\t\t\tret = add_cgroup(evlist, s);\n\t\t\tfree(s);\n\t\t\tif (ret)\n\t\t\t\treturn -1;\n\t\t}\n\t\t \n\t\tnr_cgroups++;\n\t\tif (!p)\n\t\t\tbreak;\n\t\tstr = p+1;\n\t}\n\t \n\ti = 0;\n\tif (nr_cgroups == 1) {\n\t\tevlist__for_each_entry(evlist, counter) {\n\t\t\tif (i == 0)\n\t\t\t\tcgrp = counter->cgrp;\n\t\t\telse {\n\t\t\t\tcounter->cgrp = cgrp;\n\t\t\t\trefcount_inc(&cgrp->refcnt);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic bool has_pattern_string(const char *str)\n{\n\treturn !!strpbrk(str, \"{}[]()|*+?^$\");\n}\n\nint evlist__expand_cgroup(struct evlist *evlist, const char *str,\n\t\t\t  struct rblist *metric_events, bool open_cgroup)\n{\n\tstruct evlist *orig_list, *tmp_list;\n\tstruct evsel *pos, *evsel, *leader;\n\tstruct rblist orig_metric_events;\n\tstruct cgroup *cgrp = NULL;\n\tstruct cgroup_name *cn;\n\tint ret = -1;\n\tint prefix_len;\n\n\tif (evlist->core.nr_entries == 0) {\n\t\tfprintf(stderr, \"must define events before cgroups\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\torig_list = evlist__new();\n\ttmp_list = evlist__new();\n\tif (orig_list == NULL || tmp_list == NULL) {\n\t\tfprintf(stderr, \"memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tevlist__splice_list_tail(orig_list, &evlist->core.entries);\n\tevlist->core.nr_entries = 0;\n\n\tif (metric_events) {\n\t\torig_metric_events = *metric_events;\n\t\trblist__init(metric_events);\n\t} else {\n\t\trblist__init(&orig_metric_events);\n\t}\n\n\tif (has_pattern_string(str))\n\t\tprefix_len = match_cgroups(str);\n\telse\n\t\tprefix_len = list_cgroups(str);\n\n\tif (prefix_len < 0)\n\t\tgoto out_err;\n\n\tlist_for_each_entry(cn, &cgroup_list, list) {\n\t\tchar *name;\n\n\t\tif (!cn->used)\n\t\t\tcontinue;\n\n\t\t \n\t\tname = cn->name + prefix_len;\n\t\tif (name[0] == '/' && name[1])\n\t\t\tname++;\n\t\tcgrp = cgroup__new(name, open_cgroup);\n\t\tif (cgrp == NULL)\n\t\t\tgoto out_err;\n\n\t\tleader = NULL;\n\t\tevlist__for_each_entry(orig_list, pos) {\n\t\t\tevsel = evsel__clone(pos);\n\t\t\tif (evsel == NULL)\n\t\t\t\tgoto out_err;\n\n\t\t\tcgroup__put(evsel->cgrp);\n\t\t\tevsel->cgrp = cgroup__get(cgrp);\n\n\t\t\tif (evsel__is_group_leader(pos))\n\t\t\t\tleader = evsel;\n\t\t\tevsel__set_leader(evsel, leader);\n\n\t\t\tevlist__add(tmp_list, evsel);\n\t\t}\n\t\t \n\t\tcgroup__put(cgrp);\n\t\tnr_cgroups++;\n\n\t\tif (metric_events) {\n\t\t\tif (metricgroup__copy_metric_events(tmp_list, cgrp,\n\t\t\t\t\t\t\t    metric_events,\n\t\t\t\t\t\t\t    &orig_metric_events) < 0)\n\t\t\t\tgoto out_err;\n\t\t}\n\n\t\tevlist__splice_list_tail(evlist, &tmp_list->core.entries);\n\t\ttmp_list->core.nr_entries = 0;\n\t}\n\n\tif (list_empty(&evlist->core.entries)) {\n\t\tfprintf(stderr, \"no cgroup matched: %s\\n\", str);\n\t\tgoto out_err;\n\t}\n\n\tret = 0;\n\tcgrp_event_expanded = true;\n\nout_err:\n\tevlist__delete(orig_list);\n\tevlist__delete(tmp_list);\n\trblist__exit(&orig_metric_events);\n\trelease_cgroup_list();\n\n\treturn ret;\n}\n\nstatic struct cgroup *__cgroup__findnew(struct rb_root *root, uint64_t id,\n\t\t\t\t\tbool create, const char *path)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct cgroup *cgrp;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tcgrp = rb_entry(parent, struct cgroup, node);\n\n\t\tif (cgrp->id == id)\n\t\t\treturn cgrp;\n\n\t\tif (cgrp->id < id)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tif (!create)\n\t\treturn NULL;\n\n\tcgrp = malloc(sizeof(*cgrp));\n\tif (cgrp == NULL)\n\t\treturn NULL;\n\n\tcgrp->name = strdup(path);\n\tif (cgrp->name == NULL) {\n\t\tfree(cgrp);\n\t\treturn NULL;\n\t}\n\n\tcgrp->fd = -1;\n\tcgrp->id = id;\n\trefcount_set(&cgrp->refcnt, 1);\n\n\trb_link_node(&cgrp->node, parent, p);\n\trb_insert_color(&cgrp->node, root);\n\n\treturn cgrp;\n}\n\nstruct cgroup *cgroup__findnew(struct perf_env *env, uint64_t id,\n\t\t\t       const char *path)\n{\n\tstruct cgroup *cgrp;\n\n\tdown_write(&env->cgroups.lock);\n\tcgrp = __cgroup__findnew(&env->cgroups.tree, id, true, path);\n\tup_write(&env->cgroups.lock);\n\treturn cgrp;\n}\n\nstruct cgroup *cgroup__find(struct perf_env *env, uint64_t id)\n{\n\tstruct cgroup *cgrp;\n\n\tdown_read(&env->cgroups.lock);\n\tcgrp = __cgroup__findnew(&env->cgroups.tree, id, false, NULL);\n\tup_read(&env->cgroups.lock);\n\treturn cgrp;\n}\n\nvoid perf_env__purge_cgroups(struct perf_env *env)\n{\n\tstruct rb_node *node;\n\tstruct cgroup *cgrp;\n\n\tdown_write(&env->cgroups.lock);\n\twhile (!RB_EMPTY_ROOT(&env->cgroups.tree)) {\n\t\tnode = rb_first(&env->cgroups.tree);\n\t\tcgrp = rb_entry(node, struct cgroup, node);\n\n\t\trb_erase(node, &env->cgroups.tree);\n\t\tcgroup__put(cgrp);\n\t}\n\tup_write(&env->cgroups.lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}