{
  "module_name": "bpf-event.c",
  "hash_id": "f42baafc0755cff3f93bb3dc3e5ec317b9e3d09c6e3def56dc5e5b1dbd8f1dd3",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/bpf-event.c",
  "human_readable_source": "\n#include <errno.h>\n#include <stdlib.h>\n#include <bpf/bpf.h>\n#include <bpf/btf.h>\n#include <bpf/libbpf.h>\n#include <linux/btf.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <internal/lib.h>\n#include <symbol/kallsyms.h>\n#include \"bpf-event.h\"\n#include \"bpf-utils.h\"\n#include \"debug.h\"\n#include \"dso.h\"\n#include \"symbol.h\"\n#include \"machine.h\"\n#include \"env.h\"\n#include \"session.h\"\n#include \"map.h\"\n#include \"evlist.h\"\n#include \"record.h\"\n#include \"util/synthetic-events.h\"\n\nstatic int snprintf_hex(char *buf, size_t size, unsigned char *data, size_t len)\n{\n\tint ret = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++)\n\t\tret += snprintf(buf + ret, size - ret, \"%02x\", data[i]);\n\treturn ret;\n}\n\nstatic int machine__process_bpf_event_load(struct machine *machine,\n\t\t\t\t\t   union perf_event *event,\n\t\t\t\t\t   struct perf_sample *sample __maybe_unused)\n{\n\tstruct bpf_prog_info_node *info_node;\n\tstruct perf_env *env = machine->env;\n\tstruct perf_bpil *info_linear;\n\tint id = event->bpf.id;\n\tunsigned int i;\n\n\t \n\tif (env == NULL)\n\t\treturn 0;\n\n\tinfo_node = perf_env__find_bpf_prog_info(env, id);\n\tif (!info_node)\n\t\treturn 0;\n\tinfo_linear = info_node->info_linear;\n\n\tfor (i = 0; i < info_linear->info.nr_jited_ksyms; i++) {\n\t\tu64 *addrs = (u64 *)(uintptr_t)(info_linear->info.jited_ksyms);\n\t\tu64 addr = addrs[i];\n\t\tstruct map *map = maps__find(machine__kernel_maps(machine), addr);\n\n\t\tif (map) {\n\t\t\tstruct dso *dso = map__dso(map);\n\n\t\t\tdso->binary_type = DSO_BINARY_TYPE__BPF_PROG_INFO;\n\t\t\tdso->bpf_prog.id = id;\n\t\t\tdso->bpf_prog.sub_id = i;\n\t\t\tdso->bpf_prog.env = env;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint machine__process_bpf(struct machine *machine, union perf_event *event,\n\t\t\t struct perf_sample *sample)\n{\n\tif (dump_trace)\n\t\tperf_event__fprintf_bpf(event, stdout);\n\n\tswitch (event->bpf.type) {\n\tcase PERF_BPF_EVENT_PROG_LOAD:\n\t\treturn machine__process_bpf_event_load(machine, event, sample);\n\n\tcase PERF_BPF_EVENT_PROG_UNLOAD:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"unexpected bpf event type of %d\\n\", event->bpf.type);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int perf_env__fetch_btf(struct perf_env *env,\n\t\t\t       u32 btf_id,\n\t\t\t       struct btf *btf)\n{\n\tstruct btf_node *node;\n\tu32 data_size;\n\tconst void *data;\n\n\tdata = btf__raw_data(btf, &data_size);\n\n\tnode = malloc(data_size + sizeof(struct btf_node));\n\tif (!node)\n\t\treturn -1;\n\n\tnode->id = btf_id;\n\tnode->data_size = data_size;\n\tmemcpy(node->data, data, data_size);\n\n\tif (!perf_env__insert_btf(env, node)) {\n\t\t \n\t\tfree(node);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int synthesize_bpf_prog_name(char *buf, int size,\n\t\t\t\t    struct bpf_prog_info *info,\n\t\t\t\t    struct btf *btf,\n\t\t\t\t    u32 sub_id)\n{\n\tu8 (*prog_tags)[BPF_TAG_SIZE] = (void *)(uintptr_t)(info->prog_tags);\n\tvoid *func_infos = (void *)(uintptr_t)(info->func_info);\n\tu32 sub_prog_cnt = info->nr_jited_ksyms;\n\tconst struct bpf_func_info *finfo;\n\tconst char *short_name = NULL;\n\tconst struct btf_type *t;\n\tint name_len;\n\n\tname_len = snprintf(buf, size, \"bpf_prog_\");\n\tname_len += snprintf_hex(buf + name_len, size - name_len,\n\t\t\t\t prog_tags[sub_id], BPF_TAG_SIZE);\n\tif (btf) {\n\t\tfinfo = func_infos + sub_id * info->func_info_rec_size;\n\t\tt = btf__type_by_id(btf, finfo->type_id);\n\t\tshort_name = btf__name_by_offset(btf, t->name_off);\n\t} else if (sub_id == 0 && sub_prog_cnt == 1) {\n\t\t \n\t\tif (info->name[0])\n\t\t\tshort_name = info->name;\n\t} else\n\t\tshort_name = \"F\";\n\tif (short_name)\n\t\tname_len += snprintf(buf + name_len, size - name_len,\n\t\t\t\t     \"_%s\", short_name);\n\treturn name_len;\n}\n\n \nstatic int perf_event__synthesize_one_bpf_prog(struct perf_session *session,\n\t\t\t\t\t       perf_event__handler_t process,\n\t\t\t\t\t       struct machine *machine,\n\t\t\t\t\t       int fd,\n\t\t\t\t\t       union perf_event *event,\n\t\t\t\t\t       struct record_opts *opts)\n{\n\tstruct perf_record_ksymbol *ksymbol_event = &event->ksymbol;\n\tstruct perf_record_bpf_event *bpf_event = &event->bpf;\n\tstruct perf_tool *tool = session->tool;\n\tstruct bpf_prog_info_node *info_node;\n\tstruct perf_bpil *info_linear;\n\tstruct bpf_prog_info *info;\n\tstruct btf *btf = NULL;\n\tstruct perf_env *env;\n\tu32 sub_prog_cnt, i;\n\tint err = 0;\n\tu64 arrays;\n\n\t \n\tenv = session->data ? &session->header.env : &perf_env;\n\n\tarrays = 1UL << PERF_BPIL_JITED_KSYMS;\n\tarrays |= 1UL << PERF_BPIL_JITED_FUNC_LENS;\n\tarrays |= 1UL << PERF_BPIL_FUNC_INFO;\n\tarrays |= 1UL << PERF_BPIL_PROG_TAGS;\n\tarrays |= 1UL << PERF_BPIL_JITED_INSNS;\n\tarrays |= 1UL << PERF_BPIL_LINE_INFO;\n\tarrays |= 1UL << PERF_BPIL_JITED_LINE_INFO;\n\n\tinfo_linear = get_bpf_prog_info_linear(fd, arrays);\n\tif (IS_ERR_OR_NULL(info_linear)) {\n\t\tinfo_linear = NULL;\n\t\tpr_debug(\"%s: failed to get BPF program info. aborting\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tif (info_linear->info_len < offsetof(struct bpf_prog_info, prog_tags)) {\n\t\tfree(info_linear);\n\t\tpr_debug(\"%s: the kernel is too old, aborting\\n\", __func__);\n\t\treturn -2;\n\t}\n\n\tinfo = &info_linear->info;\n\tif (!info->jited_ksyms) {\n\t\tfree(info_linear);\n\t\treturn -1;\n\t}\n\n\t \n\tsub_prog_cnt = info->nr_jited_ksyms;\n\tif (sub_prog_cnt != info->nr_prog_tags ||\n\t    sub_prog_cnt != info->nr_jited_func_lens) {\n\t\tfree(info_linear);\n\t\treturn -1;\n\t}\n\n\t \n\tif (info->btf_id && info->nr_func_info && info->func_info_rec_size) {\n\t\t \n\t\tif (sub_prog_cnt != info->nr_func_info) {\n\t\t\tpr_debug(\"%s: mismatch in BPF sub program count and BTF function info count, aborting\\n\", __func__);\n\t\t\tfree(info_linear);\n\t\t\treturn -1;\n\t\t}\n\t\tbtf = btf__load_from_kernel_by_id(info->btf_id);\n\t\tif (libbpf_get_error(btf)) {\n\t\t\tpr_debug(\"%s: failed to get BTF of id %u, aborting\\n\", __func__, info->btf_id);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tperf_env__fetch_btf(env, info->btf_id, btf);\n\t}\n\n\t \n\tfor (i = 0; i < sub_prog_cnt; i++) {\n\t\t__u32 *prog_lens = (__u32 *)(uintptr_t)(info->jited_func_lens);\n\t\t__u64 *prog_addrs = (__u64 *)(uintptr_t)(info->jited_ksyms);\n\t\tint name_len;\n\n\t\t*ksymbol_event = (struct perf_record_ksymbol) {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = offsetof(struct perf_record_ksymbol, name),\n\t\t\t},\n\t\t\t.addr = prog_addrs[i],\n\t\t\t.len = prog_lens[i],\n\t\t\t.ksym_type = PERF_RECORD_KSYMBOL_TYPE_BPF,\n\t\t\t.flags = 0,\n\t\t};\n\n\t\tname_len = synthesize_bpf_prog_name(ksymbol_event->name,\n\t\t\t\t\t\t    KSYM_NAME_LEN, info, btf, i);\n\t\tksymbol_event->header.size += PERF_ALIGN(name_len + 1,\n\t\t\t\t\t\t\t sizeof(u64));\n\n\t\tmemset((void *)event + event->header.size, 0, machine->id_hdr_size);\n\t\tevent->header.size += machine->id_hdr_size;\n\t\terr = perf_tool__process_synth_event(tool, event,\n\t\t\t\t\t\t     machine, process);\n\t}\n\n\tif (!opts->no_bpf_event) {\n\t\t \n\t\t*bpf_event = (struct perf_record_bpf_event) {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_BPF_EVENT,\n\t\t\t\t.size = sizeof(struct perf_record_bpf_event),\n\t\t\t},\n\t\t\t.type = PERF_BPF_EVENT_PROG_LOAD,\n\t\t\t.flags = 0,\n\t\t\t.id = info->id,\n\t\t};\n\t\tmemcpy(bpf_event->tag, info->tag, BPF_TAG_SIZE);\n\t\tmemset((void *)event + event->header.size, 0, machine->id_hdr_size);\n\t\tevent->header.size += machine->id_hdr_size;\n\n\t\t \n\t\tinfo_node = malloc(sizeof(struct bpf_prog_info_node));\n\t\tif (!info_node) {\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinfo_node->info_linear = info_linear;\n\t\tperf_env__insert_bpf_prog_info(env, info_node);\n\t\tinfo_linear = NULL;\n\n\t\t \n\t\terr = perf_tool__process_synth_event(tool, event,\n\t\t\t\t\t\t     machine, process);\n\t}\n\nout:\n\tfree(info_linear);\n\tbtf__free(btf);\n\treturn err ? -1 : 0;\n}\n\nstruct kallsyms_parse {\n\tunion perf_event\t*event;\n\tperf_event__handler_t\t process;\n\tstruct machine\t\t*machine;\n\tstruct perf_tool\t*tool;\n};\n\nstatic int\nprocess_bpf_image(char *name, u64 addr, struct kallsyms_parse *data)\n{\n\tstruct machine *machine = data->machine;\n\tunion perf_event *event = data->event;\n\tstruct perf_record_ksymbol *ksymbol;\n\tint len;\n\n\tksymbol = &event->ksymbol;\n\n\t*ksymbol = (struct perf_record_ksymbol) {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t.size = offsetof(struct perf_record_ksymbol, name),\n\t\t},\n\t\t.addr      = addr,\n\t\t.len       = page_size,\n\t\t.ksym_type = PERF_RECORD_KSYMBOL_TYPE_BPF,\n\t\t.flags     = 0,\n\t};\n\n\tlen = scnprintf(ksymbol->name, KSYM_NAME_LEN, \"%s\", name);\n\tksymbol->header.size += PERF_ALIGN(len + 1, sizeof(u64));\n\tmemset((void *) event + event->header.size, 0, machine->id_hdr_size);\n\tevent->header.size += machine->id_hdr_size;\n\n\treturn perf_tool__process_synth_event(data->tool, event, machine,\n\t\t\t\t\t      data->process);\n}\n\nstatic int\nkallsyms_process_symbol(void *data, const char *_name,\n\t\t\tchar type __maybe_unused, u64 start)\n{\n\tchar disp[KSYM_NAME_LEN];\n\tchar *module, *name;\n\tunsigned long id;\n\tint err = 0;\n\n\tmodule = strchr(_name, '\\t');\n\tif (!module)\n\t\treturn 0;\n\n\t \n\tif (strcmp(module + 1, \"[bpf]\"))\n\t\treturn 0;\n\n\tname = memdup(_name, (module - _name) + 1);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tname[module - _name] = 0;\n\n\t \n\tif ((sscanf(name, \"bpf_trampoline_%lu\", &id) == 1) ||\n\t    (sscanf(name, \"bpf_dispatcher_%s\", disp) == 1))\n\t\terr = process_bpf_image(name, start, data);\n\n\tfree(name);\n\treturn err;\n}\n\nint perf_event__synthesize_bpf_events(struct perf_session *session,\n\t\t\t\t      perf_event__handler_t process,\n\t\t\t\t      struct machine *machine,\n\t\t\t\t      struct record_opts *opts)\n{\n\tconst char *kallsyms_filename = \"/proc/kallsyms\";\n\tstruct kallsyms_parse arg;\n\tunion perf_event *event;\n\t__u32 id = 0;\n\tint err;\n\tint fd;\n\n\tevent = malloc(sizeof(event->bpf) + KSYM_NAME_LEN + machine->id_hdr_size);\n\tif (!event)\n\t\treturn -1;\n\n\t \n\twhile (true) {\n\t\terr = bpf_prog_get_next_id(id, &id);\n\t\tif (err) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpr_debug(\"%s: can't get next program: %s%s\\n\",\n\t\t\t\t __func__, strerror(errno),\n\t\t\t\t errno == EINVAL ? \" -- kernel too old?\" : \"\");\n\t\t\t \n\t\t\terr = (errno == EINVAL || errno == EPERM) ? 0 : -1;\n\t\t\tbreak;\n\t\t}\n\t\tfd = bpf_prog_get_fd_by_id(id);\n\t\tif (fd < 0) {\n\t\t\tpr_debug(\"%s: failed to get fd for prog_id %u\\n\",\n\t\t\t\t __func__, id);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = perf_event__synthesize_one_bpf_prog(session, process,\n\t\t\t\t\t\t\t  machine, fd,\n\t\t\t\t\t\t\t  event, opts);\n\t\tclose(fd);\n\t\tif (err) {\n\t\t\t \n\t\t\tif (err == -2)\n\t\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (symbol_conf.kallsyms_name != NULL)\n\t\tkallsyms_filename = symbol_conf.kallsyms_name;\n\n\targ = (struct kallsyms_parse) {\n\t\t.event   = event,\n\t\t.process = process,\n\t\t.machine = machine,\n\t\t.tool    = session->tool,\n\t};\n\n\tif (kallsyms__parse(kallsyms_filename, &arg, kallsyms_process_symbol)) {\n\t\tpr_err(\"%s: failed to synthesize bpf images: %s\\n\",\n\t\t       __func__, strerror(errno));\n\t}\n\n\tfree(event);\n\treturn err;\n}\n\nstatic void perf_env__add_bpf_info(struct perf_env *env, u32 id)\n{\n\tstruct bpf_prog_info_node *info_node;\n\tstruct perf_bpil *info_linear;\n\tstruct btf *btf = NULL;\n\tu64 arrays;\n\tu32 btf_id;\n\tint fd;\n\n\tfd = bpf_prog_get_fd_by_id(id);\n\tif (fd < 0)\n\t\treturn;\n\n\tarrays = 1UL << PERF_BPIL_JITED_KSYMS;\n\tarrays |= 1UL << PERF_BPIL_JITED_FUNC_LENS;\n\tarrays |= 1UL << PERF_BPIL_FUNC_INFO;\n\tarrays |= 1UL << PERF_BPIL_PROG_TAGS;\n\tarrays |= 1UL << PERF_BPIL_JITED_INSNS;\n\tarrays |= 1UL << PERF_BPIL_LINE_INFO;\n\tarrays |= 1UL << PERF_BPIL_JITED_LINE_INFO;\n\n\tinfo_linear = get_bpf_prog_info_linear(fd, arrays);\n\tif (IS_ERR_OR_NULL(info_linear)) {\n\t\tpr_debug(\"%s: failed to get BPF program info. aborting\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tbtf_id = info_linear->info.btf_id;\n\n\tinfo_node = malloc(sizeof(struct bpf_prog_info_node));\n\tif (info_node) {\n\t\tinfo_node->info_linear = info_linear;\n\t\tperf_env__insert_bpf_prog_info(env, info_node);\n\t} else\n\t\tfree(info_linear);\n\n\tif (btf_id == 0)\n\t\tgoto out;\n\n\tbtf = btf__load_from_kernel_by_id(btf_id);\n\tif (libbpf_get_error(btf)) {\n\t\tpr_debug(\"%s: failed to get BTF of id %u, aborting\\n\",\n\t\t\t __func__, btf_id);\n\t\tgoto out;\n\t}\n\tperf_env__fetch_btf(env, btf_id, btf);\n\nout:\n\tbtf__free(btf);\n\tclose(fd);\n}\n\nstatic int bpf_event__sb_cb(union perf_event *event, void *data)\n{\n\tstruct perf_env *env = data;\n\n\tif (event->header.type != PERF_RECORD_BPF_EVENT)\n\t\treturn -1;\n\n\tswitch (event->bpf.type) {\n\tcase PERF_BPF_EVENT_PROG_LOAD:\n\t\tperf_env__add_bpf_info(env, event->bpf.id);\n\n\tcase PERF_BPF_EVENT_PROG_UNLOAD:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"unexpected bpf event type of %d\\n\", event->bpf.type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint evlist__add_bpf_sb_event(struct evlist *evlist, struct perf_env *env)\n{\n\tstruct perf_event_attr attr = {\n\t\t.type\t          = PERF_TYPE_SOFTWARE,\n\t\t.config           = PERF_COUNT_SW_DUMMY,\n\t\t.sample_id_all    = 1,\n\t\t.watermark        = 1,\n\t\t.bpf_event        = 1,\n\t\t.size\t   = sizeof(attr),  \n\t};\n\n\t \n\tattr.wakeup_watermark = 1;\n\n\treturn evlist__add_sb_event(evlist, &attr, bpf_event__sb_cb, env);\n}\n\nvoid __bpf_event__print_bpf_prog_info(struct bpf_prog_info *info,\n\t\t\t\t      struct perf_env *env,\n\t\t\t\t      FILE *fp)\n{\n\t__u32 *prog_lens = (__u32 *)(uintptr_t)(info->jited_func_lens);\n\t__u64 *prog_addrs = (__u64 *)(uintptr_t)(info->jited_ksyms);\n\tchar name[KSYM_NAME_LEN];\n\tstruct btf *btf = NULL;\n\tu32 sub_prog_cnt, i;\n\n\tsub_prog_cnt = info->nr_jited_ksyms;\n\tif (sub_prog_cnt != info->nr_prog_tags ||\n\t    sub_prog_cnt != info->nr_jited_func_lens)\n\t\treturn;\n\n\tif (info->btf_id) {\n\t\tstruct btf_node *node;\n\n\t\tnode = __perf_env__find_btf(env, info->btf_id);\n\t\tif (node)\n\t\t\tbtf = btf__new((__u8 *)(node->data),\n\t\t\t\t       node->data_size);\n\t}\n\n\tif (sub_prog_cnt == 1) {\n\t\tsynthesize_bpf_prog_name(name, KSYM_NAME_LEN, info, btf, 0);\n\t\tfprintf(fp, \"# bpf_prog_info %u: %s addr 0x%llx size %u\\n\",\n\t\t\tinfo->id, name, prog_addrs[0], prog_lens[0]);\n\t\tgoto out;\n\t}\n\n\tfprintf(fp, \"# bpf_prog_info %u:\\n\", info->id);\n\tfor (i = 0; i < sub_prog_cnt; i++) {\n\t\tsynthesize_bpf_prog_name(name, KSYM_NAME_LEN, info, btf, i);\n\n\t\tfprintf(fp, \"# \\tsub_prog %u: %s addr 0x%llx size %u\\n\",\n\t\t\ti, name, prog_addrs[i], prog_lens[i]);\n\t}\nout:\n\tbtf__free(btf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}