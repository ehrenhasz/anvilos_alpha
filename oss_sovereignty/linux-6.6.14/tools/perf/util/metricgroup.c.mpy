{
  "module_name": "metricgroup.c",
  "hash_id": "c800b4d61345f9739803c8c36bf8273f52f7c62aeac0fe9cc813bdbe8a370992",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/metricgroup.c",
  "human_readable_source": "\n \n\n \n\n#include \"metricgroup.h\"\n#include \"debug.h\"\n#include \"evlist.h\"\n#include \"evsel.h\"\n#include \"strbuf.h\"\n#include \"pmu.h\"\n#include \"pmus.h\"\n#include \"print-events.h\"\n#include \"smt.h\"\n#include \"expr.h\"\n#include \"rblist.h\"\n#include <string.h>\n#include <errno.h>\n#include \"strlist.h\"\n#include <assert.h>\n#include <linux/ctype.h>\n#include <linux/list_sort.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <perf/cpumap.h>\n#include <subcmd/parse-options.h>\n#include <api/fs/fs.h>\n#include \"util.h\"\n#include <asm/bug.h>\n#include \"cgroup.h\"\n#include \"util/hashmap.h\"\n\nstruct metric_event *metricgroup__lookup(struct rblist *metric_events,\n\t\t\t\t\t struct evsel *evsel,\n\t\t\t\t\t bool create)\n{\n\tstruct rb_node *nd;\n\tstruct metric_event me = {\n\t\t.evsel = evsel\n\t};\n\n\tif (!metric_events)\n\t\treturn NULL;\n\n\tnd = rblist__find(metric_events, &me);\n\tif (nd)\n\t\treturn container_of(nd, struct metric_event, nd);\n\tif (create) {\n\t\trblist__add_node(metric_events, &me);\n\t\tnd = rblist__find(metric_events, &me);\n\t\tif (nd)\n\t\t\treturn container_of(nd, struct metric_event, nd);\n\t}\n\treturn NULL;\n}\n\nstatic int metric_event_cmp(struct rb_node *rb_node, const void *entry)\n{\n\tstruct metric_event *a = container_of(rb_node,\n\t\t\t\t\t      struct metric_event,\n\t\t\t\t\t      nd);\n\tconst struct metric_event *b = entry;\n\n\tif (a->evsel == b->evsel)\n\t\treturn 0;\n\tif ((char *)a->evsel < (char *)b->evsel)\n\t\treturn -1;\n\treturn +1;\n}\n\nstatic struct rb_node *metric_event_new(struct rblist *rblist __maybe_unused,\n\t\t\t\t\tconst void *entry)\n{\n\tstruct metric_event *me = malloc(sizeof(struct metric_event));\n\n\tif (!me)\n\t\treturn NULL;\n\tmemcpy(me, entry, sizeof(struct metric_event));\n\tme->evsel = ((struct metric_event *)entry)->evsel;\n\tme->is_default = false;\n\tINIT_LIST_HEAD(&me->head);\n\treturn &me->nd;\n}\n\nstatic void metric_event_delete(struct rblist *rblist __maybe_unused,\n\t\t\t\tstruct rb_node *rb_node)\n{\n\tstruct metric_event *me = container_of(rb_node, struct metric_event, nd);\n\tstruct metric_expr *expr, *tmp;\n\n\tlist_for_each_entry_safe(expr, tmp, &me->head, nd) {\n\t\tzfree(&expr->metric_name);\n\t\tzfree(&expr->metric_refs);\n\t\tzfree(&expr->metric_events);\n\t\tfree(expr);\n\t}\n\n\tfree(me);\n}\n\nstatic void metricgroup__rblist_init(struct rblist *metric_events)\n{\n\trblist__init(metric_events);\n\tmetric_events->node_cmp = metric_event_cmp;\n\tmetric_events->node_new = metric_event_new;\n\tmetric_events->node_delete = metric_event_delete;\n}\n\nvoid metricgroup__rblist_exit(struct rblist *metric_events)\n{\n\trblist__exit(metric_events);\n}\n\n \nstruct metric {\n\tstruct list_head nd;\n\t \n\tstruct expr_parse_ctx *pctx;\n\tconst char *pmu;\n\t \n\tconst char *metric_name;\n\t \n\tconst char *modifier;\n\t \n\tconst char *metric_expr;\n\t \n\tconst char *metric_threshold;\n\t \n\tconst char *metric_unit;\n\t \n\tconst char *default_metricgroup_name;\n\t \n\tstruct metric_ref *metric_refs;\n\t \n\tbool group_events;\n\t \n\tstruct evlist *evlist;\n};\n\nstatic void metric__watchdog_constraint_hint(const char *name, bool foot)\n{\n\tstatic bool violate_nmi_constraint;\n\n\tif (!foot) {\n\t\tpr_warning(\"Not grouping metric %s's events.\\n\", name);\n\t\tviolate_nmi_constraint = true;\n\t\treturn;\n\t}\n\n\tif (!violate_nmi_constraint)\n\t\treturn;\n\n\tpr_warning(\"Try disabling the NMI watchdog to comply NO_NMI_WATCHDOG metric constraint:\\n\"\n\t\t   \"    echo 0 > /proc/sys/kernel/nmi_watchdog\\n\"\n\t\t   \"    perf stat ...\\n\"\n\t\t   \"    echo 1 > /proc/sys/kernel/nmi_watchdog\\n\");\n}\n\nstatic bool metric__group_events(const struct pmu_metric *pm)\n{\n\tswitch (pm->event_grouping) {\n\tcase MetricNoGroupEvents:\n\t\treturn false;\n\tcase MetricNoGroupEventsNmi:\n\t\tif (!sysctl__nmi_watchdog_enabled())\n\t\t\treturn true;\n\t\tmetric__watchdog_constraint_hint(pm->metric_name,  false);\n\t\treturn false;\n\tcase MetricNoGroupEventsSmt:\n\t\treturn !smt_on();\n\tcase MetricGroupEvents:\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic void metric__free(struct metric *m)\n{\n\tif (!m)\n\t\treturn;\n\n\tzfree(&m->metric_refs);\n\texpr__ctx_free(m->pctx);\n\tzfree(&m->modifier);\n\tevlist__delete(m->evlist);\n\tfree(m);\n}\n\nstatic struct metric *metric__new(const struct pmu_metric *pm,\n\t\t\t\t  const char *modifier,\n\t\t\t\t  bool metric_no_group,\n\t\t\t\t  int runtime,\n\t\t\t\t  const char *user_requested_cpu_list,\n\t\t\t\t  bool system_wide)\n{\n\tstruct metric *m;\n\n\tm = zalloc(sizeof(*m));\n\tif (!m)\n\t\treturn NULL;\n\n\tm->pctx = expr__ctx_new();\n\tif (!m->pctx)\n\t\tgoto out_err;\n\n\tm->pmu = pm->pmu ?: \"cpu\";\n\tm->metric_name = pm->metric_name;\n\tm->default_metricgroup_name = pm->default_metricgroup_name ?: \"\";\n\tm->modifier = NULL;\n\tif (modifier) {\n\t\tm->modifier = strdup(modifier);\n\t\tif (!m->modifier)\n\t\t\tgoto out_err;\n\t}\n\tm->metric_expr = pm->metric_expr;\n\tm->metric_threshold = pm->metric_threshold;\n\tm->metric_unit = pm->unit;\n\tm->pctx->sctx.user_requested_cpu_list = NULL;\n\tif (user_requested_cpu_list) {\n\t\tm->pctx->sctx.user_requested_cpu_list = strdup(user_requested_cpu_list);\n\t\tif (!m->pctx->sctx.user_requested_cpu_list)\n\t\t\tgoto out_err;\n\t}\n\tm->pctx->sctx.runtime = runtime;\n\tm->pctx->sctx.system_wide = system_wide;\n\tm->group_events = !metric_no_group && metric__group_events(pm);\n\tm->metric_refs = NULL;\n\tm->evlist = NULL;\n\n\treturn m;\nout_err:\n\tmetric__free(m);\n\treturn NULL;\n}\n\nstatic bool contains_metric_id(struct evsel **metric_events, int num_events,\n\t\t\t       const char *metric_id)\n{\n\tint i;\n\n\tfor (i = 0; i < num_events; i++) {\n\t\tif (!strcmp(evsel__metric_id(metric_events[i]), metric_id))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic int setup_metric_events(const char *pmu, struct hashmap *ids,\n\t\t\t       struct evlist *metric_evlist,\n\t\t\t       struct evsel ***out_metric_events)\n{\n\tstruct evsel **metric_events;\n\tconst char *metric_id;\n\tstruct evsel *ev;\n\tsize_t ids_size, matched_events, i;\n\tbool all_pmus = !strcmp(pmu, \"all\") || perf_pmus__num_core_pmus() == 1 || !is_pmu_core(pmu);\n\n\t*out_metric_events = NULL;\n\tids_size = hashmap__size(ids);\n\n\tmetric_events = calloc(sizeof(void *), ids_size + 1);\n\tif (!metric_events)\n\t\treturn -ENOMEM;\n\n\tmatched_events = 0;\n\tevlist__for_each_entry(metric_evlist, ev) {\n\t\tstruct expr_id_data *val_ptr;\n\n\t\t \n\t\tif (!all_pmus && ev->pmu_name && evsel__is_hybrid(ev) &&\n\t\t    strcmp(ev->pmu_name, pmu))\n\t\t\tcontinue;\n\t\t \n\t\tmetric_id = evsel__metric_id(ev);\n\t\tif (contains_metric_id(metric_events, matched_events, metric_id))\n\t\t\tcontinue;\n\t\t \n\t\tif (hashmap__find(ids, metric_id, &val_ptr)) {\n\t\t\tpr_debug(\"Matched metric-id %s to %s\\n\", metric_id, evsel__name(ev));\n\t\t\tmetric_events[matched_events++] = ev;\n\n\t\t\tif (matched_events >= ids_size)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (matched_events < ids_size) {\n\t\tfree(metric_events);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < ids_size; i++) {\n\t\tev = metric_events[i];\n\t\tev->collect_stat = true;\n\n\t\t \n\t\tev->metric_leader = ev;\n\t\t \n\t\tmetric_id = evsel__metric_id(ev);\n\t\tevlist__for_each_entry_continue(metric_evlist, ev) {\n\t\t\tif (!strcmp(evsel__metric_id(ev), metric_id))\n\t\t\t\tev->metric_leader = metric_events[i];\n\t\t}\n\t}\n\t*out_metric_events = metric_events;\n\treturn 0;\n}\n\nstatic bool match_metric(const char *n, const char *list)\n{\n\tint len;\n\tchar *m;\n\n\tif (!list)\n\t\treturn false;\n\tif (!strcmp(list, \"all\"))\n\t\treturn true;\n\tif (!n)\n\t\treturn !strcasecmp(list, \"No_group\");\n\tlen = strlen(list);\n\tm = strcasestr(n, list);\n\tif (!m)\n\t\treturn false;\n\tif ((m == n || m[-1] == ';' || m[-1] == ' ') &&\n\t    (m[len] == 0 || m[len] == ';'))\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool match_pm_metric(const struct pmu_metric *pm, const char *pmu, const char *metric)\n{\n\tconst char *pm_pmu = pm->pmu ?: \"cpu\";\n\n\tif (strcmp(pmu, \"all\") && strcmp(pm_pmu, pmu))\n\t\treturn false;\n\n\treturn match_metric(pm->metric_group, metric) ||\n\t       match_metric(pm->metric_name, metric);\n}\n\n \nstruct mep {\n\t \n\tstruct rb_node nd;\n\t \n\tchar *metric_group;\n\tconst char *metric_name;\n\tconst char *metric_desc;\n\tconst char *metric_long_desc;\n\tconst char *metric_expr;\n\tconst char *metric_threshold;\n\tconst char *metric_unit;\n};\n\nstatic int mep_cmp(struct rb_node *rb_node, const void *entry)\n{\n\tstruct mep *a = container_of(rb_node, struct mep, nd);\n\tstruct mep *b = (struct mep *)entry;\n\tint ret;\n\n\tret = strcmp(a->metric_group, b->metric_group);\n\tif (ret)\n\t\treturn ret;\n\n\treturn strcmp(a->metric_name, b->metric_name);\n}\n\nstatic struct rb_node *mep_new(struct rblist *rl __maybe_unused, const void *entry)\n{\n\tstruct mep *me = malloc(sizeof(struct mep));\n\n\tif (!me)\n\t\treturn NULL;\n\n\tmemcpy(me, entry, sizeof(struct mep));\n\treturn &me->nd;\n}\n\nstatic void mep_delete(struct rblist *rl __maybe_unused,\n\t\t       struct rb_node *nd)\n{\n\tstruct mep *me = container_of(nd, struct mep, nd);\n\n\tzfree(&me->metric_group);\n\tfree(me);\n}\n\nstatic struct mep *mep_lookup(struct rblist *groups, const char *metric_group,\n\t\t\t      const char *metric_name)\n{\n\tstruct rb_node *nd;\n\tstruct mep me = {\n\t\t.metric_group = strdup(metric_group),\n\t\t.metric_name = metric_name,\n\t};\n\tnd = rblist__find(groups, &me);\n\tif (nd) {\n\t\tfree(me.metric_group);\n\t\treturn container_of(nd, struct mep, nd);\n\t}\n\trblist__add_node(groups, &me);\n\tnd = rblist__find(groups, &me);\n\tif (nd)\n\t\treturn container_of(nd, struct mep, nd);\n\treturn NULL;\n}\n\nstatic int metricgroup__add_to_mep_groups(const struct pmu_metric *pm,\n\t\t\t\t\tstruct rblist *groups)\n{\n\tconst char *g;\n\tchar *omg, *mg;\n\n\tmg = strdup(pm->metric_group ?: \"No_group\");\n\tif (!mg)\n\t\treturn -ENOMEM;\n\tomg = mg;\n\twhile ((g = strsep(&mg, \";\")) != NULL) {\n\t\tstruct mep *me;\n\n\t\tg = skip_spaces(g);\n\t\tif (strlen(g))\n\t\t\tme = mep_lookup(groups, g, pm->metric_name);\n\t\telse\n\t\t\tme = mep_lookup(groups, \"No_group\", pm->metric_name);\n\n\t\tif (me) {\n\t\t\tme->metric_desc = pm->desc;\n\t\t\tme->metric_long_desc = pm->long_desc;\n\t\t\tme->metric_expr = pm->metric_expr;\n\t\t\tme->metric_threshold = pm->metric_threshold;\n\t\t\tme->metric_unit = pm->unit;\n\t\t}\n\t}\n\tfree(omg);\n\n\treturn 0;\n}\n\nstruct metricgroup_iter_data {\n\tpmu_metric_iter_fn fn;\n\tvoid *data;\n};\n\nstatic int metricgroup__sys_event_iter(const struct pmu_metric *pm,\n\t\t\t\t       const struct pmu_metrics_table *table,\n\t\t\t\t       void *data)\n{\n\tstruct metricgroup_iter_data *d = data;\n\tstruct perf_pmu *pmu = NULL;\n\n\tif (!pm->metric_expr || !pm->compat)\n\t\treturn 0;\n\n\twhile ((pmu = perf_pmus__scan(pmu))) {\n\n\t\tif (!pmu->id || strcmp(pmu->id, pm->compat))\n\t\t\tcontinue;\n\n\t\treturn d->fn(pm, table, d->data);\n\t}\n\treturn 0;\n}\n\nstatic int metricgroup__add_to_mep_groups_callback(const struct pmu_metric *pm,\n\t\t\t\t\tconst struct pmu_metrics_table *table __maybe_unused,\n\t\t\t\t\tvoid *vdata)\n{\n\tstruct rblist *groups = vdata;\n\n\treturn metricgroup__add_to_mep_groups(pm, groups);\n}\n\nvoid metricgroup__print(const struct print_callbacks *print_cb, void *print_state)\n{\n\tstruct rblist groups;\n\tconst struct pmu_metrics_table *table;\n\tstruct rb_node *node, *next;\n\n\trblist__init(&groups);\n\tgroups.node_new = mep_new;\n\tgroups.node_cmp = mep_cmp;\n\tgroups.node_delete = mep_delete;\n\ttable = pmu_metrics_table__find();\n\tif (table) {\n\t\tpmu_metrics_table__for_each_metric(table,\n\t\t\t\t\t\t metricgroup__add_to_mep_groups_callback,\n\t\t\t\t\t\t &groups);\n\t}\n\t{\n\t\tstruct metricgroup_iter_data data = {\n\t\t\t.fn = metricgroup__add_to_mep_groups_callback,\n\t\t\t.data = &groups,\n\t\t};\n\t\tpmu_for_each_sys_metric(metricgroup__sys_event_iter, &data);\n\t}\n\n\tfor (node = rb_first_cached(&groups.entries); node; node = next) {\n\t\tstruct mep *me = container_of(node, struct mep, nd);\n\n\t\tprint_cb->print_metric(print_state,\n\t\t\t\tme->metric_group,\n\t\t\t\tme->metric_name,\n\t\t\t\tme->metric_desc,\n\t\t\t\tme->metric_long_desc,\n\t\t\t\tme->metric_expr,\n\t\t\t\tme->metric_threshold,\n\t\t\t\tme->metric_unit);\n\t\tnext = rb_next(node);\n\t\trblist__remove_node(&groups, node);\n\t}\n}\n\nstatic const char *code_characters = \",-=@\";\n\nstatic int encode_metric_id(struct strbuf *sb, const char *x)\n{\n\tchar *c;\n\tint ret = 0;\n\n\tfor (; *x; x++) {\n\t\tc = strchr(code_characters, *x);\n\t\tif (c) {\n\t\t\tret = strbuf_addch(sb, '!');\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tret = strbuf_addch(sb, '0' + (c - code_characters));\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tret = strbuf_addch(sb, *x);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int decode_metric_id(struct strbuf *sb, const char *x)\n{\n\tconst char *orig = x;\n\tsize_t i;\n\tchar c;\n\tint ret;\n\n\tfor (; *x; x++) {\n\t\tc = *x;\n\t\tif (*x == '!') {\n\t\t\tx++;\n\t\t\ti = *x - '0';\n\t\t\tif (i > strlen(code_characters)) {\n\t\t\t\tpr_err(\"Bad metric-id encoding in: '%s'\", orig);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tc = code_characters[i];\n\t\t}\n\t\tret = strbuf_addch(sb, c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int decode_all_metric_ids(struct evlist *perf_evlist, const char *modifier)\n{\n\tstruct evsel *ev;\n\tstruct strbuf sb = STRBUF_INIT;\n\tchar *cur;\n\tint ret = 0;\n\n\tevlist__for_each_entry(perf_evlist, ev) {\n\t\tif (!ev->metric_id)\n\t\t\tcontinue;\n\n\t\tret = strbuf_setlen(&sb, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = decode_metric_id(&sb, ev->metric_id);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tfree((char *)ev->metric_id);\n\t\tev->metric_id = strdup(sb.buf);\n\t\tif (!ev->metric_id) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (strstr(ev->name, \"metric-id=\")) {\n\t\t\tbool has_slash = false;\n\n\t\t\tzfree(&ev->name);\n\t\t\tfor (cur = strchr(sb.buf, '@') ; cur; cur = strchr(++cur, '@')) {\n\t\t\t\t*cur = '/';\n\t\t\t\thas_slash = true;\n\t\t\t}\n\n\t\t\tif (modifier) {\n\t\t\t\tif (!has_slash && !strchr(sb.buf, ':')) {\n\t\t\t\t\tret = strbuf_addch(&sb, ':');\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = strbuf_addstr(&sb, modifier);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tev->name = strdup(sb.buf);\n\t\t\tif (!ev->name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tstrbuf_release(&sb);\n\treturn ret;\n}\n\nstatic int metricgroup__build_event_string(struct strbuf *events,\n\t\t\t\t\t   const struct expr_parse_ctx *ctx,\n\t\t\t\t\t   const char *modifier,\n\t\t\t\t\t   bool group_events)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\tbool no_group = true, has_tool_events = false;\n\tbool tool_events[PERF_TOOL_MAX] = {false};\n\tint ret = 0;\n\n#define RETURN_IF_NON_ZERO(x) do { if (x) return x; } while (0)\n\n\thashmap__for_each_entry(ctx->ids, cur, bkt) {\n\t\tconst char *sep, *rsep, *id = cur->pkey;\n\t\tenum perf_tool_event ev;\n\n\t\tpr_debug(\"found event %s\\n\", id);\n\n\t\t \n\t\tev = perf_tool_event__from_str(id);\n\t\tif (ev != PERF_TOOL_NONE) {\n\t\t\thas_tool_events = true;\n\t\t\ttool_events[ev] = true;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (no_group) {\n\t\t\tif (group_events) {\n\t\t\t\tret = strbuf_addch(events, '{');\n\t\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t\t}\n\n\t\t\tno_group = false;\n\t\t} else {\n\t\t\tret = strbuf_addch(events, ',');\n\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t}\n\t\t \n\t\tsep = strchr(id, '@');\n\t\tif (sep != NULL) {\n\t\t\tret = strbuf_add(events, id, sep - id);\n\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t\tret = strbuf_addch(events, '/');\n\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t\trsep = strrchr(sep, '@');\n\t\t\tret = strbuf_add(events, sep + 1, rsep - sep - 1);\n\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t\tret = strbuf_addstr(events, \",metric-id=\");\n\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t\tsep = rsep;\n\t\t} else {\n\t\t\tsep = strchr(id, ':');\n\t\t\tif (sep != NULL) {\n\t\t\t\tret = strbuf_add(events, id, sep - id);\n\t\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t\t} else {\n\t\t\t\tret = strbuf_addstr(events, id);\n\t\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t\t}\n\t\t\tret = strbuf_addstr(events, \"/metric-id=\");\n\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t}\n\t\tret = encode_metric_id(events, id);\n\t\tRETURN_IF_NON_ZERO(ret);\n\t\tret = strbuf_addstr(events, \"/\");\n\t\tRETURN_IF_NON_ZERO(ret);\n\n\t\tif (sep != NULL) {\n\t\t\tret = strbuf_addstr(events, sep + 1);\n\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t}\n\t\tif (modifier) {\n\t\t\tret = strbuf_addstr(events, modifier);\n\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t}\n\t}\n\tif (!no_group && group_events) {\n\t\tret = strbuf_addf(events, \"}:W\");\n\t\tRETURN_IF_NON_ZERO(ret);\n\t}\n\tif (has_tool_events) {\n\t\tint i;\n\n\t\tperf_tool_event__for_each_event(i) {\n\t\t\tif (tool_events[i]) {\n\t\t\t\tif (!no_group) {\n\t\t\t\t\tret = strbuf_addch(events, ',');\n\t\t\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t\t\t}\n\t\t\t\tno_group = false;\n\t\t\t\tret = strbuf_addstr(events, perf_tool_event__to_str(i));\n\t\t\t\tRETURN_IF_NON_ZERO(ret);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n#undef RETURN_IF_NON_ZERO\n}\n\nint __weak arch_get_runtimeparam(const struct pmu_metric *pm __maybe_unused)\n{\n\treturn 1;\n}\n\n \nstruct visited_metric {\n\tconst char *name;\n\tconst struct visited_metric *parent;\n};\n\nstruct metricgroup_add_iter_data {\n\tstruct list_head *metric_list;\n\tconst char *pmu;\n\tconst char *metric_name;\n\tconst char *modifier;\n\tint *ret;\n\tbool *has_match;\n\tbool metric_no_group;\n\tbool metric_no_threshold;\n\tconst char *user_requested_cpu_list;\n\tbool system_wide;\n\tstruct metric *root_metric;\n\tconst struct visited_metric *visited;\n\tconst struct pmu_metrics_table *table;\n};\n\nstatic bool metricgroup__find_metric(const char *pmu,\n\t\t\t\t     const char *metric,\n\t\t\t\t     const struct pmu_metrics_table *table,\n\t\t\t\t     struct pmu_metric *pm);\n\nstatic int add_metric(struct list_head *metric_list,\n\t\t      const struct pmu_metric *pm,\n\t\t      const char *modifier,\n\t\t      bool metric_no_group,\n\t\t      bool metric_no_threshold,\n\t\t      const char *user_requested_cpu_list,\n\t\t      bool system_wide,\n\t\t      struct metric *root_metric,\n\t\t      const struct visited_metric *visited,\n\t\t      const struct pmu_metrics_table *table);\n\n \nstatic int resolve_metric(struct list_head *metric_list,\n\t\t\t  const char *pmu,\n\t\t\t  const char *modifier,\n\t\t\t  bool metric_no_group,\n\t\t\t  bool metric_no_threshold,\n\t\t\t  const char *user_requested_cpu_list,\n\t\t\t  bool system_wide,\n\t\t\t  struct metric *root_metric,\n\t\t\t  const struct visited_metric *visited,\n\t\t\t  const struct pmu_metrics_table *table)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\tstruct to_resolve {\n\t\t \n\t\tstruct pmu_metric pm;\n\t\t \n\t\tconst char *key;\n\t} *pending = NULL;\n\tint i, ret = 0, pending_cnt = 0;\n\n\t \n\thashmap__for_each_entry(root_metric->pctx->ids, cur, bkt) {\n\t\tstruct pmu_metric pm;\n\n\t\tif (metricgroup__find_metric(pmu, cur->pkey, table, &pm)) {\n\t\t\tpending = realloc(pending,\n\t\t\t\t\t(pending_cnt + 1) * sizeof(struct to_resolve));\n\t\t\tif (!pending)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmemcpy(&pending[pending_cnt].pm, &pm, sizeof(pm));\n\t\t\tpending[pending_cnt].key = cur->pkey;\n\t\t\tpending_cnt++;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < pending_cnt; i++)\n\t\texpr__del_id(root_metric->pctx, pending[i].key);\n\n\t \n\tfor (i = 0; i < pending_cnt; i++) {\n\t\tret = add_metric(metric_list, &pending[i].pm, modifier, metric_no_group,\n\t\t\t\t metric_no_threshold, user_requested_cpu_list, system_wide,\n\t\t\t\t root_metric, visited, table);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tfree(pending);\n\treturn ret;\n}\n\n \nstatic int __add_metric(struct list_head *metric_list,\n\t\t\tconst struct pmu_metric *pm,\n\t\t\tconst char *modifier,\n\t\t\tbool metric_no_group,\n\t\t\tbool metric_no_threshold,\n\t\t\tint runtime,\n\t\t\tconst char *user_requested_cpu_list,\n\t\t\tbool system_wide,\n\t\t\tstruct metric *root_metric,\n\t\t\tconst struct visited_metric *visited,\n\t\t\tconst struct pmu_metrics_table *table)\n{\n\tconst struct visited_metric *vm;\n\tint ret;\n\tbool is_root = !root_metric;\n\tconst char *expr;\n\tstruct visited_metric visited_node = {\n\t\t.name = pm->metric_name,\n\t\t.parent = visited,\n\t};\n\n\tfor (vm = visited; vm; vm = vm->parent) {\n\t\tif (!strcmp(pm->metric_name, vm->name)) {\n\t\t\tpr_err(\"failed: recursion detected for %s\\n\", pm->metric_name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (is_root) {\n\t\t \n\t\troot_metric = metric__new(pm, modifier, metric_no_group, runtime,\n\t\t\t\t\t  user_requested_cpu_list, system_wide);\n\t\tif (!root_metric)\n\t\t\treturn -ENOMEM;\n\n\t} else {\n\t\tint cnt = 0;\n\n\t\t \n\t\tif (root_metric->metric_refs) {\n\t\t\tfor (; root_metric->metric_refs[cnt].metric_name; cnt++) {\n\t\t\t\tif (!strcmp(pm->metric_name,\n\t\t\t\t\t    root_metric->metric_refs[cnt].metric_name))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\troot_metric->metric_refs = realloc(root_metric->metric_refs,\n\t\t\t\t\t\t(cnt + 2) * sizeof(struct metric_ref));\n\t\tif (!root_metric->metric_refs)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\troot_metric->metric_refs[cnt].metric_name = pm->metric_name;\n\t\troot_metric->metric_refs[cnt].metric_expr = pm->metric_expr;\n\n\t\t \n\t\troot_metric->metric_refs[cnt+1].metric_name = NULL;\n\t\troot_metric->metric_refs[cnt+1].metric_expr = NULL;\n\t}\n\n\t \n\tret = 0;\n\texpr = pm->metric_expr;\n\tif (is_root && pm->metric_threshold) {\n\t\t \n\t\tassert(strstr(pm->metric_threshold, pm->metric_name));\n\t\texpr = metric_no_threshold ? pm->metric_name : pm->metric_threshold;\n\t\tvisited_node.name = \"__threshold__\";\n\t}\n\tif (expr__find_ids(expr, NULL, root_metric->pctx) < 0) {\n\t\t \n\t\tret = -EINVAL;\n\t}\n\tif (!ret) {\n\t\t \n\t\tconst char *pmu = pm->pmu ?: \"cpu\";\n\n\t\tret = resolve_metric(metric_list, pmu, modifier, metric_no_group,\n\t\t\t\t     metric_no_threshold, user_requested_cpu_list,\n\t\t\t\t     system_wide, root_metric, &visited_node,\n\t\t\t\t     table);\n\t}\n\tif (ret) {\n\t\tif (is_root)\n\t\t\tmetric__free(root_metric);\n\n\t} else if (is_root)\n\t\tlist_add(&root_metric->nd, metric_list);\n\n\treturn ret;\n}\n\nstruct metricgroup__find_metric_data {\n\tconst char *pmu;\n\tconst char *metric;\n\tstruct pmu_metric *pm;\n};\n\nstatic int metricgroup__find_metric_callback(const struct pmu_metric *pm,\n\t\t\t\t\t     const struct pmu_metrics_table *table  __maybe_unused,\n\t\t\t\t\t     void *vdata)\n{\n\tstruct metricgroup__find_metric_data *data = vdata;\n\tconst char *pm_pmu = pm->pmu ?: \"cpu\";\n\n\tif (strcmp(data->pmu, \"all\") && strcmp(pm_pmu, data->pmu))\n\t\treturn 0;\n\n\tif (!match_metric(pm->metric_name, data->metric))\n\t\treturn 0;\n\n\tmemcpy(data->pm, pm, sizeof(*pm));\n\treturn 1;\n}\n\nstatic bool metricgroup__find_metric(const char *pmu,\n\t\t\t\t     const char *metric,\n\t\t\t\t     const struct pmu_metrics_table *table,\n\t\t\t\t     struct pmu_metric *pm)\n{\n\tstruct metricgroup__find_metric_data data = {\n\t\t.pmu = pmu,\n\t\t.metric = metric,\n\t\t.pm = pm,\n\t};\n\n\treturn pmu_metrics_table__for_each_metric(table, metricgroup__find_metric_callback, &data)\n\t\t? true : false;\n}\n\nstatic int add_metric(struct list_head *metric_list,\n\t\t      const struct pmu_metric *pm,\n\t\t      const char *modifier,\n\t\t      bool metric_no_group,\n\t\t      bool metric_no_threshold,\n\t\t      const char *user_requested_cpu_list,\n\t\t      bool system_wide,\n\t\t      struct metric *root_metric,\n\t\t      const struct visited_metric *visited,\n\t\t      const struct pmu_metrics_table *table)\n{\n\tint ret = 0;\n\n\tpr_debug(\"metric expr %s for %s\\n\", pm->metric_expr, pm->metric_name);\n\n\tif (!strstr(pm->metric_expr, \"?\")) {\n\t\tret = __add_metric(metric_list, pm, modifier, metric_no_group,\n\t\t\t\t   metric_no_threshold, 0, user_requested_cpu_list,\n\t\t\t\t   system_wide, root_metric, visited, table);\n\t} else {\n\t\tint j, count;\n\n\t\tcount = arch_get_runtimeparam(pm);\n\n\t\t \n\n\t\tfor (j = 0; j < count && !ret; j++)\n\t\t\tret = __add_metric(metric_list, pm, modifier, metric_no_group,\n\t\t\t\t\t   metric_no_threshold, j, user_requested_cpu_list,\n\t\t\t\t\t   system_wide, root_metric, visited, table);\n\t}\n\n\treturn ret;\n}\n\nstatic int metricgroup__add_metric_sys_event_iter(const struct pmu_metric *pm,\n\t\t\t\t\tconst struct pmu_metrics_table *table __maybe_unused,\n\t\t\t\t\tvoid *data)\n{\n\tstruct metricgroup_add_iter_data *d = data;\n\tint ret;\n\n\tif (!match_pm_metric(pm, d->pmu, d->metric_name))\n\t\treturn 0;\n\n\tret = add_metric(d->metric_list, pm, d->modifier, d->metric_no_group,\n\t\t\t d->metric_no_threshold, d->user_requested_cpu_list,\n\t\t\t d->system_wide, d->root_metric, d->visited, d->table);\n\tif (ret)\n\t\tgoto out;\n\n\t*(d->has_match) = true;\n\nout:\n\t*(d->ret) = ret;\n\treturn ret;\n}\n\n \nstatic int metric_list_cmp(void *priv __maybe_unused, const struct list_head *l,\n\t\t\t   const struct list_head *r)\n{\n\tconst struct metric *left = container_of(l, struct metric, nd);\n\tconst struct metric *right = container_of(r, struct metric, nd);\n\tstruct expr_id_data *data;\n\tint i, left_count, right_count;\n\n\tleft_count = hashmap__size(left->pctx->ids);\n\tperf_tool_event__for_each_event(i) {\n\t\tif (!expr__get_id(left->pctx, perf_tool_event__to_str(i), &data))\n\t\t\tleft_count--;\n\t}\n\n\tright_count = hashmap__size(right->pctx->ids);\n\tperf_tool_event__for_each_event(i) {\n\t\tif (!expr__get_id(right->pctx, perf_tool_event__to_str(i), &data))\n\t\t\tright_count--;\n\t}\n\n\treturn right_count - left_count;\n}\n\n \nstatic int default_metricgroup_cmp(void *priv __maybe_unused,\n\t\t\t\t   const struct list_head *l,\n\t\t\t\t   const struct list_head *r)\n{\n\tconst struct metric *left = container_of(l, struct metric, nd);\n\tconst struct metric *right = container_of(r, struct metric, nd);\n\tint diff = strcmp(right->default_metricgroup_name, left->default_metricgroup_name);\n\n\tif (diff)\n\t\treturn diff;\n\n\treturn strcmp(right->metric_name, left->metric_name);\n}\n\nstruct metricgroup__add_metric_data {\n\tstruct list_head *list;\n\tconst char *pmu;\n\tconst char *metric_name;\n\tconst char *modifier;\n\tconst char *user_requested_cpu_list;\n\tbool metric_no_group;\n\tbool metric_no_threshold;\n\tbool system_wide;\n\tbool has_match;\n};\n\nstatic int metricgroup__add_metric_callback(const struct pmu_metric *pm,\n\t\t\t\t\t    const struct pmu_metrics_table *table,\n\t\t\t\t\t    void *vdata)\n{\n\tstruct metricgroup__add_metric_data *data = vdata;\n\tint ret = 0;\n\n\tif (pm->metric_expr && match_pm_metric(pm, data->pmu, data->metric_name)) {\n\t\tbool metric_no_group = data->metric_no_group ||\n\t\t\tmatch_metric(pm->metricgroup_no_group, data->metric_name);\n\n\t\tdata->has_match = true;\n\t\tret = add_metric(data->list, pm, data->modifier, metric_no_group,\n\t\t\t\t data->metric_no_threshold, data->user_requested_cpu_list,\n\t\t\t\t data->system_wide,  NULL,\n\t\t\t\t  NULL, table);\n\t}\n\treturn ret;\n}\n\n \nstatic int metricgroup__add_metric(const char *pmu, const char *metric_name, const char *modifier,\n\t\t\t\t   bool metric_no_group, bool metric_no_threshold,\n\t\t\t\t   const char *user_requested_cpu_list,\n\t\t\t\t   bool system_wide,\n\t\t\t\t   struct list_head *metric_list,\n\t\t\t\t   const struct pmu_metrics_table *table)\n{\n\tLIST_HEAD(list);\n\tint ret;\n\tbool has_match = false;\n\n\t{\n\t\tstruct metricgroup__add_metric_data data = {\n\t\t\t.list = &list,\n\t\t\t.pmu = pmu,\n\t\t\t.metric_name = metric_name,\n\t\t\t.modifier = modifier,\n\t\t\t.metric_no_group = metric_no_group,\n\t\t\t.metric_no_threshold = metric_no_threshold,\n\t\t\t.user_requested_cpu_list = user_requested_cpu_list,\n\t\t\t.system_wide = system_wide,\n\t\t\t.has_match = false,\n\t\t};\n\t\t \n\t\tret = pmu_metrics_table__for_each_metric(table, metricgroup__add_metric_callback,\n\t\t\t\t\t\t       &data);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\thas_match = data.has_match;\n\t}\n\t{\n\t\tstruct metricgroup_iter_data data = {\n\t\t\t.fn = metricgroup__add_metric_sys_event_iter,\n\t\t\t.data = (void *) &(struct metricgroup_add_iter_data) {\n\t\t\t\t.metric_list = &list,\n\t\t\t\t.pmu = pmu,\n\t\t\t\t.metric_name = metric_name,\n\t\t\t\t.modifier = modifier,\n\t\t\t\t.metric_no_group = metric_no_group,\n\t\t\t\t.user_requested_cpu_list = user_requested_cpu_list,\n\t\t\t\t.system_wide = system_wide,\n\t\t\t\t.has_match = &has_match,\n\t\t\t\t.ret = &ret,\n\t\t\t\t.table = table,\n\t\t\t},\n\t\t};\n\n\t\tpmu_for_each_sys_metric(metricgroup__sys_event_iter, &data);\n\t}\n\t \n\tif (!has_match)\n\t\tret = -EINVAL;\n\nout:\n\t \n\tlist_splice(&list, metric_list);\n\treturn ret;\n}\n\n \nstatic int metricgroup__add_metric_list(const char *pmu, const char *list,\n\t\t\t\t\tbool metric_no_group,\n\t\t\t\t\tbool metric_no_threshold,\n\t\t\t\t\tconst char *user_requested_cpu_list,\n\t\t\t\t\tbool system_wide, struct list_head *metric_list,\n\t\t\t\t\tconst struct pmu_metrics_table *table)\n{\n\tchar *list_itr, *list_copy, *metric_name, *modifier;\n\tint ret, count = 0;\n\n\tlist_copy = strdup(list);\n\tif (!list_copy)\n\t\treturn -ENOMEM;\n\tlist_itr = list_copy;\n\n\twhile ((metric_name = strsep(&list_itr, \",\")) != NULL) {\n\t\tmodifier = strchr(metric_name, ':');\n\t\tif (modifier)\n\t\t\t*modifier++ = '\\0';\n\n\t\tret = metricgroup__add_metric(pmu, metric_name, modifier,\n\t\t\t\t\t      metric_no_group, metric_no_threshold,\n\t\t\t\t\t      user_requested_cpu_list,\n\t\t\t\t\t      system_wide, metric_list, table);\n\t\tif (ret == -EINVAL)\n\t\t\tpr_err(\"Cannot find metric or group `%s'\\n\", metric_name);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tcount++;\n\t}\n\tfree(list_copy);\n\n\tif (!ret) {\n\t\t \n\t\tmetric__watchdog_constraint_hint(NULL,  true);\n\t\t \n\t\tif (count == 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic void metricgroup__free_metrics(struct list_head *metric_list)\n{\n\tstruct metric *m, *tmp;\n\n\tlist_for_each_entry_safe (m, tmp, metric_list, nd) {\n\t\tlist_del_init(&m->nd);\n\t\tmetric__free(m);\n\t}\n}\n\n \nstatic void find_tool_events(const struct list_head *metric_list,\n\t\t\t     bool tool_events[PERF_TOOL_MAX])\n{\n\tstruct metric *m;\n\n\tlist_for_each_entry(m, metric_list, nd) {\n\t\tint i;\n\n\t\tperf_tool_event__for_each_event(i) {\n\t\t\tstruct expr_id_data *data;\n\n\t\t\tif (!tool_events[i] &&\n\t\t\t    !expr__get_id(m->pctx, perf_tool_event__to_str(i), &data))\n\t\t\t\ttool_events[i] = true;\n\t\t}\n\t}\n}\n\n \nstatic int build_combined_expr_ctx(const struct list_head *metric_list,\n\t\t\t\t   struct expr_parse_ctx **combined)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\tstruct metric *m;\n\tchar *dup;\n\tint ret;\n\n\t*combined = expr__ctx_new();\n\tif (!*combined)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(m, metric_list, nd) {\n\t\tif (!m->group_events && !m->modifier) {\n\t\t\thashmap__for_each_entry(m->pctx->ids, cur, bkt) {\n\t\t\t\tdup = strdup(cur->pkey);\n\t\t\t\tif (!dup) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t\tret = expr__add_id(*combined, dup);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\nerr_out:\n\texpr__ctx_free(*combined);\n\t*combined = NULL;\n\treturn ret;\n}\n\n \nstatic int parse_ids(bool metric_no_merge, struct perf_pmu *fake_pmu,\n\t\t     struct expr_parse_ctx *ids, const char *modifier,\n\t\t     bool group_events, const bool tool_events[PERF_TOOL_MAX],\n\t\t     struct evlist **out_evlist)\n{\n\tstruct parse_events_error parse_error;\n\tstruct evlist *parsed_evlist;\n\tstruct strbuf events = STRBUF_INIT;\n\tint ret;\n\n\t*out_evlist = NULL;\n\tif (!metric_no_merge || hashmap__size(ids->ids) == 0) {\n\t\tbool added_event = false;\n\t\tint i;\n\t\t \n\t\tperf_tool_event__for_each_event(i) {\n\t\t\tif (tool_events[i]) {\n\t\t\t\tchar *tmp = strdup(perf_tool_event__to_str(i));\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tids__insert(ids->ids, tmp);\n\t\t\t\tadded_event = true;\n\t\t\t}\n\t\t}\n\t\tif (!added_event && hashmap__size(ids->ids) == 0) {\n\t\t\tchar *tmp = strdup(\"duration_time\");\n\n\t\t\tif (!tmp)\n\t\t\t\treturn -ENOMEM;\n\t\t\tids__insert(ids->ids, tmp);\n\t\t}\n\t}\n\tret = metricgroup__build_event_string(&events, ids, modifier,\n\t\t\t\t\t      group_events);\n\tif (ret)\n\t\treturn ret;\n\n\tparsed_evlist = evlist__new();\n\tif (!parsed_evlist) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tpr_debug(\"Parsing metric events '%s'\\n\", events.buf);\n\tparse_events_error__init(&parse_error);\n\tret = __parse_events(parsed_evlist, events.buf,  NULL,\n\t\t\t     &parse_error, fake_pmu,  false);\n\tif (ret) {\n\t\tparse_events_error__print(&parse_error, events.buf);\n\t\tgoto err_out;\n\t}\n\tret = decode_all_metric_ids(parsed_evlist, modifier);\n\tif (ret)\n\t\tgoto err_out;\n\n\t*out_evlist = parsed_evlist;\n\tparsed_evlist = NULL;\nerr_out:\n\tparse_events_error__exit(&parse_error);\n\tevlist__delete(parsed_evlist);\n\tstrbuf_release(&events);\n\treturn ret;\n}\n\nstatic int parse_groups(struct evlist *perf_evlist,\n\t\t\tconst char *pmu, const char *str,\n\t\t\tbool metric_no_group,\n\t\t\tbool metric_no_merge,\n\t\t\tbool metric_no_threshold,\n\t\t\tconst char *user_requested_cpu_list,\n\t\t\tbool system_wide,\n\t\t\tstruct perf_pmu *fake_pmu,\n\t\t\tstruct rblist *metric_events_list,\n\t\t\tconst struct pmu_metrics_table *table)\n{\n\tstruct evlist *combined_evlist = NULL;\n\tLIST_HEAD(metric_list);\n\tstruct metric *m;\n\tbool tool_events[PERF_TOOL_MAX] = {false};\n\tbool is_default = !strcmp(str, \"Default\");\n\tint ret;\n\n\tif (metric_events_list->nr_entries == 0)\n\t\tmetricgroup__rblist_init(metric_events_list);\n\tret = metricgroup__add_metric_list(pmu, str, metric_no_group, metric_no_threshold,\n\t\t\t\t\t   user_requested_cpu_list,\n\t\t\t\t\t   system_wide, &metric_list, table);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tlist_sort(NULL, &metric_list, metric_list_cmp);\n\n\tif (!metric_no_merge) {\n\t\tstruct expr_parse_ctx *combined = NULL;\n\n\t\tfind_tool_events(&metric_list, tool_events);\n\n\t\tret = build_combined_expr_ctx(&metric_list, &combined);\n\n\t\tif (!ret && combined && hashmap__size(combined->ids)) {\n\t\t\tret = parse_ids(metric_no_merge, fake_pmu, combined,\n\t\t\t\t\t NULL,\n\t\t\t\t\t false,\n\t\t\t\t\ttool_events,\n\t\t\t\t\t&combined_evlist);\n\t\t}\n\t\tif (combined)\n\t\t\texpr__ctx_free(combined);\n\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (is_default)\n\t\tlist_sort(NULL, &metric_list, default_metricgroup_cmp);\n\n\tlist_for_each_entry(m, &metric_list, nd) {\n\t\tstruct metric_event *me;\n\t\tstruct evsel **metric_events;\n\t\tstruct evlist *metric_evlist = NULL;\n\t\tstruct metric *n;\n\t\tstruct metric_expr *expr;\n\n\t\tif (combined_evlist && !m->group_events) {\n\t\t\tmetric_evlist = combined_evlist;\n\t\t} else if (!metric_no_merge) {\n\t\t\t \n\t\t\tlist_for_each_entry(n, &metric_list, nd) {\n\t\t\t\tif (m == n)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (n->evlist == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ((!m->modifier && n->modifier) ||\n\t\t\t\t    (m->modifier && !n->modifier) ||\n\t\t\t\t    (m->modifier && n->modifier &&\n\t\t\t\t\t    strcmp(m->modifier, n->modifier)))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ((!m->pmu && n->pmu) ||\n\t\t\t\t    (m->pmu && !n->pmu) ||\n\t\t\t\t    (m->pmu && n->pmu && strcmp(m->pmu, n->pmu)))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (expr__subset_of_ids(n->pctx, m->pctx)) {\n\t\t\t\t\tpr_debug(\"Events in '%s' fully contained within '%s'\\n\",\n\t\t\t\t\t\t m->metric_name, n->metric_name);\n\t\t\t\t\tmetric_evlist = n->evlist;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (!metric_evlist) {\n\t\t\tret = parse_ids(metric_no_merge, fake_pmu, m->pctx, m->modifier,\n\t\t\t\t\tm->group_events, tool_events, &m->evlist);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tmetric_evlist = m->evlist;\n\t\t}\n\t\tret = setup_metric_events(fake_pmu ? \"all\" : m->pmu, m->pctx->ids,\n\t\t\t\t\t  metric_evlist, &metric_events);\n\t\tif (ret) {\n\t\t\tpr_err(\"Cannot resolve IDs for %s: %s\\n\",\n\t\t\t\tm->metric_name, m->metric_expr);\n\t\t\tgoto out;\n\t\t}\n\n\t\tme = metricgroup__lookup(metric_events_list, metric_events[0], true);\n\n\t\texpr = malloc(sizeof(struct metric_expr));\n\t\tif (!expr) {\n\t\t\tret = -ENOMEM;\n\t\t\tfree(metric_events);\n\t\t\tgoto out;\n\t\t}\n\n\t\texpr->metric_refs = m->metric_refs;\n\t\tm->metric_refs = NULL;\n\t\texpr->metric_expr = m->metric_expr;\n\t\tif (m->modifier) {\n\t\t\tchar *tmp;\n\n\t\t\tif (asprintf(&tmp, \"%s:%s\", m->metric_name, m->modifier) < 0)\n\t\t\t\texpr->metric_name = NULL;\n\t\t\telse\n\t\t\t\texpr->metric_name = tmp;\n\t\t} else\n\t\t\texpr->metric_name = strdup(m->metric_name);\n\n\t\tif (!expr->metric_name) {\n\t\t\tret = -ENOMEM;\n\t\t\tfree(metric_events);\n\t\t\tgoto out;\n\t\t}\n\t\texpr->metric_threshold = m->metric_threshold;\n\t\texpr->metric_unit = m->metric_unit;\n\t\texpr->metric_events = metric_events;\n\t\texpr->runtime = m->pctx->sctx.runtime;\n\t\texpr->default_metricgroup_name = m->default_metricgroup_name;\n\t\tme->is_default = is_default;\n\t\tlist_add(&expr->nd, &me->head);\n\t}\n\n\n\tif (combined_evlist) {\n\t\tevlist__splice_list_tail(perf_evlist, &combined_evlist->core.entries);\n\t\tevlist__delete(combined_evlist);\n\t}\n\n\tlist_for_each_entry(m, &metric_list, nd) {\n\t\tif (m->evlist)\n\t\t\tevlist__splice_list_tail(perf_evlist, &m->evlist->core.entries);\n\t}\n\nout:\n\tmetricgroup__free_metrics(&metric_list);\n\treturn ret;\n}\n\nint metricgroup__parse_groups(struct evlist *perf_evlist,\n\t\t\t      const char *pmu,\n\t\t\t      const char *str,\n\t\t\t      bool metric_no_group,\n\t\t\t      bool metric_no_merge,\n\t\t\t      bool metric_no_threshold,\n\t\t\t      const char *user_requested_cpu_list,\n\t\t\t      bool system_wide,\n\t\t\t      struct rblist *metric_events)\n{\n\tconst struct pmu_metrics_table *table = pmu_metrics_table__find();\n\n\tif (!table)\n\t\treturn -EINVAL;\n\n\treturn parse_groups(perf_evlist, pmu, str, metric_no_group, metric_no_merge,\n\t\t\t    metric_no_threshold, user_requested_cpu_list, system_wide,\n\t\t\t     NULL, metric_events, table);\n}\n\nint metricgroup__parse_groups_test(struct evlist *evlist,\n\t\t\t\t   const struct pmu_metrics_table *table,\n\t\t\t\t   const char *str,\n\t\t\t\t   struct rblist *metric_events)\n{\n\treturn parse_groups(evlist, \"all\", str,\n\t\t\t     false,\n\t\t\t     false,\n\t\t\t     false,\n\t\t\t     NULL,\n\t\t\t     false,\n\t\t\t    &perf_pmu__fake, metric_events, table);\n}\n\nstruct metricgroup__has_metric_data {\n\tconst char *pmu;\n\tconst char *metric;\n};\nstatic int metricgroup__has_metric_callback(const struct pmu_metric *pm,\n\t\t\t\t\t    const struct pmu_metrics_table *table __maybe_unused,\n\t\t\t\t\t    void *vdata)\n{\n\tstruct metricgroup__has_metric_data *data = vdata;\n\n\treturn match_pm_metric(pm, data->pmu, data->metric) ? 1 : 0;\n}\n\nbool metricgroup__has_metric(const char *pmu, const char *metric)\n{\n\tconst struct pmu_metrics_table *table = pmu_metrics_table__find();\n\tstruct metricgroup__has_metric_data data = {\n\t\t.pmu = pmu,\n\t\t.metric = metric,\n\t};\n\n\tif (!table)\n\t\treturn false;\n\n\treturn pmu_metrics_table__for_each_metric(table, metricgroup__has_metric_callback, &data)\n\t\t? true : false;\n}\n\nstatic int metricgroup__topdown_max_level_callback(const struct pmu_metric *pm,\n\t\t\t\t\t    const struct pmu_metrics_table *table __maybe_unused,\n\t\t\t\t\t    void *data)\n{\n\tunsigned int *max_level = data;\n\tunsigned int level;\n\tconst char *p = strstr(pm->metric_group ?: \"\", \"TopdownL\");\n\n\tif (!p || p[8] == '\\0')\n\t\treturn 0;\n\n\tlevel = p[8] - '0';\n\tif (level > *max_level)\n\t\t*max_level = level;\n\n\treturn 0;\n}\n\nunsigned int metricgroups__topdown_max_level(void)\n{\n\tunsigned int max_level = 0;\n\tconst struct pmu_metrics_table *table = pmu_metrics_table__find();\n\n\tif (!table)\n\t\treturn false;\n\n\tpmu_metrics_table__for_each_metric(table, metricgroup__topdown_max_level_callback,\n\t\t\t\t\t  &max_level);\n\treturn max_level;\n}\n\nint metricgroup__copy_metric_events(struct evlist *evlist, struct cgroup *cgrp,\n\t\t\t\t    struct rblist *new_metric_events,\n\t\t\t\t    struct rblist *old_metric_events)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < rblist__nr_entries(old_metric_events); i++) {\n\t\tstruct rb_node *nd;\n\t\tstruct metric_event *old_me, *new_me;\n\t\tstruct metric_expr *old_expr, *new_expr;\n\t\tstruct evsel *evsel;\n\t\tsize_t alloc_size;\n\t\tint idx, nr;\n\n\t\tnd = rblist__entry(old_metric_events, i);\n\t\told_me = container_of(nd, struct metric_event, nd);\n\n\t\tevsel = evlist__find_evsel(evlist, old_me->evsel->core.idx);\n\t\tif (!evsel)\n\t\t\treturn -EINVAL;\n\t\tnew_me = metricgroup__lookup(new_metric_events, evsel, true);\n\t\tif (!new_me)\n\t\t\treturn -ENOMEM;\n\n\t\tpr_debug(\"copying metric event for cgroup '%s': %s (idx=%d)\\n\",\n\t\t\t cgrp ? cgrp->name : \"root\", evsel->name, evsel->core.idx);\n\n\t\tlist_for_each_entry(old_expr, &old_me->head, nd) {\n\t\t\tnew_expr = malloc(sizeof(*new_expr));\n\t\t\tif (!new_expr)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnew_expr->metric_expr = old_expr->metric_expr;\n\t\t\tnew_expr->metric_threshold = old_expr->metric_threshold;\n\t\t\tnew_expr->metric_name = strdup(old_expr->metric_name);\n\t\t\tif (!new_expr->metric_name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnew_expr->metric_unit = old_expr->metric_unit;\n\t\t\tnew_expr->runtime = old_expr->runtime;\n\n\t\t\tif (old_expr->metric_refs) {\n\t\t\t\t \n\t\t\t\tfor (nr = 0; old_expr->metric_refs[nr].metric_name; nr++)\n\t\t\t\t\tcontinue;\n\t\t\t\talloc_size = sizeof(*new_expr->metric_refs);\n\t\t\t\tnew_expr->metric_refs = calloc(nr + 1, alloc_size);\n\t\t\t\tif (!new_expr->metric_refs) {\n\t\t\t\t\tfree(new_expr);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(new_expr->metric_refs, old_expr->metric_refs,\n\t\t\t\t       nr * alloc_size);\n\t\t\t} else {\n\t\t\t\tnew_expr->metric_refs = NULL;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (nr = 0; old_expr->metric_events[nr]; nr++)\n\t\t\t\tcontinue;\n\t\t\talloc_size = sizeof(*new_expr->metric_events);\n\t\t\tnew_expr->metric_events = calloc(nr + 1, alloc_size);\n\t\t\tif (!new_expr->metric_events) {\n\t\t\t\tzfree(&new_expr->metric_refs);\n\t\t\t\tfree(new_expr);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (idx = 0; idx < nr; idx++) {\n\t\t\t\tevsel = old_expr->metric_events[idx];\n\t\t\t\tevsel = evlist__find_evsel(evlist, evsel->core.idx);\n\t\t\t\tif (evsel == NULL) {\n\t\t\t\t\tzfree(&new_expr->metric_events);\n\t\t\t\t\tzfree(&new_expr->metric_refs);\n\t\t\t\t\tfree(new_expr);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tnew_expr->metric_events[idx] = evsel;\n\t\t\t}\n\n\t\t\tlist_add(&new_expr->nd, &new_me->head);\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}