{
  "module_name": "jitdump.c",
  "hash_id": "d6c3788c836ca1b326bd9ea6108e8a4d12458e44a7c10d411bd37b0a051e65e7",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/jitdump.c",
  "human_readable_source": "\n#include <sys/sysmacros.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <libgen.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <inttypes.h>\n#include <byteswap.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <linux/stringify.h>\n\n#include \"build-id.h\"\n#include \"event.h\"\n#include \"debug.h\"\n#include \"evlist.h\"\n#include \"namespaces.h\"\n#include \"symbol.h\"\n#include <elf.h>\n\n#include \"tsc.h\"\n#include \"session.h\"\n#include \"jit.h\"\n#include \"jitdump.h\"\n#include \"genelf.h\"\n#include \"thread.h\"\n\n#include <linux/ctype.h>\n#include <linux/zalloc.h>\n\nstruct jit_buf_desc {\n\tstruct perf_data *output;\n\tstruct perf_session *session;\n\tstruct machine *machine;\n\tstruct nsinfo  *nsi;\n\tunion jr_entry   *entry;\n\tvoid             *buf;\n\tuint64_t\t sample_type;\n\tsize_t           bufsize;\n\tFILE             *in;\n\tbool\t\t needs_bswap;  \n\tbool\t\t use_arch_timestamp;\n\tvoid\t\t *debug_data;\n\tvoid\t\t *unwinding_data;\n\tuint64_t\t unwinding_size;\n\tuint64_t\t unwinding_mapped_size;\n\tuint64_t         eh_frame_hdr_size;\n\tsize_t\t\t nr_debug_entries;\n\tuint32_t         code_load_count;\n\tu64\t\t bytes_written;\n\tstruct rb_root   code_root;\n\tchar\t\t dir[PATH_MAX];\n};\n\nstruct jit_tool {\n\tstruct perf_tool tool;\n\tstruct perf_data\toutput;\n\tstruct perf_data\tinput;\n\tu64 bytes_written;\n};\n\n#define hmax(a, b) ((a) > (b) ? (a) : (b))\n#define get_jit_tool(t) (container_of(tool, struct jit_tool, tool))\n\nstatic int\njit_emit_elf(struct jit_buf_desc *jd,\n\t     char *filename,\n\t     const char *sym,\n\t     uint64_t code_addr,\n\t     const void *code,\n\t     int csize,\n\t     void *debug,\n\t     int nr_debug_entries,\n\t     void *unwinding,\n\t     uint32_t unwinding_header_size,\n\t     uint32_t unwinding_size)\n{\n\tint ret, fd, saved_errno;\n\tstruct nscookie nsc;\n\n\tif (verbose > 0)\n\t\tfprintf(stderr, \"write ELF image %s\\n\", filename);\n\n\tnsinfo__mountns_enter(jd->nsi, &nsc);\n\tfd = open(filename, O_CREAT|O_TRUNC|O_WRONLY, 0644);\n\tsaved_errno = errno;\n\tnsinfo__mountns_exit(&nsc);\n\tif (fd == -1) {\n\t\tpr_warning(\"cannot create jit ELF %s: %s\\n\", filename, strerror(saved_errno));\n\t\treturn -1;\n\t}\n\n\tret = jit_write_elf(fd, code_addr, sym, (const void *)code, csize, debug, nr_debug_entries,\n\t\t\t    unwinding, unwinding_header_size, unwinding_size);\n\n        close(fd);\n\n\tif (ret) {\n\t\tnsinfo__mountns_enter(jd->nsi, &nsc);\n\t\tunlink(filename);\n\t\tnsinfo__mountns_exit(&nsc);\n\t}\n\n\treturn ret;\n}\n\nstatic void\njit_close(struct jit_buf_desc *jd)\n{\n\tif (!(jd && jd->in))\n\t\treturn;\n\tfunlockfile(jd->in);\n\tfclose(jd->in);\n\tjd->in = NULL;\n}\n\nstatic int\njit_validate_events(struct perf_session *session)\n{\n\tstruct evsel *evsel;\n\n\t \n\tevlist__for_each_entry(session->evlist, evsel) {\n\t\tif (evsel->core.attr.use_clockid == 0 || evsel->core.attr.clockid != CLOCK_MONOTONIC)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\njit_open(struct jit_buf_desc *jd, const char *name)\n{\n\tstruct jitheader header;\n\tstruct nscookie nsc;\n\tstruct jr_prefix *prefix;\n\tssize_t bs, bsz = 0;\n\tvoid *n, *buf = NULL;\n\tint ret, retval = -1;\n\n\tnsinfo__mountns_enter(jd->nsi, &nsc);\n\tjd->in = fopen(name, \"r\");\n\tnsinfo__mountns_exit(&nsc);\n\tif (!jd->in)\n\t\treturn -1;\n\n\tbsz = hmax(sizeof(header), sizeof(*prefix));\n\n\tbuf = malloc(bsz);\n\tif (!buf)\n\t\tgoto error;\n\n\t \n\tflockfile(jd->in);\n\n\tret = fread(buf, sizeof(header), 1, jd->in);\n\tif (ret != 1)\n\t\tgoto error;\n\n\tmemcpy(&header, buf, sizeof(header));\n\n\tif (header.magic != JITHEADER_MAGIC) {\n\t\tif (header.magic != JITHEADER_MAGIC_SW)\n\t\t\tgoto error;\n\t\tjd->needs_bswap = true;\n\t}\n\n\tif (jd->needs_bswap) {\n\t\theader.version    = bswap_32(header.version);\n\t\theader.total_size = bswap_32(header.total_size);\n\t\theader.pid\t  = bswap_32(header.pid);\n\t\theader.elf_mach   = bswap_32(header.elf_mach);\n\t\theader.timestamp  = bswap_64(header.timestamp);\n\t\theader.flags      = bswap_64(header.flags);\n\t}\n\n\tjd->use_arch_timestamp = header.flags & JITDUMP_FLAGS_ARCH_TIMESTAMP;\n\n\tif (verbose > 2)\n\t\tpr_debug(\"version=%u\\nhdr.size=%u\\nts=0x%llx\\npid=%d\\nelf_mach=%d\\nuse_arch_timestamp=%d\\n\",\n\t\t\theader.version,\n\t\t\theader.total_size,\n\t\t\t(unsigned long long)header.timestamp,\n\t\t\theader.pid,\n\t\t\theader.elf_mach,\n\t\t\tjd->use_arch_timestamp);\n\n\tif (header.version > JITHEADER_VERSION) {\n\t\tpr_err(\"wrong jitdump version %u, expected \" __stringify(JITHEADER_VERSION),\n\t\t\theader.version);\n\t\tgoto error;\n\t}\n\n\tif (header.flags & JITDUMP_FLAGS_RESERVED) {\n\t\tpr_err(\"jitdump file contains invalid or unsupported flags 0x%llx\\n\",\n\t\t       (unsigned long long)header.flags & JITDUMP_FLAGS_RESERVED);\n\t\tgoto error;\n\t}\n\n\tif (jd->use_arch_timestamp && !jd->session->time_conv.time_mult) {\n\t\tpr_err(\"jitdump file uses arch timestamps but there is no timestamp conversion\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tif (!jd->use_arch_timestamp && jit_validate_events(jd->session)) {\n\t\tpr_err(\"error, jitted code must be sampled with perf record -k 1\\n\");\n\t\tgoto error;\n\t}\n\n\tbs = header.total_size - sizeof(header);\n\n\tif (bs > bsz) {\n\t\tn = realloc(buf, bs);\n\t\tif (!n)\n\t\t\tgoto error;\n\t\tbsz = bs;\n\t\tbuf = n;\n\t\t \n\t\tret = fread(buf, bs - bsz, 1, jd->in);\n\t\tif (ret != 1)\n\t\t\tgoto error;\n\t}\n\t \n\tstrcpy(jd->dir, name);\n\tdirname(jd->dir);\n\tfree(buf);\n\n\treturn 0;\nerror:\n\tfree(buf);\n\tfunlockfile(jd->in);\n\tfclose(jd->in);\n\treturn retval;\n}\n\nstatic union jr_entry *\njit_get_next_entry(struct jit_buf_desc *jd)\n{\n\tstruct jr_prefix *prefix;\n\tunion jr_entry *jr;\n\tvoid *addr;\n\tsize_t bs, size;\n\tint id, ret;\n\n\tif (!(jd && jd->in))\n\t\treturn NULL;\n\n\tif (jd->buf == NULL) {\n\t\tsize_t sz = getpagesize();\n\t\tif (sz < sizeof(*prefix))\n\t\t\tsz = sizeof(*prefix);\n\n\t\tjd->buf = malloc(sz);\n\t\tif (jd->buf == NULL)\n\t\t\treturn NULL;\n\n\t\tjd->bufsize = sz;\n\t}\n\n\tprefix = jd->buf;\n\n\t \n\tret = fread(prefix, sizeof(*prefix), 1, jd->in);\n\tif (ret  != 1)\n\t\treturn NULL;\n\n\tif (jd->needs_bswap) {\n\t\tprefix->id   \t   = bswap_32(prefix->id);\n\t\tprefix->total_size = bswap_32(prefix->total_size);\n\t\tprefix->timestamp  = bswap_64(prefix->timestamp);\n\t}\n\tid   = prefix->id;\n\tsize = prefix->total_size;\n\n\tbs = (size_t)size;\n\tif (bs < sizeof(*prefix))\n\t\treturn NULL;\n\n\tif (id >= JIT_CODE_MAX) {\n\t\tpr_warning(\"next_entry: unknown record type %d, skipping\\n\", id);\n\t}\n\tif (bs > jd->bufsize) {\n\t\tvoid *n;\n\t\tn = realloc(jd->buf, bs);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tjd->buf = n;\n\t\tjd->bufsize = bs;\n\t}\n\n\taddr = ((void *)jd->buf) + sizeof(*prefix);\n\n\tret = fread(addr, bs - sizeof(*prefix), 1, jd->in);\n\tif (ret != 1)\n\t\treturn NULL;\n\n\tjr = (union jr_entry *)jd->buf;\n\n\tswitch(id) {\n\tcase JIT_CODE_DEBUG_INFO:\n\t\tif (jd->needs_bswap) {\n\t\t\tuint64_t n;\n\t\t\tjr->info.code_addr = bswap_64(jr->info.code_addr);\n\t\t\tjr->info.nr_entry  = bswap_64(jr->info.nr_entry);\n\t\t\tfor (n = 0 ; n < jr->info.nr_entry; n++) {\n\t\t\t\tjr->info.entries[n].addr    = bswap_64(jr->info.entries[n].addr);\n\t\t\t\tjr->info.entries[n].lineno  = bswap_32(jr->info.entries[n].lineno);\n\t\t\t\tjr->info.entries[n].discrim = bswap_32(jr->info.entries[n].discrim);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase JIT_CODE_UNWINDING_INFO:\n\t\tif (jd->needs_bswap) {\n\t\t\tjr->unwinding.unwinding_size = bswap_64(jr->unwinding.unwinding_size);\n\t\t\tjr->unwinding.eh_frame_hdr_size = bswap_64(jr->unwinding.eh_frame_hdr_size);\n\t\t\tjr->unwinding.mapped_size = bswap_64(jr->unwinding.mapped_size);\n\t\t}\n\t\tbreak;\n\tcase JIT_CODE_CLOSE:\n\t\tbreak;\n\tcase JIT_CODE_LOAD:\n\t\tif (jd->needs_bswap) {\n\t\t\tjr->load.pid       = bswap_32(jr->load.pid);\n\t\t\tjr->load.tid       = bswap_32(jr->load.tid);\n\t\t\tjr->load.vma       = bswap_64(jr->load.vma);\n\t\t\tjr->load.code_addr = bswap_64(jr->load.code_addr);\n\t\t\tjr->load.code_size = bswap_64(jr->load.code_size);\n\t\t\tjr->load.code_index= bswap_64(jr->load.code_index);\n\t\t}\n\t\tjd->code_load_count++;\n\t\tbreak;\n\tcase JIT_CODE_MOVE:\n\t\tif (jd->needs_bswap) {\n\t\t\tjr->move.pid           = bswap_32(jr->move.pid);\n\t\t\tjr->move.tid           = bswap_32(jr->move.tid);\n\t\t\tjr->move.vma           = bswap_64(jr->move.vma);\n\t\t\tjr->move.old_code_addr = bswap_64(jr->move.old_code_addr);\n\t\t\tjr->move.new_code_addr = bswap_64(jr->move.new_code_addr);\n\t\t\tjr->move.code_size     = bswap_64(jr->move.code_size);\n\t\t\tjr->move.code_index    = bswap_64(jr->move.code_index);\n\t\t}\n\t\tbreak;\n\tcase JIT_CODE_MAX:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn jr;\n}\n\nstatic int\njit_inject_event(struct jit_buf_desc *jd, union perf_event *event)\n{\n\tssize_t size;\n\n\tsize = perf_data__write(jd->output, event, event->header.size);\n\tif (size < 0)\n\t\treturn -1;\n\n\tjd->bytes_written += size;\n\treturn 0;\n}\n\nstatic pid_t jr_entry_pid(struct jit_buf_desc *jd, union jr_entry *jr)\n{\n\tif (jd->nsi && nsinfo__in_pidns(jd->nsi))\n\t\treturn nsinfo__tgid(jd->nsi);\n\treturn jr->load.pid;\n}\n\nstatic pid_t jr_entry_tid(struct jit_buf_desc *jd, union jr_entry *jr)\n{\n\tif (jd->nsi && nsinfo__in_pidns(jd->nsi))\n\t\treturn nsinfo__pid(jd->nsi);\n\treturn jr->load.tid;\n}\n\nstatic uint64_t convert_timestamp(struct jit_buf_desc *jd, uint64_t timestamp)\n{\n\tstruct perf_tsc_conversion tc = { .time_shift = 0, };\n\tstruct perf_record_time_conv *time_conv = &jd->session->time_conv;\n\n\tif (!jd->use_arch_timestamp)\n\t\treturn timestamp;\n\n\ttc.time_shift = time_conv->time_shift;\n\ttc.time_mult  = time_conv->time_mult;\n\ttc.time_zero  = time_conv->time_zero;\n\n\t \n\tif (event_contains(*time_conv, time_cycles)) {\n\t\ttc.time_cycles\t       = time_conv->time_cycles;\n\t\ttc.time_mask\t       = time_conv->time_mask;\n\t\ttc.cap_user_time_zero  = time_conv->cap_user_time_zero;\n\t\ttc.cap_user_time_short = time_conv->cap_user_time_short;\n\n\t\tif (!tc.cap_user_time_zero)\n\t\t\treturn 0;\n\t}\n\n\treturn tsc_to_perf_time(timestamp, &tc);\n}\n\nstatic int jit_repipe_code_load(struct jit_buf_desc *jd, union jr_entry *jr)\n{\n\tstruct perf_sample sample;\n\tunion perf_event *event;\n\tstruct perf_tool *tool = jd->session->tool;\n\tuint64_t code, addr;\n\tuintptr_t uaddr;\n\tchar *filename;\n\tstruct stat st;\n\tsize_t size;\n\tu16 idr_size;\n\tconst char *sym;\n\tuint64_t count;\n\tint ret, csize, usize;\n\tpid_t nspid, pid, tid;\n\tstruct {\n\t\tu32 pid, tid;\n\t\tu64 time;\n\t} *id;\n\n\tnspid = jr->load.pid;\n\tpid   = jr_entry_pid(jd, jr);\n\ttid   = jr_entry_tid(jd, jr);\n\tcsize = jr->load.code_size;\n\tusize = jd->unwinding_mapped_size;\n\taddr  = jr->load.code_addr;\n\tsym   = (void *)((unsigned long)jr + sizeof(jr->load));\n\tcode  = (unsigned long)jr + jr->load.p.total_size - csize;\n\tcount = jr->load.code_index;\n\tidr_size = jd->machine->id_hdr_size;\n\n\tevent = calloc(1, sizeof(*event) + idr_size);\n\tif (!event)\n\t\treturn -1;\n\n\tfilename = event->mmap2.filename;\n\tsize = snprintf(filename, PATH_MAX, \"%s/jitted-%d-%\" PRIu64 \".so\",\n\t\t\tjd->dir,\n\t\t\tnspid,\n\t\t\tcount);\n\n\tsize++;  \n\n\tsize = PERF_ALIGN(size, sizeof(u64));\n\tuaddr = (uintptr_t)code;\n\tret = jit_emit_elf(jd, filename, sym, addr, (const void *)uaddr, csize, jd->debug_data, jd->nr_debug_entries,\n\t\t\t   jd->unwinding_data, jd->eh_frame_hdr_size, jd->unwinding_size);\n\n\tif (jd->debug_data && jd->nr_debug_entries) {\n\t\tzfree(&jd->debug_data);\n\t\tjd->nr_debug_entries = 0;\n\t}\n\n\tif (jd->unwinding_data && jd->eh_frame_hdr_size) {\n\t\tzfree(&jd->unwinding_data);\n\t\tjd->eh_frame_hdr_size = 0;\n\t\tjd->unwinding_mapped_size = 0;\n\t\tjd->unwinding_size = 0;\n\t}\n\n\tif (ret) {\n\t\tfree(event);\n\t\treturn -1;\n\t}\n\tif (nsinfo__stat(filename, &st, jd->nsi))\n\t\tmemset(&st, 0, sizeof(st));\n\n\tevent->mmap2.header.type = PERF_RECORD_MMAP2;\n\tevent->mmap2.header.misc = PERF_RECORD_MISC_USER;\n\tevent->mmap2.header.size = (sizeof(event->mmap2) -\n\t\t\t(sizeof(event->mmap2.filename) - size) + idr_size);\n\n\tevent->mmap2.pgoff = GEN_ELF_TEXT_OFFSET;\n\tevent->mmap2.start = addr;\n\tevent->mmap2.len   = usize ? ALIGN_8(csize) + usize : csize;\n\tevent->mmap2.pid   = pid;\n\tevent->mmap2.tid   = tid;\n\tevent->mmap2.ino   = st.st_ino;\n\tevent->mmap2.maj   = major(st.st_dev);\n\tevent->mmap2.min   = minor(st.st_dev);\n\tevent->mmap2.prot  = st.st_mode;\n\tevent->mmap2.flags = MAP_SHARED;\n\tevent->mmap2.ino_generation = 1;\n\n\tid = (void *)((unsigned long)event + event->mmap.header.size - idr_size);\n\tif (jd->sample_type & PERF_SAMPLE_TID) {\n\t\tid->pid  = pid;\n\t\tid->tid  = tid;\n\t}\n\tif (jd->sample_type & PERF_SAMPLE_TIME)\n\t\tid->time = convert_timestamp(jd, jr->load.p.timestamp);\n\n\t \n\tmemset(&sample, 0, sizeof(sample));\n\tsample.cpumode = PERF_RECORD_MISC_USER;\n\tsample.pid  = pid;\n\tsample.tid  = tid;\n\tsample.time = id->time;\n\tsample.ip   = addr;\n\n\tret = perf_event__process_mmap2(tool, event, &sample, jd->machine);\n\tif (ret)\n\t\tgoto out;\n\n\tret = jit_inject_event(jd, event);\n\t \n\tif (!ret)\n\t\tbuild_id__mark_dso_hit(tool, event, &sample, NULL, jd->machine);\n\nout:\n\tfree(event);\n\treturn ret;\n}\n\nstatic int jit_repipe_code_move(struct jit_buf_desc *jd, union jr_entry *jr)\n{\n\tstruct perf_sample sample;\n\tunion perf_event *event;\n\tstruct perf_tool *tool = jd->session->tool;\n\tchar *filename;\n\tsize_t size;\n\tstruct stat st;\n\tint usize;\n\tu16 idr_size;\n\tint ret;\n\tpid_t nspid, pid, tid;\n\tstruct {\n\t\tu32 pid, tid;\n\t\tu64 time;\n\t} *id;\n\n\tnspid = jr->load.pid;\n\tpid   = jr_entry_pid(jd, jr);\n\ttid   = jr_entry_tid(jd, jr);\n\tusize = jd->unwinding_mapped_size;\n\tidr_size = jd->machine->id_hdr_size;\n\n\t \n\tevent = calloc(1, sizeof(*event) + 16);\n\tif (!event)\n\t\treturn -1;\n\n\tfilename = event->mmap2.filename;\n\tsize = snprintf(filename, PATH_MAX, \"%s/jitted-%d-%\" PRIu64 \".so\",\n\t         jd->dir,\n\t\t nspid,\n\t\t jr->move.code_index);\n\n\tsize++;  \n\n\tif (nsinfo__stat(filename, &st, jd->nsi))\n\t\tmemset(&st, 0, sizeof(st));\n\n\tsize = PERF_ALIGN(size, sizeof(u64));\n\n\tevent->mmap2.header.type = PERF_RECORD_MMAP2;\n\tevent->mmap2.header.misc = PERF_RECORD_MISC_USER;\n\tevent->mmap2.header.size = (sizeof(event->mmap2) -\n\t\t\t(sizeof(event->mmap2.filename) - size) + idr_size);\n\tevent->mmap2.pgoff = GEN_ELF_TEXT_OFFSET;\n\tevent->mmap2.start = jr->move.new_code_addr;\n\tevent->mmap2.len   = usize ? ALIGN_8(jr->move.code_size) + usize\n\t\t\t\t   : jr->move.code_size;\n\tevent->mmap2.pid   = pid;\n\tevent->mmap2.tid   = tid;\n\tevent->mmap2.ino   = st.st_ino;\n\tevent->mmap2.maj   = major(st.st_dev);\n\tevent->mmap2.min   = minor(st.st_dev);\n\tevent->mmap2.prot  = st.st_mode;\n\tevent->mmap2.flags = MAP_SHARED;\n\tevent->mmap2.ino_generation = 1;\n\n\tid = (void *)((unsigned long)event + event->mmap.header.size - idr_size);\n\tif (jd->sample_type & PERF_SAMPLE_TID) {\n\t\tid->pid  = pid;\n\t\tid->tid  = tid;\n\t}\n\tif (jd->sample_type & PERF_SAMPLE_TIME)\n\t\tid->time = convert_timestamp(jd, jr->load.p.timestamp);\n\n\t \n\tmemset(&sample, 0, sizeof(sample));\n\tsample.cpumode = PERF_RECORD_MISC_USER;\n\tsample.pid  = pid;\n\tsample.tid  = tid;\n\tsample.time = id->time;\n\tsample.ip   = jr->move.new_code_addr;\n\n\tret = perf_event__process_mmap2(tool, event, &sample, jd->machine);\n\tif (ret)\n\t\treturn ret;\n\n\tret = jit_inject_event(jd, event);\n\tif (!ret)\n\t\tbuild_id__mark_dso_hit(tool, event, &sample, NULL, jd->machine);\n\n\treturn ret;\n}\n\nstatic int jit_repipe_debug_info(struct jit_buf_desc *jd, union jr_entry *jr)\n{\n\tvoid *data;\n\tsize_t sz;\n\n\tif (!(jd && jr))\n\t\treturn -1;\n\n\tsz  = jr->prefix.total_size - sizeof(jr->info);\n\tdata = malloc(sz);\n\tif (!data)\n\t\treturn -1;\n\n\tmemcpy(data, &jr->info.entries, sz);\n\n\tjd->debug_data       = data;\n\n\t \n\tjd->nr_debug_entries = jr->info.nr_entry;\n\n\treturn 0;\n}\n\nstatic int\njit_repipe_unwinding_info(struct jit_buf_desc *jd, union jr_entry *jr)\n{\n\tvoid *unwinding_data;\n\tuint32_t unwinding_data_size;\n\n\tif (!(jd && jr))\n\t\treturn -1;\n\n\tunwinding_data_size  = jr->prefix.total_size - sizeof(jr->unwinding);\n\tunwinding_data = malloc(unwinding_data_size);\n\tif (!unwinding_data)\n\t\treturn -1;\n\n\tmemcpy(unwinding_data, &jr->unwinding.unwinding_data,\n\t       unwinding_data_size);\n\n\tjd->eh_frame_hdr_size = jr->unwinding.eh_frame_hdr_size;\n\tjd->unwinding_size = jr->unwinding.unwinding_size;\n\tjd->unwinding_mapped_size = jr->unwinding.mapped_size;\n\tjd->unwinding_data = unwinding_data;\n\n\treturn 0;\n}\n\nstatic int\njit_process_dump(struct jit_buf_desc *jd)\n{\n\tunion jr_entry *jr;\n\tint ret = 0;\n\n\twhile ((jr = jit_get_next_entry(jd))) {\n\t\tswitch(jr->prefix.id) {\n\t\tcase JIT_CODE_LOAD:\n\t\t\tret = jit_repipe_code_load(jd, jr);\n\t\t\tbreak;\n\t\tcase JIT_CODE_MOVE:\n\t\t\tret = jit_repipe_code_move(jd, jr);\n\t\t\tbreak;\n\t\tcase JIT_CODE_DEBUG_INFO:\n\t\t\tret = jit_repipe_debug_info(jd, jr);\n\t\t\tbreak;\n\t\tcase JIT_CODE_UNWINDING_INFO:\n\t\t\tret = jit_repipe_unwinding_info(jd, jr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int\njit_inject(struct jit_buf_desc *jd, char *path)\n{\n\tint ret;\n\n\tif (verbose > 0)\n\t\tfprintf(stderr, \"injecting: %s\\n\", path);\n\n\tret = jit_open(jd, path);\n\tif (ret)\n\t\treturn -1;\n\n\tret = jit_process_dump(jd);\n\n\tjit_close(jd);\n\n\tif (verbose > 0)\n\t\tfprintf(stderr, \"injected: %s (%d)\\n\", path, ret);\n\n\treturn 0;\n}\n\n \nstatic int\njit_detect(char *mmap_name, pid_t pid, struct nsinfo *nsi)\n {\n\tchar *p;\n\tchar *end = NULL;\n\tpid_t pid2;\n\n\tif (verbose > 2)\n\t\tfprintf(stderr, \"jit marker trying : %s\\n\", mmap_name);\n\t \n\tp = strrchr(mmap_name, '/');\n\tif (!p)\n\t\treturn -1;\n\n\t \n\tif (strncmp(p, \"/jit-\", 5))\n\t\treturn -1;\n\n\t \n\tp += 5;\n\n\t \n\tif (!isdigit(*p))\n\t\treturn -1;\n\n\tpid2 = (int)strtol(p, &end, 10);\n\tif (!end)\n\t\treturn -1;\n\n\t \n\tif (pid && pid2 != nsinfo__nstgid(nsi))\n\t\treturn -1;\n\t \n\tif (strcmp(end, \".dump\"))\n\t\treturn -1;\n\n\tif (verbose > 0)\n\t\tfprintf(stderr, \"jit marker found: %s\\n\", mmap_name);\n\n\treturn 0;\n}\n\nstatic void jit_add_pid(struct machine *machine, pid_t pid)\n{\n\tstruct thread *thread = machine__findnew_thread(machine, pid, pid);\n\n\tif (!thread) {\n\t\tpr_err(\"%s: thread %d not found or created\\n\", __func__, pid);\n\t\treturn;\n\t}\n\n\tthread__set_priv(thread, (void *)true);\n\tthread__put(thread);\n}\n\nstatic bool jit_has_pid(struct machine *machine, pid_t pid)\n{\n\tstruct thread *thread = machine__find_thread(machine, pid, pid);\n\tvoid *priv;\n\n\tif (!thread)\n\t\treturn false;\n\n\tpriv = thread__priv(thread);\n\tthread__put(thread);\n\treturn (bool)priv;\n}\n\nint\njit_process(struct perf_session *session,\n\t    struct perf_data *output,\n\t    struct machine *machine,\n\t    char *filename,\n\t    pid_t pid,\n\t    pid_t tid,\n\t    u64 *nbytes)\n{\n\tstruct thread *thread;\n\tstruct nsinfo *nsi;\n\tstruct evsel *first;\n\tstruct jit_buf_desc jd;\n\tint ret;\n\n\tthread = machine__findnew_thread(machine, pid, tid);\n\tif (thread == NULL) {\n\t\tpr_err(\"problem processing JIT mmap event, skipping it.\\n\");\n\t\treturn 0;\n\t}\n\n\tnsi = nsinfo__get(thread__nsinfo(thread));\n\tthread__put(thread);\n\n\t \n\tif (jit_detect(filename, pid, nsi)) {\n\t\tnsinfo__put(nsi);\n\n\t\t \n\t\tif (jit_has_pid(machine, pid) &&\n\t\t\t((strncmp(filename, \"//anon\", 6) == 0) ||\n\t\t\t (strncmp(filename, \"[anon:\", 6) == 0) ||\n\t\t\t (strncmp(filename, \"/memfd:\", 7) == 0)))\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\tmemset(&jd, 0, sizeof(jd));\n\n\tjd.session = session;\n\tjd.output  = output;\n\tjd.machine = machine;\n\tjd.nsi = nsi;\n\n\t \n\tfirst = evlist__first(session->evlist);\n\tjd.sample_type = first->core.attr.sample_type;\n\n\t*nbytes = 0;\n\n\tret = jit_inject(&jd, filename);\n\tif (!ret) {\n\t\tjit_add_pid(machine, pid);\n\t\t*nbytes = jd.bytes_written;\n\t\tret = 1;\n\t}\n\n\tnsinfo__put(jd.nsi);\n\tfree(jd.buf);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}