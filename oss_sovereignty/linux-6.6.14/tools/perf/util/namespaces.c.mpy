{
  "module_name": "namespaces.c",
  "hash_id": "455ebd12f95a46f53e56b82fc62dc8db7c17e5d2d3ee28e76170e3f0989ed136",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/namespaces.c",
  "human_readable_source": "\n \n\n#include \"namespaces.h\"\n#include \"event.h\"\n#include \"get_current_dir_name.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <sched.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <asm/bug.h>\n#include <linux/kernel.h>\n#include <linux/zalloc.h>\n\nstatic const char *perf_ns__names[] = {\n\t[NET_NS_INDEX]\t\t= \"net\",\n\t[UTS_NS_INDEX]\t\t= \"uts\",\n\t[IPC_NS_INDEX]\t\t= \"ipc\",\n\t[PID_NS_INDEX]\t\t= \"pid\",\n\t[USER_NS_INDEX]\t\t= \"user\",\n\t[MNT_NS_INDEX]\t\t= \"mnt\",\n\t[CGROUP_NS_INDEX]\t= \"cgroup\",\n};\n\nconst char *perf_ns__name(unsigned int id)\n{\n\tif (id >= ARRAY_SIZE(perf_ns__names))\n\t\treturn \"UNKNOWN\";\n\treturn perf_ns__names[id];\n}\n\nstruct namespaces *namespaces__new(struct perf_record_namespaces *event)\n{\n\tstruct namespaces *namespaces;\n\tu64 link_info_size = ((event ? event->nr_namespaces : NR_NAMESPACES) *\n\t\t\t      sizeof(struct perf_ns_link_info));\n\n\tnamespaces = zalloc(sizeof(struct namespaces) + link_info_size);\n\tif (!namespaces)\n\t\treturn NULL;\n\n\tnamespaces->end_time = -1;\n\n\tif (event)\n\t\tmemcpy(namespaces->link_info, event->link_info, link_info_size);\n\n\treturn namespaces;\n}\n\nvoid namespaces__free(struct namespaces *namespaces)\n{\n\tfree(namespaces);\n}\n\nstatic int nsinfo__get_nspid(pid_t *tgid, pid_t *nstgid, bool *in_pidns, const char *path)\n{\n\tFILE *f = NULL;\n\tchar *statln = NULL;\n\tsize_t linesz = 0;\n\tchar *nspid;\n\n\tf = fopen(path, \"r\");\n\tif (f == NULL)\n\t\treturn -1;\n\n\twhile (getline(&statln, &linesz, f) != -1) {\n\t\t \n\t\tif (strstr(statln, \"Tgid:\") != NULL) {\n\t\t\t*tgid = (pid_t)strtol(strrchr(statln, '\\t'), NULL, 10);\n\t\t\t*nstgid = *tgid;\n\t\t}\n\n\t\tif (strstr(statln, \"NStgid:\") != NULL) {\n\t\t\tnspid = strrchr(statln, '\\t');\n\t\t\t*nstgid = (pid_t)strtol(nspid, NULL, 10);\n\t\t\t \n\t\t\t*in_pidns = (statln + sizeof(\"NStgid:\") - 1) != nspid;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tfree(statln);\n\treturn 0;\n}\n\nint nsinfo__init(struct nsinfo *nsi)\n{\n\tchar oldns[PATH_MAX];\n\tchar spath[PATH_MAX];\n\tchar *newns = NULL;\n\tstruct stat old_stat;\n\tstruct stat new_stat;\n\tint rv = -1;\n\n\tif (snprintf(oldns, PATH_MAX, \"/proc/self/ns/mnt\") >= PATH_MAX)\n\t\treturn rv;\n\n\tif (asprintf(&newns, \"/proc/%d/ns/mnt\", nsinfo__pid(nsi)) == -1)\n\t\treturn rv;\n\n\tif (stat(oldns, &old_stat) < 0)\n\t\tgoto out;\n\n\tif (stat(newns, &new_stat) < 0)\n\t\tgoto out;\n\n\t \n\tif (old_stat.st_ino != new_stat.st_ino) {\n\t\tRC_CHK_ACCESS(nsi)->need_setns = true;\n\t\tRC_CHK_ACCESS(nsi)->mntns_path = newns;\n\t\tnewns = NULL;\n\t}\n\n\t \n\tif (snprintf(spath, PATH_MAX, \"/proc/%d/status\", nsinfo__pid(nsi)) >= PATH_MAX)\n\t\tgoto out;\n\n\trv = nsinfo__get_nspid(&RC_CHK_ACCESS(nsi)->tgid, &RC_CHK_ACCESS(nsi)->nstgid,\n\t\t\t       &RC_CHK_ACCESS(nsi)->in_pidns, spath);\n\nout:\n\tfree(newns);\n\treturn rv;\n}\n\nstatic struct nsinfo *nsinfo__alloc(void)\n{\n\tstruct nsinfo *res;\n\tRC_STRUCT(nsinfo) *nsi;\n\n\tnsi = calloc(1, sizeof(*nsi));\n\tif (ADD_RC_CHK(res, nsi))\n\t\trefcount_set(&nsi->refcnt, 1);\n\n\treturn res;\n}\n\nstruct nsinfo *nsinfo__new(pid_t pid)\n{\n\tstruct nsinfo *nsi;\n\n\tif (pid == 0)\n\t\treturn NULL;\n\n\tnsi = nsinfo__alloc();\n\tif (!nsi)\n\t\treturn NULL;\n\n\tRC_CHK_ACCESS(nsi)->pid = pid;\n\tRC_CHK_ACCESS(nsi)->tgid = pid;\n\tRC_CHK_ACCESS(nsi)->nstgid = pid;\n\tnsinfo__clear_need_setns(nsi);\n\tRC_CHK_ACCESS(nsi)->in_pidns = false;\n\t \n\tif (nsinfo__init(nsi) == -1)\n\t\tnsinfo__clear_need_setns(nsi);\n\n\treturn nsi;\n}\n\nstatic const char *nsinfo__mntns_path(const struct nsinfo *nsi)\n{\n\treturn RC_CHK_ACCESS(nsi)->mntns_path;\n}\n\nstruct nsinfo *nsinfo__copy(const struct nsinfo *nsi)\n{\n\tstruct nsinfo *nnsi;\n\n\tif (nsi == NULL)\n\t\treturn NULL;\n\n\tnnsi = nsinfo__alloc();\n\tif (!nnsi)\n\t\treturn NULL;\n\n\tRC_CHK_ACCESS(nnsi)->pid = nsinfo__pid(nsi);\n\tRC_CHK_ACCESS(nnsi)->tgid = nsinfo__tgid(nsi);\n\tRC_CHK_ACCESS(nnsi)->nstgid = nsinfo__nstgid(nsi);\n\tRC_CHK_ACCESS(nnsi)->need_setns = nsinfo__need_setns(nsi);\n\tRC_CHK_ACCESS(nnsi)->in_pidns = nsinfo__in_pidns(nsi);\n\tif (nsinfo__mntns_path(nsi)) {\n\t\tRC_CHK_ACCESS(nnsi)->mntns_path = strdup(nsinfo__mntns_path(nsi));\n\t\tif (!RC_CHK_ACCESS(nnsi)->mntns_path) {\n\t\t\tnsinfo__put(nnsi);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn nnsi;\n}\n\nstatic refcount_t *nsinfo__refcnt(struct nsinfo *nsi)\n{\n\treturn &RC_CHK_ACCESS(nsi)->refcnt;\n}\n\nstatic void nsinfo__delete(struct nsinfo *nsi)\n{\n\tif (nsi) {\n\t\tWARN_ONCE(refcount_read(nsinfo__refcnt(nsi)) != 0, \"nsinfo refcnt unbalanced\\n\");\n\t\tzfree(&RC_CHK_ACCESS(nsi)->mntns_path);\n\t\tRC_CHK_FREE(nsi);\n\t}\n}\n\nstruct nsinfo *nsinfo__get(struct nsinfo *nsi)\n{\n\tstruct nsinfo *result;\n\n\tif (RC_CHK_GET(result, nsi))\n\t\trefcount_inc(nsinfo__refcnt(nsi));\n\n\treturn result;\n}\n\nvoid nsinfo__put(struct nsinfo *nsi)\n{\n\tif (nsi && refcount_dec_and_test(nsinfo__refcnt(nsi)))\n\t\tnsinfo__delete(nsi);\n\telse\n\t\tRC_CHK_PUT(nsi);\n}\n\nbool nsinfo__need_setns(const struct nsinfo *nsi)\n{\n\treturn RC_CHK_ACCESS(nsi)->need_setns;\n}\n\nvoid nsinfo__clear_need_setns(struct nsinfo *nsi)\n{\n\tRC_CHK_ACCESS(nsi)->need_setns = false;\n}\n\npid_t nsinfo__tgid(const struct nsinfo  *nsi)\n{\n\treturn RC_CHK_ACCESS(nsi)->tgid;\n}\n\npid_t nsinfo__nstgid(const struct nsinfo  *nsi)\n{\n\treturn RC_CHK_ACCESS(nsi)->nstgid;\n}\n\npid_t nsinfo__pid(const struct nsinfo  *nsi)\n{\n\treturn RC_CHK_ACCESS(nsi)->pid;\n}\n\npid_t nsinfo__in_pidns(const struct nsinfo  *nsi)\n{\n\treturn RC_CHK_ACCESS(nsi)->in_pidns;\n}\n\nvoid nsinfo__mountns_enter(struct nsinfo *nsi,\n\t\t\t\t  struct nscookie *nc)\n{\n\tchar curpath[PATH_MAX];\n\tint oldns = -1;\n\tint newns = -1;\n\tchar *oldcwd = NULL;\n\n\tif (nc == NULL)\n\t\treturn;\n\n\tnc->oldns = -1;\n\tnc->newns = -1;\n\n\tif (!nsi || !nsinfo__need_setns(nsi))\n\t\treturn;\n\n\tif (snprintf(curpath, PATH_MAX, \"/proc/self/ns/mnt\") >= PATH_MAX)\n\t\treturn;\n\n\toldcwd = get_current_dir_name();\n\tif (!oldcwd)\n\t\treturn;\n\n\toldns = open(curpath, O_RDONLY);\n\tif (oldns < 0)\n\t\tgoto errout;\n\n\tnewns = open(nsinfo__mntns_path(nsi), O_RDONLY);\n\tif (newns < 0)\n\t\tgoto errout;\n\n\tif (setns(newns, CLONE_NEWNS) < 0)\n\t\tgoto errout;\n\n\tnc->oldcwd = oldcwd;\n\tnc->oldns = oldns;\n\tnc->newns = newns;\n\treturn;\n\nerrout:\n\tfree(oldcwd);\n\tif (oldns > -1)\n\t\tclose(oldns);\n\tif (newns > -1)\n\t\tclose(newns);\n}\n\nvoid nsinfo__mountns_exit(struct nscookie *nc)\n{\n\tif (nc == NULL || nc->oldns == -1 || nc->newns == -1 || !nc->oldcwd)\n\t\treturn;\n\n\tsetns(nc->oldns, CLONE_NEWNS);\n\n\tif (nc->oldcwd) {\n\t\tWARN_ON_ONCE(chdir(nc->oldcwd));\n\t\tzfree(&nc->oldcwd);\n\t}\n\n\tif (nc->oldns > -1) {\n\t\tclose(nc->oldns);\n\t\tnc->oldns = -1;\n\t}\n\n\tif (nc->newns > -1) {\n\t\tclose(nc->newns);\n\t\tnc->newns = -1;\n\t}\n}\n\nchar *nsinfo__realpath(const char *path, struct nsinfo *nsi)\n{\n\tchar *rpath;\n\tstruct nscookie nsc;\n\n\tnsinfo__mountns_enter(nsi, &nsc);\n\trpath = realpath(path, NULL);\n\tnsinfo__mountns_exit(&nsc);\n\n\treturn rpath;\n}\n\nint nsinfo__stat(const char *filename, struct stat *st, struct nsinfo *nsi)\n{\n\tint ret;\n\tstruct nscookie nsc;\n\n\tnsinfo__mountns_enter(nsi, &nsc);\n\tret = stat(filename, st);\n\tnsinfo__mountns_exit(&nsc);\n\n\treturn ret;\n}\n\nbool nsinfo__is_in_root_namespace(void)\n{\n\tpid_t tgid = 0, nstgid = 0;\n\tbool in_pidns = false;\n\n\tnsinfo__get_nspid(&tgid, &nstgid, &in_pidns, \"/proc/self/status\");\n\treturn !in_pidns;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}