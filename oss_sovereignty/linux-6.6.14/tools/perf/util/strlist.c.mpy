{
  "module_name": "strlist.c",
  "hash_id": "80ee564c979583d9a50cbd4ab22f0c9bf5ebd0904473146f3c70e73fb0522c99",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/strlist.c",
  "human_readable_source": "\n \n\n#include \"strlist.h\"\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <linux/zalloc.h>\n\nstatic\nstruct rb_node *strlist__node_new(struct rblist *rblist, const void *entry)\n{\n\tconst char *s = entry;\n\tstruct rb_node *rc = NULL;\n\tstruct strlist *strlist = container_of(rblist, struct strlist, rblist);\n\tstruct str_node *snode = malloc(sizeof(*snode));\n\n\tif (snode != NULL) {\n\t\tif (strlist->dupstr) {\n\t\t\ts = strdup(s);\n\t\t\tif (s == NULL)\n\t\t\t\tgoto out_delete;\n\t\t}\n\t\tsnode->s = s;\n\t\trc = &snode->rb_node;\n\t}\n\n\treturn rc;\n\nout_delete:\n\tfree(snode);\n\treturn NULL;\n}\n\nstatic void str_node__delete(struct str_node *snode, bool dupstr)\n{\n\tif (dupstr)\n\t\tzfree((char **)&snode->s);\n\tfree(snode);\n}\n\nstatic\nvoid strlist__node_delete(struct rblist *rblist, struct rb_node *rb_node)\n{\n\tstruct strlist *slist = container_of(rblist, struct strlist, rblist);\n\tstruct str_node *snode = container_of(rb_node, struct str_node, rb_node);\n\n\tstr_node__delete(snode, slist->dupstr);\n}\n\nstatic int strlist__node_cmp(struct rb_node *rb_node, const void *entry)\n{\n\tconst char *str = entry;\n\tstruct str_node *snode = container_of(rb_node, struct str_node, rb_node);\n\n\treturn strcmp(snode->s, str);\n}\n\nint strlist__add(struct strlist *slist, const char *new_entry)\n{\n\treturn rblist__add_node(&slist->rblist, new_entry);\n}\n\nint strlist__load(struct strlist *slist, const char *filename)\n{\n\tchar entry[1024];\n\tint err;\n\tFILE *fp = fopen(filename, \"r\");\n\n\tif (fp == NULL)\n\t\treturn -errno;\n\n\twhile (fgets(entry, sizeof(entry), fp) != NULL) {\n\t\tconst size_t len = strlen(entry);\n\n\t\tif (len == 0)\n\t\t\tcontinue;\n\t\tentry[len - 1] = '\\0';\n\n\t\terr = strlist__add(slist, entry);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\tfclose(fp);\n\treturn err;\n}\n\nvoid strlist__remove(struct strlist *slist, struct str_node *snode)\n{\n\trblist__remove_node(&slist->rblist, &snode->rb_node);\n}\n\nstruct str_node *strlist__find(struct strlist *slist, const char *entry)\n{\n\tstruct str_node *snode = NULL;\n\tstruct rb_node *rb_node = rblist__find(&slist->rblist, entry);\n\n\tif (rb_node)\n\t\tsnode = container_of(rb_node, struct str_node, rb_node);\n\n\treturn snode;\n}\n\nstatic int strlist__parse_list_entry(struct strlist *slist, const char *s,\n\t\t\t\t     const char *subst_dir)\n{\n\tint err;\n\tchar *subst = NULL;\n\n\tif (strncmp(s, \"file://\", 7) == 0)\n\t\treturn strlist__load(slist, s + 7);\n\n\tif (subst_dir) {\n\t\terr = -ENOMEM;\n\t\tif (asprintf(&subst, \"%s/%s\", subst_dir, s) < 0)\n\t\t\tgoto out;\n\n\t\tif (access(subst, F_OK) == 0) {\n\t\t\terr = strlist__load(slist, subst);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (slist->file_only) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = strlist__add(slist, s);\nout:\n\tfree(subst);\n\treturn err;\n}\n\nstatic int strlist__parse_list(struct strlist *slist, const char *s, const char *subst_dir)\n{\n\tchar *sep;\n\tint err;\n\n\twhile ((sep = strchr(s, ',')) != NULL) {\n\t\t*sep = '\\0';\n\t\terr = strlist__parse_list_entry(slist, s, subst_dir);\n\t\t*sep = ',';\n\t\tif (err != 0)\n\t\t\treturn err;\n\t\ts = sep + 1;\n\t}\n\n\treturn *s ? strlist__parse_list_entry(slist, s, subst_dir) : 0;\n}\n\nstruct strlist *strlist__new(const char *list, const struct strlist_config *config)\n{\n\tstruct strlist *slist = malloc(sizeof(*slist));\n\n\tif (slist != NULL) {\n\t\tbool dupstr = true;\n\t\tbool file_only = false;\n\t\tconst char *dirname = NULL;\n\n\t\tif (config) {\n\t\t\tdupstr = !config->dont_dupstr;\n\t\t\tdirname = config->dirname;\n\t\t\tfile_only = config->file_only;\n\t\t}\n\n\t\trblist__init(&slist->rblist);\n\t\tslist->rblist.node_cmp    = strlist__node_cmp;\n\t\tslist->rblist.node_new    = strlist__node_new;\n\t\tslist->rblist.node_delete = strlist__node_delete;\n\n\t\tslist->dupstr\t = dupstr;\n\t\tslist->file_only = file_only;\n\n\t\tif (list && strlist__parse_list(slist, list, dirname) != 0)\n\t\t\tgoto out_error;\n\t}\n\n\treturn slist;\nout_error:\n\tfree(slist);\n\treturn NULL;\n}\n\nvoid strlist__delete(struct strlist *slist)\n{\n\tif (slist != NULL)\n\t\trblist__delete(&slist->rblist);\n}\n\nstruct str_node *strlist__entry(const struct strlist *slist, unsigned int idx)\n{\n\tstruct str_node *snode = NULL;\n\tstruct rb_node *rb_node;\n\n\trb_node = rblist__entry(&slist->rblist, idx);\n\tif (rb_node)\n\t\tsnode = container_of(rb_node, struct str_node, rb_node);\n\n\treturn snode;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}