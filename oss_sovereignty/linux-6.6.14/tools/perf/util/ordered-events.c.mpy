{
  "module_name": "ordered-events.c",
  "hash_id": "f06159ba2da17281e1e9da0d8d2f75426f41cb569f39be095ebd270be6e17cbe",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/ordered-events.c",
  "human_readable_source": "\n#include <errno.h>\n#include <inttypes.h>\n#include <linux/list.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include \"ordered-events.h\"\n#include \"session.h\"\n#include \"asm/bug.h\"\n#include \"debug.h\"\n#include \"ui/progress.h\"\n\n#define pr_N(n, fmt, ...) \\\n\teprintf(n, debug_ordered_events, fmt, ##__VA_ARGS__)\n\n#define pr(fmt, ...) pr_N(1, pr_fmt(fmt), ##__VA_ARGS__)\n\nstatic void queue_event(struct ordered_events *oe, struct ordered_event *new)\n{\n\tstruct ordered_event *last = oe->last;\n\tu64 timestamp = new->timestamp;\n\tstruct list_head *p;\n\n\t++oe->nr_events;\n\toe->last = new;\n\n\tpr_oe_time2(timestamp, \"queue_event nr_events %u\\n\", oe->nr_events);\n\n\tif (!last) {\n\t\tlist_add(&new->list, &oe->events);\n\t\toe->max_timestamp = timestamp;\n\t\treturn;\n\t}\n\n\t \n\tif (last->timestamp <= timestamp) {\n\t\twhile (last->timestamp <= timestamp) {\n\t\t\tp = last->list.next;\n\t\t\tif (p == &oe->events) {\n\t\t\t\tlist_add_tail(&new->list, &oe->events);\n\t\t\t\toe->max_timestamp = timestamp;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlast = list_entry(p, struct ordered_event, list);\n\t\t}\n\t\tlist_add_tail(&new->list, &last->list);\n\t} else {\n\t\twhile (last->timestamp > timestamp) {\n\t\t\tp = last->list.prev;\n\t\t\tif (p == &oe->events) {\n\t\t\t\tlist_add(&new->list, &oe->events);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlast = list_entry(p, struct ordered_event, list);\n\t\t}\n\t\tlist_add(&new->list, &last->list);\n\t}\n}\n\nstatic union perf_event *__dup_event(struct ordered_events *oe,\n\t\t\t\t     union perf_event *event)\n{\n\tunion perf_event *new_event = NULL;\n\n\tif (oe->cur_alloc_size < oe->max_alloc_size) {\n\t\tnew_event = memdup(event, event->header.size);\n\t\tif (new_event)\n\t\t\toe->cur_alloc_size += event->header.size;\n\t}\n\n\treturn new_event;\n}\n\nstatic union perf_event *dup_event(struct ordered_events *oe,\n\t\t\t\t   union perf_event *event)\n{\n\treturn oe->copy_on_queue ? __dup_event(oe, event) : event;\n}\n\nstatic void __free_dup_event(struct ordered_events *oe, union perf_event *event)\n{\n\tif (event) {\n\t\toe->cur_alloc_size -= event->header.size;\n\t\tfree(event);\n\t}\n}\n\nstatic void free_dup_event(struct ordered_events *oe, union perf_event *event)\n{\n\tif (oe->copy_on_queue)\n\t\t__free_dup_event(oe, event);\n}\n\n#define MAX_SAMPLE_BUFFER\t(64 * 1024 / sizeof(struct ordered_event))\nstatic struct ordered_event *alloc_event(struct ordered_events *oe,\n\t\t\t\t\t union perf_event *event)\n{\n\tstruct list_head *cache = &oe->cache;\n\tstruct ordered_event *new = NULL;\n\tunion perf_event *new_event;\n\tsize_t size;\n\n\tnew_event = dup_event(oe, event);\n\tif (!new_event)\n\t\treturn NULL;\n\n\t \n\tsize = sizeof(*oe->buffer) + MAX_SAMPLE_BUFFER * sizeof(*new);\n\n\tif (!list_empty(cache)) {\n\t\tnew = list_entry(cache->next, struct ordered_event, list);\n\t\tlist_del_init(&new->list);\n\t} else if (oe->buffer) {\n\t\tnew = &oe->buffer->event[oe->buffer_idx];\n\t\tif (++oe->buffer_idx == MAX_SAMPLE_BUFFER)\n\t\t\toe->buffer = NULL;\n\t} else if ((oe->cur_alloc_size + size) < oe->max_alloc_size) {\n\t\toe->buffer = malloc(size);\n\t\tif (!oe->buffer) {\n\t\t\tfree_dup_event(oe, new_event);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tpr(\"alloc size %\" PRIu64 \"B (+%zu), max %\" PRIu64 \"B\\n\",\n\t\t   oe->cur_alloc_size, size, oe->max_alloc_size);\n\n\t\toe->cur_alloc_size += size;\n\t\tlist_add(&oe->buffer->list, &oe->to_free);\n\n\t\toe->buffer_idx = 1;\n\t\tnew = &oe->buffer->event[0];\n\t} else {\n\t\tpr(\"allocation limit reached %\" PRIu64 \"B\\n\", oe->max_alloc_size);\n\t\treturn NULL;\n\t}\n\n\tnew->event = new_event;\n\treturn new;\n}\n\nstatic struct ordered_event *\nordered_events__new_event(struct ordered_events *oe, u64 timestamp,\n\t\t    union perf_event *event)\n{\n\tstruct ordered_event *new;\n\n\tnew = alloc_event(oe, event);\n\tif (new) {\n\t\tnew->timestamp = timestamp;\n\t\tqueue_event(oe, new);\n\t}\n\n\treturn new;\n}\n\nvoid ordered_events__delete(struct ordered_events *oe, struct ordered_event *event)\n{\n\tlist_move(&event->list, &oe->cache);\n\toe->nr_events--;\n\tfree_dup_event(oe, event->event);\n\tevent->event = NULL;\n}\n\nint ordered_events__queue(struct ordered_events *oe, union perf_event *event,\n\t\t\t  u64 timestamp, u64 file_offset, const char *file_path)\n{\n\tstruct ordered_event *oevent;\n\n\tif (!timestamp || timestamp == ~0ULL)\n\t\treturn -ETIME;\n\n\tif (timestamp < oe->last_flush) {\n\t\tpr_oe_time(timestamp,      \"out of order event\\n\");\n\t\tpr_oe_time(oe->last_flush, \"last flush, last_flush_type %d\\n\",\n\t\t\t   oe->last_flush_type);\n\n\t\toe->nr_unordered_events++;\n\t}\n\n\toevent = ordered_events__new_event(oe, timestamp, event);\n\tif (!oevent) {\n\t\tordered_events__flush(oe, OE_FLUSH__HALF);\n\t\toevent = ordered_events__new_event(oe, timestamp, event);\n\t}\n\n\tif (!oevent)\n\t\treturn -ENOMEM;\n\n\toevent->file_offset = file_offset;\n\toevent->file_path = file_path;\n\treturn 0;\n}\n\nstatic int do_flush(struct ordered_events *oe, bool show_progress)\n{\n\tstruct list_head *head = &oe->events;\n\tstruct ordered_event *tmp, *iter;\n\tu64 limit = oe->next_flush;\n\tu64 last_ts = oe->last ? oe->last->timestamp : 0ULL;\n\tstruct ui_progress prog;\n\tint ret;\n\n\tif (!limit)\n\t\treturn 0;\n\n\tif (show_progress)\n\t\tui_progress__init(&prog, oe->nr_events, \"Processing time ordered events...\");\n\n\tlist_for_each_entry_safe(iter, tmp, head, list) {\n\t\tif (session_done())\n\t\t\treturn 0;\n\n\t\tif (iter->timestamp > limit)\n\t\t\tbreak;\n\t\tret = oe->deliver(oe, iter);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tordered_events__delete(oe, iter);\n\t\toe->last_flush = iter->timestamp;\n\n\t\tif (show_progress)\n\t\t\tui_progress__update(&prog, 1);\n\t}\n\n\tif (list_empty(head))\n\t\toe->last = NULL;\n\telse if (last_ts <= limit)\n\t\toe->last = list_entry(head->prev, struct ordered_event, list);\n\n\tif (show_progress)\n\t\tui_progress__finish();\n\n\treturn 0;\n}\n\nstatic int __ordered_events__flush(struct ordered_events *oe, enum oe_flush how,\n\t\t\t\t   u64 timestamp)\n{\n\tstatic const char * const str[] = {\n\t\t\"NONE\",\n\t\t\"FINAL\",\n\t\t\"ROUND\",\n\t\t\"HALF \",\n\t\t\"TOP  \",\n\t\t\"TIME \",\n\t};\n\tint err;\n\tbool show_progress = false;\n\n\tif (oe->nr_events == 0)\n\t\treturn 0;\n\n\tswitch (how) {\n\tcase OE_FLUSH__FINAL:\n\t\tshow_progress = true;\n\t\tfallthrough;\n\tcase OE_FLUSH__TOP:\n\t\toe->next_flush = ULLONG_MAX;\n\t\tbreak;\n\n\tcase OE_FLUSH__HALF:\n\t{\n\t\tstruct ordered_event *first, *last;\n\t\tstruct list_head *head = &oe->events;\n\n\t\tfirst = list_entry(head->next, struct ordered_event, list);\n\t\tlast = oe->last;\n\n\t\t \n\t\tif (WARN_ONCE(!last || list_empty(head), \"empty queue\"))\n\t\t\treturn 0;\n\n\t\toe->next_flush  = first->timestamp;\n\t\toe->next_flush += (last->timestamp - first->timestamp) / 2;\n\t\tbreak;\n\t}\n\n\tcase OE_FLUSH__TIME:\n\t\toe->next_flush = timestamp;\n\t\tshow_progress = false;\n\t\tbreak;\n\n\tcase OE_FLUSH__ROUND:\n\tcase OE_FLUSH__NONE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpr_oe_time(oe->next_flush, \"next_flush - ordered_events__flush PRE  %s, nr_events %u\\n\",\n\t\t   str[how], oe->nr_events);\n\tpr_oe_time(oe->max_timestamp, \"max_timestamp\\n\");\n\n\terr = do_flush(oe, show_progress);\n\n\tif (!err) {\n\t\tif (how == OE_FLUSH__ROUND)\n\t\t\toe->next_flush = oe->max_timestamp;\n\n\t\toe->last_flush_type = how;\n\t}\n\n\tpr_oe_time(oe->next_flush, \"next_flush - ordered_events__flush POST %s, nr_events %u\\n\",\n\t\t   str[how], oe->nr_events);\n\tpr_oe_time(oe->last_flush, \"last_flush\\n\");\n\n\treturn err;\n}\n\nint ordered_events__flush(struct ordered_events *oe, enum oe_flush how)\n{\n\treturn __ordered_events__flush(oe, how, 0);\n}\n\nint ordered_events__flush_time(struct ordered_events *oe, u64 timestamp)\n{\n\treturn __ordered_events__flush(oe, OE_FLUSH__TIME, timestamp);\n}\n\nu64 ordered_events__first_time(struct ordered_events *oe)\n{\n\tstruct ordered_event *event;\n\n\tif (list_empty(&oe->events))\n\t\treturn 0;\n\n\tevent = list_first_entry(&oe->events, struct ordered_event, list);\n\treturn event->timestamp;\n}\n\nvoid ordered_events__init(struct ordered_events *oe, ordered_events__deliver_t deliver,\n\t\t\t  void *data)\n{\n\tINIT_LIST_HEAD(&oe->events);\n\tINIT_LIST_HEAD(&oe->cache);\n\tINIT_LIST_HEAD(&oe->to_free);\n\toe->max_alloc_size = (u64) -1;\n\toe->cur_alloc_size = 0;\n\toe->deliver\t   = deliver;\n\toe->data\t   = data;\n}\n\nstatic void\nordered_events_buffer__free(struct ordered_events_buffer *buffer,\n\t\t\t    unsigned int max, struct ordered_events *oe)\n{\n\tif (oe->copy_on_queue) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < max; i++)\n\t\t\t__free_dup_event(oe, buffer->event[i].event);\n\t}\n\n\tfree(buffer);\n}\n\nvoid ordered_events__free(struct ordered_events *oe)\n{\n\tstruct ordered_events_buffer *buffer, *tmp;\n\n\tif (list_empty(&oe->to_free))\n\t\treturn;\n\n\t \n\tif (oe->buffer) {\n\t\tlist_del_init(&oe->buffer->list);\n\t\tordered_events_buffer__free(oe->buffer, oe->buffer_idx, oe);\n\t}\n\n\t \n\tlist_for_each_entry_safe(buffer, tmp, &oe->to_free, list) {\n\t\tlist_del_init(&buffer->list);\n\t\tordered_events_buffer__free(buffer, MAX_SAMPLE_BUFFER, oe);\n\t}\n}\n\nvoid ordered_events__reinit(struct ordered_events *oe)\n{\n\tordered_events__deliver_t old_deliver = oe->deliver;\n\n\tordered_events__free(oe);\n\tmemset(oe, '\\0', sizeof(*oe));\n\tordered_events__init(oe, old_deliver, oe->data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}