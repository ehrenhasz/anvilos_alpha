{
  "module_name": "event.c",
  "hash_id": "c9d62783b892f1bc8adf639bffd87d214ec3b41152d6261726cf33c9c266be45",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/event.c",
  "human_readable_source": "#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <perf/cpumap.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <uapi/linux/mman.h>  \n#include <linux/perf_event.h>\n#include <linux/zalloc.h>\n#include \"cpumap.h\"\n#include \"dso.h\"\n#include \"event.h\"\n#include \"debug.h\"\n#include \"hist.h\"\n#include \"machine.h\"\n#include \"sort.h\"\n#include \"string2.h\"\n#include \"strlist.h\"\n#include \"thread.h\"\n#include \"thread_map.h\"\n#include \"time-utils.h\"\n#include <linux/ctype.h>\n#include \"map.h\"\n#include \"util/namespaces.h\"\n#include \"symbol.h\"\n#include \"symbol/kallsyms.h\"\n#include \"asm/bug.h\"\n#include \"stat.h\"\n#include \"session.h\"\n#include \"bpf-event.h\"\n#include \"print_binary.h\"\n#include \"tool.h\"\n#include \"util.h\"\n\nstatic const char *perf_event__names[] = {\n\t[0]\t\t\t\t\t= \"TOTAL\",\n\t[PERF_RECORD_MMAP]\t\t\t= \"MMAP\",\n\t[PERF_RECORD_MMAP2]\t\t\t= \"MMAP2\",\n\t[PERF_RECORD_LOST]\t\t\t= \"LOST\",\n\t[PERF_RECORD_COMM]\t\t\t= \"COMM\",\n\t[PERF_RECORD_EXIT]\t\t\t= \"EXIT\",\n\t[PERF_RECORD_THROTTLE]\t\t\t= \"THROTTLE\",\n\t[PERF_RECORD_UNTHROTTLE]\t\t= \"UNTHROTTLE\",\n\t[PERF_RECORD_FORK]\t\t\t= \"FORK\",\n\t[PERF_RECORD_READ]\t\t\t= \"READ\",\n\t[PERF_RECORD_SAMPLE]\t\t\t= \"SAMPLE\",\n\t[PERF_RECORD_AUX]\t\t\t= \"AUX\",\n\t[PERF_RECORD_ITRACE_START]\t\t= \"ITRACE_START\",\n\t[PERF_RECORD_LOST_SAMPLES]\t\t= \"LOST_SAMPLES\",\n\t[PERF_RECORD_SWITCH]\t\t\t= \"SWITCH\",\n\t[PERF_RECORD_SWITCH_CPU_WIDE]\t\t= \"SWITCH_CPU_WIDE\",\n\t[PERF_RECORD_NAMESPACES]\t\t= \"NAMESPACES\",\n\t[PERF_RECORD_KSYMBOL]\t\t\t= \"KSYMBOL\",\n\t[PERF_RECORD_BPF_EVENT]\t\t\t= \"BPF_EVENT\",\n\t[PERF_RECORD_CGROUP]\t\t\t= \"CGROUP\",\n\t[PERF_RECORD_TEXT_POKE]\t\t\t= \"TEXT_POKE\",\n\t[PERF_RECORD_AUX_OUTPUT_HW_ID]\t\t= \"AUX_OUTPUT_HW_ID\",\n\t[PERF_RECORD_HEADER_ATTR]\t\t= \"ATTR\",\n\t[PERF_RECORD_HEADER_EVENT_TYPE]\t\t= \"EVENT_TYPE\",\n\t[PERF_RECORD_HEADER_TRACING_DATA]\t= \"TRACING_DATA\",\n\t[PERF_RECORD_HEADER_BUILD_ID]\t\t= \"BUILD_ID\",\n\t[PERF_RECORD_FINISHED_ROUND]\t\t= \"FINISHED_ROUND\",\n\t[PERF_RECORD_ID_INDEX]\t\t\t= \"ID_INDEX\",\n\t[PERF_RECORD_AUXTRACE_INFO]\t\t= \"AUXTRACE_INFO\",\n\t[PERF_RECORD_AUXTRACE]\t\t\t= \"AUXTRACE\",\n\t[PERF_RECORD_AUXTRACE_ERROR]\t\t= \"AUXTRACE_ERROR\",\n\t[PERF_RECORD_THREAD_MAP]\t\t= \"THREAD_MAP\",\n\t[PERF_RECORD_CPU_MAP]\t\t\t= \"CPU_MAP\",\n\t[PERF_RECORD_STAT_CONFIG]\t\t= \"STAT_CONFIG\",\n\t[PERF_RECORD_STAT]\t\t\t= \"STAT\",\n\t[PERF_RECORD_STAT_ROUND]\t\t= \"STAT_ROUND\",\n\t[PERF_RECORD_EVENT_UPDATE]\t\t= \"EVENT_UPDATE\",\n\t[PERF_RECORD_TIME_CONV]\t\t\t= \"TIME_CONV\",\n\t[PERF_RECORD_HEADER_FEATURE]\t\t= \"FEATURE\",\n\t[PERF_RECORD_COMPRESSED]\t\t= \"COMPRESSED\",\n\t[PERF_RECORD_FINISHED_INIT]\t\t= \"FINISHED_INIT\",\n};\n\nconst char *perf_event__name(unsigned int id)\n{\n\tif (id >= ARRAY_SIZE(perf_event__names))\n\t\treturn \"INVALID\";\n\tif (!perf_event__names[id])\n\t\treturn \"UNKNOWN\";\n\treturn perf_event__names[id];\n}\n\nstruct process_symbol_args {\n\tconst char *name;\n\tu64\t   start;\n};\n\nstatic int find_func_symbol_cb(void *arg, const char *name, char type,\n\t\t\t       u64 start)\n{\n\tstruct process_symbol_args *args = arg;\n\n\t \n\tif (!(kallsyms__is_function(type) ||\n\t      type == 'A') || strcmp(name, args->name))\n\t\treturn 0;\n\n\targs->start = start;\n\treturn 1;\n}\n\nstatic int find_any_symbol_cb(void *arg, const char *name,\n\t\t\t      char type __maybe_unused, u64 start)\n{\n\tstruct process_symbol_args *args = arg;\n\n\tif (strcmp(name, args->name))\n\t\treturn 0;\n\n\targs->start = start;\n\treturn 1;\n}\n\nint kallsyms__get_function_start(const char *kallsyms_filename,\n\t\t\t\t const char *symbol_name, u64 *addr)\n{\n\tstruct process_symbol_args args = { .name = symbol_name, };\n\n\tif (kallsyms__parse(kallsyms_filename, &args, find_func_symbol_cb) <= 0)\n\t\treturn -1;\n\n\t*addr = args.start;\n\treturn 0;\n}\n\nint kallsyms__get_symbol_start(const char *kallsyms_filename,\n\t\t\t       const char *symbol_name, u64 *addr)\n{\n\tstruct process_symbol_args args = { .name = symbol_name, };\n\n\tif (kallsyms__parse(kallsyms_filename, &args, find_any_symbol_cb) <= 0)\n\t\treturn -1;\n\n\t*addr = args.start;\n\treturn 0;\n}\n\nvoid perf_event__read_stat_config(struct perf_stat_config *config,\n\t\t\t\t  struct perf_record_stat_config *event)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < event->nr; i++) {\n\n\t\tswitch (event->data[i].tag) {\n#define CASE(__term, __val)\t\t\t\t\t\\\n\t\tcase PERF_STAT_CONFIG_TERM__##__term:\t\t\\\n\t\t\tconfig->__val = event->data[i].val;\t\\\n\t\t\tbreak;\n\n\t\tCASE(AGGR_MODE,  aggr_mode)\n\t\tCASE(SCALE,      scale)\n\t\tCASE(INTERVAL,   interval)\n\t\tCASE(AGGR_LEVEL, aggr_level)\n#undef CASE\n\t\tdefault:\n\t\t\tpr_warning(\"unknown stat config term %\" PRI_lu64 \"\\n\",\n\t\t\t\t   event->data[i].tag);\n\t\t}\n\t}\n}\n\nsize_t perf_event__fprintf_comm(union perf_event *event, FILE *fp)\n{\n\tconst char *s;\n\n\tif (event->header.misc & PERF_RECORD_MISC_COMM_EXEC)\n\t\ts = \" exec\";\n\telse\n\t\ts = \"\";\n\n\treturn fprintf(fp, \"%s: %s:%d/%d\\n\", s, event->comm.comm, event->comm.pid, event->comm.tid);\n}\n\nsize_t perf_event__fprintf_namespaces(union perf_event *event, FILE *fp)\n{\n\tsize_t ret = 0;\n\tstruct perf_ns_link_info *ns_link_info;\n\tu32 nr_namespaces, idx;\n\n\tns_link_info = event->namespaces.link_info;\n\tnr_namespaces = event->namespaces.nr_namespaces;\n\n\tret += fprintf(fp, \" %d/%d - nr_namespaces: %u\\n\\t\\t[\",\n\t\t       event->namespaces.pid,\n\t\t       event->namespaces.tid,\n\t\t       nr_namespaces);\n\n\tfor (idx = 0; idx < nr_namespaces; idx++) {\n\t\tif (idx && (idx % 4 == 0))\n\t\t\tret += fprintf(fp, \"\\n\\t\\t \");\n\n\t\tret  += fprintf(fp, \"%u/%s: %\" PRIu64 \"/%#\" PRIx64 \"%s\", idx,\n\t\t\t\tperf_ns__name(idx), (u64)ns_link_info[idx].dev,\n\t\t\t\t(u64)ns_link_info[idx].ino,\n\t\t\t\t((idx + 1) != nr_namespaces) ? \", \" : \"]\\n\");\n\t}\n\n\treturn ret;\n}\n\nsize_t perf_event__fprintf_cgroup(union perf_event *event, FILE *fp)\n{\n\treturn fprintf(fp, \" cgroup: %\" PRI_lu64 \" %s\\n\",\n\t\t       event->cgroup.id, event->cgroup.path);\n}\n\nint perf_event__process_comm(struct perf_tool *tool __maybe_unused,\n\t\t\t     union perf_event *event,\n\t\t\t     struct perf_sample *sample,\n\t\t\t     struct machine *machine)\n{\n\treturn machine__process_comm_event(machine, event, sample);\n}\n\nint perf_event__process_namespaces(struct perf_tool *tool __maybe_unused,\n\t\t\t\t   union perf_event *event,\n\t\t\t\t   struct perf_sample *sample,\n\t\t\t\t   struct machine *machine)\n{\n\treturn machine__process_namespaces_event(machine, event, sample);\n}\n\nint perf_event__process_cgroup(struct perf_tool *tool __maybe_unused,\n\t\t\t       union perf_event *event,\n\t\t\t       struct perf_sample *sample,\n\t\t\t       struct machine *machine)\n{\n\treturn machine__process_cgroup_event(machine, event, sample);\n}\n\nint perf_event__process_lost(struct perf_tool *tool __maybe_unused,\n\t\t\t     union perf_event *event,\n\t\t\t     struct perf_sample *sample,\n\t\t\t     struct machine *machine)\n{\n\treturn machine__process_lost_event(machine, event, sample);\n}\n\nint perf_event__process_aux(struct perf_tool *tool __maybe_unused,\n\t\t\t    union perf_event *event,\n\t\t\t    struct perf_sample *sample __maybe_unused,\n\t\t\t    struct machine *machine)\n{\n\treturn machine__process_aux_event(machine, event);\n}\n\nint perf_event__process_itrace_start(struct perf_tool *tool __maybe_unused,\n\t\t\t\t     union perf_event *event,\n\t\t\t\t     struct perf_sample *sample __maybe_unused,\n\t\t\t\t     struct machine *machine)\n{\n\treturn machine__process_itrace_start_event(machine, event);\n}\n\nint perf_event__process_aux_output_hw_id(struct perf_tool *tool __maybe_unused,\n\t\t\t\t\t union perf_event *event,\n\t\t\t\t\t struct perf_sample *sample __maybe_unused,\n\t\t\t\t\t struct machine *machine)\n{\n\treturn machine__process_aux_output_hw_id_event(machine, event);\n}\n\nint perf_event__process_lost_samples(struct perf_tool *tool __maybe_unused,\n\t\t\t\t     union perf_event *event,\n\t\t\t\t     struct perf_sample *sample,\n\t\t\t\t     struct machine *machine)\n{\n\treturn machine__process_lost_samples_event(machine, event, sample);\n}\n\nint perf_event__process_switch(struct perf_tool *tool __maybe_unused,\n\t\t\t       union perf_event *event,\n\t\t\t       struct perf_sample *sample __maybe_unused,\n\t\t\t       struct machine *machine)\n{\n\treturn machine__process_switch_event(machine, event);\n}\n\nint perf_event__process_ksymbol(struct perf_tool *tool __maybe_unused,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample __maybe_unused,\n\t\t\t\tstruct machine *machine)\n{\n\treturn machine__process_ksymbol(machine, event, sample);\n}\n\nint perf_event__process_bpf(struct perf_tool *tool __maybe_unused,\n\t\t\t    union perf_event *event,\n\t\t\t    struct perf_sample *sample,\n\t\t\t    struct machine *machine)\n{\n\treturn machine__process_bpf(machine, event, sample);\n}\n\nint perf_event__process_text_poke(struct perf_tool *tool __maybe_unused,\n\t\t\t\t  union perf_event *event,\n\t\t\t\t  struct perf_sample *sample,\n\t\t\t\t  struct machine *machine)\n{\n\treturn machine__process_text_poke(machine, event, sample);\n}\n\nsize_t perf_event__fprintf_mmap(union perf_event *event, FILE *fp)\n{\n\treturn fprintf(fp, \" %d/%d: [%#\" PRI_lx64 \"(%#\" PRI_lx64 \") @ %#\" PRI_lx64 \"]: %c %s\\n\",\n\t\t       event->mmap.pid, event->mmap.tid, event->mmap.start,\n\t\t       event->mmap.len, event->mmap.pgoff,\n\t\t       (event->header.misc & PERF_RECORD_MISC_MMAP_DATA) ? 'r' : 'x',\n\t\t       event->mmap.filename);\n}\n\nsize_t perf_event__fprintf_mmap2(union perf_event *event, FILE *fp)\n{\n\tif (event->header.misc & PERF_RECORD_MISC_MMAP_BUILD_ID) {\n\t\tchar sbuild_id[SBUILD_ID_SIZE];\n\t\tstruct build_id bid;\n\n\t\tbuild_id__init(&bid, event->mmap2.build_id,\n\t\t\t       event->mmap2.build_id_size);\n\t\tbuild_id__sprintf(&bid, sbuild_id);\n\n\t\treturn fprintf(fp, \" %d/%d: [%#\" PRI_lx64 \"(%#\" PRI_lx64 \") @ %#\" PRI_lx64\n\t\t\t\t   \" <%s>]: %c%c%c%c %s\\n\",\n\t\t\t       event->mmap2.pid, event->mmap2.tid, event->mmap2.start,\n\t\t\t       event->mmap2.len, event->mmap2.pgoff, sbuild_id,\n\t\t\t       (event->mmap2.prot & PROT_READ) ? 'r' : '-',\n\t\t\t       (event->mmap2.prot & PROT_WRITE) ? 'w' : '-',\n\t\t\t       (event->mmap2.prot & PROT_EXEC) ? 'x' : '-',\n\t\t\t       (event->mmap2.flags & MAP_SHARED) ? 's' : 'p',\n\t\t\t       event->mmap2.filename);\n\t} else {\n\t\treturn fprintf(fp, \" %d/%d: [%#\" PRI_lx64 \"(%#\" PRI_lx64 \") @ %#\" PRI_lx64\n\t\t\t\t   \" %02x:%02x %\"PRI_lu64\" %\"PRI_lu64\"]: %c%c%c%c %s\\n\",\n\t\t\t       event->mmap2.pid, event->mmap2.tid, event->mmap2.start,\n\t\t\t       event->mmap2.len, event->mmap2.pgoff, event->mmap2.maj,\n\t\t\t       event->mmap2.min, event->mmap2.ino,\n\t\t\t       event->mmap2.ino_generation,\n\t\t\t       (event->mmap2.prot & PROT_READ) ? 'r' : '-',\n\t\t\t       (event->mmap2.prot & PROT_WRITE) ? 'w' : '-',\n\t\t\t       (event->mmap2.prot & PROT_EXEC) ? 'x' : '-',\n\t\t\t       (event->mmap2.flags & MAP_SHARED) ? 's' : 'p',\n\t\t\t       event->mmap2.filename);\n\t}\n}\n\nsize_t perf_event__fprintf_thread_map(union perf_event *event, FILE *fp)\n{\n\tstruct perf_thread_map *threads = thread_map__new_event(&event->thread_map);\n\tsize_t ret;\n\n\tret = fprintf(fp, \" nr: \");\n\n\tif (threads)\n\t\tret += thread_map__fprintf(threads, fp);\n\telse\n\t\tret += fprintf(fp, \"failed to get threads from event\\n\");\n\n\tperf_thread_map__put(threads);\n\treturn ret;\n}\n\nsize_t perf_event__fprintf_cpu_map(union perf_event *event, FILE *fp)\n{\n\tstruct perf_cpu_map *cpus = cpu_map__new_data(&event->cpu_map.data);\n\tsize_t ret;\n\n\tret = fprintf(fp, \": \");\n\n\tif (cpus)\n\t\tret += cpu_map__fprintf(cpus, fp);\n\telse\n\t\tret += fprintf(fp, \"failed to get cpumap from event\\n\");\n\n\tperf_cpu_map__put(cpus);\n\treturn ret;\n}\n\nint perf_event__process_mmap(struct perf_tool *tool __maybe_unused,\n\t\t\t     union perf_event *event,\n\t\t\t     struct perf_sample *sample,\n\t\t\t     struct machine *machine)\n{\n\treturn machine__process_mmap_event(machine, event, sample);\n}\n\nint perf_event__process_mmap2(struct perf_tool *tool __maybe_unused,\n\t\t\t     union perf_event *event,\n\t\t\t     struct perf_sample *sample,\n\t\t\t     struct machine *machine)\n{\n\treturn machine__process_mmap2_event(machine, event, sample);\n}\n\nsize_t perf_event__fprintf_task(union perf_event *event, FILE *fp)\n{\n\treturn fprintf(fp, \"(%d:%d):(%d:%d)\\n\",\n\t\t       event->fork.pid, event->fork.tid,\n\t\t       event->fork.ppid, event->fork.ptid);\n}\n\nint perf_event__process_fork(struct perf_tool *tool __maybe_unused,\n\t\t\t     union perf_event *event,\n\t\t\t     struct perf_sample *sample,\n\t\t\t     struct machine *machine)\n{\n\treturn machine__process_fork_event(machine, event, sample);\n}\n\nint perf_event__process_exit(struct perf_tool *tool __maybe_unused,\n\t\t\t     union perf_event *event,\n\t\t\t     struct perf_sample *sample,\n\t\t\t     struct machine *machine)\n{\n\treturn machine__process_exit_event(machine, event, sample);\n}\n\nsize_t perf_event__fprintf_aux(union perf_event *event, FILE *fp)\n{\n\treturn fprintf(fp, \" offset: %#\"PRI_lx64\" size: %#\"PRI_lx64\" flags: %#\"PRI_lx64\" [%s%s%s]\\n\",\n\t\t       event->aux.aux_offset, event->aux.aux_size,\n\t\t       event->aux.flags,\n\t\t       event->aux.flags & PERF_AUX_FLAG_TRUNCATED ? \"T\" : \"\",\n\t\t       event->aux.flags & PERF_AUX_FLAG_OVERWRITE ? \"O\" : \"\",\n\t\t       event->aux.flags & PERF_AUX_FLAG_PARTIAL   ? \"P\" : \"\");\n}\n\nsize_t perf_event__fprintf_itrace_start(union perf_event *event, FILE *fp)\n{\n\treturn fprintf(fp, \" pid: %u tid: %u\\n\",\n\t\t       event->itrace_start.pid, event->itrace_start.tid);\n}\n\nsize_t perf_event__fprintf_aux_output_hw_id(union perf_event *event, FILE *fp)\n{\n\treturn fprintf(fp, \" hw_id: %#\"PRI_lx64\"\\n\",\n\t\t       event->aux_output_hw_id.hw_id);\n}\n\nsize_t perf_event__fprintf_switch(union perf_event *event, FILE *fp)\n{\n\tbool out = event->header.misc & PERF_RECORD_MISC_SWITCH_OUT;\n\tconst char *in_out = !out ? \"IN         \" :\n\t\t!(event->header.misc & PERF_RECORD_MISC_SWITCH_OUT_PREEMPT) ?\n\t\t\t\t    \"OUT        \" : \"OUT preempt\";\n\n\tif (event->header.type == PERF_RECORD_SWITCH)\n\t\treturn fprintf(fp, \" %s\\n\", in_out);\n\n\treturn fprintf(fp, \" %s  %s pid/tid: %5d/%-5d\\n\",\n\t\t       in_out, out ? \"next\" : \"prev\",\n\t\t       event->context_switch.next_prev_pid,\n\t\t       event->context_switch.next_prev_tid);\n}\n\nstatic size_t perf_event__fprintf_lost(union perf_event *event, FILE *fp)\n{\n\treturn fprintf(fp, \" lost %\" PRI_lu64 \"\\n\", event->lost.lost);\n}\n\nsize_t perf_event__fprintf_ksymbol(union perf_event *event, FILE *fp)\n{\n\treturn fprintf(fp, \" addr %\" PRI_lx64 \" len %u type %u flags 0x%x name %s\\n\",\n\t\t       event->ksymbol.addr, event->ksymbol.len,\n\t\t       event->ksymbol.ksym_type,\n\t\t       event->ksymbol.flags, event->ksymbol.name);\n}\n\nsize_t perf_event__fprintf_bpf(union perf_event *event, FILE *fp)\n{\n\treturn fprintf(fp, \" type %u, flags %u, id %u\\n\",\n\t\t       event->bpf.type, event->bpf.flags, event->bpf.id);\n}\n\nstatic int text_poke_printer(enum binary_printer_ops op, unsigned int val,\n\t\t\t     void *extra, FILE *fp)\n{\n\tbool old = *(bool *)extra;\n\n\tswitch ((int)op) {\n\tcase BINARY_PRINT_LINE_BEGIN:\n\t\treturn fprintf(fp, \"            %s bytes:\", old ? \"Old\" : \"New\");\n\tcase BINARY_PRINT_NUM_DATA:\n\t\treturn fprintf(fp, \" %02x\", val);\n\tcase BINARY_PRINT_LINE_END:\n\t\treturn fprintf(fp, \"\\n\");\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nsize_t perf_event__fprintf_text_poke(union perf_event *event, struct machine *machine, FILE *fp)\n{\n\tstruct perf_record_text_poke_event *tp = &event->text_poke;\n\tsize_t ret;\n\tbool old;\n\n\tret = fprintf(fp, \" %\" PRI_lx64 \" \", tp->addr);\n\tif (machine) {\n\t\tstruct addr_location al;\n\n\t\taddr_location__init(&al);\n\t\tal.map = map__get(maps__find(machine__kernel_maps(machine), tp->addr));\n\t\tif (al.map && map__load(al.map) >= 0) {\n\t\t\tal.addr = map__map_ip(al.map, tp->addr);\n\t\t\tal.sym = map__find_symbol(al.map, al.addr);\n\t\t\tif (al.sym)\n\t\t\t\tret += symbol__fprintf_symname_offs(al.sym, &al, fp);\n\t\t}\n\t\taddr_location__exit(&al);\n\t}\n\tret += fprintf(fp, \" old len %u new len %u\\n\", tp->old_len, tp->new_len);\n\told = true;\n\tret += binary__fprintf(tp->bytes, tp->old_len, 16, text_poke_printer,\n\t\t\t       &old, fp);\n\told = false;\n\tret += binary__fprintf(tp->bytes + tp->old_len, tp->new_len, 16,\n\t\t\t       text_poke_printer, &old, fp);\n\treturn ret;\n}\n\nsize_t perf_event__fprintf(union perf_event *event, struct machine *machine, FILE *fp)\n{\n\tsize_t ret = fprintf(fp, \"PERF_RECORD_%s\",\n\t\t\t     perf_event__name(event->header.type));\n\n\tswitch (event->header.type) {\n\tcase PERF_RECORD_COMM:\n\t\tret += perf_event__fprintf_comm(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_FORK:\n\tcase PERF_RECORD_EXIT:\n\t\tret += perf_event__fprintf_task(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_MMAP:\n\t\tret += perf_event__fprintf_mmap(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_NAMESPACES:\n\t\tret += perf_event__fprintf_namespaces(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_CGROUP:\n\t\tret += perf_event__fprintf_cgroup(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_MMAP2:\n\t\tret += perf_event__fprintf_mmap2(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_AUX:\n\t\tret += perf_event__fprintf_aux(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_ITRACE_START:\n\t\tret += perf_event__fprintf_itrace_start(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_SWITCH:\n\tcase PERF_RECORD_SWITCH_CPU_WIDE:\n\t\tret += perf_event__fprintf_switch(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_LOST:\n\t\tret += perf_event__fprintf_lost(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_KSYMBOL:\n\t\tret += perf_event__fprintf_ksymbol(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_BPF_EVENT:\n\t\tret += perf_event__fprintf_bpf(event, fp);\n\t\tbreak;\n\tcase PERF_RECORD_TEXT_POKE:\n\t\tret += perf_event__fprintf_text_poke(event, machine, fp);\n\t\tbreak;\n\tcase PERF_RECORD_AUX_OUTPUT_HW_ID:\n\t\tret += perf_event__fprintf_aux_output_hw_id(event, fp);\n\t\tbreak;\n\tdefault:\n\t\tret += fprintf(fp, \"\\n\");\n\t}\n\n\treturn ret;\n}\n\nint perf_event__process(struct perf_tool *tool __maybe_unused,\n\t\t\tunion perf_event *event,\n\t\t\tstruct perf_sample *sample,\n\t\t\tstruct machine *machine)\n{\n\treturn machine__process_event(machine, event, sample);\n}\n\nstruct map *thread__find_map(struct thread *thread, u8 cpumode, u64 addr,\n\t\t\t     struct addr_location *al)\n{\n\tstruct maps *maps = thread__maps(thread);\n\tstruct machine *machine = maps__machine(maps);\n\tbool load_map = false;\n\n\tmaps__zput(al->maps);\n\tmap__zput(al->map);\n\tthread__zput(al->thread);\n\tal->thread = thread__get(thread);\n\n\tal->addr = addr;\n\tal->cpumode = cpumode;\n\tal->filtered = 0;\n\n\tif (machine == NULL)\n\t\treturn NULL;\n\n\tif (cpumode == PERF_RECORD_MISC_KERNEL && perf_host) {\n\t\tal->level = 'k';\n\t\tmaps = machine__kernel_maps(machine);\n\t\tload_map = true;\n\t} else if (cpumode == PERF_RECORD_MISC_USER && perf_host) {\n\t\tal->level = '.';\n\t} else if (cpumode == PERF_RECORD_MISC_GUEST_KERNEL && perf_guest) {\n\t\tal->level = 'g';\n\t\tmaps = machine__kernel_maps(machine);\n\t\tload_map = true;\n\t} else if (cpumode == PERF_RECORD_MISC_GUEST_USER && perf_guest) {\n\t\tal->level = 'u';\n\t} else {\n\t\tal->level = 'H';\n\n\t\tif ((cpumode == PERF_RECORD_MISC_GUEST_USER ||\n\t\t\tcpumode == PERF_RECORD_MISC_GUEST_KERNEL) &&\n\t\t\t!perf_guest)\n\t\t\tal->filtered |= (1 << HIST_FILTER__GUEST);\n\t\tif ((cpumode == PERF_RECORD_MISC_USER ||\n\t\t\tcpumode == PERF_RECORD_MISC_KERNEL) &&\n\t\t\t!perf_host)\n\t\t\tal->filtered |= (1 << HIST_FILTER__HOST);\n\n\t\treturn NULL;\n\t}\n\tal->maps = maps__get(maps);\n\tal->map = map__get(maps__find(maps, al->addr));\n\tif (al->map != NULL) {\n\t\t \n\t\tif (load_map)\n\t\t\tmap__load(al->map);\n\t\tal->addr = map__map_ip(al->map, al->addr);\n\t}\n\n\treturn al->map;\n}\n\n \nstruct map *thread__find_map_fb(struct thread *thread, u8 cpumode, u64 addr,\n\t\t\t\tstruct addr_location *al)\n{\n\tstruct map *map = thread__find_map(thread, cpumode, addr, al);\n\tstruct machine *machine = maps__machine(thread__maps(thread));\n\tu8 addr_cpumode = machine__addr_cpumode(machine, cpumode, addr);\n\n\tif (map || addr_cpumode == cpumode)\n\t\treturn map;\n\n\treturn thread__find_map(thread, addr_cpumode, addr, al);\n}\n\nstruct symbol *thread__find_symbol(struct thread *thread, u8 cpumode,\n\t\t\t\t   u64 addr, struct addr_location *al)\n{\n\tal->sym = NULL;\n\tif (thread__find_map(thread, cpumode, addr, al))\n\t\tal->sym = map__find_symbol(al->map, al->addr);\n\treturn al->sym;\n}\n\nstruct symbol *thread__find_symbol_fb(struct thread *thread, u8 cpumode,\n\t\t\t\t      u64 addr, struct addr_location *al)\n{\n\tal->sym = NULL;\n\tif (thread__find_map_fb(thread, cpumode, addr, al))\n\t\tal->sym = map__find_symbol(al->map, al->addr);\n\treturn al->sym;\n}\n\nstatic bool check_address_range(struct intlist *addr_list, int addr_range,\n\t\t\t\tunsigned long addr)\n{\n\tstruct int_node *pos;\n\n\tintlist__for_each_entry(pos, addr_list) {\n\t\tif (addr >= pos->i && addr < pos->i + addr_range)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nint machine__resolve(struct machine *machine, struct addr_location *al,\n\t\t     struct perf_sample *sample)\n{\n\tstruct thread *thread;\n\tstruct dso *dso;\n\n\tif (symbol_conf.guest_code && !machine__is_host(machine))\n\t\tthread = machine__findnew_guest_code(machine, sample->pid);\n\telse\n\t\tthread = machine__findnew_thread(machine, sample->pid, sample->tid);\n\tif (thread == NULL)\n\t\treturn -1;\n\n\tdump_printf(\" ... thread: %s:%d\\n\", thread__comm_str(thread), thread__tid(thread));\n\tthread__find_map(thread, sample->cpumode, sample->ip, al);\n\tdso = al->map ? map__dso(al->map) : NULL;\n\tdump_printf(\" ...... dso: %s\\n\",\n\t\tdso\n\t\t? dso->long_name\n\t\t: (al->level == 'H' ? \"[hypervisor]\" : \"<not found>\"));\n\n\tif (thread__is_filtered(thread))\n\t\tal->filtered |= (1 << HIST_FILTER__THREAD);\n\n\tthread__put(thread);\n\tthread = NULL;\n\n\tal->sym = NULL;\n\tal->cpu = sample->cpu;\n\tal->socket = -1;\n\tal->srcline = NULL;\n\n\tif (al->cpu >= 0) {\n\t\tstruct perf_env *env = machine->env;\n\n\t\tif (env && env->cpu)\n\t\t\tal->socket = env->cpu[al->cpu].socket_id;\n\t}\n\n\tif (al->map) {\n\t\tif (symbol_conf.dso_list &&\n\t\t    (!dso || !(strlist__has_entry(symbol_conf.dso_list,\n\t\t\t\t\t\t  dso->short_name) ||\n\t\t\t       (dso->short_name != dso->long_name &&\n\t\t\t\tstrlist__has_entry(symbol_conf.dso_list,\n\t\t\t\t\t\t   dso->long_name))))) {\n\t\t\tal->filtered |= (1 << HIST_FILTER__DSO);\n\t\t}\n\n\t\tal->sym = map__find_symbol(al->map, al->addr);\n\t} else if (symbol_conf.dso_list) {\n\t\tal->filtered |= (1 << HIST_FILTER__DSO);\n\t}\n\n\tif (symbol_conf.sym_list) {\n\t\tint ret = 0;\n\t\tchar al_addr_str[32];\n\t\tsize_t sz = sizeof(al_addr_str);\n\n\t\tif (al->sym) {\n\t\t\tret = strlist__has_entry(symbol_conf.sym_list,\n\t\t\t\t\t\tal->sym->name);\n\t\t}\n\t\tif (!ret && al->sym) {\n\t\t\tsnprintf(al_addr_str, sz, \"0x%\"PRIx64,\n\t\t\t\t map__unmap_ip(al->map, al->sym->start));\n\t\t\tret = strlist__has_entry(symbol_conf.sym_list,\n\t\t\t\t\t\tal_addr_str);\n\t\t}\n\t\tif (!ret && symbol_conf.addr_list && al->map) {\n\t\t\tunsigned long addr = map__unmap_ip(al->map, al->addr);\n\n\t\t\tret = intlist__has_entry(symbol_conf.addr_list, addr);\n\t\t\tif (!ret && symbol_conf.addr_range) {\n\t\t\t\tret = check_address_range(symbol_conf.addr_list,\n\t\t\t\t\t\t\t  symbol_conf.addr_range,\n\t\t\t\t\t\t\t  addr);\n\t\t\t}\n\t\t}\n\n\t\tif (!ret)\n\t\t\tal->filtered |= (1 << HIST_FILTER__SYMBOL);\n\t}\n\n\treturn 0;\n}\n\nbool is_bts_event(struct perf_event_attr *attr)\n{\n\treturn attr->type == PERF_TYPE_HARDWARE &&\n\t       (attr->config & PERF_COUNT_HW_BRANCH_INSTRUCTIONS) &&\n\t       attr->sample_period == 1;\n}\n\nbool sample_addr_correlates_sym(struct perf_event_attr *attr)\n{\n\tif (attr->type == PERF_TYPE_SOFTWARE &&\n\t    (attr->config == PERF_COUNT_SW_PAGE_FAULTS ||\n\t     attr->config == PERF_COUNT_SW_PAGE_FAULTS_MIN ||\n\t     attr->config == PERF_COUNT_SW_PAGE_FAULTS_MAJ))\n\t\treturn true;\n\n\tif (is_bts_event(attr))\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid thread__resolve(struct thread *thread, struct addr_location *al,\n\t\t     struct perf_sample *sample)\n{\n\tthread__find_map_fb(thread, sample->cpumode, sample->addr, al);\n\n\tal->cpu = sample->cpu;\n\tal->sym = NULL;\n\n\tif (al->map)\n\t\tal->sym = map__find_symbol(al->map, al->addr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}