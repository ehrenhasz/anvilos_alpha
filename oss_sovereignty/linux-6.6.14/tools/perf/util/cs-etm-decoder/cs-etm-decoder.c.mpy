{
  "module_name": "cs-etm-decoder.c",
  "hash_id": "0a2885a4438a1f9912c01c7557d016ba6c3670279d36676f2d9941afefc09e65",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/cs-etm-decoder/cs-etm-decoder.c",
  "human_readable_source": "\n \n\n#include <asm/bug.h>\n#include <linux/coresight-pmu.h>\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/zalloc.h>\n#include <stdlib.h>\n#include <opencsd/c_api/opencsd_c_api.h>\n\n#include \"cs-etm.h\"\n#include \"cs-etm-decoder.h\"\n#include \"debug.h\"\n#include \"intlist.h\"\n\n \n#ifdef CS_DEBUG_RAW\n#define CS_LOG_RAW_FRAMES\n#ifdef CS_RAW_PACKED\n#define CS_RAW_DEBUG_FLAGS (OCSD_DFRMTR_UNPACKED_RAW_OUT | \\\n\t\t\t    OCSD_DFRMTR_PACKED_RAW_OUT)\n#else\n#define CS_RAW_DEBUG_FLAGS (OCSD_DFRMTR_UNPACKED_RAW_OUT)\n#endif\n#endif\n\n \nconst u32 INSTR_PER_NS = 10;\n\nstruct cs_etm_decoder {\n\tvoid *data;\n\tvoid (*packet_printer)(const char *msg);\n\tbool suppress_printing;\n\tdcd_tree_handle_t dcd_tree;\n\tcs_etm_mem_cb_type mem_access;\n\tocsd_datapath_resp_t prev_return;\n\tconst char *decoder_name;\n};\n\nstatic u32\ncs_etm_decoder__mem_access(const void *context,\n\t\t\t   const ocsd_vaddr_t address,\n\t\t\t   const ocsd_mem_space_acc_t mem_space,\n\t\t\t   const u8 trace_chan_id,\n\t\t\t   const u32 req_size,\n\t\t\t   u8 *buffer)\n{\n\tstruct cs_etm_decoder *decoder = (struct cs_etm_decoder *) context;\n\n\treturn decoder->mem_access(decoder->data, trace_chan_id, address,\n\t\t\t\t   req_size, buffer, mem_space);\n}\n\nint cs_etm_decoder__add_mem_access_cb(struct cs_etm_decoder *decoder,\n\t\t\t\t      u64 start, u64 end,\n\t\t\t\t      cs_etm_mem_cb_type cb_func)\n{\n\tdecoder->mem_access = cb_func;\n\n\tif (ocsd_dt_add_callback_trcid_mem_acc(decoder->dcd_tree, start, end,\n\t\t\t\t\t       OCSD_MEM_SPACE_ANY,\n\t\t\t\t\t       cs_etm_decoder__mem_access,\n\t\t\t\t\t       decoder))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint cs_etm_decoder__reset(struct cs_etm_decoder *decoder)\n{\n\tocsd_datapath_resp_t dp_ret;\n\n\tdecoder->prev_return = OCSD_RESP_CONT;\n\tdecoder->suppress_printing = true;\n\tdp_ret = ocsd_dt_process_data(decoder->dcd_tree, OCSD_OP_RESET,\n\t\t\t\t      0, 0, NULL, NULL);\n\tdecoder->suppress_printing = false;\n\tif (OCSD_DATA_RESP_IS_FATAL(dp_ret))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint cs_etm_decoder__get_packet(struct cs_etm_packet_queue *packet_queue,\n\t\t\t       struct cs_etm_packet *packet)\n{\n\tif (!packet_queue || !packet)\n\t\treturn -EINVAL;\n\n\t \n\tif (packet_queue->packet_count == 0)\n\t\treturn 0;\n\t \n\tpacket_queue->head = (packet_queue->head + 1) &\n\t\t\t     (CS_ETM_PACKET_MAX_BUFFER - 1);\n\n\t*packet = packet_queue->packet_buffer[packet_queue->head];\n\n\tpacket_queue->packet_count--;\n\n\treturn 1;\n}\n\n \nstatic u32 cs_etm_decoder__dec_instr_count_to_ns(u32 *instr_count)\n{\n\tconst u32 instr_copy = *instr_count;\n\n\t*instr_count %= INSTR_PER_NS;\n\treturn instr_copy / INSTR_PER_NS;\n}\n\nstatic int cs_etm_decoder__gen_etmv3_config(struct cs_etm_trace_params *params,\n\t\t\t\t\t    ocsd_etmv3_cfg *config)\n{\n\tconfig->reg_idr = params->etmv3.reg_idr;\n\tconfig->reg_ctrl = params->etmv3.reg_ctrl;\n\tconfig->reg_ccer = params->etmv3.reg_ccer;\n\tconfig->reg_trc_id = params->etmv3.reg_trc_id;\n\tconfig->arch_ver = ARCH_V7;\n\tconfig->core_prof = profile_CortexA;\n\n\treturn 0;\n}\n\n#define TRCIDR1_TRCARCHMIN_SHIFT 4\n#define TRCIDR1_TRCARCHMIN_MASK  GENMASK(7, 4)\n#define TRCIDR1_TRCARCHMIN(x)    (((x) & TRCIDR1_TRCARCHMIN_MASK) >> TRCIDR1_TRCARCHMIN_SHIFT)\n\nstatic enum _ocsd_arch_version cs_etm_decoder__get_etmv4_arch_ver(u32 reg_idr1)\n{\n\t \n\treturn TRCIDR1_TRCARCHMIN(reg_idr1) >= 4 ? ARCH_AA64 : ARCH_V8;\n}\n\nstatic void cs_etm_decoder__gen_etmv4_config(struct cs_etm_trace_params *params,\n\t\t\t\t\t     ocsd_etmv4_cfg *config)\n{\n\tconfig->reg_configr = params->etmv4.reg_configr;\n\tconfig->reg_traceidr = params->etmv4.reg_traceidr;\n\tconfig->reg_idr0 = params->etmv4.reg_idr0;\n\tconfig->reg_idr1 = params->etmv4.reg_idr1;\n\tconfig->reg_idr2 = params->etmv4.reg_idr2;\n\tconfig->reg_idr8 = params->etmv4.reg_idr8;\n\tconfig->reg_idr9 = 0;\n\tconfig->reg_idr10 = 0;\n\tconfig->reg_idr11 = 0;\n\tconfig->reg_idr12 = 0;\n\tconfig->reg_idr13 = 0;\n\tconfig->arch_ver = cs_etm_decoder__get_etmv4_arch_ver(params->etmv4.reg_idr1);\n\tconfig->core_prof = profile_CortexA;\n}\n\nstatic void cs_etm_decoder__gen_ete_config(struct cs_etm_trace_params *params,\n\t\t\t\t\t   ocsd_ete_cfg *config)\n{\n\tconfig->reg_configr = params->ete.reg_configr;\n\tconfig->reg_traceidr = params->ete.reg_traceidr;\n\tconfig->reg_idr0 = params->ete.reg_idr0;\n\tconfig->reg_idr1 = params->ete.reg_idr1;\n\tconfig->reg_idr2 = params->ete.reg_idr2;\n\tconfig->reg_idr8 = params->ete.reg_idr8;\n\tconfig->reg_devarch = params->ete.reg_devarch;\n\tconfig->arch_ver = ARCH_AA64;\n\tconfig->core_prof = profile_CortexA;\n}\n\nstatic void cs_etm_decoder__print_str_cb(const void *p_context,\n\t\t\t\t\t const char *msg,\n\t\t\t\t\t const int str_len)\n{\n\tconst struct cs_etm_decoder *decoder = p_context;\n\n\tif (p_context && str_len && !decoder->suppress_printing)\n\t\tdecoder->packet_printer(msg);\n}\n\nstatic int\ncs_etm_decoder__init_def_logger_printing(struct cs_etm_decoder_params *d_params,\n\t\t\t\t\t struct cs_etm_decoder *decoder)\n{\n\tint ret = 0;\n\n\tif (d_params->packet_printer == NULL)\n\t\treturn -1;\n\n\tdecoder->packet_printer = d_params->packet_printer;\n\n\t \n\tret = ocsd_def_errlog_init(OCSD_ERR_SEV_ERROR, 1);\n\tif (ret != 0)\n\t\treturn -1;\n\n\t \n\tret = ocsd_def_errlog_config_output(C_API_MSGLOGOUT_FLG_NONE, NULL);\n\tif (ret != 0)\n\t\treturn -1;\n\n\t \n\tret = ocsd_def_errlog_set_strprint_cb(decoder->dcd_tree,\n\t\t\t\t\t      (void *)decoder,\n\t\t\t\t\t      cs_etm_decoder__print_str_cb);\n\tif (ret != 0)\n\t\tret = -1;\n\n\treturn 0;\n}\n\n#ifdef CS_LOG_RAW_FRAMES\nstatic void\ncs_etm_decoder__init_raw_frame_logging(struct cs_etm_decoder_params *d_params,\n\t\t\t\t       struct cs_etm_decoder *decoder)\n{\n\t \n\tif (d_params->operation == CS_ETM_OPERATION_PRINT) {\n\t\t \n\t\tocsd_def_errlog_init(OCSD_ERR_SEV_ERROR, 1);\n\n\t\t \n\t\tocsd_def_errlog_config_output(C_API_MSGLOGOUT_FLG_NONE, NULL);\n\n\t\t \n\t\tocsd_def_errlog_set_strprint_cb(decoder->dcd_tree,\n\t\t\t\t\t\t(void *)decoder,\n\t\t\t\t\t\tcs_etm_decoder__print_str_cb);\n\n\t\t \n\t\tocsd_dt_set_raw_frame_printer(decoder->dcd_tree,\n\t\t\t\t\t      CS_RAW_DEBUG_FLAGS);\n\t}\n}\n#else\nstatic void\ncs_etm_decoder__init_raw_frame_logging(\n\t\tstruct cs_etm_decoder_params *d_params __maybe_unused,\n\t\tstruct cs_etm_decoder *decoder __maybe_unused)\n{\n}\n#endif\n\nstatic ocsd_datapath_resp_t\ncs_etm_decoder__do_soft_timestamp(struct cs_etm_queue *etmq,\n\t\t\t\t  struct cs_etm_packet_queue *packet_queue,\n\t\t\t\t  const uint8_t trace_chan_id)\n{\n\tu64 estimated_ts;\n\n\t \n\tif (!packet_queue->next_cs_timestamp)\n\t\treturn OCSD_RESP_CONT;\n\n\testimated_ts = packet_queue->cs_timestamp +\n\t\t\tcs_etm_decoder__dec_instr_count_to_ns(&packet_queue->instr_count);\n\n\t \n\tpacket_queue->cs_timestamp = min(packet_queue->next_cs_timestamp, estimated_ts);\n\n\t \n\tcs_etm__etmq_set_traceid_queue_timestamp(etmq, trace_chan_id);\n\n\treturn OCSD_RESP_WAIT;\n}\n\nstatic ocsd_datapath_resp_t\ncs_etm_decoder__do_hard_timestamp(struct cs_etm_queue *etmq,\n\t\t\t\t  const ocsd_generic_trace_elem *elem,\n\t\t\t\t  const uint8_t trace_chan_id,\n\t\t\t\t  const ocsd_trc_index_t indx)\n{\n\tstruct cs_etm_packet_queue *packet_queue;\n\tu64 converted_timestamp;\n\tu64 estimated_first_ts;\n\n\t \n\tpacket_queue = cs_etm__etmq_get_packet_queue(etmq, trace_chan_id);\n\tif (!packet_queue)\n\t\treturn OCSD_RESP_FATAL_SYS_ERR;\n\n\t \n\tconverted_timestamp = elem->timestamp ?\n\t\t\t\tcs_etm__convert_sample_time(etmq, elem->timestamp) : 0;\n\n\t \n\tif (packet_queue->next_cs_timestamp) {\n\t\t \n\t\tpacket_queue->cs_timestamp = packet_queue->next_cs_timestamp;\n\t\tpacket_queue->next_cs_timestamp = converted_timestamp;\n\t\treturn OCSD_RESP_CONT;\n\t}\n\n\tif (!converted_timestamp) {\n\t\t \n\t\tpacket_queue->cs_timestamp = 0;\n\t\tif (!cs_etm__etmq_is_timeless(etmq))\n\t\t\tpr_warning_once(\"Zero Coresight timestamp found at Idx:%\" OCSD_TRC_IDX_STR\n\t\t\t\t\t\". Decoding may be improved by prepending 'Z' to your current --itrace arguments.\\n\",\n\t\t\t\t\tindx);\n\n\t} else if (packet_queue->instr_count / INSTR_PER_NS > converted_timestamp) {\n\t\t \n\t\tpacket_queue->cs_timestamp = 0;\n\t\tpr_err(\"Timestamp calculation underflow at Idx:%\" OCSD_TRC_IDX_STR \"\\n\", indx);\n\t} else {\n\t\t \n\t\testimated_first_ts = converted_timestamp -\n\t\t\t\t\t(packet_queue->instr_count / INSTR_PER_NS);\n\t\tpacket_queue->cs_timestamp = max(packet_queue->cs_timestamp, estimated_first_ts);\n\t}\n\tpacket_queue->next_cs_timestamp = converted_timestamp;\n\tpacket_queue->instr_count = 0;\n\n\t \n\tcs_etm__etmq_set_traceid_queue_timestamp(etmq, trace_chan_id);\n\n\t \n\treturn OCSD_RESP_WAIT;\n}\n\nstatic void\ncs_etm_decoder__reset_timestamp(struct cs_etm_packet_queue *packet_queue)\n{\n\tpacket_queue->next_cs_timestamp = 0;\n\tpacket_queue->instr_count = 0;\n}\n\nstatic ocsd_datapath_resp_t\ncs_etm_decoder__buffer_packet(struct cs_etm_packet_queue *packet_queue,\n\t\t\t      const u8 trace_chan_id,\n\t\t\t      enum cs_etm_sample_type sample_type)\n{\n\tu32 et = 0;\n\tint cpu;\n\n\tif (packet_queue->packet_count >= CS_ETM_PACKET_MAX_BUFFER - 1)\n\t\treturn OCSD_RESP_FATAL_SYS_ERR;\n\n\tif (cs_etm__get_cpu(trace_chan_id, &cpu) < 0)\n\t\treturn OCSD_RESP_FATAL_SYS_ERR;\n\n\tet = packet_queue->tail;\n\tet = (et + 1) & (CS_ETM_PACKET_MAX_BUFFER - 1);\n\tpacket_queue->tail = et;\n\tpacket_queue->packet_count++;\n\n\tpacket_queue->packet_buffer[et].sample_type = sample_type;\n\tpacket_queue->packet_buffer[et].isa = CS_ETM_ISA_UNKNOWN;\n\tpacket_queue->packet_buffer[et].cpu = cpu;\n\tpacket_queue->packet_buffer[et].start_addr = CS_ETM_INVAL_ADDR;\n\tpacket_queue->packet_buffer[et].end_addr = CS_ETM_INVAL_ADDR;\n\tpacket_queue->packet_buffer[et].instr_count = 0;\n\tpacket_queue->packet_buffer[et].last_instr_taken_branch = false;\n\tpacket_queue->packet_buffer[et].last_instr_size = 0;\n\tpacket_queue->packet_buffer[et].last_instr_type = 0;\n\tpacket_queue->packet_buffer[et].last_instr_subtype = 0;\n\tpacket_queue->packet_buffer[et].last_instr_cond = 0;\n\tpacket_queue->packet_buffer[et].flags = 0;\n\tpacket_queue->packet_buffer[et].exception_number = UINT32_MAX;\n\tpacket_queue->packet_buffer[et].trace_chan_id = trace_chan_id;\n\n\tif (packet_queue->packet_count == CS_ETM_PACKET_MAX_BUFFER - 1)\n\t\treturn OCSD_RESP_WAIT;\n\n\treturn OCSD_RESP_CONT;\n}\n\nstatic ocsd_datapath_resp_t\ncs_etm_decoder__buffer_range(struct cs_etm_queue *etmq,\n\t\t\t     struct cs_etm_packet_queue *packet_queue,\n\t\t\t     const ocsd_generic_trace_elem *elem,\n\t\t\t     const uint8_t trace_chan_id)\n{\n\tint ret = 0;\n\tstruct cs_etm_packet *packet;\n\n\tret = cs_etm_decoder__buffer_packet(packet_queue, trace_chan_id,\n\t\t\t\t\t    CS_ETM_RANGE);\n\tif (ret != OCSD_RESP_CONT && ret != OCSD_RESP_WAIT)\n\t\treturn ret;\n\n\tpacket = &packet_queue->packet_buffer[packet_queue->tail];\n\n\tswitch (elem->isa) {\n\tcase ocsd_isa_aarch64:\n\t\tpacket->isa = CS_ETM_ISA_A64;\n\t\tbreak;\n\tcase ocsd_isa_arm:\n\t\tpacket->isa = CS_ETM_ISA_A32;\n\t\tbreak;\n\tcase ocsd_isa_thumb2:\n\t\tpacket->isa = CS_ETM_ISA_T32;\n\t\tbreak;\n\tcase ocsd_isa_tee:\n\tcase ocsd_isa_jazelle:\n\tcase ocsd_isa_custom:\n\tcase ocsd_isa_unknown:\n\tdefault:\n\t\tpacket->isa = CS_ETM_ISA_UNKNOWN;\n\t}\n\n\tpacket->start_addr = elem->st_addr;\n\tpacket->end_addr = elem->en_addr;\n\tpacket->instr_count = elem->num_instr_range;\n\tpacket->last_instr_type = elem->last_i_type;\n\tpacket->last_instr_subtype = elem->last_i_subtype;\n\tpacket->last_instr_cond = elem->last_instr_cond;\n\n\tif (elem->last_i_type == OCSD_INSTR_BR || elem->last_i_type == OCSD_INSTR_BR_INDIRECT)\n\t\tpacket->last_instr_taken_branch = elem->last_instr_exec;\n\telse\n\t\tpacket->last_instr_taken_branch = false;\n\n\tpacket->last_instr_size = elem->last_instr_sz;\n\n\t \n\tif (cs_etm__etmq_is_timeless(etmq))\n\t\tgoto out;\n\n\t \n\tif (ret == OCSD_RESP_WAIT)\n\t\tgoto out;\n\n\tpacket_queue->instr_count += elem->num_instr_range;\n\t \n\tret = cs_etm_decoder__do_soft_timestamp(etmq, packet_queue,\n\t\t\t\t\t\ttrace_chan_id);\nout:\n\treturn ret;\n}\n\nstatic ocsd_datapath_resp_t\ncs_etm_decoder__buffer_discontinuity(struct cs_etm_packet_queue *queue,\n\t\t\t\t     const uint8_t trace_chan_id)\n{\n\t \n\tcs_etm_decoder__reset_timestamp(queue);\n\treturn cs_etm_decoder__buffer_packet(queue, trace_chan_id,\n\t\t\t\t\t     CS_ETM_DISCONTINUITY);\n}\n\nstatic ocsd_datapath_resp_t\ncs_etm_decoder__buffer_exception(struct cs_etm_packet_queue *queue,\n\t\t\t\t const ocsd_generic_trace_elem *elem,\n\t\t\t\t const uint8_t trace_chan_id)\n{\tint ret = 0;\n\tstruct cs_etm_packet *packet;\n\n\tret = cs_etm_decoder__buffer_packet(queue, trace_chan_id,\n\t\t\t\t\t    CS_ETM_EXCEPTION);\n\tif (ret != OCSD_RESP_CONT && ret != OCSD_RESP_WAIT)\n\t\treturn ret;\n\n\tpacket = &queue->packet_buffer[queue->tail];\n\tpacket->exception_number = elem->exception_number;\n\n\treturn ret;\n}\n\nstatic ocsd_datapath_resp_t\ncs_etm_decoder__buffer_exception_ret(struct cs_etm_packet_queue *queue,\n\t\t\t\t     const uint8_t trace_chan_id)\n{\n\treturn cs_etm_decoder__buffer_packet(queue, trace_chan_id,\n\t\t\t\t\t     CS_ETM_EXCEPTION_RET);\n}\n\nstatic ocsd_datapath_resp_t\ncs_etm_decoder__set_tid(struct cs_etm_queue *etmq,\n\t\t\tstruct cs_etm_packet_queue *packet_queue,\n\t\t\tconst ocsd_generic_trace_elem *elem,\n\t\t\tconst uint8_t trace_chan_id)\n{\n\tpid_t tid = -1;\n\n\t \n\tswitch (cs_etm__get_pid_fmt(etmq)) {\n\tcase CS_ETM_PIDFMT_CTXTID:\n\t\tif (elem->context.ctxt_id_valid)\n\t\t\ttid = elem->context.context_id;\n\t\tbreak;\n\tcase CS_ETM_PIDFMT_CTXTID2:\n\t\tif (elem->context.vmid_valid)\n\t\t\ttid = elem->context.vmid;\n\t\tbreak;\n\tcase CS_ETM_PIDFMT_NONE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (cs_etm__etmq_set_tid_el(etmq, tid, trace_chan_id,\n\t\t\t\t    elem->context.exception_level))\n\t\treturn OCSD_RESP_FATAL_SYS_ERR;\n\n\tif (tid == -1)\n\t\treturn OCSD_RESP_CONT;\n\n\t \n\tcs_etm_decoder__reset_timestamp(packet_queue);\n\n\treturn OCSD_RESP_CONT;\n}\n\nstatic ocsd_datapath_resp_t cs_etm_decoder__gen_trace_elem_printer(\n\t\t\t\tconst void *context,\n\t\t\t\tconst ocsd_trc_index_t indx,\n\t\t\t\tconst u8 trace_chan_id __maybe_unused,\n\t\t\t\tconst ocsd_generic_trace_elem *elem)\n{\n\tocsd_datapath_resp_t resp = OCSD_RESP_CONT;\n\tstruct cs_etm_decoder *decoder = (struct cs_etm_decoder *) context;\n\tstruct cs_etm_queue *etmq = decoder->data;\n\tstruct cs_etm_packet_queue *packet_queue;\n\n\t \n\tpacket_queue = cs_etm__etmq_get_packet_queue(etmq, trace_chan_id);\n\tif (!packet_queue)\n\t\treturn OCSD_RESP_FATAL_SYS_ERR;\n\n\tswitch (elem->elem_type) {\n\tcase OCSD_GEN_TRC_ELEM_UNKNOWN:\n\t\tbreak;\n\tcase OCSD_GEN_TRC_ELEM_EO_TRACE:\n\tcase OCSD_GEN_TRC_ELEM_NO_SYNC:\n\tcase OCSD_GEN_TRC_ELEM_TRACE_ON:\n\t\tresp = cs_etm_decoder__buffer_discontinuity(packet_queue,\n\t\t\t\t\t\t\t    trace_chan_id);\n\t\tbreak;\n\tcase OCSD_GEN_TRC_ELEM_INSTR_RANGE:\n\t\tresp = cs_etm_decoder__buffer_range(etmq, packet_queue, elem,\n\t\t\t\t\t\t    trace_chan_id);\n\t\tbreak;\n\tcase OCSD_GEN_TRC_ELEM_EXCEPTION:\n\t\tresp = cs_etm_decoder__buffer_exception(packet_queue, elem,\n\t\t\t\t\t\t\ttrace_chan_id);\n\t\tbreak;\n\tcase OCSD_GEN_TRC_ELEM_EXCEPTION_RET:\n\t\tresp = cs_etm_decoder__buffer_exception_ret(packet_queue,\n\t\t\t\t\t\t\t    trace_chan_id);\n\t\tbreak;\n\tcase OCSD_GEN_TRC_ELEM_TIMESTAMP:\n\t\tresp = cs_etm_decoder__do_hard_timestamp(etmq, elem,\n\t\t\t\t\t\t\t trace_chan_id,\n\t\t\t\t\t\t\t indx);\n\t\tbreak;\n\tcase OCSD_GEN_TRC_ELEM_PE_CONTEXT:\n\t\tresp = cs_etm_decoder__set_tid(etmq, packet_queue,\n\t\t\t\t\t       elem, trace_chan_id);\n\t\tbreak;\n\t \n\tcase OCSD_GEN_TRC_ELEM_I_RANGE_NOPATH:\n\tcase OCSD_GEN_TRC_ELEM_ADDR_NACC:\n\tcase OCSD_GEN_TRC_ELEM_CYCLE_COUNT:\n\tcase OCSD_GEN_TRC_ELEM_ADDR_UNKNOWN:\n\tcase OCSD_GEN_TRC_ELEM_EVENT:\n\tcase OCSD_GEN_TRC_ELEM_SWTRACE:\n\tcase OCSD_GEN_TRC_ELEM_CUSTOM:\n\tcase OCSD_GEN_TRC_ELEM_SYNC_MARKER:\n\tcase OCSD_GEN_TRC_ELEM_MEMTRANS:\n#if (OCSD_VER_NUM >= 0x010400)\n\tcase OCSD_GEN_TRC_ELEM_INSTRUMENTATION:\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn resp;\n}\n\nstatic int\ncs_etm_decoder__create_etm_decoder(struct cs_etm_decoder_params *d_params,\n\t\t\t\t   struct cs_etm_trace_params *t_params,\n\t\t\t\t   struct cs_etm_decoder *decoder)\n{\n\tocsd_etmv3_cfg config_etmv3;\n\tocsd_etmv4_cfg trace_config_etmv4;\n\tocsd_ete_cfg trace_config_ete;\n\tvoid *trace_config;\n\tu8 csid;\n\n\tswitch (t_params->protocol) {\n\tcase CS_ETM_PROTO_ETMV3:\n\tcase CS_ETM_PROTO_PTM:\n\t\tcsid = (t_params->etmv3.reg_idr & CORESIGHT_TRACE_ID_VAL_MASK);\n\t\tcs_etm_decoder__gen_etmv3_config(t_params, &config_etmv3);\n\t\tdecoder->decoder_name = (t_params->protocol == CS_ETM_PROTO_ETMV3) ?\n\t\t\t\t\t\t\tOCSD_BUILTIN_DCD_ETMV3 :\n\t\t\t\t\t\t\tOCSD_BUILTIN_DCD_PTM;\n\t\ttrace_config = &config_etmv3;\n\t\tbreak;\n\tcase CS_ETM_PROTO_ETMV4i:\n\t\tcsid = (t_params->etmv4.reg_traceidr & CORESIGHT_TRACE_ID_VAL_MASK);\n\t\tcs_etm_decoder__gen_etmv4_config(t_params, &trace_config_etmv4);\n\t\tdecoder->decoder_name = OCSD_BUILTIN_DCD_ETMV4I;\n\t\ttrace_config = &trace_config_etmv4;\n\t\tbreak;\n\tcase CS_ETM_PROTO_ETE:\n\t\tcsid = (t_params->ete.reg_traceidr & CORESIGHT_TRACE_ID_VAL_MASK);\n\t\tcs_etm_decoder__gen_ete_config(t_params, &trace_config_ete);\n\t\tdecoder->decoder_name = OCSD_BUILTIN_DCD_ETE;\n\t\ttrace_config = &trace_config_ete;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\t \n\tif (csid == CORESIGHT_TRACE_ID_UNUSED_VAL)\n\t\treturn 0;\n\n\tif (d_params->operation == CS_ETM_OPERATION_DECODE) {\n\t\tif (ocsd_dt_create_decoder(decoder->dcd_tree,\n\t\t\t\t\t   decoder->decoder_name,\n\t\t\t\t\t   OCSD_CREATE_FLG_FULL_DECODER,\n\t\t\t\t\t   trace_config, &csid))\n\t\t\treturn -1;\n\n\t\tif (ocsd_dt_set_gen_elem_outfn(decoder->dcd_tree,\n\t\t\t\t\t       cs_etm_decoder__gen_trace_elem_printer,\n\t\t\t\t\t       decoder))\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t} else if (d_params->operation == CS_ETM_OPERATION_PRINT) {\n\t\tif (ocsd_dt_create_decoder(decoder->dcd_tree, decoder->decoder_name,\n\t\t\t\t\t   OCSD_CREATE_FLG_PACKET_PROC,\n\t\t\t\t\t   trace_config, &csid))\n\t\t\treturn -1;\n\n\t\tif (ocsd_dt_set_pkt_protocol_printer(decoder->dcd_tree, csid, 0))\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstruct cs_etm_decoder *\ncs_etm_decoder__new(int decoders, struct cs_etm_decoder_params *d_params,\n\t\t    struct cs_etm_trace_params t_params[])\n{\n\tstruct cs_etm_decoder *decoder;\n\tocsd_dcd_tree_src_t format;\n\tu32 flags;\n\tint i, ret;\n\n\tif ((!t_params) || (!d_params))\n\t\treturn NULL;\n\n\tdecoder = zalloc(sizeof(*decoder));\n\n\tif (!decoder)\n\t\treturn NULL;\n\n\tdecoder->data = d_params->data;\n\tdecoder->prev_return = OCSD_RESP_CONT;\n\tformat = (d_params->formatted ? OCSD_TRC_SRC_FRAME_FORMATTED :\n\t\t\t\t\t OCSD_TRC_SRC_SINGLE);\n\tflags = 0;\n\tflags |= (d_params->fsyncs ? OCSD_DFRMTR_HAS_FSYNCS : 0);\n\tflags |= (d_params->hsyncs ? OCSD_DFRMTR_HAS_HSYNCS : 0);\n\tflags |= (d_params->frame_aligned ? OCSD_DFRMTR_FRAME_MEM_ALIGN : 0);\n\n\t \n\tflags |= OCSD_DFRMTR_RESET_ON_4X_FSYNC;\n\n\t \n\tdecoder->dcd_tree = ocsd_create_dcd_tree(format, flags);\n\n\tif (decoder->dcd_tree == 0)\n\t\tgoto err_free_decoder;\n\n\t \n\tret = cs_etm_decoder__init_def_logger_printing(d_params, decoder);\n\tif (ret != 0)\n\t\tgoto err_free_decoder;\n\n\t \n\tcs_etm_decoder__init_raw_frame_logging(d_params, decoder);\n\n\tfor (i = 0; i < decoders; i++) {\n\t\tret = cs_etm_decoder__create_etm_decoder(d_params,\n\t\t\t\t\t\t\t &t_params[i],\n\t\t\t\t\t\t\t decoder);\n\t\tif (ret != 0)\n\t\t\tgoto err_free_decoder;\n\t}\n\n\treturn decoder;\n\nerr_free_decoder:\n\tcs_etm_decoder__free(decoder);\n\treturn NULL;\n}\n\nint cs_etm_decoder__process_data_block(struct cs_etm_decoder *decoder,\n\t\t\t\t       u64 indx, const u8 *buf,\n\t\t\t\t       size_t len, size_t *consumed)\n{\n\tint ret = 0;\n\tocsd_datapath_resp_t cur = OCSD_RESP_CONT;\n\tocsd_datapath_resp_t prev_return = decoder->prev_return;\n\tsize_t processed = 0;\n\tu32 count;\n\n\twhile (processed < len) {\n\t\tif (OCSD_DATA_RESP_IS_WAIT(prev_return)) {\n\t\t\tcur = ocsd_dt_process_data(decoder->dcd_tree,\n\t\t\t\t\t\t   OCSD_OP_FLUSH,\n\t\t\t\t\t\t   0,\n\t\t\t\t\t\t   0,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   NULL);\n\t\t} else if (OCSD_DATA_RESP_IS_CONT(prev_return)) {\n\t\t\tcur = ocsd_dt_process_data(decoder->dcd_tree,\n\t\t\t\t\t\t   OCSD_OP_DATA,\n\t\t\t\t\t\t   indx + processed,\n\t\t\t\t\t\t   len - processed,\n\t\t\t\t\t\t   &buf[processed],\n\t\t\t\t\t\t   &count);\n\t\t\tprocessed += count;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (OCSD_DATA_RESP_IS_WAIT(cur))\n\t\t\tbreak;\n\n\t\tprev_return = cur;\n\t}\n\n\tdecoder->prev_return = cur;\n\t*consumed = processed;\n\n\treturn ret;\n}\n\nvoid cs_etm_decoder__free(struct cs_etm_decoder *decoder)\n{\n\tif (!decoder)\n\t\treturn;\n\n\tocsd_destroy_dcd_tree(decoder->dcd_tree);\n\tdecoder->dcd_tree = NULL;\n\tfree(decoder);\n}\n\nconst char *cs_etm_decoder__get_name(struct cs_etm_decoder *decoder)\n{\n\treturn decoder->decoder_name;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}