{
  "module_name": "lzma.c",
  "hash_id": "51188dc8a9eee7e2253d65b11329215e8faf1eb8fadc3c128e7869d62829b84c",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/lzma.c",
  "human_readable_source": "\n#include <errno.h>\n#include <lzma.h>\n#include <stdio.h>\n#include <linux/compiler.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"compress.h\"\n#include \"debug.h\"\n#include <string.h>\n#include <unistd.h>\n#include <internal/lib.h>\n\n#define BUFSIZE 8192\n\nstatic const char *lzma_strerror(lzma_ret ret)\n{\n\tswitch ((int) ret) {\n\tcase LZMA_MEM_ERROR:\n\t\treturn \"Memory allocation failed\";\n\tcase LZMA_OPTIONS_ERROR:\n\t\treturn \"Unsupported decompressor flags\";\n\tcase LZMA_FORMAT_ERROR:\n\t\treturn \"The input is not in the .xz format\";\n\tcase LZMA_DATA_ERROR:\n\t\treturn \"Compressed file is corrupt\";\n\tcase LZMA_BUF_ERROR:\n\t\treturn \"Compressed file is truncated or otherwise corrupt\";\n\tdefault:\n\t\treturn \"Unknown error, possibly a bug\";\n\t}\n}\n\nint lzma_decompress_to_file(const char *input, int output_fd)\n{\n\tlzma_action action = LZMA_RUN;\n\tlzma_stream strm   = LZMA_STREAM_INIT;\n\tlzma_ret ret;\n\tint err = -1;\n\n\tu8 buf_in[BUFSIZE];\n\tu8 buf_out[BUFSIZE];\n\tFILE *infile;\n\n\tinfile = fopen(input, \"rb\");\n\tif (!infile) {\n\t\tpr_debug(\"lzma: fopen failed on %s: '%s'\\n\", input, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tret = lzma_stream_decoder(&strm, UINT64_MAX, LZMA_CONCATENATED);\n\tif (ret != LZMA_OK) {\n\t\tpr_debug(\"lzma: lzma_stream_decoder failed %s (%d)\\n\", lzma_strerror(ret), ret);\n\t\tgoto err_fclose;\n\t}\n\n\tstrm.next_in   = NULL;\n\tstrm.avail_in  = 0;\n\tstrm.next_out  = buf_out;\n\tstrm.avail_out = sizeof(buf_out);\n\n\twhile (1) {\n\t\tif (strm.avail_in == 0 && !feof(infile)) {\n\t\t\tstrm.next_in  = buf_in;\n\t\t\tstrm.avail_in = fread(buf_in, 1, sizeof(buf_in), infile);\n\n\t\t\tif (ferror(infile)) {\n\t\t\t\tpr_debug(\"lzma: read error: %s\\n\", strerror(errno));\n\t\t\t\tgoto err_lzma_end;\n\t\t\t}\n\n\t\t\tif (feof(infile))\n\t\t\t\taction = LZMA_FINISH;\n\t\t}\n\n\t\tret = lzma_code(&strm, action);\n\n\t\tif (strm.avail_out == 0 || ret == LZMA_STREAM_END) {\n\t\t\tssize_t write_size = sizeof(buf_out) - strm.avail_out;\n\n\t\t\tif (writen(output_fd, buf_out, write_size) != write_size) {\n\t\t\t\tpr_debug(\"lzma: write error: %s\\n\", strerror(errno));\n\t\t\t\tgoto err_lzma_end;\n\t\t\t}\n\n\t\t\tstrm.next_out  = buf_out;\n\t\t\tstrm.avail_out = sizeof(buf_out);\n\t\t}\n\n\t\tif (ret != LZMA_OK) {\n\t\t\tif (ret == LZMA_STREAM_END)\n\t\t\t\tbreak;\n\n\t\t\tpr_debug(\"lzma: failed %s\\n\", lzma_strerror(ret));\n\t\t\tgoto err_lzma_end;\n\t\t}\n\t}\n\n\terr = 0;\nerr_lzma_end:\n\tlzma_end(&strm);\nerr_fclose:\n\tfclose(infile);\n\treturn err;\n}\n\nbool lzma_is_compressed(const char *input)\n{\n\tint fd = open(input, O_RDONLY);\n\tconst uint8_t magic[6] = { 0xFD, '7', 'z', 'X', 'Z', 0x00 };\n\tchar buf[6] = { 0 };\n\tssize_t rc;\n\n\tif (fd < 0)\n\t\treturn -1;\n\n\trc = read(fd, buf, sizeof(buf));\n\tclose(fd);\n\treturn rc == sizeof(buf) ?\n\t       memcmp(buf, magic, sizeof(buf)) == 0 : false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}