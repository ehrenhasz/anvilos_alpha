{
  "module_name": "bpf_lock_contention.c",
  "hash_id": "395635f776083f193aa9d67326aa7f0c1c87ff907770540f741e52786c95601e",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/bpf_lock_contention.c",
  "human_readable_source": "\n#include \"util/debug.h\"\n#include \"util/evlist.h\"\n#include \"util/machine.h\"\n#include \"util/map.h\"\n#include \"util/symbol.h\"\n#include \"util/target.h\"\n#include \"util/thread.h\"\n#include \"util/thread_map.h\"\n#include \"util/lock-contention.h\"\n#include <linux/zalloc.h>\n#include <linux/string.h>\n#include <bpf/bpf.h>\n\n#include \"bpf_skel/lock_contention.skel.h\"\n#include \"bpf_skel/lock_data.h\"\n\nstatic struct lock_contention_bpf *skel;\n\nint lock_contention_prepare(struct lock_contention *con)\n{\n\tint i, fd;\n\tint ncpus = 1, ntasks = 1, ntypes = 1, naddrs = 1;\n\tstruct evlist *evlist = con->evlist;\n\tstruct target *target = con->target;\n\n\tskel = lock_contention_bpf__open();\n\tif (!skel) {\n\t\tpr_err(\"Failed to open lock-contention BPF skeleton\\n\");\n\t\treturn -1;\n\t}\n\n\tbpf_map__set_value_size(skel->maps.stacks, con->max_stack * sizeof(u64));\n\tbpf_map__set_max_entries(skel->maps.lock_stat, con->map_nr_entries);\n\tbpf_map__set_max_entries(skel->maps.tstamp, con->map_nr_entries);\n\n\tif (con->aggr_mode == LOCK_AGGR_TASK)\n\t\tbpf_map__set_max_entries(skel->maps.task_data, con->map_nr_entries);\n\telse\n\t\tbpf_map__set_max_entries(skel->maps.task_data, 1);\n\n\tif (con->save_callstack)\n\t\tbpf_map__set_max_entries(skel->maps.stacks, con->map_nr_entries);\n\telse\n\t\tbpf_map__set_max_entries(skel->maps.stacks, 1);\n\n\tif (target__has_cpu(target))\n\t\tncpus = perf_cpu_map__nr(evlist->core.user_requested_cpus);\n\tif (target__has_task(target))\n\t\tntasks = perf_thread_map__nr(evlist->core.threads);\n\tif (con->filters->nr_types)\n\t\tntypes = con->filters->nr_types;\n\n\t \n\tif (con->filters->nr_syms) {\n\t\tstruct symbol *sym;\n\t\tstruct map *kmap;\n\t\tunsigned long *addrs;\n\n\t\tfor (i = 0; i < con->filters->nr_syms; i++) {\n\t\t\tsym = machine__find_kernel_symbol_by_name(con->machine,\n\t\t\t\t\t\t\t\t  con->filters->syms[i],\n\t\t\t\t\t\t\t\t  &kmap);\n\t\t\tif (sym == NULL) {\n\t\t\t\tpr_warning(\"ignore unknown symbol: %s\\n\",\n\t\t\t\t\t   con->filters->syms[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taddrs = realloc(con->filters->addrs,\n\t\t\t\t\t(con->filters->nr_addrs + 1) * sizeof(*addrs));\n\t\t\tif (addrs == NULL) {\n\t\t\t\tpr_warning(\"memory allocation failure\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taddrs[con->filters->nr_addrs++] = map__unmap_ip(kmap, sym->start);\n\t\t\tcon->filters->addrs = addrs;\n\t\t}\n\t\tnaddrs = con->filters->nr_addrs;\n\t}\n\n\tbpf_map__set_max_entries(skel->maps.cpu_filter, ncpus);\n\tbpf_map__set_max_entries(skel->maps.task_filter, ntasks);\n\tbpf_map__set_max_entries(skel->maps.type_filter, ntypes);\n\tbpf_map__set_max_entries(skel->maps.addr_filter, naddrs);\n\n\tif (lock_contention_bpf__load(skel) < 0) {\n\t\tpr_err(\"Failed to load lock-contention BPF skeleton\\n\");\n\t\treturn -1;\n\t}\n\n\tif (target__has_cpu(target)) {\n\t\tu32 cpu;\n\t\tu8 val = 1;\n\n\t\tskel->bss->has_cpu = 1;\n\t\tfd = bpf_map__fd(skel->maps.cpu_filter);\n\n\t\tfor (i = 0; i < ncpus; i++) {\n\t\t\tcpu = perf_cpu_map__cpu(evlist->core.user_requested_cpus, i).cpu;\n\t\t\tbpf_map_update_elem(fd, &cpu, &val, BPF_ANY);\n\t\t}\n\t}\n\n\tif (target__has_task(target)) {\n\t\tu32 pid;\n\t\tu8 val = 1;\n\n\t\tskel->bss->has_task = 1;\n\t\tfd = bpf_map__fd(skel->maps.task_filter);\n\n\t\tfor (i = 0; i < ntasks; i++) {\n\t\t\tpid = perf_thread_map__pid(evlist->core.threads, i);\n\t\t\tbpf_map_update_elem(fd, &pid, &val, BPF_ANY);\n\t\t}\n\t}\n\n\tif (target__none(target) && evlist->workload.pid > 0) {\n\t\tu32 pid = evlist->workload.pid;\n\t\tu8 val = 1;\n\n\t\tskel->bss->has_task = 1;\n\t\tfd = bpf_map__fd(skel->maps.task_filter);\n\t\tbpf_map_update_elem(fd, &pid, &val, BPF_ANY);\n\t}\n\n\tif (con->filters->nr_types) {\n\t\tu8 val = 1;\n\n\t\tskel->bss->has_type = 1;\n\t\tfd = bpf_map__fd(skel->maps.type_filter);\n\n\t\tfor (i = 0; i < con->filters->nr_types; i++)\n\t\t\tbpf_map_update_elem(fd, &con->filters->types[i], &val, BPF_ANY);\n\t}\n\n\tif (con->filters->nr_addrs) {\n\t\tu8 val = 1;\n\n\t\tskel->bss->has_addr = 1;\n\t\tfd = bpf_map__fd(skel->maps.addr_filter);\n\n\t\tfor (i = 0; i < con->filters->nr_addrs; i++)\n\t\t\tbpf_map_update_elem(fd, &con->filters->addrs[i], &val, BPF_ANY);\n\t}\n\n\t \n\tskel->bss->stack_skip = con->stack_skip;\n\tskel->bss->aggr_mode = con->aggr_mode;\n\tskel->bss->needs_callstack = con->save_callstack;\n\tskel->bss->lock_owner = con->owner;\n\n\tbpf_program__set_autoload(skel->progs.collect_lock_syms, false);\n\n\tlock_contention_bpf__attach(skel);\n\treturn 0;\n}\n\nint lock_contention_start(void)\n{\n\tskel->bss->enabled = 1;\n\treturn 0;\n}\n\nint lock_contention_stop(void)\n{\n\tskel->bss->enabled = 0;\n\treturn 0;\n}\n\nstatic const char *lock_contention_get_name(struct lock_contention *con,\n\t\t\t\t\t    struct contention_key *key,\n\t\t\t\t\t    u64 *stack_trace, u32 flags)\n{\n\tint idx = 0;\n\tu64 addr;\n\tconst char *name = \"\";\n\tstatic char name_buf[KSYM_NAME_LEN];\n\tstruct symbol *sym;\n\tstruct map *kmap;\n\tstruct machine *machine = con->machine;\n\n\tif (con->aggr_mode == LOCK_AGGR_TASK) {\n\t\tstruct contention_task_data task;\n\t\tint pid = key->pid;\n\t\tint task_fd = bpf_map__fd(skel->maps.task_data);\n\n\t\t \n\t\tif (pid) {\n\t\t\tstruct thread *t = __machine__findnew_thread(machine,  -1, pid);\n\n\t\t\tif (t == NULL)\n\t\t\t\treturn name;\n\t\t\tif (!bpf_map_lookup_elem(task_fd, &pid, &task) &&\n\t\t\t    thread__set_comm(t, task.comm,  0))\n\t\t\t\tname = task.comm;\n\t\t}\n\t\treturn name;\n\t}\n\n\tif (con->aggr_mode == LOCK_AGGR_ADDR) {\n\t\tint lock_fd = bpf_map__fd(skel->maps.lock_syms);\n\n\t\t \n\t\tif (flags & LCD_F_MMAP_LOCK)\n\t\t\treturn \"mmap_lock\";\n\t\tif (flags & LCD_F_SIGHAND_LOCK)\n\t\t\treturn \"siglock\";\n\n\t\t \n\t\tsym = machine__find_kernel_symbol(machine, key->lock_addr, &kmap);\n\t\tif (sym)\n\t\t\treturn sym->name;\n\n\t\t \n\t\tif (!bpf_map_lookup_elem(lock_fd, &key->lock_addr, &flags)) {\n\t\t\tif (flags == LOCK_CLASS_RQLOCK)\n\t\t\t\treturn \"rq_lock\";\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\t \n\twhile (machine__is_lock_function(machine, stack_trace[idx]) &&\n\t       idx < con->max_stack - 1)\n\t\tidx++;\n\n\taddr = stack_trace[idx];\n\tsym = machine__find_kernel_symbol(machine, addr, &kmap);\n\n\tif (sym) {\n\t\tunsigned long offset;\n\n\t\toffset = map__map_ip(kmap, addr) - sym->start;\n\n\t\tif (offset == 0)\n\t\t\treturn sym->name;\n\n\t\tsnprintf(name_buf, sizeof(name_buf), \"%s+%#lx\", sym->name, offset);\n\t} else {\n\t\tsnprintf(name_buf, sizeof(name_buf), \"%#lx\", (unsigned long)addr);\n\t}\n\n\treturn name_buf;\n}\n\nint lock_contention_read(struct lock_contention *con)\n{\n\tint fd, stack, err = 0;\n\tstruct contention_key *prev_key, key = {};\n\tstruct contention_data data = {};\n\tstruct lock_stat *st = NULL;\n\tstruct machine *machine = con->machine;\n\tu64 *stack_trace;\n\tsize_t stack_size = con->max_stack * sizeof(*stack_trace);\n\n\tfd = bpf_map__fd(skel->maps.lock_stat);\n\tstack = bpf_map__fd(skel->maps.stacks);\n\n\tcon->fails.task = skel->bss->task_fail;\n\tcon->fails.stack = skel->bss->stack_fail;\n\tcon->fails.time = skel->bss->time_fail;\n\tcon->fails.data = skel->bss->data_fail;\n\n\tstack_trace = zalloc(stack_size);\n\tif (stack_trace == NULL)\n\t\treturn -1;\n\n\tif (con->aggr_mode == LOCK_AGGR_TASK) {\n\t\tstruct thread *idle = __machine__findnew_thread(machine,\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t 0);\n\t\tthread__set_comm(idle, \"swapper\",  0);\n\t}\n\n\tif (con->aggr_mode == LOCK_AGGR_ADDR) {\n\t\tDECLARE_LIBBPF_OPTS(bpf_test_run_opts, opts,\n\t\t\t.flags = BPF_F_TEST_RUN_ON_CPU,\n\t\t);\n\t\tint prog_fd = bpf_program__fd(skel->progs.collect_lock_syms);\n\n\t\tbpf_prog_test_run_opts(prog_fd, &opts);\n\t}\n\n\t \n\tmap__load(maps__first(machine->kmaps)->map);\n\n\tprev_key = NULL;\n\twhile (!bpf_map_get_next_key(fd, prev_key, &key)) {\n\t\ts64 ls_key;\n\t\tconst char *name;\n\n\t\t \n\t\terr = -1;\n\n\t\tbpf_map_lookup_elem(fd, &key, &data);\n\t\tif (con->save_callstack) {\n\t\t\tbpf_map_lookup_elem(stack, &key.stack_id, stack_trace);\n\n\t\t\tif (!match_callstack_filter(machine, stack_trace)) {\n\t\t\t\tcon->nr_filtered += data.count;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\tswitch (con->aggr_mode) {\n\t\tcase LOCK_AGGR_CALLER:\n\t\t\tls_key = key.stack_id;\n\t\t\tbreak;\n\t\tcase LOCK_AGGR_TASK:\n\t\t\tls_key = key.pid;\n\t\t\tbreak;\n\t\tcase LOCK_AGGR_ADDR:\n\t\t\tls_key = key.lock_addr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto next;\n\t\t}\n\n\t\tst = lock_stat_find(ls_key);\n\t\tif (st != NULL) {\n\t\t\tst->wait_time_total += data.total_time;\n\t\t\tif (st->wait_time_max < data.max_time)\n\t\t\t\tst->wait_time_max = data.max_time;\n\t\t\tif (st->wait_time_min > data.min_time)\n\t\t\t\tst->wait_time_min = data.min_time;\n\n\t\t\tst->nr_contended += data.count;\n\t\t\tif (st->nr_contended)\n\t\t\t\tst->avg_wait_time = st->wait_time_total / st->nr_contended;\n\t\t\tgoto next;\n\t\t}\n\n\t\tname = lock_contention_get_name(con, &key, stack_trace, data.flags);\n\t\tst = lock_stat_findnew(ls_key, name, data.flags);\n\t\tif (st == NULL)\n\t\t\tbreak;\n\n\t\tst->nr_contended = data.count;\n\t\tst->wait_time_total = data.total_time;\n\t\tst->wait_time_max = data.max_time;\n\t\tst->wait_time_min = data.min_time;\n\n\t\tif (data.count)\n\t\t\tst->avg_wait_time = data.total_time / data.count;\n\n\t\tif (con->aggr_mode == LOCK_AGGR_CALLER && verbose > 0) {\n\t\t\tst->callstack = memdup(stack_trace, stack_size);\n\t\t\tif (st->callstack == NULL)\n\t\t\t\tbreak;\n\t\t}\n\nnext:\n\t\tprev_key = &key;\n\n\t\t \n\t\terr = 0;\n\t}\n\n\tfree(stack_trace);\n\n\treturn err;\n}\n\nint lock_contention_finish(void)\n{\n\tif (skel) {\n\t\tskel->bss->enabled = 0;\n\t\tlock_contention_bpf__destroy(skel);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}