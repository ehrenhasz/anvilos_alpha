{
  "module_name": "pmu.c",
  "hash_id": "3e6983050bc8facaf66de76a95f251d7c09443167fb6b83201873bf5361648f9",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/pmu.c",
  "human_readable_source": "\n#include <linux/list.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <linux/ctype.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <dirent.h>\n#include <api/fs/fs.h>\n#include <locale.h>\n#include <fnmatch.h>\n#include <math.h>\n#include \"debug.h\"\n#include \"evsel.h\"\n#include \"pmu.h\"\n#include \"pmus.h\"\n#include <util/pmu-bison.h>\n#include <util/pmu-flex.h>\n#include \"parse-events.h\"\n#include \"print-events.h\"\n#include \"header.h\"\n#include \"string2.h\"\n#include \"strbuf.h\"\n#include \"fncache.h\"\n#include \"util/evsel_config.h\"\n\nstruct perf_pmu perf_pmu__fake = {\n\t.name = \"fake\",\n};\n\n#define UNIT_MAX_LEN\t31  \n\n \nstruct perf_pmu_alias {\n\t \n\tchar *name;\n\t \n\tchar *desc;\n\t \n\tchar *long_desc;\n\t \n\tchar *topic;\n\t \n\tstruct list_head terms;\n\t \n\tstruct list_head list;\n\t \n\tchar *pmu_name;\n\t \n\tchar unit[UNIT_MAX_LEN+1];\n\t \n\tdouble scale;\n\t \n\tbool per_pkg;\n\t \n\tbool snapshot;\n\t \n\tbool deprecated;\n\t \n\tbool from_sysfs;\n\t \n\tbool info_loaded;\n};\n\n \nstruct perf_pmu_format {\n\t \n\tstruct list_head list;\n\t \n\tDECLARE_BITMAP(bits, PERF_PMU_FORMAT_BITS);\n\t \n\tchar *name;\n\t \n\tu16 value;\n\t \n\tbool loaded;\n};\n\nstatic int pmu_aliases_parse(struct perf_pmu *pmu);\n\nstatic struct perf_pmu_format *perf_pmu__new_format(struct list_head *list, char *name)\n{\n\tstruct perf_pmu_format *format;\n\n\tformat = zalloc(sizeof(*format));\n\tif (!format)\n\t\treturn NULL;\n\n\tformat->name = strdup(name);\n\tif (!format->name) {\n\t\tfree(format);\n\t\treturn NULL;\n\t}\n\tlist_add_tail(&format->list, list);\n\treturn format;\n}\n\n \nvoid perf_pmu_format__set_value(void *vformat, int config, unsigned long *bits)\n{\n\tstruct perf_pmu_format *format = vformat;\n\n\tformat->value = config;\n\tmemcpy(format->bits, bits, sizeof(format->bits));\n}\n\nstatic void __perf_pmu_format__load(struct perf_pmu_format *format, FILE *file)\n{\n\tvoid *scanner;\n\tint ret;\n\n\tret = perf_pmu_lex_init(&scanner);\n\tif (ret)\n\t\treturn;\n\n\tperf_pmu_set_in(file, scanner);\n\tret = perf_pmu_parse(format, scanner);\n\tperf_pmu_lex_destroy(scanner);\n\tformat->loaded = true;\n}\n\nstatic void perf_pmu_format__load(struct perf_pmu *pmu, struct perf_pmu_format *format)\n{\n\tchar path[PATH_MAX];\n\tFILE *file = NULL;\n\n\tif (format->loaded)\n\t\treturn;\n\n\tif (!perf_pmu__pathname_scnprintf(path, sizeof(path), pmu->name, \"format\"))\n\t\treturn;\n\n\tassert(strlen(path) + strlen(format->name) + 2 < sizeof(path));\n\tstrcat(path, \"/\");\n\tstrcat(path, format->name);\n\n\tfile = fopen(path, \"r\");\n\tif (!file)\n\t\treturn;\n\t__perf_pmu_format__load(format, file);\n\tfclose(file);\n}\n\n \nint perf_pmu__format_parse(struct perf_pmu *pmu, int dirfd, bool eager_load)\n{\n\tstruct dirent *evt_ent;\n\tDIR *format_dir;\n\tint ret = 0;\n\n\tformat_dir = fdopendir(dirfd);\n\tif (!format_dir)\n\t\treturn -EINVAL;\n\n\twhile ((evt_ent = readdir(format_dir)) != NULL) {\n\t\tstruct perf_pmu_format *format;\n\t\tchar *name = evt_ent->d_name;\n\n\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\"))\n\t\t\tcontinue;\n\n\t\tformat = perf_pmu__new_format(&pmu->format, name);\n\t\tif (!format) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (eager_load) {\n\t\t\tFILE *file;\n\t\t\tint fd = openat(dirfd, name, O_RDONLY);\n\n\t\t\tif (fd < 0) {\n\t\t\t\tret = -errno;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfile = fdopen(fd, \"r\");\n\t\t\tif (!file) {\n\t\t\t\tclose(fd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__perf_pmu_format__load(format, file);\n\t\t\tfclose(file);\n\t\t}\n\t}\n\n\tclosedir(format_dir);\n\treturn ret;\n}\n\n \nstatic int pmu_format(struct perf_pmu *pmu, int dirfd, const char *name)\n{\n\tint fd;\n\n\tfd = perf_pmu__pathname_fd(dirfd, name, \"format\", O_DIRECTORY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\t \n\tif (perf_pmu__format_parse(pmu, fd,  false))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint perf_pmu__convert_scale(const char *scale, char **end, double *sval)\n{\n\tchar *lc;\n\tint ret = 0;\n\n\t \n\tlc = setlocale(LC_NUMERIC, NULL);\n\n\t \n\tlc = strdup(lc);\n\tif (!lc) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tsetlocale(LC_NUMERIC, \"C\");\n\n\t*sval = strtod(scale, end);\n\nout:\n\t \n\tsetlocale(LC_NUMERIC, lc);\n\tfree(lc);\n\treturn ret;\n}\n\nstatic int perf_pmu__parse_scale(struct perf_pmu *pmu, struct perf_pmu_alias *alias)\n{\n\tstruct stat st;\n\tssize_t sret;\n\tsize_t len;\n\tchar scale[128];\n\tint fd, ret = -1;\n\tchar path[PATH_MAX];\n\n\tlen = perf_pmu__event_source_devices_scnprintf(path, sizeof(path));\n\tif (!len)\n\t\treturn 0;\n\tscnprintf(path + len, sizeof(path) - len, \"%s/events/%s.scale\", pmu->name, alias->name);\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tif (fstat(fd, &st) < 0)\n\t\tgoto error;\n\n\tsret = read(fd, scale, sizeof(scale)-1);\n\tif (sret < 0)\n\t\tgoto error;\n\n\tif (scale[sret - 1] == '\\n')\n\t\tscale[sret - 1] = '\\0';\n\telse\n\t\tscale[sret] = '\\0';\n\n\tret = perf_pmu__convert_scale(scale, NULL, &alias->scale);\nerror:\n\tclose(fd);\n\treturn ret;\n}\n\nstatic int perf_pmu__parse_unit(struct perf_pmu *pmu, struct perf_pmu_alias *alias)\n{\n\tchar path[PATH_MAX];\n\tsize_t len;\n\tssize_t sret;\n\tint fd;\n\n\n\tlen = perf_pmu__event_source_devices_scnprintf(path, sizeof(path));\n\tif (!len)\n\t\treturn 0;\n\tscnprintf(path + len, sizeof(path) - len, \"%s/events/%s.unit\", pmu->name, alias->name);\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tsret = read(fd, alias->unit, UNIT_MAX_LEN);\n\tif (sret < 0)\n\t\tgoto error;\n\n\tclose(fd);\n\n\tif (alias->unit[sret - 1] == '\\n')\n\t\talias->unit[sret - 1] = '\\0';\n\telse\n\t\talias->unit[sret] = '\\0';\n\n\treturn 0;\nerror:\n\tclose(fd);\n\talias->unit[0] = '\\0';\n\treturn -1;\n}\n\nstatic int\nperf_pmu__parse_per_pkg(struct perf_pmu *pmu, struct perf_pmu_alias *alias)\n{\n\tchar path[PATH_MAX];\n\tsize_t len;\n\tint fd;\n\n\tlen = perf_pmu__event_source_devices_scnprintf(path, sizeof(path));\n\tif (!len)\n\t\treturn 0;\n\tscnprintf(path + len, sizeof(path) - len, \"%s/events/%s.per-pkg\", pmu->name, alias->name);\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tclose(fd);\n\n\talias->per_pkg = true;\n\treturn 0;\n}\n\nstatic int perf_pmu__parse_snapshot(struct perf_pmu *pmu, struct perf_pmu_alias *alias)\n{\n\tchar path[PATH_MAX];\n\tsize_t len;\n\tint fd;\n\n\tlen = perf_pmu__event_source_devices_scnprintf(path, sizeof(path));\n\tif (!len)\n\t\treturn 0;\n\tscnprintf(path + len, sizeof(path) - len, \"%s/events/%s.snapshot\", pmu->name, alias->name);\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn -1;\n\n\talias->snapshot = true;\n\tclose(fd);\n\treturn 0;\n}\n\n \nstatic void perf_pmu_free_alias(struct perf_pmu_alias *newalias)\n{\n\tzfree(&newalias->name);\n\tzfree(&newalias->desc);\n\tzfree(&newalias->long_desc);\n\tzfree(&newalias->topic);\n\tzfree(&newalias->pmu_name);\n\tparse_events_terms__purge(&newalias->terms);\n\tfree(newalias);\n}\n\nstatic void perf_pmu__del_aliases(struct perf_pmu *pmu)\n{\n\tstruct perf_pmu_alias *alias, *tmp;\n\n\tlist_for_each_entry_safe(alias, tmp, &pmu->aliases, list) {\n\t\tlist_del(&alias->list);\n\t\tperf_pmu_free_alias(alias);\n\t}\n}\n\nstatic struct perf_pmu_alias *perf_pmu__find_alias(struct perf_pmu *pmu,\n\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t   bool load)\n{\n\tstruct perf_pmu_alias *alias;\n\n\tif (load && !pmu->sysfs_aliases_loaded)\n\t\tpmu_aliases_parse(pmu);\n\n\tlist_for_each_entry(alias, &pmu->aliases, list) {\n\t\tif (!strcasecmp(alias->name, name))\n\t\t\treturn alias;\n\t}\n\treturn NULL;\n}\n\nstatic bool assign_str(const char *name, const char *field, char **old_str,\n\t\t\t\tconst char *new_str)\n{\n\tif (!*old_str && new_str) {\n\t\t*old_str = strdup(new_str);\n\t\treturn true;\n\t}\n\n\tif (!new_str || !strcasecmp(*old_str, new_str))\n\t\treturn false;  \n\n\tpr_debug(\"alias %s differs in field '%s' ('%s' != '%s')\\n\",\n\t\tname, field, *old_str, new_str);\n\tzfree(old_str);\n\t*old_str = strdup(new_str);\n\treturn true;\n}\n\nstatic void read_alias_info(struct perf_pmu *pmu, struct perf_pmu_alias *alias)\n{\n\tif (!alias->from_sysfs || alias->info_loaded)\n\t\treturn;\n\n\t \n\tperf_pmu__parse_unit(pmu, alias);\n\tperf_pmu__parse_scale(pmu, alias);\n\tperf_pmu__parse_per_pkg(pmu, alias);\n\tperf_pmu__parse_snapshot(pmu, alias);\n}\n\nstruct update_alias_data {\n\tstruct perf_pmu *pmu;\n\tstruct perf_pmu_alias *alias;\n};\n\nstatic int update_alias(const struct pmu_event *pe,\n\t\t\tconst struct pmu_events_table *table __maybe_unused,\n\t\t\tvoid *vdata)\n{\n\tstruct update_alias_data *data = vdata;\n\tint ret = 0;\n\n\tread_alias_info(data->pmu, data->alias);\n\tassign_str(pe->name, \"desc\", &data->alias->desc, pe->desc);\n\tassign_str(pe->name, \"long_desc\", &data->alias->long_desc, pe->long_desc);\n\tassign_str(pe->name, \"topic\", &data->alias->topic, pe->topic);\n\tdata->alias->per_pkg = pe->perpkg;\n\tif (pe->event) {\n\t\tparse_events_terms__purge(&data->alias->terms);\n\t\tret = parse_events_terms(&data->alias->terms, pe->event,  NULL);\n\t}\n\tif (!ret && pe->unit) {\n\t\tchar *unit;\n\n\t\tret = perf_pmu__convert_scale(pe->unit, &unit, &data->alias->scale);\n\t\tif (!ret)\n\t\t\tsnprintf(data->alias->unit, sizeof(data->alias->unit), \"%s\", unit);\n\t}\n\treturn ret;\n}\n\nstatic int perf_pmu__new_alias(struct perf_pmu *pmu, const char *name,\n\t\t\t\tconst char *desc, const char *val, FILE *val_fd,\n\t\t\t\tconst struct pmu_event *pe)\n{\n\tstruct perf_pmu_alias *alias;\n\tint ret;\n\tconst char *long_desc = NULL, *topic = NULL, *unit = NULL, *pmu_name = NULL;\n\tbool deprecated = false, perpkg = false;\n\n\tif (perf_pmu__find_alias(pmu, name,   false)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (pe) {\n\t\tlong_desc = pe->long_desc;\n\t\ttopic = pe->topic;\n\t\tunit = pe->unit;\n\t\tperpkg = pe->perpkg;\n\t\tdeprecated = pe->deprecated;\n\t\tpmu_name = pe->pmu;\n\t}\n\n\talias = zalloc(sizeof(*alias));\n\tif (!alias)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&alias->terms);\n\talias->scale = 1.0;\n\talias->unit[0] = '\\0';\n\talias->per_pkg = perpkg;\n\talias->snapshot = false;\n\talias->deprecated = deprecated;\n\n\tret = parse_events_terms(&alias->terms, val, val_fd);\n\tif (ret) {\n\t\tpr_err(\"Cannot parse alias %s: %d\\n\", val, ret);\n\t\tfree(alias);\n\t\treturn ret;\n\t}\n\n\talias->name = strdup(name);\n\talias->desc = desc ? strdup(desc) : NULL;\n\talias->long_desc = long_desc ? strdup(long_desc) :\n\t\t\t\tdesc ? strdup(desc) : NULL;\n\talias->topic = topic ? strdup(topic) : NULL;\n\talias->pmu_name = pmu_name ? strdup(pmu_name) : NULL;\n\tif (unit) {\n\t\tif (perf_pmu__convert_scale(unit, (char **)&unit, &alias->scale) < 0) {\n\t\t\tperf_pmu_free_alias(alias);\n\t\t\treturn -1;\n\t\t}\n\t\tsnprintf(alias->unit, sizeof(alias->unit), \"%s\", unit);\n\t}\n\tif (!pe) {\n\t\t \n\t\tstruct update_alias_data data = {\n\t\t\t.pmu = pmu,\n\t\t\t.alias = alias,\n\t\t};\n\n\t\talias->from_sysfs = true;\n\t\tif (pmu->events_table) {\n\t\t\tif (pmu_events_table__find_event(pmu->events_table, pmu, name,\n\t\t\t\t\t\t\t update_alias, &data) == 0)\n\t\t\t\tpmu->loaded_json_aliases++;\n\t\t}\n\t}\n\n\tif (!pe)\n\t\tpmu->sysfs_aliases++;\n\telse\n\t\tpmu->loaded_json_aliases++;\n\tlist_add_tail(&alias->list, &pmu->aliases);\n\treturn 0;\n}\n\nstatic inline bool pmu_alias_info_file(char *name)\n{\n\tsize_t len;\n\n\tlen = strlen(name);\n\tif (len > 5 && !strcmp(name + len - 5, \".unit\"))\n\t\treturn true;\n\tif (len > 6 && !strcmp(name + len - 6, \".scale\"))\n\t\treturn true;\n\tif (len > 8 && !strcmp(name + len - 8, \".per-pkg\"))\n\t\treturn true;\n\tif (len > 9 && !strcmp(name + len - 9, \".snapshot\"))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int pmu_aliases_parse(struct perf_pmu *pmu)\n{\n\tchar path[PATH_MAX];\n\tstruct dirent *evt_ent;\n\tDIR *event_dir;\n\tsize_t len;\n\tint fd, dir_fd;\n\n\tlen = perf_pmu__event_source_devices_scnprintf(path, sizeof(path));\n\tif (!len)\n\t\treturn 0;\n\tscnprintf(path + len, sizeof(path) - len, \"%s/events\", pmu->name);\n\n\tdir_fd = open(path, O_DIRECTORY);\n\tif (dir_fd == -1) {\n\t\tpmu->sysfs_aliases_loaded = true;\n\t\treturn 0;\n\t}\n\n\tevent_dir = fdopendir(dir_fd);\n\tif (!event_dir){\n\t\tclose (dir_fd);\n\t\treturn -EINVAL;\n\t}\n\n\twhile ((evt_ent = readdir(event_dir))) {\n\t\tchar *name = evt_ent->d_name;\n\t\tFILE *file;\n\n\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\"))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (pmu_alias_info_file(name))\n\t\t\tcontinue;\n\n\t\tfd = openat(dir_fd, name, O_RDONLY);\n\t\tif (fd == -1) {\n\t\t\tpr_debug(\"Cannot open %s\\n\", name);\n\t\t\tcontinue;\n\t\t}\n\t\tfile = fdopen(fd, \"r\");\n\t\tif (!file) {\n\t\t\tclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (perf_pmu__new_alias(pmu, name,   NULL,\n\t\t\t\t\t  NULL, file,   NULL) < 0)\n\t\t\tpr_debug(\"Cannot set up %s\\n\", name);\n\t\tfclose(file);\n\t}\n\n\tclosedir(event_dir);\n\tclose (dir_fd);\n\tpmu->sysfs_aliases_loaded = true;\n\treturn 0;\n}\n\nstatic int pmu_alias_terms(struct perf_pmu_alias *alias,\n\t\t\t   struct list_head *terms)\n{\n\tstruct parse_events_term *term, *cloned;\n\tLIST_HEAD(list);\n\tint ret;\n\n\tlist_for_each_entry(term, &alias->terms, list) {\n\t\tret = parse_events_term__clone(&cloned, term);\n\t\tif (ret) {\n\t\t\tparse_events_terms__purge(&list);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tcloned->weak = true;\n\t\tlist_add_tail(&cloned->list, &list);\n\t}\n\tlist_splice(&list, terms);\n\treturn 0;\n}\n\n \nstatic struct perf_cpu_map *pmu_cpumask(int dirfd, const char *name, bool is_core)\n{\n\tstruct perf_cpu_map *cpus;\n\tconst char *templates[] = {\n\t\t\"cpumask\",\n\t\t\"cpus\",\n\t\tNULL\n\t};\n\tconst char **template;\n\tchar pmu_name[PATH_MAX];\n\tstruct perf_pmu pmu = {.name = pmu_name};\n\tFILE *file;\n\n\tstrlcpy(pmu_name, name, sizeof(pmu_name));\n\tfor (template = templates; *template; template++) {\n\t\tfile = perf_pmu__open_file_at(&pmu, dirfd, *template);\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tcpus = perf_cpu_map__read(file);\n\t\tfclose(file);\n\t\tif (cpus)\n\t\t\treturn cpus;\n\t}\n\n\t \n\treturn is_core ? perf_cpu_map__get(cpu_map__online()) : NULL;\n}\n\nstatic bool pmu_is_uncore(int dirfd, const char *name)\n{\n\tint fd;\n\n\tfd = perf_pmu__pathname_fd(dirfd, name, \"cpumask\", O_PATH);\n\tif (fd < 0)\n\t\treturn false;\n\n\tclose(fd);\n\treturn true;\n}\n\nstatic char *pmu_id(const char *name)\n{\n\tchar path[PATH_MAX], *str;\n\tsize_t len;\n\n\tperf_pmu__pathname_scnprintf(path, sizeof(path), name, \"identifier\");\n\n\tif (filename__read_str(path, &str, &len) < 0)\n\t\treturn NULL;\n\n\tstr[len - 1] = 0;  \n\n\treturn str;\n}\n\n \nstatic int is_sysfs_pmu_core(const char *name)\n{\n\tchar path[PATH_MAX];\n\n\tif (!perf_pmu__pathname_scnprintf(path, sizeof(path), name, \"cpus\"))\n\t\treturn 0;\n\treturn file_available(path);\n}\n\nchar *perf_pmu__getcpuid(struct perf_pmu *pmu)\n{\n\tchar *cpuid;\n\tstatic bool printed;\n\n\tcpuid = getenv(\"PERF_CPUID\");\n\tif (cpuid)\n\t\tcpuid = strdup(cpuid);\n\tif (!cpuid)\n\t\tcpuid = get_cpuid_str(pmu);\n\tif (!cpuid)\n\t\treturn NULL;\n\n\tif (!printed) {\n\t\tpr_debug(\"Using CPUID %s\\n\", cpuid);\n\t\tprinted = true;\n\t}\n\treturn cpuid;\n}\n\n__weak const struct pmu_events_table *pmu_events_table__find(void)\n{\n\treturn perf_pmu__find_events_table(NULL);\n}\n\n__weak const struct pmu_metrics_table *pmu_metrics_table__find(void)\n{\n\treturn perf_pmu__find_metrics_table(NULL);\n}\n\n \nstatic bool perf_pmu__match_ignoring_suffix(const char *pmu_name, const char *tok)\n{\n\tconst char *p;\n\n\tif (strncmp(pmu_name, tok, strlen(tok)))\n\t\treturn false;\n\n\tp = pmu_name + strlen(tok);\n\tif (*p == 0)\n\t\treturn true;\n\n\tif (*p == '_')\n\t\t++p;\n\n\t \n\twhile (1) {\n\t\tif (!isdigit(*p))\n\t\t\treturn false;\n\t\tif (*(++p) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool pmu_uncore_alias_match(const char *pmu_name, const char *name)\n{\n\tchar *tmp = NULL, *tok, *str;\n\tbool res;\n\n\tif (strchr(pmu_name, ',') == NULL)\n\t\treturn perf_pmu__match_ignoring_suffix(name, pmu_name);\n\n\tstr = strdup(pmu_name);\n\tif (!str)\n\t\treturn false;\n\n\t \n\ttok = strtok_r(str, \",\", &tmp);\n\tif (strncmp(pmu_name, tok, strlen(tok))) {\n\t\tres = false;\n\t\tgoto out;\n\t}\n\n\t \n\twhile (1) {\n\t\tchar *next_tok = strtok_r(NULL, \",\", &tmp);\n\n\t\tname = strstr(name, tok);\n\t\tif (!name ||\n\t\t    (!next_tok && !perf_pmu__match_ignoring_suffix(name, tok))) {\n\t\t\tres = false;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!next_tok)\n\t\t\tbreak;\n\t\ttok = next_tok;\n\t\tname += strlen(tok);\n\t}\n\n\tres = true;\nout:\n\tfree(str);\n\treturn res;\n}\n\nstatic int pmu_add_cpu_aliases_map_callback(const struct pmu_event *pe,\n\t\t\t\t\tconst struct pmu_events_table *table __maybe_unused,\n\t\t\t\t\tvoid *vdata)\n{\n\tstruct perf_pmu *pmu = vdata;\n\n\tperf_pmu__new_alias(pmu, pe->name, pe->desc, pe->event,   NULL, pe);\n\treturn 0;\n}\n\n \nvoid pmu_add_cpu_aliases_table(struct perf_pmu *pmu, const struct pmu_events_table *table)\n{\n\tpmu_events_table__for_each_event(table, pmu, pmu_add_cpu_aliases_map_callback, pmu);\n}\n\nstatic void pmu_add_cpu_aliases(struct perf_pmu *pmu)\n{\n\tif (!pmu->events_table)\n\t\treturn;\n\n\tif (pmu->cpu_aliases_added)\n\t\treturn;\n\n\tpmu_add_cpu_aliases_table(pmu, pmu->events_table);\n\tpmu->cpu_aliases_added = true;\n}\n\nstatic int pmu_add_sys_aliases_iter_fn(const struct pmu_event *pe,\n\t\t\t\t       const struct pmu_events_table *table __maybe_unused,\n\t\t\t\t       void *vdata)\n{\n\tstruct perf_pmu *pmu = vdata;\n\n\tif (!pe->compat || !pe->pmu)\n\t\treturn 0;\n\n\tif (!strcmp(pmu->id, pe->compat) &&\n\t    pmu_uncore_alias_match(pe->pmu, pmu->name)) {\n\t\tperf_pmu__new_alias(pmu,\n\t\t\t\tpe->name,\n\t\t\t\tpe->desc,\n\t\t\t\tpe->event,\n\t\t\t\t  NULL,\n\t\t\t\tpe);\n\t}\n\n\treturn 0;\n}\n\nvoid pmu_add_sys_aliases(struct perf_pmu *pmu)\n{\n\tif (!pmu->id)\n\t\treturn;\n\n\tpmu_for_each_sys_event(pmu_add_sys_aliases_iter_fn, pmu);\n}\n\nstruct perf_event_attr * __weak\nperf_pmu__get_default_config(struct perf_pmu *pmu __maybe_unused)\n{\n\treturn NULL;\n}\n\nconst char * __weak\npmu_find_real_name(const char *name)\n{\n\treturn name;\n}\n\nconst char * __weak\npmu_find_alias_name(const char *name __maybe_unused)\n{\n\treturn NULL;\n}\n\nstatic int pmu_max_precise(int dirfd, struct perf_pmu *pmu)\n{\n\tint max_precise = -1;\n\n\tperf_pmu__scan_file_at(pmu, dirfd, \"caps/max_precise\", \"%d\", &max_precise);\n\treturn max_precise;\n}\n\nstruct perf_pmu *perf_pmu__lookup(struct list_head *pmus, int dirfd, const char *lookup_name)\n{\n\tstruct perf_pmu *pmu;\n\t__u32 type;\n\tconst char *name = pmu_find_real_name(lookup_name);\n\tconst char *alias_name;\n\n\tpmu = zalloc(sizeof(*pmu));\n\tif (!pmu)\n\t\treturn NULL;\n\n\tpmu->name = strdup(name);\n\tif (!pmu->name)\n\t\tgoto err;\n\n\t \n\tif (perf_pmu__scan_file_at(pmu, dirfd, \"type\", \"%u\", &type) != 1)\n\t\tgoto err;\n\n\tINIT_LIST_HEAD(&pmu->format);\n\tINIT_LIST_HEAD(&pmu->aliases);\n\tINIT_LIST_HEAD(&pmu->caps);\n\n\t \n\tif (pmu_format(pmu, dirfd, name)) {\n\t\tfree(pmu);\n\t\treturn NULL;\n\t}\n\tpmu->is_core = is_pmu_core(name);\n\tpmu->cpus = pmu_cpumask(dirfd, name, pmu->is_core);\n\n\talias_name = pmu_find_alias_name(name);\n\tif (alias_name) {\n\t\tpmu->alias_name = strdup(alias_name);\n\t\tif (!pmu->alias_name)\n\t\t\tgoto err;\n\t}\n\n\tpmu->type = type;\n\tpmu->is_uncore = pmu_is_uncore(dirfd, name);\n\tif (pmu->is_uncore)\n\t\tpmu->id = pmu_id(name);\n\tpmu->max_precise = pmu_max_precise(dirfd, pmu);\n\tpmu->events_table = perf_pmu__find_events_table(pmu);\n\tpmu_add_sys_aliases(pmu);\n\tlist_add_tail(&pmu->list, pmus);\n\n\tpmu->default_config = perf_pmu__get_default_config(pmu);\n\n\treturn pmu;\nerr:\n\tzfree(&pmu->name);\n\tfree(pmu);\n\treturn NULL;\n}\n\n \nstruct perf_pmu *perf_pmu__create_placeholder_core_pmu(struct list_head *core_pmus)\n{\n\tstruct perf_pmu *pmu = zalloc(sizeof(*pmu));\n\n\tif (!pmu)\n\t\treturn NULL;\n\n\tpmu->name = strdup(\"cpu\");\n\tif (!pmu->name) {\n\t\tfree(pmu);\n\t\treturn NULL;\n\t}\n\n\tpmu->is_core = true;\n\tpmu->type = PERF_TYPE_RAW;\n\tpmu->cpus = cpu_map__online();\n\n\tINIT_LIST_HEAD(&pmu->format);\n\tINIT_LIST_HEAD(&pmu->aliases);\n\tINIT_LIST_HEAD(&pmu->caps);\n\tlist_add_tail(&pmu->list, core_pmus);\n\treturn pmu;\n}\n\nvoid perf_pmu__warn_invalid_formats(struct perf_pmu *pmu)\n{\n\tstruct perf_pmu_format *format;\n\n\tif (pmu->formats_checked)\n\t\treturn;\n\n\tpmu->formats_checked = true;\n\n\t \n\tif (pmu == &perf_pmu__fake)\n\t\treturn;\n\n\tlist_for_each_entry(format, &pmu->format, list) {\n\t\tperf_pmu_format__load(pmu, format);\n\t\tif (format->value >= PERF_PMU_FORMAT_VALUE_CONFIG_END) {\n\t\t\tpr_warning(\"WARNING: '%s' format '%s' requires 'perf_event_attr::config%d'\"\n\t\t\t\t   \"which is not supported by this version of perf!\\n\",\n\t\t\t\t   pmu->name, format->name, format->value);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nbool evsel__is_aux_event(const struct evsel *evsel)\n{\n\tstruct perf_pmu *pmu = evsel__find_pmu(evsel);\n\n\treturn pmu && pmu->auxtrace;\n}\n\n \n#define field_prep(_mask, _val) (((_val) << (ffsll(_mask) - 1)) & (_mask))\nvoid evsel__set_config_if_unset(struct perf_pmu *pmu, struct evsel *evsel,\n\t\t\t\tconst char *config_name, u64 val)\n{\n\tu64 user_bits = 0, bits;\n\tstruct evsel_config_term *term = evsel__get_config_term(evsel, CFG_CHG);\n\n\tif (term)\n\t\tuser_bits = term->val.cfg_chg;\n\n\tbits = perf_pmu__format_bits(pmu, config_name);\n\n\t \n\tif (bits & user_bits)\n\t\treturn;\n\n\t \n\tevsel->core.attr.config &= ~bits;\n\tevsel->core.attr.config |= field_prep(bits, val);\n}\n\nstatic struct perf_pmu_format *\npmu_find_format(struct list_head *formats, const char *name)\n{\n\tstruct perf_pmu_format *format;\n\n\tlist_for_each_entry(format, formats, list)\n\t\tif (!strcmp(format->name, name))\n\t\t\treturn format;\n\n\treturn NULL;\n}\n\n__u64 perf_pmu__format_bits(struct perf_pmu *pmu, const char *name)\n{\n\tstruct perf_pmu_format *format = pmu_find_format(&pmu->format, name);\n\t__u64 bits = 0;\n\tint fbit;\n\n\tif (!format)\n\t\treturn 0;\n\n\tfor_each_set_bit(fbit, format->bits, PERF_PMU_FORMAT_BITS)\n\t\tbits |= 1ULL << fbit;\n\n\treturn bits;\n}\n\nint perf_pmu__format_type(struct perf_pmu *pmu, const char *name)\n{\n\tstruct perf_pmu_format *format = pmu_find_format(&pmu->format, name);\n\n\tif (!format)\n\t\treturn -1;\n\n\tperf_pmu_format__load(pmu, format);\n\treturn format->value;\n}\n\n \nstatic void pmu_format_value(unsigned long *format, __u64 value, __u64 *v,\n\t\t\t     bool zero)\n{\n\tunsigned long fbit, vbit;\n\n\tfor (fbit = 0, vbit = 0; fbit < PERF_PMU_FORMAT_BITS; fbit++) {\n\n\t\tif (!test_bit(fbit, format))\n\t\t\tcontinue;\n\n\t\tif (value & (1llu << vbit++))\n\t\t\t*v |= (1llu << fbit);\n\t\telse if (zero)\n\t\t\t*v &= ~(1llu << fbit);\n\t}\n}\n\nstatic __u64 pmu_format_max_value(const unsigned long *format)\n{\n\tint w;\n\n\tw = bitmap_weight(format, PERF_PMU_FORMAT_BITS);\n\tif (!w)\n\t\treturn 0;\n\tif (w < 64)\n\t\treturn (1ULL << w) - 1;\n\treturn -1;\n}\n\n \nstatic int pmu_resolve_param_term(struct parse_events_term *term,\n\t\t\t\t  struct list_head *head_terms,\n\t\t\t\t  __u64 *value)\n{\n\tstruct parse_events_term *t;\n\n\tlist_for_each_entry(t, head_terms, list) {\n\t\tif (t->type_val == PARSE_EVENTS__TERM_TYPE_NUM &&\n\t\t    t->config && !strcmp(t->config, term->config)) {\n\t\t\tt->used = true;\n\t\t\t*value = t->val.num;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (verbose > 0)\n\t\tprintf(\"Required parameter '%s' not specified\\n\", term->config);\n\n\treturn -1;\n}\n\nstatic char *pmu_formats_string(struct list_head *formats)\n{\n\tstruct perf_pmu_format *format;\n\tchar *str = NULL;\n\tstruct strbuf buf = STRBUF_INIT;\n\tunsigned int i = 0;\n\n\tif (!formats)\n\t\treturn NULL;\n\n\t \n\tlist_for_each_entry(format, formats, list)\n\t\tif (strbuf_addf(&buf, i++ ? \",%s\" : \"%s\", format->name) < 0)\n\t\t\tgoto error;\n\n\tstr = strbuf_detach(&buf, NULL);\nerror:\n\tstrbuf_release(&buf);\n\n\treturn str;\n}\n\n \nstatic int pmu_config_term(struct perf_pmu *pmu,\n\t\t\t   struct perf_event_attr *attr,\n\t\t\t   struct parse_events_term *term,\n\t\t\t   struct list_head *head_terms,\n\t\t\t   bool zero, struct parse_events_error *err)\n{\n\tstruct perf_pmu_format *format;\n\t__u64 *vp;\n\t__u64 val, max_val;\n\n\t \n\tif (term->used)\n\t\treturn 0;\n\n\t \n\tif (parse_events__is_hardcoded_term(term))\n\t\treturn 0;\n\n\tformat = pmu_find_format(&pmu->format, term->config);\n\tif (!format) {\n\t\tchar *pmu_term = pmu_formats_string(&pmu->format);\n\t\tchar *unknown_term;\n\t\tchar *help_msg;\n\n\t\tif (asprintf(&unknown_term,\n\t\t\t\t\"unknown term '%s' for pmu '%s'\",\n\t\t\t\tterm->config, pmu->name) < 0)\n\t\t\tunknown_term = NULL;\n\t\thelp_msg = parse_events_formats_error_string(pmu_term);\n\t\tif (err) {\n\t\t\tparse_events_error__handle(err, term->err_term,\n\t\t\t\t\t\t   unknown_term,\n\t\t\t\t\t\t   help_msg);\n\t\t} else {\n\t\t\tpr_debug(\"%s (%s)\\n\", unknown_term, help_msg);\n\t\t\tfree(unknown_term);\n\t\t}\n\t\tfree(pmu_term);\n\t\treturn -EINVAL;\n\t}\n\tperf_pmu_format__load(pmu, format);\n\tswitch (format->value) {\n\tcase PERF_PMU_FORMAT_VALUE_CONFIG:\n\t\tvp = &attr->config;\n\t\tbreak;\n\tcase PERF_PMU_FORMAT_VALUE_CONFIG1:\n\t\tvp = &attr->config1;\n\t\tbreak;\n\tcase PERF_PMU_FORMAT_VALUE_CONFIG2:\n\t\tvp = &attr->config2;\n\t\tbreak;\n\tcase PERF_PMU_FORMAT_VALUE_CONFIG3:\n\t\tvp = &attr->config3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (term->type_val == PARSE_EVENTS__TERM_TYPE_NUM) {\n\t\tif (term->no_value &&\n\t\t    bitmap_weight(format->bits, PERF_PMU_FORMAT_BITS) > 1) {\n\t\t\tif (err) {\n\t\t\t\tparse_events_error__handle(err, term->err_val,\n\t\t\t\t\t   strdup(\"no value assigned for term\"),\n\t\t\t\t\t   NULL);\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = term->val.num;\n\t} else if (term->type_val == PARSE_EVENTS__TERM_TYPE_STR) {\n\t\tif (strcmp(term->val.str, \"?\")) {\n\t\t\tif (verbose > 0) {\n\t\t\t\tpr_info(\"Invalid sysfs entry %s=%s\\n\",\n\t\t\t\t\t\tterm->config, term->val.str);\n\t\t\t}\n\t\t\tif (err) {\n\t\t\t\tparse_events_error__handle(err, term->err_val,\n\t\t\t\t\tstrdup(\"expected numeric value\"),\n\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (pmu_resolve_param_term(term, head_terms, &val))\n\t\t\treturn -EINVAL;\n\t} else\n\t\treturn -EINVAL;\n\n\tmax_val = pmu_format_max_value(format->bits);\n\tif (val > max_val) {\n\t\tif (err) {\n\t\t\tchar *err_str;\n\n\t\t\tparse_events_error__handle(err, term->err_val,\n\t\t\t\tasprintf(&err_str,\n\t\t\t\t    \"value too big for format, maximum is %llu\",\n\t\t\t\t    (unsigned long long)max_val) < 0\n\t\t\t\t    ? strdup(\"value too big for format\")\n\t\t\t\t    : err_str,\n\t\t\t\t    NULL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t}\n\n\tpmu_format_value(format->bits, val, vp, zero);\n\treturn 0;\n}\n\nint perf_pmu__config_terms(struct perf_pmu *pmu,\n\t\t\t   struct perf_event_attr *attr,\n\t\t\t   struct list_head *head_terms,\n\t\t\t   bool zero, struct parse_events_error *err)\n{\n\tstruct parse_events_term *term;\n\n\tlist_for_each_entry(term, head_terms, list) {\n\t\tif (pmu_config_term(pmu, attr, term, head_terms, zero, err))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint perf_pmu__config(struct perf_pmu *pmu, struct perf_event_attr *attr,\n\t\t     struct list_head *head_terms,\n\t\t     struct parse_events_error *err)\n{\n\tbool zero = !!pmu->default_config;\n\n\treturn perf_pmu__config_terms(pmu, attr, head_terms, zero, err);\n}\n\nstatic struct perf_pmu_alias *pmu_find_alias(struct perf_pmu *pmu,\n\t\t\t\t\t     struct parse_events_term *term)\n{\n\tstruct perf_pmu_alias *alias;\n\tconst char *name;\n\n\tif (parse_events__is_hardcoded_term(term))\n\t\treturn NULL;\n\n\tif (term->type_val == PARSE_EVENTS__TERM_TYPE_NUM) {\n\t\tif (!term->no_value)\n\t\t\treturn NULL;\n\t\tif (pmu_find_format(&pmu->format, term->config))\n\t\t\treturn NULL;\n\t\tname = term->config;\n\n\t} else if (term->type_val == PARSE_EVENTS__TERM_TYPE_STR) {\n\t\tif (strcasecmp(term->config, \"event\"))\n\t\t\treturn NULL;\n\t\tname = term->val.str;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\talias = perf_pmu__find_alias(pmu, name,   true);\n\tif (alias || pmu->cpu_aliases_added)\n\t\treturn alias;\n\n\t \n\tif (pmu->events_table &&\n\t    pmu_events_table__find_event(pmu->events_table, pmu, name,\n\t\t\t\t         pmu_add_cpu_aliases_map_callback,\n\t\t\t\t         pmu) == 0) {\n\t\talias = perf_pmu__find_alias(pmu, name,   false);\n\t}\n\treturn alias;\n}\n\n\nstatic int check_info_data(struct perf_pmu *pmu,\n\t\t\t   struct perf_pmu_alias *alias,\n\t\t\t   struct perf_pmu_info *info,\n\t\t\t   struct parse_events_error *err,\n\t\t\t   int column)\n{\n\tread_alias_info(pmu, alias);\n\t \n\tif (info->unit && alias->unit[0]) {\n\t\tparse_events_error__handle(err, column,\n\t\t\t\t\tstrdup(\"Attempt to set event's unit twice\"),\n\t\t\t\t\tNULL);\n\t\treturn -EINVAL;\n\t}\n\tif (info->scale && alias->scale) {\n\t\tparse_events_error__handle(err, column,\n\t\t\t\t\tstrdup(\"Attempt to set event's scale twice\"),\n\t\t\t\t\tNULL);\n\t\treturn -EINVAL;\n\t}\n\tif (info->snapshot && alias->snapshot) {\n\t\tparse_events_error__handle(err, column,\n\t\t\t\t\tstrdup(\"Attempt to set event snapshot twice\"),\n\t\t\t\t\tNULL);\n\t\treturn -EINVAL;\n\t}\n\n\tif (alias->unit[0])\n\t\tinfo->unit = alias->unit;\n\n\tif (alias->scale)\n\t\tinfo->scale = alias->scale;\n\n\tif (alias->snapshot)\n\t\tinfo->snapshot = alias->snapshot;\n\n\treturn 0;\n}\n\n \nint perf_pmu__check_alias(struct perf_pmu *pmu, struct list_head *head_terms,\n\t\t\t  struct perf_pmu_info *info, struct parse_events_error *err)\n{\n\tstruct parse_events_term *term, *h;\n\tstruct perf_pmu_alias *alias;\n\tint ret;\n\n\tinfo->per_pkg = false;\n\n\t \n\tinfo->unit     = NULL;\n\tinfo->scale    = 0.0;\n\tinfo->snapshot = false;\n\n\tlist_for_each_entry_safe(term, h, head_terms, list) {\n\t\talias = pmu_find_alias(pmu, term);\n\t\tif (!alias)\n\t\t\tcontinue;\n\t\tret = pmu_alias_terms(alias, &term->list);\n\t\tif (ret) {\n\t\t\tparse_events_error__handle(err, term->err_term,\n\t\t\t\t\t\tstrdup(\"Failure to duplicate terms\"),\n\t\t\t\t\t\tNULL);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = check_info_data(pmu, alias, info, err, term->err_term);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (alias->per_pkg)\n\t\t\tinfo->per_pkg = true;\n\n\t\tlist_del_init(&term->list);\n\t\tparse_events_term__delete(term);\n\t}\n\n\t \n\tif (info->unit == NULL)\n\t\tinfo->unit   = \"\";\n\n\tif (info->scale == 0.0)\n\t\tinfo->scale  = 1.0;\n\n\treturn 0;\n}\n\nstruct find_event_args {\n\tconst char *event;\n\tvoid *state;\n\tpmu_event_callback cb;\n};\n\nstatic int find_event_callback(void *state, struct pmu_event_info *info)\n{\n\tstruct find_event_args *args = state;\n\n\tif (!strcmp(args->event, info->name))\n\t\treturn args->cb(args->state, info);\n\n\treturn 0;\n}\n\nint perf_pmu__find_event(struct perf_pmu *pmu, const char *event, void *state, pmu_event_callback cb)\n{\n\tstruct find_event_args args = {\n\t\t.event = event,\n\t\t.state = state,\n\t\t.cb = cb,\n\t};\n\n\t \n\treturn perf_pmu__for_each_event(pmu,   false,\n\t\t\t\t\t&args, find_event_callback);\n}\n\nstatic void perf_pmu__del_formats(struct list_head *formats)\n{\n\tstruct perf_pmu_format *fmt, *tmp;\n\n\tlist_for_each_entry_safe(fmt, tmp, formats, list) {\n\t\tlist_del(&fmt->list);\n\t\tzfree(&fmt->name);\n\t\tfree(fmt);\n\t}\n}\n\nbool perf_pmu__has_format(const struct perf_pmu *pmu, const char *name)\n{\n\tstruct perf_pmu_format *format;\n\n\tlist_for_each_entry(format, &pmu->format, list) {\n\t\tif (!strcmp(format->name, name))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool is_pmu_core(const char *name)\n{\n\treturn !strcmp(name, \"cpu\") || !strcmp(name, \"cpum_cf\") || is_sysfs_pmu_core(name);\n}\n\nbool perf_pmu__supports_legacy_cache(const struct perf_pmu *pmu)\n{\n\treturn pmu->is_core;\n}\n\nbool perf_pmu__auto_merge_stats(const struct perf_pmu *pmu)\n{\n\treturn !pmu->is_core || perf_pmus__num_core_pmus() == 1;\n}\n\nbool perf_pmu__have_event(struct perf_pmu *pmu, const char *name)\n{\n\tif (perf_pmu__find_alias(pmu, name,   true) != NULL)\n\t\treturn true;\n\tif (pmu->cpu_aliases_added || !pmu->events_table)\n\t\treturn false;\n\treturn pmu_events_table__find_event(pmu->events_table, pmu, name, NULL, NULL) == 0;\n}\n\nsize_t perf_pmu__num_events(struct perf_pmu *pmu)\n{\n\tsize_t nr;\n\n\tif (!pmu->sysfs_aliases_loaded)\n\t\tpmu_aliases_parse(pmu);\n\n\tnr = pmu->sysfs_aliases;\n\n\tif (pmu->cpu_aliases_added)\n\t\t nr += pmu->loaded_json_aliases;\n\telse if (pmu->events_table)\n\t\tnr += pmu_events_table__num_events(pmu->events_table, pmu) - pmu->loaded_json_aliases;\n\n\treturn pmu->selectable ? nr + 1 : nr;\n}\n\nstatic int sub_non_neg(int a, int b)\n{\n\tif (b > a)\n\t\treturn 0;\n\treturn a - b;\n}\n\nstatic char *format_alias(char *buf, int len, const struct perf_pmu *pmu,\n\t\t\t  const struct perf_pmu_alias *alias, bool skip_duplicate_pmus)\n{\n\tstruct parse_events_term *term;\n\tint pmu_name_len = skip_duplicate_pmus\n\t\t? pmu_name_len_no_suffix(pmu->name,  NULL)\n\t\t: (int)strlen(pmu->name);\n\tint used = snprintf(buf, len, \"%.*s/%s\", pmu_name_len, pmu->name, alias->name);\n\n\tlist_for_each_entry(term, &alias->terms, list) {\n\t\tif (term->type_val == PARSE_EVENTS__TERM_TYPE_STR)\n\t\t\tused += snprintf(buf + used, sub_non_neg(len, used),\n\t\t\t\t\t\",%s=%s\", term->config,\n\t\t\t\t\tterm->val.str);\n\t}\n\n\tif (sub_non_neg(len, used) > 0) {\n\t\tbuf[used] = '/';\n\t\tused++;\n\t}\n\tif (sub_non_neg(len, used) > 0) {\n\t\tbuf[used] = '\\0';\n\t\tused++;\n\t} else\n\t\tbuf[len - 1] = '\\0';\n\n\treturn buf;\n}\n\nint perf_pmu__for_each_event(struct perf_pmu *pmu, bool skip_duplicate_pmus,\n\t\t\t     void *state, pmu_event_callback cb)\n{\n\tchar buf[1024];\n\tstruct perf_pmu_alias *event;\n\tstruct pmu_event_info info = {\n\t\t.pmu = pmu,\n\t};\n\tint ret = 0;\n\tstruct strbuf sb;\n\n\tstrbuf_init(&sb,   0);\n\tpmu_add_cpu_aliases(pmu);\n\tlist_for_each_entry(event, &pmu->aliases, list) {\n\t\tsize_t buf_used;\n\n\t\tinfo.pmu_name = event->pmu_name ?: pmu->name;\n\t\tinfo.alias = NULL;\n\t\tif (event->desc) {\n\t\t\tinfo.name = event->name;\n\t\t\tbuf_used = 0;\n\t\t} else {\n\t\t\tinfo.name = format_alias(buf, sizeof(buf), pmu, event,\n\t\t\t\t\t\t skip_duplicate_pmus);\n\t\t\tif (pmu->is_core) {\n\t\t\t\tinfo.alias = info.name;\n\t\t\t\tinfo.name = event->name;\n\t\t\t}\n\t\t\tbuf_used = strlen(buf) + 1;\n\t\t}\n\t\tinfo.scale_unit = NULL;\n\t\tif (strlen(event->unit) || event->scale != 1.0) {\n\t\t\tinfo.scale_unit = buf + buf_used;\n\t\t\tbuf_used += snprintf(buf + buf_used, sizeof(buf) - buf_used,\n\t\t\t\t\t\"%G%s\", event->scale, event->unit) + 1;\n\t\t}\n\t\tinfo.desc = event->desc;\n\t\tinfo.long_desc = event->long_desc;\n\t\tinfo.encoding_desc = buf + buf_used;\n\t\tparse_events_term__to_strbuf(&event->terms, &sb);\n\t\tbuf_used += snprintf(buf + buf_used, sizeof(buf) - buf_used,\n\t\t\t\t\"%s/%s/\", info.pmu_name, sb.buf) + 1;\n\t\tinfo.topic = event->topic;\n\t\tinfo.str = sb.buf;\n\t\tinfo.deprecated = event->deprecated;\n\t\tret = cb(state, &info);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tstrbuf_setlen(&sb,   0);\n\t}\n\tif (pmu->selectable) {\n\t\tinfo.name = buf;\n\t\tsnprintf(buf, sizeof(buf), \"%s//\", pmu->name);\n\t\tinfo.alias = NULL;\n\t\tinfo.scale_unit = NULL;\n\t\tinfo.desc = NULL;\n\t\tinfo.long_desc = NULL;\n\t\tinfo.encoding_desc = NULL;\n\t\tinfo.topic = NULL;\n\t\tinfo.pmu_name = pmu->name;\n\t\tinfo.deprecated = false;\n\t\tret = cb(state, &info);\n\t}\nout:\n\tstrbuf_release(&sb);\n\treturn ret;\n}\n\nbool pmu__name_match(const struct perf_pmu *pmu, const char *pmu_name)\n{\n\treturn !strcmp(pmu->name, pmu_name) ||\n\t\t(pmu->is_uncore && pmu_uncore_alias_match(pmu_name, pmu->name)) ||\n\t\t \n\t        (pmu->is_core && !strcmp(pmu_name, \"default_core\"));\n}\n\nbool perf_pmu__is_software(const struct perf_pmu *pmu)\n{\n\tif (pmu->is_core || pmu->is_uncore || pmu->auxtrace)\n\t\treturn false;\n\tswitch (pmu->type) {\n\tcase PERF_TYPE_HARDWARE:\treturn false;\n\tcase PERF_TYPE_SOFTWARE:\treturn true;\n\tcase PERF_TYPE_TRACEPOINT:\treturn true;\n\tcase PERF_TYPE_HW_CACHE:\treturn false;\n\tcase PERF_TYPE_RAW:\t\treturn false;\n\tcase PERF_TYPE_BREAKPOINT:\treturn true;\n\tdefault: break;\n\t}\n\treturn !strcmp(pmu->name, \"kprobe\") || !strcmp(pmu->name, \"uprobe\");\n}\n\nFILE *perf_pmu__open_file(struct perf_pmu *pmu, const char *name)\n{\n\tchar path[PATH_MAX];\n\n\tif (!perf_pmu__pathname_scnprintf(path, sizeof(path), pmu->name, name) ||\n\t    !file_available(path))\n\t\treturn NULL;\n\n\treturn fopen(path, \"r\");\n}\n\nFILE *perf_pmu__open_file_at(struct perf_pmu *pmu, int dirfd, const char *name)\n{\n\tint fd;\n\n\tfd = perf_pmu__pathname_fd(dirfd, pmu->name, name, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\treturn fdopen(fd, \"r\");\n}\n\nint perf_pmu__scan_file(struct perf_pmu *pmu, const char *name, const char *fmt,\n\t\t\t...)\n{\n\tva_list args;\n\tFILE *file;\n\tint ret = EOF;\n\n\tva_start(args, fmt);\n\tfile = perf_pmu__open_file(pmu, name);\n\tif (file) {\n\t\tret = vfscanf(file, fmt, args);\n\t\tfclose(file);\n\t}\n\tva_end(args);\n\treturn ret;\n}\n\nint perf_pmu__scan_file_at(struct perf_pmu *pmu, int dirfd, const char *name,\n\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\tFILE *file;\n\tint ret = EOF;\n\n\tva_start(args, fmt);\n\tfile = perf_pmu__open_file_at(pmu, dirfd, name);\n\tif (file) {\n\t\tret = vfscanf(file, fmt, args);\n\t\tfclose(file);\n\t}\n\tva_end(args);\n\treturn ret;\n}\n\nbool perf_pmu__file_exists(struct perf_pmu *pmu, const char *name)\n{\n\tchar path[PATH_MAX];\n\n\tif (!perf_pmu__pathname_scnprintf(path, sizeof(path), pmu->name, name))\n\t\treturn false;\n\n\treturn file_available(path);\n}\n\nstatic int perf_pmu__new_caps(struct list_head *list, char *name, char *value)\n{\n\tstruct perf_pmu_caps *caps = zalloc(sizeof(*caps));\n\n\tif (!caps)\n\t\treturn -ENOMEM;\n\n\tcaps->name = strdup(name);\n\tif (!caps->name)\n\t\tgoto free_caps;\n\tcaps->value = strndup(value, strlen(value) - 1);\n\tif (!caps->value)\n\t\tgoto free_name;\n\tlist_add_tail(&caps->list, list);\n\treturn 0;\n\nfree_name:\n\tzfree(&caps->name);\nfree_caps:\n\tfree(caps);\n\n\treturn -ENOMEM;\n}\n\nstatic void perf_pmu__del_caps(struct perf_pmu *pmu)\n{\n\tstruct perf_pmu_caps *caps, *tmp;\n\n\tlist_for_each_entry_safe(caps, tmp, &pmu->caps, list) {\n\t\tlist_del(&caps->list);\n\t\tzfree(&caps->name);\n\t\tzfree(&caps->value);\n\t\tfree(caps);\n\t}\n}\n\n \nint perf_pmu__caps_parse(struct perf_pmu *pmu)\n{\n\tstruct stat st;\n\tchar caps_path[PATH_MAX];\n\tDIR *caps_dir;\n\tstruct dirent *evt_ent;\n\tint caps_fd;\n\n\tif (pmu->caps_initialized)\n\t\treturn pmu->nr_caps;\n\n\tpmu->nr_caps = 0;\n\n\tif (!perf_pmu__pathname_scnprintf(caps_path, sizeof(caps_path), pmu->name, \"caps\"))\n\t\treturn -1;\n\n\tif (stat(caps_path, &st) < 0) {\n\t\tpmu->caps_initialized = true;\n\t\treturn 0;\t \n\t}\n\n\tcaps_dir = opendir(caps_path);\n\tif (!caps_dir)\n\t\treturn -EINVAL;\n\n\tcaps_fd = dirfd(caps_dir);\n\n\twhile ((evt_ent = readdir(caps_dir)) != NULL) {\n\t\tchar *name = evt_ent->d_name;\n\t\tchar value[128];\n\t\tFILE *file;\n\t\tint fd;\n\n\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\"))\n\t\t\tcontinue;\n\n\t\tfd = openat(caps_fd, name, O_RDONLY);\n\t\tif (fd == -1)\n\t\t\tcontinue;\n\t\tfile = fdopen(fd, \"r\");\n\t\tif (!file) {\n\t\t\tclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!fgets(value, sizeof(value), file) ||\n\t\t    (perf_pmu__new_caps(&pmu->caps, name, value) < 0)) {\n\t\t\tfclose(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpmu->nr_caps++;\n\t\tfclose(file);\n\t}\n\n\tclosedir(caps_dir);\n\n\tpmu->caps_initialized = true;\n\treturn pmu->nr_caps;\n}\n\nstatic void perf_pmu__compute_config_masks(struct perf_pmu *pmu)\n{\n\tstruct perf_pmu_format *format;\n\n\tif (pmu->config_masks_computed)\n\t\treturn;\n\n\tlist_for_each_entry(format, &pmu->format, list)\t{\n\t\tunsigned int i;\n\t\t__u64 *mask;\n\n\t\tif (format->value >= PERF_PMU_FORMAT_VALUE_CONFIG_END)\n\t\t\tcontinue;\n\n\t\tpmu->config_masks_present = true;\n\t\tmask = &pmu->config_masks[format->value];\n\n\t\tfor_each_set_bit(i, format->bits, PERF_PMU_FORMAT_BITS)\n\t\t\t*mask |= 1ULL << i;\n\t}\n\tpmu->config_masks_computed = true;\n}\n\nvoid perf_pmu__warn_invalid_config(struct perf_pmu *pmu, __u64 config,\n\t\t\t\t   const char *name, int config_num,\n\t\t\t\t   const char *config_name)\n{\n\t__u64 bits;\n\tchar buf[100];\n\n\tperf_pmu__compute_config_masks(pmu);\n\n\t \n\tif (!pmu->config_masks_present)\n\t\treturn;\n\n\tbits = config & ~pmu->config_masks[config_num];\n\tif (bits == 0)\n\t\treturn;\n\n\tbitmap_scnprintf((unsigned long *)&bits, sizeof(bits) * 8, buf, sizeof(buf));\n\n\tpr_warning(\"WARNING: event '%s' not valid (bits %s of %s \"\n\t\t   \"'%llx' not supported by kernel)!\\n\",\n\t\t   name ?: \"N/A\", buf, config_name, config);\n}\n\nint perf_pmu__match(const char *pattern, const char *name, const char *tok)\n{\n\tif (!name)\n\t\treturn -1;\n\n\tif (fnmatch(pattern, name, 0))\n\t\treturn -1;\n\n\tif (tok && !perf_pmu__match_ignoring_suffix(name, tok))\n\t\treturn -1;\n\n\treturn 0;\n}\n\ndouble __weak perf_pmu__cpu_slots_per_cycle(void)\n{\n\treturn NAN;\n}\n\nint perf_pmu__event_source_devices_scnprintf(char *pathname, size_t size)\n{\n\tconst char *sysfs = sysfs__mountpoint();\n\n\tif (!sysfs)\n\t\treturn 0;\n\treturn scnprintf(pathname, size, \"%s/bus/event_source/devices/\", sysfs);\n}\n\nint perf_pmu__event_source_devices_fd(void)\n{\n\tchar path[PATH_MAX];\n\tconst char *sysfs = sysfs__mountpoint();\n\n\tif (!sysfs)\n\t\treturn -1;\n\n\tscnprintf(path, sizeof(path), \"%s/bus/event_source/devices/\", sysfs);\n\treturn open(path, O_DIRECTORY);\n}\n\n \nint perf_pmu__pathname_scnprintf(char *buf, size_t size,\n\t\t\t\t const char *pmu_name, const char *filename)\n{\n\tsize_t len;\n\n\tlen = perf_pmu__event_source_devices_scnprintf(buf, size);\n\tif (!len || (len + strlen(pmu_name) + strlen(filename) + 1)  >= size)\n\t\treturn 0;\n\n\treturn scnprintf(buf + len, size - len, \"%s/%s\", pmu_name, filename);\n}\n\nint perf_pmu__pathname_fd(int dirfd, const char *pmu_name, const char *filename, int flags)\n{\n\tchar path[PATH_MAX];\n\n\tscnprintf(path, sizeof(path), \"%s/%s\", pmu_name, filename);\n\treturn openat(dirfd, path, flags);\n}\n\nvoid perf_pmu__delete(struct perf_pmu *pmu)\n{\n\tperf_pmu__del_formats(&pmu->format);\n\tperf_pmu__del_aliases(pmu);\n\tperf_pmu__del_caps(pmu);\n\n\tperf_cpu_map__put(pmu->cpus);\n\n\tzfree(&pmu->default_config);\n\tzfree(&pmu->name);\n\tzfree(&pmu->alias_name);\n\tzfree(&pmu->id);\n\tfree(pmu);\n}\n\nstruct perf_pmu *pmu__find_core_pmu(void)\n{\n\tstruct perf_pmu *pmu = NULL;\n\n\twhile ((pmu = perf_pmus__scan_core(pmu))) {\n\t\t \n\t\tif (RC_CHK_ACCESS(pmu->cpus)->nr != cpu__max_cpu().cpu)\n\t\t\treturn NULL;\n\n\t\treturn pmu;\n\t}\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}