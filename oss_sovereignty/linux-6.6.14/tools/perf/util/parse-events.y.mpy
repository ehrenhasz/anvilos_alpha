{
  "module_name": "parse-events.y",
  "hash_id": "cf7b04fb6c0548fce6b297d520d6d161d8e6c92977d524a35d03e205b02ac69c",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/parse-events.y",
  "human_readable_source": "%define api.pure full\n%parse-param {void *_parse_state}\n%parse-param {void *scanner}\n%lex-param {void* scanner}\n%locations\n\n%{\n\n#define YYDEBUG 1\n\n#include <errno.h>\n#include <fnmatch.h>\n#include <stdio.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/zalloc.h>\n#include \"pmu.h\"\n#include \"pmus.h\"\n#include \"evsel.h\"\n#include \"parse-events.h\"\n#include \"parse-events-bison.h\"\n\nint parse_events_lex(YYSTYPE * yylval_param, YYLTYPE * yylloc_param , void *yyscanner);\nvoid parse_events_error(YYLTYPE *loc, void *parse_state, void *scanner, char const *msg);\n\n#define PE_ABORT(val) \\\ndo { \\\n\tif (val == -ENOMEM) \\\n\t\tYYNOMEM; \\\n\tYYABORT; \\\n} while (0)\n\nstatic struct list_head* alloc_list(void)\n{\n\tstruct list_head *list;\n\n\tlist = malloc(sizeof(*list));\n\tif (!list)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(list);\n\treturn list;\n}\n\nstatic void free_list_evsel(struct list_head* list_evsel)\n{\n\tstruct evsel *evsel, *tmp;\n\n\tlist_for_each_entry_safe(evsel, tmp, list_evsel, core.node) {\n\t\tlist_del_init(&evsel->core.node);\n\t\tevsel__delete(evsel);\n\t}\n\tfree(list_evsel);\n}\n\n%}\n\n%token PE_START_EVENTS PE_START_TERMS\n%token PE_VALUE PE_VALUE_SYM_HW PE_VALUE_SYM_SW PE_TERM\n%token PE_VALUE_SYM_TOOL\n%token PE_EVENT_NAME\n%token PE_RAW PE_NAME\n%token PE_MODIFIER_EVENT PE_MODIFIER_BP PE_BP_COLON PE_BP_SLASH\n%token PE_LEGACY_CACHE\n%token PE_PREFIX_MEM\n%token PE_ERROR\n%token PE_DRV_CFG_TERM\n%token PE_TERM_HW\n%type <num> PE_VALUE\n%type <num> PE_VALUE_SYM_HW\n%type <num> PE_VALUE_SYM_SW\n%type <num> PE_VALUE_SYM_TOOL\n%type <num> PE_TERM\n%type <num> value_sym\n%type <str> PE_RAW\n%type <str> PE_NAME\n%type <str> PE_LEGACY_CACHE\n%type <str> PE_MODIFIER_EVENT\n%type <str> PE_MODIFIER_BP\n%type <str> PE_EVENT_NAME\n%type <str> PE_DRV_CFG_TERM\n%type <str> name_or_raw\n%destructor { free ($$); } <str>\n%type <term> event_term\n%destructor { parse_events_term__delete ($$); } <term>\n%type <list_terms> event_config\n%type <list_terms> opt_event_config\n%type <list_terms> opt_pmu_config\n%destructor { parse_events_terms__delete ($$); } <list_terms>\n%type <list_evsel> event_pmu\n%type <list_evsel> event_legacy_symbol\n%type <list_evsel> event_legacy_cache\n%type <list_evsel> event_legacy_mem\n%type <list_evsel> event_legacy_tracepoint\n%type <list_evsel> event_legacy_numeric\n%type <list_evsel> event_legacy_raw\n%type <list_evsel> event_def\n%type <list_evsel> event_mod\n%type <list_evsel> event_name\n%type <list_evsel> event\n%type <list_evsel> events\n%type <list_evsel> group_def\n%type <list_evsel> group\n%type <list_evsel> groups\n%destructor { free_list_evsel ($$); } <list_evsel>\n%type <tracepoint_name> tracepoint_name\n%destructor { free ($$.sys); free ($$.event); } <tracepoint_name>\n%type <hardware_term> PE_TERM_HW\n%destructor { free ($$.str); } <hardware_term>\n\n%union\n{\n\tchar *str;\n\tu64 num;\n\tstruct list_head *list_evsel;\n\tstruct list_head *list_terms;\n\tstruct parse_events_term *term;\n\tstruct tracepoint_name {\n\t\tchar *sys;\n\t\tchar *event;\n\t} tracepoint_name;\n\tstruct hardware_term {\n\t\tchar *str;\n\t\tu64 num;\n\t} hardware_term;\n}\n%%\n\nstart:\nPE_START_EVENTS start_events\n|\nPE_START_TERMS  start_terms\n\nstart_events: groups\n{\n\tstruct parse_events_state *parse_state = _parse_state;\n\n\t/* frees $1 */\n\tparse_events_update_lists($1, &parse_state->list);\n}\n\ngroups:\ngroups ',' group\n{\n\tstruct list_head *list  = $1;\n\tstruct list_head *group = $3;\n\n\t/* frees $3 */\n\tparse_events_update_lists(group, list);\n\t$$ = list;\n}\n|\ngroups ',' event\n{\n\tstruct list_head *list  = $1;\n\tstruct list_head *event = $3;\n\n\t/* frees $3 */\n\tparse_events_update_lists(event, list);\n\t$$ = list;\n}\n|\ngroup\n|\nevent\n\ngroup:\ngroup_def ':' PE_MODIFIER_EVENT\n{\n\tstruct list_head *list = $1;\n\tint err;\n\n\terr = parse_events__modifier_group(list, $3);\n\tfree($3);\n\tif (err) {\n\t\tstruct parse_events_state *parse_state = _parse_state;\n\t\tstruct parse_events_error *error = parse_state->error;\n\n\t\tparse_events_error__handle(error, @3.first_column,\n\t\t\t\t\t   strdup(\"Bad modifier\"), NULL);\n\t\tfree_list_evsel(list);\n\t\tYYABORT;\n\t}\n\t$$ = list;\n}\n|\ngroup_def\n\ngroup_def:\nPE_NAME '{' events '}'\n{\n\tstruct list_head *list = $3;\n\n\t/* Takes ownership of $1. */\n\tparse_events__set_leader($1, list);\n\t$$ = list;\n}\n|\n'{' events '}'\n{\n\tstruct list_head *list = $2;\n\n\tparse_events__set_leader(NULL, list);\n\t$$ = list;\n}\n\nevents:\nevents ',' event\n{\n\tstruct list_head *event = $3;\n\tstruct list_head *list  = $1;\n\n\t/* frees $3 */\n\tparse_events_update_lists(event, list);\n\t$$ = list;\n}\n|\nevent\n\nevent: event_mod\n\nevent_mod:\nevent_name PE_MODIFIER_EVENT\n{\n\tstruct list_head *list = $1;\n\tint err;\n\n\t/*\n\t * Apply modifier on all events added by single event definition\n\t * (there could be more events added for multiple tracepoint\n\t * definitions via '*?'.\n\t */\n\terr = parse_events__modifier_event(list, $2, false);\n\tfree($2);\n\tif (err) {\n\t\tstruct parse_events_state *parse_state = _parse_state;\n\t\tstruct parse_events_error *error = parse_state->error;\n\n\t\tparse_events_error__handle(error, @2.first_column,\n\t\t\t\t\t   strdup(\"Bad modifier\"), NULL);\n\t\tfree_list_evsel(list);\n\t\tYYABORT;\n\t}\n\t$$ = list;\n}\n|\nevent_name\n\nevent_name:\nPE_EVENT_NAME event_def\n{\n\tint err;\n\n\terr = parse_events_name($2, $1);\n\tfree($1);\n\tif (err) {\n\t\tfree_list_evsel($2);\n\t\tYYNOMEM;\n\t}\n\t$$ = $2;\n}\n|\nevent_def\n\nevent_def: event_pmu |\n\t   event_legacy_symbol |\n\t   event_legacy_cache sep_dc |\n\t   event_legacy_mem sep_dc |\n\t   event_legacy_tracepoint sep_dc |\n\t   event_legacy_numeric sep_dc |\n\t   event_legacy_raw sep_dc\n\nevent_pmu:\nPE_NAME opt_pmu_config\n{\n\tstruct parse_events_state *parse_state = _parse_state;\n\tstruct list_head *list = NULL, *orig_terms = NULL, *terms= NULL;\n\tchar *pattern = NULL;\n\n#define CLEANUP\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tparse_events_terms__delete($2);\t\t\\\n\t\tparse_events_terms__delete(orig_terms);\t\\\n\t\tfree(list);\t\t\t\t\\\n\t\tfree($1);\t\t\t\t\\\n\t\tfree(pattern);\t\t\t\t\\\n\t} while(0)\n\n\tif (parse_events_copy_term_list($2, &orig_terms)) {\n\t\tCLEANUP;\n\t\tYYNOMEM;\n\t}\n\n\tlist = alloc_list();\n\tif (!list) {\n\t\tCLEANUP;\n\t\tYYNOMEM;\n\t}\n\t/* Attempt to add to list assuming $1 is a PMU name. */\n\tif (parse_events_add_pmu(parse_state, list, $1, $2, /*auto_merge_stats=*/false, &@1)) {\n\t\tstruct perf_pmu *pmu = NULL;\n\t\tint ok = 0;\n\n\t\t/* Failure to add, try wildcard expansion of $1 as a PMU name. */\n\t\tif (asprintf(&pattern, \"%s*\", $1) < 0) {\n\t\t\tCLEANUP;\n\t\t\tYYNOMEM;\n\t\t}\n\n\t\twhile ((pmu = perf_pmus__scan(pmu)) != NULL) {\n\t\t\tconst char *name = pmu->name;\n\n\t\t\tif (parse_events__filter_pmu(parse_state, pmu))\n\t\t\t\tcontinue;\n\n\t\t\tif (!strncmp(name, \"uncore_\", 7) &&\n\t\t\t    strncmp($1, \"uncore_\", 7))\n\t\t\t\tname += 7;\n\t\t\tif (!perf_pmu__match(pattern, name, $1) ||\n\t\t\t    !perf_pmu__match(pattern, pmu->alias_name, $1)) {\n\t\t\t\tbool auto_merge_stats = perf_pmu__auto_merge_stats(pmu);\n\n\t\t\t\tif (parse_events_copy_term_list(orig_terms, &terms)) {\n\t\t\t\t\tCLEANUP;\n\t\t\t\t\tYYNOMEM;\n\t\t\t\t}\n\t\t\t\tif (!parse_events_add_pmu(parse_state, list, pmu->name, terms,\n\t\t\t\t\t\t\t  auto_merge_stats, &@1)) {\n\t\t\t\t\tok++;\n\t\t\t\t\tparse_state->wild_card_pmus = true;\n\t\t\t\t}\n\t\t\t\tparse_events_terms__delete(terms);\n\t\t\t}\n\t\t}\n\n\t\tif (!ok) {\n\t\t\t/* Failure to add, assume $1 is an event name. */\n\t\t\tzfree(&list);\n\t\t\tok = !parse_events_multi_pmu_add(parse_state, $1, $2, &list, &@1);\n\t\t\t$2 = NULL;\n\t\t}\n\t\tif (!ok) {\n\t\t\tstruct parse_events_error *error = parse_state->error;\n\t\t\tchar *help;\n\n\t\t\tif (asprintf(&help, \"Unable to find PMU or event on a PMU of '%s'\", $1) < 0)\n\t\t\t\thelp = NULL;\n\t\t\tparse_events_error__handle(error, @1.first_column,\n\t\t\t\t\t\t   strdup(\"Bad event or PMU\"),\n\t\t\t\t\t\t   help);\n\t\t\tCLEANUP;\n\t\t\tYYABORT;\n\t\t}\n\t}\n\t$$ = list;\n\tlist = NULL;\n\tCLEANUP;\n#undef CLEANUP\n}\n|\nPE_NAME sep_dc\n{\n\tstruct list_head *list;\n\tint err;\n\n\terr = parse_events_multi_pmu_add(_parse_state, $1, NULL, &list, &@1);\n\tif (err < 0) {\n\t\tstruct parse_events_state *parse_state = _parse_state;\n\t\tstruct parse_events_error *error = parse_state->error;\n\t\tchar *help;\n\n\t\tif (asprintf(&help, \"Unable to find event on a PMU of '%s'\", $1) < 0)\n\t\t\thelp = NULL;\n\t\tparse_events_error__handle(error, @1.first_column, strdup(\"Bad event name\"), help);\n\t\tfree($1);\n\t\tPE_ABORT(err);\n\t}\n\tfree($1);\n\t$$ = list;\n}\n\nvalue_sym:\nPE_VALUE_SYM_HW\n|\nPE_VALUE_SYM_SW\n\nevent_legacy_symbol:\nvalue_sym '/' event_config '/'\n{\n\tstruct list_head *list;\n\tint type = $1 >> 16;\n\tint config = $1 & 255;\n\tint err;\n\tbool wildcard = (type == PERF_TYPE_HARDWARE || type == PERF_TYPE_HW_CACHE);\n\n\tlist = alloc_list();\n\tif (!list)\n\t\tYYNOMEM;\n\terr = parse_events_add_numeric(_parse_state, list, type, config, $3, wildcard);\n\tparse_events_terms__delete($3);\n\tif (err) {\n\t\tfree_list_evsel(list);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = list;\n}\n|\nvalue_sym sep_slash_slash_dc\n{\n\tstruct list_head *list;\n\tint type = $1 >> 16;\n\tint config = $1 & 255;\n\tbool wildcard = (type == PERF_TYPE_HARDWARE || type == PERF_TYPE_HW_CACHE);\n\tint err;\n\n\tlist = alloc_list();\n\tif (!list)\n\t\tYYNOMEM;\n\terr = parse_events_add_numeric(_parse_state, list, type, config, /*head_config=*/NULL, wildcard);\n\tif (err)\n\t\tPE_ABORT(err);\n\t$$ = list;\n}\n|\nPE_VALUE_SYM_TOOL sep_slash_slash_dc\n{\n\tstruct list_head *list;\n\tint err;\n\n\tlist = alloc_list();\n\tif (!list)\n\t\tYYNOMEM;\n\terr = parse_events_add_tool(_parse_state, list, $1);\n\tif (err)\n\t\tYYNOMEM;\n\t$$ = list;\n}\n\nevent_legacy_cache:\nPE_LEGACY_CACHE opt_event_config\n{\n\tstruct parse_events_state *parse_state = _parse_state;\n\tstruct list_head *list;\n\tint err;\n\n\tlist = alloc_list();\n\tif (!list)\n\t\tYYNOMEM;\n\n\terr = parse_events_add_cache(list, &parse_state->idx, $1, parse_state, $2);\n\n\tparse_events_terms__delete($2);\n\tfree($1);\n\tif (err) {\n\t\tfree_list_evsel(list);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = list;\n}\n\nevent_legacy_mem:\nPE_PREFIX_MEM PE_VALUE PE_BP_SLASH PE_VALUE PE_BP_COLON PE_MODIFIER_BP opt_event_config\n{\n\tstruct list_head *list;\n\tint err;\n\n\tlist = alloc_list();\n\tif (!list)\n\t\tYYNOMEM;\n\n\terr = parse_events_add_breakpoint(_parse_state, list,\n\t\t\t\t\t  $2, $6, $4, $7);\n\tparse_events_terms__delete($7);\n\tfree($6);\n\tif (err) {\n\t\tfree(list);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = list;\n}\n|\nPE_PREFIX_MEM PE_VALUE PE_BP_SLASH PE_VALUE opt_event_config\n{\n\tstruct list_head *list;\n\tint err;\n\n\tlist = alloc_list();\n\tif (!list)\n\t\tYYNOMEM;\n\n\terr = parse_events_add_breakpoint(_parse_state, list,\n\t\t\t\t\t  $2, NULL, $4, $5);\n\tparse_events_terms__delete($5);\n\tif (err) {\n\t\tfree(list);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = list;\n}\n|\nPE_PREFIX_MEM PE_VALUE PE_BP_COLON PE_MODIFIER_BP opt_event_config\n{\n\tstruct list_head *list;\n\tint err;\n\n\tlist = alloc_list();\n\tif (!list)\n\t\tYYNOMEM;\n\n\terr = parse_events_add_breakpoint(_parse_state, list,\n\t\t\t\t\t  $2, $4, 0, $5);\n\tparse_events_terms__delete($5);\n\tfree($4);\n\tif (err) {\n\t\tfree(list);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = list;\n}\n|\nPE_PREFIX_MEM PE_VALUE opt_event_config\n{\n\tstruct list_head *list;\n\tint err;\n\n\tlist = alloc_list();\n\tif (!list)\n\t\tYYNOMEM;\n\terr = parse_events_add_breakpoint(_parse_state, list,\n\t\t\t\t\t  $2, NULL, 0, $3);\n\tparse_events_terms__delete($3);\n\tif (err) {\n\t\tfree(list);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = list;\n}\n\nevent_legacy_tracepoint:\ntracepoint_name opt_event_config\n{\n\tstruct parse_events_state *parse_state = _parse_state;\n\tstruct parse_events_error *error = parse_state->error;\n\tstruct list_head *list;\n\tint err;\n\n\tlist = alloc_list();\n\tif (!list)\n\t\tYYNOMEM;\n\tif (error)\n\t\terror->idx = @1.first_column;\n\n\terr = parse_events_add_tracepoint(list, &parse_state->idx, $1.sys, $1.event,\n\t\t\t\t\terror, $2, &@1);\n\n\tparse_events_terms__delete($2);\n\tfree($1.sys);\n\tfree($1.event);\n\tif (err) {\n\t\tfree(list);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = list;\n}\n\ntracepoint_name:\nPE_NAME ':' PE_NAME\n{\n\tstruct tracepoint_name tracepoint = {$1, $3};\n\n\t$$ = tracepoint;\n}\n\nevent_legacy_numeric:\nPE_VALUE ':' PE_VALUE opt_event_config\n{\n\tstruct list_head *list;\n\tint err;\n\n\tlist = alloc_list();\n\tif (!list)\n\t\tYYNOMEM;\n\terr = parse_events_add_numeric(_parse_state, list, (u32)$1, $3, $4,\n\t\t\t\t       /*wildcard=*/false);\n\tparse_events_terms__delete($4);\n\tif (err) {\n\t\tfree(list);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = list;\n}\n\nevent_legacy_raw:\nPE_RAW opt_event_config\n{\n\tstruct list_head *list;\n\tint err;\n\tu64 num;\n\n\tlist = alloc_list();\n\tif (!list)\n\t\tYYNOMEM;\n\terrno = 0;\n\tnum = strtoull($1 + 1, NULL, 16);\n\t/* Given the lexer will only give [a-fA-F0-9]+ a failure here should be impossible. */\n\tif (errno)\n\t\tYYABORT;\n\tfree($1);\n\terr = parse_events_add_numeric(_parse_state, list, PERF_TYPE_RAW, num, $2,\n\t\t\t\t       /*wildcard=*/false);\n\tparse_events_terms__delete($2);\n\tif (err) {\n\t\tfree(list);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = list;\n}\n\nopt_event_config:\n'/' event_config '/'\n{\n\t$$ = $2;\n}\n|\n'/' '/'\n{\n\t$$ = NULL;\n}\n|\n{\n\t$$ = NULL;\n}\n\nopt_pmu_config:\n'/' event_config '/'\n{\n\t$$ = $2;\n}\n|\n'/' '/'\n{\n\t$$ = NULL;\n}\n\nstart_terms: event_config\n{\n\tstruct parse_events_state *parse_state = _parse_state;\n\tif (parse_state->terms) {\n\t\tparse_events_terms__delete ($1);\n\t\tYYABORT;\n\t}\n\tparse_state->terms = $1;\n}\n\nevent_config:\nevent_config ',' event_term\n{\n\tstruct list_head *head = $1;\n\tstruct parse_events_term *term = $3;\n\n\tif (!head) {\n\t\tparse_events_term__delete(term);\n\t\tYYABORT;\n\t}\n\tlist_add_tail(&term->list, head);\n\t$$ = $1;\n}\n|\nevent_term\n{\n\tstruct list_head *head = malloc(sizeof(*head));\n\tstruct parse_events_term *term = $1;\n\n\tif (!head)\n\t\tYYNOMEM;\n\tINIT_LIST_HEAD(head);\n\tlist_add_tail(&term->list, head);\n\t$$ = head;\n}\n\nname_or_raw: PE_RAW | PE_NAME | PE_LEGACY_CACHE\n\nevent_term:\nPE_RAW\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__str(&term, PARSE_EVENTS__TERM_TYPE_RAW,\n\t\t\t\t\t strdup(\"raw\"), $1, &@1, &@1);\n\n\tif (err) {\n\t\tfree($1);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = term;\n}\n|\nname_or_raw '=' name_or_raw\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__str(&term, PARSE_EVENTS__TERM_TYPE_USER, $1, $3, &@1, &@3);\n\n\tif (err) {\n\t\tfree($1);\n\t\tfree($3);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = term;\n}\n|\nname_or_raw '=' PE_VALUE\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__num(&term, PARSE_EVENTS__TERM_TYPE_USER,\n\t\t\t\t\t $1, $3, /*novalue=*/false, &@1, &@3);\n\n\tif (err) {\n\t\tfree($1);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = term;\n}\n|\nname_or_raw '=' PE_TERM_HW\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__str(&term, PARSE_EVENTS__TERM_TYPE_USER,\n\t\t\t\t\t $1, $3.str, &@1, &@3);\n\n\tif (err) {\n\t\tfree($1);\n\t\tfree($3.str);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = term;\n}\n|\nPE_LEGACY_CACHE\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__num(&term, PARSE_EVENTS__TERM_TYPE_LEGACY_CACHE,\n\t\t\t\t\t $1, /*num=*/1, /*novalue=*/true, &@1, /*loc_val=*/NULL);\n\n\tif (err) {\n\t\tfree($1);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = term;\n}\n|\nPE_NAME\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__num(&term, PARSE_EVENTS__TERM_TYPE_USER,\n\t\t\t\t\t $1, /*num=*/1, /*novalue=*/true, &@1, /*loc_val=*/NULL);\n\n\tif (err) {\n\t\tfree($1);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = term;\n}\n|\nPE_TERM_HW\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__num(&term, PARSE_EVENTS__TERM_TYPE_HARDWARE,\n\t\t\t\t\t $1.str, $1.num & 255, /*novalue=*/false,\n\t\t\t\t\t &@1, /*loc_val=*/NULL);\n\n\tif (err) {\n\t\tfree($1.str);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = term;\n}\n|\nPE_TERM '=' name_or_raw\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__str(&term, (enum parse_events__term_type)$1,\n\t\t\t\t\t/*config=*/NULL, $3, &@1, &@3);\n\n\tif (err) {\n\t\tfree($3);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = term;\n}\n|\nPE_TERM '=' PE_TERM_HW\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__str(&term, (enum parse_events__term_type)$1,\n\t\t\t\t\t /*config=*/NULL, $3.str, &@1, &@3);\n\n\tif (err) {\n\t\tfree($3.str);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = term;\n}\n|\nPE_TERM '=' PE_TERM\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__term(&term,\n\t\t\t\t\t  (enum parse_events__term_type)$1,\n\t\t\t\t\t  (enum parse_events__term_type)$3,\n\t\t\t\t\t  &@1, &@3);\n\n\tif (err)\n\t\tPE_ABORT(err);\n\n\t$$ = term;\n}\n|\nPE_TERM '=' PE_VALUE\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__num(&term, (enum parse_events__term_type)$1,\n\t\t\t\t\t /*config=*/NULL, $3, /*novalue=*/false, &@1, &@3);\n\n\tif (err)\n\t\tPE_ABORT(err);\n\n\t$$ = term;\n}\n|\nPE_TERM\n{\n\tstruct parse_events_term *term;\n\tint err = parse_events_term__num(&term, (enum parse_events__term_type)$1,\n\t\t\t\t\t/*config=*/NULL, /*num=*/1, /*novalue=*/true,\n\t\t\t\t\t&@1, /*loc_val=*/NULL);\n\n\tif (err)\n\t\tPE_ABORT(err);\n\n\t$$ = term;\n}\n|\nPE_DRV_CFG_TERM\n{\n\tstruct parse_events_term *term;\n\tchar *config = strdup($1);\n\tint err;\n\n\tif (!config)\n\t\tYYNOMEM;\n\terr = parse_events_term__str(&term, PARSE_EVENTS__TERM_TYPE_DRV_CFG, config, $1, &@1, NULL);\n\tif (err) {\n\t\tfree($1);\n\t\tfree(config);\n\t\tPE_ABORT(err);\n\t}\n\t$$ = term;\n}\n\nsep_dc: ':' |\n\nsep_slash_slash_dc: '/' '/' | ':' |\n\n%%\n\nvoid parse_events_error(YYLTYPE *loc, void *parse_state,\n\t\t\tvoid *scanner __maybe_unused,\n\t\t\tchar const *msg __maybe_unused)\n{\n\tparse_events_evlist_error(parse_state, loc->last_column, \"parser error\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}