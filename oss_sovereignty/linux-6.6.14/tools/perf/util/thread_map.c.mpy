{
  "module_name": "thread_map.c",
  "hash_id": "99364aa47207e496165715e00ce0aa4e71215b9d58824b2ffb68154c37f320b9",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/thread_map.c",
  "human_readable_source": "\n#include <dirent.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include \"string2.h\"\n#include \"strlist.h\"\n#include <string.h>\n#include <api/fs/fs.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include \"asm/bug.h\"\n#include \"thread_map.h\"\n#include \"debug.h\"\n#include \"event.h\"\n#include <internal/threadmap.h>\n\n \nstatic int filter(const struct dirent *dir)\n{\n\tif (dir->d_name[0] == '.')\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\n#define thread_map__alloc(__nr) perf_thread_map__realloc(NULL, __nr)\n\nstruct perf_thread_map *thread_map__new_by_pid(pid_t pid)\n{\n\tstruct perf_thread_map *threads;\n\tchar name[256];\n\tint items;\n\tstruct dirent **namelist = NULL;\n\tint i;\n\n\tsprintf(name, \"/proc/%d/task\", pid);\n\titems = scandir(name, &namelist, filter, NULL);\n\tif (items <= 0)\n\t\treturn NULL;\n\n\tthreads = thread_map__alloc(items);\n\tif (threads != NULL) {\n\t\tfor (i = 0; i < items; i++)\n\t\t\tperf_thread_map__set_pid(threads, i, atoi(namelist[i]->d_name));\n\t\tthreads->nr = items;\n\t\trefcount_set(&threads->refcnt, 1);\n\t}\n\n\tfor (i=0; i<items; i++)\n\t\tzfree(&namelist[i]);\n\tfree(namelist);\n\n\treturn threads;\n}\n\nstruct perf_thread_map *thread_map__new_by_tid(pid_t tid)\n{\n\tstruct perf_thread_map *threads = thread_map__alloc(1);\n\n\tif (threads != NULL) {\n\t\tperf_thread_map__set_pid(threads, 0, tid);\n\t\tthreads->nr = 1;\n\t\trefcount_set(&threads->refcnt, 1);\n\t}\n\n\treturn threads;\n}\n\nstatic struct perf_thread_map *__thread_map__new_all_cpus(uid_t uid)\n{\n\tDIR *proc;\n\tint max_threads = 32, items, i;\n\tchar path[NAME_MAX + 1 + 6];\n\tstruct dirent *dirent, **namelist = NULL;\n\tstruct perf_thread_map *threads = thread_map__alloc(max_threads);\n\n\tif (threads == NULL)\n\t\tgoto out;\n\n\tproc = opendir(\"/proc\");\n\tif (proc == NULL)\n\t\tgoto out_free_threads;\n\n\tthreads->nr = 0;\n\trefcount_set(&threads->refcnt, 1);\n\n\twhile ((dirent = readdir(proc)) != NULL) {\n\t\tchar *end;\n\t\tbool grow = false;\n\t\tpid_t pid = strtol(dirent->d_name, &end, 10);\n\n\t\tif (*end)  \n\t\t\tcontinue;\n\n\t\tsnprintf(path, sizeof(path), \"/proc/%s\", dirent->d_name);\n\n\t\tif (uid != UINT_MAX) {\n\t\t\tstruct stat st;\n\n\t\t\tif (stat(path, &st) != 0 || st.st_uid != uid)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tsnprintf(path, sizeof(path), \"/proc/%d/task\", pid);\n\t\titems = scandir(path, &namelist, filter, NULL);\n\t\tif (items <= 0)\n\t\t\tgoto out_free_closedir;\n\n\t\twhile (threads->nr + items >= max_threads) {\n\t\t\tmax_threads *= 2;\n\t\t\tgrow = true;\n\t\t}\n\n\t\tif (grow) {\n\t\t\tstruct perf_thread_map *tmp;\n\n\t\t\ttmp = perf_thread_map__realloc(threads, max_threads);\n\t\t\tif (tmp == NULL)\n\t\t\t\tgoto out_free_namelist;\n\n\t\t\tthreads = tmp;\n\t\t}\n\n\t\tfor (i = 0; i < items; i++) {\n\t\t\tperf_thread_map__set_pid(threads, threads->nr + i,\n\t\t\t\t\t\t    atoi(namelist[i]->d_name));\n\t\t}\n\n\t\tfor (i = 0; i < items; i++)\n\t\t\tzfree(&namelist[i]);\n\t\tfree(namelist);\n\n\t\tthreads->nr += items;\n\t}\n\nout_closedir:\n\tclosedir(proc);\nout:\n\treturn threads;\n\nout_free_threads:\n\tfree(threads);\n\treturn NULL;\n\nout_free_namelist:\n\tfor (i = 0; i < items; i++)\n\t\tzfree(&namelist[i]);\n\tfree(namelist);\n\nout_free_closedir:\n\tzfree(&threads);\n\tgoto out_closedir;\n}\n\nstruct perf_thread_map *thread_map__new_all_cpus(void)\n{\n\treturn __thread_map__new_all_cpus(UINT_MAX);\n}\n\nstruct perf_thread_map *thread_map__new_by_uid(uid_t uid)\n{\n\treturn __thread_map__new_all_cpus(uid);\n}\n\nstruct perf_thread_map *thread_map__new(pid_t pid, pid_t tid, uid_t uid)\n{\n\tif (pid != -1)\n\t\treturn thread_map__new_by_pid(pid);\n\n\tif (tid == -1 && uid != UINT_MAX)\n\t\treturn thread_map__new_by_uid(uid);\n\n\treturn thread_map__new_by_tid(tid);\n}\n\nstatic struct perf_thread_map *thread_map__new_by_pid_str(const char *pid_str)\n{\n\tstruct perf_thread_map *threads = NULL, *nt;\n\tchar name[256];\n\tint items, total_tasks = 0;\n\tstruct dirent **namelist = NULL;\n\tint i, j = 0;\n\tpid_t pid, prev_pid = INT_MAX;\n\tchar *end_ptr;\n\tstruct str_node *pos;\n\tstruct strlist_config slist_config = { .dont_dupstr = true, };\n\tstruct strlist *slist = strlist__new(pid_str, &slist_config);\n\n\tif (!slist)\n\t\treturn NULL;\n\n\tstrlist__for_each_entry(pos, slist) {\n\t\tpid = strtol(pos->s, &end_ptr, 10);\n\n\t\tif (pid == INT_MIN || pid == INT_MAX ||\n\t\t    (*end_ptr != '\\0' && *end_ptr != ','))\n\t\t\tgoto out_free_threads;\n\n\t\tif (pid == prev_pid)\n\t\t\tcontinue;\n\n\t\tsprintf(name, \"/proc/%d/task\", pid);\n\t\titems = scandir(name, &namelist, filter, NULL);\n\t\tif (items <= 0)\n\t\t\tgoto out_free_threads;\n\n\t\ttotal_tasks += items;\n\t\tnt = perf_thread_map__realloc(threads, total_tasks);\n\t\tif (nt == NULL)\n\t\t\tgoto out_free_namelist;\n\n\t\tthreads = nt;\n\n\t\tfor (i = 0; i < items; i++) {\n\t\t\tperf_thread_map__set_pid(threads, j++, atoi(namelist[i]->d_name));\n\t\t\tzfree(&namelist[i]);\n\t\t}\n\t\tthreads->nr = total_tasks;\n\t\tfree(namelist);\n\t}\n\nout:\n\tstrlist__delete(slist);\n\tif (threads)\n\t\trefcount_set(&threads->refcnt, 1);\n\treturn threads;\n\nout_free_namelist:\n\tfor (i = 0; i < items; i++)\n\t\tzfree(&namelist[i]);\n\tfree(namelist);\n\nout_free_threads:\n\tzfree(&threads);\n\tgoto out;\n}\n\nstruct perf_thread_map *thread_map__new_by_tid_str(const char *tid_str)\n{\n\tstruct perf_thread_map *threads = NULL, *nt;\n\tint ntasks = 0;\n\tpid_t tid, prev_tid = INT_MAX;\n\tchar *end_ptr;\n\tstruct str_node *pos;\n\tstruct strlist_config slist_config = { .dont_dupstr = true, };\n\tstruct strlist *slist;\n\n\t \n\tif (!tid_str)\n\t\treturn perf_thread_map__new_dummy();\n\n\tslist = strlist__new(tid_str, &slist_config);\n\tif (!slist)\n\t\treturn NULL;\n\n\tstrlist__for_each_entry(pos, slist) {\n\t\ttid = strtol(pos->s, &end_ptr, 10);\n\n\t\tif (tid == INT_MIN || tid == INT_MAX ||\n\t\t    (*end_ptr != '\\0' && *end_ptr != ','))\n\t\t\tgoto out_free_threads;\n\n\t\tif (tid == prev_tid)\n\t\t\tcontinue;\n\n\t\tntasks++;\n\t\tnt = perf_thread_map__realloc(threads, ntasks);\n\n\t\tif (nt == NULL)\n\t\t\tgoto out_free_threads;\n\n\t\tthreads = nt;\n\t\tperf_thread_map__set_pid(threads, ntasks - 1, tid);\n\t\tthreads->nr = ntasks;\n\t}\nout:\n\tif (threads)\n\t\trefcount_set(&threads->refcnt, 1);\n\treturn threads;\n\nout_free_threads:\n\tzfree(&threads);\n\tstrlist__delete(slist);\n\tgoto out;\n}\n\nstruct perf_thread_map *thread_map__new_str(const char *pid, const char *tid,\n\t\t\t\t       uid_t uid, bool all_threads)\n{\n\tif (pid)\n\t\treturn thread_map__new_by_pid_str(pid);\n\n\tif (!tid && uid != UINT_MAX)\n\t\treturn thread_map__new_by_uid(uid);\n\n\tif (all_threads)\n\t\treturn thread_map__new_all_cpus();\n\n\treturn thread_map__new_by_tid_str(tid);\n}\n\nsize_t thread_map__fprintf(struct perf_thread_map *threads, FILE *fp)\n{\n\tint i;\n\tsize_t printed = fprintf(fp, \"%d thread%s: \",\n\t\t\t\t threads->nr, threads->nr > 1 ? \"s\" : \"\");\n\tfor (i = 0; i < threads->nr; ++i)\n\t\tprinted += fprintf(fp, \"%s%d\", i ? \", \" : \"\", perf_thread_map__pid(threads, i));\n\n\treturn printed + fprintf(fp, \"\\n\");\n}\n\nstatic int get_comm(char **comm, pid_t pid)\n{\n\tchar *path;\n\tsize_t size;\n\tint err;\n\n\tif (asprintf(&path, \"%s/%d/comm\", procfs__mountpoint(), pid) == -1)\n\t\treturn -ENOMEM;\n\n\terr = filename__read_str(path, comm, &size);\n\tif (!err) {\n\t\t \n\t\t(*comm)[size] = 0;\n\t\tstrim(*comm);\n\t}\n\n\tfree(path);\n\treturn err;\n}\n\nstatic void comm_init(struct perf_thread_map *map, int i)\n{\n\tpid_t pid = perf_thread_map__pid(map, i);\n\tchar *comm = NULL;\n\n\t \n\tif (pid == -1) {\n\t\tmap->map[i].comm = strdup(\"dummy\");\n\t\treturn;\n\t}\n\n\t \n\tif (get_comm(&comm, pid))\n\t\tpr_warning(\"Couldn't resolve comm name for pid %d\\n\", pid);\n\n\tmap->map[i].comm = comm;\n}\n\nvoid thread_map__read_comms(struct perf_thread_map *threads)\n{\n\tint i;\n\n\tfor (i = 0; i < threads->nr; ++i)\n\t\tcomm_init(threads, i);\n}\n\nstatic void thread_map__copy_event(struct perf_thread_map *threads,\n\t\t\t\t   struct perf_record_thread_map *event)\n{\n\tunsigned i;\n\n\tthreads->nr = (int) event->nr;\n\n\tfor (i = 0; i < event->nr; i++) {\n\t\tperf_thread_map__set_pid(threads, i, (pid_t) event->entries[i].pid);\n\t\tthreads->map[i].comm = strndup(event->entries[i].comm, 16);\n\t}\n\n\trefcount_set(&threads->refcnt, 1);\n}\n\nstruct perf_thread_map *thread_map__new_event(struct perf_record_thread_map *event)\n{\n\tstruct perf_thread_map *threads;\n\n\tthreads = thread_map__alloc(event->nr);\n\tif (threads)\n\t\tthread_map__copy_event(threads, event);\n\n\treturn threads;\n}\n\nbool thread_map__has(struct perf_thread_map *threads, pid_t pid)\n{\n\tint i;\n\n\tfor (i = 0; i < threads->nr; ++i) {\n\t\tif (threads->map[i].pid == pid)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint thread_map__remove(struct perf_thread_map *threads, int idx)\n{\n\tint i;\n\n\tif (threads->nr < 1)\n\t\treturn -EINVAL;\n\n\tif (idx >= threads->nr)\n\t\treturn -EINVAL;\n\n\t \n\tzfree(&threads->map[idx].comm);\n\n\tfor (i = idx; i < threads->nr - 1; i++)\n\t\tthreads->map[i] = threads->map[i + 1];\n\n\tthreads->nr--;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}