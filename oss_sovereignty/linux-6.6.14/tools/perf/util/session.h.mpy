{
  "module_name": "session.h",
  "hash_id": "31019b24e31a84c6a5f8da45ba02346603b3a364be76fea0baee36eb0a3241ff",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/session.h",
  "human_readable_source": " \n#ifndef __PERF_SESSION_H\n#define __PERF_SESSION_H\n\n#include \"trace-event.h\"\n#include \"event.h\"\n#include \"header.h\"\n#include \"machine.h\"\n#include \"data.h\"\n#include \"ordered-events.h\"\n#include \"util/compress.h\"\n#include <linux/kernel.h>\n#include <linux/rbtree.h>\n#include <linux/perf_event.h>\n\nstruct ip_callchain;\nstruct symbol;\nstruct thread;\n\nstruct auxtrace;\nstruct itrace_synth_opts;\n\nstruct decomp_data {\n\tstruct decomp\t *decomp;\n\tstruct decomp\t *decomp_last;\n\tstruct zstd_data *zstd_decomp;\n};\n\nstruct perf_session {\n\tstruct perf_header\theader;\n\tstruct machines\t\tmachines;\n\tstruct evlist\t*evlist;\n\tstruct auxtrace\t\t*auxtrace;\n\tstruct itrace_synth_opts *itrace_synth_opts;\n\tstruct list_head\tauxtrace_index;\n#ifdef HAVE_LIBTRACEEVENT\n\tstruct trace_event\ttevent;\n#endif\n\tstruct perf_record_time_conv\ttime_conv;\n\tbool\t\t\trepipe;\n\tbool\t\t\tone_mmap;\n\tvoid\t\t\t*one_mmap_addr;\n\tu64\t\t\tone_mmap_offset;\n\tstruct ordered_events\tordered_events;\n\tstruct perf_data\t*data;\n\tstruct perf_tool\t*tool;\n\tu64\t\t\tbytes_transferred;\n\tu64\t\t\tbytes_compressed;\n\tstruct zstd_data\tzstd_data;\n\tstruct decomp_data\tdecomp_data;\n\tstruct decomp_data\t*active_decomp;\n};\n\nstruct decomp {\n\tstruct decomp *next;\n\tu64 file_pos;\n\tconst char *file_path;\n\tsize_t mmap_len;\n\tu64 head;\n\tsize_t size;\n\tchar data[];\n};\n\nstruct perf_tool;\n\nstruct perf_session *__perf_session__new(struct perf_data *data,\n\t\t\t\t\t bool repipe, int repipe_fd,\n\t\t\t\t\t struct perf_tool *tool);\n\nstatic inline struct perf_session *perf_session__new(struct perf_data *data,\n\t\t\t\t\t\t     struct perf_tool *tool)\n{\n\treturn __perf_session__new(data, false, -1, tool);\n}\n\nvoid perf_session__delete(struct perf_session *session);\n\nvoid perf_event_header__bswap(struct perf_event_header *hdr);\n\nint perf_session__peek_event(struct perf_session *session, off_t file_offset,\n\t\t\t     void *buf, size_t buf_sz,\n\t\t\t     union perf_event **event_ptr,\n\t\t\t     struct perf_sample *sample);\ntypedef int (*peek_events_cb_t)(struct perf_session *session,\n\t\t\t\tunion perf_event *event, u64 offset,\n\t\t\t\tvoid *data);\nint perf_session__peek_events(struct perf_session *session, u64 offset,\n\t\t\t      u64 size, peek_events_cb_t cb, void *data);\n\nint perf_session__process_events(struct perf_session *session);\n\nint perf_session__queue_event(struct perf_session *s, union perf_event *event,\n\t\t\t      u64 timestamp, u64 file_offset, const char *file_path);\n\nvoid perf_tool__fill_defaults(struct perf_tool *tool);\n\nint perf_session__resolve_callchain(struct perf_session *session,\n\t\t\t\t    struct evsel *evsel,\n\t\t\t\t    struct thread *thread,\n\t\t\t\t    struct ip_callchain *chain,\n\t\t\t\t    struct symbol **parent);\n\nbool perf_session__has_traces(struct perf_session *session, const char *msg);\n\nvoid perf_event__attr_swap(struct perf_event_attr *attr);\n\nint perf_session__create_kernel_maps(struct perf_session *session);\n\nvoid perf_session__set_id_hdr_size(struct perf_session *session);\n\nstatic inline\nstruct machine *perf_session__find_machine(struct perf_session *session, pid_t pid)\n{\n\treturn machines__find(&session->machines, pid);\n}\n\nstatic inline\nstruct machine *perf_session__findnew_machine(struct perf_session *session, pid_t pid)\n{\n\treturn machines__findnew(&session->machines, pid);\n}\n\nstruct thread *perf_session__findnew(struct perf_session *session, pid_t pid);\nint perf_session__register_idle_thread(struct perf_session *session);\n\nsize_t perf_session__fprintf(struct perf_session *session, FILE *fp);\n\nsize_t perf_session__fprintf_dsos(struct perf_session *session, FILE *fp);\n\nsize_t perf_session__fprintf_dsos_buildid(struct perf_session *session, FILE *fp,\n\t\t\t\t\t  bool (fn)(struct dso *dso, int parm), int parm);\n\nsize_t perf_session__fprintf_nr_events(struct perf_session *session, FILE *fp,\n\t\t\t\t       bool skip_empty);\n\nstruct evsel *perf_session__find_first_evtype(struct perf_session *session,\n\t\t\t\t\t    unsigned int type);\n\nint perf_session__cpu_bitmap(struct perf_session *session,\n\t\t\t     const char *cpu_list, unsigned long *cpu_bitmap);\n\nvoid perf_session__fprintf_info(struct perf_session *s, FILE *fp, bool full);\n\nstruct evsel_str_handler;\n\n#define perf_session__set_tracepoints_handlers(session, array) \\\n\t__evlist__set_tracepoints_handlers(session->evlist, array, ARRAY_SIZE(array))\n\nextern volatile int session_done;\n\n#define session_done()\tREAD_ONCE(session_done)\n\nint perf_session__deliver_synth_event(struct perf_session *session,\n\t\t\t\t      union perf_event *event,\n\t\t\t\t      struct perf_sample *sample);\n\nint perf_event__process_id_index(struct perf_session *session,\n\t\t\t\t union perf_event *event);\n\nint perf_event__process_finished_round(struct perf_tool *tool,\n\t\t\t\t       union perf_event *event,\n\t\t\t\t       struct ordered_events *oe);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}