{
  "module_name": "data-convert-json.c",
  "hash_id": "291d330657474661899717e57c5fb232758bdf9038286e50e4306affdb4caf55",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/data-convert-json.c",
  "human_readable_source": "\n \n\n#include \"data-convert.h\"\n\n#include <fcntl.h>\n#include <inttypes.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"linux/compiler.h\"\n#include \"linux/err.h\"\n#include \"util/auxtrace.h\"\n#include \"util/debug.h\"\n#include \"util/dso.h\"\n#include \"util/event.h\"\n#include \"util/evsel.h\"\n#include \"util/evlist.h\"\n#include \"util/header.h\"\n#include \"util/map.h\"\n#include \"util/session.h\"\n#include \"util/symbol.h\"\n#include \"util/thread.h\"\n#include \"util/tool.h\"\n\n#ifdef HAVE_LIBTRACEEVENT\n#include <traceevent/event-parse.h>\n#endif\n\nstruct convert_json {\n\tstruct perf_tool tool;\n\tFILE *out;\n\tbool first;\n\tu64 events_count;\n};\n\n\nstatic void output_json_string(FILE *out, const char *s)\n{\n\tfputc('\"', out);\n\twhile (*s) {\n\t\tswitch (*s) {\n\n\t\t\n\t\tcase '\"':  fputs(\"\\\\\\\"\", out); break;\n\t\tcase '\\\\': fputs(\"\\\\\\\\\", out); break;\n\t\tcase '\\b': fputs(\"\\\\b\", out);  break;\n\t\tcase '\\f': fputs(\"\\\\f\", out);  break;\n\t\tcase '\\n': fputs(\"\\\\n\", out);  break;\n\t\tcase '\\r': fputs(\"\\\\r\", out);  break;\n\t\tcase '\\t': fputs(\"\\\\t\", out);  break;\n\n\t\tdefault:\n\t\t\t\n\t\t\tif (*s <= 0x1f)\n\t\t\t\tfprintf(out, \"\\\\u%04x\", *s);\n\t\t\telse\n\t\t\t\tfputc(*s, out);\n\t\t\tbreak;\n\t\t}\n\n\t\t++s;\n\t}\n\tfputc('\"', out);\n}\n\n\n\nstatic void output_json_delimiters(FILE *out, bool comma, int depth)\n{\n\tint i;\n\n\tif (comma)\n\t\tfputc(',', out);\n\tfputc('\\n', out);\n\tfor (i = 0; i < depth; ++i)\n\t\tfputc('\\t', out);\n}\n\n\n__printf(4, 5)\nstatic void output_json_format(FILE *out, bool comma, int depth, const char *format, ...)\n{\n\tva_list args;\n\n\toutput_json_delimiters(out, comma, depth);\n\tva_start(args, format);\n\tvfprintf(out,  format, args);\n\tva_end(args);\n}\n\n\nstatic void output_json_key_string(FILE *out, bool comma, int depth,\n\t\tconst char *key, const char *value)\n{\n\toutput_json_delimiters(out, comma, depth);\n\toutput_json_string(out, key);\n\tfputs(\": \", out);\n\toutput_json_string(out, value);\n}\n\n\n__printf(5, 6)\nstatic void output_json_key_format(FILE *out, bool comma, int depth,\n\t\tconst char *key, const char *format, ...)\n{\n\tva_list args;\n\n\toutput_json_delimiters(out, comma, depth);\n\toutput_json_string(out, key);\n\tfputs(\": \", out);\n\tva_start(args, format);\n\tvfprintf(out,  format, args);\n\tva_end(args);\n}\n\nstatic void output_sample_callchain_entry(struct perf_tool *tool,\n\t\tu64 ip, struct addr_location *al)\n{\n\tstruct convert_json *c = container_of(tool, struct convert_json, tool);\n\tFILE *out = c->out;\n\n\toutput_json_format(out, false, 4, \"{\");\n\toutput_json_key_format(out, false, 5, \"ip\", \"\\\"0x%\" PRIx64 \"\\\"\", ip);\n\n\tif (al && al->sym && al->sym->namelen) {\n\t\tstruct dso *dso = al->map ? map__dso(al->map) : NULL;\n\n\t\tfputc(',', out);\n\t\toutput_json_key_string(out, false, 5, \"symbol\", al->sym->name);\n\n\t\tif (dso) {\n\t\t\tconst char *dso_name = dso->short_name;\n\n\t\t\tif (dso_name && strlen(dso_name) > 0) {\n\t\t\t\tfputc(',', out);\n\t\t\t\toutput_json_key_string(out, false, 5, \"dso\", dso_name);\n\t\t\t}\n\t\t}\n\t}\n\n\toutput_json_format(out, false, 4, \"}\");\n}\n\nstatic int process_sample_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event __maybe_unused,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct evsel *evsel __maybe_unused,\n\t\t\t\tstruct machine *machine)\n{\n\tstruct convert_json *c = container_of(tool, struct convert_json, tool);\n\tFILE *out = c->out;\n\tstruct addr_location al;\n\tu64 sample_type = __evlist__combined_sample_type(evsel->evlist);\n\tu8 cpumode = PERF_RECORD_MISC_USER;\n\n\taddr_location__init(&al);\n\tif (machine__resolve(machine, &al, sample) < 0) {\n\t\tpr_err(\"Sample resolution failed!\\n\");\n\t\taddr_location__exit(&al);\n\t\treturn -1;\n\t}\n\n\t++c->events_count;\n\n\tif (c->first)\n\t\tc->first = false;\n\telse\n\t\tfputc(',', out);\n\toutput_json_format(out, false, 2, \"{\");\n\n\toutput_json_key_format(out, false, 3, \"timestamp\", \"%\" PRIi64, sample->time);\n\toutput_json_key_format(out, true, 3, \"pid\", \"%i\", thread__pid(al.thread));\n\toutput_json_key_format(out, true, 3, \"tid\", \"%i\", thread__tid(al.thread));\n\n\tif ((sample_type & PERF_SAMPLE_CPU))\n\t\toutput_json_key_format(out, true, 3, \"cpu\", \"%i\", sample->cpu);\n\telse if (thread__cpu(al.thread) >= 0)\n\t\toutput_json_key_format(out, true, 3, \"cpu\", \"%i\", thread__cpu(al.thread));\n\n\toutput_json_key_string(out, true, 3, \"comm\", thread__comm_str(al.thread));\n\n\toutput_json_key_format(out, true, 3, \"callchain\", \"[\");\n\tif (sample->callchain) {\n\t\tunsigned int i;\n\t\tbool ok;\n\t\tbool first_callchain = true;\n\n\t\tfor (i = 0; i < sample->callchain->nr; ++i) {\n\t\t\tu64 ip = sample->callchain->ips[i];\n\t\t\tstruct addr_location tal;\n\n\t\t\tif (ip >= PERF_CONTEXT_MAX) {\n\t\t\t\tswitch (ip) {\n\t\t\t\tcase PERF_CONTEXT_HV:\n\t\t\t\t\tcpumode = PERF_RECORD_MISC_HYPERVISOR;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PERF_CONTEXT_KERNEL:\n\t\t\t\t\tcpumode = PERF_RECORD_MISC_KERNEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PERF_CONTEXT_USER:\n\t\t\t\t\tcpumode = PERF_RECORD_MISC_USER;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tpr_debug(\"invalid callchain context: %\"\n\t\t\t\t\t\t\tPRId64 \"\\n\", (s64) ip);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first_callchain)\n\t\t\t\tfirst_callchain = false;\n\t\t\telse\n\t\t\t\tfputc(',', out);\n\n\t\t\taddr_location__init(&tal);\n\t\t\tok = thread__find_symbol(al.thread, cpumode, ip, &tal);\n\t\t\toutput_sample_callchain_entry(tool, ip, ok ? &tal : NULL);\n\t\t\taddr_location__exit(&tal);\n\t\t}\n\t} else {\n\t\toutput_sample_callchain_entry(tool, sample->ip, &al);\n\t}\n\toutput_json_format(out, false, 3, \"]\");\n\n#ifdef HAVE_LIBTRACEEVENT\n\tif (sample->raw_data) {\n\t\tint i;\n\t\tstruct tep_format_field **fields;\n\n\t\tfields = tep_event_fields(evsel->tp_format);\n\t\tif (fields) {\n\t\t\ti = 0;\n\t\t\twhile (fields[i]) {\n\t\t\t\tstruct trace_seq s;\n\n\t\t\t\ttrace_seq_init(&s);\n\t\t\t\ttep_print_field(&s, sample->raw_data, fields[i]);\n\t\t\t\toutput_json_key_string(out, true, 3, fields[i]->name, s.buffer);\n\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfree(fields);\n\t\t}\n\t}\n#endif\n\toutput_json_format(out, false, 2, \"}\");\n\taddr_location__exit(&al);\n\treturn 0;\n}\n\nstatic void output_headers(struct perf_session *session, struct convert_json *c)\n{\n\tstruct stat st;\n\tstruct perf_header *header = &session->header;\n\tint ret;\n\tint fd = perf_data__fd(session->data);\n\tint i;\n\tFILE *out = c->out;\n\n\toutput_json_key_format(out, false, 2, \"header-version\", \"%u\", header->version);\n\n\tret = fstat(fd, &st);\n\tif (ret >= 0) {\n\t\ttime_t stctime = st.st_mtime;\n\t\tchar buf[256];\n\n\t\tstrftime(buf, sizeof(buf), \"%FT%TZ\", gmtime(&stctime));\n\t\toutput_json_key_string(out, true, 2, \"captured-on\", buf);\n\t} else {\n\t\tpr_debug(\"Failed to get mtime of source file, not writing captured-on\");\n\t}\n\n\toutput_json_key_format(out, true, 2, \"data-offset\", \"%\" PRIu64, header->data_offset);\n\toutput_json_key_format(out, true, 2, \"data-size\", \"%\" PRIu64, header->data_size);\n\toutput_json_key_format(out, true, 2, \"feat-offset\", \"%\" PRIu64, header->feat_offset);\n\n\toutput_json_key_string(out, true, 2, \"hostname\", header->env.hostname);\n\toutput_json_key_string(out, true, 2, \"os-release\", header->env.os_release);\n\toutput_json_key_string(out, true, 2, \"arch\", header->env.arch);\n\n\toutput_json_key_string(out, true, 2, \"cpu-desc\", header->env.cpu_desc);\n\toutput_json_key_string(out, true, 2, \"cpuid\", header->env.cpuid);\n\toutput_json_key_format(out, true, 2, \"nrcpus-online\", \"%u\", header->env.nr_cpus_online);\n\toutput_json_key_format(out, true, 2, \"nrcpus-avail\", \"%u\", header->env.nr_cpus_avail);\n\n\tif (header->env.clock.enabled) {\n\t\toutput_json_key_format(out, true, 2, \"clockid\",\n\t\t\t\t\"%u\", header->env.clock.clockid);\n\t\toutput_json_key_format(out, true, 2, \"clock-time\",\n\t\t\t\t\"%\" PRIu64, header->env.clock.clockid_ns);\n\t\toutput_json_key_format(out, true, 2, \"real-time\",\n\t\t\t\t\"%\" PRIu64, header->env.clock.tod_ns);\n\t}\n\n\toutput_json_key_string(out, true, 2, \"perf-version\", header->env.version);\n\n\toutput_json_key_format(out, true, 2, \"cmdline\", \"[\");\n\tfor (i = 0; i < header->env.nr_cmdline; i++) {\n\t\toutput_json_delimiters(out, i != 0, 3);\n\t\toutput_json_string(c->out, header->env.cmdline_argv[i]);\n\t}\n\toutput_json_format(out, false, 2, \"]\");\n}\n\nint bt_convert__perf2json(const char *input_name, const char *output_name,\n\t\tstruct perf_data_convert_opts *opts __maybe_unused)\n{\n\tstruct perf_session *session;\n\tint fd;\n\tint ret = -1;\n\n\tstruct convert_json c = {\n\t\t.tool = {\n\t\t\t.sample         = process_sample_event,\n\t\t\t.mmap           = perf_event__process_mmap,\n\t\t\t.mmap2          = perf_event__process_mmap2,\n\t\t\t.comm           = perf_event__process_comm,\n\t\t\t.namespaces     = perf_event__process_namespaces,\n\t\t\t.cgroup         = perf_event__process_cgroup,\n\t\t\t.exit           = perf_event__process_exit,\n\t\t\t.fork           = perf_event__process_fork,\n\t\t\t.lost           = perf_event__process_lost,\n#ifdef HAVE_LIBTRACEEVENT\n\t\t\t.tracing_data   = perf_event__process_tracing_data,\n#endif\n\t\t\t.build_id       = perf_event__process_build_id,\n\t\t\t.id_index       = perf_event__process_id_index,\n\t\t\t.auxtrace_info  = perf_event__process_auxtrace_info,\n\t\t\t.auxtrace       = perf_event__process_auxtrace,\n\t\t\t.event_update   = perf_event__process_event_update,\n\t\t\t.ordered_events = true,\n\t\t\t.ordering_requires_timestamps = true,\n\t\t},\n\t\t.first = true,\n\t\t.events_count = 0,\n\t};\n\n\tstruct perf_data data = {\n\t\t.mode = PERF_DATA_MODE_READ,\n\t\t.path = input_name,\n\t\t.force = opts->force,\n\t};\n\n\tif (opts->all) {\n\t\tpr_err(\"--all is currently unsupported for JSON output.\\n\");\n\t\tgoto err;\n\t}\n\tif (opts->tod) {\n\t\tpr_err(\"--tod is currently unsupported for JSON output.\\n\");\n\t\tgoto err;\n\t}\n\n\tfd = open(output_name, O_CREAT | O_WRONLY | (opts->force ? O_TRUNC : O_EXCL), 0666);\n\tif (fd == -1) {\n\t\tif (errno == EEXIST)\n\t\t\tpr_err(\"Output file exists. Use --force to overwrite it.\\n\");\n\t\telse\n\t\t\tpr_err(\"Error opening output file!\\n\");\n\t\tgoto err;\n\t}\n\n\tc.out = fdopen(fd, \"w\");\n\tif (!c.out) {\n\t\tfprintf(stderr, \"Error opening output file!\\n\");\n\t\tclose(fd);\n\t\tgoto err;\n\t}\n\n\tsession = perf_session__new(&data, &c.tool);\n\tif (IS_ERR(session)) {\n\t\tfprintf(stderr, \"Error creating perf session!\\n\");\n\t\tgoto err_fclose;\n\t}\n\n\tif (symbol__init(&session->header.env) < 0) {\n\t\tfprintf(stderr, \"Symbol init error!\\n\");\n\t\tgoto err_session_delete;\n\t}\n\n\t\n\t\n\tfputc('{', c.out);\n\n\t\n\t\n\t\n\toutput_json_format(c.out, false, 1, \"\\\"linux-perf-json-version\\\": 1\");\n\n\t\n\toutput_json_format(c.out, true, 1, \"\\\"headers\\\": {\");\n\toutput_headers(session, &c);\n\toutput_json_format(c.out, false, 1, \"}\");\n\n\t\n\toutput_json_format(c.out, true, 1, \"\\\"samples\\\": [\");\n\tperf_session__process_events(session);\n\toutput_json_format(c.out, false, 1, \"]\");\n\toutput_json_format(c.out, false, 0, \"}\");\n\tfputc('\\n', c.out);\n\n\tfprintf(stderr,\n\t\t\t\"[ perf data convert: Converted '%s' into JSON data '%s' ]\\n\",\n\t\t\tdata.path, output_name);\n\n\tfprintf(stderr,\n\t\t\t\"[ perf data convert: Converted and wrote %.3f MB (%\" PRIu64 \" samples) ]\\n\",\n\t\t\t(ftell(c.out)) / 1024.0 / 1024.0, c.events_count);\n\n\tret = 0;\nerr_session_delete:\n\tperf_session__delete(session);\nerr_fclose:\n\tfclose(c.out);\nerr:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}