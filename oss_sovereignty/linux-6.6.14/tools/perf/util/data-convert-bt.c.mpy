{
  "module_name": "data-convert-bt.c",
  "hash_id": "8cb934efb45f44f9710983442e7e9eb0ee7eb06bb87255c5b76fc2202b5a960d",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/data-convert-bt.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <inttypes.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/zalloc.h>\n#include <babeltrace/ctf-writer/writer.h>\n#include <babeltrace/ctf-writer/clock.h>\n#include <babeltrace/ctf-writer/stream.h>\n#include <babeltrace/ctf-writer/event.h>\n#include <babeltrace/ctf-writer/event-types.h>\n#include <babeltrace/ctf-writer/event-fields.h>\n#include <babeltrace/ctf-ir/utils.h>\n#include <babeltrace/ctf/events.h>\n#include \"asm/bug.h\"\n#include \"data-convert.h\"\n#include \"session.h\"\n#include \"debug.h\"\n#include \"tool.h\"\n#include \"evlist.h\"\n#include \"evsel.h\"\n#include \"machine.h\"\n#include \"config.h\"\n#include <linux/ctype.h>\n#include <linux/err.h>\n#include <linux/time64.h>\n#include \"util.h\"\n#include \"clockid.h\"\n#include \"util/sample.h\"\n\n#ifdef HAVE_LIBTRACEEVENT\n#include <traceevent/event-parse.h>\n#endif\n\n#define pr_N(n, fmt, ...) \\\n\teprintf(n, debug_data_convert, fmt, ##__VA_ARGS__)\n\n#define pr(fmt, ...)  pr_N(1, pr_fmt(fmt), ##__VA_ARGS__)\n#define pr2(fmt, ...) pr_N(2, pr_fmt(fmt), ##__VA_ARGS__)\n\n#define pr_time2(t, fmt, ...) pr_time_N(2, debug_data_convert, t, pr_fmt(fmt), ##__VA_ARGS__)\n\nstruct evsel_priv {\n\tstruct bt_ctf_event_class *event_class;\n};\n\n#define MAX_CPUS\t4096\n\nstruct ctf_stream {\n\tstruct bt_ctf_stream *stream;\n\tint cpu;\n\tu32 count;\n};\n\nstruct ctf_writer {\n\t \n\tstruct bt_ctf_writer\t\t *writer;\n\tstruct ctf_stream\t\t**stream;\n\tint\t\t\t\t  stream_cnt;\n\tstruct bt_ctf_stream_class\t *stream_class;\n\tstruct bt_ctf_clock\t\t *clock;\n\n\t \n\tunion {\n\t\tstruct {\n\t\t\tstruct bt_ctf_field_type\t*s64;\n\t\t\tstruct bt_ctf_field_type\t*u64;\n\t\t\tstruct bt_ctf_field_type\t*s32;\n\t\t\tstruct bt_ctf_field_type\t*u32;\n\t\t\tstruct bt_ctf_field_type\t*string;\n\t\t\tstruct bt_ctf_field_type\t*u32_hex;\n\t\t\tstruct bt_ctf_field_type\t*u64_hex;\n\t\t};\n\t\tstruct bt_ctf_field_type *array[6];\n\t} data;\n\tstruct bt_ctf_event_class\t*comm_class;\n\tstruct bt_ctf_event_class\t*exit_class;\n\tstruct bt_ctf_event_class\t*fork_class;\n\tstruct bt_ctf_event_class\t*mmap_class;\n\tstruct bt_ctf_event_class\t*mmap2_class;\n};\n\nstruct convert {\n\tstruct perf_tool\ttool;\n\tstruct ctf_writer\twriter;\n\n\tu64\t\t\tevents_size;\n\tu64\t\t\tevents_count;\n\tu64\t\t\tnon_sample_count;\n\n\t \n\tu64\t\t\tqueue_size;\n};\n\nstatic int value_set(struct bt_ctf_field_type *type,\n\t\t     struct bt_ctf_event *event,\n\t\t     const char *name, u64 val)\n{\n\tstruct bt_ctf_field *field;\n\tbool sign = bt_ctf_field_type_integer_get_signed(type);\n\tint ret;\n\n\tfield = bt_ctf_field_create(type);\n\tif (!field) {\n\t\tpr_err(\"failed to create a field %s\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (sign) {\n\t\tret = bt_ctf_field_signed_integer_set_value(field, val);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set field value %s\\n\", name);\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tret = bt_ctf_field_unsigned_integer_set_value(field, val);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set field value %s\\n\", name);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = bt_ctf_event_set_payload(event, name, field);\n\tif (ret) {\n\t\tpr_err(\"failed to set payload %s\\n\", name);\n\t\tgoto err;\n\t}\n\n\tpr2(\"  SET [%s = %\" PRIu64 \"]\\n\", name, val);\n\nerr:\n\tbt_ctf_field_put(field);\n\treturn ret;\n}\n\n#define __FUNC_VALUE_SET(_name, _val_type)\t\t\t\t\\\nstatic __maybe_unused int value_set_##_name(struct ctf_writer *cw,\t\\\n\t\t\t     struct bt_ctf_event *event,\t\t\\\n\t\t\t     const char *name,\t\t\t\t\\\n\t\t\t     _val_type val)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bt_ctf_field_type *type = cw->data._name;\t\t\\\n\treturn value_set(type, event, name, (u64) val);\t\t\t\\\n}\n\n#define FUNC_VALUE_SET(_name) __FUNC_VALUE_SET(_name, _name)\n\nFUNC_VALUE_SET(s32)\nFUNC_VALUE_SET(u32)\nFUNC_VALUE_SET(s64)\nFUNC_VALUE_SET(u64)\n__FUNC_VALUE_SET(u64_hex, u64)\n\nstatic int string_set_value(struct bt_ctf_field *field, const char *string);\nstatic __maybe_unused int\nvalue_set_string(struct ctf_writer *cw, struct bt_ctf_event *event,\n\t\t const char *name, const char *string)\n{\n\tstruct bt_ctf_field_type *type = cw->data.string;\n\tstruct bt_ctf_field *field;\n\tint ret = 0;\n\n\tfield = bt_ctf_field_create(type);\n\tif (!field) {\n\t\tpr_err(\"failed to create a field %s\\n\", name);\n\t\treturn -1;\n\t}\n\n\tret = string_set_value(field, string);\n\tif (ret) {\n\t\tpr_err(\"failed to set value %s\\n\", name);\n\t\tgoto err_put_field;\n\t}\n\n\tret = bt_ctf_event_set_payload(event, name, field);\n\tif (ret)\n\t\tpr_err(\"failed to set payload %s\\n\", name);\n\nerr_put_field:\n\tbt_ctf_field_put(field);\n\treturn ret;\n}\n\nstatic struct bt_ctf_field_type*\nget_tracepoint_field_type(struct ctf_writer *cw, struct tep_format_field *field)\n{\n\tunsigned long flags = field->flags;\n\n\tif (flags & TEP_FIELD_IS_STRING)\n\t\treturn cw->data.string;\n\n\tif (!(flags & TEP_FIELD_IS_SIGNED)) {\n\t\t \n\t\tif (flags & TEP_FIELD_IS_LONG || flags & TEP_FIELD_IS_POINTER)\n\t\t\treturn cw->data.u64_hex;\n\t}\n\n\tif (flags & TEP_FIELD_IS_SIGNED) {\n\t\tif (field->size == 8)\n\t\t\treturn cw->data.s64;\n\t\telse\n\t\t\treturn cw->data.s32;\n\t}\n\n\tif (field->size == 8)\n\t\treturn cw->data.u64;\n\telse\n\t\treturn cw->data.u32;\n}\n\nstatic unsigned long long adjust_signedness(unsigned long long value_int, int size)\n{\n\tunsigned long long value_mask;\n\n\t \n\tswitch (size) {\n\tcase 1:\n\t\tvalue_mask = 0x7fULL;\n\t\tbreak;\n\tcase 2:\n\t\tvalue_mask = 0x7fffULL;\n\t\tbreak;\n\tcase 4:\n\t\tvalue_mask = 0x7fffffffULL;\n\t\tbreak;\n\tcase 8:\n\t\t \n\t\t \n\tdefault:\n\t\t \n\t\treturn value_int;\n\t}\n\n\t \n\tif ((value_int & (~0ULL - value_mask)) == 0)\n\t\treturn value_int;\n\n\t \n\treturn (value_int & value_mask) | ~value_mask;\n}\n\nstatic int string_set_value(struct bt_ctf_field *field, const char *string)\n{\n\tchar *buffer = NULL;\n\tsize_t len = strlen(string), i, p;\n\tint err;\n\n\tfor (i = p = 0; i < len; i++, p++) {\n\t\tif (isprint(string[i])) {\n\t\t\tif (!buffer)\n\t\t\t\tcontinue;\n\t\t\tbuffer[p] = string[i];\n\t\t} else {\n\t\t\tchar numstr[5];\n\n\t\t\tsnprintf(numstr, sizeof(numstr), \"\\\\x%02x\",\n\t\t\t\t (unsigned int)(string[i]) & 0xff);\n\n\t\t\tif (!buffer) {\n\t\t\t\tbuffer = zalloc(i + (len - i) * 4 + 2);\n\t\t\t\tif (!buffer) {\n\t\t\t\t\tpr_err(\"failed to set unprintable string '%s'\\n\", string);\n\t\t\t\t\treturn bt_ctf_field_string_set_value(field, \"UNPRINTABLE-STRING\");\n\t\t\t\t}\n\t\t\t\tif (i > 0)\n\t\t\t\t\tstrncpy(buffer, string, i);\n\t\t\t}\n\t\t\tmemcpy(buffer + p, numstr, 4);\n\t\t\tp += 3;\n\t\t}\n\t}\n\n\tif (!buffer)\n\t\treturn bt_ctf_field_string_set_value(field, string);\n\terr = bt_ctf_field_string_set_value(field, buffer);\n\tfree(buffer);\n\treturn err;\n}\n\nstatic int add_tracepoint_field_value(struct ctf_writer *cw,\n\t\t\t\t      struct bt_ctf_event_class *event_class,\n\t\t\t\t      struct bt_ctf_event *event,\n\t\t\t\t      struct perf_sample *sample,\n\t\t\t\t      struct tep_format_field *fmtf)\n{\n\tstruct bt_ctf_field_type *type;\n\tstruct bt_ctf_field *array_field;\n\tstruct bt_ctf_field *field;\n\tconst char *name = fmtf->name;\n\tvoid *data = sample->raw_data;\n\tunsigned long flags = fmtf->flags;\n\tunsigned int n_items;\n\tunsigned int i;\n\tunsigned int offset;\n\tunsigned int len;\n\tint ret;\n\n\tname = fmtf->alias;\n\toffset = fmtf->offset;\n\tlen = fmtf->size;\n\tif (flags & TEP_FIELD_IS_STRING)\n\t\tflags &= ~TEP_FIELD_IS_ARRAY;\n\n\tif (flags & TEP_FIELD_IS_DYNAMIC) {\n\t\tunsigned long long tmp_val;\n\n\t\ttmp_val = tep_read_number(fmtf->event->tep,\n\t\t\t\t\t  data + offset, len);\n\t\toffset = tmp_val;\n\t\tlen = offset >> 16;\n\t\toffset &= 0xffff;\n\t\tif (tep_field_is_relative(flags))\n\t\t\toffset += fmtf->offset + fmtf->size;\n\t}\n\n\tif (flags & TEP_FIELD_IS_ARRAY) {\n\n\t\ttype = bt_ctf_event_class_get_field_by_name(\n\t\t\t\tevent_class, name);\n\t\tarray_field = bt_ctf_field_create(type);\n\t\tbt_ctf_field_type_put(type);\n\t\tif (!array_field) {\n\t\t\tpr_err(\"Failed to create array type %s\\n\", name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = fmtf->size / fmtf->arraylen;\n\t\tn_items = fmtf->arraylen;\n\t} else {\n\t\tn_items = 1;\n\t\tarray_field = NULL;\n\t}\n\n\ttype = get_tracepoint_field_type(cw, fmtf);\n\n\tfor (i = 0; i < n_items; i++) {\n\t\tif (flags & TEP_FIELD_IS_ARRAY)\n\t\t\tfield = bt_ctf_field_array_get_field(array_field, i);\n\t\telse\n\t\t\tfield = bt_ctf_field_create(type);\n\n\t\tif (!field) {\n\t\t\tpr_err(\"failed to create a field %s\\n\", name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (flags & TEP_FIELD_IS_STRING)\n\t\t\tret = string_set_value(field, data + offset + i * len);\n\t\telse {\n\t\t\tunsigned long long value_int;\n\n\t\t\tvalue_int = tep_read_number(\n\t\t\t\t\tfmtf->event->tep,\n\t\t\t\t\tdata + offset + i * len, len);\n\n\t\t\tif (!(flags & TEP_FIELD_IS_SIGNED))\n\t\t\t\tret = bt_ctf_field_unsigned_integer_set_value(\n\t\t\t\t\t\tfield, value_int);\n\t\t\telse\n\t\t\t\tret = bt_ctf_field_signed_integer_set_value(\n\t\t\t\t\t\tfield, adjust_signedness(value_int, len));\n\t\t}\n\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set file value %s\\n\", name);\n\t\t\tgoto err_put_field;\n\t\t}\n\t\tif (!(flags & TEP_FIELD_IS_ARRAY)) {\n\t\t\tret = bt_ctf_event_set_payload(event, name, field);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"failed to set payload %s\\n\", name);\n\t\t\t\tgoto err_put_field;\n\t\t\t}\n\t\t}\n\t\tbt_ctf_field_put(field);\n\t}\n\tif (flags & TEP_FIELD_IS_ARRAY) {\n\t\tret = bt_ctf_event_set_payload(event, name, array_field);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed add payload array %s\\n\", name);\n\t\t\treturn -1;\n\t\t}\n\t\tbt_ctf_field_put(array_field);\n\t}\n\treturn 0;\n\nerr_put_field:\n\tbt_ctf_field_put(field);\n\treturn -1;\n}\n\nstatic int add_tracepoint_fields_values(struct ctf_writer *cw,\n\t\t\t\t\tstruct bt_ctf_event_class *event_class,\n\t\t\t\t\tstruct bt_ctf_event *event,\n\t\t\t\t\tstruct tep_format_field *fields,\n\t\t\t\t\tstruct perf_sample *sample)\n{\n\tstruct tep_format_field *field;\n\tint ret;\n\n\tfor (field = fields; field; field = field->next) {\n\t\tret = add_tracepoint_field_value(cw, event_class, event, sample,\n\t\t\t\tfield);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int add_tracepoint_values(struct ctf_writer *cw,\n\t\t\t\t struct bt_ctf_event_class *event_class,\n\t\t\t\t struct bt_ctf_event *event,\n\t\t\t\t struct evsel *evsel,\n\t\t\t\t struct perf_sample *sample)\n{\n\tstruct tep_format_field *common_fields = evsel->tp_format->format.common_fields;\n\tstruct tep_format_field *fields        = evsel->tp_format->format.fields;\n\tint ret;\n\n\tret = add_tracepoint_fields_values(cw, event_class, event,\n\t\t\t\t\t   common_fields, sample);\n\tif (!ret)\n\t\tret = add_tracepoint_fields_values(cw, event_class, event,\n\t\t\t\t\t\t   fields, sample);\n\n\treturn ret;\n}\n\nstatic int\nadd_bpf_output_values(struct bt_ctf_event_class *event_class,\n\t\t      struct bt_ctf_event *event,\n\t\t      struct perf_sample *sample)\n{\n\tstruct bt_ctf_field_type *len_type, *seq_type;\n\tstruct bt_ctf_field *len_field, *seq_field;\n\tunsigned int raw_size = sample->raw_size;\n\tunsigned int nr_elements = raw_size / sizeof(u32);\n\tunsigned int i;\n\tint ret;\n\n\tif (nr_elements * sizeof(u32) != raw_size)\n\t\tpr_warning(\"Incorrect raw_size (%u) in bpf output event, skip %zu bytes\\n\",\n\t\t\t   raw_size, nr_elements * sizeof(u32) - raw_size);\n\n\tlen_type = bt_ctf_event_class_get_field_by_name(event_class, \"raw_len\");\n\tlen_field = bt_ctf_field_create(len_type);\n\tif (!len_field) {\n\t\tpr_err(\"failed to create 'raw_len' for bpf output event\\n\");\n\t\tret = -1;\n\t\tgoto put_len_type;\n\t}\n\n\tret = bt_ctf_field_unsigned_integer_set_value(len_field, nr_elements);\n\tif (ret) {\n\t\tpr_err(\"failed to set field value for raw_len\\n\");\n\t\tgoto put_len_field;\n\t}\n\tret = bt_ctf_event_set_payload(event, \"raw_len\", len_field);\n\tif (ret) {\n\t\tpr_err(\"failed to set payload to raw_len\\n\");\n\t\tgoto put_len_field;\n\t}\n\n\tseq_type = bt_ctf_event_class_get_field_by_name(event_class, \"raw_data\");\n\tseq_field = bt_ctf_field_create(seq_type);\n\tif (!seq_field) {\n\t\tpr_err(\"failed to create 'raw_data' for bpf output event\\n\");\n\t\tret = -1;\n\t\tgoto put_seq_type;\n\t}\n\n\tret = bt_ctf_field_sequence_set_length(seq_field, len_field);\n\tif (ret) {\n\t\tpr_err(\"failed to set length of 'raw_data'\\n\");\n\t\tgoto put_seq_field;\n\t}\n\n\tfor (i = 0; i < nr_elements; i++) {\n\t\tstruct bt_ctf_field *elem_field =\n\t\t\tbt_ctf_field_sequence_get_field(seq_field, i);\n\n\t\tret = bt_ctf_field_unsigned_integer_set_value(elem_field,\n\t\t\t\t((u32 *)(sample->raw_data))[i]);\n\n\t\tbt_ctf_field_put(elem_field);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set raw_data[%d]\\n\", i);\n\t\t\tgoto put_seq_field;\n\t\t}\n\t}\n\n\tret = bt_ctf_event_set_payload(event, \"raw_data\", seq_field);\n\tif (ret)\n\t\tpr_err(\"failed to set payload for raw_data\\n\");\n\nput_seq_field:\n\tbt_ctf_field_put(seq_field);\nput_seq_type:\n\tbt_ctf_field_type_put(seq_type);\nput_len_field:\n\tbt_ctf_field_put(len_field);\nput_len_type:\n\tbt_ctf_field_type_put(len_type);\n\treturn ret;\n}\n\nstatic int\nadd_callchain_output_values(struct bt_ctf_event_class *event_class,\n\t\t      struct bt_ctf_event *event,\n\t\t      struct ip_callchain *callchain)\n{\n\tstruct bt_ctf_field_type *len_type, *seq_type;\n\tstruct bt_ctf_field *len_field, *seq_field;\n\tunsigned int nr_elements = callchain->nr;\n\tunsigned int i;\n\tint ret;\n\n\tlen_type = bt_ctf_event_class_get_field_by_name(\n\t\t\tevent_class, \"perf_callchain_size\");\n\tlen_field = bt_ctf_field_create(len_type);\n\tif (!len_field) {\n\t\tpr_err(\"failed to create 'perf_callchain_size' for callchain output event\\n\");\n\t\tret = -1;\n\t\tgoto put_len_type;\n\t}\n\n\tret = bt_ctf_field_unsigned_integer_set_value(len_field, nr_elements);\n\tif (ret) {\n\t\tpr_err(\"failed to set field value for perf_callchain_size\\n\");\n\t\tgoto put_len_field;\n\t}\n\tret = bt_ctf_event_set_payload(event, \"perf_callchain_size\", len_field);\n\tif (ret) {\n\t\tpr_err(\"failed to set payload to perf_callchain_size\\n\");\n\t\tgoto put_len_field;\n\t}\n\n\tseq_type = bt_ctf_event_class_get_field_by_name(\n\t\t\tevent_class, \"perf_callchain\");\n\tseq_field = bt_ctf_field_create(seq_type);\n\tif (!seq_field) {\n\t\tpr_err(\"failed to create 'perf_callchain' for callchain output event\\n\");\n\t\tret = -1;\n\t\tgoto put_seq_type;\n\t}\n\n\tret = bt_ctf_field_sequence_set_length(seq_field, len_field);\n\tif (ret) {\n\t\tpr_err(\"failed to set length of 'perf_callchain'\\n\");\n\t\tgoto put_seq_field;\n\t}\n\n\tfor (i = 0; i < nr_elements; i++) {\n\t\tstruct bt_ctf_field *elem_field =\n\t\t\tbt_ctf_field_sequence_get_field(seq_field, i);\n\n\t\tret = bt_ctf_field_unsigned_integer_set_value(elem_field,\n\t\t\t\t((u64 *)(callchain->ips))[i]);\n\n\t\tbt_ctf_field_put(elem_field);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set callchain[%d]\\n\", i);\n\t\t\tgoto put_seq_field;\n\t\t}\n\t}\n\n\tret = bt_ctf_event_set_payload(event, \"perf_callchain\", seq_field);\n\tif (ret)\n\t\tpr_err(\"failed to set payload for raw_data\\n\");\n\nput_seq_field:\n\tbt_ctf_field_put(seq_field);\nput_seq_type:\n\tbt_ctf_field_type_put(seq_type);\nput_len_field:\n\tbt_ctf_field_put(len_field);\nput_len_type:\n\tbt_ctf_field_type_put(len_type);\n\treturn ret;\n}\n\nstatic int add_generic_values(struct ctf_writer *cw,\n\t\t\t      struct bt_ctf_event *event,\n\t\t\t      struct evsel *evsel,\n\t\t\t      struct perf_sample *sample)\n{\n\tu64 type = evsel->core.attr.sample_type;\n\tint ret;\n\n\t \n\n\tif (type & PERF_SAMPLE_IP) {\n\t\tret = value_set_u64_hex(cw, event, \"perf_ip\", sample->ip);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\tif (type & PERF_SAMPLE_TID) {\n\t\tret = value_set_s32(cw, event, \"perf_tid\", sample->tid);\n\t\tif (ret)\n\t\t\treturn -1;\n\n\t\tret = value_set_s32(cw, event, \"perf_pid\", sample->pid);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\tif ((type & PERF_SAMPLE_ID) ||\n\t    (type & PERF_SAMPLE_IDENTIFIER)) {\n\t\tret = value_set_u64(cw, event, \"perf_id\", sample->id);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\tif (type & PERF_SAMPLE_STREAM_ID) {\n\t\tret = value_set_u64(cw, event, \"perf_stream_id\", sample->stream_id);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\tif (type & PERF_SAMPLE_PERIOD) {\n\t\tret = value_set_u64(cw, event, \"perf_period\", sample->period);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\tif (type & PERF_SAMPLE_WEIGHT) {\n\t\tret = value_set_u64(cw, event, \"perf_weight\", sample->weight);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\tif (type & PERF_SAMPLE_DATA_SRC) {\n\t\tret = value_set_u64(cw, event, \"perf_data_src\",\n\t\t\t\tsample->data_src);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\tif (type & PERF_SAMPLE_TRANSACTION) {\n\t\tret = value_set_u64(cw, event, \"perf_transaction\",\n\t\t\t\tsample->transaction);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ctf_stream__flush(struct ctf_stream *cs)\n{\n\tint err = 0;\n\n\tif (cs) {\n\t\terr = bt_ctf_stream_flush(cs->stream);\n\t\tif (err)\n\t\t\tpr_err(\"CTF stream %d flush failed\\n\", cs->cpu);\n\n\t\tpr(\"Flush stream for cpu %d (%u samples)\\n\",\n\t\t   cs->cpu, cs->count);\n\n\t\tcs->count = 0;\n\t}\n\n\treturn err;\n}\n\nstatic struct ctf_stream *ctf_stream__create(struct ctf_writer *cw, int cpu)\n{\n\tstruct ctf_stream *cs;\n\tstruct bt_ctf_field *pkt_ctx   = NULL;\n\tstruct bt_ctf_field *cpu_field = NULL;\n\tstruct bt_ctf_stream *stream   = NULL;\n\tint ret;\n\n\tcs = zalloc(sizeof(*cs));\n\tif (!cs) {\n\t\tpr_err(\"Failed to allocate ctf stream\\n\");\n\t\treturn NULL;\n\t}\n\n\tstream = bt_ctf_writer_create_stream(cw->writer, cw->stream_class);\n\tif (!stream) {\n\t\tpr_err(\"Failed to create CTF stream\\n\");\n\t\tgoto out;\n\t}\n\n\tpkt_ctx = bt_ctf_stream_get_packet_context(stream);\n\tif (!pkt_ctx) {\n\t\tpr_err(\"Failed to obtain packet context\\n\");\n\t\tgoto out;\n\t}\n\n\tcpu_field = bt_ctf_field_structure_get_field(pkt_ctx, \"cpu_id\");\n\tbt_ctf_field_put(pkt_ctx);\n\tif (!cpu_field) {\n\t\tpr_err(\"Failed to obtain cpu field\\n\");\n\t\tgoto out;\n\t}\n\n\tret = bt_ctf_field_unsigned_integer_set_value(cpu_field, (u32) cpu);\n\tif (ret) {\n\t\tpr_err(\"Failed to update CPU number\\n\");\n\t\tgoto out;\n\t}\n\n\tbt_ctf_field_put(cpu_field);\n\n\tcs->cpu    = cpu;\n\tcs->stream = stream;\n\treturn cs;\n\nout:\n\tif (cpu_field)\n\t\tbt_ctf_field_put(cpu_field);\n\tif (stream)\n\t\tbt_ctf_stream_put(stream);\n\n\tfree(cs);\n\treturn NULL;\n}\n\nstatic void ctf_stream__delete(struct ctf_stream *cs)\n{\n\tif (cs) {\n\t\tbt_ctf_stream_put(cs->stream);\n\t\tfree(cs);\n\t}\n}\n\nstatic struct ctf_stream *ctf_stream(struct ctf_writer *cw, int cpu)\n{\n\tstruct ctf_stream *cs = cw->stream[cpu];\n\n\tif (!cs) {\n\t\tcs = ctf_stream__create(cw, cpu);\n\t\tcw->stream[cpu] = cs;\n\t}\n\n\treturn cs;\n}\n\nstatic int get_sample_cpu(struct ctf_writer *cw, struct perf_sample *sample,\n\t\t\t  struct evsel *evsel)\n{\n\tint cpu = 0;\n\n\tif (evsel->core.attr.sample_type & PERF_SAMPLE_CPU)\n\t\tcpu = sample->cpu;\n\n\tif (cpu > cw->stream_cnt) {\n\t\tpr_err(\"Event was recorded for CPU %d, limit is at %d.\\n\",\n\t\t\tcpu, cw->stream_cnt);\n\t\tcpu = 0;\n\t}\n\n\treturn cpu;\n}\n\n#define STREAM_FLUSH_COUNT 100000\n\n \nstatic bool is_flush_needed(struct ctf_stream *cs)\n{\n\treturn cs->count >= STREAM_FLUSH_COUNT;\n}\n\nstatic int process_sample_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *_event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct machine *machine __maybe_unused)\n{\n\tstruct convert *c = container_of(tool, struct convert, tool);\n\tstruct evsel_priv *priv = evsel->priv;\n\tstruct ctf_writer *cw = &c->writer;\n\tstruct ctf_stream *cs;\n\tstruct bt_ctf_event_class *event_class;\n\tstruct bt_ctf_event *event;\n\tint ret;\n\tunsigned long type = evsel->core.attr.sample_type;\n\n\tif (WARN_ONCE(!priv, \"Failed to setup all events.\\n\"))\n\t\treturn 0;\n\n\tevent_class = priv->event_class;\n\n\t \n\tc->events_count++;\n\tc->events_size += _event->header.size;\n\n\tpr_time2(sample->time, \"sample %\" PRIu64 \"\\n\", c->events_count);\n\n\tevent = bt_ctf_event_create(event_class);\n\tif (!event) {\n\t\tpr_err(\"Failed to create an CTF event\\n\");\n\t\treturn -1;\n\t}\n\n\tbt_ctf_clock_set_time(cw->clock, sample->time);\n\n\tret = add_generic_values(cw, event, evsel, sample);\n\tif (ret)\n\t\treturn -1;\n\n\tif (evsel->core.attr.type == PERF_TYPE_TRACEPOINT) {\n\t\tret = add_tracepoint_values(cw, event_class, event,\n\t\t\t\t\t    evsel, sample);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\tif (type & PERF_SAMPLE_CALLCHAIN) {\n\t\tret = add_callchain_output_values(event_class,\n\t\t\t\tevent, sample->callchain);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\tif (evsel__is_bpf_output(evsel)) {\n\t\tret = add_bpf_output_values(event_class, event, sample);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\tcs = ctf_stream(cw, get_sample_cpu(cw, sample, evsel));\n\tif (cs) {\n\t\tif (is_flush_needed(cs))\n\t\t\tctf_stream__flush(cs);\n\n\t\tcs->count++;\n\t\tbt_ctf_stream_append_event(cs->stream, event);\n\t}\n\n\tbt_ctf_event_put(event);\n\treturn cs ? 0 : -1;\n}\n\n#define __NON_SAMPLE_SET_FIELD(_name, _type, _field) \t\\\ndo {\t\t\t\t\t\t\t\\\n\tret = value_set_##_type(cw, event, #_field, _event->_name._field);\\\n\tif (ret)\t\t\t\t\t\\\n\t\treturn -1;\t\t\t\t\\\n} while(0)\n\n#define __FUNC_PROCESS_NON_SAMPLE(_name, body) \t\\\nstatic int process_##_name##_event(struct perf_tool *tool,\t\\\n\t\t\t\t   union perf_event *_event,\t\\\n\t\t\t\t   struct perf_sample *sample,\t\\\n\t\t\t\t   struct machine *machine)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct convert *c = container_of(tool, struct convert, tool);\\\n\tstruct ctf_writer *cw = &c->writer;\t\t\t\\\n\tstruct bt_ctf_event_class *event_class = cw->_name##_class;\\\n\tstruct bt_ctf_event *event;\t\t\t\t\\\n\tstruct ctf_stream *cs;\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tc->non_sample_count++;\t\t\t\t\t\\\n\tc->events_size += _event->header.size;\t\t\t\\\n\tevent = bt_ctf_event_create(event_class);\t\t\\\n\tif (!event) {\t\t\t\t\t\t\\\n\t\tpr_err(\"Failed to create an CTF event\\n\");\t\\\n\t\treturn -1;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tbt_ctf_clock_set_time(cw->clock, sample->time);\t\t\\\n\tbody\t\t\t\t\t\t\t\\\n\tcs = ctf_stream(cw, 0);\t\t\t\t\t\\\n\tif (cs) {\t\t\t\t\t\t\\\n\t\tif (is_flush_needed(cs))\t\t\t\\\n\t\t\tctf_stream__flush(cs);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t\tcs->count++;\t\t\t\t\t\\\n\t\tbt_ctf_stream_append_event(cs->stream, event);\t\\\n\t}\t\t\t\t\t\t\t\\\n\tbt_ctf_event_put(event);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\treturn perf_event__process_##_name(tool, _event, sample, machine);\\\n}\n\n__FUNC_PROCESS_NON_SAMPLE(comm,\n\t__NON_SAMPLE_SET_FIELD(comm, u32, pid);\n\t__NON_SAMPLE_SET_FIELD(comm, u32, tid);\n\t__NON_SAMPLE_SET_FIELD(comm, string, comm);\n)\n__FUNC_PROCESS_NON_SAMPLE(fork,\n\t__NON_SAMPLE_SET_FIELD(fork, u32, pid);\n\t__NON_SAMPLE_SET_FIELD(fork, u32, ppid);\n\t__NON_SAMPLE_SET_FIELD(fork, u32, tid);\n\t__NON_SAMPLE_SET_FIELD(fork, u32, ptid);\n\t__NON_SAMPLE_SET_FIELD(fork, u64, time);\n)\n\n__FUNC_PROCESS_NON_SAMPLE(exit,\n\t__NON_SAMPLE_SET_FIELD(fork, u32, pid);\n\t__NON_SAMPLE_SET_FIELD(fork, u32, ppid);\n\t__NON_SAMPLE_SET_FIELD(fork, u32, tid);\n\t__NON_SAMPLE_SET_FIELD(fork, u32, ptid);\n\t__NON_SAMPLE_SET_FIELD(fork, u64, time);\n)\n__FUNC_PROCESS_NON_SAMPLE(mmap,\n\t__NON_SAMPLE_SET_FIELD(mmap, u32, pid);\n\t__NON_SAMPLE_SET_FIELD(mmap, u32, tid);\n\t__NON_SAMPLE_SET_FIELD(mmap, u64_hex, start);\n\t__NON_SAMPLE_SET_FIELD(mmap, string, filename);\n)\n__FUNC_PROCESS_NON_SAMPLE(mmap2,\n\t__NON_SAMPLE_SET_FIELD(mmap2, u32, pid);\n\t__NON_SAMPLE_SET_FIELD(mmap2, u32, tid);\n\t__NON_SAMPLE_SET_FIELD(mmap2, u64_hex, start);\n\t__NON_SAMPLE_SET_FIELD(mmap2, string, filename);\n)\n#undef __NON_SAMPLE_SET_FIELD\n#undef __FUNC_PROCESS_NON_SAMPLE\n\n \nstatic char *change_name(char *name, char *orig_name, int dup)\n{\n\tchar *new_name = NULL;\n\tsize_t len;\n\n\tif (!name)\n\t\tname = orig_name;\n\n\tif (dup >= 10)\n\t\tgoto out;\n\t \n\tif (dup < 0)\n\t\tlen = strlen(name) + sizeof(\"_\");\n\telse\n\t\tlen = strlen(orig_name) + sizeof(\"_dupl_X\");\n\n\tnew_name = malloc(len);\n\tif (!new_name)\n\t\tgoto out;\n\n\tif (dup < 0)\n\t\tsnprintf(new_name, len, \"_%s\", name);\n\telse\n\t\tsnprintf(new_name, len, \"%s_dupl_%d\", orig_name, dup);\n\nout:\n\tif (name != orig_name)\n\t\tfree(name);\n\treturn new_name;\n}\n\nstatic int event_class_add_field(struct bt_ctf_event_class *event_class,\n\t\tstruct bt_ctf_field_type *type,\n\t\tstruct tep_format_field *field)\n{\n\tstruct bt_ctf_field_type *t = NULL;\n\tchar *name;\n\tint dup = 1;\n\tint ret;\n\n\t \n\tif (field->alias != field->name)\n\t\treturn bt_ctf_event_class_add_field(event_class, type,\n\t\t\t\t(char *)field->alias);\n\n\tname = field->name;\n\n\t \n\tif (bt_ctf_validate_identifier(name))\n\t\tname = change_name(name, field->name, -1);\n\n\tif (!name) {\n\t\tpr_err(\"Failed to fix invalid identifier.\");\n\t\treturn -1;\n\t}\n\twhile ((t = bt_ctf_event_class_get_field_by_name(event_class, name))) {\n\t\tbt_ctf_field_type_put(t);\n\t\tname = change_name(name, field->name, dup++);\n\t\tif (!name) {\n\t\t\tpr_err(\"Failed to create dup name for '%s'\\n\", field->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = bt_ctf_event_class_add_field(event_class, type, name);\n\tif (!ret)\n\t\tfield->alias = name;\n\n\treturn ret;\n}\n\nstatic int add_tracepoint_fields_types(struct ctf_writer *cw,\n\t\t\t\t       struct tep_format_field *fields,\n\t\t\t\t       struct bt_ctf_event_class *event_class)\n{\n\tstruct tep_format_field *field;\n\tint ret;\n\n\tfor (field = fields; field; field = field->next) {\n\t\tstruct bt_ctf_field_type *type;\n\t\tunsigned long flags = field->flags;\n\n\t\tpr2(\"  field '%s'\\n\", field->name);\n\n\t\ttype = get_tracepoint_field_type(cw, field);\n\t\tif (!type)\n\t\t\treturn -1;\n\n\t\t \n\t\tif (flags & TEP_FIELD_IS_STRING)\n\t\t\tflags &= ~TEP_FIELD_IS_ARRAY;\n\n\t\tif (flags & TEP_FIELD_IS_ARRAY)\n\t\t\ttype = bt_ctf_field_type_array_create(type, field->arraylen);\n\n\t\tret = event_class_add_field(event_class, type, field);\n\n\t\tif (flags & TEP_FIELD_IS_ARRAY)\n\t\t\tbt_ctf_field_type_put(type);\n\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to add field '%s': %d\\n\",\n\t\t\t\t\tfield->name, ret);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int add_tracepoint_types(struct ctf_writer *cw,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct bt_ctf_event_class *class)\n{\n\tstruct tep_format_field *common_fields = evsel->tp_format->format.common_fields;\n\tstruct tep_format_field *fields        = evsel->tp_format->format.fields;\n\tint ret;\n\n\tret = add_tracepoint_fields_types(cw, common_fields, class);\n\tif (!ret)\n\t\tret = add_tracepoint_fields_types(cw, fields, class);\n\n\treturn ret;\n}\n\nstatic int add_bpf_output_types(struct ctf_writer *cw,\n\t\t\t\tstruct bt_ctf_event_class *class)\n{\n\tstruct bt_ctf_field_type *len_type = cw->data.u32;\n\tstruct bt_ctf_field_type *seq_base_type = cw->data.u32_hex;\n\tstruct bt_ctf_field_type *seq_type;\n\tint ret;\n\n\tret = bt_ctf_event_class_add_field(class, len_type, \"raw_len\");\n\tif (ret)\n\t\treturn ret;\n\n\tseq_type = bt_ctf_field_type_sequence_create(seq_base_type, \"raw_len\");\n\tif (!seq_type)\n\t\treturn -1;\n\n\treturn bt_ctf_event_class_add_field(class, seq_type, \"raw_data\");\n}\n\nstatic int add_generic_types(struct ctf_writer *cw, struct evsel *evsel,\n\t\t\t     struct bt_ctf_event_class *event_class)\n{\n\tu64 type = evsel->core.attr.sample_type;\n\n\t \n\n#define ADD_FIELD(cl, t, n)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tpr2(\"  field '%s'\\n\", n);\t\t\t\t\\\n\t\tif (bt_ctf_event_class_add_field(cl, t, n)) {\t\t\\\n\t\t\tpr_err(\"Failed to add field '%s';\\n\", n);\t\\\n\t\t\treturn -1;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (type & PERF_SAMPLE_IP)\n\t\tADD_FIELD(event_class, cw->data.u64_hex, \"perf_ip\");\n\n\tif (type & PERF_SAMPLE_TID) {\n\t\tADD_FIELD(event_class, cw->data.s32, \"perf_tid\");\n\t\tADD_FIELD(event_class, cw->data.s32, \"perf_pid\");\n\t}\n\n\tif ((type & PERF_SAMPLE_ID) ||\n\t    (type & PERF_SAMPLE_IDENTIFIER))\n\t\tADD_FIELD(event_class, cw->data.u64, \"perf_id\");\n\n\tif (type & PERF_SAMPLE_STREAM_ID)\n\t\tADD_FIELD(event_class, cw->data.u64, \"perf_stream_id\");\n\n\tif (type & PERF_SAMPLE_PERIOD)\n\t\tADD_FIELD(event_class, cw->data.u64, \"perf_period\");\n\n\tif (type & PERF_SAMPLE_WEIGHT)\n\t\tADD_FIELD(event_class, cw->data.u64, \"perf_weight\");\n\n\tif (type & PERF_SAMPLE_DATA_SRC)\n\t\tADD_FIELD(event_class, cw->data.u64, \"perf_data_src\");\n\n\tif (type & PERF_SAMPLE_TRANSACTION)\n\t\tADD_FIELD(event_class, cw->data.u64, \"perf_transaction\");\n\n\tif (type & PERF_SAMPLE_CALLCHAIN) {\n\t\tADD_FIELD(event_class, cw->data.u32, \"perf_callchain_size\");\n\t\tADD_FIELD(event_class,\n\t\t\tbt_ctf_field_type_sequence_create(\n\t\t\t\tcw->data.u64_hex, \"perf_callchain_size\"),\n\t\t\t\"perf_callchain\");\n\t}\n\n#undef ADD_FIELD\n\treturn 0;\n}\n\nstatic int add_event(struct ctf_writer *cw, struct evsel *evsel)\n{\n\tstruct bt_ctf_event_class *event_class;\n\tstruct evsel_priv *priv;\n\tconst char *name = evsel__name(evsel);\n\tint ret;\n\n\tpr(\"Adding event '%s' (type %d)\\n\", name, evsel->core.attr.type);\n\n\tevent_class = bt_ctf_event_class_create(name);\n\tif (!event_class)\n\t\treturn -1;\n\n\tret = add_generic_types(cw, evsel, event_class);\n\tif (ret)\n\t\tgoto err;\n\n\tif (evsel->core.attr.type == PERF_TYPE_TRACEPOINT) {\n\t\tret = add_tracepoint_types(cw, evsel, event_class);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (evsel__is_bpf_output(evsel)) {\n\t\tret = add_bpf_output_types(cw, event_class);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = bt_ctf_stream_class_add_event_class(cw->stream_class, event_class);\n\tif (ret) {\n\t\tpr(\"Failed to add event class into stream.\\n\");\n\t\tgoto err;\n\t}\n\n\tpriv = malloc(sizeof(*priv));\n\tif (!priv)\n\t\tgoto err;\n\n\tpriv->event_class = event_class;\n\tevsel->priv       = priv;\n\treturn 0;\n\nerr:\n\tbt_ctf_event_class_put(event_class);\n\tpr_err(\"Failed to add event '%s'.\\n\", name);\n\treturn -1;\n}\n\nstatic int setup_events(struct ctf_writer *cw, struct perf_session *session)\n{\n\tstruct evlist *evlist = session->evlist;\n\tstruct evsel *evsel;\n\tint ret;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tret = add_event(cw, evsel);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n#define __NON_SAMPLE_ADD_FIELD(t, n)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tpr2(\"  field '%s'\\n\", #n);\t\t\t\\\n\t\tif (bt_ctf_event_class_add_field(event_class, cw->data.t, #n)) {\\\n\t\t\tpr_err(\"Failed to add field '%s';\\n\", #n);\\\n\t\t\treturn -1;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while(0)\n\n#define __FUNC_ADD_NON_SAMPLE_EVENT_CLASS(_name, body) \t\t\\\nstatic int add_##_name##_event(struct ctf_writer *cw)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct bt_ctf_event_class *event_class;\t\t\t\\\n\tint ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tpr(\"Adding \"#_name\" event\\n\");\t\t\t\t\\\n\tevent_class = bt_ctf_event_class_create(\"perf_\" #_name);\\\n\tif (!event_class)\t\t\t\t\t\\\n\t\treturn -1;\t\t\t\t\t\\\n\tbody\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tret = bt_ctf_stream_class_add_event_class(cw->stream_class, event_class);\\\n\tif (ret) {\t\t\t\t\t\t\\\n\t\tpr(\"Failed to add event class '\"#_name\"' into stream.\\n\");\\\n\t\treturn ret;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tcw->_name##_class = event_class;\t\t\t\\\n\tbt_ctf_event_class_put(event_class);\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\\\n}\n\n__FUNC_ADD_NON_SAMPLE_EVENT_CLASS(comm,\n\t__NON_SAMPLE_ADD_FIELD(u32, pid);\n\t__NON_SAMPLE_ADD_FIELD(u32, tid);\n\t__NON_SAMPLE_ADD_FIELD(string, comm);\n)\n\n__FUNC_ADD_NON_SAMPLE_EVENT_CLASS(fork,\n\t__NON_SAMPLE_ADD_FIELD(u32, pid);\n\t__NON_SAMPLE_ADD_FIELD(u32, ppid);\n\t__NON_SAMPLE_ADD_FIELD(u32, tid);\n\t__NON_SAMPLE_ADD_FIELD(u32, ptid);\n\t__NON_SAMPLE_ADD_FIELD(u64, time);\n)\n\n__FUNC_ADD_NON_SAMPLE_EVENT_CLASS(exit,\n\t__NON_SAMPLE_ADD_FIELD(u32, pid);\n\t__NON_SAMPLE_ADD_FIELD(u32, ppid);\n\t__NON_SAMPLE_ADD_FIELD(u32, tid);\n\t__NON_SAMPLE_ADD_FIELD(u32, ptid);\n\t__NON_SAMPLE_ADD_FIELD(u64, time);\n)\n\n__FUNC_ADD_NON_SAMPLE_EVENT_CLASS(mmap,\n\t__NON_SAMPLE_ADD_FIELD(u32, pid);\n\t__NON_SAMPLE_ADD_FIELD(u32, tid);\n\t__NON_SAMPLE_ADD_FIELD(u64_hex, start);\n\t__NON_SAMPLE_ADD_FIELD(string, filename);\n)\n\n__FUNC_ADD_NON_SAMPLE_EVENT_CLASS(mmap2,\n\t__NON_SAMPLE_ADD_FIELD(u32, pid);\n\t__NON_SAMPLE_ADD_FIELD(u32, tid);\n\t__NON_SAMPLE_ADD_FIELD(u64_hex, start);\n\t__NON_SAMPLE_ADD_FIELD(string, filename);\n)\n#undef __NON_SAMPLE_ADD_FIELD\n#undef __FUNC_ADD_NON_SAMPLE_EVENT_CLASS\n\nstatic int setup_non_sample_events(struct ctf_writer *cw,\n\t\t\t\t   struct perf_session *session __maybe_unused)\n{\n\tint ret;\n\n\tret = add_comm_event(cw);\n\tif (ret)\n\t\treturn ret;\n\tret = add_exit_event(cw);\n\tif (ret)\n\t\treturn ret;\n\tret = add_fork_event(cw);\n\tif (ret)\n\t\treturn ret;\n\tret = add_mmap_event(cw);\n\tif (ret)\n\t\treturn ret;\n\tret = add_mmap2_event(cw);\n\tif (ret)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic void cleanup_events(struct perf_session *session)\n{\n\tstruct evlist *evlist = session->evlist;\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tstruct evsel_priv *priv;\n\n\t\tpriv = evsel->priv;\n\t\tbt_ctf_event_class_put(priv->event_class);\n\t\tzfree(&evsel->priv);\n\t}\n\n\tevlist__delete(evlist);\n\tsession->evlist = NULL;\n}\n\nstatic int setup_streams(struct ctf_writer *cw, struct perf_session *session)\n{\n\tstruct ctf_stream **stream;\n\tstruct perf_header *ph = &session->header;\n\tint ncpus;\n\n\t \n\tncpus = ph->env.nr_cpus_avail ?: MAX_CPUS;\n\n\tstream = zalloc(sizeof(*stream) * ncpus);\n\tif (!stream) {\n\t\tpr_err(\"Failed to allocate streams.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcw->stream     = stream;\n\tcw->stream_cnt = ncpus;\n\treturn 0;\n}\n\nstatic void free_streams(struct ctf_writer *cw)\n{\n\tint cpu;\n\n\tfor (cpu = 0; cpu < cw->stream_cnt; cpu++)\n\t\tctf_stream__delete(cw->stream[cpu]);\n\n\tzfree(&cw->stream);\n}\n\nstatic int ctf_writer__setup_env(struct ctf_writer *cw,\n\t\t\t\t struct perf_session *session)\n{\n\tstruct perf_header *header = &session->header;\n\tstruct bt_ctf_writer *writer = cw->writer;\n\n#define ADD(__n, __v)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (bt_ctf_writer_add_environment_field(writer, __n, __v))\t\\\n\t\treturn -1;\t\t\t\t\t\t\\\n} while (0)\n\n\tADD(\"host\",    header->env.hostname);\n\tADD(\"sysname\", \"Linux\");\n\tADD(\"release\", header->env.os_release);\n\tADD(\"version\", header->env.version);\n\tADD(\"machine\", header->env.arch);\n\tADD(\"domain\", \"kernel\");\n\tADD(\"tracer_name\", \"perf\");\n\n#undef ADD\n\treturn 0;\n}\n\nstatic int ctf_writer__setup_clock(struct ctf_writer *cw,\n\t\t\t\t   struct perf_session *session,\n\t\t\t\t   bool tod)\n{\n\tstruct bt_ctf_clock *clock = cw->clock;\n\tconst char *desc = \"perf clock\";\n\tint64_t offset = 0;\n\n\tif (tod) {\n\t\tstruct perf_env *env = &session->header.env;\n\n\t\tif (!env->clock.enabled) {\n\t\t\tpr_err(\"Can't provide --tod time, missing clock data. \"\n\t\t\t       \"Please record with -k/--clockid option.\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tdesc   = clockid_name(env->clock.clockid);\n\t\toffset = env->clock.tod_ns - env->clock.clockid_ns;\n\t}\n\n#define SET(__n, __v)\t\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tif (bt_ctf_clock_set_##__n(clock, __v))\t\\\n\t\treturn -1;\t\t\t\\\n} while (0)\n\n\tSET(frequency,   1000000000);\n\tSET(offset,      offset);\n\tSET(description, desc);\n\tSET(precision,   10);\n\tSET(is_absolute, 0);\n\n#undef SET\n\treturn 0;\n}\n\nstatic struct bt_ctf_field_type *create_int_type(int size, bool sign, bool hex)\n{\n\tstruct bt_ctf_field_type *type;\n\n\ttype = bt_ctf_field_type_integer_create(size);\n\tif (!type)\n\t\treturn NULL;\n\n\tif (sign &&\n\t    bt_ctf_field_type_integer_set_signed(type, 1))\n\t\tgoto err;\n\n\tif (hex &&\n\t    bt_ctf_field_type_integer_set_base(type, BT_CTF_INTEGER_BASE_HEXADECIMAL))\n\t\tgoto err;\n\n#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\tbt_ctf_field_type_set_byte_order(type, BT_CTF_BYTE_ORDER_BIG_ENDIAN);\n#else\n\tbt_ctf_field_type_set_byte_order(type, BT_CTF_BYTE_ORDER_LITTLE_ENDIAN);\n#endif\n\n\tpr2(\"Created type: INTEGER %d-bit %ssigned %s\\n\",\n\t    size, sign ? \"un\" : \"\", hex ? \"hex\" : \"\");\n\treturn type;\n\nerr:\n\tbt_ctf_field_type_put(type);\n\treturn NULL;\n}\n\nstatic void ctf_writer__cleanup_data(struct ctf_writer *cw)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cw->data.array); i++)\n\t\tbt_ctf_field_type_put(cw->data.array[i]);\n}\n\nstatic int ctf_writer__init_data(struct ctf_writer *cw)\n{\n#define CREATE_INT_TYPE(type, size, sign, hex)\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\t(type) = create_int_type(size, sign, hex);\t\\\n\tif (!(type))\t\t\t\t\t\\\n\t\tgoto err;\t\t\t\t\\\n} while (0)\n\n\tCREATE_INT_TYPE(cw->data.s64, 64, true,  false);\n\tCREATE_INT_TYPE(cw->data.u64, 64, false, false);\n\tCREATE_INT_TYPE(cw->data.s32, 32, true,  false);\n\tCREATE_INT_TYPE(cw->data.u32, 32, false, false);\n\tCREATE_INT_TYPE(cw->data.u32_hex, 32, false, true);\n\tCREATE_INT_TYPE(cw->data.u64_hex, 64, false, true);\n\n\tcw->data.string  = bt_ctf_field_type_string_create();\n\tif (cw->data.string)\n\t\treturn 0;\n\nerr:\n\tctf_writer__cleanup_data(cw);\n\tpr_err(\"Failed to create data types.\\n\");\n\treturn -1;\n}\n\nstatic void ctf_writer__cleanup(struct ctf_writer *cw)\n{\n\tctf_writer__cleanup_data(cw);\n\n\tbt_ctf_clock_put(cw->clock);\n\tfree_streams(cw);\n\tbt_ctf_stream_class_put(cw->stream_class);\n\tbt_ctf_writer_put(cw->writer);\n\n\t \n\tmemset(cw, 0, sizeof(*cw));\n}\n\nstatic int ctf_writer__init(struct ctf_writer *cw, const char *path,\n\t\t\t    struct perf_session *session, bool tod)\n{\n\tstruct bt_ctf_writer\t\t*writer;\n\tstruct bt_ctf_stream_class\t*stream_class;\n\tstruct bt_ctf_clock\t\t*clock;\n\tstruct bt_ctf_field_type\t*pkt_ctx_type;\n\tint\t\t\t\tret;\n\n\t \n\twriter = bt_ctf_writer_create(path);\n\tif (!writer)\n\t\tgoto err;\n\n\tcw->writer = writer;\n\n\t \n\tclock = bt_ctf_clock_create(\"perf_clock\");\n\tif (!clock) {\n\t\tpr(\"Failed to create CTF clock.\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\tcw->clock = clock;\n\n\tif (ctf_writer__setup_clock(cw, session, tod)) {\n\t\tpr(\"Failed to setup CTF clock.\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\t \n\tstream_class = bt_ctf_stream_class_create(\"perf_stream\");\n\tif (!stream_class) {\n\t\tpr(\"Failed to create CTF stream class.\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\tcw->stream_class = stream_class;\n\n\t \n\tif (bt_ctf_stream_class_set_clock(stream_class, clock)) {\n\t\tpr(\"Failed to assign CTF clock to stream class.\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\tif (ctf_writer__init_data(cw))\n\t\tgoto err_cleanup;\n\n\t \n\tpkt_ctx_type = bt_ctf_stream_class_get_packet_context_type(stream_class);\n\tif (!pkt_ctx_type)\n\t\tgoto err_cleanup;\n\n\tret = bt_ctf_field_type_structure_add_field(pkt_ctx_type, cw->data.u32, \"cpu_id\");\n\tbt_ctf_field_type_put(pkt_ctx_type);\n\tif (ret)\n\t\tgoto err_cleanup;\n\n\t \n\tif (bt_ctf_writer_add_clock(writer, clock)) {\n\t\tpr(\"Failed to assign CTF clock to writer.\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\treturn 0;\n\nerr_cleanup:\n\tctf_writer__cleanup(cw);\nerr:\n\tpr_err(\"Failed to setup CTF writer.\\n\");\n\treturn -1;\n}\n\nstatic int ctf_writer__flush_streams(struct ctf_writer *cw)\n{\n\tint cpu, ret = 0;\n\n\tfor (cpu = 0; cpu < cw->stream_cnt && !ret; cpu++)\n\t\tret = ctf_stream__flush(cw->stream[cpu]);\n\n\treturn ret;\n}\n\nstatic int convert__config(const char *var, const char *value, void *cb)\n{\n\tstruct convert *c = cb;\n\n\tif (!strcmp(var, \"convert.queue-size\"))\n\t\treturn perf_config_u64(&c->queue_size, var, value);\n\n\treturn 0;\n}\n\nint bt_convert__perf2ctf(const char *input, const char *path,\n\t\t\t struct perf_data_convert_opts *opts)\n{\n\tstruct perf_session *session;\n\tstruct perf_data data = {\n\t\t.path\t   = input,\n\t\t.mode      = PERF_DATA_MODE_READ,\n\t\t.force     = opts->force,\n\t};\n\tstruct convert c = {\n\t\t.tool = {\n\t\t\t.sample          = process_sample_event,\n\t\t\t.mmap            = perf_event__process_mmap,\n\t\t\t.mmap2           = perf_event__process_mmap2,\n\t\t\t.comm            = perf_event__process_comm,\n\t\t\t.exit            = perf_event__process_exit,\n\t\t\t.fork            = perf_event__process_fork,\n\t\t\t.lost            = perf_event__process_lost,\n\t\t\t.tracing_data    = perf_event__process_tracing_data,\n\t\t\t.build_id        = perf_event__process_build_id,\n\t\t\t.namespaces      = perf_event__process_namespaces,\n\t\t\t.ordered_events  = true,\n\t\t\t.ordering_requires_timestamps = true,\n\t\t},\n\t};\n\tstruct ctf_writer *cw = &c.writer;\n\tint err;\n\n\tif (opts->all) {\n\t\tc.tool.comm = process_comm_event;\n\t\tc.tool.exit = process_exit_event;\n\t\tc.tool.fork = process_fork_event;\n\t\tc.tool.mmap = process_mmap_event;\n\t\tc.tool.mmap2 = process_mmap2_event;\n\t}\n\n\terr = perf_config(convert__config, &c);\n\tif (err)\n\t\treturn err;\n\n\terr = -1;\n\t \n\tsession = perf_session__new(&data, &c.tool);\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\t \n\tif (ctf_writer__init(cw, path, session, opts->tod))\n\t\tgoto free_session;\n\n\tif (c.queue_size) {\n\t\tordered_events__set_alloc_size(&session->ordered_events,\n\t\t\t\t\t       c.queue_size);\n\t}\n\n\t \n\tif (ctf_writer__setup_env(cw, session))\n\t\tgoto free_writer;\n\n\t \n\tif (setup_events(cw, session))\n\t\tgoto free_writer;\n\n\tif (opts->all && setup_non_sample_events(cw, session))\n\t\tgoto free_writer;\n\n\tif (setup_streams(cw, session))\n\t\tgoto free_writer;\n\n\terr = perf_session__process_events(session);\n\tif (!err)\n\t\terr = ctf_writer__flush_streams(cw);\n\telse\n\t\tpr_err(\"Error during conversion.\\n\");\n\n\tfprintf(stderr,\n\t\t\"[ perf data convert: Converted '%s' into CTF data '%s' ]\\n\",\n\t\tdata.path, path);\n\n\tfprintf(stderr,\n\t\t\"[ perf data convert: Converted and wrote %.3f MB (%\" PRIu64 \" samples\",\n\t\t(double) c.events_size / 1024.0 / 1024.0,\n\t\tc.events_count);\n\n\tif (!c.non_sample_count)\n\t\tfprintf(stderr, \") ]\\n\");\n\telse\n\t\tfprintf(stderr, \", %\" PRIu64 \" non-samples) ]\\n\", c.non_sample_count);\n\n\tcleanup_events(session);\n\tperf_session__delete(session);\n\tctf_writer__cleanup(cw);\n\n\treturn err;\n\nfree_writer:\n\tctf_writer__cleanup(cw);\nfree_session:\n\tperf_session__delete(session);\n\tpr_err(\"Error during conversion setup.\\n\");\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}