{
  "module_name": "cs-etm.c",
  "hash_id": "be0f57a753b8441686c9ad4311d55d6d1095e85548f811aa49d4a5af9a73a67e",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/cs-etm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/coresight-pmu.h>\n#include <linux/err.h>\n#include <linux/log2.h>\n#include <linux/types.h>\n#include <linux/zalloc.h>\n\n#include <stdlib.h>\n\n#include \"auxtrace.h\"\n#include \"color.h\"\n#include \"cs-etm.h\"\n#include \"cs-etm-decoder/cs-etm-decoder.h\"\n#include \"debug.h\"\n#include \"dso.h\"\n#include \"evlist.h\"\n#include \"intlist.h\"\n#include \"machine.h\"\n#include \"map.h\"\n#include \"perf.h\"\n#include \"session.h\"\n#include \"map_symbol.h\"\n#include \"branch.h\"\n#include \"symbol.h\"\n#include \"tool.h\"\n#include \"thread.h\"\n#include \"thread-stack.h\"\n#include \"tsc.h\"\n#include <tools/libc_compat.h>\n#include \"util/synthetic-events.h\"\n#include \"util/util.h\"\n\nstruct cs_etm_auxtrace {\n\tstruct auxtrace auxtrace;\n\tstruct auxtrace_queues queues;\n\tstruct auxtrace_heap heap;\n\tstruct itrace_synth_opts synth_opts;\n\tstruct perf_session *session;\n\tstruct perf_tsc_conversion tc;\n\n\t \n\tbool timeless_decoding;\n\n\t \n\tbool per_thread_decoding;\n\tbool snapshot_mode;\n\tbool data_queued;\n\tbool has_virtual_ts;  \n\n\tint num_cpu;\n\tu64 latest_kernel_timestamp;\n\tu32 auxtrace_type;\n\tu64 branches_sample_type;\n\tu64 branches_id;\n\tu64 instructions_sample_type;\n\tu64 instructions_sample_period;\n\tu64 instructions_id;\n\tu64 **metadata;\n\tunsigned int pmu_type;\n\tenum cs_etm_pid_fmt pid_fmt;\n};\n\nstruct cs_etm_traceid_queue {\n\tu8 trace_chan_id;\n\tu64 period_instructions;\n\tsize_t last_branch_pos;\n\tunion perf_event *event_buf;\n\tstruct thread *thread;\n\tstruct thread *prev_packet_thread;\n\tocsd_ex_level prev_packet_el;\n\tocsd_ex_level el;\n\tstruct branch_stack *last_branch;\n\tstruct branch_stack *last_branch_rb;\n\tstruct cs_etm_packet *prev_packet;\n\tstruct cs_etm_packet *packet;\n\tstruct cs_etm_packet_queue packet_queue;\n};\n\nstruct cs_etm_queue {\n\tstruct cs_etm_auxtrace *etm;\n\tstruct cs_etm_decoder *decoder;\n\tstruct auxtrace_buffer *buffer;\n\tunsigned int queue_nr;\n\tu8 pending_timestamp_chan_id;\n\tu64 offset;\n\tconst unsigned char *buf;\n\tsize_t buf_len, buf_used;\n\t \n\tstruct intlist *traceid_queues_list;\n\tstruct cs_etm_traceid_queue **traceid_queues;\n};\n\n \nstatic struct intlist *traceid_list;\n\nstatic int cs_etm__process_timestamped_queues(struct cs_etm_auxtrace *etm);\nstatic int cs_etm__process_timeless_queues(struct cs_etm_auxtrace *etm,\n\t\t\t\t\t   pid_t tid);\nstatic int cs_etm__get_data_block(struct cs_etm_queue *etmq);\nstatic int cs_etm__decode_data_block(struct cs_etm_queue *etmq);\n\n \n#define ETMIDR_PTM_VERSION 0x00000300\n\n \n#define TO_CS_QUEUE_NR(queue_nr, trace_chan_id)\t\\\n\t\t      (queue_nr << 16 | trace_chan_id)\n#define TO_QUEUE_NR(cs_queue_nr) (cs_queue_nr >> 16)\n#define TO_TRACE_CHAN_ID(cs_queue_nr) (cs_queue_nr & 0x0000ffff)\n\nstatic u32 cs_etm__get_v7_protocol_version(u32 etmidr)\n{\n\tetmidr &= ETMIDR_PTM_VERSION;\n\n\tif (etmidr == ETMIDR_PTM_VERSION)\n\t\treturn CS_ETM_PROTO_PTM;\n\n\treturn CS_ETM_PROTO_ETMV3;\n}\n\nstatic int cs_etm__get_magic(u8 trace_chan_id, u64 *magic)\n{\n\tstruct int_node *inode;\n\tu64 *metadata;\n\n\tinode = intlist__find(traceid_list, trace_chan_id);\n\tif (!inode)\n\t\treturn -EINVAL;\n\n\tmetadata = inode->priv;\n\t*magic = metadata[CS_ETM_MAGIC];\n\treturn 0;\n}\n\nint cs_etm__get_cpu(u8 trace_chan_id, int *cpu)\n{\n\tstruct int_node *inode;\n\tu64 *metadata;\n\n\tinode = intlist__find(traceid_list, trace_chan_id);\n\tif (!inode)\n\t\treturn -EINVAL;\n\n\tmetadata = inode->priv;\n\t*cpu = (int)metadata[CS_ETM_CPU];\n\treturn 0;\n}\n\n \nstatic enum cs_etm_pid_fmt cs_etm__init_pid_fmt(u64 *metadata)\n{\n\tu64 val;\n\n\tif (metadata[CS_ETM_MAGIC] == __perf_cs_etmv3_magic) {\n\t\tval = metadata[CS_ETM_ETMCR];\n\t\t \n\t\tif (val & BIT(ETM_OPT_CTXTID))\n\t\t\treturn CS_ETM_PIDFMT_CTXTID;\n\t} else {\n\t\tval = metadata[CS_ETMV4_TRCCONFIGR];\n\t\t \n\t\tif (val & (BIT(ETM4_CFG_BIT_VMID) | BIT(ETM4_CFG_BIT_VMID_OPT)))\n\t\t\treturn CS_ETM_PIDFMT_CTXTID2;\n\t\t \n\t\telse if (val & BIT(ETM4_CFG_BIT_CTXTID))\n\t\t\treturn CS_ETM_PIDFMT_CTXTID;\n\t}\n\n\treturn CS_ETM_PIDFMT_NONE;\n}\n\nenum cs_etm_pid_fmt cs_etm__get_pid_fmt(struct cs_etm_queue *etmq)\n{\n\treturn etmq->etm->pid_fmt;\n}\n\nstatic int cs_etm__map_trace_id(u8 trace_chan_id, u64 *cpu_metadata)\n{\n\tstruct int_node *inode;\n\n\t \n\tinode = intlist__findnew(traceid_list, trace_chan_id);\n\n\t \n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\t \n\tif (inode->priv)\n\t\treturn -EINVAL;\n\n\t \n\tinode->priv = cpu_metadata;\n\n\treturn 0;\n}\n\nstatic int cs_etm__metadata_get_trace_id(u8 *trace_chan_id, u64 *cpu_metadata)\n{\n\tu64 cs_etm_magic = cpu_metadata[CS_ETM_MAGIC];\n\n\tswitch (cs_etm_magic) {\n\tcase __perf_cs_etmv3_magic:\n\t\t*trace_chan_id = (u8)(cpu_metadata[CS_ETM_ETMTRACEIDR] &\n\t\t\t\t      CORESIGHT_TRACE_ID_VAL_MASK);\n\t\tbreak;\n\tcase __perf_cs_etmv4_magic:\n\tcase __perf_cs_ete_magic:\n\t\t*trace_chan_id = (u8)(cpu_metadata[CS_ETMV4_TRCTRACEIDR] &\n\t\t\t\t      CORESIGHT_TRACE_ID_VAL_MASK);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int cs_etm__metadata_set_trace_id(u8 trace_chan_id, u64 *cpu_metadata)\n{\n\tu64 cs_etm_magic = cpu_metadata[CS_ETM_MAGIC];\n\n\tswitch (cs_etm_magic) {\n\tcase __perf_cs_etmv3_magic:\n\t\t cpu_metadata[CS_ETM_ETMTRACEIDR] = trace_chan_id;\n\t\tbreak;\n\tcase __perf_cs_etmv4_magic:\n\tcase __perf_cs_ete_magic:\n\t\tcpu_metadata[CS_ETMV4_TRCTRACEIDR] = trace_chan_id;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic u64 *get_cpu_data(struct cs_etm_auxtrace *etm, int cpu)\n{\n\tint i;\n\tu64 *metadata = NULL;\n\n\tfor (i = 0; i < etm->num_cpu; i++) {\n\t\tif (etm->metadata[i][CS_ETM_CPU] == (u64)cpu) {\n\t\t\tmetadata = etm->metadata[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn metadata;\n}\n\n \nstatic int cs_etm__process_aux_output_hw_id(struct perf_session *session,\n\t\t\t\t\t    union perf_event *event)\n{\n\tstruct cs_etm_auxtrace *etm;\n\tstruct perf_sample sample;\n\tstruct int_node *inode;\n\tstruct evsel *evsel;\n\tu64 *cpu_data;\n\tu64 hw_id;\n\tint cpu, version, err;\n\tu8 trace_chan_id, curr_chan_id;\n\n\t \n\thw_id = event->aux_output_hw_id.hw_id;\n\tversion = FIELD_GET(CS_AUX_HW_ID_VERSION_MASK, hw_id);\n\ttrace_chan_id = FIELD_GET(CS_AUX_HW_ID_TRACE_ID_MASK, hw_id);\n\n\t \n\tif (version > CS_AUX_HW_ID_CURR_VERSION)\n\t\treturn -EINVAL;\n\n\t \n\tetm = container_of(session->auxtrace, struct cs_etm_auxtrace, auxtrace);\n\tif (!etm || !etm->metadata)\n\t\treturn -EINVAL;\n\n\t \n\tevsel = evlist__event2evsel(session->evlist, event);\n\tif (!evsel)\n\t\treturn -EINVAL;\n\terr = evsel__parse_sample(evsel, event, &sample);\n\tif (err)\n\t\treturn err;\n\tcpu = sample.cpu;\n\tif (cpu == -1) {\n\t\t \n\t\tpr_err(\"CS_ETM: no CPU AUX_OUTPUT_HW_ID sample. Use compatible perf to record.\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tinode = intlist__find(traceid_list, trace_chan_id);\n\tif (inode) {\n\t\tcpu_data = inode->priv;\n\t\tif ((int)cpu_data[CS_ETM_CPU] != cpu) {\n\t\t\tpr_err(\"CS_ETM: map mismatch between HW_ID packet CPU and Trace ID\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\terr = cs_etm__metadata_get_trace_id(&curr_chan_id, cpu_data);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (curr_chan_id != trace_chan_id) {\n\t\t\tpr_err(\"CS_ETM: mismatch between CPU trace ID and HW_ID packet ID\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\treturn 0;\n\t}\n\n\tcpu_data = get_cpu_data(etm, cpu);\n\tif (cpu_data == NULL)\n\t\treturn err;\n\n\t \n\terr = cs_etm__map_trace_id(trace_chan_id, cpu_data);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = cs_etm__metadata_set_trace_id(trace_chan_id, cpu_data);\n\treturn err;\n}\n\nvoid cs_etm__etmq_set_traceid_queue_timestamp(struct cs_etm_queue *etmq,\n\t\t\t\t\t      u8 trace_chan_id)\n{\n\t \n\tetmq->pending_timestamp_chan_id = trace_chan_id;\n}\n\nstatic u64 cs_etm__etmq_get_timestamp(struct cs_etm_queue *etmq,\n\t\t\t\t      u8 *trace_chan_id)\n{\n\tstruct cs_etm_packet_queue *packet_queue;\n\n\tif (!etmq->pending_timestamp_chan_id)\n\t\treturn 0;\n\n\tif (trace_chan_id)\n\t\t*trace_chan_id = etmq->pending_timestamp_chan_id;\n\n\tpacket_queue = cs_etm__etmq_get_packet_queue(etmq,\n\t\t\t\t\t\t     etmq->pending_timestamp_chan_id);\n\tif (!packet_queue)\n\t\treturn 0;\n\n\t \n\tetmq->pending_timestamp_chan_id = 0;\n\n\t \n\treturn packet_queue->cs_timestamp;\n}\n\nstatic void cs_etm__clear_packet_queue(struct cs_etm_packet_queue *queue)\n{\n\tint i;\n\n\tqueue->head = 0;\n\tqueue->tail = 0;\n\tqueue->packet_count = 0;\n\tfor (i = 0; i < CS_ETM_PACKET_MAX_BUFFER; i++) {\n\t\tqueue->packet_buffer[i].isa = CS_ETM_ISA_UNKNOWN;\n\t\tqueue->packet_buffer[i].start_addr = CS_ETM_INVAL_ADDR;\n\t\tqueue->packet_buffer[i].end_addr = CS_ETM_INVAL_ADDR;\n\t\tqueue->packet_buffer[i].instr_count = 0;\n\t\tqueue->packet_buffer[i].last_instr_taken_branch = false;\n\t\tqueue->packet_buffer[i].last_instr_size = 0;\n\t\tqueue->packet_buffer[i].last_instr_type = 0;\n\t\tqueue->packet_buffer[i].last_instr_subtype = 0;\n\t\tqueue->packet_buffer[i].last_instr_cond = 0;\n\t\tqueue->packet_buffer[i].flags = 0;\n\t\tqueue->packet_buffer[i].exception_number = UINT32_MAX;\n\t\tqueue->packet_buffer[i].trace_chan_id = UINT8_MAX;\n\t\tqueue->packet_buffer[i].cpu = INT_MIN;\n\t}\n}\n\nstatic void cs_etm__clear_all_packet_queues(struct cs_etm_queue *etmq)\n{\n\tint idx;\n\tstruct int_node *inode;\n\tstruct cs_etm_traceid_queue *tidq;\n\tstruct intlist *traceid_queues_list = etmq->traceid_queues_list;\n\n\tintlist__for_each_entry(inode, traceid_queues_list) {\n\t\tidx = (int)(intptr_t)inode->priv;\n\t\ttidq = etmq->traceid_queues[idx];\n\t\tcs_etm__clear_packet_queue(&tidq->packet_queue);\n\t}\n}\n\nstatic int cs_etm__init_traceid_queue(struct cs_etm_queue *etmq,\n\t\t\t\t      struct cs_etm_traceid_queue *tidq,\n\t\t\t\t      u8 trace_chan_id)\n{\n\tint rc = -ENOMEM;\n\tstruct auxtrace_queue *queue;\n\tstruct cs_etm_auxtrace *etm = etmq->etm;\n\n\tcs_etm__clear_packet_queue(&tidq->packet_queue);\n\n\tqueue = &etmq->etm->queues.queue_array[etmq->queue_nr];\n\ttidq->trace_chan_id = trace_chan_id;\n\ttidq->el = tidq->prev_packet_el = ocsd_EL_unknown;\n\ttidq->thread = machine__findnew_thread(&etm->session->machines.host, -1,\n\t\t\t\t\t       queue->tid);\n\ttidq->prev_packet_thread = machine__idle_thread(&etm->session->machines.host);\n\n\ttidq->packet = zalloc(sizeof(struct cs_etm_packet));\n\tif (!tidq->packet)\n\t\tgoto out;\n\n\ttidq->prev_packet = zalloc(sizeof(struct cs_etm_packet));\n\tif (!tidq->prev_packet)\n\t\tgoto out_free;\n\n\tif (etm->synth_opts.last_branch) {\n\t\tsize_t sz = sizeof(struct branch_stack);\n\n\t\tsz += etm->synth_opts.last_branch_sz *\n\t\t      sizeof(struct branch_entry);\n\t\ttidq->last_branch = zalloc(sz);\n\t\tif (!tidq->last_branch)\n\t\t\tgoto out_free;\n\t\ttidq->last_branch_rb = zalloc(sz);\n\t\tif (!tidq->last_branch_rb)\n\t\t\tgoto out_free;\n\t}\n\n\ttidq->event_buf = malloc(PERF_SAMPLE_MAX_SIZE);\n\tif (!tidq->event_buf)\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_free:\n\tzfree(&tidq->last_branch_rb);\n\tzfree(&tidq->last_branch);\n\tzfree(&tidq->prev_packet);\n\tzfree(&tidq->packet);\nout:\n\treturn rc;\n}\n\nstatic struct cs_etm_traceid_queue\n*cs_etm__etmq_get_traceid_queue(struct cs_etm_queue *etmq, u8 trace_chan_id)\n{\n\tint idx;\n\tstruct int_node *inode;\n\tstruct intlist *traceid_queues_list;\n\tstruct cs_etm_traceid_queue *tidq, **traceid_queues;\n\tstruct cs_etm_auxtrace *etm = etmq->etm;\n\n\tif (etm->per_thread_decoding)\n\t\ttrace_chan_id = CS_ETM_PER_THREAD_TRACEID;\n\n\ttraceid_queues_list = etmq->traceid_queues_list;\n\n\t \n\tinode = intlist__find(traceid_queues_list, trace_chan_id);\n\tif (inode) {\n\t\tidx = (int)(intptr_t)inode->priv;\n\t\treturn etmq->traceid_queues[idx];\n\t}\n\n\t \n\ttidq = malloc(sizeof(*tidq));\n\tif (!tidq)\n\t\treturn NULL;\n\n\tmemset(tidq, 0, sizeof(*tidq));\n\n\t \n\tidx = intlist__nr_entries(traceid_queues_list);\n\t \n\tinode = intlist__findnew(traceid_queues_list, trace_chan_id);\n\tif (!inode)\n\t\tgoto out_free;\n\n\t \n\tinode->priv = (void *)(intptr_t)idx;\n\n\tif (cs_etm__init_traceid_queue(etmq, tidq, trace_chan_id))\n\t\tgoto out_free;\n\n\t \n\ttraceid_queues = etmq->traceid_queues;\n\ttraceid_queues = reallocarray(traceid_queues,\n\t\t\t\t      idx + 1,\n\t\t\t\t      sizeof(*traceid_queues));\n\n\t \n\tif (!traceid_queues)\n\t\tgoto out_free;\n\n\ttraceid_queues[idx] = tidq;\n\tetmq->traceid_queues = traceid_queues;\n\n\treturn etmq->traceid_queues[idx];\n\nout_free:\n\t \n\tintlist__remove(traceid_queues_list, inode);\n\tfree(tidq);\n\n\treturn NULL;\n}\n\nstruct cs_etm_packet_queue\n*cs_etm__etmq_get_packet_queue(struct cs_etm_queue *etmq, u8 trace_chan_id)\n{\n\tstruct cs_etm_traceid_queue *tidq;\n\n\ttidq = cs_etm__etmq_get_traceid_queue(etmq, trace_chan_id);\n\tif (tidq)\n\t\treturn &tidq->packet_queue;\n\n\treturn NULL;\n}\n\nstatic void cs_etm__packet_swap(struct cs_etm_auxtrace *etm,\n\t\t\t\tstruct cs_etm_traceid_queue *tidq)\n{\n\tstruct cs_etm_packet *tmp;\n\n\tif (etm->synth_opts.branches || etm->synth_opts.last_branch ||\n\t    etm->synth_opts.instructions) {\n\t\t \n\t\ttmp = tidq->packet;\n\t\ttidq->packet = tidq->prev_packet;\n\t\ttidq->prev_packet = tmp;\n\t\ttidq->prev_packet_el = tidq->el;\n\t\tthread__put(tidq->prev_packet_thread);\n\t\ttidq->prev_packet_thread = thread__get(tidq->thread);\n\t}\n}\n\nstatic void cs_etm__packet_dump(const char *pkt_string)\n{\n\tconst char *color = PERF_COLOR_BLUE;\n\tint len = strlen(pkt_string);\n\n\tif (len && (pkt_string[len-1] == '\\n'))\n\t\tcolor_fprintf(stdout, color, \"\t%s\", pkt_string);\n\telse\n\t\tcolor_fprintf(stdout, color, \"\t%s\\n\", pkt_string);\n\n\tfflush(stdout);\n}\n\nstatic void cs_etm__set_trace_param_etmv3(struct cs_etm_trace_params *t_params,\n\t\t\t\t\t  struct cs_etm_auxtrace *etm, int idx,\n\t\t\t\t\t  u32 etmidr)\n{\n\tu64 **metadata = etm->metadata;\n\n\tt_params[idx].protocol = cs_etm__get_v7_protocol_version(etmidr);\n\tt_params[idx].etmv3.reg_ctrl = metadata[idx][CS_ETM_ETMCR];\n\tt_params[idx].etmv3.reg_trc_id = metadata[idx][CS_ETM_ETMTRACEIDR];\n}\n\nstatic void cs_etm__set_trace_param_etmv4(struct cs_etm_trace_params *t_params,\n\t\t\t\t\t  struct cs_etm_auxtrace *etm, int idx)\n{\n\tu64 **metadata = etm->metadata;\n\n\tt_params[idx].protocol = CS_ETM_PROTO_ETMV4i;\n\tt_params[idx].etmv4.reg_idr0 = metadata[idx][CS_ETMV4_TRCIDR0];\n\tt_params[idx].etmv4.reg_idr1 = metadata[idx][CS_ETMV4_TRCIDR1];\n\tt_params[idx].etmv4.reg_idr2 = metadata[idx][CS_ETMV4_TRCIDR2];\n\tt_params[idx].etmv4.reg_idr8 = metadata[idx][CS_ETMV4_TRCIDR8];\n\tt_params[idx].etmv4.reg_configr = metadata[idx][CS_ETMV4_TRCCONFIGR];\n\tt_params[idx].etmv4.reg_traceidr = metadata[idx][CS_ETMV4_TRCTRACEIDR];\n}\n\nstatic void cs_etm__set_trace_param_ete(struct cs_etm_trace_params *t_params,\n\t\t\t\t\t  struct cs_etm_auxtrace *etm, int idx)\n{\n\tu64 **metadata = etm->metadata;\n\n\tt_params[idx].protocol = CS_ETM_PROTO_ETE;\n\tt_params[idx].ete.reg_idr0 = metadata[idx][CS_ETE_TRCIDR0];\n\tt_params[idx].ete.reg_idr1 = metadata[idx][CS_ETE_TRCIDR1];\n\tt_params[idx].ete.reg_idr2 = metadata[idx][CS_ETE_TRCIDR2];\n\tt_params[idx].ete.reg_idr8 = metadata[idx][CS_ETE_TRCIDR8];\n\tt_params[idx].ete.reg_configr = metadata[idx][CS_ETE_TRCCONFIGR];\n\tt_params[idx].ete.reg_traceidr = metadata[idx][CS_ETE_TRCTRACEIDR];\n\tt_params[idx].ete.reg_devarch = metadata[idx][CS_ETE_TRCDEVARCH];\n}\n\nstatic int cs_etm__init_trace_params(struct cs_etm_trace_params *t_params,\n\t\t\t\t     struct cs_etm_auxtrace *etm,\n\t\t\t\t     int decoders)\n{\n\tint i;\n\tu32 etmidr;\n\tu64 architecture;\n\n\tfor (i = 0; i < decoders; i++) {\n\t\tarchitecture = etm->metadata[i][CS_ETM_MAGIC];\n\n\t\tswitch (architecture) {\n\t\tcase __perf_cs_etmv3_magic:\n\t\t\tetmidr = etm->metadata[i][CS_ETM_ETMIDR];\n\t\t\tcs_etm__set_trace_param_etmv3(t_params, etm, i, etmidr);\n\t\t\tbreak;\n\t\tcase __perf_cs_etmv4_magic:\n\t\t\tcs_etm__set_trace_param_etmv4(t_params, etm, i);\n\t\t\tbreak;\n\t\tcase __perf_cs_ete_magic:\n\t\t\tcs_etm__set_trace_param_ete(t_params, etm, i);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cs_etm__init_decoder_params(struct cs_etm_decoder_params *d_params,\n\t\t\t\t       struct cs_etm_queue *etmq,\n\t\t\t\t       enum cs_etm_decoder_operation mode,\n\t\t\t\t       bool formatted)\n{\n\tint ret = -EINVAL;\n\n\tif (!(mode < CS_ETM_OPERATION_MAX))\n\t\tgoto out;\n\n\td_params->packet_printer = cs_etm__packet_dump;\n\td_params->operation = mode;\n\td_params->data = etmq;\n\td_params->formatted = formatted;\n\td_params->fsyncs = false;\n\td_params->hsyncs = false;\n\td_params->frame_aligned = true;\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic void cs_etm__dump_event(struct cs_etm_queue *etmq,\n\t\t\t       struct auxtrace_buffer *buffer)\n{\n\tint ret;\n\tconst char *color = PERF_COLOR_BLUE;\n\tsize_t buffer_used = 0;\n\n\tfprintf(stdout, \"\\n\");\n\tcolor_fprintf(stdout, color,\n\t\t     \". ... CoreSight %s Trace data: size %#zx bytes\\n\",\n\t\t     cs_etm_decoder__get_name(etmq->decoder), buffer->size);\n\n\tdo {\n\t\tsize_t consumed;\n\n\t\tret = cs_etm_decoder__process_data_block(\n\t\t\t\tetmq->decoder, buffer->offset,\n\t\t\t\t&((u8 *)buffer->data)[buffer_used],\n\t\t\t\tbuffer->size - buffer_used, &consumed);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tbuffer_used += consumed;\n\t} while (buffer_used < buffer->size);\n\n\tcs_etm_decoder__reset(etmq->decoder);\n}\n\nstatic int cs_etm__flush_events(struct perf_session *session,\n\t\t\t\tstruct perf_tool *tool)\n{\n\tstruct cs_etm_auxtrace *etm = container_of(session->auxtrace,\n\t\t\t\t\t\t   struct cs_etm_auxtrace,\n\t\t\t\t\t\t   auxtrace);\n\tif (dump_trace)\n\t\treturn 0;\n\n\tif (!tool->ordered_events)\n\t\treturn -EINVAL;\n\n\tif (etm->timeless_decoding) {\n\t\t \n\t\treturn cs_etm__process_timeless_queues(etm, -1);\n\t}\n\n\treturn cs_etm__process_timestamped_queues(etm);\n}\n\nstatic void cs_etm__free_traceid_queues(struct cs_etm_queue *etmq)\n{\n\tint idx;\n\tuintptr_t priv;\n\tstruct int_node *inode, *tmp;\n\tstruct cs_etm_traceid_queue *tidq;\n\tstruct intlist *traceid_queues_list = etmq->traceid_queues_list;\n\n\tintlist__for_each_entry_safe(inode, tmp, traceid_queues_list) {\n\t\tpriv = (uintptr_t)inode->priv;\n\t\tidx = priv;\n\n\t\t \n\t\ttidq = etmq->traceid_queues[idx];\n\t\tthread__zput(tidq->thread);\n\t\tthread__zput(tidq->prev_packet_thread);\n\t\tzfree(&tidq->event_buf);\n\t\tzfree(&tidq->last_branch);\n\t\tzfree(&tidq->last_branch_rb);\n\t\tzfree(&tidq->prev_packet);\n\t\tzfree(&tidq->packet);\n\t\tzfree(&tidq);\n\n\t\t \n\t\tintlist__remove(traceid_queues_list, inode);\n\t}\n\n\t \n\tintlist__delete(traceid_queues_list);\n\tetmq->traceid_queues_list = NULL;\n\n\t \n\tzfree(&etmq->traceid_queues);\n}\n\nstatic void cs_etm__free_queue(void *priv)\n{\n\tstruct cs_etm_queue *etmq = priv;\n\n\tif (!etmq)\n\t\treturn;\n\n\tcs_etm_decoder__free(etmq->decoder);\n\tcs_etm__free_traceid_queues(etmq);\n\tfree(etmq);\n}\n\nstatic void cs_etm__free_events(struct perf_session *session)\n{\n\tunsigned int i;\n\tstruct cs_etm_auxtrace *aux = container_of(session->auxtrace,\n\t\t\t\t\t\t   struct cs_etm_auxtrace,\n\t\t\t\t\t\t   auxtrace);\n\tstruct auxtrace_queues *queues = &aux->queues;\n\n\tfor (i = 0; i < queues->nr_queues; i++) {\n\t\tcs_etm__free_queue(queues->queue_array[i].priv);\n\t\tqueues->queue_array[i].priv = NULL;\n\t}\n\n\tauxtrace_queues__free(queues);\n}\n\nstatic void cs_etm__free(struct perf_session *session)\n{\n\tint i;\n\tstruct int_node *inode, *tmp;\n\tstruct cs_etm_auxtrace *aux = container_of(session->auxtrace,\n\t\t\t\t\t\t   struct cs_etm_auxtrace,\n\t\t\t\t\t\t   auxtrace);\n\tcs_etm__free_events(session);\n\tsession->auxtrace = NULL;\n\n\t \n\tintlist__for_each_entry_safe(inode, tmp, traceid_list)\n\t\tintlist__remove(traceid_list, inode);\n\t \n\tintlist__delete(traceid_list);\n\n\tfor (i = 0; i < aux->num_cpu; i++)\n\t\tzfree(&aux->metadata[i]);\n\n\tzfree(&aux->metadata);\n\tzfree(&aux);\n}\n\nstatic bool cs_etm__evsel_is_auxtrace(struct perf_session *session,\n\t\t\t\t      struct evsel *evsel)\n{\n\tstruct cs_etm_auxtrace *aux = container_of(session->auxtrace,\n\t\t\t\t\t\t   struct cs_etm_auxtrace,\n\t\t\t\t\t\t   auxtrace);\n\n\treturn evsel->core.attr.type == aux->pmu_type;\n}\n\nstatic struct machine *cs_etm__get_machine(struct cs_etm_queue *etmq,\n\t\t\t\t\t   ocsd_ex_level el)\n{\n\tenum cs_etm_pid_fmt pid_fmt = cs_etm__get_pid_fmt(etmq);\n\n\t \n\tif (pid_fmt == CS_ETM_PIDFMT_CTXTID)\n\t\treturn &etmq->etm->session->machines.host;\n\n\t \n\tswitch (el) {\n\tcase ocsd_EL1:\n\t\treturn machines__find_guest(&etmq->etm->session->machines,\n\t\t\t\t\t    DEFAULT_GUEST_KERNEL_ID);\n\tcase ocsd_EL3:\n\tcase ocsd_EL2:\n\tcase ocsd_EL0:\n\tcase ocsd_EL_unknown:\n\tdefault:\n\t\treturn &etmq->etm->session->machines.host;\n\t}\n}\n\nstatic u8 cs_etm__cpu_mode(struct cs_etm_queue *etmq, u64 address,\n\t\t\t   ocsd_ex_level el)\n{\n\tstruct machine *machine = cs_etm__get_machine(etmq, el);\n\n\tif (address >= machine__kernel_start(machine)) {\n\t\tif (machine__is_host(machine))\n\t\t\treturn PERF_RECORD_MISC_KERNEL;\n\t\telse\n\t\t\treturn PERF_RECORD_MISC_GUEST_KERNEL;\n\t} else {\n\t\tif (machine__is_host(machine))\n\t\t\treturn PERF_RECORD_MISC_USER;\n\t\telse {\n\t\t\t \n\t\t\treturn PERF_RECORD_MISC_GUEST_USER;\n\t\t}\n\t}\n}\n\nstatic u32 cs_etm__mem_access(struct cs_etm_queue *etmq, u8 trace_chan_id,\n\t\t\t      u64 address, size_t size, u8 *buffer,\n\t\t\t      const ocsd_mem_space_acc_t mem_space)\n{\n\tu8  cpumode;\n\tu64 offset;\n\tint len;\n\tstruct addr_location al;\n\tstruct dso *dso;\n\tstruct cs_etm_traceid_queue *tidq;\n\tint ret = 0;\n\n\tif (!etmq)\n\t\treturn 0;\n\n\taddr_location__init(&al);\n\ttidq = cs_etm__etmq_get_traceid_queue(etmq, trace_chan_id);\n\tif (!tidq)\n\t\tgoto out;\n\n\t \n\tif (!(mem_space == OCSD_MEM_SPACE_ANY ||\n\t      mem_space == OCSD_MEM_SPACE_N || mem_space == OCSD_MEM_SPACE_S)) {\n\t\tif (mem_space & OCSD_MEM_SPACE_EL1N) {\n\t\t\t \n\t\t\tassert(tidq->el == ocsd_EL1 || tidq->el == ocsd_EL0);\n\t\t} else if (mem_space & OCSD_MEM_SPACE_EL2)\n\t\t\tassert(tidq->el == ocsd_EL2);\n\t\telse if (mem_space & OCSD_MEM_SPACE_EL3)\n\t\t\tassert(tidq->el == ocsd_EL3);\n\t}\n\n\tcpumode = cs_etm__cpu_mode(etmq, address, tidq->el);\n\n\tif (!thread__find_map(tidq->thread, cpumode, address, &al))\n\t\tgoto out;\n\n\tdso = map__dso(al.map);\n\tif (!dso)\n\t\tgoto out;\n\n\tif (dso->data.status == DSO_DATA_STATUS_ERROR &&\n\t    dso__data_status_seen(dso, DSO_DATA_STATUS_SEEN_ITRACE))\n\t\tgoto out;\n\n\toffset = map__map_ip(al.map, address);\n\n\tmap__load(al.map);\n\n\tlen = dso__data_read_offset(dso, maps__machine(thread__maps(tidq->thread)),\n\t\t\t\t    offset, buffer, size);\n\n\tif (len <= 0) {\n\t\tui__warning_once(\"CS ETM Trace: Missing DSO. Use 'perf archive' or debuginfod to export data from the traced system.\\n\"\n\t\t\t\t \"              Enable CONFIG_PROC_KCORE or use option '-k /path/to/vmlinux' for kernel symbols.\\n\");\n\t\tif (!dso->auxtrace_warned) {\n\t\t\tpr_err(\"CS ETM Trace: Debug data not found for address %#\"PRIx64\" in %s\\n\",\n\t\t\t\t    address,\n\t\t\t\t    dso->long_name ? dso->long_name : \"Unknown\");\n\t\t\tdso->auxtrace_warned = true;\n\t\t}\n\t\tgoto out;\n\t}\n\tret = len;\nout:\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\nstatic struct cs_etm_queue *cs_etm__alloc_queue(struct cs_etm_auxtrace *etm,\n\t\t\t\t\t\tbool formatted)\n{\n\tstruct cs_etm_decoder_params d_params;\n\tstruct cs_etm_trace_params  *t_params = NULL;\n\tstruct cs_etm_queue *etmq;\n\t \n\tint decoders = formatted ? etm->num_cpu : 1;\n\n\tetmq = zalloc(sizeof(*etmq));\n\tif (!etmq)\n\t\treturn NULL;\n\n\tetmq->traceid_queues_list = intlist__new(NULL);\n\tif (!etmq->traceid_queues_list)\n\t\tgoto out_free;\n\n\t \n\tt_params = zalloc(sizeof(*t_params) * decoders);\n\n\tif (!t_params)\n\t\tgoto out_free;\n\n\tif (cs_etm__init_trace_params(t_params, etm, decoders))\n\t\tgoto out_free;\n\n\t \n\tif (cs_etm__init_decoder_params(&d_params, etmq,\n\t\t\t\t\tdump_trace ? CS_ETM_OPERATION_PRINT :\n\t\t\t\t\t\t     CS_ETM_OPERATION_DECODE,\n\t\t\t\t\tformatted))\n\t\tgoto out_free;\n\n\tetmq->decoder = cs_etm_decoder__new(decoders, &d_params,\n\t\t\t\t\t    t_params);\n\n\tif (!etmq->decoder)\n\t\tgoto out_free;\n\n\t \n\tif (cs_etm_decoder__add_mem_access_cb(etmq->decoder,\n\t\t\t\t\t      0x0L, ((u64) -1L),\n\t\t\t\t\t      cs_etm__mem_access))\n\t\tgoto out_free_decoder;\n\n\tzfree(&t_params);\n\treturn etmq;\n\nout_free_decoder:\n\tcs_etm_decoder__free(etmq->decoder);\nout_free:\n\tintlist__delete(etmq->traceid_queues_list);\n\tfree(etmq);\n\n\treturn NULL;\n}\n\nstatic int cs_etm__setup_queue(struct cs_etm_auxtrace *etm,\n\t\t\t       struct auxtrace_queue *queue,\n\t\t\t       unsigned int queue_nr,\n\t\t\t       bool formatted)\n{\n\tstruct cs_etm_queue *etmq = queue->priv;\n\n\tif (list_empty(&queue->head) || etmq)\n\t\treturn 0;\n\n\tetmq = cs_etm__alloc_queue(etm, formatted);\n\n\tif (!etmq)\n\t\treturn -ENOMEM;\n\n\tqueue->priv = etmq;\n\tetmq->etm = etm;\n\tetmq->queue_nr = queue_nr;\n\tetmq->offset = 0;\n\n\treturn 0;\n}\n\nstatic int cs_etm__queue_first_cs_timestamp(struct cs_etm_auxtrace *etm,\n\t\t\t\t\t    struct cs_etm_queue *etmq,\n\t\t\t\t\t    unsigned int queue_nr)\n{\n\tint ret = 0;\n\tunsigned int cs_queue_nr;\n\tu8 trace_chan_id;\n\tu64 cs_timestamp;\n\n\t \n\twhile (1) {\n\t\t \n\t\tret = cs_etm__get_data_block(etmq);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tret = cs_etm__decode_data_block(etmq);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tcs_timestamp = cs_etm__etmq_get_timestamp(etmq, &trace_chan_id);\n\n\t\t \n\t\tif (cs_timestamp)\n\t\t\tbreak;\n\n\t\t \n\t\tcs_etm__clear_all_packet_queues(etmq);\n\t}\n\n\t \n\tcs_queue_nr = TO_CS_QUEUE_NR(queue_nr, trace_chan_id);\n\tret = auxtrace_heap__add(&etm->heap, cs_queue_nr, cs_timestamp);\nout:\n\treturn ret;\n}\n\nstatic inline\nvoid cs_etm__copy_last_branch_rb(struct cs_etm_queue *etmq,\n\t\t\t\t struct cs_etm_traceid_queue *tidq)\n{\n\tstruct branch_stack *bs_src = tidq->last_branch_rb;\n\tstruct branch_stack *bs_dst = tidq->last_branch;\n\tsize_t nr = 0;\n\n\t \n\tbs_dst->nr = bs_src->nr;\n\n\t \n\tif (!bs_src->nr)\n\t\treturn;\n\n\t \n\tnr = etmq->etm->synth_opts.last_branch_sz - tidq->last_branch_pos;\n\tmemcpy(&bs_dst->entries[0],\n\t       &bs_src->entries[tidq->last_branch_pos],\n\t       sizeof(struct branch_entry) * nr);\n\n\t \n\tif (bs_src->nr >= etmq->etm->synth_opts.last_branch_sz) {\n\t\tmemcpy(&bs_dst->entries[nr],\n\t\t       &bs_src->entries[0],\n\t\t       sizeof(struct branch_entry) * tidq->last_branch_pos);\n\t}\n}\n\nstatic inline\nvoid cs_etm__reset_last_branch_rb(struct cs_etm_traceid_queue *tidq)\n{\n\ttidq->last_branch_pos = 0;\n\ttidq->last_branch_rb->nr = 0;\n}\n\nstatic inline int cs_etm__t32_instr_size(struct cs_etm_queue *etmq,\n\t\t\t\t\t u8 trace_chan_id, u64 addr)\n{\n\tu8 instrBytes[2];\n\n\tcs_etm__mem_access(etmq, trace_chan_id, addr, ARRAY_SIZE(instrBytes),\n\t\t\t   instrBytes, 0);\n\t \n\treturn ((instrBytes[1] & 0xF8) >= 0xE8) ? 4 : 2;\n}\n\nstatic inline u64 cs_etm__first_executed_instr(struct cs_etm_packet *packet)\n{\n\t \n\tif (packet->sample_type == CS_ETM_DISCONTINUITY)\n\t\treturn 0;\n\n\treturn packet->start_addr;\n}\n\nstatic inline\nu64 cs_etm__last_executed_instr(const struct cs_etm_packet *packet)\n{\n\t \n\tif (packet->sample_type == CS_ETM_DISCONTINUITY)\n\t\treturn 0;\n\n\treturn packet->end_addr - packet->last_instr_size;\n}\n\nstatic inline u64 cs_etm__instr_addr(struct cs_etm_queue *etmq,\n\t\t\t\t     u64 trace_chan_id,\n\t\t\t\t     const struct cs_etm_packet *packet,\n\t\t\t\t     u64 offset)\n{\n\tif (packet->isa == CS_ETM_ISA_T32) {\n\t\tu64 addr = packet->start_addr;\n\n\t\twhile (offset) {\n\t\t\taddr += cs_etm__t32_instr_size(etmq,\n\t\t\t\t\t\t       trace_chan_id, addr);\n\t\t\toffset--;\n\t\t}\n\t\treturn addr;\n\t}\n\n\t \n\treturn packet->start_addr + offset * 4;\n}\n\nstatic void cs_etm__update_last_branch_rb(struct cs_etm_queue *etmq,\n\t\t\t\t\t  struct cs_etm_traceid_queue *tidq)\n{\n\tstruct branch_stack *bs = tidq->last_branch_rb;\n\tstruct branch_entry *be;\n\n\t \n\tif (!tidq->last_branch_pos)\n\t\ttidq->last_branch_pos = etmq->etm->synth_opts.last_branch_sz;\n\n\ttidq->last_branch_pos -= 1;\n\n\tbe       = &bs->entries[tidq->last_branch_pos];\n\tbe->from = cs_etm__last_executed_instr(tidq->prev_packet);\n\tbe->to\t = cs_etm__first_executed_instr(tidq->packet);\n\t \n\tbe->flags.mispred = 0;\n\tbe->flags.predicted = 1;\n\n\t \n\tif (bs->nr < etmq->etm->synth_opts.last_branch_sz)\n\t\tbs->nr += 1;\n}\n\nstatic int cs_etm__inject_event(union perf_event *event,\n\t\t\t       struct perf_sample *sample, u64 type)\n{\n\tevent->header.size = perf_event__sample_event_size(sample, type, 0);\n\treturn perf_event__synthesize_sample(event, type, 0, sample);\n}\n\n\nstatic int\ncs_etm__get_trace(struct cs_etm_queue *etmq)\n{\n\tstruct auxtrace_buffer *aux_buffer = etmq->buffer;\n\tstruct auxtrace_buffer *old_buffer = aux_buffer;\n\tstruct auxtrace_queue *queue;\n\n\tqueue = &etmq->etm->queues.queue_array[etmq->queue_nr];\n\n\taux_buffer = auxtrace_buffer__next(queue, aux_buffer);\n\n\t \n\tif (!aux_buffer) {\n\t\tif (old_buffer)\n\t\t\tauxtrace_buffer__drop_data(old_buffer);\n\t\tetmq->buf_len = 0;\n\t\treturn 0;\n\t}\n\n\tetmq->buffer = aux_buffer;\n\n\t \n\tif (!aux_buffer->data) {\n\t\t \n\t\tint fd = perf_data__fd(etmq->etm->session->data);\n\n\t\taux_buffer->data = auxtrace_buffer__get_data(aux_buffer, fd);\n\t\tif (!aux_buffer->data)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (old_buffer)\n\t\tauxtrace_buffer__drop_data(old_buffer);\n\n\tetmq->buf_used = 0;\n\tetmq->buf_len = aux_buffer->size;\n\tetmq->buf = aux_buffer->data;\n\n\treturn etmq->buf_len;\n}\n\nstatic void cs_etm__set_thread(struct cs_etm_queue *etmq,\n\t\t\t       struct cs_etm_traceid_queue *tidq, pid_t tid,\n\t\t\t       ocsd_ex_level el)\n{\n\tstruct machine *machine = cs_etm__get_machine(etmq, el);\n\n\tif (tid != -1) {\n\t\tthread__zput(tidq->thread);\n\t\ttidq->thread = machine__find_thread(machine, -1, tid);\n\t}\n\n\t \n\tif (!tidq->thread)\n\t\ttidq->thread = machine__idle_thread(machine);\n\n\ttidq->el = el;\n}\n\nint cs_etm__etmq_set_tid_el(struct cs_etm_queue *etmq, pid_t tid,\n\t\t\t    u8 trace_chan_id, ocsd_ex_level el)\n{\n\tstruct cs_etm_traceid_queue *tidq;\n\n\ttidq = cs_etm__etmq_get_traceid_queue(etmq, trace_chan_id);\n\tif (!tidq)\n\t\treturn -EINVAL;\n\n\tcs_etm__set_thread(etmq, tidq, tid, el);\n\treturn 0;\n}\n\nbool cs_etm__etmq_is_timeless(struct cs_etm_queue *etmq)\n{\n\treturn !!etmq->etm->timeless_decoding;\n}\n\nstatic void cs_etm__copy_insn(struct cs_etm_queue *etmq,\n\t\t\t      u64 trace_chan_id,\n\t\t\t      const struct cs_etm_packet *packet,\n\t\t\t      struct perf_sample *sample)\n{\n\t \n\tif (packet->sample_type == CS_ETM_DISCONTINUITY) {\n\t\tsample->insn_len = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (packet->isa == CS_ETM_ISA_T32)\n\t\tsample->insn_len = cs_etm__t32_instr_size(etmq, trace_chan_id,\n\t\t\t\t\t\t\t  sample->ip);\n\t \n\telse\n\t\tsample->insn_len = 4;\n\n\tcs_etm__mem_access(etmq, trace_chan_id, sample->ip, sample->insn_len,\n\t\t\t   (void *)sample->insn, 0);\n}\n\nu64 cs_etm__convert_sample_time(struct cs_etm_queue *etmq, u64 cs_timestamp)\n{\n\tstruct cs_etm_auxtrace *etm = etmq->etm;\n\n\tif (etm->has_virtual_ts)\n\t\treturn tsc_to_perf_time(cs_timestamp, &etm->tc);\n\telse\n\t\treturn cs_timestamp;\n}\n\nstatic inline u64 cs_etm__resolve_sample_time(struct cs_etm_queue *etmq,\n\t\t\t\t\t       struct cs_etm_traceid_queue *tidq)\n{\n\tstruct cs_etm_auxtrace *etm = etmq->etm;\n\tstruct cs_etm_packet_queue *packet_queue = &tidq->packet_queue;\n\n\tif (!etm->timeless_decoding && etm->has_virtual_ts)\n\t\treturn packet_queue->cs_timestamp;\n\telse\n\t\treturn etm->latest_kernel_timestamp;\n}\n\nstatic int cs_etm__synth_instruction_sample(struct cs_etm_queue *etmq,\n\t\t\t\t\t    struct cs_etm_traceid_queue *tidq,\n\t\t\t\t\t    u64 addr, u64 period)\n{\n\tint ret = 0;\n\tstruct cs_etm_auxtrace *etm = etmq->etm;\n\tunion perf_event *event = tidq->event_buf;\n\tstruct perf_sample sample = {.ip = 0,};\n\n\tevent->sample.header.type = PERF_RECORD_SAMPLE;\n\tevent->sample.header.misc = cs_etm__cpu_mode(etmq, addr, tidq->el);\n\tevent->sample.header.size = sizeof(struct perf_event_header);\n\n\t \n\tsample.time = cs_etm__resolve_sample_time(etmq, tidq);\n\n\tsample.ip = addr;\n\tsample.pid = thread__pid(tidq->thread);\n\tsample.tid = thread__tid(tidq->thread);\n\tsample.id = etmq->etm->instructions_id;\n\tsample.stream_id = etmq->etm->instructions_id;\n\tsample.period = period;\n\tsample.cpu = tidq->packet->cpu;\n\tsample.flags = tidq->prev_packet->flags;\n\tsample.cpumode = event->sample.header.misc;\n\n\tcs_etm__copy_insn(etmq, tidq->trace_chan_id, tidq->packet, &sample);\n\n\tif (etm->synth_opts.last_branch)\n\t\tsample.branch_stack = tidq->last_branch;\n\n\tif (etm->synth_opts.inject) {\n\t\tret = cs_etm__inject_event(event, &sample,\n\t\t\t\t\t   etm->instructions_sample_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = perf_session__deliver_synth_event(etm->session, event, &sample);\n\n\tif (ret)\n\t\tpr_err(\n\t\t\t\"CS ETM Trace: failed to deliver instruction event, error %d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\n \nstatic int cs_etm__synth_branch_sample(struct cs_etm_queue *etmq,\n\t\t\t\t       struct cs_etm_traceid_queue *tidq)\n{\n\tint ret = 0;\n\tstruct cs_etm_auxtrace *etm = etmq->etm;\n\tstruct perf_sample sample = {.ip = 0,};\n\tunion perf_event *event = tidq->event_buf;\n\tstruct dummy_branch_stack {\n\t\tu64\t\t\tnr;\n\t\tu64\t\t\thw_idx;\n\t\tstruct branch_entry\tentries;\n\t} dummy_bs;\n\tu64 ip;\n\n\tip = cs_etm__last_executed_instr(tidq->prev_packet);\n\n\tevent->sample.header.type = PERF_RECORD_SAMPLE;\n\tevent->sample.header.misc = cs_etm__cpu_mode(etmq, ip,\n\t\t\t\t\t\t     tidq->prev_packet_el);\n\tevent->sample.header.size = sizeof(struct perf_event_header);\n\n\t \n\tsample.time = cs_etm__resolve_sample_time(etmq, tidq);\n\n\tsample.ip = ip;\n\tsample.pid = thread__pid(tidq->prev_packet_thread);\n\tsample.tid = thread__tid(tidq->prev_packet_thread);\n\tsample.addr = cs_etm__first_executed_instr(tidq->packet);\n\tsample.id = etmq->etm->branches_id;\n\tsample.stream_id = etmq->etm->branches_id;\n\tsample.period = 1;\n\tsample.cpu = tidq->packet->cpu;\n\tsample.flags = tidq->prev_packet->flags;\n\tsample.cpumode = event->sample.header.misc;\n\n\tcs_etm__copy_insn(etmq, tidq->trace_chan_id, tidq->prev_packet,\n\t\t\t  &sample);\n\n\t \n\tif (etm->synth_opts.last_branch) {\n\t\tdummy_bs = (struct dummy_branch_stack){\n\t\t\t.nr = 1,\n\t\t\t.hw_idx = -1ULL,\n\t\t\t.entries = {\n\t\t\t\t.from = sample.ip,\n\t\t\t\t.to = sample.addr,\n\t\t\t},\n\t\t};\n\t\tsample.branch_stack = (struct branch_stack *)&dummy_bs;\n\t}\n\n\tif (etm->synth_opts.inject) {\n\t\tret = cs_etm__inject_event(event, &sample,\n\t\t\t\t\t   etm->branches_sample_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = perf_session__deliver_synth_event(etm->session, event, &sample);\n\n\tif (ret)\n\t\tpr_err(\n\t\t\"CS ETM Trace: failed to deliver instruction event, error %d\\n\",\n\t\tret);\n\n\treturn ret;\n}\n\nstruct cs_etm_synth {\n\tstruct perf_tool dummy_tool;\n\tstruct perf_session *session;\n};\n\nstatic int cs_etm__event_synth(struct perf_tool *tool,\n\t\t\t       union perf_event *event,\n\t\t\t       struct perf_sample *sample __maybe_unused,\n\t\t\t       struct machine *machine __maybe_unused)\n{\n\tstruct cs_etm_synth *cs_etm_synth =\n\t\t      container_of(tool, struct cs_etm_synth, dummy_tool);\n\n\treturn perf_session__deliver_synth_event(cs_etm_synth->session,\n\t\t\t\t\t\t event, NULL);\n}\n\nstatic int cs_etm__synth_event(struct perf_session *session,\n\t\t\t       struct perf_event_attr *attr, u64 id)\n{\n\tstruct cs_etm_synth cs_etm_synth;\n\n\tmemset(&cs_etm_synth, 0, sizeof(struct cs_etm_synth));\n\tcs_etm_synth.session = session;\n\n\treturn perf_event__synthesize_attr(&cs_etm_synth.dummy_tool, attr, 1,\n\t\t\t\t\t   &id, cs_etm__event_synth);\n}\n\nstatic int cs_etm__synth_events(struct cs_etm_auxtrace *etm,\n\t\t\t\tstruct perf_session *session)\n{\n\tstruct evlist *evlist = session->evlist;\n\tstruct evsel *evsel;\n\tstruct perf_event_attr attr;\n\tbool found = false;\n\tu64 id;\n\tint err;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.type == etm->pmu_type) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tpr_debug(\"No selected events with CoreSight Trace data\\n\");\n\t\treturn 0;\n\t}\n\n\tmemset(&attr, 0, sizeof(struct perf_event_attr));\n\tattr.size = sizeof(struct perf_event_attr);\n\tattr.type = PERF_TYPE_HARDWARE;\n\tattr.sample_type = evsel->core.attr.sample_type & PERF_SAMPLE_MASK;\n\tattr.sample_type |= PERF_SAMPLE_IP | PERF_SAMPLE_TID |\n\t\t\t    PERF_SAMPLE_PERIOD;\n\tif (etm->timeless_decoding)\n\t\tattr.sample_type &= ~(u64)PERF_SAMPLE_TIME;\n\telse\n\t\tattr.sample_type |= PERF_SAMPLE_TIME;\n\n\tattr.exclude_user = evsel->core.attr.exclude_user;\n\tattr.exclude_kernel = evsel->core.attr.exclude_kernel;\n\tattr.exclude_hv = evsel->core.attr.exclude_hv;\n\tattr.exclude_host = evsel->core.attr.exclude_host;\n\tattr.exclude_guest = evsel->core.attr.exclude_guest;\n\tattr.sample_id_all = evsel->core.attr.sample_id_all;\n\tattr.read_format = evsel->core.attr.read_format;\n\n\t \n\tid = evsel->core.id[0] + 1000000000;\n\n\tif (!id)\n\t\tid = 1;\n\n\tif (etm->synth_opts.branches) {\n\t\tattr.config = PERF_COUNT_HW_BRANCH_INSTRUCTIONS;\n\t\tattr.sample_period = 1;\n\t\tattr.sample_type |= PERF_SAMPLE_ADDR;\n\t\terr = cs_etm__synth_event(session, &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tetm->branches_sample_type = attr.sample_type;\n\t\tetm->branches_id = id;\n\t\tid += 1;\n\t\tattr.sample_type &= ~(u64)PERF_SAMPLE_ADDR;\n\t}\n\n\tif (etm->synth_opts.last_branch) {\n\t\tattr.sample_type |= PERF_SAMPLE_BRANCH_STACK;\n\t\t \n\t\tattr.branch_sample_type |= PERF_SAMPLE_BRANCH_HW_INDEX;\n\t}\n\n\tif (etm->synth_opts.instructions) {\n\t\tattr.config = PERF_COUNT_HW_INSTRUCTIONS;\n\t\tattr.sample_period = etm->synth_opts.period;\n\t\tetm->instructions_sample_period = attr.sample_period;\n\t\terr = cs_etm__synth_event(session, &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tetm->instructions_sample_type = attr.sample_type;\n\t\tetm->instructions_id = id;\n\t\tid += 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs_etm__sample(struct cs_etm_queue *etmq,\n\t\t\t  struct cs_etm_traceid_queue *tidq)\n{\n\tstruct cs_etm_auxtrace *etm = etmq->etm;\n\tint ret;\n\tu8 trace_chan_id = tidq->trace_chan_id;\n\tu64 instrs_prev;\n\n\t \n\tinstrs_prev = tidq->period_instructions;\n\n\ttidq->period_instructions += tidq->packet->instr_count;\n\n\t \n\tif (etm->synth_opts.last_branch &&\n\t    tidq->prev_packet->sample_type == CS_ETM_RANGE &&\n\t    tidq->prev_packet->last_instr_taken_branch)\n\t\tcs_etm__update_last_branch_rb(etmq, tidq);\n\n\tif (etm->synth_opts.instructions &&\n\t    tidq->period_instructions >= etm->instructions_sample_period) {\n\t\t \n\n\t\t \n\n\t\t \n\t\tu64 offset = etm->instructions_sample_period - instrs_prev;\n\t\tu64 addr;\n\n\t\t \n\t\tif (etm->synth_opts.last_branch)\n\t\t\tcs_etm__copy_last_branch_rb(etmq, tidq);\n\n\t\twhile (tidq->period_instructions >=\n\t\t\t\tetm->instructions_sample_period) {\n\t\t\t \n\t\t\taddr = cs_etm__instr_addr(etmq, trace_chan_id,\n\t\t\t\t\t\t  tidq->packet, offset - 1);\n\t\t\tret = cs_etm__synth_instruction_sample(\n\t\t\t\tetmq, tidq, addr,\n\t\t\t\tetm->instructions_sample_period);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toffset += etm->instructions_sample_period;\n\t\t\ttidq->period_instructions -=\n\t\t\t\tetm->instructions_sample_period;\n\t\t}\n\t}\n\n\tif (etm->synth_opts.branches) {\n\t\tbool generate_sample = false;\n\n\t\t \n\t\tif (tidq->prev_packet->sample_type == CS_ETM_DISCONTINUITY)\n\t\t\tgenerate_sample = true;\n\n\t\t \n\t\tif (tidq->prev_packet->sample_type == CS_ETM_RANGE &&\n\t\t    tidq->prev_packet->last_instr_taken_branch)\n\t\t\tgenerate_sample = true;\n\n\t\tif (generate_sample) {\n\t\t\tret = cs_etm__synth_branch_sample(etmq, tidq);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcs_etm__packet_swap(etm, tidq);\n\n\treturn 0;\n}\n\nstatic int cs_etm__exception(struct cs_etm_traceid_queue *tidq)\n{\n\t \n\tif (tidq->prev_packet->sample_type == CS_ETM_RANGE)\n\t\ttidq->prev_packet->last_instr_taken_branch = true;\n\n\treturn 0;\n}\n\nstatic int cs_etm__flush(struct cs_etm_queue *etmq,\n\t\t\t struct cs_etm_traceid_queue *tidq)\n{\n\tint err = 0;\n\tstruct cs_etm_auxtrace *etm = etmq->etm;\n\n\t \n\tif (tidq->prev_packet->sample_type == CS_ETM_EMPTY)\n\t\tgoto swap_packet;\n\n\tif (etmq->etm->synth_opts.last_branch &&\n\t    etmq->etm->synth_opts.instructions &&\n\t    tidq->prev_packet->sample_type == CS_ETM_RANGE) {\n\t\tu64 addr;\n\n\t\t \n\t\tcs_etm__copy_last_branch_rb(etmq, tidq);\n\n\t\t \n\t\taddr = cs_etm__last_executed_instr(tidq->prev_packet);\n\n\t\terr = cs_etm__synth_instruction_sample(\n\t\t\tetmq, tidq, addr,\n\t\t\ttidq->period_instructions);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttidq->period_instructions = 0;\n\n\t}\n\n\tif (etm->synth_opts.branches &&\n\t    tidq->prev_packet->sample_type == CS_ETM_RANGE) {\n\t\terr = cs_etm__synth_branch_sample(etmq, tidq);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\nswap_packet:\n\tcs_etm__packet_swap(etm, tidq);\n\n\t \n\tif (etm->synth_opts.last_branch)\n\t\tcs_etm__reset_last_branch_rb(tidq);\n\n\treturn err;\n}\n\nstatic int cs_etm__end_block(struct cs_etm_queue *etmq,\n\t\t\t     struct cs_etm_traceid_queue *tidq)\n{\n\tint err;\n\n\t \n\tif (etmq->etm->synth_opts.last_branch &&\n\t    etmq->etm->synth_opts.instructions &&\n\t    tidq->prev_packet->sample_type == CS_ETM_RANGE) {\n\t\tu64 addr;\n\n\t\t \n\t\tcs_etm__copy_last_branch_rb(etmq, tidq);\n\n\t\t \n\t\taddr = cs_etm__last_executed_instr(tidq->prev_packet);\n\n\t\terr = cs_etm__synth_instruction_sample(\n\t\t\tetmq, tidq, addr,\n\t\t\ttidq->period_instructions);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttidq->period_instructions = 0;\n\t}\n\n\treturn 0;\n}\n \nstatic int cs_etm__get_data_block(struct cs_etm_queue *etmq)\n{\n\tint ret;\n\n\tif (!etmq->buf_len) {\n\t\tret = cs_etm__get_trace(etmq);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t\t \n\t\tret = cs_etm_decoder__reset(etmq->decoder);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn etmq->buf_len;\n}\n\nstatic bool cs_etm__is_svc_instr(struct cs_etm_queue *etmq, u8 trace_chan_id,\n\t\t\t\t struct cs_etm_packet *packet,\n\t\t\t\t u64 end_addr)\n{\n\t \n\tu16 instr16 = 0;\n\tu32 instr32 = 0;\n\tu64 addr;\n\n\tswitch (packet->isa) {\n\tcase CS_ETM_ISA_T32:\n\t\t \n\t\taddr = end_addr - 2;\n\t\tcs_etm__mem_access(etmq, trace_chan_id, addr, sizeof(instr16),\n\t\t\t\t   (u8 *)&instr16, 0);\n\t\tif ((instr16 & 0xFF00) == 0xDF00)\n\t\t\treturn true;\n\n\t\tbreak;\n\tcase CS_ETM_ISA_A32:\n\t\t \n\t\taddr = end_addr - 4;\n\t\tcs_etm__mem_access(etmq, trace_chan_id, addr, sizeof(instr32),\n\t\t\t\t   (u8 *)&instr32, 0);\n\t\tif ((instr32 & 0x0F000000) == 0x0F000000 &&\n\t\t    (instr32 & 0xF0000000) != 0xF0000000)\n\t\t\treturn true;\n\n\t\tbreak;\n\tcase CS_ETM_ISA_A64:\n\t\t \n\t\taddr = end_addr - 4;\n\t\tcs_etm__mem_access(etmq, trace_chan_id, addr, sizeof(instr32),\n\t\t\t\t   (u8 *)&instr32, 0);\n\t\tif ((instr32 & 0xFFE0001F) == 0xd4000001)\n\t\t\treturn true;\n\n\t\tbreak;\n\tcase CS_ETM_ISA_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool cs_etm__is_syscall(struct cs_etm_queue *etmq,\n\t\t\t       struct cs_etm_traceid_queue *tidq, u64 magic)\n{\n\tu8 trace_chan_id = tidq->trace_chan_id;\n\tstruct cs_etm_packet *packet = tidq->packet;\n\tstruct cs_etm_packet *prev_packet = tidq->prev_packet;\n\n\tif (magic == __perf_cs_etmv3_magic)\n\t\tif (packet->exception_number == CS_ETMV3_EXC_SVC)\n\t\t\treturn true;\n\n\t \n\tif (magic == __perf_cs_etmv4_magic) {\n\t\tif (packet->exception_number == CS_ETMV4_EXC_CALL &&\n\t\t    cs_etm__is_svc_instr(etmq, trace_chan_id, prev_packet,\n\t\t\t\t\t prev_packet->end_addr))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool cs_etm__is_async_exception(struct cs_etm_traceid_queue *tidq,\n\t\t\t\t       u64 magic)\n{\n\tstruct cs_etm_packet *packet = tidq->packet;\n\n\tif (magic == __perf_cs_etmv3_magic)\n\t\tif (packet->exception_number == CS_ETMV3_EXC_DEBUG_HALT ||\n\t\t    packet->exception_number == CS_ETMV3_EXC_ASYNC_DATA_ABORT ||\n\t\t    packet->exception_number == CS_ETMV3_EXC_PE_RESET ||\n\t\t    packet->exception_number == CS_ETMV3_EXC_IRQ ||\n\t\t    packet->exception_number == CS_ETMV3_EXC_FIQ)\n\t\t\treturn true;\n\n\tif (magic == __perf_cs_etmv4_magic)\n\t\tif (packet->exception_number == CS_ETMV4_EXC_RESET ||\n\t\t    packet->exception_number == CS_ETMV4_EXC_DEBUG_HALT ||\n\t\t    packet->exception_number == CS_ETMV4_EXC_SYSTEM_ERROR ||\n\t\t    packet->exception_number == CS_ETMV4_EXC_INST_DEBUG ||\n\t\t    packet->exception_number == CS_ETMV4_EXC_DATA_DEBUG ||\n\t\t    packet->exception_number == CS_ETMV4_EXC_IRQ ||\n\t\t    packet->exception_number == CS_ETMV4_EXC_FIQ)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool cs_etm__is_sync_exception(struct cs_etm_queue *etmq,\n\t\t\t\t      struct cs_etm_traceid_queue *tidq,\n\t\t\t\t      u64 magic)\n{\n\tu8 trace_chan_id = tidq->trace_chan_id;\n\tstruct cs_etm_packet *packet = tidq->packet;\n\tstruct cs_etm_packet *prev_packet = tidq->prev_packet;\n\n\tif (magic == __perf_cs_etmv3_magic)\n\t\tif (packet->exception_number == CS_ETMV3_EXC_SMC ||\n\t\t    packet->exception_number == CS_ETMV3_EXC_HYP ||\n\t\t    packet->exception_number == CS_ETMV3_EXC_JAZELLE_THUMBEE ||\n\t\t    packet->exception_number == CS_ETMV3_EXC_UNDEFINED_INSTR ||\n\t\t    packet->exception_number == CS_ETMV3_EXC_PREFETCH_ABORT ||\n\t\t    packet->exception_number == CS_ETMV3_EXC_DATA_FAULT ||\n\t\t    packet->exception_number == CS_ETMV3_EXC_GENERIC)\n\t\t\treturn true;\n\n\tif (magic == __perf_cs_etmv4_magic) {\n\t\tif (packet->exception_number == CS_ETMV4_EXC_TRAP ||\n\t\t    packet->exception_number == CS_ETMV4_EXC_ALIGNMENT ||\n\t\t    packet->exception_number == CS_ETMV4_EXC_INST_FAULT ||\n\t\t    packet->exception_number == CS_ETMV4_EXC_DATA_FAULT)\n\t\t\treturn true;\n\n\t\t \n\t\tif (packet->exception_number == CS_ETMV4_EXC_CALL &&\n\t\t    !cs_etm__is_svc_instr(etmq, trace_chan_id, prev_packet,\n\t\t\t\t\t  prev_packet->end_addr))\n\t\t\treturn true;\n\n\t\t \n\t\tif (packet->exception_number > CS_ETMV4_EXC_FIQ &&\n\t\t    packet->exception_number <= CS_ETMV4_EXC_END)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int cs_etm__set_sample_flags(struct cs_etm_queue *etmq,\n\t\t\t\t    struct cs_etm_traceid_queue *tidq)\n{\n\tstruct cs_etm_packet *packet = tidq->packet;\n\tstruct cs_etm_packet *prev_packet = tidq->prev_packet;\n\tu8 trace_chan_id = tidq->trace_chan_id;\n\tu64 magic;\n\tint ret;\n\n\tswitch (packet->sample_type) {\n\tcase CS_ETM_RANGE:\n\t\t \n\t\tif (packet->last_instr_type == OCSD_INSTR_BR &&\n\t\t    packet->last_instr_subtype == OCSD_S_INSTR_NONE) {\n\t\t\tpacket->flags = PERF_IP_FLAG_BRANCH;\n\n\t\t\tif (packet->last_instr_cond)\n\t\t\t\tpacket->flags |= PERF_IP_FLAG_CONDITIONAL;\n\t\t}\n\n\t\t \n\t\tif (packet->last_instr_type == OCSD_INSTR_BR &&\n\t\t    packet->last_instr_subtype == OCSD_S_INSTR_BR_LINK)\n\t\t\tpacket->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t\tPERF_IP_FLAG_CALL;\n\n\t\t \n\t\tif (packet->last_instr_type == OCSD_INSTR_BR_INDIRECT &&\n\t\t    packet->last_instr_subtype == OCSD_S_INSTR_BR_LINK)\n\t\t\tpacket->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t\tPERF_IP_FLAG_CALL;\n\n\t\t \n\t\tif (packet->last_instr_type == OCSD_INSTR_BR_INDIRECT &&\n\t\t    packet->last_instr_subtype == OCSD_S_INSTR_V7_IMPLIED_RET)\n\t\t\tpacket->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t\tPERF_IP_FLAG_RETURN;\n\n\t\t \n\t\tif (packet->last_instr_type == OCSD_INSTR_BR_INDIRECT &&\n\t\t    packet->last_instr_subtype == OCSD_S_INSTR_NONE)\n\t\t\tpacket->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t\tPERF_IP_FLAG_RETURN;\n\n\t\t \n\t\tif (packet->last_instr_type == OCSD_INSTR_BR_INDIRECT &&\n\t\t    packet->last_instr_subtype == OCSD_S_INSTR_V8_RET)\n\t\t\tpacket->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t\tPERF_IP_FLAG_RETURN;\n\n\t\t \n\t\tif (prev_packet->sample_type == CS_ETM_DISCONTINUITY)\n\t\t\tprev_packet->flags |= PERF_IP_FLAG_BRANCH |\n\t\t\t\t\t      PERF_IP_FLAG_TRACE_BEGIN;\n\n\t\t \n\t\tif (prev_packet->flags == (PERF_IP_FLAG_BRANCH |\n\t\t\t\t\t   PERF_IP_FLAG_RETURN |\n\t\t\t\t\t   PERF_IP_FLAG_INTERRUPT) &&\n\t\t    cs_etm__is_svc_instr(etmq, trace_chan_id,\n\t\t\t\t\t packet, packet->start_addr))\n\t\t\tprev_packet->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t\t     PERF_IP_FLAG_RETURN |\n\t\t\t\t\t     PERF_IP_FLAG_SYSCALLRET;\n\t\tbreak;\n\tcase CS_ETM_DISCONTINUITY:\n\t\t \n\t\tif (prev_packet->sample_type == CS_ETM_RANGE)\n\t\t\tprev_packet->flags |= PERF_IP_FLAG_BRANCH |\n\t\t\t\t\t      PERF_IP_FLAG_TRACE_END;\n\t\tbreak;\n\tcase CS_ETM_EXCEPTION:\n\t\tret = cs_etm__get_magic(packet->trace_chan_id, &magic);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (cs_etm__is_syscall(etmq, tidq, magic))\n\t\t\tpacket->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t\tPERF_IP_FLAG_CALL |\n\t\t\t\t\tPERF_IP_FLAG_SYSCALLRET;\n\t\t \n\t\telse if (cs_etm__is_async_exception(tidq, magic))\n\t\t\tpacket->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t\tPERF_IP_FLAG_CALL |\n\t\t\t\t\tPERF_IP_FLAG_ASYNC |\n\t\t\t\t\tPERF_IP_FLAG_INTERRUPT;\n\t\t \n\t\telse if (cs_etm__is_sync_exception(etmq, tidq, magic))\n\t\t\tpacket->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t\tPERF_IP_FLAG_CALL |\n\t\t\t\t\tPERF_IP_FLAG_INTERRUPT;\n\n\t\t \n\t\tif (prev_packet->sample_type == CS_ETM_RANGE)\n\t\t\tprev_packet->flags = packet->flags;\n\t\tbreak;\n\tcase CS_ETM_EXCEPTION_RET:\n\t\t \n\t\tif (prev_packet->sample_type == CS_ETM_RANGE)\n\t\t\tprev_packet->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t\t     PERF_IP_FLAG_RETURN |\n\t\t\t\t\t     PERF_IP_FLAG_INTERRUPT;\n\t\tbreak;\n\tcase CS_ETM_EMPTY:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs_etm__decode_data_block(struct cs_etm_queue *etmq)\n{\n\tint ret = 0;\n\tsize_t processed = 0;\n\n\t \n\tret = cs_etm_decoder__process_data_block(etmq->decoder,\n\t\t\t\t\t\t etmq->offset,\n\t\t\t\t\t\t &etmq->buf[etmq->buf_used],\n\t\t\t\t\t\t etmq->buf_len,\n\t\t\t\t\t\t &processed);\n\tif (ret)\n\t\tgoto out;\n\n\tetmq->offset += processed;\n\tetmq->buf_used += processed;\n\tetmq->buf_len -= processed;\n\nout:\n\treturn ret;\n}\n\nstatic int cs_etm__process_traceid_queue(struct cs_etm_queue *etmq,\n\t\t\t\t\t struct cs_etm_traceid_queue *tidq)\n{\n\tint ret;\n\tstruct cs_etm_packet_queue *packet_queue;\n\n\tpacket_queue = &tidq->packet_queue;\n\n\t \n\twhile (1) {\n\t\tret = cs_etm_decoder__get_packet(packet_queue,\n\t\t\t\t\t\t tidq->packet);\n\t\tif (ret <= 0)\n\t\t\t \n\t\t\tbreak;\n\n\t\t \n\t\tret = cs_etm__set_sample_flags(etmq, tidq);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tswitch (tidq->packet->sample_type) {\n\t\tcase CS_ETM_RANGE:\n\t\t\t \n\t\t\tcs_etm__sample(etmq, tidq);\n\t\t\tbreak;\n\t\tcase CS_ETM_EXCEPTION:\n\t\tcase CS_ETM_EXCEPTION_RET:\n\t\t\t \n\t\t\tcs_etm__exception(tidq);\n\t\t\tbreak;\n\t\tcase CS_ETM_DISCONTINUITY:\n\t\t\t \n\t\t\tcs_etm__flush(etmq, tidq);\n\t\t\tbreak;\n\t\tcase CS_ETM_EMPTY:\n\t\t\t \n\t\t\tpr_err(\"CS ETM Trace: empty packet\\n\");\n\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void cs_etm__clear_all_traceid_queues(struct cs_etm_queue *etmq)\n{\n\tint idx;\n\tstruct int_node *inode;\n\tstruct cs_etm_traceid_queue *tidq;\n\tstruct intlist *traceid_queues_list = etmq->traceid_queues_list;\n\n\tintlist__for_each_entry(inode, traceid_queues_list) {\n\t\tidx = (int)(intptr_t)inode->priv;\n\t\ttidq = etmq->traceid_queues[idx];\n\n\t\t \n\t\tcs_etm__process_traceid_queue(etmq, tidq);\n\n\t\t \n\t\tcs_etm__flush(etmq, tidq);\n\t}\n}\n\nstatic int cs_etm__run_per_thread_timeless_decoder(struct cs_etm_queue *etmq)\n{\n\tint err = 0;\n\tstruct cs_etm_traceid_queue *tidq;\n\n\ttidq = cs_etm__etmq_get_traceid_queue(etmq, CS_ETM_PER_THREAD_TRACEID);\n\tif (!tidq)\n\t\treturn -EINVAL;\n\n\t \n\twhile (1) {\n\t\terr = cs_etm__get_data_block(etmq);\n\t\tif (err <= 0)\n\t\t\treturn err;\n\n\t\t \n\t\tdo {\n\t\t\terr = cs_etm__decode_data_block(etmq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\terr = cs_etm__process_traceid_queue(etmq, tidq);\n\n\t\t} while (etmq->buf_len);\n\n\t\tif (err == 0)\n\t\t\t \n\t\t\terr = cs_etm__end_block(etmq, tidq);\n\t}\n\n\treturn err;\n}\n\nstatic int cs_etm__run_per_cpu_timeless_decoder(struct cs_etm_queue *etmq)\n{\n\tint idx, err = 0;\n\tstruct cs_etm_traceid_queue *tidq;\n\tstruct int_node *inode;\n\n\t \n\twhile (1) {\n\t\terr = cs_etm__get_data_block(etmq);\n\t\tif (err <= 0)\n\t\t\treturn err;\n\n\t\t \n\t\tdo {\n\t\t\terr = cs_etm__decode_data_block(etmq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\tintlist__for_each_entry(inode,\n\t\t\t\t\t\tetmq->traceid_queues_list) {\n\t\t\t\tidx = (int)(intptr_t)inode->priv;\n\t\t\t\ttidq = etmq->traceid_queues[idx];\n\t\t\t\tcs_etm__process_traceid_queue(etmq, tidq);\n\t\t\t}\n\t\t} while (etmq->buf_len);\n\n\t\tintlist__for_each_entry(inode, etmq->traceid_queues_list) {\n\t\t\tidx = (int)(intptr_t)inode->priv;\n\t\t\ttidq = etmq->traceid_queues[idx];\n\t\t\t \n\t\t\terr = cs_etm__end_block(etmq, tidq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int cs_etm__process_timeless_queues(struct cs_etm_auxtrace *etm,\n\t\t\t\t\t   pid_t tid)\n{\n\tunsigned int i;\n\tstruct auxtrace_queues *queues = &etm->queues;\n\n\tfor (i = 0; i < queues->nr_queues; i++) {\n\t\tstruct auxtrace_queue *queue = &etm->queues.queue_array[i];\n\t\tstruct cs_etm_queue *etmq = queue->priv;\n\t\tstruct cs_etm_traceid_queue *tidq;\n\n\t\tif (!etmq)\n\t\t\tcontinue;\n\n\t\tif (etm->per_thread_decoding) {\n\t\t\ttidq = cs_etm__etmq_get_traceid_queue(\n\t\t\t\tetmq, CS_ETM_PER_THREAD_TRACEID);\n\n\t\t\tif (!tidq)\n\t\t\t\tcontinue;\n\n\t\t\tif (tid == -1 || thread__tid(tidq->thread) == tid)\n\t\t\t\tcs_etm__run_per_thread_timeless_decoder(etmq);\n\t\t} else\n\t\t\tcs_etm__run_per_cpu_timeless_decoder(etmq);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs_etm__process_timestamped_queues(struct cs_etm_auxtrace *etm)\n{\n\tint ret = 0;\n\tunsigned int cs_queue_nr, queue_nr, i;\n\tu8 trace_chan_id;\n\tu64 cs_timestamp;\n\tstruct auxtrace_queue *queue;\n\tstruct cs_etm_queue *etmq;\n\tstruct cs_etm_traceid_queue *tidq;\n\n\t \n\tfor (i = 0; i < etm->queues.nr_queues; i++) {\n\t\tetmq = etm->queues.queue_array[i].priv;\n\t\tif (!etmq)\n\t\t\tcontinue;\n\n\t\tret = cs_etm__queue_first_cs_timestamp(etm, etmq, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twhile (1) {\n\t\tif (!etm->heap.heap_cnt)\n\t\t\tgoto out;\n\n\t\t \n\t\tcs_queue_nr = etm->heap.heap_array[0].queue_nr;\n\t\tqueue_nr = TO_QUEUE_NR(cs_queue_nr);\n\t\ttrace_chan_id = TO_TRACE_CHAN_ID(cs_queue_nr);\n\t\tqueue = &etm->queues.queue_array[queue_nr];\n\t\tetmq = queue->priv;\n\n\t\t \n\t\tauxtrace_heap__pop(&etm->heap);\n\n\t\ttidq  = cs_etm__etmq_get_traceid_queue(etmq, trace_chan_id);\n\t\tif (!tidq) {\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = cs_etm__process_traceid_queue(etmq, tidq);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \nrefetch:\n\t\tret = cs_etm__get_data_block(etmq);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (!ret)\n\t\t\tcontinue;\n\n\t\tret = cs_etm__decode_data_block(etmq);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tcs_timestamp = cs_etm__etmq_get_timestamp(etmq, &trace_chan_id);\n\n\t\tif (!cs_timestamp) {\n\t\t\t \n\t\t\tcs_etm__clear_all_traceid_queues(etmq);\n\n\t\t\t \n\t\t\tgoto refetch;\n\t\t}\n\n\t\t \n\t\tcs_queue_nr = TO_CS_QUEUE_NR(queue_nr, trace_chan_id);\n\t\tret = auxtrace_heap__add(&etm->heap, cs_queue_nr, cs_timestamp);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int cs_etm__process_itrace_start(struct cs_etm_auxtrace *etm,\n\t\t\t\t\tunion perf_event *event)\n{\n\tstruct thread *th;\n\n\tif (etm->timeless_decoding)\n\t\treturn 0;\n\n\t \n\tth = machine__findnew_thread(&etm->session->machines.host,\n\t\t\t\t     event->itrace_start.pid,\n\t\t\t\t     event->itrace_start.tid);\n\tif (!th)\n\t\treturn -ENOMEM;\n\n\tthread__put(th);\n\n\treturn 0;\n}\n\nstatic int cs_etm__process_switch_cpu_wide(struct cs_etm_auxtrace *etm,\n\t\t\t\t\t   union perf_event *event)\n{\n\tstruct thread *th;\n\tbool out = event->header.misc & PERF_RECORD_MISC_SWITCH_OUT;\n\n\t \n\tif (etm->timeless_decoding)\n\t\treturn 0;\n\n\t \n\tif (!out)\n\t\treturn 0;\n\n\t \n\tth = machine__findnew_thread(&etm->session->machines.host,\n\t\t\t\t     event->context_switch.next_prev_pid,\n\t\t\t\t     event->context_switch.next_prev_tid);\n\tif (!th)\n\t\treturn -ENOMEM;\n\n\tthread__put(th);\n\n\treturn 0;\n}\n\nstatic int cs_etm__process_event(struct perf_session *session,\n\t\t\t\t union perf_event *event,\n\t\t\t\t struct perf_sample *sample,\n\t\t\t\t struct perf_tool *tool)\n{\n\tstruct cs_etm_auxtrace *etm = container_of(session->auxtrace,\n\t\t\t\t\t\t   struct cs_etm_auxtrace,\n\t\t\t\t\t\t   auxtrace);\n\n\tif (dump_trace)\n\t\treturn 0;\n\n\tif (!tool->ordered_events) {\n\t\tpr_err(\"CoreSight ETM Trace requires ordered events\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (event->header.type) {\n\tcase PERF_RECORD_EXIT:\n\t\t \n\t\tif (etm->per_thread_decoding && etm->timeless_decoding)\n\t\t\treturn cs_etm__process_timeless_queues(etm,\n\t\t\t\t\t\t\t       event->fork.tid);\n\t\tbreak;\n\n\tcase PERF_RECORD_ITRACE_START:\n\t\treturn cs_etm__process_itrace_start(etm, event);\n\n\tcase PERF_RECORD_SWITCH_CPU_WIDE:\n\t\treturn cs_etm__process_switch_cpu_wide(etm, event);\n\n\tcase PERF_RECORD_AUX:\n\t\t \n\t\tif (sample->time && (sample->time != (u64)-1))\n\t\t\tetm->latest_kernel_timestamp = sample->time;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void dump_queued_data(struct cs_etm_auxtrace *etm,\n\t\t\t     struct perf_record_auxtrace *event)\n{\n\tstruct auxtrace_buffer *buf;\n\tunsigned int i;\n\t \n\tfor (i = 0; i < etm->queues.nr_queues; ++i)\n\t\tlist_for_each_entry(buf, &etm->queues.queue_array[i].head, list)\n\t\t\tif (buf->reference == event->reference)\n\t\t\t\tcs_etm__dump_event(etm->queues.queue_array[i].priv, buf);\n}\n\nstatic int cs_etm__process_auxtrace_event(struct perf_session *session,\n\t\t\t\t\t  union perf_event *event,\n\t\t\t\t\t  struct perf_tool *tool __maybe_unused)\n{\n\tstruct cs_etm_auxtrace *etm = container_of(session->auxtrace,\n\t\t\t\t\t\t   struct cs_etm_auxtrace,\n\t\t\t\t\t\t   auxtrace);\n\tif (!etm->data_queued) {\n\t\tstruct auxtrace_buffer *buffer;\n\t\toff_t  data_offset;\n\t\tint fd = perf_data__fd(session->data);\n\t\tbool is_pipe = perf_data__is_pipe(session->data);\n\t\tint err;\n\t\tint idx = event->auxtrace.idx;\n\n\t\tif (is_pipe)\n\t\t\tdata_offset = 0;\n\t\telse {\n\t\t\tdata_offset = lseek(fd, 0, SEEK_CUR);\n\t\t\tif (data_offset == -1)\n\t\t\t\treturn -errno;\n\t\t}\n\n\t\terr = auxtrace_queues__add_event(&etm->queues, session,\n\t\t\t\t\t\t event, data_offset, &buffer);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = cs_etm__setup_queue(etm, &etm->queues.queue_array[idx],\n\t\t\t\t\t  idx, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (dump_trace)\n\t\t\tif (auxtrace_buffer__get_data(buffer, fd)) {\n\t\t\t\tcs_etm__dump_event(etm->queues.queue_array[idx].priv, buffer);\n\t\t\t\tauxtrace_buffer__put_data(buffer);\n\t\t\t}\n\t} else if (dump_trace)\n\t\tdump_queued_data(etm, &event->auxtrace);\n\n\treturn 0;\n}\n\nstatic int cs_etm__setup_timeless_decoding(struct cs_etm_auxtrace *etm)\n{\n\tstruct evsel *evsel;\n\tstruct evlist *evlist = etm->session->evlist;\n\n\t \n\tif (etm->synth_opts.timeless_decoding) {\n\t\tetm->timeless_decoding = true;\n\t\treturn 0;\n\t}\n\n\t \n\tevlist__for_each_entry(evlist, evsel)\n\t\tif (cs_etm__evsel_is_auxtrace(etm->session, evsel)) {\n\t\t\tetm->timeless_decoding =\n\t\t\t\t!(evsel->core.attr.config & BIT(ETM_OPT_TS));\n\t\t\treturn 0;\n\t\t}\n\n\tpr_err(\"CS ETM: Couldn't find ETM evsel\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic u64 *cs_etm__create_meta_blk(u64 *buff_in, int *buff_in_offset,\n\t\t\t\t    int out_blk_size, int nr_params_v0)\n{\n\tu64 *metadata = NULL;\n\tint hdr_version;\n\tint nr_in_params, nr_out_params, nr_cmn_params;\n\tint i, k;\n\n\tmetadata = zalloc(sizeof(*metadata) * out_blk_size);\n\tif (!metadata)\n\t\treturn NULL;\n\n\t \n\ti = *buff_in_offset;\n\thdr_version = buff_in[CS_HEADER_VERSION];\n\n\tif (!hdr_version) {\n\t \n\t\tnr_in_params = nr_params_v0;\n\t\tmetadata[CS_ETM_MAGIC] = buff_in[i + CS_ETM_MAGIC];\n\t\tmetadata[CS_ETM_CPU] = buff_in[i + CS_ETM_CPU];\n\t\tmetadata[CS_ETM_NR_TRC_PARAMS] = nr_in_params;\n\t\t \n\t\tfor (k = CS_ETM_COMMON_BLK_MAX_V1 - 1; k < nr_in_params; k++)\n\t\t\tmetadata[k + 1] = buff_in[i + k];\n\t\t \n\t\tnr_cmn_params = 2;\n\t} else {\n\t \n\t\t \n\t\tnr_cmn_params = 3;\n\t\tnr_in_params = buff_in[i + CS_ETM_NR_TRC_PARAMS];\n\n\t\t \n\t\tnr_out_params = nr_in_params + nr_cmn_params;\n\t\tif (nr_out_params > out_blk_size)\n\t\t\tnr_out_params = out_blk_size;\n\n\t\tfor (k = CS_ETM_MAGIC; k < nr_out_params; k++)\n\t\t\tmetadata[k] = buff_in[i + k];\n\n\t\t \n\t\tmetadata[CS_ETM_NR_TRC_PARAMS] = nr_out_params - nr_cmn_params;\n\t}\n\n\t \n\ti += nr_in_params + nr_cmn_params;\n\t*buff_in_offset = i;\n\treturn metadata;\n}\n\n \nstatic int cs_etm__queue_aux_fragment(struct perf_session *session, off_t file_offset, size_t sz,\n\t\t\t\t      struct perf_record_aux *aux_event, struct perf_sample *sample)\n{\n\tint err;\n\tchar buf[PERF_SAMPLE_MAX_SIZE];\n\tunion perf_event *auxtrace_event_union;\n\tstruct perf_record_auxtrace *auxtrace_event;\n\tunion perf_event auxtrace_fragment;\n\t__u64 aux_offset, aux_size;\n\t__u32 idx;\n\tbool formatted;\n\n\tstruct cs_etm_auxtrace *etm = container_of(session->auxtrace,\n\t\t\t\t\t\t   struct cs_etm_auxtrace,\n\t\t\t\t\t\t   auxtrace);\n\n\t \n\terr = perf_session__peek_event(session, file_offset, buf,\n\t\t\t\t       PERF_SAMPLE_MAX_SIZE, &auxtrace_event_union, NULL);\n\tif (err)\n\t\treturn err;\n\tauxtrace_event = &auxtrace_event_union->auxtrace;\n\tif (auxtrace_event->header.type != PERF_RECORD_AUXTRACE)\n\t\treturn -EINVAL;\n\n\tif (auxtrace_event->header.size < sizeof(struct perf_record_auxtrace) ||\n\t\tauxtrace_event->header.size != sz) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (auxtrace_event->cpu == (__u32) -1) {\n\t\tetm->per_thread_decoding = true;\n\t\tif (auxtrace_event->tid != sample->tid)\n\t\t\treturn 1;\n\t} else if (auxtrace_event->cpu != sample->cpu) {\n\t\tif (etm->per_thread_decoding) {\n\t\t\t \n\t\t\tpr_err(\"CS ETM: Inconsistent per-thread/per-cpu mode.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (aux_event->flags & PERF_AUX_FLAG_OVERWRITE) {\n\t\t \n\t\taux_size = min(aux_event->aux_size, auxtrace_event->size);\n\n\t\t \n\t\taux_offset = aux_event->aux_offset - aux_size;\n\t} else {\n\t\taux_size = aux_event->aux_size;\n\t\taux_offset = aux_event->aux_offset;\n\t}\n\n\tif (aux_offset >= auxtrace_event->offset &&\n\t    aux_offset + aux_size <= auxtrace_event->offset + auxtrace_event->size) {\n\t\t \n\t\tauxtrace_fragment.auxtrace = *auxtrace_event;\n\t\tauxtrace_fragment.auxtrace.size = aux_size;\n\t\tauxtrace_fragment.auxtrace.offset = aux_offset;\n\t\tfile_offset += aux_offset - auxtrace_event->offset + auxtrace_event->header.size;\n\n\t\tpr_debug3(\"CS ETM: Queue buffer size: %#\"PRI_lx64\" offset: %#\"PRI_lx64\n\t\t\t  \" tid: %d cpu: %d\\n\", aux_size, aux_offset, sample->tid, sample->cpu);\n\t\terr = auxtrace_queues__add_event(&etm->queues, session, &auxtrace_fragment,\n\t\t\t\t\t\t file_offset, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tidx = auxtrace_event->idx;\n\t\tformatted = !(aux_event->flags & PERF_AUX_FLAG_CORESIGHT_FORMAT_RAW);\n\t\treturn cs_etm__setup_queue(etm, &etm->queues.queue_array[idx],\n\t\t\t\t\t   idx, formatted);\n\t}\n\n\t \n\treturn 1;\n}\n\nstatic int cs_etm__process_aux_hw_id_cb(struct perf_session *session, union perf_event *event,\n\t\t\t\t\tu64 offset __maybe_unused, void *data __maybe_unused)\n{\n\t \n\tif (event->header.type == PERF_RECORD_AUX_OUTPUT_HW_ID) {\n\t\t(*(int *)data)++;  \n\t\treturn cs_etm__process_aux_output_hw_id(session, event);\n\t}\n\treturn 0;\n}\n\nstatic int cs_etm__queue_aux_records_cb(struct perf_session *session, union perf_event *event,\n\t\t\t\t\tu64 offset __maybe_unused, void *data __maybe_unused)\n{\n\tstruct perf_sample sample;\n\tint ret;\n\tstruct auxtrace_index_entry *ent;\n\tstruct auxtrace_index *auxtrace_index;\n\tstruct evsel *evsel;\n\tsize_t i;\n\n\t \n\tif (event->header.type != PERF_RECORD_AUX)\n\t\treturn 0;\n\n\tif (event->header.size < sizeof(struct perf_record_aux))\n\t\treturn -EINVAL;\n\n\t \n\tif (!event->aux.aux_size)\n\t\treturn 0;\n\n\t \n\tevsel = evlist__event2evsel(session->evlist, event);\n\tif (!evsel)\n\t\treturn -EINVAL;\n\tret = evsel__parse_sample(evsel, event, &sample);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlist_for_each_entry(auxtrace_index, &session->auxtrace_index, list) {\n\t\tfor (i = 0; i < auxtrace_index->nr; i++) {\n\t\t\tent = &auxtrace_index->entries[i];\n\t\t\tret = cs_etm__queue_aux_fragment(session, ent->file_offset,\n\t\t\t\t\t\t\t ent->sz, &event->aux, &sample);\n\t\t\t \n\t\t\tif (ret != 1)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tpr_err(\"CS ETM: Couldn't find auxtrace buffer for aux_offset: %#\"PRI_lx64\n\t       \" tid: %d cpu: %d\\n\", event->aux.aux_offset, sample.tid, sample.cpu);\n\treturn 0;\n}\n\nstatic int cs_etm__queue_aux_records(struct perf_session *session)\n{\n\tstruct auxtrace_index *index = list_first_entry_or_null(&session->auxtrace_index,\n\t\t\t\t\t\t\t\tstruct auxtrace_index, list);\n\tif (index && index->nr > 0)\n\t\treturn perf_session__peek_events(session, session->header.data_offset,\n\t\t\t\t\t\t session->header.data_size,\n\t\t\t\t\t\t cs_etm__queue_aux_records_cb, NULL);\n\n\t \n\treturn 0;\n}\n\n#define HAS_PARAM(j, type, param) (metadata[(j)][CS_ETM_NR_TRC_PARAMS] <= \\\n\t\t\t\t  (CS_##type##_##param - CS_ETM_COMMON_BLK_MAX_V1))\n\n \nstatic bool cs_etm__has_virtual_ts(u64 **metadata, int num_cpu)\n{\n\tint j;\n\n\tfor (j = 0; j < num_cpu; j++) {\n\t\tswitch (metadata[j][CS_ETM_MAGIC]) {\n\t\tcase __perf_cs_etmv4_magic:\n\t\t\tif (HAS_PARAM(j, ETMV4, TS_SOURCE) || metadata[j][CS_ETMV4_TS_SOURCE] != 1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase __perf_cs_ete_magic:\n\t\t\tif (HAS_PARAM(j, ETE, TS_SOURCE) || metadata[j][CS_ETE_TS_SOURCE] != 1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n \nstatic int cs_etm__map_trace_ids_metadata(int num_cpu, u64 **metadata)\n{\n\tu64 cs_etm_magic;\n\tu8 trace_chan_id;\n\tint i, err;\n\n\tfor (i = 0; i < num_cpu; i++) {\n\t\tcs_etm_magic = metadata[i][CS_ETM_MAGIC];\n\t\tswitch (cs_etm_magic) {\n\t\tcase __perf_cs_etmv3_magic:\n\t\t\tmetadata[i][CS_ETM_ETMTRACEIDR] &= CORESIGHT_TRACE_ID_VAL_MASK;\n\t\t\ttrace_chan_id = (u8)(metadata[i][CS_ETM_ETMTRACEIDR]);\n\t\t\tbreak;\n\t\tcase __perf_cs_etmv4_magic:\n\t\tcase __perf_cs_ete_magic:\n\t\t\tmetadata[i][CS_ETMV4_TRCTRACEIDR] &= CORESIGHT_TRACE_ID_VAL_MASK;\n\t\t\ttrace_chan_id = (u8)(metadata[i][CS_ETMV4_TRCTRACEIDR]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = cs_etm__map_trace_id(trace_chan_id, metadata[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int cs_etm__clear_unused_trace_ids_metadata(int num_cpu, u64 **metadata)\n{\n\tu64 cs_etm_magic;\n\tint i;\n\n\tfor (i = 0; i < num_cpu; i++) {\n\t\tcs_etm_magic = metadata[i][CS_ETM_MAGIC];\n\t\tswitch (cs_etm_magic) {\n\t\tcase __perf_cs_etmv3_magic:\n\t\t\tif (metadata[i][CS_ETM_ETMTRACEIDR] & CORESIGHT_TRACE_ID_UNUSED_FLAG)\n\t\t\t\tmetadata[i][CS_ETM_ETMTRACEIDR] = CORESIGHT_TRACE_ID_UNUSED_VAL;\n\t\t\tbreak;\n\t\tcase __perf_cs_etmv4_magic:\n\t\tcase __perf_cs_ete_magic:\n\t\t\tif (metadata[i][CS_ETMV4_TRCTRACEIDR] & CORESIGHT_TRACE_ID_UNUSED_FLAG)\n\t\t\t\tmetadata[i][CS_ETMV4_TRCTRACEIDR] = CORESIGHT_TRACE_ID_UNUSED_VAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint cs_etm__process_auxtrace_info_full(union perf_event *event,\n\t\t\t\t       struct perf_session *session)\n{\n\tstruct perf_record_auxtrace_info *auxtrace_info = &event->auxtrace_info;\n\tstruct cs_etm_auxtrace *etm = NULL;\n\tstruct perf_record_time_conv *tc = &session->time_conv;\n\tint event_header_size = sizeof(struct perf_event_header);\n\tint total_size = auxtrace_info->header.size;\n\tint priv_size = 0;\n\tint num_cpu;\n\tint err = 0;\n\tint aux_hw_id_found;\n\tint i, j;\n\tu64 *ptr = NULL;\n\tu64 **metadata = NULL;\n\n\t \n\ttraceid_list = intlist__new(NULL);\n\tif (!traceid_list)\n\t\treturn -ENOMEM;\n\n\t \n\tptr = (u64 *) auxtrace_info->priv;\n\tnum_cpu = ptr[CS_PMU_TYPE_CPUS] & 0xffffffff;\n\tmetadata = zalloc(sizeof(*metadata) * num_cpu);\n\tif (!metadata) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_traceid_list;\n\t}\n\n\t \n\ti = CS_HEADER_VERSION_MAX;\n\n\t \n\tfor (j = 0; j < num_cpu; j++) {\n\t\tif (ptr[i] == __perf_cs_etmv3_magic) {\n\t\t\tmetadata[j] =\n\t\t\t\tcs_etm__create_meta_blk(ptr, &i,\n\t\t\t\t\t\t\tCS_ETM_PRIV_MAX,\n\t\t\t\t\t\t\tCS_ETM_NR_TRC_PARAMS_V0);\n\t\t} else if (ptr[i] == __perf_cs_etmv4_magic) {\n\t\t\tmetadata[j] =\n\t\t\t\tcs_etm__create_meta_blk(ptr, &i,\n\t\t\t\t\t\t\tCS_ETMV4_PRIV_MAX,\n\t\t\t\t\t\t\tCS_ETMV4_NR_TRC_PARAMS_V0);\n\t\t} else if (ptr[i] == __perf_cs_ete_magic) {\n\t\t\tmetadata[j] = cs_etm__create_meta_blk(ptr, &i, CS_ETE_PRIV_MAX, -1);\n\t\t} else {\n\t\t\tui__error(\"CS ETM Trace: Unrecognised magic number %#\"PRIx64\". File could be from a newer version of perf.\\n\",\n\t\t\t\t  ptr[i]);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free_metadata;\n\t\t}\n\n\t\tif (!metadata[j]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_metadata;\n\t\t}\n\t}\n\n\t \n\tpriv_size = total_size - event_header_size - INFO_HEADER_SIZE;\n\tif (i * 8 != priv_size) {\n\t\terr = -EINVAL;\n\t\tgoto err_free_metadata;\n\t}\n\n\tetm = zalloc(sizeof(*etm));\n\n\tif (!etm) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_metadata;\n\t}\n\n\t \n\tetm->pid_fmt = cs_etm__init_pid_fmt(metadata[0]);\n\n\terr = auxtrace_queues__init(&etm->queues);\n\tif (err)\n\t\tgoto err_free_etm;\n\n\tif (session->itrace_synth_opts->set) {\n\t\tetm->synth_opts = *session->itrace_synth_opts;\n\t} else {\n\t\titrace_synth_opts__set_default(&etm->synth_opts,\n\t\t\t\tsession->itrace_synth_opts->default_no_sample);\n\t\tetm->synth_opts.callchain = false;\n\t}\n\n\tetm->session = session;\n\n\tetm->num_cpu = num_cpu;\n\tetm->pmu_type = (unsigned int) ((ptr[CS_PMU_TYPE_CPUS] >> 32) & 0xffffffff);\n\tetm->snapshot_mode = (ptr[CS_ETM_SNAPSHOT] != 0);\n\tetm->metadata = metadata;\n\tetm->auxtrace_type = auxtrace_info->type;\n\n\t \n\tetm->has_virtual_ts = cs_etm__has_virtual_ts(metadata, num_cpu);\n\n\tif (!etm->has_virtual_ts)\n\t\tui__warning(\"Virtual timestamps are not enabled, or not supported by the traced system.\\n\"\n\t\t\t    \"The time field of the samples will not be set accurately.\\n\\n\");\n\n\tetm->auxtrace.process_event = cs_etm__process_event;\n\tetm->auxtrace.process_auxtrace_event = cs_etm__process_auxtrace_event;\n\tetm->auxtrace.flush_events = cs_etm__flush_events;\n\tetm->auxtrace.free_events = cs_etm__free_events;\n\tetm->auxtrace.free = cs_etm__free;\n\tetm->auxtrace.evsel_is_auxtrace = cs_etm__evsel_is_auxtrace;\n\tsession->auxtrace = &etm->auxtrace;\n\n\terr = cs_etm__setup_timeless_decoding(etm);\n\tif (err)\n\t\treturn err;\n\n\tetm->tc.time_shift = tc->time_shift;\n\tetm->tc.time_mult = tc->time_mult;\n\tetm->tc.time_zero = tc->time_zero;\n\tif (event_contains(*tc, time_cycles)) {\n\t\tetm->tc.time_cycles = tc->time_cycles;\n\t\tetm->tc.time_mask = tc->time_mask;\n\t\tetm->tc.cap_user_time_zero = tc->cap_user_time_zero;\n\t\tetm->tc.cap_user_time_short = tc->cap_user_time_short;\n\t}\n\terr = cs_etm__synth_events(etm, session);\n\tif (err)\n\t\tgoto err_free_queues;\n\n\t \n\n\t \n\taux_hw_id_found = 0;\n\terr = perf_session__peek_events(session, session->header.data_offset,\n\t\t\t\t\tsession->header.data_size,\n\t\t\t\t\tcs_etm__process_aux_hw_id_cb, &aux_hw_id_found);\n\tif (err)\n\t\tgoto err_free_queues;\n\n\t \n\tif (aux_hw_id_found)\n\t\terr = cs_etm__clear_unused_trace_ids_metadata(num_cpu, metadata);\n\t \n\telse\n\t\terr = cs_etm__map_trace_ids_metadata(num_cpu, metadata);\n\n\tif (err)\n\t\tgoto err_free_queues;\n\n\terr = cs_etm__queue_aux_records(session);\n\tif (err)\n\t\tgoto err_free_queues;\n\n\tetm->data_queued = etm->queues.populated;\n\treturn 0;\n\nerr_free_queues:\n\tauxtrace_queues__free(&etm->queues);\n\tsession->auxtrace = NULL;\nerr_free_etm:\n\tzfree(&etm);\nerr_free_metadata:\n\t \n\tfor (j = 0; j < num_cpu; j++)\n\t\tzfree(&metadata[j]);\n\tzfree(&metadata);\nerr_free_traceid_list:\n\tintlist__delete(traceid_list);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}