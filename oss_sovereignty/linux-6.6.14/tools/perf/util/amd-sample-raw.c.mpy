{
  "module_name": "amd-sample-raw.c",
  "hash_id": "9d3031104a1d5e53a097f4a93bb7ca9b24257c1590485788148b9a48c7dc1435",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/amd-sample-raw.c",
  "human_readable_source": "\n \n\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <inttypes.h>\n\n#include <linux/string.h>\n#include \"../../arch/x86/include/asm/amd-ibs.h\"\n\n#include \"debug.h\"\n#include \"session.h\"\n#include \"evlist.h\"\n#include \"sample-raw.h\"\n#include \"util/sample.h\"\n\nstatic u32 cpu_family, cpu_model, ibs_fetch_type, ibs_op_type;\nstatic bool zen4_ibs_extensions;\n\nstatic void pr_ibs_fetch_ctl(union ibs_fetch_ctl reg)\n{\n\tconst char * const ic_miss_strs[] = {\n\t\t\" IcMiss 0\",\n\t\t\" IcMiss 1\",\n\t};\n\tconst char * const l1tlb_pgsz_strs[] = {\n\t\t\" L1TlbPgSz 4KB\",\n\t\t\" L1TlbPgSz 2MB\",\n\t\t\" L1TlbPgSz 1GB\",\n\t\t\" L1TlbPgSz RESERVED\"\n\t};\n\tconst char * const l1tlb_pgsz_strs_erratum1347[] = {\n\t\t\" L1TlbPgSz 4KB\",\n\t\t\" L1TlbPgSz 16KB\",\n\t\t\" L1TlbPgSz 2MB\",\n\t\t\" L1TlbPgSz 1GB\"\n\t};\n\tconst char *ic_miss_str = NULL;\n\tconst char *l1tlb_pgsz_str = NULL;\n\tchar l3_miss_str[sizeof(\" L3MissOnly _ FetchOcMiss _ FetchL3Miss _\")] = \"\";\n\n\tif (cpu_family == 0x19 && cpu_model < 0x10) {\n\t\t \n\t\tif (reg.phy_addr_valid)\n\t\t\tl1tlb_pgsz_str = l1tlb_pgsz_strs_erratum1347[reg.l1tlb_pgsz];\n\t} else {\n\t\tif (reg.phy_addr_valid)\n\t\t\tl1tlb_pgsz_str = l1tlb_pgsz_strs[reg.l1tlb_pgsz];\n\t\tic_miss_str = ic_miss_strs[reg.ic_miss];\n\t}\n\n\tif (zen4_ibs_extensions) {\n\t\tsnprintf(l3_miss_str, sizeof(l3_miss_str),\n\t\t\t \" L3MissOnly %d FetchOcMiss %d FetchL3Miss %d\",\n\t\t\t reg.l3_miss_only, reg.fetch_oc_miss, reg.fetch_l3_miss);\n\t}\n\n\tprintf(\"ibs_fetch_ctl:\\t%016llx MaxCnt %7d Cnt %7d Lat %5d En %d Val %d Comp %d%s \"\n\t\t\"PhyAddrValid %d%s L1TlbMiss %d L2TlbMiss %d RandEn %d%s%s\\n\",\n\t\treg.val, reg.fetch_maxcnt << 4, reg.fetch_cnt << 4, reg.fetch_lat,\n\t\treg.fetch_en, reg.fetch_val, reg.fetch_comp, ic_miss_str ? : \"\",\n\t\treg.phy_addr_valid, l1tlb_pgsz_str ? : \"\", reg.l1tlb_miss, reg.l2tlb_miss,\n\t\treg.rand_en, reg.fetch_comp ? (reg.fetch_l2_miss ? \" L2Miss 1\" : \" L2Miss 0\") : \"\",\n\t\tl3_miss_str);\n}\n\nstatic void pr_ic_ibs_extd_ctl(union ic_ibs_extd_ctl reg)\n{\n\tprintf(\"ic_ibs_ext_ctl:\\t%016llx IbsItlbRefillLat %3d\\n\", reg.val, reg.itlb_refill_lat);\n}\n\nstatic void pr_ibs_op_ctl(union ibs_op_ctl reg)\n{\n\tchar l3_miss_only[sizeof(\" L3MissOnly _\")] = \"\";\n\n\tif (zen4_ibs_extensions)\n\t\tsnprintf(l3_miss_only, sizeof(l3_miss_only), \" L3MissOnly %d\", reg.l3_miss_only);\n\n\tprintf(\"ibs_op_ctl:\\t%016llx MaxCnt %9d%s En %d Val %d CntCtl %d=%s CurCnt %9d\\n\",\n\t\treg.val, ((reg.opmaxcnt_ext << 16) | reg.opmaxcnt) << 4, l3_miss_only,\n\t\treg.op_en, reg.op_val, reg.cnt_ctl,\n\t\treg.cnt_ctl ? \"uOps\" : \"cycles\", reg.opcurcnt);\n}\n\nstatic void pr_ibs_op_data(union ibs_op_data reg)\n{\n\tprintf(\"ibs_op_data:\\t%016llx CompToRetCtr %5d TagToRetCtr %5d%s%s%s BrnRet %d \"\n\t\t\" RipInvalid %d BrnFuse %d Microcode %d\\n\",\n\t\treg.val, reg.comp_to_ret_ctr, reg.tag_to_ret_ctr,\n\t\treg.op_brn_ret ? (reg.op_return ? \" OpReturn 1\" : \" OpReturn 0\") : \"\",\n\t\treg.op_brn_ret ? (reg.op_brn_taken ? \" OpBrnTaken 1\" : \" OpBrnTaken 0\") : \"\",\n\t\treg.op_brn_ret ? (reg.op_brn_misp ? \" OpBrnMisp 1\" : \" OpBrnMisp 0\") : \"\",\n\t\treg.op_brn_ret, reg.op_rip_invalid, reg.op_brn_fuse, reg.op_microcode);\n}\n\nstatic void pr_ibs_op_data2_extended(union ibs_op_data2 reg)\n{\n\tstatic const char * const data_src_str[] = {\n\t\t\"\",\n\t\t\" DataSrc 1=Local L3 or other L1/L2 in CCX\",\n\t\t\" DataSrc 2=Another CCX cache in the same NUMA node\",\n\t\t\" DataSrc 3=DRAM\",\n\t\t\" DataSrc 4=(reserved)\",\n\t\t\" DataSrc 5=Another CCX cache in a different NUMA node\",\n\t\t\" DataSrc 6=Long-latency DIMM\",\n\t\t\" DataSrc 7=MMIO/Config/PCI/APIC\",\n\t\t\" DataSrc 8=Extension Memory\",\n\t\t\" DataSrc 9=(reserved)\",\n\t\t\" DataSrc 10=(reserved)\",\n\t\t\" DataSrc 11=(reserved)\",\n\t\t\" DataSrc 12=Coherent Memory of a different processor type\",\n\t\t \n\t};\n\tint data_src = (reg.data_src_hi << 3) | reg.data_src_lo;\n\n\tprintf(\"ibs_op_data2:\\t%016llx %sRmtNode %d%s\\n\", reg.val,\n\t\t(data_src == 1 || data_src == 2 || data_src == 5) ?\n\t\t\t(reg.cache_hit_st ? \"CacheHitSt 1=O-State \" : \"CacheHitSt 0=M-state \") : \"\",\n\t\treg.rmt_node,\n\t\tdata_src < (int)ARRAY_SIZE(data_src_str) ? data_src_str[data_src] : \"\");\n}\n\nstatic void pr_ibs_op_data2_default(union ibs_op_data2 reg)\n{\n\tstatic const char * const data_src_str[] = {\n\t\t\"\",\n\t\t\" DataSrc 1=(reserved)\",\n\t\t\" DataSrc 2=Local node cache\",\n\t\t\" DataSrc 3=DRAM\",\n\t\t\" DataSrc 4=Remote node cache\",\n\t\t\" DataSrc 5=(reserved)\",\n\t\t\" DataSrc 6=(reserved)\",\n\t\t\" DataSrc 7=Other\"\n\t};\n\n\tprintf(\"ibs_op_data2:\\t%016llx %sRmtNode %d%s\\n\", reg.val,\n\t       reg.data_src_lo == 2 ? (reg.cache_hit_st ? \"CacheHitSt 1=O-State \"\n\t\t\t\t\t\t     : \"CacheHitSt 0=M-state \") : \"\",\n\t       reg.rmt_node, data_src_str[reg.data_src_lo]);\n}\n\nstatic void pr_ibs_op_data2(union ibs_op_data2 reg)\n{\n\tif (zen4_ibs_extensions)\n\t\treturn pr_ibs_op_data2_extended(reg);\n\tpr_ibs_op_data2_default(reg);\n}\n\nstatic void pr_ibs_op_data3(union ibs_op_data3 reg)\n{\n\tchar l2_miss_str[sizeof(\" L2Miss _\")] = \"\";\n\tchar op_mem_width_str[sizeof(\" OpMemWidth _____ bytes\")] = \"\";\n\tchar op_dc_miss_open_mem_reqs_str[sizeof(\" OpDcMissOpenMemReqs __\")] = \"\";\n\n\t \n\tif (!(cpu_family == 0x19 && cpu_model < 0x10 && (reg.dc_miss_no_mab_alloc || reg.sw_pf))) {\n\t\tsnprintf(l2_miss_str, sizeof(l2_miss_str), \" L2Miss %d\", reg.l2_miss);\n\t\tsnprintf(op_dc_miss_open_mem_reqs_str, sizeof(op_dc_miss_open_mem_reqs_str),\n\t\t\t \" OpDcMissOpenMemReqs %2d\", reg.op_dc_miss_open_mem_reqs);\n\t}\n\n\tif (reg.op_mem_width)\n\t\tsnprintf(op_mem_width_str, sizeof(op_mem_width_str),\n\t\t\t \" OpMemWidth %2d bytes\", 1 << (reg.op_mem_width - 1));\n\n\tprintf(\"ibs_op_data3:\\t%016llx LdOp %d StOp %d DcL1TlbMiss %d DcL2TlbMiss %d \"\n\t\t\"DcL1TlbHit2M %d DcL1TlbHit1G %d DcL2TlbHit2M %d DcMiss %d DcMisAcc %d \"\n\t\t\"DcWcMemAcc %d DcUcMemAcc %d DcLockedOp %d DcMissNoMabAlloc %d DcLinAddrValid %d \"\n\t\t\"DcPhyAddrValid %d DcL2TlbHit1G %d%s SwPf %d%s%s DcMissLat %5d TlbRefillLat %5d\\n\",\n\t\treg.val, reg.ld_op, reg.st_op, reg.dc_l1tlb_miss, reg.dc_l2tlb_miss,\n\t\treg.dc_l1tlb_hit_2m, reg.dc_l1tlb_hit_1g, reg.dc_l2tlb_hit_2m, reg.dc_miss,\n\t\treg.dc_mis_acc, reg.dc_wc_mem_acc, reg.dc_uc_mem_acc, reg.dc_locked_op,\n\t\treg.dc_miss_no_mab_alloc, reg.dc_lin_addr_valid, reg.dc_phy_addr_valid,\n\t\treg.dc_l2_tlb_hit_1g, l2_miss_str, reg.sw_pf, op_mem_width_str,\n\t\top_dc_miss_open_mem_reqs_str, reg.dc_miss_lat, reg.tlb_refill_lat);\n}\n\n \nstatic void amd_dump_ibs_op(struct perf_sample *sample)\n{\n\tstruct perf_ibs_data *data = sample->raw_data;\n\tunion ibs_op_ctl *op_ctl = (union ibs_op_ctl *)data->data;\n\t__u64 *rip = (__u64 *)op_ctl + 1;\n\tunion ibs_op_data *op_data = (union ibs_op_data *)(rip + 1);\n\tunion ibs_op_data3 *op_data3 = (union ibs_op_data3 *)(rip + 3);\n\n\tpr_ibs_op_ctl(*op_ctl);\n\tif (!op_data->op_rip_invalid)\n\t\tprintf(\"IbsOpRip:\\t%016llx\\n\", *rip);\n\tpr_ibs_op_data(*op_data);\n\t \n\tif (!(cpu_family == 0x19 && cpu_model < 0x10 &&\n\t      (op_data3->dc_miss_no_mab_alloc || op_data3->sw_pf)))\n\t\tpr_ibs_op_data2(*(union ibs_op_data2 *)(rip + 2));\n\tpr_ibs_op_data3(*op_data3);\n\tif (op_data3->dc_lin_addr_valid)\n\t\tprintf(\"IbsDCLinAd:\\t%016llx\\n\", *(rip + 4));\n\tif (op_data3->dc_phy_addr_valid)\n\t\tprintf(\"IbsDCPhysAd:\\t%016llx\\n\", *(rip + 5));\n\tif (op_data->op_brn_ret && *(rip + 6))\n\t\tprintf(\"IbsBrTarget:\\t%016llx\\n\", *(rip + 6));\n}\n\n \nstatic void amd_dump_ibs_fetch(struct perf_sample *sample)\n{\n\tstruct perf_ibs_data *data = sample->raw_data;\n\tunion ibs_fetch_ctl *fetch_ctl = (union ibs_fetch_ctl *)data->data;\n\t__u64 *addr = (__u64 *)fetch_ctl + 1;\n\tunion ic_ibs_extd_ctl *extd_ctl = (union ic_ibs_extd_ctl *)addr + 2;\n\n\tpr_ibs_fetch_ctl(*fetch_ctl);\n\tprintf(\"IbsFetchLinAd:\\t%016llx\\n\", *addr++);\n\tif (fetch_ctl->phy_addr_valid)\n\t\tprintf(\"IbsFetchPhysAd:\\t%016llx\\n\", *addr);\n\tpr_ic_ibs_extd_ctl(*extd_ctl);\n}\n\n \nstatic bool is_valid_ibs_fetch_sample(struct perf_sample *sample)\n{\n\tstruct perf_ibs_data *data = sample->raw_data;\n\tunion ibs_fetch_ctl *fetch_ctl = (union ibs_fetch_ctl *)data->data;\n\n\tif (fetch_ctl->fetch_en && fetch_ctl->fetch_val)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool is_valid_ibs_op_sample(struct perf_sample *sample)\n{\n\tstruct perf_ibs_data *data = sample->raw_data;\n\tunion ibs_op_ctl *op_ctl = (union ibs_op_ctl *)data->data;\n\n\tif (op_ctl->op_en && op_ctl->op_val)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nvoid evlist__amd_sample_raw(struct evlist *evlist, union perf_event *event,\n\t\t\t    struct perf_sample *sample)\n{\n\tstruct evsel *evsel;\n\n\tif (event->header.type != PERF_RECORD_SAMPLE || !sample->raw_size)\n\t\treturn;\n\n\tevsel = evlist__event2evsel(evlist, event);\n\tif (!evsel)\n\t\treturn;\n\n\tif (evsel->core.attr.type == ibs_fetch_type) {\n\t\tif (!is_valid_ibs_fetch_sample(sample)) {\n\t\t\tpr_debug(\"Invalid raw IBS Fetch MSR data encountered\\n\");\n\t\t\treturn;\n\t\t}\n\t\tamd_dump_ibs_fetch(sample);\n\t} else if (evsel->core.attr.type == ibs_op_type) {\n\t\tif (!is_valid_ibs_op_sample(sample)) {\n\t\t\tpr_debug(\"Invalid raw IBS Op MSR data encountered\\n\");\n\t\t\treturn;\n\t\t}\n\t\tamd_dump_ibs_op(sample);\n\t}\n}\n\nstatic void parse_cpuid(struct perf_env *env)\n{\n\tconst char *cpuid;\n\tint ret;\n\n\tcpuid = perf_env__cpuid(env);\n\t \n\tret = sscanf(cpuid, \"%*[^,],%u,%u\", &cpu_family, &cpu_model);\n\tif (ret != 2)\n\t\tpr_debug(\"problem parsing cpuid\\n\");\n}\n\n \nbool evlist__has_amd_ibs(struct evlist *evlist)\n{\n\tstruct perf_env *env = evlist->env;\n\tint ret, nr_pmu_mappings = perf_env__nr_pmu_mappings(env);\n\tconst char *pmu_mapping = perf_env__pmu_mappings(env);\n\tchar name[sizeof(\"ibs_fetch\")];\n\tu32 type;\n\n\twhile (nr_pmu_mappings--) {\n\t\tret = sscanf(pmu_mapping, \"%u:%9s\", &type, name);\n\t\tif (ret == 2) {\n\t\t\tif (strstarts(name, \"ibs_op\"))\n\t\t\t\tibs_op_type = type;\n\t\t\telse if (strstarts(name, \"ibs_fetch\"))\n\t\t\t\tibs_fetch_type = type;\n\t\t}\n\t\tpmu_mapping += strlen(pmu_mapping) + 1  ;\n\t}\n\n\tif (perf_env__find_pmu_cap(env, \"ibs_op\", \"zen4_ibs_extensions\"))\n\t\tzen4_ibs_extensions = 1;\n\n\tif (ibs_fetch_type || ibs_op_type) {\n\t\tif (!cpu_family)\n\t\t\tparse_cpuid(env);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}