{
  "module_name": "stat.h",
  "hash_id": "2539f96217aa474c4352037f4ffd25f386f53756ea51d4277e93e923c472aed2",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/stat.h",
  "human_readable_source": " \n#ifndef __PERF_STATS_H\n#define __PERF_STATS_H\n\n#include <linux/types.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include \"cpumap.h\"\n#include \"rblist.h\"\n#include \"counts.h\"\n\nstruct perf_cpu_map;\nstruct perf_stat_config;\nstruct timespec;\n\nstruct stats {\n\tdouble n, mean, M2;\n\tu64 max, min;\n};\n\n \nstruct perf_stat_aggr {\n\t \n\tstruct perf_counts_values\tcounts;\n\t \n\tint\t\t\t\tnr;\n\t \n\tbool\t\t\t\tfailed;\n\t \n\tbool\t\t\t\tused;\n};\n\n \nstruct perf_stat_evsel {\n\t \n\tstruct stats\t\t res_stats;\n\t \n\tint\t\t\t nr_aggr;\n\t \n\tstruct perf_stat_aggr\t*aggr;\n\t \n\tu64\t\t\t*group_data;\n};\n\nenum aggr_mode {\n\tAGGR_NONE,\n\tAGGR_GLOBAL,\n\tAGGR_SOCKET,\n\tAGGR_DIE,\n\tAGGR_CACHE,\n\tAGGR_CORE,\n\tAGGR_THREAD,\n\tAGGR_UNSET,\n\tAGGR_NODE,\n\tAGGR_MAX\n};\n\nstruct rusage_stats {\n\tstruct stats ru_utime_usec_stat;\n\tstruct stats ru_stime_usec_stat;\n};\n\ntypedef struct aggr_cpu_id (*aggr_get_id_t)(struct perf_stat_config *config, struct perf_cpu cpu);\n\nstruct perf_stat_config {\n\tenum aggr_mode\t\t aggr_mode;\n\tu32\t\t\t aggr_level;\n\tbool\t\t\t scale;\n\tbool\t\t\t no_inherit;\n\tbool\t\t\t identifier;\n\tbool\t\t\t csv_output;\n\tbool\t\t\t json_output;\n\tbool\t\t\t interval_clear;\n\tbool\t\t\t metric_only;\n\tbool\t\t\t null_run;\n\tbool\t\t\t ru_display;\n\tbool\t\t\t big_num;\n\tbool\t\t\t no_merge;\n\tbool\t\t\t hybrid_merge;\n\tbool\t\t\t walltime_run_table;\n\tbool\t\t\t all_kernel;\n\tbool\t\t\t all_user;\n\tbool\t\t\t percore_show_thread;\n\tbool\t\t\t summary;\n\tbool\t\t\t no_csv_summary;\n\tbool\t\t\t metric_no_group;\n\tbool\t\t\t metric_no_merge;\n\tbool\t\t\t metric_no_threshold;\n\tbool\t\t\t stop_read_counter;\n\tbool\t\t\t iostat_run;\n\tchar\t\t\t *user_requested_cpu_list;\n\tbool\t\t\t system_wide;\n\tFILE\t\t\t*output;\n\tunsigned int\t\t interval;\n\tunsigned int\t\t timeout;\n\tunsigned int\t\t unit_width;\n\tunsigned int\t\t metric_only_len;\n\tint\t\t\t times;\n\tint\t\t\t run_count;\n\tint\t\t\t print_free_counters_hint;\n\tint\t\t\t print_mixed_hw_group_error;\n\tconst char\t\t*csv_sep;\n\tstruct stats\t\t*walltime_nsecs_stats;\n\tstruct rusage\t\t ru_data;\n\tstruct rusage_stats\t\t *ru_stats;\n\tstruct cpu_aggr_map\t*aggr_map;\n\taggr_get_id_t\t\t aggr_get_id;\n\tstruct cpu_aggr_map\t*cpus_aggr_map;\n\tu64\t\t\t*walltime_run;\n\tstruct rblist\t\t metric_events;\n\tint\t\t\t ctl_fd;\n\tint\t\t\t ctl_fd_ack;\n\tbool\t\t\t ctl_fd_close;\n\tconst char\t\t*cgroup_list;\n\tunsigned int\t\ttopdown_level;\n};\n\nvoid perf_stat__set_big_num(int set);\nvoid perf_stat__set_no_csv_summary(int set);\n\nvoid update_stats(struct stats *stats, u64 val);\ndouble avg_stats(struct stats *stats);\ndouble stddev_stats(struct stats *stats);\ndouble rel_stddev_stats(double stddev, double avg);\n\nstatic inline void init_stats(struct stats *stats)\n{\n\tstats->n    = 0.0;\n\tstats->mean = 0.0;\n\tstats->M2   = 0.0;\n\tstats->min  = (u64) -1;\n\tstats->max  = 0;\n}\n\nstatic inline void init_rusage_stats(struct rusage_stats *ru_stats) {\n\tinit_stats(&ru_stats->ru_utime_usec_stat);\n\tinit_stats(&ru_stats->ru_stime_usec_stat);\n}\n\nstatic inline void update_rusage_stats(struct rusage_stats *ru_stats, struct rusage* rusage) {\n\tconst u64 us_to_ns = 1000;\n\tconst u64 s_to_ns = 1000000000;\n\tupdate_stats(&ru_stats->ru_utime_usec_stat,\n\t             (rusage->ru_utime.tv_usec * us_to_ns + rusage->ru_utime.tv_sec * s_to_ns));\n\tupdate_stats(&ru_stats->ru_stime_usec_stat,\n\t             (rusage->ru_stime.tv_usec * us_to_ns + rusage->ru_stime.tv_sec * s_to_ns));\n}\n\nstruct evsel;\nstruct evlist;\n\nextern struct stats walltime_nsecs_stats;\nextern struct rusage_stats ru_stats;\n\ntypedef void (*print_metric_t)(struct perf_stat_config *config,\n\t\t\t       void *ctx, const char *color, const char *unit,\n\t\t\t       const char *fmt, double val);\ntypedef void (*new_line_t)(struct perf_stat_config *config, void *ctx);\n\n \ntypedef void (*print_metricgroup_header_t)(struct perf_stat_config *config,\n\t\t\t\t\t   void *ctx, const char *metricgroup_name);\n\nvoid perf_stat__reset_shadow_stats(void);\nstruct perf_stat_output_ctx {\n\tvoid *ctx;\n\tprint_metric_t print_metric;\n\tnew_line_t new_line;\n\tprint_metricgroup_header_t print_metricgroup_header;\n\tbool force_header;\n};\n\nvoid perf_stat__print_shadow_stats(struct perf_stat_config *config,\n\t\t\t\t   struct evsel *evsel,\n\t\t\t\t   double avg, int aggr_idx,\n\t\t\t\t   struct perf_stat_output_ctx *out,\n\t\t\t\t   struct rblist *metric_events);\nbool perf_stat__skip_metric_event(struct evsel *evsel,\n\t\t\t\t  struct rblist *metric_events,\n\t\t\t\t  u64 ena, u64 run);\nvoid *perf_stat__print_shadow_stats_metricgroup(struct perf_stat_config *config,\n\t\t\t\t\t\tstruct evsel *evsel,\n\t\t\t\t\t\tint aggr_idx,\n\t\t\t\t\t\tint *num,\n\t\t\t\t\t\tvoid *from,\n\t\t\t\t\t\tstruct perf_stat_output_ctx *out,\n\t\t\t\t\t\tstruct rblist *metric_events);\n\nint evlist__alloc_stats(struct perf_stat_config *config,\n\t\t\tstruct evlist *evlist, bool alloc_raw);\nvoid evlist__free_stats(struct evlist *evlist);\nvoid evlist__reset_stats(struct evlist *evlist);\nvoid evlist__reset_prev_raw_counts(struct evlist *evlist);\nvoid evlist__copy_prev_raw_counts(struct evlist *evlist);\nvoid evlist__save_aggr_prev_raw_counts(struct evlist *evlist);\n\nint evlist__alloc_aggr_stats(struct evlist *evlist, int nr_aggr);\nvoid evlist__reset_aggr_stats(struct evlist *evlist);\nvoid evlist__copy_res_stats(struct perf_stat_config *config, struct evlist *evlist);\n\nint perf_stat_process_counter(struct perf_stat_config *config,\n\t\t\t      struct evsel *counter);\nvoid perf_stat_merge_counters(struct perf_stat_config *config, struct evlist *evlist);\nvoid perf_stat_process_percore(struct perf_stat_config *config, struct evlist *evlist);\n\nstruct perf_tool;\nunion perf_event;\nstruct perf_session;\nstruct target;\n\nint perf_event__process_stat_event(struct perf_session *session,\n\t\t\t\t   union perf_event *event);\n\nsize_t perf_event__fprintf_stat(union perf_event *event, FILE *fp);\nsize_t perf_event__fprintf_stat_round(union perf_event *event, FILE *fp);\nsize_t perf_event__fprintf_stat_config(union perf_event *event, FILE *fp);\n\nint create_perf_stat_counter(struct evsel *evsel,\n\t\t\t     struct perf_stat_config *config,\n\t\t\t     struct target *target,\n\t\t\t     int cpu_map_idx);\nvoid evlist__print_counters(struct evlist *evlist, struct perf_stat_config *config,\n\t\t\t    struct target *_target, struct timespec *ts, int argc, const char **argv);\n\nstruct metric_expr;\ndouble test_generic_metric(struct metric_expr *mexp, int aggr_idx);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}