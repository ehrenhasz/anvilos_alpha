{
  "module_name": "unwind-libunwind.c",
  "hash_id": "0b8425c6ddf474e13adde718dbf1b6d3150a96a255ef1eeda18a7cd90210c7bc",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/unwind-libunwind.c",
  "human_readable_source": "\n#include \"unwind.h\"\n#include \"dso.h\"\n#include \"map.h\"\n#include \"thread.h\"\n#include \"session.h\"\n#include \"debug.h\"\n#include \"env.h\"\n#include \"callchain.h\"\n\nstruct unwind_libunwind_ops __weak *local_unwind_libunwind_ops;\nstruct unwind_libunwind_ops __weak *x86_32_unwind_libunwind_ops;\nstruct unwind_libunwind_ops __weak *arm64_unwind_libunwind_ops;\n\nstatic void unwind__register_ops(struct maps *maps, struct unwind_libunwind_ops *ops)\n{\n\tRC_CHK_ACCESS(maps)->unwind_libunwind_ops = ops;\n}\n\nint unwind__prepare_access(struct maps *maps, struct map *map, bool *initialized)\n{\n\tconst char *arch;\n\tenum dso_type dso_type;\n\tstruct unwind_libunwind_ops *ops = local_unwind_libunwind_ops;\n\tstruct dso *dso = map__dso(map);\n\tstruct machine *machine;\n\tint err;\n\n\tif (!dwarf_callchain_users)\n\t\treturn 0;\n\n\tif (maps__addr_space(maps)) {\n\t\tpr_debug(\"unwind: thread map already set, dso=%s\\n\", dso->name);\n\t\tif (initialized)\n\t\t\t*initialized = true;\n\t\treturn 0;\n\t}\n\n\tmachine = maps__machine(maps);\n\t \n\tif (!machine->env || !machine->env->arch)\n\t\tgoto out_register;\n\n\tdso_type = dso__type(dso, machine);\n\tif (dso_type == DSO__TYPE_UNKNOWN)\n\t\treturn 0;\n\n\tarch = perf_env__arch(machine->env);\n\n\tif (!strcmp(arch, \"x86\")) {\n\t\tif (dso_type != DSO__TYPE_64BIT)\n\t\t\tops = x86_32_unwind_libunwind_ops;\n\t} else if (!strcmp(arch, \"arm64\") || !strcmp(arch, \"arm\")) {\n\t\tif (dso_type == DSO__TYPE_64BIT)\n\t\t\tops = arm64_unwind_libunwind_ops;\n\t}\n\n\tif (!ops) {\n\t\tpr_warning_once(\"unwind: target platform=%s is not supported\\n\", arch);\n\t\treturn 0;\n\t}\nout_register:\n\tunwind__register_ops(maps, ops);\n\n\terr = maps__unwind_libunwind_ops(maps)->prepare_access(maps);\n\tif (initialized)\n\t\t*initialized = err ? false : true;\n\treturn err;\n}\n\nvoid unwind__flush_access(struct maps *maps)\n{\n\tconst struct unwind_libunwind_ops *ops = maps__unwind_libunwind_ops(maps);\n\n\tif (ops)\n\t\tops->flush_access(maps);\n}\n\nvoid unwind__finish_access(struct maps *maps)\n{\n\tconst struct unwind_libunwind_ops *ops = maps__unwind_libunwind_ops(maps);\n\n\tif (ops)\n\t\tops->finish_access(maps);\n}\n\nint unwind__get_entries(unwind_entry_cb_t cb, void *arg,\n\t\t\t struct thread *thread,\n\t\t\t struct perf_sample *data, int max_stack,\n\t\t\t bool best_effort)\n{\n\tconst struct unwind_libunwind_ops *ops = maps__unwind_libunwind_ops(thread__maps(thread));\n\n\tif (ops)\n\t\treturn ops->get_entries(cb, arg, thread, data, max_stack, best_effort);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}