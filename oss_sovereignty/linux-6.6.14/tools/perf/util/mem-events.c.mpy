{
  "module_name": "mem-events.c",
  "hash_id": "46f5acd62e903ce0218e245d58cafff0c5528e0975351755da876d05575a03c7",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/mem-events.c",
  "human_readable_source": "\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <api/fs/fs.h>\n#include <linux/kernel.h>\n#include \"map_symbol.h\"\n#include \"mem-events.h\"\n#include \"debug.h\"\n#include \"symbol.h\"\n#include \"pmu.h\"\n#include \"pmus.h\"\n\nunsigned int perf_mem_events__loads_ldlat = 30;\n\n#define E(t, n, s) { .tag = t, .name = n, .sysfs_name = s }\n\nstatic struct perf_mem_event perf_mem_events[PERF_MEM_EVENTS__MAX] = {\n\tE(\"ldlat-loads\",\t\"cpu/mem-loads,ldlat=%u/P\",\t\"cpu/events/mem-loads\"),\n\tE(\"ldlat-stores\",\t\"cpu/mem-stores/P\",\t\t\"cpu/events/mem-stores\"),\n\tE(NULL,\t\t\tNULL,\t\t\t\tNULL),\n};\n#undef E\n\nstatic char mem_loads_name[100];\nstatic bool mem_loads_name__init;\n\nstruct perf_mem_event * __weak perf_mem_events__ptr(int i)\n{\n\tif (i >= PERF_MEM_EVENTS__MAX)\n\t\treturn NULL;\n\n\treturn &perf_mem_events[i];\n}\n\nconst char * __weak perf_mem_events__name(int i, const char *pmu_name  __maybe_unused)\n{\n\tstruct perf_mem_event *e = perf_mem_events__ptr(i);\n\n\tif (!e)\n\t\treturn NULL;\n\n\tif (i == PERF_MEM_EVENTS__LOAD) {\n\t\tif (!mem_loads_name__init) {\n\t\t\tmem_loads_name__init = true;\n\t\t\tscnprintf(mem_loads_name, sizeof(mem_loads_name),\n\t\t\t\t  e->name, perf_mem_events__loads_ldlat);\n\t\t}\n\t\treturn mem_loads_name;\n\t}\n\n\treturn e->name;\n}\n\n__weak bool is_mem_loads_aux_event(struct evsel *leader __maybe_unused)\n{\n\treturn false;\n}\n\nint perf_mem_events__parse(const char *str)\n{\n\tchar *tok, *saveptr = NULL;\n\tbool found = false;\n\tchar *buf;\n\tint j;\n\n\t \n\tbuf = malloc(strlen(str) + 1);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tstrcpy(buf, str);\n\n\ttok = strtok_r((char *)buf, \",\", &saveptr);\n\n\twhile (tok) {\n\t\tfor (j = 0; j < PERF_MEM_EVENTS__MAX; j++) {\n\t\t\tstruct perf_mem_event *e = perf_mem_events__ptr(j);\n\n\t\t\tif (!e->tag)\n\t\t\t\tcontinue;\n\n\t\t\tif (strstr(e->tag, tok))\n\t\t\t\te->record = found = true;\n\t\t}\n\n\t\ttok = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(buf);\n\n\tif (found)\n\t\treturn 0;\n\n\tpr_err(\"failed: event '%s' not found, use '-e list' to get list of available events\\n\", str);\n\treturn -1;\n}\n\nstatic bool perf_mem_event__supported(const char *mnt, struct perf_pmu *pmu,\n\t\t\t\t      struct perf_mem_event *e)\n{\n\tchar sysfs_name[100];\n\tchar path[PATH_MAX];\n\tstruct stat st;\n\n\tscnprintf(sysfs_name, sizeof(sysfs_name), e->sysfs_name, pmu->name);\n\tscnprintf(path, PATH_MAX, \"%s/devices/%s\", mnt, sysfs_name);\n\treturn !stat(path, &st);\n}\n\nint perf_mem_events__init(void)\n{\n\tconst char *mnt = sysfs__mount();\n\tbool found = false;\n\tint j;\n\n\tif (!mnt)\n\t\treturn -ENOENT;\n\n\tfor (j = 0; j < PERF_MEM_EVENTS__MAX; j++) {\n\t\tstruct perf_mem_event *e = perf_mem_events__ptr(j);\n\t\tstruct perf_pmu *pmu = NULL;\n\n\t\t \n\t\tif (!e->tag)\n\t\t\tcontinue;\n\n\t\t \n\t\twhile ((pmu = perf_pmus__scan(pmu)) != NULL) {\n\t\t\te->supported |= perf_mem_event__supported(mnt, pmu, e);\n\t\t\tif (e->supported) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found ? 0 : -ENOENT;\n}\n\nvoid perf_mem_events__list(void)\n{\n\tint j;\n\n\tfor (j = 0; j < PERF_MEM_EVENTS__MAX; j++) {\n\t\tstruct perf_mem_event *e = perf_mem_events__ptr(j);\n\n\t\tfprintf(stderr, \"%-*s%-*s%s\",\n\t\t\te->tag ? 13 : 0,\n\t\t\te->tag ? : \"\",\n\t\t\te->tag && verbose > 0 ? 25 : 0,\n\t\t\te->tag && verbose > 0 ? perf_mem_events__name(j, NULL) : \"\",\n\t\t\te->supported ? \": available\\n\" : \"\");\n\t}\n}\n\nstatic void perf_mem_events__print_unsupport_hybrid(struct perf_mem_event *e,\n\t\t\t\t\t\t    int idx)\n{\n\tconst char *mnt = sysfs__mount();\n\tstruct perf_pmu *pmu = NULL;\n\n\twhile ((pmu = perf_pmus__scan(pmu)) != NULL) {\n\t\tif (!perf_mem_event__supported(mnt, pmu, e)) {\n\t\t\tpr_err(\"failed: event '%s' not supported\\n\",\n\t\t\t       perf_mem_events__name(idx, pmu->name));\n\t\t}\n\t}\n}\n\nint perf_mem_events__record_args(const char **rec_argv, int *argv_nr,\n\t\t\t\t char **rec_tmp, int *tmp_nr)\n{\n\tconst char *mnt = sysfs__mount();\n\tint i = *argv_nr, k = 0;\n\tstruct perf_mem_event *e;\n\n\tfor (int j = 0; j < PERF_MEM_EVENTS__MAX; j++) {\n\t\te = perf_mem_events__ptr(j);\n\t\tif (!e->record)\n\t\t\tcontinue;\n\n\t\tif (perf_pmus__num_mem_pmus() == 1) {\n\t\t\tif (!e->supported) {\n\t\t\t\tpr_err(\"failed: event '%s' not supported\\n\",\n\t\t\t\t       perf_mem_events__name(j, NULL));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trec_argv[i++] = \"-e\";\n\t\t\trec_argv[i++] = perf_mem_events__name(j, NULL);\n\t\t} else {\n\t\t\tstruct perf_pmu *pmu = NULL;\n\n\t\t\tif (!e->supported) {\n\t\t\t\tperf_mem_events__print_unsupport_hybrid(e, j);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\twhile ((pmu = perf_pmus__scan(pmu)) != NULL) {\n\t\t\t\tconst char *s = perf_mem_events__name(j, pmu->name);\n\n\t\t\t\tif (!perf_mem_event__supported(mnt, pmu, e))\n\t\t\t\t\tcontinue;\n\n\t\t\t\trec_argv[i++] = \"-e\";\n\t\t\t\tif (s) {\n\t\t\t\t\tchar *copy = strdup(s);\n\t\t\t\t\tif (!copy)\n\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\trec_argv[i++] = copy;\n\t\t\t\t\trec_tmp[k++] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*argv_nr = i;\n\t*tmp_nr = k;\n\treturn 0;\n}\n\nstatic const char * const tlb_access[] = {\n\t\"N/A\",\n\t\"HIT\",\n\t\"MISS\",\n\t\"L1\",\n\t\"L2\",\n\t\"Walker\",\n\t\"Fault\",\n};\n\nint perf_mem__tlb_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\n{\n\tsize_t l = 0, i;\n\tu64 m = PERF_MEM_TLB_NA;\n\tu64 hit, miss;\n\n\tsz -= 1;  \n\tout[0] = '\\0';\n\n\tif (mem_info)\n\t\tm = mem_info->data_src.mem_dtlb;\n\n\thit = m & PERF_MEM_TLB_HIT;\n\tmiss = m & PERF_MEM_TLB_MISS;\n\n\t \n\tm &= ~(PERF_MEM_TLB_HIT|PERF_MEM_TLB_MISS);\n\n\tfor (i = 0; m && i < ARRAY_SIZE(tlb_access); i++, m >>= 1) {\n\t\tif (!(m & 0x1))\n\t\t\tcontinue;\n\t\tif (l) {\n\t\t\tstrcat(out, \" or \");\n\t\t\tl += 4;\n\t\t}\n\t\tl += scnprintf(out + l, sz - l, tlb_access[i]);\n\t}\n\tif (*out == '\\0')\n\t\tl += scnprintf(out, sz - l, \"N/A\");\n\tif (hit)\n\t\tl += scnprintf(out + l, sz - l, \" hit\");\n\tif (miss)\n\t\tl += scnprintf(out + l, sz - l, \" miss\");\n\n\treturn l;\n}\n\nstatic const char * const mem_lvl[] = {\n\t\"N/A\",\n\t\"HIT\",\n\t\"MISS\",\n\t\"L1\",\n\t\"LFB/MAB\",\n\t\"L2\",\n\t\"L3\",\n\t\"Local RAM\",\n\t\"Remote RAM (1 hop)\",\n\t\"Remote RAM (2 hops)\",\n\t\"Remote Cache (1 hop)\",\n\t\"Remote Cache (2 hops)\",\n\t\"I/O\",\n\t\"Uncached\",\n};\n\nstatic const char * const mem_lvlnum[] = {\n\t[PERF_MEM_LVLNUM_UNC] = \"Uncached\",\n\t[PERF_MEM_LVLNUM_CXL] = \"CXL\",\n\t[PERF_MEM_LVLNUM_IO] = \"I/O\",\n\t[PERF_MEM_LVLNUM_ANY_CACHE] = \"Any cache\",\n\t[PERF_MEM_LVLNUM_LFB] = \"LFB/MAB\",\n\t[PERF_MEM_LVLNUM_RAM] = \"RAM\",\n\t[PERF_MEM_LVLNUM_PMEM] = \"PMEM\",\n\t[PERF_MEM_LVLNUM_NA] = \"N/A\",\n};\n\nstatic const char * const mem_hops[] = {\n\t\"N/A\",\n\t \n\t\"core, same node\",\n\t\"node, same socket\",\n\t\"socket, same board\",\n\t\"board\",\n};\n\nstatic int perf_mem__op_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\n{\n\tu64 op = PERF_MEM_LOCK_NA;\n\tint l;\n\n\tif (mem_info)\n\t\top = mem_info->data_src.mem_op;\n\n\tif (op & PERF_MEM_OP_NA)\n\t\tl = scnprintf(out, sz, \"N/A\");\n\telse if (op & PERF_MEM_OP_LOAD)\n\t\tl = scnprintf(out, sz, \"LOAD\");\n\telse if (op & PERF_MEM_OP_STORE)\n\t\tl = scnprintf(out, sz, \"STORE\");\n\telse if (op & PERF_MEM_OP_PFETCH)\n\t\tl = scnprintf(out, sz, \"PFETCH\");\n\telse if (op & PERF_MEM_OP_EXEC)\n\t\tl = scnprintf(out, sz, \"EXEC\");\n\telse\n\t\tl = scnprintf(out, sz, \"No\");\n\n\treturn l;\n}\n\nint perf_mem__lvl_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\n{\n\tunion perf_mem_data_src data_src;\n\tint printed = 0;\n\tsize_t l = 0;\n\tsize_t i;\n\tint lvl;\n\tchar hit_miss[5] = {0};\n\n\tsz -= 1;  \n\tout[0] = '\\0';\n\n\tif (!mem_info)\n\t\tgoto na;\n\n\tdata_src = mem_info->data_src;\n\n\tif (data_src.mem_lvl & PERF_MEM_LVL_HIT)\n\t\tmemcpy(hit_miss, \"hit\", 3);\n\telse if (data_src.mem_lvl & PERF_MEM_LVL_MISS)\n\t\tmemcpy(hit_miss, \"miss\", 4);\n\n\tlvl = data_src.mem_lvl_num;\n\tif (lvl && lvl != PERF_MEM_LVLNUM_NA) {\n\t\tif (data_src.mem_remote) {\n\t\t\tstrcat(out, \"Remote \");\n\t\t\tl += 7;\n\t\t}\n\n\t\tif (data_src.mem_hops)\n\t\t\tl += scnprintf(out + l, sz - l, \"%s \", mem_hops[data_src.mem_hops]);\n\n\t\tif (mem_lvlnum[lvl])\n\t\t\tl += scnprintf(out + l, sz - l, mem_lvlnum[lvl]);\n\t\telse\n\t\t\tl += scnprintf(out + l, sz - l, \"L%d\", lvl);\n\n\t\tl += scnprintf(out + l, sz - l, \" %s\", hit_miss);\n\t\treturn l;\n\t}\n\n\tlvl = data_src.mem_lvl;\n\tif (!lvl)\n\t\tgoto na;\n\n\tlvl &= ~(PERF_MEM_LVL_NA | PERF_MEM_LVL_HIT | PERF_MEM_LVL_MISS);\n\tif (!lvl)\n\t\tgoto na;\n\n\tfor (i = 0; lvl && i < ARRAY_SIZE(mem_lvl); i++, lvl >>= 1) {\n\t\tif (!(lvl & 0x1))\n\t\t\tcontinue;\n\t\tif (printed++) {\n\t\t\tstrcat(out, \" or \");\n\t\t\tl += 4;\n\t\t}\n\t\tl += scnprintf(out + l, sz - l, mem_lvl[i]);\n\t}\n\n\tif (printed) {\n\t\tl += scnprintf(out + l, sz - l, \" %s\", hit_miss);\n\t\treturn l;\n\t}\n\nna:\n\tstrcat(out, \"N/A\");\n\treturn 3;\n}\n\nstatic const char * const snoop_access[] = {\n\t\"N/A\",\n\t\"None\",\n\t\"Hit\",\n\t\"Miss\",\n\t\"HitM\",\n};\n\nstatic const char * const snoopx_access[] = {\n\t\"Fwd\",\n\t\"Peer\",\n};\n\nint perf_mem__snp_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\n{\n\tsize_t i, l = 0;\n\tu64 m = PERF_MEM_SNOOP_NA;\n\n\tsz -= 1;  \n\tout[0] = '\\0';\n\n\tif (mem_info)\n\t\tm = mem_info->data_src.mem_snoop;\n\n\tfor (i = 0; m && i < ARRAY_SIZE(snoop_access); i++, m >>= 1) {\n\t\tif (!(m & 0x1))\n\t\t\tcontinue;\n\t\tif (l) {\n\t\t\tstrcat(out, \" or \");\n\t\t\tl += 4;\n\t\t}\n\t\tl += scnprintf(out + l, sz - l, snoop_access[i]);\n\t}\n\n\tm = 0;\n\tif (mem_info)\n\t\tm = mem_info->data_src.mem_snoopx;\n\n\tfor (i = 0; m && i < ARRAY_SIZE(snoopx_access); i++, m >>= 1) {\n\t\tif (!(m & 0x1))\n\t\t\tcontinue;\n\n\t\tif (l) {\n\t\t\tstrcat(out, \" or \");\n\t\t\tl += 4;\n\t\t}\n\t\tl += scnprintf(out + l, sz - l, snoopx_access[i]);\n\t}\n\n\tif (*out == '\\0')\n\t\tl += scnprintf(out, sz - l, \"N/A\");\n\n\treturn l;\n}\n\nint perf_mem__lck_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\n{\n\tu64 mask = PERF_MEM_LOCK_NA;\n\tint l;\n\n\tif (mem_info)\n\t\tmask = mem_info->data_src.mem_lock;\n\n\tif (mask & PERF_MEM_LOCK_NA)\n\t\tl = scnprintf(out, sz, \"N/A\");\n\telse if (mask & PERF_MEM_LOCK_LOCKED)\n\t\tl = scnprintf(out, sz, \"Yes\");\n\telse\n\t\tl = scnprintf(out, sz, \"No\");\n\n\treturn l;\n}\n\nint perf_mem__blk_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\n{\n\tsize_t l = 0;\n\tu64 mask = PERF_MEM_BLK_NA;\n\n\tsz -= 1;  \n\tout[0] = '\\0';\n\n\tif (mem_info)\n\t\tmask = mem_info->data_src.mem_blk;\n\n\tif (!mask || (mask & PERF_MEM_BLK_NA)) {\n\t\tl += scnprintf(out + l, sz - l, \" N/A\");\n\t\treturn l;\n\t}\n\tif (mask & PERF_MEM_BLK_DATA)\n\t\tl += scnprintf(out + l, sz - l, \" Data\");\n\tif (mask & PERF_MEM_BLK_ADDR)\n\t\tl += scnprintf(out + l, sz - l, \" Addr\");\n\n\treturn l;\n}\n\nint perf_script__meminfo_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\n{\n\tint i = 0;\n\n\ti += scnprintf(out, sz, \"|OP \");\n\ti += perf_mem__op_scnprintf(out + i, sz - i, mem_info);\n\ti += scnprintf(out + i, sz - i, \"|LVL \");\n\ti += perf_mem__lvl_scnprintf(out + i, sz, mem_info);\n\ti += scnprintf(out + i, sz - i, \"|SNP \");\n\ti += perf_mem__snp_scnprintf(out + i, sz - i, mem_info);\n\ti += scnprintf(out + i, sz - i, \"|TLB \");\n\ti += perf_mem__tlb_scnprintf(out + i, sz - i, mem_info);\n\ti += scnprintf(out + i, sz - i, \"|LCK \");\n\ti += perf_mem__lck_scnprintf(out + i, sz - i, mem_info);\n\ti += scnprintf(out + i, sz - i, \"|BLK \");\n\ti += perf_mem__blk_scnprintf(out + i, sz - i, mem_info);\n\n\treturn i;\n}\n\nint c2c_decode_stats(struct c2c_stats *stats, struct mem_info *mi)\n{\n\tunion perf_mem_data_src *data_src = &mi->data_src;\n\tu64 daddr  = mi->daddr.addr;\n\tu64 op     = data_src->mem_op;\n\tu64 lvl    = data_src->mem_lvl;\n\tu64 snoop  = data_src->mem_snoop;\n\tu64 snoopx = data_src->mem_snoopx;\n\tu64 lock   = data_src->mem_lock;\n\tu64 blk    = data_src->mem_blk;\n\t \n\tbool mrem  = (data_src->mem_remote && !data_src->mem_hops);\n\tint err = 0;\n\n#define HITM_INC(__f)\t\t\\\ndo {\t\t\t\t\\\n\tstats->__f++;\t\t\\\n\tstats->tot_hitm++;\t\\\n} while (0)\n\n#define PEER_INC(__f)\t\t\\\ndo {\t\t\t\t\\\n\tstats->__f++;\t\t\\\n\tstats->tot_peer++;\t\\\n} while (0)\n\n#define P(a, b) PERF_MEM_##a##_##b\n\n\tstats->nr_entries++;\n\n\tif (lock & P(LOCK, LOCKED)) stats->locks++;\n\n\tif (blk & P(BLK, DATA)) stats->blk_data++;\n\tif (blk & P(BLK, ADDR)) stats->blk_addr++;\n\n\tif (op & P(OP, LOAD)) {\n\t\t \n\t\tstats->load++;\n\n\t\tif (!daddr) {\n\t\t\tstats->ld_noadrs++;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lvl & P(LVL, HIT)) {\n\t\t\tif (lvl & P(LVL, UNC)) stats->ld_uncache++;\n\t\t\tif (lvl & P(LVL, IO))  stats->ld_io++;\n\t\t\tif (lvl & P(LVL, LFB)) stats->ld_fbhit++;\n\t\t\tif (lvl & P(LVL, L1 )) stats->ld_l1hit++;\n\t\t\tif (lvl & P(LVL, L2)) {\n\t\t\t\tstats->ld_l2hit++;\n\n\t\t\t\tif (snoopx & P(SNOOPX, PEER))\n\t\t\t\t\tPEER_INC(lcl_peer);\n\t\t\t}\n\t\t\tif (lvl & P(LVL, L3 )) {\n\t\t\t\tif (snoop & P(SNOOP, HITM))\n\t\t\t\t\tHITM_INC(lcl_hitm);\n\t\t\t\telse\n\t\t\t\t\tstats->ld_llchit++;\n\n\t\t\t\tif (snoopx & P(SNOOPX, PEER))\n\t\t\t\t\tPEER_INC(lcl_peer);\n\t\t\t}\n\n\t\t\tif (lvl & P(LVL, LOC_RAM)) {\n\t\t\t\tstats->lcl_dram++;\n\t\t\t\tif (snoop & P(SNOOP, HIT))\n\t\t\t\t\tstats->ld_shared++;\n\t\t\t\telse\n\t\t\t\t\tstats->ld_excl++;\n\t\t\t}\n\n\t\t\tif ((lvl & P(LVL, REM_RAM1)) ||\n\t\t\t    (lvl & P(LVL, REM_RAM2)) ||\n\t\t\t     mrem) {\n\t\t\t\tstats->rmt_dram++;\n\t\t\t\tif (snoop & P(SNOOP, HIT))\n\t\t\t\t\tstats->ld_shared++;\n\t\t\t\telse\n\t\t\t\t\tstats->ld_excl++;\n\t\t\t}\n\t\t}\n\n\t\tif ((lvl & P(LVL, REM_CCE1)) ||\n\t\t    (lvl & P(LVL, REM_CCE2)) ||\n\t\t     mrem) {\n\t\t\tif (snoop & P(SNOOP, HIT)) {\n\t\t\t\tstats->rmt_hit++;\n\t\t\t} else if (snoop & P(SNOOP, HITM)) {\n\t\t\t\tHITM_INC(rmt_hitm);\n\t\t\t} else if (snoopx & P(SNOOPX, PEER)) {\n\t\t\t\tstats->rmt_hit++;\n\t\t\t\tPEER_INC(rmt_peer);\n\t\t\t}\n\t\t}\n\n\t\tif ((lvl & P(LVL, MISS)))\n\t\t\tstats->ld_miss++;\n\n\t} else if (op & P(OP, STORE)) {\n\t\t \n\t\tstats->store++;\n\n\t\tif (!daddr) {\n\t\t\tstats->st_noadrs++;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lvl & P(LVL, HIT)) {\n\t\t\tif (lvl & P(LVL, UNC)) stats->st_uncache++;\n\t\t\tif (lvl & P(LVL, L1 )) stats->st_l1hit++;\n\t\t}\n\t\tif (lvl & P(LVL, MISS))\n\t\t\tif (lvl & P(LVL, L1)) stats->st_l1miss++;\n\t\tif (lvl & P(LVL, NA))\n\t\t\tstats->st_na++;\n\t} else {\n\t\t \n\t\tstats->noparse++;\n\t\treturn -1;\n\t}\n\n\tif (!mi->daddr.ms.map || !mi->iaddr.ms.map) {\n\t\tstats->nomap++;\n\t\treturn -1;\n\t}\n\n#undef P\n#undef HITM_INC\n\treturn err;\n}\n\nvoid c2c_add_stats(struct c2c_stats *stats, struct c2c_stats *add)\n{\n\tstats->nr_entries\t+= add->nr_entries;\n\n\tstats->locks\t\t+= add->locks;\n\tstats->store\t\t+= add->store;\n\tstats->st_uncache\t+= add->st_uncache;\n\tstats->st_noadrs\t+= add->st_noadrs;\n\tstats->st_l1hit\t\t+= add->st_l1hit;\n\tstats->st_l1miss\t+= add->st_l1miss;\n\tstats->st_na\t\t+= add->st_na;\n\tstats->load\t\t+= add->load;\n\tstats->ld_excl\t\t+= add->ld_excl;\n\tstats->ld_shared\t+= add->ld_shared;\n\tstats->ld_uncache\t+= add->ld_uncache;\n\tstats->ld_io\t\t+= add->ld_io;\n\tstats->ld_miss\t\t+= add->ld_miss;\n\tstats->ld_noadrs\t+= add->ld_noadrs;\n\tstats->ld_fbhit\t\t+= add->ld_fbhit;\n\tstats->ld_l1hit\t\t+= add->ld_l1hit;\n\tstats->ld_l2hit\t\t+= add->ld_l2hit;\n\tstats->ld_llchit\t+= add->ld_llchit;\n\tstats->lcl_hitm\t\t+= add->lcl_hitm;\n\tstats->rmt_hitm\t\t+= add->rmt_hitm;\n\tstats->tot_hitm\t\t+= add->tot_hitm;\n\tstats->lcl_peer\t\t+= add->lcl_peer;\n\tstats->rmt_peer\t\t+= add->rmt_peer;\n\tstats->tot_peer\t\t+= add->tot_peer;\n\tstats->rmt_hit\t\t+= add->rmt_hit;\n\tstats->lcl_dram\t\t+= add->lcl_dram;\n\tstats->rmt_dram\t\t+= add->rmt_dram;\n\tstats->blk_data\t\t+= add->blk_data;\n\tstats->blk_addr\t\t+= add->blk_addr;\n\tstats->nomap\t\t+= add->nomap;\n\tstats->noparse\t\t+= add->noparse;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}