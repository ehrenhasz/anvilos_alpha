{
  "module_name": "data.c",
  "hash_id": "9868f0dee8c27f6061fbaf97937feedd904a6ec3bf361842ac40bc36191059f6",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/data.c",
  "human_readable_source": "\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <linux/err.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <asm/bug.h>\n#include <dirent.h>\n\n#include \"data.h\"\n#include \"util.h\" \n#include \"debug.h\"\n#include \"header.h\"\n#include <internal/lib.h>\n\nstatic void close_dir(struct perf_data_file *files, int nr)\n{\n\twhile (--nr >= 0) {\n\t\tclose(files[nr].fd);\n\t\tzfree(&files[nr].path);\n\t}\n\tfree(files);\n}\n\nvoid perf_data__close_dir(struct perf_data *data)\n{\n\tclose_dir(data->dir.files, data->dir.nr);\n}\n\nint perf_data__create_dir(struct perf_data *data, int nr)\n{\n\tstruct perf_data_file *files = NULL;\n\tint i, ret;\n\n\tif (WARN_ON(!data->is_dir))\n\t\treturn -EINVAL;\n\n\tfiles = zalloc(nr * sizeof(*files));\n\tif (!files)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct perf_data_file *file = &files[i];\n\n\t\tret = asprintf(&file->path, \"%s/data.%d\", data->path, i);\n\t\tif (ret < 0) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tret = open(file->path, O_RDWR|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR);\n\t\tif (ret < 0) {\n\t\t\tret = -errno;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tfile->fd = ret;\n\t}\n\n\tdata->dir.version = PERF_DIR_VERSION;\n\tdata->dir.files   = files;\n\tdata->dir.nr      = nr;\n\treturn 0;\n\nout_err:\n\tclose_dir(files, i);\n\treturn ret;\n}\n\nint perf_data__open_dir(struct perf_data *data)\n{\n\tstruct perf_data_file *files = NULL;\n\tstruct dirent *dent;\n\tint ret = -1;\n\tDIR *dir;\n\tint nr = 0;\n\n\t \n\tif (perf_data__is_single_file(data))\n\t\treturn 0;\n\n\tif (WARN_ON(!data->is_dir))\n\t\treturn -EINVAL;\n\n\t \n\tif (WARN_ON(data->dir.version != PERF_DIR_VERSION))\n\t\treturn -1;\n\n\tdir = opendir(data->path);\n\tif (!dir)\n\t\treturn -EINVAL;\n\n\twhile ((dent = readdir(dir)) != NULL) {\n\t\tstruct perf_data_file *file;\n\t\tchar path[PATH_MAX];\n\t\tstruct stat st;\n\n\t\tsnprintf(path, sizeof(path), \"%s/%s\", data->path, dent->d_name);\n\t\tif (stat(path, &st))\n\t\t\tcontinue;\n\n\t\tif (!S_ISREG(st.st_mode) || strncmp(dent->d_name, \"data.\", 5))\n\t\t\tcontinue;\n\n\t\tret = -ENOMEM;\n\n\t\tfile = realloc(files, (nr + 1) * sizeof(*files));\n\t\tif (!file)\n\t\t\tgoto out_err;\n\n\t\tfiles = file;\n\t\tfile = &files[nr++];\n\n\t\tfile->path = strdup(path);\n\t\tif (!file->path)\n\t\t\tgoto out_err;\n\n\t\tret = open(file->path, O_RDONLY);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\n\t\tfile->fd = ret;\n\t\tfile->size = st.st_size;\n\t}\n\n\tclosedir(dir);\n\tif (!files)\n\t\treturn -EINVAL;\n\n\tdata->dir.files = files;\n\tdata->dir.nr    = nr;\n\treturn 0;\n\nout_err:\n\tclosedir(dir);\n\tclose_dir(files, nr);\n\treturn ret;\n}\n\nint perf_data__update_dir(struct perf_data *data)\n{\n\tint i;\n\n\tif (WARN_ON(!data->is_dir))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < data->dir.nr; i++) {\n\t\tstruct perf_data_file *file = &data->dir.files[i];\n\t\tstruct stat st;\n\n\t\tif (fstat(file->fd, &st))\n\t\t\treturn -1;\n\n\t\tfile->size = st.st_size;\n\t}\n\n\treturn 0;\n}\n\nstatic bool check_pipe(struct perf_data *data)\n{\n\tstruct stat st;\n\tbool is_pipe = false;\n\tint fd = perf_data__is_read(data) ?\n\t\t STDIN_FILENO : STDOUT_FILENO;\n\n\tif (!data->path) {\n\t\tif (!fstat(fd, &st) && S_ISFIFO(st.st_mode))\n\t\t\tis_pipe = true;\n\t} else {\n\t\tif (!strcmp(data->path, \"-\"))\n\t\t\tis_pipe = true;\n\t}\n\n\tif (is_pipe) {\n\t\tif (data->use_stdio) {\n\t\t\tconst char *mode;\n\n\t\t\tmode = perf_data__is_read(data) ? \"r\" : \"w\";\n\t\t\tdata->file.fptr = fdopen(fd, mode);\n\n\t\t\tif (data->file.fptr == NULL) {\n\t\t\t\tdata->file.fd = fd;\n\t\t\t\tdata->use_stdio = false;\n\t\t\t}\n\t\t} else {\n\t\t\tdata->file.fd = fd;\n\t\t}\n\t}\n\n\treturn data->is_pipe = is_pipe;\n}\n\nstatic int check_backup(struct perf_data *data)\n{\n\tstruct stat st;\n\n\tif (perf_data__is_read(data))\n\t\treturn 0;\n\n\tif (!stat(data->path, &st) && st.st_size) {\n\t\tchar oldname[PATH_MAX];\n\t\tint ret;\n\n\t\tsnprintf(oldname, sizeof(oldname), \"%s.old\",\n\t\t\t data->path);\n\n\t\tret = rm_rf_perf_data(oldname);\n\t\tif (ret) {\n\t\t\tpr_err(\"Can't remove old data: %s (%s)\\n\",\n\t\t\t       ret == -2 ?\n\t\t\t       \"Unknown file found\" : strerror(errno),\n\t\t\t       oldname);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (rename(data->path, oldname)) {\n\t\t\tpr_err(\"Can't move data: %s (%s to %s)\\n\",\n\t\t\t       strerror(errno),\n\t\t\t       data->path, oldname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool is_dir(struct perf_data *data)\n{\n\tstruct stat st;\n\n\tif (stat(data->path, &st))\n\t\treturn false;\n\n\treturn (st.st_mode & S_IFMT) == S_IFDIR;\n}\n\nstatic int open_file_read(struct perf_data *data)\n{\n\tint flags = data->in_place_update ? O_RDWR : O_RDONLY;\n\tstruct stat st;\n\tint fd;\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tfd = open(data->file.path, flags);\n\tif (fd < 0) {\n\t\tint err = errno;\n\n\t\tpr_err(\"failed to open %s: %s\", data->file.path,\n\t\t\tstr_error_r(err, sbuf, sizeof(sbuf)));\n\t\tif (err == ENOENT && !strcmp(data->file.path, \"perf.data\"))\n\t\t\tpr_err(\"  (try 'perf record' first)\");\n\t\tpr_err(\"\\n\");\n\t\treturn -err;\n\t}\n\n\tif (fstat(fd, &st) < 0)\n\t\tgoto out_close;\n\n\tif (!data->force && st.st_uid && (st.st_uid != geteuid())) {\n\t\tpr_err(\"File %s not owned by current user or root (use -f to override)\\n\",\n\t\t       data->file.path);\n\t\tgoto out_close;\n\t}\n\n\tif (!st.st_size) {\n\t\tpr_info(\"zero-sized data (%s), nothing to do!\\n\",\n\t\t\tdata->file.path);\n\t\tgoto out_close;\n\t}\n\n\tdata->file.size = st.st_size;\n\treturn fd;\n\n out_close:\n\tclose(fd);\n\treturn -1;\n}\n\nstatic int open_file_write(struct perf_data *data)\n{\n\tint fd;\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tfd = open(data->file.path, O_CREAT|O_RDWR|O_TRUNC|O_CLOEXEC,\n\t\t  S_IRUSR|S_IWUSR);\n\n\tif (fd < 0)\n\t\tpr_err(\"failed to open %s : %s\\n\", data->file.path,\n\t\t\tstr_error_r(errno, sbuf, sizeof(sbuf)));\n\n\treturn fd;\n}\n\nstatic int open_file(struct perf_data *data)\n{\n\tint fd;\n\n\tfd = perf_data__is_read(data) ?\n\t     open_file_read(data) : open_file_write(data);\n\n\tif (fd < 0) {\n\t\tzfree(&data->file.path);\n\t\treturn -1;\n\t}\n\n\tdata->file.fd = fd;\n\treturn 0;\n}\n\nstatic int open_file_dup(struct perf_data *data)\n{\n\tdata->file.path = strdup(data->path);\n\tif (!data->file.path)\n\t\treturn -ENOMEM;\n\n\treturn open_file(data);\n}\n\nstatic int open_dir(struct perf_data *data)\n{\n\tint ret;\n\n\t \n\tif (asprintf(&data->file.path, \"%s/data\", data->path) < 0)\n\t\treturn -1;\n\n\tif (perf_data__is_write(data) &&\n\t    mkdir(data->path, S_IRWXU) < 0)\n\t\treturn -1;\n\n\tret = open_file(data);\n\n\t \n\tif (ret && perf_data__is_write(data))\n\t\trm_rf_perf_data(data->path);\n\n\treturn ret;\n}\n\nint perf_data__open(struct perf_data *data)\n{\n\tif (check_pipe(data))\n\t\treturn 0;\n\n\t \n\tdata->use_stdio = false;\n\n\tif (!data->path)\n\t\tdata->path = \"perf.data\";\n\n\tif (check_backup(data))\n\t\treturn -1;\n\n\tif (perf_data__is_read(data))\n\t\tdata->is_dir = is_dir(data);\n\n\treturn perf_data__is_dir(data) ?\n\t       open_dir(data) : open_file_dup(data);\n}\n\nvoid perf_data__close(struct perf_data *data)\n{\n\tif (perf_data__is_dir(data))\n\t\tperf_data__close_dir(data);\n\n\tzfree(&data->file.path);\n\n\tif (data->use_stdio)\n\t\tfclose(data->file.fptr);\n\telse\n\t\tclose(data->file.fd);\n}\n\nssize_t perf_data__read(struct perf_data *data, void *buf, size_t size)\n{\n\tif (data->use_stdio) {\n\t\tif (fread(buf, size, 1, data->file.fptr) == 1)\n\t\t\treturn size;\n\t\treturn feof(data->file.fptr) ? 0 : -1;\n\t}\n\treturn readn(data->file.fd, buf, size);\n}\n\nssize_t perf_data_file__write(struct perf_data_file *file,\n\t\t\t      void *buf, size_t size)\n{\n\treturn writen(file->fd, buf, size);\n}\n\nssize_t perf_data__write(struct perf_data *data,\n\t\t\t      void *buf, size_t size)\n{\n\tif (data->use_stdio) {\n\t\tif (fwrite(buf, size, 1, data->file.fptr) == 1)\n\t\t\treturn size;\n\t\treturn -1;\n\t}\n\treturn perf_data_file__write(&data->file, buf, size);\n}\n\nint perf_data__switch(struct perf_data *data,\n\t\t\t   const char *postfix,\n\t\t\t   size_t pos, bool at_exit,\n\t\t\t   char **new_filepath)\n{\n\tint ret;\n\n\tif (check_pipe(data))\n\t\treturn -EINVAL;\n\tif (perf_data__is_read(data))\n\t\treturn -EINVAL;\n\n\tif (asprintf(new_filepath, \"%s.%s\", data->path, postfix) < 0)\n\t\treturn -ENOMEM;\n\n\t \n\tif (rename(data->path, *new_filepath))\n\t\tpr_warning(\"Failed to rename %s to %s\\n\", data->path, *new_filepath);\n\n\tif (!at_exit) {\n\t\tclose(data->file.fd);\n\t\tret = perf_data__open(data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (lseek(data->file.fd, pos, SEEK_SET) == (off_t)-1) {\n\t\t\tret = -errno;\n\t\t\tpr_debug(\"Failed to lseek to %zu: %s\",\n\t\t\t\t pos, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = data->file.fd;\nout:\n\treturn ret;\n}\n\nunsigned long perf_data__size(struct perf_data *data)\n{\n\tu64 size = data->file.size;\n\tint i;\n\n\tif (perf_data__is_single_file(data))\n\t\treturn size;\n\n\tfor (i = 0; i < data->dir.nr; i++) {\n\t\tstruct perf_data_file *file = &data->dir.files[i];\n\n\t\tsize += file->size;\n\t}\n\n\treturn size;\n}\n\nint perf_data__make_kcore_dir(struct perf_data *data, char *buf, size_t buf_sz)\n{\n\tint ret;\n\n\tif (!data->is_dir)\n\t\treturn -1;\n\n\tret = snprintf(buf, buf_sz, \"%s/kcore_dir\", data->path);\n\tif (ret < 0 || (size_t)ret >= buf_sz)\n\t\treturn -1;\n\n\treturn mkdir(buf, S_IRWXU);\n}\n\nbool has_kcore_dir(const char *path)\n{\n\tstruct dirent *d = ERR_PTR(-EINVAL);\n\tconst char *name = \"kcore_dir\";\n\tDIR *dir = opendir(path);\n\tsize_t n = strlen(name);\n\tbool result = false;\n\n\tif (dir) {\n\t\twhile (d && !result) {\n\t\t\td = readdir(dir);\n\t\t\tresult = d ? strncmp(d->d_name, name, n) : false;\n\t\t}\n\t\tclosedir(dir);\n\t}\n\n\treturn result;\n}\n\nchar *perf_data__kallsyms_name(struct perf_data *data)\n{\n\tchar *kallsyms_name;\n\tstruct stat st;\n\n\tif (!data->is_dir)\n\t\treturn NULL;\n\n\tif (asprintf(&kallsyms_name, \"%s/kcore_dir/kallsyms\", data->path) < 0)\n\t\treturn NULL;\n\n\tif (stat(kallsyms_name, &st)) {\n\t\tfree(kallsyms_name);\n\t\treturn NULL;\n\t}\n\n\treturn kallsyms_name;\n}\n\nchar *perf_data__guest_kallsyms_name(struct perf_data *data, pid_t machine_pid)\n{\n\tchar *kallsyms_name;\n\tstruct stat st;\n\n\tif (!data->is_dir)\n\t\treturn NULL;\n\n\tif (asprintf(&kallsyms_name, \"%s/kcore_dir__%d/kallsyms\", data->path, machine_pid) < 0)\n\t\treturn NULL;\n\n\tif (stat(kallsyms_name, &st)) {\n\t\tfree(kallsyms_name);\n\t\treturn NULL;\n\t}\n\n\treturn kallsyms_name;\n}\n\nbool is_perf_data(const char *path)\n{\n\tbool ret = false;\n\tFILE *file;\n\tu64 magic;\n\n\tfile = fopen(path, \"r\");\n\tif (!file)\n\t\treturn false;\n\n\tif (fread(&magic, 1, 8, file) < 8)\n\t\tgoto out;\n\n\tret = is_perf_magic(magic);\nout:\n\tfclose(file);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}