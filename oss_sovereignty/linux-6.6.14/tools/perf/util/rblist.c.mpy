{
  "module_name": "rblist.c",
  "hash_id": "8384ab48bd2221f2564bc6c44938c251fa6e588f8a6e5bc9a2a4b5a546108e11",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/rblist.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"rblist.h\"\n\nint rblist__add_node(struct rblist *rblist, const void *new_entry)\n{\n\tstruct rb_node **p = &rblist->entries.rb_root.rb_node;\n\tstruct rb_node *parent = NULL, *new_node;\n\tbool leftmost = true;\n\n\twhile (*p != NULL) {\n\t\tint rc;\n\n\t\tparent = *p;\n\n\t\trc = rblist->node_cmp(parent, new_entry);\n\t\tif (rc > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (rc < 0) {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\tnew_node = rblist->node_new(rblist, new_entry);\n\tif (new_node == NULL)\n\t\treturn -ENOMEM;\n\n\trb_link_node(new_node, parent, p);\n\trb_insert_color_cached(new_node, &rblist->entries, leftmost);\n\t++rblist->nr_entries;\n\n\treturn 0;\n}\n\nvoid rblist__remove_node(struct rblist *rblist, struct rb_node *rb_node)\n{\n\trb_erase_cached(rb_node, &rblist->entries);\n\t--rblist->nr_entries;\n\trblist->node_delete(rblist, rb_node);\n}\n\nstatic struct rb_node *__rblist__findnew(struct rblist *rblist,\n\t\t\t\t\t const void *entry,\n\t\t\t\t\t bool create)\n{\n\tstruct rb_node **p = &rblist->entries.rb_root.rb_node;\n\tstruct rb_node *parent = NULL, *new_node = NULL;\n\tbool leftmost = true;\n\n\twhile (*p != NULL) {\n\t\tint rc;\n\n\t\tparent = *p;\n\n\t\trc = rblist->node_cmp(parent, entry);\n\t\tif (rc > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (rc < 0) {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\tif (create) {\n\t\tnew_node = rblist->node_new(rblist, entry);\n\t\tif (new_node) {\n\t\t\trb_link_node(new_node, parent, p);\n\t\t\trb_insert_color_cached(new_node,\n\t\t\t\t\t       &rblist->entries, leftmost);\n\t\t\t++rblist->nr_entries;\n\t\t}\n\t}\n\n\treturn new_node;\n}\n\nstruct rb_node *rblist__find(struct rblist *rblist, const void *entry)\n{\n\treturn __rblist__findnew(rblist, entry, false);\n}\n\nstruct rb_node *rblist__findnew(struct rblist *rblist, const void *entry)\n{\n\treturn __rblist__findnew(rblist, entry, true);\n}\n\nvoid rblist__init(struct rblist *rblist)\n{\n\tif (rblist != NULL) {\n\t\trblist->entries\t = RB_ROOT_CACHED;\n\t\trblist->nr_entries = 0;\n\t}\n\n\treturn;\n}\n\nvoid rblist__exit(struct rblist *rblist)\n{\n\tstruct rb_node *pos, *next = rb_first_cached(&rblist->entries);\n\n\twhile (next) {\n\t\tpos = next;\n\t\tnext = rb_next(pos);\n\t\trblist__remove_node(rblist, pos);\n\t}\n}\n\nvoid rblist__delete(struct rblist *rblist)\n{\n\tif (rblist != NULL) {\n\t\trblist__exit(rblist);\n\t\tfree(rblist);\n\t}\n}\n\nstruct rb_node *rblist__entry(const struct rblist *rblist, unsigned int idx)\n{\n\tstruct rb_node *node;\n\n\tfor (node = rb_first_cached(&rblist->entries); node;\n\t     node = rb_next(node)) {\n\t\tif (!idx--)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}