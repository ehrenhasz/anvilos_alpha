{
  "module_name": "values.c",
  "hash_id": "b4af56d77ecf9f207332a0994cc5738e8227f937df688b6564f1a558e4f0f820",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/values.c",
  "human_readable_source": "\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <linux/zalloc.h>\n\n#include \"values.h\"\n#include \"debug.h\"\n\nint perf_read_values_init(struct perf_read_values *values)\n{\n\tvalues->threads_max = 16;\n\tvalues->pid = malloc(values->threads_max * sizeof(*values->pid));\n\tvalues->tid = malloc(values->threads_max * sizeof(*values->tid));\n\tvalues->value = zalloc(values->threads_max * sizeof(*values->value));\n\tif (!values->pid || !values->tid || !values->value) {\n\t\tpr_debug(\"failed to allocate read_values threads arrays\");\n\t\tgoto out_free_pid;\n\t}\n\tvalues->threads = 0;\n\n\tvalues->counters_max = 16;\n\tvalues->counterrawid = malloc(values->counters_max\n\t\t\t\t      * sizeof(*values->counterrawid));\n\tvalues->countername = malloc(values->counters_max\n\t\t\t\t     * sizeof(*values->countername));\n\tif (!values->counterrawid || !values->countername) {\n\t\tpr_debug(\"failed to allocate read_values counters arrays\");\n\t\tgoto out_free_counter;\n\t}\n\tvalues->counters = 0;\n\n\treturn 0;\n\nout_free_counter:\n\tzfree(&values->counterrawid);\n\tzfree(&values->countername);\nout_free_pid:\n\tzfree(&values->pid);\n\tzfree(&values->tid);\n\tzfree(&values->value);\n\treturn -ENOMEM;\n}\n\nvoid perf_read_values_destroy(struct perf_read_values *values)\n{\n\tint i;\n\n\tif (!values->threads_max || !values->counters_max)\n\t\treturn;\n\n\tfor (i = 0; i < values->threads; i++)\n\t\tzfree(&values->value[i]);\n\tzfree(&values->value);\n\tzfree(&values->pid);\n\tzfree(&values->tid);\n\tzfree(&values->counterrawid);\n\tfor (i = 0; i < values->counters; i++)\n\t\tzfree(&values->countername[i]);\n\tzfree(&values->countername);\n}\n\nstatic int perf_read_values__enlarge_threads(struct perf_read_values *values)\n{\n\tint nthreads_max = values->threads_max * 2;\n\tvoid *npid = realloc(values->pid, nthreads_max * sizeof(*values->pid)),\n\t     *ntid = realloc(values->tid, nthreads_max * sizeof(*values->tid)),\n\t     *nvalue = realloc(values->value, nthreads_max * sizeof(*values->value));\n\n\tif (!npid || !ntid || !nvalue)\n\t\tgoto out_err;\n\n\tvalues->threads_max = nthreads_max;\n\tvalues->pid = npid;\n\tvalues->tid = ntid;\n\tvalues->value = nvalue;\n\treturn 0;\nout_err:\n\tfree(npid);\n\tfree(ntid);\n\tfree(nvalue);\n\tpr_debug(\"failed to enlarge read_values threads arrays\");\n\treturn -ENOMEM;\n}\n\nstatic int perf_read_values__findnew_thread(struct perf_read_values *values,\n\t\t\t\t\t    u32 pid, u32 tid)\n{\n\tint i;\n\n\tfor (i = 0; i < values->threads; i++)\n\t\tif (values->pid[i] == pid && values->tid[i] == tid)\n\t\t\treturn i;\n\n\tif (values->threads == values->threads_max) {\n\t\ti = perf_read_values__enlarge_threads(values);\n\t\tif (i < 0)\n\t\t\treturn i;\n\t}\n\n\ti = values->threads;\n\n\tvalues->value[i] = zalloc(values->counters_max * sizeof(**values->value));\n\tif (!values->value[i]) {\n\t\tpr_debug(\"failed to allocate read_values counters array\");\n\t\treturn -ENOMEM;\n\t}\n\tvalues->pid[i] = pid;\n\tvalues->tid[i] = tid;\n\tvalues->threads = i + 1;\n\n\treturn i;\n}\n\nstatic int perf_read_values__enlarge_counters(struct perf_read_values *values)\n{\n\tchar **countername;\n\tint i, counters_max = values->counters_max * 2;\n\tu64 *counterrawid = realloc(values->counterrawid, counters_max * sizeof(*values->counterrawid));\n\n\tif (!counterrawid) {\n\t\tpr_debug(\"failed to enlarge read_values rawid array\");\n\t\tgoto out_enomem;\n\t}\n\n\tcountername = realloc(values->countername, counters_max * sizeof(*values->countername));\n\tif (!countername) {\n\t\tpr_debug(\"failed to enlarge read_values rawid array\");\n\t\tgoto out_free_rawid;\n\t}\n\n\tfor (i = 0; i < values->threads; i++) {\n\t\tu64 *value = realloc(values->value[i], counters_max * sizeof(**values->value));\n\t\tint j;\n\n\t\tif (!value) {\n\t\t\tpr_debug(\"failed to enlarge read_values ->values array\");\n\t\t\tgoto out_free_name;\n\t\t}\n\n\t\tfor (j = values->counters_max; j < counters_max; j++)\n\t\t\tvalue[j] = 0;\n\n\t\tvalues->value[i] = value;\n\t}\n\n\tvalues->counters_max = counters_max;\n\tvalues->counterrawid = counterrawid;\n\tvalues->countername  = countername;\n\n\treturn 0;\nout_free_name:\n\tfree(countername);\nout_free_rawid:\n\tfree(counterrawid);\nout_enomem:\n\treturn -ENOMEM;\n}\n\nstatic int perf_read_values__findnew_counter(struct perf_read_values *values,\n\t\t\t\t\t     u64 rawid, const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < values->counters; i++)\n\t\tif (values->counterrawid[i] == rawid)\n\t\t\treturn i;\n\n\tif (values->counters == values->counters_max) {\n\t\ti = perf_read_values__enlarge_counters(values);\n\t\tif (i)\n\t\t\treturn i;\n\t}\n\n\ti = values->counters++;\n\tvalues->counterrawid[i] = rawid;\n\tvalues->countername[i] = strdup(name);\n\n\treturn i;\n}\n\nint perf_read_values_add_value(struct perf_read_values *values,\n\t\t\t\tu32 pid, u32 tid,\n\t\t\t\tu64 rawid, const char *name, u64 value)\n{\n\tint tindex, cindex;\n\n\ttindex = perf_read_values__findnew_thread(values, pid, tid);\n\tif (tindex < 0)\n\t\treturn tindex;\n\tcindex = perf_read_values__findnew_counter(values, rawid, name);\n\tif (cindex < 0)\n\t\treturn cindex;\n\n\tvalues->value[tindex][cindex] += value;\n\treturn 0;\n}\n\nstatic void perf_read_values__display_pretty(FILE *fp,\n\t\t\t\t\t     struct perf_read_values *values)\n{\n\tint i, j;\n\tint pidwidth, tidwidth;\n\tint *counterwidth;\n\n\tcounterwidth = malloc(values->counters * sizeof(*counterwidth));\n\tif (!counterwidth) {\n\t\tfprintf(fp, \"INTERNAL ERROR: Failed to allocate counterwidth array\\n\");\n\t\treturn;\n\t}\n\ttidwidth = 3;\n\tpidwidth = 3;\n\tfor (j = 0; j < values->counters; j++)\n\t\tcounterwidth[j] = strlen(values->countername[j]);\n\tfor (i = 0; i < values->threads; i++) {\n\t\tint width;\n\n\t\twidth = snprintf(NULL, 0, \"%d\", values->pid[i]);\n\t\tif (width > pidwidth)\n\t\t\tpidwidth = width;\n\t\twidth = snprintf(NULL, 0, \"%d\", values->tid[i]);\n\t\tif (width > tidwidth)\n\t\t\ttidwidth = width;\n\t\tfor (j = 0; j < values->counters; j++) {\n\t\t\twidth = snprintf(NULL, 0, \"%\" PRIu64, values->value[i][j]);\n\t\t\tif (width > counterwidth[j])\n\t\t\t\tcounterwidth[j] = width;\n\t\t}\n\t}\n\n\tfprintf(fp, \"# %*s  %*s\", pidwidth, \"PID\", tidwidth, \"TID\");\n\tfor (j = 0; j < values->counters; j++)\n\t\tfprintf(fp, \"  %*s\", counterwidth[j], values->countername[j]);\n\tfprintf(fp, \"\\n\");\n\n\tfor (i = 0; i < values->threads; i++) {\n\t\tfprintf(fp, \"  %*d  %*d\", pidwidth, values->pid[i],\n\t\t\ttidwidth, values->tid[i]);\n\t\tfor (j = 0; j < values->counters; j++)\n\t\t\tfprintf(fp, \"  %*\" PRIu64,\n\t\t\t\tcounterwidth[j], values->value[i][j]);\n\t\tfprintf(fp, \"\\n\");\n\t}\n\tfree(counterwidth);\n}\n\nstatic void perf_read_values__display_raw(FILE *fp,\n\t\t\t\t\t  struct perf_read_values *values)\n{\n\tint width, pidwidth, tidwidth, namewidth, rawwidth, countwidth;\n\tint i, j;\n\n\ttidwidth = 3;  \n\tpidwidth = 3;  \n\tnamewidth = 4;  \n\trawwidth = 3;  \n\tcountwidth = 5;  \n\n\tfor (i = 0; i < values->threads; i++) {\n\t\twidth = snprintf(NULL, 0, \"%d\", values->pid[i]);\n\t\tif (width > pidwidth)\n\t\t\tpidwidth = width;\n\t\twidth = snprintf(NULL, 0, \"%d\", values->tid[i]);\n\t\tif (width > tidwidth)\n\t\t\ttidwidth = width;\n\t}\n\tfor (j = 0; j < values->counters; j++) {\n\t\twidth = strlen(values->countername[j]);\n\t\tif (width > namewidth)\n\t\t\tnamewidth = width;\n\t\twidth = snprintf(NULL, 0, \"%\" PRIx64, values->counterrawid[j]);\n\t\tif (width > rawwidth)\n\t\t\trawwidth = width;\n\t}\n\tfor (i = 0; i < values->threads; i++) {\n\t\tfor (j = 0; j < values->counters; j++) {\n\t\t\twidth = snprintf(NULL, 0, \"%\" PRIu64, values->value[i][j]);\n\t\t\tif (width > countwidth)\n\t\t\t\tcountwidth = width;\n\t\t}\n\t}\n\n\tfprintf(fp, \"# %*s  %*s  %*s  %*s  %*s\\n\",\n\t\tpidwidth, \"PID\", tidwidth, \"TID\",\n\t\tnamewidth, \"Name\", rawwidth, \"Raw\",\n\t\tcountwidth, \"Count\");\n\tfor (i = 0; i < values->threads; i++)\n\t\tfor (j = 0; j < values->counters; j++)\n\t\t\tfprintf(fp, \"  %*d  %*d  %*s  %*\" PRIx64 \"  %*\" PRIu64,\n\t\t\t\tpidwidth, values->pid[i],\n\t\t\t\ttidwidth, values->tid[i],\n\t\t\t\tnamewidth, values->countername[j],\n\t\t\t\trawwidth, values->counterrawid[j],\n\t\t\t\tcountwidth, values->value[i][j]);\n}\n\nvoid perf_read_values_display(FILE *fp, struct perf_read_values *values, int raw)\n{\n\tif (raw)\n\t\tperf_read_values__display_raw(fp, values);\n\telse\n\t\tperf_read_values__display_pretty(fp, values);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}