{
  "module_name": "comm.c",
  "hash_id": "219527c921a9ff3d4f2f5ca592a59309be6014ee95dcfc01338b901aa32a991c",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/comm.c",
  "human_readable_source": "\n#include \"comm.h\"\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n#include <linux/zalloc.h>\n#include \"rwsem.h\"\n\nstruct comm_str {\n\tchar *str;\n\tstruct rb_node rb_node;\n\trefcount_t refcnt;\n};\n\n \nstatic struct rb_root comm_str_root;\nstatic struct rw_semaphore comm_str_lock = {.lock = PTHREAD_RWLOCK_INITIALIZER,};\n\nstatic struct comm_str *comm_str__get(struct comm_str *cs)\n{\n\tif (cs && refcount_inc_not_zero(&cs->refcnt))\n\t\treturn cs;\n\n\treturn NULL;\n}\n\nstatic void comm_str__put(struct comm_str *cs)\n{\n\tif (cs && refcount_dec_and_test(&cs->refcnt)) {\n\t\tdown_write(&comm_str_lock);\n\t\trb_erase(&cs->rb_node, &comm_str_root);\n\t\tup_write(&comm_str_lock);\n\t\tzfree(&cs->str);\n\t\tfree(cs);\n\t}\n}\n\nstatic struct comm_str *comm_str__alloc(const char *str)\n{\n\tstruct comm_str *cs;\n\n\tcs = zalloc(sizeof(*cs));\n\tif (!cs)\n\t\treturn NULL;\n\n\tcs->str = strdup(str);\n\tif (!cs->str) {\n\t\tfree(cs);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cs->refcnt, 1);\n\n\treturn cs;\n}\n\nstatic\nstruct comm_str *__comm_str__findnew(const char *str, struct rb_root *root)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct comm_str *iter, *new;\n\tint cmp;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\titer = rb_entry(parent, struct comm_str, rb_node);\n\n\t\t \n\t\tcmp = strcmp(str, iter->str);\n\t\tif (!cmp && comm_str__get(iter))\n\t\t\treturn iter;\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tnew = comm_str__alloc(str);\n\tif (!new)\n\t\treturn NULL;\n\n\trb_link_node(&new->rb_node, parent, p);\n\trb_insert_color(&new->rb_node, root);\n\n\treturn new;\n}\n\nstatic struct comm_str *comm_str__findnew(const char *str, struct rb_root *root)\n{\n\tstruct comm_str *cs;\n\n\tdown_write(&comm_str_lock);\n\tcs = __comm_str__findnew(str, root);\n\tup_write(&comm_str_lock);\n\n\treturn cs;\n}\n\nstruct comm *comm__new(const char *str, u64 timestamp, bool exec)\n{\n\tstruct comm *comm = zalloc(sizeof(*comm));\n\n\tif (!comm)\n\t\treturn NULL;\n\n\tcomm->start = timestamp;\n\tcomm->exec = exec;\n\n\tcomm->comm_str = comm_str__findnew(str, &comm_str_root);\n\tif (!comm->comm_str) {\n\t\tfree(comm);\n\t\treturn NULL;\n\t}\n\n\treturn comm;\n}\n\nint comm__override(struct comm *comm, const char *str, u64 timestamp, bool exec)\n{\n\tstruct comm_str *new, *old = comm->comm_str;\n\n\tnew = comm_str__findnew(str, &comm_str_root);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tcomm_str__put(old);\n\tcomm->comm_str = new;\n\tcomm->start = timestamp;\n\tif (exec)\n\t\tcomm->exec = true;\n\n\treturn 0;\n}\n\nvoid comm__free(struct comm *comm)\n{\n\tcomm_str__put(comm->comm_str);\n\tfree(comm);\n}\n\nconst char *comm__str(const struct comm *comm)\n{\n\treturn comm->comm_str->str;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}