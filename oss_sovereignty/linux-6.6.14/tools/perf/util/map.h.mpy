{
  "module_name": "map.h",
  "hash_id": "6e21f3b664453808554e89a3685fa92b185d4754458dcc22ccb2ab0c58775d0a",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/map.h",
  "human_readable_source": " \n#ifndef __PERF_MAP_H\n#define __PERF_MAP_H\n\n#include <linux/refcount.h>\n#include <linux/compiler.h>\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <linux/types.h>\n#include <internal/rc_check.h>\n\nstruct dso;\nstruct maps;\nstruct machine;\n\nDECLARE_RC_STRUCT(map) {\n\tu64\t\t\tstart;\n\tu64\t\t\tend;\n\tbool\t\t\terange_warned:1;\n\tbool\t\t\tpriv:1;\n\tu32\t\t\tprot;\n\tu64\t\t\tpgoff;\n\tu64\t\t\treloc;\n\n\t \n\tu64\t\t\t(*map_ip)(const struct map *, u64);\n\t \n\tu64\t\t\t(*unmap_ip)(const struct map *, u64);\n\n\tstruct dso\t\t*dso;\n\trefcount_t\t\trefcnt;\n\tu32\t\t\tflags;\n};\n\nstruct kmap;\n\nstruct kmap *__map__kmap(struct map *map);\nstruct kmap *map__kmap(struct map *map);\nstruct maps *map__kmaps(struct map *map);\n\n \nu64 map__dso_map_ip(const struct map *map, u64 ip);\n \nu64 map__dso_unmap_ip(const struct map *map, u64 ip);\n \nu64 identity__map_ip(const struct map *map __maybe_unused, u64 ip);\n\nstatic inline struct dso *map__dso(const struct map *map)\n{\n\treturn RC_CHK_ACCESS(map)->dso;\n}\n\nstatic inline u64 map__map_ip(const struct map *map, u64 ip)\n{\n\treturn RC_CHK_ACCESS(map)->map_ip(map, ip);\n}\n\nstatic inline u64 map__unmap_ip(const struct map *map, u64 ip)\n{\n\treturn RC_CHK_ACCESS(map)->unmap_ip(map, ip);\n}\n\nstatic inline void *map__map_ip_ptr(struct map *map)\n{\n\treturn RC_CHK_ACCESS(map)->map_ip;\n}\n\nstatic inline void* map__unmap_ip_ptr(struct map *map)\n{\n\treturn RC_CHK_ACCESS(map)->unmap_ip;\n}\n\nstatic inline u64 map__start(const struct map *map)\n{\n\treturn RC_CHK_ACCESS(map)->start;\n}\n\nstatic inline u64 map__end(const struct map *map)\n{\n\treturn RC_CHK_ACCESS(map)->end;\n}\n\nstatic inline u64 map__pgoff(const struct map *map)\n{\n\treturn RC_CHK_ACCESS(map)->pgoff;\n}\n\nstatic inline u64 map__reloc(const struct map *map)\n{\n\treturn RC_CHK_ACCESS(map)->reloc;\n}\n\nstatic inline u32 map__flags(const struct map *map)\n{\n\treturn RC_CHK_ACCESS(map)->flags;\n}\n\nstatic inline u32 map__prot(const struct map *map)\n{\n\treturn RC_CHK_ACCESS(map)->prot;\n}\n\nstatic inline bool map__priv(const struct map *map)\n{\n\treturn RC_CHK_ACCESS(map)->priv;\n}\n\nstatic inline refcount_t *map__refcnt(struct map *map)\n{\n\treturn &RC_CHK_ACCESS(map)->refcnt;\n}\n\nstatic inline bool map__erange_warned(struct map *map)\n{\n\treturn RC_CHK_ACCESS(map)->erange_warned;\n}\n\nstatic inline size_t map__size(const struct map *map)\n{\n\treturn map__end(map) - map__start(map);\n}\n\n \nu64 map__rip_2objdump(struct map *map, u64 rip);\n\n \nu64 map__objdump_2mem(struct map *map, u64 ip);\n\nstruct symbol;\nstruct thread;\n\n \n#define map__for_each_symbol(map, pos, n)\t\\\n\tdso__for_each_symbol(map__dso(map), pos, n)\n\n \n#define __map__for_each_symbol_by_name(map, sym_name, pos, idx)\t\t\\\n\tfor (pos = map__find_symbol_by_name_idx(map, sym_name, &idx);\t\\\n\t     pos &&\t\t\t\t\t\t\\\n\t     !symbol__match_symbol_name(pos->name, sym_name,\t\\\n\t\t\t\t\tSYMBOL_TAG_INCLUDE__DEFAULT_ONLY); \\\n\t     pos = dso__next_symbol_by_name(map__dso(map), &idx))\n\n#define map__for_each_symbol_by_name(map, sym_name, pos, idx)\t\\\n\t__map__for_each_symbol_by_name(map, sym_name, (pos), idx)\n\nvoid map__init(struct map *map,\n\t       u64 start, u64 end, u64 pgoff, struct dso *dso);\n\nstruct dso_id;\nstruct build_id;\n\nstruct map *map__new(struct machine *machine, u64 start, u64 len,\n\t\t     u64 pgoff, struct dso_id *id, u32 prot, u32 flags,\n\t\t     struct build_id *bid, char *filename, struct thread *thread);\nstruct map *map__new2(u64 start, struct dso *dso);\nvoid map__delete(struct map *map);\nstruct map *map__clone(struct map *map);\n\nstatic inline struct map *map__get(struct map *map)\n{\n\tstruct map *result;\n\n\tif (RC_CHK_GET(result, map))\n\t\trefcount_inc(map__refcnt(map));\n\n\treturn result;\n}\n\nvoid map__put(struct map *map);\n\nstatic inline void __map__zput(struct map **map)\n{\n\tmap__put(*map);\n\t*map = NULL;\n}\n\n#define map__zput(map) __map__zput(&map)\n\nsize_t map__fprintf(struct map *map, FILE *fp);\nsize_t map__fprintf_dsoname(struct map *map, FILE *fp);\nsize_t map__fprintf_dsoname_dsoff(struct map *map, bool print_off, u64 addr, FILE *fp);\nchar *map__srcline(struct map *map, u64 addr, struct symbol *sym);\nint map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,\n\t\t\t FILE *fp);\n\nint map__load(struct map *map);\nstruct symbol *map__find_symbol(struct map *map, u64 addr);\nstruct symbol *map__find_symbol_by_name(struct map *map, const char *name);\nstruct symbol *map__find_symbol_by_name_idx(struct map *map, const char *name, size_t *idx);\nvoid map__fixup_start(struct map *map);\nvoid map__fixup_end(struct map *map);\n\nint map__set_kallsyms_ref_reloc_sym(struct map *map, const char *symbol_name,\n\t\t\t\t    u64 addr);\n\nbool __map__is_kernel(const struct map *map);\nbool __map__is_extra_kernel_map(const struct map *map);\nbool __map__is_bpf_prog(const struct map *map);\nbool __map__is_bpf_image(const struct map *map);\nbool __map__is_ool(const struct map *map);\n\nstatic inline bool __map__is_kmodule(const struct map *map)\n{\n\treturn !__map__is_kernel(map) && !__map__is_extra_kernel_map(map) &&\n\t       !__map__is_bpf_prog(map) && !__map__is_ool(map) &&\n\t       !__map__is_bpf_image(map);\n}\n\nbool map__has_symbols(const struct map *map);\n\nbool map__contains_symbol(const struct map *map, const struct symbol *sym);\n\n#define ENTRY_TRAMPOLINE_NAME \"__entry_SYSCALL_64_trampoline\"\n\nstatic inline bool is_entry_trampoline(const char *name)\n{\n\treturn !strcmp(name, ENTRY_TRAMPOLINE_NAME);\n}\n\nstatic inline bool is_bpf_image(const char *name)\n{\n\treturn strncmp(name, \"bpf_trampoline_\", sizeof(\"bpf_trampoline_\") - 1) == 0 ||\n\t       strncmp(name, \"bpf_dispatcher_\", sizeof(\"bpf_dispatcher_\") - 1) == 0;\n}\n\nstatic inline int is_anon_memory(const char *filename)\n{\n\treturn !strcmp(filename, \"//anon\") ||\n\t       !strncmp(filename, \"/dev/zero\", sizeof(\"/dev/zero\") - 1) ||\n\t       !strncmp(filename, \"/anon_hugepage\", sizeof(\"/anon_hugepage\") - 1);\n}\n\nstatic inline int is_no_dso_memory(const char *filename)\n{\n\treturn !strncmp(filename, \"[stack\", 6) ||\n\t       !strncmp(filename, \"/SYSV\", 5)  ||\n\t       !strcmp(filename, \"[heap]\");\n}\n\nstatic inline void map__set_start(struct map *map, u64 start)\n{\n\tRC_CHK_ACCESS(map)->start = start;\n}\n\nstatic inline void map__set_end(struct map *map, u64 end)\n{\n\tRC_CHK_ACCESS(map)->end = end;\n}\n\nstatic inline void map__set_pgoff(struct map *map, u64 pgoff)\n{\n\tRC_CHK_ACCESS(map)->pgoff = pgoff;\n}\n\nstatic inline void map__add_pgoff(struct map *map, u64 inc)\n{\n\tRC_CHK_ACCESS(map)->pgoff += inc;\n}\n\nstatic inline void map__set_reloc(struct map *map, u64 reloc)\n{\n\tRC_CHK_ACCESS(map)->reloc = reloc;\n}\n\nstatic inline void map__set_priv(struct map *map, int priv)\n{\n\tRC_CHK_ACCESS(map)->priv = priv;\n}\n\nstatic inline void map__set_erange_warned(struct map *map, bool erange_warned)\n{\n\tRC_CHK_ACCESS(map)->erange_warned = erange_warned;\n}\n\nstatic inline void map__set_dso(struct map *map, struct dso *dso)\n{\n\tRC_CHK_ACCESS(map)->dso = dso;\n}\n\nstatic inline void map__set_map_ip(struct map *map, u64 (*map_ip)(const struct map *map, u64 ip))\n{\n\tRC_CHK_ACCESS(map)->map_ip = map_ip;\n}\n\nstatic inline void map__set_unmap_ip(struct map *map, u64 (*unmap_ip)(const struct map *map, u64 rip))\n{\n\tRC_CHK_ACCESS(map)->unmap_ip = unmap_ip;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}