{
  "module_name": "unwind-libdw.c",
  "hash_id": "7a21445488346fbde7689f7c894f4cf18544d00a0d2593367f936c9e4dd537e8",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/unwind-libdw.c",
  "human_readable_source": "\n#include <linux/compiler.h>\n#include <elfutils/libdw.h>\n#include <elfutils/libdwfl.h>\n#include <inttypes.h>\n#include <errno.h>\n#include \"debug.h\"\n#include \"dso.h\"\n#include \"unwind.h\"\n#include \"unwind-libdw.h\"\n#include \"machine.h\"\n#include \"map.h\"\n#include \"symbol.h\"\n#include \"thread.h\"\n#include <linux/types.h>\n#include <linux/zalloc.h>\n#include \"event.h\"\n#include \"perf_regs.h\"\n#include \"callchain.h\"\n#include \"util/env.h\"\n\nstatic char *debuginfo_path;\n\nstatic int __find_debuginfo(Dwfl_Module *mod __maybe_unused, void **userdata,\n\t\t\t    const char *modname __maybe_unused, Dwarf_Addr base __maybe_unused,\n\t\t\t    const char *file_name, const char *debuglink_file __maybe_unused,\n\t\t\t    GElf_Word debuglink_crc __maybe_unused, char **debuginfo_file_name)\n{\n\tconst struct dso *dso = *userdata;\n\n\tassert(dso);\n\tif (dso->symsrc_filename && strcmp (file_name, dso->symsrc_filename))\n\t\t*debuginfo_file_name = strdup(dso->symsrc_filename);\n\treturn -1;\n}\n\nstatic const Dwfl_Callbacks offline_callbacks = {\n\t.find_debuginfo\t\t= __find_debuginfo,\n\t.debuginfo_path\t\t= &debuginfo_path,\n\t.section_address\t= dwfl_offline_section_address,\n\t\n};\n\nstatic int __report_module(struct addr_location *al, u64 ip,\n\t\t\t    struct unwind_info *ui)\n{\n\tDwfl_Module *mod;\n\tstruct dso *dso = NULL;\n\tDwarf_Addr base;\n\t \n\tthread__find_symbol(ui->thread, PERF_RECORD_MISC_USER, ip, al);\n\n\tif (al->map)\n\t\tdso = map__dso(al->map);\n\n\tif (!dso)\n\t\treturn 0;\n\n\t \n\tif (!strncmp(dso->long_name, \"/tmp/jitted-\", 12))\n\t\tbase = map__start(al->map);\n\telse\n\t\tbase = map__start(al->map) - map__pgoff(al->map);\n\n\tmod = dwfl_addrmodule(ui->dwfl, ip);\n\tif (mod) {\n\t\tDwarf_Addr s;\n\n\t\tdwfl_module_info(mod, NULL, &s, NULL, NULL, NULL, NULL, NULL);\n\t\tif (s != base)\n\t\t\tmod = NULL;\n\t}\n\n\tif (!mod) {\n\t\tchar filename[PATH_MAX];\n\n\t\t__symbol__join_symfs(filename, sizeof(filename), dso->long_name);\n\t\tmod = dwfl_report_elf(ui->dwfl, dso->short_name, filename, -1,\n\t\t\t\t      base, false);\n\t}\n\tif (!mod) {\n\t\tchar filename[PATH_MAX];\n\n\t\tif (dso__build_id_filename(dso, filename, sizeof(filename), false))\n\t\t\tmod = dwfl_report_elf(ui->dwfl, dso->short_name, filename, -1,\n\t\t\t\t\t      base, false);\n\t}\n\n\tif (mod) {\n\t\tvoid **userdatap;\n\n\t\tdwfl_module_info(mod, &userdatap, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t*userdatap = dso;\n\t}\n\n\treturn mod && dwfl_addrmodule(ui->dwfl, ip) == mod ? 0 : -1;\n}\n\nstatic int report_module(u64 ip, struct unwind_info *ui)\n{\n\tstruct addr_location al;\n\tint res;\n\n\taddr_location__init(&al);\n\tres = __report_module(&al, ip, ui);\n\taddr_location__exit(&al);\n\treturn res;\n}\n\n \nstatic int entry(u64 ip, struct unwind_info *ui)\n\n{\n\tstruct unwind_entry *e = &ui->entries[ui->idx++];\n\tstruct addr_location al;\n\n\taddr_location__init(&al);\n\tif (__report_module(&al, ip, ui)) {\n\t\taddr_location__exit(&al);\n\t\treturn -1;\n\t}\n\n\te->ip\t  = ip;\n\te->ms.maps = al.maps;\n\te->ms.map = al.map;\n\te->ms.sym = al.sym;\n\n\tpr_debug(\"unwind: %s:ip = 0x%\" PRIx64 \" (0x%\" PRIx64 \")\\n\",\n\t\t al.sym ? al.sym->name : \"''\",\n\t\t ip,\n\t\t al.map ? map__map_ip(al.map, ip) : (u64) 0);\n\taddr_location__exit(&al);\n\treturn 0;\n}\n\nstatic pid_t next_thread(Dwfl *dwfl, void *arg, void **thread_argp)\n{\n\t \n\tif (*thread_argp != NULL)\n\t\treturn 0;\n\n\t*thread_argp = arg;\n\treturn dwfl_pid(dwfl);\n}\n\nstatic int access_dso_mem(struct unwind_info *ui, Dwarf_Addr addr,\n\t\t\t  Dwarf_Word *data)\n{\n\tstruct addr_location al;\n\tssize_t size;\n\tstruct dso *dso;\n\n\taddr_location__init(&al);\n\tif (!thread__find_map(ui->thread, PERF_RECORD_MISC_USER, addr, &al)) {\n\t\tpr_debug(\"unwind: no map for %lx\\n\", (unsigned long)addr);\n\t\tgoto out_fail;\n\t}\n\tdso = map__dso(al.map);\n\tif (!dso)\n\t\tgoto out_fail;\n\n\tsize = dso__data_read_addr(dso, al.map, ui->machine, addr, (u8 *) data, sizeof(*data));\n\n\taddr_location__exit(&al);\n\treturn !(size == sizeof(*data));\nout_fail:\n\taddr_location__exit(&al);\n\treturn -1;\n}\n\nstatic bool memory_read(Dwfl *dwfl __maybe_unused, Dwarf_Addr addr, Dwarf_Word *result,\n\t\t\tvoid *arg)\n{\n\tstruct unwind_info *ui = arg;\n\tconst char *arch = perf_env__arch(ui->machine->env);\n\tstruct stack_dump *stack = &ui->sample->user_stack;\n\tu64 start, end;\n\tint offset;\n\tint ret;\n\n\tret = perf_reg_value(&start, &ui->sample->user_regs,\n\t\t\t     perf_arch_reg_sp(arch));\n\tif (ret)\n\t\treturn false;\n\n\tend = start + stack->size;\n\n\t \n\tif (addr + sizeof(Dwarf_Word) < addr)\n\t\treturn false;\n\n\tif (addr < start || addr + sizeof(Dwarf_Word) > end) {\n\t\tret = access_dso_mem(ui, addr, result);\n\t\tif (ret) {\n\t\t\tpr_debug(\"unwind: access_mem 0x%\" PRIx64 \" not inside range\"\n\t\t\t\t \" 0x%\" PRIx64 \"-0x%\" PRIx64 \"\\n\",\n\t\t\t\taddr, start, end);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\toffset  = addr - start;\n\t*result = *(Dwarf_Word *)&stack->data[offset];\n\tpr_debug(\"unwind: access_mem addr 0x%\" PRIx64 \", val %lx, offset %d\\n\",\n\t\t addr, (unsigned long)*result, offset);\n\treturn true;\n}\n\nstatic const Dwfl_Thread_Callbacks callbacks = {\n\t.next_thread\t\t= next_thread,\n\t.memory_read\t\t= memory_read,\n\t.set_initial_registers\t= libdw__arch_set_initial_registers,\n};\n\nstatic int\nframe_callback(Dwfl_Frame *state, void *arg)\n{\n\tstruct unwind_info *ui = arg;\n\tDwarf_Addr pc;\n\tbool isactivation;\n\n\tif (!dwfl_frame_pc(state, &pc, NULL)) {\n\t\tif (!ui->best_effort)\n\t\t\tpr_err(\"%s\", dwfl_errmsg(-1));\n\t\treturn DWARF_CB_ABORT;\n\t}\n\n\t \n\treport_module(pc, ui);\n\n\tif (!dwfl_frame_pc(state, &pc, &isactivation)) {\n\t\tif (!ui->best_effort)\n\t\t\tpr_err(\"%s\", dwfl_errmsg(-1));\n\t\treturn DWARF_CB_ABORT;\n\t}\n\n\tif (!isactivation)\n\t\t--pc;\n\n\treturn entry(pc, ui) || !(--ui->max_stack) ?\n\t       DWARF_CB_ABORT : DWARF_CB_OK;\n}\n\nint unwind__get_entries(unwind_entry_cb_t cb, void *arg,\n\t\t\tstruct thread *thread,\n\t\t\tstruct perf_sample *data,\n\t\t\tint max_stack,\n\t\t\tbool best_effort)\n{\n\tstruct unwind_info *ui, ui_buf = {\n\t\t.sample\t\t= data,\n\t\t.thread\t\t= thread,\n\t\t.machine\t= RC_CHK_ACCESS(thread__maps(thread))->machine,\n\t\t.cb\t\t= cb,\n\t\t.arg\t\t= arg,\n\t\t.max_stack\t= max_stack,\n\t\t.best_effort    = best_effort\n\t};\n\tconst char *arch = perf_env__arch(ui_buf.machine->env);\n\tDwarf_Word ip;\n\tint err = -EINVAL, i;\n\n\tif (!data->user_regs.regs)\n\t\treturn -EINVAL;\n\n\tui = zalloc(sizeof(ui_buf) + sizeof(ui_buf.entries[0]) * max_stack);\n\tif (!ui)\n\t\treturn -ENOMEM;\n\n\t*ui = ui_buf;\n\n\tui->dwfl = dwfl_begin(&offline_callbacks);\n\tif (!ui->dwfl)\n\t\tgoto out;\n\n\terr = perf_reg_value(&ip, &data->user_regs, perf_arch_reg_ip(arch));\n\tif (err)\n\t\tgoto out;\n\n\terr = report_module(ip, ui);\n\tif (err)\n\t\tgoto out;\n\n\terr = !dwfl_attach_state(ui->dwfl, EM_NONE, thread__tid(thread), &callbacks, ui);\n\tif (err)\n\t\tgoto out;\n\n\terr = dwfl_getthread_frames(ui->dwfl, thread__tid(thread), frame_callback, ui);\n\n\tif (err && ui->max_stack != max_stack)\n\t\terr = 0;\n\n\t \n\tfor (i = 0; i < ui->idx && !err; i++) {\n\t\tint j = i;\n\n\t\tif (callchain_param.order == ORDER_CALLER)\n\t\t\tj = ui->idx - i - 1;\n\n\t\terr = ui->entries[j].ip ? ui->cb(&ui->entries[j], ui->arg) : 0;\n\t}\n\n out:\n\tif (err)\n\t\tpr_debug(\"unwind: failed with '%s'\\n\", dwfl_errmsg(-1));\n\n\tdwfl_end(ui->dwfl);\n\tfree(ui);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}