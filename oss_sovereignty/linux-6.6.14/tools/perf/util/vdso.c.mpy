{
  "module_name": "vdso.c",
  "hash_id": "18d33df76c3263f70939b8a1f9a847a8eebec0a3e0857c849108a3fa67b2bdaf",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/vdso.c",
  "human_readable_source": "\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <linux/kernel.h>\n\n#include \"vdso.h\"\n#include \"dso.h\"\n#include <internal/lib.h>\n#include \"map.h\"\n#include \"symbol.h\"\n#include \"machine.h\"\n#include \"thread.h\"\n#include \"linux/string.h\"\n#include <linux/zalloc.h>\n#include \"debug.h\"\n\n \n#include \"find-map.c\"\n\n#define VDSO__TEMP_FILE_NAME \"/tmp/perf-vdso.so-XXXXXX\"\n\nstruct vdso_file {\n\tbool found;\n\tbool error;\n\tchar temp_file_name[sizeof(VDSO__TEMP_FILE_NAME)];\n\tconst char *dso_name;\n\tconst char *read_prog;\n};\n\nstruct vdso_info {\n\tstruct vdso_file vdso;\n#if BITS_PER_LONG == 64\n\tstruct vdso_file vdso32;\n\tstruct vdso_file vdsox32;\n#endif\n};\n\nstatic struct vdso_info *vdso_info__new(void)\n{\n\tstatic const struct vdso_info vdso_info_init = {\n\t\t.vdso    = {\n\t\t\t.temp_file_name = VDSO__TEMP_FILE_NAME,\n\t\t\t.dso_name = DSO__NAME_VDSO,\n\t\t},\n#if BITS_PER_LONG == 64\n\t\t.vdso32  = {\n\t\t\t.temp_file_name = VDSO__TEMP_FILE_NAME,\n\t\t\t.dso_name = DSO__NAME_VDSO32,\n\t\t\t.read_prog = \"perf-read-vdso32\",\n\t\t},\n\t\t.vdsox32  = {\n\t\t\t.temp_file_name = VDSO__TEMP_FILE_NAME,\n\t\t\t.dso_name = DSO__NAME_VDSOX32,\n\t\t\t.read_prog = \"perf-read-vdsox32\",\n\t\t},\n#endif\n\t};\n\n\treturn memdup(&vdso_info_init, sizeof(vdso_info_init));\n}\n\nstatic char *get_file(struct vdso_file *vdso_file)\n{\n\tchar *vdso = NULL;\n\tchar *buf = NULL;\n\tvoid *start, *end;\n\tsize_t size;\n\tint fd;\n\n\tif (vdso_file->found)\n\t\treturn vdso_file->temp_file_name;\n\n\tif (vdso_file->error || find_map(&start, &end, VDSO__MAP_NAME))\n\t\treturn NULL;\n\n\tsize = end - start;\n\n\tbuf = memdup(start, size);\n\tif (!buf)\n\t\treturn NULL;\n\n\tfd = mkstemp(vdso_file->temp_file_name);\n\tif (fd < 0)\n\t\tgoto out;\n\n\tif (size == (size_t) write(fd, buf, size))\n\t\tvdso = vdso_file->temp_file_name;\n\n\tclose(fd);\n\n out:\n\tfree(buf);\n\n\tvdso_file->found = (vdso != NULL);\n\tvdso_file->error = !vdso_file->found;\n\treturn vdso;\n}\n\nvoid machine__exit_vdso(struct machine *machine)\n{\n\tstruct vdso_info *vdso_info = machine->vdso_info;\n\n\tif (!vdso_info)\n\t\treturn;\n\n\tif (vdso_info->vdso.found)\n\t\tunlink(vdso_info->vdso.temp_file_name);\n#if BITS_PER_LONG == 64\n\tif (vdso_info->vdso32.found)\n\t\tunlink(vdso_info->vdso32.temp_file_name);\n\tif (vdso_info->vdsox32.found)\n\t\tunlink(vdso_info->vdsox32.temp_file_name);\n#endif\n\n\tzfree(&machine->vdso_info);\n}\n\nstatic struct dso *__machine__addnew_vdso(struct machine *machine, const char *short_name,\n\t\t\t\t\t  const char *long_name)\n{\n\tstruct dso *dso;\n\n\tdso = dso__new(short_name);\n\tif (dso != NULL) {\n\t\t__dsos__add(&machine->dsos, dso);\n\t\tdso__set_long_name(dso, long_name, false);\n\t\t \n\t\tdso__put(dso);\n\t}\n\n\treturn dso;\n}\n\nstatic enum dso_type machine__thread_dso_type(struct machine *machine,\n\t\t\t\t\t      struct thread *thread)\n{\n\tenum dso_type dso_type = DSO__TYPE_UNKNOWN;\n\tstruct map_rb_node *rb_node;\n\n\tmaps__for_each_entry(thread__maps(thread), rb_node) {\n\t\tstruct dso *dso = map__dso(rb_node->map);\n\n\t\tif (!dso || dso->long_name[0] != '/')\n\t\t\tcontinue;\n\t\tdso_type = dso__type(dso, machine);\n\t\tif (dso_type != DSO__TYPE_UNKNOWN)\n\t\t\tbreak;\n\t}\n\n\treturn dso_type;\n}\n\n#if BITS_PER_LONG == 64\n\nstatic int vdso__do_copy_compat(FILE *f, int fd)\n{\n\tchar buf[4096];\n\tsize_t count;\n\n\twhile (1) {\n\t\tcount = fread(buf, 1, sizeof(buf), f);\n\t\tif (ferror(f))\n\t\t\treturn -errno;\n\t\tif (feof(f))\n\t\t\tbreak;\n\t\tif (count && writen(fd, buf, count) != (ssize_t)count)\n\t\t\treturn -errno;\n\t}\n\n\treturn 0;\n}\n\nstatic int vdso__copy_compat(const char *prog, int fd)\n{\n\tFILE *f;\n\tint err;\n\n\tf = popen(prog, \"r\");\n\tif (!f)\n\t\treturn -errno;\n\n\terr = vdso__do_copy_compat(f, fd);\n\n\tif (pclose(f) == -1)\n\t\treturn -errno;\n\n\treturn err;\n}\n\nstatic int vdso__create_compat_file(const char *prog, char *temp_name)\n{\n\tint fd, err;\n\n\tfd = mkstemp(temp_name);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\terr = vdso__copy_compat(prog, fd);\n\n\tif (close(fd) == -1)\n\t\treturn -errno;\n\n\treturn err;\n}\n\nstatic const char *vdso__get_compat_file(struct vdso_file *vdso_file)\n{\n\tint err;\n\n\tif (vdso_file->found)\n\t\treturn vdso_file->temp_file_name;\n\n\tif (vdso_file->error)\n\t\treturn NULL;\n\n\terr = vdso__create_compat_file(vdso_file->read_prog,\n\t\t\t\t       vdso_file->temp_file_name);\n\tif (err) {\n\t\tpr_err(\"%s failed, error %d\\n\", vdso_file->read_prog, err);\n\t\tvdso_file->error = true;\n\t\treturn NULL;\n\t}\n\n\tvdso_file->found = true;\n\n\treturn vdso_file->temp_file_name;\n}\n\nstatic struct dso *__machine__findnew_compat(struct machine *machine,\n\t\t\t\t\t     struct vdso_file *vdso_file)\n{\n\tconst char *file_name;\n\tstruct dso *dso;\n\n\tdso = __dsos__find(&machine->dsos, vdso_file->dso_name, true);\n\tif (dso)\n\t\tgoto out;\n\n\tfile_name = vdso__get_compat_file(vdso_file);\n\tif (!file_name)\n\t\tgoto out;\n\n\tdso = __machine__addnew_vdso(machine, vdso_file->dso_name, file_name);\nout:\n\treturn dso;\n}\n\nstatic int __machine__findnew_vdso_compat(struct machine *machine,\n\t\t\t\t\t  struct thread *thread,\n\t\t\t\t\t  struct vdso_info *vdso_info,\n\t\t\t\t\t  struct dso **dso)\n{\n\tenum dso_type dso_type;\n\n\tdso_type = machine__thread_dso_type(machine, thread);\n\n#ifndef HAVE_PERF_READ_VDSO32\n\tif (dso_type == DSO__TYPE_32BIT)\n\t\treturn 0;\n#endif\n#ifndef HAVE_PERF_READ_VDSOX32\n\tif (dso_type == DSO__TYPE_X32BIT)\n\t\treturn 0;\n#endif\n\n\tswitch (dso_type) {\n\tcase DSO__TYPE_32BIT:\n\t\t*dso = __machine__findnew_compat(machine, &vdso_info->vdso32);\n\t\treturn 1;\n\tcase DSO__TYPE_X32BIT:\n\t\t*dso = __machine__findnew_compat(machine, &vdso_info->vdsox32);\n\t\treturn 1;\n\tcase DSO__TYPE_UNKNOWN:\n\tcase DSO__TYPE_64BIT:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n#endif\n\nstatic struct dso *machine__find_vdso(struct machine *machine,\n\t\t\t\t      struct thread *thread)\n{\n\tstruct dso *dso = NULL;\n\tenum dso_type dso_type;\n\n\tdso_type = machine__thread_dso_type(machine, thread);\n\tswitch (dso_type) {\n\tcase DSO__TYPE_32BIT:\n\t\tdso = __dsos__find(&machine->dsos, DSO__NAME_VDSO32, true);\n\t\tif (!dso) {\n\t\t\tdso = __dsos__find(&machine->dsos, DSO__NAME_VDSO,\n\t\t\t\t\t   true);\n\t\t\tif (dso && dso_type != dso__type(dso, machine))\n\t\t\t\tdso = NULL;\n\t\t}\n\t\tbreak;\n\tcase DSO__TYPE_X32BIT:\n\t\tdso = __dsos__find(&machine->dsos, DSO__NAME_VDSOX32, true);\n\t\tbreak;\n\tcase DSO__TYPE_64BIT:\n\tcase DSO__TYPE_UNKNOWN:\n\tdefault:\n\t\tdso = __dsos__find(&machine->dsos, DSO__NAME_VDSO, true);\n\t\tbreak;\n\t}\n\n\treturn dso;\n}\n\nstruct dso *machine__findnew_vdso(struct machine *machine,\n\t\t\t\t  struct thread *thread)\n{\n\tstruct vdso_info *vdso_info;\n\tstruct dso *dso = NULL;\n\n\tdown_write(&machine->dsos.lock);\n\tif (!machine->vdso_info)\n\t\tmachine->vdso_info = vdso_info__new();\n\n\tvdso_info = machine->vdso_info;\n\tif (!vdso_info)\n\t\tgoto out_unlock;\n\n\tdso = machine__find_vdso(machine, thread);\n\tif (dso)\n\t\tgoto out_unlock;\n\n#if BITS_PER_LONG == 64\n\tif (__machine__findnew_vdso_compat(machine, thread, vdso_info, &dso))\n\t\tgoto out_unlock;\n#endif\n\n\tdso = __dsos__find(&machine->dsos, DSO__NAME_VDSO, true);\n\tif (!dso) {\n\t\tchar *file;\n\n\t\tfile = get_file(&vdso_info->vdso);\n\t\tif (file)\n\t\t\tdso = __machine__addnew_vdso(machine, DSO__NAME_VDSO, file);\n\t}\n\nout_unlock:\n\tdso__get(dso);\n\tup_write(&machine->dsos.lock);\n\treturn dso;\n}\n\nbool dso__is_vdso(struct dso *dso)\n{\n\treturn !strcmp(dso->short_name, DSO__NAME_VDSO) ||\n\t       !strcmp(dso->short_name, DSO__NAME_VDSO32) ||\n\t       !strcmp(dso->short_name, DSO__NAME_VDSOX32);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}