{
  "module_name": "probe-file.c",
  "hash_id": "a3172d3d3ba11ed3bce58a97006bf1dcfe1028e92142e56e7a8ca1188b682803",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/probe-file.c",
  "human_readable_source": "\n \n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include <linux/zalloc.h>\n#include \"namespaces.h\"\n#include \"event.h\"\n#include \"strlist.h\"\n#include \"strfilter.h\"\n#include \"debug.h\"\n#include \"build-id.h\"\n#include \"dso.h\"\n#include \"color.h\"\n#include \"symbol.h\"\n#include \"strbuf.h\"\n#include <api/fs/tracing_path.h>\n#include <api/fs/fs.h>\n#include \"probe-event.h\"\n#include \"probe-file.h\"\n#include \"session.h\"\n#include \"perf_regs.h\"\n#include \"string2.h\"\n\n \n#define MAX_CMDLEN 4094\n\nstatic bool print_common_warning(int err, bool readwrite)\n{\n\tif (err == -EACCES)\n\t\tpr_warning(\"No permission to %s tracefs.\\nPlease %s\\n\",\n\t\t\t   readwrite ? \"write\" : \"read\",\n\t\t\t   readwrite ? \"run this command again with sudo.\" :\n\t\t\t\t       \"try 'sudo mount -o remount,mode=755 /sys/kernel/tracing/'\");\n\telse\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool print_configure_probe_event(int kerr, int uerr)\n{\n\tconst char *config, *file;\n\n\tif (kerr == -ENOENT && uerr == -ENOENT) {\n\t\tfile = \"{k,u}probe_events\";\n\t\tconfig = \"CONFIG_KPROBE_EVENTS=y and CONFIG_UPROBE_EVENTS=y\";\n\t} else if (kerr == -ENOENT) {\n\t\tfile = \"kprobe_events\";\n\t\tconfig = \"CONFIG_KPROBE_EVENTS=y\";\n\t} else if (uerr == -ENOENT) {\n\t\tfile = \"uprobe_events\";\n\t\tconfig = \"CONFIG_UPROBE_EVENTS=y\";\n\t} else\n\t\treturn false;\n\n\tif (!debugfs__configured() && !tracefs__configured())\n\t\tpr_warning(\"Debugfs or tracefs is not mounted\\n\"\n\t\t\t   \"Please try 'sudo mount -t tracefs nodev /sys/kernel/tracing/'\\n\");\n\telse\n\t\tpr_warning(\"%s/%s does not exist.\\nPlease rebuild kernel with %s.\\n\",\n\t\t\t   tracing_path_mount(), file, config);\n\n\treturn true;\n}\n\nstatic void print_open_warning(int err, bool uprobe, bool readwrite)\n{\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tif (print_common_warning(err, readwrite))\n\t\treturn;\n\n\tif (print_configure_probe_event(uprobe ? 0 : err, uprobe ? err : 0))\n\t\treturn;\n\n\tpr_warning(\"Failed to open %s/%cprobe_events: %s\\n\",\n\t\t   tracing_path_mount(), uprobe ? 'u' : 'k',\n\t\t   str_error_r(-err, sbuf, sizeof(sbuf)));\n}\n\nstatic void print_both_open_warning(int kerr, int uerr, bool readwrite)\n{\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tif (kerr == uerr && print_common_warning(kerr, readwrite))\n\t\treturn;\n\n\tif (print_configure_probe_event(kerr, uerr))\n\t\treturn;\n\n\tif (kerr < 0)\n\t\tpr_warning(\"Failed to open %s/kprobe_events: %s.\\n\",\n\t\t\t   tracing_path_mount(),\n\t\t\t   str_error_r(-kerr, sbuf, sizeof(sbuf)));\n\tif (uerr < 0)\n\t\tpr_warning(\"Failed to open %s/uprobe_events: %s.\\n\",\n\t\t\t   tracing_path_mount(),\n\t\t\t   str_error_r(-uerr, sbuf, sizeof(sbuf)));\n}\n\nint open_trace_file(const char *trace_file, bool readwrite)\n{\n\tchar buf[PATH_MAX];\n\tint ret;\n\n\tret = e_snprintf(buf, PATH_MAX, \"%s/%s\", tracing_path_mount(), trace_file);\n\tif (ret >= 0) {\n\t\tpr_debug(\"Opening %s write=%d\\n\", buf, readwrite);\n\t\tif (readwrite && !probe_event_dry_run)\n\t\t\tret = open(buf, O_RDWR | O_APPEND, 0);\n\t\telse\n\t\t\tret = open(buf, O_RDONLY, 0);\n\n\t\tif (ret < 0)\n\t\t\tret = -errno;\n\t}\n\treturn ret;\n}\n\nstatic int open_kprobe_events(bool readwrite)\n{\n\treturn open_trace_file(\"kprobe_events\", readwrite);\n}\n\nstatic int open_uprobe_events(bool readwrite)\n{\n\treturn open_trace_file(\"uprobe_events\", readwrite);\n}\n\nint probe_file__open(int flag)\n{\n\tint fd;\n\n\tif (flag & PF_FL_UPROBE)\n\t\tfd = open_uprobe_events(flag & PF_FL_RW);\n\telse\n\t\tfd = open_kprobe_events(flag & PF_FL_RW);\n\tif (fd < 0)\n\t\tprint_open_warning(fd, flag & PF_FL_UPROBE, flag & PF_FL_RW);\n\n\treturn fd;\n}\n\nint probe_file__open_both(int *kfd, int *ufd, int flag)\n{\n\tif (!kfd || !ufd)\n\t\treturn -EINVAL;\n\n\t*kfd = open_kprobe_events(flag & PF_FL_RW);\n\t*ufd = open_uprobe_events(flag & PF_FL_RW);\n\tif (*kfd < 0 && *ufd < 0) {\n\t\tprint_both_open_warning(*kfd, *ufd, flag & PF_FL_RW);\n\t\treturn *kfd;\n\t}\n\n\treturn 0;\n}\n\n \nstruct strlist *probe_file__get_rawlist(int fd)\n{\n\tint ret, idx, fddup;\n\tFILE *fp;\n\tchar buf[MAX_CMDLEN];\n\tchar *p;\n\tstruct strlist *sl;\n\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tsl = strlist__new(NULL, NULL);\n\tif (sl == NULL)\n\t\treturn NULL;\n\n\tfddup = dup(fd);\n\tif (fddup < 0)\n\t\tgoto out_free_sl;\n\n\tfp = fdopen(fddup, \"r\");\n\tif (!fp)\n\t\tgoto out_close_fddup;\n\n\twhile (!feof(fp)) {\n\t\tp = fgets(buf, MAX_CMDLEN, fp);\n\t\tif (!p)\n\t\t\tbreak;\n\n\t\tidx = strlen(p) - 1;\n\t\tif (p[idx] == '\\n')\n\t\t\tp[idx] = '\\0';\n\t\tret = strlist__add(sl, buf);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"strlist__add failed (%d)\\n\", ret);\n\t\t\tgoto out_close_fp;\n\t\t}\n\t}\n\tfclose(fp);\n\n\treturn sl;\n\nout_close_fp:\n\tfclose(fp);\n\tgoto out_free_sl;\nout_close_fddup:\n\tclose(fddup);\nout_free_sl:\n\tstrlist__delete(sl);\n\treturn NULL;\n}\n\nstatic struct strlist *__probe_file__get_namelist(int fd, bool include_group)\n{\n\tchar buf[128];\n\tstruct strlist *sl, *rawlist;\n\tstruct str_node *ent;\n\tstruct probe_trace_event tev;\n\tint ret = 0;\n\n\tmemset(&tev, 0, sizeof(tev));\n\trawlist = probe_file__get_rawlist(fd);\n\tif (!rawlist)\n\t\treturn NULL;\n\tsl = strlist__new(NULL, NULL);\n\tstrlist__for_each_entry(ent, rawlist) {\n\t\tret = parse_probe_trace_command(ent->s, &tev);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (include_group) {\n\t\t\tret = e_snprintf(buf, 128, \"%s:%s\", tev.group,\n\t\t\t\t\ttev.event);\n\t\t\tif (ret >= 0)\n\t\t\t\tret = strlist__add(sl, buf);\n\t\t} else\n\t\t\tret = strlist__add(sl, tev.event);\n\t\tclear_probe_trace_event(&tev);\n\t\t \n\t\tif (ret == -EEXIST)\n\t\t\tret = 0;\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tstrlist__delete(rawlist);\n\n\tif (ret < 0) {\n\t\tstrlist__delete(sl);\n\t\treturn NULL;\n\t}\n\treturn sl;\n}\n\n \nstruct strlist *probe_file__get_namelist(int fd)\n{\n\treturn __probe_file__get_namelist(fd, false);\n}\n\nint probe_file__add_event(int fd, struct probe_trace_event *tev)\n{\n\tint ret = 0;\n\tchar *buf = synthesize_probe_trace_command(tev);\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tif (!buf) {\n\t\tpr_debug(\"Failed to synthesize probe trace event.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"Writing event: %s\\n\", buf);\n\tif (!probe_event_dry_run) {\n\t\tif (write(fd, buf, strlen(buf)) < (int)strlen(buf)) {\n\t\t\tret = -errno;\n\t\t\tpr_warning(\"Failed to write event: %s\\n\",\n\t\t\t\t   str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\t}\n\t}\n\tfree(buf);\n\n\treturn ret;\n}\n\nstatic int __del_trace_probe_event(int fd, struct str_node *ent)\n{\n\tchar *p;\n\tchar buf[128];\n\tint ret;\n\n\t \n\tret = e_snprintf(buf, 128, \"-:%s\", ent->s);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tp = strchr(buf + 2, ':');\n\tif (!p) {\n\t\tpr_debug(\"Internal error: %s should have ':' but not.\\n\",\n\t\t\t ent->s);\n\t\tret = -ENOTSUP;\n\t\tgoto error;\n\t}\n\t*p = '/';\n\n\tpr_debug(\"Writing event: %s\\n\", buf);\n\tret = write(fd, buf, strlen(buf));\n\tif (ret < 0) {\n\t\tret = -errno;\n\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tpr_warning(\"Failed to delete event: %s\\n\",\n\t\t   str_error_r(-ret, buf, sizeof(buf)));\n\treturn ret;\n}\n\nint probe_file__get_events(int fd, struct strfilter *filter,\n\t\t\t   struct strlist *plist)\n{\n\tstruct strlist *namelist;\n\tstruct str_node *ent;\n\tconst char *p;\n\tint ret = -ENOENT;\n\n\tif (!plist)\n\t\treturn -EINVAL;\n\n\tnamelist = __probe_file__get_namelist(fd, true);\n\tif (!namelist)\n\t\treturn -ENOENT;\n\n\tstrlist__for_each_entry(ent, namelist) {\n\t\tp = strchr(ent->s, ':');\n\t\tif ((p && strfilter__compare(filter, p + 1)) ||\n\t\t    strfilter__compare(filter, ent->s)) {\n\t\t\tret = strlist__add(plist, ent->s);\n\t\t\tif (ret == -ENOMEM) {\n\t\t\t\tpr_err(\"strlist__add failed with -ENOMEM\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = 0;\n\t\t}\n\t}\nout:\n\tstrlist__delete(namelist);\n\n\treturn ret;\n}\n\nint probe_file__del_strlist(int fd, struct strlist *namelist)\n{\n\tint ret = 0;\n\tstruct str_node *ent;\n\n\tstrlist__for_each_entry(ent, namelist) {\n\t\tret = __del_trace_probe_event(fd, ent);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint probe_file__del_events(int fd, struct strfilter *filter)\n{\n\tstruct strlist *namelist;\n\tint ret;\n\n\tnamelist = strlist__new(NULL, NULL);\n\tif (!namelist)\n\t\treturn -ENOMEM;\n\n\tret = probe_file__get_events(fd, filter, namelist);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = probe_file__del_strlist(fd, namelist);\nout:\n\tstrlist__delete(namelist);\n\treturn ret;\n}\n\n \nstatic void probe_cache_entry__delete(struct probe_cache_entry *entry)\n{\n\tif (entry) {\n\t\tBUG_ON(!list_empty(&entry->node));\n\n\t\tstrlist__delete(entry->tevlist);\n\t\tclear_perf_probe_event(&entry->pev);\n\t\tzfree(&entry->spev);\n\t\tfree(entry);\n\t}\n}\n\nstatic struct probe_cache_entry *\nprobe_cache_entry__new(struct perf_probe_event *pev)\n{\n\tstruct probe_cache_entry *entry = zalloc(sizeof(*entry));\n\n\tif (entry) {\n\t\tINIT_LIST_HEAD(&entry->node);\n\t\tentry->tevlist = strlist__new(NULL, NULL);\n\t\tif (!entry->tevlist)\n\t\t\tzfree(&entry);\n\t\telse if (pev) {\n\t\t\tentry->spev = synthesize_perf_probe_command(pev);\n\t\t\tif (!entry->spev ||\n\t\t\t    perf_probe_event__copy(&entry->pev, pev) < 0) {\n\t\t\t\tprobe_cache_entry__delete(entry);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn entry;\n}\n\nint probe_cache_entry__get_event(struct probe_cache_entry *entry,\n\t\t\t\t struct probe_trace_event **tevs)\n{\n\tstruct probe_trace_event *tev;\n\tstruct str_node *node;\n\tint ret, i;\n\n\tret = strlist__nr_entries(entry->tevlist);\n\tif (ret > probe_conf.max_probes)\n\t\treturn -E2BIG;\n\n\t*tevs = zalloc(ret * sizeof(*tev));\n\tif (!*tevs)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tstrlist__for_each_entry(node, entry->tevlist) {\n\t\ttev = &(*tevs)[i++];\n\t\tret = parse_probe_trace_command(node->s, tev);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\n \nstatic int probe_cache__open(struct probe_cache *pcache, const char *target,\n\t\t\t     struct nsinfo *nsi)\n{\n\tchar cpath[PATH_MAX];\n\tchar sbuildid[SBUILD_ID_SIZE];\n\tchar *dir_name = NULL;\n\tbool is_kallsyms = false;\n\tint ret, fd;\n\tstruct nscookie nsc;\n\n\tif (target && build_id_cache__cached(target)) {\n\t\t \n\t\tstrlcpy(sbuildid, target, SBUILD_ID_SIZE);\n\t\tdir_name = build_id_cache__linkname(sbuildid, NULL, 0);\n\t\tgoto found;\n\t}\n\n\tif (!target || !strcmp(target, DSO__NAME_KALLSYMS)) {\n\t\ttarget = DSO__NAME_KALLSYMS;\n\t\tis_kallsyms = true;\n\t\tret = sysfs__sprintf_build_id(\"/\", sbuildid);\n\t} else {\n\t\tnsinfo__mountns_enter(nsi, &nsc);\n\t\tret = filename__sprintf_build_id(target, sbuildid);\n\t\tnsinfo__mountns_exit(&nsc);\n\t}\n\n\tif (ret < 0) {\n\t\tpr_debug(\"Failed to get build-id from %s.\\n\", target);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!build_id_cache__cached(sbuildid)) {\n\t\tret = build_id_cache__add_s(sbuildid, target, nsi,\n\t\t\t\t\t    is_kallsyms, NULL);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"Failed to add build-id cache: %s\\n\", target);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdir_name = build_id_cache__cachedir(sbuildid, target, nsi, is_kallsyms,\n\t\t\t\t\t    false);\nfound:\n\tif (!dir_name) {\n\t\tpr_debug(\"Failed to get cache from %s\\n\", target);\n\t\treturn -ENOMEM;\n\t}\n\n\tsnprintf(cpath, PATH_MAX, \"%s/probes\", dir_name);\n\tfd = open(cpath, O_CREAT | O_RDWR, 0644);\n\tif (fd < 0)\n\t\tpr_debug(\"Failed to open cache(%d): %s\\n\", fd, cpath);\n\tfree(dir_name);\n\tpcache->fd = fd;\n\n\treturn fd;\n}\n\nstatic int probe_cache__load(struct probe_cache *pcache)\n{\n\tstruct probe_cache_entry *entry = NULL;\n\tchar buf[MAX_CMDLEN], *p;\n\tint ret = 0, fddup;\n\tFILE *fp;\n\n\tfddup = dup(pcache->fd);\n\tif (fddup < 0)\n\t\treturn -errno;\n\tfp = fdopen(fddup, \"r\");\n\tif (!fp) {\n\t\tclose(fddup);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (!feof(fp)) {\n\t\tif (!fgets(buf, MAX_CMDLEN, fp))\n\t\t\tbreak;\n\t\tp = strchr(buf, '\\n');\n\t\tif (p)\n\t\t\t*p = '\\0';\n\t\t \n\t\tif (buf[0] == '#' || buf[0] == '%') {\n\t\t\tentry = probe_cache_entry__new(NULL);\n\t\t\tif (!entry) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (buf[0] == '%')\n\t\t\t\tentry->sdt = true;\n\t\t\tentry->spev = strdup(buf + 1);\n\t\t\tif (entry->spev)\n\t\t\t\tret = parse_perf_probe_command(buf + 1,\n\t\t\t\t\t\t\t\t&entry->pev);\n\t\t\telse\n\t\t\t\tret = -ENOMEM;\n\t\t\tif (ret < 0) {\n\t\t\t\tprobe_cache_entry__delete(entry);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlist_add_tail(&entry->node, &pcache->entries);\n\t\t} else {\t \n\t\t\tif (!entry) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = strlist__add(entry->tevlist, buf);\n\t\t\tif (ret == -ENOMEM) {\n\t\t\t\tpr_err(\"strlist__add failed with -ENOMEM\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tfclose(fp);\n\treturn ret;\n}\n\nstatic struct probe_cache *probe_cache__alloc(void)\n{\n\tstruct probe_cache *pcache = zalloc(sizeof(*pcache));\n\n\tif (pcache) {\n\t\tINIT_LIST_HEAD(&pcache->entries);\n\t\tpcache->fd = -EINVAL;\n\t}\n\treturn pcache;\n}\n\nvoid probe_cache__purge(struct probe_cache *pcache)\n{\n\tstruct probe_cache_entry *entry, *n;\n\n\tlist_for_each_entry_safe(entry, n, &pcache->entries, node) {\n\t\tlist_del_init(&entry->node);\n\t\tprobe_cache_entry__delete(entry);\n\t}\n}\n\nvoid probe_cache__delete(struct probe_cache *pcache)\n{\n\tif (!pcache)\n\t\treturn;\n\n\tprobe_cache__purge(pcache);\n\tif (pcache->fd > 0)\n\t\tclose(pcache->fd);\n\tfree(pcache);\n}\n\nstruct probe_cache *probe_cache__new(const char *target, struct nsinfo *nsi)\n{\n\tstruct probe_cache *pcache = probe_cache__alloc();\n\tint ret;\n\n\tif (!pcache)\n\t\treturn NULL;\n\n\tret = probe_cache__open(pcache, target, nsi);\n\tif (ret < 0) {\n\t\tpr_debug(\"Cache open error: %d\\n\", ret);\n\t\tgoto out_err;\n\t}\n\n\tret = probe_cache__load(pcache);\n\tif (ret < 0) {\n\t\tpr_debug(\"Cache read error: %d\\n\", ret);\n\t\tgoto out_err;\n\t}\n\n\treturn pcache;\n\nout_err:\n\tprobe_cache__delete(pcache);\n\treturn NULL;\n}\n\nstatic bool streql(const char *a, const char *b)\n{\n\tif (a == b)\n\t\treturn true;\n\n\tif (!a || !b)\n\t\treturn false;\n\n\treturn !strcmp(a, b);\n}\n\nstruct probe_cache_entry *\nprobe_cache__find(struct probe_cache *pcache, struct perf_probe_event *pev)\n{\n\tstruct probe_cache_entry *entry = NULL;\n\tchar *cmd = synthesize_perf_probe_command(pev);\n\n\tif (!cmd)\n\t\treturn NULL;\n\n\tfor_each_probe_cache_entry(entry, pcache) {\n\t\tif (pev->sdt) {\n\t\t\tif (entry->pev.event &&\n\t\t\t    streql(entry->pev.event, pev->event) &&\n\t\t\t    (!pev->group ||\n\t\t\t     streql(entry->pev.group, pev->group)))\n\t\t\t\tgoto found;\n\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif ((pev->event &&\n\t\t     (streql(entry->pev.group, pev->group) &&\n\t\t      streql(entry->pev.event, pev->event))) ||\n\t\t    (!strcmp(entry->spev, cmd)))\n\t\t\tgoto found;\n\t}\n\tentry = NULL;\n\nfound:\n\tfree(cmd);\n\treturn entry;\n}\n\nstruct probe_cache_entry *\nprobe_cache__find_by_name(struct probe_cache *pcache,\n\t\t\t  const char *group, const char *event)\n{\n\tstruct probe_cache_entry *entry = NULL;\n\n\tfor_each_probe_cache_entry(entry, pcache) {\n\t\t \n\t\tif (streql(entry->pev.group, group) &&\n\t\t    streql(entry->pev.event, event))\n\t\t\tgoto found;\n\t}\n\tentry = NULL;\n\nfound:\n\treturn entry;\n}\n\nint probe_cache__add_entry(struct probe_cache *pcache,\n\t\t\t   struct perf_probe_event *pev,\n\t\t\t   struct probe_trace_event *tevs, int ntevs)\n{\n\tstruct probe_cache_entry *entry = NULL;\n\tchar *command;\n\tint i, ret = 0;\n\n\tif (!pcache || !pev || !tevs || ntevs <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\t \n\tentry = probe_cache__find(pcache, pev);\n\tif (entry) {\n\t\tlist_del_init(&entry->node);\n\t\tprobe_cache_entry__delete(entry);\n\t}\n\n\tret = -ENOMEM;\n\tentry = probe_cache_entry__new(pev);\n\tif (!entry)\n\t\tgoto out_err;\n\n\tfor (i = 0; i < ntevs; i++) {\n\t\tif (!tevs[i].point.symbol)\n\t\t\tcontinue;\n\n\t\tcommand = synthesize_probe_trace_command(&tevs[i]);\n\t\tif (!command)\n\t\t\tgoto out_err;\n\t\tret = strlist__add(entry->tevlist, command);\n\t\tif (ret == -ENOMEM) {\n\t\t\tpr_err(\"strlist__add failed with -ENOMEM\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tfree(command);\n\t}\n\tlist_add_tail(&entry->node, &pcache->entries);\n\tpr_debug(\"Added probe cache: %d\\n\", ntevs);\n\treturn 0;\n\nout_err:\n\tpr_debug(\"Failed to add probe caches\\n\");\n\tprobe_cache_entry__delete(entry);\n\treturn ret;\n}\n\n#ifdef HAVE_GELF_GETNOTE_SUPPORT\nstatic unsigned long long sdt_note__get_addr(struct sdt_note *note)\n{\n\treturn note->bit32 ?\n\t\t(unsigned long long)note->addr.a32[SDT_NOTE_IDX_LOC] :\n\t\t(unsigned long long)note->addr.a64[SDT_NOTE_IDX_LOC];\n}\n\nstatic unsigned long long sdt_note__get_ref_ctr_offset(struct sdt_note *note)\n{\n\treturn note->bit32 ?\n\t\t(unsigned long long)note->addr.a32[SDT_NOTE_IDX_REFCTR] :\n\t\t(unsigned long long)note->addr.a64[SDT_NOTE_IDX_REFCTR];\n}\n\nstatic const char * const type_to_suffix[] = {\n\t\":s64\", \"\", \"\", \"\", \":s32\", \"\", \":s16\", \":s8\",\n\t\"\", \":u8\", \":u16\", \"\", \":u32\", \"\", \"\", \"\", \":u64\"\n};\n\n \nstatic int sdt_arg_parse_size(char *n_ptr, const char **suffix)\n{\n\tlong type_idx;\n\n\ttype_idx = strtol(n_ptr, NULL, 10);\n\tif (type_idx < -8 || type_idx > 8) {\n\t\tpr_debug4(\"Failed to get a valid sdt type\\n\");\n\t\treturn -1;\n\t}\n\n\t*suffix = type_to_suffix[type_idx + 8];\n\treturn 0;\n}\n\nstatic int synthesize_sdt_probe_arg(struct strbuf *buf, int i, const char *arg)\n{\n\tchar *op, *desc = strdup(arg), *new_op = NULL;\n\tconst char *suffix = \"\";\n\tint ret = -1;\n\n\tif (desc == NULL) {\n\t\tpr_debug4(\"Allocation error\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\top = strchr(desc, '@');\n\tif (op) {\n\t\top[0] = '\\0';\n\t\top++;\n\n\t\tif (sdt_arg_parse_size(desc, &suffix))\n\t\t\tgoto error;\n\t} else {\n\t\top = desc;\n\t}\n\n\tret = arch_sdt_arg_parse_op(op, &new_op);\n\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (ret == SDT_ARG_VALID) {\n\t\tret = strbuf_addf(buf, \" arg%d=%s%s\", i + 1, new_op, suffix);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tret = 0;\nerror:\n\tfree(desc);\n\tfree(new_op);\n\treturn ret;\n}\n\nstatic char *synthesize_sdt_probe_command(struct sdt_note *note,\n\t\t\t\t\tconst char *pathname,\n\t\t\t\t\tconst char *sdtgrp)\n{\n\tstruct strbuf buf;\n\tchar *ret = NULL;\n\tint i, args_count, err;\n\tunsigned long long ref_ctr_offset;\n\tchar *arg;\n\tint arg_idx = 0;\n\n\tif (strbuf_init(&buf, 32) < 0)\n\t\treturn NULL;\n\n\terr = strbuf_addf(&buf, \"p:%s/%s %s:0x%llx\",\n\t\t\tsdtgrp, note->name, pathname,\n\t\t\tsdt_note__get_addr(note));\n\n\tref_ctr_offset = sdt_note__get_ref_ctr_offset(note);\n\tif (ref_ctr_offset && err >= 0)\n\t\terr = strbuf_addf(&buf, \"(0x%llx)\", ref_ctr_offset);\n\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (!note->args)\n\t\tgoto out;\n\n\tif (note->args) {\n\t\tchar **args = argv_split(note->args, &args_count);\n\n\t\tif (args == NULL)\n\t\t\tgoto error;\n\n\t\tfor (i = 0; i < args_count; ) {\n\t\t\t \n\t\t\tif (strstr(args[i], \"[sp,\") && (i+1) < args_count) {\n\t\t\t\terr = asprintf(&arg, \"%s %s\", args[i], args[i+1]);\n\t\t\t\ti += 2;\n\t\t\t} else {\n\t\t\t\terr = asprintf(&arg, \"%s\", args[i]);\n\t\t\t\ti += 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (err < 0) {\n\t\t\t\targv_free(args);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (synthesize_sdt_probe_arg(&buf, arg_idx, arg) < 0) {\n\t\t\t\tfree(arg);\n\t\t\t\targv_free(args);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tfree(arg);\n\t\t\targ_idx++;\n\t\t}\n\n\t\targv_free(args);\n\t}\n\nout:\n\tret = strbuf_detach(&buf, NULL);\nerror:\n\tstrbuf_release(&buf);\n\treturn ret;\n}\n\nint probe_cache__scan_sdt(struct probe_cache *pcache, const char *pathname)\n{\n\tstruct probe_cache_entry *entry = NULL;\n\tstruct list_head sdtlist;\n\tstruct sdt_note *note;\n\tchar *buf;\n\tchar sdtgrp[64];\n\tint ret;\n\n\tINIT_LIST_HEAD(&sdtlist);\n\tret = get_sdt_note_list(&sdtlist, pathname);\n\tif (ret < 0) {\n\t\tpr_debug4(\"Failed to get sdt note: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tlist_for_each_entry(note, &sdtlist, note_list) {\n\t\tret = snprintf(sdtgrp, 64, \"sdt_%s\", note->provider);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\t \n\t\tentry = probe_cache__find_by_name(pcache, sdtgrp, note->name);\n\t\tif (!entry) {\n\t\t\tentry = probe_cache_entry__new(NULL);\n\t\t\tif (!entry) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry->sdt = true;\n\t\t\tret = asprintf(&entry->spev, \"%s:%s=%s\", sdtgrp,\n\t\t\t\t\tnote->name, note->name);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tentry->pev.event = strdup(note->name);\n\t\t\tentry->pev.group = strdup(sdtgrp);\n\t\t\tlist_add_tail(&entry->node, &pcache->entries);\n\t\t}\n\t\tbuf = synthesize_sdt_probe_command(note, pathname, sdtgrp);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = strlist__add(entry->tevlist, buf);\n\n\t\tfree(buf);\n\t\tentry = NULL;\n\n\t\tif (ret == -ENOMEM) {\n\t\t\tpr_err(\"strlist__add failed with -ENOMEM\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (entry) {\n\t\tlist_del_init(&entry->node);\n\t\tprobe_cache_entry__delete(entry);\n\t}\n\tcleanup_sdt_note_list(&sdtlist);\n\treturn ret;\n}\n#endif\n\nstatic int probe_cache_entry__write(struct probe_cache_entry *entry, int fd)\n{\n\tstruct str_node *snode;\n\tstruct stat st;\n\tstruct iovec iov[3];\n\tconst char *prefix = entry->sdt ? \"%\" : \"#\";\n\tint ret;\n\t \n\tret = fstat(fd, &st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpr_debug(\"Writing cache: %s%s\\n\", prefix, entry->spev);\n\tiov[0].iov_base = (void *)prefix; iov[0].iov_len = 1;\n\tiov[1].iov_base = entry->spev; iov[1].iov_len = strlen(entry->spev);\n\tiov[2].iov_base = (void *)\"\\n\"; iov[2].iov_len = 1;\n\tret = writev(fd, iov, 3);\n\tif (ret < (int)iov[1].iov_len + 2)\n\t\tgoto rollback;\n\n\tstrlist__for_each_entry(snode, entry->tevlist) {\n\t\tiov[0].iov_base = (void *)snode->s;\n\t\tiov[0].iov_len = strlen(snode->s);\n\t\tiov[1].iov_base = (void *)\"\\n\"; iov[1].iov_len = 1;\n\t\tret = writev(fd, iov, 2);\n\t\tif (ret < (int)iov[0].iov_len + 1)\n\t\t\tgoto rollback;\n\t}\n\treturn 0;\n\nrollback:\n\t \n\tif (ret > 0)\n\t\tret = -1;\n\tif (ftruncate(fd, st.st_size) < 0)\n\t\tret = -2;\n\n\treturn ret;\n}\n\nint probe_cache__commit(struct probe_cache *pcache)\n{\n\tstruct probe_cache_entry *entry;\n\tint ret = 0;\n\n\t \n\tret = lseek(pcache->fd, 0, SEEK_SET);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = ftruncate(pcache->fd, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor_each_probe_cache_entry(entry, pcache) {\n\t\tret = probe_cache_entry__write(entry, pcache->fd);\n\t\tpr_debug(\"Cache committed: %d\\n\", ret);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\nstatic bool probe_cache_entry__compare(struct probe_cache_entry *entry,\n\t\t\t\t       struct strfilter *filter)\n{\n\tchar buf[128], *ptr = entry->spev;\n\n\tif (entry->pev.event) {\n\t\tsnprintf(buf, 128, \"%s:%s\", entry->pev.group, entry->pev.event);\n\t\tptr = buf;\n\t}\n\treturn strfilter__compare(filter, ptr);\n}\n\nint probe_cache__filter_purge(struct probe_cache *pcache,\n\t\t\t      struct strfilter *filter)\n{\n\tstruct probe_cache_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &pcache->entries, node) {\n\t\tif (probe_cache_entry__compare(entry, filter)) {\n\t\t\tpr_info(\"Removed cached event: %s\\n\", entry->spev);\n\t\t\tlist_del_init(&entry->node);\n\t\t\tprobe_cache_entry__delete(entry);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int probe_cache__show_entries(struct probe_cache *pcache,\n\t\t\t\t     struct strfilter *filter)\n{\n\tstruct probe_cache_entry *entry;\n\n\tfor_each_probe_cache_entry(entry, pcache) {\n\t\tif (probe_cache_entry__compare(entry, filter))\n\t\t\tprintf(\"%s\\n\", entry->spev);\n\t}\n\treturn 0;\n}\n\n \nint probe_cache__show_all_caches(struct strfilter *filter)\n{\n\tstruct probe_cache *pcache;\n\tstruct strlist *bidlist;\n\tstruct str_node *nd;\n\tchar *buf = strfilter__string(filter);\n\n\tpr_debug(\"list cache with filter: %s\\n\", buf);\n\tfree(buf);\n\n\tbidlist = build_id_cache__list_all(true);\n\tif (!bidlist) {\n\t\tpr_debug(\"Failed to get buildids: %d\\n\", errno);\n\t\treturn -EINVAL;\n\t}\n\tstrlist__for_each_entry(nd, bidlist) {\n\t\tpcache = probe_cache__new(nd->s, NULL);\n\t\tif (!pcache)\n\t\t\tcontinue;\n\t\tif (!list_empty(&pcache->entries)) {\n\t\t\tbuf = build_id_cache__origname(nd->s);\n\t\t\tprintf(\"%s (%s):\\n\", buf, nd->s);\n\t\t\tfree(buf);\n\t\t\tprobe_cache__show_entries(pcache, filter);\n\t\t}\n\t\tprobe_cache__delete(pcache);\n\t}\n\tstrlist__delete(bidlist);\n\n\treturn 0;\n}\n\nenum ftrace_readme {\n\tFTRACE_README_PROBE_TYPE_X = 0,\n\tFTRACE_README_KRETPROBE_OFFSET,\n\tFTRACE_README_UPROBE_REF_CTR,\n\tFTRACE_README_USER_ACCESS,\n\tFTRACE_README_MULTIPROBE_EVENT,\n\tFTRACE_README_IMMEDIATE_VALUE,\n\tFTRACE_README_END,\n};\n\nstatic struct {\n\tconst char *pattern;\n\tbool avail;\n} ftrace_readme_table[] = {\n#define DEFINE_TYPE(idx, pat)\t\t\t\\\n\t[idx] = {.pattern = pat, .avail = false}\n\tDEFINE_TYPE(FTRACE_README_PROBE_TYPE_X, \"*type: * x8/16/32/64,*\"),\n\tDEFINE_TYPE(FTRACE_README_KRETPROBE_OFFSET, \"*place (kretprobe): *\"),\n\tDEFINE_TYPE(FTRACE_README_UPROBE_REF_CTR, \"*ref_ctr_offset*\"),\n\tDEFINE_TYPE(FTRACE_README_USER_ACCESS, \"*u]<offset>*\"),\n\tDEFINE_TYPE(FTRACE_README_MULTIPROBE_EVENT, \"*Create/append/*\"),\n\tDEFINE_TYPE(FTRACE_README_IMMEDIATE_VALUE, \"*\\\\imm-value,*\"),\n};\n\nstatic bool scan_ftrace_readme(enum ftrace_readme type)\n{\n\tint fd;\n\tFILE *fp;\n\tchar *buf = NULL;\n\tsize_t len = 0;\n\tbool ret = false;\n\tstatic bool scanned = false;\n\n\tif (scanned)\n\t\tgoto result;\n\n\tfd = open_trace_file(\"README\", false);\n\tif (fd < 0)\n\t\treturn ret;\n\n\tfp = fdopen(fd, \"r\");\n\tif (!fp) {\n\t\tclose(fd);\n\t\treturn ret;\n\t}\n\n\twhile (getline(&buf, &len, fp) > 0)\n\t\tfor (enum ftrace_readme i = 0; i < FTRACE_README_END; i++)\n\t\t\tif (!ftrace_readme_table[i].avail)\n\t\t\t\tftrace_readme_table[i].avail =\n\t\t\t\t\tstrglobmatch(buf, ftrace_readme_table[i].pattern);\n\tscanned = true;\n\n\tfclose(fp);\n\tfree(buf);\n\nresult:\n\tif (type >= FTRACE_README_END)\n\t\treturn false;\n\n\treturn ftrace_readme_table[type].avail;\n}\n\nbool probe_type_is_available(enum probe_type type)\n{\n\tif (type >= PROBE_TYPE_END)\n\t\treturn false;\n\telse if (type == PROBE_TYPE_X)\n\t\treturn scan_ftrace_readme(FTRACE_README_PROBE_TYPE_X);\n\n\treturn true;\n}\n\nbool kretprobe_offset_is_supported(void)\n{\n\treturn scan_ftrace_readme(FTRACE_README_KRETPROBE_OFFSET);\n}\n\nbool uprobe_ref_ctr_is_supported(void)\n{\n\treturn scan_ftrace_readme(FTRACE_README_UPROBE_REF_CTR);\n}\n\nbool user_access_is_supported(void)\n{\n\treturn scan_ftrace_readme(FTRACE_README_USER_ACCESS);\n}\n\nbool multiprobe_event_is_supported(void)\n{\n\treturn scan_ftrace_readme(FTRACE_README_MULTIPROBE_EVENT);\n}\n\nbool immediate_value_is_supported(void)\n{\n\treturn scan_ftrace_readme(FTRACE_README_IMMEDIATE_VALUE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}