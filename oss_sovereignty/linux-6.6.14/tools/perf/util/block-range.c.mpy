{
  "module_name": "block-range.c",
  "hash_id": "cdb1fe154f478a3a69ffca3f38d77be5f05e72d6e45c34bf12e671a50a432828",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/block-range.c",
  "human_readable_source": "\n#include \"block-range.h\"\n#include \"annotate.h\"\n#include <assert.h>\n#include <stdlib.h>\n\nstruct {\n\tstruct rb_root root;\n\tu64 blocks;\n} block_ranges;\n\nstatic void block_range__debug(void)\n{\n#ifndef NDEBUG\n\tstruct rb_node *rb;\n\tu64 old = 0;  \n\n\tfor (rb = rb_first(&block_ranges.root); rb; rb = rb_next(rb)) {\n\t\tstruct block_range *entry = rb_entry(rb, struct block_range, node);\n\n\t\tassert(old < entry->start);\n\t\tassert(entry->start <= entry->end);  \n\n\t\told = entry->end;\n\t}\n#endif\n}\n\nstruct block_range *block_range__find(u64 addr)\n{\n\tstruct rb_node **p = &block_ranges.root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct block_range *entry;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct block_range, node);\n\n\t\tif (addr < entry->start)\n\t\t\tp = &parent->rb_left;\n\t\telse if (addr > entry->end)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline void rb_link_left_of_node(struct rb_node *left, struct rb_node *node)\n{\n\tstruct rb_node **p = &node->rb_left;\n\twhile (*p) {\n\t\tnode = *p;\n\t\tp = &node->rb_right;\n\t}\n\trb_link_node(left, node, p);\n}\n\nstatic inline void rb_link_right_of_node(struct rb_node *right, struct rb_node *node)\n{\n\tstruct rb_node **p = &node->rb_right;\n\twhile (*p) {\n\t\tnode = *p;\n\t\tp = &node->rb_left;\n\t}\n\trb_link_node(right, node, p);\n}\n\n \nstruct block_range_iter block_range__create(u64 start, u64 end)\n{\n\tstruct rb_node **p = &block_ranges.root.rb_node;\n\tstruct rb_node *n, *parent = NULL;\n\tstruct block_range *next, *entry = NULL;\n\tstruct block_range_iter iter = { NULL, NULL };\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct block_range, node);\n\n\t\tif (start < entry->start)\n\t\t\tp = &parent->rb_left;\n\t\telse if (start > entry->end)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!*p) {\n\t\tif (!entry)  \n\t\t\tgoto do_whole;\n\n\t\t \n\t\tn = parent;\n\t\tif (entry->end < start) {\n\t\t\tn = rb_next(n);\n\t\t\tif (!n)\n\t\t\t\tgoto do_whole;\n\t\t}\n\t\tnext = rb_entry(n, struct block_range, node);\n\n\t\tif (next->start <= end) {  \n\t\t\tstruct block_range *head = malloc(sizeof(struct block_range));\n\t\t\tif (!head)\n\t\t\t\treturn iter;\n\n\t\t\t*head = (struct block_range){\n\t\t\t\t.start\t\t= start,\n\t\t\t\t.end\t\t= next->start - 1,\n\t\t\t\t.is_target\t= 1,\n\t\t\t\t.is_branch\t= 0,\n\t\t\t};\n\n\t\t\trb_link_left_of_node(&head->node, &next->node);\n\t\t\trb_insert_color(&head->node, &block_ranges.root);\n\t\t\tblock_range__debug();\n\n\t\t\titer.start = head;\n\t\t\tgoto do_tail;\n\t\t}\n\ndo_whole:\n\t\t \n\t\tentry = malloc(sizeof(struct block_range));\n\t\tif (!entry)\n\t\t\treturn iter;\n\n\t\t*entry = (struct block_range){\n\t\t\t.start\t\t= start,\n\t\t\t.end\t\t= end,\n\t\t\t.is_target\t= 1,\n\t\t\t.is_branch\t= 1,\n\t\t};\n\n\t\trb_link_node(&entry->node, parent, p);\n\t\trb_insert_color(&entry->node, &block_ranges.root);\n\t\tblock_range__debug();\n\n\t\titer.start = entry;\n\t\titer.end   = entry;\n\t\tgoto done;\n\t}\n\n\t \n\tif (entry->start < start) {  \n\t\tstruct block_range *head = malloc(sizeof(struct block_range));\n\t\tif (!head)\n\t\t\treturn iter;\n\n\t\t*head = (struct block_range){\n\t\t\t.start\t\t= entry->start,\n\t\t\t.end\t\t= start - 1,\n\t\t\t.is_target\t= entry->is_target,\n\t\t\t.is_branch\t= 0,\n\n\t\t\t.coverage\t= entry->coverage,\n\t\t\t.entry\t\t= entry->entry,\n\t\t};\n\n\t\tentry->start\t\t= start;\n\t\tentry->is_target\t= 1;\n\t\tentry->entry\t\t= 0;\n\n\t\trb_link_left_of_node(&head->node, &entry->node);\n\t\trb_insert_color(&head->node, &block_ranges.root);\n\t\tblock_range__debug();\n\n\t} else if (entry->start == start)\n\t\tentry->is_target = 1;\n\n\titer.start = entry;\n\ndo_tail:\n\t \n\tentry = iter.start;\n\tfor (;;) {\n\t\t \n\t\tif (end < entry->end) {  \n\t\t\tstruct block_range *tail = malloc(sizeof(struct block_range));\n\t\t\tif (!tail)\n\t\t\t\treturn iter;\n\n\t\t\t*tail = (struct block_range){\n\t\t\t\t.start\t\t= end + 1,\n\t\t\t\t.end\t\t= entry->end,\n\t\t\t\t.is_target\t= 0,\n\t\t\t\t.is_branch\t= entry->is_branch,\n\n\t\t\t\t.coverage\t= entry->coverage,\n\t\t\t\t.taken\t\t= entry->taken,\n\t\t\t\t.pred\t\t= entry->pred,\n\t\t\t};\n\n\t\t\tentry->end\t\t= end;\n\t\t\tentry->is_branch\t= 1;\n\t\t\tentry->taken\t\t= 0;\n\t\t\tentry->pred\t\t= 0;\n\n\t\t\trb_link_right_of_node(&tail->node, &entry->node);\n\t\t\trb_insert_color(&tail->node, &block_ranges.root);\n\t\t\tblock_range__debug();\n\n\t\t\titer.end = entry;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (end == entry->end) {\n\t\t\tentry->is_branch = 1;\n\t\t\titer.end = entry;\n\t\t\tgoto done;\n\t\t}\n\n\t\tnext = block_range__next(entry);\n\t\tif (!next)\n\t\t\tgoto add_tail;\n\n\t\t \n\t\tif (end < next->start) {  \n\t\t\tstruct block_range *tail;\nadd_tail:\n\t\t\ttail = malloc(sizeof(struct block_range));\n\t\t\tif (!tail)\n\t\t\t\treturn iter;\n\n\t\t\t*tail = (struct block_range){\n\t\t\t\t.start\t\t= entry->end + 1,\n\t\t\t\t.end\t\t= end,\n\t\t\t\t.is_target\t= 0,\n\t\t\t\t.is_branch\t= 1,\n\t\t\t};\n\n\t\t\trb_link_right_of_node(&tail->node, &entry->node);\n\t\t\trb_insert_color(&tail->node, &block_ranges.root);\n\t\t\tblock_range__debug();\n\n\t\t\titer.end = tail;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (entry->end + 1 != next->start) {\n\t\t\tstruct block_range *hole = malloc(sizeof(struct block_range));\n\t\t\tif (!hole)\n\t\t\t\treturn iter;\n\n\t\t\t*hole = (struct block_range){\n\t\t\t\t.start\t\t= entry->end + 1,\n\t\t\t\t.end\t\t= next->start - 1,\n\t\t\t\t.is_target\t= 0,\n\t\t\t\t.is_branch\t= 0,\n\t\t\t};\n\n\t\t\trb_link_left_of_node(&hole->node, &next->node);\n\t\t\trb_insert_color(&hole->node, &block_ranges.root);\n\t\t\tblock_range__debug();\n\t\t}\n\n\t\tentry = next;\n\t}\n\ndone:\n\tassert(iter.start->start == start && iter.start->is_target);\n\tassert(iter.end->end == end && iter.end->is_branch);\n\n\tblock_ranges.blocks++;\n\n\treturn iter;\n}\n\n\n \ndouble block_range__coverage(struct block_range *br)\n{\n\tstruct symbol *sym;\n\n\tif (!br) {\n\t\tif (block_ranges.blocks)\n\t\t\treturn 0;\n\n\t\treturn -1;\n\t}\n\n\tsym = br->sym;\n\tif (!sym)\n\t\treturn -1;\n\n\treturn (double)br->coverage / symbol__annotation(sym)->max_coverage;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}