{
  "module_name": "parse-events.l",
  "hash_id": "6ce219532767dde0c45458a95ee102b5317ef52aacf54f85522251fddd60c71a",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/parse-events.l",
  "human_readable_source": "\n%option reentrant\n%option bison-bridge\n%option prefix=\"parse_events_\"\n%option stack\n%option bison-locations\n%option yylineno\n%option reject\n\n%{\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include \"parse-events.h\"\n#include \"parse-events-bison.h\"\n#include \"evsel.h\"\n\nchar *parse_events_get_text(yyscan_t yyscanner);\nYYSTYPE *parse_events_get_lval(yyscan_t yyscanner);\n\nstatic int __value(YYSTYPE *yylval, char *str, int base, int token)\n{\n\tu64 num;\n\n\terrno = 0;\n\tnum = strtoull(str, NULL, base);\n\tif (errno)\n\t\treturn PE_ERROR;\n\n\tyylval->num = num;\n\treturn token;\n}\n\nstatic int value(yyscan_t scanner, int base)\n{\n\tYYSTYPE *yylval = parse_events_get_lval(scanner);\n\tchar *text = parse_events_get_text(scanner);\n\n\treturn __value(yylval, text, base, PE_VALUE);\n}\n\nstatic int str(yyscan_t scanner, int token)\n{\n\tYYSTYPE *yylval = parse_events_get_lval(scanner);\n\tchar *text = parse_events_get_text(scanner);\n\n\tif (text[0] != '\\'') {\n\t\tyylval->str = strdup(text);\n\t} else {\n\t\t/*\n\t\t * If a text tag specified on the command line\n\t\t * contains opening single quite ' then it is\n\t\t * expected that the tag ends with single quote\n\t\t * as well, like this:\n\t\t *     name=\\'CPU_CLK_UNHALTED.THREAD:cmask=1\\'\n\t\t * quotes need to be escaped to bypass shell\n\t\t * processing.\n\t\t */\n\t\tyylval->str = strndup(&text[1], strlen(text) - 2);\n\t}\n\n\treturn token;\n}\n\nstatic int lc_str(yyscan_t scanner, const struct parse_events_state *state)\n{\n\treturn str(scanner, state->match_legacy_cache_terms ? PE_LEGACY_CACHE : PE_NAME);\n}\n\n/*\n * This function is called when the parser gets two kind of input:\n *\n * \t@cfg1 or @cfg2=config\n *\n * The leading '@' is stripped off before 'cfg1' and 'cfg2=config' are given to\n * bison.  In the latter case it is necessary to keep the string intact so that\n * the PMU kernel driver can determine what configurable is associated to\n * 'config'.\n */\nstatic int drv_str(yyscan_t scanner, int token)\n{\n\tYYSTYPE *yylval = parse_events_get_lval(scanner);\n\tchar *text = parse_events_get_text(scanner);\n\n\t/* Strip off the '@' */\n\tyylval->str = strdup(text + 1);\n\treturn token;\n}\n\n#define REWIND(__alloc)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tYYSTYPE *__yylval = parse_events_get_lval(yyscanner);\t\\\n\tchar *text = parse_events_get_text(yyscanner);\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (__alloc)\t\t\t\t\t\t\\\n\t\t__yylval->str = strdup(text);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tyycolumn -= strlen(text);\t\t\t\t\\\n\tyyless(0);\t\t\t\t\t\t\\\n} while (0)\n\nstatic int sym(yyscan_t scanner, int type, int config)\n{\n\tYYSTYPE *yylval = parse_events_get_lval(scanner);\n\n\tyylval->num = (type << 16) + config;\n\treturn type == PERF_TYPE_HARDWARE ? PE_VALUE_SYM_HW : PE_VALUE_SYM_SW;\n}\n\nstatic int tool(yyscan_t scanner, enum perf_tool_event event)\n{\n\tYYSTYPE *yylval = parse_events_get_lval(scanner);\n\n\tyylval->num = event;\n\treturn PE_VALUE_SYM_TOOL;\n}\n\nstatic int term(yyscan_t scanner, enum parse_events__term_type type)\n{\n\tYYSTYPE *yylval = parse_events_get_lval(scanner);\n\n\tyylval->num = type;\n\treturn PE_TERM;\n}\n\nstatic int hw_term(yyscan_t scanner, int config)\n{\n\tYYSTYPE *yylval = parse_events_get_lval(scanner);\n\tchar *text = parse_events_get_text(scanner);\n\n\tyylval->hardware_term.str = strdup(text);\n\tyylval->hardware_term.num = PERF_TYPE_HARDWARE + config;\n\treturn PE_TERM_HW;\n}\n\n#define YY_USER_ACTION\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tyylloc->last_column  = yylloc->first_column;\t\\\n\tyylloc->first_column = yycolumn;\t\t\\\n\tyycolumn += yyleng;\t\t\t\t\\\n} while (0);\n\n#define USER_REJECT\t\t\\\n\tyycolumn -= yyleng;\t\\\n\tREJECT\n\n%}\n\n%x mem\n%s config\n%x event\n\ngroup\t\t[^,{}/]*[{][^}]*[}][^,{}/]*\nevent_pmu\t[^,{}/]+[/][^/]*[/][^,{}/]*\nevent\t\t[^,{}/]+\n\nnum_dec\t\t[0-9]+\nnum_hex\t\t0x[a-fA-F0-9]+\nnum_raw_hex\t[a-fA-F0-9]+\nname\t\t[a-zA-Z_*?\\[\\]][a-zA-Z0-9_*?.\\[\\]!\\-]*\nname_tag\t[\\'][a-zA-Z_*?\\[\\]][a-zA-Z0-9_*?\\-,\\.\\[\\]:=]*[\\']\nname_minus\t[a-zA-Z_*?][a-zA-Z0-9\\-_*?.:]*\ndrv_cfg_term\t[a-zA-Z0-9_\\.]+(=[a-zA-Z0-9_*?\\.:]+)?\n/*\n * If you add a modifier you need to update check_modifier().\n * Also, the letters in modifier_event must not be in modifier_bp.\n */\nmodifier_event\t[ukhpPGHSDIWeb]+\nmodifier_bp\t[rwx]{1,3}\nlc_type \t(L1-dcache|l1-d|l1d|L1-data|L1-icache|l1-i|l1i|L1-instruction|LLC|L2|dTLB|d-tlb|Data-TLB|iTLB|i-tlb|Instruction-TLB|branch|branches|bpu|btb|bpc|node)\nlc_op_result\t(load|loads|read|store|stores|write|prefetch|prefetches|speculative-read|speculative-load|refs|Reference|ops|access|misses|miss)\ndigit\t\t[0-9]\nnon_digit\t[^0-9]\n\n%%\n\n%{\n\tstruct parse_events_state *_parse_state = parse_events_get_extra(yyscanner);\n\t{\n\t\tint start_token = _parse_state->stoken;\n\n\t\tif (start_token == PE_START_TERMS)\n\t\t\tBEGIN(config);\n\t\telse if (start_token == PE_START_EVENTS)\n\t\t\tBEGIN(event);\n\n\t\tif (start_token) {\n\t\t\t_parse_state->stoken = 0;\n\t\t\t/*\n\t\t\t * The flex parser does not init locations variable\n\t\t\t * via the scan_string interface, so we need do the\n\t\t\t * init in here.\n\t\t\t */\n\t\t\tyycolumn = 0;\n\t\t\treturn start_token;\n\t\t}\n         }\n%}\n\n<event>{\n\n{group}\t\t{\n\t\t\tBEGIN(INITIAL);\n\t\t\tREWIND(0);\n\t\t}\n\n{event_pmu}\t|\n{event}\t\t{\n\t\t\tBEGIN(INITIAL);\n\t\t\tREWIND(1);\n\t\t\treturn PE_EVENT_NAME;\n\t\t}\n\n<<EOF>>\t\t{\n\t\t\tBEGIN(INITIAL);\n\t\t\tREWIND(0);\n\t\t}\n,\t\t{\n\t\t\treturn ',';\n\t\t}\n}\n\n<config>{\n\t/*\n\t * Please update config_term_names when new static term is added.\n\t */\nconfig\t\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CONFIG); }\nconfig1\t\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CONFIG1); }\nconfig2\t\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CONFIG2); }\nconfig3\t\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CONFIG3); }\nname\t\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_NAME); }\nperiod\t\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD); }\nfreq\t\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ); }\nbranch_type\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE); }\ntime\t\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_TIME); }\ncall-graph\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CALLGRAPH); }\nstack-size\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_STACKSIZE); }\nmax-stack\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_MAX_STACK); }\nnr\t\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_MAX_EVENTS); }\ninherit\t\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_INHERIT); }\nno-inherit\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_NOINHERIT); }\noverwrite\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_OVERWRITE); }\nno-overwrite\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_NOOVERWRITE); }\npercore\t\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_PERCORE); }\naux-output\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_AUX_OUTPUT); }\naux-sample-size\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_AUX_SAMPLE_SIZE); }\nmetric-id\t\t{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_METRIC_ID); }\ncpu-cycles|cycles\t\t\t\t{ return hw_term(yyscanner, PERF_COUNT_HW_CPU_CYCLES); }\nstalled-cycles-frontend|idle-cycles-frontend\t{ return hw_term(yyscanner, PERF_COUNT_HW_STALLED_CYCLES_FRONTEND); }\nstalled-cycles-backend|idle-cycles-backend\t{ return hw_term(yyscanner, PERF_COUNT_HW_STALLED_CYCLES_BACKEND); }\ninstructions\t\t\t\t\t{ return hw_term(yyscanner, PERF_COUNT_HW_INSTRUCTIONS); }\ncache-references\t\t\t\t{ return hw_term(yyscanner, PERF_COUNT_HW_CACHE_REFERENCES); }\ncache-misses\t\t\t\t\t{ return hw_term(yyscanner, PERF_COUNT_HW_CACHE_MISSES); }\nbranch-instructions|branches\t\t\t{ return hw_term(yyscanner, PERF_COUNT_HW_BRANCH_INSTRUCTIONS); }\nbranch-misses\t\t\t\t\t{ return hw_term(yyscanner, PERF_COUNT_HW_BRANCH_MISSES); }\nbus-cycles\t\t\t\t\t{ return hw_term(yyscanner, PERF_COUNT_HW_BUS_CYCLES); }\nref-cycles\t\t\t\t\t{ return hw_term(yyscanner, PERF_COUNT_HW_REF_CPU_CYCLES); }\nr{num_raw_hex}\t\t{ return str(yyscanner, PE_RAW); }\nr0x{num_raw_hex}\t{ return str(yyscanner, PE_RAW); }\n,\t\t\t{ return ','; }\n\"/\"\t\t\t{ BEGIN(INITIAL); return '/'; }\n{lc_type}\t\t\t{ return lc_str(yyscanner, _parse_state); }\n{lc_type}-{lc_op_result}\t{ return lc_str(yyscanner, _parse_state); }\n{lc_type}-{lc_op_result}-{lc_op_result}\t{ return lc_str(yyscanner, _parse_state); }\n{name_minus}\t\t{ return str(yyscanner, PE_NAME); }\n@{drv_cfg_term}\t\t{ return drv_str(yyscanner, PE_DRV_CFG_TERM); }\n}\n\n<mem>{\n{modifier_bp}\t\t{ return str(yyscanner, PE_MODIFIER_BP); }\n\t/*\n\t * The colon before memory access modifiers can get mixed up with the\n\t * colon before event modifiers. Fortunately none of the option letters\n\t * are the same, so trailing context can be used disambiguate the two\n\t * cases.\n\t */\n\":\"/{modifier_bp}\t{ return PE_BP_COLON; }\n\t/*\n\t * The slash before memory length can get mixed up with the slash before\n\t * config terms. Fortunately config terms do not start with a numeric\n\t * digit, so trailing context can be used disambiguate the two cases.\n\t */\n\"/\"/{digit}\t\t{ return PE_BP_SLASH; }\n\"/\"/{non_digit}\t\t{ BEGIN(config); return '/'; }\n{num_dec}\t\t{ return value(yyscanner, 10); }\n{num_hex}\t\t{ return value(yyscanner, 16); }\n\t/*\n\t * We need to separate 'mem:' scanner part, in order to get specific\n\t * modifier bits parsed out. Otherwise we would need to handle PE_NAME\n\t * and we'd need to parse it manually. During the escape from <mem>\n\t * state we need to put the escaping char back, so we dont miss it.\n\t */\n.\t\t\t{ unput(*yytext); BEGIN(INITIAL); }\n\t/*\n\t * We destroy the scanner after reaching EOF,\n\t * but anyway just to be sure get back to INIT state.\n\t */\n<<EOF>>\t\t\t{ BEGIN(INITIAL); }\n}\n\ncpu-cycles|cycles\t\t\t\t{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_CPU_CYCLES); }\nstalled-cycles-frontend|idle-cycles-frontend\t{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_STALLED_CYCLES_FRONTEND); }\nstalled-cycles-backend|idle-cycles-backend\t{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_STALLED_CYCLES_BACKEND); }\ninstructions\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_INSTRUCTIONS); }\ncache-references\t\t\t\t{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_CACHE_REFERENCES); }\ncache-misses\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_CACHE_MISSES); }\nbranch-instructions|branches\t\t\t{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_BRANCH_INSTRUCTIONS); }\nbranch-misses\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_BRANCH_MISSES); }\nbus-cycles\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_BUS_CYCLES); }\nref-cycles\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_REF_CPU_CYCLES); }\ncpu-clock\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_CPU_CLOCK); }\ntask-clock\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_TASK_CLOCK); }\npage-faults|faults\t\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_PAGE_FAULTS); }\nminor-faults\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_PAGE_FAULTS_MIN); }\nmajor-faults\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_PAGE_FAULTS_MAJ); }\ncontext-switches|cs\t\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_CONTEXT_SWITCHES); }\ncpu-migrations|migrations\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_CPU_MIGRATIONS); }\nalignment-faults\t\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_ALIGNMENT_FAULTS); }\nemulation-faults\t\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_EMULATION_FAULTS); }\ndummy\t\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_DUMMY); }\nduration_time\t\t\t\t\t{ return tool(yyscanner, PERF_TOOL_DURATION_TIME); }\nuser_time\t\t\t\t\t\t{ return tool(yyscanner, PERF_TOOL_USER_TIME); }\nsystem_time\t\t\t\t\t\t{ return tool(yyscanner, PERF_TOOL_SYSTEM_TIME); }\nbpf-output\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_BPF_OUTPUT); }\ncgroup-switches\t\t\t\t\t{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_CGROUP_SWITCHES); }\n\n{lc_type}\t\t\t{ return str(yyscanner, PE_LEGACY_CACHE); }\n{lc_type}-{lc_op_result}\t{ return str(yyscanner, PE_LEGACY_CACHE); }\n{lc_type}-{lc_op_result}-{lc_op_result}\t{ return str(yyscanner, PE_LEGACY_CACHE); }\nmem:\t\t\t{ BEGIN(mem); return PE_PREFIX_MEM; }\nr{num_raw_hex}\t\t{ return str(yyscanner, PE_RAW); }\n{num_dec}\t\t{ return value(yyscanner, 10); }\n{num_hex}\t\t{ return value(yyscanner, 16); }\n\n{modifier_event}\t{ return str(yyscanner, PE_MODIFIER_EVENT); }\n{name}\t\t\t{ return str(yyscanner, PE_NAME); }\n{name_tag}\t\t{ return str(yyscanner, PE_NAME); }\n\"/\"\t\t\t{ BEGIN(config); return '/'; }\n,\t\t\t{ BEGIN(event); return ','; }\n:\t\t\t{ return ':'; }\n\"{\"\t\t\t{ BEGIN(event); return '{'; }\n\"}\"\t\t\t{ return '}'; }\n=\t\t\t{ return '='; }\n\\n\t\t\t{ }\n.\t\t\t{ }\n\n%%\n\nint parse_events_wrap(void *scanner __maybe_unused)\n{\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}