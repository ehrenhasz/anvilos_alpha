{
  "module_name": "trace-event-info.c",
  "hash_id": "45252c0fc487614f822cef4b32f19ed742ca8181508188342b6a50b6c3df0cd0",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/trace-event-info.c",
  "human_readable_source": "\n \n#include <dirent.h>\n#include <mntent.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/zalloc.h>\n#include <internal/lib.h> \n#include <sys/param.h>\n\n#include \"trace-event.h\"\n#include \"tracepoint.h\"\n#include <api/fs/tracing_path.h>\n#include \"evsel.h\"\n#include \"debug.h\"\n#include \"util.h\"\n\n#define VERSION \"0.6\"\n#define MAX_EVENT_LENGTH 512\n\nstatic int output_fd;\n\nstruct tracepoint_path {\n\tchar *system;\n\tchar *name;\n\tstruct tracepoint_path *next;\n};\n\n \nstatic int record_file(const char *file, ssize_t hdr_sz)\n{\n\tunsigned long long size = 0;\n\tchar buf[BUFSIZ], *sizep;\n\toff_t hdr_pos = lseek(output_fd, 0, SEEK_CUR);\n\tint r, fd;\n\tint err = -EIO;\n\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t\tpr_debug(\"Can't read '%s'\", file);\n\t\treturn -errno;\n\t}\n\n\t \n\tif (hdr_sz) {\n\t\tif (write(output_fd, &size, hdr_sz) != hdr_sz)\n\t\t\tgoto out;\n\t}\n\n\tdo {\n\t\tr = read(fd, buf, BUFSIZ);\n\t\tif (r > 0) {\n\t\t\tsize += r;\n\t\t\tif (write(output_fd, buf, r) != r)\n\t\t\t\tgoto out;\n\t\t}\n\t} while (r > 0);\n\n\t \n\tsizep = (char*)&size;\n\tif (host_is_bigendian())\n\t\tsizep += sizeof(u64) - hdr_sz;\n\n\tif (hdr_sz && pwrite(output_fd, sizep, hdr_sz, hdr_pos) < 0) {\n\t\tpr_debug(\"writing file size failed\\n\");\n\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\tclose(fd);\n\treturn err;\n}\n\nstatic int record_header_files(void)\n{\n\tchar *path = get_events_file(\"header_page\");\n\tstruct stat st;\n\tint err = -EIO;\n\n\tif (!path) {\n\t\tpr_debug(\"can't get tracing/events/header_page\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (stat(path, &st) < 0) {\n\t\tpr_debug(\"can't read '%s'\", path);\n\t\tgoto out;\n\t}\n\n\tif (write(output_fd, \"header_page\", 12) != 12) {\n\t\tpr_debug(\"can't write header_page\\n\");\n\t\tgoto out;\n\t}\n\n\tif (record_file(path, 8) < 0) {\n\t\tpr_debug(\"can't record header_page file\\n\");\n\t\tgoto out;\n\t}\n\n\tput_events_file(path);\n\n\tpath = get_events_file(\"header_event\");\n\tif (!path) {\n\t\tpr_debug(\"can't get tracing/events/header_event\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (stat(path, &st) < 0) {\n\t\tpr_debug(\"can't read '%s'\", path);\n\t\tgoto out;\n\t}\n\n\tif (write(output_fd, \"header_event\", 13) != 13) {\n\t\tpr_debug(\"can't write header_event\\n\");\n\t\tgoto out;\n\t}\n\n\tif (record_file(path, 8) < 0) {\n\t\tpr_debug(\"can't record header_event file\\n\");\n\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\tput_events_file(path);\n\treturn err;\n}\n\nstatic bool name_in_tp_list(char *sys, struct tracepoint_path *tps)\n{\n\twhile (tps) {\n\t\tif (!strcmp(sys, tps->name))\n\t\t\treturn true;\n\t\ttps = tps->next;\n\t}\n\n\treturn false;\n}\n\n#define for_each_event_tps(dir, dent, tps)\t\t\t\\\n\twhile ((dent = readdir(dir)))\t\t\t\t\\\n\t\tif (dent->d_type == DT_DIR &&\t\t\t\\\n\t\t    (strcmp(dent->d_name, \".\")) &&\t\t\\\n\t\t    (strcmp(dent->d_name, \"..\")))\t\t\\\n\nstatic int copy_event_system(const char *sys, struct tracepoint_path *tps)\n{\n\tstruct dirent *dent;\n\tstruct stat st;\n\tchar *format;\n\tDIR *dir;\n\tint count = 0;\n\tint ret;\n\tint err;\n\n\tdir = opendir(sys);\n\tif (!dir) {\n\t\tpr_debug(\"can't read directory '%s'\", sys);\n\t\treturn -errno;\n\t}\n\n\tfor_each_event_tps(dir, dent, tps) {\n\t\tif (!name_in_tp_list(dent->d_name, tps))\n\t\t\tcontinue;\n\n\t\tif (asprintf(&format, \"%s/%s/format\", sys, dent->d_name) < 0) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = stat(format, &st);\n\t\tfree(format);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\t\tcount++;\n\t}\n\n\tif (write(output_fd, &count, 4) != 4) {\n\t\terr = -EIO;\n\t\tpr_debug(\"can't write count\\n\");\n\t\tgoto out;\n\t}\n\n\trewinddir(dir);\n\tfor_each_event_tps(dir, dent, tps) {\n\t\tif (!name_in_tp_list(dent->d_name, tps))\n\t\t\tcontinue;\n\n\t\tif (asprintf(&format, \"%s/%s/format\", sys, dent->d_name) < 0) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = stat(format, &st);\n\n\t\tif (ret >= 0) {\n\t\t\terr = record_file(format, 8);\n\t\t\tif (err) {\n\t\t\t\tfree(format);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfree(format);\n\t}\n\terr = 0;\nout:\n\tclosedir(dir);\n\treturn err;\n}\n\nstatic int record_ftrace_files(struct tracepoint_path *tps)\n{\n\tchar *path;\n\tint ret;\n\n\tpath = get_events_file(\"ftrace\");\n\tif (!path) {\n\t\tpr_debug(\"can't get tracing/events/ftrace\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = copy_event_system(path, tps);\n\n\tput_tracing_file(path);\n\n\treturn ret;\n}\n\nstatic bool system_in_tp_list(char *sys, struct tracepoint_path *tps)\n{\n\twhile (tps) {\n\t\tif (!strcmp(sys, tps->system))\n\t\t\treturn true;\n\t\ttps = tps->next;\n\t}\n\n\treturn false;\n}\n\nstatic int record_event_files(struct tracepoint_path *tps)\n{\n\tstruct dirent *dent;\n\tstruct stat st;\n\tchar *path;\n\tchar *sys;\n\tDIR *dir;\n\tint count = 0;\n\tint ret;\n\tint err;\n\n\tpath = get_tracing_file(\"events\");\n\tif (!path) {\n\t\tpr_debug(\"can't get tracing/events\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdir = opendir(path);\n\tif (!dir) {\n\t\terr = -errno;\n\t\tpr_debug(\"can't read directory '%s'\", path);\n\t\tgoto out;\n\t}\n\n\tfor_each_event_tps(dir, dent, tps) {\n\t\tif (strcmp(dent->d_name, \"ftrace\") == 0 ||\n\t\t    !system_in_tp_list(dent->d_name, tps))\n\t\t\tcontinue;\n\n\t\tcount++;\n\t}\n\n\tif (write(output_fd, &count, 4) != 4) {\n\t\terr = -EIO;\n\t\tpr_debug(\"can't write count\\n\");\n\t\tgoto out;\n\t}\n\n\trewinddir(dir);\n\tfor_each_event_tps(dir, dent, tps) {\n\t\tif (strcmp(dent->d_name, \"ftrace\") == 0 ||\n\t\t    !system_in_tp_list(dent->d_name, tps))\n\t\t\tcontinue;\n\n\t\tif (asprintf(&sys, \"%s/%s\", path, dent->d_name) < 0) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = stat(sys, &st);\n\t\tif (ret >= 0) {\n\t\t\tssize_t size = strlen(dent->d_name) + 1;\n\n\t\t\tif (write(output_fd, dent->d_name, size) != size ||\n\t\t\t    copy_event_system(sys, tps) < 0) {\n\t\t\t\terr = -EIO;\n\t\t\t\tfree(sys);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfree(sys);\n\t}\n\terr = 0;\nout:\n\tclosedir(dir);\n\tput_tracing_file(path);\n\n\treturn err;\n}\n\nstatic int record_proc_kallsyms(void)\n{\n\tunsigned long long size = 0;\n\t \n\treturn write(output_fd, &size, 4) != 4 ? -EIO : 0;\n}\n\nstatic int record_ftrace_printk(void)\n{\n\tunsigned int size;\n\tchar *path;\n\tstruct stat st;\n\tint ret, err = 0;\n\n\tpath = get_tracing_file(\"printk_formats\");\n\tif (!path) {\n\t\tpr_debug(\"can't get tracing/printk_formats\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = stat(path, &st);\n\tif (ret < 0) {\n\t\t \n\t\tsize = 0;\n\t\tif (write(output_fd, &size, 4) != 4)\n\t\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\terr = record_file(path, 4);\n\nout:\n\tput_tracing_file(path);\n\treturn err;\n}\n\nstatic int record_saved_cmdline(void)\n{\n\tunsigned long long size;\n\tchar *path;\n\tstruct stat st;\n\tint ret, err = 0;\n\n\tpath = get_tracing_file(\"saved_cmdlines\");\n\tif (!path) {\n\t\tpr_debug(\"can't get tracing/saved_cmdline\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = stat(path, &st);\n\tif (ret < 0) {\n\t\t \n\t\tsize = 0;\n\t\tif (write(output_fd, &size, 8) != 8)\n\t\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\terr = record_file(path, 8);\n\nout:\n\tput_tracing_file(path);\n\treturn err;\n}\n\nstatic void\nput_tracepoints_path(struct tracepoint_path *tps)\n{\n\twhile (tps) {\n\t\tstruct tracepoint_path *t = tps;\n\n\t\ttps = tps->next;\n\t\tzfree(&t->name);\n\t\tzfree(&t->system);\n\t\tfree(t);\n\t}\n}\n\nstatic struct tracepoint_path *tracepoint_id_to_path(u64 config)\n{\n\tstruct tracepoint_path *path = NULL;\n\tDIR *sys_dir, *evt_dir;\n\tstruct dirent *sys_dirent, *evt_dirent;\n\tchar id_buf[24];\n\tint fd;\n\tu64 id;\n\tchar evt_path[MAXPATHLEN];\n\tchar *dir_path;\n\n\tsys_dir = tracing_events__opendir();\n\tif (!sys_dir)\n\t\treturn NULL;\n\n\tfor_each_subsystem(sys_dir, sys_dirent) {\n\t\tdir_path = get_events_file(sys_dirent->d_name);\n\t\tif (!dir_path)\n\t\t\tcontinue;\n\t\tevt_dir = opendir(dir_path);\n\t\tif (!evt_dir)\n\t\t\tgoto next;\n\n\t\tfor_each_event(dir_path, evt_dir, evt_dirent) {\n\n\t\t\tscnprintf(evt_path, MAXPATHLEN, \"%s/%s/id\", dir_path,\n\t\t\t\t  evt_dirent->d_name);\n\t\t\tfd = open(evt_path, O_RDONLY);\n\t\t\tif (fd < 0)\n\t\t\t\tcontinue;\n\t\t\tif (read(fd, id_buf, sizeof(id_buf)) < 0) {\n\t\t\t\tclose(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(fd);\n\t\t\tid = atoll(id_buf);\n\t\t\tif (id == config) {\n\t\t\t\tput_events_file(dir_path);\n\t\t\t\tclosedir(evt_dir);\n\t\t\t\tclosedir(sys_dir);\n\t\t\t\tpath = zalloc(sizeof(*path));\n\t\t\t\tif (!path)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (asprintf(&path->system, \"%.*s\",\n\t\t\t\t\t     MAX_EVENT_LENGTH, sys_dirent->d_name) < 0) {\n\t\t\t\t\tfree(path);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (asprintf(&path->name, \"%.*s\",\n\t\t\t\t\t     MAX_EVENT_LENGTH, evt_dirent->d_name) < 0) {\n\t\t\t\t\tzfree(&path->system);\n\t\t\t\t\tfree(path);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn path;\n\t\t\t}\n\t\t}\n\t\tclosedir(evt_dir);\nnext:\n\t\tput_events_file(dir_path);\n\t}\n\n\tclosedir(sys_dir);\n\treturn NULL;\n}\n\nchar *tracepoint_id_to_name(u64 config)\n{\n\tstruct tracepoint_path *path = tracepoint_id_to_path(config);\n\tchar *buf = NULL;\n\n\tif (path && asprintf(&buf, \"%s:%s\", path->system, path->name) < 0)\n\t\tbuf = NULL;\n\n\tput_tracepoints_path(path);\n\treturn buf;\n}\n\nstatic struct tracepoint_path *tracepoint_name_to_path(const char *name)\n{\n\tstruct tracepoint_path *path = zalloc(sizeof(*path));\n\tchar *str = strchr(name, ':');\n\n\tif (path == NULL || str == NULL) {\n\t\tfree(path);\n\t\treturn NULL;\n\t}\n\n\tpath->system = strndup(name, str - name);\n\tpath->name = strdup(str+1);\n\n\tif (path->system == NULL || path->name == NULL) {\n\t\tzfree(&path->system);\n\t\tzfree(&path->name);\n\t\tzfree(&path);\n\t}\n\n\treturn path;\n}\n\nstatic struct tracepoint_path *\nget_tracepoints_path(struct list_head *pattrs)\n{\n\tstruct tracepoint_path path, *ppath = &path;\n\tstruct evsel *pos;\n\tint nr_tracepoints = 0;\n\n\tlist_for_each_entry(pos, pattrs, core.node) {\n\t\tif (pos->core.attr.type != PERF_TYPE_TRACEPOINT)\n\t\t\tcontinue;\n\t\t++nr_tracepoints;\n\n\t\tif (pos->name) {\n\t\t\tppath->next = tracepoint_name_to_path(pos->name);\n\t\t\tif (ppath->next)\n\t\t\t\tgoto next;\n\n\t\t\tif (strchr(pos->name, ':') == NULL)\n\t\t\t\tgoto try_id;\n\n\t\t\tgoto error;\n\t\t}\n\ntry_id:\n\t\tppath->next = tracepoint_id_to_path(pos->core.attr.config);\n\t\tif (!ppath->next) {\nerror:\n\t\t\tpr_debug(\"No memory to alloc tracepoints list\\n\");\n\t\t\tput_tracepoints_path(path.next);\n\t\t\treturn NULL;\n\t\t}\nnext:\n\t\tppath = ppath->next;\n\t}\n\n\treturn nr_tracepoints > 0 ? path.next : NULL;\n}\n\nbool have_tracepoints(struct list_head *pattrs)\n{\n\tstruct evsel *pos;\n\n\tlist_for_each_entry(pos, pattrs, core.node)\n\t\tif (pos->core.attr.type == PERF_TYPE_TRACEPOINT)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int tracing_data_header(void)\n{\n\tchar buf[20];\n\tssize_t size;\n\n\t \n\tbuf[0] = 23;\n\tbuf[1] = 8;\n\tbuf[2] = 68;\n\tmemcpy(buf + 3, \"tracing\", 7);\n\n\tif (write(output_fd, buf, 10) != 10)\n\t\treturn -1;\n\n\tsize = strlen(VERSION) + 1;\n\tif (write(output_fd, VERSION, size) != size)\n\t\treturn -1;\n\n\t \n\tif (host_is_bigendian())\n\t\tbuf[0] = 1;\n\telse\n\t\tbuf[0] = 0;\n\n\tif (write(output_fd, buf, 1) != 1)\n\t\treturn -1;\n\n\t \n\tbuf[0] = sizeof(long);\n\tif (write(output_fd, buf, 1) != 1)\n\t\treturn -1;\n\n\t \n\tif (write(output_fd, &page_size, 4) != 4)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstruct tracing_data *tracing_data_get(struct list_head *pattrs,\n\t\t\t\t      int fd, bool temp)\n{\n\tstruct tracepoint_path *tps;\n\tstruct tracing_data *tdata;\n\tint err;\n\n\toutput_fd = fd;\n\n\ttps = get_tracepoints_path(pattrs);\n\tif (!tps)\n\t\treturn NULL;\n\n\ttdata = malloc(sizeof(*tdata));\n\tif (!tdata)\n\t\treturn NULL;\n\n\ttdata->temp = temp;\n\ttdata->size = 0;\n\n\tif (temp) {\n\t\tint temp_fd;\n\n\t\tsnprintf(tdata->temp_file, sizeof(tdata->temp_file),\n\t\t\t \"/tmp/perf-XXXXXX\");\n\t\tif (!mkstemp(tdata->temp_file)) {\n\t\t\tpr_debug(\"Can't make temp file\");\n\t\t\tfree(tdata);\n\t\t\treturn NULL;\n\t\t}\n\n\t\ttemp_fd = open(tdata->temp_file, O_RDWR);\n\t\tif (temp_fd < 0) {\n\t\t\tpr_debug(\"Can't read '%s'\", tdata->temp_file);\n\t\t\tfree(tdata);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\toutput_fd = temp_fd;\n\t}\n\n\terr = tracing_data_header();\n\tif (err)\n\t\tgoto out;\n\terr = record_header_files();\n\tif (err)\n\t\tgoto out;\n\terr = record_ftrace_files(tps);\n\tif (err)\n\t\tgoto out;\n\terr = record_event_files(tps);\n\tif (err)\n\t\tgoto out;\n\terr = record_proc_kallsyms();\n\tif (err)\n\t\tgoto out;\n\terr = record_ftrace_printk();\n\tif (err)\n\t\tgoto out;\n\terr = record_saved_cmdline();\n\nout:\n\t \n\tif (temp) {\n\t\ttdata->size = lseek(output_fd, 0, SEEK_CUR);\n\t\tclose(output_fd);\n\t\toutput_fd = fd;\n\t}\n\n\tif (err)\n\t\tzfree(&tdata);\n\n\tput_tracepoints_path(tps);\n\treturn tdata;\n}\n\nint tracing_data_put(struct tracing_data *tdata)\n{\n\tint err = 0;\n\n\tif (tdata->temp) {\n\t\terr = record_file(tdata->temp_file, 0);\n\t\tunlink(tdata->temp_file);\n\t}\n\n\tfree(tdata);\n\treturn err;\n}\n\nint read_tracing_data(int fd, struct list_head *pattrs)\n{\n\tint err;\n\tstruct tracing_data *tdata;\n\n\t \n\ttdata = tracing_data_get(pattrs, fd, false);\n\tif (!tdata)\n\t\treturn -ENOMEM;\n\n\terr = tracing_data_put(tdata);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}