{
  "module_name": "sideband_evlist.c",
  "hash_id": "e7cca530081a48a179172ffdf0ef7e22fd4a224e2e7874ef49e39389fafe78b1",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/sideband_evlist.c",
  "human_readable_source": "\n\n#include \"util/debug.h\"\n#include \"util/evlist.h\"\n#include \"util/evsel.h\"\n#include \"util/mmap.h\"\n#include \"util/perf_api_probe.h\"\n#include <perf/mmap.h>\n#include <linux/perf_event.h>\n#include <limits.h>\n#include <pthread.h>\n#include <sched.h>\n#include <stdbool.h>\n\nint evlist__add_sb_event(struct evlist *evlist, struct perf_event_attr *attr,\n\t\t\t evsel__sb_cb_t cb, void *data)\n{\n\tstruct evsel *evsel;\n\n\tif (!attr->sample_id_all) {\n\t\tpr_warning(\"enabling sample_id_all for all side band events\\n\");\n\t\tattr->sample_id_all = 1;\n\t}\n\n\tevsel = evsel__new_idx(attr, evlist->core.nr_entries);\n\tif (!evsel)\n\t\treturn -1;\n\n\tevsel->side_band.cb = cb;\n\tevsel->side_band.data = data;\n\tevlist__add(evlist, evsel);\n\treturn 0;\n}\n\nstatic void *perf_evlist__poll_thread(void *arg)\n{\n\tstruct evlist *evlist = arg;\n\tbool draining = false;\n\tint i, done = 0;\n\t \n\tunshare(CLONE_FS);\n\n\twhile (!done) {\n\t\tbool got_data = false;\n\n\t\tif (evlist->thread.done)\n\t\t\tdraining = true;\n\n\t\tif (!draining)\n\t\t\tevlist__poll(evlist, 1000);\n\n\t\tfor (i = 0; i < evlist->core.nr_mmaps; i++) {\n\t\t\tstruct mmap *map = &evlist->mmap[i];\n\t\t\tunion perf_event *event;\n\n\t\t\tif (perf_mmap__read_init(&map->core))\n\t\t\t\tcontinue;\n\t\t\twhile ((event = perf_mmap__read_event(&map->core)) != NULL) {\n\t\t\t\tstruct evsel *evsel = evlist__event2evsel(evlist, event);\n\n\t\t\t\tif (evsel && evsel->side_band.cb)\n\t\t\t\t\tevsel->side_band.cb(event, evsel->side_band.data);\n\t\t\t\telse\n\t\t\t\t\tpr_warning(\"cannot locate proper evsel for the side band event\\n\");\n\n\t\t\t\tperf_mmap__consume(&map->core);\n\t\t\t\tgot_data = true;\n\t\t\t}\n\t\t\tperf_mmap__read_done(&map->core);\n\t\t}\n\n\t\tif (draining && !got_data)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nvoid evlist__set_cb(struct evlist *evlist, evsel__sb_cb_t cb, void *data)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tevsel->core.attr.sample_id_all    = 1;\n\t\tevsel->core.attr.watermark        = 1;\n\t\tevsel->core.attr.wakeup_watermark = 1;\n\t\tevsel->side_band.cb   = cb;\n\t\tevsel->side_band.data = data;\n      }\n}\n\nint evlist__start_sb_thread(struct evlist *evlist, struct target *target)\n{\n\tstruct evsel *counter;\n\n\tif (!evlist)\n\t\treturn 0;\n\n\tif (evlist__create_maps(evlist, target))\n\t\tgoto out_delete_evlist;\n\n\tif (evlist->core.nr_entries > 1) {\n\t\tbool can_sample_identifier = perf_can_sample_identifier();\n\n\t\tevlist__for_each_entry(evlist, counter)\n\t\t\tevsel__set_sample_id(counter, can_sample_identifier);\n\n\t\tevlist__set_id_pos(evlist);\n\t}\n\n\tevlist__for_each_entry(evlist, counter) {\n\t\tif (evsel__open(counter, evlist->core.user_requested_cpus,\n\t\t\t\tevlist->core.threads) < 0)\n\t\t\tgoto out_delete_evlist;\n\t}\n\n\tif (evlist__mmap(evlist, UINT_MAX))\n\t\tgoto out_delete_evlist;\n\n\tevlist__for_each_entry(evlist, counter) {\n\t\tif (evsel__enable(counter))\n\t\t\tgoto out_delete_evlist;\n\t}\n\n\tevlist->thread.done = 0;\n\tif (pthread_create(&evlist->thread.th, NULL, perf_evlist__poll_thread, evlist))\n\t\tgoto out_delete_evlist;\n\n\treturn 0;\n\nout_delete_evlist:\n\tevlist__delete(evlist);\n\tevlist = NULL;\n\treturn -1;\n}\n\nvoid evlist__stop_sb_thread(struct evlist *evlist)\n{\n\tif (!evlist)\n\t\treturn;\n\tevlist->thread.done = 1;\n\tpthread_join(evlist->thread.th, NULL);\n\tevlist__delete(evlist);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}