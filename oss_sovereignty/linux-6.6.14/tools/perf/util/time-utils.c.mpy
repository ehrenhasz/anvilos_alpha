{
  "module_name": "time-utils.c",
  "hash_id": "15375d094eb02bf50863de2b6961cddd9e4815047dd3998c9d94dee7d451413d",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/time-utils.c",
  "human_readable_source": "\n#include <stdlib.h>\n#include <string.h>\n#include <linux/string.h>\n#include <sys/time.h>\n#include <linux/time64.h>\n#include <time.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <math.h>\n#include <linux/ctype.h>\n\n#include \"debug.h\"\n#include \"time-utils.h\"\n#include \"session.h\"\n#include \"evlist.h\"\n\nint parse_nsec_time(const char *str, u64 *ptime)\n{\n\tu64 time_sec, time_nsec;\n\tchar *end;\n\n\ttime_sec = strtoul(str, &end, 10);\n\tif (*end != '.' && *end != '\\0')\n\t\treturn -1;\n\n\tif (*end == '.') {\n\t\tint i;\n\t\tchar nsec_buf[10];\n\n\t\tif (strlen(++end) > 9)\n\t\t\treturn -1;\n\n\t\tstrncpy(nsec_buf, end, 9);\n\t\tnsec_buf[9] = '\\0';\n\n\t\t \n\t\tfor (i = strlen(nsec_buf); i < 9; i++)\n\t\t\tnsec_buf[i] = '0';\n\n\t\ttime_nsec = strtoul(nsec_buf, &end, 10);\n\t\tif (*end != '\\0')\n\t\t\treturn -1;\n\t} else\n\t\ttime_nsec = 0;\n\n\t*ptime = time_sec * NSEC_PER_SEC + time_nsec;\n\treturn 0;\n}\n\nstatic int parse_timestr_sec_nsec(struct perf_time_interval *ptime,\n\t\t\t\t  char *start_str, char *end_str)\n{\n\tif (start_str && (*start_str != '\\0') &&\n\t    (parse_nsec_time(start_str, &ptime->start) != 0)) {\n\t\treturn -1;\n\t}\n\n\tif (end_str && (*end_str != '\\0') &&\n\t    (parse_nsec_time(end_str, &ptime->end) != 0)) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int split_start_end(char **start, char **end, const char *ostr, char ch)\n{\n\tchar *start_str, *end_str;\n\tchar *d, *str;\n\n\tif (ostr == NULL || *ostr == '\\0')\n\t\treturn 0;\n\n\t \n\tstr = strdup(ostr);\n\tif (str == NULL)\n\t\treturn -ENOMEM;\n\n\tstart_str = str;\n\td = strchr(start_str, ch);\n\tif (d) {\n\t\t*d = '\\0';\n\t\t++d;\n\t}\n\tend_str = d;\n\n\t*start = start_str;\n\t*end = end_str;\n\n\treturn 0;\n}\n\nint perf_time__parse_str(struct perf_time_interval *ptime, const char *ostr)\n{\n\tchar *start_str = NULL, *end_str;\n\tint rc;\n\n\trc = split_start_end(&start_str, &end_str, ostr, ',');\n\tif (rc || !start_str)\n\t\treturn rc;\n\n\tptime->start = 0;\n\tptime->end = 0;\n\n\trc = parse_timestr_sec_nsec(ptime, start_str, end_str);\n\n\tfree(start_str);\n\n\t \n\tif (rc == 0 && ptime->end && ptime->end < ptime->start)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"start time %\" PRIu64 \", \", ptime->start);\n\tpr_debug(\"end time %\" PRIu64 \"\\n\", ptime->end);\n\n\treturn rc;\n}\n\nstatic int perf_time__parse_strs(struct perf_time_interval *ptime,\n\t\t\t\t const char *ostr, int size)\n{\n\tconst char *cp;\n\tchar *str, *arg, *p;\n\tint i, num = 0, rc = 0;\n\n\t \n\tfor (cp = ostr; *cp; cp++)\n\t\tnum += !!(*cp == ',');\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tBUG_ON(num > size);\n\n\tstr = strdup(ostr);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0, p = str; i < num - 1; i++) {\n\t\targ = p;\n\t\t \n\t\tp = skip_spaces(strchr(p, ',') + 1);\n\t\t \n\t\twhile (*p && !isspace(*p)) {\n\t\t\tif (*p++ == ',') {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (*p)\n\t\t\t*p++ = 0;\n\t\trc = perf_time__parse_str(ptime + i, arg);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\trc = perf_time__parse_str(ptime + i, p);\n\tif (rc < 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < num - 1; i++) {\n\t\tif (ptime[i].end >= ptime[i + 1].start) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = num;\nout:\n\tfree(str);\n\n\treturn rc;\n}\n\nstatic int parse_percent(double *pcnt, char *str)\n{\n\tchar *c, *endptr;\n\tdouble d;\n\n\tc = strchr(str, '%');\n\tif (c)\n\t\t*c = '\\0';\n\telse\n\t\treturn -1;\n\n\td = strtod(str, &endptr);\n\tif (endptr != str + strlen(str))\n\t\treturn -1;\n\n\t*pcnt = d / 100.0;\n\treturn 0;\n}\n\nstatic int set_percent_time(struct perf_time_interval *ptime, double start_pcnt,\n\t\t\t    double end_pcnt, u64 start, u64 end)\n{\n\tu64 total = end - start;\n\n\tif (start_pcnt < 0.0 || start_pcnt > 1.0 ||\n\t    end_pcnt < 0.0 || end_pcnt > 1.0) {\n\t\treturn -1;\n\t}\n\n\tptime->start = start + round(start_pcnt * total);\n\tptime->end = start + round(end_pcnt * total);\n\n\tif (ptime->end > ptime->start && ptime->end != end)\n\t\tptime->end -= 1;\n\n\treturn 0;\n}\n\nstatic int percent_slash_split(char *str, struct perf_time_interval *ptime,\n\t\t\t       u64 start, u64 end)\n{\n\tchar *p, *end_str;\n\tdouble pcnt, start_pcnt, end_pcnt;\n\tint i;\n\n\t \n\n\t \n\tp = strchr(str, '/');\n\tif (!p)\n\t\treturn -1;\n\n\t*p = '\\0';\n\tif (parse_percent(&pcnt, str) < 0)\n\t\treturn -1;\n\n\tp++;\n\ti = (int)strtol(p, &end_str, 10);\n\tif (*end_str)\n\t\treturn -1;\n\n\tif (pcnt <= 0.0)\n\t\treturn -1;\n\n\tstart_pcnt = pcnt * (i - 1);\n\tend_pcnt = pcnt * i;\n\n\treturn set_percent_time(ptime, start_pcnt, end_pcnt, start, end);\n}\n\nstatic int percent_dash_split(char *str, struct perf_time_interval *ptime,\n\t\t\t      u64 start, u64 end)\n{\n\tchar *start_str = NULL, *end_str;\n\tdouble start_pcnt, end_pcnt;\n\tint ret;\n\n\t \n\n\tret = split_start_end(&start_str, &end_str, str, '-');\n\tif (ret || !start_str)\n\t\treturn ret;\n\n\tif ((parse_percent(&start_pcnt, start_str) != 0) ||\n\t    (parse_percent(&end_pcnt, end_str) != 0)) {\n\t\tfree(start_str);\n\t\treturn -1;\n\t}\n\n\tfree(start_str);\n\n\treturn set_percent_time(ptime, start_pcnt, end_pcnt, start, end);\n}\n\ntypedef int (*time_pecent_split)(char *, struct perf_time_interval *,\n\t\t\t\t u64 start, u64 end);\n\nstatic int percent_comma_split(struct perf_time_interval *ptime_buf, int num,\n\t\t\t       const char *ostr, u64 start, u64 end,\n\t\t\t       time_pecent_split func)\n{\n\tchar *str, *p1, *p2;\n\tint len, ret, i = 0;\n\n\tstr = strdup(ostr);\n\tif (str == NULL)\n\t\treturn -ENOMEM;\n\n\tlen = strlen(str);\n\tp1 = str;\n\n\twhile (p1 < str + len) {\n\t\tif (i >= num) {\n\t\t\tfree(str);\n\t\t\treturn -1;\n\t\t}\n\n\t\tp2 = strchr(p1, ',');\n\t\tif (p2)\n\t\t\t*p2 = '\\0';\n\n\t\tret = (func)(p1, &ptime_buf[i], start, end);\n\t\tif (ret < 0) {\n\t\t\tfree(str);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpr_debug(\"start time %d: %\" PRIu64 \", \", i, ptime_buf[i].start);\n\t\tpr_debug(\"end time %d: %\" PRIu64 \"\\n\", i, ptime_buf[i].end);\n\n\t\ti++;\n\n\t\tif (p2)\n\t\t\tp1 = p2 + 1;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tfree(str);\n\treturn i;\n}\n\nstatic int one_percent_convert(struct perf_time_interval *ptime_buf,\n\t\t\t       const char *ostr, u64 start, u64 end, char *c)\n{\n\tchar *str;\n\tint len = strlen(ostr), ret;\n\n\t \n\tif (ostr + len - 1 != c)\n\t\treturn -1;\n\n\t \n\tstr = malloc(len + 3);\n\tif (str == NULL)\n\t\treturn -ENOMEM;\n\n\tmemcpy(str, ostr, len);\n\tstrcpy(str + len, \"/1\");\n\n\tret = percent_slash_split(str, ptime_buf, start, end);\n\tif (ret == 0)\n\t\tret = 1;\n\n\tfree(str);\n\treturn ret;\n}\n\nint perf_time__percent_parse_str(struct perf_time_interval *ptime_buf, int num,\n\t\t\t\t const char *ostr, u64 start, u64 end)\n{\n\tchar *c;\n\n\t \n\n\tmemset(ptime_buf, 0, sizeof(*ptime_buf) * num);\n\n\tc = strchr(ostr, '/');\n\tif (c) {\n\t\treturn percent_comma_split(ptime_buf, num, ostr, start,\n\t\t\t\t\t   end, percent_slash_split);\n\t}\n\n\tc = strchr(ostr, '-');\n\tif (c) {\n\t\treturn percent_comma_split(ptime_buf, num, ostr, start,\n\t\t\t\t\t   end, percent_dash_split);\n\t}\n\n\tc = strchr(ostr, '%');\n\tif (c)\n\t\treturn one_percent_convert(ptime_buf, ostr, start, end, c);\n\n\treturn -1;\n}\n\nstruct perf_time_interval *perf_time__range_alloc(const char *ostr, int *size)\n{\n\tconst char *p1, *p2;\n\tint i = 1;\n\tstruct perf_time_interval *ptime;\n\n\t \n\tif (!ostr)\n\t\tgoto alloc;\n\n\tp1 = ostr;\n\twhile (p1 < ostr + strlen(ostr)) {\n\t\tp2 = strchr(p1, ',');\n\t\tif (!p2)\n\t\t\tbreak;\n\n\t\tp1 = p2 + 1;\n\t\ti++;\n\t}\n\nalloc:\n\t*size = i;\n\tptime = calloc(i, sizeof(*ptime));\n\treturn ptime;\n}\n\nbool perf_time__skip_sample(struct perf_time_interval *ptime, u64 timestamp)\n{\n\t \n\tif (timestamp == 0)\n\t\treturn false;\n\n\t \n\tif ((ptime->start && timestamp < ptime->start) ||\n\t    (ptime->end && timestamp > ptime->end)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool perf_time__ranges_skip_sample(struct perf_time_interval *ptime_buf,\n\t\t\t\t   int num, u64 timestamp)\n{\n\tstruct perf_time_interval *ptime;\n\tint i;\n\n\tif ((!ptime_buf) || (timestamp == 0) || (num == 0))\n\t\treturn false;\n\n\tif (num == 1)\n\t\treturn perf_time__skip_sample(&ptime_buf[0], timestamp);\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tptime = &ptime_buf[i];\n\n\t\tif (timestamp >= ptime->start &&\n\t\t    (timestamp <= ptime->end || !ptime->end)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint perf_time__parse_for_ranges_reltime(const char *time_str,\n\t\t\t\tstruct perf_session *session,\n\t\t\t\tstruct perf_time_interval **ranges,\n\t\t\t\tint *range_size, int *range_num,\n\t\t\t\tbool reltime)\n{\n\tbool has_percent = strchr(time_str, '%');\n\tstruct perf_time_interval *ptime_range;\n\tint size, num, ret = -EINVAL;\n\n\tptime_range = perf_time__range_alloc(time_str, &size);\n\tif (!ptime_range)\n\t\treturn -ENOMEM;\n\n\tif (has_percent || reltime) {\n\t\tif (session->evlist->first_sample_time == 0 &&\n\t\t    session->evlist->last_sample_time == 0) {\n\t\t\tpr_err(\"HINT: no first/last sample time found in perf data.\\n\"\n\t\t\t       \"Please use latest perf binary to execute 'perf record'\\n\"\n\t\t\t       \"(if '--buildid-all' is enabled, please set '--timestamp-boundary').\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (has_percent) {\n\t\tnum = perf_time__percent_parse_str(\n\t\t\t\tptime_range, size,\n\t\t\t\ttime_str,\n\t\t\t\tsession->evlist->first_sample_time,\n\t\t\t\tsession->evlist->last_sample_time);\n\t} else {\n\t\tnum = perf_time__parse_strs(ptime_range, time_str, size);\n\t}\n\n\tif (num < 0)\n\t\tgoto error_invalid;\n\n\tif (reltime) {\n\t\tint i;\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tptime_range[i].start += session->evlist->first_sample_time;\n\t\t\tptime_range[i].end += session->evlist->first_sample_time;\n\t\t}\n\t}\n\n\t*range_size = size;\n\t*range_num = num;\n\t*ranges = ptime_range;\n\treturn 0;\n\nerror_invalid:\n\tpr_err(\"Invalid time string\\n\");\nerror:\n\tfree(ptime_range);\n\treturn ret;\n}\n\nint perf_time__parse_for_ranges(const char *time_str,\n\t\t\t\tstruct perf_session *session,\n\t\t\t\tstruct perf_time_interval **ranges,\n\t\t\t\tint *range_size, int *range_num)\n{\n\treturn perf_time__parse_for_ranges_reltime(time_str, session, ranges,\n\t\t\t\t\trange_size, range_num, false);\n}\n\nint timestamp__scnprintf_usec(u64 timestamp, char *buf, size_t sz)\n{\n\tu64  sec = timestamp / NSEC_PER_SEC;\n\tu64 usec = (timestamp % NSEC_PER_SEC) / NSEC_PER_USEC;\n\n\treturn scnprintf(buf, sz, \"%\"PRIu64\".%06\"PRIu64, sec, usec);\n}\n\nint timestamp__scnprintf_nsec(u64 timestamp, char *buf, size_t sz)\n{\n\tu64 sec  = timestamp / NSEC_PER_SEC,\n\t    nsec = timestamp % NSEC_PER_SEC;\n\n\treturn scnprintf(buf, sz, \"%\" PRIu64 \".%09\" PRIu64, sec, nsec);\n}\n\nint fetch_current_timestamp(char *buf, size_t sz)\n{\n\tstruct timeval tv;\n\tstruct tm tm;\n\tchar dt[32];\n\n\tif (gettimeofday(&tv, NULL) || !localtime_r(&tv.tv_sec, &tm))\n\t\treturn -1;\n\n\tif (!strftime(dt, sizeof(dt), \"%Y%m%d%H%M%S\", &tm))\n\t\treturn -1;\n\n\tscnprintf(buf, sz, \"%s%02u\", dt, (unsigned)tv.tv_usec / 10000);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}