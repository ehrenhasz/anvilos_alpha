{
  "module_name": "svghelper.c",
  "hash_id": "04153d531762d3733f8faa208ab764724e9eb88dafe1b9725fd05db31ef855cc",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/svghelper.c",
  "human_readable_source": "\n \n\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <linux/bitmap.h>\n#include <linux/string.h>\n#include <linux/time64.h>\n#include <linux/zalloc.h>\n#include <internal/cpumap.h>\n#include <perf/cpumap.h>\n\n#include \"env.h\"\n#include \"svghelper.h\"\n\nstatic u64 first_time, last_time;\nstatic u64 turbo_frequency, max_freq;\n\n\n#define SLOT_MULT 30.0\n#define SLOT_HEIGHT 25.0\n#define SLOT_HALF (SLOT_HEIGHT / 2)\n\nint svg_page_width = 1000;\nu64 svg_highlight;\nconst char *svg_highlight_name;\n\n#define MIN_TEXT_SIZE 0.01\n\nstatic u64 total_height;\nstatic FILE *svgfile;\n\nstatic double cpu2slot(int cpu)\n{\n\treturn 2 * cpu + 1;\n}\n\nstatic int *topology_map;\n\nstatic double cpu2y(int cpu)\n{\n\tif (topology_map)\n\t\treturn cpu2slot(topology_map[cpu]) * SLOT_MULT;\n\telse\n\t\treturn cpu2slot(cpu) * SLOT_MULT;\n}\n\nstatic double time2pixels(u64 __time)\n{\n\tdouble X;\n\n\tX = 1.0 * svg_page_width * (__time - first_time) / (last_time - first_time);\n\treturn X;\n}\n\n \nstatic double round_text_size(double size)\n{\n\tint loop = 100;\n\tdouble target = 10.0;\n\n\tif (size >= 10.0)\n\t\treturn size;\n\twhile (loop--) {\n\t\tif (size >= target)\n\t\t\treturn target;\n\t\ttarget = target / 2.0;\n\t}\n\treturn size;\n}\n\nvoid open_svg(const char *filename, int cpus, int rows, u64 start, u64 end)\n{\n\tint new_width;\n\n\tsvgfile = fopen(filename, \"w\");\n\tif (!svgfile) {\n\t\tfprintf(stderr, \"Cannot open %s for output\\n\", filename);\n\t\treturn;\n\t}\n\tfirst_time = start;\n\tfirst_time = first_time / 100000000 * 100000000;\n\tlast_time = end;\n\n\t \n\tnew_width = (last_time - first_time) / 5000000;\n\n\tif (new_width > svg_page_width)\n\t\tsvg_page_width = new_width;\n\n\ttotal_height = (1 + rows + cpu2slot(cpus)) * SLOT_MULT;\n\tfprintf(svgfile, \"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\"?> \\n\");\n\tfprintf(svgfile, \"<!DOCTYPE svg SYSTEM \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\\n\");\n\tfprintf(svgfile, \"<svg width=\\\"%i\\\" height=\\\"%\" PRIu64 \"\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\", svg_page_width, total_height);\n\n\tfprintf(svgfile, \"<defs>\\n  <style type=\\\"text/css\\\">\\n    <![CDATA[\\n\");\n\n\tfprintf(svgfile, \"      rect          { stroke-width: 1; }\\n\");\n\tfprintf(svgfile, \"      rect.process  { fill:rgb(180,180,180); fill-opacity:0.9; stroke-width:1;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.process2 { fill:rgb(180,180,180); fill-opacity:0.9; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.process3 { fill:rgb(180,180,180); fill-opacity:0.5; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.sample   { fill:rgb(  0,  0,255); fill-opacity:0.8; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.sample_hi{ fill:rgb(255,128,  0); fill-opacity:0.8; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.error    { fill:rgb(255,  0,  0); fill-opacity:0.5; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.net      { fill:rgb(  0,128,  0); fill-opacity:0.5; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.disk     { fill:rgb(  0,  0,255); fill-opacity:0.5; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.sync     { fill:rgb(128,128,  0); fill-opacity:0.5; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.poll     { fill:rgb(  0,128,128); fill-opacity:0.2; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.blocked  { fill:rgb(255,  0,  0); fill-opacity:0.5; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.waiting  { fill:rgb(224,214,  0); fill-opacity:0.8; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.WAITING  { fill:rgb(255,214, 48); fill-opacity:0.6; stroke-width:0;   stroke:rgb(  0,  0,  0); } \\n\");\n\tfprintf(svgfile, \"      rect.cpu      { fill:rgb(192,192,192); fill-opacity:0.2; stroke-width:0.5; stroke:rgb(128,128,128); } \\n\");\n\tfprintf(svgfile, \"      rect.pstate   { fill:rgb(128,128,128); fill-opacity:0.8; stroke-width:0; } \\n\");\n\tfprintf(svgfile, \"      rect.c1       { fill:rgb(255,214,214); fill-opacity:0.5; stroke-width:0; } \\n\");\n\tfprintf(svgfile, \"      rect.c2       { fill:rgb(255,172,172); fill-opacity:0.5; stroke-width:0; } \\n\");\n\tfprintf(svgfile, \"      rect.c3       { fill:rgb(255,130,130); fill-opacity:0.5; stroke-width:0; } \\n\");\n\tfprintf(svgfile, \"      rect.c4       { fill:rgb(255, 88, 88); fill-opacity:0.5; stroke-width:0; } \\n\");\n\tfprintf(svgfile, \"      rect.c5       { fill:rgb(255, 44, 44); fill-opacity:0.5; stroke-width:0; } \\n\");\n\tfprintf(svgfile, \"      rect.c6       { fill:rgb(255,  0,  0); fill-opacity:0.5; stroke-width:0; } \\n\");\n\tfprintf(svgfile, \"      line.pstate   { stroke:rgb(255,255,  0); stroke-opacity:0.8; stroke-width:2; } \\n\");\n\n\tfprintf(svgfile, \"    ]]>\\n   </style>\\n</defs>\\n\");\n}\n\nstatic double normalize_height(double height)\n{\n\tif (height < 0.25)\n\t\treturn 0.25;\n\telse if (height < 0.50)\n\t\treturn 0.50;\n\telse if (height < 0.75)\n\t\treturn 0.75;\n\telse\n\t\treturn 0.100;\n}\n\nvoid svg_ubox(int Yslot, u64 start, u64 end, double height, const char *type, int fd, int err, int merges)\n{\n\tdouble w = time2pixels(end) - time2pixels(start);\n\theight = normalize_height(height);\n\n\tif (!svgfile)\n\t\treturn;\n\n\tfprintf(svgfile, \"<g>\\n\");\n\tfprintf(svgfile, \"<title>fd=%d error=%d merges=%d</title>\\n\", fd, err, merges);\n\tfprintf(svgfile, \"<rect x=\\\"%.8f\\\" width=\\\"%.8f\\\" y=\\\"%.1f\\\" height=\\\"%.1f\\\" class=\\\"%s\\\"/>\\n\",\n\t\ttime2pixels(start),\n\t\tw,\n\t\tYslot * SLOT_MULT,\n\t\tSLOT_HALF * height,\n\t\ttype);\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nvoid svg_lbox(int Yslot, u64 start, u64 end, double height, const char *type, int fd, int err, int merges)\n{\n\tdouble w = time2pixels(end) - time2pixels(start);\n\theight = normalize_height(height);\n\n\tif (!svgfile)\n\t\treturn;\n\n\tfprintf(svgfile, \"<g>\\n\");\n\tfprintf(svgfile, \"<title>fd=%d error=%d merges=%d</title>\\n\", fd, err, merges);\n\tfprintf(svgfile, \"<rect x=\\\"%.8f\\\" width=\\\"%.8f\\\" y=\\\"%.1f\\\" height=\\\"%.1f\\\" class=\\\"%s\\\"/>\\n\",\n\t\ttime2pixels(start),\n\t\tw,\n\t\tYslot * SLOT_MULT + SLOT_HEIGHT - SLOT_HALF * height,\n\t\tSLOT_HALF * height,\n\t\ttype);\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nvoid svg_fbox(int Yslot, u64 start, u64 end, double height, const char *type, int fd, int err, int merges)\n{\n\tdouble w = time2pixels(end) - time2pixels(start);\n\theight = normalize_height(height);\n\n\tif (!svgfile)\n\t\treturn;\n\n\tfprintf(svgfile, \"<g>\\n\");\n\tfprintf(svgfile, \"<title>fd=%d error=%d merges=%d</title>\\n\", fd, err, merges);\n\tfprintf(svgfile, \"<rect x=\\\"%.8f\\\" width=\\\"%.8f\\\" y=\\\"%.1f\\\" height=\\\"%.1f\\\" class=\\\"%s\\\"/>\\n\",\n\t\ttime2pixels(start),\n\t\tw,\n\t\tYslot * SLOT_MULT + SLOT_HEIGHT - SLOT_HEIGHT * height,\n\t\tSLOT_HEIGHT * height,\n\t\ttype);\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nvoid svg_box(int Yslot, u64 start, u64 end, const char *type)\n{\n\tif (!svgfile)\n\t\treturn;\n\n\tfprintf(svgfile, \"<rect x=\\\"%.8f\\\" width=\\\"%.8f\\\" y=\\\"%.1f\\\" height=\\\"%.1f\\\" class=\\\"%s\\\"/>\\n\",\n\t\ttime2pixels(start), time2pixels(end)-time2pixels(start), Yslot * SLOT_MULT, SLOT_HEIGHT, type);\n}\n\nstatic char *time_to_string(u64 duration);\nvoid svg_blocked(int Yslot, int cpu, u64 start, u64 end, const char *backtrace)\n{\n\tif (!svgfile)\n\t\treturn;\n\n\tfprintf(svgfile, \"<g>\\n\");\n\tfprintf(svgfile, \"<title>#%d blocked %s</title>\\n\", cpu,\n\t\ttime_to_string(end - start));\n\tif (backtrace)\n\t\tfprintf(svgfile, \"<desc>Blocked on:\\n%s</desc>\\n\", backtrace);\n\tsvg_box(Yslot, start, end, \"blocked\");\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nvoid svg_running(int Yslot, int cpu, u64 start, u64 end, const char *backtrace)\n{\n\tdouble text_size;\n\tconst char *type;\n\n\tif (!svgfile)\n\t\treturn;\n\n\tif (svg_highlight && end - start > svg_highlight)\n\t\ttype = \"sample_hi\";\n\telse\n\t\ttype = \"sample\";\n\tfprintf(svgfile, \"<g>\\n\");\n\n\tfprintf(svgfile, \"<title>#%d running %s</title>\\n\",\n\t\tcpu, time_to_string(end - start));\n\tif (backtrace)\n\t\tfprintf(svgfile, \"<desc>Switched because:\\n%s</desc>\\n\", backtrace);\n\tfprintf(svgfile, \"<rect x=\\\"%.8f\\\" width=\\\"%.8f\\\" y=\\\"%.1f\\\" height=\\\"%.1f\\\" class=\\\"%s\\\"/>\\n\",\n\t\ttime2pixels(start), time2pixels(end)-time2pixels(start), Yslot * SLOT_MULT, SLOT_HEIGHT,\n\t\ttype);\n\n\ttext_size = (time2pixels(end)-time2pixels(start));\n\tif (cpu > 9)\n\t\ttext_size = text_size/2;\n\tif (text_size > 1.25)\n\t\ttext_size = 1.25;\n\ttext_size = round_text_size(text_size);\n\n\tif (text_size > MIN_TEXT_SIZE)\n\t\tfprintf(svgfile, \"<text x=\\\"%.8f\\\" y=\\\"%.8f\\\" font-size=\\\"%.8fpt\\\">%i</text>\\n\",\n\t\t\ttime2pixels(start), Yslot *  SLOT_MULT + SLOT_HEIGHT - 1, text_size,  cpu + 1);\n\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nstatic char *time_to_string(u64 duration)\n{\n\tstatic char text[80];\n\n\ttext[0] = 0;\n\n\tif (duration < NSEC_PER_USEC)  \n\t\treturn text;\n\n\tif (duration < NSEC_PER_MSEC) {  \n\t\tsprintf(text, \"%.1f us\", duration / (double)NSEC_PER_USEC);\n\t\treturn text;\n\t}\n\tsprintf(text, \"%.1f ms\", duration / (double)NSEC_PER_MSEC);\n\n\treturn text;\n}\n\nvoid svg_waiting(int Yslot, int cpu, u64 start, u64 end, const char *backtrace)\n{\n\tchar *text;\n\tconst char *style;\n\tdouble font_size;\n\n\tif (!svgfile)\n\t\treturn;\n\n\tstyle = \"waiting\";\n\n\tif (end-start > 10 * NSEC_PER_MSEC)  \n\t\tstyle = \"WAITING\";\n\n\ttext = time_to_string(end-start);\n\n\tfont_size = 1.0 * (time2pixels(end)-time2pixels(start));\n\n\tif (font_size > 3)\n\t\tfont_size = 3;\n\n\tfont_size = round_text_size(font_size);\n\n\tfprintf(svgfile, \"<g transform=\\\"translate(%.8f,%.8f)\\\">\\n\", time2pixels(start), Yslot * SLOT_MULT);\n\tfprintf(svgfile, \"<title>#%d waiting %s</title>\\n\", cpu, time_to_string(end - start));\n\tif (backtrace)\n\t\tfprintf(svgfile, \"<desc>Waiting on:\\n%s</desc>\\n\", backtrace);\n\tfprintf(svgfile, \"<rect x=\\\"0\\\" width=\\\"%.8f\\\" y=\\\"0\\\" height=\\\"%.1f\\\" class=\\\"%s\\\"/>\\n\",\n\t\ttime2pixels(end)-time2pixels(start), SLOT_HEIGHT, style);\n\tif (font_size > MIN_TEXT_SIZE)\n\t\tfprintf(svgfile, \"<text transform=\\\"rotate(90)\\\" font-size=\\\"%.8fpt\\\"> %s</text>\\n\",\n\t\t\tfont_size, text);\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nstatic char *cpu_model(void)\n{\n\tstatic char cpu_m[255];\n\tchar buf[256];\n\tFILE *file;\n\n\tcpu_m[0] = 0;\n\t \n\tfile = fopen(\"/proc/cpuinfo\", \"r\");\n\tif (file) {\n\t\twhile (fgets(buf, 255, file)) {\n\t\t\tif (strcasestr(buf, \"model name\")) {\n\t\t\t\tstrlcpy(cpu_m, &buf[13], 255);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t}\n\n\t \n\tfile = fopen(\"/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies\", \"r\");\n\tif (file) {\n\t\twhile (fgets(buf, 255, file)) {\n\t\t\tunsigned int freq;\n\t\t\tfreq = strtoull(buf, NULL, 10);\n\t\t\tif (freq > max_freq)\n\t\t\t\tmax_freq = freq;\n\t\t}\n\t\tfclose(file);\n\t}\n\treturn cpu_m;\n}\n\nvoid svg_cpu_box(int cpu, u64 __max_freq, u64 __turbo_freq)\n{\n\tchar cpu_string[80];\n\tif (!svgfile)\n\t\treturn;\n\n\tmax_freq = __max_freq;\n\tturbo_frequency = __turbo_freq;\n\n\tfprintf(svgfile, \"<g>\\n\");\n\n\tfprintf(svgfile, \"<rect x=\\\"%.8f\\\" width=\\\"%.8f\\\" y=\\\"%.1f\\\" height=\\\"%.1f\\\" class=\\\"cpu\\\"/>\\n\",\n\t\ttime2pixels(first_time),\n\t\ttime2pixels(last_time)-time2pixels(first_time),\n\t\tcpu2y(cpu), SLOT_MULT+SLOT_HEIGHT);\n\n\tsprintf(cpu_string, \"CPU %i\", (int)cpu);\n\tfprintf(svgfile, \"<text x=\\\"%.8f\\\" y=\\\"%.8f\\\">%s</text>\\n\",\n\t\t10+time2pixels(first_time), cpu2y(cpu) + SLOT_HEIGHT/2, cpu_string);\n\n\tfprintf(svgfile, \"<text transform=\\\"translate(%.8f,%.8f)\\\" font-size=\\\"1.25pt\\\">%s</text>\\n\",\n\t\t10+time2pixels(first_time), cpu2y(cpu) + SLOT_MULT + SLOT_HEIGHT - 4, cpu_model());\n\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nvoid svg_process(int cpu, u64 start, u64 end, int pid, const char *name, const char *backtrace)\n{\n\tdouble width;\n\tconst char *type;\n\n\tif (!svgfile)\n\t\treturn;\n\n\tif (svg_highlight && end - start >= svg_highlight)\n\t\ttype = \"sample_hi\";\n\telse if (svg_highlight_name && strstr(name, svg_highlight_name))\n\t\ttype = \"sample_hi\";\n\telse\n\t\ttype = \"sample\";\n\n\tfprintf(svgfile, \"<g transform=\\\"translate(%.8f,%.8f)\\\">\\n\", time2pixels(start), cpu2y(cpu));\n\tfprintf(svgfile, \"<title>%d %s running %s</title>\\n\", pid, name, time_to_string(end - start));\n\tif (backtrace)\n\t\tfprintf(svgfile, \"<desc>Switched because:\\n%s</desc>\\n\", backtrace);\n\tfprintf(svgfile, \"<rect x=\\\"0\\\" width=\\\"%.8f\\\" y=\\\"0\\\" height=\\\"%.1f\\\" class=\\\"%s\\\"/>\\n\",\n\t\ttime2pixels(end)-time2pixels(start), SLOT_MULT+SLOT_HEIGHT, type);\n\twidth = time2pixels(end)-time2pixels(start);\n\tif (width > 6)\n\t\twidth = 6;\n\n\twidth = round_text_size(width);\n\n\tif (width > MIN_TEXT_SIZE)\n\t\tfprintf(svgfile, \"<text transform=\\\"rotate(90)\\\" font-size=\\\"%.8fpt\\\">%s</text>\\n\",\n\t\t\twidth, name);\n\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nvoid svg_cstate(int cpu, u64 start, u64 end, int type)\n{\n\tdouble width;\n\tchar style[128];\n\n\tif (!svgfile)\n\t\treturn;\n\n\n\tfprintf(svgfile, \"<g>\\n\");\n\n\tif (type > 6)\n\t\ttype = 6;\n\tsprintf(style, \"c%i\", type);\n\n\tfprintf(svgfile, \"<rect class=\\\"%s\\\" x=\\\"%.8f\\\" width=\\\"%.8f\\\" y=\\\"%.1f\\\" height=\\\"%.1f\\\"/>\\n\",\n\t\tstyle,\n\t\ttime2pixels(start), time2pixels(end)-time2pixels(start),\n\t\tcpu2y(cpu), SLOT_MULT+SLOT_HEIGHT);\n\n\twidth = (time2pixels(end)-time2pixels(start))/2.0;\n\tif (width > 6)\n\t\twidth = 6;\n\n\twidth = round_text_size(width);\n\n\tif (width > MIN_TEXT_SIZE)\n\t\tfprintf(svgfile, \"<text x=\\\"%.8f\\\" y=\\\"%.8f\\\" font-size=\\\"%.8fpt\\\">C%i</text>\\n\",\n\t\t\ttime2pixels(start), cpu2y(cpu)+width, width, type);\n\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nstatic char *HzToHuman(unsigned long hz)\n{\n\tstatic char buffer[1024];\n\tunsigned long long Hz;\n\n\tmemset(buffer, 0, 1024);\n\n\tHz = hz;\n\n\t \n\tsprintf(buffer, \"%9lli\", Hz);\n\n\tif (Hz > 1000)\n\t\tsprintf(buffer, \" %6lli Mhz\", (Hz+500)/1000);\n\n\tif (Hz > 1500000)\n\t\tsprintf(buffer, \" %6.2f Ghz\", (Hz+5000.0)/1000000);\n\n\tif (Hz == turbo_frequency)\n\t\tsprintf(buffer, \"Turbo\");\n\n\treturn buffer;\n}\n\nvoid svg_pstate(int cpu, u64 start, u64 end, u64 freq)\n{\n\tdouble height = 0;\n\n\tif (!svgfile)\n\t\treturn;\n\n\tfprintf(svgfile, \"<g>\\n\");\n\n\tif (max_freq)\n\t\theight = freq * 1.0 / max_freq * (SLOT_HEIGHT + SLOT_MULT);\n\theight = 1 + cpu2y(cpu) + SLOT_MULT + SLOT_HEIGHT - height;\n\tfprintf(svgfile, \"<line x1=\\\"%.8f\\\" x2=\\\"%.8f\\\" y1=\\\"%.1f\\\" y2=\\\"%.1f\\\" class=\\\"pstate\\\"/>\\n\",\n\t\ttime2pixels(start), time2pixels(end), height, height);\n\tfprintf(svgfile, \"<text x=\\\"%.8f\\\" y=\\\"%.8f\\\" font-size=\\\"0.25pt\\\">%s</text>\\n\",\n\t\ttime2pixels(start), height+0.9, HzToHuman(freq));\n\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\n\nvoid svg_partial_wakeline(u64 start, int row1, char *desc1, int row2, char *desc2, const char *backtrace)\n{\n\tdouble height;\n\n\tif (!svgfile)\n\t\treturn;\n\n\n\tfprintf(svgfile, \"<g>\\n\");\n\n\tfprintf(svgfile, \"<title>%s wakes up %s</title>\\n\",\n\t\tdesc1 ? desc1 : \"?\",\n\t\tdesc2 ? desc2 : \"?\");\n\n\tif (backtrace)\n\t\tfprintf(svgfile, \"<desc>%s</desc>\\n\", backtrace);\n\n\tif (row1 < row2) {\n\t\tif (row1) {\n\t\t\tfprintf(svgfile, \"<line x1=\\\"%.8f\\\" y1=\\\"%.2f\\\" x2=\\\"%.8f\\\" y2=\\\"%.2f\\\" style=\\\"stroke:rgb(32,255,32);stroke-width:0.009\\\"/>\\n\",\n\t\t\t\ttime2pixels(start), row1 * SLOT_MULT + SLOT_HEIGHT,  time2pixels(start), row1 * SLOT_MULT + SLOT_HEIGHT + SLOT_MULT/32);\n\t\t\tif (desc2)\n\t\t\t\tfprintf(svgfile, \"<g transform=\\\"translate(%.8f,%.8f)\\\"><text transform=\\\"rotate(90)\\\" font-size=\\\"0.02pt\\\">%s &gt;</text></g>\\n\",\n\t\t\t\t\ttime2pixels(start), row1 * SLOT_MULT + SLOT_HEIGHT + SLOT_HEIGHT/48, desc2);\n\t\t}\n\t\tif (row2) {\n\t\t\tfprintf(svgfile, \"<line x1=\\\"%.8f\\\" y1=\\\"%.2f\\\" x2=\\\"%.8f\\\" y2=\\\"%.2f\\\" style=\\\"stroke:rgb(32,255,32);stroke-width:0.009\\\"/>\\n\",\n\t\t\t\ttime2pixels(start), row2 * SLOT_MULT - SLOT_MULT/32,  time2pixels(start), row2 * SLOT_MULT);\n\t\t\tif (desc1)\n\t\t\t\tfprintf(svgfile, \"<g transform=\\\"translate(%.8f,%.8f)\\\"><text transform=\\\"rotate(90)\\\" font-size=\\\"0.02pt\\\">%s &gt;</text></g>\\n\",\n\t\t\t\t\ttime2pixels(start), row2 * SLOT_MULT - SLOT_MULT/32, desc1);\n\t\t}\n\t} else {\n\t\tif (row2) {\n\t\t\tfprintf(svgfile, \"<line x1=\\\"%.8f\\\" y1=\\\"%.2f\\\" x2=\\\"%.8f\\\" y2=\\\"%.2f\\\" style=\\\"stroke:rgb(32,255,32);stroke-width:0.009\\\"/>\\n\",\n\t\t\t\ttime2pixels(start), row2 * SLOT_MULT + SLOT_HEIGHT,  time2pixels(start), row2 * SLOT_MULT + SLOT_HEIGHT + SLOT_MULT/32);\n\t\t\tif (desc1)\n\t\t\t\tfprintf(svgfile, \"<g transform=\\\"translate(%.8f,%.8f)\\\"><text transform=\\\"rotate(90)\\\" font-size=\\\"0.02pt\\\">%s &lt;</text></g>\\n\",\n\t\t\t\t\ttime2pixels(start), row2 * SLOT_MULT + SLOT_HEIGHT + SLOT_MULT/48, desc1);\n\t\t}\n\t\tif (row1) {\n\t\t\tfprintf(svgfile, \"<line x1=\\\"%.8f\\\" y1=\\\"%.2f\\\" x2=\\\"%.8f\\\" y2=\\\"%.2f\\\" style=\\\"stroke:rgb(32,255,32);stroke-width:0.009\\\"/>\\n\",\n\t\t\t\ttime2pixels(start), row1 * SLOT_MULT - SLOT_MULT/32,  time2pixels(start), row1 * SLOT_MULT);\n\t\t\tif (desc2)\n\t\t\t\tfprintf(svgfile, \"<g transform=\\\"translate(%.8f,%.8f)\\\"><text transform=\\\"rotate(90)\\\" font-size=\\\"0.02pt\\\">%s &lt;</text></g>\\n\",\n\t\t\t\t\ttime2pixels(start), row1 * SLOT_MULT - SLOT_HEIGHT/32, desc2);\n\t\t}\n\t}\n\theight = row1 * SLOT_MULT;\n\tif (row2 > row1)\n\t\theight += SLOT_HEIGHT;\n\tif (row1)\n\t\tfprintf(svgfile, \"<circle  cx=\\\"%.8f\\\" cy=\\\"%.2f\\\" r = \\\"0.01\\\"  style=\\\"fill:rgb(32,255,32)\\\"/>\\n\",\n\t\t\ttime2pixels(start), height);\n\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nvoid svg_wakeline(u64 start, int row1, int row2, const char *backtrace)\n{\n\tdouble height;\n\n\tif (!svgfile)\n\t\treturn;\n\n\n\tfprintf(svgfile, \"<g>\\n\");\n\n\tif (backtrace)\n\t\tfprintf(svgfile, \"<desc>%s</desc>\\n\", backtrace);\n\n\tif (row1 < row2)\n\t\tfprintf(svgfile, \"<line x1=\\\"%.8f\\\" y1=\\\"%.2f\\\" x2=\\\"%.8f\\\" y2=\\\"%.2f\\\" style=\\\"stroke:rgb(32,255,32);stroke-width:0.009\\\"/>\\n\",\n\t\t\ttime2pixels(start), row1 * SLOT_MULT + SLOT_HEIGHT,  time2pixels(start), row2 * SLOT_MULT);\n\telse\n\t\tfprintf(svgfile, \"<line x1=\\\"%.8f\\\" y1=\\\"%.2f\\\" x2=\\\"%.8f\\\" y2=\\\"%.2f\\\" style=\\\"stroke:rgb(32,255,32);stroke-width:0.009\\\"/>\\n\",\n\t\t\ttime2pixels(start), row2 * SLOT_MULT + SLOT_HEIGHT,  time2pixels(start), row1 * SLOT_MULT);\n\n\theight = row1 * SLOT_MULT;\n\tif (row2 > row1)\n\t\theight += SLOT_HEIGHT;\n\tfprintf(svgfile, \"<circle  cx=\\\"%.8f\\\" cy=\\\"%.2f\\\" r = \\\"0.01\\\"  style=\\\"fill:rgb(32,255,32)\\\"/>\\n\",\n\t\t\ttime2pixels(start), height);\n\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nvoid svg_interrupt(u64 start, int row, const char *backtrace)\n{\n\tif (!svgfile)\n\t\treturn;\n\n\tfprintf(svgfile, \"<g>\\n\");\n\n\tfprintf(svgfile, \"<title>Wakeup from interrupt</title>\\n\");\n\n\tif (backtrace)\n\t\tfprintf(svgfile, \"<desc>%s</desc>\\n\", backtrace);\n\n\tfprintf(svgfile, \"<circle  cx=\\\"%.8f\\\" cy=\\\"%.2f\\\" r = \\\"0.01\\\"  style=\\\"fill:rgb(255,128,128)\\\"/>\\n\",\n\t\t\ttime2pixels(start), row * SLOT_MULT);\n\tfprintf(svgfile, \"<circle  cx=\\\"%.8f\\\" cy=\\\"%.2f\\\" r = \\\"0.01\\\"  style=\\\"fill:rgb(255,128,128)\\\"/>\\n\",\n\t\t\ttime2pixels(start), row * SLOT_MULT + SLOT_HEIGHT);\n\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nvoid svg_text(int Yslot, u64 start, const char *text)\n{\n\tif (!svgfile)\n\t\treturn;\n\n\tfprintf(svgfile, \"<text x=\\\"%.8f\\\" y=\\\"%.8f\\\">%s</text>\\n\",\n\t\ttime2pixels(start), Yslot * SLOT_MULT+SLOT_HEIGHT/2, text);\n}\n\nstatic void svg_legenda_box(int X, const char *text, const char *style)\n{\n\tdouble boxsize;\n\tboxsize = SLOT_HEIGHT / 2;\n\n\tfprintf(svgfile, \"<rect x=\\\"%i\\\" width=\\\"%.8f\\\" y=\\\"0\\\" height=\\\"%.1f\\\" class=\\\"%s\\\"/>\\n\",\n\t\tX, boxsize, boxsize, style);\n\tfprintf(svgfile, \"<text transform=\\\"translate(%.8f, %.8f)\\\" font-size=\\\"%.8fpt\\\">%s</text>\\n\",\n\t\tX + boxsize + 5, boxsize, 0.8 * boxsize, text);\n}\n\nvoid svg_io_legenda(void)\n{\n\tif (!svgfile)\n\t\treturn;\n\n\tfprintf(svgfile, \"<g>\\n\");\n\tsvg_legenda_box(0,\t\"Disk\", \"disk\");\n\tsvg_legenda_box(100,\t\"Network\", \"net\");\n\tsvg_legenda_box(200,\t\"Sync\", \"sync\");\n\tsvg_legenda_box(300,\t\"Poll\", \"poll\");\n\tsvg_legenda_box(400,\t\"Error\", \"error\");\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nvoid svg_legenda(void)\n{\n\tif (!svgfile)\n\t\treturn;\n\n\tfprintf(svgfile, \"<g>\\n\");\n\tsvg_legenda_box(0,\t\"Running\", \"sample\");\n\tsvg_legenda_box(100,\t\"Idle\",\"c1\");\n\tsvg_legenda_box(200,\t\"Deeper Idle\", \"c3\");\n\tsvg_legenda_box(350,\t\"Deepest Idle\", \"c6\");\n\tsvg_legenda_box(550,\t\"Sleeping\", \"process2\");\n\tsvg_legenda_box(650,\t\"Waiting for cpu\", \"waiting\");\n\tsvg_legenda_box(800,\t\"Blocked on IO\", \"blocked\");\n\tfprintf(svgfile, \"</g>\\n\");\n}\n\nvoid svg_time_grid(double min_thickness)\n{\n\tu64 i;\n\n\tif (!svgfile)\n\t\treturn;\n\n\ti = first_time;\n\twhile (i < last_time) {\n\t\tint color = 220;\n\t\tdouble thickness = 0.075;\n\t\tif ((i % 100000000) == 0) {\n\t\t\tthickness = 0.5;\n\t\t\tcolor = 192;\n\t\t}\n\t\tif ((i % 1000000000) == 0) {\n\t\t\tthickness = 2.0;\n\t\t\tcolor = 128;\n\t\t}\n\n\t\tif (thickness >= min_thickness)\n\t\t\tfprintf(svgfile, \"<line x1=\\\"%.8f\\\" y1=\\\"%.2f\\\" x2=\\\"%.8f\\\" y2=\\\"%\" PRIu64 \"\\\" style=\\\"stroke:rgb(%i,%i,%i);stroke-width:%.3f\\\"/>\\n\",\n\t\t\t\ttime2pixels(i), SLOT_MULT/2, time2pixels(i),\n\t\t\t\ttotal_height, color, color, color, thickness);\n\n\t\ti += 10000000;\n\t}\n}\n\nvoid svg_close(void)\n{\n\tif (svgfile) {\n\t\tfprintf(svgfile, \"</svg>\\n\");\n\t\tfclose(svgfile);\n\t\tsvgfile = NULL;\n\t}\n}\n\n#define cpumask_bits(maskp) ((maskp)->bits)\ntypedef struct { DECLARE_BITMAP(bits, MAX_NR_CPUS); } cpumask_t;\n\nstruct topology {\n\tcpumask_t *sib_core;\n\tint sib_core_nr;\n\tcpumask_t *sib_thr;\n\tint sib_thr_nr;\n};\n\nstatic void scan_thread_topology(int *map, struct topology *t, int cpu,\n\t\t\t\t int *pos, int nr_cpus)\n{\n\tint i;\n\tint thr;\n\n\tfor (i = 0; i < t->sib_thr_nr; i++) {\n\t\tif (!test_bit(cpu, cpumask_bits(&t->sib_thr[i])))\n\t\t\tcontinue;\n\n\t\tfor_each_set_bit(thr, cpumask_bits(&t->sib_thr[i]), nr_cpus)\n\t\t\tif (map[thr] == -1)\n\t\t\t\tmap[thr] = (*pos)++;\n\t}\n}\n\nstatic void scan_core_topology(int *map, struct topology *t, int nr_cpus)\n{\n\tint pos = 0;\n\tint i;\n\tint cpu;\n\n\tfor (i = 0; i < t->sib_core_nr; i++)\n\t\tfor_each_set_bit(cpu, cpumask_bits(&t->sib_core[i]), nr_cpus)\n\t\t\tscan_thread_topology(map, t, cpu, &pos, nr_cpus);\n}\n\nstatic int str_to_bitmap(char *s, cpumask_t *b, int nr_cpus)\n{\n\tint i;\n\tint ret = 0;\n\tstruct perf_cpu_map *m;\n\tstruct perf_cpu c;\n\n\tm = perf_cpu_map__new(s);\n\tif (!m)\n\t\treturn -1;\n\n\tfor (i = 0; i < perf_cpu_map__nr(m); i++) {\n\t\tc = perf_cpu_map__cpu(m, i);\n\t\tif (c.cpu >= nr_cpus) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t__set_bit(c.cpu, cpumask_bits(b));\n\t}\n\n\tperf_cpu_map__put(m);\n\n\treturn ret;\n}\n\nint svg_build_topology_map(struct perf_env *env)\n{\n\tint i, nr_cpus;\n\tstruct topology t;\n\tchar *sib_core, *sib_thr;\n\n\tnr_cpus = min(env->nr_cpus_online, MAX_NR_CPUS);\n\n\tt.sib_core_nr = env->nr_sibling_cores;\n\tt.sib_thr_nr = env->nr_sibling_threads;\n\tt.sib_core = calloc(env->nr_sibling_cores, sizeof(cpumask_t));\n\tt.sib_thr = calloc(env->nr_sibling_threads, sizeof(cpumask_t));\n\n\tsib_core = env->sibling_cores;\n\tsib_thr = env->sibling_threads;\n\n\tif (!t.sib_core || !t.sib_thr) {\n\t\tfprintf(stderr, \"topology: no memory\\n\");\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < env->nr_sibling_cores; i++) {\n\t\tif (str_to_bitmap(sib_core, &t.sib_core[i], nr_cpus)) {\n\t\t\tfprintf(stderr, \"topology: can't parse siblings map\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tsib_core += strlen(sib_core) + 1;\n\t}\n\n\tfor (i = 0; i < env->nr_sibling_threads; i++) {\n\t\tif (str_to_bitmap(sib_thr, &t.sib_thr[i], nr_cpus)) {\n\t\t\tfprintf(stderr, \"topology: can't parse siblings map\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tsib_thr += strlen(sib_thr) + 1;\n\t}\n\n\ttopology_map = malloc(sizeof(int) * nr_cpus);\n\tif (!topology_map) {\n\t\tfprintf(stderr, \"topology: no memory\\n\");\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < nr_cpus; i++)\n\t\ttopology_map[i] = -1;\n\n\tscan_core_topology(topology_map, &t, nr_cpus);\n\n\treturn 0;\n\nexit:\n\tzfree(&t.sib_core);\n\tzfree(&t.sib_thr);\n\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}