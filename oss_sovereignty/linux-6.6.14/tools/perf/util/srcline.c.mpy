{
  "module_name": "srcline.c",
  "hash_id": "4e2ac46729919ad87fcb8f8d16eede7dbe226557dbe6aef9080e0bb236a5eb36",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/srcline.c",
  "human_readable_source": "\n#include <inttypes.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n\n#include <api/io.h>\n\n#include \"util/dso.h\"\n#include \"util/debug.h\"\n#include \"util/callchain.h\"\n#include \"util/symbol_conf.h\"\n#include \"srcline.h\"\n#include \"string2.h\"\n#include \"symbol.h\"\n#include \"subcmd/run-command.h\"\n\n \nint addr2line_timeout_ms = 1 * 1000;\nbool srcline_full_filename;\n\nchar *srcline__unknown = (char *)\"??:0\";\n\nstatic const char *dso__name(struct dso *dso)\n{\n\tconst char *dso_name;\n\n\tif (dso->symsrc_filename)\n\t\tdso_name = dso->symsrc_filename;\n\telse\n\t\tdso_name = dso->long_name;\n\n\tif (dso_name[0] == '[')\n\t\treturn NULL;\n\n\tif (!strncmp(dso_name, \"/tmp/perf-\", 10))\n\t\treturn NULL;\n\n\treturn dso_name;\n}\n\nstatic int inline_list__append(struct symbol *symbol, char *srcline,\n\t\t\t       struct inline_node *node)\n{\n\tstruct inline_list *ilist;\n\n\tilist = zalloc(sizeof(*ilist));\n\tif (ilist == NULL)\n\t\treturn -1;\n\n\tilist->symbol = symbol;\n\tilist->srcline = srcline;\n\n\tif (callchain_param.order == ORDER_CALLEE)\n\t\tlist_add_tail(&ilist->list, &node->val);\n\telse\n\t\tlist_add(&ilist->list, &node->val);\n\n\treturn 0;\n}\n\n \nstatic const char *gnu_basename(const char *path)\n{\n\tconst char *base = strrchr(path, '/');\n\n\treturn base ? base + 1 : path;\n}\n\nstatic char *srcline_from_fileline(const char *file, unsigned int line)\n{\n\tchar *srcline;\n\n\tif (!file)\n\t\treturn NULL;\n\n\tif (!srcline_full_filename)\n\t\tfile = gnu_basename(file);\n\n\tif (asprintf(&srcline, \"%s:%u\", file, line) < 0)\n\t\treturn NULL;\n\n\treturn srcline;\n}\n\nstatic struct symbol *new_inline_sym(struct dso *dso,\n\t\t\t\t     struct symbol *base_sym,\n\t\t\t\t     const char *funcname)\n{\n\tstruct symbol *inline_sym;\n\tchar *demangled = NULL;\n\n\tif (!funcname)\n\t\tfuncname = \"??\";\n\n\tif (dso) {\n\t\tdemangled = dso__demangle_sym(dso, 0, funcname);\n\t\tif (demangled)\n\t\t\tfuncname = demangled;\n\t}\n\n\tif (base_sym && strcmp(funcname, base_sym->name) == 0) {\n\t\t \n\t\tinline_sym = base_sym;\n\t\t \n\t\tassert(!base_sym->inlined);\n\t} else {\n\t\t \n\t\tinline_sym = symbol__new(base_sym ? base_sym->start : 0,\n\t\t\t\t\t base_sym ? (base_sym->end - base_sym->start) : 0,\n\t\t\t\t\t base_sym ? base_sym->binding : 0,\n\t\t\t\t\t base_sym ? base_sym->type : 0,\n\t\t\t\t\t funcname);\n\t\tif (inline_sym)\n\t\t\tinline_sym->inlined = 1;\n\t}\n\n\tfree(demangled);\n\n\treturn inline_sym;\n}\n\n#define MAX_INLINE_NEST 1024\n\n#ifdef HAVE_LIBBFD_SUPPORT\n\n \n#define PACKAGE \"perf\"\n#include <bfd.h>\n\nstruct a2l_data {\n\tconst char \t*input;\n\tu64\t \taddr;\n\n\tbool \t\tfound;\n\tconst char \t*filename;\n\tconst char \t*funcname;\n\tunsigned \tline;\n\n\tbfd \t\t*abfd;\n\tasymbol \t**syms;\n};\n\nstatic int bfd_error(const char *string)\n{\n\tconst char *errmsg;\n\n\terrmsg = bfd_errmsg(bfd_get_error());\n\tfflush(stdout);\n\n\tif (string)\n\t\tpr_debug(\"%s: %s\\n\", string, errmsg);\n\telse\n\t\tpr_debug(\"%s\\n\", errmsg);\n\n\treturn -1;\n}\n\nstatic int slurp_symtab(bfd *abfd, struct a2l_data *a2l)\n{\n\tlong storage;\n\tlong symcount;\n\tasymbol **syms;\n\tbfd_boolean dynamic = FALSE;\n\n\tif ((bfd_get_file_flags(abfd) & HAS_SYMS) == 0)\n\t\treturn bfd_error(bfd_get_filename(abfd));\n\n\tstorage = bfd_get_symtab_upper_bound(abfd);\n\tif (storage == 0L) {\n\t\tstorage = bfd_get_dynamic_symtab_upper_bound(abfd);\n\t\tdynamic = TRUE;\n\t}\n\tif (storage < 0L)\n\t\treturn bfd_error(bfd_get_filename(abfd));\n\n\tsyms = malloc(storage);\n\tif (dynamic)\n\t\tsymcount = bfd_canonicalize_dynamic_symtab(abfd, syms);\n\telse\n\t\tsymcount = bfd_canonicalize_symtab(abfd, syms);\n\n\tif (symcount < 0) {\n\t\tfree(syms);\n\t\treturn bfd_error(bfd_get_filename(abfd));\n\t}\n\n\ta2l->syms = syms;\n\treturn 0;\n}\n\nstatic void find_address_in_section(bfd *abfd, asection *section, void *data)\n{\n\tbfd_vma pc, vma;\n\tbfd_size_type size;\n\tstruct a2l_data *a2l = data;\n\tflagword flags;\n\n\tif (a2l->found)\n\t\treturn;\n\n#ifdef bfd_get_section_flags\n\tflags = bfd_get_section_flags(abfd, section);\n#else\n\tflags = bfd_section_flags(section);\n#endif\n\tif ((flags & SEC_ALLOC) == 0)\n\t\treturn;\n\n\tpc = a2l->addr;\n#ifdef bfd_get_section_vma\n\tvma = bfd_get_section_vma(abfd, section);\n#else\n\tvma = bfd_section_vma(section);\n#endif\n#ifdef bfd_get_section_size\n\tsize = bfd_get_section_size(section);\n#else\n\tsize = bfd_section_size(section);\n#endif\n\n\tif (pc < vma || pc >= vma + size)\n\t\treturn;\n\n\ta2l->found = bfd_find_nearest_line(abfd, section, a2l->syms, pc - vma,\n\t\t\t\t\t   &a2l->filename, &a2l->funcname,\n\t\t\t\t\t   &a2l->line);\n\n\tif (a2l->filename && !strlen(a2l->filename))\n\t\ta2l->filename = NULL;\n}\n\nstatic struct a2l_data *addr2line_init(const char *path)\n{\n\tbfd *abfd;\n\tstruct a2l_data *a2l = NULL;\n\n\tabfd = bfd_openr(path, NULL);\n\tif (abfd == NULL)\n\t\treturn NULL;\n\n\tif (!bfd_check_format(abfd, bfd_object))\n\t\tgoto out;\n\n\ta2l = zalloc(sizeof(*a2l));\n\tif (a2l == NULL)\n\t\tgoto out;\n\n\ta2l->abfd = abfd;\n\ta2l->input = strdup(path);\n\tif (a2l->input == NULL)\n\t\tgoto out;\n\n\tif (slurp_symtab(abfd, a2l))\n\t\tgoto out;\n\n\treturn a2l;\n\nout:\n\tif (a2l) {\n\t\tzfree((char **)&a2l->input);\n\t\tfree(a2l);\n\t}\n\tbfd_close(abfd);\n\treturn NULL;\n}\n\nstatic void addr2line_cleanup(struct a2l_data *a2l)\n{\n\tif (a2l->abfd)\n\t\tbfd_close(a2l->abfd);\n\tzfree((char **)&a2l->input);\n\tzfree(&a2l->syms);\n\tfree(a2l);\n}\n\nstatic int inline_list__append_dso_a2l(struct dso *dso,\n\t\t\t\t       struct inline_node *node,\n\t\t\t\t       struct symbol *sym)\n{\n\tstruct a2l_data *a2l = dso->a2l;\n\tstruct symbol *inline_sym = new_inline_sym(dso, sym, a2l->funcname);\n\tchar *srcline = NULL;\n\n\tif (a2l->filename)\n\t\tsrcline = srcline_from_fileline(a2l->filename, a2l->line);\n\n\treturn inline_list__append(inline_sym, srcline, node);\n}\n\nstatic int addr2line(const char *dso_name, u64 addr,\n\t\t     char **file, unsigned int *line, struct dso *dso,\n\t\t     bool unwind_inlines, struct inline_node *node,\n\t\t     struct symbol *sym)\n{\n\tint ret = 0;\n\tstruct a2l_data *a2l = dso->a2l;\n\n\tif (!a2l) {\n\t\tdso->a2l = addr2line_init(dso_name);\n\t\ta2l = dso->a2l;\n\t}\n\n\tif (a2l == NULL) {\n\t\tif (!symbol_conf.disable_add2line_warn)\n\t\t\tpr_warning(\"addr2line_init failed for %s\\n\", dso_name);\n\t\treturn 0;\n\t}\n\n\ta2l->addr = addr;\n\ta2l->found = false;\n\n\tbfd_map_over_sections(a2l->abfd, find_address_in_section, a2l);\n\n\tif (!a2l->found)\n\t\treturn 0;\n\n\tif (unwind_inlines) {\n\t\tint cnt = 0;\n\n\t\tif (node && inline_list__append_dso_a2l(dso, node, sym))\n\t\t\treturn 0;\n\n\t\twhile (bfd_find_inliner_info(a2l->abfd, &a2l->filename,\n\t\t\t\t\t     &a2l->funcname, &a2l->line) &&\n\t\t       cnt++ < MAX_INLINE_NEST) {\n\n\t\t\tif (a2l->filename && !strlen(a2l->filename))\n\t\t\t\ta2l->filename = NULL;\n\n\t\t\tif (node != NULL) {\n\t\t\t\tif (inline_list__append_dso_a2l(dso, node, sym))\n\t\t\t\t\treturn 0;\n\t\t\t\t\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (file) {\n\t\t*file = a2l->filename ? strdup(a2l->filename) : NULL;\n\t\tret = *file ? 1 : 0;\n\t}\n\n\tif (line)\n\t\t*line = a2l->line;\n\n\treturn ret;\n}\n\nvoid dso__free_a2l(struct dso *dso)\n{\n\tstruct a2l_data *a2l = dso->a2l;\n\n\tif (!a2l)\n\t\treturn;\n\n\taddr2line_cleanup(a2l);\n\n\tdso->a2l = NULL;\n}\n\n#else  \n\nstatic int filename_split(char *filename, unsigned int *line_nr)\n{\n\tchar *sep;\n\n\tsep = strchr(filename, '\\n');\n\tif (sep)\n\t\t*sep = '\\0';\n\n\tif (!strcmp(filename, \"??:0\"))\n\t\treturn 0;\n\n\tsep = strchr(filename, ':');\n\tif (sep) {\n\t\t*sep++ = '\\0';\n\t\t*line_nr = strtoul(sep, NULL, 0);\n\t\treturn 1;\n\t}\n\tpr_debug(\"addr2line missing ':' in filename split\\n\");\n\treturn 0;\n}\n\nstatic void addr2line_subprocess_cleanup(struct child_process *a2l)\n{\n\tif (a2l->pid != -1) {\n\t\tkill(a2l->pid, SIGKILL);\n\t\tfinish_command(a2l);  \n\t\ta2l->pid = -1;\n\t}\n\n\tfree(a2l);\n}\n\nstatic struct child_process *addr2line_subprocess_init(const char *addr2line_path,\n\t\t\t\t\t\t\tconst char *binary_path)\n{\n\tconst char *argv[] = {\n\t\taddr2line_path ?: \"addr2line\",\n\t\t\"-e\", binary_path,\n\t\t\"-a\", \"-i\", \"-f\", NULL\n\t};\n\tstruct child_process *a2l = zalloc(sizeof(*a2l));\n\tint start_command_status = 0;\n\n\tif (a2l == NULL) {\n\t\tpr_err(\"Failed to allocate memory for addr2line\");\n\t\treturn NULL;\n\t}\n\n\ta2l->pid = -1;\n\ta2l->in = -1;\n\ta2l->out = -1;\n\ta2l->no_stderr = 1;\n\n\ta2l->argv = argv;\n\tstart_command_status = start_command(a2l);\n\ta2l->argv = NULL;  \n\n\tif (start_command_status != 0) {\n\t\tpr_warning(\"could not start addr2line (%s) for %s: start_command return code %d\\n\",\n\t\t\taddr2line_path, binary_path, start_command_status);\n\t\taddr2line_subprocess_cleanup(a2l);\n\t\treturn NULL;\n\t}\n\n\treturn a2l;\n}\n\nenum a2l_style {\n\tBROKEN,\n\tGNU_BINUTILS,\n\tLLVM,\n};\n\nstatic enum a2l_style addr2line_configure(struct child_process *a2l, const char *dso_name)\n{\n\tstatic bool cached;\n\tstatic enum a2l_style style;\n\n\tif (!cached) {\n\t\tchar buf[128];\n\t\tstruct io io;\n\t\tint ch;\n\t\tint lines;\n\n\t\tif (write(a2l->in, \",\\n\", 2) != 2)\n\t\t\treturn BROKEN;\n\n\t\tio__init(&io, a2l->out, buf, sizeof(buf));\n\t\tch = io__get_char(&io);\n\t\tif (ch == ',') {\n\t\t\tstyle = LLVM;\n\t\t\tcached = true;\n\t\t\tlines = 1;\n\t\t\tpr_debug(\"Detected LLVM addr2line style\\n\");\n\t\t} else if (ch == '0') {\n\t\t\tstyle = GNU_BINUTILS;\n\t\t\tcached = true;\n\t\t\tlines = 3;\n\t\t\tpr_debug(\"Detected binutils addr2line style\\n\");\n\t\t} else {\n\t\t\tif (!symbol_conf.disable_add2line_warn) {\n\t\t\t\tchar *output = NULL;\n\t\t\t\tsize_t output_len;\n\n\t\t\t\tio__getline(&io, &output, &output_len);\n\t\t\t\tpr_warning(\"%s %s: addr2line configuration failed\\n\",\n\t\t\t\t\t   __func__, dso_name);\n\t\t\t\tpr_warning(\"\\t%c%s\", ch, output);\n\t\t\t}\n\t\t\tpr_debug(\"Unknown/broken addr2line style\\n\");\n\t\t\treturn BROKEN;\n\t\t}\n\t\twhile (lines) {\n\t\t\tch = io__get_char(&io);\n\t\t\tif (ch <= 0)\n\t\t\t\tbreak;\n\t\t\tif (ch == '\\n')\n\t\t\t\tlines--;\n\t\t}\n\t\t \n\t\tsignal(SIGPIPE, SIG_IGN);\n\t}\n\treturn style;\n}\n\nstatic int read_addr2line_record(struct io *io,\n\t\t\t\t enum a2l_style style,\n\t\t\t\t const char *dso_name,\n\t\t\t\t u64 addr,\n\t\t\t\t bool first,\n\t\t\t\t char **function,\n\t\t\t\t char **filename,\n\t\t\t\t unsigned int *line_nr)\n{\n\t \n\tchar *line = NULL;\n\tsize_t line_len = 0;\n\tunsigned int dummy_line_nr = 0;\n\tint ret = -1;\n\n\tif (function != NULL)\n\t\tzfree(function);\n\n\tif (filename != NULL)\n\t\tzfree(filename);\n\n\tif (line_nr != NULL)\n\t\t*line_nr = 0;\n\n\t \n\tif (io__getline(io, &line, &line_len) < 0 || !line_len)\n\t\tgoto error;\n\n\tpr_debug(\"%s %s: addr2line read address for sentinel: %s\", __func__, dso_name, line);\n\tif (style == LLVM && line_len == 2 && line[0] == ',') {\n\t\t \n\t\tzfree(&line);\n\t\treturn 0;\n\t} else if (style == GNU_BINUTILS && (!first || addr != 0)) {\n\t\tint zero_count = 0, non_zero_count = 0;\n\t\t \n\n\t\t \n\t\tif (line_len >= 2 || line[0] != '0' || line[1] != 'x') {\n\t\t\tfor (size_t i = 2; i < line_len; i++) {\n\t\t\t\tif (line[i] == '0')\n\t\t\t\t\tzero_count++;\n\t\t\t\telse if (line[i] != '\\n')\n\t\t\t\t\tnon_zero_count++;\n\t\t\t}\n\t\t\tif (!non_zero_count) {\n\t\t\t\tint ch;\n\n\t\t\t\tif (first && !zero_count) {\n\t\t\t\t\t \n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tzfree(&line);\n\t\t\t\tdo {\n\t\t\t\t\tch = io__get_char(io);\n\t\t\t\t} while (ch > 0 && ch != '\\n');\n\t\t\t\tdo {\n\t\t\t\t\tch = io__get_char(io);\n\t\t\t\t} while (ch > 0 && ch != '\\n');\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (first && (io__getline(io, &line, &line_len) < 0 || !line_len))\n\t\tgoto error;\n\n\tpr_debug(\"%s %s: addr2line read line: %s\", __func__, dso_name, line);\n\tif (function != NULL)\n\t\t*function = strdup(strim(line));\n\n\tzfree(&line);\n\tline_len = 0;\n\n\t \n\tif (io__getline(io, &line, &line_len) < 0 || !line_len)\n\t\tgoto error;\n\n\tpr_debug(\"%s %s: addr2line filename:number : %s\", __func__, dso_name, line);\n\tif (filename_split(line, line_nr == NULL ? &dummy_line_nr : line_nr) == 0 &&\n\t    style == GNU_BINUTILS) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (filename != NULL)\n\t\t*filename = strdup(line);\n\n\tzfree(&line);\n\tline_len = 0;\n\n\treturn 1;\n\nerror:\n\tfree(line);\n\tif (function != NULL)\n\t\tzfree(function);\n\tif (filename != NULL)\n\t\tzfree(filename);\n\treturn ret;\n}\n\nstatic int inline_list__append_record(struct dso *dso,\n\t\t\t\t      struct inline_node *node,\n\t\t\t\t      struct symbol *sym,\n\t\t\t\t      const char *function,\n\t\t\t\t      const char *filename,\n\t\t\t\t      unsigned int line_nr)\n{\n\tstruct symbol *inline_sym = new_inline_sym(dso, sym, function);\n\n\treturn inline_list__append(inline_sym, srcline_from_fileline(filename, line_nr), node);\n}\n\nstatic int addr2line(const char *dso_name, u64 addr,\n\t\t     char **file, unsigned int *line_nr,\n\t\t     struct dso *dso,\n\t\t     bool unwind_inlines,\n\t\t     struct inline_node *node,\n\t\t     struct symbol *sym __maybe_unused)\n{\n\tstruct child_process *a2l = dso->a2l;\n\tchar *record_function = NULL;\n\tchar *record_filename = NULL;\n\tunsigned int record_line_nr = 0;\n\tint record_status = -1;\n\tint ret = 0;\n\tsize_t inline_count = 0;\n\tint len;\n\tchar buf[128];\n\tssize_t written;\n\tstruct io io = { .eof = false };\n\tenum a2l_style a2l_style;\n\n\tif (!a2l) {\n\t\tif (!filename__has_section(dso_name, \".debug_line\"))\n\t\t\tgoto out;\n\n\t\tdso->a2l = addr2line_subprocess_init(symbol_conf.addr2line_path, dso_name);\n\t\ta2l = dso->a2l;\n\t}\n\n\tif (a2l == NULL) {\n\t\tif (!symbol_conf.disable_add2line_warn)\n\t\t\tpr_warning(\"%s %s: addr2line_subprocess_init failed\\n\", __func__, dso_name);\n\t\tgoto out;\n\t}\n\ta2l_style = addr2line_configure(a2l, dso_name);\n\tif (a2l_style == BROKEN)\n\t\tgoto out;\n\n\t \n\tlen = snprintf(buf, sizeof(buf), \"%016\"PRIx64\"\\n,\\n\", addr);\n\twritten = len > 0 ? write(a2l->in, buf, len) : -1;\n\tif (written != len) {\n\t\tif (!symbol_conf.disable_add2line_warn)\n\t\t\tpr_warning(\"%s %s: could not send request\\n\", __func__, dso_name);\n\t\tgoto out;\n\t}\n\tio__init(&io, a2l->out, buf, sizeof(buf));\n\tio.timeout_ms = addr2line_timeout_ms;\n\tswitch (read_addr2line_record(&io, a2l_style, dso_name, addr,  true,\n\t\t\t\t      &record_function, &record_filename, &record_line_nr)) {\n\tcase -1:\n\t\tif (!symbol_conf.disable_add2line_warn)\n\t\t\tpr_warning(\"%s %s: could not read first record\\n\", __func__, dso_name);\n\t\tgoto out;\n\tcase 0:\n\t\t \n\t\tswitch (read_addr2line_record(&io, a2l_style, dso_name,\n\t\t\t\t\t       1,  true,\n\t\t\t\t\t      NULL, NULL, NULL)) {\n\t\tcase -1:\n\t\t\tif (!symbol_conf.disable_add2line_warn)\n\t\t\t\tpr_warning(\"%s %s: could not read sentinel record\\n\",\n\t\t\t\t\t   __func__, dso_name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!symbol_conf.disable_add2line_warn)\n\t\t\t\tpr_warning(\"%s %s: unexpected record instead of sentinel\",\n\t\t\t\t\t   __func__, dso_name);\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (file) {\n\t\t*file = strdup(record_filename);\n\t\tret = 1;\n\t}\n\tif (line_nr)\n\t\t*line_nr = record_line_nr;\n\n\tif (unwind_inlines) {\n\t\tif (node && inline_list__append_record(dso, node, sym,\n\t\t\t\t\t\t       record_function,\n\t\t\t\t\t\t       record_filename,\n\t\t\t\t\t\t       record_line_nr)) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\twhile ((record_status = read_addr2line_record(&io,\n\t\t\t\t\t\t      a2l_style,\n\t\t\t\t\t\t      dso_name,\n\t\t\t\t\t\t       1,\n\t\t\t\t\t\t       false,\n\t\t\t\t\t\t      &record_function,\n\t\t\t\t\t\t      &record_filename,\n\t\t\t\t\t\t      &record_line_nr)) == 1) {\n\t\tif (unwind_inlines && node && inline_count++ < MAX_INLINE_NEST) {\n\t\t\tif (inline_list__append_record(dso, node, sym,\n\t\t\t\t\t\t       record_function,\n\t\t\t\t\t\t       record_filename,\n\t\t\t\t\t\t       record_line_nr)) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = 1;  \n\t\t}\n\t}\n\nout:\n\tfree(record_function);\n\tfree(record_filename);\n\tif (io.eof) {\n\t\tdso->a2l = NULL;\n\t\taddr2line_subprocess_cleanup(a2l);\n\t}\n\treturn ret;\n}\n\nvoid dso__free_a2l(struct dso *dso)\n{\n\tstruct child_process *a2l = dso->a2l;\n\n\tif (!a2l)\n\t\treturn;\n\n\taddr2line_subprocess_cleanup(a2l);\n\n\tdso->a2l = NULL;\n}\n\n#endif  \n\nstatic struct inline_node *addr2inlines(const char *dso_name, u64 addr,\n\t\t\t\t\tstruct dso *dso, struct symbol *sym)\n{\n\tstruct inline_node *node;\n\n\tnode = zalloc(sizeof(*node));\n\tif (node == NULL) {\n\t\tperror(\"not enough memory for the inline node\");\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&node->val);\n\tnode->addr = addr;\n\n\taddr2line(dso_name, addr, NULL, NULL, dso, true, node, sym);\n\treturn node;\n}\n\n \n#define A2L_FAIL_LIMIT 123\n\nchar *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,\n\t\t  bool show_sym, bool show_addr, bool unwind_inlines,\n\t\t  u64 ip)\n{\n\tchar *file = NULL;\n\tunsigned line = 0;\n\tchar *srcline;\n\tconst char *dso_name;\n\n\tif (!dso->has_srcline)\n\t\tgoto out;\n\n\tdso_name = dso__name(dso);\n\tif (dso_name == NULL)\n\t\tgoto out;\n\n\tif (!addr2line(dso_name, addr, &file, &line, dso,\n\t\t       unwind_inlines, NULL, sym))\n\t\tgoto out;\n\n\tsrcline = srcline_from_fileline(file, line);\n\tfree(file);\n\n\tif (!srcline)\n\t\tgoto out;\n\n\tdso->a2l_fails = 0;\n\n\treturn srcline;\n\nout:\n\tif (dso->a2l_fails && ++dso->a2l_fails > A2L_FAIL_LIMIT) {\n\t\tdso->has_srcline = 0;\n\t\tdso__free_a2l(dso);\n\t}\n\n\tif (!show_addr)\n\t\treturn (show_sym && sym) ?\n\t\t\t    strndup(sym->name, sym->namelen) : SRCLINE_UNKNOWN;\n\n\tif (sym) {\n\t\tif (asprintf(&srcline, \"%s+%\" PRIu64, show_sym ? sym->name : \"\",\n\t\t\t\t\tip - sym->start) < 0)\n\t\t\treturn SRCLINE_UNKNOWN;\n\t} else if (asprintf(&srcline, \"%s[%\" PRIx64 \"]\", dso->short_name, addr) < 0)\n\t\treturn SRCLINE_UNKNOWN;\n\treturn srcline;\n}\n\n \nchar *get_srcline_split(struct dso *dso, u64 addr, unsigned *line)\n{\n\tchar *file = NULL;\n\tconst char *dso_name;\n\n\tif (!dso->has_srcline)\n\t\tgoto out;\n\n\tdso_name = dso__name(dso);\n\tif (dso_name == NULL)\n\t\tgoto out;\n\n\tif (!addr2line(dso_name, addr, &file, line, dso, true, NULL, NULL))\n\t\tgoto out;\n\n\tdso->a2l_fails = 0;\n\treturn file;\n\nout:\n\tif (dso->a2l_fails && ++dso->a2l_fails > A2L_FAIL_LIMIT) {\n\t\tdso->has_srcline = 0;\n\t\tdso__free_a2l(dso);\n\t}\n\n\treturn NULL;\n}\n\nvoid zfree_srcline(char **srcline)\n{\n\tif (*srcline == NULL)\n\t\treturn;\n\n\tif (*srcline != SRCLINE_UNKNOWN)\n\t\tfree(*srcline);\n\n\t*srcline = NULL;\n}\n\nchar *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,\n\t\t  bool show_sym, bool show_addr, u64 ip)\n{\n\treturn __get_srcline(dso, addr, sym, show_sym, show_addr, false, ip);\n}\n\nstruct srcline_node {\n\tu64\t\t\taddr;\n\tchar\t\t\t*srcline;\n\tstruct rb_node\t\trb_node;\n};\n\nvoid srcline__tree_insert(struct rb_root_cached *tree, u64 addr, char *srcline)\n{\n\tstruct rb_node **p = &tree->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct srcline_node *i, *node;\n\tbool leftmost = true;\n\n\tnode = zalloc(sizeof(struct srcline_node));\n\tif (!node) {\n\t\tperror(\"not enough memory for the srcline node\");\n\t\treturn;\n\t}\n\n\tnode->addr = addr;\n\tnode->srcline = srcline;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\ti = rb_entry(parent, struct srcline_node, rb_node);\n\t\tif (addr < i->addr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\trb_link_node(&node->rb_node, parent, p);\n\trb_insert_color_cached(&node->rb_node, tree, leftmost);\n}\n\nchar *srcline__tree_find(struct rb_root_cached *tree, u64 addr)\n{\n\tstruct rb_node *n = tree->rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct srcline_node *i = rb_entry(n, struct srcline_node,\n\t\t\t\t\t\t  rb_node);\n\n\t\tif (addr < i->addr)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > i->addr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn i->srcline;\n\t}\n\n\treturn NULL;\n}\n\nvoid srcline__tree_delete(struct rb_root_cached *tree)\n{\n\tstruct srcline_node *pos;\n\tstruct rb_node *next = rb_first_cached(tree);\n\n\twhile (next) {\n\t\tpos = rb_entry(next, struct srcline_node, rb_node);\n\t\tnext = rb_next(&pos->rb_node);\n\t\trb_erase_cached(&pos->rb_node, tree);\n\t\tzfree_srcline(&pos->srcline);\n\t\tzfree(&pos);\n\t}\n}\n\nstruct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr,\n\t\t\t\t\t    struct symbol *sym)\n{\n\tconst char *dso_name;\n\n\tdso_name = dso__name(dso);\n\tif (dso_name == NULL)\n\t\treturn NULL;\n\n\treturn addr2inlines(dso_name, addr, dso, sym);\n}\n\nvoid inline_node__delete(struct inline_node *node)\n{\n\tstruct inline_list *ilist, *tmp;\n\n\tlist_for_each_entry_safe(ilist, tmp, &node->val, list) {\n\t\tlist_del_init(&ilist->list);\n\t\tzfree_srcline(&ilist->srcline);\n\t\t \n\t\tif (ilist->symbol && ilist->symbol->inlined)\n\t\t\tsymbol__delete(ilist->symbol);\n\t\tfree(ilist);\n\t}\n\n\tfree(node);\n}\n\nvoid inlines__tree_insert(struct rb_root_cached *tree,\n\t\t\t  struct inline_node *inlines)\n{\n\tstruct rb_node **p = &tree->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tconst u64 addr = inlines->addr;\n\tstruct inline_node *i;\n\tbool leftmost = true;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\ti = rb_entry(parent, struct inline_node, rb_node);\n\t\tif (addr < i->addr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\trb_link_node(&inlines->rb_node, parent, p);\n\trb_insert_color_cached(&inlines->rb_node, tree, leftmost);\n}\n\nstruct inline_node *inlines__tree_find(struct rb_root_cached *tree, u64 addr)\n{\n\tstruct rb_node *n = tree->rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct inline_node *i = rb_entry(n, struct inline_node,\n\t\t\t\t\t\t rb_node);\n\n\t\tif (addr < i->addr)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > i->addr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn i;\n\t}\n\n\treturn NULL;\n}\n\nvoid inlines__tree_delete(struct rb_root_cached *tree)\n{\n\tstruct inline_node *pos;\n\tstruct rb_node *next = rb_first_cached(tree);\n\n\twhile (next) {\n\t\tpos = rb_entry(next, struct inline_node, rb_node);\n\t\tnext = rb_next(&pos->rb_node);\n\t\trb_erase_cached(&pos->rb_node, tree);\n\t\tinline_node__delete(pos);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}