{
  "module_name": "map.c",
  "hash_id": "d8bec45aa61a02a8fe96c6b1ccbc530a379eb58f1f2db9a71ae6fa4fb5fae386",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/map.c",
  "human_readable_source": "\n#include <inttypes.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <uapi/linux/mman.h>  \n#include \"debug.h\"\n#include \"dso.h\"\n#include \"map.h\"\n#include \"namespaces.h\"\n#include \"srcline.h\"\n#include \"symbol.h\"\n#include \"thread.h\"\n#include \"vdso.h\"\n\nstatic inline int is_android_lib(const char *filename)\n{\n\treturn strstarts(filename, \"/data/app-lib/\") ||\n\t       strstarts(filename, \"/system/lib/\");\n}\n\nstatic inline bool replace_android_lib(const char *filename, char *newfilename)\n{\n\tconst char *libname;\n\tchar *app_abi;\n\tsize_t app_abi_length, new_length;\n\tsize_t lib_length = 0;\n\n\tlibname  = strrchr(filename, '/');\n\tif (libname)\n\t\tlib_length = strlen(libname);\n\n\tapp_abi = getenv(\"APP_ABI\");\n\tif (!app_abi)\n\t\treturn false;\n\n\tapp_abi_length = strlen(app_abi);\n\n\tif (strstarts(filename, \"/data/app-lib/\")) {\n\t\tchar *apk_path;\n\n\t\tif (!app_abi_length)\n\t\t\treturn false;\n\n\t\tnew_length = 7 + app_abi_length + lib_length;\n\n\t\tapk_path = getenv(\"APK_PATH\");\n\t\tif (apk_path) {\n\t\t\tnew_length += strlen(apk_path) + 1;\n\t\t\tif (new_length > PATH_MAX)\n\t\t\t\treturn false;\n\t\t\tsnprintf(newfilename, new_length,\n\t\t\t\t \"%s/libs/%s/%s\", apk_path, app_abi, libname);\n\t\t} else {\n\t\t\tif (new_length > PATH_MAX)\n\t\t\t\treturn false;\n\t\t\tsnprintf(newfilename, new_length,\n\t\t\t\t \"libs/%s/%s\", app_abi, libname);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (strstarts(filename, \"/system/lib/\")) {\n\t\tchar *ndk, *app;\n\t\tconst char *arch;\n\t\tint ndk_length, app_length;\n\n\t\tndk = getenv(\"NDK_ROOT\");\n\t\tapp = getenv(\"APP_PLATFORM\");\n\n\t\tif (!(ndk && app))\n\t\t\treturn false;\n\n\t\tndk_length = strlen(ndk);\n\t\tapp_length = strlen(app);\n\n\t\tif (!(ndk_length && app_length && app_abi_length))\n\t\t\treturn false;\n\n\t\tarch = !strncmp(app_abi, \"arm\", 3) ? \"arm\" :\n\t\t       !strncmp(app_abi, \"mips\", 4) ? \"mips\" :\n\t\t       !strncmp(app_abi, \"x86\", 3) ? \"x86\" : NULL;\n\n\t\tif (!arch)\n\t\t\treturn false;\n\n\t\tnew_length = 27 + ndk_length +\n\t\t\t     app_length + lib_length\n\t\t\t   + strlen(arch);\n\n\t\tif (new_length > PATH_MAX)\n\t\t\treturn false;\n\t\tsnprintf(newfilename, new_length,\n\t\t\t\"%.*s/platforms/%.*s/arch-%s/usr/lib/%s\",\n\t\t\tndk_length, ndk, app_length, app, arch, libname);\n\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid map__init(struct map *map, u64 start, u64 end, u64 pgoff, struct dso *dso)\n{\n\tmap__set_start(map, start);\n\tmap__set_end(map, end);\n\tmap__set_pgoff(map, pgoff);\n\tmap__set_reloc(map, 0);\n\tmap__set_dso(map, dso__get(dso));\n\tmap__set_map_ip(map, map__dso_map_ip);\n\tmap__set_unmap_ip(map, map__dso_unmap_ip);\n\tmap__set_erange_warned(map, false);\n\trefcount_set(map__refcnt(map), 1);\n}\n\nstruct map *map__new(struct machine *machine, u64 start, u64 len,\n\t\t     u64 pgoff, struct dso_id *id,\n\t\t     u32 prot, u32 flags, struct build_id *bid,\n\t\t     char *filename, struct thread *thread)\n{\n\tstruct map *result;\n\tRC_STRUCT(map) *map;\n\tstruct nsinfo *nsi = NULL;\n\tstruct nsinfo *nnsi;\n\n\tmap = malloc(sizeof(*map));\n\tif (ADD_RC_CHK(result, map)) {\n\t\tchar newfilename[PATH_MAX];\n\t\tstruct dso *dso, *header_bid_dso;\n\t\tint anon, no_dso, vdso, android;\n\n\t\tandroid = is_android_lib(filename);\n\t\tanon = is_anon_memory(filename) || flags & MAP_HUGETLB;\n\t\tvdso = is_vdso_map(filename);\n\t\tno_dso = is_no_dso_memory(filename);\n\t\tmap->prot = prot;\n\t\tmap->flags = flags;\n\t\tnsi = nsinfo__get(thread__nsinfo(thread));\n\n\t\tif ((anon || no_dso) && nsi && (prot & PROT_EXEC)) {\n\t\t\tsnprintf(newfilename, sizeof(newfilename),\n\t\t\t\t \"/tmp/perf-%d.map\", nsinfo__pid(nsi));\n\t\t\tfilename = newfilename;\n\t\t}\n\n\t\tif (android) {\n\t\t\tif (replace_android_lib(filename, newfilename))\n\t\t\t\tfilename = newfilename;\n\t\t}\n\n\t\tif (vdso) {\n\t\t\t \n\t\t\tnnsi = nsinfo__copy(nsi);\n\t\t\tif (nnsi) {\n\t\t\t\tnsinfo__put(nsi);\n\t\t\t\tnsinfo__clear_need_setns(nnsi);\n\t\t\t\tnsi = nnsi;\n\t\t\t}\n\t\t\tpgoff = 0;\n\t\t\tdso = machine__findnew_vdso(machine, thread);\n\t\t} else\n\t\t\tdso = machine__findnew_dso_id(machine, filename, id);\n\n\t\tif (dso == NULL)\n\t\t\tgoto out_delete;\n\n\t\tmap__init(result, start, start + len, pgoff, dso);\n\n\t\tif (anon || no_dso) {\n\t\t\tmap->map_ip = map->unmap_ip = identity__map_ip;\n\n\t\t\t \n\t\t\tif (!(prot & PROT_EXEC))\n\t\t\t\tdso__set_loaded(dso);\n\t\t}\n\t\tmutex_lock(&dso->lock);\n\t\tnsinfo__put(dso->nsinfo);\n\t\tdso->nsinfo = nsi;\n\t\tmutex_unlock(&dso->lock);\n\n\t\tif (build_id__is_defined(bid)) {\n\t\t\tdso__set_build_id(dso, bid);\n\t\t} else {\n\t\t\t \n\t\t\tdown_read(&machine->dsos.lock);\n\t\t\theader_bid_dso = __dsos__find(&machine->dsos, filename, false);\n\t\t\tup_read(&machine->dsos.lock);\n\t\t\tif (header_bid_dso && header_bid_dso->header_build_id) {\n\t\t\t\tdso__set_build_id(dso, &header_bid_dso->bid);\n\t\t\t\tdso->header_build_id = 1;\n\t\t\t}\n\t\t}\n\t\tdso__put(dso);\n\t}\n\treturn result;\nout_delete:\n\tnsinfo__put(nsi);\n\tRC_CHK_FREE(result);\n\treturn NULL;\n}\n\n \nstruct map *map__new2(u64 start, struct dso *dso)\n{\n\tstruct map *result;\n\tRC_STRUCT(map) *map;\n\n\tmap = calloc(1, sizeof(*map) + (dso->kernel ? sizeof(struct kmap) : 0));\n\tif (ADD_RC_CHK(result, map)) {\n\t\t \n\t\tmap__init(result, start, 0, 0, dso);\n\t}\n\n\treturn result;\n}\n\nbool __map__is_kernel(const struct map *map)\n{\n\tif (!map__dso(map)->kernel)\n\t\treturn false;\n\treturn machine__kernel_map(maps__machine(map__kmaps((struct map *)map))) == map;\n}\n\nbool __map__is_extra_kernel_map(const struct map *map)\n{\n\tstruct kmap *kmap = __map__kmap((struct map *)map);\n\n\treturn kmap && kmap->name[0];\n}\n\nbool __map__is_bpf_prog(const struct map *map)\n{\n\tconst char *name;\n\tstruct dso *dso = map__dso(map);\n\n\tif (dso->binary_type == DSO_BINARY_TYPE__BPF_PROG_INFO)\n\t\treturn true;\n\n\t \n\tname = dso->short_name;\n\treturn name && (strstr(name, \"bpf_prog_\") == name);\n}\n\nbool __map__is_bpf_image(const struct map *map)\n{\n\tconst char *name;\n\tstruct dso *dso = map__dso(map);\n\n\tif (dso->binary_type == DSO_BINARY_TYPE__BPF_IMAGE)\n\t\treturn true;\n\n\t \n\tname = dso->short_name;\n\treturn name && is_bpf_image(name);\n}\n\nbool __map__is_ool(const struct map *map)\n{\n\tconst struct dso *dso = map__dso(map);\n\n\treturn dso && dso->binary_type == DSO_BINARY_TYPE__OOL;\n}\n\nbool map__has_symbols(const struct map *map)\n{\n\treturn dso__has_symbols(map__dso(map));\n}\n\nstatic void map__exit(struct map *map)\n{\n\tBUG_ON(refcount_read(map__refcnt(map)) != 0);\n\tdso__zput(RC_CHK_ACCESS(map)->dso);\n}\n\nvoid map__delete(struct map *map)\n{\n\tmap__exit(map);\n\tRC_CHK_FREE(map);\n}\n\nvoid map__put(struct map *map)\n{\n\tif (map && refcount_dec_and_test(map__refcnt(map)))\n\t\tmap__delete(map);\n\telse\n\t\tRC_CHK_PUT(map);\n}\n\nvoid map__fixup_start(struct map *map)\n{\n\tstruct dso *dso = map__dso(map);\n\tstruct rb_root_cached *symbols = &dso->symbols;\n\tstruct rb_node *nd = rb_first_cached(symbols);\n\n\tif (nd != NULL) {\n\t\tstruct symbol *sym = rb_entry(nd, struct symbol, rb_node);\n\n\t\tmap__set_start(map, sym->start);\n\t}\n}\n\nvoid map__fixup_end(struct map *map)\n{\n\tstruct dso *dso = map__dso(map);\n\tstruct rb_root_cached *symbols = &dso->symbols;\n\tstruct rb_node *nd = rb_last(&symbols->rb_root);\n\n\tif (nd != NULL) {\n\t\tstruct symbol *sym = rb_entry(nd, struct symbol, rb_node);\n\t\tmap__set_end(map, sym->end);\n\t}\n}\n\n#define DSO__DELETED \"(deleted)\"\n\nint map__load(struct map *map)\n{\n\tstruct dso *dso = map__dso(map);\n\tconst char *name = dso->long_name;\n\tint nr;\n\n\tif (dso__loaded(dso))\n\t\treturn 0;\n\n\tnr = dso__load(dso, map);\n\tif (nr < 0) {\n\t\tif (dso->has_build_id) {\n\t\t\tchar sbuild_id[SBUILD_ID_SIZE];\n\n\t\t\tbuild_id__sprintf(&dso->bid, sbuild_id);\n\t\t\tpr_debug(\"%s with build id %s not found\", name, sbuild_id);\n\t\t} else\n\t\t\tpr_debug(\"Failed to open %s\", name);\n\n\t\tpr_debug(\", continuing without symbols\\n\");\n\t\treturn -1;\n\t} else if (nr == 0) {\n#ifdef HAVE_LIBELF_SUPPORT\n\t\tconst size_t len = strlen(name);\n\t\tconst size_t real_len = len - sizeof(DSO__DELETED);\n\n\t\tif (len > sizeof(DSO__DELETED) &&\n\t\t    strcmp(name + real_len + 1, DSO__DELETED) == 0) {\n\t\t\tpr_debug(\"%.*s was updated (is prelink enabled?). \"\n\t\t\t\t\"Restart the long running apps that use it!\\n\",\n\t\t\t\t   (int)real_len, name);\n\t\t} else {\n\t\t\tpr_debug(\"no symbols found in %s, maybe install a debug package?\\n\", name);\n\t\t}\n#endif\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstruct symbol *map__find_symbol(struct map *map, u64 addr)\n{\n\tif (map__load(map) < 0)\n\t\treturn NULL;\n\n\treturn dso__find_symbol(map__dso(map), addr);\n}\n\nstruct symbol *map__find_symbol_by_name_idx(struct map *map, const char *name, size_t *idx)\n{\n\tstruct dso *dso;\n\n\tif (map__load(map) < 0)\n\t\treturn NULL;\n\n\tdso = map__dso(map);\n\tdso__sort_by_name(dso);\n\n\treturn dso__find_symbol_by_name(dso, name, idx);\n}\n\nstruct symbol *map__find_symbol_by_name(struct map *map, const char *name)\n{\n\tsize_t idx;\n\n\treturn map__find_symbol_by_name_idx(map, name, &idx);\n}\n\nstruct map *map__clone(struct map *from)\n{\n\tstruct map *result;\n\tRC_STRUCT(map) *map;\n\tsize_t size = sizeof(RC_STRUCT(map));\n\tstruct dso *dso = map__dso(from);\n\n\tif (dso && dso->kernel)\n\t\tsize += sizeof(struct kmap);\n\n\tmap = memdup(RC_CHK_ACCESS(from), size);\n\tif (ADD_RC_CHK(result, map)) {\n\t\trefcount_set(&map->refcnt, 1);\n\t\tmap->dso = dso__get(dso);\n\t}\n\n\treturn result;\n}\n\nsize_t map__fprintf(struct map *map, FILE *fp)\n{\n\tconst struct dso *dso = map__dso(map);\n\n\treturn fprintf(fp, \" %\" PRIx64 \"-%\" PRIx64 \" %\" PRIx64 \" %s\\n\",\n\t\t       map__start(map), map__end(map), map__pgoff(map), dso->name);\n}\n\nstatic bool prefer_dso_long_name(const struct dso *dso, bool print_off)\n{\n\treturn dso->long_name &&\n\t       (symbol_conf.show_kernel_path ||\n\t\t(print_off && (dso->name[0] == '[' || dso__is_kcore(dso))));\n}\n\nstatic size_t __map__fprintf_dsoname(struct map *map, bool print_off, FILE *fp)\n{\n\tchar buf[symbol_conf.pad_output_len_dso + 1];\n\tconst char *dsoname = \"[unknown]\";\n\tconst struct dso *dso = map ? map__dso(map) : NULL;\n\n\tif (dso) {\n\t\tif (prefer_dso_long_name(dso, print_off))\n\t\t\tdsoname = dso->long_name;\n\t\telse\n\t\t\tdsoname = dso->name;\n\t}\n\n\tif (symbol_conf.pad_output_len_dso) {\n\t\tscnprintf_pad(buf, symbol_conf.pad_output_len_dso, \"%s\", dsoname);\n\t\tdsoname = buf;\n\t}\n\n\treturn fprintf(fp, \"%s\", dsoname);\n}\n\nsize_t map__fprintf_dsoname(struct map *map, FILE *fp)\n{\n\treturn __map__fprintf_dsoname(map, false, fp);\n}\n\nsize_t map__fprintf_dsoname_dsoff(struct map *map, bool print_off, u64 addr, FILE *fp)\n{\n\tconst struct dso *dso = map ? map__dso(map) : NULL;\n\tint printed = 0;\n\n\tif (print_off && (!dso || !dso__is_object_file(dso)))\n\t\tprint_off = false;\n\tprinted += fprintf(fp, \" (\");\n\tprinted += __map__fprintf_dsoname(map, print_off, fp);\n\tif (print_off)\n\t\tprinted += fprintf(fp, \"+0x%\" PRIx64, addr);\n\tprinted += fprintf(fp, \")\");\n\n\treturn printed;\n}\n\nchar *map__srcline(struct map *map, u64 addr, struct symbol *sym)\n{\n\tif (map == NULL)\n\t\treturn SRCLINE_UNKNOWN;\n\n\treturn get_srcline(map__dso(map), map__rip_2objdump(map, addr), sym, true, true, addr);\n}\n\nint map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,\n\t\t\t FILE *fp)\n{\n\tconst struct dso *dso = map ? map__dso(map) : NULL;\n\tint ret = 0;\n\n\tif (dso) {\n\t\tchar *srcline = map__srcline(map, addr, NULL);\n\t\tif (srcline != SRCLINE_UNKNOWN)\n\t\t\tret = fprintf(fp, \"%s%s\", prefix, srcline);\n\t\tzfree_srcline(&srcline);\n\t}\n\treturn ret;\n}\n\nvoid srccode_state_free(struct srccode_state *state)\n{\n\tzfree(&state->srcfile);\n\tstate->line = 0;\n}\n\n \nu64 map__rip_2objdump(struct map *map, u64 rip)\n{\n\tstruct kmap *kmap = __map__kmap(map);\n\tconst struct dso *dso = map__dso(map);\n\n\t \n\tif (kmap && is_entry_trampoline(kmap->name) && kmap->kmaps) {\n\t\tstruct machine *machine = maps__machine(kmap->kmaps);\n\n\t\tif (machine) {\n\t\t\tstruct map *kernel_map = machine__kernel_map(machine);\n\n\t\t\tif (kernel_map)\n\t\t\t\tmap = kernel_map;\n\t\t}\n\t}\n\n\tif (!dso->adjust_symbols)\n\t\treturn rip;\n\n\tif (dso->rel)\n\t\treturn rip - map__pgoff(map);\n\n\t \n\tif (dso->kernel == DSO_SPACE__USER)\n\t\treturn rip + dso->text_offset;\n\n\treturn map__unmap_ip(map, rip) - map__reloc(map);\n}\n\n \nu64 map__objdump_2mem(struct map *map, u64 ip)\n{\n\tconst struct dso *dso = map__dso(map);\n\n\tif (!dso->adjust_symbols)\n\t\treturn map__unmap_ip(map, ip);\n\n\tif (dso->rel)\n\t\treturn map__unmap_ip(map, ip + map__pgoff(map));\n\n\t \n\tif (dso->kernel == DSO_SPACE__USER)\n\t\treturn map__unmap_ip(map, ip - dso->text_offset);\n\n\treturn ip + map__reloc(map);\n}\n\nbool map__contains_symbol(const struct map *map, const struct symbol *sym)\n{\n\tu64 ip = map__unmap_ip(map, sym->start);\n\n\treturn ip >= map__start(map) && ip < map__end(map);\n}\n\nstruct kmap *__map__kmap(struct map *map)\n{\n\tconst struct dso *dso = map__dso(map);\n\n\tif (!dso || !dso->kernel)\n\t\treturn NULL;\n\treturn (struct kmap *)(&RC_CHK_ACCESS(map)[1]);\n}\n\nstruct kmap *map__kmap(struct map *map)\n{\n\tstruct kmap *kmap = __map__kmap(map);\n\n\tif (!kmap)\n\t\tpr_err(\"Internal error: map__kmap with a non-kernel map\\n\");\n\treturn kmap;\n}\n\nstruct maps *map__kmaps(struct map *map)\n{\n\tstruct kmap *kmap = map__kmap(map);\n\n\tif (!kmap || !kmap->kmaps) {\n\t\tpr_err(\"Internal error: map__kmaps with a non-kernel map\\n\");\n\t\treturn NULL;\n\t}\n\treturn kmap->kmaps;\n}\n\nu64 map__dso_map_ip(const struct map *map, u64 ip)\n{\n\treturn ip - map__start(map) + map__pgoff(map);\n}\n\nu64 map__dso_unmap_ip(const struct map *map, u64 ip)\n{\n\treturn ip + map__start(map) - map__pgoff(map);\n}\n\nu64 identity__map_ip(const struct map *map __maybe_unused, u64 ip)\n{\n\treturn ip;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}