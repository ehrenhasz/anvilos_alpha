{
  "module_name": "pmus.c",
  "hash_id": "d85c5ec10a5089ce886578cef8f8dada73fe60a81e9178d5ee2378e0cdea72f2",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/pmus.c",
  "human_readable_source": "\n#include <linux/list.h>\n#include <linux/list_sort.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <subcmd/pager.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <pthread.h>\n#include <string.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"evsel.h\"\n#include \"pmus.h\"\n#include \"pmu.h\"\n#include \"print-events.h\"\n\n \nstatic LIST_HEAD(core_pmus);\nstatic LIST_HEAD(other_pmus);\nstatic bool read_sysfs_core_pmus;\nstatic bool read_sysfs_all_pmus;\n\nint pmu_name_len_no_suffix(const char *str, unsigned long *num)\n{\n\tint orig_len, len;\n\n\torig_len = len = strlen(str);\n\n\t \n\tif (!strstarts(str, \"uncore_\"))\n\t\treturn len;\n\n\t \n\twhile (len > 0 && isdigit(str[len - 1]))\n\t\tlen--;\n\n\tif (len > 0 && len != orig_len && str[len - 1] == '_') {\n\t\tif (num)\n\t\t\t*num = strtoul(&str[len], NULL, 10);\n\t\treturn len - 1;\n\t}\n\treturn orig_len;\n}\n\nvoid perf_pmus__destroy(void)\n{\n\tstruct perf_pmu *pmu, *tmp;\n\n\tlist_for_each_entry_safe(pmu, tmp, &core_pmus, list) {\n\t\tlist_del(&pmu->list);\n\n\t\tperf_pmu__delete(pmu);\n\t}\n\tlist_for_each_entry_safe(pmu, tmp, &other_pmus, list) {\n\t\tlist_del(&pmu->list);\n\n\t\tperf_pmu__delete(pmu);\n\t}\n\tread_sysfs_core_pmus = false;\n\tread_sysfs_all_pmus = false;\n}\n\nstatic struct perf_pmu *pmu_find(const char *name)\n{\n\tstruct perf_pmu *pmu;\n\n\tlist_for_each_entry(pmu, &core_pmus, list) {\n\t\tif (!strcmp(pmu->name, name) ||\n\t\t    (pmu->alias_name && !strcmp(pmu->alias_name, name)))\n\t\t\treturn pmu;\n\t}\n\tlist_for_each_entry(pmu, &other_pmus, list) {\n\t\tif (!strcmp(pmu->name, name) ||\n\t\t    (pmu->alias_name && !strcmp(pmu->alias_name, name)))\n\t\t\treturn pmu;\n\t}\n\n\treturn NULL;\n}\n\nstruct perf_pmu *perf_pmus__find(const char *name)\n{\n\tstruct perf_pmu *pmu;\n\tint dirfd;\n\tbool core_pmu;\n\n\t \n\tpmu = pmu_find(name);\n\tif (pmu)\n\t\treturn pmu;\n\n\tif (read_sysfs_all_pmus)\n\t\treturn NULL;\n\n\tcore_pmu = is_pmu_core(name);\n\tif (core_pmu && read_sysfs_core_pmus)\n\t\treturn NULL;\n\n\tdirfd = perf_pmu__event_source_devices_fd();\n\tpmu = perf_pmu__lookup(core_pmu ? &core_pmus : &other_pmus, dirfd, name);\n\tclose(dirfd);\n\n\treturn pmu;\n}\n\nstatic struct perf_pmu *perf_pmu__find2(int dirfd, const char *name)\n{\n\tstruct perf_pmu *pmu;\n\tbool core_pmu;\n\n\t \n\tpmu = pmu_find(name);\n\tif (pmu)\n\t\treturn pmu;\n\n\tif (read_sysfs_all_pmus)\n\t\treturn NULL;\n\n\tcore_pmu = is_pmu_core(name);\n\tif (core_pmu && read_sysfs_core_pmus)\n\t\treturn NULL;\n\n\treturn perf_pmu__lookup(core_pmu ? &core_pmus : &other_pmus, dirfd, name);\n}\n\nstatic int pmus_cmp(void *priv __maybe_unused,\n\t\t    const struct list_head *lhs, const struct list_head *rhs)\n{\n\tunsigned long lhs_num = 0, rhs_num = 0;\n\tstruct perf_pmu *lhs_pmu = container_of(lhs, struct perf_pmu, list);\n\tstruct perf_pmu *rhs_pmu = container_of(rhs, struct perf_pmu, list);\n\tconst char *lhs_pmu_name = lhs_pmu->name ?: \"\";\n\tconst char *rhs_pmu_name = rhs_pmu->name ?: \"\";\n\tint lhs_pmu_name_len = pmu_name_len_no_suffix(lhs_pmu_name, &lhs_num);\n\tint rhs_pmu_name_len = pmu_name_len_no_suffix(rhs_pmu_name, &rhs_num);\n\tint ret = strncmp(lhs_pmu_name, rhs_pmu_name,\n\t\t\tlhs_pmu_name_len < rhs_pmu_name_len ? lhs_pmu_name_len : rhs_pmu_name_len);\n\n\tif (lhs_pmu_name_len != rhs_pmu_name_len || ret != 0 || lhs_pmu_name_len == 0)\n\t\treturn ret;\n\n\treturn lhs_num < rhs_num ? -1 : (lhs_num > rhs_num ? 1 : 0);\n}\n\n \nstatic void pmu_read_sysfs(bool core_only)\n{\n\tint fd;\n\tDIR *dir;\n\tstruct dirent *dent;\n\n\tif (read_sysfs_all_pmus || (core_only && read_sysfs_core_pmus))\n\t\treturn;\n\n\tfd = perf_pmu__event_source_devices_fd();\n\tif (fd < 0)\n\t\treturn;\n\n\tdir = fdopendir(fd);\n\tif (!dir) {\n\t\tclose(fd);\n\t\treturn;\n\t}\n\n\twhile ((dent = readdir(dir))) {\n\t\tif (!strcmp(dent->d_name, \".\") || !strcmp(dent->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (core_only && !is_pmu_core(dent->d_name))\n\t\t\tcontinue;\n\t\t \n\t\tperf_pmu__find2(fd, dent->d_name);\n\t}\n\n\tclosedir(dir);\n\tif (list_empty(&core_pmus)) {\n\t\tif (!perf_pmu__create_placeholder_core_pmu(&core_pmus))\n\t\t\tpr_err(\"Failure to set up any core PMUs\\n\");\n\t}\n\tlist_sort(NULL, &core_pmus, pmus_cmp);\n\tlist_sort(NULL, &other_pmus, pmus_cmp);\n\tif (!list_empty(&core_pmus)) {\n\t\tread_sysfs_core_pmus = true;\n\t\tif (!core_only)\n\t\t\tread_sysfs_all_pmus = true;\n\t}\n}\n\nstatic struct perf_pmu *__perf_pmus__find_by_type(unsigned int type)\n{\n\tstruct perf_pmu *pmu;\n\n\tlist_for_each_entry(pmu, &core_pmus, list) {\n\t\tif (pmu->type == type)\n\t\t\treturn pmu;\n\t}\n\n\tlist_for_each_entry(pmu, &other_pmus, list) {\n\t\tif (pmu->type == type)\n\t\t\treturn pmu;\n\t}\n\treturn NULL;\n}\n\nstruct perf_pmu *perf_pmus__find_by_type(unsigned int type)\n{\n\tstruct perf_pmu *pmu = __perf_pmus__find_by_type(type);\n\n\tif (pmu || read_sysfs_all_pmus)\n\t\treturn pmu;\n\n\tpmu_read_sysfs( false);\n\tpmu = __perf_pmus__find_by_type(type);\n\treturn pmu;\n}\n\n \nstruct perf_pmu *perf_pmus__scan(struct perf_pmu *pmu)\n{\n\tbool use_core_pmus = !pmu || pmu->is_core;\n\n\tif (!pmu) {\n\t\tpmu_read_sysfs( false);\n\t\tpmu = list_prepare_entry(pmu, &core_pmus, list);\n\t}\n\tif (use_core_pmus) {\n\t\tlist_for_each_entry_continue(pmu, &core_pmus, list)\n\t\t\treturn pmu;\n\n\t\tpmu = NULL;\n\t\tpmu = list_prepare_entry(pmu, &other_pmus, list);\n\t}\n\tlist_for_each_entry_continue(pmu, &other_pmus, list)\n\t\treturn pmu;\n\treturn NULL;\n}\n\nstruct perf_pmu *perf_pmus__scan_core(struct perf_pmu *pmu)\n{\n\tif (!pmu) {\n\t\tpmu_read_sysfs( true);\n\t\tpmu = list_prepare_entry(pmu, &core_pmus, list);\n\t}\n\tlist_for_each_entry_continue(pmu, &core_pmus, list)\n\t\treturn pmu;\n\n\treturn NULL;\n}\n\nstatic struct perf_pmu *perf_pmus__scan_skip_duplicates(struct perf_pmu *pmu)\n{\n\tbool use_core_pmus = !pmu || pmu->is_core;\n\tint last_pmu_name_len = 0;\n\tconst char *last_pmu_name = (pmu && pmu->name) ? pmu->name : \"\";\n\n\tif (!pmu) {\n\t\tpmu_read_sysfs( false);\n\t\tpmu = list_prepare_entry(pmu, &core_pmus, list);\n\t} else\n\t\tlast_pmu_name_len = pmu_name_len_no_suffix(pmu->name ?: \"\", NULL);\n\n\tif (use_core_pmus) {\n\t\tlist_for_each_entry_continue(pmu, &core_pmus, list) {\n\t\t\tint pmu_name_len = pmu_name_len_no_suffix(pmu->name ?: \"\",  NULL);\n\n\t\t\tif (last_pmu_name_len == pmu_name_len &&\n\t\t\t    !strncmp(last_pmu_name, pmu->name ?: \"\", pmu_name_len))\n\t\t\t\tcontinue;\n\n\t\t\treturn pmu;\n\t\t}\n\t\tpmu = NULL;\n\t\tpmu = list_prepare_entry(pmu, &other_pmus, list);\n\t}\n\tlist_for_each_entry_continue(pmu, &other_pmus, list) {\n\t\tint pmu_name_len = pmu_name_len_no_suffix(pmu->name ?: \"\",  NULL);\n\n\t\tif (last_pmu_name_len == pmu_name_len &&\n\t\t    !strncmp(last_pmu_name, pmu->name ?: \"\", pmu_name_len))\n\t\t\tcontinue;\n\n\t\treturn pmu;\n\t}\n\treturn NULL;\n}\n\nconst struct perf_pmu *perf_pmus__pmu_for_pmu_filter(const char *str)\n{\n\tstruct perf_pmu *pmu = NULL;\n\n\twhile ((pmu = perf_pmus__scan(pmu)) != NULL) {\n\t\tif (!strcmp(pmu->name, str))\n\t\t\treturn pmu;\n\t\t \n\t\tif (!strncmp(pmu->name, \"uncore_\", 7)) {\n\t\t\tif (!strcmp(pmu->name + 7, str))\n\t\t\t\treturn pmu;\n\t\t}\n\t\t \n\t\tif (!strncmp(pmu->name, \"cpu_\", 4)) {\n\t\t\tif (!strcmp(pmu->name + 4, str))\n\t\t\t\treturn pmu;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint __weak perf_pmus__num_mem_pmus(void)\n{\n\t \n\treturn perf_pmus__num_core_pmus();\n}\n\n \nstruct sevent {\n\t \n\tconst struct perf_pmu *pmu;\n\tconst char *name;\n\tconst char* alias;\n\tconst char *scale_unit;\n\tconst char *desc;\n\tconst char *long_desc;\n\tconst char *encoding_desc;\n\tconst char *topic;\n\tconst char *pmu_name;\n\tbool deprecated;\n};\n\nstatic int cmp_sevent(const void *a, const void *b)\n{\n\tconst struct sevent *as = a;\n\tconst struct sevent *bs = b;\n\tbool a_iscpu, b_iscpu;\n\tint ret;\n\n\t \n\tif (!!as->desc != !!bs->desc)\n\t\treturn !!as->desc - !!bs->desc;\n\n\t \n\tret = strcmp(as->topic ?: \"\", bs->topic ?: \"\");\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ta_iscpu = as->pmu ? as->pmu->is_core : true;\n\tb_iscpu = bs->pmu ? bs->pmu->is_core : true;\n\tif (a_iscpu != b_iscpu)\n\t\treturn a_iscpu ? -1 : 1;\n\n\t \n\tif (as->pmu != bs->pmu) {\n\t\tret = strcmp(as->pmu_name ?: \"\", bs->pmu_name ?: \"\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn strcmp(as->name, bs->name);\n}\n\nstatic bool pmu_alias_is_duplicate(struct sevent *a, struct sevent *b)\n{\n\t \n\tif (strcmp(a->name ?: \"//\", b->name ?: \"//\"))\n\t\treturn false;\n\n\t \n\treturn strcmp(a->pmu_name, b->pmu_name) == 0;\n}\n\nstruct events_callback_state {\n\tstruct sevent *aliases;\n\tsize_t aliases_len;\n\tsize_t index;\n};\n\nstatic int perf_pmus__print_pmu_events__callback(void *vstate,\n\t\t\t\t\t\tstruct pmu_event_info *info)\n{\n\tstruct events_callback_state *state = vstate;\n\tstruct sevent *s;\n\n\tif (state->index >= state->aliases_len) {\n\t\tpr_err(\"Unexpected event %s/%s/\\n\", info->pmu->name, info->name);\n\t\treturn 1;\n\t}\n\ts = &state->aliases[state->index];\n\ts->pmu = info->pmu;\n#define COPY_STR(str) s->str = info->str ? strdup(info->str) : NULL\n\tCOPY_STR(name);\n\tCOPY_STR(alias);\n\tCOPY_STR(scale_unit);\n\tCOPY_STR(desc);\n\tCOPY_STR(long_desc);\n\tCOPY_STR(encoding_desc);\n\tCOPY_STR(topic);\n\tCOPY_STR(pmu_name);\n#undef COPY_STR\n\ts->deprecated = info->deprecated;\n\tstate->index++;\n\treturn 0;\n}\n\nvoid perf_pmus__print_pmu_events(const struct print_callbacks *print_cb, void *print_state)\n{\n\tstruct perf_pmu *pmu;\n\tint printed = 0;\n\tint len;\n\tstruct sevent *aliases;\n\tstruct events_callback_state state;\n\tbool skip_duplicate_pmus = print_cb->skip_duplicate_pmus(print_state);\n\tstruct perf_pmu *(*scan_fn)(struct perf_pmu *);\n\n\tif (skip_duplicate_pmus)\n\t\tscan_fn = perf_pmus__scan_skip_duplicates;\n\telse\n\t\tscan_fn = perf_pmus__scan;\n\n\tpmu = NULL;\n\tlen = 0;\n\twhile ((pmu = scan_fn(pmu)) != NULL)\n\t\tlen += perf_pmu__num_events(pmu);\n\n\taliases = zalloc(sizeof(struct sevent) * len);\n\tif (!aliases) {\n\t\tpr_err(\"FATAL: not enough memory to print PMU events\\n\");\n\t\treturn;\n\t}\n\tpmu = NULL;\n\tstate = (struct events_callback_state) {\n\t\t.aliases = aliases,\n\t\t.aliases_len = len,\n\t\t.index = 0,\n\t};\n\twhile ((pmu = scan_fn(pmu)) != NULL) {\n\t\tperf_pmu__for_each_event(pmu, skip_duplicate_pmus, &state,\n\t\t\t\t\t perf_pmus__print_pmu_events__callback);\n\t}\n\tqsort(aliases, len, sizeof(struct sevent), cmp_sevent);\n\tfor (int j = 0; j < len; j++) {\n\t\t \n\t\tif (j > 0 && pmu_alias_is_duplicate(&aliases[j], &aliases[j - 1]))\n\t\t\tcontinue;\n\n\t\tprint_cb->print_event(print_state,\n\t\t\t\taliases[j].pmu_name,\n\t\t\t\taliases[j].topic,\n\t\t\t\taliases[j].name,\n\t\t\t\taliases[j].alias,\n\t\t\t\taliases[j].scale_unit,\n\t\t\t\taliases[j].deprecated,\n\t\t\t\t\"Kernel PMU event\",\n\t\t\t\taliases[j].desc,\n\t\t\t\taliases[j].long_desc,\n\t\t\t\taliases[j].encoding_desc);\n\t\tzfree(&aliases[j].name);\n\t\tzfree(&aliases[j].alias);\n\t\tzfree(&aliases[j].scale_unit);\n\t\tzfree(&aliases[j].desc);\n\t\tzfree(&aliases[j].long_desc);\n\t\tzfree(&aliases[j].encoding_desc);\n\t\tzfree(&aliases[j].topic);\n\t\tzfree(&aliases[j].pmu_name);\n\t}\n\tif (printed && pager_in_use())\n\t\tprintf(\"\\n\");\n\n\tzfree(&aliases);\n}\n\nbool perf_pmus__have_event(const char *pname, const char *name)\n{\n\tstruct perf_pmu *pmu = perf_pmus__find(pname);\n\n\treturn pmu && perf_pmu__have_event(pmu, name);\n}\n\nint perf_pmus__num_core_pmus(void)\n{\n\tstatic int count;\n\n\tif (!count) {\n\t\tstruct perf_pmu *pmu = NULL;\n\n\t\twhile ((pmu = perf_pmus__scan_core(pmu)) != NULL)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\nstatic bool __perf_pmus__supports_extended_type(void)\n{\n\tstruct perf_pmu *pmu = NULL;\n\n\tif (perf_pmus__num_core_pmus() <= 1)\n\t\treturn false;\n\n\twhile ((pmu = perf_pmus__scan_core(pmu)) != NULL) {\n\t\tif (!is_event_supported(PERF_TYPE_HARDWARE, PERF_COUNT_HW_CPU_CYCLES | ((__u64)pmu->type << PERF_PMU_TYPE_SHIFT)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool perf_pmus__do_support_extended_type;\n\nstatic void perf_pmus__init_supports_extended_type(void)\n{\n\tperf_pmus__do_support_extended_type = __perf_pmus__supports_extended_type();\n}\n\nbool perf_pmus__supports_extended_type(void)\n{\n\tstatic pthread_once_t extended_type_once = PTHREAD_ONCE_INIT;\n\n\tpthread_once(&extended_type_once, perf_pmus__init_supports_extended_type);\n\n\treturn perf_pmus__do_support_extended_type;\n}\n\nchar *perf_pmus__default_pmu_name(void)\n{\n\tint fd;\n\tDIR *dir;\n\tstruct dirent *dent;\n\tchar *result = NULL;\n\n\tif (!list_empty(&core_pmus))\n\t\treturn strdup(list_first_entry(&core_pmus, struct perf_pmu, list)->name);\n\n\tfd = perf_pmu__event_source_devices_fd();\n\tif (fd < 0)\n\t\treturn strdup(\"cpu\");\n\n\tdir = fdopendir(fd);\n\tif (!dir) {\n\t\tclose(fd);\n\t\treturn strdup(\"cpu\");\n\t}\n\n\twhile ((dent = readdir(dir))) {\n\t\tif (!strcmp(dent->d_name, \".\") || !strcmp(dent->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (is_pmu_core(dent->d_name)) {\n\t\t\tresult = strdup(dent->d_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\treturn result ?: strdup(\"cpu\");\n}\n\nstruct perf_pmu *evsel__find_pmu(const struct evsel *evsel)\n{\n\tstruct perf_pmu *pmu = evsel->pmu;\n\n\tif (!pmu) {\n\t\tpmu = perf_pmus__find_by_type(evsel->core.attr.type);\n\t\t((struct evsel *)evsel)->pmu = pmu;\n\t}\n\treturn pmu;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}