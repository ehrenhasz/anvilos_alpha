{
  "module_name": "s390-cpumsf.c",
  "hash_id": "f1f74497202c9bd42afe9f8204e92ac959af5f59c2e8336dd2bcb78595140d79",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/s390-cpumsf.c",
  "human_readable_source": "\n \n\n#include <endian.h>\n#include <errno.h>\n#include <byteswap.h>\n#include <inttypes.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/zalloc.h>\n\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include \"color.h\"\n#include \"evsel.h\"\n#include \"evlist.h\"\n#include \"machine.h\"\n#include \"session.h\"\n#include \"tool.h\"\n#include \"debug.h\"\n#include \"auxtrace.h\"\n#include \"s390-cpumsf.h\"\n#include \"s390-cpumsf-kernel.h\"\n#include \"s390-cpumcf-kernel.h\"\n#include \"config.h\"\n#include \"util/sample.h\"\n\nstruct s390_cpumsf {\n\tstruct auxtrace\t\tauxtrace;\n\tstruct auxtrace_queues\tqueues;\n\tstruct auxtrace_heap\theap;\n\tstruct perf_session\t*session;\n\tstruct machine\t\t*machine;\n\tu32\t\t\tauxtrace_type;\n\tu32\t\t\tpmu_type;\n\tu16\t\t\tmachine_type;\n\tbool\t\t\tdata_queued;\n\tbool\t\t\tuse_logfile;\n\tchar\t\t\t*logdir;\n};\n\nstruct s390_cpumsf_queue {\n\tstruct s390_cpumsf\t*sf;\n\tunsigned int\t\tqueue_nr;\n\tstruct auxtrace_buffer\t*buffer;\n\tint\t\t\tcpu;\n\tFILE\t\t\t*logfile;\n\tFILE\t\t\t*logfile_ctr;\n};\n\n \nstatic int s390_cpumcf_dumpctr(struct s390_cpumsf *sf,\n\t\t\t       struct perf_sample *sample)\n{\n\tstruct s390_cpumsf_queue *sfq;\n\tstruct auxtrace_queue *q;\n\tint rc = 0;\n\n\tif (!sf->use_logfile || sf->queues.nr_queues <= sample->cpu)\n\t\treturn rc;\n\n\tq = &sf->queues.queue_array[sample->cpu];\n\tsfq = q->priv;\n\tif (!sfq)\t\t \n\t\treturn rc;\n\n\tif (!sfq->logfile_ctr) {\n\t\tchar *name;\n\n\t\trc = (sf->logdir)\n\t\t\t? asprintf(&name, \"%s/aux.ctr.%02x\",\n\t\t\t\t sf->logdir, sample->cpu)\n\t\t\t: asprintf(&name, \"aux.ctr.%02x\", sample->cpu);\n\t\tif (rc > 0)\n\t\t\tsfq->logfile_ctr = fopen(name, \"w\");\n\t\tif (sfq->logfile_ctr == NULL) {\n\t\t\tpr_err(\"Failed to open counter set log file %s, \"\n\t\t\t       \"continue...\\n\", name);\n\t\t\trc = 1;\n\t\t}\n\t\tfree(name);\n\t}\n\n\tif (sfq->logfile_ctr) {\n\t\t \n\t\tsize_t n = fwrite(sample->raw_data, sample->raw_size - 4, 1,\n\t\t\t\t  sfq->logfile_ctr);\n\t\tif (n != 1) {\n\t\t\tpr_err(\"Failed to write counter set data\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\treturn rc;\n}\n\n \nstatic bool s390_cpumsf_basic_show(const char *color, size_t pos,\n\t\t\t\t   struct hws_basic_entry *basicp)\n{\n\tstruct hws_basic_entry *basic = basicp;\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\tstruct hws_basic_entry local;\n\tunsigned long long word = be64toh(*(unsigned long long *)basicp);\n\n\tmemset(&local, 0, sizeof(local));\n\tlocal.def = be16toh(basicp->def);\n\tlocal.prim_asn = word & 0xffff;\n\tlocal.CL = word >> 30 & 0x3;\n\tlocal.I = word >> 32 & 0x1;\n\tlocal.AS = word >> 33 & 0x3;\n\tlocal.P = word >> 35 & 0x1;\n\tlocal.W = word >> 36 & 0x1;\n\tlocal.T = word >> 37 & 0x1;\n\tlocal.U = word >> 40 & 0xf;\n\tlocal.ia = be64toh(basicp->ia);\n\tlocal.gpp = be64toh(basicp->gpp);\n\tlocal.hpp = be64toh(basicp->hpp);\n\tbasic = &local;\n#endif\n\tif (basic->def != 1) {\n\t\tpr_err(\"Invalid AUX trace basic entry [%#08zx]\\n\", pos);\n\t\treturn false;\n\t}\n\tcolor_fprintf(stdout, color, \"    [%#08zx] Basic   Def:%04x Inst:%#04x\"\n\t\t      \" %c%c%c%c AS:%d ASN:%#04x IA:%#018llx\\n\"\n\t\t      \"\\t\\tCL:%d HPP:%#018llx GPP:%#018llx\\n\",\n\t\t      pos, basic->def, basic->U,\n\t\t      basic->T ? 'T' : ' ',\n\t\t      basic->W ? 'W' : ' ',\n\t\t      basic->P ? 'P' : ' ',\n\t\t      basic->I ? 'I' : ' ',\n\t\t      basic->AS, basic->prim_asn, basic->ia, basic->CL,\n\t\t      basic->hpp, basic->gpp);\n\treturn true;\n}\n\n \nstatic bool s390_cpumsf_diag_show(const char *color, size_t pos,\n\t\t\t\t  struct hws_diag_entry *diagp)\n{\n\tstruct hws_diag_entry *diag = diagp;\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\tstruct hws_diag_entry local;\n\tunsigned long long word = be64toh(*(unsigned long long *)diagp);\n\n\tlocal.def = be16toh(diagp->def);\n\tlocal.I = word >> 32 & 0x1;\n\tdiag = &local;\n#endif\n\tif (diag->def < S390_CPUMSF_DIAG_DEF_FIRST) {\n\t\tpr_err(\"Invalid AUX trace diagnostic entry [%#08zx]\\n\", pos);\n\t\treturn false;\n\t}\n\tcolor_fprintf(stdout, color, \"    [%#08zx] Diag    Def:%04x %c\\n\",\n\t\t      pos, diag->def, diag->I ? 'I' : ' ');\n\treturn true;\n}\n\n \nstatic unsigned long long trailer_timestamp(struct hws_trailer_entry *te,\n\t\t\t\t\t    int idx)\n{\n\t \n\tunsigned long long ts;\n\n\tmemcpy(&ts, &te->timestamp[idx], sizeof(ts));\n\treturn be64toh(ts);\n}\n\n \nstatic bool s390_cpumsf_trailer_show(const char *color, size_t pos,\n\t\t\t\t     struct hws_trailer_entry *te)\n{\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\tstruct hws_trailer_entry local;\n\tconst unsigned long long flags = be64toh(te->flags);\n\n\tmemset(&local, 0, sizeof(local));\n\tlocal.f = flags >> 63 & 0x1;\n\tlocal.a = flags >> 62 & 0x1;\n\tlocal.t = flags >> 61 & 0x1;\n\tlocal.bsdes = be16toh((flags >> 16 & 0xffff));\n\tlocal.dsdes = be16toh((flags & 0xffff));\n\tmemcpy(&local.timestamp, te->timestamp, sizeof(te->timestamp));\n\tlocal.overflow = be64toh(te->overflow);\n\tlocal.clock_base = be64toh(te->progusage[0]) >> 63 & 1;\n\tlocal.progusage2 = be64toh(te->progusage2);\n\tte = &local;\n#endif\n\tif (te->bsdes != sizeof(struct hws_basic_entry)) {\n\t\tpr_err(\"Invalid AUX trace trailer entry [%#08zx]\\n\", pos);\n\t\treturn false;\n\t}\n\tcolor_fprintf(stdout, color, \"    [%#08zx] Trailer %c%c%c bsdes:%d\"\n\t\t      \" dsdes:%d Overflow:%lld Time:%#llx\\n\"\n\t\t      \"\\t\\tC:%d TOD:%#lx\\n\",\n\t\t      pos,\n\t\t      te->f ? 'F' : ' ',\n\t\t      te->a ? 'A' : ' ',\n\t\t      te->t ? 'T' : ' ',\n\t\t      te->bsdes, te->dsdes, te->overflow,\n\t\t      trailer_timestamp(te, te->clock_base),\n\t\t      te->clock_base, te->progusage2);\n\treturn true;\n}\n\n \nstatic bool s390_cpumsf_validate(int machine_type,\n\t\t\t\t unsigned char *buf, size_t len,\n\t\t\t\t unsigned short *bsdes,\n\t\t\t\t unsigned short *dsdes)\n{\n\tstruct hws_basic_entry *basic = (struct hws_basic_entry *)buf;\n\tstruct hws_trailer_entry *te;\n\n\t*dsdes = *bsdes = 0;\n\tif (len & (S390_CPUMSF_PAGESZ - 1))\t \n\t\treturn false;\n\tif (be16toh(basic->def) != 1)\t \n\t\treturn false;\n\t \n\tte = (struct hws_trailer_entry *)(buf + S390_CPUMSF_PAGESZ\n\t\t\t\t\t      - sizeof(*te));\n\t*bsdes = be16toh(te->bsdes);\n\t*dsdes = be16toh(te->dsdes);\n\tif (!te->bsdes && !te->dsdes) {\n\t\t \n\t\tswitch (machine_type) {\n\t\tcase 2097:\n\t\tcase 2098:\n\t\t\t*dsdes = 64;\n\t\t\t*bsdes = 32;\n\t\t\tbreak;\n\t\tcase 2817:\n\t\tcase 2818:\n\t\t\t*dsdes = 74;\n\t\t\t*bsdes = 32;\n\t\t\tbreak;\n\t\tcase 2827:\n\t\tcase 2828:\n\t\t\t*dsdes = 85;\n\t\t\t*bsdes = 32;\n\t\t\tbreak;\n\t\tcase 2964:\n\t\tcase 2965:\n\t\t\t*dsdes = 112;\n\t\t\t*bsdes = 32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n \nstatic bool s390_cpumsf_reached_trailer(size_t entry_sz, size_t pos)\n{\n\tsize_t payload = S390_CPUMSF_PAGESZ - sizeof(struct hws_trailer_entry);\n\n\tif (payload - (pos & (S390_CPUMSF_PAGESZ - 1)) < entry_sz)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic void s390_cpumsf_dump(struct s390_cpumsf *sf,\n\t\t\t     unsigned char *buf, size_t len)\n{\n\tconst char *color = PERF_COLOR_BLUE;\n\tstruct hws_basic_entry *basic;\n\tstruct hws_diag_entry *diag;\n\tunsigned short bsdes, dsdes;\n\tsize_t pos = 0;\n\n\tcolor_fprintf(stdout, color,\n\t\t      \". ... s390 AUX data: size %zu bytes\\n\",\n\t\t      len);\n\n\tif (!s390_cpumsf_validate(sf->machine_type, buf, len, &bsdes,\n\t\t\t\t  &dsdes)) {\n\t\tpr_err(\"Invalid AUX trace data block size:%zu\"\n\t\t       \" (type:%d bsdes:%hd dsdes:%hd)\\n\",\n\t\t       len, sf->machine_type, bsdes, dsdes);\n\t\treturn;\n\t}\n\n\t \n\twhile (pos < len) {\n\t\t \n\t\tbasic = (struct hws_basic_entry *)(buf + pos);\n\t\tif (s390_cpumsf_basic_show(color, pos, basic))\n\t\t\tpos += bsdes;\n\t\telse\n\t\t\treturn;\n\n\t\t \n\t\tdiag = (struct hws_diag_entry *)(buf + pos);\n\t\tif (s390_cpumsf_diag_show(color, pos, diag))\n\t\t\tpos += dsdes;\n\t\telse\n\t\t\treturn;\n\n\t\t \n\t\tif (!s390_cpumsf_reached_trailer(bsdes + dsdes, pos)) {\n\t\t\t \n\t\t\tstruct hws_trailer_entry te;\n\n\t\t\tpos = (pos + S390_CPUMSF_PAGESZ)\n\t\t\t       & ~(S390_CPUMSF_PAGESZ - 1);\n\t\t\tpos -= sizeof(te);\n\t\t\tmemcpy(&te, buf + pos, sizeof(te));\n\t\t\t \n\t\t\tte.bsdes = bsdes;\n\t\t\tte.dsdes = dsdes;\n\t\t\tif (s390_cpumsf_trailer_show(color, pos, &te))\n\t\t\t\tpos += sizeof(te);\n\t\t\telse\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void s390_cpumsf_dump_event(struct s390_cpumsf *sf, unsigned char *buf,\n\t\t\t\t   size_t len)\n{\n\tprintf(\".\\n\");\n\ts390_cpumsf_dump(sf, buf, len);\n}\n\n#define\tS390_LPP_PID_MASK\t0xffffffff\n\nstatic bool s390_cpumsf_make_event(size_t pos,\n\t\t\t\t   struct hws_basic_entry *basic,\n\t\t\t\t   struct s390_cpumsf_queue *sfq)\n{\n\tstruct perf_sample sample = {\n\t\t\t\t.ip = basic->ia,\n\t\t\t\t.pid = basic->hpp & S390_LPP_PID_MASK,\n\t\t\t\t.tid = basic->hpp & S390_LPP_PID_MASK,\n\t\t\t\t.cpumode = PERF_RECORD_MISC_CPUMODE_UNKNOWN,\n\t\t\t\t.cpu = sfq->cpu,\n\t\t\t\t.period = 1\n\t\t\t    };\n\tunion perf_event event;\n\n\tmemset(&event, 0, sizeof(event));\n\tif (basic->CL == 1)\t \n\t\tsample.cpumode = basic->P ? PERF_RECORD_MISC_USER\n\t\t\t\t\t  : PERF_RECORD_MISC_KERNEL;\n\telse if (basic->CL == 2)\t \n\t\tsample.cpumode = basic->P ? PERF_RECORD_MISC_GUEST_USER\n\t\t\t\t\t  : PERF_RECORD_MISC_GUEST_KERNEL;\n\telse if (basic->gpp || basic->prim_asn != 0xffff)\n\t\t \n\t\tsample.cpumode = basic->P ? PERF_RECORD_MISC_GUEST_USER\n\t\t\t\t\t  : PERF_RECORD_MISC_GUEST_KERNEL;\n\telse\n\t\tsample.cpumode = basic->P ? PERF_RECORD_MISC_USER\n\t\t\t\t\t  : PERF_RECORD_MISC_KERNEL;\n\n\tevent.sample.header.type = PERF_RECORD_SAMPLE;\n\tevent.sample.header.misc = sample.cpumode;\n\tevent.sample.header.size = sizeof(struct perf_event_header);\n\n\tpr_debug4(\"%s pos:%#zx ip:%#\" PRIx64 \" P:%d CL:%d pid:%d.%d cpumode:%d cpu:%d\\n\",\n\t\t __func__, pos, sample.ip, basic->P, basic->CL, sample.pid,\n\t\t sample.tid, sample.cpumode, sample.cpu);\n\tif (perf_session__deliver_synth_event(sfq->sf->session, &event,\n\t\t\t\t\t      &sample)) {\n\t\tpr_err(\"s390 Auxiliary Trace: failed to deliver event\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic unsigned long long get_trailer_time(const unsigned char *buf)\n{\n\tstruct hws_trailer_entry *te;\n\tunsigned long long aux_time, progusage2;\n\tbool clock_base;\n\n\tte = (struct hws_trailer_entry *)(buf + S390_CPUMSF_PAGESZ\n\t\t\t\t\t      - sizeof(*te));\n\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\tclock_base = be64toh(te->progusage[0]) >> 63 & 0x1;\n\tprogusage2 = be64toh(te->progusage[1]);\n#else\n\tclock_base = te->clock_base;\n\tprogusage2 = te->progusage2;\n#endif\n\tif (!clock_base)\t \n\t\treturn 0;\n\n\t \n\taux_time = trailer_timestamp(te, clock_base) - progusage2;\n\taux_time = (aux_time >> 9) * 125 + (((aux_time & 0x1ff) * 125) >> 9);\n\treturn aux_time;\n}\n\n \nstatic int s390_cpumsf_samples(struct s390_cpumsf_queue *sfq, u64 *ts)\n{\n\tstruct s390_cpumsf *sf = sfq->sf;\n\tunsigned char *buf = sfq->buffer->use_data;\n\tsize_t len = sfq->buffer->use_size;\n\tstruct hws_basic_entry *basic;\n\tunsigned short bsdes, dsdes;\n\tsize_t pos = 0;\n\tint err = 1;\n\tu64 aux_ts;\n\n\tif (!s390_cpumsf_validate(sf->machine_type, buf, len, &bsdes,\n\t\t\t\t  &dsdes)) {\n\t\t*ts = ~0ULL;\n\t\treturn -1;\n\t}\n\n\t \n\taux_ts = get_trailer_time(buf);\n\tif (!aux_ts) {\n\t\tpr_err(\"[%#08\" PRIx64 \"] Invalid AUX trailer entry TOD clock base\\n\",\n\t\t       (s64)sfq->buffer->data_offset);\n\t\taux_ts = ~0ULL;\n\t\tgoto out;\n\t}\n\tif (aux_ts > *ts) {\n\t\t*ts = aux_ts;\n\t\treturn 0;\n\t}\n\n\twhile (pos < len) {\n\t\t \n\t\tbasic = (struct hws_basic_entry *)(buf + pos);\n\t\tif (s390_cpumsf_make_event(pos, basic, sfq))\n\t\t\tpos += bsdes;\n\t\telse {\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpos += dsdes;\t \n\n\t\t \n\t\tif (!s390_cpumsf_reached_trailer(bsdes + dsdes, pos)) {\n\t\t\tpos = (pos + S390_CPUMSF_PAGESZ)\n\t\t\t       & ~(S390_CPUMSF_PAGESZ - 1);\n\t\t\t \n\t\t\tif (pos >= len)\n\t\t\t\tbreak;\n\t\t\taux_ts = get_trailer_time(buf + pos);\n\t\t\tif (!aux_ts) {\n\t\t\t\taux_ts = ~0ULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (aux_ts > *ts) {\n\t\t\t\t*ts = aux_ts;\n\t\t\t\tsfq->buffer->use_data += pos;\n\t\t\t\tsfq->buffer->use_size -= pos;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\nout:\n\t*ts = aux_ts;\n\tsfq->buffer->use_size = 0;\n\tsfq->buffer->use_data = NULL;\n\treturn err;\t \n}\n\n \nstatic int s390_cpumsf_run_decoder(struct s390_cpumsf_queue *sfq,\n\t\t\t\t   u64 *ts)\n{\n\n\tstruct auxtrace_buffer *buffer;\n\tstruct auxtrace_queue *queue;\n\tint err;\n\n\tqueue = &sfq->sf->queues.queue_array[sfq->queue_nr];\n\n\t \n\tif (sfq->buffer == NULL) {\n\t\tsfq->buffer = buffer = auxtrace_buffer__next(queue,\n\t\t\t\t\t\t\t     sfq->buffer);\n\t\tif (!buffer) {\n\t\t\t*ts = ~0ULL;\n\t\t\treturn 1;\t \n\t\t}\n\t\t \n\t\tif (buffer->data) {\n\t\t\tbuffer->use_size = buffer->size;\n\t\t\tbuffer->use_data = buffer->data;\n\t\t}\n\t\tif (sfq->logfile) {\t \n\t\t\tsize_t rc = fwrite(buffer->data, buffer->size, 1,\n\t\t\t\t\t   sfq->logfile);\n\t\t\tif (rc != 1)\n\t\t\t\tpr_err(\"Failed to write auxiliary data\\n\");\n\t\t}\n\t} else\n\t\tbuffer = sfq->buffer;\n\n\tif (!buffer->data) {\n\t\tint fd = perf_data__fd(sfq->sf->session->data);\n\n\t\tbuffer->data = auxtrace_buffer__get_data(buffer, fd);\n\t\tif (!buffer->data)\n\t\t\treturn -ENOMEM;\n\t\tbuffer->use_size = buffer->size;\n\t\tbuffer->use_data = buffer->data;\n\n\t\tif (sfq->logfile) {\t \n\t\t\tsize_t rc = fwrite(buffer->data, buffer->size, 1,\n\t\t\t\t\t   sfq->logfile);\n\t\t\tif (rc != 1)\n\t\t\t\tpr_err(\"Failed to write auxiliary data\\n\");\n\t\t}\n\t}\n\tpr_debug4(\"%s queue_nr:%d buffer:%\" PRId64 \" offset:%#\" PRIx64 \" size:%#zx rest:%#zx\\n\",\n\t\t  __func__, sfq->queue_nr, buffer->buffer_nr, buffer->offset,\n\t\t  buffer->size, buffer->use_size);\n\terr = s390_cpumsf_samples(sfq, ts);\n\n\t \n\tif (err) {\n\t\tsfq->buffer = NULL;\n\t\tlist_del_init(&buffer->list);\n\t\tauxtrace_buffer__free(buffer);\n\t\tif (err > 0)\t\t \n\t\t\terr = 0;\n\t}\n\treturn err;\n}\n\nstatic struct s390_cpumsf_queue *\ns390_cpumsf_alloc_queue(struct s390_cpumsf *sf, unsigned int queue_nr)\n{\n\tstruct s390_cpumsf_queue *sfq;\n\n\tsfq = zalloc(sizeof(struct s390_cpumsf_queue));\n\tif (sfq == NULL)\n\t\treturn NULL;\n\n\tsfq->sf = sf;\n\tsfq->queue_nr = queue_nr;\n\tsfq->cpu = -1;\n\tif (sf->use_logfile) {\n\t\tchar *name;\n\t\tint rc;\n\n\t\trc = (sf->logdir)\n\t\t\t? asprintf(&name, \"%s/aux.smp.%02x\",\n\t\t\t\t sf->logdir, queue_nr)\n\t\t\t: asprintf(&name, \"aux.smp.%02x\", queue_nr);\n\t\tif (rc > 0)\n\t\t\tsfq->logfile = fopen(name, \"w\");\n\t\tif (sfq->logfile == NULL) {\n\t\t\tpr_err(\"Failed to open auxiliary log file %s,\"\n\t\t\t       \"continue...\\n\", name);\n\t\t\tsf->use_logfile = false;\n\t\t}\n\t\tfree(name);\n\t}\n\treturn sfq;\n}\n\nstatic int s390_cpumsf_setup_queue(struct s390_cpumsf *sf,\n\t\t\t\t   struct auxtrace_queue *queue,\n\t\t\t\t   unsigned int queue_nr, u64 ts)\n{\n\tstruct s390_cpumsf_queue *sfq = queue->priv;\n\n\tif (list_empty(&queue->head))\n\t\treturn 0;\n\n\tif (sfq == NULL) {\n\t\tsfq = s390_cpumsf_alloc_queue(sf, queue_nr);\n\t\tif (!sfq)\n\t\t\treturn -ENOMEM;\n\t\tqueue->priv = sfq;\n\n\t\tif (queue->cpu != -1)\n\t\t\tsfq->cpu = queue->cpu;\n\t}\n\treturn auxtrace_heap__add(&sf->heap, queue_nr, ts);\n}\n\nstatic int s390_cpumsf_setup_queues(struct s390_cpumsf *sf, u64 ts)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < sf->queues.nr_queues; i++) {\n\t\tret = s390_cpumsf_setup_queue(sf, &sf->queues.queue_array[i],\n\t\t\t\t\t      i, ts);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int s390_cpumsf_update_queues(struct s390_cpumsf *sf, u64 ts)\n{\n\tif (!sf->queues.new_data)\n\t\treturn 0;\n\n\tsf->queues.new_data = false;\n\treturn s390_cpumsf_setup_queues(sf, ts);\n}\n\nstatic int s390_cpumsf_process_queues(struct s390_cpumsf *sf, u64 timestamp)\n{\n\tunsigned int queue_nr;\n\tu64 ts;\n\tint ret;\n\n\twhile (1) {\n\t\tstruct auxtrace_queue *queue;\n\t\tstruct s390_cpumsf_queue *sfq;\n\n\t\tif (!sf->heap.heap_cnt)\n\t\t\treturn 0;\n\n\t\tif (sf->heap.heap_array[0].ordinal >= timestamp)\n\t\t\treturn 0;\n\n\t\tqueue_nr = sf->heap.heap_array[0].queue_nr;\n\t\tqueue = &sf->queues.queue_array[queue_nr];\n\t\tsfq = queue->priv;\n\n\t\tauxtrace_heap__pop(&sf->heap);\n\t\tif (sf->heap.heap_cnt) {\n\t\t\tts = sf->heap.heap_array[0].ordinal + 1;\n\t\t\tif (ts > timestamp)\n\t\t\t\tts = timestamp;\n\t\t} else {\n\t\t\tts = timestamp;\n\t\t}\n\n\t\tret = s390_cpumsf_run_decoder(sfq, &ts);\n\t\tif (ret < 0) {\n\t\t\tauxtrace_heap__add(&sf->heap, queue_nr, ts);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!ret) {\n\t\t\tret = auxtrace_heap__add(&sf->heap, queue_nr, ts);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int s390_cpumsf_synth_error(struct s390_cpumsf *sf, int code, int cpu,\n\t\t\t\t   pid_t pid, pid_t tid, u64 ip, u64 timestamp)\n{\n\tchar msg[MAX_AUXTRACE_ERROR_MSG];\n\tunion perf_event event;\n\tint err;\n\n\tstrncpy(msg, \"Lost Auxiliary Trace Buffer\", sizeof(msg) - 1);\n\tauxtrace_synth_error(&event.auxtrace_error, PERF_AUXTRACE_ERROR_ITRACE,\n\t\t\t     code, cpu, pid, tid, ip, msg, timestamp);\n\n\terr = perf_session__deliver_synth_event(sf->session, &event, NULL);\n\tif (err)\n\t\tpr_err(\"s390 Auxiliary Trace: failed to deliver error event,\"\n\t\t\t\"error %d\\n\", err);\n\treturn err;\n}\n\nstatic int s390_cpumsf_lost(struct s390_cpumsf *sf, struct perf_sample *sample)\n{\n\treturn s390_cpumsf_synth_error(sf, 1, sample->cpu,\n\t\t\t\t       sample->pid, sample->tid, 0,\n\t\t\t\t       sample->time);\n}\n\nstatic int\ns390_cpumsf_process_event(struct perf_session *session,\n\t\t\t  union perf_event *event,\n\t\t\t  struct perf_sample *sample,\n\t\t\t  struct perf_tool *tool)\n{\n\tstruct s390_cpumsf *sf = container_of(session->auxtrace,\n\t\t\t\t\t      struct s390_cpumsf,\n\t\t\t\t\t      auxtrace);\n\tu64 timestamp = sample->time;\n\tstruct evsel *ev_bc000;\n\n\tint err = 0;\n\n\tif (dump_trace)\n\t\treturn 0;\n\n\tif (!tool->ordered_events) {\n\t\tpr_err(\"s390 Auxiliary Trace requires ordered events\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (event->header.type == PERF_RECORD_SAMPLE &&\n\t    sample->raw_size) {\n\t\t \n\t\tev_bc000 = evlist__event2evsel(session->evlist, event);\n\t\tif (ev_bc000 &&\n\t\t    ev_bc000->core.attr.config == PERF_EVENT_CPUM_CF_DIAG)\n\t\t\terr = s390_cpumcf_dumpctr(sf, sample);\n\t\treturn err;\n\t}\n\n\tif (event->header.type == PERF_RECORD_AUX &&\n\t    event->aux.flags & PERF_AUX_FLAG_TRUNCATED)\n\t\treturn s390_cpumsf_lost(sf, sample);\n\n\tif (timestamp) {\n\t\terr = s390_cpumsf_update_queues(sf, timestamp);\n\t\tif (!err)\n\t\t\terr = s390_cpumsf_process_queues(sf, timestamp);\n\t}\n\treturn err;\n}\n\nstruct s390_cpumsf_synth {\n\tstruct perf_tool cpumsf_tool;\n\tstruct perf_session *session;\n};\n\nstatic int\ns390_cpumsf_process_auxtrace_event(struct perf_session *session,\n\t\t\t\t   union perf_event *event __maybe_unused,\n\t\t\t\t   struct perf_tool *tool __maybe_unused)\n{\n\tstruct s390_cpumsf *sf = container_of(session->auxtrace,\n\t\t\t\t\t      struct s390_cpumsf,\n\t\t\t\t\t      auxtrace);\n\n\tint fd = perf_data__fd(session->data);\n\tstruct auxtrace_buffer *buffer;\n\toff_t data_offset;\n\tint err;\n\n\tif (sf->data_queued)\n\t\treturn 0;\n\n\tif (perf_data__is_pipe(session->data)) {\n\t\tdata_offset = 0;\n\t} else {\n\t\tdata_offset = lseek(fd, 0, SEEK_CUR);\n\t\tif (data_offset == -1)\n\t\t\treturn -errno;\n\t}\n\n\terr = auxtrace_queues__add_event(&sf->queues, session, event,\n\t\t\t\t\t data_offset, &buffer);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (dump_trace) {\n\t\tif (auxtrace_buffer__get_data(buffer, fd)) {\n\t\t\ts390_cpumsf_dump_event(sf, buffer->data,\n\t\t\t\t\t       buffer->size);\n\t\t\tauxtrace_buffer__put_data(buffer);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void s390_cpumsf_free_events(struct perf_session *session __maybe_unused)\n{\n}\n\nstatic int s390_cpumsf_flush(struct perf_session *session __maybe_unused,\n\t\t\t     struct perf_tool *tool __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic void s390_cpumsf_free_queues(struct perf_session *session)\n{\n\tstruct s390_cpumsf *sf = container_of(session->auxtrace,\n\t\t\t\t\t      struct s390_cpumsf,\n\t\t\t\t\t      auxtrace);\n\tstruct auxtrace_queues *queues = &sf->queues;\n\tunsigned int i;\n\n\tfor (i = 0; i < queues->nr_queues; i++) {\n\t\tstruct s390_cpumsf_queue *sfq = (struct s390_cpumsf_queue *)\n\t\t\t\t\t\tqueues->queue_array[i].priv;\n\n\t\tif (sfq != NULL) {\n\t\t\tif (sfq->logfile) {\n\t\t\t\tfclose(sfq->logfile);\n\t\t\t\tsfq->logfile = NULL;\n\t\t\t}\n\t\t\tif (sfq->logfile_ctr) {\n\t\t\t\tfclose(sfq->logfile_ctr);\n\t\t\t\tsfq->logfile_ctr = NULL;\n\t\t\t}\n\t\t}\n\t\tzfree(&queues->queue_array[i].priv);\n\t}\n\tauxtrace_queues__free(queues);\n}\n\nstatic void s390_cpumsf_free(struct perf_session *session)\n{\n\tstruct s390_cpumsf *sf = container_of(session->auxtrace,\n\t\t\t\t\t      struct s390_cpumsf,\n\t\t\t\t\t      auxtrace);\n\n\tauxtrace_heap__free(&sf->heap);\n\ts390_cpumsf_free_queues(session);\n\tsession->auxtrace = NULL;\n\tzfree(&sf->logdir);\n\tfree(sf);\n}\n\nstatic bool\ns390_cpumsf_evsel_is_auxtrace(struct perf_session *session __maybe_unused,\n\t\t\t      struct evsel *evsel)\n{\n\treturn evsel->core.attr.type == PERF_TYPE_RAW &&\n\t       evsel->core.attr.config == PERF_EVENT_CPUM_SF_DIAG;\n}\n\nstatic int s390_cpumsf_get_type(const char *cpuid)\n{\n\tint ret, family = 0;\n\n\tret = sscanf(cpuid, \"%*[^,],%u\", &family);\n\treturn (ret == 1) ? family : 0;\n}\n\n \nstatic bool check_auxtrace_itrace(struct itrace_synth_opts *itops)\n{\n\tbool ison = false;\n\n\tif (!itops || !itops->set)\n\t\treturn true;\n\tison = itops->inject || itops->instructions || itops->branches ||\n\t\titops->transactions || itops->ptwrites ||\n\t\titops->pwr_events || itops->errors ||\n\t\titops->dont_decode || itops->calls || itops->returns ||\n\t\titops->callchain || itops->thread_stack ||\n\t\titops->last_branch || itops->add_callchain ||\n\t\titops->add_last_branch;\n\tif (!ison)\n\t\treturn true;\n\tpr_err(\"Unsupported --itrace options specified\\n\");\n\treturn false;\n}\n\n \nstatic int s390_cpumsf__config(const char *var, const char *value, void *cb)\n{\n\tstruct s390_cpumsf *sf = cb;\n\tstruct stat stbuf;\n\tint rc;\n\n\tif (strcmp(var, \"auxtrace.dumpdir\"))\n\t\treturn 0;\n\tsf->logdir = strdup(value);\n\tif (sf->logdir == NULL) {\n\t\tpr_err(\"Failed to find auxtrace log directory %s,\"\n\t\t       \" continue with current directory...\\n\", value);\n\t\treturn 1;\n\t}\n\trc = stat(sf->logdir, &stbuf);\n\tif (rc == -1 || !S_ISDIR(stbuf.st_mode)) {\n\t\tpr_err(\"Missing auxtrace log directory %s,\"\n\t\t       \" continue with current directory...\\n\", value);\n\t\tzfree(&sf->logdir);\n\t}\n\treturn 1;\n}\n\nint s390_cpumsf_process_auxtrace_info(union perf_event *event,\n\t\t\t\t      struct perf_session *session)\n{\n\tstruct perf_record_auxtrace_info *auxtrace_info = &event->auxtrace_info;\n\tstruct s390_cpumsf *sf;\n\tint err;\n\n\tif (auxtrace_info->header.size < sizeof(struct perf_record_auxtrace_info))\n\t\treturn -EINVAL;\n\n\tsf = zalloc(sizeof(struct s390_cpumsf));\n\tif (sf == NULL)\n\t\treturn -ENOMEM;\n\n\tif (!check_auxtrace_itrace(session->itrace_synth_opts)) {\n\t\terr = -EINVAL;\n\t\tgoto err_free;\n\t}\n\tsf->use_logfile = session->itrace_synth_opts->log;\n\tif (sf->use_logfile)\n\t\tperf_config(s390_cpumsf__config, sf);\n\n\terr = auxtrace_queues__init(&sf->queues);\n\tif (err)\n\t\tgoto err_free;\n\n\tsf->session = session;\n\tsf->machine = &session->machines.host;  \n\tsf->auxtrace_type = auxtrace_info->type;\n\tsf->pmu_type = PERF_TYPE_RAW;\n\tsf->machine_type = s390_cpumsf_get_type(session->evlist->env->cpuid);\n\n\tsf->auxtrace.process_event = s390_cpumsf_process_event;\n\tsf->auxtrace.process_auxtrace_event = s390_cpumsf_process_auxtrace_event;\n\tsf->auxtrace.flush_events = s390_cpumsf_flush;\n\tsf->auxtrace.free_events = s390_cpumsf_free_events;\n\tsf->auxtrace.free = s390_cpumsf_free;\n\tsf->auxtrace.evsel_is_auxtrace = s390_cpumsf_evsel_is_auxtrace;\n\tsession->auxtrace = &sf->auxtrace;\n\n\tif (dump_trace)\n\t\treturn 0;\n\n\terr = auxtrace_queues__process_index(&sf->queues, session);\n\tif (err)\n\t\tgoto err_free_queues;\n\n\tif (sf->queues.populated)\n\t\tsf->data_queued = true;\n\n\treturn 0;\n\nerr_free_queues:\n\tauxtrace_queues__free(&sf->queues);\n\tsession->auxtrace = NULL;\nerr_free:\n\tzfree(&sf->logdir);\n\tfree(sf);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}