{
  "module_name": "maps.c",
  "hash_id": "3c53170b78c169dc82d6ec9d1160f2f43fe1c3c501aa8b63ded691da714a615d",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/maps.c",
  "human_readable_source": "\n#include <errno.h>\n#include <stdlib.h>\n#include <linux/zalloc.h>\n#include \"debug.h\"\n#include \"dso.h\"\n#include \"map.h\"\n#include \"maps.h\"\n#include \"thread.h\"\n#include \"ui/ui.h\"\n#include \"unwind.h\"\n\nstatic void maps__init(struct maps *maps, struct machine *machine)\n{\n\trefcount_set(maps__refcnt(maps), 1);\n\tinit_rwsem(maps__lock(maps));\n\tRC_CHK_ACCESS(maps)->entries = RB_ROOT;\n\tRC_CHK_ACCESS(maps)->machine = machine;\n\tRC_CHK_ACCESS(maps)->last_search_by_name = NULL;\n\tRC_CHK_ACCESS(maps)->nr_maps = 0;\n\tRC_CHK_ACCESS(maps)->maps_by_name = NULL;\n}\n\nstatic void __maps__free_maps_by_name(struct maps *maps)\n{\n\t \n\tfor (unsigned int i = 0; i < maps__nr_maps(maps); i++)\n\t\tmap__put(maps__maps_by_name(maps)[i]);\n\n\tzfree(&RC_CHK_ACCESS(maps)->maps_by_name);\n\tRC_CHK_ACCESS(maps)->nr_maps_allocated = 0;\n}\n\nstatic int __maps__insert(struct maps *maps, struct map *map)\n{\n\tstruct rb_node **p = &maps__entries(maps)->rb_node;\n\tstruct rb_node *parent = NULL;\n\tconst u64 ip = map__start(map);\n\tstruct map_rb_node *m, *new_rb_node;\n\n\tnew_rb_node = malloc(sizeof(*new_rb_node));\n\tif (!new_rb_node)\n\t\treturn -ENOMEM;\n\n\tRB_CLEAR_NODE(&new_rb_node->rb_node);\n\tnew_rb_node->map = map__get(map);\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tm = rb_entry(parent, struct map_rb_node, rb_node);\n\t\tif (ip < map__start(m->map))\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_rb_node->rb_node, parent, p);\n\trb_insert_color(&new_rb_node->rb_node, maps__entries(maps));\n\treturn 0;\n}\n\nint maps__insert(struct maps *maps, struct map *map)\n{\n\tint err;\n\tconst struct dso *dso = map__dso(map);\n\n\tdown_write(maps__lock(maps));\n\terr = __maps__insert(maps, map);\n\tif (err)\n\t\tgoto out;\n\n\t++RC_CHK_ACCESS(maps)->nr_maps;\n\n\tif (dso && dso->kernel) {\n\t\tstruct kmap *kmap = map__kmap(map);\n\n\t\tif (kmap)\n\t\t\tkmap->kmaps = maps;\n\t\telse\n\t\t\tpr_err(\"Internal error: kernel dso with non kernel map\\n\");\n\t}\n\n\n\t \n\tif (maps__maps_by_name(maps)) {\n\t\tif (maps__nr_maps(maps) > RC_CHK_ACCESS(maps)->nr_maps_allocated) {\n\t\t\tint nr_allocate = maps__nr_maps(maps) * 2;\n\t\t\tstruct map **maps_by_name = realloc(maps__maps_by_name(maps),\n\t\t\t\t\t\t\t    nr_allocate * sizeof(map));\n\n\t\t\tif (maps_by_name == NULL) {\n\t\t\t\t__maps__free_maps_by_name(maps);\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tRC_CHK_ACCESS(maps)->maps_by_name = maps_by_name;\n\t\t\tRC_CHK_ACCESS(maps)->nr_maps_allocated = nr_allocate;\n\t\t}\n\t\tmaps__maps_by_name(maps)[maps__nr_maps(maps) - 1] = map__get(map);\n\t\t__maps__sort_by_name(maps);\n\t}\n out:\n\tup_write(maps__lock(maps));\n\treturn err;\n}\n\nstatic void __maps__remove(struct maps *maps, struct map_rb_node *rb_node)\n{\n\trb_erase_init(&rb_node->rb_node, maps__entries(maps));\n\tmap__put(rb_node->map);\n\tfree(rb_node);\n}\n\nvoid maps__remove(struct maps *maps, struct map *map)\n{\n\tstruct map_rb_node *rb_node;\n\n\tdown_write(maps__lock(maps));\n\tif (RC_CHK_ACCESS(maps)->last_search_by_name == map)\n\t\tRC_CHK_ACCESS(maps)->last_search_by_name = NULL;\n\n\trb_node = maps__find_node(maps, map);\n\tassert(rb_node->RC_CHK_ACCESS(map) == RC_CHK_ACCESS(map));\n\t__maps__remove(maps, rb_node);\n\tif (maps__maps_by_name(maps))\n\t\t__maps__free_maps_by_name(maps);\n\t--RC_CHK_ACCESS(maps)->nr_maps;\n\tup_write(maps__lock(maps));\n}\n\nstatic void __maps__purge(struct maps *maps)\n{\n\tstruct map_rb_node *pos, *next;\n\n\tif (maps__maps_by_name(maps))\n\t\t__maps__free_maps_by_name(maps);\n\n\tmaps__for_each_entry_safe(maps, pos, next) {\n\t\trb_erase_init(&pos->rb_node,  maps__entries(maps));\n\t\tmap__put(pos->map);\n\t\tfree(pos);\n\t}\n}\n\nstatic void maps__exit(struct maps *maps)\n{\n\tdown_write(maps__lock(maps));\n\t__maps__purge(maps);\n\tup_write(maps__lock(maps));\n}\n\nbool maps__empty(struct maps *maps)\n{\n\treturn !maps__first(maps);\n}\n\nstruct maps *maps__new(struct machine *machine)\n{\n\tstruct maps *result;\n\tRC_STRUCT(maps) *maps = zalloc(sizeof(*maps));\n\n\tif (ADD_RC_CHK(result, maps))\n\t\tmaps__init(result, machine);\n\n\treturn result;\n}\n\nstatic void maps__delete(struct maps *maps)\n{\n\tmaps__exit(maps);\n\tunwind__finish_access(maps);\n\tRC_CHK_FREE(maps);\n}\n\nstruct maps *maps__get(struct maps *maps)\n{\n\tstruct maps *result;\n\n\tif (RC_CHK_GET(result, maps))\n\t\trefcount_inc(maps__refcnt(maps));\n\n\treturn result;\n}\n\nvoid maps__put(struct maps *maps)\n{\n\tif (maps && refcount_dec_and_test(maps__refcnt(maps)))\n\t\tmaps__delete(maps);\n\telse\n\t\tRC_CHK_PUT(maps);\n}\n\nstruct symbol *maps__find_symbol(struct maps *maps, u64 addr, struct map **mapp)\n{\n\tstruct map *map = maps__find(maps, addr);\n\n\t \n\tif (map != NULL && map__load(map) >= 0) {\n\t\tif (mapp != NULL)\n\t\t\t*mapp = map;\n\t\treturn map__find_symbol(map, map__map_ip(map, addr));\n\t}\n\n\treturn NULL;\n}\n\nstruct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name, struct map **mapp)\n{\n\tstruct symbol *sym;\n\tstruct map_rb_node *pos;\n\n\tdown_read(maps__lock(maps));\n\n\tmaps__for_each_entry(maps, pos) {\n\t\tsym = map__find_symbol_by_name(pos->map, name);\n\n\t\tif (sym == NULL)\n\t\t\tcontinue;\n\t\tif (!map__contains_symbol(pos->map, sym)) {\n\t\t\tsym = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mapp != NULL)\n\t\t\t*mapp = pos->map;\n\t\tgoto out;\n\t}\n\n\tsym = NULL;\nout:\n\tup_read(maps__lock(maps));\n\treturn sym;\n}\n\nint maps__find_ams(struct maps *maps, struct addr_map_symbol *ams)\n{\n\tif (ams->addr < map__start(ams->ms.map) || ams->addr >= map__end(ams->ms.map)) {\n\t\tif (maps == NULL)\n\t\t\treturn -1;\n\t\tams->ms.map = maps__find(maps, ams->addr);\n\t\tif (ams->ms.map == NULL)\n\t\t\treturn -1;\n\t}\n\n\tams->al_addr = map__map_ip(ams->ms.map, ams->addr);\n\tams->ms.sym = map__find_symbol(ams->ms.map, ams->al_addr);\n\n\treturn ams->ms.sym ? 0 : -1;\n}\n\nsize_t maps__fprintf(struct maps *maps, FILE *fp)\n{\n\tsize_t printed = 0;\n\tstruct map_rb_node *pos;\n\n\tdown_read(maps__lock(maps));\n\n\tmaps__for_each_entry(maps, pos) {\n\t\tprinted += fprintf(fp, \"Map:\");\n\t\tprinted += map__fprintf(pos->map, fp);\n\t\tif (verbose > 2) {\n\t\t\tprinted += dso__fprintf(map__dso(pos->map), fp);\n\t\t\tprinted += fprintf(fp, \"--\\n\");\n\t\t}\n\t}\n\n\tup_read(maps__lock(maps));\n\n\treturn printed;\n}\n\nint maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp)\n{\n\tstruct rb_root *root;\n\tstruct rb_node *next, *first;\n\tint err = 0;\n\n\tdown_write(maps__lock(maps));\n\n\troot = maps__entries(maps);\n\n\t \n\tnext = root->rb_node;\n\tfirst = NULL;\n\twhile (next) {\n\t\tstruct map_rb_node *pos = rb_entry(next, struct map_rb_node, rb_node);\n\n\t\tif (map__end(pos->map) > map__start(map)) {\n\t\t\tfirst = next;\n\t\t\tif (map__start(pos->map) <= map__start(map))\n\t\t\t\tbreak;\n\t\t\tnext = next->rb_left;\n\t\t} else\n\t\t\tnext = next->rb_right;\n\t}\n\n\tnext = first;\n\twhile (next && !err) {\n\t\tstruct map_rb_node *pos = rb_entry(next, struct map_rb_node, rb_node);\n\t\tnext = rb_next(&pos->rb_node);\n\n\t\t \n\t\tif (map__start(pos->map) >= map__end(map))\n\t\t\tbreak;\n\n\t\tif (verbose >= 2) {\n\n\t\t\tif (use_browser) {\n\t\t\t\tpr_debug(\"overlapping maps in %s (disable tui for more info)\\n\",\n\t\t\t\t\t map__dso(map)->name);\n\t\t\t} else {\n\t\t\t\tfputs(\"overlapping maps:\\n\", fp);\n\t\t\t\tmap__fprintf(map, fp);\n\t\t\t\tmap__fprintf(pos->map, fp);\n\t\t\t}\n\t\t}\n\n\t\trb_erase_init(&pos->rb_node, root);\n\t\t \n\t\tif (map__start(map) > map__start(pos->map)) {\n\t\t\tstruct map *before = map__clone(pos->map);\n\n\t\t\tif (before == NULL) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto put_map;\n\t\t\t}\n\n\t\t\tmap__set_end(before, map__start(map));\n\t\t\terr = __maps__insert(maps, before);\n\t\t\tif (err) {\n\t\t\t\tmap__put(before);\n\t\t\t\tgoto put_map;\n\t\t\t}\n\n\t\t\tif (verbose >= 2 && !use_browser)\n\t\t\t\tmap__fprintf(before, fp);\n\t\t\tmap__put(before);\n\t\t}\n\n\t\tif (map__end(map) < map__end(pos->map)) {\n\t\t\tstruct map *after = map__clone(pos->map);\n\n\t\t\tif (after == NULL) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto put_map;\n\t\t\t}\n\n\t\t\tmap__set_start(after, map__end(map));\n\t\t\tmap__add_pgoff(after, map__end(map) - map__start(pos->map));\n\t\t\tassert(map__map_ip(pos->map, map__end(map)) ==\n\t\t\t\tmap__map_ip(after, map__end(map)));\n\t\t\terr = __maps__insert(maps, after);\n\t\t\tif (err) {\n\t\t\t\tmap__put(after);\n\t\t\t\tgoto put_map;\n\t\t\t}\n\t\t\tif (verbose >= 2 && !use_browser)\n\t\t\t\tmap__fprintf(after, fp);\n\t\t\tmap__put(after);\n\t\t}\nput_map:\n\t\tmap__put(pos->map);\n\t\tfree(pos);\n\t}\n\tup_write(maps__lock(maps));\n\treturn err;\n}\n\n \nint maps__clone(struct thread *thread, struct maps *parent)\n{\n\tstruct maps *maps = thread__maps(thread);\n\tint err;\n\tstruct map_rb_node *rb_node;\n\n\tdown_read(maps__lock(parent));\n\n\tmaps__for_each_entry(parent, rb_node) {\n\t\tstruct map *new = map__clone(rb_node->map);\n\n\t\tif (new == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terr = unwind__prepare_access(maps, new, NULL);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\terr = maps__insert(maps, new);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\tmap__put(new);\n\t}\n\n\terr = 0;\nout_unlock:\n\tup_read(maps__lock(parent));\n\treturn err;\n}\n\nstruct map_rb_node *maps__find_node(struct maps *maps, struct map *map)\n{\n\tstruct map_rb_node *rb_node;\n\n\tmaps__for_each_entry(maps, rb_node) {\n\t\tif (rb_node->RC_CHK_ACCESS(map) == RC_CHK_ACCESS(map))\n\t\t\treturn rb_node;\n\t}\n\treturn NULL;\n}\n\nstruct map *maps__find(struct maps *maps, u64 ip)\n{\n\tstruct rb_node *p;\n\tstruct map_rb_node *m;\n\n\n\tdown_read(maps__lock(maps));\n\n\tp = maps__entries(maps)->rb_node;\n\twhile (p != NULL) {\n\t\tm = rb_entry(p, struct map_rb_node, rb_node);\n\t\tif (ip < map__start(m->map))\n\t\t\tp = p->rb_left;\n\t\telse if (ip >= map__end(m->map))\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tm = NULL;\nout:\n\tup_read(maps__lock(maps));\n\treturn m ? m->map : NULL;\n}\n\nstruct map_rb_node *maps__first(struct maps *maps)\n{\n\tstruct rb_node *first = rb_first(maps__entries(maps));\n\n\tif (first)\n\t\treturn rb_entry(first, struct map_rb_node, rb_node);\n\treturn NULL;\n}\n\nstruct map_rb_node *map_rb_node__next(struct map_rb_node *node)\n{\n\tstruct rb_node *next;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tnext = rb_next(&node->rb_node);\n\n\tif (!next)\n\t\treturn NULL;\n\n\treturn rb_entry(next, struct map_rb_node, rb_node);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}