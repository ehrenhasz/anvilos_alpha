{
  "module_name": "genelf_debug.c",
  "hash_id": "738c8065b09f5e3f865b7295e8d4adb84c4553fca542b791220213ce087e1b8d",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/genelf_debug.c",
  "human_readable_source": "\n \n#include <linux/compiler.h>\n#include <linux/zalloc.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <stddef.h>\n#include <libelf.h>\n#include <string.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <err.h>\n#include <dwarf.h>\n\n#include \"genelf.h\"\n#include \"../util/jitdump.h\"\n\n#define BUFFER_EXT_DFL_SIZE\t(4 * 1024)\n\ntypedef uint32_t uword;\ntypedef uint16_t uhalf;\ntypedef int32_t  sword;\ntypedef int16_t  shalf;\ntypedef uint8_t  ubyte;\ntypedef int8_t   sbyte;\n\nstruct buffer_ext {\n\tsize_t cur_pos;\n\tsize_t max_sz;\n\tvoid *data;\n};\n\nstatic void\nbuffer_ext_dump(struct buffer_ext *be, const char *msg)\n{\n\tsize_t i;\n\twarnx(\"DUMP for %s\", msg);\n\tfor (i = 0 ; i < be->cur_pos; i++)\n\t\twarnx(\"%4zu 0x%02x\", i, (((char *)be->data)[i]) & 0xff);\n}\n\nstatic inline int\nbuffer_ext_add(struct buffer_ext *be, void *addr, size_t sz)\n{\n\tvoid *tmp;\n\tsize_t be_sz = be->max_sz;\n\nretry:\n\tif ((be->cur_pos + sz) < be_sz) {\n\t\tmemcpy(be->data + be->cur_pos, addr, sz);\n\t\tbe->cur_pos += sz;\n\t\treturn 0;\n\t}\n\n\tif (!be_sz)\n\t\tbe_sz = BUFFER_EXT_DFL_SIZE;\n\telse\n\t\tbe_sz <<= 1;\n\n\ttmp = realloc(be->data, be_sz);\n\tif (!tmp)\n\t\treturn -1;\n\n\tbe->data   = tmp;\n\tbe->max_sz = be_sz;\n\n\tgoto retry;\n}\n\nstatic void\nbuffer_ext_init(struct buffer_ext *be)\n{\n\tbe->data = NULL;\n\tbe->cur_pos = 0;\n\tbe->max_sz = 0;\n}\n\nstatic void\nbuffer_ext_exit(struct buffer_ext *be)\n{\n\tzfree(&be->data);\n}\n\nstatic inline size_t\nbuffer_ext_size(struct buffer_ext *be)\n{\n\treturn be->cur_pos;\n}\n\nstatic inline void *\nbuffer_ext_addr(struct buffer_ext *be)\n{\n\treturn be->data;\n}\n\nstruct debug_line_header {\n\t\n\tuword total_length;\n\t\n\tuhalf version;\n\t\n\t\n\tuword prolog_length;\n\tubyte minimum_instruction_length;\n\tubyte default_is_stmt;\n\t\n\tsbyte line_base;\n\t\n\tubyte line_range;\n\t\n\tubyte opcode_base;\n\t \n\t \n\t \n\t \n} __packed;\n\n \nstruct compilation_unit_header {\n\tuword total_length;\n\tuhalf version;\n\tuword debug_abbrev_offset;\n\tubyte pointer_size;\n} __packed;\n\n#define DW_LNS_num_opcode (DW_LNS_set_isa + 1)\n\n \nstatic struct debug_line_header const default_debug_line_header = {\n\t.total_length = -1,\n\t.version = 2,\n\t.prolog_length = -1,\n\t.minimum_instruction_length = 1,\t \n\t.default_is_stmt = 1,\t \n\t.line_base = -5,\t \n\t.line_range = -14,      \n\t.opcode_base = DW_LNS_num_opcode\n};\n\nstatic ubyte standard_opcode_length[] =\n{\n\t0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1\n};\n#if 0\n{\n\t[DW_LNS_advance_pc]   = 1,\n\t[DW_LNS_advance_line] = 1,\n\t[DW_LNS_set_file] =  1,\n\t[DW_LNS_set_column] = 1,\n\t[DW_LNS_fixed_advance_pc] = 1,\n\t[DW_LNS_set_isa] = 1,\n};\n#endif\n\n \nstatic struct compilation_unit_header default_comp_unit_header = {\n\t.total_length = -1,\n\t.version = 2,\n\t.debug_abbrev_offset = 0,      \n\t.pointer_size = sizeof(void *)\n};\n\nstatic void emit_uword(struct buffer_ext *be, uword data)\n{\n\tbuffer_ext_add(be, &data, sizeof(uword));\n}\n\nstatic void emit_string(struct buffer_ext *be, const char *s)\n{\n\tbuffer_ext_add(be, (void *)s, strlen(s) + 1);\n}\n\nstatic void emit_unsigned_LEB128(struct buffer_ext *be,\n\t\t\t\t unsigned long data)\n{\n\tdo {\n\t\tubyte cur = data & 0x7F;\n\t\tdata >>= 7;\n\t\tif (data)\n\t\t\tcur |= 0x80;\n\t\tbuffer_ext_add(be, &cur, 1);\n\t} while (data);\n}\n\nstatic void emit_signed_LEB128(struct buffer_ext *be, long data)\n{\n\tint more = 1;\n\tint negative = data < 0;\n\tint size = sizeof(long) * CHAR_BIT;\n\twhile (more) {\n\t\tubyte cur = data & 0x7F;\n\t\tdata >>= 7;\n\t\tif (negative)\n\t\t\tdata |= - (1 << (size - 7));\n\t\tif ((data == 0 && !(cur & 0x40)) ||\n\t\t    (data == -1l && (cur & 0x40)))\n\t\t\tmore = 0;\n\t\telse\n\t\t\tcur |= 0x80;\n\t\tbuffer_ext_add(be, &cur, 1);\n\t}\n}\n\nstatic void emit_extended_opcode(struct buffer_ext *be, ubyte opcode,\n\t\t\t\t void *data, size_t data_len)\n{\n\tbuffer_ext_add(be, (char *)\"\", 1);\n\n\temit_unsigned_LEB128(be, data_len + 1);\n\n\tbuffer_ext_add(be, &opcode, 1);\n\tbuffer_ext_add(be, data, data_len);\n}\n\nstatic void emit_opcode(struct buffer_ext *be, ubyte opcode)\n{\n\tbuffer_ext_add(be, &opcode, 1);\n}\n\nstatic void emit_opcode_signed(struct buffer_ext  *be,\n\t\t\t       ubyte opcode, long data)\n{\n\tbuffer_ext_add(be, &opcode, 1);\n\temit_signed_LEB128(be, data);\n}\n\nstatic void emit_opcode_unsigned(struct buffer_ext *be, ubyte opcode,\n\t\t\t\t unsigned long data)\n{\n\tbuffer_ext_add(be, &opcode, 1);\n\temit_unsigned_LEB128(be, data);\n}\n\nstatic void emit_advance_pc(struct buffer_ext *be, unsigned long delta_pc)\n{\n\temit_opcode_unsigned(be, DW_LNS_advance_pc, delta_pc);\n}\n\nstatic void emit_advance_lineno(struct buffer_ext  *be, long delta_lineno)\n{\n\temit_opcode_signed(be, DW_LNS_advance_line, delta_lineno);\n}\n\nstatic void emit_lne_end_of_sequence(struct buffer_ext *be)\n{\n\temit_extended_opcode(be, DW_LNE_end_sequence, NULL, 0);\n}\n\nstatic void emit_set_file(struct buffer_ext *be, unsigned long idx)\n{\n\temit_opcode_unsigned(be, DW_LNS_set_file, idx);\n}\n\nstatic void emit_lne_define_filename(struct buffer_ext *be,\n\t\t\t\t     const char *filename)\n{\n\tbuffer_ext_add(be, (void *)\"\", 1);\n\n\t \n\temit_unsigned_LEB128(be, strlen(filename) + 5);\n\temit_opcode(be, DW_LNE_define_file);\n\temit_string(be, filename);\n\t \n        emit_unsigned_LEB128(be, 0);\n\t \n        emit_unsigned_LEB128(be, 0);\n\t \n        emit_unsigned_LEB128(be, 0);\n}\n\nstatic void emit_lne_set_address(struct buffer_ext *be,\n\t\t\t\t void *address)\n{\n\temit_extended_opcode(be, DW_LNE_set_address, &address, sizeof(unsigned long));\n}\n\nstatic ubyte get_special_opcode(struct debug_entry *ent,\n\t\t\t\tunsigned int last_line,\n\t\t\t\tunsigned long last_vma)\n{\n\tunsigned int temp;\n\tunsigned long delta_addr;\n\n\t \n\ttemp = (ent->lineno - last_line) - default_debug_line_header.line_base;\n\n\tif (temp >= default_debug_line_header.line_range)\n\t\treturn 0;\n\n\t \n\tdelta_addr = (ent->addr - last_vma) / default_debug_line_header.minimum_instruction_length;\n\n\t \n\n\tif (delta_addr <= 256 / default_debug_line_header.line_range) {\n\t\tunsigned long opcode = temp +\n\t\t\t(delta_addr * default_debug_line_header.line_range) +\n\t\t\tdefault_debug_line_header.opcode_base;\n\n\t\treturn opcode <= 255 ? opcode : 0;\n\t}\n\treturn 0;\n}\n\nstatic void emit_lineno_info(struct buffer_ext *be,\n\t\t\t     struct debug_entry *ent, size_t nr_entry,\n\t\t\t     unsigned long code_addr)\n{\n\tsize_t i;\n\n\t \n\tconst char repeated_name_marker[] = {'\\xff', '\\0'};\n\n\t \n\n\t \n\tunsigned long last_vma = 0;\n\tchar const  *cur_filename = NULL;\n\tunsigned long cur_file_idx = 0;\n\tint last_line = 1;\n\n\temit_lne_set_address(be, (void *)code_addr);\n\n\tfor (i = 0; i < nr_entry; i++, ent = debug_entry_next(ent)) {\n\t\tint need_copy = 0;\n\t\tubyte special_opcode;\n\n\t\t \n\t\tif ((!cur_filename || strcmp(cur_filename, ent->name)) &&\n\t\t\tstrcmp(repeated_name_marker, ent->name)) {\n\t\t\temit_lne_define_filename(be, ent->name);\n\t\t\tcur_filename = ent->name;\n\t\t\temit_set_file(be, ++cur_file_idx);\n\t\t\tneed_copy = 1;\n\t\t}\n\n\t\tspecial_opcode = get_special_opcode(ent, last_line, last_vma);\n\t\tif (special_opcode != 0) {\n\t\t\tlast_line = ent->lineno;\n\t\t\tlast_vma  = ent->addr;\n\t\t\temit_opcode(be, special_opcode);\n\t\t} else {\n\t\t\t \n\t\t\tif (last_line != ent->lineno) {\n\t\t\t\temit_advance_lineno(be, ent->lineno - last_line);\n\t\t\t\tlast_line = ent->lineno;\n\t\t\t\tneed_copy = 1;\n\t\t\t}\n\t\t\t \n\t\t\tif (last_vma != ent->addr) {\n\t\t\t\temit_advance_pc(be, ent->addr - last_vma);\n\t\t\t\tlast_vma = ent->addr;\n\t\t\t\tneed_copy = 1;\n\t\t\t}\n\t\t\t \n\t\t\tif (need_copy)\n\t\t\t\temit_opcode(be, DW_LNS_copy);\n\t\t}\n\t}\n}\n\nstatic void add_debug_line(struct buffer_ext *be,\n\tstruct debug_entry *ent, size_t nr_entry,\n\tunsigned long code_addr)\n{\n\tstruct debug_line_header * dbg_header;\n\tsize_t old_size;\n\n\told_size = buffer_ext_size(be);\n\n\tbuffer_ext_add(be, (void *)&default_debug_line_header,\n\t\t sizeof(default_debug_line_header));\n\n\tbuffer_ext_add(be, &standard_opcode_length,  sizeof(standard_opcode_length));\n\n\t\n\tbuffer_ext_add(be, (void *)\"\", 1);\n\n\t\n\tbuffer_ext_add(be, (void *)\"\", 1);\n\n\tdbg_header = buffer_ext_addr(be) + old_size;\n\tdbg_header->prolog_length = (buffer_ext_size(be) - old_size) -\n\t\toffsetof(struct debug_line_header, minimum_instruction_length);\n\n\temit_lineno_info(be, ent, nr_entry, code_addr);\n\n\temit_lne_end_of_sequence(be);\n\n\tdbg_header = buffer_ext_addr(be) + old_size;\n\tdbg_header->total_length = (buffer_ext_size(be) - old_size) -\n\t\toffsetof(struct debug_line_header, version);\n}\n\nstatic void\nadd_debug_abbrev(struct buffer_ext *be)\n{\n        emit_unsigned_LEB128(be, 1);\n        emit_unsigned_LEB128(be, DW_TAG_compile_unit);\n        emit_unsigned_LEB128(be, DW_CHILDREN_yes);\n        emit_unsigned_LEB128(be, DW_AT_stmt_list);\n        emit_unsigned_LEB128(be, DW_FORM_data4);\n        emit_unsigned_LEB128(be, 0);\n        emit_unsigned_LEB128(be, 0);\n        emit_unsigned_LEB128(be, 0);\n}\n\nstatic void\nadd_compilation_unit(struct buffer_ext *be,\n\t\t     size_t offset_debug_line)\n{\n\tstruct compilation_unit_header *comp_unit_header;\n\tsize_t old_size = buffer_ext_size(be);\n\n\tbuffer_ext_add(be, &default_comp_unit_header,\n\t\t       sizeof(default_comp_unit_header));\n\n\temit_unsigned_LEB128(be, 1);\n\temit_uword(be, offset_debug_line);\n\n\tcomp_unit_header = buffer_ext_addr(be) + old_size;\n\tcomp_unit_header->total_length = (buffer_ext_size(be) - old_size) -\n\t\toffsetof(struct compilation_unit_header, version);\n}\n\nstatic int\njit_process_debug_info(uint64_t code_addr,\n\t\t       void *debug, int nr_debug_entries,\n\t\t       struct buffer_ext *dl,\n\t\t       struct buffer_ext *da,\n\t\t       struct buffer_ext *di)\n{\n\tstruct debug_entry *ent = debug;\n\tint i;\n\n\tfor (i = 0; i < nr_debug_entries; i++) {\n\t\tent->addr = ent->addr - code_addr;\n\t\tent = debug_entry_next(ent);\n\t}\n\tadd_compilation_unit(di, buffer_ext_size(dl));\n\tadd_debug_line(dl, debug, nr_debug_entries, GEN_ELF_TEXT_OFFSET);\n\tadd_debug_abbrev(da);\n\tif (0) buffer_ext_dump(da, \"abbrev\");\n\n\treturn 0;\n}\n\nint\njit_add_debug_info(Elf *e, uint64_t code_addr, void *debug, int nr_debug_entries)\n{\n\tElf_Data *d;\n\tElf_Scn *scn;\n\tElf_Shdr *shdr;\n\tstruct buffer_ext dl, di, da;\n\tint ret = -1;\n\n\tbuffer_ext_init(&dl);\n\tbuffer_ext_init(&di);\n\tbuffer_ext_init(&da);\n\n\tif (jit_process_debug_info(code_addr, debug, nr_debug_entries, &dl, &da, &di))\n\t\tgoto out;\n\n\t \n\tscn = elf_newscn(e);\n\tif (!scn) {\n\t\twarnx(\"cannot create section\");\n\t\tgoto out;\n\t}\n\n\td = elf_newdata(scn);\n\tif (!d) {\n\t\twarnx(\"cannot get new data\");\n\t\tgoto out;\n\t}\n\n\td->d_align = 1;\n\td->d_off = 0LL;\n\td->d_buf = buffer_ext_addr(&dl);\n\td->d_type = ELF_T_BYTE;\n\td->d_size = buffer_ext_size(&dl);\n\td->d_version = EV_CURRENT;\n\n\tshdr = elf_getshdr(scn);\n\tif (!shdr) {\n\t\twarnx(\"cannot get section header\");\n\t\tgoto out;\n\t}\n\n\tshdr->sh_name = 52;  \n\tshdr->sh_type = SHT_PROGBITS;\n\tshdr->sh_addr = 0;  \n\tshdr->sh_flags = 0;\n\tshdr->sh_entsize = 0;\n\n\t \n\tscn = elf_newscn(e);\n\tif (!scn) {\n\t\twarnx(\"cannot create section\");\n\t\tgoto out;\n\t}\n\n\td = elf_newdata(scn);\n\tif (!d) {\n\t\twarnx(\"cannot get new data\");\n\t\tgoto out;\n\t}\n\n\td->d_align = 1;\n\td->d_off = 0LL;\n\td->d_buf = buffer_ext_addr(&di);\n\td->d_type = ELF_T_BYTE;\n\td->d_size = buffer_ext_size(&di);\n\td->d_version = EV_CURRENT;\n\n\tshdr = elf_getshdr(scn);\n\tif (!shdr) {\n\t\twarnx(\"cannot get section header\");\n\t\tgoto out;\n\t}\n\n\tshdr->sh_name = 64;  \n\tshdr->sh_type = SHT_PROGBITS;\n\tshdr->sh_addr = 0;  \n\tshdr->sh_flags = 0;\n\tshdr->sh_entsize = 0;\n\n\t \n\tscn = elf_newscn(e);\n\tif (!scn) {\n\t\twarnx(\"cannot create section\");\n\t\tgoto out;\n\t}\n\n\td = elf_newdata(scn);\n\tif (!d) {\n\t\twarnx(\"cannot get new data\");\n\t\tgoto out;\n\t}\n\n\td->d_align = 1;\n\td->d_off = 0LL;\n\td->d_buf = buffer_ext_addr(&da);\n\td->d_type = ELF_T_BYTE;\n\td->d_size = buffer_ext_size(&da);\n\td->d_version = EV_CURRENT;\n\n\tshdr = elf_getshdr(scn);\n\tif (!shdr) {\n\t\twarnx(\"cannot get section header\");\n\t\tgoto out;\n\t}\n\n\tshdr->sh_name = 76;  \n\tshdr->sh_type = SHT_PROGBITS;\n\tshdr->sh_addr = 0;  \n\tshdr->sh_flags = 0;\n\tshdr->sh_entsize = 0;\n\n\t \n\tif (elf_update(e, ELF_C_WRITE) < 0)\n\t\twarnx(\"elf_update debug failed\");\n\telse\n\t\tret = 0;\n\nout:\n\tbuffer_ext_exit(&dl);\n\tbuffer_ext_exit(&di);\n\tbuffer_ext_exit(&da);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}