{
  "module_name": "symbol-elf.c",
  "hash_id": "308273d9509736ad74857750a32b5a89f9f13cc54ca10779acaee07b13311265",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/symbol-elf.c",
  "human_readable_source": "\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <inttypes.h>\n\n#include \"dso.h\"\n#include \"map.h\"\n#include \"maps.h\"\n#include \"symbol.h\"\n#include \"symsrc.h\"\n#include \"demangle-cxx.h\"\n#include \"demangle-ocaml.h\"\n#include \"demangle-java.h\"\n#include \"demangle-rust.h\"\n#include \"machine.h\"\n#include \"vdso.h\"\n#include \"debug.h\"\n#include \"util/copyfile.h\"\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <linux/zalloc.h>\n#include <symbol/kallsyms.h>\n#include <internal/lib.h>\n\n#ifdef HAVE_LIBBFD_SUPPORT\n#define PACKAGE 'perf'\n#include <bfd.h>\n#endif\n\n#if defined(HAVE_LIBBFD_SUPPORT) || defined(HAVE_CPLUS_DEMANGLE_SUPPORT)\n#ifndef DMGL_PARAMS\n#define DMGL_PARAMS     (1 << 0)   \n#define DMGL_ANSI       (1 << 1)   \n#endif\n#endif\n\n#ifndef EM_AARCH64\n#define EM_AARCH64\t183   \n#endif\n\n#ifndef EM_LOONGARCH\n#define EM_LOONGARCH\t258\n#endif\n\n#ifndef ELF32_ST_VISIBILITY\n#define ELF32_ST_VISIBILITY(o)\t((o) & 0x03)\n#endif\n\n \n#ifndef ELF64_ST_VISIBILITY\n#define ELF64_ST_VISIBILITY(o)\tELF32_ST_VISIBILITY (o)\n#endif\n\n \n#ifndef GELF_ST_VISIBILITY\n#define GELF_ST_VISIBILITY(val)\tELF64_ST_VISIBILITY (val)\n#endif\n\ntypedef Elf64_Nhdr GElf_Nhdr;\n\n\n#ifndef HAVE_ELF_GETPHDRNUM_SUPPORT\nstatic int elf_getphdrnum(Elf *elf, size_t *dst)\n{\n\tGElf_Ehdr gehdr;\n\tGElf_Ehdr *ehdr;\n\n\tehdr = gelf_getehdr(elf, &gehdr);\n\tif (!ehdr)\n\t\treturn -1;\n\n\t*dst = ehdr->e_phnum;\n\n\treturn 0;\n}\n#endif\n\n#ifndef HAVE_ELF_GETSHDRSTRNDX_SUPPORT\nstatic int elf_getshdrstrndx(Elf *elf __maybe_unused, size_t *dst __maybe_unused)\n{\n\tpr_err(\"%s: update your libelf to > 0.140, this one lacks elf_getshdrstrndx().\\n\", __func__);\n\treturn -1;\n}\n#endif\n\n#ifndef NT_GNU_BUILD_ID\n#define NT_GNU_BUILD_ID 3\n#endif\n\n \n#define elf_symtab__for_each_symbol(syms, nr_syms, idx, sym) \\\n\tfor (idx = 0, gelf_getsym(syms, idx, &sym);\\\n\t     idx < nr_syms; \\\n\t     idx++, gelf_getsym(syms, idx, &sym))\n\nstatic inline uint8_t elf_sym__type(const GElf_Sym *sym)\n{\n\treturn GELF_ST_TYPE(sym->st_info);\n}\n\nstatic inline uint8_t elf_sym__visibility(const GElf_Sym *sym)\n{\n\treturn GELF_ST_VISIBILITY(sym->st_other);\n}\n\n#ifndef STT_GNU_IFUNC\n#define STT_GNU_IFUNC 10\n#endif\n\nstatic inline int elf_sym__is_function(const GElf_Sym *sym)\n{\n\treturn (elf_sym__type(sym) == STT_FUNC ||\n\t\telf_sym__type(sym) == STT_GNU_IFUNC) &&\n\t       sym->st_name != 0 &&\n\t       sym->st_shndx != SHN_UNDEF;\n}\n\nstatic inline bool elf_sym__is_object(const GElf_Sym *sym)\n{\n\treturn elf_sym__type(sym) == STT_OBJECT &&\n\t\tsym->st_name != 0 &&\n\t\tsym->st_shndx != SHN_UNDEF;\n}\n\nstatic inline int elf_sym__is_label(const GElf_Sym *sym)\n{\n\treturn elf_sym__type(sym) == STT_NOTYPE &&\n\t\tsym->st_name != 0 &&\n\t\tsym->st_shndx != SHN_UNDEF &&\n\t\tsym->st_shndx != SHN_ABS &&\n\t\telf_sym__visibility(sym) != STV_HIDDEN &&\n\t\telf_sym__visibility(sym) != STV_INTERNAL;\n}\n\nstatic bool elf_sym__filter(GElf_Sym *sym)\n{\n\treturn elf_sym__is_function(sym) || elf_sym__is_object(sym);\n}\n\nstatic inline const char *elf_sym__name(const GElf_Sym *sym,\n\t\t\t\t\tconst Elf_Data *symstrs)\n{\n\treturn symstrs->d_buf + sym->st_name;\n}\n\nstatic inline const char *elf_sec__name(const GElf_Shdr *shdr,\n\t\t\t\t\tconst Elf_Data *secstrs)\n{\n\treturn secstrs->d_buf + shdr->sh_name;\n}\n\nstatic inline int elf_sec__is_text(const GElf_Shdr *shdr,\n\t\t\t\t\tconst Elf_Data *secstrs)\n{\n\treturn strstr(elf_sec__name(shdr, secstrs), \"text\") != NULL;\n}\n\nstatic inline bool elf_sec__is_data(const GElf_Shdr *shdr,\n\t\t\t\t    const Elf_Data *secstrs)\n{\n\treturn strstr(elf_sec__name(shdr, secstrs), \"data\") != NULL;\n}\n\nstatic bool elf_sec__filter(GElf_Shdr *shdr, Elf_Data *secstrs)\n{\n\treturn elf_sec__is_text(shdr, secstrs) || \n\t       elf_sec__is_data(shdr, secstrs);\n}\n\nstatic size_t elf_addr_to_index(Elf *elf, GElf_Addr addr)\n{\n\tElf_Scn *sec = NULL;\n\tGElf_Shdr shdr;\n\tsize_t cnt = 1;\n\n\twhile ((sec = elf_nextscn(elf, sec)) != NULL) {\n\t\tgelf_getshdr(sec, &shdr);\n\n\t\tif ((addr >= shdr.sh_addr) &&\n\t\t    (addr < (shdr.sh_addr + shdr.sh_size)))\n\t\t\treturn cnt;\n\n\t\t++cnt;\n\t}\n\n\treturn -1;\n}\n\nElf_Scn *elf_section_by_name(Elf *elf, GElf_Ehdr *ep,\n\t\t\t     GElf_Shdr *shp, const char *name, size_t *idx)\n{\n\tElf_Scn *sec = NULL;\n\tsize_t cnt = 1;\n\n\t \n\tif (!elf_rawdata(elf_getscn(elf, ep->e_shstrndx), NULL))\n\t\treturn NULL;\n\n\twhile ((sec = elf_nextscn(elf, sec)) != NULL) {\n\t\tchar *str;\n\n\t\tgelf_getshdr(sec, shp);\n\t\tstr = elf_strptr(elf, ep->e_shstrndx, shp->sh_name);\n\t\tif (str && !strcmp(name, str)) {\n\t\t\tif (idx)\n\t\t\t\t*idx = cnt;\n\t\t\treturn sec;\n\t\t}\n\t\t++cnt;\n\t}\n\n\treturn NULL;\n}\n\nbool filename__has_section(const char *filename, const char *sec)\n{\n\tint fd;\n\tElf *elf;\n\tGElf_Ehdr ehdr;\n\tGElf_Shdr shdr;\n\tbool found = false;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\treturn false;\n\n\telf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tif (elf == NULL)\n\t\tgoto out;\n\n\tif (gelf_getehdr(elf, &ehdr) == NULL)\n\t\tgoto elf_out;\n\n\tfound = !!elf_section_by_name(elf, &ehdr, &shdr, sec, NULL);\n\nelf_out:\n\telf_end(elf);\nout:\n\tclose(fd);\n\treturn found;\n}\n\nstatic int elf_read_program_header(Elf *elf, u64 vaddr, GElf_Phdr *phdr)\n{\n\tsize_t i, phdrnum;\n\tu64 sz;\n\n\tif (elf_getphdrnum(elf, &phdrnum))\n\t\treturn -1;\n\n\tfor (i = 0; i < phdrnum; i++) {\n\t\tif (gelf_getphdr(elf, i, phdr) == NULL)\n\t\t\treturn -1;\n\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tsz = max(phdr->p_memsz, phdr->p_filesz);\n\t\tif (!sz)\n\t\t\tcontinue;\n\n\t\tif (vaddr >= phdr->p_vaddr && (vaddr < phdr->p_vaddr + sz))\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn -1;\n}\n\nstatic bool want_demangle(bool is_kernel_sym)\n{\n\treturn is_kernel_sym ? symbol_conf.demangle_kernel : symbol_conf.demangle;\n}\n\n \n__weak char *cxx_demangle_sym(const char *str __maybe_unused, bool params __maybe_unused,\n\t\t\t      bool modifiers __maybe_unused)\n{\n#ifdef HAVE_LIBBFD_SUPPORT\n\tint flags = (params ? DMGL_PARAMS : 0) | (modifiers ? DMGL_ANSI : 0);\n\n\treturn bfd_demangle(NULL, str, flags);\n#elif defined(HAVE_CPLUS_DEMANGLE_SUPPORT)\n\tint flags = (params ? DMGL_PARAMS : 0) | (modifiers ? DMGL_ANSI : 0);\n\n\treturn cplus_demangle(str, flags);\n#else\n\treturn NULL;\n#endif\n}\n\nstatic char *demangle_sym(struct dso *dso, int kmodule, const char *elf_name)\n{\n\tchar *demangled = NULL;\n\n\t \n\tif (!want_demangle(dso->kernel || kmodule))\n\t    return demangled;\n\n\tdemangled = cxx_demangle_sym(elf_name, verbose > 0, verbose > 0);\n\tif (demangled == NULL) {\n\t\tdemangled = ocaml_demangle_sym(elf_name);\n\t\tif (demangled == NULL) {\n\t\t\tdemangled = java_demangle_sym(elf_name, JAVA_DEMANGLE_NORET);\n\t\t}\n\t}\n\telse if (rust_is_mangled(demangled))\n\t\t \n\t\trust_demangle_sym(demangled);\n\n\treturn demangled;\n}\n\nstruct rel_info {\n\tu32\t\tnr_entries;\n\tu32\t\t*sorted;\n\tbool\t\tis_rela;\n\tElf_Data\t*reldata;\n\tGElf_Rela\trela;\n\tGElf_Rel\trel;\n};\n\nstatic u32 get_rel_symidx(struct rel_info *ri, u32 idx)\n{\n\tidx = ri->sorted ? ri->sorted[idx] : idx;\n\tif (ri->is_rela) {\n\t\tgelf_getrela(ri->reldata, idx, &ri->rela);\n\t\treturn GELF_R_SYM(ri->rela.r_info);\n\t}\n\tgelf_getrel(ri->reldata, idx, &ri->rel);\n\treturn GELF_R_SYM(ri->rel.r_info);\n}\n\nstatic u64 get_rel_offset(struct rel_info *ri, u32 x)\n{\n\tif (ri->is_rela) {\n\t\tGElf_Rela rela;\n\n\t\tgelf_getrela(ri->reldata, x, &rela);\n\t\treturn rela.r_offset;\n\t} else {\n\t\tGElf_Rel rel;\n\n\t\tgelf_getrel(ri->reldata, x, &rel);\n\t\treturn rel.r_offset;\n\t}\n}\n\nstatic int rel_cmp(const void *a, const void *b, void *r)\n{\n\tstruct rel_info *ri = r;\n\tu64 a_offset = get_rel_offset(ri, *(const u32 *)a);\n\tu64 b_offset = get_rel_offset(ri, *(const u32 *)b);\n\n\treturn a_offset < b_offset ? -1 : (a_offset > b_offset ? 1 : 0);\n}\n\nstatic int sort_rel(struct rel_info *ri)\n{\n\tsize_t sz = sizeof(ri->sorted[0]);\n\tu32 i;\n\n\tri->sorted = calloc(ri->nr_entries, sz);\n\tif (!ri->sorted)\n\t\treturn -1;\n\tfor (i = 0; i < ri->nr_entries; i++)\n\t\tri->sorted[i] = i;\n\tqsort_r(ri->sorted, ri->nr_entries, sz, rel_cmp, ri);\n\treturn 0;\n}\n\n \nstatic bool addend_may_be_ifunc(GElf_Ehdr *ehdr, struct rel_info *ri)\n{\n\treturn ehdr->e_machine == EM_X86_64 && ri->is_rela &&\n\t       GELF_R_TYPE(ri->rela.r_info) == R_X86_64_IRELATIVE;\n}\n\nstatic bool get_ifunc_name(Elf *elf, struct dso *dso, GElf_Ehdr *ehdr,\n\t\t\t   struct rel_info *ri, char *buf, size_t buf_sz)\n{\n\tu64 addr = ri->rela.r_addend;\n\tstruct symbol *sym;\n\tGElf_Phdr phdr;\n\n\tif (!addend_may_be_ifunc(ehdr, ri))\n\t\treturn false;\n\n\tif (elf_read_program_header(elf, addr, &phdr))\n\t\treturn false;\n\n\taddr -= phdr.p_vaddr - phdr.p_offset;\n\n\tsym = dso__find_symbol_nocache(dso, addr);\n\n\t \n\tif (!sym || sym->start != addr || (sym->type != STT_GNU_IFUNC && !sym->ifunc_alias))\n\t\treturn false;\n\n\tsnprintf(buf, buf_sz, \"%s@plt\", sym->name);\n\n\treturn true;\n}\n\nstatic void exit_rel(struct rel_info *ri)\n{\n\tzfree(&ri->sorted);\n}\n\nstatic bool get_plt_sizes(struct dso *dso, GElf_Ehdr *ehdr, GElf_Shdr *shdr_plt,\n\t\t\t  u64 *plt_header_size, u64 *plt_entry_size)\n{\n\tswitch (ehdr->e_machine) {\n\tcase EM_ARM:\n\t\t*plt_header_size = 20;\n\t\t*plt_entry_size = 12;\n\t\treturn true;\n\tcase EM_AARCH64:\n\t\t*plt_header_size = 32;\n\t\t*plt_entry_size = 16;\n\t\treturn true;\n\tcase EM_LOONGARCH:\n\t\t*plt_header_size = 32;\n\t\t*plt_entry_size = 16;\n\t\treturn true;\n\tcase EM_SPARC:\n\t\t*plt_header_size = 48;\n\t\t*plt_entry_size = 12;\n\t\treturn true;\n\tcase EM_SPARCV9:\n\t\t*plt_header_size = 128;\n\t\t*plt_entry_size = 32;\n\t\treturn true;\n\tcase EM_386:\n\tcase EM_X86_64:\n\t\t*plt_entry_size = shdr_plt->sh_entsize;\n\t\t \n\t\tif (*plt_entry_size != 8 && *plt_entry_size != 16)\n\t\t\t*plt_entry_size = shdr_plt->sh_addralign == 8 ? 8 : 16;\n\t\t*plt_header_size = *plt_entry_size;\n\t\tbreak;\n\tdefault:  \n\t\t*plt_header_size = shdr_plt->sh_entsize;\n\t\t*plt_entry_size = shdr_plt->sh_entsize;\n\t\tbreak;\n\t}\n\tif (*plt_entry_size)\n\t\treturn true;\n\tpr_debug(\"Missing PLT entry size for %s\\n\", dso->long_name);\n\treturn false;\n}\n\nstatic bool machine_is_x86(GElf_Half e_machine)\n{\n\treturn e_machine == EM_386 || e_machine == EM_X86_64;\n}\n\nstruct rela_dyn {\n\tGElf_Addr\toffset;\n\tu32\t\tsym_idx;\n};\n\nstruct rela_dyn_info {\n\tstruct dso\t*dso;\n\tElf_Data\t*plt_got_data;\n\tu32\t\tnr_entries;\n\tstruct rela_dyn\t*sorted;\n\tElf_Data\t*dynsym_data;\n\tElf_Data\t*dynstr_data;\n\tElf_Data\t*rela_dyn_data;\n};\n\nstatic void exit_rela_dyn(struct rela_dyn_info *di)\n{\n\tzfree(&di->sorted);\n}\n\nstatic int cmp_offset(const void *a, const void *b)\n{\n\tconst struct rela_dyn *va = a;\n\tconst struct rela_dyn *vb = b;\n\n\treturn va->offset < vb->offset ? -1 : (va->offset > vb->offset ? 1 : 0);\n}\n\nstatic int sort_rela_dyn(struct rela_dyn_info *di)\n{\n\tu32 i, n;\n\n\tdi->sorted = calloc(di->nr_entries, sizeof(di->sorted[0]));\n\tif (!di->sorted)\n\t\treturn -1;\n\n\t \n\tfor (i = 0, n = 0; i < di->nr_entries; i++) {\n\t\tGElf_Rela rela;\n\t\tu32 sym_idx;\n\n\t\tgelf_getrela(di->rela_dyn_data, i, &rela);\n\t\tsym_idx = GELF_R_SYM(rela.r_info);\n\t\tif (sym_idx) {\n\t\t\tdi->sorted[n].sym_idx = sym_idx;\n\t\t\tdi->sorted[n].offset = rela.r_offset;\n\t\t\tn += 1;\n\t\t}\n\t}\n\n\t \n\tdi->nr_entries = n;\n\tqsort(di->sorted, n, sizeof(di->sorted[0]), cmp_offset);\n\n\treturn 0;\n}\n\nstatic void get_rela_dyn_info(Elf *elf, GElf_Ehdr *ehdr, struct rela_dyn_info *di, Elf_Scn *scn)\n{\n\tGElf_Shdr rela_dyn_shdr;\n\tGElf_Shdr shdr;\n\n\tdi->plt_got_data = elf_getdata(scn, NULL);\n\n\tscn = elf_section_by_name(elf, ehdr, &rela_dyn_shdr, \".rela.dyn\", NULL);\n\tif (!scn || !rela_dyn_shdr.sh_link || !rela_dyn_shdr.sh_entsize)\n\t\treturn;\n\n\tdi->nr_entries = rela_dyn_shdr.sh_size / rela_dyn_shdr.sh_entsize;\n\tdi->rela_dyn_data = elf_getdata(scn, NULL);\n\n\tscn = elf_getscn(elf, rela_dyn_shdr.sh_link);\n\tif (!scn || !gelf_getshdr(scn, &shdr) || !shdr.sh_link)\n\t\treturn;\n\n\tdi->dynsym_data = elf_getdata(scn, NULL);\n\tdi->dynstr_data = elf_getdata(elf_getscn(elf, shdr.sh_link), NULL);\n\n\tif (!di->plt_got_data || !di->dynstr_data || !di->dynsym_data || !di->rela_dyn_data)\n\t\treturn;\n\n\t \n\tsort_rela_dyn(di);\n}\n\n \nstatic u32 get_x86_64_plt_disp(const u8 *p)\n{\n\tu8 endbr64[] = {0xf3, 0x0f, 0x1e, 0xfa};\n\tint n = 0;\n\n\t \n\tif (!memcmp(p, endbr64, sizeof(endbr64)))\n\t\tn += sizeof(endbr64);\n\t \n\tif (p[n] == 0xf2)\n\t\tn += 1;\n\t \n\tif (p[n] == 0xff && p[n + 1] == 0x25) {\n\t\tu32 disp;\n\n\t\tn += 2;\n\t\t \n\t\tmemcpy(&disp, p + n, sizeof(disp));\n\t\treturn n + 4 + le32toh(disp);\n\t}\n\treturn 0;\n}\n\nstatic bool get_plt_got_name(GElf_Shdr *shdr, size_t i,\n\t\t\t     struct rela_dyn_info *di,\n\t\t\t     char *buf, size_t buf_sz)\n{\n\tstruct rela_dyn vi, *vr;\n\tconst char *sym_name;\n\tchar *demangled;\n\tGElf_Sym sym;\n\tbool result;\n\tu32 disp;\n\n\tif (!di->sorted)\n\t\treturn false;\n\n\tdisp = get_x86_64_plt_disp(di->plt_got_data->d_buf + i);\n\tif (!disp)\n\t\treturn false;\n\n\t \n\tvi.offset = shdr->sh_offset + di->plt_got_data->d_off + i + disp;\n\n\t \n\tvr = bsearch(&vi, di->sorted, di->nr_entries, sizeof(di->sorted[0]), cmp_offset);\n\tif (!vr)\n\t\treturn false;\n\n\t \n\tgelf_getsym(di->dynsym_data, vr->sym_idx, &sym);\n\tsym_name = elf_sym__name(&sym, di->dynstr_data);\n\tdemangled = demangle_sym(di->dso, 0, sym_name);\n\tif (demangled != NULL)\n\t\tsym_name = demangled;\n\n\tsnprintf(buf, buf_sz, \"%s@plt\", sym_name);\n\n\tresult = *sym_name;\n\n\tfree(demangled);\n\n\treturn result;\n}\n\nstatic int dso__synthesize_plt_got_symbols(struct dso *dso, Elf *elf,\n\t\t\t\t\t   GElf_Ehdr *ehdr,\n\t\t\t\t\t   char *buf, size_t buf_sz)\n{\n\tstruct rela_dyn_info di = { .dso = dso };\n\tstruct symbol *sym;\n\tGElf_Shdr shdr;\n\tElf_Scn *scn;\n\tint err = -1;\n\tsize_t i;\n\n\tscn = elf_section_by_name(elf, ehdr, &shdr, \".plt.got\", NULL);\n\tif (!scn || !shdr.sh_entsize)\n\t\treturn 0;\n\n\tif (ehdr->e_machine == EM_X86_64)\n\t\tget_rela_dyn_info(elf, ehdr, &di, scn);\n\n\tfor (i = 0; i < shdr.sh_size; i += shdr.sh_entsize) {\n\t\tif (!get_plt_got_name(&shdr, i, &di, buf, buf_sz))\n\t\t\tsnprintf(buf, buf_sz, \"offset_%#\" PRIx64 \"@plt\", (u64)shdr.sh_offset + i);\n\t\tsym = symbol__new(shdr.sh_offset + i, shdr.sh_entsize, STB_GLOBAL, STT_FUNC, buf);\n\t\tif (!sym)\n\t\t\tgoto out;\n\t\tsymbols__insert(&dso->symbols, sym);\n\t}\n\terr = 0;\nout:\n\texit_rela_dyn(&di);\n\treturn err;\n}\n\n \nint dso__synthesize_plt_symbols(struct dso *dso, struct symsrc *ss)\n{\n\tuint32_t idx;\n\tGElf_Sym sym;\n\tu64 plt_offset, plt_header_size, plt_entry_size;\n\tGElf_Shdr shdr_plt, plt_sec_shdr;\n\tstruct symbol *f, *plt_sym;\n\tGElf_Shdr shdr_rel_plt, shdr_dynsym;\n\tElf_Data *syms, *symstrs;\n\tElf_Scn *scn_plt_rel, *scn_symstrs, *scn_dynsym;\n\tGElf_Ehdr ehdr;\n\tchar sympltname[1024];\n\tElf *elf;\n\tint nr = 0, err = -1;\n\tstruct rel_info ri = { .is_rela = false };\n\tbool lazy_plt;\n\n\telf = ss->elf;\n\tehdr = ss->ehdr;\n\n\tif (!elf_section_by_name(elf, &ehdr, &shdr_plt, \".plt\", NULL))\n\t\treturn 0;\n\n\t \n\tf = dso__find_symbol_nocache(dso, shdr_plt.sh_offset);\n\tif (f && f->start < shdr_plt.sh_offset && f->end > shdr_plt.sh_offset)\n\t\tf->end = shdr_plt.sh_offset;\n\n\tif (!get_plt_sizes(dso, &ehdr, &shdr_plt, &plt_header_size, &plt_entry_size))\n\t\treturn 0;\n\n\t \n\tplt_sym = symbol__new(shdr_plt.sh_offset, plt_header_size, STB_GLOBAL, STT_FUNC, \".plt\");\n\tif (!plt_sym)\n\t\tgoto out_elf_end;\n\tsymbols__insert(&dso->symbols, plt_sym);\n\n\t \n\tif (machine_is_x86(ehdr.e_machine) &&\n\t    dso__synthesize_plt_got_symbols(dso, elf, &ehdr, sympltname, sizeof(sympltname)))\n\t\tgoto out_elf_end;\n\n\t \n\tif (machine_is_x86(ehdr.e_machine) &&\n\t    elf_section_by_name(elf, &ehdr, &plt_sec_shdr, \".plt.sec\", NULL)) {\n\t\tif (!get_plt_sizes(dso, &ehdr, &plt_sec_shdr, &plt_header_size, &plt_entry_size))\n\t\t\treturn 0;\n\t\t \n\t\tplt_sym->end = plt_sym->start + shdr_plt.sh_size;\n\t\t \n\t\tplt_offset = plt_sec_shdr.sh_offset;\n\t\tlazy_plt = false;\n\t} else {\n\t\tplt_offset = shdr_plt.sh_offset;\n\t\tlazy_plt = true;\n\t}\n\n\tscn_plt_rel = elf_section_by_name(elf, &ehdr, &shdr_rel_plt,\n\t\t\t\t\t  \".rela.plt\", NULL);\n\tif (scn_plt_rel == NULL) {\n\t\tscn_plt_rel = elf_section_by_name(elf, &ehdr, &shdr_rel_plt,\n\t\t\t\t\t\t  \".rel.plt\", NULL);\n\t\tif (scn_plt_rel == NULL)\n\t\t\treturn 0;\n\t}\n\n\tif (shdr_rel_plt.sh_type != SHT_RELA &&\n\t    shdr_rel_plt.sh_type != SHT_REL)\n\t\treturn 0;\n\n\tif (!shdr_rel_plt.sh_link)\n\t\treturn 0;\n\n\tif (shdr_rel_plt.sh_link == ss->dynsym_idx) {\n\t\tscn_dynsym = ss->dynsym;\n\t\tshdr_dynsym = ss->dynshdr;\n\t} else if (shdr_rel_plt.sh_link == ss->symtab_idx) {\n\t\t \n\t\tscn_dynsym = ss->symtab;\n\t\tshdr_dynsym = ss->symshdr;\n\t} else {\n\t\tgoto out_elf_end;\n\t}\n\n\tif (!scn_dynsym)\n\t\treturn 0;\n\n\t \n\tri.reldata = elf_getdata(scn_plt_rel, NULL);\n\tif (!ri.reldata)\n\t\tgoto out_elf_end;\n\n\tsyms = elf_getdata(scn_dynsym, NULL);\n\tif (syms == NULL)\n\t\tgoto out_elf_end;\n\n\tscn_symstrs = elf_getscn(elf, shdr_dynsym.sh_link);\n\tif (scn_symstrs == NULL)\n\t\tgoto out_elf_end;\n\n\tsymstrs = elf_getdata(scn_symstrs, NULL);\n\tif (symstrs == NULL)\n\t\tgoto out_elf_end;\n\n\tif (symstrs->d_size == 0)\n\t\tgoto out_elf_end;\n\n\tri.nr_entries = shdr_rel_plt.sh_size / shdr_rel_plt.sh_entsize;\n\n\tri.is_rela = shdr_rel_plt.sh_type == SHT_RELA;\n\n\tif (lazy_plt) {\n\t\t \n\t\tif (ri.nr_entries * plt_entry_size == shdr_plt.sh_size)\n\t\t\tdso__delete_symbol(dso, plt_sym);\n\t\telse\n\t\t\tplt_offset += plt_header_size;\n\t}\n\n\t \n\tif (machine_is_x86(ehdr.e_machine) && sort_rel(&ri))\n\t\tgoto out_elf_end;\n\n\tfor (idx = 0; idx < ri.nr_entries; idx++) {\n\t\tconst char *elf_name = NULL;\n\t\tchar *demangled = NULL;\n\n\t\tgelf_getsym(syms, get_rel_symidx(&ri, idx), &sym);\n\n\t\telf_name = elf_sym__name(&sym, symstrs);\n\t\tdemangled = demangle_sym(dso, 0, elf_name);\n\t\tif (demangled)\n\t\t\telf_name = demangled;\n\t\tif (*elf_name)\n\t\t\tsnprintf(sympltname, sizeof(sympltname), \"%s@plt\", elf_name);\n\t\telse if (!get_ifunc_name(elf, dso, &ehdr, &ri, sympltname, sizeof(sympltname)))\n\t\t\tsnprintf(sympltname, sizeof(sympltname),\n\t\t\t\t \"offset_%#\" PRIx64 \"@plt\", plt_offset);\n\t\tfree(demangled);\n\n\t\tf = symbol__new(plt_offset, plt_entry_size, STB_GLOBAL, STT_FUNC, sympltname);\n\t\tif (!f)\n\t\t\tgoto out_elf_end;\n\n\t\tplt_offset += plt_entry_size;\n\t\tsymbols__insert(&dso->symbols, f);\n\t\t++nr;\n\t}\n\n\terr = 0;\nout_elf_end:\n\texit_rel(&ri);\n\tif (err == 0)\n\t\treturn nr;\n\tpr_debug(\"%s: problems reading %s PLT info.\\n\",\n\t\t __func__, dso->long_name);\n\treturn 0;\n}\n\nchar *dso__demangle_sym(struct dso *dso, int kmodule, const char *elf_name)\n{\n\treturn demangle_sym(dso, kmodule, elf_name);\n}\n\n \n#define NOTE_ALIGN(n) (((n) + 3) & -4U)\n\nstatic int elf_read_build_id(Elf *elf, void *bf, size_t size)\n{\n\tint err = -1;\n\tGElf_Ehdr ehdr;\n\tGElf_Shdr shdr;\n\tElf_Data *data;\n\tElf_Scn *sec;\n\tElf_Kind ek;\n\tvoid *ptr;\n\n\tif (size < BUILD_ID_SIZE)\n\t\tgoto out;\n\n\tek = elf_kind(elf);\n\tif (ek != ELF_K_ELF)\n\t\tgoto out;\n\n\tif (gelf_getehdr(elf, &ehdr) == NULL) {\n\t\tpr_err(\"%s: cannot get elf header.\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t \n\tdo {\n\t\tsec = elf_section_by_name(elf, &ehdr, &shdr,\n\t\t\t\t\t  \".note.gnu.build-id\", NULL);\n\t\tif (sec)\n\t\t\tbreak;\n\n\t\tsec = elf_section_by_name(elf, &ehdr, &shdr,\n\t\t\t\t\t  \".notes\", NULL);\n\t\tif (sec)\n\t\t\tbreak;\n\n\t\tsec = elf_section_by_name(elf, &ehdr, &shdr,\n\t\t\t\t\t  \".note\", NULL);\n\t\tif (sec)\n\t\t\tbreak;\n\n\t\treturn err;\n\n\t} while (0);\n\n\tdata = elf_getdata(sec, NULL);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tptr = data->d_buf;\n\twhile (ptr < (data->d_buf + data->d_size)) {\n\t\tGElf_Nhdr *nhdr = ptr;\n\t\tsize_t namesz = NOTE_ALIGN(nhdr->n_namesz),\n\t\t       descsz = NOTE_ALIGN(nhdr->n_descsz);\n\t\tconst char *name;\n\n\t\tptr += sizeof(*nhdr);\n\t\tname = ptr;\n\t\tptr += namesz;\n\t\tif (nhdr->n_type == NT_GNU_BUILD_ID &&\n\t\t    nhdr->n_namesz == sizeof(\"GNU\")) {\n\t\t\tif (memcmp(name, \"GNU\", sizeof(\"GNU\")) == 0) {\n\t\t\t\tsize_t sz = min(size, descsz);\n\t\t\t\tmemcpy(bf, ptr, sz);\n\t\t\t\tmemset(bf + sz, 0, size - sz);\n\t\t\t\terr = sz;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tptr += descsz;\n\t}\n\nout:\n\treturn err;\n}\n\n#ifdef HAVE_LIBBFD_BUILDID_SUPPORT\n\nstatic int read_build_id(const char *filename, struct build_id *bid)\n{\n\tsize_t size = sizeof(bid->data);\n\tint err = -1;\n\tbfd *abfd;\n\n\tabfd = bfd_openr(filename, NULL);\n\tif (!abfd)\n\t\treturn -1;\n\n\tif (!bfd_check_format(abfd, bfd_object)) {\n\t\tpr_debug2(\"%s: cannot read %s bfd file.\\n\", __func__, filename);\n\t\tgoto out_close;\n\t}\n\n\tif (!abfd->build_id || abfd->build_id->size > size)\n\t\tgoto out_close;\n\n\tmemcpy(bid->data, abfd->build_id->data, abfd->build_id->size);\n\tmemset(bid->data + abfd->build_id->size, 0, size - abfd->build_id->size);\n\terr = bid->size = abfd->build_id->size;\n\nout_close:\n\tbfd_close(abfd);\n\treturn err;\n}\n\n#else  \n\nstatic int read_build_id(const char *filename, struct build_id *bid)\n{\n\tsize_t size = sizeof(bid->data);\n\tint fd, err = -1;\n\tElf *elf;\n\n\tif (size < BUILD_ID_SIZE)\n\t\tgoto out;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto out;\n\n\telf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tif (elf == NULL) {\n\t\tpr_debug2(\"%s: cannot read %s ELF file.\\n\", __func__, filename);\n\t\tgoto out_close;\n\t}\n\n\terr = elf_read_build_id(elf, bid->data, size);\n\tif (err > 0)\n\t\tbid->size = err;\n\n\telf_end(elf);\nout_close:\n\tclose(fd);\nout:\n\treturn err;\n}\n\n#endif  \n\nint filename__read_build_id(const char *filename, struct build_id *bid)\n{\n\tstruct kmod_path m = { .name = NULL, };\n\tchar path[PATH_MAX];\n\tint err;\n\n\tif (!filename)\n\t\treturn -EFAULT;\n\n\terr = kmod_path__parse(&m, filename);\n\tif (err)\n\t\treturn -1;\n\n\tif (m.comp) {\n\t\tint error = 0, fd;\n\n\t\tfd = filename__decompress(filename, path, sizeof(path), m.comp, &error);\n\t\tif (fd < 0) {\n\t\t\tpr_debug(\"Failed to decompress (error %d) %s\\n\",\n\t\t\t\t error, filename);\n\t\t\treturn -1;\n\t\t}\n\t\tclose(fd);\n\t\tfilename = path;\n\t}\n\n\terr = read_build_id(filename, bid);\n\n\tif (m.comp)\n\t\tunlink(filename);\n\treturn err;\n}\n\nint sysfs__read_build_id(const char *filename, struct build_id *bid)\n{\n\tsize_t size = sizeof(bid->data);\n\tint fd, err = -1;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tchar bf[BUFSIZ];\n\t\tGElf_Nhdr nhdr;\n\t\tsize_t namesz, descsz;\n\n\t\tif (read(fd, &nhdr, sizeof(nhdr)) != sizeof(nhdr))\n\t\t\tbreak;\n\n\t\tnamesz = NOTE_ALIGN(nhdr.n_namesz);\n\t\tdescsz = NOTE_ALIGN(nhdr.n_descsz);\n\t\tif (nhdr.n_type == NT_GNU_BUILD_ID &&\n\t\t    nhdr.n_namesz == sizeof(\"GNU\")) {\n\t\t\tif (read(fd, bf, namesz) != (ssize_t)namesz)\n\t\t\t\tbreak;\n\t\t\tif (memcmp(bf, \"GNU\", sizeof(\"GNU\")) == 0) {\n\t\t\t\tsize_t sz = min(descsz, size);\n\t\t\t\tif (read(fd, bid->data, sz) == (ssize_t)sz) {\n\t\t\t\t\tmemset(bid->data + sz, 0, size - sz);\n\t\t\t\t\tbid->size = sz;\n\t\t\t\t\terr = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (read(fd, bf, descsz) != (ssize_t)descsz)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tint n = namesz + descsz;\n\n\t\t\tif (n > (int)sizeof(bf)) {\n\t\t\t\tn = sizeof(bf);\n\t\t\t\tpr_debug(\"%s: truncating reading of build id in sysfs file %s: n_namesz=%u, n_descsz=%u.\\n\",\n\t\t\t\t\t __func__, filename, nhdr.n_namesz, nhdr.n_descsz);\n\t\t\t}\n\t\t\tif (read(fd, bf, n) != n)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tclose(fd);\nout:\n\treturn err;\n}\n\n#ifdef HAVE_LIBBFD_SUPPORT\n\nint filename__read_debuglink(const char *filename, char *debuglink,\n\t\t\t     size_t size)\n{\n\tint err = -1;\n\tasection *section;\n\tbfd *abfd;\n\n\tabfd = bfd_openr(filename, NULL);\n\tif (!abfd)\n\t\treturn -1;\n\n\tif (!bfd_check_format(abfd, bfd_object)) {\n\t\tpr_debug2(\"%s: cannot read %s bfd file.\\n\", __func__, filename);\n\t\tgoto out_close;\n\t}\n\n\tsection = bfd_get_section_by_name(abfd, \".gnu_debuglink\");\n\tif (!section)\n\t\tgoto out_close;\n\n\tif (section->size > size)\n\t\tgoto out_close;\n\n\tif (!bfd_get_section_contents(abfd, section, debuglink, 0,\n\t\t\t\t      section->size))\n\t\tgoto out_close;\n\n\terr = 0;\n\nout_close:\n\tbfd_close(abfd);\n\treturn err;\n}\n\n#else\n\nint filename__read_debuglink(const char *filename, char *debuglink,\n\t\t\t     size_t size)\n{\n\tint fd, err = -1;\n\tElf *elf;\n\tGElf_Ehdr ehdr;\n\tGElf_Shdr shdr;\n\tElf_Data *data;\n\tElf_Scn *sec;\n\tElf_Kind ek;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto out;\n\n\telf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tif (elf == NULL) {\n\t\tpr_debug2(\"%s: cannot read %s ELF file.\\n\", __func__, filename);\n\t\tgoto out_close;\n\t}\n\n\tek = elf_kind(elf);\n\tif (ek != ELF_K_ELF)\n\t\tgoto out_elf_end;\n\n\tif (gelf_getehdr(elf, &ehdr) == NULL) {\n\t\tpr_err(\"%s: cannot get elf header.\\n\", __func__);\n\t\tgoto out_elf_end;\n\t}\n\n\tsec = elf_section_by_name(elf, &ehdr, &shdr,\n\t\t\t\t  \".gnu_debuglink\", NULL);\n\tif (sec == NULL)\n\t\tgoto out_elf_end;\n\n\tdata = elf_getdata(sec, NULL);\n\tif (data == NULL)\n\t\tgoto out_elf_end;\n\n\t \n\tstrncpy(debuglink, data->d_buf, size);\n\n\terr = 0;\n\nout_elf_end:\n\telf_end(elf);\nout_close:\n\tclose(fd);\nout:\n\treturn err;\n}\n\n#endif\n\nstatic int dso__swap_init(struct dso *dso, unsigned char eidata)\n{\n\tstatic unsigned int const endian = 1;\n\n\tdso->needs_swap = DSO_SWAP__NO;\n\n\tswitch (eidata) {\n\tcase ELFDATA2LSB:\n\t\t \n\t\tif (*(unsigned char const *)&endian != 1)\n\t\t\tdso->needs_swap = DSO_SWAP__YES;\n\t\tbreak;\n\n\tcase ELFDATA2MSB:\n\t\t \n\t\tif (*(unsigned char const *)&endian != 0)\n\t\t\tdso->needs_swap = DSO_SWAP__YES;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"unrecognized DSO data encoding %d\\n\", eidata);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nbool symsrc__possibly_runtime(struct symsrc *ss)\n{\n\treturn ss->dynsym || ss->opdsec;\n}\n\nbool symsrc__has_symtab(struct symsrc *ss)\n{\n\treturn ss->symtab != NULL;\n}\n\nvoid symsrc__destroy(struct symsrc *ss)\n{\n\tzfree(&ss->name);\n\telf_end(ss->elf);\n\tclose(ss->fd);\n}\n\nbool elf__needs_adjust_symbols(GElf_Ehdr ehdr)\n{\n\t \n\treturn ehdr.e_type == ET_EXEC || ehdr.e_type == ET_REL ||\n\t       ehdr.e_type == ET_DYN;\n}\n\nint symsrc__init(struct symsrc *ss, struct dso *dso, const char *name,\n\t\t enum dso_binary_type type)\n{\n\tGElf_Ehdr ehdr;\n\tElf *elf;\n\tint fd;\n\n\tif (dso__needs_decompress(dso)) {\n\t\tfd = dso__decompress_kmodule_fd(dso, name);\n\t\tif (fd < 0)\n\t\t\treturn -1;\n\n\t\ttype = dso->symtab_type;\n\t} else {\n\t\tfd = open(name, O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\tdso->load_errno = errno;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\telf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tif (elf == NULL) {\n\t\tpr_debug(\"%s: cannot read %s ELF file.\\n\", __func__, name);\n\t\tdso->load_errno = DSO_LOAD_ERRNO__INVALID_ELF;\n\t\tgoto out_close;\n\t}\n\n\tif (gelf_getehdr(elf, &ehdr) == NULL) {\n\t\tdso->load_errno = DSO_LOAD_ERRNO__INVALID_ELF;\n\t\tpr_debug(\"%s: cannot get elf header.\\n\", __func__);\n\t\tgoto out_elf_end;\n\t}\n\n\tif (dso__swap_init(dso, ehdr.e_ident[EI_DATA])) {\n\t\tdso->load_errno = DSO_LOAD_ERRNO__INTERNAL_ERROR;\n\t\tgoto out_elf_end;\n\t}\n\n\t \n\tif (dso->has_build_id && !symbol_conf.ignore_vmlinux_buildid) {\n\t\tu8 build_id[BUILD_ID_SIZE];\n\t\tstruct build_id bid;\n\t\tint size;\n\n\t\tsize = elf_read_build_id(elf, build_id, BUILD_ID_SIZE);\n\t\tif (size <= 0) {\n\t\t\tdso->load_errno = DSO_LOAD_ERRNO__CANNOT_READ_BUILDID;\n\t\t\tgoto out_elf_end;\n\t\t}\n\n\t\tbuild_id__init(&bid, build_id, size);\n\t\tif (!dso__build_id_equal(dso, &bid)) {\n\t\t\tpr_debug(\"%s: build id mismatch for %s.\\n\", __func__, name);\n\t\t\tdso->load_errno = DSO_LOAD_ERRNO__MISMATCHING_BUILDID;\n\t\t\tgoto out_elf_end;\n\t\t}\n\t}\n\n\tss->is_64_bit = (gelf_getclass(elf) == ELFCLASS64);\n\n\tss->symtab_idx = 0;\n\tss->symtab = elf_section_by_name(elf, &ehdr, &ss->symshdr, \".symtab\",\n\t\t\t&ss->symtab_idx);\n\tif (ss->symshdr.sh_type != SHT_SYMTAB)\n\t\tss->symtab = NULL;\n\n\tss->dynsym_idx = 0;\n\tss->dynsym = elf_section_by_name(elf, &ehdr, &ss->dynshdr, \".dynsym\",\n\t\t\t&ss->dynsym_idx);\n\tif (ss->dynshdr.sh_type != SHT_DYNSYM)\n\t\tss->dynsym = NULL;\n\n\tss->opdidx = 0;\n\tss->opdsec = elf_section_by_name(elf, &ehdr, &ss->opdshdr, \".opd\",\n\t\t\t&ss->opdidx);\n\tif (ss->opdshdr.sh_type != SHT_PROGBITS)\n\t\tss->opdsec = NULL;\n\n\tif (dso->kernel == DSO_SPACE__USER)\n\t\tss->adjust_symbols = true;\n\telse\n\t\tss->adjust_symbols = elf__needs_adjust_symbols(ehdr);\n\n\tss->name   = strdup(name);\n\tif (!ss->name) {\n\t\tdso->load_errno = errno;\n\t\tgoto out_elf_end;\n\t}\n\n\tss->elf    = elf;\n\tss->fd     = fd;\n\tss->ehdr   = ehdr;\n\tss->type   = type;\n\n\treturn 0;\n\nout_elf_end:\n\telf_end(elf);\nout_close:\n\tclose(fd);\n\treturn -1;\n}\n\n \nstatic bool ref_reloc_sym_not_found(struct kmap *kmap)\n{\n\treturn kmap && kmap->ref_reloc_sym && kmap->ref_reloc_sym->name &&\n\t       !kmap->ref_reloc_sym->unrelocated_addr;\n}\n\n \nstatic u64 ref_reloc(struct kmap *kmap)\n{\n\tif (kmap && kmap->ref_reloc_sym &&\n\t    kmap->ref_reloc_sym->unrelocated_addr)\n\t\treturn kmap->ref_reloc_sym->addr -\n\t\t       kmap->ref_reloc_sym->unrelocated_addr;\n\treturn 0;\n}\n\nvoid __weak arch__sym_update(struct symbol *s __maybe_unused,\n\t\tGElf_Sym *sym __maybe_unused) { }\n\nstatic int dso__process_kernel_symbol(struct dso *dso, struct map *map,\n\t\t\t\t      GElf_Sym *sym, GElf_Shdr *shdr,\n\t\t\t\t      struct maps *kmaps, struct kmap *kmap,\n\t\t\t\t      struct dso **curr_dsop, struct map **curr_mapp,\n\t\t\t\t      const char *section_name,\n\t\t\t\t      bool adjust_kernel_syms, bool kmodule, bool *remap_kernel)\n{\n\tstruct dso *curr_dso = *curr_dsop;\n\tstruct map *curr_map;\n\tchar dso_name[PATH_MAX];\n\n\t \n\tif (adjust_kernel_syms)\n\t\tsym->st_value -= shdr->sh_addr - shdr->sh_offset;\n\n\tif (strcmp(section_name, (curr_dso->short_name + dso->short_name_len)) == 0)\n\t\treturn 0;\n\n\tif (strcmp(section_name, \".text\") == 0) {\n\t\t \n\t\tif (*remap_kernel && dso->kernel && !kmodule) {\n\t\t\t*remap_kernel = false;\n\t\t\tmap__set_start(map, shdr->sh_addr + ref_reloc(kmap));\n\t\t\tmap__set_end(map, map__start(map) + shdr->sh_size);\n\t\t\tmap__set_pgoff(map, shdr->sh_offset);\n\t\t\tmap__set_map_ip(map, map__dso_map_ip);\n\t\t\tmap__set_unmap_ip(map, map__dso_unmap_ip);\n\t\t\t \n\t\t\tif (kmaps) {\n\t\t\t\tint err;\n\t\t\t\tstruct map *tmp = map__get(map);\n\n\t\t\t\tmaps__remove(kmaps, map);\n\t\t\t\terr = maps__insert(kmaps, map);\n\t\t\t\tmap__put(tmp);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (*remap_kernel && kmodule) {\n\t\t\t*remap_kernel = false;\n\t\t\tmap__set_pgoff(map, shdr->sh_offset);\n\t\t}\n\n\t\t*curr_mapp = map;\n\t\t*curr_dsop = dso;\n\t\treturn 0;\n\t}\n\n\tif (!kmap)\n\t\treturn 0;\n\n\tsnprintf(dso_name, sizeof(dso_name), \"%s%s\", dso->short_name, section_name);\n\n\tcurr_map = maps__find_by_name(kmaps, dso_name);\n\tif (curr_map == NULL) {\n\t\tu64 start = sym->st_value;\n\n\t\tif (kmodule)\n\t\t\tstart += map__start(map) + shdr->sh_offset;\n\n\t\tcurr_dso = dso__new(dso_name);\n\t\tif (curr_dso == NULL)\n\t\t\treturn -1;\n\t\tcurr_dso->kernel = dso->kernel;\n\t\tcurr_dso->long_name = dso->long_name;\n\t\tcurr_dso->long_name_len = dso->long_name_len;\n\t\tcurr_dso->binary_type = dso->binary_type;\n\t\tcurr_dso->adjust_symbols = dso->adjust_symbols;\n\t\tcurr_map = map__new2(start, curr_dso);\n\t\tdso__put(curr_dso);\n\t\tif (curr_map == NULL)\n\t\t\treturn -1;\n\n\t\tif (curr_dso->kernel)\n\t\t\tmap__kmap(curr_map)->kmaps = kmaps;\n\n\t\tif (adjust_kernel_syms) {\n\t\t\tmap__set_start(curr_map, shdr->sh_addr + ref_reloc(kmap));\n\t\t\tmap__set_end(curr_map, map__start(curr_map) + shdr->sh_size);\n\t\t\tmap__set_pgoff(curr_map, shdr->sh_offset);\n\t\t} else {\n\t\t\tmap__set_map_ip(curr_map, identity__map_ip);\n\t\t\tmap__set_unmap_ip(curr_map, identity__map_ip);\n\t\t}\n\t\tcurr_dso->symtab_type = dso->symtab_type;\n\t\tif (maps__insert(kmaps, curr_map))\n\t\t\treturn -1;\n\t\t \n\t\tdsos__add(&maps__machine(kmaps)->dsos, curr_dso);\n\t\t \n\t\tmap__put(curr_map);\n\t\tdso__set_loaded(curr_dso);\n\t\t*curr_mapp = curr_map;\n\t\t*curr_dsop = curr_dso;\n\t} else\n\t\t*curr_dsop = map__dso(curr_map);\n\n\treturn 0;\n}\n\nstatic int\ndso__load_sym_internal(struct dso *dso, struct map *map, struct symsrc *syms_ss,\n\t\t       struct symsrc *runtime_ss, int kmodule, int dynsym)\n{\n\tstruct kmap *kmap = dso->kernel ? map__kmap(map) : NULL;\n\tstruct maps *kmaps = kmap ? map__kmaps(map) : NULL;\n\tstruct map *curr_map = map;\n\tstruct dso *curr_dso = dso;\n\tElf_Data *symstrs, *secstrs, *secstrs_run, *secstrs_sym;\n\tuint32_t nr_syms;\n\tint err = -1;\n\tuint32_t idx;\n\tGElf_Ehdr ehdr;\n\tGElf_Shdr shdr;\n\tGElf_Shdr tshdr;\n\tElf_Data *syms, *opddata = NULL;\n\tGElf_Sym sym;\n\tElf_Scn *sec, *sec_strndx;\n\tElf *elf;\n\tint nr = 0;\n\tbool remap_kernel = false, adjust_kernel_syms = false;\n\n\tif (kmap && !kmaps)\n\t\treturn -1;\n\n\telf = syms_ss->elf;\n\tehdr = syms_ss->ehdr;\n\tif (dynsym) {\n\t\tsec  = syms_ss->dynsym;\n\t\tshdr = syms_ss->dynshdr;\n\t} else {\n\t\tsec =  syms_ss->symtab;\n\t\tshdr = syms_ss->symshdr;\n\t}\n\n\tif (elf_section_by_name(runtime_ss->elf, &runtime_ss->ehdr, &tshdr,\n\t\t\t\t\".text\", NULL))\n\t\tdso->text_offset = tshdr.sh_addr - tshdr.sh_offset;\n\n\tif (runtime_ss->opdsec)\n\t\topddata = elf_rawdata(runtime_ss->opdsec, NULL);\n\n\tsyms = elf_getdata(sec, NULL);\n\tif (syms == NULL)\n\t\tgoto out_elf_end;\n\n\tsec = elf_getscn(elf, shdr.sh_link);\n\tif (sec == NULL)\n\t\tgoto out_elf_end;\n\n\tsymstrs = elf_getdata(sec, NULL);\n\tif (symstrs == NULL)\n\t\tgoto out_elf_end;\n\n\tsec_strndx = elf_getscn(runtime_ss->elf, runtime_ss->ehdr.e_shstrndx);\n\tif (sec_strndx == NULL)\n\t\tgoto out_elf_end;\n\n\tsecstrs_run = elf_getdata(sec_strndx, NULL);\n\tif (secstrs_run == NULL)\n\t\tgoto out_elf_end;\n\n\tsec_strndx = elf_getscn(elf, ehdr.e_shstrndx);\n\tif (sec_strndx == NULL)\n\t\tgoto out_elf_end;\n\n\tsecstrs_sym = elf_getdata(sec_strndx, NULL);\n\tif (secstrs_sym == NULL)\n\t\tgoto out_elf_end;\n\n\tnr_syms = shdr.sh_size / shdr.sh_entsize;\n\n\tmemset(&sym, 0, sizeof(sym));\n\n\t \n\tif (ref_reloc_sym_not_found(kmap)) {\n\t\telf_symtab__for_each_symbol(syms, nr_syms, idx, sym) {\n\t\t\tconst char *elf_name = elf_sym__name(&sym, symstrs);\n\n\t\t\tif (strcmp(elf_name, kmap->ref_reloc_sym->name))\n\t\t\t\tcontinue;\n\t\t\tkmap->ref_reloc_sym->unrelocated_addr = sym.st_value;\n\t\t\tmap__set_reloc(map, kmap->ref_reloc_sym->addr - kmap->ref_reloc_sym->unrelocated_addr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (dso__is_vdso(dso))\n\t\tmap__set_reloc(map, map__start(map) - dso->text_offset);\n\n\tdso->adjust_symbols = runtime_ss->adjust_symbols || ref_reloc(kmap);\n\t \n\tif (dso->kernel) {\n\t\tremap_kernel = true;\n\t\tadjust_kernel_syms = dso->adjust_symbols;\n\t}\n\telf_symtab__for_each_symbol(syms, nr_syms, idx, sym) {\n\t\tstruct symbol *f;\n\t\tconst char *elf_name = elf_sym__name(&sym, symstrs);\n\t\tchar *demangled = NULL;\n\t\tint is_label = elf_sym__is_label(&sym);\n\t\tconst char *section_name;\n\t\tbool used_opd = false;\n\n\t\tif (!is_label && !elf_sym__filter(&sym))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ehdr.e_machine == EM_ARM || ehdr.e_machine == EM_AARCH64) {\n\t\t\tif (elf_name[0] == '$' && strchr(\"adtx\", elf_name[1])\n\t\t\t    && (elf_name[2] == '\\0' || elf_name[2] == '.'))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (runtime_ss->opdsec && sym.st_shndx == runtime_ss->opdidx) {\n\t\t\tu32 offset = sym.st_value - syms_ss->opdshdr.sh_addr;\n\t\t\tu64 *opd = opddata->d_buf + offset;\n\t\t\tsym.st_value = DSO__SWAP(dso, u64, *opd);\n\t\t\tsym.st_shndx = elf_addr_to_index(runtime_ss->elf,\n\t\t\t\t\tsym.st_value);\n\t\t\tused_opd = true;\n\t\t}\n\n\t\t \n\t\tif (sym.st_shndx == SHN_ABS)\n\t\t\tcontinue;\n\n\t\tsec = elf_getscn(syms_ss->elf, sym.st_shndx);\n\t\tif (!sec)\n\t\t\tgoto out_elf_end;\n\n\t\tgelf_getshdr(sec, &shdr);\n\n\t\t \n\t\tif (!(shdr.sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\tsecstrs = secstrs_sym;\n\n\t\t \n\t\tif (shdr.sh_type == SHT_NOBITS) {\n\t\t\tsec = elf_getscn(runtime_ss->elf, sym.st_shndx);\n\t\t\tif (!sec)\n\t\t\t\tgoto out_elf_end;\n\n\t\t\tgelf_getshdr(sec, &shdr);\n\t\t\tsecstrs = secstrs_run;\n\t\t}\n\n\t\tif (is_label && !elf_sec__filter(&shdr, secstrs))\n\t\t\tcontinue;\n\n\t\tsection_name = elf_sec__name(&shdr, secstrs);\n\n\t\t \n\t\tif ((ehdr.e_machine == EM_ARM) &&\n\t\t    (GELF_ST_TYPE(sym.st_info) == STT_FUNC) &&\n\t\t    (sym.st_value & 1))\n\t\t\t--sym.st_value;\n\n\t\tif (dso->kernel) {\n\t\t\tif (dso__process_kernel_symbol(dso, map, &sym, &shdr, kmaps, kmap, &curr_dso, &curr_map,\n\t\t\t\t\t\t       section_name, adjust_kernel_syms, kmodule, &remap_kernel))\n\t\t\t\tgoto out_elf_end;\n\t\t} else if ((used_opd && runtime_ss->adjust_symbols) ||\n\t\t\t   (!used_opd && syms_ss->adjust_symbols)) {\n\t\t\tGElf_Phdr phdr;\n\n\t\t\tif (elf_read_program_header(runtime_ss->elf,\n\t\t\t\t\t\t    (u64)sym.st_value, &phdr)) {\n\t\t\t\tpr_debug4(\"%s: failed to find program header for \"\n\t\t\t\t\t   \"symbol: %s st_value: %#\" PRIx64 \"\\n\",\n\t\t\t\t\t   __func__, elf_name, (u64)sym.st_value);\n\t\t\t\tpr_debug4(\"%s: adjusting symbol: st_value: %#\" PRIx64 \" \"\n\t\t\t\t\t\"sh_addr: %#\" PRIx64 \" sh_offset: %#\" PRIx64 \"\\n\",\n\t\t\t\t\t__func__, (u64)sym.st_value, (u64)shdr.sh_addr,\n\t\t\t\t\t(u64)shdr.sh_offset);\n\t\t\t\t \n\t\t\t\tsym.st_value -= shdr.sh_addr - shdr.sh_offset;\n\t\t\t} else {\n\t\t\t\tpr_debug4(\"%s: adjusting symbol: st_value: %#\" PRIx64 \" \"\n\t\t\t\t\t\"p_vaddr: %#\" PRIx64 \" p_offset: %#\" PRIx64 \"\\n\",\n\t\t\t\t\t__func__, (u64)sym.st_value, (u64)phdr.p_vaddr,\n\t\t\t\t\t(u64)phdr.p_offset);\n\t\t\t\tsym.st_value -= phdr.p_vaddr - phdr.p_offset;\n\t\t\t}\n\t\t}\n\n\t\tdemangled = demangle_sym(dso, kmodule, elf_name);\n\t\tif (demangled != NULL)\n\t\t\telf_name = demangled;\n\n\t\tf = symbol__new(sym.st_value, sym.st_size,\n\t\t\t\tGELF_ST_BIND(sym.st_info),\n\t\t\t\tGELF_ST_TYPE(sym.st_info), elf_name);\n\t\tfree(demangled);\n\t\tif (!f)\n\t\t\tgoto out_elf_end;\n\n\t\tarch__sym_update(f, &sym);\n\n\t\t__symbols__insert(&curr_dso->symbols, f, dso->kernel);\n\t\tnr++;\n\t}\n\n\t \n\tif (nr > 0) {\n\t\tsymbols__fixup_end(&dso->symbols, false);\n\t\tsymbols__fixup_duplicate(&dso->symbols);\n\t\tif (kmap) {\n\t\t\t \n\t\t\tmaps__fixup_end(kmaps);\n\t\t}\n\t}\n\terr = nr;\nout_elf_end:\n\treturn err;\n}\n\nint dso__load_sym(struct dso *dso, struct map *map, struct symsrc *syms_ss,\n\t\t  struct symsrc *runtime_ss, int kmodule)\n{\n\tint nr = 0;\n\tint err = -1;\n\n\tdso->symtab_type = syms_ss->type;\n\tdso->is_64_bit = syms_ss->is_64_bit;\n\tdso->rel = syms_ss->ehdr.e_type == ET_REL;\n\n\t \n\tif (kmodule && syms_ss->symtab)\n\t\tsymbols__delete(&dso->symbols);\n\n\tif (!syms_ss->symtab) {\n\t\t \n\t\tif (dso->kernel)\n\t\t\treturn err;\n\t} else  {\n\t\terr = dso__load_sym_internal(dso, map, syms_ss, runtime_ss,\n\t\t\t\t\t     kmodule, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tnr = err;\n\t}\n\n\tif (syms_ss->dynsym) {\n\t\terr = dso__load_sym_internal(dso, map, syms_ss, runtime_ss,\n\t\t\t\t\t     kmodule, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr += nr;\n\t}\n\n\treturn err;\n}\n\nstatic int elf_read_maps(Elf *elf, bool exe, mapfn_t mapfn, void *data)\n{\n\tGElf_Phdr phdr;\n\tsize_t i, phdrnum;\n\tint err;\n\tu64 sz;\n\n\tif (elf_getphdrnum(elf, &phdrnum))\n\t\treturn -1;\n\n\tfor (i = 0; i < phdrnum; i++) {\n\t\tif (gelf_getphdr(elf, i, &phdr) == NULL)\n\t\t\treturn -1;\n\t\tif (phdr.p_type != PT_LOAD)\n\t\t\tcontinue;\n\t\tif (exe) {\n\t\t\tif (!(phdr.p_flags & PF_X))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (!(phdr.p_flags & PF_R))\n\t\t\t\tcontinue;\n\t\t}\n\t\tsz = min(phdr.p_memsz, phdr.p_filesz);\n\t\tif (!sz)\n\t\t\tcontinue;\n\t\terr = mapfn(phdr.p_vaddr, sz, phdr.p_offset, data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint file__read_maps(int fd, bool exe, mapfn_t mapfn, void *data,\n\t\t    bool *is_64_bit)\n{\n\tint err;\n\tElf *elf;\n\n\telf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tif (elf == NULL)\n\t\treturn -1;\n\n\tif (is_64_bit)\n\t\t*is_64_bit = (gelf_getclass(elf) == ELFCLASS64);\n\n\terr = elf_read_maps(elf, exe, mapfn, data);\n\n\telf_end(elf);\n\treturn err;\n}\n\nenum dso_type dso__type_fd(int fd)\n{\n\tenum dso_type dso_type = DSO__TYPE_UNKNOWN;\n\tGElf_Ehdr ehdr;\n\tElf_Kind ek;\n\tElf *elf;\n\n\telf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tif (elf == NULL)\n\t\tgoto out;\n\n\tek = elf_kind(elf);\n\tif (ek != ELF_K_ELF)\n\t\tgoto out_end;\n\n\tif (gelf_getclass(elf) == ELFCLASS64) {\n\t\tdso_type = DSO__TYPE_64BIT;\n\t\tgoto out_end;\n\t}\n\n\tif (gelf_getehdr(elf, &ehdr) == NULL)\n\t\tgoto out_end;\n\n\tif (ehdr.e_machine == EM_X86_64)\n\t\tdso_type = DSO__TYPE_X32BIT;\n\telse\n\t\tdso_type = DSO__TYPE_32BIT;\nout_end:\n\telf_end(elf);\nout:\n\treturn dso_type;\n}\n\nstatic int copy_bytes(int from, off_t from_offs, int to, off_t to_offs, u64 len)\n{\n\tssize_t r;\n\tsize_t n;\n\tint err = -1;\n\tchar *buf = malloc(page_size);\n\n\tif (buf == NULL)\n\t\treturn -1;\n\n\tif (lseek(to, to_offs, SEEK_SET) != to_offs)\n\t\tgoto out;\n\n\tif (lseek(from, from_offs, SEEK_SET) != from_offs)\n\t\tgoto out;\n\n\twhile (len) {\n\t\tn = page_size;\n\t\tif (len < n)\n\t\t\tn = len;\n\t\t \n\t\tr = read(from, buf, n);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tif (!r)\n\t\t\tbreak;\n\t\tn = r;\n\t\tr = write(to, buf, n);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tif ((size_t)r != n)\n\t\t\tgoto out;\n\t\tlen -= n;\n\t}\n\n\terr = 0;\nout:\n\tfree(buf);\n\treturn err;\n}\n\nstruct kcore {\n\tint fd;\n\tint elfclass;\n\tElf *elf;\n\tGElf_Ehdr ehdr;\n};\n\nstatic int kcore__open(struct kcore *kcore, const char *filename)\n{\n\tGElf_Ehdr *ehdr;\n\n\tkcore->fd = open(filename, O_RDONLY);\n\tif (kcore->fd == -1)\n\t\treturn -1;\n\n\tkcore->elf = elf_begin(kcore->fd, ELF_C_READ, NULL);\n\tif (!kcore->elf)\n\t\tgoto out_close;\n\n\tkcore->elfclass = gelf_getclass(kcore->elf);\n\tif (kcore->elfclass == ELFCLASSNONE)\n\t\tgoto out_end;\n\n\tehdr = gelf_getehdr(kcore->elf, &kcore->ehdr);\n\tif (!ehdr)\n\t\tgoto out_end;\n\n\treturn 0;\n\nout_end:\n\telf_end(kcore->elf);\nout_close:\n\tclose(kcore->fd);\n\treturn -1;\n}\n\nstatic int kcore__init(struct kcore *kcore, char *filename, int elfclass,\n\t\t       bool temp)\n{\n\tkcore->elfclass = elfclass;\n\n\tif (temp)\n\t\tkcore->fd = mkstemp(filename);\n\telse\n\t\tkcore->fd = open(filename, O_WRONLY | O_CREAT | O_EXCL, 0400);\n\tif (kcore->fd == -1)\n\t\treturn -1;\n\n\tkcore->elf = elf_begin(kcore->fd, ELF_C_WRITE, NULL);\n\tif (!kcore->elf)\n\t\tgoto out_close;\n\n\tif (!gelf_newehdr(kcore->elf, elfclass))\n\t\tgoto out_end;\n\n\tmemset(&kcore->ehdr, 0, sizeof(GElf_Ehdr));\n\n\treturn 0;\n\nout_end:\n\telf_end(kcore->elf);\nout_close:\n\tclose(kcore->fd);\n\tunlink(filename);\n\treturn -1;\n}\n\nstatic void kcore__close(struct kcore *kcore)\n{\n\telf_end(kcore->elf);\n\tclose(kcore->fd);\n}\n\nstatic int kcore__copy_hdr(struct kcore *from, struct kcore *to, size_t count)\n{\n\tGElf_Ehdr *ehdr = &to->ehdr;\n\tGElf_Ehdr *kehdr = &from->ehdr;\n\n\tmemcpy(ehdr->e_ident, kehdr->e_ident, EI_NIDENT);\n\tehdr->e_type      = kehdr->e_type;\n\tehdr->e_machine   = kehdr->e_machine;\n\tehdr->e_version   = kehdr->e_version;\n\tehdr->e_entry     = 0;\n\tehdr->e_shoff     = 0;\n\tehdr->e_flags     = kehdr->e_flags;\n\tehdr->e_phnum     = count;\n\tehdr->e_shentsize = 0;\n\tehdr->e_shnum     = 0;\n\tehdr->e_shstrndx  = 0;\n\n\tif (from->elfclass == ELFCLASS32) {\n\t\tehdr->e_phoff     = sizeof(Elf32_Ehdr);\n\t\tehdr->e_ehsize    = sizeof(Elf32_Ehdr);\n\t\tehdr->e_phentsize = sizeof(Elf32_Phdr);\n\t} else {\n\t\tehdr->e_phoff     = sizeof(Elf64_Ehdr);\n\t\tehdr->e_ehsize    = sizeof(Elf64_Ehdr);\n\t\tehdr->e_phentsize = sizeof(Elf64_Phdr);\n\t}\n\n\tif (!gelf_update_ehdr(to->elf, ehdr))\n\t\treturn -1;\n\n\tif (!gelf_newphdr(to->elf, count))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int kcore__add_phdr(struct kcore *kcore, int idx, off_t offset,\n\t\t\t   u64 addr, u64 len)\n{\n\tGElf_Phdr phdr = {\n\t\t.p_type\t\t= PT_LOAD,\n\t\t.p_flags\t= PF_R | PF_W | PF_X,\n\t\t.p_offset\t= offset,\n\t\t.p_vaddr\t= addr,\n\t\t.p_paddr\t= 0,\n\t\t.p_filesz\t= len,\n\t\t.p_memsz\t= len,\n\t\t.p_align\t= page_size,\n\t};\n\n\tif (!gelf_update_phdr(kcore->elf, idx, &phdr))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic off_t kcore__write(struct kcore *kcore)\n{\n\treturn elf_update(kcore->elf, ELF_C_WRITE);\n}\n\nstruct phdr_data {\n\toff_t offset;\n\toff_t rel;\n\tu64 addr;\n\tu64 len;\n\tstruct list_head node;\n\tstruct phdr_data *remaps;\n};\n\nstruct sym_data {\n\tu64 addr;\n\tstruct list_head node;\n};\n\nstruct kcore_copy_info {\n\tu64 stext;\n\tu64 etext;\n\tu64 first_symbol;\n\tu64 last_symbol;\n\tu64 first_module;\n\tu64 first_module_symbol;\n\tu64 last_module_symbol;\n\tsize_t phnum;\n\tstruct list_head phdrs;\n\tstruct list_head syms;\n};\n\n#define kcore_copy__for_each_phdr(k, p) \\\n\tlist_for_each_entry((p), &(k)->phdrs, node)\n\nstatic struct phdr_data *phdr_data__new(u64 addr, u64 len, off_t offset)\n{\n\tstruct phdr_data *p = zalloc(sizeof(*p));\n\n\tif (p) {\n\t\tp->addr   = addr;\n\t\tp->len    = len;\n\t\tp->offset = offset;\n\t}\n\n\treturn p;\n}\n\nstatic struct phdr_data *kcore_copy_info__addnew(struct kcore_copy_info *kci,\n\t\t\t\t\t\t u64 addr, u64 len,\n\t\t\t\t\t\t off_t offset)\n{\n\tstruct phdr_data *p = phdr_data__new(addr, len, offset);\n\n\tif (p)\n\t\tlist_add_tail(&p->node, &kci->phdrs);\n\n\treturn p;\n}\n\nstatic void kcore_copy__free_phdrs(struct kcore_copy_info *kci)\n{\n\tstruct phdr_data *p, *tmp;\n\n\tlist_for_each_entry_safe(p, tmp, &kci->phdrs, node) {\n\t\tlist_del_init(&p->node);\n\t\tfree(p);\n\t}\n}\n\nstatic struct sym_data *kcore_copy__new_sym(struct kcore_copy_info *kci,\n\t\t\t\t\t    u64 addr)\n{\n\tstruct sym_data *s = zalloc(sizeof(*s));\n\n\tif (s) {\n\t\ts->addr = addr;\n\t\tlist_add_tail(&s->node, &kci->syms);\n\t}\n\n\treturn s;\n}\n\nstatic void kcore_copy__free_syms(struct kcore_copy_info *kci)\n{\n\tstruct sym_data *s, *tmp;\n\n\tlist_for_each_entry_safe(s, tmp, &kci->syms, node) {\n\t\tlist_del_init(&s->node);\n\t\tfree(s);\n\t}\n}\n\nstatic int kcore_copy__process_kallsyms(void *arg, const char *name, char type,\n\t\t\t\t\tu64 start)\n{\n\tstruct kcore_copy_info *kci = arg;\n\n\tif (!kallsyms__is_function(type))\n\t\treturn 0;\n\n\tif (strchr(name, '[')) {\n\t\tif (!kci->first_module_symbol || start < kci->first_module_symbol)\n\t\t\tkci->first_module_symbol = start;\n\t\tif (start > kci->last_module_symbol)\n\t\t\tkci->last_module_symbol = start;\n\t\treturn 0;\n\t}\n\n\tif (!kci->first_symbol || start < kci->first_symbol)\n\t\tkci->first_symbol = start;\n\n\tif (!kci->last_symbol || start > kci->last_symbol)\n\t\tkci->last_symbol = start;\n\n\tif (!strcmp(name, \"_stext\")) {\n\t\tkci->stext = start;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(name, \"_etext\")) {\n\t\tkci->etext = start;\n\t\treturn 0;\n\t}\n\n\tif (is_entry_trampoline(name) && !kcore_copy__new_sym(kci, start))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int kcore_copy__parse_kallsyms(struct kcore_copy_info *kci,\n\t\t\t\t      const char *dir)\n{\n\tchar kallsyms_filename[PATH_MAX];\n\n\tscnprintf(kallsyms_filename, PATH_MAX, \"%s/kallsyms\", dir);\n\n\tif (symbol__restricted_filename(kallsyms_filename, \"/proc/kallsyms\"))\n\t\treturn -1;\n\n\tif (kallsyms__parse(kallsyms_filename, kci,\n\t\t\t    kcore_copy__process_kallsyms) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int kcore_copy__process_modules(void *arg,\n\t\t\t\t       const char *name __maybe_unused,\n\t\t\t\t       u64 start, u64 size __maybe_unused)\n{\n\tstruct kcore_copy_info *kci = arg;\n\n\tif (!kci->first_module || start < kci->first_module)\n\t\tkci->first_module = start;\n\n\treturn 0;\n}\n\nstatic int kcore_copy__parse_modules(struct kcore_copy_info *kci,\n\t\t\t\t     const char *dir)\n{\n\tchar modules_filename[PATH_MAX];\n\n\tscnprintf(modules_filename, PATH_MAX, \"%s/modules\", dir);\n\n\tif (symbol__restricted_filename(modules_filename, \"/proc/modules\"))\n\t\treturn -1;\n\n\tif (modules__parse(modules_filename, kci,\n\t\t\t   kcore_copy__process_modules) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int kcore_copy__map(struct kcore_copy_info *kci, u64 start, u64 end,\n\t\t\t   u64 pgoff, u64 s, u64 e)\n{\n\tu64 len, offset;\n\n\tif (s < start || s >= end)\n\t\treturn 0;\n\n\toffset = (s - start) + pgoff;\n\tlen = e < end ? e - s : end - s;\n\n\treturn kcore_copy_info__addnew(kci, s, len, offset) ? 0 : -1;\n}\n\nstatic int kcore_copy__read_map(u64 start, u64 len, u64 pgoff, void *data)\n{\n\tstruct kcore_copy_info *kci = data;\n\tu64 end = start + len;\n\tstruct sym_data *sdat;\n\n\tif (kcore_copy__map(kci, start, end, pgoff, kci->stext, kci->etext))\n\t\treturn -1;\n\n\tif (kcore_copy__map(kci, start, end, pgoff, kci->first_module,\n\t\t\t    kci->last_module_symbol))\n\t\treturn -1;\n\n\tlist_for_each_entry(sdat, &kci->syms, node) {\n\t\tu64 s = round_down(sdat->addr, page_size);\n\n\t\tif (kcore_copy__map(kci, start, end, pgoff, s, s + len))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int kcore_copy__read_maps(struct kcore_copy_info *kci, Elf *elf)\n{\n\tif (elf_read_maps(elf, true, kcore_copy__read_map, kci) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void kcore_copy__find_remaps(struct kcore_copy_info *kci)\n{\n\tstruct phdr_data *p, *k = NULL;\n\tu64 kend;\n\n\tif (!kci->stext)\n\t\treturn;\n\n\t \n\tkcore_copy__for_each_phdr(kci, p) {\n\t\tu64 pend = p->addr + p->len - 1;\n\n\t\tif (p->addr <= kci->stext && pend >= kci->stext) {\n\t\t\tk = p;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!k)\n\t\treturn;\n\n\tkend = k->offset + k->len;\n\n\t \n\tkcore_copy__for_each_phdr(kci, p) {\n\t\tu64 pend = p->offset + p->len;\n\n\t\tif (p == k)\n\t\t\tcontinue;\n\n\t\tif (p->offset >= k->offset && pend <= kend)\n\t\t\tp->remaps = k;\n\t}\n}\n\nstatic void kcore_copy__layout(struct kcore_copy_info *kci)\n{\n\tstruct phdr_data *p;\n\toff_t rel = 0;\n\n\tkcore_copy__find_remaps(kci);\n\n\tkcore_copy__for_each_phdr(kci, p) {\n\t\tif (!p->remaps) {\n\t\t\tp->rel = rel;\n\t\t\trel += p->len;\n\t\t}\n\t\tkci->phnum += 1;\n\t}\n\n\tkcore_copy__for_each_phdr(kci, p) {\n\t\tstruct phdr_data *k = p->remaps;\n\n\t\tif (k)\n\t\t\tp->rel = p->offset - k->offset + k->rel;\n\t}\n}\n\nstatic int kcore_copy__calc_maps(struct kcore_copy_info *kci, const char *dir,\n\t\t\t\t Elf *elf)\n{\n\tif (kcore_copy__parse_kallsyms(kci, dir))\n\t\treturn -1;\n\n\tif (kcore_copy__parse_modules(kci, dir))\n\t\treturn -1;\n\n\tif (kci->stext)\n\t\tkci->stext = round_down(kci->stext, page_size);\n\telse\n\t\tkci->stext = round_down(kci->first_symbol, page_size);\n\n\tif (kci->etext) {\n\t\tkci->etext = round_up(kci->etext, page_size);\n\t} else if (kci->last_symbol) {\n\t\tkci->etext = round_up(kci->last_symbol, page_size);\n\t\tkci->etext += page_size;\n\t}\n\n\tif (kci->first_module_symbol &&\n\t    (!kci->first_module || kci->first_module_symbol < kci->first_module))\n\t\tkci->first_module = kci->first_module_symbol;\n\n\tkci->first_module = round_down(kci->first_module, page_size);\n\n\tif (kci->last_module_symbol) {\n\t\tkci->last_module_symbol = round_up(kci->last_module_symbol,\n\t\t\t\t\t\t   page_size);\n\t\tkci->last_module_symbol += page_size;\n\t}\n\n\tif (!kci->stext || !kci->etext)\n\t\treturn -1;\n\n\tif (kci->first_module && !kci->last_module_symbol)\n\t\treturn -1;\n\n\tif (kcore_copy__read_maps(kci, elf))\n\t\treturn -1;\n\n\tkcore_copy__layout(kci);\n\n\treturn 0;\n}\n\nstatic int kcore_copy__copy_file(const char *from_dir, const char *to_dir,\n\t\t\t\t const char *name)\n{\n\tchar from_filename[PATH_MAX];\n\tchar to_filename[PATH_MAX];\n\n\tscnprintf(from_filename, PATH_MAX, \"%s/%s\", from_dir, name);\n\tscnprintf(to_filename, PATH_MAX, \"%s/%s\", to_dir, name);\n\n\treturn copyfile_mode(from_filename, to_filename, 0400);\n}\n\nstatic int kcore_copy__unlink(const char *dir, const char *name)\n{\n\tchar filename[PATH_MAX];\n\n\tscnprintf(filename, PATH_MAX, \"%s/%s\", dir, name);\n\n\treturn unlink(filename);\n}\n\nstatic int kcore_copy__compare_fds(int from, int to)\n{\n\tchar *buf_from;\n\tchar *buf_to;\n\tssize_t ret;\n\tsize_t len;\n\tint err = -1;\n\n\tbuf_from = malloc(page_size);\n\tbuf_to = malloc(page_size);\n\tif (!buf_from || !buf_to)\n\t\tgoto out;\n\n\twhile (1) {\n\t\t \n\t\tret = read(from, buf_from, page_size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tlen = ret;\n\n\t\tif (readn(to, buf_to, len) != (int)len)\n\t\t\tgoto out;\n\n\t\tif (memcmp(buf_from, buf_to, len))\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\tfree(buf_to);\n\tfree(buf_from);\n\treturn err;\n}\n\nstatic int kcore_copy__compare_files(const char *from_filename,\n\t\t\t\t     const char *to_filename)\n{\n\tint from, to, err = -1;\n\n\tfrom = open(from_filename, O_RDONLY);\n\tif (from < 0)\n\t\treturn -1;\n\n\tto = open(to_filename, O_RDONLY);\n\tif (to < 0)\n\t\tgoto out_close_from;\n\n\terr = kcore_copy__compare_fds(from, to);\n\n\tclose(to);\nout_close_from:\n\tclose(from);\n\treturn err;\n}\n\nstatic int kcore_copy__compare_file(const char *from_dir, const char *to_dir,\n\t\t\t\t    const char *name)\n{\n\tchar from_filename[PATH_MAX];\n\tchar to_filename[PATH_MAX];\n\n\tscnprintf(from_filename, PATH_MAX, \"%s/%s\", from_dir, name);\n\tscnprintf(to_filename, PATH_MAX, \"%s/%s\", to_dir, name);\n\n\treturn kcore_copy__compare_files(from_filename, to_filename);\n}\n\n \nint kcore_copy(const char *from_dir, const char *to_dir)\n{\n\tstruct kcore kcore;\n\tstruct kcore extract;\n\tint idx = 0, err = -1;\n\toff_t offset, sz;\n\tstruct kcore_copy_info kci = { .stext = 0, };\n\tchar kcore_filename[PATH_MAX];\n\tchar extract_filename[PATH_MAX];\n\tstruct phdr_data *p;\n\n\tINIT_LIST_HEAD(&kci.phdrs);\n\tINIT_LIST_HEAD(&kci.syms);\n\n\tif (kcore_copy__copy_file(from_dir, to_dir, \"kallsyms\"))\n\t\treturn -1;\n\n\tif (kcore_copy__copy_file(from_dir, to_dir, \"modules\"))\n\t\tgoto out_unlink_kallsyms;\n\n\tscnprintf(kcore_filename, PATH_MAX, \"%s/kcore\", from_dir);\n\tscnprintf(extract_filename, PATH_MAX, \"%s/kcore\", to_dir);\n\n\tif (kcore__open(&kcore, kcore_filename))\n\t\tgoto out_unlink_modules;\n\n\tif (kcore_copy__calc_maps(&kci, from_dir, kcore.elf))\n\t\tgoto out_kcore_close;\n\n\tif (kcore__init(&extract, extract_filename, kcore.elfclass, false))\n\t\tgoto out_kcore_close;\n\n\tif (kcore__copy_hdr(&kcore, &extract, kci.phnum))\n\t\tgoto out_extract_close;\n\n\toffset = gelf_fsize(extract.elf, ELF_T_EHDR, 1, EV_CURRENT) +\n\t\t gelf_fsize(extract.elf, ELF_T_PHDR, kci.phnum, EV_CURRENT);\n\toffset = round_up(offset, page_size);\n\n\tkcore_copy__for_each_phdr(&kci, p) {\n\t\toff_t offs = p->rel + offset;\n\n\t\tif (kcore__add_phdr(&extract, idx++, offs, p->addr, p->len))\n\t\t\tgoto out_extract_close;\n\t}\n\n\tsz = kcore__write(&extract);\n\tif (sz < 0 || sz > offset)\n\t\tgoto out_extract_close;\n\n\tkcore_copy__for_each_phdr(&kci, p) {\n\t\toff_t offs = p->rel + offset;\n\n\t\tif (p->remaps)\n\t\t\tcontinue;\n\t\tif (copy_bytes(kcore.fd, p->offset, extract.fd, offs, p->len))\n\t\t\tgoto out_extract_close;\n\t}\n\n\tif (kcore_copy__compare_file(from_dir, to_dir, \"kallsyms\"))\n\t\tgoto out_extract_close;\n\n\terr = 0;\n\nout_extract_close:\n\tkcore__close(&extract);\n\tif (err)\n\t\tunlink(extract_filename);\nout_kcore_close:\n\tkcore__close(&kcore);\nout_unlink_modules:\n\tif (err)\n\t\tkcore_copy__unlink(to_dir, \"modules\");\nout_unlink_kallsyms:\n\tif (err)\n\t\tkcore_copy__unlink(to_dir, \"kallsyms\");\n\n\tkcore_copy__free_phdrs(&kci);\n\tkcore_copy__free_syms(&kci);\n\n\treturn err;\n}\n\nint kcore_extract__create(struct kcore_extract *kce)\n{\n\tstruct kcore kcore;\n\tstruct kcore extract;\n\tsize_t count = 1;\n\tint idx = 0, err = -1;\n\toff_t offset = page_size, sz;\n\n\tif (kcore__open(&kcore, kce->kcore_filename))\n\t\treturn -1;\n\n\tstrcpy(kce->extract_filename, PERF_KCORE_EXTRACT);\n\tif (kcore__init(&extract, kce->extract_filename, kcore.elfclass, true))\n\t\tgoto out_kcore_close;\n\n\tif (kcore__copy_hdr(&kcore, &extract, count))\n\t\tgoto out_extract_close;\n\n\tif (kcore__add_phdr(&extract, idx, offset, kce->addr, kce->len))\n\t\tgoto out_extract_close;\n\n\tsz = kcore__write(&extract);\n\tif (sz < 0 || sz > offset)\n\t\tgoto out_extract_close;\n\n\tif (copy_bytes(kcore.fd, kce->offs, extract.fd, offset, kce->len))\n\t\tgoto out_extract_close;\n\n\terr = 0;\n\nout_extract_close:\n\tkcore__close(&extract);\n\tif (err)\n\t\tunlink(kce->extract_filename);\nout_kcore_close:\n\tkcore__close(&kcore);\n\n\treturn err;\n}\n\nvoid kcore_extract__delete(struct kcore_extract *kce)\n{\n\tunlink(kce->extract_filename);\n}\n\n#ifdef HAVE_GELF_GETNOTE_SUPPORT\n\nstatic void sdt_adjust_loc(struct sdt_note *tmp, GElf_Addr base_off)\n{\n\tif (!base_off)\n\t\treturn;\n\n\tif (tmp->bit32)\n\t\ttmp->addr.a32[SDT_NOTE_IDX_LOC] =\n\t\t\ttmp->addr.a32[SDT_NOTE_IDX_LOC] + base_off -\n\t\t\ttmp->addr.a32[SDT_NOTE_IDX_BASE];\n\telse\n\t\ttmp->addr.a64[SDT_NOTE_IDX_LOC] =\n\t\t\ttmp->addr.a64[SDT_NOTE_IDX_LOC] + base_off -\n\t\t\ttmp->addr.a64[SDT_NOTE_IDX_BASE];\n}\n\nstatic void sdt_adjust_refctr(struct sdt_note *tmp, GElf_Addr base_addr,\n\t\t\t      GElf_Addr base_off)\n{\n\tif (!base_off)\n\t\treturn;\n\n\tif (tmp->bit32 && tmp->addr.a32[SDT_NOTE_IDX_REFCTR])\n\t\ttmp->addr.a32[SDT_NOTE_IDX_REFCTR] -= (base_addr - base_off);\n\telse if (tmp->addr.a64[SDT_NOTE_IDX_REFCTR])\n\t\ttmp->addr.a64[SDT_NOTE_IDX_REFCTR] -= (base_addr - base_off);\n}\n\n \nstatic int populate_sdt_note(Elf **elf, const char *data, size_t len,\n\t\t\t     struct list_head *sdt_notes)\n{\n\tconst char *provider, *name, *args;\n\tstruct sdt_note *tmp = NULL;\n\tGElf_Ehdr ehdr;\n\tGElf_Shdr shdr;\n\tint ret = -EINVAL;\n\n\tunion {\n\t\tElf64_Addr a64[NR_ADDR];\n\t\tElf32_Addr a32[NR_ADDR];\n\t} buf;\n\n\tElf_Data dst = {\n\t\t.d_buf = &buf, .d_type = ELF_T_ADDR, .d_version = EV_CURRENT,\n\t\t.d_size = gelf_fsize((*elf), ELF_T_ADDR, NR_ADDR, EV_CURRENT),\n\t\t.d_off = 0, .d_align = 0\n\t};\n\tElf_Data src = {\n\t\t.d_buf = (void *) data, .d_type = ELF_T_ADDR,\n\t\t.d_version = EV_CURRENT, .d_size = dst.d_size, .d_off = 0,\n\t\t.d_align = 0\n\t};\n\n\ttmp = (struct sdt_note *)calloc(1, sizeof(struct sdt_note));\n\tif (!tmp) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tINIT_LIST_HEAD(&tmp->note_list);\n\n\tif (len < dst.d_size + 3)\n\t\tgoto out_free_note;\n\n\t \n\tif (gelf_xlatetom(*elf, &dst, &src,\n\t\t\t  elf_getident(*elf, NULL)[EI_DATA]) == NULL) {\n\t\tpr_err(\"gelf_xlatetom : %s\\n\", elf_errmsg(-1));\n\t\tgoto out_free_note;\n\t}\n\n\t \n\tprovider = data + dst.d_size;\n\n\tname = (const char *)memchr(provider, '\\0', data + len - provider);\n\tif (name++ == NULL)\n\t\tgoto out_free_note;\n\n\ttmp->provider = strdup(provider);\n\tif (!tmp->provider) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_note;\n\t}\n\ttmp->name = strdup(name);\n\tif (!tmp->name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_prov;\n\t}\n\n\targs = memchr(name, '\\0', data + len - name);\n\n\t \n\tif (args == NULL || data + len - args < 2 ||\n\t\targs[1] == ':' || args[1] == '\\0')\n\t\ttmp->args = NULL;\n\telse {\n\t\ttmp->args = strdup(++args);\n\t\tif (!tmp->args) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free_name;\n\t\t}\n\t}\n\n\tif (gelf_getclass(*elf) == ELFCLASS32) {\n\t\tmemcpy(&tmp->addr, &buf, 3 * sizeof(Elf32_Addr));\n\t\ttmp->bit32 = true;\n\t} else {\n\t\tmemcpy(&tmp->addr, &buf, 3 * sizeof(Elf64_Addr));\n\t\ttmp->bit32 = false;\n\t}\n\n\tif (!gelf_getehdr(*elf, &ehdr)) {\n\t\tpr_debug(\"%s : cannot get elf header.\\n\", __func__);\n\t\tret = -EBADF;\n\t\tgoto out_free_args;\n\t}\n\n\t \n\tif (elf_section_by_name(*elf, &ehdr, &shdr, SDT_BASE_SCN, NULL))\n\t\tsdt_adjust_loc(tmp, shdr.sh_offset);\n\n\t \n\tif (elf_section_by_name(*elf, &ehdr, &shdr, SDT_PROBES_SCN, NULL))\n\t\tsdt_adjust_refctr(tmp, shdr.sh_addr, shdr.sh_offset);\n\n\tlist_add_tail(&tmp->note_list, sdt_notes);\n\treturn 0;\n\nout_free_args:\n\tzfree(&tmp->args);\nout_free_name:\n\tzfree(&tmp->name);\nout_free_prov:\n\tzfree(&tmp->provider);\nout_free_note:\n\tfree(tmp);\nout_err:\n\treturn ret;\n}\n\n \nstatic int construct_sdt_notes_list(Elf *elf, struct list_head *sdt_notes)\n{\n\tGElf_Ehdr ehdr;\n\tElf_Scn *scn = NULL;\n\tElf_Data *data;\n\tGElf_Shdr shdr;\n\tsize_t shstrndx, next;\n\tGElf_Nhdr nhdr;\n\tsize_t name_off, desc_off, offset;\n\tint ret = 0;\n\n\tif (gelf_getehdr(elf, &ehdr) == NULL) {\n\t\tret = -EBADF;\n\t\tgoto out_ret;\n\t}\n\tif (elf_getshdrstrndx(elf, &shstrndx) != 0) {\n\t\tret = -EBADF;\n\t\tgoto out_ret;\n\t}\n\n\t \n\tscn = elf_section_by_name(elf, &ehdr, &shdr, SDT_NOTE_SCN, NULL);\n\tif (!scn) {\n\t\tret = -ENOENT;\n\t\tgoto out_ret;\n\t}\n\n\tif ((shdr.sh_type != SHT_NOTE) || (shdr.sh_flags & SHF_ALLOC)) {\n\t\tret = -ENOENT;\n\t\tgoto out_ret;\n\t}\n\n\tdata = elf_getdata(scn, NULL);\n\n\t \n\tfor (offset = 0; (next = gelf_getnote(data, offset, &nhdr, &name_off,\n\t\t\t\t\t      &desc_off)) > 0; offset = next) {\n\t\tif (nhdr.n_namesz == sizeof(SDT_NOTE_NAME) &&\n\t\t    !memcmp(data->d_buf + name_off, SDT_NOTE_NAME,\n\t\t\t    sizeof(SDT_NOTE_NAME))) {\n\t\t\t \n\t\t\tif (nhdr.n_type != SDT_NOTE_TYPE)\n\t\t\t\tgoto out_ret;\n\n\t\t\tret = populate_sdt_note(&elf, ((data->d_buf) + desc_off),\n\t\t\t\t\t\tnhdr.n_descsz, sdt_notes);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_ret;\n\t\t}\n\t}\n\tif (list_empty(sdt_notes))\n\t\tret = -ENOENT;\n\nout_ret:\n\treturn ret;\n}\n\n \nint get_sdt_note_list(struct list_head *head, const char *target)\n{\n\tElf *elf;\n\tint fd, ret;\n\n\tfd = open(target, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -EBADF;\n\n\telf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\n\tif (!elf) {\n\t\tret = -EBADF;\n\t\tgoto out_close;\n\t}\n\tret = construct_sdt_notes_list(elf, head);\n\telf_end(elf);\nout_close:\n\tclose(fd);\n\treturn ret;\n}\n\n \nint cleanup_sdt_note_list(struct list_head *sdt_notes)\n{\n\tstruct sdt_note *tmp, *pos;\n\tint nr_free = 0;\n\n\tlist_for_each_entry_safe(pos, tmp, sdt_notes, note_list) {\n\t\tlist_del_init(&pos->note_list);\n\t\tzfree(&pos->args);\n\t\tzfree(&pos->name);\n\t\tzfree(&pos->provider);\n\t\tfree(pos);\n\t\tnr_free++;\n\t}\n\treturn nr_free;\n}\n\n \nint sdt_notes__get_count(struct list_head *start)\n{\n\tstruct sdt_note *sdt_ptr;\n\tint count = 0;\n\n\tlist_for_each_entry(sdt_ptr, start, note_list)\n\t\tcount++;\n\treturn count;\n}\n#endif\n\nvoid symbol__elf_init(void)\n{\n\telf_version(EV_CURRENT);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}