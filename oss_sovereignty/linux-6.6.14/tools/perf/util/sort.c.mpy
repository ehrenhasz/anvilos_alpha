{
  "module_name": "sort.c",
  "hash_id": "0e319fa47571984e89037d2508ad1ca734862e267927096577805d6af6b9e8bc",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/sort.c",
  "human_readable_source": "\n#include <errno.h>\n#include <inttypes.h>\n#include <regex.h>\n#include <stdlib.h>\n#include <linux/mman.h>\n#include <linux/time64.h>\n#include \"debug.h\"\n#include \"dso.h\"\n#include \"sort.h\"\n#include \"hist.h\"\n#include \"cacheline.h\"\n#include \"comm.h\"\n#include \"map.h\"\n#include \"maps.h\"\n#include \"symbol.h\"\n#include \"map_symbol.h\"\n#include \"branch.h\"\n#include \"thread.h\"\n#include \"evsel.h\"\n#include \"evlist.h\"\n#include \"srcline.h\"\n#include \"strlist.h\"\n#include \"strbuf.h\"\n#include \"mem-events.h\"\n#include \"annotate.h\"\n#include \"event.h\"\n#include \"time-utils.h\"\n#include \"cgroup.h\"\n#include \"machine.h\"\n#include \"trace-event.h\"\n#include <linux/kernel.h>\n#include <linux/string.h>\n\n#ifdef HAVE_LIBTRACEEVENT\n#include <traceevent/event-parse.h>\n#endif\n\nregex_t\t\tparent_regex;\nconst char\tdefault_parent_pattern[] = \"^sys_|^do_page_fault\";\nconst char\t*parent_pattern = default_parent_pattern;\nconst char\t*default_sort_order = \"comm,dso,symbol\";\nconst char\tdefault_branch_sort_order[] = \"comm,dso_from,symbol_from,symbol_to,cycles\";\nconst char\tdefault_mem_sort_order[] = \"local_weight,mem,sym,dso,symbol_daddr,dso_daddr,snoop,tlb,locked,blocked,local_ins_lat,local_p_stage_cyc\";\nconst char\tdefault_top_sort_order[] = \"dso,symbol\";\nconst char\tdefault_diff_sort_order[] = \"dso,symbol\";\nconst char\tdefault_tracepoint_sort_order[] = \"trace\";\nconst char\t*sort_order;\nconst char\t*field_order;\nregex_t\t\tignore_callees_regex;\nint\t\thave_ignore_callees = 0;\nenum sort_mode\tsort__mode = SORT_MODE__NORMAL;\nstatic const char *const dynamic_headers[] = {\"local_ins_lat\", \"ins_lat\", \"local_p_stage_cyc\", \"p_stage_cyc\"};\nstatic const char *const arch_specific_sort_keys[] = {\"local_p_stage_cyc\", \"p_stage_cyc\"};\n\n \nbool chk_double_cl;\n\n \nstatic int repsep_snprintf(char *bf, size_t size, const char *fmt, ...)\n{\n\tint n;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tn = vsnprintf(bf, size, fmt, ap);\n\tif (symbol_conf.field_sep && n > 0) {\n\t\tchar *sep = bf;\n\n\t\twhile (1) {\n\t\t\tsep = strchr(sep, *symbol_conf.field_sep);\n\t\t\tif (sep == NULL)\n\t\t\t\tbreak;\n\t\t\t*sep = '.';\n\t\t}\n\t}\n\tva_end(ap);\n\n\tif (n >= (int)size)\n\t\treturn size - 1;\n\treturn n;\n}\n\nstatic int64_t cmp_null(const void *l, const void *r)\n{\n\tif (!l && !r)\n\t\treturn 0;\n\telse if (!l)\n\t\treturn -1;\n\telse\n\t\treturn 1;\n}\n\n \n\nstatic int64_t\nsort__thread_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn thread__tid(right->thread) - thread__tid(left->thread);\n}\n\nstatic int hist_entry__thread_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t       size_t size, unsigned int width)\n{\n\tconst char *comm = thread__comm_str(he->thread);\n\n\twidth = max(7U, width) - 8;\n\treturn repsep_snprintf(bf, size, \"%7d:%-*.*s\", thread__tid(he->thread),\n\t\t\t       width, width, comm ?: \"\");\n}\n\nstatic int hist_entry__thread_filter(struct hist_entry *he, int type, const void *arg)\n{\n\tconst struct thread *th = arg;\n\n\tif (type != HIST_FILTER__THREAD)\n\t\treturn -1;\n\n\treturn th && RC_CHK_ACCESS(he->thread) != RC_CHK_ACCESS(th);\n}\n\nstruct sort_entry sort_thread = {\n\t.se_header\t= \"    Pid:Command\",\n\t.se_cmp\t\t= sort__thread_cmp,\n\t.se_snprintf\t= hist_entry__thread_snprintf,\n\t.se_filter\t= hist_entry__thread_filter,\n\t.se_width_idx\t= HISTC_THREAD,\n};\n\n \n\nstatic int64_t\nsort__simd_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tif (left->simd_flags.arch != right->simd_flags.arch)\n\t\treturn (int64_t) left->simd_flags.arch - right->simd_flags.arch;\n\n\treturn (int64_t) left->simd_flags.pred - right->simd_flags.pred;\n}\n\nstatic const char *hist_entry__get_simd_name(struct simd_flags *simd_flags)\n{\n\tu64 arch = simd_flags->arch;\n\n\tif (arch & SIMD_OP_FLAGS_ARCH_SVE)\n\t\treturn \"SVE\";\n\telse\n\t\treturn \"n/a\";\n}\n\nstatic int hist_entry__simd_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t     size_t size, unsigned int width __maybe_unused)\n{\n\tconst char *name;\n\n\tif (!he->simd_flags.arch)\n\t\treturn repsep_snprintf(bf, size, \"\");\n\n\tname = hist_entry__get_simd_name(&he->simd_flags);\n\n\tif (he->simd_flags.pred & SIMD_OP_FLAGS_PRED_EMPTY)\n\t\treturn repsep_snprintf(bf, size, \"[e] %s\", name);\n\telse if (he->simd_flags.pred & SIMD_OP_FLAGS_PRED_PARTIAL)\n\t\treturn repsep_snprintf(bf, size, \"[p] %s\", name);\n\n\treturn repsep_snprintf(bf, size, \"[.] %s\", name);\n}\n\nstruct sort_entry sort_simd = {\n\t.se_header\t= \"Simd   \",\n\t.se_cmp\t\t= sort__simd_cmp,\n\t.se_snprintf\t= hist_entry__simd_snprintf,\n\t.se_width_idx\t= HISTC_SIMD,\n};\n\n \n\n \nstatic int64_t\nsort__comm_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn strcmp(comm__str(right->comm), comm__str(left->comm));\n}\n\nstatic int64_t\nsort__comm_collapse(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn strcmp(comm__str(right->comm), comm__str(left->comm));\n}\n\nstatic int64_t\nsort__comm_sort(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn strcmp(comm__str(right->comm), comm__str(left->comm));\n}\n\nstatic int hist_entry__comm_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t     size_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width, comm__str(he->comm));\n}\n\nstruct sort_entry sort_comm = {\n\t.se_header\t= \"Command\",\n\t.se_cmp\t\t= sort__comm_cmp,\n\t.se_collapse\t= sort__comm_collapse,\n\t.se_sort\t= sort__comm_sort,\n\t.se_snprintf\t= hist_entry__comm_snprintf,\n\t.se_filter\t= hist_entry__thread_filter,\n\t.se_width_idx\t= HISTC_COMM,\n};\n\n \n\nstatic int64_t _sort__dso_cmp(struct map *map_l, struct map *map_r)\n{\n\tstruct dso *dso_l = map_l ? map__dso(map_l) : NULL;\n\tstruct dso *dso_r = map_r ? map__dso(map_r) : NULL;\n\tconst char *dso_name_l, *dso_name_r;\n\n\tif (!dso_l || !dso_r)\n\t\treturn cmp_null(dso_r, dso_l);\n\n\tif (verbose > 0) {\n\t\tdso_name_l = dso_l->long_name;\n\t\tdso_name_r = dso_r->long_name;\n\t} else {\n\t\tdso_name_l = dso_l->short_name;\n\t\tdso_name_r = dso_r->short_name;\n\t}\n\n\treturn strcmp(dso_name_l, dso_name_r);\n}\n\nstatic int64_t\nsort__dso_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn _sort__dso_cmp(right->ms.map, left->ms.map);\n}\n\nstatic int _hist_entry__dso_snprintf(struct map *map, char *bf,\n\t\t\t\t     size_t size, unsigned int width)\n{\n\tconst struct dso *dso = map ? map__dso(map) : NULL;\n\tconst char *dso_name = \"[unknown]\";\n\n\tif (dso)\n\t\tdso_name = verbose > 0 ? dso->long_name : dso->short_name;\n\n\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width, dso_name);\n}\n\nstatic int hist_entry__dso_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\treturn _hist_entry__dso_snprintf(he->ms.map, bf, size, width);\n}\n\nstatic int hist_entry__dso_filter(struct hist_entry *he, int type, const void *arg)\n{\n\tconst struct dso *dso = arg;\n\n\tif (type != HIST_FILTER__DSO)\n\t\treturn -1;\n\n\treturn dso && (!he->ms.map || map__dso(he->ms.map) != dso);\n}\n\nstruct sort_entry sort_dso = {\n\t.se_header\t= \"Shared Object\",\n\t.se_cmp\t\t= sort__dso_cmp,\n\t.se_snprintf\t= hist_entry__dso_snprintf,\n\t.se_filter\t= hist_entry__dso_filter,\n\t.se_width_idx\t= HISTC_DSO,\n};\n\n \n\nstatic int64_t _sort__addr_cmp(u64 left_ip, u64 right_ip)\n{\n\treturn (int64_t)(right_ip - left_ip);\n}\n\nint64_t _sort__sym_cmp(struct symbol *sym_l, struct symbol *sym_r)\n{\n\tif (!sym_l || !sym_r)\n\t\treturn cmp_null(sym_l, sym_r);\n\n\tif (sym_l == sym_r)\n\t\treturn 0;\n\n\tif (sym_l->inlined || sym_r->inlined) {\n\t\tint ret = strcmp(sym_l->name, sym_r->name);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif ((sym_l->start <= sym_r->end) && (sym_l->end >= sym_r->start))\n\t\t\treturn 0;\n\t}\n\n\tif (sym_l->start != sym_r->start)\n\t\treturn (int64_t)(sym_r->start - sym_l->start);\n\n\treturn (int64_t)(sym_r->end - sym_l->end);\n}\n\nstatic int64_t\nsort__sym_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tint64_t ret;\n\n\tif (!left->ms.sym && !right->ms.sym)\n\t\treturn _sort__addr_cmp(left->ip, right->ip);\n\n\t \n\tif (!hists__has(left->hists, dso) || hists__has(right->hists, dso)) {\n\t\tret = sort__dso_cmp(left, right);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treturn _sort__sym_cmp(left->ms.sym, right->ms.sym);\n}\n\nstatic int64_t\nsort__sym_sort(struct hist_entry *left, struct hist_entry *right)\n{\n\tif (!left->ms.sym || !right->ms.sym)\n\t\treturn cmp_null(left->ms.sym, right->ms.sym);\n\n\treturn strcmp(right->ms.sym->name, left->ms.sym->name);\n}\n\nstatic int _hist_entry__sym_snprintf(struct map_symbol *ms,\n\t\t\t\t     u64 ip, char level, char *bf, size_t size,\n\t\t\t\t     unsigned int width)\n{\n\tstruct symbol *sym = ms->sym;\n\tstruct map *map = ms->map;\n\tsize_t ret = 0;\n\n\tif (verbose > 0) {\n\t\tstruct dso *dso = map ? map__dso(map) : NULL;\n\t\tchar o = dso ? dso__symtab_origin(dso) : '!';\n\t\tu64 rip = ip;\n\n\t\tif (dso && dso->kernel && dso->adjust_symbols)\n\t\t\trip = map__unmap_ip(map, ip);\n\n\t\tret += repsep_snprintf(bf, size, \"%-#*llx %c \",\n\t\t\t\t       BITS_PER_LONG / 4 + 2, rip, o);\n\t}\n\n\tret += repsep_snprintf(bf + ret, size - ret, \"[%c] \", level);\n\tif (sym && map) {\n\t\tif (sym->type == STT_OBJECT) {\n\t\t\tret += repsep_snprintf(bf + ret, size - ret, \"%s\", sym->name);\n\t\t\tret += repsep_snprintf(bf + ret, size - ret, \"+0x%llx\",\n\t\t\t\t\tip - map__unmap_ip(map, sym->start));\n\t\t} else {\n\t\t\tret += repsep_snprintf(bf + ret, size - ret, \"%.*s\",\n\t\t\t\t\t       width - ret,\n\t\t\t\t\t       sym->name);\n\t\t\tif (sym->inlined)\n\t\t\t\tret += repsep_snprintf(bf + ret, size - ret,\n\t\t\t\t\t\t       \" (inlined)\");\n\t\t}\n\t} else {\n\t\tsize_t len = BITS_PER_LONG / 4;\n\t\tret += repsep_snprintf(bf + ret, size - ret, \"%-#.*llx\",\n\t\t\t\t       len, ip);\n\t}\n\n\treturn ret;\n}\n\nint hist_entry__sym_snprintf(struct hist_entry *he, char *bf, size_t size, unsigned int width)\n{\n\treturn _hist_entry__sym_snprintf(&he->ms, he->ip,\n\t\t\t\t\t he->level, bf, size, width);\n}\n\nstatic int hist_entry__sym_filter(struct hist_entry *he, int type, const void *arg)\n{\n\tconst char *sym = arg;\n\n\tif (type != HIST_FILTER__SYMBOL)\n\t\treturn -1;\n\n\treturn sym && (!he->ms.sym || !strstr(he->ms.sym->name, sym));\n}\n\nstruct sort_entry sort_sym = {\n\t.se_header\t= \"Symbol\",\n\t.se_cmp\t\t= sort__sym_cmp,\n\t.se_sort\t= sort__sym_sort,\n\t.se_snprintf\t= hist_entry__sym_snprintf,\n\t.se_filter\t= hist_entry__sym_filter,\n\t.se_width_idx\t= HISTC_SYMBOL,\n};\n\n \n\nchar *hist_entry__srcline(struct hist_entry *he)\n{\n\treturn map__srcline(he->ms.map, he->ip, he->ms.sym);\n}\n\nstatic int64_t\nsort__srcline_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tint64_t ret;\n\n\tret = _sort__addr_cmp(left->ip, right->ip);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sort__dso_cmp(left, right);\n}\n\nstatic int64_t\nsort__srcline_collapse(struct hist_entry *left, struct hist_entry *right)\n{\n\tif (!left->srcline)\n\t\tleft->srcline = hist_entry__srcline(left);\n\tif (!right->srcline)\n\t\tright->srcline = hist_entry__srcline(right);\n\n\treturn strcmp(right->srcline, left->srcline);\n}\n\nstatic int64_t\nsort__srcline_sort(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn sort__srcline_collapse(left, right);\n}\n\nstatic void\nsort__srcline_init(struct hist_entry *he)\n{\n\tif (!he->srcline)\n\t\the->srcline = hist_entry__srcline(he);\n}\n\nstatic int hist_entry__srcline_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\tsize_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-.*s\", width, he->srcline);\n}\n\nstruct sort_entry sort_srcline = {\n\t.se_header\t= \"Source:Line\",\n\t.se_cmp\t\t= sort__srcline_cmp,\n\t.se_collapse\t= sort__srcline_collapse,\n\t.se_sort\t= sort__srcline_sort,\n\t.se_init\t= sort__srcline_init,\n\t.se_snprintf\t= hist_entry__srcline_snprintf,\n\t.se_width_idx\t= HISTC_SRCLINE,\n};\n\n \n\nstatic char *addr_map_symbol__srcline(struct addr_map_symbol *ams)\n{\n\treturn map__srcline(ams->ms.map, ams->al_addr, ams->ms.sym);\n}\n\nstatic int64_t\nsort__srcline_from_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn left->branch_info->from.addr - right->branch_info->from.addr;\n}\n\nstatic int64_t\nsort__srcline_from_collapse(struct hist_entry *left, struct hist_entry *right)\n{\n\tif (!left->branch_info->srcline_from)\n\t\tleft->branch_info->srcline_from = addr_map_symbol__srcline(&left->branch_info->from);\n\n\tif (!right->branch_info->srcline_from)\n\t\tright->branch_info->srcline_from = addr_map_symbol__srcline(&right->branch_info->from);\n\n\treturn strcmp(right->branch_info->srcline_from, left->branch_info->srcline_from);\n}\n\nstatic int64_t\nsort__srcline_from_sort(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn sort__srcline_from_collapse(left, right);\n}\n\nstatic void sort__srcline_from_init(struct hist_entry *he)\n{\n\tif (!he->branch_info->srcline_from)\n\t\the->branch_info->srcline_from = addr_map_symbol__srcline(&he->branch_info->from);\n}\n\nstatic int hist_entry__srcline_from_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\tsize_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width, he->branch_info->srcline_from);\n}\n\nstruct sort_entry sort_srcline_from = {\n\t.se_header\t= \"From Source:Line\",\n\t.se_cmp\t\t= sort__srcline_from_cmp,\n\t.se_collapse\t= sort__srcline_from_collapse,\n\t.se_sort\t= sort__srcline_from_sort,\n\t.se_init\t= sort__srcline_from_init,\n\t.se_snprintf\t= hist_entry__srcline_from_snprintf,\n\t.se_width_idx\t= HISTC_SRCLINE_FROM,\n};\n\n \n\nstatic int64_t\nsort__srcline_to_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn left->branch_info->to.addr - right->branch_info->to.addr;\n}\n\nstatic int64_t\nsort__srcline_to_collapse(struct hist_entry *left, struct hist_entry *right)\n{\n\tif (!left->branch_info->srcline_to)\n\t\tleft->branch_info->srcline_to = addr_map_symbol__srcline(&left->branch_info->to);\n\n\tif (!right->branch_info->srcline_to)\n\t\tright->branch_info->srcline_to = addr_map_symbol__srcline(&right->branch_info->to);\n\n\treturn strcmp(right->branch_info->srcline_to, left->branch_info->srcline_to);\n}\n\nstatic int64_t\nsort__srcline_to_sort(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn sort__srcline_to_collapse(left, right);\n}\n\nstatic void sort__srcline_to_init(struct hist_entry *he)\n{\n\tif (!he->branch_info->srcline_to)\n\t\the->branch_info->srcline_to = addr_map_symbol__srcline(&he->branch_info->to);\n}\n\nstatic int hist_entry__srcline_to_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\tsize_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width, he->branch_info->srcline_to);\n}\n\nstruct sort_entry sort_srcline_to = {\n\t.se_header\t= \"To Source:Line\",\n\t.se_cmp\t\t= sort__srcline_to_cmp,\n\t.se_collapse\t= sort__srcline_to_collapse,\n\t.se_sort\t= sort__srcline_to_sort,\n\t.se_init\t= sort__srcline_to_init,\n\t.se_snprintf\t= hist_entry__srcline_to_snprintf,\n\t.se_width_idx\t= HISTC_SRCLINE_TO,\n};\n\nstatic int hist_entry__sym_ipc_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\tsize_t size, unsigned int width)\n{\n\n\tstruct symbol *sym = he->ms.sym;\n\tstruct annotation *notes;\n\tdouble ipc = 0.0, coverage = 0.0;\n\tchar tmp[64];\n\n\tif (!sym)\n\t\treturn repsep_snprintf(bf, size, \"%-*s\", width, \"-\");\n\n\tnotes = symbol__annotation(sym);\n\n\tif (notes->hit_cycles)\n\t\tipc = notes->hit_insn / ((double)notes->hit_cycles);\n\n\tif (notes->total_insn) {\n\t\tcoverage = notes->cover_insn * 100.0 /\n\t\t\t((double)notes->total_insn);\n\t}\n\n\tsnprintf(tmp, sizeof(tmp), \"%-5.2f [%5.1f%%]\", ipc, coverage);\n\treturn repsep_snprintf(bf, size, \"%-*s\", width, tmp);\n}\n\nstruct sort_entry sort_sym_ipc = {\n\t.se_header\t= \"IPC   [IPC Coverage]\",\n\t.se_cmp\t\t= sort__sym_cmp,\n\t.se_snprintf\t= hist_entry__sym_ipc_snprintf,\n\t.se_width_idx\t= HISTC_SYMBOL_IPC,\n};\n\nstatic int hist_entry__sym_ipc_null_snprintf(struct hist_entry *he\n\t\t\t\t\t     __maybe_unused,\n\t\t\t\t\t     char *bf, size_t size,\n\t\t\t\t\t     unsigned int width)\n{\n\tchar tmp[64];\n\n\tsnprintf(tmp, sizeof(tmp), \"%-5s %2s\", \"-\", \"-\");\n\treturn repsep_snprintf(bf, size, \"%-*s\", width, tmp);\n}\n\nstruct sort_entry sort_sym_ipc_null = {\n\t.se_header\t= \"IPC   [IPC Coverage]\",\n\t.se_cmp\t\t= sort__sym_cmp,\n\t.se_snprintf\t= hist_entry__sym_ipc_null_snprintf,\n\t.se_width_idx\t= HISTC_SYMBOL_IPC,\n};\n\n \n\nstatic char no_srcfile[1];\n\nstatic char *hist_entry__get_srcfile(struct hist_entry *e)\n{\n\tchar *sf, *p;\n\tstruct map *map = e->ms.map;\n\n\tif (!map)\n\t\treturn no_srcfile;\n\n\tsf = __get_srcline(map__dso(map), map__rip_2objdump(map, e->ip),\n\t\t\t e->ms.sym, false, true, true, e->ip);\n\tif (sf == SRCLINE_UNKNOWN)\n\t\treturn no_srcfile;\n\tp = strchr(sf, ':');\n\tif (p && *sf) {\n\t\t*p = 0;\n\t\treturn sf;\n\t}\n\tfree(sf);\n\treturn no_srcfile;\n}\n\nstatic int64_t\nsort__srcfile_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn sort__srcline_cmp(left, right);\n}\n\nstatic int64_t\nsort__srcfile_collapse(struct hist_entry *left, struct hist_entry *right)\n{\n\tif (!left->srcfile)\n\t\tleft->srcfile = hist_entry__get_srcfile(left);\n\tif (!right->srcfile)\n\t\tright->srcfile = hist_entry__get_srcfile(right);\n\n\treturn strcmp(right->srcfile, left->srcfile);\n}\n\nstatic int64_t\nsort__srcfile_sort(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn sort__srcfile_collapse(left, right);\n}\n\nstatic void sort__srcfile_init(struct hist_entry *he)\n{\n\tif (!he->srcfile)\n\t\the->srcfile = hist_entry__get_srcfile(he);\n}\n\nstatic int hist_entry__srcfile_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\tsize_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-.*s\", width, he->srcfile);\n}\n\nstruct sort_entry sort_srcfile = {\n\t.se_header\t= \"Source File\",\n\t.se_cmp\t\t= sort__srcfile_cmp,\n\t.se_collapse\t= sort__srcfile_collapse,\n\t.se_sort\t= sort__srcfile_sort,\n\t.se_init\t= sort__srcfile_init,\n\t.se_snprintf\t= hist_entry__srcfile_snprintf,\n\t.se_width_idx\t= HISTC_SRCFILE,\n};\n\n \n\nstatic int64_t\nsort__parent_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct symbol *sym_l = left->parent;\n\tstruct symbol *sym_r = right->parent;\n\n\tif (!sym_l || !sym_r)\n\t\treturn cmp_null(sym_l, sym_r);\n\n\treturn strcmp(sym_r->name, sym_l->name);\n}\n\nstatic int hist_entry__parent_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t       size_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width,\n\t\t\t      he->parent ? he->parent->name : \"[other]\");\n}\n\nstruct sort_entry sort_parent = {\n\t.se_header\t= \"Parent symbol\",\n\t.se_cmp\t\t= sort__parent_cmp,\n\t.se_snprintf\t= hist_entry__parent_snprintf,\n\t.se_width_idx\t= HISTC_PARENT,\n};\n\n \n\nstatic int64_t\nsort__cpu_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn right->cpu - left->cpu;\n}\n\nstatic int hist_entry__cpu_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%*.*d\", width, width, he->cpu);\n}\n\nstruct sort_entry sort_cpu = {\n\t.se_header      = \"CPU\",\n\t.se_cmp\t        = sort__cpu_cmp,\n\t.se_snprintf    = hist_entry__cpu_snprintf,\n\t.se_width_idx\t= HISTC_CPU,\n};\n\n \n\nstatic int64_t _sort__cgroup_dev_cmp(u64 left_dev, u64 right_dev)\n{\n\treturn (int64_t)(right_dev - left_dev);\n}\n\nstatic int64_t _sort__cgroup_inode_cmp(u64 left_ino, u64 right_ino)\n{\n\treturn (int64_t)(right_ino - left_ino);\n}\n\nstatic int64_t\nsort__cgroup_id_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tint64_t ret;\n\n\tret = _sort__cgroup_dev_cmp(right->cgroup_id.dev, left->cgroup_id.dev);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn _sort__cgroup_inode_cmp(right->cgroup_id.ino,\n\t\t\t\t       left->cgroup_id.ino);\n}\n\nstatic int hist_entry__cgroup_id_snprintf(struct hist_entry *he,\n\t\t\t\t\t  char *bf, size_t size,\n\t\t\t\t\t  unsigned int width __maybe_unused)\n{\n\treturn repsep_snprintf(bf, size, \"%lu/0x%lx\", he->cgroup_id.dev,\n\t\t\t       he->cgroup_id.ino);\n}\n\nstruct sort_entry sort_cgroup_id = {\n\t.se_header      = \"cgroup id (dev/inode)\",\n\t.se_cmp\t        = sort__cgroup_id_cmp,\n\t.se_snprintf    = hist_entry__cgroup_id_snprintf,\n\t.se_width_idx\t= HISTC_CGROUP_ID,\n};\n\n \n\nstatic int64_t\nsort__cgroup_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn right->cgroup - left->cgroup;\n}\n\nstatic int hist_entry__cgroup_snprintf(struct hist_entry *he,\n\t\t\t\t       char *bf, size_t size,\n\t\t\t\t       unsigned int width __maybe_unused)\n{\n\tconst char *cgrp_name = \"N/A\";\n\n\tif (he->cgroup) {\n\t\tstruct cgroup *cgrp = cgroup__find(maps__machine(he->ms.maps)->env,\n\t\t\t\t\t\t   he->cgroup);\n\t\tif (cgrp != NULL)\n\t\t\tcgrp_name = cgrp->name;\n\t\telse\n\t\t\tcgrp_name = \"unknown\";\n\t}\n\n\treturn repsep_snprintf(bf, size, \"%s\", cgrp_name);\n}\n\nstruct sort_entry sort_cgroup = {\n\t.se_header      = \"Cgroup\",\n\t.se_cmp\t        = sort__cgroup_cmp,\n\t.se_snprintf    = hist_entry__cgroup_snprintf,\n\t.se_width_idx\t= HISTC_CGROUP,\n};\n\n \n\nstatic int64_t\nsort__socket_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn right->socket - left->socket;\n}\n\nstatic int hist_entry__socket_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%*.*d\", width, width-3, he->socket);\n}\n\nstatic int hist_entry__socket_filter(struct hist_entry *he, int type, const void *arg)\n{\n\tint sk = *(const int *)arg;\n\n\tif (type != HIST_FILTER__SOCKET)\n\t\treturn -1;\n\n\treturn sk >= 0 && he->socket != sk;\n}\n\nstruct sort_entry sort_socket = {\n\t.se_header      = \"Socket\",\n\t.se_cmp\t        = sort__socket_cmp,\n\t.se_snprintf    = hist_entry__socket_snprintf,\n\t.se_filter      = hist_entry__socket_filter,\n\t.se_width_idx\t= HISTC_SOCKET,\n};\n\n \n\nstatic int64_t\nsort__time_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn right->time - left->time;\n}\n\nstatic int hist_entry__time_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tchar he_time[32];\n\n\tif (symbol_conf.nanosecs)\n\t\ttimestamp__scnprintf_nsec(he->time, he_time,\n\t\t\t\t\t  sizeof(he_time));\n\telse\n\t\ttimestamp__scnprintf_usec(he->time, he_time,\n\t\t\t\t\t  sizeof(he_time));\n\n\treturn repsep_snprintf(bf, size, \"%-.*s\", width, he_time);\n}\n\nstruct sort_entry sort_time = {\n\t.se_header      = \"Time\",\n\t.se_cmp\t        = sort__time_cmp,\n\t.se_snprintf    = hist_entry__time_snprintf,\n\t.se_width_idx\t= HISTC_TIME,\n};\n\n \n\n#ifdef HAVE_LIBTRACEEVENT\nstatic char *get_trace_output(struct hist_entry *he)\n{\n\tstruct trace_seq seq;\n\tstruct evsel *evsel;\n\tstruct tep_record rec = {\n\t\t.data = he->raw_data,\n\t\t.size = he->raw_size,\n\t};\n\n\tevsel = hists_to_evsel(he->hists);\n\n\ttrace_seq_init(&seq);\n\tif (symbol_conf.raw_trace) {\n\t\ttep_print_fields(&seq, he->raw_data, he->raw_size,\n\t\t\t\t evsel->tp_format);\n\t} else {\n\t\ttep_print_event(evsel->tp_format->tep,\n\t\t\t\t&seq, &rec, \"%s\", TEP_PRINT_INFO);\n\t}\n\t \n\treturn realloc(seq.buffer, seq.len + 1);\n}\n\nstatic int64_t\nsort__trace_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct evsel *evsel;\n\n\tevsel = hists_to_evsel(left->hists);\n\tif (evsel->core.attr.type != PERF_TYPE_TRACEPOINT)\n\t\treturn 0;\n\n\tif (left->trace_output == NULL)\n\t\tleft->trace_output = get_trace_output(left);\n\tif (right->trace_output == NULL)\n\t\tright->trace_output = get_trace_output(right);\n\n\treturn strcmp(right->trace_output, left->trace_output);\n}\n\nstatic int hist_entry__trace_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tstruct evsel *evsel;\n\n\tevsel = hists_to_evsel(he->hists);\n\tif (evsel->core.attr.type != PERF_TYPE_TRACEPOINT)\n\t\treturn scnprintf(bf, size, \"%-.*s\", width, \"N/A\");\n\n\tif (he->trace_output == NULL)\n\t\the->trace_output = get_trace_output(he);\n\treturn repsep_snprintf(bf, size, \"%-.*s\", width, he->trace_output);\n}\n\nstruct sort_entry sort_trace = {\n\t.se_header      = \"Trace output\",\n\t.se_cmp\t        = sort__trace_cmp,\n\t.se_snprintf    = hist_entry__trace_snprintf,\n\t.se_width_idx\t= HISTC_TRACE,\n};\n#endif  \n\n \n\nstatic int64_t\nsort__dso_from_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tif (!left->branch_info || !right->branch_info)\n\t\treturn cmp_null(left->branch_info, right->branch_info);\n\n\treturn _sort__dso_cmp(left->branch_info->from.ms.map,\n\t\t\t      right->branch_info->from.ms.map);\n}\n\nstatic int hist_entry__dso_from_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tif (he->branch_info)\n\t\treturn _hist_entry__dso_snprintf(he->branch_info->from.ms.map,\n\t\t\t\t\t\t bf, size, width);\n\telse\n\t\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width, \"N/A\");\n}\n\nstatic int hist_entry__dso_from_filter(struct hist_entry *he, int type,\n\t\t\t\t       const void *arg)\n{\n\tconst struct dso *dso = arg;\n\n\tif (type != HIST_FILTER__DSO)\n\t\treturn -1;\n\n\treturn dso && (!he->branch_info || !he->branch_info->from.ms.map ||\n\t\tmap__dso(he->branch_info->from.ms.map) != dso);\n}\n\nstatic int64_t\nsort__dso_to_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tif (!left->branch_info || !right->branch_info)\n\t\treturn cmp_null(left->branch_info, right->branch_info);\n\n\treturn _sort__dso_cmp(left->branch_info->to.ms.map,\n\t\t\t      right->branch_info->to.ms.map);\n}\n\nstatic int hist_entry__dso_to_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t       size_t size, unsigned int width)\n{\n\tif (he->branch_info)\n\t\treturn _hist_entry__dso_snprintf(he->branch_info->to.ms.map,\n\t\t\t\t\t\t bf, size, width);\n\telse\n\t\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width, \"N/A\");\n}\n\nstatic int hist_entry__dso_to_filter(struct hist_entry *he, int type,\n\t\t\t\t     const void *arg)\n{\n\tconst struct dso *dso = arg;\n\n\tif (type != HIST_FILTER__DSO)\n\t\treturn -1;\n\n\treturn dso && (!he->branch_info || !he->branch_info->to.ms.map ||\n\t\tmap__dso(he->branch_info->to.ms.map) != dso);\n}\n\nstatic int64_t\nsort__sym_from_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct addr_map_symbol *from_l, *from_r;\n\n\tif (!left->branch_info || !right->branch_info)\n\t\treturn cmp_null(left->branch_info, right->branch_info);\n\n\tfrom_l = &left->branch_info->from;\n\tfrom_r = &right->branch_info->from;\n\n\tif (!from_l->ms.sym && !from_r->ms.sym)\n\t\treturn _sort__addr_cmp(from_l->addr, from_r->addr);\n\n\treturn _sort__sym_cmp(from_l->ms.sym, from_r->ms.sym);\n}\n\nstatic int64_t\nsort__sym_to_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct addr_map_symbol *to_l, *to_r;\n\n\tif (!left->branch_info || !right->branch_info)\n\t\treturn cmp_null(left->branch_info, right->branch_info);\n\n\tto_l = &left->branch_info->to;\n\tto_r = &right->branch_info->to;\n\n\tif (!to_l->ms.sym && !to_r->ms.sym)\n\t\treturn _sort__addr_cmp(to_l->addr, to_r->addr);\n\n\treturn _sort__sym_cmp(to_l->ms.sym, to_r->ms.sym);\n}\n\nstatic int hist_entry__sym_from_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t size_t size, unsigned int width)\n{\n\tif (he->branch_info) {\n\t\tstruct addr_map_symbol *from = &he->branch_info->from;\n\n\t\treturn _hist_entry__sym_snprintf(&from->ms, from->al_addr,\n\t\t\t\t\t\t from->al_level, bf, size, width);\n\t}\n\n\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width, \"N/A\");\n}\n\nstatic int hist_entry__sym_to_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t       size_t size, unsigned int width)\n{\n\tif (he->branch_info) {\n\t\tstruct addr_map_symbol *to = &he->branch_info->to;\n\n\t\treturn _hist_entry__sym_snprintf(&to->ms, to->al_addr,\n\t\t\t\t\t\t to->al_level, bf, size, width);\n\t}\n\n\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width, \"N/A\");\n}\n\nstatic int hist_entry__sym_from_filter(struct hist_entry *he, int type,\n\t\t\t\t       const void *arg)\n{\n\tconst char *sym = arg;\n\n\tif (type != HIST_FILTER__SYMBOL)\n\t\treturn -1;\n\n\treturn sym && !(he->branch_info && he->branch_info->from.ms.sym &&\n\t\t\tstrstr(he->branch_info->from.ms.sym->name, sym));\n}\n\nstatic int hist_entry__sym_to_filter(struct hist_entry *he, int type,\n\t\t\t\t       const void *arg)\n{\n\tconst char *sym = arg;\n\n\tif (type != HIST_FILTER__SYMBOL)\n\t\treturn -1;\n\n\treturn sym && !(he->branch_info && he->branch_info->to.ms.sym &&\n\t\t        strstr(he->branch_info->to.ms.sym->name, sym));\n}\n\nstruct sort_entry sort_dso_from = {\n\t.se_header\t= \"Source Shared Object\",\n\t.se_cmp\t\t= sort__dso_from_cmp,\n\t.se_snprintf\t= hist_entry__dso_from_snprintf,\n\t.se_filter\t= hist_entry__dso_from_filter,\n\t.se_width_idx\t= HISTC_DSO_FROM,\n};\n\nstruct sort_entry sort_dso_to = {\n\t.se_header\t= \"Target Shared Object\",\n\t.se_cmp\t\t= sort__dso_to_cmp,\n\t.se_snprintf\t= hist_entry__dso_to_snprintf,\n\t.se_filter\t= hist_entry__dso_to_filter,\n\t.se_width_idx\t= HISTC_DSO_TO,\n};\n\nstruct sort_entry sort_sym_from = {\n\t.se_header\t= \"Source Symbol\",\n\t.se_cmp\t\t= sort__sym_from_cmp,\n\t.se_snprintf\t= hist_entry__sym_from_snprintf,\n\t.se_filter\t= hist_entry__sym_from_filter,\n\t.se_width_idx\t= HISTC_SYMBOL_FROM,\n};\n\nstruct sort_entry sort_sym_to = {\n\t.se_header\t= \"Target Symbol\",\n\t.se_cmp\t\t= sort__sym_to_cmp,\n\t.se_snprintf\t= hist_entry__sym_to_snprintf,\n\t.se_filter\t= hist_entry__sym_to_filter,\n\t.se_width_idx\t= HISTC_SYMBOL_TO,\n};\n\nstatic int _hist_entry__addr_snprintf(struct map_symbol *ms,\n\t\t\t\t     u64 ip, char level, char *bf, size_t size,\n\t\t\t\t     unsigned int width)\n{\n\tstruct symbol *sym = ms->sym;\n\tstruct map *map = ms->map;\n\tsize_t ret = 0, offs;\n\n\tret += repsep_snprintf(bf + ret, size - ret, \"[%c] \", level);\n\tif (sym && map) {\n\t\tif (sym->type == STT_OBJECT) {\n\t\t\tret += repsep_snprintf(bf + ret, size - ret, \"%s\", sym->name);\n\t\t\tret += repsep_snprintf(bf + ret, size - ret, \"+0x%llx\",\n\t\t\t\t\tip - map__unmap_ip(map, sym->start));\n\t\t} else {\n\t\t\tret += repsep_snprintf(bf + ret, size - ret, \"%.*s\",\n\t\t\t\t\t       width - ret,\n\t\t\t\t\t       sym->name);\n\t\t\toffs = ip - sym->start;\n\t\t\tif (offs)\n\t\t\t\tret += repsep_snprintf(bf + ret, size - ret, \"+0x%llx\", offs);\n\t\t}\n\t} else {\n\t\tsize_t len = BITS_PER_LONG / 4;\n\t\tret += repsep_snprintf(bf + ret, size - ret, \"%-#.*llx\",\n\t\t\t\t       len, ip);\n\t}\n\n\treturn ret;\n}\n\nstatic int hist_entry__addr_from_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t size_t size, unsigned int width)\n{\n\tif (he->branch_info) {\n\t\tstruct addr_map_symbol *from = &he->branch_info->from;\n\n\t\treturn _hist_entry__addr_snprintf(&from->ms, from->al_addr,\n\t\t\t\t\t\t he->level, bf, size, width);\n\t}\n\n\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width, \"N/A\");\n}\n\nstatic int hist_entry__addr_to_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t       size_t size, unsigned int width)\n{\n\tif (he->branch_info) {\n\t\tstruct addr_map_symbol *to = &he->branch_info->to;\n\n\t\treturn _hist_entry__addr_snprintf(&to->ms, to->al_addr,\n\t\t\t\t\t\t he->level, bf, size, width);\n\t}\n\n\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width, \"N/A\");\n}\n\nstatic int64_t\nsort__addr_from_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct addr_map_symbol *from_l;\n\tstruct addr_map_symbol *from_r;\n\tint64_t ret;\n\n\tif (!left->branch_info || !right->branch_info)\n\t\treturn cmp_null(left->branch_info, right->branch_info);\n\n\tfrom_l = &left->branch_info->from;\n\tfrom_r = &right->branch_info->from;\n\n\t \n\tret = _sort__dso_cmp(from_l->ms.map, from_r->ms.map);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn _sort__addr_cmp(from_l->addr, from_r->addr);\n}\n\nstatic int64_t\nsort__addr_to_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct addr_map_symbol *to_l;\n\tstruct addr_map_symbol *to_r;\n\tint64_t ret;\n\n\tif (!left->branch_info || !right->branch_info)\n\t\treturn cmp_null(left->branch_info, right->branch_info);\n\n\tto_l = &left->branch_info->to;\n\tto_r = &right->branch_info->to;\n\n\t \n\tret = _sort__dso_cmp(to_l->ms.map, to_r->ms.map);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn _sort__addr_cmp(to_l->addr, to_r->addr);\n}\n\nstruct sort_entry sort_addr_from = {\n\t.se_header\t= \"Source Address\",\n\t.se_cmp\t\t= sort__addr_from_cmp,\n\t.se_snprintf\t= hist_entry__addr_from_snprintf,\n\t.se_filter\t= hist_entry__sym_from_filter,  \n\t.se_width_idx\t= HISTC_ADDR_FROM,\n};\n\nstruct sort_entry sort_addr_to = {\n\t.se_header\t= \"Target Address\",\n\t.se_cmp\t\t= sort__addr_to_cmp,\n\t.se_snprintf\t= hist_entry__addr_to_snprintf,\n\t.se_filter\t= hist_entry__sym_to_filter,  \n\t.se_width_idx\t= HISTC_ADDR_TO,\n};\n\n\nstatic int64_t\nsort__mispredict_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tunsigned char mp, p;\n\n\tif (!left->branch_info || !right->branch_info)\n\t\treturn cmp_null(left->branch_info, right->branch_info);\n\n\tmp = left->branch_info->flags.mispred != right->branch_info->flags.mispred;\n\tp  = left->branch_info->flags.predicted != right->branch_info->flags.predicted;\n\treturn mp || p;\n}\n\nstatic int hist_entry__mispredict_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width){\n\tstatic const char *out = \"N/A\";\n\n\tif (he->branch_info) {\n\t\tif (he->branch_info->flags.predicted)\n\t\t\tout = \"N\";\n\t\telse if (he->branch_info->flags.mispred)\n\t\t\tout = \"Y\";\n\t}\n\n\treturn repsep_snprintf(bf, size, \"%-*.*s\", width, width, out);\n}\n\nstatic int64_t\nsort__cycles_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tif (!left->branch_info || !right->branch_info)\n\t\treturn cmp_null(left->branch_info, right->branch_info);\n\n\treturn left->branch_info->flags.cycles -\n\t\tright->branch_info->flags.cycles;\n}\n\nstatic int hist_entry__cycles_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tif (!he->branch_info)\n\t\treturn scnprintf(bf, size, \"%-.*s\", width, \"N/A\");\n\tif (he->branch_info->flags.cycles == 0)\n\t\treturn repsep_snprintf(bf, size, \"%-*s\", width, \"-\");\n\treturn repsep_snprintf(bf, size, \"%-*hd\", width,\n\t\t\t       he->branch_info->flags.cycles);\n}\n\nstruct sort_entry sort_cycles = {\n\t.se_header\t= \"Basic Block Cycles\",\n\t.se_cmp\t\t= sort__cycles_cmp,\n\t.se_snprintf\t= hist_entry__cycles_snprintf,\n\t.se_width_idx\t= HISTC_CYCLES,\n};\n\n \nint64_t\nsort__daddr_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tuint64_t l = 0, r = 0;\n\n\tif (left->mem_info)\n\t\tl = left->mem_info->daddr.addr;\n\tif (right->mem_info)\n\t\tr = right->mem_info->daddr.addr;\n\n\treturn (int64_t)(r - l);\n}\n\nstatic int hist_entry__daddr_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tuint64_t addr = 0;\n\tstruct map_symbol *ms = NULL;\n\n\tif (he->mem_info) {\n\t\taddr = he->mem_info->daddr.addr;\n\t\tms = &he->mem_info->daddr.ms;\n\t}\n\treturn _hist_entry__sym_snprintf(ms, addr, he->level, bf, size, width);\n}\n\nint64_t\nsort__iaddr_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tuint64_t l = 0, r = 0;\n\n\tif (left->mem_info)\n\t\tl = left->mem_info->iaddr.addr;\n\tif (right->mem_info)\n\t\tr = right->mem_info->iaddr.addr;\n\n\treturn (int64_t)(r - l);\n}\n\nstatic int hist_entry__iaddr_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tuint64_t addr = 0;\n\tstruct map_symbol *ms = NULL;\n\n\tif (he->mem_info) {\n\t\taddr = he->mem_info->iaddr.addr;\n\t\tms   = &he->mem_info->iaddr.ms;\n\t}\n\treturn _hist_entry__sym_snprintf(ms, addr, he->level, bf, size, width);\n}\n\nstatic int64_t\nsort__dso_daddr_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct map *map_l = NULL;\n\tstruct map *map_r = NULL;\n\n\tif (left->mem_info)\n\t\tmap_l = left->mem_info->daddr.ms.map;\n\tif (right->mem_info)\n\t\tmap_r = right->mem_info->daddr.ms.map;\n\n\treturn _sort__dso_cmp(map_l, map_r);\n}\n\nstatic int hist_entry__dso_daddr_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tstruct map *map = NULL;\n\n\tif (he->mem_info)\n\t\tmap = he->mem_info->daddr.ms.map;\n\n\treturn _hist_entry__dso_snprintf(map, bf, size, width);\n}\n\nstatic int64_t\nsort__locked_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tunion perf_mem_data_src data_src_l;\n\tunion perf_mem_data_src data_src_r;\n\n\tif (left->mem_info)\n\t\tdata_src_l = left->mem_info->data_src;\n\telse\n\t\tdata_src_l.mem_lock = PERF_MEM_LOCK_NA;\n\n\tif (right->mem_info)\n\t\tdata_src_r = right->mem_info->data_src;\n\telse\n\t\tdata_src_r.mem_lock = PERF_MEM_LOCK_NA;\n\n\treturn (int64_t)(data_src_r.mem_lock - data_src_l.mem_lock);\n}\n\nstatic int hist_entry__locked_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tchar out[10];\n\n\tperf_mem__lck_scnprintf(out, sizeof(out), he->mem_info);\n\treturn repsep_snprintf(bf, size, \"%.*s\", width, out);\n}\n\nstatic int64_t\nsort__tlb_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tunion perf_mem_data_src data_src_l;\n\tunion perf_mem_data_src data_src_r;\n\n\tif (left->mem_info)\n\t\tdata_src_l = left->mem_info->data_src;\n\telse\n\t\tdata_src_l.mem_dtlb = PERF_MEM_TLB_NA;\n\n\tif (right->mem_info)\n\t\tdata_src_r = right->mem_info->data_src;\n\telse\n\t\tdata_src_r.mem_dtlb = PERF_MEM_TLB_NA;\n\n\treturn (int64_t)(data_src_r.mem_dtlb - data_src_l.mem_dtlb);\n}\n\nstatic int hist_entry__tlb_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tchar out[64];\n\n\tperf_mem__tlb_scnprintf(out, sizeof(out), he->mem_info);\n\treturn repsep_snprintf(bf, size, \"%-*s\", width, out);\n}\n\nstatic int64_t\nsort__lvl_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tunion perf_mem_data_src data_src_l;\n\tunion perf_mem_data_src data_src_r;\n\n\tif (left->mem_info)\n\t\tdata_src_l = left->mem_info->data_src;\n\telse\n\t\tdata_src_l.mem_lvl = PERF_MEM_LVL_NA;\n\n\tif (right->mem_info)\n\t\tdata_src_r = right->mem_info->data_src;\n\telse\n\t\tdata_src_r.mem_lvl = PERF_MEM_LVL_NA;\n\n\treturn (int64_t)(data_src_r.mem_lvl - data_src_l.mem_lvl);\n}\n\nstatic int hist_entry__lvl_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tchar out[64];\n\n\tperf_mem__lvl_scnprintf(out, sizeof(out), he->mem_info);\n\treturn repsep_snprintf(bf, size, \"%-*s\", width, out);\n}\n\nstatic int64_t\nsort__snoop_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tunion perf_mem_data_src data_src_l;\n\tunion perf_mem_data_src data_src_r;\n\n\tif (left->mem_info)\n\t\tdata_src_l = left->mem_info->data_src;\n\telse\n\t\tdata_src_l.mem_snoop = PERF_MEM_SNOOP_NA;\n\n\tif (right->mem_info)\n\t\tdata_src_r = right->mem_info->data_src;\n\telse\n\t\tdata_src_r.mem_snoop = PERF_MEM_SNOOP_NA;\n\n\treturn (int64_t)(data_src_r.mem_snoop - data_src_l.mem_snoop);\n}\n\nstatic int hist_entry__snoop_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tchar out[64];\n\n\tperf_mem__snp_scnprintf(out, sizeof(out), he->mem_info);\n\treturn repsep_snprintf(bf, size, \"%-*s\", width, out);\n}\n\nint64_t\nsort__dcacheline_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tu64 l, r;\n\tstruct map *l_map, *r_map;\n\tstruct dso *l_dso, *r_dso;\n\tint rc;\n\n\tif (!left->mem_info)  return -1;\n\tif (!right->mem_info) return 1;\n\n\t \n\tif (left->cpumode > right->cpumode) return -1;\n\tif (left->cpumode < right->cpumode) return 1;\n\n\tl_map = left->mem_info->daddr.ms.map;\n\tr_map = right->mem_info->daddr.ms.map;\n\n\t \n\tif (!l_map && !r_map)\n\t\tgoto addr;\n\n\tif (!l_map) return -1;\n\tif (!r_map) return 1;\n\n\tl_dso = map__dso(l_map);\n\tr_dso = map__dso(r_map);\n\trc = dso__cmp_id(l_dso, r_dso);\n\tif (rc)\n\t\treturn rc;\n\t \n\n\tif ((left->cpumode != PERF_RECORD_MISC_KERNEL) &&\n\t    (!(map__flags(l_map) & MAP_SHARED)) && !l_dso->id.maj && !l_dso->id.min &&\n\t    !l_dso->id.ino && !l_dso->id.ino_generation) {\n\t\t \n\n\t\tif (thread__pid(left->thread) > thread__pid(right->thread))\n\t\t\treturn -1;\n\t\tif (thread__pid(left->thread) < thread__pid(right->thread))\n\t\t\treturn 1;\n\t}\n\naddr:\n\t \n\tl = cl_address(left->mem_info->daddr.al_addr, chk_double_cl);\n\tr = cl_address(right->mem_info->daddr.al_addr, chk_double_cl);\n\n\tif (l > r) return -1;\n\tif (l < r) return 1;\n\n\treturn 0;\n}\n\nstatic int hist_entry__dcacheline_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t  size_t size, unsigned int width)\n{\n\n\tuint64_t addr = 0;\n\tstruct map_symbol *ms = NULL;\n\tchar level = he->level;\n\n\tif (he->mem_info) {\n\t\tstruct map *map = he->mem_info->daddr.ms.map;\n\t\tstruct dso *dso = map ? map__dso(map) : NULL;\n\n\t\taddr = cl_address(he->mem_info->daddr.al_addr, chk_double_cl);\n\t\tms = &he->mem_info->daddr.ms;\n\n\t\t \n\t\tif ((he->cpumode != PERF_RECORD_MISC_KERNEL) &&\n\t\t     map && !(map__prot(map) & PROT_EXEC) &&\n\t\t     (map__flags(map) & MAP_SHARED) &&\n\t\t    (dso->id.maj || dso->id.min || dso->id.ino || dso->id.ino_generation))\n\t\t\tlevel = 's';\n\t\telse if (!map)\n\t\t\tlevel = 'X';\n\t}\n\treturn _hist_entry__sym_snprintf(ms, addr, level, bf, size, width);\n}\n\nstruct sort_entry sort_mispredict = {\n\t.se_header\t= \"Branch Mispredicted\",\n\t.se_cmp\t\t= sort__mispredict_cmp,\n\t.se_snprintf\t= hist_entry__mispredict_snprintf,\n\t.se_width_idx\t= HISTC_MISPREDICT,\n};\n\nstatic int64_t\nsort__weight_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn left->weight - right->weight;\n}\n\nstatic int hist_entry__local_weight_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-*llu\", width, he->weight);\n}\n\nstruct sort_entry sort_local_weight = {\n\t.se_header\t= \"Local Weight\",\n\t.se_cmp\t\t= sort__weight_cmp,\n\t.se_snprintf\t= hist_entry__local_weight_snprintf,\n\t.se_width_idx\t= HISTC_LOCAL_WEIGHT,\n};\n\nstatic int hist_entry__global_weight_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t      size_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-*llu\", width,\n\t\t\t       he->weight * he->stat.nr_events);\n}\n\nstruct sort_entry sort_global_weight = {\n\t.se_header\t= \"Weight\",\n\t.se_cmp\t\t= sort__weight_cmp,\n\t.se_snprintf\t= hist_entry__global_weight_snprintf,\n\t.se_width_idx\t= HISTC_GLOBAL_WEIGHT,\n};\n\nstatic int64_t\nsort__ins_lat_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn left->ins_lat - right->ins_lat;\n}\n\nstatic int hist_entry__local_ins_lat_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t      size_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-*u\", width, he->ins_lat);\n}\n\nstruct sort_entry sort_local_ins_lat = {\n\t.se_header\t= \"Local INSTR Latency\",\n\t.se_cmp\t\t= sort__ins_lat_cmp,\n\t.se_snprintf\t= hist_entry__local_ins_lat_snprintf,\n\t.se_width_idx\t= HISTC_LOCAL_INS_LAT,\n};\n\nstatic int hist_entry__global_ins_lat_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t       size_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-*u\", width,\n\t\t\t       he->ins_lat * he->stat.nr_events);\n}\n\nstruct sort_entry sort_global_ins_lat = {\n\t.se_header\t= \"INSTR Latency\",\n\t.se_cmp\t\t= sort__ins_lat_cmp,\n\t.se_snprintf\t= hist_entry__global_ins_lat_snprintf,\n\t.se_width_idx\t= HISTC_GLOBAL_INS_LAT,\n};\n\nstatic int64_t\nsort__p_stage_cyc_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn left->p_stage_cyc - right->p_stage_cyc;\n}\n\nstatic int hist_entry__global_p_stage_cyc_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\tsize_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-*u\", width,\n\t\t\the->p_stage_cyc * he->stat.nr_events);\n}\n\n\nstatic int hist_entry__p_stage_cyc_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\tsize_t size, unsigned int width)\n{\n\treturn repsep_snprintf(bf, size, \"%-*u\", width, he->p_stage_cyc);\n}\n\nstruct sort_entry sort_local_p_stage_cyc = {\n\t.se_header      = \"Local Pipeline Stage Cycle\",\n\t.se_cmp         = sort__p_stage_cyc_cmp,\n\t.se_snprintf\t= hist_entry__p_stage_cyc_snprintf,\n\t.se_width_idx\t= HISTC_LOCAL_P_STAGE_CYC,\n};\n\nstruct sort_entry sort_global_p_stage_cyc = {\n\t.se_header      = \"Pipeline Stage Cycle\",\n\t.se_cmp         = sort__p_stage_cyc_cmp,\n\t.se_snprintf    = hist_entry__global_p_stage_cyc_snprintf,\n\t.se_width_idx   = HISTC_GLOBAL_P_STAGE_CYC,\n};\n\nstruct sort_entry sort_mem_daddr_sym = {\n\t.se_header\t= \"Data Symbol\",\n\t.se_cmp\t\t= sort__daddr_cmp,\n\t.se_snprintf\t= hist_entry__daddr_snprintf,\n\t.se_width_idx\t= HISTC_MEM_DADDR_SYMBOL,\n};\n\nstruct sort_entry sort_mem_iaddr_sym = {\n\t.se_header\t= \"Code Symbol\",\n\t.se_cmp\t\t= sort__iaddr_cmp,\n\t.se_snprintf\t= hist_entry__iaddr_snprintf,\n\t.se_width_idx\t= HISTC_MEM_IADDR_SYMBOL,\n};\n\nstruct sort_entry sort_mem_daddr_dso = {\n\t.se_header\t= \"Data Object\",\n\t.se_cmp\t\t= sort__dso_daddr_cmp,\n\t.se_snprintf\t= hist_entry__dso_daddr_snprintf,\n\t.se_width_idx\t= HISTC_MEM_DADDR_DSO,\n};\n\nstruct sort_entry sort_mem_locked = {\n\t.se_header\t= \"Locked\",\n\t.se_cmp\t\t= sort__locked_cmp,\n\t.se_snprintf\t= hist_entry__locked_snprintf,\n\t.se_width_idx\t= HISTC_MEM_LOCKED,\n};\n\nstruct sort_entry sort_mem_tlb = {\n\t.se_header\t= \"TLB access\",\n\t.se_cmp\t\t= sort__tlb_cmp,\n\t.se_snprintf\t= hist_entry__tlb_snprintf,\n\t.se_width_idx\t= HISTC_MEM_TLB,\n};\n\nstruct sort_entry sort_mem_lvl = {\n\t.se_header\t= \"Memory access\",\n\t.se_cmp\t\t= sort__lvl_cmp,\n\t.se_snprintf\t= hist_entry__lvl_snprintf,\n\t.se_width_idx\t= HISTC_MEM_LVL,\n};\n\nstruct sort_entry sort_mem_snoop = {\n\t.se_header\t= \"Snoop\",\n\t.se_cmp\t\t= sort__snoop_cmp,\n\t.se_snprintf\t= hist_entry__snoop_snprintf,\n\t.se_width_idx\t= HISTC_MEM_SNOOP,\n};\n\nstruct sort_entry sort_mem_dcacheline = {\n\t.se_header\t= \"Data Cacheline\",\n\t.se_cmp\t\t= sort__dcacheline_cmp,\n\t.se_snprintf\t= hist_entry__dcacheline_snprintf,\n\t.se_width_idx\t= HISTC_MEM_DCACHELINE,\n};\n\nstatic int64_t\nsort__blocked_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tunion perf_mem_data_src data_src_l;\n\tunion perf_mem_data_src data_src_r;\n\n\tif (left->mem_info)\n\t\tdata_src_l = left->mem_info->data_src;\n\telse\n\t\tdata_src_l.mem_blk = PERF_MEM_BLK_NA;\n\n\tif (right->mem_info)\n\t\tdata_src_r = right->mem_info->data_src;\n\telse\n\t\tdata_src_r.mem_blk = PERF_MEM_BLK_NA;\n\n\treturn (int64_t)(data_src_r.mem_blk - data_src_l.mem_blk);\n}\n\nstatic int hist_entry__blocked_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\tsize_t size, unsigned int width)\n{\n\tchar out[16];\n\n\tperf_mem__blk_scnprintf(out, sizeof(out), he->mem_info);\n\treturn repsep_snprintf(bf, size, \"%.*s\", width, out);\n}\n\nstruct sort_entry sort_mem_blocked = {\n\t.se_header\t= \"Blocked\",\n\t.se_cmp\t\t= sort__blocked_cmp,\n\t.se_snprintf\t= hist_entry__blocked_snprintf,\n\t.se_width_idx\t= HISTC_MEM_BLOCKED,\n};\n\nstatic int64_t\nsort__phys_daddr_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tuint64_t l = 0, r = 0;\n\n\tif (left->mem_info)\n\t\tl = left->mem_info->daddr.phys_addr;\n\tif (right->mem_info)\n\t\tr = right->mem_info->daddr.phys_addr;\n\n\treturn (int64_t)(r - l);\n}\n\nstatic int hist_entry__phys_daddr_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t   size_t size, unsigned int width)\n{\n\tuint64_t addr = 0;\n\tsize_t ret = 0;\n\tsize_t len = BITS_PER_LONG / 4;\n\n\taddr = he->mem_info->daddr.phys_addr;\n\n\tret += repsep_snprintf(bf + ret, size - ret, \"[%c] \", he->level);\n\n\tret += repsep_snprintf(bf + ret, size - ret, \"%-#.*llx\", len, addr);\n\n\tret += repsep_snprintf(bf + ret, size - ret, \"%-*s\", width - ret, \"\");\n\n\tif (ret > width)\n\t\tbf[width] = '\\0';\n\n\treturn width;\n}\n\nstruct sort_entry sort_mem_phys_daddr = {\n\t.se_header\t= \"Data Physical Address\",\n\t.se_cmp\t\t= sort__phys_daddr_cmp,\n\t.se_snprintf\t= hist_entry__phys_daddr_snprintf,\n\t.se_width_idx\t= HISTC_MEM_PHYS_DADDR,\n};\n\nstatic int64_t\nsort__data_page_size_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tuint64_t l = 0, r = 0;\n\n\tif (left->mem_info)\n\t\tl = left->mem_info->daddr.data_page_size;\n\tif (right->mem_info)\n\t\tr = right->mem_info->daddr.data_page_size;\n\n\treturn (int64_t)(r - l);\n}\n\nstatic int hist_entry__data_page_size_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t  size_t size, unsigned int width)\n{\n\tchar str[PAGE_SIZE_NAME_LEN];\n\n\treturn repsep_snprintf(bf, size, \"%-*s\", width,\n\t\t\t       get_page_size_name(he->mem_info->daddr.data_page_size, str));\n}\n\nstruct sort_entry sort_mem_data_page_size = {\n\t.se_header\t= \"Data Page Size\",\n\t.se_cmp\t\t= sort__data_page_size_cmp,\n\t.se_snprintf\t= hist_entry__data_page_size_snprintf,\n\t.se_width_idx\t= HISTC_MEM_DATA_PAGE_SIZE,\n};\n\nstatic int64_t\nsort__code_page_size_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tuint64_t l = left->code_page_size;\n\tuint64_t r = right->code_page_size;\n\n\treturn (int64_t)(r - l);\n}\n\nstatic int hist_entry__code_page_size_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t  size_t size, unsigned int width)\n{\n\tchar str[PAGE_SIZE_NAME_LEN];\n\n\treturn repsep_snprintf(bf, size, \"%-*s\", width,\n\t\t\t       get_page_size_name(he->code_page_size, str));\n}\n\nstruct sort_entry sort_code_page_size = {\n\t.se_header\t= \"Code Page Size\",\n\t.se_cmp\t\t= sort__code_page_size_cmp,\n\t.se_snprintf\t= hist_entry__code_page_size_snprintf,\n\t.se_width_idx\t= HISTC_CODE_PAGE_SIZE,\n};\n\nstatic int64_t\nsort__abort_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tif (!left->branch_info || !right->branch_info)\n\t\treturn cmp_null(left->branch_info, right->branch_info);\n\n\treturn left->branch_info->flags.abort !=\n\t\tright->branch_info->flags.abort;\n}\n\nstatic int hist_entry__abort_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tstatic const char *out = \"N/A\";\n\n\tif (he->branch_info) {\n\t\tif (he->branch_info->flags.abort)\n\t\t\tout = \"A\";\n\t\telse\n\t\t\tout = \".\";\n\t}\n\n\treturn repsep_snprintf(bf, size, \"%-*s\", width, out);\n}\n\nstruct sort_entry sort_abort = {\n\t.se_header\t= \"Transaction abort\",\n\t.se_cmp\t\t= sort__abort_cmp,\n\t.se_snprintf\t= hist_entry__abort_snprintf,\n\t.se_width_idx\t= HISTC_ABORT,\n};\n\nstatic int64_t\nsort__in_tx_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tif (!left->branch_info || !right->branch_info)\n\t\treturn cmp_null(left->branch_info, right->branch_info);\n\n\treturn left->branch_info->flags.in_tx !=\n\t\tright->branch_info->flags.in_tx;\n}\n\nstatic int hist_entry__in_tx_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t    size_t size, unsigned int width)\n{\n\tstatic const char *out = \"N/A\";\n\n\tif (he->branch_info) {\n\t\tif (he->branch_info->flags.in_tx)\n\t\t\tout = \"T\";\n\t\telse\n\t\t\tout = \".\";\n\t}\n\n\treturn repsep_snprintf(bf, size, \"%-*s\", width, out);\n}\n\nstruct sort_entry sort_in_tx = {\n\t.se_header\t= \"Branch in transaction\",\n\t.se_cmp\t\t= sort__in_tx_cmp,\n\t.se_snprintf\t= hist_entry__in_tx_snprintf,\n\t.se_width_idx\t= HISTC_IN_TX,\n};\n\nstatic int64_t\nsort__transaction_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn left->transaction - right->transaction;\n}\n\nstatic inline char *add_str(char *p, const char *str)\n{\n\tstrcpy(p, str);\n\treturn p + strlen(str);\n}\n\nstatic struct txbit {\n\tunsigned flag;\n\tconst char *name;\n\tint skip_for_len;\n} txbits[] = {\n\t{ PERF_TXN_ELISION,        \"EL \",        0 },\n\t{ PERF_TXN_TRANSACTION,    \"TX \",        1 },\n\t{ PERF_TXN_SYNC,           \"SYNC \",      1 },\n\t{ PERF_TXN_ASYNC,          \"ASYNC \",     0 },\n\t{ PERF_TXN_RETRY,          \"RETRY \",     0 },\n\t{ PERF_TXN_CONFLICT,       \"CON \",       0 },\n\t{ PERF_TXN_CAPACITY_WRITE, \"CAP-WRITE \", 1 },\n\t{ PERF_TXN_CAPACITY_READ,  \"CAP-READ \",  0 },\n\t{ 0, NULL, 0 }\n};\n\nint hist_entry__transaction_len(void)\n{\n\tint i;\n\tint len = 0;\n\n\tfor (i = 0; txbits[i].name; i++) {\n\t\tif (!txbits[i].skip_for_len)\n\t\t\tlen += strlen(txbits[i].name);\n\t}\n\tlen += 4;  \n\treturn len;\n}\n\nstatic int hist_entry__transaction_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t    size_t size, unsigned int width)\n{\n\tu64 t = he->transaction;\n\tchar buf[128];\n\tchar *p = buf;\n\tint i;\n\n\tbuf[0] = 0;\n\tfor (i = 0; txbits[i].name; i++)\n\t\tif (txbits[i].flag & t)\n\t\t\tp = add_str(p, txbits[i].name);\n\tif (t && !(t & (PERF_TXN_SYNC|PERF_TXN_ASYNC)))\n\t\tp = add_str(p, \"NEITHER \");\n\tif (t & PERF_TXN_ABORT_MASK) {\n\t\tsprintf(p, \":%\" PRIx64,\n\t\t\t(t & PERF_TXN_ABORT_MASK) >>\n\t\t\tPERF_TXN_ABORT_SHIFT);\n\t\tp += strlen(p);\n\t}\n\n\treturn repsep_snprintf(bf, size, \"%-*s\", width, buf);\n}\n\nstruct sort_entry sort_transaction = {\n\t.se_header\t= \"Transaction                \",\n\t.se_cmp\t\t= sort__transaction_cmp,\n\t.se_snprintf\t= hist_entry__transaction_snprintf,\n\t.se_width_idx\t= HISTC_TRANSACTION,\n};\n\n \n\nstatic int64_t _sort__sym_size_cmp(struct symbol *sym_l, struct symbol *sym_r)\n{\n\tint64_t size_l = sym_l != NULL ? symbol__size(sym_l) : 0;\n\tint64_t size_r = sym_r != NULL ? symbol__size(sym_r) : 0;\n\n\treturn size_l < size_r ? -1 :\n\t\tsize_l == size_r ? 0 : 1;\n}\n\nstatic int64_t\nsort__sym_size_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn _sort__sym_size_cmp(right->ms.sym, left->ms.sym);\n}\n\nstatic int _hist_entry__sym_size_snprintf(struct symbol *sym, char *bf,\n\t\t\t\t\t  size_t bf_size, unsigned int width)\n{\n\tif (sym)\n\t\treturn repsep_snprintf(bf, bf_size, \"%*d\", width, symbol__size(sym));\n\n\treturn repsep_snprintf(bf, bf_size, \"%*s\", width, \"unknown\");\n}\n\nstatic int hist_entry__sym_size_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t size_t size, unsigned int width)\n{\n\treturn _hist_entry__sym_size_snprintf(he->ms.sym, bf, size, width);\n}\n\nstruct sort_entry sort_sym_size = {\n\t.se_header\t= \"Symbol size\",\n\t.se_cmp\t\t= sort__sym_size_cmp,\n\t.se_snprintf\t= hist_entry__sym_size_snprintf,\n\t.se_width_idx\t= HISTC_SYM_SIZE,\n};\n\n \n\nstatic int64_t _sort__dso_size_cmp(struct map *map_l, struct map *map_r)\n{\n\tint64_t size_l = map_l != NULL ? map__size(map_l) : 0;\n\tint64_t size_r = map_r != NULL ? map__size(map_r) : 0;\n\n\treturn size_l < size_r ? -1 :\n\t\tsize_l == size_r ? 0 : 1;\n}\n\nstatic int64_t\nsort__dso_size_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\treturn _sort__dso_size_cmp(right->ms.map, left->ms.map);\n}\n\nstatic int _hist_entry__dso_size_snprintf(struct map *map, char *bf,\n\t\t\t\t\t  size_t bf_size, unsigned int width)\n{\n\tif (map && map__dso(map))\n\t\treturn repsep_snprintf(bf, bf_size, \"%*d\", width, map__size(map));\n\n\treturn repsep_snprintf(bf, bf_size, \"%*s\", width, \"unknown\");\n}\n\nstatic int hist_entry__dso_size_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t\t size_t size, unsigned int width)\n{\n\treturn _hist_entry__dso_size_snprintf(he->ms.map, bf, size, width);\n}\n\nstruct sort_entry sort_dso_size = {\n\t.se_header\t= \"DSO size\",\n\t.se_cmp\t\t= sort__dso_size_cmp,\n\t.se_snprintf\t= hist_entry__dso_size_snprintf,\n\t.se_width_idx\t= HISTC_DSO_SIZE,\n};\n\n \n\nstatic int64_t\nsort__addr_cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tu64 left_ip = left->ip;\n\tu64 right_ip = right->ip;\n\tstruct map *left_map = left->ms.map;\n\tstruct map *right_map = right->ms.map;\n\n\tif (left_map)\n\t\tleft_ip = map__unmap_ip(left_map, left_ip);\n\tif (right_map)\n\t\tright_ip = map__unmap_ip(right_map, right_ip);\n\n\treturn _sort__addr_cmp(left_ip, right_ip);\n}\n\nstatic int hist_entry__addr_snprintf(struct hist_entry *he, char *bf,\n\t\t\t\t     size_t size, unsigned int width)\n{\n\tu64 ip = he->ip;\n\tstruct map *map = he->ms.map;\n\n\tif (map)\n\t\tip = map__unmap_ip(map, ip);\n\n\treturn repsep_snprintf(bf, size, \"%-#*llx\", width, ip);\n}\n\nstruct sort_entry sort_addr = {\n\t.se_header\t= \"Address\",\n\t.se_cmp\t\t= sort__addr_cmp,\n\t.se_snprintf\t= hist_entry__addr_snprintf,\n\t.se_width_idx\t= HISTC_ADDR,\n};\n\n\nstruct sort_dimension {\n\tconst char\t\t*name;\n\tstruct sort_entry\t*entry;\n\tint\t\t\ttaken;\n};\n\nint __weak arch_support_sort_key(const char *sort_key __maybe_unused)\n{\n\treturn 0;\n}\n\nconst char * __weak arch_perf_header_entry(const char *se_header)\n{\n\treturn se_header;\n}\n\nstatic void sort_dimension_add_dynamic_header(struct sort_dimension *sd)\n{\n\tsd->entry->se_header = arch_perf_header_entry(sd->entry->se_header);\n}\n\n#define DIM(d, n, func) [d] = { .name = n, .entry = &(func) }\n\nstatic struct sort_dimension common_sort_dimensions[] = {\n\tDIM(SORT_PID, \"pid\", sort_thread),\n\tDIM(SORT_COMM, \"comm\", sort_comm),\n\tDIM(SORT_DSO, \"dso\", sort_dso),\n\tDIM(SORT_SYM, \"symbol\", sort_sym),\n\tDIM(SORT_PARENT, \"parent\", sort_parent),\n\tDIM(SORT_CPU, \"cpu\", sort_cpu),\n\tDIM(SORT_SOCKET, \"socket\", sort_socket),\n\tDIM(SORT_SRCLINE, \"srcline\", sort_srcline),\n\tDIM(SORT_SRCFILE, \"srcfile\", sort_srcfile),\n\tDIM(SORT_LOCAL_WEIGHT, \"local_weight\", sort_local_weight),\n\tDIM(SORT_GLOBAL_WEIGHT, \"weight\", sort_global_weight),\n\tDIM(SORT_TRANSACTION, \"transaction\", sort_transaction),\n#ifdef HAVE_LIBTRACEEVENT\n\tDIM(SORT_TRACE, \"trace\", sort_trace),\n#endif\n\tDIM(SORT_SYM_SIZE, \"symbol_size\", sort_sym_size),\n\tDIM(SORT_DSO_SIZE, \"dso_size\", sort_dso_size),\n\tDIM(SORT_CGROUP, \"cgroup\", sort_cgroup),\n\tDIM(SORT_CGROUP_ID, \"cgroup_id\", sort_cgroup_id),\n\tDIM(SORT_SYM_IPC_NULL, \"ipc_null\", sort_sym_ipc_null),\n\tDIM(SORT_TIME, \"time\", sort_time),\n\tDIM(SORT_CODE_PAGE_SIZE, \"code_page_size\", sort_code_page_size),\n\tDIM(SORT_LOCAL_INS_LAT, \"local_ins_lat\", sort_local_ins_lat),\n\tDIM(SORT_GLOBAL_INS_LAT, \"ins_lat\", sort_global_ins_lat),\n\tDIM(SORT_LOCAL_PIPELINE_STAGE_CYC, \"local_p_stage_cyc\", sort_local_p_stage_cyc),\n\tDIM(SORT_GLOBAL_PIPELINE_STAGE_CYC, \"p_stage_cyc\", sort_global_p_stage_cyc),\n\tDIM(SORT_ADDR, \"addr\", sort_addr),\n\tDIM(SORT_LOCAL_RETIRE_LAT, \"local_retire_lat\", sort_local_p_stage_cyc),\n\tDIM(SORT_GLOBAL_RETIRE_LAT, \"retire_lat\", sort_global_p_stage_cyc),\n\tDIM(SORT_SIMD, \"simd\", sort_simd)\n};\n\n#undef DIM\n\n#define DIM(d, n, func) [d - __SORT_BRANCH_STACK] = { .name = n, .entry = &(func) }\n\nstatic struct sort_dimension bstack_sort_dimensions[] = {\n\tDIM(SORT_DSO_FROM, \"dso_from\", sort_dso_from),\n\tDIM(SORT_DSO_TO, \"dso_to\", sort_dso_to),\n\tDIM(SORT_SYM_FROM, \"symbol_from\", sort_sym_from),\n\tDIM(SORT_SYM_TO, \"symbol_to\", sort_sym_to),\n\tDIM(SORT_MISPREDICT, \"mispredict\", sort_mispredict),\n\tDIM(SORT_IN_TX, \"in_tx\", sort_in_tx),\n\tDIM(SORT_ABORT, \"abort\", sort_abort),\n\tDIM(SORT_CYCLES, \"cycles\", sort_cycles),\n\tDIM(SORT_SRCLINE_FROM, \"srcline_from\", sort_srcline_from),\n\tDIM(SORT_SRCLINE_TO, \"srcline_to\", sort_srcline_to),\n\tDIM(SORT_SYM_IPC, \"ipc_lbr\", sort_sym_ipc),\n\tDIM(SORT_ADDR_FROM, \"addr_from\", sort_addr_from),\n\tDIM(SORT_ADDR_TO, \"addr_to\", sort_addr_to),\n};\n\n#undef DIM\n\n#define DIM(d, n, func) [d - __SORT_MEMORY_MODE] = { .name = n, .entry = &(func) }\n\nstatic struct sort_dimension memory_sort_dimensions[] = {\n\tDIM(SORT_MEM_DADDR_SYMBOL, \"symbol_daddr\", sort_mem_daddr_sym),\n\tDIM(SORT_MEM_IADDR_SYMBOL, \"symbol_iaddr\", sort_mem_iaddr_sym),\n\tDIM(SORT_MEM_DADDR_DSO, \"dso_daddr\", sort_mem_daddr_dso),\n\tDIM(SORT_MEM_LOCKED, \"locked\", sort_mem_locked),\n\tDIM(SORT_MEM_TLB, \"tlb\", sort_mem_tlb),\n\tDIM(SORT_MEM_LVL, \"mem\", sort_mem_lvl),\n\tDIM(SORT_MEM_SNOOP, \"snoop\", sort_mem_snoop),\n\tDIM(SORT_MEM_DCACHELINE, \"dcacheline\", sort_mem_dcacheline),\n\tDIM(SORT_MEM_PHYS_DADDR, \"phys_daddr\", sort_mem_phys_daddr),\n\tDIM(SORT_MEM_DATA_PAGE_SIZE, \"data_page_size\", sort_mem_data_page_size),\n\tDIM(SORT_MEM_BLOCKED, \"blocked\", sort_mem_blocked),\n};\n\n#undef DIM\n\nstruct hpp_dimension {\n\tconst char\t\t*name;\n\tstruct perf_hpp_fmt\t*fmt;\n\tint\t\t\ttaken;\n};\n\n#define DIM(d, n) { .name = n, .fmt = &perf_hpp__format[d], }\n\nstatic struct hpp_dimension hpp_sort_dimensions[] = {\n\tDIM(PERF_HPP__OVERHEAD, \"overhead\"),\n\tDIM(PERF_HPP__OVERHEAD_SYS, \"overhead_sys\"),\n\tDIM(PERF_HPP__OVERHEAD_US, \"overhead_us\"),\n\tDIM(PERF_HPP__OVERHEAD_GUEST_SYS, \"overhead_guest_sys\"),\n\tDIM(PERF_HPP__OVERHEAD_GUEST_US, \"overhead_guest_us\"),\n\tDIM(PERF_HPP__OVERHEAD_ACC, \"overhead_children\"),\n\tDIM(PERF_HPP__SAMPLES, \"sample\"),\n\tDIM(PERF_HPP__PERIOD, \"period\"),\n};\n\n#undef DIM\n\nstruct hpp_sort_entry {\n\tstruct perf_hpp_fmt hpp;\n\tstruct sort_entry *se;\n};\n\nvoid perf_hpp__reset_sort_width(struct perf_hpp_fmt *fmt, struct hists *hists)\n{\n\tstruct hpp_sort_entry *hse;\n\n\tif (!perf_hpp__is_sort_entry(fmt))\n\t\treturn;\n\n\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\thists__new_col_len(hists, hse->se->se_width_idx, strlen(fmt->name));\n}\n\nstatic int __sort__hpp_header(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t      struct hists *hists, int line __maybe_unused,\n\t\t\t      int *span __maybe_unused)\n{\n\tstruct hpp_sort_entry *hse;\n\tsize_t len = fmt->user_len;\n\n\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\n\tif (!len)\n\t\tlen = hists__col_len(hists, hse->se->se_width_idx);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%-*.*s\", len, len, fmt->name);\n}\n\nstatic int __sort__hpp_width(struct perf_hpp_fmt *fmt,\n\t\t\t     struct perf_hpp *hpp __maybe_unused,\n\t\t\t     struct hists *hists)\n{\n\tstruct hpp_sort_entry *hse;\n\tsize_t len = fmt->user_len;\n\n\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\n\tif (!len)\n\t\tlen = hists__col_len(hists, hse->se->se_width_idx);\n\n\treturn len;\n}\n\nstatic int __sort__hpp_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t     struct hist_entry *he)\n{\n\tstruct hpp_sort_entry *hse;\n\tsize_t len = fmt->user_len;\n\n\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\n\tif (!len)\n\t\tlen = hists__col_len(he->hists, hse->se->se_width_idx);\n\n\treturn hse->se->se_snprintf(he, hpp->buf, hpp->size, len);\n}\n\nstatic int64_t __sort__hpp_cmp(struct perf_hpp_fmt *fmt,\n\t\t\t       struct hist_entry *a, struct hist_entry *b)\n{\n\tstruct hpp_sort_entry *hse;\n\n\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\treturn hse->se->se_cmp(a, b);\n}\n\nstatic int64_t __sort__hpp_collapse(struct perf_hpp_fmt *fmt,\n\t\t\t\t    struct hist_entry *a, struct hist_entry *b)\n{\n\tstruct hpp_sort_entry *hse;\n\tint64_t (*collapse_fn)(struct hist_entry *, struct hist_entry *);\n\n\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\tcollapse_fn = hse->se->se_collapse ?: hse->se->se_cmp;\n\treturn collapse_fn(a, b);\n}\n\nstatic int64_t __sort__hpp_sort(struct perf_hpp_fmt *fmt,\n\t\t\t\tstruct hist_entry *a, struct hist_entry *b)\n{\n\tstruct hpp_sort_entry *hse;\n\tint64_t (*sort_fn)(struct hist_entry *, struct hist_entry *);\n\n\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\tsort_fn = hse->se->se_sort ?: hse->se->se_cmp;\n\treturn sort_fn(a, b);\n}\n\nbool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format)\n{\n\treturn format->header == __sort__hpp_header;\n}\n\n#define MK_SORT_ENTRY_CHK(key)\t\t\t\t\t\\\nbool perf_hpp__is_ ## key ## _entry(struct perf_hpp_fmt *fmt)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct hpp_sort_entry *hse;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (!perf_hpp__is_sort_entry(fmt))\t\t\t\\\n\t\treturn false;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\thse = container_of(fmt, struct hpp_sort_entry, hpp);\t\\\n\treturn hse->se == &sort_ ## key ;\t\t\t\\\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nMK_SORT_ENTRY_CHK(trace)\n#else\nbool perf_hpp__is_trace_entry(struct perf_hpp_fmt *fmt __maybe_unused)\n{\n\treturn false;\n}\n#endif\nMK_SORT_ENTRY_CHK(srcline)\nMK_SORT_ENTRY_CHK(srcfile)\nMK_SORT_ENTRY_CHK(thread)\nMK_SORT_ENTRY_CHK(comm)\nMK_SORT_ENTRY_CHK(dso)\nMK_SORT_ENTRY_CHK(sym)\n\n\nstatic bool __sort__hpp_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)\n{\n\tstruct hpp_sort_entry *hse_a;\n\tstruct hpp_sort_entry *hse_b;\n\n\tif (!perf_hpp__is_sort_entry(a) || !perf_hpp__is_sort_entry(b))\n\t\treturn false;\n\n\thse_a = container_of(a, struct hpp_sort_entry, hpp);\n\thse_b = container_of(b, struct hpp_sort_entry, hpp);\n\n\treturn hse_a->se == hse_b->se;\n}\n\nstatic void hse_free(struct perf_hpp_fmt *fmt)\n{\n\tstruct hpp_sort_entry *hse;\n\n\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\tfree(hse);\n}\n\nstatic void hse_init(struct perf_hpp_fmt *fmt, struct hist_entry *he)\n{\n\tstruct hpp_sort_entry *hse;\n\n\tif (!perf_hpp__is_sort_entry(fmt))\n\t\treturn;\n\n\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\n\tif (hse->se->se_init)\n\t\thse->se->se_init(he);\n}\n\nstatic struct hpp_sort_entry *\n__sort_dimension__alloc_hpp(struct sort_dimension *sd, int level)\n{\n\tstruct hpp_sort_entry *hse;\n\n\thse = malloc(sizeof(*hse));\n\tif (hse == NULL) {\n\t\tpr_err(\"Memory allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\n\thse->se = sd->entry;\n\thse->hpp.name = sd->entry->se_header;\n\thse->hpp.header = __sort__hpp_header;\n\thse->hpp.width = __sort__hpp_width;\n\thse->hpp.entry = __sort__hpp_entry;\n\thse->hpp.color = NULL;\n\n\thse->hpp.cmp = __sort__hpp_cmp;\n\thse->hpp.collapse = __sort__hpp_collapse;\n\thse->hpp.sort = __sort__hpp_sort;\n\thse->hpp.equal = __sort__hpp_equal;\n\thse->hpp.free = hse_free;\n\thse->hpp.init = hse_init;\n\n\tINIT_LIST_HEAD(&hse->hpp.list);\n\tINIT_LIST_HEAD(&hse->hpp.sort_list);\n\thse->hpp.elide = false;\n\thse->hpp.len = 0;\n\thse->hpp.user_len = 0;\n\thse->hpp.level = level;\n\n\treturn hse;\n}\n\nstatic void hpp_free(struct perf_hpp_fmt *fmt)\n{\n\tfree(fmt);\n}\n\nstatic struct perf_hpp_fmt *__hpp_dimension__alloc_hpp(struct hpp_dimension *hd,\n\t\t\t\t\t\t       int level)\n{\n\tstruct perf_hpp_fmt *fmt;\n\n\tfmt = memdup(hd->fmt, sizeof(*fmt));\n\tif (fmt) {\n\t\tINIT_LIST_HEAD(&fmt->list);\n\t\tINIT_LIST_HEAD(&fmt->sort_list);\n\t\tfmt->free = hpp_free;\n\t\tfmt->level = level;\n\t}\n\n\treturn fmt;\n}\n\nint hist_entry__filter(struct hist_entry *he, int type, const void *arg)\n{\n\tstruct perf_hpp_fmt *fmt;\n\tstruct hpp_sort_entry *hse;\n\tint ret = -1;\n\tint r;\n\n\tperf_hpp_list__for_each_format(he->hpp_list, fmt) {\n\t\tif (!perf_hpp__is_sort_entry(fmt))\n\t\t\tcontinue;\n\n\t\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\t\tif (hse->se->se_filter == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tr = hse->se->se_filter(he, type, arg);\n\t\tif (r >= 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = 0;\n\t\t\tret |= r;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int __sort_dimension__add_hpp_sort(struct sort_dimension *sd,\n\t\t\t\t\t  struct perf_hpp_list *list,\n\t\t\t\t\t  int level)\n{\n\tstruct hpp_sort_entry *hse = __sort_dimension__alloc_hpp(sd, level);\n\n\tif (hse == NULL)\n\t\treturn -1;\n\n\tperf_hpp_list__register_sort_field(list, &hse->hpp);\n\treturn 0;\n}\n\nstatic int __sort_dimension__add_hpp_output(struct sort_dimension *sd,\n\t\t\t\t\t    struct perf_hpp_list *list)\n{\n\tstruct hpp_sort_entry *hse = __sort_dimension__alloc_hpp(sd, 0);\n\n\tif (hse == NULL)\n\t\treturn -1;\n\n\tperf_hpp_list__column_register(list, &hse->hpp);\n\treturn 0;\n}\n\n#ifndef HAVE_LIBTRACEEVENT\nbool perf_hpp__is_dynamic_entry(struct perf_hpp_fmt *fmt __maybe_unused)\n{\n\treturn false;\n}\nbool perf_hpp__defined_dynamic_entry(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\t\t     struct hists *hists __maybe_unused)\n{\n\treturn false;\n}\n#else\nstruct hpp_dynamic_entry {\n\tstruct perf_hpp_fmt hpp;\n\tstruct evsel *evsel;\n\tstruct tep_format_field *field;\n\tunsigned dynamic_len;\n\tbool raw_trace;\n};\n\nstatic int hde_width(struct hpp_dynamic_entry *hde)\n{\n\tif (!hde->hpp.len) {\n\t\tint len = hde->dynamic_len;\n\t\tint namelen = strlen(hde->field->name);\n\t\tint fieldlen = hde->field->size;\n\n\t\tif (namelen > len)\n\t\t\tlen = namelen;\n\n\t\tif (!(hde->field->flags & TEP_FIELD_IS_STRING)) {\n\t\t\t \n\t\t\tfieldlen = hde->field->size * 2 + 2;\n\t\t}\n\t\tif (fieldlen > len)\n\t\t\tlen = fieldlen;\n\n\t\thde->hpp.len = len;\n\t}\n\treturn hde->hpp.len;\n}\n\nstatic void update_dynamic_len(struct hpp_dynamic_entry *hde,\n\t\t\t       struct hist_entry *he)\n{\n\tchar *str, *pos;\n\tstruct tep_format_field *field = hde->field;\n\tsize_t namelen;\n\tbool last = false;\n\n\tif (hde->raw_trace)\n\t\treturn;\n\n\t \n\tif (!he->trace_output)\n\t\the->trace_output = get_trace_output(he);\n\n\tnamelen = strlen(field->name);\n\tstr = he->trace_output;\n\n\twhile (str) {\n\t\tpos = strchr(str, ' ');\n\t\tif (pos == NULL) {\n\t\t\tlast = true;\n\t\t\tpos = str + strlen(str);\n\t\t}\n\n\t\tif (!strncmp(str, field->name, namelen)) {\n\t\t\tsize_t len;\n\n\t\t\tstr += namelen + 1;\n\t\t\tlen = pos - str;\n\n\t\t\tif (len > hde->dynamic_len)\n\t\t\t\thde->dynamic_len = len;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (last)\n\t\t\tstr = NULL;\n\t\telse\n\t\t\tstr = pos + 1;\n\t}\n}\n\nstatic int __sort__hde_header(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t      struct hists *hists __maybe_unused,\n\t\t\t      int line __maybe_unused,\n\t\t\t      int *span __maybe_unused)\n{\n\tstruct hpp_dynamic_entry *hde;\n\tsize_t len = fmt->user_len;\n\n\thde = container_of(fmt, struct hpp_dynamic_entry, hpp);\n\n\tif (!len)\n\t\tlen = hde_width(hde);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*.*s\", len, len, hde->field->name);\n}\n\nstatic int __sort__hde_width(struct perf_hpp_fmt *fmt,\n\t\t\t     struct perf_hpp *hpp __maybe_unused,\n\t\t\t     struct hists *hists __maybe_unused)\n{\n\tstruct hpp_dynamic_entry *hde;\n\tsize_t len = fmt->user_len;\n\n\thde = container_of(fmt, struct hpp_dynamic_entry, hpp);\n\n\tif (!len)\n\t\tlen = hde_width(hde);\n\n\treturn len;\n}\n\nbool perf_hpp__defined_dynamic_entry(struct perf_hpp_fmt *fmt, struct hists *hists)\n{\n\tstruct hpp_dynamic_entry *hde;\n\n\thde = container_of(fmt, struct hpp_dynamic_entry, hpp);\n\n\treturn hists_to_evsel(hists) == hde->evsel;\n}\n\nstatic int __sort__hde_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t     struct hist_entry *he)\n{\n\tstruct hpp_dynamic_entry *hde;\n\tsize_t len = fmt->user_len;\n\tchar *str, *pos;\n\tstruct tep_format_field *field;\n\tsize_t namelen;\n\tbool last = false;\n\tint ret;\n\n\thde = container_of(fmt, struct hpp_dynamic_entry, hpp);\n\n\tif (!len)\n\t\tlen = hde_width(hde);\n\n\tif (hde->raw_trace)\n\t\tgoto raw_field;\n\n\tif (!he->trace_output)\n\t\the->trace_output = get_trace_output(he);\n\n\tfield = hde->field;\n\tnamelen = strlen(field->name);\n\tstr = he->trace_output;\n\n\twhile (str) {\n\t\tpos = strchr(str, ' ');\n\t\tif (pos == NULL) {\n\t\t\tlast = true;\n\t\t\tpos = str + strlen(str);\n\t\t}\n\n\t\tif (!strncmp(str, field->name, namelen)) {\n\t\t\tstr += namelen + 1;\n\t\t\tstr = strndup(str, pos - str);\n\n\t\t\tif (str == NULL)\n\t\t\t\treturn scnprintf(hpp->buf, hpp->size,\n\t\t\t\t\t\t \"%*.*s\", len, len, \"ERROR\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (last)\n\t\t\tstr = NULL;\n\t\telse\n\t\t\tstr = pos + 1;\n\t}\n\n\tif (str == NULL) {\n\t\tstruct trace_seq seq;\nraw_field:\n\t\ttrace_seq_init(&seq);\n\t\ttep_print_field(&seq, he->raw_data, hde->field);\n\t\tstr = seq.buffer;\n\t}\n\n\tret = scnprintf(hpp->buf, hpp->size, \"%*.*s\", len, len, str);\n\tfree(str);\n\treturn ret;\n}\n\nstatic int64_t __sort__hde_cmp(struct perf_hpp_fmt *fmt,\n\t\t\t       struct hist_entry *a, struct hist_entry *b)\n{\n\tstruct hpp_dynamic_entry *hde;\n\tstruct tep_format_field *field;\n\tunsigned offset, size;\n\n\thde = container_of(fmt, struct hpp_dynamic_entry, hpp);\n\n\tfield = hde->field;\n\tif (field->flags & TEP_FIELD_IS_DYNAMIC) {\n\t\tunsigned long long dyn;\n\n\t\ttep_read_number_field(field, a->raw_data, &dyn);\n\t\toffset = dyn & 0xffff;\n\t\tsize = (dyn >> 16) & 0xffff;\n\t\tif (tep_field_is_relative(field->flags))\n\t\t\toffset += field->offset + field->size;\n\t\t \n\t\tif (size > hde->dynamic_len)\n\t\t\thde->dynamic_len = size;\n\t} else {\n\t\toffset = field->offset;\n\t\tsize = field->size;\n\t}\n\n\treturn memcmp(a->raw_data + offset, b->raw_data + offset, size);\n}\n\nbool perf_hpp__is_dynamic_entry(struct perf_hpp_fmt *fmt)\n{\n\treturn fmt->cmp == __sort__hde_cmp;\n}\n\nstatic bool __sort__hde_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)\n{\n\tstruct hpp_dynamic_entry *hde_a;\n\tstruct hpp_dynamic_entry *hde_b;\n\n\tif (!perf_hpp__is_dynamic_entry(a) || !perf_hpp__is_dynamic_entry(b))\n\t\treturn false;\n\n\thde_a = container_of(a, struct hpp_dynamic_entry, hpp);\n\thde_b = container_of(b, struct hpp_dynamic_entry, hpp);\n\n\treturn hde_a->field == hde_b->field;\n}\n\nstatic void hde_free(struct perf_hpp_fmt *fmt)\n{\n\tstruct hpp_dynamic_entry *hde;\n\n\thde = container_of(fmt, struct hpp_dynamic_entry, hpp);\n\tfree(hde);\n}\n\nstatic void __sort__hde_init(struct perf_hpp_fmt *fmt, struct hist_entry *he)\n{\n\tstruct hpp_dynamic_entry *hde;\n\n\tif (!perf_hpp__is_dynamic_entry(fmt))\n\t\treturn;\n\n\thde = container_of(fmt, struct hpp_dynamic_entry, hpp);\n\tupdate_dynamic_len(hde, he);\n}\n\nstatic struct hpp_dynamic_entry *\n__alloc_dynamic_entry(struct evsel *evsel, struct tep_format_field *field,\n\t\t      int level)\n{\n\tstruct hpp_dynamic_entry *hde;\n\n\thde = malloc(sizeof(*hde));\n\tif (hde == NULL) {\n\t\tpr_debug(\"Memory allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\n\thde->evsel = evsel;\n\thde->field = field;\n\thde->dynamic_len = 0;\n\n\thde->hpp.name = field->name;\n\thde->hpp.header = __sort__hde_header;\n\thde->hpp.width  = __sort__hde_width;\n\thde->hpp.entry  = __sort__hde_entry;\n\thde->hpp.color  = NULL;\n\n\thde->hpp.init = __sort__hde_init;\n\thde->hpp.cmp = __sort__hde_cmp;\n\thde->hpp.collapse = __sort__hde_cmp;\n\thde->hpp.sort = __sort__hde_cmp;\n\thde->hpp.equal = __sort__hde_equal;\n\thde->hpp.free = hde_free;\n\n\tINIT_LIST_HEAD(&hde->hpp.list);\n\tINIT_LIST_HEAD(&hde->hpp.sort_list);\n\thde->hpp.elide = false;\n\thde->hpp.len = 0;\n\thde->hpp.user_len = 0;\n\thde->hpp.level = level;\n\n\treturn hde;\n}\n#endif  \n\nstruct perf_hpp_fmt *perf_hpp_fmt__dup(struct perf_hpp_fmt *fmt)\n{\n\tstruct perf_hpp_fmt *new_fmt = NULL;\n\n\tif (perf_hpp__is_sort_entry(fmt)) {\n\t\tstruct hpp_sort_entry *hse, *new_hse;\n\n\t\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\t\tnew_hse = memdup(hse, sizeof(*hse));\n\t\tif (new_hse)\n\t\t\tnew_fmt = &new_hse->hpp;\n#ifdef HAVE_LIBTRACEEVENT\n\t} else if (perf_hpp__is_dynamic_entry(fmt)) {\n\t\tstruct hpp_dynamic_entry *hde, *new_hde;\n\n\t\thde = container_of(fmt, struct hpp_dynamic_entry, hpp);\n\t\tnew_hde = memdup(hde, sizeof(*hde));\n\t\tif (new_hde)\n\t\t\tnew_fmt = &new_hde->hpp;\n#endif\n\t} else {\n\t\tnew_fmt = memdup(fmt, sizeof(*fmt));\n\t}\n\n\tINIT_LIST_HEAD(&new_fmt->list);\n\tINIT_LIST_HEAD(&new_fmt->sort_list);\n\n\treturn new_fmt;\n}\n\nstatic int parse_field_name(char *str, char **event, char **field, char **opt)\n{\n\tchar *event_name, *field_name, *opt_name;\n\n\tevent_name = str;\n\tfield_name = strchr(str, '.');\n\n\tif (field_name) {\n\t\t*field_name++ = '\\0';\n\t} else {\n\t\tevent_name = NULL;\n\t\tfield_name = str;\n\t}\n\n\topt_name = strchr(field_name, '/');\n\tif (opt_name)\n\t\t*opt_name++ = '\\0';\n\n\t*event = event_name;\n\t*field = field_name;\n\t*opt   = opt_name;\n\n\treturn 0;\n}\n\n \nstatic struct evsel *find_evsel(struct evlist *evlist, char *event_name)\n{\n\tstruct evsel *evsel = NULL;\n\tstruct evsel *pos;\n\tbool full_name;\n\n\t \n\tif (event_name[0] == '%') {\n\t\tint nr = strtol(event_name+1, NULL, 0);\n\n\t\tif (nr > evlist->core.nr_entries)\n\t\t\treturn NULL;\n\n\t\tevsel = evlist__first(evlist);\n\t\twhile (--nr > 0)\n\t\t\tevsel = evsel__next(evsel);\n\n\t\treturn evsel;\n\t}\n\n\tfull_name = !!strchr(event_name, ':');\n\tevlist__for_each_entry(evlist, pos) {\n\t\t \n\t\tif (full_name && evsel__name_is(pos, event_name))\n\t\t\treturn pos;\n\t\t \n\t\tif (!full_name && strstr(pos->name, event_name)) {\n\t\t\tif (evsel) {\n\t\t\t\tpr_debug(\"'%s' event is ambiguous: it can be %s or %s\\n\",\n\t\t\t\t\t event_name, evsel->name, pos->name);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tevsel = pos;\n\t\t}\n\t}\n\n\treturn evsel;\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nstatic int __dynamic_dimension__add(struct evsel *evsel,\n\t\t\t\t    struct tep_format_field *field,\n\t\t\t\t    bool raw_trace, int level)\n{\n\tstruct hpp_dynamic_entry *hde;\n\n\thde = __alloc_dynamic_entry(evsel, field, level);\n\tif (hde == NULL)\n\t\treturn -ENOMEM;\n\n\thde->raw_trace = raw_trace;\n\n\tperf_hpp__register_sort_field(&hde->hpp);\n\treturn 0;\n}\n\nstatic int add_evsel_fields(struct evsel *evsel, bool raw_trace, int level)\n{\n\tint ret;\n\tstruct tep_format_field *field;\n\n\tfield = evsel->tp_format->format.fields;\n\twhile (field) {\n\t\tret = __dynamic_dimension__add(evsel, field, raw_trace, level);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfield = field->next;\n\t}\n\treturn 0;\n}\n\nstatic int add_all_dynamic_fields(struct evlist *evlist, bool raw_trace,\n\t\t\t\t  int level)\n{\n\tint ret;\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.type != PERF_TYPE_TRACEPOINT)\n\t\t\tcontinue;\n\n\t\tret = add_evsel_fields(evsel, raw_trace, level);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int add_all_matching_fields(struct evlist *evlist,\n\t\t\t\t   char *field_name, bool raw_trace, int level)\n{\n\tint ret = -ESRCH;\n\tstruct evsel *evsel;\n\tstruct tep_format_field *field;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.type != PERF_TYPE_TRACEPOINT)\n\t\t\tcontinue;\n\n\t\tfield = tep_find_any_field(evsel->tp_format, field_name);\n\t\tif (field == NULL)\n\t\t\tcontinue;\n\n\t\tret = __dynamic_dimension__add(evsel, field, raw_trace, level);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n#endif  \n\nstatic int add_dynamic_entry(struct evlist *evlist, const char *tok,\n\t\t\t     int level)\n{\n\tchar *str, *event_name, *field_name, *opt_name;\n\tstruct evsel *evsel;\n\tbool raw_trace = symbol_conf.raw_trace;\n\tint ret = 0;\n\n\tif (evlist == NULL)\n\t\treturn -ENOENT;\n\n\tstr = strdup(tok);\n\tif (str == NULL)\n\t\treturn -ENOMEM;\n\n\tif (parse_field_name(str, &event_name, &field_name, &opt_name) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (opt_name) {\n\t\tif (strcmp(opt_name, \"raw\")) {\n\t\t\tpr_debug(\"unsupported field option %s\\n\", opt_name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\traw_trace = true;\n\t}\n\n#ifdef HAVE_LIBTRACEEVENT\n\tif (!strcmp(field_name, \"trace_fields\")) {\n\t\tret = add_all_dynamic_fields(evlist, raw_trace, level);\n\t\tgoto out;\n\t}\n\n\tif (event_name == NULL) {\n\t\tret = add_all_matching_fields(evlist, field_name, raw_trace, level);\n\t\tgoto out;\n\t}\n#else\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.type == PERF_TYPE_TRACEPOINT) {\n\t\t\tpr_err(\"%s %s\", ret ? \",\" : \"This perf binary isn't linked with libtraceevent, can't process\", evsel__name(evsel));\n\t\t\tret = -ENOTSUP;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tpr_err(\"\\n\");\n\t\tgoto out;\n\t}\n#endif\n\n\tevsel = find_evsel(evlist, event_name);\n\tif (evsel == NULL) {\n\t\tpr_debug(\"Cannot find event: %s\\n\", event_name);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (evsel->core.attr.type != PERF_TYPE_TRACEPOINT) {\n\t\tpr_debug(\"%s is not a tracepoint event\\n\", event_name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n#ifdef HAVE_LIBTRACEEVENT\n\tif (!strcmp(field_name, \"*\")) {\n\t\tret = add_evsel_fields(evsel, raw_trace, level);\n\t} else {\n\t\tstruct tep_format_field *field = tep_find_any_field(evsel->tp_format, field_name);\n\n\t\tif (field == NULL) {\n\t\t\tpr_debug(\"Cannot find event field for %s.%s\\n\",\n\t\t\t\t event_name, field_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tret = __dynamic_dimension__add(evsel, field, raw_trace, level);\n\t}\n#else\n\t(void)level;\n\t(void)raw_trace;\n#endif  \n\nout:\n\tfree(str);\n\treturn ret;\n}\n\nstatic int __sort_dimension__add(struct sort_dimension *sd,\n\t\t\t\t struct perf_hpp_list *list,\n\t\t\t\t int level)\n{\n\tif (sd->taken)\n\t\treturn 0;\n\n\tif (__sort_dimension__add_hpp_sort(sd, list, level) < 0)\n\t\treturn -1;\n\n\tif (sd->entry->se_collapse)\n\t\tlist->need_collapse = 1;\n\n\tsd->taken = 1;\n\n\treturn 0;\n}\n\nstatic int __hpp_dimension__add(struct hpp_dimension *hd,\n\t\t\t\tstruct perf_hpp_list *list,\n\t\t\t\tint level)\n{\n\tstruct perf_hpp_fmt *fmt;\n\n\tif (hd->taken)\n\t\treturn 0;\n\n\tfmt = __hpp_dimension__alloc_hpp(hd, level);\n\tif (!fmt)\n\t\treturn -1;\n\n\thd->taken = 1;\n\tperf_hpp_list__register_sort_field(list, fmt);\n\treturn 0;\n}\n\nstatic int __sort_dimension__add_output(struct perf_hpp_list *list,\n\t\t\t\t\tstruct sort_dimension *sd)\n{\n\tif (sd->taken)\n\t\treturn 0;\n\n\tif (__sort_dimension__add_hpp_output(sd, list) < 0)\n\t\treturn -1;\n\n\tsd->taken = 1;\n\treturn 0;\n}\n\nstatic int __hpp_dimension__add_output(struct perf_hpp_list *list,\n\t\t\t\t       struct hpp_dimension *hd)\n{\n\tstruct perf_hpp_fmt *fmt;\n\n\tif (hd->taken)\n\t\treturn 0;\n\n\tfmt = __hpp_dimension__alloc_hpp(hd, 0);\n\tif (!fmt)\n\t\treturn -1;\n\n\thd->taken = 1;\n\tperf_hpp_list__column_register(list, fmt);\n\treturn 0;\n}\n\nint hpp_dimension__add_output(unsigned col)\n{\n\tBUG_ON(col >= PERF_HPP__MAX_INDEX);\n\treturn __hpp_dimension__add_output(&perf_hpp_list, &hpp_sort_dimensions[col]);\n}\n\nint sort_dimension__add(struct perf_hpp_list *list, const char *tok,\n\t\t\tstruct evlist *evlist,\n\t\t\tint level)\n{\n\tunsigned int i, j;\n\n\t \n\tfor (j = 0; j < ARRAY_SIZE(arch_specific_sort_keys); j++) {\n\t\tif (!strcmp(arch_specific_sort_keys[j], tok) &&\n\t\t\t\t!arch_support_sort_key(tok)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(common_sort_dimensions); i++) {\n\t\tstruct sort_dimension *sd = &common_sort_dimensions[i];\n\n\t\tif (!sd->name || strncasecmp(tok, sd->name, strlen(tok)))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(dynamic_headers); j++) {\n\t\t\tif (sd->name && !strcmp(dynamic_headers[j], sd->name))\n\t\t\t\tsort_dimension_add_dynamic_header(sd);\n\t\t}\n\n\t\tif (sd->entry == &sort_parent) {\n\t\t\tint ret = regcomp(&parent_regex, parent_pattern, REG_EXTENDED);\n\t\t\tif (ret) {\n\t\t\t\tchar err[BUFSIZ];\n\n\t\t\t\tregerror(ret, &parent_regex, err, sizeof(err));\n\t\t\t\tpr_err(\"Invalid regex: %s\\n%s\", parent_pattern, err);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlist->parent = 1;\n\t\t} else if (sd->entry == &sort_sym) {\n\t\t\tlist->sym = 1;\n\t\t\t \n\t\t\tif (sort__mode == SORT_MODE__DIFF)\n\t\t\t\tsd->entry->se_collapse = sort__sym_sort;\n\n\t\t} else if (sd->entry == &sort_dso) {\n\t\t\tlist->dso = 1;\n\t\t} else if (sd->entry == &sort_socket) {\n\t\t\tlist->socket = 1;\n\t\t} else if (sd->entry == &sort_thread) {\n\t\t\tlist->thread = 1;\n\t\t} else if (sd->entry == &sort_comm) {\n\t\t\tlist->comm = 1;\n\t\t}\n\n\t\treturn __sort_dimension__add(sd, list, level);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(hpp_sort_dimensions); i++) {\n\t\tstruct hpp_dimension *hd = &hpp_sort_dimensions[i];\n\n\t\tif (strncasecmp(tok, hd->name, strlen(tok)))\n\t\t\tcontinue;\n\n\t\treturn __hpp_dimension__add(hd, list, level);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(bstack_sort_dimensions); i++) {\n\t\tstruct sort_dimension *sd = &bstack_sort_dimensions[i];\n\n\t\tif (!sd->name || strncasecmp(tok, sd->name, strlen(tok)))\n\t\t\tcontinue;\n\n\t\tif (sort__mode != SORT_MODE__BRANCH)\n\t\t\treturn -EINVAL;\n\n\t\tif (sd->entry == &sort_sym_from || sd->entry == &sort_sym_to)\n\t\t\tlist->sym = 1;\n\n\t\t__sort_dimension__add(sd, list, level);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(memory_sort_dimensions); i++) {\n\t\tstruct sort_dimension *sd = &memory_sort_dimensions[i];\n\n\t\tif (!sd->name || strncasecmp(tok, sd->name, strlen(tok)))\n\t\t\tcontinue;\n\n\t\tif (sort__mode != SORT_MODE__MEMORY)\n\t\t\treturn -EINVAL;\n\n\t\tif (sd->entry == &sort_mem_dcacheline && cacheline_size() == 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (sd->entry == &sort_mem_daddr_sym)\n\t\t\tlist->sym = 1;\n\n\t\t__sort_dimension__add(sd, list, level);\n\t\treturn 0;\n\t}\n\n\tif (!add_dynamic_entry(evlist, tok, level))\n\t\treturn 0;\n\n\treturn -ESRCH;\n}\n\nstatic int setup_sort_list(struct perf_hpp_list *list, char *str,\n\t\t\t   struct evlist *evlist)\n{\n\tchar *tmp, *tok;\n\tint ret = 0;\n\tint level = 0;\n\tint next_level = 1;\n\tbool in_group = false;\n\n\tdo {\n\t\ttok = str;\n\t\ttmp = strpbrk(str, \"{}, \");\n\t\tif (tmp) {\n\t\t\tif (in_group)\n\t\t\t\tnext_level = level;\n\t\t\telse\n\t\t\t\tnext_level = level + 1;\n\n\t\t\tif (*tmp == '{')\n\t\t\t\tin_group = true;\n\t\t\telse if (*tmp == '}')\n\t\t\t\tin_group = false;\n\n\t\t\t*tmp = '\\0';\n\t\t\tstr = tmp + 1;\n\t\t}\n\n\t\tif (*tok) {\n\t\t\tret = sort_dimension__add(list, tok, evlist, level);\n\t\t\tif (ret == -EINVAL) {\n\t\t\t\tif (!cacheline_size() && !strncasecmp(tok, \"dcacheline\", strlen(tok)))\n\t\t\t\t\tui__error(\"The \\\"dcacheline\\\" --sort key needs to know the cacheline size and it couldn't be determined on this system\");\n\t\t\t\telse\n\t\t\t\t\tui__error(\"Invalid --sort key: `%s'\", tok);\n\t\t\t\tbreak;\n\t\t\t} else if (ret == -ESRCH) {\n\t\t\t\tui__error(\"Unknown --sort key: `%s'\", tok);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlevel = next_level;\n\t} while (tmp);\n\n\treturn ret;\n}\n\nstatic const char *get_default_sort_order(struct evlist *evlist)\n{\n\tconst char *default_sort_orders[] = {\n\t\tdefault_sort_order,\n\t\tdefault_branch_sort_order,\n\t\tdefault_mem_sort_order,\n\t\tdefault_top_sort_order,\n\t\tdefault_diff_sort_order,\n\t\tdefault_tracepoint_sort_order,\n\t};\n\tbool use_trace = true;\n\tstruct evsel *evsel;\n\n\tBUG_ON(sort__mode >= ARRAY_SIZE(default_sort_orders));\n\n\tif (evlist == NULL || evlist__empty(evlist))\n\t\tgoto out_no_evlist;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.type != PERF_TYPE_TRACEPOINT) {\n\t\t\tuse_trace = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (use_trace) {\n\t\tsort__mode = SORT_MODE__TRACEPOINT;\n\t\tif (symbol_conf.raw_trace)\n\t\t\treturn \"trace_fields\";\n\t}\nout_no_evlist:\n\treturn default_sort_orders[sort__mode];\n}\n\nstatic int setup_sort_order(struct evlist *evlist)\n{\n\tchar *new_sort_order;\n\n\t \n\tif (!sort_order || is_strict_order(sort_order))\n\t\treturn 0;\n\n\tif (sort_order[1] == '\\0') {\n\t\tui__error(\"Invalid --sort key: `+'\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (asprintf(&new_sort_order, \"%s,%s\",\n\t\t     get_default_sort_order(evlist), sort_order + 1) < 0) {\n\t\tpr_err(\"Not enough memory to set up --sort\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsort_order = new_sort_order;\n\treturn 0;\n}\n\n \nstatic char *prefix_if_not_in(const char *pre, char *str)\n{\n\tchar *n;\n\n\tif (!str || strstr(str, pre))\n\t\treturn str;\n\n\tif (asprintf(&n, \"%s,%s\", pre, str) < 0)\n\t\tn = NULL;\n\n\tfree(str);\n\treturn n;\n}\n\nstatic char *setup_overhead(char *keys)\n{\n\tif (sort__mode == SORT_MODE__DIFF)\n\t\treturn keys;\n\n\tkeys = prefix_if_not_in(\"overhead\", keys);\n\n\tif (symbol_conf.cumulate_callchain)\n\t\tkeys = prefix_if_not_in(\"overhead_children\", keys);\n\n\treturn keys;\n}\n\nstatic int __setup_sorting(struct evlist *evlist)\n{\n\tchar *str;\n\tconst char *sort_keys;\n\tint ret = 0;\n\n\tret = setup_sort_order(evlist);\n\tif (ret)\n\t\treturn ret;\n\n\tsort_keys = sort_order;\n\tif (sort_keys == NULL) {\n\t\tif (is_strict_order(field_order)) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\n\t\tsort_keys = get_default_sort_order(evlist);\n\t}\n\n\tstr = strdup(sort_keys);\n\tif (str == NULL) {\n\t\tpr_err(\"Not enough memory to setup sort keys\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (!is_strict_order(field_order)) {\n\t\tstr = setup_overhead(str);\n\t\tif (str == NULL) {\n\t\t\tpr_err(\"Not enough memory to setup overhead keys\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tret = setup_sort_list(&perf_hpp_list, str, evlist);\n\n\tfree(str);\n\treturn ret;\n}\n\nvoid perf_hpp__set_elide(int idx, bool elide)\n{\n\tstruct perf_hpp_fmt *fmt;\n\tstruct hpp_sort_entry *hse;\n\n\tperf_hpp_list__for_each_format(&perf_hpp_list, fmt) {\n\t\tif (!perf_hpp__is_sort_entry(fmt))\n\t\t\tcontinue;\n\n\t\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\t\tif (hse->se->se_width_idx == idx) {\n\t\t\tfmt->elide = elide;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic bool __get_elide(struct strlist *list, const char *list_name, FILE *fp)\n{\n\tif (list && strlist__nr_entries(list) == 1) {\n\t\tif (fp != NULL)\n\t\t\tfprintf(fp, \"# %s: %s\\n\", list_name,\n\t\t\t\tstrlist__entry(list, 0)->s);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool get_elide(int idx, FILE *output)\n{\n\tswitch (idx) {\n\tcase HISTC_SYMBOL:\n\t\treturn __get_elide(symbol_conf.sym_list, \"symbol\", output);\n\tcase HISTC_DSO:\n\t\treturn __get_elide(symbol_conf.dso_list, \"dso\", output);\n\tcase HISTC_COMM:\n\t\treturn __get_elide(symbol_conf.comm_list, \"comm\", output);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sort__mode != SORT_MODE__BRANCH)\n\t\treturn false;\n\n\tswitch (idx) {\n\tcase HISTC_SYMBOL_FROM:\n\t\treturn __get_elide(symbol_conf.sym_from_list, \"sym_from\", output);\n\tcase HISTC_SYMBOL_TO:\n\t\treturn __get_elide(symbol_conf.sym_to_list, \"sym_to\", output);\n\tcase HISTC_DSO_FROM:\n\t\treturn __get_elide(symbol_conf.dso_from_list, \"dso_from\", output);\n\tcase HISTC_DSO_TO:\n\t\treturn __get_elide(symbol_conf.dso_to_list, \"dso_to\", output);\n\tcase HISTC_ADDR_FROM:\n\t\treturn __get_elide(symbol_conf.sym_from_list, \"addr_from\", output);\n\tcase HISTC_ADDR_TO:\n\t\treturn __get_elide(symbol_conf.sym_to_list, \"addr_to\", output);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nvoid sort__setup_elide(FILE *output)\n{\n\tstruct perf_hpp_fmt *fmt;\n\tstruct hpp_sort_entry *hse;\n\n\tperf_hpp_list__for_each_format(&perf_hpp_list, fmt) {\n\t\tif (!perf_hpp__is_sort_entry(fmt))\n\t\t\tcontinue;\n\n\t\thse = container_of(fmt, struct hpp_sort_entry, hpp);\n\t\tfmt->elide = get_elide(hse->se->se_width_idx, output);\n\t}\n\n\t \n\tperf_hpp_list__for_each_format(&perf_hpp_list, fmt) {\n\t\tif (!perf_hpp__is_sort_entry(fmt))\n\t\t\tcontinue;\n\n\t\tif (!fmt->elide)\n\t\t\treturn;\n\t}\n\n\tperf_hpp_list__for_each_format(&perf_hpp_list, fmt) {\n\t\tif (!perf_hpp__is_sort_entry(fmt))\n\t\t\tcontinue;\n\n\t\tfmt->elide = false;\n\t}\n}\n\nint output_field_add(struct perf_hpp_list *list, char *tok)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(common_sort_dimensions); i++) {\n\t\tstruct sort_dimension *sd = &common_sort_dimensions[i];\n\n\t\tif (!sd->name || strncasecmp(tok, sd->name, strlen(tok)))\n\t\t\tcontinue;\n\n\t\treturn __sort_dimension__add_output(list, sd);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(hpp_sort_dimensions); i++) {\n\t\tstruct hpp_dimension *hd = &hpp_sort_dimensions[i];\n\n\t\tif (strncasecmp(tok, hd->name, strlen(tok)))\n\t\t\tcontinue;\n\n\t\treturn __hpp_dimension__add_output(list, hd);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(bstack_sort_dimensions); i++) {\n\t\tstruct sort_dimension *sd = &bstack_sort_dimensions[i];\n\n\t\tif (!sd->name || strncasecmp(tok, sd->name, strlen(tok)))\n\t\t\tcontinue;\n\n\t\tif (sort__mode != SORT_MODE__BRANCH)\n\t\t\treturn -EINVAL;\n\n\t\treturn __sort_dimension__add_output(list, sd);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(memory_sort_dimensions); i++) {\n\t\tstruct sort_dimension *sd = &memory_sort_dimensions[i];\n\n\t\tif (!sd->name || strncasecmp(tok, sd->name, strlen(tok)))\n\t\t\tcontinue;\n\n\t\tif (sort__mode != SORT_MODE__MEMORY)\n\t\t\treturn -EINVAL;\n\n\t\treturn __sort_dimension__add_output(list, sd);\n\t}\n\n\treturn -ESRCH;\n}\n\nstatic int setup_output_list(struct perf_hpp_list *list, char *str)\n{\n\tchar *tmp, *tok;\n\tint ret = 0;\n\n\tfor (tok = strtok_r(str, \", \", &tmp);\n\t\t\ttok; tok = strtok_r(NULL, \", \", &tmp)) {\n\t\tret = output_field_add(list, tok);\n\t\tif (ret == -EINVAL) {\n\t\t\tui__error(\"Invalid --fields key: `%s'\", tok);\n\t\t\tbreak;\n\t\t} else if (ret == -ESRCH) {\n\t\t\tui__error(\"Unknown --fields key: `%s'\", tok);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid reset_dimensions(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(common_sort_dimensions); i++)\n\t\tcommon_sort_dimensions[i].taken = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(hpp_sort_dimensions); i++)\n\t\thpp_sort_dimensions[i].taken = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(bstack_sort_dimensions); i++)\n\t\tbstack_sort_dimensions[i].taken = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(memory_sort_dimensions); i++)\n\t\tmemory_sort_dimensions[i].taken = 0;\n}\n\nbool is_strict_order(const char *order)\n{\n\treturn order && (*order != '+');\n}\n\nstatic int __setup_output_field(void)\n{\n\tchar *str, *strp;\n\tint ret = -EINVAL;\n\n\tif (field_order == NULL)\n\t\treturn 0;\n\n\tstrp = str = strdup(field_order);\n\tif (str == NULL) {\n\t\tpr_err(\"Not enough memory to setup output fields\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!is_strict_order(field_order))\n\t\tstrp++;\n\n\tif (!strlen(strp)) {\n\t\tui__error(\"Invalid --fields key: `+'\");\n\t\tgoto out;\n\t}\n\n\tret = setup_output_list(&perf_hpp_list, strp);\n\nout:\n\tfree(str);\n\treturn ret;\n}\n\nint setup_sorting(struct evlist *evlist)\n{\n\tint err;\n\n\terr = __setup_sorting(evlist);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (parent_pattern != default_parent_pattern) {\n\t\terr = sort_dimension__add(&perf_hpp_list, \"parent\", evlist, -1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treset_dimensions();\n\n\t \n\tif (sort__mode != SORT_MODE__DIFF)\n\t\tperf_hpp__init();\n\n\terr = __setup_output_field();\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tperf_hpp__setup_output_field(&perf_hpp_list);\n\t \n\tperf_hpp__append_sort_keys(&perf_hpp_list);\n\n\t \n\tif (perf_hpp__setup_hists_formats(&perf_hpp_list, evlist) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nvoid reset_output_field(void)\n{\n\tperf_hpp_list.need_collapse = 0;\n\tperf_hpp_list.parent = 0;\n\tperf_hpp_list.sym = 0;\n\tperf_hpp_list.dso = 0;\n\n\tfield_order = NULL;\n\tsort_order = NULL;\n\n\treset_dimensions();\n\tperf_hpp__reset_output_field(&perf_hpp_list);\n}\n\n#define INDENT (3*8 + 1)\n\nstatic void add_key(struct strbuf *sb, const char *str, int *llen)\n{\n\tif (!str)\n\t\treturn;\n\n\tif (*llen >= 75) {\n\t\tstrbuf_addstr(sb, \"\\n\\t\\t\\t \");\n\t\t*llen = INDENT;\n\t}\n\tstrbuf_addf(sb, \" %s\", str);\n\t*llen += strlen(str) + 1;\n}\n\nstatic void add_sort_string(struct strbuf *sb, struct sort_dimension *s, int n,\n\t\t\t    int *llen)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tadd_key(sb, s[i].name, llen);\n}\n\nstatic void add_hpp_sort_string(struct strbuf *sb, struct hpp_dimension *s, int n,\n\t\t\t\tint *llen)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tadd_key(sb, s[i].name, llen);\n}\n\nchar *sort_help(const char *prefix)\n{\n\tstruct strbuf sb;\n\tchar *s;\n\tint len = strlen(prefix) + INDENT;\n\n\tstrbuf_init(&sb, 300);\n\tstrbuf_addstr(&sb, prefix);\n\tadd_hpp_sort_string(&sb, hpp_sort_dimensions,\n\t\t\t    ARRAY_SIZE(hpp_sort_dimensions), &len);\n\tadd_sort_string(&sb, common_sort_dimensions,\n\t\t\t    ARRAY_SIZE(common_sort_dimensions), &len);\n\tadd_sort_string(&sb, bstack_sort_dimensions,\n\t\t\t    ARRAY_SIZE(bstack_sort_dimensions), &len);\n\tadd_sort_string(&sb, memory_sort_dimensions,\n\t\t\t    ARRAY_SIZE(memory_sort_dimensions), &len);\n\ts = strbuf_detach(&sb, NULL);\n\tstrbuf_release(&sb);\n\treturn s;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}