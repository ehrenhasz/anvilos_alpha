{
  "module_name": "string.c",
  "hash_id": "28aa752760a0264c24b65e6cd78594e208cbee27ff801892801fe1f60e9a885e",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/string.c",
  "human_readable_source": "\n#include \"string2.h\"\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <stdlib.h>\n\n#include <linux/ctype.h>\n\nconst char *graph_dotted_line =\n\t\"---------------------------------------------------------------------\"\n\t\"---------------------------------------------------------------------\"\n\t\"---------------------------------------------------------------------\";\nconst char *dots =\n\t\".....................................................................\"\n\t\".....................................................................\"\n\t\".....................................................................\";\n\n \ns64 perf_atoll(const char *str)\n{\n\ts64 length;\n\tchar *p;\n\tchar c;\n\n\tif (!isdigit(str[0]))\n\t\tgoto out_err;\n\n\tlength = strtoll(str, &p, 10);\n\tswitch (c = *p++) {\n\t\tcase 'b': case 'B':\n\t\t\tif (*p)\n\t\t\t\tgoto out_err;\n\n\t\t\tfallthrough;\n\t\tcase '\\0':\n\t\t\treturn length;\n\t\tdefault:\n\t\t\tgoto out_err;\n\t\t \n\t\tcase 'k': case 'K':\n\t\t\tlength <<= 10;\n\t\t\tbreak;\n\t\tcase 'm': case 'M':\n\t\t\tlength <<= 20;\n\t\t\tbreak;\n\t\tcase 'g': case 'G':\n\t\t\tlength <<= 30;\n\t\t\tbreak;\n\t\tcase 't': case 'T':\n\t\t\tlength <<= 40;\n\t\t\tbreak;\n\t}\n\t \n\tif (islower(c)) {\n\t\tif (strcmp(p, \"b\") != 0)\n\t\t\tgoto out_err;\n\t} else {\n\t\tif (strcmp(p, \"B\") != 0)\n\t\t\tgoto out_err;\n\t}\n\treturn length;\n\nout_err:\n\treturn -1;\n}\n\n \nstatic bool __match_charclass(const char *pat, char c, const char **npat)\n{\n\tbool complement = false, ret = true;\n\n\tif (*pat == '!') {\n\t\tcomplement = true;\n\t\tpat++;\n\t}\n\tif (*pat++ == c)\t \n\t\tgoto end;\n\n\twhile (*pat && *pat != ']') {\t \n\t\tif (*pat == '-' && *(pat + 1) != ']') {\t \n\t\t\tif (*(pat - 1) <= c && c <= *(pat + 1))\n\t\t\t\tgoto end;\n\t\t\tif (*(pat - 1) > *(pat + 1))\n\t\t\t\tgoto error;\n\t\t\tpat += 2;\n\t\t} else if (*pat++ == c)\n\t\t\tgoto end;\n\t}\n\tif (!*pat)\n\t\tgoto error;\n\tret = false;\n\nend:\n\twhile (*pat && *pat != ']')\t \n\t\tpat++;\n\tif (!*pat)\n\t\tgoto error;\n\t*npat = pat + 1;\n\treturn complement ? !ret : ret;\n\nerror:\n\treturn false;\n}\n\n \nstatic bool __match_glob(const char *str, const char *pat, bool ignore_space,\n\t\t\tbool case_ins)\n{\n\twhile (*str && *pat && *pat != '*') {\n\t\tif (ignore_space) {\n\t\t\t \n\t\t\tif (isspace(*str)) {\n\t\t\t\tstr++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isspace(*pat)) {\n\t\t\t\tpat++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (*pat == '?') {\t \n\t\t\tstr++;\n\t\t\tpat++;\n\t\t\tcontinue;\n\t\t} else if (*pat == '[')\t \n\t\t\tif (__match_charclass(pat + 1, *str, &pat)) {\n\t\t\t\tstr++;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\telse if (*pat == '\\\\')  \n\t\t\tpat++;\n\t\tif (case_ins) {\n\t\t\tif (tolower(*str) != tolower(*pat))\n\t\t\t\treturn false;\n\t\t} else if (*str != *pat)\n\t\t\treturn false;\n\t\tstr++;\n\t\tpat++;\n\t}\n\t \n\tif (*pat == '*') {\n\t\twhile (*pat == '*')\n\t\t\tpat++;\n\t\tif (!*pat)\t \n\t\t\treturn true;\n\t\twhile (*str)\n\t\t\tif (__match_glob(str++, pat, ignore_space, case_ins))\n\t\t\t\treturn true;\n\t}\n\treturn !*str && !*pat;\n}\n\n \nbool strglobmatch(const char *str, const char *pat)\n{\n\treturn __match_glob(str, pat, false, false);\n}\n\nbool strglobmatch_nocase(const char *str, const char *pat)\n{\n\treturn __match_glob(str, pat, false, true);\n}\n\n \nbool strlazymatch(const char *str, const char *pat)\n{\n\treturn __match_glob(str, pat, true, false);\n}\n\n \nint strtailcmp(const char *s1, const char *s2)\n{\n\tint i1 = strlen(s1);\n\tint i2 = strlen(s2);\n\twhile (--i1 >= 0 && --i2 >= 0) {\n\t\tif (s1[i1] != s2[i2])\n\t\t\treturn s1[i1] - s2[i2];\n\t}\n\treturn 0;\n}\n\nchar *asprintf_expr_inout_ints(const char *var, bool in, size_t nints, int *ints)\n{\n\t \n\tsize_t size = nints * 28 + 1;  \n\tsize_t i, printed = 0;\n\tchar *expr = malloc(size);\n\n\tif (expr) {\n\t\tconst char *or_and = \"||\", *eq_neq = \"==\";\n\t\tchar *e = expr;\n\n\t\tif (!in) {\n\t\t\tor_and = \"&&\";\n\t\t\teq_neq = \"!=\";\n\t\t}\n\n\t\tfor (i = 0; i < nints; ++i) {\n\t\t\tif (printed == size)\n\t\t\t\tgoto out_err_overflow;\n\n\t\t\tif (i > 0)\n\t\t\t\tprinted += scnprintf(e + printed, size - printed, \" %s \", or_and);\n\t\t\tprinted += scnprintf(e + printed, size - printed,\n\t\t\t\t\t     \"%s %s %d\", var, eq_neq, ints[i]);\n\t\t}\n\t}\n\n\treturn expr;\n\nout_err_overflow:\n\tfree(expr);\n\treturn NULL;\n}\n\n \nchar *strpbrk_esc(char *str, const char *stopset)\n{\n\tchar *ptr;\n\n\tdo {\n\t\tptr = strpbrk(str, stopset);\n\t\tif (ptr == str ||\n\t\t    (ptr == str + 1 && *(ptr - 1) != '\\\\'))\n\t\t\tbreak;\n\t\tstr = ptr + 1;\n\t} while (ptr && *(ptr - 1) == '\\\\' && *(ptr - 2) != '\\\\');\n\n\treturn ptr;\n}\n\n \nchar *strdup_esc(const char *str)\n{\n\tchar *s, *d, *p, *ret = strdup(str);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\td = strchr(ret, '\\\\');\n\tif (!d)\n\t\treturn ret;\n\n\ts = d + 1;\n\tdo {\n\t\tif (*s == '\\0') {\n\t\t\t*d = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\tp = strchr(s + 1, '\\\\');\n\t\tif (p) {\n\t\t\tmemmove(d, s, p - s);\n\t\t\td += p - s;\n\t\t\ts = p + 1;\n\t\t} else\n\t\t\tmemmove(d, s, strlen(s) + 1);\n\t} while (p);\n\n\treturn ret;\n}\n\nunsigned int hex(char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\tif (c >= 'a' && c <= 'f')\n\t\treturn c - 'a' + 10;\n\treturn c - 'A' + 10;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}