{
  "module_name": "dsos.c",
  "hash_id": "fc16bb4ceca71511644e2a260faff21687f85907c0c8c95cfc6ab2f849f5de8e",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/dsos.c",
  "human_readable_source": "\n#include \"debug.h\"\n#include \"dsos.h\"\n#include \"dso.h\"\n#include \"util.h\"\n#include \"vdso.h\"\n#include \"namespaces.h\"\n#include <errno.h>\n#include <libgen.h>\n#include <stdlib.h>\n#include <string.h>\n#include <symbol.h> \n#include <unistd.h>\n\nstatic int __dso_id__cmp(struct dso_id *a, struct dso_id *b)\n{\n\tif (a->maj > b->maj) return -1;\n\tif (a->maj < b->maj) return 1;\n\n\tif (a->min > b->min) return -1;\n\tif (a->min < b->min) return 1;\n\n\tif (a->ino > b->ino) return -1;\n\tif (a->ino < b->ino) return 1;\n\n\t \n\tif (a->ino_generation && b->ino_generation) {\n\t\tif (a->ino_generation > b->ino_generation) return -1;\n\t\tif (a->ino_generation < b->ino_generation) return 1;\n\t}\n\n\treturn 0;\n}\n\nstatic bool dso_id__empty(struct dso_id *id)\n{\n\tif (!id)\n\t\treturn true;\n\n\treturn !id->maj && !id->min && !id->ino && !id->ino_generation;\n}\n\nstatic void dso__inject_id(struct dso *dso, struct dso_id *id)\n{\n\tdso->id.maj = id->maj;\n\tdso->id.min = id->min;\n\tdso->id.ino = id->ino;\n\tdso->id.ino_generation = id->ino_generation;\n}\n\nstatic int dso_id__cmp(struct dso_id *a, struct dso_id *b)\n{\n\t \n\tif (dso_id__empty(a) || dso_id__empty(b))\n\t\treturn 0;\n\n\treturn __dso_id__cmp(a, b);\n}\n\nint dso__cmp_id(struct dso *a, struct dso *b)\n{\n\treturn __dso_id__cmp(&a->id, &b->id);\n}\n\nbool __dsos__read_build_ids(struct list_head *head, bool with_hits)\n{\n\tbool have_build_id = false;\n\tstruct dso *pos;\n\tstruct nscookie nsc;\n\n\tlist_for_each_entry(pos, head, node) {\n\t\tif (with_hits && !pos->hit && !dso__is_vdso(pos))\n\t\t\tcontinue;\n\t\tif (pos->has_build_id) {\n\t\t\thave_build_id = true;\n\t\t\tcontinue;\n\t\t}\n\t\tnsinfo__mountns_enter(pos->nsinfo, &nsc);\n\t\tif (filename__read_build_id(pos->long_name, &pos->bid) > 0) {\n\t\t\thave_build_id\t  = true;\n\t\t\tpos->has_build_id = true;\n\t\t} else if (errno == ENOENT && pos->nsinfo) {\n\t\t\tchar *new_name = dso__filename_with_chroot(pos, pos->long_name);\n\n\t\t\tif (new_name && filename__read_build_id(new_name,\n\t\t\t\t\t\t\t\t&pos->bid) > 0) {\n\t\t\t\thave_build_id = true;\n\t\t\t\tpos->has_build_id = true;\n\t\t\t}\n\t\t\tfree(new_name);\n\t\t}\n\t\tnsinfo__mountns_exit(&nsc);\n\t}\n\n\treturn have_build_id;\n}\n\nstatic int __dso__cmp_long_name(const char *long_name, struct dso_id *id, struct dso *b)\n{\n\tint rc = strcmp(long_name, b->long_name);\n\treturn rc ?: dso_id__cmp(id, &b->id);\n}\n\nstatic int __dso__cmp_short_name(const char *short_name, struct dso_id *id, struct dso *b)\n{\n\tint rc = strcmp(short_name, b->short_name);\n\treturn rc ?: dso_id__cmp(id, &b->id);\n}\n\nstatic int dso__cmp_short_name(struct dso *a, struct dso *b)\n{\n\treturn __dso__cmp_short_name(a->short_name, &a->id, b);\n}\n\n \nstruct dso *__dsos__findnew_link_by_longname_id(struct rb_root *root, struct dso *dso,\n\t\t\t\t\t\tconst char *name, struct dso_id *id)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node  *parent = NULL;\n\n\tif (!name)\n\t\tname = dso->long_name;\n\t \n\twhile (*p) {\n\t\tstruct dso *this = rb_entry(*p, struct dso, rb_node);\n\t\tint rc = __dso__cmp_long_name(name, id, this);\n\n\t\tparent = *p;\n\t\tif (rc == 0) {\n\t\t\t \n\t\t\tif (!dso || (dso == this))\n\t\t\t\treturn this;\t \n\t\t\t \n\t\t\trc = dso__cmp_short_name(dso, this);\n\t\t\tif (rc == 0) {\n\t\t\t\tpr_err(\"Duplicated dso name: %s\\n\", name);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tif (rc < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\t}\n\tif (dso) {\n\t\t \n\t\trb_link_node(&dso->rb_node, parent, p);\n\t\trb_insert_color(&dso->rb_node, root);\n\t\tdso->root = root;\n\t}\n\treturn NULL;\n}\n\nvoid __dsos__add(struct dsos *dsos, struct dso *dso)\n{\n\tlist_add_tail(&dso->node, &dsos->head);\n\t__dsos__findnew_link_by_longname_id(&dsos->root, dso, NULL, &dso->id);\n\t \n\tdso__get(dso);\n}\n\nvoid dsos__add(struct dsos *dsos, struct dso *dso)\n{\n\tdown_write(&dsos->lock);\n\t__dsos__add(dsos, dso);\n\tup_write(&dsos->lock);\n}\n\nstatic struct dso *__dsos__findnew_by_longname_id(struct rb_root *root, const char *name, struct dso_id *id)\n{\n\treturn __dsos__findnew_link_by_longname_id(root, NULL, name, id);\n}\n\nstatic struct dso *__dsos__find_id(struct dsos *dsos, const char *name, struct dso_id *id, bool cmp_short)\n{\n\tstruct dso *pos;\n\n\tif (cmp_short) {\n\t\tlist_for_each_entry(pos, &dsos->head, node)\n\t\t\tif (__dso__cmp_short_name(name, id, pos) == 0)\n\t\t\t\treturn pos;\n\t\treturn NULL;\n\t}\n\treturn __dsos__findnew_by_longname_id(&dsos->root, name, id);\n}\n\nstruct dso *__dsos__find(struct dsos *dsos, const char *name, bool cmp_short)\n{\n\treturn __dsos__find_id(dsos, name, NULL, cmp_short);\n}\n\nstatic void dso__set_basename(struct dso *dso)\n{\n\tchar *base, *lname;\n\tint tid;\n\n\tif (sscanf(dso->long_name, \"/tmp/perf-%d.map\", &tid) == 1) {\n\t\tif (asprintf(&base, \"[JIT] tid %d\", tid) < 0)\n\t\t\treturn;\n\t} else {\n\t       \n\t\tlname = strdup(dso->long_name);\n\t\tif (!lname)\n\t\t\treturn;\n\n\t\t \n\t\tbase = strdup(basename(lname));\n\n\t\tfree(lname);\n\n\t\tif (!base)\n\t\t\treturn;\n\t}\n\tdso__set_short_name(dso, base, true);\n}\n\nstatic struct dso *__dsos__addnew_id(struct dsos *dsos, const char *name, struct dso_id *id)\n{\n\tstruct dso *dso = dso__new_id(name, id);\n\n\tif (dso != NULL) {\n\t\t__dsos__add(dsos, dso);\n\t\tdso__set_basename(dso);\n\t\t \n\t\tdso__put(dso);\n\t}\n\treturn dso;\n}\n\nstruct dso *__dsos__addnew(struct dsos *dsos, const char *name)\n{\n\treturn __dsos__addnew_id(dsos, name, NULL);\n}\n\nstatic struct dso *__dsos__findnew_id(struct dsos *dsos, const char *name, struct dso_id *id)\n{\n\tstruct dso *dso = __dsos__find_id(dsos, name, id, false);\n\n\tif (dso && dso_id__empty(&dso->id) && !dso_id__empty(id))\n\t\tdso__inject_id(dso, id);\n\n\treturn dso ? dso : __dsos__addnew_id(dsos, name, id);\n}\n\nstruct dso *dsos__findnew_id(struct dsos *dsos, const char *name, struct dso_id *id)\n{\n\tstruct dso *dso;\n\tdown_write(&dsos->lock);\n\tdso = dso__get(__dsos__findnew_id(dsos, name, id));\n\tup_write(&dsos->lock);\n\treturn dso;\n}\n\nsize_t __dsos__fprintf_buildid(struct list_head *head, FILE *fp,\n\t\t\t       bool (skip)(struct dso *dso, int parm), int parm)\n{\n\tstruct dso *pos;\n\tsize_t ret = 0;\n\n\tlist_for_each_entry(pos, head, node) {\n\t\tchar sbuild_id[SBUILD_ID_SIZE];\n\n\t\tif (skip && skip(pos, parm))\n\t\t\tcontinue;\n\t\tbuild_id__sprintf(&pos->bid, sbuild_id);\n\t\tret += fprintf(fp, \"%-40s %s\\n\", sbuild_id, pos->long_name);\n\t}\n\treturn ret;\n}\n\nsize_t __dsos__fprintf(struct list_head *head, FILE *fp)\n{\n\tstruct dso *pos;\n\tsize_t ret = 0;\n\n\tlist_for_each_entry(pos, head, node) {\n\t\tret += dso__fprintf(pos, fp);\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}