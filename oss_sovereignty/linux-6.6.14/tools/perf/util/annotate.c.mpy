{
  "module_name": "annotate.c",
  "hash_id": "23758b342aeb8891da11e8c497af180fa1a2c5cd0bcd9a049675a10d4f729abe",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/annotate.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <inttypes.h>\n#include <libgen.h>\n#include <stdlib.h>\n#include \"util.h\" \n#include \"ui/ui.h\"\n#include \"sort.h\"\n#include \"build-id.h\"\n#include \"color.h\"\n#include \"config.h\"\n#include \"dso.h\"\n#include \"env.h\"\n#include \"map.h\"\n#include \"maps.h\"\n#include \"symbol.h\"\n#include \"srcline.h\"\n#include \"units.h\"\n#include \"debug.h\"\n#include \"annotate.h\"\n#include \"evsel.h\"\n#include \"evlist.h\"\n#include \"bpf-event.h\"\n#include \"bpf-utils.h\"\n#include \"block-range.h\"\n#include \"string2.h\"\n#include \"util/event.h\"\n#include \"util/sharded_mutex.h\"\n#include \"arch/common.h\"\n#include \"namespaces.h\"\n#include <regex.h>\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <subcmd/parse-options.h>\n#include <subcmd/run-command.h>\n\n \n#include \"ui/browser.h\"\n\n \n#define LARROW_CHAR\t((unsigned char)',')\n#define RARROW_CHAR\t((unsigned char)'+')\n#define DARROW_CHAR\t((unsigned char)'.')\n#define UARROW_CHAR\t((unsigned char)'-')\n\n#include <linux/ctype.h>\n\nstatic regex_t\t file_lineno;\n\nstatic struct ins_ops *ins__find(struct arch *arch, const char *name);\nstatic void ins__sort(struct arch *arch);\nstatic int disasm_line__parse(char *line, const char **namep, char **rawp);\nstatic int call__scnprintf(struct ins *ins, char *bf, size_t size,\n\t\t\t  struct ins_operands *ops, int max_ins_name);\nstatic int jump__scnprintf(struct ins *ins, char *bf, size_t size,\n\t\t\t  struct ins_operands *ops, int max_ins_name);\n\nstruct arch {\n\tconst char\t*name;\n\tstruct ins\t*instructions;\n\tsize_t\t\tnr_instructions;\n\tsize_t\t\tnr_instructions_allocated;\n\tstruct ins_ops  *(*associate_instruction_ops)(struct arch *arch, const char *name);\n\tbool\t\tsorted_instructions;\n\tbool\t\tinitialized;\n\tconst char\t*insn_suffix;\n\tvoid\t\t*priv;\n\tunsigned int\tmodel;\n\tunsigned int\tfamily;\n\tint\t\t(*init)(struct arch *arch, char *cpuid);\n\tbool\t\t(*ins_is_fused)(struct arch *arch, const char *ins1,\n\t\t\t\t\tconst char *ins2);\n\tstruct\t\t{\n\t\tchar comment_char;\n\t\tchar skip_functions_char;\n\t} objdump;\n};\n\nstatic struct ins_ops call_ops;\nstatic struct ins_ops dec_ops;\nstatic struct ins_ops jump_ops;\nstatic struct ins_ops mov_ops;\nstatic struct ins_ops nop_ops;\nstatic struct ins_ops lock_ops;\nstatic struct ins_ops ret_ops;\n\nstatic int arch__grow_instructions(struct arch *arch)\n{\n\tstruct ins *new_instructions;\n\tsize_t new_nr_allocated;\n\n\tif (arch->nr_instructions_allocated == 0 && arch->instructions)\n\t\tgoto grow_from_non_allocated_table;\n\n\tnew_nr_allocated = arch->nr_instructions_allocated + 128;\n\tnew_instructions = realloc(arch->instructions, new_nr_allocated * sizeof(struct ins));\n\tif (new_instructions == NULL)\n\t\treturn -1;\n\nout_update_instructions:\n\tarch->instructions = new_instructions;\n\tarch->nr_instructions_allocated = new_nr_allocated;\n\treturn 0;\n\ngrow_from_non_allocated_table:\n\tnew_nr_allocated = arch->nr_instructions + 128;\n\tnew_instructions = calloc(new_nr_allocated, sizeof(struct ins));\n\tif (new_instructions == NULL)\n\t\treturn -1;\n\n\tmemcpy(new_instructions, arch->instructions, arch->nr_instructions);\n\tgoto out_update_instructions;\n}\n\nstatic int arch__associate_ins_ops(struct arch* arch, const char *name, struct ins_ops *ops)\n{\n\tstruct ins *ins;\n\n\tif (arch->nr_instructions == arch->nr_instructions_allocated &&\n\t    arch__grow_instructions(arch))\n\t\treturn -1;\n\n\tins = &arch->instructions[arch->nr_instructions];\n\tins->name = strdup(name);\n\tif (!ins->name)\n\t\treturn -1;\n\n\tins->ops  = ops;\n\tarch->nr_instructions++;\n\n\tins__sort(arch);\n\treturn 0;\n}\n\n#include \"arch/arc/annotate/instructions.c\"\n#include \"arch/arm/annotate/instructions.c\"\n#include \"arch/arm64/annotate/instructions.c\"\n#include \"arch/csky/annotate/instructions.c\"\n#include \"arch/loongarch/annotate/instructions.c\"\n#include \"arch/mips/annotate/instructions.c\"\n#include \"arch/x86/annotate/instructions.c\"\n#include \"arch/powerpc/annotate/instructions.c\"\n#include \"arch/riscv64/annotate/instructions.c\"\n#include \"arch/s390/annotate/instructions.c\"\n#include \"arch/sparc/annotate/instructions.c\"\n\nstatic struct arch architectures[] = {\n\t{\n\t\t.name = \"arc\",\n\t\t.init = arc__annotate_init,\n\t},\n\t{\n\t\t.name = \"arm\",\n\t\t.init = arm__annotate_init,\n\t},\n\t{\n\t\t.name = \"arm64\",\n\t\t.init = arm64__annotate_init,\n\t},\n\t{\n\t\t.name = \"csky\",\n\t\t.init = csky__annotate_init,\n\t},\n\t{\n\t\t.name = \"mips\",\n\t\t.init = mips__annotate_init,\n\t\t.objdump = {\n\t\t\t.comment_char = '#',\n\t\t},\n\t},\n\t{\n\t\t.name = \"x86\",\n\t\t.init = x86__annotate_init,\n\t\t.instructions = x86__instructions,\n\t\t.nr_instructions = ARRAY_SIZE(x86__instructions),\n\t\t.insn_suffix = \"bwlq\",\n\t\t.objdump =  {\n\t\t\t.comment_char = '#',\n\t\t},\n\t},\n\t{\n\t\t.name = \"powerpc\",\n\t\t.init = powerpc__annotate_init,\n\t},\n\t{\n\t\t.name = \"riscv64\",\n\t\t.init = riscv64__annotate_init,\n\t},\n\t{\n\t\t.name = \"s390\",\n\t\t.init = s390__annotate_init,\n\t\t.objdump =  {\n\t\t\t.comment_char = '#',\n\t\t},\n\t},\n\t{\n\t\t.name = \"sparc\",\n\t\t.init = sparc__annotate_init,\n\t\t.objdump = {\n\t\t\t.comment_char = '#',\n\t\t},\n\t},\n\t{\n\t\t.name = \"loongarch\",\n\t\t.init = loongarch__annotate_init,\n\t\t.objdump = {\n\t\t\t.comment_char = '#',\n\t\t},\n\t},\n};\n\nstatic void ins__delete(struct ins_operands *ops)\n{\n\tif (ops == NULL)\n\t\treturn;\n\tzfree(&ops->source.raw);\n\tzfree(&ops->source.name);\n\tzfree(&ops->target.raw);\n\tzfree(&ops->target.name);\n}\n\nstatic int ins__raw_scnprintf(struct ins *ins, char *bf, size_t size,\n\t\t\t      struct ins_operands *ops, int max_ins_name)\n{\n\treturn scnprintf(bf, size, \"%-*s %s\", max_ins_name, ins->name, ops->raw);\n}\n\nint ins__scnprintf(struct ins *ins, char *bf, size_t size,\n\t\t   struct ins_operands *ops, int max_ins_name)\n{\n\tif (ins->ops->scnprintf)\n\t\treturn ins->ops->scnprintf(ins, bf, size, ops, max_ins_name);\n\n\treturn ins__raw_scnprintf(ins, bf, size, ops, max_ins_name);\n}\n\nbool ins__is_fused(struct arch *arch, const char *ins1, const char *ins2)\n{\n\tif (!arch || !arch->ins_is_fused)\n\t\treturn false;\n\n\treturn arch->ins_is_fused(arch, ins1, ins2);\n}\n\nstatic int call__parse(struct arch *arch, struct ins_operands *ops, struct map_symbol *ms)\n{\n\tchar *endptr, *tok, *name;\n\tstruct map *map = ms->map;\n\tstruct addr_map_symbol target = {\n\t\t.ms = { .map = map, },\n\t};\n\n\tops->target.addr = strtoull(ops->raw, &endptr, 16);\n\n\tname = strchr(endptr, '<');\n\tif (name == NULL)\n\t\tgoto indirect_call;\n\n\tname++;\n\n\tif (arch->objdump.skip_functions_char &&\n\t    strchr(name, arch->objdump.skip_functions_char))\n\t\treturn -1;\n\n\ttok = strchr(name, '>');\n\tif (tok == NULL)\n\t\treturn -1;\n\n\t*tok = '\\0';\n\tops->target.name = strdup(name);\n\t*tok = '>';\n\n\tif (ops->target.name == NULL)\n\t\treturn -1;\nfind_target:\n\ttarget.addr = map__objdump_2mem(map, ops->target.addr);\n\n\tif (maps__find_ams(ms->maps, &target) == 0 &&\n\t    map__rip_2objdump(target.ms.map, map__map_ip(target.ms.map, target.addr)) == ops->target.addr)\n\t\tops->target.sym = target.ms.sym;\n\n\treturn 0;\n\nindirect_call:\n\ttok = strchr(endptr, '*');\n\tif (tok != NULL) {\n\t\tendptr++;\n\n\t\t \n\t\tif (strstr(endptr, \"(%r\") == NULL)\n\t\t\tops->target.addr = strtoull(endptr, NULL, 16);\n\t}\n\tgoto find_target;\n}\n\nstatic int call__scnprintf(struct ins *ins, char *bf, size_t size,\n\t\t\t   struct ins_operands *ops, int max_ins_name)\n{\n\tif (ops->target.sym)\n\t\treturn scnprintf(bf, size, \"%-*s %s\", max_ins_name, ins->name, ops->target.sym->name);\n\n\tif (ops->target.addr == 0)\n\t\treturn ins__raw_scnprintf(ins, bf, size, ops, max_ins_name);\n\n\tif (ops->target.name)\n\t\treturn scnprintf(bf, size, \"%-*s %s\", max_ins_name, ins->name, ops->target.name);\n\n\treturn scnprintf(bf, size, \"%-*s *%\" PRIx64, max_ins_name, ins->name, ops->target.addr);\n}\n\nstatic struct ins_ops call_ops = {\n\t.parse\t   = call__parse,\n\t.scnprintf = call__scnprintf,\n};\n\nbool ins__is_call(const struct ins *ins)\n{\n\treturn ins->ops == &call_ops || ins->ops == &s390_call_ops || ins->ops == &loongarch_call_ops;\n}\n\n \nstatic inline const char *validate_comma(const char *c, struct ins_operands *ops)\n{\n\tif (ops->raw_comment && c > ops->raw_comment)\n\t\treturn NULL;\n\n\tif (ops->raw_func_start && c > ops->raw_func_start)\n\t\treturn NULL;\n\n\treturn c;\n}\n\nstatic int jump__parse(struct arch *arch, struct ins_operands *ops, struct map_symbol *ms)\n{\n\tstruct map *map = ms->map;\n\tstruct symbol *sym = ms->sym;\n\tstruct addr_map_symbol target = {\n\t\t.ms = { .map = map, },\n\t};\n\tconst char *c = strchr(ops->raw, ',');\n\tu64 start, end;\n\n\tops->raw_comment = strchr(ops->raw, arch->objdump.comment_char);\n\tops->raw_func_start = strchr(ops->raw, '<');\n\n\tc = validate_comma(c, ops);\n\n\t \n\t \n\tif (c++ != NULL) {\n\t\tops->target.addr = strtoull(c, NULL, 16);\n\t\tif (!ops->target.addr) {\n\t\t\tc = strchr(c, ',');\n\t\t\tc = validate_comma(c, ops);\n\t\t\tif (c++ != NULL)\n\t\t\t\tops->target.addr = strtoull(c, NULL, 16);\n\t\t}\n\t} else {\n\t\tops->target.addr = strtoull(ops->raw, NULL, 16);\n\t}\n\n\ttarget.addr = map__objdump_2mem(map, ops->target.addr);\n\tstart = map__unmap_ip(map, sym->start);\n\tend = map__unmap_ip(map, sym->end);\n\n\tops->target.outside = target.addr < start || target.addr > end;\n\n\t \n\tif (maps__find_ams(ms->maps, &target) == 0 &&\n\t    map__rip_2objdump(target.ms.map, map__map_ip(target.ms.map, target.addr)) == ops->target.addr)\n\t\tops->target.sym = target.ms.sym;\n\n\tif (!ops->target.outside) {\n\t\tops->target.offset = target.addr - start;\n\t\tops->target.offset_avail = true;\n\t} else {\n\t\tops->target.offset_avail = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int jump__scnprintf(struct ins *ins, char *bf, size_t size,\n\t\t\t   struct ins_operands *ops, int max_ins_name)\n{\n\tconst char *c;\n\n\tif (!ops->target.addr || ops->target.offset < 0)\n\t\treturn ins__raw_scnprintf(ins, bf, size, ops, max_ins_name);\n\n\tif (ops->target.outside && ops->target.sym != NULL)\n\t\treturn scnprintf(bf, size, \"%-*s %s\", max_ins_name, ins->name, ops->target.sym->name);\n\n\tc = strchr(ops->raw, ',');\n\tc = validate_comma(c, ops);\n\n\tif (c != NULL) {\n\t\tconst char *c2 = strchr(c + 1, ',');\n\n\t\tc2 = validate_comma(c2, ops);\n\t\t \n\t\tif (c2 != NULL)\n\t\t\tc = c2;\n\t\tc++;\n\n\t\t \n\t\tif (*c == ' ')\n\t\t\tc++;\n\t}\n\n\treturn scnprintf(bf, size, \"%-*s %.*s%\" PRIx64, max_ins_name,\n\t\t\t ins->name, c ? c - ops->raw : 0, ops->raw,\n\t\t\t ops->target.offset);\n}\n\nstatic struct ins_ops jump_ops = {\n\t.parse\t   = jump__parse,\n\t.scnprintf = jump__scnprintf,\n};\n\nbool ins__is_jump(const struct ins *ins)\n{\n\treturn ins->ops == &jump_ops || ins->ops == &loongarch_jump_ops;\n}\n\nstatic int comment__symbol(char *raw, char *comment, u64 *addrp, char **namep)\n{\n\tchar *endptr, *name, *t;\n\n\tif (strstr(raw, \"(%rip)\") == NULL)\n\t\treturn 0;\n\n\t*addrp = strtoull(comment, &endptr, 16);\n\tif (endptr == comment)\n\t\treturn 0;\n\tname = strchr(endptr, '<');\n\tif (name == NULL)\n\t\treturn -1;\n\n\tname++;\n\n\tt = strchr(name, '>');\n\tif (t == NULL)\n\t\treturn 0;\n\n\t*t = '\\0';\n\t*namep = strdup(name);\n\t*t = '>';\n\n\treturn 0;\n}\n\nstatic int lock__parse(struct arch *arch, struct ins_operands *ops, struct map_symbol *ms)\n{\n\tops->locked.ops = zalloc(sizeof(*ops->locked.ops));\n\tif (ops->locked.ops == NULL)\n\t\treturn 0;\n\n\tif (disasm_line__parse(ops->raw, &ops->locked.ins.name, &ops->locked.ops->raw) < 0)\n\t\tgoto out_free_ops;\n\n\tops->locked.ins.ops = ins__find(arch, ops->locked.ins.name);\n\n\tif (ops->locked.ins.ops == NULL)\n\t\tgoto out_free_ops;\n\n\tif (ops->locked.ins.ops->parse &&\n\t    ops->locked.ins.ops->parse(arch, ops->locked.ops, ms) < 0)\n\t\tgoto out_free_ops;\n\n\treturn 0;\n\nout_free_ops:\n\tzfree(&ops->locked.ops);\n\treturn 0;\n}\n\nstatic int lock__scnprintf(struct ins *ins, char *bf, size_t size,\n\t\t\t   struct ins_operands *ops, int max_ins_name)\n{\n\tint printed;\n\n\tif (ops->locked.ins.ops == NULL)\n\t\treturn ins__raw_scnprintf(ins, bf, size, ops, max_ins_name);\n\n\tprinted = scnprintf(bf, size, \"%-*s \", max_ins_name, ins->name);\n\treturn printed + ins__scnprintf(&ops->locked.ins, bf + printed,\n\t\t\t\t\tsize - printed, ops->locked.ops, max_ins_name);\n}\n\nstatic void lock__delete(struct ins_operands *ops)\n{\n\tstruct ins *ins = &ops->locked.ins;\n\n\tif (ins->ops && ins->ops->free)\n\t\tins->ops->free(ops->locked.ops);\n\telse\n\t\tins__delete(ops->locked.ops);\n\n\tzfree(&ops->locked.ops);\n\tzfree(&ops->target.raw);\n\tzfree(&ops->target.name);\n}\n\nstatic struct ins_ops lock_ops = {\n\t.free\t   = lock__delete,\n\t.parse\t   = lock__parse,\n\t.scnprintf = lock__scnprintf,\n};\n\nstatic int mov__parse(struct arch *arch, struct ins_operands *ops, struct map_symbol *ms __maybe_unused)\n{\n\tchar *s = strchr(ops->raw, ','), *target, *comment, prev;\n\n\tif (s == NULL)\n\t\treturn -1;\n\n\t*s = '\\0';\n\n\t \n\tif (strchr(ops->raw, '(')) {\n\t\t*s = ',';\n\t\ts = strchr(ops->raw, ')');\n\t\tif (s == NULL || s[1] != ',')\n\t\t\treturn -1;\n\t\t*++s = '\\0';\n\t}\n\n\tops->source.raw = strdup(ops->raw);\n\t*s = ',';\n\n\tif (ops->source.raw == NULL)\n\t\treturn -1;\n\n\ttarget = skip_spaces(++s);\n\tcomment = strchr(s, arch->objdump.comment_char);\n\n\tif (comment != NULL)\n\t\ts = comment - 1;\n\telse\n\t\ts = strchr(s, '\\0') - 1;\n\n\twhile (s > target && isspace(s[0]))\n\t\t--s;\n\ts++;\n\tprev = *s;\n\t*s = '\\0';\n\n\tops->target.raw = strdup(target);\n\t*s = prev;\n\n\tif (ops->target.raw == NULL)\n\t\tgoto out_free_source;\n\n\tif (comment == NULL)\n\t\treturn 0;\n\n\tcomment = skip_spaces(comment);\n\tcomment__symbol(ops->source.raw, comment + 1, &ops->source.addr, &ops->source.name);\n\tcomment__symbol(ops->target.raw, comment + 1, &ops->target.addr, &ops->target.name);\n\n\treturn 0;\n\nout_free_source:\n\tzfree(&ops->source.raw);\n\treturn -1;\n}\n\nstatic int mov__scnprintf(struct ins *ins, char *bf, size_t size,\n\t\t\t   struct ins_operands *ops, int max_ins_name)\n{\n\treturn scnprintf(bf, size, \"%-*s %s,%s\", max_ins_name, ins->name,\n\t\t\t ops->source.name ?: ops->source.raw,\n\t\t\t ops->target.name ?: ops->target.raw);\n}\n\nstatic struct ins_ops mov_ops = {\n\t.parse\t   = mov__parse,\n\t.scnprintf = mov__scnprintf,\n};\n\nstatic int dec__parse(struct arch *arch __maybe_unused, struct ins_operands *ops, struct map_symbol *ms __maybe_unused)\n{\n\tchar *target, *comment, *s, prev;\n\n\ttarget = s = ops->raw;\n\n\twhile (s[0] != '\\0' && !isspace(s[0]))\n\t\t++s;\n\tprev = *s;\n\t*s = '\\0';\n\n\tops->target.raw = strdup(target);\n\t*s = prev;\n\n\tif (ops->target.raw == NULL)\n\t\treturn -1;\n\n\tcomment = strchr(s, arch->objdump.comment_char);\n\tif (comment == NULL)\n\t\treturn 0;\n\n\tcomment = skip_spaces(comment);\n\tcomment__symbol(ops->target.raw, comment + 1, &ops->target.addr, &ops->target.name);\n\n\treturn 0;\n}\n\nstatic int dec__scnprintf(struct ins *ins, char *bf, size_t size,\n\t\t\t   struct ins_operands *ops, int max_ins_name)\n{\n\treturn scnprintf(bf, size, \"%-*s %s\", max_ins_name, ins->name,\n\t\t\t ops->target.name ?: ops->target.raw);\n}\n\nstatic struct ins_ops dec_ops = {\n\t.parse\t   = dec__parse,\n\t.scnprintf = dec__scnprintf,\n};\n\nstatic int nop__scnprintf(struct ins *ins __maybe_unused, char *bf, size_t size,\n\t\t\t  struct ins_operands *ops __maybe_unused, int max_ins_name)\n{\n\treturn scnprintf(bf, size, \"%-*s\", max_ins_name, \"nop\");\n}\n\nstatic struct ins_ops nop_ops = {\n\t.scnprintf = nop__scnprintf,\n};\n\nstatic struct ins_ops ret_ops = {\n\t.scnprintf = ins__raw_scnprintf,\n};\n\nbool ins__is_ret(const struct ins *ins)\n{\n\treturn ins->ops == &ret_ops;\n}\n\nbool ins__is_lock(const struct ins *ins)\n{\n\treturn ins->ops == &lock_ops;\n}\n\nstatic int ins__key_cmp(const void *name, const void *insp)\n{\n\tconst struct ins *ins = insp;\n\n\treturn strcmp(name, ins->name);\n}\n\nstatic int ins__cmp(const void *a, const void *b)\n{\n\tconst struct ins *ia = a;\n\tconst struct ins *ib = b;\n\n\treturn strcmp(ia->name, ib->name);\n}\n\nstatic void ins__sort(struct arch *arch)\n{\n\tconst int nmemb = arch->nr_instructions;\n\n\tqsort(arch->instructions, nmemb, sizeof(struct ins), ins__cmp);\n}\n\nstatic struct ins_ops *__ins__find(struct arch *arch, const char *name)\n{\n\tstruct ins *ins;\n\tconst int nmemb = arch->nr_instructions;\n\n\tif (!arch->sorted_instructions) {\n\t\tins__sort(arch);\n\t\tarch->sorted_instructions = true;\n\t}\n\n\tins = bsearch(name, arch->instructions, nmemb, sizeof(struct ins), ins__key_cmp);\n\tif (ins)\n\t\treturn ins->ops;\n\n\tif (arch->insn_suffix) {\n\t\tchar tmp[32];\n\t\tchar suffix;\n\t\tsize_t len = strlen(name);\n\n\t\tif (len == 0 || len >= sizeof(tmp))\n\t\t\treturn NULL;\n\n\t\tsuffix = name[len - 1];\n\t\tif (strchr(arch->insn_suffix, suffix) == NULL)\n\t\t\treturn NULL;\n\n\t\tstrcpy(tmp, name);\n\t\ttmp[len - 1] = '\\0';  \n\n\t\tins = bsearch(tmp, arch->instructions, nmemb, sizeof(struct ins), ins__key_cmp);\n\t}\n\treturn ins ? ins->ops : NULL;\n}\n\nstatic struct ins_ops *ins__find(struct arch *arch, const char *name)\n{\n\tstruct ins_ops *ops = __ins__find(arch, name);\n\n\tif (!ops && arch->associate_instruction_ops)\n\t\tops = arch->associate_instruction_ops(arch, name);\n\n\treturn ops;\n}\n\nstatic int arch__key_cmp(const void *name, const void *archp)\n{\n\tconst struct arch *arch = archp;\n\n\treturn strcmp(name, arch->name);\n}\n\nstatic int arch__cmp(const void *a, const void *b)\n{\n\tconst struct arch *aa = a;\n\tconst struct arch *ab = b;\n\n\treturn strcmp(aa->name, ab->name);\n}\n\nstatic void arch__sort(void)\n{\n\tconst int nmemb = ARRAY_SIZE(architectures);\n\n\tqsort(architectures, nmemb, sizeof(struct arch), arch__cmp);\n}\n\nstatic struct arch *arch__find(const char *name)\n{\n\tconst int nmemb = ARRAY_SIZE(architectures);\n\tstatic bool sorted;\n\n\tif (!sorted) {\n\t\tarch__sort();\n\t\tsorted = true;\n\t}\n\n\treturn bsearch(name, architectures, nmemb, sizeof(struct arch), arch__key_cmp);\n}\n\nstatic struct annotated_source *annotated_source__new(void)\n{\n\tstruct annotated_source *src = zalloc(sizeof(*src));\n\n\tif (src != NULL)\n\t\tINIT_LIST_HEAD(&src->source);\n\n\treturn src;\n}\n\nstatic __maybe_unused void annotated_source__delete(struct annotated_source *src)\n{\n\tif (src == NULL)\n\t\treturn;\n\tzfree(&src->histograms);\n\tzfree(&src->cycles_hist);\n\tfree(src);\n}\n\nstatic int annotated_source__alloc_histograms(struct annotated_source *src,\n\t\t\t\t\t      size_t size, int nr_hists)\n{\n\tsize_t sizeof_sym_hist;\n\n\t \n\tif (size == 0)\n\t\tsize = 1;\n\n\t \n\tif (size > (SIZE_MAX - sizeof(struct sym_hist)) / sizeof(struct sym_hist_entry))\n\t\treturn -1;\n\n\tsizeof_sym_hist = (sizeof(struct sym_hist) + size * sizeof(struct sym_hist_entry));\n\n\t \n\tif (sizeof_sym_hist > SIZE_MAX / nr_hists)\n\t\treturn -1;\n\n\tsrc->sizeof_sym_hist = sizeof_sym_hist;\n\tsrc->nr_histograms   = nr_hists;\n\tsrc->histograms\t     = calloc(nr_hists, sizeof_sym_hist) ;\n\treturn src->histograms ? 0 : -1;\n}\n\n \nstatic int symbol__alloc_hist_cycles(struct symbol *sym)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\tconst size_t size = symbol__size(sym);\n\n\tnotes->src->cycles_hist = calloc(size, sizeof(struct cyc_hist));\n\tif (notes->src->cycles_hist == NULL)\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid symbol__annotate_zero_histograms(struct symbol *sym)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\n\tannotation__lock(notes);\n\tif (notes->src != NULL) {\n\t\tmemset(notes->src->histograms, 0,\n\t\t       notes->src->nr_histograms * notes->src->sizeof_sym_hist);\n\t\tif (notes->src->cycles_hist)\n\t\t\tmemset(notes->src->cycles_hist, 0,\n\t\t\t\tsymbol__size(sym) * sizeof(struct cyc_hist));\n\t}\n\tannotation__unlock(notes);\n}\n\nstatic int __symbol__account_cycles(struct cyc_hist *ch,\n\t\t\t\t    u64 start,\n\t\t\t\t    unsigned offset, unsigned cycles,\n\t\t\t\t    unsigned have_start)\n{\n\t \n\tch[offset].num_aggr++;\n\tch[offset].cycles_aggr += cycles;\n\n\tif (cycles > ch[offset].cycles_max)\n\t\tch[offset].cycles_max = cycles;\n\n\tif (ch[offset].cycles_min) {\n\t\tif (cycles && cycles < ch[offset].cycles_min)\n\t\t\tch[offset].cycles_min = cycles;\n\t} else\n\t\tch[offset].cycles_min = cycles;\n\n\tif (!have_start && ch[offset].have_start)\n\t\treturn 0;\n\tif (ch[offset].num) {\n\t\tif (have_start && (!ch[offset].have_start ||\n\t\t\t\t   ch[offset].start > start)) {\n\t\t\tch[offset].have_start = 0;\n\t\t\tch[offset].cycles = 0;\n\t\t\tch[offset].num = 0;\n\t\t\tif (ch[offset].reset < 0xffff)\n\t\t\t\tch[offset].reset++;\n\t\t} else if (have_start &&\n\t\t\t   ch[offset].start < start)\n\t\t\treturn 0;\n\t}\n\n\tif (ch[offset].num < NUM_SPARKS)\n\t\tch[offset].cycles_spark[ch[offset].num] = cycles;\n\n\tch[offset].have_start = have_start;\n\tch[offset].start = start;\n\tch[offset].cycles += cycles;\n\tch[offset].num++;\n\treturn 0;\n}\n\nstatic int __symbol__inc_addr_samples(struct map_symbol *ms,\n\t\t\t\t      struct annotated_source *src, int evidx, u64 addr,\n\t\t\t\t      struct perf_sample *sample)\n{\n\tstruct symbol *sym = ms->sym;\n\tunsigned offset;\n\tstruct sym_hist *h;\n\n\tpr_debug3(\"%s: addr=%#\" PRIx64 \"\\n\", __func__, map__unmap_ip(ms->map, addr));\n\n\tif ((addr < sym->start || addr >= sym->end) &&\n\t    (addr != sym->end || sym->start != sym->end)) {\n\t\tpr_debug(\"%s(%d): ERANGE! sym->name=%s, start=%#\" PRIx64 \", addr=%#\" PRIx64 \", end=%#\" PRIx64 \"\\n\",\n\t\t       __func__, __LINE__, sym->name, sym->start, addr, sym->end);\n\t\treturn -ERANGE;\n\t}\n\n\toffset = addr - sym->start;\n\th = annotated_source__histogram(src, evidx);\n\tif (h == NULL) {\n\t\tpr_debug(\"%s(%d): ENOMEM! sym->name=%s, start=%#\" PRIx64 \", addr=%#\" PRIx64 \", end=%#\" PRIx64 \", func: %d\\n\",\n\t\t\t __func__, __LINE__, sym->name, sym->start, addr, sym->end, sym->type == STT_FUNC);\n\t\treturn -ENOMEM;\n\t}\n\th->nr_samples++;\n\th->addr[offset].nr_samples++;\n\th->period += sample->period;\n\th->addr[offset].period += sample->period;\n\n\tpr_debug3(\"%#\" PRIx64 \" %s: period++ [addr: %#\" PRIx64 \", %#\" PRIx64\n\t\t  \", evidx=%d] => nr_samples: %\" PRIu64 \", period: %\" PRIu64 \"\\n\",\n\t\t  sym->start, sym->name, addr, addr - sym->start, evidx,\n\t\t  h->addr[offset].nr_samples, h->addr[offset].period);\n\treturn 0;\n}\n\nstatic struct cyc_hist *symbol__cycles_hist(struct symbol *sym)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\n\tif (notes->src == NULL) {\n\t\tnotes->src = annotated_source__new();\n\t\tif (notes->src == NULL)\n\t\t\treturn NULL;\n\t\tgoto alloc_cycles_hist;\n\t}\n\n\tif (!notes->src->cycles_hist) {\nalloc_cycles_hist:\n\t\tsymbol__alloc_hist_cycles(sym);\n\t}\n\n\treturn notes->src->cycles_hist;\n}\n\nstruct annotated_source *symbol__hists(struct symbol *sym, int nr_hists)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\n\tif (notes->src == NULL) {\n\t\tnotes->src = annotated_source__new();\n\t\tif (notes->src == NULL)\n\t\t\treturn NULL;\n\t\tgoto alloc_histograms;\n\t}\n\n\tif (notes->src->histograms == NULL) {\nalloc_histograms:\n\t\tannotated_source__alloc_histograms(notes->src, symbol__size(sym),\n\t\t\t\t\t\t   nr_hists);\n\t}\n\n\treturn notes->src;\n}\n\nstatic int symbol__inc_addr_samples(struct map_symbol *ms,\n\t\t\t\t    struct evsel *evsel, u64 addr,\n\t\t\t\t    struct perf_sample *sample)\n{\n\tstruct symbol *sym = ms->sym;\n\tstruct annotated_source *src;\n\n\tif (sym == NULL)\n\t\treturn 0;\n\tsrc = symbol__hists(sym, evsel->evlist->core.nr_entries);\n\treturn src ? __symbol__inc_addr_samples(ms, src, evsel->core.idx, addr, sample) : 0;\n}\n\nstatic int symbol__account_cycles(u64 addr, u64 start,\n\t\t\t\t  struct symbol *sym, unsigned cycles)\n{\n\tstruct cyc_hist *cycles_hist;\n\tunsigned offset;\n\n\tif (sym == NULL)\n\t\treturn 0;\n\tcycles_hist = symbol__cycles_hist(sym);\n\tif (cycles_hist == NULL)\n\t\treturn -ENOMEM;\n\tif (addr < sym->start || addr >= sym->end)\n\t\treturn -ERANGE;\n\n\tif (start) {\n\t\tif (start < sym->start || start >= sym->end)\n\t\t\treturn -ERANGE;\n\t\tif (start >= addr)\n\t\t\tstart = 0;\n\t}\n\toffset = addr - sym->start;\n\treturn __symbol__account_cycles(cycles_hist,\n\t\t\t\t\tstart ? start - sym->start : 0,\n\t\t\t\t\toffset, cycles,\n\t\t\t\t\t!!start);\n}\n\nint addr_map_symbol__account_cycles(struct addr_map_symbol *ams,\n\t\t\t\t    struct addr_map_symbol *start,\n\t\t\t\t    unsigned cycles)\n{\n\tu64 saddr = 0;\n\tint err;\n\n\tif (!cycles)\n\t\treturn 0;\n\n\t \n\tif (start &&\n\t\t(start->ms.sym == ams->ms.sym ||\n\t\t (ams->ms.sym &&\n\t\t  start->addr == ams->ms.sym->start + map__start(ams->ms.map))))\n\t\tsaddr = start->al_addr;\n\tif (saddr == 0)\n\t\tpr_debug2(\"BB with bad start: addr %\"PRIx64\" start %\"PRIx64\" sym %\"PRIx64\" saddr %\"PRIx64\"\\n\",\n\t\t\tams->addr,\n\t\t\tstart ? start->addr : 0,\n\t\t\tams->ms.sym ? ams->ms.sym->start + map__start(ams->ms.map) : 0,\n\t\t\tsaddr);\n\terr = symbol__account_cycles(ams->al_addr, saddr, ams->ms.sym, cycles);\n\tif (err)\n\t\tpr_debug2(\"account_cycles failed %d\\n\", err);\n\treturn err;\n}\n\nstatic unsigned annotation__count_insn(struct annotation *notes, u64 start, u64 end)\n{\n\tunsigned n_insn = 0;\n\tu64 offset;\n\n\tfor (offset = start; offset <= end; offset++) {\n\t\tif (notes->offsets[offset])\n\t\t\tn_insn++;\n\t}\n\treturn n_insn;\n}\n\nstatic void annotation__count_and_fill(struct annotation *notes, u64 start, u64 end, struct cyc_hist *ch)\n{\n\tunsigned n_insn;\n\tunsigned int cover_insn = 0;\n\tu64 offset;\n\n\tn_insn = annotation__count_insn(notes, start, end);\n\tif (n_insn && ch->num && ch->cycles) {\n\t\tfloat ipc = n_insn / ((double)ch->cycles / (double)ch->num);\n\n\t\t \n\t\tif (ch->reset >= 0x7fff)\n\t\t\treturn;\n\n\t\tfor (offset = start; offset <= end; offset++) {\n\t\t\tstruct annotation_line *al = notes->offsets[offset];\n\n\t\t\tif (al && al->ipc == 0.0) {\n\t\t\t\tal->ipc = ipc;\n\t\t\t\tcover_insn++;\n\t\t\t}\n\t\t}\n\n\t\tif (cover_insn) {\n\t\t\tnotes->hit_cycles += ch->cycles;\n\t\t\tnotes->hit_insn += n_insn * ch->num;\n\t\t\tnotes->cover_insn += cover_insn;\n\t\t}\n\t}\n}\n\nvoid annotation__compute_ipc(struct annotation *notes, size_t size)\n{\n\ts64 offset;\n\n\tif (!notes->src || !notes->src->cycles_hist)\n\t\treturn;\n\n\tnotes->total_insn = annotation__count_insn(notes, 0, size - 1);\n\tnotes->hit_cycles = 0;\n\tnotes->hit_insn = 0;\n\tnotes->cover_insn = 0;\n\n\tannotation__lock(notes);\n\tfor (offset = size - 1; offset >= 0; --offset) {\n\t\tstruct cyc_hist *ch;\n\n\t\tch = &notes->src->cycles_hist[offset];\n\t\tif (ch && ch->cycles) {\n\t\t\tstruct annotation_line *al;\n\n\t\t\tif (ch->have_start)\n\t\t\t\tannotation__count_and_fill(notes, ch->start, offset, ch);\n\t\t\tal = notes->offsets[offset];\n\t\t\tif (al && ch->num_aggr) {\n\t\t\t\tal->cycles = ch->cycles_aggr / ch->num_aggr;\n\t\t\t\tal->cycles_max = ch->cycles_max;\n\t\t\t\tal->cycles_min = ch->cycles_min;\n\t\t\t}\n\t\t\tnotes->have_cycles = true;\n\t\t}\n\t}\n\tannotation__unlock(notes);\n}\n\nint addr_map_symbol__inc_samples(struct addr_map_symbol *ams, struct perf_sample *sample,\n\t\t\t\t struct evsel *evsel)\n{\n\treturn symbol__inc_addr_samples(&ams->ms, evsel, ams->al_addr, sample);\n}\n\nint hist_entry__inc_addr_samples(struct hist_entry *he, struct perf_sample *sample,\n\t\t\t\t struct evsel *evsel, u64 ip)\n{\n\treturn symbol__inc_addr_samples(&he->ms, evsel, ip, sample);\n}\n\nstatic void disasm_line__init_ins(struct disasm_line *dl, struct arch *arch, struct map_symbol *ms)\n{\n\tdl->ins.ops = ins__find(arch, dl->ins.name);\n\n\tif (!dl->ins.ops)\n\t\treturn;\n\n\tif (dl->ins.ops->parse && dl->ins.ops->parse(arch, &dl->ops, ms) < 0)\n\t\tdl->ins.ops = NULL;\n}\n\nstatic int disasm_line__parse(char *line, const char **namep, char **rawp)\n{\n\tchar tmp, *name = skip_spaces(line);\n\n\tif (name[0] == '\\0')\n\t\treturn -1;\n\n\t*rawp = name + 1;\n\n\twhile ((*rawp)[0] != '\\0' && !isspace((*rawp)[0]))\n\t\t++*rawp;\n\n\ttmp = (*rawp)[0];\n\t(*rawp)[0] = '\\0';\n\t*namep = strdup(name);\n\n\tif (*namep == NULL)\n\t\tgoto out;\n\n\t(*rawp)[0] = tmp;\n\t*rawp = strim(*rawp);\n\n\treturn 0;\n\nout:\n\treturn -1;\n}\n\nstruct annotate_args {\n\tstruct arch\t\t  *arch;\n\tstruct map_symbol\t  ms;\n\tstruct evsel\t\t  *evsel;\n\tstruct annotation_options *options;\n\ts64\t\t\t  offset;\n\tchar\t\t\t  *line;\n\tint\t\t\t  line_nr;\n\tchar\t\t\t  *fileloc;\n};\n\nstatic void annotation_line__init(struct annotation_line *al,\n\t\t\t\t  struct annotate_args *args,\n\t\t\t\t  int nr)\n{\n\tal->offset = args->offset;\n\tal->line = strdup(args->line);\n\tal->line_nr = args->line_nr;\n\tal->fileloc = args->fileloc;\n\tal->data_nr = nr;\n}\n\nstatic void annotation_line__exit(struct annotation_line *al)\n{\n\tzfree_srcline(&al->path);\n\tzfree(&al->line);\n}\n\nstatic size_t disasm_line_size(int nr)\n{\n\tstruct annotation_line *al;\n\n\treturn (sizeof(struct disasm_line) + (sizeof(al->data[0]) * nr));\n}\n\n \nstatic struct disasm_line *disasm_line__new(struct annotate_args *args)\n{\n\tstruct disasm_line *dl = NULL;\n\tint nr = 1;\n\n\tif (evsel__is_group_event(args->evsel))\n\t\tnr = args->evsel->core.nr_members;\n\n\tdl = zalloc(disasm_line_size(nr));\n\tif (!dl)\n\t\treturn NULL;\n\n\tannotation_line__init(&dl->al, args, nr);\n\tif (dl->al.line == NULL)\n\t\tgoto out_delete;\n\n\tif (args->offset != -1) {\n\t\tif (disasm_line__parse(dl->al.line, &dl->ins.name, &dl->ops.raw) < 0)\n\t\t\tgoto out_free_line;\n\n\t\tdisasm_line__init_ins(dl, args->arch, &args->ms);\n\t}\n\n\treturn dl;\n\nout_free_line:\n\tzfree(&dl->al.line);\nout_delete:\n\tfree(dl);\n\treturn NULL;\n}\n\nvoid disasm_line__free(struct disasm_line *dl)\n{\n\tif (dl->ins.ops && dl->ins.ops->free)\n\t\tdl->ins.ops->free(&dl->ops);\n\telse\n\t\tins__delete(&dl->ops);\n\tzfree(&dl->ins.name);\n\tannotation_line__exit(&dl->al);\n\tfree(dl);\n}\n\nint disasm_line__scnprintf(struct disasm_line *dl, char *bf, size_t size, bool raw, int max_ins_name)\n{\n\tif (raw || !dl->ins.ops)\n\t\treturn scnprintf(bf, size, \"%-*s %s\", max_ins_name, dl->ins.name, dl->ops.raw);\n\n\treturn ins__scnprintf(&dl->ins, bf, size, &dl->ops, max_ins_name);\n}\n\nvoid annotation__exit(struct annotation *notes)\n{\n\tannotated_source__delete(notes->src);\n}\n\nstatic struct sharded_mutex *sharded_mutex;\n\nstatic void annotation__init_sharded_mutex(void)\n{\n\t \n\tsharded_mutex = sharded_mutex__new(cpu__max_present_cpu().cpu);\n}\n\nstatic size_t annotation__hash(const struct annotation *notes)\n{\n\treturn (size_t)notes;\n}\n\nstatic struct mutex *annotation__get_mutex(const struct annotation *notes)\n{\n\tstatic pthread_once_t once = PTHREAD_ONCE_INIT;\n\n\tpthread_once(&once, annotation__init_sharded_mutex);\n\tif (!sharded_mutex)\n\t\treturn NULL;\n\n\treturn sharded_mutex__get_mutex(sharded_mutex, annotation__hash(notes));\n}\n\nvoid annotation__lock(struct annotation *notes)\n\tNO_THREAD_SAFETY_ANALYSIS\n{\n\tstruct mutex *mutex = annotation__get_mutex(notes);\n\n\tif (mutex)\n\t\tmutex_lock(mutex);\n}\n\nvoid annotation__unlock(struct annotation *notes)\n\tNO_THREAD_SAFETY_ANALYSIS\n{\n\tstruct mutex *mutex = annotation__get_mutex(notes);\n\n\tif (mutex)\n\t\tmutex_unlock(mutex);\n}\n\nbool annotation__trylock(struct annotation *notes)\n{\n\tstruct mutex *mutex = annotation__get_mutex(notes);\n\n\tif (!mutex)\n\t\treturn false;\n\n\treturn mutex_trylock(mutex);\n}\n\n\nstatic void annotation_line__add(struct annotation_line *al, struct list_head *head)\n{\n\tlist_add_tail(&al->node, head);\n}\n\nstruct annotation_line *\nannotation_line__next(struct annotation_line *pos, struct list_head *head)\n{\n\tlist_for_each_entry_continue(pos, head, node)\n\t\tif (pos->offset >= 0)\n\t\t\treturn pos;\n\n\treturn NULL;\n}\n\nstatic const char *annotate__address_color(struct block_range *br)\n{\n\tdouble cov = block_range__coverage(br);\n\n\tif (cov >= 0) {\n\t\t \n\t\tif (cov > 0.75)\n\t\t\treturn PERF_COLOR_RED;\n\n\t\t \n\t\tif (cov < 0.01)\n\t\t\treturn PERF_COLOR_NORMAL;\n\t}\n\n\treturn PERF_COLOR_MAGENTA;\n}\n\nstatic const char *annotate__asm_color(struct block_range *br)\n{\n\tdouble cov = block_range__coverage(br);\n\n\tif (cov >= 0) {\n\t\t \n\t\tif (cov < 0.01)\n\t\t\treturn PERF_COLOR_NORMAL;\n\t}\n\n\treturn PERF_COLOR_BLUE;\n}\n\nstatic void annotate__branch_printf(struct block_range *br, u64 addr)\n{\n\tbool emit_comment = true;\n\n\tif (!br)\n\t\treturn;\n\n#if 1\n\tif (br->is_target && br->start == addr) {\n\t\tstruct block_range *branch = br;\n\t\tdouble p;\n\n\t\t \n\t\twhile (!branch->is_branch)\n\t\t\tbranch = block_range__next(branch);\n\n\t\tp = 100 *(double)br->entry / branch->coverage;\n\n\t\tif (p > 0.1) {\n\t\t\tif (emit_comment) {\n\t\t\t\temit_comment = false;\n\t\t\t\tprintf(\"\\t#\");\n\t\t\t}\n\n\t\t\t \n\t\t\tprintf(\" +%.2f%%\", p);\n\t\t}\n\t}\n#endif\n\tif (br->is_branch && br->end == addr) {\n\t\tdouble p = 100*(double)br->taken / br->coverage;\n\n\t\tif (p > 0.1) {\n\t\t\tif (emit_comment) {\n\t\t\t\temit_comment = false;\n\t\t\t\tprintf(\"\\t#\");\n\t\t\t}\n\n\t\t\t \n\t\t\tprintf(\" -%.2f%% (p:%.2f%%)\", p, 100*(double)br->pred  / br->taken);\n\t\t}\n\t}\n}\n\nstatic int disasm_line__print(struct disasm_line *dl, u64 start, int addr_fmt_width)\n{\n\ts64 offset = dl->al.offset;\n\tconst u64 addr = start + offset;\n\tstruct block_range *br;\n\n\tbr = block_range__find(addr);\n\tcolor_fprintf(stdout, annotate__address_color(br), \"  %*\" PRIx64 \":\", addr_fmt_width, addr);\n\tcolor_fprintf(stdout, annotate__asm_color(br), \"%s\", dl->al.line);\n\tannotate__branch_printf(br, addr);\n\treturn 0;\n}\n\nstatic int\nannotation_line__print(struct annotation_line *al, struct symbol *sym, u64 start,\n\t\t       struct evsel *evsel, u64 len, int min_pcnt, int printed,\n\t\t       int max_lines, struct annotation_line *queue, int addr_fmt_width,\n\t\t       int percent_type)\n{\n\tstruct disasm_line *dl = container_of(al, struct disasm_line, al);\n\tstatic const char *prev_line;\n\n\tif (al->offset != -1) {\n\t\tdouble max_percent = 0.0;\n\t\tint i, nr_percent = 1;\n\t\tconst char *color;\n\t\tstruct annotation *notes = symbol__annotation(sym);\n\n\t\tfor (i = 0; i < al->data_nr; i++) {\n\t\t\tdouble percent;\n\n\t\t\tpercent = annotation_data__percent(&al->data[i],\n\t\t\t\t\t\t\t   percent_type);\n\n\t\t\tif (percent > max_percent)\n\t\t\t\tmax_percent = percent;\n\t\t}\n\n\t\tif (al->data_nr > nr_percent)\n\t\t\tnr_percent = al->data_nr;\n\n\t\tif (max_percent < min_pcnt)\n\t\t\treturn -1;\n\n\t\tif (max_lines && printed >= max_lines)\n\t\t\treturn 1;\n\n\t\tif (queue != NULL) {\n\t\t\tlist_for_each_entry_from(queue, &notes->src->source, node) {\n\t\t\t\tif (queue == al)\n\t\t\t\t\tbreak;\n\t\t\t\tannotation_line__print(queue, sym, start, evsel, len,\n\t\t\t\t\t\t       0, 0, 1, NULL, addr_fmt_width,\n\t\t\t\t\t\t       percent_type);\n\t\t\t}\n\t\t}\n\n\t\tcolor = get_percent_color(max_percent);\n\n\t\tfor (i = 0; i < nr_percent; i++) {\n\t\t\tstruct annotation_data *data = &al->data[i];\n\t\t\tdouble percent;\n\n\t\t\tpercent = annotation_data__percent(data, percent_type);\n\t\t\tcolor = get_percent_color(percent);\n\n\t\t\tif (symbol_conf.show_total_period)\n\t\t\t\tcolor_fprintf(stdout, color, \" %11\" PRIu64,\n\t\t\t\t\t      data->he.period);\n\t\t\telse if (symbol_conf.show_nr_samples)\n\t\t\t\tcolor_fprintf(stdout, color, \" %7\" PRIu64,\n\t\t\t\t\t      data->he.nr_samples);\n\t\t\telse\n\t\t\t\tcolor_fprintf(stdout, color, \" %7.2f\", percent);\n\t\t}\n\n\t\tprintf(\" : \");\n\n\t\tdisasm_line__print(dl, start, addr_fmt_width);\n\n\t\t \n\t\tif (al->path) {\n\t\t\tif (!prev_line || strcmp(prev_line, al->path)) {\n\t\t\t\tcolor_fprintf(stdout, color, \" // %s\", al->path);\n\t\t\t\tprev_line = al->path;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t} else if (max_lines && printed >= max_lines)\n\t\treturn 1;\n\telse {\n\t\tint width = symbol_conf.show_total_period ? 12 : 8;\n\n\t\tif (queue)\n\t\t\treturn -1;\n\n\t\tif (evsel__is_group_event(evsel))\n\t\t\twidth *= evsel->core.nr_members;\n\n\t\tif (!*al->line)\n\t\t\tprintf(\" %*s:\\n\", width, \" \");\n\t\telse\n\t\t\tprintf(\" %*s: %-*d %s\\n\", width, \" \", addr_fmt_width, al->line_nr, al->line);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int symbol__parse_objdump_line(struct symbol *sym,\n\t\t\t\t      struct annotate_args *args,\n\t\t\t\t      char *parsed_line, int *line_nr, char **fileloc)\n{\n\tstruct map *map = args->ms.map;\n\tstruct annotation *notes = symbol__annotation(sym);\n\tstruct disasm_line *dl;\n\tchar *tmp;\n\ts64 line_ip, offset = -1;\n\tregmatch_t match[2];\n\n\t \n\tif (regexec(&file_lineno, parsed_line, 2, match, 0) == 0) {\n\t\t*line_nr = atoi(parsed_line + match[1].rm_so);\n\t\tfree(*fileloc);\n\t\t*fileloc = strdup(parsed_line);\n\t\treturn 0;\n\t}\n\n\t \n\tline_ip = strtoull(parsed_line, &tmp, 16);\n\tif (parsed_line != tmp && tmp[0] == ':' && tmp[1] != '\\0') {\n\t\tu64 start = map__rip_2objdump(map, sym->start),\n\t\t    end = map__rip_2objdump(map, sym->end);\n\n\t\toffset = line_ip - start;\n\t\tif ((u64)line_ip < start || (u64)line_ip >= end)\n\t\t\toffset = -1;\n\t\telse\n\t\t\tparsed_line = tmp + 1;\n\t}\n\n\targs->offset  = offset;\n\targs->line    = parsed_line;\n\targs->line_nr = *line_nr;\n\targs->fileloc = *fileloc;\n\targs->ms.sym  = sym;\n\n\tdl = disasm_line__new(args);\n\t(*line_nr)++;\n\n\tif (dl == NULL)\n\t\treturn -1;\n\n\tif (!disasm_line__has_local_offset(dl)) {\n\t\tdl->ops.target.offset = dl->ops.target.addr -\n\t\t\t\t\tmap__rip_2objdump(map, sym->start);\n\t\tdl->ops.target.offset_avail = true;\n\t}\n\n\t \n\tif (dl->ins.ops && ins__is_call(&dl->ins) && !dl->ops.target.sym) {\n\t\tstruct addr_map_symbol target = {\n\t\t\t.addr = dl->ops.target.addr,\n\t\t\t.ms = { .map = map, },\n\t\t};\n\n\t\tif (!maps__find_ams(args->ms.maps, &target) &&\n\t\t    target.ms.sym->start == target.al_addr)\n\t\t\tdl->ops.target.sym = target.ms.sym;\n\t}\n\n\tannotation_line__add(&dl->al, &notes->src->source);\n\treturn 0;\n}\n\nstatic __attribute__((constructor)) void symbol__init_regexpr(void)\n{\n\tregcomp(&file_lineno, \"^/[^:]+:([0-9]+)\", REG_EXTENDED);\n}\n\nstatic void delete_last_nop(struct symbol *sym)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\tstruct list_head *list = &notes->src->source;\n\tstruct disasm_line *dl;\n\n\twhile (!list_empty(list)) {\n\t\tdl = list_entry(list->prev, struct disasm_line, al.node);\n\n\t\tif (dl->ins.ops) {\n\t\t\tif (dl->ins.ops != &nop_ops)\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tif (!strstr(dl->al.line, \" nop \") &&\n\t\t\t    !strstr(dl->al.line, \" nopl \") &&\n\t\t\t    !strstr(dl->al.line, \" nopw \"))\n\t\t\t\treturn;\n\t\t}\n\n\t\tlist_del_init(&dl->al.node);\n\t\tdisasm_line__free(dl);\n\t}\n}\n\nint symbol__strerror_disassemble(struct map_symbol *ms, int errnum, char *buf, size_t buflen)\n{\n\tstruct dso *dso = map__dso(ms->map);\n\n\tBUG_ON(buflen == 0);\n\n\tif (errnum >= 0) {\n\t\tstr_error_r(errnum, buf, buflen);\n\t\treturn 0;\n\t}\n\n\tswitch (errnum) {\n\tcase SYMBOL_ANNOTATE_ERRNO__NO_VMLINUX: {\n\t\tchar bf[SBUILD_ID_SIZE + 15] = \" with build id \";\n\t\tchar *build_id_msg = NULL;\n\n\t\tif (dso->has_build_id) {\n\t\t\tbuild_id__sprintf(&dso->bid, bf + 15);\n\t\t\tbuild_id_msg = bf;\n\t\t}\n\t\tscnprintf(buf, buflen,\n\t\t\t  \"No vmlinux file%s\\nwas found in the path.\\n\\n\"\n\t\t\t  \"Note that annotation using /proc/kcore requires CAP_SYS_RAWIO capability.\\n\\n\"\n\t\t\t  \"Please use:\\n\\n\"\n\t\t\t  \"  perf buildid-cache -vu vmlinux\\n\\n\"\n\t\t\t  \"or:\\n\\n\"\n\t\t\t  \"  --vmlinux vmlinux\\n\", build_id_msg ?: \"\");\n\t}\n\t\tbreak;\n\tcase SYMBOL_ANNOTATE_ERRNO__NO_LIBOPCODES_FOR_BPF:\n\t\tscnprintf(buf, buflen, \"Please link with binutils's libopcode to enable BPF annotation\");\n\t\tbreak;\n\tcase SYMBOL_ANNOTATE_ERRNO__ARCH_INIT_REGEXP:\n\t\tscnprintf(buf, buflen, \"Problems with arch specific instruction name regular expressions.\");\n\t\tbreak;\n\tcase SYMBOL_ANNOTATE_ERRNO__ARCH_INIT_CPUID_PARSING:\n\t\tscnprintf(buf, buflen, \"Problems while parsing the CPUID in the arch specific initialization.\");\n\t\tbreak;\n\tcase SYMBOL_ANNOTATE_ERRNO__BPF_INVALID_FILE:\n\t\tscnprintf(buf, buflen, \"Invalid BPF file: %s.\", dso->long_name);\n\t\tbreak;\n\tcase SYMBOL_ANNOTATE_ERRNO__BPF_MISSING_BTF:\n\t\tscnprintf(buf, buflen, \"The %s BPF file has no BTF section, compile with -g or use pahole -J.\",\n\t\t\t  dso->long_name);\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(buf, buflen, \"Internal error: Invalid %d error code\\n\", errnum);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int dso__disassemble_filename(struct dso *dso, char *filename, size_t filename_size)\n{\n\tchar linkname[PATH_MAX];\n\tchar *build_id_filename;\n\tchar *build_id_path = NULL;\n\tchar *pos;\n\tint len;\n\n\tif (dso->symtab_type == DSO_BINARY_TYPE__KALLSYMS &&\n\t    !dso__is_kcore(dso))\n\t\treturn SYMBOL_ANNOTATE_ERRNO__NO_VMLINUX;\n\n\tbuild_id_filename = dso__build_id_filename(dso, NULL, 0, false);\n\tif (build_id_filename) {\n\t\t__symbol__join_symfs(filename, filename_size, build_id_filename);\n\t\tfree(build_id_filename);\n\t} else {\n\t\tif (dso->has_build_id)\n\t\t\treturn ENOMEM;\n\t\tgoto fallback;\n\t}\n\n\tbuild_id_path = strdup(filename);\n\tif (!build_id_path)\n\t\treturn ENOMEM;\n\n\t \n\tpos = strrchr(build_id_path, '/');\n\tif (pos && strlen(pos) < SBUILD_ID_SIZE - 2)\n\t\tdirname(build_id_path);\n\n\tif (dso__is_kcore(dso))\n\t\tgoto fallback;\n\n\tlen = readlink(build_id_path, linkname, sizeof(linkname) - 1);\n\tif (len < 0)\n\t\tgoto fallback;\n\n\tlinkname[len] = '\\0';\n\tif (strstr(linkname, DSO__NAME_KALLSYMS) ||\n\t\taccess(filename, R_OK)) {\nfallback:\n\t\t \n\t\tif (dso->kernel && dso->long_name[0] == '/')\n\t\t\tsnprintf(filename, filename_size, \"%s\", dso->long_name);\n\t\telse\n\t\t\t__symbol__join_symfs(filename, filename_size, dso->long_name);\n\n\t\tmutex_lock(&dso->lock);\n\t\tif (access(filename, R_OK) && errno == ENOENT && dso->nsinfo) {\n\t\t\tchar *new_name = dso__filename_with_chroot(dso, filename);\n\t\t\tif (new_name) {\n\t\t\t\tstrlcpy(filename, new_name, filename_size);\n\t\t\t\tfree(new_name);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&dso->lock);\n\t}\n\n\tfree(build_id_path);\n\treturn 0;\n}\n\n#if defined(HAVE_LIBBFD_SUPPORT) && defined(HAVE_LIBBPF_SUPPORT)\n#define PACKAGE \"perf\"\n#include <bfd.h>\n#include <dis-asm.h>\n#include <bpf/bpf.h>\n#include <bpf/btf.h>\n#include <bpf/libbpf.h>\n#include <linux/btf.h>\n#include <tools/dis-asm-compat.h>\n\nstatic int symbol__disassemble_bpf(struct symbol *sym,\n\t\t\t\t   struct annotate_args *args)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\tstruct annotation_options *opts = args->options;\n\tstruct bpf_prog_linfo *prog_linfo = NULL;\n\tstruct bpf_prog_info_node *info_node;\n\tint len = sym->end - sym->start;\n\tdisassembler_ftype disassemble;\n\tstruct map *map = args->ms.map;\n\tstruct perf_bpil *info_linear;\n\tstruct disassemble_info info;\n\tstruct dso *dso = map__dso(map);\n\tint pc = 0, count, sub_id;\n\tstruct btf *btf = NULL;\n\tchar tpath[PATH_MAX];\n\tsize_t buf_size;\n\tint nr_skip = 0;\n\tchar *buf;\n\tbfd *bfdf;\n\tint ret;\n\tFILE *s;\n\n\tif (dso->binary_type != DSO_BINARY_TYPE__BPF_PROG_INFO)\n\t\treturn SYMBOL_ANNOTATE_ERRNO__BPF_INVALID_FILE;\n\n\tpr_debug(\"%s: handling sym %s addr %\" PRIx64 \" len %\" PRIx64 \"\\n\", __func__,\n\t\t  sym->name, sym->start, sym->end - sym->start);\n\n\tmemset(tpath, 0, sizeof(tpath));\n\tperf_exe(tpath, sizeof(tpath));\n\n\tbfdf = bfd_openr(tpath, NULL);\n\tif (bfdf == NULL)\n\t\tabort();\n\n\tif (!bfd_check_format(bfdf, bfd_object))\n\t\tabort();\n\n\ts = open_memstream(&buf, &buf_size);\n\tif (!s) {\n\t\tret = errno;\n\t\tgoto out;\n\t}\n\tinit_disassemble_info_compat(&info, s,\n\t\t\t\t     (fprintf_ftype) fprintf,\n\t\t\t\t     fprintf_styled);\n\tinfo.arch = bfd_get_arch(bfdf);\n\tinfo.mach = bfd_get_mach(bfdf);\n\n\tinfo_node = perf_env__find_bpf_prog_info(dso->bpf_prog.env,\n\t\t\t\t\t\t dso->bpf_prog.id);\n\tif (!info_node) {\n\t\tret = SYMBOL_ANNOTATE_ERRNO__BPF_MISSING_BTF;\n\t\tgoto out;\n\t}\n\tinfo_linear = info_node->info_linear;\n\tsub_id = dso->bpf_prog.sub_id;\n\n\tinfo.buffer = (void *)(uintptr_t)(info_linear->info.jited_prog_insns);\n\tinfo.buffer_length = info_linear->info.jited_prog_len;\n\n\tif (info_linear->info.nr_line_info)\n\t\tprog_linfo = bpf_prog_linfo__new(&info_linear->info);\n\n\tif (info_linear->info.btf_id) {\n\t\tstruct btf_node *node;\n\n\t\tnode = perf_env__find_btf(dso->bpf_prog.env,\n\t\t\t\t\t  info_linear->info.btf_id);\n\t\tif (node)\n\t\t\tbtf = btf__new((__u8 *)(node->data),\n\t\t\t\t       node->data_size);\n\t}\n\n\tdisassemble_init_for_target(&info);\n\n#ifdef DISASM_FOUR_ARGS_SIGNATURE\n\tdisassemble = disassembler(info.arch,\n\t\t\t\t   bfd_big_endian(bfdf),\n\t\t\t\t   info.mach,\n\t\t\t\t   bfdf);\n#else\n\tdisassemble = disassembler(bfdf);\n#endif\n\tif (disassemble == NULL)\n\t\tabort();\n\n\tfflush(s);\n\tdo {\n\t\tconst struct bpf_line_info *linfo = NULL;\n\t\tstruct disasm_line *dl;\n\t\tsize_t prev_buf_size;\n\t\tconst char *srcline;\n\t\tu64 addr;\n\n\t\taddr = pc + ((u64 *)(uintptr_t)(info_linear->info.jited_ksyms))[sub_id];\n\t\tcount = disassemble(pc, &info);\n\n\t\tif (prog_linfo)\n\t\t\tlinfo = bpf_prog_linfo__lfind_addr_func(prog_linfo,\n\t\t\t\t\t\t\t\taddr, sub_id,\n\t\t\t\t\t\t\t\tnr_skip);\n\n\t\tif (linfo && btf) {\n\t\t\tsrcline = btf__name_by_offset(btf, linfo->line_off);\n\t\t\tnr_skip++;\n\t\t} else\n\t\t\tsrcline = NULL;\n\n\t\tfprintf(s, \"\\n\");\n\t\tprev_buf_size = buf_size;\n\t\tfflush(s);\n\n\t\tif (!opts->hide_src_code && srcline) {\n\t\t\targs->offset = -1;\n\t\t\targs->line = strdup(srcline);\n\t\t\targs->line_nr = 0;\n\t\t\targs->fileloc = NULL;\n\t\t\targs->ms.sym  = sym;\n\t\t\tdl = disasm_line__new(args);\n\t\t\tif (dl) {\n\t\t\t\tannotation_line__add(&dl->al,\n\t\t\t\t\t\t     &notes->src->source);\n\t\t\t}\n\t\t}\n\n\t\targs->offset = pc;\n\t\targs->line = buf + prev_buf_size;\n\t\targs->line_nr = 0;\n\t\targs->fileloc = NULL;\n\t\targs->ms.sym  = sym;\n\t\tdl = disasm_line__new(args);\n\t\tif (dl)\n\t\t\tannotation_line__add(&dl->al, &notes->src->source);\n\n\t\tpc += count;\n\t} while (count > 0 && pc < len);\n\n\tret = 0;\nout:\n\tfree(prog_linfo);\n\tbtf__free(btf);\n\tfclose(s);\n\tbfd_close(bfdf);\n\treturn ret;\n}\n#else \nstatic int symbol__disassemble_bpf(struct symbol *sym __maybe_unused,\n\t\t\t\t   struct annotate_args *args __maybe_unused)\n{\n\treturn SYMBOL_ANNOTATE_ERRNO__NO_LIBOPCODES_FOR_BPF;\n}\n#endif \n\nstatic int\nsymbol__disassemble_bpf_image(struct symbol *sym,\n\t\t\t      struct annotate_args *args)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\tstruct disasm_line *dl;\n\n\targs->offset = -1;\n\targs->line = strdup(\"to be implemented\");\n\targs->line_nr = 0;\n\targs->fileloc = NULL;\n\tdl = disasm_line__new(args);\n\tif (dl)\n\t\tannotation_line__add(&dl->al, &notes->src->source);\n\n\tzfree(&args->line);\n\treturn 0;\n}\n\n \nstatic char *expand_tabs(char *line, char **storage, size_t *storage_len)\n{\n\tsize_t i, src, dst, len, new_storage_len, num_tabs;\n\tchar *new_line;\n\tsize_t line_len = strlen(line);\n\n\tfor (num_tabs = 0, i = 0; i < line_len; i++)\n\t\tif (line[i] == '\\t')\n\t\t\tnum_tabs++;\n\n\tif (num_tabs == 0)\n\t\treturn line;\n\n\t \n\tnew_storage_len = line_len + 1 + (num_tabs * 7);\n\n\tnew_line = malloc(new_storage_len);\n\tif (new_line == NULL) {\n\t\tpr_err(\"Failure allocating memory for tab expansion\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tfor (i = 0, src = 0, dst = 0; i < line_len && num_tabs; i++) {\n\t\tif (line[i] == '\\t') {\n\t\t\tlen = i - src;\n\t\t\tmemcpy(&new_line[dst], &line[src], len);\n\t\t\tdst += len;\n\t\t\tnew_line[dst++] = ' ';\n\t\t\twhile (dst % 8 != 0)\n\t\t\t\tnew_line[dst++] = ' ';\n\t\t\tsrc = i + 1;\n\t\t\tnum_tabs--;\n\t\t}\n\t}\n\n\t \n\tlen = line_len - src;\n\tmemcpy(&new_line[dst], &line[src], len);\n\tdst += len;\n\tnew_line[dst] = '\\0';\n\n\tfree(*storage);\n\t*storage = new_line;\n\t*storage_len = new_storage_len;\n\treturn new_line;\n\n}\n\nstatic int symbol__disassemble(struct symbol *sym, struct annotate_args *args)\n{\n\tstruct annotation_options *opts = args->options;\n\tstruct map *map = args->ms.map;\n\tstruct dso *dso = map__dso(map);\n\tchar *command;\n\tFILE *file;\n\tchar symfs_filename[PATH_MAX];\n\tstruct kcore_extract kce;\n\tbool delete_extract = false;\n\tbool decomp = false;\n\tint lineno = 0;\n\tchar *fileloc = NULL;\n\tint nline;\n\tchar *line;\n\tsize_t line_len;\n\tconst char *objdump_argv[] = {\n\t\t\"/bin/sh\",\n\t\t\"-c\",\n\t\tNULL,  \n\t\t\"--\",\n\t\tNULL,  \n\t\tNULL,\n\t};\n\tstruct child_process objdump_process;\n\tint err = dso__disassemble_filename(dso, symfs_filename, sizeof(symfs_filename));\n\n\tif (err)\n\t\treturn err;\n\n\tpr_debug(\"%s: filename=%s, sym=%s, start=%#\" PRIx64 \", end=%#\" PRIx64 \"\\n\", __func__,\n\t\t symfs_filename, sym->name, map__unmap_ip(map, sym->start),\n\t\t map__unmap_ip(map, sym->end));\n\n\tpr_debug(\"annotating [%p] %30s : [%p] %30s\\n\",\n\t\t dso, dso->long_name, sym, sym->name);\n\n\tif (dso->binary_type == DSO_BINARY_TYPE__BPF_PROG_INFO) {\n\t\treturn symbol__disassemble_bpf(sym, args);\n\t} else if (dso->binary_type == DSO_BINARY_TYPE__BPF_IMAGE) {\n\t\treturn symbol__disassemble_bpf_image(sym, args);\n\t} else if (dso__is_kcore(dso)) {\n\t\tkce.kcore_filename = symfs_filename;\n\t\tkce.addr = map__rip_2objdump(map, sym->start);\n\t\tkce.offs = sym->start;\n\t\tkce.len = sym->end - sym->start;\n\t\tif (!kcore_extract__create(&kce)) {\n\t\t\tdelete_extract = true;\n\t\t\tstrlcpy(symfs_filename, kce.extract_filename,\n\t\t\t\tsizeof(symfs_filename));\n\t\t}\n\t} else if (dso__needs_decompress(dso)) {\n\t\tchar tmp[KMOD_DECOMP_LEN];\n\n\t\tif (dso__decompress_kmodule_path(dso, symfs_filename,\n\t\t\t\t\t\t tmp, sizeof(tmp)) < 0)\n\t\t\treturn -1;\n\n\t\tdecomp = true;\n\t\tstrcpy(symfs_filename, tmp);\n\t}\n\n\terr = asprintf(&command,\n\t\t \"%s %s%s --start-address=0x%016\" PRIx64\n\t\t \" --stop-address=0x%016\" PRIx64\n\t\t \" -l -d %s %s %s %c%s%c %s%s -C \\\"$1\\\"\",\n\t\t opts->objdump_path ?: \"objdump\",\n\t\t opts->disassembler_style ? \"-M \" : \"\",\n\t\t opts->disassembler_style ?: \"\",\n\t\t map__rip_2objdump(map, sym->start),\n\t\t map__rip_2objdump(map, sym->end),\n\t\t opts->show_asm_raw ? \"\" : \"--no-show-raw-insn\",\n\t\t opts->annotate_src ? \"-S\" : \"\",\n\t\t opts->prefix ? \"--prefix \" : \"\",\n\t\t opts->prefix ? '\"' : ' ',\n\t\t opts->prefix ?: \"\",\n\t\t opts->prefix ? '\"' : ' ',\n\t\t opts->prefix_strip ? \"--prefix-strip=\" : \"\",\n\t\t opts->prefix_strip ?: \"\");\n\n\tif (err < 0) {\n\t\tpr_err(\"Failure allocating memory for the command to run\\n\");\n\t\tgoto out_remove_tmp;\n\t}\n\n\tpr_debug(\"Executing: %s\\n\", command);\n\n\tobjdump_argv[2] = command;\n\tobjdump_argv[4] = symfs_filename;\n\n\t \n\tmemset(&objdump_process, 0, sizeof(objdump_process));\n\tobjdump_process.argv = objdump_argv;\n\tobjdump_process.out = -1;\n\tobjdump_process.err = -1;\n\tobjdump_process.no_stderr = 1;\n\tif (start_command(&objdump_process)) {\n\t\tpr_err(\"Failure starting to run %s\\n\", command);\n\t\terr = -1;\n\t\tgoto out_free_command;\n\t}\n\n\tfile = fdopen(objdump_process.out, \"r\");\n\tif (!file) {\n\t\tpr_err(\"Failure creating FILE stream for %s\\n\", command);\n\t\t \n\t\terr = -1;\n\t\tgoto out_close_stdout;\n\t}\n\n\t \n\tline = NULL;\n\tline_len = 0;\n\n\tnline = 0;\n\twhile (!feof(file)) {\n\t\tconst char *match;\n\t\tchar *expanded_line;\n\n\t\tif (getline(&line, &line_len, file) < 0 || !line)\n\t\t\tbreak;\n\n\t\t \n\t\tmatch = strstr(line, symfs_filename);\n\t\tif (match && match[strlen(symfs_filename)] == ':')\n\t\t\tcontinue;\n\n\t\texpanded_line = strim(line);\n\t\texpanded_line = expand_tabs(expanded_line, &line, &line_len);\n\t\tif (!expanded_line)\n\t\t\tbreak;\n\n\t\t \n\t\tif (symbol__parse_objdump_line(sym, args, expanded_line,\n\t\t\t\t\t       &lineno, &fileloc) < 0)\n\t\t\tbreak;\n\t\tnline++;\n\t}\n\tfree(line);\n\tfree(fileloc);\n\n\terr = finish_command(&objdump_process);\n\tif (err)\n\t\tpr_err(\"Error running %s\\n\", command);\n\n\tif (nline == 0) {\n\t\terr = -1;\n\t\tpr_err(\"No output from %s\\n\", command);\n\t}\n\n\t \n\tif (dso__is_kcore(dso))\n\t\tdelete_last_nop(sym);\n\n\tfclose(file);\n\nout_close_stdout:\n\tclose(objdump_process.out);\n\nout_free_command:\n\tfree(command);\n\nout_remove_tmp:\n\tif (decomp)\n\t\tunlink(symfs_filename);\n\n\tif (delete_extract)\n\t\tkcore_extract__delete(&kce);\n\n\treturn err;\n}\n\nstatic void calc_percent(struct sym_hist *sym_hist,\n\t\t\t struct hists *hists,\n\t\t\t struct annotation_data *data,\n\t\t\t s64 offset, s64 end)\n{\n\tunsigned int hits = 0;\n\tu64 period = 0;\n\n\twhile (offset < end) {\n\t\thits   += sym_hist->addr[offset].nr_samples;\n\t\tperiod += sym_hist->addr[offset].period;\n\t\t++offset;\n\t}\n\n\tif (sym_hist->nr_samples) {\n\t\tdata->he.period     = period;\n\t\tdata->he.nr_samples = hits;\n\t\tdata->percent[PERCENT_HITS_LOCAL] = 100.0 * hits / sym_hist->nr_samples;\n\t}\n\n\tif (hists->stats.nr_non_filtered_samples)\n\t\tdata->percent[PERCENT_HITS_GLOBAL] = 100.0 * hits / hists->stats.nr_non_filtered_samples;\n\n\tif (sym_hist->period)\n\t\tdata->percent[PERCENT_PERIOD_LOCAL] = 100.0 * period / sym_hist->period;\n\n\tif (hists->stats.total_period)\n\t\tdata->percent[PERCENT_PERIOD_GLOBAL] = 100.0 * period / hists->stats.total_period;\n}\n\nstatic void annotation__calc_percent(struct annotation *notes,\n\t\t\t\t     struct evsel *leader, s64 len)\n{\n\tstruct annotation_line *al, *next;\n\tstruct evsel *evsel;\n\n\tlist_for_each_entry(al, &notes->src->source, node) {\n\t\ts64 end;\n\t\tint i = 0;\n\n\t\tif (al->offset == -1)\n\t\t\tcontinue;\n\n\t\tnext = annotation_line__next(al, &notes->src->source);\n\t\tend  = next ? next->offset : len;\n\n\t\tfor_each_group_evsel(evsel, leader) {\n\t\t\tstruct hists *hists = evsel__hists(evsel);\n\t\t\tstruct annotation_data *data;\n\t\t\tstruct sym_hist *sym_hist;\n\n\t\t\tBUG_ON(i >= al->data_nr);\n\n\t\t\tsym_hist = annotation__histogram(notes, evsel->core.idx);\n\t\t\tdata = &al->data[i++];\n\n\t\t\tcalc_percent(sym_hist, hists, data, al->offset, end);\n\t\t}\n\t}\n}\n\nvoid symbol__calc_percent(struct symbol *sym, struct evsel *evsel)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\n\tannotation__calc_percent(notes, evsel, symbol__size(sym));\n}\n\nint symbol__annotate(struct map_symbol *ms, struct evsel *evsel,\n\t\t     struct annotation_options *options, struct arch **parch)\n{\n\tstruct symbol *sym = ms->sym;\n\tstruct annotation *notes = symbol__annotation(sym);\n\tstruct annotate_args args = {\n\t\t.evsel\t\t= evsel,\n\t\t.options\t= options,\n\t};\n\tstruct perf_env *env = evsel__env(evsel);\n\tconst char *arch_name = perf_env__arch(env);\n\tstruct arch *arch;\n\tint err;\n\n\tif (!arch_name)\n\t\treturn errno;\n\n\targs.arch = arch = arch__find(arch_name);\n\tif (arch == NULL) {\n\t\tpr_err(\"%s: unsupported arch %s\\n\", __func__, arch_name);\n\t\treturn ENOTSUP;\n\t}\n\n\tif (parch)\n\t\t*parch = arch;\n\n\tif (arch->init) {\n\t\terr = arch->init(arch, env ? env->cpuid : NULL);\n\t\tif (err) {\n\t\t\tpr_err(\"%s: failed to initialize %s arch priv area\\n\", __func__, arch->name);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\targs.ms = *ms;\n\tif (notes->options && notes->options->full_addr)\n\t\tnotes->start = map__objdump_2mem(ms->map, ms->sym->start);\n\telse\n\t\tnotes->start = map__rip_2objdump(ms->map, ms->sym->start);\n\n\treturn symbol__disassemble(sym, &args);\n}\n\nstatic void insert_source_line(struct rb_root *root, struct annotation_line *al,\n\t\t\t       struct annotation_options *opts)\n{\n\tstruct annotation_line *iter;\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint i, ret;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\titer = rb_entry(parent, struct annotation_line, rb_node);\n\n\t\tret = strcmp(iter->path, al->path);\n\t\tif (ret == 0) {\n\t\t\tfor (i = 0; i < al->data_nr; i++) {\n\t\t\t\titer->data[i].percent_sum += annotation_data__percent(&al->data[i],\n\t\t\t\t\t\t\t\t\t\t      opts->percent_type);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tfor (i = 0; i < al->data_nr; i++) {\n\t\tal->data[i].percent_sum = annotation_data__percent(&al->data[i],\n\t\t\t\t\t\t\t\t   opts->percent_type);\n\t}\n\n\trb_link_node(&al->rb_node, parent, p);\n\trb_insert_color(&al->rb_node, root);\n}\n\nstatic int cmp_source_line(struct annotation_line *a, struct annotation_line *b)\n{\n\tint i;\n\n\tfor (i = 0; i < a->data_nr; i++) {\n\t\tif (a->data[i].percent_sum == b->data[i].percent_sum)\n\t\t\tcontinue;\n\t\treturn a->data[i].percent_sum > b->data[i].percent_sum;\n\t}\n\n\treturn 0;\n}\n\nstatic void __resort_source_line(struct rb_root *root, struct annotation_line *al)\n{\n\tstruct annotation_line *iter;\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\titer = rb_entry(parent, struct annotation_line, rb_node);\n\n\t\tif (cmp_source_line(al, iter))\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&al->rb_node, parent, p);\n\trb_insert_color(&al->rb_node, root);\n}\n\nstatic void resort_source_line(struct rb_root *dest_root, struct rb_root *src_root)\n{\n\tstruct annotation_line *al;\n\tstruct rb_node *node;\n\n\tnode = rb_first(src_root);\n\twhile (node) {\n\t\tstruct rb_node *next;\n\n\t\tal = rb_entry(node, struct annotation_line, rb_node);\n\t\tnext = rb_next(node);\n\t\trb_erase(node, src_root);\n\n\t\t__resort_source_line(dest_root, al);\n\t\tnode = next;\n\t}\n}\n\nstatic void print_summary(struct rb_root *root, const char *filename)\n{\n\tstruct annotation_line *al;\n\tstruct rb_node *node;\n\n\tprintf(\"\\nSorted summary for file %s\\n\", filename);\n\tprintf(\"----------------------------------------------\\n\\n\");\n\n\tif (RB_EMPTY_ROOT(root)) {\n\t\tprintf(\" Nothing higher than %1.1f%%\\n\", MIN_GREEN);\n\t\treturn;\n\t}\n\n\tnode = rb_first(root);\n\twhile (node) {\n\t\tdouble percent, percent_max = 0.0;\n\t\tconst char *color;\n\t\tchar *path;\n\t\tint i;\n\n\t\tal = rb_entry(node, struct annotation_line, rb_node);\n\t\tfor (i = 0; i < al->data_nr; i++) {\n\t\t\tpercent = al->data[i].percent_sum;\n\t\t\tcolor = get_percent_color(percent);\n\t\t\tcolor_fprintf(stdout, color, \" %7.2f\", percent);\n\n\t\t\tif (percent > percent_max)\n\t\t\t\tpercent_max = percent;\n\t\t}\n\n\t\tpath = al->path;\n\t\tcolor = get_percent_color(percent_max);\n\t\tcolor_fprintf(stdout, color, \" %s\\n\", path);\n\n\t\tnode = rb_next(node);\n\t}\n}\n\nstatic void symbol__annotate_hits(struct symbol *sym, struct evsel *evsel)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\tstruct sym_hist *h = annotation__histogram(notes, evsel->core.idx);\n\tu64 len = symbol__size(sym), offset;\n\n\tfor (offset = 0; offset < len; ++offset)\n\t\tif (h->addr[offset].nr_samples != 0)\n\t\t\tprintf(\"%*\" PRIx64 \": %\" PRIu64 \"\\n\", BITS_PER_LONG / 2,\n\t\t\t       sym->start + offset, h->addr[offset].nr_samples);\n\tprintf(\"%*s: %\" PRIu64 \"\\n\", BITS_PER_LONG / 2, \"h->nr_samples\", h->nr_samples);\n}\n\nstatic int annotated_source__addr_fmt_width(struct list_head *lines, u64 start)\n{\n\tchar bf[32];\n\tstruct annotation_line *line;\n\n\tlist_for_each_entry_reverse(line, lines, node) {\n\t\tif (line->offset != -1)\n\t\t\treturn scnprintf(bf, sizeof(bf), \"%\" PRIx64, start + line->offset);\n\t}\n\n\treturn 0;\n}\n\nint symbol__annotate_printf(struct map_symbol *ms, struct evsel *evsel,\n\t\t\t    struct annotation_options *opts)\n{\n\tstruct map *map = ms->map;\n\tstruct symbol *sym = ms->sym;\n\tstruct dso *dso = map__dso(map);\n\tchar *filename;\n\tconst char *d_filename;\n\tconst char *evsel_name = evsel__name(evsel);\n\tstruct annotation *notes = symbol__annotation(sym);\n\tstruct sym_hist *h = annotation__histogram(notes, evsel->core.idx);\n\tstruct annotation_line *pos, *queue = NULL;\n\tu64 start = map__rip_2objdump(map, sym->start);\n\tint printed = 2, queue_len = 0, addr_fmt_width;\n\tint more = 0;\n\tbool context = opts->context;\n\tu64 len;\n\tint width = symbol_conf.show_total_period ? 12 : 8;\n\tint graph_dotted_len;\n\tchar buf[512];\n\n\tfilename = strdup(dso->long_name);\n\tif (!filename)\n\t\treturn -ENOMEM;\n\n\tif (opts->full_path)\n\t\td_filename = filename;\n\telse\n\t\td_filename = basename(filename);\n\n\tlen = symbol__size(sym);\n\n\tif (evsel__is_group_event(evsel)) {\n\t\twidth *= evsel->core.nr_members;\n\t\tevsel__group_desc(evsel, buf, sizeof(buf));\n\t\tevsel_name = buf;\n\t}\n\n\tgraph_dotted_len = printf(\" %-*.*s|\tSource code & Disassembly of %s for %s (%\" PRIu64 \" samples, \"\n\t\t\t\t  \"percent: %s)\\n\",\n\t\t\t\t  width, width, symbol_conf.show_total_period ? \"Period\" :\n\t\t\t\t  symbol_conf.show_nr_samples ? \"Samples\" : \"Percent\",\n\t\t\t\t  d_filename, evsel_name, h->nr_samples,\n\t\t\t\t  percent_type_str(opts->percent_type));\n\n\tprintf(\"%-*.*s----\\n\",\n\t       graph_dotted_len, graph_dotted_len, graph_dotted_line);\n\n\tif (verbose > 0)\n\t\tsymbol__annotate_hits(sym, evsel);\n\n\taddr_fmt_width = annotated_source__addr_fmt_width(&notes->src->source, start);\n\n\tlist_for_each_entry(pos, &notes->src->source, node) {\n\t\tint err;\n\n\t\tif (context && queue == NULL) {\n\t\t\tqueue = pos;\n\t\t\tqueue_len = 0;\n\t\t}\n\n\t\terr = annotation_line__print(pos, sym, start, evsel, len,\n\t\t\t\t\t     opts->min_pcnt, printed, opts->max_lines,\n\t\t\t\t\t     queue, addr_fmt_width, opts->percent_type);\n\n\t\tswitch (err) {\n\t\tcase 0:\n\t\t\t++printed;\n\t\t\tif (context) {\n\t\t\t\tprinted += queue_len;\n\t\t\t\tqueue = NULL;\n\t\t\t\tqueue_len = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\t++more;\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\t \n\t\t\tif (!context)\n\t\t\t\tbreak;\n\t\t\tif (queue_len == context)\n\t\t\t\tqueue = list_entry(queue->node.next, typeof(*queue), node);\n\t\t\telse\n\t\t\t\t++queue_len;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(filename);\n\n\treturn more;\n}\n\nstatic void FILE__set_percent_color(void *fp __maybe_unused,\n\t\t\t\t    double percent __maybe_unused,\n\t\t\t\t    bool current __maybe_unused)\n{\n}\n\nstatic int FILE__set_jumps_percent_color(void *fp __maybe_unused,\n\t\t\t\t\t int nr __maybe_unused, bool current __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int FILE__set_color(void *fp __maybe_unused, int color __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic void FILE__printf(void *fp, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(fp, fmt, args);\n\tva_end(args);\n}\n\nstatic void FILE__write_graph(void *fp, int graph)\n{\n\tconst char *s;\n\tswitch (graph) {\n\n\tcase DARROW_CHAR: s = \"\u2193\"; break;\n\tcase UARROW_CHAR: s = \"\u2191\"; break;\n\tcase LARROW_CHAR: s = \"\u2190\"; break;\n\tcase RARROW_CHAR: s = \"\u2192\"; break;\n\tdefault:\t\ts = \"?\"; break;\n\t}\n\n\tfputs(s, fp);\n}\n\nstatic int symbol__annotate_fprintf2(struct symbol *sym, FILE *fp,\n\t\t\t\t     struct annotation_options *opts)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\tstruct annotation_write_ops wops = {\n\t\t.first_line\t\t = true,\n\t\t.obj\t\t\t = fp,\n\t\t.set_color\t\t = FILE__set_color,\n\t\t.set_percent_color\t = FILE__set_percent_color,\n\t\t.set_jumps_percent_color = FILE__set_jumps_percent_color,\n\t\t.printf\t\t\t = FILE__printf,\n\t\t.write_graph\t\t = FILE__write_graph,\n\t};\n\tstruct annotation_line *al;\n\n\tlist_for_each_entry(al, &notes->src->source, node) {\n\t\tif (annotation_line__filter(al, notes))\n\t\t\tcontinue;\n\t\tannotation_line__write(al, notes, &wops, opts);\n\t\tfputc('\\n', fp);\n\t\twops.first_line = false;\n\t}\n\n\treturn 0;\n}\n\nint map_symbol__annotation_dump(struct map_symbol *ms, struct evsel *evsel,\n\t\t\t\tstruct annotation_options *opts)\n{\n\tconst char *ev_name = evsel__name(evsel);\n\tchar buf[1024];\n\tchar *filename;\n\tint err = -1;\n\tFILE *fp;\n\n\tif (asprintf(&filename, \"%s.annotation\", ms->sym->name) < 0)\n\t\treturn -1;\n\n\tfp = fopen(filename, \"w\");\n\tif (fp == NULL)\n\t\tgoto out_free_filename;\n\n\tif (evsel__is_group_event(evsel)) {\n\t\tevsel__group_desc(evsel, buf, sizeof(buf));\n\t\tev_name = buf;\n\t}\n\n\tfprintf(fp, \"%s() %s\\nEvent: %s\\n\\n\",\n\t\tms->sym->name, map__dso(ms->map)->long_name, ev_name);\n\tsymbol__annotate_fprintf2(ms->sym, fp, opts);\n\n\tfclose(fp);\n\terr = 0;\nout_free_filename:\n\tfree(filename);\n\treturn err;\n}\n\nvoid symbol__annotate_zero_histogram(struct symbol *sym, int evidx)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\tstruct sym_hist *h = annotation__histogram(notes, evidx);\n\n\tmemset(h, 0, notes->src->sizeof_sym_hist);\n}\n\nvoid symbol__annotate_decay_histogram(struct symbol *sym, int evidx)\n{\n\tstruct annotation *notes = symbol__annotation(sym);\n\tstruct sym_hist *h = annotation__histogram(notes, evidx);\n\tint len = symbol__size(sym), offset;\n\n\th->nr_samples = 0;\n\tfor (offset = 0; offset < len; ++offset) {\n\t\th->addr[offset].nr_samples = h->addr[offset].nr_samples * 7 / 8;\n\t\th->nr_samples += h->addr[offset].nr_samples;\n\t}\n}\n\nvoid annotated_source__purge(struct annotated_source *as)\n{\n\tstruct annotation_line *al, *n;\n\n\tlist_for_each_entry_safe(al, n, &as->source, node) {\n\t\tlist_del_init(&al->node);\n\t\tdisasm_line__free(disasm_line(al));\n\t}\n}\n\nstatic size_t disasm_line__fprintf(struct disasm_line *dl, FILE *fp)\n{\n\tsize_t printed;\n\n\tif (dl->al.offset == -1)\n\t\treturn fprintf(fp, \"%s\\n\", dl->al.line);\n\n\tprinted = fprintf(fp, \"%#\" PRIx64 \" %s\", dl->al.offset, dl->ins.name);\n\n\tif (dl->ops.raw[0] != '\\0') {\n\t\tprinted += fprintf(fp, \"%.*s %s\\n\", 6 - (int)printed, \" \",\n\t\t\t\t   dl->ops.raw);\n\t}\n\n\treturn printed + fprintf(fp, \"\\n\");\n}\n\nsize_t disasm__fprintf(struct list_head *head, FILE *fp)\n{\n\tstruct disasm_line *pos;\n\tsize_t printed = 0;\n\n\tlist_for_each_entry(pos, head, al.node)\n\t\tprinted += disasm_line__fprintf(pos, fp);\n\n\treturn printed;\n}\n\nbool disasm_line__is_valid_local_jump(struct disasm_line *dl, struct symbol *sym)\n{\n\tif (!dl || !dl->ins.ops || !ins__is_jump(&dl->ins) ||\n\t    !disasm_line__has_local_offset(dl) || dl->ops.target.offset < 0 ||\n\t    dl->ops.target.offset >= (s64)symbol__size(sym))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid annotation__mark_jump_targets(struct annotation *notes, struct symbol *sym)\n{\n\tu64 offset, size = symbol__size(sym);\n\n\t \n\tif (strstr(sym->name, \"@plt\"))\n\t\treturn;\n\n\tfor (offset = 0; offset < size; ++offset) {\n\t\tstruct annotation_line *al = notes->offsets[offset];\n\t\tstruct disasm_line *dl;\n\n\t\tdl = disasm_line(al);\n\n\t\tif (!disasm_line__is_valid_local_jump(dl, sym))\n\t\t\tcontinue;\n\n\t\tal = notes->offsets[dl->ops.target.offset];\n\n\t\t \n\t\tif (al == NULL)\n\t\t\tcontinue;\n\n\t\tif (++al->jump_sources > notes->max_jump_sources)\n\t\t\tnotes->max_jump_sources = al->jump_sources;\n\t}\n}\n\nvoid annotation__set_offsets(struct annotation *notes, s64 size)\n{\n\tstruct annotation_line *al;\n\n\tnotes->max_line_len = 0;\n\tnotes->nr_entries = 0;\n\tnotes->nr_asm_entries = 0;\n\n\tlist_for_each_entry(al, &notes->src->source, node) {\n\t\tsize_t line_len = strlen(al->line);\n\n\t\tif (notes->max_line_len < line_len)\n\t\t\tnotes->max_line_len = line_len;\n\t\tal->idx = notes->nr_entries++;\n\t\tif (al->offset != -1) {\n\t\t\tal->idx_asm = notes->nr_asm_entries++;\n\t\t\t \n\t\t\tif (al->offset < size)\n\t\t\t\tnotes->offsets[al->offset] = al;\n\t\t} else\n\t\t\tal->idx_asm = -1;\n\t}\n}\n\nstatic inline int width_jumps(int n)\n{\n\tif (n >= 100)\n\t\treturn 5;\n\tif (n / 10)\n\t\treturn 2;\n\treturn 1;\n}\n\nstatic int annotation__max_ins_name(struct annotation *notes)\n{\n\tint max_name = 0, len;\n\tstruct annotation_line *al;\n\n        list_for_each_entry(al, &notes->src->source, node) {\n\t\tif (al->offset == -1)\n\t\t\tcontinue;\n\n\t\tlen = strlen(disasm_line(al)->ins.name);\n\t\tif (max_name < len)\n\t\t\tmax_name = len;\n\t}\n\n\treturn max_name;\n}\n\nvoid annotation__init_column_widths(struct annotation *notes, struct symbol *sym)\n{\n\tnotes->widths.addr = notes->widths.target =\n\t\tnotes->widths.min_addr = hex_width(symbol__size(sym));\n\tnotes->widths.max_addr = hex_width(sym->end);\n\tnotes->widths.jumps = width_jumps(notes->max_jump_sources);\n\tnotes->widths.max_ins_name = annotation__max_ins_name(notes);\n}\n\nvoid annotation__update_column_widths(struct annotation *notes)\n{\n\tif (notes->options->use_offset)\n\t\tnotes->widths.target = notes->widths.min_addr;\n\telse if (notes->options->full_addr)\n\t\tnotes->widths.target = BITS_PER_LONG / 4;\n\telse\n\t\tnotes->widths.target = notes->widths.max_addr;\n\n\tnotes->widths.addr = notes->widths.target;\n\n\tif (notes->options->show_nr_jumps)\n\t\tnotes->widths.addr += notes->widths.jumps + 1;\n}\n\nvoid annotation__toggle_full_addr(struct annotation *notes, struct map_symbol *ms)\n{\n\tnotes->options->full_addr = !notes->options->full_addr;\n\n\tif (notes->options->full_addr)\n\t\tnotes->start = map__objdump_2mem(ms->map, ms->sym->start);\n\telse\n\t\tnotes->start = map__rip_2objdump(ms->map, ms->sym->start);\n\n\tannotation__update_column_widths(notes);\n}\n\nstatic void annotation__calc_lines(struct annotation *notes, struct map *map,\n\t\t\t\t   struct rb_root *root,\n\t\t\t\t   struct annotation_options *opts)\n{\n\tstruct annotation_line *al;\n\tstruct rb_root tmp_root = RB_ROOT;\n\n\tlist_for_each_entry(al, &notes->src->source, node) {\n\t\tdouble percent_max = 0.0;\n\t\tint i;\n\n\t\tfor (i = 0; i < al->data_nr; i++) {\n\t\t\tdouble percent;\n\n\t\t\tpercent = annotation_data__percent(&al->data[i],\n\t\t\t\t\t\t\t   opts->percent_type);\n\n\t\t\tif (percent > percent_max)\n\t\t\t\tpercent_max = percent;\n\t\t}\n\n\t\tif (percent_max <= 0.5)\n\t\t\tcontinue;\n\n\t\tal->path = get_srcline(map__dso(map), notes->start + al->offset, NULL,\n\t\t\t\t       false, true, notes->start + al->offset);\n\t\tinsert_source_line(&tmp_root, al, opts);\n\t}\n\n\tresort_source_line(root, &tmp_root);\n}\n\nstatic void symbol__calc_lines(struct map_symbol *ms, struct rb_root *root,\n\t\t\t       struct annotation_options *opts)\n{\n\tstruct annotation *notes = symbol__annotation(ms->sym);\n\n\tannotation__calc_lines(notes, ms->map, root, opts);\n}\n\nint symbol__tty_annotate2(struct map_symbol *ms, struct evsel *evsel,\n\t\t\t  struct annotation_options *opts)\n{\n\tstruct dso *dso = map__dso(ms->map);\n\tstruct symbol *sym = ms->sym;\n\tstruct rb_root source_line = RB_ROOT;\n\tstruct hists *hists = evsel__hists(evsel);\n\tchar buf[1024];\n\tint err;\n\n\terr = symbol__annotate2(ms, evsel, opts, NULL);\n\tif (err) {\n\t\tchar msg[BUFSIZ];\n\n\t\tdso->annotate_warned = true;\n\t\tsymbol__strerror_disassemble(ms, err, msg, sizeof(msg));\n\t\tui__error(\"Couldn't annotate %s:\\n%s\", sym->name, msg);\n\t\treturn -1;\n\t}\n\n\tif (opts->print_lines) {\n\t\tsrcline_full_filename = opts->full_path;\n\t\tsymbol__calc_lines(ms, &source_line, opts);\n\t\tprint_summary(&source_line, dso->long_name);\n\t}\n\n\thists__scnprintf_title(hists, buf, sizeof(buf));\n\tfprintf(stdout, \"%s, [percent: %s]\\n%s() %s\\n\",\n\t\tbuf, percent_type_str(opts->percent_type), sym->name, dso->long_name);\n\tsymbol__annotate_fprintf2(sym, stdout, opts);\n\n\tannotated_source__purge(symbol__annotation(sym)->src);\n\n\treturn 0;\n}\n\nint symbol__tty_annotate(struct map_symbol *ms, struct evsel *evsel,\n\t\t\t struct annotation_options *opts)\n{\n\tstruct dso *dso = map__dso(ms->map);\n\tstruct symbol *sym = ms->sym;\n\tstruct rb_root source_line = RB_ROOT;\n\tint err;\n\n\terr = symbol__annotate(ms, evsel, opts, NULL);\n\tif (err) {\n\t\tchar msg[BUFSIZ];\n\n\t\tdso->annotate_warned = true;\n\t\tsymbol__strerror_disassemble(ms, err, msg, sizeof(msg));\n\t\tui__error(\"Couldn't annotate %s:\\n%s\", sym->name, msg);\n\t\treturn -1;\n\t}\n\n\tsymbol__calc_percent(sym, evsel);\n\n\tif (opts->print_lines) {\n\t\tsrcline_full_filename = opts->full_path;\n\t\tsymbol__calc_lines(ms, &source_line, opts);\n\t\tprint_summary(&source_line, dso->long_name);\n\t}\n\n\tsymbol__annotate_printf(ms, evsel, opts);\n\n\tannotated_source__purge(symbol__annotation(sym)->src);\n\n\treturn 0;\n}\n\nbool ui__has_annotation(void)\n{\n\treturn use_browser == 1 && perf_hpp_list.sym;\n}\n\n\nstatic double annotation_line__max_percent(struct annotation_line *al,\n\t\t\t\t\t   struct annotation *notes,\n\t\t\t\t\t   unsigned int percent_type)\n{\n\tdouble percent_max = 0.0;\n\tint i;\n\n\tfor (i = 0; i < notes->nr_events; i++) {\n\t\tdouble percent;\n\n\t\tpercent = annotation_data__percent(&al->data[i],\n\t\t\t\t\t\t   percent_type);\n\n\t\tif (percent > percent_max)\n\t\t\tpercent_max = percent;\n\t}\n\n\treturn percent_max;\n}\n\nstatic void disasm_line__write(struct disasm_line *dl, struct annotation *notes,\n\t\t\t       void *obj, char *bf, size_t size,\n\t\t\t       void (*obj__printf)(void *obj, const char *fmt, ...),\n\t\t\t       void (*obj__write_graph)(void *obj, int graph))\n{\n\tif (dl->ins.ops && dl->ins.ops->scnprintf) {\n\t\tif (ins__is_jump(&dl->ins)) {\n\t\t\tbool fwd;\n\n\t\t\tif (dl->ops.target.outside)\n\t\t\t\tgoto call_like;\n\t\t\tfwd = dl->ops.target.offset > dl->al.offset;\n\t\t\tobj__write_graph(obj, fwd ? DARROW_CHAR : UARROW_CHAR);\n\t\t\tobj__printf(obj, \" \");\n\t\t} else if (ins__is_call(&dl->ins)) {\ncall_like:\n\t\t\tobj__write_graph(obj, RARROW_CHAR);\n\t\t\tobj__printf(obj, \" \");\n\t\t} else if (ins__is_ret(&dl->ins)) {\n\t\t\tobj__write_graph(obj, LARROW_CHAR);\n\t\t\tobj__printf(obj, \" \");\n\t\t} else {\n\t\t\tobj__printf(obj, \"  \");\n\t\t}\n\t} else {\n\t\tobj__printf(obj, \"  \");\n\t}\n\n\tdisasm_line__scnprintf(dl, bf, size, !notes->options->use_offset, notes->widths.max_ins_name);\n}\n\nstatic void ipc_coverage_string(char *bf, int size, struct annotation *notes)\n{\n\tdouble ipc = 0.0, coverage = 0.0;\n\n\tif (notes->hit_cycles)\n\t\tipc = notes->hit_insn / ((double)notes->hit_cycles);\n\n\tif (notes->total_insn) {\n\t\tcoverage = notes->cover_insn * 100.0 /\n\t\t\t((double)notes->total_insn);\n\t}\n\n\tscnprintf(bf, size, \"(Average IPC: %.2f, IPC Coverage: %.1f%%)\",\n\t\t  ipc, coverage);\n}\n\nstatic void __annotation_line__write(struct annotation_line *al, struct annotation *notes,\n\t\t\t\t     bool first_line, bool current_entry, bool change_color, int width,\n\t\t\t\t     void *obj, unsigned int percent_type,\n\t\t\t\t     int  (*obj__set_color)(void *obj, int color),\n\t\t\t\t     void (*obj__set_percent_color)(void *obj, double percent, bool current),\n\t\t\t\t     int  (*obj__set_jumps_percent_color)(void *obj, int nr, bool current),\n\t\t\t\t     void (*obj__printf)(void *obj, const char *fmt, ...),\n\t\t\t\t     void (*obj__write_graph)(void *obj, int graph))\n\n{\n\tdouble percent_max = annotation_line__max_percent(al, notes, percent_type);\n\tint pcnt_width = annotation__pcnt_width(notes),\n\t    cycles_width = annotation__cycles_width(notes);\n\tbool show_title = false;\n\tchar bf[256];\n\tint printed;\n\n\tif (first_line && (al->offset == -1 || percent_max == 0.0)) {\n\t\tif (notes->have_cycles) {\n\t\t\tif (al->ipc == 0.0 && al->cycles == 0)\n\t\t\t\tshow_title = true;\n\t\t} else\n\t\t\tshow_title = true;\n\t}\n\n\tif (al->offset != -1 && percent_max != 0.0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < notes->nr_events; i++) {\n\t\t\tdouble percent;\n\n\t\t\tpercent = annotation_data__percent(&al->data[i], percent_type);\n\n\t\t\tobj__set_percent_color(obj, percent, current_entry);\n\t\t\tif (symbol_conf.show_total_period) {\n\t\t\t\tobj__printf(obj, \"%11\" PRIu64 \" \", al->data[i].he.period);\n\t\t\t} else if (symbol_conf.show_nr_samples) {\n\t\t\t\tobj__printf(obj, \"%6\" PRIu64 \" \",\n\t\t\t\t\t\t   al->data[i].he.nr_samples);\n\t\t\t} else {\n\t\t\t\tobj__printf(obj, \"%6.2f \", percent);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tobj__set_percent_color(obj, 0, current_entry);\n\n\t\tif (!show_title)\n\t\t\tobj__printf(obj, \"%-*s\", pcnt_width, \" \");\n\t\telse {\n\t\t\tobj__printf(obj, \"%-*s\", pcnt_width,\n\t\t\t\t\t   symbol_conf.show_total_period ? \"Period\" :\n\t\t\t\t\t   symbol_conf.show_nr_samples ? \"Samples\" : \"Percent\");\n\t\t}\n\t}\n\n\tif (notes->have_cycles) {\n\t\tif (al->ipc)\n\t\t\tobj__printf(obj, \"%*.2f \", ANNOTATION__IPC_WIDTH - 1, al->ipc);\n\t\telse if (!show_title)\n\t\t\tobj__printf(obj, \"%*s\", ANNOTATION__IPC_WIDTH, \" \");\n\t\telse\n\t\t\tobj__printf(obj, \"%*s \", ANNOTATION__IPC_WIDTH - 1, \"IPC\");\n\n\t\tif (!notes->options->show_minmax_cycle) {\n\t\t\tif (al->cycles)\n\t\t\t\tobj__printf(obj, \"%*\" PRIu64 \" \",\n\t\t\t\t\t   ANNOTATION__CYCLES_WIDTH - 1, al->cycles);\n\t\t\telse if (!show_title)\n\t\t\t\tobj__printf(obj, \"%*s\",\n\t\t\t\t\t    ANNOTATION__CYCLES_WIDTH, \" \");\n\t\t\telse\n\t\t\t\tobj__printf(obj, \"%*s \",\n\t\t\t\t\t    ANNOTATION__CYCLES_WIDTH - 1,\n\t\t\t\t\t    \"Cycle\");\n\t\t} else {\n\t\t\tif (al->cycles) {\n\t\t\t\tchar str[32];\n\n\t\t\t\tscnprintf(str, sizeof(str),\n\t\t\t\t\t\"%\" PRIu64 \"(%\" PRIu64 \"/%\" PRIu64 \")\",\n\t\t\t\t\tal->cycles, al->cycles_min,\n\t\t\t\t\tal->cycles_max);\n\n\t\t\t\tobj__printf(obj, \"%*s \",\n\t\t\t\t\t    ANNOTATION__MINMAX_CYCLES_WIDTH - 1,\n\t\t\t\t\t    str);\n\t\t\t} else if (!show_title)\n\t\t\t\tobj__printf(obj, \"%*s\",\n\t\t\t\t\t    ANNOTATION__MINMAX_CYCLES_WIDTH,\n\t\t\t\t\t    \" \");\n\t\t\telse\n\t\t\t\tobj__printf(obj, \"%*s \",\n\t\t\t\t\t    ANNOTATION__MINMAX_CYCLES_WIDTH - 1,\n\t\t\t\t\t    \"Cycle(min/max)\");\n\t\t}\n\n\t\tif (show_title && !*al->line) {\n\t\t\tipc_coverage_string(bf, sizeof(bf), notes);\n\t\t\tobj__printf(obj, \"%*s\", ANNOTATION__AVG_IPC_WIDTH, bf);\n\t\t}\n\t}\n\n\tobj__printf(obj, \" \");\n\n\tif (!*al->line)\n\t\tobj__printf(obj, \"%-*s\", width - pcnt_width - cycles_width, \" \");\n\telse if (al->offset == -1) {\n\t\tif (al->line_nr && notes->options->show_linenr)\n\t\t\tprinted = scnprintf(bf, sizeof(bf), \"%-*d \", notes->widths.addr + 1, al->line_nr);\n\t\telse\n\t\t\tprinted = scnprintf(bf, sizeof(bf), \"%-*s  \", notes->widths.addr, \" \");\n\t\tobj__printf(obj, bf);\n\t\tobj__printf(obj, \"%-*s\", width - printed - pcnt_width - cycles_width + 1, al->line);\n\t} else {\n\t\tu64 addr = al->offset;\n\t\tint color = -1;\n\n\t\tif (!notes->options->use_offset)\n\t\t\taddr += notes->start;\n\n\t\tif (!notes->options->use_offset) {\n\t\t\tprinted = scnprintf(bf, sizeof(bf), \"%\" PRIx64 \": \", addr);\n\t\t} else {\n\t\t\tif (al->jump_sources &&\n\t\t\t    notes->options->offset_level >= ANNOTATION__OFFSET_JUMP_TARGETS) {\n\t\t\t\tif (notes->options->show_nr_jumps) {\n\t\t\t\t\tint prev;\n\t\t\t\t\tprinted = scnprintf(bf, sizeof(bf), \"%*d \",\n\t\t\t\t\t\t\t    notes->widths.jumps,\n\t\t\t\t\t\t\t    al->jump_sources);\n\t\t\t\t\tprev = obj__set_jumps_percent_color(obj, al->jump_sources,\n\t\t\t\t\t\t\t\t\t    current_entry);\n\t\t\t\t\tobj__printf(obj, bf);\n\t\t\t\t\tobj__set_color(obj, prev);\n\t\t\t\t}\nprint_addr:\n\t\t\t\tprinted = scnprintf(bf, sizeof(bf), \"%*\" PRIx64 \": \",\n\t\t\t\t\t\t    notes->widths.target, addr);\n\t\t\t} else if (ins__is_call(&disasm_line(al)->ins) &&\n\t\t\t\t   notes->options->offset_level >= ANNOTATION__OFFSET_CALL) {\n\t\t\t\tgoto print_addr;\n\t\t\t} else if (notes->options->offset_level == ANNOTATION__MAX_OFFSET_LEVEL) {\n\t\t\t\tgoto print_addr;\n\t\t\t} else {\n\t\t\t\tprinted = scnprintf(bf, sizeof(bf), \"%-*s  \",\n\t\t\t\t\t\t    notes->widths.addr, \" \");\n\t\t\t}\n\t\t}\n\n\t\tif (change_color)\n\t\t\tcolor = obj__set_color(obj, HE_COLORSET_ADDR);\n\t\tobj__printf(obj, bf);\n\t\tif (change_color)\n\t\t\tobj__set_color(obj, color);\n\n\t\tdisasm_line__write(disasm_line(al), notes, obj, bf, sizeof(bf), obj__printf, obj__write_graph);\n\n\t\tobj__printf(obj, \"%-*s\", width - pcnt_width - cycles_width - 3 - printed, bf);\n\t}\n\n}\n\nvoid annotation_line__write(struct annotation_line *al, struct annotation *notes,\n\t\t\t    struct annotation_write_ops *wops,\n\t\t\t    struct annotation_options *opts)\n{\n\t__annotation_line__write(al, notes, wops->first_line, wops->current_entry,\n\t\t\t\t wops->change_color, wops->width, wops->obj,\n\t\t\t\t opts->percent_type,\n\t\t\t\t wops->set_color, wops->set_percent_color,\n\t\t\t\t wops->set_jumps_percent_color, wops->printf,\n\t\t\t\t wops->write_graph);\n}\n\nint symbol__annotate2(struct map_symbol *ms, struct evsel *evsel,\n\t\t      struct annotation_options *options, struct arch **parch)\n{\n\tstruct symbol *sym = ms->sym;\n\tstruct annotation *notes = symbol__annotation(sym);\n\tsize_t size = symbol__size(sym);\n\tint nr_pcnt = 1, err;\n\n\tnotes->offsets = zalloc(size * sizeof(struct annotation_line *));\n\tif (notes->offsets == NULL)\n\t\treturn ENOMEM;\n\n\tif (evsel__is_group_event(evsel))\n\t\tnr_pcnt = evsel->core.nr_members;\n\n\terr = symbol__annotate(ms, evsel, options, parch);\n\tif (err)\n\t\tgoto out_free_offsets;\n\n\tnotes->options = options;\n\n\tsymbol__calc_percent(sym, evsel);\n\n\tannotation__set_offsets(notes, size);\n\tannotation__mark_jump_targets(notes, sym);\n\tannotation__compute_ipc(notes, size);\n\tannotation__init_column_widths(notes, sym);\n\tnotes->nr_events = nr_pcnt;\n\n\tannotation__update_column_widths(notes);\n\tsym->annotate2 = 1;\n\n\treturn 0;\n\nout_free_offsets:\n\tzfree(&notes->offsets);\n\treturn err;\n}\n\nstatic int annotation__config(const char *var, const char *value, void *data)\n{\n\tstruct annotation_options *opt = data;\n\n\tif (!strstarts(var, \"annotate.\"))\n\t\treturn 0;\n\n\tif (!strcmp(var, \"annotate.offset_level\")) {\n\t\tperf_config_u8(&opt->offset_level, \"offset_level\", value);\n\n\t\tif (opt->offset_level > ANNOTATION__MAX_OFFSET_LEVEL)\n\t\t\topt->offset_level = ANNOTATION__MAX_OFFSET_LEVEL;\n\t\telse if (opt->offset_level < ANNOTATION__MIN_OFFSET_LEVEL)\n\t\t\topt->offset_level = ANNOTATION__MIN_OFFSET_LEVEL;\n\t} else if (!strcmp(var, \"annotate.hide_src_code\")) {\n\t\topt->hide_src_code = perf_config_bool(\"hide_src_code\", value);\n\t} else if (!strcmp(var, \"annotate.jump_arrows\")) {\n\t\topt->jump_arrows = perf_config_bool(\"jump_arrows\", value);\n\t} else if (!strcmp(var, \"annotate.show_linenr\")) {\n\t\topt->show_linenr = perf_config_bool(\"show_linenr\", value);\n\t} else if (!strcmp(var, \"annotate.show_nr_jumps\")) {\n\t\topt->show_nr_jumps = perf_config_bool(\"show_nr_jumps\", value);\n\t} else if (!strcmp(var, \"annotate.show_nr_samples\")) {\n\t\tsymbol_conf.show_nr_samples = perf_config_bool(\"show_nr_samples\",\n\t\t\t\t\t\t\t\tvalue);\n\t} else if (!strcmp(var, \"annotate.show_total_period\")) {\n\t\tsymbol_conf.show_total_period = perf_config_bool(\"show_total_period\",\n\t\t\t\t\t\t\t\tvalue);\n\t} else if (!strcmp(var, \"annotate.use_offset\")) {\n\t\topt->use_offset = perf_config_bool(\"use_offset\", value);\n\t} else if (!strcmp(var, \"annotate.disassembler_style\")) {\n\t\topt->disassembler_style = strdup(value);\n\t\tif (!opt->disassembler_style) {\n\t\t\tpr_err(\"Not enough memory for annotate.disassembler_style\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (!strcmp(var, \"annotate.objdump\")) {\n\t\topt->objdump_path = strdup(value);\n\t\tif (!opt->objdump_path) {\n\t\t\tpr_err(\"Not enough memory for annotate.objdump\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (!strcmp(var, \"annotate.addr2line\")) {\n\t\tsymbol_conf.addr2line_path = strdup(value);\n\t\tif (!symbol_conf.addr2line_path) {\n\t\t\tpr_err(\"Not enough memory for annotate.addr2line\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (!strcmp(var, \"annotate.demangle\")) {\n\t\tsymbol_conf.demangle = perf_config_bool(\"demangle\", value);\n\t} else if (!strcmp(var, \"annotate.demangle_kernel\")) {\n\t\tsymbol_conf.demangle_kernel = perf_config_bool(\"demangle_kernel\", value);\n\t} else {\n\t\tpr_debug(\"%s variable unknown, ignoring...\", var);\n\t}\n\n\treturn 0;\n}\n\nvoid annotation_options__init(struct annotation_options *opt)\n{\n\tmemset(opt, 0, sizeof(*opt));\n\n\t \n\topt->use_offset = true;\n\topt->jump_arrows = true;\n\topt->annotate_src = true;\n\topt->offset_level = ANNOTATION__OFFSET_JUMP_TARGETS;\n\topt->percent_type = PERCENT_PERIOD_LOCAL;\n}\n\n\nvoid annotation_options__exit(struct annotation_options *opt)\n{\n\tzfree(&opt->disassembler_style);\n\tzfree(&opt->objdump_path);\n}\n\nvoid annotation_config__init(struct annotation_options *opt)\n{\n\tperf_config(annotation__config, opt);\n}\n\nstatic unsigned int parse_percent_type(char *str1, char *str2)\n{\n\tunsigned int type = (unsigned int) -1;\n\n\tif (!strcmp(\"period\", str1)) {\n\t\tif (!strcmp(\"local\", str2))\n\t\t\ttype = PERCENT_PERIOD_LOCAL;\n\t\telse if (!strcmp(\"global\", str2))\n\t\t\ttype = PERCENT_PERIOD_GLOBAL;\n\t}\n\n\tif (!strcmp(\"hits\", str1)) {\n\t\tif (!strcmp(\"local\", str2))\n\t\t\ttype = PERCENT_HITS_LOCAL;\n\t\telse if (!strcmp(\"global\", str2))\n\t\t\ttype = PERCENT_HITS_GLOBAL;\n\t}\n\n\treturn type;\n}\n\nint annotate_parse_percent_type(const struct option *opt, const char *_str,\n\t\t\t\tint unset __maybe_unused)\n{\n\tstruct annotation_options *opts = opt->value;\n\tunsigned int type;\n\tchar *str1, *str2;\n\tint err = -1;\n\n\tstr1 = strdup(_str);\n\tif (!str1)\n\t\treturn -ENOMEM;\n\n\tstr2 = strchr(str1, '-');\n\tif (!str2)\n\t\tgoto out;\n\n\t*str2++ = 0;\n\n\ttype = parse_percent_type(str1, str2);\n\tif (type == (unsigned int) -1)\n\t\ttype = parse_percent_type(str2, str1);\n\tif (type != (unsigned int) -1) {\n\t\topts->percent_type = type;\n\t\terr = 0;\n\t}\n\nout:\n\tfree(str1);\n\treturn err;\n}\n\nint annotate_check_args(struct annotation_options *args)\n{\n\tif (args->prefix_strip && !args->prefix) {\n\t\tpr_err(\"--prefix-strip requires --prefix\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}