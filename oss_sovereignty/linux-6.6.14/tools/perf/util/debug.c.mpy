{
  "module_name": "debug.c",
  "hash_id": "e3e0ce96c81dda2e9cf7fd5a72ab6e429ec3041d80be7e08ea066ce8e4896ce3",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/debug.c",
  "human_readable_source": "\n \n\n#include <inttypes.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <api/debug.h>\n#include <linux/kernel.h>\n#include <linux/time64.h>\n#include <sys/time.h>\n#ifdef HAVE_BACKTRACE_SUPPORT\n#include <execinfo.h>\n#endif\n#include \"color.h\"\n#include \"event.h\"\n#include \"debug.h\"\n#include \"print_binary.h\"\n#include \"target.h\"\n#include \"trace-event.h\"\n#include \"ui/helpline.h\"\n#include \"ui/ui.h\"\n#include \"util/parse-sublevel-options.h\"\n\n#include <linux/ctype.h>\n\n#ifdef HAVE_LIBTRACEEVENT\n#include <traceevent/event-parse.h>\n#else\n#define LIBTRACEEVENT_VERSION 0\n#endif\n\nint verbose;\nint debug_peo_args;\nbool dump_trace = false, quiet = false;\nint debug_ordered_events;\nstatic int redirect_to_stderr;\nint debug_data_convert;\nstatic FILE *debug_file;\nbool debug_display_time;\n\nvoid debug_set_file(FILE *file)\n{\n\tdebug_file = file;\n}\n\nvoid debug_set_display_time(bool set)\n{\n\tdebug_display_time = set;\n}\n\nstatic int fprintf_time(FILE *file)\n{\n\tstruct timeval tod;\n\tstruct tm ltime;\n\tchar date[64];\n\n\tif (!debug_display_time)\n\t\treturn 0;\n\n\tif (gettimeofday(&tod, NULL) != 0)\n\t\treturn 0;\n\n\tif (localtime_r(&tod.tv_sec, &ltime) == NULL)\n\t\treturn 0;\n\n\tstrftime(date, sizeof(date),  \"%F %H:%M:%S\", &ltime);\n\treturn fprintf(file, \"[%s.%06lu] \", date, (long)tod.tv_usec);\n}\n\nint veprintf(int level, int var, const char *fmt, va_list args)\n{\n\tint ret = 0;\n\n\tif (var >= level) {\n\t\tif (use_browser >= 1 && !redirect_to_stderr) {\n\t\t\tui_helpline__vshow(fmt, args);\n\t\t} else {\n\t\t\tret = fprintf_time(debug_file);\n\t\t\tret += vfprintf(debug_file, fmt, args);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint eprintf(int level, int var, const char *fmt, ...)\n{\n\tva_list args;\n\tint ret;\n\n\tva_start(args, fmt);\n\tret = veprintf(level, var, fmt, args);\n\tva_end(args);\n\n\treturn ret;\n}\n\nstatic int veprintf_time(u64 t, const char *fmt, va_list args)\n{\n\tint ret = 0;\n\tu64 secs, usecs, nsecs = t;\n\n\tsecs   = nsecs / NSEC_PER_SEC;\n\tnsecs -= secs  * NSEC_PER_SEC;\n\tusecs  = nsecs / NSEC_PER_USEC;\n\n\tret = fprintf(stderr, \"[%13\" PRIu64 \".%06\" PRIu64 \"] \",\n\t\t      secs, usecs);\n\tret += vfprintf(stderr, fmt, args);\n\treturn ret;\n}\n\nint eprintf_time(int level, int var, u64 t, const char *fmt, ...)\n{\n\tint ret = 0;\n\tva_list args;\n\n\tif (var >= level) {\n\t\tva_start(args, fmt);\n\t\tret = veprintf_time(t, fmt, args);\n\t\tva_end(args);\n\t}\n\n\treturn ret;\n}\n\n \nvoid pr_stat(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tveprintf(1, verbose, fmt, args);\n\tva_end(args);\n\teprintf(1, verbose, \"\\n\");\n}\n\nint dump_printf(const char *fmt, ...)\n{\n\tva_list args;\n\tint ret = 0;\n\n\tif (dump_trace) {\n\t\tva_start(args, fmt);\n\t\tret = vprintf(fmt, args);\n\t\tva_end(args);\n\t}\n\n\treturn ret;\n}\n\nstatic int trace_event_printer(enum binary_printer_ops op,\n\t\t\t       unsigned int val, void *extra, FILE *fp)\n{\n\tconst char *color = PERF_COLOR_BLUE;\n\tunion perf_event *event = (union perf_event *)extra;\n\tunsigned char ch = (unsigned char)val;\n\tint printed = 0;\n\n\tswitch (op) {\n\tcase BINARY_PRINT_DATA_BEGIN:\n\t\tprinted += fprintf(fp, \".\");\n\t\tprinted += color_fprintf(fp, color, \"\\n. ... raw event: size %d bytes\\n\",\n\t\t\t\t\t event->header.size);\n\t\tbreak;\n\tcase BINARY_PRINT_LINE_BEGIN:\n\t\tprinted += fprintf(fp, \".\");\n\t\tbreak;\n\tcase BINARY_PRINT_ADDR:\n\t\tprinted += color_fprintf(fp, color, \"  %04x: \", val);\n\t\tbreak;\n\tcase BINARY_PRINT_NUM_DATA:\n\t\tprinted += color_fprintf(fp, color, \" %02x\", val);\n\t\tbreak;\n\tcase BINARY_PRINT_NUM_PAD:\n\t\tprinted += color_fprintf(fp, color, \"   \");\n\t\tbreak;\n\tcase BINARY_PRINT_SEP:\n\t\tprinted += color_fprintf(fp, color, \"  \");\n\t\tbreak;\n\tcase BINARY_PRINT_CHAR_DATA:\n\t\tprinted += color_fprintf(fp, color, \"%c\",\n\t\t\t      isprint(ch) && isascii(ch) ? ch : '.');\n\t\tbreak;\n\tcase BINARY_PRINT_CHAR_PAD:\n\t\tprinted += color_fprintf(fp, color, \" \");\n\t\tbreak;\n\tcase BINARY_PRINT_LINE_END:\n\t\tprinted += color_fprintf(fp, color, \"\\n\");\n\t\tbreak;\n\tcase BINARY_PRINT_DATA_END:\n\t\tprinted += fprintf(fp, \"\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn printed;\n}\n\nvoid trace_event(union perf_event *event)\n{\n\tunsigned char *raw_event = (void *)event;\n\n\tif (!dump_trace)\n\t\treturn;\n\n\tprint_binary(raw_event, event->header.size, 16,\n\t\t     trace_event_printer, event);\n}\n\nstatic struct sublevel_option debug_opts[] = {\n\t{ .name = \"verbose\",\t\t.value_ptr = &verbose },\n\t{ .name = \"ordered-events\",\t.value_ptr = &debug_ordered_events},\n\t{ .name = \"stderr\",\t\t.value_ptr = &redirect_to_stderr},\n\t{ .name = \"data-convert\",\t.value_ptr = &debug_data_convert },\n\t{ .name = \"perf-event-open\",\t.value_ptr = &debug_peo_args },\n\t{ .name = NULL, }\n};\n\nint perf_debug_option(const char *str)\n{\n\tint ret;\n\n\tret = perf_parse_sublevel_options(str, debug_opts);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tverbose = (verbose < 0) || (verbose > 10) ? 0 : verbose;\n\n#if LIBTRACEEVENT_VERSION >= MAKE_LIBTRACEEVENT_VERSION(1, 3, 0)\n\tif (verbose == 1)\n\t\ttep_set_loglevel(TEP_LOG_INFO);\n\telse if (verbose == 2)\n\t\ttep_set_loglevel(TEP_LOG_DEBUG);\n\telse if (verbose >= 3)\n\t\ttep_set_loglevel(TEP_LOG_ALL);\n#endif\n\treturn 0;\n}\n\nint perf_quiet_option(void)\n{\n\tstruct sublevel_option *opt = &debug_opts[0];\n\n\t \n\twhile (opt->name) {\n\t\t*opt->value_ptr = -1;\n\t\topt++;\n\t}\n\n\t \n\tredirect_to_stderr = 0;\n\tdebug_peo_args = 0;\n\n\treturn 0;\n}\n\n#define DEBUG_WRAPPER(__n, __l)\t\t\t\t\\\nstatic int pr_ ## __n ## _wrapper(const char *fmt, ...)\t\\\n{\t\t\t\t\t\t\t\\\n\tva_list args;\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\n\tva_start(args, fmt);\t\t\t\t\\\n\tret = veprintf(__l, verbose, fmt, args);\t\\\n\tva_end(args);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\\\n}\n\nDEBUG_WRAPPER(warning, 0);\nDEBUG_WRAPPER(debug, 1);\n\nvoid perf_debug_setup(void)\n{\n\tdebug_set_file(stderr);\n\tlibapi_set_print(pr_warning_wrapper, pr_warning_wrapper, pr_debug_wrapper);\n}\n\n \n#ifdef HAVE_BACKTRACE_SUPPORT\nvoid dump_stack(void)\n{\n\tvoid *array[16];\n\tsize_t size = backtrace(array, ARRAY_SIZE(array));\n\tchar **strings = backtrace_symbols(array, size);\n\tsize_t i;\n\n\tprintf(\"Obtained %zd stack frames.\\n\", size);\n\n\tfor (i = 0; i < size; i++)\n\t\tprintf(\"%s\\n\", strings[i]);\n\n\tfree(strings);\n}\n#else\nvoid dump_stack(void) {}\n#endif\n\nvoid sighandler_dump_stack(int sig)\n{\n\tpsignal(sig, \"perf\");\n\tdump_stack();\n\tsignal(sig, SIG_DFL);\n\traise(sig);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}