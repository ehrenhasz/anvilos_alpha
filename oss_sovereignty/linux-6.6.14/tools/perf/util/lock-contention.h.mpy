{
  "module_name": "lock-contention.h",
  "hash_id": "39eaead390b2355e57892a06475b1bccc78bb7e7526ab3f355b8b73e74a33bfd",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/lock-contention.h",
  "human_readable_source": "\n#ifndef PERF_LOCK_CONTENTION_H\n#define PERF_LOCK_CONTENTION_H\n\n#include <linux/list.h>\n#include <linux/rbtree.h>\n\nstruct lock_filter {\n\tint\t\t\tnr_types;\n\tint\t\t\tnr_addrs;\n\tint\t\t\tnr_syms;\n\tunsigned int\t\t*types;\n\tunsigned long\t\t*addrs;\n\tchar\t\t\t**syms;\n};\n\nstruct lock_stat {\n\tstruct hlist_node\thash_entry;\n\tstruct rb_node\t\trb;\t\t \n\n\tu64\t\t\taddr;\t\t \n\tchar\t\t\t*name;\t\t \n\tu64\t\t\t*callstack;\n\n\tunsigned int\t\tnr_acquire;\n\tunsigned int\t\tnr_acquired;\n\tunsigned int\t\tnr_contended;\n\tunsigned int\t\tnr_release;\n\n\tunion {\n\t\tunsigned int\tnr_readlock;\n\t\tunsigned int\tflags;\n\t};\n\tunsigned int\t\tnr_trylock;\n\n\t \n\tu64                     avg_wait_time;\n\tu64\t\t\twait_time_total;\n\tu64\t\t\twait_time_min;\n\tu64\t\t\twait_time_max;\n\n\tint\t\t\tbroken;  \n\tint\t\t\tcombined;\n};\n\n \n#define SEQ_STATE_UNINITIALIZED      0\t        \n#define SEQ_STATE_RELEASED\t1\n#define SEQ_STATE_ACQUIRING\t2\n#define SEQ_STATE_ACQUIRED\t3\n#define SEQ_STATE_READ_ACQUIRED\t4\n#define SEQ_STATE_CONTENDED\t5\n\n \n#define MAX_LOCK_DEPTH 48\n\nstruct lock_stat *lock_stat_find(u64 addr);\nstruct lock_stat *lock_stat_findnew(u64 addr, const char *name, int flags);\n\nbool match_callstack_filter(struct machine *machine, u64 *callstack);\n\n \nstruct lock_seq_stat {\n\tstruct list_head        list;\n\tint\t\t\tstate;\n\tu64\t\t\tprev_event_time;\n\tu64                     addr;\n\n\tint                     read_count;\n};\n\nstruct thread_stat {\n\tstruct rb_node\t\trb;\n\n\tu32                     tid;\n\tstruct list_head        seq_list;\n};\n\n \n#define CONTENTION_STACK_DEPTH  8\n\n \n#define CONTENTION_STACK_SKIP  4\n\n \n#define LCB_F_SPIN\t(1U << 0)\n#define LCB_F_READ\t(1U << 1)\n#define LCB_F_WRITE\t(1U << 2)\n#define LCB_F_RT\t(1U << 3)\n#define LCB_F_PERCPU\t(1U << 4)\n#define LCB_F_MUTEX\t(1U << 5)\n\nstruct evlist;\nstruct machine;\nstruct target;\n\nstruct lock_contention_fails {\n\tint task;\n\tint stack;\n\tint time;\n\tint data;\n};\n\nstruct lock_contention {\n\tstruct evlist *evlist;\n\tstruct target *target;\n\tstruct machine *machine;\n\tstruct hlist_head *result;\n\tstruct lock_filter *filters;\n\tstruct lock_contention_fails fails;\n\tunsigned long map_nr_entries;\n\tint max_stack;\n\tint stack_skip;\n\tint aggr_mode;\n\tint owner;\n\tint nr_filtered;\n\tbool save_callstack;\n};\n\n#ifdef HAVE_BPF_SKEL\n\nint lock_contention_prepare(struct lock_contention *con);\nint lock_contention_start(void);\nint lock_contention_stop(void);\nint lock_contention_read(struct lock_contention *con);\nint lock_contention_finish(void);\n\n#else   \n\nstatic inline int lock_contention_prepare(struct lock_contention *con __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline int lock_contention_start(void) { return 0; }\nstatic inline int lock_contention_stop(void) { return 0; }\nstatic inline int lock_contention_finish(void) { return 0; }\n\nstatic inline int lock_contention_read(struct lock_contention *con __maybe_unused)\n{\n\treturn 0;\n}\n\n#endif   \n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}