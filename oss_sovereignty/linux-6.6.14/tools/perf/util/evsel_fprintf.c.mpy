{
  "module_name": "evsel_fprintf.c",
  "hash_id": "e0b5e388bb352f8b66764262f7ebe58544c695f6637b06e422675630c735dce1",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/evsel_fprintf.c",
  "human_readable_source": "\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include \"util/evlist.h\"\n#include \"evsel.h\"\n#include \"util/evsel_fprintf.h\"\n#include \"util/event.h\"\n#include \"callchain.h\"\n#include \"map.h\"\n#include \"strlist.h\"\n#include \"symbol.h\"\n#include \"srcline.h\"\n#include \"dso.h\"\n\n#ifdef HAVE_LIBTRACEEVENT\n#include <traceevent/event-parse.h>\n#endif\n\nstatic int comma_fprintf(FILE *fp, bool *first, const char *fmt, ...)\n{\n\tva_list args;\n\tint ret = 0;\n\n\tif (!*first) {\n\t\tret += fprintf(fp, \",\");\n\t} else {\n\t\tret += fprintf(fp, \":\");\n\t\t*first = false;\n\t}\n\n\tva_start(args, fmt);\n\tret += vfprintf(fp, fmt, args);\n\tva_end(args);\n\treturn ret;\n}\n\nstatic int __print_attr__fprintf(FILE *fp, const char *name, const char *val, void *priv)\n{\n\treturn comma_fprintf(fp, (bool *)priv, \" %s: %s\", name, val);\n}\n\nint evsel__fprintf(struct evsel *evsel, struct perf_attr_details *details, FILE *fp)\n{\n\tbool first = true;\n\tint printed = 0;\n\n\tif (details->event_group) {\n\t\tstruct evsel *pos;\n\n\t\tif (!evsel__is_group_leader(evsel))\n\t\t\treturn 0;\n\n\t\tif (evsel->core.nr_members > 1)\n\t\t\tprinted += fprintf(fp, \"%s{\", evsel->group_name ?: \"\");\n\n\t\tprinted += fprintf(fp, \"%s\", evsel__name(evsel));\n\t\tfor_each_group_member(pos, evsel)\n\t\t\tprinted += fprintf(fp, \",%s\", evsel__name(pos));\n\n\t\tif (evsel->core.nr_members > 1)\n\t\t\tprinted += fprintf(fp, \"}\");\n\t\tgoto out;\n\t}\n\n\tprinted += fprintf(fp, \"%s\", evsel__name(evsel));\n\n\tif (details->verbose) {\n\t\tprinted += perf_event_attr__fprintf(fp, &evsel->core.attr,\n\t\t\t\t\t\t    __print_attr__fprintf, &first);\n\t} else if (details->freq) {\n\t\tconst char *term = \"sample_freq\";\n\n\t\tif (!evsel->core.attr.freq)\n\t\t\tterm = \"sample_period\";\n\n\t\tprinted += comma_fprintf(fp, &first, \" %s=%\" PRIu64,\n\t\t\t\t\t term, (u64)evsel->core.attr.sample_freq);\n\t}\n\n#ifdef HAVE_LIBTRACEEVENT\n\tif (details->trace_fields) {\n\t\tstruct tep_format_field *field;\n\n\t\tif (evsel->core.attr.type != PERF_TYPE_TRACEPOINT) {\n\t\t\tprinted += comma_fprintf(fp, &first, \" (not a tracepoint)\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield = evsel->tp_format->format.fields;\n\t\tif (field == NULL) {\n\t\t\tprinted += comma_fprintf(fp, &first, \" (no trace field)\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tprinted += comma_fprintf(fp, &first, \" trace_fields: %s\", field->name);\n\n\t\tfield = field->next;\n\t\twhile (field) {\n\t\t\tprinted += comma_fprintf(fp, &first, \"%s\", field->name);\n\t\t\tfield = field->next;\n\t\t}\n\t}\n#endif\nout:\n\tfputc('\\n', fp);\n\treturn ++printed;\n}\n\n#ifndef PYTHON_PERF\nint sample__fprintf_callchain(struct perf_sample *sample, int left_alignment,\n\t\t\t      unsigned int print_opts, struct callchain_cursor *cursor,\n\t\t\t      struct strlist *bt_stop_list, FILE *fp)\n{\n\tint printed = 0;\n\tstruct callchain_cursor_node *node;\n\tint print_ip = print_opts & EVSEL__PRINT_IP;\n\tint print_sym = print_opts & EVSEL__PRINT_SYM;\n\tint print_dso = print_opts & EVSEL__PRINT_DSO;\n\tint print_dsoff = print_opts & EVSEL__PRINT_DSOFF;\n\tint print_symoffset = print_opts & EVSEL__PRINT_SYMOFFSET;\n\tint print_oneline = print_opts & EVSEL__PRINT_ONELINE;\n\tint print_srcline = print_opts & EVSEL__PRINT_SRCLINE;\n\tint print_unknown_as_addr = print_opts & EVSEL__PRINT_UNKNOWN_AS_ADDR;\n\tint print_arrow = print_opts & EVSEL__PRINT_CALLCHAIN_ARROW;\n\tint print_skip_ignored = print_opts & EVSEL__PRINT_SKIP_IGNORED;\n\tchar s = print_oneline ? ' ' : '\\t';\n\tbool first = true;\n\n\tif (cursor == NULL)\n\t\treturn fprintf(fp, \"<not enough memory for the callchain cursor>%s\", print_oneline ? \"\" : \"\\n\");\n\n\tif (sample->callchain) {\n\t\tcallchain_cursor_commit(cursor);\n\n\t\twhile (1) {\n\t\t\tstruct symbol *sym;\n\t\t\tstruct map *map;\n\t\t\tu64 addr = 0;\n\n\t\t\tnode = callchain_cursor_current(cursor);\n\t\t\tif (!node)\n\t\t\t\tbreak;\n\n\t\t\tsym = node->ms.sym;\n\t\t\tmap = node->ms.map;\n\n\t\t\tif (sym && sym->ignore && print_skip_ignored)\n\t\t\t\tgoto next;\n\n\t\t\tprinted += fprintf(fp, \"%-*.*s\", left_alignment, left_alignment, \" \");\n\n\t\t\tif (print_arrow && !first)\n\t\t\t\tprinted += fprintf(fp, \" <-\");\n\n\t\t\tif (map)\n\t\t\t\taddr = map__map_ip(map, node->ip);\n\n\t\t\tif (print_ip)\n\t\t\t\tprinted += fprintf(fp, \"%c%16\" PRIx64, s, node->ip);\n\n\t\t\tif (print_sym) {\n\t\t\t\tstruct addr_location node_al;\n\n\t\t\t\taddr_location__init(&node_al);\n\t\t\t\tprinted += fprintf(fp, \" \");\n\t\t\t\tnode_al.addr = addr;\n\t\t\t\tnode_al.map  = map__get(map);\n\n\t\t\t\tif (print_symoffset) {\n\t\t\t\t\tprinted += __symbol__fprintf_symname_offs(sym, &node_al,\n\t\t\t\t\t\t\t\t\t\t  print_unknown_as_addr,\n\t\t\t\t\t\t\t\t\t\t  true, fp);\n\t\t\t\t} else {\n\t\t\t\t\tprinted += __symbol__fprintf_symname(sym, &node_al,\n\t\t\t\t\t\t\t\t\t     print_unknown_as_addr, fp);\n\t\t\t\t}\n\t\t\t\taddr_location__exit(&node_al);\n\t\t\t}\n\n\t\t\tif (print_dso && (!sym || !sym->inlined))\n\t\t\t\tprinted += map__fprintf_dsoname_dsoff(map, print_dsoff, addr, fp);\n\n\t\t\tif (print_srcline)\n\t\t\t\tprinted += map__fprintf_srcline(map, addr, \"\\n  \", fp);\n\n\t\t\tif (sym && sym->inlined)\n\t\t\t\tprinted += fprintf(fp, \" (inlined)\");\n\n\t\t\tif (!print_oneline)\n\t\t\t\tprinted += fprintf(fp, \"\\n\");\n\n\t\t\t \n\t\t\tif (bt_stop_list && sym &&\n\t\t\t    strlist__has_entry(bt_stop_list, sym->name)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfirst = false;\nnext:\n\t\t\tcallchain_cursor_advance(cursor);\n\t\t}\n\t}\n\n\treturn printed;\n}\n\nint sample__fprintf_sym(struct perf_sample *sample, struct addr_location *al,\n\t\t\tint left_alignment, unsigned int print_opts,\n\t\t\tstruct callchain_cursor *cursor, struct strlist *bt_stop_list, FILE *fp)\n{\n\tint printed = 0;\n\tint print_ip = print_opts & EVSEL__PRINT_IP;\n\tint print_sym = print_opts & EVSEL__PRINT_SYM;\n\tint print_dso = print_opts & EVSEL__PRINT_DSO;\n\tint print_dsoff = print_opts & EVSEL__PRINT_DSOFF;\n\tint print_symoffset = print_opts & EVSEL__PRINT_SYMOFFSET;\n\tint print_srcline = print_opts & EVSEL__PRINT_SRCLINE;\n\tint print_unknown_as_addr = print_opts & EVSEL__PRINT_UNKNOWN_AS_ADDR;\n\n\tif (cursor != NULL) {\n\t\tprinted += sample__fprintf_callchain(sample, left_alignment, print_opts,\n\t\t\t\t\t\t     cursor, bt_stop_list, fp);\n\t} else {\n\t\tprinted += fprintf(fp, \"%-*.*s\", left_alignment, left_alignment, \" \");\n\n\t\tif (print_ip)\n\t\t\tprinted += fprintf(fp, \"%16\" PRIx64, sample->ip);\n\n\t\tif (print_sym) {\n\t\t\tprinted += fprintf(fp, \" \");\n\t\t\tif (print_symoffset) {\n\t\t\t\tprinted += __symbol__fprintf_symname_offs(al->sym, al,\n\t\t\t\t\t\t\t\t\t  print_unknown_as_addr,\n\t\t\t\t\t\t\t\t\t  true, fp);\n\t\t\t} else {\n\t\t\t\tprinted += __symbol__fprintf_symname(al->sym, al,\n\t\t\t\t\t\t\t\t     print_unknown_as_addr, fp);\n\t\t\t}\n\t\t}\n\n\t\tif (print_dso)\n\t\t\tprinted += map__fprintf_dsoname_dsoff(al->map, print_dsoff, al->addr, fp);\n\n\t\tif (print_srcline)\n\t\t\tprinted += map__fprintf_srcline(al->map, al->addr, \"\\n  \", fp);\n\t}\n\n\treturn printed;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}