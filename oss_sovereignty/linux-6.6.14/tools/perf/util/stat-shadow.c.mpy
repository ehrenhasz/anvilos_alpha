{
  "module_name": "stat-shadow.c",
  "hash_id": "391453e92918988a07ee97060abab0627d0228873eca1d73f066991e7662bd2e",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/stat-shadow.c",
  "human_readable_source": "\n#include <math.h>\n#include <stdio.h>\n#include \"evsel.h\"\n#include \"stat.h\"\n#include \"color.h\"\n#include \"debug.h\"\n#include \"pmu.h\"\n#include \"rblist.h\"\n#include \"evlist.h\"\n#include \"expr.h\"\n#include \"metricgroup.h\"\n#include \"cgroup.h\"\n#include \"units.h\"\n#include <linux/zalloc.h>\n#include \"iostat.h\"\n#include \"util/hashmap.h\"\n\nstruct stats walltime_nsecs_stats;\nstruct rusage_stats ru_stats;\n\nenum {\n\tCTX_BIT_USER\t= 1 << 0,\n\tCTX_BIT_KERNEL\t= 1 << 1,\n\tCTX_BIT_HV\t= 1 << 2,\n\tCTX_BIT_HOST\t= 1 << 3,\n\tCTX_BIT_IDLE\t= 1 << 4,\n\tCTX_BIT_MAX\t= 1 << 5,\n};\n\nenum stat_type {\n\tSTAT_NONE = 0,\n\tSTAT_NSECS,\n\tSTAT_CYCLES,\n\tSTAT_INSTRUCTIONS,\n\tSTAT_STALLED_CYCLES_FRONT,\n\tSTAT_STALLED_CYCLES_BACK,\n\tSTAT_BRANCHES,\n\tSTAT_BRANCH_MISS,\n\tSTAT_CACHE_REFS,\n\tSTAT_CACHE_MISSES,\n\tSTAT_L1_DCACHE,\n\tSTAT_L1_ICACHE,\n\tSTAT_LL_CACHE,\n\tSTAT_ITLB_CACHE,\n\tSTAT_DTLB_CACHE,\n\tSTAT_L1D_MISS,\n\tSTAT_L1I_MISS,\n\tSTAT_LL_MISS,\n\tSTAT_DTLB_MISS,\n\tSTAT_ITLB_MISS,\n\tSTAT_MAX\n};\n\nstatic int evsel_context(const struct evsel *evsel)\n{\n\tint ctx = 0;\n\n\tif (evsel->core.attr.exclude_kernel)\n\t\tctx |= CTX_BIT_KERNEL;\n\tif (evsel->core.attr.exclude_user)\n\t\tctx |= CTX_BIT_USER;\n\tif (evsel->core.attr.exclude_hv)\n\t\tctx |= CTX_BIT_HV;\n\tif (evsel->core.attr.exclude_host)\n\t\tctx |= CTX_BIT_HOST;\n\tif (evsel->core.attr.exclude_idle)\n\t\tctx |= CTX_BIT_IDLE;\n\n\treturn ctx;\n}\n\nvoid perf_stat__reset_shadow_stats(void)\n{\n\tmemset(&walltime_nsecs_stats, 0, sizeof(walltime_nsecs_stats));\n\tmemset(&ru_stats, 0, sizeof(ru_stats));\n}\n\nstatic enum stat_type evsel__stat_type(const struct evsel *evsel)\n{\n\t \n\tu64 PERF_COUNT_hw_cache_l1d_miss = PERF_COUNT_HW_CACHE_L1D |\n\t\t((PERF_COUNT_HW_CACHE_OP_READ) << 8) |\n\t\t((PERF_COUNT_HW_CACHE_RESULT_MISS) << 16);\n\tu64 PERF_COUNT_hw_cache_l1i_miss = PERF_COUNT_HW_CACHE_L1I |\n\t\t((PERF_COUNT_HW_CACHE_OP_READ) << 8) |\n\t\t((PERF_COUNT_HW_CACHE_RESULT_MISS) << 16);\n\tu64 PERF_COUNT_hw_cache_ll_miss = PERF_COUNT_HW_CACHE_LL |\n\t\t((PERF_COUNT_HW_CACHE_OP_READ) << 8) |\n\t\t((PERF_COUNT_HW_CACHE_RESULT_MISS) << 16);\n\tu64 PERF_COUNT_hw_cache_dtlb_miss = PERF_COUNT_HW_CACHE_DTLB |\n\t\t((PERF_COUNT_HW_CACHE_OP_READ) << 8) |\n\t\t((PERF_COUNT_HW_CACHE_RESULT_MISS) << 16);\n\tu64 PERF_COUNT_hw_cache_itlb_miss = PERF_COUNT_HW_CACHE_ITLB |\n\t\t((PERF_COUNT_HW_CACHE_OP_READ) << 8) |\n\t\t((PERF_COUNT_HW_CACHE_RESULT_MISS) << 16);\n\n\tif (evsel__is_clock(evsel))\n\t\treturn STAT_NSECS;\n\telse if (evsel__match(evsel, HARDWARE, HW_CPU_CYCLES))\n\t\treturn STAT_CYCLES;\n\telse if (evsel__match(evsel, HARDWARE, HW_INSTRUCTIONS))\n\t\treturn STAT_INSTRUCTIONS;\n\telse if (evsel__match(evsel, HARDWARE, HW_STALLED_CYCLES_FRONTEND))\n\t\treturn STAT_STALLED_CYCLES_FRONT;\n\telse if (evsel__match(evsel, HARDWARE, HW_STALLED_CYCLES_BACKEND))\n\t\treturn STAT_STALLED_CYCLES_BACK;\n\telse if (evsel__match(evsel, HARDWARE, HW_BRANCH_INSTRUCTIONS))\n\t\treturn STAT_BRANCHES;\n\telse if (evsel__match(evsel, HARDWARE, HW_BRANCH_MISSES))\n\t\treturn STAT_BRANCH_MISS;\n\telse if (evsel__match(evsel, HARDWARE, HW_CACHE_REFERENCES))\n\t\treturn STAT_CACHE_REFS;\n\telse if (evsel__match(evsel, HARDWARE, HW_CACHE_MISSES))\n\t\treturn STAT_CACHE_MISSES;\n\telse if (evsel__match(evsel, HW_CACHE, HW_CACHE_L1D))\n\t\treturn STAT_L1_DCACHE;\n\telse if (evsel__match(evsel, HW_CACHE, HW_CACHE_L1I))\n\t\treturn STAT_L1_ICACHE;\n\telse if (evsel__match(evsel, HW_CACHE, HW_CACHE_LL))\n\t\treturn STAT_LL_CACHE;\n\telse if (evsel__match(evsel, HW_CACHE, HW_CACHE_DTLB))\n\t\treturn STAT_DTLB_CACHE;\n\telse if (evsel__match(evsel, HW_CACHE, HW_CACHE_ITLB))\n\t\treturn STAT_ITLB_CACHE;\n\telse if (evsel__match(evsel, HW_CACHE, hw_cache_l1d_miss))\n\t\treturn STAT_L1D_MISS;\n\telse if (evsel__match(evsel, HW_CACHE, hw_cache_l1i_miss))\n\t\treturn STAT_L1I_MISS;\n\telse if (evsel__match(evsel, HW_CACHE, hw_cache_ll_miss))\n\t\treturn STAT_LL_MISS;\n\telse if (evsel__match(evsel, HW_CACHE, hw_cache_dtlb_miss))\n\t\treturn STAT_DTLB_MISS;\n\telse if (evsel__match(evsel, HW_CACHE, hw_cache_itlb_miss))\n\t\treturn STAT_ITLB_MISS;\n\treturn STAT_NONE;\n}\n\nstatic const char *get_ratio_color(const double ratios[3], double val)\n{\n\tconst char *color = PERF_COLOR_NORMAL;\n\n\tif (val > ratios[0])\n\t\tcolor = PERF_COLOR_RED;\n\telse if (val > ratios[1])\n\t\tcolor = PERF_COLOR_MAGENTA;\n\telse if (val > ratios[2])\n\t\tcolor = PERF_COLOR_YELLOW;\n\n\treturn color;\n}\n\nstatic double find_stat(const struct evsel *evsel, int aggr_idx, enum stat_type type)\n{\n\tconst struct evsel *cur;\n\tint evsel_ctx = evsel_context(evsel);\n\n\tevlist__for_each_entry(evsel->evlist, cur) {\n\t\tstruct perf_stat_aggr *aggr;\n\n\t\t \n\t\tif (evsel == cur)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (evsel->core.leader->nr_members > 1 &&\n\t\t    evsel->core.leader != cur->core.leader)\n\t\t\tcontinue;\n\t\t \n\t\tif (evsel_ctx != evsel_context(cur))\n\t\t\tcontinue;\n\t\t \n\t\tif (evsel->cgrp != cur->cgrp)\n\t\t\tcontinue;\n\t\t \n\t\tif (type != evsel__stat_type(cur))\n\t\t\tcontinue;\n\n\t\taggr = &cur->stats->aggr[aggr_idx];\n\t\tif (type == STAT_NSECS)\n\t\t\treturn aggr->counts.val;\n\t\treturn aggr->counts.val * cur->scale;\n\t}\n\treturn 0.0;\n}\n\nstatic void print_ratio(struct perf_stat_config *config,\n\t\t\tconst struct evsel *evsel, int aggr_idx,\n\t\t\tdouble numerator, struct perf_stat_output_ctx *out,\n\t\t\tenum stat_type denominator_type,\n\t\t\tconst double color_ratios[3], const char *unit)\n{\n\tdouble denominator = find_stat(evsel, aggr_idx, denominator_type);\n\n\tif (numerator && denominator) {\n\t\tdouble ratio = numerator / denominator * 100.0;\n\t\tconst char *color = get_ratio_color(color_ratios, ratio);\n\n\t\tout->print_metric(config, out->ctx, color, \"%7.2f%%\", unit, ratio);\n\t} else\n\t\tout->print_metric(config, out->ctx, NULL, NULL, unit, 0);\n}\n\nstatic void print_stalled_cycles_front(struct perf_stat_config *config,\n\t\t\t\tconst struct evsel *evsel,\n\t\t\t\tint aggr_idx, double stalled,\n\t\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tstatic const double color_ratios[3] = {50.0, 30.0, 10.0};\n\n\tprint_ratio(config, evsel, aggr_idx, stalled, out, STAT_CYCLES, color_ratios,\n\t\t    \"frontend cycles idle\");\n}\n\nstatic void print_stalled_cycles_back(struct perf_stat_config *config,\n\t\t\t\tconst struct evsel *evsel,\n\t\t\t\tint aggr_idx, double stalled,\n\t\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tstatic const double color_ratios[3] = {75.0, 50.0, 20.0};\n\n\tprint_ratio(config, evsel, aggr_idx, stalled, out, STAT_CYCLES, color_ratios,\n\t\t    \"backend cycles idle\");\n}\n\nstatic void print_branch_miss(struct perf_stat_config *config,\n\t\t\tconst struct evsel *evsel,\n\t\t\tint aggr_idx, double misses,\n\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tstatic const double color_ratios[3] = {20.0, 10.0, 5.0};\n\n\tprint_ratio(config, evsel, aggr_idx, misses, out, STAT_BRANCHES, color_ratios,\n\t\t    \"of all branches\");\n}\n\nstatic void print_l1d_miss(struct perf_stat_config *config,\n\t\t\tconst struct evsel *evsel,\n\t\t\tint aggr_idx, double misses,\n\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tstatic const double color_ratios[3] = {20.0, 10.0, 5.0};\n\n\tprint_ratio(config, evsel, aggr_idx, misses, out, STAT_L1_DCACHE, color_ratios,\n\t\t    \"of all L1-dcache accesses\");\n}\n\nstatic void print_l1i_miss(struct perf_stat_config *config,\n\t\t\tconst struct evsel *evsel,\n\t\t\tint aggr_idx, double misses,\n\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tstatic const double color_ratios[3] = {20.0, 10.0, 5.0};\n\n\tprint_ratio(config, evsel, aggr_idx, misses, out, STAT_L1_ICACHE, color_ratios,\n\t\t    \"of all L1-icache accesses\");\n}\n\nstatic void print_ll_miss(struct perf_stat_config *config,\n\t\t\tconst struct evsel *evsel,\n\t\t\tint aggr_idx, double misses,\n\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tstatic const double color_ratios[3] = {20.0, 10.0, 5.0};\n\n\tprint_ratio(config, evsel, aggr_idx, misses, out, STAT_LL_CACHE, color_ratios,\n\t\t    \"of all LL-cache accesses\");\n}\n\nstatic void print_dtlb_miss(struct perf_stat_config *config,\n\t\t\tconst struct evsel *evsel,\n\t\t\tint aggr_idx, double misses,\n\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tstatic const double color_ratios[3] = {20.0, 10.0, 5.0};\n\n\tprint_ratio(config, evsel, aggr_idx, misses, out, STAT_DTLB_CACHE, color_ratios,\n\t\t    \"of all dTLB cache accesses\");\n}\n\nstatic void print_itlb_miss(struct perf_stat_config *config,\n\t\t\tconst struct evsel *evsel,\n\t\t\tint aggr_idx, double misses,\n\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tstatic const double color_ratios[3] = {20.0, 10.0, 5.0};\n\n\tprint_ratio(config, evsel, aggr_idx, misses, out, STAT_ITLB_CACHE, color_ratios,\n\t\t    \"of all iTLB cache accesses\");\n}\n\nstatic void print_cache_miss(struct perf_stat_config *config,\n\t\t\tconst struct evsel *evsel,\n\t\t\tint aggr_idx, double misses,\n\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tstatic const double color_ratios[3] = {20.0, 10.0, 5.0};\n\n\tprint_ratio(config, evsel, aggr_idx, misses, out, STAT_CACHE_REFS, color_ratios,\n\t\t    \"of all cache refs\");\n}\n\nstatic void print_instructions(struct perf_stat_config *config,\n\t\t\tconst struct evsel *evsel,\n\t\t\tint aggr_idx, double instructions,\n\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tprint_metric_t print_metric = out->print_metric;\n\tvoid *ctxp = out->ctx;\n\tdouble cycles = find_stat(evsel, aggr_idx, STAT_CYCLES);\n\tdouble max_stalled = max(find_stat(evsel, aggr_idx, STAT_STALLED_CYCLES_FRONT),\n\t\t\t\tfind_stat(evsel, aggr_idx, STAT_STALLED_CYCLES_BACK));\n\n\tif (cycles) {\n\t\tprint_metric(config, ctxp, NULL, \"%7.2f \", \"insn per cycle\",\n\t\t\tinstructions / cycles);\n\t} else\n\t\tprint_metric(config, ctxp, NULL, NULL, \"insn per cycle\", 0);\n\n\tif (max_stalled && instructions) {\n\t\tout->new_line(config, ctxp);\n\t\tprint_metric(config, ctxp, NULL, \"%7.2f \", \"stalled cycles per insn\",\n\t\t\tmax_stalled / instructions);\n\t}\n}\n\nstatic void print_cycles(struct perf_stat_config *config,\n\t\t\tconst struct evsel *evsel,\n\t\t\tint aggr_idx, double cycles,\n\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tdouble nsecs = find_stat(evsel, aggr_idx, STAT_NSECS);\n\n\tif (cycles && nsecs) {\n\t\tdouble ratio = cycles / nsecs;\n\n\t\tout->print_metric(config, out->ctx, NULL, \"%8.3f\", \"GHz\", ratio);\n\t} else\n\t\tout->print_metric(config, out->ctx, NULL, NULL, \"GHz\", 0);\n}\n\nstatic void print_nsecs(struct perf_stat_config *config,\n\t\t\tconst struct evsel *evsel,\n\t\t\tint aggr_idx __maybe_unused, double nsecs,\n\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tprint_metric_t print_metric = out->print_metric;\n\tvoid *ctxp = out->ctx;\n\tdouble wall_time = avg_stats(&walltime_nsecs_stats);\n\n\tif (wall_time) {\n\t\tprint_metric(config, ctxp, NULL, \"%8.3f\", \"CPUs utilized\",\n\t\t\tnsecs / (wall_time * evsel->scale));\n\t} else\n\t\tprint_metric(config, ctxp, NULL, NULL, \"CPUs utilized\", 0);\n}\n\nstatic int prepare_metric(struct evsel **metric_events,\n\t\t\t  struct metric_ref *metric_refs,\n\t\t\t  struct expr_parse_ctx *pctx,\n\t\t\t  int aggr_idx)\n{\n\tint i;\n\n\tfor (i = 0; metric_events[i]; i++) {\n\t\tchar *n;\n\t\tdouble val;\n\t\tint source_count = 0;\n\n\t\tif (evsel__is_tool(metric_events[i])) {\n\t\t\tstruct stats *stats;\n\t\t\tdouble scale;\n\n\t\t\tswitch (metric_events[i]->tool_event) {\n\t\t\tcase PERF_TOOL_DURATION_TIME:\n\t\t\t\tstats = &walltime_nsecs_stats;\n\t\t\t\tscale = 1e-9;\n\t\t\t\tbreak;\n\t\t\tcase PERF_TOOL_USER_TIME:\n\t\t\t\tstats = &ru_stats.ru_utime_usec_stat;\n\t\t\t\tscale = 1e-6;\n\t\t\t\tbreak;\n\t\t\tcase PERF_TOOL_SYSTEM_TIME:\n\t\t\t\tstats = &ru_stats.ru_stime_usec_stat;\n\t\t\t\tscale = 1e-6;\n\t\t\t\tbreak;\n\t\t\tcase PERF_TOOL_NONE:\n\t\t\t\tpr_err(\"Invalid tool event 'none'\");\n\t\t\t\tabort();\n\t\t\tcase PERF_TOOL_MAX:\n\t\t\t\tpr_err(\"Invalid tool event 'max'\");\n\t\t\t\tabort();\n\t\t\tdefault:\n\t\t\t\tpr_err(\"Unknown tool event '%s'\", evsel__name(metric_events[i]));\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tval = avg_stats(stats) * scale;\n\t\t\tsource_count = 1;\n\t\t} else {\n\t\t\tstruct perf_stat_evsel *ps = metric_events[i]->stats;\n\t\t\tstruct perf_stat_aggr *aggr = &ps->aggr[aggr_idx];\n\n\t\t\tif (!aggr)\n\t\t\t\tbreak;\n\n                        if (!metric_events[i]->supported) {\n\t\t\t\t \n\t\t\t\tval = NAN;\n\t\t\t\tsource_count = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tval = aggr->counts.val * (1.0 / metric_events[i]->scale);\n\t\t\t\tsource_count = evsel__source_count(metric_events[i]);\n\t\t\t}\n\t\t}\n\t\tn = strdup(evsel__metric_id(metric_events[i]));\n\t\tif (!n)\n\t\t\treturn -ENOMEM;\n\n\t\texpr__add_id_val_source_count(pctx, n, val, source_count);\n\t}\n\n\tfor (int j = 0; metric_refs && metric_refs[j].metric_name; j++) {\n\t\tint ret = expr__add_ref(pctx, &metric_refs[j]);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn i;\n}\n\nstatic void generic_metric(struct perf_stat_config *config,\n\t\t\t   const char *metric_expr,\n\t\t\t   const char *metric_threshold,\n\t\t\t   struct evsel **metric_events,\n\t\t\t   struct metric_ref *metric_refs,\n\t\t\t   char *name,\n\t\t\t   const char *metric_name,\n\t\t\t   const char *metric_unit,\n\t\t\t   int runtime,\n\t\t\t   int aggr_idx,\n\t\t\t   struct perf_stat_output_ctx *out)\n{\n\tprint_metric_t print_metric = out->print_metric;\n\tstruct expr_parse_ctx *pctx;\n\tdouble ratio, scale, threshold;\n\tint i;\n\tvoid *ctxp = out->ctx;\n\tconst char *color = NULL;\n\n\tpctx = expr__ctx_new();\n\tif (!pctx)\n\t\treturn;\n\n\tif (config->user_requested_cpu_list)\n\t\tpctx->sctx.user_requested_cpu_list = strdup(config->user_requested_cpu_list);\n\tpctx->sctx.runtime = runtime;\n\tpctx->sctx.system_wide = config->system_wide;\n\ti = prepare_metric(metric_events, metric_refs, pctx, aggr_idx);\n\tif (i < 0) {\n\t\texpr__ctx_free(pctx);\n\t\treturn;\n\t}\n\tif (!metric_events[i]) {\n\t\tif (expr__parse(&ratio, pctx, metric_expr) == 0) {\n\t\t\tchar *unit;\n\t\t\tchar metric_bf[64];\n\n\t\t\tif (metric_threshold &&\n\t\t\t    expr__parse(&threshold, pctx, metric_threshold) == 0 &&\n\t\t\t    !isnan(threshold)) {\n\t\t\t\tcolor = fpclassify(threshold) == FP_ZERO\n\t\t\t\t\t? PERF_COLOR_GREEN : PERF_COLOR_RED;\n\t\t\t}\n\n\t\t\tif (metric_unit && metric_name) {\n\t\t\t\tif (perf_pmu__convert_scale(metric_unit,\n\t\t\t\t\t&unit, &scale) >= 0) {\n\t\t\t\t\tratio *= scale;\n\t\t\t\t}\n\t\t\t\tif (strstr(metric_expr, \"?\"))\n\t\t\t\t\tscnprintf(metric_bf, sizeof(metric_bf),\n\t\t\t\t\t  \"%s  %s_%d\", unit, metric_name, runtime);\n\t\t\t\telse\n\t\t\t\t\tscnprintf(metric_bf, sizeof(metric_bf),\n\t\t\t\t\t  \"%s  %s\", unit, metric_name);\n\n\t\t\t\tprint_metric(config, ctxp, color, \"%8.1f\",\n\t\t\t\t\t     metric_bf, ratio);\n\t\t\t} else {\n\t\t\t\tprint_metric(config, ctxp, color, \"%8.2f\",\n\t\t\t\t\tmetric_name ?\n\t\t\t\t\tmetric_name :\n\t\t\t\t\tout->force_header ?  name : \"\",\n\t\t\t\t\tratio);\n\t\t\t}\n\t\t} else {\n\t\t\tprint_metric(config, ctxp, color,  NULL,\n\t\t\t\t     out->force_header ?\n\t\t\t\t     (metric_name ? metric_name : name) : \"\", 0);\n\t\t}\n\t} else {\n\t\tprint_metric(config, ctxp, color,  NULL,\n\t\t\t     out->force_header ?\n\t\t\t     (metric_name ? metric_name : name) : \"\", 0);\n\t}\n\n\texpr__ctx_free(pctx);\n}\n\ndouble test_generic_metric(struct metric_expr *mexp, int aggr_idx)\n{\n\tstruct expr_parse_ctx *pctx;\n\tdouble ratio = 0.0;\n\n\tpctx = expr__ctx_new();\n\tif (!pctx)\n\t\treturn NAN;\n\n\tif (prepare_metric(mexp->metric_events, mexp->metric_refs, pctx, aggr_idx) < 0)\n\t\tgoto out;\n\n\tif (expr__parse(&ratio, pctx, mexp->metric_expr))\n\t\tratio = 0.0;\n\nout:\n\texpr__ctx_free(pctx);\n\treturn ratio;\n}\n\nstatic void perf_stat__print_metricgroup_header(struct perf_stat_config *config,\n\t\t\t\t\t\tstruct evsel *evsel,\n\t\t\t\t\t\tvoid *ctxp,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tstruct perf_stat_output_ctx *out)\n{\n\tbool need_full_name = perf_pmus__num_core_pmus() > 1;\n\tstatic const char *last_name;\n\tstatic const char *last_pmu;\n\tchar full_name[64];\n\n\t \n\tif (last_name && !strcmp(last_name, name)) {\n\t\tif (!need_full_name || !strcmp(last_pmu, evsel->pmu_name)) {\n\t\t\tout->print_metricgroup_header(config, ctxp, NULL);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (need_full_name)\n\t\tscnprintf(full_name, sizeof(full_name), \"%s (%s)\", name, evsel->pmu_name);\n\telse\n\t\tscnprintf(full_name, sizeof(full_name), \"%s\", name);\n\n\tout->print_metricgroup_header(config, ctxp, full_name);\n\n\tlast_name = name;\n\tlast_pmu = evsel->pmu_name;\n}\n\n \nvoid *perf_stat__print_shadow_stats_metricgroup(struct perf_stat_config *config,\n\t\t\t\t\t\tstruct evsel *evsel,\n\t\t\t\t\t\tint aggr_idx,\n\t\t\t\t\t\tint *num,\n\t\t\t\t\t\tvoid *from,\n\t\t\t\t\t\tstruct perf_stat_output_ctx *out,\n\t\t\t\t\t\tstruct rblist *metric_events)\n{\n\tstruct metric_event *me;\n\tstruct metric_expr *mexp = from;\n\tvoid *ctxp = out->ctx;\n\tbool header_printed = false;\n\tconst char *name = NULL;\n\n\tme = metricgroup__lookup(metric_events, evsel, false);\n\tif (me == NULL)\n\t\treturn NULL;\n\n\tif (!mexp)\n\t\tmexp = list_first_entry(&me->head, typeof(*mexp), nd);\n\n\tlist_for_each_entry_from(mexp, &me->head, nd) {\n\t\t \n\t\tif (!config->metric_only && me->is_default) {\n\t\t\tif (!name)\n\t\t\t\tname = mexp->default_metricgroup_name;\n\t\t\t \n\t\t\tif (strcmp(name, mexp->default_metricgroup_name))\n\t\t\t\treturn (void *)mexp;\n\t\t\t \n\t\t\tif (!header_printed) {\n\t\t\t\theader_printed = true;\n\t\t\t\tperf_stat__print_metricgroup_header(config, evsel, ctxp,\n\t\t\t\t\t\t\t\t    name, out);\n\t\t\t}\n\t\t}\n\n\t\tif ((*num)++ > 0)\n\t\t\tout->new_line(config, ctxp);\n\t\tgeneric_metric(config, mexp->metric_expr, mexp->metric_threshold,\n\t\t\t       mexp->metric_events, mexp->metric_refs, evsel->name,\n\t\t\t       mexp->metric_name, mexp->metric_unit, mexp->runtime,\n\t\t\t       aggr_idx, out);\n\t}\n\n\treturn NULL;\n}\n\nvoid perf_stat__print_shadow_stats(struct perf_stat_config *config,\n\t\t\t\t   struct evsel *evsel,\n\t\t\t\t   double avg, int aggr_idx,\n\t\t\t\t   struct perf_stat_output_ctx *out,\n\t\t\t\t   struct rblist *metric_events)\n{\n\ttypedef void (*stat_print_function_t)(struct perf_stat_config *config,\n\t\t\t\t\tconst struct evsel *evsel,\n\t\t\t\t\tint aggr_idx, double misses,\n\t\t\t\t\tstruct perf_stat_output_ctx *out);\n\tstatic const stat_print_function_t stat_print_function[STAT_MAX] = {\n\t\t[STAT_INSTRUCTIONS] = print_instructions,\n\t\t[STAT_BRANCH_MISS] = print_branch_miss,\n\t\t[STAT_L1D_MISS] = print_l1d_miss,\n\t\t[STAT_L1I_MISS] = print_l1i_miss,\n\t\t[STAT_DTLB_MISS] = print_dtlb_miss,\n\t\t[STAT_ITLB_MISS] = print_itlb_miss,\n\t\t[STAT_LL_MISS] = print_ll_miss,\n\t\t[STAT_CACHE_MISSES] = print_cache_miss,\n\t\t[STAT_STALLED_CYCLES_FRONT] = print_stalled_cycles_front,\n\t\t[STAT_STALLED_CYCLES_BACK] = print_stalled_cycles_back,\n\t\t[STAT_CYCLES] = print_cycles,\n\t\t[STAT_NSECS] = print_nsecs,\n\t};\n\tprint_metric_t print_metric = out->print_metric;\n\tvoid *ctxp = out->ctx;\n\tint num = 1;\n\n\tif (config->iostat_run) {\n\t\tiostat_print_metric(config, evsel, out);\n\t} else {\n\t\tstat_print_function_t fn = stat_print_function[evsel__stat_type(evsel)];\n\n\t\tif (fn)\n\t\t\tfn(config, evsel, aggr_idx, avg, out);\n\t\telse {\n\t\t\tdouble nsecs =\tfind_stat(evsel, aggr_idx, STAT_NSECS);\n\n\t\t\tif (nsecs) {\n\t\t\t\tchar unit = ' ';\n\t\t\t\tchar unit_buf[10] = \"/sec\";\n\t\t\t\tdouble ratio = convert_unit_double(1000000000.0 * avg / nsecs,\n\t\t\t\t\t\t\t\t   &unit);\n\n\t\t\t\tif (unit != ' ')\n\t\t\t\t\tsnprintf(unit_buf, sizeof(unit_buf), \"%c/sec\", unit);\n\t\t\t\tprint_metric(config, ctxp, NULL, \"%8.3f\", unit_buf, ratio);\n\t\t\t} else\n\t\t\t\tnum = 0;\n\t\t}\n\t}\n\n\tperf_stat__print_shadow_stats_metricgroup(config, evsel, aggr_idx,\n\t\t\t\t\t\t  &num, NULL, out, metric_events);\n\n\tif (num == 0)\n\t\tprint_metric(config, ctxp, NULL, NULL, NULL, 0);\n}\n\n \nbool perf_stat__skip_metric_event(struct evsel *evsel,\n\t\t\t\t  struct rblist *metric_events,\n\t\t\t\t  u64 ena, u64 run)\n{\n\tif (!evsel->default_metricgroup)\n\t\treturn false;\n\n\tif (!ena || !run)\n\t\treturn true;\n\n\treturn !metricgroup__lookup(metric_events, evsel, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}