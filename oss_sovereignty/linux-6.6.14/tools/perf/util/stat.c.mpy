{
  "module_name": "stat.c",
  "hash_id": "5b17728205f4ec4caa70ab354144780aafd04b3002d31d3d804850b12d0e528b",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/stat.c",
  "human_readable_source": "\n#include <errno.h>\n#include <linux/err.h>\n#include <inttypes.h>\n#include <math.h>\n#include <string.h>\n#include \"counts.h\"\n#include \"cpumap.h\"\n#include \"debug.h\"\n#include \"header.h\"\n#include \"stat.h\"\n#include \"session.h\"\n#include \"target.h\"\n#include \"evlist.h\"\n#include \"evsel.h\"\n#include \"thread_map.h\"\n#include \"util/hashmap.h\"\n#include <linux/zalloc.h>\n\nvoid update_stats(struct stats *stats, u64 val)\n{\n\tdouble delta;\n\n\tstats->n++;\n\tdelta = val - stats->mean;\n\tstats->mean += delta / stats->n;\n\tstats->M2 += delta*(val - stats->mean);\n\n\tif (val > stats->max)\n\t\tstats->max = val;\n\n\tif (val < stats->min)\n\t\tstats->min = val;\n}\n\ndouble avg_stats(struct stats *stats)\n{\n\treturn stats->mean;\n}\n\n \ndouble stddev_stats(struct stats *stats)\n{\n\tdouble variance, variance_mean;\n\n\tif (stats->n < 2)\n\t\treturn 0.0;\n\n\tvariance = stats->M2 / (stats->n - 1);\n\tvariance_mean = variance / stats->n;\n\n\treturn sqrt(variance_mean);\n}\n\ndouble rel_stddev_stats(double stddev, double avg)\n{\n\tdouble pct = 0.0;\n\n\tif (avg)\n\t\tpct = 100.0 * stddev/avg;\n\n\treturn pct;\n}\n\nstatic void evsel__reset_aggr_stats(struct evsel *evsel)\n{\n\tstruct perf_stat_evsel *ps = evsel->stats;\n\tstruct perf_stat_aggr *aggr = ps->aggr;\n\n\tif (aggr)\n\t\tmemset(aggr, 0, sizeof(*aggr) * ps->nr_aggr);\n}\n\nstatic void evsel__reset_stat_priv(struct evsel *evsel)\n{\n\tstruct perf_stat_evsel *ps = evsel->stats;\n\n\tinit_stats(&ps->res_stats);\n\tevsel__reset_aggr_stats(evsel);\n}\n\nstatic int evsel__alloc_aggr_stats(struct evsel *evsel, int nr_aggr)\n{\n\tstruct perf_stat_evsel *ps = evsel->stats;\n\n\tif (ps == NULL)\n\t\treturn 0;\n\n\tps->nr_aggr = nr_aggr;\n\tps->aggr = calloc(nr_aggr, sizeof(*ps->aggr));\n\tif (ps->aggr == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint evlist__alloc_aggr_stats(struct evlist *evlist, int nr_aggr)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel__alloc_aggr_stats(evsel, nr_aggr) < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int evsel__alloc_stat_priv(struct evsel *evsel, int nr_aggr)\n{\n\tstruct perf_stat_evsel *ps;\n\n\tps = zalloc(sizeof(*ps));\n\tif (ps == NULL)\n\t\treturn -ENOMEM;\n\n\tevsel->stats = ps;\n\n\tif (nr_aggr && evsel__alloc_aggr_stats(evsel, nr_aggr) < 0) {\n\t\tevsel->stats = NULL;\n\t\tfree(ps);\n\t\treturn -ENOMEM;\n\t}\n\n\tevsel__reset_stat_priv(evsel);\n\treturn 0;\n}\n\nstatic void evsel__free_stat_priv(struct evsel *evsel)\n{\n\tstruct perf_stat_evsel *ps = evsel->stats;\n\n\tif (ps) {\n\t\tzfree(&ps->aggr);\n\t\tzfree(&ps->group_data);\n\t}\n\tzfree(&evsel->stats);\n}\n\nstatic int evsel__alloc_prev_raw_counts(struct evsel *evsel)\n{\n\tint cpu_map_nr = evsel__nr_cpus(evsel);\n\tint nthreads = perf_thread_map__nr(evsel->core.threads);\n\tstruct perf_counts *counts;\n\n\tcounts = perf_counts__new(cpu_map_nr, nthreads);\n\tif (counts)\n\t\tevsel->prev_raw_counts = counts;\n\n\treturn counts ? 0 : -ENOMEM;\n}\n\nstatic void evsel__free_prev_raw_counts(struct evsel *evsel)\n{\n\tperf_counts__delete(evsel->prev_raw_counts);\n\tevsel->prev_raw_counts = NULL;\n}\n\nstatic void evsel__reset_prev_raw_counts(struct evsel *evsel)\n{\n\tif (evsel->prev_raw_counts)\n\t\tperf_counts__reset(evsel->prev_raw_counts);\n}\n\nstatic int evsel__alloc_stats(struct evsel *evsel, int nr_aggr, bool alloc_raw)\n{\n\tif (evsel__alloc_stat_priv(evsel, nr_aggr) < 0 ||\n\t    evsel__alloc_counts(evsel) < 0 ||\n\t    (alloc_raw && evsel__alloc_prev_raw_counts(evsel) < 0))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint evlist__alloc_stats(struct perf_stat_config *config,\n\t\t\tstruct evlist *evlist, bool alloc_raw)\n{\n\tstruct evsel *evsel;\n\tint nr_aggr = 0;\n\n\tif (config && config->aggr_map)\n\t\tnr_aggr = config->aggr_map->nr;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel__alloc_stats(evsel, nr_aggr, alloc_raw))\n\t\t\tgoto out_free;\n\t}\n\n\treturn 0;\n\nout_free:\n\tevlist__free_stats(evlist);\n\treturn -1;\n}\n\nvoid evlist__free_stats(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tevsel__free_stat_priv(evsel);\n\t\tevsel__free_counts(evsel);\n\t\tevsel__free_prev_raw_counts(evsel);\n\t}\n}\n\nvoid evlist__reset_stats(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tevsel__reset_stat_priv(evsel);\n\t\tevsel__reset_counts(evsel);\n\t}\n}\n\nvoid evlist__reset_aggr_stats(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel)\n\t\tevsel__reset_aggr_stats(evsel);\n}\n\nvoid evlist__reset_prev_raw_counts(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel)\n\t\tevsel__reset_prev_raw_counts(evsel);\n}\n\nstatic void evsel__copy_prev_raw_counts(struct evsel *evsel)\n{\n\tint idx, nthreads = perf_thread_map__nr(evsel->core.threads);\n\n\tfor (int thread = 0; thread < nthreads; thread++) {\n\t\tperf_cpu_map__for_each_idx(idx, evsel__cpus(evsel)) {\n\t\t\t*perf_counts(evsel->counts, idx, thread) =\n\t\t\t\t*perf_counts(evsel->prev_raw_counts, idx, thread);\n\t\t}\n\t}\n}\n\nvoid evlist__copy_prev_raw_counts(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel)\n\t\tevsel__copy_prev_raw_counts(evsel);\n}\n\nstatic void evsel__copy_res_stats(struct evsel *evsel)\n{\n\tstruct perf_stat_evsel *ps = evsel->stats;\n\n\t \n\t*ps->aggr[0].counts.values = avg_stats(&ps->res_stats);\n}\n\nvoid evlist__copy_res_stats(struct perf_stat_config *config, struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tif (config->aggr_mode != AGGR_GLOBAL)\n\t\treturn;\n\n\tevlist__for_each_entry(evlist, evsel)\n\t\tevsel__copy_res_stats(evsel);\n}\n\nstatic size_t pkg_id_hash(long __key, void *ctx __maybe_unused)\n{\n\tuint64_t *key = (uint64_t *) __key;\n\n\treturn *key & 0xffffffff;\n}\n\nstatic bool pkg_id_equal(long __key1, long __key2, void *ctx __maybe_unused)\n{\n\tuint64_t *key1 = (uint64_t *) __key1;\n\tuint64_t *key2 = (uint64_t *) __key2;\n\n\treturn *key1 == *key2;\n}\n\nstatic int check_per_pkg(struct evsel *counter, struct perf_counts_values *vals,\n\t\t\t int cpu_map_idx, bool *skip)\n{\n\tstruct hashmap *mask = counter->per_pkg_mask;\n\tstruct perf_cpu_map *cpus = evsel__cpus(counter);\n\tstruct perf_cpu cpu = perf_cpu_map__cpu(cpus, cpu_map_idx);\n\tint s, d, ret = 0;\n\tuint64_t *key;\n\n\t*skip = false;\n\n\tif (!counter->per_pkg)\n\t\treturn 0;\n\n\tif (perf_cpu_map__empty(cpus))\n\t\treturn 0;\n\n\tif (!mask) {\n\t\tmask = hashmap__new(pkg_id_hash, pkg_id_equal, NULL);\n\t\tif (IS_ERR(mask))\n\t\t\treturn -ENOMEM;\n\n\t\tcounter->per_pkg_mask = mask;\n\t}\n\n\t \n\tif (!(vals->run && vals->ena))\n\t\treturn 0;\n\n\ts = cpu__get_socket_id(cpu);\n\tif (s < 0)\n\t\treturn -1;\n\n\t \n\td = cpu__get_die_id(cpu);\n\tif (d < 0)\n\t\treturn -1;\n\n\tkey = malloc(sizeof(*key));\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\t*key = (uint64_t)d << 32 | s;\n\tif (hashmap__find(mask, key, NULL)) {\n\t\t*skip = true;\n\t\tfree(key);\n\t} else\n\t\tret = hashmap__add(mask, key, 1);\n\n\treturn ret;\n}\n\nstatic bool evsel__count_has_error(struct evsel *evsel,\n\t\t\t\t   struct perf_counts_values *count,\n\t\t\t\t   struct perf_stat_config *config)\n{\n\t \n\tif (evsel->err || evsel->counts->scaled == -1)\n\t\treturn true;\n\n\t \n\tif (config->aggr_mode == AGGR_GLOBAL)\n\t\treturn false;\n\n\t \n\tif (count->ena != 0 && count->run != 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\nprocess_counter_values(struct perf_stat_config *config, struct evsel *evsel,\n\t\t       int cpu_map_idx, int thread,\n\t\t       struct perf_counts_values *count)\n{\n\tstruct perf_stat_evsel *ps = evsel->stats;\n\tstatic struct perf_counts_values zero;\n\tbool skip = false;\n\n\tif (check_per_pkg(evsel, count, cpu_map_idx, &skip)) {\n\t\tpr_err(\"failed to read per-pkg counter\\n\");\n\t\treturn -1;\n\t}\n\n\tif (skip)\n\t\tcount = &zero;\n\n\tif (!evsel->snapshot)\n\t\tevsel__compute_deltas(evsel, cpu_map_idx, thread, count);\n\tperf_counts_values__scale(count, config->scale, NULL);\n\n\tif (config->aggr_mode == AGGR_THREAD) {\n\t\tstruct perf_counts_values *aggr_counts = &ps->aggr[thread].counts;\n\n\t\t \n\t\tif (count->val == 0 && config->system_wide)\n\t\t\treturn 0;\n\n\t\tps->aggr[thread].nr++;\n\n\t\taggr_counts->val += count->val;\n\t\taggr_counts->ena += count->ena;\n\t\taggr_counts->run += count->run;\n\t\treturn 0;\n\t}\n\n\tif (ps->aggr) {\n\t\tstruct perf_cpu cpu = perf_cpu_map__cpu(evsel->core.cpus, cpu_map_idx);\n\t\tstruct aggr_cpu_id aggr_id = config->aggr_get_id(config, cpu);\n\t\tstruct perf_stat_aggr *ps_aggr;\n\t\tint i;\n\n\t\tfor (i = 0; i < ps->nr_aggr; i++) {\n\t\t\tif (!aggr_cpu_id__equal(&aggr_id, &config->aggr_map->map[i]))\n\t\t\t\tcontinue;\n\n\t\t\tps_aggr = &ps->aggr[i];\n\t\t\tps_aggr->nr++;\n\n\t\t\t \n\t\t\tif (evsel__count_has_error(evsel, count, config) && !ps_aggr->failed) {\n\t\t\t\tps_aggr->counts.val = 0;\n\t\t\t\tps_aggr->counts.ena = 0;\n\t\t\t\tps_aggr->counts.run = 0;\n\t\t\t\tps_aggr->failed = true;\n\t\t\t}\n\n\t\t\tif (!ps_aggr->failed) {\n\t\t\t\tps_aggr->counts.val += count->val;\n\t\t\t\tps_aggr->counts.ena += count->ena;\n\t\t\t\tps_aggr->counts.run += count->run;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int process_counter_maps(struct perf_stat_config *config,\n\t\t\t\tstruct evsel *counter)\n{\n\tint nthreads = perf_thread_map__nr(counter->core.threads);\n\tint ncpus = evsel__nr_cpus(counter);\n\tint idx, thread;\n\n\tfor (thread = 0; thread < nthreads; thread++) {\n\t\tfor (idx = 0; idx < ncpus; idx++) {\n\t\t\tif (process_counter_values(config, counter, idx, thread,\n\t\t\t\t\t\t   perf_counts(counter->counts, idx, thread)))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint perf_stat_process_counter(struct perf_stat_config *config,\n\t\t\t      struct evsel *counter)\n{\n\tstruct perf_stat_evsel *ps = counter->stats;\n\tu64 *count;\n\tint ret;\n\n\tif (counter->per_pkg)\n\t\tevsel__zero_per_pkg(counter);\n\n\tret = process_counter_maps(config, counter);\n\tif (ret)\n\t\treturn ret;\n\n\tif (config->aggr_mode != AGGR_GLOBAL)\n\t\treturn 0;\n\n\t \n\tcount = ps->aggr[0].counts.values;\n\tupdate_stats(&ps->res_stats, *count);\n\n\tif (verbose > 0) {\n\t\tfprintf(config->output, \"%s: %\" PRIu64 \" %\" PRIu64 \" %\" PRIu64 \"\\n\",\n\t\t\tevsel__name(counter), count[0], count[1], count[2]);\n\t}\n\n\treturn 0;\n}\n\nstatic int evsel__merge_aggr_counters(struct evsel *evsel, struct evsel *alias)\n{\n\tstruct perf_stat_evsel *ps_a = evsel->stats;\n\tstruct perf_stat_evsel *ps_b = alias->stats;\n\tint i;\n\n\tif (ps_a->aggr == NULL && ps_b->aggr == NULL)\n\t\treturn 0;\n\n\tif (ps_a->nr_aggr != ps_b->nr_aggr) {\n\t\tpr_err(\"Unmatched aggregation mode between aliases\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < ps_a->nr_aggr; i++) {\n\t\tstruct perf_counts_values *aggr_counts_a = &ps_a->aggr[i].counts;\n\t\tstruct perf_counts_values *aggr_counts_b = &ps_b->aggr[i].counts;\n\n\t\t \n\n\t\taggr_counts_a->val += aggr_counts_b->val;\n\t\taggr_counts_a->ena += aggr_counts_b->ena;\n\t\taggr_counts_a->run += aggr_counts_b->run;\n\t}\n\n\treturn 0;\n}\n \nstatic bool evsel__is_alias(struct evsel *evsel_a, struct evsel *evsel_b)\n{\n\tif (strcmp(evsel__name(evsel_a), evsel__name(evsel_b)))\n\t\treturn false;\n\n\tif (evsel_a->scale != evsel_b->scale)\n\t\treturn false;\n\n\tif (evsel_a->cgrp != evsel_b->cgrp)\n\t\treturn false;\n\n\tif (strcmp(evsel_a->unit, evsel_b->unit))\n\t\treturn false;\n\n\tif (evsel__is_clock(evsel_a) != evsel__is_clock(evsel_b))\n\t\treturn false;\n\n\treturn !!strcmp(evsel_a->pmu_name, evsel_b->pmu_name);\n}\n\nstatic void evsel__merge_aliases(struct evsel *evsel)\n{\n\tstruct evlist *evlist = evsel->evlist;\n\tstruct evsel *alias;\n\n\talias = list_prepare_entry(evsel, &(evlist->core.entries), core.node);\n\tlist_for_each_entry_continue(alias, &evlist->core.entries, core.node) {\n\t\t \n\t\tif (evsel__is_alias(evsel, alias)) {\n\t\t\tevsel__merge_aggr_counters(evsel, alias);\n\t\t\talias->merged_stat = true;\n\t\t}\n\t}\n}\n\nstatic bool evsel__should_merge_hybrid(const struct evsel *evsel,\n\t\t\t\t       const struct perf_stat_config *config)\n{\n\treturn config->hybrid_merge && evsel__is_hybrid(evsel);\n}\n\nstatic void evsel__merge_stats(struct evsel *evsel, struct perf_stat_config *config)\n{\n\t \n\tif (evsel->merged_stat)\n\t\treturn;\n\n\tif (evsel->auto_merge_stats || evsel__should_merge_hybrid(evsel, config))\n\t\tevsel__merge_aliases(evsel);\n}\n\n \nvoid perf_stat_merge_counters(struct perf_stat_config *config, struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tif (config->no_merge)\n\t\treturn;\n\n\tevlist__for_each_entry(evlist, evsel)\n\t\tevsel__merge_stats(evsel, config);\n}\n\nstatic void evsel__update_percore_stats(struct evsel *evsel, struct aggr_cpu_id *core_id)\n{\n\tstruct perf_stat_evsel *ps = evsel->stats;\n\tstruct perf_counts_values counts = { 0, };\n\tstruct aggr_cpu_id id;\n\tstruct perf_cpu cpu;\n\tint idx;\n\n\t \n\tperf_cpu_map__for_each_cpu(cpu, idx, evsel->core.cpus) {\n\t\tstruct perf_stat_aggr *aggr = &ps->aggr[idx];\n\n\t\tid = aggr_cpu_id__core(cpu, NULL);\n\t\tif (!aggr_cpu_id__equal(core_id, &id))\n\t\t\tcontinue;\n\n\t\tcounts.val += aggr->counts.val;\n\t\tcounts.ena += aggr->counts.ena;\n\t\tcounts.run += aggr->counts.run;\n\t}\n\n\t \n\tperf_cpu_map__for_each_cpu(cpu, idx, evsel->core.cpus) {\n\t\tstruct perf_stat_aggr *aggr = &ps->aggr[idx];\n\n\t\tid = aggr_cpu_id__core(cpu, NULL);\n\t\tif (!aggr_cpu_id__equal(core_id, &id))\n\t\t\tcontinue;\n\n\t\taggr->counts.val = counts.val;\n\t\taggr->counts.ena = counts.ena;\n\t\taggr->counts.run = counts.run;\n\n\t\taggr->used = true;\n\t}\n}\n\n \nstatic void evsel__process_percore(struct evsel *evsel)\n{\n\tstruct perf_stat_evsel *ps = evsel->stats;\n\tstruct aggr_cpu_id core_id;\n\tstruct perf_cpu cpu;\n\tint idx;\n\n\tif (!evsel->percore)\n\t\treturn;\n\n\tperf_cpu_map__for_each_cpu(cpu, idx, evsel->core.cpus) {\n\t\tstruct perf_stat_aggr *aggr = &ps->aggr[idx];\n\n\t\tif (aggr->used)\n\t\t\tcontinue;\n\n\t\tcore_id = aggr_cpu_id__core(cpu, NULL);\n\t\tevsel__update_percore_stats(evsel, &core_id);\n\t}\n}\n\n \nvoid perf_stat_process_percore(struct perf_stat_config *config, struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tif (config->aggr_mode != AGGR_NONE)\n\t\treturn;\n\n\tevlist__for_each_entry(evlist, evsel)\n\t\tevsel__process_percore(evsel);\n}\n\nint perf_event__process_stat_event(struct perf_session *session,\n\t\t\t\t   union perf_event *event)\n{\n\tstruct perf_counts_values count, *ptr;\n\tstruct perf_record_stat *st = &event->stat;\n\tstruct evsel *counter;\n\tint cpu_map_idx;\n\n\tcount.val = st->val;\n\tcount.ena = st->ena;\n\tcount.run = st->run;\n\n\tcounter = evlist__id2evsel(session->evlist, st->id);\n\tif (!counter) {\n\t\tpr_err(\"Failed to resolve counter for stat event.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcpu_map_idx = perf_cpu_map__idx(evsel__cpus(counter), (struct perf_cpu){.cpu = st->cpu});\n\tif (cpu_map_idx == -1) {\n\t\tpr_err(\"Invalid CPU %d for event %s.\\n\", st->cpu, evsel__name(counter));\n\t\treturn -EINVAL;\n\t}\n\tptr = perf_counts(counter->counts, cpu_map_idx, st->thread);\n\tif (ptr == NULL) {\n\t\tpr_err(\"Failed to find perf count for CPU %d thread %d on event %s.\\n\",\n\t\t\tst->cpu, st->thread, evsel__name(counter));\n\t\treturn -EINVAL;\n\t}\n\t*ptr = count;\n\tcounter->supported = true;\n\treturn 0;\n}\n\nsize_t perf_event__fprintf_stat(union perf_event *event, FILE *fp)\n{\n\tstruct perf_record_stat *st = (struct perf_record_stat *)event;\n\tsize_t ret;\n\n\tret  = fprintf(fp, \"\\n... id %\" PRI_lu64 \", cpu %d, thread %d\\n\",\n\t\t       st->id, st->cpu, st->thread);\n\tret += fprintf(fp, \"... value %\" PRI_lu64 \", enabled %\" PRI_lu64 \", running %\" PRI_lu64 \"\\n\",\n\t\t       st->val, st->ena, st->run);\n\n\treturn ret;\n}\n\nsize_t perf_event__fprintf_stat_round(union perf_event *event, FILE *fp)\n{\n\tstruct perf_record_stat_round *rd = (struct perf_record_stat_round *)event;\n\tsize_t ret;\n\n\tret = fprintf(fp, \"\\n... time %\" PRI_lu64 \", type %s\\n\", rd->time,\n\t\t      rd->type == PERF_STAT_ROUND_TYPE__FINAL ? \"FINAL\" : \"INTERVAL\");\n\n\treturn ret;\n}\n\nsize_t perf_event__fprintf_stat_config(union perf_event *event, FILE *fp)\n{\n\tstruct perf_stat_config sc = {};\n\tsize_t ret;\n\n\tperf_event__read_stat_config(&sc, &event->stat_config);\n\n\tret  = fprintf(fp, \"\\n\");\n\tret += fprintf(fp, \"... aggr_mode %d\\n\", sc.aggr_mode);\n\tret += fprintf(fp, \"... scale     %d\\n\", sc.scale);\n\tret += fprintf(fp, \"... interval  %u\\n\", sc.interval);\n\n\treturn ret;\n}\n\nint create_perf_stat_counter(struct evsel *evsel,\n\t\t\t     struct perf_stat_config *config,\n\t\t\t     struct target *target,\n\t\t\t     int cpu_map_idx)\n{\n\tstruct perf_event_attr *attr = &evsel->core.attr;\n\tstruct evsel *leader = evsel__leader(evsel);\n\n\tattr->read_format = PERF_FORMAT_TOTAL_TIME_ENABLED |\n\t\t\t    PERF_FORMAT_TOTAL_TIME_RUNNING;\n\n\t \n\tif (leader->core.nr_members > 1)\n\t\tattr->read_format |= PERF_FORMAT_ID|PERF_FORMAT_GROUP;\n\n\tattr->inherit = !config->no_inherit && list_empty(&evsel->bpf_counter_list);\n\n\t \n\tattr->sample_period = 0;\n\n\tif (config->identifier)\n\t\tattr->sample_type = PERF_SAMPLE_IDENTIFIER;\n\n\tif (config->all_user) {\n\t\tattr->exclude_kernel = 1;\n\t\tattr->exclude_user   = 0;\n\t}\n\n\tif (config->all_kernel) {\n\t\tattr->exclude_kernel = 0;\n\t\tattr->exclude_user   = 1;\n\t}\n\n\t \n\tif (evsel__is_group_leader(evsel)) {\n\t\tattr->disabled = 1;\n\n\t\tif (target__enable_on_exec(target))\n\t\t\tattr->enable_on_exec = 1;\n\t}\n\n\tif (target__has_cpu(target) && !target__has_per_thread(target))\n\t\treturn evsel__open_per_cpu(evsel, evsel__cpus(evsel), cpu_map_idx);\n\n\treturn evsel__open_per_thread(evsel, evsel->core.threads);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}