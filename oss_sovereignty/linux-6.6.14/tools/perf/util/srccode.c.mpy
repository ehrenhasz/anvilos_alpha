{
  "module_name": "srccode.c",
  "hash_id": "e10875884d08587ae6859794682a706f6384270c06e4eeb19fb1a9ede6bdf061",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/srccode.c",
  "human_readable_source": "\n \n#include <linux/list.h>\n#include <linux/zalloc.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n#include \"srccode.h\"\n#include \"debug.h\"\n#include <internal/lib.h> \n#include \"fncache.h\"\n\n#define MAXSRCCACHE (32*1024*1024)\n#define MAXSRCFILES     64\n#define SRC_HTAB_SZ\t64\n\nstruct srcfile {\n\tstruct hlist_node hash_nd;\n\tstruct list_head nd;\n\tchar *fn;\n\tchar **lines;\n\tchar *map;\n\tunsigned numlines;\n\tsize_t maplen;\n};\n\nstatic struct hlist_head srcfile_htab[SRC_HTAB_SZ];\nstatic LIST_HEAD(srcfile_list);\nstatic long map_total_sz;\nstatic int num_srcfiles;\n\nstatic int countlines(char *map, int maplen)\n{\n\tint numl;\n\tchar *end = map + maplen;\n\tchar *p = map;\n\n\tif (maplen == 0)\n\t\treturn 0;\n\tnuml = 0;\n\twhile (p < end && (p = memchr(p, '\\n', end - p)) != NULL) {\n\t\tnuml++;\n\t\tp++;\n\t}\n\tif (p < end)\n\t\tnuml++;\n\treturn numl;\n}\n\nstatic void fill_lines(char **lines, int maxline, char *map, int maplen)\n{\n\tint l;\n\tchar *end = map + maplen;\n\tchar *p = map;\n\n\tif (maplen == 0 || maxline == 0)\n\t\treturn;\n\tl = 0;\n\tlines[l++] = map;\n\twhile (p < end && (p = memchr(p, '\\n', end - p)) != NULL) {\n\t\tif (l >= maxline)\n\t\t\treturn;\n\t\tlines[l++] = ++p;\n\t}\n\tif (p < end)\n\t\tlines[l] = p;\n}\n\nstatic void free_srcfile(struct srcfile *sf)\n{\n\tlist_del_init(&sf->nd);\n\thlist_del(&sf->hash_nd);\n\tmap_total_sz -= sf->maplen;\n\tmunmap(sf->map, sf->maplen);\n\tzfree(&sf->lines);\n\tzfree(&sf->fn);\n\tfree(sf);\n\tnum_srcfiles--;\n}\n\nstatic struct srcfile *find_srcfile(char *fn)\n{\n\tstruct stat st;\n\tstruct srcfile *h;\n\tint fd;\n\tunsigned long sz;\n\tunsigned hval = shash((unsigned char *)fn) % SRC_HTAB_SZ;\n\n\thlist_for_each_entry (h, &srcfile_htab[hval], hash_nd) {\n\t\tif (!strcmp(fn, h->fn)) {\n\t\t\t \n\t\t\tlist_move(&h->nd, &srcfile_list);\n\t\t\treturn h;\n\t\t}\n\t}\n\n\t \n\twhile ((num_srcfiles > MAXSRCFILES || map_total_sz > MAXSRCCACHE) &&\n\t       srcfile_list.next != &srcfile_list) {\n\t\tassert(!list_empty(&srcfile_list));\n\t\th = list_entry(srcfile_list.prev, struct srcfile, nd);\n\t\tfree_srcfile(h);\n\t}\n\n\tfd = open(fn, O_RDONLY);\n\tif (fd < 0 || fstat(fd, &st) < 0) {\n\t\tpr_debug(\"cannot open source file %s\\n\", fn);\n\t\treturn NULL;\n\t}\n\n\th = malloc(sizeof(struct srcfile));\n\tif (!h)\n\t\treturn NULL;\n\n\th->fn = strdup(fn);\n\tif (!h->fn)\n\t\tgoto out_h;\n\n\th->maplen = st.st_size;\n\tsz = (h->maplen + page_size - 1) & ~(page_size - 1);\n\th->map = mmap(NULL, sz, PROT_READ, MAP_SHARED, fd, 0);\n\tclose(fd);\n\tif (h->map == (char *)-1) {\n\t\tpr_debug(\"cannot mmap source file %s\\n\", fn);\n\t\tgoto out_fn;\n\t}\n\th->numlines = countlines(h->map, h->maplen);\n\th->lines = calloc(h->numlines, sizeof(char *));\n\tif (!h->lines)\n\t\tgoto out_map;\n\tfill_lines(h->lines, h->numlines, h->map, h->maplen);\n\tlist_add(&h->nd, &srcfile_list);\n\thlist_add_head(&h->hash_nd, &srcfile_htab[hval]);\n\tmap_total_sz += h->maplen;\n\tnum_srcfiles++;\n\treturn h;\n\nout_map:\n\tmunmap(h->map, sz);\nout_fn:\n\tzfree(&h->fn);\nout_h:\n\tfree(h);\n\treturn NULL;\n}\n\n \nchar *find_sourceline(char *fn, unsigned line, int *lenp)\n{\n\tchar *l, *p;\n\tstruct srcfile *sf = find_srcfile(fn);\n\tif (!sf)\n\t\treturn NULL;\n\tline--;\n\tif (line >= sf->numlines)\n\t\treturn NULL;\n\tl = sf->lines[line];\n\tif (!l)\n\t\treturn NULL;\n\tp = memchr(l, '\\n', sf->map + sf->maplen - l);\n\t*lenp = p - l;\n\treturn l;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}