{
  "module_name": "bpf-filter.l",
  "hash_id": "c5f04d2fa055fa77b4cb17515ede04febb07e9ef649b2aa02e9a13759b63817c",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/bpf-filter.l",
  "human_readable_source": "%option prefix=\"perf_bpf_filter_\"\n%option noyywrap\n\n%{\n#include <stdio.h>\n#include <stdlib.h>\n#include <linux/perf_event.h>\n\n#include \"bpf-filter.h\"\n#include \"bpf-filter-bison.h\"\n\nstatic int sample(unsigned long sample_flag)\n{\n\tperf_bpf_filter_lval.sample.type = sample_flag;\n\tperf_bpf_filter_lval.sample.part = 0;\n\treturn BFT_SAMPLE;\n}\n\nstatic int sample_part(unsigned long sample_flag, int part)\n{\n\tperf_bpf_filter_lval.sample.type = sample_flag;\n\tperf_bpf_filter_lval.sample.part = part;\n\treturn BFT_SAMPLE;\n}\n\nstatic int operator(enum perf_bpf_filter_op op)\n{\n\tperf_bpf_filter_lval.op = op;\n\treturn BFT_OP;\n}\n\nstatic int value(int base)\n{\n\tlong num;\n\n\terrno = 0;\n\tnum = strtoul(perf_bpf_filter_text, NULL, base);\n\tif (errno)\n\t\treturn BFT_ERROR;\n\n\tperf_bpf_filter_lval.num = num;\n\treturn BFT_NUM;\n}\n\nstatic int constant(int val)\n{\n\tperf_bpf_filter_lval.num = val;\n\treturn BFT_NUM;\n}\n\nstatic int error(const char *str)\n{\n\tprintf(\"perf_bpf_filter: Unexpected filter %s: %s\\n\", str, perf_bpf_filter_text);\n\treturn BFT_ERROR;\n}\n\n%}\n\nnum_dec\t\t[0-9]+\nnum_hex\t\t0[Xx][0-9a-fA-F]+\nspace\t\t[ \\t]+\nident\t\t[_a-zA-Z][_a-zA-Z0-9]+\n\n%%\n\n{num_dec}\t{ return value(10); }\n{num_hex}\t{ return value(16); }\n{space}\t\t{ }\n\nip\t\t{ return sample(PERF_SAMPLE_IP); }\nid\t\t{ return sample(PERF_SAMPLE_ID); }\ntid\t\t{ return sample(PERF_SAMPLE_TID); }\npid\t\t{ return sample_part(PERF_SAMPLE_TID, 1); }\ncpu\t\t{ return sample(PERF_SAMPLE_CPU); }\ntime\t\t{ return sample(PERF_SAMPLE_TIME); }\naddr\t\t{ return sample(PERF_SAMPLE_ADDR); }\nperiod\t\t{ return sample(PERF_SAMPLE_PERIOD); }\ntxn\t\t{ return sample(PERF_SAMPLE_TRANSACTION); }\nweight\t\t{ return sample(PERF_SAMPLE_WEIGHT); }\nweight1\t\t{ return sample_part(PERF_SAMPLE_WEIGHT_STRUCT, 1); }\nweight2\t\t{ return sample_part(PERF_SAMPLE_WEIGHT_STRUCT, 2); }\nweight3\t\t{ return sample_part(PERF_SAMPLE_WEIGHT_STRUCT, 3); }\nins_lat\t\t{ return sample_part(PERF_SAMPLE_WEIGHT_STRUCT, 2); } /* alias for weight2 */\np_stage_cyc\t{ return sample_part(PERF_SAMPLE_WEIGHT_STRUCT, 3); } /* alias for weight3 */\nretire_lat\t{ return sample_part(PERF_SAMPLE_WEIGHT_STRUCT, 3); } /* alias for weight3 */\nphys_addr\t{ return sample(PERF_SAMPLE_PHYS_ADDR); }\ncode_pgsz\t{ return sample(PERF_SAMPLE_CODE_PAGE_SIZE); }\ndata_pgsz\t{ return sample(PERF_SAMPLE_DATA_PAGE_SIZE); }\nmem_op\t\t{ return sample_part(PERF_SAMPLE_DATA_SRC, 1); }\nmem_lvlnum\t{ return sample_part(PERF_SAMPLE_DATA_SRC, 2); }\nmem_lvl\t\t{ return sample_part(PERF_SAMPLE_DATA_SRC, 2); } /* alias for mem_lvlnum */\nmem_snoop\t{ return sample_part(PERF_SAMPLE_DATA_SRC, 3); } /* include snoopx */\nmem_remote\t{ return sample_part(PERF_SAMPLE_DATA_SRC, 4); }\nmem_lock\t{ return sample_part(PERF_SAMPLE_DATA_SRC, 5); }\nmem_dtlb\t{ return sample_part(PERF_SAMPLE_DATA_SRC, 6); }\nmem_blk\t\t{ return sample_part(PERF_SAMPLE_DATA_SRC, 7); }\nmem_hops\t{ return sample_part(PERF_SAMPLE_DATA_SRC, 8); }\n\n\"==\"\t\t{ return operator(PBF_OP_EQ); }\n\"!=\"\t\t{ return operator(PBF_OP_NEQ); }\n\">\"\t\t{ return operator(PBF_OP_GT); }\n\"<\"\t\t{ return operator(PBF_OP_LT); }\n\">=\"\t\t{ return operator(PBF_OP_GE); }\n\"<=\"\t\t{ return operator(PBF_OP_LE); }\n\"&\"\t\t{ return operator(PBF_OP_AND); }\n\nna\t\t{ return constant(PERF_MEM_OP_NA); }\nload\t\t{ return constant(PERF_MEM_OP_LOAD); }\nstore\t\t{ return constant(PERF_MEM_OP_STORE); }\npfetch\t\t{ return constant(PERF_MEM_OP_PFETCH); }\nexec\t\t{ return constant(PERF_MEM_OP_EXEC); }\n\nl1\t\t{ return constant(PERF_MEM_LVLNUM_L1); }\nl2\t\t{ return constant(PERF_MEM_LVLNUM_L2); }\nl3\t\t{ return constant(PERF_MEM_LVLNUM_L3); }\nl4\t\t{ return constant(PERF_MEM_LVLNUM_L4); }\ncxl\t\t{ return constant(PERF_MEM_LVLNUM_CXL); }\nio\t\t{ return constant(PERF_MEM_LVLNUM_IO); }\nany_cache\t{ return constant(PERF_MEM_LVLNUM_ANY_CACHE); }\nlfb\t\t{ return constant(PERF_MEM_LVLNUM_LFB); }\nram\t\t{ return constant(PERF_MEM_LVLNUM_RAM); }\npmem\t\t{ return constant(PERF_MEM_LVLNUM_PMEM); }\n\nnone\t\t{ return constant(PERF_MEM_SNOOP_NONE); }\nhit\t\t{ return constant(PERF_MEM_SNOOP_HIT); }\nmiss\t\t{ return constant(PERF_MEM_SNOOP_MISS); }\nhitm\t\t{ return constant(PERF_MEM_SNOOP_HITM); }\nfwd\t\t{ return constant(PERF_MEM_SNOOPX_FWD); }\npeer\t\t{ return constant(PERF_MEM_SNOOPX_PEER); }\n\nremote\t\t{ return constant(PERF_MEM_REMOTE_REMOTE); }\n\nlocked\t\t{ return constant(PERF_MEM_LOCK_LOCKED); }\n\nl1_hit\t\t{ return constant(PERF_MEM_TLB_L1 | PERF_MEM_TLB_HIT); }\nl1_miss\t\t{ return constant(PERF_MEM_TLB_L1 | PERF_MEM_TLB_MISS); }\nl2_hit\t\t{ return constant(PERF_MEM_TLB_L2 | PERF_MEM_TLB_HIT); }\nl2_miss\t\t{ return constant(PERF_MEM_TLB_L2 | PERF_MEM_TLB_MISS); }\nany_hit\t\t{ return constant(PERF_MEM_TLB_HIT); }\nany_miss\t{ return constant(PERF_MEM_TLB_MISS); }\nwalk\t\t{ return constant(PERF_MEM_TLB_WK); }\nos\t\t{ return constant(PERF_MEM_TLB_OS); }\nfault\t\t{ return constant(PERF_MEM_TLB_OS); } /* alias for os */\n\nby_data\t\t{ return constant(PERF_MEM_BLK_DATA); }\nby_addr\t\t{ return constant(PERF_MEM_BLK_ADDR); }\n\nhops0\t\t{ return constant(PERF_MEM_HOPS_0); }\nhops1\t\t{ return constant(PERF_MEM_HOPS_1); }\nhops2\t\t{ return constant(PERF_MEM_HOPS_2); }\nhops3\t\t{ return constant(PERF_MEM_HOPS_3); }\n\n\",\"\t\t{ return ','; }\n\"||\"\t\t{ return BFT_LOGICAL_OR; }\n\n{ident}\t\t{ return error(\"ident\"); }\n.\t\t{ return error(\"input\"); }\n\n%%\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}