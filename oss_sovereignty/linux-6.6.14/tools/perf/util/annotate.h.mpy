{
  "module_name": "annotate.h",
  "hash_id": "b4dda18c99569232026adbca0c0942f4e043e7e3348c941fe0297dcbda7e1e71",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/annotate.h",
  "human_readable_source": " \n#ifndef __PERF_ANNOTATE_H\n#define __PERF_ANNOTATE_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <asm/bug.h>\n#include \"symbol_conf.h\"\n#include \"mutex.h\"\n#include \"spark.h\"\n\nstruct hist_browser_timer;\nstruct hist_entry;\nstruct ins_ops;\nstruct map;\nstruct map_symbol;\nstruct addr_map_symbol;\nstruct option;\nstruct perf_sample;\nstruct evsel;\nstruct symbol;\n\nstruct ins {\n\tconst char     *name;\n\tstruct ins_ops *ops;\n};\n\nstruct ins_operands {\n\tchar\t*raw;\n\tchar\t*raw_comment;\n\tchar\t*raw_func_start;\n\tstruct {\n\t\tchar\t*raw;\n\t\tchar\t*name;\n\t\tstruct symbol *sym;\n\t\tu64\taddr;\n\t\ts64\toffset;\n\t\tbool\toffset_avail;\n\t\tbool\toutside;\n\t} target;\n\tunion {\n\t\tstruct {\n\t\t\tchar\t*raw;\n\t\t\tchar\t*name;\n\t\t\tu64\taddr;\n\t\t} source;\n\t\tstruct {\n\t\t\tstruct ins\t    ins;\n\t\t\tstruct ins_operands *ops;\n\t\t} locked;\n\t};\n};\n\nstruct arch;\n\nstruct ins_ops {\n\tvoid (*free)(struct ins_operands *ops);\n\tint (*parse)(struct arch *arch, struct ins_operands *ops, struct map_symbol *ms);\n\tint (*scnprintf)(struct ins *ins, char *bf, size_t size,\n\t\t\t struct ins_operands *ops, int max_ins_name);\n};\n\nbool ins__is_jump(const struct ins *ins);\nbool ins__is_call(const struct ins *ins);\nbool ins__is_ret(const struct ins *ins);\nbool ins__is_lock(const struct ins *ins);\nint ins__scnprintf(struct ins *ins, char *bf, size_t size, struct ins_operands *ops, int max_ins_name);\nbool ins__is_fused(struct arch *arch, const char *ins1, const char *ins2);\n\n#define ANNOTATION__IPC_WIDTH 6\n#define ANNOTATION__CYCLES_WIDTH 6\n#define ANNOTATION__MINMAX_CYCLES_WIDTH 19\n#define ANNOTATION__AVG_IPC_WIDTH 36\n#define ANNOTATION_DUMMY_LEN\t256\n\nstruct annotation_options {\n\tbool hide_src_code,\n\t     use_offset,\n\t     jump_arrows,\n\t     print_lines,\n\t     full_path,\n\t     show_linenr,\n\t     show_fileloc,\n\t     show_nr_jumps,\n\t     show_minmax_cycle,\n\t     show_asm_raw,\n\t     annotate_src,\n\t     full_addr;\n\tu8   offset_level;\n\tint  min_pcnt;\n\tint  max_lines;\n\tint  context;\n\tchar *objdump_path;\n\tchar *disassembler_style;\n\tconst char *prefix;\n\tconst char *prefix_strip;\n\tunsigned int percent_type;\n};\n\nenum {\n\tANNOTATION__OFFSET_JUMP_TARGETS = 1,\n\tANNOTATION__OFFSET_CALL,\n\tANNOTATION__MAX_OFFSET_LEVEL,\n};\n\n#define ANNOTATION__MIN_OFFSET_LEVEL ANNOTATION__OFFSET_JUMP_TARGETS\n\nstruct annotation;\n\nstruct sym_hist_entry {\n\tu64\t\tnr_samples;\n\tu64\t\tperiod;\n};\n\nenum {\n\tPERCENT_HITS_LOCAL,\n\tPERCENT_HITS_GLOBAL,\n\tPERCENT_PERIOD_LOCAL,\n\tPERCENT_PERIOD_GLOBAL,\n\tPERCENT_MAX,\n};\n\nstruct annotation_data {\n\tdouble\t\t\t percent[PERCENT_MAX];\n\tdouble\t\t\t percent_sum;\n\tstruct sym_hist_entry\t he;\n};\n\nstruct annotation_line {\n\tstruct list_head\t node;\n\tstruct rb_node\t\t rb_node;\n\ts64\t\t\t offset;\n\tchar\t\t\t*line;\n\tint\t\t\t line_nr;\n\tchar\t\t\t*fileloc;\n\tint\t\t\t jump_sources;\n\tfloat\t\t\t ipc;\n\tu64\t\t\t cycles;\n\tu64\t\t\t cycles_max;\n\tu64\t\t\t cycles_min;\n\tchar\t\t\t*path;\n\tu32\t\t\t idx;\n\tint\t\t\t idx_asm;\n\tint\t\t\t data_nr;\n\tstruct annotation_data\t data[];\n};\n\nstruct disasm_line {\n\tstruct ins\t\t ins;\n\tstruct ins_operands\t ops;\n\n\t \n\tstruct annotation_line\t al;\n};\n\nstatic inline double annotation_data__percent(struct annotation_data *data,\n\t\t\t\t\t      unsigned int which)\n{\n\treturn which < PERCENT_MAX ? data->percent[which] : -1;\n}\n\nstatic inline const char *percent_type_str(unsigned int type)\n{\n\tstatic const char *str[PERCENT_MAX] = {\n\t\t\"local hits\",\n\t\t\"global hits\",\n\t\t\"local period\",\n\t\t\"global period\",\n\t};\n\n\tif (WARN_ON(type >= PERCENT_MAX))\n\t\treturn \"N/A\";\n\n\treturn str[type];\n}\n\nstatic inline struct disasm_line *disasm_line(struct annotation_line *al)\n{\n\treturn al ? container_of(al, struct disasm_line, al) : NULL;\n}\n\n \nstatic inline bool disasm_line__has_local_offset(const struct disasm_line *dl)\n{\n\treturn dl->ops.target.offset_avail && !dl->ops.target.outside;\n}\n\n \nbool disasm_line__is_valid_local_jump(struct disasm_line *dl, struct symbol *sym);\n\nvoid disasm_line__free(struct disasm_line *dl);\nstruct annotation_line *\nannotation_line__next(struct annotation_line *pos, struct list_head *head);\n\nstruct annotation_write_ops {\n\tbool first_line, current_entry, change_color;\n\tint  width;\n\tvoid *obj;\n\tint  (*set_color)(void *obj, int color);\n\tvoid (*set_percent_color)(void *obj, double percent, bool current);\n\tint  (*set_jumps_percent_color)(void *obj, int nr, bool current);\n\tvoid (*printf)(void *obj, const char *fmt, ...);\n\tvoid (*write_graph)(void *obj, int graph);\n};\n\nvoid annotation_line__write(struct annotation_line *al, struct annotation *notes,\n\t\t\t    struct annotation_write_ops *ops,\n\t\t\t    struct annotation_options *opts);\n\nint __annotation__scnprintf_samples_period(struct annotation *notes,\n\t\t\t\t\t   char *bf, size_t size,\n\t\t\t\t\t   struct evsel *evsel,\n\t\t\t\t\t   bool show_freq);\n\nint disasm_line__scnprintf(struct disasm_line *dl, char *bf, size_t size, bool raw, int max_ins_name);\nsize_t disasm__fprintf(struct list_head *head, FILE *fp);\nvoid symbol__calc_percent(struct symbol *sym, struct evsel *evsel);\n\nstruct sym_hist {\n\tu64\t\t      nr_samples;\n\tu64\t\t      period;\n\tstruct sym_hist_entry addr[];\n};\n\nstruct cyc_hist {\n\tu64\tstart;\n\tu64\tcycles;\n\tu64\tcycles_aggr;\n\tu64\tcycles_max;\n\tu64\tcycles_min;\n\ts64\tcycles_spark[NUM_SPARKS];\n\tu32\tnum;\n\tu32\tnum_aggr;\n\tu8\thave_start;\n\t \n\tu16\treset;\n};\n\n \nstruct annotated_source {\n\tstruct list_head   source;\n\tint    \t\t   nr_histograms;\n\tsize_t\t\t   sizeof_sym_hist;\n\tstruct cyc_hist\t   *cycles_hist;\n\tstruct sym_hist\t   *histograms;\n};\n\nstruct LOCKABLE annotation {\n\tu64\t\t\tmax_coverage;\n\tu64\t\t\tstart;\n\tu64\t\t\thit_cycles;\n\tu64\t\t\thit_insn;\n\tunsigned int\t\ttotal_insn;\n\tunsigned int\t\tcover_insn;\n\tstruct annotation_options *options;\n\tstruct annotation_line\t**offsets;\n\tint\t\t\tnr_events;\n\tint\t\t\tmax_jump_sources;\n\tint\t\t\tnr_entries;\n\tint\t\t\tnr_asm_entries;\n\tu16\t\t\tmax_line_len;\n\tstruct {\n\t\tu8\t\taddr;\n\t\tu8\t\tjumps;\n\t\tu8\t\ttarget;\n\t\tu8\t\tmin_addr;\n\t\tu8\t\tmax_addr;\n\t\tu8\t\tmax_ins_name;\n\t} widths;\n\tbool\t\t\thave_cycles;\n\tstruct annotated_source *src;\n};\n\nstatic inline void annotation__init(struct annotation *notes __maybe_unused)\n{\n}\nvoid annotation__exit(struct annotation *notes);\n\nvoid annotation__lock(struct annotation *notes) EXCLUSIVE_LOCK_FUNCTION(*notes);\nvoid annotation__unlock(struct annotation *notes) UNLOCK_FUNCTION(*notes);\nbool annotation__trylock(struct annotation *notes) EXCLUSIVE_TRYLOCK_FUNCTION(true, *notes);\n\nstatic inline int annotation__cycles_width(struct annotation *notes)\n{\n\tif (notes->have_cycles && notes->options->show_minmax_cycle)\n\t\treturn ANNOTATION__IPC_WIDTH + ANNOTATION__MINMAX_CYCLES_WIDTH;\n\n\treturn notes->have_cycles ? ANNOTATION__IPC_WIDTH + ANNOTATION__CYCLES_WIDTH : 0;\n}\n\nstatic inline int annotation__pcnt_width(struct annotation *notes)\n{\n\treturn (symbol_conf.show_total_period ? 12 : 7) * notes->nr_events;\n}\n\nstatic inline bool annotation_line__filter(struct annotation_line *al, struct annotation *notes)\n{\n\treturn notes->options->hide_src_code && al->offset == -1;\n}\n\nvoid annotation__set_offsets(struct annotation *notes, s64 size);\nvoid annotation__compute_ipc(struct annotation *notes, size_t size);\nvoid annotation__mark_jump_targets(struct annotation *notes, struct symbol *sym);\nvoid annotation__update_column_widths(struct annotation *notes);\nvoid annotation__init_column_widths(struct annotation *notes, struct symbol *sym);\nvoid annotation__toggle_full_addr(struct annotation *notes, struct map_symbol *ms);\n\nstatic inline struct sym_hist *annotated_source__histogram(struct annotated_source *src, int idx)\n{\n\treturn ((void *)src->histograms) + (src->sizeof_sym_hist * idx);\n}\n\nstatic inline struct sym_hist *annotation__histogram(struct annotation *notes, int idx)\n{\n\treturn annotated_source__histogram(notes->src, idx);\n}\n\nstatic inline struct annotation *symbol__annotation(struct symbol *sym)\n{\n\treturn (void *)sym - symbol_conf.priv_size;\n}\n\nint addr_map_symbol__inc_samples(struct addr_map_symbol *ams, struct perf_sample *sample,\n\t\t\t\t struct evsel *evsel);\n\nint addr_map_symbol__account_cycles(struct addr_map_symbol *ams,\n\t\t\t\t    struct addr_map_symbol *start,\n\t\t\t\t    unsigned cycles);\n\nint hist_entry__inc_addr_samples(struct hist_entry *he, struct perf_sample *sample,\n\t\t\t\t struct evsel *evsel, u64 addr);\n\nstruct annotated_source *symbol__hists(struct symbol *sym, int nr_hists);\nvoid symbol__annotate_zero_histograms(struct symbol *sym);\n\nint symbol__annotate(struct map_symbol *ms,\n\t\t     struct evsel *evsel,\n\t\t     struct annotation_options *options,\n\t\t     struct arch **parch);\nint symbol__annotate2(struct map_symbol *ms,\n\t\t      struct evsel *evsel,\n\t\t      struct annotation_options *options,\n\t\t      struct arch **parch);\n\nenum symbol_disassemble_errno {\n\tSYMBOL_ANNOTATE_ERRNO__SUCCESS\t\t= 0,\n\n\t \n\t__SYMBOL_ANNOTATE_ERRNO__START\t\t= -10000,\n\n\tSYMBOL_ANNOTATE_ERRNO__NO_VMLINUX\t= __SYMBOL_ANNOTATE_ERRNO__START,\n\tSYMBOL_ANNOTATE_ERRNO__NO_LIBOPCODES_FOR_BPF,\n\tSYMBOL_ANNOTATE_ERRNO__ARCH_INIT_CPUID_PARSING,\n\tSYMBOL_ANNOTATE_ERRNO__ARCH_INIT_REGEXP,\n\tSYMBOL_ANNOTATE_ERRNO__BPF_INVALID_FILE,\n\tSYMBOL_ANNOTATE_ERRNO__BPF_MISSING_BTF,\n\n\t__SYMBOL_ANNOTATE_ERRNO__END,\n};\n\nint symbol__strerror_disassemble(struct map_symbol *ms, int errnum, char *buf, size_t buflen);\n\nint symbol__annotate_printf(struct map_symbol *ms, struct evsel *evsel,\n\t\t\t    struct annotation_options *options);\nvoid symbol__annotate_zero_histogram(struct symbol *sym, int evidx);\nvoid symbol__annotate_decay_histogram(struct symbol *sym, int evidx);\nvoid annotated_source__purge(struct annotated_source *as);\n\nint map_symbol__annotation_dump(struct map_symbol *ms, struct evsel *evsel,\n\t\t\t\tstruct annotation_options *opts);\n\nbool ui__has_annotation(void);\n\nint symbol__tty_annotate(struct map_symbol *ms, struct evsel *evsel, struct annotation_options *opts);\n\nint symbol__tty_annotate2(struct map_symbol *ms, struct evsel *evsel, struct annotation_options *opts);\n\n#ifdef HAVE_SLANG_SUPPORT\nint symbol__tui_annotate(struct map_symbol *ms, struct evsel *evsel,\n\t\t\t struct hist_browser_timer *hbt,\n\t\t\t struct annotation_options *opts);\n#else\nstatic inline int symbol__tui_annotate(struct map_symbol *ms __maybe_unused,\n\t\t\t\tstruct evsel *evsel  __maybe_unused,\n\t\t\t\tstruct hist_browser_timer *hbt __maybe_unused,\n\t\t\t\tstruct annotation_options *opts __maybe_unused)\n{\n\treturn 0;\n}\n#endif\n\nvoid annotation_options__init(struct annotation_options *opt);\nvoid annotation_options__exit(struct annotation_options *opt);\n\nvoid annotation_config__init(struct annotation_options *opt);\n\nint annotate_parse_percent_type(const struct option *opt, const char *_str,\n\t\t\t\tint unset);\n\nint annotate_check_args(struct annotation_options *args);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}