{
  "module_name": "symbol-minimal.c",
  "hash_id": "8ee652bcedfb0139bbc7d0d8c87e9053eaf14f81dffe0ca1d7cc9352349e0c7f",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/symbol-minimal.c",
  "human_readable_source": "#include \"dso.h\"\n#include \"symbol.h\"\n#include \"symsrc.h\"\n\n#include <errno.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <byteswap.h>\n#include <sys/stat.h>\n#include <linux/zalloc.h>\n#include <internal/lib.h>\n\nstatic bool check_need_swap(int file_endian)\n{\n\tconst int data = 1;\n\tu8 *check = (u8 *)&data;\n\tint host_endian;\n\n\tif (check[0] == 1)\n\t\thost_endian = ELFDATA2LSB;\n\telse\n\t\thost_endian = ELFDATA2MSB;\n\n\treturn host_endian != file_endian;\n}\n\n#define NOTE_ALIGN(sz) (((sz) + 3) & ~3)\n\n#define NT_GNU_BUILD_ID\t3\n\nstatic int read_build_id(void *note_data, size_t note_len, struct build_id *bid,\n\t\t\t bool need_swap)\n{\n\tsize_t size = sizeof(bid->data);\n\tstruct {\n\t\tu32 n_namesz;\n\t\tu32 n_descsz;\n\t\tu32 n_type;\n\t} *nhdr;\n\tvoid *ptr;\n\n\tptr = note_data;\n\twhile (ptr < (note_data + note_len)) {\n\t\tconst char *name;\n\t\tsize_t namesz, descsz;\n\n\t\tnhdr = ptr;\n\t\tif (need_swap) {\n\t\t\tnhdr->n_namesz = bswap_32(nhdr->n_namesz);\n\t\t\tnhdr->n_descsz = bswap_32(nhdr->n_descsz);\n\t\t\tnhdr->n_type = bswap_32(nhdr->n_type);\n\t\t}\n\n\t\tnamesz = NOTE_ALIGN(nhdr->n_namesz);\n\t\tdescsz = NOTE_ALIGN(nhdr->n_descsz);\n\n\t\tptr += sizeof(*nhdr);\n\t\tname = ptr;\n\t\tptr += namesz;\n\t\tif (nhdr->n_type == NT_GNU_BUILD_ID &&\n\t\t    nhdr->n_namesz == sizeof(\"GNU\")) {\n\t\t\tif (memcmp(name, \"GNU\", sizeof(\"GNU\")) == 0) {\n\t\t\t\tsize_t sz = min(size, descsz);\n\t\t\t\tmemcpy(bid->data, ptr, sz);\n\t\t\t\tmemset(bid->data + sz, 0, size - sz);\n\t\t\t\tbid->size = sz;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tptr += descsz;\n\t}\n\n\treturn -1;\n}\n\nint filename__read_debuglink(const char *filename __maybe_unused,\n\t\t\t     char *debuglink __maybe_unused,\n\t\t\t     size_t size __maybe_unused)\n{\n\treturn -1;\n}\n\n \nint filename__read_build_id(const char *filename, struct build_id *bid)\n{\n\tFILE *fp;\n\tint ret = -1;\n\tbool need_swap = false;\n\tu8 e_ident[EI_NIDENT];\n\tsize_t buf_size;\n\tvoid *buf;\n\tint i;\n\n\tfp = fopen(filename, \"r\");\n\tif (fp == NULL)\n\t\treturn -1;\n\n\tif (fread(e_ident, sizeof(e_ident), 1, fp) != 1)\n\t\tgoto out;\n\n\tif (memcmp(e_ident, ELFMAG, SELFMAG) ||\n\t    e_ident[EI_VERSION] != EV_CURRENT)\n\t\tgoto out;\n\n\tneed_swap = check_need_swap(e_ident[EI_DATA]);\n\n\t \n\tfseek(fp, 0, SEEK_SET);\n\n\tif (e_ident[EI_CLASS] == ELFCLASS32) {\n\t\tElf32_Ehdr ehdr;\n\t\tElf32_Phdr *phdr;\n\n\t\tif (fread(&ehdr, sizeof(ehdr), 1, fp) != 1)\n\t\t\tgoto out;\n\n\t\tif (need_swap) {\n\t\t\tehdr.e_phoff = bswap_32(ehdr.e_phoff);\n\t\t\tehdr.e_phentsize = bswap_16(ehdr.e_phentsize);\n\t\t\tehdr.e_phnum = bswap_16(ehdr.e_phnum);\n\t\t}\n\n\t\tbuf_size = ehdr.e_phentsize * ehdr.e_phnum;\n\t\tbuf = malloc(buf_size);\n\t\tif (buf == NULL)\n\t\t\tgoto out;\n\n\t\tfseek(fp, ehdr.e_phoff, SEEK_SET);\n\t\tif (fread(buf, buf_size, 1, fp) != 1)\n\t\t\tgoto out_free;\n\n\t\tfor (i = 0, phdr = buf; i < ehdr.e_phnum; i++, phdr++) {\n\t\t\tvoid *tmp;\n\t\t\tlong offset;\n\n\t\t\tif (need_swap) {\n\t\t\t\tphdr->p_type = bswap_32(phdr->p_type);\n\t\t\t\tphdr->p_offset = bswap_32(phdr->p_offset);\n\t\t\t\tphdr->p_filesz = bswap_32(phdr->p_filesz);\n\t\t\t}\n\n\t\t\tif (phdr->p_type != PT_NOTE)\n\t\t\t\tcontinue;\n\n\t\t\tbuf_size = phdr->p_filesz;\n\t\t\toffset = phdr->p_offset;\n\t\t\ttmp = realloc(buf, buf_size);\n\t\t\tif (tmp == NULL)\n\t\t\t\tgoto out_free;\n\n\t\t\tbuf = tmp;\n\t\t\tfseek(fp, offset, SEEK_SET);\n\t\t\tif (fread(buf, buf_size, 1, fp) != 1)\n\t\t\t\tgoto out_free;\n\n\t\t\tret = read_build_id(buf, buf_size, bid, need_swap);\n\t\t\tif (ret == 0)\n\t\t\t\tret = bid->size;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tElf64_Ehdr ehdr;\n\t\tElf64_Phdr *phdr;\n\n\t\tif (fread(&ehdr, sizeof(ehdr), 1, fp) != 1)\n\t\t\tgoto out;\n\n\t\tif (need_swap) {\n\t\t\tehdr.e_phoff = bswap_64(ehdr.e_phoff);\n\t\t\tehdr.e_phentsize = bswap_16(ehdr.e_phentsize);\n\t\t\tehdr.e_phnum = bswap_16(ehdr.e_phnum);\n\t\t}\n\n\t\tbuf_size = ehdr.e_phentsize * ehdr.e_phnum;\n\t\tbuf = malloc(buf_size);\n\t\tif (buf == NULL)\n\t\t\tgoto out;\n\n\t\tfseek(fp, ehdr.e_phoff, SEEK_SET);\n\t\tif (fread(buf, buf_size, 1, fp) != 1)\n\t\t\tgoto out_free;\n\n\t\tfor (i = 0, phdr = buf; i < ehdr.e_phnum; i++, phdr++) {\n\t\t\tvoid *tmp;\n\t\t\tlong offset;\n\n\t\t\tif (need_swap) {\n\t\t\t\tphdr->p_type = bswap_32(phdr->p_type);\n\t\t\t\tphdr->p_offset = bswap_64(phdr->p_offset);\n\t\t\t\tphdr->p_filesz = bswap_64(phdr->p_filesz);\n\t\t\t}\n\n\t\t\tif (phdr->p_type != PT_NOTE)\n\t\t\t\tcontinue;\n\n\t\t\tbuf_size = phdr->p_filesz;\n\t\t\toffset = phdr->p_offset;\n\t\t\ttmp = realloc(buf, buf_size);\n\t\t\tif (tmp == NULL)\n\t\t\t\tgoto out_free;\n\n\t\t\tbuf = tmp;\n\t\t\tfseek(fp, offset, SEEK_SET);\n\t\t\tif (fread(buf, buf_size, 1, fp) != 1)\n\t\t\t\tgoto out_free;\n\n\t\t\tret = read_build_id(buf, buf_size, bid, need_swap);\n\t\t\tif (ret == 0)\n\t\t\t\tret = bid->size;\n\t\t\tbreak;\n\t\t}\n\t}\nout_free:\n\tfree(buf);\nout:\n\tfclose(fp);\n\treturn ret;\n}\n\nint sysfs__read_build_id(const char *filename, struct build_id *bid)\n{\n\tint fd;\n\tint ret = -1;\n\tstruct stat stbuf;\n\tsize_t buf_size;\n\tvoid *buf;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (fstat(fd, &stbuf) < 0)\n\t\tgoto out;\n\n\tbuf_size = stbuf.st_size;\n\tbuf = malloc(buf_size);\n\tif (buf == NULL)\n\t\tgoto out;\n\n\tif (read(fd, buf, buf_size) != (ssize_t) buf_size)\n\t\tgoto out_free;\n\n\tret = read_build_id(buf, buf_size, bid, false);\nout_free:\n\tfree(buf);\nout:\n\tclose(fd);\n\treturn ret;\n}\n\nint symsrc__init(struct symsrc *ss, struct dso *dso, const char *name,\n\t         enum dso_binary_type type)\n{\n\tint fd = open(name, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto out_errno;\n\n\tss->name = strdup(name);\n\tif (!ss->name)\n\t\tgoto out_close;\n\n\tss->fd = fd;\n\tss->type = type;\n\n\treturn 0;\nout_close:\n\tclose(fd);\nout_errno:\n\tdso->load_errno = errno;\n\treturn -1;\n}\n\nbool symsrc__possibly_runtime(struct symsrc *ss __maybe_unused)\n{\n\t \n\treturn true;\n}\n\nbool symsrc__has_symtab(struct symsrc *ss __maybe_unused)\n{\n\treturn false;\n}\n\nvoid symsrc__destroy(struct symsrc *ss)\n{\n\tzfree(&ss->name);\n\tclose(ss->fd);\n}\n\nint dso__synthesize_plt_symbols(struct dso *dso __maybe_unused,\n\t\t\t\tstruct symsrc *ss __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int fd__is_64_bit(int fd)\n{\n\tu8 e_ident[EI_NIDENT];\n\n\tif (lseek(fd, 0, SEEK_SET))\n\t\treturn -1;\n\n\tif (readn(fd, e_ident, sizeof(e_ident)) != sizeof(e_ident))\n\t\treturn -1;\n\n\tif (memcmp(e_ident, ELFMAG, SELFMAG) ||\n\t    e_ident[EI_VERSION] != EV_CURRENT)\n\t\treturn -1;\n\n\treturn e_ident[EI_CLASS] == ELFCLASS64;\n}\n\nenum dso_type dso__type_fd(int fd)\n{\n\tElf64_Ehdr ehdr;\n\tint ret;\n\n\tret = fd__is_64_bit(fd);\n\tif (ret < 0)\n\t\treturn DSO__TYPE_UNKNOWN;\n\n\tif (ret)\n\t\treturn DSO__TYPE_64BIT;\n\n\tif (readn(fd, &ehdr, sizeof(ehdr)) != sizeof(ehdr))\n\t\treturn DSO__TYPE_UNKNOWN;\n\n\tif (ehdr.e_machine == EM_X86_64)\n\t\treturn DSO__TYPE_X32BIT;\n\n\treturn DSO__TYPE_32BIT;\n}\n\nint dso__load_sym(struct dso *dso, struct map *map __maybe_unused,\n\t\t  struct symsrc *ss,\n\t\t  struct symsrc *runtime_ss __maybe_unused,\n\t\t  int kmodule __maybe_unused)\n{\n\tstruct build_id bid;\n\tint ret;\n\n\tret = fd__is_64_bit(ss->fd);\n\tif (ret >= 0)\n\t\tdso->is_64_bit = ret;\n\n\tif (filename__read_build_id(ss->name, &bid) > 0)\n\t\tdso__set_build_id(dso, &bid);\n\treturn 0;\n}\n\nint file__read_maps(int fd __maybe_unused, bool exe __maybe_unused,\n\t\t    mapfn_t mapfn __maybe_unused, void *data __maybe_unused,\n\t\t    bool *is_64_bit __maybe_unused)\n{\n\treturn -1;\n}\n\nint kcore_extract__create(struct kcore_extract *kce __maybe_unused)\n{\n\treturn -1;\n}\n\nvoid kcore_extract__delete(struct kcore_extract *kce __maybe_unused)\n{\n}\n\nint kcore_copy(const char *from_dir __maybe_unused,\n\t       const char *to_dir __maybe_unused)\n{\n\treturn -1;\n}\n\nvoid symbol__elf_init(void)\n{\n}\n\nchar *dso__demangle_sym(struct dso *dso __maybe_unused,\n\t\t\tint kmodule __maybe_unused,\n\t\t\tconst char *elf_name __maybe_unused)\n{\n\treturn NULL;\n}\n\nbool filename__has_section(const char *filename __maybe_unused, const char *sec __maybe_unused)\n{\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}