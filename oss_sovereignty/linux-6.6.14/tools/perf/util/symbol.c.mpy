{
  "module_name": "symbol.c",
  "hash_id": "e0a122fde6991d35dc84b17c23fd92d5067f736193e6b328398fbdb0ffc61036",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/symbol.c",
  "human_readable_source": "\n#include <dirent.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <linux/capability.h>\n#include <linux/kernel.h>\n#include <linux/mman.h>\n#include <linux/string.h>\n#include <linux/time64.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <inttypes.h>\n#include \"annotate.h\"\n#include \"build-id.h\"\n#include \"cap.h\"\n#include \"dso.h\"\n#include \"util.h\" \n#include \"debug.h\"\n#include \"event.h\"\n#include \"machine.h\"\n#include \"map.h\"\n#include \"symbol.h\"\n#include \"map_symbol.h\"\n#include \"mem-events.h\"\n#include \"symsrc.h\"\n#include \"strlist.h\"\n#include \"intlist.h\"\n#include \"namespaces.h\"\n#include \"header.h\"\n#include \"path.h\"\n#include <linux/ctype.h>\n#include <linux/zalloc.h>\n\n#include <elf.h>\n#include <limits.h>\n#include <symbol/kallsyms.h>\n#include <sys/utsname.h>\n\nstatic int dso__load_kernel_sym(struct dso *dso, struct map *map);\nstatic int dso__load_guest_kernel_sym(struct dso *dso, struct map *map);\nstatic bool symbol__is_idle(const char *name);\n\nint vmlinux_path__nr_entries;\nchar **vmlinux_path;\n\nstruct map_list_node {\n\tstruct list_head node;\n\tstruct map *map;\n};\n\nstruct symbol_conf symbol_conf = {\n\t.nanosecs\t\t= false,\n\t.use_modules\t\t= true,\n\t.try_vmlinux_path\t= true,\n\t.demangle\t\t= true,\n\t.demangle_kernel\t= false,\n\t.cumulate_callchain\t= true,\n\t.time_quantum\t\t= 100 * NSEC_PER_MSEC,  \n\t.show_hist_headers\t= true,\n\t.symfs\t\t\t= \"\",\n\t.event_group\t\t= true,\n\t.inline_name\t\t= true,\n\t.res_sample\t\t= 0,\n};\n\nstatic enum dso_binary_type binary_type_symtab[] = {\n\tDSO_BINARY_TYPE__KALLSYMS,\n\tDSO_BINARY_TYPE__GUEST_KALLSYMS,\n\tDSO_BINARY_TYPE__JAVA_JIT,\n\tDSO_BINARY_TYPE__DEBUGLINK,\n\tDSO_BINARY_TYPE__BUILD_ID_CACHE,\n\tDSO_BINARY_TYPE__BUILD_ID_CACHE_DEBUGINFO,\n\tDSO_BINARY_TYPE__FEDORA_DEBUGINFO,\n\tDSO_BINARY_TYPE__UBUNTU_DEBUGINFO,\n\tDSO_BINARY_TYPE__BUILDID_DEBUGINFO,\n\tDSO_BINARY_TYPE__SYSTEM_PATH_DSO,\n\tDSO_BINARY_TYPE__GUEST_KMODULE,\n\tDSO_BINARY_TYPE__GUEST_KMODULE_COMP,\n\tDSO_BINARY_TYPE__SYSTEM_PATH_KMODULE,\n\tDSO_BINARY_TYPE__SYSTEM_PATH_KMODULE_COMP,\n\tDSO_BINARY_TYPE__OPENEMBEDDED_DEBUGINFO,\n\tDSO_BINARY_TYPE__MIXEDUP_UBUNTU_DEBUGINFO,\n\tDSO_BINARY_TYPE__NOT_FOUND,\n};\n\n#define DSO_BINARY_TYPE__SYMTAB_CNT ARRAY_SIZE(binary_type_symtab)\n\nstatic struct map_list_node *map_list_node__new(void)\n{\n\treturn malloc(sizeof(struct map_list_node));\n}\n\nstatic bool symbol_type__filter(char symbol_type)\n{\n\tsymbol_type = toupper(symbol_type);\n\treturn symbol_type == 'T' || symbol_type == 'W' || symbol_type == 'D' || symbol_type == 'B';\n}\n\nstatic int prefix_underscores_count(const char *str)\n{\n\tconst char *tail = str;\n\n\twhile (*tail == '_')\n\t\ttail++;\n\n\treturn tail - str;\n}\n\nconst char * __weak arch__normalize_symbol_name(const char *name)\n{\n\treturn name;\n}\n\nint __weak arch__compare_symbol_names(const char *namea, const char *nameb)\n{\n\treturn strcmp(namea, nameb);\n}\n\nint __weak arch__compare_symbol_names_n(const char *namea, const char *nameb,\n\t\t\t\t\tunsigned int n)\n{\n\treturn strncmp(namea, nameb, n);\n}\n\nint __weak arch__choose_best_symbol(struct symbol *syma,\n\t\t\t\t    struct symbol *symb __maybe_unused)\n{\n\t \n\tif (strlen(syma->name) >= 3 && !strncmp(syma->name, \"SyS\", 3))\n\t\treturn SYMBOL_B;\n\tif (strlen(syma->name) >= 10 && !strncmp(syma->name, \"compat_SyS\", 10))\n\t\treturn SYMBOL_B;\n\n\treturn SYMBOL_A;\n}\n\nstatic int choose_best_symbol(struct symbol *syma, struct symbol *symb)\n{\n\ts64 a;\n\ts64 b;\n\tsize_t na, nb;\n\n\t \n\ta = syma->end - syma->start;\n\tb = symb->end - symb->start;\n\tif ((b == 0) && (a > 0))\n\t\treturn SYMBOL_A;\n\telse if ((a == 0) && (b > 0))\n\t\treturn SYMBOL_B;\n\n\t \n\ta = syma->binding == STB_WEAK;\n\tb = symb->binding == STB_WEAK;\n\tif (b && !a)\n\t\treturn SYMBOL_A;\n\tif (a && !b)\n\t\treturn SYMBOL_B;\n\n\t \n\ta = syma->binding == STB_GLOBAL;\n\tb = symb->binding == STB_GLOBAL;\n\tif (a && !b)\n\t\treturn SYMBOL_A;\n\tif (b && !a)\n\t\treturn SYMBOL_B;\n\n\t \n\ta = prefix_underscores_count(syma->name);\n\tb = prefix_underscores_count(symb->name);\n\tif (b > a)\n\t\treturn SYMBOL_A;\n\telse if (a > b)\n\t\treturn SYMBOL_B;\n\n\t \n\tna = strlen(syma->name);\n\tnb = strlen(symb->name);\n\tif (na > nb)\n\t\treturn SYMBOL_A;\n\telse if (na < nb)\n\t\treturn SYMBOL_B;\n\n\treturn arch__choose_best_symbol(syma, symb);\n}\n\nvoid symbols__fixup_duplicate(struct rb_root_cached *symbols)\n{\n\tstruct rb_node *nd;\n\tstruct symbol *curr, *next;\n\n\tif (symbol_conf.allow_aliases)\n\t\treturn;\n\n\tnd = rb_first_cached(symbols);\n\n\twhile (nd) {\n\t\tcurr = rb_entry(nd, struct symbol, rb_node);\nagain:\n\t\tnd = rb_next(&curr->rb_node);\n\t\tnext = rb_entry(nd, struct symbol, rb_node);\n\n\t\tif (!nd)\n\t\t\tbreak;\n\n\t\tif (curr->start != next->start)\n\t\t\tcontinue;\n\n\t\tif (choose_best_symbol(curr, next) == SYMBOL_A) {\n\t\t\tif (next->type == STT_GNU_IFUNC)\n\t\t\t\tcurr->ifunc_alias = true;\n\t\t\trb_erase_cached(&next->rb_node, symbols);\n\t\t\tsymbol__delete(next);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tif (curr->type == STT_GNU_IFUNC)\n\t\t\t\tnext->ifunc_alias = true;\n\t\t\tnd = rb_next(&curr->rb_node);\n\t\t\trb_erase_cached(&curr->rb_node, symbols);\n\t\t\tsymbol__delete(curr);\n\t\t}\n\t}\n}\n\n \nvoid symbols__fixup_end(struct rb_root_cached *symbols, bool is_kallsyms)\n{\n\tstruct rb_node *nd, *prevnd = rb_first_cached(symbols);\n\tstruct symbol *curr, *prev;\n\n\tif (prevnd == NULL)\n\t\treturn;\n\n\tcurr = rb_entry(prevnd, struct symbol, rb_node);\n\n\tfor (nd = rb_next(prevnd); nd; nd = rb_next(nd)) {\n\t\tprev = curr;\n\t\tcurr = rb_entry(nd, struct symbol, rb_node);\n\n\t\t \n\t\tif (prev->end == prev->start) {\n\t\t\t \n\t\t\tif (is_kallsyms && (!strchr(prev->name, '[') !=\n\t\t\t\t\t    !strchr(curr->name, '[')))\n\t\t\t\tprev->end = roundup(prev->end + 4096, 4096);\n\t\t\telse\n\t\t\t\tprev->end = curr->start;\n\n\t\t\tpr_debug4(\"%s sym:%s end:%#\" PRIx64 \"\\n\",\n\t\t\t\t  __func__, prev->name, prev->end);\n\t\t}\n\t}\n\n\t \n\tif (curr->end == curr->start)\n\t\tcurr->end = roundup(curr->start, 4096) + 4096;\n}\n\nvoid maps__fixup_end(struct maps *maps)\n{\n\tstruct map_rb_node *prev = NULL, *curr;\n\n\tdown_write(maps__lock(maps));\n\n\tmaps__for_each_entry(maps, curr) {\n\t\tif (prev != NULL && !map__end(prev->map))\n\t\t\tmap__set_end(prev->map, map__start(curr->map));\n\n\t\tprev = curr;\n\t}\n\n\t \n\tif (curr && !map__end(curr->map))\n\t\tmap__set_end(curr->map, ~0ULL);\n\n\tup_write(maps__lock(maps));\n}\n\nstruct symbol *symbol__new(u64 start, u64 len, u8 binding, u8 type, const char *name)\n{\n\tsize_t namelen = strlen(name) + 1;\n\tstruct symbol *sym = calloc(1, (symbol_conf.priv_size +\n\t\t\t\t\tsizeof(*sym) + namelen));\n\tif (sym == NULL)\n\t\treturn NULL;\n\n\tif (symbol_conf.priv_size) {\n\t\tif (symbol_conf.init_annotation) {\n\t\t\tstruct annotation *notes = (void *)sym;\n\t\t\tannotation__init(notes);\n\t\t}\n\t\tsym = ((void *)sym) + symbol_conf.priv_size;\n\t}\n\n\tsym->start   = start;\n\tsym->end     = len ? start + len : start;\n\tsym->type    = type;\n\tsym->binding = binding;\n\tsym->namelen = namelen - 1;\n\n\tpr_debug4(\"%s: %s %#\" PRIx64 \"-%#\" PRIx64 \"\\n\",\n\t\t  __func__, name, start, sym->end);\n\tmemcpy(sym->name, name, namelen);\n\n\treturn sym;\n}\n\nvoid symbol__delete(struct symbol *sym)\n{\n\tif (symbol_conf.priv_size) {\n\t\tif (symbol_conf.init_annotation) {\n\t\t\tstruct annotation *notes = symbol__annotation(sym);\n\n\t\t\tannotation__exit(notes);\n\t\t}\n\t}\n\tfree(((void *)sym) - symbol_conf.priv_size);\n}\n\nvoid symbols__delete(struct rb_root_cached *symbols)\n{\n\tstruct symbol *pos;\n\tstruct rb_node *next = rb_first_cached(symbols);\n\n\twhile (next) {\n\t\tpos = rb_entry(next, struct symbol, rb_node);\n\t\tnext = rb_next(&pos->rb_node);\n\t\trb_erase_cached(&pos->rb_node, symbols);\n\t\tsymbol__delete(pos);\n\t}\n}\n\nvoid __symbols__insert(struct rb_root_cached *symbols,\n\t\t       struct symbol *sym, bool kernel)\n{\n\tstruct rb_node **p = &symbols->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tconst u64 ip = sym->start;\n\tstruct symbol *s;\n\tbool leftmost = true;\n\n\tif (kernel) {\n\t\tconst char *name = sym->name;\n\t\t \n\t\tif (name[0] == '.')\n\t\t\tname++;\n\t\tsym->idle = symbol__is_idle(name);\n\t}\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\ts = rb_entry(parent, struct symbol, rb_node);\n\t\tif (ip < s->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\trb_link_node(&sym->rb_node, parent, p);\n\trb_insert_color_cached(&sym->rb_node, symbols, leftmost);\n}\n\nvoid symbols__insert(struct rb_root_cached *symbols, struct symbol *sym)\n{\n\t__symbols__insert(symbols, sym, false);\n}\n\nstatic struct symbol *symbols__find(struct rb_root_cached *symbols, u64 ip)\n{\n\tstruct rb_node *n;\n\n\tif (symbols == NULL)\n\t\treturn NULL;\n\n\tn = symbols->rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct symbol *s = rb_entry(n, struct symbol, rb_node);\n\n\t\tif (ip < s->start)\n\t\t\tn = n->rb_left;\n\t\telse if (ip > s->end || (ip == s->end && ip != s->start))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn s;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct symbol *symbols__first(struct rb_root_cached *symbols)\n{\n\tstruct rb_node *n = rb_first_cached(symbols);\n\n\tif (n)\n\t\treturn rb_entry(n, struct symbol, rb_node);\n\n\treturn NULL;\n}\n\nstatic struct symbol *symbols__last(struct rb_root_cached *symbols)\n{\n\tstruct rb_node *n = rb_last(&symbols->rb_root);\n\n\tif (n)\n\t\treturn rb_entry(n, struct symbol, rb_node);\n\n\treturn NULL;\n}\n\nstatic struct symbol *symbols__next(struct symbol *sym)\n{\n\tstruct rb_node *n = rb_next(&sym->rb_node);\n\n\tif (n)\n\t\treturn rb_entry(n, struct symbol, rb_node);\n\n\treturn NULL;\n}\n\nstatic int symbols__sort_name_cmp(const void *vlhs, const void *vrhs)\n{\n\tconst struct symbol *lhs = *((const struct symbol **)vlhs);\n\tconst struct symbol *rhs = *((const struct symbol **)vrhs);\n\n\treturn strcmp(lhs->name, rhs->name);\n}\n\nstatic struct symbol **symbols__sort_by_name(struct rb_root_cached *source, size_t *len)\n{\n\tstruct rb_node *nd;\n\tstruct symbol **result;\n\tsize_t i = 0, size = 0;\n\n\tfor (nd = rb_first_cached(source); nd; nd = rb_next(nd))\n\t\tsize++;\n\n\tresult = malloc(sizeof(*result) * size);\n\tif (!result)\n\t\treturn NULL;\n\n\tfor (nd = rb_first_cached(source); nd; nd = rb_next(nd)) {\n\t\tstruct symbol *pos = rb_entry(nd, struct symbol, rb_node);\n\n\t\tresult[i++] = pos;\n\t}\n\tqsort(result, size, sizeof(*result), symbols__sort_name_cmp);\n\t*len = size;\n\treturn result;\n}\n\nint symbol__match_symbol_name(const char *name, const char *str,\n\t\t\t      enum symbol_tag_include includes)\n{\n\tconst char *versioning;\n\n\tif (includes == SYMBOL_TAG_INCLUDE__DEFAULT_ONLY &&\n\t    (versioning = strstr(name, \"@@\"))) {\n\t\tint len = strlen(str);\n\n\t\tif (len < versioning - name)\n\t\t\tlen = versioning - name;\n\n\t\treturn arch__compare_symbol_names_n(name, str, len);\n\t} else\n\t\treturn arch__compare_symbol_names(name, str);\n}\n\nstatic struct symbol *symbols__find_by_name(struct symbol *symbols[],\n\t\t\t\t\t    size_t symbols_len,\n\t\t\t\t\t    const char *name,\n\t\t\t\t\t    enum symbol_tag_include includes,\n\t\t\t\t\t    size_t *found_idx)\n{\n\tsize_t i, lower = 0, upper = symbols_len;\n\tstruct symbol *s = NULL;\n\n\tif (found_idx)\n\t\t*found_idx = SIZE_MAX;\n\n\tif (!symbols_len)\n\t\treturn NULL;\n\n\twhile (lower < upper) {\n\t\tint cmp;\n\n\t\ti = (lower + upper) / 2;\n\t\tcmp = symbol__match_symbol_name(symbols[i]->name, name, includes);\n\n\t\tif (cmp > 0)\n\t\t\tupper = i;\n\t\telse if (cmp < 0)\n\t\t\tlower = i + 1;\n\t\telse {\n\t\t\tif (found_idx)\n\t\t\t\t*found_idx = i;\n\t\t\ts = symbols[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (s && includes != SYMBOL_TAG_INCLUDE__DEFAULT_ONLY) {\n\t\t \n\t\tfor (; i > 0; i--) {\n\t\t\tstruct symbol *tmp = symbols[i - 1];\n\n\t\t\tif (!arch__compare_symbol_names(tmp->name, s->name)) {\n\t\t\t\tif (found_idx)\n\t\t\t\t\t*found_idx = i - 1;\n\t\t\t\ts = tmp;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(!found_idx || !s || s == symbols[*found_idx]);\n\treturn s;\n}\n\nvoid dso__reset_find_symbol_cache(struct dso *dso)\n{\n\tdso->last_find_result.addr   = 0;\n\tdso->last_find_result.symbol = NULL;\n}\n\nvoid dso__insert_symbol(struct dso *dso, struct symbol *sym)\n{\n\t__symbols__insert(&dso->symbols, sym, dso->kernel);\n\n\t \n\tif (dso->last_find_result.addr >= sym->start &&\n\t    (dso->last_find_result.addr < sym->end ||\n\t    sym->start == sym->end)) {\n\t\tdso->last_find_result.symbol = sym;\n\t}\n}\n\nvoid dso__delete_symbol(struct dso *dso, struct symbol *sym)\n{\n\trb_erase_cached(&sym->rb_node, &dso->symbols);\n\tsymbol__delete(sym);\n\tdso__reset_find_symbol_cache(dso);\n}\n\nstruct symbol *dso__find_symbol(struct dso *dso, u64 addr)\n{\n\tif (dso->last_find_result.addr != addr || dso->last_find_result.symbol == NULL) {\n\t\tdso->last_find_result.addr   = addr;\n\t\tdso->last_find_result.symbol = symbols__find(&dso->symbols, addr);\n\t}\n\n\treturn dso->last_find_result.symbol;\n}\n\nstruct symbol *dso__find_symbol_nocache(struct dso *dso, u64 addr)\n{\n\treturn symbols__find(&dso->symbols, addr);\n}\n\nstruct symbol *dso__first_symbol(struct dso *dso)\n{\n\treturn symbols__first(&dso->symbols);\n}\n\nstruct symbol *dso__last_symbol(struct dso *dso)\n{\n\treturn symbols__last(&dso->symbols);\n}\n\nstruct symbol *dso__next_symbol(struct symbol *sym)\n{\n\treturn symbols__next(sym);\n}\n\nstruct symbol *dso__next_symbol_by_name(struct dso *dso, size_t *idx)\n{\n\tif (*idx + 1 >= dso->symbol_names_len)\n\t\treturn NULL;\n\n\t++*idx;\n\treturn dso->symbol_names[*idx];\n}\n\n  \nstruct symbol *dso__find_symbol_by_name(struct dso *dso, const char *name, size_t *idx)\n{\n\tstruct symbol *s = symbols__find_by_name(dso->symbol_names, dso->symbol_names_len,\n\t\t\t\t\t\tname, SYMBOL_TAG_INCLUDE__NONE, idx);\n\tif (!s)\n\t\ts = symbols__find_by_name(dso->symbol_names, dso->symbol_names_len,\n\t\t\t\t\tname, SYMBOL_TAG_INCLUDE__DEFAULT_ONLY, idx);\n\treturn s;\n}\n\nvoid dso__sort_by_name(struct dso *dso)\n{\n\tmutex_lock(&dso->lock);\n\tif (!dso__sorted_by_name(dso)) {\n\t\tsize_t len;\n\n\t\tdso->symbol_names = symbols__sort_by_name(&dso->symbols, &len);\n\t\tif (dso->symbol_names) {\n\t\t\tdso->symbol_names_len = len;\n\t\t\tdso__set_sorted_by_name(dso);\n\t\t}\n\t}\n\tmutex_unlock(&dso->lock);\n}\n\n \nstatic int hex2u64(const char *ptr, u64 *long_val)\n{\n\tchar *p;\n\n\t*long_val = strtoull(ptr, &p, 16);\n\n\treturn p - ptr;\n}\n\n\nint modules__parse(const char *filename, void *arg,\n\t\t   int (*process_module)(void *arg, const char *name,\n\t\t\t\t\t u64 start, u64 size))\n{\n\tchar *line = NULL;\n\tsize_t n;\n\tFILE *file;\n\tint err = 0;\n\n\tfile = fopen(filename, \"r\");\n\tif (file == NULL)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tchar name[PATH_MAX];\n\t\tu64 start, size;\n\t\tchar *sep, *endptr;\n\t\tssize_t line_len;\n\n\t\tline_len = getline(&line, &n, file);\n\t\tif (line_len < 0) {\n\t\t\tif (feof(file))\n\t\t\t\tbreak;\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!line) {\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tline[--line_len] = '\\0';  \n\n\t\tsep = strrchr(line, 'x');\n\t\tif (sep == NULL)\n\t\t\tcontinue;\n\n\t\thex2u64(sep + 1, &start);\n\n\t\tsep = strchr(line, ' ');\n\t\tif (sep == NULL)\n\t\t\tcontinue;\n\n\t\t*sep = '\\0';\n\n\t\tscnprintf(name, sizeof(name), \"[%s]\", line);\n\n\t\tsize = strtoul(sep + 1, &endptr, 0);\n\t\tif (*endptr != ' ' && *endptr != '\\t')\n\t\t\tcontinue;\n\n\t\terr = process_module(arg, name, start, size);\n\t\tif (err)\n\t\t\tbreak;\n\t}\nout:\n\tfree(line);\n\tfclose(file);\n\treturn err;\n}\n\n \nstatic bool symbol__is_idle(const char *name)\n{\n\tconst char * const idle_symbols[] = {\n\t\t\"acpi_idle_do_entry\",\n\t\t\"acpi_processor_ffh_cstate_enter\",\n\t\t\"arch_cpu_idle\",\n\t\t\"cpu_idle\",\n\t\t\"cpu_startup_entry\",\n\t\t\"idle_cpu\",\n\t\t\"intel_idle\",\n\t\t\"default_idle\",\n\t\t\"native_safe_halt\",\n\t\t\"enter_idle\",\n\t\t\"exit_idle\",\n\t\t\"mwait_idle\",\n\t\t\"mwait_idle_with_hints\",\n\t\t\"mwait_idle_with_hints.constprop.0\",\n\t\t\"poll_idle\",\n\t\t\"ppc64_runlatch_off\",\n\t\t\"pseries_dedicated_idle_sleep\",\n\t\t\"psw_idle\",\n\t\t\"psw_idle_exit\",\n\t\tNULL\n\t};\n\tint i;\n\tstatic struct strlist *idle_symbols_list;\n\n\tif (idle_symbols_list)\n\t\treturn strlist__has_entry(idle_symbols_list, name);\n\n\tidle_symbols_list = strlist__new(NULL, NULL);\n\n\tfor (i = 0; idle_symbols[i]; i++)\n\t\tstrlist__add(idle_symbols_list, idle_symbols[i]);\n\n\treturn strlist__has_entry(idle_symbols_list, name);\n}\n\nstatic int map__process_kallsym_symbol(void *arg, const char *name,\n\t\t\t\t       char type, u64 start)\n{\n\tstruct symbol *sym;\n\tstruct dso *dso = arg;\n\tstruct rb_root_cached *root = &dso->symbols;\n\n\tif (!symbol_type__filter(type))\n\t\treturn 0;\n\n\t \n\tif (name[0] == '$')\n\t\treturn 0;\n\n\t \n\tsym = symbol__new(start, 0, kallsyms2elf_binding(type), kallsyms2elf_type(type), name);\n\tif (sym == NULL)\n\t\treturn -ENOMEM;\n\t \n\t__symbols__insert(root, sym, !strchr(name, '['));\n\n\treturn 0;\n}\n\n \nstatic int dso__load_all_kallsyms(struct dso *dso, const char *filename)\n{\n\treturn kallsyms__parse(filename, dso, map__process_kallsym_symbol);\n}\n\nstatic int maps__split_kallsyms_for_kcore(struct maps *kmaps, struct dso *dso)\n{\n\tstruct map *curr_map;\n\tstruct symbol *pos;\n\tint count = 0;\n\tstruct rb_root_cached old_root = dso->symbols;\n\tstruct rb_root_cached *root = &dso->symbols;\n\tstruct rb_node *next = rb_first_cached(root);\n\n\tif (!kmaps)\n\t\treturn -1;\n\n\t*root = RB_ROOT_CACHED;\n\n\twhile (next) {\n\t\tstruct dso *curr_map_dso;\n\t\tchar *module;\n\n\t\tpos = rb_entry(next, struct symbol, rb_node);\n\t\tnext = rb_next(&pos->rb_node);\n\n\t\trb_erase_cached(&pos->rb_node, &old_root);\n\t\tRB_CLEAR_NODE(&pos->rb_node);\n\t\tmodule = strchr(pos->name, '\\t');\n\t\tif (module)\n\t\t\t*module = '\\0';\n\n\t\tcurr_map = maps__find(kmaps, pos->start);\n\n\t\tif (!curr_map) {\n\t\t\tsymbol__delete(pos);\n\t\t\tcontinue;\n\t\t}\n\t\tcurr_map_dso = map__dso(curr_map);\n\t\tpos->start -= map__start(curr_map) - map__pgoff(curr_map);\n\t\tif (pos->end > map__end(curr_map))\n\t\t\tpos->end = map__end(curr_map);\n\t\tif (pos->end)\n\t\t\tpos->end -= map__start(curr_map) - map__pgoff(curr_map);\n\t\tsymbols__insert(&curr_map_dso->symbols, pos);\n\t\t++count;\n\t}\n\n\t \n\tdso->adjust_symbols = 1;\n\n\treturn count;\n}\n\n \nstatic int maps__split_kallsyms(struct maps *kmaps, struct dso *dso, u64 delta,\n\t\t\t\tstruct map *initial_map)\n{\n\tstruct machine *machine;\n\tstruct map *curr_map = initial_map;\n\tstruct symbol *pos;\n\tint count = 0, moved = 0;\n\tstruct rb_root_cached *root = &dso->symbols;\n\tstruct rb_node *next = rb_first_cached(root);\n\tint kernel_range = 0;\n\tbool x86_64;\n\n\tif (!kmaps)\n\t\treturn -1;\n\n\tmachine = maps__machine(kmaps);\n\n\tx86_64 = machine__is(machine, \"x86_64\");\n\n\twhile (next) {\n\t\tchar *module;\n\n\t\tpos = rb_entry(next, struct symbol, rb_node);\n\t\tnext = rb_next(&pos->rb_node);\n\n\t\tmodule = strchr(pos->name, '\\t');\n\t\tif (module) {\n\t\t\tstruct dso *curr_map_dso;\n\n\t\t\tif (!symbol_conf.use_modules)\n\t\t\t\tgoto discard_symbol;\n\n\t\t\t*module++ = '\\0';\n\t\t\tcurr_map_dso = map__dso(curr_map);\n\t\t\tif (strcmp(curr_map_dso->short_name, module)) {\n\t\t\t\tif (RC_CHK_ACCESS(curr_map) != RC_CHK_ACCESS(initial_map) &&\n\t\t\t\t    dso->kernel == DSO_SPACE__KERNEL_GUEST &&\n\t\t\t\t    machine__is_default_guest(machine)) {\n\t\t\t\t\t \n\t\t\t\t\tdso__set_loaded(curr_map_dso);\n\t\t\t\t}\n\n\t\t\t\tcurr_map = maps__find_by_name(kmaps, module);\n\t\t\t\tif (curr_map == NULL) {\n\t\t\t\t\tpr_debug(\"%s/proc/{kallsyms,modules} \"\n\t\t\t\t\t         \"inconsistency while looking \"\n\t\t\t\t\t\t \"for \\\"%s\\\" module!\\n\",\n\t\t\t\t\t\t machine->root_dir, module);\n\t\t\t\t\tcurr_map = initial_map;\n\t\t\t\t\tgoto discard_symbol;\n\t\t\t\t}\n\t\t\t\tcurr_map_dso = map__dso(curr_map);\n\t\t\t\tif (curr_map_dso->loaded &&\n\t\t\t\t    !machine__is_default_guest(machine))\n\t\t\t\t\tgoto discard_symbol;\n\t\t\t}\n\t\t\t \n\t\t\tpos->start = map__map_ip(curr_map, pos->start);\n\t\t\tpos->end   = map__map_ip(curr_map, pos->end);\n\t\t} else if (x86_64 && is_entry_trampoline(pos->name)) {\n\t\t\t \n\t\t\tgoto discard_symbol;\n\t\t} else if (curr_map != initial_map) {\n\t\t\tchar dso_name[PATH_MAX];\n\t\t\tstruct dso *ndso;\n\n\t\t\tif (delta) {\n\t\t\t\t \n\t\t\t\tpos->start -= delta;\n\t\t\t\tpos->end -= delta;\n\t\t\t}\n\n\t\t\tif (count == 0) {\n\t\t\t\tcurr_map = initial_map;\n\t\t\t\tgoto add_symbol;\n\t\t\t}\n\n\t\t\tif (dso->kernel == DSO_SPACE__KERNEL_GUEST)\n\t\t\t\tsnprintf(dso_name, sizeof(dso_name),\n\t\t\t\t\t\"[guest.kernel].%d\",\n\t\t\t\t\tkernel_range++);\n\t\t\telse\n\t\t\t\tsnprintf(dso_name, sizeof(dso_name),\n\t\t\t\t\t\"[kernel].%d\",\n\t\t\t\t\tkernel_range++);\n\n\t\t\tndso = dso__new(dso_name);\n\t\t\tif (ndso == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tndso->kernel = dso->kernel;\n\n\t\t\tcurr_map = map__new2(pos->start, ndso);\n\t\t\tif (curr_map == NULL) {\n\t\t\t\tdso__put(ndso);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tmap__set_map_ip(curr_map, identity__map_ip);\n\t\t\tmap__set_unmap_ip(curr_map, identity__map_ip);\n\t\t\tif (maps__insert(kmaps, curr_map)) {\n\t\t\t\tdso__put(ndso);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t++kernel_range;\n\t\t} else if (delta) {\n\t\t\t \n\t\t\tpos->start -= delta;\n\t\t\tpos->end -= delta;\n\t\t}\nadd_symbol:\n\t\tif (curr_map != initial_map) {\n\t\t\tstruct dso *curr_map_dso = map__dso(curr_map);\n\n\t\t\trb_erase_cached(&pos->rb_node, root);\n\t\t\tsymbols__insert(&curr_map_dso->symbols, pos);\n\t\t\t++moved;\n\t\t} else\n\t\t\t++count;\n\n\t\tcontinue;\ndiscard_symbol:\n\t\trb_erase_cached(&pos->rb_node, root);\n\t\tsymbol__delete(pos);\n\t}\n\n\tif (curr_map != initial_map &&\n\t    dso->kernel == DSO_SPACE__KERNEL_GUEST &&\n\t    machine__is_default_guest(maps__machine(kmaps))) {\n\t\tdso__set_loaded(map__dso(curr_map));\n\t}\n\n\treturn count + moved;\n}\n\nbool symbol__restricted_filename(const char *filename,\n\t\t\t\t const char *restricted_filename)\n{\n\tbool restricted = false;\n\n\tif (symbol_conf.kptr_restrict) {\n\t\tchar *r = realpath(filename, NULL);\n\n\t\tif (r != NULL) {\n\t\t\trestricted = strcmp(r, restricted_filename) == 0;\n\t\t\tfree(r);\n\t\t\treturn restricted;\n\t\t}\n\t}\n\n\treturn restricted;\n}\n\nstruct module_info {\n\tstruct rb_node rb_node;\n\tchar *name;\n\tu64 start;\n};\n\nstatic void add_module(struct module_info *mi, struct rb_root *modules)\n{\n\tstruct rb_node **p = &modules->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct module_info *m;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tm = rb_entry(parent, struct module_info, rb_node);\n\t\tif (strcmp(mi->name, m->name) < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\trb_link_node(&mi->rb_node, parent, p);\n\trb_insert_color(&mi->rb_node, modules);\n}\n\nstatic void delete_modules(struct rb_root *modules)\n{\n\tstruct module_info *mi;\n\tstruct rb_node *next = rb_first(modules);\n\n\twhile (next) {\n\t\tmi = rb_entry(next, struct module_info, rb_node);\n\t\tnext = rb_next(&mi->rb_node);\n\t\trb_erase(&mi->rb_node, modules);\n\t\tzfree(&mi->name);\n\t\tfree(mi);\n\t}\n}\n\nstatic struct module_info *find_module(const char *name,\n\t\t\t\t       struct rb_root *modules)\n{\n\tstruct rb_node *n = modules->rb_node;\n\n\twhile (n) {\n\t\tstruct module_info *m;\n\t\tint cmp;\n\n\t\tm = rb_entry(n, struct module_info, rb_node);\n\t\tcmp = strcmp(name, m->name);\n\t\tif (cmp < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn m;\n\t}\n\n\treturn NULL;\n}\n\nstatic int __read_proc_modules(void *arg, const char *name, u64 start,\n\t\t\t       u64 size __maybe_unused)\n{\n\tstruct rb_root *modules = arg;\n\tstruct module_info *mi;\n\n\tmi = zalloc(sizeof(struct module_info));\n\tif (!mi)\n\t\treturn -ENOMEM;\n\n\tmi->name = strdup(name);\n\tmi->start = start;\n\n\tif (!mi->name) {\n\t\tfree(mi);\n\t\treturn -ENOMEM;\n\t}\n\n\tadd_module(mi, modules);\n\n\treturn 0;\n}\n\nstatic int read_proc_modules(const char *filename, struct rb_root *modules)\n{\n\tif (symbol__restricted_filename(filename, \"/proc/modules\"))\n\t\treturn -1;\n\n\tif (modules__parse(filename, modules, __read_proc_modules)) {\n\t\tdelete_modules(modules);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint compare_proc_modules(const char *from, const char *to)\n{\n\tstruct rb_root from_modules = RB_ROOT;\n\tstruct rb_root to_modules = RB_ROOT;\n\tstruct rb_node *from_node, *to_node;\n\tstruct module_info *from_m, *to_m;\n\tint ret = -1;\n\n\tif (read_proc_modules(from, &from_modules))\n\t\treturn -1;\n\n\tif (read_proc_modules(to, &to_modules))\n\t\tgoto out_delete_from;\n\n\tfrom_node = rb_first(&from_modules);\n\tto_node = rb_first(&to_modules);\n\twhile (from_node) {\n\t\tif (!to_node)\n\t\t\tbreak;\n\n\t\tfrom_m = rb_entry(from_node, struct module_info, rb_node);\n\t\tto_m = rb_entry(to_node, struct module_info, rb_node);\n\n\t\tif (from_m->start != to_m->start ||\n\t\t    strcmp(from_m->name, to_m->name))\n\t\t\tbreak;\n\n\t\tfrom_node = rb_next(from_node);\n\t\tto_node = rb_next(to_node);\n\t}\n\n\tif (!from_node && !to_node)\n\t\tret = 0;\n\n\tdelete_modules(&to_modules);\nout_delete_from:\n\tdelete_modules(&from_modules);\n\n\treturn ret;\n}\n\nstatic int do_validate_kcore_modules(const char *filename, struct maps *kmaps)\n{\n\tstruct rb_root modules = RB_ROOT;\n\tstruct map_rb_node *old_node;\n\tint err;\n\n\terr = read_proc_modules(filename, &modules);\n\tif (err)\n\t\treturn err;\n\n\tmaps__for_each_entry(kmaps, old_node) {\n\t\tstruct map *old_map = old_node->map;\n\t\tstruct module_info *mi;\n\t\tstruct dso *dso;\n\n\t\tif (!__map__is_kmodule(old_map)) {\n\t\t\tcontinue;\n\t\t}\n\t\tdso = map__dso(old_map);\n\t\t \n\t\tmi = find_module(dso->short_name, &modules);\n\t\tif (!mi || mi->start != map__start(old_map)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tdelete_modules(&modules);\n\treturn err;\n}\n\n \nstatic bool filename_from_kallsyms_filename(char *filename,\n\t\t\t\t\t    const char *base_name,\n\t\t\t\t\t    const char *kallsyms_filename)\n{\n\tchar *name;\n\n\tstrcpy(filename, kallsyms_filename);\n\tname = strrchr(filename, '/');\n\tif (!name)\n\t\treturn false;\n\n\tname += 1;\n\n\tif (!strcmp(name, \"kallsyms\")) {\n\t\tstrcpy(name, base_name);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int validate_kcore_modules(const char *kallsyms_filename,\n\t\t\t\t  struct map *map)\n{\n\tstruct maps *kmaps = map__kmaps(map);\n\tchar modules_filename[PATH_MAX];\n\n\tif (!kmaps)\n\t\treturn -EINVAL;\n\n\tif (!filename_from_kallsyms_filename(modules_filename, \"modules\",\n\t\t\t\t\t     kallsyms_filename))\n\t\treturn -EINVAL;\n\n\tif (do_validate_kcore_modules(modules_filename, kmaps))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int validate_kcore_addresses(const char *kallsyms_filename,\n\t\t\t\t    struct map *map)\n{\n\tstruct kmap *kmap = map__kmap(map);\n\n\tif (!kmap)\n\t\treturn -EINVAL;\n\n\tif (kmap->ref_reloc_sym && kmap->ref_reloc_sym->name) {\n\t\tu64 start;\n\n\t\tif (kallsyms__get_function_start(kallsyms_filename,\n\t\t\t\t\t\t kmap->ref_reloc_sym->name, &start))\n\t\t\treturn -ENOENT;\n\t\tif (start != kmap->ref_reloc_sym->addr)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn validate_kcore_modules(kallsyms_filename, map);\n}\n\nstruct kcore_mapfn_data {\n\tstruct dso *dso;\n\tstruct list_head maps;\n};\n\nstatic int kcore_mapfn(u64 start, u64 len, u64 pgoff, void *data)\n{\n\tstruct kcore_mapfn_data *md = data;\n\tstruct map_list_node *list_node = map_list_node__new();\n\n\tif (!list_node)\n\t\treturn -ENOMEM;\n\n\tlist_node->map = map__new2(start, md->dso);\n\tif (!list_node->map) {\n\t\tfree(list_node);\n\t\treturn -ENOMEM;\n\t}\n\n\tmap__set_end(list_node->map, map__start(list_node->map) + len);\n\tmap__set_pgoff(list_node->map, pgoff);\n\n\tlist_add(&list_node->node, &md->maps);\n\n\treturn 0;\n}\n\n \nint maps__merge_in(struct maps *kmaps, struct map *new_map)\n{\n\tstruct map_rb_node *rb_node;\n\tLIST_HEAD(merged);\n\tint err = 0;\n\n\tmaps__for_each_entry(kmaps, rb_node) {\n\t\tstruct map *old_map = rb_node->map;\n\n\t\t \n\t\tif (map__end(new_map) < map__start(old_map) ||\n\t\t    map__start(new_map) >= map__end(old_map))\n\t\t\tcontinue;\n\n\t\tif (map__start(new_map) < map__start(old_map)) {\n\t\t\t \n\t\t\tif (map__end(new_map) < map__end(old_map)) {\n\t\t\t\t \n\t\t\t\tmap__set_end(new_map, map__start(old_map));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstruct map_list_node *m = map_list_node__new();\n\n\t\t\t\tif (!m) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tm->map = map__clone(new_map);\n\t\t\t\tif (!m->map) {\n\t\t\t\t\tfree(m);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tmap__set_end(m->map, map__start(old_map));\n\t\t\t\tlist_add_tail(&m->node, &merged);\n\t\t\t\tmap__add_pgoff(new_map, map__end(old_map) - map__start(new_map));\n\t\t\t\tmap__set_start(new_map, map__end(old_map));\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (map__end(new_map) < map__end(old_map)) {\n\t\t\t\t \n\t\t\t\tmap__put(new_map);\n\t\t\t\tnew_map = NULL;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmap__add_pgoff(new_map, map__end(old_map) - map__start(new_map));\n\t\t\t\tmap__set_start(new_map, map__end(old_map));\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\twhile (!list_empty(&merged)) {\n\t\tstruct map_list_node *old_node;\n\n\t\told_node = list_entry(merged.next, struct map_list_node, node);\n\t\tlist_del_init(&old_node->node);\n\t\tif (!err)\n\t\t\terr = maps__insert(kmaps, old_node->map);\n\t\tmap__put(old_node->map);\n\t\tfree(old_node);\n\t}\n\n\tif (new_map) {\n\t\tif (!err)\n\t\t\terr = maps__insert(kmaps, new_map);\n\t\tmap__put(new_map);\n\t}\n\treturn err;\n}\n\nstatic int dso__load_kcore(struct dso *dso, struct map *map,\n\t\t\t   const char *kallsyms_filename)\n{\n\tstruct maps *kmaps = map__kmaps(map);\n\tstruct kcore_mapfn_data md;\n\tstruct map *replacement_map = NULL;\n\tstruct map_rb_node *old_node, *next;\n\tstruct machine *machine;\n\tbool is_64_bit;\n\tint err, fd;\n\tchar kcore_filename[PATH_MAX];\n\tu64 stext;\n\n\tif (!kmaps)\n\t\treturn -EINVAL;\n\n\tmachine = maps__machine(kmaps);\n\n\t \n\tif (!__map__is_kernel(map))\n\t\treturn -EINVAL;\n\n\tif (!filename_from_kallsyms_filename(kcore_filename, \"kcore\",\n\t\t\t\t\t     kallsyms_filename))\n\t\treturn -EINVAL;\n\n\t \n\tif (validate_kcore_addresses(kallsyms_filename, map))\n\t\treturn -EINVAL;\n\n\tmd.dso = dso;\n\tINIT_LIST_HEAD(&md.maps);\n\n\tfd = open(kcore_filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tpr_debug(\"Failed to open %s. Note /proc/kcore requires CAP_SYS_RAWIO capability to access.\\n\",\n\t\t\t kcore_filename);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = file__read_maps(fd, map__prot(map) & PROT_EXEC, kcore_mapfn, &md,\n\t\t\t      &is_64_bit);\n\tif (err)\n\t\tgoto out_err;\n\tdso->is_64_bit = is_64_bit;\n\n\tif (list_empty(&md.maps)) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\t \n\tmaps__for_each_entry_safe(kmaps, old_node, next) {\n\t\tstruct map *old_map = old_node->map;\n\n\t\t \n\t\tif (old_map != map && !__map__is_bpf_prog(old_map))\n\t\t\tmaps__remove(kmaps, old_map);\n\t}\n\tmachine->trampolines_mapped = false;\n\n\t \n\tif (!kallsyms__get_function_start(kallsyms_filename, \"_stext\", &stext)) {\n\t\tu64 replacement_size = 0;\n\t\tstruct map_list_node *new_node;\n\n\t\tlist_for_each_entry(new_node, &md.maps, node) {\n\t\t\tstruct map *new_map = new_node->map;\n\t\t\tu64 new_size = map__size(new_map);\n\n\t\t\tif (!(stext >= map__start(new_map) && stext < map__end(new_map)))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!replacement_map || new_size < replacement_size) {\n\t\t\t\treplacement_map = new_map;\n\t\t\t\treplacement_size = new_size;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!replacement_map)\n\t\treplacement_map = list_entry(md.maps.next, struct map_list_node, node)->map;\n\n\t \n\twhile (!list_empty(&md.maps)) {\n\t\tstruct map_list_node *new_node = list_entry(md.maps.next, struct map_list_node, node);\n\t\tstruct map *new_map = new_node->map;\n\n\t\tlist_del_init(&new_node->node);\n\n\t\tif (RC_CHK_ACCESS(new_map) == RC_CHK_ACCESS(replacement_map)) {\n\t\t\tstruct map *map_ref;\n\n\t\t\tmap__set_start(map, map__start(new_map));\n\t\t\tmap__set_end(map, map__end(new_map));\n\t\t\tmap__set_pgoff(map, map__pgoff(new_map));\n\t\t\tmap__set_map_ip(map, map__map_ip_ptr(new_map));\n\t\t\tmap__set_unmap_ip(map, map__unmap_ip_ptr(new_map));\n\t\t\t \n\t\t\tmap_ref = map__get(map);\n\t\t\tmaps__remove(kmaps, map_ref);\n\t\t\terr = maps__insert(kmaps, map_ref);\n\t\t\tmap__put(map_ref);\n\t\t\tmap__put(new_map);\n\t\t\tif (err)\n\t\t\t\tgoto out_err;\n\t\t} else {\n\t\t\t \n\t\t\tif (maps__merge_in(kmaps, new_map)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tfree(new_node);\n\t}\n\n\tif (machine__is(machine, \"x86_64\")) {\n\t\tu64 addr;\n\n\t\t \n\t\tif (!kallsyms__get_function_start(kallsyms_filename,\n\t\t\t\t\t\t  ENTRY_TRAMPOLINE_NAME,\n\t\t\t\t\t\t  &addr))\n\t\t\tmachine->trampolines_mapped = true;\n\t}\n\n\t \n\tif (dso->kernel == DSO_SPACE__KERNEL_GUEST)\n\t\tdso->binary_type = DSO_BINARY_TYPE__GUEST_KCORE;\n\telse\n\t\tdso->binary_type = DSO_BINARY_TYPE__KCORE;\n\tdso__set_long_name(dso, strdup(kcore_filename), true);\n\n\tclose(fd);\n\n\tif (map__prot(map) & PROT_EXEC)\n\t\tpr_debug(\"Using %s for kernel object code\\n\", kcore_filename);\n\telse\n\t\tpr_debug(\"Using %s for kernel data\\n\", kcore_filename);\n\n\treturn 0;\n\nout_err:\n\twhile (!list_empty(&md.maps)) {\n\t\tstruct map_list_node *list_node;\n\n\t\tlist_node = list_entry(md.maps.next, struct map_list_node, node);\n\t\tlist_del_init(&list_node->node);\n\t\tmap__zput(list_node->map);\n\t\tfree(list_node);\n\t}\n\tclose(fd);\n\treturn err;\n}\n\n \nstatic int kallsyms__delta(struct kmap *kmap, const char *filename, u64 *delta)\n{\n\tu64 addr;\n\n\tif (!kmap->ref_reloc_sym || !kmap->ref_reloc_sym->name)\n\t\treturn 0;\n\n\tif (kallsyms__get_function_start(filename, kmap->ref_reloc_sym->name, &addr))\n\t\treturn -1;\n\n\t*delta = addr - kmap->ref_reloc_sym->addr;\n\treturn 0;\n}\n\nint __dso__load_kallsyms(struct dso *dso, const char *filename,\n\t\t\t struct map *map, bool no_kcore)\n{\n\tstruct kmap *kmap = map__kmap(map);\n\tu64 delta = 0;\n\n\tif (symbol__restricted_filename(filename, \"/proc/kallsyms\"))\n\t\treturn -1;\n\n\tif (!kmap || !kmap->kmaps)\n\t\treturn -1;\n\n\tif (dso__load_all_kallsyms(dso, filename) < 0)\n\t\treturn -1;\n\n\tif (kallsyms__delta(kmap, filename, &delta))\n\t\treturn -1;\n\n\tsymbols__fixup_end(&dso->symbols, true);\n\tsymbols__fixup_duplicate(&dso->symbols);\n\n\tif (dso->kernel == DSO_SPACE__KERNEL_GUEST)\n\t\tdso->symtab_type = DSO_BINARY_TYPE__GUEST_KALLSYMS;\n\telse\n\t\tdso->symtab_type = DSO_BINARY_TYPE__KALLSYMS;\n\n\tif (!no_kcore && !dso__load_kcore(dso, map, filename))\n\t\treturn maps__split_kallsyms_for_kcore(kmap->kmaps, dso);\n\telse\n\t\treturn maps__split_kallsyms(kmap->kmaps, dso, delta, map);\n}\n\nint dso__load_kallsyms(struct dso *dso, const char *filename,\n\t\t       struct map *map)\n{\n\treturn __dso__load_kallsyms(dso, filename, map, false);\n}\n\nstatic int dso__load_perf_map(const char *map_path, struct dso *dso)\n{\n\tchar *line = NULL;\n\tsize_t n;\n\tFILE *file;\n\tint nr_syms = 0;\n\n\tfile = fopen(map_path, \"r\");\n\tif (file == NULL)\n\t\tgoto out_failure;\n\n\twhile (!feof(file)) {\n\t\tu64 start, size;\n\t\tstruct symbol *sym;\n\t\tint line_len, len;\n\n\t\tline_len = getline(&line, &n, file);\n\t\tif (line_len < 0)\n\t\t\tbreak;\n\n\t\tif (!line)\n\t\t\tgoto out_failure;\n\n\t\tline[--line_len] = '\\0';  \n\n\t\tlen = hex2u64(line, &start);\n\n\t\tlen++;\n\t\tif (len + 2 >= line_len)\n\t\t\tcontinue;\n\n\t\tlen += hex2u64(line + len, &size);\n\n\t\tlen++;\n\t\tif (len + 2 >= line_len)\n\t\t\tcontinue;\n\n\t\tsym = symbol__new(start, size, STB_GLOBAL, STT_FUNC, line + len);\n\n\t\tif (sym == NULL)\n\t\t\tgoto out_delete_line;\n\n\t\tsymbols__insert(&dso->symbols, sym);\n\t\tnr_syms++;\n\t}\n\n\tfree(line);\n\tfclose(file);\n\n\treturn nr_syms;\n\nout_delete_line:\n\tfree(line);\nout_failure:\n\treturn -1;\n}\n\n#ifdef HAVE_LIBBFD_SUPPORT\n#define PACKAGE 'perf'\n#include <bfd.h>\n\nstatic int bfd_symbols__cmpvalue(const void *a, const void *b)\n{\n\tconst asymbol *as = *(const asymbol **)a, *bs = *(const asymbol **)b;\n\n\tif (bfd_asymbol_value(as) != bfd_asymbol_value(bs))\n\t\treturn bfd_asymbol_value(as) - bfd_asymbol_value(bs);\n\n\treturn bfd_asymbol_name(as)[0] - bfd_asymbol_name(bs)[0];\n}\n\nstatic int bfd2elf_binding(asymbol *symbol)\n{\n\tif (symbol->flags & BSF_WEAK)\n\t\treturn STB_WEAK;\n\tif (symbol->flags & BSF_GLOBAL)\n\t\treturn STB_GLOBAL;\n\tif (symbol->flags & BSF_LOCAL)\n\t\treturn STB_LOCAL;\n\treturn -1;\n}\n\nint dso__load_bfd_symbols(struct dso *dso, const char *debugfile)\n{\n\tint err = -1;\n\tlong symbols_size, symbols_count, i;\n\tasection *section;\n\tasymbol **symbols, *sym;\n\tstruct symbol *symbol;\n\tbfd *abfd;\n\tu64 start, len;\n\n\tabfd = bfd_openr(debugfile, NULL);\n\tif (!abfd)\n\t\treturn -1;\n\n\tif (!bfd_check_format(abfd, bfd_object)) {\n\t\tpr_debug2(\"%s: cannot read %s bfd file.\\n\", __func__,\n\t\t\t  dso->long_name);\n\t\tgoto out_close;\n\t}\n\n\tif (bfd_get_flavour(abfd) == bfd_target_elf_flavour)\n\t\tgoto out_close;\n\n\tsymbols_size = bfd_get_symtab_upper_bound(abfd);\n\tif (symbols_size == 0) {\n\t\tbfd_close(abfd);\n\t\treturn 0;\n\t}\n\n\tif (symbols_size < 0)\n\t\tgoto out_close;\n\n\tsymbols = malloc(symbols_size);\n\tif (!symbols)\n\t\tgoto out_close;\n\n\tsymbols_count = bfd_canonicalize_symtab(abfd, symbols);\n\tif (symbols_count < 0)\n\t\tgoto out_free;\n\n\tsection = bfd_get_section_by_name(abfd, \".text\");\n\tif (section) {\n\t\tfor (i = 0; i < symbols_count; ++i) {\n\t\t\tif (!strcmp(bfd_asymbol_name(symbols[i]), \"__ImageBase\") ||\n\t\t\t    !strcmp(bfd_asymbol_name(symbols[i]), \"__image_base__\"))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < symbols_count) {\n\t\t\t \n\t\t\tdso->text_offset = section->vma - (u32)section->vma;\n\t\t\tdso->text_offset += (u32)bfd_asymbol_value(symbols[i]);\n\t\t} else {\n\t\t\tdso->text_offset = section->vma - section->filepos;\n\t\t}\n\t}\n\n\tqsort(symbols, symbols_count, sizeof(asymbol *), bfd_symbols__cmpvalue);\n\n#ifdef bfd_get_section\n#define bfd_asymbol_section bfd_get_section\n#endif\n\tfor (i = 0; i < symbols_count; ++i) {\n\t\tsym = symbols[i];\n\t\tsection = bfd_asymbol_section(sym);\n\t\tif (bfd2elf_binding(sym) < 0)\n\t\t\tcontinue;\n\n\t\twhile (i + 1 < symbols_count &&\n\t\t       bfd_asymbol_section(symbols[i + 1]) == section &&\n\t\t       bfd2elf_binding(symbols[i + 1]) < 0)\n\t\t\ti++;\n\n\t\tif (i + 1 < symbols_count &&\n\t\t    bfd_asymbol_section(symbols[i + 1]) == section)\n\t\t\tlen = symbols[i + 1]->value - sym->value;\n\t\telse\n\t\t\tlen = section->size - sym->value;\n\n\t\tstart = bfd_asymbol_value(sym) - dso->text_offset;\n\t\tsymbol = symbol__new(start, len, bfd2elf_binding(sym), STT_FUNC,\n\t\t\t\t     bfd_asymbol_name(sym));\n\t\tif (!symbol)\n\t\t\tgoto out_free;\n\n\t\tsymbols__insert(&dso->symbols, symbol);\n\t}\n#ifdef bfd_get_section\n#undef bfd_asymbol_section\n#endif\n\n\tsymbols__fixup_end(&dso->symbols, false);\n\tsymbols__fixup_duplicate(&dso->symbols);\n\tdso->adjust_symbols = 1;\n\n\terr = 0;\nout_free:\n\tfree(symbols);\nout_close:\n\tbfd_close(abfd);\n\treturn err;\n}\n#endif\n\nstatic bool dso__is_compatible_symtab_type(struct dso *dso, bool kmod,\n\t\t\t\t\t   enum dso_binary_type type)\n{\n\tswitch (type) {\n\tcase DSO_BINARY_TYPE__JAVA_JIT:\n\tcase DSO_BINARY_TYPE__DEBUGLINK:\n\tcase DSO_BINARY_TYPE__SYSTEM_PATH_DSO:\n\tcase DSO_BINARY_TYPE__FEDORA_DEBUGINFO:\n\tcase DSO_BINARY_TYPE__UBUNTU_DEBUGINFO:\n\tcase DSO_BINARY_TYPE__MIXEDUP_UBUNTU_DEBUGINFO:\n\tcase DSO_BINARY_TYPE__BUILDID_DEBUGINFO:\n\tcase DSO_BINARY_TYPE__OPENEMBEDDED_DEBUGINFO:\n\t\treturn !kmod && dso->kernel == DSO_SPACE__USER;\n\n\tcase DSO_BINARY_TYPE__KALLSYMS:\n\tcase DSO_BINARY_TYPE__VMLINUX:\n\tcase DSO_BINARY_TYPE__KCORE:\n\t\treturn dso->kernel == DSO_SPACE__KERNEL;\n\n\tcase DSO_BINARY_TYPE__GUEST_KALLSYMS:\n\tcase DSO_BINARY_TYPE__GUEST_VMLINUX:\n\tcase DSO_BINARY_TYPE__GUEST_KCORE:\n\t\treturn dso->kernel == DSO_SPACE__KERNEL_GUEST;\n\n\tcase DSO_BINARY_TYPE__GUEST_KMODULE:\n\tcase DSO_BINARY_TYPE__GUEST_KMODULE_COMP:\n\tcase DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE:\n\tcase DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE_COMP:\n\t\t \n\t\treturn kmod && dso->symtab_type == type;\n\n\tcase DSO_BINARY_TYPE__BUILD_ID_CACHE:\n\tcase DSO_BINARY_TYPE__BUILD_ID_CACHE_DEBUGINFO:\n\t\treturn true;\n\n\tcase DSO_BINARY_TYPE__BPF_PROG_INFO:\n\tcase DSO_BINARY_TYPE__BPF_IMAGE:\n\tcase DSO_BINARY_TYPE__OOL:\n\tcase DSO_BINARY_TYPE__NOT_FOUND:\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int dso__find_perf_map(char *filebuf, size_t bufsz,\n\t\t\t      struct nsinfo **nsip)\n{\n\tstruct nscookie nsc;\n\tstruct nsinfo *nsi;\n\tstruct nsinfo *nnsi;\n\tint rc = -1;\n\n\tnsi = *nsip;\n\n\tif (nsinfo__need_setns(nsi)) {\n\t\tsnprintf(filebuf, bufsz, \"/tmp/perf-%d.map\", nsinfo__nstgid(nsi));\n\t\tnsinfo__mountns_enter(nsi, &nsc);\n\t\trc = access(filebuf, R_OK);\n\t\tnsinfo__mountns_exit(&nsc);\n\t\tif (rc == 0)\n\t\t\treturn rc;\n\t}\n\n\tnnsi = nsinfo__copy(nsi);\n\tif (nnsi) {\n\t\tnsinfo__put(nsi);\n\n\t\tnsinfo__clear_need_setns(nnsi);\n\t\tsnprintf(filebuf, bufsz, \"/tmp/perf-%d.map\", nsinfo__tgid(nnsi));\n\t\t*nsip = nnsi;\n\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\nint dso__load(struct dso *dso, struct map *map)\n{\n\tchar *name;\n\tint ret = -1;\n\tu_int i;\n\tstruct machine *machine = NULL;\n\tchar *root_dir = (char *) \"\";\n\tint ss_pos = 0;\n\tstruct symsrc ss_[2];\n\tstruct symsrc *syms_ss = NULL, *runtime_ss = NULL;\n\tbool kmod;\n\tbool perfmap;\n\tstruct build_id bid;\n\tstruct nscookie nsc;\n\tchar newmapname[PATH_MAX];\n\tconst char *map_path = dso->long_name;\n\n\tmutex_lock(&dso->lock);\n\tperfmap = strncmp(dso->name, \"/tmp/perf-\", 10) == 0;\n\tif (perfmap) {\n\t\tif (dso->nsinfo && (dso__find_perf_map(newmapname,\n\t\t    sizeof(newmapname), &dso->nsinfo) == 0)) {\n\t\t\tmap_path = newmapname;\n\t\t}\n\t}\n\n\tnsinfo__mountns_enter(dso->nsinfo, &nsc);\n\n\t \n\tif (dso__loaded(dso)) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tkmod = dso->symtab_type == DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE ||\n\t\tdso->symtab_type == DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE_COMP ||\n\t\tdso->symtab_type == DSO_BINARY_TYPE__GUEST_KMODULE ||\n\t\tdso->symtab_type == DSO_BINARY_TYPE__GUEST_KMODULE_COMP;\n\n\tif (dso->kernel && !kmod) {\n\t\tif (dso->kernel == DSO_SPACE__KERNEL)\n\t\t\tret = dso__load_kernel_sym(dso, map);\n\t\telse if (dso->kernel == DSO_SPACE__KERNEL_GUEST)\n\t\t\tret = dso__load_guest_kernel_sym(dso, map);\n\n\t\tmachine = maps__machine(map__kmaps(map));\n\t\tif (machine__is(machine, \"x86_64\"))\n\t\t\tmachine__map_x86_64_entry_trampolines(machine, dso);\n\t\tgoto out;\n\t}\n\n\tdso->adjust_symbols = 0;\n\n\tif (perfmap) {\n\t\tret = dso__load_perf_map(map_path, dso);\n\t\tdso->symtab_type = ret > 0 ? DSO_BINARY_TYPE__JAVA_JIT :\n\t\t\t\t\t     DSO_BINARY_TYPE__NOT_FOUND;\n\t\tgoto out;\n\t}\n\n\tif (machine)\n\t\troot_dir = machine->root_dir;\n\n\tname = malloc(PATH_MAX);\n\tif (!name)\n\t\tgoto out;\n\n\t \n\tif (!dso->has_build_id &&\n\t    is_regular_file(dso->long_name)) {\n\t    __symbol__join_symfs(name, PATH_MAX, dso->long_name);\n\t\tif (filename__read_build_id(name, &bid) > 0)\n\t\t\tdso__set_build_id(dso, &bid);\n\t}\n\n\t \n\tfor (i = 0; i < DSO_BINARY_TYPE__SYMTAB_CNT; i++) {\n\t\tstruct symsrc *ss = &ss_[ss_pos];\n\t\tbool next_slot = false;\n\t\tbool is_reg;\n\t\tbool nsexit;\n\t\tint bfdrc = -1;\n\t\tint sirc = -1;\n\n\t\tenum dso_binary_type symtab_type = binary_type_symtab[i];\n\n\t\tnsexit = (symtab_type == DSO_BINARY_TYPE__BUILD_ID_CACHE ||\n\t\t    symtab_type == DSO_BINARY_TYPE__BUILD_ID_CACHE_DEBUGINFO);\n\n\t\tif (!dso__is_compatible_symtab_type(dso, kmod, symtab_type))\n\t\t\tcontinue;\n\n\t\tif (dso__read_binary_type_filename(dso, symtab_type,\n\t\t\t\t\t\t   root_dir, name, PATH_MAX))\n\t\t\tcontinue;\n\n\t\tif (nsexit)\n\t\t\tnsinfo__mountns_exit(&nsc);\n\n\t\tis_reg = is_regular_file(name);\n\t\tif (!is_reg && errno == ENOENT && dso->nsinfo) {\n\t\t\tchar *new_name = dso__filename_with_chroot(dso, name);\n\t\t\tif (new_name) {\n\t\t\t\tis_reg = is_regular_file(new_name);\n\t\t\t\tstrlcpy(name, new_name, PATH_MAX);\n\t\t\t\tfree(new_name);\n\t\t\t}\n\t\t}\n\n#ifdef HAVE_LIBBFD_SUPPORT\n\t\tif (is_reg)\n\t\t\tbfdrc = dso__load_bfd_symbols(dso, name);\n#endif\n\t\tif (is_reg && bfdrc < 0)\n\t\t\tsirc = symsrc__init(ss, dso, name, symtab_type);\n\n\t\tif (nsexit)\n\t\t\tnsinfo__mountns_enter(dso->nsinfo, &nsc);\n\n\t\tif (bfdrc == 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!is_reg || sirc < 0)\n\t\t\tcontinue;\n\n\t\tif (!syms_ss && symsrc__has_symtab(ss)) {\n\t\t\tsyms_ss = ss;\n\t\t\tnext_slot = true;\n\t\t\tif (!dso->symsrc_filename)\n\t\t\t\tdso->symsrc_filename = strdup(name);\n\t\t}\n\n\t\tif (!runtime_ss && symsrc__possibly_runtime(ss)) {\n\t\t\truntime_ss = ss;\n\t\t\tnext_slot = true;\n\t\t}\n\n\t\tif (next_slot) {\n\t\t\tss_pos++;\n\n\t\t\tif (syms_ss && runtime_ss)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tsymsrc__destroy(ss);\n\t\t}\n\n\t}\n\n\tif (!runtime_ss && !syms_ss)\n\t\tgoto out_free;\n\n\tif (runtime_ss && !syms_ss) {\n\t\tsyms_ss = runtime_ss;\n\t}\n\n\t \n\tif (!runtime_ss && syms_ss)\n\t\truntime_ss = syms_ss;\n\n\tif (syms_ss)\n\t\tret = dso__load_sym(dso, map, syms_ss, runtime_ss, kmod);\n\telse\n\t\tret = -1;\n\n\tif (ret > 0) {\n\t\tint nr_plt;\n\n\t\tnr_plt = dso__synthesize_plt_symbols(dso, runtime_ss);\n\t\tif (nr_plt > 0)\n\t\t\tret += nr_plt;\n\t}\n\n\tfor (; ss_pos > 0; ss_pos--)\n\t\tsymsrc__destroy(&ss_[ss_pos - 1]);\nout_free:\n\tfree(name);\n\tif (ret < 0 && strstr(dso->name, \" (deleted)\") != NULL)\n\t\tret = 0;\nout:\n\tdso__set_loaded(dso);\n\tmutex_unlock(&dso->lock);\n\tnsinfo__mountns_exit(&nsc);\n\n\treturn ret;\n}\n\nstatic int map__strcmp(const void *a, const void *b)\n{\n\tconst struct map *map_a = *(const struct map **)a;\n\tconst struct map *map_b = *(const struct map **)b;\n\tconst struct dso *dso_a = map__dso(map_a);\n\tconst struct dso *dso_b = map__dso(map_b);\n\tint ret = strcmp(dso_a->short_name, dso_b->short_name);\n\n\tif (ret == 0 && map_a != map_b) {\n\t\t \n\t\tret = (int)map__start(map_a) - (int)map__start(map_b);\n\t\tif (ret == 0)\n\t\t\tret = (int)((intptr_t)map_a - (intptr_t)map_b);\n\t}\n\n\treturn ret;\n}\n\nstatic int map__strcmp_name(const void *name, const void *b)\n{\n\tconst struct dso *dso = map__dso(*(const struct map **)b);\n\n\treturn strcmp(name, dso->short_name);\n}\n\nvoid __maps__sort_by_name(struct maps *maps)\n{\n\tqsort(maps__maps_by_name(maps), maps__nr_maps(maps), sizeof(struct map *), map__strcmp);\n}\n\nstatic int map__groups__sort_by_name_from_rbtree(struct maps *maps)\n{\n\tstruct map_rb_node *rb_node;\n\tstruct map **maps_by_name = realloc(maps__maps_by_name(maps),\n\t\t\t\t\t    maps__nr_maps(maps) * sizeof(struct map *));\n\tint i = 0;\n\n\tif (maps_by_name == NULL)\n\t\treturn -1;\n\n\tup_read(maps__lock(maps));\n\tdown_write(maps__lock(maps));\n\n\tRC_CHK_ACCESS(maps)->maps_by_name = maps_by_name;\n\tRC_CHK_ACCESS(maps)->nr_maps_allocated = maps__nr_maps(maps);\n\n\tmaps__for_each_entry(maps, rb_node)\n\t\tmaps_by_name[i++] = map__get(rb_node->map);\n\n\t__maps__sort_by_name(maps);\n\n\tup_write(maps__lock(maps));\n\tdown_read(maps__lock(maps));\n\n\treturn 0;\n}\n\nstatic struct map *__maps__find_by_name(struct maps *maps, const char *name)\n{\n\tstruct map **mapp;\n\n\tif (maps__maps_by_name(maps) == NULL &&\n\t    map__groups__sort_by_name_from_rbtree(maps))\n\t\treturn NULL;\n\n\tmapp = bsearch(name, maps__maps_by_name(maps), maps__nr_maps(maps),\n\t\t       sizeof(*mapp), map__strcmp_name);\n\tif (mapp)\n\t\treturn *mapp;\n\treturn NULL;\n}\n\nstruct map *maps__find_by_name(struct maps *maps, const char *name)\n{\n\tstruct map_rb_node *rb_node;\n\tstruct map *map;\n\n\tdown_read(maps__lock(maps));\n\n\n\tif (RC_CHK_ACCESS(maps)->last_search_by_name) {\n\t\tconst struct dso *dso = map__dso(RC_CHK_ACCESS(maps)->last_search_by_name);\n\n\t\tif (strcmp(dso->short_name, name) == 0) {\n\t\t\tmap = RC_CHK_ACCESS(maps)->last_search_by_name;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\t \n\tmap = __maps__find_by_name(maps, name);\n\tif (map || maps__maps_by_name(maps) != NULL)\n\t\tgoto out_unlock;\n\n\t \n\tmaps__for_each_entry(maps, rb_node) {\n\t\tstruct dso *dso;\n\n\t\tmap = rb_node->map;\n\t\tdso = map__dso(map);\n\t\tif (strcmp(dso->short_name, name) == 0) {\n\t\t\tRC_CHK_ACCESS(maps)->last_search_by_name = map;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tmap = NULL;\n\nout_unlock:\n\tup_read(maps__lock(maps));\n\treturn map;\n}\n\nint dso__load_vmlinux(struct dso *dso, struct map *map,\n\t\t      const char *vmlinux, bool vmlinux_allocated)\n{\n\tint err = -1;\n\tstruct symsrc ss;\n\tchar symfs_vmlinux[PATH_MAX];\n\tenum dso_binary_type symtab_type;\n\n\tif (vmlinux[0] == '/')\n\t\tsnprintf(symfs_vmlinux, sizeof(symfs_vmlinux), \"%s\", vmlinux);\n\telse\n\t\tsymbol__join_symfs(symfs_vmlinux, vmlinux);\n\n\tif (dso->kernel == DSO_SPACE__KERNEL_GUEST)\n\t\tsymtab_type = DSO_BINARY_TYPE__GUEST_VMLINUX;\n\telse\n\t\tsymtab_type = DSO_BINARY_TYPE__VMLINUX;\n\n\tif (symsrc__init(&ss, dso, symfs_vmlinux, symtab_type))\n\t\treturn -1;\n\n\t \n\tdso__set_long_name(dso, vmlinux, vmlinux_allocated);\n\tif (dso->kernel == DSO_SPACE__KERNEL_GUEST)\n\t\tdso->binary_type = DSO_BINARY_TYPE__GUEST_VMLINUX;\n\telse\n\t\tdso->binary_type = DSO_BINARY_TYPE__VMLINUX;\n\n\terr = dso__load_sym(dso, map, &ss, &ss, 0);\n\tsymsrc__destroy(&ss);\n\n\tif (err > 0) {\n\t\tdso__set_loaded(dso);\n\t\tpr_debug(\"Using %s for symbols\\n\", symfs_vmlinux);\n\t}\n\n\treturn err;\n}\n\nint dso__load_vmlinux_path(struct dso *dso, struct map *map)\n{\n\tint i, err = 0;\n\tchar *filename = NULL;\n\n\tpr_debug(\"Looking at the vmlinux_path (%d entries long)\\n\",\n\t\t vmlinux_path__nr_entries + 1);\n\n\tfor (i = 0; i < vmlinux_path__nr_entries; ++i) {\n\t\terr = dso__load_vmlinux(dso, map, vmlinux_path[i], false);\n\t\tif (err > 0)\n\t\t\tgoto out;\n\t}\n\n\tif (!symbol_conf.ignore_vmlinux_buildid)\n\t\tfilename = dso__build_id_filename(dso, NULL, 0, false);\n\tif (filename != NULL) {\n\t\terr = dso__load_vmlinux(dso, map, filename, true);\n\t\tif (err > 0)\n\t\t\tgoto out;\n\t\tfree(filename);\n\t}\nout:\n\treturn err;\n}\n\nstatic bool visible_dir_filter(const char *name, struct dirent *d)\n{\n\tif (d->d_type != DT_DIR)\n\t\treturn false;\n\treturn lsdir_no_dot_filter(name, d);\n}\n\nstatic int find_matching_kcore(struct map *map, char *dir, size_t dir_sz)\n{\n\tchar kallsyms_filename[PATH_MAX];\n\tint ret = -1;\n\tstruct strlist *dirs;\n\tstruct str_node *nd;\n\n\tdirs = lsdir(dir, visible_dir_filter);\n\tif (!dirs)\n\t\treturn -1;\n\n\tstrlist__for_each_entry(nd, dirs) {\n\t\tscnprintf(kallsyms_filename, sizeof(kallsyms_filename),\n\t\t\t  \"%s/%s/kallsyms\", dir, nd->s);\n\t\tif (!validate_kcore_addresses(kallsyms_filename, map)) {\n\t\t\tstrlcpy(dir, kallsyms_filename, dir_sz);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstrlist__delete(dirs);\n\n\treturn ret;\n}\n\n \nstatic bool filename__readable(const char *file)\n{\n\tint fd = open(file, O_RDONLY);\n\tif (fd < 0)\n\t\treturn false;\n\tclose(fd);\n\treturn true;\n}\n\nstatic char *dso__find_kallsyms(struct dso *dso, struct map *map)\n{\n\tstruct build_id bid;\n\tchar sbuild_id[SBUILD_ID_SIZE];\n\tbool is_host = false;\n\tchar path[PATH_MAX];\n\n\tif (!dso->has_build_id) {\n\t\t \n\t\tgoto proc_kallsyms;\n\t}\n\n\tif (sysfs__read_build_id(\"/sys/kernel/notes\", &bid) == 0)\n\t\tis_host = dso__build_id_equal(dso, &bid);\n\n\t \n\tif (is_host) {\n\t\t \n\t\tif (filename__readable(\"/proc/kcore\") &&\n\t\t    !validate_kcore_addresses(\"/proc/kallsyms\", map))\n\t\t\tgoto proc_kallsyms;\n\t}\n\n\tbuild_id__sprintf(&dso->bid, sbuild_id);\n\n\t \n\tscnprintf(path, sizeof(path), \"%s/%s/%s\",\n\t\t  buildid_dir, DSO__NAME_KCORE, sbuild_id);\n\n\tif (!find_matching_kcore(map, path, sizeof(path)))\n\t\treturn strdup(path);\n\n\t \n\tif (is_host) {\nproc_kallsyms:\n\t\treturn strdup(\"/proc/kallsyms\");\n\t}\n\n\t \n\tif (!build_id_cache__kallsyms_path(sbuild_id, path, sizeof(path))) {\n\t\tpr_err(\"No kallsyms or vmlinux with build-id %s was found\\n\",\n\t\t       sbuild_id);\n\t\treturn NULL;\n\t}\n\n\treturn strdup(path);\n}\n\nstatic int dso__load_kernel_sym(struct dso *dso, struct map *map)\n{\n\tint err;\n\tconst char *kallsyms_filename = NULL;\n\tchar *kallsyms_allocated_filename = NULL;\n\tchar *filename = NULL;\n\n\t \n\tif (symbol_conf.kallsyms_name != NULL) {\n\t\tkallsyms_filename = symbol_conf.kallsyms_name;\n\t\tgoto do_kallsyms;\n\t}\n\n\tif (!symbol_conf.ignore_vmlinux && symbol_conf.vmlinux_name != NULL) {\n\t\treturn dso__load_vmlinux(dso, map, symbol_conf.vmlinux_name, false);\n\t}\n\n\t \n\tif (!symbol_conf.ignore_vmlinux_buildid)\n\t\tfilename = __dso__build_id_filename(dso, NULL, 0, false, false);\n\tif (filename != NULL) {\n\t\terr = dso__load_vmlinux(dso, map, filename, true);\n\t\tif (err > 0)\n\t\t\treturn err;\n\t\tfree(filename);\n\t}\n\n\tif (!symbol_conf.ignore_vmlinux && vmlinux_path != NULL) {\n\t\terr = dso__load_vmlinux_path(dso, map);\n\t\tif (err > 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (symbol_conf.symfs[0] != 0)\n\t\treturn -1;\n\n\tkallsyms_allocated_filename = dso__find_kallsyms(dso, map);\n\tif (!kallsyms_allocated_filename)\n\t\treturn -1;\n\n\tkallsyms_filename = kallsyms_allocated_filename;\n\ndo_kallsyms:\n\terr = dso__load_kallsyms(dso, kallsyms_filename, map);\n\tif (err > 0)\n\t\tpr_debug(\"Using %s for symbols\\n\", kallsyms_filename);\n\tfree(kallsyms_allocated_filename);\n\n\tif (err > 0 && !dso__is_kcore(dso)) {\n\t\tdso->binary_type = DSO_BINARY_TYPE__KALLSYMS;\n\t\tdso__set_long_name(dso, DSO__NAME_KALLSYMS, false);\n\t\tmap__fixup_start(map);\n\t\tmap__fixup_end(map);\n\t}\n\n\treturn err;\n}\n\nstatic int dso__load_guest_kernel_sym(struct dso *dso, struct map *map)\n{\n\tint err;\n\tconst char *kallsyms_filename;\n\tstruct machine *machine = maps__machine(map__kmaps(map));\n\tchar path[PATH_MAX];\n\n\tif (machine->kallsyms_filename) {\n\t\tkallsyms_filename = machine->kallsyms_filename;\n\t} else if (machine__is_default_guest(machine)) {\n\t\t \n\t\tif (symbol_conf.default_guest_vmlinux_name != NULL) {\n\t\t\terr = dso__load_vmlinux(dso, map,\n\t\t\t\t\t\tsymbol_conf.default_guest_vmlinux_name,\n\t\t\t\t\t\tfalse);\n\t\t\treturn err;\n\t\t}\n\n\t\tkallsyms_filename = symbol_conf.default_guest_kallsyms;\n\t\tif (!kallsyms_filename)\n\t\t\treturn -1;\n\t} else {\n\t\tsprintf(path, \"%s/proc/kallsyms\", machine->root_dir);\n\t\tkallsyms_filename = path;\n\t}\n\n\terr = dso__load_kallsyms(dso, kallsyms_filename, map);\n\tif (err > 0)\n\t\tpr_debug(\"Using %s for symbols\\n\", kallsyms_filename);\n\tif (err > 0 && !dso__is_kcore(dso)) {\n\t\tdso->binary_type = DSO_BINARY_TYPE__GUEST_KALLSYMS;\n\t\tdso__set_long_name(dso, machine->mmap_name, false);\n\t\tmap__fixup_start(map);\n\t\tmap__fixup_end(map);\n\t}\n\n\treturn err;\n}\n\nstatic void vmlinux_path__exit(void)\n{\n\twhile (--vmlinux_path__nr_entries >= 0)\n\t\tzfree(&vmlinux_path[vmlinux_path__nr_entries]);\n\tvmlinux_path__nr_entries = 0;\n\n\tzfree(&vmlinux_path);\n}\n\nstatic const char * const vmlinux_paths[] = {\n\t\"vmlinux\",\n\t\"/boot/vmlinux\"\n};\n\nstatic const char * const vmlinux_paths_upd[] = {\n\t\"/boot/vmlinux-%s\",\n\t\"/usr/lib/debug/boot/vmlinux-%s\",\n\t\"/lib/modules/%s/build/vmlinux\",\n\t\"/usr/lib/debug/lib/modules/%s/vmlinux\",\n\t\"/usr/lib/debug/boot/vmlinux-%s.debug\"\n};\n\nstatic int vmlinux_path__add(const char *new_entry)\n{\n\tvmlinux_path[vmlinux_path__nr_entries] = strdup(new_entry);\n\tif (vmlinux_path[vmlinux_path__nr_entries] == NULL)\n\t\treturn -1;\n\t++vmlinux_path__nr_entries;\n\n\treturn 0;\n}\n\nstatic int vmlinux_path__init(struct perf_env *env)\n{\n\tstruct utsname uts;\n\tchar bf[PATH_MAX];\n\tchar *kernel_version;\n\tunsigned int i;\n\n\tvmlinux_path = malloc(sizeof(char *) * (ARRAY_SIZE(vmlinux_paths) +\n\t\t\t      ARRAY_SIZE(vmlinux_paths_upd)));\n\tif (vmlinux_path == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(vmlinux_paths); i++)\n\t\tif (vmlinux_path__add(vmlinux_paths[i]) < 0)\n\t\t\tgoto out_fail;\n\n\t \n\tif (symbol_conf.symfs[0] != 0)\n\t\treturn 0;\n\n\tif (env) {\n\t\tkernel_version = env->os_release;\n\t} else {\n\t\tif (uname(&uts) < 0)\n\t\t\tgoto out_fail;\n\n\t\tkernel_version = uts.release;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(vmlinux_paths_upd); i++) {\n\t\tsnprintf(bf, sizeof(bf), vmlinux_paths_upd[i], kernel_version);\n\t\tif (vmlinux_path__add(bf) < 0)\n\t\t\tgoto out_fail;\n\t}\n\n\treturn 0;\n\nout_fail:\n\tvmlinux_path__exit();\n\treturn -1;\n}\n\nint setup_list(struct strlist **list, const char *list_str,\n\t\t      const char *list_name)\n{\n\tif (list_str == NULL)\n\t\treturn 0;\n\n\t*list = strlist__new(list_str, NULL);\n\tif (!*list) {\n\t\tpr_err(\"problems parsing %s list\\n\", list_name);\n\t\treturn -1;\n\t}\n\n\tsymbol_conf.has_filter = true;\n\treturn 0;\n}\n\nint setup_intlist(struct intlist **list, const char *list_str,\n\t\t  const char *list_name)\n{\n\tif (list_str == NULL)\n\t\treturn 0;\n\n\t*list = intlist__new(list_str);\n\tif (!*list) {\n\t\tpr_err(\"problems parsing %s list\\n\", list_name);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int setup_addrlist(struct intlist **addr_list, struct strlist *sym_list)\n{\n\tstruct str_node *pos, *tmp;\n\tunsigned long val;\n\tchar *sep;\n\tconst char *end;\n\tint i = 0, err;\n\n\t*addr_list = intlist__new(NULL);\n\tif (!*addr_list)\n\t\treturn -1;\n\n\tstrlist__for_each_entry_safe(pos, tmp, sym_list) {\n\t\terrno = 0;\n\t\tval = strtoul(pos->s, &sep, 16);\n\t\tif (errno || (sep == pos->s))\n\t\t\tcontinue;\n\n\t\tif (*sep != '\\0') {\n\t\t\tend = pos->s + strlen(pos->s) - 1;\n\t\t\twhile (end >= sep && isspace(*end))\n\t\t\t\tend--;\n\n\t\t\tif (end >= sep)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr = intlist__add(*addr_list, val);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tstrlist__remove(sym_list, pos);\n\t\ti++;\n\t}\n\n\tif (i == 0) {\n\t\tintlist__delete(*addr_list);\n\t\t*addr_list = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool symbol__read_kptr_restrict(void)\n{\n\tbool value = false;\n\tFILE *fp = fopen(\"/proc/sys/kernel/kptr_restrict\", \"r\");\n\n\tif (fp != NULL) {\n\t\tchar line[8];\n\n\t\tif (fgets(line, sizeof(line), fp) != NULL)\n\t\t\tvalue = perf_cap__capable(CAP_SYSLOG) ?\n\t\t\t\t\t(atoi(line) >= 2) :\n\t\t\t\t\t(atoi(line) != 0);\n\n\t\tfclose(fp);\n\t}\n\n\t \n\tif (perf_event_paranoid() > 1 && !perf_cap__capable(CAP_SYSLOG))\n\t\tvalue = true;\n\n\treturn value;\n}\n\nint symbol__annotation_init(void)\n{\n\tif (symbol_conf.init_annotation)\n\t\treturn 0;\n\n\tif (symbol_conf.initialized) {\n\t\tpr_err(\"Annotation needs to be init before symbol__init()\\n\");\n\t\treturn -1;\n\t}\n\n\tsymbol_conf.priv_size += sizeof(struct annotation);\n\tsymbol_conf.init_annotation = true;\n\treturn 0;\n}\n\nint symbol__init(struct perf_env *env)\n{\n\tconst char *symfs;\n\n\tif (symbol_conf.initialized)\n\t\treturn 0;\n\n\tsymbol_conf.priv_size = PERF_ALIGN(symbol_conf.priv_size, sizeof(u64));\n\n\tsymbol__elf_init();\n\n\tif (symbol_conf.try_vmlinux_path && vmlinux_path__init(env) < 0)\n\t\treturn -1;\n\n\tif (symbol_conf.field_sep && *symbol_conf.field_sep == '.') {\n\t\tpr_err(\"'.' is the only non valid --field-separator argument\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setup_list(&symbol_conf.dso_list,\n\t\t       symbol_conf.dso_list_str, \"dso\") < 0)\n\t\treturn -1;\n\n\tif (setup_list(&symbol_conf.comm_list,\n\t\t       symbol_conf.comm_list_str, \"comm\") < 0)\n\t\tgoto out_free_dso_list;\n\n\tif (setup_intlist(&symbol_conf.pid_list,\n\t\t       symbol_conf.pid_list_str, \"pid\") < 0)\n\t\tgoto out_free_comm_list;\n\n\tif (setup_intlist(&symbol_conf.tid_list,\n\t\t       symbol_conf.tid_list_str, \"tid\") < 0)\n\t\tgoto out_free_pid_list;\n\n\tif (setup_list(&symbol_conf.sym_list,\n\t\t       symbol_conf.sym_list_str, \"symbol\") < 0)\n\t\tgoto out_free_tid_list;\n\n\tif (symbol_conf.sym_list &&\n\t    setup_addrlist(&symbol_conf.addr_list, symbol_conf.sym_list) < 0)\n\t\tgoto out_free_sym_list;\n\n\tif (setup_list(&symbol_conf.bt_stop_list,\n\t\t       symbol_conf.bt_stop_list_str, \"symbol\") < 0)\n\t\tgoto out_free_sym_list;\n\n\t \n\tsymfs = realpath(symbol_conf.symfs, NULL);\n\tif (symfs == NULL)\n\t\tsymfs = symbol_conf.symfs;\n\tif (strcmp(symfs, \"/\") == 0)\n\t\tsymbol_conf.symfs = \"\";\n\tif (symfs != symbol_conf.symfs)\n\t\tfree((void *)symfs);\n\n\tsymbol_conf.kptr_restrict = symbol__read_kptr_restrict();\n\n\tsymbol_conf.initialized = true;\n\treturn 0;\n\nout_free_sym_list:\n\tstrlist__delete(symbol_conf.sym_list);\n\tintlist__delete(symbol_conf.addr_list);\nout_free_tid_list:\n\tintlist__delete(symbol_conf.tid_list);\nout_free_pid_list:\n\tintlist__delete(symbol_conf.pid_list);\nout_free_comm_list:\n\tstrlist__delete(symbol_conf.comm_list);\nout_free_dso_list:\n\tstrlist__delete(symbol_conf.dso_list);\n\treturn -1;\n}\n\nvoid symbol__exit(void)\n{\n\tif (!symbol_conf.initialized)\n\t\treturn;\n\tstrlist__delete(symbol_conf.bt_stop_list);\n\tstrlist__delete(symbol_conf.sym_list);\n\tstrlist__delete(symbol_conf.dso_list);\n\tstrlist__delete(symbol_conf.comm_list);\n\tintlist__delete(symbol_conf.tid_list);\n\tintlist__delete(symbol_conf.pid_list);\n\tintlist__delete(symbol_conf.addr_list);\n\tvmlinux_path__exit();\n\tsymbol_conf.sym_list = symbol_conf.dso_list = symbol_conf.comm_list = NULL;\n\tsymbol_conf.bt_stop_list = NULL;\n\tsymbol_conf.initialized = false;\n}\n\nint symbol__config_symfs(const struct option *opt __maybe_unused,\n\t\t\t const char *dir, int unset __maybe_unused)\n{\n\tchar *bf = NULL;\n\tint ret;\n\n\tsymbol_conf.symfs = strdup(dir);\n\tif (symbol_conf.symfs == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tret = asprintf(&bf, \"%s/%s\", dir, \".debug\");\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\n\tset_buildid_dir(bf);\n\n\tfree(bf);\n\treturn 0;\n}\n\nstruct mem_info *mem_info__get(struct mem_info *mi)\n{\n\tif (mi)\n\t\trefcount_inc(&mi->refcnt);\n\treturn mi;\n}\n\nvoid mem_info__put(struct mem_info *mi)\n{\n\tif (mi && refcount_dec_and_test(&mi->refcnt))\n\t\tfree(mi);\n}\n\nstruct mem_info *mem_info__new(void)\n{\n\tstruct mem_info *mi = zalloc(sizeof(*mi));\n\n\tif (mi)\n\t\trefcount_set(&mi->refcnt, 1);\n\treturn mi;\n}\n\n \nint symbol__validate_sym_arguments(void)\n{\n\tif (symbol_conf.vmlinux_name &&\n\t    access(symbol_conf.vmlinux_name, R_OK)) {\n\t\tpr_err(\"Invalid file: %s\\n\", symbol_conf.vmlinux_name);\n\t\treturn -EINVAL;\n\t}\n\tif (symbol_conf.kallsyms_name &&\n\t    access(symbol_conf.kallsyms_name, R_OK)) {\n\t\tpr_err(\"Invalid file: %s\\n\", symbol_conf.kallsyms_name);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}