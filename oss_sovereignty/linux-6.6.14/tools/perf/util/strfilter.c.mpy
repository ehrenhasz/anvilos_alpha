{
  "module_name": "strfilter.c",
  "hash_id": "e506b7d09cedc587c62b5d44582cf5b3ba84d44c42e10eeea93340d69e982314",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/strfilter.c",
  "human_readable_source": "\n#include \"string2.h\"\n#include \"strfilter.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n\n \nstatic const char *OP_and\t= \"&\";\t \nstatic const char *OP_or\t= \"|\";\t \nstatic const char *OP_not\t= \"!\";\t \n\n#define is_operator(c)\t((c) == '|' || (c) == '&' || (c) == '!')\n#define is_separator(c)\t(is_operator(c) || (c) == '(' || (c) == ')')\n\nstatic void strfilter_node__delete(struct strfilter_node *node)\n{\n\tif (node) {\n\t\tif (node->p && !is_operator(*node->p))\n\t\t\tzfree((char **)&node->p);\n\t\tstrfilter_node__delete(node->l);\n\t\tstrfilter_node__delete(node->r);\n\t\tfree(node);\n\t}\n}\n\nvoid strfilter__delete(struct strfilter *filter)\n{\n\tif (filter) {\n\t\tstrfilter_node__delete(filter->root);\n\t\tfree(filter);\n\t}\n}\n\nstatic const char *get_token(const char *s, const char **e)\n{\n\tconst char *p;\n\n\ts = skip_spaces(s);\n\n\tif (*s == '\\0') {\n\t\tp = s;\n\t\tgoto end;\n\t}\n\n\tp = s + 1;\n\tif (!is_separator(*s)) {\n\t\t \nretry:\n\t\twhile (*p && !is_separator(*p) && !isspace(*p))\n\t\t\tp++;\n\t\t \n\t\tif (*(p - 1) == '\\\\' || (*p == '!' && *(p - 1) == '[')) {\n\t\t\tp++;\n\t\t\tgoto retry;\n\t\t}\n\t}\nend:\n\t*e = p;\n\treturn s;\n}\n\nstatic struct strfilter_node *strfilter_node__alloc(const char *op,\n\t\t\t\t\t\t    struct strfilter_node *l,\n\t\t\t\t\t\t    struct strfilter_node *r)\n{\n\tstruct strfilter_node *node = zalloc(sizeof(*node));\n\n\tif (node) {\n\t\tnode->p = op;\n\t\tnode->l = l;\n\t\tnode->r = r;\n\t}\n\n\treturn node;\n}\n\nstatic struct strfilter_node *strfilter_node__new(const char *s,\n\t\t\t\t\t\t  const char **ep)\n{\n\tstruct strfilter_node root, *cur, *last_op;\n\tconst char *e;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tmemset(&root, 0, sizeof(root));\n\tlast_op = cur = &root;\n\n\ts = get_token(s, &e);\n\twhile (*s != '\\0' && *s != ')') {\n\t\tswitch (*s) {\n\t\tcase '&':\t \n\t\t\tif (!cur->r || !last_op->r)\n\t\t\t\tgoto error;\n\t\t\tcur = strfilter_node__alloc(OP_and, last_op->r, NULL);\n\t\t\tif (!cur)\n\t\t\t\tgoto nomem;\n\t\t\tlast_op->r = cur;\n\t\t\tlast_op = cur;\n\t\t\tbreak;\n\t\tcase '|':\t \n\t\t\tif (!cur->r || !root.r)\n\t\t\t\tgoto error;\n\t\t\tcur = strfilter_node__alloc(OP_or, root.r, NULL);\n\t\t\tif (!cur)\n\t\t\t\tgoto nomem;\n\t\t\troot.r = cur;\n\t\t\tlast_op = cur;\n\t\t\tbreak;\n\t\tcase '!':\t \n\t\t\tif (cur->r)\n\t\t\t\tgoto error;\n\t\t\tcur->r = strfilter_node__alloc(OP_not, NULL, NULL);\n\t\t\tif (!cur->r)\n\t\t\t\tgoto nomem;\n\t\t\tcur = cur->r;\n\t\t\tbreak;\n\t\tcase '(':\t \n\t\t\tif (cur->r)\n\t\t\t\tgoto error;\n\t\t\tcur->r = strfilter_node__new(s + 1, &s);\n\t\t\tif (!s)\n\t\t\t\tgoto nomem;\n\t\t\tif (!cur->r || *s != ')')\n\t\t\t\tgoto error;\n\t\t\te = s + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (cur->r)\n\t\t\t\tgoto error;\n\t\t\tcur->r = strfilter_node__alloc(NULL, NULL, NULL);\n\t\t\tif (!cur->r)\n\t\t\t\tgoto nomem;\n\t\t\tcur->r->p = strndup(s, e - s);\n\t\t\tif (!cur->r->p)\n\t\t\t\tgoto nomem;\n\t\t}\n\t\ts = get_token(e, &e);\n\t}\n\tif (!cur->r)\n\t\tgoto error;\n\t*ep = s;\n\treturn root.r;\nnomem:\n\ts = NULL;\nerror:\n\t*ep = s;\n\tstrfilter_node__delete(root.r);\n\treturn NULL;\n}\n\n \nstruct strfilter *strfilter__new(const char *rules, const char **err)\n{\n\tstruct strfilter *filter = zalloc(sizeof(*filter));\n\tconst char *ep = NULL;\n\n\tif (filter)\n\t\tfilter->root = strfilter_node__new(rules, &ep);\n\n\tif (!filter || !filter->root || *ep != '\\0') {\n\t\tif (err)\n\t\t\t*err = ep;\n\t\tstrfilter__delete(filter);\n\t\tfilter = NULL;\n\t}\n\n\treturn filter;\n}\n\nstatic int strfilter__append(struct strfilter *filter, bool _or,\n\t\t\t     const char *rules, const char **err)\n{\n\tstruct strfilter_node *right, *root;\n\tconst char *ep = NULL;\n\n\tif (!filter || !rules)\n\t\treturn -EINVAL;\n\n\tright = strfilter_node__new(rules, &ep);\n\tif (!right || *ep != '\\0') {\n\t\tif (err)\n\t\t\t*err = ep;\n\t\tgoto error;\n\t}\n\troot = strfilter_node__alloc(_or ? OP_or : OP_and, filter->root, right);\n\tif (!root) {\n\t\tep = NULL;\n\t\tgoto error;\n\t}\n\n\tfilter->root = root;\n\treturn 0;\n\nerror:\n\tstrfilter_node__delete(right);\n\treturn ep ? -EINVAL : -ENOMEM;\n}\n\nint strfilter__or(struct strfilter *filter, const char *rules, const char **err)\n{\n\treturn strfilter__append(filter, true, rules, err);\n}\n\nint strfilter__and(struct strfilter *filter, const char *rules,\n\t\t   const char **err)\n{\n\treturn strfilter__append(filter, false, rules, err);\n}\n\nstatic bool strfilter_node__compare(struct strfilter_node *node,\n\t\t\t\t    const char *str)\n{\n\tif (!node || !node->p)\n\t\treturn false;\n\n\tswitch (*node->p) {\n\tcase '|':\t \n\t\treturn strfilter_node__compare(node->l, str) ||\n\t\t\tstrfilter_node__compare(node->r, str);\n\tcase '&':\t \n\t\treturn strfilter_node__compare(node->l, str) &&\n\t\t\tstrfilter_node__compare(node->r, str);\n\tcase '!':\t \n\t\treturn !strfilter_node__compare(node->r, str);\n\tdefault:\n\t\treturn strglobmatch(str, node->p);\n\t}\n}\n\n \nbool strfilter__compare(struct strfilter *filter, const char *str)\n{\n\tif (!filter)\n\t\treturn false;\n\treturn strfilter_node__compare(filter->root, str);\n}\n\nstatic int strfilter_node__sprint(struct strfilter_node *node, char *buf);\n\n \nstatic int strfilter_node__sprint_pt(struct strfilter_node *node, char *buf)\n{\n\tint len;\n\tint pt = node->r ? 2 : 0;\t \n\n\tif (buf && pt)\n\t\t*buf++ = '(';\n\tlen = strfilter_node__sprint(node, buf);\n\tif (len < 0)\n\t\treturn len;\n\tif (buf && pt)\n\t\t*(buf + len) = ')';\n\treturn len + pt;\n}\n\nstatic int strfilter_node__sprint(struct strfilter_node *node, char *buf)\n{\n\tint len = 0, rlen;\n\n\tif (!node || !node->p)\n\t\treturn -EINVAL;\n\n\tswitch (*node->p) {\n\tcase '|':\n\tcase '&':\n\t\tlen = strfilter_node__sprint_pt(node->l, buf);\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\tfallthrough;\n\tcase '!':\n\t\tif (buf) {\n\t\t\t*(buf + len++) = *node->p;\n\t\t\tbuf += len;\n\t\t} else\n\t\t\tlen++;\n\t\trlen = strfilter_node__sprint_pt(node->r, buf);\n\t\tif (rlen < 0)\n\t\t\treturn rlen;\n\t\tlen += rlen;\n\t\tbreak;\n\tdefault:\n\t\tlen = strlen(node->p);\n\t\tif (buf)\n\t\t\tstrcpy(buf, node->p);\n\t}\n\n\treturn len;\n}\n\nchar *strfilter__string(struct strfilter *filter)\n{\n\tint len;\n\tchar *ret = NULL;\n\n\tlen = strfilter_node__sprint(filter->root, NULL);\n\tif (len < 0)\n\t\treturn NULL;\n\n\tret = malloc(len + 1);\n\tif (ret)\n\t\tstrfilter_node__sprint(filter->root, ret);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}