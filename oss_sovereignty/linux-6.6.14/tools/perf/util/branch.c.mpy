{
  "module_name": "branch.c",
  "hash_id": "6c1311a972f9e578970cacd805f831651d4ce21ea620ea82061bf45b68dac988",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/branch.c",
  "human_readable_source": "#include \"util/map_symbol.h\"\n#include \"util/branch.h\"\n#include <linux/kernel.h>\n\nstatic bool cross_area(u64 addr1, u64 addr2, int size)\n{\n\tu64 align1, align2;\n\n\talign1 = addr1 & ~(size - 1);\n\talign2 = addr2 & ~(size - 1);\n\n\treturn (align1 != align2) ? true : false;\n}\n\n#define AREA_4K\t\t4096\n#define AREA_2M\t\t(2 * 1024 * 1024)\n\nvoid branch_type_count(struct branch_type_stat *st, struct branch_flags *flags,\n\t\t       u64 from, u64 to)\n{\n\tif (flags->type == PERF_BR_UNKNOWN || from == 0)\n\t\treturn;\n\n\tif (flags->type == PERF_BR_EXTEND_ABI)\n\t\tst->new_counts[flags->new_type]++;\n\telse\n\t\tst->counts[flags->type]++;\n\n\tif (flags->type == PERF_BR_COND) {\n\t\tif (to > from)\n\t\t\tst->cond_fwd++;\n\t\telse\n\t\t\tst->cond_bwd++;\n\t}\n\n\tif (cross_area(from, to, AREA_2M))\n\t\tst->cross_2m++;\n\telse if (cross_area(from, to, AREA_4K))\n\t\tst->cross_4k++;\n}\n\nconst char *branch_new_type_name(int new_type)\n{\n\tconst char *branch_new_names[PERF_BR_NEW_MAX] = {\n\t\t\"FAULT_ALGN\",\n\t\t\"FAULT_DATA\",\n\t\t\"FAULT_INST\",\n \n#ifdef __aarch64__\n\t\t\"ARM64_FIQ\",\n\t\t\"ARM64_DEBUG_HALT\",\n\t\t\"ARM64_DEBUG_EXIT\",\n\t\t\"ARM64_DEBUG_INST\",\n\t\t\"ARM64_DEBUG_DATA\"\n#else\n\t\t\"ARCH_1\",\n\t\t\"ARCH_2\",\n\t\t\"ARCH_3\",\n\t\t\"ARCH_4\",\n\t\t\"ARCH_5\"\n#endif\n\t};\n\n\tif (new_type >= 0 && new_type < PERF_BR_NEW_MAX)\n\t\treturn branch_new_names[new_type];\n\n\treturn NULL;\n}\n\nconst char *branch_type_name(int type)\n{\n\tconst char *branch_names[PERF_BR_MAX] = {\n\t\t\"N/A\",\n\t\t\"COND\",\n\t\t\"UNCOND\",\n\t\t\"IND\",\n\t\t\"CALL\",\n\t\t\"IND_CALL\",\n\t\t\"RET\",\n\t\t\"SYSCALL\",\n\t\t\"SYSRET\",\n\t\t\"COND_CALL\",\n\t\t\"COND_RET\",\n\t\t\"ERET\",\n\t\t\"IRQ\",\n\t\t\"SERROR\",\n\t\t\"NO_TX\",\n\t\t\"\", \n\t};\n\n\tif (type >= 0 && type < PERF_BR_MAX)\n\t\treturn branch_names[type];\n\n\treturn NULL;\n}\n\nconst char *get_branch_type(struct branch_entry *e)\n{\n\tif (e->flags.type == PERF_BR_UNKNOWN)\n\t\treturn \"\";\n\n\tif (e->flags.type == PERF_BR_EXTEND_ABI)\n\t\treturn branch_new_type_name(e->flags.new_type);\n\n\treturn branch_type_name(e->flags.type);\n}\n\nvoid branch_type_stat_display(FILE *fp, struct branch_type_stat *st)\n{\n\tu64 total = 0;\n\tint i;\n\n\tfor (i = 0; i < PERF_BR_MAX; i++)\n\t\ttotal += st->counts[i];\n\n\tif (total == 0)\n\t\treturn;\n\n\tfprintf(fp, \"\\n#\");\n\tfprintf(fp, \"\\n# Branch Statistics:\");\n\tfprintf(fp, \"\\n#\");\n\n\tif (st->cond_fwd > 0) {\n\t\tfprintf(fp, \"\\n%8s: %5.1f%%\",\n\t\t\t\"COND_FWD\",\n\t\t\t100.0 * (double)st->cond_fwd / (double)total);\n\t}\n\n\tif (st->cond_bwd > 0) {\n\t\tfprintf(fp, \"\\n%8s: %5.1f%%\",\n\t\t\t\"COND_BWD\",\n\t\t\t100.0 * (double)st->cond_bwd / (double)total);\n\t}\n\n\tif (st->cross_4k > 0) {\n\t\tfprintf(fp, \"\\n%8s: %5.1f%%\",\n\t\t\t\"CROSS_4K\",\n\t\t\t100.0 * (double)st->cross_4k / (double)total);\n\t}\n\n\tif (st->cross_2m > 0) {\n\t\tfprintf(fp, \"\\n%8s: %5.1f%%\",\n\t\t\t\"CROSS_2M\",\n\t\t\t100.0 * (double)st->cross_2m / (double)total);\n\t}\n\n\tfor (i = 0; i < PERF_BR_MAX; i++) {\n\t\tif (st->counts[i] > 0)\n\t\t\tfprintf(fp, \"\\n%8s: %5.1f%%\",\n\t\t\t\tbranch_type_name(i),\n\t\t\t\t100.0 *\n\t\t\t\t(double)st->counts[i] / (double)total);\n\t}\n\n\tfor (i = 0; i < PERF_BR_NEW_MAX; i++) {\n\t\tif (st->new_counts[i] > 0)\n\t\t\tfprintf(fp, \"\\n%8s: %5.1f%%\",\n\t\t\t\tbranch_new_type_name(i),\n\t\t\t\t100.0 *\n\t\t\t\t(double)st->new_counts[i] / (double)total);\n\t}\n\n}\n\nstatic int count_str_scnprintf(int idx, const char *str, char *bf, int size)\n{\n\treturn scnprintf(bf, size, \"%s%s\", (idx) ? \" \" : \" (\", str);\n}\n\nint branch_type_str(struct branch_type_stat *st, char *bf, int size)\n{\n\tint i, j = 0, printed = 0;\n\tu64 total = 0;\n\n\tfor (i = 0; i < PERF_BR_MAX; i++)\n\t\ttotal += st->counts[i];\n\n\tfor (i = 0; i < PERF_BR_NEW_MAX; i++)\n\t\ttotal += st->new_counts[i];\n\n\tif (total == 0)\n\t\treturn 0;\n\n\tif (st->cond_fwd > 0)\n\t\tprinted += count_str_scnprintf(j++, \"COND_FWD\", bf + printed, size - printed);\n\n\tif (st->cond_bwd > 0)\n\t\tprinted += count_str_scnprintf(j++, \"COND_BWD\", bf + printed, size - printed);\n\n\tfor (i = 0; i < PERF_BR_MAX; i++) {\n\t\tif (i == PERF_BR_COND)\n\t\t\tcontinue;\n\n\t\tif (st->counts[i] > 0)\n\t\t\tprinted += count_str_scnprintf(j++, branch_type_name(i), bf + printed, size - printed);\n\t}\n\n\tfor (i = 0; i < PERF_BR_NEW_MAX; i++) {\n\t\tif (st->new_counts[i] > 0)\n\t\t\tprinted += count_str_scnprintf(j++, branch_new_type_name(i), bf + printed, size - printed);\n\t}\n\n\tif (st->cross_4k > 0)\n\t\tprinted += count_str_scnprintf(j++, \"CROSS_4K\", bf + printed, size - printed);\n\n\tif (st->cross_2m > 0)\n\t\tprinted += count_str_scnprintf(j++, \"CROSS_2M\", bf + printed, size - printed);\n\n\treturn printed;\n}\n\nconst char *branch_spec_desc(int spec)\n{\n\tconst char *branch_spec_outcomes[PERF_BR_SPEC_MAX] = {\n\t\t\"N/A\",\n\t\t\"SPEC_WRONG_PATH\",\n\t\t\"NON_SPEC_CORRECT_PATH\",\n\t\t\"SPEC_CORRECT_PATH\",\n\t};\n\n\tif (spec >= 0 && spec < PERF_BR_SPEC_MAX)\n\t\treturn branch_spec_outcomes[spec];\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}