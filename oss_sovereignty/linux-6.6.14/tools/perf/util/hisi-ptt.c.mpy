{
  "module_name": "hisi-ptt.c",
  "hash_id": "a8efccb717583bba31b5c2d48df24d55b42d866a9796a51fbf39e3693de6d66b",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/hisi-ptt.c",
  "human_readable_source": "\n \n\n#include <byteswap.h>\n#include <endian.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/types.h>\n#include <linux/zalloc.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"auxtrace.h\"\n#include \"color.h\"\n#include \"debug.h\"\n#include \"evsel.h\"\n#include \"hisi-ptt.h\"\n#include \"hisi-ptt-decoder/hisi-ptt-pkt-decoder.h\"\n#include \"machine.h\"\n#include \"session.h\"\n#include \"tool.h\"\n#include <internal/lib.h>\n\nstruct hisi_ptt {\n\tstruct auxtrace auxtrace;\n\tu32 auxtrace_type;\n\tstruct perf_session *session;\n\tstruct machine *machine;\n\tu32 pmu_type;\n};\n\nstruct hisi_ptt_queue {\n\tstruct hisi_ptt *ptt;\n\tstruct auxtrace_buffer *buffer;\n};\n\nstatic enum hisi_ptt_pkt_type hisi_ptt_check_packet_type(unsigned char *buf)\n{\n\tuint32_t head = *(uint32_t *)buf;\n\n\tif ((HISI_PTT_8DW_CHECK_MASK & head) == HISI_PTT_IS_8DW_PKT)\n\t\treturn HISI_PTT_8DW_PKT;\n\n\treturn HISI_PTT_4DW_PKT;\n}\n\nstatic void hisi_ptt_dump(struct hisi_ptt *ptt __maybe_unused,\n\t\t\t  unsigned char *buf, size_t len)\n{\n\tconst char *color = PERF_COLOR_BLUE;\n\tenum hisi_ptt_pkt_type type;\n\tsize_t pos = 0;\n\tint pkt_len;\n\n\ttype = hisi_ptt_check_packet_type(buf);\n\tlen = round_down(len, hisi_ptt_pkt_size[type]);\n\tcolor_fprintf(stdout, color, \". ... HISI PTT data: size %zu bytes\\n\",\n\t\t      len);\n\n\twhile (len > 0) {\n\t\tpkt_len = hisi_ptt_pkt_desc(buf, pos, type);\n\t\tif (!pkt_len)\n\t\t\tcolor_fprintf(stdout, color, \" Bad packet!\\n\");\n\n\t\tpos += pkt_len;\n\t\tlen -= pkt_len;\n\t}\n}\n\nstatic void hisi_ptt_dump_event(struct hisi_ptt *ptt, unsigned char *buf,\n\t\t\t\tsize_t len)\n{\n\tprintf(\".\\n\");\n\n\thisi_ptt_dump(ptt, buf, len);\n}\n\nstatic int hisi_ptt_process_event(struct perf_session *session __maybe_unused,\n\t\t\t\t  union perf_event *event __maybe_unused,\n\t\t\t\t  struct perf_sample *sample __maybe_unused,\n\t\t\t\t  struct perf_tool *tool __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int hisi_ptt_process_auxtrace_event(struct perf_session *session,\n\t\t\t\t\t   union perf_event *event,\n\t\t\t\t\t   struct perf_tool *tool __maybe_unused)\n{\n\tstruct hisi_ptt *ptt = container_of(session->auxtrace, struct hisi_ptt,\n\t\t\t\t\t    auxtrace);\n\tint fd = perf_data__fd(session->data);\n\tint size = event->auxtrace.size;\n\tvoid *data = malloc(size);\n\toff_t data_offset;\n\tint err;\n\n\tif (!data)\n\t\treturn -errno;\n\n\tif (perf_data__is_pipe(session->data)) {\n\t\tdata_offset = 0;\n\t} else {\n\t\tdata_offset = lseek(fd, 0, SEEK_CUR);\n\t\tif (data_offset == -1)\n\t\t\treturn -errno;\n\t}\n\n\terr = readn(fd, data, size);\n\tif (err != (ssize_t)size) {\n\t\tfree(data);\n\t\treturn -errno;\n\t}\n\n\tif (dump_trace)\n\t\thisi_ptt_dump_event(ptt, data, size);\n\n\tfree(data);\n\treturn 0;\n}\n\nstatic int hisi_ptt_flush(struct perf_session *session __maybe_unused,\n\t\t\t  struct perf_tool *tool __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic void hisi_ptt_free_events(struct perf_session *session __maybe_unused)\n{\n}\n\nstatic void hisi_ptt_free(struct perf_session *session)\n{\n\tstruct hisi_ptt *ptt = container_of(session->auxtrace, struct hisi_ptt,\n\t\t\t\t\t    auxtrace);\n\n\tsession->auxtrace = NULL;\n\tfree(ptt);\n}\n\nstatic bool hisi_ptt_evsel_is_auxtrace(struct perf_session *session,\n\t\t\t\t       struct evsel *evsel)\n{\n\tstruct hisi_ptt *ptt = container_of(session->auxtrace, struct hisi_ptt, auxtrace);\n\n\treturn evsel->core.attr.type == ptt->pmu_type;\n}\n\nstatic void hisi_ptt_print_info(__u64 type)\n{\n\tif (!dump_trace)\n\t\treturn;\n\n\tfprintf(stdout, \"  PMU Type           %\" PRId64 \"\\n\", (s64) type);\n}\n\nint hisi_ptt_process_auxtrace_info(union perf_event *event,\n\t\t\t\t   struct perf_session *session)\n{\n\tstruct perf_record_auxtrace_info *auxtrace_info = &event->auxtrace_info;\n\tstruct hisi_ptt *ptt;\n\n\tif (auxtrace_info->header.size < HISI_PTT_AUXTRACE_PRIV_SIZE +\n\t\t\t\tsizeof(struct perf_record_auxtrace_info))\n\t\treturn -EINVAL;\n\n\tptt = zalloc(sizeof(*ptt));\n\tif (!ptt)\n\t\treturn -ENOMEM;\n\n\tptt->session = session;\n\tptt->machine = &session->machines.host;  \n\tptt->auxtrace_type = auxtrace_info->type;\n\tptt->pmu_type = auxtrace_info->priv[0];\n\n\tptt->auxtrace.process_event = hisi_ptt_process_event;\n\tptt->auxtrace.process_auxtrace_event = hisi_ptt_process_auxtrace_event;\n\tptt->auxtrace.flush_events = hisi_ptt_flush;\n\tptt->auxtrace.free_events = hisi_ptt_free_events;\n\tptt->auxtrace.free = hisi_ptt_free;\n\tptt->auxtrace.evsel_is_auxtrace = hisi_ptt_evsel_is_auxtrace;\n\tsession->auxtrace = &ptt->auxtrace;\n\n\thisi_ptt_print_info(auxtrace_info->priv[0]);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}