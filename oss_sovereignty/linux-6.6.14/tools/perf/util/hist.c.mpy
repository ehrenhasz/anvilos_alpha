{
  "module_name": "hist.c",
  "hash_id": "e29c1087e282b1a29035e4fd6d40877b3894e565c1dbbbe10f804ac9d4dd6cb0",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/hist.c",
  "human_readable_source": "\n#include \"callchain.h\"\n#include \"debug.h\"\n#include \"dso.h\"\n#include \"build-id.h\"\n#include \"hist.h\"\n#include \"kvm-stat.h\"\n#include \"map.h\"\n#include \"map_symbol.h\"\n#include \"branch.h\"\n#include \"mem-events.h\"\n#include \"session.h\"\n#include \"namespaces.h\"\n#include \"cgroup.h\"\n#include \"sort.h\"\n#include \"units.h\"\n#include \"evlist.h\"\n#include \"evsel.h\"\n#include \"annotate.h\"\n#include \"srcline.h\"\n#include \"symbol.h\"\n#include \"thread.h\"\n#include \"block-info.h\"\n#include \"ui/progress.h\"\n#include <errno.h>\n#include <math.h>\n#include <inttypes.h>\n#include <sys/param.h>\n#include <linux/rbtree.h>\n#include <linux/string.h>\n#include <linux/time64.h>\n#include <linux/zalloc.h>\n\nstatic bool hists__filter_entry_by_dso(struct hists *hists,\n\t\t\t\t       struct hist_entry *he);\nstatic bool hists__filter_entry_by_thread(struct hists *hists,\n\t\t\t\t\t  struct hist_entry *he);\nstatic bool hists__filter_entry_by_symbol(struct hists *hists,\n\t\t\t\t\t  struct hist_entry *he);\nstatic bool hists__filter_entry_by_socket(struct hists *hists,\n\t\t\t\t\t  struct hist_entry *he);\n\nu16 hists__col_len(struct hists *hists, enum hist_column col)\n{\n\treturn hists->col_len[col];\n}\n\nvoid hists__set_col_len(struct hists *hists, enum hist_column col, u16 len)\n{\n\thists->col_len[col] = len;\n}\n\nbool hists__new_col_len(struct hists *hists, enum hist_column col, u16 len)\n{\n\tif (len > hists__col_len(hists, col)) {\n\t\thists__set_col_len(hists, col, len);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid hists__reset_col_len(struct hists *hists)\n{\n\tenum hist_column col;\n\n\tfor (col = 0; col < HISTC_NR_COLS; ++col)\n\t\thists__set_col_len(hists, col, 0);\n}\n\nstatic void hists__set_unres_dso_col_len(struct hists *hists, int dso)\n{\n\tconst unsigned int unresolved_col_width = BITS_PER_LONG / 4;\n\n\tif (hists__col_len(hists, dso) < unresolved_col_width &&\n\t    !symbol_conf.col_width_list_str && !symbol_conf.field_sep &&\n\t    !symbol_conf.dso_list)\n\t\thists__set_col_len(hists, dso, unresolved_col_width);\n}\n\nvoid hists__calc_col_len(struct hists *hists, struct hist_entry *h)\n{\n\tconst unsigned int unresolved_col_width = BITS_PER_LONG / 4;\n\tint symlen;\n\tu16 len;\n\n\tif (h->block_info)\n\t\treturn;\n\t \n\tif (h->ms.sym) {\n\t\tsymlen = h->ms.sym->namelen + 4;\n\t\tif (verbose > 0)\n\t\t\tsymlen += BITS_PER_LONG / 4 + 2 + 3;\n\t\thists__new_col_len(hists, HISTC_SYMBOL, symlen);\n\t} else {\n\t\tsymlen = unresolved_col_width + 4 + 2;\n\t\thists__new_col_len(hists, HISTC_SYMBOL, symlen);\n\t\thists__set_unres_dso_col_len(hists, HISTC_DSO);\n\t}\n\n\tlen = thread__comm_len(h->thread);\n\tif (hists__new_col_len(hists, HISTC_COMM, len))\n\t\thists__set_col_len(hists, HISTC_THREAD, len + 8);\n\n\tif (h->ms.map) {\n\t\tlen = dso__name_len(map__dso(h->ms.map));\n\t\thists__new_col_len(hists, HISTC_DSO, len);\n\t}\n\n\tif (h->parent)\n\t\thists__new_col_len(hists, HISTC_PARENT, h->parent->namelen);\n\n\tif (h->branch_info) {\n\t\tif (h->branch_info->from.ms.sym) {\n\t\t\tsymlen = (int)h->branch_info->from.ms.sym->namelen + 4;\n\t\t\tif (verbose > 0)\n\t\t\t\tsymlen += BITS_PER_LONG / 4 + 2 + 3;\n\t\t\thists__new_col_len(hists, HISTC_SYMBOL_FROM, symlen);\n\n\t\t\tsymlen = dso__name_len(map__dso(h->branch_info->from.ms.map));\n\t\t\thists__new_col_len(hists, HISTC_DSO_FROM, symlen);\n\t\t} else {\n\t\t\tsymlen = unresolved_col_width + 4 + 2;\n\t\t\thists__new_col_len(hists, HISTC_SYMBOL_FROM, symlen);\n\t\t\thists__new_col_len(hists, HISTC_ADDR_FROM, symlen);\n\t\t\thists__set_unres_dso_col_len(hists, HISTC_DSO_FROM);\n\t\t}\n\n\t\tif (h->branch_info->to.ms.sym) {\n\t\t\tsymlen = (int)h->branch_info->to.ms.sym->namelen + 4;\n\t\t\tif (verbose > 0)\n\t\t\t\tsymlen += BITS_PER_LONG / 4 + 2 + 3;\n\t\t\thists__new_col_len(hists, HISTC_SYMBOL_TO, symlen);\n\n\t\t\tsymlen = dso__name_len(map__dso(h->branch_info->to.ms.map));\n\t\t\thists__new_col_len(hists, HISTC_DSO_TO, symlen);\n\t\t} else {\n\t\t\tsymlen = unresolved_col_width + 4 + 2;\n\t\t\thists__new_col_len(hists, HISTC_SYMBOL_TO, symlen);\n\t\t\thists__new_col_len(hists, HISTC_ADDR_TO, symlen);\n\t\t\thists__set_unres_dso_col_len(hists, HISTC_DSO_TO);\n\t\t}\n\n\t\tif (h->branch_info->srcline_from)\n\t\t\thists__new_col_len(hists, HISTC_SRCLINE_FROM,\n\t\t\t\t\tstrlen(h->branch_info->srcline_from));\n\t\tif (h->branch_info->srcline_to)\n\t\t\thists__new_col_len(hists, HISTC_SRCLINE_TO,\n\t\t\t\t\tstrlen(h->branch_info->srcline_to));\n\t}\n\n\tif (h->mem_info) {\n\t\tif (h->mem_info->daddr.ms.sym) {\n\t\t\tsymlen = (int)h->mem_info->daddr.ms.sym->namelen + 4\n\t\t\t       + unresolved_col_width + 2;\n\t\t\thists__new_col_len(hists, HISTC_MEM_DADDR_SYMBOL,\n\t\t\t\t\t   symlen);\n\t\t\thists__new_col_len(hists, HISTC_MEM_DCACHELINE,\n\t\t\t\t\t   symlen + 1);\n\t\t} else {\n\t\t\tsymlen = unresolved_col_width + 4 + 2;\n\t\t\thists__new_col_len(hists, HISTC_MEM_DADDR_SYMBOL,\n\t\t\t\t\t   symlen);\n\t\t\thists__new_col_len(hists, HISTC_MEM_DCACHELINE,\n\t\t\t\t\t   symlen);\n\t\t}\n\n\t\tif (h->mem_info->iaddr.ms.sym) {\n\t\t\tsymlen = (int)h->mem_info->iaddr.ms.sym->namelen + 4\n\t\t\t       + unresolved_col_width + 2;\n\t\t\thists__new_col_len(hists, HISTC_MEM_IADDR_SYMBOL,\n\t\t\t\t\t   symlen);\n\t\t} else {\n\t\t\tsymlen = unresolved_col_width + 4 + 2;\n\t\t\thists__new_col_len(hists, HISTC_MEM_IADDR_SYMBOL,\n\t\t\t\t\t   symlen);\n\t\t}\n\n\t\tif (h->mem_info->daddr.ms.map) {\n\t\t\tsymlen = dso__name_len(map__dso(h->mem_info->daddr.ms.map));\n\t\t\thists__new_col_len(hists, HISTC_MEM_DADDR_DSO,\n\t\t\t\t\t   symlen);\n\t\t} else {\n\t\t\tsymlen = unresolved_col_width + 4 + 2;\n\t\t\thists__set_unres_dso_col_len(hists, HISTC_MEM_DADDR_DSO);\n\t\t}\n\n\t\thists__new_col_len(hists, HISTC_MEM_PHYS_DADDR,\n\t\t\t\t   unresolved_col_width + 4 + 2);\n\n\t\thists__new_col_len(hists, HISTC_MEM_DATA_PAGE_SIZE,\n\t\t\t\t   unresolved_col_width + 4 + 2);\n\n\t} else {\n\t\tsymlen = unresolved_col_width + 4 + 2;\n\t\thists__new_col_len(hists, HISTC_MEM_DADDR_SYMBOL, symlen);\n\t\thists__new_col_len(hists, HISTC_MEM_IADDR_SYMBOL, symlen);\n\t\thists__set_unres_dso_col_len(hists, HISTC_MEM_DADDR_DSO);\n\t}\n\n\thists__new_col_len(hists, HISTC_CGROUP, 6);\n\thists__new_col_len(hists, HISTC_CGROUP_ID, 20);\n\thists__new_col_len(hists, HISTC_CPU, 3);\n\thists__new_col_len(hists, HISTC_SOCKET, 6);\n\thists__new_col_len(hists, HISTC_MEM_LOCKED, 6);\n\thists__new_col_len(hists, HISTC_MEM_TLB, 22);\n\thists__new_col_len(hists, HISTC_MEM_SNOOP, 12);\n\thists__new_col_len(hists, HISTC_MEM_LVL, 36 + 3);\n\thists__new_col_len(hists, HISTC_LOCAL_WEIGHT, 12);\n\thists__new_col_len(hists, HISTC_GLOBAL_WEIGHT, 12);\n\thists__new_col_len(hists, HISTC_MEM_BLOCKED, 10);\n\thists__new_col_len(hists, HISTC_LOCAL_INS_LAT, 13);\n\thists__new_col_len(hists, HISTC_GLOBAL_INS_LAT, 13);\n\thists__new_col_len(hists, HISTC_LOCAL_P_STAGE_CYC, 13);\n\thists__new_col_len(hists, HISTC_GLOBAL_P_STAGE_CYC, 13);\n\thists__new_col_len(hists, HISTC_ADDR, BITS_PER_LONG / 4 + 2);\n\n\tif (symbol_conf.nanosecs)\n\t\thists__new_col_len(hists, HISTC_TIME, 16);\n\telse\n\t\thists__new_col_len(hists, HISTC_TIME, 12);\n\thists__new_col_len(hists, HISTC_CODE_PAGE_SIZE, 6);\n\n\tif (h->srcline) {\n\t\tlen = MAX(strlen(h->srcline), strlen(sort_srcline.se_header));\n\t\thists__new_col_len(hists, HISTC_SRCLINE, len);\n\t}\n\n\tif (h->srcfile)\n\t\thists__new_col_len(hists, HISTC_SRCFILE, strlen(h->srcfile));\n\n\tif (h->transaction)\n\t\thists__new_col_len(hists, HISTC_TRANSACTION,\n\t\t\t\t   hist_entry__transaction_len());\n\n\tif (h->trace_output)\n\t\thists__new_col_len(hists, HISTC_TRACE, strlen(h->trace_output));\n\n\tif (h->cgroup) {\n\t\tconst char *cgrp_name = \"unknown\";\n\t\tstruct cgroup *cgrp = cgroup__find(maps__machine(h->ms.maps)->env,\n\t\t\t\t\t\t   h->cgroup);\n\t\tif (cgrp != NULL)\n\t\t\tcgrp_name = cgrp->name;\n\n\t\thists__new_col_len(hists, HISTC_CGROUP, strlen(cgrp_name));\n\t}\n}\n\nvoid hists__output_recalc_col_len(struct hists *hists, int max_rows)\n{\n\tstruct rb_node *next = rb_first_cached(&hists->entries);\n\tstruct hist_entry *n;\n\tint row = 0;\n\n\thists__reset_col_len(hists);\n\n\twhile (next && row++ < max_rows) {\n\t\tn = rb_entry(next, struct hist_entry, rb_node);\n\t\tif (!n->filtered)\n\t\t\thists__calc_col_len(hists, n);\n\t\tnext = rb_next(&n->rb_node);\n\t}\n}\n\nstatic void he_stat__add_cpumode_period(struct he_stat *he_stat,\n\t\t\t\t\tunsigned int cpumode, u64 period)\n{\n\tswitch (cpumode) {\n\tcase PERF_RECORD_MISC_KERNEL:\n\t\the_stat->period_sys += period;\n\t\tbreak;\n\tcase PERF_RECORD_MISC_USER:\n\t\the_stat->period_us += period;\n\t\tbreak;\n\tcase PERF_RECORD_MISC_GUEST_KERNEL:\n\t\the_stat->period_guest_sys += period;\n\t\tbreak;\n\tcase PERF_RECORD_MISC_GUEST_USER:\n\t\the_stat->period_guest_us += period;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic long hist_time(unsigned long htime)\n{\n\tunsigned long time_quantum = symbol_conf.time_quantum;\n\tif (time_quantum)\n\t\treturn (htime / time_quantum) * time_quantum;\n\treturn htime;\n}\n\nstatic void he_stat__add_period(struct he_stat *he_stat, u64 period)\n{\n\the_stat->period\t\t+= period;\n\the_stat->nr_events\t+= 1;\n}\n\nstatic void he_stat__add_stat(struct he_stat *dest, struct he_stat *src)\n{\n\tdest->period\t\t+= src->period;\n\tdest->period_sys\t+= src->period_sys;\n\tdest->period_us\t\t+= src->period_us;\n\tdest->period_guest_sys\t+= src->period_guest_sys;\n\tdest->period_guest_us\t+= src->period_guest_us;\n\tdest->nr_events\t\t+= src->nr_events;\n}\n\nstatic void he_stat__decay(struct he_stat *he_stat)\n{\n\the_stat->period = (he_stat->period * 7) / 8;\n\the_stat->nr_events = (he_stat->nr_events * 7) / 8;\n\t \n}\n\nstatic void hists__delete_entry(struct hists *hists, struct hist_entry *he);\n\nstatic bool hists__decay_entry(struct hists *hists, struct hist_entry *he)\n{\n\tu64 prev_period = he->stat.period;\n\tu64 diff;\n\n\tif (prev_period == 0)\n\t\treturn true;\n\n\the_stat__decay(&he->stat);\n\tif (symbol_conf.cumulate_callchain)\n\t\the_stat__decay(he->stat_acc);\n\tdecay_callchain(he->callchain);\n\n\tdiff = prev_period - he->stat.period;\n\n\tif (!he->depth) {\n\t\thists->stats.total_period -= diff;\n\t\tif (!he->filtered)\n\t\t\thists->stats.total_non_filtered_period -= diff;\n\t}\n\n\tif (!he->leaf) {\n\t\tstruct hist_entry *child;\n\t\tstruct rb_node *node = rb_first_cached(&he->hroot_out);\n\t\twhile (node) {\n\t\t\tchild = rb_entry(node, struct hist_entry, rb_node);\n\t\t\tnode = rb_next(node);\n\n\t\t\tif (hists__decay_entry(hists, child))\n\t\t\t\thists__delete_entry(hists, child);\n\t\t}\n\t}\n\n\treturn he->stat.period == 0;\n}\n\nstatic void hists__delete_entry(struct hists *hists, struct hist_entry *he)\n{\n\tstruct rb_root_cached *root_in;\n\tstruct rb_root_cached *root_out;\n\n\tif (he->parent_he) {\n\t\troot_in  = &he->parent_he->hroot_in;\n\t\troot_out = &he->parent_he->hroot_out;\n\t} else {\n\t\tif (hists__has(hists, need_collapse))\n\t\t\troot_in = &hists->entries_collapsed;\n\t\telse\n\t\t\troot_in = hists->entries_in;\n\t\troot_out = &hists->entries;\n\t}\n\n\trb_erase_cached(&he->rb_node_in, root_in);\n\trb_erase_cached(&he->rb_node, root_out);\n\n\t--hists->nr_entries;\n\tif (!he->filtered)\n\t\t--hists->nr_non_filtered_entries;\n\n\thist_entry__delete(he);\n}\n\nvoid hists__decay_entries(struct hists *hists, bool zap_user, bool zap_kernel)\n{\n\tstruct rb_node *next = rb_first_cached(&hists->entries);\n\tstruct hist_entry *n;\n\n\twhile (next) {\n\t\tn = rb_entry(next, struct hist_entry, rb_node);\n\t\tnext = rb_next(&n->rb_node);\n\t\tif (((zap_user && n->level == '.') ||\n\t\t     (zap_kernel && n->level != '.') ||\n\t\t     hists__decay_entry(hists, n))) {\n\t\t\thists__delete_entry(hists, n);\n\t\t}\n\t}\n}\n\nvoid hists__delete_entries(struct hists *hists)\n{\n\tstruct rb_node *next = rb_first_cached(&hists->entries);\n\tstruct hist_entry *n;\n\n\twhile (next) {\n\t\tn = rb_entry(next, struct hist_entry, rb_node);\n\t\tnext = rb_next(&n->rb_node);\n\n\t\thists__delete_entry(hists, n);\n\t}\n}\n\nstruct hist_entry *hists__get_entry(struct hists *hists, int idx)\n{\n\tstruct rb_node *next = rb_first_cached(&hists->entries);\n\tstruct hist_entry *n;\n\tint i = 0;\n\n\twhile (next) {\n\t\tn = rb_entry(next, struct hist_entry, rb_node);\n\t\tif (i == idx)\n\t\t\treturn n;\n\n\t\tnext = rb_next(&n->rb_node);\n\t\ti++;\n\t}\n\n\treturn NULL;\n}\n\n \n\nstatic int hist_entry__init(struct hist_entry *he,\n\t\t\t    struct hist_entry *template,\n\t\t\t    bool sample_self,\n\t\t\t    size_t callchain_size)\n{\n\t*he = *template;\n\the->callchain_size = callchain_size;\n\n\tif (symbol_conf.cumulate_callchain) {\n\t\the->stat_acc = malloc(sizeof(he->stat));\n\t\tif (he->stat_acc == NULL)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(he->stat_acc, &he->stat, sizeof(he->stat));\n\t\tif (!sample_self)\n\t\t\tmemset(&he->stat, 0, sizeof(he->stat));\n\t}\n\n\the->ms.maps = maps__get(he->ms.maps);\n\the->ms.map = map__get(he->ms.map);\n\n\tif (he->branch_info) {\n\t\t \n\t\the->branch_info = malloc(sizeof(*he->branch_info));\n\t\tif (he->branch_info == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(he->branch_info, template->branch_info,\n\t\t       sizeof(*he->branch_info));\n\n\t\the->branch_info->from.ms.map = map__get(he->branch_info->from.ms.map);\n\t\the->branch_info->to.ms.map = map__get(he->branch_info->to.ms.map);\n\t}\n\n\tif (he->mem_info) {\n\t\the->mem_info->iaddr.ms.map = map__get(he->mem_info->iaddr.ms.map);\n\t\the->mem_info->daddr.ms.map = map__get(he->mem_info->daddr.ms.map);\n\t}\n\n\tif (hist_entry__has_callchains(he) && symbol_conf.use_callchain)\n\t\tcallchain_init(he->callchain);\n\n\tif (he->raw_data) {\n\t\the->raw_data = memdup(he->raw_data, he->raw_size);\n\t\tif (he->raw_data == NULL)\n\t\t\tgoto err_infos;\n\t}\n\n\tif (he->srcline && he->srcline != SRCLINE_UNKNOWN) {\n\t\the->srcline = strdup(he->srcline);\n\t\tif (he->srcline == NULL)\n\t\t\tgoto err_rawdata;\n\t}\n\n\tif (symbol_conf.res_sample) {\n\t\the->res_samples = calloc(sizeof(struct res_sample),\n\t\t\t\t\tsymbol_conf.res_sample);\n\t\tif (!he->res_samples)\n\t\t\tgoto err_srcline;\n\t}\n\n\tINIT_LIST_HEAD(&he->pairs.node);\n\the->thread = thread__get(he->thread);\n\the->hroot_in  = RB_ROOT_CACHED;\n\the->hroot_out = RB_ROOT_CACHED;\n\n\tif (!symbol_conf.report_hierarchy)\n\t\the->leaf = true;\n\n\treturn 0;\n\nerr_srcline:\n\tzfree(&he->srcline);\n\nerr_rawdata:\n\tzfree(&he->raw_data);\n\nerr_infos:\n\tif (he->branch_info) {\n\t\tmap__put(he->branch_info->from.ms.map);\n\t\tmap__put(he->branch_info->to.ms.map);\n\t\tzfree(&he->branch_info);\n\t}\n\tif (he->mem_info) {\n\t\tmap__put(he->mem_info->iaddr.ms.map);\n\t\tmap__put(he->mem_info->daddr.ms.map);\n\t}\nerr:\n\tmaps__zput(he->ms.maps);\n\tmap__zput(he->ms.map);\n\tzfree(&he->stat_acc);\n\treturn -ENOMEM;\n}\n\nstatic void *hist_entry__zalloc(size_t size)\n{\n\treturn zalloc(size + sizeof(struct hist_entry));\n}\n\nstatic void hist_entry__free(void *ptr)\n{\n\tfree(ptr);\n}\n\nstatic struct hist_entry_ops default_ops = {\n\t.new\t= hist_entry__zalloc,\n\t.free\t= hist_entry__free,\n};\n\nstatic struct hist_entry *hist_entry__new(struct hist_entry *template,\n\t\t\t\t\t  bool sample_self)\n{\n\tstruct hist_entry_ops *ops = template->ops;\n\tsize_t callchain_size = 0;\n\tstruct hist_entry *he;\n\tint err = 0;\n\n\tif (!ops)\n\t\tops = template->ops = &default_ops;\n\n\tif (symbol_conf.use_callchain)\n\t\tcallchain_size = sizeof(struct callchain_root);\n\n\the = ops->new(callchain_size);\n\tif (he) {\n\t\terr = hist_entry__init(he, template, sample_self, callchain_size);\n\t\tif (err) {\n\t\t\tops->free(he);\n\t\t\the = NULL;\n\t\t}\n\t}\n\n\treturn he;\n}\n\nstatic u8 symbol__parent_filter(const struct symbol *parent)\n{\n\tif (symbol_conf.exclude_other && parent == NULL)\n\t\treturn 1 << HIST_FILTER__PARENT;\n\treturn 0;\n}\n\nstatic void hist_entry__add_callchain_period(struct hist_entry *he, u64 period)\n{\n\tif (!hist_entry__has_callchains(he) || !symbol_conf.use_callchain)\n\t\treturn;\n\n\the->hists->callchain_period += period;\n\tif (!he->filtered)\n\t\the->hists->callchain_non_filtered_period += period;\n}\n\nstatic struct hist_entry *hists__findnew_entry(struct hists *hists,\n\t\t\t\t\t       struct hist_entry *entry,\n\t\t\t\t\t       const struct addr_location *al,\n\t\t\t\t\t       bool sample_self)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct hist_entry *he;\n\tint64_t cmp;\n\tu64 period = entry->stat.period;\n\tbool leftmost = true;\n\n\tp = &hists->entries_in->rb_root.rb_node;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\the = rb_entry(parent, struct hist_entry, rb_node_in);\n\n\t\t \n\t\tcmp = hist_entry__cmp(he, entry);\n\t\tif (!cmp) {\n\t\t\tif (sample_self) {\n\t\t\t\the_stat__add_period(&he->stat, period);\n\t\t\t\thist_entry__add_callchain_period(he, period);\n\t\t\t}\n\t\t\tif (symbol_conf.cumulate_callchain)\n\t\t\t\the_stat__add_period(he->stat_acc, period);\n\n\t\t\t \n\t\t\tmem_info__zput(entry->mem_info);\n\n\t\t\tblock_info__zput(entry->block_info);\n\n\t\t\tkvm_info__zput(entry->kvm_info);\n\n\t\t\t \n\t\t\tif (he->ms.map != entry->ms.map) {\n\t\t\t\tmap__put(he->ms.map);\n\t\t\t\the->ms.map = map__get(entry->ms.map);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\the = hist_entry__new(entry, sample_self);\n\tif (!he)\n\t\treturn NULL;\n\n\tif (sample_self)\n\t\thist_entry__add_callchain_period(he, period);\n\thists->nr_entries++;\n\n\trb_link_node(&he->rb_node_in, parent, p);\n\trb_insert_color_cached(&he->rb_node_in, hists->entries_in, leftmost);\nout:\n\tif (sample_self)\n\t\the_stat__add_cpumode_period(&he->stat, al->cpumode, period);\n\tif (symbol_conf.cumulate_callchain)\n\t\the_stat__add_cpumode_period(he->stat_acc, al->cpumode, period);\n\treturn he;\n}\n\nstatic unsigned random_max(unsigned high)\n{\n\tunsigned thresh = -high % high;\n\tfor (;;) {\n\t\tunsigned r = random();\n\t\tif (r >= thresh)\n\t\t\treturn r % high;\n\t}\n}\n\nstatic void hists__res_sample(struct hist_entry *he, struct perf_sample *sample)\n{\n\tstruct res_sample *r;\n\tint j;\n\n\tif (he->num_res < symbol_conf.res_sample) {\n\t\tj = he->num_res++;\n\t} else {\n\t\tj = random_max(symbol_conf.res_sample);\n\t}\n\tr = &he->res_samples[j];\n\tr->time = sample->time;\n\tr->cpu = sample->cpu;\n\tr->tid = sample->tid;\n}\n\nstatic struct hist_entry*\n__hists__add_entry(struct hists *hists,\n\t\t   struct addr_location *al,\n\t\t   struct symbol *sym_parent,\n\t\t   struct branch_info *bi,\n\t\t   struct mem_info *mi,\n\t\t   struct kvm_info *ki,\n\t\t   struct block_info *block_info,\n\t\t   struct perf_sample *sample,\n\t\t   bool sample_self,\n\t\t   struct hist_entry_ops *ops)\n{\n\tstruct namespaces *ns = thread__namespaces(al->thread);\n\tstruct hist_entry entry = {\n\t\t.thread\t= al->thread,\n\t\t.comm = thread__comm(al->thread),\n\t\t.cgroup_id = {\n\t\t\t.dev = ns ? ns->link_info[CGROUP_NS_INDEX].dev : 0,\n\t\t\t.ino = ns ? ns->link_info[CGROUP_NS_INDEX].ino : 0,\n\t\t},\n\t\t.cgroup = sample->cgroup,\n\t\t.ms = {\n\t\t\t.maps\t= al->maps,\n\t\t\t.map\t= al->map,\n\t\t\t.sym\t= al->sym,\n\t\t},\n\t\t.srcline = (char *) al->srcline,\n\t\t.socket\t = al->socket,\n\t\t.cpu\t = al->cpu,\n\t\t.cpumode = al->cpumode,\n\t\t.ip\t = al->addr,\n\t\t.level\t = al->level,\n\t\t.code_page_size = sample->code_page_size,\n\t\t.stat = {\n\t\t\t.nr_events = 1,\n\t\t\t.period\t= sample->period,\n\t\t},\n\t\t.parent = sym_parent,\n\t\t.filtered = symbol__parent_filter(sym_parent) | al->filtered,\n\t\t.hists\t= hists,\n\t\t.branch_info = bi,\n\t\t.mem_info = mi,\n\t\t.kvm_info = ki,\n\t\t.block_info = block_info,\n\t\t.transaction = sample->transaction,\n\t\t.raw_data = sample->raw_data,\n\t\t.raw_size = sample->raw_size,\n\t\t.ops = ops,\n\t\t.time = hist_time(sample->time),\n\t\t.weight = sample->weight,\n\t\t.ins_lat = sample->ins_lat,\n\t\t.p_stage_cyc = sample->p_stage_cyc,\n\t\t.simd_flags = sample->simd_flags,\n\t}, *he = hists__findnew_entry(hists, &entry, al, sample_self);\n\n\tif (!hists->has_callchains && he && he->callchain_size != 0)\n\t\thists->has_callchains = true;\n\tif (he && symbol_conf.res_sample)\n\t\thists__res_sample(he, sample);\n\treturn he;\n}\n\nstruct hist_entry *hists__add_entry(struct hists *hists,\n\t\t\t\t    struct addr_location *al,\n\t\t\t\t    struct symbol *sym_parent,\n\t\t\t\t    struct branch_info *bi,\n\t\t\t\t    struct mem_info *mi,\n\t\t\t\t    struct kvm_info *ki,\n\t\t\t\t    struct perf_sample *sample,\n\t\t\t\t    bool sample_self)\n{\n\treturn __hists__add_entry(hists, al, sym_parent, bi, mi, ki, NULL,\n\t\t\t\t  sample, sample_self, NULL);\n}\n\nstruct hist_entry *hists__add_entry_ops(struct hists *hists,\n\t\t\t\t\tstruct hist_entry_ops *ops,\n\t\t\t\t\tstruct addr_location *al,\n\t\t\t\t\tstruct symbol *sym_parent,\n\t\t\t\t\tstruct branch_info *bi,\n\t\t\t\t\tstruct mem_info *mi,\n\t\t\t\t\tstruct kvm_info *ki,\n\t\t\t\t\tstruct perf_sample *sample,\n\t\t\t\t\tbool sample_self)\n{\n\treturn __hists__add_entry(hists, al, sym_parent, bi, mi, ki, NULL,\n\t\t\t\t  sample, sample_self, ops);\n}\n\nstruct hist_entry *hists__add_entry_block(struct hists *hists,\n\t\t\t\t\t  struct addr_location *al,\n\t\t\t\t\t  struct block_info *block_info)\n{\n\tstruct hist_entry entry = {\n\t\t.block_info = block_info,\n\t\t.hists = hists,\n\t\t.ms = {\n\t\t\t.maps = al->maps,\n\t\t\t.map = al->map,\n\t\t\t.sym = al->sym,\n\t\t},\n\t}, *he = hists__findnew_entry(hists, &entry, al, false);\n\n\treturn he;\n}\n\nstatic int\niter_next_nop_entry(struct hist_entry_iter *iter __maybe_unused,\n\t\t    struct addr_location *al __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int\niter_add_next_nop_entry(struct hist_entry_iter *iter __maybe_unused,\n\t\t\tstruct addr_location *al __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int\niter_prepare_mem_entry(struct hist_entry_iter *iter, struct addr_location *al)\n{\n\tstruct perf_sample *sample = iter->sample;\n\tstruct mem_info *mi;\n\n\tmi = sample__resolve_mem(sample, al);\n\tif (mi == NULL)\n\t\treturn -ENOMEM;\n\n\titer->priv = mi;\n\treturn 0;\n}\n\nstatic int\niter_add_single_mem_entry(struct hist_entry_iter *iter, struct addr_location *al)\n{\n\tu64 cost;\n\tstruct mem_info *mi = iter->priv;\n\tstruct hists *hists = evsel__hists(iter->evsel);\n\tstruct perf_sample *sample = iter->sample;\n\tstruct hist_entry *he;\n\n\tif (mi == NULL)\n\t\treturn -EINVAL;\n\n\tcost = sample->weight;\n\tif (!cost)\n\t\tcost = 1;\n\n\t \n\tsample->period = cost;\n\n\the = hists__add_entry(hists, al, iter->parent, NULL, mi, NULL,\n\t\t\t      sample, true);\n\tif (!he)\n\t\treturn -ENOMEM;\n\n\titer->he = he;\n\treturn 0;\n}\n\nstatic int\niter_finish_mem_entry(struct hist_entry_iter *iter,\n\t\t      struct addr_location *al __maybe_unused)\n{\n\tstruct evsel *evsel = iter->evsel;\n\tstruct hists *hists = evsel__hists(evsel);\n\tstruct hist_entry *he = iter->he;\n\tint err = -EINVAL;\n\n\tif (he == NULL)\n\t\tgoto out;\n\n\thists__inc_nr_samples(hists, he->filtered);\n\n\terr = hist_entry__append_callchain(he, iter->sample);\n\nout:\n\t \n\titer->priv = NULL;\n\n\titer->he = NULL;\n\treturn err;\n}\n\nstatic int\niter_prepare_branch_entry(struct hist_entry_iter *iter, struct addr_location *al)\n{\n\tstruct branch_info *bi;\n\tstruct perf_sample *sample = iter->sample;\n\n\tbi = sample__resolve_bstack(sample, al);\n\tif (!bi)\n\t\treturn -ENOMEM;\n\n\titer->curr = 0;\n\titer->total = sample->branch_stack->nr;\n\n\titer->priv = bi;\n\treturn 0;\n}\n\nstatic int\niter_add_single_branch_entry(struct hist_entry_iter *iter __maybe_unused,\n\t\t\t     struct addr_location *al __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int\niter_next_branch_entry(struct hist_entry_iter *iter, struct addr_location *al)\n{\n\tstruct branch_info *bi = iter->priv;\n\tint i = iter->curr;\n\n\tif (bi == NULL)\n\t\treturn 0;\n\n\tif (iter->curr >= iter->total)\n\t\treturn 0;\n\n\tmaps__put(al->maps);\n\tal->maps = maps__get(bi[i].to.ms.maps);\n\tmap__put(al->map);\n\tal->map = map__get(bi[i].to.ms.map);\n\tal->sym = bi[i].to.ms.sym;\n\tal->addr = bi[i].to.addr;\n\treturn 1;\n}\n\nstatic int\niter_add_next_branch_entry(struct hist_entry_iter *iter, struct addr_location *al)\n{\n\tstruct branch_info *bi;\n\tstruct evsel *evsel = iter->evsel;\n\tstruct hists *hists = evsel__hists(evsel);\n\tstruct perf_sample *sample = iter->sample;\n\tstruct hist_entry *he = NULL;\n\tint i = iter->curr;\n\tint err = 0;\n\n\tbi = iter->priv;\n\n\tif (iter->hide_unresolved && !(bi[i].from.ms.sym && bi[i].to.ms.sym))\n\t\tgoto out;\n\n\t \n\tsample->period = 1;\n\tsample->weight = bi->flags.cycles ? bi->flags.cycles : 1;\n\n\the = hists__add_entry(hists, al, iter->parent, &bi[i], NULL, NULL,\n\t\t\t      sample, true);\n\tif (he == NULL)\n\t\treturn -ENOMEM;\n\n\thists__inc_nr_samples(hists, he->filtered);\n\nout:\n\titer->he = he;\n\titer->curr++;\n\treturn err;\n}\n\nstatic int\niter_finish_branch_entry(struct hist_entry_iter *iter,\n\t\t\t struct addr_location *al __maybe_unused)\n{\n\tzfree(&iter->priv);\n\titer->he = NULL;\n\n\treturn iter->curr >= iter->total ? 0 : -1;\n}\n\nstatic int\niter_prepare_normal_entry(struct hist_entry_iter *iter __maybe_unused,\n\t\t\t  struct addr_location *al __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int\niter_add_single_normal_entry(struct hist_entry_iter *iter, struct addr_location *al)\n{\n\tstruct evsel *evsel = iter->evsel;\n\tstruct perf_sample *sample = iter->sample;\n\tstruct hist_entry *he;\n\n\the = hists__add_entry(evsel__hists(evsel), al, iter->parent, NULL, NULL,\n\t\t\t      NULL, sample, true);\n\tif (he == NULL)\n\t\treturn -ENOMEM;\n\n\titer->he = he;\n\treturn 0;\n}\n\nstatic int\niter_finish_normal_entry(struct hist_entry_iter *iter,\n\t\t\t struct addr_location *al __maybe_unused)\n{\n\tstruct hist_entry *he = iter->he;\n\tstruct evsel *evsel = iter->evsel;\n\tstruct perf_sample *sample = iter->sample;\n\n\tif (he == NULL)\n\t\treturn 0;\n\n\titer->he = NULL;\n\n\thists__inc_nr_samples(evsel__hists(evsel), he->filtered);\n\n\treturn hist_entry__append_callchain(he, sample);\n}\n\nstatic int\niter_prepare_cumulative_entry(struct hist_entry_iter *iter,\n\t\t\t      struct addr_location *al __maybe_unused)\n{\n\tstruct hist_entry **he_cache;\n\tstruct callchain_cursor *cursor = get_tls_callchain_cursor();\n\n\tif (cursor == NULL)\n\t\treturn -ENOMEM;\n\n\tcallchain_cursor_commit(cursor);\n\n\t \n\the_cache = malloc(sizeof(*he_cache) * (cursor->nr + 1));\n\tif (he_cache == NULL)\n\t\treturn -ENOMEM;\n\n\titer->priv = he_cache;\n\titer->curr = 0;\n\n\treturn 0;\n}\n\nstatic int\niter_add_single_cumulative_entry(struct hist_entry_iter *iter,\n\t\t\t\t struct addr_location *al)\n{\n\tstruct evsel *evsel = iter->evsel;\n\tstruct hists *hists = evsel__hists(evsel);\n\tstruct perf_sample *sample = iter->sample;\n\tstruct hist_entry **he_cache = iter->priv;\n\tstruct hist_entry *he;\n\tint err = 0;\n\n\the = hists__add_entry(hists, al, iter->parent, NULL, NULL, NULL,\n\t\t\t      sample, true);\n\tif (he == NULL)\n\t\treturn -ENOMEM;\n\n\titer->he = he;\n\the_cache[iter->curr++] = he;\n\n\thist_entry__append_callchain(he, sample);\n\n\t \n\tcallchain_cursor_commit(get_tls_callchain_cursor());\n\n\thists__inc_nr_samples(hists, he->filtered);\n\n\treturn err;\n}\n\nstatic int\niter_next_cumulative_entry(struct hist_entry_iter *iter,\n\t\t\t   struct addr_location *al)\n{\n\tstruct callchain_cursor_node *node;\n\n\tnode = callchain_cursor_current(get_tls_callchain_cursor());\n\tif (node == NULL)\n\t\treturn 0;\n\n\treturn fill_callchain_info(al, node, iter->hide_unresolved);\n}\n\nstatic bool\nhist_entry__fast__sym_diff(struct hist_entry *left,\n\t\t\t   struct hist_entry *right)\n{\n\tstruct symbol *sym_l = left->ms.sym;\n\tstruct symbol *sym_r = right->ms.sym;\n\n\tif (!sym_l && !sym_r)\n\t\treturn left->ip != right->ip;\n\n\treturn !!_sort__sym_cmp(sym_l, sym_r);\n}\n\n\nstatic int\niter_add_next_cumulative_entry(struct hist_entry_iter *iter,\n\t\t\t       struct addr_location *al)\n{\n\tstruct evsel *evsel = iter->evsel;\n\tstruct perf_sample *sample = iter->sample;\n\tstruct hist_entry **he_cache = iter->priv;\n\tstruct hist_entry *he;\n\tstruct hist_entry he_tmp = {\n\t\t.hists = evsel__hists(evsel),\n\t\t.cpu = al->cpu,\n\t\t.thread = al->thread,\n\t\t.comm = thread__comm(al->thread),\n\t\t.ip = al->addr,\n\t\t.ms = {\n\t\t\t.maps = al->maps,\n\t\t\t.map = al->map,\n\t\t\t.sym = al->sym,\n\t\t},\n\t\t.srcline = (char *) al->srcline,\n\t\t.parent = iter->parent,\n\t\t.raw_data = sample->raw_data,\n\t\t.raw_size = sample->raw_size,\n\t};\n\tint i;\n\tstruct callchain_cursor cursor, *tls_cursor = get_tls_callchain_cursor();\n\tbool fast = hists__has(he_tmp.hists, sym);\n\n\tif (tls_cursor == NULL)\n\t\treturn -ENOMEM;\n\n\tcallchain_cursor_snapshot(&cursor, tls_cursor);\n\n\tcallchain_cursor_advance(tls_cursor);\n\n\t \n\tfor (i = 0; i < iter->curr; i++) {\n\t\t \n\t\tif (fast && hist_entry__fast__sym_diff(he_cache[i], &he_tmp))\n\t\t\tcontinue;\n\n\t\tif (hist_entry__cmp(he_cache[i], &he_tmp) == 0) {\n\t\t\t \n\t\t\titer->he = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\the = hists__add_entry(evsel__hists(evsel), al, iter->parent, NULL, NULL,\n\t\t\t      NULL, sample, false);\n\tif (he == NULL)\n\t\treturn -ENOMEM;\n\n\titer->he = he;\n\the_cache[iter->curr++] = he;\n\n\tif (hist_entry__has_callchains(he) && symbol_conf.use_callchain)\n\t\tcallchain_append(he->callchain, &cursor, sample->period);\n\treturn 0;\n}\n\nstatic int\niter_finish_cumulative_entry(struct hist_entry_iter *iter,\n\t\t\t     struct addr_location *al __maybe_unused)\n{\n\tzfree(&iter->priv);\n\titer->he = NULL;\n\n\treturn 0;\n}\n\nconst struct hist_iter_ops hist_iter_mem = {\n\t.prepare_entry \t\t= iter_prepare_mem_entry,\n\t.add_single_entry \t= iter_add_single_mem_entry,\n\t.next_entry \t\t= iter_next_nop_entry,\n\t.add_next_entry \t= iter_add_next_nop_entry,\n\t.finish_entry \t\t= iter_finish_mem_entry,\n};\n\nconst struct hist_iter_ops hist_iter_branch = {\n\t.prepare_entry \t\t= iter_prepare_branch_entry,\n\t.add_single_entry \t= iter_add_single_branch_entry,\n\t.next_entry \t\t= iter_next_branch_entry,\n\t.add_next_entry \t= iter_add_next_branch_entry,\n\t.finish_entry \t\t= iter_finish_branch_entry,\n};\n\nconst struct hist_iter_ops hist_iter_normal = {\n\t.prepare_entry \t\t= iter_prepare_normal_entry,\n\t.add_single_entry \t= iter_add_single_normal_entry,\n\t.next_entry \t\t= iter_next_nop_entry,\n\t.add_next_entry \t= iter_add_next_nop_entry,\n\t.finish_entry \t\t= iter_finish_normal_entry,\n};\n\nconst struct hist_iter_ops hist_iter_cumulative = {\n\t.prepare_entry \t\t= iter_prepare_cumulative_entry,\n\t.add_single_entry \t= iter_add_single_cumulative_entry,\n\t.next_entry \t\t= iter_next_cumulative_entry,\n\t.add_next_entry \t= iter_add_next_cumulative_entry,\n\t.finish_entry \t\t= iter_finish_cumulative_entry,\n};\n\nint hist_entry_iter__add(struct hist_entry_iter *iter, struct addr_location *al,\n\t\t\t int max_stack_depth, void *arg)\n{\n\tint err, err2;\n\tstruct map *alm = NULL;\n\n\tif (al)\n\t\talm = map__get(al->map);\n\n\terr = sample__resolve_callchain(iter->sample, get_tls_callchain_cursor(), &iter->parent,\n\t\t\t\t\titer->evsel, al, max_stack_depth);\n\tif (err) {\n\t\tmap__put(alm);\n\t\treturn err;\n\t}\n\n\terr = iter->ops->prepare_entry(iter, al);\n\tif (err)\n\t\tgoto out;\n\n\terr = iter->ops->add_single_entry(iter, al);\n\tif (err)\n\t\tgoto out;\n\n\tif (iter->he && iter->add_entry_cb) {\n\t\terr = iter->add_entry_cb(iter, al, true, arg);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\twhile (iter->ops->next_entry(iter, al)) {\n\t\terr = iter->ops->add_next_entry(iter, al);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (iter->he && iter->add_entry_cb) {\n\t\t\terr = iter->add_entry_cb(iter, al, false, arg);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\terr2 = iter->ops->finish_entry(iter, al);\n\tif (!err)\n\t\terr = err2;\n\n\tmap__put(alm);\n\n\treturn err;\n}\n\nint64_t\nhist_entry__cmp(struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct hists *hists = left->hists;\n\tstruct perf_hpp_fmt *fmt;\n\tint64_t cmp = 0;\n\n\thists__for_each_sort_list(hists, fmt) {\n\t\tif (perf_hpp__is_dynamic_entry(fmt) &&\n\t\t    !perf_hpp__defined_dynamic_entry(fmt, hists))\n\t\t\tcontinue;\n\n\t\tcmp = fmt->cmp(fmt, left, right);\n\t\tif (cmp)\n\t\t\tbreak;\n\t}\n\n\treturn cmp;\n}\n\nint64_t\nhist_entry__collapse(struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct hists *hists = left->hists;\n\tstruct perf_hpp_fmt *fmt;\n\tint64_t cmp = 0;\n\n\thists__for_each_sort_list(hists, fmt) {\n\t\tif (perf_hpp__is_dynamic_entry(fmt) &&\n\t\t    !perf_hpp__defined_dynamic_entry(fmt, hists))\n\t\t\tcontinue;\n\n\t\tcmp = fmt->collapse(fmt, left, right);\n\t\tif (cmp)\n\t\t\tbreak;\n\t}\n\n\treturn cmp;\n}\n\nvoid hist_entry__delete(struct hist_entry *he)\n{\n\tstruct hist_entry_ops *ops = he->ops;\n\n\tthread__zput(he->thread);\n\tmaps__zput(he->ms.maps);\n\tmap__zput(he->ms.map);\n\n\tif (he->branch_info) {\n\t\tmap__zput(he->branch_info->from.ms.map);\n\t\tmap__zput(he->branch_info->to.ms.map);\n\t\tzfree_srcline(&he->branch_info->srcline_from);\n\t\tzfree_srcline(&he->branch_info->srcline_to);\n\t\tzfree(&he->branch_info);\n\t}\n\n\tif (he->mem_info) {\n\t\tmap__zput(he->mem_info->iaddr.ms.map);\n\t\tmap__zput(he->mem_info->daddr.ms.map);\n\t\tmem_info__zput(he->mem_info);\n\t}\n\n\tif (he->block_info)\n\t\tblock_info__zput(he->block_info);\n\n\tif (he->kvm_info)\n\t\tkvm_info__zput(he->kvm_info);\n\n\tzfree(&he->res_samples);\n\tzfree(&he->stat_acc);\n\tzfree_srcline(&he->srcline);\n\tif (he->srcfile && he->srcfile[0])\n\t\tzfree(&he->srcfile);\n\tfree_callchain(he->callchain);\n\tzfree(&he->trace_output);\n\tzfree(&he->raw_data);\n\tops->free(he);\n}\n\n \nint hist_entry__snprintf_alignment(struct hist_entry *he, struct perf_hpp *hpp,\n\t\t\t\t   struct perf_hpp_fmt *fmt, int printed)\n{\n\tif (!list_is_last(&fmt->list, &he->hists->hpp_list->fields)) {\n\t\tconst int width = fmt->width(fmt, hpp, he->hists);\n\t\tif (printed < width) {\n\t\t\tadvance_hpp(hpp, printed);\n\t\t\tprinted = scnprintf(hpp->buf, hpp->size, \"%-*s\", width - printed, \" \");\n\t\t}\n\t}\n\n\treturn printed;\n}\n\n \n\nstatic void hists__apply_filters(struct hists *hists, struct hist_entry *he);\nstatic void hists__remove_entry_filter(struct hists *hists, struct hist_entry *he,\n\t\t\t\t       enum hist_filter type);\n\ntypedef bool (*fmt_chk_fn)(struct perf_hpp_fmt *fmt);\n\nstatic bool check_thread_entry(struct perf_hpp_fmt *fmt)\n{\n\treturn perf_hpp__is_thread_entry(fmt) || perf_hpp__is_comm_entry(fmt);\n}\n\nstatic void hist_entry__check_and_remove_filter(struct hist_entry *he,\n\t\t\t\t\t\tenum hist_filter type,\n\t\t\t\t\t\tfmt_chk_fn check)\n{\n\tstruct perf_hpp_fmt *fmt;\n\tbool type_match = false;\n\tstruct hist_entry *parent = he->parent_he;\n\n\tswitch (type) {\n\tcase HIST_FILTER__THREAD:\n\t\tif (symbol_conf.comm_list == NULL &&\n\t\t    symbol_conf.pid_list == NULL &&\n\t\t    symbol_conf.tid_list == NULL)\n\t\t\treturn;\n\t\tbreak;\n\tcase HIST_FILTER__DSO:\n\t\tif (symbol_conf.dso_list == NULL)\n\t\t\treturn;\n\t\tbreak;\n\tcase HIST_FILTER__SYMBOL:\n\t\tif (symbol_conf.sym_list == NULL)\n\t\t\treturn;\n\t\tbreak;\n\tcase HIST_FILTER__PARENT:\n\tcase HIST_FILTER__GUEST:\n\tcase HIST_FILTER__HOST:\n\tcase HIST_FILTER__SOCKET:\n\tcase HIST_FILTER__C2C:\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tperf_hpp_list__for_each_format(he->hpp_list, fmt) {\n\t\tif (check(fmt)) {\n\t\t\ttype_match = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (type_match) {\n\t\t \n\t\tif (!(he->filtered & (1 << type))) {\n\t\t\twhile (parent) {\n\t\t\t\tparent->filtered &= ~(1 << type);\n\t\t\t\tparent = parent->parent_he;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (parent == NULL)\n\t\t\the->filtered |= (1 << type);\n\t\telse\n\t\t\the->filtered |= (parent->filtered & (1 << type));\n\t}\n}\n\nstatic void hist_entry__apply_hierarchy_filters(struct hist_entry *he)\n{\n\thist_entry__check_and_remove_filter(he, HIST_FILTER__THREAD,\n\t\t\t\t\t    check_thread_entry);\n\n\thist_entry__check_and_remove_filter(he, HIST_FILTER__DSO,\n\t\t\t\t\t    perf_hpp__is_dso_entry);\n\n\thist_entry__check_and_remove_filter(he, HIST_FILTER__SYMBOL,\n\t\t\t\t\t    perf_hpp__is_sym_entry);\n\n\thists__apply_filters(he->hists, he);\n}\n\nstatic struct hist_entry *hierarchy_insert_entry(struct hists *hists,\n\t\t\t\t\t\t struct rb_root_cached *root,\n\t\t\t\t\t\t struct hist_entry *he,\n\t\t\t\t\t\t struct hist_entry *parent_he,\n\t\t\t\t\t\t struct perf_hpp_list *hpp_list)\n{\n\tstruct rb_node **p = &root->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct hist_entry *iter, *new;\n\tstruct perf_hpp_fmt *fmt;\n\tint64_t cmp;\n\tbool leftmost = true;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\titer = rb_entry(parent, struct hist_entry, rb_node_in);\n\n\t\tcmp = 0;\n\t\tperf_hpp_list__for_each_sort_list(hpp_list, fmt) {\n\t\t\tcmp = fmt->collapse(fmt, iter, he);\n\t\t\tif (cmp)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!cmp) {\n\t\t\the_stat__add_stat(&iter->stat, &he->stat);\n\t\t\treturn iter;\n\t\t}\n\n\t\tif (cmp < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse {\n\t\t\tp = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\tnew = hist_entry__new(he, true);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\thists->nr_entries++;\n\n\t \n\tnew->hpp_list = hpp_list;\n\tnew->parent_he = parent_he;\n\n\thist_entry__apply_hierarchy_filters(new);\n\n\t \n\tperf_hpp_list__for_each_sort_list(hpp_list, fmt) {\n\t\tif (perf_hpp__is_trace_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))\n\t\t\the->trace_output = NULL;\n\t\telse\n\t\t\tnew->trace_output = NULL;\n\n\t\tif (perf_hpp__is_srcline_entry(fmt))\n\t\t\the->srcline = NULL;\n\t\telse\n\t\t\tnew->srcline = NULL;\n\n\t\tif (perf_hpp__is_srcfile_entry(fmt))\n\t\t\the->srcfile = NULL;\n\t\telse\n\t\t\tnew->srcfile = NULL;\n\t}\n\n\trb_link_node(&new->rb_node_in, parent, p);\n\trb_insert_color_cached(&new->rb_node_in, root, leftmost);\n\treturn new;\n}\n\nstatic int hists__hierarchy_insert_entry(struct hists *hists,\n\t\t\t\t\t struct rb_root_cached *root,\n\t\t\t\t\t struct hist_entry *he)\n{\n\tstruct perf_hpp_list_node *node;\n\tstruct hist_entry *new_he = NULL;\n\tstruct hist_entry *parent = NULL;\n\tint depth = 0;\n\tint ret = 0;\n\n\tlist_for_each_entry(node, &hists->hpp_formats, list) {\n\t\t \n\t\tif (node->level == 0 || node->skip)\n\t\t\tcontinue;\n\n\t\t \n\t\tnew_he = hierarchy_insert_entry(hists, root, he, parent, &node->hpp);\n\t\tif (new_he == NULL) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\troot = &new_he->hroot_in;\n\t\tnew_he->depth = depth++;\n\t\tparent = new_he;\n\t}\n\n\tif (new_he) {\n\t\tnew_he->leaf = true;\n\n\t\tif (hist_entry__has_callchains(new_he) &&\n\t\t    symbol_conf.use_callchain) {\n\t\t\tstruct callchain_cursor *cursor = get_tls_callchain_cursor();\n\n\t\t\tif (cursor == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tcallchain_cursor_reset(cursor);\n\t\t\tif (callchain_merge(cursor,\n\t\t\t\t\t    new_he->callchain,\n\t\t\t\t\t    he->callchain) < 0)\n\t\t\t\tret = -1;\n\t\t}\n\t}\n\n\t \n\thist_entry__delete(he);\n\n\t \n\treturn ret;\n}\n\nstatic int hists__collapse_insert_entry(struct hists *hists,\n\t\t\t\t\tstruct rb_root_cached *root,\n\t\t\t\t\tstruct hist_entry *he)\n{\n\tstruct rb_node **p = &root->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct hist_entry *iter;\n\tint64_t cmp;\n\tbool leftmost = true;\n\n\tif (symbol_conf.report_hierarchy)\n\t\treturn hists__hierarchy_insert_entry(hists, root, he);\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\titer = rb_entry(parent, struct hist_entry, rb_node_in);\n\n\t\tcmp = hist_entry__collapse(iter, he);\n\n\t\tif (!cmp) {\n\t\t\tint ret = 0;\n\n\t\t\the_stat__add_stat(&iter->stat, &he->stat);\n\t\t\tif (symbol_conf.cumulate_callchain)\n\t\t\t\the_stat__add_stat(iter->stat_acc, he->stat_acc);\n\n\t\t\tif (hist_entry__has_callchains(he) && symbol_conf.use_callchain) {\n\t\t\t\tstruct callchain_cursor *cursor = get_tls_callchain_cursor();\n\n\t\t\t\tif (cursor != NULL) {\n\t\t\t\t\tcallchain_cursor_reset(cursor);\n\t\t\t\t\tif (callchain_merge(cursor, iter->callchain, he->callchain) < 0)\n\t\t\t\t\t\tret = -1;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\thist_entry__delete(he);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\thists->nr_entries++;\n\n\trb_link_node(&he->rb_node_in, parent, p);\n\trb_insert_color_cached(&he->rb_node_in, root, leftmost);\n\treturn 1;\n}\n\nstruct rb_root_cached *hists__get_rotate_entries_in(struct hists *hists)\n{\n\tstruct rb_root_cached *root;\n\n\tmutex_lock(&hists->lock);\n\n\troot = hists->entries_in;\n\tif (++hists->entries_in > &hists->entries_in_array[1])\n\t\thists->entries_in = &hists->entries_in_array[0];\n\n\tmutex_unlock(&hists->lock);\n\n\treturn root;\n}\n\nstatic void hists__apply_filters(struct hists *hists, struct hist_entry *he)\n{\n\thists__filter_entry_by_dso(hists, he);\n\thists__filter_entry_by_thread(hists, he);\n\thists__filter_entry_by_symbol(hists, he);\n\thists__filter_entry_by_socket(hists, he);\n}\n\nint hists__collapse_resort(struct hists *hists, struct ui_progress *prog)\n{\n\tstruct rb_root_cached *root;\n\tstruct rb_node *next;\n\tstruct hist_entry *n;\n\tint ret;\n\n\tif (!hists__has(hists, need_collapse))\n\t\treturn 0;\n\n\thists->nr_entries = 0;\n\n\troot = hists__get_rotate_entries_in(hists);\n\n\tnext = rb_first_cached(root);\n\n\twhile (next) {\n\t\tif (session_done())\n\t\t\tbreak;\n\t\tn = rb_entry(next, struct hist_entry, rb_node_in);\n\t\tnext = rb_next(&n->rb_node_in);\n\n\t\trb_erase_cached(&n->rb_node_in, root);\n\t\tret = hists__collapse_insert_entry(hists, &hists->entries_collapsed, n);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\n\t\tif (ret) {\n\t\t\t \n\t\t\thists__apply_filters(hists, n);\n\t\t}\n\t\tif (prog)\n\t\t\tui_progress__update(prog, 1);\n\t}\n\treturn 0;\n}\n\nstatic int64_t hist_entry__sort(struct hist_entry *a, struct hist_entry *b)\n{\n\tstruct hists *hists = a->hists;\n\tstruct perf_hpp_fmt *fmt;\n\tint64_t cmp = 0;\n\n\thists__for_each_sort_list(hists, fmt) {\n\t\tif (perf_hpp__should_skip(fmt, a->hists))\n\t\t\tcontinue;\n\n\t\tcmp = fmt->sort(fmt, a, b);\n\t\tif (cmp)\n\t\t\tbreak;\n\t}\n\n\treturn cmp;\n}\n\nstatic void hists__reset_filter_stats(struct hists *hists)\n{\n\thists->nr_non_filtered_entries = 0;\n\thists->stats.total_non_filtered_period = 0;\n}\n\nvoid hists__reset_stats(struct hists *hists)\n{\n\thists->nr_entries = 0;\n\thists->stats.total_period = 0;\n\n\thists__reset_filter_stats(hists);\n}\n\nstatic void hists__inc_filter_stats(struct hists *hists, struct hist_entry *h)\n{\n\thists->nr_non_filtered_entries++;\n\thists->stats.total_non_filtered_period += h->stat.period;\n}\n\nvoid hists__inc_stats(struct hists *hists, struct hist_entry *h)\n{\n\tif (!h->filtered)\n\t\thists__inc_filter_stats(hists, h);\n\n\thists->nr_entries++;\n\thists->stats.total_period += h->stat.period;\n}\n\nstatic void hierarchy_recalc_total_periods(struct hists *hists)\n{\n\tstruct rb_node *node;\n\tstruct hist_entry *he;\n\n\tnode = rb_first_cached(&hists->entries);\n\n\thists->stats.total_period = 0;\n\thists->stats.total_non_filtered_period = 0;\n\n\t \n\twhile (node) {\n\t\the = rb_entry(node, struct hist_entry, rb_node);\n\t\tnode = rb_next(node);\n\n\t\thists->stats.total_period += he->stat.period;\n\t\tif (!he->filtered)\n\t\t\thists->stats.total_non_filtered_period += he->stat.period;\n\t}\n}\n\nstatic void hierarchy_insert_output_entry(struct rb_root_cached *root,\n\t\t\t\t\t  struct hist_entry *he)\n{\n\tstruct rb_node **p = &root->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct hist_entry *iter;\n\tstruct perf_hpp_fmt *fmt;\n\tbool leftmost = true;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\titer = rb_entry(parent, struct hist_entry, rb_node);\n\n\t\tif (hist_entry__sort(he, iter) > 0)\n\t\t\tp = &parent->rb_left;\n\t\telse {\n\t\t\tp = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\trb_link_node(&he->rb_node, parent, p);\n\trb_insert_color_cached(&he->rb_node, root, leftmost);\n\n\t \n\tperf_hpp_list__for_each_sort_list(he->hpp_list, fmt) {\n\t\tif (fmt->init)\n\t\t\tfmt->init(fmt, he);\n\t}\n}\n\nstatic void hists__hierarchy_output_resort(struct hists *hists,\n\t\t\t\t\t   struct ui_progress *prog,\n\t\t\t\t\t   struct rb_root_cached *root_in,\n\t\t\t\t\t   struct rb_root_cached *root_out,\n\t\t\t\t\t   u64 min_callchain_hits,\n\t\t\t\t\t   bool use_callchain)\n{\n\tstruct rb_node *node;\n\tstruct hist_entry *he;\n\n\t*root_out = RB_ROOT_CACHED;\n\tnode = rb_first_cached(root_in);\n\n\twhile (node) {\n\t\the = rb_entry(node, struct hist_entry, rb_node_in);\n\t\tnode = rb_next(node);\n\n\t\thierarchy_insert_output_entry(root_out, he);\n\n\t\tif (prog)\n\t\t\tui_progress__update(prog, 1);\n\n\t\thists->nr_entries++;\n\t\tif (!he->filtered) {\n\t\t\thists->nr_non_filtered_entries++;\n\t\t\thists__calc_col_len(hists, he);\n\t\t}\n\n\t\tif (!he->leaf) {\n\t\t\thists__hierarchy_output_resort(hists, prog,\n\t\t\t\t\t\t       &he->hroot_in,\n\t\t\t\t\t\t       &he->hroot_out,\n\t\t\t\t\t\t       min_callchain_hits,\n\t\t\t\t\t\t       use_callchain);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!use_callchain)\n\t\t\tcontinue;\n\n\t\tif (callchain_param.mode == CHAIN_GRAPH_REL) {\n\t\t\tu64 total = he->stat.period;\n\n\t\t\tif (symbol_conf.cumulate_callchain)\n\t\t\t\ttotal = he->stat_acc->period;\n\n\t\t\tmin_callchain_hits = total * (callchain_param.min_percent / 100);\n\t\t}\n\n\t\tcallchain_param.sort(&he->sorted_chain, he->callchain,\n\t\t\t\t     min_callchain_hits, &callchain_param);\n\t}\n}\n\nstatic void __hists__insert_output_entry(struct rb_root_cached *entries,\n\t\t\t\t\t struct hist_entry *he,\n\t\t\t\t\t u64 min_callchain_hits,\n\t\t\t\t\t bool use_callchain)\n{\n\tstruct rb_node **p = &entries->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct hist_entry *iter;\n\tstruct perf_hpp_fmt *fmt;\n\tbool leftmost = true;\n\n\tif (use_callchain) {\n\t\tif (callchain_param.mode == CHAIN_GRAPH_REL) {\n\t\t\tu64 total = he->stat.period;\n\n\t\t\tif (symbol_conf.cumulate_callchain)\n\t\t\t\ttotal = he->stat_acc->period;\n\n\t\t\tmin_callchain_hits = total * (callchain_param.min_percent / 100);\n\t\t}\n\t\tcallchain_param.sort(&he->sorted_chain, he->callchain,\n\t\t\t\t      min_callchain_hits, &callchain_param);\n\t}\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\titer = rb_entry(parent, struct hist_entry, rb_node);\n\n\t\tif (hist_entry__sort(he, iter) > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\trb_link_node(&he->rb_node, parent, p);\n\trb_insert_color_cached(&he->rb_node, entries, leftmost);\n\n\t \n\tperf_hpp_list__for_each_sort_list(&perf_hpp_list, fmt) {\n\t\tif (fmt->init)\n\t\t\tfmt->init(fmt, he);\n\t}\n}\n\nstatic void output_resort(struct hists *hists, struct ui_progress *prog,\n\t\t\t  bool use_callchain, hists__resort_cb_t cb,\n\t\t\t  void *cb_arg)\n{\n\tstruct rb_root_cached *root;\n\tstruct rb_node *next;\n\tstruct hist_entry *n;\n\tu64 callchain_total;\n\tu64 min_callchain_hits;\n\n\tcallchain_total = hists->callchain_period;\n\tif (symbol_conf.filter_relative)\n\t\tcallchain_total = hists->callchain_non_filtered_period;\n\n\tmin_callchain_hits = callchain_total * (callchain_param.min_percent / 100);\n\n\thists__reset_stats(hists);\n\thists__reset_col_len(hists);\n\n\tif (symbol_conf.report_hierarchy) {\n\t\thists__hierarchy_output_resort(hists, prog,\n\t\t\t\t\t       &hists->entries_collapsed,\n\t\t\t\t\t       &hists->entries,\n\t\t\t\t\t       min_callchain_hits,\n\t\t\t\t\t       use_callchain);\n\t\thierarchy_recalc_total_periods(hists);\n\t\treturn;\n\t}\n\n\tif (hists__has(hists, need_collapse))\n\t\troot = &hists->entries_collapsed;\n\telse\n\t\troot = hists->entries_in;\n\n\tnext = rb_first_cached(root);\n\thists->entries = RB_ROOT_CACHED;\n\n\twhile (next) {\n\t\tn = rb_entry(next, struct hist_entry, rb_node_in);\n\t\tnext = rb_next(&n->rb_node_in);\n\n\t\tif (cb && cb(n, cb_arg))\n\t\t\tcontinue;\n\n\t\t__hists__insert_output_entry(&hists->entries, n, min_callchain_hits, use_callchain);\n\t\thists__inc_stats(hists, n);\n\n\t\tif (!n->filtered)\n\t\t\thists__calc_col_len(hists, n);\n\n\t\tif (prog)\n\t\t\tui_progress__update(prog, 1);\n\t}\n}\n\nvoid evsel__output_resort_cb(struct evsel *evsel, struct ui_progress *prog,\n\t\t\t     hists__resort_cb_t cb, void *cb_arg)\n{\n\tbool use_callchain;\n\n\tif (evsel && symbol_conf.use_callchain && !symbol_conf.show_ref_callgraph)\n\t\tuse_callchain = evsel__has_callchain(evsel);\n\telse\n\t\tuse_callchain = symbol_conf.use_callchain;\n\n\tuse_callchain |= symbol_conf.show_branchflag_count;\n\n\toutput_resort(evsel__hists(evsel), prog, use_callchain, cb, cb_arg);\n}\n\nvoid evsel__output_resort(struct evsel *evsel, struct ui_progress *prog)\n{\n\treturn evsel__output_resort_cb(evsel, prog, NULL, NULL);\n}\n\nvoid hists__output_resort(struct hists *hists, struct ui_progress *prog)\n{\n\toutput_resort(hists, prog, symbol_conf.use_callchain, NULL, NULL);\n}\n\nvoid hists__output_resort_cb(struct hists *hists, struct ui_progress *prog,\n\t\t\t     hists__resort_cb_t cb)\n{\n\toutput_resort(hists, prog, symbol_conf.use_callchain, cb, NULL);\n}\n\nstatic bool can_goto_child(struct hist_entry *he, enum hierarchy_move_dir hmd)\n{\n\tif (he->leaf || hmd == HMD_FORCE_SIBLING)\n\t\treturn false;\n\n\tif (he->unfolded || hmd == HMD_FORCE_CHILD)\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct rb_node *rb_hierarchy_last(struct rb_node *node)\n{\n\tstruct hist_entry *he = rb_entry(node, struct hist_entry, rb_node);\n\n\twhile (can_goto_child(he, HMD_NORMAL)) {\n\t\tnode = rb_last(&he->hroot_out.rb_root);\n\t\the = rb_entry(node, struct hist_entry, rb_node);\n\t}\n\treturn node;\n}\n\nstruct rb_node *__rb_hierarchy_next(struct rb_node *node, enum hierarchy_move_dir hmd)\n{\n\tstruct hist_entry *he = rb_entry(node, struct hist_entry, rb_node);\n\n\tif (can_goto_child(he, hmd))\n\t\tnode = rb_first_cached(&he->hroot_out);\n\telse\n\t\tnode = rb_next(node);\n\n\twhile (node == NULL) {\n\t\the = he->parent_he;\n\t\tif (he == NULL)\n\t\t\tbreak;\n\n\t\tnode = rb_next(&he->rb_node);\n\t}\n\treturn node;\n}\n\nstruct rb_node *rb_hierarchy_prev(struct rb_node *node)\n{\n\tstruct hist_entry *he = rb_entry(node, struct hist_entry, rb_node);\n\n\tnode = rb_prev(node);\n\tif (node)\n\t\treturn rb_hierarchy_last(node);\n\n\the = he->parent_he;\n\tif (he == NULL)\n\t\treturn NULL;\n\n\treturn &he->rb_node;\n}\n\nbool hist_entry__has_hierarchy_children(struct hist_entry *he, float limit)\n{\n\tstruct rb_node *node;\n\tstruct hist_entry *child;\n\tfloat percent;\n\n\tif (he->leaf)\n\t\treturn false;\n\n\tnode = rb_first_cached(&he->hroot_out);\n\tchild = rb_entry(node, struct hist_entry, rb_node);\n\n\twhile (node && child->filtered) {\n\t\tnode = rb_next(node);\n\t\tchild = rb_entry(node, struct hist_entry, rb_node);\n\t}\n\n\tif (node)\n\t\tpercent = hist_entry__get_percent_limit(child);\n\telse\n\t\tpercent = 0;\n\n\treturn node && percent >= limit;\n}\n\nstatic void hists__remove_entry_filter(struct hists *hists, struct hist_entry *h,\n\t\t\t\t       enum hist_filter filter)\n{\n\th->filtered &= ~(1 << filter);\n\n\tif (symbol_conf.report_hierarchy) {\n\t\tstruct hist_entry *parent = h->parent_he;\n\n\t\twhile (parent) {\n\t\t\the_stat__add_stat(&parent->stat, &h->stat);\n\n\t\t\tparent->filtered &= ~(1 << filter);\n\n\t\t\tif (parent->filtered)\n\t\t\t\tgoto next;\n\n\t\t\t \n\t\t\tparent->unfolded = false;\n\t\t\tparent->has_no_entry = false;\n\t\t\tparent->row_offset = 0;\n\t\t\tparent->nr_rows = 0;\nnext:\n\t\t\tparent = parent->parent_he;\n\t\t}\n\t}\n\n\tif (h->filtered)\n\t\treturn;\n\n\t \n\th->unfolded = false;\n\th->has_no_entry = false;\n\th->row_offset = 0;\n\th->nr_rows = 0;\n\n\thists->stats.nr_non_filtered_samples += h->stat.nr_events;\n\n\thists__inc_filter_stats(hists, h);\n\thists__calc_col_len(hists, h);\n}\n\n\nstatic bool hists__filter_entry_by_dso(struct hists *hists,\n\t\t\t\t       struct hist_entry *he)\n{\n\tif (hists->dso_filter != NULL &&\n\t    (he->ms.map == NULL || map__dso(he->ms.map) != hists->dso_filter)) {\n\t\the->filtered |= (1 << HIST_FILTER__DSO);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool hists__filter_entry_by_thread(struct hists *hists,\n\t\t\t\t\t  struct hist_entry *he)\n{\n\tif (hists->thread_filter != NULL &&\n\t    RC_CHK_ACCESS(he->thread) != RC_CHK_ACCESS(hists->thread_filter)) {\n\t\the->filtered |= (1 << HIST_FILTER__THREAD);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool hists__filter_entry_by_symbol(struct hists *hists,\n\t\t\t\t\t  struct hist_entry *he)\n{\n\tif (hists->symbol_filter_str != NULL &&\n\t    (!he->ms.sym || strstr(he->ms.sym->name,\n\t\t\t\t   hists->symbol_filter_str) == NULL)) {\n\t\the->filtered |= (1 << HIST_FILTER__SYMBOL);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool hists__filter_entry_by_socket(struct hists *hists,\n\t\t\t\t\t  struct hist_entry *he)\n{\n\tif ((hists->socket_filter > -1) &&\n\t    (he->socket != hists->socket_filter)) {\n\t\the->filtered |= (1 << HIST_FILTER__SOCKET);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\ntypedef bool (*filter_fn_t)(struct hists *hists, struct hist_entry *he);\n\nstatic void hists__filter_by_type(struct hists *hists, int type, filter_fn_t filter)\n{\n\tstruct rb_node *nd;\n\n\thists->stats.nr_non_filtered_samples = 0;\n\n\thists__reset_filter_stats(hists);\n\thists__reset_col_len(hists);\n\n\tfor (nd = rb_first_cached(&hists->entries); nd; nd = rb_next(nd)) {\n\t\tstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\n\n\t\tif (filter(hists, h))\n\t\t\tcontinue;\n\n\t\thists__remove_entry_filter(hists, h, type);\n\t}\n}\n\nstatic void resort_filtered_entry(struct rb_root_cached *root,\n\t\t\t\t  struct hist_entry *he)\n{\n\tstruct rb_node **p = &root->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct hist_entry *iter;\n\tstruct rb_root_cached new_root = RB_ROOT_CACHED;\n\tstruct rb_node *nd;\n\tbool leftmost = true;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\titer = rb_entry(parent, struct hist_entry, rb_node);\n\n\t\tif (hist_entry__sort(he, iter) > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\trb_link_node(&he->rb_node, parent, p);\n\trb_insert_color_cached(&he->rb_node, root, leftmost);\n\n\tif (he->leaf || he->filtered)\n\t\treturn;\n\n\tnd = rb_first_cached(&he->hroot_out);\n\twhile (nd) {\n\t\tstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\n\n\t\tnd = rb_next(nd);\n\t\trb_erase_cached(&h->rb_node, &he->hroot_out);\n\n\t\tresort_filtered_entry(&new_root, h);\n\t}\n\n\the->hroot_out = new_root;\n}\n\nstatic void hists__filter_hierarchy(struct hists *hists, int type, const void *arg)\n{\n\tstruct rb_node *nd;\n\tstruct rb_root_cached new_root = RB_ROOT_CACHED;\n\n\thists->stats.nr_non_filtered_samples = 0;\n\n\thists__reset_filter_stats(hists);\n\thists__reset_col_len(hists);\n\n\tnd = rb_first_cached(&hists->entries);\n\twhile (nd) {\n\t\tstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\n\t\tint ret;\n\n\t\tret = hist_entry__filter(h, type, arg);\n\n\t\t \n\t\tif (ret < 0) {\n\t\t\tmemset(&h->stat, 0, sizeof(h->stat));\n\t\t\th->filtered |= (1 << type);\n\n\t\t\tnd = __rb_hierarchy_next(&h->rb_node, HMD_FORCE_CHILD);\n\t\t}\n\t\t \n\t\telse if (ret == 1) {\n\t\t\th->filtered |= (1 << type);\n\n\t\t\tnd = __rb_hierarchy_next(&h->rb_node, HMD_FORCE_SIBLING);\n\t\t}\n\t\t \n\t\telse {\n\t\t\thists__remove_entry_filter(hists, h, type);\n\n\t\t\tnd = __rb_hierarchy_next(&h->rb_node, HMD_FORCE_SIBLING);\n\t\t}\n\t}\n\n\thierarchy_recalc_total_periods(hists);\n\n\t \n\tnd = rb_first_cached(&hists->entries);\n\twhile (nd) {\n\t\tstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\n\n\t\tnd = rb_next(nd);\n\t\trb_erase_cached(&h->rb_node, &hists->entries);\n\n\t\tresort_filtered_entry(&new_root, h);\n\t}\n\n\thists->entries = new_root;\n}\n\nvoid hists__filter_by_thread(struct hists *hists)\n{\n\tif (symbol_conf.report_hierarchy)\n\t\thists__filter_hierarchy(hists, HIST_FILTER__THREAD,\n\t\t\t\t\thists->thread_filter);\n\telse\n\t\thists__filter_by_type(hists, HIST_FILTER__THREAD,\n\t\t\t\t      hists__filter_entry_by_thread);\n}\n\nvoid hists__filter_by_dso(struct hists *hists)\n{\n\tif (symbol_conf.report_hierarchy)\n\t\thists__filter_hierarchy(hists, HIST_FILTER__DSO,\n\t\t\t\t\thists->dso_filter);\n\telse\n\t\thists__filter_by_type(hists, HIST_FILTER__DSO,\n\t\t\t\t      hists__filter_entry_by_dso);\n}\n\nvoid hists__filter_by_symbol(struct hists *hists)\n{\n\tif (symbol_conf.report_hierarchy)\n\t\thists__filter_hierarchy(hists, HIST_FILTER__SYMBOL,\n\t\t\t\t\thists->symbol_filter_str);\n\telse\n\t\thists__filter_by_type(hists, HIST_FILTER__SYMBOL,\n\t\t\t\t      hists__filter_entry_by_symbol);\n}\n\nvoid hists__filter_by_socket(struct hists *hists)\n{\n\tif (symbol_conf.report_hierarchy)\n\t\thists__filter_hierarchy(hists, HIST_FILTER__SOCKET,\n\t\t\t\t\t&hists->socket_filter);\n\telse\n\t\thists__filter_by_type(hists, HIST_FILTER__SOCKET,\n\t\t\t\t      hists__filter_entry_by_socket);\n}\n\nvoid events_stats__inc(struct events_stats *stats, u32 type)\n{\n\t++stats->nr_events[0];\n\t++stats->nr_events[type];\n}\n\nstatic void hists_stats__inc(struct hists_stats *stats)\n{\n\t++stats->nr_samples;\n}\n\nvoid hists__inc_nr_events(struct hists *hists)\n{\n\thists_stats__inc(&hists->stats);\n}\n\nvoid hists__inc_nr_samples(struct hists *hists, bool filtered)\n{\n\thists_stats__inc(&hists->stats);\n\tif (!filtered)\n\t\thists->stats.nr_non_filtered_samples++;\n}\n\nvoid hists__inc_nr_lost_samples(struct hists *hists, u32 lost)\n{\n\thists->stats.nr_lost_samples += lost;\n}\n\nstatic struct hist_entry *hists__add_dummy_entry(struct hists *hists,\n\t\t\t\t\t\t struct hist_entry *pair)\n{\n\tstruct rb_root_cached *root;\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct hist_entry *he;\n\tint64_t cmp;\n\tbool leftmost = true;\n\n\tif (hists__has(hists, need_collapse))\n\t\troot = &hists->entries_collapsed;\n\telse\n\t\troot = hists->entries_in;\n\n\tp = &root->rb_root.rb_node;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\the = rb_entry(parent, struct hist_entry, rb_node_in);\n\n\t\tcmp = hist_entry__collapse(he, pair);\n\n\t\tif (!cmp)\n\t\t\tgoto out;\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\the = hist_entry__new(pair, true);\n\tif (he) {\n\t\tmemset(&he->stat, 0, sizeof(he->stat));\n\t\the->hists = hists;\n\t\tif (symbol_conf.cumulate_callchain)\n\t\t\tmemset(he->stat_acc, 0, sizeof(he->stat));\n\t\trb_link_node(&he->rb_node_in, parent, p);\n\t\trb_insert_color_cached(&he->rb_node_in, root, leftmost);\n\t\thists__inc_stats(hists, he);\n\t\the->dummy = true;\n\t}\nout:\n\treturn he;\n}\n\nstatic struct hist_entry *add_dummy_hierarchy_entry(struct hists *hists,\n\t\t\t\t\t\t    struct rb_root_cached *root,\n\t\t\t\t\t\t    struct hist_entry *pair)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct hist_entry *he;\n\tstruct perf_hpp_fmt *fmt;\n\tbool leftmost = true;\n\n\tp = &root->rb_root.rb_node;\n\twhile (*p != NULL) {\n\t\tint64_t cmp = 0;\n\n\t\tparent = *p;\n\t\the = rb_entry(parent, struct hist_entry, rb_node_in);\n\n\t\tperf_hpp_list__for_each_sort_list(he->hpp_list, fmt) {\n\t\t\tcmp = fmt->collapse(fmt, he, pair);\n\t\t\tif (cmp)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!cmp)\n\t\t\tgoto out;\n\n\t\tif (cmp < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse {\n\t\t\tp = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\the = hist_entry__new(pair, true);\n\tif (he) {\n\t\trb_link_node(&he->rb_node_in, parent, p);\n\t\trb_insert_color_cached(&he->rb_node_in, root, leftmost);\n\n\t\the->dummy = true;\n\t\the->hists = hists;\n\t\tmemset(&he->stat, 0, sizeof(he->stat));\n\t\thists__inc_stats(hists, he);\n\t}\nout:\n\treturn he;\n}\n\nstatic struct hist_entry *hists__find_entry(struct hists *hists,\n\t\t\t\t\t    struct hist_entry *he)\n{\n\tstruct rb_node *n;\n\n\tif (hists__has(hists, need_collapse))\n\t\tn = hists->entries_collapsed.rb_root.rb_node;\n\telse\n\t\tn = hists->entries_in->rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct hist_entry *iter = rb_entry(n, struct hist_entry, rb_node_in);\n\t\tint64_t cmp = hist_entry__collapse(iter, he);\n\n\t\tif (cmp < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn iter;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct hist_entry *hists__find_hierarchy_entry(struct rb_root_cached *root,\n\t\t\t\t\t\t      struct hist_entry *he)\n{\n\tstruct rb_node *n = root->rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct hist_entry *iter;\n\t\tstruct perf_hpp_fmt *fmt;\n\t\tint64_t cmp = 0;\n\n\t\titer = rb_entry(n, struct hist_entry, rb_node_in);\n\t\tperf_hpp_list__for_each_sort_list(he->hpp_list, fmt) {\n\t\t\tcmp = fmt->collapse(fmt, iter, he);\n\t\t\tif (cmp)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cmp < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn iter;\n\t}\n\n\treturn NULL;\n}\n\nstatic void hists__match_hierarchy(struct rb_root_cached *leader_root,\n\t\t\t\t   struct rb_root_cached *other_root)\n{\n\tstruct rb_node *nd;\n\tstruct hist_entry *pos, *pair;\n\n\tfor (nd = rb_first_cached(leader_root); nd; nd = rb_next(nd)) {\n\t\tpos  = rb_entry(nd, struct hist_entry, rb_node_in);\n\t\tpair = hists__find_hierarchy_entry(other_root, pos);\n\n\t\tif (pair) {\n\t\t\thist_entry__add_pair(pair, pos);\n\t\t\thists__match_hierarchy(&pos->hroot_in, &pair->hroot_in);\n\t\t}\n\t}\n}\n\n \nvoid hists__match(struct hists *leader, struct hists *other)\n{\n\tstruct rb_root_cached *root;\n\tstruct rb_node *nd;\n\tstruct hist_entry *pos, *pair;\n\n\tif (symbol_conf.report_hierarchy) {\n\t\t \n\t\treturn hists__match_hierarchy(&leader->entries_collapsed,\n\t\t\t\t\t      &other->entries_collapsed);\n\t}\n\n\tif (hists__has(leader, need_collapse))\n\t\troot = &leader->entries_collapsed;\n\telse\n\t\troot = leader->entries_in;\n\n\tfor (nd = rb_first_cached(root); nd; nd = rb_next(nd)) {\n\t\tpos  = rb_entry(nd, struct hist_entry, rb_node_in);\n\t\tpair = hists__find_entry(other, pos);\n\n\t\tif (pair)\n\t\t\thist_entry__add_pair(pair, pos);\n\t}\n}\n\nstatic int hists__link_hierarchy(struct hists *leader_hists,\n\t\t\t\t struct hist_entry *parent,\n\t\t\t\t struct rb_root_cached *leader_root,\n\t\t\t\t struct rb_root_cached *other_root)\n{\n\tstruct rb_node *nd;\n\tstruct hist_entry *pos, *leader;\n\n\tfor (nd = rb_first_cached(other_root); nd; nd = rb_next(nd)) {\n\t\tpos = rb_entry(nd, struct hist_entry, rb_node_in);\n\n\t\tif (hist_entry__has_pairs(pos)) {\n\t\t\tbool found = false;\n\n\t\t\tlist_for_each_entry(leader, &pos->pairs.head, pairs.node) {\n\t\t\t\tif (leader->hists == leader_hists) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tleader = add_dummy_hierarchy_entry(leader_hists,\n\t\t\t\t\t\t\t   leader_root, pos);\n\t\t\tif (leader == NULL)\n\t\t\t\treturn -1;\n\n\t\t\t \n\t\t\tleader->parent_he = parent;\n\n\t\t\thist_entry__add_pair(pos, leader);\n\t\t}\n\n\t\tif (!pos->leaf) {\n\t\t\tif (hists__link_hierarchy(leader_hists, leader,\n\t\t\t\t\t\t  &leader->hroot_in,\n\t\t\t\t\t\t  &pos->hroot_in) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint hists__link(struct hists *leader, struct hists *other)\n{\n\tstruct rb_root_cached *root;\n\tstruct rb_node *nd;\n\tstruct hist_entry *pos, *pair;\n\n\tif (symbol_conf.report_hierarchy) {\n\t\t \n\t\treturn hists__link_hierarchy(leader, NULL,\n\t\t\t\t\t     &leader->entries_collapsed,\n\t\t\t\t\t     &other->entries_collapsed);\n\t}\n\n\tif (hists__has(other, need_collapse))\n\t\troot = &other->entries_collapsed;\n\telse\n\t\troot = other->entries_in;\n\n\tfor (nd = rb_first_cached(root); nd; nd = rb_next(nd)) {\n\t\tpos = rb_entry(nd, struct hist_entry, rb_node_in);\n\n\t\tif (!hist_entry__has_pairs(pos)) {\n\t\t\tpair = hists__add_dummy_entry(leader, pos);\n\t\t\tif (pair == NULL)\n\t\t\t\treturn -1;\n\t\t\thist_entry__add_pair(pos, pair);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint hists__unlink(struct hists *hists)\n{\n\tstruct rb_root_cached *root;\n\tstruct rb_node *nd;\n\tstruct hist_entry *pos;\n\n\tif (hists__has(hists, need_collapse))\n\t\troot = &hists->entries_collapsed;\n\telse\n\t\troot = hists->entries_in;\n\n\tfor (nd = rb_first_cached(root); nd; nd = rb_next(nd)) {\n\t\tpos = rb_entry(nd, struct hist_entry, rb_node_in);\n\t\tlist_del_init(&pos->pairs.node);\n\t}\n\n\treturn 0;\n}\n\nvoid hist__account_cycles(struct branch_stack *bs, struct addr_location *al,\n\t\t\t  struct perf_sample *sample, bool nonany_branch_mode,\n\t\t\t  u64 *total_cycles)\n{\n\tstruct branch_info *bi;\n\tstruct branch_entry *entries = perf_sample__branch_entries(sample);\n\n\t \n\tif (bs && bs->nr && entries[0].flags.cycles) {\n\t\tbi = sample__resolve_bstack(sample, al);\n\t\tif (bi) {\n\t\t\tstruct addr_map_symbol *prev = NULL;\n\n\t\t\t \n\t\t\tfor (int i = bs->nr - 1; i >= 0; i--) {\n\t\t\t\taddr_map_symbol__account_cycles(&bi[i].from,\n\t\t\t\t\tnonany_branch_mode ? NULL : prev,\n\t\t\t\t\tbi[i].flags.cycles);\n\t\t\t\tprev = &bi[i].to;\n\n\t\t\t\tif (total_cycles)\n\t\t\t\t\t*total_cycles += bi[i].flags.cycles;\n\t\t\t}\n\t\t\tfor (unsigned int i = 0; i < bs->nr; i++) {\n\t\t\t\tmap__put(bi[i].to.ms.map);\n\t\t\t\tmaps__put(bi[i].to.ms.maps);\n\t\t\t\tmap__put(bi[i].from.ms.map);\n\t\t\t\tmaps__put(bi[i].from.ms.maps);\n\t\t\t}\n\t\t\tfree(bi);\n\t\t}\n\t}\n}\n\nsize_t evlist__fprintf_nr_events(struct evlist *evlist, FILE *fp,\n\t\t\t\t bool skip_empty)\n{\n\tstruct evsel *pos;\n\tsize_t ret = 0;\n\n\tevlist__for_each_entry(evlist, pos) {\n\t\tstruct hists *hists = evsel__hists(pos);\n\n\t\tif (skip_empty && !hists->stats.nr_samples && !hists->stats.nr_lost_samples)\n\t\t\tcontinue;\n\n\t\tret += fprintf(fp, \"%s stats:\\n\", evsel__name(pos));\n\t\tif (hists->stats.nr_samples)\n\t\t\tret += fprintf(fp, \"%16s events: %10d\\n\",\n\t\t\t\t       \"SAMPLE\", hists->stats.nr_samples);\n\t\tif (hists->stats.nr_lost_samples)\n\t\t\tret += fprintf(fp, \"%16s events: %10d\\n\",\n\t\t\t\t       \"LOST_SAMPLES\", hists->stats.nr_lost_samples);\n\t}\n\n\treturn ret;\n}\n\n\nu64 hists__total_period(struct hists *hists)\n{\n\treturn symbol_conf.filter_relative ? hists->stats.total_non_filtered_period :\n\t\thists->stats.total_period;\n}\n\nint __hists__scnprintf_title(struct hists *hists, char *bf, size_t size, bool show_freq)\n{\n\tchar unit;\n\tint printed;\n\tconst struct dso *dso = hists->dso_filter;\n\tstruct thread *thread = hists->thread_filter;\n\tint socket_id = hists->socket_filter;\n\tunsigned long nr_samples = hists->stats.nr_samples;\n\tu64 nr_events = hists->stats.total_period;\n\tstruct evsel *evsel = hists_to_evsel(hists);\n\tconst char *ev_name = evsel__name(evsel);\n\tchar buf[512], sample_freq_str[64] = \"\";\n\tsize_t buflen = sizeof(buf);\n\tchar ref[30] = \" show reference callgraph, \";\n\tbool enable_ref = false;\n\n\tif (symbol_conf.filter_relative) {\n\t\tnr_samples = hists->stats.nr_non_filtered_samples;\n\t\tnr_events = hists->stats.total_non_filtered_period;\n\t}\n\n\tif (evsel__is_group_event(evsel)) {\n\t\tstruct evsel *pos;\n\n\t\tevsel__group_desc(evsel, buf, buflen);\n\t\tev_name = buf;\n\n\t\tfor_each_group_member(pos, evsel) {\n\t\t\tstruct hists *pos_hists = evsel__hists(pos);\n\n\t\t\tif (symbol_conf.filter_relative) {\n\t\t\t\tnr_samples += pos_hists->stats.nr_non_filtered_samples;\n\t\t\t\tnr_events += pos_hists->stats.total_non_filtered_period;\n\t\t\t} else {\n\t\t\t\tnr_samples += pos_hists->stats.nr_samples;\n\t\t\t\tnr_events += pos_hists->stats.total_period;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (symbol_conf.show_ref_callgraph &&\n\t    strstr(ev_name, \"call-graph=no\"))\n\t\tenable_ref = true;\n\n\tif (show_freq)\n\t\tscnprintf(sample_freq_str, sizeof(sample_freq_str), \" %d Hz,\", evsel->core.attr.sample_freq);\n\n\tnr_samples = convert_unit(nr_samples, &unit);\n\tprinted = scnprintf(bf, size,\n\t\t\t   \"Samples: %lu%c of event%s '%s',%s%sEvent count (approx.): %\" PRIu64,\n\t\t\t   nr_samples, unit, evsel->core.nr_members > 1 ? \"s\" : \"\",\n\t\t\t   ev_name, sample_freq_str, enable_ref ? ref : \" \", nr_events);\n\n\n\tif (hists->uid_filter_str)\n\t\tprinted += snprintf(bf + printed, size - printed,\n\t\t\t\t    \", UID: %s\", hists->uid_filter_str);\n\tif (thread) {\n\t\tif (hists__has(hists, thread)) {\n\t\t\tprinted += scnprintf(bf + printed, size - printed,\n\t\t\t\t    \", Thread: %s(%d)\",\n\t\t\t\t    (thread__comm_set(thread) ? thread__comm_str(thread) : \"\"),\n\t\t\t\t\tthread__tid(thread));\n\t\t} else {\n\t\t\tprinted += scnprintf(bf + printed, size - printed,\n\t\t\t\t    \", Thread: %s\",\n\t\t\t\t    (thread__comm_set(thread) ? thread__comm_str(thread) : \"\"));\n\t\t}\n\t}\n\tif (dso)\n\t\tprinted += scnprintf(bf + printed, size - printed,\n\t\t\t\t    \", DSO: %s\", dso->short_name);\n\tif (socket_id > -1)\n\t\tprinted += scnprintf(bf + printed, size - printed,\n\t\t\t\t    \", Processor Socket: %d\", socket_id);\n\n\treturn printed;\n}\n\nint parse_filter_percentage(const struct option *opt __maybe_unused,\n\t\t\t    const char *arg, int unset __maybe_unused)\n{\n\tif (!strcmp(arg, \"relative\"))\n\t\tsymbol_conf.filter_relative = true;\n\telse if (!strcmp(arg, \"absolute\"))\n\t\tsymbol_conf.filter_relative = false;\n\telse {\n\t\tpr_debug(\"Invalid percentage: %s\\n\", arg);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint perf_hist_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"hist.percentage\"))\n\t\treturn parse_filter_percentage(NULL, value, 0);\n\n\treturn 0;\n}\n\nint __hists__init(struct hists *hists, struct perf_hpp_list *hpp_list)\n{\n\tmemset(hists, 0, sizeof(*hists));\n\thists->entries_in_array[0] = hists->entries_in_array[1] = RB_ROOT_CACHED;\n\thists->entries_in = &hists->entries_in_array[0];\n\thists->entries_collapsed = RB_ROOT_CACHED;\n\thists->entries = RB_ROOT_CACHED;\n\tmutex_init(&hists->lock);\n\thists->socket_filter = -1;\n\thists->hpp_list = hpp_list;\n\tINIT_LIST_HEAD(&hists->hpp_formats);\n\treturn 0;\n}\n\nstatic void hists__delete_remaining_entries(struct rb_root_cached *root)\n{\n\tstruct rb_node *node;\n\tstruct hist_entry *he;\n\n\twhile (!RB_EMPTY_ROOT(&root->rb_root)) {\n\t\tnode = rb_first_cached(root);\n\t\trb_erase_cached(node, root);\n\n\t\the = rb_entry(node, struct hist_entry, rb_node_in);\n\t\thist_entry__delete(he);\n\t}\n}\n\nstatic void hists__delete_all_entries(struct hists *hists)\n{\n\thists__delete_entries(hists);\n\thists__delete_remaining_entries(&hists->entries_in_array[0]);\n\thists__delete_remaining_entries(&hists->entries_in_array[1]);\n\thists__delete_remaining_entries(&hists->entries_collapsed);\n}\n\nstatic void hists_evsel__exit(struct evsel *evsel)\n{\n\tstruct hists *hists = evsel__hists(evsel);\n\tstruct perf_hpp_fmt *fmt, *pos;\n\tstruct perf_hpp_list_node *node, *tmp;\n\n\thists__delete_all_entries(hists);\n\n\tlist_for_each_entry_safe(node, tmp, &hists->hpp_formats, list) {\n\t\tperf_hpp_list__for_each_format_safe(&node->hpp, fmt, pos) {\n\t\t\tlist_del_init(&fmt->list);\n\t\t\tfree(fmt);\n\t\t}\n\t\tlist_del_init(&node->list);\n\t\tfree(node);\n\t}\n}\n\nstatic int hists_evsel__init(struct evsel *evsel)\n{\n\tstruct hists *hists = evsel__hists(evsel);\n\n\t__hists__init(hists, &perf_hpp_list);\n\treturn 0;\n}\n\n \n\nint hists__init(void)\n{\n\tint err = evsel__object_config(sizeof(struct hists_evsel),\n\t\t\t\t       hists_evsel__init, hists_evsel__exit);\n\tif (err)\n\t\tfputs(\"FATAL ERROR: Couldn't setup hists class\\n\", stderr);\n\n\treturn err;\n}\n\nvoid perf_hpp_list__init(struct perf_hpp_list *list)\n{\n\tINIT_LIST_HEAD(&list->fields);\n\tINIT_LIST_HEAD(&list->sorts);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}