{
  "module_name": "arm-spe-pkt-decoder.c",
  "hash_id": "d55952d64219c2cc1c6b6f01f2034b8440ee973aaaec51f86b513209af65a799",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/arm-spe-decoder/arm-spe-pkt-decoder.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <string.h>\n#include <endian.h>\n#include <byteswap.h>\n#include <linux/bitops.h>\n#include <stdarg.h>\n\n#include \"arm-spe-pkt-decoder.h\"\n\n#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#define le16_to_cpu bswap_16\n#define le32_to_cpu bswap_32\n#define le64_to_cpu bswap_64\n#define memcpy_le64(d, s, n) do { \\\n\tmemcpy((d), (s), (n));    \\\n\t*(d) = le64_to_cpu(*(d)); \\\n} while (0)\n#else\n#define le16_to_cpu\n#define le32_to_cpu\n#define le64_to_cpu\n#define memcpy_le64 memcpy\n#endif\n\nstatic const char * const arm_spe_packet_name[] = {\n\t[ARM_SPE_PAD]\t\t= \"PAD\",\n\t[ARM_SPE_END]\t\t= \"END\",\n\t[ARM_SPE_TIMESTAMP]\t= \"TS\",\n\t[ARM_SPE_ADDRESS]\t= \"ADDR\",\n\t[ARM_SPE_COUNTER]\t= \"LAT\",\n\t[ARM_SPE_CONTEXT]\t= \"CONTEXT\",\n\t[ARM_SPE_OP_TYPE]\t= \"OP-TYPE\",\n\t[ARM_SPE_EVENTS]\t= \"EVENTS\",\n\t[ARM_SPE_DATA_SOURCE]\t= \"DATA-SOURCE\",\n};\n\nconst char *arm_spe_pkt_name(enum arm_spe_pkt_type type)\n{\n\treturn arm_spe_packet_name[type];\n}\n\n \nstatic unsigned int arm_spe_payload_len(unsigned char hdr)\n{\n\treturn 1U << ((hdr & GENMASK_ULL(5, 4)) >> 4);\n}\n\nstatic int arm_spe_get_payload(const unsigned char *buf, size_t len,\n\t\t\t       unsigned char ext_hdr,\n\t\t\t       struct arm_spe_pkt *packet)\n{\n\tsize_t payload_len = arm_spe_payload_len(buf[ext_hdr]);\n\n\tif (len < 1 + ext_hdr + payload_len)\n\t\treturn ARM_SPE_NEED_MORE_BYTES;\n\n\tbuf += 1 + ext_hdr;\n\n\tswitch (payload_len) {\n\tcase 1: packet->payload = *(uint8_t *)buf; break;\n\tcase 2: packet->payload = le16_to_cpu(*(uint16_t *)buf); break;\n\tcase 4: packet->payload = le32_to_cpu(*(uint32_t *)buf); break;\n\tcase 8: packet->payload = le64_to_cpu(*(uint64_t *)buf); break;\n\tdefault: return ARM_SPE_BAD_PACKET;\n\t}\n\n\treturn 1 + ext_hdr + payload_len;\n}\n\nstatic int arm_spe_get_pad(struct arm_spe_pkt *packet)\n{\n\tpacket->type = ARM_SPE_PAD;\n\treturn 1;\n}\n\nstatic int arm_spe_get_alignment(const unsigned char *buf, size_t len,\n\t\t\t\t struct arm_spe_pkt *packet)\n{\n\tunsigned int alignment = 1 << ((buf[0] & 0xf) + 1);\n\n\tif (len < alignment)\n\t\treturn ARM_SPE_NEED_MORE_BYTES;\n\n\tpacket->type = ARM_SPE_PAD;\n\treturn alignment - (((uintptr_t)buf) & (alignment - 1));\n}\n\nstatic int arm_spe_get_end(struct arm_spe_pkt *packet)\n{\n\tpacket->type = ARM_SPE_END;\n\treturn 1;\n}\n\nstatic int arm_spe_get_timestamp(const unsigned char *buf, size_t len,\n\t\t\t\t struct arm_spe_pkt *packet)\n{\n\tpacket->type = ARM_SPE_TIMESTAMP;\n\treturn arm_spe_get_payload(buf, len, 0, packet);\n}\n\nstatic int arm_spe_get_events(const unsigned char *buf, size_t len,\n\t\t\t      struct arm_spe_pkt *packet)\n{\n\tpacket->type = ARM_SPE_EVENTS;\n\n\t \n\tpacket->index = arm_spe_payload_len(buf[0]);\n\n\treturn arm_spe_get_payload(buf, len, 0, packet);\n}\n\nstatic int arm_spe_get_data_source(const unsigned char *buf, size_t len,\n\t\t\t\t   struct arm_spe_pkt *packet)\n{\n\tpacket->type = ARM_SPE_DATA_SOURCE;\n\treturn arm_spe_get_payload(buf, len, 0, packet);\n}\n\nstatic int arm_spe_get_context(const unsigned char *buf, size_t len,\n\t\t\t       struct arm_spe_pkt *packet)\n{\n\tpacket->type = ARM_SPE_CONTEXT;\n\tpacket->index = SPE_CTX_PKT_HDR_INDEX(buf[0]);\n\treturn arm_spe_get_payload(buf, len, 0, packet);\n}\n\nstatic int arm_spe_get_op_type(const unsigned char *buf, size_t len,\n\t\t\t       struct arm_spe_pkt *packet)\n{\n\tpacket->type = ARM_SPE_OP_TYPE;\n\tpacket->index = SPE_OP_PKT_HDR_CLASS(buf[0]);\n\treturn arm_spe_get_payload(buf, len, 0, packet);\n}\n\nstatic int arm_spe_get_counter(const unsigned char *buf, size_t len,\n\t\t\t       const unsigned char ext_hdr, struct arm_spe_pkt *packet)\n{\n\tpacket->type = ARM_SPE_COUNTER;\n\n\tif (ext_hdr)\n\t\tpacket->index = SPE_HDR_EXTENDED_INDEX(buf[0], buf[1]);\n\telse\n\t\tpacket->index = SPE_HDR_SHORT_INDEX(buf[0]);\n\n\treturn arm_spe_get_payload(buf, len, ext_hdr, packet);\n}\n\nstatic int arm_spe_get_addr(const unsigned char *buf, size_t len,\n\t\t\t    const unsigned char ext_hdr, struct arm_spe_pkt *packet)\n{\n\tpacket->type = ARM_SPE_ADDRESS;\n\n\tif (ext_hdr)\n\t\tpacket->index = SPE_HDR_EXTENDED_INDEX(buf[0], buf[1]);\n\telse\n\t\tpacket->index = SPE_HDR_SHORT_INDEX(buf[0]);\n\n\treturn arm_spe_get_payload(buf, len, ext_hdr, packet);\n}\n\nstatic int arm_spe_do_get_packet(const unsigned char *buf, size_t len,\n\t\t\t\t struct arm_spe_pkt *packet)\n{\n\tunsigned int hdr;\n\tunsigned char ext_hdr = 0;\n\n\tmemset(packet, 0, sizeof(struct arm_spe_pkt));\n\n\tif (!len)\n\t\treturn ARM_SPE_NEED_MORE_BYTES;\n\n\thdr = buf[0];\n\n\tif (hdr == SPE_HEADER0_PAD)\n\t\treturn arm_spe_get_pad(packet);\n\n\tif (hdr == SPE_HEADER0_END)  \n\t\treturn arm_spe_get_end(packet);\n\n\tif (hdr == SPE_HEADER0_TIMESTAMP)\n\t\treturn arm_spe_get_timestamp(buf, len, packet);\n\n\tif ((hdr & SPE_HEADER0_MASK1) == SPE_HEADER0_EVENTS)\n\t\treturn arm_spe_get_events(buf, len, packet);\n\n\tif ((hdr & SPE_HEADER0_MASK1) == SPE_HEADER0_SOURCE)\n\t\treturn arm_spe_get_data_source(buf, len, packet);\n\n\tif ((hdr & SPE_HEADER0_MASK2) == SPE_HEADER0_CONTEXT)\n\t\treturn arm_spe_get_context(buf, len, packet);\n\n\tif ((hdr & SPE_HEADER0_MASK2) == SPE_HEADER0_OP_TYPE)\n\t\treturn arm_spe_get_op_type(buf, len, packet);\n\n\tif ((hdr & SPE_HEADER0_MASK2) == SPE_HEADER0_EXTENDED) {\n\t\t \n\t\tif (len == 1)\n\t\t\treturn ARM_SPE_BAD_PACKET;\n\n\t\text_hdr = 1;\n\t\thdr = buf[1];\n\t\tif (hdr == SPE_HEADER1_ALIGNMENT)\n\t\t\treturn arm_spe_get_alignment(buf, len, packet);\n\t}\n\n\t \n\tif ((hdr & SPE_HEADER0_MASK3) == SPE_HEADER0_ADDRESS)\n\t\treturn arm_spe_get_addr(buf, len, ext_hdr, packet);\n\n\tif ((hdr & SPE_HEADER0_MASK3) == SPE_HEADER0_COUNTER)\n\t\treturn arm_spe_get_counter(buf, len, ext_hdr, packet);\n\n\treturn ARM_SPE_BAD_PACKET;\n}\n\nint arm_spe_get_packet(const unsigned char *buf, size_t len,\n\t\t       struct arm_spe_pkt *packet)\n{\n\tint ret;\n\n\tret = arm_spe_do_get_packet(buf, len, packet);\n\t \n\tif (ret > 0 && packet->type == ARM_SPE_PAD) {\n\t\twhile (ret < 16 && len > (size_t)ret && !buf[ret])\n\t\t\tret += 1;\n\t}\n\treturn ret;\n}\n\nstatic int arm_spe_pkt_out_string(int *err, char **buf_p, size_t *blen,\n\t\t\t\t  const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\t \n\tif (err && *err)\n\t\treturn *err;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(*buf_p, *blen, fmt, ap);\n\tva_end(ap);\n\n\tif (ret < 0) {\n\t\tif (err && !*err)\n\t\t\t*err = ret;\n\n\t \n\t} else if ((size_t)ret >= *blen) {\n\t\t(*buf_p)[*blen - 1] = '\\0';\n\n\t\t \n\t\tif (err && !*err)\n\t\t\t*err = ret;\n\t} else {\n\t\t*buf_p += ret;\n\t\t*blen -= ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int arm_spe_pkt_desc_event(const struct arm_spe_pkt *packet,\n\t\t\t\t  char *buf, size_t buf_len)\n{\n\tu64 payload = packet->payload;\n\tint err = 0;\n\n\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \"EV\");\n\n\tif (payload & BIT(EV_EXCEPTION_GEN))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" EXCEPTION-GEN\");\n\tif (payload & BIT(EV_RETIRED))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" RETIRED\");\n\tif (payload & BIT(EV_L1D_ACCESS))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" L1D-ACCESS\");\n\tif (payload & BIT(EV_L1D_REFILL))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" L1D-REFILL\");\n\tif (payload & BIT(EV_TLB_ACCESS))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" TLB-ACCESS\");\n\tif (payload & BIT(EV_TLB_WALK))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" TLB-REFILL\");\n\tif (payload & BIT(EV_NOT_TAKEN))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" NOT-TAKEN\");\n\tif (payload & BIT(EV_MISPRED))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" MISPRED\");\n\tif (payload & BIT(EV_LLC_ACCESS))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" LLC-ACCESS\");\n\tif (payload & BIT(EV_LLC_MISS))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" LLC-REFILL\");\n\tif (payload & BIT(EV_REMOTE_ACCESS))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" REMOTE-ACCESS\");\n\tif (payload & BIT(EV_ALIGNMENT))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" ALIGNMENT\");\n\tif (payload & BIT(EV_PARTIAL_PREDICATE))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" SVE-PARTIAL-PRED\");\n\tif (payload & BIT(EV_EMPTY_PREDICATE))\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" SVE-EMPTY-PRED\");\n\n\treturn err;\n}\n\nstatic int arm_spe_pkt_desc_op_type(const struct arm_spe_pkt *packet,\n\t\t\t\t    char *buf, size_t buf_len)\n{\n\tu64 payload = packet->payload;\n\tint err = 0;\n\n\tswitch (packet->index) {\n\tcase SPE_OP_PKT_HDR_CLASS_OTHER:\n\t\tif (SPE_OP_PKT_IS_OTHER_SVE_OP(payload)) {\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \"SVE-OTHER\");\n\n\t\t\t \n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" EVLEN %d\",\n\t\t\t\t\t       SPE_OP_PKG_SVE_EVL(payload));\n\n\t\t\tif (payload & SPE_OP_PKT_SVE_FP)\n\t\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" FP\");\n\t\t\tif (payload & SPE_OP_PKT_SVE_PRED)\n\t\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" PRED\");\n\t\t} else {\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \"OTHER\");\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" %s\",\n\t\t\t\t\t       payload & SPE_OP_PKT_COND ?\n\t\t\t\t\t       \"COND-SELECT\" : \"INSN-OTHER\");\n\t\t}\n\t\tbreak;\n\tcase SPE_OP_PKT_HDR_CLASS_LD_ST_ATOMIC:\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len,\n\t\t\t\t       payload & 0x1 ? \"ST\" : \"LD\");\n\n\t\tif (SPE_OP_PKT_IS_LDST_ATOMIC(payload)) {\n\t\t\tif (payload & SPE_OP_PKT_AT)\n\t\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" AT\");\n\t\t\tif (payload & SPE_OP_PKT_EXCL)\n\t\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" EXCL\");\n\t\t\tif (payload & SPE_OP_PKT_AR)\n\t\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" AR\");\n\t\t}\n\n\t\tswitch (SPE_OP_PKT_LDST_SUBCLASS_GET(payload)) {\n\t\tcase SPE_OP_PKT_LDST_SUBCLASS_SIMD_FP:\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" SIMD-FP\");\n\t\t\tbreak;\n\t\tcase SPE_OP_PKT_LDST_SUBCLASS_GP_REG:\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" GP-REG\");\n\t\t\tbreak;\n\t\tcase SPE_OP_PKT_LDST_SUBCLASS_UNSPEC_REG:\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" UNSPEC-REG\");\n\t\t\tbreak;\n\t\tcase SPE_OP_PKT_LDST_SUBCLASS_NV_SYSREG:\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" NV-SYSREG\");\n\t\t\tbreak;\n\t\tcase SPE_OP_PKT_LDST_SUBCLASS_MTE_TAG:\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" MTE-TAG\");\n\t\t\tbreak;\n\t\tcase SPE_OP_PKT_LDST_SUBCLASS_MEMCPY:\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" MEMCPY\");\n\t\t\tbreak;\n\t\tcase SPE_OP_PKT_LDST_SUBCLASS_MEMSET:\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" MEMSET\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (SPE_OP_PKT_IS_LDST_SVE(payload)) {\n\t\t\t \n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" EVLEN %d\",\n\t\t\t\t\t       SPE_OP_PKG_SVE_EVL(payload));\n\n\t\t\tif (payload & SPE_OP_PKT_SVE_PRED)\n\t\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" PRED\");\n\t\t\tif (payload & SPE_OP_PKT_SVE_SG)\n\t\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" SG\");\n\t\t}\n\t\tbreak;\n\tcase SPE_OP_PKT_HDR_CLASS_BR_ERET:\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \"B\");\n\n\t\tif (payload & SPE_OP_PKT_COND)\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" COND\");\n\n\t\tif (SPE_OP_PKT_IS_INDIRECT_BRANCH(payload))\n\t\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \" IND\");\n\n\t\tbreak;\n\tdefault:\n\t\t \n\t\terr = -1;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int arm_spe_pkt_desc_addr(const struct arm_spe_pkt *packet,\n\t\t\t\t char *buf, size_t buf_len)\n{\n\tint ns, el, idx = packet->index;\n\tint ch, pat;\n\tu64 payload = packet->payload;\n\tint err = 0;\n\tstatic const char *idx_name[] = {\"PC\", \"TGT\", \"VA\", \"PA\", \"PBT\"};\n\n\tswitch (idx) {\n\tcase SPE_ADDR_PKT_HDR_INDEX_INS:\n\tcase SPE_ADDR_PKT_HDR_INDEX_BRANCH:\n\tcase SPE_ADDR_PKT_HDR_INDEX_PREV_BRANCH:\n\t\tns = !!SPE_ADDR_PKT_GET_NS(payload);\n\t\tel = SPE_ADDR_PKT_GET_EL(payload);\n\t\tpayload = SPE_ADDR_PKT_ADDR_GET_BYTES_0_6(payload);\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len,\n\t\t\t\t\"%s 0x%llx el%d ns=%d\",\n\t\t\t\tidx_name[idx], payload, el, ns);\n\t\tbreak;\n\tcase SPE_ADDR_PKT_HDR_INDEX_DATA_VIRT:\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len,\n\t\t\t\t       \"VA 0x%llx\", payload);\n\t\tbreak;\n\tcase SPE_ADDR_PKT_HDR_INDEX_DATA_PHYS:\n\t\tns = !!SPE_ADDR_PKT_GET_NS(payload);\n\t\tch = !!SPE_ADDR_PKT_GET_CH(payload);\n\t\tpat = SPE_ADDR_PKT_GET_PAT(payload);\n\t\tpayload = SPE_ADDR_PKT_ADDR_GET_BYTES_0_6(payload);\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len,\n\t\t\t\t       \"PA 0x%llx ns=%d ch=%d pat=%x\",\n\t\t\t\t       payload, ns, ch, pat);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\terr = -1;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int arm_spe_pkt_desc_counter(const struct arm_spe_pkt *packet,\n\t\t\t\t    char *buf, size_t buf_len)\n{\n\tu64 payload = packet->payload;\n\tconst char *name = arm_spe_pkt_name(packet->type);\n\tint err = 0;\n\n\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \"%s %d \", name,\n\t\t\t       (unsigned short)payload);\n\n\tswitch (packet->index) {\n\tcase SPE_CNT_PKT_HDR_INDEX_TOTAL_LAT:\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \"TOT\");\n\t\tbreak;\n\tcase SPE_CNT_PKT_HDR_INDEX_ISSUE_LAT:\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \"ISSUE\");\n\t\tbreak;\n\tcase SPE_CNT_PKT_HDR_INDEX_TRANS_LAT:\n\t\tarm_spe_pkt_out_string(&err, &buf, &buf_len, \"XLAT\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint arm_spe_pkt_desc(const struct arm_spe_pkt *packet, char *buf,\n\t\t     size_t buf_len)\n{\n\tint idx = packet->index;\n\tunsigned long long payload = packet->payload;\n\tconst char *name = arm_spe_pkt_name(packet->type);\n\tchar *buf_orig = buf;\n\tsize_t blen = buf_len;\n\tint err = 0;\n\n\tswitch (packet->type) {\n\tcase ARM_SPE_BAD:\n\tcase ARM_SPE_PAD:\n\tcase ARM_SPE_END:\n\t\tarm_spe_pkt_out_string(&err, &buf, &blen, \"%s\", name);\n\t\tbreak;\n\tcase ARM_SPE_EVENTS:\n\t\terr = arm_spe_pkt_desc_event(packet, buf, buf_len);\n\t\tbreak;\n\tcase ARM_SPE_OP_TYPE:\n\t\terr = arm_spe_pkt_desc_op_type(packet, buf, buf_len);\n\t\tbreak;\n\tcase ARM_SPE_DATA_SOURCE:\n\tcase ARM_SPE_TIMESTAMP:\n\t\tarm_spe_pkt_out_string(&err, &buf, &blen, \"%s %lld\", name, payload);\n\t\tbreak;\n\tcase ARM_SPE_ADDRESS:\n\t\terr = arm_spe_pkt_desc_addr(packet, buf, buf_len);\n\t\tbreak;\n\tcase ARM_SPE_CONTEXT:\n\t\tarm_spe_pkt_out_string(&err, &buf, &blen, \"%s 0x%lx el%d\",\n\t\t\t\t       name, (unsigned long)payload, idx + 1);\n\t\tbreak;\n\tcase ARM_SPE_COUNTER:\n\t\terr = arm_spe_pkt_desc_counter(packet, buf, buf_len);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\terr = -1;\n\t\tbreak;\n\t}\n\n\t \n\tif (err) {\n\t\terr = 0;\n\t\tarm_spe_pkt_out_string(&err, &buf_orig, &buf_len, \"%s 0x%llx (%d)\",\n\t\t\t\t       name, payload, packet->index);\n\t}\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}