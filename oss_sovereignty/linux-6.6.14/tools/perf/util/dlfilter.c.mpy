{
  "module_name": "dlfilter.c",
  "hash_id": "30b4254f8d3fc635b648a90d916e74a9513d82671706435a1a2676419b1a9eb8",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/dlfilter.c",
  "human_readable_source": "\n \n#include <dlfcn.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <subcmd/exec-cmd.h>\n#include <linux/zalloc.h>\n#include <linux/build_bug.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\n#include \"debug.h\"\n#include \"event.h\"\n#include \"evsel.h\"\n#include \"dso.h\"\n#include \"map.h\"\n#include \"thread.h\"\n#include \"trace-event.h\"\n#include \"symbol.h\"\n#include \"srcline.h\"\n#include \"dlfilter.h\"\n#include \"../include/perf/perf_dlfilter.h\"\n\nstatic void al_to_d_al(struct addr_location *al, struct perf_dlfilter_al *d_al)\n{\n\tstruct symbol *sym = al->sym;\n\n\td_al->size = sizeof(*d_al);\n\tif (al->map) {\n\t\tstruct dso *dso = map__dso(al->map);\n\n\t\tif (symbol_conf.show_kernel_path && dso->long_name)\n\t\t\td_al->dso = dso->long_name;\n\t\telse\n\t\t\td_al->dso = dso->name;\n\t\td_al->is_64_bit = dso->is_64_bit;\n\t\td_al->buildid_size = dso->bid.size;\n\t\td_al->buildid = dso->bid.data;\n\t} else {\n\t\td_al->dso = NULL;\n\t\td_al->is_64_bit = 0;\n\t\td_al->buildid_size = 0;\n\t\td_al->buildid = NULL;\n\t}\n\tif (sym) {\n\t\td_al->sym = sym->name;\n\t\td_al->sym_start = sym->start;\n\t\td_al->sym_end = sym->end;\n\t\tif (al->addr < sym->end)\n\t\t\td_al->symoff = al->addr - sym->start;\n\t\telse\n\t\t\td_al->symoff = al->addr - map__start(al->map) - sym->start;\n\t\td_al->sym_binding = sym->binding;\n\t} else {\n\t\td_al->sym = NULL;\n\t\td_al->sym_start = 0;\n\t\td_al->sym_end = 0;\n\t\td_al->symoff = 0;\n\t\td_al->sym_binding = 0;\n\t}\n\td_al->addr = al->addr;\n\td_al->comm = NULL;\n\td_al->filtered = 0;\n\td_al->priv = NULL;\n}\n\nstatic struct addr_location *get_al(struct dlfilter *d)\n{\n\tstruct addr_location *al = d->al;\n\n\tif (!al->thread && machine__resolve(d->machine, al, d->sample) < 0)\n\t\treturn NULL;\n\treturn al;\n}\n\nstatic struct thread *get_thread(struct dlfilter *d)\n{\n\tstruct addr_location *al = get_al(d);\n\n\treturn al ? al->thread : NULL;\n}\n\nstatic const struct perf_dlfilter_al *dlfilter__resolve_ip(void *ctx)\n{\n\tstruct dlfilter *d = (struct dlfilter *)ctx;\n\tstruct perf_dlfilter_al *d_al = d->d_ip_al;\n\tstruct addr_location *al;\n\n\tif (!d->ctx_valid)\n\t\treturn NULL;\n\n\t \n\tif (d_al->size)\n\t\treturn d_al;\n\n\tal = get_al(d);\n\tif (!al)\n\t\treturn NULL;\n\n\tal_to_d_al(al, d_al);\n\n\td_al->is_kernel_ip = machine__kernel_ip(d->machine, d->sample->ip);\n\td_al->comm = al->thread ? thread__comm_str(al->thread) : \":-1\";\n\td_al->filtered = al->filtered;\n\n\treturn d_al;\n}\n\nstatic const struct perf_dlfilter_al *dlfilter__resolve_addr(void *ctx)\n{\n\tstruct dlfilter *d = (struct dlfilter *)ctx;\n\tstruct perf_dlfilter_al *d_addr_al = d->d_addr_al;\n\tstruct addr_location *addr_al = d->addr_al;\n\n\tif (!d->ctx_valid || !d->d_sample->addr_correlates_sym)\n\t\treturn NULL;\n\n\t \n\tif (d_addr_al->size)\n\t\treturn d_addr_al;\n\n\tif (!addr_al->thread) {\n\t\tstruct thread *thread = get_thread(d);\n\n\t\tif (!thread)\n\t\t\treturn NULL;\n\t\tthread__resolve(thread, addr_al, d->sample);\n\t}\n\n\tal_to_d_al(addr_al, d_addr_al);\n\n\td_addr_al->is_kernel_ip = machine__kernel_ip(d->machine, d->sample->addr);\n\n\treturn d_addr_al;\n}\n\nstatic char **dlfilter__args(void *ctx, int *dlargc)\n{\n\tstruct dlfilter *d = (struct dlfilter *)ctx;\n\n\tif (dlargc)\n\t\t*dlargc = 0;\n\telse\n\t\treturn NULL;\n\n\tif (!d->ctx_valid && !d->in_start && !d->in_stop)\n\t\treturn NULL;\n\n\t*dlargc = d->dlargc;\n\treturn d->dlargv;\n}\n\nstatic bool has_priv(struct perf_dlfilter_al *d_al_p)\n{\n\treturn d_al_p->size >= offsetof(struct perf_dlfilter_al, priv) + sizeof(d_al_p->priv);\n}\n\nstatic __s32 dlfilter__resolve_address(void *ctx, __u64 address, struct perf_dlfilter_al *d_al_p)\n{\n\tstruct dlfilter *d = (struct dlfilter *)ctx;\n\tstruct perf_dlfilter_al d_al;\n\tstruct addr_location al;\n\tstruct thread *thread;\n\t__u32 sz;\n\n\tif (!d->ctx_valid || !d_al_p)\n\t\treturn -1;\n\n\tthread = get_thread(d);\n\tif (!thread)\n\t\treturn -1;\n\n\taddr_location__init(&al);\n\tthread__find_symbol_fb(thread, d->sample->cpumode, address, &al);\n\n\tal_to_d_al(&al, &d_al);\n\n\td_al.is_kernel_ip = machine__kernel_ip(d->machine, address);\n\n\tsz = d_al_p->size;\n\tmemcpy(d_al_p, &d_al, min((size_t)sz, sizeof(d_al)));\n\td_al_p->size = sz;\n\n\tif (has_priv(d_al_p))\n\t\td_al_p->priv = memdup(&al, sizeof(al));\n\telse  \n\t\taddr_location__exit(&al);\n\n\treturn 0;\n}\n\nstatic void dlfilter__al_cleanup(void *ctx __maybe_unused, struct perf_dlfilter_al *d_al_p)\n{\n\tstruct addr_location *al;\n\n\t \n\tif (!has_priv(d_al_p) || !d_al_p->priv)\n\t\treturn;\n\n\tal = d_al_p->priv;\n\n\td_al_p->priv = NULL;\n\n\taddr_location__exit(al);\n\n\tfree(al);\n}\n\nstatic const __u8 *dlfilter__insn(void *ctx, __u32 *len)\n{\n\tstruct dlfilter *d = (struct dlfilter *)ctx;\n\n\tif (!len)\n\t\treturn NULL;\n\n\t*len = 0;\n\n\tif (!d->ctx_valid)\n\t\treturn NULL;\n\n\tif (d->sample->ip && !d->sample->insn_len) {\n\t\tstruct addr_location *al = d->al;\n\n\t\tif (!al->thread && machine__resolve(d->machine, al, d->sample) < 0)\n\t\t\treturn NULL;\n\n\t\tif (thread__maps(al->thread)) {\n\t\t\tstruct machine *machine = maps__machine(thread__maps(al->thread));\n\n\t\t\tif (machine)\n\t\t\t\tscript_fetch_insn(d->sample, al->thread, machine);\n\t\t}\n\t}\n\n\tif (!d->sample->insn_len)\n\t\treturn NULL;\n\n\t*len = d->sample->insn_len;\n\n\treturn (__u8 *)d->sample->insn;\n}\n\nstatic const char *dlfilter__srcline(void *ctx, __u32 *line_no)\n{\n\tstruct dlfilter *d = (struct dlfilter *)ctx;\n\tstruct addr_location *al;\n\tunsigned int line = 0;\n\tchar *srcfile = NULL;\n\tstruct map *map;\n\tstruct dso *dso;\n\tu64 addr;\n\n\tif (!d->ctx_valid || !line_no)\n\t\treturn NULL;\n\n\tal = get_al(d);\n\tif (!al)\n\t\treturn NULL;\n\n\tmap = al->map;\n\taddr = al->addr;\n\tdso = map ? map__dso(map) : NULL;\n\n\tif (dso)\n\t\tsrcfile = get_srcline_split(dso, map__rip_2objdump(map, addr), &line);\n\n\t*line_no = line;\n\treturn srcfile;\n}\n\nstatic struct perf_event_attr *dlfilter__attr(void *ctx)\n{\n\tstruct dlfilter *d = (struct dlfilter *)ctx;\n\n\tif (!d->ctx_valid)\n\t\treturn NULL;\n\n\treturn &d->evsel->core.attr;\n}\n\nstatic __s32 code_read(__u64 ip, struct map *map, struct machine *machine, void *buf, __u32 len)\n{\n\tu64 offset = map__map_ip(map, ip);\n\n\tif (ip + len >= map__end(map))\n\t\tlen = map__end(map) - ip;\n\n\treturn dso__data_read_offset(map__dso(map), machine, offset, buf, len);\n}\n\nstatic __s32 dlfilter__object_code(void *ctx, __u64 ip, void *buf, __u32 len)\n{\n\tstruct dlfilter *d = (struct dlfilter *)ctx;\n\tstruct addr_location *al;\n\tstruct addr_location a;\n\t__s32 ret;\n\n\tif (!d->ctx_valid)\n\t\treturn -1;\n\n\tal = get_al(d);\n\tif (!al)\n\t\treturn -1;\n\n\tif (al->map && ip >= map__start(al->map) && ip < map__end(al->map) &&\n\t    machine__kernel_ip(d->machine, ip) == machine__kernel_ip(d->machine, d->sample->ip))\n\t\treturn code_read(ip, al->map, d->machine, buf, len);\n\n\taddr_location__init(&a);\n\n\tthread__find_map_fb(al->thread, d->sample->cpumode, ip, &a);\n\tret = a.map ? code_read(ip, a.map, d->machine, buf, len) : -1;\n\n\taddr_location__exit(&a);\n\n\treturn ret;\n}\n\nstatic const struct perf_dlfilter_fns perf_dlfilter_fns = {\n\t.resolve_ip      = dlfilter__resolve_ip,\n\t.resolve_addr    = dlfilter__resolve_addr,\n\t.args            = dlfilter__args,\n\t.resolve_address = dlfilter__resolve_address,\n\t.al_cleanup      = dlfilter__al_cleanup,\n\t.insn            = dlfilter__insn,\n\t.srcline         = dlfilter__srcline,\n\t.attr            = dlfilter__attr,\n\t.object_code     = dlfilter__object_code,\n};\n\nstatic char *find_dlfilter(const char *file)\n{\n\tchar path[PATH_MAX];\n\tchar *exec_path;\n\n\tif (strchr(file, '/'))\n\t\tgoto out;\n\n\tif (!access(file, R_OK)) {\n\t\t \n\t\tsnprintf(path, sizeof(path), \"./%s\", file);\n\t\tfile = path;\n\t\tgoto out;\n\t}\n\n\texec_path = get_argv_exec_path();\n\tif (!exec_path)\n\t\tgoto out;\n\tsnprintf(path, sizeof(path), \"%s/dlfilters/%s\", exec_path, file);\n\tfree(exec_path);\n\tif (!access(path, R_OK))\n\t\tfile = path;\nout:\n\treturn strdup(file);\n}\n\n#define CHECK_FLAG(x) BUILD_BUG_ON((u64)PERF_DLFILTER_FLAG_ ## x != (u64)PERF_IP_FLAG_ ## x)\n\nstatic int dlfilter__init(struct dlfilter *d, const char *file, int dlargc, char **dlargv)\n{\n\tCHECK_FLAG(BRANCH);\n\tCHECK_FLAG(CALL);\n\tCHECK_FLAG(RETURN);\n\tCHECK_FLAG(CONDITIONAL);\n\tCHECK_FLAG(SYSCALLRET);\n\tCHECK_FLAG(ASYNC);\n\tCHECK_FLAG(INTERRUPT);\n\tCHECK_FLAG(TX_ABORT);\n\tCHECK_FLAG(TRACE_BEGIN);\n\tCHECK_FLAG(TRACE_END);\n\tCHECK_FLAG(IN_TX);\n\tCHECK_FLAG(VMENTRY);\n\tCHECK_FLAG(VMEXIT);\n\n\tmemset(d, 0, sizeof(*d));\n\td->file = find_dlfilter(file);\n\tif (!d->file)\n\t\treturn -1;\n\td->dlargc = dlargc;\n\td->dlargv = dlargv;\n\treturn 0;\n}\n\nstatic void dlfilter__exit(struct dlfilter *d)\n{\n\tzfree(&d->file);\n}\n\nstatic int dlfilter__open(struct dlfilter *d)\n{\n\td->handle = dlopen(d->file, RTLD_NOW);\n\tif (!d->handle) {\n\t\tpr_err(\"dlopen failed for: '%s'\\n\", d->file);\n\t\treturn -1;\n\t}\n\td->start = dlsym(d->handle, \"start\");\n\td->filter_event = dlsym(d->handle, \"filter_event\");\n\td->filter_event_early = dlsym(d->handle, \"filter_event_early\");\n\td->stop = dlsym(d->handle, \"stop\");\n\td->fns = dlsym(d->handle, \"perf_dlfilter_fns\");\n\tif (d->fns)\n\t\tmemcpy(d->fns, &perf_dlfilter_fns, sizeof(struct perf_dlfilter_fns));\n\treturn 0;\n}\n\nstatic int dlfilter__close(struct dlfilter *d)\n{\n\treturn dlclose(d->handle);\n}\n\nstruct dlfilter *dlfilter__new(const char *file, int dlargc, char **dlargv)\n{\n\tstruct dlfilter *d = malloc(sizeof(*d));\n\n\tif (!d)\n\t\treturn NULL;\n\n\tif (dlfilter__init(d, file, dlargc, dlargv))\n\t\tgoto err_free;\n\n\tif (dlfilter__open(d))\n\t\tgoto err_exit;\n\n\treturn d;\n\nerr_exit:\n\tdlfilter__exit(d);\nerr_free:\n\tfree(d);\n\treturn NULL;\n}\n\nstatic void dlfilter__free(struct dlfilter *d)\n{\n\tif (d) {\n\t\tdlfilter__exit(d);\n\t\tfree(d);\n\t}\n}\n\nint dlfilter__start(struct dlfilter *d, struct perf_session *session)\n{\n\tif (d) {\n\t\td->session = session;\n\t\tif (d->start) {\n\t\t\tint ret;\n\n\t\t\td->in_start = true;\n\t\t\tret = d->start(&d->data, d);\n\t\t\td->in_start = false;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dlfilter__stop(struct dlfilter *d)\n{\n\tif (d && d->stop) {\n\t\tint ret;\n\n\t\td->in_stop = true;\n\t\tret = d->stop(d->data, d);\n\t\td->in_stop = false;\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nvoid dlfilter__cleanup(struct dlfilter *d)\n{\n\tif (d) {\n\t\tdlfilter__stop(d);\n\t\tdlfilter__close(d);\n\t\tdlfilter__free(d);\n\t}\n}\n\n#define ASSIGN(x) d_sample.x = sample->x\n\nint dlfilter__do_filter_event(struct dlfilter *d,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample,\n\t\t\t      struct evsel *evsel,\n\t\t\t      struct machine *machine,\n\t\t\t      struct addr_location *al,\n\t\t\t      struct addr_location *addr_al,\n\t\t\t      bool early)\n{\n\tstruct perf_dlfilter_sample d_sample;\n\tstruct perf_dlfilter_al d_ip_al;\n\tstruct perf_dlfilter_al d_addr_al;\n\tint ret;\n\n\td->event       = event;\n\td->sample      = sample;\n\td->evsel       = evsel;\n\td->machine     = machine;\n\td->al          = al;\n\td->addr_al     = addr_al;\n\td->d_sample    = &d_sample;\n\td->d_ip_al     = &d_ip_al;\n\td->d_addr_al   = &d_addr_al;\n\n\td_sample.size  = sizeof(d_sample);\n\td_ip_al.size   = 0;  \n\td_addr_al.size = 0;  \n\n\tASSIGN(ip);\n\tASSIGN(pid);\n\tASSIGN(tid);\n\tASSIGN(time);\n\tASSIGN(addr);\n\tASSIGN(id);\n\tASSIGN(stream_id);\n\tASSIGN(period);\n\tASSIGN(weight);\n\tASSIGN(ins_lat);\n\tASSIGN(p_stage_cyc);\n\tASSIGN(transaction);\n\tASSIGN(insn_cnt);\n\tASSIGN(cyc_cnt);\n\tASSIGN(cpu);\n\tASSIGN(flags);\n\tASSIGN(data_src);\n\tASSIGN(phys_addr);\n\tASSIGN(data_page_size);\n\tASSIGN(code_page_size);\n\tASSIGN(cgroup);\n\tASSIGN(cpumode);\n\tASSIGN(misc);\n\tASSIGN(raw_size);\n\tASSIGN(raw_data);\n\tASSIGN(machine_pid);\n\tASSIGN(vcpu);\n\n\tif (sample->branch_stack) {\n\t\td_sample.brstack_nr = sample->branch_stack->nr;\n\t\td_sample.brstack = (struct perf_branch_entry *)perf_sample__branch_entries(sample);\n\t} else {\n\t\td_sample.brstack_nr = 0;\n\t\td_sample.brstack = NULL;\n\t}\n\n\tif (sample->callchain) {\n\t\td_sample.raw_callchain_nr = sample->callchain->nr;\n\t\td_sample.raw_callchain = (__u64 *)sample->callchain->ips;\n\t} else {\n\t\td_sample.raw_callchain_nr = 0;\n\t\td_sample.raw_callchain = NULL;\n\t}\n\n\td_sample.addr_correlates_sym =\n\t\t(evsel->core.attr.sample_type & PERF_SAMPLE_ADDR) &&\n\t\tsample_addr_correlates_sym(&evsel->core.attr);\n\n\td_sample.event = evsel__name(evsel);\n\n\td->ctx_valid = true;\n\n\tif (early)\n\t\tret = d->filter_event_early(d->data, &d_sample, d);\n\telse\n\t\tret = d->filter_event(d->data, &d_sample, d);\n\n\td->ctx_valid = false;\n\n\treturn ret;\n}\n\nbool get_filter_desc(const char *dirname, const char *name, char **desc,\n\t\t     char **long_desc)\n{\n\tchar path[PATH_MAX];\n\tvoid *handle;\n\tconst char *(*desc_fn)(const char **long_description);\n\n\tsnprintf(path, sizeof(path), \"%s/%s\", dirname, name);\n\thandle = dlopen(path, RTLD_NOW);\n\tif (!handle || !(dlsym(handle, \"filter_event\") || dlsym(handle, \"filter_event_early\")))\n\t\treturn false;\n\tdesc_fn = dlsym(handle, \"filter_description\");\n\tif (desc_fn) {\n\t\tconst char *dsc;\n\t\tconst char *long_dsc;\n\n\t\tdsc = desc_fn(&long_dsc);\n\t\tif (dsc)\n\t\t\t*desc = strdup(dsc);\n\t\tif (long_dsc)\n\t\t\t*long_desc = strdup(long_dsc);\n\t}\n\tdlclose(handle);\n\treturn true;\n}\n\nstatic void list_filters(const char *dirname)\n{\n\tstruct dirent *entry;\n\tDIR *dir;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn;\n\n\twhile ((entry = readdir(dir)) != NULL)\n\t{\n\t\tsize_t n = strlen(entry->d_name);\n\t\tchar *long_desc = NULL;\n\t\tchar *desc = NULL;\n\n\t\tif (entry->d_type == DT_DIR || n < 4 ||\n\t\t    strcmp(\".so\", entry->d_name + n - 3))\n\t\t\tcontinue;\n\t\tif (!get_filter_desc(dirname, entry->d_name, &desc, &long_desc))\n\t\t\tcontinue;\n\t\tprintf(\"  %-36s %s\\n\", entry->d_name, desc ? desc : \"\");\n\t\tif (verbose > 0) {\n\t\t\tchar *p = long_desc;\n\t\t\tchar *line;\n\n\t\t\twhile ((line = strsep(&p, \"\\n\")) != NULL)\n\t\t\t\tprintf(\"%39s%s\\n\", \"\", line);\n\t\t}\n\t\tfree(long_desc);\n\t\tfree(desc);\n\t}\n\n\tclosedir(dir);\n}\n\nint list_available_dlfilters(const struct option *opt __maybe_unused,\n\t\t\t     const char *s __maybe_unused,\n\t\t\t     int unset __maybe_unused)\n{\n\tchar path[PATH_MAX];\n\tchar *exec_path;\n\n\tprintf(\"List of available dlfilters:\\n\");\n\n\tlist_filters(\".\");\n\n\texec_path = get_argv_exec_path();\n\tif (!exec_path)\n\t\tgoto out;\n\tsnprintf(path, sizeof(path), \"%s/dlfilters\", exec_path);\n\n\tlist_filters(path);\n\n\tfree(exec_path);\nout:\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}