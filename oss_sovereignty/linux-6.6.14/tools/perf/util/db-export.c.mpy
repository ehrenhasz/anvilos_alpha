{
  "module_name": "db-export.c",
  "hash_id": "989fe66b218a9f916413c89506394b35f50e042855a5e225749c6d6783464c7d",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/db-export.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <stdlib.h>\n\n#include \"dso.h\"\n#include \"evsel.h\"\n#include \"machine.h\"\n#include \"thread.h\"\n#include \"comm.h\"\n#include \"symbol.h\"\n#include \"map.h\"\n#include \"event.h\"\n#include \"thread-stack.h\"\n#include \"callchain.h\"\n#include \"call-path.h\"\n#include \"db-export.h\"\n#include <linux/zalloc.h>\n\nint db_export__init(struct db_export *dbe)\n{\n\tmemset(dbe, 0, sizeof(struct db_export));\n\treturn 0;\n}\n\nvoid db_export__exit(struct db_export *dbe)\n{\n\tcall_return_processor__free(dbe->crp);\n\tdbe->crp = NULL;\n}\n\nint db_export__evsel(struct db_export *dbe, struct evsel *evsel)\n{\n\tif (evsel->db_id)\n\t\treturn 0;\n\n\tevsel->db_id = ++dbe->evsel_last_db_id;\n\n\tif (dbe->export_evsel)\n\t\treturn dbe->export_evsel(dbe, evsel);\n\n\treturn 0;\n}\n\nint db_export__machine(struct db_export *dbe, struct machine *machine)\n{\n\tif (machine->db_id)\n\t\treturn 0;\n\n\tmachine->db_id = ++dbe->machine_last_db_id;\n\n\tif (dbe->export_machine)\n\t\treturn dbe->export_machine(dbe, machine);\n\n\treturn 0;\n}\n\nint db_export__thread(struct db_export *dbe, struct thread *thread,\n\t\t      struct machine *machine, struct thread *main_thread)\n{\n\tu64 main_thread_db_id = 0;\n\n\tif (thread__db_id(thread))\n\t\treturn 0;\n\n\tthread__set_db_id(thread, ++dbe->thread_last_db_id);\n\n\tif (main_thread)\n\t\tmain_thread_db_id = thread__db_id(main_thread);\n\n\tif (dbe->export_thread)\n\t\treturn dbe->export_thread(dbe, thread, main_thread_db_id,\n\t\t\t\t\t  machine);\n\n\treturn 0;\n}\n\nstatic int __db_export__comm(struct db_export *dbe, struct comm *comm,\n\t\t\t     struct thread *thread)\n{\n\tcomm->db_id = ++dbe->comm_last_db_id;\n\n\tif (dbe->export_comm)\n\t\treturn dbe->export_comm(dbe, comm, thread);\n\n\treturn 0;\n}\n\nint db_export__comm(struct db_export *dbe, struct comm *comm,\n\t\t    struct thread *thread)\n{\n\tif (comm->db_id)\n\t\treturn 0;\n\n\treturn __db_export__comm(dbe, comm, thread);\n}\n\n \nint db_export__exec_comm(struct db_export *dbe, struct comm *comm,\n\t\t\t struct thread *main_thread)\n{\n\tint err;\n\n\tif (comm->db_id)\n\t\treturn 0;\n\n\terr = __db_export__comm(dbe, comm, main_thread);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn db_export__comm_thread(dbe, comm, main_thread);\n}\n\nint db_export__comm_thread(struct db_export *dbe, struct comm *comm,\n\t\t\t   struct thread *thread)\n{\n\tu64 db_id;\n\n\tdb_id = ++dbe->comm_thread_last_db_id;\n\n\tif (dbe->export_comm_thread)\n\t\treturn dbe->export_comm_thread(dbe, db_id, comm, thread);\n\n\treturn 0;\n}\n\nint db_export__dso(struct db_export *dbe, struct dso *dso,\n\t\t   struct machine *machine)\n{\n\tif (dso->db_id)\n\t\treturn 0;\n\n\tdso->db_id = ++dbe->dso_last_db_id;\n\n\tif (dbe->export_dso)\n\t\treturn dbe->export_dso(dbe, dso, machine);\n\n\treturn 0;\n}\n\nint db_export__symbol(struct db_export *dbe, struct symbol *sym,\n\t\t      struct dso *dso)\n{\n\tu64 *sym_db_id = symbol__priv(sym);\n\n\tif (*sym_db_id)\n\t\treturn 0;\n\n\t*sym_db_id = ++dbe->symbol_last_db_id;\n\n\tif (dbe->export_symbol)\n\t\treturn dbe->export_symbol(dbe, sym, dso);\n\n\treturn 0;\n}\n\nstatic int db_ids_from_al(struct db_export *dbe, struct addr_location *al,\n\t\t\t  u64 *dso_db_id, u64 *sym_db_id, u64 *offset)\n{\n\tint err;\n\n\tif (al->map) {\n\t\tstruct dso *dso = map__dso(al->map);\n\n\t\terr = db_export__dso(dbe, dso, maps__machine(al->maps));\n\t\tif (err)\n\t\t\treturn err;\n\t\t*dso_db_id = dso->db_id;\n\n\t\tif (!al->sym) {\n\t\t\tal->sym = symbol__new(al->addr, 0, 0, 0, \"unknown\");\n\t\t\tif (al->sym)\n\t\t\t\tdso__insert_symbol(dso, al->sym);\n\t\t}\n\n\t\tif (al->sym) {\n\t\t\tu64 *db_id = symbol__priv(al->sym);\n\n\t\t\terr = db_export__symbol(dbe, al->sym, dso);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t*sym_db_id = *db_id;\n\t\t\t*offset = al->addr - al->sym->start;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct call_path *call_path_from_sample(struct db_export *dbe,\n\t\t\t\t\t       struct machine *machine,\n\t\t\t\t\t       struct thread *thread,\n\t\t\t\t\t       struct perf_sample *sample,\n\t\t\t\t\t       struct evsel *evsel)\n{\n\tu64 kernel_start = machine__kernel_start(machine);\n\tstruct call_path *current = &dbe->cpr->call_path;\n\tenum chain_order saved_order = callchain_param.order;\n\tstruct callchain_cursor *cursor;\n\tint err;\n\n\tif (!symbol_conf.use_callchain || !sample->callchain)\n\t\treturn NULL;\n\n\t \n\tcallchain_param.order = ORDER_CALLER;\n\tcursor = get_tls_callchain_cursor();\n\terr = thread__resolve_callchain(thread, cursor, evsel,\n\t\t\t\t\tsample, NULL, NULL, PERF_MAX_STACK_DEPTH);\n\tif (err) {\n\t\tcallchain_param.order = saved_order;\n\t\treturn NULL;\n\t}\n\tcallchain_cursor_commit(cursor);\n\n\twhile (1) {\n\t\tstruct callchain_cursor_node *node;\n\t\tstruct addr_location al;\n\t\tu64 dso_db_id = 0, sym_db_id = 0, offset = 0;\n\n\n\t\tnode = callchain_cursor_current(cursor);\n\t\tif (!node)\n\t\t\tbreak;\n\n\t\t \n\t\taddr_location__init(&al);\n\t\tal.sym = node->ms.sym;\n\t\tal.map = map__get(node->ms.map);\n\t\tal.maps = maps__get(thread__maps(thread));\n\t\tal.addr = node->ip;\n\n\t\tif (al.map && !al.sym)\n\t\t\tal.sym = dso__find_symbol(map__dso(al.map), al.addr);\n\n\t\tdb_ids_from_al(dbe, &al, &dso_db_id, &sym_db_id, &offset);\n\n\t\t \n\t\tcurrent = call_path__findnew(dbe->cpr, current,\n\t\t\t\t\t     al.sym, node->ip,\n\t\t\t\t\t     kernel_start);\n\n\t\tcallchain_cursor_advance(cursor);\n\t\taddr_location__exit(&al);\n\t}\n\n\t \n\tcallchain_param.order = saved_order;\n\n\tif (current == &dbe->cpr->call_path) {\n\t\t \n\t\treturn NULL;\n\t}\n\n\treturn current;\n}\n\nint db_export__branch_type(struct db_export *dbe, u32 branch_type,\n\t\t\t   const char *name)\n{\n\tif (dbe->export_branch_type)\n\t\treturn dbe->export_branch_type(dbe, branch_type, name);\n\n\treturn 0;\n}\n\nstatic int db_export__threads(struct db_export *dbe, struct thread *thread,\n\t\t\t      struct thread *main_thread,\n\t\t\t      struct machine *machine, struct comm **comm_ptr)\n{\n\tstruct comm *comm = NULL;\n\tstruct comm *curr_comm;\n\tint err;\n\n\tif (main_thread) {\n\t\t \n\t\terr = db_export__thread(dbe, main_thread, machine, main_thread);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\tcomm = machine__thread_exec_comm(machine, main_thread);\n\t\tif (comm) {\n\t\t\terr = db_export__exec_comm(dbe, comm, main_thread);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t*comm_ptr = comm;\n\t\t}\n\t}\n\n\tif (thread != main_thread) {\n\t\t \n\t\tbool export_comm_thread = comm && !thread__db_id(thread);\n\n\t\terr = db_export__thread(dbe, thread, machine, main_thread);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (export_comm_thread) {\n\t\t\terr = db_export__comm_thread(dbe, comm, thread);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tcurr_comm = thread__comm(thread);\n\tif (curr_comm)\n\t\treturn db_export__comm(dbe, curr_comm, thread);\n\n\treturn 0;\n}\n\nint db_export__sample(struct db_export *dbe, union perf_event *event,\n\t\t      struct perf_sample *sample, struct evsel *evsel,\n\t\t      struct addr_location *al, struct addr_location *addr_al)\n{\n\tstruct thread *thread = al->thread;\n\tstruct export_sample es = {\n\t\t.event = event,\n\t\t.sample = sample,\n\t\t.evsel = evsel,\n\t\t.al = al,\n\t};\n\tstruct thread *main_thread;\n\tstruct comm *comm = NULL;\n\tstruct machine *machine;\n\tint err;\n\n\terr = db_export__evsel(dbe, evsel);\n\tif (err)\n\t\treturn err;\n\n\tmachine = maps__machine(al->maps);\n\terr = db_export__machine(dbe, machine);\n\tif (err)\n\t\treturn err;\n\n\tmain_thread = thread__main_thread(machine, thread);\n\n\terr = db_export__threads(dbe, thread, main_thread, machine, &comm);\n\tif (err)\n\t\tgoto out_put;\n\n\tif (comm)\n\t\tes.comm_db_id = comm->db_id;\n\n\tes.db_id = ++dbe->sample_last_db_id;\n\n\terr = db_ids_from_al(dbe, al, &es.dso_db_id, &es.sym_db_id, &es.offset);\n\tif (err)\n\t\tgoto out_put;\n\n\tif (dbe->cpr) {\n\t\tstruct call_path *cp = call_path_from_sample(dbe, machine,\n\t\t\t\t\t\t\t     thread, sample,\n\t\t\t\t\t\t\t     evsel);\n\t\tif (cp) {\n\t\t\tdb_export__call_path(dbe, cp);\n\t\t\tes.call_path_id = cp->db_id;\n\t\t}\n\t}\n\n\tif (addr_al) {\n\t\terr = db_ids_from_al(dbe, addr_al, &es.addr_dso_db_id,\n\t\t\t\t     &es.addr_sym_db_id, &es.addr_offset);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t\tif (dbe->crp) {\n\t\t\terr = thread_stack__process(thread, comm, sample, al,\n\t\t\t\t\t\t    addr_al, es.db_id,\n\t\t\t\t\t\t    dbe->crp);\n\t\t\tif (err)\n\t\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tif (dbe->export_sample)\n\t\terr = dbe->export_sample(dbe, &es);\n\nout_put:\n\tthread__put(main_thread);\n\treturn err;\n}\n\nstatic struct {\n\tu32 branch_type;\n\tconst char *name;\n} branch_types[] = {\n\t{0, \"no branch\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL, \"call\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_RETURN, \"return\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CONDITIONAL, \"conditional jump\"},\n\t{PERF_IP_FLAG_BRANCH, \"unconditional jump\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL | PERF_IP_FLAG_INTERRUPT,\n\t \"software interrupt\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_RETURN | PERF_IP_FLAG_INTERRUPT,\n\t \"return from interrupt\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL | PERF_IP_FLAG_SYSCALLRET,\n\t \"system call\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_RETURN | PERF_IP_FLAG_SYSCALLRET,\n\t \"return from system call\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_ASYNC, \"asynchronous branch\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL | PERF_IP_FLAG_ASYNC |\n\t PERF_IP_FLAG_INTERRUPT, \"hardware interrupt\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_TX_ABORT, \"transaction abort\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_TRACE_BEGIN, \"trace begin\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_TRACE_END, \"trace end\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL | PERF_IP_FLAG_VMENTRY, \"vm entry\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL | PERF_IP_FLAG_VMEXIT, \"vm exit\"},\n\t{0, NULL}\n};\n\nint db_export__branch_types(struct db_export *dbe)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; branch_types[i].name ; i++) {\n\t\terr = db_export__branch_type(dbe, branch_types[i].branch_type,\n\t\t\t\t\t     branch_types[i].name);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0; branch_types[i].name ; i++) {\n\t\tconst char *name = branch_types[i].name;\n\t\tu32 type = branch_types[i].branch_type;\n\t\tchar buf[64];\n\n\t\tif (type == PERF_IP_FLAG_BRANCH ||\n\t\t    (type & (PERF_IP_FLAG_TRACE_BEGIN | PERF_IP_FLAG_TRACE_END)))\n\t\t\tcontinue;\n\n\t\tsnprintf(buf, sizeof(buf), \"trace begin / %s\", name);\n\t\terr = db_export__branch_type(dbe, type | PERF_IP_FLAG_TRACE_BEGIN, buf);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tsnprintf(buf, sizeof(buf), \"%s / trace end\", name);\n\t\terr = db_export__branch_type(dbe, type | PERF_IP_FLAG_TRACE_END, buf);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint db_export__call_path(struct db_export *dbe, struct call_path *cp)\n{\n\tint err;\n\n\tif (cp->db_id)\n\t\treturn 0;\n\n\tif (cp->parent) {\n\t\terr = db_export__call_path(dbe, cp->parent);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcp->db_id = ++dbe->call_path_last_db_id;\n\n\tif (dbe->export_call_path)\n\t\treturn dbe->export_call_path(dbe, cp);\n\n\treturn 0;\n}\n\nint db_export__call_return(struct db_export *dbe, struct call_return *cr,\n\t\t\t   u64 *parent_db_id)\n{\n\tint err;\n\n\terr = db_export__call_path(dbe, cr->cp);\n\tif (err)\n\t\treturn err;\n\n\tif (!cr->db_id)\n\t\tcr->db_id = ++dbe->call_return_last_db_id;\n\n\tif (parent_db_id) {\n\t\tif (!*parent_db_id)\n\t\t\t*parent_db_id = ++dbe->call_return_last_db_id;\n\t\tcr->parent_db_id = *parent_db_id;\n\t}\n\n\tif (dbe->export_call_return)\n\t\treturn dbe->export_call_return(dbe, cr);\n\n\treturn 0;\n}\n\nstatic int db_export__pid_tid(struct db_export *dbe, struct machine *machine,\n\t\t\t      pid_t pid, pid_t tid, u64 *db_id,\n\t\t\t      struct comm **comm_ptr, bool *is_idle)\n{\n\tstruct thread *thread = machine__find_thread(machine, pid, tid);\n\tstruct thread *main_thread;\n\tint err = 0;\n\n\tif (!thread || !thread__comm_set(thread))\n\t\tgoto out_put;\n\n\t*is_idle = !thread__pid(thread) && !thread__tid(thread);\n\n\tmain_thread = thread__main_thread(machine, thread);\n\n\terr = db_export__threads(dbe, thread, main_thread, machine, comm_ptr);\n\n\t*db_id = thread__db_id(thread);\n\n\tthread__put(main_thread);\nout_put:\n\tthread__put(thread);\n\n\treturn err;\n}\n\nint db_export__switch(struct db_export *dbe, union perf_event *event,\n\t\t      struct perf_sample *sample, struct machine *machine)\n{\n\tbool out = event->header.misc & PERF_RECORD_MISC_SWITCH_OUT;\n\tbool out_preempt = out &&\n\t\t(event->header.misc & PERF_RECORD_MISC_SWITCH_OUT_PREEMPT);\n\tint flags = out | (out_preempt << 1);\n\tbool is_idle_a = false, is_idle_b = false;\n\tu64 th_a_id = 0, th_b_id = 0;\n\tu64 comm_out_id, comm_in_id;\n\tstruct comm *comm_a = NULL;\n\tstruct comm *comm_b = NULL;\n\tu64 th_out_id, th_in_id;\n\tu64 db_id;\n\tint err;\n\n\terr = db_export__machine(dbe, machine);\n\tif (err)\n\t\treturn err;\n\n\terr = db_export__pid_tid(dbe, machine, sample->pid, sample->tid,\n\t\t\t\t &th_a_id, &comm_a, &is_idle_a);\n\tif (err)\n\t\treturn err;\n\n\tif (event->header.type == PERF_RECORD_SWITCH_CPU_WIDE) {\n\t\tpid_t pid = event->context_switch.next_prev_pid;\n\t\tpid_t tid = event->context_switch.next_prev_tid;\n\n\t\terr = db_export__pid_tid(dbe, machine, pid, tid, &th_b_id,\n\t\t\t\t\t &comm_b, &is_idle_b);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif ((!th_a_id || is_idle_a) && (!th_b_id || is_idle_b))\n\t\treturn 0;\n\n\tdb_id = ++dbe->context_switch_last_db_id;\n\n\tif (out) {\n\t\tth_out_id   = th_a_id;\n\t\tth_in_id    = th_b_id;\n\t\tcomm_out_id = comm_a ? comm_a->db_id : 0;\n\t\tcomm_in_id  = comm_b ? comm_b->db_id : 0;\n\t} else {\n\t\tth_out_id   = th_b_id;\n\t\tth_in_id    = th_a_id;\n\t\tcomm_out_id = comm_b ? comm_b->db_id : 0;\n\t\tcomm_in_id  = comm_a ? comm_a->db_id : 0;\n\t}\n\n\tif (dbe->export_context_switch)\n\t\treturn dbe->export_context_switch(dbe, db_id, machine, sample,\n\t\t\t\t\t\t  th_out_id, comm_out_id,\n\t\t\t\t\t\t  th_in_id, comm_in_id, flags);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}