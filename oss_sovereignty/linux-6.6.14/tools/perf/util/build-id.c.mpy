{
  "module_name": "build-id.c",
  "hash_id": "ce9b5aefa9781566d8e734e67be8e20812a022d707de6712eb9582de2b0165fa",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/build-id.c",
  "human_readable_source": "\n \n#include \"util.h\" \n#include <dirent.h>\n#include <errno.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"util/copyfile.h\"\n#include \"dso.h\"\n#include \"build-id.h\"\n#include \"event.h\"\n#include \"namespaces.h\"\n#include \"map.h\"\n#include \"symbol.h\"\n#include \"thread.h\"\n#include <linux/kernel.h>\n#include \"debug.h\"\n#include \"session.h\"\n#include \"tool.h\"\n#include \"header.h\"\n#include \"vdso.h\"\n#include \"path.h\"\n#include \"probe-file.h\"\n#include \"strlist.h\"\n\n#ifdef HAVE_DEBUGINFOD_SUPPORT\n#include <elfutils/debuginfod.h>\n#endif\n\n#include <linux/ctype.h>\n#include <linux/zalloc.h>\n#include <linux/string.h>\n#include <asm/bug.h>\n\nstatic bool no_buildid_cache;\n\nint build_id__mark_dso_hit(struct perf_tool *tool __maybe_unused,\n\t\t\t   union perf_event *event,\n\t\t\t   struct perf_sample *sample,\n\t\t\t   struct evsel *evsel __maybe_unused,\n\t\t\t   struct machine *machine)\n{\n\tstruct addr_location al;\n\tstruct thread *thread = machine__findnew_thread(machine, sample->pid,\n\t\t\t\t\t\t\tsample->tid);\n\n\tif (thread == NULL) {\n\t\tpr_err(\"problem processing %d event, skipping it.\\n\",\n\t\t\tevent->header.type);\n\t\treturn -1;\n\t}\n\n\taddr_location__init(&al);\n\tif (thread__find_map(thread, sample->cpumode, sample->ip, &al))\n\t\tmap__dso(al.map)->hit = 1;\n\n\taddr_location__exit(&al);\n\tthread__put(thread);\n\treturn 0;\n}\n\nstatic int perf_event__exit_del_thread(struct perf_tool *tool __maybe_unused,\n\t\t\t\t       union perf_event *event,\n\t\t\t\t       struct perf_sample *sample\n\t\t\t\t       __maybe_unused,\n\t\t\t\t       struct machine *machine)\n{\n\tstruct thread *thread = machine__findnew_thread(machine,\n\t\t\t\t\t\t\tevent->fork.pid,\n\t\t\t\t\t\t\tevent->fork.tid);\n\n\tdump_printf(\"(%d:%d):(%d:%d)\\n\", event->fork.pid, event->fork.tid,\n\t\t    event->fork.ppid, event->fork.ptid);\n\n\tif (thread) {\n\t\tmachine__remove_thread(machine, thread);\n\t\tthread__put(thread);\n\t}\n\n\treturn 0;\n}\n\nstruct perf_tool build_id__mark_dso_hit_ops = {\n\t.sample\t= build_id__mark_dso_hit,\n\t.mmap\t= perf_event__process_mmap,\n\t.mmap2\t= perf_event__process_mmap2,\n\t.fork\t= perf_event__process_fork,\n\t.exit\t= perf_event__exit_del_thread,\n\t.attr\t\t = perf_event__process_attr,\n\t.build_id\t = perf_event__process_build_id,\n\t.ordered_events\t = true,\n};\n\nint build_id__sprintf(const struct build_id *build_id, char *bf)\n{\n\tchar *bid = bf;\n\tconst u8 *raw = build_id->data;\n\tsize_t i;\n\n\tbf[0] = 0x0;\n\n\tfor (i = 0; i < build_id->size; ++i) {\n\t\tsprintf(bid, \"%02x\", *raw);\n\t\t++raw;\n\t\tbid += 2;\n\t}\n\n\treturn (bid - bf) + 1;\n}\n\nint sysfs__sprintf_build_id(const char *root_dir, char *sbuild_id)\n{\n\tchar notes[PATH_MAX];\n\tstruct build_id bid;\n\tint ret;\n\n\tif (!root_dir)\n\t\troot_dir = \"\";\n\n\tscnprintf(notes, sizeof(notes), \"%s/sys/kernel/notes\", root_dir);\n\n\tret = sysfs__read_build_id(notes, &bid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn build_id__sprintf(&bid, sbuild_id);\n}\n\nint filename__sprintf_build_id(const char *pathname, char *sbuild_id)\n{\n\tstruct build_id bid;\n\tint ret;\n\n\tret = filename__read_build_id(pathname, &bid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn build_id__sprintf(&bid, sbuild_id);\n}\n\n \nstatic int asnprintf(char **strp, size_t size, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tif (!strp)\n\t\treturn -EINVAL;\n\n\tva_start(ap, fmt);\n\tif (*strp)\n\t\tret = vsnprintf(*strp, size, fmt, ap);\n\telse\n\t\tret = vasprintf(strp, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\n\nchar *build_id_cache__kallsyms_path(const char *sbuild_id, char *bf,\n\t\t\t\t    size_t size)\n{\n\tbool retry_old = true;\n\n\tsnprintf(bf, size, \"%s/%s/%s/kallsyms\",\n\t\t buildid_dir, DSO__NAME_KALLSYMS, sbuild_id);\nretry:\n\tif (!access(bf, F_OK))\n\t\treturn bf;\n\tif (retry_old) {\n\t\t \n\t\tsnprintf(bf, size, \"%s/%s/%s\",\n\t\t\t buildid_dir, DSO__NAME_KALLSYMS, sbuild_id);\n\t\tretry_old = false;\n\t\tgoto retry;\n\t}\n\n\treturn NULL;\n}\n\nchar *build_id_cache__linkname(const char *sbuild_id, char *bf, size_t size)\n{\n\tchar *tmp = bf;\n\tint ret = asnprintf(&bf, size, \"%s/.build-id/%.2s/%s\", buildid_dir,\n\t\t\t    sbuild_id, sbuild_id + 2);\n\tif (ret < 0 || (tmp && size < (unsigned int)ret))\n\t\treturn NULL;\n\treturn bf;\n}\n\n \nchar *build_id_cache__origname(const char *sbuild_id)\n{\n\tchar *linkname;\n\tchar buf[PATH_MAX];\n\tchar *ret = NULL, *p;\n\tsize_t offs = 5;\t \n\tssize_t len;\n\n\tlinkname = build_id_cache__linkname(sbuild_id, NULL, 0);\n\tif (!linkname)\n\t\treturn NULL;\n\n\tlen = readlink(linkname, buf, sizeof(buf) - 1);\n\tif (len <= 0)\n\t\tgoto out;\n\tbuf[len] = '\\0';\n\n\t \n\tp = strrchr(buf, '/');\t \n\tif (p && (p > buf + offs)) {\n\t\t*p = '\\0';\n\t\tif (buf[offs + 1] == '[')\n\t\t\toffs++;\t \n\t\tret = strdup(buf + offs);\t \n\t}\nout:\n\tfree(linkname);\n\treturn ret;\n}\n\n \nstatic bool build_id_cache__valid_id(char *sbuild_id)\n{\n\tchar real_sbuild_id[SBUILD_ID_SIZE] = \"\";\n\tchar *pathname;\n\tint ret = 0;\n\tbool result = false;\n\n\tpathname = build_id_cache__origname(sbuild_id);\n\tif (!pathname)\n\t\treturn false;\n\n\tif (!strcmp(pathname, DSO__NAME_KALLSYMS))\n\t\tret = sysfs__sprintf_build_id(\"/\", real_sbuild_id);\n\telse if (pathname[0] == '/')\n\t\tret = filename__sprintf_build_id(pathname, real_sbuild_id);\n\telse\n\t\tret = -EINVAL;\t \n\tif (ret >= 0)\n\t\tresult = (strcmp(sbuild_id, real_sbuild_id) == 0);\n\tfree(pathname);\n\n\treturn result;\n}\n\nstatic const char *build_id_cache__basename(bool is_kallsyms, bool is_vdso,\n\t\t\t\t\t    bool is_debug)\n{\n\treturn is_kallsyms ? \"kallsyms\" : (is_vdso ? \"vdso\" : (is_debug ?\n\t    \"debug\" : \"elf\"));\n}\n\nchar *__dso__build_id_filename(const struct dso *dso, char *bf, size_t size,\n\t\t\t       bool is_debug, bool is_kallsyms)\n{\n\tbool is_vdso = dso__is_vdso((struct dso *)dso);\n\tchar sbuild_id[SBUILD_ID_SIZE];\n\tchar *linkname;\n\tbool alloc = (bf == NULL);\n\tint ret;\n\n\tif (!dso->has_build_id)\n\t\treturn NULL;\n\n\tbuild_id__sprintf(&dso->bid, sbuild_id);\n\tlinkname = build_id_cache__linkname(sbuild_id, NULL, 0);\n\tif (!linkname)\n\t\treturn NULL;\n\n\t \n\tif (is_regular_file(linkname))\n\t\tret = asnprintf(&bf, size, \"%s\", linkname);\n\telse\n\t\tret = asnprintf(&bf, size, \"%s/%s\", linkname,\n\t\t\t build_id_cache__basename(is_kallsyms, is_vdso,\n\t\t\t\t\t\t  is_debug));\n\tif (ret < 0 || (!alloc && size < (unsigned int)ret))\n\t\tbf = NULL;\n\tfree(linkname);\n\n\treturn bf;\n}\n\nchar *dso__build_id_filename(const struct dso *dso, char *bf, size_t size,\n\t\t\t     bool is_debug)\n{\n\tbool is_kallsyms = dso__is_kallsyms((struct dso *)dso);\n\n\treturn __dso__build_id_filename(dso, bf, size, is_debug, is_kallsyms);\n}\n\nstatic int write_buildid(const char *name, size_t name_len, struct build_id *bid,\n\t\t\t pid_t pid, u16 misc, struct feat_fd *fd)\n{\n\tint err;\n\tstruct perf_record_header_build_id b;\n\tsize_t len;\n\n\tlen = name_len + 1;\n\tlen = PERF_ALIGN(len, NAME_ALIGN);\n\n\tmemset(&b, 0, sizeof(b));\n\tmemcpy(&b.data, bid->data, bid->size);\n\tb.size = (u8) bid->size;\n\tmisc |= PERF_RECORD_MISC_BUILD_ID_SIZE;\n\tb.pid = pid;\n\tb.header.misc = misc;\n\tb.header.size = sizeof(b) + len;\n\n\terr = do_write(fd, &b, sizeof(b));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn write_padded(fd, name, name_len + 1, len);\n}\n\nstatic int machine__write_buildid_table(struct machine *machine,\n\t\t\t\t\tstruct feat_fd *fd)\n{\n\tint err = 0;\n\tstruct dso *pos;\n\tu16 kmisc = PERF_RECORD_MISC_KERNEL,\n\t    umisc = PERF_RECORD_MISC_USER;\n\n\tif (!machine__is_host(machine)) {\n\t\tkmisc = PERF_RECORD_MISC_GUEST_KERNEL;\n\t\tumisc = PERF_RECORD_MISC_GUEST_USER;\n\t}\n\n\tdsos__for_each_with_build_id(pos, &machine->dsos.head) {\n\t\tconst char *name;\n\t\tsize_t name_len;\n\t\tbool in_kernel = false;\n\n\t\tif (!pos->hit && !dso__is_vdso(pos))\n\t\t\tcontinue;\n\n\t\tif (dso__is_vdso(pos)) {\n\t\t\tname = pos->short_name;\n\t\t\tname_len = pos->short_name_len;\n\t\t} else if (dso__is_kcore(pos)) {\n\t\t\tname = machine->mmap_name;\n\t\t\tname_len = strlen(name);\n\t\t} else {\n\t\t\tname = pos->long_name;\n\t\t\tname_len = pos->long_name_len;\n\t\t}\n\n\t\tin_kernel = pos->kernel ||\n\t\t\t\tis_kernel_module(name,\n\t\t\t\t\tPERF_RECORD_MISC_CPUMODE_UNKNOWN);\n\t\terr = write_buildid(name, name_len, &pos->bid, machine->pid,\n\t\t\t\t    in_kernel ? kmisc : umisc, fd);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint perf_session__write_buildid_table(struct perf_session *session,\n\t\t\t\t      struct feat_fd *fd)\n{\n\tstruct rb_node *nd;\n\tint err = machine__write_buildid_table(&session->machines.host, fd);\n\n\tif (err)\n\t\treturn err;\n\n\tfor (nd = rb_first_cached(&session->machines.guests); nd;\n\t     nd = rb_next(nd)) {\n\t\tstruct machine *pos = rb_entry(nd, struct machine, rb_node);\n\t\terr = machine__write_buildid_table(pos, fd);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic int __dsos__hit_all(struct list_head *head)\n{\n\tstruct dso *pos;\n\n\tlist_for_each_entry(pos, head, node)\n\t\tpos->hit = true;\n\n\treturn 0;\n}\n\nstatic int machine__hit_all_dsos(struct machine *machine)\n{\n\treturn __dsos__hit_all(&machine->dsos.head);\n}\n\nint dsos__hit_all(struct perf_session *session)\n{\n\tstruct rb_node *nd;\n\tint err;\n\n\terr = machine__hit_all_dsos(&session->machines.host);\n\tif (err)\n\t\treturn err;\n\n\tfor (nd = rb_first_cached(&session->machines.guests); nd;\n\t     nd = rb_next(nd)) {\n\t\tstruct machine *pos = rb_entry(nd, struct machine, rb_node);\n\n\t\terr = machine__hit_all_dsos(pos);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid disable_buildid_cache(void)\n{\n\tno_buildid_cache = true;\n}\n\nstatic bool lsdir_bid_head_filter(const char *name __maybe_unused,\n\t\t\t\t  struct dirent *d)\n{\n\treturn (strlen(d->d_name) == 2) &&\n\t\tisxdigit(d->d_name[0]) && isxdigit(d->d_name[1]);\n}\n\nstatic bool lsdir_bid_tail_filter(const char *name __maybe_unused,\n\t\t\t\t  struct dirent *d)\n{\n\tint i = 0;\n\twhile (isxdigit(d->d_name[i]) && i < SBUILD_ID_SIZE - 3)\n\t\ti++;\n\treturn (i >= SBUILD_ID_MIN_SIZE - 3) && (i <= SBUILD_ID_SIZE - 3) &&\n\t\t(d->d_name[i] == '\\0');\n}\n\nstruct strlist *build_id_cache__list_all(bool validonly)\n{\n\tstruct strlist *toplist, *linklist = NULL, *bidlist;\n\tstruct str_node *nd, *nd2;\n\tchar *topdir, *linkdir = NULL;\n\tchar sbuild_id[SBUILD_ID_SIZE];\n\n\t \n\tif (validonly)\n\t\tsymbol__init(NULL);\n\n\t \n\tif (asprintf(&topdir, \"%s/.build-id/\", buildid_dir) < 0)\n\t\treturn NULL;\n\n\tbidlist = strlist__new(NULL, NULL);\n\tif (!bidlist)\n\t\tgoto out;\n\n\ttoplist = lsdir(topdir, lsdir_bid_head_filter);\n\tif (!toplist) {\n\t\tpr_debug(\"Error in lsdir(%s): %d\\n\", topdir, errno);\n\t\t \n\t\tif (errno == ENOENT)\n\t\t\tgoto out;\n\t\tgoto err_out;\n\t}\n\n\tstrlist__for_each_entry(nd, toplist) {\n\t\tif (asprintf(&linkdir, \"%s/%s\", topdir, nd->s) < 0)\n\t\t\tgoto err_out;\n\t\t \n\t\tlinklist = lsdir(linkdir, lsdir_bid_tail_filter);\n\t\tif (!linklist) {\n\t\t\tpr_debug(\"Error in lsdir(%s): %d\\n\", linkdir, errno);\n\t\t\tgoto err_out;\n\t\t}\n\t\tstrlist__for_each_entry(nd2, linklist) {\n\t\t\tif (snprintf(sbuild_id, SBUILD_ID_SIZE, \"%s%s\",\n\t\t\t\t     nd->s, nd2->s) > SBUILD_ID_SIZE - 1)\n\t\t\t\tgoto err_out;\n\t\t\tif (validonly && !build_id_cache__valid_id(sbuild_id))\n\t\t\t\tcontinue;\n\t\t\tif (strlist__add(bidlist, sbuild_id) < 0)\n\t\t\t\tgoto err_out;\n\t\t}\n\t\tstrlist__delete(linklist);\n\t\tzfree(&linkdir);\n\t}\n\nout_free:\n\tstrlist__delete(toplist);\nout:\n\tfree(topdir);\n\n\treturn bidlist;\n\nerr_out:\n\tstrlist__delete(linklist);\n\tzfree(&linkdir);\n\tstrlist__delete(bidlist);\n\tbidlist = NULL;\n\tgoto out_free;\n}\n\nstatic bool str_is_build_id(const char *maybe_sbuild_id, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!isxdigit(maybe_sbuild_id[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nchar *build_id_cache__complement(const char *incomplete_sbuild_id)\n{\n\tstruct strlist *bidlist;\n\tstruct str_node *nd, *cand = NULL;\n\tchar *sbuild_id = NULL;\n\tsize_t len = strlen(incomplete_sbuild_id);\n\n\tif (len >= SBUILD_ID_SIZE ||\n\t    !str_is_build_id(incomplete_sbuild_id, len))\n\t\treturn NULL;\n\n\tbidlist = build_id_cache__list_all(true);\n\tif (!bidlist)\n\t\treturn NULL;\n\n\tstrlist__for_each_entry(nd, bidlist) {\n\t\tif (strncmp(nd->s, incomplete_sbuild_id, len) != 0)\n\t\t\tcontinue;\n\t\tif (cand) {\t \n\t\t\tcand = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tcand = nd;\n\t}\n\tif (cand)\n\t\tsbuild_id = strdup(cand->s);\n\tstrlist__delete(bidlist);\n\n\treturn sbuild_id;\n}\n\nchar *build_id_cache__cachedir(const char *sbuild_id, const char *name,\n\t\t\t       struct nsinfo *nsi, bool is_kallsyms,\n\t\t\t       bool is_vdso)\n{\n\tchar *realname = NULL, *filename;\n\tbool slash = is_kallsyms || is_vdso;\n\n\tif (!slash)\n\t\trealname = nsinfo__realpath(name, nsi);\n\n\tif (asprintf(&filename, \"%s%s%s%s%s\", buildid_dir, slash ? \"/\" : \"\",\n\t\t     is_vdso ? DSO__NAME_VDSO : (realname ? realname : name),\n\t\t     sbuild_id ? \"/\" : \"\", sbuild_id ?: \"\") < 0)\n\t\tfilename = NULL;\n\n\tfree(realname);\n\treturn filename;\n}\n\nint build_id_cache__list_build_ids(const char *pathname, struct nsinfo *nsi,\n\t\t\t\t   struct strlist **result)\n{\n\tchar *dir_name;\n\tint ret = 0;\n\n\tdir_name = build_id_cache__cachedir(NULL, pathname, nsi, false, false);\n\tif (!dir_name)\n\t\treturn -ENOMEM;\n\n\t*result = lsdir(dir_name, lsdir_no_dot_filter);\n\tif (!*result)\n\t\tret = -errno;\n\tfree(dir_name);\n\n\treturn ret;\n}\n\n#if defined(HAVE_LIBELF_SUPPORT) && defined(HAVE_GELF_GETNOTE_SUPPORT)\nstatic int build_id_cache__add_sdt_cache(const char *sbuild_id,\n\t\t\t\t\t  const char *realname,\n\t\t\t\t\t  struct nsinfo *nsi)\n{\n\tstruct probe_cache *cache;\n\tint ret;\n\tstruct nscookie nsc;\n\n\tcache = probe_cache__new(sbuild_id, nsi);\n\tif (!cache)\n\t\treturn -1;\n\n\tnsinfo__mountns_enter(nsi, &nsc);\n\tret = probe_cache__scan_sdt(cache, realname);\n\tnsinfo__mountns_exit(&nsc);\n\tif (ret >= 0) {\n\t\tpr_debug4(\"Found %d SDTs in %s\\n\", ret, realname);\n\t\tif (probe_cache__commit(cache) < 0)\n\t\t\tret = -1;\n\t}\n\tprobe_cache__delete(cache);\n\treturn ret;\n}\n#else\n#define build_id_cache__add_sdt_cache(sbuild_id, realname, nsi) (0)\n#endif\n\nstatic char *build_id_cache__find_debug(const char *sbuild_id,\n\t\t\t\t\tstruct nsinfo *nsi,\n\t\t\t\t\tconst char *root_dir)\n{\n\tconst char *dirname = \"/usr/lib/debug/.build-id/\";\n\tchar *realname = NULL;\n\tchar dirbuf[PATH_MAX];\n\tchar *debugfile;\n\tstruct nscookie nsc;\n\tsize_t len = 0;\n\n\tdebugfile = calloc(1, PATH_MAX);\n\tif (!debugfile)\n\t\tgoto out;\n\n\tif (root_dir) {\n\t\tpath__join(dirbuf, PATH_MAX, root_dir, dirname);\n\t\tdirname = dirbuf;\n\t}\n\n\tlen = __symbol__join_symfs(debugfile, PATH_MAX, dirname);\n\tsnprintf(debugfile + len, PATH_MAX - len, \"%.2s/%s.debug\", sbuild_id,\n\t\t sbuild_id + 2);\n\n\tnsinfo__mountns_enter(nsi, &nsc);\n\trealname = realpath(debugfile, NULL);\n\tif (realname && access(realname, R_OK))\n\t\tzfree(&realname);\n\tnsinfo__mountns_exit(&nsc);\n\n#ifdef HAVE_DEBUGINFOD_SUPPORT\n\tif (realname == NULL) {\n\t\tdebuginfod_client* c;\n\n\t\tpr_debug(\"Downloading debug info with build id %s\\n\", sbuild_id);\n\n\t\tc = debuginfod_begin();\n\t\tif (c != NULL) {\n\t\t\tint fd = debuginfod_find_debuginfo(c,\n\t\t\t\t\t(const unsigned char*)sbuild_id, 0,\n\t\t\t\t\t&realname);\n\t\t\tif (fd >= 0)\n\t\t\t\tclose(fd);  \n\t\t\tdebuginfod_end(c);\n\t\t}\n\t}\n#endif\n\nout:\n\tfree(debugfile);\n\treturn realname;\n}\n\nint\nbuild_id_cache__add(const char *sbuild_id, const char *name, const char *realname,\n\t\t    struct nsinfo *nsi, bool is_kallsyms, bool is_vdso,\n\t\t    const char *proper_name, const char *root_dir)\n{\n\tconst size_t size = PATH_MAX;\n\tchar *filename = NULL, *dir_name = NULL, *linkname = zalloc(size), *tmp;\n\tchar *debugfile = NULL;\n\tint err = -1;\n\n\tif (!proper_name)\n\t\tproper_name = name;\n\n\tdir_name = build_id_cache__cachedir(sbuild_id, proper_name, nsi, is_kallsyms,\n\t\t\t\t\t    is_vdso);\n\tif (!dir_name)\n\t\tgoto out_free;\n\n\t \n\tif (is_regular_file(dir_name))\n\t\tif (unlink(dir_name))\n\t\t\tgoto out_free;\n\n\tif (mkdir_p(dir_name, 0755))\n\t\tgoto out_free;\n\n\t \n\tif (asprintf(&filename, \"%s/%s\", dir_name,\n\t\t     build_id_cache__basename(is_kallsyms, is_vdso,\n\t\t     false)) < 0) {\n\t\tfilename = NULL;\n\t\tgoto out_free;\n\t}\n\n\tif (access(filename, F_OK)) {\n\t\tif (is_kallsyms) {\n\t\t\tif (copyfile(\"/proc/kallsyms\", filename))\n\t\t\t\tgoto out_free;\n\t\t} else if (nsi && nsinfo__need_setns(nsi)) {\n\t\t\tif (copyfile_ns(name, filename, nsi))\n\t\t\t\tgoto out_free;\n\t\t} else if (link(realname, filename) && errno != EEXIST) {\n\t\t\tstruct stat f_stat;\n\n\t\t\tif (!(stat(name, &f_stat) < 0) &&\n\t\t\t\t\tcopyfile_mode(name, filename, f_stat.st_mode))\n\t\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t \n\tif (!is_kallsyms && !is_vdso &&\n\t    strncmp(\".ko\", name + strlen(name) - 3, 3)) {\n\t\tdebugfile = build_id_cache__find_debug(sbuild_id, nsi, root_dir);\n\t\tif (debugfile) {\n\t\t\tzfree(&filename);\n\t\t\tif (asprintf(&filename, \"%s/%s\", dir_name,\n\t\t\t    build_id_cache__basename(false, false, true)) < 0) {\n\t\t\t\tfilename = NULL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tif (access(filename, F_OK)) {\n\t\t\t\tif (nsi && nsinfo__need_setns(nsi)) {\n\t\t\t\t\tif (copyfile_ns(debugfile, filename,\n\t\t\t\t\t\t\tnsi))\n\t\t\t\t\t\tgoto out_free;\n\t\t\t\t} else if (link(debugfile, filename) &&\n\t\t\t\t\t\terrno != EEXIST &&\n\t\t\t\t\t\tcopyfile(debugfile, filename))\n\t\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!build_id_cache__linkname(sbuild_id, linkname, size))\n\t\tgoto out_free;\n\ttmp = strrchr(linkname, '/');\n\t*tmp = '\\0';\n\n\tif (access(linkname, X_OK) && mkdir_p(linkname, 0755))\n\t\tgoto out_free;\n\n\t*tmp = '/';\n\ttmp = dir_name + strlen(buildid_dir) - 5;\n\tmemcpy(tmp, \"../..\", 5);\n\n\tif (symlink(tmp, linkname) == 0) {\n\t\terr = 0;\n\t} else if (errno == EEXIST) {\n\t\tchar path[PATH_MAX];\n\t\tssize_t len;\n\n\t\tlen = readlink(linkname, path, sizeof(path) - 1);\n\t\tif (len <= 0) {\n\t\t\tpr_err(\"Can't read link: %s\\n\", linkname);\n\t\t\tgoto out_free;\n\t\t}\n\t\tpath[len] = '\\0';\n\n\t\tif (strcmp(tmp, path)) {\n\t\t\tpr_debug(\"build <%s> already linked to %s\\n\",\n\t\t\t\t sbuild_id, linkname);\n\t\t}\n\t\terr = 0;\n\t}\n\n\t \n\tif (realname &&\n\t    build_id_cache__add_sdt_cache(sbuild_id, realname, nsi) < 0)\n\t\tpr_debug4(\"Failed to update/scan SDT cache for %s\\n\", realname);\n\nout_free:\n\tfree(filename);\n\tfree(debugfile);\n\tfree(dir_name);\n\tfree(linkname);\n\treturn err;\n}\n\nint __build_id_cache__add_s(const char *sbuild_id, const char *name,\n\t\t\t    struct nsinfo *nsi, bool is_kallsyms, bool is_vdso,\n\t\t\t    const char *proper_name, const char *root_dir)\n{\n\tchar *realname = NULL;\n\tint err = -1;\n\n\tif (!is_kallsyms) {\n\t\tif (!is_vdso)\n\t\t\trealname = nsinfo__realpath(name, nsi);\n\t\telse\n\t\t\trealname = realpath(name, NULL);\n\t\tif (!realname)\n\t\t\tgoto out_free;\n\t}\n\n\terr = build_id_cache__add(sbuild_id, name, realname, nsi,\n\t\t\t\t  is_kallsyms, is_vdso, proper_name, root_dir);\nout_free:\n\tif (!is_kallsyms)\n\t\tfree(realname);\n\treturn err;\n}\n\nstatic int build_id_cache__add_b(const struct build_id *bid,\n\t\t\t\t const char *name, struct nsinfo *nsi,\n\t\t\t\t bool is_kallsyms, bool is_vdso,\n\t\t\t\t const char *proper_name,\n\t\t\t\t const char *root_dir)\n{\n\tchar sbuild_id[SBUILD_ID_SIZE];\n\n\tbuild_id__sprintf(bid, sbuild_id);\n\n\treturn __build_id_cache__add_s(sbuild_id, name, nsi, is_kallsyms,\n\t\t\t\t       is_vdso, proper_name, root_dir);\n}\n\nbool build_id_cache__cached(const char *sbuild_id)\n{\n\tbool ret = false;\n\tchar *filename = build_id_cache__linkname(sbuild_id, NULL, 0);\n\n\tif (filename && !access(filename, F_OK))\n\t\tret = true;\n\tfree(filename);\n\n\treturn ret;\n}\n\nint build_id_cache__remove_s(const char *sbuild_id)\n{\n\tconst size_t size = PATH_MAX;\n\tchar *filename = zalloc(size),\n\t     *linkname = zalloc(size), *tmp;\n\tint err = -1;\n\n\tif (filename == NULL || linkname == NULL)\n\t\tgoto out_free;\n\n\tif (!build_id_cache__linkname(sbuild_id, linkname, size))\n\t\tgoto out_free;\n\n\tif (access(linkname, F_OK))\n\t\tgoto out_free;\n\n\tif (readlink(linkname, filename, size - 1) < 0)\n\t\tgoto out_free;\n\n\tif (unlink(linkname))\n\t\tgoto out_free;\n\n\t \n\ttmp = strrchr(linkname, '/') + 1;\n\tsnprintf(tmp, size - (tmp - linkname), \"%s\", filename);\n\n\tif (rm_rf(linkname))\n\t\tgoto out_free;\n\n\terr = 0;\nout_free:\n\tfree(filename);\n\tfree(linkname);\n\treturn err;\n}\n\nstatic int filename__read_build_id_ns(const char *filename,\n\t\t\t\t      struct build_id *bid,\n\t\t\t\t      struct nsinfo *nsi)\n{\n\tstruct nscookie nsc;\n\tint ret;\n\n\tnsinfo__mountns_enter(nsi, &nsc);\n\tret = filename__read_build_id(filename, bid);\n\tnsinfo__mountns_exit(&nsc);\n\n\treturn ret;\n}\n\nstatic bool dso__build_id_mismatch(struct dso *dso, const char *name)\n{\n\tstruct build_id bid;\n\tbool ret = false;\n\n\tmutex_lock(&dso->lock);\n\tif (filename__read_build_id_ns(name, &bid, dso->nsinfo) >= 0)\n\t\tret = !dso__build_id_equal(dso, &bid);\n\n\tmutex_unlock(&dso->lock);\n\n\treturn ret;\n}\n\nstatic int dso__cache_build_id(struct dso *dso, struct machine *machine,\n\t\t\t       void *priv __maybe_unused)\n{\n\tbool is_kallsyms = dso__is_kallsyms(dso);\n\tbool is_vdso = dso__is_vdso(dso);\n\tconst char *name = dso->long_name;\n\tconst char *proper_name = NULL;\n\tconst char *root_dir = NULL;\n\tchar *allocated_name = NULL;\n\tint ret = 0;\n\n\tif (!dso->has_build_id)\n\t\treturn 0;\n\n\tif (dso__is_kcore(dso)) {\n\t\tis_kallsyms = true;\n\t\tname = machine->mmap_name;\n\t}\n\n\tif (!machine__is_host(machine)) {\n\t\tif (*machine->root_dir) {\n\t\t\troot_dir = machine->root_dir;\n\t\t\tret = asprintf(&allocated_name, \"%s/%s\", root_dir, name);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tproper_name = name;\n\t\t\tname = allocated_name;\n\t\t} else if (is_kallsyms) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!is_kallsyms && dso__build_id_mismatch(dso, name))\n\t\tgoto out_free;\n\n\tmutex_lock(&dso->lock);\n\tret = build_id_cache__add_b(&dso->bid, name, dso->nsinfo,\n\t\t\t\t    is_kallsyms, is_vdso, proper_name, root_dir);\n\tmutex_unlock(&dso->lock);\nout_free:\n\tfree(allocated_name);\n\treturn ret;\n}\n\nstatic int\nmachines__for_each_dso(struct machines *machines, machine__dso_t fn, void *priv)\n{\n\tint ret = machine__for_each_dso(&machines->host, fn, priv);\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first_cached(&machines->guests); nd;\n\t     nd = rb_next(nd)) {\n\t\tstruct machine *pos = rb_entry(nd, struct machine, rb_node);\n\n\t\tret |= machine__for_each_dso(pos, fn, priv);\n\t}\n\treturn ret ? -1 : 0;\n}\n\nint __perf_session__cache_build_ids(struct perf_session *session,\n\t\t\t\t    machine__dso_t fn, void *priv)\n{\n\tif (no_buildid_cache)\n\t\treturn 0;\n\n\tif (mkdir(buildid_dir, 0755) != 0 && errno != EEXIST)\n\t\treturn -1;\n\n\treturn machines__for_each_dso(&session->machines, fn, priv) ?  -1 : 0;\n}\n\nint perf_session__cache_build_ids(struct perf_session *session)\n{\n\treturn __perf_session__cache_build_ids(session, dso__cache_build_id, NULL);\n}\n\nstatic bool machine__read_build_ids(struct machine *machine, bool with_hits)\n{\n\treturn __dsos__read_build_ids(&machine->dsos.head, with_hits);\n}\n\nbool perf_session__read_build_ids(struct perf_session *session, bool with_hits)\n{\n\tstruct rb_node *nd;\n\tbool ret = machine__read_build_ids(&session->machines.host, with_hits);\n\n\tfor (nd = rb_first_cached(&session->machines.guests); nd;\n\t     nd = rb_next(nd)) {\n\t\tstruct machine *pos = rb_entry(nd, struct machine, rb_node);\n\t\tret |= machine__read_build_ids(pos, with_hits);\n\t}\n\n\treturn ret;\n}\n\nvoid build_id__init(struct build_id *bid, const u8 *data, size_t size)\n{\n\tWARN_ON(size > BUILD_ID_SIZE);\n\tmemcpy(bid->data, data, size);\n\tbid->size = size;\n}\n\nbool build_id__is_defined(const struct build_id *bid)\n{\n\treturn bid && bid->size ? !!memchr_inv(bid->data, 0, bid->size) : false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}