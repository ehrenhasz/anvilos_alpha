{
  "module_name": "genelf.c",
  "hash_id": "0d269dcf73d1808769a9b226862e4e4fa695c0d5009199fbea30102d0f296c27",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/genelf.c",
  "human_readable_source": "\n \n\n#include <sys/types.h>\n#include <stddef.h>\n#include <libelf.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <err.h>\n#ifdef HAVE_DWARF_SUPPORT\n#include <dwarf.h>\n#endif\n\n#include \"genelf.h\"\n#include \"../util/jitdump.h\"\n#include <linux/compiler.h>\n\n#ifndef NT_GNU_BUILD_ID\n#define NT_GNU_BUILD_ID 3\n#endif\n\n#define BUILD_ID_URANDOM  \n\n#ifdef HAVE_LIBCRYPTO_SUPPORT\n\n#define BUILD_ID_MD5\n#undef BUILD_ID_SHA\t \n#undef BUILD_ID_URANDOM  \n\n#ifdef BUILD_ID_SHA\n#include <openssl/sha.h>\n#endif\n\n#ifdef BUILD_ID_MD5\n#include <openssl/evp.h>\n#include <openssl/md5.h>\n#endif\n#endif\n\n\ntypedef struct {\n  unsigned int namesz;   \n  unsigned int descsz;   \n  unsigned int type;     \n  char         name[0];  \n} Elf_Note;\n\nstruct options {\n\tchar *output;\n\tint fd;\n};\n\nstatic char shd_string_table[] = {\n\t0,\n\t'.', 't', 'e', 'x', 't', 0,\t\t\t \n\t'.', 's', 'h', 's', 't', 'r', 't', 'a', 'b', 0,  \n\t'.', 's', 'y', 'm', 't', 'a', 'b', 0,\t\t \n\t'.', 's', 't', 'r', 't', 'a', 'b', 0,\t\t \n\t'.', 'n', 'o', 't', 'e', '.', 'g', 'n', 'u', '.', 'b', 'u', 'i', 'l', 'd', '-', 'i', 'd', 0,  \n\t'.', 'd', 'e', 'b', 'u', 'g', '_', 'l', 'i', 'n', 'e', 0,  \n\t'.', 'd', 'e', 'b', 'u', 'g', '_', 'i', 'n', 'f', 'o', 0,  \n\t'.', 'd', 'e', 'b', 'u', 'g', '_', 'a', 'b', 'b', 'r', 'e', 'v', 0,  \n\t'.', 'e', 'h', '_', 'f', 'r', 'a', 'm', 'e', '_', 'h', 'd', 'r', 0,  \n\t'.', 'e', 'h', '_', 'f', 'r', 'a', 'm', 'e', 0,  \n};\n\nstatic struct buildid_note {\n\tElf_Note desc;\t\t \n\tchar\t name[4];\t \n\tchar\t build_id[20];\n} bnote;\n\nstatic Elf_Sym symtab[]={\n\t \n\t{ .st_name  = 0,  \n\t  .st_info  = ELF_ST_TYPE(STT_NOTYPE),\n\t  .st_shndx = 0,  \n\t  .st_value = 0x0,\n\t  .st_other = ELF_ST_VIS(STV_DEFAULT),\n\t  .st_size  = 0,\n\t},\n\t{ .st_name  = 1,  \n\t  .st_info  = ELF_ST_BIND(STB_LOCAL) | ELF_ST_TYPE(STT_FUNC),\n\t  .st_shndx = 1,\n\t  .st_value = 0,  \n\t  .st_other = ELF_ST_VIS(STV_DEFAULT),\n\t  .st_size  = 0,  \n\t}\n};\n\n#ifdef BUILD_ID_URANDOM\nstatic void\ngen_build_id(struct buildid_note *note,\n\t     unsigned long load_addr __maybe_unused,\n\t     const void *code __maybe_unused,\n\t     size_t csize __maybe_unused)\n{\n\tint fd;\n\tsize_t sz = sizeof(note->build_id);\n\tssize_t sret;\n\n\tfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (fd == -1)\n\t\terr(1, \"cannot access /dev/urandom for buildid\");\n\n\tsret = read(fd, note->build_id, sz);\n\n\tclose(fd);\n\n\tif (sret != (ssize_t)sz)\n\t\tmemset(note->build_id, 0, sz);\n}\n#endif\n\n#ifdef BUILD_ID_SHA\nstatic void\ngen_build_id(struct buildid_note *note,\n\t     unsigned long load_addr __maybe_unused,\n\t     const void *code,\n\t     size_t csize)\n{\n\tif (sizeof(note->build_id) < SHA_DIGEST_LENGTH)\n\t\terrx(1, \"build_id too small for SHA1\");\n\n\tSHA1(code, csize, (unsigned char *)note->build_id);\n}\n#endif\n\n#ifdef BUILD_ID_MD5\nstatic void\ngen_build_id(struct buildid_note *note, unsigned long load_addr, const void *code, size_t csize)\n{\n\tEVP_MD_CTX *mdctx;\n\n\tif (sizeof(note->build_id) < 16)\n\t\terrx(1, \"build_id too small for MD5\");\n\n\tmdctx = EVP_MD_CTX_new();\n\tif (!mdctx)\n\t\terrx(2, \"failed to create EVP_MD_CTX\");\n\n\tEVP_DigestInit_ex(mdctx, EVP_md5(), NULL);\n\tEVP_DigestUpdate(mdctx, &load_addr, sizeof(load_addr));\n\tEVP_DigestUpdate(mdctx, code, csize);\n\tEVP_DigestFinal_ex(mdctx, (unsigned char *)note->build_id, NULL);\n\tEVP_MD_CTX_free(mdctx);\n}\n#endif\n\nstatic int\njit_add_eh_frame_info(Elf *e, void* unwinding, uint64_t unwinding_header_size,\n\t\t      uint64_t unwinding_size, uint64_t base_offset)\n{\n\tElf_Data *d;\n\tElf_Scn *scn;\n\tElf_Shdr *shdr;\n\tuint64_t unwinding_table_size = unwinding_size - unwinding_header_size;\n\n\t \n\tscn = elf_newscn(e);\n\tif (!scn) {\n\t\twarnx(\"cannot create section\");\n\t\treturn -1;\n\t}\n\n\td = elf_newdata(scn);\n\tif (!d) {\n\t\twarnx(\"cannot get new data\");\n\t\treturn -1;\n\t}\n\n\td->d_align = 8;\n\td->d_off = 0LL;\n\td->d_buf = unwinding;\n\td->d_type = ELF_T_BYTE;\n\td->d_size = unwinding_table_size;\n\td->d_version = EV_CURRENT;\n\n\tshdr = elf_getshdr(scn);\n\tif (!shdr) {\n\t\twarnx(\"cannot get section header\");\n\t\treturn -1;\n\t}\n\n\tshdr->sh_name = 104;\n\tshdr->sh_type = SHT_PROGBITS;\n\tshdr->sh_addr = base_offset;\n\tshdr->sh_flags = SHF_ALLOC;\n\tshdr->sh_entsize = 0;\n\n\t \n\tscn = elf_newscn(e);\n\tif (!scn) {\n\t\twarnx(\"cannot create section\");\n\t\treturn -1;\n\t}\n\n\td = elf_newdata(scn);\n\tif (!d) {\n\t\twarnx(\"cannot get new data\");\n\t\treturn -1;\n\t}\n\n\td->d_align = 4;\n\td->d_off = 0LL;\n\td->d_buf = unwinding + unwinding_table_size;\n\td->d_type = ELF_T_BYTE;\n\td->d_size = unwinding_header_size;\n\td->d_version = EV_CURRENT;\n\n\tshdr = elf_getshdr(scn);\n\tif (!shdr) {\n\t\twarnx(\"cannot get section header\");\n\t\treturn -1;\n\t}\n\n\tshdr->sh_name = 90;\n\tshdr->sh_type = SHT_PROGBITS;\n\tshdr->sh_addr = base_offset + unwinding_table_size;\n\tshdr->sh_flags = SHF_ALLOC;\n\tshdr->sh_entsize = 0;\n\n\treturn 0;\n}\n\n \nint\njit_write_elf(int fd, uint64_t load_addr, const char *sym,\n\t      const void *code, int csize,\n\t      void *debug __maybe_unused, int nr_debug_entries __maybe_unused,\n\t      void *unwinding, uint64_t unwinding_header_size, uint64_t unwinding_size)\n{\n\tElf *e;\n\tElf_Data *d;\n\tElf_Scn *scn;\n\tElf_Ehdr *ehdr;\n\tElf_Phdr *phdr;\n\tElf_Shdr *shdr;\n\tuint64_t eh_frame_base_offset;\n\tchar *strsym = NULL;\n\tint symlen;\n\tint retval = -1;\n\n\tif (elf_version(EV_CURRENT) == EV_NONE) {\n\t\twarnx(\"ELF initialization failed\");\n\t\treturn -1;\n\t}\n\n\te = elf_begin(fd, ELF_C_WRITE, NULL);\n\tif (!e) {\n\t\twarnx(\"elf_begin failed\");\n\t\tgoto error;\n\t}\n\n\t \n\tehdr = elf_newehdr(e);\n\tif (!ehdr) {\n\t\twarnx(\"cannot get ehdr\");\n\t\tgoto error;\n\t}\n\n\tehdr->e_ident[EI_DATA] = GEN_ELF_ENDIAN;\n\tehdr->e_ident[EI_CLASS] = GEN_ELF_CLASS;\n\tehdr->e_machine = GEN_ELF_ARCH;\n\tehdr->e_type = ET_DYN;\n\tehdr->e_entry = GEN_ELF_TEXT_OFFSET;\n\tehdr->e_version = EV_CURRENT;\n\tehdr->e_shstrndx= unwinding ? 4 : 2;  \n\n\t \n\tphdr = elf_newphdr(e, 1);\n\tphdr[0].p_type = PT_LOAD;\n\tphdr[0].p_offset = GEN_ELF_TEXT_OFFSET;\n\tphdr[0].p_vaddr = GEN_ELF_TEXT_OFFSET;\n\tphdr[0].p_paddr = GEN_ELF_TEXT_OFFSET;\n\tphdr[0].p_filesz = csize;\n\tphdr[0].p_memsz = csize;\n\tphdr[0].p_flags = PF_X | PF_R;\n\tphdr[0].p_align = 8;\n\n\t \n\tscn = elf_newscn(e);\n\tif (!scn) {\n\t\twarnx(\"cannot create section\");\n\t\tgoto error;\n\t}\n\n\td = elf_newdata(scn);\n\tif (!d) {\n\t\twarnx(\"cannot get new data\");\n\t\tgoto error;\n\t}\n\n\td->d_align = 16;\n\td->d_off = 0LL;\n\td->d_buf = (void *)code;\n\td->d_type = ELF_T_BYTE;\n\td->d_size = csize;\n\td->d_version = EV_CURRENT;\n\n\tshdr = elf_getshdr(scn);\n\tif (!shdr) {\n\t\twarnx(\"cannot get section header\");\n\t\tgoto error;\n\t}\n\n\tshdr->sh_name = 1;\n\tshdr->sh_type = SHT_PROGBITS;\n\tshdr->sh_addr = GEN_ELF_TEXT_OFFSET;\n\tshdr->sh_flags = SHF_EXECINSTR | SHF_ALLOC;\n\tshdr->sh_entsize = 0;\n\n\t \n\tif (unwinding) {\n\t\teh_frame_base_offset = ALIGN_8(GEN_ELF_TEXT_OFFSET + csize);\n\t\tretval = jit_add_eh_frame_info(e, unwinding,\n\t\t\t\t\t       unwinding_header_size, unwinding_size,\n\t\t\t\t\t       eh_frame_base_offset);\n\t\tif (retval)\n\t\t\tgoto error;\n\t\tretval = -1;\n\t}\n\n\t \n\tscn = elf_newscn(e);\n\tif (!scn) {\n\t\twarnx(\"cannot create section\");\n\t\tgoto error;\n\t}\n\n\td = elf_newdata(scn);\n\tif (!d) {\n\t\twarnx(\"cannot get new data\");\n\t\tgoto error;\n\t}\n\n\td->d_align = 1;\n\td->d_off = 0LL;\n\td->d_buf = shd_string_table;\n\td->d_type = ELF_T_BYTE;\n\td->d_size = sizeof(shd_string_table);\n\td->d_version = EV_CURRENT;\n\n\tshdr = elf_getshdr(scn);\n\tif (!shdr) {\n\t\twarnx(\"cannot get section header\");\n\t\tgoto error;\n\t}\n\n\tshdr->sh_name = 7;  \n\tshdr->sh_type = SHT_STRTAB;\n\tshdr->sh_flags = 0;\n\tshdr->sh_entsize = 0;\n\n\t \n\tsymtab[1].st_size  = csize;\n\tsymtab[1].st_value = GEN_ELF_TEXT_OFFSET;\n\n\tscn = elf_newscn(e);\n\tif (!scn) {\n\t\twarnx(\"cannot create section\");\n\t\tgoto error;\n\t}\n\n\td = elf_newdata(scn);\n\tif (!d) {\n\t\twarnx(\"cannot get new data\");\n\t\tgoto error;\n\t}\n\n\td->d_align = 8;\n\td->d_off = 0LL;\n\td->d_buf = symtab;\n\td->d_type = ELF_T_SYM;\n\td->d_size = sizeof(symtab);\n\td->d_version = EV_CURRENT;\n\n\tshdr = elf_getshdr(scn);\n\tif (!shdr) {\n\t\twarnx(\"cannot get section header\");\n\t\tgoto error;\n\t}\n\n\tshdr->sh_name = 17;  \n\tshdr->sh_type = SHT_SYMTAB;\n\tshdr->sh_flags = 0;\n\tshdr->sh_entsize = sizeof(Elf_Sym);\n\tshdr->sh_link = unwinding ? 6 : 4;  \n\n\t \n\tsymlen = 2 + strlen(sym);\n\tstrsym = calloc(1, symlen);\n\tif (!strsym) {\n\t\twarnx(\"cannot allocate strsym\");\n\t\tgoto error;\n\t}\n\tstrcpy(strsym + 1, sym);\n\n\tscn = elf_newscn(e);\n\tif (!scn) {\n\t\twarnx(\"cannot create section\");\n\t\tgoto error;\n\t}\n\n\td = elf_newdata(scn);\n\tif (!d) {\n\t\twarnx(\"cannot get new data\");\n\t\tgoto error;\n\t}\n\n\td->d_align = 1;\n\td->d_off = 0LL;\n\td->d_buf = strsym;\n\td->d_type = ELF_T_BYTE;\n\td->d_size = symlen;\n\td->d_version = EV_CURRENT;\n\n\tshdr = elf_getshdr(scn);\n\tif (!shdr) {\n\t\twarnx(\"cannot get section header\");\n\t\tgoto error;\n\t}\n\n\tshdr->sh_name = 25;  \n\tshdr->sh_type = SHT_STRTAB;\n\tshdr->sh_flags = 0;\n\tshdr->sh_entsize = 0;\n\n\t \n\tscn = elf_newscn(e);\n\tif (!scn) {\n\t\twarnx(\"cannot create section\");\n\t\tgoto error;\n\t}\n\n\td = elf_newdata(scn);\n\tif (!d) {\n\t\twarnx(\"cannot get new data\");\n\t\tgoto error;\n\t}\n\n\t \n\tgen_build_id(&bnote, load_addr, code, csize);\n\tbnote.desc.namesz = sizeof(bnote.name);  \n\tbnote.desc.descsz = sizeof(bnote.build_id);\n\tbnote.desc.type   = NT_GNU_BUILD_ID;\n\tstrcpy(bnote.name, \"GNU\");\n\n\td->d_align = 4;\n\td->d_off = 0LL;\n\td->d_buf = &bnote;\n\td->d_type = ELF_T_BYTE;\n\td->d_size = sizeof(bnote);\n\td->d_version = EV_CURRENT;\n\n\tshdr = elf_getshdr(scn);\n\tif (!shdr) {\n\t\twarnx(\"cannot get section header\");\n\t\tgoto error;\n\t}\n\n\tshdr->sh_name = 33;  \n\tshdr->sh_type = SHT_NOTE;\n\tshdr->sh_addr = 0x0;\n\tshdr->sh_flags = SHF_ALLOC;\n\tshdr->sh_size = sizeof(bnote);\n\tshdr->sh_entsize = 0;\n\n#ifdef HAVE_DWARF_SUPPORT\n\tif (debug && nr_debug_entries) {\n\t\tretval = jit_add_debug_info(e, load_addr, debug, nr_debug_entries);\n\t\tif (retval)\n\t\t\tgoto error;\n\t} else\n#endif\n\t{\n\t\tif (elf_update(e, ELF_C_WRITE) < 0) {\n\t\t\twarnx(\"elf_update 4 failed\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tretval = 0;\nerror:\n\t(void)elf_end(e);\n\n\tfree(strsym);\n\n\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}