{
  "module_name": "intel-pt-decoder.c",
  "hash_id": "98d72f2041c2ee09e42ed3363423c0429651c2037c82f492c52e35018cf10e05",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c",
  "human_readable_source": "\n \n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <errno.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n\n#include \"../auxtrace.h\"\n\n#include \"intel-pt-insn-decoder.h\"\n#include \"intel-pt-pkt-decoder.h\"\n#include \"intel-pt-decoder.h\"\n#include \"intel-pt-log.h\"\n\n#define BITULL(x) (1ULL << (x))\n\n \n#define INTEL_PT_CYC_ENABLE\t\tBITULL(1)\n#define INTEL_PT_CYC_THRESHOLD\t\t(BITULL(22) | BITULL(21) | BITULL(20) | BITULL(19))\n#define INTEL_PT_CYC_THRESHOLD_SHIFT\t19\n\n#define INTEL_PT_BLK_SIZE 1024\n\n#define BIT63 (((uint64_t)1 << 63))\n\n#define SEVEN_BYTES 0xffffffffffffffULL\n\n#define NO_VMCS 0xffffffffffULL\n\n#define INTEL_PT_RETURN 1\n\n \n#define INTEL_PT_MAX_LOOPS 100000\n\nstruct intel_pt_blk {\n\tstruct intel_pt_blk *prev;\n\tuint64_t ip[INTEL_PT_BLK_SIZE];\n};\n\nstruct intel_pt_stack {\n\tstruct intel_pt_blk *blk;\n\tstruct intel_pt_blk *spare;\n\tint pos;\n};\n\nenum intel_pt_p_once {\n\tINTEL_PT_PRT_ONCE_UNK_VMCS,\n\tINTEL_PT_PRT_ONCE_ERANGE,\n};\n\nenum intel_pt_pkt_state {\n\tINTEL_PT_STATE_NO_PSB,\n\tINTEL_PT_STATE_NO_IP,\n\tINTEL_PT_STATE_ERR_RESYNC,\n\tINTEL_PT_STATE_IN_SYNC,\n\tINTEL_PT_STATE_TNT_CONT,\n\tINTEL_PT_STATE_TNT,\n\tINTEL_PT_STATE_TIP,\n\tINTEL_PT_STATE_TIP_PGD,\n\tINTEL_PT_STATE_FUP,\n\tINTEL_PT_STATE_FUP_NO_TIP,\n\tINTEL_PT_STATE_FUP_IN_PSB,\n\tINTEL_PT_STATE_RESAMPLE,\n\tINTEL_PT_STATE_VM_TIME_CORRELATION,\n};\n\nstatic inline bool intel_pt_sample_time(enum intel_pt_pkt_state pkt_state)\n{\n\tswitch (pkt_state) {\n\tcase INTEL_PT_STATE_NO_PSB:\n\tcase INTEL_PT_STATE_NO_IP:\n\tcase INTEL_PT_STATE_ERR_RESYNC:\n\tcase INTEL_PT_STATE_IN_SYNC:\n\tcase INTEL_PT_STATE_TNT_CONT:\n\tcase INTEL_PT_STATE_RESAMPLE:\n\tcase INTEL_PT_STATE_VM_TIME_CORRELATION:\n\t\treturn true;\n\tcase INTEL_PT_STATE_TNT:\n\tcase INTEL_PT_STATE_TIP:\n\tcase INTEL_PT_STATE_TIP_PGD:\n\tcase INTEL_PT_STATE_FUP:\n\tcase INTEL_PT_STATE_FUP_NO_TIP:\n\tcase INTEL_PT_STATE_FUP_IN_PSB:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t};\n}\n\n#ifdef INTEL_PT_STRICT\n#define INTEL_PT_STATE_ERR1\tINTEL_PT_STATE_NO_PSB\n#define INTEL_PT_STATE_ERR2\tINTEL_PT_STATE_NO_PSB\n#define INTEL_PT_STATE_ERR3\tINTEL_PT_STATE_NO_PSB\n#define INTEL_PT_STATE_ERR4\tINTEL_PT_STATE_NO_PSB\n#else\n#define INTEL_PT_STATE_ERR1\t(decoder->pkt_state)\n#define INTEL_PT_STATE_ERR2\tINTEL_PT_STATE_NO_IP\n#define INTEL_PT_STATE_ERR3\tINTEL_PT_STATE_ERR_RESYNC\n#define INTEL_PT_STATE_ERR4\tINTEL_PT_STATE_IN_SYNC\n#endif\n\nstruct intel_pt_decoder {\n\tint (*get_trace)(struct intel_pt_buffer *buffer, void *data);\n\tint (*walk_insn)(struct intel_pt_insn *intel_pt_insn,\n\t\t\t uint64_t *insn_cnt_ptr, uint64_t *ip, uint64_t to_ip,\n\t\t\t uint64_t max_insn_cnt, void *data);\n\tbool (*pgd_ip)(uint64_t ip, void *data);\n\tint (*lookahead)(void *data, intel_pt_lookahead_cb_t cb, void *cb_data);\n\tstruct intel_pt_vmcs_info *(*findnew_vmcs_info)(void *data, uint64_t vmcs);\n\tvoid *data;\n\tstruct intel_pt_state state;\n\tconst unsigned char *buf;\n\tsize_t len;\n\tbool return_compression;\n\tbool branch_enable;\n\tbool mtc_insn;\n\tbool pge;\n\tbool have_tma;\n\tbool have_cyc;\n\tbool fixup_last_mtc;\n\tbool have_last_ip;\n\tbool in_psb;\n\tbool hop;\n\tbool leap;\n\tbool emulated_ptwrite;\n\tbool vm_time_correlation;\n\tbool vm_tm_corr_dry_run;\n\tbool vm_tm_corr_reliable;\n\tbool vm_tm_corr_same_buf;\n\tbool vm_tm_corr_continuous;\n\tbool nr;\n\tbool next_nr;\n\tbool iflag;\n\tbool next_iflag;\n\tenum intel_pt_param_flags flags;\n\tuint64_t pos;\n\tuint64_t last_ip;\n\tuint64_t ip;\n\tuint64_t pip_payload;\n\tuint64_t timestamp;\n\tuint64_t tsc_timestamp;\n\tuint64_t ref_timestamp;\n\tuint64_t buf_timestamp;\n\tuint64_t sample_timestamp;\n\tuint64_t ret_addr;\n\tuint64_t ctc_timestamp;\n\tuint64_t ctc_delta;\n\tuint64_t cycle_cnt;\n\tuint64_t cyc_ref_timestamp;\n\tuint64_t first_timestamp;\n\tuint64_t last_reliable_timestamp;\n\tuint64_t vmcs;\n\tuint64_t print_once;\n\tuint64_t last_ctc;\n\tuint32_t last_mtc;\n\tuint32_t tsc_ctc_ratio_n;\n\tuint32_t tsc_ctc_ratio_d;\n\tuint32_t tsc_ctc_mult;\n\tuint32_t tsc_slip;\n\tuint32_t ctc_rem_mask;\n\tint mtc_shift;\n\tstruct intel_pt_stack stack;\n\tenum intel_pt_pkt_state pkt_state;\n\tenum intel_pt_pkt_ctx pkt_ctx;\n\tenum intel_pt_pkt_ctx prev_pkt_ctx;\n\tenum intel_pt_blk_type blk_type;\n\tint blk_type_pos;\n\tstruct intel_pt_pkt packet;\n\tstruct intel_pt_pkt tnt;\n\tint pkt_step;\n\tint pkt_len;\n\tint last_packet_type;\n\tunsigned int cbr;\n\tunsigned int cbr_seen;\n\tunsigned int max_non_turbo_ratio;\n\tdouble max_non_turbo_ratio_fp;\n\tdouble cbr_cyc_to_tsc;\n\tdouble calc_cyc_to_tsc;\n\tbool have_calc_cyc_to_tsc;\n\tint exec_mode;\n\tunsigned int insn_bytes;\n\tuint64_t period;\n\tenum intel_pt_period_type period_type;\n\tuint64_t tot_insn_cnt;\n\tuint64_t period_insn_cnt;\n\tuint64_t period_mask;\n\tuint64_t period_ticks;\n\tuint64_t last_masked_timestamp;\n\tuint64_t tot_cyc_cnt;\n\tuint64_t sample_tot_cyc_cnt;\n\tuint64_t base_cyc_cnt;\n\tuint64_t cyc_cnt_timestamp;\n\tuint64_t ctl;\n\tuint64_t cyc_threshold;\n\tdouble tsc_to_cyc;\n\tbool continuous_period;\n\tbool overflow;\n\tbool set_fup_tx_flags;\n\tbool set_fup_ptw;\n\tbool set_fup_mwait;\n\tbool set_fup_pwre;\n\tbool set_fup_exstop;\n\tbool set_fup_bep;\n\tbool set_fup_cfe_ip;\n\tbool set_fup_cfe;\n\tbool set_fup_mode_exec;\n\tbool sample_cyc;\n\tunsigned int fup_tx_flags;\n\tunsigned int tx_flags;\n\tuint64_t fup_ptw_payload;\n\tuint64_t fup_mwait_payload;\n\tuint64_t fup_pwre_payload;\n\tuint64_t cbr_payload;\n\tuint64_t timestamp_insn_cnt;\n\tuint64_t sample_insn_cnt;\n\tuint64_t stuck_ip;\n\tstruct intel_pt_pkt fup_cfe_pkt;\n\tint max_loops;\n\tint no_progress;\n\tint stuck_ip_prd;\n\tint stuck_ip_cnt;\n\tuint64_t psb_ip;\n\tconst unsigned char *next_buf;\n\tsize_t next_len;\n\tunsigned char temp_buf[INTEL_PT_PKT_MAX_SZ];\n\tint evd_cnt;\n\tstruct intel_pt_evd evd[INTEL_PT_MAX_EVDS];\n};\n\nstatic uint64_t intel_pt_lower_power_of_2(uint64_t x)\n{\n\tint i;\n\n\tfor (i = 0; x != 1; i++)\n\t\tx >>= 1;\n\n\treturn x << i;\n}\n\n__printf(1, 2)\nstatic void p_log(const char *fmt, ...)\n{\n\tchar buf[512];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tfprintf(stderr, \"%s\\n\", buf);\n\tintel_pt_log(\"%s\\n\", buf);\n}\n\nstatic bool intel_pt_print_once(struct intel_pt_decoder *decoder,\n\t\t\t\tenum intel_pt_p_once id)\n{\n\tuint64_t bit = 1ULL << id;\n\n\tif (decoder->print_once & bit)\n\t\treturn false;\n\tdecoder->print_once |= bit;\n\treturn true;\n}\n\nstatic uint64_t intel_pt_cyc_threshold(uint64_t ctl)\n{\n\tif (!(ctl & INTEL_PT_CYC_ENABLE))\n\t\treturn 0;\n\n\treturn (ctl & INTEL_PT_CYC_THRESHOLD) >> INTEL_PT_CYC_THRESHOLD_SHIFT;\n}\n\nstatic void intel_pt_setup_period(struct intel_pt_decoder *decoder)\n{\n\tif (decoder->period_type == INTEL_PT_PERIOD_TICKS) {\n\t\tuint64_t period;\n\n\t\tperiod = intel_pt_lower_power_of_2(decoder->period);\n\t\tdecoder->period_mask  = ~(period - 1);\n\t\tdecoder->period_ticks = period;\n\t}\n}\n\nstatic uint64_t multdiv(uint64_t t, uint32_t n, uint32_t d)\n{\n\tif (!d)\n\t\treturn 0;\n\treturn (t / d) * n + ((t % d) * n) / d;\n}\n\nstruct intel_pt_decoder *intel_pt_decoder_new(struct intel_pt_params *params)\n{\n\tstruct intel_pt_decoder *decoder;\n\n\tif (!params->get_trace || !params->walk_insn)\n\t\treturn NULL;\n\n\tdecoder = zalloc(sizeof(struct intel_pt_decoder));\n\tif (!decoder)\n\t\treturn NULL;\n\n\tdecoder->get_trace          = params->get_trace;\n\tdecoder->walk_insn          = params->walk_insn;\n\tdecoder->pgd_ip             = params->pgd_ip;\n\tdecoder->lookahead          = params->lookahead;\n\tdecoder->findnew_vmcs_info  = params->findnew_vmcs_info;\n\tdecoder->data               = params->data;\n\tdecoder->return_compression = params->return_compression;\n\tdecoder->branch_enable      = params->branch_enable;\n\tdecoder->hop                = params->quick >= 1;\n\tdecoder->leap               = params->quick >= 2;\n\tdecoder->vm_time_correlation = params->vm_time_correlation;\n\tdecoder->vm_tm_corr_dry_run = params->vm_tm_corr_dry_run;\n\tdecoder->first_timestamp    = params->first_timestamp;\n\tdecoder->last_reliable_timestamp = params->first_timestamp;\n\tdecoder->max_loops          = params->max_loops ? params->max_loops : INTEL_PT_MAX_LOOPS;\n\n\tdecoder->flags              = params->flags;\n\n\tdecoder->ctl                = params->ctl;\n\tdecoder->period             = params->period;\n\tdecoder->period_type        = params->period_type;\n\n\tdecoder->max_non_turbo_ratio    = params->max_non_turbo_ratio;\n\tdecoder->max_non_turbo_ratio_fp = params->max_non_turbo_ratio;\n\n\tdecoder->cyc_threshold = intel_pt_cyc_threshold(decoder->ctl);\n\n\tintel_pt_setup_period(decoder);\n\n\tdecoder->mtc_shift = params->mtc_period;\n\tdecoder->ctc_rem_mask = (1 << decoder->mtc_shift) - 1;\n\n\tdecoder->tsc_ctc_ratio_n = params->tsc_ctc_ratio_n;\n\tdecoder->tsc_ctc_ratio_d = params->tsc_ctc_ratio_d;\n\n\tif (!decoder->tsc_ctc_ratio_n)\n\t\tdecoder->tsc_ctc_ratio_d = 0;\n\n\tif (decoder->tsc_ctc_ratio_d) {\n\t\tif (!(decoder->tsc_ctc_ratio_n % decoder->tsc_ctc_ratio_d))\n\t\t\tdecoder->tsc_ctc_mult = decoder->tsc_ctc_ratio_n /\n\t\t\t\t\t\tdecoder->tsc_ctc_ratio_d;\n\t}\n\n\t \n\tdecoder->tsc_slip = 0x10000;\n\n\tintel_pt_log(\"timestamp: mtc_shift %u\\n\", decoder->mtc_shift);\n\tintel_pt_log(\"timestamp: tsc_ctc_ratio_n %u\\n\", decoder->tsc_ctc_ratio_n);\n\tintel_pt_log(\"timestamp: tsc_ctc_ratio_d %u\\n\", decoder->tsc_ctc_ratio_d);\n\tintel_pt_log(\"timestamp: tsc_ctc_mult %u\\n\", decoder->tsc_ctc_mult);\n\tintel_pt_log(\"timestamp: tsc_slip %#x\\n\", decoder->tsc_slip);\n\n\tif (decoder->hop)\n\t\tintel_pt_log(\"Hop mode: decoding FUP and TIPs, but not TNT\\n\");\n\n\treturn decoder;\n}\n\nvoid intel_pt_set_first_timestamp(struct intel_pt_decoder *decoder,\n\t\t\t\t  uint64_t first_timestamp)\n{\n\tdecoder->first_timestamp = first_timestamp;\n}\n\nstatic void intel_pt_pop_blk(struct intel_pt_stack *stack)\n{\n\tstruct intel_pt_blk *blk = stack->blk;\n\n\tstack->blk = blk->prev;\n\tif (!stack->spare)\n\t\tstack->spare = blk;\n\telse\n\t\tfree(blk);\n}\n\nstatic uint64_t intel_pt_pop(struct intel_pt_stack *stack)\n{\n\tif (!stack->pos) {\n\t\tif (!stack->blk)\n\t\t\treturn 0;\n\t\tintel_pt_pop_blk(stack);\n\t\tif (!stack->blk)\n\t\t\treturn 0;\n\t\tstack->pos = INTEL_PT_BLK_SIZE;\n\t}\n\treturn stack->blk->ip[--stack->pos];\n}\n\nstatic int intel_pt_alloc_blk(struct intel_pt_stack *stack)\n{\n\tstruct intel_pt_blk *blk;\n\n\tif (stack->spare) {\n\t\tblk = stack->spare;\n\t\tstack->spare = NULL;\n\t} else {\n\t\tblk = malloc(sizeof(struct intel_pt_blk));\n\t\tif (!blk)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tblk->prev = stack->blk;\n\tstack->blk = blk;\n\tstack->pos = 0;\n\treturn 0;\n}\n\nstatic int intel_pt_push(struct intel_pt_stack *stack, uint64_t ip)\n{\n\tint err;\n\n\tif (!stack->blk || stack->pos == INTEL_PT_BLK_SIZE) {\n\t\terr = intel_pt_alloc_blk(stack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tstack->blk->ip[stack->pos++] = ip;\n\treturn 0;\n}\n\nstatic void intel_pt_clear_stack(struct intel_pt_stack *stack)\n{\n\twhile (stack->blk)\n\t\tintel_pt_pop_blk(stack);\n\tstack->pos = 0;\n}\n\nstatic void intel_pt_free_stack(struct intel_pt_stack *stack)\n{\n\tintel_pt_clear_stack(stack);\n\tzfree(&stack->blk);\n\tzfree(&stack->spare);\n}\n\nvoid intel_pt_decoder_free(struct intel_pt_decoder *decoder)\n{\n\tintel_pt_free_stack(&decoder->stack);\n\tfree(decoder);\n}\n\nstatic int intel_pt_ext_err(int code)\n{\n\tswitch (code) {\n\tcase -ENOMEM:\n\t\treturn INTEL_PT_ERR_NOMEM;\n\tcase -ENOSYS:\n\t\treturn INTEL_PT_ERR_INTERN;\n\tcase -EBADMSG:\n\t\treturn INTEL_PT_ERR_BADPKT;\n\tcase -ENODATA:\n\t\treturn INTEL_PT_ERR_NODATA;\n\tcase -EILSEQ:\n\t\treturn INTEL_PT_ERR_NOINSN;\n\tcase -ENOENT:\n\t\treturn INTEL_PT_ERR_MISMAT;\n\tcase -EOVERFLOW:\n\t\treturn INTEL_PT_ERR_OVR;\n\tcase -ENOSPC:\n\t\treturn INTEL_PT_ERR_LOST;\n\tcase -ELOOP:\n\t\treturn INTEL_PT_ERR_NELOOP;\n\tcase -ECONNRESET:\n\t\treturn INTEL_PT_ERR_EPTW;\n\tdefault:\n\t\treturn INTEL_PT_ERR_UNK;\n\t}\n}\n\nstatic const char *intel_pt_err_msgs[] = {\n\t[INTEL_PT_ERR_NOMEM]  = \"Memory allocation failed\",\n\t[INTEL_PT_ERR_INTERN] = \"Internal error\",\n\t[INTEL_PT_ERR_BADPKT] = \"Bad packet\",\n\t[INTEL_PT_ERR_NODATA] = \"No more data\",\n\t[INTEL_PT_ERR_NOINSN] = \"Failed to get instruction\",\n\t[INTEL_PT_ERR_MISMAT] = \"Trace doesn't match instruction\",\n\t[INTEL_PT_ERR_OVR]    = \"Overflow packet\",\n\t[INTEL_PT_ERR_LOST]   = \"Lost trace data\",\n\t[INTEL_PT_ERR_UNK]    = \"Unknown error!\",\n\t[INTEL_PT_ERR_NELOOP] = \"Never-ending loop (refer perf config intel-pt.max-loops)\",\n\t[INTEL_PT_ERR_EPTW]   = \"Broken emulated ptwrite\",\n};\n\nint intel_pt__strerror(int code, char *buf, size_t buflen)\n{\n\tif (code < 1 || code >= INTEL_PT_ERR_MAX)\n\t\tcode = INTEL_PT_ERR_UNK;\n\tstrlcpy(buf, intel_pt_err_msgs[code], buflen);\n\treturn 0;\n}\n\nstatic uint64_t intel_pt_calc_ip(const struct intel_pt_pkt *packet,\n\t\t\t\t uint64_t last_ip)\n{\n\tuint64_t ip;\n\n\tswitch (packet->count) {\n\tcase 1:\n\t\tip = (last_ip & (uint64_t)0xffffffffffff0000ULL) |\n\t\t     packet->payload;\n\t\tbreak;\n\tcase 2:\n\t\tip = (last_ip & (uint64_t)0xffffffff00000000ULL) |\n\t\t     packet->payload;\n\t\tbreak;\n\tcase 3:\n\t\tip = packet->payload;\n\t\t \n\t\tif (ip & (uint64_t)0x800000000000ULL)\n\t\t\tip |= (uint64_t)0xffff000000000000ULL;\n\t\tbreak;\n\tcase 4:\n\t\tip = (last_ip & (uint64_t)0xffff000000000000ULL) |\n\t\t     packet->payload;\n\t\tbreak;\n\tcase 6:\n\t\tip = packet->payload;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn ip;\n}\n\nstatic inline void intel_pt_set_last_ip(struct intel_pt_decoder *decoder)\n{\n\tdecoder->last_ip = intel_pt_calc_ip(&decoder->packet, decoder->last_ip);\n\tdecoder->have_last_ip = true;\n}\n\nstatic inline void intel_pt_set_ip(struct intel_pt_decoder *decoder)\n{\n\tintel_pt_set_last_ip(decoder);\n\tdecoder->ip = decoder->last_ip;\n}\n\nstatic void intel_pt_decoder_log_packet(struct intel_pt_decoder *decoder)\n{\n\tintel_pt_log_packet(&decoder->packet, decoder->pkt_len, decoder->pos,\n\t\t\t    decoder->buf);\n}\n\nstatic int intel_pt_bug(struct intel_pt_decoder *decoder)\n{\n\tintel_pt_log(\"ERROR: Internal error\\n\");\n\tdecoder->pkt_state = INTEL_PT_STATE_NO_PSB;\n\treturn -ENOSYS;\n}\n\nstatic inline void intel_pt_clear_tx_flags(struct intel_pt_decoder *decoder)\n{\n\tdecoder->tx_flags = 0;\n}\n\nstatic inline void intel_pt_update_in_tx(struct intel_pt_decoder *decoder)\n{\n\tdecoder->tx_flags = decoder->packet.payload & INTEL_PT_IN_TX;\n}\n\nstatic inline void intel_pt_update_pip(struct intel_pt_decoder *decoder)\n{\n\tdecoder->pip_payload = decoder->packet.payload;\n}\n\nstatic inline void intel_pt_update_nr(struct intel_pt_decoder *decoder)\n{\n\tdecoder->next_nr = decoder->pip_payload & 1;\n}\n\nstatic inline void intel_pt_set_nr(struct intel_pt_decoder *decoder)\n{\n\tdecoder->nr = decoder->pip_payload & 1;\n\tdecoder->next_nr = decoder->nr;\n}\n\nstatic inline void intel_pt_set_pip(struct intel_pt_decoder *decoder)\n{\n\tintel_pt_update_pip(decoder);\n\tintel_pt_set_nr(decoder);\n}\n\nstatic int intel_pt_bad_packet(struct intel_pt_decoder *decoder)\n{\n\tintel_pt_clear_tx_flags(decoder);\n\tdecoder->have_tma = false;\n\tdecoder->pkt_len = 1;\n\tdecoder->pkt_step = 1;\n\tintel_pt_decoder_log_packet(decoder);\n\tif (decoder->pkt_state != INTEL_PT_STATE_NO_PSB) {\n\t\tintel_pt_log(\"ERROR: Bad packet\\n\");\n\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR1;\n\t}\n\treturn -EBADMSG;\n}\n\nstatic inline void intel_pt_update_sample_time(struct intel_pt_decoder *decoder)\n{\n\tdecoder->sample_timestamp = decoder->timestamp;\n\tdecoder->sample_insn_cnt = decoder->timestamp_insn_cnt;\n\tdecoder->state.cycles = decoder->tot_cyc_cnt;\n}\n\nstatic void intel_pt_reposition(struct intel_pt_decoder *decoder)\n{\n\tdecoder->ip = 0;\n\tdecoder->pkt_state = INTEL_PT_STATE_NO_PSB;\n\tdecoder->timestamp = 0;\n\tdecoder->have_tma = false;\n}\n\nstatic int intel_pt_get_data(struct intel_pt_decoder *decoder, bool reposition)\n{\n\tstruct intel_pt_buffer buffer = { .buf = 0, };\n\tint ret;\n\n\tdecoder->pkt_step = 0;\n\n\tintel_pt_log(\"Getting more data\\n\");\n\tret = decoder->get_trace(&buffer, decoder->data);\n\tif (ret)\n\t\treturn ret;\n\tdecoder->buf = buffer.buf;\n\tdecoder->len = buffer.len;\n\tif (!decoder->len) {\n\t\tintel_pt_log(\"No more data\\n\");\n\t\treturn -ENODATA;\n\t}\n\tdecoder->buf_timestamp = buffer.ref_timestamp;\n\tif (!buffer.consecutive || reposition) {\n\t\tintel_pt_reposition(decoder);\n\t\tdecoder->ref_timestamp = buffer.ref_timestamp;\n\t\tdecoder->state.trace_nr = buffer.trace_nr;\n\t\tdecoder->vm_tm_corr_same_buf = false;\n\t\tintel_pt_log(\"Reference timestamp 0x%\" PRIx64 \"\\n\",\n\t\t\t     decoder->ref_timestamp);\n\t\treturn -ENOLINK;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_pt_get_next_data(struct intel_pt_decoder *decoder,\n\t\t\t\t  bool reposition)\n{\n\tif (!decoder->next_buf)\n\t\treturn intel_pt_get_data(decoder, reposition);\n\n\tdecoder->buf = decoder->next_buf;\n\tdecoder->len = decoder->next_len;\n\tdecoder->next_buf = 0;\n\tdecoder->next_len = 0;\n\treturn 0;\n}\n\nstatic int intel_pt_get_split_packet(struct intel_pt_decoder *decoder)\n{\n\tunsigned char *buf = decoder->temp_buf;\n\tsize_t old_len, len, n;\n\tint ret;\n\n\told_len = decoder->len;\n\tlen = decoder->len;\n\tmemcpy(buf, decoder->buf, len);\n\n\tret = intel_pt_get_data(decoder, false);\n\tif (ret) {\n\t\tdecoder->pos += old_len;\n\t\treturn ret < 0 ? ret : -EINVAL;\n\t}\n\n\tn = INTEL_PT_PKT_MAX_SZ - len;\n\tif (n > decoder->len)\n\t\tn = decoder->len;\n\tmemcpy(buf + len, decoder->buf, n);\n\tlen += n;\n\n\tdecoder->prev_pkt_ctx = decoder->pkt_ctx;\n\tret = intel_pt_get_packet(buf, len, &decoder->packet, &decoder->pkt_ctx);\n\tif (ret < (int)old_len) {\n\t\tdecoder->next_buf = decoder->buf;\n\t\tdecoder->next_len = decoder->len;\n\t\tdecoder->buf = buf;\n\t\tdecoder->len = old_len;\n\t\treturn intel_pt_bad_packet(decoder);\n\t}\n\n\tdecoder->next_buf = decoder->buf + (ret - old_len);\n\tdecoder->next_len = decoder->len - (ret - old_len);\n\n\tdecoder->buf = buf;\n\tdecoder->len = ret;\n\n\treturn ret;\n}\n\nstruct intel_pt_pkt_info {\n\tstruct intel_pt_decoder\t  *decoder;\n\tstruct intel_pt_pkt       packet;\n\tuint64_t                  pos;\n\tint                       pkt_len;\n\tint                       last_packet_type;\n\tvoid                      *data;\n};\n\ntypedef int (*intel_pt_pkt_cb_t)(struct intel_pt_pkt_info *pkt_info);\n\n \nstatic int intel_pt_pkt_lookahead(struct intel_pt_decoder *decoder,\n\t\t\t\t  intel_pt_pkt_cb_t cb, void *data)\n{\n\tstruct intel_pt_pkt_info pkt_info;\n\tconst unsigned char *buf = decoder->buf;\n\tenum intel_pt_pkt_ctx pkt_ctx = decoder->pkt_ctx;\n\tsize_t len = decoder->len;\n\tint ret;\n\n\tpkt_info.decoder          = decoder;\n\tpkt_info.pos              = decoder->pos;\n\tpkt_info.pkt_len          = decoder->pkt_step;\n\tpkt_info.last_packet_type = decoder->last_packet_type;\n\tpkt_info.data             = data;\n\n\twhile (1) {\n\t\tdo {\n\t\t\tpkt_info.pos += pkt_info.pkt_len;\n\t\t\tbuf          += pkt_info.pkt_len;\n\t\t\tlen          -= pkt_info.pkt_len;\n\n\t\t\tif (!len)\n\t\t\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\n\t\t\tret = intel_pt_get_packet(buf, len, &pkt_info.packet,\n\t\t\t\t\t\t  &pkt_ctx);\n\t\t\tif (!ret)\n\t\t\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tpkt_info.pkt_len = ret;\n\t\t} while (pkt_info.packet.type == INTEL_PT_PAD);\n\n\t\tret = cb(&pkt_info);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tpkt_info.last_packet_type = pkt_info.packet.type;\n\t}\n}\n\nstruct intel_pt_calc_cyc_to_tsc_info {\n\tuint64_t        cycle_cnt;\n\tunsigned int    cbr;\n\tuint32_t        last_mtc;\n\tuint64_t        ctc_timestamp;\n\tuint64_t        ctc_delta;\n\tuint64_t        tsc_timestamp;\n\tuint64_t        timestamp;\n\tbool            have_tma;\n\tbool            fixup_last_mtc;\n\tbool            from_mtc;\n\tdouble          cbr_cyc_to_tsc;\n};\n\n \nstatic void intel_pt_fixup_last_mtc(uint32_t mtc, int mtc_shift,\n\t\t\t\t    uint32_t *last_mtc)\n{\n\tuint32_t first_missing_bit = 1U << (16 - mtc_shift);\n\tuint32_t mask = ~(first_missing_bit - 1);\n\n\t*last_mtc |= mtc & mask;\n\tif (*last_mtc >= mtc) {\n\t\t*last_mtc -= first_missing_bit;\n\t\t*last_mtc &= 0xff;\n\t}\n}\n\nstatic int intel_pt_calc_cyc_cb(struct intel_pt_pkt_info *pkt_info)\n{\n\tstruct intel_pt_decoder *decoder = pkt_info->decoder;\n\tstruct intel_pt_calc_cyc_to_tsc_info *data = pkt_info->data;\n\tuint64_t timestamp;\n\tdouble cyc_to_tsc;\n\tunsigned int cbr;\n\tuint32_t mtc, mtc_delta, ctc, fc, ctc_rem;\n\n\tswitch (pkt_info->packet.type) {\n\tcase INTEL_PT_TNT:\n\tcase INTEL_PT_TIP_PGE:\n\tcase INTEL_PT_TIP:\n\tcase INTEL_PT_FUP:\n\tcase INTEL_PT_PSB:\n\tcase INTEL_PT_PIP:\n\tcase INTEL_PT_MODE_EXEC:\n\tcase INTEL_PT_MODE_TSX:\n\tcase INTEL_PT_PSBEND:\n\tcase INTEL_PT_PAD:\n\tcase INTEL_PT_VMCS:\n\tcase INTEL_PT_MNT:\n\tcase INTEL_PT_PTWRITE:\n\tcase INTEL_PT_PTWRITE_IP:\n\tcase INTEL_PT_BBP:\n\tcase INTEL_PT_BIP:\n\tcase INTEL_PT_BEP:\n\tcase INTEL_PT_BEP_IP:\n\tcase INTEL_PT_CFE:\n\tcase INTEL_PT_CFE_IP:\n\tcase INTEL_PT_EVD:\n\t\treturn 0;\n\n\tcase INTEL_PT_MTC:\n\t\tif (!data->have_tma)\n\t\t\treturn 0;\n\n\t\tmtc = pkt_info->packet.payload;\n\t\tif (decoder->mtc_shift > 8 && data->fixup_last_mtc) {\n\t\t\tdata->fixup_last_mtc = false;\n\t\t\tintel_pt_fixup_last_mtc(mtc, decoder->mtc_shift,\n\t\t\t\t\t\t&data->last_mtc);\n\t\t}\n\t\tif (mtc > data->last_mtc)\n\t\t\tmtc_delta = mtc - data->last_mtc;\n\t\telse\n\t\t\tmtc_delta = mtc + 256 - data->last_mtc;\n\t\tdata->ctc_delta += mtc_delta << decoder->mtc_shift;\n\t\tdata->last_mtc = mtc;\n\n\t\tif (decoder->tsc_ctc_mult) {\n\t\t\ttimestamp = data->ctc_timestamp +\n\t\t\t\tdata->ctc_delta * decoder->tsc_ctc_mult;\n\t\t} else {\n\t\t\ttimestamp = data->ctc_timestamp +\n\t\t\t\tmultdiv(data->ctc_delta,\n\t\t\t\t\tdecoder->tsc_ctc_ratio_n,\n\t\t\t\t\tdecoder->tsc_ctc_ratio_d);\n\t\t}\n\n\t\tif (timestamp < data->timestamp)\n\t\t\treturn 1;\n\n\t\tif (pkt_info->last_packet_type != INTEL_PT_CYC) {\n\t\t\tdata->timestamp = timestamp;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbreak;\n\n\tcase INTEL_PT_TSC:\n\t\t \n\t\tif (data->from_mtc)\n\t\t\treturn 1;\n\t\ttimestamp = pkt_info->packet.payload |\n\t\t\t    (data->timestamp & (0xffULL << 56));\n\t\tif (data->from_mtc && timestamp < data->timestamp &&\n\t\t    data->timestamp - timestamp < decoder->tsc_slip)\n\t\t\treturn 1;\n\t\tif (timestamp < data->timestamp)\n\t\t\ttimestamp += (1ULL << 56);\n\t\tif (pkt_info->last_packet_type != INTEL_PT_CYC) {\n\t\t\tif (data->from_mtc)\n\t\t\t\treturn 1;\n\t\t\tdata->tsc_timestamp = timestamp;\n\t\t\tdata->timestamp = timestamp;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase INTEL_PT_TMA:\n\t\tif (data->from_mtc)\n\t\t\treturn 1;\n\n\t\tif (!decoder->tsc_ctc_ratio_d)\n\t\t\treturn 0;\n\n\t\tctc = pkt_info->packet.payload;\n\t\tfc = pkt_info->packet.count;\n\t\tctc_rem = ctc & decoder->ctc_rem_mask;\n\n\t\tdata->last_mtc = (ctc >> decoder->mtc_shift) & 0xff;\n\n\t\tdata->ctc_timestamp = data->tsc_timestamp - fc;\n\t\tif (decoder->tsc_ctc_mult) {\n\t\t\tdata->ctc_timestamp -= ctc_rem * decoder->tsc_ctc_mult;\n\t\t} else {\n\t\t\tdata->ctc_timestamp -=\n\t\t\t\tmultdiv(ctc_rem, decoder->tsc_ctc_ratio_n,\n\t\t\t\t\tdecoder->tsc_ctc_ratio_d);\n\t\t}\n\n\t\tdata->ctc_delta = 0;\n\t\tdata->have_tma = true;\n\t\tdata->fixup_last_mtc = true;\n\n\t\treturn 0;\n\n\tcase INTEL_PT_CYC:\n\t\tdata->cycle_cnt += pkt_info->packet.payload;\n\t\treturn 0;\n\n\tcase INTEL_PT_CBR:\n\t\tcbr = pkt_info->packet.payload;\n\t\tif (data->cbr && data->cbr != cbr)\n\t\t\treturn 1;\n\t\tdata->cbr = cbr;\n\t\tdata->cbr_cyc_to_tsc = decoder->max_non_turbo_ratio_fp / cbr;\n\t\treturn 0;\n\n\tcase INTEL_PT_TIP_PGD:\n\tcase INTEL_PT_TRACESTOP:\n\tcase INTEL_PT_EXSTOP:\n\tcase INTEL_PT_EXSTOP_IP:\n\tcase INTEL_PT_MWAIT:\n\tcase INTEL_PT_PWRE:\n\tcase INTEL_PT_PWRX:\n\tcase INTEL_PT_OVF:\n\tcase INTEL_PT_BAD:  \n\tdefault:\n\t\treturn 1;\n\t}\n\n\tif (!data->cbr && decoder->cbr) {\n\t\tdata->cbr = decoder->cbr;\n\t\tdata->cbr_cyc_to_tsc = decoder->cbr_cyc_to_tsc;\n\t}\n\n\tif (!data->cycle_cnt)\n\t\treturn 1;\n\n\tcyc_to_tsc = (double)(timestamp - decoder->timestamp) / data->cycle_cnt;\n\n\tif (data->cbr && cyc_to_tsc > data->cbr_cyc_to_tsc &&\n\t    cyc_to_tsc / data->cbr_cyc_to_tsc > 1.25) {\n\t\tintel_pt_log(\"Timestamp: calculated %g TSC ticks per cycle too big (c.f. CBR-based value %g), pos \" x64_fmt \"\\n\",\n\t\t\t     cyc_to_tsc, data->cbr_cyc_to_tsc, pkt_info->pos);\n\t\treturn 1;\n\t}\n\n\tdecoder->calc_cyc_to_tsc = cyc_to_tsc;\n\tdecoder->have_calc_cyc_to_tsc = true;\n\n\tif (data->cbr) {\n\t\tintel_pt_log(\"Timestamp: calculated %g TSC ticks per cycle c.f. CBR-based value %g, pos \" x64_fmt \"\\n\",\n\t\t\t     cyc_to_tsc, data->cbr_cyc_to_tsc, pkt_info->pos);\n\t} else {\n\t\tintel_pt_log(\"Timestamp: calculated %g TSC ticks per cycle c.f. unknown CBR-based value, pos \" x64_fmt \"\\n\",\n\t\t\t     cyc_to_tsc, pkt_info->pos);\n\t}\n\n\treturn 1;\n}\n\nstatic void intel_pt_calc_cyc_to_tsc(struct intel_pt_decoder *decoder,\n\t\t\t\t     bool from_mtc)\n{\n\tstruct intel_pt_calc_cyc_to_tsc_info data = {\n\t\t.cycle_cnt      = 0,\n\t\t.cbr            = 0,\n\t\t.last_mtc       = decoder->last_mtc,\n\t\t.ctc_timestamp  = decoder->ctc_timestamp,\n\t\t.ctc_delta      = decoder->ctc_delta,\n\t\t.tsc_timestamp  = decoder->tsc_timestamp,\n\t\t.timestamp      = decoder->timestamp,\n\t\t.have_tma       = decoder->have_tma,\n\t\t.fixup_last_mtc = decoder->fixup_last_mtc,\n\t\t.from_mtc       = from_mtc,\n\t\t.cbr_cyc_to_tsc = 0,\n\t};\n\n\t \n\tif (!from_mtc)\n\t\treturn;\n\n\tintel_pt_pkt_lookahead(decoder, intel_pt_calc_cyc_cb, &data);\n}\n\nstatic int intel_pt_get_next_packet(struct intel_pt_decoder *decoder)\n{\n\tint ret;\n\n\tdecoder->last_packet_type = decoder->packet.type;\n\n\tdo {\n\t\tdecoder->pos += decoder->pkt_step;\n\t\tdecoder->buf += decoder->pkt_step;\n\t\tdecoder->len -= decoder->pkt_step;\n\n\t\tif (!decoder->len) {\n\t\t\tret = intel_pt_get_next_data(decoder, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tdecoder->prev_pkt_ctx = decoder->pkt_ctx;\n\t\tret = intel_pt_get_packet(decoder->buf, decoder->len,\n\t\t\t\t\t  &decoder->packet, &decoder->pkt_ctx);\n\t\tif (ret == INTEL_PT_NEED_MORE_BYTES && BITS_PER_LONG == 32 &&\n\t\t    decoder->len < INTEL_PT_PKT_MAX_SZ && !decoder->next_buf) {\n\t\t\tret = intel_pt_get_split_packet(decoder);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (ret <= 0)\n\t\t\treturn intel_pt_bad_packet(decoder);\n\n\t\tdecoder->pkt_len = ret;\n\t\tdecoder->pkt_step = ret;\n\t\tintel_pt_decoder_log_packet(decoder);\n\t} while (decoder->packet.type == INTEL_PT_PAD);\n\n\treturn 0;\n}\n\nstatic uint64_t intel_pt_next_period(struct intel_pt_decoder *decoder)\n{\n\tuint64_t timestamp, masked_timestamp;\n\n\ttimestamp = decoder->timestamp + decoder->timestamp_insn_cnt;\n\tmasked_timestamp = timestamp & decoder->period_mask;\n\tif (decoder->continuous_period) {\n\t\tif (masked_timestamp > decoder->last_masked_timestamp)\n\t\t\treturn 1;\n\t} else {\n\t\ttimestamp += 1;\n\t\tmasked_timestamp = timestamp & decoder->period_mask;\n\t\tif (masked_timestamp > decoder->last_masked_timestamp) {\n\t\t\tdecoder->last_masked_timestamp = masked_timestamp;\n\t\t\tdecoder->continuous_period = true;\n\t\t}\n\t}\n\n\tif (masked_timestamp < decoder->last_masked_timestamp)\n\t\treturn decoder->period_ticks;\n\n\treturn decoder->period_ticks - (timestamp - masked_timestamp);\n}\n\nstatic uint64_t intel_pt_next_sample(struct intel_pt_decoder *decoder)\n{\n\tswitch (decoder->period_type) {\n\tcase INTEL_PT_PERIOD_INSTRUCTIONS:\n\t\treturn decoder->period - decoder->period_insn_cnt;\n\tcase INTEL_PT_PERIOD_TICKS:\n\t\treturn intel_pt_next_period(decoder);\n\tcase INTEL_PT_PERIOD_NONE:\n\tcase INTEL_PT_PERIOD_MTC:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void intel_pt_sample_insn(struct intel_pt_decoder *decoder)\n{\n\tuint64_t timestamp, masked_timestamp;\n\n\tswitch (decoder->period_type) {\n\tcase INTEL_PT_PERIOD_INSTRUCTIONS:\n\t\tdecoder->period_insn_cnt = 0;\n\t\tbreak;\n\tcase INTEL_PT_PERIOD_TICKS:\n\t\ttimestamp = decoder->timestamp + decoder->timestamp_insn_cnt;\n\t\tmasked_timestamp = timestamp & decoder->period_mask;\n\t\tif (masked_timestamp > decoder->last_masked_timestamp)\n\t\t\tdecoder->last_masked_timestamp = masked_timestamp;\n\t\telse\n\t\t\tdecoder->last_masked_timestamp += decoder->period_ticks;\n\t\tbreak;\n\tcase INTEL_PT_PERIOD_NONE:\n\tcase INTEL_PT_PERIOD_MTC:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdecoder->state.type |= INTEL_PT_INSTRUCTION;\n}\n\n \nstatic void intel_pt_sample_fup_insn(struct intel_pt_decoder *decoder)\n{\n\tstruct intel_pt_insn intel_pt_insn;\n\tuint64_t max_insn_cnt, insn_cnt = 0;\n\tint err;\n\n\tdecoder->state.insn_op = INTEL_PT_OP_OTHER;\n\tdecoder->state.insn_len = 0;\n\n\tif (!decoder->branch_enable || !decoder->pge || decoder->hop ||\n\t    decoder->ip != decoder->last_ip)\n\t\treturn;\n\n\tif (!decoder->mtc_insn)\n\t\tdecoder->mtc_insn = true;\n\n\tmax_insn_cnt = intel_pt_next_sample(decoder);\n\tif (max_insn_cnt != 1)\n\t\treturn;\n\n\terr = decoder->walk_insn(&intel_pt_insn, &insn_cnt, &decoder->ip,\n\t\t\t\t 0, max_insn_cnt, decoder->data);\n\t \n\tif (err)\n\t\treturn;\n\n\tif (intel_pt_insn.branch != INTEL_PT_BR_NO_BRANCH) {\n\t\tintel_pt_log_at(\"ERROR: Unexpected branch at FUP instruction\", decoder->ip);\n\t\treturn;\n\t}\n\n\tdecoder->tot_insn_cnt += insn_cnt;\n\tdecoder->timestamp_insn_cnt += insn_cnt;\n\tdecoder->sample_insn_cnt += insn_cnt;\n\tdecoder->period_insn_cnt += insn_cnt;\n\n\tintel_pt_sample_insn(decoder);\n\n\tdecoder->state.type |= INTEL_PT_INSTRUCTION;\n\tdecoder->ip += intel_pt_insn.length;\n}\n\nstatic int intel_pt_walk_insn(struct intel_pt_decoder *decoder,\n\t\t\t      struct intel_pt_insn *intel_pt_insn, uint64_t ip)\n{\n\tuint64_t max_insn_cnt, insn_cnt = 0;\n\tint err;\n\n\tif (!decoder->mtc_insn)\n\t\tdecoder->mtc_insn = true;\n\n\tmax_insn_cnt = intel_pt_next_sample(decoder);\n\n\terr = decoder->walk_insn(intel_pt_insn, &insn_cnt, &decoder->ip, ip,\n\t\t\t\t max_insn_cnt, decoder->data);\n\n\tdecoder->tot_insn_cnt += insn_cnt;\n\tdecoder->timestamp_insn_cnt += insn_cnt;\n\tdecoder->sample_insn_cnt += insn_cnt;\n\tdecoder->period_insn_cnt += insn_cnt;\n\n\tif (err) {\n\t\tdecoder->no_progress = 0;\n\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR2;\n\t\tintel_pt_log_at(\"ERROR: Failed to get instruction\",\n\t\t\t\tdecoder->ip);\n\t\tif (err == -ENOENT)\n\t\t\treturn -ENOLINK;\n\t\treturn -EILSEQ;\n\t}\n\n\tif (ip && decoder->ip == ip) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (max_insn_cnt && insn_cnt >= max_insn_cnt)\n\t\tintel_pt_sample_insn(decoder);\n\n\tif (intel_pt_insn->branch == INTEL_PT_BR_NO_BRANCH) {\n\t\tdecoder->state.type = INTEL_PT_INSTRUCTION;\n\t\tdecoder->state.from_ip = decoder->ip;\n\t\tdecoder->state.to_ip = 0;\n\t\tdecoder->ip += intel_pt_insn->length;\n\t\terr = INTEL_PT_RETURN;\n\t\tgoto out;\n\t}\n\n\tif (intel_pt_insn->op == INTEL_PT_OP_CALL) {\n\t\t \n\t\tif (intel_pt_insn->branch != INTEL_PT_BR_UNCONDITIONAL ||\n\t\t    intel_pt_insn->rel) {\n\t\t\terr = intel_pt_push(&decoder->stack, decoder->ip +\n\t\t\t\t\t    intel_pt_insn->length);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (intel_pt_insn->op == INTEL_PT_OP_RET) {\n\t\tdecoder->ret_addr = intel_pt_pop(&decoder->stack);\n\t}\n\n\tif (intel_pt_insn->branch == INTEL_PT_BR_UNCONDITIONAL) {\n\t\tint cnt = decoder->no_progress++;\n\n\t\tdecoder->state.from_ip = decoder->ip;\n\t\tdecoder->ip += intel_pt_insn->length +\n\t\t\t\tintel_pt_insn->rel;\n\t\tdecoder->state.to_ip = decoder->ip;\n\t\terr = INTEL_PT_RETURN;\n\n\t\t \n\t\tif (cnt) {\n\t\t\tif (cnt == 1) {\n\t\t\t\tdecoder->stuck_ip = decoder->state.to_ip;\n\t\t\t\tdecoder->stuck_ip_prd = 1;\n\t\t\t\tdecoder->stuck_ip_cnt = 1;\n\t\t\t} else if (cnt > decoder->max_loops ||\n\t\t\t\t   decoder->state.to_ip == decoder->stuck_ip) {\n\t\t\t\tintel_pt_log_at(\"ERROR: Never-ending loop\",\n\t\t\t\t\t\tdecoder->state.to_ip);\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;\n\t\t\t\terr = -ELOOP;\n\t\t\t\tgoto out;\n\t\t\t} else if (!--decoder->stuck_ip_cnt) {\n\t\t\t\tdecoder->stuck_ip_prd += 1;\n\t\t\t\tdecoder->stuck_ip_cnt = decoder->stuck_ip_prd;\n\t\t\t\tdecoder->stuck_ip = decoder->state.to_ip;\n\t\t\t}\n\t\t}\n\t\tgoto out_no_progress;\n\t}\nout:\n\tdecoder->no_progress = 0;\nout_no_progress:\n\tdecoder->state.insn_op = intel_pt_insn->op;\n\tdecoder->state.insn_len = intel_pt_insn->length;\n\tmemcpy(decoder->state.insn, intel_pt_insn->buf,\n\t       INTEL_PT_INSN_BUF_SZ);\n\n\tif (decoder->tx_flags & INTEL_PT_IN_TX)\n\t\tdecoder->state.flags |= INTEL_PT_IN_TX;\n\n\treturn err;\n}\n\nstatic void intel_pt_mode_exec_status(struct intel_pt_decoder *decoder)\n{\n\tbool iflag = decoder->packet.count & INTEL_PT_IFLAG;\n\n\tdecoder->exec_mode = decoder->packet.payload;\n\tdecoder->iflag = iflag;\n\tdecoder->next_iflag = iflag;\n\tdecoder->state.from_iflag = iflag;\n\tdecoder->state.to_iflag = iflag;\n}\n\nstatic void intel_pt_mode_exec(struct intel_pt_decoder *decoder)\n{\n\tbool iflag = decoder->packet.count & INTEL_PT_IFLAG;\n\n\tdecoder->exec_mode = decoder->packet.payload;\n\tdecoder->next_iflag = iflag;\n}\n\nstatic void intel_pt_sample_iflag(struct intel_pt_decoder *decoder)\n{\n\tdecoder->state.type |= INTEL_PT_IFLAG_CHG;\n\tdecoder->state.from_iflag = decoder->iflag;\n\tdecoder->state.to_iflag = decoder->next_iflag;\n\tdecoder->iflag = decoder->next_iflag;\n}\n\nstatic void intel_pt_sample_iflag_chg(struct intel_pt_decoder *decoder)\n{\n\tif (decoder->iflag != decoder->next_iflag)\n\t\tintel_pt_sample_iflag(decoder);\n}\n\nstatic void intel_pt_clear_fup_event(struct intel_pt_decoder *decoder)\n{\n\tdecoder->set_fup_tx_flags = false;\n\tdecoder->set_fup_ptw = false;\n\tdecoder->set_fup_mwait = false;\n\tdecoder->set_fup_pwre = false;\n\tdecoder->set_fup_exstop = false;\n\tdecoder->set_fup_bep = false;\n\tdecoder->set_fup_cfe_ip = false;\n\tdecoder->set_fup_cfe = false;\n\tdecoder->evd_cnt = 0;\n\tdecoder->set_fup_mode_exec = false;\n\tdecoder->iflag = decoder->next_iflag;\n}\n\nstatic bool intel_pt_fup_event(struct intel_pt_decoder *decoder, bool no_tip)\n{\n\tenum intel_pt_sample_type type = decoder->state.type;\n\tbool sample_fup_insn = false;\n\tbool ret = false;\n\n\tdecoder->state.type &= ~INTEL_PT_BRANCH;\n\n\tif (decoder->set_fup_cfe_ip || decoder->set_fup_cfe) {\n\t\tbool ip = decoder->set_fup_cfe_ip;\n\n\t\tdecoder->set_fup_cfe_ip = false;\n\t\tdecoder->set_fup_cfe = false;\n\t\tdecoder->state.type |= INTEL_PT_EVT;\n\t\tif (!ip && decoder->pge)\n\t\t\tdecoder->state.type |= INTEL_PT_BRANCH;\n\t\tdecoder->state.cfe_type = decoder->fup_cfe_pkt.count;\n\t\tdecoder->state.cfe_vector = decoder->fup_cfe_pkt.payload;\n\t\tdecoder->state.evd_cnt = decoder->evd_cnt;\n\t\tdecoder->state.evd = decoder->evd;\n\t\tdecoder->evd_cnt = 0;\n\t\tif (ip || decoder->pge)\n\t\t\tdecoder->state.flags |= INTEL_PT_FUP_IP;\n\t\tret = true;\n\t}\n\tif (decoder->set_fup_mode_exec) {\n\t\tdecoder->set_fup_mode_exec = false;\n\t\tintel_pt_sample_iflag(decoder);\n\t\tsample_fup_insn = no_tip;\n\t\tret = true;\n\t}\n\tif (decoder->set_fup_tx_flags) {\n\t\tdecoder->set_fup_tx_flags = false;\n\t\tdecoder->tx_flags = decoder->fup_tx_flags;\n\t\tdecoder->state.type |= INTEL_PT_TRANSACTION;\n\t\tif (decoder->fup_tx_flags & INTEL_PT_ABORT_TX)\n\t\t\tdecoder->state.type |= INTEL_PT_BRANCH;\n\t\tdecoder->state.flags = decoder->fup_tx_flags;\n\t\tret = true;\n\t}\n\tif (decoder->set_fup_ptw) {\n\t\tdecoder->set_fup_ptw = false;\n\t\tdecoder->state.type |= INTEL_PT_PTW;\n\t\tdecoder->state.flags |= INTEL_PT_FUP_IP;\n\t\tdecoder->state.ptw_payload = decoder->fup_ptw_payload;\n\t\tret = true;\n\t}\n\tif (decoder->set_fup_mwait) {\n\t\tdecoder->set_fup_mwait = false;\n\t\tdecoder->state.type |= INTEL_PT_MWAIT_OP;\n\t\tdecoder->state.mwait_payload = decoder->fup_mwait_payload;\n\t\tret = true;\n\t}\n\tif (decoder->set_fup_pwre) {\n\t\tdecoder->set_fup_pwre = false;\n\t\tdecoder->state.type |= INTEL_PT_PWR_ENTRY;\n\t\tdecoder->state.pwre_payload = decoder->fup_pwre_payload;\n\t\tret = true;\n\t}\n\tif (decoder->set_fup_exstop) {\n\t\tdecoder->set_fup_exstop = false;\n\t\tdecoder->state.type |= INTEL_PT_EX_STOP;\n\t\tdecoder->state.flags |= INTEL_PT_FUP_IP;\n\t\tret = true;\n\t}\n\tif (decoder->set_fup_bep) {\n\t\tdecoder->set_fup_bep = false;\n\t\tdecoder->state.type |= INTEL_PT_BLK_ITEMS;\n\t\tret = true;\n\t}\n\tif (decoder->overflow) {\n\t\tdecoder->overflow = false;\n\t\tif (!ret && !decoder->pge) {\n\t\t\tif (decoder->hop) {\n\t\t\t\tdecoder->state.type = 0;\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_RESAMPLE;\n\t\t\t}\n\t\t\tdecoder->pge = true;\n\t\t\tdecoder->state.type |= INTEL_PT_BRANCH | INTEL_PT_TRACE_BEGIN;\n\t\t\tdecoder->state.from_ip = 0;\n\t\t\tdecoder->state.to_ip = decoder->ip;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (ret) {\n\t\tdecoder->state.from_ip = decoder->ip;\n\t\tdecoder->state.to_ip = 0;\n\t\tif (sample_fup_insn)\n\t\t\tintel_pt_sample_fup_insn(decoder);\n\t} else {\n\t\tdecoder->state.type = type;\n\t}\n\treturn ret;\n}\n\nstatic inline bool intel_pt_fup_with_nlip(struct intel_pt_decoder *decoder,\n\t\t\t\t\t  struct intel_pt_insn *intel_pt_insn,\n\t\t\t\t\t  uint64_t ip, int err)\n{\n\treturn decoder->flags & INTEL_PT_FUP_WITH_NLIP && !err &&\n\t       intel_pt_insn->branch == INTEL_PT_BR_INDIRECT &&\n\t       ip == decoder->ip + intel_pt_insn->length;\n}\n\nstatic int intel_pt_walk_fup(struct intel_pt_decoder *decoder)\n{\n\tstruct intel_pt_insn intel_pt_insn;\n\tuint64_t ip;\n\tint err;\n\n\tip = decoder->last_ip;\n\n\twhile (1) {\n\t\terr = intel_pt_walk_insn(decoder, &intel_pt_insn, ip);\n\t\tif (err == INTEL_PT_RETURN)\n\t\t\treturn 0;\n\t\tif (err == -EAGAIN ||\n\t\t    intel_pt_fup_with_nlip(decoder, &intel_pt_insn, ip, err)) {\n\t\t\tbool no_tip = decoder->pkt_state != INTEL_PT_STATE_FUP;\n\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\t\t\tif (intel_pt_fup_event(decoder, no_tip) && no_tip)\n\t\t\t\treturn 0;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tdecoder->set_fup_tx_flags = false;\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (intel_pt_insn.branch == INTEL_PT_BR_INDIRECT) {\n\t\t\tintel_pt_log_at(\"ERROR: Unexpected indirect branch\",\n\t\t\t\t\tdecoder->ip);\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (intel_pt_insn.branch == INTEL_PT_BR_CONDITIONAL) {\n\t\t\tintel_pt_log_at(\"ERROR: Unexpected conditional branch\",\n\t\t\t\t\tdecoder->ip);\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tintel_pt_bug(decoder);\n\t}\n}\n\nstatic int intel_pt_walk_tip(struct intel_pt_decoder *decoder)\n{\n\tstruct intel_pt_insn intel_pt_insn;\n\tint err;\n\n\terr = intel_pt_walk_insn(decoder, &intel_pt_insn, 0);\n\tif (err == INTEL_PT_RETURN &&\n\t    decoder->pgd_ip &&\n\t    decoder->pkt_state == INTEL_PT_STATE_TIP_PGD &&\n\t    (decoder->state.type & INTEL_PT_BRANCH) &&\n\t    decoder->pgd_ip(decoder->state.to_ip, decoder->data)) {\n\t\t \n\t\tdecoder->no_progress = 0;\n\t\tdecoder->pge = false;\n\t\tdecoder->continuous_period = false;\n\t\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\t\tdecoder->state.type |= INTEL_PT_TRACE_END;\n\t\tintel_pt_update_nr(decoder);\n\t\treturn 0;\n\t}\n\tif (err == INTEL_PT_RETURN)\n\t\treturn 0;\n\tif (err)\n\t\treturn err;\n\n\tintel_pt_update_nr(decoder);\n\tintel_pt_sample_iflag_chg(decoder);\n\n\tif (intel_pt_insn.branch == INTEL_PT_BR_INDIRECT) {\n\t\tif (decoder->pkt_state == INTEL_PT_STATE_TIP_PGD) {\n\t\t\tdecoder->pge = false;\n\t\t\tdecoder->continuous_period = false;\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tif (decoder->packet.count == 0) {\n\t\t\t\tdecoder->state.to_ip = 0;\n\t\t\t} else {\n\t\t\t\tdecoder->state.to_ip = decoder->last_ip;\n\t\t\t\tdecoder->ip = decoder->last_ip;\n\t\t\t}\n\t\t\tdecoder->state.type |= INTEL_PT_TRACE_END;\n\t\t} else {\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tif (decoder->packet.count == 0) {\n\t\t\t\tdecoder->state.to_ip = 0;\n\t\t\t} else {\n\t\t\t\tdecoder->state.to_ip = decoder->last_ip;\n\t\t\t\tdecoder->ip = decoder->last_ip;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (intel_pt_insn.branch == INTEL_PT_BR_CONDITIONAL) {\n\t\tuint64_t to_ip = decoder->ip + intel_pt_insn.length +\n\t\t\t\t intel_pt_insn.rel;\n\n\t\tif (decoder->pgd_ip &&\n\t\t    decoder->pkt_state == INTEL_PT_STATE_TIP_PGD &&\n\t\t    decoder->pgd_ip(to_ip, decoder->data)) {\n\t\t\t \n\t\t\tdecoder->pge = false;\n\t\t\tdecoder->continuous_period = false;\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\t\t\tdecoder->ip = to_ip;\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tdecoder->state.to_ip = to_ip;\n\t\t\tdecoder->state.type |= INTEL_PT_TRACE_END;\n\t\t\treturn 0;\n\t\t}\n\t\tintel_pt_log_at(\"ERROR: Conditional branch when expecting indirect branch\",\n\t\t\t\tdecoder->ip);\n\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;\n\t\treturn -ENOENT;\n\t}\n\n\treturn intel_pt_bug(decoder);\n}\n\nstruct eptw_data {\n\tint bit_countdown;\n\tuint64_t payload;\n};\n\nstatic int intel_pt_eptw_lookahead_cb(struct intel_pt_pkt_info *pkt_info)\n{\n\tstruct eptw_data *data = pkt_info->data;\n\tint nr_bits;\n\n\tswitch (pkt_info->packet.type) {\n\tcase INTEL_PT_PAD:\n\tcase INTEL_PT_MNT:\n\tcase INTEL_PT_MODE_EXEC:\n\tcase INTEL_PT_MODE_TSX:\n\tcase INTEL_PT_MTC:\n\tcase INTEL_PT_FUP:\n\tcase INTEL_PT_CYC:\n\tcase INTEL_PT_CBR:\n\tcase INTEL_PT_TSC:\n\tcase INTEL_PT_TMA:\n\tcase INTEL_PT_PIP:\n\tcase INTEL_PT_VMCS:\n\tcase INTEL_PT_PSB:\n\tcase INTEL_PT_PSBEND:\n\tcase INTEL_PT_PTWRITE:\n\tcase INTEL_PT_PTWRITE_IP:\n\tcase INTEL_PT_EXSTOP:\n\tcase INTEL_PT_EXSTOP_IP:\n\tcase INTEL_PT_MWAIT:\n\tcase INTEL_PT_PWRE:\n\tcase INTEL_PT_PWRX:\n\tcase INTEL_PT_BBP:\n\tcase INTEL_PT_BIP:\n\tcase INTEL_PT_BEP:\n\tcase INTEL_PT_BEP_IP:\n\tcase INTEL_PT_CFE:\n\tcase INTEL_PT_CFE_IP:\n\tcase INTEL_PT_EVD:\n\t\tbreak;\n\n\tcase INTEL_PT_TNT:\n\t\tnr_bits = data->bit_countdown;\n\t\tif (nr_bits > pkt_info->packet.count)\n\t\t\tnr_bits = pkt_info->packet.count;\n\t\tdata->payload <<= nr_bits;\n\t\tdata->payload |= pkt_info->packet.payload >> (64 - nr_bits);\n\t\tdata->bit_countdown -= nr_bits;\n\t\treturn !data->bit_countdown;\n\n\tcase INTEL_PT_TIP_PGE:\n\tcase INTEL_PT_TIP_PGD:\n\tcase INTEL_PT_TIP:\n\tcase INTEL_PT_BAD:\n\tcase INTEL_PT_OVF:\n\tcase INTEL_PT_TRACESTOP:\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_pt_emulated_ptwrite(struct intel_pt_decoder *decoder)\n{\n\tint n = 64 - decoder->tnt.count;\n\tstruct eptw_data data = {\n\t\t.bit_countdown = n,\n\t\t.payload = decoder->tnt.payload >> n,\n\t};\n\n\tdecoder->emulated_ptwrite = false;\n\tintel_pt_log(\"Emulated ptwrite detected\\n\");\n\n\tintel_pt_pkt_lookahead(decoder, intel_pt_eptw_lookahead_cb, &data);\n\tif (data.bit_countdown)\n\t\treturn -ECONNRESET;\n\n\tdecoder->state.type = INTEL_PT_PTW;\n\tdecoder->state.from_ip = decoder->ip;\n\tdecoder->state.to_ip = 0;\n\tdecoder->state.ptw_payload = data.payload;\n\treturn 0;\n}\n\nstatic int intel_pt_walk_tnt(struct intel_pt_decoder *decoder)\n{\n\tstruct intel_pt_insn intel_pt_insn;\n\tint err;\n\n\twhile (1) {\n\t\tif (decoder->emulated_ptwrite)\n\t\t\treturn intel_pt_emulated_ptwrite(decoder);\n\t\terr = intel_pt_walk_insn(decoder, &intel_pt_insn, 0);\n\t\tif (err == INTEL_PT_RETURN) {\n\t\t\tdecoder->emulated_ptwrite = intel_pt_insn.emulated_ptwrite;\n\t\t\treturn 0;\n\t\t}\n\t\tif (err) {\n\t\t\tdecoder->emulated_ptwrite = false;\n\t\t\treturn err;\n\t\t}\n\n\t\tif (intel_pt_insn.op == INTEL_PT_OP_RET) {\n\t\t\tif (!decoder->return_compression) {\n\t\t\t\tintel_pt_log_at(\"ERROR: RET when expecting conditional branch\",\n\t\t\t\t\t\tdecoder->ip);\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR3;\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\tif (!decoder->ret_addr) {\n\t\t\t\tintel_pt_log_at(\"ERROR: Bad RET compression (stack empty)\",\n\t\t\t\t\t\tdecoder->ip);\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR3;\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\tif (!(decoder->tnt.payload & BIT63)) {\n\t\t\t\tintel_pt_log_at(\"ERROR: Bad RET compression (TNT=N)\",\n\t\t\t\t\t\tdecoder->ip);\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR3;\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\tdecoder->tnt.count -= 1;\n\t\t\tif (decoder->tnt.count)\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_TNT_CONT;\n\t\t\telse\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\t\t\tdecoder->tnt.payload <<= 1;\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tdecoder->ip = decoder->ret_addr;\n\t\t\tdecoder->state.to_ip = decoder->ip;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (intel_pt_insn.branch == INTEL_PT_BR_INDIRECT) {\n\t\t\t \n\t\t\terr = intel_pt_get_next_packet(decoder);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (decoder->packet.type != INTEL_PT_TIP ||\n\t\t\t    decoder->packet.count == 0) {\n\t\t\t\tintel_pt_log_at(\"ERROR: Missing deferred TIP for indirect branch\",\n\t\t\t\t\t\tdecoder->ip);\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR3;\n\t\t\t\tdecoder->pkt_step = 0;\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\tintel_pt_set_last_ip(decoder);\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tdecoder->state.to_ip = decoder->last_ip;\n\t\t\tdecoder->ip = decoder->last_ip;\n\t\t\tintel_pt_update_nr(decoder);\n\t\t\tintel_pt_sample_iflag_chg(decoder);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (intel_pt_insn.branch == INTEL_PT_BR_CONDITIONAL) {\n\t\t\tdecoder->tnt.count -= 1;\n\t\t\tif (decoder->tnt.count)\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_TNT_CONT;\n\t\t\telse\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\t\t\tif (decoder->tnt.payload & BIT63) {\n\t\t\t\tdecoder->tnt.payload <<= 1;\n\t\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\t\tdecoder->ip += intel_pt_insn.length +\n\t\t\t\t\t       intel_pt_insn.rel;\n\t\t\t\tdecoder->state.to_ip = decoder->ip;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tif (decoder->state.type & INTEL_PT_INSTRUCTION) {\n\t\t\t\tdecoder->tnt.payload <<= 1;\n\t\t\t\tdecoder->state.type = INTEL_PT_INSTRUCTION;\n\t\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\t\tdecoder->state.to_ip = 0;\n\t\t\t\tdecoder->ip += intel_pt_insn.length;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdecoder->sample_cyc = false;\n\t\t\tdecoder->ip += intel_pt_insn.length;\n\t\t\tif (!decoder->tnt.count) {\n\t\t\t\tintel_pt_update_sample_time(decoder);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\tdecoder->tnt.payload <<= 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn intel_pt_bug(decoder);\n\t}\n}\n\nstatic int intel_pt_mode_tsx(struct intel_pt_decoder *decoder, bool *no_tip)\n{\n\tunsigned int fup_tx_flags;\n\tint err;\n\n\tfup_tx_flags = decoder->packet.payload &\n\t\t       (INTEL_PT_IN_TX | INTEL_PT_ABORT_TX);\n\terr = intel_pt_get_next_packet(decoder);\n\tif (err)\n\t\treturn err;\n\tif (decoder->packet.type == INTEL_PT_FUP) {\n\t\tdecoder->fup_tx_flags = fup_tx_flags;\n\t\tdecoder->set_fup_tx_flags = true;\n\t\tif (!(decoder->fup_tx_flags & INTEL_PT_ABORT_TX))\n\t\t\t*no_tip = true;\n\t} else {\n\t\tintel_pt_log_at(\"ERROR: Missing FUP after MODE.TSX\",\n\t\t\t\tdecoder->pos);\n\t\tintel_pt_update_in_tx(decoder);\n\t}\n\treturn 0;\n}\n\nstatic int intel_pt_evd(struct intel_pt_decoder *decoder)\n{\n\tif (decoder->evd_cnt >= INTEL_PT_MAX_EVDS) {\n\t\tintel_pt_log_at(\"ERROR: Too many EVD packets\", decoder->pos);\n\t\treturn -ENOSYS;\n\t}\n\tdecoder->evd[decoder->evd_cnt++] = (struct intel_pt_evd){\n\t\t.type = decoder->packet.count,\n\t\t.payload = decoder->packet.payload,\n\t};\n\treturn 0;\n}\n\nstatic uint64_t intel_pt_8b_tsc(uint64_t timestamp, uint64_t ref_timestamp)\n{\n\ttimestamp |= (ref_timestamp & (0xffULL << 56));\n\n\tif (timestamp < ref_timestamp) {\n\t\tif (ref_timestamp - timestamp > (1ULL << 55))\n\t\t\ttimestamp += (1ULL << 56);\n\t} else {\n\t\tif (timestamp - ref_timestamp > (1ULL << 55))\n\t\t\ttimestamp -= (1ULL << 56);\n\t}\n\n\treturn timestamp;\n}\n\n \nstatic bool intel_pt_time_in_range(struct intel_pt_decoder *decoder,\n\t\t\t\t   uint64_t timestamp)\n{\n\tuint64_t max_timestamp = decoder->buf_timestamp;\n\n\tif (!max_timestamp) {\n\t\tmax_timestamp = decoder->last_reliable_timestamp +\n\t\t\t\t0x400000000ULL;\n\t}\n\treturn timestamp >= decoder->last_reliable_timestamp &&\n\t       timestamp < decoder->buf_timestamp;\n}\n\nstatic void intel_pt_calc_tsc_timestamp(struct intel_pt_decoder *decoder)\n{\n\tuint64_t timestamp;\n\tbool bad = false;\n\n\tdecoder->have_tma = false;\n\n\tif (decoder->ref_timestamp) {\n\t\ttimestamp = intel_pt_8b_tsc(decoder->packet.payload,\n\t\t\t\t\t    decoder->ref_timestamp);\n\t\tdecoder->tsc_timestamp = timestamp;\n\t\tdecoder->timestamp = timestamp;\n\t\tdecoder->ref_timestamp = 0;\n\t\tdecoder->timestamp_insn_cnt = 0;\n\t} else if (decoder->timestamp) {\n\t\ttimestamp = decoder->packet.payload |\n\t\t\t    (decoder->timestamp & (0xffULL << 56));\n\t\tdecoder->tsc_timestamp = timestamp;\n\t\tif (timestamp < decoder->timestamp &&\n\t\t    decoder->timestamp - timestamp < decoder->tsc_slip) {\n\t\t\tintel_pt_log_to(\"Suppressing backwards timestamp\",\n\t\t\t\t\ttimestamp);\n\t\t\ttimestamp = decoder->timestamp;\n\t\t}\n\t\tif (timestamp < decoder->timestamp) {\n\t\t\tif (!decoder->buf_timestamp ||\n\t\t\t    (timestamp + (1ULL << 56) < decoder->buf_timestamp)) {\n\t\t\t\tintel_pt_log_to(\"Wraparound timestamp\", timestamp);\n\t\t\t\ttimestamp += (1ULL << 56);\n\t\t\t\tdecoder->tsc_timestamp = timestamp;\n\t\t\t} else {\n\t\t\t\tintel_pt_log_to(\"Suppressing bad timestamp\", timestamp);\n\t\t\t\ttimestamp = decoder->timestamp;\n\t\t\t\tbad = true;\n\t\t\t}\n\t\t}\n\t\tif (decoder->vm_time_correlation &&\n\t\t    (bad || !intel_pt_time_in_range(decoder, timestamp)) &&\n\t\t    intel_pt_print_once(decoder, INTEL_PT_PRT_ONCE_ERANGE))\n\t\t\tp_log(\"Timestamp out of range\");\n\t\tdecoder->timestamp = timestamp;\n\t\tdecoder->timestamp_insn_cnt = 0;\n\t}\n\n\tif (decoder->last_packet_type == INTEL_PT_CYC) {\n\t\tdecoder->cyc_ref_timestamp = decoder->timestamp;\n\t\tdecoder->cycle_cnt = 0;\n\t\tdecoder->have_calc_cyc_to_tsc = false;\n\t\tintel_pt_calc_cyc_to_tsc(decoder, false);\n\t}\n\n\tintel_pt_log_to(\"Setting timestamp\", decoder->timestamp);\n}\n\nstatic int intel_pt_overflow(struct intel_pt_decoder *decoder)\n{\n\tintel_pt_log(\"ERROR: Buffer overflow\\n\");\n\tintel_pt_clear_tx_flags(decoder);\n\tintel_pt_set_nr(decoder);\n\tdecoder->timestamp_insn_cnt = 0;\n\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\tdecoder->state.from_ip = decoder->ip;\n\tdecoder->ip = 0;\n\tdecoder->pge = false;\n\tintel_pt_clear_fup_event(decoder);\n\tdecoder->overflow = true;\n\treturn -EOVERFLOW;\n}\n\nstatic inline void intel_pt_mtc_cyc_cnt_pge(struct intel_pt_decoder *decoder)\n{\n\tif (decoder->have_cyc)\n\t\treturn;\n\n\tdecoder->cyc_cnt_timestamp = decoder->timestamp;\n\tdecoder->base_cyc_cnt = decoder->tot_cyc_cnt;\n}\n\nstatic inline void intel_pt_mtc_cyc_cnt_cbr(struct intel_pt_decoder *decoder)\n{\n\tdecoder->tsc_to_cyc = decoder->cbr / decoder->max_non_turbo_ratio_fp;\n\n\tif (decoder->pge)\n\t\tintel_pt_mtc_cyc_cnt_pge(decoder);\n}\n\nstatic inline void intel_pt_mtc_cyc_cnt_upd(struct intel_pt_decoder *decoder)\n{\n\tuint64_t tot_cyc_cnt, tsc_delta;\n\n\tif (decoder->have_cyc)\n\t\treturn;\n\n\tdecoder->sample_cyc = true;\n\n\tif (!decoder->pge || decoder->timestamp <= decoder->cyc_cnt_timestamp)\n\t\treturn;\n\n\ttsc_delta = decoder->timestamp - decoder->cyc_cnt_timestamp;\n\ttot_cyc_cnt = tsc_delta * decoder->tsc_to_cyc + decoder->base_cyc_cnt;\n\n\tif (tot_cyc_cnt > decoder->tot_cyc_cnt)\n\t\tdecoder->tot_cyc_cnt = tot_cyc_cnt;\n}\n\nstatic void intel_pt_calc_tma(struct intel_pt_decoder *decoder)\n{\n\tuint32_t ctc = decoder->packet.payload;\n\tuint32_t fc = decoder->packet.count;\n\tuint32_t ctc_rem = ctc & decoder->ctc_rem_mask;\n\n\tif (!decoder->tsc_ctc_ratio_d)\n\t\treturn;\n\n\tif (decoder->pge && !decoder->in_psb)\n\t\tintel_pt_mtc_cyc_cnt_pge(decoder);\n\telse\n\t\tintel_pt_mtc_cyc_cnt_upd(decoder);\n\n\tdecoder->last_mtc = (ctc >> decoder->mtc_shift) & 0xff;\n\tdecoder->last_ctc = ctc - ctc_rem;\n\tdecoder->ctc_timestamp = decoder->tsc_timestamp - fc;\n\tif (decoder->tsc_ctc_mult) {\n\t\tdecoder->ctc_timestamp -= ctc_rem * decoder->tsc_ctc_mult;\n\t} else {\n\t\tdecoder->ctc_timestamp -= multdiv(ctc_rem,\n\t\t\t\t\t\t  decoder->tsc_ctc_ratio_n,\n\t\t\t\t\t\t  decoder->tsc_ctc_ratio_d);\n\t}\n\tdecoder->ctc_delta = 0;\n\tdecoder->have_tma = true;\n\tdecoder->fixup_last_mtc = true;\n\tintel_pt_log(\"CTC timestamp \" x64_fmt \" last MTC %#x  CTC rem %#x\\n\",\n\t\t     decoder->ctc_timestamp, decoder->last_mtc, ctc_rem);\n}\n\nstatic void intel_pt_calc_mtc_timestamp(struct intel_pt_decoder *decoder)\n{\n\tuint64_t timestamp;\n\tuint32_t mtc, mtc_delta;\n\n\tif (!decoder->have_tma)\n\t\treturn;\n\n\tmtc = decoder->packet.payload;\n\n\tif (decoder->mtc_shift > 8 && decoder->fixup_last_mtc) {\n\t\tdecoder->fixup_last_mtc = false;\n\t\tintel_pt_fixup_last_mtc(mtc, decoder->mtc_shift,\n\t\t\t\t\t&decoder->last_mtc);\n\t}\n\n\tif (mtc > decoder->last_mtc)\n\t\tmtc_delta = mtc - decoder->last_mtc;\n\telse\n\t\tmtc_delta = mtc + 256 - decoder->last_mtc;\n\n\tdecoder->ctc_delta += mtc_delta << decoder->mtc_shift;\n\n\tif (decoder->tsc_ctc_mult) {\n\t\ttimestamp = decoder->ctc_timestamp +\n\t\t\t    decoder->ctc_delta * decoder->tsc_ctc_mult;\n\t} else {\n\t\ttimestamp = decoder->ctc_timestamp +\n\t\t\t    multdiv(decoder->ctc_delta,\n\t\t\t\t    decoder->tsc_ctc_ratio_n,\n\t\t\t\t    decoder->tsc_ctc_ratio_d);\n\t}\n\n\tif (timestamp < decoder->timestamp)\n\t\tintel_pt_log(\"Suppressing MTC timestamp \" x64_fmt \" less than current timestamp \" x64_fmt \"\\n\",\n\t\t\t     timestamp, decoder->timestamp);\n\telse\n\t\tdecoder->timestamp = timestamp;\n\n\tintel_pt_mtc_cyc_cnt_upd(decoder);\n\n\tdecoder->timestamp_insn_cnt = 0;\n\tdecoder->last_mtc = mtc;\n\n\tif (decoder->last_packet_type == INTEL_PT_CYC) {\n\t\tdecoder->cyc_ref_timestamp = decoder->timestamp;\n\t\tdecoder->cycle_cnt = 0;\n\t\tdecoder->have_calc_cyc_to_tsc = false;\n\t\tintel_pt_calc_cyc_to_tsc(decoder, true);\n\t}\n\n\tintel_pt_log_to(\"Setting timestamp\", decoder->timestamp);\n}\n\nstatic void intel_pt_calc_cbr(struct intel_pt_decoder *decoder)\n{\n\tunsigned int cbr = decoder->packet.payload & 0xff;\n\n\tdecoder->cbr_payload = decoder->packet.payload;\n\n\tif (decoder->cbr == cbr)\n\t\treturn;\n\n\tdecoder->cbr = cbr;\n\tdecoder->cbr_cyc_to_tsc = decoder->max_non_turbo_ratio_fp / cbr;\n\tdecoder->cyc_ref_timestamp = decoder->timestamp;\n\tdecoder->cycle_cnt = 0;\n\n\tintel_pt_mtc_cyc_cnt_cbr(decoder);\n}\n\nstatic void intel_pt_calc_cyc_timestamp(struct intel_pt_decoder *decoder)\n{\n\tuint64_t timestamp = decoder->cyc_ref_timestamp;\n\n\tdecoder->have_cyc = true;\n\n\tdecoder->cycle_cnt += decoder->packet.payload;\n\tif (decoder->pge)\n\t\tdecoder->tot_cyc_cnt += decoder->packet.payload;\n\tdecoder->sample_cyc = true;\n\n\tif (!decoder->cyc_ref_timestamp)\n\t\treturn;\n\n\tif (decoder->have_calc_cyc_to_tsc)\n\t\ttimestamp += decoder->cycle_cnt * decoder->calc_cyc_to_tsc;\n\telse if (decoder->cbr)\n\t\ttimestamp += decoder->cycle_cnt * decoder->cbr_cyc_to_tsc;\n\telse\n\t\treturn;\n\n\tif (timestamp < decoder->timestamp)\n\t\tintel_pt_log(\"Suppressing CYC timestamp \" x64_fmt \" less than current timestamp \" x64_fmt \"\\n\",\n\t\t\t     timestamp, decoder->timestamp);\n\telse\n\t\tdecoder->timestamp = timestamp;\n\n\tdecoder->timestamp_insn_cnt = 0;\n\n\tintel_pt_log_to(\"Setting timestamp\", decoder->timestamp);\n}\n\nstatic void intel_pt_bbp(struct intel_pt_decoder *decoder)\n{\n\tif (decoder->prev_pkt_ctx == INTEL_PT_NO_CTX) {\n\t\tmemset(decoder->state.items.mask, 0, sizeof(decoder->state.items.mask));\n\t\tdecoder->state.items.is_32_bit = false;\n\t}\n\tdecoder->blk_type = decoder->packet.payload;\n\tdecoder->blk_type_pos = intel_pt_blk_type_pos(decoder->blk_type);\n\tif (decoder->blk_type == INTEL_PT_GP_REGS)\n\t\tdecoder->state.items.is_32_bit = decoder->packet.count;\n\tif (decoder->blk_type_pos < 0) {\n\t\tintel_pt_log(\"WARNING: Unknown block type %u\\n\",\n\t\t\t     decoder->blk_type);\n\t} else if (decoder->state.items.mask[decoder->blk_type_pos]) {\n\t\tintel_pt_log(\"WARNING: Duplicate block type %u\\n\",\n\t\t\t     decoder->blk_type);\n\t}\n}\n\nstatic void intel_pt_bip(struct intel_pt_decoder *decoder)\n{\n\tuint32_t id = decoder->packet.count;\n\tuint32_t bit = 1 << id;\n\tint pos = decoder->blk_type_pos;\n\n\tif (pos < 0 || id >= INTEL_PT_BLK_ITEM_ID_CNT) {\n\t\tintel_pt_log(\"WARNING: Unknown block item %u type %d\\n\",\n\t\t\t     id, decoder->blk_type);\n\t\treturn;\n\t}\n\n\tif (decoder->state.items.mask[pos] & bit) {\n\t\tintel_pt_log(\"WARNING: Duplicate block item %u type %d\\n\",\n\t\t\t     id, decoder->blk_type);\n\t}\n\n\tdecoder->state.items.mask[pos] |= bit;\n\tdecoder->state.items.val[pos][id] = decoder->packet.payload;\n}\n\n \nstatic int intel_pt_walk_psbend(struct intel_pt_decoder *decoder)\n{\n\tint err;\n\n\tdecoder->in_psb = true;\n\n\twhile (1) {\n\t\terr = intel_pt_get_next_packet(decoder);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tswitch (decoder->packet.type) {\n\t\tcase INTEL_PT_PSBEND:\n\t\t\terr = 0;\n\t\t\tgoto out;\n\n\t\tcase INTEL_PT_TIP_PGD:\n\t\tcase INTEL_PT_TIP_PGE:\n\t\tcase INTEL_PT_TIP:\n\t\tcase INTEL_PT_TNT:\n\t\tcase INTEL_PT_TRACESTOP:\n\t\tcase INTEL_PT_BAD:\n\t\tcase INTEL_PT_PSB:\n\t\tcase INTEL_PT_PTWRITE:\n\t\tcase INTEL_PT_PTWRITE_IP:\n\t\tcase INTEL_PT_EXSTOP:\n\t\tcase INTEL_PT_EXSTOP_IP:\n\t\tcase INTEL_PT_MWAIT:\n\t\tcase INTEL_PT_PWRE:\n\t\tcase INTEL_PT_PWRX:\n\t\tcase INTEL_PT_BBP:\n\t\tcase INTEL_PT_BIP:\n\t\tcase INTEL_PT_BEP:\n\t\tcase INTEL_PT_BEP_IP:\n\t\tcase INTEL_PT_CFE:\n\t\tcase INTEL_PT_CFE_IP:\n\t\tcase INTEL_PT_EVD:\n\t\t\tdecoder->have_tma = false;\n\t\t\tintel_pt_log(\"ERROR: Unexpected packet\\n\");\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\n\t\tcase INTEL_PT_OVF:\n\t\t\terr = intel_pt_overflow(decoder);\n\t\t\tgoto out;\n\n\t\tcase INTEL_PT_TSC:\n\t\t\tintel_pt_calc_tsc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_TMA:\n\t\t\tintel_pt_calc_tma(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CBR:\n\t\t\tintel_pt_calc_cbr(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MODE_EXEC:\n\t\t\tintel_pt_mode_exec_status(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_PIP:\n\t\t\tintel_pt_set_pip(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_FUP:\n\t\t\tdecoder->pge = true;\n\t\t\tif (decoder->packet.count) {\n\t\t\t\tintel_pt_set_last_ip(decoder);\n\t\t\t\tdecoder->psb_ip = decoder->last_ip;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MODE_TSX:\n\t\t\tintel_pt_update_in_tx(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MTC:\n\t\t\tintel_pt_calc_mtc_timestamp(decoder);\n\t\t\tif (decoder->period_type == INTEL_PT_PERIOD_MTC)\n\t\t\t\tdecoder->state.type |= INTEL_PT_INSTRUCTION;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CYC:\n\t\t\tintel_pt_calc_cyc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_VMCS:\n\t\tcase INTEL_PT_MNT:\n\t\tcase INTEL_PT_PAD:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tdecoder->in_psb = false;\n\n\treturn err;\n}\n\nstatic int intel_pt_walk_fup_tip(struct intel_pt_decoder *decoder)\n{\n\tint err;\n\n\tif (decoder->tx_flags & INTEL_PT_ABORT_TX) {\n\t\tdecoder->tx_flags = 0;\n\t\tdecoder->state.flags &= ~INTEL_PT_IN_TX;\n\t\tdecoder->state.flags |= INTEL_PT_ABORT_TX;\n\t} else {\n\t\tdecoder->state.flags |= INTEL_PT_ASYNC;\n\t}\n\n\twhile (1) {\n\t\terr = intel_pt_get_next_packet(decoder);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tswitch (decoder->packet.type) {\n\t\tcase INTEL_PT_TNT:\n\t\tcase INTEL_PT_FUP:\n\t\tcase INTEL_PT_TRACESTOP:\n\t\tcase INTEL_PT_PSB:\n\t\tcase INTEL_PT_TSC:\n\t\tcase INTEL_PT_TMA:\n\t\tcase INTEL_PT_MODE_TSX:\n\t\tcase INTEL_PT_BAD:\n\t\tcase INTEL_PT_PSBEND:\n\t\tcase INTEL_PT_PTWRITE:\n\t\tcase INTEL_PT_PTWRITE_IP:\n\t\tcase INTEL_PT_EXSTOP:\n\t\tcase INTEL_PT_EXSTOP_IP:\n\t\tcase INTEL_PT_MWAIT:\n\t\tcase INTEL_PT_PWRE:\n\t\tcase INTEL_PT_PWRX:\n\t\tcase INTEL_PT_BBP:\n\t\tcase INTEL_PT_BIP:\n\t\tcase INTEL_PT_BEP:\n\t\tcase INTEL_PT_BEP_IP:\n\t\tcase INTEL_PT_CFE:\n\t\tcase INTEL_PT_CFE_IP:\n\t\tcase INTEL_PT_EVD:\n\t\t\tintel_pt_log(\"ERROR: Missing TIP after FUP\\n\");\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR3;\n\t\t\tdecoder->pkt_step = 0;\n\t\t\treturn -ENOENT;\n\n\t\tcase INTEL_PT_CBR:\n\t\t\tintel_pt_calc_cbr(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_OVF:\n\t\t\treturn intel_pt_overflow(decoder);\n\n\t\tcase INTEL_PT_TIP_PGD:\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tif (decoder->packet.count == 0) {\n\t\t\t\tdecoder->state.to_ip = 0;\n\t\t\t} else {\n\t\t\t\tintel_pt_set_ip(decoder);\n\t\t\t\tdecoder->state.to_ip = decoder->ip;\n\t\t\t}\n\t\t\tdecoder->pge = false;\n\t\t\tdecoder->continuous_period = false;\n\t\t\tdecoder->state.type |= INTEL_PT_TRACE_END;\n\t\t\tintel_pt_update_nr(decoder);\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_TIP_PGE:\n\t\t\tdecoder->pge = true;\n\t\t\tintel_pt_log(\"Omitting PGE ip \" x64_fmt \"\\n\",\n\t\t\t\t     decoder->ip);\n\t\t\tdecoder->state.from_ip = 0;\n\t\t\tif (decoder->packet.count == 0) {\n\t\t\t\tdecoder->state.to_ip = 0;\n\t\t\t} else {\n\t\t\t\tintel_pt_set_ip(decoder);\n\t\t\t\tdecoder->state.to_ip = decoder->ip;\n\t\t\t}\n\t\t\tdecoder->state.type |= INTEL_PT_TRACE_BEGIN;\n\t\t\tintel_pt_mtc_cyc_cnt_pge(decoder);\n\t\t\tintel_pt_set_nr(decoder);\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_TIP:\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tif (decoder->packet.count == 0) {\n\t\t\t\tdecoder->state.to_ip = 0;\n\t\t\t} else {\n\t\t\t\tintel_pt_set_ip(decoder);\n\t\t\t\tdecoder->state.to_ip = decoder->ip;\n\t\t\t}\n\t\t\tintel_pt_update_nr(decoder);\n\t\t\tintel_pt_sample_iflag_chg(decoder);\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_PIP:\n\t\t\tintel_pt_update_pip(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MTC:\n\t\t\tintel_pt_calc_mtc_timestamp(decoder);\n\t\t\tif (decoder->period_type == INTEL_PT_PERIOD_MTC)\n\t\t\t\tdecoder->state.type |= INTEL_PT_INSTRUCTION;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CYC:\n\t\t\tintel_pt_calc_cyc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MODE_EXEC:\n\t\t\tintel_pt_mode_exec(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_VMCS:\n\t\tcase INTEL_PT_MNT:\n\t\tcase INTEL_PT_PAD:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn intel_pt_bug(decoder);\n\t\t}\n\t}\n}\n\nstatic int intel_pt_resample(struct intel_pt_decoder *decoder)\n{\n\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\tdecoder->state.type = INTEL_PT_INSTRUCTION;\n\tdecoder->state.from_ip = decoder->ip;\n\tdecoder->state.to_ip = 0;\n\treturn 0;\n}\n\nstruct intel_pt_vm_tsc_info {\n\tstruct intel_pt_pkt pip_packet;\n\tstruct intel_pt_pkt vmcs_packet;\n\tstruct intel_pt_pkt tma_packet;\n\tbool tsc, pip, vmcs, tma, psbend;\n\tuint64_t ctc_delta;\n\tuint64_t last_ctc;\n\tint max_lookahead;\n};\n\n \nstatic int intel_pt_vm_psb_lookahead_cb(struct intel_pt_pkt_info *pkt_info)\n{\n\tstruct intel_pt_vm_tsc_info *data = pkt_info->data;\n\n\tswitch (pkt_info->packet.type) {\n\tcase INTEL_PT_PAD:\n\tcase INTEL_PT_MNT:\n\tcase INTEL_PT_MODE_EXEC:\n\tcase INTEL_PT_MODE_TSX:\n\tcase INTEL_PT_MTC:\n\tcase INTEL_PT_FUP:\n\tcase INTEL_PT_CYC:\n\tcase INTEL_PT_CBR:\n\t\tbreak;\n\n\tcase INTEL_PT_TSC:\n\t\tdata->tsc = true;\n\t\tbreak;\n\n\tcase INTEL_PT_TMA:\n\t\tdata->tma_packet = pkt_info->packet;\n\t\tdata->tma = true;\n\t\tbreak;\n\n\tcase INTEL_PT_PIP:\n\t\tdata->pip_packet = pkt_info->packet;\n\t\tdata->pip = true;\n\t\tbreak;\n\n\tcase INTEL_PT_VMCS:\n\t\tdata->vmcs_packet = pkt_info->packet;\n\t\tdata->vmcs = true;\n\t\tbreak;\n\n\tcase INTEL_PT_PSBEND:\n\t\tdata->psbend = true;\n\t\treturn 1;\n\n\tcase INTEL_PT_TIP_PGE:\n\tcase INTEL_PT_PTWRITE:\n\tcase INTEL_PT_PTWRITE_IP:\n\tcase INTEL_PT_EXSTOP:\n\tcase INTEL_PT_EXSTOP_IP:\n\tcase INTEL_PT_MWAIT:\n\tcase INTEL_PT_PWRE:\n\tcase INTEL_PT_PWRX:\n\tcase INTEL_PT_BBP:\n\tcase INTEL_PT_BIP:\n\tcase INTEL_PT_BEP:\n\tcase INTEL_PT_BEP_IP:\n\tcase INTEL_PT_OVF:\n\tcase INTEL_PT_BAD:\n\tcase INTEL_PT_TNT:\n\tcase INTEL_PT_TIP_PGD:\n\tcase INTEL_PT_TIP:\n\tcase INTEL_PT_PSB:\n\tcase INTEL_PT_TRACESTOP:\n\tcase INTEL_PT_CFE:\n\tcase INTEL_PT_CFE_IP:\n\tcase INTEL_PT_EVD:\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstruct intel_pt_ovf_fup_info {\n\tint max_lookahead;\n\tbool found;\n};\n\n \nstatic int intel_pt_ovf_fup_lookahead_cb(struct intel_pt_pkt_info *pkt_info)\n{\n\tstruct intel_pt_ovf_fup_info *data = pkt_info->data;\n\n\tif (pkt_info->packet.type == INTEL_PT_CYC ||\n\t    pkt_info->packet.type == INTEL_PT_MTC ||\n\t    pkt_info->packet.type == INTEL_PT_TSC)\n\t\treturn !--(data->max_lookahead);\n\tdata->found = pkt_info->packet.type == INTEL_PT_FUP;\n\treturn 1;\n}\n\nstatic bool intel_pt_ovf_fup_lookahead(struct intel_pt_decoder *decoder)\n{\n\tstruct intel_pt_ovf_fup_info data = {\n\t\t.max_lookahead = 16,\n\t\t.found = false,\n\t};\n\n\tintel_pt_pkt_lookahead(decoder, intel_pt_ovf_fup_lookahead_cb, &data);\n\treturn data.found;\n}\n\n \nstatic int intel_pt_tma_lookahead_cb(struct intel_pt_pkt_info *pkt_info)\n{\n\tstruct intel_pt_vm_tsc_info *data = pkt_info->data;\n\n\tif (pkt_info->packet.type == INTEL_PT_CYC ||\n\t    pkt_info->packet.type == INTEL_PT_MTC)\n\t\treturn !--(data->max_lookahead);\n\n\tif (pkt_info->packet.type == INTEL_PT_TMA) {\n\t\tdata->tma_packet = pkt_info->packet;\n\t\tdata->tma = true;\n\t}\n\treturn 1;\n}\n\nstatic uint64_t intel_pt_ctc_to_tsc(struct intel_pt_decoder *decoder, uint64_t ctc)\n{\n\tif (decoder->tsc_ctc_mult)\n\t\treturn ctc * decoder->tsc_ctc_mult;\n\telse\n\t\treturn multdiv(ctc, decoder->tsc_ctc_ratio_n, decoder->tsc_ctc_ratio_d);\n}\n\nstatic uint64_t intel_pt_calc_expected_tsc(struct intel_pt_decoder *decoder,\n\t\t\t\t\t   uint32_t ctc,\n\t\t\t\t\t   uint32_t fc,\n\t\t\t\t\t   uint64_t last_ctc_timestamp,\n\t\t\t\t\t   uint64_t ctc_delta,\n\t\t\t\t\t   uint32_t last_ctc)\n{\n\t \n\tuint64_t last_mtc_ctc = last_ctc + ctc_delta;\n\t \n\tuint64_t delta = (int16_t)((uint16_t)ctc - (uint16_t)last_mtc_ctc);\n\t \n\tuint64_t new_ctc_delta = ctc_delta + delta;\n\tuint64_t expected_tsc;\n\n\t \n\texpected_tsc = last_ctc_timestamp + intel_pt_ctc_to_tsc(decoder, new_ctc_delta) + fc;\n\n\tif (intel_pt_enable_logging) {\n\t\tintel_pt_log_x64(last_mtc_ctc);\n\t\tintel_pt_log_x32(last_ctc);\n\t\tintel_pt_log_x64(ctc_delta);\n\t\tintel_pt_log_x64(delta);\n\t\tintel_pt_log_x32(ctc);\n\t\tintel_pt_log_x64(new_ctc_delta);\n\t\tintel_pt_log_x64(last_ctc_timestamp);\n\t\tintel_pt_log_x32(fc);\n\t\tintel_pt_log_x64(intel_pt_ctc_to_tsc(decoder, new_ctc_delta));\n\t\tintel_pt_log_x64(expected_tsc);\n\t}\n\n\treturn expected_tsc;\n}\n\nstatic uint64_t intel_pt_expected_tsc(struct intel_pt_decoder *decoder,\n\t\t\t\t      struct intel_pt_vm_tsc_info *data)\n{\n\tuint32_t ctc = data->tma_packet.payload;\n\tuint32_t fc = data->tma_packet.count;\n\n\treturn intel_pt_calc_expected_tsc(decoder, ctc, fc,\n\t\t\t\t\t  decoder->ctc_timestamp,\n\t\t\t\t\t  data->ctc_delta, data->last_ctc);\n}\n\nstatic void intel_pt_translate_vm_tsc(struct intel_pt_decoder *decoder,\n\t\t\t\t      struct intel_pt_vmcs_info *vmcs_info)\n{\n\tuint64_t payload = decoder->packet.payload;\n\n\t \n\tdecoder->packet.payload -= vmcs_info->tsc_offset;\n\t \n\tdecoder->packet.payload &= SEVEN_BYTES;\n\n\t \n\tif (!decoder->vm_tm_corr_dry_run)\n\t\tmemcpy((void *)decoder->buf + 1, &decoder->packet.payload, 7);\n\n\tintel_pt_log(\"Translated VM TSC %#\" PRIx64 \" -> %#\" PRIx64\n\t\t     \"    VMCS %#\" PRIx64 \"    TSC Offset %#\" PRIx64 \"\\n\",\n\t\t     payload, decoder->packet.payload, vmcs_info->vmcs,\n\t\t     vmcs_info->tsc_offset);\n}\n\nstatic void intel_pt_translate_vm_tsc_offset(struct intel_pt_decoder *decoder,\n\t\t\t\t\t     uint64_t tsc_offset)\n{\n\tstruct intel_pt_vmcs_info vmcs_info = {\n\t\t.vmcs = NO_VMCS,\n\t\t.tsc_offset = tsc_offset\n\t};\n\n\tintel_pt_translate_vm_tsc(decoder, &vmcs_info);\n}\n\nstatic inline bool in_vm(uint64_t pip_payload)\n{\n\treturn pip_payload & 1;\n}\n\nstatic inline bool pip_in_vm(struct intel_pt_pkt *pip_packet)\n{\n\treturn pip_packet->payload & 1;\n}\n\nstatic void intel_pt_print_vmcs_info(struct intel_pt_vmcs_info *vmcs_info)\n{\n\tp_log(\"VMCS: %#\" PRIx64 \"  TSC Offset %#\" PRIx64,\n\t      vmcs_info->vmcs, vmcs_info->tsc_offset);\n}\n\nstatic void intel_pt_vm_tm_corr_psb(struct intel_pt_decoder *decoder,\n\t\t\t\t    struct intel_pt_vm_tsc_info *data)\n{\n\tmemset(data, 0, sizeof(*data));\n\tdata->ctc_delta = decoder->ctc_delta;\n\tdata->last_ctc = decoder->last_ctc;\n\tintel_pt_pkt_lookahead(decoder, intel_pt_vm_psb_lookahead_cb, data);\n\tif (data->tsc && !data->psbend)\n\t\tp_log(\"ERROR: PSB without PSBEND\");\n\tdecoder->in_psb = data->psbend;\n}\n\nstatic void intel_pt_vm_tm_corr_first_tsc(struct intel_pt_decoder *decoder,\n\t\t\t\t\t  struct intel_pt_vm_tsc_info *data,\n\t\t\t\t\t  struct intel_pt_vmcs_info *vmcs_info,\n\t\t\t\t\t  uint64_t host_tsc)\n{\n\tif (!decoder->in_psb) {\n\t\t \n\t\tp_log(\"ERROR: First TSC is not in PSB+\");\n\t}\n\n\tif (data->pip) {\n\t\tif (pip_in_vm(&data->pip_packet)) {  \n\t\t\tif (vmcs_info && vmcs_info->tsc_offset) {\n\t\t\t\tintel_pt_translate_vm_tsc(decoder, vmcs_info);\n\t\t\t\tdecoder->vm_tm_corr_reliable = true;\n\t\t\t} else {\n\t\t\t\tp_log(\"ERROR: First TSC, unknown TSC Offset\");\n\t\t\t}\n\t\t} else {  \n\t\t\tdecoder->vm_tm_corr_reliable = true;\n\t\t}\n\t} else {  \n\t\tdecoder->vm_tm_corr_reliable = false;\n\t\tif (intel_pt_time_in_range(decoder, host_tsc)) {\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tif (vmcs_info && vmcs_info->tsc_offset)\n\t\t\t\tintel_pt_translate_vm_tsc(decoder, vmcs_info);\n\t\t\telse\n\t\t\t\tp_log(\"ERROR: First TSC, no PIP, unknown TSC Offset\");\n\t\t}\n\t}\n}\n\nstatic void intel_pt_vm_tm_corr_tsc(struct intel_pt_decoder *decoder,\n\t\t\t\t    struct intel_pt_vm_tsc_info *data)\n{\n\tstruct intel_pt_vmcs_info *vmcs_info;\n\tuint64_t tsc_offset = 0;\n\tuint64_t vmcs;\n\tbool reliable = true;\n\tuint64_t expected_tsc;\n\tuint64_t host_tsc;\n\tuint64_t ref_timestamp;\n\n\tbool assign = false;\n\tbool assign_reliable = false;\n\n\t \n\tif (!decoder->in_psb) {\n\t\tmemset(data, 0, sizeof(*data));\n\t\tdata->ctc_delta = decoder->ctc_delta;\n\t\tdata->last_ctc = decoder->last_ctc;\n\t\tdata->max_lookahead = 16;\n\t\tintel_pt_pkt_lookahead(decoder, intel_pt_tma_lookahead_cb, data);\n\t\tif (decoder->pge) {\n\t\t\tdata->pip = true;\n\t\t\tdata->pip_packet.payload = decoder->pip_payload;\n\t\t}\n\t}\n\n\t \n\tif (!data->tma) {\n\t\tp_log(\"ERROR: TSC without TMA\");\n\t\treturn;\n\t}\n\n\tvmcs = data->vmcs ? data->vmcs_packet.payload : decoder->vmcs;\n\tif (vmcs == NO_VMCS)\n\t\tvmcs = 0;\n\n\tvmcs_info = decoder->findnew_vmcs_info(decoder->data, vmcs);\n\n\tref_timestamp = decoder->timestamp ? decoder->timestamp : decoder->buf_timestamp;\n\thost_tsc = intel_pt_8b_tsc(decoder->packet.payload, ref_timestamp);\n\n\tif (!decoder->ctc_timestamp) {\n\t\tintel_pt_vm_tm_corr_first_tsc(decoder, data, vmcs_info, host_tsc);\n\t\treturn;\n\t}\n\n\texpected_tsc = intel_pt_expected_tsc(decoder, data);\n\n\ttsc_offset = host_tsc - expected_tsc;\n\n\t \n\tif (data->pip) {\n\t\tif (pip_in_vm(&data->pip_packet)) {  \n\t\t\tif (!vmcs_info) {\n\t\t\t\t \n\t\t\t\tp_log(\"ERROR: Missing VMCS\");\n\t\t\t\tintel_pt_translate_vm_tsc_offset(decoder, tsc_offset);\n\t\t\t\tdecoder->vm_tm_corr_reliable = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {  \n\t\t\tdecoder->last_reliable_timestamp = host_tsc;\n\t\t\tdecoder->vm_tm_corr_reliable = true;\n\t\t\treturn;\n\t\t}\n\t} else {  \n\t\treliable = false;  \n\t\tif (decoder->in_psb) {\n\t\t\tif (!tsc_offset)\n\t\t\t\treturn;  \n\t\t\t \n\t\t\tif (vmcs_info &&\n\t\t\t    (tsc_offset & SEVEN_BYTES) ==\n\t\t\t    (vmcs_info->tsc_offset & SEVEN_BYTES)) {\n\t\t\t\t \n\t\t\t\tgoto guest;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (host_tsc >= expected_tsc && intel_pt_time_in_range(decoder, host_tsc)) {\n\t\t\t \n\t\t\tdecoder->vm_tm_corr_reliable = false;\n\t\t\treturn;\n\t\t}\n\t}\n\nguest:  \n\n\t \n\tif (vmcs_info && vmcs_info->vmcs) {\n\t\tif (vmcs_info->tsc_offset && vmcs_info->reliable) {\n\t\t\tassign = false;\n\t\t} else if (decoder->in_psb && data->pip && decoder->vm_tm_corr_reliable &&\n\t\t\t   decoder->vm_tm_corr_continuous && decoder->vm_tm_corr_same_buf) {\n\t\t\t \n\t\t\tassign = true;\n\t\t\tassign_reliable = true;\n\t\t} else if (decoder->in_psb && data->pip && decoder->vm_tm_corr_same_buf) {\n\t\t\t \n\t\t\tassign = true;\n\t\t\tassign_reliable = false;\n\t\t}\n\t}\n\n\t \n\tif (assign && (vmcs_info->tsc_offset != tsc_offset ||\n\t\t       vmcs_info->reliable != assign_reliable)) {\n\t\tbool print = vmcs_info->tsc_offset != tsc_offset;\n\n\t\tvmcs_info->tsc_offset = tsc_offset;\n\t\tvmcs_info->reliable = assign_reliable;\n\t\tif (print)\n\t\t\tintel_pt_print_vmcs_info(vmcs_info);\n\t}\n\n\t \n\tif (vmcs_info && vmcs_info->tsc_offset) {\n\t\tif (!vmcs_info->reliable)\n\t\t\treliable = false;\n\t\tintel_pt_translate_vm_tsc(decoder, vmcs_info);\n\t} else {\n\t\treliable = false;\n\t\tif (vmcs_info) {\n\t\t\tif (!vmcs_info->error_printed) {\n\t\t\t\tp_log(\"ERROR: Unknown TSC Offset for VMCS %#\" PRIx64,\n\t\t\t\t      vmcs_info->vmcs);\n\t\t\t\tvmcs_info->error_printed = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (intel_pt_print_once(decoder, INTEL_PT_PRT_ONCE_UNK_VMCS))\n\t\t\t\tp_log(\"ERROR: Unknown VMCS\");\n\t\t}\n\t\tintel_pt_translate_vm_tsc_offset(decoder, tsc_offset);\n\t}\n\n\tdecoder->vm_tm_corr_reliable = reliable;\n}\n\nstatic void intel_pt_vm_tm_corr_pebs_tsc(struct intel_pt_decoder *decoder)\n{\n\tuint64_t host_tsc = decoder->packet.payload;\n\tuint64_t guest_tsc = decoder->packet.payload;\n\tstruct intel_pt_vmcs_info *vmcs_info;\n\tuint64_t vmcs;\n\n\tvmcs = decoder->vmcs;\n\tif (vmcs == NO_VMCS)\n\t\tvmcs = 0;\n\n\tvmcs_info = decoder->findnew_vmcs_info(decoder->data, vmcs);\n\n\tif (decoder->pge) {\n\t\tif (in_vm(decoder->pip_payload)) {  \n\t\t\tif (!vmcs_info) {\n\t\t\t\t \n\t\t\t\tp_log(\"ERROR: Missing VMCS\");\n\t\t\t}\n\t\t} else {  \n\t\t\treturn;\n\t\t}\n\t} else {  \n\t\tif (intel_pt_time_in_range(decoder, host_tsc)) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (vmcs_info) {\n\t\t \n\t\thost_tsc = ((guest_tsc & SEVEN_BYTES) - vmcs_info->tsc_offset) & SEVEN_BYTES;\n\t\thost_tsc = intel_pt_8b_tsc(host_tsc, decoder->timestamp);\n\t\tintel_pt_log(\"Translated VM TSC %#\" PRIx64 \" -> %#\" PRIx64\n\t\t\t     \"    VMCS %#\" PRIx64 \"    TSC Offset %#\" PRIx64 \"\\n\",\n\t\t\t     guest_tsc, host_tsc, vmcs_info->vmcs,\n\t\t\t     vmcs_info->tsc_offset);\n\t\tif (!intel_pt_time_in_range(decoder, host_tsc) &&\n\t\t    intel_pt_print_once(decoder, INTEL_PT_PRT_ONCE_ERANGE))\n\t\t\tp_log(\"Timestamp out of range\");\n\t} else {\n\t\tif (intel_pt_print_once(decoder, INTEL_PT_PRT_ONCE_UNK_VMCS))\n\t\t\tp_log(\"ERROR: Unknown VMCS\");\n\t\thost_tsc = decoder->timestamp;\n\t}\n\n\tdecoder->packet.payload = host_tsc;\n\n\tif (!decoder->vm_tm_corr_dry_run)\n\t\tmemcpy((void *)decoder->buf + 1, &host_tsc, 8);\n}\n\nstatic int intel_pt_vm_time_correlation(struct intel_pt_decoder *decoder)\n{\n\tstruct intel_pt_vm_tsc_info data = { .psbend = false };\n\tbool pge;\n\tint err;\n\n\tif (decoder->in_psb)\n\t\tintel_pt_vm_tm_corr_psb(decoder, &data);\n\n\twhile (1) {\n\t\terr = intel_pt_get_next_packet(decoder);\n\t\tif (err == -ENOLINK)\n\t\t\tcontinue;\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tswitch (decoder->packet.type) {\n\t\tcase INTEL_PT_TIP_PGD:\n\t\t\tdecoder->pge = false;\n\t\t\tdecoder->vm_tm_corr_continuous = false;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_TNT:\n\t\tcase INTEL_PT_TIP:\n\t\tcase INTEL_PT_TIP_PGE:\n\t\t\tdecoder->pge = true;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_OVF:\n\t\t\tdecoder->in_psb = false;\n\t\t\tpge = decoder->pge;\n\t\t\tdecoder->pge = intel_pt_ovf_fup_lookahead(decoder);\n\t\t\tif (pge != decoder->pge)\n\t\t\t\tintel_pt_log(\"Surprising PGE change in OVF!\");\n\t\t\tif (!decoder->pge)\n\t\t\t\tdecoder->vm_tm_corr_continuous = false;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_FUP:\n\t\t\tif (decoder->in_psb)\n\t\t\t\tdecoder->pge = true;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_TRACESTOP:\n\t\t\tdecoder->pge = false;\n\t\t\tdecoder->vm_tm_corr_continuous = false;\n\t\t\tdecoder->have_tma = false;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_PSB:\n\t\t\tintel_pt_vm_tm_corr_psb(decoder, &data);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_PIP:\n\t\t\tdecoder->pip_payload = decoder->packet.payload;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MTC:\n\t\t\tintel_pt_calc_mtc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_TSC:\n\t\t\tintel_pt_vm_tm_corr_tsc(decoder, &data);\n\t\t\tintel_pt_calc_tsc_timestamp(decoder);\n\t\t\tdecoder->vm_tm_corr_same_buf = true;\n\t\t\tdecoder->vm_tm_corr_continuous = decoder->pge;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_TMA:\n\t\t\tintel_pt_calc_tma(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CYC:\n\t\t\tintel_pt_calc_cyc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CBR:\n\t\t\tintel_pt_calc_cbr(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_PSBEND:\n\t\t\tdecoder->in_psb = false;\n\t\t\tdata.psbend = false;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_VMCS:\n\t\t\tif (decoder->packet.payload != NO_VMCS)\n\t\t\t\tdecoder->vmcs = decoder->packet.payload;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_BBP:\n\t\t\tdecoder->blk_type = decoder->packet.payload;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_BIP:\n\t\t\tif (decoder->blk_type == INTEL_PT_PEBS_BASIC &&\n\t\t\t    decoder->packet.count == 2)\n\t\t\t\tintel_pt_vm_tm_corr_pebs_tsc(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_BEP:\n\t\tcase INTEL_PT_BEP_IP:\n\t\t\tdecoder->blk_type = 0;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CFE:\n\t\tcase INTEL_PT_CFE_IP:\n\t\tcase INTEL_PT_EVD:\n\t\tcase INTEL_PT_MODE_EXEC:\n\t\tcase INTEL_PT_MODE_TSX:\n\t\tcase INTEL_PT_MNT:\n\t\tcase INTEL_PT_PAD:\n\t\tcase INTEL_PT_PTWRITE_IP:\n\t\tcase INTEL_PT_PTWRITE:\n\t\tcase INTEL_PT_MWAIT:\n\t\tcase INTEL_PT_PWRE:\n\t\tcase INTEL_PT_EXSTOP_IP:\n\t\tcase INTEL_PT_EXSTOP:\n\t\tcase INTEL_PT_PWRX:\n\t\tcase INTEL_PT_BAD:  \n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n#define HOP_PROCESS\t0\n#define HOP_IGNORE\t1\n#define HOP_RETURN\t2\n#define HOP_AGAIN\t3\n\nstatic int intel_pt_scan_for_psb(struct intel_pt_decoder *decoder);\n\n \nstatic int intel_pt_hop_trace(struct intel_pt_decoder *decoder, bool *no_tip, int *err)\n{\n\t*err = 0;\n\n\t \n\tif (decoder->leap && !decoder->in_psb && decoder->packet.type != INTEL_PT_PSB) {\n\t\t*err = intel_pt_scan_for_psb(decoder);\n\t\tif (*err)\n\t\t\treturn HOP_RETURN;\n\t}\n\n\tswitch (decoder->packet.type) {\n\tcase INTEL_PT_TNT:\n\t\treturn HOP_IGNORE;\n\n\tcase INTEL_PT_TIP_PGD:\n\t\tdecoder->pge = false;\n\t\tif (!decoder->packet.count) {\n\t\t\tintel_pt_set_nr(decoder);\n\t\t\treturn HOP_IGNORE;\n\t\t}\n\t\tintel_pt_set_ip(decoder);\n\t\tdecoder->state.type |= INTEL_PT_TRACE_END;\n\t\tdecoder->state.from_ip = 0;\n\t\tdecoder->state.to_ip = decoder->ip;\n\t\tintel_pt_update_nr(decoder);\n\t\treturn HOP_RETURN;\n\n\tcase INTEL_PT_TIP:\n\t\tif (!decoder->packet.count) {\n\t\t\tintel_pt_set_nr(decoder);\n\t\t\treturn HOP_IGNORE;\n\t\t}\n\t\tintel_pt_set_ip(decoder);\n\t\tdecoder->state.type = INTEL_PT_INSTRUCTION;\n\t\tdecoder->state.from_ip = decoder->ip;\n\t\tdecoder->state.to_ip = 0;\n\t\tintel_pt_update_nr(decoder);\n\t\tintel_pt_sample_iflag_chg(decoder);\n\t\treturn HOP_RETURN;\n\n\tcase INTEL_PT_FUP:\n\t\tif (!decoder->packet.count)\n\t\t\treturn HOP_IGNORE;\n\t\tintel_pt_set_ip(decoder);\n\t\tif (decoder->set_fup_mwait || decoder->set_fup_pwre)\n\t\t\t*no_tip = true;\n\t\tif (!decoder->branch_enable || !decoder->pge)\n\t\t\t*no_tip = true;\n\t\tif (*no_tip) {\n\t\t\tdecoder->state.type = INTEL_PT_INSTRUCTION;\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tdecoder->state.to_ip = 0;\n\t\t\tintel_pt_fup_event(decoder, *no_tip);\n\t\t\treturn HOP_RETURN;\n\t\t}\n\t\tintel_pt_fup_event(decoder, *no_tip);\n\t\tdecoder->state.type |= INTEL_PT_INSTRUCTION | INTEL_PT_BRANCH;\n\t\t*err = intel_pt_walk_fup_tip(decoder);\n\t\tif (!*err && decoder->state.to_ip)\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_RESAMPLE;\n\t\treturn HOP_RETURN;\n\n\tcase INTEL_PT_PSB:\n\t\tdecoder->state.psb_offset = decoder->pos;\n\t\tdecoder->psb_ip = 0;\n\t\tdecoder->last_ip = 0;\n\t\tdecoder->have_last_ip = true;\n\t\t*err = intel_pt_walk_psbend(decoder);\n\t\tif (*err == -EAGAIN)\n\t\t\treturn HOP_AGAIN;\n\t\tif (*err)\n\t\t\treturn HOP_RETURN;\n\t\tdecoder->state.type = INTEL_PT_PSB_EVT;\n\t\tif (decoder->psb_ip) {\n\t\t\tdecoder->state.type |= INTEL_PT_INSTRUCTION;\n\t\t\tdecoder->ip = decoder->psb_ip;\n\t\t}\n\t\tdecoder->state.from_ip = decoder->psb_ip;\n\t\tdecoder->state.to_ip = 0;\n\t\treturn HOP_RETURN;\n\n\tcase INTEL_PT_BAD:\n\tcase INTEL_PT_PAD:\n\tcase INTEL_PT_TIP_PGE:\n\tcase INTEL_PT_TSC:\n\tcase INTEL_PT_TMA:\n\tcase INTEL_PT_MODE_EXEC:\n\tcase INTEL_PT_MODE_TSX:\n\tcase INTEL_PT_MTC:\n\tcase INTEL_PT_CYC:\n\tcase INTEL_PT_VMCS:\n\tcase INTEL_PT_PSBEND:\n\tcase INTEL_PT_CBR:\n\tcase INTEL_PT_TRACESTOP:\n\tcase INTEL_PT_PIP:\n\tcase INTEL_PT_OVF:\n\tcase INTEL_PT_MNT:\n\tcase INTEL_PT_PTWRITE:\n\tcase INTEL_PT_PTWRITE_IP:\n\tcase INTEL_PT_EXSTOP:\n\tcase INTEL_PT_EXSTOP_IP:\n\tcase INTEL_PT_MWAIT:\n\tcase INTEL_PT_PWRE:\n\tcase INTEL_PT_PWRX:\n\tcase INTEL_PT_BBP:\n\tcase INTEL_PT_BIP:\n\tcase INTEL_PT_BEP:\n\tcase INTEL_PT_BEP_IP:\n\tcase INTEL_PT_CFE:\n\tcase INTEL_PT_CFE_IP:\n\tcase INTEL_PT_EVD:\n\tdefault:\n\t\treturn HOP_PROCESS;\n\t}\n}\n\nstruct intel_pt_psb_info {\n\tstruct intel_pt_pkt fup_packet;\n\tbool fup;\n\tint after_psbend;\n};\n\n \nstatic int intel_pt_psb_lookahead_cb(struct intel_pt_pkt_info *pkt_info)\n{\n\tstruct intel_pt_psb_info *data = pkt_info->data;\n\n\tswitch (pkt_info->packet.type) {\n\tcase INTEL_PT_PAD:\n\tcase INTEL_PT_MNT:\n\tcase INTEL_PT_TSC:\n\tcase INTEL_PT_TMA:\n\tcase INTEL_PT_MODE_EXEC:\n\tcase INTEL_PT_MODE_TSX:\n\tcase INTEL_PT_MTC:\n\tcase INTEL_PT_CYC:\n\tcase INTEL_PT_VMCS:\n\tcase INTEL_PT_CBR:\n\tcase INTEL_PT_PIP:\n\t\tif (data->after_psbend) {\n\t\t\tdata->after_psbend -= 1;\n\t\t\tif (!data->after_psbend)\n\t\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tcase INTEL_PT_FUP:\n\t\tif (data->after_psbend)\n\t\t\treturn 1;\n\t\tif (data->fup || pkt_info->packet.count == 0)\n\t\t\treturn 1;\n\t\tdata->fup_packet = pkt_info->packet;\n\t\tdata->fup = true;\n\t\tbreak;\n\n\tcase INTEL_PT_PSBEND:\n\t\tif (!data->fup)\n\t\t\treturn 1;\n\t\t \n\t\tdata->after_psbend = 6;\n\t\tbreak;\n\n\tcase INTEL_PT_TIP_PGE:\n\t\t \n\t\tif (data->after_psbend)\n\t\t\tdata->fup = false;\n\t\treturn 1;\n\n\tcase INTEL_PT_PTWRITE:\n\tcase INTEL_PT_PTWRITE_IP:\n\tcase INTEL_PT_EXSTOP:\n\tcase INTEL_PT_EXSTOP_IP:\n\tcase INTEL_PT_MWAIT:\n\tcase INTEL_PT_PWRE:\n\tcase INTEL_PT_PWRX:\n\tcase INTEL_PT_BBP:\n\tcase INTEL_PT_BIP:\n\tcase INTEL_PT_BEP:\n\tcase INTEL_PT_BEP_IP:\n\tcase INTEL_PT_CFE:\n\tcase INTEL_PT_CFE_IP:\n\tcase INTEL_PT_EVD:\n\t\tif (data->after_psbend) {\n\t\t\tdata->after_psbend -= 1;\n\t\t\tif (!data->after_psbend)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\n\tcase INTEL_PT_OVF:\n\tcase INTEL_PT_BAD:\n\tcase INTEL_PT_TNT:\n\tcase INTEL_PT_TIP_PGD:\n\tcase INTEL_PT_TIP:\n\tcase INTEL_PT_PSB:\n\tcase INTEL_PT_TRACESTOP:\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_pt_psb(struct intel_pt_decoder *decoder)\n{\n\tint err;\n\n\tdecoder->last_ip = 0;\n\tdecoder->psb_ip = 0;\n\tdecoder->have_last_ip = true;\n\tintel_pt_clear_stack(&decoder->stack);\n\terr = intel_pt_walk_psbend(decoder);\n\tif (err)\n\t\treturn err;\n\tdecoder->state.type = INTEL_PT_PSB_EVT;\n\tdecoder->state.from_ip = decoder->psb_ip;\n\tdecoder->state.to_ip = 0;\n\treturn 0;\n}\n\nstatic int intel_pt_fup_in_psb(struct intel_pt_decoder *decoder)\n{\n\tint err;\n\n\tif (decoder->ip != decoder->last_ip) {\n\t\terr = intel_pt_walk_fup(decoder);\n\t\tif (!err || err != -EAGAIN)\n\t\t\treturn err;\n\t}\n\n\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\terr = intel_pt_psb(decoder);\n\tif (err) {\n\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR3;\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nstatic bool intel_pt_psb_with_fup(struct intel_pt_decoder *decoder, int *err)\n{\n\tstruct intel_pt_psb_info data = { .fup = false };\n\n\tif (!decoder->branch_enable)\n\t\treturn false;\n\n\tintel_pt_pkt_lookahead(decoder, intel_pt_psb_lookahead_cb, &data);\n\tif (!data.fup)\n\t\treturn false;\n\n\tdecoder->packet = data.fup_packet;\n\tintel_pt_set_last_ip(decoder);\n\tdecoder->pkt_state = INTEL_PT_STATE_FUP_IN_PSB;\n\n\t*err = intel_pt_fup_in_psb(decoder);\n\n\treturn true;\n}\n\nstatic int intel_pt_walk_trace(struct intel_pt_decoder *decoder)\n{\n\tint last_packet_type = INTEL_PT_PAD;\n\tbool no_tip = false;\n\tint err;\n\n\twhile (1) {\n\t\terr = intel_pt_get_next_packet(decoder);\n\t\tif (err)\n\t\t\treturn err;\nnext:\n\t\terr = 0;\n\t\tif (decoder->cyc_threshold) {\n\t\t\tif (decoder->sample_cyc && last_packet_type != INTEL_PT_CYC)\n\t\t\t\tdecoder->sample_cyc = false;\n\t\t\tlast_packet_type = decoder->packet.type;\n\t\t}\n\n\t\tif (decoder->hop) {\n\t\t\tswitch (intel_pt_hop_trace(decoder, &no_tip, &err)) {\n\t\t\tcase HOP_IGNORE:\n\t\t\t\tcontinue;\n\t\t\tcase HOP_RETURN:\n\t\t\t\treturn err;\n\t\t\tcase HOP_AGAIN:\n\t\t\t\tgoto next;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tswitch (decoder->packet.type) {\n\t\tcase INTEL_PT_TNT:\n\t\t\tif (!decoder->packet.count)\n\t\t\t\tbreak;\n\t\t\tdecoder->tnt = decoder->packet;\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_TNT;\n\t\t\terr = intel_pt_walk_tnt(decoder);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tbreak;\n\t\t\treturn err;\n\n\t\tcase INTEL_PT_TIP_PGD:\n\t\t\tif (decoder->packet.count != 0)\n\t\t\t\tintel_pt_set_last_ip(decoder);\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_TIP_PGD;\n\t\t\treturn intel_pt_walk_tip(decoder);\n\n\t\tcase INTEL_PT_TIP_PGE: {\n\t\t\tdecoder->pge = true;\n\t\t\tdecoder->overflow = false;\n\t\t\tintel_pt_mtc_cyc_cnt_pge(decoder);\n\t\t\tintel_pt_set_nr(decoder);\n\t\t\tif (decoder->packet.count == 0) {\n\t\t\t\tintel_pt_log_at(\"Skipping zero TIP.PGE\",\n\t\t\t\t\t\tdecoder->pos);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintel_pt_sample_iflag_chg(decoder);\n\t\t\tintel_pt_set_ip(decoder);\n\t\t\tdecoder->state.from_ip = 0;\n\t\t\tdecoder->state.to_ip = decoder->ip;\n\t\t\tdecoder->state.type |= INTEL_PT_TRACE_BEGIN;\n\t\t\t \n\t\t\tif (decoder->hop)\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_RESAMPLE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcase INTEL_PT_OVF:\n\t\t\treturn intel_pt_overflow(decoder);\n\n\t\tcase INTEL_PT_TIP:\n\t\t\tif (decoder->packet.count != 0)\n\t\t\t\tintel_pt_set_last_ip(decoder);\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_TIP;\n\t\t\treturn intel_pt_walk_tip(decoder);\n\n\t\tcase INTEL_PT_FUP:\n\t\t\tif (decoder->packet.count == 0) {\n\t\t\t\tintel_pt_log_at(\"Skipping zero FUP\",\n\t\t\t\t\t\tdecoder->pos);\n\t\t\t\tno_tip = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintel_pt_set_last_ip(decoder);\n\t\t\tif (!decoder->branch_enable || !decoder->pge) {\n\t\t\t\tdecoder->ip = decoder->last_ip;\n\t\t\t\tif (intel_pt_fup_event(decoder, no_tip))\n\t\t\t\t\treturn 0;\n\t\t\t\tno_tip = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (decoder->set_fup_mwait)\n\t\t\t\tno_tip = true;\n\t\t\tif (no_tip)\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_FUP_NO_TIP;\n\t\t\telse\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_FUP;\n\t\t\terr = intel_pt_walk_fup(decoder);\n\t\t\tif (err != -EAGAIN)\n\t\t\t\treturn err;\n\t\t\tif (no_tip) {\n\t\t\t\tno_tip = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn intel_pt_walk_fup_tip(decoder);\n\n\t\tcase INTEL_PT_TRACESTOP:\n\t\t\tdecoder->pge = false;\n\t\t\tdecoder->continuous_period = false;\n\t\t\tintel_pt_clear_tx_flags(decoder);\n\t\t\tdecoder->have_tma = false;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_PSB:\n\t\t\tdecoder->state.psb_offset = decoder->pos;\n\t\t\tdecoder->psb_ip = 0;\n\t\t\tif (intel_pt_psb_with_fup(decoder, &err))\n\t\t\t\treturn err;\n\t\t\terr = intel_pt_psb(decoder);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto next;\n\t\t\treturn err;\n\n\t\tcase INTEL_PT_PIP:\n\t\t\tintel_pt_update_pip(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MTC:\n\t\t\tintel_pt_calc_mtc_timestamp(decoder);\n\t\t\tif (decoder->period_type != INTEL_PT_PERIOD_MTC)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (!decoder->mtc_insn)\n\t\t\t\tbreak;\n\t\t\tdecoder->mtc_insn = false;\n\t\t\t \n\t\t\tif (!decoder->timestamp)\n\t\t\t\tbreak;\n\t\t\tdecoder->state.type = INTEL_PT_INSTRUCTION;\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tdecoder->state.to_ip = 0;\n\t\t\tdecoder->mtc_insn = false;\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_TSC:\n\t\t\tintel_pt_calc_tsc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_TMA:\n\t\t\tintel_pt_calc_tma(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CYC:\n\t\t\tintel_pt_calc_cyc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CBR:\n\t\t\tintel_pt_calc_cbr(decoder);\n\t\t\tif (decoder->cbr != decoder->cbr_seen) {\n\t\t\t\tdecoder->state.type = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MODE_EXEC:\n\t\t\tintel_pt_mode_exec(decoder);\n\t\t\terr = intel_pt_get_next_packet(decoder);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (decoder->packet.type == INTEL_PT_FUP) {\n\t\t\t\tdecoder->set_fup_mode_exec = true;\n\t\t\t\tno_tip = true;\n\t\t\t}\n\t\t\tgoto next;\n\n\t\tcase INTEL_PT_MODE_TSX:\n\t\t\t \n\t\t\tif (!decoder->pge || decoder->in_psb) {\n\t\t\t\tintel_pt_update_in_tx(decoder);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = intel_pt_mode_tsx(decoder, &no_tip);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tgoto next;\n\n\t\tcase INTEL_PT_BAD:  \n\t\t\treturn intel_pt_bug(decoder);\n\n\t\tcase INTEL_PT_PSBEND:\n\t\tcase INTEL_PT_VMCS:\n\t\tcase INTEL_PT_MNT:\n\t\tcase INTEL_PT_PAD:\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_PTWRITE_IP:\n\t\t\tdecoder->fup_ptw_payload = decoder->packet.payload;\n\t\t\terr = intel_pt_get_next_packet(decoder);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (decoder->packet.type == INTEL_PT_FUP) {\n\t\t\t\tdecoder->set_fup_ptw = true;\n\t\t\t\tno_tip = true;\n\t\t\t} else {\n\t\t\t\tintel_pt_log_at(\"ERROR: Missing FUP after PTWRITE\",\n\t\t\t\t\t\tdecoder->pos);\n\t\t\t}\n\t\t\tgoto next;\n\n\t\tcase INTEL_PT_PTWRITE:\n\t\t\tdecoder->state.type = INTEL_PT_PTW;\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tdecoder->state.to_ip = 0;\n\t\t\tdecoder->state.ptw_payload = decoder->packet.payload;\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_MWAIT:\n\t\t\tdecoder->fup_mwait_payload = decoder->packet.payload;\n\t\t\tdecoder->set_fup_mwait = true;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_PWRE:\n\t\t\tif (decoder->set_fup_mwait) {\n\t\t\t\tdecoder->fup_pwre_payload =\n\t\t\t\t\t\t\tdecoder->packet.payload;\n\t\t\t\tdecoder->set_fup_pwre = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdecoder->state.type = INTEL_PT_PWR_ENTRY;\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tdecoder->state.to_ip = 0;\n\t\t\tdecoder->state.pwrx_payload = decoder->packet.payload;\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_EXSTOP_IP:\n\t\t\terr = intel_pt_get_next_packet(decoder);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (decoder->packet.type == INTEL_PT_FUP) {\n\t\t\t\tdecoder->set_fup_exstop = true;\n\t\t\t\tno_tip = true;\n\t\t\t} else {\n\t\t\t\tintel_pt_log_at(\"ERROR: Missing FUP after EXSTOP\",\n\t\t\t\t\t\tdecoder->pos);\n\t\t\t}\n\t\t\tgoto next;\n\n\t\tcase INTEL_PT_EXSTOP:\n\t\t\tdecoder->state.type = INTEL_PT_EX_STOP;\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tdecoder->state.to_ip = 0;\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_PWRX:\n\t\t\tdecoder->state.type = INTEL_PT_PWR_EXIT;\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tdecoder->state.to_ip = 0;\n\t\t\tdecoder->state.pwrx_payload = decoder->packet.payload;\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_BBP:\n\t\t\tintel_pt_bbp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_BIP:\n\t\t\tintel_pt_bip(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_BEP:\n\t\t\tdecoder->state.type = INTEL_PT_BLK_ITEMS;\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\tdecoder->state.to_ip = 0;\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_BEP_IP:\n\t\t\terr = intel_pt_get_next_packet(decoder);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (decoder->packet.type == INTEL_PT_FUP) {\n\t\t\t\tdecoder->set_fup_bep = true;\n\t\t\t\tno_tip = true;\n\t\t\t} else {\n\t\t\t\tintel_pt_log_at(\"ERROR: Missing FUP after BEP\",\n\t\t\t\t\t\tdecoder->pos);\n\t\t\t}\n\t\t\tgoto next;\n\n\t\tcase INTEL_PT_CFE:\n\t\t\tdecoder->fup_cfe_pkt = decoder->packet;\n\t\t\tdecoder->set_fup_cfe = true;\n\t\t\tif (!decoder->pge) {\n\t\t\t\tintel_pt_fup_event(decoder, true);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CFE_IP:\n\t\t\tdecoder->fup_cfe_pkt = decoder->packet;\n\t\t\terr = intel_pt_get_next_packet(decoder);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (decoder->packet.type == INTEL_PT_FUP) {\n\t\t\t\tdecoder->set_fup_cfe_ip = true;\n\t\t\t\tno_tip = true;\n\t\t\t} else {\n\t\t\t\tintel_pt_log_at(\"ERROR: Missing FUP after CFE\",\n\t\t\t\t\t\tdecoder->pos);\n\t\t\t}\n\t\t\tgoto next;\n\n\t\tcase INTEL_PT_EVD:\n\t\t\terr = intel_pt_evd(decoder);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn intel_pt_bug(decoder);\n\t\t}\n\t}\n}\n\nstatic inline bool intel_pt_have_ip(struct intel_pt_decoder *decoder)\n{\n\treturn decoder->packet.count &&\n\t       (decoder->have_last_ip || decoder->packet.count == 3 ||\n\t\tdecoder->packet.count == 6);\n}\n\n \nstatic int intel_pt_walk_psb(struct intel_pt_decoder *decoder)\n{\n\tint err;\n\n\tdecoder->in_psb = true;\n\n\twhile (1) {\n\t\terr = intel_pt_get_next_packet(decoder);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tswitch (decoder->packet.type) {\n\t\tcase INTEL_PT_TIP_PGD:\n\t\t\tdecoder->continuous_period = false;\n\t\t\tfallthrough;\n\t\tcase INTEL_PT_TIP_PGE:\n\t\tcase INTEL_PT_TIP:\n\t\tcase INTEL_PT_PTWRITE:\n\t\tcase INTEL_PT_PTWRITE_IP:\n\t\tcase INTEL_PT_EXSTOP:\n\t\tcase INTEL_PT_EXSTOP_IP:\n\t\tcase INTEL_PT_MWAIT:\n\t\tcase INTEL_PT_PWRE:\n\t\tcase INTEL_PT_PWRX:\n\t\tcase INTEL_PT_BBP:\n\t\tcase INTEL_PT_BIP:\n\t\tcase INTEL_PT_BEP:\n\t\tcase INTEL_PT_BEP_IP:\n\t\tcase INTEL_PT_CFE:\n\t\tcase INTEL_PT_CFE_IP:\n\t\tcase INTEL_PT_EVD:\n\t\t\tintel_pt_log(\"ERROR: Unexpected packet\\n\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\n\t\tcase INTEL_PT_FUP:\n\t\t\tdecoder->pge = true;\n\t\t\tif (intel_pt_have_ip(decoder)) {\n\t\t\t\tuint64_t current_ip = decoder->ip;\n\n\t\t\t\tintel_pt_set_ip(decoder);\n\t\t\t\tdecoder->psb_ip = decoder->ip;\n\t\t\t\tif (current_ip)\n\t\t\t\t\tintel_pt_log_to(\"Setting IP\",\n\t\t\t\t\t\t\tdecoder->ip);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MTC:\n\t\t\tintel_pt_calc_mtc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_TSC:\n\t\t\tintel_pt_calc_tsc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_TMA:\n\t\t\tintel_pt_calc_tma(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CYC:\n\t\t\tintel_pt_calc_cyc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CBR:\n\t\t\tintel_pt_calc_cbr(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_PIP:\n\t\t\tintel_pt_set_pip(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MODE_EXEC:\n\t\t\tintel_pt_mode_exec_status(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MODE_TSX:\n\t\t\tintel_pt_update_in_tx(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_TRACESTOP:\n\t\t\tdecoder->pge = false;\n\t\t\tdecoder->continuous_period = false;\n\t\t\tintel_pt_clear_tx_flags(decoder);\n\t\t\tfallthrough;\n\n\t\tcase INTEL_PT_TNT:\n\t\t\tdecoder->have_tma = false;\n\t\t\tintel_pt_log(\"ERROR: Unexpected packet\\n\");\n\t\t\tif (decoder->ip)\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR4;\n\t\t\telse\n\t\t\t\tdecoder->pkt_state = INTEL_PT_STATE_ERR3;\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\n\t\tcase INTEL_PT_BAD:  \n\t\t\terr = intel_pt_bug(decoder);\n\t\t\tgoto out;\n\n\t\tcase INTEL_PT_OVF:\n\t\t\terr = intel_pt_overflow(decoder);\n\t\t\tgoto out;\n\n\t\tcase INTEL_PT_PSBEND:\n\t\t\terr = 0;\n\t\t\tgoto out;\n\n\t\tcase INTEL_PT_PSB:\n\t\tcase INTEL_PT_VMCS:\n\t\tcase INTEL_PT_MNT:\n\t\tcase INTEL_PT_PAD:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tdecoder->in_psb = false;\n\n\treturn err;\n}\n\nstatic int intel_pt_walk_to_ip(struct intel_pt_decoder *decoder)\n{\n\tint err;\n\n\twhile (1) {\n\t\terr = intel_pt_get_next_packet(decoder);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tswitch (decoder->packet.type) {\n\t\tcase INTEL_PT_TIP_PGD:\n\t\t\tdecoder->continuous_period = false;\n\t\t\tdecoder->pge = false;\n\t\t\tif (intel_pt_have_ip(decoder))\n\t\t\t\tintel_pt_set_ip(decoder);\n\t\t\tif (!decoder->ip)\n\t\t\t\tbreak;\n\t\t\tdecoder->state.type |= INTEL_PT_TRACE_END;\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_TIP_PGE:\n\t\t\tdecoder->pge = true;\n\t\t\tintel_pt_mtc_cyc_cnt_pge(decoder);\n\t\t\tif (intel_pt_have_ip(decoder))\n\t\t\t\tintel_pt_set_ip(decoder);\n\t\t\tif (!decoder->ip)\n\t\t\t\tbreak;\n\t\t\tdecoder->state.type |= INTEL_PT_TRACE_BEGIN;\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_TIP:\n\t\t\tdecoder->pge = true;\n\t\t\tif (intel_pt_have_ip(decoder))\n\t\t\t\tintel_pt_set_ip(decoder);\n\t\t\tif (!decoder->ip)\n\t\t\t\tbreak;\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_FUP:\n\t\t\tif (intel_pt_have_ip(decoder))\n\t\t\t\tintel_pt_set_ip(decoder);\n\t\t\tif (decoder->ip)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MTC:\n\t\t\tintel_pt_calc_mtc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_TSC:\n\t\t\tintel_pt_calc_tsc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_TMA:\n\t\t\tintel_pt_calc_tma(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CYC:\n\t\t\tintel_pt_calc_cyc_timestamp(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_CBR:\n\t\t\tintel_pt_calc_cbr(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_PIP:\n\t\t\tintel_pt_set_pip(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MODE_EXEC:\n\t\t\tintel_pt_mode_exec_status(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_MODE_TSX:\n\t\t\tintel_pt_update_in_tx(decoder);\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_OVF:\n\t\t\treturn intel_pt_overflow(decoder);\n\n\t\tcase INTEL_PT_BAD:  \n\t\t\treturn intel_pt_bug(decoder);\n\n\t\tcase INTEL_PT_TRACESTOP:\n\t\t\tdecoder->pge = false;\n\t\t\tdecoder->continuous_period = false;\n\t\t\tintel_pt_clear_tx_flags(decoder);\n\t\t\tdecoder->have_tma = false;\n\t\t\tbreak;\n\n\t\tcase INTEL_PT_PSB:\n\t\t\tdecoder->state.psb_offset = decoder->pos;\n\t\t\tdecoder->psb_ip = 0;\n\t\t\tdecoder->last_ip = 0;\n\t\t\tdecoder->have_last_ip = true;\n\t\t\tintel_pt_clear_stack(&decoder->stack);\n\t\t\terr = intel_pt_walk_psb(decoder);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdecoder->state.type = INTEL_PT_PSB_EVT;\n\t\t\tdecoder->state.from_ip = decoder->psb_ip;\n\t\t\tdecoder->state.to_ip = 0;\n\t\t\treturn 0;\n\n\t\tcase INTEL_PT_TNT:\n\t\tcase INTEL_PT_PSBEND:\n\t\tcase INTEL_PT_VMCS:\n\t\tcase INTEL_PT_MNT:\n\t\tcase INTEL_PT_PAD:\n\t\tcase INTEL_PT_PTWRITE:\n\t\tcase INTEL_PT_PTWRITE_IP:\n\t\tcase INTEL_PT_EXSTOP:\n\t\tcase INTEL_PT_EXSTOP_IP:\n\t\tcase INTEL_PT_MWAIT:\n\t\tcase INTEL_PT_PWRE:\n\t\tcase INTEL_PT_PWRX:\n\t\tcase INTEL_PT_BBP:\n\t\tcase INTEL_PT_BIP:\n\t\tcase INTEL_PT_BEP:\n\t\tcase INTEL_PT_BEP_IP:\n\t\tcase INTEL_PT_CFE:\n\t\tcase INTEL_PT_CFE_IP:\n\t\tcase INTEL_PT_EVD:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int intel_pt_sync_ip(struct intel_pt_decoder *decoder)\n{\n\tint err;\n\n\tintel_pt_clear_fup_event(decoder);\n\tdecoder->overflow = false;\n\n\tif (!decoder->branch_enable) {\n\t\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\t\tdecoder->state.type = 0;  \n\t\treturn 0;\n\t}\n\n\tintel_pt_log(\"Scanning for full IP\\n\");\n\terr = intel_pt_walk_to_ip(decoder);\n\tif (err || ((decoder->state.type & INTEL_PT_PSB_EVT) && !decoder->ip))\n\t\treturn err;\n\n\t \n\tif (decoder->hop)\n\t\tdecoder->pkt_state = INTEL_PT_STATE_RESAMPLE;\n\telse\n\t\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\n\tdecoder->state.from_ip = 0;\n\tdecoder->state.to_ip = decoder->ip;\n\tintel_pt_log_to(\"Setting IP\", decoder->ip);\n\n\treturn 0;\n}\n\nstatic int intel_pt_part_psb(struct intel_pt_decoder *decoder)\n{\n\tconst unsigned char *end = decoder->buf + decoder->len;\n\tsize_t i;\n\n\tfor (i = INTEL_PT_PSB_LEN - 1; i; i--) {\n\t\tif (i > decoder->len)\n\t\t\tcontinue;\n\t\tif (!memcmp(end - i, INTEL_PT_PSB_STR, i))\n\t\t\treturn i;\n\t}\n\treturn 0;\n}\n\nstatic int intel_pt_rest_psb(struct intel_pt_decoder *decoder, int part_psb)\n{\n\tsize_t rest_psb = INTEL_PT_PSB_LEN - part_psb;\n\tconst char *psb = INTEL_PT_PSB_STR;\n\n\tif (rest_psb > decoder->len ||\n\t    memcmp(decoder->buf, psb + part_psb, rest_psb))\n\t\treturn 0;\n\n\treturn rest_psb;\n}\n\nstatic int intel_pt_get_split_psb(struct intel_pt_decoder *decoder,\n\t\t\t\t  int part_psb)\n{\n\tint rest_psb, ret;\n\n\tdecoder->pos += decoder->len;\n\tdecoder->len = 0;\n\n\tret = intel_pt_get_next_data(decoder, false);\n\tif (ret)\n\t\treturn ret;\n\n\trest_psb = intel_pt_rest_psb(decoder, part_psb);\n\tif (!rest_psb)\n\t\treturn 0;\n\n\tdecoder->pos -= part_psb;\n\tdecoder->next_buf = decoder->buf + rest_psb;\n\tdecoder->next_len = decoder->len - rest_psb;\n\tmemcpy(decoder->temp_buf, INTEL_PT_PSB_STR, INTEL_PT_PSB_LEN);\n\tdecoder->buf = decoder->temp_buf;\n\tdecoder->len = INTEL_PT_PSB_LEN;\n\n\treturn 0;\n}\n\nstatic int intel_pt_scan_for_psb(struct intel_pt_decoder *decoder)\n{\n\tunsigned char *next;\n\tint ret;\n\n\tintel_pt_log(\"Scanning for PSB\\n\");\n\twhile (1) {\n\t\tif (!decoder->len) {\n\t\t\tret = intel_pt_get_next_data(decoder, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tnext = memmem(decoder->buf, decoder->len, INTEL_PT_PSB_STR,\n\t\t\t      INTEL_PT_PSB_LEN);\n\t\tif (!next) {\n\t\t\tint part_psb;\n\n\t\t\tpart_psb = intel_pt_part_psb(decoder);\n\t\t\tif (part_psb) {\n\t\t\t\tret = intel_pt_get_split_psb(decoder, part_psb);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tdecoder->pos += decoder->len;\n\t\t\t\tdecoder->len = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tdecoder->pkt_step = next - decoder->buf;\n\t\treturn intel_pt_get_next_packet(decoder);\n\t}\n}\n\nstatic int intel_pt_sync(struct intel_pt_decoder *decoder)\n{\n\tint err;\n\n\tdecoder->pge = false;\n\tdecoder->continuous_period = false;\n\tdecoder->have_last_ip = false;\n\tdecoder->last_ip = 0;\n\tdecoder->psb_ip = 0;\n\tdecoder->ip = 0;\n\tintel_pt_clear_stack(&decoder->stack);\n\n\terr = intel_pt_scan_for_psb(decoder);\n\tif (err)\n\t\treturn err;\n\n\tif (decoder->vm_time_correlation) {\n\t\tdecoder->in_psb = true;\n\t\tif (!decoder->timestamp)\n\t\t\tdecoder->timestamp = 1;\n\t\tdecoder->state.type = 0;\n\t\tdecoder->pkt_state = INTEL_PT_STATE_VM_TIME_CORRELATION;\n\t\treturn 0;\n\t}\n\n\tdecoder->have_last_ip = true;\n\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\n\terr = intel_pt_walk_psb(decoder);\n\tif (err)\n\t\treturn err;\n\n\tdecoder->state.type = INTEL_PT_PSB_EVT;  \n\tdecoder->state.from_ip = decoder->psb_ip;\n\tdecoder->state.to_ip = 0;\n\n\tif (decoder->ip) {\n\t\t \n\t\tif (decoder->hop)\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_RESAMPLE;\n\t\telse\n\t\t\tdecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\n\t}\n\n\treturn 0;\n}\n\nstatic uint64_t intel_pt_est_timestamp(struct intel_pt_decoder *decoder)\n{\n\tuint64_t est = decoder->sample_insn_cnt << 1;\n\n\tif (!decoder->cbr || !decoder->max_non_turbo_ratio)\n\t\tgoto out;\n\n\test *= decoder->max_non_turbo_ratio;\n\test /= decoder->cbr;\nout:\n\treturn decoder->sample_timestamp + est;\n}\n\nconst struct intel_pt_state *intel_pt_decode(struct intel_pt_decoder *decoder)\n{\n\tint err;\n\n\tdo {\n\t\tdecoder->state.type = INTEL_PT_BRANCH;\n\t\tdecoder->state.flags = 0;\n\n\t\tswitch (decoder->pkt_state) {\n\t\tcase INTEL_PT_STATE_NO_PSB:\n\t\t\terr = intel_pt_sync(decoder);\n\t\t\tbreak;\n\t\tcase INTEL_PT_STATE_NO_IP:\n\t\t\tdecoder->have_last_ip = false;\n\t\t\tdecoder->last_ip = 0;\n\t\t\tdecoder->ip = 0;\n\t\t\tfallthrough;\n\t\tcase INTEL_PT_STATE_ERR_RESYNC:\n\t\t\terr = intel_pt_sync_ip(decoder);\n\t\t\tbreak;\n\t\tcase INTEL_PT_STATE_IN_SYNC:\n\t\t\terr = intel_pt_walk_trace(decoder);\n\t\t\tbreak;\n\t\tcase INTEL_PT_STATE_TNT:\n\t\tcase INTEL_PT_STATE_TNT_CONT:\n\t\t\terr = intel_pt_walk_tnt(decoder);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\terr = intel_pt_walk_trace(decoder);\n\t\t\tbreak;\n\t\tcase INTEL_PT_STATE_TIP:\n\t\tcase INTEL_PT_STATE_TIP_PGD:\n\t\t\terr = intel_pt_walk_tip(decoder);\n\t\t\tbreak;\n\t\tcase INTEL_PT_STATE_FUP:\n\t\t\terr = intel_pt_walk_fup(decoder);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\terr = intel_pt_walk_fup_tip(decoder);\n\t\t\tbreak;\n\t\tcase INTEL_PT_STATE_FUP_NO_TIP:\n\t\t\terr = intel_pt_walk_fup(decoder);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\terr = intel_pt_walk_trace(decoder);\n\t\t\tbreak;\n\t\tcase INTEL_PT_STATE_FUP_IN_PSB:\n\t\t\terr = intel_pt_fup_in_psb(decoder);\n\t\t\tbreak;\n\t\tcase INTEL_PT_STATE_RESAMPLE:\n\t\t\terr = intel_pt_resample(decoder);\n\t\t\tbreak;\n\t\tcase INTEL_PT_STATE_VM_TIME_CORRELATION:\n\t\t\terr = intel_pt_vm_time_correlation(decoder);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = intel_pt_bug(decoder);\n\t\t\tbreak;\n\t\t}\n\t} while (err == -ENOLINK);\n\n\tif (err) {\n\t\tdecoder->state.err = intel_pt_ext_err(err);\n\t\tif (err != -EOVERFLOW)\n\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\tintel_pt_update_sample_time(decoder);\n\t\tdecoder->sample_tot_cyc_cnt = decoder->tot_cyc_cnt;\n\t\tintel_pt_set_nr(decoder);\n\t} else {\n\t\tdecoder->state.err = 0;\n\t\tif (decoder->cbr != decoder->cbr_seen) {\n\t\t\tdecoder->cbr_seen = decoder->cbr;\n\t\t\tif (!decoder->state.type) {\n\t\t\t\tdecoder->state.from_ip = decoder->ip;\n\t\t\t\tdecoder->state.to_ip = 0;\n\t\t\t}\n\t\t\tdecoder->state.type |= INTEL_PT_CBR_CHG;\n\t\t\tdecoder->state.cbr_payload = decoder->cbr_payload;\n\t\t\tdecoder->state.cbr = decoder->cbr;\n\t\t}\n\t\tif (intel_pt_sample_time(decoder->pkt_state)) {\n\t\t\tintel_pt_update_sample_time(decoder);\n\t\t\tif (decoder->sample_cyc) {\n\t\t\t\tdecoder->sample_tot_cyc_cnt = decoder->tot_cyc_cnt;\n\t\t\t\tdecoder->state.flags |= INTEL_PT_SAMPLE_IPC;\n\t\t\t\tdecoder->sample_cyc = false;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (!decoder->have_cyc)\n\t\t\tdecoder->state.flags |= INTEL_PT_SAMPLE_IPC;\n\t}\n\n\t  \n\tif ((decoder->state.type & INTEL_PT_PSB_EVT) && decoder->tsc_timestamp)\n\t\tdecoder->sample_timestamp = decoder->tsc_timestamp;\n\n\tdecoder->state.from_nr = decoder->nr;\n\tdecoder->state.to_nr = decoder->next_nr;\n\tdecoder->nr = decoder->next_nr;\n\n\tdecoder->state.timestamp = decoder->sample_timestamp;\n\tdecoder->state.est_timestamp = intel_pt_est_timestamp(decoder);\n\tdecoder->state.tot_insn_cnt = decoder->tot_insn_cnt;\n\tdecoder->state.tot_cyc_cnt = decoder->sample_tot_cyc_cnt;\n\n\treturn &decoder->state;\n}\n\n \nstatic bool intel_pt_next_psb(unsigned char **buf, size_t *len)\n{\n\tunsigned char *next;\n\n\tnext = memmem(*buf, *len, INTEL_PT_PSB_STR, INTEL_PT_PSB_LEN);\n\tif (next) {\n\t\t*len -= next - *buf;\n\t\t*buf = next;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool intel_pt_step_psb(unsigned char **buf, size_t *len)\n{\n\tunsigned char *next;\n\n\tif (!*len)\n\t\treturn false;\n\n\tnext = memmem(*buf + 1, *len - 1, INTEL_PT_PSB_STR, INTEL_PT_PSB_LEN);\n\tif (next) {\n\t\t*len -= next - *buf;\n\t\t*buf = next;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic unsigned char *intel_pt_last_psb(unsigned char *buf, size_t len)\n{\n\tconst char *n = INTEL_PT_PSB_STR;\n\tunsigned char *p;\n\tsize_t k;\n\n\tif (len < INTEL_PT_PSB_LEN)\n\t\treturn NULL;\n\n\tk = len - INTEL_PT_PSB_LEN + 1;\n\twhile (1) {\n\t\tp = memrchr(buf, n[0], k);\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tif (!memcmp(p + 1, n + 1, INTEL_PT_PSB_LEN - 1))\n\t\t\treturn p;\n\t\tk = p - buf;\n\t\tif (!k)\n\t\t\treturn NULL;\n\t}\n}\n\n \nstatic bool intel_pt_next_tsc(unsigned char *buf, size_t len, uint64_t *tsc,\n\t\t\t      size_t *rem)\n{\n\tenum intel_pt_pkt_ctx ctx = INTEL_PT_NO_CTX;\n\tstruct intel_pt_pkt packet;\n\tint ret;\n\n\twhile (len) {\n\t\tret = intel_pt_get_packet(buf, len, &packet, &ctx);\n\t\tif (ret <= 0)\n\t\t\treturn false;\n\t\tif (packet.type == INTEL_PT_TSC) {\n\t\t\t*tsc = packet.payload;\n\t\t\t*rem = len;\n\t\t\treturn true;\n\t\t}\n\t\tif (packet.type == INTEL_PT_PSBEND)\n\t\t\treturn false;\n\t\tbuf += ret;\n\t\tlen -= ret;\n\t}\n\treturn false;\n}\n\n \nstatic int intel_pt_tsc_cmp(uint64_t tsc1, uint64_t tsc2)\n{\n\tconst uint64_t halfway = (1ULL << 55);\n\n\tif (tsc1 == tsc2)\n\t\treturn 0;\n\n\tif (tsc1 < tsc2) {\n\t\tif (tsc2 - tsc1 < halfway)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t} else {\n\t\tif (tsc1 - tsc2 < halfway)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n}\n\n#define MAX_PADDING (PERF_AUXTRACE_RECORD_ALIGNMENT - 1)\n\n \nstatic unsigned char *adj_for_padding(unsigned char *buf_b,\n\t\t\t\t      unsigned char *buf_a, size_t len_a)\n{\n\tunsigned char *p = buf_b - MAX_PADDING;\n\tunsigned char *q = buf_a + len_a - MAX_PADDING;\n\tint i;\n\n\tfor (i = MAX_PADDING; i; i--, p++, q++) {\n\t\tif (*p != *q)\n\t\t\tbreak;\n\t}\n\n\treturn p;\n}\n\n \nstatic unsigned char *intel_pt_find_overlap_tsc(unsigned char *buf_a,\n\t\t\t\t\t\tsize_t len_a,\n\t\t\t\t\t\tunsigned char *buf_b,\n\t\t\t\t\t\tsize_t len_b, bool *consecutive,\n\t\t\t\t\t\tbool ooo_tsc)\n{\n\tuint64_t tsc_a, tsc_b;\n\tunsigned char *p;\n\tsize_t len, rem_a, rem_b;\n\n\tp = intel_pt_last_psb(buf_a, len_a);\n\tif (!p)\n\t\treturn buf_b;  \n\n\tlen = len_a - (p - buf_a);\n\tif (!intel_pt_next_tsc(p, len, &tsc_a, &rem_a)) {\n\t\t \n\t\tlen_a -= len;\n\t\tp = intel_pt_last_psb(buf_a, len_a);\n\t\tif (!p)\n\t\t\treturn buf_b;  \n\t\tlen = len_a - (p - buf_a);\n\t\tif (!intel_pt_next_tsc(p, len, &tsc_a, &rem_a))\n\t\t\treturn buf_b;  \n\t}\n\n\twhile (1) {\n\t\t \n\t\tif (intel_pt_next_tsc(buf_b, len_b, &tsc_b, &rem_b)) {\n\t\t\tint cmp = intel_pt_tsc_cmp(tsc_a, tsc_b);\n\n\t\t\t \n\t\t\tif (!cmp && rem_b >= rem_a) {\n\t\t\t\tunsigned char *start;\n\n\t\t\t\t*consecutive = true;\n\t\t\t\tstart = buf_b + len_b - (rem_b - rem_a);\n\t\t\t\treturn adj_for_padding(start, buf_a, len_a);\n\t\t\t}\n\t\t\tif (cmp < 0 && !ooo_tsc)\n\t\t\t\treturn buf_b;  \n\t\t}\n\n\t\tif (!intel_pt_step_psb(&buf_b, &len_b))\n\t\t\treturn buf_b + len_b;  \n\t}\n}\n\n \nunsigned char *intel_pt_find_overlap(unsigned char *buf_a, size_t len_a,\n\t\t\t\t     unsigned char *buf_b, size_t len_b,\n\t\t\t\t     bool have_tsc, bool *consecutive,\n\t\t\t\t     bool ooo_tsc)\n{\n\tunsigned char *found;\n\n\t \n\tif (!intel_pt_next_psb(&buf_b, &len_b))\n\t\treturn buf_b + len_b;  \n\n\tif (!intel_pt_next_psb(&buf_a, &len_a))\n\t\treturn buf_b;  \n\n\tif (have_tsc) {\n\t\tfound = intel_pt_find_overlap_tsc(buf_a, len_a, buf_b, len_b,\n\t\t\t\t\t\t  consecutive, ooo_tsc);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\t \n\twhile (len_b < len_a) {\n\t\tif (!intel_pt_step_psb(&buf_a, &len_a))\n\t\t\treturn buf_b;  \n\t}\n\n\t \n\twhile (1) {\n\t\t \n\t\tfound = memmem(buf_a, len_a, buf_b, len_a);\n\t\tif (found) {\n\t\t\t*consecutive = true;\n\t\t\treturn adj_for_padding(buf_b + len_a, buf_a, len_a);\n\t\t}\n\n\t\t \n\t\tif (!intel_pt_step_psb(&buf_a, &len_a))\n\t\t\treturn buf_b;  \n\t}\n}\n\n \nstruct fast_forward_data {\n\tuint64_t timestamp;\n\tuint64_t buf_timestamp;\n};\n\n \nstatic int intel_pt_ff_cb(struct intel_pt_buffer *buffer, void *data)\n{\n\tstruct fast_forward_data *d = data;\n\tunsigned char *buf;\n\tuint64_t tsc;\n\tsize_t rem;\n\tsize_t len;\n\n\tbuf = (unsigned char *)buffer->buf;\n\tlen = buffer->len;\n\n\tif (!intel_pt_next_psb(&buf, &len) ||\n\t    !intel_pt_next_tsc(buf, len, &tsc, &rem))\n\t\treturn 0;\n\n\ttsc = intel_pt_8b_tsc(tsc, buffer->ref_timestamp);\n\n\tintel_pt_log(\"Buffer 1st timestamp \" x64_fmt \" ref timestamp \" x64_fmt \"\\n\",\n\t\t     tsc, buffer->ref_timestamp);\n\n\t \n\tif (tsc < d->timestamp)\n\t\td->buf_timestamp = buffer->ref_timestamp;\n\telse\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nint intel_pt_fast_forward(struct intel_pt_decoder *decoder, uint64_t timestamp)\n{\n\tstruct fast_forward_data d = { .timestamp = timestamp };\n\tunsigned char *buf;\n\tsize_t len;\n\tint err;\n\n\tintel_pt_log(\"Fast forward towards timestamp \" x64_fmt \"\\n\", timestamp);\n\n\t \n\terr = decoder->lookahead(decoder->data, intel_pt_ff_cb, &d);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (d.buf_timestamp) {\n\t\tdo {\n\t\t\tdecoder->pos += decoder->len;\n\t\t\tdecoder->len = 0;\n\t\t\terr = intel_pt_get_next_data(decoder, true);\n\t\t\t \n\t\t\tif (err && err != -ENOLINK)\n\t\t\t\treturn err;\n\t\t} while (decoder->buf_timestamp != d.buf_timestamp);\n\t}\n\n\tif (!decoder->buf)\n\t\treturn 0;\n\n\tbuf = (unsigned char *)decoder->buf;\n\tlen = decoder->len;\n\n\tif (!intel_pt_next_psb(&buf, &len))\n\t\treturn 0;\n\n\t \n\tdo {\n\t\tuint64_t tsc;\n\t\tsize_t rem;\n\n\t\tif (!intel_pt_next_tsc(buf, len, &tsc, &rem))\n\t\t\tbreak;\n\t\ttsc = intel_pt_8b_tsc(tsc, decoder->buf_timestamp);\n\t\t \n\t\tif (tsc < timestamp) {\n\t\t\tintel_pt_log(\"Fast forward to next PSB timestamp \" x64_fmt \"\\n\", tsc);\n\t\t\tdecoder->pos += decoder->len - len;\n\t\t\tdecoder->buf = buf;\n\t\t\tdecoder->len = len;\n\t\t\tintel_pt_reposition(decoder);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (intel_pt_step_psb(&buf, &len));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}