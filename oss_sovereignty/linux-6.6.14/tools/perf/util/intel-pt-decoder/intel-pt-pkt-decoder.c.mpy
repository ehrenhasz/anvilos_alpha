{
  "module_name": "intel-pt-pkt-decoder.c",
  "hash_id": "116beec9099ae6d7a70ba6f3b81f18d68fba075781564fe18533b0685aa33e9c",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/intel-pt-decoder/intel-pt-pkt-decoder.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <string.h>\n#include <endian.h>\n#include <byteswap.h>\n#include <linux/compiler.h>\n\n#include \"intel-pt-pkt-decoder.h\"\n\n#define BIT(n)\t\t(1 << (n))\n\n#define BIT63\t\t((uint64_t)1 << 63)\n\n#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#define le16_to_cpu bswap_16\n#define le32_to_cpu bswap_32\n#define le64_to_cpu bswap_64\n#define memcpy_le64(d, s, n) do { \\\n\tmemcpy((d), (s), (n));    \\\n\t*(d) = le64_to_cpu(*(d)); \\\n} while (0)\n#else\n#define le16_to_cpu\n#define le32_to_cpu\n#define le64_to_cpu\n#define memcpy_le64 memcpy\n#endif\n\nstatic const char * const packet_name[] = {\n\t[INTEL_PT_BAD]\t\t= \"Bad Packet!\",\n\t[INTEL_PT_PAD]\t\t= \"PAD\",\n\t[INTEL_PT_TNT]\t\t= \"TNT\",\n\t[INTEL_PT_TIP_PGD]\t= \"TIP.PGD\",\n\t[INTEL_PT_TIP_PGE]\t= \"TIP.PGE\",\n\t[INTEL_PT_TSC]\t\t= \"TSC\",\n\t[INTEL_PT_TMA]\t\t= \"TMA\",\n\t[INTEL_PT_MODE_EXEC]\t= \"MODE.Exec\",\n\t[INTEL_PT_MODE_TSX]\t= \"MODE.TSX\",\n\t[INTEL_PT_MTC]\t\t= \"MTC\",\n\t[INTEL_PT_TIP]\t\t= \"TIP\",\n\t[INTEL_PT_FUP]\t\t= \"FUP\",\n\t[INTEL_PT_CYC]\t\t= \"CYC\",\n\t[INTEL_PT_VMCS]\t\t= \"VMCS\",\n\t[INTEL_PT_PSB]\t\t= \"PSB\",\n\t[INTEL_PT_PSBEND]\t= \"PSBEND\",\n\t[INTEL_PT_CBR]\t\t= \"CBR\",\n\t[INTEL_PT_TRACESTOP]\t= \"TraceSTOP\",\n\t[INTEL_PT_PIP]\t\t= \"PIP\",\n\t[INTEL_PT_OVF]\t\t= \"OVF\",\n\t[INTEL_PT_MNT]\t\t= \"MNT\",\n\t[INTEL_PT_PTWRITE]\t= \"PTWRITE\",\n\t[INTEL_PT_PTWRITE_IP]\t= \"PTWRITE\",\n\t[INTEL_PT_EXSTOP]\t= \"EXSTOP\",\n\t[INTEL_PT_EXSTOP_IP]\t= \"EXSTOP\",\n\t[INTEL_PT_MWAIT]\t= \"MWAIT\",\n\t[INTEL_PT_PWRE]\t\t= \"PWRE\",\n\t[INTEL_PT_PWRX]\t\t= \"PWRX\",\n\t[INTEL_PT_BBP]\t\t= \"BBP\",\n\t[INTEL_PT_BIP]\t\t= \"BIP\",\n\t[INTEL_PT_BEP]\t\t= \"BEP\",\n\t[INTEL_PT_BEP_IP]\t= \"BEP\",\n\t[INTEL_PT_CFE]\t\t= \"CFE\",\n\t[INTEL_PT_CFE_IP]\t= \"CFE\",\n\t[INTEL_PT_EVD]\t\t= \"EVD\",\n};\n\nconst char *intel_pt_pkt_name(enum intel_pt_pkt_type type)\n{\n\treturn packet_name[type];\n}\n\nstatic int intel_pt_get_long_tnt(const unsigned char *buf, size_t len,\n\t\t\t\t struct intel_pt_pkt *packet)\n{\n\tuint64_t payload;\n\tint count;\n\n\tif (len < 8)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\n\tpayload = le64_to_cpu(*(uint64_t *)buf);\n\n\tfor (count = 47; count; count--) {\n\t\tif (payload & BIT63)\n\t\t\tbreak;\n\t\tpayload <<= 1;\n\t}\n\n\tpacket->type = INTEL_PT_TNT;\n\tpacket->count = count;\n\tpacket->payload = payload << 1;\n\treturn 8;\n}\n\nstatic int intel_pt_get_pip(const unsigned char *buf, size_t len,\n\t\t\t    struct intel_pt_pkt *packet)\n{\n\tuint64_t payload = 0;\n\n\tif (len < 8)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\n\tpacket->type = INTEL_PT_PIP;\n\tmemcpy_le64(&payload, buf + 2, 6);\n\tpacket->payload = payload;\n\n\treturn 8;\n}\n\nstatic int intel_pt_get_tracestop(struct intel_pt_pkt *packet)\n{\n\tpacket->type = INTEL_PT_TRACESTOP;\n\treturn 2;\n}\n\nstatic int intel_pt_get_cbr(const unsigned char *buf, size_t len,\n\t\t\t    struct intel_pt_pkt *packet)\n{\n\tif (len < 4)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_CBR;\n\tpacket->payload = le16_to_cpu(*(uint16_t *)(buf + 2));\n\treturn 4;\n}\n\nstatic int intel_pt_get_vmcs(const unsigned char *buf, size_t len,\n\t\t\t     struct intel_pt_pkt *packet)\n{\n\tunsigned int count = (52 - 5) >> 3;\n\n\tif (count < 1 || count > 7)\n\t\treturn INTEL_PT_BAD_PACKET;\n\n\tif (len < count + 2)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\n\tpacket->type = INTEL_PT_VMCS;\n\tpacket->count = count;\n\tmemcpy_le64(&packet->payload, buf + 2, count);\n\n\treturn count + 2;\n}\n\nstatic int intel_pt_get_ovf(struct intel_pt_pkt *packet)\n{\n\tpacket->type = INTEL_PT_OVF;\n\treturn 2;\n}\n\nstatic int intel_pt_get_psb(const unsigned char *buf, size_t len,\n\t\t\t    struct intel_pt_pkt *packet)\n{\n\tint i;\n\n\tif (len < 16)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\n\tfor (i = 2; i < 16; i += 2) {\n\t\tif (buf[i] != 2 || buf[i + 1] != 0x82)\n\t\t\treturn INTEL_PT_BAD_PACKET;\n\t}\n\n\tpacket->type = INTEL_PT_PSB;\n\treturn 16;\n}\n\nstatic int intel_pt_get_psbend(struct intel_pt_pkt *packet)\n{\n\tpacket->type = INTEL_PT_PSBEND;\n\treturn 2;\n}\n\nstatic int intel_pt_get_tma(const unsigned char *buf, size_t len,\n\t\t\t    struct intel_pt_pkt *packet)\n{\n\tif (len < 7)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\n\tpacket->type = INTEL_PT_TMA;\n\tpacket->payload = buf[2] | (buf[3] << 8);\n\tpacket->count = buf[5] | ((buf[6] & BIT(0)) << 8);\n\treturn 7;\n}\n\nstatic int intel_pt_get_pad(struct intel_pt_pkt *packet)\n{\n\tpacket->type = INTEL_PT_PAD;\n\treturn 1;\n}\n\nstatic int intel_pt_get_mnt(const unsigned char *buf, size_t len,\n\t\t\t    struct intel_pt_pkt *packet)\n{\n\tif (len < 11)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_MNT;\n\tmemcpy_le64(&packet->payload, buf + 3, 8);\n\treturn 11;\n}\n\nstatic int intel_pt_get_3byte(const unsigned char *buf, size_t len,\n\t\t\t      struct intel_pt_pkt *packet)\n{\n\tif (len < 3)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\n\tswitch (buf[2]) {\n\tcase 0x88:  \n\t\treturn intel_pt_get_mnt(buf, len, packet);\n\tdefault:\n\t\treturn INTEL_PT_BAD_PACKET;\n\t}\n}\n\nstatic int intel_pt_get_ptwrite(const unsigned char *buf, size_t len,\n\t\t\t\tstruct intel_pt_pkt *packet)\n{\n\tpacket->count = (buf[1] >> 5) & 0x3;\n\tpacket->type = buf[1] & BIT(7) ? INTEL_PT_PTWRITE_IP :\n\t\t\t\t\t INTEL_PT_PTWRITE;\n\n\tswitch (packet->count) {\n\tcase 0:\n\t\tif (len < 6)\n\t\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\t\tpacket->payload = le32_to_cpu(*(uint32_t *)(buf + 2));\n\t\treturn 6;\n\tcase 1:\n\t\tif (len < 10)\n\t\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\t\tpacket->payload = le64_to_cpu(*(uint64_t *)(buf + 2));\n\t\treturn 10;\n\tdefault:\n\t\treturn INTEL_PT_BAD_PACKET;\n\t}\n}\n\nstatic int intel_pt_get_exstop(struct intel_pt_pkt *packet)\n{\n\tpacket->type = INTEL_PT_EXSTOP;\n\treturn 2;\n}\n\nstatic int intel_pt_get_exstop_ip(struct intel_pt_pkt *packet)\n{\n\tpacket->type = INTEL_PT_EXSTOP_IP;\n\treturn 2;\n}\n\nstatic int intel_pt_get_mwait(const unsigned char *buf, size_t len,\n\t\t\t      struct intel_pt_pkt *packet)\n{\n\tif (len < 10)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_MWAIT;\n\tpacket->payload = le64_to_cpu(*(uint64_t *)(buf + 2));\n\treturn 10;\n}\n\nstatic int intel_pt_get_pwre(const unsigned char *buf, size_t len,\n\t\t\t     struct intel_pt_pkt *packet)\n{\n\tif (len < 4)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_PWRE;\n\tmemcpy_le64(&packet->payload, buf + 2, 2);\n\treturn 4;\n}\n\nstatic int intel_pt_get_pwrx(const unsigned char *buf, size_t len,\n\t\t\t     struct intel_pt_pkt *packet)\n{\n\tif (len < 7)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_PWRX;\n\tmemcpy_le64(&packet->payload, buf + 2, 5);\n\treturn 7;\n}\n\nstatic int intel_pt_get_bbp(const unsigned char *buf, size_t len,\n\t\t\t    struct intel_pt_pkt *packet)\n{\n\tif (len < 3)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_BBP;\n\tpacket->count = buf[2] >> 7;\n\tpacket->payload = buf[2] & 0x1f;\n\treturn 3;\n}\n\nstatic int intel_pt_get_bip_4(const unsigned char *buf, size_t len,\n\t\t\t      struct intel_pt_pkt *packet)\n{\n\tif (len < 5)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_BIP;\n\tpacket->count = buf[0] >> 3;\n\tmemcpy_le64(&packet->payload, buf + 1, 4);\n\treturn 5;\n}\n\nstatic int intel_pt_get_bip_8(const unsigned char *buf, size_t len,\n\t\t\t      struct intel_pt_pkt *packet)\n{\n\tif (len < 9)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_BIP;\n\tpacket->count = buf[0] >> 3;\n\tmemcpy_le64(&packet->payload, buf + 1, 8);\n\treturn 9;\n}\n\nstatic int intel_pt_get_bep(size_t len, struct intel_pt_pkt *packet)\n{\n\tif (len < 2)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_BEP;\n\treturn 2;\n}\n\nstatic int intel_pt_get_bep_ip(size_t len, struct intel_pt_pkt *packet)\n{\n\tif (len < 2)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_BEP_IP;\n\treturn 2;\n}\n\nstatic int intel_pt_get_cfe(const unsigned char *buf, size_t len,\n\t\t\t    struct intel_pt_pkt *packet)\n{\n\tif (len < 4)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = buf[2] & 0x80 ? INTEL_PT_CFE_IP : INTEL_PT_CFE;\n\tpacket->count = buf[2] & 0x1f;\n\tpacket->payload = buf[3];\n\treturn 4;\n}\n\nstatic int intel_pt_get_evd(const unsigned char *buf, size_t len,\n\t\t\t    struct intel_pt_pkt *packet)\n{\n\tif (len < 11)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_EVD;\n\tpacket->count = buf[2] & 0x3f;\n\tpacket->payload = buf[3];\n\tmemcpy_le64(&packet->payload, buf + 3, 8);\n\treturn 11;\n}\n\nstatic int intel_pt_get_ext(const unsigned char *buf, size_t len,\n\t\t\t    struct intel_pt_pkt *packet)\n{\n\tif (len < 2)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\n\tif ((buf[1] & 0x1f) == 0x12)\n\t\treturn intel_pt_get_ptwrite(buf, len, packet);\n\n\tswitch (buf[1]) {\n\tcase 0xa3:  \n\t\treturn intel_pt_get_long_tnt(buf, len, packet);\n\tcase 0x43:  \n\t\treturn intel_pt_get_pip(buf, len, packet);\n\tcase 0x83:  \n\t\treturn intel_pt_get_tracestop(packet);\n\tcase 0x03:  \n\t\treturn intel_pt_get_cbr(buf, len, packet);\n\tcase 0xc8:  \n\t\treturn intel_pt_get_vmcs(buf, len, packet);\n\tcase 0xf3:  \n\t\treturn intel_pt_get_ovf(packet);\n\tcase 0x82:  \n\t\treturn intel_pt_get_psb(buf, len, packet);\n\tcase 0x23:  \n\t\treturn intel_pt_get_psbend(packet);\n\tcase 0x73:  \n\t\treturn intel_pt_get_tma(buf, len, packet);\n\tcase 0xC3:  \n\t\treturn intel_pt_get_3byte(buf, len, packet);\n\tcase 0x62:  \n\t\treturn intel_pt_get_exstop(packet);\n\tcase 0xE2:  \n\t\treturn intel_pt_get_exstop_ip(packet);\n\tcase 0xC2:  \n\t\treturn intel_pt_get_mwait(buf, len, packet);\n\tcase 0x22:  \n\t\treturn intel_pt_get_pwre(buf, len, packet);\n\tcase 0xA2:  \n\t\treturn intel_pt_get_pwrx(buf, len, packet);\n\tcase 0x63:  \n\t\treturn intel_pt_get_bbp(buf, len, packet);\n\tcase 0x33:  \n\t\treturn intel_pt_get_bep(len, packet);\n\tcase 0xb3:  \n\t\treturn intel_pt_get_bep_ip(len, packet);\n\tcase 0x13:  \n\t\treturn intel_pt_get_cfe(buf, len, packet);\n\tcase 0x53:  \n\t\treturn intel_pt_get_evd(buf, len, packet);\n\tdefault:\n\t\treturn INTEL_PT_BAD_PACKET;\n\t}\n}\n\nstatic int intel_pt_get_short_tnt(unsigned int byte,\n\t\t\t\t  struct intel_pt_pkt *packet)\n{\n\tint count;\n\n\tfor (count = 6; count; count--) {\n\t\tif (byte & BIT(7))\n\t\t\tbreak;\n\t\tbyte <<= 1;\n\t}\n\n\tpacket->type = INTEL_PT_TNT;\n\tpacket->count = count;\n\tpacket->payload = (uint64_t)byte << 57;\n\n\treturn 1;\n}\n\nstatic int intel_pt_get_cyc(unsigned int byte, const unsigned char *buf,\n\t\t\t    size_t len, struct intel_pt_pkt *packet)\n{\n\tunsigned int offs = 1, shift;\n\tuint64_t payload = byte >> 3;\n\n\tbyte >>= 2;\n\tlen -= 1;\n\tfor (shift = 5; byte & 1; shift += 7) {\n\t\tif (offs > 9)\n\t\t\treturn INTEL_PT_BAD_PACKET;\n\t\tif (len < offs)\n\t\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\t\tbyte = buf[offs++];\n\t\tpayload |= ((uint64_t)byte >> 1) << shift;\n\t}\n\n\tpacket->type = INTEL_PT_CYC;\n\tpacket->payload = payload;\n\treturn offs;\n}\n\nstatic int intel_pt_get_ip(enum intel_pt_pkt_type type, unsigned int byte,\n\t\t\t   const unsigned char *buf, size_t len,\n\t\t\t   struct intel_pt_pkt *packet)\n{\n\tint ip_len;\n\n\tpacket->count = byte >> 5;\n\n\tswitch (packet->count) {\n\tcase 0:\n\t\tip_len = 0;\n\t\tbreak;\n\tcase 1:\n\t\tif (len < 3)\n\t\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\t\tip_len = 2;\n\t\tpacket->payload = le16_to_cpu(*(uint16_t *)(buf + 1));\n\t\tbreak;\n\tcase 2:\n\t\tif (len < 5)\n\t\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\t\tip_len = 4;\n\t\tpacket->payload = le32_to_cpu(*(uint32_t *)(buf + 1));\n\t\tbreak;\n\tcase 3:\n\tcase 4:\n\t\tif (len < 7)\n\t\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\t\tip_len = 6;\n\t\tmemcpy_le64(&packet->payload, buf + 1, 6);\n\t\tbreak;\n\tcase 6:\n\t\tif (len < 9)\n\t\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\t\tip_len = 8;\n\t\tpacket->payload = le64_to_cpu(*(uint64_t *)(buf + 1));\n\t\tbreak;\n\tdefault:\n\t\treturn INTEL_PT_BAD_PACKET;\n\t}\n\n\tpacket->type = type;\n\n\treturn ip_len + 1;\n}\n\nstatic int intel_pt_get_mode(const unsigned char *buf, size_t len,\n\t\t\t     struct intel_pt_pkt *packet)\n{\n\tif (len < 2)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\n\tswitch (buf[1] >> 5) {\n\tcase 0:\n\t\tpacket->type = INTEL_PT_MODE_EXEC;\n\t\tpacket->count = buf[1];\n\t\tswitch (buf[1] & 3) {\n\t\tcase 0:\n\t\t\tpacket->payload = 16;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpacket->payload = 64;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpacket->payload = 32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn INTEL_PT_BAD_PACKET;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tpacket->type = INTEL_PT_MODE_TSX;\n\t\tif ((buf[1] & 3) == 3)\n\t\t\treturn INTEL_PT_BAD_PACKET;\n\t\tpacket->payload = buf[1] & 3;\n\t\tbreak;\n\tdefault:\n\t\treturn INTEL_PT_BAD_PACKET;\n\t}\n\n\treturn 2;\n}\n\nstatic int intel_pt_get_tsc(const unsigned char *buf, size_t len,\n\t\t\t    struct intel_pt_pkt *packet)\n{\n\tif (len < 8)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_TSC;\n\tmemcpy_le64(&packet->payload, buf + 1, 7);\n\treturn 8;\n}\n\nstatic int intel_pt_get_mtc(const unsigned char *buf, size_t len,\n\t\t\t    struct intel_pt_pkt *packet)\n{\n\tif (len < 2)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\tpacket->type = INTEL_PT_MTC;\n\tpacket->payload = buf[1];\n\treturn 2;\n}\n\nstatic int intel_pt_do_get_packet(const unsigned char *buf, size_t len,\n\t\t\t\t  struct intel_pt_pkt *packet,\n\t\t\t\t  enum intel_pt_pkt_ctx ctx)\n{\n\tunsigned int byte;\n\n\tmemset(packet, 0, sizeof(struct intel_pt_pkt));\n\n\tif (!len)\n\t\treturn INTEL_PT_NEED_MORE_BYTES;\n\n\tbyte = buf[0];\n\n\tswitch (ctx) {\n\tcase INTEL_PT_NO_CTX:\n\t\tbreak;\n\tcase INTEL_PT_BLK_4_CTX:\n\t\tif ((byte & 0x7) == 4)\n\t\t\treturn intel_pt_get_bip_4(buf, len, packet);\n\t\tbreak;\n\tcase INTEL_PT_BLK_8_CTX:\n\t\tif ((byte & 0x7) == 4)\n\t\t\treturn intel_pt_get_bip_8(buf, len, packet);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!(byte & BIT(0))) {\n\t\tif (byte == 0)\n\t\t\treturn intel_pt_get_pad(packet);\n\t\tif (byte == 2)\n\t\t\treturn intel_pt_get_ext(buf, len, packet);\n\t\treturn intel_pt_get_short_tnt(byte, packet);\n\t}\n\n\tif ((byte & 2))\n\t\treturn intel_pt_get_cyc(byte, buf, len, packet);\n\n\tswitch (byte & 0x1f) {\n\tcase 0x0D:\n\t\treturn intel_pt_get_ip(INTEL_PT_TIP, byte, buf, len, packet);\n\tcase 0x11:\n\t\treturn intel_pt_get_ip(INTEL_PT_TIP_PGE, byte, buf, len,\n\t\t\t\t       packet);\n\tcase 0x01:\n\t\treturn intel_pt_get_ip(INTEL_PT_TIP_PGD, byte, buf, len,\n\t\t\t\t       packet);\n\tcase 0x1D:\n\t\treturn intel_pt_get_ip(INTEL_PT_FUP, byte, buf, len, packet);\n\tcase 0x19:\n\t\tswitch (byte) {\n\t\tcase 0x99:\n\t\t\treturn intel_pt_get_mode(buf, len, packet);\n\t\tcase 0x19:\n\t\t\treturn intel_pt_get_tsc(buf, len, packet);\n\t\tcase 0x59:\n\t\t\treturn intel_pt_get_mtc(buf, len, packet);\n\t\tdefault:\n\t\t\treturn INTEL_PT_BAD_PACKET;\n\t\t}\n\tdefault:\n\t\treturn INTEL_PT_BAD_PACKET;\n\t}\n}\n\nvoid intel_pt_upd_pkt_ctx(const struct intel_pt_pkt *packet,\n\t\t\t  enum intel_pt_pkt_ctx *ctx)\n{\n\tswitch (packet->type) {\n\tcase INTEL_PT_BAD:\n\tcase INTEL_PT_PAD:\n\tcase INTEL_PT_TSC:\n\tcase INTEL_PT_TMA:\n\tcase INTEL_PT_MTC:\n\tcase INTEL_PT_FUP:\n\tcase INTEL_PT_CYC:\n\tcase INTEL_PT_CBR:\n\tcase INTEL_PT_MNT:\n\tcase INTEL_PT_EXSTOP:\n\tcase INTEL_PT_EXSTOP_IP:\n\tcase INTEL_PT_PWRE:\n\tcase INTEL_PT_PWRX:\n\tcase INTEL_PT_BIP:\n\t\tbreak;\n\tcase INTEL_PT_TNT:\n\tcase INTEL_PT_TIP:\n\tcase INTEL_PT_TIP_PGD:\n\tcase INTEL_PT_TIP_PGE:\n\tcase INTEL_PT_MODE_EXEC:\n\tcase INTEL_PT_MODE_TSX:\n\tcase INTEL_PT_PIP:\n\tcase INTEL_PT_OVF:\n\tcase INTEL_PT_VMCS:\n\tcase INTEL_PT_TRACESTOP:\n\tcase INTEL_PT_PSB:\n\tcase INTEL_PT_PSBEND:\n\tcase INTEL_PT_PTWRITE:\n\tcase INTEL_PT_PTWRITE_IP:\n\tcase INTEL_PT_MWAIT:\n\tcase INTEL_PT_BEP:\n\tcase INTEL_PT_BEP_IP:\n\tcase INTEL_PT_CFE:\n\tcase INTEL_PT_CFE_IP:\n\tcase INTEL_PT_EVD:\n\t\t*ctx = INTEL_PT_NO_CTX;\n\t\tbreak;\n\tcase INTEL_PT_BBP:\n\t\tif (packet->count)\n\t\t\t*ctx = INTEL_PT_BLK_4_CTX;\n\t\telse\n\t\t\t*ctx = INTEL_PT_BLK_8_CTX;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nint intel_pt_get_packet(const unsigned char *buf, size_t len,\n\t\t\tstruct intel_pt_pkt *packet, enum intel_pt_pkt_ctx *ctx)\n{\n\tint ret;\n\n\tret = intel_pt_do_get_packet(buf, len, packet, *ctx);\n\tif (ret > 0) {\n\t\twhile (ret < 8 && len > (size_t)ret && !buf[ret])\n\t\t\tret += 1;\n\t\tintel_pt_upd_pkt_ctx(packet, ctx);\n\t}\n\treturn ret;\n}\n\nint intel_pt_pkt_desc(const struct intel_pt_pkt *packet, char *buf,\n\t\t      size_t buf_len)\n{\n\tint ret, i, nr;\n\tunsigned long long payload = packet->payload;\n\tconst char *name = intel_pt_pkt_name(packet->type);\n\n\tswitch (packet->type) {\n\tcase INTEL_PT_BAD:\n\tcase INTEL_PT_PAD:\n\tcase INTEL_PT_PSB:\n\tcase INTEL_PT_PSBEND:\n\tcase INTEL_PT_TRACESTOP:\n\tcase INTEL_PT_OVF:\n\t\treturn snprintf(buf, buf_len, \"%s\", name);\n\tcase INTEL_PT_TNT: {\n\t\tsize_t blen = buf_len;\n\n\t\tret = snprintf(buf, blen, \"%s \", name);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbuf += ret;\n\t\tblen -= ret;\n\t\tfor (i = 0; i < packet->count; i++) {\n\t\t\tif (payload & BIT63)\n\t\t\t\tret = snprintf(buf, blen, \"T\");\n\t\t\telse\n\t\t\t\tret = snprintf(buf, blen, \"N\");\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbuf += ret;\n\t\t\tblen -= ret;\n\t\t\tpayload <<= 1;\n\t\t}\n\t\tret = snprintf(buf, blen, \" (%d)\", packet->count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tblen -= ret;\n\t\treturn buf_len - blen;\n\t}\n\tcase INTEL_PT_TIP_PGD:\n\tcase INTEL_PT_TIP_PGE:\n\tcase INTEL_PT_TIP:\n\tcase INTEL_PT_FUP:\n\t\tif (!(packet->count))\n\t\t\treturn snprintf(buf, buf_len, \"%s no ip\", name);\n\t\tfallthrough;\n\tcase INTEL_PT_CYC:\n\tcase INTEL_PT_VMCS:\n\tcase INTEL_PT_MTC:\n\tcase INTEL_PT_MNT:\n\tcase INTEL_PT_CBR:\n\tcase INTEL_PT_TSC:\n\t\treturn snprintf(buf, buf_len, \"%s 0x%llx\", name, payload);\n\tcase INTEL_PT_TMA:\n\t\treturn snprintf(buf, buf_len, \"%s CTC 0x%x FC 0x%x\", name,\n\t\t\t\t(unsigned)payload, packet->count);\n\tcase INTEL_PT_MODE_EXEC:\n\t\treturn snprintf(buf, buf_len, \"%s IF:%d %lld\",\n\t\t\t\tname, !!(packet->count & 4), payload);\n\tcase INTEL_PT_MODE_TSX:\n\t\treturn snprintf(buf, buf_len, \"%s TXAbort:%u InTX:%u\",\n\t\t\t\tname, (unsigned)(payload >> 1) & 1,\n\t\t\t\t(unsigned)payload & 1);\n\tcase INTEL_PT_PIP:\n\t\tnr = packet->payload & INTEL_PT_VMX_NR_FLAG ? 1 : 0;\n\t\tpayload &= ~INTEL_PT_VMX_NR_FLAG;\n\t\tret = snprintf(buf, buf_len, \"%s 0x%llx (NR=%d)\",\n\t\t\t       name, payload >> 1, nr);\n\t\treturn ret;\n\tcase INTEL_PT_PTWRITE:\n\t\treturn snprintf(buf, buf_len, \"%s 0x%llx IP:0\", name, payload);\n\tcase INTEL_PT_PTWRITE_IP:\n\t\treturn snprintf(buf, buf_len, \"%s 0x%llx IP:1\", name, payload);\n\tcase INTEL_PT_BEP:\n\tcase INTEL_PT_EXSTOP:\n\t\treturn snprintf(buf, buf_len, \"%s IP:0\", name);\n\tcase INTEL_PT_BEP_IP:\n\tcase INTEL_PT_EXSTOP_IP:\n\t\treturn snprintf(buf, buf_len, \"%s IP:1\", name);\n\tcase INTEL_PT_MWAIT:\n\t\treturn snprintf(buf, buf_len, \"%s 0x%llx Hints 0x%x Extensions 0x%x\",\n\t\t\t\tname, payload, (unsigned int)(payload & 0xff),\n\t\t\t\t(unsigned int)((payload >> 32) & 0x3));\n\tcase INTEL_PT_PWRE:\n\t\treturn snprintf(buf, buf_len, \"%s 0x%llx HW:%u CState:%u Sub-CState:%u\",\n\t\t\t\tname, payload, !!(payload & 0x80),\n\t\t\t\t(unsigned int)((payload >> 12) & 0xf),\n\t\t\t\t(unsigned int)((payload >> 8) & 0xf));\n\tcase INTEL_PT_PWRX:\n\t\treturn snprintf(buf, buf_len, \"%s 0x%llx Last CState:%u Deepest CState:%u Wake Reason 0x%x\",\n\t\t\t\tname, payload,\n\t\t\t\t(unsigned int)((payload >> 4) & 0xf),\n\t\t\t\t(unsigned int)(payload & 0xf),\n\t\t\t\t(unsigned int)((payload >> 8) & 0xf));\n\tcase INTEL_PT_BBP:\n\t\treturn snprintf(buf, buf_len, \"%s SZ %s-byte Type 0x%llx\",\n\t\t\t\tname, packet->count ? \"4\" : \"8\", payload);\n\tcase INTEL_PT_BIP:\n\t\treturn snprintf(buf, buf_len, \"%s ID 0x%02x Value 0x%llx\",\n\t\t\t\tname, packet->count, payload);\n\tcase INTEL_PT_CFE:\n\tcase INTEL_PT_CFE_IP:\n\t\treturn snprintf(buf, buf_len, \"%s IP:%d Type 0x%02x Vector 0x%llx\",\n\t\t\t\tname, packet->type == INTEL_PT_CFE_IP, packet->count, payload);\n\tcase INTEL_PT_EVD:\n\t\treturn snprintf(buf, buf_len, \"%s Type 0x%02x Payload 0x%llx\",\n\t\t\t\tname, packet->count, payload);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn snprintf(buf, buf_len, \"%s 0x%llx (%d)\",\n\t\t\tname, payload, packet->count);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}