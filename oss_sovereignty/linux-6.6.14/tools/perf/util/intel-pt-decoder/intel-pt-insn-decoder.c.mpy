{
  "module_name": "intel-pt-insn-decoder.c",
  "hash_id": "94a07baead5c0cac636258294cb4954aad558fa26ef6b0e702a5f0aaa761a024",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/intel-pt-decoder/intel-pt-insn-decoder.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <stdio.h>\n#include <string.h>\n#include <endian.h>\n#include <byteswap.h>\n#include \"../../../arch/x86/include/asm/insn.h\"\n\n#include \"../../../arch/x86/lib/inat.c\"\n#include \"../../../arch/x86/lib/insn.c\"\n\n#include \"event.h\"\n\n#include \"intel-pt-insn-decoder.h\"\n#include \"dump-insn.h\"\n#include \"util/sample.h\"\n\n#if INTEL_PT_INSN_BUF_SZ < MAX_INSN_SIZE || INTEL_PT_INSN_BUF_SZ > MAX_INSN\n#error Instruction buffer size too small\n#endif\n\n \nstatic void intel_pt_insn_decoder(struct insn *insn,\n\t\t\t\t  struct intel_pt_insn *intel_pt_insn)\n{\n\tenum intel_pt_insn_op op = INTEL_PT_OP_OTHER;\n\tenum intel_pt_insn_branch branch = INTEL_PT_BR_NO_BRANCH;\n\tint ext;\n\n\tintel_pt_insn->rel = 0;\n\tintel_pt_insn->emulated_ptwrite = false;\n\n\tif (insn_is_avx(insn)) {\n\t\tintel_pt_insn->op = INTEL_PT_OP_OTHER;\n\t\tintel_pt_insn->branch = INTEL_PT_BR_NO_BRANCH;\n\t\tintel_pt_insn->length = insn->length;\n\t\treturn;\n\t}\n\n\tswitch (insn->opcode.bytes[0]) {\n\tcase 0xf:\n\t\tswitch (insn->opcode.bytes[1]) {\n\t\tcase 0x01:\n\t\t\tswitch (insn->modrm.bytes[0]) {\n\t\t\tcase 0xc2:  \n\t\t\tcase 0xc3:  \n\t\t\t\top = INTEL_PT_OP_VMENTRY;\n\t\t\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\t\t\tbreak;\n\t\t\tcase 0xca:\n\t\t\t\tswitch (insn->prefixes.bytes[3]) {\n\t\t\t\tcase 0xf2:  \n\t\t\t\t\top = INTEL_PT_OP_ERETS;\n\t\t\t\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xf3:  \n\t\t\t\t\top = INTEL_PT_OP_ERETU;\n\t\t\t\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x05:  \n\t\tcase 0x34:  \n\t\t\top = INTEL_PT_OP_SYSCALL;\n\t\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\t\tbreak;\n\t\tcase 0x07:  \n\t\tcase 0x35:  \n\t\t\top = INTEL_PT_OP_SYSRET;\n\t\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\t\tbreak;\n\t\tcase 0x80 ... 0x8f:  \n\t\t\top = INTEL_PT_OP_JCC;\n\t\t\tbranch = INTEL_PT_BR_CONDITIONAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 0x70 ... 0x7f:  \n\t\top = INTEL_PT_OP_JCC;\n\t\tbranch = INTEL_PT_BR_CONDITIONAL;\n\t\tbreak;\n\tcase 0xc2:  \n\tcase 0xc3:  \n\tcase 0xca:  \n\tcase 0xcb:  \n\t\top = INTEL_PT_OP_RET;\n\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\tbreak;\n\tcase 0xcf:  \n\t\top = INTEL_PT_OP_IRET;\n\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\tbreak;\n\tcase 0xcc ... 0xce:  \n\t\top = INTEL_PT_OP_INT;\n\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\tbreak;\n\tcase 0xe8:  \n\t\top = INTEL_PT_OP_CALL;\n\t\tbranch = INTEL_PT_BR_UNCONDITIONAL;\n\t\tbreak;\n\tcase 0x9a:  \n\t\top = INTEL_PT_OP_CALL;\n\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\tbreak;\n\tcase 0xe0 ... 0xe2:  \n\t\top = INTEL_PT_OP_LOOP;\n\t\tbranch = INTEL_PT_BR_CONDITIONAL;\n\t\tbreak;\n\tcase 0xe3:  \n\t\top = INTEL_PT_OP_JCC;\n\t\tbranch = INTEL_PT_BR_CONDITIONAL;\n\t\tbreak;\n\tcase 0xe9:  \n\tcase 0xeb:  \n\t\top = INTEL_PT_OP_JMP;\n\t\tbranch = INTEL_PT_BR_UNCONDITIONAL;\n\t\tbreak;\n\tcase 0xea:  \n\t\top = INTEL_PT_OP_JMP;\n\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\tbreak;\n\tcase 0xff:  \n\t\text = (insn->modrm.bytes[0] >> 3) & 0x7;\n\t\tswitch (ext) {\n\t\tcase 2:  \n\t\tcase 3:  \n\t\t\top = INTEL_PT_OP_CALL;\n\t\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\top = INTEL_PT_OP_JMP;\n\t\t\tbranch = INTEL_PT_BR_INDIRECT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tintel_pt_insn->op = op;\n\tintel_pt_insn->branch = branch;\n\tintel_pt_insn->length = insn->length;\n\n\tif (branch == INTEL_PT_BR_CONDITIONAL ||\n\t    branch == INTEL_PT_BR_UNCONDITIONAL) {\n#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\t\tswitch (insn->immediate.nbytes) {\n\t\tcase 1:\n\t\t\tintel_pt_insn->rel = insn->immediate.value;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tintel_pt_insn->rel =\n\t\t\t\t\tbswap_16((short)insn->immediate.value);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tintel_pt_insn->rel = bswap_32(insn->immediate.value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tintel_pt_insn->rel = 0;\n\t\t\tbreak;\n\t\t}\n#else\n\t\tintel_pt_insn->rel = insn->immediate.value;\n#endif\n\t}\n}\n\nint intel_pt_get_insn(const unsigned char *buf, size_t len, int x86_64,\n\t\t      struct intel_pt_insn *intel_pt_insn)\n{\n\tstruct insn insn;\n\tint ret;\n\n\tret = insn_decode(&insn, buf, len,\n\t\t\t  x86_64 ? INSN_MODE_64 : INSN_MODE_32);\n\tif (ret < 0 || insn.length > len)\n\t\treturn -1;\n\n\tintel_pt_insn_decoder(&insn, intel_pt_insn);\n\tif (insn.length < INTEL_PT_INSN_BUF_SZ)\n\t\tmemcpy(intel_pt_insn->buf, buf, insn.length);\n\telse\n\t\tmemcpy(intel_pt_insn->buf, buf, INTEL_PT_INSN_BUF_SZ);\n\treturn 0;\n}\n\nint arch_is_branch(const unsigned char *buf, size_t len, int x86_64)\n{\n\tstruct intel_pt_insn in;\n\tif (intel_pt_get_insn(buf, len, x86_64, &in) < 0)\n\t\treturn -1;\n\treturn in.branch != INTEL_PT_BR_NO_BRANCH;\n}\n\nconst char *dump_insn(struct perf_insn *x, uint64_t ip __maybe_unused,\n\t\t      u8 *inbuf, int inlen, int *lenp)\n{\n\tstruct insn insn;\n\tint n, i, ret;\n\tint left;\n\n\tret = insn_decode(&insn, inbuf, inlen,\n\t\t\t  x->is64bit ? INSN_MODE_64 : INSN_MODE_32);\n\n\tif (ret < 0 || insn.length > inlen)\n\t\treturn \"<bad>\";\n\tif (lenp)\n\t\t*lenp = insn.length;\n\tleft = sizeof(x->out);\n\tn = snprintf(x->out, left, \"insn: \");\n\tleft -= n;\n\tfor (i = 0; i < insn.length; i++) {\n\t\tn += snprintf(x->out + n, left, \"%02x \", inbuf[i]);\n\t\tleft -= n;\n\t}\n\treturn x->out;\n}\n\nconst char *branch_name[] = {\n\t[INTEL_PT_OP_OTHER]\t= \"Other\",\n\t[INTEL_PT_OP_CALL]\t= \"Call\",\n\t[INTEL_PT_OP_RET]\t= \"Ret\",\n\t[INTEL_PT_OP_JCC]\t= \"Jcc\",\n\t[INTEL_PT_OP_JMP]\t= \"Jmp\",\n\t[INTEL_PT_OP_LOOP]\t= \"Loop\",\n\t[INTEL_PT_OP_IRET]\t= \"IRet\",\n\t[INTEL_PT_OP_INT]\t= \"Int\",\n\t[INTEL_PT_OP_SYSCALL]\t= \"Syscall\",\n\t[INTEL_PT_OP_SYSRET]\t= \"Sysret\",\n\t[INTEL_PT_OP_VMENTRY]\t= \"VMentry\",\n\t[INTEL_PT_OP_ERETS]\t= \"Erets\",\n\t[INTEL_PT_OP_ERETU]\t= \"Eretu\",\n};\n\nconst char *intel_pt_insn_name(enum intel_pt_insn_op op)\n{\n\treturn branch_name[op];\n}\n\nint intel_pt_insn_desc(const struct intel_pt_insn *intel_pt_insn, char *buf,\n\t\t       size_t buf_len)\n{\n\tswitch (intel_pt_insn->branch) {\n\tcase INTEL_PT_BR_CONDITIONAL:\n\tcase INTEL_PT_BR_UNCONDITIONAL:\n\t\treturn snprintf(buf, buf_len, \"%s %s%d\",\n\t\t\t\tintel_pt_insn_name(intel_pt_insn->op),\n\t\t\t\tintel_pt_insn->rel > 0 ? \"+\" : \"\",\n\t\t\t\tintel_pt_insn->rel);\n\tcase INTEL_PT_BR_NO_BRANCH:\n\tcase INTEL_PT_BR_INDIRECT:\n\t\treturn snprintf(buf, buf_len, \"%s\",\n\t\t\t\tintel_pt_insn_name(intel_pt_insn->op));\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint intel_pt_insn_type(enum intel_pt_insn_op op)\n{\n\tswitch (op) {\n\tcase INTEL_PT_OP_OTHER:\n\t\treturn 0;\n\tcase INTEL_PT_OP_CALL:\n\t\treturn PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL;\n\tcase INTEL_PT_OP_RET:\n\t\treturn PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_RETURN;\n\tcase INTEL_PT_OP_JCC:\n\t\treturn PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CONDITIONAL;\n\tcase INTEL_PT_OP_JMP:\n\t\treturn PERF_IP_FLAG_BRANCH;\n\tcase INTEL_PT_OP_LOOP:\n\t\treturn PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CONDITIONAL;\n\tcase INTEL_PT_OP_IRET:\n\tcase INTEL_PT_OP_ERETS:\n\tcase INTEL_PT_OP_ERETU:\n\t\treturn PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_RETURN |\n\t\t       PERF_IP_FLAG_INTERRUPT;\n\tcase INTEL_PT_OP_INT:\n\t\treturn PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL |\n\t\t       PERF_IP_FLAG_INTERRUPT;\n\tcase INTEL_PT_OP_SYSCALL:\n\t\treturn PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL |\n\t\t       PERF_IP_FLAG_SYSCALLRET;\n\tcase INTEL_PT_OP_SYSRET:\n\t\treturn PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_RETURN |\n\t\t       PERF_IP_FLAG_SYSCALLRET;\n\tcase INTEL_PT_OP_VMENTRY:\n\t\treturn PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL |\n\t\t       PERF_IP_FLAG_VMENTRY;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}