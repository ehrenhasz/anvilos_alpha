{
  "module_name": "hashmap.c",
  "hash_id": "5e06a018719d724415a71a3fb8197c18e834150dae8455d6a92c177e615fbce9",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/hashmap.c",
  "human_readable_source": "\n\n \n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <linux/err.h>\n#include \"hashmap.h\"\n\n \n#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64\n\n \n#pragma GCC poison reallocarray\n\n \n#define HASHMAP_MIN_CAP_BITS 2\n\nstatic void hashmap_add_entry(struct hashmap_entry **pprev,\n\t\t\t      struct hashmap_entry *entry)\n{\n\tentry->next = *pprev;\n\t*pprev = entry;\n}\n\nstatic void hashmap_del_entry(struct hashmap_entry **pprev,\n\t\t\t      struct hashmap_entry *entry)\n{\n\t*pprev = entry->next;\n\tentry->next = NULL;\n}\n\nvoid hashmap__init(struct hashmap *map, hashmap_hash_fn hash_fn,\n\t\t   hashmap_equal_fn equal_fn, void *ctx)\n{\n\tmap->hash_fn = hash_fn;\n\tmap->equal_fn = equal_fn;\n\tmap->ctx = ctx;\n\n\tmap->buckets = NULL;\n\tmap->cap = 0;\n\tmap->cap_bits = 0;\n\tmap->sz = 0;\n}\n\nstruct hashmap *hashmap__new(hashmap_hash_fn hash_fn,\n\t\t\t     hashmap_equal_fn equal_fn,\n\t\t\t     void *ctx)\n{\n\tstruct hashmap *map = malloc(sizeof(struct hashmap));\n\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\thashmap__init(map, hash_fn, equal_fn, ctx);\n\treturn map;\n}\n\nvoid hashmap__clear(struct hashmap *map)\n{\n\tstruct hashmap_entry *cur, *tmp;\n\tsize_t bkt;\n\n\thashmap__for_each_entry_safe(map, cur, tmp, bkt) {\n\t\tfree(cur);\n\t}\n\tfree(map->buckets);\n\tmap->buckets = NULL;\n\tmap->cap = map->cap_bits = map->sz = 0;\n}\n\nvoid hashmap__free(struct hashmap *map)\n{\n\tif (IS_ERR_OR_NULL(map))\n\t\treturn;\n\n\thashmap__clear(map);\n\tfree(map);\n}\n\nsize_t hashmap__size(const struct hashmap *map)\n{\n\treturn map->sz;\n}\n\nsize_t hashmap__capacity(const struct hashmap *map)\n{\n\treturn map->cap;\n}\n\nstatic bool hashmap_needs_to_grow(struct hashmap *map)\n{\n\t \n\treturn (map->cap == 0) || ((map->sz + 1) * 4 / 3 > map->cap);\n}\n\nstatic int hashmap_grow(struct hashmap *map)\n{\n\tstruct hashmap_entry **new_buckets;\n\tstruct hashmap_entry *cur, *tmp;\n\tsize_t new_cap_bits, new_cap;\n\tsize_t h, bkt;\n\n\tnew_cap_bits = map->cap_bits + 1;\n\tif (new_cap_bits < HASHMAP_MIN_CAP_BITS)\n\t\tnew_cap_bits = HASHMAP_MIN_CAP_BITS;\n\n\tnew_cap = 1UL << new_cap_bits;\n\tnew_buckets = calloc(new_cap, sizeof(new_buckets[0]));\n\tif (!new_buckets)\n\t\treturn -ENOMEM;\n\n\thashmap__for_each_entry_safe(map, cur, tmp, bkt) {\n\t\th = hash_bits(map->hash_fn(cur->key, map->ctx), new_cap_bits);\n\t\thashmap_add_entry(&new_buckets[h], cur);\n\t}\n\n\tmap->cap = new_cap;\n\tmap->cap_bits = new_cap_bits;\n\tfree(map->buckets);\n\tmap->buckets = new_buckets;\n\n\treturn 0;\n}\n\nstatic bool hashmap_find_entry(const struct hashmap *map,\n\t\t\t       const long key, size_t hash,\n\t\t\t       struct hashmap_entry ***pprev,\n\t\t\t       struct hashmap_entry **entry)\n{\n\tstruct hashmap_entry *cur, **prev_ptr;\n\n\tif (!map->buckets)\n\t\treturn false;\n\n\tfor (prev_ptr = &map->buckets[hash], cur = *prev_ptr;\n\t     cur;\n\t     prev_ptr = &cur->next, cur = cur->next) {\n\t\tif (map->equal_fn(cur->key, key, map->ctx)) {\n\t\t\tif (pprev)\n\t\t\t\t*pprev = prev_ptr;\n\t\t\t*entry = cur;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint hashmap_insert(struct hashmap *map, long key, long value,\n\t\t   enum hashmap_insert_strategy strategy,\n\t\t   long *old_key, long *old_value)\n{\n\tstruct hashmap_entry *entry;\n\tsize_t h;\n\tint err;\n\n\tif (old_key)\n\t\t*old_key = 0;\n\tif (old_value)\n\t\t*old_value = 0;\n\n\th = hash_bits(map->hash_fn(key, map->ctx), map->cap_bits);\n\tif (strategy != HASHMAP_APPEND &&\n\t    hashmap_find_entry(map, key, h, NULL, &entry)) {\n\t\tif (old_key)\n\t\t\t*old_key = entry->key;\n\t\tif (old_value)\n\t\t\t*old_value = entry->value;\n\n\t\tif (strategy == HASHMAP_SET || strategy == HASHMAP_UPDATE) {\n\t\t\tentry->key = key;\n\t\t\tentry->value = value;\n\t\t\treturn 0;\n\t\t} else if (strategy == HASHMAP_ADD) {\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tif (strategy == HASHMAP_UPDATE)\n\t\treturn -ENOENT;\n\n\tif (hashmap_needs_to_grow(map)) {\n\t\terr = hashmap_grow(map);\n\t\tif (err)\n\t\t\treturn err;\n\t\th = hash_bits(map->hash_fn(key, map->ctx), map->cap_bits);\n\t}\n\n\tentry = malloc(sizeof(struct hashmap_entry));\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->key = key;\n\tentry->value = value;\n\thashmap_add_entry(&map->buckets[h], entry);\n\tmap->sz++;\n\n\treturn 0;\n}\n\nbool hashmap_find(const struct hashmap *map, long key, long *value)\n{\n\tstruct hashmap_entry *entry;\n\tsize_t h;\n\n\th = hash_bits(map->hash_fn(key, map->ctx), map->cap_bits);\n\tif (!hashmap_find_entry(map, key, h, NULL, &entry))\n\t\treturn false;\n\n\tif (value)\n\t\t*value = entry->value;\n\treturn true;\n}\n\nbool hashmap_delete(struct hashmap *map, long key,\n\t\t    long *old_key, long *old_value)\n{\n\tstruct hashmap_entry **pprev, *entry;\n\tsize_t h;\n\n\th = hash_bits(map->hash_fn(key, map->ctx), map->cap_bits);\n\tif (!hashmap_find_entry(map, key, h, &pprev, &entry))\n\t\treturn false;\n\n\tif (old_key)\n\t\t*old_key = entry->key;\n\tif (old_value)\n\t\t*old_value = entry->value;\n\n\thashmap_del_entry(pprev, entry);\n\tfree(entry);\n\tmap->sz--;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}