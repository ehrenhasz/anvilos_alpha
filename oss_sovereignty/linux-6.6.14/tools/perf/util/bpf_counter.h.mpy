{
  "module_name": "bpf_counter.h",
  "hash_id": "d28cd896b750c66a19710634c0541aabec90b9ef1ed33003a951ead80526b804",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/bpf_counter.h",
  "human_readable_source": " \n#ifndef __PERF_BPF_COUNTER_H\n#define __PERF_BPF_COUNTER_H 1\n\n#include <linux/list.h>\n#include <sys/resource.h>\n\n#ifdef HAVE_LIBBPF_SUPPORT\n#include <bpf/bpf.h>\n#include <bpf/btf.h>\n#include <bpf/libbpf.h>\n#endif\n\nstruct evsel;\nstruct target;\nstruct bpf_counter;\n\ntypedef int (*bpf_counter_evsel_op)(struct evsel *evsel);\ntypedef int (*bpf_counter_evsel_target_op)(struct evsel *evsel,\n\t\t\t\t\t   struct target *target);\ntypedef int (*bpf_counter_evsel_install_pe_op)(struct evsel *evsel,\n\t\t\t\t\t       int cpu_map_idx,\n\t\t\t\t\t       int fd);\n\nstruct bpf_counter_ops {\n\tbpf_counter_evsel_target_op load;\n\tbpf_counter_evsel_op enable;\n\tbpf_counter_evsel_op disable;\n\tbpf_counter_evsel_op read;\n\tbpf_counter_evsel_op destroy;\n\tbpf_counter_evsel_install_pe_op install_pe;\n};\n\nstruct bpf_counter {\n\tvoid *skel;\n\tstruct list_head list;\n};\n\n#ifdef HAVE_BPF_SKEL\n\nint bpf_counter__load(struct evsel *evsel, struct target *target);\nint bpf_counter__enable(struct evsel *evsel);\nint bpf_counter__disable(struct evsel *evsel);\nint bpf_counter__read(struct evsel *evsel);\nvoid bpf_counter__destroy(struct evsel *evsel);\nint bpf_counter__install_pe(struct evsel *evsel, int cpu_map_idx, int fd);\n\n#else  \n\n#include <linux/err.h>\n\nstatic inline int bpf_counter__load(struct evsel *evsel __maybe_unused,\n\t\t\t\t    struct target *target __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline int bpf_counter__enable(struct evsel *evsel __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline int bpf_counter__disable(struct evsel *evsel __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline int bpf_counter__read(struct evsel *evsel __maybe_unused)\n{\n\treturn -EAGAIN;\n}\n\nstatic inline void bpf_counter__destroy(struct evsel *evsel __maybe_unused)\n{\n}\n\nstatic inline int bpf_counter__install_pe(struct evsel *evsel __maybe_unused,\n\t\t\t\t\t  int cpu __maybe_unused,\n\t\t\t\t\t  int fd __maybe_unused)\n{\n\treturn 0;\n}\n\n#endif  \n\nstatic inline void set_max_rlimit(void)\n{\n\tstruct rlimit rinf = { RLIM_INFINITY, RLIM_INFINITY };\n\n\tsetrlimit(RLIMIT_MEMLOCK, &rinf);\n}\n\n#ifdef HAVE_BPF_SKEL\n\nstatic inline __u32 bpf_link_get_id(int fd)\n{\n\tstruct bpf_link_info link_info = { .id = 0, };\n\t__u32 link_info_len = sizeof(link_info);\n\n\tbpf_obj_get_info_by_fd(fd, &link_info, &link_info_len);\n\treturn link_info.id;\n}\n\nstatic inline __u32 bpf_link_get_prog_id(int fd)\n{\n\tstruct bpf_link_info link_info = { .id = 0, };\n\t__u32 link_info_len = sizeof(link_info);\n\n\tbpf_obj_get_info_by_fd(fd, &link_info, &link_info_len);\n\treturn link_info.prog_id;\n}\n\nstatic inline __u32 bpf_map_get_id(int fd)\n{\n\tstruct bpf_map_info map_info = { .id = 0, };\n\t__u32 map_info_len = sizeof(map_info);\n\n\tbpf_obj_get_info_by_fd(fd, &map_info, &map_info_len);\n\treturn map_info.id;\n}\n\n \nstatic inline int bperf_trigger_reading(int prog_fd, int cpu)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_test_run_opts, opts,\n\t\t\t    .ctx_in = NULL,\n\t\t\t    .ctx_size_in = 0,\n\t\t\t    .flags = BPF_F_TEST_RUN_ON_CPU,\n\t\t\t    .cpu = cpu,\n\t\t\t    .retval = 0,\n\t\t);\n\n\treturn bpf_prog_test_run_opts(prog_fd, &opts);\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}