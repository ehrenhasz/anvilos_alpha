{
  "module_name": "bpf_kwork.c",
  "hash_id": "9ac476a8cc0e845bfbc4a72669307363a1355f0c0864b8cd3a2cd052ba8199f1",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/bpf_kwork.c",
  "human_readable_source": "\n \n\n#include <time.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include <linux/time64.h>\n\n#include \"util/debug.h\"\n#include \"util/evsel.h\"\n#include \"util/kwork.h\"\n\n#include <bpf/bpf.h>\n#include <perf/cpumap.h>\n\n#include \"util/bpf_skel/kwork_trace.skel.h\"\n\n \n#define MAX_KWORKNAME 128\n\nstruct work_key {\n\tu32 type;\n\tu32 cpu;\n\tu64 id;\n};\n\nstruct report_data {\n\tu64 nr;\n\tu64 total_time;\n\tu64 max_time;\n\tu64 max_time_start;\n\tu64 max_time_end;\n};\n\nstruct kwork_class_bpf {\n\tstruct kwork_class *class;\n\n\tvoid (*load_prepare)(struct perf_kwork *kwork);\n\tint  (*get_work_name)(struct work_key *key, char **ret_name);\n};\n\nstatic struct kwork_trace_bpf *skel;\n\nstatic struct timespec ts_start;\nstatic struct timespec ts_end;\n\nvoid perf_kwork__trace_start(void)\n{\n\tclock_gettime(CLOCK_MONOTONIC, &ts_start);\n\tskel->bss->enabled = 1;\n}\n\nvoid perf_kwork__trace_finish(void)\n{\n\tclock_gettime(CLOCK_MONOTONIC, &ts_end);\n\tskel->bss->enabled = 0;\n}\n\nstatic int get_work_name_from_map(struct work_key *key, char **ret_name)\n{\n\tchar name[MAX_KWORKNAME] = { 0 };\n\tint fd = bpf_map__fd(skel->maps.perf_kwork_names);\n\n\t*ret_name = NULL;\n\n\tif (fd < 0) {\n\t\tpr_debug(\"Invalid names map fd\\n\");\n\t\treturn 0;\n\t}\n\n\tif ((bpf_map_lookup_elem(fd, key, name) == 0) && (strlen(name) != 0)) {\n\t\t*ret_name = strdup(name);\n\t\tif (*ret_name == NULL) {\n\t\t\tpr_err(\"Failed to copy work name\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void irq_load_prepare(struct perf_kwork *kwork)\n{\n\tif (kwork->report == KWORK_REPORT_RUNTIME) {\n\t\tbpf_program__set_autoload(skel->progs.report_irq_handler_entry, true);\n\t\tbpf_program__set_autoload(skel->progs.report_irq_handler_exit, true);\n\t}\n}\n\nstatic struct kwork_class_bpf kwork_irq_bpf = {\n\t.load_prepare  = irq_load_prepare,\n\t.get_work_name = get_work_name_from_map,\n};\n\nstatic void softirq_load_prepare(struct perf_kwork *kwork)\n{\n\tif (kwork->report == KWORK_REPORT_RUNTIME) {\n\t\tbpf_program__set_autoload(skel->progs.report_softirq_entry, true);\n\t\tbpf_program__set_autoload(skel->progs.report_softirq_exit, true);\n\t} else if (kwork->report == KWORK_REPORT_LATENCY) {\n\t\tbpf_program__set_autoload(skel->progs.latency_softirq_raise, true);\n\t\tbpf_program__set_autoload(skel->progs.latency_softirq_entry, true);\n\t}\n}\n\nstatic struct kwork_class_bpf kwork_softirq_bpf = {\n\t.load_prepare  = softirq_load_prepare,\n\t.get_work_name = get_work_name_from_map,\n};\n\nstatic void workqueue_load_prepare(struct perf_kwork *kwork)\n{\n\tif (kwork->report == KWORK_REPORT_RUNTIME) {\n\t\tbpf_program__set_autoload(skel->progs.report_workqueue_execute_start, true);\n\t\tbpf_program__set_autoload(skel->progs.report_workqueue_execute_end, true);\n\t} else if (kwork->report == KWORK_REPORT_LATENCY) {\n\t\tbpf_program__set_autoload(skel->progs.latency_workqueue_activate_work, true);\n\t\tbpf_program__set_autoload(skel->progs.latency_workqueue_execute_start, true);\n\t}\n}\n\nstatic struct kwork_class_bpf kwork_workqueue_bpf = {\n\t.load_prepare  = workqueue_load_prepare,\n\t.get_work_name = get_work_name_from_map,\n};\n\nstatic struct kwork_class_bpf *\nkwork_class_bpf_supported_list[KWORK_CLASS_MAX] = {\n\t[KWORK_CLASS_IRQ]       = &kwork_irq_bpf,\n\t[KWORK_CLASS_SOFTIRQ]   = &kwork_softirq_bpf,\n\t[KWORK_CLASS_WORKQUEUE] = &kwork_workqueue_bpf,\n};\n\nstatic bool valid_kwork_class_type(enum kwork_class_type type)\n{\n\treturn type >= 0 && type < KWORK_CLASS_MAX ? true : false;\n}\n\nstatic int setup_filters(struct perf_kwork *kwork)\n{\n\tu8 val = 1;\n\tint i, nr_cpus, key, fd;\n\tstruct perf_cpu_map *map;\n\n\tif (kwork->cpu_list != NULL) {\n\t\tfd = bpf_map__fd(skel->maps.perf_kwork_cpu_filter);\n\t\tif (fd < 0) {\n\t\t\tpr_debug(\"Invalid cpu filter fd\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmap = perf_cpu_map__new(kwork->cpu_list);\n\t\tif (map == NULL) {\n\t\t\tpr_debug(\"Invalid cpu_list\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tnr_cpus = libbpf_num_possible_cpus();\n\t\tfor (i = 0; i < perf_cpu_map__nr(map); i++) {\n\t\t\tstruct perf_cpu cpu = perf_cpu_map__cpu(map, i);\n\n\t\t\tif (cpu.cpu >= nr_cpus) {\n\t\t\t\tperf_cpu_map__put(map);\n\t\t\t\tpr_err(\"Requested cpu %d too large\\n\", cpu.cpu);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbpf_map_update_elem(fd, &cpu.cpu, &val, BPF_ANY);\n\t\t}\n\t\tperf_cpu_map__put(map);\n\n\t\tskel->bss->has_cpu_filter = 1;\n\t}\n\n\tif (kwork->profile_name != NULL) {\n\t\tif (strlen(kwork->profile_name) >= MAX_KWORKNAME) {\n\t\t\tpr_err(\"Requested name filter %s too large, limit to %d\\n\",\n\t\t\t       kwork->profile_name, MAX_KWORKNAME - 1);\n\t\t\treturn -1;\n\t\t}\n\n\t\tfd = bpf_map__fd(skel->maps.perf_kwork_name_filter);\n\t\tif (fd < 0) {\n\t\t\tpr_debug(\"Invalid name filter fd\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tkey = 0;\n\t\tbpf_map_update_elem(fd, &key, kwork->profile_name, BPF_ANY);\n\n\t\tskel->bss->has_name_filter = 1;\n\t}\n\n\treturn 0;\n}\n\nint perf_kwork__trace_prepare_bpf(struct perf_kwork *kwork)\n{\n\tstruct bpf_program *prog;\n\tstruct kwork_class *class;\n\tstruct kwork_class_bpf *class_bpf;\n\tenum kwork_class_type type;\n\n\tskel = kwork_trace_bpf__open();\n\tif (!skel) {\n\t\tpr_debug(\"Failed to open kwork trace skeleton\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tbpf_object__for_each_program(prog, skel->obj)\n\t\tbpf_program__set_autoload(prog, false);\n\n\tlist_for_each_entry(class, &kwork->class_list, list) {\n\t\ttype = class->type;\n\t\tif (!valid_kwork_class_type(type) ||\n\t\t    (kwork_class_bpf_supported_list[type] == NULL)) {\n\t\t\tpr_err(\"Unsupported bpf trace class %s\\n\", class->name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tclass_bpf = kwork_class_bpf_supported_list[type];\n\t\tclass_bpf->class = class;\n\n\t\tif (class_bpf->load_prepare != NULL)\n\t\t\tclass_bpf->load_prepare(kwork);\n\t}\n\n\tif (kwork_trace_bpf__load(skel)) {\n\t\tpr_debug(\"Failed to load kwork trace skeleton\\n\");\n\t\tgoto out;\n\t}\n\n\tif (setup_filters(kwork))\n\t\tgoto out;\n\n\tif (kwork_trace_bpf__attach(skel)) {\n\t\tpr_debug(\"Failed to attach kwork trace skeleton\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tkwork_trace_bpf__destroy(skel);\n\treturn -1;\n}\n\nstatic int add_work(struct perf_kwork *kwork,\n\t\t    struct work_key *key,\n\t\t    struct report_data *data)\n{\n\tstruct kwork_work *work;\n\tstruct kwork_class_bpf *bpf_trace;\n\tstruct kwork_work tmp = {\n\t\t.id = key->id,\n\t\t.name = NULL,\n\t\t.cpu = key->cpu,\n\t};\n\tenum kwork_class_type type = key->type;\n\n\tif (!valid_kwork_class_type(type)) {\n\t\tpr_debug(\"Invalid class type %d to add work\\n\", type);\n\t\treturn -1;\n\t}\n\n\tbpf_trace = kwork_class_bpf_supported_list[type];\n\ttmp.class = bpf_trace->class;\n\n\tif ((bpf_trace->get_work_name != NULL) &&\n\t    (bpf_trace->get_work_name(key, &tmp.name)))\n\t\treturn -1;\n\n\twork = perf_kwork_add_work(kwork, tmp.class, &tmp);\n\tif (work == NULL)\n\t\treturn -1;\n\n\tif (kwork->report == KWORK_REPORT_RUNTIME) {\n\t\twork->nr_atoms = data->nr;\n\t\twork->total_runtime = data->total_time;\n\t\twork->max_runtime = data->max_time;\n\t\twork->max_runtime_start = data->max_time_start;\n\t\twork->max_runtime_end = data->max_time_end;\n\t} else if (kwork->report == KWORK_REPORT_LATENCY) {\n\t\twork->nr_atoms = data->nr;\n\t\twork->total_latency = data->total_time;\n\t\twork->max_latency = data->max_time;\n\t\twork->max_latency_start = data->max_time_start;\n\t\twork->max_latency_end = data->max_time_end;\n\t} else {\n\t\tpr_debug(\"Invalid bpf report type %d\\n\", kwork->report);\n\t\treturn -1;\n\t}\n\n\tkwork->timestart = (u64)ts_start.tv_sec * NSEC_PER_SEC + ts_start.tv_nsec;\n\tkwork->timeend = (u64)ts_end.tv_sec * NSEC_PER_SEC + ts_end.tv_nsec;\n\n\treturn 0;\n}\n\nint perf_kwork__report_read_bpf(struct perf_kwork *kwork)\n{\n\tstruct report_data data;\n\tstruct work_key key = {\n\t\t.type = 0,\n\t\t.cpu  = 0,\n\t\t.id   = 0,\n\t};\n\tstruct work_key prev = {\n\t\t.type = 0,\n\t\t.cpu  = 0,\n\t\t.id   = 0,\n\t};\n\tint fd = bpf_map__fd(skel->maps.perf_kwork_report);\n\n\tif (fd < 0) {\n\t\tpr_debug(\"Invalid report fd\\n\");\n\t\treturn -1;\n\t}\n\n\twhile (!bpf_map_get_next_key(fd, &prev, &key)) {\n\t\tif ((bpf_map_lookup_elem(fd, &key, &data)) != 0) {\n\t\t\tpr_debug(\"Failed to lookup report elem\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((data.nr != 0) && (add_work(kwork, &key, &data) != 0))\n\t\t\treturn -1;\n\n\t\tprev = key;\n\t}\n\treturn 0;\n}\n\nvoid perf_kwork__report_cleanup_bpf(void)\n{\n\tkwork_trace_bpf__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}