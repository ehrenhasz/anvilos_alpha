{
  "module_name": "intel-pt.c",
  "hash_id": "bab8a702628e68e91ae0515d952fa173d2a99ce6add138e5c4dd6ea558572168",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/intel-pt.c",
  "human_readable_source": "\n \n\n#include <inttypes.h>\n#include <linux/perf_event.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <errno.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/zalloc.h>\n\n#include \"session.h\"\n#include \"machine.h\"\n#include \"memswap.h\"\n#include \"sort.h\"\n#include \"tool.h\"\n#include \"event.h\"\n#include \"evlist.h\"\n#include \"evsel.h\"\n#include \"map.h\"\n#include \"color.h\"\n#include \"thread.h\"\n#include \"thread-stack.h\"\n#include \"symbol.h\"\n#include \"callchain.h\"\n#include \"dso.h\"\n#include \"debug.h\"\n#include \"auxtrace.h\"\n#include \"tsc.h\"\n#include \"intel-pt.h\"\n#include \"config.h\"\n#include \"util/perf_api_probe.h\"\n#include \"util/synthetic-events.h\"\n#include \"time-utils.h\"\n\n#include \"../arch/x86/include/uapi/asm/perf_regs.h\"\n\n#include \"intel-pt-decoder/intel-pt-log.h\"\n#include \"intel-pt-decoder/intel-pt-decoder.h\"\n#include \"intel-pt-decoder/intel-pt-insn-decoder.h\"\n#include \"intel-pt-decoder/intel-pt-pkt-decoder.h\"\n\n#define MAX_TIMESTAMP (~0ULL)\n\n#define INTEL_PT_CFG_PASS_THRU\tBIT_ULL(0)\n#define INTEL_PT_CFG_PWR_EVT_EN\tBIT_ULL(4)\n#define INTEL_PT_CFG_BRANCH_EN\tBIT_ULL(13)\n#define INTEL_PT_CFG_EVT_EN\tBIT_ULL(31)\n#define INTEL_PT_CFG_TNT_DIS\tBIT_ULL(55)\n\nstruct range {\n\tu64 start;\n\tu64 end;\n};\n\nstruct intel_pt {\n\tstruct auxtrace auxtrace;\n\tstruct auxtrace_queues queues;\n\tstruct auxtrace_heap heap;\n\tu32 auxtrace_type;\n\tstruct perf_session *session;\n\tstruct machine *machine;\n\tstruct evsel *switch_evsel;\n\tstruct thread *unknown_thread;\n\tbool timeless_decoding;\n\tbool sampling_mode;\n\tbool snapshot_mode;\n\tbool per_cpu_mmaps;\n\tbool have_tsc;\n\tbool data_queued;\n\tbool est_tsc;\n\tbool sync_switch;\n\tbool sync_switch_not_supported;\n\tbool mispred_all;\n\tbool use_thread_stack;\n\tbool callstack;\n\tbool cap_event_trace;\n\tbool have_guest_sideband;\n\tunsigned int br_stack_sz;\n\tunsigned int br_stack_sz_plus;\n\tint have_sched_switch;\n\tu32 pmu_type;\n\tu64 kernel_start;\n\tu64 switch_ip;\n\tu64 ptss_ip;\n\tu64 first_timestamp;\n\n\tstruct perf_tsc_conversion tc;\n\tbool cap_user_time_zero;\n\n\tstruct itrace_synth_opts synth_opts;\n\n\tbool sample_instructions;\n\tu64 instructions_sample_type;\n\tu64 instructions_id;\n\n\tbool sample_cycles;\n\tu64 cycles_sample_type;\n\tu64 cycles_id;\n\n\tbool sample_branches;\n\tu32 branches_filter;\n\tu64 branches_sample_type;\n\tu64 branches_id;\n\n\tbool sample_transactions;\n\tu64 transactions_sample_type;\n\tu64 transactions_id;\n\n\tbool sample_ptwrites;\n\tu64 ptwrites_sample_type;\n\tu64 ptwrites_id;\n\n\tbool sample_pwr_events;\n\tu64 pwr_events_sample_type;\n\tu64 mwait_id;\n\tu64 pwre_id;\n\tu64 exstop_id;\n\tu64 pwrx_id;\n\tu64 cbr_id;\n\tu64 psb_id;\n\n\tbool single_pebs;\n\tbool sample_pebs;\n\tstruct evsel *pebs_evsel;\n\n\tu64 evt_sample_type;\n\tu64 evt_id;\n\n\tu64 iflag_chg_sample_type;\n\tu64 iflag_chg_id;\n\n\tu64 tsc_bit;\n\tu64 mtc_bit;\n\tu64 mtc_freq_bits;\n\tu32 tsc_ctc_ratio_n;\n\tu32 tsc_ctc_ratio_d;\n\tu64 cyc_bit;\n\tu64 noretcomp_bit;\n\tunsigned max_non_turbo_ratio;\n\tunsigned cbr2khz;\n\tint max_loops;\n\n\tunsigned long num_events;\n\n\tchar *filter;\n\tstruct addr_filters filts;\n\n\tstruct range *time_ranges;\n\tunsigned int range_cnt;\n\n\tstruct ip_callchain *chain;\n\tstruct branch_stack *br_stack;\n\n\tu64 dflt_tsc_offset;\n\tstruct rb_root vmcs_info;\n};\n\nenum switch_state {\n\tINTEL_PT_SS_NOT_TRACING,\n\tINTEL_PT_SS_UNKNOWN,\n\tINTEL_PT_SS_TRACING,\n\tINTEL_PT_SS_EXPECTING_SWITCH_EVENT,\n\tINTEL_PT_SS_EXPECTING_SWITCH_IP,\n};\n\n \n#define INTEL_PT_MAX_PEBS 64\n\nstruct intel_pt_pebs_event {\n\tstruct evsel *evsel;\n\tu64 id;\n};\n\nstruct intel_pt_queue {\n\tstruct intel_pt *pt;\n\tunsigned int queue_nr;\n\tstruct auxtrace_buffer *buffer;\n\tstruct auxtrace_buffer *old_buffer;\n\tvoid *decoder;\n\tconst struct intel_pt_state *state;\n\tstruct ip_callchain *chain;\n\tstruct branch_stack *last_branch;\n\tunion perf_event *event_buf;\n\tbool on_heap;\n\tbool stop;\n\tbool step_through_buffers;\n\tbool use_buffer_pid_tid;\n\tbool sync_switch;\n\tbool sample_ipc;\n\tpid_t pid, tid;\n\tint cpu;\n\tint switch_state;\n\tpid_t next_tid;\n\tstruct thread *thread;\n\tstruct machine *guest_machine;\n\tstruct thread *guest_thread;\n\tstruct thread *unknown_guest_thread;\n\tpid_t guest_machine_pid;\n\tpid_t guest_pid;\n\tpid_t guest_tid;\n\tint vcpu;\n\tbool exclude_kernel;\n\tbool have_sample;\n\tu64 time;\n\tu64 timestamp;\n\tu64 sel_timestamp;\n\tbool sel_start;\n\tunsigned int sel_idx;\n\tu32 flags;\n\tu16 insn_len;\n\tu64 last_insn_cnt;\n\tu64 ipc_insn_cnt;\n\tu64 ipc_cyc_cnt;\n\tu64 last_in_insn_cnt;\n\tu64 last_in_cyc_cnt;\n\tu64 last_cy_insn_cnt;\n\tu64 last_cy_cyc_cnt;\n\tu64 last_br_insn_cnt;\n\tu64 last_br_cyc_cnt;\n\tunsigned int cbr_seen;\n\tchar insn[INTEL_PT_INSN_BUF_SZ];\n\tstruct intel_pt_pebs_event pebs[INTEL_PT_MAX_PEBS];\n};\n\nstatic void intel_pt_dump(struct intel_pt *pt __maybe_unused,\n\t\t\t  unsigned char *buf, size_t len)\n{\n\tstruct intel_pt_pkt packet;\n\tsize_t pos = 0;\n\tint ret, pkt_len, i;\n\tchar desc[INTEL_PT_PKT_DESC_MAX];\n\tconst char *color = PERF_COLOR_BLUE;\n\tenum intel_pt_pkt_ctx ctx = INTEL_PT_NO_CTX;\n\n\tcolor_fprintf(stdout, color,\n\t\t      \". ... Intel Processor Trace data: size %zu bytes\\n\",\n\t\t      len);\n\n\twhile (len) {\n\t\tret = intel_pt_get_packet(buf, len, &packet, &ctx);\n\t\tif (ret > 0)\n\t\t\tpkt_len = ret;\n\t\telse\n\t\t\tpkt_len = 1;\n\t\tprintf(\".\");\n\t\tcolor_fprintf(stdout, color, \"  %08x: \", pos);\n\t\tfor (i = 0; i < pkt_len; i++)\n\t\t\tcolor_fprintf(stdout, color, \" %02x\", buf[i]);\n\t\tfor (; i < 16; i++)\n\t\t\tcolor_fprintf(stdout, color, \"   \");\n\t\tif (ret > 0) {\n\t\t\tret = intel_pt_pkt_desc(&packet, desc,\n\t\t\t\t\t\tINTEL_PT_PKT_DESC_MAX);\n\t\t\tif (ret > 0)\n\t\t\t\tcolor_fprintf(stdout, color, \" %s\\n\", desc);\n\t\t} else {\n\t\t\tcolor_fprintf(stdout, color, \" Bad packet!\\n\");\n\t\t}\n\t\tpos += pkt_len;\n\t\tbuf += pkt_len;\n\t\tlen -= pkt_len;\n\t}\n}\n\nstatic void intel_pt_dump_event(struct intel_pt *pt, unsigned char *buf,\n\t\t\t\tsize_t len)\n{\n\tprintf(\".\\n\");\n\tintel_pt_dump(pt, buf, len);\n}\n\nstatic void intel_pt_log_event(union perf_event *event)\n{\n\tFILE *f = intel_pt_log_fp();\n\n\tif (!intel_pt_enable_logging || !f)\n\t\treturn;\n\n\tperf_event__fprintf(event, NULL, f);\n}\n\nstatic void intel_pt_dump_sample(struct perf_session *session,\n\t\t\t\t struct perf_sample *sample)\n{\n\tstruct intel_pt *pt = container_of(session->auxtrace, struct intel_pt,\n\t\t\t\t\t   auxtrace);\n\n\tprintf(\"\\n\");\n\tintel_pt_dump(pt, sample->aux_sample.data, sample->aux_sample.size);\n}\n\nstatic bool intel_pt_log_events(struct intel_pt *pt, u64 tm)\n{\n\tstruct perf_time_interval *range = pt->synth_opts.ptime_range;\n\tint n = pt->synth_opts.range_num;\n\n\tif (pt->synth_opts.log_plus_flags & AUXTRACE_LOG_FLG_ALL_PERF_EVTS)\n\t\treturn true;\n\n\tif (pt->synth_opts.log_minus_flags & AUXTRACE_LOG_FLG_ALL_PERF_EVTS)\n\t\treturn false;\n\n\t \n\tif (!tm)\n\t\ttm = 1;\n\n\treturn !n || !perf_time__ranges_skip_sample(range, n, tm);\n}\n\nstatic struct intel_pt_vmcs_info *intel_pt_findnew_vmcs(struct rb_root *rb_root,\n\t\t\t\t\t\t\tu64 vmcs,\n\t\t\t\t\t\t\tu64 dflt_tsc_offset)\n{\n\tstruct rb_node **p = &rb_root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct intel_pt_vmcs_info *v;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tv = rb_entry(parent, struct intel_pt_vmcs_info, rb_node);\n\n\t\tif (v->vmcs == vmcs)\n\t\t\treturn v;\n\n\t\tif (vmcs < v->vmcs)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tv = zalloc(sizeof(*v));\n\tif (v) {\n\t\tv->vmcs = vmcs;\n\t\tv->tsc_offset = dflt_tsc_offset;\n\t\tv->reliable = dflt_tsc_offset;\n\n\t\trb_link_node(&v->rb_node, parent, p);\n\t\trb_insert_color(&v->rb_node, rb_root);\n\t}\n\n\treturn v;\n}\n\nstatic struct intel_pt_vmcs_info *intel_pt_findnew_vmcs_info(void *data, uint64_t vmcs)\n{\n\tstruct intel_pt_queue *ptq = data;\n\tstruct intel_pt *pt = ptq->pt;\n\n\tif (!vmcs && !pt->dflt_tsc_offset)\n\t\treturn NULL;\n\n\treturn intel_pt_findnew_vmcs(&pt->vmcs_info, vmcs, pt->dflt_tsc_offset);\n}\n\nstatic void intel_pt_free_vmcs_info(struct intel_pt *pt)\n{\n\tstruct intel_pt_vmcs_info *v;\n\tstruct rb_node *n;\n\n\tn = rb_first(&pt->vmcs_info);\n\twhile (n) {\n\t\tv = rb_entry(n, struct intel_pt_vmcs_info, rb_node);\n\t\tn = rb_next(n);\n\t\trb_erase(&v->rb_node, &pt->vmcs_info);\n\t\tfree(v);\n\t}\n}\n\nstatic int intel_pt_do_fix_overlap(struct intel_pt *pt, struct auxtrace_buffer *a,\n\t\t\t\t   struct auxtrace_buffer *b)\n{\n\tbool consecutive = false;\n\tvoid *start;\n\n\tstart = intel_pt_find_overlap(a->data, a->size, b->data, b->size,\n\t\t\t\t      pt->have_tsc, &consecutive,\n\t\t\t\t      pt->synth_opts.vm_time_correlation);\n\tif (!start)\n\t\treturn -EINVAL;\n\t \n\tif (pt->synth_opts.vm_time_correlation)\n\t\tmemset(b->data, 0, start - b->data);\n\tb->use_size = b->data + b->size - start;\n\tb->use_data = start;\n\tif (b->use_size && consecutive)\n\t\tb->consecutive = true;\n\treturn 0;\n}\n\nstatic int intel_pt_get_buffer(struct intel_pt_queue *ptq,\n\t\t\t       struct auxtrace_buffer *buffer,\n\t\t\t       struct auxtrace_buffer *old_buffer,\n\t\t\t       struct intel_pt_buffer *b)\n{\n\tbool might_overlap;\n\n\tif (!buffer->data) {\n\t\tint fd = perf_data__fd(ptq->pt->session->data);\n\n\t\tbuffer->data = auxtrace_buffer__get_data(buffer, fd);\n\t\tif (!buffer->data)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmight_overlap = ptq->pt->snapshot_mode || ptq->pt->sampling_mode;\n\tif (might_overlap && !buffer->consecutive && old_buffer &&\n\t    intel_pt_do_fix_overlap(ptq->pt, old_buffer, buffer))\n\t\treturn -ENOMEM;\n\n\tif (buffer->use_data) {\n\t\tb->len = buffer->use_size;\n\t\tb->buf = buffer->use_data;\n\t} else {\n\t\tb->len = buffer->size;\n\t\tb->buf = buffer->data;\n\t}\n\tb->ref_timestamp = buffer->reference;\n\n\tif (!old_buffer || (might_overlap && !buffer->consecutive)) {\n\t\tb->consecutive = false;\n\t\tb->trace_nr = buffer->buffer_nr + 1;\n\t} else {\n\t\tb->consecutive = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void intel_pt_lookahead_drop_buffer(struct intel_pt_queue *ptq,\n\t\t\t\t\t   struct auxtrace_buffer *buffer)\n{\n\tif (!buffer || buffer == ptq->buffer || buffer == ptq->old_buffer)\n\t\treturn;\n\n\tauxtrace_buffer__drop_data(buffer);\n}\n\n \nstatic int intel_pt_lookahead(void *data, intel_pt_lookahead_cb_t cb,\n\t\t\t      void *cb_data)\n{\n\tstruct intel_pt_queue *ptq = data;\n\tstruct auxtrace_buffer *buffer = ptq->buffer;\n\tstruct auxtrace_buffer *old_buffer = ptq->old_buffer;\n\tstruct auxtrace_queue *queue;\n\tint err = 0;\n\n\tqueue = &ptq->pt->queues.queue_array[ptq->queue_nr];\n\n\twhile (1) {\n\t\tstruct intel_pt_buffer b = { .len = 0 };\n\n\t\tbuffer = auxtrace_buffer__next(queue, buffer);\n\t\tif (!buffer)\n\t\t\tbreak;\n\n\t\terr = intel_pt_get_buffer(ptq, buffer, old_buffer, &b);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (b.len) {\n\t\t\tintel_pt_lookahead_drop_buffer(ptq, old_buffer);\n\t\t\told_buffer = buffer;\n\t\t} else {\n\t\t\tintel_pt_lookahead_drop_buffer(ptq, buffer);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = cb(&b, cb_data);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (buffer != old_buffer)\n\t\tintel_pt_lookahead_drop_buffer(ptq, buffer);\n\tintel_pt_lookahead_drop_buffer(ptq, old_buffer);\n\n\treturn err;\n}\n\n \nstatic int intel_pt_get_trace(struct intel_pt_buffer *b, void *data)\n{\n\tstruct intel_pt_queue *ptq = data;\n\tstruct auxtrace_buffer *buffer = ptq->buffer;\n\tstruct auxtrace_buffer *old_buffer = ptq->old_buffer;\n\tstruct auxtrace_queue *queue;\n\tint err;\n\n\tif (ptq->stop) {\n\t\tb->len = 0;\n\t\treturn 0;\n\t}\n\n\tqueue = &ptq->pt->queues.queue_array[ptq->queue_nr];\n\n\tbuffer = auxtrace_buffer__next(queue, buffer);\n\tif (!buffer) {\n\t\tif (old_buffer)\n\t\t\tauxtrace_buffer__drop_data(old_buffer);\n\t\tb->len = 0;\n\t\treturn 0;\n\t}\n\n\tptq->buffer = buffer;\n\n\terr = intel_pt_get_buffer(ptq, buffer, old_buffer, b);\n\tif (err)\n\t\treturn err;\n\n\tif (ptq->step_through_buffers)\n\t\tptq->stop = true;\n\n\tif (b->len) {\n\t\tif (old_buffer)\n\t\t\tauxtrace_buffer__drop_data(old_buffer);\n\t\tptq->old_buffer = buffer;\n\t} else {\n\t\tauxtrace_buffer__drop_data(buffer);\n\t\treturn intel_pt_get_trace(b, data);\n\t}\n\n\treturn 0;\n}\n\nstruct intel_pt_cache_entry {\n\tstruct auxtrace_cache_entry\tentry;\n\tu64\t\t\t\tinsn_cnt;\n\tu64\t\t\t\tbyte_cnt;\n\tenum intel_pt_insn_op\t\top;\n\tenum intel_pt_insn_branch\tbranch;\n\tbool\t\t\t\temulated_ptwrite;\n\tint\t\t\t\tlength;\n\tint32_t\t\t\t\trel;\n\tchar\t\t\t\tinsn[INTEL_PT_INSN_BUF_SZ];\n};\n\nstatic int intel_pt_config_div(const char *var, const char *value, void *data)\n{\n\tint *d = data;\n\tlong val;\n\n\tif (!strcmp(var, \"intel-pt.cache-divisor\")) {\n\t\tval = strtol(value, NULL, 0);\n\t\tif (val > 0 && val <= INT_MAX)\n\t\t\t*d = val;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_pt_cache_divisor(void)\n{\n\tstatic int d;\n\n\tif (d)\n\t\treturn d;\n\n\tperf_config(intel_pt_config_div, &d);\n\n\tif (!d)\n\t\td = 64;\n\n\treturn d;\n}\n\nstatic unsigned int intel_pt_cache_size(struct dso *dso,\n\t\t\t\t\tstruct machine *machine)\n{\n\toff_t size;\n\n\tsize = dso__data_size(dso, machine);\n\tsize /= intel_pt_cache_divisor();\n\tif (size < 1000)\n\t\treturn 10;\n\tif (size > (1 << 21))\n\t\treturn 21;\n\treturn 32 - __builtin_clz(size);\n}\n\nstatic struct auxtrace_cache *intel_pt_cache(struct dso *dso,\n\t\t\t\t\t     struct machine *machine)\n{\n\tstruct auxtrace_cache *c;\n\tunsigned int bits;\n\n\tif (dso->auxtrace_cache)\n\t\treturn dso->auxtrace_cache;\n\n\tbits = intel_pt_cache_size(dso, machine);\n\n\t \n\tc = auxtrace_cache__new(bits, sizeof(struct intel_pt_cache_entry), 200);\n\n\tdso->auxtrace_cache = c;\n\n\treturn c;\n}\n\nstatic int intel_pt_cache_add(struct dso *dso, struct machine *machine,\n\t\t\t      u64 offset, u64 insn_cnt, u64 byte_cnt,\n\t\t\t      struct intel_pt_insn *intel_pt_insn)\n{\n\tstruct auxtrace_cache *c = intel_pt_cache(dso, machine);\n\tstruct intel_pt_cache_entry *e;\n\tint err;\n\n\tif (!c)\n\t\treturn -ENOMEM;\n\n\te = auxtrace_cache__alloc_entry(c);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->insn_cnt = insn_cnt;\n\te->byte_cnt = byte_cnt;\n\te->op = intel_pt_insn->op;\n\te->branch = intel_pt_insn->branch;\n\te->emulated_ptwrite = intel_pt_insn->emulated_ptwrite;\n\te->length = intel_pt_insn->length;\n\te->rel = intel_pt_insn->rel;\n\tmemcpy(e->insn, intel_pt_insn->buf, INTEL_PT_INSN_BUF_SZ);\n\n\terr = auxtrace_cache__add(c, offset, &e->entry);\n\tif (err)\n\t\tauxtrace_cache__free_entry(c, e);\n\n\treturn err;\n}\n\nstatic struct intel_pt_cache_entry *\nintel_pt_cache_lookup(struct dso *dso, struct machine *machine, u64 offset)\n{\n\tstruct auxtrace_cache *c = intel_pt_cache(dso, machine);\n\n\tif (!c)\n\t\treturn NULL;\n\n\treturn auxtrace_cache__lookup(dso->auxtrace_cache, offset);\n}\n\nstatic void intel_pt_cache_invalidate(struct dso *dso, struct machine *machine,\n\t\t\t\t      u64 offset)\n{\n\tstruct auxtrace_cache *c = intel_pt_cache(dso, machine);\n\n\tif (!c)\n\t\treturn;\n\n\tauxtrace_cache__remove(dso->auxtrace_cache, offset);\n}\n\nstatic inline bool intel_pt_guest_kernel_ip(uint64_t ip)\n{\n\t \n\treturn ip & (1ULL << 63);\n}\n\nstatic inline u8 intel_pt_nr_cpumode(struct intel_pt_queue *ptq, uint64_t ip, bool nr)\n{\n\tif (nr) {\n\t\treturn intel_pt_guest_kernel_ip(ip) ?\n\t\t       PERF_RECORD_MISC_GUEST_KERNEL :\n\t\t       PERF_RECORD_MISC_GUEST_USER;\n\t}\n\n\treturn ip >= ptq->pt->kernel_start ?\n\t       PERF_RECORD_MISC_KERNEL :\n\t       PERF_RECORD_MISC_USER;\n}\n\nstatic inline u8 intel_pt_cpumode(struct intel_pt_queue *ptq, uint64_t from_ip, uint64_t to_ip)\n{\n\t \n\tif (from_ip)\n\t\treturn intel_pt_nr_cpumode(ptq, from_ip, ptq->state->from_nr);\n\treturn intel_pt_nr_cpumode(ptq, to_ip, ptq->state->to_nr);\n}\n\nstatic int intel_pt_get_guest(struct intel_pt_queue *ptq)\n{\n\tstruct machines *machines = &ptq->pt->session->machines;\n\tstruct machine *machine;\n\tpid_t pid = ptq->pid <= 0 ? DEFAULT_GUEST_KERNEL_ID : ptq->pid;\n\n\tif (ptq->guest_machine && pid == ptq->guest_machine->pid)\n\t\treturn 0;\n\n\tptq->guest_machine = NULL;\n\tthread__zput(ptq->unknown_guest_thread);\n\n\tif (symbol_conf.guest_code) {\n\t\tthread__zput(ptq->guest_thread);\n\t\tptq->guest_thread = machines__findnew_guest_code(machines, pid);\n\t}\n\n\tmachine = machines__find_guest(machines, pid);\n\tif (!machine)\n\t\treturn -1;\n\n\tptq->unknown_guest_thread = machine__idle_thread(machine);\n\tif (!ptq->unknown_guest_thread)\n\t\treturn -1;\n\n\tptq->guest_machine = machine;\n\n\treturn 0;\n}\n\nstatic inline bool intel_pt_jmp_16(struct intel_pt_insn *intel_pt_insn)\n{\n\treturn intel_pt_insn->rel == 16 && intel_pt_insn->branch == INTEL_PT_BR_UNCONDITIONAL;\n}\n\n#define PTWRITE_MAGIC\t\t\"\\x0f\\x0bperf,ptwrite  \"\n#define PTWRITE_MAGIC_LEN\t16\n\nstatic bool intel_pt_emulated_ptwrite(struct dso *dso, struct machine *machine, u64 offset)\n{\n\tunsigned char buf[PTWRITE_MAGIC_LEN];\n\tssize_t len;\n\n\tlen = dso__data_read_offset(dso, machine, offset, buf, PTWRITE_MAGIC_LEN);\n\tif (len == PTWRITE_MAGIC_LEN && !memcmp(buf, PTWRITE_MAGIC, PTWRITE_MAGIC_LEN)) {\n\t\tintel_pt_log(\"Emulated ptwrite signature found\\n\");\n\t\treturn true;\n\t}\n\tintel_pt_log(\"Emulated ptwrite signature not found\\n\");\n\treturn false;\n}\n\nstatic int intel_pt_walk_next_insn(struct intel_pt_insn *intel_pt_insn,\n\t\t\t\t   uint64_t *insn_cnt_ptr, uint64_t *ip,\n\t\t\t\t   uint64_t to_ip, uint64_t max_insn_cnt,\n\t\t\t\t   void *data)\n{\n\tstruct intel_pt_queue *ptq = data;\n\tstruct machine *machine = ptq->pt->machine;\n\tstruct thread *thread;\n\tstruct addr_location al;\n\tunsigned char buf[INTEL_PT_INSN_BUF_SZ];\n\tssize_t len;\n\tint x86_64, ret = 0;\n\tu8 cpumode;\n\tu64 offset, start_offset, start_ip;\n\tu64 insn_cnt = 0;\n\tbool one_map = true;\n\tbool nr;\n\n\n\taddr_location__init(&al);\n\tintel_pt_insn->length = 0;\n\n\tif (to_ip && *ip == to_ip)\n\t\tgoto out_no_cache;\n\n\tnr = ptq->state->to_nr;\n\tcpumode = intel_pt_nr_cpumode(ptq, *ip, nr);\n\n\tif (nr) {\n\t\tif (ptq->pt->have_guest_sideband) {\n\t\t\tif (!ptq->guest_machine || ptq->guest_machine_pid != ptq->pid) {\n\t\t\t\tintel_pt_log(\"ERROR: guest sideband but no guest machine\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_ret;\n\t\t\t}\n\t\t} else if ((!symbol_conf.guest_code && cpumode != PERF_RECORD_MISC_GUEST_KERNEL) ||\n\t\t\t   intel_pt_get_guest(ptq)) {\n\t\t\tintel_pt_log(\"ERROR: no guest machine\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_ret;\n\t\t}\n\t\tmachine = ptq->guest_machine;\n\t\tthread = ptq->guest_thread;\n\t\tif (!thread) {\n\t\t\tif (cpumode != PERF_RECORD_MISC_GUEST_KERNEL) {\n\t\t\t\tintel_pt_log(\"ERROR: no guest thread\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_ret;\n\t\t\t}\n\t\t\tthread = ptq->unknown_guest_thread;\n\t\t}\n\t} else {\n\t\tthread = ptq->thread;\n\t\tif (!thread) {\n\t\t\tif (cpumode != PERF_RECORD_MISC_KERNEL) {\n\t\t\t\tintel_pt_log(\"ERROR: no thread\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_ret;\n\t\t\t}\n\t\t\tthread = ptq->pt->unknown_thread;\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tstruct dso *dso;\n\n\t\tif (!thread__find_map(thread, cpumode, *ip, &al) || !map__dso(al.map)) {\n\t\t\tif (al.map)\n\t\t\t\tintel_pt_log(\"ERROR: thread has no dso for %#\" PRIx64 \"\\n\", *ip);\n\t\t\telse\n\t\t\t\tintel_pt_log(\"ERROR: thread has no map for %#\" PRIx64 \"\\n\", *ip);\n\t\t\taddr_location__exit(&al);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_ret;\n\t\t}\n\t\tdso = map__dso(al.map);\n\n\t\tif (dso->data.status == DSO_DATA_STATUS_ERROR &&\n\t\t\tdso__data_status_seen(dso, DSO_DATA_STATUS_SEEN_ITRACE)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_ret;\n\t\t}\n\n\t\toffset = map__map_ip(al.map, *ip);\n\n\t\tif (!to_ip && one_map) {\n\t\t\tstruct intel_pt_cache_entry *e;\n\n\t\t\te = intel_pt_cache_lookup(dso, machine, offset);\n\t\t\tif (e &&\n\t\t\t    (!max_insn_cnt || e->insn_cnt <= max_insn_cnt)) {\n\t\t\t\t*insn_cnt_ptr = e->insn_cnt;\n\t\t\t\t*ip += e->byte_cnt;\n\t\t\t\tintel_pt_insn->op = e->op;\n\t\t\t\tintel_pt_insn->branch = e->branch;\n\t\t\t\tintel_pt_insn->emulated_ptwrite = e->emulated_ptwrite;\n\t\t\t\tintel_pt_insn->length = e->length;\n\t\t\t\tintel_pt_insn->rel = e->rel;\n\t\t\t\tmemcpy(intel_pt_insn->buf, e->insn, INTEL_PT_INSN_BUF_SZ);\n\t\t\t\tintel_pt_log_insn_no_data(intel_pt_insn, *ip);\n\t\t\t\tret = 0;\n\t\t\t\tgoto out_ret;\n\t\t\t}\n\t\t}\n\n\t\tstart_offset = offset;\n\t\tstart_ip = *ip;\n\n\t\t \n\t\tmap__load(al.map);\n\n\t\tx86_64 = dso->is_64_bit;\n\n\t\twhile (1) {\n\t\t\tlen = dso__data_read_offset(dso, machine,\n\t\t\t\t\t\t    offset, buf,\n\t\t\t\t\t\t    INTEL_PT_INSN_BUF_SZ);\n\t\t\tif (len <= 0) {\n\t\t\t\tintel_pt_log(\"ERROR: failed to read at offset %#\" PRIx64 \" \",\n\t\t\t\t\t     offset);\n\t\t\t\tif (intel_pt_enable_logging)\n\t\t\t\t\tdso__fprintf(dso, intel_pt_log_fp());\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_ret;\n\t\t\t}\n\n\t\t\tif (intel_pt_get_insn(buf, len, x86_64, intel_pt_insn)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_ret;\n\t\t\t}\n\n\t\t\tintel_pt_log_insn(intel_pt_insn, *ip);\n\n\t\t\tinsn_cnt += 1;\n\n\t\t\tif (intel_pt_insn->branch != INTEL_PT_BR_NO_BRANCH) {\n\t\t\t\tbool eptw;\n\t\t\t\tu64 offs;\n\n\t\t\t\tif (!intel_pt_jmp_16(intel_pt_insn))\n\t\t\t\t\tgoto out;\n\t\t\t\t \n\t\t\t\toffs = offset + intel_pt_insn->length;\n\t\t\t\teptw = intel_pt_emulated_ptwrite(dso, machine, offs);\n\t\t\t\tintel_pt_insn->emulated_ptwrite = eptw;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (max_insn_cnt && insn_cnt >= max_insn_cnt)\n\t\t\t\tgoto out_no_cache;\n\n\t\t\t*ip += intel_pt_insn->length;\n\n\t\t\tif (to_ip && *ip == to_ip) {\n\t\t\t\tintel_pt_insn->length = 0;\n\t\t\t\tgoto out_no_cache;\n\t\t\t}\n\n\t\t\tif (*ip >= map__end(al.map))\n\t\t\t\tbreak;\n\n\t\t\toffset += intel_pt_insn->length;\n\t\t}\n\t\tone_map = false;\n\t}\nout:\n\t*insn_cnt_ptr = insn_cnt;\n\n\tif (!one_map)\n\t\tgoto out_no_cache;\n\n\t \n\tif (to_ip) {\n\t\tstruct intel_pt_cache_entry *e;\n\n\t\te = intel_pt_cache_lookup(map__dso(al.map), machine, start_offset);\n\t\tif (e)\n\t\t\tgoto out_ret;\n\t}\n\n\t \n\tintel_pt_cache_add(map__dso(al.map), machine, start_offset, insn_cnt,\n\t\t\t   *ip - start_ip, intel_pt_insn);\n\nout_ret:\n\taddr_location__exit(&al);\n\treturn ret;\n\nout_no_cache:\n\t*insn_cnt_ptr = insn_cnt;\n\taddr_location__exit(&al);\n\treturn 0;\n}\n\nstatic bool intel_pt_match_pgd_ip(struct intel_pt *pt, uint64_t ip,\n\t\t\t\t  uint64_t offset, const char *filename)\n{\n\tstruct addr_filter *filt;\n\tbool have_filter   = false;\n\tbool hit_tracestop = false;\n\tbool hit_filter    = false;\n\n\tlist_for_each_entry(filt, &pt->filts.head, list) {\n\t\tif (filt->start)\n\t\t\thave_filter = true;\n\n\t\tif ((filename && !filt->filename) ||\n\t\t    (!filename && filt->filename) ||\n\t\t    (filename && strcmp(filename, filt->filename)))\n\t\t\tcontinue;\n\n\t\tif (!(offset >= filt->addr && offset < filt->addr + filt->size))\n\t\t\tcontinue;\n\n\t\tintel_pt_log(\"TIP.PGD ip %#\"PRIx64\" offset %#\"PRIx64\" in %s hit filter: %s offset %#\"PRIx64\" size %#\"PRIx64\"\\n\",\n\t\t\t     ip, offset, filename ? filename : \"[kernel]\",\n\t\t\t     filt->start ? \"filter\" : \"stop\",\n\t\t\t     filt->addr, filt->size);\n\n\t\tif (filt->start)\n\t\t\thit_filter = true;\n\t\telse\n\t\t\thit_tracestop = true;\n\t}\n\n\tif (!hit_tracestop && !hit_filter)\n\t\tintel_pt_log(\"TIP.PGD ip %#\"PRIx64\" offset %#\"PRIx64\" in %s is not in a filter region\\n\",\n\t\t\t     ip, offset, filename ? filename : \"[kernel]\");\n\n\treturn hit_tracestop || (have_filter && !hit_filter);\n}\n\nstatic int __intel_pt_pgd_ip(uint64_t ip, void *data)\n{\n\tstruct intel_pt_queue *ptq = data;\n\tstruct thread *thread;\n\tstruct addr_location al;\n\tu8 cpumode;\n\tu64 offset;\n\tint res;\n\n\tif (ptq->state->to_nr) {\n\t\tif (intel_pt_guest_kernel_ip(ip))\n\t\t\treturn intel_pt_match_pgd_ip(ptq->pt, ip, ip, NULL);\n\t\t \n\t\treturn -EINVAL;\n\t} else if (ip >= ptq->pt->kernel_start) {\n\t\treturn intel_pt_match_pgd_ip(ptq->pt, ip, ip, NULL);\n\t}\n\n\tcpumode = PERF_RECORD_MISC_USER;\n\n\tthread = ptq->thread;\n\tif (!thread)\n\t\treturn -EINVAL;\n\n\taddr_location__init(&al);\n\tif (!thread__find_map(thread, cpumode, ip, &al) || !map__dso(al.map))\n\t\treturn -EINVAL;\n\n\toffset = map__map_ip(al.map, ip);\n\n\tres = intel_pt_match_pgd_ip(ptq->pt, ip, offset, map__dso(al.map)->long_name);\n\taddr_location__exit(&al);\n\treturn res;\n}\n\nstatic bool intel_pt_pgd_ip(uint64_t ip, void *data)\n{\n\treturn __intel_pt_pgd_ip(ip, data) > 0;\n}\n\nstatic bool intel_pt_get_config(struct intel_pt *pt,\n\t\t\t\tstruct perf_event_attr *attr, u64 *config)\n{\n\tif (attr->type == pt->pmu_type) {\n\t\tif (config)\n\t\t\t*config = attr->config;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool intel_pt_exclude_kernel(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (intel_pt_get_config(pt, &evsel->core.attr, NULL) &&\n\t\t    !evsel->core.attr.exclude_kernel)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool intel_pt_return_compression(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\tu64 config;\n\n\tif (!pt->noretcomp_bit)\n\t\treturn true;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (intel_pt_get_config(pt, &evsel->core.attr, &config) &&\n\t\t    (config & pt->noretcomp_bit))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool intel_pt_branch_enable(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\tu64 config;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (intel_pt_get_config(pt, &evsel->core.attr, &config) &&\n\t\t    (config & INTEL_PT_CFG_PASS_THRU) &&\n\t\t    !(config & INTEL_PT_CFG_BRANCH_EN))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool intel_pt_disabled_tnt(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\tu64 config;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (intel_pt_get_config(pt, &evsel->core.attr, &config) &&\n\t\t    config & INTEL_PT_CFG_TNT_DIS)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic unsigned int intel_pt_mtc_period(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\tunsigned int shift;\n\tu64 config;\n\n\tif (!pt->mtc_freq_bits)\n\t\treturn 0;\n\n\tfor (shift = 0, config = pt->mtc_freq_bits; !(config & 1); shift++)\n\t\tconfig >>= 1;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (intel_pt_get_config(pt, &evsel->core.attr, &config))\n\t\t\treturn (config & pt->mtc_freq_bits) >> shift;\n\t}\n\treturn 0;\n}\n\nstatic bool intel_pt_timeless_decoding(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\tbool timeless_decoding = true;\n\tu64 config;\n\n\tif (!pt->tsc_bit || !pt->cap_user_time_zero || pt->synth_opts.timeless_decoding)\n\t\treturn true;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (!(evsel->core.attr.sample_type & PERF_SAMPLE_TIME))\n\t\t\treturn true;\n\t\tif (intel_pt_get_config(pt, &evsel->core.attr, &config)) {\n\t\t\tif (config & pt->tsc_bit)\n\t\t\t\ttimeless_decoding = false;\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn timeless_decoding;\n}\n\nstatic bool intel_pt_tracing_kernel(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (intel_pt_get_config(pt, &evsel->core.attr, NULL) &&\n\t\t    !evsel->core.attr.exclude_kernel)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool intel_pt_have_tsc(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\tbool have_tsc = false;\n\tu64 config;\n\n\tif (!pt->tsc_bit)\n\t\treturn false;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (intel_pt_get_config(pt, &evsel->core.attr, &config)) {\n\t\t\tif (config & pt->tsc_bit)\n\t\t\t\thave_tsc = true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn have_tsc;\n}\n\nstatic bool intel_pt_have_mtc(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\tu64 config;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (intel_pt_get_config(pt, &evsel->core.attr, &config) &&\n\t\t    (config & pt->mtc_bit))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool intel_pt_sampling_mode(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif ((evsel->core.attr.sample_type & PERF_SAMPLE_AUX) &&\n\t\t    evsel->core.attr.aux_sample_size)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic u64 intel_pt_ctl(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\tu64 config;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (intel_pt_get_config(pt, &evsel->core.attr, &config))\n\t\t\treturn config;\n\t}\n\treturn 0;\n}\n\nstatic u64 intel_pt_ns_to_ticks(const struct intel_pt *pt, u64 ns)\n{\n\tu64 quot, rem;\n\n\tquot = ns / pt->tc.time_mult;\n\trem  = ns % pt->tc.time_mult;\n\treturn (quot << pt->tc.time_shift) + (rem << pt->tc.time_shift) /\n\t\tpt->tc.time_mult;\n}\n\nstatic struct ip_callchain *intel_pt_alloc_chain(struct intel_pt *pt)\n{\n\tsize_t sz = sizeof(struct ip_callchain);\n\n\t \n\tsz += (pt->synth_opts.callchain_sz + 1) * sizeof(u64);\n\treturn zalloc(sz);\n}\n\nstatic int intel_pt_callchain_init(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (!(evsel->core.attr.sample_type & PERF_SAMPLE_CALLCHAIN))\n\t\t\tevsel->synth_sample_type |= PERF_SAMPLE_CALLCHAIN;\n\t}\n\n\tpt->chain = intel_pt_alloc_chain(pt);\n\tif (!pt->chain)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void intel_pt_add_callchain(struct intel_pt *pt,\n\t\t\t\t   struct perf_sample *sample)\n{\n\tstruct thread *thread = machine__findnew_thread(pt->machine,\n\t\t\t\t\t\t\tsample->pid,\n\t\t\t\t\t\t\tsample->tid);\n\n\tthread_stack__sample_late(thread, sample->cpu, pt->chain,\n\t\t\t\t  pt->synth_opts.callchain_sz + 1, sample->ip,\n\t\t\t\t  pt->kernel_start);\n\n\tsample->callchain = pt->chain;\n}\n\nstatic struct branch_stack *intel_pt_alloc_br_stack(unsigned int entry_cnt)\n{\n\tsize_t sz = sizeof(struct branch_stack);\n\n\tsz += entry_cnt * sizeof(struct branch_entry);\n\treturn zalloc(sz);\n}\n\nstatic int intel_pt_br_stack_init(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (!(evsel->core.attr.sample_type & PERF_SAMPLE_BRANCH_STACK))\n\t\t\tevsel->synth_sample_type |= PERF_SAMPLE_BRANCH_STACK;\n\t}\n\n\tpt->br_stack = intel_pt_alloc_br_stack(pt->br_stack_sz);\n\tif (!pt->br_stack)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void intel_pt_add_br_stack(struct intel_pt *pt,\n\t\t\t\t  struct perf_sample *sample)\n{\n\tstruct thread *thread = machine__findnew_thread(pt->machine,\n\t\t\t\t\t\t\tsample->pid,\n\t\t\t\t\t\t\tsample->tid);\n\n\tthread_stack__br_sample_late(thread, sample->cpu, pt->br_stack,\n\t\t\t\t     pt->br_stack_sz, sample->ip,\n\t\t\t\t     pt->kernel_start);\n\n\tsample->branch_stack = pt->br_stack;\n\tthread__put(thread);\n}\n\n \n#define LBRS_MAX (INTEL_PT_BLK_ITEM_ID_CNT * 3U)\n\nstatic struct intel_pt_queue *intel_pt_alloc_queue(struct intel_pt *pt,\n\t\t\t\t\t\t   unsigned int queue_nr)\n{\n\tstruct intel_pt_params params = { .get_trace = 0, };\n\tstruct perf_env *env = pt->machine->env;\n\tstruct intel_pt_queue *ptq;\n\n\tptq = zalloc(sizeof(struct intel_pt_queue));\n\tif (!ptq)\n\t\treturn NULL;\n\n\tif (pt->synth_opts.callchain) {\n\t\tptq->chain = intel_pt_alloc_chain(pt);\n\t\tif (!ptq->chain)\n\t\t\tgoto out_free;\n\t}\n\n\tif (pt->synth_opts.last_branch || pt->synth_opts.other_events) {\n\t\tunsigned int entry_cnt = max(LBRS_MAX, pt->br_stack_sz);\n\n\t\tptq->last_branch = intel_pt_alloc_br_stack(entry_cnt);\n\t\tif (!ptq->last_branch)\n\t\t\tgoto out_free;\n\t}\n\n\tptq->event_buf = malloc(PERF_SAMPLE_MAX_SIZE);\n\tif (!ptq->event_buf)\n\t\tgoto out_free;\n\n\tptq->pt = pt;\n\tptq->queue_nr = queue_nr;\n\tptq->exclude_kernel = intel_pt_exclude_kernel(pt);\n\tptq->pid = -1;\n\tptq->tid = -1;\n\tptq->cpu = -1;\n\tptq->next_tid = -1;\n\n\tparams.get_trace = intel_pt_get_trace;\n\tparams.walk_insn = intel_pt_walk_next_insn;\n\tparams.lookahead = intel_pt_lookahead;\n\tparams.findnew_vmcs_info = intel_pt_findnew_vmcs_info;\n\tparams.data = ptq;\n\tparams.return_compression = intel_pt_return_compression(pt);\n\tparams.branch_enable = intel_pt_branch_enable(pt);\n\tparams.ctl = intel_pt_ctl(pt);\n\tparams.max_non_turbo_ratio = pt->max_non_turbo_ratio;\n\tparams.mtc_period = intel_pt_mtc_period(pt);\n\tparams.tsc_ctc_ratio_n = pt->tsc_ctc_ratio_n;\n\tparams.tsc_ctc_ratio_d = pt->tsc_ctc_ratio_d;\n\tparams.quick = pt->synth_opts.quick;\n\tparams.vm_time_correlation = pt->synth_opts.vm_time_correlation;\n\tparams.vm_tm_corr_dry_run = pt->synth_opts.vm_tm_corr_dry_run;\n\tparams.first_timestamp = pt->first_timestamp;\n\tparams.max_loops = pt->max_loops;\n\n\t \n\tif (params.branch_enable && intel_pt_disabled_tnt(pt) && !params.quick)\n\t\tparams.quick = 1;\n\n\tif (pt->filts.cnt > 0)\n\t\tparams.pgd_ip = intel_pt_pgd_ip;\n\n\tif (pt->synth_opts.instructions || pt->synth_opts.cycles) {\n\t\tif (pt->synth_opts.period) {\n\t\t\tswitch (pt->synth_opts.period_type) {\n\t\t\tcase PERF_ITRACE_PERIOD_INSTRUCTIONS:\n\t\t\t\tparams.period_type =\n\t\t\t\t\t\tINTEL_PT_PERIOD_INSTRUCTIONS;\n\t\t\t\tparams.period = pt->synth_opts.period;\n\t\t\t\tbreak;\n\t\t\tcase PERF_ITRACE_PERIOD_TICKS:\n\t\t\t\tparams.period_type = INTEL_PT_PERIOD_TICKS;\n\t\t\t\tparams.period = pt->synth_opts.period;\n\t\t\t\tbreak;\n\t\t\tcase PERF_ITRACE_PERIOD_NANOSECS:\n\t\t\t\tparams.period_type = INTEL_PT_PERIOD_TICKS;\n\t\t\t\tparams.period = intel_pt_ns_to_ticks(pt,\n\t\t\t\t\t\t\tpt->synth_opts.period);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!params.period) {\n\t\t\tparams.period_type = INTEL_PT_PERIOD_INSTRUCTIONS;\n\t\t\tparams.period = 1;\n\t\t}\n\t}\n\n\tif (env->cpuid && !strncmp(env->cpuid, \"GenuineIntel,6,92,\", 18))\n\t\tparams.flags |= INTEL_PT_FUP_WITH_NLIP;\n\n\tptq->decoder = intel_pt_decoder_new(&params);\n\tif (!ptq->decoder)\n\t\tgoto out_free;\n\n\treturn ptq;\n\nout_free:\n\tzfree(&ptq->event_buf);\n\tzfree(&ptq->last_branch);\n\tzfree(&ptq->chain);\n\tfree(ptq);\n\treturn NULL;\n}\n\nstatic void intel_pt_free_queue(void *priv)\n{\n\tstruct intel_pt_queue *ptq = priv;\n\n\tif (!ptq)\n\t\treturn;\n\tthread__zput(ptq->thread);\n\tthread__zput(ptq->guest_thread);\n\tthread__zput(ptq->unknown_guest_thread);\n\tintel_pt_decoder_free(ptq->decoder);\n\tzfree(&ptq->event_buf);\n\tzfree(&ptq->last_branch);\n\tzfree(&ptq->chain);\n\tfree(ptq);\n}\n\nstatic void intel_pt_first_timestamp(struct intel_pt *pt, u64 timestamp)\n{\n\tunsigned int i;\n\n\tpt->first_timestamp = timestamp;\n\n\tfor (i = 0; i < pt->queues.nr_queues; i++) {\n\t\tstruct auxtrace_queue *queue = &pt->queues.queue_array[i];\n\t\tstruct intel_pt_queue *ptq = queue->priv;\n\n\t\tif (ptq && ptq->decoder)\n\t\t\tintel_pt_set_first_timestamp(ptq->decoder, timestamp);\n\t}\n}\n\nstatic int intel_pt_get_guest_from_sideband(struct intel_pt_queue *ptq)\n{\n\tstruct machines *machines = &ptq->pt->session->machines;\n\tstruct machine *machine;\n\tpid_t machine_pid = ptq->pid;\n\tpid_t tid;\n\tint vcpu;\n\n\tif (machine_pid <= 0)\n\t\treturn 0;  \n\n\tmachine = machines__find(machines, machine_pid);\n\tif (!machine)\n\t\treturn 0;  \n\n\tif (ptq->guest_machine != machine) {\n\t\tptq->guest_machine = NULL;\n\t\tthread__zput(ptq->guest_thread);\n\t\tthread__zput(ptq->unknown_guest_thread);\n\n\t\tptq->unknown_guest_thread = machine__find_thread(machine, 0, 0);\n\t\tif (!ptq->unknown_guest_thread)\n\t\t\treturn -1;\n\t\tptq->guest_machine = machine;\n\t}\n\n\tvcpu = ptq->thread ? thread__guest_cpu(ptq->thread) : -1;\n\tif (vcpu < 0)\n\t\treturn -1;\n\n\ttid = machine__get_current_tid(machine, vcpu);\n\n\tif (ptq->guest_thread && thread__tid(ptq->guest_thread) != tid)\n\t\tthread__zput(ptq->guest_thread);\n\n\tif (!ptq->guest_thread) {\n\t\tptq->guest_thread = machine__find_thread(machine, -1, tid);\n\t\tif (!ptq->guest_thread)\n\t\t\treturn -1;\n\t}\n\n\tptq->guest_machine_pid = machine_pid;\n\tptq->guest_pid = thread__pid(ptq->guest_thread);\n\tptq->guest_tid = tid;\n\tptq->vcpu = vcpu;\n\n\treturn 0;\n}\n\nstatic void intel_pt_set_pid_tid_cpu(struct intel_pt *pt,\n\t\t\t\t     struct auxtrace_queue *queue)\n{\n\tstruct intel_pt_queue *ptq = queue->priv;\n\n\tif (queue->tid == -1 || pt->have_sched_switch) {\n\t\tptq->tid = machine__get_current_tid(pt->machine, ptq->cpu);\n\t\tif (ptq->tid == -1)\n\t\t\tptq->pid = -1;\n\t\tthread__zput(ptq->thread);\n\t}\n\n\tif (!ptq->thread && ptq->tid != -1)\n\t\tptq->thread = machine__find_thread(pt->machine, -1, ptq->tid);\n\n\tif (ptq->thread) {\n\t\tptq->pid = thread__pid(ptq->thread);\n\t\tif (queue->cpu == -1)\n\t\t\tptq->cpu = thread__cpu(ptq->thread);\n\t}\n\n\tif (pt->have_guest_sideband && intel_pt_get_guest_from_sideband(ptq)) {\n\t\tptq->guest_machine_pid = 0;\n\t\tptq->guest_pid = -1;\n\t\tptq->guest_tid = -1;\n\t\tptq->vcpu = -1;\n\t}\n}\n\nstatic void intel_pt_sample_flags(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\n\tptq->insn_len = 0;\n\tif (ptq->state->flags & INTEL_PT_ABORT_TX) {\n\t\tptq->flags = PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_TX_ABORT;\n\t} else if (ptq->state->flags & INTEL_PT_ASYNC) {\n\t\tif (!ptq->state->to_ip)\n\t\t\tptq->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t     PERF_IP_FLAG_ASYNC |\n\t\t\t\t     PERF_IP_FLAG_TRACE_END;\n\t\telse if (ptq->state->from_nr && !ptq->state->to_nr)\n\t\t\tptq->flags = PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL |\n\t\t\t\t     PERF_IP_FLAG_ASYNC |\n\t\t\t\t     PERF_IP_FLAG_VMEXIT;\n\t\telse\n\t\t\tptq->flags = PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL |\n\t\t\t\t     PERF_IP_FLAG_ASYNC |\n\t\t\t\t     PERF_IP_FLAG_INTERRUPT;\n\t} else {\n\t\tif (ptq->state->from_ip)\n\t\t\tptq->flags = intel_pt_insn_type(ptq->state->insn_op);\n\t\telse\n\t\t\tptq->flags = PERF_IP_FLAG_BRANCH |\n\t\t\t\t     PERF_IP_FLAG_TRACE_BEGIN;\n\t\tif (ptq->state->flags & INTEL_PT_IN_TX)\n\t\t\tptq->flags |= PERF_IP_FLAG_IN_TX;\n\t\tptq->insn_len = ptq->state->insn_len;\n\t\tmemcpy(ptq->insn, ptq->state->insn, INTEL_PT_INSN_BUF_SZ);\n\t}\n\n\tif (ptq->state->type & INTEL_PT_TRACE_BEGIN)\n\t\tptq->flags |= PERF_IP_FLAG_TRACE_BEGIN;\n\tif (ptq->state->type & INTEL_PT_TRACE_END)\n\t\tptq->flags |= PERF_IP_FLAG_TRACE_END;\n\n\tif (pt->cap_event_trace) {\n\t\tif (ptq->state->type & INTEL_PT_IFLAG_CHG) {\n\t\t\tif (!ptq->state->from_iflag)\n\t\t\t\tptq->flags |= PERF_IP_FLAG_INTR_DISABLE;\n\t\t\tif (ptq->state->from_iflag != ptq->state->to_iflag)\n\t\t\t\tptq->flags |= PERF_IP_FLAG_INTR_TOGGLE;\n\t\t} else if (!ptq->state->to_iflag) {\n\t\t\tptq->flags |= PERF_IP_FLAG_INTR_DISABLE;\n\t\t}\n\t}\n}\n\nstatic void intel_pt_setup_time_range(struct intel_pt *pt,\n\t\t\t\t      struct intel_pt_queue *ptq)\n{\n\tif (!pt->range_cnt)\n\t\treturn;\n\n\tptq->sel_timestamp = pt->time_ranges[0].start;\n\tptq->sel_idx = 0;\n\n\tif (ptq->sel_timestamp) {\n\t\tptq->sel_start = true;\n\t} else {\n\t\tptq->sel_timestamp = pt->time_ranges[0].end;\n\t\tptq->sel_start = false;\n\t}\n}\n\nstatic int intel_pt_setup_queue(struct intel_pt *pt,\n\t\t\t\tstruct auxtrace_queue *queue,\n\t\t\t\tunsigned int queue_nr)\n{\n\tstruct intel_pt_queue *ptq = queue->priv;\n\n\tif (list_empty(&queue->head))\n\t\treturn 0;\n\n\tif (!ptq) {\n\t\tptq = intel_pt_alloc_queue(pt, queue_nr);\n\t\tif (!ptq)\n\t\t\treturn -ENOMEM;\n\t\tqueue->priv = ptq;\n\n\t\tif (queue->cpu != -1)\n\t\t\tptq->cpu = queue->cpu;\n\t\tptq->tid = queue->tid;\n\n\t\tptq->cbr_seen = UINT_MAX;\n\n\t\tif (pt->sampling_mode && !pt->snapshot_mode &&\n\t\t    pt->timeless_decoding)\n\t\t\tptq->step_through_buffers = true;\n\n\t\tptq->sync_switch = pt->sync_switch;\n\n\t\tintel_pt_setup_time_range(pt, ptq);\n\t}\n\n\tif (!ptq->on_heap &&\n\t    (!ptq->sync_switch ||\n\t     ptq->switch_state != INTEL_PT_SS_EXPECTING_SWITCH_EVENT)) {\n\t\tconst struct intel_pt_state *state;\n\t\tint ret;\n\n\t\tif (pt->timeless_decoding)\n\t\t\treturn 0;\n\n\t\tintel_pt_log(\"queue %u getting timestamp\\n\", queue_nr);\n\t\tintel_pt_log(\"queue %u decoding cpu %d pid %d tid %d\\n\",\n\t\t\t     queue_nr, ptq->cpu, ptq->pid, ptq->tid);\n\n\t\tif (ptq->sel_start && ptq->sel_timestamp) {\n\t\t\tret = intel_pt_fast_forward(ptq->decoder,\n\t\t\t\t\t\t    ptq->sel_timestamp);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tstate = intel_pt_decode(ptq->decoder);\n\t\t\tif (state->err) {\n\t\t\t\tif (state->err == INTEL_PT_ERR_NODATA) {\n\t\t\t\t\tintel_pt_log(\"queue %u has no timestamp\\n\",\n\t\t\t\t\t\t     queue_nr);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (state->timestamp)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tptq->timestamp = state->timestamp;\n\t\tintel_pt_log(\"queue %u timestamp 0x%\" PRIx64 \"\\n\",\n\t\t\t     queue_nr, ptq->timestamp);\n\t\tptq->state = state;\n\t\tptq->have_sample = true;\n\t\tif (ptq->sel_start && ptq->sel_timestamp &&\n\t\t    ptq->timestamp < ptq->sel_timestamp)\n\t\t\tptq->have_sample = false;\n\t\tintel_pt_sample_flags(ptq);\n\t\tret = auxtrace_heap__add(&pt->heap, queue_nr, ptq->timestamp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tptq->on_heap = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_pt_setup_queues(struct intel_pt *pt)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < pt->queues.nr_queues; i++) {\n\t\tret = intel_pt_setup_queue(pt, &pt->queues.queue_array[i], i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic inline bool intel_pt_skip_event(struct intel_pt *pt)\n{\n\treturn pt->synth_opts.initial_skip &&\n\t       pt->num_events++ < pt->synth_opts.initial_skip;\n}\n\n \nstatic inline bool intel_pt_skip_cbr_event(struct intel_pt *pt)\n{\n\treturn pt->synth_opts.initial_skip &&\n\t       pt->num_events + 4 < pt->synth_opts.initial_skip;\n}\n\nstatic void intel_pt_prep_a_sample(struct intel_pt_queue *ptq,\n\t\t\t\t   union perf_event *event,\n\t\t\t\t   struct perf_sample *sample)\n{\n\tevent->sample.header.type = PERF_RECORD_SAMPLE;\n\tevent->sample.header.size = sizeof(struct perf_event_header);\n\n\tsample->pid = ptq->pid;\n\tsample->tid = ptq->tid;\n\n\tif (ptq->pt->have_guest_sideband) {\n\t\tif ((ptq->state->from_ip && ptq->state->from_nr) ||\n\t\t    (ptq->state->to_ip && ptq->state->to_nr)) {\n\t\t\tsample->pid = ptq->guest_pid;\n\t\t\tsample->tid = ptq->guest_tid;\n\t\t\tsample->machine_pid = ptq->guest_machine_pid;\n\t\t\tsample->vcpu = ptq->vcpu;\n\t\t}\n\t}\n\n\tsample->cpu = ptq->cpu;\n\tsample->insn_len = ptq->insn_len;\n\tmemcpy(sample->insn, ptq->insn, INTEL_PT_INSN_BUF_SZ);\n}\n\nstatic void intel_pt_prep_b_sample(struct intel_pt *pt,\n\t\t\t\t   struct intel_pt_queue *ptq,\n\t\t\t\t   union perf_event *event,\n\t\t\t\t   struct perf_sample *sample)\n{\n\tintel_pt_prep_a_sample(ptq, event, sample);\n\n\tif (!pt->timeless_decoding)\n\t\tsample->time = tsc_to_perf_time(ptq->timestamp, &pt->tc);\n\n\tsample->ip = ptq->state->from_ip;\n\tsample->addr = ptq->state->to_ip;\n\tsample->cpumode = intel_pt_cpumode(ptq, sample->ip, sample->addr);\n\tsample->period = 1;\n\tsample->flags = ptq->flags;\n\n\tevent->sample.header.misc = sample->cpumode;\n}\n\nstatic int intel_pt_inject_event(union perf_event *event,\n\t\t\t\t struct perf_sample *sample, u64 type)\n{\n\tevent->header.size = perf_event__sample_event_size(sample, type, 0);\n\treturn perf_event__synthesize_sample(event, type, 0, sample);\n}\n\nstatic inline int intel_pt_opt_inject(struct intel_pt *pt,\n\t\t\t\t      union perf_event *event,\n\t\t\t\t      struct perf_sample *sample, u64 type)\n{\n\tif (!pt->synth_opts.inject)\n\t\treturn 0;\n\n\treturn intel_pt_inject_event(event, sample, type);\n}\n\nstatic int intel_pt_deliver_synth_event(struct intel_pt *pt,\n\t\t\t\t\tunion perf_event *event,\n\t\t\t\t\tstruct perf_sample *sample, u64 type)\n{\n\tint ret;\n\n\tret = intel_pt_opt_inject(pt, event, sample, type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_session__deliver_synth_event(pt->session, event, sample);\n\tif (ret)\n\t\tpr_err(\"Intel PT: failed to deliver event, error %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int intel_pt_synth_branch_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\tstruct dummy_branch_stack {\n\t\tu64\t\t\tnr;\n\t\tu64\t\t\thw_idx;\n\t\tstruct branch_entry\tentries;\n\t} dummy_bs;\n\n\tif (pt->branches_filter && !(pt->branches_filter & ptq->flags))\n\t\treturn 0;\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_b_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->branches_id;\n\tsample.stream_id = ptq->pt->branches_id;\n\n\t \n\tif (pt->synth_opts.last_branch && sort__mode == SORT_MODE__BRANCH) {\n\t\tdummy_bs = (struct dummy_branch_stack){\n\t\t\t.nr = 1,\n\t\t\t.hw_idx = -1ULL,\n\t\t\t.entries = {\n\t\t\t\t.from = sample.ip,\n\t\t\t\t.to = sample.addr,\n\t\t\t},\n\t\t};\n\t\tsample.branch_stack = (struct branch_stack *)&dummy_bs;\n\t}\n\n\tif (ptq->sample_ipc)\n\t\tsample.cyc_cnt = ptq->ipc_cyc_cnt - ptq->last_br_cyc_cnt;\n\tif (sample.cyc_cnt) {\n\t\tsample.insn_cnt = ptq->ipc_insn_cnt - ptq->last_br_insn_cnt;\n\t\tptq->last_br_insn_cnt = ptq->ipc_insn_cnt;\n\t\tptq->last_br_cyc_cnt = ptq->ipc_cyc_cnt;\n\t}\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->branches_sample_type);\n}\n\nstatic void intel_pt_prep_sample(struct intel_pt *pt,\n\t\t\t\t struct intel_pt_queue *ptq,\n\t\t\t\t union perf_event *event,\n\t\t\t\t struct perf_sample *sample)\n{\n\tintel_pt_prep_b_sample(pt, ptq, event, sample);\n\n\tif (pt->synth_opts.callchain) {\n\t\tthread_stack__sample(ptq->thread, ptq->cpu, ptq->chain,\n\t\t\t\t     pt->synth_opts.callchain_sz + 1,\n\t\t\t\t     sample->ip, pt->kernel_start);\n\t\tsample->callchain = ptq->chain;\n\t}\n\n\tif (pt->synth_opts.last_branch) {\n\t\tthread_stack__br_sample(ptq->thread, ptq->cpu, ptq->last_branch,\n\t\t\t\t\tpt->br_stack_sz);\n\t\tsample->branch_stack = ptq->last_branch;\n\t}\n}\n\nstatic int intel_pt_synth_instruction_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->instructions_id;\n\tsample.stream_id = ptq->pt->instructions_id;\n\tif (pt->synth_opts.quick)\n\t\tsample.period = 1;\n\telse\n\t\tsample.period = ptq->state->tot_insn_cnt - ptq->last_insn_cnt;\n\n\tif (ptq->sample_ipc)\n\t\tsample.cyc_cnt = ptq->ipc_cyc_cnt - ptq->last_in_cyc_cnt;\n\tif (sample.cyc_cnt) {\n\t\tsample.insn_cnt = ptq->ipc_insn_cnt - ptq->last_in_insn_cnt;\n\t\tptq->last_in_insn_cnt = ptq->ipc_insn_cnt;\n\t\tptq->last_in_cyc_cnt = ptq->ipc_cyc_cnt;\n\t}\n\n\tptq->last_insn_cnt = ptq->state->tot_insn_cnt;\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->instructions_sample_type);\n}\n\nstatic int intel_pt_synth_cycle_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\tu64 period = 0;\n\n\tif (ptq->sample_ipc)\n\t\tperiod = ptq->ipc_cyc_cnt - ptq->last_cy_cyc_cnt;\n\n\tif (!period || intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->cycles_id;\n\tsample.stream_id = ptq->pt->cycles_id;\n\tsample.period = period;\n\n\tsample.cyc_cnt = period;\n\tsample.insn_cnt = ptq->ipc_insn_cnt - ptq->last_cy_insn_cnt;\n\tptq->last_cy_insn_cnt = ptq->ipc_insn_cnt;\n\tptq->last_cy_cyc_cnt = ptq->ipc_cyc_cnt;\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample, pt->cycles_sample_type);\n}\n\nstatic int intel_pt_synth_transaction_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->transactions_id;\n\tsample.stream_id = ptq->pt->transactions_id;\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->transactions_sample_type);\n}\n\nstatic void intel_pt_prep_p_sample(struct intel_pt *pt,\n\t\t\t\t   struct intel_pt_queue *ptq,\n\t\t\t\t   union perf_event *event,\n\t\t\t\t   struct perf_sample *sample)\n{\n\tintel_pt_prep_sample(pt, ptq, event, sample);\n\n\t \n\tif (!sample->ip)\n\t\tsample->flags = 0;\n}\n\nstatic int intel_pt_synth_ptwrite_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\tstruct perf_synth_intel_ptwrite raw;\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_p_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->ptwrites_id;\n\tsample.stream_id = ptq->pt->ptwrites_id;\n\n\traw.flags = 0;\n\traw.ip = !!(ptq->state->flags & INTEL_PT_FUP_IP);\n\traw.payload = cpu_to_le64(ptq->state->ptw_payload);\n\n\tsample.raw_size = perf_synth__raw_size(raw);\n\tsample.raw_data = perf_synth__raw_data(&raw);\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->ptwrites_sample_type);\n}\n\nstatic int intel_pt_synth_cbr_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\tstruct perf_synth_intel_cbr raw;\n\tu32 flags;\n\n\tif (intel_pt_skip_cbr_event(pt))\n\t\treturn 0;\n\n\tptq->cbr_seen = ptq->state->cbr;\n\n\tintel_pt_prep_p_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->cbr_id;\n\tsample.stream_id = ptq->pt->cbr_id;\n\n\tflags = (u16)ptq->state->cbr_payload | (pt->max_non_turbo_ratio << 16);\n\traw.flags = cpu_to_le32(flags);\n\traw.freq = cpu_to_le32(raw.cbr * pt->cbr2khz);\n\traw.reserved3 = 0;\n\n\tsample.raw_size = perf_synth__raw_size(raw);\n\tsample.raw_data = perf_synth__raw_data(&raw);\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->pwr_events_sample_type);\n}\n\nstatic int intel_pt_synth_psb_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\tstruct perf_synth_intel_psb raw;\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_p_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->psb_id;\n\tsample.stream_id = ptq->pt->psb_id;\n\tsample.flags = 0;\n\n\traw.reserved = 0;\n\traw.offset = ptq->state->psb_offset;\n\n\tsample.raw_size = perf_synth__raw_size(raw);\n\tsample.raw_data = perf_synth__raw_data(&raw);\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->pwr_events_sample_type);\n}\n\nstatic int intel_pt_synth_mwait_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\tstruct perf_synth_intel_mwait raw;\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_p_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->mwait_id;\n\tsample.stream_id = ptq->pt->mwait_id;\n\n\traw.reserved = 0;\n\traw.payload = cpu_to_le64(ptq->state->mwait_payload);\n\n\tsample.raw_size = perf_synth__raw_size(raw);\n\tsample.raw_data = perf_synth__raw_data(&raw);\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->pwr_events_sample_type);\n}\n\nstatic int intel_pt_synth_pwre_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\tstruct perf_synth_intel_pwre raw;\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_p_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->pwre_id;\n\tsample.stream_id = ptq->pt->pwre_id;\n\n\traw.reserved = 0;\n\traw.payload = cpu_to_le64(ptq->state->pwre_payload);\n\n\tsample.raw_size = perf_synth__raw_size(raw);\n\tsample.raw_data = perf_synth__raw_data(&raw);\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->pwr_events_sample_type);\n}\n\nstatic int intel_pt_synth_exstop_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\tstruct perf_synth_intel_exstop raw;\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_p_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->exstop_id;\n\tsample.stream_id = ptq->pt->exstop_id;\n\n\traw.flags = 0;\n\traw.ip = !!(ptq->state->flags & INTEL_PT_FUP_IP);\n\n\tsample.raw_size = perf_synth__raw_size(raw);\n\tsample.raw_data = perf_synth__raw_data(&raw);\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->pwr_events_sample_type);\n}\n\nstatic int intel_pt_synth_pwrx_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\tstruct perf_synth_intel_pwrx raw;\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_p_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->pwrx_id;\n\tsample.stream_id = ptq->pt->pwrx_id;\n\n\traw.reserved = 0;\n\traw.payload = cpu_to_le64(ptq->state->pwrx_payload);\n\n\tsample.raw_size = perf_synth__raw_size(raw);\n\tsample.raw_data = perf_synth__raw_data(&raw);\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->pwr_events_sample_type);\n}\n\n \nstatic const int pebs_gp_regs[] = {\n\t[PERF_REG_X86_FLAGS]\t= 1,\n\t[PERF_REG_X86_IP]\t= 2,\n\t[PERF_REG_X86_AX]\t= 3,\n\t[PERF_REG_X86_CX]\t= 4,\n\t[PERF_REG_X86_DX]\t= 5,\n\t[PERF_REG_X86_BX]\t= 6,\n\t[PERF_REG_X86_SP]\t= 7,\n\t[PERF_REG_X86_BP]\t= 8,\n\t[PERF_REG_X86_SI]\t= 9,\n\t[PERF_REG_X86_DI]\t= 10,\n\t[PERF_REG_X86_R8]\t= 11,\n\t[PERF_REG_X86_R9]\t= 12,\n\t[PERF_REG_X86_R10]\t= 13,\n\t[PERF_REG_X86_R11]\t= 14,\n\t[PERF_REG_X86_R12]\t= 15,\n\t[PERF_REG_X86_R13]\t= 16,\n\t[PERF_REG_X86_R14]\t= 17,\n\t[PERF_REG_X86_R15]\t= 18,\n};\n\nstatic u64 *intel_pt_add_gp_regs(struct regs_dump *intr_regs, u64 *pos,\n\t\t\t\t const struct intel_pt_blk_items *items,\n\t\t\t\t u64 regs_mask)\n{\n\tconst u64 *gp_regs = items->val[INTEL_PT_GP_REGS_POS];\n\tu32 mask = items->mask[INTEL_PT_GP_REGS_POS];\n\tu32 bit;\n\tint i;\n\n\tfor (i = 0, bit = 1; i < PERF_REG_X86_64_MAX; i++, bit <<= 1) {\n\t\t \n\t\tint n = pebs_gp_regs[i] - 1;\n\n\t\tif (n < 0)\n\t\t\tcontinue;\n\t\t \n\t\tif (mask & 1 << n && regs_mask & bit) {\n\t\t\tintr_regs->mask |= bit;\n\t\t\t*pos++ = gp_regs[n];\n\t\t}\n\t}\n\n\treturn pos;\n}\n\n#ifndef PERF_REG_X86_XMM0\n#define PERF_REG_X86_XMM0 32\n#endif\n\nstatic void intel_pt_add_xmm(struct regs_dump *intr_regs, u64 *pos,\n\t\t\t     const struct intel_pt_blk_items *items,\n\t\t\t     u64 regs_mask)\n{\n\tu32 mask = items->has_xmm & (regs_mask >> PERF_REG_X86_XMM0);\n\tconst u64 *xmm = items->xmm;\n\n\t \n\tintr_regs->mask |= (u64)mask << PERF_REG_X86_XMM0;\n\n\tfor (; mask; mask >>= 1, xmm++) {\n\t\tif (mask & 1)\n\t\t\t*pos++ = *xmm;\n\t}\n}\n\n#define LBR_INFO_MISPRED\t(1ULL << 63)\n#define LBR_INFO_IN_TX\t\t(1ULL << 62)\n#define LBR_INFO_ABORT\t\t(1ULL << 61)\n#define LBR_INFO_CYCLES\t\t0xffff\n\n \nstatic u64 intel_pt_lbr_flags(u64 info)\n{\n\tunion {\n\t\tstruct branch_flags flags;\n\t\tu64 result;\n\t} u;\n\n\tu.result\t  = 0;\n\tu.flags.mispred\t  = !!(info & LBR_INFO_MISPRED);\n\tu.flags.predicted = !(info & LBR_INFO_MISPRED);\n\tu.flags.in_tx\t  = !!(info & LBR_INFO_IN_TX);\n\tu.flags.abort\t  = !!(info & LBR_INFO_ABORT);\n\tu.flags.cycles\t  = info & LBR_INFO_CYCLES;\n\n\treturn u.result;\n}\n\nstatic void intel_pt_add_lbrs(struct branch_stack *br_stack,\n\t\t\t      const struct intel_pt_blk_items *items)\n{\n\tu64 *to;\n\tint i;\n\n\tbr_stack->nr = 0;\n\n\tto = &br_stack->entries[0].from;\n\n\tfor (i = INTEL_PT_LBR_0_POS; i <= INTEL_PT_LBR_2_POS; i++) {\n\t\tu32 mask = items->mask[i];\n\t\tconst u64 *from = items->val[i];\n\n\t\tfor (; mask; mask >>= 3, from += 3) {\n\t\t\tif ((mask & 7) == 7) {\n\t\t\t\t*to++ = from[0];\n\t\t\t\t*to++ = from[1];\n\t\t\t\t*to++ = intel_pt_lbr_flags(from[2]);\n\t\t\t\tbr_stack->nr += 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int intel_pt_do_synth_pebs_sample(struct intel_pt_queue *ptq, struct evsel *evsel, u64 id)\n{\n\tconst struct intel_pt_blk_items *items = &ptq->state->items;\n\tstruct perf_sample sample = { .ip = 0, };\n\tunion perf_event *event = ptq->event_buf;\n\tstruct intel_pt *pt = ptq->pt;\n\tu64 sample_type = evsel->core.attr.sample_type;\n\tu8 cpumode;\n\tu64 regs[8 * sizeof(sample.intr_regs.mask)];\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_a_sample(ptq, event, &sample);\n\n\tsample.id = id;\n\tsample.stream_id = id;\n\n\tif (!evsel->core.attr.freq)\n\t\tsample.period = evsel->core.attr.sample_period;\n\n\t \n\tif (items->has_ip)\n\t\tsample.ip = items->ip;\n\telse if (items->has_rip)\n\t\tsample.ip = items->rip;\n\telse\n\t\tsample.ip = ptq->state->from_ip;\n\n\tcpumode = intel_pt_cpumode(ptq, sample.ip, 0);\n\n\tevent->sample.header.misc = cpumode | PERF_RECORD_MISC_EXACT_IP;\n\n\tsample.cpumode = cpumode;\n\n\tif (sample_type & PERF_SAMPLE_TIME) {\n\t\tu64 timestamp = 0;\n\n\t\tif (items->has_timestamp)\n\t\t\ttimestamp = items->timestamp;\n\t\telse if (!pt->timeless_decoding)\n\t\t\ttimestamp = ptq->timestamp;\n\t\tif (timestamp)\n\t\t\tsample.time = tsc_to_perf_time(timestamp, &pt->tc);\n\t}\n\n\tif (sample_type & PERF_SAMPLE_CALLCHAIN &&\n\t    pt->synth_opts.callchain) {\n\t\tthread_stack__sample(ptq->thread, ptq->cpu, ptq->chain,\n\t\t\t\t     pt->synth_opts.callchain_sz, sample.ip,\n\t\t\t\t     pt->kernel_start);\n\t\tsample.callchain = ptq->chain;\n\t}\n\n\tif (sample_type & PERF_SAMPLE_REGS_INTR &&\n\t    (items->mask[INTEL_PT_GP_REGS_POS] ||\n\t     items->mask[INTEL_PT_XMM_POS])) {\n\t\tu64 regs_mask = evsel->core.attr.sample_regs_intr;\n\t\tu64 *pos;\n\n\t\tsample.intr_regs.abi = items->is_32_bit ?\n\t\t\t\t       PERF_SAMPLE_REGS_ABI_32 :\n\t\t\t\t       PERF_SAMPLE_REGS_ABI_64;\n\t\tsample.intr_regs.regs = regs;\n\n\t\tpos = intel_pt_add_gp_regs(&sample.intr_regs, regs, items, regs_mask);\n\n\t\tintel_pt_add_xmm(&sample.intr_regs, pos, items, regs_mask);\n\t}\n\n\tif (sample_type & PERF_SAMPLE_BRANCH_STACK) {\n\t\tif (items->mask[INTEL_PT_LBR_0_POS] ||\n\t\t    items->mask[INTEL_PT_LBR_1_POS] ||\n\t\t    items->mask[INTEL_PT_LBR_2_POS]) {\n\t\t\tintel_pt_add_lbrs(ptq->last_branch, items);\n\t\t} else if (pt->synth_opts.last_branch) {\n\t\t\tthread_stack__br_sample(ptq->thread, ptq->cpu,\n\t\t\t\t\t\tptq->last_branch,\n\t\t\t\t\t\tpt->br_stack_sz);\n\t\t} else {\n\t\t\tptq->last_branch->nr = 0;\n\t\t}\n\t\tsample.branch_stack = ptq->last_branch;\n\t}\n\n\tif (sample_type & PERF_SAMPLE_ADDR && items->has_mem_access_address)\n\t\tsample.addr = items->mem_access_address;\n\n\tif (sample_type & PERF_SAMPLE_WEIGHT_TYPE) {\n\t\t \n\t\tif (items->has_mem_access_latency) {\n\t\t\tu64 weight = items->mem_access_latency >> 32;\n\n\t\t\t \n\t\t\tif (weight > 0) {\n\t\t\t\tsample.weight = weight & 0xffff;\n\t\t\t\tsample.ins_lat = items->mem_access_latency & 0xffff;\n\t\t\t} else\n\t\t\t\tsample.weight = items->mem_access_latency;\n\t\t}\n\t\tif (!sample.weight && items->has_tsx_aux_info) {\n\t\t\t \n\t\t\tsample.weight = (u32)items->tsx_aux_info;\n\t\t}\n\t}\n\n\tif (sample_type & PERF_SAMPLE_TRANSACTION && items->has_tsx_aux_info) {\n\t\tu64 ax = items->has_rax ? items->rax : 0;\n\t\t \n\t\tu64 txn = (u8)(items->tsx_aux_info >> 32);\n\n\t\t \n\t\tif (txn & PERF_TXN_TRANSACTION && ax & 1)\n\t\t\ttxn |= ((ax >> 24) & 0xff) << PERF_TXN_ABORT_SHIFT;\n\t\tsample.transaction = txn;\n\t}\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample, sample_type);\n}\n\nstatic int intel_pt_synth_single_pebs_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tstruct evsel *evsel = pt->pebs_evsel;\n\tu64 id = evsel->core.id[0];\n\n\treturn intel_pt_do_synth_pebs_sample(ptq, evsel, id);\n}\n\nstatic int intel_pt_synth_pebs_sample(struct intel_pt_queue *ptq)\n{\n\tconst struct intel_pt_blk_items *items = &ptq->state->items;\n\tstruct intel_pt_pebs_event *pe;\n\tstruct intel_pt *pt = ptq->pt;\n\tint err = -EINVAL;\n\tint hw_id;\n\n\tif (!items->has_applicable_counters || !items->applicable_counters) {\n\t\tif (!pt->single_pebs)\n\t\t\tpr_err(\"PEBS-via-PT record with no applicable_counters\\n\");\n\t\treturn intel_pt_synth_single_pebs_sample(ptq);\n\t}\n\n\tfor_each_set_bit(hw_id, (unsigned long *)&items->applicable_counters, INTEL_PT_MAX_PEBS) {\n\t\tpe = &ptq->pebs[hw_id];\n\t\tif (!pe->evsel) {\n\t\t\tif (!pt->single_pebs)\n\t\t\t\tpr_err(\"PEBS-via-PT record with no matching event, hw_id %d\\n\",\n\t\t\t\t       hw_id);\n\t\t\treturn intel_pt_synth_single_pebs_sample(ptq);\n\t\t}\n\t\terr = intel_pt_do_synth_pebs_sample(ptq, pe->evsel, pe->id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int intel_pt_synth_events_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\tstruct {\n\t\tstruct perf_synth_intel_evt cfe;\n\t\tstruct perf_synth_intel_evd evd[INTEL_PT_MAX_EVDS];\n\t} raw;\n\tint i;\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_p_sample(pt, ptq, event, &sample);\n\n\tsample.id        = ptq->pt->evt_id;\n\tsample.stream_id = ptq->pt->evt_id;\n\n\traw.cfe.type     = ptq->state->cfe_type;\n\traw.cfe.reserved = 0;\n\traw.cfe.ip       = !!(ptq->state->flags & INTEL_PT_FUP_IP);\n\traw.cfe.vector   = ptq->state->cfe_vector;\n\traw.cfe.evd_cnt  = ptq->state->evd_cnt;\n\n\tfor (i = 0; i < ptq->state->evd_cnt; i++) {\n\t\traw.evd[i].et       = 0;\n\t\traw.evd[i].evd_type = ptq->state->evd[i].type;\n\t\traw.evd[i].payload  = ptq->state->evd[i].payload;\n\t}\n\n\tsample.raw_size = perf_synth__raw_size(raw) +\n\t\t\t  ptq->state->evd_cnt * sizeof(struct perf_synth_intel_evd);\n\tsample.raw_data = perf_synth__raw_data(&raw);\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->evt_sample_type);\n}\n\nstatic int intel_pt_synth_iflag_chg_sample(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tunion perf_event *event = ptq->event_buf;\n\tstruct perf_sample sample = { .ip = 0, };\n\tstruct perf_synth_intel_iflag_chg raw;\n\n\tif (intel_pt_skip_event(pt))\n\t\treturn 0;\n\n\tintel_pt_prep_p_sample(pt, ptq, event, &sample);\n\n\tsample.id = ptq->pt->iflag_chg_id;\n\tsample.stream_id = ptq->pt->iflag_chg_id;\n\n\traw.flags = 0;\n\traw.iflag = ptq->state->to_iflag;\n\n\tif (ptq->state->type & INTEL_PT_BRANCH) {\n\t\traw.via_branch = 1;\n\t\traw.branch_ip = ptq->state->to_ip;\n\t} else {\n\t\tsample.addr = 0;\n\t}\n\tsample.flags = ptq->flags;\n\n\tsample.raw_size = perf_synth__raw_size(raw);\n\tsample.raw_data = perf_synth__raw_data(&raw);\n\n\treturn intel_pt_deliver_synth_event(pt, event, &sample,\n\t\t\t\t\t    pt->iflag_chg_sample_type);\n}\n\nstatic int intel_pt_synth_error(struct intel_pt *pt, int code, int cpu,\n\t\t\t\tpid_t pid, pid_t tid, u64 ip, u64 timestamp,\n\t\t\t\tpid_t machine_pid, int vcpu)\n{\n\tbool dump_log_on_error = pt->synth_opts.log_plus_flags & AUXTRACE_LOG_FLG_ON_ERROR;\n\tbool log_on_stdout = pt->synth_opts.log_plus_flags & AUXTRACE_LOG_FLG_USE_STDOUT;\n\tunion perf_event event;\n\tchar msg[MAX_AUXTRACE_ERROR_MSG];\n\tint err;\n\n\tif (pt->synth_opts.error_minus_flags) {\n\t\tif (code == INTEL_PT_ERR_OVR &&\n\t\t    pt->synth_opts.error_minus_flags & AUXTRACE_ERR_FLG_OVERFLOW)\n\t\t\treturn 0;\n\t\tif (code == INTEL_PT_ERR_LOST &&\n\t\t    pt->synth_opts.error_minus_flags & AUXTRACE_ERR_FLG_DATA_LOST)\n\t\t\treturn 0;\n\t}\n\n\tintel_pt__strerror(code, msg, MAX_AUXTRACE_ERROR_MSG);\n\n\tauxtrace_synth_guest_error(&event.auxtrace_error, PERF_AUXTRACE_ERROR_ITRACE,\n\t\t\t\t   code, cpu, pid, tid, ip, msg, timestamp,\n\t\t\t\t   machine_pid, vcpu);\n\n\tif (intel_pt_enable_logging && !log_on_stdout) {\n\t\tFILE *fp = intel_pt_log_fp();\n\n\t\tif (fp)\n\t\t\tperf_event__fprintf_auxtrace_error(&event, fp);\n\t}\n\n\tif (code != INTEL_PT_ERR_LOST && dump_log_on_error)\n\t\tintel_pt_log_dump_buf();\n\n\terr = perf_session__deliver_synth_event(pt->session, &event, NULL);\n\tif (err)\n\t\tpr_err(\"Intel Processor Trace: failed to deliver error event, error %d\\n\",\n\t\t       err);\n\n\treturn err;\n}\n\nstatic int intel_ptq_synth_error(struct intel_pt_queue *ptq,\n\t\t\t\t const struct intel_pt_state *state)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\tu64 tm = ptq->timestamp;\n\tpid_t machine_pid = 0;\n\tpid_t pid = ptq->pid;\n\tpid_t tid = ptq->tid;\n\tint vcpu = -1;\n\n\ttm = pt->timeless_decoding ? 0 : tsc_to_perf_time(tm, &pt->tc);\n\n\tif (pt->have_guest_sideband && state->from_nr) {\n\t\tmachine_pid = ptq->guest_machine_pid;\n\t\tvcpu = ptq->vcpu;\n\t\tpid = ptq->guest_pid;\n\t\ttid = ptq->guest_tid;\n\t}\n\n\treturn intel_pt_synth_error(pt, state->err, ptq->cpu, pid, tid,\n\t\t\t\t    state->from_ip, tm, machine_pid, vcpu);\n}\n\nstatic int intel_pt_next_tid(struct intel_pt *pt, struct intel_pt_queue *ptq)\n{\n\tstruct auxtrace_queue *queue;\n\tpid_t tid = ptq->next_tid;\n\tint err;\n\n\tif (tid == -1)\n\t\treturn 0;\n\n\tintel_pt_log(\"switch: cpu %d tid %d\\n\", ptq->cpu, tid);\n\n\terr = machine__set_current_tid(pt->machine, ptq->cpu, -1, tid);\n\n\tqueue = &pt->queues.queue_array[ptq->queue_nr];\n\tintel_pt_set_pid_tid_cpu(pt, queue);\n\n\tptq->next_tid = -1;\n\n\treturn err;\n}\n\nstatic inline bool intel_pt_is_switch_ip(struct intel_pt_queue *ptq, u64 ip)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\n\treturn ip == pt->switch_ip &&\n\t       (ptq->flags & PERF_IP_FLAG_BRANCH) &&\n\t       !(ptq->flags & (PERF_IP_FLAG_CONDITIONAL | PERF_IP_FLAG_ASYNC |\n\t\t\t       PERF_IP_FLAG_INTERRUPT | PERF_IP_FLAG_TX_ABORT));\n}\n\n#define INTEL_PT_PWR_EVT (INTEL_PT_MWAIT_OP | INTEL_PT_PWR_ENTRY | \\\n\t\t\t  INTEL_PT_EX_STOP | INTEL_PT_PWR_EXIT)\n\nstatic int intel_pt_sample(struct intel_pt_queue *ptq)\n{\n\tconst struct intel_pt_state *state = ptq->state;\n\tstruct intel_pt *pt = ptq->pt;\n\tint err;\n\n\tif (!ptq->have_sample)\n\t\treturn 0;\n\n\tptq->have_sample = false;\n\n\tif (pt->synth_opts.approx_ipc) {\n\t\tptq->ipc_insn_cnt = ptq->state->tot_insn_cnt;\n\t\tptq->ipc_cyc_cnt = ptq->state->cycles;\n\t\tptq->sample_ipc = true;\n\t} else {\n\t\tptq->ipc_insn_cnt = ptq->state->tot_insn_cnt;\n\t\tptq->ipc_cyc_cnt = ptq->state->tot_cyc_cnt;\n\t\tptq->sample_ipc = ptq->state->flags & INTEL_PT_SAMPLE_IPC;\n\t}\n\n\t \n\tif (symbol_conf.guest_code && (state->from_nr || state->to_nr))\n\t\tintel_pt_get_guest(ptq);\n\n\t \n\tif (pt->sample_pebs && state->type & INTEL_PT_BLK_ITEMS) {\n\t\terr = intel_pt_synth_pebs_sample(ptq);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pt->synth_opts.intr_events) {\n\t\tif (state->type & INTEL_PT_EVT) {\n\t\t\terr = intel_pt_synth_events_sample(ptq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (state->type & INTEL_PT_IFLAG_CHG) {\n\t\t\terr = intel_pt_synth_iflag_chg_sample(ptq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (pt->sample_pwr_events) {\n\t\tif (state->type & INTEL_PT_PSB_EVT) {\n\t\t\terr = intel_pt_synth_psb_sample(ptq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (ptq->state->cbr != ptq->cbr_seen) {\n\t\t\terr = intel_pt_synth_cbr_sample(ptq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (state->type & INTEL_PT_PWR_EVT) {\n\t\t\tif (state->type & INTEL_PT_MWAIT_OP) {\n\t\t\t\terr = intel_pt_synth_mwait_sample(ptq);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (state->type & INTEL_PT_PWR_ENTRY) {\n\t\t\t\terr = intel_pt_synth_pwre_sample(ptq);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (state->type & INTEL_PT_EX_STOP) {\n\t\t\t\terr = intel_pt_synth_exstop_sample(ptq);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (state->type & INTEL_PT_PWR_EXIT) {\n\t\t\t\terr = intel_pt_synth_pwrx_sample(ptq);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (state->type & INTEL_PT_INSTRUCTION) {\n\t\tif (pt->sample_instructions) {\n\t\t\terr = intel_pt_synth_instruction_sample(ptq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (pt->sample_cycles) {\n\t\t\terr = intel_pt_synth_cycle_sample(ptq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (pt->sample_transactions && (state->type & INTEL_PT_TRANSACTION)) {\n\t\terr = intel_pt_synth_transaction_sample(ptq);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pt->sample_ptwrites && (state->type & INTEL_PT_PTW)) {\n\t\terr = intel_pt_synth_ptwrite_sample(ptq);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!(state->type & INTEL_PT_BRANCH))\n\t\treturn 0;\n\n\tif (pt->use_thread_stack) {\n\t\tthread_stack__event(ptq->thread, ptq->cpu, ptq->flags,\n\t\t\t\t    state->from_ip, state->to_ip, ptq->insn_len,\n\t\t\t\t    state->trace_nr, pt->callstack,\n\t\t\t\t    pt->br_stack_sz_plus,\n\t\t\t\t    pt->mispred_all);\n\t} else {\n\t\tthread_stack__set_trace_nr(ptq->thread, ptq->cpu, state->trace_nr);\n\t}\n\n\tif (pt->sample_branches) {\n\t\tif (state->from_nr != state->to_nr &&\n\t\t    state->from_ip && state->to_ip) {\n\t\t\tstruct intel_pt_state *st = (struct intel_pt_state *)state;\n\t\t\tu64 to_ip = st->to_ip;\n\t\t\tu64 from_ip = st->from_ip;\n\n\t\t\t \n\t\t\tst->to_ip = 0;\n\t\t\terr = intel_pt_synth_branch_sample(ptq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tst->from_ip = 0;\n\t\t\tst->to_ip = to_ip;\n\t\t\terr = intel_pt_synth_branch_sample(ptq);\n\t\t\tst->from_ip = from_ip;\n\t\t} else {\n\t\t\terr = intel_pt_synth_branch_sample(ptq);\n\t\t}\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!ptq->sync_switch)\n\t\treturn 0;\n\n\tif (intel_pt_is_switch_ip(ptq, state->to_ip)) {\n\t\tswitch (ptq->switch_state) {\n\t\tcase INTEL_PT_SS_NOT_TRACING:\n\t\tcase INTEL_PT_SS_UNKNOWN:\n\t\tcase INTEL_PT_SS_EXPECTING_SWITCH_IP:\n\t\t\terr = intel_pt_next_tid(pt, ptq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tptq->switch_state = INTEL_PT_SS_TRACING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tptq->switch_state = INTEL_PT_SS_EXPECTING_SWITCH_EVENT;\n\t\t\treturn 1;\n\t\t}\n\t} else if (!state->to_ip) {\n\t\tptq->switch_state = INTEL_PT_SS_NOT_TRACING;\n\t} else if (ptq->switch_state == INTEL_PT_SS_NOT_TRACING) {\n\t\tptq->switch_state = INTEL_PT_SS_UNKNOWN;\n\t} else if (ptq->switch_state == INTEL_PT_SS_UNKNOWN &&\n\t\t   state->to_ip == pt->ptss_ip &&\n\t\t   (ptq->flags & PERF_IP_FLAG_CALL)) {\n\t\tptq->switch_state = INTEL_PT_SS_TRACING;\n\t}\n\n\treturn 0;\n}\n\nstatic u64 intel_pt_switch_ip(struct intel_pt *pt, u64 *ptss_ip)\n{\n\tstruct machine *machine = pt->machine;\n\tstruct map *map;\n\tstruct symbol *sym, *start;\n\tu64 ip, switch_ip = 0;\n\tconst char *ptss;\n\n\tif (ptss_ip)\n\t\t*ptss_ip = 0;\n\n\tmap = machine__kernel_map(machine);\n\tif (!map)\n\t\treturn 0;\n\n\tif (map__load(map))\n\t\treturn 0;\n\n\tstart = dso__first_symbol(map__dso(map));\n\n\tfor (sym = start; sym; sym = dso__next_symbol(sym)) {\n\t\tif (sym->binding == STB_GLOBAL &&\n\t\t    !strcmp(sym->name, \"__switch_to\")) {\n\t\t\tip = map__unmap_ip(map, sym->start);\n\t\t\tif (ip >= map__start(map) && ip < map__end(map)) {\n\t\t\t\tswitch_ip = ip;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!switch_ip || !ptss_ip)\n\t\treturn 0;\n\n\tif (pt->have_sched_switch == 1)\n\t\tptss = \"perf_trace_sched_switch\";\n\telse\n\t\tptss = \"__perf_event_task_sched_out\";\n\n\tfor (sym = start; sym; sym = dso__next_symbol(sym)) {\n\t\tif (!strcmp(sym->name, ptss)) {\n\t\t\tip = map__unmap_ip(map, sym->start);\n\t\t\tif (ip >= map__start(map) && ip < map__end(map)) {\n\t\t\t\t*ptss_ip = ip;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn switch_ip;\n}\n\nstatic void intel_pt_enable_sync_switch(struct intel_pt *pt)\n{\n\tunsigned int i;\n\n\tif (pt->sync_switch_not_supported)\n\t\treturn;\n\n\tpt->sync_switch = true;\n\n\tfor (i = 0; i < pt->queues.nr_queues; i++) {\n\t\tstruct auxtrace_queue *queue = &pt->queues.queue_array[i];\n\t\tstruct intel_pt_queue *ptq = queue->priv;\n\n\t\tif (ptq)\n\t\t\tptq->sync_switch = true;\n\t}\n}\n\nstatic void intel_pt_disable_sync_switch(struct intel_pt *pt)\n{\n\tunsigned int i;\n\n\tpt->sync_switch = false;\n\n\tfor (i = 0; i < pt->queues.nr_queues; i++) {\n\t\tstruct auxtrace_queue *queue = &pt->queues.queue_array[i];\n\t\tstruct intel_pt_queue *ptq = queue->priv;\n\n\t\tif (ptq) {\n\t\t\tptq->sync_switch = false;\n\t\t\tintel_pt_next_tid(pt, ptq);\n\t\t}\n\t}\n}\n\n \nstatic bool intel_pt_next_time(struct intel_pt_queue *ptq)\n{\n\tstruct intel_pt *pt = ptq->pt;\n\n\tif (ptq->sel_start) {\n\t\t \n\t\tptq->sel_start = false;\n\t\tptq->sel_timestamp = pt->time_ranges[ptq->sel_idx].end;\n\t\treturn true;\n\t} else if (ptq->sel_idx + 1 < pt->range_cnt) {\n\t\t \n\t\tptq->sel_start = true;\n\t\tptq->sel_idx += 1;\n\t\tptq->sel_timestamp = pt->time_ranges[ptq->sel_idx].start;\n\t\treturn true;\n\t}\n\n\t \n\treturn false;\n}\n\nstatic int intel_pt_time_filter(struct intel_pt_queue *ptq, u64 *ff_timestamp)\n{\n\tint err;\n\n\twhile (1) {\n\t\tif (ptq->sel_start) {\n\t\t\tif (ptq->timestamp >= ptq->sel_timestamp) {\n\t\t\t\t \n\t\t\t\tintel_pt_next_time(ptq);\n\t\t\t\tif (!ptq->sel_timestamp) {\n\t\t\t\t\t \n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tptq->have_sample = false;\n\t\t\tif (ptq->sel_timestamp > *ff_timestamp) {\n\t\t\t\tif (ptq->sync_switch) {\n\t\t\t\t\tintel_pt_next_tid(ptq->pt, ptq);\n\t\t\t\t\tptq->switch_state = INTEL_PT_SS_UNKNOWN;\n\t\t\t\t}\n\t\t\t\t*ff_timestamp = ptq->sel_timestamp;\n\t\t\t\terr = intel_pt_fast_forward(ptq->decoder,\n\t\t\t\t\t\t\t    ptq->sel_timestamp);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (ptq->timestamp > ptq->sel_timestamp) {\n\t\t\t \n\t\t\tif (!intel_pt_next_time(ptq)) {\n\t\t\t\t \n\t\t\t\tptq->have_sample = false;\n\t\t\t\tptq->switch_state = INTEL_PT_SS_NOT_TRACING;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t \n\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\nstatic int intel_pt_run_decoder(struct intel_pt_queue *ptq, u64 *timestamp)\n{\n\tconst struct intel_pt_state *state = ptq->state;\n\tstruct intel_pt *pt = ptq->pt;\n\tu64 ff_timestamp = 0;\n\tint err;\n\n\tif (!pt->kernel_start) {\n\t\tpt->kernel_start = machine__kernel_start(pt->machine);\n\t\tif (pt->per_cpu_mmaps &&\n\t\t    (pt->have_sched_switch == 1 || pt->have_sched_switch == 3) &&\n\t\t    !pt->timeless_decoding && intel_pt_tracing_kernel(pt) &&\n\t\t    !pt->sampling_mode && !pt->synth_opts.vm_time_correlation) {\n\t\t\tpt->switch_ip = intel_pt_switch_ip(pt, &pt->ptss_ip);\n\t\t\tif (pt->switch_ip) {\n\t\t\t\tintel_pt_log(\"switch_ip: %\"PRIx64\" ptss_ip: %\"PRIx64\"\\n\",\n\t\t\t\t\t     pt->switch_ip, pt->ptss_ip);\n\t\t\t\tintel_pt_enable_sync_switch(pt);\n\t\t\t}\n\t\t}\n\t}\n\n\tintel_pt_log(\"queue %u decoding cpu %d pid %d tid %d\\n\",\n\t\t     ptq->queue_nr, ptq->cpu, ptq->pid, ptq->tid);\n\twhile (1) {\n\t\terr = intel_pt_sample(ptq);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstate = intel_pt_decode(ptq->decoder);\n\t\tif (state->err) {\n\t\t\tif (state->err == INTEL_PT_ERR_NODATA)\n\t\t\t\treturn 1;\n\t\t\tif (ptq->sync_switch &&\n\t\t\t    state->from_ip >= pt->kernel_start) {\n\t\t\t\tptq->sync_switch = false;\n\t\t\t\tintel_pt_next_tid(pt, ptq);\n\t\t\t}\n\t\t\tptq->timestamp = state->est_timestamp;\n\t\t\tif (pt->synth_opts.errors) {\n\t\t\t\terr = intel_ptq_synth_error(ptq, state);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tptq->state = state;\n\t\tptq->have_sample = true;\n\t\tintel_pt_sample_flags(ptq);\n\n\t\t \n\t\tif (pt->est_tsc &&\n\t\t    (state->from_ip >= pt->kernel_start || !state->from_ip) &&\n\t\t    state->to_ip && state->to_ip < pt->kernel_start) {\n\t\t\tintel_pt_log(\"TSC %\"PRIx64\" est. TSC %\"PRIx64\"\\n\",\n\t\t\t\t     state->timestamp, state->est_timestamp);\n\t\t\tptq->timestamp = state->est_timestamp;\n\t\t \n\t\t} else if (ptq->sync_switch &&\n\t\t\t   ptq->switch_state == INTEL_PT_SS_UNKNOWN &&\n\t\t\t   intel_pt_is_switch_ip(ptq, state->to_ip) &&\n\t\t\t   ptq->next_tid == -1) {\n\t\t\tintel_pt_log(\"TSC %\"PRIx64\" est. TSC %\"PRIx64\"\\n\",\n\t\t\t\t     state->timestamp, state->est_timestamp);\n\t\t\tptq->timestamp = state->est_timestamp;\n\t\t} else if (state->timestamp > ptq->timestamp) {\n\t\t\tptq->timestamp = state->timestamp;\n\t\t}\n\n\t\tif (ptq->sel_timestamp) {\n\t\t\terr = intel_pt_time_filter(ptq, &ff_timestamp);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (!pt->timeless_decoding && ptq->timestamp >= *timestamp) {\n\t\t\t*timestamp = ptq->timestamp;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline int intel_pt_update_queues(struct intel_pt *pt)\n{\n\tif (pt->queues.new_data) {\n\t\tpt->queues.new_data = false;\n\t\treturn intel_pt_setup_queues(pt);\n\t}\n\treturn 0;\n}\n\nstatic int intel_pt_process_queues(struct intel_pt *pt, u64 timestamp)\n{\n\tunsigned int queue_nr;\n\tu64 ts;\n\tint ret;\n\n\twhile (1) {\n\t\tstruct auxtrace_queue *queue;\n\t\tstruct intel_pt_queue *ptq;\n\n\t\tif (!pt->heap.heap_cnt)\n\t\t\treturn 0;\n\n\t\tif (pt->heap.heap_array[0].ordinal >= timestamp)\n\t\t\treturn 0;\n\n\t\tqueue_nr = pt->heap.heap_array[0].queue_nr;\n\t\tqueue = &pt->queues.queue_array[queue_nr];\n\t\tptq = queue->priv;\n\n\t\tintel_pt_log(\"queue %u processing 0x%\" PRIx64 \" to 0x%\" PRIx64 \"\\n\",\n\t\t\t     queue_nr, pt->heap.heap_array[0].ordinal,\n\t\t\t     timestamp);\n\n\t\tauxtrace_heap__pop(&pt->heap);\n\n\t\tif (pt->heap.heap_cnt) {\n\t\t\tts = pt->heap.heap_array[0].ordinal + 1;\n\t\t\tif (ts > timestamp)\n\t\t\t\tts = timestamp;\n\t\t} else {\n\t\t\tts = timestamp;\n\t\t}\n\n\t\tintel_pt_set_pid_tid_cpu(pt, queue);\n\n\t\tret = intel_pt_run_decoder(ptq, &ts);\n\n\t\tif (ret < 0) {\n\t\t\tauxtrace_heap__add(&pt->heap, queue_nr, ts);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!ret) {\n\t\t\tret = auxtrace_heap__add(&pt->heap, queue_nr, ts);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tptq->on_heap = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_pt_process_timeless_queues(struct intel_pt *pt, pid_t tid,\n\t\t\t\t\t    u64 time_)\n{\n\tstruct auxtrace_queues *queues = &pt->queues;\n\tunsigned int i;\n\tu64 ts = 0;\n\n\tfor (i = 0; i < queues->nr_queues; i++) {\n\t\tstruct auxtrace_queue *queue = &pt->queues.queue_array[i];\n\t\tstruct intel_pt_queue *ptq = queue->priv;\n\n\t\tif (ptq && (tid == -1 || ptq->tid == tid)) {\n\t\t\tptq->time = time_;\n\t\t\tintel_pt_set_pid_tid_cpu(pt, queue);\n\t\t\tintel_pt_run_decoder(ptq, &ts);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void intel_pt_sample_set_pid_tid_cpu(struct intel_pt_queue *ptq,\n\t\t\t\t\t    struct auxtrace_queue *queue,\n\t\t\t\t\t    struct perf_sample *sample)\n{\n\tstruct machine *m = ptq->pt->machine;\n\n\tptq->pid = sample->pid;\n\tptq->tid = sample->tid;\n\tptq->cpu = queue->cpu;\n\n\tintel_pt_log(\"queue %u cpu %d pid %d tid %d\\n\",\n\t\t     ptq->queue_nr, ptq->cpu, ptq->pid, ptq->tid);\n\n\tthread__zput(ptq->thread);\n\n\tif (ptq->tid == -1)\n\t\treturn;\n\n\tif (ptq->pid == -1) {\n\t\tptq->thread = machine__find_thread(m, -1, ptq->tid);\n\t\tif (ptq->thread)\n\t\t\tptq->pid = thread__pid(ptq->thread);\n\t\treturn;\n\t}\n\n\tptq->thread = machine__findnew_thread(m, ptq->pid, ptq->tid);\n}\n\nstatic int intel_pt_process_timeless_sample(struct intel_pt *pt,\n\t\t\t\t\t    struct perf_sample *sample)\n{\n\tstruct auxtrace_queue *queue;\n\tstruct intel_pt_queue *ptq;\n\tu64 ts = 0;\n\n\tqueue = auxtrace_queues__sample_queue(&pt->queues, sample, pt->session);\n\tif (!queue)\n\t\treturn -EINVAL;\n\n\tptq = queue->priv;\n\tif (!ptq)\n\t\treturn 0;\n\n\tptq->stop = false;\n\tptq->time = sample->time;\n\tintel_pt_sample_set_pid_tid_cpu(ptq, queue, sample);\n\tintel_pt_run_decoder(ptq, &ts);\n\treturn 0;\n}\n\nstatic int intel_pt_lost(struct intel_pt *pt, struct perf_sample *sample)\n{\n\treturn intel_pt_synth_error(pt, INTEL_PT_ERR_LOST, sample->cpu,\n\t\t\t\t    sample->pid, sample->tid, 0, sample->time,\n\t\t\t\t    sample->machine_pid, sample->vcpu);\n}\n\nstatic struct intel_pt_queue *intel_pt_cpu_to_ptq(struct intel_pt *pt, int cpu)\n{\n\tunsigned i, j;\n\n\tif (cpu < 0 || !pt->queues.nr_queues)\n\t\treturn NULL;\n\n\tif ((unsigned)cpu >= pt->queues.nr_queues)\n\t\ti = pt->queues.nr_queues - 1;\n\telse\n\t\ti = cpu;\n\n\tif (pt->queues.queue_array[i].cpu == cpu)\n\t\treturn pt->queues.queue_array[i].priv;\n\n\tfor (j = 0; i > 0; j++) {\n\t\tif (pt->queues.queue_array[--i].cpu == cpu)\n\t\t\treturn pt->queues.queue_array[i].priv;\n\t}\n\n\tfor (; j < pt->queues.nr_queues; j++) {\n\t\tif (pt->queues.queue_array[j].cpu == cpu)\n\t\t\treturn pt->queues.queue_array[j].priv;\n\t}\n\n\treturn NULL;\n}\n\nstatic int intel_pt_sync_switch(struct intel_pt *pt, int cpu, pid_t tid,\n\t\t\t\tu64 timestamp)\n{\n\tstruct intel_pt_queue *ptq;\n\tint err;\n\n\tif (!pt->sync_switch)\n\t\treturn 1;\n\n\tptq = intel_pt_cpu_to_ptq(pt, cpu);\n\tif (!ptq || !ptq->sync_switch)\n\t\treturn 1;\n\n\tswitch (ptq->switch_state) {\n\tcase INTEL_PT_SS_NOT_TRACING:\n\t\tbreak;\n\tcase INTEL_PT_SS_UNKNOWN:\n\tcase INTEL_PT_SS_TRACING:\n\t\tptq->next_tid = tid;\n\t\tptq->switch_state = INTEL_PT_SS_EXPECTING_SWITCH_IP;\n\t\treturn 0;\n\tcase INTEL_PT_SS_EXPECTING_SWITCH_EVENT:\n\t\tif (!ptq->on_heap) {\n\t\t\tptq->timestamp = perf_time_to_tsc(timestamp,\n\t\t\t\t\t\t\t  &pt->tc);\n\t\t\terr = auxtrace_heap__add(&pt->heap, ptq->queue_nr,\n\t\t\t\t\t\t ptq->timestamp);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tptq->on_heap = true;\n\t\t}\n\t\tptq->switch_state = INTEL_PT_SS_TRACING;\n\t\tbreak;\n\tcase INTEL_PT_SS_EXPECTING_SWITCH_IP:\n\t\tintel_pt_log(\"ERROR: cpu %d expecting switch ip\\n\", cpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tptq->next_tid = -1;\n\n\treturn 1;\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nstatic int intel_pt_process_switch(struct intel_pt *pt,\n\t\t\t\t   struct perf_sample *sample)\n{\n\tpid_t tid;\n\tint cpu, ret;\n\tstruct evsel *evsel = evlist__id2evsel(pt->session->evlist, sample->id);\n\n\tif (evsel != pt->switch_evsel)\n\t\treturn 0;\n\n\ttid = evsel__intval(evsel, sample, \"next_pid\");\n\tcpu = sample->cpu;\n\n\tintel_pt_log(\"sched_switch: cpu %d tid %d time %\"PRIu64\" tsc %#\"PRIx64\"\\n\",\n\t\t     cpu, tid, sample->time, perf_time_to_tsc(sample->time,\n\t\t     &pt->tc));\n\n\tret = intel_pt_sync_switch(pt, cpu, tid, sample->time);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\treturn machine__set_current_tid(pt->machine, cpu, -1, tid);\n}\n#endif  \n\nstatic int intel_pt_context_switch_in(struct intel_pt *pt,\n\t\t\t\t      struct perf_sample *sample)\n{\n\tpid_t pid = sample->pid;\n\tpid_t tid = sample->tid;\n\tint cpu = sample->cpu;\n\n\tif (pt->sync_switch) {\n\t\tstruct intel_pt_queue *ptq;\n\n\t\tptq = intel_pt_cpu_to_ptq(pt, cpu);\n\t\tif (ptq && ptq->sync_switch) {\n\t\t\tptq->next_tid = -1;\n\t\t\tswitch (ptq->switch_state) {\n\t\t\tcase INTEL_PT_SS_NOT_TRACING:\n\t\t\tcase INTEL_PT_SS_UNKNOWN:\n\t\t\tcase INTEL_PT_SS_TRACING:\n\t\t\t\tbreak;\n\t\t\tcase INTEL_PT_SS_EXPECTING_SWITCH_EVENT:\n\t\t\tcase INTEL_PT_SS_EXPECTING_SWITCH_IP:\n\t\t\t\tptq->switch_state = INTEL_PT_SS_TRACING;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (machine__get_current_tid(pt->machine, cpu) == tid)\n\t\treturn 0;\n\n\treturn machine__set_current_tid(pt->machine, cpu, pid, tid);\n}\n\nstatic int intel_pt_guest_context_switch(struct intel_pt *pt,\n\t\t\t\t\t union perf_event *event,\n\t\t\t\t\t struct perf_sample *sample)\n{\n\tbool out = event->header.misc & PERF_RECORD_MISC_SWITCH_OUT;\n\tstruct machines *machines = &pt->session->machines;\n\tstruct machine *machine = machines__find(machines, sample->machine_pid);\n\n\tpt->have_guest_sideband = true;\n\n\t \n\tpt->sync_switch_not_supported = true;\n\tif (pt->sync_switch)\n\t\tintel_pt_disable_sync_switch(pt);\n\n\tif (out)\n\t\treturn 0;\n\n\tif (!machine)\n\t\treturn -EINVAL;\n\n\treturn machine__set_current_tid(machine, sample->vcpu, sample->pid, sample->tid);\n}\n\nstatic int intel_pt_context_switch(struct intel_pt *pt, union perf_event *event,\n\t\t\t\t   struct perf_sample *sample)\n{\n\tbool out = event->header.misc & PERF_RECORD_MISC_SWITCH_OUT;\n\tpid_t pid, tid;\n\tint cpu, ret;\n\n\tif (perf_event__is_guest(event))\n\t\treturn intel_pt_guest_context_switch(pt, event, sample);\n\n\tcpu = sample->cpu;\n\n\tif (pt->have_sched_switch == 3) {\n\t\tif (!out)\n\t\t\treturn intel_pt_context_switch_in(pt, sample);\n\t\tif (event->header.type != PERF_RECORD_SWITCH_CPU_WIDE) {\n\t\t\tpr_err(\"Expecting CPU-wide context switch event\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpid = event->context_switch.next_prev_pid;\n\t\ttid = event->context_switch.next_prev_tid;\n\t} else {\n\t\tif (out)\n\t\t\treturn 0;\n\t\tpid = sample->pid;\n\t\ttid = sample->tid;\n\t}\n\n\tif (tid == -1)\n\t\tintel_pt_log(\"context_switch event has no tid\\n\");\n\n\tret = intel_pt_sync_switch(pt, cpu, tid, sample->time);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\treturn machine__set_current_tid(pt->machine, cpu, pid, tid);\n}\n\nstatic int intel_pt_process_itrace_start(struct intel_pt *pt,\n\t\t\t\t\t union perf_event *event,\n\t\t\t\t\t struct perf_sample *sample)\n{\n\tif (!pt->per_cpu_mmaps)\n\t\treturn 0;\n\n\tintel_pt_log(\"itrace_start: cpu %d pid %d tid %d time %\"PRIu64\" tsc %#\"PRIx64\"\\n\",\n\t\t     sample->cpu, event->itrace_start.pid,\n\t\t     event->itrace_start.tid, sample->time,\n\t\t     perf_time_to_tsc(sample->time, &pt->tc));\n\n\treturn machine__set_current_tid(pt->machine, sample->cpu,\n\t\t\t\t\tevent->itrace_start.pid,\n\t\t\t\t\tevent->itrace_start.tid);\n}\n\nstatic int intel_pt_process_aux_output_hw_id(struct intel_pt *pt,\n\t\t\t\t\t     union perf_event *event,\n\t\t\t\t\t     struct perf_sample *sample)\n{\n\tu64 hw_id = event->aux_output_hw_id.hw_id;\n\tstruct auxtrace_queue *queue;\n\tstruct intel_pt_queue *ptq;\n\tstruct evsel *evsel;\n\n\tqueue = auxtrace_queues__sample_queue(&pt->queues, sample, pt->session);\n\tevsel = evlist__id2evsel_strict(pt->session->evlist, sample->id);\n\tif (!queue || !queue->priv || !evsel || hw_id > INTEL_PT_MAX_PEBS) {\n\t\tpr_err(\"Bad AUX output hardware ID\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tptq = queue->priv;\n\n\tptq->pebs[hw_id].evsel = evsel;\n\tptq->pebs[hw_id].id = sample->id;\n\n\treturn 0;\n}\n\nstatic int intel_pt_find_map(struct thread *thread, u8 cpumode, u64 addr,\n\t\t\t     struct addr_location *al)\n{\n\tif (!al->map || addr < map__start(al->map) || addr >= map__end(al->map)) {\n\t\tif (!thread__find_map(thread, cpumode, addr, al))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int intel_pt_text_poke(struct intel_pt *pt, union perf_event *event)\n{\n\tu8 cpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\n\tu64 addr = event->text_poke.addr + event->text_poke.new_len - 1;\n\t \n\tint cnt = 4096 + event->text_poke.new_len;\n\tstruct thread *thread = pt->unknown_thread;\n\tstruct addr_location al;\n\tstruct machine *machine = pt->machine;\n\tstruct intel_pt_cache_entry *e;\n\tu64 offset;\n\tint ret = 0;\n\n\taddr_location__init(&al);\n\tif (!event->text_poke.new_len)\n\t\tgoto out;\n\n\tfor (; cnt; cnt--, addr--) {\n\t\tstruct dso *dso;\n\n\t\tif (intel_pt_find_map(thread, cpumode, addr, &al)) {\n\t\t\tif (addr < event->text_poke.addr)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdso = map__dso(al.map);\n\t\tif (!dso || !dso->auxtrace_cache)\n\t\t\tcontinue;\n\n\t\toffset = map__map_ip(al.map, addr);\n\n\t\te = intel_pt_cache_lookup(dso, machine, offset);\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif (addr + e->byte_cnt + e->length <= event->text_poke.addr) {\n\t\t\t \n\t\t\tif (e->branch != INTEL_PT_BR_NO_BRANCH)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tintel_pt_cache_invalidate(dso, machine, offset);\n\t\t\tintel_pt_log(\"Invalidated instruction cache for %s at %#\"PRIx64\"\\n\",\n\t\t\t\t     dso->long_name, addr);\n\t\t}\n\t}\nout:\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\nstatic int intel_pt_process_event(struct perf_session *session,\n\t\t\t\t  union perf_event *event,\n\t\t\t\t  struct perf_sample *sample,\n\t\t\t\t  struct perf_tool *tool)\n{\n\tstruct intel_pt *pt = container_of(session->auxtrace, struct intel_pt,\n\t\t\t\t\t   auxtrace);\n\tu64 timestamp;\n\tint err = 0;\n\n\tif (dump_trace)\n\t\treturn 0;\n\n\tif (!tool->ordered_events) {\n\t\tpr_err(\"Intel Processor Trace requires ordered events\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sample->time && sample->time != (u64)-1)\n\t\ttimestamp = perf_time_to_tsc(sample->time, &pt->tc);\n\telse\n\t\ttimestamp = 0;\n\n\tif (timestamp || pt->timeless_decoding) {\n\t\terr = intel_pt_update_queues(pt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pt->timeless_decoding) {\n\t\tif (pt->sampling_mode) {\n\t\t\tif (sample->aux_sample.size)\n\t\t\t\terr = intel_pt_process_timeless_sample(pt,\n\t\t\t\t\t\t\t\t       sample);\n\t\t} else if (event->header.type == PERF_RECORD_EXIT) {\n\t\t\terr = intel_pt_process_timeless_queues(pt,\n\t\t\t\t\t\t\t       event->fork.tid,\n\t\t\t\t\t\t\t       sample->time);\n\t\t}\n\t} else if (timestamp) {\n\t\tif (!pt->first_timestamp)\n\t\t\tintel_pt_first_timestamp(pt, timestamp);\n\t\terr = intel_pt_process_queues(pt, timestamp);\n\t}\n\tif (err)\n\t\treturn err;\n\n\tif (event->header.type == PERF_RECORD_SAMPLE) {\n\t\tif (pt->synth_opts.add_callchain && !sample->callchain)\n\t\t\tintel_pt_add_callchain(pt, sample);\n\t\tif (pt->synth_opts.add_last_branch && !sample->branch_stack)\n\t\t\tintel_pt_add_br_stack(pt, sample);\n\t}\n\n\tif (event->header.type == PERF_RECORD_AUX &&\n\t    (event->aux.flags & PERF_AUX_FLAG_TRUNCATED) &&\n\t    pt->synth_opts.errors) {\n\t\terr = intel_pt_lost(pt, sample);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n#ifdef HAVE_LIBTRACEEVENT\n\tif (pt->switch_evsel && event->header.type == PERF_RECORD_SAMPLE)\n\t\terr = intel_pt_process_switch(pt, sample);\n\telse\n#endif\n\tif (event->header.type == PERF_RECORD_ITRACE_START)\n\t\terr = intel_pt_process_itrace_start(pt, event, sample);\n\telse if (event->header.type == PERF_RECORD_AUX_OUTPUT_HW_ID)\n\t\terr = intel_pt_process_aux_output_hw_id(pt, event, sample);\n\telse if (event->header.type == PERF_RECORD_SWITCH ||\n\t\t event->header.type == PERF_RECORD_SWITCH_CPU_WIDE)\n\t\terr = intel_pt_context_switch(pt, event, sample);\n\n\tif (!err && event->header.type == PERF_RECORD_TEXT_POKE)\n\t\terr = intel_pt_text_poke(pt, event);\n\n\tif (intel_pt_enable_logging && intel_pt_log_events(pt, sample->time)) {\n\t\tintel_pt_log(\"event %u: cpu %d time %\"PRIu64\" tsc %#\"PRIx64\" \",\n\t\t\t     event->header.type, sample->cpu, sample->time, timestamp);\n\t\tintel_pt_log_event(event);\n\t}\n\n\treturn err;\n}\n\nstatic int intel_pt_flush(struct perf_session *session, struct perf_tool *tool)\n{\n\tstruct intel_pt *pt = container_of(session->auxtrace, struct intel_pt,\n\t\t\t\t\t   auxtrace);\n\tint ret;\n\n\tif (dump_trace)\n\t\treturn 0;\n\n\tif (!tool->ordered_events)\n\t\treturn -EINVAL;\n\n\tret = intel_pt_update_queues(pt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pt->timeless_decoding)\n\t\treturn intel_pt_process_timeless_queues(pt, -1,\n\t\t\t\t\t\t\tMAX_TIMESTAMP - 1);\n\n\treturn intel_pt_process_queues(pt, MAX_TIMESTAMP);\n}\n\nstatic void intel_pt_free_events(struct perf_session *session)\n{\n\tstruct intel_pt *pt = container_of(session->auxtrace, struct intel_pt,\n\t\t\t\t\t   auxtrace);\n\tstruct auxtrace_queues *queues = &pt->queues;\n\tunsigned int i;\n\n\tfor (i = 0; i < queues->nr_queues; i++) {\n\t\tintel_pt_free_queue(queues->queue_array[i].priv);\n\t\tqueues->queue_array[i].priv = NULL;\n\t}\n\tintel_pt_log_disable();\n\tauxtrace_queues__free(queues);\n}\n\nstatic void intel_pt_free(struct perf_session *session)\n{\n\tstruct intel_pt *pt = container_of(session->auxtrace, struct intel_pt,\n\t\t\t\t\t   auxtrace);\n\n\tauxtrace_heap__free(&pt->heap);\n\tintel_pt_free_events(session);\n\tsession->auxtrace = NULL;\n\tintel_pt_free_vmcs_info(pt);\n\tthread__put(pt->unknown_thread);\n\taddr_filters__exit(&pt->filts);\n\tzfree(&pt->chain);\n\tzfree(&pt->filter);\n\tzfree(&pt->time_ranges);\n\tzfree(&pt->br_stack);\n\tfree(pt);\n}\n\nstatic bool intel_pt_evsel_is_auxtrace(struct perf_session *session,\n\t\t\t\t       struct evsel *evsel)\n{\n\tstruct intel_pt *pt = container_of(session->auxtrace, struct intel_pt,\n\t\t\t\t\t   auxtrace);\n\n\treturn evsel->core.attr.type == pt->pmu_type;\n}\n\nstatic int intel_pt_process_auxtrace_event(struct perf_session *session,\n\t\t\t\t\t   union perf_event *event,\n\t\t\t\t\t   struct perf_tool *tool __maybe_unused)\n{\n\tstruct intel_pt *pt = container_of(session->auxtrace, struct intel_pt,\n\t\t\t\t\t   auxtrace);\n\n\tif (!pt->data_queued) {\n\t\tstruct auxtrace_buffer *buffer;\n\t\toff_t data_offset;\n\t\tint fd = perf_data__fd(session->data);\n\t\tint err;\n\n\t\tif (perf_data__is_pipe(session->data)) {\n\t\t\tdata_offset = 0;\n\t\t} else {\n\t\t\tdata_offset = lseek(fd, 0, SEEK_CUR);\n\t\t\tif (data_offset == -1)\n\t\t\t\treturn -errno;\n\t\t}\n\n\t\terr = auxtrace_queues__add_event(&pt->queues, session, event,\n\t\t\t\t\t\t data_offset, &buffer);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (dump_trace) {\n\t\t\tif (auxtrace_buffer__get_data(buffer, fd)) {\n\t\t\t\tintel_pt_dump_event(pt, buffer->data,\n\t\t\t\t\t\t    buffer->size);\n\t\t\t\tauxtrace_buffer__put_data(buffer);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_pt_queue_data(struct perf_session *session,\n\t\t\t       struct perf_sample *sample,\n\t\t\t       union perf_event *event, u64 data_offset)\n{\n\tstruct intel_pt *pt = container_of(session->auxtrace, struct intel_pt,\n\t\t\t\t\t   auxtrace);\n\tu64 timestamp;\n\n\tif (event) {\n\t\treturn auxtrace_queues__add_event(&pt->queues, session, event,\n\t\t\t\t\t\t  data_offset, NULL);\n\t}\n\n\tif (sample->time && sample->time != (u64)-1)\n\t\ttimestamp = perf_time_to_tsc(sample->time, &pt->tc);\n\telse\n\t\ttimestamp = 0;\n\n\treturn auxtrace_queues__add_sample(&pt->queues, session, sample,\n\t\t\t\t\t   data_offset, timestamp);\n}\n\nstruct intel_pt_synth {\n\tstruct perf_tool dummy_tool;\n\tstruct perf_session *session;\n};\n\nstatic int intel_pt_event_synth(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample __maybe_unused,\n\t\t\t\tstruct machine *machine __maybe_unused)\n{\n\tstruct intel_pt_synth *intel_pt_synth =\n\t\t\tcontainer_of(tool, struct intel_pt_synth, dummy_tool);\n\n\treturn perf_session__deliver_synth_event(intel_pt_synth->session, event,\n\t\t\t\t\t\t NULL);\n}\n\nstatic int intel_pt_synth_event(struct perf_session *session, const char *name,\n\t\t\t\tstruct perf_event_attr *attr, u64 id)\n{\n\tstruct intel_pt_synth intel_pt_synth;\n\tint err;\n\n\tpr_debug(\"Synthesizing '%s' event with id %\" PRIu64 \" sample type %#\" PRIx64 \"\\n\",\n\t\t name, id, (u64)attr->sample_type);\n\n\tmemset(&intel_pt_synth, 0, sizeof(struct intel_pt_synth));\n\tintel_pt_synth.session = session;\n\n\terr = perf_event__synthesize_attr(&intel_pt_synth.dummy_tool, attr, 1,\n\t\t\t\t\t  &id, intel_pt_event_synth);\n\tif (err)\n\t\tpr_err(\"%s: failed to synthesize '%s' event type\\n\",\n\t\t       __func__, name);\n\n\treturn err;\n}\n\nstatic void intel_pt_set_event_name(struct evlist *evlist, u64 id,\n\t\t\t\t    const char *name)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.id && evsel->core.id[0] == id) {\n\t\t\tif (evsel->name)\n\t\t\t\tzfree(&evsel->name);\n\t\t\tevsel->name = strdup(name);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct evsel *intel_pt_evsel(struct intel_pt *pt,\n\t\t\t\t\t struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.type == pt->pmu_type && evsel->core.ids)\n\t\t\treturn evsel;\n\t}\n\n\treturn NULL;\n}\n\nstatic int intel_pt_synth_events(struct intel_pt *pt,\n\t\t\t\t struct perf_session *session)\n{\n\tstruct evlist *evlist = session->evlist;\n\tstruct evsel *evsel = intel_pt_evsel(pt, evlist);\n\tstruct perf_event_attr attr;\n\tu64 id;\n\tint err;\n\n\tif (!evsel) {\n\t\tpr_debug(\"There are no selected events with Intel Processor Trace data\\n\");\n\t\treturn 0;\n\t}\n\n\tmemset(&attr, 0, sizeof(struct perf_event_attr));\n\tattr.size = sizeof(struct perf_event_attr);\n\tattr.type = PERF_TYPE_HARDWARE;\n\tattr.sample_type = evsel->core.attr.sample_type & PERF_SAMPLE_MASK;\n\tattr.sample_type |= PERF_SAMPLE_IP | PERF_SAMPLE_TID |\n\t\t\t    PERF_SAMPLE_PERIOD;\n\tif (pt->timeless_decoding)\n\t\tattr.sample_type &= ~(u64)PERF_SAMPLE_TIME;\n\telse\n\t\tattr.sample_type |= PERF_SAMPLE_TIME;\n\tif (!pt->per_cpu_mmaps)\n\t\tattr.sample_type &= ~(u64)PERF_SAMPLE_CPU;\n\tattr.exclude_user = evsel->core.attr.exclude_user;\n\tattr.exclude_kernel = evsel->core.attr.exclude_kernel;\n\tattr.exclude_hv = evsel->core.attr.exclude_hv;\n\tattr.exclude_host = evsel->core.attr.exclude_host;\n\tattr.exclude_guest = evsel->core.attr.exclude_guest;\n\tattr.sample_id_all = evsel->core.attr.sample_id_all;\n\tattr.read_format = evsel->core.attr.read_format;\n\n\tid = evsel->core.id[0] + 1000000000;\n\tif (!id)\n\t\tid = 1;\n\n\tif (pt->synth_opts.branches) {\n\t\tattr.config = PERF_COUNT_HW_BRANCH_INSTRUCTIONS;\n\t\tattr.sample_period = 1;\n\t\tattr.sample_type |= PERF_SAMPLE_ADDR;\n\t\terr = intel_pt_synth_event(session, \"branches\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->sample_branches = true;\n\t\tpt->branches_sample_type = attr.sample_type;\n\t\tpt->branches_id = id;\n\t\tid += 1;\n\t\tattr.sample_type &= ~(u64)PERF_SAMPLE_ADDR;\n\t}\n\n\tif (pt->synth_opts.callchain)\n\t\tattr.sample_type |= PERF_SAMPLE_CALLCHAIN;\n\tif (pt->synth_opts.last_branch) {\n\t\tattr.sample_type |= PERF_SAMPLE_BRANCH_STACK;\n\t\t \n\t\tattr.branch_sample_type |= PERF_SAMPLE_BRANCH_HW_INDEX;\n\t}\n\n\tif (pt->synth_opts.instructions) {\n\t\tattr.config = PERF_COUNT_HW_INSTRUCTIONS;\n\t\tif (pt->synth_opts.period_type == PERF_ITRACE_PERIOD_NANOSECS)\n\t\t\tattr.sample_period =\n\t\t\t\tintel_pt_ns_to_ticks(pt, pt->synth_opts.period);\n\t\telse\n\t\t\tattr.sample_period = pt->synth_opts.period;\n\t\terr = intel_pt_synth_event(session, \"instructions\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->sample_instructions = true;\n\t\tpt->instructions_sample_type = attr.sample_type;\n\t\tpt->instructions_id = id;\n\t\tid += 1;\n\t}\n\n\tif (pt->synth_opts.cycles) {\n\t\tattr.config = PERF_COUNT_HW_CPU_CYCLES;\n\t\tif (pt->synth_opts.period_type == PERF_ITRACE_PERIOD_NANOSECS)\n\t\t\tattr.sample_period =\n\t\t\t\tintel_pt_ns_to_ticks(pt, pt->synth_opts.period);\n\t\telse\n\t\t\tattr.sample_period = pt->synth_opts.period;\n\t\terr = intel_pt_synth_event(session, \"cycles\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->sample_cycles = true;\n\t\tpt->cycles_sample_type = attr.sample_type;\n\t\tpt->cycles_id = id;\n\t\tid += 1;\n\t}\n\n\tattr.sample_type &= ~(u64)PERF_SAMPLE_PERIOD;\n\tattr.sample_period = 1;\n\n\tif (pt->synth_opts.transactions) {\n\t\tattr.config = PERF_COUNT_HW_INSTRUCTIONS;\n\t\terr = intel_pt_synth_event(session, \"transactions\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->sample_transactions = true;\n\t\tpt->transactions_sample_type = attr.sample_type;\n\t\tpt->transactions_id = id;\n\t\tintel_pt_set_event_name(evlist, id, \"transactions\");\n\t\tid += 1;\n\t}\n\n\tattr.type = PERF_TYPE_SYNTH;\n\tattr.sample_type |= PERF_SAMPLE_RAW;\n\n\tif (pt->synth_opts.ptwrites) {\n\t\tattr.config = PERF_SYNTH_INTEL_PTWRITE;\n\t\terr = intel_pt_synth_event(session, \"ptwrite\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->sample_ptwrites = true;\n\t\tpt->ptwrites_sample_type = attr.sample_type;\n\t\tpt->ptwrites_id = id;\n\t\tintel_pt_set_event_name(evlist, id, \"ptwrite\");\n\t\tid += 1;\n\t}\n\n\tif (pt->synth_opts.pwr_events) {\n\t\tpt->sample_pwr_events = true;\n\t\tpt->pwr_events_sample_type = attr.sample_type;\n\n\t\tattr.config = PERF_SYNTH_INTEL_CBR;\n\t\terr = intel_pt_synth_event(session, \"cbr\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->cbr_id = id;\n\t\tintel_pt_set_event_name(evlist, id, \"cbr\");\n\t\tid += 1;\n\n\t\tattr.config = PERF_SYNTH_INTEL_PSB;\n\t\terr = intel_pt_synth_event(session, \"psb\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->psb_id = id;\n\t\tintel_pt_set_event_name(evlist, id, \"psb\");\n\t\tid += 1;\n\t}\n\n\tif (pt->synth_opts.pwr_events && (evsel->core.attr.config & INTEL_PT_CFG_PWR_EVT_EN)) {\n\t\tattr.config = PERF_SYNTH_INTEL_MWAIT;\n\t\terr = intel_pt_synth_event(session, \"mwait\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->mwait_id = id;\n\t\tintel_pt_set_event_name(evlist, id, \"mwait\");\n\t\tid += 1;\n\n\t\tattr.config = PERF_SYNTH_INTEL_PWRE;\n\t\terr = intel_pt_synth_event(session, \"pwre\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->pwre_id = id;\n\t\tintel_pt_set_event_name(evlist, id, \"pwre\");\n\t\tid += 1;\n\n\t\tattr.config = PERF_SYNTH_INTEL_EXSTOP;\n\t\terr = intel_pt_synth_event(session, \"exstop\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->exstop_id = id;\n\t\tintel_pt_set_event_name(evlist, id, \"exstop\");\n\t\tid += 1;\n\n\t\tattr.config = PERF_SYNTH_INTEL_PWRX;\n\t\terr = intel_pt_synth_event(session, \"pwrx\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->pwrx_id = id;\n\t\tintel_pt_set_event_name(evlist, id, \"pwrx\");\n\t\tid += 1;\n\t}\n\n\tif (pt->synth_opts.intr_events && (evsel->core.attr.config & INTEL_PT_CFG_EVT_EN)) {\n\t\tattr.config = PERF_SYNTH_INTEL_EVT;\n\t\terr = intel_pt_synth_event(session, \"evt\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->evt_sample_type = attr.sample_type;\n\t\tpt->evt_id = id;\n\t\tintel_pt_set_event_name(evlist, id, \"evt\");\n\t\tid += 1;\n\t}\n\n\tif (pt->synth_opts.intr_events && pt->cap_event_trace) {\n\t\tattr.config = PERF_SYNTH_INTEL_IFLAG_CHG;\n\t\terr = intel_pt_synth_event(session, \"iflag\", &attr, id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpt->iflag_chg_sample_type = attr.sample_type;\n\t\tpt->iflag_chg_id = id;\n\t\tintel_pt_set_event_name(evlist, id, \"iflag\");\n\t\tid += 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void intel_pt_setup_pebs_events(struct intel_pt *pt)\n{\n\tstruct evsel *evsel;\n\n\tif (!pt->synth_opts.other_events)\n\t\treturn;\n\n\tevlist__for_each_entry(pt->session->evlist, evsel) {\n\t\tif (evsel->core.attr.aux_output && evsel->core.id) {\n\t\t\tif (pt->single_pebs) {\n\t\t\t\tpt->single_pebs = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpt->single_pebs = true;\n\t\t\tpt->sample_pebs = true;\n\t\t\tpt->pebs_evsel = evsel;\n\t\t}\n\t}\n}\n\nstatic struct evsel *intel_pt_find_sched_switch(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry_reverse(evlist, evsel) {\n\t\tconst char *name = evsel__name(evsel);\n\n\t\tif (!strcmp(name, \"sched:sched_switch\"))\n\t\t\treturn evsel;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool intel_pt_find_switch(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.context_switch)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int intel_pt_perf_config(const char *var, const char *value, void *data)\n{\n\tstruct intel_pt *pt = data;\n\n\tif (!strcmp(var, \"intel-pt.mispred-all\"))\n\t\tpt->mispred_all = perf_config_bool(var, value);\n\n\tif (!strcmp(var, \"intel-pt.max-loops\"))\n\t\tperf_config_int(&pt->max_loops, var, value);\n\n\treturn 0;\n}\n\n \nstatic u64 intel_pt_tsc_start(u64 ns, struct intel_pt *pt)\n{\n\tu64 tsc, tm;\n\n\ttsc = perf_time_to_tsc(ns, &pt->tc);\n\n\twhile (1) {\n\t\ttm = tsc_to_perf_time(tsc, &pt->tc);\n\t\tif (tm < ns)\n\t\t\tbreak;\n\t\ttsc -= 1;\n\t}\n\n\twhile (tm < ns)\n\t\ttm = tsc_to_perf_time(++tsc, &pt->tc);\n\n\treturn tsc;\n}\n\n \nstatic u64 intel_pt_tsc_end(u64 ns, struct intel_pt *pt)\n{\n\tu64 tsc, tm;\n\n\ttsc = perf_time_to_tsc(ns, &pt->tc);\n\n\twhile (1) {\n\t\ttm = tsc_to_perf_time(tsc, &pt->tc);\n\t\tif (tm > ns)\n\t\t\tbreak;\n\t\ttsc += 1;\n\t}\n\n\twhile (tm > ns)\n\t\ttm = tsc_to_perf_time(--tsc, &pt->tc);\n\n\treturn tsc;\n}\n\nstatic int intel_pt_setup_time_ranges(struct intel_pt *pt,\n\t\t\t\t      struct itrace_synth_opts *opts)\n{\n\tstruct perf_time_interval *p = opts->ptime_range;\n\tint n = opts->range_num;\n\tint i;\n\n\tif (!n || !p || pt->timeless_decoding)\n\t\treturn 0;\n\n\tpt->time_ranges = calloc(n, sizeof(struct range));\n\tif (!pt->time_ranges)\n\t\treturn -ENOMEM;\n\n\tpt->range_cnt = n;\n\n\tintel_pt_log(\"%s: %u range(s)\\n\", __func__, n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct range *r = &pt->time_ranges[i];\n\t\tu64 ts = p[i].start;\n\t\tu64 te = p[i].end;\n\n\t\t \n\t\tr->start = ts ? intel_pt_tsc_start(ts, pt) : 0;\n\t\tr->end   = te ? intel_pt_tsc_end(te, pt) : 0;\n\n\t\tintel_pt_log(\"range %d: perf time interval: %\"PRIu64\" to %\"PRIu64\"\\n\",\n\t\t\t     i, ts, te);\n\t\tintel_pt_log(\"range %d: TSC time interval: %#\"PRIx64\" to %#\"PRIx64\"\\n\",\n\t\t\t     i, r->start, r->end);\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_pt_parse_vm_tm_corr_arg(struct intel_pt *pt, char **args)\n{\n\tstruct intel_pt_vmcs_info *vmcs_info;\n\tu64 tsc_offset, vmcs;\n\tchar *p = *args;\n\n\terrno = 0;\n\n\tp = skip_spaces(p);\n\tif (!*p)\n\t\treturn 1;\n\n\ttsc_offset = strtoull(p, &p, 0);\n\tif (errno)\n\t\treturn -errno;\n\tp = skip_spaces(p);\n\tif (*p != ':') {\n\t\tpt->dflt_tsc_offset = tsc_offset;\n\t\t*args = p;\n\t\treturn 0;\n\t}\n\tp += 1;\n\twhile (1) {\n\t\tvmcs = strtoull(p, &p, 0);\n\t\tif (errno)\n\t\t\treturn -errno;\n\t\tif (!vmcs)\n\t\t\treturn -EINVAL;\n\t\tvmcs_info = intel_pt_findnew_vmcs(&pt->vmcs_info, vmcs, tsc_offset);\n\t\tif (!vmcs_info)\n\t\t\treturn -ENOMEM;\n\t\tp = skip_spaces(p);\n\t\tif (*p != ',')\n\t\t\tbreak;\n\t\tp += 1;\n\t}\n\t*args = p;\n\treturn 0;\n}\n\nstatic int intel_pt_parse_vm_tm_corr_args(struct intel_pt *pt)\n{\n\tchar *args = pt->synth_opts.vm_tm_corr_args;\n\tint ret;\n\n\tif (!args)\n\t\treturn 0;\n\n\tdo {\n\t\tret = intel_pt_parse_vm_tm_corr_arg(pt, &args);\n\t} while (!ret);\n\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to parse VM Time Correlation options\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const intel_pt_info_fmts[] = {\n\t[INTEL_PT_PMU_TYPE]\t\t= \"  PMU Type            %\"PRId64\"\\n\",\n\t[INTEL_PT_TIME_SHIFT]\t\t= \"  Time Shift          %\"PRIu64\"\\n\",\n\t[INTEL_PT_TIME_MULT]\t\t= \"  Time Muliplier      %\"PRIu64\"\\n\",\n\t[INTEL_PT_TIME_ZERO]\t\t= \"  Time Zero           %\"PRIu64\"\\n\",\n\t[INTEL_PT_CAP_USER_TIME_ZERO]\t= \"  Cap Time Zero       %\"PRId64\"\\n\",\n\t[INTEL_PT_TSC_BIT]\t\t= \"  TSC bit             %#\"PRIx64\"\\n\",\n\t[INTEL_PT_NORETCOMP_BIT]\t= \"  NoRETComp bit       %#\"PRIx64\"\\n\",\n\t[INTEL_PT_HAVE_SCHED_SWITCH]\t= \"  Have sched_switch   %\"PRId64\"\\n\",\n\t[INTEL_PT_SNAPSHOT_MODE]\t= \"  Snapshot mode       %\"PRId64\"\\n\",\n\t[INTEL_PT_PER_CPU_MMAPS]\t= \"  Per-cpu maps        %\"PRId64\"\\n\",\n\t[INTEL_PT_MTC_BIT]\t\t= \"  MTC bit             %#\"PRIx64\"\\n\",\n\t[INTEL_PT_MTC_FREQ_BITS]\t= \"  MTC freq bits       %#\"PRIx64\"\\n\",\n\t[INTEL_PT_TSC_CTC_N]\t\t= \"  TSC:CTC numerator   %\"PRIu64\"\\n\",\n\t[INTEL_PT_TSC_CTC_D]\t\t= \"  TSC:CTC denominator %\"PRIu64\"\\n\",\n\t[INTEL_PT_CYC_BIT]\t\t= \"  CYC bit             %#\"PRIx64\"\\n\",\n\t[INTEL_PT_MAX_NONTURBO_RATIO]\t= \"  Max non-turbo ratio %\"PRIu64\"\\n\",\n\t[INTEL_PT_FILTER_STR_LEN]\t= \"  Filter string len.  %\"PRIu64\"\\n\",\n};\n\nstatic void intel_pt_print_info(__u64 *arr, int start, int finish)\n{\n\tint i;\n\n\tif (!dump_trace)\n\t\treturn;\n\n\tfor (i = start; i <= finish; i++) {\n\t\tconst char *fmt = intel_pt_info_fmts[i];\n\n\t\tif (fmt)\n\t\t\tfprintf(stdout, fmt, arr[i]);\n\t}\n}\n\nstatic void intel_pt_print_info_str(const char *name, const char *str)\n{\n\tif (!dump_trace)\n\t\treturn;\n\n\tfprintf(stdout, \"  %-20s%s\\n\", name, str ? str : \"\");\n}\n\nstatic bool intel_pt_has(struct perf_record_auxtrace_info *auxtrace_info, int pos)\n{\n\treturn auxtrace_info->header.size >=\n\t\tsizeof(struct perf_record_auxtrace_info) + (sizeof(u64) * (pos + 1));\n}\n\nint intel_pt_process_auxtrace_info(union perf_event *event,\n\t\t\t\t   struct perf_session *session)\n{\n\tstruct perf_record_auxtrace_info *auxtrace_info = &event->auxtrace_info;\n\tsize_t min_sz = sizeof(u64) * INTEL_PT_PER_CPU_MMAPS;\n\tstruct intel_pt *pt;\n\tvoid *info_end;\n\t__u64 *info;\n\tint err;\n\n\tif (auxtrace_info->header.size < sizeof(struct perf_record_auxtrace_info) +\n\t\t\t\t\tmin_sz)\n\t\treturn -EINVAL;\n\n\tpt = zalloc(sizeof(struct intel_pt));\n\tif (!pt)\n\t\treturn -ENOMEM;\n\n\tpt->vmcs_info = RB_ROOT;\n\n\taddr_filters__init(&pt->filts);\n\n\terr = perf_config(intel_pt_perf_config, pt);\n\tif (err)\n\t\tgoto err_free;\n\n\terr = auxtrace_queues__init(&pt->queues);\n\tif (err)\n\t\tgoto err_free;\n\n\tif (session->itrace_synth_opts->set) {\n\t\tpt->synth_opts = *session->itrace_synth_opts;\n\t} else {\n\t\tstruct itrace_synth_opts *opts = session->itrace_synth_opts;\n\n\t\titrace_synth_opts__set_default(&pt->synth_opts, opts->default_no_sample);\n\t\tif (!opts->default_no_sample && !opts->inject) {\n\t\t\tpt->synth_opts.branches = false;\n\t\t\tpt->synth_opts.callchain = true;\n\t\t\tpt->synth_opts.add_callchain = true;\n\t\t}\n\t\tpt->synth_opts.thread_stack = opts->thread_stack;\n\t}\n\n\tif (!(pt->synth_opts.log_plus_flags & AUXTRACE_LOG_FLG_USE_STDOUT))\n\t\tintel_pt_log_set_name(INTEL_PT_PMU_NAME);\n\n\tpt->session = session;\n\tpt->machine = &session->machines.host;  \n\tpt->auxtrace_type = auxtrace_info->type;\n\tpt->pmu_type = auxtrace_info->priv[INTEL_PT_PMU_TYPE];\n\tpt->tc.time_shift = auxtrace_info->priv[INTEL_PT_TIME_SHIFT];\n\tpt->tc.time_mult = auxtrace_info->priv[INTEL_PT_TIME_MULT];\n\tpt->tc.time_zero = auxtrace_info->priv[INTEL_PT_TIME_ZERO];\n\tpt->cap_user_time_zero = auxtrace_info->priv[INTEL_PT_CAP_USER_TIME_ZERO];\n\tpt->tsc_bit = auxtrace_info->priv[INTEL_PT_TSC_BIT];\n\tpt->noretcomp_bit = auxtrace_info->priv[INTEL_PT_NORETCOMP_BIT];\n\tpt->have_sched_switch = auxtrace_info->priv[INTEL_PT_HAVE_SCHED_SWITCH];\n\tpt->snapshot_mode = auxtrace_info->priv[INTEL_PT_SNAPSHOT_MODE];\n\tpt->per_cpu_mmaps = auxtrace_info->priv[INTEL_PT_PER_CPU_MMAPS];\n\tintel_pt_print_info(&auxtrace_info->priv[0], INTEL_PT_PMU_TYPE,\n\t\t\t    INTEL_PT_PER_CPU_MMAPS);\n\n\tif (intel_pt_has(auxtrace_info, INTEL_PT_CYC_BIT)) {\n\t\tpt->mtc_bit = auxtrace_info->priv[INTEL_PT_MTC_BIT];\n\t\tpt->mtc_freq_bits = auxtrace_info->priv[INTEL_PT_MTC_FREQ_BITS];\n\t\tpt->tsc_ctc_ratio_n = auxtrace_info->priv[INTEL_PT_TSC_CTC_N];\n\t\tpt->tsc_ctc_ratio_d = auxtrace_info->priv[INTEL_PT_TSC_CTC_D];\n\t\tpt->cyc_bit = auxtrace_info->priv[INTEL_PT_CYC_BIT];\n\t\tintel_pt_print_info(&auxtrace_info->priv[0], INTEL_PT_MTC_BIT,\n\t\t\t\t    INTEL_PT_CYC_BIT);\n\t}\n\n\tif (intel_pt_has(auxtrace_info, INTEL_PT_MAX_NONTURBO_RATIO)) {\n\t\tpt->max_non_turbo_ratio =\n\t\t\tauxtrace_info->priv[INTEL_PT_MAX_NONTURBO_RATIO];\n\t\tintel_pt_print_info(&auxtrace_info->priv[0],\n\t\t\t\t    INTEL_PT_MAX_NONTURBO_RATIO,\n\t\t\t\t    INTEL_PT_MAX_NONTURBO_RATIO);\n\t}\n\n\tinfo = &auxtrace_info->priv[INTEL_PT_FILTER_STR_LEN] + 1;\n\tinfo_end = (void *)auxtrace_info + auxtrace_info->header.size;\n\n\tif (intel_pt_has(auxtrace_info, INTEL_PT_FILTER_STR_LEN)) {\n\t\tsize_t len;\n\n\t\tlen = auxtrace_info->priv[INTEL_PT_FILTER_STR_LEN];\n\t\tintel_pt_print_info(&auxtrace_info->priv[0],\n\t\t\t\t    INTEL_PT_FILTER_STR_LEN,\n\t\t\t\t    INTEL_PT_FILTER_STR_LEN);\n\t\tif (len) {\n\t\t\tconst char *filter = (const char *)info;\n\n\t\t\tlen = roundup(len + 1, 8);\n\t\t\tinfo += len >> 3;\n\t\t\tif ((void *)info > info_end) {\n\t\t\t\tpr_err(\"%s: bad filter string length\\n\", __func__);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_free_queues;\n\t\t\t}\n\t\t\tpt->filter = memdup(filter, len);\n\t\t\tif (!pt->filter) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_free_queues;\n\t\t\t}\n\t\t\tif (session->header.needs_swap)\n\t\t\t\tmem_bswap_64(pt->filter, len);\n\t\t\tif (pt->filter[len - 1]) {\n\t\t\t\tpr_err(\"%s: filter string not null terminated\\n\", __func__);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_free_queues;\n\t\t\t}\n\t\t\terr = addr_filters__parse_bare_filter(&pt->filts,\n\t\t\t\t\t\t\t      filter);\n\t\t\tif (err)\n\t\t\t\tgoto err_free_queues;\n\t\t}\n\t\tintel_pt_print_info_str(\"Filter string\", pt->filter);\n\t}\n\n\tif ((void *)info < info_end) {\n\t\tpt->cap_event_trace = *info++;\n\t\tif (dump_trace)\n\t\t\tfprintf(stdout, \"  Cap Event Trace     %d\\n\",\n\t\t\t\tpt->cap_event_trace);\n\t}\n\n\tpt->timeless_decoding = intel_pt_timeless_decoding(pt);\n\tif (pt->timeless_decoding && !pt->tc.time_mult)\n\t\tpt->tc.time_mult = 1;\n\tpt->have_tsc = intel_pt_have_tsc(pt);\n\tpt->sampling_mode = intel_pt_sampling_mode(pt);\n\tpt->est_tsc = !pt->timeless_decoding;\n\n\tif (pt->synth_opts.vm_time_correlation) {\n\t\tif (pt->timeless_decoding) {\n\t\t\tpr_err(\"Intel PT has no time information for VM Time Correlation\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free_queues;\n\t\t}\n\t\tif (session->itrace_synth_opts->ptime_range) {\n\t\t\tpr_err(\"Time ranges cannot be specified with VM Time Correlation\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free_queues;\n\t\t}\n\t\t \n\t\tif (!intel_pt_have_mtc(pt)) {\n\t\t\tpr_err(\"MTC packets must have been enabled for VM Time Correlation\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free_queues;\n\t\t}\n\t\terr = intel_pt_parse_vm_tm_corr_args(pt);\n\t\tif (err)\n\t\t\tgoto err_free_queues;\n\t}\n\n\tpt->unknown_thread = thread__new(999999999, 999999999);\n\tif (!pt->unknown_thread) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_queues;\n\t}\n\n\terr = thread__set_comm(pt->unknown_thread, \"unknown\", 0);\n\tif (err)\n\t\tgoto err_delete_thread;\n\tif (thread__init_maps(pt->unknown_thread, pt->machine)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_delete_thread;\n\t}\n\n\tpt->auxtrace.process_event = intel_pt_process_event;\n\tpt->auxtrace.process_auxtrace_event = intel_pt_process_auxtrace_event;\n\tpt->auxtrace.queue_data = intel_pt_queue_data;\n\tpt->auxtrace.dump_auxtrace_sample = intel_pt_dump_sample;\n\tpt->auxtrace.flush_events = intel_pt_flush;\n\tpt->auxtrace.free_events = intel_pt_free_events;\n\tpt->auxtrace.free = intel_pt_free;\n\tpt->auxtrace.evsel_is_auxtrace = intel_pt_evsel_is_auxtrace;\n\tsession->auxtrace = &pt->auxtrace;\n\n\tif (dump_trace)\n\t\treturn 0;\n\n\tif (pt->have_sched_switch == 1) {\n\t\tpt->switch_evsel = intel_pt_find_sched_switch(session->evlist);\n\t\tif (!pt->switch_evsel) {\n\t\t\tpr_err(\"%s: missing sched_switch event\\n\", __func__);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_delete_thread;\n\t\t}\n\t} else if (pt->have_sched_switch == 2 &&\n\t\t   !intel_pt_find_switch(session->evlist)) {\n\t\tpr_err(\"%s: missing context_switch attribute flag\\n\", __func__);\n\t\terr = -EINVAL;\n\t\tgoto err_delete_thread;\n\t}\n\n\tif (pt->synth_opts.log) {\n\t\tbool log_on_error = pt->synth_opts.log_plus_flags & AUXTRACE_LOG_FLG_ON_ERROR;\n\t\tunsigned int log_on_error_size = pt->synth_opts.log_on_error_size;\n\n\t\tintel_pt_log_enable(log_on_error, log_on_error_size);\n\t}\n\n\t \n\tif (pt->tc.time_mult) {\n\t\tu64 tsc_freq = intel_pt_ns_to_ticks(pt, 1000000000);\n\n\t\tif (!pt->max_non_turbo_ratio)\n\t\t\tpt->max_non_turbo_ratio =\n\t\t\t\t\t(tsc_freq + 50000000) / 100000000;\n\t\tintel_pt_log(\"TSC frequency %\"PRIu64\"\\n\", tsc_freq);\n\t\tintel_pt_log(\"Maximum non-turbo ratio %u\\n\",\n\t\t\t     pt->max_non_turbo_ratio);\n\t\tpt->cbr2khz = tsc_freq / pt->max_non_turbo_ratio / 1000;\n\t}\n\n\terr = intel_pt_setup_time_ranges(pt, session->itrace_synth_opts);\n\tif (err)\n\t\tgoto err_delete_thread;\n\n\tif (pt->synth_opts.calls)\n\t\tpt->branches_filter |= PERF_IP_FLAG_CALL | PERF_IP_FLAG_ASYNC |\n\t\t\t\t       PERF_IP_FLAG_TRACE_END;\n\tif (pt->synth_opts.returns)\n\t\tpt->branches_filter |= PERF_IP_FLAG_RETURN |\n\t\t\t\t       PERF_IP_FLAG_TRACE_BEGIN;\n\n\tif ((pt->synth_opts.callchain || pt->synth_opts.add_callchain) &&\n\t    !symbol_conf.use_callchain) {\n\t\tsymbol_conf.use_callchain = true;\n\t\tif (callchain_register_param(&callchain_param) < 0) {\n\t\t\tsymbol_conf.use_callchain = false;\n\t\t\tpt->synth_opts.callchain = false;\n\t\t\tpt->synth_opts.add_callchain = false;\n\t\t}\n\t}\n\n\tif (pt->synth_opts.add_callchain) {\n\t\terr = intel_pt_callchain_init(pt);\n\t\tif (err)\n\t\t\tgoto err_delete_thread;\n\t}\n\n\tif (pt->synth_opts.last_branch || pt->synth_opts.add_last_branch) {\n\t\tpt->br_stack_sz = pt->synth_opts.last_branch_sz;\n\t\tpt->br_stack_sz_plus = pt->br_stack_sz;\n\t}\n\n\tif (pt->synth_opts.add_last_branch) {\n\t\terr = intel_pt_br_stack_init(pt);\n\t\tif (err)\n\t\t\tgoto err_delete_thread;\n\t\t \n\t\tif (intel_pt_tracing_kernel(pt))\n\t\t\tpt->br_stack_sz_plus += 1024;\n\t\telse\n\t\t\tpt->br_stack_sz_plus += 1;\n\t}\n\n\tpt->use_thread_stack = pt->synth_opts.callchain ||\n\t\t\t       pt->synth_opts.add_callchain ||\n\t\t\t       pt->synth_opts.thread_stack ||\n\t\t\t       pt->synth_opts.last_branch ||\n\t\t\t       pt->synth_opts.add_last_branch;\n\n\tpt->callstack = pt->synth_opts.callchain ||\n\t\t\tpt->synth_opts.add_callchain ||\n\t\t\tpt->synth_opts.thread_stack;\n\n\terr = intel_pt_synth_events(pt, session);\n\tif (err)\n\t\tgoto err_delete_thread;\n\n\tintel_pt_setup_pebs_events(pt);\n\n\tif (perf_data__is_pipe(session->data)) {\n\t\tpr_warning(\"WARNING: Intel PT with pipe mode is not recommended.\\n\"\n\t\t\t   \"         The output cannot relied upon.  In particular,\\n\"\n\t\t\t   \"         timestamps and the order of events may be incorrect.\\n\");\n\t}\n\n\tif (pt->sampling_mode || list_empty(&session->auxtrace_index))\n\t\terr = auxtrace_queue_data(session, true, true);\n\telse\n\t\terr = auxtrace_queues__process_index(&pt->queues, session);\n\tif (err)\n\t\tgoto err_delete_thread;\n\n\tif (pt->queues.populated)\n\t\tpt->data_queued = true;\n\n\tif (pt->timeless_decoding)\n\t\tpr_debug2(\"Intel PT decoding without timestamps\\n\");\n\n\treturn 0;\n\nerr_delete_thread:\n\tzfree(&pt->chain);\n\tthread__zput(pt->unknown_thread);\nerr_free_queues:\n\tintel_pt_log_disable();\n\tauxtrace_queues__free(&pt->queues);\n\tsession->auxtrace = NULL;\nerr_free:\n\taddr_filters__exit(&pt->filts);\n\tzfree(&pt->filter);\n\tzfree(&pt->time_ranges);\n\tfree(pt);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}