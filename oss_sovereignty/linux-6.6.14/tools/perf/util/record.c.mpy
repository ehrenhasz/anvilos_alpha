{
  "module_name": "record.c",
  "hash_id": "da458d0deb1c4cdb79674efa251648437bfe5fa3135e396429aaa0701b44f059",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/record.c",
  "human_readable_source": "\n#include \"debug.h\"\n#include \"evlist.h\"\n#include \"evsel.h\"\n#include \"evsel_config.h\"\n#include \"parse-events.h\"\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <api/fs/fs.h>\n#include <subcmd/parse-options.h>\n#include <perf/cpumap.h>\n#include \"cloexec.h\"\n#include \"util/perf_api_probe.h\"\n#include \"record.h\"\n#include \"../perf-sys.h\"\n#include \"topdown.h\"\n#include \"map_symbol.h\"\n#include \"mem-events.h\"\n\n \nstatic struct evsel *evsel__read_sampler(struct evsel *evsel, struct evlist *evlist)\n{\n\tstruct evsel *leader = evsel__leader(evsel);\n\n\tif (evsel__is_aux_event(leader) || arch_topdown_sample_read(leader) ||\n\t    is_mem_loads_aux_event(leader)) {\n\t\tevlist__for_each_entry(evlist, evsel) {\n\t\t\tif (evsel__leader(evsel) == leader && evsel != evsel__leader(evsel))\n\t\t\t\treturn evsel;\n\t\t}\n\t}\n\n\treturn leader;\n}\n\nstatic u64 evsel__config_term_mask(struct evsel *evsel)\n{\n\tstruct evsel_config_term *term;\n\tstruct list_head *config_terms = &evsel->config_terms;\n\tu64 term_types = 0;\n\n\tlist_for_each_entry(term, config_terms, list) {\n\t\tterm_types |= 1 << term->type;\n\t}\n\treturn term_types;\n}\n\nstatic void evsel__config_leader_sampling(struct evsel *evsel, struct evlist *evlist)\n{\n\tstruct perf_event_attr *attr = &evsel->core.attr;\n\tstruct evsel *leader = evsel__leader(evsel);\n\tstruct evsel *read_sampler;\n\tu64 term_types, freq_mask;\n\n\tif (!leader->sample_read)\n\t\treturn;\n\n\tread_sampler = evsel__read_sampler(evsel, evlist);\n\n\tif (evsel == read_sampler)\n\t\treturn;\n\n\tterm_types = evsel__config_term_mask(evsel);\n\t \n\tfreq_mask = (1 << EVSEL__CONFIG_TERM_FREQ) | (1 << EVSEL__CONFIG_TERM_PERIOD);\n\tif ((term_types & freq_mask) == 0) {\n\t\tattr->freq           = 0;\n\t\tattr->sample_freq    = 0;\n\t\tattr->sample_period  = 0;\n\t}\n\tif ((term_types & (1 << EVSEL__CONFIG_TERM_OVERWRITE)) == 0)\n\t\tattr->write_backward = 0;\n\n\t \n\tattr->sample_type = read_sampler->core.attr.sample_type |\n\t\t\t    leader->core.attr.sample_type;\n}\n\nvoid evlist__config(struct evlist *evlist, struct record_opts *opts, struct callchain_param *callchain)\n{\n\tstruct evsel *evsel;\n\tbool use_sample_identifier = false;\n\tbool use_comm_exec;\n\tbool sample_id = opts->sample_id;\n\n\tif (perf_cpu_map__cpu(evlist->core.user_requested_cpus, 0).cpu < 0)\n\t\topts->no_inherit = true;\n\n\tuse_comm_exec = perf_can_comm_exec();\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tevsel__config(evsel, opts, callchain);\n\t\tif (evsel->tracking && use_comm_exec)\n\t\t\tevsel->core.attr.comm_exec = 1;\n\t}\n\n\t \n\tevlist__for_each_entry(evlist, evsel)\n\t\tevsel__config_leader_sampling(evsel, evlist);\n\n\tif (opts->full_auxtrace || opts->sample_identifier) {\n\t\t \n\t\tuse_sample_identifier = perf_can_sample_identifier();\n\t\tsample_id = true;\n\t} else if (evlist->core.nr_entries > 1) {\n\t\tstruct evsel *first = evlist__first(evlist);\n\n\t\tevlist__for_each_entry(evlist, evsel) {\n\t\t\tif (evsel->core.attr.sample_type == first->core.attr.sample_type)\n\t\t\t\tcontinue;\n\t\t\tuse_sample_identifier = perf_can_sample_identifier();\n\t\t\tbreak;\n\t\t}\n\t\tsample_id = true;\n\t}\n\n\tif (sample_id) {\n\t\tevlist__for_each_entry(evlist, evsel)\n\t\t\tevsel__set_sample_id(evsel, use_sample_identifier);\n\t}\n\n\tevlist__set_id_pos(evlist);\n}\n\nstatic int get_max_rate(unsigned int *rate)\n{\n\treturn sysctl__read_int(\"kernel/perf_event_max_sample_rate\", (int *)rate);\n}\n\nstatic int record_opts__config_freq(struct record_opts *opts)\n{\n\tbool user_freq = opts->user_freq != UINT_MAX;\n\tbool user_interval = opts->user_interval != ULLONG_MAX;\n\tunsigned int max_rate;\n\n\tif (user_interval && user_freq) {\n\t\tpr_err(\"cannot set frequency and period at the same time\\n\");\n\t\treturn -1;\n\t}\n\n\tif (user_interval)\n\t\topts->default_interval = opts->user_interval;\n\tif (user_freq)\n\t\topts->freq = opts->user_freq;\n\n\t \n\tif (opts->default_interval)\n\t\topts->freq = 0;\n\telse if (opts->freq) {\n\t\topts->default_interval = opts->freq;\n\t} else {\n\t\tpr_err(\"frequency and count are zero, aborting\\n\");\n\t\treturn -1;\n\t}\n\n\tif (get_max_rate(&max_rate))\n\t\treturn 0;\n\n\t \n\tif (user_freq && (max_rate < opts->freq)) {\n\t\tif (opts->strict_freq) {\n\t\t\tpr_err(\"error: Maximum frequency rate (%'u Hz) exceeded.\\n\"\n\t\t\t       \"       Please use -F freq option with a lower value or consider\\n\"\n\t\t\t       \"       tweaking /proc/sys/kernel/perf_event_max_sample_rate.\\n\",\n\t\t\t       max_rate);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tpr_warning(\"warning: Maximum frequency rate (%'u Hz) exceeded, throttling from %'u Hz to %'u Hz.\\n\"\n\t\t\t\t   \"         The limit can be raised via /proc/sys/kernel/perf_event_max_sample_rate.\\n\"\n\t\t\t\t   \"         The kernel will lower it when perf's interrupts take too long.\\n\"\n\t\t\t\t   \"         Use --strict-freq to disable this throttling, refusing to record.\\n\",\n\t\t\t\t   max_rate, opts->freq, max_rate);\n\n\t\t\topts->freq = max_rate;\n\t\t}\n\t}\n\n\t \n\tif (max_rate < opts->freq) {\n\t\tpr_warning(\"Lowering default frequency rate from %u to %u.\\n\"\n\t\t\t   \"Please consider tweaking \"\n\t\t\t   \"/proc/sys/kernel/perf_event_max_sample_rate.\\n\",\n\t\t\t   opts->freq, max_rate);\n\t\topts->freq = max_rate;\n\t}\n\n\treturn 0;\n}\n\nint record_opts__config(struct record_opts *opts)\n{\n\treturn record_opts__config_freq(opts);\n}\n\nbool evlist__can_select_event(struct evlist *evlist, const char *str)\n{\n\tstruct evlist *temp_evlist;\n\tstruct evsel *evsel;\n\tint err, fd;\n\tstruct perf_cpu cpu = { .cpu = 0 };\n\tbool ret = false;\n\tpid_t pid = -1;\n\n\ttemp_evlist = evlist__new();\n\tif (!temp_evlist)\n\t\treturn false;\n\n\terr = parse_event(temp_evlist, str);\n\tif (err)\n\t\tgoto out_delete;\n\n\tevsel = evlist__last(temp_evlist);\n\n\tif (!evlist || perf_cpu_map__empty(evlist->core.user_requested_cpus)) {\n\t\tstruct perf_cpu_map *cpus = perf_cpu_map__new(NULL);\n\n\t\tif (cpus)\n\t\t\tcpu =  perf_cpu_map__cpu(cpus, 0);\n\n\t\tperf_cpu_map__put(cpus);\n\t} else {\n\t\tcpu = perf_cpu_map__cpu(evlist->core.user_requested_cpus, 0);\n\t}\n\n\twhile (1) {\n\t\tfd = sys_perf_event_open(&evsel->core.attr, pid, cpu.cpu, -1,\n\t\t\t\t\t perf_event_open_cloexec_flag());\n\t\tif (fd < 0) {\n\t\t\tif (pid == -1 && errno == EACCES) {\n\t\t\t\tpid = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out_delete;\n\t\t}\n\t\tbreak;\n\t}\n\tclose(fd);\n\tret = true;\n\nout_delete:\n\tevlist__delete(temp_evlist);\n\treturn ret;\n}\n\nint record__parse_freq(const struct option *opt, const char *str, int unset __maybe_unused)\n{\n\tunsigned int freq;\n\tstruct record_opts *opts = opt->value;\n\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (strcasecmp(str, \"max\") == 0) {\n\t\tif (get_max_rate(&freq)) {\n\t\t\tpr_err(\"couldn't read /proc/sys/kernel/perf_event_max_sample_rate\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tpr_info(\"info: Using a maximum frequency rate of %'d Hz\\n\", freq);\n\t} else {\n\t\tfreq = atoi(str);\n\t}\n\n\topts->user_freq = freq;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}