{
  "module_name": "builtin-bench.c",
  "hash_id": "650fcd7b73d4984760b7c549a7800fa4229dd249704d8da269da663af56b472e",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-bench.c",
  "human_readable_source": "\n \n\n \n#include <subcmd/parse-options.h>\n#include \"builtin.h\"\n#include \"bench/bench.h\"\n\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/prctl.h>\n#include <linux/zalloc.h>\n\ntypedef int (*bench_fn_t)(int argc, const char **argv);\n\nstruct bench {\n\tconst char\t*name;\n\tconst char\t*summary;\n\tbench_fn_t\tfn;\n};\n\n#ifdef HAVE_LIBNUMA_SUPPORT\nstatic struct bench numa_benchmarks[] = {\n\t{ \"mem\",\t\"Benchmark for NUMA workloads\",\t\t\tbench_numa\t\t},\n\t{ \"all\",\t\"Run all NUMA benchmarks\",\t\t\tNULL\t\t\t},\n\t{ NULL,\t\tNULL,\t\t\t\t\t\tNULL\t\t\t}\n};\n#endif\n\nstatic struct bench sched_benchmarks[] = {\n\t{ \"messaging\",\t\"Benchmark for scheduling and IPC\",\t\tbench_sched_messaging\t},\n\t{ \"pipe\",\t\"Benchmark for pipe() between two processes\",\tbench_sched_pipe\t},\n\t{ \"seccomp-notify\",\t\"Benchmark for seccomp user notify\",\tbench_sched_seccomp_notify},\n\t{ \"all\",\t\"Run all scheduler benchmarks\",\t\tNULL\t\t\t},\n\t{ NULL,\t\tNULL,\t\t\t\t\t\tNULL\t\t\t}\n};\n\nstatic struct bench syscall_benchmarks[] = {\n\t{ \"basic\",\t\"Benchmark for basic getppid(2) calls\",\t\tbench_syscall_basic\t},\n\t{ \"getpgid\",\t\"Benchmark for getpgid(2) calls\",\t\tbench_syscall_getpgid\t},\n\t{ \"fork\",\t\"Benchmark for fork(2) calls\",\t\t\tbench_syscall_fork\t},\n\t{ \"execve\",\t\"Benchmark for execve(2) calls\",\t\tbench_syscall_execve\t},\n\t{ \"all\",\t\"Run all syscall benchmarks\",\t\t\tNULL\t\t\t},\n\t{ NULL,\t\tNULL,\t\t\t\t\t\tNULL\t\t\t},\n};\n\nstatic struct bench mem_benchmarks[] = {\n\t{ \"memcpy\",\t\"Benchmark for memcpy() functions\",\t\tbench_mem_memcpy\t},\n\t{ \"memset\",\t\"Benchmark for memset() functions\",\t\tbench_mem_memset\t},\n\t{ \"find_bit\",\t\"Benchmark for find_bit() functions\",\t\tbench_mem_find_bit\t},\n\t{ \"all\",\t\"Run all memory access benchmarks\",\t\tNULL\t\t\t},\n\t{ NULL,\t\tNULL,\t\t\t\t\t\tNULL\t\t\t}\n};\n\nstatic struct bench futex_benchmarks[] = {\n\t{ \"hash\",\t\"Benchmark for futex hash table\",               bench_futex_hash\t},\n\t{ \"wake\",\t\"Benchmark for futex wake calls\",               bench_futex_wake\t},\n\t{ \"wake-parallel\", \"Benchmark for parallel futex wake calls\",   bench_futex_wake_parallel },\n\t{ \"requeue\",\t\"Benchmark for futex requeue calls\",            bench_futex_requeue\t},\n\t \n\t{ \"lock-pi\",\t\"Benchmark for futex lock_pi calls\",            bench_futex_lock_pi\t},\n\t{ \"all\",\t\"Run all futex benchmarks\",\t\t\tNULL\t\t\t},\n\t{ NULL,\t\tNULL,\t\t\t\t\t\tNULL\t\t\t}\n};\n\n#ifdef HAVE_EVENTFD_SUPPORT\nstatic struct bench epoll_benchmarks[] = {\n\t{ \"wait\",\t\"Benchmark epoll concurrent epoll_waits\",       bench_epoll_wait\t},\n\t{ \"ctl\",\t\"Benchmark epoll concurrent epoll_ctls\",        bench_epoll_ctl\t\t},\n\t{ \"all\",\t\"Run all futex benchmarks\",\t\t\tNULL\t\t\t},\n\t{ NULL,\t\tNULL,\t\t\t\t\t\tNULL\t\t\t}\n};\n#endif \n\nstatic struct bench internals_benchmarks[] = {\n\t{ \"synthesize\", \"Benchmark perf event synthesis\",\tbench_synthesize\t},\n\t{ \"kallsyms-parse\", \"Benchmark kallsyms parsing\",\tbench_kallsyms_parse\t},\n\t{ \"inject-build-id\", \"Benchmark build-id injection\",\tbench_inject_build_id\t},\n\t{ \"evlist-open-close\", \"Benchmark evlist open and close\",\tbench_evlist_open_close\t},\n\t{ \"pmu-scan\", \"Benchmark sysfs PMU info scanning\",\tbench_pmu_scan\t\t},\n\t{ NULL,\t\tNULL,\t\t\t\t\tNULL\t\t\t}\n};\n\nstatic struct bench breakpoint_benchmarks[] = {\n\t{ \"thread\", \"Benchmark thread start/finish with breakpoints\", bench_breakpoint_thread},\n\t{ \"enable\", \"Benchmark breakpoint enable/disable\", bench_breakpoint_enable},\n\t{ \"all\", \"Run all breakpoint benchmarks\", NULL},\n\t{ NULL,\tNULL, NULL },\n};\n\nstatic struct bench uprobe_benchmarks[] = {\n\t{ \"baseline\",\t\"Baseline libc usleep(1000) call\",\t\t\t\tbench_uprobe_baseline,\t},\n\t{ \"empty\",\t\"Attach empty BPF prog to uprobe on usleep, system wide\",\tbench_uprobe_empty,\t},\n\t{ \"trace_printk\", \"Attach trace_printk BPF prog to uprobe on usleep syswide\",\tbench_uprobe_trace_printk,\t},\n\t{ NULL,\tNULL, NULL },\n};\n\nstruct collection {\n\tconst char\t*name;\n\tconst char\t*summary;\n\tstruct bench\t*benchmarks;\n};\n\nstatic struct collection collections[] = {\n\t{ \"sched\",\t\"Scheduler and IPC benchmarks\",\t\t\tsched_benchmarks\t},\n\t{ \"syscall\",\t\"System call benchmarks\",\t\t\tsyscall_benchmarks\t},\n\t{ \"mem\",\t\"Memory access benchmarks\",\t\t\tmem_benchmarks\t\t},\n#ifdef HAVE_LIBNUMA_SUPPORT\n\t{ \"numa\",\t\"NUMA scheduling and MM benchmarks\",\t\tnuma_benchmarks\t\t},\n#endif\n\t{\"futex\",       \"Futex stressing benchmarks\",                   futex_benchmarks        },\n#ifdef HAVE_EVENTFD_SUPPORT\n\t{\"epoll\",       \"Epoll stressing benchmarks\",                   epoll_benchmarks        },\n#endif\n\t{ \"internals\",\t\"Perf-internals benchmarks\",\t\t\tinternals_benchmarks\t},\n\t{ \"breakpoint\",\t\"Breakpoint benchmarks\",\t\t\tbreakpoint_benchmarks\t},\n\t{ \"uprobe\",\t\"uprobe benchmarks\",\t\t\t\tuprobe_benchmarks\t},\n\t{ \"all\",\t\"All benchmarks\",\t\t\t\tNULL\t\t\t},\n\t{ NULL,\t\tNULL,\t\t\t\t\t\tNULL\t\t\t}\n};\n\n \n#define for_each_collection(coll) \\\n\tfor (coll = collections; coll->name; coll++)\n\n \n#define for_each_bench(coll, bench) \\\n\tfor (bench = coll->benchmarks; bench && bench->name; bench++)\n\nstatic void dump_benchmarks(struct collection *coll)\n{\n\tstruct bench *bench;\n\n\tprintf(\"\\n        # List of available benchmarks for collection '%s':\\n\\n\", coll->name);\n\n\tfor_each_bench(coll, bench)\n\t\tprintf(\"%14s: %s\\n\", bench->name, bench->summary);\n\n\tprintf(\"\\n\");\n}\n\nstatic const char *bench_format_str;\n\n \nint bench_format = BENCH_FORMAT_DEFAULT;\nunsigned int bench_repeat = 10;  \n\nstatic const struct option bench_options[] = {\n\tOPT_STRING('f', \"format\", &bench_format_str, \"default|simple\", \"Specify the output formatting style\"),\n\tOPT_UINTEGER('r', \"repeat\",  &bench_repeat,   \"Specify number of times to repeat the run\"),\n\tOPT_END()\n};\n\nstatic const char * const bench_usage[] = {\n\t\"perf bench [<common options>] <collection> <benchmark> [<options>]\",\n\tNULL\n};\n\nstatic void print_usage(void)\n{\n\tstruct collection *coll;\n\tint i;\n\n\tprintf(\"Usage: \\n\");\n\tfor (i = 0; bench_usage[i]; i++)\n\t\tprintf(\"\\t%s\\n\", bench_usage[i]);\n\tprintf(\"\\n\");\n\n\tprintf(\"        # List of all available benchmark collections:\\n\\n\");\n\n\tfor_each_collection(coll)\n\t\tprintf(\"%14s: %s\\n\", coll->name, coll->summary);\n\tprintf(\"\\n\");\n}\n\nstatic int bench_str2int(const char *str)\n{\n\tif (!str)\n\t\treturn BENCH_FORMAT_DEFAULT;\n\n\tif (!strcmp(str, BENCH_FORMAT_DEFAULT_STR))\n\t\treturn BENCH_FORMAT_DEFAULT;\n\telse if (!strcmp(str, BENCH_FORMAT_SIMPLE_STR))\n\t\treturn BENCH_FORMAT_SIMPLE;\n\n\treturn BENCH_FORMAT_UNKNOWN;\n}\n\n \nstatic int run_bench(const char *coll_name, const char *bench_name, bench_fn_t fn,\n\t\t     int argc, const char **argv)\n{\n\tint size;\n\tchar *name;\n\tint ret;\n\n\tsize = strlen(coll_name) + 1 + strlen(bench_name) + 1;\n\n\tname = zalloc(size);\n\tBUG_ON(!name);\n\n\tscnprintf(name, size, \"%s-%s\", coll_name, bench_name);\n\n\tprctl(PR_SET_NAME, name);\n\targv[0] = name;\n\n\tret = fn(argc, argv);\n\n\tfree(name);\n\n\treturn ret;\n}\n\nstatic void run_collection(struct collection *coll)\n{\n\tstruct bench *bench;\n\tconst char *argv[2];\n\n\targv[1] = NULL;\n\t \n\tfor_each_bench(coll, bench) {\n\t\tif (!bench->fn)\n\t\t\tbreak;\n\t\tprintf(\"# Running %s/%s benchmark...\\n\", coll->name, bench->name);\n\n\t\targv[1] = bench->name;\n\t\trun_bench(coll->name, bench->name, bench->fn, 1, argv);\n\t\tprintf(\"\\n\");\n\t}\n}\n\nstatic void run_all_collections(void)\n{\n\tstruct collection *coll;\n\n\tfor_each_collection(coll)\n\t\trun_collection(coll);\n}\n\nint cmd_bench(int argc, const char **argv)\n{\n\tstruct collection *coll;\n\tint ret = 0;\n\n\t \n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\tsetlocale(LC_ALL, \"\");\n\n\tif (argc < 2) {\n\t\t \n\t\tprint_usage();\n\t\tgoto end;\n\t}\n\n\targc = parse_options(argc, argv, bench_options, bench_usage,\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\n\tbench_format = bench_str2int(bench_format_str);\n\tif (bench_format == BENCH_FORMAT_UNKNOWN) {\n\t\tprintf(\"Unknown format descriptor: '%s'\\n\", bench_format_str);\n\t\tgoto end;\n\t}\n\n\tif (bench_repeat == 0) {\n\t\tprintf(\"Invalid repeat option: Must specify a positive value\\n\");\n\t\tgoto end;\n\t}\n\n\tif (argc < 1) {\n\t\tprint_usage();\n\t\tgoto end;\n\t}\n\n\tif (!strcmp(argv[0], \"all\")) {\n\t\trun_all_collections();\n\t\tgoto end;\n\t}\n\n\tfor_each_collection(coll) {\n\t\tstruct bench *bench;\n\n\t\tif (strcmp(coll->name, argv[0]))\n\t\t\tcontinue;\n\n\t\tif (argc < 2) {\n\t\t\t \n\t\t\tdump_benchmarks(coll);\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (!strcmp(argv[1], \"all\")) {\n\t\t\trun_collection(coll);\n\t\t\tgoto end;\n\t\t}\n\n\t\tfor_each_bench(coll, bench) {\n\t\t\tif (strcmp(bench->name, argv[1]))\n\t\t\t\tcontinue;\n\n\t\t\tif (bench_format == BENCH_FORMAT_DEFAULT)\n\t\t\t\tprintf(\"# Running '%s/%s' benchmark:\\n\", coll->name, bench->name);\n\t\t\tret = run_bench(coll->name, bench->name, bench->fn, argc-1, argv+1);\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (!strcmp(argv[1], \"-h\") || !strcmp(argv[1], \"--help\")) {\n\t\t\tdump_benchmarks(coll);\n\t\t\tgoto end;\n\t\t}\n\n\t\tprintf(\"Unknown benchmark: '%s' for collection '%s'\\n\", argv[1], argv[0]);\n\t\tret = 1;\n\t\tgoto end;\n\t}\n\n\tprintf(\"Unknown collection: '%s'\\n\", argv[0]);\n\tret = 1;\n\nend:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}