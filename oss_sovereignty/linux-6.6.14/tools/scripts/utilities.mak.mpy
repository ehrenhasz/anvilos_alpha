{
  "module_name": "utilities.mak",
  "hash_id": "a389fd827d87e081b1ac509fe797ef03c33407a9756da12c304176ac65a32008",
  "original_prompt": "Ingested from linux-6.6.14/tools/scripts/utilities.mak",
  "human_readable_source": "# This allows us to work with the newline character:\ndefine newline\n\n\nendef\nnewline := $(newline)\n\n# nl-escape\n#\n# Usage: escape = $(call nl-escape[,escape])\n#\n# This is used as the common way to specify\n# what should replace a newline when escaping\n# newlines; the default is a bizarre string.\n#\nnl-escape = $(if $(1),$(1),m822df3020w6a44id34bt574ctac44eb9f4n)\n\n# escape-nl\n#\n# Usage: escaped-text = $(call escape-nl,text[,escape])\n#\n# GNU make's $(shell ...) function converts to a\n# single space each newline character in the output\n# produced during the expansion; this may not be\n# desirable.\n#\n# The only solution is to change each newline into\n# something that won't be converted, so that the\n# information can be recovered later with\n# $(call unescape-nl...)\n#\nescape-nl = $(subst $(newline),$(call nl-escape,$(2)),$(1))\n\n# unescape-nl\n#\n# Usage: text = $(call unescape-nl,escaped-text[,escape])\n#\n# See escape-nl.\n#\nunescape-nl = $(subst $(call nl-escape,$(2)),$(newline),$(1))\n\n# shell-escape-nl\n#\n# Usage: $(shell some-command | $(call shell-escape-nl[,escape]))\n#\n# Use this to escape newlines from within a shell call;\n# the default escape is a bizarre string.\n#\n# NOTE: The escape is used directly as a string constant\n#       in an `awk' program that is delimited by shell\n#       single-quotes, so be wary of the characters\n#       that are chosen.\n#\ndefine shell-escape-nl\nawk 'NR==1 {t=$$0} NR>1 {t=t \"$(nl-escape)\" $$0} END {printf t}'\nendef\n\n# shell-unescape-nl\n#\n# Usage: $(shell some-command | $(call shell-unescape-nl[,escape]))\n#\n# Use this to unescape newlines from within a shell call;\n# the default escape is a bizarre string.\n#\n# NOTE: The escape is used directly as an extended regular\n#       expression constant in an `awk' program that is\n#       delimited by shell single-quotes, so be wary\n#       of the characters that are chosen.\n#\n# (The bash shell has a bug where `{gsub(...),...}' is\n#  misinterpreted as a brace expansion; this can be\n#  overcome by putting a space between `{' and `gsub').\n#\ndefine shell-unescape-nl\nawk 'NR==1 {t=$$0} NR>1 {t=t \"\\n\" $$0} END { gsub(/$(nl-escape)/,\"\\n\",t); printf t }'\nendef\n\n# escape-for-shell-sq\n#\n# Usage: embeddable-text = $(call escape-for-shell-sq,text)\n#\n# This function produces text that is suitable for\n# embedding in a shell string that is delimited by\n# single-quotes.\n#\nescape-for-shell-sq =  $(subst ','\\'',$(1))\n\n# shell-sq\n#\n# Usage: single-quoted-and-escaped-text = $(call shell-sq,text)\n#\nshell-sq = '$(escape-for-shell-sq)'\n\n# shell-wordify\n#\n# Usage: wordified-text = $(call shell-wordify,text)\n#\n# For instance:\n#\n#  |define text\n#  |hello\n#  |world\n#  |endef\n#  |\n#  |target:\n#  |\techo $(call shell-wordify,$(text))\n#\n# At least GNU make gets confused by expanding a newline\n# within the context of a command line of a makefile rule\n# (this is in constrast to a `$(shell ...)' function call,\n# which can handle it just fine).\n#\n# This function avoids the problem by producing a string\n# that works as a shell word, regardless of whether or\n# not it contains a newline.\n#\n# If the text to be wordified contains a newline, then\n# an intrictate shell command substitution is constructed\n# to render the text as a single line; when the shell\n# processes the resulting escaped text, it transforms\n# it into the original unescaped text.\n#\n# If the text does not contain a newline, then this function\n# produces the same results as the `$(shell-sq)' function.\n#\nshell-wordify = $(if $(findstring $(newline),$(1)),$(_sw-esc-nl),$(shell-sq))\ndefine _sw-esc-nl\n\"$$(echo $(call escape-nl,$(shell-sq),$(2)) | $(call shell-unescape-nl,$(2)))\"\nendef\n\n# is-absolute\n#\n# Usage: bool-value = $(call is-absolute,path)\n#\nis-absolute = $(shell echo $(shell-sq) | grep -q ^/ && echo y)\n\n# lookup\n#\n# Usage: absolute-executable-path-or-empty = $(call lookup,path)\n#\n# (It's necessary to use `sh -c' because GNU make messes up by\n#  trying too hard and getting things wrong).\n#\nlookup = $(call unescape-nl,$(shell sh -c $(_l-sh)))\n_l-sh = $(call shell-sq,command -v $(shell-sq) | $(call shell-escape-nl,))\n\n# is-executable\n#\n# Usage: bool-value = $(call is-executable,path)\n#\n# (It's necessary to use `sh -c' because GNU make messes up by\n#  trying too hard and getting things wrong).\n#\nis-executable = $(call _is-executable-helper,$(shell-sq))\n_is-executable-helper = $(shell sh -c $(_is-executable-sh))\n_is-executable-sh = $(call shell-sq,test -f $(1) -a -x $(1) && echo y)\n\n# get-executable\n#\n# Usage: absolute-executable-path-or-empty = $(call get-executable,path)\n#\n# The goal is to get an absolute path for an executable;\n# the `command -v' is defined by POSIX, but it's not\n# necessarily very portable, so it's only used if\n# relative path resolution is requested, as determined\n# by the presence of a leading `/'.\n#\nget-executable = $(if $(1),$(if $(is-absolute),$(_ge-abspath),$(lookup)))\n_ge-abspath = $(if $(is-executable),$(1))\n\n# get-supplied-or-default-executable\n#\n# Usage: absolute-executable-path-or-empty = $(call get-executable-or-default,variable,default)\n#\ndefine get-executable-or-default\n$(if $($(1)),$(call _ge_attempt,$($(1)),$(1)),$(call _ge_attempt,$(2)))\nendef\n_ge_attempt = $(or $(get-executable),$(call _gea_err,$(2)))\n_gea_err  = $(if $(1),$(error Please set '$(1)' appropriately))\n\n# version-ge3\n#\n# Usage $(call version-ge3,2.6.4,$(FLEX_VERSION))\n#\n# To compare if a 3 component version is greater or equal to another, first use\n# was to check the flex version to see if we can use compiler warnings as\n# errors for one of the cases flex generates code C compilers complains about.\n\nversion-ge3 = $(shell echo \"$(1).$(2)\" | awk -F'.' '{ printf(\"%d\\n\", (10000000 * $$1 + 10000 * $$2 + $$3) >= (10000000 * $$4 + 10000 * $$5 + $$6)) }')\n\n# version-lt3\n#\n# Usage $(call version-lt3,2.6.2,$(FLEX_VERSION))\n#\n# To compare if a 3 component version is less thjan another, first use was to\n# check the flex version to see if we can use compiler warnings as errors for\n# one of the cases flex generates code C compilers complains about.\n\nversion-lt3 = $(shell echo \"$(1).$(2)\" | awk -F'.' '{ printf(\"%d\\n\", (10000000 * $$1 + 10000 * $$2 + $$3) < (10000000 * $$4 + 10000 * $$5 + $$6)) }')\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}