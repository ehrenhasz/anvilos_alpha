{
  "module_name": "test_dbc.py",
  "hash_id": "2897398f9e4b9b0b29e7f71cc2202271bccf681102cfea6c6a5fa1da33414734",
  "original_prompt": "Ingested from linux-6.6.14/tools/crypto/ccp/test_dbc.py",
  "human_readable_source": "#!/usr/bin/python3\n# SPDX-License-Identifier: GPL-2.0\nimport unittest\nimport os\nimport time\nimport glob\nimport fcntl\ntry:\n    import ioctl_opt as ioctl\nexcept ImportError:\n    ioctl = None\n    pass\nfrom dbc import *\n\n# Artificial delay between set commands\nSET_DELAY = 0.5\n\n\nclass invalid_param(ctypes.Structure):\n    _fields_ = [\n        (\"data\", ctypes.c_uint8),\n    ]\n\n\ndef system_is_secured() -> bool:\n    fused_part = glob.glob(\"/sys/bus/pci/drivers/ccp/**/fused_part\")[0]\n    if os.path.exists(fused_part):\n        with open(fused_part, \"r\") as r:\n            return int(r.read()) == 1\n    return True\n\n\nclass DynamicBoostControlTest(unittest.TestCase):\n    def __init__(self, data) -> None:\n        self.d = None\n        self.signature = b\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        self.uid = b\"1111111111111111\"\n        super().__init__(data)\n\n    def setUp(self) -> None:\n        self.d = open(DEVICE_NODE)\n        return super().setUp()\n\n    def tearDown(self) -> None:\n        if self.d:\n            self.d.close()\n        return super().tearDown()\n\n\nclass TestUnsupportedSystem(DynamicBoostControlTest):\n    def setUp(self) -> None:\n        if os.path.exists(DEVICE_NODE):\n            self.skipTest(\"system is supported\")\n        with self.assertRaises(FileNotFoundError) as error:\n            super().setUp()\n        self.assertEqual(error.exception.errno, 2)\n\n    def test_unauthenticated_nonce(self) -> None:\n        \"\"\"fetch unauthenticated nonce\"\"\"\n        with self.assertRaises(ValueError) as error:\n            get_nonce(self.d, None)\n\n\nclass TestInvalidIoctls(DynamicBoostControlTest):\n    def __init__(self, data) -> None:\n        self.data = invalid_param()\n        self.data.data = 1\n        super().__init__(data)\n\n    def setUp(self) -> None:\n        if not os.path.exists(DEVICE_NODE):\n            self.skipTest(\"system is unsupported\")\n        if not ioctl:\n            self.skipTest(\"unable to test IOCTLs without ioctl_opt\")\n\n        return super().setUp()\n\n    def test_invalid_nonce_ioctl(self) -> None:\n        \"\"\"tries to call get_nonce ioctl with invalid data structures\"\"\"\n\n        # 0x1 (get nonce), and invalid data\n        INVALID1 = ioctl.IOWR(ord(\"D\"), 0x01, invalid_param)\n        with self.assertRaises(OSError) as error:\n            fcntl.ioctl(self.d, INVALID1, self.data, True)\n        self.assertEqual(error.exception.errno, 22)\n\n    def test_invalid_setuid_ioctl(self) -> None:\n        \"\"\"tries to call set_uid ioctl with invalid data structures\"\"\"\n\n        # 0x2 (set uid), and invalid data\n        INVALID2 = ioctl.IOW(ord(\"D\"), 0x02, invalid_param)\n        with self.assertRaises(OSError) as error:\n            fcntl.ioctl(self.d, INVALID2, self.data, True)\n        self.assertEqual(error.exception.errno, 22)\n\n    def test_invalid_setuid_rw_ioctl(self) -> None:\n        \"\"\"tries to call set_uid ioctl with invalid data structures\"\"\"\n\n        # 0x2 as RW (set uid), and invalid data\n        INVALID3 = ioctl.IOWR(ord(\"D\"), 0x02, invalid_param)\n        with self.assertRaises(OSError) as error:\n            fcntl.ioctl(self.d, INVALID3, self.data, True)\n        self.assertEqual(error.exception.errno, 22)\n\n    def test_invalid_param_ioctl(self) -> None:\n        \"\"\"tries to call param ioctl with invalid data structures\"\"\"\n        # 0x3 (param), and invalid data\n        INVALID4 = ioctl.IOWR(ord(\"D\"), 0x03, invalid_param)\n        with self.assertRaises(OSError) as error:\n            fcntl.ioctl(self.d, INVALID4, self.data, True)\n        self.assertEqual(error.exception.errno, 22)\n\n    def test_invalid_call_ioctl(self) -> None:\n        \"\"\"tries to call the DBC ioctl with invalid data structures\"\"\"\n        # 0x4, and invalid data\n        INVALID5 = ioctl.IOWR(ord(\"D\"), 0x04, invalid_param)\n        with self.assertRaises(OSError) as error:\n            fcntl.ioctl(self.d, INVALID5, self.data, True)\n        self.assertEqual(error.exception.errno, 22)\n\n\nclass TestInvalidSignature(DynamicBoostControlTest):\n    def setUp(self) -> None:\n        if not os.path.exists(DEVICE_NODE):\n            self.skipTest(\"system is unsupported\")\n        if not system_is_secured():\n            self.skipTest(\"system is unfused\")\n        return super().setUp()\n\n    def test_unauthenticated_nonce(self) -> None:\n        \"\"\"fetch unauthenticated nonce\"\"\"\n        get_nonce(self.d, None)\n\n    def test_multiple_unauthenticated_nonce(self) -> None:\n        \"\"\"ensure state machine always returns nonce\"\"\"\n        for count in range(0, 2):\n            get_nonce(self.d, None)\n\n    def test_authenticated_nonce(self) -> None:\n        \"\"\"fetch authenticated nonce\"\"\"\n        with self.assertRaises(OSError) as error:\n            get_nonce(self.d, self.signature)\n        self.assertEqual(error.exception.errno, 1)\n\n    def test_set_uid(self) -> None:\n        \"\"\"set uid\"\"\"\n        with self.assertRaises(OSError) as error:\n            set_uid(self.d, self.uid, self.signature)\n        self.assertEqual(error.exception.errno, 1)\n\n    def test_get_param(self) -> None:\n        \"\"\"fetch a parameter\"\"\"\n        with self.assertRaises(OSError) as error:\n            process_param(self.d, PARAM_GET_SOC_PWR_CUR, self.signature)\n        self.assertEqual(error.exception.errno, 1)\n\n    def test_set_param(self) -> None:\n        \"\"\"set a parameter\"\"\"\n        with self.assertRaises(OSError) as error:\n            process_param(self.d, PARAM_SET_PWR_CAP, self.signature, 1000)\n        self.assertEqual(error.exception.errno, 1)\n\n\nclass TestUnFusedSystem(DynamicBoostControlTest):\n    def setup_identity(self) -> None:\n        \"\"\"sets up the identity of the caller\"\"\"\n        # if already authenticated these may fail\n        try:\n            get_nonce(self.d, None)\n        except PermissionError:\n            pass\n        try:\n            set_uid(self.d, self.uid, self.signature)\n        except BlockingIOError:\n            pass\n        try:\n            get_nonce(self.d, self.signature)\n        except PermissionError:\n            pass\n\n    def setUp(self) -> None:\n        if not os.path.exists(DEVICE_NODE):\n            self.skipTest(\"system is unsupported\")\n        if system_is_secured():\n            self.skipTest(\"system is fused\")\n        super().setUp()\n        self.setup_identity()\n        time.sleep(SET_DELAY)\n\n    def test_get_valid_param(self) -> None:\n        \"\"\"fetch all possible parameters\"\"\"\n        # SOC power\n        soc_power_max = process_param(self.d, PARAM_GET_SOC_PWR_MAX, self.signature)\n        soc_power_min = process_param(self.d, PARAM_GET_SOC_PWR_MIN, self.signature)\n        self.assertGreater(soc_power_max[0], soc_power_min[0])\n\n        # fmax\n        fmax_max = process_param(self.d, PARAM_GET_FMAX_MAX, self.signature)\n        fmax_min = process_param(self.d, PARAM_GET_FMAX_MIN, self.signature)\n        self.assertGreater(fmax_max[0], fmax_min[0])\n\n        # cap values\n        keys = {\n            \"fmax-cap\": PARAM_GET_FMAX_CAP,\n            \"power-cap\": PARAM_GET_PWR_CAP,\n            \"current-temp\": PARAM_GET_CURR_TEMP,\n            \"soc-power-cur\": PARAM_GET_SOC_PWR_CUR,\n        }\n        for k in keys:\n            result = process_param(self.d, keys[k], self.signature)\n            self.assertGreater(result[0], 0)\n\n    def test_get_invalid_param(self) -> None:\n        \"\"\"fetch an invalid parameter\"\"\"\n        try:\n            set_uid(self.d, self.uid, self.signature)\n        except OSError:\n            pass\n        with self.assertRaises(OSError) as error:\n            process_param(self.d, (0xF,), self.signature)\n        self.assertEqual(error.exception.errno, 22)\n\n    def test_set_fmax(self) -> None:\n        \"\"\"get/set fmax limit\"\"\"\n        # fetch current\n        original = process_param(self.d, PARAM_GET_FMAX_CAP, self.signature)\n\n        # set the fmax\n        target = original[0] - 100\n        process_param(self.d, PARAM_SET_FMAX_CAP, self.signature, target)\n        time.sleep(SET_DELAY)\n        new = process_param(self.d, PARAM_GET_FMAX_CAP, self.signature)\n        self.assertEqual(new[0], target)\n\n        # revert back to current\n        process_param(self.d, PARAM_SET_FMAX_CAP, self.signature, original[0])\n        time.sleep(SET_DELAY)\n        cur = process_param(self.d, PARAM_GET_FMAX_CAP, self.signature)\n        self.assertEqual(cur[0], original[0])\n\n    def test_set_power_cap(self) -> None:\n        \"\"\"get/set power cap limit\"\"\"\n        # fetch current\n        original = process_param(self.d, PARAM_GET_PWR_CAP, self.signature)\n\n        # set the fmax\n        target = original[0] - 10\n        process_param(self.d, PARAM_SET_PWR_CAP, self.signature, target)\n        time.sleep(SET_DELAY)\n        new = process_param(self.d, PARAM_GET_PWR_CAP, self.signature)\n        self.assertEqual(new[0], target)\n\n        # revert back to current\n        process_param(self.d, PARAM_SET_PWR_CAP, self.signature, original[0])\n        time.sleep(SET_DELAY)\n        cur = process_param(self.d, PARAM_GET_PWR_CAP, self.signature)\n        self.assertEqual(cur[0], original[0])\n\n    def test_set_3d_graphics_mode(self) -> None:\n        \"\"\"set/get 3d graphics mode\"\"\"\n        # these aren't currently implemented but may be some day\n        # they are *expected* to fail\n        with self.assertRaises(OSError) as error:\n            process_param(self.d, PARAM_GET_GFX_MODE, self.signature)\n        self.assertEqual(error.exception.errno, 2)\n\n        time.sleep(SET_DELAY)\n\n        with self.assertRaises(OSError) as error:\n            process_param(self.d, PARAM_SET_GFX_MODE, self.signature, 1)\n        self.assertEqual(error.exception.errno, 2)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}