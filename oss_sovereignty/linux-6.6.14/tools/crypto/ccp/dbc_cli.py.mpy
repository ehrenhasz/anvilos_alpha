{
  "module_name": "dbc_cli.py",
  "hash_id": "8d6a7659d9449f18daacf61c309f1d5b9132546c6ba2699e7a2736fd39a5958c",
  "original_prompt": "Ingested from linux-6.6.14/tools/crypto/ccp/dbc_cli.py",
  "human_readable_source": "#!/usr/bin/python3\n# SPDX-License-Identifier: GPL-2.0\nimport argparse\nimport binascii\nimport os\nimport errno\nfrom dbc import *\n\nERRORS = {\n    errno.EACCES: \"Access is denied\",\n    errno.E2BIG: \"Excess data provided\",\n    errno.EINVAL: \"Bad parameters\",\n    errno.EAGAIN: \"Bad state\",\n    errno.ENOENT: \"Not implemented or message failure\",\n    errno.EBUSY: \"Busy\",\n    errno.ENFILE: \"Overflow\",\n    errno.EPERM: \"Signature invalid\",\n}\n\nmessages = {\n    \"get-fmax-cap\": PARAM_GET_FMAX_CAP,\n    \"set-fmax-cap\": PARAM_SET_FMAX_CAP,\n    \"get-power-cap\": PARAM_GET_PWR_CAP,\n    \"set-power-cap\": PARAM_SET_PWR_CAP,\n    \"get-graphics-mode\": PARAM_GET_GFX_MODE,\n    \"set-graphics-mode\": PARAM_SET_GFX_MODE,\n    \"get-current-temp\": PARAM_GET_CURR_TEMP,\n    \"get-fmax-max\": PARAM_GET_FMAX_MAX,\n    \"get-fmax-min\": PARAM_GET_FMAX_MIN,\n    \"get-soc-power-max\": PARAM_GET_SOC_PWR_MAX,\n    \"get-soc-power-min\": PARAM_GET_SOC_PWR_MIN,\n    \"get-soc-power-cur\": PARAM_GET_SOC_PWR_CUR,\n}\n\n\ndef _pretty_buffer(ba):\n    return str(binascii.hexlify(ba, \" \"))\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(\n        description=\"Dynamic Boost control command line interface\"\n    )\n    parser.add_argument(\n        \"command\",\n        choices=[\"get-nonce\", \"get-param\", \"set-param\", \"set-uid\"],\n        help=\"Command to send\",\n    )\n    parser.add_argument(\"--device\", default=\"/dev/dbc\", help=\"Device to operate\")\n    parser.add_argument(\"--signature\", help=\"File containing signature for command\")\n    parser.add_argument(\"--message\", choices=messages.keys(), help=\"Message index\")\n    parser.add_argument(\"--data\", help=\"Argument to pass to message\")\n    parser.add_argument(\"--uid\", help=\"File containing UID to pass\")\n    return parser.parse_args()\n\n\ndef pretty_error(code):\n    if code in ERRORS:\n        print(ERRORS[code])\n    else:\n        print(\"failed with return code %d\" % code)\n\n\nif __name__ == \"__main__\":\n    args = parse_args()\n    data = 0\n    sig = None\n    uid = None\n    if not os.path.exists(args.device):\n        raise IOError(\"Missing device {device}\".format(device=args.device))\n    if args.signature:\n        if not os.path.exists(args.signature):\n            raise ValueError(\"Invalid signature file %s\" % args.signature)\n        with open(args.signature, \"rb\") as f:\n            sig = f.read()\n        if len(sig) != DBC_SIG_SIZE:\n            raise ValueError(\n                \"Invalid signature length %d (expected %d)\" % (len(sig), DBC_SIG_SIZE)\n            )\n    if args.uid:\n        if not os.path.exists(args.uid):\n            raise ValueError(\"Invalid uid file %s\" % args.uid)\n        with open(args.uid, \"rb\") as f:\n            uid = f.read()\n        if len(uid) != DBC_UID_SIZE:\n            raise ValueError(\n                \"Invalid UID length %d (expected %d)\" % (len(uid), DBC_UID_SIZE)\n            )\n    if args.data:\n        try:\n            data = int(args.data, 10)\n        except ValueError:\n            data = int(args.data, 16)\n\n    with open(args.device) as d:\n        if args.command == \"get-nonce\":\n            try:\n                nonce = get_nonce(d, sig)\n                print(\"Nonce: %s\" % _pretty_buffer(bytes(nonce)))\n            except OSError as e:\n                pretty_error(e.errno)\n        elif args.command == \"set-uid\":\n            try:\n                result = set_uid(d, uid, sig)\n                if result:\n                    print(\"Set UID\")\n            except OSError as e:\n                pretty_error(e.errno)\n        elif args.command == \"get-param\":\n            if not args.message or args.message.startswith(\"set\"):\n                raise ValueError(\"Invalid message %s\" % args.message)\n            try:\n                param, signature = process_param(d, messages[args.message], sig)\n                print(\n                    \"Parameter: {par}, response signature {sig}\".format(\n                        par=param,\n                        sig=_pretty_buffer(bytes(signature)),\n                    )\n                )\n            except OSError as e:\n                pretty_error(e.errno)\n        elif args.command == \"set-param\":\n            if not args.message or args.message.startswith(\"get\"):\n                raise ValueError(\"Invalid message %s\" % args.message)\n            try:\n                param, signature = process_param(d, messages[args.message], sig, data)\n                print(\n                    \"Parameter: {par}, response signature {sig}\".format(\n                        par=param,\n                        sig=_pretty_buffer(bytes(signature)),\n                    )\n                )\n            except OSError as e:\n                pretty_error(e.errno)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}