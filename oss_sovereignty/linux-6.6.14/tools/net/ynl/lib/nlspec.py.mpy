{
  "module_name": "nlspec.py",
  "hash_id": "f56a2f200810c3abf259323b42a03175d409c097edb36800aac649811cb888f0",
  "original_prompt": "Ingested from linux-6.6.14/tools/net/ynl/lib/nlspec.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause\n\nimport collections\nimport importlib\nimport os\nimport yaml\n\n\n# To be loaded dynamically as needed\njsonschema = None\n\n\nclass SpecElement:\n    \"\"\"Netlink spec element.\n\n    Abstract element of the Netlink spec. Implements the dictionary interface\n    for access to the raw spec. Supports iterative resolution of dependencies\n    across elements and class inheritance levels. The elements of the spec\n    may refer to each other, and although loops should be very rare, having\n    to maintain correct ordering of instantiation is painful, so the resolve()\n    method should be used to perform parts of init which require access to\n    other parts of the spec.\n\n    Attributes:\n        yaml        raw spec as loaded from the spec file\n        family      back reference to the full family\n\n        name        name of the entity as listed in the spec (optional)\n        ident_name  name which can be safely used as identifier in code (optional)\n    \"\"\"\n    def __init__(self, family, yaml):\n        self.yaml = yaml\n        self.family = family\n\n        if 'name' in self.yaml:\n            self.name = self.yaml['name']\n            self.ident_name = self.name.replace('-', '_')\n\n        self._super_resolved = False\n        family.add_unresolved(self)\n\n    def __getitem__(self, key):\n        return self.yaml[key]\n\n    def __contains__(self, key):\n        return key in self.yaml\n\n    def get(self, key, default=None):\n        return self.yaml.get(key, default)\n\n    def resolve_up(self, up):\n        if not self._super_resolved:\n            up.resolve()\n            self._super_resolved = True\n\n    def resolve(self):\n        pass\n\n\nclass SpecEnumEntry(SpecElement):\n    \"\"\" Entry within an enum declared in the Netlink spec.\n\n    Attributes:\n        doc         documentation string\n        enum_set    back reference to the enum\n        value       numerical value of this enum (use accessors in most situations!)\n\n    Methods:\n        raw_value   raw value, i.e. the id in the enum, unlike user value which is a mask for flags\n        user_value   user value, same as raw value for enums, for flags it's the mask\n    \"\"\"\n    def __init__(self, enum_set, yaml, prev, value_start):\n        if isinstance(yaml, str):\n            yaml = {'name': yaml}\n        super().__init__(enum_set.family, yaml)\n\n        self.doc = yaml.get('doc', '')\n        self.enum_set = enum_set\n\n        if 'value' in yaml:\n            self.value = yaml['value']\n        elif prev:\n            self.value = prev.value + 1\n        else:\n            self.value = value_start\n\n    def has_doc(self):\n        return bool(self.doc)\n\n    def raw_value(self):\n        return self.value\n\n    def user_value(self, as_flags=None):\n        if self.enum_set['type'] == 'flags' or as_flags:\n            return 1 << self.value\n        else:\n            return self.value\n\n\nclass SpecEnumSet(SpecElement):\n    \"\"\" Enum type\n\n    Represents an enumeration (list of numerical constants)\n    as declared in the \"definitions\" section of the spec.\n\n    Attributes:\n        type            enum or flags\n        entries         entries by name\n        entries_by_val  entries by value\n    Methods:\n        get_mask      for flags compute the mask of all defined values\n    \"\"\"\n    def __init__(self, family, yaml):\n        super().__init__(family, yaml)\n\n        self.type = yaml['type']\n\n        prev_entry = None\n        value_start = self.yaml.get('value-start', 0)\n        self.entries = dict()\n        self.entries_by_val = dict()\n        for entry in self.yaml['entries']:\n            e = self.new_entry(entry, prev_entry, value_start)\n            self.entries[e.name] = e\n            self.entries_by_val[e.raw_value()] = e\n            prev_entry = e\n\n    def new_entry(self, entry, prev_entry, value_start):\n        return SpecEnumEntry(self, entry, prev_entry, value_start)\n\n    def has_doc(self):\n        if 'doc' in self.yaml:\n            return True\n        for entry in self.entries.values():\n            if entry.has_doc():\n                return True\n        return False\n\n    def get_mask(self, as_flags=None):\n        mask = 0\n        for e in self.entries.values():\n            mask += e.user_value(as_flags)\n        return mask\n\n\nclass SpecAttr(SpecElement):\n    \"\"\" Single Netlink atttribute type\n\n    Represents a single attribute type within an attr space.\n\n    Attributes:\n        value         numerical ID when serialized\n        attr_set      Attribute Set containing this attr\n        is_multi      bool, attr may repeat multiple times\n        struct_name   string, name of struct definition\n        sub_type      string, name of sub type\n        len           integer, optional byte length of binary types\n        display_hint  string, hint to help choose format specifier\n                      when displaying the value\n    \"\"\"\n    def __init__(self, family, attr_set, yaml, value):\n        super().__init__(family, yaml)\n\n        self.value = value\n        self.attr_set = attr_set\n        self.is_multi = yaml.get('multi-attr', False)\n        self.struct_name = yaml.get('struct')\n        self.sub_type = yaml.get('sub-type')\n        self.byte_order = yaml.get('byte-order')\n        self.len = yaml.get('len')\n        self.display_hint = yaml.get('display-hint')\n\n\nclass SpecAttrSet(SpecElement):\n    \"\"\" Netlink Attribute Set class.\n\n    Represents a ID space of attributes within Netlink.\n\n    Note that unlike other elements, which expose contents of the raw spec\n    via the dictionary interface Attribute Set exposes attributes by name.\n\n    Attributes:\n        attrs      ordered dict of all attributes (indexed by name)\n        attrs_by_val  ordered dict of all attributes (indexed by value)\n        subset_of  parent set if this is a subset, otherwise None\n    \"\"\"\n    def __init__(self, family, yaml):\n        super().__init__(family, yaml)\n\n        self.subset_of = self.yaml.get('subset-of', None)\n\n        self.attrs = collections.OrderedDict()\n        self.attrs_by_val = collections.OrderedDict()\n\n        if self.subset_of is None:\n            val = 1\n            for elem in self.yaml['attributes']:\n                if 'value' in elem:\n                    val = elem['value']\n\n                attr = self.new_attr(elem, val)\n                self.attrs[attr.name] = attr\n                self.attrs_by_val[attr.value] = attr\n                val += 1\n        else:\n            real_set = family.attr_sets[self.subset_of]\n            for elem in self.yaml['attributes']:\n                attr = real_set[elem['name']]\n                self.attrs[attr.name] = attr\n                self.attrs_by_val[attr.value] = attr\n\n    def new_attr(self, elem, value):\n        return SpecAttr(self.family, self, elem, value)\n\n    def __getitem__(self, key):\n        return self.attrs[key]\n\n    def __contains__(self, key):\n        return key in self.attrs\n\n    def __iter__(self):\n        yield from self.attrs\n\n    def items(self):\n        return self.attrs.items()\n\n\nclass SpecStructMember(SpecElement):\n    \"\"\"Struct member attribute\n\n    Represents a single struct member attribute.\n\n    Attributes:\n        type        string, type of the member attribute\n        byte_order  string or None for native byte order\n        enum        string, name of the enum definition\n        len         integer, optional byte length of binary types\n        display_hint  string, hint to help choose format specifier\n                      when displaying the value\n    \"\"\"\n    def __init__(self, family, yaml):\n        super().__init__(family, yaml)\n        self.type = yaml['type']\n        self.byte_order = yaml.get('byte-order')\n        self.enum = yaml.get('enum')\n        self.len = yaml.get('len')\n        self.display_hint = yaml.get('display-hint')\n\n\nclass SpecStruct(SpecElement):\n    \"\"\"Netlink struct type\n\n    Represents a C struct definition.\n\n    Attributes:\n        members   ordered list of struct members\n    \"\"\"\n    def __init__(self, family, yaml):\n        super().__init__(family, yaml)\n\n        self.members = []\n        for member in yaml.get('members', []):\n            self.members.append(self.new_member(family, member))\n\n    def new_member(self, family, elem):\n        return SpecStructMember(family, elem)\n\n    def __iter__(self):\n        yield from self.members\n\n    def items(self):\n        return self.members.items()\n\n\nclass SpecOperation(SpecElement):\n    \"\"\"Netlink Operation\n\n    Information about a single Netlink operation.\n\n    Attributes:\n        value           numerical ID when serialized, None if req/rsp values differ\n\n        req_value       numerical ID when serialized, user -> kernel\n        rsp_value       numerical ID when serialized, user <- kernel\n        is_call         bool, whether the operation is a call\n        is_async        bool, whether the operation is a notification\n        is_resv         bool, whether the operation does not exist (it's just a reserved ID)\n        attr_set        attribute set name\n        fixed_header    string, optional name of fixed header struct\n\n        yaml            raw spec as loaded from the spec file\n    \"\"\"\n    def __init__(self, family, yaml, req_value, rsp_value):\n        super().__init__(family, yaml)\n\n        self.value = req_value if req_value == rsp_value else None\n        self.req_value = req_value\n        self.rsp_value = rsp_value\n\n        self.is_call = 'do' in yaml or 'dump' in yaml\n        self.is_async = 'notify' in yaml or 'event' in yaml\n        self.is_resv = not self.is_async and not self.is_call\n        self.fixed_header = self.yaml.get('fixed-header', family.fixed_header)\n\n        # Added by resolve:\n        self.attr_set = None\n        delattr(self, \"attr_set\")\n\n    def resolve(self):\n        self.resolve_up(super())\n\n        if 'attribute-set' in self.yaml:\n            attr_set_name = self.yaml['attribute-set']\n        elif 'notify' in self.yaml:\n            msg = self.family.msgs[self.yaml['notify']]\n            attr_set_name = msg['attribute-set']\n        elif self.is_resv:\n            attr_set_name = ''\n        else:\n            raise Exception(f\"Can't resolve attribute set for op '{self.name}'\")\n        if attr_set_name:\n            self.attr_set = self.family.attr_sets[attr_set_name]\n\n\nclass SpecMcastGroup(SpecElement):\n    \"\"\"Netlink Multicast Group\n\n    Information about a multicast group.\n\n    Value is only used for classic netlink families that use the\n    netlink-raw schema. Genetlink families use dynamic ID allocation\n    where the ids of multicast groups get resolved at runtime. Value\n    will be None for genetlink families.\n\n    Attributes:\n        name      name of the mulitcast group\n        value     integer id of this multicast group for netlink-raw or None\n        yaml      raw spec as loaded from the spec file\n    \"\"\"\n    def __init__(self, family, yaml):\n        super().__init__(family, yaml)\n        self.value = self.yaml.get('value')\n\n\nclass SpecFamily(SpecElement):\n    \"\"\" Netlink Family Spec class.\n\n    Netlink family information loaded from a spec (e.g. in YAML).\n    Takes care of unfolding implicit information which can be skipped\n    in the spec itself for brevity.\n\n    The class can be used like a dictionary to access the raw spec\n    elements but that's usually a bad idea.\n\n    Attributes:\n        proto     protocol type (e.g. genetlink)\n        msg_id_model   enum-model for operations (unified, directional etc.)\n        license   spec license (loaded from an SPDX tag on the spec)\n\n        attr_sets  dict of attribute sets\n        msgs       dict of all messages (index by name)\n        ops        dict of all valid requests / responses\n        ntfs       dict of all async events\n        consts     dict of all constants/enums\n        fixed_header  string, optional name of family default fixed header struct\n        mcast_groups  dict of all multicast groups (index by name)\n    \"\"\"\n    def __init__(self, spec_path, schema_path=None, exclude_ops=None):\n        with open(spec_path, \"r\") as stream:\n            prefix = '# SPDX-License-Identifier: '\n            first = stream.readline().strip()\n            if not first.startswith(prefix):\n                raise Exception('SPDX license tag required in the spec')\n            self.license = first[len(prefix):]\n\n            stream.seek(0)\n            spec = yaml.safe_load(stream)\n\n        self._resolution_list = []\n\n        super().__init__(self, spec)\n\n        self._exclude_ops = exclude_ops if exclude_ops else []\n\n        self.proto = self.yaml.get('protocol', 'genetlink')\n        self.msg_id_model = self.yaml['operations'].get('enum-model', 'unified')\n\n        if schema_path is None:\n            schema_path = os.path.dirname(os.path.dirname(spec_path)) + f'/{self.proto}.yaml'\n        if schema_path:\n            global jsonschema\n\n            with open(schema_path, \"r\") as stream:\n                schema = yaml.safe_load(stream)\n\n            if jsonschema is None:\n                jsonschema = importlib.import_module(\"jsonschema\")\n\n            jsonschema.validate(self.yaml, schema)\n\n        self.attr_sets = collections.OrderedDict()\n        self.msgs = collections.OrderedDict()\n        self.req_by_value = collections.OrderedDict()\n        self.rsp_by_value = collections.OrderedDict()\n        self.ops = collections.OrderedDict()\n        self.ntfs = collections.OrderedDict()\n        self.consts = collections.OrderedDict()\n        self.mcast_groups = collections.OrderedDict()\n\n        last_exception = None\n        while len(self._resolution_list) > 0:\n            resolved = []\n            unresolved = self._resolution_list\n            self._resolution_list = []\n\n            for elem in unresolved:\n                try:\n                    elem.resolve()\n                except (KeyError, AttributeError) as e:\n                    self._resolution_list.append(elem)\n                    last_exception = e\n                    continue\n\n                resolved.append(elem)\n\n            if len(resolved) == 0:\n                raise last_exception\n\n    def new_enum(self, elem):\n        return SpecEnumSet(self, elem)\n\n    def new_attr_set(self, elem):\n        return SpecAttrSet(self, elem)\n\n    def new_struct(self, elem):\n        return SpecStruct(self, elem)\n\n    def new_operation(self, elem, req_val, rsp_val):\n        return SpecOperation(self, elem, req_val, rsp_val)\n\n    def new_mcast_group(self, elem):\n        return SpecMcastGroup(self, elem)\n\n    def add_unresolved(self, elem):\n        self._resolution_list.append(elem)\n\n    def _dictify_ops_unified(self):\n        self.fixed_header = self.yaml['operations'].get('fixed-header')\n        val = 1\n        for elem in self.yaml['operations']['list']:\n            if 'value' in elem:\n                val = elem['value']\n\n            op = self.new_operation(elem, val, val)\n            val += 1\n\n            self.msgs[op.name] = op\n\n    def _dictify_ops_directional(self):\n        self.fixed_header = self.yaml['operations'].get('fixed-header')\n        req_val = rsp_val = 1\n        for elem in self.yaml['operations']['list']:\n            if 'notify' in elem or 'event' in elem:\n                if 'value' in elem:\n                    rsp_val = elem['value']\n                req_val_next = req_val\n                rsp_val_next = rsp_val + 1\n                req_val = None\n            elif 'do' in elem or 'dump' in elem:\n                mode = elem['do'] if 'do' in elem else elem['dump']\n\n                v = mode.get('request', {}).get('value', None)\n                if v:\n                    req_val = v\n                v = mode.get('reply', {}).get('value', None)\n                if v:\n                    rsp_val = v\n\n                rsp_inc = 1 if 'reply' in mode else 0\n                req_val_next = req_val + 1\n                rsp_val_next = rsp_val + rsp_inc\n            else:\n                raise Exception(\"Can't parse directional ops\")\n\n            if req_val == req_val_next:\n                req_val = None\n            if rsp_val == rsp_val_next:\n                rsp_val = None\n\n            skip = False\n            for exclude in self._exclude_ops:\n                skip |= bool(exclude.match(elem['name']))\n            if not skip:\n                op = self.new_operation(elem, req_val, rsp_val)\n\n            req_val = req_val_next\n            rsp_val = rsp_val_next\n\n            self.msgs[op.name] = op\n\n    def find_operation(self, name):\n      \"\"\"\n      For a given operation name, find and return operation spec.\n      \"\"\"\n      for op in self.yaml['operations']['list']:\n        if name == op['name']:\n          return op\n      return None\n\n    def resolve(self):\n        self.resolve_up(super())\n\n        definitions = self.yaml.get('definitions', [])\n        for elem in definitions:\n            if elem['type'] == 'enum' or elem['type'] == 'flags':\n                self.consts[elem['name']] = self.new_enum(elem)\n            elif elem['type'] == 'struct':\n                self.consts[elem['name']] = self.new_struct(elem)\n            else:\n                self.consts[elem['name']] = elem\n\n        for elem in self.yaml['attribute-sets']:\n            attr_set = self.new_attr_set(elem)\n            self.attr_sets[elem['name']] = attr_set\n\n        if self.msg_id_model == 'unified':\n            self._dictify_ops_unified()\n        elif self.msg_id_model == 'directional':\n            self._dictify_ops_directional()\n\n        for op in self.msgs.values():\n            if op.req_value is not None:\n                self.req_by_value[op.req_value] = op\n            if op.rsp_value is not None:\n                self.rsp_by_value[op.rsp_value] = op\n            if not op.is_async and 'attribute-set' in op:\n                self.ops[op.name] = op\n            elif op.is_async:\n                self.ntfs[op.name] = op\n\n        mcgs = self.yaml.get('mcast-groups')\n        if mcgs:\n            for elem in mcgs['list']:\n                mcg = self.new_mcast_group(elem)\n                self.mcast_groups[elem['name']] = mcg\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}