{
  "module_name": "ynl.py",
  "hash_id": "f4e56f0d7ae2fdb4f5f4fefc63f09c412f9718a8027ad9bcb886614a8de22f08",
  "original_prompt": "Ingested from linux-6.6.14/tools/net/ynl/lib/ynl.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause\n\nfrom collections import namedtuple\nimport functools\nimport os\nimport random\nimport socket\nimport struct\nfrom struct import Struct\nimport yaml\nimport ipaddress\nimport uuid\n\nfrom .nlspec import SpecFamily\n\n#\n# Generic Netlink code which should really be in some library, but I can't quickly find one.\n#\n\n\nclass Netlink:\n    # Netlink socket\n    SOL_NETLINK = 270\n\n    NETLINK_ADD_MEMBERSHIP = 1\n    NETLINK_CAP_ACK = 10\n    NETLINK_EXT_ACK = 11\n    NETLINK_GET_STRICT_CHK = 12\n\n    # Netlink message\n    NLMSG_ERROR = 2\n    NLMSG_DONE = 3\n\n    NLM_F_REQUEST = 1\n    NLM_F_ACK = 4\n    NLM_F_ROOT = 0x100\n    NLM_F_MATCH = 0x200\n\n    NLM_F_REPLACE = 0x100\n    NLM_F_EXCL = 0x200\n    NLM_F_CREATE = 0x400\n    NLM_F_APPEND = 0x800\n\n    NLM_F_CAPPED = 0x100\n    NLM_F_ACK_TLVS = 0x200\n\n    NLM_F_DUMP = NLM_F_ROOT | NLM_F_MATCH\n\n    NLA_F_NESTED = 0x8000\n    NLA_F_NET_BYTEORDER = 0x4000\n\n    NLA_TYPE_MASK = NLA_F_NESTED | NLA_F_NET_BYTEORDER\n\n    # Genetlink defines\n    NETLINK_GENERIC = 16\n\n    GENL_ID_CTRL = 0x10\n\n    # nlctrl\n    CTRL_CMD_GETFAMILY = 3\n\n    CTRL_ATTR_FAMILY_ID = 1\n    CTRL_ATTR_FAMILY_NAME = 2\n    CTRL_ATTR_MAXATTR = 5\n    CTRL_ATTR_MCAST_GROUPS = 7\n\n    CTRL_ATTR_MCAST_GRP_NAME = 1\n    CTRL_ATTR_MCAST_GRP_ID = 2\n\n    # Extack types\n    NLMSGERR_ATTR_MSG = 1\n    NLMSGERR_ATTR_OFFS = 2\n    NLMSGERR_ATTR_COOKIE = 3\n    NLMSGERR_ATTR_POLICY = 4\n    NLMSGERR_ATTR_MISS_TYPE = 5\n    NLMSGERR_ATTR_MISS_NEST = 6\n\n\nclass NlError(Exception):\n  def __init__(self, nl_msg):\n    self.nl_msg = nl_msg\n\n  def __str__(self):\n    return f\"Netlink error: {os.strerror(-self.nl_msg.error)}\\n{self.nl_msg}\"\n\n\nclass NlAttr:\n    ScalarFormat = namedtuple('ScalarFormat', ['native', 'big', 'little'])\n    type_formats = {\n        'u8' : ScalarFormat(Struct('B'), Struct(\"B\"),  Struct(\"B\")),\n        's8' : ScalarFormat(Struct('b'), Struct(\"b\"),  Struct(\"b\")),\n        'u16': ScalarFormat(Struct('H'), Struct(\">H\"), Struct(\"<H\")),\n        's16': ScalarFormat(Struct('h'), Struct(\">h\"), Struct(\"<h\")),\n        'u32': ScalarFormat(Struct('I'), Struct(\">I\"), Struct(\"<I\")),\n        's32': ScalarFormat(Struct('i'), Struct(\">i\"), Struct(\"<i\")),\n        'u64': ScalarFormat(Struct('Q'), Struct(\">Q\"), Struct(\"<Q\")),\n        's64': ScalarFormat(Struct('q'), Struct(\">q\"), Struct(\"<q\"))\n    }\n\n    def __init__(self, raw, offset):\n        self._len, self._type = struct.unpack(\"HH\", raw[offset:offset + 4])\n        self.type = self._type & ~Netlink.NLA_TYPE_MASK\n        self.payload_len = self._len\n        self.full_len = (self.payload_len + 3) & ~3\n        self.raw = raw[offset + 4:offset + self.payload_len]\n\n    @classmethod\n    def get_format(cls, attr_type, byte_order=None):\n        format = cls.type_formats[attr_type]\n        if byte_order:\n            return format.big if byte_order == \"big-endian\" \\\n                else format.little\n        return format.native\n\n    @classmethod\n    def formatted_string(cls, raw, display_hint):\n        if display_hint == 'mac':\n            formatted = ':'.join('%02x' % b for b in raw)\n        elif display_hint == 'hex':\n            formatted = bytes.hex(raw, ' ')\n        elif display_hint in [ 'ipv4', 'ipv6' ]:\n            formatted = format(ipaddress.ip_address(raw))\n        elif display_hint == 'uuid':\n            formatted = str(uuid.UUID(bytes=raw))\n        else:\n            formatted = raw\n        return formatted\n\n    def as_scalar(self, attr_type, byte_order=None):\n        format = self.get_format(attr_type, byte_order)\n        return format.unpack(self.raw)[0]\n\n    def as_strz(self):\n        return self.raw.decode('ascii')[:-1]\n\n    def as_bin(self):\n        return self.raw\n\n    def as_c_array(self, type):\n        format = self.get_format(type)\n        return [ x[0] for x in format.iter_unpack(self.raw) ]\n\n    def as_struct(self, members):\n        value = dict()\n        offset = 0\n        for m in members:\n            # TODO: handle non-scalar members\n            if m.type == 'binary':\n                decoded = self.raw[offset:offset+m['len']]\n                offset += m['len']\n            elif m.type in NlAttr.type_formats:\n                format = self.get_format(m.type, m.byte_order)\n                [ decoded ] = format.unpack_from(self.raw, offset)\n                offset += format.size\n            if m.display_hint:\n                decoded = self.formatted_string(decoded, m.display_hint)\n            value[m.name] = decoded\n        return value\n\n    def __repr__(self):\n        return f\"[type:{self.type} len:{self._len}] {self.raw}\"\n\n\nclass NlAttrs:\n    def __init__(self, msg):\n        self.attrs = []\n\n        offset = 0\n        while offset < len(msg):\n            attr = NlAttr(msg, offset)\n            offset += attr.full_len\n            self.attrs.append(attr)\n\n    def __iter__(self):\n        yield from self.attrs\n\n    def __repr__(self):\n        msg = ''\n        for a in self.attrs:\n            if msg:\n                msg += '\\n'\n            msg += repr(a)\n        return msg\n\n\nclass NlMsg:\n    def __init__(self, msg, offset, attr_space=None):\n        self.hdr = msg[offset:offset + 16]\n\n        self.nl_len, self.nl_type, self.nl_flags, self.nl_seq, self.nl_portid = \\\n            struct.unpack(\"IHHII\", self.hdr)\n\n        self.raw = msg[offset + 16:offset + self.nl_len]\n\n        self.error = 0\n        self.done = 0\n\n        extack_off = None\n        if self.nl_type == Netlink.NLMSG_ERROR:\n            self.error = struct.unpack(\"i\", self.raw[0:4])[0]\n            self.done = 1\n            extack_off = 20\n        elif self.nl_type == Netlink.NLMSG_DONE:\n            self.done = 1\n            extack_off = 4\n\n        self.extack = None\n        if self.nl_flags & Netlink.NLM_F_ACK_TLVS and extack_off:\n            self.extack = dict()\n            extack_attrs = NlAttrs(self.raw[extack_off:])\n            for extack in extack_attrs:\n                if extack.type == Netlink.NLMSGERR_ATTR_MSG:\n                    self.extack['msg'] = extack.as_strz()\n                elif extack.type == Netlink.NLMSGERR_ATTR_MISS_TYPE:\n                    self.extack['miss-type'] = extack.as_scalar('u32')\n                elif extack.type == Netlink.NLMSGERR_ATTR_MISS_NEST:\n                    self.extack['miss-nest'] = extack.as_scalar('u32')\n                elif extack.type == Netlink.NLMSGERR_ATTR_OFFS:\n                    self.extack['bad-attr-offs'] = extack.as_scalar('u32')\n                else:\n                    if 'unknown' not in self.extack:\n                        self.extack['unknown'] = []\n                    self.extack['unknown'].append(extack)\n\n            if attr_space:\n                # We don't have the ability to parse nests yet, so only do global\n                if 'miss-type' in self.extack and 'miss-nest' not in self.extack:\n                    miss_type = self.extack['miss-type']\n                    if miss_type in attr_space.attrs_by_val:\n                        spec = attr_space.attrs_by_val[miss_type]\n                        desc = spec['name']\n                        if 'doc' in spec:\n                            desc += f\" ({spec['doc']})\"\n                        self.extack['miss-type'] = desc\n\n    def cmd(self):\n        return self.nl_type\n\n    def __repr__(self):\n        msg = f\"nl_len = {self.nl_len} ({len(self.raw)}) nl_flags = 0x{self.nl_flags:x} nl_type = {self.nl_type}\\n\"\n        if self.error:\n            msg += '\\terror: ' + str(self.error)\n        if self.extack:\n            msg += '\\textack: ' + repr(self.extack)\n        return msg\n\n\nclass NlMsgs:\n    def __init__(self, data, attr_space=None):\n        self.msgs = []\n\n        offset = 0\n        while offset < len(data):\n            msg = NlMsg(data, offset, attr_space=attr_space)\n            offset += msg.nl_len\n            self.msgs.append(msg)\n\n    def __iter__(self):\n        yield from self.msgs\n\n\ngenl_family_name_to_id = None\n\n\ndef _genl_msg(nl_type, nl_flags, genl_cmd, genl_version, seq=None):\n    # we prepend length in _genl_msg_finalize()\n    if seq is None:\n        seq = random.randint(1, 1024)\n    nlmsg = struct.pack(\"HHII\", nl_type, nl_flags, seq, 0)\n    genlmsg = struct.pack(\"BBH\", genl_cmd, genl_version, 0)\n    return nlmsg + genlmsg\n\n\ndef _genl_msg_finalize(msg):\n    return struct.pack(\"I\", len(msg) + 4) + msg\n\n\ndef _genl_load_families():\n    with socket.socket(socket.AF_NETLINK, socket.SOCK_RAW, Netlink.NETLINK_GENERIC) as sock:\n        sock.setsockopt(Netlink.SOL_NETLINK, Netlink.NETLINK_CAP_ACK, 1)\n\n        msg = _genl_msg(Netlink.GENL_ID_CTRL,\n                        Netlink.NLM_F_REQUEST | Netlink.NLM_F_ACK | Netlink.NLM_F_DUMP,\n                        Netlink.CTRL_CMD_GETFAMILY, 1)\n        msg = _genl_msg_finalize(msg)\n\n        sock.send(msg, 0)\n\n        global genl_family_name_to_id\n        genl_family_name_to_id = dict()\n\n        while True:\n            reply = sock.recv(128 * 1024)\n            nms = NlMsgs(reply)\n            for nl_msg in nms:\n                if nl_msg.error:\n                    print(\"Netlink error:\", nl_msg.error)\n                    return\n                if nl_msg.done:\n                    return\n\n                gm = GenlMsg(nl_msg)\n                fam = dict()\n                for attr in NlAttrs(gm.raw):\n                    if attr.type == Netlink.CTRL_ATTR_FAMILY_ID:\n                        fam['id'] = attr.as_scalar('u16')\n                    elif attr.type == Netlink.CTRL_ATTR_FAMILY_NAME:\n                        fam['name'] = attr.as_strz()\n                    elif attr.type == Netlink.CTRL_ATTR_MAXATTR:\n                        fam['maxattr'] = attr.as_scalar('u32')\n                    elif attr.type == Netlink.CTRL_ATTR_MCAST_GROUPS:\n                        fam['mcast'] = dict()\n                        for entry in NlAttrs(attr.raw):\n                            mcast_name = None\n                            mcast_id = None\n                            for entry_attr in NlAttrs(entry.raw):\n                                if entry_attr.type == Netlink.CTRL_ATTR_MCAST_GRP_NAME:\n                                    mcast_name = entry_attr.as_strz()\n                                elif entry_attr.type == Netlink.CTRL_ATTR_MCAST_GRP_ID:\n                                    mcast_id = entry_attr.as_scalar('u32')\n                            if mcast_name and mcast_id is not None:\n                                fam['mcast'][mcast_name] = mcast_id\n                if 'name' in fam and 'id' in fam:\n                    genl_family_name_to_id[fam['name']] = fam\n\n\nclass GenlMsg:\n    def __init__(self, nl_msg):\n        self.nl = nl_msg\n        self.genl_cmd, self.genl_version, _ = struct.unpack_from(\"BBH\", nl_msg.raw, 0)\n        self.raw = nl_msg.raw[4:]\n\n    def cmd(self):\n        return self.genl_cmd\n\n    def __repr__(self):\n        msg = repr(self.nl)\n        msg += f\"\\tgenl_cmd = {self.genl_cmd} genl_ver = {self.genl_version}\\n\"\n        for a in self.raw_attrs:\n            msg += '\\t\\t' + repr(a) + '\\n'\n        return msg\n\n\nclass NetlinkProtocol:\n    def __init__(self, family_name, proto_num):\n        self.family_name = family_name\n        self.proto_num = proto_num\n\n    def _message(self, nl_type, nl_flags, seq=None):\n        if seq is None:\n            seq = random.randint(1, 1024)\n        nlmsg = struct.pack(\"HHII\", nl_type, nl_flags, seq, 0)\n        return nlmsg\n\n    def message(self, flags, command, version, seq=None):\n        return self._message(command, flags, seq)\n\n    def _decode(self, nl_msg):\n        return nl_msg\n\n    def decode(self, ynl, nl_msg):\n        msg = self._decode(nl_msg)\n        fixed_header_size = 0\n        if ynl:\n            op = ynl.rsp_by_value[msg.cmd()]\n            fixed_header_size = ynl._fixed_header_size(op)\n        msg.raw_attrs = NlAttrs(msg.raw[fixed_header_size:])\n        return msg\n\n    def get_mcast_id(self, mcast_name, mcast_groups):\n        if mcast_name not in mcast_groups:\n            raise Exception(f'Multicast group \"{mcast_name}\" not present in the spec')\n        return mcast_groups[mcast_name].value\n\n\nclass GenlProtocol(NetlinkProtocol):\n    def __init__(self, family_name):\n        super().__init__(family_name, Netlink.NETLINK_GENERIC)\n\n        global genl_family_name_to_id\n        if genl_family_name_to_id is None:\n            _genl_load_families()\n\n        self.genl_family = genl_family_name_to_id[family_name]\n        self.family_id = genl_family_name_to_id[family_name]['id']\n\n    def message(self, flags, command, version, seq=None):\n        nlmsg = self._message(self.family_id, flags, seq)\n        genlmsg = struct.pack(\"BBH\", command, version, 0)\n        return nlmsg + genlmsg\n\n    def _decode(self, nl_msg):\n        return GenlMsg(nl_msg)\n\n    def get_mcast_id(self, mcast_name, mcast_groups):\n        if mcast_name not in self.genl_family['mcast']:\n            raise Exception(f'Multicast group \"{mcast_name}\" not present in the family')\n        return self.genl_family['mcast'][mcast_name]\n\n\n#\n# YNL implementation details.\n#\n\n\nclass YnlFamily(SpecFamily):\n    def __init__(self, def_path, schema=None):\n        super().__init__(def_path, schema)\n\n        self.include_raw = False\n\n        try:\n            if self.proto == \"netlink-raw\":\n                self.nlproto = NetlinkProtocol(self.yaml['name'],\n                                               self.yaml['protonum'])\n            else:\n                self.nlproto = GenlProtocol(self.yaml['name'])\n        except KeyError:\n            raise Exception(f\"Family '{self.yaml['name']}' not supported by the kernel\")\n\n        self.sock = socket.socket(socket.AF_NETLINK, socket.SOCK_RAW, self.nlproto.proto_num)\n        self.sock.setsockopt(Netlink.SOL_NETLINK, Netlink.NETLINK_CAP_ACK, 1)\n        self.sock.setsockopt(Netlink.SOL_NETLINK, Netlink.NETLINK_EXT_ACK, 1)\n        self.sock.setsockopt(Netlink.SOL_NETLINK, Netlink.NETLINK_GET_STRICT_CHK, 1)\n\n        self.async_msg_ids = set()\n        self.async_msg_queue = []\n\n        for msg in self.msgs.values():\n            if msg.is_async:\n                self.async_msg_ids.add(msg.rsp_value)\n\n        for op_name, op in self.ops.items():\n            bound_f = functools.partial(self._op, op_name)\n            setattr(self, op.ident_name, bound_f)\n\n\n    def ntf_subscribe(self, mcast_name):\n        mcast_id = self.nlproto.get_mcast_id(mcast_name, self.mcast_groups)\n        self.sock.bind((0, 0))\n        self.sock.setsockopt(Netlink.SOL_NETLINK, Netlink.NETLINK_ADD_MEMBERSHIP,\n                             mcast_id)\n\n    def _add_attr(self, space, name, value):\n        try:\n            attr = self.attr_sets[space][name]\n        except KeyError:\n            raise Exception(f\"Space '{space}' has no attribute '{name}'\")\n        nl_type = attr.value\n        if attr[\"type\"] == 'nest':\n            nl_type |= Netlink.NLA_F_NESTED\n            attr_payload = b''\n            for subname, subvalue in value.items():\n                attr_payload += self._add_attr(attr['nested-attributes'], subname, subvalue)\n        elif attr[\"type\"] == 'flag':\n            attr_payload = b''\n        elif attr[\"type\"] == 'string':\n            attr_payload = str(value).encode('ascii') + b'\\x00'\n        elif attr[\"type\"] == 'binary':\n            if isinstance(value, bytes):\n                attr_payload = value\n            elif isinstance(value, str):\n                attr_payload = bytes.fromhex(value)\n            else:\n                raise Exception(f'Unknown type for binary attribute, value: {value}')\n        elif attr['type'] in NlAttr.type_formats:\n            format = NlAttr.get_format(attr['type'], attr.byte_order)\n            attr_payload = format.pack(int(value))\n        else:\n            raise Exception(f'Unknown type at {space} {name} {value} {attr[\"type\"]}')\n\n        pad = b'\\x00' * ((4 - len(attr_payload) % 4) % 4)\n        return struct.pack('HH', len(attr_payload) + 4, nl_type) + attr_payload + pad\n\n    def _decode_enum(self, raw, attr_spec):\n        enum = self.consts[attr_spec['enum']]\n        if 'enum-as-flags' in attr_spec and attr_spec['enum-as-flags']:\n            i = 0\n            value = set()\n            while raw:\n                if raw & 1:\n                    value.add(enum.entries_by_val[i].name)\n                raw >>= 1\n                i += 1\n        else:\n            value = enum.entries_by_val[raw].name\n        return value\n\n    def _decode_binary(self, attr, attr_spec):\n        if attr_spec.struct_name:\n            members = self.consts[attr_spec.struct_name]\n            decoded = attr.as_struct(members)\n            for m in members:\n                if m.enum:\n                    decoded[m.name] = self._decode_enum(decoded[m.name], m)\n        elif attr_spec.sub_type:\n            decoded = attr.as_c_array(attr_spec.sub_type)\n        else:\n            decoded = attr.as_bin()\n            if attr_spec.display_hint:\n                decoded = NlAttr.formatted_string(decoded, attr_spec.display_hint)\n        return decoded\n\n    def _decode_array_nest(self, attr, attr_spec):\n        decoded = []\n        offset = 0\n        while offset < len(attr.raw):\n            item = NlAttr(attr.raw, offset)\n            offset += item.full_len\n\n            subattrs = self._decode(NlAttrs(item.raw), attr_spec['nested-attributes'])\n            decoded.append({ item.type: subattrs })\n        return decoded\n\n    def _decode(self, attrs, space):\n        attr_space = self.attr_sets[space]\n        rsp = dict()\n        for attr in attrs:\n            try:\n                attr_spec = attr_space.attrs_by_val[attr.type]\n            except KeyError:\n                raise Exception(f\"Space '{space}' has no attribute with value '{attr.type}'\")\n            if attr_spec[\"type\"] == 'nest':\n                subdict = self._decode(NlAttrs(attr.raw), attr_spec['nested-attributes'])\n                decoded = subdict\n            elif attr_spec[\"type\"] == 'string':\n                decoded = attr.as_strz()\n            elif attr_spec[\"type\"] == 'binary':\n                decoded = self._decode_binary(attr, attr_spec)\n            elif attr_spec[\"type\"] == 'flag':\n                decoded = True\n            elif attr_spec[\"type\"] in NlAttr.type_formats:\n                decoded = attr.as_scalar(attr_spec['type'], attr_spec.byte_order)\n            elif attr_spec[\"type\"] == 'array-nest':\n                decoded = self._decode_array_nest(attr, attr_spec)\n            else:\n                raise Exception(f'Unknown {attr_spec[\"type\"]} with name {attr_spec[\"name\"]}')\n\n            if 'enum' in attr_spec:\n                decoded = self._decode_enum(decoded, attr_spec)\n\n            if not attr_spec.is_multi:\n                rsp[attr_spec['name']] = decoded\n            elif attr_spec.name in rsp:\n                rsp[attr_spec.name].append(decoded)\n            else:\n                rsp[attr_spec.name] = [decoded]\n\n        return rsp\n\n    def _decode_extack_path(self, attrs, attr_set, offset, target):\n        for attr in attrs:\n            try:\n                attr_spec = attr_set.attrs_by_val[attr.type]\n            except KeyError:\n                raise Exception(f\"Space '{attr_set.name}' has no attribute with value '{attr.type}'\")\n            if offset > target:\n                break\n            if offset == target:\n                return '.' + attr_spec.name\n\n            if offset + attr.full_len <= target:\n                offset += attr.full_len\n                continue\n            if attr_spec['type'] != 'nest':\n                raise Exception(f\"Can't dive into {attr.type} ({attr_spec['name']}) for extack\")\n            offset += 4\n            subpath = self._decode_extack_path(NlAttrs(attr.raw),\n                                               self.attr_sets[attr_spec['nested-attributes']],\n                                               offset, target)\n            if subpath is None:\n                return None\n            return '.' + attr_spec.name + subpath\n\n        return None\n\n    def _decode_extack(self, request, op, extack):\n        if 'bad-attr-offs' not in extack:\n            return\n\n        msg = self.nlproto.decode(self, NlMsg(request, 0, op.attr_set))\n        offset = 20 + self._fixed_header_size(op)\n        path = self._decode_extack_path(msg.raw_attrs, op.attr_set, offset,\n                                        extack['bad-attr-offs'])\n        if path:\n            del extack['bad-attr-offs']\n            extack['bad-attr'] = path\n\n    def _fixed_header_size(self, op):\n        if op.fixed_header:\n            fixed_header_members = self.consts[op.fixed_header].members\n            size = 0\n            for m in fixed_header_members:\n                format = NlAttr.get_format(m.type, m.byte_order)\n                size += format.size\n            return size\n        else:\n            return 0\n\n    def _decode_fixed_header(self, msg, name):\n        fixed_header_members = self.consts[name].members\n        fixed_header_attrs = dict()\n        offset = 0\n        for m in fixed_header_members:\n            format = NlAttr.get_format(m.type, m.byte_order)\n            [ value ] = format.unpack_from(msg.raw, offset)\n            offset += format.size\n            if m.enum:\n                value = self._decode_enum(value, m)\n            fixed_header_attrs[m.name] = value\n        return fixed_header_attrs\n\n    def handle_ntf(self, decoded):\n        msg = dict()\n        if self.include_raw:\n            msg['raw'] = decoded\n        op = self.rsp_by_value[decoded.cmd()]\n        attrs = self._decode(decoded.raw_attrs, op.attr_set.name)\n        if op.fixed_header:\n            attrs.update(self._decode_fixed_header(decoded, op.fixed_header))\n\n        msg['name'] = op['name']\n        msg['msg'] = attrs\n        self.async_msg_queue.append(msg)\n\n    def check_ntf(self):\n        while True:\n            try:\n                reply = self.sock.recv(128 * 1024, socket.MSG_DONTWAIT)\n            except BlockingIOError:\n                return\n\n            nms = NlMsgs(reply)\n            for nl_msg in nms:\n                if nl_msg.error:\n                    print(\"Netlink error in ntf!?\", os.strerror(-nl_msg.error))\n                    print(nl_msg)\n                    continue\n                if nl_msg.done:\n                    print(\"Netlink done while checking for ntf!?\")\n                    continue\n\n                decoded = self.nlproto.decode(self, nl_msg)\n                if decoded.cmd() not in self.async_msg_ids:\n                    print(\"Unexpected msg id done while checking for ntf\", decoded)\n                    continue\n\n                self.handle_ntf(decoded)\n\n    def operation_do_attributes(self, name):\n      \"\"\"\n      For a given operation name, find and return a supported\n      set of attributes (as a dict).\n      \"\"\"\n      op = self.find_operation(name)\n      if not op:\n        return None\n\n      return op['do']['request']['attributes'].copy()\n\n    def _op(self, method, vals, flags, dump=False):\n        op = self.ops[method]\n\n        nl_flags = Netlink.NLM_F_REQUEST | Netlink.NLM_F_ACK\n        for flag in flags or []:\n            nl_flags |= flag\n        if dump:\n            nl_flags |= Netlink.NLM_F_DUMP\n\n        req_seq = random.randint(1024, 65535)\n        msg = self.nlproto.message(nl_flags, op.req_value, 1, req_seq)\n        fixed_header_members = []\n        if op.fixed_header:\n            fixed_header_members = self.consts[op.fixed_header].members\n            for m in fixed_header_members:\n                value = vals.pop(m.name) if m.name in vals else 0\n                format = NlAttr.get_format(m.type, m.byte_order)\n                msg += format.pack(value)\n        for name, value in vals.items():\n            msg += self._add_attr(op.attr_set.name, name, value)\n        msg = _genl_msg_finalize(msg)\n\n        self.sock.send(msg, 0)\n\n        done = False\n        rsp = []\n        while not done:\n            reply = self.sock.recv(128 * 1024)\n            nms = NlMsgs(reply, attr_space=op.attr_set)\n            for nl_msg in nms:\n                if nl_msg.extack:\n                    self._decode_extack(msg, op, nl_msg.extack)\n\n                if nl_msg.error:\n                    raise NlError(nl_msg)\n                if nl_msg.done:\n                    if nl_msg.extack:\n                        print(\"Netlink warning:\")\n                        print(nl_msg)\n                    done = True\n                    break\n\n                decoded = self.nlproto.decode(self, nl_msg)\n\n                # Check if this is a reply to our request\n                if nl_msg.nl_seq != req_seq or decoded.cmd() != op.rsp_value:\n                    if decoded.cmd() in self.async_msg_ids:\n                        self.handle_ntf(decoded)\n                        continue\n                    else:\n                        print('Unexpected message: ' + repr(decoded))\n                        continue\n\n                rsp_msg = self._decode(decoded.raw_attrs, op.attr_set.name)\n                if op.fixed_header:\n                    rsp_msg.update(self._decode_fixed_header(decoded, op.fixed_header))\n                rsp.append(rsp_msg)\n\n        if not rsp:\n            return None\n        if not dump and len(rsp) == 1:\n            return rsp[0]\n        return rsp\n\n    def do(self, method, vals, flags):\n        return self._op(method, vals, flags)\n\n    def dump(self, method, vals):\n        return self._op(method, vals, [], dump=True)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}