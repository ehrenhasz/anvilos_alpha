{
  "module_name": "ynl.c",
  "hash_id": "2f0bcb7398e460f69cff9ea679de6e37428a71cb2827e876654b60c3c5df78e8",
  "original_prompt": "Ingested from linux-6.6.14/tools/net/ynl/lib/ynl.c",
  "human_readable_source": "\n#include <errno.h>\n#include <poll.h>\n#include <string.h>\n#include <stdlib.h>\n#include <linux/types.h>\n\n#include <libmnl/libmnl.h>\n#include <linux/genetlink.h>\n\n#include \"ynl.h\"\n\n#define ARRAY_SIZE(arr)\t\t(sizeof(arr) / sizeof(*arr))\n\n#define __yerr_msg(yse, _msg...)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tstruct ynl_error *_yse = (yse);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (_yse) {\t\t\t\t\t\t\\\n\t\t\tsnprintf(_yse->msg, sizeof(_yse->msg) - 1,  _msg); \\\n\t\t\t_yse->msg[sizeof(_yse->msg) - 1] = 0;\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t})\n\n#define __yerr_code(yse, _code...)\t\t\\\n\t({\t\t\t\t\t\\\n\t\tstruct ynl_error *_yse = (yse);\t\\\n\t\t\t\t\t\t\\\n\t\tif (_yse) {\t\t\t\\\n\t\t\t_yse->code = _code;\t\\\n\t\t}\t\t\t\t\\\n\t})\n\n#define __yerr(yse, _code, _msg...)\t\t\\\n\t({\t\t\t\t\t\\\n\t\t__yerr_msg(yse, _msg);\t\t\\\n\t\t__yerr_code(yse, _code);\t\\\n\t})\n\n#define __perr(yse, _msg)\t\t__yerr(yse, errno, _msg)\n\n#define yerr_msg(_ys, _msg...)\t\t__yerr_msg(&(_ys)->err, _msg)\n#define yerr(_ys, _code, _msg...)\t__yerr(&(_ys)->err, _code, _msg)\n#define perr(_ys, _msg)\t\t\t__yerr(&(_ys)->err, errno, _msg)\n\n \nstatic int\nynl_err_walk_report_one(struct ynl_policy_nest *policy, unsigned int type,\n\t\t\tchar *str, int str_sz, int *n)\n{\n\tif (!policy) {\n\t\tif (*n < str_sz)\n\t\t\t*n += snprintf(str, str_sz, \"!policy\");\n\t\treturn 1;\n\t}\n\n\tif (type > policy->max_attr) {\n\t\tif (*n < str_sz)\n\t\t\t*n += snprintf(str, str_sz, \"!oob\");\n\t\treturn 1;\n\t}\n\n\tif (!policy->table[type].name) {\n\t\tif (*n < str_sz)\n\t\t\t*n += snprintf(str, str_sz, \"!name\");\n\t\treturn 1;\n\t}\n\n\tif (*n < str_sz)\n\t\t*n += snprintf(str, str_sz - *n,\n\t\t\t       \".%s\", policy->table[type].name);\n\treturn 0;\n}\n\nstatic int\nynl_err_walk(struct ynl_sock *ys, void *start, void *end, unsigned int off,\n\t     struct ynl_policy_nest *policy, char *str, int str_sz,\n\t     struct ynl_policy_nest **nest_pol)\n{\n\tunsigned int astart_off, aend_off;\n\tconst struct nlattr *attr;\n\tunsigned int data_len;\n\tunsigned int type;\n\tbool found = false;\n\tint n = 0;\n\n\tif (!policy) {\n\t\tif (n < str_sz)\n\t\t\tn += snprintf(str, str_sz, \"!policy\");\n\t\treturn n;\n\t}\n\n\tdata_len = end - start;\n\n\tmnl_attr_for_each_payload(start, data_len) {\n\t\tastart_off = (char *)attr - (char *)start;\n\t\taend_off = astart_off + mnl_attr_get_payload_len(attr);\n\t\tif (aend_off <= off)\n\t\t\tcontinue;\n\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found)\n\t\treturn 0;\n\n\toff -= astart_off;\n\n\ttype = mnl_attr_get_type(attr);\n\n\tif (ynl_err_walk_report_one(policy, type, str, str_sz, &n))\n\t\treturn n;\n\n\tif (!off) {\n\t\tif (nest_pol)\n\t\t\t*nest_pol = policy->table[type].nest;\n\t\treturn n;\n\t}\n\n\tif (!policy->table[type].nest) {\n\t\tif (n < str_sz)\n\t\t\tn += snprintf(str, str_sz, \"!nest\");\n\t\treturn n;\n\t}\n\n\toff -= sizeof(struct nlattr);\n\tstart =  mnl_attr_get_payload(attr);\n\tend = start + mnl_attr_get_payload_len(attr);\n\n\treturn n + ynl_err_walk(ys, start, end, off, policy->table[type].nest,\n\t\t\t\t&str[n], str_sz - n, nest_pol);\n}\n\n#define NLMSGERR_ATTR_MISS_TYPE (NLMSGERR_ATTR_POLICY + 1)\n#define NLMSGERR_ATTR_MISS_NEST (NLMSGERR_ATTR_POLICY + 2)\n#define NLMSGERR_ATTR_MAX (NLMSGERR_ATTR_MAX + 2)\n\nstatic int\nynl_ext_ack_check(struct ynl_sock *ys, const struct nlmsghdr *nlh,\n\t\t  unsigned int hlen)\n{\n\tconst struct nlattr *tb[NLMSGERR_ATTR_MAX + 1] = {};\n\tchar miss_attr[sizeof(ys->err.msg)];\n\tchar bad_attr[sizeof(ys->err.msg)];\n\tconst struct nlattr *attr;\n\tconst char *str = NULL;\n\n\tif (!(nlh->nlmsg_flags & NLM_F_ACK_TLVS))\n\t\treturn MNL_CB_OK;\n\n\tmnl_attr_for_each(attr, nlh, hlen) {\n\t\tunsigned int len, type;\n\n\t\tlen = mnl_attr_get_payload_len(attr);\n\t\ttype = mnl_attr_get_type(attr);\n\n\t\tif (type > NLMSGERR_ATTR_MAX)\n\t\t\tcontinue;\n\n\t\ttb[type] = attr;\n\n\t\tswitch (type) {\n\t\tcase NLMSGERR_ATTR_OFFS:\n\t\tcase NLMSGERR_ATTR_MISS_TYPE:\n\t\tcase NLMSGERR_ATTR_MISS_NEST:\n\t\t\tif (len != sizeof(__u32))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tbreak;\n\t\tcase NLMSGERR_ATTR_MSG:\n\t\t\tstr = mnl_attr_get_payload(attr);\n\t\t\tif (str[len - 1])\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbad_attr[0] = '\\0';\n\tmiss_attr[0] = '\\0';\n\n\tif (tb[NLMSGERR_ATTR_OFFS]) {\n\t\tunsigned int n, off;\n\t\tvoid *start, *end;\n\n\t\tys->err.attr_offs = mnl_attr_get_u32(tb[NLMSGERR_ATTR_OFFS]);\n\n\t\tn = snprintf(bad_attr, sizeof(bad_attr), \"%sbad attribute: \",\n\t\t\t     str ? \" (\" : \"\");\n\n\t\tstart = mnl_nlmsg_get_payload_offset(ys->nlh,\n\t\t\t\t\t\t     sizeof(struct genlmsghdr));\n\t\tend = mnl_nlmsg_get_payload_tail(ys->nlh);\n\n\t\toff = ys->err.attr_offs;\n\t\toff -= sizeof(struct nlmsghdr);\n\t\toff -= sizeof(struct genlmsghdr);\n\n\t\tn += ynl_err_walk(ys, start, end, off, ys->req_policy,\n\t\t\t\t  &bad_attr[n], sizeof(bad_attr) - n, NULL);\n\n\t\tif (n >= sizeof(bad_attr))\n\t\t\tn = sizeof(bad_attr) - 1;\n\t\tbad_attr[n] = '\\0';\n\t}\n\tif (tb[NLMSGERR_ATTR_MISS_TYPE]) {\n\t\tstruct ynl_policy_nest *nest_pol = NULL;\n\t\tunsigned int n, off, type;\n\t\tvoid *start, *end;\n\t\tint n2;\n\n\t\ttype = mnl_attr_get_u32(tb[NLMSGERR_ATTR_MISS_TYPE]);\n\n\t\tn = snprintf(miss_attr, sizeof(miss_attr), \"%smissing attribute: \",\n\t\t\t     bad_attr[0] ? \", \" : (str ? \" (\" : \"\"));\n\n\t\tstart = mnl_nlmsg_get_payload_offset(ys->nlh,\n\t\t\t\t\t\t     sizeof(struct genlmsghdr));\n\t\tend = mnl_nlmsg_get_payload_tail(ys->nlh);\n\n\t\tnest_pol = ys->req_policy;\n\t\tif (tb[NLMSGERR_ATTR_MISS_NEST]) {\n\t\t\toff = mnl_attr_get_u32(tb[NLMSGERR_ATTR_MISS_NEST]);\n\t\t\toff -= sizeof(struct nlmsghdr);\n\t\t\toff -= sizeof(struct genlmsghdr);\n\n\t\t\tn += ynl_err_walk(ys, start, end, off, ys->req_policy,\n\t\t\t\t\t  &miss_attr[n], sizeof(miss_attr) - n,\n\t\t\t\t\t  &nest_pol);\n\t\t}\n\n\t\tn2 = 0;\n\t\tynl_err_walk_report_one(nest_pol, type, &miss_attr[n],\n\t\t\t\t\tsizeof(miss_attr) - n, &n2);\n\t\tn += n2;\n\n\t\tif (n >= sizeof(miss_attr))\n\t\t\tn = sizeof(miss_attr) - 1;\n\t\tmiss_attr[n] = '\\0';\n\t}\n\n\t \n\tif (str)\n\t\tyerr_msg(ys, \"Kernel %s: '%s'%s%s%s\",\n\t\t\t ys->err.code ? \"error\" : \"warning\",\n\t\t\t str, bad_attr, miss_attr,\n\t\t\t bad_attr[0] || miss_attr[0] ? \")\" : \"\");\n\telse if (bad_attr[0] || miss_attr[0])\n\t\tyerr_msg(ys, \"Kernel %s: %s%s\",\n\t\t\t ys->err.code ? \"error\" : \"warning\",\n\t\t\t bad_attr, miss_attr);\n\n\treturn MNL_CB_OK;\n}\n\nstatic int ynl_cb_error(const struct nlmsghdr *nlh, void *data)\n{\n\tconst struct nlmsgerr *err = mnl_nlmsg_get_payload(nlh);\n\tstruct ynl_parse_arg *yarg = data;\n\tunsigned int hlen;\n\tint code;\n\n\tcode = err->error >= 0 ? err->error : -err->error;\n\tyarg->ys->err.code = code;\n\terrno = code;\n\n\thlen = sizeof(*err);\n\tif (!(nlh->nlmsg_flags & NLM_F_CAPPED))\n\t\thlen += mnl_nlmsg_get_payload_len(&err->msg);\n\n\tynl_ext_ack_check(yarg->ys, nlh, hlen);\n\n\treturn code ? MNL_CB_ERROR : MNL_CB_STOP;\n}\n\nstatic int ynl_cb_done(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tint err;\n\n\terr = *(int *)NLMSG_DATA(nlh);\n\tif (err < 0) {\n\t\tyarg->ys->err.code = -err;\n\t\terrno = -err;\n\n\t\tynl_ext_ack_check(yarg->ys, nlh, sizeof(int));\n\n\t\treturn MNL_CB_ERROR;\n\t}\n\treturn MNL_CB_STOP;\n}\n\nstatic int ynl_cb_noop(const struct nlmsghdr *nlh, void *data)\n{\n\treturn MNL_CB_OK;\n}\n\nmnl_cb_t ynl_cb_array[NLMSG_MIN_TYPE] = {\n\t[NLMSG_NOOP]\t= ynl_cb_noop,\n\t[NLMSG_ERROR]\t= ynl_cb_error,\n\t[NLMSG_DONE]\t= ynl_cb_done,\n\t[NLMSG_OVERRUN]\t= ynl_cb_noop,\n};\n\n \n\nint ynl_attr_validate(struct ynl_parse_arg *yarg, const struct nlattr *attr)\n{\n\tstruct ynl_policy_attr *policy;\n\tunsigned int type, len;\n\tunsigned char *data;\n\n\tdata = mnl_attr_get_payload(attr);\n\tlen = mnl_attr_get_payload_len(attr);\n\ttype = mnl_attr_get_type(attr);\n\tif (type > yarg->rsp_policy->max_attr) {\n\t\tyerr(yarg->ys, YNL_ERROR_INTERNAL,\n\t\t     \"Internal error, validating unknown attribute\");\n\t\treturn -1;\n\t}\n\n\tpolicy = &yarg->rsp_policy->table[type];\n\n\tswitch (policy->type) {\n\tcase YNL_PT_REJECT:\n\t\tyerr(yarg->ys, YNL_ERROR_ATTR_INVALID,\n\t\t     \"Rejected attribute (%s)\", policy->name);\n\t\treturn -1;\n\tcase YNL_PT_IGNORE:\n\t\tbreak;\n\tcase YNL_PT_U8:\n\t\tif (len == sizeof(__u8))\n\t\t\tbreak;\n\t\tyerr(yarg->ys, YNL_ERROR_ATTR_INVALID,\n\t\t     \"Invalid attribute (u8 %s)\", policy->name);\n\t\treturn -1;\n\tcase YNL_PT_U16:\n\t\tif (len == sizeof(__u16))\n\t\t\tbreak;\n\t\tyerr(yarg->ys, YNL_ERROR_ATTR_INVALID,\n\t\t     \"Invalid attribute (u16 %s)\", policy->name);\n\t\treturn -1;\n\tcase YNL_PT_U32:\n\t\tif (len == sizeof(__u32))\n\t\t\tbreak;\n\t\tyerr(yarg->ys, YNL_ERROR_ATTR_INVALID,\n\t\t     \"Invalid attribute (u32 %s)\", policy->name);\n\t\treturn -1;\n\tcase YNL_PT_U64:\n\t\tif (len == sizeof(__u64))\n\t\t\tbreak;\n\t\tyerr(yarg->ys, YNL_ERROR_ATTR_INVALID,\n\t\t     \"Invalid attribute (u64 %s)\", policy->name);\n\t\treturn -1;\n\tcase YNL_PT_FLAG:\n\t\t \n\t\tbreak;\n\tcase YNL_PT_NEST:\n\t\tif (!len || len >= sizeof(*attr))\n\t\t\tbreak;\n\t\tyerr(yarg->ys, YNL_ERROR_ATTR_INVALID,\n\t\t     \"Invalid attribute (nest %s)\", policy->name);\n\t\treturn -1;\n\tcase YNL_PT_BINARY:\n\t\tif (!policy->len || len == policy->len)\n\t\t\tbreak;\n\t\tyerr(yarg->ys, YNL_ERROR_ATTR_INVALID,\n\t\t     \"Invalid attribute (binary %s)\", policy->name);\n\t\treturn -1;\n\tcase YNL_PT_NUL_STR:\n\t\tif ((!policy->len || len <= policy->len) && !data[len - 1])\n\t\t\tbreak;\n\t\tyerr(yarg->ys, YNL_ERROR_ATTR_INVALID,\n\t\t     \"Invalid attribute (string %s)\", policy->name);\n\t\treturn -1;\n\tdefault:\n\t\tyerr(yarg->ys, YNL_ERROR_ATTR_INVALID,\n\t\t     \"Invalid attribute (unknown %s)\", policy->name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void ynl_err_reset(struct ynl_sock *ys)\n{\n\tys->err.code = 0;\n\tys->err.attr_offs = 0;\n\tys->err.msg[0] = 0;\n}\n\nstruct nlmsghdr *ynl_msg_start(struct ynl_sock *ys, __u32 id, __u16 flags)\n{\n\tstruct nlmsghdr *nlh;\n\n\tynl_err_reset(ys);\n\n\tnlh = ys->nlh = mnl_nlmsg_put_header(ys->tx_buf);\n\tnlh->nlmsg_type\t= id;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_seq = ++ys->seq;\n\n\treturn nlh;\n}\n\nstruct nlmsghdr *\nynl_gemsg_start(struct ynl_sock *ys, __u32 id, __u16 flags,\n\t\t__u8 cmd, __u8 version)\n{\n\tstruct genlmsghdr gehdr;\n\tstruct nlmsghdr *nlh;\n\tvoid *data;\n\n\tnlh = ynl_msg_start(ys, id, flags);\n\n\tmemset(&gehdr, 0, sizeof(gehdr));\n\tgehdr.cmd = cmd;\n\tgehdr.version = version;\n\n\tdata = mnl_nlmsg_put_extra_header(nlh, sizeof(gehdr));\n\tmemcpy(data, &gehdr, sizeof(gehdr));\n\n\treturn nlh;\n}\n\nvoid ynl_msg_start_req(struct ynl_sock *ys, __u32 id)\n{\n\tynl_msg_start(ys, id, NLM_F_REQUEST | NLM_F_ACK);\n}\n\nvoid ynl_msg_start_dump(struct ynl_sock *ys, __u32 id)\n{\n\tynl_msg_start(ys, id, NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP);\n}\n\nstruct nlmsghdr *\nynl_gemsg_start_req(struct ynl_sock *ys, __u32 id, __u8 cmd, __u8 version)\n{\n\treturn ynl_gemsg_start(ys, id, NLM_F_REQUEST | NLM_F_ACK, cmd, version);\n}\n\nstruct nlmsghdr *\nynl_gemsg_start_dump(struct ynl_sock *ys, __u32 id, __u8 cmd, __u8 version)\n{\n\treturn ynl_gemsg_start(ys, id, NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP,\n\t\t\t       cmd, version);\n}\n\nint ynl_recv_ack(struct ynl_sock *ys, int ret)\n{\n\tif (!ret) {\n\t\tyerr(ys, YNL_ERROR_EXPECT_ACK,\n\t\t     \"Expecting an ACK but nothing received\");\n\t\treturn -1;\n\t}\n\n\tret = mnl_socket_recvfrom(ys->sock, ys->rx_buf, MNL_SOCKET_BUFFER_SIZE);\n\tif (ret < 0) {\n\t\tperr(ys, \"Socket receive failed\");\n\t\treturn ret;\n\t}\n\treturn mnl_cb_run(ys->rx_buf, ret, ys->seq, ys->portid,\n\t\t\t  ynl_cb_null, ys);\n}\n\nint ynl_cb_null(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\n\tyerr(yarg->ys, YNL_ERROR_UNEXPECT_MSG,\n\t     \"Received a message when none were expected\");\n\n\treturn MNL_CB_ERROR;\n}\n\n \nstatic int\nynl_get_family_info_mcast(struct ynl_sock *ys, const struct nlattr *mcasts)\n{\n\tconst struct nlattr *entry, *attr;\n\tunsigned int i;\n\n\tmnl_attr_for_each_nested(attr, mcasts)\n\t\tys->n_mcast_groups++;\n\n\tif (!ys->n_mcast_groups)\n\t\treturn 0;\n\n\tys->mcast_groups = calloc(ys->n_mcast_groups,\n\t\t\t\t  sizeof(*ys->mcast_groups));\n\tif (!ys->mcast_groups)\n\t\treturn MNL_CB_ERROR;\n\n\ti = 0;\n\tmnl_attr_for_each_nested(entry, mcasts) {\n\t\tmnl_attr_for_each_nested(attr, entry) {\n\t\t\tif (mnl_attr_get_type(attr) == CTRL_ATTR_MCAST_GRP_ID)\n\t\t\t\tys->mcast_groups[i].id = mnl_attr_get_u32(attr);\n\t\t\tif (mnl_attr_get_type(attr) == CTRL_ATTR_MCAST_GRP_NAME) {\n\t\t\t\tstrncpy(ys->mcast_groups[i].name,\n\t\t\t\t\tmnl_attr_get_str(attr),\n\t\t\t\t\tGENL_NAMSIZ - 1);\n\t\t\t\tys->mcast_groups[i].name[GENL_NAMSIZ - 1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ynl_get_family_info_cb(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct ynl_sock *ys = yarg->ys;\n\tconst struct nlattr *attr;\n\tbool found_id = true;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tif (mnl_attr_get_type(attr) == CTRL_ATTR_MCAST_GROUPS)\n\t\t\tif (ynl_get_family_info_mcast(ys, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\tif (mnl_attr_get_type(attr) != CTRL_ATTR_FAMILY_ID)\n\t\t\tcontinue;\n\n\t\tif (mnl_attr_get_payload_len(attr) != sizeof(__u16)) {\n\t\t\tyerr(ys, YNL_ERROR_ATTR_INVALID, \"Invalid family ID\");\n\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\n\t\tys->family_id = mnl_attr_get_u16(attr);\n\t\tfound_id = true;\n\t}\n\n\tif (!found_id) {\n\t\tyerr(ys, YNL_ERROR_ATTR_MISSING, \"Family ID missing\");\n\t\treturn MNL_CB_ERROR;\n\t}\n\treturn MNL_CB_OK;\n}\n\nstatic int ynl_sock_read_family(struct ynl_sock *ys, const char *family_name)\n{\n\tstruct ynl_parse_arg yarg = { .ys = ys, };\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, GENL_ID_CTRL, CTRL_CMD_GETFAMILY, 1);\n\tmnl_attr_put_strz(nlh, CTRL_ATTR_FAMILY_NAME, family_name);\n\n\terr = mnl_socket_sendto(ys->sock, nlh, nlh->nlmsg_len);\n\tif (err < 0) {\n\t\tperr(ys, \"failed to request socket family info\");\n\t\treturn err;\n\t}\n\n\terr = mnl_socket_recvfrom(ys->sock, ys->rx_buf, MNL_SOCKET_BUFFER_SIZE);\n\tif (err <= 0) {\n\t\tperr(ys, \"failed to receive the socket family info\");\n\t\treturn err;\n\t}\n\terr = mnl_cb_run2(ys->rx_buf, err, ys->seq, ys->portid,\n\t\t\t  ynl_get_family_info_cb, &yarg,\n\t\t\t  ynl_cb_array, ARRAY_SIZE(ynl_cb_array));\n\tif (err < 0) {\n\t\tfree(ys->mcast_groups);\n\t\tperr(ys, \"failed to receive the socket family info - no such family?\");\n\t\treturn err;\n\t}\n\n\treturn ynl_recv_ack(ys, err);\n}\n\nstruct ynl_sock *\nynl_sock_create(const struct ynl_family *yf, struct ynl_error *yse)\n{\n\tstruct ynl_sock *ys;\n\tint one = 1;\n\n\tys = malloc(sizeof(*ys) + 2 * MNL_SOCKET_BUFFER_SIZE);\n\tif (!ys)\n\t\treturn NULL;\n\tmemset(ys, 0, sizeof(*ys));\n\n\tys->family = yf;\n\tys->tx_buf = &ys->raw_buf[0];\n\tys->rx_buf = &ys->raw_buf[MNL_SOCKET_BUFFER_SIZE];\n\tys->ntf_last_next = &ys->ntf_first;\n\n\tys->sock = mnl_socket_open(NETLINK_GENERIC);\n\tif (!ys->sock) {\n\t\t__perr(yse, \"failed to create a netlink socket\");\n\t\tgoto err_free_sock;\n\t}\n\n\tif (mnl_socket_setsockopt(ys->sock, NETLINK_CAP_ACK,\n\t\t\t\t  &one, sizeof(one))) {\n\t\t__perr(yse, \"failed to enable netlink ACK\");\n\t\tgoto err_close_sock;\n\t}\n\tif (mnl_socket_setsockopt(ys->sock, NETLINK_EXT_ACK,\n\t\t\t\t  &one, sizeof(one))) {\n\t\t__perr(yse, \"failed to enable netlink ext ACK\");\n\t\tgoto err_close_sock;\n\t}\n\n\tys->seq = random();\n\tys->portid = mnl_socket_get_portid(ys->sock);\n\n\tif (ynl_sock_read_family(ys, yf->name)) {\n\t\tif (yse)\n\t\t\tmemcpy(yse, &ys->err, sizeof(*yse));\n\t\tgoto err_close_sock;\n\t}\n\n\treturn ys;\n\nerr_close_sock:\n\tmnl_socket_close(ys->sock);\nerr_free_sock:\n\tfree(ys);\n\treturn NULL;\n}\n\nvoid ynl_sock_destroy(struct ynl_sock *ys)\n{\n\tstruct ynl_ntf_base_type *ntf;\n\n\tmnl_socket_close(ys->sock);\n\twhile ((ntf = ynl_ntf_dequeue(ys)))\n\t\tynl_ntf_free(ntf);\n\tfree(ys->mcast_groups);\n\tfree(ys);\n}\n\n \n\nvoid ynl_ntf_free(struct ynl_ntf_base_type *ntf)\n{\n\tntf->free(ntf);\n}\n\nint ynl_subscribe(struct ynl_sock *ys, const char *grp_name)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < ys->n_mcast_groups; i++)\n\t\tif (!strcmp(ys->mcast_groups[i].name, grp_name))\n\t\t\tbreak;\n\tif (i == ys->n_mcast_groups) {\n\t\tyerr(ys, ENOENT, \"Multicast group '%s' not found\", grp_name);\n\t\treturn -1;\n\t}\n\n\terr = mnl_socket_setsockopt(ys->sock, NETLINK_ADD_MEMBERSHIP,\n\t\t\t\t    &ys->mcast_groups[i].id,\n\t\t\t\t    sizeof(ys->mcast_groups[i].id));\n\tif (err < 0) {\n\t\tperr(ys, \"Subscribing to multicast group failed\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint ynl_socket_get_fd(struct ynl_sock *ys)\n{\n\treturn mnl_socket_get_fd(ys->sock);\n}\n\nstruct ynl_ntf_base_type *ynl_ntf_dequeue(struct ynl_sock *ys)\n{\n\tstruct ynl_ntf_base_type *ntf;\n\n\tif (!ynl_has_ntf(ys))\n\t\treturn NULL;\n\n\tntf = ys->ntf_first;\n\tys->ntf_first = ntf->next;\n\tif (ys->ntf_last_next == &ntf->next)\n\t\tys->ntf_last_next = &ys->ntf_first;\n\n\treturn ntf;\n}\n\nstatic int ynl_ntf_parse(struct ynl_sock *ys, const struct nlmsghdr *nlh)\n{\n\tstruct ynl_parse_arg yarg = { .ys = ys, };\n\tconst struct ynl_ntf_info *info;\n\tstruct ynl_ntf_base_type *rsp;\n\tstruct genlmsghdr *gehdr;\n\tint ret;\n\n\tgehdr = mnl_nlmsg_get_payload(nlh);\n\tif (gehdr->cmd >= ys->family->ntf_info_size)\n\t\treturn MNL_CB_ERROR;\n\tinfo = &ys->family->ntf_info[gehdr->cmd];\n\tif (!info->cb)\n\t\treturn MNL_CB_ERROR;\n\n\trsp = calloc(1, info->alloc_sz);\n\trsp->free = info->free;\n\tyarg.data = rsp->data;\n\tyarg.rsp_policy = info->policy;\n\n\tret = info->cb(nlh, &yarg);\n\tif (ret <= MNL_CB_STOP)\n\t\tgoto err_free;\n\n\trsp->family = nlh->nlmsg_type;\n\trsp->cmd = gehdr->cmd;\n\n\t*ys->ntf_last_next = rsp;\n\tys->ntf_last_next = &rsp->next;\n\n\treturn MNL_CB_OK;\n\nerr_free:\n\tinfo->free(rsp);\n\treturn MNL_CB_ERROR;\n}\n\nstatic int ynl_ntf_trampoline(const struct nlmsghdr *nlh, void *data)\n{\n\treturn ynl_ntf_parse((struct ynl_sock *)data, nlh);\n}\n\nint ynl_ntf_check(struct ynl_sock *ys)\n{\n\tssize_t len;\n\tint err;\n\n\tdo {\n\t\t \n\t\tstruct pollfd pfd = { };\n\n\t\tpfd.fd = mnl_socket_get_fd(ys->sock);\n\t\tpfd.events = POLLIN;\n\t\terr = poll(&pfd, 1, 1);\n\t\tif (err < 1)\n\t\t\treturn err;\n\n\t\tlen = mnl_socket_recvfrom(ys->sock, ys->rx_buf,\n\t\t\t\t\t  MNL_SOCKET_BUFFER_SIZE);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\terr = mnl_cb_run2(ys->rx_buf, len, ys->seq, ys->portid,\n\t\t\t\t  ynl_ntf_trampoline, ys,\n\t\t\t\t  ynl_cb_array, NLMSG_MIN_TYPE);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} while (err > 0);\n\n\treturn 0;\n}\n\n \n\nstruct ynl_dump_list_type *YNL_LIST_END = (void *)(0xb4d123);\n\nvoid ynl_error_unknown_notification(struct ynl_sock *ys, __u8 cmd)\n{\n\tyerr(ys, YNL_ERROR_UNKNOWN_NTF,\n\t     \"Unknown notification message type '%d'\", cmd);\n}\n\nint ynl_error_parse(struct ynl_parse_arg *yarg, const char *msg)\n{\n\tyerr(yarg->ys, YNL_ERROR_INV_RESP, \"Error parsing response: %s\", msg);\n\treturn MNL_CB_ERROR;\n}\n\nstatic int\nynl_check_alien(struct ynl_sock *ys, const struct nlmsghdr *nlh, __u32 rsp_cmd)\n{\n\tstruct genlmsghdr *gehdr;\n\n\tif (mnl_nlmsg_get_payload_len(nlh) < sizeof(*gehdr)) {\n\t\tyerr(ys, YNL_ERROR_INV_RESP,\n\t\t     \"Kernel responded with truncated message\");\n\t\treturn -1;\n\t}\n\n\tgehdr = mnl_nlmsg_get_payload(nlh);\n\tif (gehdr->cmd != rsp_cmd)\n\t\treturn ynl_ntf_parse(ys, nlh);\n\n\treturn 0;\n}\n\nstatic int ynl_req_trampoline(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_req_state *yrs = data;\n\tint ret;\n\n\tret = ynl_check_alien(yrs->yarg.ys, nlh, yrs->rsp_cmd);\n\tif (ret)\n\t\treturn ret < 0 ? MNL_CB_ERROR : MNL_CB_OK;\n\n\treturn yrs->cb(nlh, &yrs->yarg);\n}\n\nint ynl_exec(struct ynl_sock *ys, struct nlmsghdr *req_nlh,\n\t     struct ynl_req_state *yrs)\n{\n\tssize_t len;\n\tint err;\n\n\terr = mnl_socket_sendto(ys->sock, req_nlh, req_nlh->nlmsg_len);\n\tif (err < 0)\n\t\treturn err;\n\n\tdo {\n\t\tlen = mnl_socket_recvfrom(ys->sock, ys->rx_buf,\n\t\t\t\t\t  MNL_SOCKET_BUFFER_SIZE);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\terr = mnl_cb_run2(ys->rx_buf, len, ys->seq, ys->portid,\n\t\t\t\t  ynl_req_trampoline, yrs,\n\t\t\t\t  ynl_cb_array, NLMSG_MIN_TYPE);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} while (err > 0);\n\n\treturn 0;\n}\n\nstatic int ynl_dump_trampoline(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_dump_state *ds = data;\n\tstruct ynl_dump_list_type *obj;\n\tstruct ynl_parse_arg yarg = {};\n\tint ret;\n\n\tret = ynl_check_alien(ds->ys, nlh, ds->rsp_cmd);\n\tif (ret)\n\t\treturn ret < 0 ? MNL_CB_ERROR : MNL_CB_OK;\n\n\tobj = calloc(1, ds->alloc_sz);\n\tif (!obj)\n\t\treturn MNL_CB_ERROR;\n\n\tif (!ds->first)\n\t\tds->first = obj;\n\tif (ds->last)\n\t\tds->last->next = obj;\n\tds->last = obj;\n\n\tyarg.ys = ds->ys;\n\tyarg.rsp_policy = ds->rsp_policy;\n\tyarg.data = &obj->data;\n\n\treturn ds->cb(nlh, &yarg);\n}\n\nstatic void *ynl_dump_end(struct ynl_dump_state *ds)\n{\n\tif (!ds->first)\n\t\treturn YNL_LIST_END;\n\n\tds->last->next = YNL_LIST_END;\n\treturn ds->first;\n}\n\nint ynl_exec_dump(struct ynl_sock *ys, struct nlmsghdr *req_nlh,\n\t\t  struct ynl_dump_state *yds)\n{\n\tssize_t len;\n\tint err;\n\n\terr = mnl_socket_sendto(ys->sock, req_nlh, req_nlh->nlmsg_len);\n\tif (err < 0)\n\t\treturn err;\n\n\tdo {\n\t\tlen = mnl_socket_recvfrom(ys->sock, ys->rx_buf,\n\t\t\t\t\t  MNL_SOCKET_BUFFER_SIZE);\n\t\tif (len < 0)\n\t\t\tgoto err_close_list;\n\n\t\terr = mnl_cb_run2(ys->rx_buf, len, ys->seq, ys->portid,\n\t\t\t\t  ynl_dump_trampoline, yds,\n\t\t\t\t  ynl_cb_array, NLMSG_MIN_TYPE);\n\t\tif (err < 0)\n\t\t\tgoto err_close_list;\n\t} while (err > 0);\n\n\tyds->first = ynl_dump_end(yds);\n\treturn 0;\n\nerr_close_list:\n\tyds->first = ynl_dump_end(yds);\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}