{
  "module_name": "ethtool-user.c",
  "hash_id": "a66fee1c2c60db4f81e5ebc5794e3fe69f3d5aeaceb3d35af986b7917143e6fc",
  "original_prompt": "Ingested from linux-6.6.14/tools/net/ynl/generated/ethtool-user.c",
  "human_readable_source": "\n \n \n \n \n\n#include <stdlib.h>\n#include <string.h>\n#include \"ethtool-user.h\"\n#include \"ynl.h\"\n#include <linux/ethtool.h>\n\n#include <libmnl/libmnl.h>\n#include <linux/genetlink.h>\n\n#include \"linux/ethtool_netlink.h\"\n\n \nstatic const char * const ethtool_op_strmap[] = {\n\t[ETHTOOL_MSG_STRSET_GET] = \"strset-get\",\n\t[ETHTOOL_MSG_LINKINFO_GET] = \"linkinfo-get\",\n\t[3] = \"linkinfo-ntf\",\n\t[ETHTOOL_MSG_LINKMODES_GET] = \"linkmodes-get\",\n\t[5] = \"linkmodes-ntf\",\n\t[ETHTOOL_MSG_LINKSTATE_GET] = \"linkstate-get\",\n\t[ETHTOOL_MSG_DEBUG_GET] = \"debug-get\",\n\t[8] = \"debug-ntf\",\n\t[ETHTOOL_MSG_WOL_GET] = \"wol-get\",\n\t[10] = \"wol-ntf\",\n\t[ETHTOOL_MSG_FEATURES_GET] = \"features-get\",\n\t[ETHTOOL_MSG_FEATURES_SET] = \"features-set\",\n\t[13] = \"features-ntf\",\n\t[14] = \"privflags-get\",\n\t[15] = \"privflags-ntf\",\n\t[16] = \"rings-get\",\n\t[17] = \"rings-ntf\",\n\t[18] = \"channels-get\",\n\t[19] = \"channels-ntf\",\n\t[20] = \"coalesce-get\",\n\t[21] = \"coalesce-ntf\",\n\t[22] = \"pause-get\",\n\t[23] = \"pause-ntf\",\n\t[24] = \"eee-get\",\n\t[25] = \"eee-ntf\",\n\t[26] = \"tsinfo-get\",\n\t[27] = \"cable-test-ntf\",\n\t[28] = \"cable-test-tdr-ntf\",\n\t[29] = \"tunnel-info-get\",\n\t[30] = \"fec-get\",\n\t[31] = \"fec-ntf\",\n\t[32] = \"module-eeprom-get\",\n\t[34] = \"phc-vclocks-get\",\n\t[35] = \"module-get\",\n\t[36] = \"module-ntf\",\n\t[37] = \"pse-get\",\n\t[ETHTOOL_MSG_RSS_GET] = \"rss-get\",\n\t[ETHTOOL_MSG_PLCA_GET_CFG] = \"plca-get-cfg\",\n\t[40] = \"plca-get-status\",\n\t[41] = \"plca-ntf\",\n\t[ETHTOOL_MSG_MM_GET] = \"mm-get\",\n\t[43] = \"mm-ntf\",\n};\n\nconst char *ethtool_op_str(int op)\n{\n\tif (op < 0 || op >= (int)MNL_ARRAY_SIZE(ethtool_op_strmap))\n\t\treturn NULL;\n\treturn ethtool_op_strmap[op];\n}\n\nstatic const char * const ethtool_udp_tunnel_type_strmap[] = {\n\t[0] = \"vxlan\",\n\t[1] = \"geneve\",\n\t[2] = \"vxlan-gpe\",\n};\n\nconst char *ethtool_udp_tunnel_type_str(int value)\n{\n\tif (value < 0 || value >= (int)MNL_ARRAY_SIZE(ethtool_udp_tunnel_type_strmap))\n\t\treturn NULL;\n\treturn ethtool_udp_tunnel_type_strmap[value];\n}\n\nstatic const char * const ethtool_stringset_strmap[] = {\n};\n\nconst char *ethtool_stringset_str(enum ethtool_stringset value)\n{\n\tif (value < 0 || value >= (int)MNL_ARRAY_SIZE(ethtool_stringset_strmap))\n\t\treturn NULL;\n\treturn ethtool_stringset_strmap[value];\n}\n\n \nstruct ynl_policy_attr ethtool_header_policy[ETHTOOL_A_HEADER_MAX + 1] = {\n\t[ETHTOOL_A_HEADER_DEV_INDEX] = { .name = \"dev-index\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_HEADER_DEV_NAME] = { .name = \"dev-name\", .type = YNL_PT_NUL_STR, },\n\t[ETHTOOL_A_HEADER_FLAGS] = { .name = \"flags\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_header_nest = {\n\t.max_attr = ETHTOOL_A_HEADER_MAX,\n\t.table = ethtool_header_policy,\n};\n\nstruct ynl_policy_attr ethtool_pause_stat_policy[ETHTOOL_A_PAUSE_STAT_MAX + 1] = {\n\t[ETHTOOL_A_PAUSE_STAT_PAD] = { .name = \"pad\", .type = YNL_PT_IGNORE, },\n\t[ETHTOOL_A_PAUSE_STAT_TX_FRAMES] = { .name = \"tx-frames\", .type = YNL_PT_U64, },\n\t[ETHTOOL_A_PAUSE_STAT_RX_FRAMES] = { .name = \"rx-frames\", .type = YNL_PT_U64, },\n};\n\nstruct ynl_policy_nest ethtool_pause_stat_nest = {\n\t.max_attr = ETHTOOL_A_PAUSE_STAT_MAX,\n\t.table = ethtool_pause_stat_policy,\n};\n\nstruct ynl_policy_attr ethtool_cable_test_tdr_cfg_policy[ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX + 1] = {\n\t[ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST] = { .name = \"first\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST] = { .name = \"last\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP] = { .name = \"step\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR] = { .name = \"pair\", .type = YNL_PT_U8, },\n};\n\nstruct ynl_policy_nest ethtool_cable_test_tdr_cfg_nest = {\n\t.max_attr = ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX,\n\t.table = ethtool_cable_test_tdr_cfg_policy,\n};\n\nstruct ynl_policy_attr ethtool_fec_stat_policy[ETHTOOL_A_FEC_STAT_MAX + 1] = {\n\t[ETHTOOL_A_FEC_STAT_PAD] = { .name = \"pad\", .type = YNL_PT_IGNORE, },\n\t[ETHTOOL_A_FEC_STAT_CORRECTED] = { .name = \"corrected\", .type = YNL_PT_BINARY,},\n\t[ETHTOOL_A_FEC_STAT_UNCORR] = { .name = \"uncorr\", .type = YNL_PT_BINARY,},\n\t[ETHTOOL_A_FEC_STAT_CORR_BITS] = { .name = \"corr-bits\", .type = YNL_PT_BINARY,},\n};\n\nstruct ynl_policy_nest ethtool_fec_stat_nest = {\n\t.max_attr = ETHTOOL_A_FEC_STAT_MAX,\n\t.table = ethtool_fec_stat_policy,\n};\n\nstruct ynl_policy_attr ethtool_mm_stat_policy[ETHTOOL_A_MM_STAT_MAX + 1] = {\n\t[ETHTOOL_A_MM_STAT_PAD] = { .name = \"pad\", .type = YNL_PT_IGNORE, },\n\t[ETHTOOL_A_MM_STAT_REASSEMBLY_ERRORS] = { .name = \"reassembly-errors\", .type = YNL_PT_U64, },\n\t[ETHTOOL_A_MM_STAT_SMD_ERRORS] = { .name = \"smd-errors\", .type = YNL_PT_U64, },\n\t[ETHTOOL_A_MM_STAT_REASSEMBLY_OK] = { .name = \"reassembly-ok\", .type = YNL_PT_U64, },\n\t[ETHTOOL_A_MM_STAT_RX_FRAG_COUNT] = { .name = \"rx-frag-count\", .type = YNL_PT_U64, },\n\t[ETHTOOL_A_MM_STAT_TX_FRAG_COUNT] = { .name = \"tx-frag-count\", .type = YNL_PT_U64, },\n\t[ETHTOOL_A_MM_STAT_HOLD_COUNT] = { .name = \"hold-count\", .type = YNL_PT_U64, },\n};\n\nstruct ynl_policy_nest ethtool_mm_stat_nest = {\n\t.max_attr = ETHTOOL_A_MM_STAT_MAX,\n\t.table = ethtool_mm_stat_policy,\n};\n\nstruct ynl_policy_attr ethtool_cable_result_policy[ETHTOOL_A_CABLE_RESULT_MAX + 1] = {\n\t[ETHTOOL_A_CABLE_RESULT_PAIR] = { .name = \"pair\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_CABLE_RESULT_CODE] = { .name = \"code\", .type = YNL_PT_U8, },\n};\n\nstruct ynl_policy_nest ethtool_cable_result_nest = {\n\t.max_attr = ETHTOOL_A_CABLE_RESULT_MAX,\n\t.table = ethtool_cable_result_policy,\n};\n\nstruct ynl_policy_attr ethtool_cable_fault_length_policy[ETHTOOL_A_CABLE_FAULT_LENGTH_MAX + 1] = {\n\t[ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR] = { .name = \"pair\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_CABLE_FAULT_LENGTH_CM] = { .name = \"cm\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_cable_fault_length_nest = {\n\t.max_attr = ETHTOOL_A_CABLE_FAULT_LENGTH_MAX,\n\t.table = ethtool_cable_fault_length_policy,\n};\n\nstruct ynl_policy_attr ethtool_bitset_bit_policy[ETHTOOL_A_BITSET_BIT_MAX + 1] = {\n\t[ETHTOOL_A_BITSET_BIT_INDEX] = { .name = \"index\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_BITSET_BIT_NAME] = { .name = \"name\", .type = YNL_PT_NUL_STR, },\n\t[ETHTOOL_A_BITSET_BIT_VALUE] = { .name = \"value\", .type = YNL_PT_FLAG, },\n};\n\nstruct ynl_policy_nest ethtool_bitset_bit_nest = {\n\t.max_attr = ETHTOOL_A_BITSET_BIT_MAX,\n\t.table = ethtool_bitset_bit_policy,\n};\n\nstruct ynl_policy_attr ethtool_tunnel_udp_entry_policy[ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX + 1] = {\n\t[ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT] = { .name = \"port\", .type = YNL_PT_U16, },\n\t[ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE] = { .name = \"type\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_tunnel_udp_entry_nest = {\n\t.max_attr = ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX,\n\t.table = ethtool_tunnel_udp_entry_policy,\n};\n\nstruct ynl_policy_attr ethtool_string_policy[ETHTOOL_A_STRING_MAX + 1] = {\n\t[ETHTOOL_A_STRING_INDEX] = { .name = \"index\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_STRING_VALUE] = { .name = \"value\", .type = YNL_PT_NUL_STR, },\n};\n\nstruct ynl_policy_nest ethtool_string_nest = {\n\t.max_attr = ETHTOOL_A_STRING_MAX,\n\t.table = ethtool_string_policy,\n};\n\nstruct ynl_policy_attr ethtool_cable_nest_policy[ETHTOOL_A_CABLE_NEST_MAX + 1] = {\n\t[ETHTOOL_A_CABLE_NEST_RESULT] = { .name = \"result\", .type = YNL_PT_NEST, .nest = &ethtool_cable_result_nest, },\n\t[ETHTOOL_A_CABLE_NEST_FAULT_LENGTH] = { .name = \"fault-length\", .type = YNL_PT_NEST, .nest = &ethtool_cable_fault_length_nest, },\n};\n\nstruct ynl_policy_nest ethtool_cable_nest_nest = {\n\t.max_attr = ETHTOOL_A_CABLE_NEST_MAX,\n\t.table = ethtool_cable_nest_policy,\n};\n\nstruct ynl_policy_attr ethtool_bitset_bits_policy[ETHTOOL_A_BITSET_BITS_MAX + 1] = {\n\t[ETHTOOL_A_BITSET_BITS_BIT] = { .name = \"bit\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_bit_nest, },\n};\n\nstruct ynl_policy_nest ethtool_bitset_bits_nest = {\n\t.max_attr = ETHTOOL_A_BITSET_BITS_MAX,\n\t.table = ethtool_bitset_bits_policy,\n};\n\nstruct ynl_policy_attr ethtool_strings_policy[ETHTOOL_A_STRINGS_MAX + 1] = {\n\t[ETHTOOL_A_STRINGS_STRING] = { .name = \"string\", .type = YNL_PT_NEST, .nest = &ethtool_string_nest, },\n};\n\nstruct ynl_policy_nest ethtool_strings_nest = {\n\t.max_attr = ETHTOOL_A_STRINGS_MAX,\n\t.table = ethtool_strings_policy,\n};\n\nstruct ynl_policy_attr ethtool_bitset_policy[ETHTOOL_A_BITSET_MAX + 1] = {\n\t[ETHTOOL_A_BITSET_NOMASK] = { .name = \"nomask\", .type = YNL_PT_FLAG, },\n\t[ETHTOOL_A_BITSET_SIZE] = { .name = \"size\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_BITSET_BITS] = { .name = \"bits\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_bits_nest, },\n};\n\nstruct ynl_policy_nest ethtool_bitset_nest = {\n\t.max_attr = ETHTOOL_A_BITSET_MAX,\n\t.table = ethtool_bitset_policy,\n};\n\nstruct ynl_policy_attr ethtool_stringset_policy[ETHTOOL_A_STRINGSET_MAX + 1] = {\n\t[ETHTOOL_A_STRINGSET_ID] = { .name = \"id\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_STRINGSET_COUNT] = { .name = \"count\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_STRINGSET_STRINGS] = { .name = \"strings\", .type = YNL_PT_NEST, .nest = &ethtool_strings_nest, },\n};\n\nstruct ynl_policy_nest ethtool_stringset_nest = {\n\t.max_attr = ETHTOOL_A_STRINGSET_MAX,\n\t.table = ethtool_stringset_policy,\n};\n\nstruct ynl_policy_attr ethtool_tunnel_udp_table_policy[ETHTOOL_A_TUNNEL_UDP_TABLE_MAX + 1] = {\n\t[ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE] = { .name = \"size\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES] = { .name = \"types\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY] = { .name = \"entry\", .type = YNL_PT_NEST, .nest = &ethtool_tunnel_udp_entry_nest, },\n};\n\nstruct ynl_policy_nest ethtool_tunnel_udp_table_nest = {\n\t.max_attr = ETHTOOL_A_TUNNEL_UDP_TABLE_MAX,\n\t.table = ethtool_tunnel_udp_table_policy,\n};\n\nstruct ynl_policy_attr ethtool_stringsets_policy[ETHTOOL_A_STRINGSETS_MAX + 1] = {\n\t[ETHTOOL_A_STRINGSETS_STRINGSET] = { .name = \"stringset\", .type = YNL_PT_NEST, .nest = &ethtool_stringset_nest, },\n};\n\nstruct ynl_policy_nest ethtool_stringsets_nest = {\n\t.max_attr = ETHTOOL_A_STRINGSETS_MAX,\n\t.table = ethtool_stringsets_policy,\n};\n\nstruct ynl_policy_attr ethtool_tunnel_udp_policy[ETHTOOL_A_TUNNEL_UDP_MAX + 1] = {\n\t[ETHTOOL_A_TUNNEL_UDP_TABLE] = { .name = \"table\", .type = YNL_PT_NEST, .nest = &ethtool_tunnel_udp_table_nest, },\n};\n\nstruct ynl_policy_nest ethtool_tunnel_udp_nest = {\n\t.max_attr = ETHTOOL_A_TUNNEL_UDP_MAX,\n\t.table = ethtool_tunnel_udp_policy,\n};\n\nstruct ynl_policy_attr ethtool_strset_policy[ETHTOOL_A_STRSET_MAX + 1] = {\n\t[ETHTOOL_A_STRSET_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_STRSET_STRINGSETS] = { .name = \"stringsets\", .type = YNL_PT_NEST, .nest = &ethtool_stringsets_nest, },\n\t[ETHTOOL_A_STRSET_COUNTS_ONLY] = { .name = \"counts-only\", .type = YNL_PT_FLAG, },\n};\n\nstruct ynl_policy_nest ethtool_strset_nest = {\n\t.max_attr = ETHTOOL_A_STRSET_MAX,\n\t.table = ethtool_strset_policy,\n};\n\nstruct ynl_policy_attr ethtool_linkinfo_policy[ETHTOOL_A_LINKINFO_MAX + 1] = {\n\t[ETHTOOL_A_LINKINFO_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_LINKINFO_PORT] = { .name = \"port\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_LINKINFO_PHYADDR] = { .name = \"phyaddr\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_LINKINFO_TP_MDIX] = { .name = \"tp-mdix\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_LINKINFO_TP_MDIX_CTRL] = { .name = \"tp-mdix-ctrl\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_LINKINFO_TRANSCEIVER] = { .name = \"transceiver\", .type = YNL_PT_U8, },\n};\n\nstruct ynl_policy_nest ethtool_linkinfo_nest = {\n\t.max_attr = ETHTOOL_A_LINKINFO_MAX,\n\t.table = ethtool_linkinfo_policy,\n};\n\nstruct ynl_policy_attr ethtool_linkmodes_policy[ETHTOOL_A_LINKMODES_MAX + 1] = {\n\t[ETHTOOL_A_LINKMODES_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_LINKMODES_AUTONEG] = { .name = \"autoneg\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_LINKMODES_OURS] = { .name = \"ours\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_LINKMODES_PEER] = { .name = \"peer\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_LINKMODES_SPEED] = { .name = \"speed\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_LINKMODES_DUPLEX] = { .name = \"duplex\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG] = { .name = \"master-slave-cfg\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE] = { .name = \"master-slave-state\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_LINKMODES_LANES] = { .name = \"lanes\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_LINKMODES_RATE_MATCHING] = { .name = \"rate-matching\", .type = YNL_PT_U8, },\n};\n\nstruct ynl_policy_nest ethtool_linkmodes_nest = {\n\t.max_attr = ETHTOOL_A_LINKMODES_MAX,\n\t.table = ethtool_linkmodes_policy,\n};\n\nstruct ynl_policy_attr ethtool_linkstate_policy[ETHTOOL_A_LINKSTATE_MAX + 1] = {\n\t[ETHTOOL_A_LINKSTATE_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_LINKSTATE_LINK] = { .name = \"link\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_LINKSTATE_SQI] = { .name = \"sqi\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_LINKSTATE_SQI_MAX] = { .name = \"sqi-max\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_LINKSTATE_EXT_STATE] = { .name = \"ext-state\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_LINKSTATE_EXT_SUBSTATE] = { .name = \"ext-substate\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_LINKSTATE_EXT_DOWN_CNT] = { .name = \"ext-down-cnt\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_linkstate_nest = {\n\t.max_attr = ETHTOOL_A_LINKSTATE_MAX,\n\t.table = ethtool_linkstate_policy,\n};\n\nstruct ynl_policy_attr ethtool_debug_policy[ETHTOOL_A_DEBUG_MAX + 1] = {\n\t[ETHTOOL_A_DEBUG_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_DEBUG_MSGMASK] = { .name = \"msgmask\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n};\n\nstruct ynl_policy_nest ethtool_debug_nest = {\n\t.max_attr = ETHTOOL_A_DEBUG_MAX,\n\t.table = ethtool_debug_policy,\n};\n\nstruct ynl_policy_attr ethtool_wol_policy[ETHTOOL_A_WOL_MAX + 1] = {\n\t[ETHTOOL_A_WOL_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_WOL_MODES] = { .name = \"modes\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_WOL_SOPASS] = { .name = \"sopass\", .type = YNL_PT_BINARY,},\n};\n\nstruct ynl_policy_nest ethtool_wol_nest = {\n\t.max_attr = ETHTOOL_A_WOL_MAX,\n\t.table = ethtool_wol_policy,\n};\n\nstruct ynl_policy_attr ethtool_features_policy[ETHTOOL_A_FEATURES_MAX + 1] = {\n\t[ETHTOOL_A_FEATURES_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_FEATURES_HW] = { .name = \"hw\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_FEATURES_WANTED] = { .name = \"wanted\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_FEATURES_ACTIVE] = { .name = \"active\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_FEATURES_NOCHANGE] = { .name = \"nochange\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n};\n\nstruct ynl_policy_nest ethtool_features_nest = {\n\t.max_attr = ETHTOOL_A_FEATURES_MAX,\n\t.table = ethtool_features_policy,\n};\n\nstruct ynl_policy_attr ethtool_privflags_policy[ETHTOOL_A_PRIVFLAGS_MAX + 1] = {\n\t[ETHTOOL_A_PRIVFLAGS_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_PRIVFLAGS_FLAGS] = { .name = \"flags\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n};\n\nstruct ynl_policy_nest ethtool_privflags_nest = {\n\t.max_attr = ETHTOOL_A_PRIVFLAGS_MAX,\n\t.table = ethtool_privflags_policy,\n};\n\nstruct ynl_policy_attr ethtool_rings_policy[ETHTOOL_A_RINGS_MAX + 1] = {\n\t[ETHTOOL_A_RINGS_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_RINGS_RX_MAX] = { .name = \"rx-max\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RINGS_RX_MINI_MAX] = { .name = \"rx-mini-max\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RINGS_RX_JUMBO_MAX] = { .name = \"rx-jumbo-max\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RINGS_TX_MAX] = { .name = \"tx-max\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RINGS_RX] = { .name = \"rx\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RINGS_RX_MINI] = { .name = \"rx-mini\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RINGS_RX_JUMBO] = { .name = \"rx-jumbo\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RINGS_TX] = { .name = \"tx\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RINGS_RX_BUF_LEN] = { .name = \"rx-buf-len\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RINGS_TCP_DATA_SPLIT] = { .name = \"tcp-data-split\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_RINGS_CQE_SIZE] = { .name = \"cqe-size\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RINGS_TX_PUSH] = { .name = \"tx-push\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_RINGS_RX_PUSH] = { .name = \"rx-push\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN] = { .name = \"tx-push-buf-len\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN_MAX] = { .name = \"tx-push-buf-len-max\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_rings_nest = {\n\t.max_attr = ETHTOOL_A_RINGS_MAX,\n\t.table = ethtool_rings_policy,\n};\n\nstruct ynl_policy_attr ethtool_channels_policy[ETHTOOL_A_CHANNELS_MAX + 1] = {\n\t[ETHTOOL_A_CHANNELS_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_CHANNELS_RX_MAX] = { .name = \"rx-max\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_CHANNELS_TX_MAX] = { .name = \"tx-max\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_CHANNELS_OTHER_MAX] = { .name = \"other-max\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_CHANNELS_COMBINED_MAX] = { .name = \"combined-max\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_CHANNELS_RX_COUNT] = { .name = \"rx-count\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_CHANNELS_TX_COUNT] = { .name = \"tx-count\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_CHANNELS_OTHER_COUNT] = { .name = \"other-count\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_CHANNELS_COMBINED_COUNT] = { .name = \"combined-count\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_channels_nest = {\n\t.max_attr = ETHTOOL_A_CHANNELS_MAX,\n\t.table = ethtool_channels_policy,\n};\n\nstruct ynl_policy_attr ethtool_coalesce_policy[ETHTOOL_A_COALESCE_MAX + 1] = {\n\t[ETHTOOL_A_COALESCE_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_COALESCE_RX_USECS] = { .name = \"rx-usecs\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_RX_MAX_FRAMES] = { .name = \"rx-max-frames\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_RX_USECS_IRQ] = { .name = \"rx-usecs-irq\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ] = { .name = \"rx-max-frames-irq\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_TX_USECS] = { .name = \"tx-usecs\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_TX_MAX_FRAMES] = { .name = \"tx-max-frames\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_TX_USECS_IRQ] = { .name = \"tx-usecs-irq\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ] = { .name = \"tx-max-frames-irq\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_STATS_BLOCK_USECS] = { .name = \"stats-block-usecs\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX] = { .name = \"use-adaptive-rx\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX] = { .name = \"use-adaptive-tx\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_COALESCE_PKT_RATE_LOW] = { .name = \"pkt-rate-low\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_RX_USECS_LOW] = { .name = \"rx-usecs-low\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW] = { .name = \"rx-max-frames-low\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_TX_USECS_LOW] = { .name = \"tx-usecs-low\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW] = { .name = \"tx-max-frames-low\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_PKT_RATE_HIGH] = { .name = \"pkt-rate-high\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_RX_USECS_HIGH] = { .name = \"rx-usecs-high\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH] = { .name = \"rx-max-frames-high\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_TX_USECS_HIGH] = { .name = \"tx-usecs-high\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH] = { .name = \"tx-max-frames-high\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL] = { .name = \"rate-sample-interval\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_USE_CQE_MODE_TX] = { .name = \"use-cqe-mode-tx\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_COALESCE_USE_CQE_MODE_RX] = { .name = \"use-cqe-mode-rx\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_COALESCE_TX_AGGR_MAX_BYTES] = { .name = \"tx-aggr-max-bytes\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_TX_AGGR_MAX_FRAMES] = { .name = \"tx-aggr-max-frames\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_COALESCE_TX_AGGR_TIME_USECS] = { .name = \"tx-aggr-time-usecs\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_coalesce_nest = {\n\t.max_attr = ETHTOOL_A_COALESCE_MAX,\n\t.table = ethtool_coalesce_policy,\n};\n\nstruct ynl_policy_attr ethtool_pause_policy[ETHTOOL_A_PAUSE_MAX + 1] = {\n\t[ETHTOOL_A_PAUSE_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_PAUSE_AUTONEG] = { .name = \"autoneg\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_PAUSE_RX] = { .name = \"rx\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_PAUSE_TX] = { .name = \"tx\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_PAUSE_STATS] = { .name = \"stats\", .type = YNL_PT_NEST, .nest = &ethtool_pause_stat_nest, },\n\t[ETHTOOL_A_PAUSE_STATS_SRC] = { .name = \"stats-src\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_pause_nest = {\n\t.max_attr = ETHTOOL_A_PAUSE_MAX,\n\t.table = ethtool_pause_policy,\n};\n\nstruct ynl_policy_attr ethtool_eee_policy[ETHTOOL_A_EEE_MAX + 1] = {\n\t[ETHTOOL_A_EEE_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_EEE_MODES_OURS] = { .name = \"modes-ours\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_EEE_MODES_PEER] = { .name = \"modes-peer\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_EEE_ACTIVE] = { .name = \"active\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_EEE_ENABLED] = { .name = \"enabled\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_EEE_TX_LPI_ENABLED] = { .name = \"tx-lpi-enabled\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_EEE_TX_LPI_TIMER] = { .name = \"tx-lpi-timer\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_eee_nest = {\n\t.max_attr = ETHTOOL_A_EEE_MAX,\n\t.table = ethtool_eee_policy,\n};\n\nstruct ynl_policy_attr ethtool_tsinfo_policy[ETHTOOL_A_TSINFO_MAX + 1] = {\n\t[ETHTOOL_A_TSINFO_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_TSINFO_TIMESTAMPING] = { .name = \"timestamping\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_TSINFO_TX_TYPES] = { .name = \"tx-types\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_TSINFO_RX_FILTERS] = { .name = \"rx-filters\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_TSINFO_PHC_INDEX] = { .name = \"phc-index\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_tsinfo_nest = {\n\t.max_attr = ETHTOOL_A_TSINFO_MAX,\n\t.table = ethtool_tsinfo_policy,\n};\n\nstruct ynl_policy_attr ethtool_cable_test_policy[ETHTOOL_A_CABLE_TEST_MAX + 1] = {\n\t[ETHTOOL_A_CABLE_TEST_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n};\n\nstruct ynl_policy_nest ethtool_cable_test_nest = {\n\t.max_attr = ETHTOOL_A_CABLE_TEST_MAX,\n\t.table = ethtool_cable_test_policy,\n};\n\nstruct ynl_policy_attr ethtool_cable_test_ntf_policy[ETHTOOL_A_CABLE_TEST_NTF_MAX + 1] = {\n\t[ETHTOOL_A_CABLE_TEST_NTF_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_CABLE_TEST_NTF_STATUS] = { .name = \"status\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_CABLE_TEST_NTF_NEST] = { .name = \"nest\", .type = YNL_PT_NEST, .nest = &ethtool_cable_nest_nest, },\n};\n\nstruct ynl_policy_nest ethtool_cable_test_ntf_nest = {\n\t.max_attr = ETHTOOL_A_CABLE_TEST_NTF_MAX,\n\t.table = ethtool_cable_test_ntf_policy,\n};\n\nstruct ynl_policy_attr ethtool_cable_test_tdr_policy[ETHTOOL_A_CABLE_TEST_TDR_MAX + 1] = {\n\t[ETHTOOL_A_CABLE_TEST_TDR_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_CABLE_TEST_TDR_CFG] = { .name = \"cfg\", .type = YNL_PT_NEST, .nest = &ethtool_cable_test_tdr_cfg_nest, },\n};\n\nstruct ynl_policy_nest ethtool_cable_test_tdr_nest = {\n\t.max_attr = ETHTOOL_A_CABLE_TEST_TDR_MAX,\n\t.table = ethtool_cable_test_tdr_policy,\n};\n\nstruct ynl_policy_attr ethtool_cable_test_tdr_ntf_policy[ETHTOOL_A_CABLE_TEST_TDR_NTF_MAX + 1] = {\n\t[ETHTOOL_A_CABLE_TEST_TDR_NTF_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_CABLE_TEST_TDR_NTF_STATUS] = { .name = \"status\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_CABLE_TEST_TDR_NTF_NEST] = { .name = \"nest\", .type = YNL_PT_NEST, .nest = &ethtool_cable_nest_nest, },\n};\n\nstruct ynl_policy_nest ethtool_cable_test_tdr_ntf_nest = {\n\t.max_attr = ETHTOOL_A_CABLE_TEST_TDR_NTF_MAX,\n\t.table = ethtool_cable_test_tdr_ntf_policy,\n};\n\nstruct ynl_policy_attr ethtool_tunnel_info_policy[ETHTOOL_A_TUNNEL_INFO_MAX + 1] = {\n\t[ETHTOOL_A_TUNNEL_INFO_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_TUNNEL_INFO_UDP_PORTS] = { .name = \"udp-ports\", .type = YNL_PT_NEST, .nest = &ethtool_tunnel_udp_nest, },\n};\n\nstruct ynl_policy_nest ethtool_tunnel_info_nest = {\n\t.max_attr = ETHTOOL_A_TUNNEL_INFO_MAX,\n\t.table = ethtool_tunnel_info_policy,\n};\n\nstruct ynl_policy_attr ethtool_fec_policy[ETHTOOL_A_FEC_MAX + 1] = {\n\t[ETHTOOL_A_FEC_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_FEC_MODES] = { .name = \"modes\", .type = YNL_PT_NEST, .nest = &ethtool_bitset_nest, },\n\t[ETHTOOL_A_FEC_AUTO] = { .name = \"auto\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_FEC_ACTIVE] = { .name = \"active\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_FEC_STATS] = { .name = \"stats\", .type = YNL_PT_NEST, .nest = &ethtool_fec_stat_nest, },\n};\n\nstruct ynl_policy_nest ethtool_fec_nest = {\n\t.max_attr = ETHTOOL_A_FEC_MAX,\n\t.table = ethtool_fec_policy,\n};\n\nstruct ynl_policy_attr ethtool_module_eeprom_policy[ETHTOOL_A_MODULE_EEPROM_MAX + 1] = {\n\t[ETHTOOL_A_MODULE_EEPROM_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_MODULE_EEPROM_OFFSET] = { .name = \"offset\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_MODULE_EEPROM_LENGTH] = { .name = \"length\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_MODULE_EEPROM_PAGE] = { .name = \"page\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_MODULE_EEPROM_BANK] = { .name = \"bank\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS] = { .name = \"i2c-address\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_MODULE_EEPROM_DATA] = { .name = \"data\", .type = YNL_PT_BINARY,},\n};\n\nstruct ynl_policy_nest ethtool_module_eeprom_nest = {\n\t.max_attr = ETHTOOL_A_MODULE_EEPROM_MAX,\n\t.table = ethtool_module_eeprom_policy,\n};\n\nstruct ynl_policy_attr ethtool_phc_vclocks_policy[ETHTOOL_A_PHC_VCLOCKS_MAX + 1] = {\n\t[ETHTOOL_A_PHC_VCLOCKS_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_PHC_VCLOCKS_NUM] = { .name = \"num\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_PHC_VCLOCKS_INDEX] = { .name = \"index\", .type = YNL_PT_BINARY,},\n};\n\nstruct ynl_policy_nest ethtool_phc_vclocks_nest = {\n\t.max_attr = ETHTOOL_A_PHC_VCLOCKS_MAX,\n\t.table = ethtool_phc_vclocks_policy,\n};\n\nstruct ynl_policy_attr ethtool_module_policy[ETHTOOL_A_MODULE_MAX + 1] = {\n\t[ETHTOOL_A_MODULE_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_MODULE_POWER_MODE_POLICY] = { .name = \"power-mode-policy\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_MODULE_POWER_MODE] = { .name = \"power-mode\", .type = YNL_PT_U8, },\n};\n\nstruct ynl_policy_nest ethtool_module_nest = {\n\t.max_attr = ETHTOOL_A_MODULE_MAX,\n\t.table = ethtool_module_policy,\n};\n\nstruct ynl_policy_attr ethtool_pse_policy[ETHTOOL_A_PSE_MAX + 1] = {\n\t[ETHTOOL_A_PSE_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_PODL_PSE_ADMIN_STATE] = { .name = \"admin-state\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_PODL_PSE_ADMIN_CONTROL] = { .name = \"admin-control\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_PODL_PSE_PW_D_STATUS] = { .name = \"pw-d-status\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_pse_nest = {\n\t.max_attr = ETHTOOL_A_PSE_MAX,\n\t.table = ethtool_pse_policy,\n};\n\nstruct ynl_policy_attr ethtool_rss_policy[ETHTOOL_A_RSS_MAX + 1] = {\n\t[ETHTOOL_A_RSS_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_RSS_CONTEXT] = { .name = \"context\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RSS_HFUNC] = { .name = \"hfunc\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_RSS_INDIR] = { .name = \"indir\", .type = YNL_PT_BINARY,},\n\t[ETHTOOL_A_RSS_HKEY] = { .name = \"hkey\", .type = YNL_PT_BINARY,},\n};\n\nstruct ynl_policy_nest ethtool_rss_nest = {\n\t.max_attr = ETHTOOL_A_RSS_MAX,\n\t.table = ethtool_rss_policy,\n};\n\nstruct ynl_policy_attr ethtool_plca_policy[ETHTOOL_A_PLCA_MAX + 1] = {\n\t[ETHTOOL_A_PLCA_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_PLCA_VERSION] = { .name = \"version\", .type = YNL_PT_U16, },\n\t[ETHTOOL_A_PLCA_ENABLED] = { .name = \"enabled\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_PLCA_STATUS] = { .name = \"status\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_PLCA_NODE_CNT] = { .name = \"node-cnt\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_PLCA_NODE_ID] = { .name = \"node-id\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_PLCA_TO_TMR] = { .name = \"to-tmr\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_PLCA_BURST_CNT] = { .name = \"burst-cnt\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_PLCA_BURST_TMR] = { .name = \"burst-tmr\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest ethtool_plca_nest = {\n\t.max_attr = ETHTOOL_A_PLCA_MAX,\n\t.table = ethtool_plca_policy,\n};\n\nstruct ynl_policy_attr ethtool_mm_policy[ETHTOOL_A_MM_MAX + 1] = {\n\t[ETHTOOL_A_MM_HEADER] = { .name = \"header\", .type = YNL_PT_NEST, .nest = &ethtool_header_nest, },\n\t[ETHTOOL_A_MM_PMAC_ENABLED] = { .name = \"pmac-enabled\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_MM_TX_ENABLED] = { .name = \"tx-enabled\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_MM_TX_ACTIVE] = { .name = \"tx-active\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_MM_TX_MIN_FRAG_SIZE] = { .name = \"tx-min-frag-size\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_MM_RX_MIN_FRAG_SIZE] = { .name = \"rx-min-frag-size\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_MM_VERIFY_ENABLED] = { .name = \"verify-enabled\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_MM_VERIFY_STATUS] = { .name = \"verify-status\", .type = YNL_PT_U8, },\n\t[ETHTOOL_A_MM_VERIFY_TIME] = { .name = \"verify-time\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_MM_MAX_VERIFY_TIME] = { .name = \"max-verify-time\", .type = YNL_PT_U32, },\n\t[ETHTOOL_A_MM_STATS] = { .name = \"stats\", .type = YNL_PT_NEST, .nest = &ethtool_mm_stat_nest, },\n};\n\nstruct ynl_policy_nest ethtool_mm_nest = {\n\t.max_attr = ETHTOOL_A_MM_MAX,\n\t.table = ethtool_mm_policy,\n};\n\n \nvoid ethtool_header_free(struct ethtool_header *obj)\n{\n\tfree(obj->dev_name);\n}\n\nint ethtool_header_put(struct nlmsghdr *nlh, unsigned int attr_type,\n\t\t       struct ethtool_header *obj)\n{\n\tstruct nlattr *nest;\n\n\tnest = mnl_attr_nest_start(nlh, attr_type);\n\tif (obj->_present.dev_index)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_HEADER_DEV_INDEX, obj->dev_index);\n\tif (obj->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, ETHTOOL_A_HEADER_DEV_NAME, obj->dev_name);\n\tif (obj->_present.flags)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_HEADER_FLAGS, obj->flags);\n\tmnl_attr_nest_end(nlh, nest);\n\n\treturn 0;\n}\n\nint ethtool_header_parse(struct ynl_parse_arg *yarg,\n\t\t\t const struct nlattr *nested)\n{\n\tstruct ethtool_header *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_HEADER_DEV_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.dev_index = 1;\n\t\t\tdst->dev_index = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_HEADER_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == ETHTOOL_A_HEADER_FLAGS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.flags = 1;\n\t\t\tdst->flags = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_pause_stat_free(struct ethtool_pause_stat *obj)\n{\n}\n\nint ethtool_pause_stat_put(struct nlmsghdr *nlh, unsigned int attr_type,\n\t\t\t   struct ethtool_pause_stat *obj)\n{\n\tstruct nlattr *nest;\n\n\tnest = mnl_attr_nest_start(nlh, attr_type);\n\tif (obj->_present.tx_frames)\n\t\tmnl_attr_put_u64(nlh, ETHTOOL_A_PAUSE_STAT_TX_FRAMES, obj->tx_frames);\n\tif (obj->_present.rx_frames)\n\t\tmnl_attr_put_u64(nlh, ETHTOOL_A_PAUSE_STAT_RX_FRAMES, obj->rx_frames);\n\tmnl_attr_nest_end(nlh, nest);\n\n\treturn 0;\n}\n\nint ethtool_pause_stat_parse(struct ynl_parse_arg *yarg,\n\t\t\t     const struct nlattr *nested)\n{\n\tstruct ethtool_pause_stat *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_PAUSE_STAT_TX_FRAMES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_frames = 1;\n\t\t\tdst->tx_frames = mnl_attr_get_u64(attr);\n\t\t} else if (type == ETHTOOL_A_PAUSE_STAT_RX_FRAMES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_frames = 1;\n\t\t\tdst->rx_frames = mnl_attr_get_u64(attr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_cable_test_tdr_cfg_free(struct ethtool_cable_test_tdr_cfg *obj)\n{\n}\n\nvoid ethtool_fec_stat_free(struct ethtool_fec_stat *obj)\n{\n\tfree(obj->corrected);\n\tfree(obj->uncorr);\n\tfree(obj->corr_bits);\n}\n\nint ethtool_fec_stat_put(struct nlmsghdr *nlh, unsigned int attr_type,\n\t\t\t struct ethtool_fec_stat *obj)\n{\n\tstruct nlattr *nest;\n\n\tnest = mnl_attr_nest_start(nlh, attr_type);\n\tif (obj->_present.corrected_len)\n\t\tmnl_attr_put(nlh, ETHTOOL_A_FEC_STAT_CORRECTED, obj->_present.corrected_len, obj->corrected);\n\tif (obj->_present.uncorr_len)\n\t\tmnl_attr_put(nlh, ETHTOOL_A_FEC_STAT_UNCORR, obj->_present.uncorr_len, obj->uncorr);\n\tif (obj->_present.corr_bits_len)\n\t\tmnl_attr_put(nlh, ETHTOOL_A_FEC_STAT_CORR_BITS, obj->_present.corr_bits_len, obj->corr_bits);\n\tmnl_attr_nest_end(nlh, nest);\n\n\treturn 0;\n}\n\nint ethtool_fec_stat_parse(struct ynl_parse_arg *yarg,\n\t\t\t   const struct nlattr *nested)\n{\n\tstruct ethtool_fec_stat *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_FEC_STAT_CORRECTED) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = mnl_attr_get_payload_len(attr);\n\t\t\tdst->_present.corrected_len = len;\n\t\t\tdst->corrected = malloc(len);\n\t\t\tmemcpy(dst->corrected, mnl_attr_get_payload(attr), len);\n\t\t} else if (type == ETHTOOL_A_FEC_STAT_UNCORR) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = mnl_attr_get_payload_len(attr);\n\t\t\tdst->_present.uncorr_len = len;\n\t\t\tdst->uncorr = malloc(len);\n\t\t\tmemcpy(dst->uncorr, mnl_attr_get_payload(attr), len);\n\t\t} else if (type == ETHTOOL_A_FEC_STAT_CORR_BITS) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = mnl_attr_get_payload_len(attr);\n\t\t\tdst->_present.corr_bits_len = len;\n\t\t\tdst->corr_bits = malloc(len);\n\t\t\tmemcpy(dst->corr_bits, mnl_attr_get_payload(attr), len);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_mm_stat_free(struct ethtool_mm_stat *obj)\n{\n}\n\nint ethtool_mm_stat_parse(struct ynl_parse_arg *yarg,\n\t\t\t  const struct nlattr *nested)\n{\n\tstruct ethtool_mm_stat *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_MM_STAT_REASSEMBLY_ERRORS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.reassembly_errors = 1;\n\t\t\tdst->reassembly_errors = mnl_attr_get_u64(attr);\n\t\t} else if (type == ETHTOOL_A_MM_STAT_SMD_ERRORS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.smd_errors = 1;\n\t\t\tdst->smd_errors = mnl_attr_get_u64(attr);\n\t\t} else if (type == ETHTOOL_A_MM_STAT_REASSEMBLY_OK) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.reassembly_ok = 1;\n\t\t\tdst->reassembly_ok = mnl_attr_get_u64(attr);\n\t\t} else if (type == ETHTOOL_A_MM_STAT_RX_FRAG_COUNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_frag_count = 1;\n\t\t\tdst->rx_frag_count = mnl_attr_get_u64(attr);\n\t\t} else if (type == ETHTOOL_A_MM_STAT_TX_FRAG_COUNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_frag_count = 1;\n\t\t\tdst->tx_frag_count = mnl_attr_get_u64(attr);\n\t\t} else if (type == ETHTOOL_A_MM_STAT_HOLD_COUNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.hold_count = 1;\n\t\t\tdst->hold_count = mnl_attr_get_u64(attr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_cable_result_free(struct ethtool_cable_result *obj)\n{\n}\n\nint ethtool_cable_result_parse(struct ynl_parse_arg *yarg,\n\t\t\t       const struct nlattr *nested)\n{\n\tstruct ethtool_cable_result *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_CABLE_RESULT_PAIR) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.pair = 1;\n\t\t\tdst->pair = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_CABLE_RESULT_CODE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.code = 1;\n\t\t\tdst->code = mnl_attr_get_u8(attr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_cable_fault_length_free(struct ethtool_cable_fault_length *obj)\n{\n}\n\nint ethtool_cable_fault_length_parse(struct ynl_parse_arg *yarg,\n\t\t\t\t     const struct nlattr *nested)\n{\n\tstruct ethtool_cable_fault_length *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.pair = 1;\n\t\t\tdst->pair = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_CABLE_FAULT_LENGTH_CM) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.cm = 1;\n\t\t\tdst->cm = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_bitset_bit_free(struct ethtool_bitset_bit *obj)\n{\n\tfree(obj->name);\n}\n\nint ethtool_bitset_bit_put(struct nlmsghdr *nlh, unsigned int attr_type,\n\t\t\t   struct ethtool_bitset_bit *obj)\n{\n\tstruct nlattr *nest;\n\n\tnest = mnl_attr_nest_start(nlh, attr_type);\n\tif (obj->_present.index)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_BITSET_BIT_INDEX, obj->index);\n\tif (obj->_present.name_len)\n\t\tmnl_attr_put_strz(nlh, ETHTOOL_A_BITSET_BIT_NAME, obj->name);\n\tif (obj->_present.value)\n\t\tmnl_attr_put(nlh, ETHTOOL_A_BITSET_BIT_VALUE, 0, NULL);\n\tmnl_attr_nest_end(nlh, nest);\n\n\treturn 0;\n}\n\nint ethtool_bitset_bit_parse(struct ynl_parse_arg *yarg,\n\t\t\t     const struct nlattr *nested)\n{\n\tstruct ethtool_bitset_bit *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_BITSET_BIT_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.index = 1;\n\t\t\tdst->index = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_BITSET_BIT_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.name_len = len;\n\t\t\tdst->name = malloc(len + 1);\n\t\t\tmemcpy(dst->name, mnl_attr_get_str(attr), len);\n\t\t\tdst->name[len] = 0;\n\t\t} else if (type == ETHTOOL_A_BITSET_BIT_VALUE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.value = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_tunnel_udp_entry_free(struct ethtool_tunnel_udp_entry *obj)\n{\n}\n\nint ethtool_tunnel_udp_entry_parse(struct ynl_parse_arg *yarg,\n\t\t\t\t   const struct nlattr *nested)\n{\n\tstruct ethtool_tunnel_udp_entry *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.port = 1;\n\t\t\tdst->port = mnl_attr_get_u16(attr);\n\t\t} else if (type == ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.type = 1;\n\t\t\tdst->type = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_string_free(struct ethtool_string *obj)\n{\n\tfree(obj->value);\n}\n\nint ethtool_string_put(struct nlmsghdr *nlh, unsigned int attr_type,\n\t\t       struct ethtool_string *obj)\n{\n\tstruct nlattr *nest;\n\n\tnest = mnl_attr_nest_start(nlh, attr_type);\n\tif (obj->_present.index)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_STRING_INDEX, obj->index);\n\tif (obj->_present.value_len)\n\t\tmnl_attr_put_strz(nlh, ETHTOOL_A_STRING_VALUE, obj->value);\n\tmnl_attr_nest_end(nlh, nest);\n\n\treturn 0;\n}\n\nint ethtool_string_parse(struct ynl_parse_arg *yarg,\n\t\t\t const struct nlattr *nested)\n{\n\tstruct ethtool_string *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_STRING_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.index = 1;\n\t\t\tdst->index = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_STRING_VALUE) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.value_len = len;\n\t\t\tdst->value = malloc(len + 1);\n\t\t\tmemcpy(dst->value, mnl_attr_get_str(attr), len);\n\t\t\tdst->value[len] = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_cable_nest_free(struct ethtool_cable_nest *obj)\n{\n\tethtool_cable_result_free(&obj->result);\n\tethtool_cable_fault_length_free(&obj->fault_length);\n}\n\nint ethtool_cable_nest_parse(struct ynl_parse_arg *yarg,\n\t\t\t     const struct nlattr *nested)\n{\n\tstruct ethtool_cable_nest *dst = yarg->data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_CABLE_NEST_RESULT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.result = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_cable_result_nest;\n\t\t\tparg.data = &dst->result;\n\t\t\tif (ethtool_cable_result_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_CABLE_NEST_FAULT_LENGTH) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.fault_length = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_cable_fault_length_nest;\n\t\t\tparg.data = &dst->fault_length;\n\t\t\tif (ethtool_cable_fault_length_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_bitset_bits_free(struct ethtool_bitset_bits *obj)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < obj->n_bit; i++)\n\t\tethtool_bitset_bit_free(&obj->bit[i]);\n\tfree(obj->bit);\n}\n\nint ethtool_bitset_bits_put(struct nlmsghdr *nlh, unsigned int attr_type,\n\t\t\t    struct ethtool_bitset_bits *obj)\n{\n\tstruct nlattr *nest;\n\n\tnest = mnl_attr_nest_start(nlh, attr_type);\n\tfor (unsigned int i = 0; i < obj->n_bit; i++)\n\t\tethtool_bitset_bit_put(nlh, ETHTOOL_A_BITSET_BITS_BIT, &obj->bit[i]);\n\tmnl_attr_nest_end(nlh, nest);\n\n\treturn 0;\n}\n\nint ethtool_bitset_bits_parse(struct ynl_parse_arg *yarg,\n\t\t\t      const struct nlattr *nested)\n{\n\tstruct ethtool_bitset_bits *dst = yarg->data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\tunsigned int n_bit = 0;\n\tint i;\n\n\tparg.ys = yarg->ys;\n\n\tif (dst->bit)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (bitset-bits.bit)\");\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_BITSET_BITS_BIT) {\n\t\t\tn_bit++;\n\t\t}\n\t}\n\n\tif (n_bit) {\n\t\tdst->bit = calloc(n_bit, sizeof(*dst->bit));\n\t\tdst->n_bit = n_bit;\n\t\ti = 0;\n\t\tparg.rsp_policy = &ethtool_bitset_bit_nest;\n\t\tmnl_attr_for_each_nested(attr, nested) {\n\t\t\tif (mnl_attr_get_type(attr) == ETHTOOL_A_BITSET_BITS_BIT) {\n\t\t\t\tparg.data = &dst->bit[i];\n\t\t\t\tif (ethtool_bitset_bit_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_strings_free(struct ethtool_strings *obj)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < obj->n_string; i++)\n\t\tethtool_string_free(&obj->string[i]);\n\tfree(obj->string);\n}\n\nint ethtool_strings_put(struct nlmsghdr *nlh, unsigned int attr_type,\n\t\t\tstruct ethtool_strings *obj)\n{\n\tstruct nlattr *nest;\n\n\tnest = mnl_attr_nest_start(nlh, attr_type);\n\tfor (unsigned int i = 0; i < obj->n_string; i++)\n\t\tethtool_string_put(nlh, ETHTOOL_A_STRINGS_STRING, &obj->string[i]);\n\tmnl_attr_nest_end(nlh, nest);\n\n\treturn 0;\n}\n\nint ethtool_strings_parse(struct ynl_parse_arg *yarg,\n\t\t\t  const struct nlattr *nested)\n{\n\tstruct ethtool_strings *dst = yarg->data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\tunsigned int n_string = 0;\n\tint i;\n\n\tparg.ys = yarg->ys;\n\n\tif (dst->string)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (strings.string)\");\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_STRINGS_STRING) {\n\t\t\tn_string++;\n\t\t}\n\t}\n\n\tif (n_string) {\n\t\tdst->string = calloc(n_string, sizeof(*dst->string));\n\t\tdst->n_string = n_string;\n\t\ti = 0;\n\t\tparg.rsp_policy = &ethtool_string_nest;\n\t\tmnl_attr_for_each_nested(attr, nested) {\n\t\t\tif (mnl_attr_get_type(attr) == ETHTOOL_A_STRINGS_STRING) {\n\t\t\t\tparg.data = &dst->string[i];\n\t\t\t\tif (ethtool_string_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_bitset_free(struct ethtool_bitset *obj)\n{\n\tethtool_bitset_bits_free(&obj->bits);\n}\n\nint ethtool_bitset_put(struct nlmsghdr *nlh, unsigned int attr_type,\n\t\t       struct ethtool_bitset *obj)\n{\n\tstruct nlattr *nest;\n\n\tnest = mnl_attr_nest_start(nlh, attr_type);\n\tif (obj->_present.nomask)\n\t\tmnl_attr_put(nlh, ETHTOOL_A_BITSET_NOMASK, 0, NULL);\n\tif (obj->_present.size)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_BITSET_SIZE, obj->size);\n\tif (obj->_present.bits)\n\t\tethtool_bitset_bits_put(nlh, ETHTOOL_A_BITSET_BITS, &obj->bits);\n\tmnl_attr_nest_end(nlh, nest);\n\n\treturn 0;\n}\n\nint ethtool_bitset_parse(struct ynl_parse_arg *yarg,\n\t\t\t const struct nlattr *nested)\n{\n\tstruct ethtool_bitset *dst = yarg->data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_BITSET_NOMASK) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.nomask = 1;\n\t\t} else if (type == ETHTOOL_A_BITSET_SIZE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.size = 1;\n\t\t\tdst->size = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_BITSET_BITS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.bits = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_bits_nest;\n\t\t\tparg.data = &dst->bits;\n\t\t\tif (ethtool_bitset_bits_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_stringset_free(struct ethtool_stringset_ *obj)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < obj->n_strings; i++)\n\t\tethtool_strings_free(&obj->strings[i]);\n\tfree(obj->strings);\n}\n\nint ethtool_stringset_put(struct nlmsghdr *nlh, unsigned int attr_type,\n\t\t\t  struct ethtool_stringset_ *obj)\n{\n\tstruct nlattr *nest;\n\n\tnest = mnl_attr_nest_start(nlh, attr_type);\n\tif (obj->_present.id)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_STRINGSET_ID, obj->id);\n\tif (obj->_present.count)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_STRINGSET_COUNT, obj->count);\n\tfor (unsigned int i = 0; i < obj->n_strings; i++)\n\t\tethtool_strings_put(nlh, ETHTOOL_A_STRINGSET_STRINGS, &obj->strings[i]);\n\tmnl_attr_nest_end(nlh, nest);\n\n\treturn 0;\n}\n\nint ethtool_stringset_parse(struct ynl_parse_arg *yarg,\n\t\t\t    const struct nlattr *nested)\n{\n\tstruct ethtool_stringset_ *dst = yarg->data;\n\tunsigned int n_strings = 0;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\tint i;\n\n\tparg.ys = yarg->ys;\n\n\tif (dst->strings)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (stringset.strings)\");\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_STRINGSET_ID) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.id = 1;\n\t\t\tdst->id = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_STRINGSET_COUNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.count = 1;\n\t\t\tdst->count = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_STRINGSET_STRINGS) {\n\t\t\tn_strings++;\n\t\t}\n\t}\n\n\tif (n_strings) {\n\t\tdst->strings = calloc(n_strings, sizeof(*dst->strings));\n\t\tdst->n_strings = n_strings;\n\t\ti = 0;\n\t\tparg.rsp_policy = &ethtool_strings_nest;\n\t\tmnl_attr_for_each_nested(attr, nested) {\n\t\t\tif (mnl_attr_get_type(attr) == ETHTOOL_A_STRINGSET_STRINGS) {\n\t\t\t\tparg.data = &dst->strings[i];\n\t\t\t\tif (ethtool_strings_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_tunnel_udp_table_free(struct ethtool_tunnel_udp_table *obj)\n{\n\tunsigned int i;\n\n\tethtool_bitset_free(&obj->types);\n\tfor (i = 0; i < obj->n_entry; i++)\n\t\tethtool_tunnel_udp_entry_free(&obj->entry[i]);\n\tfree(obj->entry);\n}\n\nint ethtool_tunnel_udp_table_parse(struct ynl_parse_arg *yarg,\n\t\t\t\t   const struct nlattr *nested)\n{\n\tstruct ethtool_tunnel_udp_table *dst = yarg->data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\tunsigned int n_entry = 0;\n\tint i;\n\n\tparg.ys = yarg->ys;\n\n\tif (dst->entry)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (tunnel-udp-table.entry)\");\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.size = 1;\n\t\t\tdst->size = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.types = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->types;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY) {\n\t\t\tn_entry++;\n\t\t}\n\t}\n\n\tif (n_entry) {\n\t\tdst->entry = calloc(n_entry, sizeof(*dst->entry));\n\t\tdst->n_entry = n_entry;\n\t\ti = 0;\n\t\tparg.rsp_policy = &ethtool_tunnel_udp_entry_nest;\n\t\tmnl_attr_for_each_nested(attr, nested) {\n\t\t\tif (mnl_attr_get_type(attr) == ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY) {\n\t\t\t\tparg.data = &dst->entry[i];\n\t\t\t\tif (ethtool_tunnel_udp_entry_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_stringsets_free(struct ethtool_stringsets *obj)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < obj->n_stringset; i++)\n\t\tethtool_stringset_free(&obj->stringset[i]);\n\tfree(obj->stringset);\n}\n\nint ethtool_stringsets_put(struct nlmsghdr *nlh, unsigned int attr_type,\n\t\t\t   struct ethtool_stringsets *obj)\n{\n\tstruct nlattr *nest;\n\n\tnest = mnl_attr_nest_start(nlh, attr_type);\n\tfor (unsigned int i = 0; i < obj->n_stringset; i++)\n\t\tethtool_stringset_put(nlh, ETHTOOL_A_STRINGSETS_STRINGSET, &obj->stringset[i]);\n\tmnl_attr_nest_end(nlh, nest);\n\n\treturn 0;\n}\n\nint ethtool_stringsets_parse(struct ynl_parse_arg *yarg,\n\t\t\t     const struct nlattr *nested)\n{\n\tstruct ethtool_stringsets *dst = yarg->data;\n\tunsigned int n_stringset = 0;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\tint i;\n\n\tparg.ys = yarg->ys;\n\n\tif (dst->stringset)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (stringsets.stringset)\");\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_STRINGSETS_STRINGSET) {\n\t\t\tn_stringset++;\n\t\t}\n\t}\n\n\tif (n_stringset) {\n\t\tdst->stringset = calloc(n_stringset, sizeof(*dst->stringset));\n\t\tdst->n_stringset = n_stringset;\n\t\ti = 0;\n\t\tparg.rsp_policy = &ethtool_stringset_nest;\n\t\tmnl_attr_for_each_nested(attr, nested) {\n\t\t\tif (mnl_attr_get_type(attr) == ETHTOOL_A_STRINGSETS_STRINGSET) {\n\t\t\t\tparg.data = &dst->stringset[i];\n\t\t\t\tif (ethtool_stringset_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ethtool_tunnel_udp_free(struct ethtool_tunnel_udp *obj)\n{\n\tethtool_tunnel_udp_table_free(&obj->table);\n}\n\nint ethtool_tunnel_udp_parse(struct ynl_parse_arg *yarg,\n\t\t\t     const struct nlattr *nested)\n{\n\tstruct ethtool_tunnel_udp *dst = yarg->data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_TUNNEL_UDP_TABLE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.table = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_tunnel_udp_table_nest;\n\t\t\tparg.data = &dst->table;\n\t\t\tif (ethtool_tunnel_udp_table_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_strset_get_req_free(struct ethtool_strset_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tethtool_stringsets_free(&req->stringsets);\n\tfree(req);\n}\n\nvoid ethtool_strset_get_rsp_free(struct ethtool_strset_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_stringsets_free(&rsp->stringsets);\n\tfree(rsp);\n}\n\nint ethtool_strset_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_strset_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_STRSET_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_STRSET_STRINGSETS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.stringsets = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_stringsets_nest;\n\t\t\tparg.data = &dst->stringsets;\n\t\t\tif (ethtool_stringsets_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_strset_get_rsp *\nethtool_strset_get(struct ynl_sock *ys, struct ethtool_strset_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_strset_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_STRSET_GET, 1);\n\tys->req_policy = &ethtool_strset_nest;\n\tyrs.yarg.rsp_policy = &ethtool_strset_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_STRSET_HEADER, &req->header);\n\tif (req->_present.stringsets)\n\t\tethtool_stringsets_put(nlh, ETHTOOL_A_STRSET_STRINGSETS, &req->stringsets);\n\tif (req->_present.counts_only)\n\t\tmnl_attr_put(nlh, ETHTOOL_A_STRSET_COUNTS_ONLY, 0, NULL);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_strset_get_rsp_parse;\n\tyrs.rsp_cmd = ETHTOOL_MSG_STRSET_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_strset_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_strset_get_list_free(struct ethtool_strset_get_list *rsp)\n{\n\tstruct ethtool_strset_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_stringsets_free(&rsp->obj.stringsets);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_strset_get_list *\nethtool_strset_get_dump(struct ynl_sock *ys,\n\t\t\tstruct ethtool_strset_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_strset_get_list);\n\tyds.cb = ethtool_strset_get_rsp_parse;\n\tyds.rsp_cmd = ETHTOOL_MSG_STRSET_GET;\n\tyds.rsp_policy = &ethtool_strset_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_STRSET_GET, 1);\n\tys->req_policy = &ethtool_strset_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_STRSET_HEADER, &req->header);\n\tif (req->_present.stringsets)\n\t\tethtool_stringsets_put(nlh, ETHTOOL_A_STRSET_STRINGSETS, &req->stringsets);\n\tif (req->_present.counts_only)\n\t\tmnl_attr_put(nlh, ETHTOOL_A_STRSET_COUNTS_ONLY, 0, NULL);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_strset_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid ethtool_linkinfo_get_req_free(struct ethtool_linkinfo_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_linkinfo_get_rsp_free(struct ethtool_linkinfo_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp);\n}\n\nint ethtool_linkinfo_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_linkinfo_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_LINKINFO_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_LINKINFO_PORT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.port = 1;\n\t\t\tdst->port = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_LINKINFO_PHYADDR) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.phyaddr = 1;\n\t\t\tdst->phyaddr = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_LINKINFO_TP_MDIX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tp_mdix = 1;\n\t\t\tdst->tp_mdix = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_LINKINFO_TP_MDIX_CTRL) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tp_mdix_ctrl = 1;\n\t\t\tdst->tp_mdix_ctrl = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_LINKINFO_TRANSCEIVER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.transceiver = 1;\n\t\t\tdst->transceiver = mnl_attr_get_u8(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_linkinfo_get_rsp *\nethtool_linkinfo_get(struct ynl_sock *ys, struct ethtool_linkinfo_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_linkinfo_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_LINKINFO_GET, 1);\n\tys->req_policy = &ethtool_linkinfo_nest;\n\tyrs.yarg.rsp_policy = &ethtool_linkinfo_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_LINKINFO_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_linkinfo_get_rsp_parse;\n\tyrs.rsp_cmd = ETHTOOL_MSG_LINKINFO_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_linkinfo_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_linkinfo_get_list_free(struct ethtool_linkinfo_get_list *rsp)\n{\n\tstruct ethtool_linkinfo_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_linkinfo_get_list *\nethtool_linkinfo_get_dump(struct ynl_sock *ys,\n\t\t\t  struct ethtool_linkinfo_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_linkinfo_get_list);\n\tyds.cb = ethtool_linkinfo_get_rsp_parse;\n\tyds.rsp_cmd = ETHTOOL_MSG_LINKINFO_GET;\n\tyds.rsp_policy = &ethtool_linkinfo_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_LINKINFO_GET, 1);\n\tys->req_policy = &ethtool_linkinfo_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_LINKINFO_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_linkinfo_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_linkinfo_get_ntf_free(struct ethtool_linkinfo_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_linkinfo_set_req_free(struct ethtool_linkinfo_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nint ethtool_linkinfo_set(struct ynl_sock *ys,\n\t\t\t struct ethtool_linkinfo_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_LINKINFO_SET, 1);\n\tys->req_policy = &ethtool_linkinfo_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_LINKINFO_HEADER, &req->header);\n\tif (req->_present.port)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_LINKINFO_PORT, req->port);\n\tif (req->_present.phyaddr)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_LINKINFO_PHYADDR, req->phyaddr);\n\tif (req->_present.tp_mdix)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_LINKINFO_TP_MDIX, req->tp_mdix);\n\tif (req->_present.tp_mdix_ctrl)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_LINKINFO_TP_MDIX_CTRL, req->tp_mdix_ctrl);\n\tif (req->_present.transceiver)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_LINKINFO_TRANSCEIVER, req->transceiver);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_linkmodes_get_req_free(struct ethtool_linkmodes_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_linkmodes_get_rsp_free(struct ethtool_linkmodes_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_bitset_free(&rsp->ours);\n\tethtool_bitset_free(&rsp->peer);\n\tfree(rsp);\n}\n\nint ethtool_linkmodes_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_linkmodes_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_LINKMODES_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_LINKMODES_AUTONEG) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.autoneg = 1;\n\t\t\tdst->autoneg = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_LINKMODES_OURS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.ours = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->ours;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_LINKMODES_PEER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.peer = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->peer;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_LINKMODES_SPEED) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.speed = 1;\n\t\t\tdst->speed = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_LINKMODES_DUPLEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.duplex = 1;\n\t\t\tdst->duplex = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.master_slave_cfg = 1;\n\t\t\tdst->master_slave_cfg = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.master_slave_state = 1;\n\t\t\tdst->master_slave_state = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_LINKMODES_LANES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.lanes = 1;\n\t\t\tdst->lanes = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_LINKMODES_RATE_MATCHING) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rate_matching = 1;\n\t\t\tdst->rate_matching = mnl_attr_get_u8(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_linkmodes_get_rsp *\nethtool_linkmodes_get(struct ynl_sock *ys,\n\t\t      struct ethtool_linkmodes_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_linkmodes_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_LINKMODES_GET, 1);\n\tys->req_policy = &ethtool_linkmodes_nest;\n\tyrs.yarg.rsp_policy = &ethtool_linkmodes_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_LINKMODES_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_linkmodes_get_rsp_parse;\n\tyrs.rsp_cmd = ETHTOOL_MSG_LINKMODES_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_linkmodes_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_linkmodes_get_list_free(struct ethtool_linkmodes_get_list *rsp)\n{\n\tstruct ethtool_linkmodes_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_bitset_free(&rsp->obj.ours);\n\t\tethtool_bitset_free(&rsp->obj.peer);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_linkmodes_get_list *\nethtool_linkmodes_get_dump(struct ynl_sock *ys,\n\t\t\t   struct ethtool_linkmodes_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_linkmodes_get_list);\n\tyds.cb = ethtool_linkmodes_get_rsp_parse;\n\tyds.rsp_cmd = ETHTOOL_MSG_LINKMODES_GET;\n\tyds.rsp_policy = &ethtool_linkmodes_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_LINKMODES_GET, 1);\n\tys->req_policy = &ethtool_linkmodes_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_LINKMODES_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_linkmodes_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_linkmodes_get_ntf_free(struct ethtool_linkmodes_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tethtool_bitset_free(&rsp->obj.ours);\n\tethtool_bitset_free(&rsp->obj.peer);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_linkmodes_set_req_free(struct ethtool_linkmodes_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tethtool_bitset_free(&req->ours);\n\tethtool_bitset_free(&req->peer);\n\tfree(req);\n}\n\nint ethtool_linkmodes_set(struct ynl_sock *ys,\n\t\t\t  struct ethtool_linkmodes_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_LINKMODES_SET, 1);\n\tys->req_policy = &ethtool_linkmodes_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_LINKMODES_HEADER, &req->header);\n\tif (req->_present.autoneg)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_LINKMODES_AUTONEG, req->autoneg);\n\tif (req->_present.ours)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_LINKMODES_OURS, &req->ours);\n\tif (req->_present.peer)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_LINKMODES_PEER, &req->peer);\n\tif (req->_present.speed)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_LINKMODES_SPEED, req->speed);\n\tif (req->_present.duplex)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_LINKMODES_DUPLEX, req->duplex);\n\tif (req->_present.master_slave_cfg)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG, req->master_slave_cfg);\n\tif (req->_present.master_slave_state)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE, req->master_slave_state);\n\tif (req->_present.lanes)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_LINKMODES_LANES, req->lanes);\n\tif (req->_present.rate_matching)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_LINKMODES_RATE_MATCHING, req->rate_matching);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_linkstate_get_req_free(struct ethtool_linkstate_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_linkstate_get_rsp_free(struct ethtool_linkstate_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp);\n}\n\nint ethtool_linkstate_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_linkstate_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_LINKSTATE_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_LINKSTATE_LINK) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.link = 1;\n\t\t\tdst->link = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_LINKSTATE_SQI) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.sqi = 1;\n\t\t\tdst->sqi = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_LINKSTATE_SQI_MAX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.sqi_max = 1;\n\t\t\tdst->sqi_max = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_LINKSTATE_EXT_STATE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.ext_state = 1;\n\t\t\tdst->ext_state = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_LINKSTATE_EXT_SUBSTATE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.ext_substate = 1;\n\t\t\tdst->ext_substate = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_LINKSTATE_EXT_DOWN_CNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.ext_down_cnt = 1;\n\t\t\tdst->ext_down_cnt = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_linkstate_get_rsp *\nethtool_linkstate_get(struct ynl_sock *ys,\n\t\t      struct ethtool_linkstate_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_linkstate_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_LINKSTATE_GET, 1);\n\tys->req_policy = &ethtool_linkstate_nest;\n\tyrs.yarg.rsp_policy = &ethtool_linkstate_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_LINKSTATE_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_linkstate_get_rsp_parse;\n\tyrs.rsp_cmd = ETHTOOL_MSG_LINKSTATE_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_linkstate_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_linkstate_get_list_free(struct ethtool_linkstate_get_list *rsp)\n{\n\tstruct ethtool_linkstate_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_linkstate_get_list *\nethtool_linkstate_get_dump(struct ynl_sock *ys,\n\t\t\t   struct ethtool_linkstate_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_linkstate_get_list);\n\tyds.cb = ethtool_linkstate_get_rsp_parse;\n\tyds.rsp_cmd = ETHTOOL_MSG_LINKSTATE_GET;\n\tyds.rsp_policy = &ethtool_linkstate_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_LINKSTATE_GET, 1);\n\tys->req_policy = &ethtool_linkstate_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_LINKSTATE_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_linkstate_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid ethtool_debug_get_req_free(struct ethtool_debug_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_debug_get_rsp_free(struct ethtool_debug_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_bitset_free(&rsp->msgmask);\n\tfree(rsp);\n}\n\nint ethtool_debug_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_debug_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_DEBUG_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_DEBUG_MSGMASK) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.msgmask = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->msgmask;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_debug_get_rsp *\nethtool_debug_get(struct ynl_sock *ys, struct ethtool_debug_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_debug_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_DEBUG_GET, 1);\n\tys->req_policy = &ethtool_debug_nest;\n\tyrs.yarg.rsp_policy = &ethtool_debug_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_DEBUG_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_debug_get_rsp_parse;\n\tyrs.rsp_cmd = ETHTOOL_MSG_DEBUG_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_debug_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_debug_get_list_free(struct ethtool_debug_get_list *rsp)\n{\n\tstruct ethtool_debug_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_bitset_free(&rsp->obj.msgmask);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_debug_get_list *\nethtool_debug_get_dump(struct ynl_sock *ys,\n\t\t       struct ethtool_debug_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_debug_get_list);\n\tyds.cb = ethtool_debug_get_rsp_parse;\n\tyds.rsp_cmd = ETHTOOL_MSG_DEBUG_GET;\n\tyds.rsp_policy = &ethtool_debug_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_DEBUG_GET, 1);\n\tys->req_policy = &ethtool_debug_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_DEBUG_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_debug_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_debug_get_ntf_free(struct ethtool_debug_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tethtool_bitset_free(&rsp->obj.msgmask);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_debug_set_req_free(struct ethtool_debug_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tethtool_bitset_free(&req->msgmask);\n\tfree(req);\n}\n\nint ethtool_debug_set(struct ynl_sock *ys, struct ethtool_debug_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_DEBUG_SET, 1);\n\tys->req_policy = &ethtool_debug_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_DEBUG_HEADER, &req->header);\n\tif (req->_present.msgmask)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_DEBUG_MSGMASK, &req->msgmask);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_wol_get_req_free(struct ethtool_wol_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_wol_get_rsp_free(struct ethtool_wol_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_bitset_free(&rsp->modes);\n\tfree(rsp->sopass);\n\tfree(rsp);\n}\n\nint ethtool_wol_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct ethtool_wol_get_rsp *dst;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_WOL_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_WOL_MODES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.modes = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->modes;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_WOL_SOPASS) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = mnl_attr_get_payload_len(attr);\n\t\t\tdst->_present.sopass_len = len;\n\t\t\tdst->sopass = malloc(len);\n\t\t\tmemcpy(dst->sopass, mnl_attr_get_payload(attr), len);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_wol_get_rsp *\nethtool_wol_get(struct ynl_sock *ys, struct ethtool_wol_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_wol_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_WOL_GET, 1);\n\tys->req_policy = &ethtool_wol_nest;\n\tyrs.yarg.rsp_policy = &ethtool_wol_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_WOL_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_wol_get_rsp_parse;\n\tyrs.rsp_cmd = ETHTOOL_MSG_WOL_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_wol_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_wol_get_list_free(struct ethtool_wol_get_list *rsp)\n{\n\tstruct ethtool_wol_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_bitset_free(&rsp->obj.modes);\n\t\tfree(rsp->obj.sopass);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_wol_get_list *\nethtool_wol_get_dump(struct ynl_sock *ys, struct ethtool_wol_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_wol_get_list);\n\tyds.cb = ethtool_wol_get_rsp_parse;\n\tyds.rsp_cmd = ETHTOOL_MSG_WOL_GET;\n\tyds.rsp_policy = &ethtool_wol_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_WOL_GET, 1);\n\tys->req_policy = &ethtool_wol_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_WOL_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_wol_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_wol_get_ntf_free(struct ethtool_wol_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tethtool_bitset_free(&rsp->obj.modes);\n\tfree(rsp->obj.sopass);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_wol_set_req_free(struct ethtool_wol_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tethtool_bitset_free(&req->modes);\n\tfree(req->sopass);\n\tfree(req);\n}\n\nint ethtool_wol_set(struct ynl_sock *ys, struct ethtool_wol_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_WOL_SET, 1);\n\tys->req_policy = &ethtool_wol_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_WOL_HEADER, &req->header);\n\tif (req->_present.modes)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_WOL_MODES, &req->modes);\n\tif (req->_present.sopass_len)\n\t\tmnl_attr_put(nlh, ETHTOOL_A_WOL_SOPASS, req->_present.sopass_len, req->sopass);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_features_get_req_free(struct ethtool_features_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_features_get_rsp_free(struct ethtool_features_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_bitset_free(&rsp->hw);\n\tethtool_bitset_free(&rsp->wanted);\n\tethtool_bitset_free(&rsp->active);\n\tethtool_bitset_free(&rsp->nochange);\n\tfree(rsp);\n}\n\nint ethtool_features_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_features_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_FEATURES_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_FEATURES_HW) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.hw = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->hw;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_FEATURES_WANTED) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.wanted = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->wanted;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_FEATURES_ACTIVE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.active = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->active;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_FEATURES_NOCHANGE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.nochange = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->nochange;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_features_get_rsp *\nethtool_features_get(struct ynl_sock *ys, struct ethtool_features_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_features_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_FEATURES_GET, 1);\n\tys->req_policy = &ethtool_features_nest;\n\tyrs.yarg.rsp_policy = &ethtool_features_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_FEATURES_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_features_get_rsp_parse;\n\tyrs.rsp_cmd = ETHTOOL_MSG_FEATURES_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_features_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_features_get_list_free(struct ethtool_features_get_list *rsp)\n{\n\tstruct ethtool_features_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_bitset_free(&rsp->obj.hw);\n\t\tethtool_bitset_free(&rsp->obj.wanted);\n\t\tethtool_bitset_free(&rsp->obj.active);\n\t\tethtool_bitset_free(&rsp->obj.nochange);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_features_get_list *\nethtool_features_get_dump(struct ynl_sock *ys,\n\t\t\t  struct ethtool_features_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_features_get_list);\n\tyds.cb = ethtool_features_get_rsp_parse;\n\tyds.rsp_cmd = ETHTOOL_MSG_FEATURES_GET;\n\tyds.rsp_policy = &ethtool_features_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_FEATURES_GET, 1);\n\tys->req_policy = &ethtool_features_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_FEATURES_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_features_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_features_get_ntf_free(struct ethtool_features_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tethtool_bitset_free(&rsp->obj.hw);\n\tethtool_bitset_free(&rsp->obj.wanted);\n\tethtool_bitset_free(&rsp->obj.active);\n\tethtool_bitset_free(&rsp->obj.nochange);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_features_set_req_free(struct ethtool_features_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tethtool_bitset_free(&req->hw);\n\tethtool_bitset_free(&req->wanted);\n\tethtool_bitset_free(&req->active);\n\tethtool_bitset_free(&req->nochange);\n\tfree(req);\n}\n\nvoid ethtool_features_set_rsp_free(struct ethtool_features_set_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_bitset_free(&rsp->hw);\n\tethtool_bitset_free(&rsp->wanted);\n\tethtool_bitset_free(&rsp->active);\n\tethtool_bitset_free(&rsp->nochange);\n\tfree(rsp);\n}\n\nint ethtool_features_set_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_features_set_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_FEATURES_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_FEATURES_HW) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.hw = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->hw;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_FEATURES_WANTED) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.wanted = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->wanted;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_FEATURES_ACTIVE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.active = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->active;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_FEATURES_NOCHANGE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.nochange = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->nochange;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_features_set_rsp *\nethtool_features_set(struct ynl_sock *ys, struct ethtool_features_set_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_features_set_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_FEATURES_SET, 1);\n\tys->req_policy = &ethtool_features_nest;\n\tyrs.yarg.rsp_policy = &ethtool_features_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_FEATURES_HEADER, &req->header);\n\tif (req->_present.hw)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_FEATURES_HW, &req->hw);\n\tif (req->_present.wanted)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_FEATURES_WANTED, &req->wanted);\n\tif (req->_present.active)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_FEATURES_ACTIVE, &req->active);\n\tif (req->_present.nochange)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_FEATURES_NOCHANGE, &req->nochange);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_features_set_rsp_parse;\n\tyrs.rsp_cmd = ETHTOOL_MSG_FEATURES_SET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_features_set_rsp_free(rsp);\n\treturn NULL;\n}\n\n \n \nvoid ethtool_privflags_get_req_free(struct ethtool_privflags_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_privflags_get_rsp_free(struct ethtool_privflags_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_bitset_free(&rsp->flags);\n\tfree(rsp);\n}\n\nint ethtool_privflags_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_privflags_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_PRIVFLAGS_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_PRIVFLAGS_FLAGS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.flags = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->flags;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_privflags_get_rsp *\nethtool_privflags_get(struct ynl_sock *ys,\n\t\t      struct ethtool_privflags_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_privflags_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_PRIVFLAGS_GET, 1);\n\tys->req_policy = &ethtool_privflags_nest;\n\tyrs.yarg.rsp_policy = &ethtool_privflags_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PRIVFLAGS_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_privflags_get_rsp_parse;\n\tyrs.rsp_cmd = 14;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_privflags_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_privflags_get_list_free(struct ethtool_privflags_get_list *rsp)\n{\n\tstruct ethtool_privflags_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_bitset_free(&rsp->obj.flags);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_privflags_get_list *\nethtool_privflags_get_dump(struct ynl_sock *ys,\n\t\t\t   struct ethtool_privflags_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_privflags_get_list);\n\tyds.cb = ethtool_privflags_get_rsp_parse;\n\tyds.rsp_cmd = 14;\n\tyds.rsp_policy = &ethtool_privflags_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_PRIVFLAGS_GET, 1);\n\tys->req_policy = &ethtool_privflags_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PRIVFLAGS_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_privflags_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_privflags_get_ntf_free(struct ethtool_privflags_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tethtool_bitset_free(&rsp->obj.flags);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_privflags_set_req_free(struct ethtool_privflags_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tethtool_bitset_free(&req->flags);\n\tfree(req);\n}\n\nint ethtool_privflags_set(struct ynl_sock *ys,\n\t\t\t  struct ethtool_privflags_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_PRIVFLAGS_SET, 1);\n\tys->req_policy = &ethtool_privflags_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PRIVFLAGS_HEADER, &req->header);\n\tif (req->_present.flags)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_PRIVFLAGS_FLAGS, &req->flags);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_rings_get_req_free(struct ethtool_rings_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_rings_get_rsp_free(struct ethtool_rings_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp);\n}\n\nint ethtool_rings_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_rings_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_RINGS_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_RINGS_RX_MAX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_max = 1;\n\t\t\tdst->rx_max = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_RX_MINI_MAX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_mini_max = 1;\n\t\t\tdst->rx_mini_max = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_RX_JUMBO_MAX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_jumbo_max = 1;\n\t\t\tdst->rx_jumbo_max = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_TX_MAX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_max = 1;\n\t\t\tdst->tx_max = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_RX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx = 1;\n\t\t\tdst->rx = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_RX_MINI) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_mini = 1;\n\t\t\tdst->rx_mini = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_RX_JUMBO) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_jumbo = 1;\n\t\t\tdst->rx_jumbo = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_TX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx = 1;\n\t\t\tdst->tx = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_RX_BUF_LEN) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_buf_len = 1;\n\t\t\tdst->rx_buf_len = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_TCP_DATA_SPLIT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tcp_data_split = 1;\n\t\t\tdst->tcp_data_split = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_CQE_SIZE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.cqe_size = 1;\n\t\t\tdst->cqe_size = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_TX_PUSH) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_push = 1;\n\t\t\tdst->tx_push = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_RX_PUSH) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_push = 1;\n\t\t\tdst->rx_push = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_push_buf_len = 1;\n\t\t\tdst->tx_push_buf_len = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN_MAX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_push_buf_len_max = 1;\n\t\t\tdst->tx_push_buf_len_max = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_rings_get_rsp *\nethtool_rings_get(struct ynl_sock *ys, struct ethtool_rings_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_rings_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_RINGS_GET, 1);\n\tys->req_policy = &ethtool_rings_nest;\n\tyrs.yarg.rsp_policy = &ethtool_rings_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_RINGS_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_rings_get_rsp_parse;\n\tyrs.rsp_cmd = 16;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_rings_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_rings_get_list_free(struct ethtool_rings_get_list *rsp)\n{\n\tstruct ethtool_rings_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_rings_get_list *\nethtool_rings_get_dump(struct ynl_sock *ys,\n\t\t       struct ethtool_rings_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_rings_get_list);\n\tyds.cb = ethtool_rings_get_rsp_parse;\n\tyds.rsp_cmd = 16;\n\tyds.rsp_policy = &ethtool_rings_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_RINGS_GET, 1);\n\tys->req_policy = &ethtool_rings_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_RINGS_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_rings_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_rings_get_ntf_free(struct ethtool_rings_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_rings_set_req_free(struct ethtool_rings_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nint ethtool_rings_set(struct ynl_sock *ys, struct ethtool_rings_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_RINGS_SET, 1);\n\tys->req_policy = &ethtool_rings_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_RINGS_HEADER, &req->header);\n\tif (req->_present.rx_max)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_RX_MAX, req->rx_max);\n\tif (req->_present.rx_mini_max)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_RX_MINI_MAX, req->rx_mini_max);\n\tif (req->_present.rx_jumbo_max)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_RX_JUMBO_MAX, req->rx_jumbo_max);\n\tif (req->_present.tx_max)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_TX_MAX, req->tx_max);\n\tif (req->_present.rx)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_RX, req->rx);\n\tif (req->_present.rx_mini)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_RX_MINI, req->rx_mini);\n\tif (req->_present.rx_jumbo)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_RX_JUMBO, req->rx_jumbo);\n\tif (req->_present.tx)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_TX, req->tx);\n\tif (req->_present.rx_buf_len)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_RX_BUF_LEN, req->rx_buf_len);\n\tif (req->_present.tcp_data_split)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_RINGS_TCP_DATA_SPLIT, req->tcp_data_split);\n\tif (req->_present.cqe_size)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_CQE_SIZE, req->cqe_size);\n\tif (req->_present.tx_push)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_RINGS_TX_PUSH, req->tx_push);\n\tif (req->_present.rx_push)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_RINGS_RX_PUSH, req->rx_push);\n\tif (req->_present.tx_push_buf_len)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN, req->tx_push_buf_len);\n\tif (req->_present.tx_push_buf_len_max)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN_MAX, req->tx_push_buf_len_max);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_channels_get_req_free(struct ethtool_channels_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_channels_get_rsp_free(struct ethtool_channels_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp);\n}\n\nint ethtool_channels_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_channels_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_CHANNELS_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_CHANNELS_RX_MAX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_max = 1;\n\t\t\tdst->rx_max = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_CHANNELS_TX_MAX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_max = 1;\n\t\t\tdst->tx_max = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_CHANNELS_OTHER_MAX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.other_max = 1;\n\t\t\tdst->other_max = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_CHANNELS_COMBINED_MAX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.combined_max = 1;\n\t\t\tdst->combined_max = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_CHANNELS_RX_COUNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_count = 1;\n\t\t\tdst->rx_count = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_CHANNELS_TX_COUNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_count = 1;\n\t\t\tdst->tx_count = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_CHANNELS_OTHER_COUNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.other_count = 1;\n\t\t\tdst->other_count = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_CHANNELS_COMBINED_COUNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.combined_count = 1;\n\t\t\tdst->combined_count = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_channels_get_rsp *\nethtool_channels_get(struct ynl_sock *ys, struct ethtool_channels_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_channels_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_CHANNELS_GET, 1);\n\tys->req_policy = &ethtool_channels_nest;\n\tyrs.yarg.rsp_policy = &ethtool_channels_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_CHANNELS_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_channels_get_rsp_parse;\n\tyrs.rsp_cmd = 18;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_channels_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_channels_get_list_free(struct ethtool_channels_get_list *rsp)\n{\n\tstruct ethtool_channels_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_channels_get_list *\nethtool_channels_get_dump(struct ynl_sock *ys,\n\t\t\t  struct ethtool_channels_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_channels_get_list);\n\tyds.cb = ethtool_channels_get_rsp_parse;\n\tyds.rsp_cmd = 18;\n\tyds.rsp_policy = &ethtool_channels_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_CHANNELS_GET, 1);\n\tys->req_policy = &ethtool_channels_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_CHANNELS_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_channels_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_channels_get_ntf_free(struct ethtool_channels_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_channels_set_req_free(struct ethtool_channels_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nint ethtool_channels_set(struct ynl_sock *ys,\n\t\t\t struct ethtool_channels_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_CHANNELS_SET, 1);\n\tys->req_policy = &ethtool_channels_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_CHANNELS_HEADER, &req->header);\n\tif (req->_present.rx_max)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_CHANNELS_RX_MAX, req->rx_max);\n\tif (req->_present.tx_max)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_CHANNELS_TX_MAX, req->tx_max);\n\tif (req->_present.other_max)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_CHANNELS_OTHER_MAX, req->other_max);\n\tif (req->_present.combined_max)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_CHANNELS_COMBINED_MAX, req->combined_max);\n\tif (req->_present.rx_count)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_CHANNELS_RX_COUNT, req->rx_count);\n\tif (req->_present.tx_count)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_CHANNELS_TX_COUNT, req->tx_count);\n\tif (req->_present.other_count)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_CHANNELS_OTHER_COUNT, req->other_count);\n\tif (req->_present.combined_count)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_CHANNELS_COMBINED_COUNT, req->combined_count);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_coalesce_get_req_free(struct ethtool_coalesce_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_coalesce_get_rsp_free(struct ethtool_coalesce_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp);\n}\n\nint ethtool_coalesce_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_coalesce_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_COALESCE_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_COALESCE_RX_USECS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_usecs = 1;\n\t\t\tdst->rx_usecs = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_RX_MAX_FRAMES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_max_frames = 1;\n\t\t\tdst->rx_max_frames = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_RX_USECS_IRQ) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_usecs_irq = 1;\n\t\t\tdst->rx_usecs_irq = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_max_frames_irq = 1;\n\t\t\tdst->rx_max_frames_irq = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_TX_USECS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_usecs = 1;\n\t\t\tdst->tx_usecs = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_TX_MAX_FRAMES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_max_frames = 1;\n\t\t\tdst->tx_max_frames = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_TX_USECS_IRQ) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_usecs_irq = 1;\n\t\t\tdst->tx_usecs_irq = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_max_frames_irq = 1;\n\t\t\tdst->tx_max_frames_irq = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_STATS_BLOCK_USECS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.stats_block_usecs = 1;\n\t\t\tdst->stats_block_usecs = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.use_adaptive_rx = 1;\n\t\t\tdst->use_adaptive_rx = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.use_adaptive_tx = 1;\n\t\t\tdst->use_adaptive_tx = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_PKT_RATE_LOW) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.pkt_rate_low = 1;\n\t\t\tdst->pkt_rate_low = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_RX_USECS_LOW) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_usecs_low = 1;\n\t\t\tdst->rx_usecs_low = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_max_frames_low = 1;\n\t\t\tdst->rx_max_frames_low = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_TX_USECS_LOW) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_usecs_low = 1;\n\t\t\tdst->tx_usecs_low = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_max_frames_low = 1;\n\t\t\tdst->tx_max_frames_low = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_PKT_RATE_HIGH) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.pkt_rate_high = 1;\n\t\t\tdst->pkt_rate_high = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_RX_USECS_HIGH) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_usecs_high = 1;\n\t\t\tdst->rx_usecs_high = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_max_frames_high = 1;\n\t\t\tdst->rx_max_frames_high = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_TX_USECS_HIGH) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_usecs_high = 1;\n\t\t\tdst->tx_usecs_high = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_max_frames_high = 1;\n\t\t\tdst->tx_max_frames_high = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rate_sample_interval = 1;\n\t\t\tdst->rate_sample_interval = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_USE_CQE_MODE_TX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.use_cqe_mode_tx = 1;\n\t\t\tdst->use_cqe_mode_tx = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_USE_CQE_MODE_RX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.use_cqe_mode_rx = 1;\n\t\t\tdst->use_cqe_mode_rx = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_TX_AGGR_MAX_BYTES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_aggr_max_bytes = 1;\n\t\t\tdst->tx_aggr_max_bytes = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_TX_AGGR_MAX_FRAMES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_aggr_max_frames = 1;\n\t\t\tdst->tx_aggr_max_frames = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_COALESCE_TX_AGGR_TIME_USECS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_aggr_time_usecs = 1;\n\t\t\tdst->tx_aggr_time_usecs = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_coalesce_get_rsp *\nethtool_coalesce_get(struct ynl_sock *ys, struct ethtool_coalesce_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_coalesce_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_COALESCE_GET, 1);\n\tys->req_policy = &ethtool_coalesce_nest;\n\tyrs.yarg.rsp_policy = &ethtool_coalesce_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_COALESCE_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_coalesce_get_rsp_parse;\n\tyrs.rsp_cmd = 20;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_coalesce_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_coalesce_get_list_free(struct ethtool_coalesce_get_list *rsp)\n{\n\tstruct ethtool_coalesce_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_coalesce_get_list *\nethtool_coalesce_get_dump(struct ynl_sock *ys,\n\t\t\t  struct ethtool_coalesce_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_coalesce_get_list);\n\tyds.cb = ethtool_coalesce_get_rsp_parse;\n\tyds.rsp_cmd = 20;\n\tyds.rsp_policy = &ethtool_coalesce_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_COALESCE_GET, 1);\n\tys->req_policy = &ethtool_coalesce_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_COALESCE_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_coalesce_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_coalesce_get_ntf_free(struct ethtool_coalesce_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_coalesce_set_req_free(struct ethtool_coalesce_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nint ethtool_coalesce_set(struct ynl_sock *ys,\n\t\t\t struct ethtool_coalesce_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_COALESCE_SET, 1);\n\tys->req_policy = &ethtool_coalesce_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_COALESCE_HEADER, &req->header);\n\tif (req->_present.rx_usecs)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_RX_USECS, req->rx_usecs);\n\tif (req->_present.rx_max_frames)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_RX_MAX_FRAMES, req->rx_max_frames);\n\tif (req->_present.rx_usecs_irq)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_RX_USECS_IRQ, req->rx_usecs_irq);\n\tif (req->_present.rx_max_frames_irq)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ, req->rx_max_frames_irq);\n\tif (req->_present.tx_usecs)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_TX_USECS, req->tx_usecs);\n\tif (req->_present.tx_max_frames)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_TX_MAX_FRAMES, req->tx_max_frames);\n\tif (req->_present.tx_usecs_irq)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_TX_USECS_IRQ, req->tx_usecs_irq);\n\tif (req->_present.tx_max_frames_irq)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ, req->tx_max_frames_irq);\n\tif (req->_present.stats_block_usecs)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_STATS_BLOCK_USECS, req->stats_block_usecs);\n\tif (req->_present.use_adaptive_rx)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX, req->use_adaptive_rx);\n\tif (req->_present.use_adaptive_tx)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX, req->use_adaptive_tx);\n\tif (req->_present.pkt_rate_low)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_PKT_RATE_LOW, req->pkt_rate_low);\n\tif (req->_present.rx_usecs_low)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_RX_USECS_LOW, req->rx_usecs_low);\n\tif (req->_present.rx_max_frames_low)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW, req->rx_max_frames_low);\n\tif (req->_present.tx_usecs_low)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_TX_USECS_LOW, req->tx_usecs_low);\n\tif (req->_present.tx_max_frames_low)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW, req->tx_max_frames_low);\n\tif (req->_present.pkt_rate_high)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_PKT_RATE_HIGH, req->pkt_rate_high);\n\tif (req->_present.rx_usecs_high)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_RX_USECS_HIGH, req->rx_usecs_high);\n\tif (req->_present.rx_max_frames_high)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH, req->rx_max_frames_high);\n\tif (req->_present.tx_usecs_high)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_TX_USECS_HIGH, req->tx_usecs_high);\n\tif (req->_present.tx_max_frames_high)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH, req->tx_max_frames_high);\n\tif (req->_present.rate_sample_interval)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL, req->rate_sample_interval);\n\tif (req->_present.use_cqe_mode_tx)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_COALESCE_USE_CQE_MODE_TX, req->use_cqe_mode_tx);\n\tif (req->_present.use_cqe_mode_rx)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_COALESCE_USE_CQE_MODE_RX, req->use_cqe_mode_rx);\n\tif (req->_present.tx_aggr_max_bytes)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_TX_AGGR_MAX_BYTES, req->tx_aggr_max_bytes);\n\tif (req->_present.tx_aggr_max_frames)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_TX_AGGR_MAX_FRAMES, req->tx_aggr_max_frames);\n\tif (req->_present.tx_aggr_time_usecs)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_COALESCE_TX_AGGR_TIME_USECS, req->tx_aggr_time_usecs);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_pause_get_req_free(struct ethtool_pause_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_pause_get_rsp_free(struct ethtool_pause_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_pause_stat_free(&rsp->stats);\n\tfree(rsp);\n}\n\nint ethtool_pause_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_pause_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_PAUSE_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_PAUSE_AUTONEG) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.autoneg = 1;\n\t\t\tdst->autoneg = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_PAUSE_RX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx = 1;\n\t\t\tdst->rx = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_PAUSE_TX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx = 1;\n\t\t\tdst->tx = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_PAUSE_STATS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.stats = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_pause_stat_nest;\n\t\t\tparg.data = &dst->stats;\n\t\t\tif (ethtool_pause_stat_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_PAUSE_STATS_SRC) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.stats_src = 1;\n\t\t\tdst->stats_src = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_pause_get_rsp *\nethtool_pause_get(struct ynl_sock *ys, struct ethtool_pause_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_pause_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_PAUSE_GET, 1);\n\tys->req_policy = &ethtool_pause_nest;\n\tyrs.yarg.rsp_policy = &ethtool_pause_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PAUSE_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_pause_get_rsp_parse;\n\tyrs.rsp_cmd = 22;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_pause_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_pause_get_list_free(struct ethtool_pause_get_list *rsp)\n{\n\tstruct ethtool_pause_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_pause_stat_free(&rsp->obj.stats);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_pause_get_list *\nethtool_pause_get_dump(struct ynl_sock *ys,\n\t\t       struct ethtool_pause_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_pause_get_list);\n\tyds.cb = ethtool_pause_get_rsp_parse;\n\tyds.rsp_cmd = 22;\n\tyds.rsp_policy = &ethtool_pause_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_PAUSE_GET, 1);\n\tys->req_policy = &ethtool_pause_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PAUSE_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_pause_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_pause_get_ntf_free(struct ethtool_pause_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tethtool_pause_stat_free(&rsp->obj.stats);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_pause_set_req_free(struct ethtool_pause_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tethtool_pause_stat_free(&req->stats);\n\tfree(req);\n}\n\nint ethtool_pause_set(struct ynl_sock *ys, struct ethtool_pause_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_PAUSE_SET, 1);\n\tys->req_policy = &ethtool_pause_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PAUSE_HEADER, &req->header);\n\tif (req->_present.autoneg)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_PAUSE_AUTONEG, req->autoneg);\n\tif (req->_present.rx)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_PAUSE_RX, req->rx);\n\tif (req->_present.tx)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_PAUSE_TX, req->tx);\n\tif (req->_present.stats)\n\t\tethtool_pause_stat_put(nlh, ETHTOOL_A_PAUSE_STATS, &req->stats);\n\tif (req->_present.stats_src)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_PAUSE_STATS_SRC, req->stats_src);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_eee_get_req_free(struct ethtool_eee_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_eee_get_rsp_free(struct ethtool_eee_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_bitset_free(&rsp->modes_ours);\n\tethtool_bitset_free(&rsp->modes_peer);\n\tfree(rsp);\n}\n\nint ethtool_eee_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct ethtool_eee_get_rsp *dst;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_EEE_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_EEE_MODES_OURS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.modes_ours = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->modes_ours;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_EEE_MODES_PEER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.modes_peer = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->modes_peer;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_EEE_ACTIVE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.active = 1;\n\t\t\tdst->active = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_EEE_ENABLED) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.enabled = 1;\n\t\t\tdst->enabled = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_EEE_TX_LPI_ENABLED) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_lpi_enabled = 1;\n\t\t\tdst->tx_lpi_enabled = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_EEE_TX_LPI_TIMER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_lpi_timer = 1;\n\t\t\tdst->tx_lpi_timer = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_eee_get_rsp *\nethtool_eee_get(struct ynl_sock *ys, struct ethtool_eee_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_eee_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_EEE_GET, 1);\n\tys->req_policy = &ethtool_eee_nest;\n\tyrs.yarg.rsp_policy = &ethtool_eee_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_EEE_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_eee_get_rsp_parse;\n\tyrs.rsp_cmd = 24;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_eee_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_eee_get_list_free(struct ethtool_eee_get_list *rsp)\n{\n\tstruct ethtool_eee_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_bitset_free(&rsp->obj.modes_ours);\n\t\tethtool_bitset_free(&rsp->obj.modes_peer);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_eee_get_list *\nethtool_eee_get_dump(struct ynl_sock *ys, struct ethtool_eee_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_eee_get_list);\n\tyds.cb = ethtool_eee_get_rsp_parse;\n\tyds.rsp_cmd = 24;\n\tyds.rsp_policy = &ethtool_eee_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_EEE_GET, 1);\n\tys->req_policy = &ethtool_eee_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_EEE_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_eee_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_eee_get_ntf_free(struct ethtool_eee_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tethtool_bitset_free(&rsp->obj.modes_ours);\n\tethtool_bitset_free(&rsp->obj.modes_peer);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_eee_set_req_free(struct ethtool_eee_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tethtool_bitset_free(&req->modes_ours);\n\tethtool_bitset_free(&req->modes_peer);\n\tfree(req);\n}\n\nint ethtool_eee_set(struct ynl_sock *ys, struct ethtool_eee_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_EEE_SET, 1);\n\tys->req_policy = &ethtool_eee_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_EEE_HEADER, &req->header);\n\tif (req->_present.modes_ours)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_EEE_MODES_OURS, &req->modes_ours);\n\tif (req->_present.modes_peer)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_EEE_MODES_PEER, &req->modes_peer);\n\tif (req->_present.active)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_EEE_ACTIVE, req->active);\n\tif (req->_present.enabled)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_EEE_ENABLED, req->enabled);\n\tif (req->_present.tx_lpi_enabled)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_EEE_TX_LPI_ENABLED, req->tx_lpi_enabled);\n\tif (req->_present.tx_lpi_timer)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_EEE_TX_LPI_TIMER, req->tx_lpi_timer);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_tsinfo_get_req_free(struct ethtool_tsinfo_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_tsinfo_get_rsp_free(struct ethtool_tsinfo_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_bitset_free(&rsp->timestamping);\n\tethtool_bitset_free(&rsp->tx_types);\n\tethtool_bitset_free(&rsp->rx_filters);\n\tfree(rsp);\n}\n\nint ethtool_tsinfo_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_tsinfo_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_TSINFO_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_TSINFO_TIMESTAMPING) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.timestamping = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->timestamping;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_TSINFO_TX_TYPES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_types = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->tx_types;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_TSINFO_RX_FILTERS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_filters = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->rx_filters;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_TSINFO_PHC_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.phc_index = 1;\n\t\t\tdst->phc_index = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_tsinfo_get_rsp *\nethtool_tsinfo_get(struct ynl_sock *ys, struct ethtool_tsinfo_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_tsinfo_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_TSINFO_GET, 1);\n\tys->req_policy = &ethtool_tsinfo_nest;\n\tyrs.yarg.rsp_policy = &ethtool_tsinfo_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_TSINFO_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_tsinfo_get_rsp_parse;\n\tyrs.rsp_cmd = 26;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_tsinfo_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_tsinfo_get_list_free(struct ethtool_tsinfo_get_list *rsp)\n{\n\tstruct ethtool_tsinfo_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_bitset_free(&rsp->obj.timestamping);\n\t\tethtool_bitset_free(&rsp->obj.tx_types);\n\t\tethtool_bitset_free(&rsp->obj.rx_filters);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_tsinfo_get_list *\nethtool_tsinfo_get_dump(struct ynl_sock *ys,\n\t\t\tstruct ethtool_tsinfo_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_tsinfo_get_list);\n\tyds.cb = ethtool_tsinfo_get_rsp_parse;\n\tyds.rsp_cmd = 26;\n\tyds.rsp_policy = &ethtool_tsinfo_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_TSINFO_GET, 1);\n\tys->req_policy = &ethtool_tsinfo_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_TSINFO_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_tsinfo_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid ethtool_cable_test_act_req_free(struct ethtool_cable_test_act_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nint ethtool_cable_test_act(struct ynl_sock *ys,\n\t\t\t   struct ethtool_cable_test_act_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_CABLE_TEST_ACT, 1);\n\tys->req_policy = &ethtool_cable_test_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_CABLE_TEST_HEADER, &req->header);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid\nethtool_cable_test_tdr_act_req_free(struct ethtool_cable_test_tdr_act_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nint ethtool_cable_test_tdr_act(struct ynl_sock *ys,\n\t\t\t       struct ethtool_cable_test_tdr_act_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_CABLE_TEST_TDR_ACT, 1);\n\tys->req_policy = &ethtool_cable_test_tdr_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_CABLE_TEST_TDR_HEADER, &req->header);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_tunnel_info_get_req_free(struct ethtool_tunnel_info_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_tunnel_info_get_rsp_free(struct ethtool_tunnel_info_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_tunnel_udp_free(&rsp->udp_ports);\n\tfree(rsp);\n}\n\nint ethtool_tunnel_info_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_tunnel_info_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_TUNNEL_INFO_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_TUNNEL_INFO_UDP_PORTS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.udp_ports = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_tunnel_udp_nest;\n\t\t\tparg.data = &dst->udp_ports;\n\t\t\tif (ethtool_tunnel_udp_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_tunnel_info_get_rsp *\nethtool_tunnel_info_get(struct ynl_sock *ys,\n\t\t\tstruct ethtool_tunnel_info_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_tunnel_info_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_TUNNEL_INFO_GET, 1);\n\tys->req_policy = &ethtool_tunnel_info_nest;\n\tyrs.yarg.rsp_policy = &ethtool_tunnel_info_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_TUNNEL_INFO_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_tunnel_info_get_rsp_parse;\n\tyrs.rsp_cmd = 29;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_tunnel_info_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid\nethtool_tunnel_info_get_list_free(struct ethtool_tunnel_info_get_list *rsp)\n{\n\tstruct ethtool_tunnel_info_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_tunnel_udp_free(&rsp->obj.udp_ports);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_tunnel_info_get_list *\nethtool_tunnel_info_get_dump(struct ynl_sock *ys,\n\t\t\t     struct ethtool_tunnel_info_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_tunnel_info_get_list);\n\tyds.cb = ethtool_tunnel_info_get_rsp_parse;\n\tyds.rsp_cmd = 29;\n\tyds.rsp_policy = &ethtool_tunnel_info_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_TUNNEL_INFO_GET, 1);\n\tys->req_policy = &ethtool_tunnel_info_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_TUNNEL_INFO_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_tunnel_info_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid ethtool_fec_get_req_free(struct ethtool_fec_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_fec_get_rsp_free(struct ethtool_fec_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_bitset_free(&rsp->modes);\n\tethtool_fec_stat_free(&rsp->stats);\n\tfree(rsp);\n}\n\nint ethtool_fec_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct ethtool_fec_get_rsp *dst;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_FEC_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_FEC_MODES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.modes = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_bitset_nest;\n\t\t\tparg.data = &dst->modes;\n\t\t\tif (ethtool_bitset_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_FEC_AUTO) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.auto_ = 1;\n\t\t\tdst->auto_ = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_FEC_ACTIVE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.active = 1;\n\t\t\tdst->active = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_FEC_STATS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.stats = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_fec_stat_nest;\n\t\t\tparg.data = &dst->stats;\n\t\t\tif (ethtool_fec_stat_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_fec_get_rsp *\nethtool_fec_get(struct ynl_sock *ys, struct ethtool_fec_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_fec_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_FEC_GET, 1);\n\tys->req_policy = &ethtool_fec_nest;\n\tyrs.yarg.rsp_policy = &ethtool_fec_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_FEC_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_fec_get_rsp_parse;\n\tyrs.rsp_cmd = 30;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_fec_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_fec_get_list_free(struct ethtool_fec_get_list *rsp)\n{\n\tstruct ethtool_fec_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_bitset_free(&rsp->obj.modes);\n\t\tethtool_fec_stat_free(&rsp->obj.stats);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_fec_get_list *\nethtool_fec_get_dump(struct ynl_sock *ys, struct ethtool_fec_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_fec_get_list);\n\tyds.cb = ethtool_fec_get_rsp_parse;\n\tyds.rsp_cmd = 30;\n\tyds.rsp_policy = &ethtool_fec_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_FEC_GET, 1);\n\tys->req_policy = &ethtool_fec_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_FEC_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_fec_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_fec_get_ntf_free(struct ethtool_fec_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tethtool_bitset_free(&rsp->obj.modes);\n\tethtool_fec_stat_free(&rsp->obj.stats);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_fec_set_req_free(struct ethtool_fec_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tethtool_bitset_free(&req->modes);\n\tethtool_fec_stat_free(&req->stats);\n\tfree(req);\n}\n\nint ethtool_fec_set(struct ynl_sock *ys, struct ethtool_fec_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_FEC_SET, 1);\n\tys->req_policy = &ethtool_fec_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_FEC_HEADER, &req->header);\n\tif (req->_present.modes)\n\t\tethtool_bitset_put(nlh, ETHTOOL_A_FEC_MODES, &req->modes);\n\tif (req->_present.auto_)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_FEC_AUTO, req->auto_);\n\tif (req->_present.active)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_FEC_ACTIVE, req->active);\n\tif (req->_present.stats)\n\t\tethtool_fec_stat_put(nlh, ETHTOOL_A_FEC_STATS, &req->stats);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid\nethtool_module_eeprom_get_req_free(struct ethtool_module_eeprom_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid\nethtool_module_eeprom_get_rsp_free(struct ethtool_module_eeprom_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp->data);\n\tfree(rsp);\n}\n\nint ethtool_module_eeprom_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_module_eeprom_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_MODULE_EEPROM_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_MODULE_EEPROM_OFFSET) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.offset = 1;\n\t\t\tdst->offset = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_MODULE_EEPROM_LENGTH) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.length = 1;\n\t\t\tdst->length = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_MODULE_EEPROM_PAGE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.page = 1;\n\t\t\tdst->page = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_MODULE_EEPROM_BANK) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.bank = 1;\n\t\t\tdst->bank = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.i2c_address = 1;\n\t\t\tdst->i2c_address = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_MODULE_EEPROM_DATA) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = mnl_attr_get_payload_len(attr);\n\t\t\tdst->_present.data_len = len;\n\t\t\tdst->data = malloc(len);\n\t\t\tmemcpy(dst->data, mnl_attr_get_payload(attr), len);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_module_eeprom_get_rsp *\nethtool_module_eeprom_get(struct ynl_sock *ys,\n\t\t\t  struct ethtool_module_eeprom_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_module_eeprom_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_MODULE_EEPROM_GET, 1);\n\tys->req_policy = &ethtool_module_eeprom_nest;\n\tyrs.yarg.rsp_policy = &ethtool_module_eeprom_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_MODULE_EEPROM_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_module_eeprom_get_rsp_parse;\n\tyrs.rsp_cmd = 32;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_module_eeprom_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid\nethtool_module_eeprom_get_list_free(struct ethtool_module_eeprom_get_list *rsp)\n{\n\tstruct ethtool_module_eeprom_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp->obj.data);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_module_eeprom_get_list *\nethtool_module_eeprom_get_dump(struct ynl_sock *ys,\n\t\t\t       struct ethtool_module_eeprom_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_module_eeprom_get_list);\n\tyds.cb = ethtool_module_eeprom_get_rsp_parse;\n\tyds.rsp_cmd = 32;\n\tyds.rsp_policy = &ethtool_module_eeprom_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_MODULE_EEPROM_GET, 1);\n\tys->req_policy = &ethtool_module_eeprom_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_MODULE_EEPROM_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_module_eeprom_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid ethtool_phc_vclocks_get_req_free(struct ethtool_phc_vclocks_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_phc_vclocks_get_rsp_free(struct ethtool_phc_vclocks_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp);\n}\n\nint ethtool_phc_vclocks_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_phc_vclocks_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_PHC_VCLOCKS_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_PHC_VCLOCKS_NUM) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.num = 1;\n\t\t\tdst->num = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_phc_vclocks_get_rsp *\nethtool_phc_vclocks_get(struct ynl_sock *ys,\n\t\t\tstruct ethtool_phc_vclocks_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_phc_vclocks_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_PHC_VCLOCKS_GET, 1);\n\tys->req_policy = &ethtool_phc_vclocks_nest;\n\tyrs.yarg.rsp_policy = &ethtool_phc_vclocks_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PHC_VCLOCKS_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_phc_vclocks_get_rsp_parse;\n\tyrs.rsp_cmd = 34;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_phc_vclocks_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid\nethtool_phc_vclocks_get_list_free(struct ethtool_phc_vclocks_get_list *rsp)\n{\n\tstruct ethtool_phc_vclocks_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_phc_vclocks_get_list *\nethtool_phc_vclocks_get_dump(struct ynl_sock *ys,\n\t\t\t     struct ethtool_phc_vclocks_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_phc_vclocks_get_list);\n\tyds.cb = ethtool_phc_vclocks_get_rsp_parse;\n\tyds.rsp_cmd = 34;\n\tyds.rsp_policy = &ethtool_phc_vclocks_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_PHC_VCLOCKS_GET, 1);\n\tys->req_policy = &ethtool_phc_vclocks_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PHC_VCLOCKS_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_phc_vclocks_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid ethtool_module_get_req_free(struct ethtool_module_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_module_get_rsp_free(struct ethtool_module_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp);\n}\n\nint ethtool_module_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_module_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_MODULE_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_MODULE_POWER_MODE_POLICY) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.power_mode_policy = 1;\n\t\t\tdst->power_mode_policy = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_MODULE_POWER_MODE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.power_mode = 1;\n\t\t\tdst->power_mode = mnl_attr_get_u8(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_module_get_rsp *\nethtool_module_get(struct ynl_sock *ys, struct ethtool_module_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_module_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_MODULE_GET, 1);\n\tys->req_policy = &ethtool_module_nest;\n\tyrs.yarg.rsp_policy = &ethtool_module_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_MODULE_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_module_get_rsp_parse;\n\tyrs.rsp_cmd = 35;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_module_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_module_get_list_free(struct ethtool_module_get_list *rsp)\n{\n\tstruct ethtool_module_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_module_get_list *\nethtool_module_get_dump(struct ynl_sock *ys,\n\t\t\tstruct ethtool_module_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_module_get_list);\n\tyds.cb = ethtool_module_get_rsp_parse;\n\tyds.rsp_cmd = 35;\n\tyds.rsp_policy = &ethtool_module_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_MODULE_GET, 1);\n\tys->req_policy = &ethtool_module_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_MODULE_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_module_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_module_get_ntf_free(struct ethtool_module_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_module_set_req_free(struct ethtool_module_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nint ethtool_module_set(struct ynl_sock *ys, struct ethtool_module_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_MODULE_SET, 1);\n\tys->req_policy = &ethtool_module_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_MODULE_HEADER, &req->header);\n\tif (req->_present.power_mode_policy)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_MODULE_POWER_MODE_POLICY, req->power_mode_policy);\n\tif (req->_present.power_mode)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_MODULE_POWER_MODE, req->power_mode);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_pse_get_req_free(struct ethtool_pse_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_pse_get_rsp_free(struct ethtool_pse_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp);\n}\n\nint ethtool_pse_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct ethtool_pse_get_rsp *dst;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_PSE_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_PODL_PSE_ADMIN_STATE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.admin_state = 1;\n\t\t\tdst->admin_state = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_PODL_PSE_ADMIN_CONTROL) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.admin_control = 1;\n\t\t\tdst->admin_control = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_PODL_PSE_PW_D_STATUS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.pw_d_status = 1;\n\t\t\tdst->pw_d_status = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_pse_get_rsp *\nethtool_pse_get(struct ynl_sock *ys, struct ethtool_pse_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_pse_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_PSE_GET, 1);\n\tys->req_policy = &ethtool_pse_nest;\n\tyrs.yarg.rsp_policy = &ethtool_pse_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PSE_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_pse_get_rsp_parse;\n\tyrs.rsp_cmd = 37;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_pse_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_pse_get_list_free(struct ethtool_pse_get_list *rsp)\n{\n\tstruct ethtool_pse_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_pse_get_list *\nethtool_pse_get_dump(struct ynl_sock *ys, struct ethtool_pse_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_pse_get_list);\n\tyds.cb = ethtool_pse_get_rsp_parse;\n\tyds.rsp_cmd = 37;\n\tyds.rsp_policy = &ethtool_pse_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_PSE_GET, 1);\n\tys->req_policy = &ethtool_pse_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PSE_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_pse_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid ethtool_pse_set_req_free(struct ethtool_pse_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nint ethtool_pse_set(struct ynl_sock *ys, struct ethtool_pse_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_PSE_SET, 1);\n\tys->req_policy = &ethtool_pse_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PSE_HEADER, &req->header);\n\tif (req->_present.admin_state)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_PODL_PSE_ADMIN_STATE, req->admin_state);\n\tif (req->_present.admin_control)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_PODL_PSE_ADMIN_CONTROL, req->admin_control);\n\tif (req->_present.pw_d_status)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_PODL_PSE_PW_D_STATUS, req->pw_d_status);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_rss_get_req_free(struct ethtool_rss_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_rss_get_rsp_free(struct ethtool_rss_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp->indir);\n\tfree(rsp->hkey);\n\tfree(rsp);\n}\n\nint ethtool_rss_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct ethtool_rss_get_rsp *dst;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_RSS_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_RSS_CONTEXT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.context = 1;\n\t\t\tdst->context = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RSS_HFUNC) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.hfunc = 1;\n\t\t\tdst->hfunc = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_RSS_INDIR) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = mnl_attr_get_payload_len(attr);\n\t\t\tdst->_present.indir_len = len;\n\t\t\tdst->indir = malloc(len);\n\t\t\tmemcpy(dst->indir, mnl_attr_get_payload(attr), len);\n\t\t} else if (type == ETHTOOL_A_RSS_HKEY) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = mnl_attr_get_payload_len(attr);\n\t\t\tdst->_present.hkey_len = len;\n\t\t\tdst->hkey = malloc(len);\n\t\t\tmemcpy(dst->hkey, mnl_attr_get_payload(attr), len);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_rss_get_rsp *\nethtool_rss_get(struct ynl_sock *ys, struct ethtool_rss_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_rss_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_RSS_GET, 1);\n\tys->req_policy = &ethtool_rss_nest;\n\tyrs.yarg.rsp_policy = &ethtool_rss_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_RSS_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_rss_get_rsp_parse;\n\tyrs.rsp_cmd = ETHTOOL_MSG_RSS_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_rss_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_rss_get_list_free(struct ethtool_rss_get_list *rsp)\n{\n\tstruct ethtool_rss_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp->obj.indir);\n\t\tfree(rsp->obj.hkey);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_rss_get_list *\nethtool_rss_get_dump(struct ynl_sock *ys, struct ethtool_rss_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_rss_get_list);\n\tyds.cb = ethtool_rss_get_rsp_parse;\n\tyds.rsp_cmd = ETHTOOL_MSG_RSS_GET;\n\tyds.rsp_policy = &ethtool_rss_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_RSS_GET, 1);\n\tys->req_policy = &ethtool_rss_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_RSS_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_rss_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid ethtool_plca_get_cfg_req_free(struct ethtool_plca_get_cfg_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_plca_get_cfg_rsp_free(struct ethtool_plca_get_cfg_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp);\n}\n\nint ethtool_plca_get_cfg_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_plca_get_cfg_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_PLCA_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_PLCA_VERSION) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.version = 1;\n\t\t\tdst->version = mnl_attr_get_u16(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_ENABLED) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.enabled = 1;\n\t\t\tdst->enabled = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_STATUS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.status = 1;\n\t\t\tdst->status = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_NODE_CNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.node_cnt = 1;\n\t\t\tdst->node_cnt = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_NODE_ID) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.node_id = 1;\n\t\t\tdst->node_id = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_TO_TMR) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.to_tmr = 1;\n\t\t\tdst->to_tmr = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_BURST_CNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.burst_cnt = 1;\n\t\t\tdst->burst_cnt = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_BURST_TMR) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.burst_tmr = 1;\n\t\t\tdst->burst_tmr = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_plca_get_cfg_rsp *\nethtool_plca_get_cfg(struct ynl_sock *ys, struct ethtool_plca_get_cfg_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_plca_get_cfg_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_PLCA_GET_CFG, 1);\n\tys->req_policy = &ethtool_plca_nest;\n\tyrs.yarg.rsp_policy = &ethtool_plca_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PLCA_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_plca_get_cfg_rsp_parse;\n\tyrs.rsp_cmd = ETHTOOL_MSG_PLCA_GET_CFG;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_plca_get_cfg_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_plca_get_cfg_list_free(struct ethtool_plca_get_cfg_list *rsp)\n{\n\tstruct ethtool_plca_get_cfg_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_plca_get_cfg_list *\nethtool_plca_get_cfg_dump(struct ynl_sock *ys,\n\t\t\t  struct ethtool_plca_get_cfg_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_plca_get_cfg_list);\n\tyds.cb = ethtool_plca_get_cfg_rsp_parse;\n\tyds.rsp_cmd = ETHTOOL_MSG_PLCA_GET_CFG;\n\tyds.rsp_policy = &ethtool_plca_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_PLCA_GET_CFG, 1);\n\tys->req_policy = &ethtool_plca_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PLCA_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_plca_get_cfg_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_plca_get_cfg_ntf_free(struct ethtool_plca_get_cfg_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_plca_set_cfg_req_free(struct ethtool_plca_set_cfg_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nint ethtool_plca_set_cfg(struct ynl_sock *ys,\n\t\t\t struct ethtool_plca_set_cfg_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_PLCA_SET_CFG, 1);\n\tys->req_policy = &ethtool_plca_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PLCA_HEADER, &req->header);\n\tif (req->_present.version)\n\t\tmnl_attr_put_u16(nlh, ETHTOOL_A_PLCA_VERSION, req->version);\n\tif (req->_present.enabled)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_PLCA_ENABLED, req->enabled);\n\tif (req->_present.status)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_PLCA_STATUS, req->status);\n\tif (req->_present.node_cnt)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_PLCA_NODE_CNT, req->node_cnt);\n\tif (req->_present.node_id)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_PLCA_NODE_ID, req->node_id);\n\tif (req->_present.to_tmr)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_PLCA_TO_TMR, req->to_tmr);\n\tif (req->_present.burst_cnt)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_PLCA_BURST_CNT, req->burst_cnt);\n\tif (req->_present.burst_tmr)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_PLCA_BURST_TMR, req->burst_tmr);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid ethtool_plca_get_status_req_free(struct ethtool_plca_get_status_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_plca_get_status_rsp_free(struct ethtool_plca_get_status_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tfree(rsp);\n}\n\nint ethtool_plca_get_status_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_plca_get_status_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_PLCA_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_PLCA_VERSION) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.version = 1;\n\t\t\tdst->version = mnl_attr_get_u16(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_ENABLED) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.enabled = 1;\n\t\t\tdst->enabled = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_STATUS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.status = 1;\n\t\t\tdst->status = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_NODE_CNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.node_cnt = 1;\n\t\t\tdst->node_cnt = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_NODE_ID) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.node_id = 1;\n\t\t\tdst->node_id = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_TO_TMR) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.to_tmr = 1;\n\t\t\tdst->to_tmr = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_BURST_CNT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.burst_cnt = 1;\n\t\t\tdst->burst_cnt = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_PLCA_BURST_TMR) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.burst_tmr = 1;\n\t\t\tdst->burst_tmr = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_plca_get_status_rsp *\nethtool_plca_get_status(struct ynl_sock *ys,\n\t\t\tstruct ethtool_plca_get_status_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_plca_get_status_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_PLCA_GET_STATUS, 1);\n\tys->req_policy = &ethtool_plca_nest;\n\tyrs.yarg.rsp_policy = &ethtool_plca_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PLCA_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_plca_get_status_rsp_parse;\n\tyrs.rsp_cmd = 40;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_plca_get_status_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid\nethtool_plca_get_status_list_free(struct ethtool_plca_get_status_list *rsp)\n{\n\tstruct ethtool_plca_get_status_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_plca_get_status_list *\nethtool_plca_get_status_dump(struct ynl_sock *ys,\n\t\t\t     struct ethtool_plca_get_status_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_plca_get_status_list);\n\tyds.cb = ethtool_plca_get_status_rsp_parse;\n\tyds.rsp_cmd = 40;\n\tyds.rsp_policy = &ethtool_plca_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_PLCA_GET_STATUS, 1);\n\tys->req_policy = &ethtool_plca_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_PLCA_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_plca_get_status_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid ethtool_mm_get_req_free(struct ethtool_mm_get_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nvoid ethtool_mm_get_rsp_free(struct ethtool_mm_get_rsp *rsp)\n{\n\tethtool_header_free(&rsp->header);\n\tethtool_mm_stat_free(&rsp->stats);\n\tfree(rsp);\n}\n\nint ethtool_mm_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct ethtool_mm_get_rsp *dst;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_MM_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_MM_PMAC_ENABLED) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.pmac_enabled = 1;\n\t\t\tdst->pmac_enabled = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_MM_TX_ENABLED) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_enabled = 1;\n\t\t\tdst->tx_enabled = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_MM_TX_ACTIVE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_active = 1;\n\t\t\tdst->tx_active = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_MM_TX_MIN_FRAG_SIZE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.tx_min_frag_size = 1;\n\t\t\tdst->tx_min_frag_size = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_MM_RX_MIN_FRAG_SIZE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.rx_min_frag_size = 1;\n\t\t\tdst->rx_min_frag_size = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_MM_VERIFY_ENABLED) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.verify_enabled = 1;\n\t\t\tdst->verify_enabled = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_MM_VERIFY_TIME) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.verify_time = 1;\n\t\t\tdst->verify_time = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_MM_MAX_VERIFY_TIME) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.max_verify_time = 1;\n\t\t\tdst->max_verify_time = mnl_attr_get_u32(attr);\n\t\t} else if (type == ETHTOOL_A_MM_STATS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.stats = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_mm_stat_nest;\n\t\t\tparg.data = &dst->stats;\n\t\t\tif (ethtool_mm_stat_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct ethtool_mm_get_rsp *\nethtool_mm_get(struct ynl_sock *ys, struct ethtool_mm_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct ethtool_mm_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_MM_GET, 1);\n\tys->req_policy = &ethtool_mm_nest;\n\tyrs.yarg.rsp_policy = &ethtool_mm_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_MM_HEADER, &req->header);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = ethtool_mm_get_rsp_parse;\n\tyrs.rsp_cmd = ETHTOOL_MSG_MM_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tethtool_mm_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid ethtool_mm_get_list_free(struct ethtool_mm_get_list *rsp)\n{\n\tstruct ethtool_mm_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tethtool_header_free(&rsp->obj.header);\n\t\tethtool_mm_stat_free(&rsp->obj.stats);\n\t\tfree(rsp);\n\t}\n}\n\nstruct ethtool_mm_get_list *\nethtool_mm_get_dump(struct ynl_sock *ys, struct ethtool_mm_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct ethtool_mm_get_list);\n\tyds.cb = ethtool_mm_get_rsp_parse;\n\tyds.rsp_cmd = ETHTOOL_MSG_MM_GET;\n\tyds.rsp_policy = &ethtool_mm_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, ETHTOOL_MSG_MM_GET, 1);\n\tys->req_policy = &ethtool_mm_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_MM_HEADER, &req->header);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tethtool_mm_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid ethtool_mm_get_ntf_free(struct ethtool_mm_get_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tethtool_mm_stat_free(&rsp->obj.stats);\n\tfree(rsp);\n}\n\n \n \nvoid ethtool_mm_set_req_free(struct ethtool_mm_set_req *req)\n{\n\tethtool_header_free(&req->header);\n\tfree(req);\n}\n\nint ethtool_mm_set(struct ynl_sock *ys, struct ethtool_mm_set_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, ETHTOOL_MSG_MM_SET, 1);\n\tys->req_policy = &ethtool_mm_nest;\n\n\tif (req->_present.header)\n\t\tethtool_header_put(nlh, ETHTOOL_A_MM_HEADER, &req->header);\n\tif (req->_present.verify_enabled)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_MM_VERIFY_ENABLED, req->verify_enabled);\n\tif (req->_present.verify_time)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_MM_VERIFY_TIME, req->verify_time);\n\tif (req->_present.tx_enabled)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_MM_TX_ENABLED, req->tx_enabled);\n\tif (req->_present.pmac_enabled)\n\t\tmnl_attr_put_u8(nlh, ETHTOOL_A_MM_PMAC_ENABLED, req->pmac_enabled);\n\tif (req->_present.tx_min_frag_size)\n\t\tmnl_attr_put_u32(nlh, ETHTOOL_A_MM_TX_MIN_FRAG_SIZE, req->tx_min_frag_size);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nint ethtool_cable_test_ntf_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ethtool_cable_test_ntf_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_CABLE_TEST_NTF_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_CABLE_TEST_NTF_STATUS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.status = 1;\n\t\t\tdst->status = mnl_attr_get_u8(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nvoid ethtool_cable_test_ntf_free(struct ethtool_cable_test_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tfree(rsp);\n}\n\n \nint ethtool_cable_test_tdr_ntf_rsp_parse(const struct nlmsghdr *nlh,\n\t\t\t\t\t void *data)\n{\n\tstruct ethtool_cable_test_tdr_ntf_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == ETHTOOL_A_CABLE_TEST_TDR_NTF_HEADER) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.header = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_header_nest;\n\t\t\tparg.data = &dst->header;\n\t\t\tif (ethtool_header_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == ETHTOOL_A_CABLE_TEST_TDR_NTF_STATUS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.status = 1;\n\t\t\tdst->status = mnl_attr_get_u8(attr);\n\t\t} else if (type == ETHTOOL_A_CABLE_TEST_TDR_NTF_NEST) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.nest = 1;\n\n\t\t\tparg.rsp_policy = &ethtool_cable_nest_nest;\n\t\t\tparg.data = &dst->nest;\n\t\t\tif (ethtool_cable_nest_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nvoid ethtool_cable_test_tdr_ntf_free(struct ethtool_cable_test_tdr_ntf *rsp)\n{\n\tethtool_header_free(&rsp->obj.header);\n\tethtool_cable_nest_free(&rsp->obj.nest);\n\tfree(rsp);\n}\n\nstatic const struct ynl_ntf_info ethtool_ntf_info[] =  {\n\t[ETHTOOL_MSG_LINKINFO_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_linkinfo_get_ntf),\n\t\t.cb\t\t= ethtool_linkinfo_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_linkinfo_nest,\n\t\t.free\t\t= (void *)ethtool_linkinfo_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_LINKMODES_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_linkmodes_get_ntf),\n\t\t.cb\t\t= ethtool_linkmodes_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_linkmodes_nest,\n\t\t.free\t\t= (void *)ethtool_linkmodes_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_DEBUG_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_debug_get_ntf),\n\t\t.cb\t\t= ethtool_debug_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_debug_nest,\n\t\t.free\t\t= (void *)ethtool_debug_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_WOL_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_wol_get_ntf),\n\t\t.cb\t\t= ethtool_wol_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_wol_nest,\n\t\t.free\t\t= (void *)ethtool_wol_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_FEATURES_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_features_get_ntf),\n\t\t.cb\t\t= ethtool_features_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_features_nest,\n\t\t.free\t\t= (void *)ethtool_features_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_PRIVFLAGS_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_privflags_get_ntf),\n\t\t.cb\t\t= ethtool_privflags_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_privflags_nest,\n\t\t.free\t\t= (void *)ethtool_privflags_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_RINGS_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_rings_get_ntf),\n\t\t.cb\t\t= ethtool_rings_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_rings_nest,\n\t\t.free\t\t= (void *)ethtool_rings_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_CHANNELS_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_channels_get_ntf),\n\t\t.cb\t\t= ethtool_channels_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_channels_nest,\n\t\t.free\t\t= (void *)ethtool_channels_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_COALESCE_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_coalesce_get_ntf),\n\t\t.cb\t\t= ethtool_coalesce_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_coalesce_nest,\n\t\t.free\t\t= (void *)ethtool_coalesce_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_PAUSE_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_pause_get_ntf),\n\t\t.cb\t\t= ethtool_pause_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_pause_nest,\n\t\t.free\t\t= (void *)ethtool_pause_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_EEE_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_eee_get_ntf),\n\t\t.cb\t\t= ethtool_eee_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_eee_nest,\n\t\t.free\t\t= (void *)ethtool_eee_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_CABLE_TEST_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_cable_test_ntf),\n\t\t.cb\t\t= ethtool_cable_test_ntf_rsp_parse,\n\t\t.policy\t\t= &ethtool_cable_test_ntf_nest,\n\t\t.free\t\t= (void *)ethtool_cable_test_ntf_free,\n\t},\n\t[ETHTOOL_MSG_CABLE_TEST_TDR_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_cable_test_tdr_ntf),\n\t\t.cb\t\t= ethtool_cable_test_tdr_ntf_rsp_parse,\n\t\t.policy\t\t= &ethtool_cable_test_tdr_ntf_nest,\n\t\t.free\t\t= (void *)ethtool_cable_test_tdr_ntf_free,\n\t},\n\t[ETHTOOL_MSG_FEC_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_fec_get_ntf),\n\t\t.cb\t\t= ethtool_fec_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_fec_nest,\n\t\t.free\t\t= (void *)ethtool_fec_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_MODULE_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_module_get_ntf),\n\t\t.cb\t\t= ethtool_module_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_module_nest,\n\t\t.free\t\t= (void *)ethtool_module_get_ntf_free,\n\t},\n\t[ETHTOOL_MSG_PLCA_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_plca_get_cfg_ntf),\n\t\t.cb\t\t= ethtool_plca_get_cfg_rsp_parse,\n\t\t.policy\t\t= &ethtool_plca_nest,\n\t\t.free\t\t= (void *)ethtool_plca_get_cfg_ntf_free,\n\t},\n\t[ETHTOOL_MSG_MM_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct ethtool_mm_get_ntf),\n\t\t.cb\t\t= ethtool_mm_get_rsp_parse,\n\t\t.policy\t\t= &ethtool_mm_nest,\n\t\t.free\t\t= (void *)ethtool_mm_get_ntf_free,\n\t},\n};\n\nconst struct ynl_family ynl_ethtool_family =  {\n\t.name\t\t= \"ethtool\",\n\t.ntf_info\t= ethtool_ntf_info,\n\t.ntf_info_size\t= MNL_ARRAY_SIZE(ethtool_ntf_info),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}