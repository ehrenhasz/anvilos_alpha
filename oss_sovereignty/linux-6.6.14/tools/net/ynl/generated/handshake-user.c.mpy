{
  "module_name": "handshake-user.c",
  "hash_id": "900d014039f827dbf0d3c170fa5038f94debc5a76d617b5cba9bad4f48b7b08d",
  "original_prompt": "Ingested from linux-6.6.14/tools/net/ynl/generated/handshake-user.c",
  "human_readable_source": "\n \n \n \n\n#include <stdlib.h>\n#include <string.h>\n#include \"handshake-user.h\"\n#include \"ynl.h\"\n#include <linux/handshake.h>\n\n#include <libmnl/libmnl.h>\n#include <linux/genetlink.h>\n\n \nstatic const char * const handshake_op_strmap[] = {\n\t[HANDSHAKE_CMD_READY] = \"ready\",\n\t[HANDSHAKE_CMD_ACCEPT] = \"accept\",\n\t[HANDSHAKE_CMD_DONE] = \"done\",\n};\n\nconst char *handshake_op_str(int op)\n{\n\tif (op < 0 || op >= (int)MNL_ARRAY_SIZE(handshake_op_strmap))\n\t\treturn NULL;\n\treturn handshake_op_strmap[op];\n}\n\nstatic const char * const handshake_handler_class_strmap[] = {\n\t[0] = \"none\",\n\t[1] = \"tlshd\",\n\t[2] = \"max\",\n};\n\nconst char *handshake_handler_class_str(enum handshake_handler_class value)\n{\n\tif (value < 0 || value >= (int)MNL_ARRAY_SIZE(handshake_handler_class_strmap))\n\t\treturn NULL;\n\treturn handshake_handler_class_strmap[value];\n}\n\nstatic const char * const handshake_msg_type_strmap[] = {\n\t[0] = \"unspec\",\n\t[1] = \"clienthello\",\n\t[2] = \"serverhello\",\n};\n\nconst char *handshake_msg_type_str(enum handshake_msg_type value)\n{\n\tif (value < 0 || value >= (int)MNL_ARRAY_SIZE(handshake_msg_type_strmap))\n\t\treturn NULL;\n\treturn handshake_msg_type_strmap[value];\n}\n\nstatic const char * const handshake_auth_strmap[] = {\n\t[0] = \"unspec\",\n\t[1] = \"unauth\",\n\t[2] = \"psk\",\n\t[3] = \"x509\",\n};\n\nconst char *handshake_auth_str(enum handshake_auth value)\n{\n\tif (value < 0 || value >= (int)MNL_ARRAY_SIZE(handshake_auth_strmap))\n\t\treturn NULL;\n\treturn handshake_auth_strmap[value];\n}\n\n \nstruct ynl_policy_attr handshake_x509_policy[HANDSHAKE_A_X509_MAX + 1] = {\n\t[HANDSHAKE_A_X509_CERT] = { .name = \"cert\", .type = YNL_PT_U32, },\n\t[HANDSHAKE_A_X509_PRIVKEY] = { .name = \"privkey\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest handshake_x509_nest = {\n\t.max_attr = HANDSHAKE_A_X509_MAX,\n\t.table = handshake_x509_policy,\n};\n\nstruct ynl_policy_attr handshake_accept_policy[HANDSHAKE_A_ACCEPT_MAX + 1] = {\n\t[HANDSHAKE_A_ACCEPT_SOCKFD] = { .name = \"sockfd\", .type = YNL_PT_U32, },\n\t[HANDSHAKE_A_ACCEPT_HANDLER_CLASS] = { .name = \"handler-class\", .type = YNL_PT_U32, },\n\t[HANDSHAKE_A_ACCEPT_MESSAGE_TYPE] = { .name = \"message-type\", .type = YNL_PT_U32, },\n\t[HANDSHAKE_A_ACCEPT_TIMEOUT] = { .name = \"timeout\", .type = YNL_PT_U32, },\n\t[HANDSHAKE_A_ACCEPT_AUTH_MODE] = { .name = \"auth-mode\", .type = YNL_PT_U32, },\n\t[HANDSHAKE_A_ACCEPT_PEER_IDENTITY] = { .name = \"peer-identity\", .type = YNL_PT_U32, },\n\t[HANDSHAKE_A_ACCEPT_CERTIFICATE] = { .name = \"certificate\", .type = YNL_PT_NEST, .nest = &handshake_x509_nest, },\n\t[HANDSHAKE_A_ACCEPT_PEERNAME] = { .name = \"peername\", .type = YNL_PT_NUL_STR, },\n};\n\nstruct ynl_policy_nest handshake_accept_nest = {\n\t.max_attr = HANDSHAKE_A_ACCEPT_MAX,\n\t.table = handshake_accept_policy,\n};\n\nstruct ynl_policy_attr handshake_done_policy[HANDSHAKE_A_DONE_MAX + 1] = {\n\t[HANDSHAKE_A_DONE_STATUS] = { .name = \"status\", .type = YNL_PT_U32, },\n\t[HANDSHAKE_A_DONE_SOCKFD] = { .name = \"sockfd\", .type = YNL_PT_U32, },\n\t[HANDSHAKE_A_DONE_REMOTE_AUTH] = { .name = \"remote-auth\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest handshake_done_nest = {\n\t.max_attr = HANDSHAKE_A_DONE_MAX,\n\t.table = handshake_done_policy,\n};\n\n \nvoid handshake_x509_free(struct handshake_x509 *obj)\n{\n}\n\nint handshake_x509_parse(struct ynl_parse_arg *yarg,\n\t\t\t const struct nlattr *nested)\n{\n\tstruct handshake_x509 *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == HANDSHAKE_A_X509_CERT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.cert = 1;\n\t\t\tdst->cert = mnl_attr_get_u32(attr);\n\t\t} else if (type == HANDSHAKE_A_X509_PRIVKEY) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.privkey = 1;\n\t\t\tdst->privkey = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n \nvoid handshake_accept_req_free(struct handshake_accept_req *req)\n{\n\tfree(req);\n}\n\nvoid handshake_accept_rsp_free(struct handshake_accept_rsp *rsp)\n{\n\tunsigned int i;\n\n\tfree(rsp->peer_identity);\n\tfor (i = 0; i < rsp->n_certificate; i++)\n\t\thandshake_x509_free(&rsp->certificate[i]);\n\tfree(rsp->certificate);\n\tfree(rsp->peername);\n\tfree(rsp);\n}\n\nint handshake_accept_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct handshake_accept_rsp *dst;\n\tunsigned int n_peer_identity = 0;\n\tunsigned int n_certificate = 0;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\tint i;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tif (dst->certificate)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (accept.certificate)\");\n\tif (dst->peer_identity)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (accept.peer-identity)\");\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == HANDSHAKE_A_ACCEPT_SOCKFD) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.sockfd = 1;\n\t\t\tdst->sockfd = mnl_attr_get_u32(attr);\n\t\t} else if (type == HANDSHAKE_A_ACCEPT_MESSAGE_TYPE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.message_type = 1;\n\t\t\tdst->message_type = mnl_attr_get_u32(attr);\n\t\t} else if (type == HANDSHAKE_A_ACCEPT_TIMEOUT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.timeout = 1;\n\t\t\tdst->timeout = mnl_attr_get_u32(attr);\n\t\t} else if (type == HANDSHAKE_A_ACCEPT_AUTH_MODE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.auth_mode = 1;\n\t\t\tdst->auth_mode = mnl_attr_get_u32(attr);\n\t\t} else if (type == HANDSHAKE_A_ACCEPT_PEER_IDENTITY) {\n\t\t\tn_peer_identity++;\n\t\t} else if (type == HANDSHAKE_A_ACCEPT_CERTIFICATE) {\n\t\t\tn_certificate++;\n\t\t} else if (type == HANDSHAKE_A_ACCEPT_PEERNAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.peername_len = len;\n\t\t\tdst->peername = malloc(len + 1);\n\t\t\tmemcpy(dst->peername, mnl_attr_get_str(attr), len);\n\t\t\tdst->peername[len] = 0;\n\t\t}\n\t}\n\n\tif (n_certificate) {\n\t\tdst->certificate = calloc(n_certificate, sizeof(*dst->certificate));\n\t\tdst->n_certificate = n_certificate;\n\t\ti = 0;\n\t\tparg.rsp_policy = &handshake_x509_nest;\n\t\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\t\tif (mnl_attr_get_type(attr) == HANDSHAKE_A_ACCEPT_CERTIFICATE) {\n\t\t\t\tparg.data = &dst->certificate[i];\n\t\t\t\tif (handshake_x509_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n_peer_identity) {\n\t\tdst->peer_identity = calloc(n_peer_identity, sizeof(*dst->peer_identity));\n\t\tdst->n_peer_identity = n_peer_identity;\n\t\ti = 0;\n\t\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\t\tif (mnl_attr_get_type(attr) == HANDSHAKE_A_ACCEPT_PEER_IDENTITY) {\n\t\t\t\tdst->peer_identity[i] = mnl_attr_get_u32(attr);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct handshake_accept_rsp *\nhandshake_accept(struct ynl_sock *ys, struct handshake_accept_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct handshake_accept_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, HANDSHAKE_CMD_ACCEPT, 1);\n\tys->req_policy = &handshake_accept_nest;\n\tyrs.yarg.rsp_policy = &handshake_accept_nest;\n\n\tif (req->_present.handler_class)\n\t\tmnl_attr_put_u32(nlh, HANDSHAKE_A_ACCEPT_HANDLER_CLASS, req->handler_class);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = handshake_accept_rsp_parse;\n\tyrs.rsp_cmd = HANDSHAKE_CMD_ACCEPT;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\thandshake_accept_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid handshake_accept_ntf_free(struct handshake_accept_ntf *rsp)\n{\n\tunsigned int i;\n\n\tfree(rsp->obj.peer_identity);\n\tfor (i = 0; i < rsp->obj.n_certificate; i++)\n\t\thandshake_x509_free(&rsp->obj.certificate[i]);\n\tfree(rsp->obj.certificate);\n\tfree(rsp->obj.peername);\n\tfree(rsp);\n}\n\n \n \nvoid handshake_done_req_free(struct handshake_done_req *req)\n{\n\tfree(req->remote_auth);\n\tfree(req);\n}\n\nint handshake_done(struct ynl_sock *ys, struct handshake_done_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, HANDSHAKE_CMD_DONE, 1);\n\tys->req_policy = &handshake_done_nest;\n\n\tif (req->_present.status)\n\t\tmnl_attr_put_u32(nlh, HANDSHAKE_A_DONE_STATUS, req->status);\n\tif (req->_present.sockfd)\n\t\tmnl_attr_put_u32(nlh, HANDSHAKE_A_DONE_SOCKFD, req->sockfd);\n\tfor (unsigned int i = 0; i < req->n_remote_auth; i++)\n\t\tmnl_attr_put_u32(nlh, HANDSHAKE_A_DONE_REMOTE_AUTH, req->remote_auth[i]);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic const struct ynl_ntf_info handshake_ntf_info[] =  {\n\t[HANDSHAKE_CMD_READY] =  {\n\t\t.alloc_sz\t= sizeof(struct handshake_accept_ntf),\n\t\t.cb\t\t= handshake_accept_rsp_parse,\n\t\t.policy\t\t= &handshake_accept_nest,\n\t\t.free\t\t= (void *)handshake_accept_ntf_free,\n\t},\n};\n\nconst struct ynl_family ynl_handshake_family =  {\n\t.name\t\t= \"handshake\",\n\t.ntf_info\t= handshake_ntf_info,\n\t.ntf_info_size\t= MNL_ARRAY_SIZE(handshake_ntf_info),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}