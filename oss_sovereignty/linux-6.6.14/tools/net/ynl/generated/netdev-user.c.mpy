{
  "module_name": "netdev-user.c",
  "hash_id": "4f5de3734d3bf66c95ccdf61b0f5ce1128861c8511c7d98f6c701e2d626cbe91",
  "original_prompt": "Ingested from linux-6.6.14/tools/net/ynl/generated/netdev-user.c",
  "human_readable_source": "\n \n \n \n\n#include <stdlib.h>\n#include <string.h>\n#include \"netdev-user.h\"\n#include \"ynl.h\"\n#include <linux/netdev.h>\n\n#include <libmnl/libmnl.h>\n#include <linux/genetlink.h>\n\n \nstatic const char * const netdev_op_strmap[] = {\n\t[NETDEV_CMD_DEV_GET] = \"dev-get\",\n\t[NETDEV_CMD_DEV_ADD_NTF] = \"dev-add-ntf\",\n\t[NETDEV_CMD_DEV_DEL_NTF] = \"dev-del-ntf\",\n\t[NETDEV_CMD_DEV_CHANGE_NTF] = \"dev-change-ntf\",\n};\n\nconst char *netdev_op_str(int op)\n{\n\tif (op < 0 || op >= (int)MNL_ARRAY_SIZE(netdev_op_strmap))\n\t\treturn NULL;\n\treturn netdev_op_strmap[op];\n}\n\nstatic const char * const netdev_xdp_act_strmap[] = {\n\t[0] = \"basic\",\n\t[1] = \"redirect\",\n\t[2] = \"ndo-xmit\",\n\t[3] = \"xsk-zerocopy\",\n\t[4] = \"hw-offload\",\n\t[5] = \"rx-sg\",\n\t[6] = \"ndo-xmit-sg\",\n};\n\nconst char *netdev_xdp_act_str(enum netdev_xdp_act value)\n{\n\tvalue = ffs(value) - 1;\n\tif (value < 0 || value >= (int)MNL_ARRAY_SIZE(netdev_xdp_act_strmap))\n\t\treturn NULL;\n\treturn netdev_xdp_act_strmap[value];\n}\n\n \nstruct ynl_policy_attr netdev_dev_policy[NETDEV_A_DEV_MAX + 1] = {\n\t[NETDEV_A_DEV_IFINDEX] = { .name = \"ifindex\", .type = YNL_PT_U32, },\n\t[NETDEV_A_DEV_PAD] = { .name = \"pad\", .type = YNL_PT_IGNORE, },\n\t[NETDEV_A_DEV_XDP_FEATURES] = { .name = \"xdp-features\", .type = YNL_PT_U64, },\n\t[NETDEV_A_DEV_XDP_ZC_MAX_SEGS] = { .name = \"xdp-zc-max-segs\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest netdev_dev_nest = {\n\t.max_attr = NETDEV_A_DEV_MAX,\n\t.table = netdev_dev_policy,\n};\n\n \n \n \nvoid netdev_dev_get_req_free(struct netdev_dev_get_req *req)\n{\n\tfree(req);\n}\n\nvoid netdev_dev_get_rsp_free(struct netdev_dev_get_rsp *rsp)\n{\n\tfree(rsp);\n}\n\nint netdev_dev_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct netdev_dev_get_rsp *dst;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == NETDEV_A_DEV_IFINDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.ifindex = 1;\n\t\t\tdst->ifindex = mnl_attr_get_u32(attr);\n\t\t} else if (type == NETDEV_A_DEV_XDP_FEATURES) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.xdp_features = 1;\n\t\t\tdst->xdp_features = mnl_attr_get_u64(attr);\n\t\t} else if (type == NETDEV_A_DEV_XDP_ZC_MAX_SEGS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.xdp_zc_max_segs = 1;\n\t\t\tdst->xdp_zc_max_segs = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct netdev_dev_get_rsp *\nnetdev_dev_get(struct ynl_sock *ys, struct netdev_dev_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct netdev_dev_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, NETDEV_CMD_DEV_GET, 1);\n\tys->req_policy = &netdev_dev_nest;\n\tyrs.yarg.rsp_policy = &netdev_dev_nest;\n\n\tif (req->_present.ifindex)\n\t\tmnl_attr_put_u32(nlh, NETDEV_A_DEV_IFINDEX, req->ifindex);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = netdev_dev_get_rsp_parse;\n\tyrs.rsp_cmd = NETDEV_CMD_DEV_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tnetdev_dev_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid netdev_dev_get_list_free(struct netdev_dev_get_list *rsp)\n{\n\tstruct netdev_dev_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp);\n\t}\n}\n\nstruct netdev_dev_get_list *netdev_dev_get_dump(struct ynl_sock *ys)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct netdev_dev_get_list);\n\tyds.cb = netdev_dev_get_rsp_parse;\n\tyds.rsp_cmd = NETDEV_CMD_DEV_GET;\n\tyds.rsp_policy = &netdev_dev_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, NETDEV_CMD_DEV_GET, 1);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tnetdev_dev_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \nvoid netdev_dev_get_ntf_free(struct netdev_dev_get_ntf *rsp)\n{\n\tfree(rsp);\n}\n\nstatic const struct ynl_ntf_info netdev_ntf_info[] =  {\n\t[NETDEV_CMD_DEV_ADD_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct netdev_dev_get_ntf),\n\t\t.cb\t\t= netdev_dev_get_rsp_parse,\n\t\t.policy\t\t= &netdev_dev_nest,\n\t\t.free\t\t= (void *)netdev_dev_get_ntf_free,\n\t},\n\t[NETDEV_CMD_DEV_DEL_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct netdev_dev_get_ntf),\n\t\t.cb\t\t= netdev_dev_get_rsp_parse,\n\t\t.policy\t\t= &netdev_dev_nest,\n\t\t.free\t\t= (void *)netdev_dev_get_ntf_free,\n\t},\n\t[NETDEV_CMD_DEV_CHANGE_NTF] =  {\n\t\t.alloc_sz\t= sizeof(struct netdev_dev_get_ntf),\n\t\t.cb\t\t= netdev_dev_get_rsp_parse,\n\t\t.policy\t\t= &netdev_dev_nest,\n\t\t.free\t\t= (void *)netdev_dev_get_ntf_free,\n\t},\n};\n\nconst struct ynl_family ynl_netdev_family =  {\n\t.name\t\t= \"netdev\",\n\t.ntf_info\t= netdev_ntf_info,\n\t.ntf_info_size\t= MNL_ARRAY_SIZE(netdev_ntf_info),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}