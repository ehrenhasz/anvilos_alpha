{
  "module_name": "devlink-user.c",
  "hash_id": "e09c3a3d10ea43e1f3d93f85bdb9ece3cf94b463fe09c720a39201fd33e9c707",
  "original_prompt": "Ingested from linux-6.6.14/tools/net/ynl/generated/devlink-user.c",
  "human_readable_source": "\n \n \n \n\n#include <stdlib.h>\n#include <string.h>\n#include \"devlink-user.h\"\n#include \"ynl.h\"\n#include <linux/devlink.h>\n\n#include <libmnl/libmnl.h>\n#include <linux/genetlink.h>\n\n \nstatic const char * const devlink_op_strmap[] = {\n\t[3] = \"get\",\n\t[7] = \"port-get\",\n\t[13] = \"sb-get\",\n\t[17] = \"sb-pool-get\",\n\t[21] = \"sb-port-pool-get\",\n\t[25] = \"sb-tc-pool-bind-get\",\n\t[DEVLINK_CMD_PARAM_GET] = \"param-get\",\n\t[DEVLINK_CMD_REGION_GET] = \"region-get\",\n\t[DEVLINK_CMD_INFO_GET] = \"info-get\",\n\t[DEVLINK_CMD_HEALTH_REPORTER_GET] = \"health-reporter-get\",\n\t[63] = \"trap-get\",\n\t[67] = \"trap-group-get\",\n\t[71] = \"trap-policer-get\",\n\t[76] = \"rate-get\",\n\t[80] = \"linecard-get\",\n\t[DEVLINK_CMD_SELFTESTS_GET] = \"selftests-get\",\n};\n\nconst char *devlink_op_str(int op)\n{\n\tif (op < 0 || op >= (int)MNL_ARRAY_SIZE(devlink_op_strmap))\n\t\treturn NULL;\n\treturn devlink_op_strmap[op];\n}\n\nstatic const char * const devlink_sb_pool_type_strmap[] = {\n\t[0] = \"ingress\",\n\t[1] = \"egress\",\n};\n\nconst char *devlink_sb_pool_type_str(enum devlink_sb_pool_type value)\n{\n\tif (value < 0 || value >= (int)MNL_ARRAY_SIZE(devlink_sb_pool_type_strmap))\n\t\treturn NULL;\n\treturn devlink_sb_pool_type_strmap[value];\n}\n\n \nstruct ynl_policy_attr devlink_dl_info_version_policy[DEVLINK_ATTR_MAX + 1] = {\n\t[DEVLINK_ATTR_INFO_VERSION_NAME] = { .name = \"info-version-name\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_INFO_VERSION_VALUE] = { .name = \"info-version-value\", .type = YNL_PT_NUL_STR, },\n};\n\nstruct ynl_policy_nest devlink_dl_info_version_nest = {\n\t.max_attr = DEVLINK_ATTR_MAX,\n\t.table = devlink_dl_info_version_policy,\n};\n\nstruct ynl_policy_attr devlink_dl_reload_stats_entry_policy[DEVLINK_ATTR_MAX + 1] = {\n\t[DEVLINK_ATTR_RELOAD_STATS_LIMIT] = { .name = \"reload-stats-limit\", .type = YNL_PT_U8, },\n\t[DEVLINK_ATTR_RELOAD_STATS_VALUE] = { .name = \"reload-stats-value\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest devlink_dl_reload_stats_entry_nest = {\n\t.max_attr = DEVLINK_ATTR_MAX,\n\t.table = devlink_dl_reload_stats_entry_policy,\n};\n\nstruct ynl_policy_attr devlink_dl_reload_act_stats_policy[DEVLINK_ATTR_MAX + 1] = {\n\t[DEVLINK_ATTR_RELOAD_STATS_ENTRY] = { .name = \"reload-stats-entry\", .type = YNL_PT_NEST, .nest = &devlink_dl_reload_stats_entry_nest, },\n};\n\nstruct ynl_policy_nest devlink_dl_reload_act_stats_nest = {\n\t.max_attr = DEVLINK_ATTR_MAX,\n\t.table = devlink_dl_reload_act_stats_policy,\n};\n\nstruct ynl_policy_attr devlink_dl_reload_act_info_policy[DEVLINK_ATTR_MAX + 1] = {\n\t[DEVLINK_ATTR_RELOAD_ACTION] = { .name = \"reload-action\", .type = YNL_PT_U8, },\n\t[DEVLINK_ATTR_RELOAD_ACTION_STATS] = { .name = \"reload-action-stats\", .type = YNL_PT_NEST, .nest = &devlink_dl_reload_act_stats_nest, },\n};\n\nstruct ynl_policy_nest devlink_dl_reload_act_info_nest = {\n\t.max_attr = DEVLINK_ATTR_MAX,\n\t.table = devlink_dl_reload_act_info_policy,\n};\n\nstruct ynl_policy_attr devlink_dl_reload_stats_policy[DEVLINK_ATTR_MAX + 1] = {\n\t[DEVLINK_ATTR_RELOAD_ACTION_INFO] = { .name = \"reload-action-info\", .type = YNL_PT_NEST, .nest = &devlink_dl_reload_act_info_nest, },\n};\n\nstruct ynl_policy_nest devlink_dl_reload_stats_nest = {\n\t.max_attr = DEVLINK_ATTR_MAX,\n\t.table = devlink_dl_reload_stats_policy,\n};\n\nstruct ynl_policy_attr devlink_dl_dev_stats_policy[DEVLINK_ATTR_MAX + 1] = {\n\t[DEVLINK_ATTR_RELOAD_STATS] = { .name = \"reload-stats\", .type = YNL_PT_NEST, .nest = &devlink_dl_reload_stats_nest, },\n\t[DEVLINK_ATTR_REMOTE_RELOAD_STATS] = { .name = \"remote-reload-stats\", .type = YNL_PT_NEST, .nest = &devlink_dl_reload_stats_nest, },\n};\n\nstruct ynl_policy_nest devlink_dl_dev_stats_nest = {\n\t.max_attr = DEVLINK_ATTR_MAX,\n\t.table = devlink_dl_dev_stats_policy,\n};\n\nstruct ynl_policy_attr devlink_policy[DEVLINK_ATTR_MAX + 1] = {\n\t[DEVLINK_ATTR_BUS_NAME] = { .name = \"bus-name\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_DEV_NAME] = { .name = \"dev-name\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_PORT_INDEX] = { .name = \"port-index\", .type = YNL_PT_U32, },\n\t[DEVLINK_ATTR_SB_INDEX] = { .name = \"sb-index\", .type = YNL_PT_U32, },\n\t[DEVLINK_ATTR_SB_POOL_INDEX] = { .name = \"sb-pool-index\", .type = YNL_PT_U16, },\n\t[DEVLINK_ATTR_SB_POOL_TYPE] = { .name = \"sb-pool-type\", .type = YNL_PT_U8, },\n\t[DEVLINK_ATTR_SB_TC_INDEX] = { .name = \"sb-tc-index\", .type = YNL_PT_U16, },\n\t[DEVLINK_ATTR_PARAM_NAME] = { .name = \"param-name\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_REGION_NAME] = { .name = \"region-name\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_INFO_DRIVER_NAME] = { .name = \"info-driver-name\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_INFO_SERIAL_NUMBER] = { .name = \"info-serial-number\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_INFO_VERSION_FIXED] = { .name = \"info-version-fixed\", .type = YNL_PT_NEST, .nest = &devlink_dl_info_version_nest, },\n\t[DEVLINK_ATTR_INFO_VERSION_RUNNING] = { .name = \"info-version-running\", .type = YNL_PT_NEST, .nest = &devlink_dl_info_version_nest, },\n\t[DEVLINK_ATTR_INFO_VERSION_STORED] = { .name = \"info-version-stored\", .type = YNL_PT_NEST, .nest = &devlink_dl_info_version_nest, },\n\t[DEVLINK_ATTR_INFO_VERSION_NAME] = { .name = \"info-version-name\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_INFO_VERSION_VALUE] = { .name = \"info-version-value\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_HEALTH_REPORTER_NAME] = { .name = \"health-reporter-name\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_TRAP_NAME] = { .name = \"trap-name\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_TRAP_GROUP_NAME] = { .name = \"trap-group-name\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_RELOAD_FAILED] = { .name = \"reload-failed\", .type = YNL_PT_U8, },\n\t[DEVLINK_ATTR_TRAP_POLICER_ID] = { .name = \"trap-policer-id\", .type = YNL_PT_U32, },\n\t[DEVLINK_ATTR_RELOAD_ACTION] = { .name = \"reload-action\", .type = YNL_PT_U8, },\n\t[DEVLINK_ATTR_DEV_STATS] = { .name = \"dev-stats\", .type = YNL_PT_NEST, .nest = &devlink_dl_dev_stats_nest, },\n\t[DEVLINK_ATTR_RELOAD_STATS] = { .name = \"reload-stats\", .type = YNL_PT_NEST, .nest = &devlink_dl_reload_stats_nest, },\n\t[DEVLINK_ATTR_RELOAD_STATS_ENTRY] = { .name = \"reload-stats-entry\", .type = YNL_PT_NEST, .nest = &devlink_dl_reload_stats_entry_nest, },\n\t[DEVLINK_ATTR_RELOAD_STATS_LIMIT] = { .name = \"reload-stats-limit\", .type = YNL_PT_U8, },\n\t[DEVLINK_ATTR_RELOAD_STATS_VALUE] = { .name = \"reload-stats-value\", .type = YNL_PT_U32, },\n\t[DEVLINK_ATTR_REMOTE_RELOAD_STATS] = { .name = \"remote-reload-stats\", .type = YNL_PT_NEST, .nest = &devlink_dl_reload_stats_nest, },\n\t[DEVLINK_ATTR_RELOAD_ACTION_INFO] = { .name = \"reload-action-info\", .type = YNL_PT_NEST, .nest = &devlink_dl_reload_act_info_nest, },\n\t[DEVLINK_ATTR_RELOAD_ACTION_STATS] = { .name = \"reload-action-stats\", .type = YNL_PT_NEST, .nest = &devlink_dl_reload_act_stats_nest, },\n\t[DEVLINK_ATTR_RATE_NODE_NAME] = { .name = \"rate-node-name\", .type = YNL_PT_NUL_STR, },\n\t[DEVLINK_ATTR_LINECARD_INDEX] = { .name = \"linecard-index\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest devlink_nest = {\n\t.max_attr = DEVLINK_ATTR_MAX,\n\t.table = devlink_policy,\n};\n\n \nvoid devlink_dl_info_version_free(struct devlink_dl_info_version *obj)\n{\n\tfree(obj->info_version_name);\n\tfree(obj->info_version_value);\n}\n\nint devlink_dl_info_version_parse(struct ynl_parse_arg *yarg,\n\t\t\t\t  const struct nlattr *nested)\n{\n\tstruct devlink_dl_info_version *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_INFO_VERSION_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.info_version_name_len = len;\n\t\t\tdst->info_version_name = malloc(len + 1);\n\t\t\tmemcpy(dst->info_version_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->info_version_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_INFO_VERSION_VALUE) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.info_version_value_len = len;\n\t\t\tdst->info_version_value = malloc(len + 1);\n\t\t\tmemcpy(dst->info_version_value, mnl_attr_get_str(attr), len);\n\t\t\tdst->info_version_value[len] = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid\ndevlink_dl_reload_stats_entry_free(struct devlink_dl_reload_stats_entry *obj)\n{\n}\n\nint devlink_dl_reload_stats_entry_parse(struct ynl_parse_arg *yarg,\n\t\t\t\t\tconst struct nlattr *nested)\n{\n\tstruct devlink_dl_reload_stats_entry *dst = yarg->data;\n\tconst struct nlattr *attr;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_RELOAD_STATS_LIMIT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.reload_stats_limit = 1;\n\t\t\tdst->reload_stats_limit = mnl_attr_get_u8(attr);\n\t\t} else if (type == DEVLINK_ATTR_RELOAD_STATS_VALUE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.reload_stats_value = 1;\n\t\t\tdst->reload_stats_value = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid devlink_dl_reload_act_stats_free(struct devlink_dl_reload_act_stats *obj)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < obj->n_reload_stats_entry; i++)\n\t\tdevlink_dl_reload_stats_entry_free(&obj->reload_stats_entry[i]);\n\tfree(obj->reload_stats_entry);\n}\n\nint devlink_dl_reload_act_stats_parse(struct ynl_parse_arg *yarg,\n\t\t\t\t      const struct nlattr *nested)\n{\n\tstruct devlink_dl_reload_act_stats *dst = yarg->data;\n\tunsigned int n_reload_stats_entry = 0;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\tint i;\n\n\tparg.ys = yarg->ys;\n\n\tif (dst->reload_stats_entry)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (dl-reload-act-stats.reload-stats-entry)\");\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_RELOAD_STATS_ENTRY) {\n\t\t\tn_reload_stats_entry++;\n\t\t}\n\t}\n\n\tif (n_reload_stats_entry) {\n\t\tdst->reload_stats_entry = calloc(n_reload_stats_entry, sizeof(*dst->reload_stats_entry));\n\t\tdst->n_reload_stats_entry = n_reload_stats_entry;\n\t\ti = 0;\n\t\tparg.rsp_policy = &devlink_dl_reload_stats_entry_nest;\n\t\tmnl_attr_for_each_nested(attr, nested) {\n\t\t\tif (mnl_attr_get_type(attr) == DEVLINK_ATTR_RELOAD_STATS_ENTRY) {\n\t\t\t\tparg.data = &dst->reload_stats_entry[i];\n\t\t\t\tif (devlink_dl_reload_stats_entry_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid devlink_dl_reload_act_info_free(struct devlink_dl_reload_act_info *obj)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < obj->n_reload_action_stats; i++)\n\t\tdevlink_dl_reload_act_stats_free(&obj->reload_action_stats[i]);\n\tfree(obj->reload_action_stats);\n}\n\nint devlink_dl_reload_act_info_parse(struct ynl_parse_arg *yarg,\n\t\t\t\t     const struct nlattr *nested)\n{\n\tstruct devlink_dl_reload_act_info *dst = yarg->data;\n\tunsigned int n_reload_action_stats = 0;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\tint i;\n\n\tparg.ys = yarg->ys;\n\n\tif (dst->reload_action_stats)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (dl-reload-act-info.reload-action-stats)\");\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_RELOAD_ACTION) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.reload_action = 1;\n\t\t\tdst->reload_action = mnl_attr_get_u8(attr);\n\t\t} else if (type == DEVLINK_ATTR_RELOAD_ACTION_STATS) {\n\t\t\tn_reload_action_stats++;\n\t\t}\n\t}\n\n\tif (n_reload_action_stats) {\n\t\tdst->reload_action_stats = calloc(n_reload_action_stats, sizeof(*dst->reload_action_stats));\n\t\tdst->n_reload_action_stats = n_reload_action_stats;\n\t\ti = 0;\n\t\tparg.rsp_policy = &devlink_dl_reload_act_stats_nest;\n\t\tmnl_attr_for_each_nested(attr, nested) {\n\t\t\tif (mnl_attr_get_type(attr) == DEVLINK_ATTR_RELOAD_ACTION_STATS) {\n\t\t\t\tparg.data = &dst->reload_action_stats[i];\n\t\t\t\tif (devlink_dl_reload_act_stats_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid devlink_dl_reload_stats_free(struct devlink_dl_reload_stats *obj)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < obj->n_reload_action_info; i++)\n\t\tdevlink_dl_reload_act_info_free(&obj->reload_action_info[i]);\n\tfree(obj->reload_action_info);\n}\n\nint devlink_dl_reload_stats_parse(struct ynl_parse_arg *yarg,\n\t\t\t\t  const struct nlattr *nested)\n{\n\tstruct devlink_dl_reload_stats *dst = yarg->data;\n\tunsigned int n_reload_action_info = 0;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\tint i;\n\n\tparg.ys = yarg->ys;\n\n\tif (dst->reload_action_info)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (dl-reload-stats.reload-action-info)\");\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_RELOAD_ACTION_INFO) {\n\t\t\tn_reload_action_info++;\n\t\t}\n\t}\n\n\tif (n_reload_action_info) {\n\t\tdst->reload_action_info = calloc(n_reload_action_info, sizeof(*dst->reload_action_info));\n\t\tdst->n_reload_action_info = n_reload_action_info;\n\t\ti = 0;\n\t\tparg.rsp_policy = &devlink_dl_reload_act_info_nest;\n\t\tmnl_attr_for_each_nested(attr, nested) {\n\t\t\tif (mnl_attr_get_type(attr) == DEVLINK_ATTR_RELOAD_ACTION_INFO) {\n\t\t\t\tparg.data = &dst->reload_action_info[i];\n\t\t\t\tif (devlink_dl_reload_act_info_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid devlink_dl_dev_stats_free(struct devlink_dl_dev_stats *obj)\n{\n\tdevlink_dl_reload_stats_free(&obj->reload_stats);\n\tdevlink_dl_reload_stats_free(&obj->remote_reload_stats);\n}\n\nint devlink_dl_dev_stats_parse(struct ynl_parse_arg *yarg,\n\t\t\t       const struct nlattr *nested)\n{\n\tstruct devlink_dl_dev_stats *dst = yarg->data;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each_nested(attr, nested) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_RELOAD_STATS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.reload_stats = 1;\n\n\t\t\tparg.rsp_policy = &devlink_dl_reload_stats_nest;\n\t\t\tparg.data = &dst->reload_stats;\n\t\t\tif (devlink_dl_reload_stats_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t} else if (type == DEVLINK_ATTR_REMOTE_RELOAD_STATS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.remote_reload_stats = 1;\n\n\t\t\tparg.rsp_policy = &devlink_dl_reload_stats_nest;\n\t\t\tparg.data = &dst->remote_reload_stats;\n\t\t\tif (devlink_dl_reload_stats_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n \nvoid devlink_get_req_free(struct devlink_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req);\n}\n\nvoid devlink_get_rsp_free(struct devlink_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tdevlink_dl_dev_stats_free(&rsp->dev_stats);\n\tfree(rsp);\n}\n\nint devlink_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct devlink_get_rsp *dst;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_RELOAD_FAILED) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.reload_failed = 1;\n\t\t\tdst->reload_failed = mnl_attr_get_u8(attr);\n\t\t} else if (type == DEVLINK_ATTR_RELOAD_ACTION) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.reload_action = 1;\n\t\t\tdst->reload_action = mnl_attr_get_u8(attr);\n\t\t} else if (type == DEVLINK_ATTR_DEV_STATS) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.dev_stats = 1;\n\n\t\t\tparg.rsp_policy = &devlink_dl_dev_stats_nest;\n\t\t\tparg.data = &dst->dev_stats;\n\t\t\tif (devlink_dl_dev_stats_parse(&parg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_get_rsp *\ndevlink_get(struct ynl_sock *ys, struct devlink_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_get_rsp_parse;\n\tyrs.rsp_cmd = 3;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid devlink_get_list_free(struct devlink_get_list *rsp)\n{\n\tstruct devlink_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tdevlink_dl_dev_stats_free(&rsp->obj.dev_stats);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_get_list *devlink_get_dump(struct ynl_sock *ys)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_get_list);\n\tyds.cb = devlink_get_rsp_parse;\n\tyds.rsp_cmd = 3;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_GET, 1);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid devlink_port_get_req_free(struct devlink_port_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req);\n}\n\nvoid devlink_port_get_rsp_free(struct devlink_port_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp);\n}\n\nint devlink_port_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct devlink_port_get_rsp *dst;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_PORT_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.port_index = 1;\n\t\t\tdst->port_index = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_port_get_rsp *\ndevlink_port_get(struct ynl_sock *ys, struct devlink_port_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_port_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_PORT_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.port_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_PORT_INDEX, req->port_index);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_port_get_rsp_parse;\n\tyrs.rsp_cmd = 7;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_port_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nint devlink_port_get_rsp_dump_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct devlink_port_get_rsp_dump *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_PORT_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.port_index = 1;\n\t\t\tdst->port_index = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nvoid devlink_port_get_rsp_list_free(struct devlink_port_get_rsp_list *rsp)\n{\n\tstruct devlink_port_get_rsp_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_port_get_rsp_list *\ndevlink_port_get_dump(struct ynl_sock *ys,\n\t\t      struct devlink_port_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_port_get_rsp_list);\n\tyds.cb = devlink_port_get_rsp_dump_parse;\n\tyds.rsp_cmd = 7;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_PORT_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_port_get_rsp_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid devlink_sb_get_req_free(struct devlink_sb_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req);\n}\n\nvoid devlink_sb_get_rsp_free(struct devlink_sb_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp);\n}\n\nint devlink_sb_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct devlink_sb_get_rsp *dst;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_SB_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.sb_index = 1;\n\t\t\tdst->sb_index = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_sb_get_rsp *\ndevlink_sb_get(struct ynl_sock *ys, struct devlink_sb_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_sb_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_SB_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.sb_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_SB_INDEX, req->sb_index);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_sb_get_rsp_parse;\n\tyrs.rsp_cmd = 13;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_sb_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid devlink_sb_get_list_free(struct devlink_sb_get_list *rsp)\n{\n\tstruct devlink_sb_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_sb_get_list *\ndevlink_sb_get_dump(struct ynl_sock *ys, struct devlink_sb_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_sb_get_list);\n\tyds.cb = devlink_sb_get_rsp_parse;\n\tyds.rsp_cmd = 13;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_SB_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_sb_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid devlink_sb_pool_get_req_free(struct devlink_sb_pool_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req);\n}\n\nvoid devlink_sb_pool_get_rsp_free(struct devlink_sb_pool_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp);\n}\n\nint devlink_sb_pool_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct devlink_sb_pool_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_SB_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.sb_index = 1;\n\t\t\tdst->sb_index = mnl_attr_get_u32(attr);\n\t\t} else if (type == DEVLINK_ATTR_SB_POOL_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.sb_pool_index = 1;\n\t\t\tdst->sb_pool_index = mnl_attr_get_u16(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_sb_pool_get_rsp *\ndevlink_sb_pool_get(struct ynl_sock *ys, struct devlink_sb_pool_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_sb_pool_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_SB_POOL_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.sb_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_SB_INDEX, req->sb_index);\n\tif (req->_present.sb_pool_index)\n\t\tmnl_attr_put_u16(nlh, DEVLINK_ATTR_SB_POOL_INDEX, req->sb_pool_index);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_sb_pool_get_rsp_parse;\n\tyrs.rsp_cmd = 17;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_sb_pool_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid devlink_sb_pool_get_list_free(struct devlink_sb_pool_get_list *rsp)\n{\n\tstruct devlink_sb_pool_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_sb_pool_get_list *\ndevlink_sb_pool_get_dump(struct ynl_sock *ys,\n\t\t\t struct devlink_sb_pool_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_sb_pool_get_list);\n\tyds.cb = devlink_sb_pool_get_rsp_parse;\n\tyds.rsp_cmd = 17;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_SB_POOL_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_sb_pool_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid\ndevlink_sb_port_pool_get_req_free(struct devlink_sb_port_pool_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req);\n}\n\nvoid\ndevlink_sb_port_pool_get_rsp_free(struct devlink_sb_port_pool_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp);\n}\n\nint devlink_sb_port_pool_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct devlink_sb_port_pool_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_PORT_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.port_index = 1;\n\t\t\tdst->port_index = mnl_attr_get_u32(attr);\n\t\t} else if (type == DEVLINK_ATTR_SB_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.sb_index = 1;\n\t\t\tdst->sb_index = mnl_attr_get_u32(attr);\n\t\t} else if (type == DEVLINK_ATTR_SB_POOL_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.sb_pool_index = 1;\n\t\t\tdst->sb_pool_index = mnl_attr_get_u16(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_sb_port_pool_get_rsp *\ndevlink_sb_port_pool_get(struct ynl_sock *ys,\n\t\t\t struct devlink_sb_port_pool_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_sb_port_pool_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_SB_PORT_POOL_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.port_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_PORT_INDEX, req->port_index);\n\tif (req->_present.sb_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_SB_INDEX, req->sb_index);\n\tif (req->_present.sb_pool_index)\n\t\tmnl_attr_put_u16(nlh, DEVLINK_ATTR_SB_POOL_INDEX, req->sb_pool_index);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_sb_port_pool_get_rsp_parse;\n\tyrs.rsp_cmd = 21;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_sb_port_pool_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid\ndevlink_sb_port_pool_get_list_free(struct devlink_sb_port_pool_get_list *rsp)\n{\n\tstruct devlink_sb_port_pool_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_sb_port_pool_get_list *\ndevlink_sb_port_pool_get_dump(struct ynl_sock *ys,\n\t\t\t      struct devlink_sb_port_pool_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_sb_port_pool_get_list);\n\tyds.cb = devlink_sb_port_pool_get_rsp_parse;\n\tyds.rsp_cmd = 21;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_SB_PORT_POOL_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_sb_port_pool_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid\ndevlink_sb_tc_pool_bind_get_req_free(struct devlink_sb_tc_pool_bind_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req);\n}\n\nvoid\ndevlink_sb_tc_pool_bind_get_rsp_free(struct devlink_sb_tc_pool_bind_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp);\n}\n\nint devlink_sb_tc_pool_bind_get_rsp_parse(const struct nlmsghdr *nlh,\n\t\t\t\t\t  void *data)\n{\n\tstruct devlink_sb_tc_pool_bind_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_PORT_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.port_index = 1;\n\t\t\tdst->port_index = mnl_attr_get_u32(attr);\n\t\t} else if (type == DEVLINK_ATTR_SB_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.sb_index = 1;\n\t\t\tdst->sb_index = mnl_attr_get_u32(attr);\n\t\t} else if (type == DEVLINK_ATTR_SB_POOL_TYPE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.sb_pool_type = 1;\n\t\t\tdst->sb_pool_type = mnl_attr_get_u8(attr);\n\t\t} else if (type == DEVLINK_ATTR_SB_TC_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.sb_tc_index = 1;\n\t\t\tdst->sb_tc_index = mnl_attr_get_u16(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_sb_tc_pool_bind_get_rsp *\ndevlink_sb_tc_pool_bind_get(struct ynl_sock *ys,\n\t\t\t    struct devlink_sb_tc_pool_bind_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_sb_tc_pool_bind_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_SB_TC_POOL_BIND_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.port_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_PORT_INDEX, req->port_index);\n\tif (req->_present.sb_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_SB_INDEX, req->sb_index);\n\tif (req->_present.sb_pool_type)\n\t\tmnl_attr_put_u8(nlh, DEVLINK_ATTR_SB_POOL_TYPE, req->sb_pool_type);\n\tif (req->_present.sb_tc_index)\n\t\tmnl_attr_put_u16(nlh, DEVLINK_ATTR_SB_TC_INDEX, req->sb_tc_index);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_sb_tc_pool_bind_get_rsp_parse;\n\tyrs.rsp_cmd = 25;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_sb_tc_pool_bind_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid\ndevlink_sb_tc_pool_bind_get_list_free(struct devlink_sb_tc_pool_bind_get_list *rsp)\n{\n\tstruct devlink_sb_tc_pool_bind_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_sb_tc_pool_bind_get_list *\ndevlink_sb_tc_pool_bind_get_dump(struct ynl_sock *ys,\n\t\t\t\t struct devlink_sb_tc_pool_bind_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_sb_tc_pool_bind_get_list);\n\tyds.cb = devlink_sb_tc_pool_bind_get_rsp_parse;\n\tyds.rsp_cmd = 25;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_SB_TC_POOL_BIND_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_sb_tc_pool_bind_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid devlink_param_get_req_free(struct devlink_param_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req->param_name);\n\tfree(req);\n}\n\nvoid devlink_param_get_rsp_free(struct devlink_param_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp->param_name);\n\tfree(rsp);\n}\n\nint devlink_param_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct devlink_param_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_PARAM_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.param_name_len = len;\n\t\t\tdst->param_name = malloc(len + 1);\n\t\t\tmemcpy(dst->param_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->param_name[len] = 0;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_param_get_rsp *\ndevlink_param_get(struct ynl_sock *ys, struct devlink_param_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_param_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_PARAM_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.param_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_PARAM_NAME, req->param_name);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_param_get_rsp_parse;\n\tyrs.rsp_cmd = DEVLINK_CMD_PARAM_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_param_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid devlink_param_get_list_free(struct devlink_param_get_list *rsp)\n{\n\tstruct devlink_param_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp->obj.param_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_param_get_list *\ndevlink_param_get_dump(struct ynl_sock *ys,\n\t\t       struct devlink_param_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_param_get_list);\n\tyds.cb = devlink_param_get_rsp_parse;\n\tyds.rsp_cmd = DEVLINK_CMD_PARAM_GET;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_PARAM_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_param_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid devlink_region_get_req_free(struct devlink_region_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req->region_name);\n\tfree(req);\n}\n\nvoid devlink_region_get_rsp_free(struct devlink_region_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp->region_name);\n\tfree(rsp);\n}\n\nint devlink_region_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct devlink_region_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_PORT_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.port_index = 1;\n\t\t\tdst->port_index = mnl_attr_get_u32(attr);\n\t\t} else if (type == DEVLINK_ATTR_REGION_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.region_name_len = len;\n\t\t\tdst->region_name = malloc(len + 1);\n\t\t\tmemcpy(dst->region_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->region_name[len] = 0;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_region_get_rsp *\ndevlink_region_get(struct ynl_sock *ys, struct devlink_region_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_region_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_REGION_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.port_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_PORT_INDEX, req->port_index);\n\tif (req->_present.region_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_REGION_NAME, req->region_name);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_region_get_rsp_parse;\n\tyrs.rsp_cmd = DEVLINK_CMD_REGION_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_region_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid devlink_region_get_list_free(struct devlink_region_get_list *rsp)\n{\n\tstruct devlink_region_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp->obj.region_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_region_get_list *\ndevlink_region_get_dump(struct ynl_sock *ys,\n\t\t\tstruct devlink_region_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_region_get_list);\n\tyds.cb = devlink_region_get_rsp_parse;\n\tyds.rsp_cmd = DEVLINK_CMD_REGION_GET;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_REGION_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_region_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid devlink_info_get_req_free(struct devlink_info_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req);\n}\n\nvoid devlink_info_get_rsp_free(struct devlink_info_get_rsp *rsp)\n{\n\tunsigned int i;\n\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp->info_driver_name);\n\tfree(rsp->info_serial_number);\n\tfor (i = 0; i < rsp->n_info_version_fixed; i++)\n\t\tdevlink_dl_info_version_free(&rsp->info_version_fixed[i]);\n\tfree(rsp->info_version_fixed);\n\tfor (i = 0; i < rsp->n_info_version_running; i++)\n\t\tdevlink_dl_info_version_free(&rsp->info_version_running[i]);\n\tfree(rsp->info_version_running);\n\tfor (i = 0; i < rsp->n_info_version_stored; i++)\n\t\tdevlink_dl_info_version_free(&rsp->info_version_stored[i]);\n\tfree(rsp->info_version_stored);\n\tfree(rsp);\n}\n\nint devlink_info_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tunsigned int n_info_version_running = 0;\n\tunsigned int n_info_version_stored = 0;\n\tunsigned int n_info_version_fixed = 0;\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct devlink_info_get_rsp *dst;\n\tconst struct nlattr *attr;\n\tstruct ynl_parse_arg parg;\n\tint i;\n\n\tdst = yarg->data;\n\tparg.ys = yarg->ys;\n\n\tif (dst->info_version_fixed)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (devlink.info-version-fixed)\");\n\tif (dst->info_version_running)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (devlink.info-version-running)\");\n\tif (dst->info_version_stored)\n\t\treturn ynl_error_parse(yarg, \"attribute already present (devlink.info-version-stored)\");\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_INFO_DRIVER_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.info_driver_name_len = len;\n\t\t\tdst->info_driver_name = malloc(len + 1);\n\t\t\tmemcpy(dst->info_driver_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->info_driver_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_INFO_SERIAL_NUMBER) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.info_serial_number_len = len;\n\t\t\tdst->info_serial_number = malloc(len + 1);\n\t\t\tmemcpy(dst->info_serial_number, mnl_attr_get_str(attr), len);\n\t\t\tdst->info_serial_number[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_INFO_VERSION_FIXED) {\n\t\t\tn_info_version_fixed++;\n\t\t} else if (type == DEVLINK_ATTR_INFO_VERSION_RUNNING) {\n\t\t\tn_info_version_running++;\n\t\t} else if (type == DEVLINK_ATTR_INFO_VERSION_STORED) {\n\t\t\tn_info_version_stored++;\n\t\t}\n\t}\n\n\tif (n_info_version_fixed) {\n\t\tdst->info_version_fixed = calloc(n_info_version_fixed, sizeof(*dst->info_version_fixed));\n\t\tdst->n_info_version_fixed = n_info_version_fixed;\n\t\ti = 0;\n\t\tparg.rsp_policy = &devlink_dl_info_version_nest;\n\t\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\t\tif (mnl_attr_get_type(attr) == DEVLINK_ATTR_INFO_VERSION_FIXED) {\n\t\t\t\tparg.data = &dst->info_version_fixed[i];\n\t\t\t\tif (devlink_dl_info_version_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n_info_version_running) {\n\t\tdst->info_version_running = calloc(n_info_version_running, sizeof(*dst->info_version_running));\n\t\tdst->n_info_version_running = n_info_version_running;\n\t\ti = 0;\n\t\tparg.rsp_policy = &devlink_dl_info_version_nest;\n\t\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\t\tif (mnl_attr_get_type(attr) == DEVLINK_ATTR_INFO_VERSION_RUNNING) {\n\t\t\t\tparg.data = &dst->info_version_running[i];\n\t\t\t\tif (devlink_dl_info_version_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n_info_version_stored) {\n\t\tdst->info_version_stored = calloc(n_info_version_stored, sizeof(*dst->info_version_stored));\n\t\tdst->n_info_version_stored = n_info_version_stored;\n\t\ti = 0;\n\t\tparg.rsp_policy = &devlink_dl_info_version_nest;\n\t\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\t\tif (mnl_attr_get_type(attr) == DEVLINK_ATTR_INFO_VERSION_STORED) {\n\t\t\t\tparg.data = &dst->info_version_stored[i];\n\t\t\t\tif (devlink_dl_info_version_parse(&parg, attr))\n\t\t\t\t\treturn MNL_CB_ERROR;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_info_get_rsp *\ndevlink_info_get(struct ynl_sock *ys, struct devlink_info_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_info_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_INFO_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_info_get_rsp_parse;\n\tyrs.rsp_cmd = DEVLINK_CMD_INFO_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_info_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid devlink_info_get_list_free(struct devlink_info_get_list *rsp)\n{\n\tstruct devlink_info_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\tunsigned int i;\n\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp->obj.info_driver_name);\n\t\tfree(rsp->obj.info_serial_number);\n\t\tfor (i = 0; i < rsp->obj.n_info_version_fixed; i++)\n\t\t\tdevlink_dl_info_version_free(&rsp->obj.info_version_fixed[i]);\n\t\tfree(rsp->obj.info_version_fixed);\n\t\tfor (i = 0; i < rsp->obj.n_info_version_running; i++)\n\t\t\tdevlink_dl_info_version_free(&rsp->obj.info_version_running[i]);\n\t\tfree(rsp->obj.info_version_running);\n\t\tfor (i = 0; i < rsp->obj.n_info_version_stored; i++)\n\t\t\tdevlink_dl_info_version_free(&rsp->obj.info_version_stored[i]);\n\t\tfree(rsp->obj.info_version_stored);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_info_get_list *devlink_info_get_dump(struct ynl_sock *ys)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_info_get_list);\n\tyds.cb = devlink_info_get_rsp_parse;\n\tyds.rsp_cmd = DEVLINK_CMD_INFO_GET;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_INFO_GET, 1);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_info_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid\ndevlink_health_reporter_get_req_free(struct devlink_health_reporter_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req->health_reporter_name);\n\tfree(req);\n}\n\nvoid\ndevlink_health_reporter_get_rsp_free(struct devlink_health_reporter_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp->health_reporter_name);\n\tfree(rsp);\n}\n\nint devlink_health_reporter_get_rsp_parse(const struct nlmsghdr *nlh,\n\t\t\t\t\t  void *data)\n{\n\tstruct devlink_health_reporter_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_PORT_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.port_index = 1;\n\t\t\tdst->port_index = mnl_attr_get_u32(attr);\n\t\t} else if (type == DEVLINK_ATTR_HEALTH_REPORTER_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.health_reporter_name_len = len;\n\t\t\tdst->health_reporter_name = malloc(len + 1);\n\t\t\tmemcpy(dst->health_reporter_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->health_reporter_name[len] = 0;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_health_reporter_get_rsp *\ndevlink_health_reporter_get(struct ynl_sock *ys,\n\t\t\t    struct devlink_health_reporter_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_health_reporter_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_HEALTH_REPORTER_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.port_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_PORT_INDEX, req->port_index);\n\tif (req->_present.health_reporter_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_HEALTH_REPORTER_NAME, req->health_reporter_name);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_health_reporter_get_rsp_parse;\n\tyrs.rsp_cmd = DEVLINK_CMD_HEALTH_REPORTER_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_health_reporter_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid\ndevlink_health_reporter_get_list_free(struct devlink_health_reporter_get_list *rsp)\n{\n\tstruct devlink_health_reporter_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp->obj.health_reporter_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_health_reporter_get_list *\ndevlink_health_reporter_get_dump(struct ynl_sock *ys,\n\t\t\t\t struct devlink_health_reporter_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_health_reporter_get_list);\n\tyds.cb = devlink_health_reporter_get_rsp_parse;\n\tyds.rsp_cmd = DEVLINK_CMD_HEALTH_REPORTER_GET;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_HEALTH_REPORTER_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.port_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_PORT_INDEX, req->port_index);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_health_reporter_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid devlink_trap_get_req_free(struct devlink_trap_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req->trap_name);\n\tfree(req);\n}\n\nvoid devlink_trap_get_rsp_free(struct devlink_trap_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp->trap_name);\n\tfree(rsp);\n}\n\nint devlink_trap_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct devlink_trap_get_rsp *dst;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_TRAP_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.trap_name_len = len;\n\t\t\tdst->trap_name = malloc(len + 1);\n\t\t\tmemcpy(dst->trap_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->trap_name[len] = 0;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_trap_get_rsp *\ndevlink_trap_get(struct ynl_sock *ys, struct devlink_trap_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_trap_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_TRAP_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.trap_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_TRAP_NAME, req->trap_name);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_trap_get_rsp_parse;\n\tyrs.rsp_cmd = 63;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_trap_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid devlink_trap_get_list_free(struct devlink_trap_get_list *rsp)\n{\n\tstruct devlink_trap_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp->obj.trap_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_trap_get_list *\ndevlink_trap_get_dump(struct ynl_sock *ys,\n\t\t      struct devlink_trap_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_trap_get_list);\n\tyds.cb = devlink_trap_get_rsp_parse;\n\tyds.rsp_cmd = 63;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_TRAP_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_trap_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid devlink_trap_group_get_req_free(struct devlink_trap_group_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req->trap_group_name);\n\tfree(req);\n}\n\nvoid devlink_trap_group_get_rsp_free(struct devlink_trap_group_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp->trap_group_name);\n\tfree(rsp);\n}\n\nint devlink_trap_group_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct devlink_trap_group_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_TRAP_GROUP_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.trap_group_name_len = len;\n\t\t\tdst->trap_group_name = malloc(len + 1);\n\t\t\tmemcpy(dst->trap_group_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->trap_group_name[len] = 0;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_trap_group_get_rsp *\ndevlink_trap_group_get(struct ynl_sock *ys,\n\t\t       struct devlink_trap_group_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_trap_group_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_TRAP_GROUP_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.trap_group_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_TRAP_GROUP_NAME, req->trap_group_name);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_trap_group_get_rsp_parse;\n\tyrs.rsp_cmd = 67;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_trap_group_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid devlink_trap_group_get_list_free(struct devlink_trap_group_get_list *rsp)\n{\n\tstruct devlink_trap_group_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp->obj.trap_group_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_trap_group_get_list *\ndevlink_trap_group_get_dump(struct ynl_sock *ys,\n\t\t\t    struct devlink_trap_group_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_trap_group_get_list);\n\tyds.cb = devlink_trap_group_get_rsp_parse;\n\tyds.rsp_cmd = 67;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_TRAP_GROUP_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_trap_group_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid\ndevlink_trap_policer_get_req_free(struct devlink_trap_policer_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req);\n}\n\nvoid\ndevlink_trap_policer_get_rsp_free(struct devlink_trap_policer_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp);\n}\n\nint devlink_trap_policer_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct devlink_trap_policer_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_TRAP_POLICER_ID) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.trap_policer_id = 1;\n\t\t\tdst->trap_policer_id = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_trap_policer_get_rsp *\ndevlink_trap_policer_get(struct ynl_sock *ys,\n\t\t\t struct devlink_trap_policer_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_trap_policer_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_TRAP_POLICER_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.trap_policer_id)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_TRAP_POLICER_ID, req->trap_policer_id);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_trap_policer_get_rsp_parse;\n\tyrs.rsp_cmd = 71;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_trap_policer_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid\ndevlink_trap_policer_get_list_free(struct devlink_trap_policer_get_list *rsp)\n{\n\tstruct devlink_trap_policer_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_trap_policer_get_list *\ndevlink_trap_policer_get_dump(struct ynl_sock *ys,\n\t\t\t      struct devlink_trap_policer_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_trap_policer_get_list);\n\tyds.cb = devlink_trap_policer_get_rsp_parse;\n\tyds.rsp_cmd = 71;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_TRAP_POLICER_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_trap_policer_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid devlink_rate_get_req_free(struct devlink_rate_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req->rate_node_name);\n\tfree(req);\n}\n\nvoid devlink_rate_get_rsp_free(struct devlink_rate_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp->rate_node_name);\n\tfree(rsp);\n}\n\nint devlink_rate_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tstruct devlink_rate_get_rsp *dst;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_PORT_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.port_index = 1;\n\t\t\tdst->port_index = mnl_attr_get_u32(attr);\n\t\t} else if (type == DEVLINK_ATTR_RATE_NODE_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.rate_node_name_len = len;\n\t\t\tdst->rate_node_name = malloc(len + 1);\n\t\t\tmemcpy(dst->rate_node_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->rate_node_name[len] = 0;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_rate_get_rsp *\ndevlink_rate_get(struct ynl_sock *ys, struct devlink_rate_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_rate_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_RATE_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.port_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_PORT_INDEX, req->port_index);\n\tif (req->_present.rate_node_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_RATE_NODE_NAME, req->rate_node_name);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_rate_get_rsp_parse;\n\tyrs.rsp_cmd = 76;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_rate_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid devlink_rate_get_list_free(struct devlink_rate_get_list *rsp)\n{\n\tstruct devlink_rate_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp->obj.rate_node_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_rate_get_list *\ndevlink_rate_get_dump(struct ynl_sock *ys,\n\t\t      struct devlink_rate_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_rate_get_list);\n\tyds.cb = devlink_rate_get_rsp_parse;\n\tyds.rsp_cmd = 76;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_RATE_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_rate_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid devlink_linecard_get_req_free(struct devlink_linecard_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req);\n}\n\nvoid devlink_linecard_get_rsp_free(struct devlink_linecard_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp);\n}\n\nint devlink_linecard_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct devlink_linecard_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_LINECARD_INDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.linecard_index = 1;\n\t\t\tdst->linecard_index = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_linecard_get_rsp *\ndevlink_linecard_get(struct ynl_sock *ys, struct devlink_linecard_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_linecard_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_LINECARD_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\tif (req->_present.linecard_index)\n\t\tmnl_attr_put_u32(nlh, DEVLINK_ATTR_LINECARD_INDEX, req->linecard_index);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_linecard_get_rsp_parse;\n\tyrs.rsp_cmd = 80;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_linecard_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid devlink_linecard_get_list_free(struct devlink_linecard_get_list *rsp)\n{\n\tstruct devlink_linecard_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_linecard_get_list *\ndevlink_linecard_get_dump(struct ynl_sock *ys,\n\t\t\t  struct devlink_linecard_get_req_dump *req)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_linecard_get_list);\n\tyds.cb = devlink_linecard_get_rsp_parse;\n\tyds.rsp_cmd = 80;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_LINECARD_GET, 1);\n\tys->req_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_linecard_get_list_free(yds.first);\n\treturn NULL;\n}\n\n \n \nvoid devlink_selftests_get_req_free(struct devlink_selftests_get_req *req)\n{\n\tfree(req->bus_name);\n\tfree(req->dev_name);\n\tfree(req);\n}\n\nvoid devlink_selftests_get_rsp_free(struct devlink_selftests_get_rsp *rsp)\n{\n\tfree(rsp->bus_name);\n\tfree(rsp->dev_name);\n\tfree(rsp);\n}\n\nint devlink_selftests_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct devlink_selftests_get_rsp *dst;\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == DEVLINK_ATTR_BUS_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.bus_name_len = len;\n\t\t\tdst->bus_name = malloc(len + 1);\n\t\t\tmemcpy(dst->bus_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->bus_name[len] = 0;\n\t\t} else if (type == DEVLINK_ATTR_DEV_NAME) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));\n\t\t\tdst->_present.dev_name_len = len;\n\t\t\tdst->dev_name = malloc(len + 1);\n\t\t\tmemcpy(dst->dev_name, mnl_attr_get_str(attr), len);\n\t\t\tdst->dev_name[len] = 0;\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct devlink_selftests_get_rsp *\ndevlink_selftests_get(struct ynl_sock *ys,\n\t\t      struct devlink_selftests_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct devlink_selftests_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, DEVLINK_CMD_SELFTESTS_GET, 1);\n\tys->req_policy = &devlink_nest;\n\tyrs.yarg.rsp_policy = &devlink_nest;\n\n\tif (req->_present.bus_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_BUS_NAME, req->bus_name);\n\tif (req->_present.dev_name_len)\n\t\tmnl_attr_put_strz(nlh, DEVLINK_ATTR_DEV_NAME, req->dev_name);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = devlink_selftests_get_rsp_parse;\n\tyrs.rsp_cmd = DEVLINK_CMD_SELFTESTS_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tdevlink_selftests_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid devlink_selftests_get_list_free(struct devlink_selftests_get_list *rsp)\n{\n\tstruct devlink_selftests_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.bus_name);\n\t\tfree(rsp->obj.dev_name);\n\t\tfree(rsp);\n\t}\n}\n\nstruct devlink_selftests_get_list *\ndevlink_selftests_get_dump(struct ynl_sock *ys)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct devlink_selftests_get_list);\n\tyds.cb = devlink_selftests_get_rsp_parse;\n\tyds.rsp_cmd = DEVLINK_CMD_SELFTESTS_GET;\n\tyds.rsp_policy = &devlink_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, DEVLINK_CMD_SELFTESTS_GET, 1);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tdevlink_selftests_get_list_free(yds.first);\n\treturn NULL;\n}\n\nconst struct ynl_family ynl_devlink_family =  {\n\t.name\t\t= \"devlink\",\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}