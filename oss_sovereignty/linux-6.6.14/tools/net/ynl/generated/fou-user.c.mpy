{
  "module_name": "fou-user.c",
  "hash_id": "57884fac688be095b6f8066cfaa58943956016699353bc9d435324da70667ab7",
  "original_prompt": "Ingested from linux-6.6.14/tools/net/ynl/generated/fou-user.c",
  "human_readable_source": "\n \n \n \n\n#include <stdlib.h>\n#include <string.h>\n#include \"fou-user.h\"\n#include \"ynl.h\"\n#include <linux/fou.h>\n\n#include <libmnl/libmnl.h>\n#include <linux/genetlink.h>\n\n \nstatic const char * const fou_op_strmap[] = {\n\t[FOU_CMD_ADD] = \"add\",\n\t[FOU_CMD_DEL] = \"del\",\n\t[FOU_CMD_GET] = \"get\",\n};\n\nconst char *fou_op_str(int op)\n{\n\tif (op < 0 || op >= (int)MNL_ARRAY_SIZE(fou_op_strmap))\n\t\treturn NULL;\n\treturn fou_op_strmap[op];\n}\n\nstatic const char * const fou_encap_type_strmap[] = {\n\t[0] = \"unspec\",\n\t[1] = \"direct\",\n\t[2] = \"gue\",\n};\n\nconst char *fou_encap_type_str(int value)\n{\n\tif (value < 0 || value >= (int)MNL_ARRAY_SIZE(fou_encap_type_strmap))\n\t\treturn NULL;\n\treturn fou_encap_type_strmap[value];\n}\n\n \nstruct ynl_policy_attr fou_policy[FOU_ATTR_MAX + 1] = {\n\t[FOU_ATTR_UNSPEC] = { .name = \"unspec\", .type = YNL_PT_REJECT, },\n\t[FOU_ATTR_PORT] = { .name = \"port\", .type = YNL_PT_U16, },\n\t[FOU_ATTR_AF] = { .name = \"af\", .type = YNL_PT_U8, },\n\t[FOU_ATTR_IPPROTO] = { .name = \"ipproto\", .type = YNL_PT_U8, },\n\t[FOU_ATTR_TYPE] = { .name = \"type\", .type = YNL_PT_U8, },\n\t[FOU_ATTR_REMCSUM_NOPARTIAL] = { .name = \"remcsum_nopartial\", .type = YNL_PT_FLAG, },\n\t[FOU_ATTR_LOCAL_V4] = { .name = \"local_v4\", .type = YNL_PT_U32, },\n\t[FOU_ATTR_LOCAL_V6] = { .name = \"local_v6\", .type = YNL_PT_BINARY,},\n\t[FOU_ATTR_PEER_V4] = { .name = \"peer_v4\", .type = YNL_PT_U32, },\n\t[FOU_ATTR_PEER_V6] = { .name = \"peer_v6\", .type = YNL_PT_BINARY,},\n\t[FOU_ATTR_PEER_PORT] = { .name = \"peer_port\", .type = YNL_PT_U16, },\n\t[FOU_ATTR_IFINDEX] = { .name = \"ifindex\", .type = YNL_PT_U32, },\n};\n\nstruct ynl_policy_nest fou_nest = {\n\t.max_attr = FOU_ATTR_MAX,\n\t.table = fou_policy,\n};\n\n \n \n \nvoid fou_add_req_free(struct fou_add_req *req)\n{\n\tfree(req->local_v6);\n\tfree(req->peer_v6);\n\tfree(req);\n}\n\nint fou_add(struct ynl_sock *ys, struct fou_add_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, FOU_CMD_ADD, 1);\n\tys->req_policy = &fou_nest;\n\n\tif (req->_present.port)\n\t\tmnl_attr_put_u16(nlh, FOU_ATTR_PORT, req->port);\n\tif (req->_present.ipproto)\n\t\tmnl_attr_put_u8(nlh, FOU_ATTR_IPPROTO, req->ipproto);\n\tif (req->_present.type)\n\t\tmnl_attr_put_u8(nlh, FOU_ATTR_TYPE, req->type);\n\tif (req->_present.remcsum_nopartial)\n\t\tmnl_attr_put(nlh, FOU_ATTR_REMCSUM_NOPARTIAL, 0, NULL);\n\tif (req->_present.local_v4)\n\t\tmnl_attr_put_u32(nlh, FOU_ATTR_LOCAL_V4, req->local_v4);\n\tif (req->_present.peer_v4)\n\t\tmnl_attr_put_u32(nlh, FOU_ATTR_PEER_V4, req->peer_v4);\n\tif (req->_present.local_v6_len)\n\t\tmnl_attr_put(nlh, FOU_ATTR_LOCAL_V6, req->_present.local_v6_len, req->local_v6);\n\tif (req->_present.peer_v6_len)\n\t\tmnl_attr_put(nlh, FOU_ATTR_PEER_V6, req->_present.peer_v6_len, req->peer_v6);\n\tif (req->_present.peer_port)\n\t\tmnl_attr_put_u16(nlh, FOU_ATTR_PEER_PORT, req->peer_port);\n\tif (req->_present.ifindex)\n\t\tmnl_attr_put_u32(nlh, FOU_ATTR_IFINDEX, req->ifindex);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid fou_del_req_free(struct fou_del_req *req)\n{\n\tfree(req->local_v6);\n\tfree(req->peer_v6);\n\tfree(req);\n}\n\nint fou_del(struct ynl_sock *ys, struct fou_del_req *req)\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, FOU_CMD_DEL, 1);\n\tys->req_policy = &fou_nest;\n\n\tif (req->_present.af)\n\t\tmnl_attr_put_u8(nlh, FOU_ATTR_AF, req->af);\n\tif (req->_present.ifindex)\n\t\tmnl_attr_put_u32(nlh, FOU_ATTR_IFINDEX, req->ifindex);\n\tif (req->_present.port)\n\t\tmnl_attr_put_u16(nlh, FOU_ATTR_PORT, req->port);\n\tif (req->_present.peer_port)\n\t\tmnl_attr_put_u16(nlh, FOU_ATTR_PEER_PORT, req->peer_port);\n\tif (req->_present.local_v4)\n\t\tmnl_attr_put_u32(nlh, FOU_ATTR_LOCAL_V4, req->local_v4);\n\tif (req->_present.peer_v4)\n\t\tmnl_attr_put_u32(nlh, FOU_ATTR_PEER_V4, req->peer_v4);\n\tif (req->_present.local_v6_len)\n\t\tmnl_attr_put(nlh, FOU_ATTR_LOCAL_V6, req->_present.local_v6_len, req->local_v6);\n\tif (req->_present.peer_v6_len)\n\t\tmnl_attr_put(nlh, FOU_ATTR_PEER_V6, req->_present.peer_v6_len, req->peer_v6);\n\n\terr = ynl_exec(ys, nlh, NULL);\n\tif (err < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n \nvoid fou_get_req_free(struct fou_get_req *req)\n{\n\tfree(req->local_v6);\n\tfree(req->peer_v6);\n\tfree(req);\n}\n\nvoid fou_get_rsp_free(struct fou_get_rsp *rsp)\n{\n\tfree(rsp->local_v6);\n\tfree(rsp->peer_v6);\n\tfree(rsp);\n}\n\nint fou_get_rsp_parse(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct ynl_parse_arg *yarg = data;\n\tconst struct nlattr *attr;\n\tstruct fou_get_rsp *dst;\n\n\tdst = yarg->data;\n\n\tmnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr)) {\n\t\tunsigned int type = mnl_attr_get_type(attr);\n\n\t\tif (type == FOU_ATTR_PORT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.port = 1;\n\t\t\tdst->port = mnl_attr_get_u16(attr);\n\t\t} else if (type == FOU_ATTR_IPPROTO) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.ipproto = 1;\n\t\t\tdst->ipproto = mnl_attr_get_u8(attr);\n\t\t} else if (type == FOU_ATTR_TYPE) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.type = 1;\n\t\t\tdst->type = mnl_attr_get_u8(attr);\n\t\t} else if (type == FOU_ATTR_REMCSUM_NOPARTIAL) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.remcsum_nopartial = 1;\n\t\t} else if (type == FOU_ATTR_LOCAL_V4) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.local_v4 = 1;\n\t\t\tdst->local_v4 = mnl_attr_get_u32(attr);\n\t\t} else if (type == FOU_ATTR_PEER_V4) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.peer_v4 = 1;\n\t\t\tdst->peer_v4 = mnl_attr_get_u32(attr);\n\t\t} else if (type == FOU_ATTR_LOCAL_V6) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = mnl_attr_get_payload_len(attr);\n\t\t\tdst->_present.local_v6_len = len;\n\t\t\tdst->local_v6 = malloc(len);\n\t\t\tmemcpy(dst->local_v6, mnl_attr_get_payload(attr), len);\n\t\t} else if (type == FOU_ATTR_PEER_V6) {\n\t\t\tunsigned int len;\n\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\n\t\t\tlen = mnl_attr_get_payload_len(attr);\n\t\t\tdst->_present.peer_v6_len = len;\n\t\t\tdst->peer_v6 = malloc(len);\n\t\t\tmemcpy(dst->peer_v6, mnl_attr_get_payload(attr), len);\n\t\t} else if (type == FOU_ATTR_PEER_PORT) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.peer_port = 1;\n\t\t\tdst->peer_port = mnl_attr_get_u16(attr);\n\t\t} else if (type == FOU_ATTR_IFINDEX) {\n\t\t\tif (ynl_attr_validate(yarg, attr))\n\t\t\t\treturn MNL_CB_ERROR;\n\t\t\tdst->_present.ifindex = 1;\n\t\t\tdst->ifindex = mnl_attr_get_u32(attr);\n\t\t}\n\t}\n\n\treturn MNL_CB_OK;\n}\n\nstruct fou_get_rsp *fou_get(struct ynl_sock *ys, struct fou_get_req *req)\n{\n\tstruct ynl_req_state yrs = { .yarg = { .ys = ys, }, };\n\tstruct fou_get_rsp *rsp;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = ynl_gemsg_start_req(ys, ys->family_id, FOU_CMD_GET, 1);\n\tys->req_policy = &fou_nest;\n\tyrs.yarg.rsp_policy = &fou_nest;\n\n\tif (req->_present.af)\n\t\tmnl_attr_put_u8(nlh, FOU_ATTR_AF, req->af);\n\tif (req->_present.ifindex)\n\t\tmnl_attr_put_u32(nlh, FOU_ATTR_IFINDEX, req->ifindex);\n\tif (req->_present.port)\n\t\tmnl_attr_put_u16(nlh, FOU_ATTR_PORT, req->port);\n\tif (req->_present.peer_port)\n\t\tmnl_attr_put_u16(nlh, FOU_ATTR_PEER_PORT, req->peer_port);\n\tif (req->_present.local_v4)\n\t\tmnl_attr_put_u32(nlh, FOU_ATTR_LOCAL_V4, req->local_v4);\n\tif (req->_present.peer_v4)\n\t\tmnl_attr_put_u32(nlh, FOU_ATTR_PEER_V4, req->peer_v4);\n\tif (req->_present.local_v6_len)\n\t\tmnl_attr_put(nlh, FOU_ATTR_LOCAL_V6, req->_present.local_v6_len, req->local_v6);\n\tif (req->_present.peer_v6_len)\n\t\tmnl_attr_put(nlh, FOU_ATTR_PEER_V6, req->_present.peer_v6_len, req->peer_v6);\n\n\trsp = calloc(1, sizeof(*rsp));\n\tyrs.yarg.data = rsp;\n\tyrs.cb = fou_get_rsp_parse;\n\tyrs.rsp_cmd = FOU_CMD_GET;\n\n\terr = ynl_exec(ys, nlh, &yrs);\n\tif (err < 0)\n\t\tgoto err_free;\n\n\treturn rsp;\n\nerr_free:\n\tfou_get_rsp_free(rsp);\n\treturn NULL;\n}\n\n \nvoid fou_get_list_free(struct fou_get_list *rsp)\n{\n\tstruct fou_get_list *next = rsp;\n\n\twhile ((void *)next != YNL_LIST_END) {\n\t\trsp = next;\n\t\tnext = rsp->next;\n\n\t\tfree(rsp->obj.local_v6);\n\t\tfree(rsp->obj.peer_v6);\n\t\tfree(rsp);\n\t}\n}\n\nstruct fou_get_list *fou_get_dump(struct ynl_sock *ys)\n{\n\tstruct ynl_dump_state yds = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tyds.ys = ys;\n\tyds.alloc_sz = sizeof(struct fou_get_list);\n\tyds.cb = fou_get_rsp_parse;\n\tyds.rsp_cmd = FOU_CMD_GET;\n\tyds.rsp_policy = &fou_nest;\n\n\tnlh = ynl_gemsg_start_dump(ys, ys->family_id, FOU_CMD_GET, 1);\n\n\terr = ynl_exec_dump(ys, nlh, &yds);\n\tif (err < 0)\n\t\tgoto free_list;\n\n\treturn yds.first;\n\nfree_list:\n\tfou_get_list_free(yds.first);\n\treturn NULL;\n}\n\nconst struct ynl_family ynl_fou_family =  {\n\t.name\t\t= \"fou\",\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}