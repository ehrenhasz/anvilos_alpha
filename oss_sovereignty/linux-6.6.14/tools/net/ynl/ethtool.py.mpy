{
  "module_name": "ethtool.py",
  "hash_id": "29e503ac187202665147639ad4082c6246be4fc709a496909dd5862fb1087d9f",
  "original_prompt": "Ingested from linux-6.6.14/tools/net/ynl/ethtool.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause\n\nimport argparse\nimport json\nimport pprint\nimport sys\nimport re\n\nfrom lib import YnlFamily\n\ndef args_to_req(ynl, op_name, args, req):\n    \"\"\"\n    Verify and convert command-line arguments to the ynl-compatible request.\n    \"\"\"\n    valid_attrs = ynl.operation_do_attributes(op_name)\n    valid_attrs.remove('header') # not user-provided\n\n    if len(args) == 0:\n        print(f'no attributes, expected: {valid_attrs}')\n        sys.exit(1)\n\n    i = 0\n    while i < len(args):\n        attr = args[i]\n        if i + 1 >= len(args):\n            print(f'expected value for \\'{attr}\\'')\n            sys.exit(1)\n\n        if attr not in valid_attrs:\n            print(f'invalid attribute \\'{attr}\\', expected: {valid_attrs}')\n            sys.exit(1)\n\n        val = args[i+1]\n        i += 2\n\n        req[attr] = val\n\ndef print_field(reply, *desc):\n    \"\"\"\n    Pretty-print a set of fields from the reply. desc specifies the\n    fields and the optional type (bool/yn).\n    \"\"\"\n    if len(desc) == 0:\n        return print_field(reply, *zip(reply.keys(), reply.keys()))\n\n    for spec in desc:\n        try:\n            field, name, tp = spec\n        except:\n            field, name = spec\n            tp = 'int'\n\n        value = reply.get(field, None)\n        if tp == 'yn':\n            value = 'yes' if value else 'no'\n        elif tp == 'bool' or isinstance(value, bool):\n            value = 'on' if value else 'off'\n        else:\n            value = 'n/a' if value is None else value\n\n        print(f'{name}: {value}')\n\ndef print_speed(name, value):\n    \"\"\"\n    Print out the speed-like strings from the value dict.\n    \"\"\"\n    speed_re = re.compile(r'[0-9]+base[^/]+/.+')\n    speed = [ k for k, v in value.items() if v and speed_re.match(k) ]\n    print(f'{name}: {\" \".join(speed)}')\n\ndef doit(ynl, args, op_name):\n    \"\"\"\n    Prepare request header, parse arguments and doit.\n    \"\"\"\n    req = {\n        'header': {\n          'dev-name': args.device,\n        },\n    }\n\n    args_to_req(ynl, op_name, args.args, req)\n    ynl.do(op_name, req)\n\ndef dumpit(ynl, args, op_name, extra = {}):\n    \"\"\"\n    Prepare request header, parse arguments and dumpit (filtering out the\n    devices we're not interested in).\n    \"\"\"\n    reply = ynl.dump(op_name, { 'header': {} } | extra)\n    if not reply:\n        return {}\n\n    for msg in reply:\n        if msg['header']['dev-name'] == args.device:\n            if args.json:\n                pprint.PrettyPrinter().pprint(msg)\n                sys.exit(0)\n            msg.pop('header', None)\n            return msg\n\n    print(f\"Not supported for device {args.device}\")\n    sys.exit(1)\n\ndef bits_to_dict(attr):\n    \"\"\"\n    Convert ynl-formatted bitmask to a dict of bit=value.\n    \"\"\"\n    ret = {}\n    if 'bits' not in attr:\n        return dict()\n    if 'bit' not in attr['bits']:\n        return dict()\n    for bit in attr['bits']['bit']:\n        if bit['name'] == '':\n            continue\n        name = bit['name']\n        value = bit.get('value', False)\n        ret[name] = value\n    return ret\n\ndef main():\n    parser = argparse.ArgumentParser(description='ethtool wannabe')\n    parser.add_argument('--json', action=argparse.BooleanOptionalAction)\n    parser.add_argument('--show-priv-flags', action=argparse.BooleanOptionalAction)\n    parser.add_argument('--set-priv-flags', action=argparse.BooleanOptionalAction)\n    parser.add_argument('--show-eee', action=argparse.BooleanOptionalAction)\n    parser.add_argument('--set-eee', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-a', '--show-pause', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-A', '--set-pause', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-c', '--show-coalesce', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-C', '--set-coalesce', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-g', '--show-ring', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-G', '--set-ring', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-k', '--show-features', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-K', '--set-features', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-l', '--show-channels', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-L', '--set-channels', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-T', '--show-time-stamping', action=argparse.BooleanOptionalAction)\n    parser.add_argument('-S', '--statistics', action=argparse.BooleanOptionalAction)\n    # TODO: --show-tunnels        tunnel-info-get\n    # TODO: --show-module         module-get\n    # TODO: --get-plca-cfg        plca-get\n    # TODO: --get-plca-status     plca-get-status\n    # TODO: --show-mm             mm-get\n    # TODO: --show-fec            fec-get\n    # TODO: --dump-module-eerpom  module-eeprom-get\n    # TODO:                       pse-get\n    # TODO:                       rss-get\n    parser.add_argument('device', metavar='device', type=str)\n    parser.add_argument('args', metavar='args', type=str, nargs='*')\n    global args\n    args = parser.parse_args()\n\n    spec = '../../../Documentation/netlink/specs/ethtool.yaml'\n    schema = '../../../Documentation/netlink/genetlink-legacy.yaml'\n\n    ynl = YnlFamily(spec, schema)\n\n    if args.set_priv_flags:\n        # TODO: parse the bitmask\n        print(\"not implemented\")\n        return\n\n    if args.set_eee:\n        return doit(ynl, args, 'eee-set')\n\n    if args.set_pause:\n        return doit(ynl, args, 'pause-set')\n\n    if args.set_coalesce:\n        return doit(ynl, args, 'coalesce-set')\n\n    if args.set_features:\n        # TODO: parse the bitmask\n        print(\"not implemented\")\n        return\n\n    if args.set_channels:\n        return doit(ynl, args, 'channels-set')\n\n    if args.set_ring:\n        return doit(ynl, args, 'rings-set')\n\n    if args.show_priv_flags:\n        flags = bits_to_dict(dumpit(ynl, args, 'privflags-get')['flags'])\n        print_field(flags)\n        return\n\n    if args.show_eee:\n        eee = dumpit(ynl, args, 'eee-get')\n        ours = bits_to_dict(eee['modes-ours'])\n        peer = bits_to_dict(eee['modes-peer'])\n\n        if 'enabled' in eee:\n            status = 'enabled' if eee['enabled'] else 'disabled'\n            if 'active' in eee and eee['active']:\n                status = status + ' - active'\n            else:\n                status = status + ' - inactive'\n        else:\n            status = 'not supported'\n\n        print(f'EEE status: {status}')\n        print_field(eee, ('tx-lpi-timer', 'Tx LPI'))\n        print_speed('Advertised EEE link modes', ours)\n        print_speed('Link partner advertised EEE link modes', peer)\n\n        return\n\n    if args.show_pause:\n        print_field(dumpit(ynl, args, 'pause-get'),\n                ('autoneg', 'Autonegotiate', 'bool'),\n                ('rx', 'RX', 'bool'),\n                ('tx', 'TX', 'bool'))\n        return\n\n    if args.show_coalesce:\n        print_field(dumpit(ynl, args, 'coalesce-get'))\n        return\n\n    if args.show_features:\n        reply = dumpit(ynl, args, 'features-get')\n        available = bits_to_dict(reply['hw'])\n        requested = bits_to_dict(reply['wanted']).keys()\n        active = bits_to_dict(reply['active']).keys()\n        never_changed = bits_to_dict(reply['nochange']).keys()\n\n        for f in sorted(available):\n            value = \"off\"\n            if f in active:\n                value = \"on\"\n\n            fixed = \"\"\n            if f not in available or f in never_changed:\n                fixed = \" [fixed]\"\n\n            req = \"\"\n            if f in requested:\n                if f in active:\n                    req = \" [requested on]\"\n                else:\n                    req = \" [requested off]\"\n\n            print(f'{f}: {value}{fixed}{req}')\n\n        return\n\n    if args.show_channels:\n        reply = dumpit(ynl, args, 'channels-get')\n        print(f'Channel parameters for {args.device}:')\n\n        print(f'Pre-set maximums:')\n        print_field(reply,\n            ('rx-max', 'RX'),\n            ('tx-max', 'TX'),\n            ('other-max', 'Other'),\n            ('combined-max', 'Combined'))\n\n        print(f'Current hardware settings:')\n        print_field(reply,\n            ('rx-count', 'RX'),\n            ('tx-count', 'TX'),\n            ('other-count', 'Other'),\n            ('combined-count', 'Combined'))\n\n        return\n\n    if args.show_ring:\n        reply = dumpit(ynl, args, 'channels-get')\n\n        print(f'Ring parameters for {args.device}:')\n\n        print(f'Pre-set maximums:')\n        print_field(reply,\n            ('rx-max', 'RX'),\n            ('rx-mini-max', 'RX Mini'),\n            ('rx-jumbo-max', 'RX Jumbo'),\n            ('tx-max', 'TX'))\n\n        print(f'Current hardware settings:')\n        print_field(reply,\n            ('rx', 'RX'),\n            ('rx-mini', 'RX Mini'),\n            ('rx-jumbo', 'RX Jumbo'),\n            ('tx', 'TX'))\n\n        print_field(reply,\n            ('rx-buf-len', 'RX Buf Len'),\n            ('cqe-size', 'CQE Size'),\n            ('tx-push', 'TX Push', 'bool'))\n\n        return\n\n    if args.statistics:\n        print(f'NIC statistics:')\n\n        # TODO: pass id?\n        strset = dumpit(ynl, args, 'strset-get')\n        pprint.PrettyPrinter().pprint(strset)\n\n        req = {\n          'groups': {\n            'size': 1,\n            'bits': {\n              'bit':\n                # TODO: support passing the bitmask\n                #[\n                  #{ 'name': 'eth-phy', 'value': True },\n                  { 'name': 'eth-mac', 'value': True },\n                  #{ 'name': 'eth-ctrl', 'value': True },\n                  #{ 'name': 'rmon', 'value': True },\n                #],\n            },\n          },\n        }\n\n        rsp = dumpit(ynl, args, 'stats-get', req)\n        pprint.PrettyPrinter().pprint(rsp)\n        return\n\n    if args.show_time_stamping:\n        tsinfo = dumpit(ynl, args, 'tsinfo-get')\n\n        print(f'Time stamping parameters for {args.device}:')\n\n        print('Capabilities:')\n        [print(f'\\t{v}') for v in bits_to_dict(tsinfo['timestamping'])]\n\n        print(f'PTP Hardware Clock: {tsinfo[\"phc-index\"]}')\n\n        print('Hardware Transmit Timestamp Modes:')\n        [print(f'\\t{v}') for v in bits_to_dict(tsinfo['tx-types'])]\n\n        print('Hardware Receive Filter Modes:')\n        [print(f'\\t{v}') for v in bits_to_dict(tsinfo['rx-filters'])]\n        return\n\n    print(f'Settings for {args.device}:')\n    linkmodes = dumpit(ynl, args, 'linkmodes-get')\n    ours = bits_to_dict(linkmodes['ours'])\n\n    supported_ports = ('TP',  'AUI', 'BNC', 'MII', 'FIBRE', 'Backplane')\n    ports = [ p for p in supported_ports if ours.get(p, False)]\n    print(f'Supported ports: [ {\" \".join(ports)} ]')\n\n    print_speed('Supported link modes', ours)\n\n    print_field(ours, ('Pause', 'Supported pause frame use', 'yn'))\n    print_field(ours, ('Autoneg', 'Supports auto-negotiation', 'yn'))\n\n    supported_fec = ('None',  'PS', 'BASER', 'LLRS')\n    fec = [ p for p in supported_fec if ours.get(p, False)]\n    fec_str = \" \".join(fec)\n    if len(fec) == 0:\n        fec_str = \"Not reported\"\n\n    print(f'Supported FEC modes: {fec_str}')\n\n    speed = 'Unknown!'\n    if linkmodes['speed'] > 0 and linkmodes['speed'] < 0xffffffff:\n        speed = f'{linkmodes[\"speed\"]}Mb/s'\n    print(f'Speed: {speed}')\n\n    duplex_modes = {\n            0: 'Half',\n            1: 'Full',\n    }\n    duplex = duplex_modes.get(linkmodes[\"duplex\"], None)\n    if not duplex:\n        duplex = f'Unknown! ({linkmodes[\"duplex\"]})'\n    print(f'Duplex: {duplex}')\n\n    autoneg = \"off\"\n    if linkmodes.get(\"autoneg\", 0) != 0:\n        autoneg = \"on\"\n    print(f'Auto-negotiation: {autoneg}')\n\n    ports = {\n            0: 'Twisted Pair',\n            1: 'AUI',\n            2: 'MII',\n            3: 'FIBRE',\n            4: 'BNC',\n            5: 'Directly Attached Copper',\n            0xef: 'None',\n    }\n    linkinfo = dumpit(ynl, args, 'linkinfo-get')\n    print(f'Port: {ports.get(linkinfo[\"port\"], \"Other\")}')\n\n    print_field(linkinfo, ('phyaddr', 'PHYAD'))\n\n    transceiver = {\n            0: 'Internal',\n            1: 'External',\n    }\n    print(f'Transceiver: {transceiver.get(linkinfo[\"transceiver\"], \"Unknown\")}')\n\n    mdix_ctrl = {\n            1: 'off',\n            2: 'on',\n    }\n    mdix = mdix_ctrl.get(linkinfo['tp-mdix-ctrl'], None)\n    if mdix:\n        mdix = mdix + ' (forced)'\n    else:\n        mdix = mdix_ctrl.get(linkinfo['tp-mdix'], 'Unknown (auto)')\n    print(f'MDI-X: {mdix}')\n\n    debug = dumpit(ynl, args, 'debug-get')\n    msgmask = bits_to_dict(debug.get(\"msgmask\", [])).keys()\n    print(f'Current message level: {\" \".join(msgmask)}')\n\n    linkstate = dumpit(ynl, args, 'linkstate-get')\n    detected_states = {\n            0: 'no',\n            1: 'yes',\n    }\n    # TODO: wol-get\n    detected = detected_states.get(linkstate['link'], 'unknown')\n    print(f'Link detected: {detected}')\n\nif __name__ == '__main__':\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}