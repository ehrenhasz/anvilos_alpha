{
  "module_name": "ynl-gen-c.py",
  "hash_id": "1964426e164297438d83b77115d7faeecf544589c82d260fd6cb92b85d2adc5a",
  "original_prompt": "Ingested from linux-6.6.14/tools/net/ynl/ynl-gen-c.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)\n\nimport argparse\nimport collections\nimport os\nimport re\nimport shutil\nimport tempfile\nimport yaml\n\nfrom lib import SpecFamily, SpecAttrSet, SpecAttr, SpecOperation, SpecEnumSet, SpecEnumEntry\n\n\ndef c_upper(name):\n    return name.upper().replace('-', '_')\n\n\ndef c_lower(name):\n    return name.lower().replace('-', '_')\n\n\nclass BaseNlLib:\n    def get_family_id(self):\n        return 'ys->family_id'\n\n    def parse_cb_run(self, cb, data, is_dump=False, indent=1):\n        ind = '\\n\\t\\t' + '\\t' * indent + ' '\n        if is_dump:\n            return f\"mnl_cb_run2(ys->rx_buf, len, 0, 0, {cb}, {data},{ind}ynl_cb_array, NLMSG_MIN_TYPE)\"\n        else:\n            return f\"mnl_cb_run2(ys->rx_buf, len, ys->seq, ys->portid,{ind}{cb}, {data},{ind}\" + \\\n                   \"ynl_cb_array, NLMSG_MIN_TYPE)\"\n\n\nclass Type(SpecAttr):\n    def __init__(self, family, attr_set, attr, value):\n        super().__init__(family, attr_set, attr, value)\n\n        self.attr = attr\n        self.attr_set = attr_set\n        self.type = attr['type']\n        self.checks = attr.get('checks', {})\n\n        if 'len' in attr:\n            self.len = attr['len']\n        if 'nested-attributes' in attr:\n            self.nested_attrs = attr['nested-attributes']\n            if self.nested_attrs == family.name:\n                self.nested_render_name = f\"{family.name}\"\n            else:\n                self.nested_render_name = f\"{family.name}_{c_lower(self.nested_attrs)}\"\n\n            if self.nested_attrs in self.family.consts:\n                self.nested_struct_type = 'struct ' + self.nested_render_name + '_'\n            else:\n                self.nested_struct_type = 'struct ' + self.nested_render_name\n\n        self.c_name = c_lower(self.name)\n        if self.c_name in _C_KW:\n            self.c_name += '_'\n\n        # Added by resolve():\n        self.enum_name = None\n        delattr(self, \"enum_name\")\n\n    def resolve(self):\n        if 'name-prefix' in self.attr:\n            enum_name = f\"{self.attr['name-prefix']}{self.name}\"\n        else:\n            enum_name = f\"{self.attr_set.name_prefix}{self.name}\"\n        self.enum_name = c_upper(enum_name)\n\n    def is_multi_val(self):\n        return None\n\n    def is_scalar(self):\n        return self.type in {'u8', 'u16', 'u32', 'u64', 's32', 's64'}\n\n    def presence_type(self):\n        return 'bit'\n\n    def presence_member(self, space, type_filter):\n        if self.presence_type() != type_filter:\n            return\n\n        if self.presence_type() == 'bit':\n            pfx = '__' if space == 'user' else ''\n            return f\"{pfx}u32 {self.c_name}:1;\"\n\n        if self.presence_type() == 'len':\n            pfx = '__' if space == 'user' else ''\n            return f\"{pfx}u32 {self.c_name}_len;\"\n\n    def _complex_member_type(self, ri):\n        return None\n\n    def free_needs_iter(self):\n        return False\n\n    def free(self, ri, var, ref):\n        if self.is_multi_val() or self.presence_type() == 'len':\n            ri.cw.p(f'free({var}->{ref}{self.c_name});')\n\n    def arg_member(self, ri):\n        member = self._complex_member_type(ri)\n        if member:\n            arg = [member + ' *' + self.c_name]\n            if self.presence_type() == 'count':\n                arg += ['unsigned int n_' + self.c_name]\n            return arg\n        raise Exception(f\"Struct member not implemented for class type {self.type}\")\n\n    def struct_member(self, ri):\n        if self.is_multi_val():\n            ri.cw.p(f\"unsigned int n_{self.c_name};\")\n        member = self._complex_member_type(ri)\n        if member:\n            ptr = '*' if self.is_multi_val() else ''\n            ri.cw.p(f\"{member} {ptr}{self.c_name};\")\n            return\n        members = self.arg_member(ri)\n        for one in members:\n            ri.cw.p(one + ';')\n\n    def _attr_policy(self, policy):\n        return '{ .type = ' + policy + ', }'\n\n    def attr_policy(self, cw):\n        policy = c_upper('nla-' + self.attr['type'])\n\n        spec = self._attr_policy(policy)\n        cw.p(f\"\\t[{self.enum_name}] = {spec},\")\n\n    def _attr_typol(self):\n        raise Exception(f\"Type policy not implemented for class type {self.type}\")\n\n    def attr_typol(self, cw):\n        typol = self._attr_typol()\n        cw.p(f'[{self.enum_name}] = {\"{\"} .name = \"{self.name}\", {typol}{\"}\"},')\n\n    def _attr_put_line(self, ri, var, line):\n        if self.presence_type() == 'bit':\n            ri.cw.p(f\"if ({var}->_present.{self.c_name})\")\n        elif self.presence_type() == 'len':\n            ri.cw.p(f\"if ({var}->_present.{self.c_name}_len)\")\n        ri.cw.p(f\"{line};\")\n\n    def _attr_put_simple(self, ri, var, put_type):\n        line = f\"mnl_attr_put_{put_type}(nlh, {self.enum_name}, {var}->{self.c_name})\"\n        self._attr_put_line(ri, var, line)\n\n    def attr_put(self, ri, var):\n        raise Exception(f\"Put not implemented for class type {self.type}\")\n\n    def _attr_get(self, ri, var):\n        raise Exception(f\"Attr get not implemented for class type {self.type}\")\n\n    def attr_get(self, ri, var, first):\n        lines, init_lines, local_vars = self._attr_get(ri, var)\n        if type(lines) is str:\n            lines = [lines]\n        if type(init_lines) is str:\n            init_lines = [init_lines]\n\n        kw = 'if' if first else 'else if'\n        ri.cw.block_start(line=f\"{kw} (type == {self.enum_name})\")\n        if local_vars:\n            for local in local_vars:\n                ri.cw.p(local)\n            ri.cw.nl()\n\n        if not self.is_multi_val():\n            ri.cw.p(\"if (ynl_attr_validate(yarg, attr))\")\n            ri.cw.p(\"return MNL_CB_ERROR;\")\n            if self.presence_type() == 'bit':\n                ri.cw.p(f\"{var}->_present.{self.c_name} = 1;\")\n\n        if init_lines:\n            ri.cw.nl()\n            for line in init_lines:\n                ri.cw.p(line)\n\n        for line in lines:\n            ri.cw.p(line)\n        ri.cw.block_end()\n        return True\n\n    def _setter_lines(self, ri, member, presence):\n        raise Exception(f\"Setter not implemented for class type {self.type}\")\n\n    def setter(self, ri, space, direction, deref=False, ref=None):\n        ref = (ref if ref else []) + [self.c_name]\n        var = \"req\"\n        member = f\"{var}->{'.'.join(ref)}\"\n\n        code = []\n        presence = ''\n        for i in range(0, len(ref)):\n            presence = f\"{var}->{'.'.join(ref[:i] + [''])}_present.{ref[i]}\"\n            if self.presence_type() == 'bit':\n                code.append(presence + ' = 1;')\n        code += self._setter_lines(ri, member, presence)\n\n        func_name = f\"{op_prefix(ri, direction, deref=deref)}_set_{'_'.join(ref)}\"\n        free = bool([x for x in code if 'free(' in x])\n        alloc = bool([x for x in code if 'alloc(' in x])\n        if free and not alloc:\n            func_name = '__' + func_name\n        ri.cw.write_func('static inline void', func_name, body=code,\n                         args=[f'{type_name(ri, direction, deref=deref)} *{var}'] + self.arg_member(ri))\n\n\nclass TypeUnused(Type):\n    def presence_type(self):\n        return ''\n\n    def arg_member(self, ri):\n        return []\n\n    def _attr_get(self, ri, var):\n        return ['return MNL_CB_ERROR;'], None, None\n\n    def _attr_typol(self):\n        return '.type = YNL_PT_REJECT, '\n\n    def attr_policy(self, cw):\n        pass\n\n\nclass TypePad(Type):\n    def presence_type(self):\n        return ''\n\n    def arg_member(self, ri):\n        return []\n\n    def _attr_typol(self):\n        return '.type = YNL_PT_IGNORE, '\n\n    def attr_put(self, ri, var):\n        pass\n\n    def attr_get(self, ri, var, first):\n        pass\n\n    def attr_policy(self, cw):\n        pass\n\n    def setter(self, ri, space, direction, deref=False, ref=None):\n        pass\n\n\nclass TypeScalar(Type):\n    def __init__(self, family, attr_set, attr, value):\n        super().__init__(family, attr_set, attr, value)\n\n        self.byte_order_comment = ''\n        if 'byte-order' in attr:\n            self.byte_order_comment = f\" /* {attr['byte-order']} */\"\n\n        # Added by resolve():\n        self.is_bitfield = None\n        delattr(self, \"is_bitfield\")\n        self.type_name = None\n        delattr(self, \"type_name\")\n\n    def resolve(self):\n        self.resolve_up(super())\n\n        if 'enum-as-flags' in self.attr and self.attr['enum-as-flags']:\n            self.is_bitfield = True\n        elif 'enum' in self.attr:\n            self.is_bitfield = self.family.consts[self.attr['enum']]['type'] == 'flags'\n        else:\n            self.is_bitfield = False\n\n        maybe_enum = not self.is_bitfield and 'enum' in self.attr\n        if maybe_enum and self.family.consts[self.attr['enum']].enum_name:\n            self.type_name = f\"enum {self.family.name}_{c_lower(self.attr['enum'])}\"\n        else:\n            self.type_name = '__' + self.type\n\n    def _mnl_type(self):\n        t = self.type\n        # mnl does not have a helper for signed types\n        if t[0] == 's':\n            t = 'u' + t[1:]\n        return t\n\n    def _attr_policy(self, policy):\n        if 'flags-mask' in self.checks or self.is_bitfield:\n            if self.is_bitfield:\n                enum = self.family.consts[self.attr['enum']]\n                mask = enum.get_mask(as_flags=True)\n            else:\n                flags = self.family.consts[self.checks['flags-mask']]\n                flag_cnt = len(flags['entries'])\n                mask = (1 << flag_cnt) - 1\n            return f\"NLA_POLICY_MASK({policy}, 0x{mask:x})\"\n        elif 'min' in self.checks:\n            return f\"NLA_POLICY_MIN({policy}, {self.checks['min']})\"\n        elif 'enum' in self.attr:\n            enum = self.family.consts[self.attr['enum']]\n            low, high = enum.value_range()\n            if low == 0:\n                return f\"NLA_POLICY_MAX({policy}, {high})\"\n            return f\"NLA_POLICY_RANGE({policy}, {low}, {high})\"\n        return super()._attr_policy(policy)\n\n    def _attr_typol(self):\n        return f'.type = YNL_PT_U{self.type[1:]}, '\n\n    def arg_member(self, ri):\n        return [f'{self.type_name} {self.c_name}{self.byte_order_comment}']\n\n    def attr_put(self, ri, var):\n        self._attr_put_simple(ri, var, self._mnl_type())\n\n    def _attr_get(self, ri, var):\n        return f\"{var}->{self.c_name} = mnl_attr_get_{self._mnl_type()}(attr);\", None, None\n\n    def _setter_lines(self, ri, member, presence):\n        return [f\"{member} = {self.c_name};\"]\n\n\nclass TypeFlag(Type):\n    def arg_member(self, ri):\n        return []\n\n    def _attr_typol(self):\n        return '.type = YNL_PT_FLAG, '\n\n    def attr_put(self, ri, var):\n        self._attr_put_line(ri, var, f\"mnl_attr_put(nlh, {self.enum_name}, 0, NULL)\")\n\n    def _attr_get(self, ri, var):\n        return [], None, None\n\n    def _setter_lines(self, ri, member, presence):\n        return []\n\n\nclass TypeString(Type):\n    def arg_member(self, ri):\n        return [f\"const char *{self.c_name}\"]\n\n    def presence_type(self):\n        return 'len'\n\n    def struct_member(self, ri):\n        ri.cw.p(f\"char *{self.c_name};\")\n\n    def _attr_typol(self):\n        return f'.type = YNL_PT_NUL_STR, '\n\n    def _attr_policy(self, policy):\n        mem = '{ .type = ' + policy\n        if 'max-len' in self.checks:\n            mem += ', .len = ' + str(self.checks['max-len'])\n        mem += ', }'\n        return mem\n\n    def attr_policy(self, cw):\n        if self.checks.get('unterminated-ok', False):\n            policy = 'NLA_STRING'\n        else:\n            policy = 'NLA_NUL_STRING'\n\n        spec = self._attr_policy(policy)\n        cw.p(f\"\\t[{self.enum_name}] = {spec},\")\n\n    def attr_put(self, ri, var):\n        self._attr_put_simple(ri, var, 'strz')\n\n    def _attr_get(self, ri, var):\n        len_mem = var + '->_present.' + self.c_name + '_len'\n        return [f\"{len_mem} = len;\",\n                f\"{var}->{self.c_name} = malloc(len + 1);\",\n                f\"memcpy({var}->{self.c_name}, mnl_attr_get_str(attr), len);\",\n                f\"{var}->{self.c_name}[len] = 0;\"], \\\n               ['len = strnlen(mnl_attr_get_str(attr), mnl_attr_get_payload_len(attr));'], \\\n               ['unsigned int len;']\n\n    def _setter_lines(self, ri, member, presence):\n        return [f\"free({member});\",\n                f\"{presence}_len = strlen({self.c_name});\",\n                f\"{member} = malloc({presence}_len + 1);\",\n                f'memcpy({member}, {self.c_name}, {presence}_len);',\n                f'{member}[{presence}_len] = 0;']\n\n\nclass TypeBinary(Type):\n    def arg_member(self, ri):\n        return [f\"const void *{self.c_name}\", 'size_t len']\n\n    def presence_type(self):\n        return 'len'\n\n    def struct_member(self, ri):\n        ri.cw.p(f\"void *{self.c_name};\")\n\n    def _attr_typol(self):\n        return f'.type = YNL_PT_BINARY,'\n\n    def _attr_policy(self, policy):\n        mem = '{ '\n        if len(self.checks) == 1 and 'min-len' in self.checks:\n            mem += '.len = ' + str(self.checks['min-len'])\n        elif len(self.checks) == 0:\n            mem += '.type = NLA_BINARY'\n        else:\n            raise Exception('One or more of binary type checks not implemented, yet')\n        mem += ', }'\n        return mem\n\n    def attr_put(self, ri, var):\n        self._attr_put_line(ri, var, f\"mnl_attr_put(nlh, {self.enum_name}, \" +\n                            f\"{var}->_present.{self.c_name}_len, {var}->{self.c_name})\")\n\n    def _attr_get(self, ri, var):\n        len_mem = var + '->_present.' + self.c_name + '_len'\n        return [f\"{len_mem} = len;\",\n                f\"{var}->{self.c_name} = malloc(len);\",\n                f\"memcpy({var}->{self.c_name}, mnl_attr_get_payload(attr), len);\"], \\\n               ['len = mnl_attr_get_payload_len(attr);'], \\\n               ['unsigned int len;']\n\n    def _setter_lines(self, ri, member, presence):\n        return [f\"free({member});\",\n                f\"{presence}_len = len;\",\n                f\"{member} = malloc({presence}_len);\",\n                f'memcpy({member}, {self.c_name}, {presence}_len);']\n\n\nclass TypeNest(Type):\n    def _complex_member_type(self, ri):\n        return self.nested_struct_type\n\n    def free(self, ri, var, ref):\n        ri.cw.p(f'{self.nested_render_name}_free(&{var}->{ref}{self.c_name});')\n\n    def _attr_typol(self):\n        return f'.type = YNL_PT_NEST, .nest = &{self.nested_render_name}_nest, '\n\n    def _attr_policy(self, policy):\n        return 'NLA_POLICY_NESTED(' + self.nested_render_name + '_nl_policy)'\n\n    def attr_put(self, ri, var):\n        self._attr_put_line(ri, var, f\"{self.nested_render_name}_put(nlh, \" +\n                            f\"{self.enum_name}, &{var}->{self.c_name})\")\n\n    def _attr_get(self, ri, var):\n        get_lines = [f\"if ({self.nested_render_name}_parse(&parg, attr))\",\n                     \"return MNL_CB_ERROR;\"]\n        init_lines = [f\"parg.rsp_policy = &{self.nested_render_name}_nest;\",\n                      f\"parg.data = &{var}->{self.c_name};\"]\n        return get_lines, init_lines, None\n\n    def setter(self, ri, space, direction, deref=False, ref=None):\n        ref = (ref if ref else []) + [self.c_name]\n\n        for _, attr in ri.family.pure_nested_structs[self.nested_attrs].member_list():\n            attr.setter(ri, self.nested_attrs, direction, deref=deref, ref=ref)\n\n\nclass TypeMultiAttr(Type):\n    def __init__(self, family, attr_set, attr, value, base_type):\n        super().__init__(family, attr_set, attr, value)\n\n        self.base_type = base_type\n\n    def is_multi_val(self):\n        return True\n\n    def presence_type(self):\n        return 'count'\n\n    def _mnl_type(self):\n        t = self.type\n        # mnl does not have a helper for signed types\n        if t[0] == 's':\n            t = 'u' + t[1:]\n        return t\n\n    def _complex_member_type(self, ri):\n        if 'type' not in self.attr or self.attr['type'] == 'nest':\n            return self.nested_struct_type\n        elif self.attr['type'] in scalars:\n            scalar_pfx = '__' if ri.ku_space == 'user' else ''\n            return scalar_pfx + self.attr['type']\n        else:\n            raise Exception(f\"Sub-type {self.attr['type']} not supported yet\")\n\n    def free_needs_iter(self):\n        return 'type' not in self.attr or self.attr['type'] == 'nest'\n\n    def free(self, ri, var, ref):\n        if self.attr['type'] in scalars:\n            ri.cw.p(f\"free({var}->{ref}{self.c_name});\")\n        elif 'type' not in self.attr or self.attr['type'] == 'nest':\n            ri.cw.p(f\"for (i = 0; i < {var}->{ref}n_{self.c_name}; i++)\")\n            ri.cw.p(f'{self.nested_render_name}_free(&{var}->{ref}{self.c_name}[i]);')\n            ri.cw.p(f\"free({var}->{ref}{self.c_name});\")\n        else:\n            raise Exception(f\"Free of MultiAttr sub-type {self.attr['type']} not supported yet\")\n\n    def _attr_policy(self, policy):\n        return self.base_type._attr_policy(policy)\n\n    def _attr_typol(self):\n        return self.base_type._attr_typol()\n\n    def _attr_get(self, ri, var):\n        return f'n_{self.c_name}++;', None, None\n\n    def attr_put(self, ri, var):\n        if self.attr['type'] in scalars:\n            put_type = self._mnl_type()\n            ri.cw.p(f\"for (unsigned int i = 0; i < {var}->n_{self.c_name}; i++)\")\n            ri.cw.p(f\"mnl_attr_put_{put_type}(nlh, {self.enum_name}, {var}->{self.c_name}[i]);\")\n        elif 'type' not in self.attr or self.attr['type'] == 'nest':\n            ri.cw.p(f\"for (unsigned int i = 0; i < {var}->n_{self.c_name}; i++)\")\n            self._attr_put_line(ri, var, f\"{self.nested_render_name}_put(nlh, \" +\n                                f\"{self.enum_name}, &{var}->{self.c_name}[i])\")\n        else:\n            raise Exception(f\"Put of MultiAttr sub-type {self.attr['type']} not supported yet\")\n\n    def _setter_lines(self, ri, member, presence):\n        # For multi-attr we have a count, not presence, hack up the presence\n        presence = presence[:-(len('_present.') + len(self.c_name))] + \"n_\" + self.c_name\n        return [f\"free({member});\",\n                f\"{member} = {self.c_name};\",\n                f\"{presence} = n_{self.c_name};\"]\n\n\nclass TypeArrayNest(Type):\n    def is_multi_val(self):\n        return True\n\n    def presence_type(self):\n        return 'count'\n\n    def _complex_member_type(self, ri):\n        if 'sub-type' not in self.attr or self.attr['sub-type'] == 'nest':\n            return self.nested_struct_type\n        elif self.attr['sub-type'] in scalars:\n            scalar_pfx = '__' if ri.ku_space == 'user' else ''\n            return scalar_pfx + self.attr['sub-type']\n        else:\n            raise Exception(f\"Sub-type {self.attr['sub-type']} not supported yet\")\n\n    def _attr_typol(self):\n        return f'.type = YNL_PT_NEST, .nest = &{self.nested_render_name}_nest, '\n\n    def _attr_get(self, ri, var):\n        local_vars = ['const struct nlattr *attr2;']\n        get_lines = [f'attr_{self.c_name} = attr;',\n                     'mnl_attr_for_each_nested(attr2, attr)',\n                     f'\\t{var}->n_{self.c_name}++;']\n        return get_lines, None, local_vars\n\n\nclass TypeNestTypeValue(Type):\n    def _complex_member_type(self, ri):\n        return self.nested_struct_type\n\n    def _attr_typol(self):\n        return f'.type = YNL_PT_NEST, .nest = &{self.nested_render_name}_nest, '\n\n    def _attr_get(self, ri, var):\n        prev = 'attr'\n        tv_args = ''\n        get_lines = []\n        local_vars = []\n        init_lines = [f\"parg.rsp_policy = &{self.nested_render_name}_nest;\",\n                      f\"parg.data = &{var}->{self.c_name};\"]\n        if 'type-value' in self.attr:\n            tv_names = [c_lower(x) for x in self.attr[\"type-value\"]]\n            local_vars += [f'const struct nlattr *attr_{\", *attr_\".join(tv_names)};']\n            local_vars += [f'__u32 {\", \".join(tv_names)};']\n            for level in self.attr[\"type-value\"]:\n                level = c_lower(level)\n                get_lines += [f'attr_{level} = mnl_attr_get_payload({prev});']\n                get_lines += [f'{level} = mnl_attr_get_type(attr_{level});']\n                prev = 'attr_' + level\n\n            tv_args = f\", {', '.join(tv_names)}\"\n\n        get_lines += [f\"{self.nested_render_name}_parse(&parg, {prev}{tv_args});\"]\n        return get_lines, init_lines, local_vars\n\n\nclass Struct:\n    def __init__(self, family, space_name, type_list=None, inherited=None):\n        self.family = family\n        self.space_name = space_name\n        self.attr_set = family.attr_sets[space_name]\n        # Use list to catch comparisons with empty sets\n        self._inherited = inherited if inherited is not None else []\n        self.inherited = []\n\n        self.nested = type_list is None\n        if family.name == c_lower(space_name):\n            self.render_name = f\"{family.name}\"\n        else:\n            self.render_name = f\"{family.name}_{c_lower(space_name)}\"\n        self.struct_name = 'struct ' + self.render_name\n        if self.nested and space_name in family.consts:\n            self.struct_name += '_'\n        self.ptr_name = self.struct_name + ' *'\n\n        self.request = False\n        self.reply = False\n\n        self.attr_list = []\n        self.attrs = dict()\n        if type_list is not None:\n            for t in type_list:\n                self.attr_list.append((t, self.attr_set[t]),)\n        else:\n            for t in self.attr_set:\n                self.attr_list.append((t, self.attr_set[t]),)\n\n        max_val = 0\n        self.attr_max_val = None\n        for name, attr in self.attr_list:\n            if attr.value >= max_val:\n                max_val = attr.value\n                self.attr_max_val = attr\n            self.attrs[name] = attr\n\n    def __iter__(self):\n        yield from self.attrs\n\n    def __getitem__(self, key):\n        return self.attrs[key]\n\n    def member_list(self):\n        return self.attr_list\n\n    def set_inherited(self, new_inherited):\n        if self._inherited != new_inherited:\n            raise Exception(\"Inheriting different members not supported\")\n        self.inherited = [c_lower(x) for x in sorted(self._inherited)]\n\n\nclass EnumEntry(SpecEnumEntry):\n    def __init__(self, enum_set, yaml, prev, value_start):\n        super().__init__(enum_set, yaml, prev, value_start)\n\n        if prev:\n            self.value_change = (self.value != prev.value + 1)\n        else:\n            self.value_change = (self.value != 0)\n        self.value_change = self.value_change or self.enum_set['type'] == 'flags'\n\n        # Added by resolve:\n        self.c_name = None\n        delattr(self, \"c_name\")\n\n    def resolve(self):\n        self.resolve_up(super())\n\n        self.c_name = c_upper(self.enum_set.value_pfx + self.name)\n\n\nclass EnumSet(SpecEnumSet):\n    def __init__(self, family, yaml):\n        self.render_name = c_lower(family.name + '-' + yaml['name'])\n\n        if 'enum-name' in yaml:\n            if yaml['enum-name']:\n                self.enum_name = 'enum ' + c_lower(yaml['enum-name'])\n            else:\n                self.enum_name = None\n        else:\n            self.enum_name = 'enum ' + self.render_name\n\n        self.value_pfx = yaml.get('name-prefix', f\"{family.name}-{yaml['name']}-\")\n\n        super().__init__(family, yaml)\n\n    def new_entry(self, entry, prev_entry, value_start):\n        return EnumEntry(self, entry, prev_entry, value_start)\n\n    def value_range(self):\n        low = min([x.value for x in self.entries.values()])\n        high = max([x.value for x in self.entries.values()])\n\n        if high - low + 1 != len(self.entries):\n            raise Exception(\"Can't get value range for a noncontiguous enum\")\n\n        return low, high\n\n\nclass AttrSet(SpecAttrSet):\n    def __init__(self, family, yaml):\n        super().__init__(family, yaml)\n\n        if self.subset_of is None:\n            if 'name-prefix' in yaml:\n                pfx = yaml['name-prefix']\n            elif self.name == family.name:\n                pfx = family.name + '-a-'\n            else:\n                pfx = f\"{family.name}-a-{self.name}-\"\n            self.name_prefix = c_upper(pfx)\n            self.max_name = c_upper(self.yaml.get('attr-max-name', f\"{self.name_prefix}max\"))\n        else:\n            self.name_prefix = family.attr_sets[self.subset_of].name_prefix\n            self.max_name = family.attr_sets[self.subset_of].max_name\n\n        # Added by resolve:\n        self.c_name = None\n        delattr(self, \"c_name\")\n\n    def resolve(self):\n        self.c_name = c_lower(self.name)\n        if self.c_name in _C_KW:\n            self.c_name += '_'\n        if self.c_name == self.family.c_name:\n            self.c_name = ''\n\n    def new_attr(self, elem, value):\n        if elem['type'] in scalars:\n            t = TypeScalar(self.family, self, elem, value)\n        elif elem['type'] == 'unused':\n            t = TypeUnused(self.family, self, elem, value)\n        elif elem['type'] == 'pad':\n            t = TypePad(self.family, self, elem, value)\n        elif elem['type'] == 'flag':\n            t = TypeFlag(self.family, self, elem, value)\n        elif elem['type'] == 'string':\n            t = TypeString(self.family, self, elem, value)\n        elif elem['type'] == 'binary':\n            t = TypeBinary(self.family, self, elem, value)\n        elif elem['type'] == 'nest':\n            t = TypeNest(self.family, self, elem, value)\n        elif elem['type'] == 'array-nest':\n            t = TypeArrayNest(self.family, self, elem, value)\n        elif elem['type'] == 'nest-type-value':\n            t = TypeNestTypeValue(self.family, self, elem, value)\n        else:\n            raise Exception(f\"No typed class for type {elem['type']}\")\n\n        if 'multi-attr' in elem and elem['multi-attr']:\n            t = TypeMultiAttr(self.family, self, elem, value, t)\n\n        return t\n\n\nclass Operation(SpecOperation):\n    def __init__(self, family, yaml, req_value, rsp_value):\n        super().__init__(family, yaml, req_value, rsp_value)\n\n        self.render_name = family.name + '_' + c_lower(self.name)\n\n        self.dual_policy = ('do' in yaml and 'request' in yaml['do']) and \\\n                         ('dump' in yaml and 'request' in yaml['dump'])\n\n        self.has_ntf = False\n\n        # Added by resolve:\n        self.enum_name = None\n        delattr(self, \"enum_name\")\n\n    def resolve(self):\n        self.resolve_up(super())\n\n        if not self.is_async:\n            self.enum_name = self.family.op_prefix + c_upper(self.name)\n        else:\n            self.enum_name = self.family.async_op_prefix + c_upper(self.name)\n\n    def mark_has_ntf(self):\n        self.has_ntf = True\n\n\nclass Family(SpecFamily):\n    def __init__(self, file_name, exclude_ops):\n        # Added by resolve:\n        self.c_name = None\n        delattr(self, \"c_name\")\n        self.op_prefix = None\n        delattr(self, \"op_prefix\")\n        self.async_op_prefix = None\n        delattr(self, \"async_op_prefix\")\n        self.mcgrps = None\n        delattr(self, \"mcgrps\")\n        self.consts = None\n        delattr(self, \"consts\")\n        self.hooks = None\n        delattr(self, \"hooks\")\n\n        super().__init__(file_name, exclude_ops=exclude_ops)\n\n        self.fam_key = c_upper(self.yaml.get('c-family-name', self.yaml[\"name\"] + '_FAMILY_NAME'))\n        self.ver_key = c_upper(self.yaml.get('c-version-name', self.yaml[\"name\"] + '_FAMILY_VERSION'))\n\n        if 'definitions' not in self.yaml:\n            self.yaml['definitions'] = []\n\n        if 'uapi-header' in self.yaml:\n            self.uapi_header = self.yaml['uapi-header']\n        else:\n            self.uapi_header = f\"linux/{self.name}.h\"\n\n    def resolve(self):\n        self.resolve_up(super())\n\n        if self.yaml.get('protocol', 'genetlink') not in {'genetlink', 'genetlink-c', 'genetlink-legacy'}:\n            raise Exception(\"Codegen only supported for genetlink\")\n\n        self.c_name = c_lower(self.name)\n        if 'name-prefix' in self.yaml['operations']:\n            self.op_prefix = c_upper(self.yaml['operations']['name-prefix'])\n        else:\n            self.op_prefix = c_upper(self.yaml['name'] + '-cmd-')\n        if 'async-prefix' in self.yaml['operations']:\n            self.async_op_prefix = c_upper(self.yaml['operations']['async-prefix'])\n        else:\n            self.async_op_prefix = self.op_prefix\n\n        self.mcgrps = self.yaml.get('mcast-groups', {'list': []})\n\n        self.hooks = dict()\n        for when in ['pre', 'post']:\n            self.hooks[when] = dict()\n            for op_mode in ['do', 'dump']:\n                self.hooks[when][op_mode] = dict()\n                self.hooks[when][op_mode]['set'] = set()\n                self.hooks[when][op_mode]['list'] = []\n\n        # dict space-name -> 'request': set(attrs), 'reply': set(attrs)\n        self.root_sets = dict()\n        # dict space-name -> set('request', 'reply')\n        self.pure_nested_structs = dict()\n\n        self._mark_notify()\n        self._mock_up_events()\n\n        self._load_root_sets()\n        self._load_nested_sets()\n        self._load_hooks()\n\n        self.kernel_policy = self.yaml.get('kernel-policy', 'split')\n        if self.kernel_policy == 'global':\n            self._load_global_policy()\n\n    def new_enum(self, elem):\n        return EnumSet(self, elem)\n\n    def new_attr_set(self, elem):\n        return AttrSet(self, elem)\n\n    def new_operation(self, elem, req_value, rsp_value):\n        return Operation(self, elem, req_value, rsp_value)\n\n    def _mark_notify(self):\n        for op in self.msgs.values():\n            if 'notify' in op:\n                self.ops[op['notify']].mark_has_ntf()\n\n    # Fake a 'do' equivalent of all events, so that we can render their response parsing\n    def _mock_up_events(self):\n        for op in self.yaml['operations']['list']:\n            if 'event' in op:\n                op['do'] = {\n                    'reply': {\n                        'attributes': op['event']['attributes']\n                    }\n                }\n\n    def _load_root_sets(self):\n        for op_name, op in self.msgs.items():\n            if 'attribute-set' not in op:\n                continue\n\n            req_attrs = set()\n            rsp_attrs = set()\n            for op_mode in ['do', 'dump']:\n                if op_mode in op and 'request' in op[op_mode]:\n                    req_attrs.update(set(op[op_mode]['request']['attributes']))\n                if op_mode in op and 'reply' in op[op_mode]:\n                    rsp_attrs.update(set(op[op_mode]['reply']['attributes']))\n            if 'event' in op:\n                rsp_attrs.update(set(op['event']['attributes']))\n\n            if op['attribute-set'] not in self.root_sets:\n                self.root_sets[op['attribute-set']] = {'request': req_attrs, 'reply': rsp_attrs}\n            else:\n                self.root_sets[op['attribute-set']]['request'].update(req_attrs)\n                self.root_sets[op['attribute-set']]['reply'].update(rsp_attrs)\n\n    def _load_nested_sets(self):\n        attr_set_queue = list(self.root_sets.keys())\n        attr_set_seen = set(self.root_sets.keys())\n\n        while len(attr_set_queue):\n            a_set = attr_set_queue.pop(0)\n            for attr, spec in self.attr_sets[a_set].items():\n                if 'nested-attributes' not in spec:\n                    continue\n\n                nested = spec['nested-attributes']\n                if nested not in attr_set_seen:\n                    attr_set_queue.append(nested)\n                    attr_set_seen.add(nested)\n\n                inherit = set()\n                if nested not in self.root_sets:\n                    if nested not in self.pure_nested_structs:\n                        self.pure_nested_structs[nested] = Struct(self, nested, inherited=inherit)\n                else:\n                    raise Exception(f'Using attr set as root and nested not supported - {nested}')\n\n                if 'type-value' in spec:\n                    if nested in self.root_sets:\n                        raise Exception(\"Inheriting members to a space used as root not supported\")\n                    inherit.update(set(spec['type-value']))\n                elif spec['type'] == 'array-nest':\n                    inherit.add('idx')\n                self.pure_nested_structs[nested].set_inherited(inherit)\n\n        for root_set, rs_members in self.root_sets.items():\n            for attr, spec in self.attr_sets[root_set].items():\n                if 'nested-attributes' in spec:\n                    nested = spec['nested-attributes']\n                    if attr in rs_members['request']:\n                        self.pure_nested_structs[nested].request = True\n                    if attr in rs_members['reply']:\n                        self.pure_nested_structs[nested].reply = True\n\n        # Try to reorder according to dependencies\n        pns_key_list = list(self.pure_nested_structs.keys())\n        pns_key_seen = set()\n        rounds = len(pns_key_list)**2  # it's basically bubble sort\n        for _ in range(rounds):\n            if len(pns_key_list) == 0:\n                break\n            name = pns_key_list.pop(0)\n            finished = True\n            for _, spec in self.attr_sets[name].items():\n                if 'nested-attributes' in spec:\n                    if spec['nested-attributes'] not in pns_key_seen:\n                        # Dicts are sorted, this will make struct last\n                        struct = self.pure_nested_structs.pop(name)\n                        self.pure_nested_structs[name] = struct\n                        finished = False\n                        break\n            if finished:\n                pns_key_seen.add(name)\n            else:\n                pns_key_list.append(name)\n        # Propagate the request / reply\n        for attr_set, struct in reversed(self.pure_nested_structs.items()):\n            for _, spec in self.attr_sets[attr_set].items():\n                if 'nested-attributes' in spec:\n                    child = self.pure_nested_structs.get(spec['nested-attributes'])\n                    if child:\n                        child.request |= struct.request\n                        child.reply |= struct.reply\n\n    def _load_global_policy(self):\n        global_set = set()\n        attr_set_name = None\n        for op_name, op in self.ops.items():\n            if not op:\n                continue\n            if 'attribute-set' not in op:\n                continue\n\n            if attr_set_name is None:\n                attr_set_name = op['attribute-set']\n            if attr_set_name != op['attribute-set']:\n                raise Exception('For a global policy all ops must use the same set')\n\n            for op_mode in ['do', 'dump']:\n                if op_mode in op:\n                    req = op[op_mode].get('request')\n                    if req:\n                        global_set.update(req.get('attributes', []))\n\n        self.global_policy = []\n        self.global_policy_set = attr_set_name\n        for attr in self.attr_sets[attr_set_name]:\n            if attr in global_set:\n                self.global_policy.append(attr)\n\n    def _load_hooks(self):\n        for op in self.ops.values():\n            for op_mode in ['do', 'dump']:\n                if op_mode not in op:\n                    continue\n                for when in ['pre', 'post']:\n                    if when not in op[op_mode]:\n                        continue\n                    name = op[op_mode][when]\n                    if name in self.hooks[when][op_mode]['set']:\n                        continue\n                    self.hooks[when][op_mode]['set'].add(name)\n                    self.hooks[when][op_mode]['list'].append(name)\n\n\nclass RenderInfo:\n    def __init__(self, cw, family, ku_space, op, op_mode, attr_set=None):\n        self.family = family\n        self.nl = cw.nlib\n        self.ku_space = ku_space\n        self.op_mode = op_mode\n        self.op = op\n\n        # 'do' and 'dump' response parsing is identical\n        self.type_consistent = True\n        if op_mode != 'do' and 'dump' in op and 'do' in op:\n            if ('reply' in op['do']) != ('reply' in op[\"dump\"]):\n                self.type_consistent = False\n            elif 'reply' in op['do'] and op[\"do\"][\"reply\"] != op[\"dump\"][\"reply\"]:\n                self.type_consistent = False\n\n        self.attr_set = attr_set\n        if not self.attr_set:\n            self.attr_set = op['attribute-set']\n\n        self.type_name_conflict = False\n        if op:\n            self.type_name = c_lower(op.name)\n        else:\n            self.type_name = c_lower(attr_set)\n            if attr_set in family.consts:\n                self.type_name_conflict = True\n\n        self.cw = cw\n\n        self.struct = dict()\n        if op_mode == 'notify':\n            op_mode = 'do'\n        for op_dir in ['request', 'reply']:\n            if op and op_dir in op[op_mode]:\n                self.struct[op_dir] = Struct(family, self.attr_set,\n                                             type_list=op[op_mode][op_dir]['attributes'])\n        if op_mode == 'event':\n            self.struct['reply'] = Struct(family, self.attr_set, type_list=op['event']['attributes'])\n\n\nclass CodeWriter:\n    def __init__(self, nlib, out_file=None):\n        self.nlib = nlib\n\n        self._nl = False\n        self._block_end = False\n        self._silent_block = False\n        self._ind = 0\n        if out_file is None:\n            self._out = os.sys.stdout\n        else:\n            self._out = tempfile.TemporaryFile('w+')\n            self._out_file = out_file\n\n    def __del__(self):\n        self.close_out_file()\n\n    def close_out_file(self):\n        if self._out == os.sys.stdout:\n            return\n        with open(self._out_file, 'w+') as out_file:\n            self._out.seek(0)\n            shutil.copyfileobj(self._out, out_file)\n            self._out.close()\n        self._out = os.sys.stdout\n\n    @classmethod\n    def _is_cond(cls, line):\n        return line.startswith('if') or line.startswith('while') or line.startswith('for')\n\n    def p(self, line, add_ind=0):\n        if self._block_end:\n            self._block_end = False\n            if line.startswith('else'):\n                line = '} ' + line\n            else:\n                self._out.write('\\t' * self._ind + '}\\n')\n\n        if self._nl:\n            self._out.write('\\n')\n            self._nl = False\n\n        ind = self._ind\n        if line[-1] == ':':\n            ind -= 1\n        if self._silent_block:\n            ind += 1\n        self._silent_block = line.endswith(')') and CodeWriter._is_cond(line)\n        if add_ind:\n            ind += add_ind\n        self._out.write('\\t' * ind + line + '\\n')\n\n    def nl(self):\n        self._nl = True\n\n    def block_start(self, line=''):\n        if line:\n            line = line + ' '\n        self.p(line + '{')\n        self._ind += 1\n\n    def block_end(self, line=''):\n        if line and line[0] not in {';', ','}:\n            line = ' ' + line\n        self._ind -= 1\n        self._nl = False\n        if not line:\n            # Delay printing closing bracket in case \"else\" comes next\n            if self._block_end:\n                self._out.write('\\t' * (self._ind + 1) + '}\\n')\n            self._block_end = True\n        else:\n            self.p('}' + line)\n\n    def write_doc_line(self, doc, indent=True):\n        words = doc.split()\n        line = ' *'\n        for word in words:\n            if len(line) + len(word) >= 79:\n                self.p(line)\n                line = ' *'\n                if indent:\n                    line += '  '\n            line += ' ' + word\n        self.p(line)\n\n    def write_func_prot(self, qual_ret, name, args=None, doc=None, suffix=''):\n        if not args:\n            args = ['void']\n\n        if doc:\n            self.p('/*')\n            self.p(' * ' + doc)\n            self.p(' */')\n\n        oneline = qual_ret\n        if qual_ret[-1] != '*':\n            oneline += ' '\n        oneline += f\"{name}({', '.join(args)}){suffix}\"\n\n        if len(oneline) < 80:\n            self.p(oneline)\n            return\n\n        v = qual_ret\n        if len(v) > 3:\n            self.p(v)\n            v = ''\n        elif qual_ret[-1] != '*':\n            v += ' '\n        v += name + '('\n        ind = '\\t' * (len(v) // 8) + ' ' * (len(v) % 8)\n        delta_ind = len(v) - len(ind)\n        v += args[0]\n        i = 1\n        while i < len(args):\n            next_len = len(v) + len(args[i])\n            if v[0] == '\\t':\n                next_len += delta_ind\n            if next_len > 76:\n                self.p(v + ',')\n                v = ind\n            else:\n                v += ', '\n            v += args[i]\n            i += 1\n        self.p(v + ')' + suffix)\n\n    def write_func_lvar(self, local_vars):\n        if not local_vars:\n            return\n\n        if type(local_vars) is str:\n            local_vars = [local_vars]\n\n        local_vars.sort(key=len, reverse=True)\n        for var in local_vars:\n            self.p(var)\n        self.nl()\n\n    def write_func(self, qual_ret, name, body, args=None, local_vars=None):\n        self.write_func_prot(qual_ret=qual_ret, name=name, args=args)\n        self.write_func_lvar(local_vars=local_vars)\n\n        self.block_start()\n        for line in body:\n            self.p(line)\n        self.block_end()\n\n    def writes_defines(self, defines):\n        longest = 0\n        for define in defines:\n            if len(define[0]) > longest:\n                longest = len(define[0])\n        longest = ((longest + 8) // 8) * 8\n        for define in defines:\n            line = '#define ' + define[0]\n            line += '\\t' * ((longest - len(define[0]) + 7) // 8)\n            if type(define[1]) is int:\n                line += str(define[1])\n            elif type(define[1]) is str:\n                line += '\"' + define[1] + '\"'\n            self.p(line)\n\n    def write_struct_init(self, members):\n        longest = max([len(x[0]) for x in members])\n        longest += 1  # because we prepend a .\n        longest = ((longest + 8) // 8) * 8\n        for one in members:\n            line = '.' + one[0]\n            line += '\\t' * ((longest - len(one[0]) - 1 + 7) // 8)\n            line += '= ' + one[1] + ','\n            self.p(line)\n\n\nscalars = {'u8', 'u16', 'u32', 'u64', 's32', 's64'}\n\ndirection_to_suffix = {\n    'reply': '_rsp',\n    'request': '_req',\n    '': ''\n}\n\nop_mode_to_wrapper = {\n    'do': '',\n    'dump': '_list',\n    'notify': '_ntf',\n    'event': '',\n}\n\n_C_KW = {\n    'auto',\n    'bool',\n    'break',\n    'case',\n    'char',\n    'const',\n    'continue',\n    'default',\n    'do',\n    'double',\n    'else',\n    'enum',\n    'extern',\n    'float',\n    'for',\n    'goto',\n    'if',\n    'inline',\n    'int',\n    'long',\n    'register',\n    'return',\n    'short',\n    'signed',\n    'sizeof',\n    'static',\n    'struct',\n    'switch',\n    'typedef',\n    'union',\n    'unsigned',\n    'void',\n    'volatile',\n    'while'\n}\n\n\ndef rdir(direction):\n    if direction == 'reply':\n        return 'request'\n    if direction == 'request':\n        return 'reply'\n    return direction\n\n\ndef op_prefix(ri, direction, deref=False):\n    suffix = f\"_{ri.type_name}\"\n\n    if not ri.op_mode or ri.op_mode == 'do':\n        suffix += f\"{direction_to_suffix[direction]}\"\n    else:\n        if direction == 'request':\n            suffix += '_req_dump'\n        else:\n            if ri.type_consistent:\n                if deref:\n                    suffix += f\"{direction_to_suffix[direction]}\"\n                else:\n                    suffix += op_mode_to_wrapper[ri.op_mode]\n            else:\n                suffix += '_rsp'\n                suffix += '_dump' if deref else '_list'\n\n    return f\"{ri.family['name']}{suffix}\"\n\n\ndef type_name(ri, direction, deref=False):\n    return f\"struct {op_prefix(ri, direction, deref=deref)}\"\n\n\ndef print_prototype(ri, direction, terminate=True, doc=None):\n    suffix = ';' if terminate else ''\n\n    fname = ri.op.render_name\n    if ri.op_mode == 'dump':\n        fname += '_dump'\n\n    args = ['struct ynl_sock *ys']\n    if 'request' in ri.op[ri.op_mode]:\n        args.append(f\"{type_name(ri, direction)} *\" + f\"{direction_to_suffix[direction][1:]}\")\n\n    ret = 'int'\n    if 'reply' in ri.op[ri.op_mode]:\n        ret = f\"{type_name(ri, rdir(direction))} *\"\n\n    ri.cw.write_func_prot(ret, fname, args, doc=doc, suffix=suffix)\n\n\ndef print_req_prototype(ri):\n    print_prototype(ri, \"request\", doc=ri.op['doc'])\n\n\ndef print_dump_prototype(ri):\n    print_prototype(ri, \"request\")\n\n\ndef put_typol(cw, struct):\n    type_max = struct.attr_set.max_name\n    cw.block_start(line=f'struct ynl_policy_attr {struct.render_name}_policy[{type_max} + 1] =')\n\n    for _, arg in struct.member_list():\n        arg.attr_typol(cw)\n\n    cw.block_end(line=';')\n    cw.nl()\n\n    cw.block_start(line=f'struct ynl_policy_nest {struct.render_name}_nest =')\n    cw.p(f'.max_attr = {type_max},')\n    cw.p(f'.table = {struct.render_name}_policy,')\n    cw.block_end(line=';')\n    cw.nl()\n\n\ndef _put_enum_to_str_helper(cw, render_name, map_name, arg_name, enum=None):\n    args = [f'int {arg_name}']\n    if enum and not ('enum-name' in enum and not enum['enum-name']):\n        args = [f'enum {render_name} {arg_name}']\n    cw.write_func_prot('const char *', f'{render_name}_str', args)\n    cw.block_start()\n    if enum and enum.type == 'flags':\n        cw.p(f'{arg_name} = ffs({arg_name}) - 1;')\n    cw.p(f'if ({arg_name} < 0 || {arg_name} >= (int)MNL_ARRAY_SIZE({map_name}))')\n    cw.p('return NULL;')\n    cw.p(f'return {map_name}[{arg_name}];')\n    cw.block_end()\n    cw.nl()\n\n\ndef put_op_name_fwd(family, cw):\n    cw.write_func_prot('const char *', f'{family.name}_op_str', ['int op'], suffix=';')\n\n\ndef put_op_name(family, cw):\n    map_name = f'{family.name}_op_strmap'\n    cw.block_start(line=f\"static const char * const {map_name}[] =\")\n    for op_name, op in family.msgs.items():\n        if op.rsp_value:\n            if op.req_value == op.rsp_value:\n                cw.p(f'[{op.enum_name}] = \"{op_name}\",')\n            else:\n                cw.p(f'[{op.rsp_value}] = \"{op_name}\",')\n    cw.block_end(line=';')\n    cw.nl()\n\n    _put_enum_to_str_helper(cw, family.name + '_op', map_name, 'op')\n\n\ndef put_enum_to_str_fwd(family, cw, enum):\n    args = [f'enum {enum.render_name} value']\n    if 'enum-name' in enum and not enum['enum-name']:\n        args = ['int value']\n    cw.write_func_prot('const char *', f'{enum.render_name}_str', args, suffix=';')\n\n\ndef put_enum_to_str(family, cw, enum):\n    map_name = f'{enum.render_name}_strmap'\n    cw.block_start(line=f\"static const char * const {map_name}[] =\")\n    for entry in enum.entries.values():\n        cw.p(f'[{entry.value}] = \"{entry.name}\",')\n    cw.block_end(line=';')\n    cw.nl()\n\n    _put_enum_to_str_helper(cw, enum.render_name, map_name, 'value', enum=enum)\n\n\ndef put_req_nested(ri, struct):\n    func_args = ['struct nlmsghdr *nlh',\n                 'unsigned int attr_type',\n                 f'{struct.ptr_name}obj']\n\n    ri.cw.write_func_prot('int', f'{struct.render_name}_put', func_args)\n    ri.cw.block_start()\n    ri.cw.write_func_lvar('struct nlattr *nest;')\n\n    ri.cw.p(\"nest = mnl_attr_nest_start(nlh, attr_type);\")\n\n    for _, arg in struct.member_list():\n        arg.attr_put(ri, \"obj\")\n\n    ri.cw.p(\"mnl_attr_nest_end(nlh, nest);\")\n\n    ri.cw.nl()\n    ri.cw.p('return 0;')\n    ri.cw.block_end()\n    ri.cw.nl()\n\n\ndef _multi_parse(ri, struct, init_lines, local_vars):\n    if struct.nested:\n        iter_line = \"mnl_attr_for_each_nested(attr, nested)\"\n    else:\n        iter_line = \"mnl_attr_for_each(attr, nlh, sizeof(struct genlmsghdr))\"\n\n    array_nests = set()\n    multi_attrs = set()\n    needs_parg = False\n    for arg, aspec in struct.member_list():\n        if aspec['type'] == 'array-nest':\n            local_vars.append(f'const struct nlattr *attr_{aspec.c_name};')\n            array_nests.add(arg)\n        if 'multi-attr' in aspec:\n            multi_attrs.add(arg)\n        needs_parg |= 'nested-attributes' in aspec\n    if array_nests or multi_attrs:\n        local_vars.append('int i;')\n    if needs_parg:\n        local_vars.append('struct ynl_parse_arg parg;')\n        init_lines.append('parg.ys = yarg->ys;')\n\n    all_multi = array_nests | multi_attrs\n\n    for anest in sorted(all_multi):\n        local_vars.append(f\"unsigned int n_{struct[anest].c_name} = 0;\")\n\n    ri.cw.block_start()\n    ri.cw.write_func_lvar(local_vars)\n\n    for line in init_lines:\n        ri.cw.p(line)\n    ri.cw.nl()\n\n    for arg in struct.inherited:\n        ri.cw.p(f'dst->{arg} = {arg};')\n\n    for anest in sorted(all_multi):\n        aspec = struct[anest]\n        ri.cw.p(f\"if (dst->{aspec.c_name})\")\n        ri.cw.p(f'return ynl_error_parse(yarg, \"attribute already present ({struct.attr_set.name}.{aspec.name})\");')\n\n    ri.cw.nl()\n    ri.cw.block_start(line=iter_line)\n    ri.cw.p('unsigned int type = mnl_attr_get_type(attr);')\n    ri.cw.nl()\n\n    first = True\n    for _, arg in struct.member_list():\n        good = arg.attr_get(ri, 'dst', first=first)\n        # First may be 'unused' or 'pad', ignore those\n        first &= not good\n\n    ri.cw.block_end()\n    ri.cw.nl()\n\n    for anest in sorted(array_nests):\n        aspec = struct[anest]\n\n        ri.cw.block_start(line=f\"if (n_{aspec.c_name})\")\n        ri.cw.p(f\"dst->{aspec.c_name} = calloc({aspec.c_name}, sizeof(*dst->{aspec.c_name}));\")\n        ri.cw.p(f\"dst->n_{aspec.c_name} = n_{aspec.c_name};\")\n        ri.cw.p('i = 0;')\n        ri.cw.p(f\"parg.rsp_policy = &{aspec.nested_render_name}_nest;\")\n        ri.cw.block_start(line=f\"mnl_attr_for_each_nested(attr, attr_{aspec.c_name})\")\n        ri.cw.p(f\"parg.data = &dst->{aspec.c_name}[i];\")\n        ri.cw.p(f\"if ({aspec.nested_render_name}_parse(&parg, attr, mnl_attr_get_type(attr)))\")\n        ri.cw.p('return MNL_CB_ERROR;')\n        ri.cw.p('i++;')\n        ri.cw.block_end()\n        ri.cw.block_end()\n    ri.cw.nl()\n\n    for anest in sorted(multi_attrs):\n        aspec = struct[anest]\n        ri.cw.block_start(line=f\"if (n_{aspec.c_name})\")\n        ri.cw.p(f\"dst->{aspec.c_name} = calloc(n_{aspec.c_name}, sizeof(*dst->{aspec.c_name}));\")\n        ri.cw.p(f\"dst->n_{aspec.c_name} = n_{aspec.c_name};\")\n        ri.cw.p('i = 0;')\n        if 'nested-attributes' in aspec:\n            ri.cw.p(f\"parg.rsp_policy = &{aspec.nested_render_name}_nest;\")\n        ri.cw.block_start(line=iter_line)\n        ri.cw.block_start(line=f\"if (mnl_attr_get_type(attr) == {aspec.enum_name})\")\n        if 'nested-attributes' in aspec:\n            ri.cw.p(f\"parg.data = &dst->{aspec.c_name}[i];\")\n            ri.cw.p(f\"if ({aspec.nested_render_name}_parse(&parg, attr))\")\n            ri.cw.p('return MNL_CB_ERROR;')\n        elif aspec['type'] in scalars:\n            t = aspec['type']\n            if t[0] == 's':\n                t = 'u' + t[1:]\n            ri.cw.p(f\"dst->{aspec.c_name}[i] = mnl_attr_get_{t}(attr);\")\n        else:\n            raise Exception('Nest parsing type not supported yet')\n        ri.cw.p('i++;')\n        ri.cw.block_end()\n        ri.cw.block_end()\n        ri.cw.block_end()\n    ri.cw.nl()\n\n    if struct.nested:\n        ri.cw.p('return 0;')\n    else:\n        ri.cw.p('return MNL_CB_OK;')\n    ri.cw.block_end()\n    ri.cw.nl()\n\n\ndef parse_rsp_nested(ri, struct):\n    func_args = ['struct ynl_parse_arg *yarg',\n                 'const struct nlattr *nested']\n    for arg in struct.inherited:\n        func_args.append('__u32 ' + arg)\n\n    local_vars = ['const struct nlattr *attr;',\n                  f'{struct.ptr_name}dst = yarg->data;']\n    init_lines = []\n\n    ri.cw.write_func_prot('int', f'{struct.render_name}_parse', func_args)\n\n    _multi_parse(ri, struct, init_lines, local_vars)\n\n\ndef parse_rsp_msg(ri, deref=False):\n    if 'reply' not in ri.op[ri.op_mode] and ri.op_mode != 'event':\n        return\n\n    func_args = ['const struct nlmsghdr *nlh',\n                 'void *data']\n\n    local_vars = [f'{type_name(ri, \"reply\", deref=deref)} *dst;',\n                  'struct ynl_parse_arg *yarg = data;',\n                  'const struct nlattr *attr;']\n    init_lines = ['dst = yarg->data;']\n\n    ri.cw.write_func_prot('int', f'{op_prefix(ri, \"reply\", deref=deref)}_parse', func_args)\n\n    if ri.struct[\"reply\"].member_list():\n        _multi_parse(ri, ri.struct[\"reply\"], init_lines, local_vars)\n    else:\n        # Empty reply\n        ri.cw.block_start()\n        ri.cw.p('return MNL_CB_OK;')\n        ri.cw.block_end()\n        ri.cw.nl()\n\n\ndef print_req(ri):\n    ret_ok = '0'\n    ret_err = '-1'\n    direction = \"request\"\n    local_vars = ['struct nlmsghdr *nlh;',\n                  'int err;']\n\n    if 'reply' in ri.op[ri.op_mode]:\n        ret_ok = 'rsp'\n        ret_err = 'NULL'\n        local_vars += [f'{type_name(ri, rdir(direction))} *rsp;',\n                       'struct ynl_req_state yrs = { .yarg = { .ys = ys, }, };']\n\n    print_prototype(ri, direction, terminate=False)\n    ri.cw.block_start()\n    ri.cw.write_func_lvar(local_vars)\n\n    ri.cw.p(f\"nlh = ynl_gemsg_start_req(ys, {ri.nl.get_family_id()}, {ri.op.enum_name}, 1);\")\n\n    ri.cw.p(f\"ys->req_policy = &{ri.struct['request'].render_name}_nest;\")\n    if 'reply' in ri.op[ri.op_mode]:\n        ri.cw.p(f\"yrs.yarg.rsp_policy = &{ri.struct['reply'].render_name}_nest;\")\n    ri.cw.nl()\n    for _, attr in ri.struct[\"request\"].member_list():\n        attr.attr_put(ri, \"req\")\n    ri.cw.nl()\n\n    parse_arg = \"NULL\"\n    if 'reply' in ri.op[ri.op_mode]:\n        ri.cw.p('rsp = calloc(1, sizeof(*rsp));')\n        ri.cw.p('yrs.yarg.data = rsp;')\n        ri.cw.p(f\"yrs.cb = {op_prefix(ri, 'reply')}_parse;\")\n        if ri.op.value is not None:\n            ri.cw.p(f'yrs.rsp_cmd = {ri.op.enum_name};')\n        else:\n            ri.cw.p(f'yrs.rsp_cmd = {ri.op.rsp_value};')\n        ri.cw.nl()\n        parse_arg = '&yrs'\n    ri.cw.p(f\"err = ynl_exec(ys, nlh, {parse_arg});\")\n    ri.cw.p('if (err < 0)')\n    if 'reply' in ri.op[ri.op_mode]:\n        ri.cw.p('goto err_free;')\n    else:\n        ri.cw.p('return -1;')\n    ri.cw.nl()\n\n    ri.cw.p(f\"return {ret_ok};\")\n    ri.cw.nl()\n\n    if 'reply' in ri.op[ri.op_mode]:\n        ri.cw.p('err_free:')\n        ri.cw.p(f\"{call_free(ri, rdir(direction), 'rsp')}\")\n        ri.cw.p(f\"return {ret_err};\")\n\n    ri.cw.block_end()\n\n\ndef print_dump(ri):\n    direction = \"request\"\n    print_prototype(ri, direction, terminate=False)\n    ri.cw.block_start()\n    local_vars = ['struct ynl_dump_state yds = {};',\n                  'struct nlmsghdr *nlh;',\n                  'int err;']\n\n    for var in local_vars:\n        ri.cw.p(f'{var}')\n    ri.cw.nl()\n\n    ri.cw.p('yds.ys = ys;')\n    ri.cw.p(f\"yds.alloc_sz = sizeof({type_name(ri, rdir(direction))});\")\n    ri.cw.p(f\"yds.cb = {op_prefix(ri, 'reply', deref=True)}_parse;\")\n    if ri.op.value is not None:\n        ri.cw.p(f'yds.rsp_cmd = {ri.op.enum_name};')\n    else:\n        ri.cw.p(f'yds.rsp_cmd = {ri.op.rsp_value};')\n    ri.cw.p(f\"yds.rsp_policy = &{ri.struct['reply'].render_name}_nest;\")\n    ri.cw.nl()\n    ri.cw.p(f\"nlh = ynl_gemsg_start_dump(ys, {ri.nl.get_family_id()}, {ri.op.enum_name}, 1);\")\n\n    if \"request\" in ri.op[ri.op_mode]:\n        ri.cw.p(f\"ys->req_policy = &{ri.struct['request'].render_name}_nest;\")\n        ri.cw.nl()\n        for _, attr in ri.struct[\"request\"].member_list():\n            attr.attr_put(ri, \"req\")\n    ri.cw.nl()\n\n    ri.cw.p('err = ynl_exec_dump(ys, nlh, &yds);')\n    ri.cw.p('if (err < 0)')\n    ri.cw.p('goto free_list;')\n    ri.cw.nl()\n\n    ri.cw.p('return yds.first;')\n    ri.cw.nl()\n    ri.cw.p('free_list:')\n    ri.cw.p(call_free(ri, rdir(direction), 'yds.first'))\n    ri.cw.p('return NULL;')\n    ri.cw.block_end()\n\n\ndef call_free(ri, direction, var):\n    return f\"{op_prefix(ri, direction)}_free({var});\"\n\n\ndef free_arg_name(direction):\n    if direction:\n        return direction_to_suffix[direction][1:]\n    return 'obj'\n\n\ndef print_alloc_wrapper(ri, direction):\n    name = op_prefix(ri, direction)\n    ri.cw.write_func_prot(f'static inline struct {name} *', f\"{name}_alloc\", [f\"void\"])\n    ri.cw.block_start()\n    ri.cw.p(f'return calloc(1, sizeof(struct {name}));')\n    ri.cw.block_end()\n\n\ndef print_free_prototype(ri, direction, suffix=';'):\n    name = op_prefix(ri, direction)\n    struct_name = name\n    if ri.type_name_conflict:\n        struct_name += '_'\n    arg = free_arg_name(direction)\n    ri.cw.write_func_prot('void', f\"{name}_free\", [f\"struct {struct_name} *{arg}\"], suffix=suffix)\n\n\ndef _print_type(ri, direction, struct):\n    suffix = f'_{ri.type_name}{direction_to_suffix[direction]}'\n    if not direction and ri.type_name_conflict:\n        suffix += '_'\n\n    if ri.op_mode == 'dump':\n        suffix += '_dump'\n\n    ri.cw.block_start(line=f\"struct {ri.family['name']}{suffix}\")\n\n    meta_started = False\n    for _, attr in struct.member_list():\n        for type_filter in ['len', 'bit']:\n            line = attr.presence_member(ri.ku_space, type_filter)\n            if line:\n                if not meta_started:\n                    ri.cw.block_start(line=f\"struct\")\n                    meta_started = True\n                ri.cw.p(line)\n    if meta_started:\n        ri.cw.block_end(line='_present;')\n        ri.cw.nl()\n\n    for arg in struct.inherited:\n        ri.cw.p(f\"__u32 {arg};\")\n\n    for _, attr in struct.member_list():\n        attr.struct_member(ri)\n\n    ri.cw.block_end(line=';')\n    ri.cw.nl()\n\n\ndef print_type(ri, direction):\n    _print_type(ri, direction, ri.struct[direction])\n\n\ndef print_type_full(ri, struct):\n    _print_type(ri, \"\", struct)\n\n\ndef print_type_helpers(ri, direction, deref=False):\n    print_free_prototype(ri, direction)\n    ri.cw.nl()\n\n    if ri.ku_space == 'user' and direction == 'request':\n        for _, attr in ri.struct[direction].member_list():\n            attr.setter(ri, ri.attr_set, direction, deref=deref)\n    ri.cw.nl()\n\n\ndef print_req_type_helpers(ri):\n    print_alloc_wrapper(ri, \"request\")\n    print_type_helpers(ri, \"request\")\n\n\ndef print_rsp_type_helpers(ri):\n    if 'reply' not in ri.op[ri.op_mode]:\n        return\n    print_type_helpers(ri, \"reply\")\n\n\ndef print_parse_prototype(ri, direction, terminate=True):\n    suffix = \"_rsp\" if direction == \"reply\" else \"_req\"\n    term = ';' if terminate else ''\n\n    ri.cw.write_func_prot('void', f\"{ri.op.render_name}{suffix}_parse\",\n                          ['const struct nlattr **tb',\n                           f\"struct {ri.op.render_name}{suffix} *req\"],\n                          suffix=term)\n\n\ndef print_req_type(ri):\n    print_type(ri, \"request\")\n\n\ndef print_req_free(ri):\n    if 'request' not in ri.op[ri.op_mode]:\n        return\n    _free_type(ri, 'request', ri.struct['request'])\n\n\ndef print_rsp_type(ri):\n    if (ri.op_mode == 'do' or ri.op_mode == 'dump') and 'reply' in ri.op[ri.op_mode]:\n        direction = 'reply'\n    elif ri.op_mode == 'event':\n        direction = 'reply'\n    else:\n        return\n    print_type(ri, direction)\n\n\ndef print_wrapped_type(ri):\n    ri.cw.block_start(line=f\"{type_name(ri, 'reply')}\")\n    if ri.op_mode == 'dump':\n        ri.cw.p(f\"{type_name(ri, 'reply')} *next;\")\n    elif ri.op_mode == 'notify' or ri.op_mode == 'event':\n        ri.cw.p('__u16 family;')\n        ri.cw.p('__u8 cmd;')\n        ri.cw.p('struct ynl_ntf_base_type *next;')\n        ri.cw.p(f\"void (*free)({type_name(ri, 'reply')} *ntf);\")\n    ri.cw.p(f\"{type_name(ri, 'reply', deref=True)} obj __attribute__ ((aligned (8)));\")\n    ri.cw.block_end(line=';')\n    ri.cw.nl()\n    print_free_prototype(ri, 'reply')\n    ri.cw.nl()\n\n\ndef _free_type_members_iter(ri, struct):\n    for _, attr in struct.member_list():\n        if attr.free_needs_iter():\n            ri.cw.p('unsigned int i;')\n            ri.cw.nl()\n            break\n\n\ndef _free_type_members(ri, var, struct, ref=''):\n    for _, attr in struct.member_list():\n        attr.free(ri, var, ref)\n\n\ndef _free_type(ri, direction, struct):\n    var = free_arg_name(direction)\n\n    print_free_prototype(ri, direction, suffix='')\n    ri.cw.block_start()\n    _free_type_members_iter(ri, struct)\n    _free_type_members(ri, var, struct)\n    if direction:\n        ri.cw.p(f'free({var});')\n    ri.cw.block_end()\n    ri.cw.nl()\n\n\ndef free_rsp_nested(ri, struct):\n    _free_type(ri, \"\", struct)\n\n\ndef print_rsp_free(ri):\n    if 'reply' not in ri.op[ri.op_mode]:\n        return\n    _free_type(ri, 'reply', ri.struct['reply'])\n\n\ndef print_dump_type_free(ri):\n    sub_type = type_name(ri, 'reply')\n\n    print_free_prototype(ri, 'reply', suffix='')\n    ri.cw.block_start()\n    ri.cw.p(f\"{sub_type} *next = rsp;\")\n    ri.cw.nl()\n    ri.cw.block_start(line='while ((void *)next != YNL_LIST_END)')\n    _free_type_members_iter(ri, ri.struct['reply'])\n    ri.cw.p('rsp = next;')\n    ri.cw.p('next = rsp->next;')\n    ri.cw.nl()\n\n    _free_type_members(ri, 'rsp', ri.struct['reply'], ref='obj.')\n    ri.cw.p(f'free(rsp);')\n    ri.cw.block_end()\n    ri.cw.block_end()\n    ri.cw.nl()\n\n\ndef print_ntf_type_free(ri):\n    print_free_prototype(ri, 'reply', suffix='')\n    ri.cw.block_start()\n    _free_type_members_iter(ri, ri.struct['reply'])\n    _free_type_members(ri, 'rsp', ri.struct['reply'], ref='obj.')\n    ri.cw.p(f'free(rsp);')\n    ri.cw.block_end()\n    ri.cw.nl()\n\n\ndef print_req_policy_fwd(cw, struct, ri=None, terminate=True):\n    if terminate and ri and policy_should_be_static(struct.family):\n        return\n\n    if terminate:\n        prefix = 'extern '\n    else:\n        if ri and policy_should_be_static(struct.family):\n            prefix = 'static '\n        else:\n            prefix = ''\n\n    suffix = ';' if terminate else ' = {'\n\n    max_attr = struct.attr_max_val\n    if ri:\n        name = ri.op.render_name\n        if ri.op.dual_policy:\n            name += '_' + ri.op_mode\n    else:\n        name = struct.render_name\n    cw.p(f\"{prefix}const struct nla_policy {name}_nl_policy[{max_attr.enum_name} + 1]{suffix}\")\n\n\ndef print_req_policy(cw, struct, ri=None):\n    print_req_policy_fwd(cw, struct, ri=ri, terminate=False)\n    for _, arg in struct.member_list():\n        arg.attr_policy(cw)\n    cw.p(\"};\")\n    cw.nl()\n\n\ndef kernel_can_gen_family_struct(family):\n    return family.proto == 'genetlink'\n\n\ndef policy_should_be_static(family):\n    return family.kernel_policy == 'split' or kernel_can_gen_family_struct(family)\n\n\ndef print_kernel_op_table_fwd(family, cw, terminate):\n    exported = not kernel_can_gen_family_struct(family)\n\n    if not terminate or exported:\n        cw.p(f\"/* Ops table for {family.name} */\")\n\n        pol_to_struct = {'global': 'genl_small_ops',\n                         'per-op': 'genl_ops',\n                         'split': 'genl_split_ops'}\n        struct_type = pol_to_struct[family.kernel_policy]\n\n        if not exported:\n            cnt = \"\"\n        elif family.kernel_policy == 'split':\n            cnt = 0\n            for op in family.ops.values():\n                if 'do' in op:\n                    cnt += 1\n                if 'dump' in op:\n                    cnt += 1\n        else:\n            cnt = len(family.ops)\n\n        qual = 'static const' if not exported else 'const'\n        line = f\"{qual} struct {struct_type} {family.name}_nl_ops[{cnt}]\"\n        if terminate:\n            cw.p(f\"extern {line};\")\n        else:\n            cw.block_start(line=line + ' =')\n\n    if not terminate:\n        return\n\n    cw.nl()\n    for name in family.hooks['pre']['do']['list']:\n        cw.write_func_prot('int', c_lower(name),\n                           ['const struct genl_split_ops *ops',\n                            'struct sk_buff *skb', 'struct genl_info *info'], suffix=';')\n    for name in family.hooks['post']['do']['list']:\n        cw.write_func_prot('void', c_lower(name),\n                           ['const struct genl_split_ops *ops',\n                            'struct sk_buff *skb', 'struct genl_info *info'], suffix=';')\n    for name in family.hooks['pre']['dump']['list']:\n        cw.write_func_prot('int', c_lower(name),\n                           ['struct netlink_callback *cb'], suffix=';')\n    for name in family.hooks['post']['dump']['list']:\n        cw.write_func_prot('int', c_lower(name),\n                           ['struct netlink_callback *cb'], suffix=';')\n\n    cw.nl()\n\n    for op_name, op in family.ops.items():\n        if op.is_async:\n            continue\n\n        if 'do' in op:\n            name = c_lower(f\"{family.name}-nl-{op_name}-doit\")\n            cw.write_func_prot('int', name,\n                               ['struct sk_buff *skb', 'struct genl_info *info'], suffix=';')\n\n        if 'dump' in op:\n            name = c_lower(f\"{family.name}-nl-{op_name}-dumpit\")\n            cw.write_func_prot('int', name,\n                               ['struct sk_buff *skb', 'struct netlink_callback *cb'], suffix=';')\n    cw.nl()\n\n\ndef print_kernel_op_table_hdr(family, cw):\n    print_kernel_op_table_fwd(family, cw, terminate=True)\n\n\ndef print_kernel_op_table(family, cw):\n    print_kernel_op_table_fwd(family, cw, terminate=False)\n    if family.kernel_policy == 'global' or family.kernel_policy == 'per-op':\n        for op_name, op in family.ops.items():\n            if op.is_async:\n                continue\n\n            cw.block_start()\n            members = [('cmd', op.enum_name)]\n            if 'dont-validate' in op:\n                members.append(('validate',\n                                ' | '.join([c_upper('genl-dont-validate-' + x)\n                                            for x in op['dont-validate']])), )\n            for op_mode in ['do', 'dump']:\n                if op_mode in op:\n                    name = c_lower(f\"{family.name}-nl-{op_name}-{op_mode}it\")\n                    members.append((op_mode + 'it', name))\n            if family.kernel_policy == 'per-op':\n                struct = Struct(family, op['attribute-set'],\n                                type_list=op['do']['request']['attributes'])\n\n                name = c_lower(f\"{family.name}-{op_name}-nl-policy\")\n                members.append(('policy', name))\n                members.append(('maxattr', struct.attr_max_val.enum_name))\n            if 'flags' in op:\n                members.append(('flags', ' | '.join([c_upper('genl-' + x) for x in op['flags']])))\n            cw.write_struct_init(members)\n            cw.block_end(line=',')\n    elif family.kernel_policy == 'split':\n        cb_names = {'do':   {'pre': 'pre_doit', 'post': 'post_doit'},\n                    'dump': {'pre': 'start', 'post': 'done'}}\n\n        for op_name, op in family.ops.items():\n            for op_mode in ['do', 'dump']:\n                if op.is_async or op_mode not in op:\n                    continue\n\n                cw.block_start()\n                members = [('cmd', op.enum_name)]\n                if 'dont-validate' in op:\n                    dont_validate = []\n                    for x in op['dont-validate']:\n                        if op_mode == 'do' and x in ['dump', 'dump-strict']:\n                            continue\n                        if op_mode == \"dump\" and x == 'strict':\n                            continue\n                        dont_validate.append(x)\n\n                    if dont_validate:\n                        members.append(('validate',\n                                        ' | '.join([c_upper('genl-dont-validate-' + x)\n                                                    for x in dont_validate])), )\n                name = c_lower(f\"{family.name}-nl-{op_name}-{op_mode}it\")\n                if 'pre' in op[op_mode]:\n                    members.append((cb_names[op_mode]['pre'], c_lower(op[op_mode]['pre'])))\n                members.append((op_mode + 'it', name))\n                if 'post' in op[op_mode]:\n                    members.append((cb_names[op_mode]['post'], c_lower(op[op_mode]['post'])))\n                if 'request' in op[op_mode]:\n                    struct = Struct(family, op['attribute-set'],\n                                    type_list=op[op_mode]['request']['attributes'])\n\n                    if op.dual_policy:\n                        name = c_lower(f\"{family.name}-{op_name}-{op_mode}-nl-policy\")\n                    else:\n                        name = c_lower(f\"{family.name}-{op_name}-nl-policy\")\n                    members.append(('policy', name))\n                    members.append(('maxattr', struct.attr_max_val.enum_name))\n                flags = (op['flags'] if 'flags' in op else []) + ['cmd-cap-' + op_mode]\n                members.append(('flags', ' | '.join([c_upper('genl-' + x) for x in flags])))\n                cw.write_struct_init(members)\n                cw.block_end(line=',')\n\n    cw.block_end(line=';')\n    cw.nl()\n\n\ndef print_kernel_mcgrp_hdr(family, cw):\n    if not family.mcgrps['list']:\n        return\n\n    cw.block_start('enum')\n    for grp in family.mcgrps['list']:\n        grp_id = c_upper(f\"{family.name}-nlgrp-{grp['name']},\")\n        cw.p(grp_id)\n    cw.block_end(';')\n    cw.nl()\n\n\ndef print_kernel_mcgrp_src(family, cw):\n    if not family.mcgrps['list']:\n        return\n\n    cw.block_start('static const struct genl_multicast_group ' + family.name + '_nl_mcgrps[] =')\n    for grp in family.mcgrps['list']:\n        name = grp['name']\n        grp_id = c_upper(f\"{family.name}-nlgrp-{name}\")\n        cw.p('[' + grp_id + '] = { \"' + name + '\", },')\n    cw.block_end(';')\n    cw.nl()\n\n\ndef print_kernel_family_struct_hdr(family, cw):\n    if not kernel_can_gen_family_struct(family):\n        return\n\n    cw.p(f\"extern struct genl_family {family.name}_nl_family;\")\n    cw.nl()\n\n\ndef print_kernel_family_struct_src(family, cw):\n    if not kernel_can_gen_family_struct(family):\n        return\n\n    cw.block_start(f\"struct genl_family {family.name}_nl_family __ro_after_init =\")\n    cw.p('.name\\t\\t= ' + family.fam_key + ',')\n    cw.p('.version\\t= ' + family.ver_key + ',')\n    cw.p('.netnsok\\t= true,')\n    cw.p('.parallel_ops\\t= true,')\n    cw.p('.module\\t\\t= THIS_MODULE,')\n    if family.kernel_policy == 'per-op':\n        cw.p(f'.ops\\t\\t= {family.name}_nl_ops,')\n        cw.p(f'.n_ops\\t\\t= ARRAY_SIZE({family.name}_nl_ops),')\n    elif family.kernel_policy == 'split':\n        cw.p(f'.split_ops\\t= {family.name}_nl_ops,')\n        cw.p(f'.n_split_ops\\t= ARRAY_SIZE({family.name}_nl_ops),')\n    if family.mcgrps['list']:\n        cw.p(f'.mcgrps\\t\\t= {family.name}_nl_mcgrps,')\n        cw.p(f'.n_mcgrps\\t= ARRAY_SIZE({family.name}_nl_mcgrps),')\n    cw.block_end(';')\n\n\ndef uapi_enum_start(family, cw, obj, ckey='', enum_name='enum-name'):\n    start_line = 'enum'\n    if enum_name in obj:\n        if obj[enum_name]:\n            start_line = 'enum ' + c_lower(obj[enum_name])\n    elif ckey and ckey in obj:\n        start_line = 'enum ' + family.name + '_' + c_lower(obj[ckey])\n    cw.block_start(line=start_line)\n\n\ndef render_uapi(family, cw):\n    hdr_prot = f\"_UAPI_LINUX_{family.name.upper()}_H\"\n    cw.p('#ifndef ' + hdr_prot)\n    cw.p('#define ' + hdr_prot)\n    cw.nl()\n\n    defines = [(family.fam_key, family[\"name\"]),\n               (family.ver_key, family.get('version', 1))]\n    cw.writes_defines(defines)\n    cw.nl()\n\n    defines = []\n    for const in family['definitions']:\n        if const['type'] != 'const':\n            cw.writes_defines(defines)\n            defines = []\n            cw.nl()\n\n        # Write kdoc for enum and flags (one day maybe also structs)\n        if const['type'] == 'enum' or const['type'] == 'flags':\n            enum = family.consts[const['name']]\n\n            if enum.has_doc():\n                cw.p('/**')\n                doc = ''\n                if 'doc' in enum:\n                    doc = ' - ' + enum['doc']\n                cw.write_doc_line(enum.enum_name + doc)\n                for entry in enum.entries.values():\n                    if entry.has_doc():\n                        doc = '@' + entry.c_name + ': ' + entry['doc']\n                        cw.write_doc_line(doc)\n                cw.p(' */')\n\n            uapi_enum_start(family, cw, const, 'name')\n            name_pfx = const.get('name-prefix', f\"{family.name}-{const['name']}-\")\n            for entry in enum.entries.values():\n                suffix = ','\n                if entry.value_change:\n                    suffix = f\" = {entry.user_value()}\" + suffix\n                cw.p(entry.c_name + suffix)\n\n            if const.get('render-max', False):\n                cw.nl()\n                cw.p('/* private: */')\n                if const['type'] == 'flags':\n                    max_name = c_upper(name_pfx + 'mask')\n                    max_val = f' = {enum.get_mask()},'\n                    cw.p(max_name + max_val)\n                else:\n                    max_name = c_upper(name_pfx + 'max')\n                    cw.p('__' + max_name + ',')\n                    cw.p(max_name + ' = (__' + max_name + ' - 1)')\n            cw.block_end(line=';')\n            cw.nl()\n        elif const['type'] == 'const':\n            defines.append([c_upper(family.get('c-define-name',\n                                               f\"{family.name}-{const['name']}\")),\n                            const['value']])\n\n    if defines:\n        cw.writes_defines(defines)\n        cw.nl()\n\n    max_by_define = family.get('max-by-define', False)\n\n    for _, attr_set in family.attr_sets.items():\n        if attr_set.subset_of:\n            continue\n\n        cnt_name = c_upper(family.get('attr-cnt-name', f\"__{attr_set.name_prefix}MAX\"))\n        max_value = f\"({cnt_name} - 1)\"\n\n        val = 0\n        uapi_enum_start(family, cw, attr_set.yaml, 'enum-name')\n        for _, attr in attr_set.items():\n            suffix = ','\n            if attr.value != val:\n                suffix = f\" = {attr.value},\"\n                val = attr.value\n            val += 1\n            cw.p(attr.enum_name + suffix)\n        cw.nl()\n        cw.p(cnt_name + ('' if max_by_define else ','))\n        if not max_by_define:\n            cw.p(f\"{attr_set.max_name} = {max_value}\")\n        cw.block_end(line=';')\n        if max_by_define:\n            cw.p(f\"#define {attr_set.max_name} {max_value}\")\n        cw.nl()\n\n    # Commands\n    separate_ntf = 'async-prefix' in family['operations']\n\n    max_name = c_upper(family.get('cmd-max-name', f\"{family.op_prefix}MAX\"))\n    cnt_name = c_upper(family.get('cmd-cnt-name', f\"__{family.op_prefix}MAX\"))\n    max_value = f\"({cnt_name} - 1)\"\n\n    uapi_enum_start(family, cw, family['operations'], 'enum-name')\n    val = 0\n    for op in family.msgs.values():\n        if separate_ntf and ('notify' in op or 'event' in op):\n            continue\n\n        suffix = ','\n        if op.value != val:\n            suffix = f\" = {op.value},\"\n            val = op.value\n        cw.p(op.enum_name + suffix)\n        val += 1\n    cw.nl()\n    cw.p(cnt_name + ('' if max_by_define else ','))\n    if not max_by_define:\n        cw.p(f\"{max_name} = {max_value}\")\n    cw.block_end(line=';')\n    if max_by_define:\n        cw.p(f\"#define {max_name} {max_value}\")\n    cw.nl()\n\n    if separate_ntf:\n        uapi_enum_start(family, cw, family['operations'], enum_name='async-enum')\n        for op in family.msgs.values():\n            if separate_ntf and not ('notify' in op or 'event' in op):\n                continue\n\n            suffix = ','\n            if 'value' in op:\n                suffix = f\" = {op['value']},\"\n            cw.p(op.enum_name + suffix)\n        cw.block_end(line=';')\n        cw.nl()\n\n    # Multicast\n    defines = []\n    for grp in family.mcgrps['list']:\n        name = grp['name']\n        defines.append([c_upper(grp.get('c-define-name', f\"{family.name}-mcgrp-{name}\")),\n                        f'{name}'])\n    cw.nl()\n    if defines:\n        cw.writes_defines(defines)\n        cw.nl()\n\n    cw.p(f'#endif /* {hdr_prot} */')\n\n\ndef _render_user_ntf_entry(ri, op):\n    ri.cw.block_start(line=f\"[{op.enum_name}] = \")\n    ri.cw.p(f\".alloc_sz\\t= sizeof({type_name(ri, 'event')}),\")\n    ri.cw.p(f\".cb\\t\\t= {op_prefix(ri, 'reply', deref=True)}_parse,\")\n    ri.cw.p(f\".policy\\t\\t= &{ri.struct['reply'].render_name}_nest,\")\n    ri.cw.p(f\".free\\t\\t= (void *){op_prefix(ri, 'notify')}_free,\")\n    ri.cw.block_end(line=',')\n\n\ndef render_user_family(family, cw, prototype):\n    symbol = f'const struct ynl_family ynl_{family.c_name}_family'\n    if prototype:\n        cw.p(f'extern {symbol};')\n        return\n\n    if family.ntfs:\n        cw.block_start(line=f\"static const struct ynl_ntf_info {family['name']}_ntf_info[] = \")\n        for ntf_op_name, ntf_op in family.ntfs.items():\n            if 'notify' in ntf_op:\n                op = family.ops[ntf_op['notify']]\n                ri = RenderInfo(cw, family, \"user\", op, \"notify\")\n            elif 'event' in ntf_op:\n                ri = RenderInfo(cw, family, \"user\", ntf_op, \"event\")\n            else:\n                raise Exception('Invalid notification ' + ntf_op_name)\n            _render_user_ntf_entry(ri, ntf_op)\n        for op_name, op in family.ops.items():\n            if 'event' not in op:\n                continue\n            ri = RenderInfo(cw, family, \"user\", op, \"event\")\n            _render_user_ntf_entry(ri, op)\n        cw.block_end(line=\";\")\n        cw.nl()\n\n    cw.block_start(f'{symbol} = ')\n    cw.p(f'.name\\t\\t= \"{family.name}\",')\n    if family.ntfs:\n        cw.p(f\".ntf_info\\t= {family['name']}_ntf_info,\")\n        cw.p(f\".ntf_info_size\\t= MNL_ARRAY_SIZE({family['name']}_ntf_info),\")\n    cw.block_end(line=';')\n\n\ndef find_kernel_root(full_path):\n    sub_path = ''\n    while True:\n        sub_path = os.path.join(os.path.basename(full_path), sub_path)\n        full_path = os.path.dirname(full_path)\n        maintainers = os.path.join(full_path, \"MAINTAINERS\")\n        if os.path.exists(maintainers):\n            return full_path, sub_path[:-1]\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='Netlink simple parsing generator')\n    parser.add_argument('--mode', dest='mode', type=str, required=True)\n    parser.add_argument('--spec', dest='spec', type=str, required=True)\n    parser.add_argument('--header', dest='header', action='store_true', default=None)\n    parser.add_argument('--source', dest='header', action='store_false')\n    parser.add_argument('--user-header', nargs='+', default=[])\n    parser.add_argument('--exclude-op', action='append', default=[])\n    parser.add_argument('-o', dest='out_file', type=str, default=None)\n    args = parser.parse_args()\n\n    if args.header is None:\n        parser.error(\"--header or --source is required\")\n\n    exclude_ops = [re.compile(expr) for expr in args.exclude_op]\n\n    try:\n        parsed = Family(args.spec, exclude_ops)\n        if parsed.license != '((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)':\n            print('Spec license:', parsed.license)\n            print('License must be: ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)')\n            os.sys.exit(1)\n    except yaml.YAMLError as exc:\n        print(exc)\n        os.sys.exit(1)\n        return\n\n    supported_models = ['unified']\n    if args.mode in ['user', 'kernel']:\n        supported_models += ['directional']\n    if parsed.msg_id_model not in supported_models:\n        print(f'Message enum-model {parsed.msg_id_model} not supported for {args.mode} generation')\n        os.sys.exit(1)\n\n    cw = CodeWriter(BaseNlLib(), args.out_file)\n\n    _, spec_kernel = find_kernel_root(args.spec)\n    if args.mode == 'uapi' or args.header:\n        cw.p(f'/* SPDX-License-Identifier: {parsed.license} */')\n    else:\n        cw.p(f'// SPDX-License-Identifier: {parsed.license}')\n    cw.p(\"/* Do not edit directly, auto-generated from: */\")\n    cw.p(f\"/*\\t{spec_kernel} */\")\n    cw.p(f\"/* YNL-GEN {args.mode} {'header' if args.header else 'source'} */\")\n    if args.exclude_op or args.user_header:\n        line = ''\n        line += ' --user-header '.join([''] + args.user_header)\n        line += ' --exclude-op '.join([''] + args.exclude_op)\n        cw.p(f'/* YNL-ARG{line} */')\n    cw.nl()\n\n    if args.mode == 'uapi':\n        render_uapi(parsed, cw)\n        return\n\n    hdr_prot = f\"_LINUX_{parsed.name.upper()}_GEN_H\"\n    if args.header:\n        cw.p('#ifndef ' + hdr_prot)\n        cw.p('#define ' + hdr_prot)\n        cw.nl()\n\n    if args.mode == 'kernel':\n        cw.p('#include <net/netlink.h>')\n        cw.p('#include <net/genetlink.h>')\n        cw.nl()\n        if not args.header:\n            if args.out_file:\n                cw.p(f'#include \"{os.path.basename(args.out_file[:-2])}.h\"')\n            cw.nl()\n        headers = ['uapi/' + parsed.uapi_header]\n    else:\n        cw.p('#include <stdlib.h>')\n        cw.p('#include <string.h>')\n        if args.header:\n            cw.p('#include <linux/types.h>')\n        else:\n            cw.p(f'#include \"{parsed.name}-user.h\"')\n            cw.p('#include \"ynl.h\"')\n        headers = [parsed.uapi_header]\n    for definition in parsed['definitions']:\n        if 'header' in definition:\n            headers.append(definition['header'])\n    for one in headers:\n        cw.p(f\"#include <{one}>\")\n    cw.nl()\n\n    if args.mode == \"user\":\n        if not args.header:\n            cw.p(\"#include <libmnl/libmnl.h>\")\n            cw.p(\"#include <linux/genetlink.h>\")\n            cw.nl()\n            for one in args.user_header:\n                cw.p(f'#include \"{one}\"')\n        else:\n            cw.p('struct ynl_sock;')\n            cw.nl()\n            render_user_family(parsed, cw, True)\n        cw.nl()\n\n    if args.mode == \"kernel\":\n        if args.header:\n            for _, struct in sorted(parsed.pure_nested_structs.items()):\n                if struct.request:\n                    cw.p('/* Common nested types */')\n                    break\n            for attr_set, struct in sorted(parsed.pure_nested_structs.items()):\n                if struct.request:\n                    print_req_policy_fwd(cw, struct)\n            cw.nl()\n\n            if parsed.kernel_policy == 'global':\n                cw.p(f\"/* Global operation policy for {parsed.name} */\")\n\n                struct = Struct(parsed, parsed.global_policy_set, type_list=parsed.global_policy)\n                print_req_policy_fwd(cw, struct)\n                cw.nl()\n\n            if parsed.kernel_policy in {'per-op', 'split'}:\n                for op_name, op in parsed.ops.items():\n                    if 'do' in op and 'event' not in op:\n                        ri = RenderInfo(cw, parsed, args.mode, op, \"do\")\n                        print_req_policy_fwd(cw, ri.struct['request'], ri=ri)\n                        cw.nl()\n\n            print_kernel_op_table_hdr(parsed, cw)\n            print_kernel_mcgrp_hdr(parsed, cw)\n            print_kernel_family_struct_hdr(parsed, cw)\n        else:\n            for _, struct in sorted(parsed.pure_nested_structs.items()):\n                if struct.request:\n                    cw.p('/* Common nested types */')\n                    break\n            for attr_set, struct in sorted(parsed.pure_nested_structs.items()):\n                if struct.request:\n                    print_req_policy(cw, struct)\n            cw.nl()\n\n            if parsed.kernel_policy == 'global':\n                cw.p(f\"/* Global operation policy for {parsed.name} */\")\n\n                struct = Struct(parsed, parsed.global_policy_set, type_list=parsed.global_policy)\n                print_req_policy(cw, struct)\n                cw.nl()\n\n            for op_name, op in parsed.ops.items():\n                if parsed.kernel_policy in {'per-op', 'split'}:\n                    for op_mode in ['do', 'dump']:\n                        if op_mode in op and 'request' in op[op_mode]:\n                            cw.p(f\"/* {op.enum_name} - {op_mode} */\")\n                            ri = RenderInfo(cw, parsed, args.mode, op, op_mode)\n                            print_req_policy(cw, ri.struct['request'], ri=ri)\n                            cw.nl()\n\n            print_kernel_op_table(parsed, cw)\n            print_kernel_mcgrp_src(parsed, cw)\n            print_kernel_family_struct_src(parsed, cw)\n\n    if args.mode == \"user\":\n        if args.header:\n            cw.p('/* Enums */')\n            put_op_name_fwd(parsed, cw)\n\n            for name, const in parsed.consts.items():\n                if isinstance(const, EnumSet):\n                    put_enum_to_str_fwd(parsed, cw, const)\n            cw.nl()\n\n            cw.p('/* Common nested types */')\n            for attr_set, struct in parsed.pure_nested_structs.items():\n                ri = RenderInfo(cw, parsed, args.mode, \"\", \"\", attr_set)\n                print_type_full(ri, struct)\n\n            for op_name, op in parsed.ops.items():\n                cw.p(f\"/* ============== {op.enum_name} ============== */\")\n\n                if 'do' in op and 'event' not in op:\n                    cw.p(f\"/* {op.enum_name} - do */\")\n                    ri = RenderInfo(cw, parsed, args.mode, op, \"do\")\n                    print_req_type(ri)\n                    print_req_type_helpers(ri)\n                    cw.nl()\n                    print_rsp_type(ri)\n                    print_rsp_type_helpers(ri)\n                    cw.nl()\n                    print_req_prototype(ri)\n                    cw.nl()\n\n                if 'dump' in op:\n                    cw.p(f\"/* {op.enum_name} - dump */\")\n                    ri = RenderInfo(cw, parsed, args.mode, op, 'dump')\n                    if 'request' in op['dump']:\n                        print_req_type(ri)\n                        print_req_type_helpers(ri)\n                    if not ri.type_consistent:\n                        print_rsp_type(ri)\n                    print_wrapped_type(ri)\n                    print_dump_prototype(ri)\n                    cw.nl()\n\n                if op.has_ntf:\n                    cw.p(f\"/* {op.enum_name} - notify */\")\n                    ri = RenderInfo(cw, parsed, args.mode, op, 'notify')\n                    if not ri.type_consistent:\n                        raise Exception(f'Only notifications with consistent types supported ({op.name})')\n                    print_wrapped_type(ri)\n\n            for op_name, op in parsed.ntfs.items():\n                if 'event' in op:\n                    ri = RenderInfo(cw, parsed, args.mode, op, 'event')\n                    cw.p(f\"/* {op.enum_name} - event */\")\n                    print_rsp_type(ri)\n                    cw.nl()\n                    print_wrapped_type(ri)\n            cw.nl()\n        else:\n            cw.p('/* Enums */')\n            put_op_name(parsed, cw)\n\n            for name, const in parsed.consts.items():\n                if isinstance(const, EnumSet):\n                    put_enum_to_str(parsed, cw, const)\n            cw.nl()\n\n            cw.p('/* Policies */')\n            for name in parsed.pure_nested_structs:\n                struct = Struct(parsed, name)\n                put_typol(cw, struct)\n            for name in parsed.root_sets:\n                struct = Struct(parsed, name)\n                put_typol(cw, struct)\n\n            cw.p('/* Common nested types */')\n            for attr_set, struct in parsed.pure_nested_structs.items():\n                ri = RenderInfo(cw, parsed, args.mode, \"\", \"\", attr_set)\n\n                free_rsp_nested(ri, struct)\n                if struct.request:\n                    put_req_nested(ri, struct)\n                if struct.reply:\n                    parse_rsp_nested(ri, struct)\n\n            for op_name, op in parsed.ops.items():\n                cw.p(f\"/* ============== {op.enum_name} ============== */\")\n                if 'do' in op and 'event' not in op:\n                    cw.p(f\"/* {op.enum_name} - do */\")\n                    ri = RenderInfo(cw, parsed, args.mode, op, \"do\")\n                    print_req_free(ri)\n                    print_rsp_free(ri)\n                    parse_rsp_msg(ri)\n                    print_req(ri)\n                    cw.nl()\n\n                if 'dump' in op:\n                    cw.p(f\"/* {op.enum_name} - dump */\")\n                    ri = RenderInfo(cw, parsed, args.mode, op, \"dump\")\n                    if not ri.type_consistent:\n                        parse_rsp_msg(ri, deref=True)\n                    print_dump_type_free(ri)\n                    print_dump(ri)\n                    cw.nl()\n\n                if op.has_ntf:\n                    cw.p(f\"/* {op.enum_name} - notify */\")\n                    ri = RenderInfo(cw, parsed, args.mode, op, 'notify')\n                    if not ri.type_consistent:\n                        raise Exception(f'Only notifications with consistent types supported ({op.name})')\n                    print_ntf_type_free(ri)\n\n            for op_name, op in parsed.ntfs.items():\n                if 'event' in op:\n                    cw.p(f\"/* {op.enum_name} - event */\")\n\n                    ri = RenderInfo(cw, parsed, args.mode, op, \"do\")\n                    parse_rsp_msg(ri)\n\n                    ri = RenderInfo(cw, parsed, args.mode, op, \"event\")\n                    print_ntf_type_free(ri)\n            cw.nl()\n            render_user_family(parsed, cw, False)\n\n    if args.header:\n        cw.p(f'#endif /* {hdr_prot} */')\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}