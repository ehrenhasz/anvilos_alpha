{
  "module_name": "thermometer.c",
  "hash_id": "3807ac8538f0bd49bf1c8ef1323515cd03a40cf69fd9bd95bfa3beed9211d984",
  "original_prompt": "Ingested from linux-6.6.14/tools/thermal/thermometer/thermometer.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <dirent.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <regex.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/signalfd.h>\n#include <sys/timerfd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include <linux/thermal.h>\n\n#include <libconfig.h>\n#include \"thermal-tools.h\"\n\n#define CLASS_THERMAL \"/sys/class/thermal\"\n\nenum {\n\tTHERMOMETER_SUCCESS = 0,\n\tTHERMOMETER_OPTION_ERROR,\n\tTHERMOMETER_LOG_ERROR,\n\tTHERMOMETER_CONFIG_ERROR,\n\tTHERMOMETER_TIME_ERROR,\n\tTHERMOMETER_INIT_ERROR,\n\tTHERMOMETER_RUNTIME_ERROR\n};\n\nstruct options {\n\tint loglvl;\n\tint logopt;\n\tint overwrite;\n\tint duration;\n\tconst char *config;\n\tchar postfix[PATH_MAX];\n\tchar output[PATH_MAX];\n};\n\nstruct tz_regex {\n\tregex_t regex;\n\tint polling;\n};\n\nstruct configuration {\n\tstruct tz_regex *tz_regex;\n\tint nr_tz_regex;\n\n};\n\nstruct tz {\n\tFILE *file_out;\n\tint fd_temp;\n\tint fd_timer;\n\tint polling;\n\tconst char *name;\n};\n\nstruct thermometer {\n\tstruct tz *tz;\n\tint nr_tz;\n};\n\nstatic struct tz_regex *configuration_tz_match(const char *expr,\n\t\t\t\t\t       struct configuration *config)\n{\n\tint i;\n\n\tfor (i = 0; i < config->nr_tz_regex; i++) {\n\n\t\tif (!regexec(&config->tz_regex[i].regex, expr, 0, NULL, 0))\n\t\t\treturn &config->tz_regex[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int configuration_default_init(struct configuration *config)\n{\n\tconfig->tz_regex = realloc(config->tz_regex, sizeof(*config->tz_regex) *\n\t\t\t\t   (config->nr_tz_regex + 1));\n\n\tif (regcomp(&config->tz_regex[config->nr_tz_regex].regex, \".*\",\n\t\t    REG_NOSUB | REG_EXTENDED)) {\n\t\tERROR(\"Invalid regular expression\\n\");\n\t\treturn -1;\n\t}\n\n\tconfig->tz_regex[config->nr_tz_regex].polling = 250;\n\tconfig->nr_tz_regex = 1;\n\n\treturn 0;\n}\n\nstatic int configuration_init(const char *path, struct configuration *config)\n{\n\tconfig_t cfg;\n\n\tconfig_setting_t *tz;\n\tint i, length;\n\n\tif (path && access(path, F_OK)) {\n\t\tERROR(\"'%s' is not accessible\\n\", path);\n\t\treturn -1;\n\t}\n\n\tif (!path && !config->nr_tz_regex) {\n\t\tINFO(\"No thermal zones configured, using wildcard for all of them\\n\");\n\t\treturn configuration_default_init(config);\n\t}\n\n\tconfig_init(&cfg);\n\n\tif (!config_read_file(&cfg, path)) {\n\t\tERROR(\"Failed to parse %s:%d - %s\\n\", config_error_file(&cfg),\n\t\t      config_error_line(&cfg), config_error_text(&cfg));\n\n\t\treturn -1;\n\t}\n\n\ttz = config_lookup(&cfg, \"thermal-zones\");\n\tif (!tz) {\n\t\tERROR(\"No thermal zone configured to be monitored\\n\");\n\t\treturn -1;\n\t}\n\n\tlength = config_setting_length(tz);\n\n\tINFO(\"Found %d thermal zone(s) regular expression\\n\", length);\n\n\tfor (i = 0; i < length; i++) {\n\n\t\tconfig_setting_t *node;\n\t\tconst char *name;\n\t\tint polling;\n\n\t\tnode = config_setting_get_elem(tz, i);\n\t\tif (!node) {\n\t\t\tERROR(\"Missing node name '%d'\\n\", i);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!config_setting_lookup_string(node, \"name\", &name)) {\n\t\t\tERROR(\"Thermal zone name not found\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!config_setting_lookup_int(node, \"polling\", &polling)) {\n\t\t\tERROR(\"Polling value not found\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tconfig->tz_regex = realloc(config->tz_regex, sizeof(*config->tz_regex) *\n\t\t\t\t\t(config->nr_tz_regex + 1));\n\n\t\tif (regcomp(&config->tz_regex[config->nr_tz_regex].regex, name,\n\t\t\t    REG_NOSUB | REG_EXTENDED)) {\n\t\t\tERROR(\"Invalid regular expression '%s'\\n\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconfig->tz_regex[config->nr_tz_regex].polling = polling;\n\t\tconfig->nr_tz_regex++;\n\n\t\tINFO(\"Thermal zone regular expression '%s' with polling %d\\n\",\n\t\t     name, polling);\n\t}\n\n\treturn 0;\n}\n\nstatic void usage(const char *cmd)\n{\n\tprintf(\"%s Version: %s\\n\", cmd, VERSION);\n\tprintf(\"Usage: %s [options]\\n\", cmd);\n\tprintf(\"\\t-h, --help\\t\\tthis help\\n\");\n\tprintf(\"\\t-o, --output <dir>\\toutput directory for temperature capture\\n\");\n\tprintf(\"\\t-c, --config <file>\\tconfiguration file\\n\");\n\tprintf(\"\\t-d, --duration <seconds>\\tcapture duration\\n\");\n\tprintf(\"\\t-l, --loglevel <level>\\tlog level: \");\n\tprintf(\"DEBUG, INFO, NOTICE, WARN, ERROR\\n\");\n\tprintf(\"\\t-p, --postfix <string>\\tpostfix to be happened at the end of the files\\n\");\n\tprintf(\"\\t-s, --syslog\\t\\toutput to syslog\\n\");\n\tprintf(\"\\t-w, --overwrite\\t\\toverwrite the temperature capture files if they exist\\n\");\n\tprintf(\"\\n\");\n\texit(0);\n}\n\nstatic int options_init(int argc, char *argv[], struct options *options)\n{\n\tint opt;\n\ttime_t now = time(NULL);\n\n\tstruct option long_options[] = {\n\t\t{ \"help\",\tno_argument, NULL, 'h' },\n\t\t{ \"config\",\trequired_argument, NULL, 'c' },\n\t\t{ \"duration\",\trequired_argument, NULL, 'd' },\n\t\t{ \"loglevel\",\trequired_argument, NULL, 'l' },\n\t\t{ \"postfix\",\trequired_argument, NULL, 'p' },\n\t\t{ \"output\",\trequired_argument, NULL, 'o' },\n\t\t{ \"syslog\",\trequired_argument, NULL, 's' },\n\t\t{ \"overwrite\",\tno_argument, NULL, 'w' },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\n\tstrftime(options->postfix, sizeof(options->postfix),\n\t\t \"-%Y-%m-%d_%H:%M:%S\", gmtime(&now));\n\n\twhile (1) {\n\n\t\tint optindex = 0;\n\n\t\topt = getopt_long(argc, argv, \"ho:c:d:l:p:sw\", long_options, &optindex);\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase 'c':\n\t\t\toptions->config = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\toptions->duration = atoi(optarg) * 1000;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\toptions->loglvl = log_str2level(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(basename(argv[0]));\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tstrcpy(options->postfix, optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tstrcpy(options->output, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\toptions->logopt = TO_SYSLOG;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\toptions->overwrite = 1;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tERROR(\"Usage: %s --help\\n\", argv[0]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int thermometer_add_tz(const char *path, const char *name, int polling,\n\t\t\t      struct thermometer *thermometer)\n{\n\tint fd;\n\tchar tz_path[PATH_MAX];\n\n\tsprintf(tz_path, CLASS_THERMAL\"/%s/temp\", path);\n\n\tfd = open(tz_path, O_RDONLY);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to open '%s': %m\\n\", tz_path);\n\t\treturn -1;\n\t}\n\n\tthermometer->tz = realloc(thermometer->tz,\n\t\t\t\t  sizeof(*thermometer->tz) * (thermometer->nr_tz + 1));\n\tif (!thermometer->tz) {\n\t\tERROR(\"Failed to allocate thermometer->tz\\n\");\n\t\treturn -1;\n\t}\n\n\tthermometer->tz[thermometer->nr_tz].fd_temp = fd;\n\tthermometer->tz[thermometer->nr_tz].name = strdup(name);\n\tthermometer->tz[thermometer->nr_tz].polling = polling;\n\tthermometer->nr_tz++;\n\n\tINFO(\"Added thermal zone '%s->%s (polling:%d)'\\n\", path, name, polling);\n\n\treturn 0;\n}\n\nstatic int thermometer_init(struct configuration *config,\n\t\t\t    struct thermometer *thermometer)\n{\n\tDIR *dir;\n\tstruct dirent *dirent;\n\tstruct tz_regex *tz_regex;\n\tconst char *tz_dirname = \"thermal_zone\";\n\n\tif (mainloop_init()) {\n\t\tERROR(\"Failed to start mainloop\\n\");\n\t\treturn -1;\n\t}\n\n\tdir = opendir(CLASS_THERMAL);\n\tif (!dir) {\n\t\tERROR(\"failed to open '%s'\\n\", CLASS_THERMAL);\n\t\treturn -1;\n\t}\n\n\twhile ((dirent = readdir(dir))) {\n\t\tchar tz_type[THERMAL_NAME_LENGTH];\n\t\tchar tz_path[PATH_MAX];\n\t\tFILE *tz_file;\n\n\t\tif (strncmp(dirent->d_name, tz_dirname, strlen(tz_dirname)))\n\t\t\tcontinue;\n\n\t\tsprintf(tz_path, CLASS_THERMAL\"/%s/type\", dirent->d_name);\n\n\t\ttz_file = fopen(tz_path, \"r\");\n\t\tif (!tz_file) {\n\t\t\tERROR(\"Failed to open '%s': %m\", tz_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfscanf(tz_file, \"%s\", tz_type);\n\n\t\tfclose(tz_file);\n\n\t\ttz_regex = configuration_tz_match(tz_type, config);\n\t\tif (!tz_regex)\n\t\t\tcontinue;\n\n\t\tif (thermometer_add_tz(dirent->d_name, tz_type,\n\t\t\t\t       tz_regex->polling, thermometer))\n\t\t\tcontinue;\n\t}\n\n\tclosedir(dir);\n\n\treturn 0;\n}\n\nstatic int timer_temperature_callback(int fd, void *arg)\n{\n\tstruct tz *tz = arg;\n\tchar buf[16] = { 0 };\n\n\tpread(tz->fd_temp, buf, sizeof(buf), 0);\n\n\tfprintf(tz->file_out, \"%ld %s\", getuptimeofday_ms(), buf);\n\n\tread(fd, buf, sizeof(buf));\n\n\treturn 0;\n}\n\nstatic int thermometer_start(struct thermometer *thermometer,\n\t\t\t     struct options *options)\n{\n\tstruct itimerspec timer_it = { 0 };\n\tchar *path;\n\tFILE *f;\n\tint i;\n\n\tINFO(\"Capturing %d thermal zone(s) temperature...\\n\", thermometer->nr_tz);\n\n\tif (access(options->output, F_OK) && mkdir(options->output, 0700)) {\n\t\tERROR(\"Failed to create directory '%s'\\n\", options->output);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < thermometer->nr_tz; i++) {\n\n\t\tasprintf(&path, \"%s/%s%s\", options->output,\n\t\t\t thermometer->tz[i].name, options->postfix);\n\n\t\tif (!options->overwrite && !access(path, F_OK)) {\n\t\t\tERROR(\"'%s' already exists\\n\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tf = fopen(path, \"w\");\n\t\tif (!f) {\n\t\t\tERROR(\"Failed to create '%s':%m\\n\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tfprintf(f, \"timestamp(ms) %s(\u00b0mC)\\n\", thermometer->tz[i].name);\n\n\t\tthermometer->tz[i].file_out = f;\n\n\t\tDEBUG(\"Created '%s' file for thermal zone '%s'\\n\", path, thermometer->tz[i].name);\n\n\t\t \n\t\tthermometer->tz[i].fd_timer = timerfd_create(CLOCK_MONOTONIC, 0);\n\t\tif (thermometer->tz[i].fd_timer < 0) {\n\t\t\tERROR(\"Failed to create timer for '%s': %m\\n\",\n\t\t\t      thermometer->tz[i].name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"Watching '%s' every %d ms\\n\",\n\t\t      thermometer->tz[i].name, thermometer->tz[i].polling);\n\n\t\ttimer_it.it_interval = timer_it.it_value =\n\t\t\tmsec_to_timespec(thermometer->tz[i].polling);\n\n\t\tif (timerfd_settime(thermometer->tz[i].fd_timer, 0,\n\t\t\t\t    &timer_it, NULL) < 0)\n\t\t\treturn -1;\n\n\t\tif (mainloop_add(thermometer->tz[i].fd_timer,\n\t\t\t\t timer_temperature_callback,\n\t\t\t\t &thermometer->tz[i]))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int thermometer_execute(int argc, char *argv[], char *const envp[], pid_t *pid)\n{\n\tif (!argc)\n\t\treturn 0;\n\n\t*pid = fork();\n\tif (*pid < 0) {\n\t\tERROR(\"Failed to fork process: %m\");\n\t\treturn -1;\n\t}\n\n\tif (!(*pid)) {\n\t\texecvpe(argv[0], argv, envp);\n\t\texit(1);\n\t}\n\n\treturn 0;\n}\n\nstatic int kill_process(__maybe_unused int fd, void *arg)\n{\n\tpid_t pid = *(pid_t *)arg;\n\n\tif (kill(pid, SIGTERM))\n\t\tERROR(\"Failed to send SIGTERM signal to '%d': %p\\n\", pid);\n\telse if (waitpid(pid, NULL, 0))\n\t\tERROR(\"Failed to wait pid '%d': %p\\n\", pid);\n\n\tmainloop_exit();\n\n\treturn 0;\n}\n\nstatic int exit_mainloop(__maybe_unused int fd, __maybe_unused void *arg)\n{\n\tmainloop_exit();\n\treturn 0;\n}\n\nstatic int thermometer_wait(struct options *options, pid_t pid)\n{\n\tint fd;\n\tsigset_t mask;\n\n\t \n\tif (options->duration) {\n\t\tstruct itimerspec timer_it = { 0 };\n\n\t\ttimer_it.it_value = msec_to_timespec(options->duration);\n\n\t\tfd = timerfd_create(CLOCK_MONOTONIC, 0);\n\t\tif (fd < 0) {\n\t\t\tERROR(\"Failed to create duration timer: %m\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (timerfd_settime(fd, 0, &timer_it, NULL)) {\n\t\t\tERROR(\"Failed to set timer time: %m\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (mainloop_add(fd, pid < 0 ? exit_mainloop : kill_process, &pid)) {\n\t\t\tERROR(\"Failed to set timer exit mainloop callback\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGINT);\n\tsigaddset(&mask, SIGQUIT);\n\tsigaddset(&mask, SIGCHLD);\n\n\tif (sigprocmask(SIG_BLOCK, &mask, NULL)) {\n\t\tERROR(\"Failed to set sigprocmask: %m\\n\");\n\t\treturn -1;\n\t}\n\n\tfd = signalfd(-1, &mask, 0);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to set the signalfd: %m\\n\");\n\t\treturn -1;\n\t}\n\n\tif (mainloop_add(fd, exit_mainloop, NULL)) {\n\t\tERROR(\"Failed to set timer exit mainloop callback\\n\");\n\t\treturn -1;\n\t}\n\n\treturn mainloop(-1);\n}\n\nstatic int thermometer_stop(struct thermometer *thermometer)\n{\n\tint i;\n\n\tINFO(\"Closing/flushing output files\\n\");\n\n\tfor (i = 0; i < thermometer->nr_tz; i++)\n\t\tfclose(thermometer->tz[i].file_out);\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[], char *const envp[])\n{\n\tstruct options options = {\n\t\t.loglvl = LOG_DEBUG,\n\t\t.logopt = TO_STDOUT,\n\t\t.output = \".\",\n\t};\n\tstruct configuration config = { 0 };\n\tstruct thermometer thermometer = { 0 };\n\n\tpid_t pid = -1;\n\n\tif (options_init(argc, argv, &options))\n\t\treturn THERMOMETER_OPTION_ERROR;\n\n\tif (log_init(options.loglvl, argv[0], options.logopt))\n\t\treturn THERMOMETER_LOG_ERROR;\n\n\tif (configuration_init(options.config, &config))\n\t\treturn THERMOMETER_CONFIG_ERROR;\n\n\tif (uptimeofday_init())\n\t\treturn THERMOMETER_TIME_ERROR;\n\n\tif (thermometer_init(&config, &thermometer))\n\t\treturn THERMOMETER_INIT_ERROR;\n\n\tif (thermometer_start(&thermometer, &options))\n\t\treturn THERMOMETER_RUNTIME_ERROR;\n\n\tif (thermometer_execute(argc - optind, &argv[optind], envp, &pid))\n\t\treturn THERMOMETER_RUNTIME_ERROR;\n\n\tif (thermometer_wait(&options, pid))\n\t\treturn THERMOMETER_RUNTIME_ERROR;\n\n\tif (thermometer_stop(&thermometer))\n\t\treturn THERMOMETER_RUNTIME_ERROR;\n\n\treturn THERMOMETER_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}