{
  "module_name": "tmon.c",
  "hash_id": "537edff4479a6c6e7c80e72f415cc7fdc672092d9874f056199c4b5a27ddbd94",
  "original_prompt": "Ingested from linux-6.6.14/tools/thermal/tmon/tmon.c",
  "human_readable_source": "\n \n\n#include <getopt.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <ncurses.h>\n#include <ctype.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <sys/time.h>\n#include <pthread.h>\n#include <math.h>\n#include <stdarg.h>\n#include <syslog.h>\n\n#include \"tmon.h\"\n\nunsigned long ticktime = 1;  \nunsigned long no_control = 1;  \ndouble time_elapsed = 0.0;\nunsigned long target_temp_user = 65;  \nint dialogue_on;\nint tmon_exit;\nstatic short\tdaemon_mode;\nstatic int logging;  \nstatic int debug_on;\nFILE *tmon_log;\n \nchar ctrl_cdev[CDEV_NAME_SIZE] = \"None\";\nint target_thermal_zone;  \nstatic void\tstart_daemon_mode(void);\n\npthread_t event_tid;\npthread_mutex_t input_lock;\nvoid usage(void)\n{\n\tprintf(\"Usage: tmon [OPTION...]\\n\");\n\tprintf(\"  -c, --control         cooling device in control\\n\");\n\tprintf(\"  -d, --daemon          run as daemon, no TUI\\n\");\n\tprintf(\"  -g, --debug           debug message in syslog\\n\");\n\tprintf(\"  -h, --help            show this help message\\n\");\n\tprintf(\"  -l, --log             log data to /var/tmp/tmon.log\\n\");\n\tprintf(\"  -t, --time-interval   sampling time interval, > 1 sec.\\n\");\n\tprintf(\"  -T, --target-temp     initial target temperature\\n\");\n\tprintf(\"  -v, --version         show version\\n\");\n\tprintf(\"  -z, --zone            target thermal zone id\\n\");\n\n\texit(0);\n}\n\nvoid version(void)\n{\n\tprintf(\"TMON version %s\\n\", VERSION);\n\texit(EXIT_SUCCESS);\n}\n\nstatic void tmon_cleanup(void)\n{\n\tsyslog(LOG_INFO, \"TMON exit cleanup\\n\");\n\tfflush(stdout);\n\trefresh();\n\tif (tmon_log)\n\t\tfclose(tmon_log);\n\tif (event_tid) {\n\t\tpthread_mutex_lock(&input_lock);\n\t\tpthread_cancel(event_tid);\n\t\tpthread_mutex_unlock(&input_lock);\n\t\tpthread_mutex_destroy(&input_lock);\n\t}\n\tcloselog();\n\t \n\tset_ctrl_state(0);\n\n\tkeypad(stdscr, FALSE);\n\techo();\n\tnocbreak();\n\tclose_windows();\n\tendwin();\n\tfree_thermal_data();\n\n\texit(1);\n}\n\nstatic void tmon_sig_handler(int sig)\n{\n\tsyslog(LOG_INFO, \"TMON caught signal %d\\n\", sig);\n\trefresh();\n\tswitch (sig) {\n\tcase SIGTERM:\n\t\tprintf(\"sigterm, exit and clean up\\n\");\n\t\tfflush(stdout);\n\t\tbreak;\n\tcase SIGKILL:\n\t\tprintf(\"sigkill, exit and clean up\\n\");\n\t\tfflush(stdout);\n\t\tbreak;\n\tcase SIGINT:\n\t\tprintf(\"ctrl-c, exit and clean up\\n\");\n\t\tfflush(stdout);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\ttmon_exit = true;\n}\n\nstatic void start_syslog(void)\n{\n\tif (debug_on)\n\t\tsetlogmask(LOG_UPTO(LOG_DEBUG));\n\telse\n\t\tsetlogmask(LOG_UPTO(LOG_ERR));\n\topenlog(\"tmon.log\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL0);\n\tsyslog(LOG_NOTICE, \"TMON started by User %d\", getuid());\n}\n\nstatic void prepare_logging(void)\n{\n\tint i;\n\tstruct stat logstat;\n\n\tif (!logging)\n\t\treturn;\n\t \n\ttmon_log = fopen(TMON_LOG_FILE, \"w+\");\n\tif (!tmon_log) {\n\t\tsyslog(LOG_ERR, \"failed to open log file %s\\n\", TMON_LOG_FILE);\n\t\treturn;\n\t}\n\n\tif (lstat(TMON_LOG_FILE, &logstat) < 0) {\n\t\tsyslog(LOG_ERR, \"Unable to stat log file %s\\n\", TMON_LOG_FILE);\n\t\tfclose(tmon_log);\n\t\ttmon_log = NULL;\n\t\treturn;\n\t}\n\n\t \n\tif (S_ISLNK(logstat.st_mode)) {\n\t\tsyslog(LOG_ERR, \"Log file is a symlink.  Will not log\\n\");\n\t\tfclose(tmon_log);\n\t\ttmon_log = NULL;\n\t\treturn;\n\t}\n\n\tif (logstat.st_uid != getuid()) {\n\t\tsyslog(LOG_ERR, \"We don't own the log file.  Not logging\\n\");\n\t\tfclose(tmon_log);\n\t\ttmon_log = NULL;\n\t\treturn;\n\t}\n\n\tfprintf(tmon_log, \"#----------- THERMAL SYSTEM CONFIG -------------\\n\");\n\tfor (i = 0; i < ptdata.nr_tz_sensor; i++) {\n\t\tchar binding_str[33];  \n\t\tint j;\n\n\t\tmemset(binding_str, 0, sizeof(binding_str));\n\t\tfor (j = 0; j < 32; j++)\n\t\t\tbinding_str[j] = (ptdata.tzi[i].cdev_binding & (1 << j)) ?\n\t\t\t\t'1' : '0';\n\n\t\tfprintf(tmon_log, \"#thermal zone %s%02d cdevs binding: %32s\\n\",\n\t\t\tptdata.tzi[i].type,\n\t\t\tptdata.tzi[i].instance,\n\t\t\tbinding_str);\n\t\tfor (j = 0; j <\tptdata.tzi[i].nr_trip_pts; j++) {\n\t\t\tfprintf(tmon_log, \"#\\tTP%02d type:%s, temp:%lu\\n\", j,\n\t\t\t\ttrip_type_name[ptdata.tzi[i].tp[j].type],\n\t\t\t\tptdata.tzi[i].tp[j].temp);\n\t\t}\n\t}\n\n\tfor (i = 0; i <\tptdata.nr_cooling_dev; i++)\n\t\tfprintf(tmon_log, \"#cooling devices%02d: %s\\n\",\n\t\t\ti, ptdata.cdi[i].type);\n\n\tfprintf(tmon_log, \"#---------- THERMAL DATA LOG STARTED -----------\\n\");\n\tfprintf(tmon_log, \"Samples TargetTemp \");\n\tfor (i = 0; i < ptdata.nr_tz_sensor; i++) {\n\t\tfprintf(tmon_log, \"%s%d    \", ptdata.tzi[i].type,\n\t\t\tptdata.tzi[i].instance);\n\t}\n\tfor (i = 0; i <\tptdata.nr_cooling_dev; i++)\n\t\tfprintf(tmon_log, \"%s%d \", ptdata.cdi[i].type,\n\t\t\tptdata.cdi[i].instance);\n\n\tfprintf(tmon_log, \"\\n\");\n}\n\nstatic struct option opts[] = {\n\t{ \"control\", 1, NULL, 'c' },\n\t{ \"daemon\", 0, NULL, 'd' },\n\t{ \"time-interval\", 1, NULL, 't' },\n\t{ \"target-temp\", 1, NULL, 'T' },\n\t{ \"log\", 0, NULL, 'l' },\n\t{ \"help\", 0, NULL, 'h' },\n\t{ \"version\", 0, NULL, 'v' },\n\t{ \"debug\", 0, NULL, 'g' },\n\t{ 0, 0, NULL, 0 }\n};\n\nint main(int argc, char **argv)\n{\n\tint err = 0;\n\tint id2 = 0, c;\n\tdouble yk = 0.0, temp;  \n\tint target_tz_index;\n\n\tif (geteuid() != 0) {\n\t\tprintf(\"TMON needs to be run as root\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\twhile ((c = getopt_long(argc, argv, \"c:dlht:T:vgz:\", opts, &id2)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tno_control = 0;\n\t\t\tstrncpy(ctrl_cdev, optarg, CDEV_NAME_SIZE);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tstart_daemon_mode();\n\t\t\tprintf(\"Run TMON in daemon mode\\n\");\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tticktime = strtod(optarg, NULL);\n\t\t\tif (ticktime < 1)\n\t\t\t\tticktime = 1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\ttemp = strtod(optarg, NULL);\n\t\t\tif (temp < 0) {\n\t\t\t\tfprintf(stderr, \"error: temperature must be positive\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\ttarget_temp_user = temp;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tprintf(\"Logging data to /var/tmp/tmon.log\\n\");\n\t\t\tlogging = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tversion();\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tdebug_on = 1;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\ttarget_thermal_zone = strtod(optarg, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pthread_mutex_init(&input_lock, NULL) != 0) {\n\t\tfprintf(stderr, \"\\n mutex init failed, exit\\n\");\n\t\treturn 1;\n\t}\n\tstart_syslog();\n\tif (signal(SIGINT, tmon_sig_handler) == SIG_ERR)\n\t\tsyslog(LOG_DEBUG, \"Cannot handle SIGINT\\n\");\n\tif (signal(SIGTERM, tmon_sig_handler) == SIG_ERR)\n\t\tsyslog(LOG_DEBUG, \"Cannot handle SIGTERM\\n\");\n\n\tif (probe_thermal_sysfs()) {\n\t\tpthread_mutex_destroy(&input_lock);\n\t\tcloselog();\n\t\treturn -1;\n\t}\n\tinitialize_curses();\n\tsetup_windows();\n\tsignal(SIGWINCH, resize_handler);\n\tshow_title_bar();\n\tshow_sensors_w();\n\tshow_cooling_device();\n\tupdate_thermal_data();\n\tshow_data_w();\n\tprepare_logging();\n\tinit_thermal_controller();\n\n\tnodelay(stdscr, TRUE);\n\terr = pthread_create(&event_tid, NULL, &handle_tui_events, NULL);\n\tif (err != 0) {\n\t\tprintf(\"\\ncan't create thread :[%s]\", strerror(err));\n\t\ttmon_cleanup();\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\ttarget_tz_index = zone_instance_to_index(target_thermal_zone);\n\tif (target_tz_index < 0) {\n\t\ttarget_thermal_zone = ptdata.tzi[0].instance;\n\t\tsyslog(LOG_ERR, \"target zone is not found, default to %d\\n\",\n\t\t\ttarget_thermal_zone);\n\t}\n\twhile (1) {\n\t\tsleep(ticktime);\n\t\tshow_title_bar();\n\t\tshow_sensors_w();\n\t\tupdate_thermal_data();\n\t\tif (!dialogue_on) {\n\t\t\tshow_data_w();\n\t\t\tshow_cooling_device();\n\t\t}\n\t\ttime_elapsed += ticktime;\n\t\tcontroller_handler(trec[0].temp[target_tz_index] / 1000, &yk);\n\t\ttrec[0].pid_out_pct = yk;\n\t\tif (!dialogue_on)\n\t\t\tshow_control_w();\n\t\tif (tmon_exit)\n\t\t\tbreak;\n\t}\n\ttmon_cleanup();\n\treturn 0;\n}\n\nstatic void start_daemon_mode(void)\n{\n\tdaemon_mode = 1;\n\t \n\tpid_t\tsid, pid = fork();\n\n\tif (pid < 0)\n\t\texit(EXIT_FAILURE);\n\telse if (pid > 0)\n\t\t \n\t\texit(EXIT_SUCCESS);\n\n\t \n\tdisable_tui();\n\n\t \n\tumask(S_IWGRP | S_IWOTH);\n\n\t \n\tsid = setsid();\n\tif (sid < 0)\n\t\texit(EXIT_FAILURE);\n\n\t \n\tif ((chdir(\"/\")) < 0)\n\t\texit(EXIT_FAILURE);\n\n\tsleep(10);\n\n\tclose(STDIN_FILENO);\n\tclose(STDOUT_FILENO);\n\tclose(STDERR_FILENO);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}