{
  "module_name": "sysfs.c",
  "hash_id": "f43f7d135ac1dd0b3ae9fd00c363e2acc536060a02b7358895933d3cdfbe679a",
  "original_prompt": "Ingested from linux-6.6.14/tools/thermal/tmon/sysfs.c",
  "human_readable_source": "\n \n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <dirent.h>\n#include <libintl.h>\n#include <limits.h>\n#include <ctype.h>\n#include <time.h>\n#include <syslog.h>\n#include <sys/time.h>\n#include <errno.h>\n\n#include \"tmon.h\"\n\nstruct tmon_platform_data ptdata;\nconst char *trip_type_name[] = {\n\t\"critical\",\n\t\"hot\",\n\t\"passive\",\n\t\"active\",\n};\n\nint sysfs_set_ulong(char *path, char *filename, unsigned long val)\n{\n\tFILE *fd;\n\tint ret = -1;\n\tchar filepath[PATH_MAX + 2];  \n\n\tsnprintf(filepath, sizeof(filepath), \"%s/%s\", path, filename);\n\n\tfd = fopen(filepath, \"w\");\n\tif (!fd) {\n\t\tsyslog(LOG_ERR, \"Err: open %s: %s\\n\", __func__, filepath);\n\t\treturn ret;\n\t}\n\tret = fprintf(fd, \"%lu\", val);\n\tfclose(fd);\n\n\treturn 0;\n}\n\n \n#define NR_THERMAL_RECORDS 3\nstruct thermal_data_record trec[NR_THERMAL_RECORDS];\nint cur_thermal_record;  \n\nstatic int sysfs_get_ulong(char *path, char *filename, unsigned long *p_ulong)\n{\n\tFILE *fd;\n\tint ret = -1;\n\tchar filepath[PATH_MAX + 2];  \n\n\tsnprintf(filepath, sizeof(filepath), \"%s/%s\", path, filename);\n\n\tfd = fopen(filepath, \"r\");\n\tif (!fd) {\n\t\tsyslog(LOG_ERR, \"Err: open %s: %s\\n\", __func__, filepath);\n\t\treturn ret;\n\t}\n\tret = fscanf(fd, \"%lu\", p_ulong);\n\tfclose(fd);\n\n\treturn 0;\n}\n\nstatic int sysfs_get_string(char *path, char *filename, char *str)\n{\n\tFILE *fd;\n\tint ret = -1;\n\tchar filepath[PATH_MAX + 2];  \n\n\tsnprintf(filepath, sizeof(filepath), \"%s/%s\", path, filename);\n\n\tfd = fopen(filepath, \"r\");\n\tif (!fd) {\n\t\tsyslog(LOG_ERR, \"Err: open %s: %s\\n\", __func__, filepath);\n\t\treturn ret;\n\t}\n\tret = fscanf(fd, \"%256s\", str);\n\tfclose(fd);\n\n\treturn ret;\n}\n\n \nstatic int probe_cdev(struct cdev_info *cdi, char *path)\n{\n\tsysfs_get_string(path, \"type\", cdi->type);\n\tsysfs_get_ulong(path, \"max_state\",  &cdi->max_state);\n\tsysfs_get_ulong(path, \"cur_state\", &cdi->cur_state);\n\n\tsyslog(LOG_INFO, \"%s: %s: type %s, max %lu, curr %lu inst %d\\n\",\n\t\t__func__, path,\n\t\tcdi->type, cdi->max_state, cdi->cur_state, cdi->instance);\n\n\treturn 0;\n}\n\nstatic int str_to_trip_type(char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_THERMAL_TRIP_TYPE; i++) {\n\t\tif (!strcmp(name, trip_type_name[i]))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic int get_trip_point_data(char *tz_path, int tzid, int tpid)\n{\n\tchar filename[256];\n\tchar temp_str[256];\n\tint trip_type;\n\n\tif (tpid >= MAX_NR_TRIP)\n\t\treturn -EINVAL;\n\t \n\tsnprintf(filename, sizeof(filename), \"trip_point_%d_type\", tpid);\n\tsysfs_get_string(tz_path, filename, temp_str);\n\ttrip_type = str_to_trip_type(temp_str);\n\tif (trip_type < 0) {\n\t\tsyslog(LOG_ERR, \"%s:%s no matching type\\n\", __func__, temp_str);\n\t\treturn -ENOENT;\n\t}\n\tptdata.tzi[tzid].tp[tpid].type = trip_type;\n\tsyslog(LOG_INFO, \"%s:tz:%d tp:%d:type:%s type id %d\\n\", __func__, tzid,\n\t\ttpid, temp_str, trip_type);\n\n\t \n\n\treturn 0;\n}\n\n \nstatic int get_instance_id(char *name, int pos, int skip)\n{\n\tchar *ch;\n\tint i = 0;\n\n\tch = strtok(name, \"_\");\n\twhile (ch != NULL) {\n\t\t++i;\n\t\tsyslog(LOG_INFO, \"%s:%s:%s:%d\", __func__, name, ch, i);\n\t\tch = strtok(NULL, \"_\");\n\t\tif (pos == i)\n\t\t\treturn atol(ch + skip);\n\t}\n\n\treturn -1;\n}\n\n \nstatic int find_tzone_tp(char *tz_name, char *d_name, struct tz_info *tzi,\n\t\t\tint tz_id)\n{\n\tint tp_id;\n\tunsigned long temp_ulong;\n\n\tif (strstr(d_name, \"trip_point\") &&\n\t\tstrstr(d_name, \"temp\")) {\n\t\t \n\t\tsysfs_get_ulong(tz_name, d_name, &temp_ulong);\n\t\tif (temp_ulong < MAX_TEMP_KC) {\n\t\t\ttzi->nr_trip_pts++;\n\t\t\t \n\t\t\ttp_id = get_instance_id(d_name, 2, 0);\n\t\t\tsyslog(LOG_DEBUG, \"tzone %s trip %d temp %lu tpnode %s\",\n\t\t\t\ttz_name, tp_id, temp_ulong, d_name);\n\t\t\tif (tp_id < 0 || tp_id >= MAX_NR_TRIP) {\n\t\t\t\tsyslog(LOG_ERR, \"Failed to find TP inst %s\\n\",\n\t\t\t\t\td_name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tget_trip_point_data(tz_name, tz_id, tp_id);\n\t\t\ttzi->tp[tp_id].temp = temp_ulong;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int find_tzone_cdev(struct dirent *nl, char *tz_name,\n\t\t\tstruct tz_info *tzi, int tz_id, int cid)\n{\n\tunsigned long trip_instance = 0;\n\tchar cdev_name_linked[256];\n\tchar cdev_name[PATH_MAX];\n\tchar cdev_trip_name[PATH_MAX];\n\tint cdev_id;\n\n\tif (nl->d_type == DT_LNK) {\n\t\tsyslog(LOG_DEBUG, \"TZ%d: cdev: %s cid %d\\n\", tz_id, nl->d_name,\n\t\t\tcid);\n\t\ttzi->nr_cdev++;\n\t\tif (tzi->nr_cdev > ptdata.nr_cooling_dev) {\n\t\t\tsyslog(LOG_ERR, \"Err: Too many cdev? %d\\n\",\n\t\t\t\ttzi->nr_cdev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tsnprintf(cdev_name, sizeof(cdev_name) - 2, \"%s/%s\",\n\t\t\t tz_name, nl->d_name);\n\t\tmemset(cdev_name_linked, 0, sizeof(cdev_name_linked));\n\t\tif (readlink(cdev_name, cdev_name_linked,\n\t\t\t\tsizeof(cdev_name_linked) - 1) != -1) {\n\t\t\tcdev_id = get_instance_id(cdev_name_linked, 1,\n\t\t\t\t\t\tsizeof(\"device\") - 1);\n\t\t\tsyslog(LOG_DEBUG, \"cdev %s linked to %s : %d\\n\",\n\t\t\t\tcdev_name, cdev_name_linked, cdev_id);\n\t\t\ttzi->cdev_binding |= (1 << cdev_id);\n\n\t\t\t \n\t\t\tsnprintf(cdev_trip_name, sizeof(cdev_trip_name) - 1,\n\t\t\t\t\"%s%s\", nl->d_name, \"_trip_point\");\n\t\t\tsysfs_get_ulong(tz_name, cdev_trip_name,\n\t\t\t\t\t&trip_instance);\n\t\t\t \n\t\t\tif (trip_instance > MAX_NR_TRIP)\n\t\t\t\ttrip_instance = 0;\n\t\t\ttzi->trip_binding[cdev_id] |= 1 << trip_instance;\n\t\t\tsyslog(LOG_DEBUG, \"cdev %s -> trip:%lu: 0x%lx %d\\n\",\n\t\t\t\tcdev_name, trip_instance,\n\t\t\t\ttzi->trip_binding[cdev_id],\n\t\t\t\tcdev_id);\n\n\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\n\n\n \nstatic int scan_tzones(void)\n{\n\tDIR *dir;\n\tstruct dirent **namelist;\n\tchar tz_name[256];\n\tint i, j, n, k = 0;\n\n\tif (!ptdata.nr_tz_sensor)\n\t\treturn -1;\n\n\tfor (i = 0; i <= ptdata.max_tz_instance; i++) {\n\t\tmemset(tz_name, 0, sizeof(tz_name));\n\t\tsnprintf(tz_name, 256, \"%s/%s%d\", THERMAL_SYSFS, TZONE, i);\n\n\t\tdir = opendir(tz_name);\n\t\tif (!dir) {\n\t\t\tsyslog(LOG_INFO, \"Thermal zone %s skipped\\n\", tz_name);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tn = scandir(tz_name, &namelist, 0, alphasort);\n\t\tif (n < 0)\n\t\t\tsyslog(LOG_ERR, \"scandir failed in %s\",  tz_name);\n\t\telse {\n\t\t\tsysfs_get_string(tz_name, \"type\", ptdata.tzi[k].type);\n\t\t\tptdata.tzi[k].instance = i;\n\t\t\t \n\t\t\tj = 0;  \n\t\t\tptdata.tzi[k].nr_cdev = 0;\n\t\t\tptdata.tzi[k].nr_trip_pts = 0;\n\t\t\twhile (n--) {\n\t\t\t\tchar *temp_str;\n\n\t\t\t\tif (find_tzone_tp(tz_name, namelist[n]->d_name,\n\t\t\t\t\t\t\t&ptdata.tzi[k], k))\n\t\t\t\t\tbreak;\n\t\t\t\ttemp_str = strstr(namelist[n]->d_name, \"cdev\");\n\t\t\t\tif (!temp_str) {\n\t\t\t\t\tfree(namelist[n]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!find_tzone_cdev(namelist[n], tz_name,\n\t\t\t\t\t\t\t&ptdata.tzi[k], i, j))\n\t\t\t\t\tj++;  \n\t\t\t\tfree(namelist[n]);\n\t\t\t}\n\t\t\tfree(namelist);\n\t\t}\n\t\t \n\t\tclosedir(dir);\n\t\tsyslog(LOG_INFO, \"TZ %d has %d cdev\\n\",\ti,\n\t\t\tptdata.tzi[k].nr_cdev);\n\t\tk++;\n\t}\n\n\treturn 0;\n}\n\nstatic int scan_cdevs(void)\n{\n\tDIR *dir;\n\tstruct dirent **namelist;\n\tchar cdev_name[256];\n\tint i, n, k = 0;\n\n\tif (!ptdata.nr_cooling_dev) {\n\t\tfprintf(stderr, \"No cooling devices found\\n\");\n\t\treturn 0;\n\t}\n\tfor (i = 0; i <= ptdata.max_cdev_instance; i++) {\n\t\tmemset(cdev_name, 0, sizeof(cdev_name));\n\t\tsnprintf(cdev_name, 256, \"%s/%s%d\", THERMAL_SYSFS, CDEV, i);\n\n\t\tdir = opendir(cdev_name);\n\t\tif (!dir) {\n\t\t\tsyslog(LOG_INFO, \"Cooling dev %s skipped\\n\", cdev_name);\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tn = scandir(cdev_name, &namelist, 0, alphasort);\n\t\tif (n < 0)\n\t\t\tsyslog(LOG_ERR, \"scandir failed in %s\",  cdev_name);\n\t\telse {\n\t\t\tsysfs_get_string(cdev_name, \"type\", ptdata.cdi[k].type);\n\t\t\tptdata.cdi[k].instance = i;\n\t\t\tif (strstr(ptdata.cdi[k].type, ctrl_cdev)) {\n\t\t\t\tptdata.cdi[k].flag |= CDEV_FLAG_IN_CONTROL;\n\t\t\t\tsyslog(LOG_DEBUG, \"control cdev id %d\\n\", i);\n\t\t\t}\n\t\t\twhile (n--)\n\t\t\t\tfree(namelist[n]);\n\t\t\tfree(namelist);\n\t\t}\n\t\tclosedir(dir);\n\t\tk++;\n\t}\n\treturn 0;\n}\n\n\nint probe_thermal_sysfs(void)\n{\n\tDIR *dir;\n\tstruct dirent **namelist;\n\tint n;\n\n\tdir = opendir(THERMAL_SYSFS);\n\tif (!dir) {\n\t\tfprintf(stderr, \"\\nNo thermal sysfs, exit\\n\");\n\t\treturn -1;\n\t}\n\tn = scandir(THERMAL_SYSFS, &namelist, 0, alphasort);\n\tif (n < 0)\n\t\tsyslog(LOG_ERR, \"scandir failed in thermal sysfs\");\n\telse {\n\t\t \n\t\twhile (n--) {\n\t\t\tint inst;\n\n\t\t\tif (strstr(namelist[n]->d_name, CDEV)) {\n\t\t\t\tinst = get_instance_id(namelist[n]->d_name, 1,\n\t\t\t\t\t\tsizeof(\"device\") - 1);\n\t\t\t\t \n\t\t\t\tif (inst > ptdata.max_cdev_instance)\n\t\t\t\t\tptdata.max_cdev_instance = inst;\n\n\t\t\t\tsyslog(LOG_DEBUG, \"found cdev: %s %d %d\\n\",\n\t\t\t\t\tnamelist[n]->d_name,\n\t\t\t\t\tptdata.nr_cooling_dev,\n\t\t\t\t\tptdata.max_cdev_instance);\n\t\t\t\tptdata.nr_cooling_dev++;\n\t\t\t} else if (strstr(namelist[n]->d_name, TZONE)) {\n\t\t\t\tinst = get_instance_id(namelist[n]->d_name, 1,\n\t\t\t\t\t\tsizeof(\"zone\") - 1);\n\t\t\t\tif (inst > ptdata.max_tz_instance)\n\t\t\t\t\tptdata.max_tz_instance = inst;\n\n\t\t\t\tsyslog(LOG_DEBUG, \"found tzone: %s %d %d\\n\",\n\t\t\t\t\tnamelist[n]->d_name,\n\t\t\t\t\tptdata.nr_tz_sensor,\n\t\t\t\t\tptdata.max_tz_instance);\n\t\t\t\tptdata.nr_tz_sensor++;\n\t\t\t}\n\t\t\tfree(namelist[n]);\n\t\t}\n\t\tfree(namelist);\n\t}\n\tsyslog(LOG_INFO, \"found %d tzone(s), %d cdev(s), target zone %d\\n\",\n\t\tptdata.nr_tz_sensor, ptdata.nr_cooling_dev,\n\t\ttarget_thermal_zone);\n\tclosedir(dir);\n\n\tif (!ptdata.nr_tz_sensor) {\n\t\tfprintf(stderr, \"\\nNo thermal zones found, exit\\n\\n\");\n\t\treturn -1;\n\t}\n\n\tptdata.tzi = calloc(ptdata.max_tz_instance+1, sizeof(struct tz_info));\n\tif (!ptdata.tzi) {\n\t\tfprintf(stderr, \"Err: allocate tz_info\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (ptdata.nr_cooling_dev) {\n\t\tptdata.cdi = calloc(ptdata.max_cdev_instance + 1,\n\t\t\t\tsizeof(struct cdev_info));\n\t\tif (!ptdata.cdi) {\n\t\t\tfree(ptdata.tzi);\n\t\t\tfprintf(stderr, \"Err: allocate cdev_info\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tif (scan_tzones())\n\t\treturn -1;\n\tif (scan_cdevs())\n\t\treturn -1;\n\treturn 0;\n}\n\n \nint zone_instance_to_index(int zone_inst)\n{\n\tint i;\n\n\tfor (i = 0; i < ptdata.nr_tz_sensor; i++)\n\t\tif (ptdata.tzi[i].instance == zone_inst)\n\t\t\treturn i;\n\treturn -ENOENT;\n}\n\n \nint update_thermal_data()\n{\n\tint i;\n\tint next_thermal_record = cur_thermal_record + 1;\n\tchar tz_name[256];\n\tstatic unsigned long samples;\n\n\tif (!ptdata.nr_tz_sensor) {\n\t\tsyslog(LOG_ERR, \"No thermal zones found!\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (next_thermal_record >= NR_THERMAL_RECORDS)\n\t\tnext_thermal_record = 0;\n\tgettimeofday(&trec[next_thermal_record].tv, NULL);\n\tif (tmon_log) {\n\t\tfprintf(tmon_log, \"%lu \", ++samples);\n\t\tfprintf(tmon_log, \"%3.1f \", p_param.t_target);\n\t}\n\tfor (i = 0; i < ptdata.nr_tz_sensor; i++) {\n\t\tmemset(tz_name, 0, sizeof(tz_name));\n\t\tsnprintf(tz_name, 256, \"%s/%s%d\", THERMAL_SYSFS, TZONE,\n\t\t\tptdata.tzi[i].instance);\n\t\tsysfs_get_ulong(tz_name, \"temp\",\n\t\t\t\t&trec[next_thermal_record].temp[i]);\n\t\tif (tmon_log)\n\t\t\tfprintf(tmon_log, \"%lu \",\n\t\t\t\ttrec[next_thermal_record].temp[i] / 1000);\n\t}\n\tcur_thermal_record = next_thermal_record;\n\tfor (i = 0; i < ptdata.nr_cooling_dev; i++) {\n\t\tchar cdev_name[256];\n\t\tunsigned long val;\n\n\t\tsnprintf(cdev_name, 256, \"%s/%s%d\", THERMAL_SYSFS, CDEV,\n\t\t\tptdata.cdi[i].instance);\n\t\tprobe_cdev(&ptdata.cdi[i], cdev_name);\n\t\tval = ptdata.cdi[i].cur_state;\n\t\tif (val > 1000000)\n\t\t\tval = 0;\n\t\tif (tmon_log)\n\t\t\tfprintf(tmon_log, \"%lu \", val);\n\t}\n\n\tif (tmon_log) {\n\t\tfprintf(tmon_log, \"\\n\");\n\t\tfflush(tmon_log);\n\t}\n\n\treturn 0;\n}\n\nvoid set_ctrl_state(unsigned long state)\n{\n\tchar ctrl_cdev_path[256];\n\tint i;\n\tunsigned long cdev_state;\n\n\tif (no_control)\n\t\treturn;\n\t \n\tfor (i = 0; i < ptdata.nr_cooling_dev; i++) {\n\t\tif (ptdata.cdi[i].flag & CDEV_FLAG_IN_CONTROL) {\n\t\t\tif (ptdata.cdi[i].max_state < 10) {\n\t\t\t\tstrcpy(ctrl_cdev, \"None.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tcdev_state = state * ptdata.cdi[i].max_state/100;\n\t\t\tsyslog(LOG_DEBUG,\n\t\t\t\t\"ctrl cdev %d set state %lu scaled to %lu\\n\",\n\t\t\t\tptdata.cdi[i].instance, state, cdev_state);\n\t\t\tsnprintf(ctrl_cdev_path, 256, \"%s/%s%d\", THERMAL_SYSFS,\n\t\t\t\tCDEV, ptdata.cdi[i].instance);\n\t\t\tsyslog(LOG_DEBUG, \"ctrl cdev path %s\", ctrl_cdev_path);\n\t\t\tsysfs_set_ulong(ctrl_cdev_path, \"cur_state\",\n\t\t\t\t\tcdev_state);\n\t\t}\n\t}\n}\n\nvoid get_ctrl_state(unsigned long *state)\n{\n\tchar ctrl_cdev_path[256];\n\tint ctrl_cdev_id = -1;\n\tint i;\n\n\t \n\tfor (i = 0; i < ptdata.nr_cooling_dev; i++) {\n\t\tif (ptdata.cdi[i].flag & CDEV_FLAG_IN_CONTROL) {\n\t\t\tctrl_cdev_id = ptdata.cdi[i].instance;\n\t\t\tsyslog(LOG_INFO, \"ctrl cdev %d get state\\n\",\n\t\t\t\tptdata.cdi[i].instance);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ctrl_cdev_id == -1) {\n\t\t*state = 0;\n\t\treturn;\n\t}\n\tsnprintf(ctrl_cdev_path, 256, \"%s/%s%d\", THERMAL_SYSFS,\n\t\tCDEV, ctrl_cdev_id);\n\tsysfs_get_ulong(ctrl_cdev_path, \"cur_state\", state);\n}\n\nvoid free_thermal_data(void)\n{\n\tfree(ptdata.tzi);\n\tfree(ptdata.cdi);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}