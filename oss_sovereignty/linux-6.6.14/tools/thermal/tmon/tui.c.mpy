{
  "module_name": "tui.c",
  "hash_id": "bafb99e0fbf3ce7bf0ff094fd497a704c6ea6b3be52f77ab84fca1a9cb841e4b",
  "original_prompt": "Ingested from linux-6.6.14/tools/thermal/tmon/tui.c",
  "human_readable_source": "\n \n\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <ncurses.h>\n#include <time.h>\n#include <syslog.h>\n#include <panel.h>\n#include <pthread.h>\n#include <signal.h>\n\n#include \"tmon.h\"\n\n#define min(x, y) ({\t\t\t\t\\\n\ttypeof(x) _min1 = (x);\t\t\t\\\n\ttypeof(y) _min2 = (y);\t\t\t\\\n\t(void) (&_min1 == &_min2);\t\t\\\n\t_min1 < _min2 ? _min1 : _min2; })\n\n#define max(x, y) ({\t\t\t\t\\\n\ttypeof(x) _max1 = (x);\t\t\t\\\n\ttypeof(y) _max2 = (y);\t\t\t\\\n\t(void) (&_max1 == &_max2);\t\t\\\n\t_max1 > _max2 ? _max1 : _max2; })\n\nstatic PANEL *data_panel;\nstatic PANEL *dialogue_panel;\nstatic PANEL *top;\n\nstatic WINDOW *title_bar_window;\nstatic WINDOW *tz_sensor_window;\nstatic WINDOW *cooling_device_window;\nstatic WINDOW *control_window;\nstatic WINDOW *status_bar_window;\nstatic WINDOW *thermal_data_window;\nstatic WINDOW *dialogue_window;\n\nchar status_bar_slots[10][40];\nstatic void draw_hbar(WINDOW *win, int y, int start, int len,\n\t\tunsigned long pattern, bool end);\n\nstatic int maxx, maxy;\nstatic int maxwidth = 200;\n\n#define TITLE_BAR_HIGHT 1\n#define SENSOR_WIN_HIGHT 4  \n\n\n \nstatic int  tui_disabled;\n\nstatic void close_panel(PANEL *p)\n{\n\tif (p) {\n\t\tdel_panel(p);\n\t\tp = NULL;\n\t}\n}\n\nstatic void close_window(WINDOW *win)\n{\n\tif (win) {\n\t\tdelwin(win);\n\t\twin = NULL;\n\t}\n}\n\nvoid close_windows(void)\n{\n\tif (tui_disabled)\n\t\treturn;\n\t \n\tif (dialogue_window)\n\t\tclose_panel(dialogue_panel);\n\tif (cooling_device_window)\n\t\tclose_panel(data_panel);\n\n\tclose_window(title_bar_window);\n\tclose_window(tz_sensor_window);\n\tclose_window(status_bar_window);\n\tclose_window(cooling_device_window);\n\tclose_window(control_window);\n\tclose_window(thermal_data_window);\n\tclose_window(dialogue_window);\n\n}\n\nvoid write_status_bar(int x, char *line)\n{\n\tmvwprintw(status_bar_window, 0, x, \"%s\", line);\n\twrefresh(status_bar_window);\n}\n\n \n#define DIAG_DEV_ROWS  5\n \nstatic int diag_dev_rows(void)\n{\n\tint entries = ptdata.nr_cooling_dev + 1;\n\tint rows = max(DIAG_DEV_ROWS, (entries + 1) / 2);\n\treturn min(rows, entries);\n}\n\nvoid setup_windows(void)\n{\n\tint y_begin = 1;\n\n\tif (tui_disabled)\n\t\treturn;\n\n\tgetmaxyx(stdscr, maxy, maxx);\n\tresizeterm(maxy, maxx);\n\n\ttitle_bar_window = subwin(stdscr, TITLE_BAR_HIGHT, maxx, 0, 0);\n\ty_begin += TITLE_BAR_HIGHT;\n\n\ttz_sensor_window = subwin(stdscr, SENSOR_WIN_HIGHT, maxx, y_begin, 0);\n\ty_begin += SENSOR_WIN_HIGHT;\n\n\tcooling_device_window = subwin(stdscr, ptdata.nr_cooling_dev + 3, maxx,\n\t\t\t\ty_begin, 0);\n\ty_begin += ptdata.nr_cooling_dev + 3;  \n\t \n\n\tdialogue_window = subwin(stdscr, diag_dev_rows() + 5, maxx-50,\n\t\t\t\tDIAG_Y, DIAG_X);\n\n\tthermal_data_window = subwin(stdscr, ptdata.nr_tz_sensor *\n\t\t\t\tNR_LINES_TZDATA + 3, maxx, y_begin, 0);\n\ty_begin += ptdata.nr_tz_sensor * NR_LINES_TZDATA + 3;\n\tcontrol_window = subwin(stdscr, 4, maxx, y_begin, 0);\n\n\tscrollok(cooling_device_window, TRUE);\n\tmaxwidth = maxx - 18;\n\tstatus_bar_window = subwin(stdscr, 1, maxx, maxy-1, 0);\n\n\tstrcpy(status_bar_slots[0], \" Ctrl-c - Quit \");\n\tstrcpy(status_bar_slots[1], \" TAB - Tuning \");\n\twmove(status_bar_window, 1, 30);\n\n\t \n\tdata_panel = new_panel(cooling_device_window);\n\tif (!data_panel)\n\t\tsyslog(LOG_DEBUG, \"No data panel\\n\");\n\telse {\n\t\tif (dialogue_window) {\n\t\t\tdialogue_panel = new_panel(dialogue_window);\n\t\t\tif (!dialogue_panel)\n\t\t\t\tsyslog(LOG_DEBUG, \"No dialogue panel\\n\");\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tset_panel_userptr(data_panel, dialogue_panel);\n\t\t\t\tset_panel_userptr(dialogue_panel, data_panel);\n\t\t\t\ttop = data_panel;\n\t\t\t}\n\t\t} else\n\t\t\tsyslog(LOG_INFO, \"no dialogue win, term too small\\n\");\n\t}\n\tdoupdate();\n\twerase(stdscr);\n\trefresh();\n}\n\nvoid resize_handler(int sig)\n{\n\t \n\tclose_windows();\n\tendwin();\n\trefresh();\n\tclear();\n\tgetmaxyx(stdscr, maxy, maxx);   \n\tsetup_windows();\n\t \n\tsleep(1);\n\tsyslog(LOG_DEBUG, \"SIG %d, term resized to %d x %d\\n\",\n\t\tsig, maxy, maxx);\n\tsignal(SIGWINCH, resize_handler);\n}\n\nconst char cdev_title[] = \" COOLING DEVICES \";\nvoid show_cooling_device(void)\n{\n\tint i, j, x, y = 0;\n\n\tif (tui_disabled || !cooling_device_window)\n\t\treturn;\n\n\twerase(cooling_device_window);\n\twattron(cooling_device_window, A_BOLD);\n\tmvwprintw(cooling_device_window,  1, 1,\n\t\t\"ID  Cooling Dev   Cur    Max   Thermal Zone Binding\");\n\twattroff(cooling_device_window, A_BOLD);\n\tfor (j = 0; j <\tptdata.nr_cooling_dev; j++) {\n\t\t \n\t\tmvwprintw(cooling_device_window, j + 2, 1,\n\t\t\t\"%02d %12.12s%6d %6d\",\n\t\t\tptdata.cdi[j].instance,\n\t\t\tptdata.cdi[j].type,\n\t\t\tptdata.cdi[j].cur_state,\n\t\t\tptdata.cdi[j].max_state);\n\t}\n\n\t \n\tfor (i = 0; i < ptdata.nr_tz_sensor; i++) {\n\t\tint tz_inst = ptdata.tzi[i].instance;\n\t\tfor (j = 0; j < ptdata.nr_cooling_dev; j++) {\n\t\t\tint cdev_inst;\n\t\t\ty = j;\n\t\t\tx = tz_inst * TZONE_RECORD_SIZE + TZ_LEFT_ALIGN;\n\n\t\t\tdraw_hbar(cooling_device_window, y+2, x,\n\t\t\t\tTZONE_RECORD_SIZE-1, ACS_VLINE, false);\n\n\t\t\t \n\t\t\tmvwprintw(cooling_device_window, y+2, x-1, \" \");\n\t\t\tif (ptdata.tzi[i].cdev_binding) {\n\t\t\t\tcdev_inst = ptdata.cdi[j].instance;\n\t\t\t\tunsigned long trip_binding =\n\t\t\t\t\tptdata.tzi[i].trip_binding[cdev_inst];\n\t\t\t\tint k = 0;  \n\t\t\t\tsyslog(LOG_DEBUG,\n\t\t\t\t\t\"bind tz%d cdev%d tp%lx %d cdev%lx\\n\",\n\t\t\t\t\ti, j, trip_binding, y,\n\t\t\t\t\tptdata.tzi[i].cdev_binding);\n\t\t\t\t \n\t\t\t\twhile (trip_binding >>= 1) {\n\t\t\t\t\tk++;\n\t\t\t\t\tif (!(trip_binding & 1))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t \n\t\t\t\t\tmvwprintw(cooling_device_window,\n\t\t\t\t\t\ty + 2,\n\t\t\t\t\t\tx + ptdata.tzi[i].nr_trip_pts -\n\t\t\t\t\t\tk - 1, \"*\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\twborder(cooling_device_window, 0, 0, 0, 0, 0, 0, 0, 0);\n\twattron(cooling_device_window, A_BOLD);\n\tmvwprintw(cooling_device_window, 0, maxx/2 - sizeof(cdev_title),\n\t\tcdev_title);\n\twattroff(cooling_device_window, A_BOLD);\n\n\twrefresh(cooling_device_window);\n}\n\nconst char DIAG_TITLE[] = \"[ TUNABLES ]\";\nvoid show_dialogue(void)\n{\n\tint j, x = 0, y = 0;\n\tint rows, cols;\n\tWINDOW *w = dialogue_window;\n\n\tif (tui_disabled || !w)\n\t\treturn;\n\n\tgetmaxyx(w, rows, cols);\n\n\t \n\t(void)cols;\n\n\twerase(w);\n\tbox(w, 0, 0);\n\tmvwprintw(w, 0, maxx/4, DIAG_TITLE);\n\t \n\tfor (j = 0; j <= ptdata.nr_cooling_dev; j++) {\n\t\ty = j % diag_dev_rows();\n\t\tif (y == 0 && j != 0)\n\t\t\tx += 20;\n\t\tif (j == ptdata.nr_cooling_dev)\n\t\t\t \n\t\t\tmvwprintw(w, y+1, x+1, \"%C-%.12s\", 'A'+j, \"Set Temp\");\n\t\telse\n\t\t\tmvwprintw(w, y+1, x+1, \"%C-%.10s-%2d\", 'A'+j,\n\t\t\t\tptdata.cdi[j].type, ptdata.cdi[j].instance);\n\t}\n\twattron(w, A_BOLD);\n\tmvwprintw(w, diag_dev_rows()+1, 1, \"Enter Choice [A-Z]?\");\n\twattroff(w, A_BOLD);\n\t \n\tmvwprintw(w, rows - 2, 1,\n\t\t\"Legend: A=Active, P=Passive, C=Critical\");\n\n\twrefresh(dialogue_window);\n}\n\nvoid write_dialogue_win(char *buf, int y, int x)\n{\n\tWINDOW *w = dialogue_window;\n\n\tmvwprintw(w, y, x, \"%s\", buf);\n}\n\nconst char control_title[] = \" CONTROLS \";\nvoid show_control_w(void)\n{\n\tunsigned long state;\n\n\tget_ctrl_state(&state);\n\n\tif (tui_disabled || !control_window)\n\t\treturn;\n\n\twerase(control_window);\n\tmvwprintw(control_window, 1, 1,\n\t\t\"PID gain: kp=%2.2f ki=%2.2f kd=%2.2f Output %2.2f\",\n\t\tp_param.kp, p_param.ki, p_param.kd, p_param.y_k);\n\n\tmvwprintw(control_window, 2, 1,\n\t\t\"Target Temp: %2.1fC, Zone: %d, Control Device: %.12s\",\n\t\tp_param.t_target, target_thermal_zone, ctrl_cdev);\n\n\t \n\twborder(control_window, 0, 0, 0, 0, 0, 0, 0, 0);\n\twattron(control_window, A_BOLD);\n\tmvwprintw(control_window, 0, maxx/2 - sizeof(control_title),\n\t\tcontrol_title);\n\twattroff(control_window, A_BOLD);\n\n\twrefresh(control_window);\n}\n\nvoid initialize_curses(void)\n{\n\tif (tui_disabled)\n\t\treturn;\n\n\tinitscr();\n\tstart_color();\n\tkeypad(stdscr, TRUE);\t \n\tnonl();\t\t\t \n\tcbreak();\t\t \n\tnoecho();\t\t \n\tcurs_set(0);\t\t \n\tuse_default_colors();\n\n\tinit_pair(PT_COLOR_DEFAULT, COLOR_WHITE, COLOR_BLACK);\n\tinit_pair(PT_COLOR_HEADER_BAR, COLOR_BLACK, COLOR_WHITE);\n\tinit_pair(PT_COLOR_ERROR, COLOR_BLACK, COLOR_RED);\n\tinit_pair(PT_COLOR_RED, COLOR_WHITE, COLOR_RED);\n\tinit_pair(PT_COLOR_YELLOW, COLOR_WHITE, COLOR_YELLOW);\n\tinit_pair(PT_COLOR_GREEN, COLOR_WHITE, COLOR_GREEN);\n\tinit_pair(PT_COLOR_BLUE, COLOR_WHITE, COLOR_BLUE);\n\tinit_pair(PT_COLOR_BRIGHT, COLOR_WHITE, COLOR_BLACK);\n\n}\n\nvoid show_title_bar(void)\n{\n\tint i;\n\tint x = 0;\n\n\tif (tui_disabled || !title_bar_window)\n\t\treturn;\n\n\twattrset(title_bar_window, COLOR_PAIR(PT_COLOR_HEADER_BAR));\n\twbkgd(title_bar_window, COLOR_PAIR(PT_COLOR_HEADER_BAR));\n\twerase(title_bar_window);\n\n\tmvwprintw(title_bar_window, 0, 0,\n\t\t\"     TMON v%s\", VERSION);\n\n\twrefresh(title_bar_window);\n\n\twerase(status_bar_window);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tif (strlen(status_bar_slots[i]) == 0)\n\t\t\tcontinue;\n\t\twattron(status_bar_window, A_REVERSE);\n\t\tmvwprintw(status_bar_window, 0, x, \"%s\", status_bar_slots[i]);\n\t\twattroff(status_bar_window, A_REVERSE);\n\t\tx += strlen(status_bar_slots[i]) + 1;\n\t}\n\twrefresh(status_bar_window);\n}\n\nstatic void handle_input_val(int ch)\n{\n\tchar buf[32];\n\tint val;\n\tchar path[256];\n\tWINDOW *w = dialogue_window;\n\n\techo();\n\tkeypad(w, TRUE);\n\twgetnstr(w, buf, 31);\n\tval = atoi(buf);\n\n\tif (ch == ptdata.nr_cooling_dev) {\n\t\tsnprintf(buf, 31, \"Invalid Temp %d! %d-%d\", val,\n\t\t\tMIN_CTRL_TEMP, MAX_CTRL_TEMP);\n\t\tif (val < MIN_CTRL_TEMP || val > MAX_CTRL_TEMP)\n\t\t\twrite_status_bar(40, buf);\n\t\telse {\n\t\t\tp_param.t_target = val;\n\t\t\tsnprintf(buf, 31, \"Set New Target Temp %d\", val);\n\t\t\twrite_status_bar(40, buf);\n\t\t}\n\t} else {\n\t\tsnprintf(path, 256, \"%s/%s%d\", THERMAL_SYSFS,\n\t\t\tCDEV, ptdata.cdi[ch].instance);\n\t\tsysfs_set_ulong(path, \"cur_state\", val);\n\t}\n\tnoecho();\n\tdialogue_on = 0;\n\tshow_data_w();\n\tshow_control_w();\n\n\ttop = (PANEL *)panel_userptr(top);\n\ttop_panel(top);\n}\n\nstatic void handle_input_choice(int ch)\n{\n\tchar buf[48];\n\tint base = 0;\n\tint cdev_id = 0;\n\n\tif ((ch >= 'A' && ch <= 'A' + ptdata.nr_cooling_dev) ||\n\t\t(ch >= 'a' && ch <= 'a' + ptdata.nr_cooling_dev)) {\n\t\tbase = (ch < 'a') ? 'A' : 'a';\n\t\tcdev_id = ch - base;\n\t\tif (ptdata.nr_cooling_dev == cdev_id)\n\t\t\tsnprintf(buf, sizeof(buf), \"New Target Temp:\");\n\t\telse\n\t\t\tsnprintf(buf, sizeof(buf), \"New Value for %.10s-%2d: \",\n\t\t\t\tptdata.cdi[cdev_id].type,\n\t\t\t\tptdata.cdi[cdev_id].instance);\n\t\twrite_dialogue_win(buf, diag_dev_rows() + 2, 2);\n\t\thandle_input_val(cdev_id);\n\t} else {\n\t\tsnprintf(buf, sizeof(buf), \"Invalid selection %d\", ch);\n\t\twrite_dialogue_win(buf, 8, 2);\n\t}\n}\n\nvoid *handle_tui_events(void *arg)\n{\n\tint ch;\n\n\tkeypad(cooling_device_window, TRUE);\n\twhile ((ch = wgetch(cooling_device_window)) != EOF) {\n\t\tif (tmon_exit)\n\t\t\tbreak;\n\t\t \n\t\tif (!data_panel || !dialogue_panel ||\n\t\t\t!cooling_device_window ||\n\t\t\t!dialogue_window) {\n\n\t\t\tcontinue;\n\t\t}\n\t\tpthread_mutex_lock(&input_lock);\n\t\tif (dialogue_on) {\n\t\t\thandle_input_choice(ch);\n\t\t\t \n\t\t\tif (ch == 'q' || ch == 'Q')\n\t\t\t\tch = 0;\n\t\t}\n\t\tswitch (ch) {\n\t\tcase KEY_LEFT:\n\t\t\tbox(cooling_device_window, 10, 0);\n\t\t\tbreak;\n\t\tcase 9:  \n\t\t\ttop = (PANEL *)panel_userptr(top);\n\t\t\ttop_panel(top);\n\t\t\tif (top == dialogue_panel) {\n\t\t\t\tdialogue_on = 1;\n\t\t\t\tshow_dialogue();\n\t\t\t} else {\n\t\t\t\tdialogue_on = 0;\n\t\t\t\t \n\t\t\t\tshow_data_w();\n\t\t\t\tshow_control_w();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q':\n\t\tcase 'Q':\n\t\t\ttmon_exit = 1;\n\t\t\tbreak;\n\t\t}\n\t\tupdate_panels();\n\t\tdoupdate();\n\t\tpthread_mutex_unlock(&input_lock);\n\t}\n\n\tif (arg)\n\t\t*(int *)arg = 0;  \n\n\treturn NULL;\n}\n\n \nstatic void draw_hbar(WINDOW *win, int y, int start, int len, unsigned long ptn,\n\t\tbool end)\n{\n\tmvwaddch(win, y, start, ptn);\n\twhline(win, ptn, len);\n\tif (end)\n\t\tmvwaddch(win, y, MAX_DISP_TEMP+TDATA_LEFT, ']');\n}\n\nstatic char trip_type_to_char(int type)\n{\n\tswitch (type) {\n\tcase THERMAL_TRIP_CRITICAL: return 'C';\n\tcase THERMAL_TRIP_HOT: return 'H';\n\tcase THERMAL_TRIP_PASSIVE: return 'P';\n\tcase THERMAL_TRIP_ACTIVE: return 'A';\n\tdefault:\n\t\treturn '?';\n\t}\n}\n\n \nstatic void draw_tp_line(int tz, int y)\n{\n\tint j;\n\tint x;\n\n\tfor (j = 0; j < ptdata.tzi[tz].nr_trip_pts; j++) {\n\t\tx = ptdata.tzi[tz].tp[j].temp / 1000;\n\t\tmvwprintw(thermal_data_window, y + 0, x + TDATA_LEFT,\n\t\t\t\"%c%d\", trip_type_to_char(ptdata.tzi[tz].tp[j].type),\n\t\t\tx);\n\t\tsyslog(LOG_INFO, \"%s:tz %d tp %d temp = %lu\\n\", __func__,\n\t\t\ttz, j, ptdata.tzi[tz].tp[j].temp);\n\t}\n}\n\nconst char data_win_title[] = \" THERMAL DATA \";\nvoid show_data_w(void)\n{\n\tint i;\n\n\n\tif (tui_disabled || !thermal_data_window)\n\t\treturn;\n\n\twerase(thermal_data_window);\n\twattron(thermal_data_window, A_BOLD);\n\tmvwprintw(thermal_data_window, 0, maxx/2 - sizeof(data_win_title),\n\t\tdata_win_title);\n\twattroff(thermal_data_window, A_BOLD);\n\t \n\tfor (i = 10; i < MAX_DISP_TEMP; i += 10)\n\t\tmvwprintw(thermal_data_window, 1, i+TDATA_LEFT, \"%2d\", i);\n\n\tfor (i = 0; i < ptdata.nr_tz_sensor; i++) {\n\t\tint temp = trec[cur_thermal_record].temp[i] / 1000;\n\t\tint y = 0;\n\n\t\ty = i * NR_LINES_TZDATA + 2;\n\t\t \n\t\tmvwprintw(thermal_data_window, y, 1, \"%6.6s%2d:[%3d][\",\n\t\t\tptdata.tzi[i].type,\n\t\t\tptdata.tzi[i].instance, temp);\n\t\tdraw_hbar(thermal_data_window, y, TDATA_LEFT, temp, ACS_RARROW,\n\t\t\ttrue);\n\t\tdraw_tp_line(i, y);\n\t}\n\twborder(thermal_data_window, 0, 0, 0, 0, 0, 0, 0, 0);\n\twrefresh(thermal_data_window);\n}\n\nconst char tz_title[] = \"THERMAL ZONES(SENSORS)\";\n\nvoid show_sensors_w(void)\n{\n\tint i, j;\n\tchar buffer[512];\n\n\tif (tui_disabled || !tz_sensor_window)\n\t\treturn;\n\n\twerase(tz_sensor_window);\n\n\tmemset(buffer, 0, sizeof(buffer));\n\twattron(tz_sensor_window, A_BOLD);\n\tmvwprintw(tz_sensor_window, 1, 1, \"Thermal Zones:\");\n\twattroff(tz_sensor_window, A_BOLD);\n\n\tmvwprintw(tz_sensor_window, 1, TZ_LEFT_ALIGN, \"%s\", buffer);\n\t \n\twattron(tz_sensor_window, A_BOLD);\n\tmvwprintw(tz_sensor_window, 2, 1, \"Trip Points:\");\n\twattroff(tz_sensor_window, A_BOLD);\n\n\t \n\tfor (i = 0; i < ptdata.nr_tz_sensor; i++) {\n\t\tint inst = ptdata.tzi[i].instance;\n\n\t\tmvwprintw(tz_sensor_window, 1,\n\t\t\tTZ_LEFT_ALIGN+TZONE_RECORD_SIZE * inst, \"%.9s%02d\",\n\t\t\tptdata.tzi[i].type, ptdata.tzi[i].instance);\n\t\tfor (j = ptdata.tzi[i].nr_trip_pts - 1; j >= 0; j--) {\n\t\t\t \n\t\t\tchar type;\n\t\t\tint tp_pos;\n\t\t\t \n\t\t\ttp_pos = ptdata.tzi[i].nr_trip_pts - j - 1;\n\n\t\t\ttype = trip_type_to_char(ptdata.tzi[i].tp[j].type);\n\t\t\tmvwaddch(tz_sensor_window, 2,\n\t\t\t\tinst * TZONE_RECORD_SIZE + TZ_LEFT_ALIGN +\n\t\t\t\ttp_pos,\ttype);\n\t\t\tsyslog(LOG_DEBUG, \"draw tz %d tp %d ch:%c\\n\",\n\t\t\t\tinst, j, type);\n\t\t}\n\t}\n\twborder(tz_sensor_window, 0, 0, 0, 0, 0, 0, 0, 0);\n\twattron(tz_sensor_window, A_BOLD);\n\tmvwprintw(tz_sensor_window, 0, maxx/2 - sizeof(tz_title), tz_title);\n\twattroff(tz_sensor_window, A_BOLD);\n\twrefresh(tz_sensor_window);\n}\n\nvoid disable_tui(void)\n{\n\ttui_disabled = 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}