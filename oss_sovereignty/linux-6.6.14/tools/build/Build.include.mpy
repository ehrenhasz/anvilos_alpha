{
  "module_name": "Build.include",
  "hash_id": "590c70f692bd2b017f1708289bcae5eb6762854a5d24c1fe3b750db1b11856d8",
  "original_prompt": "Ingested from linux-6.6.14/tools/build/Build.include",
  "human_readable_source": "###\n# build: Generic definitions\n#\n#  Lots of this code have been borrowed or heavily inspired from parts\n#  of kbuild code, which is not credited, but mostly developed by:\n#\n#  Copyright (C) Sam Ravnborg <sam@mars.ravnborg.org>, 2015\n#  Copyright (C) Linus Torvalds <torvalds@linux-foundation.org>, 2015\n#\n\n###\n# Convenient variables\ncomma   := ,\nsquote  := '\npound   := \\#\n\n###\n# Name of target with a '.' as filename prefix. foo/bar.o => foo/.bar.o\ndot-target = $(dir $@).$(notdir $@)\n\n###\n# filename of target with directory and extension stripped\nbasetarget = $(basename $(notdir $@))\n\n###\n# The temporary file to save gcc -MD generated dependencies must not\n# contain a comma\ndepfile = $(subst $(comma),_,$(dot-target).d)\n\n###\n# Check if both arguments has same arguments. Result is empty string if equal.\narg-check = $(strip $(filter-out $(cmd_$(1)), $(cmd_$@)) \\\n                    $(filter-out $(cmd_$@),   $(cmd_$(1))) )\n\n###\n# Escape single quote for use in echo statements\nescsq = $(subst $(squote),'\\$(squote)',$1)\n\n# Echo command\n# Short version is used, if $(quiet) equals `quiet_', otherwise full one.\necho-cmd = $(if $($(quiet)cmd_$(1)),\\\n           echo '  $(call escsq,$($(quiet)cmd_$(1)))';)\n\n###\n# Replace >$< with >$$< to preserve $ when reloading the .cmd file\n# (needed for make)\n# Replace >#< with >$(pound)< to avoid starting a comment in the .cmd file\n# (needed for make)\n# Replace >'< with >'\\''< to be able to enclose the whole string in '...'\n# (needed for the shell)\nmake-cmd = $(call escsq,$(subst $(pound),$$(pound),$(subst $$,$$$$,$(cmd_$(1)))))\n\n###\n# Find any prerequisites that is newer than target or that does not exist.\n# PHONY targets skipped in both cases.\nany-prereq = $(filter-out $(PHONY),$?) $(filter-out $(PHONY) $(wildcard $^),$^)\n\n###\n# Copy dependency data into .cmd file\n#  - gcc -M dependency info\n#  - command line to create object 'cmd_object :='\ndep-cmd = $(if $(wildcard $(fixdep)),                                           \\\n           $(fixdep) $(depfile) $@ '$(make-cmd)' > $(dot-target).tmp;           \\\n           rm -f $(depfile);                                                    \\\n           mv -f $(dot-target).tmp $(dot-target).cmd,                           \\\n           printf '$(pound) cannot find fixdep (%s)\\n' $(fixdep) > $(dot-target).cmd; \\\n           printf '$(pound) using basic dep data\\n\\n' >> $(dot-target).cmd;           \\\n           cat $(depfile) >> $(dot-target).cmd;                                 \\\n           printf '\\n%s\\n' 'cmd_$@ := $(make-cmd)' >> $(dot-target).cmd)\n\n###\n# if_changed_dep  - execute command if any prerequisite is newer than\n#                   target, or command line has changed and update\n#                   dependencies in the cmd file\nif_changed_dep = $(if $(strip $(any-prereq) $(arg-check)),         \\\n                  @set -e;                                         \\\n                  $(echo-cmd) $(cmd_$(1));                         \\\n                  $(dep-cmd))\n\n# if_changed      - execute command if any prerequisite is newer than\n#                   target, or command line has changed\nif_changed = $(if $(strip $(any-prereq) $(arg-check)),                   \\\n              @set -e;                                                   \\\n              $(echo-cmd) $(cmd_$(1));                                   \\\n              printf '%s\\n' 'cmd_$@ := $(make-cmd)' > $(dot-target).cmd)\n\n###\n# C flags to be used in rule definitions, includes:\n# - depfile generation\n# - global $(CFLAGS)\n# - per target C flags\n# - per object C flags\n# - BUILD_STR macro to allow '-D\"$(variable)\"' constructs\nc_flags_1 = -Wp,-MD,$(depfile) -Wp,-MT,$@ $(CFLAGS) -D\"BUILD_STR(s)=\\#s\" $(CFLAGS_$(basetarget).o) $(CFLAGS_$(obj))\nc_flags_2 = $(filter-out $(CFLAGS_REMOVE_$(basetarget).o), $(c_flags_1))\nc_flags   = $(filter-out $(CFLAGS_REMOVE_$(obj)), $(c_flags_2))\ncxx_flags = -Wp,-MD,$(depfile) -Wp,-MT,$@ $(CXXFLAGS) -D\"BUILD_STR(s)=\\#s\" $(CXXFLAGS_$(basetarget).o) $(CXXFLAGS_$(obj))\n\n###\n## HOSTCC C flags\n\nhost_c_flags = -Wp,-MD,$(depfile) -Wp,-MT,$@ $(HOSTCFLAGS) -D\"BUILD_STR(s)=\\#s\" $(HOSTCFLAGS_$(basetarget).o) $(HOSTCFLAGS_$(obj))\n\n# output directory for tests below\nTMPOUT = .tmp_$$$$\n\n# try-run\n# Usage: option = $(call try-run, $(CC)...-o \"$$TMP\",option-ok,otherwise)\n# Exit code chooses option. \"$$TMP\" serves as a temporary file and is\n# automatically cleaned up.\ntry-run = $(shell set -e;\t\t\\\n\tTMP=$(TMPOUT)/tmp;\t\t\\\n\tmkdir -p $(TMPOUT);\t\t\\\n\ttrap \"rm -rf $(TMPOUT)\" EXIT;\t\\\n\tif ($(1)) >/dev/null 2>&1;\t\\\n\tthen echo \"$(2)\";\t\t\\\n\telse echo \"$(3)\";\t\t\\\n\tfi)\n\n# cc-option\n# Usage: cflags-y += $(call cc-option,-march=winchip-c6,-march=i586)\ncc-option = $(call try-run, \\\n\t$(CC) -Werror $(1) -c -x c /dev/null -o \"$$TMP\",$(1),$(2))\n\n# delete partially updated (i.e. corrupted) files on error\n.DELETE_ON_ERROR:\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}