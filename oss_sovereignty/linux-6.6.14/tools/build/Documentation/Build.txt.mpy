{
  "module_name": "Build.txt",
  "hash_id": "9d62157b171af32774f368957ad26bd598953539b997e18116f39fca5947e20e",
  "original_prompt": "Ingested from linux-6.6.14/tools/build/Documentation/Build.txt",
  "human_readable_source": "Build Framework\n===============\n\nThe perf build framework was adopted from the kernel build system, hence the\nidea and the way how objects are built is the same.\n\nBasically the user provides set of 'Build' files that list objects and\ndirectories to nest for specific target to be build.\n\nUnlike the kernel we don't have a single build object 'obj-y' list that where\nwe setup source objects, but we support more. This allows one 'Build' file to\ncarry a sources list for multiple build objects.\n\n\nBuild framework makefiles\n-------------------------\n\nThe build framework consists of 2 Makefiles:\n\n  Build.include\n  Makefile.build\n\nWhile the 'Build.include' file contains just some generic definitions, the\n'Makefile.build' file is the makefile used from the outside. It's\ninterface/usage is following:\n\n  $ make -f tools/build/Makefile.build srctree=$(KSRC) dir=$(DIR) obj=$(OBJECT)\n\nwhere:\n\n  KSRC   - is the path to kernel sources\n  DIR    - is the path to the project to be built\n  OBJECT - is the name of the build object\n\nWhen succefully finished the $(DIR) directory contains the final object file\ncalled $(OBJECT)-in.o:\n\n  $ ls $(DIR)/$(OBJECT)-in.o\n\nwhich includes all compiled sources described in 'Build' makefiles.\n\n\nBuild makefiles\n---------------\n\nThe user supplies 'Build' makefiles that contains a objects list, and connects\nthe build to nested directories.\n\nAssume we have the following project structure:\n\n  ex/a.c\n    /b.c\n    /c.c\n    /d.c\n    /arch/e.c\n    /arch/f.c\n\nOut of which you build the 'ex' binary ' and the 'libex.a' library:\n\n  'ex'      - consists of 'a.o', 'b.o' and libex.a\n  'libex.a' - consists of 'c.o', 'd.o', 'e.o' and 'f.o'\n\nThe build framework does not create the 'ex' and 'libex.a' binaries for you, it\nonly prepares proper objects to be compiled and grouped together.\n\nTo follow the above example, the user provides following 'Build' files:\n\n  ex/Build:\n    ex-y += a.o\n    ex-y += b.o\n    ex-y += b.o # duplicates in the lists are allowed\n\n    libex-y += c.o\n    libex-y += d.o\n    libex-y += arch/\n\n  ex/arch/Build:\n    libex-y += e.o\n    libex-y += f.o\n\nand runs:\n\n  $ make -f tools/build/Makefile.build dir=. obj=ex\n  $ make -f tools/build/Makefile.build dir=. obj=libex\n\nwhich creates the following objects:\n\n  ex/ex-in.o\n  ex/libex-in.o\n\nthat contain request objects names in Build files.\n\nIt's only a matter of 2 single commands to create the final binaries:\n\n  $ ar  rcs libex.a libex-in.o\n  $ gcc -o ex ex-in.o libex.a\n\nYou can check the 'ex' example in 'tools/build/tests/ex' for more details.\n\n\nMakefile.include\n----------------\n\nThe tools/build/Makefile.include makefile could be included\nvia user makefiles to get usefull definitions.\n\nIt defines following interface:\n\n  - build macro definition:\n      build := -f $(srctree)/tools/build/Makefile.build dir=. obj\n\n    to make it easier to invoke build like:\n      make $(build)=ex\n\n\nFixdep\n------\nIt is necessary to build the fixdep helper before invoking the build.\nThe Makefile.include file adds the fixdep target, that could be\ninvoked by the user.\n\n\nRules\n-----\n\nThe build framework provides standard compilation rules to handle .S and .c\ncompilation.\n\nIt's possible to include special rule if needed (like we do for flex or bison\ncode generation).\n\n\nCFLAGS\n------\n\nIt's possible to alter the standard object C flags in the following way:\n\n  CFLAGS_perf.o        += '...'  - adds CFLAGS for perf.o object\n  CFLAGS_gtk           += '...'  - adds CFLAGS for gtk build object\n  CFLAGS_REMOVE_perf.o += '...'  - removes CFLAGS for perf.o object\n  CFLAGS_REMOVE_gtk    += '...'  - removes CFLAGS for gtk build object\n\nThis C flags changes has the scope of the Build makefile they are defined in.\n\n\nDependencies\n------------\n\nFor each built object file 'a.o' the '.a.cmd' is created and holds:\n\n  - Command line used to built that object\n    (for each object)\n\n  - Dependency rules generated by 'gcc -Wp,-MD,...'\n    (for compiled object)\n\nAll existing '.cmd' files are included in the Build process to follow properly\nthe dependencies and trigger a rebuild when necessary.\n\n\nSingle rules\n------------\n\nIt's possible to build single object file by choice, like:\n\n  $ make util/map.o    # objects\n  $ make util/map.i    # preprocessor\n  $ make util/map.s    # assembly\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}