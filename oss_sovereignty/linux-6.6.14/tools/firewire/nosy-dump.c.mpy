{
  "module_name": "nosy-dump.c",
  "hash_id": "808db0ed1b6eeb65bb0e7a67683f7c10c4df8ade8bbd1e8ffe05302dbabd1da8",
  "original_prompt": "Ingested from linux-6.6.14/tools/firewire/nosy-dump.c",
  "human_readable_source": "\n \n\n#include <byteswap.h>\n#include <endian.h>\n#include <fcntl.h>\n#include <linux/firewire-constants.h>\n#include <poll.h>\n#include <popt.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include \"list.h\"\n#include \"nosy-dump.h\"\n#include \"nosy-user.h\"\n\nenum {\n\tPACKET_FIELD_DETAIL\t\t= 0x01,\n\tPACKET_FIELD_DATA_LENGTH\t= 0x02,\n\t \n\tPACKET_FIELD_TRANSACTION\t= 0x04,\n};\n\nstatic void print_packet(uint32_t *data, size_t length);\nstatic void decode_link_packet(struct link_packet *packet, size_t length,\n\t\t\t       int include_flags, int exclude_flags);\nstatic int run = 1;\nsig_t sys_sigint_handler;\n\nstatic char *option_nosy_device = \"/dev/nosy\";\nstatic char *option_view = \"packet\";\nstatic char *option_output;\nstatic char *option_input;\nstatic int option_hex;\nstatic int option_iso;\nstatic int option_cycle_start;\nstatic int option_version;\nstatic int option_verbose;\n\nenum {\n\tVIEW_TRANSACTION,\n\tVIEW_PACKET,\n\tVIEW_STATS,\n};\n\nstatic const struct poptOption options[] = {\n\t{\n\t\t.longName\t= \"device\",\n\t\t.shortName\t= 'd',\n\t\t.argInfo\t= POPT_ARG_STRING,\n\t\t.arg\t\t= &option_nosy_device,\n\t\t.descrip\t= \"Path to nosy device.\",\n\t\t.argDescrip\t= \"DEVICE\"\n\t},\n\t{\n\t\t.longName\t= \"view\",\n\t\t.argInfo\t= POPT_ARG_STRING,\n\t\t.arg\t\t= &option_view,\n\t\t.descrip\t= \"Specify view of bus traffic: packet, transaction or stats.\",\n\t\t.argDescrip\t= \"VIEW\"\n\t},\n\t{\n\t\t.longName\t= \"hex\",\n\t\t.shortName\t= 'x',\n\t\t.argInfo\t= POPT_ARG_NONE,\n\t\t.arg\t\t= &option_hex,\n\t\t.descrip\t= \"Print each packet in hex.\",\n\t},\n\t{\n\t\t.longName\t= \"iso\",\n\t\t.argInfo\t= POPT_ARG_NONE,\n\t\t.arg\t\t= &option_iso,\n\t\t.descrip\t= \"Print iso packets.\",\n\t},\n\t{\n\t\t.longName\t= \"cycle-start\",\n\t\t.argInfo\t= POPT_ARG_NONE,\n\t\t.arg\t\t= &option_cycle_start,\n\t\t.descrip\t= \"Print cycle start packets.\",\n\t},\n\t{\n\t\t.longName\t= \"verbose\",\n\t\t.shortName\t= 'v',\n\t\t.argInfo\t= POPT_ARG_NONE,\n\t\t.arg\t\t= &option_verbose,\n\t\t.descrip\t= \"Verbose packet view.\",\n\t},\n\t{\n\t\t.longName\t= \"output\",\n\t\t.shortName\t= 'o',\n\t\t.argInfo\t= POPT_ARG_STRING,\n\t\t.arg\t\t= &option_output,\n\t\t.descrip\t= \"Log to output file.\",\n\t\t.argDescrip\t= \"FILENAME\"\n\t},\n\t{\n\t\t.longName\t= \"input\",\n\t\t.shortName\t= 'i',\n\t\t.argInfo\t= POPT_ARG_STRING,\n\t\t.arg\t\t= &option_input,\n\t\t.descrip\t= \"Decode log from file.\",\n\t\t.argDescrip\t= \"FILENAME\"\n\t},\n\t{\n\t\t.longName\t= \"version\",\n\t\t.argInfo\t= POPT_ARG_NONE,\n\t\t.arg\t\t= &option_version,\n\t\t.descrip\t= \"Specify print version info.\",\n\t},\n\tPOPT_AUTOHELP\n\tPOPT_TABLEEND\n};\n\n \nstatic void\nsigint_handler(int signal_num)\n{\n\tif (run == 1) {\n\t\trun = 0;\n\t\tsignal(SIGINT, SIG_DFL);\n\t}\n}\n\nstatic struct subaction *\nsubaction_create(uint32_t *data, size_t length)\n{\n\tstruct subaction *sa;\n\n\t \n\tsa = malloc(sizeof *sa - sizeof sa->packet + length);\n\tif (!sa)\n\t\texit(EXIT_FAILURE);\n\tsa->ack = data[length / 4 - 1];\n\tsa->length = length;\n\tmemcpy(&sa->packet, data, length);\n\n\treturn sa;\n}\n\nstatic void\nsubaction_destroy(struct subaction *sa)\n{\n\tfree(sa);\n}\n\nstatic struct list pending_transaction_list = {\n\t&pending_transaction_list, &pending_transaction_list\n};\n\nstatic struct link_transaction *\nlink_transaction_lookup(int request_node, int response_node, int tlabel)\n{\n\tstruct link_transaction *t;\n\n\tlist_for_each_entry(t, &pending_transaction_list, link) {\n\t\tif (t->request_node == request_node &&\n\t\t    t->response_node == response_node &&\n\t\t    t->tlabel == tlabel)\n\t\t\treturn t;\n\t}\n\n\tt = malloc(sizeof *t);\n\tif (!t)\n\t\texit(EXIT_FAILURE);\n\tt->request_node = request_node;\n\tt->response_node = response_node;\n\tt->tlabel = tlabel;\n\tlist_init(&t->request_list);\n\tlist_init(&t->response_list);\n\n\tlist_append(&pending_transaction_list, &t->link);\n\n\treturn t;\n}\n\nstatic void\nlink_transaction_destroy(struct link_transaction *t)\n{\n\tstruct subaction *sa;\n\n\twhile (!list_empty(&t->request_list)) {\n\t\tsa = list_head(&t->request_list, struct subaction, link);\n\t\tlist_remove(&sa->link);\n\t\tsubaction_destroy(sa);\n\t}\n\twhile (!list_empty(&t->response_list)) {\n\t\tsa = list_head(&t->response_list, struct subaction, link);\n\t\tlist_remove(&sa->link);\n\t\tsubaction_destroy(sa);\n\t}\n\tfree(t);\n}\n\nstruct protocol_decoder {\n\tconst char *name;\n\tint (*decode)(struct link_transaction *t);\n};\n\nstatic const struct protocol_decoder protocol_decoders[] = {\n\t{ \"FCP\", decode_fcp }\n};\n\nstatic void\nhandle_transaction(struct link_transaction *t)\n{\n\tstruct subaction *sa;\n\tint i;\n\n\tif (!t->request) {\n\t\tprintf(\"BUG in handle_transaction\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < array_length(protocol_decoders); i++)\n\t\tif (protocol_decoders[i].decode(t))\n\t\t\tbreak;\n\n\t \n\treturn;\n\n\tdecode_link_packet(&t->request->packet, t->request->length,\n\t\t\t   PACKET_FIELD_TRANSACTION, 0);\n\tif (t->response)\n\t\tdecode_link_packet(&t->response->packet, t->request->length,\n\t\t\t\t   PACKET_FIELD_TRANSACTION, 0);\n\telse\n\t\tprintf(\"[no response]\");\n\n\tif (option_verbose) {\n\t\tlist_for_each_entry(sa, &t->request_list, link)\n\t\t\tprint_packet((uint32_t *) &sa->packet, sa->length);\n\t\tlist_for_each_entry(sa, &t->response_list, link)\n\t\t\tprint_packet((uint32_t *) &sa->packet, sa->length);\n\t}\n\tprintf(\"\\r\\n\");\n\n\tlink_transaction_destroy(t);\n}\n\nstatic void\nclear_pending_transaction_list(void)\n{\n\tstruct link_transaction *t;\n\n\twhile (!list_empty(&pending_transaction_list)) {\n\t\tt = list_head(&pending_transaction_list,\n\t\t\t      struct link_transaction, link);\n\t\tlist_remove(&t->link);\n\t\tlink_transaction_destroy(t);\n\t\t \n\t}\n}\n\nstatic const char * const tcode_names[] = {\n\t[0x0] = \"write_quadlet_request\",\t[0x6] = \"read_quadlet_response\",\n\t[0x1] = \"write_block_request\",\t\t[0x7] = \"read_block_response\",\n\t[0x2] = \"write_response\",\t\t[0x8] = \"cycle_start\",\n\t[0x3] = \"reserved\",\t\t\t[0x9] = \"lock_request\",\n\t[0x4] = \"read_quadlet_request\",\t\t[0xa] = \"iso_data\",\n\t[0x5] = \"read_block_request\",\t\t[0xb] = \"lock_response\",\n};\n\nstatic const char * const ack_names[] = {\n\t[0x0] = \"no ack\",\t\t\t[0x8] = \"reserved (0x08)\",\n\t[0x1] = \"ack_complete\",\t\t\t[0x9] = \"reserved (0x09)\",\n\t[0x2] = \"ack_pending\",\t\t\t[0xa] = \"reserved (0x0a)\",\n\t[0x3] = \"reserved (0x03)\",\t\t[0xb] = \"reserved (0x0b)\",\n\t[0x4] = \"ack_busy_x\",\t\t\t[0xc] = \"reserved (0x0c)\",\n\t[0x5] = \"ack_busy_a\",\t\t\t[0xd] = \"ack_data_error\",\n\t[0x6] = \"ack_busy_b\",\t\t\t[0xe] = \"ack_type_error\",\n\t[0x7] = \"reserved (0x07)\",\t\t[0xf] = \"reserved (0x0f)\",\n};\n\nstatic const char * const rcode_names[] = {\n\t[0x0] = \"complete\",\t\t\t[0x4] = \"conflict_error\",\n\t[0x1] = \"reserved (0x01)\",\t\t[0x5] = \"data_error\",\n\t[0x2] = \"reserved (0x02)\",\t\t[0x6] = \"type_error\",\n\t[0x3] = \"reserved (0x03)\",\t\t[0x7] = \"address_error\",\n};\n\nstatic const char * const retry_names[] = {\n\t[0x0] = \"retry_1\",\n\t[0x1] = \"retry_x\",\n\t[0x2] = \"retry_a\",\n\t[0x3] = \"retry_b\",\n};\n\nenum {\n\tPACKET_RESERVED,\n\tPACKET_REQUEST,\n\tPACKET_RESPONSE,\n\tPACKET_OTHER,\n};\n\nstruct packet_info {\n\tconst char *name;\n\tint type;\n\tint response_tcode;\n\tconst struct packet_field *fields;\n\tint field_count;\n};\n\nstruct packet_field {\n\tconst char *name;  \n\tint offset;\t \n\t\t\t \n\tint width;\t \n\tint flags;\t \n\tconst char * const *value_names;\n};\n\n#define COMMON_REQUEST_FIELDS\t\t\t\t\t\t\\\n\t{ \"dest\", 0, 16, PACKET_FIELD_TRANSACTION },\t\t\t\\\n\t{ \"tl\", 16, 6 },\t\t\t\t\t\t\\\n\t{ \"rt\", 22, 2, PACKET_FIELD_DETAIL, retry_names },\t\t\\\n\t{ \"tcode\", 24, 4, PACKET_FIELD_TRANSACTION, tcode_names },\t\\\n\t{ \"pri\", 28, 4, PACKET_FIELD_DETAIL },\t\t\t\t\\\n\t{ \"src\", 32, 16, PACKET_FIELD_TRANSACTION },\t\t\t\\\n\t{ \"offs\", 48, 48, PACKET_FIELD_TRANSACTION }\n\n#define COMMON_RESPONSE_FIELDS\t\t\t\t\t\t\\\n\t{ \"dest\", 0, 16 },\t\t\t\t\t\t\\\n\t{ \"tl\", 16, 6 },\t\t\t\t\t\t\\\n\t{ \"rt\", 22, 2, PACKET_FIELD_DETAIL, retry_names },\t\t\\\n\t{ \"tcode\", 24, 4, 0, tcode_names },\t\t\t\t\\\n\t{ \"pri\", 28, 4, PACKET_FIELD_DETAIL },\t\t\t\t\\\n\t{ \"src\", 32, 16 },\t\t\t\t\t\t\\\n\t{ \"rcode\", 48, 4, PACKET_FIELD_TRANSACTION, rcode_names }\n\nstatic const struct packet_field read_quadlet_request_fields[] = {\n\tCOMMON_REQUEST_FIELDS,\n\t{ \"crc\", 96, 32, PACKET_FIELD_DETAIL },\n\t{ \"ack\", 156, 4, 0, ack_names },\n};\n\nstatic const struct packet_field read_quadlet_response_fields[] = {\n\tCOMMON_RESPONSE_FIELDS,\n\t{ \"data\", 96, 32, PACKET_FIELD_TRANSACTION },\n\t{ \"crc\", 128, 32, PACKET_FIELD_DETAIL },\n\t{ \"ack\", 188, 4, 0, ack_names },\n};\n\nstatic const struct packet_field read_block_request_fields[] = {\n\tCOMMON_REQUEST_FIELDS,\n\t{ \"data_length\", 96, 16, PACKET_FIELD_TRANSACTION },\n\t{ \"extended_tcode\", 112, 16 },\n\t{ \"crc\", 128, 32, PACKET_FIELD_DETAIL },\n\t{ \"ack\", 188, 4, 0, ack_names },\n};\n\nstatic const struct packet_field block_response_fields[] = {\n\tCOMMON_RESPONSE_FIELDS,\n\t{ \"data_length\", 96, 16, PACKET_FIELD_DATA_LENGTH },\n\t{ \"extended_tcode\", 112, 16 },\n\t{ \"crc\", 128, 32, PACKET_FIELD_DETAIL },\n\t{ \"data\", 160, 0, PACKET_FIELD_TRANSACTION },\n\t{ \"crc\", -64, 32, PACKET_FIELD_DETAIL },\n\t{ \"ack\", -4, 4, 0, ack_names },\n};\n\nstatic const struct packet_field write_quadlet_request_fields[] = {\n\tCOMMON_REQUEST_FIELDS,\n\t{ \"data\", 96, 32, PACKET_FIELD_TRANSACTION },\n\t{ \"ack\", -4, 4, 0, ack_names },\n};\n\nstatic const struct packet_field block_request_fields[] = {\n\tCOMMON_REQUEST_FIELDS,\n\t{ \"data_length\", 96, 16, PACKET_FIELD_DATA_LENGTH | PACKET_FIELD_TRANSACTION },\n\t{ \"extended_tcode\", 112, 16, PACKET_FIELD_TRANSACTION },\n\t{ \"crc\", 128, 32, PACKET_FIELD_DETAIL },\n\t{ \"data\", 160, 0, PACKET_FIELD_TRANSACTION },\n\t{ \"crc\", -64, 32, PACKET_FIELD_DETAIL },\n\t{ \"ack\", -4, 4, 0, ack_names },\n};\n\nstatic const struct packet_field write_response_fields[] = {\n\tCOMMON_RESPONSE_FIELDS,\n\t{ \"reserved\", 64, 32, PACKET_FIELD_DETAIL },\n\t{ \"ack\", -4, 4, 0, ack_names },\n};\n\nstatic const struct packet_field iso_data_fields[] = {\n\t{ \"data_length\", 0, 16, PACKET_FIELD_DATA_LENGTH },\n\t{ \"tag\", 16, 2 },\n\t{ \"channel\", 18, 6 },\n\t{ \"tcode\", 24, 4, 0, tcode_names },\n\t{ \"sy\", 28, 4 },\n\t{ \"crc\", 32, 32, PACKET_FIELD_DETAIL },\n\t{ \"data\", 64, 0 },\n\t{ \"crc\", -64, 32, PACKET_FIELD_DETAIL },\n\t{ \"ack\", -4, 4, 0, ack_names },\n};\n\nstatic const struct packet_info packet_info[] = {\n\t{\n\t\t.name\t\t= \"write_quadlet_request\",\n\t\t.type\t\t= PACKET_REQUEST,\n\t\t.response_tcode\t= TCODE_WRITE_RESPONSE,\n\t\t.fields\t\t= write_quadlet_request_fields,\n\t\t.field_count\t= array_length(write_quadlet_request_fields)\n\t},\n\t{\n\t\t.name\t\t= \"write_block_request\",\n\t\t.type\t\t= PACKET_REQUEST,\n\t\t.response_tcode\t= TCODE_WRITE_RESPONSE,\n\t\t.fields\t\t= block_request_fields,\n\t\t.field_count\t= array_length(block_request_fields)\n\t},\n\t{\n\t\t.name\t\t= \"write_response\",\n\t\t.type\t\t= PACKET_RESPONSE,\n\t\t.fields\t\t= write_response_fields,\n\t\t.field_count\t= array_length(write_response_fields)\n\t},\n\t{\n\t\t.name\t\t= \"reserved\",\n\t\t.type\t\t= PACKET_RESERVED,\n\t},\n\t{\n\t\t.name\t\t= \"read_quadlet_request\",\n\t\t.type\t\t= PACKET_REQUEST,\n\t\t.response_tcode\t= TCODE_READ_QUADLET_RESPONSE,\n\t\t.fields\t\t= read_quadlet_request_fields,\n\t\t.field_count\t= array_length(read_quadlet_request_fields)\n\t},\n\t{\n\t\t.name\t\t= \"read_block_request\",\n\t\t.type\t\t= PACKET_REQUEST,\n\t\t.response_tcode\t= TCODE_READ_BLOCK_RESPONSE,\n\t\t.fields\t\t= read_block_request_fields,\n\t\t.field_count\t= array_length(read_block_request_fields)\n\t},\n\t{\n\t\t.name\t\t= \"read_quadlet_response\",\n\t\t.type\t\t= PACKET_RESPONSE,\n\t\t.fields\t\t= read_quadlet_response_fields,\n\t\t.field_count\t= array_length(read_quadlet_response_fields)\n\t},\n\t{\n\t\t.name\t\t= \"read_block_response\",\n\t\t.type\t\t= PACKET_RESPONSE,\n\t\t.fields\t\t= block_response_fields,\n\t\t.field_count\t= array_length(block_response_fields)\n\t},\n\t{\n\t\t.name\t\t= \"cycle_start\",\n\t\t.type\t\t= PACKET_OTHER,\n\t\t.fields\t\t= write_quadlet_request_fields,\n\t\t.field_count\t= array_length(write_quadlet_request_fields)\n\t},\n\t{\n\t\t.name\t\t= \"lock_request\",\n\t\t.type\t\t= PACKET_REQUEST,\n\t\t.fields\t\t= block_request_fields,\n\t\t.field_count\t= array_length(block_request_fields)\n\t},\n\t{\n\t\t.name\t\t= \"iso_data\",\n\t\t.type\t\t= PACKET_OTHER,\n\t\t.fields\t\t= iso_data_fields,\n\t\t.field_count\t= array_length(iso_data_fields)\n\t},\n\t{\n\t\t.name\t\t= \"lock_response\",\n\t\t.type\t\t= PACKET_RESPONSE,\n\t\t.fields\t\t= block_response_fields,\n\t\t.field_count\t= array_length(block_response_fields)\n\t},\n};\n\nstatic int\nhandle_request_packet(uint32_t *data, size_t length)\n{\n\tstruct link_packet *p = (struct link_packet *) data;\n\tstruct subaction *sa, *prev;\n\tstruct link_transaction *t;\n\n\tt = link_transaction_lookup(p->common.source, p->common.destination,\n\t\t\tp->common.tlabel);\n\tsa = subaction_create(data, length);\n\tt->request = sa;\n\n\tif (!list_empty(&t->request_list)) {\n\t\tprev = list_tail(&t->request_list,\n\t\t\t\t struct subaction, link);\n\n\t\tif (!ACK_BUSY(prev->ack)) {\n\t\t\t \n\t\t}\n\n\t\tif (prev->packet.common.tcode != sa->packet.common.tcode ||\n\t\t    prev->packet.common.tlabel != sa->packet.common.tlabel) {\n\t\t\t \n\t\t\t \n\t\t}\n\t}\n\n\tlist_append(&t->request_list, &sa->link);\n\n\tswitch (sa->ack) {\n\tcase ACK_COMPLETE:\n\t\tif (p->common.tcode != TCODE_WRITE_QUADLET_REQUEST &&\n\t\t    p->common.tcode != TCODE_WRITE_BLOCK_REQUEST)\n\t\t\t ;\n\t\tlist_remove(&t->link);\n\t\thandle_transaction(t);\n\t\tbreak;\n\n\tcase ACK_NO_ACK:\n\tcase ACK_DATA_ERROR:\n\tcase ACK_TYPE_ERROR:\n\t\tlist_remove(&t->link);\n\t\thandle_transaction(t);\n\t\tbreak;\n\n\tcase ACK_PENDING:\n\t\t \n\t\tbreak;\n\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\n\t\t \n\t\t \n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nhandle_response_packet(uint32_t *data, size_t length)\n{\n\tstruct link_packet *p = (struct link_packet *) data;\n\tstruct subaction *sa, *prev;\n\tstruct link_transaction *t;\n\n\tt = link_transaction_lookup(p->common.destination, p->common.source,\n\t\t\tp->common.tlabel);\n\tif (list_empty(&t->request_list)) {\n\t\t \n\t}\n\n\tsa = subaction_create(data, length);\n\tt->response = sa;\n\n\tif (!list_empty(&t->response_list)) {\n\t\tprev = list_tail(&t->response_list, struct subaction, link);\n\n\t\tif (!ACK_BUSY(prev->ack)) {\n\t\t\t \n\t\t}\n\n\t\tif (prev->packet.common.tcode != sa->packet.common.tcode ||\n\t\t    prev->packet.common.tlabel != sa->packet.common.tlabel) {\n\t\t\t \n\t\t\t \n\t\t}\n\t} else {\n\t\tprev = list_tail(&t->request_list, struct subaction, link);\n\t\tif (prev->ack != ACK_PENDING) {\n\t\t\t \n\t\t}\n\n\t\tif (packet_info[prev->packet.common.tcode].response_tcode !=\n\t\t    sa->packet.common.tcode) {\n\t\t\t \n\t\t}\n\t}\n\n\tlist_append(&t->response_list, &sa->link);\n\n\tswitch (sa->ack) {\n\tcase ACK_COMPLETE:\n\tcase ACK_NO_ACK:\n\tcase ACK_DATA_ERROR:\n\tcase ACK_TYPE_ERROR:\n\t\tlist_remove(&t->link);\n\t\thandle_transaction(t);\n\t\t \n\t\tbreak;\n\n\tcase ACK_PENDING:\n\t\t \n\t\tbreak;\n\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nhandle_packet(uint32_t *data, size_t length)\n{\n\tif (length == 0) {\n\t\tprintf(\"bus reset\\r\\n\");\n\t\tclear_pending_transaction_list();\n\t} else if (length > sizeof(struct phy_packet)) {\n\t\tstruct link_packet *p = (struct link_packet *) data;\n\n\t\tswitch (packet_info[p->common.tcode].type) {\n\t\tcase PACKET_REQUEST:\n\t\t\treturn handle_request_packet(data, length);\n\n\t\tcase PACKET_RESPONSE:\n\t\t\treturn handle_response_packet(data, length);\n\n\t\tcase PACKET_OTHER:\n\t\tcase PACKET_RESERVED:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic unsigned int\nget_bits(struct link_packet *packet, int offset, int width)\n{\n\tuint32_t *data = (uint32_t *) packet;\n\tuint32_t index, shift, mask;\n\n\tindex = offset / 32 + 1;\n\tshift = 32 - (offset & 31) - width;\n\tmask = width == 32 ? ~0 : (1 << width) - 1;\n\n\treturn (data[index] >> shift) & mask;\n}\n\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n#define byte_index(i) ((i) ^ 3)\n#elif __BYTE_ORDER == __BIG_ENDIAN\n#define byte_index(i) (i)\n#else\n#error unsupported byte order.\n#endif\n\nstatic void\ndump_data(unsigned char *data, int length)\n{\n\tint i, print_length;\n\n\tif (length > 128)\n\t\tprint_length = 128;\n\telse\n\t\tprint_length = length;\n\n\tfor (i = 0; i < print_length; i++)\n\t\tprintf(\"%s%02hhx\",\n\t\t       (i % 4 == 0 && i != 0) ? \" \" : \"\",\n\t\t       data[byte_index(i)]);\n\n\tif (print_length < length)\n\t\tprintf(\" (%d more bytes)\", length - print_length);\n}\n\nstatic void\ndecode_link_packet(struct link_packet *packet, size_t length,\n\t\t   int include_flags, int exclude_flags)\n{\n\tconst struct packet_info *pi;\n\tint data_length = 0;\n\tint i;\n\n\tpi = &packet_info[packet->common.tcode];\n\n\tfor (i = 0; i < pi->field_count; i++) {\n\t\tconst struct packet_field *f = &pi->fields[i];\n\t\tint offset;\n\n\t\tif (f->flags & exclude_flags)\n\t\t\tcontinue;\n\t\tif (include_flags && !(f->flags & include_flags))\n\t\t\tcontinue;\n\n\t\tif (f->offset < 0)\n\t\t\toffset = length * 8 + f->offset - 32;\n\t\telse\n\t\t\toffset = f->offset;\n\n\t\tif (f->value_names != NULL) {\n\t\t\tuint32_t bits;\n\n\t\t\tbits = get_bits(packet, offset, f->width);\n\t\t\tprintf(\"%s\", f->value_names[bits]);\n\t\t} else if (f->width == 0) {\n\t\t\tprintf(\"%s=[\", f->name);\n\t\t\tdump_data((unsigned char *) packet + (offset / 8 + 4), data_length);\n\t\t\tprintf(\"]\");\n\t\t} else {\n\t\t\tunsigned long long bits;\n\t\t\tint high_width, low_width;\n\n\t\t\tif ((offset & ~31) != ((offset + f->width - 1) & ~31)) {\n\t\t\t\t \n\t\t\t\thigh_width = ((offset + 31) & ~31) - offset;\n\t\t\t\tlow_width = f->width - high_width;\n\n\t\t\t\tbits = get_bits(packet, offset, high_width);\n\t\t\t\tbits = (bits << low_width) |\n\t\t\t\t\tget_bits(packet, offset + high_width, low_width);\n\t\t\t} else {\n\t\t\t\tbits = get_bits(packet, offset, f->width);\n\t\t\t}\n\n\t\t\tprintf(\"%s=0x%0*llx\", f->name, (f->width + 3) / 4, bits);\n\n\t\t\tif (f->flags & PACKET_FIELD_DATA_LENGTH)\n\t\t\t\tdata_length = bits;\n\t\t}\n\n\t\tif (i < pi->field_count - 1)\n\t\t\tprintf(\", \");\n\t}\n}\n\nstatic void\nprint_packet(uint32_t *data, size_t length)\n{\n\tint i;\n\n\tprintf(\"%6u  \", data[0]);\n\n\tif (length == 4) {\n\t\tprintf(\"bus reset\");\n\t} else if (length < sizeof(struct phy_packet)) {\n\t\tprintf(\"short packet: \");\n\t\tfor (i = 1; i < length / 4; i++)\n\t\t\tprintf(\"%s%08x\", i == 0 ? \"[\" : \" \", data[i]);\n\t\tprintf(\"]\");\n\n\t} else if (length == sizeof(struct phy_packet) && data[1] == ~data[2]) {\n\t\tstruct phy_packet *pp = (struct phy_packet *) data;\n\n\t\t \n\n\t\tswitch (pp->common.identifier) {\n\t\tcase PHY_PACKET_CONFIGURATION:\n\t\t\tif (!pp->phy_config.set_root && !pp->phy_config.set_gap_count) {\n\t\t\t\tprintf(\"ext phy config: phy_id=%02x\", pp->phy_config.root_id);\n\t\t\t} else {\n\t\t\t\tprintf(\"phy config:\");\n\t\t\t\tif (pp->phy_config.set_root)\n\t\t\t\t\tprintf(\" set_root_id=%02x\", pp->phy_config.root_id);\n\t\t\t\tif (pp->phy_config.set_gap_count)\n\t\t\t\t\tprintf(\" set_gap_count=%d\", pp->phy_config.gap_count);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PHY_PACKET_LINK_ON:\n\t\t\tprintf(\"link-on packet, phy_id=%02x\", pp->link_on.phy_id);\n\t\t\tbreak;\n\n\t\tcase PHY_PACKET_SELF_ID:\n\t\t\tif (pp->self_id.extended) {\n\t\t\t\tprintf(\"extended self id: phy_id=%02x, seq=%d\",\n\t\t\t\t       pp->ext_self_id.phy_id, pp->ext_self_id.sequence);\n\t\t\t} else {\n\t\t\t\tstatic const char * const speed_names[] = {\n\t\t\t\t\t\"S100\", \"S200\", \"S400\", \"BETA\"\n\t\t\t\t};\n\t\t\t\tprintf(\"self id: phy_id=%02x, link %s, gap_count=%d, speed=%s%s%s\",\n\t\t\t\t       pp->self_id.phy_id,\n\t\t\t\t       (pp->self_id.link_active ? \"active\" : \"not active\"),\n\t\t\t\t       pp->self_id.gap_count,\n\t\t\t\t       speed_names[pp->self_id.phy_speed],\n\t\t\t\t       (pp->self_id.contender ? \", irm contender\" : \"\"),\n\t\t\t\t       (pp->self_id.initiated_reset ? \", initiator\" : \"\"));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"unknown phy packet: \");\n\t\t\tfor (i = 1; i < length / 4; i++)\n\t\t\t\tprintf(\"%s%08x\", i == 0 ? \"[\" : \" \", data[i]);\n\t\t\tprintf(\"]\");\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tstruct link_packet *packet = (struct link_packet *) data;\n\n\t\tdecode_link_packet(packet, length, 0,\n\t\t\t\t   option_verbose ? 0 : PACKET_FIELD_DETAIL);\n\t}\n\n\tif (option_hex) {\n\t\tprintf(\"  [\");\n\t\tdump_data((unsigned char *) data + 4, length - 4);\n\t\tprintf(\"]\");\n\t}\n\n\tprintf(\"\\r\\n\");\n}\n\n#define HIDE_CURSOR\t\"\\033[?25l\"\n#define SHOW_CURSOR\t\"\\033[?25h\"\n#define CLEAR\t\t\"\\033[H\\033[2J\"\n\nstatic void\nprint_stats(uint32_t *data, size_t length)\n{\n\tstatic int bus_reset_count, short_packet_count, phy_packet_count;\n\tstatic int tcode_count[16];\n\tstatic struct timeval last_update;\n\tstruct timeval now;\n\tint i;\n\n\tif (length == 0)\n\t\tbus_reset_count++;\n\telse if (length < sizeof(struct phy_packet))\n\t\tshort_packet_count++;\n\telse if (length == sizeof(struct phy_packet) && data[1] == ~data[2])\n\t\tphy_packet_count++;\n\telse {\n\t\tstruct link_packet *packet = (struct link_packet *) data;\n\t\ttcode_count[packet->common.tcode]++;\n\t}\n\n\tgettimeofday(&now, NULL);\n\tif (now.tv_sec <= last_update.tv_sec &&\n\t    now.tv_usec < last_update.tv_usec + 500000)\n\t\treturn;\n\n\tlast_update = now;\n\tprintf(CLEAR HIDE_CURSOR\n\t       \"  bus resets              : %8d\\n\"\n\t       \"  short packets           : %8d\\n\"\n\t       \"  phy packets             : %8d\\n\",\n\t       bus_reset_count, short_packet_count, phy_packet_count);\n\n\tfor (i = 0; i < array_length(packet_info); i++)\n\t\tif (packet_info[i].type != PACKET_RESERVED)\n\t\t\tprintf(\"  %-24s: %8d\\n\", packet_info[i].name, tcode_count[i]);\n\tprintf(SHOW_CURSOR \"\\n\");\n}\n\nstatic struct termios saved_attributes;\n\nstatic void\nreset_input_mode(void)\n{\n\ttcsetattr(STDIN_FILENO, TCSANOW, &saved_attributes);\n}\n\nstatic void\nset_input_mode(void)\n{\n\tstruct termios tattr;\n\n\t \n\tif (!isatty(STDIN_FILENO)) {\n\t\tfprintf(stderr, \"Not a terminal.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\ttcgetattr(STDIN_FILENO, &saved_attributes);\n\tatexit(reset_input_mode);\n\n\t \n\ttcgetattr(STDIN_FILENO, &tattr);\n\ttattr.c_lflag &= ~(ICANON|ECHO);  \n\ttattr.c_cc[VMIN] = 1;\n\ttattr.c_cc[VTIME] = 0;\n\ttcsetattr(STDIN_FILENO, TCSAFLUSH, &tattr);\n}\n\nint main(int argc, const char *argv[])\n{\n\tuint32_t buf[128 * 1024];\n\tuint32_t filter;\n\tint length, retval, view;\n\tint fd = -1;\n\tFILE *output = NULL, *input = NULL;\n\tpoptContext con;\n\tchar c;\n\tstruct pollfd pollfds[2];\n\n\tsys_sigint_handler = signal(SIGINT, sigint_handler);\n\n\tcon = poptGetContext(NULL, argc, argv, options, 0);\n\tretval = poptGetNextOpt(con);\n\tif (retval < -1) {\n\t\tpoptPrintUsage(con, stdout, 0);\n\t\treturn -1;\n\t}\n\n\tif (option_version) {\n\t\tprintf(\"dump tool for nosy sniffer, version %s\\n\", VERSION);\n\t\treturn 0;\n\t}\n\n\tif (__BYTE_ORDER != __LITTLE_ENDIAN)\n\t\tfprintf(stderr, \"warning: nosy has only been tested on little \"\n\t\t\t\"endian machines\\n\");\n\n\tif (option_input != NULL) {\n\t\tinput = fopen(option_input, \"r\");\n\t\tif (input == NULL) {\n\t\t\tfprintf(stderr, \"Could not open %s, %m\\n\", option_input);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tfd = open(option_nosy_device, O_RDWR);\n\t\tif (fd < 0) {\n\t\t\tfprintf(stderr, \"Could not open %s, %m\\n\", option_nosy_device);\n\t\t\treturn -1;\n\t\t}\n\t\tset_input_mode();\n\t}\n\n\tif (strcmp(option_view, \"transaction\") == 0)\n\t\tview = VIEW_TRANSACTION;\n\telse if (strcmp(option_view, \"stats\") == 0)\n\t\tview = VIEW_STATS;\n\telse\n\t\tview = VIEW_PACKET;\n\n\tif (option_output) {\n\t\toutput = fopen(option_output, \"w\");\n\t\tif (output == NULL) {\n\t\t\tfprintf(stderr, \"Could not open %s, %m\\n\", option_output);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tsetvbuf(stdout, NULL, _IOLBF, BUFSIZ);\n\n\tfilter = ~0;\n\tif (!option_iso)\n\t\tfilter &= ~(1 << TCODE_STREAM_DATA);\n\tif (!option_cycle_start)\n\t\tfilter &= ~(1 << TCODE_CYCLE_START);\n\tif (view == VIEW_STATS)\n\t\tfilter = ~(1 << TCODE_CYCLE_START);\n\n\tioctl(fd, NOSY_IOC_FILTER, filter);\n\n\tioctl(fd, NOSY_IOC_START);\n\n\tpollfds[0].fd = fd;\n\tpollfds[0].events = POLLIN;\n\tpollfds[1].fd = STDIN_FILENO;\n\tpollfds[1].events = POLLIN;\n\n\twhile (run) {\n\t\tif (input != NULL) {\n\t\t\tif (fread(&length, sizeof length, 1, input) != 1)\n\t\t\t\treturn 0;\n\t\t\tfread(buf, 1, length, input);\n\t\t} else {\n\t\t\tpoll(pollfds, 2, -1);\n\t\t\tif (pollfds[1].revents) {\n\t\t\t\tread(STDIN_FILENO, &c, sizeof c);\n\t\t\t\tswitch (c) {\n\t\t\t\tcase 'q':\n\t\t\t\t\tif (output != NULL)\n\t\t\t\t\t\tfclose(output);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pollfds[0].revents)\n\t\t\t\tlength = read(fd, buf, sizeof buf);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (output != NULL) {\n\t\t\tfwrite(&length, sizeof length, 1, output);\n\t\t\tfwrite(buf, 1, length, output);\n\t\t}\n\n\t\tswitch (view) {\n\t\tcase VIEW_TRANSACTION:\n\t\t\thandle_packet(buf, length);\n\t\t\tbreak;\n\t\tcase VIEW_PACKET:\n\t\t\tprint_packet(buf, length);\n\t\t\tbreak;\n\t\tcase VIEW_STATS:\n\t\t\tprint_stats(buf, length);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (output != NULL)\n\t\tfclose(output);\n\n\tclose(fd);\n\n\tpoptFreeContext(con);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}