{
  "module_name": "decode-fcp.c",
  "hash_id": "962012a0a1d252124685ed07dd485fb13fda581189830c0dbaaca0579ba74733",
  "original_prompt": "Ingested from linux-6.6.14/tools/firewire/decode-fcp.c",
  "human_readable_source": "\n#include <linux/firewire-constants.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"list.h\"\n#include \"nosy-dump.h\"\n\n#define CSR_FCP_COMMAND\t\t\t0xfffff0000b00ull\n#define CSR_FCP_RESPONSE\t\t0xfffff0000d00ull\n\nstatic const char * const ctype_names[] = {\n\t[0x0] = \"control\",\t\t[0x8] = \"not implemented\",\n\t[0x1] = \"status\",\t\t[0x9] = \"accepted\",\n\t[0x2] = \"specific inquiry\",\t[0xa] = \"rejected\",\n\t[0x3] = \"notify\",\t\t[0xb] = \"in transition\",\n\t[0x4] = \"general inquiry\",\t[0xc] = \"stable\",\n\t[0x5] = \"(reserved 0x05)\",\t[0xd] = \"changed\",\n\t[0x6] = \"(reserved 0x06)\",\t[0xe] = \"(reserved 0x0e)\",\n\t[0x7] = \"(reserved 0x07)\",\t[0xf] = \"interim\",\n};\n\nstatic const char * const subunit_type_names[] = {\n\t[0x00] = \"monitor\",\t\t[0x10] = \"(reserved 0x10)\",\n\t[0x01] = \"audio\",\t\t[0x11] = \"(reserved 0x11)\",\n\t[0x02] = \"printer\",\t\t[0x12] = \"(reserved 0x12)\",\n\t[0x03] = \"disc\",\t\t[0x13] = \"(reserved 0x13)\",\n\t[0x04] = \"tape recorder/player\",[0x14] = \"(reserved 0x14)\",\n\t[0x05] = \"tuner\",\t\t[0x15] = \"(reserved 0x15)\",\n\t[0x06] = \"ca\",\t\t\t[0x16] = \"(reserved 0x16)\",\n\t[0x07] = \"camera\",\t\t[0x17] = \"(reserved 0x17)\",\n\t[0x08] = \"(reserved 0x08)\",\t[0x18] = \"(reserved 0x18)\",\n\t[0x09] = \"panel\",\t\t[0x19] = \"(reserved 0x19)\",\n\t[0x0a] = \"bulletin board\",\t[0x1a] = \"(reserved 0x1a)\",\n\t[0x0b] = \"camera storage\",\t[0x1b] = \"(reserved 0x1b)\",\n\t[0x0c] = \"(reserved 0x0c)\",\t[0x1c] = \"vendor unique\",\n\t[0x0d] = \"(reserved 0x0d)\",\t[0x1d] = \"all subunit types\",\n\t[0x0e] = \"(reserved 0x0e)\",\t[0x1e] = \"subunit_type extended to next byte\",\n\t[0x0f] = \"(reserved 0x0f)\",\t[0x1f] = \"unit\",\n};\n\nstruct avc_enum {\n\tint value;\n\tconst char *name;\n};\n\nstruct avc_field {\n\tconst char *name;\t \n\tint offset;\t\t \n\t\t\t\t \n\tint width;\t\t \n\tstruct avc_enum *names;\n};\n\nstruct avc_opcode_info {\n\tconst char *name;\n\tstruct avc_field fields[8];\n};\n\nstruct avc_enum power_field_names[] = {\n\t{ 0x70, \"on\" },\n\t{ 0x60, \"off\" },\n\t{ }\n};\n\nstatic const struct avc_opcode_info opcode_info[256] = {\n\n\t \n\t \n\t[0xb2] = { \"power\", {\n\t\t\t{ \"state\", 0, 8, power_field_names }\n\t\t}\n\t},\n\t[0x30] = { \"unit info\", {\n\t\t\t{ \"foo\", 0, 8 },\n\t\t\t{ \"unit_type\", 8, 5 },\n\t\t\t{ \"unit\", 13, 3 },\n\t\t\t{ \"company id\", 16, 24 },\n\t\t}\n\t},\n\t[0x31] = { \"subunit info\" },\n\t[0x01] = { \"reserve\" },\n\t[0xb0] = { \"version\" },\n\t[0x00] = { \"vendor dependent\" },\n\t[0x02] = { \"plug info\" },\n\t[0x12] = { \"channel usage\" },\n\t[0x24] = { \"connect\" },\n\t[0x20] = { \"connect av\" },\n\t[0x22] = { \"connections\" },\n\t[0x11] = { \"digital input\" },\n\t[0x10] = { \"digital output\" },\n\t[0x25] = { \"disconnect\" },\n\t[0x21] = { \"disconnect av\" },\n\t[0x19] = { \"input plug signal format\" },\n\t[0x18] = { \"output plug signal format\" },\n\t[0x1f] = { \"general bus setup\" },\n\n\t \n\t \n\t[0x0c] = { \"create descriptor\" },\n\t[0x08] = { \"open descriptor\" },\n\t[0x09] = { \"read descriptor\" },\n\t[0x0a] = { \"write descriptor\" },\n\t[0x05] = { \"open info block\" },\n\t[0x06] = { \"read info block\" },\n\t[0x07] = { \"write info block\" },\n\t[0x0b] = { \"search descriptor\" },\n\t[0x0d] = { \"object number select\" },\n\n\t \n\t \n\t[0xb3] = { \"rate\", {\n\t\t\t{ \"subfunction\", 0, 8 },\n\t\t\t{ \"result\", 8, 8 },\n\t\t\t{ \"plug_type\", 16, 8 },\n\t\t\t{ \"plug_id\", 16, 8 },\n\t\t}\n\t},\n\n\t \n\t \n\t[0xb8] = { \"function block\" },\n\n\t \n\t \n\t[0x7d] = { \"gui update\" },\n\t[0x7e] = { \"push gui data\" },\n\t[0x7f] = { \"user action\" },\n\t[0x7c] = { \"pass through\" },\n\n\t \n\t[0x26] = { \"asynchronous connection\" },\n};\n\nstruct avc_frame {\n\tuint32_t operand0:8;\n\tuint32_t opcode:8;\n\tuint32_t subunit_id:3;\n\tuint32_t subunit_type:5;\n\tuint32_t ctype:4;\n\tuint32_t cts:4;\n};\n\nstatic void\ndecode_avc(struct link_transaction *t)\n{\n\tstruct avc_frame *frame =\n\t    (struct avc_frame *) t->request->packet.write_block.data;\n\tconst struct avc_opcode_info *info;\n\tconst char *name;\n\tchar buffer[32];\n\tint i;\n\n\tinfo = &opcode_info[frame->opcode];\n\tif (info->name == NULL) {\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"(unknown opcode 0x%02x)\", frame->opcode);\n\t\tname = buffer;\n\t} else {\n\t\tname = info->name;\n\t}\n\n\tprintf(\"av/c %s, subunit_type=%s, subunit_id=%d, opcode=%s\",\n\t    ctype_names[frame->ctype], subunit_type_names[frame->subunit_type],\n\t    frame->subunit_id, name);\n\n\tfor (i = 0; info->fields[i].name != NULL; i++)\n\t\tprintf(\", %s\", info->fields[i].name);\n\n\tprintf(\"\\n\");\n}\n\nint\ndecode_fcp(struct link_transaction *t)\n{\n\tstruct avc_frame *frame =\n\t    (struct avc_frame *) t->request->packet.write_block.data;\n\tunsigned long long offset =\n\t    ((unsigned long long) t->request->packet.common.offset_high << 32) |\n\t    t->request->packet.common.offset_low;\n\n\tif (t->request->packet.common.tcode != TCODE_WRITE_BLOCK_REQUEST)\n\t\treturn 0;\n\n\tif (offset == CSR_FCP_COMMAND || offset == CSR_FCP_RESPONSE) {\n\t\tswitch (frame->cts) {\n\t\tcase 0x00:\n\t\t\tdecode_avc(t);\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tprintf(\"cal fcp frame (cts=0x01)\\n\");\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tprintf(\"ehs fcp frame (cts=0x02)\\n\");\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tprintf(\"havi fcp frame (cts=0x03)\\n\");\n\t\t\tbreak;\n\t\tcase 0x0e:\n\t\t\tprintf(\"vendor specific fcp frame (cts=0x0e)\\n\");\n\t\t\tbreak;\n\t\tcase 0x0f:\n\t\t\tprintf(\"extended cts\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"reserved fcp frame (ctx=0x%02x)\\n\", frame->cts);\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}