{
  "module_name": "wq_dump.py",
  "hash_id": "8fffa629b7ae5db5a1a1ec86222805d4e301412bec25d0715a3f796ec579998a",
  "original_prompt": "Ingested from linux-6.6.14/tools/workqueue/wq_dump.py",
  "human_readable_source": "#!/usr/bin/env drgn\n#\n# Copyright (C) 2023 Tejun Heo <tj@kernel.org>\n# Copyright (C) 2023 Meta Platforms, Inc. and affiliates.\n\ndesc = \"\"\"\nThis is a drgn script to show the current workqueue configuration. For more\ninfo on drgn, visit https://github.com/osandov/drgn.\n\nAffinity Scopes\n===============\n\nShows the CPUs that can be used for unbound workqueues and how they will be\ngrouped by each available affinity type. For each type:\n\n  nr_pods   number of CPU pods in the affinity type\n  pod_cpus  CPUs in each pod\n  pod_node  NUMA node for memory allocation for each pod\n  cpu_pod   pod that each CPU is associated to\n\nWorker Pools\n============\n\nLists all worker pools indexed by their ID. For each pool:\n\n  ref       number of pool_workqueue's associated with this pool\n  nice      nice value of the worker threads in the pool\n  idle      number of idle workers\n  workers   number of all workers\n  cpu       CPU the pool is associated with (per-cpu pool)\n  cpus      CPUs the workers in the pool can run on (unbound pool)\n\nWorkqueue CPU -> pool\n=====================\n\nLists all workqueues along with their type and worker pool association. For\neach workqueue:\n\n  NAME TYPE[,FLAGS] POOL_ID...\n\n  NAME      name of the workqueue\n  TYPE      percpu, unbound or ordered\n  FLAGS     S: strict affinity scope\n  POOL_ID   worker pool ID associated with each possible CPU\n\"\"\"\n\nimport sys\n\nimport drgn\nfrom drgn.helpers.linux.list import list_for_each_entry,list_empty\nfrom drgn.helpers.linux.percpu import per_cpu_ptr\nfrom drgn.helpers.linux.cpumask import for_each_cpu,for_each_possible_cpu\nfrom drgn.helpers.linux.idr import idr_for_each\n\nimport argparse\nparser = argparse.ArgumentParser(description=desc,\n                                 formatter_class=argparse.RawTextHelpFormatter)\nargs = parser.parse_args()\n\ndef err(s):\n    print(s, file=sys.stderr, flush=True)\n    sys.exit(1)\n\ndef cpumask_str(cpumask):\n    output = \"\"\n    base = 0\n    v = 0\n    for cpu in for_each_cpu(cpumask[0]):\n        while cpu - base >= 32:\n            output += f'{hex(v)} '\n            base += 32\n            v = 0\n        v |= 1 << (cpu - base)\n    if v > 0:\n        output += f'{v:08x}'\n    return output.strip()\n\nworker_pool_idr         = prog['worker_pool_idr']\nworkqueues              = prog['workqueues']\nwq_unbound_cpumask      = prog['wq_unbound_cpumask']\nwq_pod_types            = prog['wq_pod_types']\nwq_affn_dfl             = prog['wq_affn_dfl']\nwq_affn_names           = prog['wq_affn_names']\n\nWQ_UNBOUND              = prog['WQ_UNBOUND']\nWQ_ORDERED              = prog['__WQ_ORDERED']\nWQ_MEM_RECLAIM          = prog['WQ_MEM_RECLAIM']\n\nWQ_AFFN_CPU             = prog['WQ_AFFN_CPU']\nWQ_AFFN_SMT             = prog['WQ_AFFN_SMT']\nWQ_AFFN_CACHE           = prog['WQ_AFFN_CACHE']\nWQ_AFFN_NUMA            = prog['WQ_AFFN_NUMA']\nWQ_AFFN_SYSTEM          = prog['WQ_AFFN_SYSTEM']\n\nprint('Affinity Scopes')\nprint('===============')\n\nprint(f'wq_unbound_cpumask={cpumask_str(wq_unbound_cpumask)}')\n\ndef print_pod_type(pt):\n    print(f'  nr_pods  {pt.nr_pods.value_()}')\n\n    print('  pod_cpus', end='')\n    for pod in range(pt.nr_pods):\n        print(f' [{pod}]={cpumask_str(pt.pod_cpus[pod])}', end='')\n    print('')\n\n    print('  pod_node', end='')\n    for pod in range(pt.nr_pods):\n        print(f' [{pod}]={pt.pod_node[pod].value_()}', end='')\n    print('')\n\n    print(f'  cpu_pod ', end='')\n    for cpu in for_each_possible_cpu(prog):\n        print(f' [{cpu}]={pt.cpu_pod[cpu].value_()}', end='')\n    print('')\n\nfor affn in [WQ_AFFN_CPU, WQ_AFFN_SMT, WQ_AFFN_CACHE, WQ_AFFN_NUMA, WQ_AFFN_SYSTEM]:\n    print('')\n    print(f'{wq_affn_names[affn].string_().decode().upper()}{\" (default)\" if affn == wq_affn_dfl else \"\"}')\n    print_pod_type(wq_pod_types[affn])\n\nprint('')\nprint('Worker Pools')\nprint('============')\n\nmax_pool_id_len = 0\nmax_ref_len = 0\nfor pi, pool in idr_for_each(worker_pool_idr):\n    pool = drgn.Object(prog, 'struct worker_pool', address=pool)\n    max_pool_id_len = max(max_pool_id_len, len(f'{pi}'))\n    max_ref_len = max(max_ref_len, len(f'{pool.refcnt.value_()}'))\n\nfor pi, pool in idr_for_each(worker_pool_idr):\n    pool = drgn.Object(prog, 'struct worker_pool', address=pool)\n    print(f'pool[{pi:0{max_pool_id_len}}] ref={pool.refcnt.value_():{max_ref_len}} nice={pool.attrs.nice.value_():3} ', end='')\n    print(f'idle/workers={pool.nr_idle.value_():3}/{pool.nr_workers.value_():3} ', end='')\n    if pool.cpu >= 0:\n        print(f'cpu={pool.cpu.value_():3}', end='')\n    else:\n        print(f'cpus={cpumask_str(pool.attrs.cpumask)}', end='')\n        print(f' pod_cpus={cpumask_str(pool.attrs.__pod_cpumask)}', end='')\n        if pool.attrs.affn_strict:\n            print(' strict', end='')\n    print('')\n\nprint('')\nprint('Workqueue CPU -> pool')\nprint('=====================')\n\nprint('[    workqueue     \\     type   CPU', end='')\nfor cpu in for_each_possible_cpu(prog):\n    print(f' {cpu:{max_pool_id_len}}', end='')\nprint(' dfl]')\n\nfor wq in list_for_each_entry('struct workqueue_struct', workqueues.address_of_(), 'list'):\n    print(f'{wq.name.string_().decode()[-24:]:24}', end='')\n    if wq.flags & WQ_UNBOUND:\n        if wq.flags & WQ_ORDERED:\n            print(' ordered   ', end='')\n        else:\n            print(' unbound', end='')\n            if wq.unbound_attrs.affn_strict:\n                print(',S ', end='')\n            else:\n                print('   ', end='')\n    else:\n        print(' percpu    ', end='')\n\n    for cpu in for_each_possible_cpu(prog):\n        pool_id = per_cpu_ptr(wq.cpu_pwq, cpu)[0].pool.id.value_()\n        field_len = max(len(str(cpu)), max_pool_id_len)\n        print(f' {pool_id:{field_len}}', end='')\n\n    if wq.flags & WQ_UNBOUND:\n        print(f' {wq.dfl_pwq.pool.id.value_():{max_pool_id_len}}', end='')\n    print('')\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}