{
  "module_name": "lsgpio.c",
  "hash_id": "bab767e2c9804e252cd34b30a82aa0bb17b2581242947ceb23a2d175a11ea0fe",
  "original_prompt": "Ingested from linux-6.6.14/tools/gpio/lsgpio.c",
  "human_readable_source": "\n \n\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <dirent.h>\n#include <errno.h>\n#include <string.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <sys/ioctl.h>\n#include <linux/gpio.h>\n\n#include \"gpio-utils.h\"\n\nstruct gpio_flag {\n\tchar *name;\n\tunsigned long long mask;\n};\n\nstruct gpio_flag flagnames[] = {\n\t{\n\t\t.name = \"used\",\n\t\t.mask = GPIO_V2_LINE_FLAG_USED,\n\t},\n\t{\n\t\t.name = \"input\",\n\t\t.mask = GPIO_V2_LINE_FLAG_INPUT,\n\t},\n\t{\n\t\t.name = \"output\",\n\t\t.mask = GPIO_V2_LINE_FLAG_OUTPUT,\n\t},\n\t{\n\t\t.name = \"active-low\",\n\t\t.mask = GPIO_V2_LINE_FLAG_ACTIVE_LOW,\n\t},\n\t{\n\t\t.name = \"open-drain\",\n\t\t.mask = GPIO_V2_LINE_FLAG_OPEN_DRAIN,\n\t},\n\t{\n\t\t.name = \"open-source\",\n\t\t.mask = GPIO_V2_LINE_FLAG_OPEN_SOURCE,\n\t},\n\t{\n\t\t.name = \"pull-up\",\n\t\t.mask = GPIO_V2_LINE_FLAG_BIAS_PULL_UP,\n\t},\n\t{\n\t\t.name = \"pull-down\",\n\t\t.mask = GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN,\n\t},\n\t{\n\t\t.name = \"bias-disabled\",\n\t\t.mask = GPIO_V2_LINE_FLAG_BIAS_DISABLED,\n\t},\n\t{\n\t\t.name = \"clock-realtime\",\n\t\t.mask = GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME,\n\t},\n};\n\nstatic void print_attributes(struct gpio_v2_line_info *info)\n{\n\tint i;\n\tconst char *field_format = \"%s\";\n\n\tfor (i = 0; i < ARRAY_SIZE(flagnames); i++) {\n\t\tif (info->flags & flagnames[i].mask) {\n\t\t\tfprintf(stdout, field_format, flagnames[i].name);\n\t\t\tfield_format = \", %s\";\n\t\t}\n\t}\n\n\tif ((info->flags & GPIO_V2_LINE_FLAG_EDGE_RISING) &&\n\t    (info->flags & GPIO_V2_LINE_FLAG_EDGE_FALLING))\n\t\tfprintf(stdout, field_format, \"both-edges\");\n\telse if (info->flags & GPIO_V2_LINE_FLAG_EDGE_RISING)\n\t\tfprintf(stdout, field_format, \"rising-edge\");\n\telse if (info->flags & GPIO_V2_LINE_FLAG_EDGE_FALLING)\n\t\tfprintf(stdout, field_format, \"falling-edge\");\n\n\tfor (i = 0; i < info->num_attrs; i++) {\n\t\tif (info->attrs[i].id == GPIO_V2_LINE_ATTR_ID_DEBOUNCE)\n\t\t\tfprintf(stdout, \", debounce_period=%dusec\",\n\t\t\t\tinfo->attrs[i].debounce_period_us);\n\t}\n}\n\nint list_device(const char *device_name)\n{\n\tstruct gpiochip_info cinfo;\n\tchar *chrdev_name;\n\tint fd;\n\tint ret;\n\tint i;\n\n\tret = asprintf(&chrdev_name, \"/dev/%s\", device_name);\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\n\tfd = open(chrdev_name, 0);\n\tif (fd == -1) {\n\t\tret = -errno;\n\t\tfprintf(stderr, \"Failed to open %s\\n\", chrdev_name);\n\t\tgoto exit_free_name;\n\t}\n\n\t \n\tret = ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &cinfo);\n\tif (ret == -1) {\n\t\tret = -errno;\n\t\tperror(\"Failed to issue CHIPINFO IOCTL\\n\");\n\t\tgoto exit_close_error;\n\t}\n\tfprintf(stdout, \"GPIO chip: %s, \\\"%s\\\", %u GPIO lines\\n\",\n\t\tcinfo.name, cinfo.label, cinfo.lines);\n\n\t \n\tfor (i = 0; i < cinfo.lines; i++) {\n\t\tstruct gpio_v2_line_info linfo;\n\n\t\tmemset(&linfo, 0, sizeof(linfo));\n\t\tlinfo.offset = i;\n\n\t\tret = ioctl(fd, GPIO_V2_GET_LINEINFO_IOCTL, &linfo);\n\t\tif (ret == -1) {\n\t\t\tret = -errno;\n\t\t\tperror(\"Failed to issue LINEINFO IOCTL\\n\");\n\t\t\tgoto exit_close_error;\n\t\t}\n\t\tfprintf(stdout, \"\\tline %2d:\", linfo.offset);\n\t\tif (linfo.name[0])\n\t\t\tfprintf(stdout, \" \\\"%s\\\"\", linfo.name);\n\t\telse\n\t\t\tfprintf(stdout, \" unnamed\");\n\t\tif (linfo.consumer[0])\n\t\t\tfprintf(stdout, \" \\\"%s\\\"\", linfo.consumer);\n\t\telse\n\t\t\tfprintf(stdout, \" unused\");\n\t\tif (linfo.flags) {\n\t\t\tfprintf(stdout, \" [\");\n\t\t\tprint_attributes(&linfo);\n\t\t\tfprintf(stdout, \"]\");\n\t\t}\n\t\tfprintf(stdout, \"\\n\");\n\n\t}\n\nexit_close_error:\n\tif (close(fd) == -1)\n\t\tperror(\"Failed to close GPIO character device file\");\nexit_free_name:\n\tfree(chrdev_name);\n\treturn ret;\n}\n\nvoid print_usage(void)\n{\n\tfprintf(stderr, \"Usage: lsgpio [options]...\\n\"\n\t\t\"List GPIO chips, lines and states\\n\"\n\t\t\"  -n <name>  List GPIOs on a named device\\n\"\n\t\t\"  -?         This helptext\\n\"\n\t);\n}\n\nint main(int argc, char **argv)\n{\n\tconst char *device_name = NULL;\n\tint ret;\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"n:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'n':\n\t\t\tdevice_name = optarg;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tprint_usage();\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (device_name)\n\t\tret = list_device(device_name);\n\telse {\n\t\tconst struct dirent *ent;\n\t\tDIR *dp;\n\n\t\t \n\t\tdp = opendir(\"/dev\");\n\t\tif (!dp) {\n\t\t\tret = -errno;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tret = -ENOENT;\n\t\twhile (ent = readdir(dp), ent) {\n\t\t\tif (check_prefix(ent->d_name, \"gpiochip\")) {\n\t\t\t\tret = list_device(ent->d_name);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tret = 0;\n\t\tif (closedir(dp) == -1) {\n\t\t\tperror(\"scanning devices: Failed to close directory\");\n\t\t\tret = -errno;\n\t\t}\n\t}\nerror_out:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}