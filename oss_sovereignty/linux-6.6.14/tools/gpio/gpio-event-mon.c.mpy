{
  "module_name": "gpio-event-mon.c",
  "hash_id": "d5f275b06ce9b8d34b5fcbcbf30c1ee1f3ead5cb0ed9227d78942d9b37d3257e",
  "original_prompt": "Ingested from linux-6.6.14/tools/gpio/gpio-event-mon.c",
  "human_readable_source": "\n \n\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <dirent.h>\n#include <errno.h>\n#include <string.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <linux/gpio.h>\n#include \"gpio-utils.h\"\n\nint monitor_device(const char *device_name,\n\t\t   unsigned int *lines,\n\t\t   unsigned int num_lines,\n\t\t   struct gpio_v2_line_config *config,\n\t\t   unsigned int loops)\n{\n\tstruct gpio_v2_line_values values;\n\tchar *chrdev_name;\n\tint cfd, lfd;\n\tint ret;\n\tint i = 0;\n\n\tret = asprintf(&chrdev_name, \"/dev/%s\", device_name);\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\n\tcfd = open(chrdev_name, 0);\n\tif (cfd == -1) {\n\t\tret = -errno;\n\t\tfprintf(stderr, \"Failed to open %s\\n\", chrdev_name);\n\t\tgoto exit_free_name;\n\t}\n\n\tret = gpiotools_request_line(device_name, lines, num_lines, config,\n\t\t\t\t     \"gpio-event-mon\");\n\tif (ret < 0)\n\t\tgoto exit_device_close;\n\telse\n\t\tlfd = ret;\n\n\t \n\tvalues.mask = 0;\n\tvalues.bits = 0;\n\tfor (i = 0; i < num_lines; i++)\n\t\tgpiotools_set_bit(&values.mask, i);\n\tret = gpiotools_get_values(lfd, &values);\n\tif (ret < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"Failed to issue GPIO LINE GET VALUES IOCTL (%d)\\n\",\n\t\t\tret);\n\t\tgoto exit_line_close;\n\t}\n\n\tif (num_lines == 1) {\n\t\tfprintf(stdout, \"Monitoring line %d on %s\\n\", lines[0], device_name);\n\t\tfprintf(stdout, \"Initial line value: %d\\n\",\n\t\t\tgpiotools_test_bit(values.bits, 0));\n\t} else {\n\t\tfprintf(stdout, \"Monitoring lines %d\", lines[0]);\n\t\tfor (i = 1; i < num_lines - 1; i++)\n\t\t\tfprintf(stdout, \", %d\", lines[i]);\n\t\tfprintf(stdout, \" and %d on %s\\n\", lines[i], device_name);\n\t\tfprintf(stdout, \"Initial line values: %d\",\n\t\t\tgpiotools_test_bit(values.bits, 0));\n\t\tfor (i = 1; i < num_lines - 1; i++)\n\t\t\tfprintf(stdout, \", %d\",\n\t\t\t\tgpiotools_test_bit(values.bits, i));\n\t\tfprintf(stdout, \" and %d\\n\",\n\t\t\tgpiotools_test_bit(values.bits, i));\n\t}\n\n\ti = 0;\n\twhile (1) {\n\t\tstruct gpio_v2_line_event event;\n\n\t\tret = read(lfd, &event, sizeof(event));\n\t\tif (ret == -1) {\n\t\t\tif (errno == -EAGAIN) {\n\t\t\t\tfprintf(stderr, \"nothing available\\n\");\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tret = -errno;\n\t\t\t\tfprintf(stderr, \"Failed to read event (%d)\\n\",\n\t\t\t\t\tret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ret != sizeof(event)) {\n\t\t\tfprintf(stderr, \"Reading event failed\\n\");\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tfprintf(stdout, \"GPIO EVENT at %\" PRIu64 \" on line %d (%d|%d) \",\n\t\t\t(uint64_t)event.timestamp_ns, event.offset, event.line_seqno,\n\t\t\tevent.seqno);\n\t\tswitch (event.id) {\n\t\tcase GPIO_V2_LINE_EVENT_RISING_EDGE:\n\t\t\tfprintf(stdout, \"rising edge\");\n\t\t\tbreak;\n\t\tcase GPIO_V2_LINE_EVENT_FALLING_EDGE:\n\t\t\tfprintf(stdout, \"falling edge\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stdout, \"unknown event\");\n\t\t}\n\t\tfprintf(stdout, \"\\n\");\n\n\t\ti++;\n\t\tif (i == loops)\n\t\t\tbreak;\n\t}\n\nexit_line_close:\n\tif (close(lfd) == -1)\n\t\tperror(\"Failed to close line file\");\nexit_device_close:\n\tif (close(cfd) == -1)\n\t\tperror(\"Failed to close GPIO character device file\");\nexit_free_name:\n\tfree(chrdev_name);\n\treturn ret;\n}\n\nvoid print_usage(void)\n{\n\tfprintf(stderr, \"Usage: gpio-event-mon [options]...\\n\"\n\t\t\"Listen to events on GPIO lines, 0->1 1->0\\n\"\n\t\t\"  -n <name>  Listen on GPIOs on a named device (must be stated)\\n\"\n\t\t\"  -o <n>     Offset of line to monitor (may be repeated)\\n\"\n\t\t\"  -d         Set line as open drain\\n\"\n\t\t\"  -s         Set line as open source\\n\"\n\t\t\"  -r         Listen for rising edges\\n\"\n\t\t\"  -f         Listen for falling edges\\n\"\n\t\t\"  -w         Report the wall-clock time for events\\n\"\n\t\t\"  -t         Report the hardware timestamp for events\\n\"\n\t\t\"  -b <n>     Debounce the line with period n microseconds\\n\"\n\t\t\" [-c <n>]    Do <n> loops (optional, infinite loop if not stated)\\n\"\n\t\t\"  -?         This helptext\\n\"\n\t\t\"\\n\"\n\t\t\"Example:\\n\"\n\t\t\"gpio-event-mon -n gpiochip0 -o 4 -r -f -b 10000\\n\"\n\t);\n}\n\n#define EDGE_FLAGS \\\n\t(GPIO_V2_LINE_FLAG_EDGE_RISING | \\\n\t GPIO_V2_LINE_FLAG_EDGE_FALLING)\n\nint main(int argc, char **argv)\n{\n\tconst char *device_name = NULL;\n\tunsigned int lines[GPIO_V2_LINES_MAX];\n\tunsigned int num_lines = 0;\n\tunsigned int loops = 0;\n\tstruct gpio_v2_line_config config;\n\tint c, attr, i;\n\tunsigned long debounce_period_us = 0;\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.flags = GPIO_V2_LINE_FLAG_INPUT;\n\twhile ((c = getopt(argc, argv, \"c:n:o:b:dsrfwt?\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tloops = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdevice_name = optarg;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (num_lines >= GPIO_V2_LINES_MAX) {\n\t\t\t\tprint_usage();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tlines[num_lines] = strtoul(optarg, NULL, 10);\n\t\t\tnum_lines++;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tdebounce_period_us = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tconfig.flags |= GPIO_V2_LINE_FLAG_OPEN_DRAIN;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tconfig.flags |= GPIO_V2_LINE_FLAG_OPEN_SOURCE;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tconfig.flags |= GPIO_V2_LINE_FLAG_EDGE_RISING;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconfig.flags |= GPIO_V2_LINE_FLAG_EDGE_FALLING;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tconfig.flags |= GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tconfig.flags |= GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tprint_usage();\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (debounce_period_us) {\n\t\tattr = config.num_attrs;\n\t\tconfig.num_attrs++;\n\t\tfor (i = 0; i < num_lines; i++)\n\t\t\tgpiotools_set_bit(&config.attrs[attr].mask, i);\n\t\tconfig.attrs[attr].attr.id = GPIO_V2_LINE_ATTR_ID_DEBOUNCE;\n\t\tconfig.attrs[attr].attr.debounce_period_us = debounce_period_us;\n\t}\n\n\tif (!device_name || num_lines == 0) {\n\t\tprint_usage();\n\t\treturn -1;\n\t}\n\tif (!(config.flags & EDGE_FLAGS)) {\n\t\tprintf(\"No flags specified, listening on both rising and \"\n\t\t       \"falling edges\\n\");\n\t\tconfig.flags |= EDGE_FLAGS;\n\t}\n\treturn monitor_device(device_name, lines, num_lines, &config, loops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}