{
  "module_name": "kernel.h",
  "hash_id": "32ef5c7e96596c150ed0713e85f5e744d41e840dd0d48599d50dc0148641ea81",
  "original_prompt": "Ingested from linux-6.6.14/tools/virtio/linux/kernel.h",
  "human_readable_source": " \n#ifndef KERNEL_H\n#define KERNEL_H\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <stdarg.h>\n\n#include <linux/compiler.h>\n#include \"../../../include/linux/container_of.h\"\n#include <linux/log2.h>\n#include <linux/types.h>\n#include <linux/overflow.h>\n#include <linux/list.h>\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <errno.h>\n#include <unistd.h>\n#include <asm/barrier.h>\n\n#define CONFIG_SMP\n\n#define PAGE_SIZE getpagesize()\n#define PAGE_MASK (~(PAGE_SIZE-1))\n#define PAGE_ALIGN(x) ((x + PAGE_SIZE - 1) & PAGE_MASK)\n\n \n#define READ                    0\n#define WRITE                   1\n\ntypedef unsigned long long dma_addr_t;\ntypedef size_t __kernel_size_t;\ntypedef unsigned int __wsum;\n\nstruct page {\n\tunsigned long long dummy;\n};\n\n \n#define virt_to_phys(p) ((unsigned long)p)\n#define phys_to_virt(a) ((void *)(unsigned long)(a))\n \n#define page_to_phys(p) ((dma_addr_t)(unsigned long)(p))\n#define virt_to_page(p) ((struct page *)((unsigned long)p & PAGE_MASK))\n\n#define offset_in_page(p) (((unsigned long)p) % PAGE_SIZE)\n\n#define __printf(a,b) __attribute__((format(printf,a,b)))\n\n#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))\n\nextern void *__kmalloc_fake, *__kfree_ignore_start, *__kfree_ignore_end;\nstatic inline void *kmalloc(size_t s, gfp_t gfp)\n{\n\tif (__kmalloc_fake)\n\t\treturn __kmalloc_fake;\n\treturn malloc(s);\n}\nstatic inline void *kmalloc_array(unsigned n, size_t s, gfp_t gfp)\n{\n\treturn kmalloc(n * s, gfp);\n}\n\nstatic inline void *kzalloc(size_t s, gfp_t gfp)\n{\n\tvoid *p = kmalloc(s, gfp);\n\n\tmemset(p, 0, s);\n\treturn p;\n}\n\nstatic inline void *alloc_pages_exact(size_t s, gfp_t gfp)\n{\n\treturn kmalloc(s, gfp);\n}\n\nstatic inline void kfree(void *p)\n{\n\tif (p >= __kfree_ignore_start && p < __kfree_ignore_end)\n\t\treturn;\n\tfree(p);\n}\n\nstatic inline void free_pages_exact(void *p, size_t s)\n{\n\tkfree(p);\n}\n\nstatic inline void *krealloc(void *p, size_t s, gfp_t gfp)\n{\n\treturn realloc(p, s);\n}\n\n\nstatic inline unsigned long __get_free_page(gfp_t gfp)\n{\n\tvoid *p;\n\n\tposix_memalign(&p, PAGE_SIZE, PAGE_SIZE);\n\treturn (unsigned long)p;\n}\n\nstatic inline void free_page(unsigned long addr)\n{\n\tfree((void *)addr);\n}\n\n# ifndef likely\n#  define likely(x)\t(__builtin_expect(!!(x), 1))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__builtin_expect(!!(x), 0))\n# endif\n\nstatic inline void *krealloc_array(void *p, size_t new_n, size_t new_size, gfp_t gfp)\n{\n\tsize_t bytes;\n\n\tif (unlikely(check_mul_overflow(new_n, new_size, &bytes)))\n\t\treturn NULL;\n\n\treturn krealloc(p, bytes, gfp);\n}\n\n#define pr_err(format, ...) fprintf (stderr, format, ## __VA_ARGS__)\n#ifdef DEBUG\n#define pr_debug(format, ...) fprintf (stderr, format, ## __VA_ARGS__)\n#else\n#define pr_debug(format, ...) do {} while (0)\n#endif\n#define dev_err(dev, format, ...) fprintf (stderr, format, ## __VA_ARGS__)\n#define dev_warn(dev, format, ...) fprintf (stderr, format, ## __VA_ARGS__)\n#define dev_warn_once(dev, format, ...) fprintf (stderr, format, ## __VA_ARGS__)\n\n#define min(x, y) ({\t\t\t\t\\\n\ttypeof(x) _min1 = (x);\t\t\t\\\n\ttypeof(y) _min2 = (y);\t\t\t\\\n\t(void) (&_min1 == &_min2);\t\t\\\n\t_min1 < _min2 ? _min1 : _min2; })\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}