{
  "module_name": "vringh_test.c",
  "hash_id": "f997825672730e5e74a045b7725bb40c3c730b3970745c3ec27c5bcf2ed3d695",
  "original_prompt": "Ingested from linux-6.6.14/tools/virtio/vringh_test.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <sched.h>\n#include <err.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/virtio.h>\n#include <linux/vringh.h>\n#include <linux/virtio_ring.h>\n#include <linux/virtio_config.h>\n#include <linux/uaccess.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n\n#define USER_MEM (1024*1024)\nvoid *__user_addr_min, *__user_addr_max;\nvoid *__kmalloc_fake, *__kfree_ignore_start, *__kfree_ignore_end;\nstatic u64 user_addr_offset;\n\n#define RINGSIZE 256\n#define ALIGN 4096\n\nstatic bool never_notify_host(struct virtqueue *vq)\n{\n\tabort();\n}\n\nstatic void never_callback_guest(struct virtqueue *vq)\n{\n\tabort();\n}\n\nstatic bool getrange_iov(struct vringh *vrh, u64 addr, struct vringh_range *r)\n{\n\tif (addr < (u64)(unsigned long)__user_addr_min - user_addr_offset)\n\t\treturn false;\n\tif (addr >= (u64)(unsigned long)__user_addr_max - user_addr_offset)\n\t\treturn false;\n\n\tr->start = (u64)(unsigned long)__user_addr_min - user_addr_offset;\n\tr->end_incl = (u64)(unsigned long)__user_addr_max - 1 - user_addr_offset;\n\tr->offset = user_addr_offset;\n\treturn true;\n}\n\n \nstatic bool getrange_slow(struct vringh *vrh, u64 addr, struct vringh_range *r)\n{\n\tif (addr < (u64)(unsigned long)__user_addr_min - user_addr_offset)\n\t\treturn false;\n\tif (addr >= (u64)(unsigned long)__user_addr_max - user_addr_offset)\n\t\treturn false;\n\n\tr->start = addr;\n\tr->end_incl = r->start;\n\tr->offset = user_addr_offset;\n\treturn true;\n}\n\nstruct guest_virtio_device {\n\tstruct virtio_device vdev;\n\tint to_host_fd;\n\tunsigned long notifies;\n};\n\nstatic bool parallel_notify_host(struct virtqueue *vq)\n{\n\tint rc;\n\tstruct guest_virtio_device *gvdev;\n\n\tgvdev = container_of(vq->vdev, struct guest_virtio_device, vdev);\n\trc = write(gvdev->to_host_fd, \"\", 1);\n\tif (rc < 0)\n\t\treturn false;\n\tgvdev->notifies++;\n\treturn true;\n}\n\nstatic bool no_notify_host(struct virtqueue *vq)\n{\n\treturn true;\n}\n\n#define NUM_XFERS (10000000)\n\n \nstatic void find_cpus(unsigned int *first, unsigned int *last)\n{\n\tunsigned int i;\n\n\t*first = -1U;\n\t*last = 0;\n\tfor (i = 0; i < 4096; i++) {\n\t\tcpu_set_t set;\n\t\tCPU_ZERO(&set);\n\t\tCPU_SET(i, &set);\n\t\tif (sched_setaffinity(getpid(), sizeof(set), &set) == 0) {\n\t\t\tif (i < *first)\n\t\t\t\t*first = i;\n\t\t\tif (i > *last)\n\t\t\t\t*last = i;\n\t\t}\n\t}\n}\n\n \nstatic inline int vringh_get_head(struct vringh *vrh, u16 *head)\n{\n\tu16 avail_idx, i;\n\tint err;\n\n\terr = get_user(avail_idx, &vrh->vring.avail->idx);\n\tif (err)\n\t\treturn err;\n\n\tif (vrh->last_avail_idx == avail_idx)\n\t\treturn 0;\n\n\t \n\tvirtio_rmb(vrh->weak_barriers);\n\n\ti = vrh->last_avail_idx & (vrh->vring.num - 1);\n\n\terr = get_user(*head, &vrh->vring.avail->ring[i]);\n\tif (err)\n\t\treturn err;\n\n\tvrh->last_avail_idx++;\n\treturn 1;\n}\n\nstatic int parallel_test(u64 features,\n\t\t\t bool (*getrange)(struct vringh *vrh,\n\t\t\t\t\t  u64 addr, struct vringh_range *r),\n\t\t\t bool fast_vringh)\n{\n\tvoid *host_map, *guest_map;\n\tint fd, mapsize, to_guest[2], to_host[2];\n\tunsigned long xfers = 0, notifies = 0, receives = 0;\n\tunsigned int first_cpu, last_cpu;\n\tcpu_set_t cpu_set;\n\tchar buf[128];\n\n\t \n\tfd = open(\"/tmp/vringh_test-file\", O_RDWR|O_CREAT|O_TRUNC, 0600);\n\tif (fd < 0)\n\t\terr(1, \"Opening /tmp/vringh_test-file\");\n\n\t \n\tmapsize = vring_size(RINGSIZE, ALIGN)\n\t\t+ RINGSIZE * 2 * sizeof(int)\n\t\t+ RINGSIZE * 6 * sizeof(struct vring_desc);\n\tmapsize = (mapsize + getpagesize() - 1) & ~(getpagesize() - 1);\n\tftruncate(fd, mapsize);\n\n\t \n\thost_map = mmap(NULL, mapsize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tguest_map = mmap(NULL, mapsize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\n\tpipe(to_guest);\n\tpipe(to_host);\n\n\tCPU_ZERO(&cpu_set);\n\tfind_cpus(&first_cpu, &last_cpu);\n\tprintf(\"Using CPUS %u and %u\\n\", first_cpu, last_cpu);\n\tfflush(stdout);\n\n\tif (fork() != 0) {\n\t\tstruct vringh vrh;\n\t\tint status, err, rlen = 0;\n\t\tchar rbuf[5];\n\n\t\t \n\t\tmunmap(guest_map, mapsize);\n\n\t\t__user_addr_min = host_map;\n\t\t__user_addr_max = __user_addr_min + mapsize;\n\t\tuser_addr_offset = host_map - guest_map;\n\t\tassert(user_addr_offset);\n\n\t\tclose(to_guest[0]);\n\t\tclose(to_host[1]);\n\n\t\tvring_init(&vrh.vring, RINGSIZE, host_map, ALIGN);\n\t\tvringh_init_user(&vrh, features, RINGSIZE, true,\n\t\t\t\t vrh.vring.desc, vrh.vring.avail, vrh.vring.used);\n\t\tCPU_SET(first_cpu, &cpu_set);\n\t\tif (sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set))\n\t\t\terrx(1, \"Could not set affinity to cpu %u\", first_cpu);\n\n\t\twhile (xfers < NUM_XFERS) {\n\t\t\tstruct iovec host_riov[2], host_wiov[2];\n\t\t\tstruct vringh_iov riov, wiov;\n\t\t\tu16 head, written;\n\n\t\t\tif (fast_vringh) {\n\t\t\t\tfor (;;) {\n\t\t\t\t\terr = vringh_get_head(&vrh, &head);\n\t\t\t\t\tif (err != 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\terr = vringh_need_notify_user(&vrh);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\terrx(1, \"vringh_need_notify_user: %i\",\n\t\t\t\t\t\t     err);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\twrite(to_guest[1], \"\", 1);\n\t\t\t\t\t\tnotifies++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (err != 1)\n\t\t\t\t\terrx(1, \"vringh_get_head\");\n\t\t\t\twritten = 0;\n\t\t\t\tgoto complete;\n\t\t\t} else {\n\t\t\t\tvringh_iov_init(&riov,\n\t\t\t\t\t\thost_riov,\n\t\t\t\t\t\tARRAY_SIZE(host_riov));\n\t\t\t\tvringh_iov_init(&wiov,\n\t\t\t\t\t\thost_wiov,\n\t\t\t\t\t\tARRAY_SIZE(host_wiov));\n\n\t\t\t\terr = vringh_getdesc_user(&vrh, &riov, &wiov,\n\t\t\t\t\t\t\t  getrange, &head);\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\terr = vringh_need_notify_user(&vrh);\n\t\t\t\tif (err < 0)\n\t\t\t\t\terrx(1, \"vringh_need_notify_user: %i\",\n\t\t\t\t\t     err);\n\t\t\t\tif (err) {\n\t\t\t\t\twrite(to_guest[1], \"\", 1);\n\t\t\t\t\tnotifies++;\n\t\t\t\t}\n\n\t\t\t\tif (!vringh_notify_enable_user(&vrh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (read(to_host[0], buf, sizeof(buf)) < 1)\n\t\t\t\t\tbreak;\n\n\t\t\t\tvringh_notify_disable_user(&vrh);\n\t\t\t\treceives++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err != 1)\n\t\t\t\terrx(1, \"vringh_getdesc_user: %i\", err);\n\n\t\t\t \n\t\t\tif (riov.used) {\n\t\t\t\trlen = vringh_iov_pull_user(&riov, rbuf,\n\t\t\t\t\t\t\t    sizeof(rbuf));\n\t\t\t\tif (rlen != 4)\n\t\t\t\t\terrx(1, \"vringh_iov_pull_user: %i\",\n\t\t\t\t\t     rlen);\n\t\t\t\tassert(riov.i == riov.used);\n\t\t\t\twritten = 0;\n\t\t\t} else {\n\t\t\t\terr = vringh_iov_push_user(&wiov, rbuf, rlen);\n\t\t\t\tif (err != rlen)\n\t\t\t\t\terrx(1, \"vringh_iov_push_user: %i\",\n\t\t\t\t\t     err);\n\t\t\t\tassert(wiov.i == wiov.used);\n\t\t\t\twritten = err;\n\t\t\t}\n\t\tcomplete:\n\t\t\txfers++;\n\n\t\t\terr = vringh_complete_user(&vrh, head, written);\n\t\t\tif (err != 0)\n\t\t\t\terrx(1, \"vringh_complete_user: %i\", err);\n\t\t}\n\n\t\terr = vringh_need_notify_user(&vrh);\n\t\tif (err < 0)\n\t\t\terrx(1, \"vringh_need_notify_user: %i\", err);\n\t\tif (err) {\n\t\t\twrite(to_guest[1], \"\", 1);\n\t\t\tnotifies++;\n\t\t}\n\t\twait(&status);\n\t\tif (!WIFEXITED(status))\n\t\t\terrx(1, \"Child died with signal %i?\", WTERMSIG(status));\n\t\tif (WEXITSTATUS(status) != 0)\n\t\t\terrx(1, \"Child exited %i?\", WEXITSTATUS(status));\n\t\tprintf(\"Host: notified %lu, pinged %lu\\n\", notifies, receives);\n\t\treturn 0;\n\t} else {\n\t\tstruct guest_virtio_device gvdev;\n\t\tstruct virtqueue *vq;\n\t\tunsigned int *data;\n\t\tstruct vring_desc *indirects;\n\t\tunsigned int finished = 0;\n\n\t\t \n\t\tdata = guest_map + vring_size(RINGSIZE, ALIGN);\n\t\tindirects = (void *)data + (RINGSIZE + 1) * 2 * sizeof(int);\n\n\t\t \n\t\tmunmap(host_map, mapsize);\n\n\t\tclose(to_guest[1]);\n\t\tclose(to_host[0]);\n\n\t\tgvdev.vdev.features = features;\n\t\tINIT_LIST_HEAD(&gvdev.vdev.vqs);\n\t\tspin_lock_init(&gvdev.vdev.vqs_list_lock);\n\t\tgvdev.to_host_fd = to_host[1];\n\t\tgvdev.notifies = 0;\n\n\t\tCPU_SET(first_cpu, &cpu_set);\n\t\tif (sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set))\n\t\t\terr(1, \"Could not set affinity to cpu %u\", first_cpu);\n\n\t\tvq = vring_new_virtqueue(0, RINGSIZE, ALIGN, &gvdev.vdev, true,\n\t\t\t\t\t false, guest_map,\n\t\t\t\t\t fast_vringh ? no_notify_host\n\t\t\t\t\t : parallel_notify_host,\n\t\t\t\t\t never_callback_guest, \"guest vq\");\n\n\t\t \n\t\t__kfree_ignore_start = indirects;\n\t\t__kfree_ignore_end = indirects + RINGSIZE * 6;\n\n\t\twhile (xfers < NUM_XFERS) {\n\t\t\tstruct scatterlist sg[4];\n\t\t\tunsigned int num_sg, len;\n\t\t\tint *dbuf, err;\n\t\t\tbool output = !(xfers % 2);\n\n\t\t\t \n\t\t\twhile ((dbuf = virtqueue_get_buf(vq, &len)) != NULL) {\n\t\t\t\tif (len == 4)\n\t\t\t\t\tassert(*dbuf == finished - 1);\n\t\t\t\telse if (!fast_vringh)\n\t\t\t\t\tassert(*dbuf == finished);\n\t\t\t\tfinished++;\n\t\t\t}\n\n\t\t\t \n\t\t\tdbuf = data + (xfers % (RINGSIZE + 1));\n\n\t\t\tif (output)\n\t\t\t\t*dbuf = xfers;\n\t\t\telse\n\t\t\t\t*dbuf = -1;\n\n\t\t\tswitch ((xfers / sizeof(*dbuf)) % 4) {\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tsg_init_table(sg, num_sg = 3);\n\t\t\t\tsg_set_buf(&sg[0], (void *)dbuf, 1);\n\t\t\t\tsg_set_buf(&sg[1], (void *)dbuf + 1, 2);\n\t\t\t\tsg_set_buf(&sg[2], (void *)dbuf + 3, 1);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tsg_init_table(sg, num_sg = 2);\n\t\t\t\tsg_set_buf(&sg[0], (void *)dbuf, 1);\n\t\t\t\tsg_set_buf(&sg[1], (void *)dbuf + 1, 3);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsg_init_table(sg, num_sg = 1);\n\t\t\t\tsg_set_buf(&sg[0], (void *)dbuf, 4);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsg_init_table(sg, num_sg = 4);\n\t\t\t\tsg_set_buf(&sg[0], (void *)dbuf, 1);\n\t\t\t\tsg_set_buf(&sg[1], (void *)dbuf + 1, 1);\n\t\t\t\tsg_set_buf(&sg[2], (void *)dbuf + 2, 1);\n\t\t\t\tsg_set_buf(&sg[3], (void *)dbuf + 3, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\t__kmalloc_fake = indirects + (xfers % RINGSIZE) * 4;\n\t\t\tif (output)\n\t\t\t\terr = virtqueue_add_outbuf(vq, sg, num_sg, dbuf,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\telse\n\t\t\t\terr = virtqueue_add_inbuf(vq, sg, num_sg,\n\t\t\t\t\t\t\t  dbuf, GFP_KERNEL);\n\n\t\t\tif (err == -ENOSPC) {\n\t\t\t\tif (!virtqueue_enable_cb_delayed(vq))\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tif (read(to_guest[0], buf, sizeof(buf)) < 1)\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\treceives++;\n\t\t\t\tvirtqueue_disable_cb(vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (err)\n\t\t\t\terrx(1, \"virtqueue_add_in/outbuf: %i\", err);\n\n\t\t\txfers++;\n\t\t\tvirtqueue_kick(vq);\n\t\t}\n\n\t\t \n\t\twhile (finished != xfers) {\n\t\t\tint *dbuf;\n\t\t\tunsigned int len;\n\n\t\t\t \n\t\t\tdbuf = virtqueue_get_buf(vq, &len);\n\t\t\tif (dbuf) {\n\t\t\t\tif (len == 4)\n\t\t\t\t\tassert(*dbuf == finished - 1);\n\t\t\t\telse\n\t\t\t\t\tassert(len == 0);\n\t\t\t\tfinished++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!virtqueue_enable_cb_delayed(vq))\n\t\t\t\tcontinue;\n\t\t\tif (read(to_guest[0], buf, sizeof(buf)) < 1)\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\treceives++;\n\t\t\tvirtqueue_disable_cb(vq);\n\t\t}\n\n\t\tprintf(\"Guest: notified %lu, pinged %lu\\n\",\n\t\t       gvdev.notifies, receives);\n\t\tvring_del_virtqueue(vq);\n\t\treturn 0;\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct virtio_device vdev;\n\tstruct virtqueue *vq;\n\tstruct vringh vrh;\n\tstruct scatterlist guest_sg[RINGSIZE], *sgs[2];\n\tstruct iovec host_riov[2], host_wiov[2];\n\tstruct vringh_iov riov, wiov;\n\tstruct vring_used_elem used[RINGSIZE];\n\tchar buf[28];\n\tu16 head;\n\tint err;\n\tunsigned i;\n\tvoid *ret;\n\tbool (*getrange)(struct vringh *vrh, u64 addr, struct vringh_range *r);\n\tbool fast_vringh = false, parallel = false;\n\n\tgetrange = getrange_iov;\n\tvdev.features = 0;\n\tINIT_LIST_HEAD(&vdev.vqs);\n\tspin_lock_init(&vdev.vqs_list_lock);\n\n\twhile (argv[1]) {\n\t\tif (strcmp(argv[1], \"--indirect\") == 0)\n\t\t\t__virtio_set_bit(&vdev, VIRTIO_RING_F_INDIRECT_DESC);\n\t\telse if (strcmp(argv[1], \"--eventidx\") == 0)\n\t\t\t__virtio_set_bit(&vdev, VIRTIO_RING_F_EVENT_IDX);\n\t\telse if (strcmp(argv[1], \"--virtio-1\") == 0)\n\t\t\t__virtio_set_bit(&vdev, VIRTIO_F_VERSION_1);\n\t\telse if (strcmp(argv[1], \"--slow-range\") == 0)\n\t\t\tgetrange = getrange_slow;\n\t\telse if (strcmp(argv[1], \"--fast-vringh\") == 0)\n\t\t\tfast_vringh = true;\n\t\telse if (strcmp(argv[1], \"--parallel\") == 0)\n\t\t\tparallel = true;\n\t\telse\n\t\t\terrx(1, \"Unknown arg %s\", argv[1]);\n\t\targv++;\n\t}\n\n\tif (parallel)\n\t\treturn parallel_test(vdev.features, getrange, fast_vringh);\n\n\tif (posix_memalign(&__user_addr_min, PAGE_SIZE, USER_MEM) != 0)\n\t\tabort();\n\t__user_addr_max = __user_addr_min + USER_MEM;\n\tmemset(__user_addr_min, 0, vring_size(RINGSIZE, ALIGN));\n\n\t \n\tvq = vring_new_virtqueue(0, RINGSIZE, ALIGN, &vdev, true, false,\n\t\t\t\t __user_addr_min,\n\t\t\t\t never_notify_host, never_callback_guest,\n\t\t\t\t \"guest vq\");\n\n\t \n\tvring_init(&vrh.vring, RINGSIZE, __user_addr_min, ALIGN);\n\tvringh_init_user(&vrh, vdev.features, RINGSIZE, true,\n\t\t\t vrh.vring.desc, vrh.vring.avail, vrh.vring.used);\n\n\t \n\terr = vringh_getdesc_user(&vrh, &riov, &wiov, getrange, &head);\n\tif (err != 0)\n\t\terrx(1, \"vringh_getdesc_user: %i\", err);\n\n\t \n\tmemcpy(__user_addr_max - 1, \"a\", 1);\n\tsg_init_table(guest_sg, 1);\n\tsg_set_buf(&guest_sg[0], __user_addr_max - 1, 1);\n\tsg_init_table(guest_sg+1, 1);\n\tsg_set_buf(&guest_sg[1], __user_addr_max - 3, 2);\n\tsgs[0] = &guest_sg[0];\n\tsgs[1] = &guest_sg[1];\n\n\t \n\t__kmalloc_fake = __user_addr_min + vring_size(RINGSIZE, ALIGN);\n\terr = virtqueue_add_sgs(vq, sgs, 1, 1, &err, GFP_KERNEL);\n\tif (err)\n\t\terrx(1, \"virtqueue_add_sgs: %i\", err);\n\t__kmalloc_fake = NULL;\n\n\t \n\tvringh_iov_init(&riov, host_riov, ARRAY_SIZE(host_riov));\n\tvringh_iov_init(&wiov, host_wiov, ARRAY_SIZE(host_wiov));\n\n\terr = vringh_getdesc_user(&vrh, &riov, &wiov, getrange, &head);\n\tif (err != 1)\n\t\terrx(1, \"vringh_getdesc_user: %i\", err);\n\n\tassert(riov.used == 1);\n\tassert(riov.iov[0].iov_base == __user_addr_max - 1);\n\tassert(riov.iov[0].iov_len == 1);\n\tif (getrange != getrange_slow) {\n\t\tassert(wiov.used == 1);\n\t\tassert(wiov.iov[0].iov_base == __user_addr_max - 3);\n\t\tassert(wiov.iov[0].iov_len == 2);\n\t} else {\n\t\tassert(wiov.used == 2);\n\t\tassert(wiov.iov[0].iov_base == __user_addr_max - 3);\n\t\tassert(wiov.iov[0].iov_len == 1);\n\t\tassert(wiov.iov[1].iov_base == __user_addr_max - 2);\n\t\tassert(wiov.iov[1].iov_len == 1);\n\t}\n\n\terr = vringh_iov_pull_user(&riov, buf, 5);\n\tif (err != 1)\n\t\terrx(1, \"vringh_iov_pull_user: %i\", err);\n\tassert(buf[0] == 'a');\n\tassert(riov.i == 1);\n\tassert(vringh_iov_pull_user(&riov, buf, 5) == 0);\n\n\tmemcpy(buf, \"bcdef\", 5);\n\terr = vringh_iov_push_user(&wiov, buf, 5);\n\tif (err != 2)\n\t\terrx(1, \"vringh_iov_push_user: %i\", err);\n\tassert(memcmp(__user_addr_max - 3, \"bc\", 2) == 0);\n\tassert(wiov.i == wiov.used);\n\tassert(vringh_iov_push_user(&wiov, buf, 5) == 0);\n\n\t \n\terr = vringh_complete_user(&vrh, head, err);\n\tif (err != 0)\n\t\terrx(1, \"vringh_complete_user: %i\", err);\n\n\t \n\t__kfree_ignore_start = __user_addr_min + vring_size(RINGSIZE, ALIGN);\n\t__kfree_ignore_end = __kfree_ignore_start + 1;\n\tret = virtqueue_get_buf(vq, &i);\n\tif (ret != &err)\n\t\terrx(1, \"virtqueue_get_buf: %p\", ret);\n\tassert(i == 2);\n\n\t \n\tsg_init_table(guest_sg, RINGSIZE);\n\tfor (i = 0; i < RINGSIZE; i++) {\n\t\tsg_set_buf(&guest_sg[i],\n\t\t\t   __user_addr_max - USER_MEM/4, USER_MEM/4);\n\t}\n\n\t \n\tfor (i = 0; i < USER_MEM/4; i++)\n\t\t((char *)__user_addr_max - USER_MEM/4)[i] = i;\n\n\t \n\t__kmalloc_fake = __user_addr_min + vring_size(RINGSIZE, ALIGN);\n\terr = virtqueue_add_outbuf(vq, guest_sg, RINGSIZE, &err, GFP_KERNEL);\n\tif (err)\n\t\terrx(1, \"virtqueue_add_outbuf (large): %i\", err);\n\t__kmalloc_fake = NULL;\n\n\t \n\tvringh_iov_init(&riov, host_riov, ARRAY_SIZE(host_riov));\n\tvringh_iov_init(&wiov, host_wiov, ARRAY_SIZE(host_wiov));\n\n\terr = vringh_getdesc_user(&vrh, &riov, &wiov, getrange, &head);\n\tif (err != 1)\n\t\terrx(1, \"vringh_getdesc_user: %i\", err);\n\n\tassert(riov.max_num & VRINGH_IOV_ALLOCATED);\n\tassert(riov.iov != host_riov);\n\tif (getrange != getrange_slow)\n\t\tassert(riov.used == RINGSIZE);\n\telse\n\t\tassert(riov.used == RINGSIZE * USER_MEM/4);\n\n\tassert(!(wiov.max_num & VRINGH_IOV_ALLOCATED));\n\tassert(wiov.used == 0);\n\n\t \n\tfor (i = 0; i < RINGSIZE * USER_MEM/4; i += 3) {\n\t\terr = vringh_iov_pull_user(&riov, buf, 3);\n\t\tif (err != 3 && i + err != RINGSIZE * USER_MEM/4)\n\t\t\terrx(1, \"vringh_iov_pull_user large: %i\", err);\n\t\tassert(buf[0] == (char)i);\n\t\tassert(err < 2 || buf[1] == (char)(i + 1));\n\t\tassert(err < 3 || buf[2] == (char)(i + 2));\n\t}\n\tassert(riov.i == riov.used);\n\tvringh_iov_cleanup(&riov);\n\tvringh_iov_cleanup(&wiov);\n\n\t \n\tused[0].id = head;\n\tused[0].len = 0;\n\terr = vringh_complete_multi_user(&vrh, used, 1);\n\tif (err)\n\t\terrx(1, \"vringh_complete_multi_user(1): %i\", err);\n\n\t \n\tret = virtqueue_get_buf(vq, &i);\n\tif (ret != &err)\n\t\terrx(1, \"virtqueue_get_buf: %p\", ret);\n\n\t \n\tsg_init_table(guest_sg, 1);\n\tsg_set_buf(&guest_sg[0], __user_addr_max - 1, 1);\n\tfor (i = 0; i < RINGSIZE; i++) {\n\t\terr = virtqueue_add_outbuf(vq, guest_sg, 1, &err, GFP_KERNEL);\n\t\tif (err)\n\t\t\terrx(1, \"virtqueue_add_outbuf (multiple): %i\", err);\n\t}\n\n\t \n\tvringh_iov_init(&riov, host_riov, ARRAY_SIZE(host_riov));\n\tvringh_iov_init(&wiov, host_wiov, ARRAY_SIZE(host_wiov));\n\n\tfor (i = 0; i < RINGSIZE; i++) {\n\t\terr = vringh_getdesc_user(&vrh, &riov, &wiov, getrange, &head);\n\t\tif (err != 1)\n\t\t\terrx(1, \"vringh_getdesc_user: %i\", err);\n\t\tused[i].id = head;\n\t\tused[i].len = 0;\n\t}\n\t \n\tassert(vrh.vring.used->idx % RINGSIZE != 0);\n\terr = vringh_complete_multi_user(&vrh, used, RINGSIZE);\n\tif (err)\n\t\terrx(1, \"vringh_complete_multi_user: %i\", err);\n\n\t \n\tfor (i = 0; i < RINGSIZE; i++) {\n\t\tunsigned len;\n\t\tassert(virtqueue_get_buf(vq, &len) != NULL);\n\t}\n\n\t \n\tif (__virtio_test_bit(&vdev, VIRTIO_RING_F_INDIRECT_DESC)) {\n\t\tchar *data = __user_addr_max - USER_MEM/4;\n\t\tstruct vring_desc *d = __user_addr_max - USER_MEM/2;\n\t\tstruct vring vring;\n\n\t\t \n\t\t__virtio_clear_bit(&vdev, VIRTIO_RING_F_INDIRECT_DESC);\n\t\tvq = vring_new_virtqueue(0, RINGSIZE, ALIGN, &vdev, true,\n\t\t\t\t\t false, __user_addr_min,\n\t\t\t\t\t never_notify_host,\n\t\t\t\t\t never_callback_guest,\n\t\t\t\t\t \"guest vq\");\n\n\t\tsg_init_table(guest_sg, 4);\n\t\tsg_set_buf(&guest_sg[0], d, sizeof(*d)*2);\n\t\tsg_set_buf(&guest_sg[1], d + 2, sizeof(*d)*1);\n\t\tsg_set_buf(&guest_sg[2], data + 6, 4);\n\t\tsg_set_buf(&guest_sg[3], d + 3, sizeof(*d)*3);\n\n\t\terr = virtqueue_add_outbuf(vq, guest_sg, 4, &err, GFP_KERNEL);\n\t\tif (err)\n\t\t\terrx(1, \"virtqueue_add_outbuf (indirect): %i\", err);\n\n\t\tvring_init(&vring, RINGSIZE, __user_addr_min, ALIGN);\n\n\t\t \n\t\tassert(vring.desc[0].addr == (unsigned long)d);\n\t\tassert(vring.desc[1].addr == (unsigned long)(d+2));\n\t\tassert(vring.desc[2].addr == (unsigned long)data + 6);\n\t\tassert(vring.desc[3].addr == (unsigned long)(d+3));\n\t\tvring.desc[0].flags |= VRING_DESC_F_INDIRECT;\n\t\tvring.desc[1].flags |= VRING_DESC_F_INDIRECT;\n\t\tvring.desc[3].flags |= VRING_DESC_F_INDIRECT;\n\n\t\t \n\t\td[0].addr = (unsigned long)data;\n\t\td[0].len = 1;\n\t\td[0].flags = VRING_DESC_F_NEXT;\n\t\td[0].next = 1;\n\t\td[1].addr = (unsigned long)data + 1;\n\t\td[1].len = 2;\n\t\td[1].flags = 0;\n\n\t\t \n\t\td[2].addr = (unsigned long)data + 3;\n\t\td[2].len = 3;\n\t\td[2].flags = 0;\n\n\t\t \n\t\td[3].addr = (unsigned long)data + 10;\n\t\td[3].len = 5;\n\t\td[3].flags = VRING_DESC_F_NEXT;\n\t\td[3].next = 1;\n\t\td[4].addr = (unsigned long)data + 15;\n\t\td[4].len = 6;\n\t\td[4].flags = VRING_DESC_F_NEXT;\n\t\td[4].next = 2;\n\t\td[5].addr = (unsigned long)data + 21;\n\t\td[5].len = 7;\n\t\td[5].flags = 0;\n\n\t\t \n\t\tvringh_iov_init(&riov, host_riov, ARRAY_SIZE(host_riov));\n\t\tvringh_iov_init(&wiov, host_wiov, ARRAY_SIZE(host_wiov));\n\n\t\terr = vringh_getdesc_user(&vrh, &riov, &wiov, getrange, &head);\n\t\tif (err != 1)\n\t\t\terrx(1, \"vringh_getdesc_user: %i\", err);\n\n\t\tif (head != 0)\n\t\t\terrx(1, \"vringh_getdesc_user: head %i not 0\", head);\n\n\t\tassert(riov.max_num & VRINGH_IOV_ALLOCATED);\n\t\tif (getrange != getrange_slow)\n\t\t\tassert(riov.used == 7);\n\t\telse\n\t\t\tassert(riov.used == 28);\n\t\terr = vringh_iov_pull_user(&riov, buf, 29);\n\t\tassert(err == 28);\n\n\t\t \n\t\tfor (i = 0; i < err; i++)\n\t\t\tassert(buf[i] == i);\n\t\tvringh_iov_cleanup(&riov);\n\t}\n\n\t \n\tvring_del_virtqueue(vq);\n\tfree(__user_addr_min);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}