{
  "module_name": "virtio_ring_0_9.c",
  "hash_id": "be14bd6cd15b4c4efaf92697d3624827e7d13c3f7714623646e2af3abe69f8d7",
  "original_prompt": "Ingested from linux-6.6.14/tools/virtio/ringtest/virtio_ring_0_9.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include \"main.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <linux/virtio_ring.h>\n\nstruct data {\n\tvoid *data;\n} *data;\n\nstruct vring ring;\n\n \n \n \n \n\n#if defined(RING_POLL) && defined(INORDER)\n#error \"RING_POLL and INORDER are mutually exclusive\"\n#endif\n\n \n#define HOST_GUEST_PADDING 0x80\n\nstruct guest {\n\tunsigned short avail_idx;\n\tunsigned short last_used_idx;\n\tunsigned short num_free;\n\tunsigned short kicked_avail_idx;\n#ifndef INORDER\n\tunsigned short free_head;\n#else\n\tunsigned short reserved_free_head;\n#endif\n\tunsigned char reserved[HOST_GUEST_PADDING - 10];\n} guest;\n\nstruct host {\n\t \n\tunsigned short used_idx;\n\tunsigned short called_used_idx;\n\tunsigned char reserved[HOST_GUEST_PADDING - 4];\n} host;\n\n \nvoid alloc_ring(void)\n{\n\tint ret;\n\tint i;\n\tvoid *p;\n\n\tret = posix_memalign(&p, 0x1000, vring_size(ring_size, 0x1000));\n\tif (ret) {\n\t\tperror(\"Unable to allocate ring buffer.\\n\");\n\t\texit(3);\n\t}\n\tmemset(p, 0, vring_size(ring_size, 0x1000));\n\tvring_init(&ring, ring_size, p, 0x1000);\n\n\tguest.avail_idx = 0;\n\tguest.kicked_avail_idx = -1;\n\tguest.last_used_idx = 0;\n#ifndef INORDER\n\t \n\tguest.free_head = 0;\n#endif\n\tfor (i = 0; i < ring_size - 1; i++)\n\t\tring.desc[i].next = i + 1;\n\thost.used_idx = 0;\n\thost.called_used_idx = -1;\n\tguest.num_free = ring_size;\n\tdata = malloc(ring_size * sizeof *data);\n\tif (!data) {\n\t\tperror(\"Unable to allocate data buffer.\\n\");\n\t\texit(3);\n\t}\n\tmemset(data, 0, ring_size * sizeof *data);\n}\n\n \nint add_inbuf(unsigned len, void *buf, void *datap)\n{\n\tunsigned head;\n#ifndef INORDER\n\tunsigned avail;\n#endif\n\tstruct vring_desc *desc;\n\n\tif (!guest.num_free)\n\t\treturn -1;\n\n#ifdef INORDER\n\thead = (ring_size - 1) & (guest.avail_idx++);\n#else\n\thead = guest.free_head;\n#endif\n\tguest.num_free--;\n\n\tdesc = ring.desc;\n\tdesc[head].flags = VRING_DESC_F_NEXT;\n\tdesc[head].addr = (unsigned long)(void *)buf;\n\tdesc[head].len = len;\n\t \n\tdesc[head].flags &= ~VRING_DESC_F_NEXT;\n#ifndef INORDER\n\tguest.free_head = desc[head].next;\n#endif\n\n\tdata[head].data = datap;\n\n#ifdef RING_POLL\n\t \n\tsmp_release();\n\tavail = guest.avail_idx++;\n\tring.avail->ring[avail & (ring_size - 1)] =\n\t\t(head | (avail & ~(ring_size - 1))) ^ 0x8000;\n#else\n#ifndef INORDER\n\t \n\tsmp_release();\n\tavail = (ring_size - 1) & (guest.avail_idx++);\n\tring.avail->ring[avail] = head;\n#endif\n\t \n\tsmp_release();\n#endif\n\tring.avail->idx = guest.avail_idx;\n\treturn 0;\n}\n\nvoid *get_buf(unsigned *lenp, void **bufp)\n{\n\tunsigned head;\n\tunsigned index;\n\tvoid *datap;\n\n#ifdef RING_POLL\n\thead = (ring_size - 1) & guest.last_used_idx;\n\tindex = ring.used->ring[head].id;\n\tif ((index ^ guest.last_used_idx ^ 0x8000) & ~(ring_size - 1))\n\t\treturn NULL;\n\t \n\tsmp_acquire();\n\tindex &= ring_size - 1;\n#else\n\tif (ring.used->idx == guest.last_used_idx)\n\t\treturn NULL;\n\t \n\tsmp_acquire();\n#ifdef INORDER\n\thead = (ring_size - 1) & guest.last_used_idx;\n\tindex = head;\n#else\n\thead = (ring_size - 1) & guest.last_used_idx;\n\tindex = ring.used->ring[head].id;\n#endif\n\n#endif\n#ifdef INORDER\n\t*lenp = ring.desc[index].len;\n#else\n\t*lenp = ring.used->ring[head].len;\n#endif\n\tdatap = data[index].data;\n\t*bufp = (void*)(unsigned long)ring.desc[index].addr;\n\tdata[index].data = NULL;\n#ifndef INORDER\n\tring.desc[index].next = guest.free_head;\n\tguest.free_head = index;\n#endif\n\tguest.num_free++;\n\tguest.last_used_idx++;\n\treturn datap;\n}\n\nbool used_empty()\n{\n\tunsigned short last_used_idx = guest.last_used_idx;\n#ifdef RING_POLL\n\tunsigned short head = last_used_idx & (ring_size - 1);\n\tunsigned index = ring.used->ring[head].id;\n\n\treturn (index ^ last_used_idx ^ 0x8000) & ~(ring_size - 1);\n#else\n\treturn ring.used->idx == last_used_idx;\n#endif\n}\n\nvoid disable_call()\n{\n\t \n}\n\nbool enable_call()\n{\n\tvring_used_event(&ring) = guest.last_used_idx;\n\t \n\t \n\tsmp_mb();\n\treturn used_empty();\n}\n\nvoid kick_available(void)\n{\n\tbool need;\n\n\t \n\t \n\tsmp_mb();\n\tneed = vring_need_event(vring_avail_event(&ring),\n\t\t\t\tguest.avail_idx,\n\t\t\t\tguest.kicked_avail_idx);\n\n\tguest.kicked_avail_idx = guest.avail_idx;\n\tif (need)\n\t\tkick();\n}\n\n \nvoid disable_kick()\n{\n\t \n}\n\nbool enable_kick()\n{\n\tvring_avail_event(&ring) = host.used_idx;\n\t \n\tsmp_mb();\n\treturn avail_empty();\n}\n\nbool avail_empty()\n{\n\tunsigned head = host.used_idx;\n#ifdef RING_POLL\n\tunsigned index = ring.avail->ring[head & (ring_size - 1)];\n\n\treturn ((index ^ head ^ 0x8000) & ~(ring_size - 1));\n#else\n\treturn head == ring.avail->idx;\n#endif\n}\n\nbool use_buf(unsigned *lenp, void **bufp)\n{\n\tunsigned used_idx = host.used_idx;\n\tstruct vring_desc *desc;\n\tunsigned head;\n\n#ifdef RING_POLL\n\thead = ring.avail->ring[used_idx & (ring_size - 1)];\n\tif ((used_idx ^ head ^ 0x8000) & ~(ring_size - 1))\n\t\treturn false;\n\t \n\tsmp_acquire();\n\n\tused_idx &= ring_size - 1;\n\tdesc = &ring.desc[head & (ring_size - 1)];\n#else\n\tif (used_idx == ring.avail->idx)\n\t\treturn false;\n\n\t \n\tsmp_acquire();\n\n\tused_idx &= ring_size - 1;\n#ifdef INORDER\n\thead = used_idx;\n#else\n\thead = ring.avail->ring[used_idx];\n#endif\n\tdesc = &ring.desc[head];\n#endif\n\n\t*lenp = desc->len;\n\t*bufp = (void *)(unsigned long)desc->addr;\n\n#ifdef INORDER\n\tdesc->len = desc->len - 1;\n#else\n\t \n\tring.used->ring[used_idx].id = head;\n\tring.used->ring[used_idx].len = desc->len - 1;\n#endif\n\t \n\tsmp_release();\n\thost.used_idx++;\n\tring.used->idx = host.used_idx;\n\t\n\treturn true;\n}\n\nvoid call_used(void)\n{\n\tbool need;\n\n\t \n\t \n\tsmp_mb();\n\tneed = vring_need_event(vring_used_event(&ring),\n\t\t\t\thost.used_idx,\n\t\t\t\thost.called_used_idx);\n\n\thost.called_used_idx = host.used_idx;\n\tif (need)\n\t\tcall();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}