{
  "module_name": "ring.c",
  "hash_id": "5e7e669c451ad86c70be8653128fd423883484344067baa9b904247669c2c10a",
  "original_prompt": "Ingested from linux-6.6.14/tools/virtio/ringtest/ring.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include \"main.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n \nstatic inline bool need_event(unsigned short event,\n\t\t\t      unsigned short next,\n\t\t\t      unsigned short prev)\n{\n\treturn (unsigned short)(next - event - 1) < (unsigned short)(next - prev);\n}\n\n \n#define DESC_HW 0x1\n\nstruct desc {\n\tunsigned short flags;\n\tunsigned short index;\n\tunsigned len;\n\tunsigned long long addr;\n};\n\n \n#define HOST_GUEST_PADDING 0x80\n\n \nstruct event {\n\tunsigned short kick_index;\n\tunsigned char reserved0[HOST_GUEST_PADDING - 2];\n\tunsigned short call_index;\n\tunsigned char reserved1[HOST_GUEST_PADDING - 2];\n};\n\nstruct data {\n\tvoid *buf;  \n\tvoid *data;\n} *data;\n\nstruct desc *ring;\nstruct event *event;\n\nstruct guest {\n\tunsigned avail_idx;\n\tunsigned last_used_idx;\n\tunsigned num_free;\n\tunsigned kicked_avail_idx;\n\tunsigned char reserved[HOST_GUEST_PADDING - 12];\n} guest;\n\nstruct host {\n\t \n\tunsigned used_idx;\n\tunsigned called_used_idx;\n\tunsigned char reserved[HOST_GUEST_PADDING - 4];\n} host;\n\n \nvoid alloc_ring(void)\n{\n\tint ret;\n\tint i;\n\n\tret = posix_memalign((void **)&ring, 0x1000, ring_size * sizeof *ring);\n\tif (ret) {\n\t\tperror(\"Unable to allocate ring buffer.\\n\");\n\t\texit(3);\n\t}\n\tevent = calloc(1, sizeof(*event));\n\tif (!event) {\n\t\tperror(\"Unable to allocate event buffer.\\n\");\n\t\texit(3);\n\t}\n\tguest.avail_idx = 0;\n\tguest.kicked_avail_idx = -1;\n\tguest.last_used_idx = 0;\n\thost.used_idx = 0;\n\thost.called_used_idx = -1;\n\tfor (i = 0; i < ring_size; ++i) {\n\t\tstruct desc desc = {\n\t\t\t.index = i,\n\t\t};\n\t\tring[i] = desc;\n\t}\n\tguest.num_free = ring_size;\n\tdata = calloc(ring_size, sizeof(*data));\n\tif (!data) {\n\t\tperror(\"Unable to allocate data buffer.\\n\");\n\t\texit(3);\n\t}\n}\n\n \nint add_inbuf(unsigned len, void *buf, void *datap)\n{\n\tunsigned head, index;\n\n\tif (!guest.num_free)\n\t\treturn -1;\n\n\tguest.num_free--;\n\thead = (ring_size - 1) & (guest.avail_idx++);\n\n\t \n\tring[head].addr = (unsigned long)(void*)buf;\n\tring[head].len = len;\n\t \n\tbarrier();\n\tindex = ring[head].index;\n\tdata[index].buf = buf;\n\tdata[index].data = datap;\n\t \n\tsmp_release();\n\tring[head].flags = DESC_HW;\n\n\treturn 0;\n}\n\nvoid *get_buf(unsigned *lenp, void **bufp)\n{\n\tunsigned head = (ring_size - 1) & guest.last_used_idx;\n\tunsigned index;\n\tvoid *datap;\n\n\tif (ring[head].flags & DESC_HW)\n\t\treturn NULL;\n\t \n\tsmp_acquire();\n\t*lenp = ring[head].len;\n\tindex = ring[head].index & (ring_size - 1);\n\tdatap = data[index].data;\n\t*bufp = data[index].buf;\n\tdata[index].buf = NULL;\n\tdata[index].data = NULL;\n\tguest.num_free++;\n\tguest.last_used_idx++;\n\treturn datap;\n}\n\nbool used_empty()\n{\n\tunsigned head = (ring_size - 1) & guest.last_used_idx;\n\n\treturn (ring[head].flags & DESC_HW);\n}\n\nvoid disable_call()\n{\n\t \n}\n\nbool enable_call()\n{\n\tevent->call_index = guest.last_used_idx;\n\t \n\t \n\tsmp_mb();\n\treturn used_empty();\n}\n\nvoid kick_available(void)\n{\n\tbool need;\n\n\t \n\t \n\tsmp_mb();\n\tneed = need_event(event->kick_index,\n\t\t\t   guest.avail_idx,\n\t\t\t   guest.kicked_avail_idx);\n\n\tguest.kicked_avail_idx = guest.avail_idx;\n\tif (need)\n\t\tkick();\n}\n\n \nvoid disable_kick()\n{\n\t \n}\n\nbool enable_kick()\n{\n\tevent->kick_index = host.used_idx;\n\t \n\tsmp_mb();\n\treturn avail_empty();\n}\n\nbool avail_empty()\n{\n\tunsigned head = (ring_size - 1) & host.used_idx;\n\n\treturn !(ring[head].flags & DESC_HW);\n}\n\nbool use_buf(unsigned *lenp, void **bufp)\n{\n\tunsigned head = (ring_size - 1) & host.used_idx;\n\n\tif (!(ring[head].flags & DESC_HW))\n\t\treturn false;\n\n\t \n\t \n\tsmp_acquire();\n\n\t \n\tring[head].len--;\n\t \n\t \n\tsmp_release();\n\tring[head].flags = 0;\n\thost.used_idx++;\n\treturn true;\n}\n\nvoid call_used(void)\n{\n\tbool need;\n\n\t \n\t \n\tsmp_mb();\n\n\tneed = need_event(event->call_index,\n\t\t\thost.used_idx,\n\t\t\thost.called_used_idx);\n\n\thost.called_used_idx = host.used_idx;\n\n\tif (need)\n\t\tcall();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}