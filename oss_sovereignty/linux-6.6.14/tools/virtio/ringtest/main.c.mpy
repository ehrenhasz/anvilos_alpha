{
  "module_name": "main.c",
  "hash_id": "08656d683437663ae90f1e579c52ac97e48ff6f16bb7b48482763771fad15d96",
  "original_prompt": "Ingested from linux-6.6.14/tools/virtio/ringtest/main.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <getopt.h>\n#include <pthread.h>\n#include <assert.h>\n#include <sched.h>\n#include \"main.h\"\n#include <sys/eventfd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <limits.h>\n\nint runcycles = 10000000;\nint max_outstanding = INT_MAX;\nint batch = 1;\nint param = 0;\n\nbool do_sleep = false;\nbool do_relax = false;\nbool do_exit = true;\n\nunsigned ring_size = 256;\n\nstatic int kickfd = -1;\nstatic int callfd = -1;\n\nvoid notify(int fd)\n{\n\tunsigned long long v = 1;\n\tint r;\n\n\tvmexit();\n\tr = write(fd, &v, sizeof v);\n\tassert(r == sizeof v);\n\tvmentry();\n}\n\nvoid wait_for_notify(int fd)\n{\n\tunsigned long long v = 1;\n\tint r;\n\n\tvmexit();\n\tr = read(fd, &v, sizeof v);\n\tassert(r == sizeof v);\n\tvmentry();\n}\n\nvoid kick(void)\n{\n\tnotify(kickfd);\n}\n\nvoid wait_for_kick(void)\n{\n\twait_for_notify(kickfd);\n}\n\nvoid call(void)\n{\n\tnotify(callfd);\n}\n\nvoid wait_for_call(void)\n{\n\twait_for_notify(callfd);\n}\n\nvoid set_affinity(const char *arg)\n{\n\tcpu_set_t cpuset;\n\tint ret;\n\tpthread_t self;\n\tlong int cpu;\n\tchar *endptr;\n\n\tif (!arg)\n\t\treturn;\n\n\tcpu = strtol(arg, &endptr, 0);\n\tassert(!*endptr);\n\n\tassert(cpu >= 0 && cpu < CPU_SETSIZE);\n\n\tself = pthread_self();\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(cpu, &cpuset);\n\n\tret = pthread_setaffinity_np(self, sizeof(cpu_set_t), &cpuset);\n\tassert(!ret);\n}\n\nvoid poll_used(void)\n{\n\twhile (used_empty())\n\t\tbusy_wait();\n}\n\nstatic void __attribute__((__flatten__)) run_guest(void)\n{\n\tint completed_before;\n\tint completed = 0;\n\tint started = 0;\n\tint bufs = runcycles;\n\tint spurious = 0;\n\tint r;\n\tunsigned len;\n\tvoid *buf;\n\tint tokick = batch;\n\n\tfor (;;) {\n\t\tif (do_sleep)\n\t\t\tdisable_call();\n\t\tcompleted_before = completed;\n\t\tdo {\n\t\t\tif (started < bufs &&\n\t\t\t    started - completed < max_outstanding) {\n\t\t\t\tr = add_inbuf(0, \"Buffer\\n\", \"Hello, world!\");\n\t\t\t\tif (__builtin_expect(r == 0, true)) {\n\t\t\t\t\t++started;\n\t\t\t\t\tif (!--tokick) {\n\t\t\t\t\t\ttokick = batch;\n\t\t\t\t\t\tif (do_sleep)\n\t\t\t\t\t\t\tkick_available();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tr = -1;\n\n\t\t\t \n\t\t\tif (get_buf(&len, &buf)) {\n\t\t\t\t++completed;\n\t\t\t\tif (__builtin_expect(completed == bufs, false))\n\t\t\t\t\treturn;\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t} while (r == 0);\n\t\tif (completed == completed_before)\n\t\t\t++spurious;\n\t\tassert(completed <= bufs);\n\t\tassert(started <= bufs);\n\t\tif (do_sleep) {\n\t\t\tif (used_empty() && enable_call())\n\t\t\t\twait_for_call();\n\t\t} else {\n\t\t\tpoll_used();\n\t\t}\n\t}\n}\n\nvoid poll_avail(void)\n{\n\twhile (avail_empty())\n\t\tbusy_wait();\n}\n\nstatic void __attribute__((__flatten__)) run_host(void)\n{\n\tint completed_before;\n\tint completed = 0;\n\tint spurious = 0;\n\tint bufs = runcycles;\n\tunsigned len;\n\tvoid *buf;\n\n\tfor (;;) {\n\t\tif (do_sleep) {\n\t\t\tif (avail_empty() && enable_kick())\n\t\t\t\twait_for_kick();\n\t\t} else {\n\t\t\tpoll_avail();\n\t\t}\n\t\tif (do_sleep)\n\t\t\tdisable_kick();\n\t\tcompleted_before = completed;\n\t\twhile (__builtin_expect(use_buf(&len, &buf), true)) {\n\t\t\tif (do_sleep)\n\t\t\t\tcall_used();\n\t\t\t++completed;\n\t\t\tif (__builtin_expect(completed == bufs, false))\n\t\t\t\treturn;\n\t\t}\n\t\tif (completed == completed_before)\n\t\t\t++spurious;\n\t\tassert(completed <= bufs);\n\t\tif (completed == bufs)\n\t\t\tbreak;\n\t}\n}\n\nvoid *start_guest(void *arg)\n{\n\tset_affinity(arg);\n\trun_guest();\n\tpthread_exit(NULL);\n}\n\nvoid *start_host(void *arg)\n{\n\tset_affinity(arg);\n\trun_host();\n\tpthread_exit(NULL);\n}\n\nstatic const char optstring[] = \"\";\nstatic const struct option longopts[] = {\n\t{\n\t\t.name = \"help\",\n\t\t.has_arg = no_argument,\n\t\t.val = 'h',\n\t},\n\t{\n\t\t.name = \"host-affinity\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'H',\n\t},\n\t{\n\t\t.name = \"guest-affinity\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'G',\n\t},\n\t{\n\t\t.name = \"ring-size\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'R',\n\t},\n\t{\n\t\t.name = \"run-cycles\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'C',\n\t},\n\t{\n\t\t.name = \"outstanding\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'o',\n\t},\n\t{\n\t\t.name = \"batch\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'b',\n\t},\n\t{\n\t\t.name = \"param\",\n\t\t.has_arg = required_argument,\n\t\t.val = 'p',\n\t},\n\t{\n\t\t.name = \"sleep\",\n\t\t.has_arg = no_argument,\n\t\t.val = 's',\n\t},\n\t{\n\t\t.name = \"relax\",\n\t\t.has_arg = no_argument,\n\t\t.val = 'x',\n\t},\n\t{\n\t\t.name = \"exit\",\n\t\t.has_arg = no_argument,\n\t\t.val = 'e',\n\t},\n\t{\n\t}\n};\n\nstatic void help(void)\n{\n\tfprintf(stderr, \"Usage: <test> [--help]\"\n\t\t\" [--host-affinity H]\"\n\t\t\" [--guest-affinity G]\"\n\t\t\" [--ring-size R (default: %d)]\"\n\t\t\" [--run-cycles C (default: %d)]\"\n\t\t\" [--batch b]\"\n\t\t\" [--outstanding o]\"\n\t\t\" [--param p]\"\n\t\t\" [--sleep]\"\n\t\t\" [--relax]\"\n\t\t\" [--exit]\"\n\t\t\"\\n\",\n\t\tring_size,\n\t\truncycles);\n}\n\nint main(int argc, char **argv)\n{\n\tint ret;\n\tpthread_t host, guest;\n\tvoid *tret;\n\tchar *host_arg = NULL;\n\tchar *guest_arg = NULL;\n\tchar *endptr;\n\tlong int c;\n\n\tkickfd = eventfd(0, 0);\n\tassert(kickfd >= 0);\n\tcallfd = eventfd(0, 0);\n\tassert(callfd >= 0);\n\n\tfor (;;) {\n\t\tint o = getopt_long(argc, argv, optstring, longopts, NULL);\n\t\tswitch (o) {\n\t\tcase -1:\n\t\t\tgoto done;\n\t\tcase '?':\n\t\t\thelp();\n\t\t\texit(2);\n\t\tcase 'H':\n\t\t\thost_arg = optarg;\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tguest_arg = optarg;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tring_size = strtol(optarg, &endptr, 0);\n\t\t\tassert(ring_size && !(ring_size & (ring_size - 1)));\n\t\t\tassert(!*endptr);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tc = strtol(optarg, &endptr, 0);\n\t\t\tassert(!*endptr);\n\t\t\tassert(c > 0 && c < INT_MAX);\n\t\t\truncycles = c;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tc = strtol(optarg, &endptr, 0);\n\t\t\tassert(!*endptr);\n\t\t\tassert(c > 0 && c < INT_MAX);\n\t\t\tmax_outstanding = c;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tc = strtol(optarg, &endptr, 0);\n\t\t\tassert(!*endptr);\n\t\t\tassert(c > 0 && c < INT_MAX);\n\t\t\tparam = c;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tc = strtol(optarg, &endptr, 0);\n\t\t\tassert(!*endptr);\n\t\t\tassert(c > 0 && c < INT_MAX);\n\t\t\tbatch = c;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tdo_sleep = true;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tdo_relax = true;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdo_exit = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thelp();\n\t\t\texit(4);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tsmp_acquire();\n\tsmp_release();\n\tsmp_mb();\ndone:\n\n\tif (batch > max_outstanding)\n\t\tbatch = max_outstanding;\n\n\tif (optind < argc) {\n\t\thelp();\n\t\texit(4);\n\t}\n\talloc_ring();\n\n\tret = pthread_create(&host, NULL, start_host, host_arg);\n\tassert(!ret);\n\tret = pthread_create(&guest, NULL, start_guest, guest_arg);\n\tassert(!ret);\n\n\tret = pthread_join(guest, &tret);\n\tassert(!ret);\n\tret = pthread_join(host, &tret);\n\tassert(!ret);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}