{
  "module_name": "trace-agent-rw.c",
  "hash_id": "4747349b89f0baade52911cbaa8d433c86b0e460e358f86ce19103adc7464ff1",
  "original_prompt": "Ingested from linux-6.6.14/tools/virtio/virtio-trace/trace-agent-rw.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include \"trace-agent.h\"\n\n#define READ_WAIT_USEC\t100000\n\nvoid *rw_thread_info_new(void)\n{\n\tstruct rw_thread_info *rw_ti;\n\n\trw_ti = zalloc(sizeof(struct rw_thread_info));\n\tif (rw_ti == NULL) {\n\t\tpr_err(\"rw_thread_info zalloc error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\trw_ti->cpu_num = -1;\n\trw_ti->in_fd = -1;\n\trw_ti->out_fd = -1;\n\trw_ti->read_pipe = -1;\n\trw_ti->write_pipe = -1;\n\trw_ti->pipe_size = PIPE_INIT;\n\n\treturn rw_ti;\n}\n\nvoid *rw_thread_init(int cpu, const char *in_path, const char *out_path,\n\t\t\t\tbool stdout_flag, unsigned long pipe_size,\n\t\t\t\tstruct rw_thread_info *rw_ti)\n{\n\tint data_pipe[2];\n\n\trw_ti->cpu_num = cpu;\n\n\t \n\trw_ti->in_fd = open(in_path, O_RDONLY);\n\tif (rw_ti->in_fd == -1) {\n\t\tpr_err(\"Could not open in_fd (CPU:%d)\\n\", cpu);\n\t\tgoto error;\n\t}\n\n\t \n\tif (!stdout_flag) {\n\t\t \n\t\trw_ti->out_fd = open(out_path, O_WRONLY);\n\t\tif (rw_ti->out_fd == -1) {\n\t\t\tpr_err(\"Could not open out_fd (CPU:%d)\\n\", cpu);\n\t\t\tgoto error;\n\t\t}\n\t} else\n\t\t \n\t\trw_ti->out_fd = STDOUT_FILENO;\n\n\tif (pipe2(data_pipe, O_NONBLOCK) < 0) {\n\t\tpr_err(\"Could not create pipe in rw-thread(%d)\\n\", cpu);\n\t\tgoto error;\n\t}\n\n\t \n\tif (fcntl(*data_pipe, F_SETPIPE_SZ, pipe_size) < 0) {\n\t\tpr_err(\"Could not change pipe size in rw-thread(%d)\\n\", cpu);\n\t\tgoto error;\n\t}\n\n\trw_ti->read_pipe = data_pipe[1];\n\trw_ti->write_pipe = data_pipe[0];\n\trw_ti->pipe_size = pipe_size;\n\n\treturn NULL;\n\nerror:\n\texit(EXIT_FAILURE);\n}\n\n \nstatic void bind_cpu(int cpu_num)\n{\n\tcpu_set_t mask;\n\n\tCPU_ZERO(&mask);\n\tCPU_SET(cpu_num, &mask);\n\n\t \n\tif (sched_setaffinity(0, sizeof(mask), &mask) == -1)\n\t\tpr_err(\"Could not set CPU#%d affinity\\n\", (int)cpu_num);\n}\n\nstatic void *rw_thread_main(void *thread_info)\n{\n\tssize_t rlen, wlen;\n\tssize_t ret;\n\tstruct rw_thread_info *ts = (struct rw_thread_info *)thread_info;\n\n\tbind_cpu(ts->cpu_num);\n\n\twhile (1) {\n\t\t \n\t\tif (!global_run_operation) {\n\t\t\tpthread_mutex_lock(&mutex_notify);\n\t\t\tpthread_cond_wait(&cond_wakeup, &mutex_notify);\n\t\t\tpthread_mutex_unlock(&mutex_notify);\n\t\t}\n\n\t\tif (global_sig_receive)\n\t\t\tbreak;\n\n\t\t \n\t\trlen = splice(ts->in_fd, NULL, ts->read_pipe, NULL,\n\t\t\t\tts->pipe_size, SPLICE_F_MOVE | SPLICE_F_MORE);\n\n\t\tif (rlen < 0) {\n\t\t\tpr_err(\"Splice_read in rw-thread(%d)\\n\", ts->cpu_num);\n\t\t\tgoto error;\n\t\t} else if (rlen == 0) {\n\t\t\t \n\t\t\tusleep(READ_WAIT_USEC);\n\t\t\tpr_debug(\"Read retry(cpu:%d)\\n\", ts->cpu_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\twlen = 0;\n\n\t\tdo {\n\t\t\tret = splice(ts->write_pipe, NULL, ts->out_fd, NULL,\n\t\t\t\t\trlen - wlen,\n\t\t\t\t\tSPLICE_F_MOVE | SPLICE_F_MORE);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"Splice_write in rw-thread(%d)\\n\",\n\t\t\t\t\t\t\t\tts->cpu_num);\n\t\t\t\tgoto error;\n\t\t\t} else if (ret == 0)\n\t\t\t\t \n\t\t\t\tsleep(1);\n\t\t\twlen += ret;\n\t\t} while (wlen < rlen);\n\t}\n\n\treturn NULL;\n\nerror:\n\texit(EXIT_FAILURE);\n}\n\n\npthread_t rw_thread_run(struct rw_thread_info *rw_ti)\n{\n\tint ret;\n\tpthread_t rw_thread_per_cpu;\n\n\tret = pthread_create(&rw_thread_per_cpu, NULL, rw_thread_main, rw_ti);\n\tif (ret != 0) {\n\t\tpr_err(\"Could not create a rw thread(%d)\\n\", rw_ti->cpu_num);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn rw_thread_per_cpu;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}