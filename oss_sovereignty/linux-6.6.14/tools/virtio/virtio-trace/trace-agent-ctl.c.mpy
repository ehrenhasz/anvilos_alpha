{
  "module_name": "trace-agent-ctl.c",
  "hash_id": "7b53fd101d9dd543860a0b1c6c43a0b8a4bb8810e0d2fb55dd9a18c165982326",
  "original_prompt": "Ingested from linux-6.6.14/tools/virtio/virtio-trace/trace-agent-ctl.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <fcntl.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"trace-agent.h\"\n\n#define HOST_MSG_SIZE\t\t256\n#define EVENT_WAIT_MSEC\t\t100\n\nstatic volatile sig_atomic_t global_signal_val;\nbool global_sig_receive;\t \nbool global_run_operation;\t \n\n \nstatic void signal_handler(int sig)\n{\n\tglobal_signal_val = sig;\n}\n\nint rw_ctl_init(const char *ctl_path)\n{\n\tint ctl_fd;\n\n\tctl_fd = open(ctl_path, O_RDONLY);\n\tif (ctl_fd == -1) {\n\t\tpr_err(\"Cannot open ctl_fd\\n\");\n\t\tgoto error;\n\t}\n\n\treturn ctl_fd;\n\nerror:\n\texit(EXIT_FAILURE);\n}\n\nstatic int wait_order(int ctl_fd)\n{\n\tstruct pollfd poll_fd;\n\tint ret = 0;\n\n\twhile (!global_sig_receive) {\n\t\tpoll_fd.fd = ctl_fd;\n\t\tpoll_fd.events = POLLIN;\n\n\t\tret = poll(&poll_fd, 1, EVENT_WAIT_MSEC);\n\n\t\tif (global_signal_val) {\n\t\t\tglobal_sig_receive = true;\n\t\t\tpr_info(\"Receive interrupt %d\\n\", global_signal_val);\n\n\t\t\t \n\t\t\tif (!global_run_operation)\n\t\t\t\tpthread_cond_broadcast(&cond_wakeup);\n\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Polling error\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n\nerror:\n\texit(EXIT_FAILURE);\n}\n\n \nvoid *rw_ctl_loop(int ctl_fd)\n{\n\tssize_t rlen;\n\tchar buf[HOST_MSG_SIZE];\n\tint ret;\n\n\t \n\tsignal(SIGTERM, signal_handler);\n\tsignal(SIGINT, signal_handler);\n\tsignal(SIGQUIT, signal_handler);\n\n\twhile (!global_sig_receive) {\n\n\t\tret = wait_order(ctl_fd);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\trlen = read(ctl_fd, buf, sizeof(buf));\n\t\tif (rlen < 0) {\n\t\t\tpr_err(\"read data error in ctl thread\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (rlen == 2 && buf[0] == '1') {\n\t\t\t \n\t\t\tglobal_run_operation = true;\n\t\t\tpthread_cond_broadcast(&cond_wakeup);\n\t\t\tpr_debug(\"Wake up all read/write threads\\n\");\n\t\t} else if (rlen == 2 && buf[0] == '0') {\n\t\t\t \n\t\t\tglobal_run_operation = false;\n\t\t\tpr_debug(\"Stop all read/write threads\\n\");\n\t\t} else\n\t\t\tpr_info(\"Invalid host notification: %s\\n\", buf);\n\t}\n\n\treturn NULL;\n\nerror:\n\texit(EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}