{
  "module_name": "trace-agent.c",
  "hash_id": "be3ab149a9adb92ded177059bb306a5cd96a99bf1524e58b1a5f4d2230a33d02",
  "original_prompt": "Ingested from linux-6.6.14/tools/virtio/virtio-trace/trace-agent.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"trace-agent.h\"\n\n#define PAGE_SIZE\t\t(sysconf(_SC_PAGE_SIZE))\n#define PIPE_DEF_BUFS\t\t16\n#define PIPE_MIN_SIZE\t\t(PAGE_SIZE*PIPE_DEF_BUFS)\n#define PIPE_MAX_SIZE\t\t(1024*1024)\n#define TRACEFS \t\t\"/sys/kernel/tracing\"\n#define DEBUGFS \t\t\"/sys/kernel/debug/tracing\"\n#define READ_PATH_FMT\t\t\"%s/per_cpu/cpu%d/trace_pipe_raw\"\n#define WRITE_PATH_FMT\t\t\"/dev/virtio-ports/trace-path-cpu%d\"\n#define CTL_PATH\t\t\"/dev/virtio-ports/agent-ctl-path\"\n\npthread_mutex_t mutex_notify = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond_wakeup = PTHREAD_COND_INITIALIZER;\n\nstatic int get_total_cpus(void)\n{\n\tint nr_cpus = (int)sysconf(_SC_NPROCESSORS_CONF);\n\n\tif (nr_cpus <= 0) {\n\t\tpr_err(\"Could not read cpus\\n\");\n\t\tgoto error;\n\t} else if (nr_cpus > MAX_CPUS) {\n\t\tpr_err(\"Exceed max cpus(%d)\\n\", (int)MAX_CPUS);\n\t\tgoto error;\n\t}\n\n\treturn nr_cpus;\n\nerror:\n\texit(EXIT_FAILURE);\n}\n\nstatic void *agent_info_new(void)\n{\n\tstruct agent_info *s;\n\tint i;\n\n\ts = zalloc(sizeof(struct agent_info));\n\tif (s == NULL) {\n\t\tpr_err(\"agent_info zalloc error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\ts->pipe_size = PIPE_INIT;\n\ts->use_stdout = false;\n\ts->cpus = get_total_cpus();\n\ts->ctl_fd = -1;\n\n\t \n\tfor (i = 0; i < s->cpus; i++)\n\t\ts->rw_ti[i] = rw_thread_info_new();\n\n\treturn s;\n}\n\nstatic unsigned long parse_size(const char *arg)\n{\n\tunsigned long value, round;\n\tchar *ptr;\n\n\tvalue = strtoul(arg, &ptr, 10);\n\tswitch (*ptr) {\n\tcase 'K': case 'k':\n\t\tvalue <<= 10;\n\t\tbreak;\n\tcase 'M': case 'm':\n\t\tvalue <<= 20;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (value > PIPE_MAX_SIZE) {\n\t\tpr_err(\"Pipe size must be less than 1MB\\n\");\n\t\tgoto error;\n\t} else if (value < PIPE_MIN_SIZE) {\n\t\tpr_err(\"Pipe size must be over 64KB\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tround = value & (PAGE_SIZE - 1);\n\tvalue = value - round;\n\n\treturn value;\nerror:\n\treturn 0;\n}\n\nstatic void usage(char const *prg)\n{\n\tpr_err(\"usage: %s [-h] [-o] [-s <size of pipe>]\\n\", prg);\n}\n\nstatic const char *make_path(int cpu_num, bool this_is_write_path)\n{\n\tint ret;\n\tchar *buf;\n\n\tbuf = zalloc(PATH_MAX);\n\tif (buf == NULL) {\n\t\tpr_err(\"Could not allocate buffer\\n\");\n\t\tgoto error;\n\t}\n\n\tif (this_is_write_path)\n\t\t \n\t\tret = snprintf(buf, PATH_MAX, WRITE_PATH_FMT, cpu_num);\n\telse {\n\t\t \n\t\tret = snprintf(buf, PATH_MAX, READ_PATH_FMT, TRACEFS, cpu_num);\n\t\tif (ret > 0 && access(buf, F_OK) != 0)\n\t\t\tret = snprintf(buf, PATH_MAX, READ_PATH_FMT, DEBUGFS, cpu_num);\n\t}\n\n\tif (ret <= 0) {\n\t\tpr_err(\"Failed to generate %s path(CPU#%d):%d\\n\",\n\t\t\tthis_is_write_path ? \"read\" : \"write\", cpu_num, ret);\n\t\tgoto error;\n\t}\n\n\treturn buf;\n\nerror:\n\tfree(buf);\n\treturn NULL;\n}\n\nstatic const char *make_input_path(int cpu_num)\n{\n\treturn make_path(cpu_num, false);\n}\n\nstatic const char *make_output_path(int cpu_num)\n{\n\treturn make_path(cpu_num, true);\n}\n\nstatic void *agent_info_init(struct agent_info *s)\n{\n\tint cpu;\n\tconst char *in_path = NULL;\n\tconst char *out_path = NULL;\n\n\t \n\tfor (cpu = 0; cpu < s->cpus; cpu++) {\n\t\t \n\t\tin_path = make_input_path(cpu);\n\t\tif (in_path == NULL)\n\t\t\tgoto error;\n\n\t\t \n\t\tif (!s->use_stdout) {\n\t\t\tout_path = make_output_path(cpu);\n\t\t\tif (out_path == NULL)\n\t\t\t\tgoto error;\n\t\t} else\n\t\t\t \n\t\t\tpr_debug(\"stdout mode\\n\");\n\n\t\trw_thread_init(cpu, in_path, out_path, s->use_stdout,\n\t\t\t\t\t\ts->pipe_size, s->rw_ti[cpu]);\n\t}\n\n\t \n\ts->ctl_fd = rw_ctl_init((const char *)CTL_PATH);\n\n\treturn NULL;\n\nerror:\n\texit(EXIT_FAILURE);\n}\n\nstatic void *parse_args(int argc, char *argv[], struct agent_info *s)\n{\n\tint cmd;\n\tunsigned long size;\n\n\twhile ((cmd = getopt(argc, argv, \"hos:\")) != -1) {\n\t\tswitch (cmd) {\n\t\t \n\t\tcase 'o':\n\t\t\ts->use_stdout = true;\n\t\t\tbreak;\n\t\t \n\t\tcase 's':\n\t\t\tsize = parse_size(optarg);\n\t\t\tif (size == 0)\n\t\t\t\tgoto error;\n\t\t\ts->pipe_size = size;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tagent_info_init(s);\n\n\treturn NULL;\n\nerror:\n\texit(EXIT_FAILURE);\n}\n\nstatic void agent_main_loop(struct agent_info *s)\n{\n\tint cpu;\n\tpthread_t rw_thread_per_cpu[MAX_CPUS];\n\n\t \n\tfor (cpu = 0; cpu < s->cpus; cpu++)\n\t\trw_thread_per_cpu[cpu] = rw_thread_run(s->rw_ti[cpu]);\n\n\trw_ctl_loop(s->ctl_fd);\n\n\t \n\tfor (cpu = 0; cpu < s->cpus; cpu++) {\n\t\tint ret;\n\n\t\tret = pthread_join(rw_thread_per_cpu[cpu], NULL);\n\t\tif (ret != 0) {\n\t\t\tpr_err(\"pthread_join() error:%d (cpu %d)\\n\", ret, cpu);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n}\n\nstatic void agent_info_free(struct agent_info *s)\n{\n\tint i;\n\n\tclose(s->ctl_fd);\n\tfor (i = 0; i < s->cpus; i++) {\n\t\tclose(s->rw_ti[i]->in_fd);\n\t\tclose(s->rw_ti[i]->out_fd);\n\t\tclose(s->rw_ti[i]->read_pipe);\n\t\tclose(s->rw_ti[i]->write_pipe);\n\t\tfree(s->rw_ti[i]);\n\t}\n\tfree(s);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct agent_info *s = NULL;\n\n\ts = agent_info_new();\n\tparse_args(argc, argv, s);\n\n\tagent_main_loop(s);\n\n\tagent_info_free(s);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}