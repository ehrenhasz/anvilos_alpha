{
  "module_name": "virtio_test.c",
  "hash_id": "82c73586f2e598b2d9a0301fc3224f1116df88d68ae019c9203519ee056be6d7",
  "original_prompt": "Ingested from linux-6.6.14/tools/virtio/virtio_test.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <getopt.h>\n#include <limits.h>\n#include <string.h>\n#include <poll.h>\n#include <sys/eventfd.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include <linux/virtio_types.h>\n#include <linux/vhost.h>\n#include <linux/virtio.h>\n#include <linux/virtio_ring.h>\n#include \"../../drivers/vhost/test.h\"\n\n#define RANDOM_BATCH -1\n\n \nvoid *__kmalloc_fake, *__kfree_ignore_start, *__kfree_ignore_end;\n\nstruct vq_info {\n\tint kick;\n\tint call;\n\tint num;\n\tint idx;\n\tvoid *ring;\n\t \n\tstruct vring vring;\n\tstruct virtqueue *vq;\n};\n\nstruct vdev_info {\n\tstruct virtio_device vdev;\n\tint control;\n\tstruct pollfd fds[1];\n\tstruct vq_info vqs[1];\n\tint nvqs;\n\tvoid *buf;\n\tsize_t buf_size;\n\tstruct vhost_memory *mem;\n};\n\nstatic const struct vhost_vring_file no_backend = { .fd = -1 },\n\t\t\t\t     backend = { .fd = 1 };\nstatic const struct vhost_vring_state null_state = {};\n\nbool vq_notify(struct virtqueue *vq)\n{\n\tstruct vq_info *info = vq->priv;\n\tunsigned long long v = 1;\n\tint r;\n\tr = write(info->kick, &v, sizeof v);\n\tassert(r == sizeof v);\n\treturn true;\n}\n\nvoid vq_callback(struct virtqueue *vq)\n{\n}\n\n\nvoid vhost_vq_setup(struct vdev_info *dev, struct vq_info *info)\n{\n\tstruct vhost_vring_state state = { .index = info->idx };\n\tstruct vhost_vring_file file = { .index = info->idx };\n\tunsigned long long features = dev->vdev.features;\n\tstruct vhost_vring_addr addr = {\n\t\t.index = info->idx,\n\t\t.desc_user_addr = (uint64_t)(unsigned long)info->vring.desc,\n\t\t.avail_user_addr = (uint64_t)(unsigned long)info->vring.avail,\n\t\t.used_user_addr = (uint64_t)(unsigned long)info->vring.used,\n\t};\n\tint r;\n\tr = ioctl(dev->control, VHOST_SET_FEATURES, &features);\n\tassert(r >= 0);\n\tstate.num = info->vring.num;\n\tr = ioctl(dev->control, VHOST_SET_VRING_NUM, &state);\n\tassert(r >= 0);\n\tstate.num = 0;\n\tr = ioctl(dev->control, VHOST_SET_VRING_BASE, &state);\n\tassert(r >= 0);\n\tr = ioctl(dev->control, VHOST_SET_VRING_ADDR, &addr);\n\tassert(r >= 0);\n\tfile.fd = info->kick;\n\tr = ioctl(dev->control, VHOST_SET_VRING_KICK, &file);\n\tassert(r >= 0);\n\tfile.fd = info->call;\n\tr = ioctl(dev->control, VHOST_SET_VRING_CALL, &file);\n\tassert(r >= 0);\n}\n\nstatic void vq_reset(struct vq_info *info, int num, struct virtio_device *vdev)\n{\n\tif (info->vq)\n\t\tvring_del_virtqueue(info->vq);\n\n\tmemset(info->ring, 0, vring_size(num, 4096));\n\tvring_init(&info->vring, num, info->ring, 4096);\n\tinfo->vq = vring_new_virtqueue(info->idx, num, 4096, vdev, true, false,\n\t\t\t\t       info->ring, vq_notify, vq_callback, \"test\");\n\tassert(info->vq);\n\tinfo->vq->priv = info;\n}\n\nstatic void vq_info_add(struct vdev_info *dev, int num)\n{\n\tstruct vq_info *info = &dev->vqs[dev->nvqs];\n\tint r;\n\tinfo->idx = dev->nvqs;\n\tinfo->kick = eventfd(0, EFD_NONBLOCK);\n\tinfo->call = eventfd(0, EFD_NONBLOCK);\n\tr = posix_memalign(&info->ring, 4096, vring_size(num, 4096));\n\tassert(r >= 0);\n\tvq_reset(info, num, &dev->vdev);\n\tvhost_vq_setup(dev, info);\n\tdev->fds[info->idx].fd = info->call;\n\tdev->fds[info->idx].events = POLLIN;\n\tdev->nvqs++;\n}\n\nstatic void vdev_info_init(struct vdev_info* dev, unsigned long long features)\n{\n\tint r;\n\tmemset(dev, 0, sizeof *dev);\n\tdev->vdev.features = features;\n\tINIT_LIST_HEAD(&dev->vdev.vqs);\n\tspin_lock_init(&dev->vdev.vqs_list_lock);\n\tdev->buf_size = 1024;\n\tdev->buf = malloc(dev->buf_size);\n\tassert(dev->buf);\n\tdev->control = open(\"/dev/vhost-test\", O_RDWR);\n\tassert(dev->control >= 0);\n\tr = ioctl(dev->control, VHOST_SET_OWNER, NULL);\n\tassert(r >= 0);\n\tdev->mem = malloc(offsetof(struct vhost_memory, regions) +\n\t\t\t  sizeof dev->mem->regions[0]);\n\tassert(dev->mem);\n\tmemset(dev->mem, 0, offsetof(struct vhost_memory, regions) +\n                          sizeof dev->mem->regions[0]);\n\tdev->mem->nregions = 1;\n\tdev->mem->regions[0].guest_phys_addr = (long)dev->buf;\n\tdev->mem->regions[0].userspace_addr = (long)dev->buf;\n\tdev->mem->regions[0].memory_size = dev->buf_size;\n\tr = ioctl(dev->control, VHOST_SET_MEM_TABLE, dev->mem);\n\tassert(r >= 0);\n}\n\n \nstatic void wait_for_interrupt(struct vdev_info *dev)\n{\n\tint i;\n\tunsigned long long val;\n\tpoll(dev->fds, dev->nvqs, -1);\n\tfor (i = 0; i < dev->nvqs; ++i)\n\t\tif (dev->fds[i].revents & POLLIN) {\n\t\t\tread(dev->fds[i].fd, &val, sizeof val);\n\t\t}\n}\n\nstatic void run_test(struct vdev_info *dev, struct vq_info *vq,\n\t\t     bool delayed, int batch, int reset_n, int bufs)\n{\n\tstruct scatterlist sl;\n\tlong started = 0, completed = 0, next_reset = reset_n;\n\tlong completed_before, started_before;\n\tint r, test = 1;\n\tunsigned int len;\n\tlong long spurious = 0;\n\tconst bool random_batch = batch == RANDOM_BATCH;\n\n\tr = ioctl(dev->control, VHOST_TEST_RUN, &test);\n\tassert(r >= 0);\n\tif (!reset_n) {\n\t\tnext_reset = INT_MAX;\n\t}\n\n\tfor (;;) {\n\t\tvirtqueue_disable_cb(vq->vq);\n\t\tcompleted_before = completed;\n\t\tstarted_before = started;\n\t\tdo {\n\t\t\tconst bool reset = completed > next_reset;\n\t\t\tif (random_batch)\n\t\t\t\tbatch = (random() % vq->vring.num) + 1;\n\n\t\t\twhile (started < bufs &&\n\t\t\t       (started - completed) < batch) {\n\t\t\t\tsg_init_one(&sl, dev->buf, dev->buf_size);\n\t\t\t\tr = virtqueue_add_outbuf(vq->vq, &sl, 1,\n\t\t\t\t\t\t\t dev->buf + started,\n\t\t\t\t\t\t\t GFP_ATOMIC);\n\t\t\t\tif (unlikely(r != 0)) {\n\t\t\t\t\tif (r == -ENOSPC &&\n\t\t\t\t\t    started > started_before)\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t++started;\n\n\t\t\t\tif (unlikely(!virtqueue_kick(vq->vq))) {\n\t\t\t\t\tr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (started >= bufs)\n\t\t\t\tr = -1;\n\n\t\t\tif (reset) {\n\t\t\t\tr = ioctl(dev->control, VHOST_TEST_SET_BACKEND,\n\t\t\t\t\t  &no_backend);\n\t\t\t\tassert(!r);\n\t\t\t}\n\n\t\t\t \n\t\t\twhile (virtqueue_get_buf(vq->vq, &len)) {\n\t\t\t\t++completed;\n\t\t\t\tr = 0;\n\t\t\t}\n\n\t\t\tif (reset) {\n\t\t\t\tstruct vhost_vring_state s = { .index = 0 };\n\n\t\t\t\tvq_reset(vq, vq->vring.num, &dev->vdev);\n\n\t\t\t\tr = ioctl(dev->control, VHOST_GET_VRING_BASE,\n\t\t\t\t\t  &s);\n\t\t\t\tassert(!r);\n\n\t\t\t\ts.num = 0;\n\t\t\t\tr = ioctl(dev->control, VHOST_SET_VRING_BASE,\n\t\t\t\t\t  &null_state);\n\t\t\t\tassert(!r);\n\n\t\t\t\tr = ioctl(dev->control, VHOST_TEST_SET_BACKEND,\n\t\t\t\t\t  &backend);\n\t\t\t\tassert(!r);\n\n\t\t\t\tstarted = completed;\n\t\t\t\twhile (completed > next_reset)\n\t\t\t\t\tnext_reset += completed;\n\t\t\t}\n\t\t} while (r == 0);\n\t\tif (completed == completed_before && started == started_before)\n\t\t\t++spurious;\n\t\tassert(completed <= bufs);\n\t\tassert(started <= bufs);\n\t\tif (completed == bufs)\n\t\t\tbreak;\n\t\tif (delayed) {\n\t\t\tif (virtqueue_enable_cb_delayed(vq->vq))\n\t\t\t\twait_for_interrupt(dev);\n\t\t} else {\n\t\t\tif (virtqueue_enable_cb(vq->vq))\n\t\t\t\twait_for_interrupt(dev);\n\t\t}\n\t}\n\ttest = 0;\n\tr = ioctl(dev->control, VHOST_TEST_RUN, &test);\n\tassert(r >= 0);\n\tfprintf(stderr,\n\t\t\"spurious wakeups: 0x%llx started=0x%lx completed=0x%lx\\n\",\n\t\tspurious, started, completed);\n}\n\nconst char optstring[] = \"h\";\nconst struct option longopts[] = {\n\t{\n\t\t.name = \"help\",\n\t\t.val = 'h',\n\t},\n\t{\n\t\t.name = \"event-idx\",\n\t\t.val = 'E',\n\t},\n\t{\n\t\t.name = \"no-event-idx\",\n\t\t.val = 'e',\n\t},\n\t{\n\t\t.name = \"indirect\",\n\t\t.val = 'I',\n\t},\n\t{\n\t\t.name = \"no-indirect\",\n\t\t.val = 'i',\n\t},\n\t{\n\t\t.name = \"virtio-1\",\n\t\t.val = '1',\n\t},\n\t{\n\t\t.name = \"no-virtio-1\",\n\t\t.val = '0',\n\t},\n\t{\n\t\t.name = \"delayed-interrupt\",\n\t\t.val = 'D',\n\t},\n\t{\n\t\t.name = \"no-delayed-interrupt\",\n\t\t.val = 'd',\n\t},\n\t{\n\t\t.name = \"batch\",\n\t\t.val = 'b',\n\t\t.has_arg = required_argument,\n\t},\n\t{\n\t\t.name = \"reset\",\n\t\t.val = 'r',\n\t\t.has_arg = optional_argument,\n\t},\n\t{\n\t}\n};\n\nstatic void help(int status)\n{\n\tfprintf(stderr, \"Usage: virtio_test [--help]\"\n\t\t\" [--no-indirect]\"\n\t\t\" [--no-event-idx]\"\n\t\t\" [--no-virtio-1]\"\n\t\t\" [--delayed-interrupt]\"\n\t\t\" [--batch=random/N]\"\n\t\t\" [--reset=N]\"\n\t\t\"\\n\");\n\n\texit(status);\n}\n\nint main(int argc, char **argv)\n{\n\tstruct vdev_info dev;\n\tunsigned long long features = (1ULL << VIRTIO_RING_F_INDIRECT_DESC) |\n\t\t(1ULL << VIRTIO_RING_F_EVENT_IDX) | (1ULL << VIRTIO_F_VERSION_1);\n\tlong batch = 1, reset = 0;\n\tint o;\n\tbool delayed = false;\n\n\tfor (;;) {\n\t\to = getopt_long(argc, argv, optstring, longopts, NULL);\n\t\tswitch (o) {\n\t\tcase -1:\n\t\t\tgoto done;\n\t\tcase '?':\n\t\t\thelp(2);\n\t\tcase 'e':\n\t\t\tfeatures &= ~(1ULL << VIRTIO_RING_F_EVENT_IDX);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thelp(0);\n\t\tcase 'i':\n\t\t\tfeatures &= ~(1ULL << VIRTIO_RING_F_INDIRECT_DESC);\n\t\t\tbreak;\n\t\tcase '0':\n\t\t\tfeatures &= ~(1ULL << VIRTIO_F_VERSION_1);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdelayed = true;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (0 == strcmp(optarg, \"random\")) {\n\t\t\t\tbatch = RANDOM_BATCH;\n\t\t\t} else {\n\t\t\t\tbatch = strtol(optarg, NULL, 10);\n\t\t\t\tassert(batch > 0);\n\t\t\t\tassert(batch < (long)INT_MAX + 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (!optarg) {\n\t\t\t\treset = 1;\n\t\t\t} else {\n\t\t\t\treset = strtol(optarg, NULL, 10);\n\t\t\t\tassert(reset > 0);\n\t\t\t\tassert(reset < (long)INT_MAX + 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tvdev_info_init(&dev, features);\n\tvq_info_add(&dev, 256);\n\trun_test(&dev, &dev.vqs[0], delayed, batch, reset, 0x100000);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}