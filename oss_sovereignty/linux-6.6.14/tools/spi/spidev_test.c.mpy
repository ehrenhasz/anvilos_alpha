{
  "module_name": "spidev_test.c",
  "hash_id": "34d241af270662a5d67363e95fd82d6e6c4c5b50107c4b82d37d34896d8da5c0",
  "original_prompt": "Ingested from linux-6.6.14/tools/spi/spidev_test.c",
  "human_readable_source": "\n \n\n#include <stdint.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <time.h>\n#include <sys/ioctl.h>\n#include <linux/ioctl.h>\n#include <sys/stat.h>\n#include <linux/types.h>\n#include <linux/spi/spidev.h>\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n\nstatic void pabort(const char *s)\n{\n\tif (errno != 0)\n\t\tperror(s);\n\telse\n\t\tprintf(\"%s\\n\", s);\n\n\tabort();\n}\n\nstatic const char *device = \"/dev/spidev1.1\";\nstatic uint32_t mode;\nstatic uint8_t bits = 8;\nstatic char *input_file;\nstatic char *output_file;\nstatic uint32_t speed = 500000;\nstatic uint16_t delay;\nstatic int verbose;\nstatic int transfer_size;\nstatic int iterations;\nstatic int interval = 5;  \n\nstatic uint8_t default_tx[] = {\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0x40, 0x00, 0x00, 0x00, 0x00, 0x95,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xF0, 0x0D,\n};\n\nstatic uint8_t default_rx[ARRAY_SIZE(default_tx)] = {0, };\nstatic char *input_tx;\n\nstatic void hex_dump(const void *src, size_t length, size_t line_size,\n\t\t     char *prefix)\n{\n\tint i = 0;\n\tconst unsigned char *address = src;\n\tconst unsigned char *line = address;\n\tunsigned char c;\n\n\tprintf(\"%s | \", prefix);\n\twhile (length-- > 0) {\n\t\tprintf(\"%02X \", *address++);\n\t\tif (!(++i % line_size) || (length == 0 && i % line_size)) {\n\t\t\tif (length == 0) {\n\t\t\t\twhile (i++ % line_size)\n\t\t\t\t\tprintf(\"__ \");\n\t\t\t}\n\t\t\tprintf(\" |\");\n\t\t\twhile (line < address) {\n\t\t\t\tc = *line++;\n\t\t\t\tprintf(\"%c\", (c < 32 || c > 126) ? '.' : c);\n\t\t\t}\n\t\t\tprintf(\"|\\n\");\n\t\t\tif (length > 0)\n\t\t\t\tprintf(\"%s | \", prefix);\n\t\t}\n\t}\n}\n\n \nstatic int unescape(char *_dst, char *_src, size_t len)\n{\n\tint ret = 0;\n\tint match;\n\tchar *src = _src;\n\tchar *dst = _dst;\n\tunsigned int ch;\n\n\twhile (*src) {\n\t\tif (*src == '\\\\' && *(src+1) == 'x') {\n\t\t\tmatch = sscanf(src + 2, \"%2x\", &ch);\n\t\t\tif (!match)\n\t\t\t\tpabort(\"malformed input string\");\n\n\t\t\tsrc += 4;\n\t\t\t*dst++ = (unsigned char)ch;\n\t\t} else {\n\t\t\t*dst++ = *src++;\n\t\t}\n\t\tret++;\n\t}\n\treturn ret;\n}\n\nstatic void transfer(int fd, uint8_t const *tx, uint8_t const *rx, size_t len)\n{\n\tint ret;\n\tint out_fd;\n\tstruct spi_ioc_transfer tr = {\n\t\t.tx_buf = (unsigned long)tx,\n\t\t.rx_buf = (unsigned long)rx,\n\t\t.len = len,\n\t\t.delay_usecs = delay,\n\t\t.speed_hz = speed,\n\t\t.bits_per_word = bits,\n\t};\n\n\tif (mode & SPI_TX_OCTAL)\n\t\ttr.tx_nbits = 8;\n\telse if (mode & SPI_TX_QUAD)\n\t\ttr.tx_nbits = 4;\n\telse if (mode & SPI_TX_DUAL)\n\t\ttr.tx_nbits = 2;\n\tif (mode & SPI_RX_OCTAL)\n\t\ttr.rx_nbits = 8;\n\telse if (mode & SPI_RX_QUAD)\n\t\ttr.rx_nbits = 4;\n\telse if (mode & SPI_RX_DUAL)\n\t\ttr.rx_nbits = 2;\n\tif (!(mode & SPI_LOOP)) {\n\t\tif (mode & (SPI_TX_OCTAL | SPI_TX_QUAD | SPI_TX_DUAL))\n\t\t\ttr.rx_buf = 0;\n\t\telse if (mode & (SPI_RX_OCTAL | SPI_RX_QUAD | SPI_RX_DUAL))\n\t\t\ttr.tx_buf = 0;\n\t}\n\n\tret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);\n\tif (ret < 1)\n\t\tpabort(\"can't send spi message\");\n\n\tif (verbose)\n\t\thex_dump(tx, len, 32, \"TX\");\n\n\tif (output_file) {\n\t\tout_fd = open(output_file, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n\t\tif (out_fd < 0)\n\t\t\tpabort(\"could not open output file\");\n\n\t\tret = write(out_fd, rx, len);\n\t\tif (ret != len)\n\t\t\tpabort(\"not all bytes written to output file\");\n\n\t\tclose(out_fd);\n\t}\n\n\tif (verbose)\n\t\thex_dump(rx, len, 32, \"RX\");\n}\n\nstatic void print_usage(const char *prog)\n{\n\tprintf(\"Usage: %s [-2348CDFHILMNORSZbdilopsv]\\n\", prog);\n\tputs(\"general device settings:\\n\"\n\t\t \"  -D --device         device to use (default /dev/spidev1.1)\\n\"\n\t\t \"  -s --speed          max speed (Hz)\\n\"\n\t\t \"  -d --delay          delay (usec)\\n\"\n\t\t \"  -l --loop           loopback\\n\"\n\t\t \"spi mode:\\n\"\n\t\t \"  -H --cpha           clock phase\\n\"\n\t\t \"  -O --cpol           clock polarity\\n\"\n\t\t \"  -F --rx-cpha-flip   flip CPHA on Rx only xfer\\n\"\n\t\t \"number of wires for transmission:\\n\"\n\t\t \"  -2 --dual           dual transfer\\n\"\n\t\t \"  -4 --quad           quad transfer\\n\"\n\t\t \"  -8 --octal          octal transfer\\n\"\n\t\t \"  -3 --3wire          SI/SO signals shared\\n\"\n\t\t \"  -Z --3wire-hiz      high impedance turnaround\\n\"\n\t\t \"data:\\n\"\n\t\t \"  -i --input          input data from a file (e.g. \\\"test.bin\\\")\\n\"\n\t\t \"  -o --output         output data to a file (e.g. \\\"results.bin\\\")\\n\"\n\t\t \"  -p                  Send data (e.g. \\\"1234\\\\xde\\\\xad\\\")\\n\"\n\t\t \"  -S --size           transfer size\\n\"\n\t\t \"  -I --iter           iterations\\n\"\n\t\t \"additional parameters:\\n\"\n\t\t \"  -b --bpw            bits per word\\n\"\n\t\t \"  -L --lsb            least significant bit first\\n\"\n\t\t \"  -C --cs-high        chip select active high\\n\"\n\t\t \"  -N --no-cs          no chip select\\n\"\n\t\t \"  -R --ready          slave pulls low to pause\\n\"\n\t\t \"  -M --mosi-idle-low  leave mosi line low when idle\\n\"\n\t\t \"misc:\\n\"\n\t\t \"  -v --verbose        Verbose (show tx buffer)\\n\");\n\texit(1);\n}\n\nstatic void parse_opts(int argc, char *argv[])\n{\n\twhile (1) {\n\t\tstatic const struct option lopts[] = {\n\t\t\t{ \"device\",        1, 0, 'D' },\n\t\t\t{ \"speed\",         1, 0, 's' },\n\t\t\t{ \"delay\",         1, 0, 'd' },\n\t\t\t{ \"loop\",          0, 0, 'l' },\n\t\t\t{ \"cpha\",          0, 0, 'H' },\n\t\t\t{ \"cpol\",          0, 0, 'O' },\n\t\t\t{ \"rx-cpha-flip\",  0, 0, 'F' },\n\t\t\t{ \"dual\",          0, 0, '2' },\n\t\t\t{ \"quad\",          0, 0, '4' },\n\t\t\t{ \"octal\",         0, 0, '8' },\n\t\t\t{ \"3wire\",         0, 0, '3' },\n\t\t\t{ \"3wire-hiz\",     0, 0, 'Z' },\n\t\t\t{ \"input\",         1, 0, 'i' },\n\t\t\t{ \"output\",        1, 0, 'o' },\n\t\t\t{ \"size\",          1, 0, 'S' },\n\t\t\t{ \"iter\",          1, 0, 'I' },\n\t\t\t{ \"bpw\",           1, 0, 'b' },\n\t\t\t{ \"lsb\",           0, 0, 'L' },\n\t\t\t{ \"cs-high\",       0, 0, 'C' },\n\t\t\t{ \"no-cs\",         0, 0, 'N' },\n\t\t\t{ \"ready\",         0, 0, 'R' },\n\t\t\t{ \"mosi-idle-low\", 0, 0, 'M' },\n\t\t\t{ \"verbose\",       0, 0, 'v' },\n\t\t\t{ NULL, 0, 0, 0 },\n\t\t};\n\t\tint c;\n\n\t\tc = getopt_long(argc, argv, \"D:s:d:b:i:o:lHOLC3ZFMNR248p:vS:I:\",\n\t\t\t\tlopts, NULL);\n\n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'D':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tspeed = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdelay = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tbits = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tinput_file = optarg;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\toutput_file = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tmode |= SPI_LOOP;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tmode |= SPI_CPHA;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tmode |= SPI_CPOL;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tmode |= SPI_LSB_FIRST;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tmode |= SPI_CS_HIGH;\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tmode |= SPI_3WIRE;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tmode |= SPI_3WIRE_HIZ;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmode |= SPI_RX_CPHA_FLIP;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tmode |= SPI_MOSI_IDLE_LOW;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tmode |= SPI_NO_CS;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tmode |= SPI_READY;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tinput_tx = optarg;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tmode |= SPI_TX_DUAL;\n\t\t\tbreak;\n\t\tcase '4':\n\t\t\tmode |= SPI_TX_QUAD;\n\t\t\tbreak;\n\t\tcase '8':\n\t\t\tmode |= SPI_TX_OCTAL;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\ttransfer_size = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\titerations = atoi(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_usage(argv[0]);\n\t\t}\n\t}\n\tif (mode & SPI_LOOP) {\n\t\tif (mode & SPI_TX_DUAL)\n\t\t\tmode |= SPI_RX_DUAL;\n\t\tif (mode & SPI_TX_QUAD)\n\t\t\tmode |= SPI_RX_QUAD;\n\t\tif (mode & SPI_TX_OCTAL)\n\t\t\tmode |= SPI_RX_OCTAL;\n\t}\n}\n\nstatic void transfer_escaped_string(int fd, char *str)\n{\n\tsize_t size = strlen(str);\n\tuint8_t *tx;\n\tuint8_t *rx;\n\n\ttx = malloc(size);\n\tif (!tx)\n\t\tpabort(\"can't allocate tx buffer\");\n\n\trx = malloc(size);\n\tif (!rx)\n\t\tpabort(\"can't allocate rx buffer\");\n\n\tsize = unescape((char *)tx, str, size);\n\ttransfer(fd, tx, rx, size);\n\tfree(rx);\n\tfree(tx);\n}\n\nstatic void transfer_file(int fd, char *filename)\n{\n\tssize_t bytes;\n\tstruct stat sb;\n\tint tx_fd;\n\tuint8_t *tx;\n\tuint8_t *rx;\n\n\tif (stat(filename, &sb) == -1)\n\t\tpabort(\"can't stat input file\");\n\n\ttx_fd = open(filename, O_RDONLY);\n\tif (tx_fd < 0)\n\t\tpabort(\"can't open input file\");\n\n\ttx = malloc(sb.st_size);\n\tif (!tx)\n\t\tpabort(\"can't allocate tx buffer\");\n\n\trx = malloc(sb.st_size);\n\tif (!rx)\n\t\tpabort(\"can't allocate rx buffer\");\n\n\tbytes = read(tx_fd, tx, sb.st_size);\n\tif (bytes != sb.st_size)\n\t\tpabort(\"failed to read input file\");\n\n\ttransfer(fd, tx, rx, sb.st_size);\n\tfree(rx);\n\tfree(tx);\n\tclose(tx_fd);\n}\n\nstatic uint64_t _read_count;\nstatic uint64_t _write_count;\n\nstatic void show_transfer_rate(void)\n{\n\tstatic uint64_t prev_read_count, prev_write_count;\n\tdouble rx_rate, tx_rate;\n\n\trx_rate = ((_read_count - prev_read_count) * 8) / (interval*1000.0);\n\ttx_rate = ((_write_count - prev_write_count) * 8) / (interval*1000.0);\n\n\tprintf(\"rate: tx %.1fkbps, rx %.1fkbps\\n\", rx_rate, tx_rate);\n\n\tprev_read_count = _read_count;\n\tprev_write_count = _write_count;\n}\n\nstatic void transfer_buf(int fd, int len)\n{\n\tuint8_t *tx;\n\tuint8_t *rx;\n\tint i;\n\n\ttx = malloc(len);\n\tif (!tx)\n\t\tpabort(\"can't allocate tx buffer\");\n\tfor (i = 0; i < len; i++)\n\t\ttx[i] = random();\n\n\trx = malloc(len);\n\tif (!rx)\n\t\tpabort(\"can't allocate rx buffer\");\n\n\ttransfer(fd, tx, rx, len);\n\n\t_write_count += len;\n\t_read_count += len;\n\n\tif (mode & SPI_LOOP) {\n\t\tif (memcmp(tx, rx, len)) {\n\t\t\tfprintf(stderr, \"transfer error !\\n\");\n\t\t\thex_dump(tx, len, 32, \"TX\");\n\t\t\thex_dump(rx, len, 32, \"RX\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tfree(rx);\n\tfree(tx);\n}\n\nint main(int argc, char *argv[])\n{\n\tint ret = 0;\n\tint fd;\n\tuint32_t request;\n\n\tparse_opts(argc, argv);\n\n\tif (input_tx && input_file)\n\t\tpabort(\"only one of -p and --input may be selected\");\n\n\tfd = open(device, O_RDWR);\n\tif (fd < 0)\n\t\tpabort(\"can't open device\");\n\n\t \n\t \n\trequest = mode;\n\tret = ioctl(fd, SPI_IOC_WR_MODE32, &mode);\n\tif (ret == -1)\n\t\tpabort(\"can't set spi mode\");\n\n\t \n\tret = ioctl(fd, SPI_IOC_RD_MODE32, &mode);\n\tif (ret == -1)\n\t\tpabort(\"can't get spi mode\");\n\t \n\tif (request != mode)\n\t\tprintf(\"WARNING device does not support requested mode 0x%x\\n\",\n\t\t\trequest);\n\n\t \n\tret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);\n\tif (ret == -1)\n\t\tpabort(\"can't set bits per word\");\n\n\tret = ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &bits);\n\tif (ret == -1)\n\t\tpabort(\"can't get bits per word\");\n\n\t \n\tret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);\n\tif (ret == -1)\n\t\tpabort(\"can't set max speed hz\");\n\n\tret = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed);\n\tif (ret == -1)\n\t\tpabort(\"can't get max speed hz\");\n\n\tprintf(\"spi mode: 0x%x\\n\", mode);\n\tprintf(\"bits per word: %u\\n\", bits);\n\tprintf(\"max speed: %u Hz (%u kHz)\\n\", speed, speed/1000);\n\n\tif (input_tx)\n\t\ttransfer_escaped_string(fd, input_tx);\n\telse if (input_file)\n\t\ttransfer_file(fd, input_file);\n\telse if (transfer_size) {\n\t\tstruct timespec last_stat;\n\n\t\tclock_gettime(CLOCK_MONOTONIC, &last_stat);\n\n\t\twhile (iterations-- > 0) {\n\t\t\tstruct timespec current;\n\n\t\t\ttransfer_buf(fd, transfer_size);\n\n\t\t\tclock_gettime(CLOCK_MONOTONIC, &current);\n\t\t\tif (current.tv_sec - last_stat.tv_sec > interval) {\n\t\t\t\tshow_transfer_rate();\n\t\t\t\tlast_stat = current;\n\t\t\t}\n\t\t}\n\t\tprintf(\"total: tx %.1fKB, rx %.1fKB\\n\",\n\t\t       _write_count/1024.0, _read_count/1024.0);\n\t} else\n\t\ttransfer(fd, default_tx, default_rx, sizeof(default_tx));\n\n\tclose(fd);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}