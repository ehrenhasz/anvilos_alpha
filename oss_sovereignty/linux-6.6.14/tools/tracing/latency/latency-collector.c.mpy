{
  "module_name": "latency-collector.c",
  "hash_id": "89e80a48c346ccbe2f4ced9f44dd09ce1e0cdeb94320d7922f8c0f2c40aff1a4",
  "original_prompt": "Ingested from linux-6.6.14/tools/tracing/latency/latency-collector.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#define _POSIX_C_SOURCE 200809L\n\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <err.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <sched.h>\n#include <linux/unistd.h>\n#include <signal.h>\n#include <sys/inotify.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <tracefs.h>\n\nstatic const char *prg_name;\nstatic const char *prg_unknown = \"unknown program name\";\n\nstatic int fd_stdout;\n\nstatic int sched_policy;\nstatic bool sched_policy_set;\n\nstatic int sched_pri;\nstatic bool sched_pri_set;\n\nstatic bool trace_enable = true;\nstatic bool setup_ftrace = true;\nstatic bool use_random_sleep;\n\n#define TRACE_OPTS\t\t\t\t\\\n\tC(FUNC_TR, \"function-trace\"),\t\t\\\n\tC(DISP_GR, \"display-graph\"),\t\t\\\n\tC(NR,       NULL)\n\n#undef C\n#define C(a, b) OPTIDX_##a\n\nenum traceopt {\n\tTRACE_OPTS\n};\n\n#undef C\n#define C(a, b)  b\n\nstatic const char *const optstr[] = {\n\tTRACE_OPTS\n};\n\nenum errhandling {\n\tERR_EXIT = 0,\n\tERR_WARN,\n\tERR_CLEANUP,\n};\n\nstatic bool use_options[OPTIDX_NR];\n\nstatic char inotify_buffer[655360];\n\n#define likely(x)      __builtin_expect(!!(x), 1)\n#define unlikely(x)    __builtin_expect(!!(x), 0)\n#define bool2str(x)    (x ? \"true\":\"false\")\n\n#define DEFAULT_NR_PRINTER_THREADS (3)\nstatic unsigned int nr_threads = DEFAULT_NR_PRINTER_THREADS;\n\n#define DEFAULT_TABLE_SIZE (2)\nstatic unsigned int table_startsize = DEFAULT_TABLE_SIZE;\n\nstatic int verbosity;\n\n#define verbose_sizechange() (verbosity >= 1)\n#define verbose_lostevent()  (verbosity >= 2)\n#define verbose_ftrace()     (verbosity >= 1)\n\n#define was_changed(ORIG, CUR) (strcmp(ORIG, CUR) != 0)\n#define needs_change(CUR, WANTED) (strcmp(CUR, WANTED) != 0)\n\nstatic const char *debug_tracefile;\nstatic const char *debug_tracefile_dflt;\nstatic const char *debug_maxlat;\nstatic const char *debug_maxlat_dflt;\nstatic const char * const DEBUG_NOFILE = \"[file not found]\";\n\nstatic const char * const TR_MAXLAT  = \"tracing_max_latency\";\nstatic const char * const TR_THRESH  = \"tracing_thresh\";\nstatic const char * const TR_CURRENT = \"current_tracer\";\nstatic const char * const TR_OPTIONS = \"trace_options\";\n\nstatic const char * const NOP_TRACER = \"nop\";\n\nstatic const char * const OPT_NO_PREFIX = \"no\";\n\n#define DFLT_THRESHOLD_US \"0\"\nstatic const char *threshold = DFLT_THRESHOLD_US;\n\n#define DEV_URANDOM     \"/dev/urandom\"\n#define RT_DEFAULT_PRI (99)\n#define DEFAULT_PRI    (0)\n\n#define USEC_PER_MSEC (1000L)\n#define NSEC_PER_USEC (1000L)\n#define NSEC_PER_MSEC (USEC_PER_MSEC * NSEC_PER_USEC)\n\n#define MSEC_PER_SEC (1000L)\n#define USEC_PER_SEC (USEC_PER_MSEC * MSEC_PER_SEC)\n#define NSEC_PER_SEC (NSEC_PER_MSEC * MSEC_PER_SEC)\n\n#define SLEEP_TIME_MS_DEFAULT (1000L)\n#define TRY_PRINTMUTEX_MS (1000)\n\nstatic long sleep_time = (USEC_PER_MSEC * SLEEP_TIME_MS_DEFAULT);\n\nstatic const char * const queue_full_warning =\n\"Could not queue trace for printing. It is likely that events happen faster\\n\"\n\"than what they can be printed. Probably partly because of random sleeping\\n\";\n\nstatic const char * const no_tracer_msg =\n\"Could not find any tracers! Running this program as root may help!\\n\";\n\nstatic const char * const no_latency_tr_msg =\n\"No latency tracers are supported by your kernel!\\n\";\n\nstruct policy {\n\tconst char *name;\n\tint policy;\n\tint default_pri;\n};\n\nstatic const struct policy policies[] = {\n\t{ \"other\", SCHED_OTHER, DEFAULT_PRI    },\n\t{ \"batch\", SCHED_BATCH, DEFAULT_PRI    },\n\t{ \"idle\",  SCHED_IDLE,  DEFAULT_PRI    },\n\t{ \"rr\",    SCHED_RR,    RT_DEFAULT_PRI },\n\t{ \"fifo\",  SCHED_FIFO,  RT_DEFAULT_PRI },\n\t{ NULL,    0,           DEFAULT_PRI    }\n};\n\n \nstatic const char * const relevant_tracers[] = {\n\t\"preemptirqsoff\",\n\t\"preemptoff\",\n\t\"irqsoff\",\n\t\"wakeup\",\n\t\"wakeup_rt\",\n\t\"wakeup_dl\",\n\tNULL\n};\n\n \nstatic const char * const random_tracers[] = {\n\t\"preemptirqsoff\",\n\t\"preemptoff\",\n\t\"irqsoff\",\n\tNULL\n};\n\nstatic const char *current_tracer;\nstatic bool force_tracer;\n\nstruct ftrace_state {\n\tchar *tracer;\n\tchar *thresh;\n\tbool opt[OPTIDX_NR];\n\tbool opt_valid[OPTIDX_NR];\n\tpthread_mutex_t mutex;\n};\n\nstruct entry {\n\tint ticket;\n\tint ticket_completed_ref;\n};\n\nstruct print_state {\n\tint ticket_counter;\n\tint ticket_completed;\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cond;\n\tint cnt;\n\tpthread_mutex_t cnt_mutex;\n};\n\nstruct short_msg {\n\tchar buf[160];\n\tint len;\n};\n\nstatic struct print_state printstate;\nstatic struct ftrace_state save_state;\nvolatile sig_atomic_t signal_flag;\n\n#define PROB_TABLE_MAX_SIZE (1000)\n\nint probabilities[PROB_TABLE_MAX_SIZE];\n\nstruct sleep_table {\n\tint *table;\n\tint size;\n\tpthread_mutex_t mutex;\n};\n\nstatic struct sleep_table sleeptable;\n\n#define QUEUE_SIZE (10)\n\nstruct queue {\n\tstruct entry entries[QUEUE_SIZE];\n\tint next_prod_idx;\n\tint next_cons_idx;\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cond;\n};\n\n#define MAX_THREADS (40)\n\nstruct queue printqueue;\npthread_t printthread[MAX_THREADS];\npthread_mutex_t print_mtx;\n#define PRINT_BUFFER_SIZE (16 * 1024 * 1024)\n\nstatic void cleanup_exit(int status);\nstatic int set_trace_opt(const char *opt, bool value);\n\nstatic __always_inline void *malloc_or_die(size_t size)\n{\n\tvoid *ptr = malloc(size);\n\n\tif (unlikely(ptr == NULL)) {\n\t\twarn(\"malloc() failed\");\n\t\tcleanup_exit(EXIT_FAILURE);\n\t}\n\treturn ptr;\n}\n\nstatic __always_inline void *malloc_or_die_nocleanup(size_t size)\n{\n\tvoid *ptr = malloc(size);\n\n\tif (unlikely(ptr == NULL))\n\t\terr(0, \"malloc() failed\");\n\treturn ptr;\n}\n\nstatic __always_inline void write_or_die(int fd, const char *buf, size_t count)\n{\n\tssize_t r;\n\n\tdo {\n\t\tr = write(fd, buf, count);\n\t\tif (unlikely(r < 0)) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\twarn(\"write() failed\");\n\t\t\tcleanup_exit(EXIT_FAILURE);\n\t\t}\n\t\tcount -= r;\n\t\tbuf += r;\n\t} while (count > 0);\n}\n\nstatic __always_inline void clock_gettime_or_die(clockid_t clk_id,\n\t\t\t\t\t\t struct timespec *tp)\n{\n\tint r = clock_gettime(clk_id, tp);\n\n\tif (unlikely(r != 0))\n\t\terr(EXIT_FAILURE, \"clock_gettime() failed\");\n}\n\nstatic __always_inline void sigemptyset_or_die(sigset_t *s)\n{\n\tif (unlikely(sigemptyset(s) != 0)) {\n\t\twarn(\"sigemptyset() failed\");\n\t\tcleanup_exit(EXIT_FAILURE);\n\t}\n}\n\nstatic __always_inline void sigaddset_or_die(sigset_t *s, int signum)\n{\n\tif (unlikely(sigaddset(s, signum) != 0)) {\n\t\twarn(\"sigemptyset() failed\");\n\t\tcleanup_exit(EXIT_FAILURE);\n\t}\n}\n\nstatic __always_inline void sigaction_or_die(int signum,\n\t\t\t\t\t     const struct sigaction *act,\n\t\t\t\t\t     struct sigaction *oldact)\n{\n\tif (unlikely(sigaction(signum, act, oldact) != 0)) {\n\t\twarn(\"sigaction() failed\");\n\t\tcleanup_exit(EXIT_FAILURE);\n\t}\n}\n\nstatic void open_stdout(void)\n{\n\tif (setvbuf(stdout, NULL, _IONBF, 0) != 0)\n\t\terr(EXIT_FAILURE, \"setvbuf() failed\");\n\tfd_stdout = fileno(stdout);\n\tif (fd_stdout < 0)\n\t\terr(EXIT_FAILURE, \"fileno() failed\");\n}\n\n \nstatic __always_inline void mutex_lock(pthread_mutex_t *mtx)\n{\n\terrno = pthread_mutex_lock(mtx);\n\tif (unlikely(errno))\n\t\terr(EXIT_FAILURE, \"pthread_mutex_lock() failed\");\n}\n\n\nstatic __always_inline void mutex_unlock(pthread_mutex_t *mtx)\n{\n\terrno = pthread_mutex_unlock(mtx);\n\tif (unlikely(errno))\n\t\terr(EXIT_FAILURE, \"pthread_mutex_unlock() failed\");\n}\n\nstatic __always_inline void cond_signal(pthread_cond_t *cond)\n{\n\terrno = pthread_cond_signal(cond);\n\tif (unlikely(errno))\n\t\terr(EXIT_FAILURE, \"pthread_cond_signal() failed\");\n}\n\nstatic __always_inline void cond_wait(pthread_cond_t *restrict cond,\n\t\t\t\t      pthread_mutex_t *restrict mutex)\n{\n\terrno = pthread_cond_wait(cond, mutex);\n\tif (unlikely(errno))\n\t\terr(EXIT_FAILURE, \"pthread_cond_wait() failed\");\n}\n\nstatic __always_inline void cond_broadcast(pthread_cond_t *cond)\n{\n\terrno = pthread_cond_broadcast(cond);\n\tif (unlikely(errno))\n\t\terr(EXIT_FAILURE, \"pthread_cond_broadcast() failed\");\n}\n\nstatic __always_inline void\nmutex_init(pthread_mutex_t *mutex,\n\t   const pthread_mutexattr_t *attr)\n{\n\terrno = pthread_mutex_init(mutex, attr);\n\tif (errno)\n\t\terr(EXIT_FAILURE, \"pthread_mutex_init() failed\");\n}\n\nstatic __always_inline void mutexattr_init(pthread_mutexattr_t *attr)\n{\n\terrno = pthread_mutexattr_init(attr);\n\tif (errno)\n\t\terr(EXIT_FAILURE, \"pthread_mutexattr_init() failed\");\n}\n\nstatic __always_inline void mutexattr_destroy(pthread_mutexattr_t *attr)\n{\n\terrno = pthread_mutexattr_destroy(attr);\n\tif (errno)\n\t\terr(EXIT_FAILURE, \"pthread_mutexattr_destroy() failed\");\n}\n\nstatic __always_inline void mutexattr_settype(pthread_mutexattr_t *attr,\n\t\t\t\t\t      int type)\n{\n\terrno = pthread_mutexattr_settype(attr, type);\n\tif (errno)\n\t\terr(EXIT_FAILURE, \"pthread_mutexattr_settype() failed\");\n}\n\nstatic __always_inline void condattr_init(pthread_condattr_t *attr)\n{\n\terrno = pthread_condattr_init(attr);\n\tif (errno)\n\t\terr(EXIT_FAILURE, \"pthread_condattr_init() failed\");\n}\n\nstatic __always_inline void condattr_destroy(pthread_condattr_t *attr)\n{\n\terrno = pthread_condattr_destroy(attr);\n\tif (errno)\n\t\terr(EXIT_FAILURE, \"pthread_condattr_destroy() failed\");\n}\n\nstatic __always_inline void condattr_setclock(pthread_condattr_t *attr,\n\t\t\t\t\t      clockid_t clock_id)\n{\n\terrno = pthread_condattr_setclock(attr, clock_id);\n\tif (unlikely(errno))\n\t\terr(EXIT_FAILURE, \"pthread_condattr_setclock() failed\");\n}\n\nstatic __always_inline void cond_init(pthread_cond_t *cond,\n\t\t\t\t      const pthread_condattr_t *attr)\n{\n\terrno = pthread_cond_init(cond, attr);\n\tif (errno)\n\t\terr(EXIT_FAILURE, \"pthread_cond_init() failed\");\n}\n\nstatic __always_inline int\ncond_timedwait(pthread_cond_t *restrict cond,\n\t       pthread_mutex_t *restrict mutex,\n\t       const struct timespec *restrict abstime)\n{\n\terrno = pthread_cond_timedwait(cond, mutex, abstime);\n\tif (errno && errno != ETIMEDOUT)\n\t\terr(EXIT_FAILURE, \"pthread_cond_timedwait() failed\");\n\treturn errno;\n}\n\nstatic void init_printstate(void)\n{\n\tpthread_condattr_t cattr;\n\n\tprintstate.ticket_counter = 0;\n\tprintstate.ticket_completed = 0;\n\tprintstate.cnt = 0;\n\n\tmutex_init(&printstate.mutex, NULL);\n\n\tcondattr_init(&cattr);\n\tcondattr_setclock(&cattr, CLOCK_MONOTONIC);\n\tcond_init(&printstate.cond, &cattr);\n\tcondattr_destroy(&cattr);\n}\n\nstatic void init_print_mtx(void)\n{\n\tpthread_mutexattr_t mattr;\n\n\tmutexattr_init(&mattr);\n\tmutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);\n\tmutex_init(&print_mtx, &mattr);\n\tmutexattr_destroy(&mattr);\n\n}\n\nstatic void signal_blocking(int how)\n{\n\tsigset_t s;\n\n\tsigemptyset_or_die(&s);\n\tsigaddset_or_die(&s, SIGHUP);\n\tsigaddset_or_die(&s, SIGTERM);\n\tsigaddset_or_die(&s, SIGINT);\n\n\terrno = pthread_sigmask(how, &s, NULL);\n\tif (unlikely(errno)) {\n\t\twarn(\"pthread_sigmask() failed\");\n\t\tcleanup_exit(EXIT_FAILURE);\n\t}\n}\n\nstatic void signal_handler(int num)\n{\n\tsignal_flag = num;\n}\n\nstatic void setup_sig_handler(void)\n{\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = signal_handler;\n\n\tsigaction_or_die(SIGHUP, &sa, NULL);\n\tsigaction_or_die(SIGTERM, &sa, NULL);\n\tsigaction_or_die(SIGINT, &sa, NULL);\n}\n\nstatic void process_signal(int signal)\n{\n\tchar *name;\n\n\tname = strsignal(signal);\n\tif (name == NULL)\n\t\tprintf(\"Received signal %d\\n\", signal);\n\telse\n\t\tprintf(\"Received signal %d (%s)\\n\", signal, name);\n\tcleanup_exit(EXIT_SUCCESS);\n}\n\nstatic __always_inline void check_signals(void)\n{\n\tint signal = signal_flag;\n\n\tif (unlikely(signal))\n\t\tprocess_signal(signal);\n}\n\nstatic __always_inline void get_time_in_future(struct timespec *future,\n\t\t\t\t\t       long time_us)\n{\n\tlong nsec;\n\n\tclock_gettime_or_die(CLOCK_MONOTONIC, future);\n\tfuture->tv_sec += time_us / USEC_PER_SEC;\n\tnsec = future->tv_nsec + (time_us * NSEC_PER_USEC) % NSEC_PER_SEC;\n\tif (nsec >= NSEC_PER_SEC) {\n\t\tfuture->tv_nsec = nsec % NSEC_PER_SEC;\n\t\tfuture->tv_sec += 1;\n\t}\n}\n\nstatic __always_inline bool time_has_passed(const struct timespec *time)\n{\n\tstruct timespec now;\n\n\tclock_gettime_or_die(CLOCK_MONOTONIC, &now);\n\tif (now.tv_sec > time->tv_sec)\n\t\treturn true;\n\tif (now.tv_sec < time->tv_sec)\n\t\treturn false;\n\treturn (now.tv_nsec >= time->tv_nsec);\n}\n\nstatic bool mutex_trylock_limit(pthread_mutex_t *mutex, int time_ms)\n{\n\tlong time_us = time_ms * USEC_PER_MSEC;\n\tstruct timespec limit;\n\n\tget_time_in_future(&limit, time_us);\n\tdo {\n\t\terrno =  pthread_mutex_trylock(mutex);\n\t\tif (errno && errno != EBUSY)\n\t\t\terr(EXIT_FAILURE, \"pthread_mutex_trylock() failed\");\n\t} while (errno && !time_has_passed(&limit));\n\treturn errno == 0;\n}\n\nstatic void restore_trace_opts(const struct ftrace_state *state,\n\t\t\t\tconst bool *cur)\n{\n\tint i;\n\tint r;\n\n\tfor (i = 0; i < OPTIDX_NR; i++)\n\t\tif (state->opt_valid[i] && state->opt[i] != cur[i]) {\n\t\t\tr = set_trace_opt(optstr[i], state->opt[i]);\n\t\t\tif (r < 0)\n\t\t\t\twarnx(\"Failed to restore the %s option to %s\",\n\t\t\t\t      optstr[i], bool2str(state->opt[i]));\n\t\t\telse if (verbose_ftrace())\n\t\t\t\tprintf(\"Restored the %s option in %s to %s\\n\",\n\t\t\t\t       optstr[i], TR_OPTIONS,\n\t\t\t\t       bool2str(state->opt[i]));\n\t\t}\n}\n\nstatic char *read_file(const char *file, enum errhandling h)\n{\n\tint psize;\n\tchar *r;\n\tstatic const char *emsg = \"Failed to read the %s file\";\n\n\tr = tracefs_instance_file_read(NULL, file, &psize);\n\tif (!r) {\n\t\tif (h) {\n\t\t\twarn(emsg, file);\n\t\t\tif (h == ERR_CLEANUP)\n\t\t\t\tcleanup_exit(EXIT_FAILURE);\n\t\t} else\n\t\t\terrx(EXIT_FAILURE, emsg, file);\n\t}\n\n\tif (r && r[psize - 1] == '\\n')\n\t\tr[psize - 1] = '\\0';\n\treturn r;\n}\n\nstatic void restore_file(const char *file, char **saved, const char *cur)\n{\n\tif (*saved && was_changed(*saved, cur)) {\n\t\tif (tracefs_instance_file_write(NULL, file, *saved) < 0)\n\t\t\twarnx(\"Failed to restore %s to %s!\", file, *saved);\n\t\telse if (verbose_ftrace())\n\t\t\tprintf(\"Restored %s to %s\\n\", file, *saved);\n\t\tfree(*saved);\n\t\t*saved = NULL;\n\t}\n}\n\nstatic void restore_ftrace(void)\n{\n\tmutex_lock(&save_state.mutex);\n\n\trestore_file(TR_CURRENT, &save_state.tracer, current_tracer);\n\trestore_file(TR_THRESH, &save_state.thresh, threshold);\n\trestore_trace_opts(&save_state, use_options);\n\n\tmutex_unlock(&save_state.mutex);\n}\n\nstatic void cleanup_exit(int status)\n{\n\tchar *maxlat;\n\n\tif (!setup_ftrace)\n\t\texit(status);\n\n\t \n\tmutex_trylock_limit(&print_mtx, TRY_PRINTMUTEX_MS);\n\n\tmaxlat = read_file(TR_MAXLAT, ERR_WARN);\n\tif (maxlat) {\n\t\tprintf(\"The maximum detected latency was: %sus\\n\", maxlat);\n\t\tfree(maxlat);\n\t}\n\n\trestore_ftrace();\n\t \n\texit(status);\n}\n\nstatic void init_save_state(void)\n{\n\tpthread_mutexattr_t mattr;\n\n\tmutexattr_init(&mattr);\n\tmutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);\n\tmutex_init(&save_state.mutex, &mattr);\n\tmutexattr_destroy(&mattr);\n\n\tsave_state.tracer = NULL;\n\tsave_state.thresh = NULL;\n\tsave_state.opt_valid[OPTIDX_FUNC_TR] = false;\n\tsave_state.opt_valid[OPTIDX_DISP_GR] = false;\n}\n\nstatic int printstate_next_ticket(struct entry *req)\n{\n\tint r;\n\n\tr = ++(printstate.ticket_counter);\n\treq->ticket = r;\n\treq->ticket_completed_ref = printstate.ticket_completed;\n\tcond_broadcast(&printstate.cond);\n\treturn r;\n}\n\nstatic __always_inline\nvoid printstate_mark_req_completed(const struct entry *req)\n{\n\tif (req->ticket > printstate.ticket_completed)\n\t\tprintstate.ticket_completed = req->ticket;\n}\n\nstatic __always_inline\nbool printstate_has_new_req_arrived(const struct entry *req)\n{\n\treturn (printstate.ticket_counter != req->ticket);\n}\n\nstatic __always_inline int printstate_cnt_inc(void)\n{\n\tint value;\n\n\tmutex_lock(&printstate.cnt_mutex);\n\tvalue = ++printstate.cnt;\n\tmutex_unlock(&printstate.cnt_mutex);\n\treturn value;\n}\n\nstatic __always_inline int printstate_cnt_dec(void)\n{\n\tint value;\n\n\tmutex_lock(&printstate.cnt_mutex);\n\tvalue = --printstate.cnt;\n\tmutex_unlock(&printstate.cnt_mutex);\n\treturn value;\n}\n\nstatic __always_inline int printstate_cnt_read(void)\n{\n\tint value;\n\n\tmutex_lock(&printstate.cnt_mutex);\n\tvalue = printstate.cnt;\n\tmutex_unlock(&printstate.cnt_mutex);\n\treturn value;\n}\n\nstatic __always_inline\nbool prev_req_won_race(const struct entry *req)\n{\n\treturn (printstate.ticket_completed != req->ticket_completed_ref);\n}\n\nstatic void sleeptable_resize(int size, bool printout, struct short_msg *msg)\n{\n\tint bytes;\n\n\tif (printout) {\n\t\tmsg->len = 0;\n\t\tif (unlikely(size > PROB_TABLE_MAX_SIZE))\n\t\t\tbytes = snprintf(msg->buf, sizeof(msg->buf),\n\"Cannot increase probability table to %d (maximum size reached)\\n\", size);\n\t\telse\n\t\t\tbytes = snprintf(msg->buf, sizeof(msg->buf),\n\"Increasing probability table to %d\\n\", size);\n\t\tif (bytes < 0)\n\t\t\twarn(\"snprintf() failed\");\n\t\telse\n\t\t\tmsg->len = bytes;\n\t}\n\n\tif (unlikely(size < 0)) {\n\t\t \n\t\twarnx(\"Bad program state at %s:%d\", __FILE__, __LINE__);\n\t\tcleanup_exit(EXIT_FAILURE);\n\t\treturn;\n\t}\n\tsleeptable.size = size;\n\tsleeptable.table = &probabilities[PROB_TABLE_MAX_SIZE - size];\n}\n\nstatic void init_probabilities(void)\n{\n\tint i;\n\tint j = 1000;\n\n\tfor (i = 0; i < PROB_TABLE_MAX_SIZE; i++) {\n\t\tprobabilities[i] = 1000 / j;\n\t\tj--;\n\t}\n\tmutex_init(&sleeptable.mutex, NULL);\n}\n\nstatic int table_get_probability(const struct entry *req,\n\t\t\t\t struct short_msg *msg)\n{\n\tint diff = req->ticket - req->ticket_completed_ref;\n\tint rval = 0;\n\n\tmsg->len = 0;\n\tdiff--;\n\t \n\tif (unlikely(diff < 0)) {\n\t\twarnx(\"Programmer assumption error at %s:%d\\n\", __FILE__,\n\t\t      __LINE__);\n\t\tcleanup_exit(EXIT_FAILURE);\n\t}\n\tmutex_lock(&sleeptable.mutex);\n\tif (diff >= (sleeptable.size - 1)) {\n\t\trval = sleeptable.table[sleeptable.size - 1];\n\t\tsleeptable_resize(sleeptable.size + 1, verbose_sizechange(),\n\t\t\t\t  msg);\n\t} else {\n\t\trval = sleeptable.table[diff];\n\t}\n\tmutex_unlock(&sleeptable.mutex);\n\treturn rval;\n}\n\nstatic void init_queue(struct queue *q)\n{\n\tq->next_prod_idx = 0;\n\tq->next_cons_idx = 0;\n\tmutex_init(&q->mutex, NULL);\n\terrno = pthread_cond_init(&q->cond, NULL);\n\tif (errno)\n\t\terr(EXIT_FAILURE, \"pthread_cond_init() failed\");\n}\n\nstatic __always_inline int queue_len(const struct queue *q)\n{\n\tif (q->next_prod_idx >= q->next_cons_idx)\n\t\treturn q->next_prod_idx - q->next_cons_idx;\n\telse\n\t\treturn QUEUE_SIZE - q->next_cons_idx + q->next_prod_idx;\n}\n\nstatic __always_inline int queue_nr_free(const struct queue *q)\n{\n\tint nr_free = QUEUE_SIZE - queue_len(q);\n\n\t \n\tif (nr_free == 1)\n\t\tnr_free = 0;\n\treturn nr_free;\n}\n\nstatic __always_inline void queue_idx_inc(int *idx)\n{\n\t*idx = (*idx + 1) % QUEUE_SIZE;\n}\n\nstatic __always_inline void queue_push_to_back(struct queue *q,\n\t\t\t\t\t      const struct entry *e)\n{\n\tq->entries[q->next_prod_idx] = *e;\n\tqueue_idx_inc(&q->next_prod_idx);\n}\n\nstatic __always_inline struct entry queue_pop_from_front(struct queue *q)\n{\n\tstruct entry e = q->entries[q->next_cons_idx];\n\n\tqueue_idx_inc(&q->next_cons_idx);\n\treturn e;\n}\n\nstatic __always_inline void queue_cond_signal(struct queue *q)\n{\n\tcond_signal(&q->cond);\n}\n\nstatic __always_inline void queue_cond_wait(struct queue *q)\n{\n\tcond_wait(&q->cond, &q->mutex);\n}\n\nstatic __always_inline int queue_try_to_add_entry(struct queue *q,\n\t\t\t\t\t\t  const struct entry *e)\n{\n\tint r = 0;\n\n\tmutex_lock(&q->mutex);\n\tif (queue_nr_free(q) > 0) {\n\t\tqueue_push_to_back(q, e);\n\t\tcond_signal(&q->cond);\n\t} else\n\t\tr = -1;\n\tmutex_unlock(&q->mutex);\n\treturn r;\n}\n\nstatic struct entry queue_wait_for_entry(struct queue *q)\n{\n\tstruct entry e;\n\n\tmutex_lock(&q->mutex);\n\twhile (true) {\n\t\tif (queue_len(&printqueue) > 0) {\n\t\t\te = queue_pop_from_front(q);\n\t\t\tbreak;\n\t\t}\n\t\tqueue_cond_wait(q);\n\t}\n\tmutex_unlock(&q->mutex);\n\n\treturn e;\n}\n\nstatic const struct policy *policy_from_name(const char *name)\n{\n\tconst struct policy *p = &policies[0];\n\n\twhile (p->name != NULL) {\n\t\tif (!strcmp(name, p->name))\n\t\t\treturn p;\n\t\tp++;\n\t}\n\treturn NULL;\n}\n\nstatic const char *policy_name(int policy)\n{\n\tconst struct policy *p = &policies[0];\n\tstatic const char *rval = \"unknown\";\n\n\twhile (p->name != NULL) {\n\t\tif (p->policy == policy)\n\t\t\treturn p->name;\n\t\tp++;\n\t}\n\treturn rval;\n}\n\nstatic bool is_relevant_tracer(const char *name)\n{\n\tunsigned int i;\n\n\tfor (i = 0; relevant_tracers[i]; i++)\n\t\tif (!strcmp(name, relevant_tracers[i]))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic bool random_makes_sense(const char *name)\n{\n\tunsigned int i;\n\n\tfor (i = 0; random_tracers[i]; i++)\n\t\tif (!strcmp(name, random_tracers[i]))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic void show_available(void)\n{\n\tchar **tracers;\n\tint found = 0;\n\tint i;\n\n\ttracers = tracefs_tracers(NULL);\n\tfor (i = 0; tracers && tracers[i]; i++) {\n\t\tif (is_relevant_tracer(tracers[i]))\n\t\t\tfound++;\n\t}\n\n\tif (!tracers) {\n\t\twarnx(no_tracer_msg);\n\t\treturn;\n\t}\n\n\tif (!found) {\n\t\twarnx(no_latency_tr_msg);\n\t\ttracefs_list_free(tracers);\n\t\treturn;\n\t}\n\n\tprintf(\"The following latency tracers are available on your system:\\n\");\n\tfor (i = 0; tracers[i]; i++) {\n\t\tif (is_relevant_tracer(tracers[i]))\n\t\t\tprintf(\"%s\\n\", tracers[i]);\n\t}\n\ttracefs_list_free(tracers);\n}\n\nstatic bool tracer_valid(const char *name, bool *notracer)\n{\n\tchar **tracers;\n\tint i;\n\tbool rval = false;\n\n\t*notracer = false;\n\ttracers = tracefs_tracers(NULL);\n\tif (!tracers) {\n\t\t*notracer = true;\n\t\treturn false;\n\t}\n\tfor (i = 0; tracers[i]; i++)\n\t\tif (!strcmp(tracers[i], name)) {\n\t\t\trval = true;\n\t\t\tbreak;\n\t\t}\n\ttracefs_list_free(tracers);\n\treturn rval;\n}\n\nstatic const char *find_default_tracer(void)\n{\n\tint i;\n\tbool notracer;\n\tbool valid;\n\n\tfor (i = 0; relevant_tracers[i]; i++) {\n\t\tvalid = tracer_valid(relevant_tracers[i], &notracer);\n\t\tif (notracer)\n\t\t\terrx(EXIT_FAILURE, no_tracer_msg);\n\t\tif (valid)\n\t\t\treturn relevant_tracers[i];\n\t}\n\treturn NULL;\n}\n\nstatic bool toss_coin(struct drand48_data *buffer, unsigned int prob)\n{\n\tlong r;\n\n\tif (unlikely(lrand48_r(buffer, &r))) {\n\t\twarnx(\"lrand48_r() failed\");\n\t\tcleanup_exit(EXIT_FAILURE);\n\t}\n\tr = r % 1000L;\n\tif (r < prob)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n\nstatic long go_to_sleep(const struct entry *req)\n{\n\tstruct timespec future;\n\tlong delay = sleep_time;\n\n\tget_time_in_future(&future, delay);\n\n\tmutex_lock(&printstate.mutex);\n\twhile (!printstate_has_new_req_arrived(req)) {\n\t\tcond_timedwait(&printstate.cond, &printstate.mutex, &future);\n\t\tif (time_has_passed(&future))\n\t\t\tbreak;\n\t}\n\n\tif (printstate_has_new_req_arrived(req))\n\t\tdelay = -1;\n\tmutex_unlock(&printstate.mutex);\n\n\treturn delay;\n}\n\n\nstatic void set_priority(void)\n{\n\tint r;\n\tpid_t pid;\n\tstruct sched_param param;\n\n\tmemset(&param, 0, sizeof(param));\n\tparam.sched_priority = sched_pri;\n\n\tpid = getpid();\n\tr = sched_setscheduler(pid, sched_policy, &param);\n\n\tif (r != 0)\n\t\terr(EXIT_FAILURE, \"sched_setscheduler() failed\");\n}\n\npid_t latency_collector_gettid(void)\n{\n\treturn (pid_t) syscall(__NR_gettid);\n}\n\nstatic void print_priority(void)\n{\n\tpid_t tid;\n\tint policy;\n\tint r;\n\tstruct sched_param param;\n\n\ttid = latency_collector_gettid();\n\tr = pthread_getschedparam(pthread_self(), &policy, &param);\n\tif (r != 0) {\n\t\twarn(\"pthread_getschedparam() failed\");\n\t\tcleanup_exit(EXIT_FAILURE);\n\t}\n\tmutex_lock(&print_mtx);\n\tprintf(\"Thread %d runs with scheduling policy %s and priority %d\\n\",\n\t       tid, policy_name(policy), param.sched_priority);\n\tmutex_unlock(&print_mtx);\n}\n\nstatic __always_inline\nvoid __print_skipmessage(const struct short_msg *resize_msg,\n\t\t\t const struct timespec *timestamp, char *buffer,\n\t\t\t size_t bufspace, const struct entry *req, bool excuse,\n\t\t\t const char *str)\n{\n\tssize_t bytes = 0;\n\tchar *p = &buffer[0];\n\tlong us, sec;\n\tint r;\n\n\tsec = timestamp->tv_sec;\n\tus = timestamp->tv_nsec / 1000;\n\n\tif (resize_msg != NULL && resize_msg->len > 0) {\n\t\tstrncpy(p, resize_msg->buf, resize_msg->len);\n\t\tbytes += resize_msg->len;\n\t\tp += resize_msg->len;\n\t\tbufspace -= resize_msg->len;\n\t}\n\n\tif (excuse)\n\t\tr = snprintf(p, bufspace,\n\"%ld.%06ld Latency %d printout skipped due to %s\\n\",\n\t\t\t     sec, us, req->ticket, str);\n\telse\n\t\tr = snprintf(p, bufspace, \"%ld.%06ld Latency %d detected\\n\",\n\t\t\t    sec, us, req->ticket);\n\n\tif (r < 0)\n\t\twarn(\"snprintf() failed\");\n\telse\n\t\tbytes += r;\n\n\t \n\tmutex_lock(&print_mtx);\n\twrite_or_die(fd_stdout, buffer, bytes);\n\tmutex_unlock(&print_mtx);\n}\n\nstatic void print_skipmessage(const struct short_msg *resize_msg,\n\t\t\t      const struct timespec *timestamp, char *buffer,\n\t\t\t      size_t bufspace, const struct entry *req,\n\t\t\t      bool excuse)\n{\n\t__print_skipmessage(resize_msg, timestamp, buffer, bufspace, req,\n\t\t\t    excuse, \"random delay\");\n}\n\nstatic void print_lostmessage(const struct timespec *timestamp, char *buffer,\n\t\t\t      size_t bufspace, const struct entry *req,\n\t\t\t      const char *reason)\n{\n\t__print_skipmessage(NULL, timestamp, buffer, bufspace, req, true,\n\t\t\t    reason);\n}\n\nstatic void print_tracefile(const struct short_msg *resize_msg,\n\t\t\t    const struct timespec *timestamp, char *buffer,\n\t\t\t    size_t bufspace, long slept,\n\t\t\t    const struct entry *req)\n{\n\tstatic const int reserve = 256;\n\tchar *p = &buffer[0];\n\tssize_t bytes = 0;\n\tssize_t bytes_tot = 0;\n\tlong us, sec;\n\tlong slept_ms;\n\tint trace_fd;\n\n\t \n\tbufspace = bufspace - reserve - 1;\n\n\tif (resize_msg != NULL && resize_msg->len > 0) {\n\t\tbytes = resize_msg->len;\n\t\tstrncpy(p, resize_msg->buf, bytes);\n\t\tbytes_tot += bytes;\n\t\tp += bytes;\n\t\tbufspace -= bytes;\n\t}\n\n\ttrace_fd = open(debug_tracefile, O_RDONLY);\n\n\tif (trace_fd < 0) {\n\t\twarn(\"open() failed on %s\", debug_tracefile);\n\t\treturn;\n\t}\n\n\tsec = timestamp->tv_sec;\n\tus = timestamp->tv_nsec / 1000;\n\n\tif (slept != 0) {\n\t\tslept_ms = slept / 1000;\n\t\tbytes = snprintf(p, bufspace,\n\"%ld.%06ld Latency %d randomly sleep for %ld ms before print\\n\",\n\t\t\t\t sec, us, req->ticket, slept_ms);\n\t} else {\n\t\tbytes = snprintf(p, bufspace,\n\t\t\t\t \"%ld.%06ld Latency %d immediate print\\n\", sec,\n\t\t\t\t us, req->ticket);\n\t}\n\n\tif (bytes < 0) {\n\t\twarn(\"snprintf() failed\");\n\t\treturn;\n\t}\n\tp += bytes;\n\tbufspace -= bytes;\n\tbytes_tot += bytes;\n\n\tbytes = snprintf(p, bufspace,\n\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BEGIN <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\"\n\t\t);\n\n\tif (bytes < 0) {\n\t\twarn(\"snprintf() failed\");\n\t\treturn;\n\t}\n\n\tp += bytes;\n\tbufspace -= bytes;\n\tbytes_tot += bytes;\n\n\tdo {\n\t\tbytes = read(trace_fd, p, bufspace);\n\t\tif (bytes < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\twarn(\"read() failed on %s\", debug_tracefile);\n\t\t\tif (unlikely(close(trace_fd) != 0))\n\t\t\t\twarn(\"close() failed on %s\", debug_tracefile);\n\t\t\treturn;\n\t\t}\n\t\tif (bytes == 0)\n\t\t\tbreak;\n\t\tp += bytes;\n\t\tbufspace -= bytes;\n\t\tbytes_tot += bytes;\n\t} while (true);\n\n\tif (unlikely(close(trace_fd) != 0))\n\t\twarn(\"close() failed on %s\", debug_tracefile);\n\n\tprintstate_cnt_dec();\n\t \n\tbufspace += reserve;\n\n\tbytes = snprintf(p, bufspace,\n\t\t\t \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> END <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\\n\");\n\n\tif (bytes < 0) {\n\t\twarn(\"snprintf() failed\");\n\t\treturn;\n\t}\n\n\tbytes_tot += bytes;\n\n\t \n\tmutex_lock(&print_mtx);\n\twrite_or_die(fd_stdout, buffer, bytes_tot);\n\tmutex_unlock(&print_mtx);\n}\n\nstatic char *get_no_opt(const char *opt)\n{\n\tchar *no_opt;\n\tint s;\n\n\ts = strlen(opt) + strlen(OPT_NO_PREFIX) + 1;\n\t \n\tno_opt = malloc_or_die_nocleanup(s);\n\tstrcpy(no_opt, OPT_NO_PREFIX);\n\tstrcat(no_opt, opt);\n\treturn no_opt;\n}\n\nstatic char *find_next_optstr(const char *allopt, const char **next)\n{\n\tconst char *begin;\n\tconst char *end;\n\tchar *r;\n\tint s = 0;\n\n\tif (allopt == NULL)\n\t\treturn NULL;\n\n\tfor (begin = allopt; *begin != '\\0'; begin++) {\n\t\tif (isgraph(*begin))\n\t\t\tbreak;\n\t}\n\n\tif (*begin == '\\0')\n\t\treturn NULL;\n\n\tfor (end = begin; *end != '\\0' && isgraph(*end); end++)\n\t\ts++;\n\n\tr = malloc_or_die_nocleanup(s + 1);\n\tstrncpy(r, begin, s);\n\tr[s] = '\\0';\n\t*next = begin + s;\n\treturn r;\n}\n\nstatic bool get_trace_opt(const char *allopt, const char *opt, bool *found)\n{\n\t*found = false;\n\tchar *no_opt;\n\tchar *str;\n\tconst char *next = allopt;\n\tbool rval = false;\n\n\tno_opt = get_no_opt(opt);\n\n\tdo {\n\t\tstr = find_next_optstr(next, &next);\n\t\tif (str == NULL)\n\t\t\tbreak;\n\t\tif (!strcmp(str, opt)) {\n\t\t\t*found = true;\n\t\t\trval = true;\n\t\t\tfree(str);\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(str, no_opt)) {\n\t\t\t*found = true;\n\t\t\trval = false;\n\t\t\tfree(str);\n\t\t\tbreak;\n\t\t}\n\t\tfree(str);\n\t} while (true);\n\tfree(no_opt);\n\n\treturn rval;\n}\n\nstatic int set_trace_opt(const char *opt, bool value)\n{\n\tchar *str;\n\tint r;\n\n\tif (value)\n\t\tstr = strdup(opt);\n\telse\n\t\tstr = get_no_opt(opt);\n\n\tr = tracefs_instance_file_write(NULL, TR_OPTIONS, str);\n\tfree(str);\n\treturn r;\n}\n\nvoid save_trace_opts(struct ftrace_state *state)\n{\n\tchar *allopt;\n\tint psize;\n\tint i;\n\n\tallopt = tracefs_instance_file_read(NULL, TR_OPTIONS, &psize);\n\tif (!allopt)\n\t\terrx(EXIT_FAILURE, \"Failed to read the %s file\\n\", TR_OPTIONS);\n\n\tfor (i = 0; i < OPTIDX_NR; i++)\n\t\tstate->opt[i] = get_trace_opt(allopt, optstr[i],\n\t\t\t\t\t      &state->opt_valid[i]);\n\n\tfree(allopt);\n}\n\nstatic void write_file(const char *file, const char *cur, const char *new,\n\t\t       enum errhandling h)\n{\n\tint r;\n\tstatic const char *emsg = \"Failed to write to the %s file!\";\n\n\t \n\tif (cur && !needs_change(cur, new))\n\t\treturn;\n\n\tr = tracefs_instance_file_write(NULL, file, new);\n\tif (r < 0) {\n\t\tif (h) {\n\t\t\twarnx(emsg, file);\n\t\t\tif (h == ERR_CLEANUP)\n\t\t\t\tcleanup_exit(EXIT_FAILURE);\n\t\t} else\n\t\t\terrx(EXIT_FAILURE, emsg, file);\n\t}\n\tif (verbose_ftrace()) {\n\t\tmutex_lock(&print_mtx);\n\t\tprintf(\"%s was set to %s\\n\", file, new);\n\t\tmutex_unlock(&print_mtx);\n\t}\n}\n\nstatic void reset_max_latency(void)\n{\n\twrite_file(TR_MAXLAT, NULL, \"0\", ERR_CLEANUP);\n}\n\nstatic void save_and_disable_tracer(void)\n{\n\tchar *orig_th;\n\tchar *tracer;\n\tbool need_nop = false;\n\n\tmutex_lock(&save_state.mutex);\n\n\tsave_trace_opts(&save_state);\n\ttracer = read_file(TR_CURRENT, ERR_EXIT);\n\torig_th = read_file(TR_THRESH, ERR_EXIT);\n\n\tif (needs_change(tracer, NOP_TRACER)) {\n\t\tmutex_lock(&print_mtx);\n\t\tif (force_tracer) {\n\t\t\tprintf(\n\t\t\t\t\"The %s tracer is already in use but proceeding anyway!\\n\",\n\t\t\t\ttracer);\n\t\t} else {\n\t\t\tprintf(\n\t\t\t\t\"The %s tracer is already in use, cowardly bailing out!\\n\"\n\t\t\t\t\"This could indicate that another program or instance is tracing.\\n\"\n\t\t\t\t\"Use the -F [--force] option to disregard the current tracer.\\n\", tracer);\n\t\t\texit(0);\n\t\t}\n\t\tmutex_unlock(&print_mtx);\n\t\tneed_nop = true;\n\t}\n\n\tsave_state.tracer =  tracer;\n\tsave_state.thresh = orig_th;\n\n\tif (need_nop)\n\t\twrite_file(TR_CURRENT, NULL, NOP_TRACER, ERR_EXIT);\n\n\tmutex_unlock(&save_state.mutex);\n}\n\nvoid set_trace_opts(struct ftrace_state *state, bool *new)\n{\n\tint i;\n\tint r;\n\n\t \n\tfor (i = 0; i < OPTIDX_NR; i++)\n\t\tif (state->opt_valid[i] &&\n\t\t    state->opt[i] != new[i]) {\n\t\t\tr = set_trace_opt(optstr[i], new[i]);\n\t\t\tif (r < 0) {\n\t\t\t\twarnx(\"Failed to set the %s option to %s\",\n\t\t\t\t      optstr[i], bool2str(new[i]));\n\t\t\t\tcleanup_exit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tif (verbose_ftrace()) {\n\t\t\t\tmutex_lock(&print_mtx);\n\t\t\t\tprintf(\"%s in %s was set to %s\\n\", optstr[i],\n\t\t\t\t       TR_OPTIONS, bool2str(new[i]));\n\t\t\t\tmutex_unlock(&print_mtx);\n\t\t\t}\n\t\t}\n}\n\nstatic void enable_tracer(void)\n{\n\tmutex_lock(&save_state.mutex);\n\tset_trace_opts(&save_state, use_options);\n\n\twrite_file(TR_THRESH, save_state.thresh, threshold, ERR_CLEANUP);\n\twrite_file(TR_CURRENT, NOP_TRACER, current_tracer, ERR_CLEANUP);\n\n\tmutex_unlock(&save_state.mutex);\n}\n\nstatic void tracing_loop(void)\n{\n\tint ifd = inotify_init();\n\tint wd;\n\tconst ssize_t bufsize = sizeof(inotify_buffer);\n\tconst ssize_t istructsize = sizeof(struct inotify_event);\n\tchar *buf = &inotify_buffer[0];\n\tssize_t nr_read;\n\tchar *p;\n\tint modified;\n\tstruct inotify_event *event;\n\tstruct entry req;\n\tchar *buffer;\n\tconst size_t bufspace = PRINT_BUFFER_SIZE;\n\tstruct timespec timestamp;\n\n\tprint_priority();\n\n\tbuffer = malloc_or_die(bufspace);\n\n\tif (ifd < 0)\n\t\terr(EXIT_FAILURE, \"inotify_init() failed!\");\n\n\n\tif (setup_ftrace) {\n\t\t \n\t\tsave_and_disable_tracer();\n\t\t \n\t\treset_max_latency();\n\t}\n\n\twd = inotify_add_watch(ifd, debug_maxlat, IN_MODIFY);\n\tif (wd < 0)\n\t\terr(EXIT_FAILURE, \"inotify_add_watch() failed!\");\n\n\tif (setup_ftrace)\n\t\tenable_tracer();\n\n\tsignal_blocking(SIG_UNBLOCK);\n\n\twhile (true) {\n\t\tmodified = 0;\n\t\tcheck_signals();\n\t\tnr_read = read(ifd, buf, bufsize);\n\t\tcheck_signals();\n\t\tif (nr_read < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\twarn(\"read() failed on inotify fd!\");\n\t\t\tcleanup_exit(EXIT_FAILURE);\n\t\t}\n\t\tif (nr_read == bufsize)\n\t\t\twarnx(\"inotify() buffer filled, skipping events\");\n\t\tif (nr_read < istructsize) {\n\t\t\twarnx(\"read() returned too few bytes on inotify fd\");\n\t\t\tcleanup_exit(EXIT_FAILURE);\n\t\t}\n\n\t\tfor (p = buf; p < buf + nr_read;) {\n\t\t\tevent = (struct inotify_event *) p;\n\t\t\tif ((event->mask & IN_MODIFY) != 0)\n\t\t\t\tmodified++;\n\t\t\tp += istructsize + event->len;\n\t\t}\n\t\twhile (modified > 0) {\n\t\t\tcheck_signals();\n\t\t\tmutex_lock(&printstate.mutex);\n\t\t\tcheck_signals();\n\t\t\tprintstate_next_ticket(&req);\n\t\t\tif (printstate_cnt_read() > 0) {\n\t\t\t\tprintstate_mark_req_completed(&req);\n\t\t\t\tmutex_unlock(&printstate.mutex);\n\t\t\t\tif (verbose_lostevent()) {\n\t\t\t\t\tclock_gettime_or_die(CLOCK_MONOTONIC,\n\t\t\t\t\t\t\t     &timestamp);\n\t\t\t\t\tprint_lostmessage(&timestamp, buffer,\n\t\t\t\t\t\t\t  bufspace, &req,\n\t\t\t\t\t\t\t  \"inotify loop\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmutex_unlock(&printstate.mutex);\n\t\t\tif (queue_try_to_add_entry(&printqueue, &req) != 0) {\n\t\t\t\t \n\t\t\t\tcheck_signals();\n\t\t\t\tmutex_lock(&print_mtx);\n\t\t\t\tcheck_signals();\n\t\t\t\twrite_or_die(fd_stdout, queue_full_warning,\n\t\t\t\t\t     strlen(queue_full_warning));\n\t\t\t\tmutex_unlock(&print_mtx);\n\t\t\t}\n\t\t\tmodified--;\n\t\t}\n\t}\n}\n\nstatic void *do_printloop(void *arg)\n{\n\tconst size_t bufspace = PRINT_BUFFER_SIZE;\n\tchar *buffer;\n\tlong *rseed = (long *) arg;\n\tstruct drand48_data drandbuf;\n\tlong slept = 0;\n\tstruct entry req;\n\tint prob = 0;\n\tstruct timespec timestamp;\n\tstruct short_msg resize_msg;\n\n\tprint_priority();\n\n\tif (srand48_r(*rseed, &drandbuf) != 0) {\n\t\twarn(\"srand48_r() failed!\\n\");\n\t\tcleanup_exit(EXIT_FAILURE);\n\t}\n\n\tbuffer = malloc_or_die(bufspace);\n\n\twhile (true) {\n\t\treq = queue_wait_for_entry(&printqueue);\n\t\tclock_gettime_or_die(CLOCK_MONOTONIC, &timestamp);\n\t\tmutex_lock(&printstate.mutex);\n\t\tif (prev_req_won_race(&req)) {\n\t\t\tprintstate_mark_req_completed(&req);\n\t\t\tmutex_unlock(&printstate.mutex);\n\t\t\tif (verbose_lostevent())\n\t\t\t\tprint_lostmessage(&timestamp, buffer, bufspace,\n\t\t\t\t\t\t  &req, \"print loop\");\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_unlock(&printstate.mutex);\n\n\t\t \n\t\tif (trace_enable && use_random_sleep) {\n\t\t\tslept = 0;\n\t\t\tprob = table_get_probability(&req, &resize_msg);\n\t\t\tif (!toss_coin(&drandbuf, prob))\n\t\t\t\tslept = go_to_sleep(&req);\n\t\t\tif (slept >= 0) {\n\t\t\t\t \n\t\t\t\tprintstate_cnt_inc();\n\t\t\t\t \n\t\t\t\tmutex_lock(&printstate.mutex);\n\t\t\t\tprintstate_mark_req_completed(&req);\n\t\t\t\tmutex_unlock(&printstate.mutex);\n\t\t\t}\n\t\t}\n\t\tif (trace_enable) {\n\t\t\t \n\t\t\tif (slept >= 0)\n\t\t\t\t \n\t\t\t\tprint_tracefile(&resize_msg, &timestamp, buffer,\n\t\t\t\t\t\tbufspace, slept, &req);\n\t\t\telse\n\t\t\t\tprint_skipmessage(&resize_msg, &timestamp,\n\t\t\t\t\t\t  buffer, bufspace, &req, true);\n\t\t} else {\n\t\t\tprint_skipmessage(&resize_msg, &timestamp, buffer,\n\t\t\t\t\t  bufspace, &req, false);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void start_printthread(void)\n{\n\tunsigned int i;\n\tlong *seed;\n\tint ufd;\n\n\tufd = open(DEV_URANDOM, O_RDONLY);\n\tif (nr_threads > MAX_THREADS) {\n\t\twarnx(\n\"Number of requested print threads was %d, max number is %d\\n\",\n\t\t      nr_threads, MAX_THREADS);\n\t\tnr_threads = MAX_THREADS;\n\t}\n\tfor (i = 0; i < nr_threads; i++) {\n\t\tseed = malloc_or_die(sizeof(*seed));\n\t\tif (ufd <  0 ||\n\t\t    read(ufd, seed, sizeof(*seed)) != sizeof(*seed)) {\n\t\t\tprintf(\n\"Warning! Using trivial random number seed, since %s not available\\n\",\n\t\t\tDEV_URANDOM);\n\t\t\tfflush(stdout);\n\t\t\t*seed = i;\n\t\t}\n\t\terrno = pthread_create(&printthread[i], NULL, do_printloop,\n\t\t\t\t       seed);\n\t\tif (errno)\n\t\t\terr(EXIT_FAILURE, \"pthread_create()\");\n\t}\n\tif (ufd > 0 && close(ufd) != 0)\n\t\twarn(\"close() failed\");\n}\n\nstatic void show_usage(void)\n{\n\tprintf(\n\"Usage: %s [OPTION]...\\n\\n\"\n\"Collect closely occurring latencies from %s\\n\"\n\"with any of the following tracers: preemptirqsoff, preemptoff, irqsoff, \"\n\"wakeup,\\nwakeup_dl, or wakeup_rt.\\n\\n\"\n\n\"The occurrence of a latency is detected by monitoring the file\\n\"\n\"%s with inotify.\\n\\n\"\n\n\"The following options are supported:\\n\\n\"\n\n\"-l, --list\\t\\tList the latency tracers that are supported by the\\n\"\n\"\\t\\t\\tcurrently running Linux kernel. If you don't see the\\n\"\n\"\\t\\t\\ttracer that you want, you will probably need to\\n\"\n\"\\t\\t\\tchange your kernel config and build a new kernel.\\n\\n\"\n\n\"-t, --tracer TR\\t\\tUse the tracer TR. The default is to use the first\\n\"\n\"\\t\\t\\ttracer that is supported by the kernel in the following\\n\"\n\"\\t\\t\\torder of precedence:\\n\\n\"\n\"\\t\\t\\tpreemptirqsoff\\n\"\n\"\\t\\t\\tpreemptoff\\n\"\n\"\\t\\t\\tirqsoff\\n\"\n\"\\t\\t\\twakeup\\n\"\n\"\\t\\t\\twakeup_rt\\n\"\n\"\\t\\t\\twakeup_dl\\n\"\n\"\\n\"\n\"\\t\\t\\tIf TR is not on the list above, then a warning will be\\n\"\n\"\\t\\t\\tprinted.\\n\\n\"\n\n\"-F, --force\\t\\tProceed even if another ftrace tracer is active. Without\\n\"\n\"\\t\\t\\tthis option, the program will refuse to start tracing if\\n\"\n\"\\t\\t\\tany other tracer than the nop tracer is active.\\n\\n\"\n\n\"-s, --threshold TH\\tConfigure ftrace to use a threshold of TH microseconds\\n\"\n\"\\t\\t\\tfor the tracer. The default is 0, which means that\\n\"\n\"\\t\\t\\ttracing_max_latency will be used. tracing_max_latency is\\n\"\n\"\\t\\t\\tset to 0 when the program is started and contains the\\n\"\n\"\\t\\t\\tmaximum of the latencies that have been encountered.\\n\\n\"\n\n\"-f, --function\\t\\tEnable the function-trace option in trace_options. With\\n\"\n\"\\t\\t\\tthis option, ftrace will trace the functions that are\\n\"\n\"\\t\\t\\texecuted during a latency, without it we only get the\\n\"\n\"\\t\\t\\tbeginning, end, and backtrace.\\n\\n\"\n\n\"-g, --graph\\t\\tEnable the display-graph option in trace_option. This\\n\"\n\"\\t\\t\\toption causes ftrace to show the graph of how functions\\n\"\n\"\\t\\t\\tare calling other functions.\\n\\n\"\n\n\"-c, --policy POL\\tRun the program with scheduling policy POL. POL can be\\n\"\n\"\\t\\t\\tother, batch, idle, rr or fifo. The default is rr. When\\n\"\n\"\\t\\t\\tusing rr or fifo, remember that these policies may cause\\n\"\n\"\\t\\t\\tother tasks to experience latencies.\\n\\n\"\n\n\"-p, --priority PRI\\tRun the program with priority PRI. The acceptable range\\n\"\n\"\\t\\t\\tof PRI depends on the scheduling policy.\\n\\n\"\n\n\"-n, --notrace\\t\\tIf latency is detected, do not print out the content of\\n\"\n\"\\t\\t\\tthe trace file to standard output\\n\\n\"\n\n\"-t, --threads NRTHR\\tRun NRTHR threads for printing. Default is %d.\\n\\n\"\n\n\"-r, --random\\t\\tArbitrarily sleep a certain amount of time, default\\n\"\n\"\\t\\t\\t%ld ms, before reading the trace file. The\\n\"\n\"\\t\\t\\tprobabilities for sleep are chosen so that the\\n\"\n\"\\t\\t\\tprobability of obtaining any of a cluster of closely\\n\"\n\"\\t\\t\\toccurring latencies are equal, i.e. we will randomly\\n\"\n\"\\t\\t\\tchoose which one we collect from the trace file.\\n\\n\"\n\"\\t\\t\\tThis option is probably only useful with the irqsoff,\\n\"\n\"\\t\\t\\tpreemptoff, and preemptirqsoff tracers.\\n\\n\"\n\n\"-a, --nrlat NRLAT\\tFor the purpose of arbitrary delay, assume that there\\n\"\n\"\\t\\t\\tare no more than NRLAT clustered latencies. If NRLAT\\n\"\n\"\\t\\t\\tlatencies are detected during a run, this value will\\n\"\n\"\\t\\t\\tautomatically be increased to NRLAT + 1 and then to\\n\"\n\"\\t\\t\\tNRLAT + 2 and so on. The default is %d. This option\\n\"\n\"\\t\\t\\timplies -r. We need to know this number in order to\\n\"\n\"\\t\\t\\tbe able to calculate the probabilities of sleeping.\\n\"\n\"\\t\\t\\tSpecifically, the probabilities of not sleeping, i.e. to\\n\"\n\"\\t\\t\\tdo an immediate printout will be:\\n\\n\"\n\"\\t\\t\\t1/NRLAT  1/(NRLAT - 1) ... 1/3  1/2  1\\n\\n\"\n\"\\t\\t\\tThe probability of sleeping will be:\\n\\n\"\n\"\\t\\t\\t1 - P, where P is from the series above\\n\\n\"\n\"\\t\\t\\tThis descending probability will cause us to choose\\n\"\n\"\\t\\t\\tan occurrence at random. Observe that the final\\n\"\n\"\\t\\t\\tprobability is 0, it is when we reach this probability\\n\"\n\"\\t\\t\\tthat we increase NRLAT automatically. As an example,\\n\"\n\"\\t\\t\\twith the default value of 2, the probabilities will be:\\n\\n\"\n\"\\t\\t\\t1/2  0\\n\\n\"\n\"\\t\\t\\tThis means, when a latency is detected we will sleep\\n\"\n\"\\t\\t\\twith 50%% probability. If we ever detect another latency\\n\"\n\"\\t\\t\\tduring the sleep period, then the probability of sleep\\n\"\n\"\\t\\t\\twill be 0%% and the table will be expanded to:\\n\\n\"\n\"\\t\\t\\t1/3  1/2  0\\n\\n\"\n\n\"-v, --verbose\\t\\tIncrease the verbosity. If this option is given once,\\n\"\n\"\\t\\t\\tthen print a message every time that the NRLAT value\\n\"\n\"\\t\\t\\tis automatically increased. It also causes a message to\\n\"\n\"\\t\\t\\tbe printed when the ftrace settings are changed. If this\\n\"\n\"\\t\\t\\toption is given at least twice, then also print a\\n\"\n\"\\t\\t\\twarning for lost events.\\n\\n\"\n\n\"-u, --time TIME\\t\\tArbitrarily sleep for a specified time TIME ms before\\n\"\n\"\\t\\t\\tprinting out the trace from the trace file. The default\\n\"\n\"\\t\\t\\tis %ld ms. This option implies -r.\\n\\n\"\n\n\"-x, --no-ftrace\\t\\tDo not configure ftrace. This assume that the user\\n\"\n\"\\t\\t\\tconfigures the ftrace files in sysfs such as\\n\"\n\"\\t\\t\\t/sys/kernel/tracing/current_tracer or equivalent.\\n\\n\"\n\n\"-i, --tracefile FILE\\tUse FILE as trace file. The default is\\n\"\n\"\\t\\t\\t%s.\\n\"\n\"\\t\\t\\tThis options implies -x\\n\\n\"\n\n\"-m, --max-lat FILE\\tUse FILE as tracing_max_latency file. The default is\\n\"\n\"\\t\\t\\t%s.\\n\"\n\"\\t\\t\\tThis options implies -x\\n\\n\"\n,\nprg_name, debug_tracefile_dflt, debug_maxlat_dflt, DEFAULT_NR_PRINTER_THREADS,\nSLEEP_TIME_MS_DEFAULT, DEFAULT_TABLE_SIZE, SLEEP_TIME_MS_DEFAULT,\ndebug_tracefile_dflt, debug_maxlat_dflt);\n}\n\nstatic void find_tracefiles(void)\n{\n\tdebug_tracefile_dflt = tracefs_get_tracing_file(\"trace\");\n\tif (debug_tracefile_dflt == NULL) {\n\t\t \n\t\tdebug_tracefile_dflt = DEBUG_NOFILE;\n\t}\n\n\tdebug_maxlat_dflt = tracefs_get_tracing_file(\"tracing_max_latency\");\n\tif (debug_maxlat_dflt == NULL) {\n\t\t \n\t\tdebug_maxlat_dflt = DEBUG_NOFILE;\n\t}\n\n\tdebug_tracefile = debug_tracefile_dflt;\n\tdebug_maxlat = debug_maxlat_dflt;\n}\n\nbool alldigits(const char *s)\n{\n\tfor (; *s != '\\0'; s++)\n\t\tif (!isdigit(*s))\n\t\t\treturn false;\n\treturn true;\n}\n\nvoid check_alldigits(const char *optarg, const char *argname)\n{\n\tif (!alldigits(optarg))\n\t\terrx(EXIT_FAILURE,\n\t\t     \"The %s parameter expects a decimal argument\\n\", argname);\n}\n\nstatic void scan_arguments(int argc, char *argv[])\n{\n\tint c;\n\tint i;\n\tint option_idx = 0;\n\n\tstatic struct option long_options[] = {\n\t\t{ \"list\",       no_argument,            0, 'l' },\n\t\t{ \"tracer\",\trequired_argument,\t0, 't' },\n\t\t{ \"force\",      no_argument,            0, 'F' },\n\t\t{ \"threshold\",  required_argument,      0, 's' },\n\t\t{ \"function\",   no_argument,            0, 'f' },\n\t\t{ \"graph\",      no_argument,            0, 'g' },\n\t\t{ \"policy\",\trequired_argument,\t0, 'c' },\n\t\t{ \"priority\",\trequired_argument,\t0, 'p' },\n\t\t{ \"help\",\tno_argument,\t\t0, 'h' },\n\t\t{ \"notrace\",\tno_argument,\t\t0, 'n' },\n\t\t{ \"random\",\tno_argument,\t\t0, 'r' },\n\t\t{ \"nrlat\",\trequired_argument,\t0, 'a' },\n\t\t{ \"threads\",\trequired_argument,\t0, 'e' },\n\t\t{ \"time\",\trequired_argument,\t0, 'u' },\n\t\t{ \"verbose\",\tno_argument,\t\t0, 'v' },\n\t\t{ \"no-ftrace\",  no_argument,            0, 'x' },\n\t\t{ \"tracefile\",\trequired_argument,\t0, 'i' },\n\t\t{ \"max-lat\",\trequired_argument,\t0, 'm' },\n\t\t{ 0,\t\t0,\t\t\t0,  0  }\n\t};\n\tconst struct policy *p;\n\tint max, min;\n\tint value;\n\tbool notracer, valid;\n\n\t \n\tfind_tracefiles();\n\n\twhile (true) {\n\t\tc = getopt_long(argc, argv, \"lt:Fs:fgc:p:hnra:e:u:vxi:m:\",\n\t\t\t\tlong_options, &option_idx);\n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'l':\n\t\t\tshow_available();\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcurrent_tracer = strdup(optarg);\n\t\t\tif (!is_relevant_tracer(current_tracer)) {\n\t\t\t\twarnx(\"%s is not a known latency tracer!\\n\",\n\t\t\t\t      current_tracer);\n\t\t\t}\n\t\t\tvalid = tracer_valid(current_tracer, &notracer);\n\t\t\tif (notracer)\n\t\t\t\terrx(EXIT_FAILURE, no_tracer_msg);\n\t\t\tif (!valid)\n\t\t\t\terrx(EXIT_FAILURE,\n\"The tracer %s is not supported by your kernel!\\n\", current_tracer);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tforce_tracer = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcheck_alldigits(optarg, \"-s [--threshold]\");\n\t\t\tthreshold = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tuse_options[OPTIDX_FUNC_TR] = true;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tuse_options[OPTIDX_DISP_GR] = true;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tp = policy_from_name(optarg);\n\t\t\tif (p != NULL) {\n\t\t\t\tsched_policy = p->policy;\n\t\t\t\tsched_policy_set = true;\n\t\t\t\tif (!sched_pri_set) {\n\t\t\t\t\tsched_pri = p->default_pri;\n\t\t\t\t\tsched_pri_set = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twarnx(\"Unknown scheduling %s\\n\", optarg);\n\t\t\t\tshow_usage();\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcheck_alldigits(optarg, \"-p [--priority]\");\n\t\t\tsched_pri = atoi(optarg);\n\t\t\tsched_pri_set = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tshow_usage();\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\ttrace_enable = false;\n\t\t\tuse_random_sleep = false;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tcheck_alldigits(optarg, \"-e [--threads]\");\n\t\t\tvalue = atoi(optarg);\n\t\t\tif (value > 0)\n\t\t\t\tnr_threads = value;\n\t\t\telse {\n\t\t\t\twarnx(\"NRTHR must be > 0\\n\");\n\t\t\t\tshow_usage();\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tcheck_alldigits(optarg, \"-u [--time]\");\n\t\t\tvalue = atoi(optarg);\n\t\t\tif (value < 0) {\n\t\t\t\twarnx(\"TIME must be >= 0\\n\");\n\t\t\t\tshow_usage();\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\ttrace_enable = true;\n\t\t\tuse_random_sleep = true;\n\t\t\tsleep_time = value * USEC_PER_MSEC;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbosity++;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\ttrace_enable = true;\n\t\t\tuse_random_sleep = true;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tcheck_alldigits(optarg, \"-a [--nrlat]\");\n\t\t\tvalue = atoi(optarg);\n\t\t\tif (value <= 0) {\n\t\t\t\twarnx(\"NRLAT must be > 0\\n\");\n\t\t\t\tshow_usage();\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\ttrace_enable = true;\n\t\t\tuse_random_sleep = true;\n\t\t\ttable_startsize = value;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tsetup_ftrace = false;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tsetup_ftrace = false;\n\t\t\tdebug_tracefile = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tsetup_ftrace = false;\n\t\t\tdebug_maxlat = strdup(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tshow_usage();\n\t\t\texit(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (setup_ftrace) {\n\t\tif (!current_tracer) {\n\t\t\tcurrent_tracer = find_default_tracer();\n\t\t\tif (!current_tracer)\n\t\t\t\terrx(EXIT_FAILURE,\n\"No default tracer found and tracer not specified\\n\");\n\t\t}\n\n\t\tif (use_random_sleep && !random_makes_sense(current_tracer)) {\n\t\t\twarnx(\"WARNING: The tracer is %s and random sleep has\",\n\t\t\t      current_tracer);\n\t\t\tfprintf(stderr,\n\"been enabled. Random sleep is intended for the following tracers:\\n\");\n\t\t\tfor (i = 0; random_tracers[i]; i++)\n\t\t\t\tfprintf(stderr, \"%s\\n\", random_tracers[i]);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t}\n\n\tif (debug_tracefile == DEBUG_NOFILE ||\n\t    debug_maxlat == DEBUG_NOFILE)\n\t\terrx(EXIT_FAILURE,\n\"Could not find tracing directory e.g. /sys/kernel/tracing\\n\");\n\n\tif (!sched_policy_set) {\n\t\tsched_policy = SCHED_RR;\n\t\tsched_policy_set = true;\n\t\tif (!sched_pri_set) {\n\t\t\tsched_pri = RT_DEFAULT_PRI;\n\t\t\tsched_pri_set = true;\n\t\t}\n\t}\n\n\tmax = sched_get_priority_max(sched_policy);\n\tmin = sched_get_priority_min(sched_policy);\n\n\tif (sched_pri < min) {\n\t\tprintf(\n\"ATTENTION: Increasing priority to minimum, which is %d\\n\", min);\n\t\tsched_pri = min;\n\t}\n\tif (sched_pri > max) {\n\t\tprintf(\n\"ATTENTION: Reducing priority to maximum, which is %d\\n\", max);\n\t\tsched_pri = max;\n\t}\n}\n\nstatic void show_params(void)\n{\n\tprintf(\n\"\\n\"\n\"Running with scheduling policy %s and priority %d. Using %d print threads.\\n\",\n\t\tpolicy_name(sched_policy), sched_pri, nr_threads);\n\tif (trace_enable) {\n\t\tif (use_random_sleep) {\n\t\t\tprintf(\n\"%s will be printed with random delay\\n\"\n\"Start size of the probability table:\\t\\t\\t%d\\n\"\n\"Print a message when the prob. table changes size:\\t%s\\n\"\n\"Print a warning when an event has been lost:\\t\\t%s\\n\"\n\"Sleep time is:\\t\\t\\t\\t\\t\\t%ld ms\\n\",\ndebug_tracefile,\ntable_startsize,\nbool2str(verbose_sizechange()),\nbool2str(verbose_lostevent()),\nsleep_time / USEC_PER_MSEC);\n\t\t} else {\n\t\t\tprintf(\"%s will be printed immediately\\n\",\n\t\t\t       debug_tracefile);\n\t\t}\n\t} else {\n\t\tprintf(\"%s will not be printed\\n\",\n\t\t       debug_tracefile);\n\t}\n\tif (setup_ftrace) {\n\t\tprintf(\"Tracer:\\t\\t\\t\\t\\t\\t\\t%s\\n\"\n\t\t       \"%s option:\\t\\t\\t\\t\\t%s\\n\"\n\t\t       \"%s option:\\t\\t\\t\\t\\t%s\\n\",\n\t\t       current_tracer,\n\t\t       optstr[OPTIDX_FUNC_TR],\n\t\t       bool2str(use_options[OPTIDX_FUNC_TR]),\n\t\t       optstr[OPTIDX_DISP_GR],\n\t\t       bool2str(use_options[OPTIDX_DISP_GR]));\n\t\tif (!strcmp(threshold, \"0\"))\n\t\t\tprintf(\"Threshold:\\t\\t\\t\\t\\t\\ttracing_max_latency\\n\");\n\t\telse\n\t\t\tprintf(\"Threshold:\\t\\t\\t\\t\\t\\t%s\\n\", threshold);\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n\tinit_save_state();\n\tsignal_blocking(SIG_BLOCK);\n\tsetup_sig_handler();\n\topen_stdout();\n\n\tif (argc >= 1)\n\t\tprg_name = argv[0];\n\telse\n\t\tprg_name = prg_unknown;\n\n\tscan_arguments(argc, argv);\n\tshow_params();\n\n\tinit_printstate();\n\tinit_print_mtx();\n\tif (use_random_sleep) {\n\t\tinit_probabilities();\n\t\tif (verbose_sizechange())\n\t\t\tprintf(\"Initializing probability table to %d\\n\",\n\t\t\t       table_startsize);\n\t\tsleeptable_resize(table_startsize, false, NULL);\n\t}\n\tset_priority();\n\tinit_queue(&printqueue);\n\tstart_printthread();\n\ttracing_loop();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}