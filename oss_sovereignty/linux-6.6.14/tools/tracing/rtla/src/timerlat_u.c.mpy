{
  "module_name": "timerlat_u.c",
  "hash_id": "06d700c8250b7855741b011e0dc937a1e18514c318c182f5d694c507b8c3caeb",
  "original_prompt": "Ingested from linux-6.6.14/tools/tracing/rtla/src/timerlat_u.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <sched.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <tracefs.h>\n#include <pthread.h>\n#include <sys/wait.h>\n#include <sys/prctl.h>\n\n#include \"utils.h\"\n#include \"timerlat_u.h\"\n\n \nstatic int timerlat_u_main(int cpu, struct timerlat_u_params *params)\n{\n\tstruct sched_param sp = { .sched_priority = 95 };\n\tchar buffer[1024];\n\tint timerlat_fd;\n\tcpu_set_t set;\n\tint retval;\n\n\t \n\tCPU_ZERO(&set);\n\tCPU_SET(cpu, &set);\n\n\tretval = sched_setaffinity(gettid(), sizeof(set), &set);\n\tif (retval == -1) {\n\t\tdebug_msg(\"Error setting user thread affinity %d, is the CPU online?\\n\", cpu);\n\t\texit(1);\n\t}\n\n\tif (!params->sched_param) {\n\t\tretval = sched_setscheduler(0, SCHED_FIFO, &sp);\n\t\tif (retval < 0) {\n\t\t\terr_msg(\"Error setting timerlat u default priority: %s\\n\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tretval = __set_sched_attr(getpid(), params->sched_param);\n\t\tif (retval) {\n\t\t\t \n\t\t\texit(0);\n\t\t}\n\t}\n\n\tif (params->cgroup_name) {\n\t\tretval = set_pid_cgroup(gettid(), params->cgroup_name);\n\t\tif (!retval) {\n\t\t\terr_msg(\"Error setting timerlat u cgroup pid\\n\");\n\t\t\tpthread_exit(&retval);\n\t\t}\n\t}\n\n\t \n\tsnprintf(buffer, sizeof(buffer), \"osnoise/per_cpu/cpu%d/timerlat_fd\", cpu);\n\n\ttimerlat_fd = tracefs_instance_file_open(NULL, buffer, O_RDONLY);\n\tif (timerlat_fd < 0) {\n\t\terr_msg(\"Error opening %s:%s\\n\", buffer, strerror(errno));\n\t\texit(1);\n\t}\n\n\tdebug_msg(\"User-space timerlat pid %d on cpu %d\\n\", gettid(), cpu);\n\n\t \n\twhile (true) {\n\t\tretval = read(timerlat_fd, buffer, 1024);\n\t\tif (retval < 0)\n\t\t\tbreak;\n\t}\n\n\tclose(timerlat_fd);\n\n\tdebug_msg(\"Leaving timerlat pid %d on cpu %d\\n\", gettid(), cpu);\n\texit(0);\n}\n\n \nstatic int timerlat_u_send_kill(pid_t *procs, int nr_cpus)\n{\n\tint killed = 0;\n\tint i, retval;\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tif (!procs[i])\n\t\t\tcontinue;\n\t\tretval = kill(procs[i], SIGKILL);\n\t\tif (!retval)\n\t\t\tkilled++;\n\t\telse\n\t\t\terr_msg(\"Error killing child process %d\\n\", procs[i]);\n\t}\n\n\treturn killed;\n}\n\n \nvoid *timerlat_u_dispatcher(void *data)\n{\n\tint nr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\tstruct timerlat_u_params *params = data;\n\tchar proc_name[128];\n\tint procs_count = 0;\n\tint retval = 1;\n\tpid_t *procs;\n\tint wstatus;\n\tpid_t pid;\n\tint i;\n\n\tdebug_msg(\"Dispatching timerlat u procs\\n\");\n\n\tprocs = calloc(nr_cpus, sizeof(pid_t));\n\tif (!procs)\n\t\tpthread_exit(&retval);\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tif (params->set && !CPU_ISSET(i, params->set))\n\t\t\tcontinue;\n\n\t\tpid = fork();\n\n\t\t \n\t\tif (!pid) {\n\n\t\t\t \n\t\t\tsnprintf(proc_name, sizeof(proc_name), \"timerlatu/%d\", i);\n\t\t\tpthread_setname_np(pthread_self(), proc_name);\n\t\t\tprctl(PR_SET_NAME, (unsigned long)proc_name, 0, 0, 0);\n\n\t\t\ttimerlat_u_main(i, params);\n\t\t\t \n\t\t\tpthread_exit(&retval);\n\t\t}\n\n\t\t \n\t\tif (pid == -1) {\n\t\t\ttimerlat_u_send_kill(procs, nr_cpus);\n\t\t\tdebug_msg(\"Failed to create child processes\");\n\t\t\tpthread_exit(&retval);\n\t\t}\n\n\t\tprocs_count++;\n\t\tprocs[i] = pid;\n\t}\n\n\twhile (params->should_run) {\n\t\t \n\t\tpid = waitpid(-1, &wstatus, WNOHANG);\n\t\tif (pid != 0) {\n\t\t\tfor (i = 0; i < nr_cpus; i++) {\n\t\t\t\tif (procs[i] == pid) {\n\t\t\t\t\tprocs[i] = 0;\n\t\t\t\t\tprocs_count--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!procs_count)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tsleep(1);\n\t}\n\n\ttimerlat_u_send_kill(procs, nr_cpus);\n\n\twhile (procs_count) {\n\t\tpid = waitpid(-1, &wstatus, 0);\n\t\tif (pid == -1) {\n\t\t\terr_msg(\"Failed to monitor child processes\");\n\t\t\tpthread_exit(&retval);\n\t\t}\n\t\tfor (i = 0; i < nr_cpus; i++) {\n\t\t\tif (procs[i] == pid) {\n\t\t\t\tprocs[i] = 0;\n\t\t\t\tprocs_count--;\n\t\t\t}\n\t\t}\n\t}\n\n\tparams->stopped_running = 1;\n\n\tfree(procs);\n\tretval = 0;\n\tpthread_exit(&retval);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}