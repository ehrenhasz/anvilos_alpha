{
  "module_name": "utils.c",
  "hash_id": "7cef29dc5558c31938c6a51ead2d2dd57498e6f40b7c0df68eebd9cb4dbf539c",
  "original_prompt": "Ingested from linux-6.6.14/tools/tracing/rtla/src/utils.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <dirent.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <stdio.h>\n\n#include \"utils.h\"\n\n#define MAX_MSG_LENGTH\t1024\nint config_debug;\n\n \nvoid err_msg(const char *fmt, ...)\n{\n\tchar message[MAX_MSG_LENGTH];\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(message, sizeof(message), fmt, ap);\n\tva_end(ap);\n\n\tfprintf(stderr, \"%s\", message);\n}\n\n \nvoid debug_msg(const char *fmt, ...)\n{\n\tchar message[MAX_MSG_LENGTH];\n\tva_list ap;\n\n\tif (!config_debug)\n\t\treturn;\n\n\tva_start(ap, fmt);\n\tvsnprintf(message, sizeof(message), fmt, ap);\n\tva_end(ap);\n\n\tfprintf(stderr, \"%s\", message);\n}\n\n \nlong long get_llong_from_str(char *start)\n{\n\tlong long value;\n\tchar *end;\n\n\terrno = 0;\n\tvalue = strtoll(start, &end, 10);\n\tif (errno || start == end)\n\t\treturn -1;\n\n\treturn value;\n}\n\n \nvoid get_duration(time_t start_time, char *output, int output_size)\n{\n\ttime_t now = time(NULL);\n\tstruct tm *tm_info;\n\ttime_t duration;\n\n\tduration = difftime(now, start_time);\n\ttm_info = gmtime(&duration);\n\n\tsnprintf(output, output_size, \"%3d %02d:%02d:%02d\",\n\t\t\ttm_info->tm_yday,\n\t\t\ttm_info->tm_hour,\n\t\t\ttm_info->tm_min,\n\t\t\ttm_info->tm_sec);\n}\n\n \nint parse_cpu_set(char *cpu_list, cpu_set_t *set)\n{\n\tconst char *p;\n\tint end_cpu;\n\tint nr_cpus;\n\tint cpu;\n\tint i;\n\n\tCPU_ZERO(set);\n\n\tnr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\n\tfor (p = cpu_list; *p; ) {\n\t\tcpu = atoi(p);\n\t\tif (cpu < 0 || (!cpu && *p != '0') || cpu >= nr_cpus)\n\t\t\tgoto err;\n\n\t\twhile (isdigit(*p))\n\t\t\tp++;\n\t\tif (*p == '-') {\n\t\t\tp++;\n\t\t\tend_cpu = atoi(p);\n\t\t\tif (end_cpu < cpu || (!end_cpu && *p != '0') || end_cpu >= nr_cpus)\n\t\t\t\tgoto err;\n\t\t\twhile (isdigit(*p))\n\t\t\t\tp++;\n\t\t} else\n\t\t\tend_cpu = cpu;\n\n\t\tif (cpu == end_cpu) {\n\t\t\tdebug_msg(\"cpu_set: adding cpu %d\\n\", cpu);\n\t\t\tCPU_SET(cpu, set);\n\t\t} else {\n\t\t\tfor (i = cpu; i <= end_cpu; i++) {\n\t\t\t\tdebug_msg(\"cpu_set: adding cpu %d\\n\", i);\n\t\t\t\tCPU_SET(i, set);\n\t\t\t}\n\t\t}\n\n\t\tif (*p == ',')\n\t\t\tp++;\n\t}\n\n\treturn 0;\nerr:\n\tdebug_msg(\"Error parsing the cpu set %s\\n\", cpu_list);\n\treturn 1;\n}\n\n \nlong parse_seconds_duration(char *val)\n{\n\tchar *end;\n\tlong t;\n\n\tt = strtol(val, &end, 10);\n\n\tif (end) {\n\t\tswitch (*end) {\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tt *= 60;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tt *= 60 * 60;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tt *= 24 * 60 * 60;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn t;\n}\n\n \nlong parse_ns_duration(char *val)\n{\n\tchar *end;\n\tlong t;\n\n\tt = strtol(val, &end, 10);\n\n\tif (end) {\n\t\tif (!strncmp(end, \"ns\", 2)) {\n\t\t\treturn t;\n\t\t} else if (!strncmp(end, \"us\", 2)) {\n\t\t\tt *= 1000;\n\t\t\treturn t;\n\t\t} else if (!strncmp(end, \"ms\", 2)) {\n\t\t\tt *= 1000 * 1000;\n\t\t\treturn t;\n\t\t} else if (!strncmp(end, \"s\", 1)) {\n\t\t\tt *= 1000 * 1000 * 1000;\n\t\t\treturn t;\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn t;\n}\n\n \n#ifdef __x86_64__\n# define __NR_sched_setattr\t314\n# define __NR_sched_getattr\t315\n#elif __i386__\n# define __NR_sched_setattr\t351\n# define __NR_sched_getattr\t352\n#elif __arm__\n# define __NR_sched_setattr\t380\n# define __NR_sched_getattr\t381\n#elif __aarch64__ || __riscv\n# define __NR_sched_setattr\t274\n# define __NR_sched_getattr\t275\n#elif __powerpc__\n# define __NR_sched_setattr\t355\n# define __NR_sched_getattr\t356\n#elif __s390x__\n# define __NR_sched_setattr\t345\n# define __NR_sched_getattr\t346\n#endif\n\n#define SCHED_DEADLINE\t\t6\n\nstatic inline int sched_setattr(pid_t pid, const struct sched_attr *attr,\n\t\t\t\tunsigned int flags) {\n\treturn syscall(__NR_sched_setattr, pid, attr, flags);\n}\n\nstatic inline int sched_getattr(pid_t pid, struct sched_attr *attr,\n\t\t\t\tunsigned int size, unsigned int flags)\n{\n\treturn syscall(__NR_sched_getattr, pid, attr, size, flags);\n}\n\nint __set_sched_attr(int pid, struct sched_attr *attr)\n{\n\tint flags = 0;\n\tint retval;\n\n\tretval = sched_setattr(pid, attr, flags);\n\tif (retval < 0) {\n\t\terr_msg(\"Failed to set sched attributes to the pid %d: %s\\n\",\n\t\t\tpid, strerror(errno));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int procfs_is_workload_pid(const char *comm_prefix, struct dirent *proc_entry)\n{\n\tchar buffer[MAX_PATH];\n\tint comm_fd, retval;\n\tchar *t_name;\n\n\tif (proc_entry->d_type != DT_DIR)\n\t\treturn 0;\n\n\tif (*proc_entry->d_name == '.')\n\t\treturn 0;\n\n\t \n\tfor (t_name = proc_entry->d_name; t_name; t_name++) {\n\t\tif (!isdigit(*t_name))\n\t\t\tbreak;\n\t}\n\n\tif (*t_name != '\\0')\n\t\treturn 0;\n\n\tsnprintf(buffer, MAX_PATH, \"/proc/%s/comm\", proc_entry->d_name);\n\tcomm_fd = open(buffer, O_RDONLY);\n\tif (comm_fd < 0)\n\t\treturn 0;\n\n\tmemset(buffer, 0, MAX_PATH);\n\tretval = read(comm_fd, buffer, MAX_PATH);\n\n\tclose(comm_fd);\n\n\tif (retval <= 0)\n\t\treturn 0;\n\n\tretval = strncmp(comm_prefix, buffer, strlen(comm_prefix));\n\tif (retval)\n\t\treturn 0;\n\n\t \n\tdebug_msg(\"Found workload pid:%s comm:%s\", proc_entry->d_name, buffer);\n\n\treturn 1;\n}\n\n \nint set_comm_sched_attr(const char *comm_prefix, struct sched_attr *attr)\n{\n\tstruct dirent *proc_entry;\n\tDIR *procfs;\n\tint retval;\n\n\tif (strlen(comm_prefix) >= MAX_PATH) {\n\t\terr_msg(\"Command prefix is too long: %d < strlen(%s)\\n\",\n\t\t\tMAX_PATH, comm_prefix);\n\t\treturn 1;\n\t}\n\n\tprocfs = opendir(\"/proc\");\n\tif (!procfs) {\n\t\terr_msg(\"Could not open procfs\\n\");\n\t\treturn 1;\n\t}\n\n\twhile ((proc_entry = readdir(procfs))) {\n\n\t\tretval = procfs_is_workload_pid(comm_prefix, proc_entry);\n\t\tif (!retval)\n\t\t\tcontinue;\n\n\t\t \n\t\tretval = __set_sched_attr(atoi(proc_entry->d_name), attr);\n\t\tif (retval) {\n\t\t\terr_msg(\"Error setting sched attributes for pid:%s\\n\", proc_entry->d_name);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tdebug_msg(\"Set sched attributes for pid:%s\\n\", proc_entry->d_name);\n\t}\n\treturn 0;\n\nout_err:\n\tclosedir(procfs);\n\treturn 1;\n}\n\n#define INVALID_VAL\t(~0L)\nstatic long get_long_ns_after_colon(char *start)\n{\n\tlong val = INVALID_VAL;\n\n\t \n\tstart = strstr(start, \":\");\n\tif (!start)\n\t\treturn -1;\n\n\t \n\tstart++;\n\tval = parse_ns_duration(start);\n\n\treturn val;\n}\n\nstatic long get_long_after_colon(char *start)\n{\n\tlong val = INVALID_VAL;\n\n\t \n\tstart = strstr(start, \":\");\n\tif (!start)\n\t\treturn -1;\n\n\t \n\tstart++;\n\tval = get_llong_from_str(start);\n\n\treturn val;\n}\n\n \nint parse_prio(char *arg, struct sched_attr *sched_param)\n{\n\tlong prio;\n\tlong runtime;\n\tlong period;\n\n\tmemset(sched_param, 0, sizeof(*sched_param));\n\tsched_param->size = sizeof(*sched_param);\n\n\tswitch (arg[0]) {\n\tcase 'd':\n\tcase 'D':\n\t\t \n\t\tif (strlen(arg) < 4)\n\t\t\treturn -1;\n\n\t\truntime = get_long_ns_after_colon(arg);\n\t\tif (runtime == INVALID_VAL)\n\t\t\treturn -1;\n\n\t\tperiod = get_long_ns_after_colon(&arg[2]);\n\t\tif (period == INVALID_VAL)\n\t\t\treturn -1;\n\n\t\tif (runtime > period)\n\t\t\treturn -1;\n\n\t\tsched_param->sched_policy   = SCHED_DEADLINE;\n\t\tsched_param->sched_runtime  = runtime;\n\t\tsched_param->sched_deadline = period;\n\t\tsched_param->sched_period   = period;\n\t\tbreak;\n\tcase 'f':\n\tcase 'F':\n\t\t \n\t\tprio = get_long_after_colon(arg);\n\t\tif (prio == INVALID_VAL)\n\t\t\treturn -1;\n\n\t\tif (prio < sched_get_priority_min(SCHED_FIFO))\n\t\t\treturn -1;\n\t\tif (prio > sched_get_priority_max(SCHED_FIFO))\n\t\t\treturn -1;\n\n\t\tsched_param->sched_policy   = SCHED_FIFO;\n\t\tsched_param->sched_priority = prio;\n\t\tbreak;\n\tcase 'r':\n\tcase 'R':\n\t\t \n\t\tprio = get_long_after_colon(arg);\n\t\tif (prio == INVALID_VAL)\n\t\t\treturn -1;\n\n\t\tif (prio < sched_get_priority_min(SCHED_RR))\n\t\t\treturn -1;\n\t\tif (prio > sched_get_priority_max(SCHED_RR))\n\t\t\treturn -1;\n\n\t\tsched_param->sched_policy   = SCHED_RR;\n\t\tsched_param->sched_priority = prio;\n\t\tbreak;\n\tcase 'o':\n\tcase 'O':\n\t\t \n\t\tprio = get_long_after_colon(arg);\n\t\tif (prio == INVALID_VAL)\n\t\t\treturn -1;\n\n\t\tif (prio < sched_get_priority_min(SCHED_OTHER))\n\t\t\treturn -1;\n\t\tif (prio > sched_get_priority_max(SCHED_OTHER))\n\t\t\treturn -1;\n\n\t\tsched_param->sched_policy   = SCHED_OTHER;\n\t\tsched_param->sched_priority = prio;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nint set_cpu_dma_latency(int32_t latency)\n{\n\tint retval;\n\tint fd;\n\n\tfd = open(\"/dev/cpu_dma_latency\", O_RDWR);\n\tif (fd < 0) {\n\t\terr_msg(\"Error opening /dev/cpu_dma_latency\\n\");\n\t\treturn -1;\n\t}\n\n\tretval = write(fd, &latency, 4);\n\tif (retval < 1) {\n\t\terr_msg(\"Error setting /dev/cpu_dma_latency\\n\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tdebug_msg(\"Set /dev/cpu_dma_latency to %d\\n\", latency);\n\n\treturn fd;\n}\n\n#define _STR(x) #x\n#define STR(x) _STR(x)\n\n \nstatic const int find_mount(const char *fs, char *mp, int sizeof_mp)\n{\n\tchar mount_point[MAX_PATH];\n\tchar type[100];\n\tint found = 0;\n\tFILE *fp;\n\n\tfp = fopen(\"/proc/mounts\", \"r\");\n\tif (!fp)\n\t\treturn 0;\n\n\twhile (fscanf(fp, \"%*s %\" STR(MAX_PATH) \"s %99s %*s %*d %*d\\n\",\tmount_point, type) == 2) {\n\t\tif (strcmp(type, fs) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(fp);\n\n\tif (!found)\n\t\treturn 0;\n\n\tmemset(mp, 0, sizeof_mp);\n\tstrncpy(mp, mount_point, sizeof_mp - 1);\n\n\tdebug_msg(\"Fs %s found at %s\\n\", fs, mp);\n\treturn 1;\n}\n\n \nstatic int get_self_cgroup(char *self_cg, int sizeof_self_cg)\n{\n\tchar path[MAX_PATH], *start;\n\tint fd, retval;\n\n\tsnprintf(path, MAX_PATH, \"/proc/%d/cgroup\", getpid());\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tretval = read(fd, path, MAX_PATH);\n\n\tclose(fd);\n\n\tif (retval <= 0)\n\t\treturn 0;\n\n\tstart = path;\n\n\tstart = strstr(start, \":\");\n\tif (!start)\n\t\treturn 0;\n\n\t \n\tstart++;\n\n\tstart = strstr(start, \":\");\n\tif (!start)\n\t\treturn 0;\n\n\t \n\tstart++;\n\n\tif (strlen(start) >= sizeof_self_cg)\n\t\treturn 0;\n\n\tsnprintf(self_cg, sizeof_self_cg, \"%s\", start);\n\n\t \n\tstart = strstr(self_cg, \"\\n\");\n\n\t \n\tif (!start)\n\t\treturn 0;\n\n\t \n\t*start = '\\0';\n\n\treturn 1;\n}\n\n \nint set_pid_cgroup(pid_t pid, const char *cgroup)\n{\n\tchar cgroup_path[MAX_PATH - strlen(\"/cgroup.procs\")];\n\tchar cgroup_procs[MAX_PATH];\n\tchar pid_str[24];\n\tint retval;\n\tint cg_fd;\n\n\tretval = find_mount(\"cgroup2\", cgroup_path, sizeof(cgroup_path));\n\tif (!retval) {\n\t\terr_msg(\"Did not find cgroupv2 mount point\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!cgroup) {\n\t\tretval = get_self_cgroup(&cgroup_path[strlen(cgroup_path)],\n\t\t\t\tsizeof(cgroup_path) - strlen(cgroup_path));\n\t\tif (!retval) {\n\t\t\terr_msg(\"Did not find self cgroup\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tsnprintf(&cgroup_path[strlen(cgroup_path)],\n\t\t\t\tsizeof(cgroup_path) - strlen(cgroup_path), \"%s/\", cgroup);\n\t}\n\n\tsnprintf(cgroup_procs, MAX_PATH, \"%s/cgroup.procs\", cgroup_path);\n\n\tdebug_msg(\"Using cgroup path at: %s\\n\", cgroup_procs);\n\n\tcg_fd = open(cgroup_procs, O_RDWR);\n\tif (cg_fd < 0)\n\t\treturn 0;\n\n\tsnprintf(pid_str, sizeof(pid_str), \"%d\\n\", pid);\n\n\tretval = write(cg_fd, pid_str, strlen(pid_str));\n\tif (retval < 0)\n\t\terr_msg(\"Error setting cgroup attributes for pid:%s - %s\\n\",\n\t\t\t\tpid_str, strerror(errno));\n\telse\n\t\tdebug_msg(\"Set cgroup attributes for pid:%s\\n\", pid_str);\n\n\tclose(cg_fd);\n\n\treturn (retval >= 0);\n}\n\n \nint set_comm_cgroup(const char *comm_prefix, const char *cgroup)\n{\n\tchar cgroup_path[MAX_PATH - strlen(\"/cgroup.procs\")];\n\tchar cgroup_procs[MAX_PATH];\n\tstruct dirent *proc_entry;\n\tDIR *procfs;\n\tint retval;\n\tint cg_fd;\n\n\tif (strlen(comm_prefix) >= MAX_PATH) {\n\t\terr_msg(\"Command prefix is too long: %d < strlen(%s)\\n\",\n\t\t\tMAX_PATH, comm_prefix);\n\t\treturn 0;\n\t}\n\n\tretval = find_mount(\"cgroup2\", cgroup_path, sizeof(cgroup_path));\n\tif (!retval) {\n\t\terr_msg(\"Did not find cgroupv2 mount point\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!cgroup) {\n\t\tretval = get_self_cgroup(&cgroup_path[strlen(cgroup_path)],\n\t\t\t\tsizeof(cgroup_path) - strlen(cgroup_path));\n\t\tif (!retval) {\n\t\t\terr_msg(\"Did not find self cgroup\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tsnprintf(&cgroup_path[strlen(cgroup_path)],\n\t\t\t\tsizeof(cgroup_path) - strlen(cgroup_path), \"%s/\", cgroup);\n\t}\n\n\tsnprintf(cgroup_procs, MAX_PATH, \"%s/cgroup.procs\", cgroup_path);\n\n\tdebug_msg(\"Using cgroup path at: %s\\n\", cgroup_procs);\n\n\tcg_fd = open(cgroup_procs, O_RDWR);\n\tif (cg_fd < 0)\n\t\treturn 0;\n\n\tprocfs = opendir(\"/proc\");\n\tif (!procfs) {\n\t\terr_msg(\"Could not open procfs\\n\");\n\t\tgoto out_cg;\n\t}\n\n\twhile ((proc_entry = readdir(procfs))) {\n\n\t\tretval = procfs_is_workload_pid(comm_prefix, proc_entry);\n\t\tif (!retval)\n\t\t\tcontinue;\n\n\t\tretval = write(cg_fd, proc_entry->d_name, strlen(proc_entry->d_name));\n\t\tif (retval < 0) {\n\t\t\terr_msg(\"Error setting cgroup attributes for pid:%s - %s\\n\",\n\t\t\t\tproc_entry->d_name, strerror(errno));\n\t\t\tgoto out_procfs;\n\t\t}\n\n\t\tdebug_msg(\"Set cgroup attributes for pid:%s\\n\", proc_entry->d_name);\n\t}\n\n\tclosedir(procfs);\n\tclose(cg_fd);\n\treturn 1;\n\nout_procfs:\n\tclosedir(procfs);\nout_cg:\n\tclose(cg_fd);\n\treturn 0;\n}\n\n \nint auto_house_keeping(cpu_set_t *monitored_cpus)\n{\n\tcpu_set_t rtla_cpus, house_keeping_cpus;\n\tint retval;\n\n\t \n\tretval = sched_getaffinity(getpid(), sizeof(rtla_cpus), &rtla_cpus);\n\tif (retval == -1) {\n\t\tdebug_msg(\"Could not get rtla affinity, rtla might run with the threads!\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tCPU_AND(&house_keeping_cpus, &rtla_cpus, monitored_cpus);\n\tif (!CPU_COUNT(&house_keeping_cpus)) {\n\t\tdebug_msg(\"rtla and the monitored CPUs do not share CPUs.\");\n\t\tdebug_msg(\"Skipping auto house-keeping\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tCPU_XOR(&house_keeping_cpus, &rtla_cpus, monitored_cpus);\n\n\t \n\tCPU_AND(&house_keeping_cpus, &house_keeping_cpus, &rtla_cpus);\n\n\t \n\tif (!CPU_COUNT(&house_keeping_cpus)) {\n\t\tdebug_msg(\"Could not find any CPU for auto house-keeping\\n\");\n\t\treturn 0;\n\t}\n\n\tretval = sched_setaffinity(getpid(), sizeof(house_keeping_cpus), &house_keeping_cpus);\n\tif (retval == -1) {\n\t\tdebug_msg(\"Could not set affinity for auto house-keeping\\n\");\n\t\treturn 0;\n\t}\n\n\tdebug_msg(\"rtla automatically moved to an auto house-keeping cpu set\\n\");\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}