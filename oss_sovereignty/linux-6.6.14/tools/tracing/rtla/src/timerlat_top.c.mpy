{
  "module_name": "timerlat_top.c",
  "hash_id": "946cd81fb63a4ccb3e3443e445c917fcb2e4ab202832dbed7b5f3d23b4ea63cf",
  "original_prompt": "Ingested from linux-6.6.14/tools/tracing/rtla/src/timerlat_top.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <getopt.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <time.h>\n#include <errno.h>\n#include <sched.h>\n#include <pthread.h>\n\n#include \"utils.h\"\n#include \"osnoise.h\"\n#include \"timerlat.h\"\n#include \"timerlat_aa.h\"\n#include \"timerlat_u.h\"\n\nstruct timerlat_top_params {\n\tchar\t\t\t*cpus;\n\tcpu_set_t\t\tmonitored_cpus;\n\tchar\t\t\t*trace_output;\n\tchar\t\t\t*cgroup_name;\n\tunsigned long long\truntime;\n\tlong long\t\tstop_us;\n\tlong long\t\tstop_total_us;\n\tlong long\t\ttimerlat_period_us;\n\tlong long\t\tprint_stack;\n\tint\t\t\tsleep_time;\n\tint\t\t\toutput_divisor;\n\tint\t\t\tduration;\n\tint\t\t\tquiet;\n\tint\t\t\tset_sched;\n\tint\t\t\tdma_latency;\n\tint\t\t\tno_aa;\n\tint\t\t\taa_only;\n\tint\t\t\tdump_tasks;\n\tint\t\t\tcgroup;\n\tint\t\t\thk_cpus;\n\tint\t\t\tuser_top;\n\tcpu_set_t\t\thk_cpu_set;\n\tstruct sched_attr\tsched_param;\n\tstruct trace_events\t*events;\n};\n\nstruct timerlat_top_cpu {\n\tint\t\t\tirq_count;\n\tint\t\t\tthread_count;\n\tint\t\t\tuser_count;\n\n\tunsigned long long\tcur_irq;\n\tunsigned long long\tmin_irq;\n\tunsigned long long\tsum_irq;\n\tunsigned long long\tmax_irq;\n\n\tunsigned long long\tcur_thread;\n\tunsigned long long\tmin_thread;\n\tunsigned long long\tsum_thread;\n\tunsigned long long\tmax_thread;\n\n\tunsigned long long\tcur_user;\n\tunsigned long long\tmin_user;\n\tunsigned long long\tsum_user;\n\tunsigned long long\tmax_user;\n};\n\nstruct timerlat_top_data {\n\tstruct timerlat_top_cpu\t*cpu_data;\n\tint\t\t\tnr_cpus;\n};\n\n \nstatic void\ntimerlat_free_top(struct timerlat_top_data *data)\n{\n\tfree(data->cpu_data);\n\tfree(data);\n}\n\n \nstatic struct timerlat_top_data *timerlat_alloc_top(int nr_cpus)\n{\n\tstruct timerlat_top_data *data;\n\tint cpu;\n\n\tdata = calloc(1, sizeof(*data));\n\tif (!data)\n\t\treturn NULL;\n\n\tdata->nr_cpus = nr_cpus;\n\n\t \n\tdata->cpu_data = calloc(1, sizeof(*data->cpu_data) * nr_cpus);\n\tif (!data->cpu_data)\n\t\tgoto cleanup;\n\n\t \n\tfor (cpu = 0; cpu < nr_cpus; cpu++) {\n\t\tdata->cpu_data[cpu].min_irq = ~0;\n\t\tdata->cpu_data[cpu].min_thread = ~0;\n\t\tdata->cpu_data[cpu].min_user = ~0;\n\t}\n\n\treturn data;\n\ncleanup:\n\ttimerlat_free_top(data);\n\treturn NULL;\n}\n\n \nstatic void\ntimerlat_top_update(struct osnoise_tool *tool, int cpu,\n\t\t    unsigned long long thread,\n\t\t    unsigned long long latency)\n{\n\tstruct timerlat_top_data *data = tool->data;\n\tstruct timerlat_top_cpu *cpu_data = &data->cpu_data[cpu];\n\n\tif (!thread) {\n\t\tcpu_data->irq_count++;\n\t\tcpu_data->cur_irq = latency;\n\t\tupdate_min(&cpu_data->min_irq, &latency);\n\t\tupdate_sum(&cpu_data->sum_irq, &latency);\n\t\tupdate_max(&cpu_data->max_irq, &latency);\n\t} else if (thread == 1) {\n\t\tcpu_data->thread_count++;\n\t\tcpu_data->cur_thread = latency;\n\t\tupdate_min(&cpu_data->min_thread, &latency);\n\t\tupdate_sum(&cpu_data->sum_thread, &latency);\n\t\tupdate_max(&cpu_data->max_thread, &latency);\n\t} else {\n\t\tcpu_data->user_count++;\n\t\tcpu_data->cur_user = latency;\n\t\tupdate_min(&cpu_data->min_user, &latency);\n\t\tupdate_sum(&cpu_data->sum_user, &latency);\n\t\tupdate_max(&cpu_data->max_user, &latency);\n\t}\n}\n\n \nstatic int\ntimerlat_top_handler(struct trace_seq *s, struct tep_record *record,\n\t\t     struct tep_event *event, void *context)\n{\n\tstruct trace_instance *trace = context;\n\tstruct timerlat_top_params *params;\n\tunsigned long long latency, thread;\n\tstruct osnoise_tool *top;\n\tint cpu = record->cpu;\n\n\ttop = container_of(trace, struct osnoise_tool, trace);\n\tparams = top->params;\n\n\tif (!params->aa_only) {\n\t\ttep_get_field_val(s, event, \"context\", record, &thread, 1);\n\t\ttep_get_field_val(s, event, \"timer_latency\", record, &latency, 1);\n\n\t\ttimerlat_top_update(top, cpu, thread, latency);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void timerlat_top_header(struct osnoise_tool *top)\n{\n\tstruct timerlat_top_params *params = top->params;\n\tstruct trace_seq *s = top->trace.seq;\n\tchar duration[26];\n\n\tget_duration(top->start_time, duration, sizeof(duration));\n\n\ttrace_seq_printf(s, \"\\033[2;37;40m\");\n\ttrace_seq_printf(s, \"                                     Timer Latency                                              \");\n\tif (params->user_top)\n\t\ttrace_seq_printf(s, \"                                         \");\n\ttrace_seq_printf(s, \"\\033[0;0;0m\");\n\ttrace_seq_printf(s, \"\\n\");\n\n\ttrace_seq_printf(s, \"%-6s   |          IRQ Timer Latency (%s)        |         Thread Timer Latency (%s)\", duration,\n\t\t\tparams->output_divisor == 1 ? \"ns\" : \"us\",\n\t\t\tparams->output_divisor == 1 ? \"ns\" : \"us\");\n\n\tif (params->user_top) {\n\t\ttrace_seq_printf(s, \"      |    Ret user Timer Latency (%s)\",\n\t\t\t\tparams->output_divisor == 1 ? \"ns\" : \"us\");\n\t}\n\n\ttrace_seq_printf(s, \"\\n\");\n\ttrace_seq_printf(s, \"\\033[2;30;47m\");\n\ttrace_seq_printf(s, \"CPU COUNT      |      cur       min       avg       max |      cur       min       avg       max\");\n\tif (params->user_top)\n\t\ttrace_seq_printf(s, \" |      cur       min       avg       max\");\n\ttrace_seq_printf(s, \"\\033[0;0;0m\");\n\ttrace_seq_printf(s, \"\\n\");\n}\n\n \nstatic void timerlat_top_print(struct osnoise_tool *top, int cpu)\n{\n\n\tstruct timerlat_top_params *params = top->params;\n\tstruct timerlat_top_data *data = top->data;\n\tstruct timerlat_top_cpu *cpu_data = &data->cpu_data[cpu];\n\tint divisor = params->output_divisor;\n\tstruct trace_seq *s = top->trace.seq;\n\n\tif (divisor == 0)\n\t\treturn;\n\n\t \n\tif (!cpu_data->irq_count && !cpu_data->thread_count)\n\t\treturn;\n\n\t \n\ttrace_seq_printf(s, \"%3d #%-9d |\", cpu, cpu_data->irq_count);\n\n\tif (!cpu_data->irq_count) {\n\t\ttrace_seq_printf(s, \"        - \");\n\t\ttrace_seq_printf(s, \"        - \");\n\t\ttrace_seq_printf(s, \"        - \");\n\t\ttrace_seq_printf(s, \"        - |\");\n\t} else {\n\t\ttrace_seq_printf(s, \"%9llu \", cpu_data->cur_irq / params->output_divisor);\n\t\ttrace_seq_printf(s, \"%9llu \", cpu_data->min_irq / params->output_divisor);\n\t\ttrace_seq_printf(s, \"%9llu \", (cpu_data->sum_irq / cpu_data->irq_count) / divisor);\n\t\ttrace_seq_printf(s, \"%9llu |\", cpu_data->max_irq / divisor);\n\t}\n\n\tif (!cpu_data->thread_count) {\n\t\ttrace_seq_printf(s, \"        - \");\n\t\ttrace_seq_printf(s, \"        - \");\n\t\ttrace_seq_printf(s, \"        - \");\n\t\ttrace_seq_printf(s, \"        -\\n\");\n\t} else {\n\t\ttrace_seq_printf(s, \"%9llu \", cpu_data->cur_thread / divisor);\n\t\ttrace_seq_printf(s, \"%9llu \", cpu_data->min_thread / divisor);\n\t\ttrace_seq_printf(s, \"%9llu \",\n\t\t\t\t(cpu_data->sum_thread / cpu_data->thread_count) / divisor);\n\t\ttrace_seq_printf(s, \"%9llu\", cpu_data->max_thread / divisor);\n\t}\n\n\tif (!params->user_top) {\n\t\ttrace_seq_printf(s, \"\\n\");\n\t\treturn;\n\t}\n\n\ttrace_seq_printf(s, \" |\");\n\n\tif (!cpu_data->user_count) {\n\t\ttrace_seq_printf(s, \"        - \");\n\t\ttrace_seq_printf(s, \"        - \");\n\t\ttrace_seq_printf(s, \"        - \");\n\t\ttrace_seq_printf(s, \"        -\\n\");\n\t} else {\n\t\ttrace_seq_printf(s, \"%9llu \", cpu_data->cur_user / divisor);\n\t\ttrace_seq_printf(s, \"%9llu \", cpu_data->min_user / divisor);\n\t\ttrace_seq_printf(s, \"%9llu \",\n\t\t\t\t(cpu_data->sum_user / cpu_data->user_count) / divisor);\n\t\ttrace_seq_printf(s, \"%9llu\\n\", cpu_data->max_user / divisor);\n\t}\n}\n\n \nstatic void clear_terminal(struct trace_seq *seq)\n{\n\tif (!config_debug)\n\t\ttrace_seq_printf(seq, \"\\033c\");\n}\n\n \nstatic void\ntimerlat_print_stats(struct timerlat_top_params *params, struct osnoise_tool *top)\n{\n\tstruct trace_instance *trace = &top->trace;\n\tstatic int nr_cpus = -1;\n\tint i;\n\n\tif (params->aa_only)\n\t\treturn;\n\n\tif (nr_cpus == -1)\n\t\tnr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\n\tif (!params->quiet)\n\t\tclear_terminal(trace->seq);\n\n\ttimerlat_top_header(top);\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tif (params->cpus && !CPU_ISSET(i, &params->monitored_cpus))\n\t\t\tcontinue;\n\t\ttimerlat_top_print(top, i);\n\t}\n\n\ttrace_seq_do_printf(trace->seq);\n\ttrace_seq_reset(trace->seq);\n}\n\n \nstatic void timerlat_top_usage(char *usage)\n{\n\tint i;\n\n\tstatic const char *const msg[] = {\n\t\t\"\",\n\t\t\"  usage: rtla timerlat [top] [-h] [-q] [-a us] [-d s] [-D] [-n] [-p us] [-i us] [-T us] [-s us] \\\\\",\n\t\t\"\t  [[-t[=file]] [-e sys[:event]] [--filter <filter>] [--trigger <trigger>] [-c cpu-list] [-H cpu-list]\\\\\",\n\t\t\"\t  [-P priority] [--dma-latency us] [--aa-only us] [-C[=cgroup_name]] [-u]\",\n\t\t\"\",\n\t\t\"\t  -h/--help: print this menu\",\n\t\t\"\t  -a/--auto: set automatic trace mode, stopping the session if argument in us latency is hit\",\n\t\t\"\t     --aa-only us: stop if <us> latency is hit, only printing the auto analysis (reduces CPU usage)\",\n\t\t\"\t  -p/--period us: timerlat period in us\",\n\t\t\"\t  -i/--irq us: stop trace if the irq latency is higher than the argument in us\",\n\t\t\"\t  -T/--thread us: stop trace if the thread latency is higher than the argument in us\",\n\t\t\"\t  -s/--stack us: save the stack trace at the IRQ if a thread latency is higher than the argument in us\",\n\t\t\"\t  -c/--cpus cpus: run the tracer only on the given cpus\",\n\t\t\"\t  -H/--house-keeping cpus: run rtla control threads only on the given cpus\",\n\t\t\"\t  -C/--cgroup[=cgroup_name]: set cgroup, if no cgroup_name is passed, the rtla's cgroup will be inherited\",\n\t\t\"\t  -d/--duration time[m|h|d]: duration of the session in seconds\",\n\t\t\"\t  -D/--debug: print debug info\",\n\t\t\"\t     --dump-tasks: prints the task running on all CPUs if stop conditions are met (depends on !--no-aa)\",\n\t\t\"\t  -t/--trace[=file]: save the stopped trace to [file|timerlat_trace.txt]\",\n\t\t\"\t  -e/--event <sys:event>: enable the <sys:event> in the trace instance, multiple -e are allowed\",\n\t\t\"\t     --filter <command>: enable a trace event filter to the previous -e event\",\n\t\t\"\t     --trigger <command>: enable a trace event trigger to the previous -e event\",\n\t\t\"\t  -n/--nano: display data in nanoseconds\",\n\t\t\"\t     --no-aa: disable auto-analysis, reducing rtla timerlat cpu usage\",\n\t\t\"\t  -q/--quiet print only a summary at the end\",\n\t\t\"\t     --dma-latency us: set /dev/cpu_dma_latency latency <us> to reduce exit from idle latency\",\n\t\t\"\t  -P/--priority o:prio|r:prio|f:prio|d:runtime:period : set scheduling parameters\",\n\t\t\"\t\to:prio - use SCHED_OTHER with prio\",\n\t\t\"\t\tr:prio - use SCHED_RR with prio\",\n\t\t\"\t\tf:prio - use SCHED_FIFO with prio\",\n\t\t\"\t\td:runtime[us|ms|s]:period[us|ms|s] - use SCHED_DEADLINE with runtime and period\",\n\t\t\"\t\t\t\t\t\t       in nanoseconds\",\n\t\t\"\t  -u/--user-threads: use rtla user-space threads instead of in-kernel timerlat threads\",\n\t\tNULL,\n\t};\n\n\tif (usage)\n\t\tfprintf(stderr, \"%s\\n\", usage);\n\n\tfprintf(stderr, \"rtla timerlat top: a per-cpu summary of the timer latency (version %s)\\n\",\n\t\t\tVERSION);\n\n\tfor (i = 0; msg[i]; i++)\n\t\tfprintf(stderr, \"%s\\n\", msg[i]);\n\texit(1);\n}\n\n \nstatic struct timerlat_top_params\n*timerlat_top_parse_args(int argc, char **argv)\n{\n\tstruct timerlat_top_params *params;\n\tstruct trace_events *tevent;\n\tlong long auto_thresh;\n\tint retval;\n\tint c;\n\n\tparams = calloc(1, sizeof(*params));\n\tif (!params)\n\t\texit(1);\n\n\t \n\tparams->dma_latency = -1;\n\n\t \n\tparams->output_divisor = 1000;\n\n\twhile (1) {\n\t\tstatic struct option long_options[] = {\n\t\t\t{\"auto\",\t\trequired_argument,\t0, 'a'},\n\t\t\t{\"cpus\",\t\trequired_argument,\t0, 'c'},\n\t\t\t{\"cgroup\",\t\toptional_argument,\t0, 'C'},\n\t\t\t{\"debug\",\t\tno_argument,\t\t0, 'D'},\n\t\t\t{\"duration\",\t\trequired_argument,\t0, 'd'},\n\t\t\t{\"event\",\t\trequired_argument,\t0, 'e'},\n\t\t\t{\"help\",\t\tno_argument,\t\t0, 'h'},\n\t\t\t{\"house-keeping\",\trequired_argument,\t0, 'H'},\n\t\t\t{\"irq\",\t\t\trequired_argument,\t0, 'i'},\n\t\t\t{\"nano\",\t\tno_argument,\t\t0, 'n'},\n\t\t\t{\"period\",\t\trequired_argument,\t0, 'p'},\n\t\t\t{\"priority\",\t\trequired_argument,\t0, 'P'},\n\t\t\t{\"quiet\",\t\tno_argument,\t\t0, 'q'},\n\t\t\t{\"stack\",\t\trequired_argument,\t0, 's'},\n\t\t\t{\"thread\",\t\trequired_argument,\t0, 'T'},\n\t\t\t{\"trace\",\t\toptional_argument,\t0, 't'},\n\t\t\t{\"user-threads\",\tno_argument,\t\t0, 'u'},\n\t\t\t{\"trigger\",\t\trequired_argument,\t0, '0'},\n\t\t\t{\"filter\",\t\trequired_argument,\t0, '1'},\n\t\t\t{\"dma-latency\",\t\trequired_argument,\t0, '2'},\n\t\t\t{\"no-aa\",\t\tno_argument,\t\t0, '3'},\n\t\t\t{\"dump-tasks\",\t\tno_argument,\t\t0, '4'},\n\t\t\t{\"aa-only\",\t\trequired_argument,\t0, '5'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n\n\t\t \n\t\tint option_index = 0;\n\n\t\tc = getopt_long(argc, argv, \"a:c:C::d:De:hH:i:np:P:qs:t::T:u0:1:2:345:\",\n\t\t\t\t long_options, &option_index);\n\n\t\t \n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tauto_thresh = get_llong_from_str(optarg);\n\n\t\t\t \n\t\t\tparams->stop_total_us = auto_thresh;\n\t\t\tparams->stop_us = auto_thresh;\n\n\t\t\t \n\t\t\tparams->print_stack = auto_thresh;\n\n\t\t\t \n\t\t\tparams->trace_output = \"timerlat_trace.txt\";\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\t \n\t\t\tauto_thresh = get_llong_from_str(optarg);\n\n\t\t\t \n\t\t\tparams->stop_total_us = auto_thresh;\n\t\t\tparams->stop_us = auto_thresh;\n\n\t\t\t \n\t\t\tparams->print_stack = auto_thresh;\n\n\t\t\t \n\t\t\tparams->aa_only = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tretval = parse_cpu_set(optarg, &params->monitored_cpus);\n\t\t\tif (retval)\n\t\t\t\ttimerlat_top_usage(\"\\nInvalid -c cpu list\\n\");\n\t\t\tparams->cpus = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tparams->cgroup = 1;\n\t\t\tif (!optarg) {\n\t\t\t\t \n\t\t\t\tparams->cgroup_name = NULL;\n\t\t\t} else if (*optarg == '=') {\n\t\t\t\t \n\t\t\t\tparams->cgroup_name = ++optarg;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tconfig_debug = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tparams->duration = parse_seconds_duration(optarg);\n\t\t\tif (!params->duration)\n\t\t\t\ttimerlat_top_usage(\"Invalid -D duration\\n\");\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\ttevent = trace_event_alloc(optarg);\n\t\t\tif (!tevent) {\n\t\t\t\terr_msg(\"Error alloc trace event\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\tif (params->events)\n\t\t\t\ttevent->next = params->events;\n\t\t\tparams->events = tevent;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\ttimerlat_top_usage(NULL);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tparams->hk_cpus = 1;\n\t\t\tretval = parse_cpu_set(optarg, &params->hk_cpu_set);\n\t\t\tif (retval) {\n\t\t\t\terr_msg(\"Error parsing house keeping CPUs\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tparams->stop_us = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tparams->output_divisor = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparams->timerlat_period_us = get_llong_from_str(optarg);\n\t\t\tif (params->timerlat_period_us > 1000000)\n\t\t\t\ttimerlat_top_usage(\"Period longer than 1 s\\n\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tretval = parse_prio(optarg, &params->sched_param);\n\t\t\tif (retval == -1)\n\t\t\t\ttimerlat_top_usage(\"Invalid -P priority\");\n\t\t\tparams->set_sched = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tparams->quiet = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tparams->print_stack = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tparams->stop_total_us = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (optarg)\n\t\t\t\t \n\t\t\t\tparams->trace_output = &optarg[1];\n\t\t\telse\n\t\t\t\tparams->trace_output = \"timerlat_trace.txt\";\n\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tparams->user_top = true;\n\t\t\tbreak;\n\t\tcase '0':  \n\t\t\tif (params->events) {\n\t\t\t\tretval = trace_event_add_trigger(params->events, optarg);\n\t\t\t\tif (retval) {\n\t\t\t\t\terr_msg(\"Error adding trigger %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttimerlat_top_usage(\"--trigger requires a previous -e\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '1':  \n\t\t\tif (params->events) {\n\t\t\t\tretval = trace_event_add_filter(params->events, optarg);\n\t\t\t\tif (retval) {\n\t\t\t\t\terr_msg(\"Error adding filter %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttimerlat_top_usage(\"--filter requires a previous -e\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '2':  \n\t\t\tparams->dma_latency = get_llong_from_str(optarg);\n\t\t\tif (params->dma_latency < 0 || params->dma_latency > 10000) {\n\t\t\t\terr_msg(\"--dma-latency needs to be >= 0 and < 10000\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '3':  \n\t\t\tparams->no_aa = 1;\n\t\t\tbreak;\n\t\tcase '4':\n\t\t\tparams->dump_tasks = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttimerlat_top_usage(\"Invalid option\");\n\t\t}\n\t}\n\n\tif (geteuid()) {\n\t\terr_msg(\"rtla needs root permission\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tif (!params->stop_us && !params->stop_total_us)\n\t\tparams->no_aa = 1;\n\n\tif (params->no_aa && params->aa_only)\n\t\ttimerlat_top_usage(\"--no-aa and --aa-only are mutually exclusive!\");\n\n\treturn params;\n}\n\n \nstatic int\ntimerlat_top_apply_config(struct osnoise_tool *top, struct timerlat_top_params *params)\n{\n\tint retval;\n\tint i;\n\n\tif (!params->sleep_time)\n\t\tparams->sleep_time = 1;\n\n\tif (params->cpus) {\n\t\tretval = osnoise_set_cpus(top->context, params->cpus);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to apply CPUs config\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < sysconf(_SC_NPROCESSORS_CONF); i++)\n\t\t\tCPU_SET(i, &params->monitored_cpus);\n\t}\n\n\tif (params->stop_us) {\n\t\tretval = osnoise_set_stop_us(top->context, params->stop_us);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set stop us\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->stop_total_us) {\n\t\tretval = osnoise_set_stop_total_us(top->context, params->stop_total_us);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set stop total us\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\n\tif (params->timerlat_period_us) {\n\t\tretval = osnoise_set_timerlat_period_us(top->context, params->timerlat_period_us);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set timerlat period\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\n\tif (params->print_stack) {\n\t\tretval = osnoise_set_print_stack(top->context, params->print_stack);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set print stack\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->hk_cpus) {\n\t\tretval = sched_setaffinity(getpid(), sizeof(params->hk_cpu_set),\n\t\t\t\t\t   &params->hk_cpu_set);\n\t\tif (retval == -1) {\n\t\t\terr_msg(\"Failed to set rtla to the house keeping CPUs\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (params->cpus) {\n\t\t \n\t\tauto_house_keeping(&params->monitored_cpus);\n\t}\n\n\tif (params->user_top) {\n\t\tretval = osnoise_set_workload(top->context, 0);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set OSNOISE_WORKLOAD option\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_err:\n\treturn -1;\n}\n\n \nstatic struct osnoise_tool\n*timerlat_init_top(struct timerlat_top_params *params)\n{\n\tstruct osnoise_tool *top;\n\tint nr_cpus;\n\n\tnr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\n\ttop = osnoise_init_tool(\"timerlat_top\");\n\tif (!top)\n\t\treturn NULL;\n\n\ttop->data = timerlat_alloc_top(nr_cpus);\n\tif (!top->data)\n\t\tgoto out_err;\n\n\ttop->params = params;\n\n\ttep_register_event_handler(top->trace.tep, -1, \"ftrace\", \"timerlat\",\n\t\t\t\t   timerlat_top_handler, top);\n\n\treturn top;\n\nout_err:\n\tosnoise_destroy_tool(top);\n\treturn NULL;\n}\n\nstatic int stop_tracing;\nstatic void stop_top(int sig)\n{\n\tstop_tracing = 1;\n}\n\n \nstatic void\ntimerlat_top_set_signals(struct timerlat_top_params *params)\n{\n\tsignal(SIGINT, stop_top);\n\tif (params->duration) {\n\t\tsignal(SIGALRM, stop_top);\n\t\talarm(params->duration);\n\t}\n}\n\nint timerlat_top_main(int argc, char *argv[])\n{\n\tstruct timerlat_top_params *params;\n\tstruct osnoise_tool *record = NULL;\n\tstruct timerlat_u_params params_u;\n\tstruct osnoise_tool *top = NULL;\n\tstruct osnoise_tool *aa = NULL;\n\tstruct trace_instance *trace;\n\tint dma_latency_fd = -1;\n\tpthread_t timerlat_u;\n\tint return_value = 1;\n\tchar *max_lat;\n\tint retval;\n\n\tparams = timerlat_top_parse_args(argc, argv);\n\tif (!params)\n\t\texit(1);\n\n\ttop = timerlat_init_top(params);\n\tif (!top) {\n\t\terr_msg(\"Could not init osnoise top\\n\");\n\t\tgoto out_exit;\n\t}\n\n\tretval = timerlat_top_apply_config(top, params);\n\tif (retval) {\n\t\terr_msg(\"Could not apply config\\n\");\n\t\tgoto out_free;\n\t}\n\n\ttrace = &top->trace;\n\n\tretval = enable_timerlat(trace);\n\tif (retval) {\n\t\terr_msg(\"Failed to enable timerlat tracer\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (params->set_sched) {\n\t\tretval = set_comm_sched_attr(\"timerlat/\", &params->sched_param);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set sched parameters\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (params->cgroup && !params->user_top) {\n\t\tretval = set_comm_cgroup(\"timerlat/\", params->cgroup_name);\n\t\tif (!retval) {\n\t\t\terr_msg(\"Failed to move threads to cgroup\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (params->dma_latency >= 0) {\n\t\tdma_latency_fd = set_cpu_dma_latency(params->dma_latency);\n\t\tif (dma_latency_fd < 0) {\n\t\t\terr_msg(\"Could not set /dev/cpu_dma_latency.\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (params->trace_output) {\n\t\trecord = osnoise_init_trace_tool(\"timerlat\");\n\t\tif (!record) {\n\t\t\terr_msg(\"Failed to enable the trace instance\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (params->events) {\n\t\t\tretval = trace_events_enable(&record->trace, params->events);\n\t\t\tif (retval)\n\t\t\t\tgoto out_top;\n\t\t}\n\t}\n\n\tif (!params->no_aa) {\n\t\tif (params->aa_only) {\n\t\t\t \n\t\t\taa = top;\n\t\t} else  {\n\t\t\t \n\t\t\taa = osnoise_init_tool(\"timerlat_aa\");\n\t\t\tif (!aa)\n\t\t\t\tgoto out_top;\n\t\t}\n\n\t\tretval = timerlat_aa_init(aa, params->dump_tasks);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to enable the auto analysis instance\\n\");\n\t\t\tgoto out_top;\n\t\t}\n\n\t\t \n\t\tif (aa != top) {\n\t\t\tretval = enable_timerlat(&aa->trace);\n\t\t\tif (retval) {\n\t\t\t\terr_msg(\"Failed to enable timerlat tracer\\n\");\n\t\t\t\tgoto out_top;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (params->trace_output)\n\t\ttrace_instance_start(&record->trace);\n\tif (!params->no_aa && aa != top)\n\t\ttrace_instance_start(&aa->trace);\n\ttrace_instance_start(trace);\n\n\ttop->start_time = time(NULL);\n\ttimerlat_top_set_signals(params);\n\n\tif (params->user_top) {\n\t\t \n\t\tparams_u.should_run = 1;\n\t\t \n\t\tparams_u.stopped_running = 0;\n\n\t\tparams_u.set = &params->monitored_cpus;\n\t\tif (params->set_sched)\n\t\t\tparams_u.sched_param = &params->sched_param;\n\t\telse\n\t\t\tparams_u.sched_param = NULL;\n\n\t\tparams_u.cgroup_name = params->cgroup_name;\n\n\t\tretval = pthread_create(&timerlat_u, NULL, timerlat_u_dispatcher, &params_u);\n\t\tif (retval)\n\t\t\terr_msg(\"Error creating timerlat user-space threads\\n\");\n\t}\n\n\twhile (!stop_tracing) {\n\t\tsleep(params->sleep_time);\n\n\t\tif (params->aa_only && !trace_is_off(&top->trace, &record->trace))\n\t\t\tcontinue;\n\n\t\tretval = tracefs_iterate_raw_events(trace->tep,\n\t\t\t\t\t\t    trace->inst,\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    collect_registered_events,\n\t\t\t\t\t\t    trace);\n\t\tif (retval < 0) {\n\t\t\terr_msg(\"Error iterating on events\\n\");\n\t\t\tgoto out_top;\n\t\t}\n\n\t\tif (!params->quiet)\n\t\t\ttimerlat_print_stats(params, top);\n\n\t\tif (trace_is_off(&top->trace, &record->trace))\n\t\t\tbreak;\n\n\t\t \n\t\tif (params->user_top) {\n\t\t\tif (params_u.stopped_running) {\n\t\t\t\tdebug_msg(\"timerlat user space threads stopped!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (params->user_top && !params_u.stopped_running) {\n\t\tparams_u.should_run = 0;\n\t\tsleep(1);\n\t}\n\n\ttimerlat_print_stats(params, top);\n\n\treturn_value = 0;\n\n\tif (trace_is_off(&top->trace, &record->trace)) {\n\t\tprintf(\"rtla timerlat hit stop tracing\\n\");\n\n\t\tif (!params->no_aa)\n\t\t\ttimerlat_auto_analysis(params->stop_us, params->stop_total_us);\n\n\t\tif (params->trace_output) {\n\t\t\tprintf(\"  Saving trace to %s\\n\", params->trace_output);\n\t\t\tsave_trace_to_file(record->trace.inst, params->trace_output);\n\t\t}\n\t} else if (params->aa_only) {\n\t\t \n\t\tmax_lat = tracefs_instance_file_read(trace->inst, \"tracing_max_latency\", NULL);\n\t\tif (max_lat) {\n\t\t\tprintf(\"  Max latency was %s\\n\", max_lat);\n\t\t\tfree(max_lat);\n\t\t}\n\t}\n\nout_top:\n\ttimerlat_aa_destroy();\n\tif (dma_latency_fd >= 0)\n\t\tclose(dma_latency_fd);\n\ttrace_events_destroy(&record->trace, params->events);\n\tparams->events = NULL;\nout_free:\n\ttimerlat_free_top(top->data);\n\tif (aa && aa != top)\n\t\tosnoise_destroy_tool(aa);\n\tosnoise_destroy_tool(record);\n\tosnoise_destroy_tool(top);\n\tfree(params);\nout_exit:\n\texit(return_value);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}