{
  "module_name": "osnoise_hist.c",
  "hash_id": "8ec2b74d8f07cf062a207bc824691215da26349b14568674cac2e4911f3f70ea",
  "original_prompt": "Ingested from linux-6.6.14/tools/tracing/rtla/src/osnoise_hist.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <getopt.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <time.h>\n#include <sched.h>\n\n#include \"utils.h\"\n#include \"osnoise.h\"\n\nstruct osnoise_hist_params {\n\tchar\t\t\t*cpus;\n\tcpu_set_t\t\tmonitored_cpus;\n\tchar\t\t\t*trace_output;\n\tchar\t\t\t*cgroup_name;\n\tunsigned long long\truntime;\n\tunsigned long long\tperiod;\n\tlong long\t\tthreshold;\n\tlong long\t\tstop_us;\n\tlong long\t\tstop_total_us;\n\tint\t\t\tsleep_time;\n\tint\t\t\tduration;\n\tint\t\t\tset_sched;\n\tint\t\t\toutput_divisor;\n\tint\t\t\tcgroup;\n\tint\t\t\thk_cpus;\n\tcpu_set_t\t\thk_cpu_set;\n\tstruct sched_attr\tsched_param;\n\tstruct trace_events\t*events;\n\n\tchar\t\t\tno_header;\n\tchar\t\t\tno_summary;\n\tchar\t\t\tno_index;\n\tchar\t\t\twith_zeros;\n\tint\t\t\tbucket_size;\n\tint\t\t\tentries;\n};\n\nstruct osnoise_hist_cpu {\n\tint\t\t\t*samples;\n\tint\t\t\tcount;\n\n\tunsigned long long\tmin_sample;\n\tunsigned long long\tsum_sample;\n\tunsigned long long\tmax_sample;\n\n};\n\nstruct osnoise_hist_data {\n\tstruct tracefs_hist\t*trace_hist;\n\tstruct osnoise_hist_cpu\t*hist;\n\tint\t\t\tentries;\n\tint\t\t\tbucket_size;\n\tint\t\t\tnr_cpus;\n};\n\n \nstatic void\nosnoise_free_histogram(struct osnoise_hist_data *data)\n{\n\tint cpu;\n\n\t \n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (data->hist[cpu].samples)\n\t\t\tfree(data->hist[cpu].samples);\n\t}\n\n\t \n\tif (data->hist)\n\t\tfree(data->hist);\n\n\tfree(data);\n}\n\n \nstatic struct osnoise_hist_data\n*osnoise_alloc_histogram(int nr_cpus, int entries, int bucket_size)\n{\n\tstruct osnoise_hist_data *data;\n\tint cpu;\n\n\tdata = calloc(1, sizeof(*data));\n\tif (!data)\n\t\treturn NULL;\n\n\tdata->entries = entries;\n\tdata->bucket_size = bucket_size;\n\tdata->nr_cpus = nr_cpus;\n\n\tdata->hist = calloc(1, sizeof(*data->hist) * nr_cpus);\n\tif (!data->hist)\n\t\tgoto cleanup;\n\n\tfor (cpu = 0; cpu < nr_cpus; cpu++) {\n\t\tdata->hist[cpu].samples = calloc(1, sizeof(*data->hist->samples) * (entries + 1));\n\t\tif (!data->hist[cpu].samples)\n\t\t\tgoto cleanup;\n\t}\n\n\t \n\tfor (cpu = 0; cpu < nr_cpus; cpu++)\n\t\tdata->hist[cpu].min_sample = ~0;\n\n\treturn data;\n\ncleanup:\n\tosnoise_free_histogram(data);\n\treturn NULL;\n}\n\nstatic void osnoise_hist_update_multiple(struct osnoise_tool *tool, int cpu,\n\t\t\t\t\t unsigned long long duration, int count)\n{\n\tstruct osnoise_hist_params *params = tool->params;\n\tstruct osnoise_hist_data *data = tool->data;\n\tunsigned long long total_duration;\n\tint entries = data->entries;\n\tint bucket;\n\tint *hist;\n\n\tif (params->output_divisor)\n\t\tduration = duration / params->output_divisor;\n\n\tif (data->bucket_size)\n\t\tbucket = duration / data->bucket_size;\n\n\ttotal_duration = duration * count;\n\n\thist = data->hist[cpu].samples;\n\tdata->hist[cpu].count += count;\n\tupdate_min(&data->hist[cpu].min_sample, &duration);\n\tupdate_sum(&data->hist[cpu].sum_sample, &total_duration);\n\tupdate_max(&data->hist[cpu].max_sample, &duration);\n\n\tif (bucket < entries)\n\t\thist[bucket] += count;\n\telse\n\t\thist[entries] += count;\n}\n\n \nstatic void osnoise_destroy_trace_hist(struct osnoise_tool *tool)\n{\n\tstruct osnoise_hist_data *data = tool->data;\n\n\ttracefs_hist_pause(tool->trace.inst, data->trace_hist);\n\ttracefs_hist_destroy(tool->trace.inst, data->trace_hist);\n}\n\n \nstatic int osnoise_init_trace_hist(struct osnoise_tool *tool)\n{\n\tstruct osnoise_hist_params *params = tool->params;\n\tstruct osnoise_hist_data *data = tool->data;\n\tint bucket_size;\n\tchar buff[128];\n\tint retval = 0;\n\n\t \n\tbucket_size = params->output_divisor * params->bucket_size;\n\tsnprintf(buff, sizeof(buff), \"duration.buckets=%d\", bucket_size);\n\n\tdata->trace_hist = tracefs_hist_alloc(tool->trace.tep, \"osnoise\", \"sample_threshold\",\n\t\t\tbuff, TRACEFS_HIST_KEY_NORMAL);\n\tif (!data->trace_hist)\n\t\treturn 1;\n\n\tretval = tracefs_hist_add_key(data->trace_hist, \"cpu\", 0);\n\tif (retval)\n\t\tgoto out_err;\n\n\tretval = tracefs_hist_start(tool->trace.inst, data->trace_hist);\n\tif (retval)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tosnoise_destroy_trace_hist(tool);\n\treturn 1;\n}\n\n \nstatic void osnoise_read_trace_hist(struct osnoise_tool *tool)\n{\n\tstruct osnoise_hist_data *data = tool->data;\n\tlong long cpu, counter, duration;\n\tchar *content, *position;\n\n\ttracefs_hist_pause(tool->trace.inst, data->trace_hist);\n\n\tcontent = tracefs_event_file_read(tool->trace.inst, \"osnoise\",\n\t\t\t\t\t  \"sample_threshold\",\n\t\t\t\t\t  \"hist\", NULL);\n\tif (!content)\n\t\treturn;\n\n\tposition = content;\n\twhile (true) {\n\t\tposition = strstr(position, \"duration: ~\");\n\t\tif (!position)\n\t\t\tbreak;\n\t\tposition += strlen(\"duration: ~\");\n\t\tduration = get_llong_from_str(position);\n\t\tif (duration == -1)\n\t\t\terr_msg(\"error reading duration from histogram\\n\");\n\n\t\tposition = strstr(position, \"cpu:\");\n\t\tif (!position)\n\t\t\tbreak;\n\t\tposition += strlen(\"cpu: \");\n\t\tcpu = get_llong_from_str(position);\n\t\tif (cpu == -1)\n\t\t\terr_msg(\"error reading cpu from histogram\\n\");\n\n\t\tposition = strstr(position, \"hitcount:\");\n\t\tif (!position)\n\t\t\tbreak;\n\t\tposition += strlen(\"hitcount: \");\n\t\tcounter = get_llong_from_str(position);\n\t\tif (counter == -1)\n\t\t\terr_msg(\"error reading counter from histogram\\n\");\n\n\t\tosnoise_hist_update_multiple(tool, cpu, duration, counter);\n\t}\n\tfree(content);\n}\n\n \nstatic void osnoise_hist_header(struct osnoise_tool *tool)\n{\n\tstruct osnoise_hist_params *params = tool->params;\n\tstruct osnoise_hist_data *data = tool->data;\n\tstruct trace_seq *s = tool->trace.seq;\n\tchar duration[26];\n\tint cpu;\n\n\tif (params->no_header)\n\t\treturn;\n\n\tget_duration(tool->start_time, duration, sizeof(duration));\n\ttrace_seq_printf(s, \"# RTLA osnoise histogram\\n\");\n\ttrace_seq_printf(s, \"# Time unit is %s (%s)\\n\",\n\t\t\tparams->output_divisor == 1 ? \"nanoseconds\" : \"microseconds\",\n\t\t\tparams->output_divisor == 1 ? \"ns\" : \"us\");\n\n\ttrace_seq_printf(s, \"# Duration: %s\\n\", duration);\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(s, \"Index\");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].count)\n\t\t\tcontinue;\n\n\t\ttrace_seq_printf(s, \"   CPU-%03d\", cpu);\n\t}\n\ttrace_seq_printf(s, \"\\n\");\n\n\ttrace_seq_do_printf(s);\n\ttrace_seq_reset(s);\n}\n\n \nstatic void\nosnoise_print_summary(struct osnoise_hist_params *params,\n\t\t       struct trace_instance *trace,\n\t\t       struct osnoise_hist_data *data)\n{\n\tint cpu;\n\n\tif (params->no_summary)\n\t\treturn;\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(trace->seq, \"count:\");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].count)\n\t\t\tcontinue;\n\n\t\ttrace_seq_printf(trace->seq, \"%9d \", data->hist[cpu].count);\n\t}\n\ttrace_seq_printf(trace->seq, \"\\n\");\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(trace->seq, \"min:  \");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].count)\n\t\t\tcontinue;\n\n\t\ttrace_seq_printf(trace->seq, \"%9llu \",\tdata->hist[cpu].min_sample);\n\n\t}\n\ttrace_seq_printf(trace->seq, \"\\n\");\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(trace->seq, \"avg:  \");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].count)\n\t\t\tcontinue;\n\n\t\tif (data->hist[cpu].count)\n\t\t\ttrace_seq_printf(trace->seq, \"%9.2f \",\n\t\t\t\t((double) data->hist[cpu].sum_sample) / data->hist[cpu].count);\n\t\telse\n\t\t\ttrace_seq_printf(trace->seq, \"        - \");\n\t}\n\ttrace_seq_printf(trace->seq, \"\\n\");\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(trace->seq, \"max:  \");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].count)\n\t\t\tcontinue;\n\n\t\ttrace_seq_printf(trace->seq, \"%9llu \", data->hist[cpu].max_sample);\n\n\t}\n\ttrace_seq_printf(trace->seq, \"\\n\");\n\ttrace_seq_do_printf(trace->seq);\n\ttrace_seq_reset(trace->seq);\n}\n\n \nstatic void\nosnoise_print_stats(struct osnoise_hist_params *params, struct osnoise_tool *tool)\n{\n\tstruct osnoise_hist_data *data = tool->data;\n\tstruct trace_instance *trace = &tool->trace;\n\tint bucket, cpu;\n\tint total;\n\n\tosnoise_hist_header(tool);\n\n\tfor (bucket = 0; bucket < data->entries; bucket++) {\n\t\ttotal = 0;\n\n\t\tif (!params->no_index)\n\t\t\ttrace_seq_printf(trace->seq, \"%-6d\",\n\t\t\t\t\t bucket * data->bucket_size);\n\n\t\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\t\tcontinue;\n\n\t\t\tif (!data->hist[cpu].count)\n\t\t\t\tcontinue;\n\n\t\t\ttotal += data->hist[cpu].samples[bucket];\n\t\t\ttrace_seq_printf(trace->seq, \"%9d \", data->hist[cpu].samples[bucket]);\n\t\t}\n\n\t\tif (total == 0 && !params->with_zeros) {\n\t\t\ttrace_seq_reset(trace->seq);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttrace_seq_printf(trace->seq, \"\\n\");\n\t\ttrace_seq_do_printf(trace->seq);\n\t\ttrace_seq_reset(trace->seq);\n\t}\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(trace->seq, \"over: \");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].count)\n\t\t\tcontinue;\n\n\t\ttrace_seq_printf(trace->seq, \"%9d \",\n\t\t\t\t data->hist[cpu].samples[data->entries]);\n\t}\n\ttrace_seq_printf(trace->seq, \"\\n\");\n\ttrace_seq_do_printf(trace->seq);\n\ttrace_seq_reset(trace->seq);\n\n\tosnoise_print_summary(params, trace, data);\n}\n\n \nstatic void osnoise_hist_usage(char *usage)\n{\n\tint i;\n\n\tstatic const char * const msg[] = {\n\t\t\"\",\n\t\t\"  usage: rtla osnoise hist [-h] [-D] [-d s] [-a us] [-p us] [-r us] [-s us] [-S us] \\\\\",\n\t\t\"\t  [-T us] [-t[=file]] [-e sys[:event]] [--filter <filter>] [--trigger <trigger>] \\\\\",\n\t\t\"\t  [-c cpu-list] [-H cpu-list] [-P priority] [-b N] [-E N] [--no-header] [--no-summary] \\\\\",\n\t\t\"\t  [--no-index] [--with-zeros] [-C[=cgroup_name]]\",\n\t\t\"\",\n\t\t\"\t  -h/--help: print this menu\",\n\t\t\"\t  -a/--auto: set automatic trace mode, stopping the session if argument in us sample is hit\",\n\t\t\"\t  -p/--period us: osnoise period in us\",\n\t\t\"\t  -r/--runtime us: osnoise runtime in us\",\n\t\t\"\t  -s/--stop us: stop trace if a single sample is higher than the argument in us\",\n\t\t\"\t  -S/--stop-total us: stop trace if the total sample is higher than the argument in us\",\n\t\t\"\t  -T/--threshold us: the minimum delta to be considered a noise\",\n\t\t\"\t  -c/--cpus cpu-list: list of cpus to run osnoise threads\",\n\t\t\"\t  -H/--house-keeping cpus: run rtla control threads only on the given cpus\",\n\t\t\"\t  -C/--cgroup[=cgroup_name]: set cgroup, if no cgroup_name is passed, the rtla's cgroup will be inherited\",\n\t\t\"\t  -d/--duration time[s|m|h|d]: duration of the session\",\n\t\t\"\t  -D/--debug: print debug info\",\n\t\t\"\t  -t/--trace[=file]: save the stopped trace to [file|osnoise_trace.txt]\",\n\t\t\"\t  -e/--event <sys:event>: enable the <sys:event> in the trace instance, multiple -e are allowed\",\n\t\t\"\t     --filter <filter>: enable a trace event filter to the previous -e event\",\n\t\t\"\t     --trigger <trigger>: enable a trace event trigger to the previous -e event\",\n\t\t\"\t  -b/--bucket-size N: set the histogram bucket size (default 1)\",\n\t\t\"\t  -E/--entries N: set the number of entries of the histogram (default 256)\",\n\t\t\"\t     --no-header: do not print header\",\n\t\t\"\t     --no-summary: do not print summary\",\n\t\t\"\t     --no-index: do not print index\",\n\t\t\"\t     --with-zeros: print zero only entries\",\n\t\t\"\t  -P/--priority o:prio|r:prio|f:prio|d:runtime:period: set scheduling parameters\",\n\t\t\"\t\to:prio - use SCHED_OTHER with prio\",\n\t\t\"\t\tr:prio - use SCHED_RR with prio\",\n\t\t\"\t\tf:prio - use SCHED_FIFO with prio\",\n\t\t\"\t\td:runtime[us|ms|s]:period[us|ms|s] - use SCHED_DEADLINE with runtime and period\",\n\t\t\"\t\t\t\t\t\t       in nanoseconds\",\n\t\tNULL,\n\t};\n\n\tif (usage)\n\t\tfprintf(stderr, \"%s\\n\", usage);\n\n\tfprintf(stderr, \"rtla osnoise hist: a per-cpu histogram of the OS noise (version %s)\\n\",\n\t\t\tVERSION);\n\n\tfor (i = 0; msg[i]; i++)\n\t\tfprintf(stderr, \"%s\\n\", msg[i]);\n\texit(1);\n}\n\n \nstatic struct osnoise_hist_params\n*osnoise_hist_parse_args(int argc, char *argv[])\n{\n\tstruct osnoise_hist_params *params;\n\tstruct trace_events *tevent;\n\tint retval;\n\tint c;\n\n\tparams = calloc(1, sizeof(*params));\n\tif (!params)\n\t\texit(1);\n\n\t \n\tparams->output_divisor = 1000;\n\tparams->bucket_size = 1;\n\tparams->entries = 256;\n\n\twhile (1) {\n\t\tstatic struct option long_options[] = {\n\t\t\t{\"auto\",\t\trequired_argument,\t0, 'a'},\n\t\t\t{\"bucket-size\",\t\trequired_argument,\t0, 'b'},\n\t\t\t{\"entries\",\t\trequired_argument,\t0, 'E'},\n\t\t\t{\"cpus\",\t\trequired_argument,\t0, 'c'},\n\t\t\t{\"cgroup\",\t\toptional_argument,\t0, 'C'},\n\t\t\t{\"debug\",\t\tno_argument,\t\t0, 'D'},\n\t\t\t{\"duration\",\t\trequired_argument,\t0, 'd'},\n\t\t\t{\"house-keeping\",\trequired_argument,\t\t0, 'H'},\n\t\t\t{\"help\",\t\tno_argument,\t\t0, 'h'},\n\t\t\t{\"period\",\t\trequired_argument,\t0, 'p'},\n\t\t\t{\"priority\",\t\trequired_argument,\t0, 'P'},\n\t\t\t{\"runtime\",\t\trequired_argument,\t0, 'r'},\n\t\t\t{\"stop\",\t\trequired_argument,\t0, 's'},\n\t\t\t{\"stop-total\",\t\trequired_argument,\t0, 'S'},\n\t\t\t{\"trace\",\t\toptional_argument,\t0, 't'},\n\t\t\t{\"event\",\t\trequired_argument,\t0, 'e'},\n\t\t\t{\"threshold\",\t\trequired_argument,\t0, 'T'},\n\t\t\t{\"no-header\",\t\tno_argument,\t\t0, '0'},\n\t\t\t{\"no-summary\",\t\tno_argument,\t\t0, '1'},\n\t\t\t{\"no-index\",\t\tno_argument,\t\t0, '2'},\n\t\t\t{\"with-zeros\",\t\tno_argument,\t\t0, '3'},\n\t\t\t{\"trigger\",\t\trequired_argument,\t0, '4'},\n\t\t\t{\"filter\",\t\trequired_argument,\t0, '5'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n\n\t\t \n\t\tint option_index = 0;\n\n\t\tc = getopt_long(argc, argv, \"a:c:C::b:d:e:E:DhH:p:P:r:s:S:t::T:01234:5:\",\n\t\t\t\t long_options, &option_index);\n\n\t\t \n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\t \n\t\t\tparams->stop_us = get_llong_from_str(optarg);\n\n\t\t\t \n\t\t\tparams->threshold = 1;\n\n\t\t\t \n\t\t\tparams->trace_output = \"osnoise_trace.txt\";\n\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tparams->bucket_size = get_llong_from_str(optarg);\n\t\t\tif ((params->bucket_size == 0) || (params->bucket_size >= 1000000))\n\t\t\t\tosnoise_hist_usage(\"Bucket size needs to be > 0 and <= 1000000\\n\");\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tretval = parse_cpu_set(optarg, &params->monitored_cpus);\n\t\t\tif (retval)\n\t\t\t\tosnoise_hist_usage(\"\\nInvalid -c cpu list\\n\");\n\t\t\tparams->cpus = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tparams->cgroup = 1;\n\t\t\tif (!optarg) {\n\t\t\t\t \n\t\t\t\tparams->cgroup_name = NULL;\n\t\t\t} else if (*optarg == '=') {\n\t\t\t\t \n\t\t\t\tparams->cgroup_name = ++optarg;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tconfig_debug = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tparams->duration = parse_seconds_duration(optarg);\n\t\t\tif (!params->duration)\n\t\t\t\tosnoise_hist_usage(\"Invalid -D duration\\n\");\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\ttevent = trace_event_alloc(optarg);\n\t\t\tif (!tevent) {\n\t\t\t\terr_msg(\"Error alloc trace event\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\tif (params->events)\n\t\t\t\ttevent->next = params->events;\n\n\t\t\tparams->events = tevent;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tparams->entries = get_llong_from_str(optarg);\n\t\t\tif ((params->entries < 10) || (params->entries > 9999999))\n\t\t\t\tosnoise_hist_usage(\"Entries must be > 10 and < 9999999\\n\");\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tosnoise_hist_usage(NULL);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tparams->hk_cpus = 1;\n\t\t\tretval = parse_cpu_set(optarg, &params->hk_cpu_set);\n\t\t\tif (retval) {\n\t\t\t\terr_msg(\"Error parsing house keeping CPUs\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparams->period = get_llong_from_str(optarg);\n\t\t\tif (params->period > 10000000)\n\t\t\t\tosnoise_hist_usage(\"Period longer than 10 s\\n\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tretval = parse_prio(optarg, &params->sched_param);\n\t\t\tif (retval == -1)\n\t\t\t\tosnoise_hist_usage(\"Invalid -P priority\");\n\t\t\tparams->set_sched = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tparams->runtime = get_llong_from_str(optarg);\n\t\t\tif (params->runtime < 100)\n\t\t\t\tosnoise_hist_usage(\"Runtime shorter than 100 us\\n\");\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tparams->stop_us = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tparams->stop_total_us = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tparams->threshold = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (optarg)\n\t\t\t\t \n\t\t\t\tparams->trace_output = &optarg[1];\n\t\t\telse\n\t\t\t\tparams->trace_output = \"osnoise_trace.txt\";\n\t\t\tbreak;\n\t\tcase '0':  \n\t\t\tparams->no_header = 1;\n\t\t\tbreak;\n\t\tcase '1':  \n\t\t\tparams->no_summary = 1;\n\t\t\tbreak;\n\t\tcase '2':  \n\t\t\tparams->no_index = 1;\n\t\t\tbreak;\n\t\tcase '3':  \n\t\t\tparams->with_zeros = 1;\n\t\t\tbreak;\n\t\tcase '4':  \n\t\t\tif (params->events) {\n\t\t\t\tretval = trace_event_add_trigger(params->events, optarg);\n\t\t\t\tif (retval) {\n\t\t\t\t\terr_msg(\"Error adding trigger %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tosnoise_hist_usage(\"--trigger requires a previous -e\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '5':  \n\t\t\tif (params->events) {\n\t\t\t\tretval = trace_event_add_filter(params->events, optarg);\n\t\t\t\tif (retval) {\n\t\t\t\t\terr_msg(\"Error adding filter %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tosnoise_hist_usage(\"--filter requires a previous -e\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tosnoise_hist_usage(\"Invalid option\");\n\t\t}\n\t}\n\n\tif (geteuid()) {\n\t\terr_msg(\"rtla needs root permission\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (params->no_index && !params->with_zeros)\n\t\tosnoise_hist_usage(\"no-index set and with-zeros not set - it does not make sense\");\n\n\treturn params;\n}\n\n \nstatic int\nosnoise_hist_apply_config(struct osnoise_tool *tool, struct osnoise_hist_params *params)\n{\n\tint retval;\n\n\tif (!params->sleep_time)\n\t\tparams->sleep_time = 1;\n\n\tif (params->cpus) {\n\t\tretval = osnoise_set_cpus(tool->context, params->cpus);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to apply CPUs config\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->runtime || params->period) {\n\t\tretval = osnoise_set_runtime_period(tool->context,\n\t\t\t\t\t\t    params->runtime,\n\t\t\t\t\t\t    params->period);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set runtime and/or period\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->stop_us) {\n\t\tretval = osnoise_set_stop_us(tool->context, params->stop_us);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set stop us\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->stop_total_us) {\n\t\tretval = osnoise_set_stop_total_us(tool->context, params->stop_total_us);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set stop total us\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->threshold) {\n\t\tretval = osnoise_set_tracing_thresh(tool->context, params->threshold);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set tracing_thresh\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->hk_cpus) {\n\t\tretval = sched_setaffinity(getpid(), sizeof(params->hk_cpu_set),\n\t\t\t\t\t   &params->hk_cpu_set);\n\t\tif (retval == -1) {\n\t\t\terr_msg(\"Failed to set rtla to the house keeping CPUs\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (params->cpus) {\n\t\t \n\t\tauto_house_keeping(&params->monitored_cpus);\n\t}\n\n\treturn 0;\n\nout_err:\n\treturn -1;\n}\n\n \nstatic struct osnoise_tool\n*osnoise_init_hist(struct osnoise_hist_params *params)\n{\n\tstruct osnoise_tool *tool;\n\tint nr_cpus;\n\n\tnr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\n\ttool = osnoise_init_tool(\"osnoise_hist\");\n\tif (!tool)\n\t\treturn NULL;\n\n\ttool->data = osnoise_alloc_histogram(nr_cpus, params->entries, params->bucket_size);\n\tif (!tool->data)\n\t\tgoto out_err;\n\n\ttool->params = params;\n\n\treturn tool;\n\nout_err:\n\tosnoise_destroy_tool(tool);\n\treturn NULL;\n}\n\nstatic int stop_tracing;\nstatic void stop_hist(int sig)\n{\n\tstop_tracing = 1;\n}\n\n \nstatic void\nosnoise_hist_set_signals(struct osnoise_hist_params *params)\n{\n\tsignal(SIGINT, stop_hist);\n\tif (params->duration) {\n\t\tsignal(SIGALRM, stop_hist);\n\t\talarm(params->duration);\n\t}\n}\n\nint osnoise_hist_main(int argc, char *argv[])\n{\n\tstruct osnoise_hist_params *params;\n\tstruct osnoise_tool *record = NULL;\n\tstruct osnoise_tool *tool = NULL;\n\tstruct trace_instance *trace;\n\tint return_value = 1;\n\tint retval;\n\n\tparams = osnoise_hist_parse_args(argc, argv);\n\tif (!params)\n\t\texit(1);\n\n\ttool = osnoise_init_hist(params);\n\tif (!tool) {\n\t\terr_msg(\"Could not init osnoise hist\\n\");\n\t\tgoto out_exit;\n\t}\n\n\tretval = osnoise_hist_apply_config(tool, params);\n\tif (retval) {\n\t\terr_msg(\"Could not apply config\\n\");\n\t\tgoto out_destroy;\n\t}\n\n\ttrace = &tool->trace;\n\n\tretval = enable_osnoise(trace);\n\tif (retval) {\n\t\terr_msg(\"Failed to enable osnoise tracer\\n\");\n\t\tgoto out_destroy;\n\t}\n\n\tretval = osnoise_init_trace_hist(tool);\n\tif (retval)\n\t\tgoto out_destroy;\n\n\tif (params->set_sched) {\n\t\tretval = set_comm_sched_attr(\"osnoise/\", &params->sched_param);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set sched parameters\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (params->cgroup) {\n\t\tretval = set_comm_cgroup(\"timerlat/\", params->cgroup_name);\n\t\tif (!retval) {\n\t\t\terr_msg(\"Failed to move threads to cgroup\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (params->trace_output) {\n\t\trecord = osnoise_init_trace_tool(\"osnoise\");\n\t\tif (!record) {\n\t\t\terr_msg(\"Failed to enable the trace instance\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (params->events) {\n\t\t\tretval = trace_events_enable(&record->trace, params->events);\n\t\t\tif (retval)\n\t\t\t\tgoto out_hist;\n\t\t}\n\n\t}\n\n\t \n\tif (params->trace_output)\n\t\ttrace_instance_start(&record->trace);\n\ttrace_instance_start(trace);\n\n\ttool->start_time = time(NULL);\n\tosnoise_hist_set_signals(params);\n\n\twhile (!stop_tracing) {\n\t\tsleep(params->sleep_time);\n\n\t\tretval = tracefs_iterate_raw_events(trace->tep,\n\t\t\t\t\t\t    trace->inst,\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    collect_registered_events,\n\t\t\t\t\t\t    trace);\n\t\tif (retval < 0) {\n\t\t\terr_msg(\"Error iterating on events\\n\");\n\t\t\tgoto out_hist;\n\t\t}\n\n\t\tif (trace_is_off(&tool->trace, &record->trace))\n\t\t\tbreak;\n\t}\n\n\tosnoise_read_trace_hist(tool);\n\n\tosnoise_print_stats(params, tool);\n\n\treturn_value = 0;\n\n\tif (trace_is_off(&tool->trace, &record->trace)) {\n\t\tprintf(\"rtla osnoise hit stop tracing\\n\");\n\t\tif (params->trace_output) {\n\t\t\tprintf(\"  Saving trace to %s\\n\", params->trace_output);\n\t\t\tsave_trace_to_file(record->trace.inst, params->trace_output);\n\t\t}\n\t}\n\nout_hist:\n\ttrace_events_destroy(&record->trace, params->events);\n\tparams->events = NULL;\nout_free:\n\tosnoise_free_histogram(tool->data);\nout_destroy:\n\tosnoise_destroy_tool(record);\n\tosnoise_destroy_tool(tool);\n\tfree(params);\nout_exit:\n\texit(return_value);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}