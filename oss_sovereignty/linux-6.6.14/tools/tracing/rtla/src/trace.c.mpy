{
  "module_name": "trace.c",
  "hash_id": "f0e5b9b5084dfe884615a4bc03772456b5262ec420610692b99a88caab721ae4",
  "original_prompt": "Ingested from linux-6.6.14/tools/tracing/rtla/src/trace.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sys/sendfile.h>\n#include <tracefs.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include \"trace.h\"\n#include \"utils.h\"\n\n \nint enable_tracer_by_name(struct tracefs_instance *inst, const char *tracer_name)\n{\n\tenum tracefs_tracers tracer;\n\tint retval;\n\n\ttracer = TRACEFS_TRACER_CUSTOM;\n\n\tdebug_msg(\"Enabling %s tracer\\n\", tracer_name);\n\n\tretval = tracefs_tracer_set(inst, tracer, tracer_name);\n\tif (retval < 0) {\n\t\tif (errno == ENODEV)\n\t\t\terr_msg(\"Tracer %s not found!\\n\", tracer_name);\n\n\t\terr_msg(\"Failed to enable the %s tracer\\n\", tracer_name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nvoid disable_tracer(struct tracefs_instance *inst)\n{\n\tenum tracefs_tracers t = TRACEFS_TRACER_NOP;\n\tint retval;\n\n\tretval = tracefs_tracer_set(inst, t);\n\tif (retval < 0)\n\t\terr_msg(\"Oops, error disabling tracer\\n\");\n}\n\n \nstruct tracefs_instance *create_instance(char *instance_name)\n{\n\treturn tracefs_instance_create(instance_name);\n}\n\n \nvoid destroy_instance(struct tracefs_instance *inst)\n{\n\ttracefs_instance_destroy(inst);\n\ttracefs_instance_free(inst);\n}\n\n \nint save_trace_to_file(struct tracefs_instance *inst, const char *filename)\n{\n\tconst char *file = \"trace\";\n\tmode_t mode = 0644;\n\tchar buffer[4096];\n\tint out_fd, in_fd;\n\tint retval = -1;\n\n\tin_fd = tracefs_instance_file_open(inst, file, O_RDONLY);\n\tif (in_fd < 0) {\n\t\terr_msg(\"Failed to open trace file\\n\");\n\t\treturn -1;\n\t}\n\n\tout_fd = creat(filename, mode);\n\tif (out_fd < 0) {\n\t\terr_msg(\"Failed to create output file %s\\n\", filename);\n\t\tgoto out_close_in;\n\t}\n\n\tdo {\n\t\tretval = read(in_fd, buffer, sizeof(buffer));\n\t\tif (retval <= 0)\n\t\t\tgoto out_close;\n\n\t\tretval = write(out_fd, buffer, retval);\n\t\tif (retval < 0)\n\t\t\tgoto out_close;\n\t} while (retval > 0);\n\n\tretval = 0;\nout_close:\n\tclose(out_fd);\nout_close_in:\n\tclose(in_fd);\n\treturn retval;\n}\n\n \nint\ncollect_registered_events(struct tep_event *event, struct tep_record *record,\n\t\t\t  int cpu, void *context)\n{\n\tstruct trace_instance *trace = context;\n\tstruct trace_seq *s = trace->seq;\n\n\tif (!event->handler)\n\t\treturn 0;\n\n\tevent->handler(s, record, event, context);\n\n\treturn 0;\n}\n\n \nvoid trace_instance_destroy(struct trace_instance *trace)\n{\n\tif (trace->inst) {\n\t\tdisable_tracer(trace->inst);\n\t\tdestroy_instance(trace->inst);\n\t\ttrace->inst = NULL;\n\t}\n\n\tif (trace->seq) {\n\t\tfree(trace->seq);\n\t\ttrace->seq = NULL;\n\t}\n\n\tif (trace->tep) {\n\t\ttep_free(trace->tep);\n\t\ttrace->tep = NULL;\n\t}\n}\n\n \nint trace_instance_init(struct trace_instance *trace, char *tool_name)\n{\n\ttrace->seq = calloc(1, sizeof(*trace->seq));\n\tif (!trace->seq)\n\t\tgoto out_err;\n\n\ttrace_seq_init(trace->seq);\n\n\ttrace->inst = create_instance(tool_name);\n\tif (!trace->inst)\n\t\tgoto out_err;\n\n\ttrace->tep = tracefs_local_events(NULL);\n\tif (!trace->tep)\n\t\tgoto out_err;\n\n\t \n\ttracefs_trace_off(trace->inst);\n\n\treturn 0;\n\nout_err:\n\ttrace_instance_destroy(trace);\n\treturn 1;\n}\n\n \nint trace_instance_start(struct trace_instance *trace)\n{\n\treturn tracefs_trace_on(trace->inst);\n}\n\n \nstatic void trace_events_free(struct trace_events *events)\n{\n\tstruct trace_events *tevent = events;\n\tstruct trace_events *free_event;\n\n\twhile (tevent) {\n\t\tfree_event = tevent;\n\n\t\ttevent = tevent->next;\n\n\t\tif (free_event->filter)\n\t\t\tfree(free_event->filter);\n\t\tif (free_event->trigger)\n\t\t\tfree(free_event->trigger);\n\t\tfree(free_event->system);\n\t\tfree(free_event);\n\t}\n}\n\n \nstruct trace_events *trace_event_alloc(const char *event_string)\n{\n\tstruct trace_events *tevent;\n\n\ttevent = calloc(1, sizeof(*tevent));\n\tif (!tevent)\n\t\treturn NULL;\n\n\ttevent->system = strdup(event_string);\n\tif (!tevent->system) {\n\t\tfree(tevent);\n\t\treturn NULL;\n\t}\n\n\ttevent->event = strstr(tevent->system, \":\");\n\tif (tevent->event) {\n\t\t*tevent->event = '\\0';\n\t\ttevent->event = &tevent->event[1];\n\t}\n\n\treturn tevent;\n}\n\n \nint trace_event_add_filter(struct trace_events *event, char *filter)\n{\n\tif (event->filter)\n\t\tfree(event->filter);\n\n\tevent->filter = strdup(filter);\n\tif (!event->filter)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nint trace_event_add_trigger(struct trace_events *event, char *trigger)\n{\n\tif (event->trigger)\n\t\tfree(event->trigger);\n\n\tevent->trigger = strdup(trigger);\n\tif (!event->trigger)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic void trace_event_disable_filter(struct trace_instance *instance,\n\t\t\t\t       struct trace_events *tevent)\n{\n\tchar filter[1024];\n\tint retval;\n\n\tif (!tevent->filter)\n\t\treturn;\n\n\tif (!tevent->filter_enabled)\n\t\treturn;\n\n\tdebug_msg(\"Disabling %s:%s filter %s\\n\", tevent->system,\n\t\t  tevent->event ? : \"*\", tevent->filter);\n\n\tsnprintf(filter, 1024, \"!%s\\n\", tevent->filter);\n\n\tretval = tracefs_event_file_write(instance->inst, tevent->system,\n\t\t\t\t\t  tevent->event, \"filter\", filter);\n\tif (retval < 0)\n\t\terr_msg(\"Error disabling %s:%s filter %s\\n\", tevent->system,\n\t\t\ttevent->event ? : \"*\", tevent->filter);\n}\n\n \nstatic void trace_event_save_hist(struct trace_instance *instance,\n\t\t\t\t  struct trace_events *tevent)\n{\n\tint retval, index, out_fd;\n\tmode_t mode = 0644;\n\tchar path[1024];\n\tchar *hist;\n\n\tif (!tevent)\n\t\treturn;\n\n\t \n\tif (!tevent->trigger)\n\t\treturn;\n\n\t \n\tretval = strncmp(tevent->trigger, \"hist:\", strlen(\"hist:\"));\n\tif (retval)\n\t\treturn;\n\n\tsnprintf(path, 1024, \"%s_%s_hist.txt\", tevent->system, tevent->event);\n\n\tprintf(\"  Saving event %s:%s hist to %s\\n\", tevent->system, tevent->event, path);\n\n\tout_fd = creat(path, mode);\n\tif (out_fd < 0) {\n\t\terr_msg(\"  Failed to create %s output file\\n\", path);\n\t\treturn;\n\t}\n\n\thist = tracefs_event_file_read(instance->inst, tevent->system, tevent->event, \"hist\", 0);\n\tif (!hist) {\n\t\terr_msg(\"  Failed to read %s:%s hist file\\n\", tevent->system, tevent->event);\n\t\tgoto out_close;\n\t}\n\n\tindex = 0;\n\tdo {\n\t\tindex += write(out_fd, &hist[index], strlen(hist) - index);\n\t} while (index < strlen(hist));\n\n\tfree(hist);\nout_close:\n\tclose(out_fd);\n}\n\n \nstatic void trace_event_disable_trigger(struct trace_instance *instance,\n\t\t\t\t\tstruct trace_events *tevent)\n{\n\tchar trigger[1024];\n\tint retval;\n\n\tif (!tevent->trigger)\n\t\treturn;\n\n\tif (!tevent->trigger_enabled)\n\t\treturn;\n\n\tdebug_msg(\"Disabling %s:%s trigger %s\\n\", tevent->system,\n\t\t  tevent->event ? : \"*\", tevent->trigger);\n\n\ttrace_event_save_hist(instance, tevent);\n\n\tsnprintf(trigger, 1024, \"!%s\\n\", tevent->trigger);\n\n\tretval = tracefs_event_file_write(instance->inst, tevent->system,\n\t\t\t\t\t  tevent->event, \"trigger\", trigger);\n\tif (retval < 0)\n\t\terr_msg(\"Error disabling %s:%s trigger %s\\n\", tevent->system,\n\t\t\ttevent->event ? : \"*\", tevent->trigger);\n}\n\n \nvoid trace_events_disable(struct trace_instance *instance,\n\t\t\t  struct trace_events *events)\n{\n\tstruct trace_events *tevent = events;\n\n\tif (!events)\n\t\treturn;\n\n\twhile (tevent) {\n\t\tdebug_msg(\"Disabling event %s:%s\\n\", tevent->system, tevent->event ? : \"*\");\n\t\tif (tevent->enabled) {\n\t\t\ttrace_event_disable_filter(instance, tevent);\n\t\t\ttrace_event_disable_trigger(instance, tevent);\n\t\t\ttracefs_event_disable(instance->inst, tevent->system, tevent->event);\n\t\t}\n\n\t\ttevent->enabled = 0;\n\t\ttevent = tevent->next;\n\t}\n}\n\n \nstatic int trace_event_enable_filter(struct trace_instance *instance,\n\t\t\t\t     struct trace_events *tevent)\n{\n\tchar filter[1024];\n\tint retval;\n\n\tif (!tevent->filter)\n\t\treturn 0;\n\n\tif (!tevent->event) {\n\t\terr_msg(\"Filter %s applies only for single events, not for all %s:* events\\n\",\n\t\t\ttevent->filter, tevent->system);\n\t\treturn 1;\n\t}\n\n\tsnprintf(filter, 1024, \"%s\\n\", tevent->filter);\n\n\tdebug_msg(\"Enabling %s:%s filter %s\\n\", tevent->system,\n\t\t  tevent->event ? : \"*\", tevent->filter);\n\n\tretval = tracefs_event_file_write(instance->inst, tevent->system,\n\t\t\t\t\t  tevent->event, \"filter\", filter);\n\tif (retval < 0) {\n\t\terr_msg(\"Error enabling %s:%s filter %s\\n\", tevent->system,\n\t\t\ttevent->event ? : \"*\", tevent->filter);\n\t\treturn 1;\n\t}\n\n\ttevent->filter_enabled = 1;\n\treturn 0;\n}\n\n \nstatic int trace_event_enable_trigger(struct trace_instance *instance,\n\t\t\t\t      struct trace_events *tevent)\n{\n\tchar trigger[1024];\n\tint retval;\n\n\tif (!tevent->trigger)\n\t\treturn 0;\n\n\tif (!tevent->event) {\n\t\terr_msg(\"Trigger %s applies only for single events, not for all %s:* events\\n\",\n\t\t\ttevent->trigger, tevent->system);\n\t\treturn 1;\n\t}\n\n\tsnprintf(trigger, 1024, \"%s\\n\", tevent->trigger);\n\n\tdebug_msg(\"Enabling %s:%s trigger %s\\n\", tevent->system,\n\t\t  tevent->event ? : \"*\", tevent->trigger);\n\n\tretval = tracefs_event_file_write(instance->inst, tevent->system,\n\t\t\t\t\t  tevent->event, \"trigger\", trigger);\n\tif (retval < 0) {\n\t\terr_msg(\"Error enabling %s:%s trigger %s\\n\", tevent->system,\n\t\t\ttevent->event ? : \"*\", tevent->trigger);\n\t\treturn 1;\n\t}\n\n\ttevent->trigger_enabled = 1;\n\n\treturn 0;\n}\n\n \nint trace_events_enable(struct trace_instance *instance,\n\t\t\tstruct trace_events *events)\n{\n\tstruct trace_events *tevent = events;\n\tint retval;\n\n\twhile (tevent) {\n\t\tdebug_msg(\"Enabling event %s:%s\\n\", tevent->system, tevent->event ? : \"*\");\n\t\tretval = tracefs_event_enable(instance->inst, tevent->system, tevent->event);\n\t\tif (retval < 0) {\n\t\t\terr_msg(\"Error enabling event %s:%s\\n\", tevent->system,\n\t\t\t\ttevent->event ? : \"*\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tretval = trace_event_enable_filter(instance, tevent);\n\t\tif (retval)\n\t\t\treturn 1;\n\n\t\tretval = trace_event_enable_trigger(instance, tevent);\n\t\tif (retval)\n\t\t\treturn 1;\n\n\t\ttevent->enabled = 1;\n\t\ttevent = tevent->next;\n\t}\n\n\treturn 0;\n}\n\n \nvoid trace_events_destroy(struct trace_instance *instance,\n\t\t\t  struct trace_events *events)\n{\n\tif (!events)\n\t\treturn;\n\n\ttrace_events_disable(instance, events);\n\ttrace_events_free(events);\n}\n\nint trace_is_off(struct trace_instance *tool, struct trace_instance *trace)\n{\n\t \n\tif (!tracefs_trace_is_on(tool->inst))\n\t\treturn 1;\n\n\t \n\tif (trace && !tracefs_trace_is_on(trace->inst))\n\t\treturn 1;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}