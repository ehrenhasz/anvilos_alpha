{
  "module_name": "osnoise_top.c",
  "hash_id": "1e509f5c5ddec3a158daa9ee4b4aaf9a2de6fd3992aadf1ad8f2bbc5fd05cb49",
  "original_prompt": "Ingested from linux-6.6.14/tools/tracing/rtla/src/osnoise_top.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <getopt.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <time.h>\n#include <sched.h>\n\n#include \"osnoise.h\"\n#include \"utils.h\"\n\nenum osnoise_mode {\n\tMODE_OSNOISE = 0,\n\tMODE_HWNOISE\n};\n\n \nstruct osnoise_top_params {\n\tchar\t\t\t*cpus;\n\tcpu_set_t\t\tmonitored_cpus;\n\tchar\t\t\t*trace_output;\n\tchar\t\t\t*cgroup_name;\n\tunsigned long long\truntime;\n\tunsigned long long\tperiod;\n\tlong long\t\tthreshold;\n\tlong long\t\tstop_us;\n\tlong long\t\tstop_total_us;\n\tint\t\t\tsleep_time;\n\tint\t\t\tduration;\n\tint\t\t\tquiet;\n\tint\t\t\tset_sched;\n\tint\t\t\tcgroup;\n\tint\t\t\thk_cpus;\n\tcpu_set_t\t\thk_cpu_set;\n\tstruct sched_attr\tsched_param;\n\tstruct trace_events\t*events;\n\tenum osnoise_mode\tmode;\n};\n\nstruct osnoise_top_cpu {\n\tunsigned long long\tsum_runtime;\n\tunsigned long long\tsum_noise;\n\tunsigned long long\tmax_noise;\n\tunsigned long long\tmax_sample;\n\n\tunsigned long long\thw_count;\n\tunsigned long long\tnmi_count;\n\tunsigned long long\tirq_count;\n\tunsigned long long\tsoftirq_count;\n\tunsigned long long\tthread_count;\n\n\tint\t\t\tsum_cycles;\n};\n\nstruct osnoise_top_data {\n\tstruct osnoise_top_cpu\t*cpu_data;\n\tint\t\t\tnr_cpus;\n};\n\n \nstatic void\nosnoise_free_top(struct osnoise_top_data *data)\n{\n\tfree(data->cpu_data);\n\tfree(data);\n}\n\n \nstatic struct osnoise_top_data *osnoise_alloc_top(int nr_cpus)\n{\n\tstruct osnoise_top_data *data;\n\n\tdata = calloc(1, sizeof(*data));\n\tif (!data)\n\t\treturn NULL;\n\n\tdata->nr_cpus = nr_cpus;\n\n\t \n\tdata->cpu_data = calloc(1, sizeof(*data->cpu_data) * nr_cpus);\n\tif (!data->cpu_data)\n\t\tgoto cleanup;\n\n\treturn data;\n\ncleanup:\n\tosnoise_free_top(data);\n\treturn NULL;\n}\n\n \nstatic int\nosnoise_top_handler(struct trace_seq *s, struct tep_record *record,\n\t\t    struct tep_event *event, void *context)\n{\n\tstruct trace_instance *trace = context;\n\tstruct osnoise_tool *tool;\n\tunsigned long long val;\n\tstruct osnoise_top_cpu *cpu_data;\n\tstruct osnoise_top_data *data;\n\tint cpu = record->cpu;\n\n\ttool = container_of(trace, struct osnoise_tool, trace);\n\n\tdata = tool->data;\n\tcpu_data = &data->cpu_data[cpu];\n\n\tcpu_data->sum_cycles++;\n\n\ttep_get_field_val(s, event, \"runtime\", record, &val, 1);\n\tupdate_sum(&cpu_data->sum_runtime, &val);\n\n\ttep_get_field_val(s, event, \"noise\", record, &val, 1);\n\tupdate_max(&cpu_data->max_noise, &val);\n\tupdate_sum(&cpu_data->sum_noise, &val);\n\n\ttep_get_field_val(s, event, \"max_sample\", record, &val, 1);\n\tupdate_max(&cpu_data->max_sample, &val);\n\n\ttep_get_field_val(s, event, \"hw_count\", record, &val, 1);\n\tupdate_sum(&cpu_data->hw_count, &val);\n\n\ttep_get_field_val(s, event, \"nmi_count\", record, &val, 1);\n\tupdate_sum(&cpu_data->nmi_count, &val);\n\n\ttep_get_field_val(s, event, \"irq_count\", record, &val, 1);\n\tupdate_sum(&cpu_data->irq_count, &val);\n\n\ttep_get_field_val(s, event, \"softirq_count\", record, &val, 1);\n\tupdate_sum(&cpu_data->softirq_count, &val);\n\n\ttep_get_field_val(s, event, \"thread_count\", record, &val, 1);\n\tupdate_sum(&cpu_data->thread_count, &val);\n\n\treturn 0;\n}\n\n \nstatic void osnoise_top_header(struct osnoise_tool *top)\n{\n\tstruct osnoise_top_params *params = top->params;\n\tstruct trace_seq *s = top->trace.seq;\n\tchar duration[26];\n\n\tget_duration(top->start_time, duration, sizeof(duration));\n\n\ttrace_seq_printf(s, \"\\033[2;37;40m\");\n\ttrace_seq_printf(s, \"                                          \");\n\n\tif (params->mode == MODE_OSNOISE) {\n\t\ttrace_seq_printf(s, \"Operating System Noise\");\n\t\ttrace_seq_printf(s, \"                                       \");\n\t} else if (params->mode == MODE_HWNOISE) {\n\t\ttrace_seq_printf(s, \"Hardware-related Noise\");\n\t}\n\n\ttrace_seq_printf(s, \"                                   \");\n\ttrace_seq_printf(s, \"\\033[0;0;0m\");\n\ttrace_seq_printf(s, \"\\n\");\n\n\ttrace_seq_printf(s, \"duration: %9s | time is in us\\n\", duration);\n\n\ttrace_seq_printf(s, \"\\033[2;30;47m\");\n\ttrace_seq_printf(s, \"CPU Period       Runtime \");\n\ttrace_seq_printf(s, \"       Noise \");\n\ttrace_seq_printf(s, \" %% CPU Aval \");\n\ttrace_seq_printf(s, \"  Max Noise   Max Single \");\n\ttrace_seq_printf(s, \"         HW          NMI\");\n\n\tif (params->mode == MODE_HWNOISE)\n\t\tgoto eol;\n\n\ttrace_seq_printf(s, \"          IRQ      Softirq       Thread\");\n\neol:\n\ttrace_seq_printf(s, \"\\033[0;0;0m\");\n\ttrace_seq_printf(s, \"\\n\");\n}\n\n \nstatic void clear_terminal(struct trace_seq *seq)\n{\n\tif (!config_debug)\n\t\ttrace_seq_printf(seq, \"\\033c\");\n}\n\n \nstatic void osnoise_top_print(struct osnoise_tool *tool, int cpu)\n{\n\tstruct osnoise_top_params *params = tool->params;\n\tstruct trace_seq *s = tool->trace.seq;\n\tstruct osnoise_top_cpu *cpu_data;\n\tstruct osnoise_top_data *data;\n\tint percentage;\n\tint decimal;\n\n\tdata = tool->data;\n\tcpu_data = &data->cpu_data[cpu];\n\n\tif (!cpu_data->sum_runtime)\n\t\treturn;\n\n\tpercentage = ((cpu_data->sum_runtime - cpu_data->sum_noise) * 10000000)\n\t\t\t/ cpu_data->sum_runtime;\n\tdecimal = percentage % 100000;\n\tpercentage = percentage / 100000;\n\n\ttrace_seq_printf(s, \"%3d #%-6d %12llu \", cpu, cpu_data->sum_cycles, cpu_data->sum_runtime);\n\ttrace_seq_printf(s, \"%12llu \", cpu_data->sum_noise);\n\ttrace_seq_printf(s, \"  %3d.%05d\", percentage, decimal);\n\ttrace_seq_printf(s, \"%12llu %12llu\", cpu_data->max_noise, cpu_data->max_sample);\n\n\ttrace_seq_printf(s, \"%12llu \", cpu_data->hw_count);\n\ttrace_seq_printf(s, \"%12llu \", cpu_data->nmi_count);\n\n\tif (params->mode == MODE_HWNOISE) {\n\t\ttrace_seq_printf(s, \"\\n\");\n\t\treturn;\n\t}\n\n\ttrace_seq_printf(s, \"%12llu \", cpu_data->irq_count);\n\ttrace_seq_printf(s, \"%12llu \", cpu_data->softirq_count);\n\ttrace_seq_printf(s, \"%12llu\\n\", cpu_data->thread_count);\n}\n\n \nstatic void\nosnoise_print_stats(struct osnoise_top_params *params, struct osnoise_tool *top)\n{\n\tstruct trace_instance *trace = &top->trace;\n\tstatic int nr_cpus = -1;\n\tint i;\n\n\tif (nr_cpus == -1)\n\t\tnr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\n\tif (!params->quiet)\n\t\tclear_terminal(trace->seq);\n\n\tosnoise_top_header(top);\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tif (params->cpus && !CPU_ISSET(i, &params->monitored_cpus))\n\t\t\tcontinue;\n\t\tosnoise_top_print(top, i);\n\t}\n\n\ttrace_seq_do_printf(trace->seq);\n\ttrace_seq_reset(trace->seq);\n}\n\n \nstatic void osnoise_top_usage(struct osnoise_top_params *params, char *usage)\n{\n\tint i;\n\n\tstatic const char * const msg[] = {\n\t\t\" [-h] [-q] [-D] [-d s] [-a us] [-p us] [-r us] [-s us] [-S us] \\\\\",\n\t\t\"\t  [-T us] [-t[=file]] [-e sys[:event]] [--filter <filter>] [--trigger <trigger>] \\\\\",\n\t\t\"\t  [-c cpu-list] [-H cpu-list] [-P priority] [-C[=cgroup_name]]\",\n\t\t\"\",\n\t\t\"\t  -h/--help: print this menu\",\n\t\t\"\t  -a/--auto: set automatic trace mode, stopping the session if argument in us sample is hit\",\n\t\t\"\t  -p/--period us: osnoise period in us\",\n\t\t\"\t  -r/--runtime us: osnoise runtime in us\",\n\t\t\"\t  -s/--stop us: stop trace if a single sample is higher than the argument in us\",\n\t\t\"\t  -S/--stop-total us: stop trace if the total sample is higher than the argument in us\",\n\t\t\"\t  -T/--threshold us: the minimum delta to be considered a noise\",\n\t\t\"\t  -c/--cpus cpu-list: list of cpus to run osnoise threads\",\n\t\t\"\t  -H/--house-keeping cpus: run rtla control threads only on the given cpus\",\n\t\t\"\t  -C/--cgroup[=cgroup_name]: set cgroup, if no cgroup_name is passed, the rtla's cgroup will be inherited\",\n\t\t\"\t  -d/--duration time[s|m|h|d]: duration of the session\",\n\t\t\"\t  -D/--debug: print debug info\",\n\t\t\"\t  -t/--trace[=file]: save the stopped trace to [file|osnoise_trace.txt]\",\n\t\t\"\t  -e/--event <sys:event>: enable the <sys:event> in the trace instance, multiple -e are allowed\",\n\t\t\"\t     --filter <filter>: enable a trace event filter to the previous -e event\",\n\t\t\"\t     --trigger <trigger>: enable a trace event trigger to the previous -e event\",\n\t\t\"\t  -q/--quiet print only a summary at the end\",\n\t\t\"\t  -P/--priority o:prio|r:prio|f:prio|d:runtime:period : set scheduling parameters\",\n\t\t\"\t\to:prio - use SCHED_OTHER with prio\",\n\t\t\"\t\tr:prio - use SCHED_RR with prio\",\n\t\t\"\t\tf:prio - use SCHED_FIFO with prio\",\n\t\t\"\t\td:runtime[us|ms|s]:period[us|ms|s] - use SCHED_DEADLINE with runtime and period\",\n\t\t\"\t\t\t\t\t\t       in nanoseconds\",\n\t\tNULL,\n\t};\n\n\tif (usage)\n\t\tfprintf(stderr, \"%s\\n\", usage);\n\n\tif (params->mode == MODE_OSNOISE) {\n\t\tfprintf(stderr,\n\t\t\t\"rtla osnoise top: a per-cpu summary of the OS noise (version %s)\\n\",\n\t\t\tVERSION);\n\n\t\tfprintf(stderr, \"  usage: rtla osnoise [top]\");\n\t}\n\n\tif (params->mode == MODE_HWNOISE) {\n\t\tfprintf(stderr,\n\t\t\t\"rtla hwnoise: a summary of hardware-related noise (version %s)\\n\",\n\t\t\tVERSION);\n\n\t\tfprintf(stderr, \"  usage: rtla hwnoise\");\n\t}\n\n\tfor (i = 0; msg[i]; i++)\n\t\tfprintf(stderr, \"%s\\n\", msg[i]);\n\texit(1);\n}\n\n \nstruct osnoise_top_params *osnoise_top_parse_args(int argc, char **argv)\n{\n\tstruct osnoise_top_params *params;\n\tstruct trace_events *tevent;\n\tint retval;\n\tint c;\n\n\tparams = calloc(1, sizeof(*params));\n\tif (!params)\n\t\texit(1);\n\n\tif (strcmp(argv[0], \"hwnoise\") == 0) {\n\t\tparams->mode = MODE_HWNOISE;\n\t\t \n\t\tparams->runtime = 750000;\n\t\tparams->period = 1000000;\n\t}\n\n\twhile (1) {\n\t\tstatic struct option long_options[] = {\n\t\t\t{\"auto\",\t\trequired_argument,\t0, 'a'},\n\t\t\t{\"cpus\",\t\trequired_argument,\t0, 'c'},\n\t\t\t{\"cgroup\",\t\toptional_argument,\t0, 'C'},\n\t\t\t{\"debug\",\t\tno_argument,\t\t0, 'D'},\n\t\t\t{\"duration\",\t\trequired_argument,\t0, 'd'},\n\t\t\t{\"event\",\t\trequired_argument,\t0, 'e'},\n\t\t\t{\"house-keeping\",\trequired_argument,\t0, 'H'},\n\t\t\t{\"help\",\t\tno_argument,\t\t0, 'h'},\n\t\t\t{\"period\",\t\trequired_argument,\t0, 'p'},\n\t\t\t{\"priority\",\t\trequired_argument,\t0, 'P'},\n\t\t\t{\"quiet\",\t\tno_argument,\t\t0, 'q'},\n\t\t\t{\"runtime\",\t\trequired_argument,\t0, 'r'},\n\t\t\t{\"stop\",\t\trequired_argument,\t0, 's'},\n\t\t\t{\"stop-total\",\t\trequired_argument,\t0, 'S'},\n\t\t\t{\"threshold\",\t\trequired_argument,\t0, 'T'},\n\t\t\t{\"trace\",\t\toptional_argument,\t0, 't'},\n\t\t\t{\"trigger\",\t\trequired_argument,\t0, '0'},\n\t\t\t{\"filter\",\t\trequired_argument,\t0, '1'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n\n\t\t \n\t\tint option_index = 0;\n\n\t\tc = getopt_long(argc, argv, \"a:c:C::d:De:hH:p:P:qr:s:S:t::T:0:1:\",\n\t\t\t\t long_options, &option_index);\n\n\t\t \n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\t \n\t\t\tparams->stop_us = get_llong_from_str(optarg);\n\n\t\t\t \n\t\t\tparams->threshold = 1;\n\n\t\t\t \n\t\t\tparams->trace_output = \"osnoise_trace.txt\";\n\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tretval = parse_cpu_set(optarg, &params->monitored_cpus);\n\t\t\tif (retval)\n\t\t\t\tosnoise_top_usage(params, \"\\nInvalid -c cpu list\\n\");\n\t\t\tparams->cpus = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tparams->cgroup = 1;\n\t\t\tif (!optarg) {\n\t\t\t\t \n\t\t\t\tparams->cgroup_name = NULL;\n\t\t\t} else if (*optarg == '=') {\n\t\t\t\t \n\t\t\t\tparams->cgroup_name = ++optarg;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tconfig_debug = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tparams->duration = parse_seconds_duration(optarg);\n\t\t\tif (!params->duration)\n\t\t\t\tosnoise_top_usage(params, \"Invalid -D duration\\n\");\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\ttevent = trace_event_alloc(optarg);\n\t\t\tif (!tevent) {\n\t\t\t\terr_msg(\"Error alloc trace event\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\tif (params->events)\n\t\t\t\ttevent->next = params->events;\n\t\t\tparams->events = tevent;\n\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tosnoise_top_usage(params, NULL);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tparams->hk_cpus = 1;\n\t\t\tretval = parse_cpu_set(optarg, &params->hk_cpu_set);\n\t\t\tif (retval) {\n\t\t\t\terr_msg(\"Error parsing house keeping CPUs\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparams->period = get_llong_from_str(optarg);\n\t\t\tif (params->period > 10000000)\n\t\t\t\tosnoise_top_usage(params, \"Period longer than 10 s\\n\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tretval = parse_prio(optarg, &params->sched_param);\n\t\t\tif (retval == -1)\n\t\t\t\tosnoise_top_usage(params, \"Invalid -P priority\");\n\t\t\tparams->set_sched = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tparams->quiet = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tparams->runtime = get_llong_from_str(optarg);\n\t\t\tif (params->runtime < 100)\n\t\t\t\tosnoise_top_usage(params, \"Runtime shorter than 100 us\\n\");\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tparams->stop_us = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tparams->stop_total_us = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (optarg)\n\t\t\t\t \n\t\t\t\tparams->trace_output = &optarg[1];\n\t\t\telse\n\t\t\t\tparams->trace_output = \"osnoise_trace.txt\";\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tparams->threshold = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase '0':  \n\t\t\tif (params->events) {\n\t\t\t\tretval = trace_event_add_trigger(params->events, optarg);\n\t\t\t\tif (retval) {\n\t\t\t\t\terr_msg(\"Error adding trigger %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tosnoise_top_usage(params, \"--trigger requires a previous -e\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '1':  \n\t\t\tif (params->events) {\n\t\t\t\tretval = trace_event_add_filter(params->events, optarg);\n\t\t\t\tif (retval) {\n\t\t\t\t\terr_msg(\"Error adding filter %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tosnoise_top_usage(params, \"--filter requires a previous -e\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tosnoise_top_usage(params, \"Invalid option\");\n\t\t}\n\t}\n\n\tif (geteuid()) {\n\t\terr_msg(\"osnoise needs root permission\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn params;\n}\n\n \nstatic int\nosnoise_top_apply_config(struct osnoise_tool *tool, struct osnoise_top_params *params)\n{\n\tint retval;\n\n\tif (!params->sleep_time)\n\t\tparams->sleep_time = 1;\n\n\tif (params->cpus) {\n\t\tretval = osnoise_set_cpus(tool->context, params->cpus);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to apply CPUs config\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->runtime || params->period) {\n\t\tretval = osnoise_set_runtime_period(tool->context,\n\t\t\t\t\t\t    params->runtime,\n\t\t\t\t\t\t    params->period);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set runtime and/or period\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->stop_us) {\n\t\tretval = osnoise_set_stop_us(tool->context, params->stop_us);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set stop us\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->stop_total_us) {\n\t\tretval = osnoise_set_stop_total_us(tool->context, params->stop_total_us);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set stop total us\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->threshold) {\n\t\tretval = osnoise_set_tracing_thresh(tool->context, params->threshold);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set tracing_thresh\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->mode == MODE_HWNOISE) {\n\t\tretval = osnoise_set_irq_disable(tool->context, 1);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set OSNOISE_IRQ_DISABLE option\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->hk_cpus) {\n\t\tretval = sched_setaffinity(getpid(), sizeof(params->hk_cpu_set),\n\t\t\t\t\t   &params->hk_cpu_set);\n\t\tif (retval == -1) {\n\t\t\terr_msg(\"Failed to set rtla to the house keeping CPUs\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (params->cpus) {\n\t\t \n\t\tauto_house_keeping(&params->monitored_cpus);\n\t}\n\n\treturn 0;\n\nout_err:\n\treturn -1;\n}\n\n \nstruct osnoise_tool *osnoise_init_top(struct osnoise_top_params *params)\n{\n\tstruct osnoise_tool *tool;\n\tint nr_cpus;\n\n\tnr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\n\ttool = osnoise_init_tool(\"osnoise_top\");\n\tif (!tool)\n\t\treturn NULL;\n\n\ttool->data = osnoise_alloc_top(nr_cpus);\n\tif (!tool->data)\n\t\tgoto out_err;\n\n\ttool->params = params;\n\n\ttep_register_event_handler(tool->trace.tep, -1, \"ftrace\", \"osnoise\",\n\t\t\t\t   osnoise_top_handler, NULL);\n\n\treturn tool;\n\nout_err:\n\tosnoise_free_top(tool->data);\n\tosnoise_destroy_tool(tool);\n\treturn NULL;\n}\n\nstatic int stop_tracing;\nstatic void stop_top(int sig)\n{\n\tstop_tracing = 1;\n}\n\n \nstatic void osnoise_top_set_signals(struct osnoise_top_params *params)\n{\n\tsignal(SIGINT, stop_top);\n\tif (params->duration) {\n\t\tsignal(SIGALRM, stop_top);\n\t\talarm(params->duration);\n\t}\n}\n\nint osnoise_top_main(int argc, char **argv)\n{\n\tstruct osnoise_top_params *params;\n\tstruct osnoise_tool *record = NULL;\n\tstruct osnoise_tool *tool = NULL;\n\tstruct trace_instance *trace;\n\tint return_value = 1;\n\tint retval;\n\n\tparams = osnoise_top_parse_args(argc, argv);\n\tif (!params)\n\t\texit(1);\n\n\ttool = osnoise_init_top(params);\n\tif (!tool) {\n\t\terr_msg(\"Could not init osnoise top\\n\");\n\t\tgoto out_exit;\n\t}\n\n\tretval = osnoise_top_apply_config(tool, params);\n\tif (retval) {\n\t\terr_msg(\"Could not apply config\\n\");\n\t\tgoto out_free;\n\t}\n\n\ttrace = &tool->trace;\n\n\tretval = enable_osnoise(trace);\n\tif (retval) {\n\t\terr_msg(\"Failed to enable osnoise tracer\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (params->set_sched) {\n\t\tretval = set_comm_sched_attr(\"osnoise/\", &params->sched_param);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set sched parameters\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (params->cgroup) {\n\t\tretval = set_comm_cgroup(\"osnoise/\", params->cgroup_name);\n\t\tif (!retval) {\n\t\t\terr_msg(\"Failed to move threads to cgroup\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (params->trace_output) {\n\t\trecord = osnoise_init_trace_tool(\"osnoise\");\n\t\tif (!record) {\n\t\t\terr_msg(\"Failed to enable the trace instance\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (params->events) {\n\t\t\tretval = trace_events_enable(&record->trace, params->events);\n\t\t\tif (retval)\n\t\t\t\tgoto out_top;\n\t\t}\n\t}\n\n\t \n\tif (params->trace_output)\n\t\ttrace_instance_start(&record->trace);\n\ttrace_instance_start(trace);\n\n\ttool->start_time = time(NULL);\n\tosnoise_top_set_signals(params);\n\n\twhile (!stop_tracing) {\n\t\tsleep(params->sleep_time);\n\n\t\tretval = tracefs_iterate_raw_events(trace->tep,\n\t\t\t\t\t\t    trace->inst,\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    collect_registered_events,\n\t\t\t\t\t\t    trace);\n\t\tif (retval < 0) {\n\t\t\terr_msg(\"Error iterating on events\\n\");\n\t\t\tgoto out_top;\n\t\t}\n\n\t\tif (!params->quiet)\n\t\t\tosnoise_print_stats(params, tool);\n\n\t\tif (trace_is_off(&tool->trace, &record->trace))\n\t\t\tbreak;\n\n\t}\n\n\tosnoise_print_stats(params, tool);\n\n\treturn_value = 0;\n\n\tif (trace_is_off(&tool->trace, &record->trace)) {\n\t\tprintf(\"osnoise hit stop tracing\\n\");\n\t\tif (params->trace_output) {\n\t\t\tprintf(\"  Saving trace to %s\\n\", params->trace_output);\n\t\t\tsave_trace_to_file(record->trace.inst, params->trace_output);\n\t\t}\n\t}\n\nout_top:\n\ttrace_events_destroy(&record->trace, params->events);\n\tparams->events = NULL;\nout_free:\n\tosnoise_free_top(tool->data);\n\tosnoise_destroy_tool(record);\n\tosnoise_destroy_tool(tool);\n\tfree(params);\nout_exit:\n\texit(return_value);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}