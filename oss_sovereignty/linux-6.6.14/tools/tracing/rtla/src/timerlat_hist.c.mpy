{
  "module_name": "timerlat_hist.c",
  "hash_id": "df344fa2fe179ac16e9db7fb08a1c51248ac5501ca36ff2ff6589fae75b83694",
  "original_prompt": "Ingested from linux-6.6.14/tools/tracing/rtla/src/timerlat_hist.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <getopt.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <time.h>\n#include <sched.h>\n#include <pthread.h>\n\n#include \"utils.h\"\n#include \"osnoise.h\"\n#include \"timerlat.h\"\n#include \"timerlat_aa.h\"\n#include \"timerlat_u.h\"\n\nstruct timerlat_hist_params {\n\tchar\t\t\t*cpus;\n\tcpu_set_t\t\tmonitored_cpus;\n\tchar\t\t\t*trace_output;\n\tchar\t\t\t*cgroup_name;\n\tunsigned long long\truntime;\n\tlong long\t\tstop_us;\n\tlong long\t\tstop_total_us;\n\tlong long\t\ttimerlat_period_us;\n\tlong long\t\tprint_stack;\n\tint\t\t\tsleep_time;\n\tint\t\t\toutput_divisor;\n\tint\t\t\tduration;\n\tint\t\t\tset_sched;\n\tint\t\t\tdma_latency;\n\tint\t\t\tcgroup;\n\tint\t\t\thk_cpus;\n\tint\t\t\tno_aa;\n\tint\t\t\tdump_tasks;\n\tint\t\t\tuser_hist;\n\tcpu_set_t\t\thk_cpu_set;\n\tstruct sched_attr\tsched_param;\n\tstruct trace_events\t*events;\n\tchar\t\t\tno_irq;\n\tchar\t\t\tno_thread;\n\tchar\t\t\tno_header;\n\tchar\t\t\tno_summary;\n\tchar\t\t\tno_index;\n\tchar\t\t\twith_zeros;\n\tint\t\t\tbucket_size;\n\tint\t\t\tentries;\n};\n\nstruct timerlat_hist_cpu {\n\tint\t\t\t*irq;\n\tint\t\t\t*thread;\n\tint\t\t\t*user;\n\n\tint\t\t\tirq_count;\n\tint\t\t\tthread_count;\n\tint\t\t\tuser_count;\n\n\tunsigned long long\tmin_irq;\n\tunsigned long long\tsum_irq;\n\tunsigned long long\tmax_irq;\n\n\tunsigned long long\tmin_thread;\n\tunsigned long long\tsum_thread;\n\tunsigned long long\tmax_thread;\n\n\tunsigned long long\tmin_user;\n\tunsigned long long\tsum_user;\n\tunsigned long long\tmax_user;\n};\n\nstruct timerlat_hist_data {\n\tstruct timerlat_hist_cpu\t*hist;\n\tint\t\t\t\tentries;\n\tint\t\t\t\tbucket_size;\n\tint\t\t\t\tnr_cpus;\n};\n\n \nstatic void\ntimerlat_free_histogram(struct timerlat_hist_data *data)\n{\n\tint cpu;\n\n\t \n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (data->hist[cpu].irq)\n\t\t\tfree(data->hist[cpu].irq);\n\n\t\tif (data->hist[cpu].thread)\n\t\t\tfree(data->hist[cpu].thread);\n\n\t\tif (data->hist[cpu].user)\n\t\t\tfree(data->hist[cpu].user);\n\n\t}\n\n\t \n\tif (data->hist)\n\t\tfree(data->hist);\n\n\tfree(data);\n}\n\n \nstatic struct timerlat_hist_data\n*timerlat_alloc_histogram(int nr_cpus, int entries, int bucket_size)\n{\n\tstruct timerlat_hist_data *data;\n\tint cpu;\n\n\tdata = calloc(1, sizeof(*data));\n\tif (!data)\n\t\treturn NULL;\n\n\tdata->entries = entries;\n\tdata->bucket_size = bucket_size;\n\tdata->nr_cpus = nr_cpus;\n\n\t \n\tdata->hist = calloc(1, sizeof(*data->hist) * nr_cpus);\n\tif (!data->hist)\n\t\tgoto cleanup;\n\n\t \n\tfor (cpu = 0; cpu < nr_cpus; cpu++) {\n\t\tdata->hist[cpu].irq = calloc(1, sizeof(*data->hist->irq) * (entries + 1));\n\t\tif (!data->hist[cpu].irq)\n\t\t\tgoto cleanup;\n\n\t\tdata->hist[cpu].thread = calloc(1, sizeof(*data->hist->thread) * (entries + 1));\n\t\tif (!data->hist[cpu].thread)\n\t\t\tgoto cleanup;\n\n\t\tdata->hist[cpu].user = calloc(1, sizeof(*data->hist->user) * (entries + 1));\n\t\tif (!data->hist[cpu].user)\n\t\t\tgoto cleanup;\n\t}\n\n\t \n\tfor (cpu = 0; cpu < nr_cpus; cpu++) {\n\t\tdata->hist[cpu].min_irq = ~0;\n\t\tdata->hist[cpu].min_thread = ~0;\n\t\tdata->hist[cpu].min_user = ~0;\n\t}\n\n\treturn data;\n\ncleanup:\n\ttimerlat_free_histogram(data);\n\treturn NULL;\n}\n\n \nstatic void\ntimerlat_hist_update(struct osnoise_tool *tool, int cpu,\n\t\t     unsigned long long context,\n\t\t     unsigned long long latency)\n{\n\tstruct timerlat_hist_params *params = tool->params;\n\tstruct timerlat_hist_data *data = tool->data;\n\tint entries = data->entries;\n\tint bucket;\n\tint *hist;\n\n\tif (params->output_divisor)\n\t\tlatency = latency / params->output_divisor;\n\n\tif (data->bucket_size)\n\t\tbucket = latency / data->bucket_size;\n\n\tif (!context) {\n\t\thist = data->hist[cpu].irq;\n\t\tdata->hist[cpu].irq_count++;\n\t\tupdate_min(&data->hist[cpu].min_irq, &latency);\n\t\tupdate_sum(&data->hist[cpu].sum_irq, &latency);\n\t\tupdate_max(&data->hist[cpu].max_irq, &latency);\n\t} else if (context == 1) {\n\t\thist = data->hist[cpu].thread;\n\t\tdata->hist[cpu].thread_count++;\n\t\tupdate_min(&data->hist[cpu].min_thread, &latency);\n\t\tupdate_sum(&data->hist[cpu].sum_thread, &latency);\n\t\tupdate_max(&data->hist[cpu].max_thread, &latency);\n\t} else {  \n\t\thist = data->hist[cpu].user;\n\t\tdata->hist[cpu].user_count++;\n\t\tupdate_min(&data->hist[cpu].min_user, &latency);\n\t\tupdate_sum(&data->hist[cpu].sum_user, &latency);\n\t\tupdate_max(&data->hist[cpu].max_user, &latency);\n\t}\n\n\tif (bucket < entries)\n\t\thist[bucket]++;\n\telse\n\t\thist[entries]++;\n}\n\n \nstatic int\ntimerlat_hist_handler(struct trace_seq *s, struct tep_record *record,\n\t\t     struct tep_event *event, void *data)\n{\n\tstruct trace_instance *trace = data;\n\tunsigned long long context, latency;\n\tstruct osnoise_tool *tool;\n\tint cpu = record->cpu;\n\n\ttool = container_of(trace, struct osnoise_tool, trace);\n\n\ttep_get_field_val(s, event, \"context\", record, &context, 1);\n\ttep_get_field_val(s, event, \"timer_latency\", record, &latency, 1);\n\n\ttimerlat_hist_update(tool, cpu, context, latency);\n\n\treturn 0;\n}\n\n \nstatic void timerlat_hist_header(struct osnoise_tool *tool)\n{\n\tstruct timerlat_hist_params *params = tool->params;\n\tstruct timerlat_hist_data *data = tool->data;\n\tstruct trace_seq *s = tool->trace.seq;\n\tchar duration[26];\n\tint cpu;\n\n\tif (params->no_header)\n\t\treturn;\n\n\tget_duration(tool->start_time, duration, sizeof(duration));\n\ttrace_seq_printf(s, \"# RTLA timerlat histogram\\n\");\n\ttrace_seq_printf(s, \"# Time unit is %s (%s)\\n\",\n\t\t\tparams->output_divisor == 1 ? \"nanoseconds\" : \"microseconds\",\n\t\t\tparams->output_divisor == 1 ? \"ns\" : \"us\");\n\n\ttrace_seq_printf(s, \"# Duration: %s\\n\", duration);\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(s, \"Index\");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].irq_count && !data->hist[cpu].thread_count)\n\t\t\tcontinue;\n\n\t\tif (!params->no_irq)\n\t\t\ttrace_seq_printf(s, \"   IRQ-%03d\", cpu);\n\n\t\tif (!params->no_thread)\n\t\t\ttrace_seq_printf(s, \"   Thr-%03d\", cpu);\n\n\t\tif (params->user_hist)\n\t\t\ttrace_seq_printf(s, \"   Usr-%03d\", cpu);\n\t}\n\ttrace_seq_printf(s, \"\\n\");\n\n\n\ttrace_seq_do_printf(s);\n\ttrace_seq_reset(s);\n}\n\n \nstatic void\ntimerlat_print_summary(struct timerlat_hist_params *params,\n\t\t       struct trace_instance *trace,\n\t\t       struct timerlat_hist_data *data)\n{\n\tint cpu;\n\n\tif (params->no_summary)\n\t\treturn;\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(trace->seq, \"count:\");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].irq_count && !data->hist[cpu].thread_count)\n\t\t\tcontinue;\n\n\t\tif (!params->no_irq)\n\t\t\ttrace_seq_printf(trace->seq, \"%9d \",\n\t\t\t\t\tdata->hist[cpu].irq_count);\n\n\t\tif (!params->no_thread)\n\t\t\ttrace_seq_printf(trace->seq, \"%9d \",\n\t\t\t\t\tdata->hist[cpu].thread_count);\n\n\t\tif (params->user_hist)\n\t\t\ttrace_seq_printf(trace->seq, \"%9d \",\n\t\t\t\t\t data->hist[cpu].user_count);\n\t}\n\ttrace_seq_printf(trace->seq, \"\\n\");\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(trace->seq, \"min:  \");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].irq_count && !data->hist[cpu].thread_count)\n\t\t\tcontinue;\n\n\t\tif (!params->no_irq)\n\t\t\ttrace_seq_printf(trace->seq, \"%9llu \",\n\t\t\t\t\tdata->hist[cpu].min_irq);\n\n\t\tif (!params->no_thread)\n\t\t\ttrace_seq_printf(trace->seq, \"%9llu \",\n\t\t\t\t\tdata->hist[cpu].min_thread);\n\n\t\tif (params->user_hist)\n\t\t\ttrace_seq_printf(trace->seq, \"%9llu \",\n\t\t\t\t\tdata->hist[cpu].min_user);\n\t}\n\ttrace_seq_printf(trace->seq, \"\\n\");\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(trace->seq, \"avg:  \");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].irq_count && !data->hist[cpu].thread_count)\n\t\t\tcontinue;\n\n\t\tif (!params->no_irq) {\n\t\t\tif (data->hist[cpu].irq_count)\n\t\t\t\ttrace_seq_printf(trace->seq, \"%9llu \",\n\t\t\t\t\t\t data->hist[cpu].sum_irq / data->hist[cpu].irq_count);\n\t\t\telse\n\t\t\t\ttrace_seq_printf(trace->seq, \"        - \");\n\t\t}\n\n\t\tif (!params->no_thread) {\n\t\t\tif (data->hist[cpu].thread_count)\n\t\t\t\ttrace_seq_printf(trace->seq, \"%9llu \",\n\t\t\t\t\t\t data->hist[cpu].sum_thread / data->hist[cpu].thread_count);\n\t\t\telse\n\t\t\t\ttrace_seq_printf(trace->seq, \"        - \");\n\t\t}\n\n\t\tif (params->user_hist) {\n\t\t\tif (data->hist[cpu].user_count)\n\t\t\t\ttrace_seq_printf(trace->seq, \"%9llu \",\n\t\t\t\t\t\t data->hist[cpu].sum_user / data->hist[cpu].user_count);\n\t\t\telse\n\t\t\t\ttrace_seq_printf(trace->seq, \"        - \");\n\t\t}\n\t}\n\ttrace_seq_printf(trace->seq, \"\\n\");\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(trace->seq, \"max:  \");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].irq_count && !data->hist[cpu].thread_count)\n\t\t\tcontinue;\n\n\t\tif (!params->no_irq)\n\t\t\ttrace_seq_printf(trace->seq, \"%9llu \",\n\t\t\t\t\tdata->hist[cpu].max_irq);\n\n\t\tif (!params->no_thread)\n\t\t\ttrace_seq_printf(trace->seq, \"%9llu \",\n\t\t\t\t\tdata->hist[cpu].max_thread);\n\n\t\tif (params->user_hist)\n\t\t\ttrace_seq_printf(trace->seq, \"%9llu \",\n\t\t\t\t\tdata->hist[cpu].max_user);\n\t}\n\ttrace_seq_printf(trace->seq, \"\\n\");\n\ttrace_seq_do_printf(trace->seq);\n\ttrace_seq_reset(trace->seq);\n}\n\n \nstatic void\ntimerlat_print_stats(struct timerlat_hist_params *params, struct osnoise_tool *tool)\n{\n\tstruct timerlat_hist_data *data = tool->data;\n\tstruct trace_instance *trace = &tool->trace;\n\tint bucket, cpu;\n\tint total;\n\n\ttimerlat_hist_header(tool);\n\n\tfor (bucket = 0; bucket < data->entries; bucket++) {\n\t\ttotal = 0;\n\n\t\tif (!params->no_index)\n\t\t\ttrace_seq_printf(trace->seq, \"%-6d\",\n\t\t\t\t\t bucket * data->bucket_size);\n\n\t\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\t\tcontinue;\n\n\t\t\tif (!data->hist[cpu].irq_count && !data->hist[cpu].thread_count)\n\t\t\t\tcontinue;\n\n\t\t\tif (!params->no_irq) {\n\t\t\t\ttotal += data->hist[cpu].irq[bucket];\n\t\t\t\ttrace_seq_printf(trace->seq, \"%9d \",\n\t\t\t\t\t\tdata->hist[cpu].irq[bucket]);\n\t\t\t}\n\n\t\t\tif (!params->no_thread) {\n\t\t\t\ttotal += data->hist[cpu].thread[bucket];\n\t\t\t\ttrace_seq_printf(trace->seq, \"%9d \",\n\t\t\t\t\t\tdata->hist[cpu].thread[bucket]);\n\t\t\t}\n\n\t\t\tif (params->user_hist) {\n\t\t\t\ttotal += data->hist[cpu].user[bucket];\n\t\t\t\ttrace_seq_printf(trace->seq, \"%9d \",\n\t\t\t\t\t\tdata->hist[cpu].user[bucket]);\n\t\t\t}\n\n\t\t}\n\n\t\tif (total == 0 && !params->with_zeros) {\n\t\t\ttrace_seq_reset(trace->seq);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttrace_seq_printf(trace->seq, \"\\n\");\n\t\ttrace_seq_do_printf(trace->seq);\n\t\ttrace_seq_reset(trace->seq);\n\t}\n\n\tif (!params->no_index)\n\t\ttrace_seq_printf(trace->seq, \"over: \");\n\n\tfor (cpu = 0; cpu < data->nr_cpus; cpu++) {\n\t\tif (params->cpus && !CPU_ISSET(cpu, &params->monitored_cpus))\n\t\t\tcontinue;\n\n\t\tif (!data->hist[cpu].irq_count && !data->hist[cpu].thread_count)\n\t\t\tcontinue;\n\n\t\tif (!params->no_irq)\n\t\t\ttrace_seq_printf(trace->seq, \"%9d \",\n\t\t\t\t\t data->hist[cpu].irq[data->entries]);\n\n\t\tif (!params->no_thread)\n\t\t\ttrace_seq_printf(trace->seq, \"%9d \",\n\t\t\t\t\t data->hist[cpu].thread[data->entries]);\n\n\t\tif (params->user_hist)\n\t\t\ttrace_seq_printf(trace->seq, \"%9d \",\n\t\t\t\t\t data->hist[cpu].user[data->entries]);\n\t}\n\ttrace_seq_printf(trace->seq, \"\\n\");\n\ttrace_seq_do_printf(trace->seq);\n\ttrace_seq_reset(trace->seq);\n\n\ttimerlat_print_summary(params, trace, data);\n}\n\n \nstatic void timerlat_hist_usage(char *usage)\n{\n\tint i;\n\n\tchar *msg[] = {\n\t\t\"\",\n\t\t\"  usage: [rtla] timerlat hist [-h] [-q] [-d s] [-D] [-n] [-a us] [-p us] [-i us] [-T us] [-s us] \\\\\",\n\t\t\"         [-t[=file]] [-e sys[:event]] [--filter <filter>] [--trigger <trigger>] [-c cpu-list] [-H cpu-list]\\\\\",\n\t\t\"\t  [-P priority] [-E N] [-b N] [--no-irq] [--no-thread] [--no-header] [--no-summary] \\\\\",\n\t\t\"\t  [--no-index] [--with-zeros] [--dma-latency us] [-C[=cgroup_name]] [--no-aa] [--dump-task] [-u]\",\n\t\t\"\",\n\t\t\"\t  -h/--help: print this menu\",\n\t\t\"\t  -a/--auto: set automatic trace mode, stopping the session if argument in us latency is hit\",\n\t\t\"\t  -p/--period us: timerlat period in us\",\n\t\t\"\t  -i/--irq us: stop trace if the irq latency is higher than the argument in us\",\n\t\t\"\t  -T/--thread us: stop trace if the thread latency is higher than the argument in us\",\n\t\t\"\t  -s/--stack us: save the stack trace at the IRQ if a thread latency is higher than the argument in us\",\n\t\t\"\t  -c/--cpus cpus: run the tracer only on the given cpus\",\n\t\t\"\t  -H/--house-keeping cpus: run rtla control threads only on the given cpus\",\n\t\t\"\t  -C/--cgroup[=cgroup_name]: set cgroup, if no cgroup_name is passed, the rtla's cgroup will be inherited\",\n\t\t\"\t  -d/--duration time[m|h|d]: duration of the session in seconds\",\n\t\t\"\t     --dump-tasks: prints the task running on all CPUs if stop conditions are met (depends on !--no-aa)\",\n\t\t\"\t  -D/--debug: print debug info\",\n\t\t\"\t  -t/--trace[=file]: save the stopped trace to [file|timerlat_trace.txt]\",\n\t\t\"\t  -e/--event <sys:event>: enable the <sys:event> in the trace instance, multiple -e are allowed\",\n\t\t\"\t     --filter <filter>: enable a trace event filter to the previous -e event\",\n\t\t\"\t     --trigger <trigger>: enable a trace event trigger to the previous -e event\",\n\t\t\"\t  -n/--nano: display data in nanoseconds\",\n\t\t\"\t     --no-aa: disable auto-analysis, reducing rtla timerlat cpu usage\",\n\t\t\"\t  -b/--bucket-size N: set the histogram bucket size (default 1)\",\n\t\t\"\t  -E/--entries N: set the number of entries of the histogram (default 256)\",\n\t\t\"\t     --no-irq: ignore IRQ latencies\",\n\t\t\"\t     --no-thread: ignore thread latencies\",\n\t\t\"\t     --no-header: do not print header\",\n\t\t\"\t     --no-summary: do not print summary\",\n\t\t\"\t     --no-index: do not print index\",\n\t\t\"\t     --with-zeros: print zero only entries\",\n\t\t\"\t     --dma-latency us: set /dev/cpu_dma_latency latency <us> to reduce exit from idle latency\",\n\t\t\"\t  -P/--priority o:prio|r:prio|f:prio|d:runtime:period : set scheduling parameters\",\n\t\t\"\t\to:prio - use SCHED_OTHER with prio\",\n\t\t\"\t\tr:prio - use SCHED_RR with prio\",\n\t\t\"\t\tf:prio - use SCHED_FIFO with prio\",\n\t\t\"\t\td:runtime[us|ms|s]:period[us|ms|s] - use SCHED_DEADLINE with runtime and period\",\n\t\t\"\t\t\t\t\t\t       in nanoseconds\",\n\t\t\"\t  -u/--user-threads: use rtla user-space threads instead of in-kernel timerlat threads\",\n\t\tNULL,\n\t};\n\n\tif (usage)\n\t\tfprintf(stderr, \"%s\\n\", usage);\n\n\tfprintf(stderr, \"rtla timerlat hist: a per-cpu histogram of the timer latency (version %s)\\n\",\n\t\t\tVERSION);\n\n\tfor (i = 0; msg[i]; i++)\n\t\tfprintf(stderr, \"%s\\n\", msg[i]);\n\texit(1);\n}\n\n \nstatic struct timerlat_hist_params\n*timerlat_hist_parse_args(int argc, char *argv[])\n{\n\tstruct timerlat_hist_params *params;\n\tstruct trace_events *tevent;\n\tint auto_thresh;\n\tint retval;\n\tint c;\n\n\tparams = calloc(1, sizeof(*params));\n\tif (!params)\n\t\texit(1);\n\n\t \n\tparams->dma_latency = -1;\n\n\t \n\tparams->output_divisor = 1000;\n\tparams->bucket_size = 1;\n\tparams->entries = 256;\n\n\twhile (1) {\n\t\tstatic struct option long_options[] = {\n\t\t\t{\"auto\",\t\trequired_argument,\t0, 'a'},\n\t\t\t{\"cpus\",\t\trequired_argument,\t0, 'c'},\n\t\t\t{\"cgroup\",\t\toptional_argument,\t0, 'C'},\n\t\t\t{\"bucket-size\",\t\trequired_argument,\t0, 'b'},\n\t\t\t{\"debug\",\t\tno_argument,\t\t0, 'D'},\n\t\t\t{\"entries\",\t\trequired_argument,\t0, 'E'},\n\t\t\t{\"duration\",\t\trequired_argument,\t0, 'd'},\n\t\t\t{\"house-keeping\",\trequired_argument,\t0, 'H'},\n\t\t\t{\"help\",\t\tno_argument,\t\t0, 'h'},\n\t\t\t{\"irq\",\t\t\trequired_argument,\t0, 'i'},\n\t\t\t{\"nano\",\t\tno_argument,\t\t0, 'n'},\n\t\t\t{\"period\",\t\trequired_argument,\t0, 'p'},\n\t\t\t{\"priority\",\t\trequired_argument,\t0, 'P'},\n\t\t\t{\"stack\",\t\trequired_argument,\t0, 's'},\n\t\t\t{\"thread\",\t\trequired_argument,\t0, 'T'},\n\t\t\t{\"trace\",\t\toptional_argument,\t0, 't'},\n\t\t\t{\"user-threads\",\tno_argument,\t\t0, 'u'},\n\t\t\t{\"event\",\t\trequired_argument,\t0, 'e'},\n\t\t\t{\"no-irq\",\t\tno_argument,\t\t0, '0'},\n\t\t\t{\"no-thread\",\t\tno_argument,\t\t0, '1'},\n\t\t\t{\"no-header\",\t\tno_argument,\t\t0, '2'},\n\t\t\t{\"no-summary\",\t\tno_argument,\t\t0, '3'},\n\t\t\t{\"no-index\",\t\tno_argument,\t\t0, '4'},\n\t\t\t{\"with-zeros\",\t\tno_argument,\t\t0, '5'},\n\t\t\t{\"trigger\",\t\trequired_argument,\t0, '6'},\n\t\t\t{\"filter\",\t\trequired_argument,\t0, '7'},\n\t\t\t{\"dma-latency\",\t\trequired_argument,\t0, '8'},\n\t\t\t{\"no-aa\",\t\tno_argument,\t\t0, '9'},\n\t\t\t{\"dump-task\",\t\tno_argument,\t\t0, '\\1'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n\n\t\t \n\t\tint option_index = 0;\n\n\t\tc = getopt_long(argc, argv, \"a:c:C::b:d:e:E:DhH:i:np:P:s:t::T:u0123456:7:8:9\\1\",\n\t\t\t\t long_options, &option_index);\n\n\t\t \n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tauto_thresh = get_llong_from_str(optarg);\n\n\t\t\t \n\t\t\tparams->stop_total_us = auto_thresh;\n\t\t\tparams->stop_us = auto_thresh;\n\n\t\t\t \n\t\t\tparams->print_stack = auto_thresh;\n\n\t\t\t \n\t\t\tparams->trace_output = \"timerlat_trace.txt\";\n\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tretval = parse_cpu_set(optarg, &params->monitored_cpus);\n\t\t\tif (retval)\n\t\t\t\ttimerlat_hist_usage(\"\\nInvalid -c cpu list\\n\");\n\t\t\tparams->cpus = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tparams->cgroup = 1;\n\t\t\tif (!optarg) {\n\t\t\t\t \n\t\t\t\tparams->cgroup_name = NULL;\n\t\t\t} else if (*optarg == '=') {\n\t\t\t\t \n\t\t\t\tparams->cgroup_name = ++optarg;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tparams->bucket_size = get_llong_from_str(optarg);\n\t\t\tif ((params->bucket_size == 0) || (params->bucket_size >= 1000000))\n\t\t\t\ttimerlat_hist_usage(\"Bucket size needs to be > 0 and <= 1000000\\n\");\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tconfig_debug = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tparams->duration = parse_seconds_duration(optarg);\n\t\t\tif (!params->duration)\n\t\t\t\ttimerlat_hist_usage(\"Invalid -D duration\\n\");\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\ttevent = trace_event_alloc(optarg);\n\t\t\tif (!tevent) {\n\t\t\t\terr_msg(\"Error alloc trace event\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\tif (params->events)\n\t\t\t\ttevent->next = params->events;\n\n\t\t\tparams->events = tevent;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tparams->entries = get_llong_from_str(optarg);\n\t\t\tif ((params->entries < 10) || (params->entries > 9999999))\n\t\t\t\t\ttimerlat_hist_usage(\"Entries must be > 10 and < 9999999\\n\");\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\ttimerlat_hist_usage(NULL);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tparams->hk_cpus = 1;\n\t\t\tretval = parse_cpu_set(optarg, &params->hk_cpu_set);\n\t\t\tif (retval) {\n\t\t\t\terr_msg(\"Error parsing house keeping CPUs\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tparams->stop_us = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tparams->output_divisor = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparams->timerlat_period_us = get_llong_from_str(optarg);\n\t\t\tif (params->timerlat_period_us > 1000000)\n\t\t\t\ttimerlat_hist_usage(\"Period longer than 1 s\\n\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tretval = parse_prio(optarg, &params->sched_param);\n\t\t\tif (retval == -1)\n\t\t\t\ttimerlat_hist_usage(\"Invalid -P priority\");\n\t\t\tparams->set_sched = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tparams->print_stack = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tparams->stop_total_us = get_llong_from_str(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (optarg)\n\t\t\t\t \n\t\t\t\tparams->trace_output = &optarg[1];\n\t\t\telse\n\t\t\t\tparams->trace_output = \"timerlat_trace.txt\";\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tparams->user_hist = 1;\n\t\t\tbreak;\n\t\tcase '0':  \n\t\t\tparams->no_irq = 1;\n\t\t\tbreak;\n\t\tcase '1':  \n\t\t\tparams->no_thread = 1;\n\t\t\tbreak;\n\t\tcase '2':  \n\t\t\tparams->no_header = 1;\n\t\t\tbreak;\n\t\tcase '3':  \n\t\t\tparams->no_summary = 1;\n\t\t\tbreak;\n\t\tcase '4':  \n\t\t\tparams->no_index = 1;\n\t\t\tbreak;\n\t\tcase '5':  \n\t\t\tparams->with_zeros = 1;\n\t\t\tbreak;\n\t\tcase '6':  \n\t\t\tif (params->events) {\n\t\t\t\tretval = trace_event_add_trigger(params->events, optarg);\n\t\t\t\tif (retval) {\n\t\t\t\t\terr_msg(\"Error adding trigger %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttimerlat_hist_usage(\"--trigger requires a previous -e\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '7':  \n\t\t\tif (params->events) {\n\t\t\t\tretval = trace_event_add_filter(params->events, optarg);\n\t\t\t\tif (retval) {\n\t\t\t\t\terr_msg(\"Error adding filter %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttimerlat_hist_usage(\"--filter requires a previous -e\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '8':\n\t\t\tparams->dma_latency = get_llong_from_str(optarg);\n\t\t\tif (params->dma_latency < 0 || params->dma_latency > 10000) {\n\t\t\t\terr_msg(\"--dma-latency needs to be >= 0 and < 10000\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '9':\n\t\t\tparams->no_aa = 1;\n\t\t\tbreak;\n\t\tcase '\\1':\n\t\t\tparams->dump_tasks = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttimerlat_hist_usage(\"Invalid option\");\n\t\t}\n\t}\n\n\tif (geteuid()) {\n\t\terr_msg(\"rtla needs root permission\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (params->no_irq && params->no_thread)\n\t\ttimerlat_hist_usage(\"no-irq and no-thread set, there is nothing to do here\");\n\n\tif (params->no_index && !params->with_zeros)\n\t\ttimerlat_hist_usage(\"no-index set with with-zeros is not set - it does not make sense\");\n\n\t \n\tif (!params->stop_us && !params->stop_total_us)\n\t\tparams->no_aa = 1;\n\n\treturn params;\n}\n\n \nstatic int\ntimerlat_hist_apply_config(struct osnoise_tool *tool, struct timerlat_hist_params *params)\n{\n\tint retval, i;\n\n\tif (!params->sleep_time)\n\t\tparams->sleep_time = 1;\n\n\tif (params->cpus) {\n\t\tretval = osnoise_set_cpus(tool->context, params->cpus);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to apply CPUs config\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < sysconf(_SC_NPROCESSORS_CONF); i++)\n\t\t\tCPU_SET(i, &params->monitored_cpus);\n\t}\n\n\tif (params->stop_us) {\n\t\tretval = osnoise_set_stop_us(tool->context, params->stop_us);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set stop us\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->stop_total_us) {\n\t\tretval = osnoise_set_stop_total_us(tool->context, params->stop_total_us);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set stop total us\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->timerlat_period_us) {\n\t\tretval = osnoise_set_timerlat_period_us(tool->context, params->timerlat_period_us);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set timerlat period\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->print_stack) {\n\t\tretval = osnoise_set_print_stack(tool->context, params->print_stack);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set print stack\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (params->hk_cpus) {\n\t\tretval = sched_setaffinity(getpid(), sizeof(params->hk_cpu_set),\n\t\t\t\t\t   &params->hk_cpu_set);\n\t\tif (retval == -1) {\n\t\t\terr_msg(\"Failed to set rtla to the house keeping CPUs\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (params->cpus) {\n\t\t \n\t\tauto_house_keeping(&params->monitored_cpus);\n\t}\n\n\tif (params->user_hist) {\n\t\tretval = osnoise_set_workload(tool->context, 0);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set OSNOISE_WORKLOAD option\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_err:\n\treturn -1;\n}\n\n \nstatic struct osnoise_tool\n*timerlat_init_hist(struct timerlat_hist_params *params)\n{\n\tstruct osnoise_tool *tool;\n\tint nr_cpus;\n\n\tnr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\n\ttool = osnoise_init_tool(\"timerlat_hist\");\n\tif (!tool)\n\t\treturn NULL;\n\n\ttool->data = timerlat_alloc_histogram(nr_cpus, params->entries, params->bucket_size);\n\tif (!tool->data)\n\t\tgoto out_err;\n\n\ttool->params = params;\n\n\ttep_register_event_handler(tool->trace.tep, -1, \"ftrace\", \"timerlat\",\n\t\t\t\t   timerlat_hist_handler, tool);\n\n\treturn tool;\n\nout_err:\n\tosnoise_destroy_tool(tool);\n\treturn NULL;\n}\n\nstatic int stop_tracing;\nstatic void stop_hist(int sig)\n{\n\tstop_tracing = 1;\n}\n\n \nstatic void\ntimerlat_hist_set_signals(struct timerlat_hist_params *params)\n{\n\tsignal(SIGINT, stop_hist);\n\tif (params->duration) {\n\t\tsignal(SIGALRM, stop_hist);\n\t\talarm(params->duration);\n\t}\n}\n\nint timerlat_hist_main(int argc, char *argv[])\n{\n\tstruct timerlat_hist_params *params;\n\tstruct osnoise_tool *record = NULL;\n\tstruct timerlat_u_params params_u;\n\tstruct osnoise_tool *tool = NULL;\n\tstruct osnoise_tool *aa = NULL;\n\tstruct trace_instance *trace;\n\tint dma_latency_fd = -1;\n\tint return_value = 1;\n\tpthread_t timerlat_u;\n\tint retval;\n\n\tparams = timerlat_hist_parse_args(argc, argv);\n\tif (!params)\n\t\texit(1);\n\n\ttool = timerlat_init_hist(params);\n\tif (!tool) {\n\t\terr_msg(\"Could not init osnoise hist\\n\");\n\t\tgoto out_exit;\n\t}\n\n\tretval = timerlat_hist_apply_config(tool, params);\n\tif (retval) {\n\t\terr_msg(\"Could not apply config\\n\");\n\t\tgoto out_free;\n\t}\n\n\ttrace = &tool->trace;\n\n\tretval = enable_timerlat(trace);\n\tif (retval) {\n\t\terr_msg(\"Failed to enable timerlat tracer\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (params->set_sched) {\n\t\tretval = set_comm_sched_attr(\"timerlat/\", &params->sched_param);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to set sched parameters\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (params->cgroup && !params->user_hist) {\n\t\tretval = set_comm_cgroup(\"timerlat/\", params->cgroup_name);\n\t\tif (!retval) {\n\t\t\terr_msg(\"Failed to move threads to cgroup\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (params->dma_latency >= 0) {\n\t\tdma_latency_fd = set_cpu_dma_latency(params->dma_latency);\n\t\tif (dma_latency_fd < 0) {\n\t\t\terr_msg(\"Could not set /dev/cpu_dma_latency.\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (params->trace_output) {\n\t\trecord = osnoise_init_trace_tool(\"timerlat\");\n\t\tif (!record) {\n\t\t\terr_msg(\"Failed to enable the trace instance\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (params->events) {\n\t\t\tretval = trace_events_enable(&record->trace, params->events);\n\t\t\tif (retval)\n\t\t\t\tgoto out_hist;\n\t\t}\n\t}\n\n\tif (!params->no_aa) {\n\t\taa = osnoise_init_tool(\"timerlat_aa\");\n\t\tif (!aa)\n\t\t\tgoto out_hist;\n\n\t\tretval = timerlat_aa_init(aa, params->dump_tasks);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to enable the auto analysis instance\\n\");\n\t\t\tgoto out_hist;\n\t\t}\n\n\t\tretval = enable_timerlat(&aa->trace);\n\t\tif (retval) {\n\t\t\terr_msg(\"Failed to enable timerlat tracer\\n\");\n\t\t\tgoto out_hist;\n\t\t}\n\t}\n\n\t \n\tif (params->trace_output)\n\t\ttrace_instance_start(&record->trace);\n\tif (!params->no_aa)\n\t\ttrace_instance_start(&aa->trace);\n\ttrace_instance_start(trace);\n\n\ttool->start_time = time(NULL);\n\ttimerlat_hist_set_signals(params);\n\n\tif (params->user_hist) {\n\t\t \n\t\tparams_u.should_run = 1;\n\t\t \n\t\tparams_u.stopped_running = 0;\n\n\t\tparams_u.set = &params->monitored_cpus;\n\t\tif (params->set_sched)\n\t\t\tparams_u.sched_param = &params->sched_param;\n\t\telse\n\t\t\tparams_u.sched_param = NULL;\n\n\t\tparams_u.cgroup_name = params->cgroup_name;\n\n\t\tretval = pthread_create(&timerlat_u, NULL, timerlat_u_dispatcher, &params_u);\n\t\tif (retval)\n\t\t\terr_msg(\"Error creating timerlat user-space threads\\n\");\n\t}\n\n\twhile (!stop_tracing) {\n\t\tsleep(params->sleep_time);\n\n\t\tretval = tracefs_iterate_raw_events(trace->tep,\n\t\t\t\t\t\t    trace->inst,\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    collect_registered_events,\n\t\t\t\t\t\t    trace);\n\t\tif (retval < 0) {\n\t\t\terr_msg(\"Error iterating on events\\n\");\n\t\t\tgoto out_hist;\n\t\t}\n\n\t\tif (trace_is_off(&tool->trace, &record->trace))\n\t\t\tbreak;\n\n\t\t \n\t\tif (params->user_hist) {\n\t\t\tif (params_u.stopped_running) {\n\t\t\t\tdebug_msg(\"timerlat user-space threads stopped!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (params->user_hist && !params_u.stopped_running) {\n\t\tparams_u.should_run = 0;\n\t\tsleep(1);\n\t}\n\n\ttimerlat_print_stats(params, tool);\n\n\treturn_value = 0;\n\n\tif (trace_is_off(&tool->trace, &record->trace)) {\n\t\tprintf(\"rtla timerlat hit stop tracing\\n\");\n\n\t\tif (!params->no_aa)\n\t\t\ttimerlat_auto_analysis(params->stop_us, params->stop_total_us);\n\n\t\tif (params->trace_output) {\n\t\t\tprintf(\"  Saving trace to %s\\n\", params->trace_output);\n\t\t\tsave_trace_to_file(record->trace.inst, params->trace_output);\n\t\t}\n\t}\n\nout_hist:\n\ttimerlat_aa_destroy();\n\tif (dma_latency_fd >= 0)\n\t\tclose(dma_latency_fd);\n\ttrace_events_destroy(&record->trace, params->events);\n\tparams->events = NULL;\nout_free:\n\ttimerlat_free_histogram(tool->data);\n\tosnoise_destroy_tool(aa);\n\tosnoise_destroy_tool(record);\n\tosnoise_destroy_tool(tool);\n\tfree(params);\nout_exit:\n\texit(return_value);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}