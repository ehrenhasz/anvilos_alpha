{
  "module_name": "timerlat_aa.c",
  "hash_id": "acb78e6a2d901546da8a999f8711e003aacd143155678bc14f88e3b18f566caa",
  "original_prompt": "Ingested from linux-6.6.14/tools/tracing/rtla/src/timerlat_aa.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include <errno.h>\n#include \"utils.h\"\n#include \"osnoise.h\"\n#include \"timerlat.h\"\n#include <unistd.h>\n\nenum timelat_state {\n\tTIMERLAT_INIT = 0,\n\tTIMERLAT_WAITING_IRQ,\n\tTIMERLAT_WAITING_THREAD,\n};\n\n#define MAX_COMM\t\t24\n\n \nstruct timerlat_aa_data {\n\t \n\tint\t\t\tcurr_state;\n\n\t \n\tunsigned long long\ttlat_irq_seqnum;\n\tunsigned long long\ttlat_irq_latency;\n\tunsigned long long\ttlat_irq_timstamp;\n\n\t \n\tunsigned long long\ttlat_thread_seqnum;\n\tunsigned long long\ttlat_thread_latency;\n\tunsigned long long\ttlat_thread_timstamp;\n\n\t \n\tunsigned long long\trun_thread_pid;\n\tchar\t\t\trun_thread_comm[MAX_COMM];\n\tunsigned long long\tthread_blocking_duration;\n\tunsigned long long\tmax_exit_idle_latency;\n\n\t \n\tunsigned long long\ttimer_irq_start_time;\n\tunsigned long long\ttimer_irq_start_delay;\n\tunsigned long long\ttimer_irq_duration;\n\tunsigned long long\ttimer_exit_from_idle;\n\n\t \n\tunsigned long long\tprev_irq_duration;\n\tunsigned long long\tprev_irq_timstamp;\n\n\t \n\tunsigned long long\tthread_nmi_sum;\n\tunsigned long long\tthread_irq_sum;\n\tunsigned long long\tthread_softirq_sum;\n\tunsigned long long\tthread_thread_sum;\n\n\t \n\tstruct trace_seq\t*prev_irqs_seq;\n\tstruct trace_seq\t*nmi_seq;\n\tstruct trace_seq\t*irqs_seq;\n\tstruct trace_seq\t*softirqs_seq;\n\tstruct trace_seq\t*threads_seq;\n\tstruct trace_seq\t*stack_seq;\n\n\t \n\tchar\t\t\tcurrent_comm[MAX_COMM];\n\tunsigned long long\tcurrent_pid;\n\n\t \n\tunsigned long long\tkworker;\n\tunsigned long long\tkworker_func;\n};\n\n \nstruct timerlat_aa_context {\n\tint nr_cpus;\n\tint dump_tasks;\n\n\t \n\tstruct timerlat_aa_data *taa_data;\n\n\t \n\tstruct osnoise_tool *tool;\n};\n\n \nstatic struct timerlat_aa_context *__timerlat_aa_ctx;\n\nstatic struct timerlat_aa_context *timerlat_aa_get_ctx(void)\n{\n\treturn __timerlat_aa_ctx;\n}\n\n \nstatic struct timerlat_aa_data\n*timerlat_aa_get_data(struct timerlat_aa_context *taa_ctx, int cpu)\n{\n\treturn &taa_ctx->taa_data[cpu];\n}\n\n \nstatic int timerlat_aa_irq_latency(struct timerlat_aa_data *taa_data,\n\t\t\t\t   struct trace_seq *s, struct tep_record *record,\n\t\t\t\t   struct tep_event *event)\n{\n\t \n\ttaa_data->curr_state = TIMERLAT_WAITING_THREAD;\n\ttaa_data->tlat_irq_timstamp = record->ts;\n\n\t \n\ttaa_data->thread_nmi_sum = 0;\n\ttaa_data->thread_irq_sum = 0;\n\ttaa_data->thread_softirq_sum = 0;\n\ttaa_data->thread_thread_sum = 0;\n\ttaa_data->thread_blocking_duration = 0;\n\ttaa_data->timer_irq_start_time = 0;\n\ttaa_data->timer_irq_duration = 0;\n\ttaa_data->timer_exit_from_idle = 0;\n\n\t \n\ttrace_seq_reset(taa_data->nmi_seq);\n\ttrace_seq_reset(taa_data->irqs_seq);\n\ttrace_seq_reset(taa_data->softirqs_seq);\n\ttrace_seq_reset(taa_data->threads_seq);\n\n\t \n\ttep_get_field_val(s, event, \"timer_latency\", record, &taa_data->tlat_irq_latency, 1);\n\ttep_get_field_val(s, event, \"seqnum\", record, &taa_data->tlat_irq_seqnum, 1);\n\n\t \n\ttep_get_common_field_val(s, event, \"common_pid\", record, &taa_data->run_thread_pid, 1);\n\n\t \n\tif (taa_data->run_thread_pid)\n\t\treturn 0;\n\n\t \n\tif (taa_data->tlat_irq_latency < taa_data->max_exit_idle_latency)\n\t\treturn 0;\n\n\t \n\tif (taa_data->tlat_irq_timstamp - taa_data->tlat_irq_latency\n\t    < taa_data->prev_irq_timstamp + taa_data->prev_irq_duration)\n\t\treturn 0;\n\n\ttaa_data->max_exit_idle_latency = taa_data->tlat_irq_latency;\n\n\treturn 0;\n}\n\n \nstatic int timerlat_aa_thread_latency(struct timerlat_aa_data *taa_data,\n\t\t\t\t      struct trace_seq *s, struct tep_record *record,\n\t\t\t\t      struct tep_event *event)\n{\n\t \n\ttaa_data->curr_state = TIMERLAT_WAITING_IRQ;\n\ttaa_data->tlat_thread_timstamp = record->ts;\n\n\t \n\ttep_get_field_val(s, event, \"timer_latency\", record, &taa_data->tlat_thread_latency, 1);\n\ttep_get_field_val(s, event, \"seqnum\", record, &taa_data->tlat_thread_seqnum, 1);\n\n\treturn 0;\n}\n\n \nstatic int timerlat_aa_handler(struct trace_seq *s, struct tep_record *record,\n\t\t\tstruct tep_event *event, void *context)\n{\n\tstruct timerlat_aa_context *taa_ctx = timerlat_aa_get_ctx();\n\tstruct timerlat_aa_data *taa_data = timerlat_aa_get_data(taa_ctx, record->cpu);\n\tunsigned long long thread;\n\n\tif (!taa_data)\n\t\treturn -1;\n\n\ttep_get_field_val(s, event, \"context\", record, &thread, 1);\n\tif (!thread)\n\t\treturn timerlat_aa_irq_latency(taa_data, s, record, event);\n\telse\n\t\treturn timerlat_aa_thread_latency(taa_data, s, record, event);\n}\n\n \nstatic int timerlat_aa_nmi_handler(struct trace_seq *s, struct tep_record *record,\n\t\t\t\t   struct tep_event *event, void *context)\n{\n\tstruct timerlat_aa_context *taa_ctx = timerlat_aa_get_ctx();\n\tstruct timerlat_aa_data *taa_data = timerlat_aa_get_data(taa_ctx, record->cpu);\n\tunsigned long long duration;\n\tunsigned long long start;\n\n\ttep_get_field_val(s, event, \"duration\", record, &duration, 1);\n\ttep_get_field_val(s, event, \"start\", record, &start, 1);\n\n\tif (taa_data->curr_state == TIMERLAT_WAITING_IRQ) {\n\t\ttaa_data->prev_irq_duration = duration;\n\t\ttaa_data->prev_irq_timstamp = start;\n\n\t\ttrace_seq_reset(taa_data->prev_irqs_seq);\n\t\ttrace_seq_printf(taa_data->prev_irqs_seq, \"\\t%24s\t\\t\\t\\t%9.2f us\\n\",\n\t\t\t \"nmi\", ns_to_usf(duration));\n\t\treturn 0;\n\t}\n\n\ttaa_data->thread_nmi_sum += duration;\n\ttrace_seq_printf(taa_data->nmi_seq, \"\t%24s\t\\t\\t\\t%9.2f us\\n\",\n\t\t \"nmi\", ns_to_usf(duration));\n\n\treturn 0;\n}\n\n \nstatic int timerlat_aa_irq_handler(struct trace_seq *s, struct tep_record *record,\n\t\t\t\t   struct tep_event *event, void *context)\n{\n\tstruct timerlat_aa_context *taa_ctx = timerlat_aa_get_ctx();\n\tstruct timerlat_aa_data *taa_data = timerlat_aa_get_data(taa_ctx, record->cpu);\n\tunsigned long long expected_start;\n\tunsigned long long duration;\n\tunsigned long long vector;\n\tunsigned long long start;\n\tchar *desc;\n\tint val;\n\n\ttep_get_field_val(s, event, \"duration\", record, &duration, 1);\n\ttep_get_field_val(s, event, \"start\", record, &start, 1);\n\ttep_get_field_val(s, event, \"vector\", record, &vector, 1);\n\tdesc = tep_get_field_raw(s, event, \"desc\", record, &val, 1);\n\n\t \n\tif (taa_data->curr_state == TIMERLAT_WAITING_IRQ) {\n\t\ttaa_data->prev_irq_duration = duration;\n\t\ttaa_data->prev_irq_timstamp = start;\n\n\t\ttrace_seq_reset(taa_data->prev_irqs_seq);\n\t\ttrace_seq_printf(taa_data->prev_irqs_seq, \"\\t%24s:%-3llu\t\\t\\t%9.2f us\\n\",\n\t\t\t\t desc, vector, ns_to_usf(duration));\n\t\treturn 0;\n\t}\n\n\t \n\tif (!taa_data->timer_irq_start_time) {\n\t\texpected_start = taa_data->tlat_irq_timstamp - taa_data->tlat_irq_latency;\n\n\t\ttaa_data->timer_irq_start_time = start;\n\t\ttaa_data->timer_irq_duration = duration;\n\n\t\t \n\t\tif (expected_start < taa_data->timer_irq_start_time)\n\t\t\ttaa_data->timer_irq_start_delay = taa_data->timer_irq_start_time - expected_start;\n\t\telse\n\t\t\ttaa_data->timer_irq_start_delay = 0;\n\n\t\t \n\t\tif (taa_data->run_thread_pid)\n\t\t\treturn 0;\n\n\t\tif (expected_start > taa_data->prev_irq_timstamp + taa_data->prev_irq_duration)\n\t\t\ttaa_data->timer_exit_from_idle = taa_data->timer_irq_start_delay;\n\n\t\treturn 0;\n\t}\n\n\t \n\ttaa_data->thread_irq_sum += duration;\n\ttrace_seq_printf(taa_data->irqs_seq, \"\t%24s:%-3llu\t\\t\t%9.2f us\\n\",\n\t\t\t desc, vector, ns_to_usf(duration));\n\n\treturn 0;\n}\n\nstatic char *softirq_name[] = { \"HI\", \"TIMER\",\t\"NET_TX\", \"NET_RX\", \"BLOCK\",\n\t\t\t\t\"IRQ_POLL\", \"TASKLET\", \"SCHED\", \"HRTIMER\", \"RCU\" };\n\n\n \nstatic int timerlat_aa_softirq_handler(struct trace_seq *s, struct tep_record *record,\n\t\t\t\t       struct tep_event *event, void *context)\n{\n\tstruct timerlat_aa_context *taa_ctx = timerlat_aa_get_ctx();\n\tstruct timerlat_aa_data *taa_data = timerlat_aa_get_data(taa_ctx, record->cpu);\n\tunsigned long long duration;\n\tunsigned long long vector;\n\tunsigned long long start;\n\n\tif (taa_data->curr_state == TIMERLAT_WAITING_IRQ)\n\t\treturn 0;\n\n\ttep_get_field_val(s, event, \"duration\", record, &duration, 1);\n\ttep_get_field_val(s, event, \"start\", record, &start, 1);\n\ttep_get_field_val(s, event, \"vector\", record, &vector, 1);\n\n\ttaa_data->thread_softirq_sum += duration;\n\n\ttrace_seq_printf(taa_data->softirqs_seq, \"\\t%24s:%-3llu\t\\t\t%9.2f us\\n\",\n\t\t\t softirq_name[vector], vector, ns_to_usf(duration));\n\treturn 0;\n}\n\n \nstatic int timerlat_aa_thread_handler(struct trace_seq *s, struct tep_record *record,\n\t\t\t\t      struct tep_event *event, void *context)\n{\n\tstruct timerlat_aa_context *taa_ctx = timerlat_aa_get_ctx();\n\tstruct timerlat_aa_data *taa_data = timerlat_aa_get_data(taa_ctx, record->cpu);\n\tunsigned long long duration;\n\tunsigned long long start;\n\tunsigned long long pid;\n\tconst char *comm;\n\tint val;\n\n\tif (taa_data->curr_state == TIMERLAT_WAITING_IRQ)\n\t\treturn 0;\n\n\ttep_get_field_val(s, event, \"duration\", record, &duration, 1);\n\ttep_get_field_val(s, event, \"start\", record, &start, 1);\n\n\ttep_get_common_field_val(s, event, \"common_pid\", record, &pid, 1);\n\tcomm = tep_get_field_raw(s, event, \"comm\", record, &val, 1);\n\n\tif (pid == taa_data->run_thread_pid && !taa_data->thread_blocking_duration) {\n\t\ttaa_data->thread_blocking_duration = duration;\n\n\t\tif (comm)\n\t\t\tstrncpy(taa_data->run_thread_comm, comm, MAX_COMM);\n\t\telse\n\t\t\tsprintf(taa_data->run_thread_comm, \"<...>\");\n\n\t} else {\n\t\ttaa_data->thread_thread_sum += duration;\n\n\t\ttrace_seq_printf(taa_data->threads_seq, \"\\t%24s:%-3llu\t\\t\\t%9.2f us\\n\",\n\t\t\t comm, pid, ns_to_usf(duration));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int timerlat_aa_stack_handler(struct trace_seq *s, struct tep_record *record,\n\t\t\t      struct tep_event *event, void *context)\n{\n\tstruct timerlat_aa_context *taa_ctx = timerlat_aa_get_ctx();\n\tstruct timerlat_aa_data *taa_data = timerlat_aa_get_data(taa_ctx, record->cpu);\n\tunsigned long *caller;\n\tconst char *function;\n\tint val, i;\n\n\ttrace_seq_reset(taa_data->stack_seq);\n\n\ttrace_seq_printf(taa_data->stack_seq, \"    Blocking thread stack trace\\n\");\n\tcaller = tep_get_field_raw(s, event, \"caller\", record, &val, 1);\n\tif (caller) {\n\t\tfor (i = 0; ; i++) {\n\t\t\tfunction = tep_find_function(taa_ctx->tool->trace.tep, caller[i]);\n\t\t\tif (!function)\n\t\t\t\tbreak;\n\t\t\ttrace_seq_printf(taa_data->stack_seq, \"\\t\\t-> %s\\n\", function);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int timerlat_aa_sched_switch_handler(struct trace_seq *s, struct tep_record *record,\n\t\t\t\t\t    struct tep_event *event, void *context)\n{\n\tstruct timerlat_aa_context *taa_ctx = timerlat_aa_get_ctx();\n\tstruct timerlat_aa_data *taa_data = timerlat_aa_get_data(taa_ctx, record->cpu);\n\tconst char *comm;\n\tint val;\n\n\ttep_get_field_val(s, event, \"next_pid\", record, &taa_data->current_pid, 1);\n\tcomm = tep_get_field_raw(s, event, \"next_comm\", record, &val, 1);\n\n\tstrncpy(taa_data->current_comm, comm, MAX_COMM);\n\n\t \n\ttaa_data->kworker = 0;\n\ttaa_data->kworker_func = 0;\n\n\treturn 0;\n}\n\n \nstatic int timerlat_aa_kworker_start_handler(struct trace_seq *s, struct tep_record *record,\n\t\t\t\t\t     struct tep_event *event, void *context)\n{\n\tstruct timerlat_aa_context *taa_ctx = timerlat_aa_get_ctx();\n\tstruct timerlat_aa_data *taa_data = timerlat_aa_get_data(taa_ctx, record->cpu);\n\n\ttep_get_field_val(s, event, \"work\", record, &taa_data->kworker, 1);\n\ttep_get_field_val(s, event, \"function\", record, &taa_data->kworker_func, 1);\n\treturn 0;\n}\n\n \nstatic void timerlat_thread_analysis(struct timerlat_aa_data *taa_data, int cpu,\n\t\t\t\t     int irq_thresh, int thread_thresh)\n{\n\tlong long exp_irq_ts;\n\tint total;\n\tint irq;\n\n\t \n\tif (taa_data->tlat_irq_seqnum > taa_data->tlat_thread_seqnum) {\n\t\tirq = 1;\n\t\ttotal = taa_data->tlat_irq_latency;\n\t} else {\n\t\tirq = 0;\n\t\ttotal = taa_data->tlat_thread_latency;\n\t}\n\n\t \n\texp_irq_ts = taa_data->timer_irq_start_time - taa_data->timer_irq_start_delay;\n\tif (exp_irq_ts < taa_data->prev_irq_timstamp + taa_data->prev_irq_duration) {\n\t\tif (taa_data->prev_irq_timstamp < taa_data->timer_irq_start_time)\n\t\t\tprintf(\"  Previous IRQ interference:\t\\t\\t up to  %9.2f us\\n\",\n\t\t\t\tns_to_usf(taa_data->prev_irq_duration));\n\t}\n\n\t \n\tprintf(\"  IRQ handler delay:\t\t%16s\t%9.2f us (%.2f %%)\\n\",\n\t\t(ns_to_usf(taa_data->timer_exit_from_idle) > 10) ? \"(exit from idle)\" : \"\",\n\t\tns_to_usf(taa_data->timer_irq_start_delay),\n\t\tns_to_per(total, taa_data->timer_irq_start_delay));\n\n\t \n\tprintf(\"  IRQ latency:\t\\t\\t\\t\\t\t%9.2f us\\n\",\n\t\tns_to_usf(taa_data->tlat_irq_latency));\n\n\tif (irq) {\n\t\t \n\t\tprintf(\"  Blocking thread:\\n\");\n\t\tprintf(\"\t%24s:%-9llu\\n\",\n\t\t\ttaa_data->run_thread_comm, taa_data->run_thread_pid);\n\t} else  {\n\t\t \n\t\tprintf(\"  Timerlat IRQ duration:\t\\t\\t\t%9.2f us (%.2f %%)\\n\",\n\t\t\tns_to_usf(taa_data->timer_irq_duration),\n\t\t\tns_to_per(total, taa_data->timer_irq_duration));\n\n\t\t \n\t\tprintf(\"  Blocking thread:\t\\t\\t\\t\t%9.2f us (%.2f %%)\\n\",\n\t\t\tns_to_usf(taa_data->thread_blocking_duration),\n\t\t\tns_to_per(total, taa_data->thread_blocking_duration));\n\n\t\tprintf(\"\t%24s:%-9llu\t\t%9.2f us\\n\",\n\t\t\ttaa_data->run_thread_comm, taa_data->run_thread_pid,\n\t\t\tns_to_usf(taa_data->thread_blocking_duration));\n\t}\n\n\t \n\ttrace_seq_do_printf(taa_data->stack_seq);\n\n\t \n\tif (taa_data->thread_nmi_sum)\n\t\tprintf(\"  NMI interference\t\\t\\t\\t\t%9.2f us (%.2f %%)\\n\",\n\t\t\tns_to_usf(taa_data->thread_nmi_sum),\n\t\t\tns_to_per(total, taa_data->thread_nmi_sum));\n\n\t \n\tif (irq)\n\t\tgoto print_total;\n\n\t \n\tif (taa_data->thread_irq_sum) {\n\t\tprintf(\"  IRQ interference\t\\t\\t\\t\t%9.2f us (%.2f %%)\\n\",\n\t\t\tns_to_usf(taa_data->thread_irq_sum),\n\t\t\tns_to_per(total, taa_data->thread_irq_sum));\n\n\t\ttrace_seq_do_printf(taa_data->irqs_seq);\n\t}\n\n\t \n\tif (taa_data->thread_softirq_sum) {\n\t\tprintf(\"  Softirq interference\t\\t\\t\\t\t%9.2f us (%.2f %%)\\n\",\n\t\t\tns_to_usf(taa_data->thread_softirq_sum),\n\t\t\tns_to_per(total, taa_data->thread_softirq_sum));\n\n\t\ttrace_seq_do_printf(taa_data->softirqs_seq);\n\t}\n\n\t \n\tif (taa_data->thread_thread_sum) {\n\t\tprintf(\"  Thread interference\t\\t\\t\\t\t%9.2f us (%.2f %%)\\n\",\n\t\t\tns_to_usf(taa_data->thread_thread_sum),\n\t\t\tns_to_per(total, taa_data->thread_thread_sum));\n\n\t\ttrace_seq_do_printf(taa_data->threads_seq);\n\t}\n\n\t \nprint_total:\n\tprintf(\"------------------------------------------------------------------------\\n\");\n\tprintf(\"  %s latency:\t\\t\\t\\t\t%9.2f us (100%%)\\n\", irq ? \"IRQ\" : \"Thread\",\n\t\tns_to_usf(total));\n}\n\nstatic int timerlat_auto_analysis_collect_trace(struct timerlat_aa_context *taa_ctx)\n{\n\tstruct trace_instance *trace = &taa_ctx->tool->trace;\n\tint retval;\n\n\tretval = tracefs_iterate_raw_events(trace->tep,\n\t\t\t\t\t    trace->inst,\n\t\t\t\t\t    NULL,\n\t\t\t\t\t    0,\n\t\t\t\t\t    collect_registered_events,\n\t\t\t\t\t    trace);\n\t\tif (retval < 0) {\n\t\t\terr_msg(\"Error iterating on events\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\treturn 1;\n}\n\n \nvoid timerlat_auto_analysis(int irq_thresh, int thread_thresh)\n{\n\tstruct timerlat_aa_context *taa_ctx = timerlat_aa_get_ctx();\n\tunsigned long long max_exit_from_idle = 0;\n\tstruct timerlat_aa_data *taa_data;\n\tint max_exit_from_idle_cpu;\n\tstruct tep_handle *tep;\n\tint cpu;\n\n\ttimerlat_auto_analysis_collect_trace(taa_ctx);\n\n\t \n\tirq_thresh = irq_thresh * 1000;\n\tthread_thresh = thread_thresh * 1000;\n\n\tfor (cpu = 0; cpu < taa_ctx->nr_cpus; cpu++) {\n\t\ttaa_data = timerlat_aa_get_data(taa_ctx, cpu);\n\n\t\tif (irq_thresh && taa_data->tlat_irq_latency >= irq_thresh) {\n\t\t\tprintf(\"## CPU %d hit stop tracing, analyzing it ##\\n\", cpu);\n\t\t\ttimerlat_thread_analysis(taa_data, cpu, irq_thresh, thread_thresh);\n\t\t} else if (thread_thresh && (taa_data->tlat_thread_latency) >= thread_thresh) {\n\t\t\tprintf(\"## CPU %d hit stop tracing, analyzing it ##\\n\", cpu);\n\t\t\ttimerlat_thread_analysis(taa_data, cpu, irq_thresh, thread_thresh);\n\t\t}\n\n\t\tif (taa_data->max_exit_idle_latency > max_exit_from_idle) {\n\t\t\tmax_exit_from_idle = taa_data->max_exit_idle_latency;\n\t\t\tmax_exit_from_idle_cpu = cpu;\n\t\t}\n\n\t}\n\n\tif (max_exit_from_idle) {\n\t\tprintf(\"\\n\");\n\t\tprintf(\"Max timerlat IRQ latency from idle: %.2f us in cpu %d\\n\",\n\t\t\tns_to_usf(max_exit_from_idle), max_exit_from_idle_cpu);\n\t}\n\tif (!taa_ctx->dump_tasks)\n\t\treturn;\n\n\tprintf(\"\\n\");\n\tprintf(\"Printing CPU tasks:\\n\");\n\tfor (cpu = 0; cpu < taa_ctx->nr_cpus; cpu++) {\n\t\ttaa_data = timerlat_aa_get_data(taa_ctx, cpu);\n\t\ttep = taa_ctx->tool->trace.tep;\n\n\t\tprintf(\"    [%.3d] %24s:%llu\", cpu, taa_data->current_comm, taa_data->current_pid);\n\n\t\tif (taa_data->kworker_func)\n\t\t\tprintf(\" kworker:%s:%s\",\n\t\t\t\ttep_find_function(tep, taa_data->kworker) ? : \"<...>\",\n\t\t\t\ttep_find_function(tep, taa_data->kworker_func));\n\t\tprintf(\"\\n\");\n\t}\n\n}\n\n \nstatic void timerlat_aa_destroy_seqs(struct timerlat_aa_context *taa_ctx)\n{\n\tstruct timerlat_aa_data *taa_data;\n\tint i;\n\n\tif (!taa_ctx->taa_data)\n\t\treturn;\n\n\tfor (i = 0; i < taa_ctx->nr_cpus; i++) {\n\t\ttaa_data = timerlat_aa_get_data(taa_ctx, i);\n\n\t\tif (taa_data->prev_irqs_seq) {\n\t\t\ttrace_seq_destroy(taa_data->prev_irqs_seq);\n\t\t\tfree(taa_data->prev_irqs_seq);\n\t\t}\n\n\t\tif (taa_data->nmi_seq) {\n\t\t\ttrace_seq_destroy(taa_data->nmi_seq);\n\t\t\tfree(taa_data->nmi_seq);\n\t\t}\n\n\t\tif (taa_data->irqs_seq) {\n\t\t\ttrace_seq_destroy(taa_data->irqs_seq);\n\t\t\tfree(taa_data->irqs_seq);\n\t\t}\n\n\t\tif (taa_data->softirqs_seq) {\n\t\t\ttrace_seq_destroy(taa_data->softirqs_seq);\n\t\t\tfree(taa_data->softirqs_seq);\n\t\t}\n\n\t\tif (taa_data->threads_seq) {\n\t\t\ttrace_seq_destroy(taa_data->threads_seq);\n\t\t\tfree(taa_data->threads_seq);\n\t\t}\n\n\t\tif (taa_data->stack_seq) {\n\t\t\ttrace_seq_destroy(taa_data->stack_seq);\n\t\t\tfree(taa_data->stack_seq);\n\t\t}\n\t}\n}\n\n \nstatic int timerlat_aa_init_seqs(struct timerlat_aa_context *taa_ctx)\n{\n\tstruct timerlat_aa_data *taa_data;\n\tint i;\n\n\tfor (i = 0; i < taa_ctx->nr_cpus; i++) {\n\n\t\ttaa_data = timerlat_aa_get_data(taa_ctx, i);\n\n\t\ttaa_data->prev_irqs_seq = calloc(1, sizeof(*taa_data->prev_irqs_seq));\n\t\tif (!taa_data->prev_irqs_seq)\n\t\t\tgoto out_err;\n\n\t\ttrace_seq_init(taa_data->prev_irqs_seq);\n\n\t\ttaa_data->nmi_seq = calloc(1, sizeof(*taa_data->nmi_seq));\n\t\tif (!taa_data->nmi_seq)\n\t\t\tgoto out_err;\n\n\t\ttrace_seq_init(taa_data->nmi_seq);\n\n\t\ttaa_data->irqs_seq = calloc(1, sizeof(*taa_data->irqs_seq));\n\t\tif (!taa_data->irqs_seq)\n\t\t\tgoto out_err;\n\n\t\ttrace_seq_init(taa_data->irqs_seq);\n\n\t\ttaa_data->softirqs_seq = calloc(1, sizeof(*taa_data->softirqs_seq));\n\t\tif (!taa_data->softirqs_seq)\n\t\t\tgoto out_err;\n\n\t\ttrace_seq_init(taa_data->softirqs_seq);\n\n\t\ttaa_data->threads_seq = calloc(1, sizeof(*taa_data->threads_seq));\n\t\tif (!taa_data->threads_seq)\n\t\t\tgoto out_err;\n\n\t\ttrace_seq_init(taa_data->threads_seq);\n\n\t\ttaa_data->stack_seq = calloc(1, sizeof(*taa_data->stack_seq));\n\t\tif (!taa_data->stack_seq)\n\t\t\tgoto out_err;\n\n\t\ttrace_seq_init(taa_data->stack_seq);\n\t}\n\n\treturn 0;\n\nout_err:\n\ttimerlat_aa_destroy_seqs(taa_ctx);\n\treturn -1;\n}\n\n \nstatic void timerlat_aa_unregister_events(struct osnoise_tool *tool, int dump_tasks)\n{\n\n\ttep_unregister_event_handler(tool->trace.tep, -1, \"ftrace\", \"timerlat\",\n\t\t\t\t     timerlat_aa_handler, tool);\n\n\ttracefs_event_disable(tool->trace.inst, \"osnoise\", NULL);\n\n\ttep_unregister_event_handler(tool->trace.tep, -1, \"osnoise\", \"nmi_noise\",\n\t\t\t\t     timerlat_aa_nmi_handler, tool);\n\n\ttep_unregister_event_handler(tool->trace.tep, -1, \"osnoise\", \"irq_noise\",\n\t\t\t\t     timerlat_aa_irq_handler, tool);\n\n\ttep_unregister_event_handler(tool->trace.tep, -1, \"osnoise\", \"softirq_noise\",\n\t\t\t\t     timerlat_aa_softirq_handler, tool);\n\n\ttep_unregister_event_handler(tool->trace.tep, -1, \"osnoise\", \"thread_noise\",\n\t\t\t\t     timerlat_aa_thread_handler, tool);\n\n\ttep_unregister_event_handler(tool->trace.tep, -1, \"ftrace\", \"kernel_stack\",\n\t\t\t\t     timerlat_aa_stack_handler, tool);\n\tif (!dump_tasks)\n\t\treturn;\n\n\ttracefs_event_disable(tool->trace.inst, \"sched\", \"sched_switch\");\n\ttep_unregister_event_handler(tool->trace.tep, -1, \"sched\", \"sched_switch\",\n\t\t\t\t     timerlat_aa_sched_switch_handler, tool);\n\n\ttracefs_event_disable(tool->trace.inst, \"workqueue\", \"workqueue_execute_start\");\n\ttep_unregister_event_handler(tool->trace.tep, -1, \"workqueue\", \"workqueue_execute_start\",\n\t\t\t\t     timerlat_aa_kworker_start_handler, tool);\n}\n\n \nstatic int timerlat_aa_register_events(struct osnoise_tool *tool, int dump_tasks)\n{\n\tint retval;\n\n\ttep_register_event_handler(tool->trace.tep, -1, \"ftrace\", \"timerlat\",\n\t\t\t\ttimerlat_aa_handler, tool);\n\n\n\t \n\tretval = tracefs_event_enable(tool->trace.inst, \"osnoise\", NULL);\n\tif (retval < 0 && !errno) {\n\t\terr_msg(\"Could not find osnoise events\\n\");\n\t\tgoto out_err;\n\t}\n\n\ttep_register_event_handler(tool->trace.tep, -1, \"osnoise\", \"nmi_noise\",\n\t\t\t\t   timerlat_aa_nmi_handler, tool);\n\n\ttep_register_event_handler(tool->trace.tep, -1, \"osnoise\", \"irq_noise\",\n\t\t\t\t   timerlat_aa_irq_handler, tool);\n\n\ttep_register_event_handler(tool->trace.tep, -1, \"osnoise\", \"softirq_noise\",\n\t\t\t\t   timerlat_aa_softirq_handler, tool);\n\n\ttep_register_event_handler(tool->trace.tep, -1, \"osnoise\", \"thread_noise\",\n\t\t\t\t   timerlat_aa_thread_handler, tool);\n\n\ttep_register_event_handler(tool->trace.tep, -1, \"ftrace\", \"kernel_stack\",\n\t\t\t\t   timerlat_aa_stack_handler, tool);\n\n\tif (!dump_tasks)\n\t\treturn 0;\n\n\t \n\tretval = tracefs_event_enable(tool->trace.inst, \"sched\", \"sched_switch\");\n\tif (retval < 0 && !errno) {\n\t\terr_msg(\"Could not find sched_switch\\n\");\n\t\tgoto out_err;\n\t}\n\n\ttep_register_event_handler(tool->trace.tep, -1, \"sched\", \"sched_switch\",\n\t\t\t\t   timerlat_aa_sched_switch_handler, tool);\n\n\tretval = tracefs_event_enable(tool->trace.inst, \"workqueue\", \"workqueue_execute_start\");\n\tif (retval < 0 && !errno) {\n\t\terr_msg(\"Could not find workqueue_execute_start\\n\");\n\t\tgoto out_err;\n\t}\n\n\ttep_register_event_handler(tool->trace.tep, -1, \"workqueue\", \"workqueue_execute_start\",\n\t\t\t\t   timerlat_aa_kworker_start_handler, tool);\n\n\treturn 0;\n\nout_err:\n\ttimerlat_aa_unregister_events(tool, dump_tasks);\n\treturn -1;\n}\n\n \nvoid timerlat_aa_destroy(void)\n{\n\tstruct timerlat_aa_context *taa_ctx = timerlat_aa_get_ctx();\n\n\tif (!taa_ctx)\n\t\treturn;\n\n\tif (!taa_ctx->taa_data)\n\t\tgoto out_ctx;\n\n\ttimerlat_aa_unregister_events(taa_ctx->tool, taa_ctx->dump_tasks);\n\ttimerlat_aa_destroy_seqs(taa_ctx);\n\tfree(taa_ctx->taa_data);\nout_ctx:\n\tfree(taa_ctx);\n}\n\n \nint timerlat_aa_init(struct osnoise_tool *tool, int dump_tasks)\n{\n\tint nr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\tstruct timerlat_aa_context *taa_ctx;\n\tint retval;\n\n\ttaa_ctx = calloc(1, sizeof(*taa_ctx));\n\tif (!taa_ctx)\n\t\treturn -1;\n\n\t__timerlat_aa_ctx = taa_ctx;\n\n\ttaa_ctx->nr_cpus = nr_cpus;\n\ttaa_ctx->tool = tool;\n\ttaa_ctx->dump_tasks = dump_tasks;\n\n\ttaa_ctx->taa_data = calloc(nr_cpus, sizeof(*taa_ctx->taa_data));\n\tif (!taa_ctx->taa_data)\n\t\tgoto out_err;\n\n\tretval = timerlat_aa_init_seqs(taa_ctx);\n\tif (retval)\n\t\tgoto out_err;\n\n\tretval = timerlat_aa_register_events(tool, dump_tasks);\n\tif (retval)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\ttimerlat_aa_destroy();\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}