{
  "module_name": "ihex2fw.c",
  "hash_id": "3d862f5a63b2e8981507a8e5be4b201b0abc133500551eb6a07a3312bdd947f8",
  "original_prompt": "Ingested from linux-6.6.14/tools/firmware/ihex2fw.c",
  "human_readable_source": "\n \n\n#include <stdint.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#define _GNU_SOURCE\n#include <getopt.h>\n\n\n#define __ALIGN_KERNEL_MASK(x, mask)\t(((x) + (mask)) & ~(mask))\n#define __ALIGN_KERNEL(x, a)\t\t__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)\n#define ALIGN(x, a)\t\t\t__ALIGN_KERNEL((x), (a))\n\nstruct ihex_binrec {\n\tstruct ihex_binrec *next;  \n        uint32_t addr;\n        uint16_t len;\n        uint8_t data[];\n};\n\n \nstatic uint8_t nybble(const uint8_t n)\n{\n\tif      (n >= '0' && n <= '9') return n - '0';\n\telse if (n >= 'A' && n <= 'F') return n - ('A' - 10);\n\telse if (n >= 'a' && n <= 'f') return n - ('a' - 10);\n\treturn 0;\n}\n\nstatic uint8_t hex(const uint8_t *data, uint8_t *crc)\n{\n\tuint8_t val = (nybble(data[0]) << 4) | nybble(data[1]);\n\t*crc += val;\n\treturn val;\n}\n\nstatic int process_ihex(uint8_t *data, ssize_t size);\nstatic void file_record(struct ihex_binrec *record);\nstatic int output_records(int outfd);\n\nstatic int sort_records = 0;\nstatic int wide_records = 0;\nstatic int include_jump = 0;\n\nstatic int usage(void)\n{\n\tfprintf(stderr, \"ihex2fw: Convert ihex files into binary \"\n\t\t\"representation for use by Linux kernel\\n\");\n\tfprintf(stderr, \"usage: ihex2fw [<options>] <src.HEX> <dst.fw>\\n\");\n\tfprintf(stderr, \"       -w: wide records (16-bit length)\\n\");\n\tfprintf(stderr, \"       -s: sort records by address\\n\");\n\tfprintf(stderr, \"       -j: include records for CS:IP/EIP address\\n\");\n\treturn 1;\n}\n\nint main(int argc, char **argv)\n{\n\tint infd, outfd;\n\tstruct stat st;\n\tuint8_t *data;\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"wsj\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'w':\n\t\t\twide_records = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsort_records = 1;\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tinclude_jump = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn usage();\n\t\t}\n\t}\n\n\tif (optind + 2 != argc)\n\t\treturn usage();\n\n\tif (!strcmp(argv[optind], \"-\"))\n\t\tinfd = 0;\n\telse\n\t\tinfd = open(argv[optind], O_RDONLY);\n\tif (infd == -1) {\n\t\tfprintf(stderr, \"Failed to open source file: %s\",\n\t\t\tstrerror(errno));\n\t\treturn usage();\n\t}\n\tif (fstat(infd, &st)) {\n\t\tperror(\"stat\");\n\t\treturn 1;\n\t}\n\tdata = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED, infd, 0);\n\tif (data == MAP_FAILED) {\n\t\tperror(\"mmap\");\n\t\treturn 1;\n\t}\n\n\tif (!strcmp(argv[optind+1], \"-\"))\n\t\toutfd = 1;\n\telse\n\t\toutfd = open(argv[optind+1], O_TRUNC|O_CREAT|O_WRONLY, 0644);\n\tif (outfd == -1) {\n\t\tfprintf(stderr, \"Failed to open destination file: %s\",\n\t\t\tstrerror(errno));\n\t\treturn usage();\n\t}\n\tif (process_ihex(data, st.st_size))\n\t\treturn 1;\n\n\treturn output_records(outfd);\n}\n\nstatic int process_ihex(uint8_t *data, ssize_t size)\n{\n\tstruct ihex_binrec *record;\n\tsize_t record_size;\n\tuint32_t offset = 0;\n\tuint32_t data32;\n\tuint8_t type, crc = 0, crcbyte = 0;\n\tint i, j;\n\tint line = 1;\n\tint len;\n\n\ti = 0;\nnext_record:\n\t \n\twhile (i < size) {\n\t\tif (data[i] == '\\n') line++;\n\t\tif (data[i++] == ':') break;\n\t}\n\n\t \n\tif (i + 10 > size) {\n\t\tfprintf(stderr, \"Can't find valid record at line %d\\n\", line);\n\t\treturn -EINVAL;\n\t}\n\n\tlen = hex(data + i, &crc); i += 2;\n\tif (wide_records) {\n\t\tlen <<= 8;\n\t\tlen += hex(data + i, &crc); i += 2;\n\t}\n\trecord_size = ALIGN(sizeof(*record) + len, 4);\n\trecord = malloc(record_size);\n\tif (!record) {\n\t\tfprintf(stderr, \"out of memory for records\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(record, 0, record_size);\n\trecord->len = len;\n\n\t \n\tif (i + 8 + (record->len * 2) > size) {\n\t\tfprintf(stderr, \"Not enough data to read complete record at line %d\\n\",\n\t\t\tline);\n\t\treturn -EINVAL;\n\t}\n\n\trecord->addr  = hex(data + i, &crc) << 8; i += 2;\n\trecord->addr |= hex(data + i, &crc); i += 2;\n\ttype = hex(data + i, &crc); i += 2;\n\n\tfor (j = 0; j < record->len; j++, i += 2)\n\t\trecord->data[j] = hex(data + i, &crc);\n\n\t \n\tcrcbyte = hex(data + i, &crc); i += 2;\n\tif (crc != 0) {\n\t\tfprintf(stderr, \"CRC failure at line %d: got 0x%X, expected 0x%X\\n\",\n\t\t\tline, crcbyte, (unsigned char)(crcbyte-crc));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (type) {\n\tcase 0:\n\t\t \n\t\tif (!record->len)\n\t\t\tbreak;\n\n\t\trecord->addr += offset;\n\t\tfile_record(record);\n\t\tgoto next_record;\n\n\tcase 1:  \n\t\tif (record->addr || record->len) {\n\t\t\tfprintf(stderr, \"Bad EOF record (type 01) format at line %d\",\n\t\t\t\tline);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase 2:  \n\tcase 4:  \n\t\tif (record->addr || record->len != 2) {\n\t\t\tfprintf(stderr, \"Bad HEX86/HEX386 record (type %02X) at line %d\\n\",\n\t\t\t\ttype, line);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\toffset = record->data[0] << 8 | record->data[1];\n\t\toffset <<= (type == 2 ? 4 : 16);\n\t\tgoto next_record;\n\n\tcase 3:  \n\tcase 5:  \n\t\tif (record->addr || record->len != 4) {\n\t\t\tfprintf(stderr, \"Bad Start Address record (type %02X) at line %d\\n\",\n\t\t\t\ttype, line);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(&data32, &record->data[0], sizeof(data32));\n\t\tdata32 = htonl(data32);\n\t\tmemcpy(&record->data[0], &data32, sizeof(data32));\n\n\t\t \n\t\tif (include_jump)\n\t\t\tfile_record(record);\n\t\tgoto next_record;\n\n\tdefault:\n\t\tfprintf(stderr, \"Unknown record (type %02X)\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ihex_binrec *records;\n\nstatic void file_record(struct ihex_binrec *record)\n{\n\tstruct ihex_binrec **p = &records;\n\n\twhile ((*p) && (!sort_records || (*p)->addr < record->addr))\n\t\tp = &((*p)->next);\n\n\trecord->next = *p;\n\t*p = record;\n}\n\nstatic uint16_t ihex_binrec_size(struct ihex_binrec *p)\n{\n\treturn p->len + sizeof(p->addr) + sizeof(p->len);\n}\n\nstatic int output_records(int outfd)\n{\n\tunsigned char zeroes[6] = {0, 0, 0, 0, 0, 0};\n\tstruct ihex_binrec *p = records;\n\n\twhile (p) {\n\t\tuint16_t writelen = ALIGN(ihex_binrec_size(p), 4);\n\n\t\tp->addr = htonl(p->addr);\n\t\tp->len = htons(p->len);\n\t\tif (write(outfd, &p->addr, writelen) != writelen)\n\t\t\treturn 1;\n\t\tp = p->next;\n\t}\n\t \n\tif (write(outfd, zeroes, 6) != 6)\n\t\treturn 1;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}