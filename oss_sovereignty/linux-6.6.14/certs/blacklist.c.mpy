{
  "module_name": "blacklist.c",
  "hash_id": "ecf711514d9a0abe365a69d844909ea6fc9943dd2c1100043a172aafb141e0cf",
  "original_prompt": "Ingested from linux-6.6.14/certs/blacklist.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"blacklist: \"fmt\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/key.h>\n#include <linux/key-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/uidgid.h>\n#include <keys/asymmetric-type.h>\n#include <keys/system_keyring.h>\n#include \"blacklist.h\"\n\n \n#define MAX_HASH_LEN\t128\n\n#define BLACKLIST_KEY_PERM (KEY_POS_SEARCH | KEY_POS_VIEW | \\\n\t\t\t    KEY_USR_SEARCH | KEY_USR_VIEW)\n\nstatic const char tbs_prefix[] = \"tbs\";\nstatic const char bin_prefix[] = \"bin\";\n\nstatic struct key *blacklist_keyring;\n\n#ifdef CONFIG_SYSTEM_REVOCATION_LIST\nextern __initconst const u8 revocation_certificate_list[];\nextern __initconst const unsigned long revocation_certificate_list_size;\n#endif\n\n \nstatic int blacklist_vet_description(const char *desc)\n{\n\tint i, prefix_len, tbs_step = 0, bin_step = 0;\n\n\t \n\tBUILD_BUG_ON(sizeof(tbs_prefix) != sizeof(bin_prefix));\n\tprefix_len = sizeof(tbs_prefix) - 1;\n\tfor (i = 0; *desc; desc++, i++) {\n\t\tif (*desc == ':') {\n\t\t\tif (tbs_step == prefix_len)\n\t\t\t\tgoto found_colon;\n\t\t\tif (bin_step == prefix_len)\n\t\t\t\tgoto found_colon;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (i >= prefix_len)\n\t\t\treturn -EINVAL;\n\t\tif (*desc == tbs_prefix[i])\n\t\t\ttbs_step++;\n\t\tif (*desc == bin_prefix[i])\n\t\t\tbin_step++;\n\t}\n\treturn -EINVAL;\n\nfound_colon:\n\tdesc++;\n\tfor (i = 0; *desc && i < MAX_HASH_LEN; desc++, i++) {\n\t\tif (!isxdigit(*desc) || isupper(*desc))\n\t\t\treturn -EINVAL;\n\t}\n\tif (*desc)\n\t\t \n\t\treturn -ENOPKG;\n\n\t \n\tif (i == 0 || i & 1)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int blacklist_key_instantiate(struct key *key,\n\t\tstruct key_preparsed_payload *prep)\n{\n#ifdef CONFIG_SYSTEM_BLACKLIST_AUTH_UPDATE\n\tint err;\n#endif\n\n\t \n\tkey->perm = BLACKLIST_KEY_PERM;\n\n\t \n\tif (key->flags & (1 << KEY_FLAG_BUILTIN))\n\t\tgoto out;\n\n#ifdef CONFIG_SYSTEM_BLACKLIST_AUTH_UPDATE\n\t \n\terr = verify_pkcs7_signature(key->description,\n\t\t\tstrlen(key->description), prep->data, prep->datalen,\n\t\t\tNULL, VERIFYING_UNSPECIFIED_SIGNATURE, NULL, NULL);\n\tif (err)\n\t\treturn err;\n#else\n\t \n\tWARN_ON_ONCE(1);\n\treturn -EPERM;\n#endif\n\nout:\n\treturn generic_key_instantiate(key, prep);\n}\n\nstatic int blacklist_key_update(struct key *key,\n\t\tstruct key_preparsed_payload *prep)\n{\n\treturn -EPERM;\n}\n\nstatic void blacklist_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n}\n\nstatic struct key_type key_type_blacklist = {\n\t.name\t\t\t= \"blacklist\",\n\t.vet_description\t= blacklist_vet_description,\n\t.instantiate\t\t= blacklist_key_instantiate,\n\t.update\t\t\t= blacklist_key_update,\n\t.describe\t\t= blacklist_describe,\n};\n\nstatic char *get_raw_hash(const u8 *hash, size_t hash_len,\n\t\tenum blacklist_hash_type hash_type)\n{\n\tsize_t type_len;\n\tconst char *type_prefix;\n\tchar *buffer, *p;\n\n\tswitch (hash_type) {\n\tcase BLACKLIST_HASH_X509_TBS:\n\t\ttype_len = sizeof(tbs_prefix) - 1;\n\t\ttype_prefix = tbs_prefix;\n\t\tbreak;\n\tcase BLACKLIST_HASH_BINARY:\n\t\ttype_len = sizeof(bin_prefix) - 1;\n\t\ttype_prefix = bin_prefix;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tbuffer = kmalloc(type_len + 1 + hash_len * 2 + 1, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn ERR_PTR(-ENOMEM);\n\tp = memcpy(buffer, type_prefix, type_len);\n\tp += type_len;\n\t*p++ = ':';\n\tbin2hex(p, hash, hash_len);\n\tp += hash_len * 2;\n\t*p = '\\0';\n\treturn buffer;\n}\n\n \nstatic int mark_raw_hash_blacklisted(const char *hash)\n{\n\tkey_ref_t key;\n\n\tkey = key_create(make_key_ref(blacklist_keyring, true),\n\t\t\t \"blacklist\",\n\t\t\t hash,\n\t\t\t NULL,\n\t\t\t 0,\n\t\t\t BLACKLIST_KEY_PERM,\n\t\t\t KEY_ALLOC_NOT_IN_QUOTA |\n\t\t\t KEY_ALLOC_BUILT_IN);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) == -EEXIST)\n\t\t\tpr_warn(\"Duplicate blacklisted hash %s\\n\", hash);\n\t\telse\n\t\t\tpr_err(\"Problem blacklisting hash %s: %pe\\n\", hash, key);\n\t\treturn PTR_ERR(key);\n\t}\n\treturn 0;\n}\n\nint mark_hash_blacklisted(const u8 *hash, size_t hash_len,\n\t\tenum blacklist_hash_type hash_type)\n{\n\tconst char *buffer;\n\tint err;\n\n\tbuffer = get_raw_hash(hash, hash_len, hash_type);\n\tif (IS_ERR(buffer))\n\t\treturn PTR_ERR(buffer);\n\terr = mark_raw_hash_blacklisted(buffer);\n\tkfree(buffer);\n\treturn err;\n}\n\n \nint is_hash_blacklisted(const u8 *hash, size_t hash_len,\n\t\tenum blacklist_hash_type hash_type)\n{\n\tkey_ref_t kref;\n\tconst char *buffer;\n\tint ret = 0;\n\n\tbuffer = get_raw_hash(hash, hash_len, hash_type);\n\tif (IS_ERR(buffer))\n\t\treturn PTR_ERR(buffer);\n\tkref = keyring_search(make_key_ref(blacklist_keyring, true),\n\t\t\t      &key_type_blacklist, buffer, false);\n\tif (!IS_ERR(kref)) {\n\t\tkey_ref_put(kref);\n\t\tret = -EKEYREJECTED;\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(is_hash_blacklisted);\n\nint is_binary_blacklisted(const u8 *hash, size_t hash_len)\n{\n\tif (is_hash_blacklisted(hash, hash_len, BLACKLIST_HASH_BINARY) ==\n\t\t\t-EKEYREJECTED)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(is_binary_blacklisted);\n\n#ifdef CONFIG_SYSTEM_REVOCATION_LIST\n \nint add_key_to_revocation_list(const char *data, size_t size)\n{\n\tkey_ref_t key;\n\n\tkey = key_create_or_update(make_key_ref(blacklist_keyring, true),\n\t\t\t\t   \"asymmetric\",\n\t\t\t\t   NULL,\n\t\t\t\t   data,\n\t\t\t\t   size,\n\t\t\t\t   KEY_POS_VIEW | KEY_POS_READ | KEY_POS_SEARCH\n\t\t\t\t   | KEY_USR_VIEW,\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA | KEY_ALLOC_BUILT_IN\n\t\t\t\t   | KEY_ALLOC_BYPASS_RESTRICTION);\n\n\tif (IS_ERR(key)) {\n\t\tpr_err(\"Problem with revocation key (%ld)\\n\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\treturn 0;\n}\n\n \nint is_key_on_revocation_list(struct pkcs7_message *pkcs7)\n{\n\tint ret;\n\n\tret = pkcs7_validate_trust(pkcs7, blacklist_keyring);\n\n\tif (ret == 0)\n\t\treturn -EKEYREJECTED;\n\n\treturn -ENOKEY;\n}\n#endif\n\nstatic int restrict_link_for_blacklist(struct key *dest_keyring,\n\t\tconst struct key_type *type, const union key_payload *payload,\n\t\tstruct key *restrict_key)\n{\n\tif (type == &key_type_blacklist)\n\t\treturn 0;\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int __init blacklist_init(void)\n{\n\tconst char *const *bl;\n\tstruct key_restriction *restriction;\n\n\tif (register_key_type(&key_type_blacklist) < 0)\n\t\tpanic(\"Can't allocate system blacklist key type\\n\");\n\n\trestriction = kzalloc(sizeof(*restriction), GFP_KERNEL);\n\tif (!restriction)\n\t\tpanic(\"Can't allocate blacklist keyring restriction\\n\");\n\trestriction->check = restrict_link_for_blacklist;\n\n\tblacklist_keyring =\n\t\tkeyring_alloc(\".blacklist\",\n\t\t\t      GLOBAL_ROOT_UID, GLOBAL_ROOT_GID, current_cred(),\n\t\t\t      KEY_POS_VIEW | KEY_POS_READ | KEY_POS_SEARCH |\n\t\t\t      KEY_POS_WRITE |\n\t\t\t      KEY_USR_VIEW | KEY_USR_READ | KEY_USR_SEARCH\n#ifdef CONFIG_SYSTEM_BLACKLIST_AUTH_UPDATE\n\t\t\t      | KEY_USR_WRITE\n#endif\n\t\t\t      , KEY_ALLOC_NOT_IN_QUOTA |\n\t\t\t      KEY_ALLOC_SET_KEEP,\n\t\t\t      restriction, NULL);\n\tif (IS_ERR(blacklist_keyring))\n\t\tpanic(\"Can't allocate system blacklist keyring\\n\");\n\n\tfor (bl = blacklist_hashes; *bl; bl++)\n\t\tif (mark_raw_hash_blacklisted(*bl) < 0)\n\t\t\tpr_err(\"- blacklisting failed\\n\");\n\treturn 0;\n}\n\n \ndevice_initcall(blacklist_init);\n\n#ifdef CONFIG_SYSTEM_REVOCATION_LIST\n \nstatic __init int load_revocation_certificate_list(void)\n{\n\tif (revocation_certificate_list_size)\n\t\tpr_notice(\"Loading compiled-in revocation X.509 certificates\\n\");\n\n\treturn x509_load_certificate_list(revocation_certificate_list,\n\t\t\t\t\t  revocation_certificate_list_size,\n\t\t\t\t\t  blacklist_keyring);\n}\nlate_initcall(load_revocation_certificate_list);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}