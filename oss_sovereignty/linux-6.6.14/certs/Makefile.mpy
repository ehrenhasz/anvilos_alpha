{
  "module_name": "Makefile",
  "hash_id": "62594f6f19cde20d46563869b5c20bc6c6bcb782fae6b9a0e04e6fa2c5ffcd5f",
  "original_prompt": "Ingested from linux-6.6.14/certs/Makefile",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Makefile for the linux kernel signature checking certificates.\n#\n\nobj-$(CONFIG_SYSTEM_TRUSTED_KEYRING) += system_keyring.o system_certificates.o\nobj-$(CONFIG_SYSTEM_BLACKLIST_KEYRING) += blacklist.o blacklist_hashes.o\nobj-$(CONFIG_SYSTEM_REVOCATION_LIST) += revocation_certificates.o\n\n$(obj)/blacklist_hashes.o: $(obj)/blacklist_hash_list\nCFLAGS_blacklist_hashes.o := -I $(obj)\n\nquiet_cmd_check_and_copy_blacklist_hash_list = GEN     $@\n      cmd_check_and_copy_blacklist_hash_list = \\\n\t$(if $(CONFIG_SYSTEM_BLACKLIST_HASH_LIST), \\\n\t$(AWK) -f $(srctree)/$(src)/check-blacklist-hashes.awk $(CONFIG_SYSTEM_BLACKLIST_HASH_LIST) >&2; \\\n\t{ cat $(CONFIG_SYSTEM_BLACKLIST_HASH_LIST); echo $(comma) NULL; } > $@, \\\n\techo NULL > $@)\n\n$(obj)/blacklist_hash_list: $(CONFIG_SYSTEM_BLACKLIST_HASH_LIST) FORCE\n\t$(call if_changed,check_and_copy_blacklist_hash_list)\n\ntargets += blacklist_hash_list\n\nquiet_cmd_extract_certs  = CERT    $@\n      cmd_extract_certs  = $(obj)/extract-cert \"$(extract-cert-in)\" $@\nextract-cert-in = $(filter-out $(obj)/extract-cert, $(real-prereqs))\n\n$(obj)/system_certificates.o: $(obj)/x509_certificate_list\n\n$(obj)/x509_certificate_list: $(CONFIG_SYSTEM_TRUSTED_KEYS) $(obj)/extract-cert FORCE\n\t$(call if_changed,extract_certs)\n\ntargets += x509_certificate_list\n\n# If module signing is requested, say by allyesconfig, but a key has not been\n# supplied, then one will need to be generated to make sure the build does not\n# fail and that the kernel may be used afterwards.\n#\n# We do it this way rather than having a boolean option for enabling an\n# external private key, because 'make randconfig' might enable such a\n# boolean option and we unfortunately can't make it depend on !RANDCONFIG.\nifeq ($(CONFIG_MODULE_SIG_KEY),certs/signing_key.pem)\n\nkeytype-$(CONFIG_MODULE_SIG_KEY_TYPE_ECDSA) := -newkey ec -pkeyopt ec_paramgen_curve:secp384r1\n\nquiet_cmd_gen_key = GENKEY  $@\n      cmd_gen_key = openssl req -new -nodes -utf8 -$(CONFIG_MODULE_SIG_HASH) -days 36500 \\\n\t\t-batch -x509 -config $< \\\n\t\t-outform PEM -out $@ -keyout $@ $(keytype-y) 2>&1\n\n$(obj)/signing_key.pem: $(obj)/x509.genkey FORCE\n\t$(call if_changed,gen_key)\n\ntargets += signing_key.pem\n\nquiet_cmd_copy_x509_config = COPY    $@\n      cmd_copy_x509_config = cat $(srctree)/$(src)/default_x509.genkey > $@\n\n# You can provide your own config file. If not present, copy the default one.\n$(obj)/x509.genkey:\n\t$(call cmd,copy_x509_config)\n\nendif # CONFIG_MODULE_SIG_KEY\n\n$(obj)/system_certificates.o: $(obj)/signing_key.x509\n\nPKCS11_URI := $(filter pkcs11:%, $(CONFIG_MODULE_SIG_KEY))\nifdef PKCS11_URI\n$(obj)/signing_key.x509: extract-cert-in := $(PKCS11_URI)\nendif\n\n$(obj)/signing_key.x509: $(filter-out $(PKCS11_URI),$(CONFIG_MODULE_SIG_KEY)) $(obj)/extract-cert FORCE\n\t$(call if_changed,extract_certs)\n\ntargets += signing_key.x509\n\n$(obj)/revocation_certificates.o: $(obj)/x509_revocation_list\n\n$(obj)/x509_revocation_list: $(CONFIG_SYSTEM_REVOCATION_KEYS) $(obj)/extract-cert FORCE\n\t$(call if_changed,extract_certs)\n\ntargets += x509_revocation_list\n\nhostprogs := extract-cert\n\nHOSTCFLAGS_extract-cert.o = $(shell $(HOSTPKG_CONFIG) --cflags libcrypto 2> /dev/null)\nHOSTLDLIBS_extract-cert = $(shell $(HOSTPKG_CONFIG) --libs libcrypto 2> /dev/null || echo -lcrypto)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}