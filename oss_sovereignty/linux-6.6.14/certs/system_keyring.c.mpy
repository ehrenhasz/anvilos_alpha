{
  "module_name": "system_keyring.c",
  "hash_id": "ae3286467afabc3936f275e40c626c8b4ccbecc9de19984250c6d6112cc073dd",
  "original_prompt": "Ingested from linux-6.6.14/certs/system_keyring.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/uidgid.h>\n#include <linux/verification.h>\n#include <keys/asymmetric-type.h>\n#include <keys/system_keyring.h>\n#include <crypto/pkcs7.h>\n\nstatic struct key *builtin_trusted_keys;\n#ifdef CONFIG_SECONDARY_TRUSTED_KEYRING\nstatic struct key *secondary_trusted_keys;\n#endif\n#ifdef CONFIG_INTEGRITY_MACHINE_KEYRING\nstatic struct key *machine_trusted_keys;\n#endif\n#ifdef CONFIG_INTEGRITY_PLATFORM_KEYRING\nstatic struct key *platform_trusted_keys;\n#endif\n\nextern __initconst const u8 system_certificate_list[];\nextern __initconst const unsigned long system_certificate_list_size;\nextern __initconst const unsigned long module_cert_size;\n\n \nint restrict_link_by_builtin_trusted(struct key *dest_keyring,\n\t\t\t\t     const struct key_type *type,\n\t\t\t\t     const union key_payload *payload,\n\t\t\t\t     struct key *restriction_key)\n{\n\treturn restrict_link_by_signature(dest_keyring, type, payload,\n\t\t\t\t\t  builtin_trusted_keys);\n}\n\n \nint restrict_link_by_digsig_builtin(struct key *dest_keyring,\n\t\t\t\t    const struct key_type *type,\n\t\t\t\t    const union key_payload *payload,\n\t\t\t\t    struct key *restriction_key)\n{\n\treturn restrict_link_by_digsig(dest_keyring, type, payload,\n\t\t\t\t       builtin_trusted_keys);\n}\n\n#ifdef CONFIG_SECONDARY_TRUSTED_KEYRING\n \nint restrict_link_by_builtin_and_secondary_trusted(\n\tstruct key *dest_keyring,\n\tconst struct key_type *type,\n\tconst union key_payload *payload,\n\tstruct key *restrict_key)\n{\n\t \n\tif (type == &key_type_keyring &&\n\t    dest_keyring == secondary_trusted_keys &&\n\t    payload == &builtin_trusted_keys->payload)\n\t\t \n\t\treturn 0;\n\n\treturn restrict_link_by_signature(dest_keyring, type, payload,\n\t\t\t\t\t  secondary_trusted_keys);\n}\n\n \nint restrict_link_by_digsig_builtin_and_secondary(struct key *dest_keyring,\n\t\t\t\t\t\t  const struct key_type *type,\n\t\t\t\t\t\t  const union key_payload *payload,\n\t\t\t\t\t\t  struct key *restrict_key)\n{\n\t \n\tif (type == &key_type_keyring &&\n\t    dest_keyring == secondary_trusted_keys &&\n\t    payload == &builtin_trusted_keys->payload)\n\t\t \n\t\treturn 0;\n\n\treturn restrict_link_by_digsig(dest_keyring, type, payload,\n\t\t\t\t       secondary_trusted_keys);\n}\n\n \nstatic __init struct key_restriction *get_builtin_and_secondary_restriction(void)\n{\n\tstruct key_restriction *restriction;\n\n\trestriction = kzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\n\tif (!restriction)\n\t\tpanic(\"Can't allocate secondary trusted keyring restriction\\n\");\n\n\tif (IS_ENABLED(CONFIG_INTEGRITY_MACHINE_KEYRING))\n\t\trestriction->check = restrict_link_by_builtin_secondary_and_machine;\n\telse\n\t\trestriction->check = restrict_link_by_builtin_and_secondary_trusted;\n\n\treturn restriction;\n}\n\n \nvoid __init add_to_secondary_keyring(const char *source, const void *data, size_t len)\n{\n\tkey_ref_t key;\n\tkey_perm_t perm;\n\n\tperm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_VIEW;\n\n\tkey = key_create_or_update(make_key_ref(secondary_trusted_keys, 1),\n\t\t\t\t   \"asymmetric\",\n\t\t\t\t   NULL, data, len, perm,\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\tpr_err(\"Problem loading X.509 certificate from %s to secondary keyring %ld\\n\",\n\t\t       source, PTR_ERR(key));\n\t\treturn;\n\t}\n\n\tpr_notice(\"Loaded X.509 cert '%s'\\n\", key_ref_to_ptr(key)->description);\n\tkey_ref_put(key);\n}\n#endif\n#ifdef CONFIG_INTEGRITY_MACHINE_KEYRING\nvoid __init set_machine_trusted_keys(struct key *keyring)\n{\n\tmachine_trusted_keys = keyring;\n\n\tif (key_link(secondary_trusted_keys, machine_trusted_keys) < 0)\n\t\tpanic(\"Can't link (machine) trusted keyrings\\n\");\n}\n\n \nint restrict_link_by_builtin_secondary_and_machine(\n\tstruct key *dest_keyring,\n\tconst struct key_type *type,\n\tconst union key_payload *payload,\n\tstruct key *restrict_key)\n{\n\tif (machine_trusted_keys && type == &key_type_keyring &&\n\t    dest_keyring == secondary_trusted_keys &&\n\t    payload == &machine_trusted_keys->payload)\n\t\t \n\t\treturn 0;\n\n\treturn restrict_link_by_builtin_and_secondary_trusted(dest_keyring, type,\n\t\t\t\t\t\t\t      payload, restrict_key);\n}\n#endif\n\n \nstatic __init int system_trusted_keyring_init(void)\n{\n\tpr_notice(\"Initialise system trusted keyrings\\n\");\n\n\tbuiltin_trusted_keys =\n\t\tkeyring_alloc(\".builtin_trusted_keys\",\n\t\t\t      GLOBAL_ROOT_UID, GLOBAL_ROOT_GID, current_cred(),\n\t\t\t      ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t      KEY_USR_VIEW | KEY_USR_READ | KEY_USR_SEARCH),\n\t\t\t      KEY_ALLOC_NOT_IN_QUOTA,\n\t\t\t      NULL, NULL);\n\tif (IS_ERR(builtin_trusted_keys))\n\t\tpanic(\"Can't allocate builtin trusted keyring\\n\");\n\n#ifdef CONFIG_SECONDARY_TRUSTED_KEYRING\n\tsecondary_trusted_keys =\n\t\tkeyring_alloc(\".secondary_trusted_keys\",\n\t\t\t      GLOBAL_ROOT_UID, GLOBAL_ROOT_GID, current_cred(),\n\t\t\t      ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t       KEY_USR_VIEW | KEY_USR_READ | KEY_USR_SEARCH |\n\t\t\t       KEY_USR_WRITE),\n\t\t\t      KEY_ALLOC_NOT_IN_QUOTA,\n\t\t\t      get_builtin_and_secondary_restriction(),\n\t\t\t      NULL);\n\tif (IS_ERR(secondary_trusted_keys))\n\t\tpanic(\"Can't allocate secondary trusted keyring\\n\");\n\n\tif (key_link(secondary_trusted_keys, builtin_trusted_keys) < 0)\n\t\tpanic(\"Can't link trusted keyrings\\n\");\n#endif\n\n\treturn 0;\n}\n\n \ndevice_initcall(system_trusted_keyring_init);\n\n__init int load_module_cert(struct key *keyring)\n{\n\tif (!IS_ENABLED(CONFIG_IMA_APPRAISE_MODSIG))\n\t\treturn 0;\n\n\tpr_notice(\"Loading compiled-in module X.509 certificates\\n\");\n\n\treturn x509_load_certificate_list(system_certificate_list,\n\t\t\t\t\t  module_cert_size, keyring);\n}\n\n \nstatic __init int load_system_certificate_list(void)\n{\n\tconst u8 *p;\n\tunsigned long size;\n\n\tpr_notice(\"Loading compiled-in X.509 certificates\\n\");\n\n#ifdef CONFIG_MODULE_SIG\n\tp = system_certificate_list;\n\tsize = system_certificate_list_size;\n#else\n\tp = system_certificate_list + module_cert_size;\n\tsize = system_certificate_list_size - module_cert_size;\n#endif\n\n\treturn x509_load_certificate_list(p, size, builtin_trusted_keys);\n}\nlate_initcall(load_system_certificate_list);\n\n#ifdef CONFIG_SYSTEM_DATA_VERIFICATION\n\n \nint verify_pkcs7_message_sig(const void *data, size_t len,\n\t\t\t     struct pkcs7_message *pkcs7,\n\t\t\t     struct key *trusted_keys,\n\t\t\t     enum key_being_used_for usage,\n\t\t\t     int (*view_content)(void *ctx,\n\t\t\t\t\t\t const void *data, size_t len,\n\t\t\t\t\t\t size_t asn1hdrlen),\n\t\t\t     void *ctx)\n{\n\tint ret;\n\n\t \n\tif (data && pkcs7_supply_detached_data(pkcs7, data, len) < 0) {\n\t\tpr_err(\"PKCS#7 signature with non-detached data\\n\");\n\t\tret = -EBADMSG;\n\t\tgoto error;\n\t}\n\n\tret = pkcs7_verify(pkcs7, usage);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = is_key_on_revocation_list(pkcs7);\n\tif (ret != -ENOKEY) {\n\t\tpr_devel(\"PKCS#7 key is on revocation list\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!trusted_keys) {\n\t\ttrusted_keys = builtin_trusted_keys;\n\t} else if (trusted_keys == VERIFY_USE_SECONDARY_KEYRING) {\n#ifdef CONFIG_SECONDARY_TRUSTED_KEYRING\n\t\ttrusted_keys = secondary_trusted_keys;\n#else\n\t\ttrusted_keys = builtin_trusted_keys;\n#endif\n\t} else if (trusted_keys == VERIFY_USE_PLATFORM_KEYRING) {\n#ifdef CONFIG_INTEGRITY_PLATFORM_KEYRING\n\t\ttrusted_keys = platform_trusted_keys;\n#else\n\t\ttrusted_keys = NULL;\n#endif\n\t\tif (!trusted_keys) {\n\t\t\tret = -ENOKEY;\n\t\t\tpr_devel(\"PKCS#7 platform keyring is not available\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = pkcs7_validate_trust(pkcs7, trusted_keys);\n\tif (ret < 0) {\n\t\tif (ret == -ENOKEY)\n\t\t\tpr_devel(\"PKCS#7 signature not signed with a trusted key\\n\");\n\t\tgoto error;\n\t}\n\n\tif (view_content) {\n\t\tsize_t asn1hdrlen;\n\n\t\tret = pkcs7_get_content_data(pkcs7, &data, &len, &asn1hdrlen);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tpr_devel(\"PKCS#7 message does not contain data\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = view_content(ctx, data, len, asn1hdrlen);\n\t}\n\nerror:\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nint verify_pkcs7_signature(const void *data, size_t len,\n\t\t\t   const void *raw_pkcs7, size_t pkcs7_len,\n\t\t\t   struct key *trusted_keys,\n\t\t\t   enum key_being_used_for usage,\n\t\t\t   int (*view_content)(void *ctx,\n\t\t\t\t\t       const void *data, size_t len,\n\t\t\t\t\t       size_t asn1hdrlen),\n\t\t\t   void *ctx)\n{\n\tstruct pkcs7_message *pkcs7;\n\tint ret;\n\n\tpkcs7 = pkcs7_parse_message(raw_pkcs7, pkcs7_len);\n\tif (IS_ERR(pkcs7))\n\t\treturn PTR_ERR(pkcs7);\n\n\tret = verify_pkcs7_message_sig(data, len, pkcs7, trusted_keys, usage,\n\t\t\t\t       view_content, ctx);\n\n\tpkcs7_free_message(pkcs7);\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(verify_pkcs7_signature);\n\n#endif  \n\n#ifdef CONFIG_INTEGRITY_PLATFORM_KEYRING\nvoid __init set_platform_trusted_keys(struct key *keyring)\n{\n\tplatform_trusted_keys = keyring;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}