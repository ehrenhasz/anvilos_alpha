{
  "module_name": "processor.h",
  "hash_id": "73109dd2b16cd08fc3717e690e960f00d95802083f9e64ebee1f112b7341eb96",
  "original_prompt": "Ingested from linux-6.6.14/include/acpi/processor.h",
  "human_readable_source": " \n#ifndef __ACPI_PROCESSOR_H\n#define __ACPI_PROCESSOR_H\n\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/pm_qos.h>\n#include <linux/printk.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/thermal.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include <asm/acpi.h>\n\n#define ACPI_PROCESSOR_CLASS\t\t\"processor\"\n#define ACPI_PROCESSOR_DEVICE_NAME\t\"Processor\"\n#define ACPI_PROCESSOR_DEVICE_HID\t\"ACPI0007\"\n#define ACPI_PROCESSOR_CONTAINER_HID\t\"ACPI0010\"\n\n#define ACPI_PROCESSOR_BUSY_METRIC\t10\n\n#define ACPI_PROCESSOR_MAX_POWER\t8\n#define ACPI_PROCESSOR_MAX_C2_LATENCY\t100\n#define ACPI_PROCESSOR_MAX_C3_LATENCY\t1000\n\n#define ACPI_PROCESSOR_MAX_THROTTLING\t16\n#define ACPI_PROCESSOR_MAX_THROTTLE\t250\t \n#define ACPI_PROCESSOR_MAX_DUTY_WIDTH\t4\n\n#define ACPI_PDC_REVISION_ID\t\t0x1\n\n#define ACPI_PSD_REV0_REVISION\t\t0\t \n#define ACPI_PSD_REV0_ENTRIES\t\t5\n\n#define ACPI_TSD_REV0_REVISION\t\t0\t \n#define ACPI_TSD_REV0_ENTRIES\t\t5\n \n#define DOMAIN_COORD_TYPE_SW_ALL\t0xfc\n#define DOMAIN_COORD_TYPE_SW_ANY\t0xfd\n#define DOMAIN_COORD_TYPE_HW_ALL\t0xfe\n\n#define ACPI_CSTATE_SYSTEMIO\t0\n#define ACPI_CSTATE_FFH\t\t1\n#define ACPI_CSTATE_HALT\t2\n#define ACPI_CSTATE_INTEGER\t3\n\n#define ACPI_CX_DESC_LEN\t32\n\n \n\nstruct acpi_processor_cx;\n\nstruct acpi_power_register {\n\tu8 descriptor;\n\tu16 length;\n\tu8 space_id;\n\tu8 bit_width;\n\tu8 bit_offset;\n\tu8 access_size;\n\tu64 address;\n} __packed;\n\nstruct acpi_processor_cx {\n\tu8 valid;\n\tu8 type;\n\tu32 address;\n\tu8 entry_method;\n\tu8 index;\n\tu32 latency;\n\tu8 bm_sts_skip;\n\tchar desc[ACPI_CX_DESC_LEN];\n};\n\nstruct acpi_lpi_state {\n\tu32 min_residency;\n\tu32 wake_latency;  \n\tu32 flags;\n\tu32 arch_flags;\n\tu32 res_cnt_freq;\n\tu32 enable_parent_state;\n\tu64 address;\n\tu8 index;\n\tu8 entry_method;\n\tchar desc[ACPI_CX_DESC_LEN];\n};\n\nstruct acpi_processor_power {\n\tint count;\n\tunion {\n\t\tstruct acpi_processor_cx states[ACPI_PROCESSOR_MAX_POWER];\n\t\tstruct acpi_lpi_state lpi_states[ACPI_PROCESSOR_MAX_POWER];\n\t};\n\tint timer_broadcast_on_state;\n};\n\n \n\nstruct acpi_psd_package {\n\tu64 num_entries;\n\tu64 revision;\n\tu64 domain;\n\tu64 coord_type;\n\tu64 num_processors;\n} __packed;\n\nstruct acpi_pct_register {\n\tu8 descriptor;\n\tu16 length;\n\tu8 space_id;\n\tu8 bit_width;\n\tu8 bit_offset;\n\tu8 reserved;\n\tu64 address;\n} __packed;\n\nstruct acpi_processor_px {\n\tu64 core_frequency;\t \n\tu64 power;\t \n\tu64 transition_latency;\t \n\tu64 bus_master_latency;\t \n\tu64 control;\t \n\tu64 status;\t \n};\n\nstruct acpi_processor_performance {\n\tunsigned int state;\n\tunsigned int platform_limit;\n\tstruct acpi_pct_register control_register;\n\tstruct acpi_pct_register status_register;\n\tunsigned int state_count;\n\tstruct acpi_processor_px *states;\n\tstruct acpi_psd_package domain_info;\n\tcpumask_var_t shared_cpu_map;\n\tunsigned int shared_type;\n};\n\n \n\nstruct acpi_tsd_package {\n\tu64 num_entries;\n\tu64 revision;\n\tu64 domain;\n\tu64 coord_type;\n\tu64 num_processors;\n} __packed;\n\nstruct acpi_ptc_register {\n\tu8 descriptor;\n\tu16 length;\n\tu8 space_id;\n\tu8 bit_width;\n\tu8 bit_offset;\n\tu8 reserved;\n\tu64 address;\n} __packed;\n\nstruct acpi_processor_tx_tss {\n\tu64 freqpercentage;\t \n\tu64 power;\t \n\tu64 transition_latency;\t \n\tu64 control;\t \n\tu64 status;\t \n};\nstruct acpi_processor_tx {\n\tu16 power;\n\tu16 performance;\n};\n\nstruct acpi_processor;\nstruct acpi_processor_throttling {\n\tunsigned int state;\n\tunsigned int platform_limit;\n\tstruct acpi_pct_register control_register;\n\tstruct acpi_pct_register status_register;\n\tunsigned int state_count;\n\tstruct acpi_processor_tx_tss *states_tss;\n\tstruct acpi_tsd_package domain_info;\n\tcpumask_var_t shared_cpu_map;\n\tint (*acpi_processor_get_throttling) (struct acpi_processor * pr);\n\tint (*acpi_processor_set_throttling) (struct acpi_processor * pr,\n\t\t\t\t\t      int state, bool force);\n\n\tu32 address;\n\tu8 duty_offset;\n\tu8 duty_width;\n\tu8 tsd_valid_flag;\n\tunsigned int shared_type;\n\tstruct acpi_processor_tx states[ACPI_PROCESSOR_MAX_THROTTLING];\n};\n\n \n\nstruct acpi_processor_lx {\n\tint px;\t\t\t \n\tint tx;\t\t\t \n};\n\nstruct acpi_processor_limit {\n\tstruct acpi_processor_lx state;\t \n\tstruct acpi_processor_lx thermal;\t \n\tstruct acpi_processor_lx user;\t \n};\n\nstruct acpi_processor_flags {\n\tu8 power:1;\n\tu8 performance:1;\n\tu8 throttling:1;\n\tu8 limit:1;\n\tu8 bm_control:1;\n\tu8 bm_check:1;\n\tu8 has_cst:1;\n\tu8 has_lpi:1;\n\tu8 power_setup_done:1;\n\tu8 bm_rld_set:1;\n\tu8 need_hotplug_init:1;\n};\n\nstruct acpi_processor {\n\tacpi_handle handle;\n\tu32 acpi_id;\n\tphys_cpuid_t phys_id;\t \n\tu32 id;\t\t \n\tu32 pblk;\n\tint performance_platform_limit;\n\tint throttling_platform_limit;\n\t \n\n\tstruct acpi_processor_flags flags;\n\tstruct acpi_processor_power power;\n\tstruct acpi_processor_performance *performance;\n\tstruct acpi_processor_throttling throttling;\n\tstruct acpi_processor_limit limit;\n\tstruct thermal_cooling_device *cdev;\n\tstruct device *dev;  \n\tstruct freq_qos_request perflib_req;\n\tstruct freq_qos_request thermal_req;\n};\n\nstruct acpi_processor_errata {\n\tu8 smp;\n\tstruct {\n\t\tu8 throttle:1;\n\t\tu8 fdma:1;\n\t\tu8 reserved:6;\n\t\tu32 bmisx;\n\t} piix4;\n};\n\nextern int acpi_processor_preregister_performance(struct\n\t\t\t\t\t\t  acpi_processor_performance\n\t\t\t\t\t\t  __percpu *performance);\n\nextern int acpi_processor_register_performance(struct acpi_processor_performance\n\t\t\t\t\t       *performance, unsigned int cpu);\nextern void acpi_processor_unregister_performance(unsigned int cpu);\n\nint acpi_processor_pstate_control(void);\n \nint acpi_processor_notify_smm(struct module *calling_module);\nint acpi_processor_get_psd(acpi_handle handle,\n\t\t\t   struct acpi_psd_package *pdomain);\n\n \nextern int acpi_processor_get_performance_info(struct acpi_processor *pr);\n\n \nDECLARE_PER_CPU(struct acpi_processor *, processors);\nextern struct acpi_processor_errata errata;\n\n#if defined(ARCH_HAS_POWER_INIT) && defined(CONFIG_ACPI_PROCESSOR_CSTATE)\nvoid acpi_processor_power_init_bm_check(struct acpi_processor_flags *flags,\n\t\t\t\t\tunsigned int cpu);\nint acpi_processor_ffh_cstate_probe(unsigned int cpu,\n\t\t\t\t    struct acpi_processor_cx *cx,\n\t\t\t\t    struct acpi_power_register *reg);\nvoid acpi_processor_ffh_cstate_enter(struct acpi_processor_cx *cstate);\n#else\nstatic inline void acpi_processor_power_init_bm_check(struct\n\t\t\t\t\t\t      acpi_processor_flags\n\t\t\t\t\t\t      *flags, unsigned int cpu)\n{\n\tflags->bm_check = 1;\n\treturn;\n}\nstatic inline int acpi_processor_ffh_cstate_probe(unsigned int cpu,\n\t\t\t\t\t\t  struct acpi_processor_cx *cx,\n\t\t\t\t\t\t  struct acpi_power_register\n\t\t\t\t\t\t  *reg)\n{\n\treturn -1;\n}\nstatic inline void acpi_processor_ffh_cstate_enter(struct acpi_processor_cx\n\t\t\t\t\t\t   *cstate)\n{\n\treturn;\n}\n#endif\n\nstatic inline int call_on_cpu(int cpu, long (*fn)(void *), void *arg,\n\t\t\t      bool direct)\n{\n\tif (direct || (is_percpu_thread() && cpu == smp_processor_id()))\n\t\treturn fn(arg);\n\treturn work_on_cpu(cpu, fn, arg);\n}\n\n \n\n#ifdef CONFIG_CPU_FREQ\nextern bool acpi_processor_cpufreq_init;\nvoid acpi_processor_ignore_ppc_init(void);\nvoid acpi_processor_ppc_init(struct cpufreq_policy *policy);\nvoid acpi_processor_ppc_exit(struct cpufreq_policy *policy);\nvoid acpi_processor_ppc_has_changed(struct acpi_processor *pr, int event_flag);\nextern int acpi_processor_get_bios_limit(int cpu, unsigned int *limit);\n#else\nstatic inline void acpi_processor_ignore_ppc_init(void)\n{\n\treturn;\n}\nstatic inline void acpi_processor_ppc_init(struct cpufreq_policy *policy)\n{\n\treturn;\n}\nstatic inline void acpi_processor_ppc_exit(struct cpufreq_policy *policy)\n{\n\treturn;\n}\nstatic inline void acpi_processor_ppc_has_changed(struct acpi_processor *pr,\n\t\t\t\t\t\t\t\tint event_flag)\n{\n\tstatic unsigned int printout = 1;\n\tif (printout) {\n\t\tprintk(KERN_WARNING\n\t\t       \"Warning: Processor Platform Limit event detected, but not handled.\\n\");\n\t\tprintk(KERN_WARNING\n\t\t       \"Consider compiling CPUfreq support into your kernel.\\n\");\n\t\tprintout = 0;\n\t}\n}\nstatic inline int acpi_processor_get_bios_limit(int cpu, unsigned int *limit)\n{\n\treturn -ENODEV;\n}\n\n#endif\t\t\t\t \n\n \nphys_cpuid_t acpi_get_phys_id(acpi_handle, int type, u32 acpi_id);\nphys_cpuid_t acpi_map_madt_entry(u32 acpi_id);\nint acpi_map_cpuid(phys_cpuid_t phys_id, u32 acpi_id);\nint acpi_get_cpuid(acpi_handle, int type, u32 acpi_id);\n\n#ifdef CONFIG_ACPI_CPPC_LIB\nextern int acpi_cppc_processor_probe(struct acpi_processor *pr);\nextern void acpi_cppc_processor_exit(struct acpi_processor *pr);\n#else\nstatic inline int acpi_cppc_processor_probe(struct acpi_processor *pr)\n{\n\treturn 0;\n}\nstatic inline void acpi_cppc_processor_exit(struct acpi_processor *pr)\n{\n\treturn;\n}\n#endif\t \n\n \nvoid acpi_processor_set_pdc(acpi_handle handle);\n\n \n#ifdef CONFIG_ACPI_CPU_FREQ_PSS\nint acpi_processor_tstate_has_changed(struct acpi_processor *pr);\nint acpi_processor_get_throttling_info(struct acpi_processor *pr);\nextern int acpi_processor_set_throttling(struct acpi_processor *pr,\n\t\t\t\t\t int state, bool force);\n \nextern void acpi_processor_reevaluate_tstate(struct acpi_processor *pr,\n\t\t\tbool is_dead);\nextern const struct file_operations acpi_processor_throttling_fops;\nextern void acpi_processor_throttling_init(void);\n#else\nstatic inline int acpi_processor_tstate_has_changed(struct acpi_processor *pr)\n{\n\treturn 0;\n}\n\nstatic inline int acpi_processor_get_throttling_info(struct acpi_processor *pr)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_processor_set_throttling(struct acpi_processor *pr,\n\t\t\t\t\t int state, bool force)\n{\n\treturn -ENODEV;\n}\n\nstatic inline void acpi_processor_reevaluate_tstate(struct acpi_processor *pr,\n\t\t\tbool is_dead) {}\n\nstatic inline void acpi_processor_throttling_init(void) {}\n#endif\t \n\n \nextern struct cpuidle_driver acpi_idle_driver;\n#ifdef CONFIG_ACPI_PROCESSOR_IDLE\nint acpi_processor_power_init(struct acpi_processor *pr);\nint acpi_processor_power_exit(struct acpi_processor *pr);\nint acpi_processor_power_state_has_changed(struct acpi_processor *pr);\nint acpi_processor_hotplug(struct acpi_processor *pr);\n#else\nstatic inline int acpi_processor_power_init(struct acpi_processor *pr)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_processor_power_exit(struct acpi_processor *pr)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_processor_power_state_has_changed(struct acpi_processor *pr)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_processor_hotplug(struct acpi_processor *pr)\n{\n\treturn -ENODEV;\n}\n#endif  \n\n \nint acpi_processor_thermal_init(struct acpi_processor *pr,\n\t\t\t\tstruct acpi_device *device);\nvoid acpi_processor_thermal_exit(struct acpi_processor *pr,\n\t\t\t\t struct acpi_device *device);\nextern const struct thermal_cooling_device_ops processor_cooling_ops;\n#ifdef CONFIG_CPU_FREQ\nvoid acpi_thermal_cpufreq_init(struct cpufreq_policy *policy);\nvoid acpi_thermal_cpufreq_exit(struct cpufreq_policy *policy);\n#else\nstatic inline void acpi_thermal_cpufreq_init(struct cpufreq_policy *policy)\n{\n\treturn;\n}\nstatic inline void acpi_thermal_cpufreq_exit(struct cpufreq_policy *policy)\n{\n\treturn;\n}\n#endif\t \n\n#ifdef CONFIG_ACPI_PROCESSOR_IDLE\nextern int acpi_processor_ffh_lpi_probe(unsigned int cpu);\nextern int acpi_processor_ffh_lpi_enter(struct acpi_lpi_state *lpi);\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}