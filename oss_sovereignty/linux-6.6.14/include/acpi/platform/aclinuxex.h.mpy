{
  "module_name": "aclinuxex.h",
  "hash_id": "37a43830344fddb218e5f9107de73b2c859fe069e1a8b7f490dd4bc66072bcf9",
  "original_prompt": "Ingested from linux-6.6.14/include/acpi/platform/aclinuxex.h",
  "human_readable_source": " \n \n\n#ifndef __ACLINUXEX_H__\n#define __ACLINUXEX_H__\n\n#ifdef __KERNEL__\n\n#ifndef ACPI_USE_NATIVE_DIVIDE\n\n#ifndef ACPI_DIV_64_BY_32\n#define ACPI_DIV_64_BY_32(n_hi, n_lo, d32, q32, r32) \\\n\tdo { \\\n\t\tu64 (__n) = ((u64) n_hi) << 32 | (n_lo); \\\n\t\t(r32) = do_div ((__n), (d32)); \\\n\t\t(q32) = (u32) (__n); \\\n\t} while (0)\n#endif\n\n#ifndef ACPI_SHIFT_RIGHT_64\n#define ACPI_SHIFT_RIGHT_64(n_hi, n_lo) \\\n\tdo { \\\n\t\t(n_lo) >>= 1; \\\n\t\t(n_lo) |= (((n_hi) & 1) << 31); \\\n\t\t(n_hi) >>= 1; \\\n\t} while (0)\n#endif\n\n#endif\n\n \nacpi_status ACPI_INIT_FUNCTION acpi_os_initialize(void);\n\nacpi_status acpi_os_terminate(void);\n\n \nstatic inline void *acpi_os_allocate(acpi_size size)\n{\n\treturn kmalloc(size, irqs_disabled()? GFP_ATOMIC : GFP_KERNEL);\n}\n\nstatic inline void *acpi_os_allocate_zeroed(acpi_size size)\n{\n\treturn kzalloc(size, irqs_disabled()? GFP_ATOMIC : GFP_KERNEL);\n}\n\nstatic inline void acpi_os_free(void *memory)\n{\n\tkfree(memory);\n}\n\nstatic inline void *acpi_os_acquire_object(acpi_cache_t * cache)\n{\n\treturn kmem_cache_zalloc(cache,\n\t\t\t\t irqs_disabled()? GFP_ATOMIC : GFP_KERNEL);\n}\n\nstatic inline acpi_thread_id acpi_os_get_thread_id(void)\n{\n\treturn (acpi_thread_id) (unsigned long)current;\n}\n\n \n#define acpi_os_create_lock(__handle) \\\n\t({ \\\n\t\tspinlock_t *lock = ACPI_ALLOCATE(sizeof(*lock)); \\\n\t\tif (lock) { \\\n\t\t\t*(__handle) = lock; \\\n\t\t\tspin_lock_init(*(__handle)); \\\n\t\t} \\\n\t\tlock ? AE_OK : AE_NO_MEMORY; \\\n\t})\n\n\n#define acpi_os_create_raw_lock(__handle) \\\n\t({ \\\n\t\traw_spinlock_t *lock = ACPI_ALLOCATE(sizeof(*lock)); \\\n\t\tif (lock) { \\\n\t\t\t*(__handle) = lock; \\\n\t\t\traw_spin_lock_init(*(__handle)); \\\n\t\t} \\\n\t\tlock ? AE_OK : AE_NO_MEMORY; \\\n\t})\n\nstatic inline acpi_cpu_flags acpi_os_acquire_raw_lock(acpi_raw_spinlock lockp)\n{\n\tacpi_cpu_flags flags;\n\n\traw_spin_lock_irqsave(lockp, flags);\n\treturn flags;\n}\n\nstatic inline void acpi_os_release_raw_lock(acpi_raw_spinlock lockp,\n\t\t\t\t\t    acpi_cpu_flags flags)\n{\n\traw_spin_unlock_irqrestore(lockp, flags);\n}\n\nstatic inline void acpi_os_delete_raw_lock(acpi_raw_spinlock handle)\n{\n\tACPI_FREE(handle);\n}\n\nstatic inline u8 acpi_os_readable(void *pointer, acpi_size length)\n{\n\treturn TRUE;\n}\n\nstatic inline acpi_status acpi_os_initialize_debugger(void)\n{\n\treturn AE_OK;\n}\n\nstatic inline void acpi_os_terminate_debugger(void)\n{\n\treturn;\n}\n\n \n\n#endif\t\t\t\t \n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}