{
  "module_name": "cppc_acpi.h",
  "hash_id": "c0509705513adaeecd248a3340fbe71c5d1d753b4f3305fa1165c160d565fedb",
  "original_prompt": "Ingested from linux-6.6.14/include/acpi/cppc_acpi.h",
  "human_readable_source": " \n \n\n#ifndef _CPPC_ACPI_H\n#define _CPPC_ACPI_H\n\n#include <linux/acpi.h>\n#include <linux/cpufreq.h>\n#include <linux/types.h>\n\n#include <acpi/pcc.h>\n#include <acpi/processor.h>\n\n \n#define CPPC_V2_REV\t2\n#define CPPC_V3_REV\t3\n#define CPPC_V2_NUM_ENT\t21\n#define CPPC_V3_NUM_ENT\t23\n\n#define PCC_CMD_COMPLETE_MASK\t(1 << 0)\n#define PCC_ERROR_MASK\t\t(1 << 2)\n\n#define MAX_CPC_REG_ENT 21\n\n \n#define\tCMD_READ 0\n#define\tCMD_WRITE 1\n\n \nstruct cpc_reg {\n\tu8 descriptor;\n\tu16 length;\n\tu8 space_id;\n\tu8 bit_width;\n\tu8 bit_offset;\n\tu8 access_width;\n\tu64 address;\n} __packed;\n\n \nstruct cpc_register_resource {\n\tacpi_object_type type;\n\tu64 __iomem *sys_mem_vaddr;\n\tunion {\n\t\tstruct cpc_reg reg;\n\t\tu64 int_value;\n\t} cpc_entry;\n};\n\n \nstruct cpc_desc {\n\tint num_entries;\n\tint version;\n\tint cpu_id;\n\tint write_cmd_status;\n\tint write_cmd_id;\n\tstruct cpc_register_resource cpc_regs[MAX_CPC_REG_ENT];\n\tstruct acpi_psd_package domain_info;\n\tstruct kobject kobj;\n};\n\n \nenum cppc_regs {\n\tHIGHEST_PERF,\n\tNOMINAL_PERF,\n\tLOW_NON_LINEAR_PERF,\n\tLOWEST_PERF,\n\tGUARANTEED_PERF,\n\tDESIRED_PERF,\n\tMIN_PERF,\n\tMAX_PERF,\n\tPERF_REDUC_TOLERANCE,\n\tTIME_WINDOW,\n\tCTR_WRAP_TIME,\n\tREFERENCE_CTR,\n\tDELIVERED_CTR,\n\tPERF_LIMITED,\n\tENABLE,\n\tAUTO_SEL_ENABLE,\n\tAUTO_ACT_WINDOW,\n\tENERGY_PERF,\n\tREFERENCE_PERF,\n\tLOWEST_FREQ,\n\tNOMINAL_FREQ,\n};\n\n \nstruct cppc_perf_caps {\n\tu32 guaranteed_perf;\n\tu32 highest_perf;\n\tu32 nominal_perf;\n\tu32 lowest_perf;\n\tu32 lowest_nonlinear_perf;\n\tu32 lowest_freq;\n\tu32 nominal_freq;\n\tu32 energy_perf;\n\tbool auto_sel;\n};\n\nstruct cppc_perf_ctrls {\n\tu32 max_perf;\n\tu32 min_perf;\n\tu32 desired_perf;\n\tu32 energy_perf;\n};\n\nstruct cppc_perf_fb_ctrs {\n\tu64 reference;\n\tu64 delivered;\n\tu64 reference_perf;\n\tu64 wraparound_time;\n};\n\n \nstruct cppc_cpudata {\n\tstruct list_head node;\n\tstruct cppc_perf_caps perf_caps;\n\tstruct cppc_perf_ctrls perf_ctrls;\n\tstruct cppc_perf_fb_ctrs perf_fb_ctrs;\n\tunsigned int shared_type;\n\tcpumask_var_t shared_cpu_map;\n};\n\n#ifdef CONFIG_ACPI_CPPC_LIB\nextern int cppc_get_desired_perf(int cpunum, u64 *desired_perf);\nextern int cppc_get_nominal_perf(int cpunum, u64 *nominal_perf);\nextern int cppc_get_perf_ctrs(int cpu, struct cppc_perf_fb_ctrs *perf_fb_ctrs);\nextern int cppc_set_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls);\nextern int cppc_set_enable(int cpu, bool enable);\nextern int cppc_get_perf_caps(int cpu, struct cppc_perf_caps *caps);\nextern bool cppc_perf_ctrs_in_pcc(void);\nextern bool acpi_cpc_valid(void);\nextern bool cppc_allow_fast_switch(void);\nextern int acpi_get_psd_map(unsigned int cpu, struct cppc_cpudata *cpu_data);\nextern unsigned int cppc_get_transition_latency(int cpu);\nextern bool cpc_ffh_supported(void);\nextern bool cpc_supported_by_cpu(void);\nextern int cpc_read_ffh(int cpunum, struct cpc_reg *reg, u64 *val);\nextern int cpc_write_ffh(int cpunum, struct cpc_reg *reg, u64 val);\nextern int cppc_get_epp_perf(int cpunum, u64 *epp_perf);\nextern int cppc_set_epp_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls, bool enable);\nextern int cppc_get_auto_sel_caps(int cpunum, struct cppc_perf_caps *perf_caps);\nextern int cppc_set_auto_sel(int cpu, bool enable);\n#else  \nstatic inline int cppc_get_desired_perf(int cpunum, u64 *desired_perf)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int cppc_get_nominal_perf(int cpunum, u64 *nominal_perf)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int cppc_get_perf_ctrs(int cpu, struct cppc_perf_fb_ctrs *perf_fb_ctrs)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int cppc_set_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int cppc_set_enable(int cpu, bool enable)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int cppc_get_perf_caps(int cpu, struct cppc_perf_caps *caps)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline bool cppc_perf_ctrs_in_pcc(void)\n{\n\treturn false;\n}\nstatic inline bool acpi_cpc_valid(void)\n{\n\treturn false;\n}\nstatic inline bool cppc_allow_fast_switch(void)\n{\n\treturn false;\n}\nstatic inline unsigned int cppc_get_transition_latency(int cpu)\n{\n\treturn CPUFREQ_ETERNAL;\n}\nstatic inline bool cpc_ffh_supported(void)\n{\n\treturn false;\n}\nstatic inline int cpc_read_ffh(int cpunum, struct cpc_reg *reg, u64 *val)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int cpc_write_ffh(int cpunum, struct cpc_reg *reg, u64 val)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int cppc_set_epp_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls, bool enable)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int cppc_get_epp_perf(int cpunum, u64 *epp_perf)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int cppc_set_auto_sel(int cpu, bool enable)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int cppc_get_auto_sel_caps(int cpunum, struct cppc_perf_caps *perf_caps)\n{\n\treturn -ENOTSUPP;\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}