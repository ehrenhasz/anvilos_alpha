{
  "module_name": "acpiosxf.h",
  "hash_id": "f7d03fcdd110cc0dab43a20adeb6886e49fc8909d037569296cc7aeea82a29fd",
  "original_prompt": "Ingested from linux-6.6.14/include/acpi/acpiosxf.h",
  "human_readable_source": " \n \n\n#ifndef __ACPIOSXF_H__\n#define __ACPIOSXF_H__\n\n#include <acpi/platform/acenv.h>\n#include <acpi/actypes.h>\n\n \n\ntypedef enum {\n\tOSL_GLOBAL_LOCK_HANDLER,\n\tOSL_NOTIFY_HANDLER,\n\tOSL_GPE_HANDLER,\n\tOSL_DEBUGGER_MAIN_THREAD,\n\tOSL_DEBUGGER_EXEC_THREAD,\n\tOSL_EC_POLL_HANDLER,\n\tOSL_EC_BURST_HANDLER\n} acpi_execute_type;\n\n#define ACPI_NO_UNIT_LIMIT          ((u32) -1)\n#define ACPI_MUTEX_SEM              1\n\n \n\n#define ACPI_SIGNAL_FATAL           0\n#define ACPI_SIGNAL_BREAKPOINT      1\n\nstruct acpi_signal_fatal_info {\n\tu32 type;\n\tu32 code;\n\tu32 argument;\n};\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_initialize\nacpi_status acpi_os_initialize(void);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_terminate\nacpi_status acpi_os_terminate(void);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_root_pointer\nacpi_physical_address acpi_os_get_root_pointer(void);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_predefined_override\nacpi_status\nacpi_os_predefined_override(const struct acpi_predefined_names *init_val,\n\t\t\t    acpi_string *new_val);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_table_override\nacpi_status\nacpi_os_table_override(struct acpi_table_header *existing_table,\n\t\t       struct acpi_table_header **new_table);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_physical_table_override\nacpi_status\nacpi_os_physical_table_override(struct acpi_table_header *existing_table,\n\t\t\t\tacpi_physical_address *new_address,\n\t\t\t\tu32 *new_table_length);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_create_lock\nacpi_status acpi_os_create_lock(acpi_spinlock * out_handle);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_delete_lock\nvoid acpi_os_delete_lock(acpi_spinlock handle);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_acquire_lock\nacpi_cpu_flags acpi_os_acquire_lock(acpi_spinlock handle);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_release_lock\nvoid acpi_os_release_lock(acpi_spinlock handle, acpi_cpu_flags flags);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_create_raw_lock\n# define acpi_os_create_raw_lock(out_handle)\tacpi_os_create_lock(out_handle)\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_delete_raw_lock\n# define acpi_os_delete_raw_lock(handle)\tacpi_os_delete_lock(handle)\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_acquire_raw_lock\n# define acpi_os_acquire_raw_lock(handle)\tacpi_os_acquire_lock(handle)\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_release_raw_lock\n# define acpi_os_release_raw_lock(handle, flags)\t\\\n\tacpi_os_release_lock(handle, flags)\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_create_semaphore\nacpi_status\nacpi_os_create_semaphore(u32 max_units,\n\t\t\t u32 initial_units, acpi_semaphore * out_handle);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_delete_semaphore\nacpi_status acpi_os_delete_semaphore(acpi_semaphore handle);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_wait_semaphore\nacpi_status\nacpi_os_wait_semaphore(acpi_semaphore handle, u32 units, u16 timeout);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_signal_semaphore\nacpi_status acpi_os_signal_semaphore(acpi_semaphore handle, u32 units);\n#endif\n\n \n#if (ACPI_MUTEX_TYPE != ACPI_BINARY_SEMAPHORE)\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_create_mutex\nacpi_status acpi_os_create_mutex(acpi_mutex * out_handle);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_delete_mutex\nvoid acpi_os_delete_mutex(acpi_mutex handle);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_acquire_mutex\nacpi_status acpi_os_acquire_mutex(acpi_mutex handle, u16 timeout);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_release_mutex\nvoid acpi_os_release_mutex(acpi_mutex handle);\n#endif\n\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_allocate\nvoid *acpi_os_allocate(acpi_size size);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_allocate_zeroed\nvoid *acpi_os_allocate_zeroed(acpi_size size);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_free\nvoid acpi_os_free(void *memory);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_map_memory\nvoid *acpi_os_map_memory(acpi_physical_address where, acpi_size length);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_unmap_memory\nvoid acpi_os_unmap_memory(void *logical_address, acpi_size size);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_physical_address\nacpi_status\nacpi_os_get_physical_address(void *logical_address,\n\t\t\t     acpi_physical_address *physical_address);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_create_cache\nacpi_status\nacpi_os_create_cache(char *cache_name,\n\t\t     u16 object_size,\n\t\t     u16 max_depth, acpi_cache_t ** return_cache);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_delete_cache\nacpi_status acpi_os_delete_cache(acpi_cache_t * cache);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_purge_cache\nacpi_status acpi_os_purge_cache(acpi_cache_t * cache);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_acquire_object\nvoid *acpi_os_acquire_object(acpi_cache_t * cache);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_release_object\nacpi_status acpi_os_release_object(acpi_cache_t * cache, void *object);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_install_interrupt_handler\nacpi_status\nacpi_os_install_interrupt_handler(u32 interrupt_number,\n\t\t\t\t  acpi_osd_handler service_routine,\n\t\t\t\t  void *context);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_remove_interrupt_handler\nacpi_status\nacpi_os_remove_interrupt_handler(u32 interrupt_number,\n\t\t\t\t acpi_osd_handler service_routine);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_thread_id\nacpi_thread_id acpi_os_get_thread_id(void);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_execute\nacpi_status\nacpi_os_execute(acpi_execute_type type,\n\t\tacpi_osd_exec_callback function, void *context);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_wait_events_complete\nvoid acpi_os_wait_events_complete(void);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_sleep\nvoid acpi_os_sleep(u64 milliseconds);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_stall\nvoid acpi_os_stall(u32 microseconds);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_read_port\nacpi_status acpi_os_read_port(acpi_io_address address, u32 *value, u32 width);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_write_port\nacpi_status acpi_os_write_port(acpi_io_address address, u32 value, u32 width);\n#endif\n\n \nint acpi_os_read_iomem(void __iomem *virt_addr, u64 *value, u32 width);\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_read_memory\nacpi_status\nacpi_os_read_memory(acpi_physical_address address, u64 *value, u32 width);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_write_memory\nacpi_status\nacpi_os_write_memory(acpi_physical_address address, u64 value, u32 width);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_read_pci_configuration\nacpi_status\nacpi_os_read_pci_configuration(struct acpi_pci_id *pci_id,\n\t\t\t       u32 reg, u64 *value, u32 width);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_write_pci_configuration\nacpi_status\nacpi_os_write_pci_configuration(struct acpi_pci_id *pci_id,\n\t\t\t\tu32 reg, u64 value, u32 width);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_readable\nu8 acpi_os_readable(void *pointer, acpi_size length);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_writable\nu8 acpi_os_writable(void *pointer, acpi_size length);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_timer\nu64 acpi_os_get_timer(void);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_signal\nacpi_status acpi_os_signal(u32 function, void *info);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_enter_sleep\nacpi_status acpi_os_enter_sleep(u8 sleep_state, u32 rega_value, u32 regb_value);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_printf\nACPI_PRINTF_LIKE(1)\nvoid ACPI_INTERNAL_VAR_XFACE acpi_os_printf(const char *format, ...);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_vprintf\nvoid acpi_os_vprintf(const char *format, va_list args);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_redirect_output\nvoid acpi_os_redirect_output(void *destination);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_line\nacpi_status acpi_os_get_line(char *buffer, u32 buffer_length, u32 *bytes_read);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_initialize_debugger\nacpi_status acpi_os_initialize_debugger(void);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_terminate_debugger\nvoid acpi_os_terminate_debugger(void);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_wait_command_ready\nacpi_status acpi_os_wait_command_ready(void);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_notify_command_complete\nacpi_status acpi_os_notify_command_complete(void);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_trace_point\nvoid\nacpi_os_trace_point(acpi_trace_event_type type,\n\t\t    u8 begin, u8 *aml, char *pathname);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_table_by_name\nacpi_status\nacpi_os_get_table_by_name(char *signature,\n\t\t\t  u32 instance,\n\t\t\t  struct acpi_table_header **table,\n\t\t\t  acpi_physical_address *address);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_table_by_index\nacpi_status\nacpi_os_get_table_by_index(u32 index,\n\t\t\t   struct acpi_table_header **table,\n\t\t\t   u32 *instance, acpi_physical_address *address);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_table_by_address\nacpi_status\nacpi_os_get_table_by_address(acpi_physical_address address,\n\t\t\t     struct acpi_table_header **table);\n#endif\n\n \n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_open_directory\nvoid *acpi_os_open_directory(char *pathname,\n\t\t\t     char *wildcard_spec, char requested_file_type);\n#endif\n\n \n\n#define REQUEST_FILE_ONLY                   0\n#define REQUEST_DIR_ONLY                    1\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_get_next_filename\nchar *acpi_os_get_next_filename(void *dir_handle);\n#endif\n\n#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_close_directory\nvoid acpi_os_close_directory(void *dir_handle);\n#endif\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}