{
  "module_name": "acpi_bus.h",
  "hash_id": "75caf71929951895ebc35f704c7fc5698ba74ead2b40eedfa125b61a63eaea7e",
  "original_prompt": "Ingested from linux-6.6.14/include/acpi/acpi_bus.h",
  "human_readable_source": " \n \n\n#ifndef __ACPI_BUS_H__\n#define __ACPI_BUS_H__\n\n#include <linux/device.h>\n#include <linux/property.h>\n\n \n#define ACPI_MAX_HANDLES\t10\nstruct acpi_handle_list {\n\tu32 count;\n\tacpi_handle handles[ACPI_MAX_HANDLES];\n};\n\n \nacpi_status\nacpi_extract_package(union acpi_object *package,\n\t\t     struct acpi_buffer *format, struct acpi_buffer *buffer);\nacpi_status\nacpi_evaluate_integer(acpi_handle handle,\n\t\t      acpi_string pathname,\n\t\t      struct acpi_object_list *arguments, unsigned long long *data);\nacpi_status\nacpi_evaluate_reference(acpi_handle handle,\n\t\t\tacpi_string pathname,\n\t\t\tstruct acpi_object_list *arguments,\n\t\t\tstruct acpi_handle_list *list);\nacpi_status\nacpi_evaluate_ost(acpi_handle handle, u32 source_event, u32 status_code,\n\t\t  struct acpi_buffer *status_buf);\n\nacpi_status\nacpi_get_physical_device_location(acpi_handle handle, struct acpi_pld_info **pld);\n\nbool acpi_has_method(acpi_handle handle, char *name);\nacpi_status acpi_execute_simple_method(acpi_handle handle, char *method,\n\t\t\t\t       u64 arg);\nacpi_status acpi_evaluate_ej0(acpi_handle handle);\nacpi_status acpi_evaluate_lck(acpi_handle handle, int lock);\nacpi_status acpi_evaluate_reg(acpi_handle handle, u8 space_id, u32 function);\nbool acpi_ata_match(acpi_handle handle);\nbool acpi_bay_match(acpi_handle handle);\nbool acpi_dock_match(acpi_handle handle);\n\nbool acpi_check_dsm(acpi_handle handle, const guid_t *guid, u64 rev, u64 funcs);\nunion acpi_object *acpi_evaluate_dsm(acpi_handle handle, const guid_t *guid,\n\t\t\tu64 rev, u64 func, union acpi_object *argv4);\n#ifdef CONFIG_ACPI\nstatic inline union acpi_object *\nacpi_evaluate_dsm_typed(acpi_handle handle, const guid_t *guid, u64 rev,\n\t\t\tu64 func, union acpi_object *argv4,\n\t\t\tacpi_object_type type)\n{\n\tunion acpi_object *obj;\n\n\tobj = acpi_evaluate_dsm(handle, guid, rev, func, argv4);\n\tif (obj && obj->type != type) {\n\t\tACPI_FREE(obj);\n\t\tobj = NULL;\n\t}\n\n\treturn obj;\n}\n#endif\n\n#define\tACPI_INIT_DSM_ARGV4(cnt, eles)\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t  .package.type = ACPI_TYPE_PACKAGE,\t\t\\\n\t  .package.count = (cnt),\t\t\t\\\n\t  .package.elements = (eles)\t\t\t\\\n\t}\n\nbool acpi_dev_found(const char *hid);\nbool acpi_dev_present(const char *hid, const char *uid, s64 hrv);\nbool acpi_reduced_hardware(void);\n\n#ifdef CONFIG_ACPI\n\nstruct proc_dir_entry;\n\n#define ACPI_BUS_FILE_ROOT\t\"acpi\"\nextern struct proc_dir_entry *acpi_root_dir;\n\nenum acpi_bus_device_type {\n\tACPI_BUS_TYPE_DEVICE = 0,\n\tACPI_BUS_TYPE_POWER,\n\tACPI_BUS_TYPE_PROCESSOR,\n\tACPI_BUS_TYPE_THERMAL,\n\tACPI_BUS_TYPE_POWER_BUTTON,\n\tACPI_BUS_TYPE_SLEEP_BUTTON,\n\tACPI_BUS_TYPE_ECDT_EC,\n\tACPI_BUS_DEVICE_TYPE_COUNT\n};\n\nstruct acpi_driver;\nstruct acpi_device;\n\n \n\nstruct acpi_hotplug_profile {\n\tstruct kobject kobj;\n\tint (*scan_dependent)(struct acpi_device *adev);\n\tvoid (*notify_online)(struct acpi_device *adev);\n\tbool enabled:1;\n\tbool demand_offline:1;\n};\n\nstatic inline struct acpi_hotplug_profile *to_acpi_hotplug_profile(\n\t\t\t\t\t\tstruct kobject *kobj)\n{\n\treturn container_of(kobj, struct acpi_hotplug_profile, kobj);\n}\n\nstruct acpi_scan_handler {\n\tconst struct acpi_device_id *ids;\n\tstruct list_head list_node;\n\tbool (*match)(const char *idstr, const struct acpi_device_id **matchid);\n\tint (*attach)(struct acpi_device *dev, const struct acpi_device_id *id);\n\tvoid (*detach)(struct acpi_device *dev);\n\tvoid (*bind)(struct device *phys_dev);\n\tvoid (*unbind)(struct device *phys_dev);\n\tstruct acpi_hotplug_profile hotplug;\n};\n\n \n\nstruct acpi_hotplug_context {\n\tstruct acpi_device *self;\n\tint (*notify)(struct acpi_device *, u32);\n\tvoid (*uevent)(struct acpi_device *, u32);\n\tvoid (*fixup)(struct acpi_device *);\n};\n\n \n\ntypedef int (*acpi_op_add) (struct acpi_device * device);\ntypedef void (*acpi_op_remove) (struct acpi_device *device);\ntypedef void (*acpi_op_notify) (struct acpi_device * device, u32 event);\n\nstruct acpi_device_ops {\n\tacpi_op_add add;\n\tacpi_op_remove remove;\n\tacpi_op_notify notify;\n};\n\n#define ACPI_DRIVER_ALL_NOTIFY_EVENTS\t0x1\t \n\nstruct acpi_driver {\n\tchar name[80];\n\tchar class[80];\n\tconst struct acpi_device_id *ids;  \n\tunsigned int flags;\n\tstruct acpi_device_ops ops;\n\tstruct device_driver drv;\n\tstruct module *owner;\n};\n\n \n\n \n\nstruct acpi_device_status {\n\tu32 present:1;\n\tu32 enabled:1;\n\tu32 show_in_ui:1;\n\tu32 functional:1;\n\tu32 battery_present:1;\n\tu32 reserved:27;\n};\n\n \n\nstruct acpi_device_flags {\n\tu32 dynamic_status:1;\n\tu32 removable:1;\n\tu32 ejectable:1;\n\tu32 power_manageable:1;\n\tu32 match_driver:1;\n\tu32 initialized:1;\n\tu32 visited:1;\n\tu32 hotplug_notify:1;\n\tu32 is_dock_station:1;\n\tu32 of_compatible_ok:1;\n\tu32 coherent_dma:1;\n\tu32 cca_seen:1;\n\tu32 enumeration_by_parent:1;\n\tu32 honor_deps:1;\n\tu32 reserved:18;\n};\n\n \n\nstruct acpi_device_dir {\n\tstruct proc_dir_entry *entry;\n};\n\n#define acpi_device_dir(d)\t((d)->dir.entry)\n\n \n\ntypedef char acpi_bus_id[8];\ntypedef u64 acpi_bus_address;\ntypedef char acpi_device_name[40];\ntypedef char acpi_device_class[20];\n\nstruct acpi_hardware_id {\n\tstruct list_head list;\n\tconst char *id;\n};\n\nstruct acpi_pnp_type {\n\tu32 hardware_id:1;\n\tu32 bus_address:1;\n\tu32 platform_id:1;\n\tu32 backlight:1;\n\tu32 reserved:28;\n};\n\nstruct acpi_device_pnp {\n\tacpi_bus_id bus_id;\t\t \n\tint instance_no;\t\t \n\tstruct acpi_pnp_type type;\t \n\tacpi_bus_address bus_address;\t \n\tchar *unique_id;\t\t \n\tstruct list_head ids;\t\t \n\tacpi_device_name device_name;\t \n\tacpi_device_class device_class;\t \n\tunion acpi_object *str_obj;\t \n};\n\n#define acpi_device_bid(d)\t((d)->pnp.bus_id)\n#define acpi_device_adr(d)\t((d)->pnp.bus_address)\nconst char *acpi_device_hid(struct acpi_device *device);\n#define acpi_device_uid(d)\t((d)->pnp.unique_id)\n#define acpi_device_name(d)\t((d)->pnp.device_name)\n#define acpi_device_class(d)\t((d)->pnp.device_class)\n\n \n\nstruct acpi_device_power_flags {\n\tu32 explicit_get:1;\t \n\tu32 power_resources:1;\t \n\tu32 inrush_current:1;\t \n\tu32 power_removed:1;\t \n\tu32 ignore_parent:1;\t \n\tu32 dsw_present:1;\t \n\tu32 reserved:26;\n};\n\nstruct acpi_device_power_state {\n\tstruct {\n\t\tu8 valid:1;\n\t\tu8 explicit_set:1;\t \n\t\tu8 reserved:6;\n\t} flags;\n\tint power;\t\t \n\tint latency;\t\t \n\tstruct list_head resources;\t \n};\n\nstruct acpi_device_power {\n\tint state;\t\t \n\tstruct acpi_device_power_flags flags;\n\tstruct acpi_device_power_state states[ACPI_D_STATE_COUNT];\t \n\tu8 state_for_enumeration;  \n};\n\nstruct acpi_dep_data {\n\tstruct list_head node;\n\tacpi_handle supplier;\n\tacpi_handle consumer;\n\tbool honor_dep;\n\tbool met;\n\tbool free_when_met;\n};\n\n \n\nstruct acpi_device_perf_flags {\n\tu8 reserved:8;\n};\n\nstruct acpi_device_perf_state {\n\tstruct {\n\t\tu8 valid:1;\n\t\tu8 reserved:7;\n\t} flags;\n\tu8 power;\t\t \n\tu8 performance;\t\t \n\tint latency;\t\t \n};\n\nstruct acpi_device_perf {\n\tint state;\n\tstruct acpi_device_perf_flags flags;\n\tint state_count;\n\tstruct acpi_device_perf_state *states;\n};\n\n \nstruct acpi_device_wakeup_flags {\n\tu8 valid:1;\t\t \n\tu8 notifier_present:1;   \n};\n\nstruct acpi_device_wakeup_context {\n\tvoid (*func)(struct acpi_device_wakeup_context *context);\n\tstruct device *dev;\n};\n\nstruct acpi_device_wakeup {\n\tacpi_handle gpe_device;\n\tu64 gpe_number;\n\tu64 sleep_state;\n\tstruct list_head resources;\n\tstruct acpi_device_wakeup_flags flags;\n\tstruct acpi_device_wakeup_context context;\n\tstruct wakeup_source *ws;\n\tint prepare_count;\n\tint enable_count;\n};\n\nstruct acpi_device_physical_node {\n\tunsigned int node_id;\n\tstruct list_head node;\n\tstruct device *dev;\n\tbool put_online:1;\n};\n\nstruct acpi_device_properties {\n\tconst guid_t *guid;\n\tunion acpi_object *properties;\n\tstruct list_head list;\n\tvoid **bufs;\n};\n\n \nstruct acpi_device_data {\n\tconst union acpi_object *pointer;\n\tstruct list_head properties;\n\tconst union acpi_object *of_compatible;\n\tstruct list_head subnodes;\n};\n\nstruct acpi_gpio_mapping;\n\n \nstruct acpi_device {\n\tu32 pld_crc;\n\tint device_type;\n\tacpi_handle handle;\t\t \n\tstruct fwnode_handle fwnode;\n\tstruct list_head wakeup_list;\n\tstruct list_head del_list;\n\tstruct acpi_device_status status;\n\tstruct acpi_device_flags flags;\n\tstruct acpi_device_pnp pnp;\n\tstruct acpi_device_power power;\n\tstruct acpi_device_wakeup wakeup;\n\tstruct acpi_device_perf performance;\n\tstruct acpi_device_dir dir;\n\tstruct acpi_device_data data;\n\tstruct acpi_scan_handler *handler;\n\tstruct acpi_hotplug_context *hp;\n\tconst struct acpi_gpio_mapping *driver_gpios;\n\tvoid *driver_data;\n\tstruct device dev;\n\tunsigned int physical_node_count;\n\tunsigned int dep_unmet;\n\tstruct list_head physical_node_list;\n\tstruct mutex physical_node_lock;\n\tvoid (*remove)(struct acpi_device *);\n};\n\n \nstruct acpi_data_node {\n\tconst char *name;\n\tacpi_handle handle;\n\tstruct fwnode_handle fwnode;\n\tstruct fwnode_handle *parent;\n\tstruct acpi_device_data data;\n\tstruct list_head sibling;\n\tstruct kobject kobj;\n\tstruct completion kobj_done;\n};\n\nextern const struct fwnode_operations acpi_device_fwnode_ops;\nextern const struct fwnode_operations acpi_data_fwnode_ops;\nextern const struct fwnode_operations acpi_static_fwnode_ops;\n\nbool is_acpi_device_node(const struct fwnode_handle *fwnode);\nbool is_acpi_data_node(const struct fwnode_handle *fwnode);\n\nstatic inline bool is_acpi_node(const struct fwnode_handle *fwnode)\n{\n\treturn (is_acpi_device_node(fwnode) || is_acpi_data_node(fwnode));\n}\n\n#define to_acpi_device_node(__fwnode)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\ttypeof(__fwnode) __to_acpi_device_node_fwnode = __fwnode; \\\n\t\t\t\t\t\t\t\t\t\\\n\t\tis_acpi_device_node(__to_acpi_device_node_fwnode) ?\t\\\n\t\t\tcontainer_of(__to_acpi_device_node_fwnode,\t\\\n\t\t\t\t     struct acpi_device, fwnode) :\t\\\n\t\t\tNULL;\t\t\t\t\t\t\\\n\t})\n\n#define to_acpi_data_node(__fwnode)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\ttypeof(__fwnode) __to_acpi_data_node_fwnode = __fwnode;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tis_acpi_data_node(__to_acpi_data_node_fwnode) ?\t\t\\\n\t\t\tcontainer_of(__to_acpi_data_node_fwnode,\t\\\n\t\t\t\t     struct acpi_data_node, fwnode) :\t\\\n\t\t\tNULL;\t\t\t\t\t\t\\\n\t})\n\nstatic inline bool is_acpi_static_node(const struct fwnode_handle *fwnode)\n{\n\treturn !IS_ERR_OR_NULL(fwnode) &&\n\t\tfwnode->ops == &acpi_static_fwnode_ops;\n}\n\nstatic inline bool acpi_data_node_match(const struct fwnode_handle *fwnode,\n\t\t\t\t\tconst char *name)\n{\n\treturn is_acpi_data_node(fwnode) ?\n\t\t(!strcmp(to_acpi_data_node(fwnode)->name, name)) : false;\n}\n\nstatic inline struct fwnode_handle *acpi_fwnode_handle(struct acpi_device *adev)\n{\n\treturn &adev->fwnode;\n}\n\nstatic inline void *acpi_driver_data(struct acpi_device *d)\n{\n\treturn d->driver_data;\n}\n\n#define to_acpi_device(d)\tcontainer_of(d, struct acpi_device, dev)\n#define to_acpi_driver(d)\tcontainer_of(d, struct acpi_driver, drv)\n\nstatic inline struct acpi_device *acpi_dev_parent(struct acpi_device *adev)\n{\n\tif (adev->dev.parent)\n\t\treturn to_acpi_device(adev->dev.parent);\n\n\treturn NULL;\n}\n\nstatic inline void acpi_set_device_status(struct acpi_device *adev, u32 sta)\n{\n\t*((u32 *)&adev->status) = sta;\n}\n\nstatic inline void acpi_set_hp_context(struct acpi_device *adev,\n\t\t\t\t       struct acpi_hotplug_context *hp)\n{\n\thp->self = adev;\n\tadev->hp = hp;\n}\n\nvoid acpi_initialize_hp_context(struct acpi_device *adev,\n\t\t\t\tstruct acpi_hotplug_context *hp,\n\t\t\t\tint (*notify)(struct acpi_device *, u32),\n\t\t\t\tvoid (*uevent)(struct acpi_device *, u32));\n\n \nextern struct bus_type acpi_bus_type;\n\nint acpi_bus_for_each_dev(int (*fn)(struct device *, void *), void *data);\nint acpi_dev_for_each_child(struct acpi_device *adev,\n\t\t\t    int (*fn)(struct acpi_device *, void *), void *data);\nint acpi_dev_for_each_child_reverse(struct acpi_device *adev,\n\t\t\t\t    int (*fn)(struct acpi_device *, void *),\n\t\t\t\t    void *data);\n\n \n\nstruct acpi_bus_event {\n\tstruct list_head node;\n\tacpi_device_class device_class;\n\tacpi_bus_id bus_id;\n\tu32 type;\n\tu32 data;\n};\n\nextern struct kobject *acpi_kobj;\nextern int acpi_bus_generate_netlink_event(const char*, const char*, u8, int);\nvoid acpi_bus_private_data_handler(acpi_handle, void *);\nint acpi_bus_get_private_data(acpi_handle, void **);\nint acpi_bus_attach_private_data(acpi_handle, void *);\nvoid acpi_bus_detach_private_data(acpi_handle);\nint acpi_dev_install_notify_handler(struct acpi_device *adev,\n\t\t\t\t    u32 handler_type,\n\t\t\t\t    acpi_notify_handler handler);\nvoid acpi_dev_remove_notify_handler(struct acpi_device *adev,\n\t\t\t\t    u32 handler_type,\n\t\t\t\t    acpi_notify_handler handler);\nextern int acpi_notifier_call_chain(struct acpi_device *, u32, u32);\nextern int register_acpi_notifier(struct notifier_block *);\nextern int unregister_acpi_notifier(struct notifier_block *);\n\n \n\nacpi_status acpi_bus_get_status_handle(acpi_handle handle,\n\t\t\t\t       unsigned long long *sta);\nint acpi_bus_get_status(struct acpi_device *device);\n\nint acpi_bus_set_power(acpi_handle handle, int state);\nconst char *acpi_power_state_string(int state);\nint acpi_device_set_power(struct acpi_device *device, int state);\nint acpi_bus_init_power(struct acpi_device *device);\nint acpi_device_fix_up_power(struct acpi_device *device);\nvoid acpi_device_fix_up_power_extended(struct acpi_device *adev);\nvoid acpi_device_fix_up_power_children(struct acpi_device *adev);\nint acpi_bus_update_power(acpi_handle handle, int *state_p);\nint acpi_device_update_power(struct acpi_device *device, int *state_p);\nbool acpi_bus_power_manageable(acpi_handle handle);\nvoid acpi_dev_power_up_children_with_adr(struct acpi_device *adev);\nu8 acpi_dev_power_state_for_wake(struct acpi_device *adev);\nint acpi_device_power_add_dependent(struct acpi_device *adev,\n\t\t\t\t    struct device *dev);\nvoid acpi_device_power_remove_dependent(struct acpi_device *adev,\n\t\t\t\t\tstruct device *dev);\n\n#ifdef CONFIG_PM\nbool acpi_bus_can_wakeup(acpi_handle handle);\n#else\nstatic inline bool acpi_bus_can_wakeup(acpi_handle handle) { return false; }\n#endif\n\nvoid acpi_scan_lock_acquire(void);\nvoid acpi_scan_lock_release(void);\nvoid acpi_lock_hp_context(void);\nvoid acpi_unlock_hp_context(void);\nint acpi_scan_add_handler(struct acpi_scan_handler *handler);\nint acpi_bus_register_driver(struct acpi_driver *driver);\nvoid acpi_bus_unregister_driver(struct acpi_driver *driver);\nint acpi_bus_scan(acpi_handle handle);\nvoid acpi_bus_trim(struct acpi_device *start);\nacpi_status acpi_bus_get_ejd(acpi_handle handle, acpi_handle * ejd);\nint acpi_match_device_ids(struct acpi_device *device,\n\t\t\t  const struct acpi_device_id *ids);\nvoid acpi_set_modalias(struct acpi_device *adev, const char *default_id,\n\t\t       char *modalias, size_t len);\n\nstatic inline bool acpi_device_enumerated(struct acpi_device *adev)\n{\n\treturn adev && adev->flags.initialized && adev->flags.visited;\n}\n\n \n#define module_acpi_driver(__acpi_driver) \\\n\tmodule_driver(__acpi_driver, acpi_bus_register_driver, \\\n\t\t      acpi_bus_unregister_driver)\n\n \nstruct acpi_bus_type {\n\tstruct list_head list;\n\tconst char *name;\n\tbool (*match)(struct device *dev);\n\tstruct acpi_device * (*find_companion)(struct device *);\n\tvoid (*setup)(struct device *);\n};\nint register_acpi_bus_type(struct acpi_bus_type *);\nint unregister_acpi_bus_type(struct acpi_bus_type *);\nint acpi_bind_one(struct device *dev, struct acpi_device *adev);\nint acpi_unbind_one(struct device *dev);\n\nenum acpi_bridge_type {\n\tACPI_BRIDGE_TYPE_PCIE = 1,\n\tACPI_BRIDGE_TYPE_CXL,\n};\n\nstruct acpi_pci_root {\n\tstruct acpi_device * device;\n\tstruct pci_bus *bus;\n\tu16 segment;\n\tint bridge_type;\n\tstruct resource secondary;\t \n\n\tu32 osc_support_set;\t\t \n\tu32 osc_control_set;\t\t \n\tu32 osc_ext_support_set;\t \n\tu32 osc_ext_control_set;\t \n\tphys_addr_t mcfg_addr;\n};\n\n \n\nbool acpi_dma_supported(const struct acpi_device *adev);\nenum dev_dma_attr acpi_get_dma_attr(struct acpi_device *adev);\nint acpi_iommu_fwspec_init(struct device *dev, u32 id,\n\t\t\t   struct fwnode_handle *fwnode,\n\t\t\t   const struct iommu_ops *ops);\nint acpi_dma_get_range(struct device *dev, const struct bus_dma_region **map);\nint acpi_dma_configure_id(struct device *dev, enum dev_dma_attr attr,\n\t\t\t   const u32 *input_id);\nstatic inline int acpi_dma_configure(struct device *dev,\n\t\t\t\t     enum dev_dma_attr attr)\n{\n\treturn acpi_dma_configure_id(dev, attr, NULL);\n}\nstruct acpi_device *acpi_find_child_device(struct acpi_device *parent,\n\t\t\t\t\t   u64 address, bool check_children);\nstruct acpi_device *acpi_find_child_by_adr(struct acpi_device *adev,\n\t\t\t\t\t   acpi_bus_address adr);\nint acpi_is_root_bridge(acpi_handle);\nstruct acpi_pci_root *acpi_pci_find_root(acpi_handle handle);\n\nint acpi_enable_wakeup_device_power(struct acpi_device *dev, int state);\nint acpi_disable_wakeup_device_power(struct acpi_device *dev);\n\n#ifdef CONFIG_X86\nbool acpi_device_override_status(struct acpi_device *adev, unsigned long long *status);\nbool acpi_quirk_skip_acpi_ac_and_battery(void);\nint acpi_install_cmos_rtc_space_handler(acpi_handle handle);\nvoid acpi_remove_cmos_rtc_space_handler(acpi_handle handle);\n#else\nstatic inline bool acpi_device_override_status(struct acpi_device *adev,\n\t\t\t\t\t       unsigned long long *status)\n{\n\treturn false;\n}\nstatic inline bool acpi_quirk_skip_acpi_ac_and_battery(void)\n{\n\treturn false;\n}\nstatic inline int acpi_install_cmos_rtc_space_handler(acpi_handle handle)\n{\n\treturn 1;\n}\nstatic inline void acpi_remove_cmos_rtc_space_handler(acpi_handle handle)\n{\n}\n#endif\n\n#if IS_ENABLED(CONFIG_X86_ANDROID_TABLETS)\nbool acpi_quirk_skip_i2c_client_enumeration(struct acpi_device *adev);\nint acpi_quirk_skip_serdev_enumeration(struct device *controller_parent, bool *skip);\nbool acpi_quirk_skip_gpio_event_handlers(void);\n#else\nstatic inline bool acpi_quirk_skip_i2c_client_enumeration(struct acpi_device *adev)\n{\n\treturn false;\n}\nstatic inline int\nacpi_quirk_skip_serdev_enumeration(struct device *controller_parent, bool *skip)\n{\n\t*skip = false;\n\treturn 0;\n}\nstatic inline bool acpi_quirk_skip_gpio_event_handlers(void)\n{\n\treturn false;\n}\n#endif\n\n#ifdef CONFIG_PM\nvoid acpi_pm_wakeup_event(struct device *dev);\nacpi_status acpi_add_pm_notifier(struct acpi_device *adev, struct device *dev,\n\t\t\tvoid (*func)(struct acpi_device_wakeup_context *context));\nacpi_status acpi_remove_pm_notifier(struct acpi_device *adev);\nbool acpi_pm_device_can_wakeup(struct device *dev);\nint acpi_pm_device_sleep_state(struct device *, int *, int);\nint acpi_pm_set_device_wakeup(struct device *dev, bool enable);\n#else\nstatic inline void acpi_pm_wakeup_event(struct device *dev)\n{\n}\nstatic inline acpi_status acpi_add_pm_notifier(struct acpi_device *adev,\n\t\t\t\t\t       struct device *dev,\n\t\t\t\t\t       void (*func)(struct acpi_device_wakeup_context *context))\n{\n\treturn AE_SUPPORT;\n}\nstatic inline acpi_status acpi_remove_pm_notifier(struct acpi_device *adev)\n{\n\treturn AE_SUPPORT;\n}\nstatic inline bool acpi_pm_device_can_wakeup(struct device *dev)\n{\n\treturn false;\n}\nstatic inline int acpi_pm_device_sleep_state(struct device *d, int *p, int m)\n{\n\tif (p)\n\t\t*p = ACPI_STATE_D0;\n\n\treturn (m >= ACPI_STATE_D0 && m <= ACPI_STATE_D3_COLD) ?\n\t\tm : ACPI_STATE_D0;\n}\nstatic inline int acpi_pm_set_device_wakeup(struct device *dev, bool enable)\n{\n\treturn -ENODEV;\n}\n#endif\n\n#ifdef CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT\nbool acpi_sleep_state_supported(u8 sleep_state);\n#else\nstatic inline bool acpi_sleep_state_supported(u8 sleep_state) { return false; }\n#endif\n\n#ifdef CONFIG_ACPI_SLEEP\nu32 acpi_target_system_state(void);\n#else\nstatic inline u32 acpi_target_system_state(void) { return ACPI_STATE_S0; }\n#endif\n\nstatic inline bool acpi_device_power_manageable(struct acpi_device *adev)\n{\n\treturn adev->flags.power_manageable;\n}\n\nstatic inline bool acpi_device_can_wakeup(struct acpi_device *adev)\n{\n\treturn adev->wakeup.flags.valid;\n}\n\nstatic inline bool acpi_device_can_poweroff(struct acpi_device *adev)\n{\n\treturn adev->power.states[ACPI_STATE_D3_COLD].flags.valid ||\n\t\t((acpi_gbl_FADT.header.revision < 6) &&\n\t\tadev->power.states[ACPI_STATE_D3_HOT].flags.explicit_set);\n}\n\nbool acpi_dev_hid_uid_match(struct acpi_device *adev, const char *hid2, const char *uid2);\nint acpi_dev_uid_to_integer(struct acpi_device *adev, u64 *integer);\n\nvoid acpi_dev_clear_dependencies(struct acpi_device *supplier);\nbool acpi_dev_ready_for_enumeration(const struct acpi_device *device);\nstruct acpi_device *acpi_dev_get_next_consumer_dev(struct acpi_device *supplier,\n\t\t\t\t\t\t   struct acpi_device *start);\n\n \n#define for_each_acpi_consumer_dev(supplier, consumer)\t\t\t\\\n\tfor (consumer = acpi_dev_get_next_consumer_dev(supplier, NULL);\t\\\n\t     consumer;\t\t\t\t\t\t\t\\\n\t     consumer = acpi_dev_get_next_consumer_dev(supplier, consumer))\n\nstruct acpi_device *\nacpi_dev_get_next_match_dev(struct acpi_device *adev, const char *hid, const char *uid, s64 hrv);\nstruct acpi_device *\nacpi_dev_get_first_match_dev(const char *hid, const char *uid, s64 hrv);\n\n \n#define for_each_acpi_dev_match(adev, hid, uid, hrv)\t\t\t\\\n\tfor (adev = acpi_dev_get_first_match_dev(hid, uid, hrv);\t\\\n\t     adev;\t\t\t\t\t\t\t\\\n\t     adev = acpi_dev_get_next_match_dev(adev, hid, uid, hrv))\n\nstatic inline struct acpi_device *acpi_dev_get(struct acpi_device *adev)\n{\n\treturn adev ? to_acpi_device(get_device(&adev->dev)) : NULL;\n}\n\nstatic inline void acpi_dev_put(struct acpi_device *adev)\n{\n\tif (adev)\n\t\tput_device(&adev->dev);\n}\n\nstruct acpi_device *acpi_fetch_acpi_dev(acpi_handle handle);\nstruct acpi_device *acpi_get_acpi_dev(acpi_handle handle);\n\nstatic inline void acpi_put_acpi_dev(struct acpi_device *adev)\n{\n\tacpi_dev_put(adev);\n}\n#else\t \n\nstatic inline int register_acpi_bus_type(void *bus) { return 0; }\nstatic inline int unregister_acpi_bus_type(void *bus) { return 0; }\n\n#endif\t\t\t\t \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}