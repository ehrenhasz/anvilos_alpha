{
  "module_name": "trace_events.h",
  "hash_id": "b0cef974844e1476f9e45d8c1af414d67cd479891f537594d55a45fc7f3bf1d9",
  "original_prompt": "Ingested from linux-6.6.14/include/trace/trace_events.h",
  "human_readable_source": " \n \n\n#include <linux/trace_events.h>\n\n#ifndef TRACE_SYSTEM_VAR\n#define TRACE_SYSTEM_VAR TRACE_SYSTEM\n#endif\n\n#include \"stages/init.h\"\n\n \n#undef TRACE_EVENT\n#define TRACE_EVENT(name, proto, args, tstruct, assign, print) \\\n\tDECLARE_EVENT_CLASS(name,\t\t\t       \\\n\t\t\t     PARAMS(proto),\t\t       \\\n\t\t\t     PARAMS(args),\t\t       \\\n\t\t\t     PARAMS(tstruct),\t\t       \\\n\t\t\t     PARAMS(assign),\t\t       \\\n\t\t\t     PARAMS(print));\t\t       \\\n\tDEFINE_EVENT(name, name, PARAMS(proto), PARAMS(args));\n\n#include \"stages/stage1_struct_define.h\"\n\n#undef DECLARE_EVENT_CLASS\n#define DECLARE_EVENT_CLASS(name, proto, args, tstruct, assign, print)\t\\\n\tstruct trace_event_raw_##name {\t\t\t\t\t\\\n\t\tstruct trace_entry\tent;\t\t\t\t\\\n\t\ttstruct\t\t\t\t\t\t\t\\\n\t\tchar\t\t\t__data[];\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tstatic struct trace_event_class event_class_##name;\n\n#undef DEFINE_EVENT\n#define DEFINE_EVENT(template, name, proto, args)\t\\\n\tstatic struct trace_event_call\t__used\t\t\\\n\t__attribute__((__aligned__(4))) event_##name\n\n#undef DEFINE_EVENT_FN\n#define DEFINE_EVENT_FN(template, name, proto, args, reg, unreg)\t\\\n\tDEFINE_EVENT(template, name, PARAMS(proto), PARAMS(args))\n\n#undef DEFINE_EVENT_PRINT\n#define DEFINE_EVENT_PRINT(template, name, proto, args, print)\t\\\n\tDEFINE_EVENT(template, name, PARAMS(proto), PARAMS(args))\n\n \n#undef TRACE_EVENT_FN\n#define TRACE_EVENT_FN(name, proto, args, tstruct,\t\t\t\\\n\t\tassign, print, reg, unreg)\t\t\t\t\\\n\tTRACE_EVENT(name, PARAMS(proto), PARAMS(args),\t\t\t\\\n\t\tPARAMS(tstruct), PARAMS(assign), PARAMS(print))\t\t\\\n\n#undef TRACE_EVENT_FN_COND\n#define TRACE_EVENT_FN_COND(name, proto, args, cond, tstruct,\t\\\n\t\tassign, print, reg, unreg)\t\t\t\t\\\n\tTRACE_EVENT_CONDITION(name, PARAMS(proto), PARAMS(args), PARAMS(cond),\t\t\\\n\t\tPARAMS(tstruct), PARAMS(assign), PARAMS(print))\t\t\\\n\n#undef TRACE_EVENT_FLAGS\n#define TRACE_EVENT_FLAGS(name, value)\t\t\t\t\t\\\n\t__TRACE_EVENT_FLAGS(name, value)\n\n#undef TRACE_EVENT_PERF_PERM\n#define TRACE_EVENT_PERF_PERM(name, expr...)\t\t\t\t\\\n\t__TRACE_EVENT_PERF_PERM(name, expr)\n\n#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)\n\n \n\n#include \"stages/stage2_data_offsets.h\"\n\n#undef DECLARE_EVENT_CLASS\n#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)\t\\\n\tstruct trace_event_data_offsets_##call {\t\t\t\\\n\t\ttstruct;\t\t\t\t\t\t\\\n\t};\n\n#undef DEFINE_EVENT\n#define DEFINE_EVENT(template, name, proto, args)\n\n#undef DEFINE_EVENT_PRINT\n#define DEFINE_EVENT_PRINT(template, name, proto, args, print)\n\n#undef TRACE_EVENT_FLAGS\n#define TRACE_EVENT_FLAGS(event, flag)\n\n#undef TRACE_EVENT_PERF_PERM\n#define TRACE_EVENT_PERF_PERM(event, expr...)\n\n#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)\n\n \n\n#include \"stages/stage3_trace_output.h\"\n\n#undef DECLARE_EVENT_CLASS\n#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)\t\\\nstatic notrace enum print_line_t\t\t\t\t\t\\\ntrace_raw_output_##call(struct trace_iterator *iter, int flags,\t\t\\\n\t\t\tstruct trace_event *trace_event)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct trace_seq *s = &iter->seq;\t\t\t\t\\\n\tstruct trace_seq __maybe_unused *p = &iter->tmp_seq;\t\t\\\n\tstruct trace_event_raw_##call *field;\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfield = (typeof(field))iter->ent;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = trace_raw_output_prep(iter, trace_event);\t\t\t\\\n\tif (ret != TRACE_TYPE_HANDLED)\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ttrace_event_printf(iter, print);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn trace_handle_return(s);\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic struct trace_event_functions trace_event_type_funcs_##call = {\t\\\n\t.trace\t\t\t= trace_raw_output_##call,\t\t\\\n};\n\n#undef DEFINE_EVENT_PRINT\n#define DEFINE_EVENT_PRINT(template, call, proto, args, print)\t\t\\\nstatic notrace enum print_line_t\t\t\t\t\t\\\ntrace_raw_output_##call(struct trace_iterator *iter, int flags,\t\t\\\n\t\t\t struct trace_event *event)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct trace_event_raw_##template *field;\t\t\t\\\n\tstruct trace_entry *entry;\t\t\t\t\t\\\n\tstruct trace_seq *p = &iter->tmp_seq;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tentry = iter->ent;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (entry->type != event_##call.event.type) {\t\t\t\\\n\t\tWARN_ON_ONCE(1);\t\t\t\t\t\\\n\t\treturn TRACE_TYPE_UNHANDLED;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfield = (typeof(field))entry;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ttrace_seq_init(p);\t\t\t\t\t\t\\\n\treturn trace_output_call(iter, #call, print);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic struct trace_event_functions trace_event_type_funcs_##call = {\t\\\n\t.trace\t\t\t= trace_raw_output_##call,\t\t\\\n};\n\n#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)\n\n#include \"stages/stage4_event_fields.h\"\n\n#undef DECLARE_EVENT_CLASS\n#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, func, print)\t\\\nstatic struct trace_event_fields trace_event_fields_##call[] = {\t\\\n\ttstruct\t\t\t\t\t\t\t\t\\\n\t{} };\n\n#undef DEFINE_EVENT_PRINT\n#define DEFINE_EVENT_PRINT(template, name, proto, args, print)\n\n#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)\n\n#include \"stages/stage5_get_offsets.h\"\n\n#undef DECLARE_EVENT_CLASS\n#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)\t\\\nstatic inline notrace int trace_event_get_offsets_##call(\t\t\\\n\tstruct trace_event_data_offsets_##call *__data_offsets, proto)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint __data_size = 0;\t\t\t\t\t\t\\\n\tint __maybe_unused __item_length;\t\t\t\t\\\n\tstruct trace_event_raw_##call __maybe_unused *entry;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ttstruct;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn __data_size;\t\t\t\t\t\t\\\n}\n\n#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)\n\n \n\n#ifdef CONFIG_PERF_EVENTS\n\n#define _TRACE_PERF_PROTO(call, proto)\t\t\t\t\t\\\n\tstatic notrace void\t\t\t\t\t\t\\\n\tperf_trace_##call(void *__data, proto);\n\n#define _TRACE_PERF_INIT(call)\t\t\t\t\t\t\\\n\t.perf_probe\t\t= perf_trace_##call,\n\n#else\n#define _TRACE_PERF_PROTO(call, proto)\n#define _TRACE_PERF_INIT(call)\n#endif  \n\n#include \"stages/stage6_event_callback.h\"\n\n#undef DECLARE_EVENT_CLASS\n#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic notrace void\t\t\t\t\t\t\t\\\ntrace_event_raw_event_##call(void *__data, proto)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct trace_event_file *trace_file = __data;\t\t\t\\\n\tstruct trace_event_data_offsets_##call __maybe_unused __data_offsets;\\\n\tstruct trace_event_buffer fbuffer;\t\t\t\t\\\n\tstruct trace_event_raw_##call *entry;\t\t\t\t\\\n\tint __data_size;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (trace_trigger_soft_disabled(trace_file))\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__data_size = trace_event_get_offsets_##call(&__data_offsets, args); \\\n\t\t\t\t\t\t\t\t\t\\\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\t\\\n\t\t\t\t sizeof(*entry) + __data_size);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!entry)\t\t\t\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ttstruct\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t{ assign; }\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ttrace_event_buffer_commit(&fbuffer);\t\t\t\t\\\n}\n \n\n#undef DEFINE_EVENT\n#define DEFINE_EVENT(template, call, proto, args)\t\t\t\\\nstatic inline void ftrace_test_probe_##call(void)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tcheck_trace_callback_type_##call(trace_event_raw_event_##template); \\\n}\n\n#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)\n\n#include \"stages/stage7_class_define.h\"\n\n#undef DECLARE_EVENT_CLASS\n#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)\t\\\n_TRACE_PERF_PROTO(call, PARAMS(proto));\t\t\t\t\t\\\nstatic char print_fmt_##call[] = print;\t\t\t\t\t\\\nstatic struct trace_event_class __used __refdata event_class_##call = { \\\n\t.system\t\t\t= TRACE_SYSTEM_STRING,\t\t\t\\\n\t.fields_array\t\t= trace_event_fields_##call,\t\t\\\n\t.fields\t\t\t= LIST_HEAD_INIT(event_class_##call.fields),\\\n\t.raw_init\t\t= trace_event_raw_init,\t\t\t\\\n\t.probe\t\t\t= trace_event_raw_event_##call,\t\t\\\n\t.reg\t\t\t= trace_event_reg,\t\t\t\\\n\t_TRACE_PERF_INIT(call)\t\t\t\t\t\t\\\n};\n\n#undef DEFINE_EVENT\n#define DEFINE_EVENT(template, call, proto, args)\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic struct trace_event_call __used event_##call = {\t\t\t\\\n\t.class\t\t\t= &event_class_##template,\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.tp\t\t\t= &__tracepoint_##call,\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.event.funcs\t\t= &trace_event_type_funcs_##template,\t\\\n\t.print_fmt\t\t= print_fmt_##template,\t\t\t\\\n\t.flags\t\t\t= TRACE_EVENT_FL_TRACEPOINT,\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\nstatic struct trace_event_call __used\t\t\t\t\t\\\n__section(\"_ftrace_events\") *__event_##call = &event_##call\n\n#undef DEFINE_EVENT_PRINT\n#define DEFINE_EVENT_PRINT(template, call, proto, args, print)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic char print_fmt_##call[] = print;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic struct trace_event_call __used event_##call = {\t\t\t\\\n\t.class\t\t\t= &event_class_##template,\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.tp\t\t\t= &__tracepoint_##call,\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.event.funcs\t\t= &trace_event_type_funcs_##call,\t\\\n\t.print_fmt\t\t= print_fmt_##call,\t\t\t\\\n\t.flags\t\t\t= TRACE_EVENT_FL_TRACEPOINT,\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\nstatic struct trace_event_call __used\t\t\t\t\t\\\n__section(\"_ftrace_events\") *__event_##call = &event_##call\n\n#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}