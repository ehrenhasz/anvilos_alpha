{
  "module_name": "neigh.h",
  "hash_id": "1e8b473e82502d8c824dd99cdbe034419894269470e2112b1af8d4fb99038398",
  "original_prompt": "Ingested from linux-6.6.14/include/trace/events/neigh.h",
  "human_readable_source": "#undef TRACE_SYSTEM\n#define TRACE_SYSTEM neigh\n\n#if !defined(_TRACE_NEIGH_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_NEIGH_H\n\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/tracepoint.h>\n#include <net/neighbour.h>\n\n#define neigh_state_str(state)\t\t\t\t\\\n\t__print_symbolic(state,\t\t\t\t\\\n\t\t{ NUD_INCOMPLETE, \"incomplete\" },\t\\\n\t\t{ NUD_REACHABLE, \"reachable\" },\t\t\\\n\t\t{ NUD_STALE, \"stale\" },\t\t\t\\\n\t\t{ NUD_DELAY, \"delay\" },\t\t\t\\\n\t\t{ NUD_PROBE, \"probe\" },\t\t\t\\\n\t\t{ NUD_FAILED, \"failed\" },\t\t\\\n\t\t{ NUD_NOARP, \"noarp\" },\t\t\t\\\n\t\t{ NUD_PERMANENT, \"permanent\"})\n\nTRACE_EVENT(neigh_create,\n\n\tTP_PROTO(struct neigh_table *tbl, struct net_device *dev,\n\t\t const void *pkey, const struct neighbour *n,\n\t\t bool exempt_from_gc),\n\n\tTP_ARGS(tbl, dev, pkey, n, exempt_from_gc),\n\n\tTP_STRUCT__entry(\n\t\t__field(u32, family)\n\t\t__string(dev, dev ? dev->name : \"NULL\")\n\t\t__field(int, entries)\n\t\t__field(u8, created)\n\t\t__field(u8, gc_exempt)\n\t\t__array(u8, primary_key4, 4)\n\t\t__array(u8, primary_key6, 16)\n\t),\n\n\tTP_fast_assign(\n\t\t__be32 *p32;\n\n\t\t__entry->family = tbl->family;\n\t\t__assign_str(dev, (dev ? dev->name : \"NULL\"));\n\t\t__entry->entries = atomic_read(&tbl->gc_entries);\n\t\t__entry->created = n != NULL;\n\t\t__entry->gc_exempt = exempt_from_gc;\n\t\tp32 = (__be32 *)__entry->primary_key4;\n\n\t\tif (tbl->family == AF_INET)\n\t\t\t*p32 = *(__be32 *)pkey;\n\t\telse\n\t\t\t*p32 = 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (tbl->family == AF_INET6) {\n\t\t\tstruct in6_addr *pin6;\n\n\t\t\tpin6 = (struct in6_addr *)__entry->primary_key6;\n\t\t\t*pin6 = *(struct in6_addr *)pkey;\n\t\t}\n#endif\n\t),\n\n\tTP_printk(\"family %d dev %s entries %d primary_key4 %pI4 primary_key6 %pI6c created %d gc_exempt %d\",\n\t\t  __entry->family, __get_str(dev), __entry->entries,\n\t\t  __entry->primary_key4, __entry->primary_key6,\n\t\t  __entry->created, __entry->gc_exempt)\n);\n\nTRACE_EVENT(neigh_update,\n\n\tTP_PROTO(struct neighbour *n, const u8 *lladdr, u8 new,\n\t\t u32 flags, u32 nlmsg_pid),\n\n\tTP_ARGS(n, lladdr, new, flags, nlmsg_pid),\n\n\tTP_STRUCT__entry(\n\t\t__field(u32, family)\n\t\t__string(dev, (n->dev ? n->dev->name : \"NULL\"))\n\t\t__array(u8, lladdr, MAX_ADDR_LEN)\n\t\t__field(u8, lladdr_len)\n\t\t__field(u8, flags)\n\t\t__field(u8, nud_state)\n\t\t__field(u8, type)\n\t\t__field(u8, dead)\n\t\t__field(int, refcnt)\n\t\t__array(__u8, primary_key4, 4)\n\t\t__array(__u8, primary_key6, 16)\n\t\t__field(unsigned long, confirmed)\n\t\t__field(unsigned long, updated)\n\t\t__field(unsigned long, used)\n\t\t__array(u8, new_lladdr, MAX_ADDR_LEN)\n\t\t__field(u8, new_state)\n\t\t__field(u32, update_flags)\n\t\t__field(u32, pid)\n\t),\n\n\tTP_fast_assign(\n\t\tint lladdr_len = (n->dev ? n->dev->addr_len : MAX_ADDR_LEN);\n\t\tstruct in6_addr *pin6;\n\t\t__be32 *p32;\n\n\t\t__entry->family = n->tbl->family;\n\t\t__assign_str(dev, (n->dev ? n->dev->name : \"NULL\"));\n\t\t__entry->lladdr_len = lladdr_len;\n\t\tmemcpy(__entry->lladdr, n->ha, lladdr_len);\n\t\t__entry->flags = n->flags;\n\t\t__entry->nud_state = n->nud_state;\n\t\t__entry->type = n->type;\n\t\t__entry->dead = n->dead;\n\t\t__entry->refcnt = refcount_read(&n->refcnt);\n\t\tpin6 = (struct in6_addr *)__entry->primary_key6;\n\t\tp32 = (__be32 *)__entry->primary_key4;\n\n\t\tif (n->tbl->family == AF_INET)\n\t\t\t*p32 = *(__be32 *)n->primary_key;\n\t\telse\n\t\t\t*p32 = 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (n->tbl->family == AF_INET6) {\n\t\t\tpin6 = (struct in6_addr *)__entry->primary_key6;\n\t\t\t*pin6 = *(struct in6_addr *)n->primary_key;\n\t\t} else\n#endif\n\t\t{\n\t\t\tipv6_addr_set_v4mapped(*p32, pin6);\n\t\t}\n\t\t__entry->confirmed = n->confirmed;\n\t\t__entry->updated = n->updated;\n\t\t__entry->used = n->used;\n\t\tif (lladdr)\n\t\t\tmemcpy(__entry->new_lladdr, lladdr, lladdr_len);\n\t\t__entry->new_state = new;\n\t\t__entry->update_flags = flags;\n\t\t__entry->pid = nlmsg_pid;\n\t),\n\n\tTP_printk(\"family %d dev %s lladdr %s flags %02x nud_state %s type %02x \"\n\t\t  \"dead %d refcnt %d primary_key4 %pI4 primary_key6 %pI6c \"\n\t\t  \"confirmed %lu updated %lu used %lu new_lladdr %s \"\n\t\t  \"new_state %s update_flags %02x pid %d\",\n\t\t  __entry->family, __get_str(dev),\n\t\t  __print_hex_str(__entry->lladdr, __entry->lladdr_len),\n\t\t  __entry->flags, neigh_state_str(__entry->nud_state),\n\t\t  __entry->type, __entry->dead, __entry->refcnt,\n\t\t  __entry->primary_key4, __entry->primary_key6,\n\t\t  __entry->confirmed, __entry->updated, __entry->used,\n\t\t  __print_hex_str(__entry->new_lladdr, __entry->lladdr_len),\n\t\t  neigh_state_str(__entry->new_state),\n\t\t  __entry->update_flags, __entry->pid)\n);\n\nDECLARE_EVENT_CLASS(neigh__update,\n\tTP_PROTO(struct neighbour *n, int err),\n\tTP_ARGS(n, err),\n\tTP_STRUCT__entry(\n\t\t__field(u32, family)\n\t\t__string(dev, (n->dev ? n->dev->name : \"NULL\"))\n\t\t__array(u8, lladdr, MAX_ADDR_LEN)\n\t\t__field(u8, lladdr_len)\n\t\t__field(u8, flags)\n\t\t__field(u8, nud_state)\n\t\t__field(u8, type)\n\t\t__field(u8, dead)\n\t\t__field(int, refcnt)\n\t\t__array(__u8, primary_key4, 4)\n\t\t__array(__u8, primary_key6, 16)\n\t\t__field(unsigned long, confirmed)\n\t\t__field(unsigned long, updated)\n\t\t__field(unsigned long, used)\n\t\t__field(u32, err)\n\t),\n\n\tTP_fast_assign(\n\t\tint lladdr_len = (n->dev ? n->dev->addr_len : MAX_ADDR_LEN);\n\t\tstruct in6_addr *pin6;\n\t\t__be32 *p32;\n\n\t\t__entry->family = n->tbl->family;\n\t\t__assign_str(dev, (n->dev ? n->dev->name : \"NULL\"));\n\t\t__entry->lladdr_len = lladdr_len;\n\t\tmemcpy(__entry->lladdr, n->ha, lladdr_len);\n\t\t__entry->flags = n->flags;\n\t\t__entry->nud_state = n->nud_state;\n\t\t__entry->type = n->type;\n\t\t__entry->dead = n->dead;\n\t\t__entry->refcnt = refcount_read(&n->refcnt);\n\t\tpin6 = (struct in6_addr *)__entry->primary_key6;\n\t\tp32 = (__be32 *)__entry->primary_key4;\n\n\t\tif (n->tbl->family == AF_INET)\n\t\t\t*p32 = *(__be32 *)n->primary_key;\n\t\telse\n\t\t\t*p32 = 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (n->tbl->family == AF_INET6) {\n\t\t\tpin6 = (struct in6_addr *)__entry->primary_key6;\n\t\t\t*pin6 = *(struct in6_addr *)n->primary_key;\n\t\t} else\n#endif\n\t\t{\n\t\t\tipv6_addr_set_v4mapped(*p32, pin6);\n\t\t}\n\n\t\t__entry->confirmed = n->confirmed;\n\t\t__entry->updated = n->updated;\n\t\t__entry->used = n->used;\n\t\t__entry->err = err;\n\t),\n\n\tTP_printk(\"family %d dev %s lladdr %s flags %02x nud_state %s type %02x \"\n\t\t  \"dead %d refcnt %d primary_key4 %pI4 primary_key6 %pI6c \"\n\t\t  \"confirmed %lu updated %lu used %lu err %d\",\n\t\t  __entry->family, __get_str(dev),\n\t\t  __print_hex_str(__entry->lladdr, __entry->lladdr_len),\n\t\t  __entry->flags, neigh_state_str(__entry->nud_state),\n\t\t  __entry->type, __entry->dead, __entry->refcnt,\n\t\t  __entry->primary_key4, __entry->primary_key6,\n\t\t  __entry->confirmed, __entry->updated, __entry->used,\n\t\t  __entry->err)\n);\n\nDEFINE_EVENT(neigh__update, neigh_update_done,\n\tTP_PROTO(struct neighbour *neigh, int err),\n\tTP_ARGS(neigh, err)\n);\n\nDEFINE_EVENT(neigh__update, neigh_timer_handler,\n\tTP_PROTO(struct neighbour *neigh, int err),\n\tTP_ARGS(neigh, err)\n);\n\nDEFINE_EVENT(neigh__update, neigh_event_send_done,\n\tTP_PROTO(struct neighbour *neigh, int err),\n\tTP_ARGS(neigh, err)\n);\n\nDEFINE_EVENT(neigh__update, neigh_event_send_dead,\n\tTP_PROTO(struct neighbour *neigh, int err),\n\tTP_ARGS(neigh, err)\n);\n\nDEFINE_EVENT(neigh__update, neigh_cleanup_and_release,\n\tTP_PROTO(struct neighbour *neigh, int rc),\n\tTP_ARGS(neigh, rc)\n);\n\n#endif  \n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}