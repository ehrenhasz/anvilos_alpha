{
  "module_name": "smbus.h",
  "hash_id": "86e4f225c99f54aedb270fc01d0f8f2d63b276bd412b71ab56592056e9d44f52",
  "original_prompt": "Ingested from linux-6.6.14/include/trace/events/smbus.h",
  "human_readable_source": " \n \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM smbus\n\n#if !defined(_TRACE_SMBUS_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_SMBUS_H\n\n#include <linux/i2c.h>\n#include <linux/tracepoint.h>\n\n \n\n \nTRACE_EVENT_CONDITION(smbus_write,\n\tTP_PROTO(const struct i2c_adapter *adap,\n\t\t u16 addr, unsigned short flags,\n\t\t char read_write, u8 command, int protocol,\n\t\t const union i2c_smbus_data *data),\n\tTP_ARGS(adap, addr, flags, read_write, command, protocol, data),\n\tTP_CONDITION(read_write == I2C_SMBUS_WRITE ||\n\t\t     protocol == I2C_SMBUS_PROC_CALL ||\n\t\t     protocol == I2C_SMBUS_BLOCK_PROC_CALL),\n\tTP_STRUCT__entry(\n\t\t__field(int,\tadapter_nr\t\t)\n\t\t__field(__u16,\taddr\t\t\t)\n\t\t__field(__u16,\tflags\t\t\t)\n\t\t__field(__u8,\tcommand\t\t\t)\n\t\t__field(__u8,\tlen\t\t\t)\n\t\t__field(__u32,\tprotocol\t\t)\n\t\t__array(__u8, buf, I2C_SMBUS_BLOCK_MAX + 2)\t),\n\tTP_fast_assign(\n\t\t__entry->adapter_nr = adap->nr;\n\t\t__entry->addr = addr;\n\t\t__entry->flags = flags;\n\t\t__entry->command = command;\n\t\t__entry->protocol = protocol;\n\n\t\tswitch (protocol) {\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\t__entry->len = 1;\n\t\t\tgoto copy;\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\t__entry->len = 2;\n\t\t\tgoto copy;\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t\t__entry->len = data->block[0] + 1;\n\t\tcopy:\n\t\t\tmemcpy(__entry->buf, data->block, __entry->len);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_QUICK:\n\t\tcase I2C_SMBUS_BYTE:\n\t\tcase I2C_SMBUS_I2C_BLOCK_BROKEN:\n\t\tdefault:\n\t\t\t__entry->len = 0;\n\t\t}\n\t\t       ),\n\tTP_printk(\"i2c-%d a=%03x f=%04x c=%x %s l=%u [%*phD]\",\n\t\t  __entry->adapter_nr,\n\t\t  __entry->addr,\n\t\t  __entry->flags,\n\t\t  __entry->command,\n\t\t  __print_symbolic(__entry->protocol,\n\t\t\t\t   { I2C_SMBUS_QUICK,\t\t\"QUICK\"\t},\n\t\t\t\t   { I2C_SMBUS_BYTE,\t\t\"BYTE\"\t},\n\t\t\t\t   { I2C_SMBUS_BYTE_DATA,\t\t\"BYTE_DATA\" },\n\t\t\t\t   { I2C_SMBUS_WORD_DATA,\t\t\"WORD_DATA\" },\n\t\t\t\t   { I2C_SMBUS_PROC_CALL,\t\t\"PROC_CALL\" },\n\t\t\t\t   { I2C_SMBUS_BLOCK_DATA,\t\t\"BLOCK_DATA\" },\n\t\t\t\t   { I2C_SMBUS_I2C_BLOCK_BROKEN,\t\"I2C_BLOCK_BROKEN\" },\n\t\t\t\t   { I2C_SMBUS_BLOCK_PROC_CALL,\t\"BLOCK_PROC_CALL\" },\n\t\t\t\t   { I2C_SMBUS_I2C_BLOCK_DATA,\t\"I2C_BLOCK_DATA\" }),\n\t\t  __entry->len,\n\t\t  __entry->len, __entry->buf\n\t\t  ));\n\n \nTRACE_EVENT_CONDITION(smbus_read,\n\tTP_PROTO(const struct i2c_adapter *adap,\n\t\t u16 addr, unsigned short flags,\n\t\t char read_write, u8 command, int protocol),\n\tTP_ARGS(adap, addr, flags, read_write, command, protocol),\n\tTP_CONDITION(!(read_write == I2C_SMBUS_WRITE ||\n\t\t       protocol == I2C_SMBUS_PROC_CALL ||\n\t\t       protocol == I2C_SMBUS_BLOCK_PROC_CALL)),\n\tTP_STRUCT__entry(\n\t\t__field(int,\tadapter_nr\t\t)\n\t\t__field(__u16,\tflags\t\t\t)\n\t\t__field(__u16,\taddr\t\t\t)\n\t\t__field(__u8,\tcommand\t\t\t)\n\t\t__field(__u32,\tprotocol\t\t)\n\t\t__array(__u8, buf, I2C_SMBUS_BLOCK_MAX + 2)\t),\n\tTP_fast_assign(\n\t\t__entry->adapter_nr = adap->nr;\n\t\t__entry->addr = addr;\n\t\t__entry->flags = flags;\n\t\t__entry->command = command;\n\t\t__entry->protocol = protocol;\n\t\t       ),\n\tTP_printk(\"i2c-%d a=%03x f=%04x c=%x %s\",\n\t\t  __entry->adapter_nr,\n\t\t  __entry->addr,\n\t\t  __entry->flags,\n\t\t  __entry->command,\n\t\t  __print_symbolic(__entry->protocol,\n\t\t\t\t   { I2C_SMBUS_QUICK,\t\t\"QUICK\"\t},\n\t\t\t\t   { I2C_SMBUS_BYTE,\t\t\"BYTE\"\t},\n\t\t\t\t   { I2C_SMBUS_BYTE_DATA,\t\t\"BYTE_DATA\" },\n\t\t\t\t   { I2C_SMBUS_WORD_DATA,\t\t\"WORD_DATA\" },\n\t\t\t\t   { I2C_SMBUS_PROC_CALL,\t\t\"PROC_CALL\" },\n\t\t\t\t   { I2C_SMBUS_BLOCK_DATA,\t\t\"BLOCK_DATA\" },\n\t\t\t\t   { I2C_SMBUS_I2C_BLOCK_BROKEN,\t\"I2C_BLOCK_BROKEN\" },\n\t\t\t\t   { I2C_SMBUS_BLOCK_PROC_CALL,\t\"BLOCK_PROC_CALL\" },\n\t\t\t\t   { I2C_SMBUS_I2C_BLOCK_DATA,\t\"I2C_BLOCK_DATA\" })\n\t\t  ));\n\n \nTRACE_EVENT_CONDITION(smbus_reply,\n\tTP_PROTO(const struct i2c_adapter *adap,\n\t\t u16 addr, unsigned short flags,\n\t\t char read_write, u8 command, int protocol,\n\t\t const union i2c_smbus_data *data, int res),\n\tTP_ARGS(adap, addr, flags, read_write, command, protocol, data, res),\n\tTP_CONDITION(res >= 0 && read_write == I2C_SMBUS_READ),\n\tTP_STRUCT__entry(\n\t\t__field(int,\tadapter_nr\t\t)\n\t\t__field(__u16,\taddr\t\t\t)\n\t\t__field(__u16,\tflags\t\t\t)\n\t\t__field(__u8,\tcommand\t\t\t)\n\t\t__field(__u8,\tlen\t\t\t)\n\t\t__field(__u32,\tprotocol\t\t)\n\t\t__array(__u8, buf, I2C_SMBUS_BLOCK_MAX + 2)\t),\n\tTP_fast_assign(\n\t\t__entry->adapter_nr = adap->nr;\n\t\t__entry->addr = addr;\n\t\t__entry->flags = flags;\n\t\t__entry->command = command;\n\t\t__entry->protocol = protocol;\n\n\t\tswitch (protocol) {\n\t\tcase I2C_SMBUS_BYTE:\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\t__entry->len = 1;\n\t\t\tgoto copy;\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\t__entry->len = 2;\n\t\t\tgoto copy;\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t\t__entry->len = data->block[0] + 1;\n\t\tcopy:\n\t\t\tmemcpy(__entry->buf, data->block, __entry->len);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_QUICK:\n\t\tcase I2C_SMBUS_I2C_BLOCK_BROKEN:\n\t\tdefault:\n\t\t\t__entry->len = 0;\n\t\t}\n\t\t       ),\n\tTP_printk(\"i2c-%d a=%03x f=%04x c=%x %s l=%u [%*phD]\",\n\t\t  __entry->adapter_nr,\n\t\t  __entry->addr,\n\t\t  __entry->flags,\n\t\t  __entry->command,\n\t\t  __print_symbolic(__entry->protocol,\n\t\t\t\t   { I2C_SMBUS_QUICK,\t\t\"QUICK\"\t},\n\t\t\t\t   { I2C_SMBUS_BYTE,\t\t\"BYTE\"\t},\n\t\t\t\t   { I2C_SMBUS_BYTE_DATA,\t\t\"BYTE_DATA\" },\n\t\t\t\t   { I2C_SMBUS_WORD_DATA,\t\t\"WORD_DATA\" },\n\t\t\t\t   { I2C_SMBUS_PROC_CALL,\t\t\"PROC_CALL\" },\n\t\t\t\t   { I2C_SMBUS_BLOCK_DATA,\t\t\"BLOCK_DATA\" },\n\t\t\t\t   { I2C_SMBUS_I2C_BLOCK_BROKEN,\t\"I2C_BLOCK_BROKEN\" },\n\t\t\t\t   { I2C_SMBUS_BLOCK_PROC_CALL,\t\"BLOCK_PROC_CALL\" },\n\t\t\t\t   { I2C_SMBUS_I2C_BLOCK_DATA,\t\"I2C_BLOCK_DATA\" }),\n\t\t  __entry->len,\n\t\t  __entry->len, __entry->buf\n\t\t  ));\n\n \nTRACE_EVENT(smbus_result,\n\t    TP_PROTO(const struct i2c_adapter *adap,\n\t\t     u16 addr, unsigned short flags,\n\t\t     char read_write, u8 command, int protocol,\n\t\t     int res),\n\t    TP_ARGS(adap, addr, flags, read_write, command, protocol, res),\n\t    TP_STRUCT__entry(\n\t\t    __field(int,\tadapter_nr\t\t)\n\t\t    __field(__u16,\taddr\t\t\t)\n\t\t    __field(__u16,\tflags\t\t\t)\n\t\t    __field(__u8,\tread_write\t\t)\n\t\t    __field(__u8,\tcommand\t\t\t)\n\t\t    __field(__s16,\tres\t\t\t)\n\t\t    __field(__u32,\tprotocol\t\t)\n\t\t\t     ),\n\t    TP_fast_assign(\n\t\t    __entry->adapter_nr = adap->nr;\n\t\t    __entry->addr = addr;\n\t\t    __entry->flags = flags;\n\t\t    __entry->read_write = read_write;\n\t\t    __entry->command = command;\n\t\t    __entry->protocol = protocol;\n\t\t    __entry->res = res;\n\t\t\t   ),\n\t    TP_printk(\"i2c-%d a=%03x f=%04x c=%x %s %s res=%d\",\n\t\t      __entry->adapter_nr,\n\t\t      __entry->addr,\n\t\t      __entry->flags,\n\t\t      __entry->command,\n\t\t      __print_symbolic(__entry->protocol,\n\t\t\t\t       { I2C_SMBUS_QUICK,\t\t\"QUICK\"\t},\n\t\t\t\t       { I2C_SMBUS_BYTE,\t\t\"BYTE\"\t},\n\t\t\t\t       { I2C_SMBUS_BYTE_DATA,\t\t\"BYTE_DATA\" },\n\t\t\t\t       { I2C_SMBUS_WORD_DATA,\t\t\"WORD_DATA\" },\n\t\t\t\t       { I2C_SMBUS_PROC_CALL,\t\t\"PROC_CALL\" },\n\t\t\t\t       { I2C_SMBUS_BLOCK_DATA,\t\t\"BLOCK_DATA\" },\n\t\t\t\t       { I2C_SMBUS_I2C_BLOCK_BROKEN,\t\"I2C_BLOCK_BROKEN\" },\n\t\t\t\t       { I2C_SMBUS_BLOCK_PROC_CALL,\t\"BLOCK_PROC_CALL\" },\n\t\t\t\t       { I2C_SMBUS_I2C_BLOCK_DATA,\t\"I2C_BLOCK_DATA\" }),\n\t\t      __entry->read_write == I2C_SMBUS_WRITE ? \"wr\" : \"rd\",\n\t\t      __entry->res\n\t\t      ));\n\n#endif  \n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}