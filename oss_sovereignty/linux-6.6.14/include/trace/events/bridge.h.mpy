{
  "module_name": "bridge.h",
  "hash_id": "2c4b312dd1832f1153986b6d7fb1816ad35a829cb586743b304ba3c0eea86696",
  "original_prompt": "Ingested from linux-6.6.14/include/trace/events/bridge.h",
  "human_readable_source": "#undef TRACE_SYSTEM\n#define TRACE_SYSTEM bridge\n\n#if !defined(_TRACE_BRIDGE_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_BRIDGE_H\n\n#include <linux/netdevice.h>\n#include <linux/tracepoint.h>\n\n#include \"../../../net/bridge/br_private.h\"\n\nTRACE_EVENT(br_fdb_add,\n\n\tTP_PROTO(struct ndmsg *ndm, struct net_device *dev,\n\t\t const unsigned char *addr, u16 vid, u16 nlh_flags),\n\n\tTP_ARGS(ndm, dev, addr, vid, nlh_flags),\n\n\tTP_STRUCT__entry(\n\t\t__field(u8, ndm_flags)\n\t\t__string(dev, dev->name)\n\t\t__array(unsigned char, addr, ETH_ALEN)\n\t\t__field(u16, vid)\n\t\t__field(u16, nlh_flags)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(dev, dev->name);\n\t\tmemcpy(__entry->addr, addr, ETH_ALEN);\n\t\t__entry->vid = vid;\n\t\t__entry->nlh_flags = nlh_flags;\n\t\t__entry->ndm_flags = ndm->ndm_flags;\n\t),\n\n\tTP_printk(\"dev %s addr %02x:%02x:%02x:%02x:%02x:%02x vid %u nlh_flags %04x ndm_flags %02x\",\n\t\t  __get_str(dev), __entry->addr[0], __entry->addr[1],\n\t\t  __entry->addr[2], __entry->addr[3], __entry->addr[4],\n\t\t  __entry->addr[5], __entry->vid,\n\t\t  __entry->nlh_flags, __entry->ndm_flags)\n);\n\nTRACE_EVENT(br_fdb_external_learn_add,\n\n\tTP_PROTO(struct net_bridge *br, struct net_bridge_port *p,\n\t\t const unsigned char *addr, u16 vid),\n\n\tTP_ARGS(br, p, addr, vid),\n\n\tTP_STRUCT__entry(\n\t\t__string(br_dev, br->dev->name)\n\t\t__string(dev, p ? p->dev->name : \"null\")\n\t\t__array(unsigned char, addr, ETH_ALEN)\n\t\t__field(u16, vid)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(br_dev, br->dev->name);\n\t\t__assign_str(dev, p ? p->dev->name : \"null\");\n\t\tmemcpy(__entry->addr, addr, ETH_ALEN);\n\t\t__entry->vid = vid;\n\t),\n\n\tTP_printk(\"br_dev %s port %s addr %02x:%02x:%02x:%02x:%02x:%02x vid %u\",\n\t\t  __get_str(br_dev), __get_str(dev), __entry->addr[0],\n\t\t  __entry->addr[1], __entry->addr[2], __entry->addr[3],\n\t\t  __entry->addr[4], __entry->addr[5], __entry->vid)\n);\n\nTRACE_EVENT(fdb_delete,\n\n\tTP_PROTO(struct net_bridge *br, struct net_bridge_fdb_entry *f),\n\n\tTP_ARGS(br, f),\n\n\tTP_STRUCT__entry(\n\t\t__string(br_dev, br->dev->name)\n\t\t__string(dev, f->dst ? f->dst->dev->name : \"null\")\n\t\t__array(unsigned char, addr, ETH_ALEN)\n\t\t__field(u16, vid)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(br_dev, br->dev->name);\n\t\t__assign_str(dev, f->dst ? f->dst->dev->name : \"null\");\n\t\tmemcpy(__entry->addr, f->key.addr.addr, ETH_ALEN);\n\t\t__entry->vid = f->key.vlan_id;\n\t),\n\n\tTP_printk(\"br_dev %s dev %s addr %02x:%02x:%02x:%02x:%02x:%02x vid %u\",\n\t\t  __get_str(br_dev), __get_str(dev), __entry->addr[0],\n\t\t  __entry->addr[1], __entry->addr[2], __entry->addr[3],\n\t\t  __entry->addr[4], __entry->addr[5], __entry->vid)\n);\n\nTRACE_EVENT(br_fdb_update,\n\n\tTP_PROTO(struct net_bridge *br, struct net_bridge_port *source,\n\t\t const unsigned char *addr, u16 vid, unsigned long flags),\n\n\tTP_ARGS(br, source, addr, vid, flags),\n\n\tTP_STRUCT__entry(\n\t\t__string(br_dev, br->dev->name)\n\t\t__string(dev, source->dev->name)\n\t\t__array(unsigned char, addr, ETH_ALEN)\n\t\t__field(u16, vid)\n\t\t__field(unsigned long, flags)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(br_dev, br->dev->name);\n\t\t__assign_str(dev, source->dev->name);\n\t\tmemcpy(__entry->addr, addr, ETH_ALEN);\n\t\t__entry->vid = vid;\n\t\t__entry->flags = flags;\n\t),\n\n\tTP_printk(\"br_dev %s source %s addr %02x:%02x:%02x:%02x:%02x:%02x vid %u flags 0x%lx\",\n\t\t  __get_str(br_dev), __get_str(dev), __entry->addr[0],\n\t\t  __entry->addr[1], __entry->addr[2], __entry->addr[3],\n\t\t  __entry->addr[4], __entry->addr[5], __entry->vid,\n\t\t  __entry->flags)\n);\n\nTRACE_EVENT(br_mdb_full,\n\n\tTP_PROTO(const struct net_device *dev,\n\t\t const struct br_ip *group),\n\n\tTP_ARGS(dev, group),\n\n\tTP_STRUCT__entry(\n\t\t__string(dev, dev->name)\n\t\t__field(int, af)\n\t\t__field(u16, vid)\n\t\t__array(__u8, src, 16)\n\t\t__array(__u8, grp, 16)\n\t\t__array(__u8, grpmac, ETH_ALEN)  \n\t),\n\n\tTP_fast_assign(\n\t\tstruct in6_addr *in6;\n\n\t\t__assign_str(dev, dev->name);\n\t\t__entry->vid = group->vid;\n\n\t\tif (!group->proto) {\n\t\t\t__entry->af = 0;\n\n\t\t\tmemset(__entry->src, 0, sizeof(__entry->src));\n\t\t\tmemset(__entry->grp, 0, sizeof(__entry->grp));\n\t\t\tmemcpy(__entry->grpmac, group->dst.mac_addr, ETH_ALEN);\n\t\t} else if (group->proto == htons(ETH_P_IP)) {\n\t\t\t__entry->af = AF_INET;\n\n\t\t\tin6 = (struct in6_addr *)__entry->src;\n\t\t\tipv6_addr_set_v4mapped(group->src.ip4, in6);\n\n\t\t\tin6 = (struct in6_addr *)__entry->grp;\n\t\t\tipv6_addr_set_v4mapped(group->dst.ip4, in6);\n\n\t\t\tmemset(__entry->grpmac, 0, ETH_ALEN);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else {\n\t\t\t__entry->af = AF_INET6;\n\n\t\t\tin6 = (struct in6_addr *)__entry->src;\n\t\t\t*in6 = group->src.ip6;\n\n\t\t\tin6 = (struct in6_addr *)__entry->grp;\n\t\t\t*in6 = group->dst.ip6;\n\n\t\t\tmemset(__entry->grpmac, 0, ETH_ALEN);\n#endif\n\t\t}\n\t),\n\n\tTP_printk(\"dev %s af %u src %pI6c grp %pI6c/%pM vid %u\",\n\t\t  __get_str(dev), __entry->af, __entry->src, __entry->grp,\n\t\t  __entry->grpmac, __entry->vid)\n);\n\n#endif  \n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}