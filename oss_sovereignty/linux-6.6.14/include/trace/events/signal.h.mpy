{
  "module_name": "signal.h",
  "hash_id": "faa9d0d4648d631a95353d1ed3f97409dfca303865c652ae92e05d3b7da2cf75",
  "original_prompt": "Ingested from linux-6.6.14/include/trace/events/signal.h",
  "human_readable_source": " \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM signal\n\n#if !defined(_TRACE_SIGNAL_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_SIGNAL_H\n\n#include <linux/signal.h>\n#include <linux/sched.h>\n#include <linux/tracepoint.h>\n\n#define TP_STORE_SIGINFO(__entry, info)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (info == SEND_SIG_NOINFO) {\t\t\t\\\n\t\t\t__entry->errno\t= 0;\t\t\t\\\n\t\t\t__entry->code\t= SI_USER;\t\t\\\n\t\t} else if (info == SEND_SIG_PRIV) {\t\t\\\n\t\t\t__entry->errno\t= 0;\t\t\t\\\n\t\t\t__entry->code\t= SI_KERNEL;\t\t\\\n\t\t} else {\t\t\t\t\t\\\n\t\t\t__entry->errno\t= info->si_errno;\t\\\n\t\t\t__entry->code\t= info->si_code;\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0)\n\n#ifndef TRACE_HEADER_MULTI_READ\nenum {\n\tTRACE_SIGNAL_DELIVERED,\n\tTRACE_SIGNAL_IGNORED,\n\tTRACE_SIGNAL_ALREADY_PENDING,\n\tTRACE_SIGNAL_OVERFLOW_FAIL,\n\tTRACE_SIGNAL_LOSE_INFO,\n};\n#endif\n\n \nTRACE_EVENT(signal_generate,\n\n\tTP_PROTO(int sig, struct kernel_siginfo *info, struct task_struct *task,\n\t\t\tint group, int result),\n\n\tTP_ARGS(sig, info, task, group, result),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tint,\tsig\t\t\t)\n\t\t__field(\tint,\terrno\t\t\t)\n\t\t__field(\tint,\tcode\t\t\t)\n\t\t__array(\tchar,\tcomm,\tTASK_COMM_LEN\t)\n\t\t__field(\tpid_t,\tpid\t\t\t)\n\t\t__field(\tint,\tgroup\t\t\t)\n\t\t__field(\tint,\tresult\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->sig\t= sig;\n\t\tTP_STORE_SIGINFO(__entry, info);\n\t\tmemcpy(__entry->comm, task->comm, TASK_COMM_LEN);\n\t\t__entry->pid\t= task->pid;\n\t\t__entry->group\t= group;\n\t\t__entry->result\t= result;\n\t),\n\n\tTP_printk(\"sig=%d errno=%d code=%d comm=%s pid=%d grp=%d res=%d\",\n\t\t  __entry->sig, __entry->errno, __entry->code,\n\t\t  __entry->comm, __entry->pid, __entry->group,\n\t\t  __entry->result)\n);\n\n \nTRACE_EVENT(signal_deliver,\n\n\tTP_PROTO(int sig, struct kernel_siginfo *info, struct k_sigaction *ka),\n\n\tTP_ARGS(sig, info, ka),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tint,\t\tsig\t\t)\n\t\t__field(\tint,\t\terrno\t\t)\n\t\t__field(\tint,\t\tcode\t\t)\n\t\t__field(\tunsigned long,\tsa_handler\t)\n\t\t__field(\tunsigned long,\tsa_flags\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->sig\t= sig;\n\t\tTP_STORE_SIGINFO(__entry, info);\n\t\t__entry->sa_handler\t= (unsigned long)ka->sa.sa_handler;\n\t\t__entry->sa_flags\t= ka->sa.sa_flags;\n\t),\n\n\tTP_printk(\"sig=%d errno=%d code=%d sa_handler=%lx sa_flags=%lx\",\n\t\t  __entry->sig, __entry->errno, __entry->code,\n\t\t  __entry->sa_handler, __entry->sa_flags)\n);\n\n#endif  \n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}