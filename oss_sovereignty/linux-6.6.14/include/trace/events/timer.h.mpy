{
  "module_name": "timer.h",
  "hash_id": "90cf5617eccb53b5c10645fb8c0894344fbeeac9d3db90ec6f38300aef92f321",
  "original_prompt": "Ingested from linux-6.6.14/include/trace/events/timer.h",
  "human_readable_source": " \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM timer\n\n#if !defined(_TRACE_TIMER_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_TIMER_H\n\n#include <linux/tracepoint.h>\n#include <linux/hrtimer.h>\n#include <linux/timer.h>\n\nDECLARE_EVENT_CLASS(timer_class,\n\n\tTP_PROTO(struct timer_list *timer),\n\n\tTP_ARGS(timer),\n\n\tTP_STRUCT__entry(\n\t\t__field( void *,\ttimer\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->timer\t= timer;\n\t),\n\n\tTP_printk(\"timer=%p\", __entry->timer)\n);\n\n \nDEFINE_EVENT(timer_class, timer_init,\n\n\tTP_PROTO(struct timer_list *timer),\n\n\tTP_ARGS(timer)\n);\n\n#define decode_timer_flags(flags)\t\t\t\\\n\t__print_flags(flags, \"|\",\t\t\t\\\n\t\t{  TIMER_MIGRATING,\t\"M\" },\t\t\\\n\t\t{  TIMER_DEFERRABLE,\t\"D\" },\t\t\\\n\t\t{  TIMER_PINNED,\t\"P\" },\t\t\\\n\t\t{  TIMER_IRQSAFE,\t\"I\" })\n\n \nTRACE_EVENT(timer_start,\n\n\tTP_PROTO(struct timer_list *timer,\n\t\tunsigned long expires,\n\t\tunsigned int flags),\n\n\tTP_ARGS(timer, expires, flags),\n\n\tTP_STRUCT__entry(\n\t\t__field( void *,\ttimer\t\t)\n\t\t__field( void *,\tfunction\t)\n\t\t__field( unsigned long,\texpires\t\t)\n\t\t__field( unsigned long,\tnow\t\t)\n\t\t__field( unsigned int,\tflags\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->timer\t\t= timer;\n\t\t__entry->function\t= timer->function;\n\t\t__entry->expires\t= expires;\n\t\t__entry->now\t\t= jiffies;\n\t\t__entry->flags\t\t= flags;\n\t),\n\n\tTP_printk(\"timer=%p function=%ps expires=%lu [timeout=%ld] cpu=%u idx=%u flags=%s\",\n\t\t  __entry->timer, __entry->function, __entry->expires,\n\t\t  (long)__entry->expires - __entry->now,\n\t\t  __entry->flags & TIMER_CPUMASK,\n\t\t  __entry->flags >> TIMER_ARRAYSHIFT,\n\t\t  decode_timer_flags(__entry->flags & TIMER_TRACE_FLAGMASK))\n);\n\n \nTRACE_EVENT(timer_expire_entry,\n\n\tTP_PROTO(struct timer_list *timer, unsigned long baseclk),\n\n\tTP_ARGS(timer, baseclk),\n\n\tTP_STRUCT__entry(\n\t\t__field( void *,\ttimer\t)\n\t\t__field( unsigned long,\tnow\t)\n\t\t__field( void *,\tfunction)\n\t\t__field( unsigned long,\tbaseclk\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->timer\t\t= timer;\n\t\t__entry->now\t\t= jiffies;\n\t\t__entry->function\t= timer->function;\n\t\t__entry->baseclk\t= baseclk;\n\t),\n\n\tTP_printk(\"timer=%p function=%ps now=%lu baseclk=%lu\",\n\t\t  __entry->timer, __entry->function, __entry->now,\n\t\t  __entry->baseclk)\n);\n\n \nDEFINE_EVENT(timer_class, timer_expire_exit,\n\n\tTP_PROTO(struct timer_list *timer),\n\n\tTP_ARGS(timer)\n);\n\n \nDEFINE_EVENT(timer_class, timer_cancel,\n\n\tTP_PROTO(struct timer_list *timer),\n\n\tTP_ARGS(timer)\n);\n\n#define decode_clockid(type)\t\t\t\t\t\t\\\n\t__print_symbolic(type,\t\t\t\t\t\t\\\n\t\t{ CLOCK_REALTIME,\t\"CLOCK_REALTIME\"\t},\t\\\n\t\t{ CLOCK_MONOTONIC,\t\"CLOCK_MONOTONIC\"\t},\t\\\n\t\t{ CLOCK_BOOTTIME,\t\"CLOCK_BOOTTIME\"\t},\t\\\n\t\t{ CLOCK_TAI,\t\t\"CLOCK_TAI\"\t\t})\n\n#define decode_hrtimer_mode(mode)\t\t\t\t\t\\\n\t__print_symbolic(mode,\t\t\t\t\t\t\\\n\t\t{ HRTIMER_MODE_ABS,\t\t\"ABS\"\t\t},\t\\\n\t\t{ HRTIMER_MODE_REL,\t\t\"REL\"\t\t},\t\\\n\t\t{ HRTIMER_MODE_ABS_PINNED,\t\"ABS|PINNED\"\t},\t\\\n\t\t{ HRTIMER_MODE_REL_PINNED,\t\"REL|PINNED\"\t},\t\\\n\t\t{ HRTIMER_MODE_ABS_SOFT,\t\"ABS|SOFT\"\t},\t\\\n\t\t{ HRTIMER_MODE_REL_SOFT,\t\"REL|SOFT\"\t},\t\\\n\t\t{ HRTIMER_MODE_ABS_PINNED_SOFT,\t\"ABS|PINNED|SOFT\" },\t\\\n\t\t{ HRTIMER_MODE_REL_PINNED_SOFT,\t\"REL|PINNED|SOFT\" },\t\\\n\t\t{ HRTIMER_MODE_ABS_HARD,\t\"ABS|HARD\" },\t\t\\\n\t\t{ HRTIMER_MODE_REL_HARD,\t\"REL|HARD\" },\t\t\\\n\t\t{ HRTIMER_MODE_ABS_PINNED_HARD, \"ABS|PINNED|HARD\" },\t\\\n\t\t{ HRTIMER_MODE_REL_PINNED_HARD,\t\"REL|PINNED|HARD\" })\n\n \nTRACE_EVENT(hrtimer_init,\n\n\tTP_PROTO(struct hrtimer *hrtimer, clockid_t clockid,\n\t\t enum hrtimer_mode mode),\n\n\tTP_ARGS(hrtimer, clockid, mode),\n\n\tTP_STRUCT__entry(\n\t\t__field( void *,\t\thrtimer\t\t)\n\t\t__field( clockid_t,\t\tclockid\t\t)\n\t\t__field( enum hrtimer_mode,\tmode\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->hrtimer\t= hrtimer;\n\t\t__entry->clockid\t= clockid;\n\t\t__entry->mode\t\t= mode;\n\t),\n\n\tTP_printk(\"hrtimer=%p clockid=%s mode=%s\", __entry->hrtimer,\n\t\t  decode_clockid(__entry->clockid),\n\t\t  decode_hrtimer_mode(__entry->mode))\n);\n\n \nTRACE_EVENT(hrtimer_start,\n\n\tTP_PROTO(struct hrtimer *hrtimer, enum hrtimer_mode mode),\n\n\tTP_ARGS(hrtimer, mode),\n\n\tTP_STRUCT__entry(\n\t\t__field( void *,\thrtimer\t\t)\n\t\t__field( void *,\tfunction\t)\n\t\t__field( s64,\t\texpires\t\t)\n\t\t__field( s64,\t\tsoftexpires\t)\n\t\t__field( enum hrtimer_mode,\tmode\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->hrtimer\t= hrtimer;\n\t\t__entry->function\t= hrtimer->function;\n\t\t__entry->expires\t= hrtimer_get_expires(hrtimer);\n\t\t__entry->softexpires\t= hrtimer_get_softexpires(hrtimer);\n\t\t__entry->mode\t\t= mode;\n\t),\n\n\tTP_printk(\"hrtimer=%p function=%ps expires=%llu softexpires=%llu \"\n\t\t  \"mode=%s\", __entry->hrtimer, __entry->function,\n\t\t  (unsigned long long) __entry->expires,\n\t\t  (unsigned long long) __entry->softexpires,\n\t\t  decode_hrtimer_mode(__entry->mode))\n);\n\n \nTRACE_EVENT(hrtimer_expire_entry,\n\n\tTP_PROTO(struct hrtimer *hrtimer, ktime_t *now),\n\n\tTP_ARGS(hrtimer, now),\n\n\tTP_STRUCT__entry(\n\t\t__field( void *,\thrtimer\t)\n\t\t__field( s64,\t\tnow\t)\n\t\t__field( void *,\tfunction)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->hrtimer\t= hrtimer;\n\t\t__entry->now\t\t= *now;\n\t\t__entry->function\t= hrtimer->function;\n\t),\n\n\tTP_printk(\"hrtimer=%p function=%ps now=%llu\",\n\t\t  __entry->hrtimer, __entry->function,\n\t\t  (unsigned long long) __entry->now)\n);\n\nDECLARE_EVENT_CLASS(hrtimer_class,\n\n\tTP_PROTO(struct hrtimer *hrtimer),\n\n\tTP_ARGS(hrtimer),\n\n\tTP_STRUCT__entry(\n\t\t__field( void *,\thrtimer\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->hrtimer\t= hrtimer;\n\t),\n\n\tTP_printk(\"hrtimer=%p\", __entry->hrtimer)\n);\n\n \nDEFINE_EVENT(hrtimer_class, hrtimer_expire_exit,\n\n\tTP_PROTO(struct hrtimer *hrtimer),\n\n\tTP_ARGS(hrtimer)\n);\n\n \nDEFINE_EVENT(hrtimer_class, hrtimer_cancel,\n\n\tTP_PROTO(struct hrtimer *hrtimer),\n\n\tTP_ARGS(hrtimer)\n);\n\n \nTRACE_EVENT(itimer_state,\n\n\tTP_PROTO(int which, const struct itimerspec64 *const value,\n\t\t unsigned long long expires),\n\n\tTP_ARGS(which, value, expires),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tint,\t\t\twhich\t\t)\n\t\t__field(\tunsigned long long,\texpires\t\t)\n\t\t__field(\tlong,\t\t\tvalue_sec\t)\n\t\t__field(\tlong,\t\t\tvalue_nsec\t)\n\t\t__field(\tlong,\t\t\tinterval_sec\t)\n\t\t__field(\tlong,\t\t\tinterval_nsec\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->which\t\t= which;\n\t\t__entry->expires\t= expires;\n\t\t__entry->value_sec\t= value->it_value.tv_sec;\n\t\t__entry->value_nsec\t= value->it_value.tv_nsec;\n\t\t__entry->interval_sec\t= value->it_interval.tv_sec;\n\t\t__entry->interval_nsec\t= value->it_interval.tv_nsec;\n\t),\n\n\tTP_printk(\"which=%d expires=%llu it_value=%ld.%06ld it_interval=%ld.%06ld\",\n\t\t  __entry->which, __entry->expires,\n\t\t  __entry->value_sec, __entry->value_nsec / NSEC_PER_USEC,\n\t\t  __entry->interval_sec, __entry->interval_nsec / NSEC_PER_USEC)\n);\n\n \nTRACE_EVENT(itimer_expire,\n\n\tTP_PROTO(int which, struct pid *pid, unsigned long long now),\n\n\tTP_ARGS(which, pid, now),\n\n\tTP_STRUCT__entry(\n\t\t__field( int ,\t\t\twhich\t)\n\t\t__field( pid_t,\t\t\tpid\t)\n\t\t__field( unsigned long long,\tnow\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->which\t= which;\n\t\t__entry->now\t= now;\n\t\t__entry->pid\t= pid_nr(pid);\n\t),\n\n\tTP_printk(\"which=%d pid=%d now=%llu\", __entry->which,\n\t\t  (int) __entry->pid, __entry->now)\n);\n\n#ifdef CONFIG_NO_HZ_COMMON\n\n#define TICK_DEP_NAMES\t\t\t\t\t\\\n\t\ttick_dep_mask_name(NONE)\t\t\\\n\t\ttick_dep_name(POSIX_TIMER)\t\t\\\n\t\ttick_dep_name(PERF_EVENTS)\t\t\\\n\t\ttick_dep_name(SCHED)\t\t\t\\\n\t\ttick_dep_name(CLOCK_UNSTABLE)\t\t\\\n\t\ttick_dep_name(RCU)\t\t\t\\\n\t\ttick_dep_name_end(RCU_EXP)\n\n#undef tick_dep_name\n#undef tick_dep_mask_name\n#undef tick_dep_name_end\n\n \n#define tick_dep_name(sdep) TRACE_DEFINE_ENUM(TICK_DEP_BIT_##sdep); \\\n\tTRACE_DEFINE_ENUM(TICK_DEP_MASK_##sdep);\n#define tick_dep_name_end(sdep)  TRACE_DEFINE_ENUM(TICK_DEP_BIT_##sdep); \\\n\tTRACE_DEFINE_ENUM(TICK_DEP_MASK_##sdep);\n \n#define tick_dep_mask_name(sdep) TRACE_DEFINE_ENUM(TICK_DEP_MASK_##sdep);\n\nTICK_DEP_NAMES\n\n#undef tick_dep_name\n#undef tick_dep_mask_name\n#undef tick_dep_name_end\n\n#define tick_dep_name(sdep) { TICK_DEP_MASK_##sdep, #sdep },\n#define tick_dep_mask_name(sdep) { TICK_DEP_MASK_##sdep, #sdep },\n#define tick_dep_name_end(sdep) { TICK_DEP_MASK_##sdep, #sdep }\n\n#define show_tick_dep_name(val)\t\t\t\t\\\n\t__print_symbolic(val, TICK_DEP_NAMES)\n\nTRACE_EVENT(tick_stop,\n\n\tTP_PROTO(int success, int dependency),\n\n\tTP_ARGS(success, dependency),\n\n\tTP_STRUCT__entry(\n\t\t__field( int ,\t\tsuccess\t)\n\t\t__field( int ,\t\tdependency )\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->success\t= success;\n\t\t__entry->dependency\t= dependency;\n\t),\n\n\tTP_printk(\"success=%d dependency=%s\",  __entry->success, \\\n\t\t\tshow_tick_dep_name(__entry->dependency))\n);\n#endif\n\n#endif  \n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}