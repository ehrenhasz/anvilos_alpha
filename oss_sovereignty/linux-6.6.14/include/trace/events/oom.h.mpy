{
  "module_name": "oom.h",
  "hash_id": "17fae04d395fddecfedc47bc2be6062d33e83071d72588da43d30542893464ba",
  "original_prompt": "Ingested from linux-6.6.14/include/trace/events/oom.h",
  "human_readable_source": " \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM oom\n\n#if !defined(_TRACE_OOM_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_OOM_H\n#include <linux/tracepoint.h>\n#include <trace/events/mmflags.h>\n\nTRACE_EVENT(oom_score_adj_update,\n\n\tTP_PROTO(struct task_struct *task),\n\n\tTP_ARGS(task),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tpid_t,\tpid)\n\t\t__array(\tchar,\tcomm,\tTASK_COMM_LEN )\n\t\t__field(\tshort,\toom_score_adj)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->pid = task->pid;\n\t\tmemcpy(__entry->comm, task->comm, TASK_COMM_LEN);\n\t\t__entry->oom_score_adj = task->signal->oom_score_adj;\n\t),\n\n\tTP_printk(\"pid=%d comm=%s oom_score_adj=%hd\",\n\t\t__entry->pid, __entry->comm, __entry->oom_score_adj)\n);\n\nTRACE_EVENT(reclaim_retry_zone,\n\n\tTP_PROTO(struct zoneref *zoneref,\n\t\tint order,\n\t\tunsigned long reclaimable,\n\t\tunsigned long available,\n\t\tunsigned long min_wmark,\n\t\tint no_progress_loops,\n\t\tbool wmark_check),\n\n\tTP_ARGS(zoneref, order, reclaimable, available, min_wmark, no_progress_loops, wmark_check),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tint, node)\n\t\t__field(\tint, zone_idx)\n\t\t__field(\tint,\torder)\n\t\t__field(\tunsigned long,\treclaimable)\n\t\t__field(\tunsigned long,\tavailable)\n\t\t__field(\tunsigned long,\tmin_wmark)\n\t\t__field(\tint,\tno_progress_loops)\n\t\t__field(\tbool,\twmark_check)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->node = zone_to_nid(zoneref->zone);\n\t\t__entry->zone_idx = zoneref->zone_idx;\n\t\t__entry->order = order;\n\t\t__entry->reclaimable = reclaimable;\n\t\t__entry->available = available;\n\t\t__entry->min_wmark = min_wmark;\n\t\t__entry->no_progress_loops = no_progress_loops;\n\t\t__entry->wmark_check = wmark_check;\n\t),\n\n\tTP_printk(\"node=%d zone=%-8s order=%d reclaimable=%lu available=%lu min_wmark=%lu no_progress_loops=%d wmark_check=%d\",\n\t\t\t__entry->node, __print_symbolic(__entry->zone_idx, ZONE_TYPE),\n\t\t\t__entry->order,\n\t\t\t__entry->reclaimable, __entry->available, __entry->min_wmark,\n\t\t\t__entry->no_progress_loops,\n\t\t\t__entry->wmark_check)\n);\n\nTRACE_EVENT(mark_victim,\n\tTP_PROTO(int pid),\n\n\tTP_ARGS(pid),\n\n\tTP_STRUCT__entry(\n\t\t__field(int, pid)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->pid = pid;\n\t),\n\n\tTP_printk(\"pid=%d\", __entry->pid)\n);\n\nTRACE_EVENT(wake_reaper,\n\tTP_PROTO(int pid),\n\n\tTP_ARGS(pid),\n\n\tTP_STRUCT__entry(\n\t\t__field(int, pid)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->pid = pid;\n\t),\n\n\tTP_printk(\"pid=%d\", __entry->pid)\n);\n\nTRACE_EVENT(start_task_reaping,\n\tTP_PROTO(int pid),\n\n\tTP_ARGS(pid),\n\n\tTP_STRUCT__entry(\n\t\t__field(int, pid)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->pid = pid;\n\t),\n\n\tTP_printk(\"pid=%d\", __entry->pid)\n);\n\nTRACE_EVENT(finish_task_reaping,\n\tTP_PROTO(int pid),\n\n\tTP_ARGS(pid),\n\n\tTP_STRUCT__entry(\n\t\t__field(int, pid)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->pid = pid;\n\t),\n\n\tTP_printk(\"pid=%d\", __entry->pid)\n);\n\nTRACE_EVENT(skip_task_reaping,\n\tTP_PROTO(int pid),\n\n\tTP_ARGS(pid),\n\n\tTP_STRUCT__entry(\n\t\t__field(int, pid)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->pid = pid;\n\t),\n\n\tTP_printk(\"pid=%d\", __entry->pid)\n);\n\n#ifdef CONFIG_COMPACTION\nTRACE_EVENT(compact_retry,\n\n\tTP_PROTO(int order,\n\t\tenum compact_priority priority,\n\t\tenum compact_result result,\n\t\tint retries,\n\t\tint max_retries,\n\t\tbool ret),\n\n\tTP_ARGS(order, priority, result, retries, max_retries, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tint, order)\n\t\t__field(\tint, priority)\n\t\t__field(\tint, result)\n\t\t__field(\tint, retries)\n\t\t__field(\tint, max_retries)\n\t\t__field(\tbool, ret)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->order = order;\n\t\t__entry->priority = priority;\n\t\t__entry->result = compact_result_to_feedback(result);\n\t\t__entry->retries = retries;\n\t\t__entry->max_retries = max_retries;\n\t\t__entry->ret = ret;\n\t),\n\n\tTP_printk(\"order=%d priority=%s compaction_result=%s retries=%d max_retries=%d should_retry=%d\",\n\t\t\t__entry->order,\n\t\t\t__print_symbolic(__entry->priority, COMPACTION_PRIORITY),\n\t\t\t__print_symbolic(__entry->result, COMPACTION_FEEDBACK),\n\t\t\t__entry->retries, __entry->max_retries,\n\t\t\t__entry->ret)\n);\n#endif  \n#endif\n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}