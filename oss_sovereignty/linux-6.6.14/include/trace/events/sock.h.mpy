{
  "module_name": "sock.h",
  "hash_id": "c3d948108bb481ebca1c0d75c2a9ee00878a97473d856245f18b8ece657eae04",
  "original_prompt": "Ingested from linux-6.6.14/include/trace/events/sock.h",
  "human_readable_source": " \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM sock\n\n#if !defined(_TRACE_SOCK_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_SOCK_H\n\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/tracepoint.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n\n#define family_names\t\t\t\\\n\t\tEM(AF_INET)\t\t\t\t\\\n\t\tEMe(AF_INET6)\n\n \n#define inet_protocol_names\t\t\\\n\t\tEM(IPPROTO_TCP)\t\t\t\\\n\t\tEM(IPPROTO_DCCP)\t\t\\\n\t\tEM(IPPROTO_SCTP)\t\t\\\n\t\tEMe(IPPROTO_MPTCP)\n\n#define tcp_state_names\t\t\t\\\n\t\tEM(TCP_ESTABLISHED)\t\t\\\n\t\tEM(TCP_SYN_SENT)\t\t\\\n\t\tEM(TCP_SYN_RECV)\t\t\\\n\t\tEM(TCP_FIN_WAIT1)\t\t\\\n\t\tEM(TCP_FIN_WAIT2)\t\t\\\n\t\tEM(TCP_TIME_WAIT)\t\t\\\n\t\tEM(TCP_CLOSE)\t\t\t\\\n\t\tEM(TCP_CLOSE_WAIT)\t\t\\\n\t\tEM(TCP_LAST_ACK)\t\t\\\n\t\tEM(TCP_LISTEN)\t\t\t\\\n\t\tEM(TCP_CLOSING)\t\t\t\\\n\t\tEMe(TCP_NEW_SYN_RECV)\n\n#define skmem_kind_names\t\t\t\\\n\t\tEM(SK_MEM_SEND)\t\t\t\\\n\t\tEMe(SK_MEM_RECV)\n\n \n#undef EM\n#undef EMe\n#define EM(a)       TRACE_DEFINE_ENUM(a);\n#define EMe(a)      TRACE_DEFINE_ENUM(a);\n\nfamily_names\ninet_protocol_names\ntcp_state_names\nskmem_kind_names\n\n#undef EM\n#undef EMe\n#define EM(a)       { a, #a },\n#define EMe(a)      { a, #a }\n\n#define show_family_name(val)\t\t\t\\\n\t__print_symbolic(val, family_names)\n\n#define show_inet_protocol_name(val)    \\\n\t__print_symbolic(val, inet_protocol_names)\n\n#define show_tcp_state_name(val)        \\\n\t__print_symbolic(val, tcp_state_names)\n\n#define show_skmem_kind_names(val)\t\\\n\t__print_symbolic(val, skmem_kind_names)\n\nTRACE_EVENT(sock_rcvqueue_full,\n\n\tTP_PROTO(struct sock *sk, struct sk_buff *skb),\n\n\tTP_ARGS(sk, skb),\n\n\tTP_STRUCT__entry(\n\t\t__field(int, rmem_alloc)\n\t\t__field(unsigned int, truesize)\n\t\t__field(int, sk_rcvbuf)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->rmem_alloc = atomic_read(&sk->sk_rmem_alloc);\n\t\t__entry->truesize   = skb->truesize;\n\t\t__entry->sk_rcvbuf  = READ_ONCE(sk->sk_rcvbuf);\n\t),\n\n\tTP_printk(\"rmem_alloc=%d truesize=%u sk_rcvbuf=%d\",\n\t\t__entry->rmem_alloc, __entry->truesize, __entry->sk_rcvbuf)\n);\n\nTRACE_EVENT(sock_exceed_buf_limit,\n\n\tTP_PROTO(struct sock *sk, struct proto *prot, long allocated, int kind),\n\n\tTP_ARGS(sk, prot, allocated, kind),\n\n\tTP_STRUCT__entry(\n\t\t__array(char, name, 32)\n\t\t__array(long, sysctl_mem, 3)\n\t\t__field(long, allocated)\n\t\t__field(int, sysctl_rmem)\n\t\t__field(int, rmem_alloc)\n\t\t__field(int, sysctl_wmem)\n\t\t__field(int, wmem_alloc)\n\t\t__field(int, wmem_queued)\n\t\t__field(int, kind)\n\t),\n\n\tTP_fast_assign(\n\t\tstrncpy(__entry->name, prot->name, 32);\n\t\t__entry->sysctl_mem[0] = READ_ONCE(prot->sysctl_mem[0]);\n\t\t__entry->sysctl_mem[1] = READ_ONCE(prot->sysctl_mem[1]);\n\t\t__entry->sysctl_mem[2] = READ_ONCE(prot->sysctl_mem[2]);\n\t\t__entry->allocated = allocated;\n\t\t__entry->sysctl_rmem = sk_get_rmem0(sk, prot);\n\t\t__entry->rmem_alloc = atomic_read(&sk->sk_rmem_alloc);\n\t\t__entry->sysctl_wmem = sk_get_wmem0(sk, prot);\n\t\t__entry->wmem_alloc = refcount_read(&sk->sk_wmem_alloc);\n\t\t__entry->wmem_queued = READ_ONCE(sk->sk_wmem_queued);\n\t\t__entry->kind = kind;\n\t),\n\n\tTP_printk(\"proto:%s sysctl_mem=%ld,%ld,%ld allocated=%ld sysctl_rmem=%d rmem_alloc=%d sysctl_wmem=%d wmem_alloc=%d wmem_queued=%d kind=%s\",\n\t\t__entry->name,\n\t\t__entry->sysctl_mem[0],\n\t\t__entry->sysctl_mem[1],\n\t\t__entry->sysctl_mem[2],\n\t\t__entry->allocated,\n\t\t__entry->sysctl_rmem,\n\t\t__entry->rmem_alloc,\n\t\t__entry->sysctl_wmem,\n\t\t__entry->wmem_alloc,\n\t\t__entry->wmem_queued,\n\t\tshow_skmem_kind_names(__entry->kind)\n\t)\n);\n\nTRACE_EVENT(inet_sock_set_state,\n\n\tTP_PROTO(const struct sock *sk, const int oldstate, const int newstate),\n\n\tTP_ARGS(sk, oldstate, newstate),\n\n\tTP_STRUCT__entry(\n\t\t__field(const void *, skaddr)\n\t\t__field(int, oldstate)\n\t\t__field(int, newstate)\n\t\t__field(__u16, sport)\n\t\t__field(__u16, dport)\n\t\t__field(__u16, family)\n\t\t__field(__u16, protocol)\n\t\t__array(__u8, saddr, 4)\n\t\t__array(__u8, daddr, 4)\n\t\t__array(__u8, saddr_v6, 16)\n\t\t__array(__u8, daddr_v6, 16)\n\t),\n\n\tTP_fast_assign(\n\t\tconst struct inet_sock *inet = inet_sk(sk);\n\t\tstruct in6_addr *pin6;\n\t\t__be32 *p32;\n\n\t\t__entry->skaddr = sk;\n\t\t__entry->oldstate = oldstate;\n\t\t__entry->newstate = newstate;\n\n\t\t__entry->family = sk->sk_family;\n\t\t__entry->protocol = sk->sk_protocol;\n\t\t__entry->sport = ntohs(inet->inet_sport);\n\t\t__entry->dport = ntohs(inet->inet_dport);\n\n\t\tp32 = (__be32 *) __entry->saddr;\n\t\t*p32 = inet->inet_saddr;\n\n\t\tp32 = (__be32 *) __entry->daddr;\n\t\t*p32 =  inet->inet_daddr;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (sk->sk_family == AF_INET6) {\n\t\t\tpin6 = (struct in6_addr *)__entry->saddr_v6;\n\t\t\t*pin6 = sk->sk_v6_rcv_saddr;\n\t\t\tpin6 = (struct in6_addr *)__entry->daddr_v6;\n\t\t\t*pin6 = sk->sk_v6_daddr;\n\t\t} else\n#endif\n\t\t{\n\t\t\tpin6 = (struct in6_addr *)__entry->saddr_v6;\n\t\t\tipv6_addr_set_v4mapped(inet->inet_saddr, pin6);\n\t\t\tpin6 = (struct in6_addr *)__entry->daddr_v6;\n\t\t\tipv6_addr_set_v4mapped(inet->inet_daddr, pin6);\n\t\t}\n\t),\n\n\tTP_printk(\"family=%s protocol=%s sport=%hu dport=%hu saddr=%pI4 daddr=%pI4 saddrv6=%pI6c daddrv6=%pI6c oldstate=%s newstate=%s\",\n\t\t\tshow_family_name(__entry->family),\n\t\t\tshow_inet_protocol_name(__entry->protocol),\n\t\t\t__entry->sport, __entry->dport,\n\t\t\t__entry->saddr, __entry->daddr,\n\t\t\t__entry->saddr_v6, __entry->daddr_v6,\n\t\t\tshow_tcp_state_name(__entry->oldstate),\n\t\t\tshow_tcp_state_name(__entry->newstate))\n);\n\nTRACE_EVENT(inet_sk_error_report,\n\n\tTP_PROTO(const struct sock *sk),\n\n\tTP_ARGS(sk),\n\n\tTP_STRUCT__entry(\n\t\t__field(int, error)\n\t\t__field(__u16, sport)\n\t\t__field(__u16, dport)\n\t\t__field(__u16, family)\n\t\t__field(__u16, protocol)\n\t\t__array(__u8, saddr, 4)\n\t\t__array(__u8, daddr, 4)\n\t\t__array(__u8, saddr_v6, 16)\n\t\t__array(__u8, daddr_v6, 16)\n\t),\n\n\tTP_fast_assign(\n\t\tconst struct inet_sock *inet = inet_sk(sk);\n\t\tstruct in6_addr *pin6;\n\t\t__be32 *p32;\n\n\t\t__entry->error = sk->sk_err;\n\t\t__entry->family = sk->sk_family;\n\t\t__entry->protocol = sk->sk_protocol;\n\t\t__entry->sport = ntohs(inet->inet_sport);\n\t\t__entry->dport = ntohs(inet->inet_dport);\n\n\t\tp32 = (__be32 *) __entry->saddr;\n\t\t*p32 = inet->inet_saddr;\n\n\t\tp32 = (__be32 *) __entry->daddr;\n\t\t*p32 =  inet->inet_daddr;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (sk->sk_family == AF_INET6) {\n\t\t\tpin6 = (struct in6_addr *)__entry->saddr_v6;\n\t\t\t*pin6 = sk->sk_v6_rcv_saddr;\n\t\t\tpin6 = (struct in6_addr *)__entry->daddr_v6;\n\t\t\t*pin6 = sk->sk_v6_daddr;\n\t\t} else\n#endif\n\t\t{\n\t\t\tpin6 = (struct in6_addr *)__entry->saddr_v6;\n\t\t\tipv6_addr_set_v4mapped(inet->inet_saddr, pin6);\n\t\t\tpin6 = (struct in6_addr *)__entry->daddr_v6;\n\t\t\tipv6_addr_set_v4mapped(inet->inet_daddr, pin6);\n\t\t}\n\t),\n\n\tTP_printk(\"family=%s protocol=%s sport=%hu dport=%hu saddr=%pI4 daddr=%pI4 saddrv6=%pI6c daddrv6=%pI6c error=%d\",\n\t\t  show_family_name(__entry->family),\n\t\t  show_inet_protocol_name(__entry->protocol),\n\t\t  __entry->sport, __entry->dport,\n\t\t  __entry->saddr, __entry->daddr,\n\t\t  __entry->saddr_v6, __entry->daddr_v6,\n\t\t  __entry->error)\n);\n\nTRACE_EVENT(sk_data_ready,\n\n\tTP_PROTO(const struct sock *sk),\n\n\tTP_ARGS(sk),\n\n\tTP_STRUCT__entry(\n\t\t__field(const void *, skaddr)\n\t\t__field(__u16, family)\n\t\t__field(__u16, protocol)\n\t\t__field(unsigned long, ip)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->skaddr = sk;\n\t\t__entry->family = sk->sk_family;\n\t\t__entry->protocol = sk->sk_protocol;\n\t\t__entry->ip = _RET_IP_;\n\t),\n\n\tTP_printk(\"family=%u protocol=%u func=%ps\",\n\t\t  __entry->family, __entry->protocol, (void *)__entry->ip)\n);\n\n \nDECLARE_EVENT_CLASS(sock_msg_length,\n\n\tTP_PROTO(struct sock *sk, int ret, int flags),\n\n\tTP_ARGS(sk, ret, flags),\n\n\tTP_STRUCT__entry(\n\t\t__field(void *, sk)\n\t\t__field(__u16, family)\n\t\t__field(__u16, protocol)\n\t\t__field(int, ret)\n\t\t__field(int, flags)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->sk = sk;\n\t\t__entry->family = sk->sk_family;\n\t\t__entry->protocol = sk->sk_protocol;\n\t\t__entry->ret = ret;\n\t\t__entry->flags = flags;\n\t),\n\n\tTP_printk(\"sk address = %p, family = %s protocol = %s, length = %d, error = %d, flags = 0x%x\",\n\t\t  __entry->sk, show_family_name(__entry->family),\n\t\t  show_inet_protocol_name(__entry->protocol),\n\t\t  !(__entry->flags & MSG_PEEK) ?\n\t\t  (__entry->ret > 0 ? __entry->ret : 0) : 0,\n\t\t  __entry->ret < 0 ? __entry->ret : 0,\n\t\t  __entry->flags)\n);\n\nDEFINE_EVENT(sock_msg_length, sock_send_length,\n\tTP_PROTO(struct sock *sk, int ret, int flags),\n\n\tTP_ARGS(sk, ret, flags)\n);\n\nDEFINE_EVENT(sock_msg_length, sock_recv_length,\n\tTP_PROTO(struct sock *sk, int ret, int flags),\n\n\tTP_ARGS(sk, ret, flags)\n);\n#endif  \n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}