{
  "module_name": "rtc.h",
  "hash_id": "dd232dec7cf26a577865b596a86cf67c876581d210510389b2d6e2ab96883be6",
  "original_prompt": "Ingested from linux-6.6.14/include/trace/events/rtc.h",
  "human_readable_source": "#undef TRACE_SYSTEM\n#define TRACE_SYSTEM rtc\n\n#if !defined(_TRACE_RTC_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_RTC_H\n\n#include <linux/rtc.h>\n#include <linux/tracepoint.h>\n\nDECLARE_EVENT_CLASS(rtc_time_alarm_class,\n\n\tTP_PROTO(time64_t secs, int err),\n\n\tTP_ARGS(secs, err),\n\n\tTP_STRUCT__entry(\n\t\t__field(time64_t, secs)\n\t\t__field(int, err)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->secs = secs;\n\t\t__entry->err = err;\n\t),\n\n\tTP_printk(\"UTC (%lld) (%d)\",\n\t\t  __entry->secs, __entry->err\n\t)\n);\n\nDEFINE_EVENT(rtc_time_alarm_class, rtc_set_time,\n\n\tTP_PROTO(time64_t secs, int err),\n\n\tTP_ARGS(secs, err)\n);\n\nDEFINE_EVENT(rtc_time_alarm_class, rtc_read_time,\n\n\tTP_PROTO(time64_t secs, int err),\n\n\tTP_ARGS(secs, err)\n);\n\nDEFINE_EVENT(rtc_time_alarm_class, rtc_set_alarm,\n\n\tTP_PROTO(time64_t secs, int err),\n\n\tTP_ARGS(secs, err)\n);\n\nDEFINE_EVENT(rtc_time_alarm_class, rtc_read_alarm,\n\n\tTP_PROTO(time64_t secs, int err),\n\n\tTP_ARGS(secs, err)\n);\n\nTRACE_EVENT(rtc_irq_set_freq,\n\n\tTP_PROTO(int freq, int err),\n\n\tTP_ARGS(freq, err),\n\n\tTP_STRUCT__entry(\n\t\t__field(int, freq)\n\t\t__field(int, err)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->freq = freq;\n\t\t__entry->err = err;\n\t),\n\n\tTP_printk(\"set RTC periodic IRQ frequency:%u (%d)\",\n\t\t  __entry->freq, __entry->err\n\t)\n);\n\nTRACE_EVENT(rtc_irq_set_state,\n\n\tTP_PROTO(int enabled, int err),\n\n\tTP_ARGS(enabled, err),\n\n\tTP_STRUCT__entry(\n\t\t__field(int, enabled)\n\t\t__field(int, err)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->enabled = enabled;\n\t\t__entry->err = err;\n\t),\n\n\tTP_printk(\"%s RTC 2^N Hz periodic IRQs (%d)\",\n\t\t  __entry->enabled ? \"enable\" : \"disable\",\n\t\t  __entry->err\n\t)\n);\n\nTRACE_EVENT(rtc_alarm_irq_enable,\n\n\tTP_PROTO(unsigned int enabled, int err),\n\n\tTP_ARGS(enabled, err),\n\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, enabled)\n\t\t__field(int, err)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->enabled = enabled;\n\t\t__entry->err = err;\n\t),\n\n\tTP_printk(\"%s RTC alarm IRQ (%d)\",\n\t\t  __entry->enabled ? \"enable\" : \"disable\",\n\t\t  __entry->err\n\t)\n);\n\nDECLARE_EVENT_CLASS(rtc_offset_class,\n\n\tTP_PROTO(long offset, int err),\n\n\tTP_ARGS(offset, err),\n\n\tTP_STRUCT__entry(\n\t\t__field(long, offset)\n\t\t__field(int, err)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->offset = offset;\n\t\t__entry->err = err;\n\t),\n\n\tTP_printk(\"RTC offset: %ld (%d)\",\n\t\t  __entry->offset, __entry->err\n\t)\n);\n\nDEFINE_EVENT(rtc_offset_class, rtc_set_offset,\n\n\tTP_PROTO(long offset, int err),\n\n\tTP_ARGS(offset, err)\n);\n\nDEFINE_EVENT(rtc_offset_class, rtc_read_offset,\n\n\tTP_PROTO(long offset, int err),\n\n\tTP_ARGS(offset, err)\n);\n\nDECLARE_EVENT_CLASS(rtc_timer_class,\n\n\tTP_PROTO(struct rtc_timer *timer),\n\n\tTP_ARGS(timer),\n\n\tTP_STRUCT__entry(\n\t\t__field(struct rtc_timer *, timer)\n\t\t__field(ktime_t, expires)\n\t\t__field(ktime_t, period)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->timer = timer;\n\t\t__entry->expires = timer->node.expires;\n\t\t__entry->period = timer->period;\n\t),\n\n\tTP_printk(\"RTC timer:(%p) expires:%lld period:%lld\",\n\t\t  __entry->timer, __entry->expires, __entry->period\n\t)\n);\n\nDEFINE_EVENT(rtc_timer_class, rtc_timer_enqueue,\n\n\tTP_PROTO(struct rtc_timer *timer),\n\n\tTP_ARGS(timer)\n);\n\nDEFINE_EVENT(rtc_timer_class, rtc_timer_dequeue,\n\n\tTP_PROTO(struct rtc_timer *timer),\n\n\tTP_ARGS(timer)\n);\n\nDEFINE_EVENT(rtc_timer_class, rtc_timer_fired,\n\n\tTP_PROTO(struct rtc_timer *timer),\n\n\tTP_ARGS(timer)\n);\n\n#endif  \n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}