{
  "module_name": "mptcp.h",
  "hash_id": "fc4c905d20d2398c6ebd7cd8b08523c7e81cd50ebc29d4f557773ea0cc235953",
  "original_prompt": "Ingested from linux-6.6.14/include/trace/events/mptcp.h",
  "human_readable_source": " \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM mptcp\n\n#if !defined(_TRACE_MPTCP_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_MPTCP_H\n\n#include <linux/tracepoint.h>\n\n#define show_mapping_status(status)\t\t\t\t\t\\\n\t__print_symbolic(status,\t\t\t\t\t\\\n\t\t{ 0, \"MAPPING_OK\" },\t\t\t\t\t\\\n\t\t{ 1, \"MAPPING_INVALID\" },\t\t\t\t\\\n\t\t{ 2, \"MAPPING_EMPTY\" },\t\t\t\t\t\\\n\t\t{ 3, \"MAPPING_DATA_FIN\" },\t\t\t\t\\\n\t\t{ 4, \"MAPPING_DUMMY\" })\n\nTRACE_EVENT(mptcp_subflow_get_send,\n\n\tTP_PROTO(struct mptcp_subflow_context *subflow),\n\n\tTP_ARGS(subflow),\n\n\tTP_STRUCT__entry(\n\t\t__field(bool, active)\n\t\t__field(bool, free)\n\t\t__field(u32, snd_wnd)\n\t\t__field(u32, pace)\n\t\t__field(u8, backup)\n\t\t__field(u64, ratio)\n\t),\n\n\tTP_fast_assign(\n\t\tstruct sock *ssk;\n\n\t\t__entry->active = mptcp_subflow_active(subflow);\n\t\t__entry->backup = subflow->backup;\n\n\t\tif (subflow->tcp_sock && sk_fullsock(subflow->tcp_sock))\n\t\t\t__entry->free = sk_stream_memory_free(subflow->tcp_sock);\n\t\telse\n\t\t\t__entry->free = 0;\n\n\t\tssk = mptcp_subflow_tcp_sock(subflow);\n\t\tif (ssk && sk_fullsock(ssk)) {\n\t\t\t__entry->snd_wnd = tcp_sk(ssk)->snd_wnd;\n\t\t\t__entry->pace = ssk->sk_pacing_rate;\n\t\t} else {\n\t\t\t__entry->snd_wnd = 0;\n\t\t\t__entry->pace = 0;\n\t\t}\n\n\t\tif (ssk && sk_fullsock(ssk) && __entry->pace)\n\t\t\t__entry->ratio = div_u64((u64)ssk->sk_wmem_queued << 32, __entry->pace);\n\t\telse\n\t\t\t__entry->ratio = 0;\n\t),\n\n\tTP_printk(\"active=%d free=%d snd_wnd=%u pace=%u backup=%u ratio=%llu\",\n\t\t  __entry->active, __entry->free,\n\t\t  __entry->snd_wnd, __entry->pace,\n\t\t  __entry->backup, __entry->ratio)\n);\n\nDECLARE_EVENT_CLASS(mptcp_dump_mpext,\n\n\tTP_PROTO(struct mptcp_ext *mpext),\n\n\tTP_ARGS(mpext),\n\n\tTP_STRUCT__entry(\n\t\t__field(u64, data_ack)\n\t\t__field(u64, data_seq)\n\t\t__field(u32, subflow_seq)\n\t\t__field(u16, data_len)\n\t\t__field(u16, csum)\n\t\t__field(u8, use_map)\n\t\t__field(u8, dsn64)\n\t\t__field(u8, data_fin)\n\t\t__field(u8, use_ack)\n\t\t__field(u8, ack64)\n\t\t__field(u8, mpc_map)\n\t\t__field(u8, frozen)\n\t\t__field(u8, reset_transient)\n\t\t__field(u8, reset_reason)\n\t\t__field(u8, csum_reqd)\n\t\t__field(u8, infinite_map)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->data_ack = mpext->ack64 ? mpext->data_ack : mpext->data_ack32;\n\t\t__entry->data_seq = mpext->data_seq;\n\t\t__entry->subflow_seq = mpext->subflow_seq;\n\t\t__entry->data_len = mpext->data_len;\n\t\t__entry->csum = (__force u16)mpext->csum;\n\t\t__entry->use_map = mpext->use_map;\n\t\t__entry->dsn64 = mpext->dsn64;\n\t\t__entry->data_fin = mpext->data_fin;\n\t\t__entry->use_ack = mpext->use_ack;\n\t\t__entry->ack64 = mpext->ack64;\n\t\t__entry->mpc_map = mpext->mpc_map;\n\t\t__entry->frozen = mpext->frozen;\n\t\t__entry->reset_transient = mpext->reset_transient;\n\t\t__entry->reset_reason = mpext->reset_reason;\n\t\t__entry->csum_reqd = mpext->csum_reqd;\n\t\t__entry->infinite_map = mpext->infinite_map;\n\t),\n\n\tTP_printk(\"data_ack=%llu data_seq=%llu subflow_seq=%u data_len=%u csum=%x use_map=%u dsn64=%u data_fin=%u use_ack=%u ack64=%u mpc_map=%u frozen=%u reset_transient=%u reset_reason=%u csum_reqd=%u infinite_map=%u\",\n\t\t  __entry->data_ack, __entry->data_seq,\n\t\t  __entry->subflow_seq, __entry->data_len,\n\t\t  __entry->csum, __entry->use_map,\n\t\t  __entry->dsn64, __entry->data_fin,\n\t\t  __entry->use_ack, __entry->ack64,\n\t\t  __entry->mpc_map, __entry->frozen,\n\t\t  __entry->reset_transient, __entry->reset_reason,\n\t\t  __entry->csum_reqd, __entry->infinite_map)\n);\n\nDEFINE_EVENT(mptcp_dump_mpext, mptcp_sendmsg_frag,\n\tTP_PROTO(struct mptcp_ext *mpext),\n\tTP_ARGS(mpext));\n\nDEFINE_EVENT(mptcp_dump_mpext, get_mapping_status,\n\tTP_PROTO(struct mptcp_ext *mpext),\n\tTP_ARGS(mpext));\n\nTRACE_EVENT(ack_update_msk,\n\n\tTP_PROTO(u64 data_ack, u64 old_snd_una,\n\t\t u64 new_snd_una, u64 new_wnd_end,\n\t\t u64 msk_wnd_end),\n\n\tTP_ARGS(data_ack, old_snd_una,\n\t\tnew_snd_una, new_wnd_end,\n\t\tmsk_wnd_end),\n\n\tTP_STRUCT__entry(\n\t\t__field(u64, data_ack)\n\t\t__field(u64, old_snd_una)\n\t\t__field(u64, new_snd_una)\n\t\t__field(u64, new_wnd_end)\n\t\t__field(u64, msk_wnd_end)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->data_ack = data_ack;\n\t\t__entry->old_snd_una = old_snd_una;\n\t\t__entry->new_snd_una = new_snd_una;\n\t\t__entry->new_wnd_end = new_wnd_end;\n\t\t__entry->msk_wnd_end = msk_wnd_end;\n\t),\n\n\tTP_printk(\"data_ack=%llu old_snd_una=%llu new_snd_una=%llu new_wnd_end=%llu msk_wnd_end=%llu\",\n\t\t  __entry->data_ack, __entry->old_snd_una,\n\t\t  __entry->new_snd_una, __entry->new_wnd_end,\n\t\t  __entry->msk_wnd_end)\n);\n\nTRACE_EVENT(subflow_check_data_avail,\n\n\tTP_PROTO(__u8 status, struct sk_buff *skb),\n\n\tTP_ARGS(status, skb),\n\n\tTP_STRUCT__entry(\n\t\t__field(u8, status)\n\t\t__field(const void *, skb)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->status = status;\n\t\t__entry->skb = skb;\n\t),\n\n\tTP_printk(\"mapping_status=%s, skb=%p\",\n\t\t  show_mapping_status(__entry->status),\n\t\t  __entry->skb)\n);\n\n#endif  \n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}