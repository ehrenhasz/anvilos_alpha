{
  "module_name": "filelock.h",
  "hash_id": "5f1c3635f575934ce2733186bccf8dbeae9d81361e9e7d25deb83b53e7af9c4c",
  "original_prompt": "Ingested from linux-6.6.14/include/trace/events/filelock.h",
  "human_readable_source": " \n \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM filelock\n\n#if !defined(_TRACE_FILELOCK_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_FILELOCK_H\n\n#include <linux/tracepoint.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/kdev_t.h>\n\n#define show_fl_flags(val)\t\t\t\t\t\t\\\n\t__print_flags(val, \"|\", \t\t\t\t\t\\\n\t\t{ FL_POSIX,\t\t\"FL_POSIX\" },\t\t\t\\\n\t\t{ FL_FLOCK,\t\t\"FL_FLOCK\" },\t\t\t\\\n\t\t{ FL_DELEG,\t\t\"FL_DELEG\" },\t\t\t\\\n\t\t{ FL_ACCESS,\t\t\"FL_ACCESS\" },\t\t\t\\\n\t\t{ FL_EXISTS,\t\t\"FL_EXISTS\" },\t\t\t\\\n\t\t{ FL_LEASE,\t\t\"FL_LEASE\" },\t\t\t\\\n\t\t{ FL_CLOSE,\t\t\"FL_CLOSE\" },\t\t\t\\\n\t\t{ FL_SLEEP,\t\t\"FL_SLEEP\" },\t\t\t\\\n\t\t{ FL_DOWNGRADE_PENDING,\t\"FL_DOWNGRADE_PENDING\" },\t\\\n\t\t{ FL_UNLOCK_PENDING,\t\"FL_UNLOCK_PENDING\" },\t\t\\\n\t\t{ FL_OFDLCK,\t\t\"FL_OFDLCK\" })\n\n#define show_fl_type(val)\t\t\t\t\\\n\t__print_symbolic(val,\t\t\t\t\\\n\t\t\t{ F_RDLCK, \"F_RDLCK\" },\t\t\\\n\t\t\t{ F_WRLCK, \"F_WRLCK\" },\t\t\\\n\t\t\t{ F_UNLCK, \"F_UNLCK\" })\n\nTRACE_EVENT(locks_get_lock_context,\n\tTP_PROTO(struct inode *inode, int type, struct file_lock_context *ctx),\n\n\tTP_ARGS(inode, type, ctx),\n\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long, i_ino)\n\t\t__field(dev_t, s_dev)\n\t\t__field(unsigned char, type)\n\t\t__field(struct file_lock_context *, ctx)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->s_dev = inode->i_sb->s_dev;\n\t\t__entry->i_ino = inode->i_ino;\n\t\t__entry->type = type;\n\t\t__entry->ctx = ctx;\n\t),\n\n\tTP_printk(\"dev=0x%x:0x%x ino=0x%lx type=%s ctx=%p\",\n\t\t  MAJOR(__entry->s_dev), MINOR(__entry->s_dev),\n\t\t  __entry->i_ino, show_fl_type(__entry->type), __entry->ctx)\n);\n\nDECLARE_EVENT_CLASS(filelock_lock,\n\tTP_PROTO(struct inode *inode, struct file_lock *fl, int ret),\n\n\tTP_ARGS(inode, fl, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(struct file_lock *, fl)\n\t\t__field(unsigned long, i_ino)\n\t\t__field(dev_t, s_dev)\n\t\t__field(struct file_lock *, fl_blocker)\n\t\t__field(fl_owner_t, fl_owner)\n\t\t__field(unsigned int, fl_pid)\n\t\t__field(unsigned int, fl_flags)\n\t\t__field(unsigned char, fl_type)\n\t\t__field(loff_t, fl_start)\n\t\t__field(loff_t, fl_end)\n\t\t__field(int, ret)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->fl = fl ? fl : NULL;\n\t\t__entry->s_dev = inode->i_sb->s_dev;\n\t\t__entry->i_ino = inode->i_ino;\n\t\t__entry->fl_blocker = fl ? fl->fl_blocker : NULL;\n\t\t__entry->fl_owner = fl ? fl->fl_owner : NULL;\n\t\t__entry->fl_pid = fl ? fl->fl_pid : 0;\n\t\t__entry->fl_flags = fl ? fl->fl_flags : 0;\n\t\t__entry->fl_type = fl ? fl->fl_type : 0;\n\t\t__entry->fl_start = fl ? fl->fl_start : 0;\n\t\t__entry->fl_end = fl ? fl->fl_end : 0;\n\t\t__entry->ret = ret;\n\t),\n\n\tTP_printk(\"fl=%p dev=0x%x:0x%x ino=0x%lx fl_blocker=%p fl_owner=%p fl_pid=%u fl_flags=%s fl_type=%s fl_start=%lld fl_end=%lld ret=%d\",\n\t\t__entry->fl, MAJOR(__entry->s_dev), MINOR(__entry->s_dev),\n\t\t__entry->i_ino, __entry->fl_blocker, __entry->fl_owner,\n\t\t__entry->fl_pid, show_fl_flags(__entry->fl_flags),\n\t\tshow_fl_type(__entry->fl_type),\n\t\t__entry->fl_start, __entry->fl_end, __entry->ret)\n);\n\nDEFINE_EVENT(filelock_lock, posix_lock_inode,\n\t\tTP_PROTO(struct inode *inode, struct file_lock *fl, int ret),\n\t\tTP_ARGS(inode, fl, ret));\n\nDEFINE_EVENT(filelock_lock, fcntl_setlk,\n\t\tTP_PROTO(struct inode *inode, struct file_lock *fl, int ret),\n\t\tTP_ARGS(inode, fl, ret));\n\nDEFINE_EVENT(filelock_lock, locks_remove_posix,\n\t\tTP_PROTO(struct inode *inode, struct file_lock *fl, int ret),\n\t\tTP_ARGS(inode, fl, ret));\n\nDEFINE_EVENT(filelock_lock, flock_lock_inode,\n\t\tTP_PROTO(struct inode *inode, struct file_lock *fl, int ret),\n\t\tTP_ARGS(inode, fl, ret));\n\nDECLARE_EVENT_CLASS(filelock_lease,\n\tTP_PROTO(struct inode *inode, struct file_lock *fl),\n\n\tTP_ARGS(inode, fl),\n\n\tTP_STRUCT__entry(\n\t\t__field(struct file_lock *, fl)\n\t\t__field(unsigned long, i_ino)\n\t\t__field(dev_t, s_dev)\n\t\t__field(struct file_lock *, fl_blocker)\n\t\t__field(fl_owner_t, fl_owner)\n\t\t__field(unsigned int, fl_flags)\n\t\t__field(unsigned char, fl_type)\n\t\t__field(unsigned long, fl_break_time)\n\t\t__field(unsigned long, fl_downgrade_time)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->fl = fl ? fl : NULL;\n\t\t__entry->s_dev = inode->i_sb->s_dev;\n\t\t__entry->i_ino = inode->i_ino;\n\t\t__entry->fl_blocker = fl ? fl->fl_blocker : NULL;\n\t\t__entry->fl_owner = fl ? fl->fl_owner : NULL;\n\t\t__entry->fl_flags = fl ? fl->fl_flags : 0;\n\t\t__entry->fl_type = fl ? fl->fl_type : 0;\n\t\t__entry->fl_break_time = fl ? fl->fl_break_time : 0;\n\t\t__entry->fl_downgrade_time = fl ? fl->fl_downgrade_time : 0;\n\t),\n\n\tTP_printk(\"fl=%p dev=0x%x:0x%x ino=0x%lx fl_blocker=%p fl_owner=%p fl_flags=%s fl_type=%s fl_break_time=%lu fl_downgrade_time=%lu\",\n\t\t__entry->fl, MAJOR(__entry->s_dev), MINOR(__entry->s_dev),\n\t\t__entry->i_ino, __entry->fl_blocker, __entry->fl_owner,\n\t\tshow_fl_flags(__entry->fl_flags),\n\t\tshow_fl_type(__entry->fl_type),\n\t\t__entry->fl_break_time, __entry->fl_downgrade_time)\n);\n\nDEFINE_EVENT(filelock_lease, break_lease_noblock, TP_PROTO(struct inode *inode, struct file_lock *fl),\n\t\tTP_ARGS(inode, fl));\n\nDEFINE_EVENT(filelock_lease, break_lease_block, TP_PROTO(struct inode *inode, struct file_lock *fl),\n\t\tTP_ARGS(inode, fl));\n\nDEFINE_EVENT(filelock_lease, break_lease_unblock, TP_PROTO(struct inode *inode, struct file_lock *fl),\n\t\tTP_ARGS(inode, fl));\n\nDEFINE_EVENT(filelock_lease, generic_delete_lease, TP_PROTO(struct inode *inode, struct file_lock *fl),\n\t\tTP_ARGS(inode, fl));\n\nDEFINE_EVENT(filelock_lease, time_out_leases, TP_PROTO(struct inode *inode, struct file_lock *fl),\n\t\tTP_ARGS(inode, fl));\n\nTRACE_EVENT(generic_add_lease,\n\tTP_PROTO(struct inode *inode, struct file_lock *fl),\n\n\tTP_ARGS(inode, fl),\n\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long, i_ino)\n\t\t__field(int, wcount)\n\t\t__field(int, rcount)\n\t\t__field(int, icount)\n\t\t__field(dev_t, s_dev)\n\t\t__field(fl_owner_t, fl_owner)\n\t\t__field(unsigned int, fl_flags)\n\t\t__field(unsigned char, fl_type)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->s_dev = inode->i_sb->s_dev;\n\t\t__entry->i_ino = inode->i_ino;\n\t\t__entry->wcount = atomic_read(&inode->i_writecount);\n\t\t__entry->rcount = atomic_read(&inode->i_readcount);\n\t\t__entry->icount = atomic_read(&inode->i_count);\n\t\t__entry->fl_owner = fl->fl_owner;\n\t\t__entry->fl_flags = fl->fl_flags;\n\t\t__entry->fl_type = fl->fl_type;\n\t),\n\n\tTP_printk(\"dev=0x%x:0x%x ino=0x%lx wcount=%d rcount=%d icount=%d fl_owner=%p fl_flags=%s fl_type=%s\",\n\t\tMAJOR(__entry->s_dev), MINOR(__entry->s_dev),\n\t\t__entry->i_ino, __entry->wcount, __entry->rcount,\n\t\t__entry->icount, __entry->fl_owner,\n\t\tshow_fl_flags(__entry->fl_flags),\n\t\tshow_fl_type(__entry->fl_type))\n);\n\nTRACE_EVENT(leases_conflict,\n\tTP_PROTO(bool conflict, struct file_lock *lease, struct file_lock *breaker),\n\n\tTP_ARGS(conflict, lease, breaker),\n\n\tTP_STRUCT__entry(\n\t\t__field(void *, lease)\n\t\t__field(void *, breaker)\n\t\t__field(unsigned int, l_fl_flags)\n\t\t__field(unsigned int, b_fl_flags)\n\t\t__field(unsigned char, l_fl_type)\n\t\t__field(unsigned char, b_fl_type)\n\t\t__field(bool, conflict)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->lease = lease;\n\t\t__entry->l_fl_flags = lease->fl_flags;\n\t\t__entry->l_fl_type = lease->fl_type;\n\t\t__entry->breaker = breaker;\n\t\t__entry->b_fl_flags = breaker->fl_flags;\n\t\t__entry->b_fl_type = breaker->fl_type;\n\t\t__entry->conflict = conflict;\n\t),\n\n\tTP_printk(\"conflict %d: lease=%p fl_flags=%s fl_type=%s; breaker=%p fl_flags=%s fl_type=%s\",\n\t\t__entry->conflict,\n\t\t__entry->lease,\n\t\tshow_fl_flags(__entry->l_fl_flags),\n\t\tshow_fl_type(__entry->l_fl_type),\n\t\t__entry->breaker,\n\t\tshow_fl_flags(__entry->b_fl_flags),\n\t\tshow_fl_type(__entry->b_fl_type))\n);\n\n#endif  \n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}