{
  "module_name": "preempt.h",
  "hash_id": "87be46f08a89bba62a6ed21498b4a9c3be3f7938f04808dff689f4a37cbaf3b9",
  "original_prompt": "Ingested from linux-6.6.14/include/asm-generic/preempt.h",
  "human_readable_source": " \n#ifndef __ASM_PREEMPT_H\n#define __ASM_PREEMPT_H\n\n#include <linux/thread_info.h>\n\n#define PREEMPT_ENABLED\t(0)\n\nstatic __always_inline int preempt_count(void)\n{\n\treturn READ_ONCE(current_thread_info()->preempt_count);\n}\n\nstatic __always_inline volatile int *preempt_count_ptr(void)\n{\n\treturn &current_thread_info()->preempt_count;\n}\n\nstatic __always_inline void preempt_count_set(int pc)\n{\n\t*preempt_count_ptr() = pc;\n}\n\n \n#define init_task_preempt_count(p) do { \\\n\ttask_thread_info(p)->preempt_count = FORK_PREEMPT_COUNT; \\\n} while (0)\n\n#define init_idle_preempt_count(p, cpu) do { \\\n\ttask_thread_info(p)->preempt_count = PREEMPT_DISABLED; \\\n} while (0)\n\nstatic __always_inline void set_preempt_need_resched(void)\n{\n}\n\nstatic __always_inline void clear_preempt_need_resched(void)\n{\n}\n\nstatic __always_inline bool test_preempt_need_resched(void)\n{\n\treturn false;\n}\n\n \n\nstatic __always_inline void __preempt_count_add(int val)\n{\n\t*preempt_count_ptr() += val;\n}\n\nstatic __always_inline void __preempt_count_sub(int val)\n{\n\t*preempt_count_ptr() -= val;\n}\n\nstatic __always_inline bool __preempt_count_dec_and_test(void)\n{\n\t \n\treturn !--*preempt_count_ptr() && tif_need_resched();\n}\n\n \nstatic __always_inline bool should_resched(int preempt_offset)\n{\n\treturn unlikely(preempt_count() == preempt_offset &&\n\t\t\ttif_need_resched());\n}\n\n#ifdef CONFIG_PREEMPTION\nextern asmlinkage void preempt_schedule(void);\nextern asmlinkage void preempt_schedule_notrace(void);\n\n#if defined(CONFIG_PREEMPT_DYNAMIC) && defined(CONFIG_HAVE_PREEMPT_DYNAMIC_KEY)\n\nvoid dynamic_preempt_schedule(void);\nvoid dynamic_preempt_schedule_notrace(void);\n#define __preempt_schedule()\t\tdynamic_preempt_schedule()\n#define __preempt_schedule_notrace()\tdynamic_preempt_schedule_notrace()\n\n#else  \n\n#define __preempt_schedule() preempt_schedule()\n#define __preempt_schedule_notrace() preempt_schedule_notrace()\n\n#endif  \n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}