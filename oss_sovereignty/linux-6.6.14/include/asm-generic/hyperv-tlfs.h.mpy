{
  "module_name": "hyperv-tlfs.h",
  "hash_id": "ddfa11d55870ae84b98f3a3807b3ef4646e67561fcc71438cc343fcf53d9d1ee",
  "original_prompt": "Ingested from linux-6.6.14/include/asm-generic/hyperv-tlfs.h",
  "human_readable_source": " \n\n \n\n#ifndef _ASM_GENERIC_HYPERV_TLFS_H\n#define _ASM_GENERIC_HYPERV_TLFS_H\n\n#include <linux/types.h>\n#include <linux/bits.h>\n#include <linux/time64.h>\n\n \n#define HV_HYP_PAGE_SHIFT      12\n#define HV_HYP_PAGE_SIZE       BIT(HV_HYP_PAGE_SHIFT)\n#define HV_HYP_PAGE_MASK       (~(HV_HYP_PAGE_SIZE - 1))\n\n \n\n \n\n \n#define HV_MSR_VP_RUNTIME_AVAILABLE\t\tBIT(0)\n \n#define HV_MSR_TIME_REF_COUNT_AVAILABLE\t\tBIT(1)\n \n#define HV_MSR_SYNIC_AVAILABLE\t\t\tBIT(2)\n \n#define HV_MSR_SYNTIMER_AVAILABLE\t\tBIT(3)\n \n#define HV_MSR_APIC_ACCESS_AVAILABLE\t\tBIT(4)\n \n#define HV_MSR_HYPERCALL_AVAILABLE\t\tBIT(5)\n \n#define HV_MSR_VP_INDEX_AVAILABLE\t\tBIT(6)\n \n#define HV_MSR_RESET_AVAILABLE\t\t\tBIT(7)\n \n#define HV_MSR_STAT_PAGES_AVAILABLE\t\tBIT(8)\n \n#define HV_MSR_REFERENCE_TSC_AVAILABLE\t\tBIT(9)\n \n#define HV_MSR_GUEST_IDLE_AVAILABLE\t\tBIT(10)\n \n#define HV_ACCESS_FREQUENCY_MSRS\t\tBIT(11)\n \n#define HV_ACCESS_REENLIGHTENMENT\t\tBIT(13)\n \n#define HV_ACCESS_TSC_INVARIANT\t\t\tBIT(15)\n\n \n#define HV_CREATE_PARTITIONS\t\t\tBIT(0)\n#define HV_ACCESS_PARTITION_ID\t\t\tBIT(1)\n#define HV_ACCESS_MEMORY_POOL\t\t\tBIT(2)\n#define HV_ADJUST_MESSAGE_BUFFERS\t\tBIT(3)\n#define HV_POST_MESSAGES\t\t\tBIT(4)\n#define HV_SIGNAL_EVENTS\t\t\tBIT(5)\n#define HV_CREATE_PORT\t\t\t\tBIT(6)\n#define HV_CONNECT_PORT\t\t\t\tBIT(7)\n#define HV_ACCESS_STATS\t\t\t\tBIT(8)\n#define HV_DEBUGGING\t\t\t\tBIT(11)\n#define HV_CPU_MANAGEMENT\t\t\tBIT(12)\n#define HV_ENABLE_EXTENDED_HYPERCALLS\t\tBIT(20)\n#define HV_ISOLATION\t\t\t\tBIT(22)\n\n \nstruct ms_hyperv_tsc_page {\n\tvolatile u32 tsc_sequence;\n\tu32 reserved1;\n\tvolatile u64 tsc_scale;\n\tvolatile s64 tsc_offset;\n} __packed;\n\nunion hv_reference_tsc_msr {\n\tu64 as_uint64;\n\tstruct {\n\t\tu64 enable:1;\n\t\tu64 reserved:11;\n\t\tu64 pfn:52;\n\t} __packed;\n};\n\n \n\n#define HV_LINUX_VENDOR_ID              0x8100\n\n \n#define HV_CRASH_CTL_CRASH_NOTIFY_MSG\t\tBIT_ULL(62)\n#define HV_CRASH_CTL_CRASH_NOTIFY\t\tBIT_ULL(63)\n\n \n#define HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE\t0x0002\n#define HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST\t0x0003\n#define HVCALL_ENABLE_VP_VTL\t\t\t0x000f\n#define HVCALL_NOTIFY_LONG_SPIN_WAIT\t\t0x0008\n#define HVCALL_SEND_IPI\t\t\t\t0x000b\n#define HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX\t0x0013\n#define HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX\t0x0014\n#define HVCALL_SEND_IPI_EX\t\t\t0x0015\n#define HVCALL_GET_PARTITION_ID\t\t\t0x0046\n#define HVCALL_DEPOSIT_MEMORY\t\t\t0x0048\n#define HVCALL_CREATE_VP\t\t\t0x004e\n#define HVCALL_GET_VP_REGISTERS\t\t\t0x0050\n#define HVCALL_SET_VP_REGISTERS\t\t\t0x0051\n#define HVCALL_POST_MESSAGE\t\t\t0x005c\n#define HVCALL_SIGNAL_EVENT\t\t\t0x005d\n#define HVCALL_POST_DEBUG_DATA\t\t\t0x0069\n#define HVCALL_RETRIEVE_DEBUG_DATA\t\t0x006a\n#define HVCALL_RESET_DEBUG_SESSION\t\t0x006b\n#define HVCALL_ADD_LOGICAL_PROCESSOR\t\t0x0076\n#define HVCALL_MAP_DEVICE_INTERRUPT\t\t0x007c\n#define HVCALL_UNMAP_DEVICE_INTERRUPT\t\t0x007d\n#define HVCALL_RETARGET_INTERRUPT\t\t0x007e\n#define HVCALL_START_VP\t\t\t\t0x0099\n#define HVCALL_GET_VP_ID_FROM_APIC_ID\t\t0x009a\n#define HVCALL_FLUSH_GUEST_PHYSICAL_ADDRESS_SPACE 0x00af\n#define HVCALL_FLUSH_GUEST_PHYSICAL_ADDRESS_LIST 0x00b0\n#define HVCALL_MODIFY_SPARSE_GPA_PAGE_HOST_VISIBILITY 0x00db\n#define HVCALL_MMIO_READ\t\t\t0x0106\n#define HVCALL_MMIO_WRITE\t\t\t0x0107\n\n \n#define HV_EXT_CALL_QUERY_CAPABILITIES\t\t0x8001\n#define HV_EXT_CALL_MEMORY_HEAT_HINT\t\t0x8003\n\n#define HV_FLUSH_ALL_PROCESSORS\t\t\tBIT(0)\n#define HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES\tBIT(1)\n#define HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY\tBIT(2)\n#define HV_FLUSH_USE_EXTENDED_RANGE_FORMAT\tBIT(3)\n\n \n#define HV_EXT_CAPABILITY_MEMORY_COLD_DISCARD_HINT BIT(8)\n\nenum HV_GENERIC_SET_FORMAT {\n\tHV_GENERIC_SET_SPARSE_4K,\n\tHV_GENERIC_SET_ALL,\n};\n\n#define HV_PARTITION_ID_SELF\t\t((u64)-1)\n#define HV_VP_INDEX_SELF\t\t((u32)-2)\n\n#define HV_HYPERCALL_RESULT_MASK\tGENMASK_ULL(15, 0)\n#define HV_HYPERCALL_FAST_BIT\t\tBIT(16)\n#define HV_HYPERCALL_VARHEAD_OFFSET\t17\n#define HV_HYPERCALL_VARHEAD_MASK\tGENMASK_ULL(26, 17)\n#define HV_HYPERCALL_RSVD0_MASK\t\tGENMASK_ULL(31, 27)\n#define HV_HYPERCALL_NESTED\t\tBIT_ULL(31)\n#define HV_HYPERCALL_REP_COMP_OFFSET\t32\n#define HV_HYPERCALL_REP_COMP_1\t\tBIT_ULL(32)\n#define HV_HYPERCALL_REP_COMP_MASK\tGENMASK_ULL(43, 32)\n#define HV_HYPERCALL_RSVD1_MASK\t\tGENMASK_ULL(47, 44)\n#define HV_HYPERCALL_REP_START_OFFSET\t48\n#define HV_HYPERCALL_REP_START_MASK\tGENMASK_ULL(59, 48)\n#define HV_HYPERCALL_RSVD2_MASK\t\tGENMASK_ULL(63, 60)\n#define HV_HYPERCALL_RSVD_MASK\t\t(HV_HYPERCALL_RSVD0_MASK | \\\n\t\t\t\t\t HV_HYPERCALL_RSVD1_MASK | \\\n\t\t\t\t\t HV_HYPERCALL_RSVD2_MASK)\n\n \n#define HV_STATUS_SUCCESS\t\t\t0\n#define HV_STATUS_INVALID_HYPERCALL_CODE\t2\n#define HV_STATUS_INVALID_HYPERCALL_INPUT\t3\n#define HV_STATUS_INVALID_ALIGNMENT\t\t4\n#define HV_STATUS_INVALID_PARAMETER\t\t5\n#define HV_STATUS_ACCESS_DENIED\t\t\t6\n#define HV_STATUS_OPERATION_DENIED\t\t8\n#define HV_STATUS_INSUFFICIENT_MEMORY\t\t11\n#define HV_STATUS_INVALID_PORT_ID\t\t17\n#define HV_STATUS_INVALID_CONNECTION_ID\t\t18\n#define HV_STATUS_INSUFFICIENT_BUFFERS\t\t19\n#define HV_STATUS_TIME_OUT                      120\n#define HV_STATUS_VTL_ALREADY_ENABLED\t\t134\n\n \n#define HV_CLOCK_HZ (NSEC_PER_SEC/100)\n\n \n#define HV_SYNIC_SINT_COUNT\t\t(16)\n \n#define HV_SYNIC_VERSION_1\t\t(0x1)\n \n#define HV_SYNIC_FIRST_VALID_VECTOR\t(16)\n\n#define HV_SYNIC_CONTROL_ENABLE\t\t(1ULL << 0)\n#define HV_SYNIC_SIMP_ENABLE\t\t(1ULL << 0)\n#define HV_SYNIC_SIEFP_ENABLE\t\t(1ULL << 0)\n#define HV_SYNIC_SINT_MASKED\t\t(1ULL << 16)\n#define HV_SYNIC_SINT_AUTO_EOI\t\t(1ULL << 17)\n#define HV_SYNIC_SINT_VECTOR_MASK\t(0xFF)\n\n#define HV_SYNIC_STIMER_COUNT\t\t(4)\n\n \n#define HV_MESSAGE_SIZE\t\t\t(256)\n#define HV_MESSAGE_PAYLOAD_BYTE_COUNT\t(240)\n#define HV_MESSAGE_PAYLOAD_QWORD_COUNT\t(30)\n\n \nenum hv_message_type {\n\tHVMSG_NONE\t\t\t= 0x00000000,\n\n\t \n\tHVMSG_UNMAPPED_GPA\t\t= 0x80000000,\n\tHVMSG_GPA_INTERCEPT\t\t= 0x80000001,\n\n\t \n\tHVMSG_TIMER_EXPIRED\t\t= 0x80000010,\n\n\t \n\tHVMSG_INVALID_VP_REGISTER_VALUE\t= 0x80000020,\n\tHVMSG_UNRECOVERABLE_EXCEPTION\t= 0x80000021,\n\tHVMSG_UNSUPPORTED_FEATURE\t= 0x80000022,\n\n\t \n\tHVMSG_EVENTLOG_BUFFERCOMPLETE\t= 0x80000040,\n\n\t \n\tHVMSG_X64_IOPORT_INTERCEPT\t= 0x80010000,\n\tHVMSG_X64_MSR_INTERCEPT\t\t= 0x80010001,\n\tHVMSG_X64_CPUID_INTERCEPT\t= 0x80010002,\n\tHVMSG_X64_EXCEPTION_INTERCEPT\t= 0x80010003,\n\tHVMSG_X64_APIC_EOI\t\t= 0x80010004,\n\tHVMSG_X64_LEGACY_FP_ERROR\t= 0x80010005\n};\n\n \nunion hv_message_flags {\n\t__u8 asu8;\n\tstruct {\n\t\t__u8 msg_pending:1;\n\t\t__u8 reserved:7;\n\t} __packed;\n};\n\n \nunion hv_port_id {\n\t__u32 asu32;\n\tstruct {\n\t\t__u32 id:24;\n\t\t__u32 reserved:8;\n\t} __packed u;\n};\n\n \nstruct hv_message_header {\n\t__u32 message_type;\n\t__u8 payload_size;\n\tunion hv_message_flags message_flags;\n\t__u8 reserved[2];\n\tunion {\n\t\t__u64 sender;\n\t\tunion hv_port_id port;\n\t};\n} __packed;\n\n \nstruct hv_message {\n\tstruct hv_message_header header;\n\tunion {\n\t\t__u64 payload[HV_MESSAGE_PAYLOAD_QWORD_COUNT];\n\t} u;\n} __packed;\n\n \nstruct hv_message_page {\n\tstruct hv_message sint_message[HV_SYNIC_SINT_COUNT];\n} __packed;\n\n \nstruct hv_timer_message_payload {\n\t__u32 timer_index;\n\t__u32 reserved;\n\t__u64 expiration_time;\t \n\t__u64 delivery_time;\t \n} __packed;\n\n\n \n#define HV_EVENT_FLAGS_COUNT\t\t(256 * 8)\n#define HV_EVENT_FLAGS_LONG_COUNT\t(256 / sizeof(unsigned long))\n\n \nunion hv_stimer_config {\n\tu64 as_uint64;\n\tstruct {\n\t\tu64 enable:1;\n\t\tu64 periodic:1;\n\t\tu64 lazy:1;\n\t\tu64 auto_enable:1;\n\t\tu64 apic_vector:8;\n\t\tu64 direct_mode:1;\n\t\tu64 reserved_z0:3;\n\t\tu64 sintx:4;\n\t\tu64 reserved_z1:44;\n\t} __packed;\n};\n\n\n \nunion hv_synic_event_flags {\n\tunsigned long flags[HV_EVENT_FLAGS_LONG_COUNT];\n};\n\n \nunion hv_synic_scontrol {\n\tu64 as_uint64;\n\tstruct {\n\t\tu64 enable:1;\n\t\tu64 reserved:63;\n\t} __packed;\n};\n\n \nunion hv_synic_sint {\n\tu64 as_uint64;\n\tstruct {\n\t\tu64 vector:8;\n\t\tu64 reserved1:8;\n\t\tu64 masked:1;\n\t\tu64 auto_eoi:1;\n\t\tu64 polling:1;\n\t\tu64 reserved2:45;\n\t} __packed;\n};\n\n \nunion hv_synic_simp {\n\tu64 as_uint64;\n\tstruct {\n\t\tu64 simp_enabled:1;\n\t\tu64 preserved:11;\n\t\tu64 base_simp_gpa:52;\n\t} __packed;\n};\n\n \nunion hv_synic_siefp {\n\tu64 as_uint64;\n\tstruct {\n\t\tu64 siefp_enabled:1;\n\t\tu64 preserved:11;\n\t\tu64 base_siefp_gpa:52;\n\t} __packed;\n};\n\nstruct hv_vpset {\n\tu64 format;\n\tu64 valid_bank_mask;\n\tu64 bank_contents[];\n} __packed;\n\n \n#define HV_MAX_SPARSE_VCPU_BANKS (64)\n \n#define HV_VCPUS_PER_SPARSE_BANK (64)\n\n \nstruct hv_send_ipi {\n\tu32 vector;\n\tu32 reserved;\n\tu64 cpu_mask;\n} __packed;\n\n \nstruct hv_send_ipi_ex {\n\tu32 vector;\n\tu32 reserved;\n\tstruct hv_vpset vp_set;\n} __packed;\n\n \nstruct hv_guest_mapping_flush {\n\tu64 address_space;\n\tu64 flags;\n} __packed;\n\n \n#define HV_MAX_FLUSH_PAGES (2048)\n#define HV_GPA_PAGE_RANGE_PAGE_SIZE_2MB\t\t0\n#define HV_GPA_PAGE_RANGE_PAGE_SIZE_1GB\t\t1\n\n \nunion hv_gpa_page_range {\n\tu64 address_space;\n\tstruct {\n\t\tu64 additional_pages:11;\n\t\tu64 largepage:1;\n\t\tu64 basepfn:52;\n\t} page;\n\tstruct {\n\t\tu64 reserved:12;\n\t\tu64 page_size:1;\n\t\tu64 reserved1:8;\n\t\tu64 base_large_pfn:43;\n\t};\n};\n\n \n#define HV_MAX_FLUSH_REP_COUNT ((HV_HYP_PAGE_SIZE - 2 * sizeof(u64)) /\t\\\n\t\t\t\tsizeof(union hv_gpa_page_range))\n\nstruct hv_guest_mapping_flush_list {\n\tu64 address_space;\n\tu64 flags;\n\tunion hv_gpa_page_range gpa_list[HV_MAX_FLUSH_REP_COUNT];\n};\n\n \nstruct hv_tlb_flush {\n\tu64 address_space;\n\tu64 flags;\n\tu64 processor_mask;\n\tu64 gva_list[];\n} __packed;\n\n \nstruct hv_tlb_flush_ex {\n\tu64 address_space;\n\tu64 flags;\n\tstruct hv_vpset hv_vp_set;\n\tu64 gva_list[];\n} __packed;\n\n \nstruct hv_get_partition_id {\n\tu64 partition_id;\n} __packed;\n\n \nstruct hv_deposit_memory {\n\tu64 partition_id;\n\tu64 gpa_page_list[];\n} __packed;\n\nstruct hv_proximity_domain_flags {\n\tu32 proximity_preferred : 1;\n\tu32 reserved : 30;\n\tu32 proximity_info_valid : 1;\n} __packed;\n\n \nunion hv_proximity_domain_info {\n\tstruct {\n\t\tu32 domain_id;\n\t\tstruct hv_proximity_domain_flags flags;\n\t};\n\tu64 as_uint64;\n} __packed;\n\nstruct hv_lp_startup_status {\n\tu64 hv_status;\n\tu64 substatus1;\n\tu64 substatus2;\n\tu64 substatus3;\n\tu64 substatus4;\n\tu64 substatus5;\n\tu64 substatus6;\n} __packed;\n\n \nstruct hv_add_logical_processor_in {\n\tu32 lp_index;\n\tu32 apic_id;\n\tunion hv_proximity_domain_info proximity_domain_info;\n\tu64 flags;\n} __packed;\n\nstruct hv_add_logical_processor_out {\n\tstruct hv_lp_startup_status startup_status;\n} __packed;\n\nenum HV_SUBNODE_TYPE\n{\n    HvSubnodeAny = 0,\n    HvSubnodeSocket = 1,\n    HvSubnodeAmdNode = 2,\n    HvSubnodeL3 = 3,\n    HvSubnodeCount = 4,\n    HvSubnodeInvalid = -1\n};\n\n \nstruct hv_create_vp {\n\tu64 partition_id;\n\tu32 vp_index;\n\tu8 padding[3];\n\tu8 subnode_type;\n\tu64 subnode_id;\n\tunion hv_proximity_domain_info proximity_domain_info;\n\tu64 flags;\n} __packed;\n\nenum hv_interrupt_source {\n\tHV_INTERRUPT_SOURCE_MSI = 1,  \n\tHV_INTERRUPT_SOURCE_IOAPIC,\n};\n\nunion hv_ioapic_rte {\n\tu64 as_uint64;\n\n\tstruct {\n\t\tu32 vector:8;\n\t\tu32 delivery_mode:3;\n\t\tu32 destination_mode:1;\n\t\tu32 delivery_status:1;\n\t\tu32 interrupt_polarity:1;\n\t\tu32 remote_irr:1;\n\t\tu32 trigger_mode:1;\n\t\tu32 interrupt_mask:1;\n\t\tu32 reserved1:15;\n\n\t\tu32 reserved2:24;\n\t\tu32 destination_id:8;\n\t};\n\n\tstruct {\n\t\tu32 low_uint32;\n\t\tu32 high_uint32;\n\t};\n} __packed;\n\nstruct hv_interrupt_entry {\n\tu32 source;\n\tu32 reserved1;\n\tunion {\n\t\tunion hv_msi_entry msi_entry;\n\t\tunion hv_ioapic_rte ioapic_rte;\n\t};\n} __packed;\n\n \n#define HV_DEVICE_INTERRUPT_TARGET_MULTICAST\t\t1\n#define HV_DEVICE_INTERRUPT_TARGET_PROCESSOR_SET\t2\n\nstruct hv_device_interrupt_target {\n\tu32 vector;\n\tu32 flags;\n\tunion {\n\t\tu64 vp_mask;\n\t\tstruct hv_vpset vp_set;\n\t};\n} __packed;\n\nstruct hv_retarget_device_interrupt {\n\tu64 partition_id;\t\t \n\tu64 device_id;\n\tstruct hv_interrupt_entry int_entry;\n\tu64 reserved2;\n\tstruct hv_device_interrupt_target int_target;\n} __packed __aligned(8);\n\n\n \nstruct hv_get_vp_registers_input {\n\tstruct {\n\t\tu64 partitionid;\n\t\tu32 vpindex;\n\t\tu8  inputvtl;\n\t\tu8  padding[3];\n\t} header;\n\tstruct input {\n\t\tu32 name0;\n\t\tu32 name1;\n\t} element[];\n} __packed;\n\n\n \nstruct hv_get_vp_registers_output {\n\tunion {\n\t\tstruct {\n\t\t\tu32 a;\n\t\t\tu32 b;\n\t\t\tu32 c;\n\t\t\tu32 d;\n\t\t} as32 __packed;\n\t\tstruct {\n\t\t\tu64 low;\n\t\t\tu64 high;\n\t\t} as64 __packed;\n\t};\n};\n\n \nstruct hv_set_vp_registers_input {\n\tstruct {\n\t\tu64 partitionid;\n\t\tu32 vpindex;\n\t\tu8  inputvtl;\n\t\tu8  padding[3];\n\t} header;\n\tstruct {\n\t\tu32 name;\n\t\tu32 padding1;\n\t\tu64 padding2;\n\t\tu64 valuelow;\n\t\tu64 valuehigh;\n\t} element[];\n} __packed;\n\nenum hv_device_type {\n\tHV_DEVICE_TYPE_LOGICAL = 0,\n\tHV_DEVICE_TYPE_PCI = 1,\n\tHV_DEVICE_TYPE_IOAPIC = 2,\n\tHV_DEVICE_TYPE_ACPI = 3,\n};\n\ntypedef u16 hv_pci_rid;\ntypedef u16 hv_pci_segment;\ntypedef u64 hv_logical_device_id;\nunion hv_pci_bdf {\n\tu16 as_uint16;\n\n\tstruct {\n\t\tu8 function:3;\n\t\tu8 device:5;\n\t\tu8 bus;\n\t};\n} __packed;\n\nunion hv_pci_bus_range {\n\tu16 as_uint16;\n\n\tstruct {\n\t\tu8 subordinate_bus;\n\t\tu8 secondary_bus;\n\t};\n} __packed;\n\nunion hv_device_id {\n\tu64 as_uint64;\n\n\tstruct {\n\t\tu64 reserved0:62;\n\t\tu64 device_type:2;\n\t};\n\n\t \n\tstruct {\n\t\tu64 id:62;\n\t\tu64 device_type:2;\n\t} logical;\n\n\t \n\tstruct {\n\t\tunion {\n\t\t\thv_pci_rid rid;\n\t\t\tunion hv_pci_bdf bdf;\n\t\t};\n\n\t\thv_pci_segment segment;\n\t\tunion hv_pci_bus_range shadow_bus_range;\n\n\t\tu16 phantom_function_bits:2;\n\t\tu16 source_shadow:1;\n\n\t\tu16 rsvdz0:11;\n\t\tu16 device_type:2;\n\t} pci;\n\n\t \n\tstruct {\n\t\tu8 ioapic_id;\n\t\tu8 rsvdz0;\n\t\tu16 rsvdz1;\n\t\tu16 rsvdz2;\n\n\t\tu16 rsvdz3:14;\n\t\tu16 device_type:2;\n\t} ioapic;\n\n\t \n\tstruct {\n\t\tu32 input_mapping_base;\n\t\tu32 input_mapping_count:30;\n\t\tu32 device_type:2;\n\t} acpi;\n} __packed;\n\nenum hv_interrupt_trigger_mode {\n\tHV_INTERRUPT_TRIGGER_MODE_EDGE = 0,\n\tHV_INTERRUPT_TRIGGER_MODE_LEVEL = 1,\n};\n\nstruct hv_device_interrupt_descriptor {\n\tu32 interrupt_type;\n\tu32 trigger_mode;\n\tu32 vector_count;\n\tu32 reserved;\n\tstruct hv_device_interrupt_target target;\n} __packed;\n\nstruct hv_input_map_device_interrupt {\n\tu64 partition_id;\n\tu64 device_id;\n\tu64 flags;\n\tstruct hv_interrupt_entry logical_interrupt_entry;\n\tstruct hv_device_interrupt_descriptor interrupt_descriptor;\n} __packed;\n\nstruct hv_output_map_device_interrupt {\n\tstruct hv_interrupt_entry interrupt_entry;\n} __packed;\n\nstruct hv_input_unmap_device_interrupt {\n\tu64 partition_id;\n\tu64 device_id;\n\tstruct hv_interrupt_entry interrupt_entry;\n} __packed;\n\n#define HV_SOURCE_SHADOW_NONE               0x0\n#define HV_SOURCE_SHADOW_BRIDGE_BUS_RANGE   0x1\n\n \n#define HV_MEMORY_HINT_MAX_GPA_PAGE_RANGES  \\\n\t((HV_HYP_PAGE_SIZE - sizeof(struct hv_memory_hint)) / \\\n\t\tsizeof(union hv_gpa_page_range))\n\n \n#define HV_EXT_MEMORY_HEAT_HINT_TYPE_COLD_DISCARD\t2\nstruct hv_memory_hint {\n\tu64 type:2;\n\tu64 reserved:62;\n\tunion hv_gpa_page_range ranges[];\n} __packed;\n\n \n#define HV_HYPERCALL_MMIO_MAX_DATA_LENGTH 64\n\nstruct hv_mmio_read_input {\n\tu64 gpa;\n\tu32 size;\n\tu32 reserved;\n} __packed;\n\nstruct hv_mmio_read_output {\n\tu8 data[HV_HYPERCALL_MMIO_MAX_DATA_LENGTH];\n} __packed;\n\nstruct hv_mmio_write_input {\n\tu64 gpa;\n\tu32 size;\n\tu32 reserved;\n\tu8 data[HV_HYPERCALL_MMIO_MAX_DATA_LENGTH];\n} __packed;\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}