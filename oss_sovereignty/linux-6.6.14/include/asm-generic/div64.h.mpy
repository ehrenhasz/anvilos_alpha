{
  "module_name": "div64.h",
  "hash_id": "3deec9cfe365a551f03e40ce6858a44cbb88f0f52fe4d1d1a23178d02cba4197",
  "original_prompt": "Ingested from linux-6.6.14/include/asm-generic/div64.h",
  "human_readable_source": " \n#ifndef _ASM_GENERIC_DIV64_H\n#define _ASM_GENERIC_DIV64_H\n \n\n#include <linux/types.h>\n#include <linux/compiler.h>\n\n#if BITS_PER_LONG == 64\n\n \n# define do_div(n,base) ({\t\t\t\t\t\\\n\tuint32_t __base = (base);\t\t\t\t\\\n\tuint32_t __rem;\t\t\t\t\t\t\\\n\t__rem = ((uint64_t)(n)) % __base;\t\t\t\\\n\t(n) = ((uint64_t)(n)) / __base;\t\t\t\t\\\n\t__rem;\t\t\t\t\t\t\t\\\n })\n\n#elif BITS_PER_LONG == 32\n\n#include <linux/log2.h>\n\n \n\n#define __div64_const32(n, ___b)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\t\t\\\n\tuint64_t ___res, ___x, ___t, ___m, ___n = (n);\t\t\t\\\n\tuint32_t ___p, ___bias;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\t___p = 1 << ilog2(___b);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\\\n\t___m = (~0ULL / ___b) * ___p;\t\t\t\t\t\\\n\t___m += (((~0ULL % ___b + 1) * ___p) + ___b - 1) / ___b;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\\\n\t___x = ~0ULL / ___b * ___b - 1;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\\\n\t___res = ((___m & 0xffffffff) * (___x & 0xffffffff)) >> 32;\t\\\n\t___t = ___res += (___m & 0xffffffff) * (___x >> 32);\t\t\\\n\t___res += (___x & 0xffffffff) * (___m >> 32);\t\t\t\\\n\t___t = (___res < ___t) ? (1ULL << 32) : 0;\t\t\t\\\n\t___res = (___res >> 32) + ___t;\t\t\t\t\t\\\n\t___res += (___m >> 32) * (___x >> 32);\t\t\t\t\\\n\t___res /= ___p;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\\\n\tif (~0ULL % (___b / (___b & -___b)) == 0) {\t\t\t\\\n\t\t \t\t\\\n\t\t___n /= (___b & -___b);\t\t\t\t\t\\\n\t\t___m = ~0ULL / (___b / (___b & -___b));\t\t\t\\\n\t\t___p = 1;\t\t\t\t\t\t\\\n\t\t___bias = 1;\t\t\t\t\t\t\\\n\t} else if (___res != ___x / ___b) {\t\t\t\t\\\n\t\t \t\t\t\t\t\t\t\\\n\t\t___bias = 1;\t\t\t\t\t\t\\\n\t\t \t\t\t\t\\\n\t\t___m = (~0ULL / ___b) * ___p;\t\t\t\t\\\n\t\t___m += ((~0ULL % ___b + 1) * ___p) / ___b;\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\t \t\t\t\t\t\t\t\\\n\t\tuint32_t ___bits = -(___m & -___m);\t\t\t\\\n\t\t___bits |= ___m >> 32;\t\t\t\t\t\\\n\t\t___bits = (~___bits) << 1;\t\t\t\t\\\n\t\t \t\t\t\t\t\t\t\\\n\t\tif (!___bits) {\t\t\t\t\t\t\\\n\t\t\t___p /= (___m & -___m);\t\t\t\t\\\n\t\t\t___m /= (___m & -___m);\t\t\t\t\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\t___p >>= ilog2(___bits);\t\t\t\\\n\t\t\t___m >>= ilog2(___bits);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t \t\t\t\t\t\\\n\t\t___bias = 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\t\t\\\n\t___res = __arch_xprod_64(___m, ___n, ___bias);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t___res /= ___p;\t\t\t\t\t\t\t\\\n})\n\n#ifndef __arch_xprod_64\n \nstatic inline uint64_t __arch_xprod_64(const uint64_t m, uint64_t n, bool bias)\n{\n\tuint32_t m_lo = m;\n\tuint32_t m_hi = m >> 32;\n\tuint32_t n_lo = n;\n\tuint32_t n_hi = n >> 32;\n\tuint64_t res;\n\tuint32_t res_lo, res_hi, tmp;\n\n\tif (!bias) {\n\t\tres = ((uint64_t)m_lo * n_lo) >> 32;\n\t} else if (!(m & ((1ULL << 63) | (1ULL << 31)))) {\n\t\t \n\t\tres = (m + (uint64_t)m_lo * n_lo) >> 32;\n\t} else {\n\t\tres = m + (uint64_t)m_lo * n_lo;\n\t\tres_lo = res >> 32;\n\t\tres_hi = (res_lo < m_hi);\n\t\tres = res_lo | ((uint64_t)res_hi << 32);\n\t}\n\n\tif (!(m & ((1ULL << 63) | (1ULL << 31)))) {\n\t\t \n\t\tres += (uint64_t)m_lo * n_hi;\n\t\tres += (uint64_t)m_hi * n_lo;\n\t\tres >>= 32;\n\t} else {\n\t\tres += (uint64_t)m_lo * n_hi;\n\t\ttmp = res >> 32;\n\t\tres += (uint64_t)m_hi * n_lo;\n\t\tres_lo = res >> 32;\n\t\tres_hi = (res_lo < tmp);\n\t\tres = res_lo | ((uint64_t)res_hi << 32);\n\t}\n\n\tres += (uint64_t)m_hi * n_hi;\n\n\treturn res;\n}\n#endif\n\n#ifndef __div64_32\nextern uint32_t __div64_32(uint64_t *dividend, uint32_t divisor);\n#endif\n\n \n# define do_div(n,base) ({\t\t\t\t\\\n\tuint32_t __base = (base);\t\t\t\\\n\tuint32_t __rem;\t\t\t\t\t\\\n\t(void)(((typeof((n)) *)0) == ((uint64_t *)0));\t\\\n\tif (__builtin_constant_p(__base) &&\t\t\\\n\t    is_power_of_2(__base)) {\t\t\t\\\n\t\t__rem = (n) & (__base - 1);\t\t\\\n\t\t(n) >>= ilog2(__base);\t\t\t\\\n\t} else if (__builtin_constant_p(__base) &&\t\\\n\t\t   __base != 0) {\t\t\t\\\n\t\tuint32_t __res_lo, __n_lo = (n);\t\\\n\t\t(n) = __div64_const32(n, __base);\t\\\n\t\t  \\\n\t\t__res_lo = (n);\t\t\t\t\\\n\t\t__rem = __n_lo - __res_lo * __base;\t\\\n\t} else if (likely(((n) >> 32) == 0)) {\t\t\\\n\t\t__rem = (uint32_t)(n) % __base;\t\t\\\n\t\t(n) = (uint32_t)(n) / __base;\t\t\\\n\t} else {\t\t\t\t\t\\\n\t\t__rem = __div64_32(&(n), __base);\t\\\n\t}\t\t\t\t\t\t\\\n\t__rem;\t\t\t\t\t\t\\\n })\n\n#else  \n\n# error do_div() does not yet support the C64\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}