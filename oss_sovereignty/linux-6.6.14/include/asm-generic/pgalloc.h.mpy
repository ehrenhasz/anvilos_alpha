{
  "module_name": "pgalloc.h",
  "hash_id": "bed70dcbf0e79d22450a003ef7523b5e45ddfbc31e6b367472d2fb2a3957f60f",
  "original_prompt": "Ingested from linux-6.6.14/include/asm-generic/pgalloc.h",
  "human_readable_source": " \n#ifndef __ASM_GENERIC_PGALLOC_H\n#define __ASM_GENERIC_PGALLOC_H\n\n#ifdef CONFIG_MMU\n\n#define GFP_PGTABLE_KERNEL\t(GFP_KERNEL | __GFP_ZERO)\n#define GFP_PGTABLE_USER\t(GFP_PGTABLE_KERNEL | __GFP_ACCOUNT)\n\n \nstatic inline pte_t *__pte_alloc_one_kernel(struct mm_struct *mm)\n{\n\tstruct ptdesc *ptdesc = pagetable_alloc(GFP_PGTABLE_KERNEL &\n\t\t\t~__GFP_HIGHMEM, 0);\n\n\tif (!ptdesc)\n\t\treturn NULL;\n\treturn ptdesc_address(ptdesc);\n}\n\n#ifndef __HAVE_ARCH_PTE_ALLOC_ONE_KERNEL\n \nstatic inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm)\n{\n\treturn __pte_alloc_one_kernel(mm);\n}\n#endif\n\n \nstatic inline void pte_free_kernel(struct mm_struct *mm, pte_t *pte)\n{\n\tpagetable_free(virt_to_ptdesc(pte));\n}\n\n \nstatic inline pgtable_t __pte_alloc_one(struct mm_struct *mm, gfp_t gfp)\n{\n\tstruct ptdesc *ptdesc;\n\n\tptdesc = pagetable_alloc(gfp, 0);\n\tif (!ptdesc)\n\t\treturn NULL;\n\tif (!pagetable_pte_ctor(ptdesc)) {\n\t\tpagetable_free(ptdesc);\n\t\treturn NULL;\n\t}\n\n\treturn ptdesc_page(ptdesc);\n}\n\n#ifndef __HAVE_ARCH_PTE_ALLOC_ONE\n \nstatic inline pgtable_t pte_alloc_one(struct mm_struct *mm)\n{\n\treturn __pte_alloc_one(mm, GFP_PGTABLE_USER);\n}\n#endif\n\n \n\n \nstatic inline void pte_free(struct mm_struct *mm, struct page *pte_page)\n{\n\tstruct ptdesc *ptdesc = page_ptdesc(pte_page);\n\n\tpagetable_pte_dtor(ptdesc);\n\tpagetable_free(ptdesc);\n}\n\n\n#if CONFIG_PGTABLE_LEVELS > 2\n\n#ifndef __HAVE_ARCH_PMD_ALLOC_ONE\n \nstatic inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct ptdesc *ptdesc;\n\tgfp_t gfp = GFP_PGTABLE_USER;\n\n\tif (mm == &init_mm)\n\t\tgfp = GFP_PGTABLE_KERNEL;\n\tptdesc = pagetable_alloc(gfp, 0);\n\tif (!ptdesc)\n\t\treturn NULL;\n\tif (!pagetable_pmd_ctor(ptdesc)) {\n\t\tpagetable_free(ptdesc);\n\t\treturn NULL;\n\t}\n\treturn ptdesc_address(ptdesc);\n}\n#endif\n\n#ifndef __HAVE_ARCH_PMD_FREE\nstatic inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)\n{\n\tstruct ptdesc *ptdesc = virt_to_ptdesc(pmd);\n\n\tBUG_ON((unsigned long)pmd & (PAGE_SIZE-1));\n\tpagetable_pmd_dtor(ptdesc);\n\tpagetable_free(ptdesc);\n}\n#endif\n\n#endif  \n\n#if CONFIG_PGTABLE_LEVELS > 3\n\nstatic inline pud_t *__pud_alloc_one(struct mm_struct *mm, unsigned long addr)\n{\n\tgfp_t gfp = GFP_PGTABLE_USER;\n\tstruct ptdesc *ptdesc;\n\n\tif (mm == &init_mm)\n\t\tgfp = GFP_PGTABLE_KERNEL;\n\tgfp &= ~__GFP_HIGHMEM;\n\n\tptdesc = pagetable_alloc(gfp, 0);\n\tif (!ptdesc)\n\t\treturn NULL;\n\treturn ptdesc_address(ptdesc);\n}\n\n#ifndef __HAVE_ARCH_PUD_ALLOC_ONE\n \nstatic inline pud_t *pud_alloc_one(struct mm_struct *mm, unsigned long addr)\n{\n\treturn __pud_alloc_one(mm, addr);\n}\n#endif\n\nstatic inline void __pud_free(struct mm_struct *mm, pud_t *pud)\n{\n\tBUG_ON((unsigned long)pud & (PAGE_SIZE-1));\n\tpagetable_free(virt_to_ptdesc(pud));\n}\n\n#ifndef __HAVE_ARCH_PUD_FREE\nstatic inline void pud_free(struct mm_struct *mm, pud_t *pud)\n{\n\t__pud_free(mm, pud);\n}\n#endif\n\n#endif  \n\n#ifndef __HAVE_ARCH_PGD_FREE\nstatic inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)\n{\n\tpagetable_free(virt_to_ptdesc(pgd));\n}\n#endif\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}