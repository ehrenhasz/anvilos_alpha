{
  "module_name": "mshyperv.h",
  "hash_id": "e42eabc9634b40267e5e9a6c51637682e819149b1f2bb6ee5a23a1840a4f2a0b",
  "original_prompt": "Ingested from linux-6.6.14/include/asm-generic/mshyperv.h",
  "human_readable_source": " \n\n \n\n#ifndef _ASM_GENERIC_MSHYPERV_H\n#define _ASM_GENERIC_MSHYPERV_H\n\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/cpumask.h>\n#include <linux/nmi.h>\n#include <asm/ptrace.h>\n#include <asm/hyperv-tlfs.h>\n\n#define VTPM_BASE_ADDRESS 0xfed40000\n\nstruct ms_hyperv_info {\n\tu32 features;\n\tu32 priv_high;\n\tu32 misc_features;\n\tu32 hints;\n\tu32 nested_features;\n\tu32 max_vp_index;\n\tu32 max_lp_index;\n\tu8 vtl;\n\tunion {\n\t\tu32 isolation_config_a;\n\t\tstruct {\n\t\t\tu32 paravisor_present : 1;\n\t\t\tu32 reserved_a1 : 31;\n\t\t};\n\t};\n\tunion {\n\t\tu32 isolation_config_b;\n\t\tstruct {\n\t\t\tu32 cvm_type : 4;\n\t\t\tu32 reserved_b1 : 1;\n\t\t\tu32 shared_gpa_boundary_active : 1;\n\t\t\tu32 shared_gpa_boundary_bits : 6;\n\t\t\tu32 reserved_b2 : 20;\n\t\t};\n\t};\n\tu64 shared_gpa_boundary;\n};\nextern struct ms_hyperv_info ms_hyperv;\nextern bool hv_nested;\n\nextern void * __percpu *hyperv_pcpu_input_arg;\nextern void * __percpu *hyperv_pcpu_output_arg;\n\nextern u64 hv_do_hypercall(u64 control, void *inputaddr, void *outputaddr);\nextern u64 hv_do_fast_hypercall8(u16 control, u64 input8);\nbool hv_isolation_type_snp(void);\nbool hv_isolation_type_tdx(void);\n\n \nstatic inline int hv_result(u64 status)\n{\n\treturn status & HV_HYPERCALL_RESULT_MASK;\n}\n\nstatic inline bool hv_result_success(u64 status)\n{\n\treturn hv_result(status) == HV_STATUS_SUCCESS;\n}\n\nstatic inline unsigned int hv_repcomp(u64 status)\n{\n\t \n\treturn (status & HV_HYPERCALL_REP_COMP_MASK) >>\n\t\t\t HV_HYPERCALL_REP_COMP_OFFSET;\n}\n\n \nstatic inline u64 hv_do_rep_hypercall(u16 code, u16 rep_count, u16 varhead_size,\n\t\t\t\t      void *input, void *output)\n{\n\tu64 control = code;\n\tu64 status;\n\tu16 rep_comp;\n\n\tcontrol |= (u64)varhead_size << HV_HYPERCALL_VARHEAD_OFFSET;\n\tcontrol |= (u64)rep_count << HV_HYPERCALL_REP_COMP_OFFSET;\n\n\tdo {\n\t\tstatus = hv_do_hypercall(control, input, output);\n\t\tif (!hv_result_success(status))\n\t\t\treturn status;\n\n\t\trep_comp = hv_repcomp(status);\n\n\t\tcontrol &= ~HV_HYPERCALL_REP_START_MASK;\n\t\tcontrol |= (u64)rep_comp << HV_HYPERCALL_REP_START_OFFSET;\n\n\t\ttouch_nmi_watchdog();\n\t} while (rep_comp < rep_count);\n\n\treturn status;\n}\n\n \nstatic inline u64 hv_generate_guest_id(u64 kernel_version)\n{\n\tu64 guest_id;\n\n\tguest_id = (((u64)HV_LINUX_VENDOR_ID) << 48);\n\tguest_id |= (kernel_version << 16);\n\n\treturn guest_id;\n}\n\n \nstatic inline void vmbus_signal_eom(struct hv_message *msg, u32 old_msg_type)\n{\n\t \n\tif (cmpxchg(&msg->header.message_type, old_msg_type,\n\t\t    HVMSG_NONE) != old_msg_type)\n\t\treturn;\n\n\t \n\tif (msg->header.message_flags.msg_pending) {\n\t\t \n\t\thv_set_register(HV_REGISTER_EOM, 0);\n\t}\n}\n\nvoid hv_setup_vmbus_handler(void (*handler)(void));\nvoid hv_remove_vmbus_handler(void);\nvoid hv_setup_stimer0_handler(void (*handler)(void));\nvoid hv_remove_stimer0_handler(void);\n\nvoid hv_setup_kexec_handler(void (*handler)(void));\nvoid hv_remove_kexec_handler(void);\nvoid hv_setup_crash_handler(void (*handler)(struct pt_regs *regs));\nvoid hv_remove_crash_handler(void);\n\nextern int vmbus_interrupt;\nextern int vmbus_irq;\n\nextern bool hv_root_partition;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n \nextern u32 *hv_vp_index;\nextern u32 hv_max_vp_index;\n\nextern u64 (*hv_read_reference_counter)(void);\n\n \n#define VP_INVAL\tU32_MAX\n\nint __init hv_common_init(void);\nvoid __init hv_common_free(void);\nint hv_common_cpu_init(unsigned int cpu);\nint hv_common_cpu_die(unsigned int cpu);\n\nvoid *hv_alloc_hyperv_page(void);\nvoid *hv_alloc_hyperv_zeroed_page(void);\nvoid hv_free_hyperv_page(void *addr);\n\n \nstatic inline int hv_cpu_number_to_vp_number(int cpu_number)\n{\n\treturn hv_vp_index[cpu_number];\n}\n\nstatic inline int __cpumask_to_vpset(struct hv_vpset *vpset,\n\t\t\t\t    const struct cpumask *cpus,\n\t\t\t\t    bool (*func)(int cpu))\n{\n\tint cpu, vcpu, vcpu_bank, vcpu_offset, nr_bank = 1;\n\tint max_vcpu_bank = hv_max_vp_index / HV_VCPUS_PER_SPARSE_BANK;\n\n\t \n\tif (max_vcpu_bank >= HV_MAX_SPARSE_VCPU_BANKS)\n\t\treturn 0;\n\n\t \n\tfor (vcpu_bank = 0; vcpu_bank <= max_vcpu_bank; vcpu_bank++)\n\t\tvpset->bank_contents[vcpu_bank] = 0;\n\n\t \n\tfor_each_cpu(cpu, cpus) {\n\t\tif (func && func(cpu))\n\t\t\tcontinue;\n\t\tvcpu = hv_cpu_number_to_vp_number(cpu);\n\t\tif (vcpu == VP_INVAL)\n\t\t\treturn -1;\n\t\tvcpu_bank = vcpu / HV_VCPUS_PER_SPARSE_BANK;\n\t\tvcpu_offset = vcpu % HV_VCPUS_PER_SPARSE_BANK;\n\t\t__set_bit(vcpu_offset, (unsigned long *)\n\t\t\t  &vpset->bank_contents[vcpu_bank]);\n\t\tif (vcpu_bank >= nr_bank)\n\t\t\tnr_bank = vcpu_bank + 1;\n\t}\n\tvpset->valid_bank_mask = GENMASK_ULL(nr_bank - 1, 0);\n\treturn nr_bank;\n}\n\n \nstatic inline int cpumask_to_vpset(struct hv_vpset *vpset,\n\t\t\t\t    const struct cpumask *cpus)\n{\n\treturn __cpumask_to_vpset(vpset, cpus, NULL);\n}\n\nstatic inline int cpumask_to_vpset_skip(struct hv_vpset *vpset,\n\t\t\t\t    const struct cpumask *cpus,\n\t\t\t\t    bool (*func)(int cpu))\n{\n\treturn __cpumask_to_vpset(vpset, cpus, func);\n}\n\nvoid hyperv_report_panic(struct pt_regs *regs, long err, bool in_die);\nbool hv_is_hyperv_initialized(void);\nbool hv_is_hibernation_supported(void);\nenum hv_isolation_type hv_get_isolation_type(void);\nbool hv_is_isolation_supported(void);\nbool hv_isolation_type_snp(void);\nu64 hv_ghcb_hypercall(u64 control, void *input, void *output, u32 input_size);\nu64 hv_tdx_hypercall(u64 control, u64 param1, u64 param2);\nvoid hyperv_cleanup(void);\nbool hv_query_ext_cap(u64 cap_query);\nvoid hv_setup_dma_ops(struct device *dev, bool coherent);\n#else  \nstatic inline bool hv_is_hyperv_initialized(void) { return false; }\nstatic inline bool hv_is_hibernation_supported(void) { return false; }\nstatic inline void hyperv_cleanup(void) {}\nstatic inline bool hv_is_isolation_supported(void) { return false; }\nstatic inline enum hv_isolation_type hv_get_isolation_type(void)\n{\n\treturn HV_ISOLATION_TYPE_NONE;\n}\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}