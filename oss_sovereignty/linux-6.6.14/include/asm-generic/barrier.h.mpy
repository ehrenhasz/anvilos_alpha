{
  "module_name": "barrier.h",
  "hash_id": "cb1120f624db80d7d2b7d699b900600c994d5918cfe7442ce6ed554292a4c5ff",
  "original_prompt": "Ingested from linux-6.6.14/include/asm-generic/barrier.h",
  "human_readable_source": " \n \n#ifndef __ASM_GENERIC_BARRIER_H\n#define __ASM_GENERIC_BARRIER_H\n\n#ifndef __ASSEMBLY__\n\n#include <linux/compiler.h>\n#include <linux/kcsan-checks.h>\n#include <asm/rwonce.h>\n\n#ifndef nop\n#define nop()\tasm volatile (\"nop\")\n#endif\n\n \n\n#ifdef __mb\n#define mb()\tdo { kcsan_mb(); __mb(); } while (0)\n#endif\n\n#ifdef __rmb\n#define rmb()\tdo { kcsan_rmb(); __rmb(); } while (0)\n#endif\n\n#ifdef __wmb\n#define wmb()\tdo { kcsan_wmb(); __wmb(); } while (0)\n#endif\n\n#ifdef __dma_mb\n#define dma_mb()\tdo { kcsan_mb(); __dma_mb(); } while (0)\n#endif\n\n#ifdef __dma_rmb\n#define dma_rmb()\tdo { kcsan_rmb(); __dma_rmb(); } while (0)\n#endif\n\n#ifdef __dma_wmb\n#define dma_wmb()\tdo { kcsan_wmb(); __dma_wmb(); } while (0)\n#endif\n\n \n\n#ifndef mb\n#define mb()\tbarrier()\n#endif\n\n#ifndef rmb\n#define rmb()\tmb()\n#endif\n\n#ifndef wmb\n#define wmb()\tmb()\n#endif\n\n#ifndef dma_mb\n#define dma_mb()\tmb()\n#endif\n\n#ifndef dma_rmb\n#define dma_rmb()\trmb()\n#endif\n\n#ifndef dma_wmb\n#define dma_wmb()\twmb()\n#endif\n\n#ifndef __smp_mb\n#define __smp_mb()\tmb()\n#endif\n\n#ifndef __smp_rmb\n#define __smp_rmb()\trmb()\n#endif\n\n#ifndef __smp_wmb\n#define __smp_wmb()\twmb()\n#endif\n\n#ifdef CONFIG_SMP\n\n#ifndef smp_mb\n#define smp_mb()\tdo { kcsan_mb(); __smp_mb(); } while (0)\n#endif\n\n#ifndef smp_rmb\n#define smp_rmb()\tdo { kcsan_rmb(); __smp_rmb(); } while (0)\n#endif\n\n#ifndef smp_wmb\n#define smp_wmb()\tdo { kcsan_wmb(); __smp_wmb(); } while (0)\n#endif\n\n#else\t \n\n#ifndef smp_mb\n#define smp_mb()\tbarrier()\n#endif\n\n#ifndef smp_rmb\n#define smp_rmb()\tbarrier()\n#endif\n\n#ifndef smp_wmb\n#define smp_wmb()\tbarrier()\n#endif\n\n#endif\t \n\n#ifndef __smp_store_mb\n#define __smp_store_mb(var, value)  do { WRITE_ONCE(var, value); __smp_mb(); } while (0)\n#endif\n\n#ifndef __smp_mb__before_atomic\n#define __smp_mb__before_atomic()\t__smp_mb()\n#endif\n\n#ifndef __smp_mb__after_atomic\n#define __smp_mb__after_atomic()\t__smp_mb()\n#endif\n\n#ifndef __smp_store_release\n#define __smp_store_release(p, v)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tcompiletime_assert_atomic_type(*p);\t\t\t\t\\\n\t__smp_mb();\t\t\t\t\t\t\t\\\n\tWRITE_ONCE(*p, v);\t\t\t\t\t\t\\\n} while (0)\n#endif\n\n#ifndef __smp_load_acquire\n#define __smp_load_acquire(p)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(*p) ___p1 = READ_ONCE(*p);\t\t\\\n\tcompiletime_assert_atomic_type(*p);\t\t\t\t\\\n\t__smp_mb();\t\t\t\t\t\t\t\\\n\t(typeof(*p))___p1;\t\t\t\t\t\t\\\n})\n#endif\n\n#ifdef CONFIG_SMP\n\n#ifndef smp_store_mb\n#define smp_store_mb(var, value)  do { kcsan_mb(); __smp_store_mb(var, value); } while (0)\n#endif\n\n#ifndef smp_mb__before_atomic\n#define smp_mb__before_atomic()\tdo { kcsan_mb(); __smp_mb__before_atomic(); } while (0)\n#endif\n\n#ifndef smp_mb__after_atomic\n#define smp_mb__after_atomic()\tdo { kcsan_mb(); __smp_mb__after_atomic(); } while (0)\n#endif\n\n#ifndef smp_store_release\n#define smp_store_release(p, v) do { kcsan_release(); __smp_store_release(p, v); } while (0)\n#endif\n\n#ifndef smp_load_acquire\n#define smp_load_acquire(p) __smp_load_acquire(p)\n#endif\n\n#else\t \n\n#ifndef smp_store_mb\n#define smp_store_mb(var, value)  do { WRITE_ONCE(var, value); barrier(); } while (0)\n#endif\n\n#ifndef smp_mb__before_atomic\n#define smp_mb__before_atomic()\tbarrier()\n#endif\n\n#ifndef smp_mb__after_atomic\n#define smp_mb__after_atomic()\tbarrier()\n#endif\n\n#ifndef smp_store_release\n#define smp_store_release(p, v)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tcompiletime_assert_atomic_type(*p);\t\t\t\t\\\n\tbarrier();\t\t\t\t\t\t\t\\\n\tWRITE_ONCE(*p, v);\t\t\t\t\t\t\\\n} while (0)\n#endif\n\n#ifndef smp_load_acquire\n#define smp_load_acquire(p)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(*p) ___p1 = READ_ONCE(*p);\t\t\\\n\tcompiletime_assert_atomic_type(*p);\t\t\t\t\\\n\tbarrier();\t\t\t\t\t\t\t\\\n\t(typeof(*p))___p1;\t\t\t\t\t\t\\\n})\n#endif\n\n#endif\t \n\n \n#define virt_mb() do { kcsan_mb(); __smp_mb(); } while (0)\n#define virt_rmb() do { kcsan_rmb(); __smp_rmb(); } while (0)\n#define virt_wmb() do { kcsan_wmb(); __smp_wmb(); } while (0)\n#define virt_store_mb(var, value) do { kcsan_mb(); __smp_store_mb(var, value); } while (0)\n#define virt_mb__before_atomic() do { kcsan_mb(); __smp_mb__before_atomic(); } while (0)\n#define virt_mb__after_atomic()\tdo { kcsan_mb(); __smp_mb__after_atomic(); } while (0)\n#define virt_store_release(p, v) do { kcsan_release(); __smp_store_release(p, v); } while (0)\n#define virt_load_acquire(p) __smp_load_acquire(p)\n\n \n#ifndef smp_acquire__after_ctrl_dep\n#define smp_acquire__after_ctrl_dep()\t\tsmp_rmb()\n#endif\n\n \n#ifndef smp_cond_load_relaxed\n#define smp_cond_load_relaxed(ptr, cond_expr) ({\t\t\\\n\ttypeof(ptr) __PTR = (ptr);\t\t\t\t\\\n\t__unqual_scalar_typeof(*ptr) VAL;\t\t\t\\\n\tfor (;;) {\t\t\t\t\t\t\\\n\t\tVAL = READ_ONCE(*__PTR);\t\t\t\\\n\t\tif (cond_expr)\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\\\n\t\tcpu_relax();\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t(typeof(*ptr))VAL;\t\t\t\t\t\\\n})\n#endif\n\n \n#ifndef smp_cond_load_acquire\n#define smp_cond_load_acquire(ptr, cond_expr) ({\t\t\\\n\t__unqual_scalar_typeof(*ptr) _val;\t\t\t\\\n\t_val = smp_cond_load_relaxed(ptr, cond_expr);\t\t\\\n\tsmp_acquire__after_ctrl_dep();\t\t\t\t\\\n\t(typeof(*ptr))_val;\t\t\t\t\t\\\n})\n#endif\n\n \n#ifndef pmem_wmb\n#define pmem_wmb()\twmb()\n#endif\n\n \n#ifndef io_stop_wc\n#define io_stop_wc() do { } while (0)\n#endif\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}