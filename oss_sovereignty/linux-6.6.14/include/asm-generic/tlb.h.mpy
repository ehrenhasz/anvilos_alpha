{
  "module_name": "tlb.h",
  "hash_id": "53779c6c3cb8f21947f72e4bd77061494db802d079bb8143e1266adbcb932702",
  "original_prompt": "Ingested from linux-6.6.14/include/asm-generic/tlb.h",
  "human_readable_source": " \n \n#ifndef _ASM_GENERIC__TLB_H\n#define _ASM_GENERIC__TLB_H\n\n#include <linux/mmu_notifier.h>\n#include <linux/swap.h>\n#include <linux/hugetlb_inline.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n\n \n#ifndef nmi_uaccess_okay\n# define nmi_uaccess_okay() true\n#endif\n\n#ifdef CONFIG_MMU\n\n \n\n#ifdef CONFIG_MMU_GATHER_TABLE_FREE\n\nstruct mmu_table_batch {\n#ifdef CONFIG_MMU_GATHER_RCU_TABLE_FREE\n\tstruct rcu_head\t\trcu;\n#endif\n\tunsigned int\t\tnr;\n\tvoid\t\t\t*tables[];\n};\n\n#define MAX_TABLE_BATCH\t\t\\\n\t((PAGE_SIZE - sizeof(struct mmu_table_batch)) / sizeof(void *))\n\nextern void tlb_remove_table(struct mmu_gather *tlb, void *table);\n\n#else  \n\n \n#define tlb_remove_table(tlb, page) tlb_remove_page((tlb), (page))\n\n#endif  \n\n#ifdef CONFIG_MMU_GATHER_RCU_TABLE_FREE\n \n#ifndef tlb_needs_table_invalidate\n#define tlb_needs_table_invalidate() (true)\n#endif\n\nvoid tlb_remove_table_sync_one(void);\n\n#else\n\n#ifdef tlb_needs_table_invalidate\n#error tlb_needs_table_invalidate() requires MMU_GATHER_RCU_TABLE_FREE\n#endif\n\nstatic inline void tlb_remove_table_sync_one(void) { }\n\n#endif  \n\n\n#ifndef CONFIG_MMU_GATHER_NO_GATHER\n \n#define MMU_GATHER_BUNDLE\t8\n\nstruct mmu_gather_batch {\n\tstruct mmu_gather_batch\t*next;\n\tunsigned int\t\tnr;\n\tunsigned int\t\tmax;\n\tstruct encoded_page\t*encoded_pages[];\n};\n\n#define MAX_GATHER_BATCH\t\\\n\t((PAGE_SIZE - sizeof(struct mmu_gather_batch)) / sizeof(void *))\n\n \n#define MAX_GATHER_BATCH_COUNT\t(10000UL/MAX_GATHER_BATCH)\n\nextern bool __tlb_remove_page_size(struct mmu_gather *tlb,\n\t\t\t\t   struct encoded_page *page,\n\t\t\t\t   int page_size);\n\n#ifdef CONFIG_SMP\n \n#define tlb_delay_rmap(tlb) (((tlb)->delayed_rmap = 1), true)\nextern void tlb_flush_rmaps(struct mmu_gather *tlb, struct vm_area_struct *vma);\n#endif\n\n#endif\n\n \n#ifndef tlb_delay_rmap\n#define tlb_delay_rmap(tlb) (false)\nstatic inline void tlb_flush_rmaps(struct mmu_gather *tlb, struct vm_area_struct *vma) { }\n#endif\n\n \nstruct mmu_gather {\n\tstruct mm_struct\t*mm;\n\n#ifdef CONFIG_MMU_GATHER_TABLE_FREE\n\tstruct mmu_table_batch\t*batch;\n#endif\n\n\tunsigned long\t\tstart;\n\tunsigned long\t\tend;\n\t \n\tunsigned int\t\tfullmm : 1;\n\n\t \n\tunsigned int\t\tneed_flush_all : 1;\n\n\t \n\tunsigned int\t\tfreed_tables : 1;\n\n\t \n\tunsigned int\t\tdelayed_rmap : 1;\n\n\t \n\tunsigned int\t\tcleared_ptes : 1;\n\tunsigned int\t\tcleared_pmds : 1;\n\tunsigned int\t\tcleared_puds : 1;\n\tunsigned int\t\tcleared_p4ds : 1;\n\n\t \n\tunsigned int\t\tvma_exec : 1;\n\tunsigned int\t\tvma_huge : 1;\n\tunsigned int\t\tvma_pfn  : 1;\n\n\tunsigned int\t\tbatch_count;\n\n#ifndef CONFIG_MMU_GATHER_NO_GATHER\n\tstruct mmu_gather_batch *active;\n\tstruct mmu_gather_batch\tlocal;\n\tstruct page\t\t*__pages[MMU_GATHER_BUNDLE];\n\n#ifdef CONFIG_MMU_GATHER_PAGE_SIZE\n\tunsigned int page_size;\n#endif\n#endif\n};\n\nvoid tlb_flush_mmu(struct mmu_gather *tlb);\n\nstatic inline void __tlb_adjust_range(struct mmu_gather *tlb,\n\t\t\t\t      unsigned long address,\n\t\t\t\t      unsigned int range_size)\n{\n\ttlb->start = min(tlb->start, address);\n\ttlb->end = max(tlb->end, address + range_size);\n}\n\nstatic inline void __tlb_reset_range(struct mmu_gather *tlb)\n{\n\tif (tlb->fullmm) {\n\t\ttlb->start = tlb->end = ~0;\n\t} else {\n\t\ttlb->start = TASK_SIZE;\n\t\ttlb->end = 0;\n\t}\n\ttlb->freed_tables = 0;\n\ttlb->cleared_ptes = 0;\n\ttlb->cleared_pmds = 0;\n\ttlb->cleared_puds = 0;\n\ttlb->cleared_p4ds = 0;\n\t \n}\n\n#ifdef CONFIG_MMU_GATHER_NO_RANGE\n\n#if defined(tlb_flush)\n#error MMU_GATHER_NO_RANGE relies on default tlb_flush()\n#endif\n\n \nstatic inline void tlb_flush(struct mmu_gather *tlb)\n{\n\tif (tlb->end)\n\t\tflush_tlb_mm(tlb->mm);\n}\n\n#else  \n\n#ifndef tlb_flush\n \nstatic inline void tlb_flush(struct mmu_gather *tlb)\n{\n\tif (tlb->fullmm || tlb->need_flush_all) {\n\t\tflush_tlb_mm(tlb->mm);\n\t} else if (tlb->end) {\n\t\tstruct vm_area_struct vma = {\n\t\t\t.vm_mm = tlb->mm,\n\t\t\t.vm_flags = (tlb->vma_exec ? VM_EXEC    : 0) |\n\t\t\t\t    (tlb->vma_huge ? VM_HUGETLB : 0),\n\t\t};\n\n\t\tflush_tlb_range(&vma, tlb->start, tlb->end);\n\t}\n}\n#endif\n\n#endif  \n\nstatic inline void\ntlb_update_vma_flags(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\t \n\ttlb->vma_huge = is_vm_hugetlb_page(vma);\n\ttlb->vma_exec = !!(vma->vm_flags & VM_EXEC);\n\ttlb->vma_pfn  = !!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP));\n}\n\nstatic inline void tlb_flush_mmu_tlbonly(struct mmu_gather *tlb)\n{\n\t \n\tif (!(tlb->freed_tables || tlb->cleared_ptes || tlb->cleared_pmds ||\n\t      tlb->cleared_puds || tlb->cleared_p4ds))\n\t\treturn;\n\n\ttlb_flush(tlb);\n\t__tlb_reset_range(tlb);\n}\n\nstatic inline void tlb_remove_page_size(struct mmu_gather *tlb,\n\t\t\t\t\tstruct page *page, int page_size)\n{\n\tif (__tlb_remove_page_size(tlb, encode_page(page, 0), page_size))\n\t\ttlb_flush_mmu(tlb);\n}\n\nstatic __always_inline bool __tlb_remove_page(struct mmu_gather *tlb, struct page *page, unsigned int flags)\n{\n\treturn __tlb_remove_page_size(tlb, encode_page(page, flags), PAGE_SIZE);\n}\n\n \nstatic inline void tlb_remove_page(struct mmu_gather *tlb, struct page *page)\n{\n\treturn tlb_remove_page_size(tlb, page, PAGE_SIZE);\n}\n\nstatic inline void tlb_remove_ptdesc(struct mmu_gather *tlb, void *pt)\n{\n\ttlb_remove_table(tlb, pt);\n}\n\n \nstatic inline void tlb_remove_page_ptdesc(struct mmu_gather *tlb, struct ptdesc *pt)\n{\n\ttlb_remove_page(tlb, ptdesc_page(pt));\n}\n\nstatic inline void tlb_change_page_size(struct mmu_gather *tlb,\n\t\t\t\t\t\t     unsigned int page_size)\n{\n#ifdef CONFIG_MMU_GATHER_PAGE_SIZE\n\tif (tlb->page_size && tlb->page_size != page_size) {\n\t\tif (!tlb->fullmm && !tlb->need_flush_all)\n\t\t\ttlb_flush_mmu(tlb);\n\t}\n\n\ttlb->page_size = page_size;\n#endif\n}\n\nstatic inline unsigned long tlb_get_unmap_shift(struct mmu_gather *tlb)\n{\n\tif (tlb->cleared_ptes)\n\t\treturn PAGE_SHIFT;\n\tif (tlb->cleared_pmds)\n\t\treturn PMD_SHIFT;\n\tif (tlb->cleared_puds)\n\t\treturn PUD_SHIFT;\n\tif (tlb->cleared_p4ds)\n\t\treturn P4D_SHIFT;\n\n\treturn PAGE_SHIFT;\n}\n\nstatic inline unsigned long tlb_get_unmap_size(struct mmu_gather *tlb)\n{\n\treturn 1UL << tlb_get_unmap_shift(tlb);\n}\n\n \nstatic inline void tlb_start_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm)\n\t\treturn;\n\n\ttlb_update_vma_flags(tlb, vma);\n#ifndef CONFIG_MMU_GATHER_NO_FLUSH_CACHE\n\tflush_cache_range(vma, vma->vm_start, vma->vm_end);\n#endif\n}\n\nstatic inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm)\n\t\treturn;\n\n\t \n\tif (tlb->vma_pfn || !IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS)) {\n\t\t \n\t\ttlb_flush_mmu_tlbonly(tlb);\n\t}\n}\n\n \nstatic inline void tlb_flush_pte_range(struct mmu_gather *tlb,\n\t\t\t\t     unsigned long address, unsigned long size)\n{\n\t__tlb_adjust_range(tlb, address, size);\n\ttlb->cleared_ptes = 1;\n}\n\nstatic inline void tlb_flush_pmd_range(struct mmu_gather *tlb,\n\t\t\t\t     unsigned long address, unsigned long size)\n{\n\t__tlb_adjust_range(tlb, address, size);\n\ttlb->cleared_pmds = 1;\n}\n\nstatic inline void tlb_flush_pud_range(struct mmu_gather *tlb,\n\t\t\t\t     unsigned long address, unsigned long size)\n{\n\t__tlb_adjust_range(tlb, address, size);\n\ttlb->cleared_puds = 1;\n}\n\nstatic inline void tlb_flush_p4d_range(struct mmu_gather *tlb,\n\t\t\t\t     unsigned long address, unsigned long size)\n{\n\t__tlb_adjust_range(tlb, address, size);\n\ttlb->cleared_p4ds = 1;\n}\n\n#ifndef __tlb_remove_tlb_entry\n#define __tlb_remove_tlb_entry(tlb, ptep, address) do { } while (0)\n#endif\n\n \n#define tlb_remove_tlb_entry(tlb, ptep, address)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\ttlb_flush_pte_range(tlb, address, PAGE_SIZE);\t\\\n\t\t__tlb_remove_tlb_entry(tlb, ptep, address);\t\\\n\t} while (0)\n\n#define tlb_remove_huge_tlb_entry(h, tlb, ptep, address)\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tunsigned long _sz = huge_page_size(h);\t\t\\\n\t\tif (_sz >= P4D_SIZE)\t\t\t\t\\\n\t\t\ttlb_flush_p4d_range(tlb, address, _sz);\t\\\n\t\telse if (_sz >= PUD_SIZE)\t\t\t\\\n\t\t\ttlb_flush_pud_range(tlb, address, _sz);\t\\\n\t\telse if (_sz >= PMD_SIZE)\t\t\t\\\n\t\t\ttlb_flush_pmd_range(tlb, address, _sz);\t\\\n\t\telse\t\t\t\t\t\t\\\n\t\t\ttlb_flush_pte_range(tlb, address, _sz);\t\\\n\t\t__tlb_remove_tlb_entry(tlb, ptep, address);\t\\\n\t} while (0)\n\n \n#ifndef __tlb_remove_pmd_tlb_entry\n#define __tlb_remove_pmd_tlb_entry(tlb, pmdp, address) do {} while (0)\n#endif\n\n#define tlb_remove_pmd_tlb_entry(tlb, pmdp, address)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttlb_flush_pmd_range(tlb, address, HPAGE_PMD_SIZE);\t\\\n\t\t__tlb_remove_pmd_tlb_entry(tlb, pmdp, address);\t\t\\\n\t} while (0)\n\n \n#ifndef __tlb_remove_pud_tlb_entry\n#define __tlb_remove_pud_tlb_entry(tlb, pudp, address) do {} while (0)\n#endif\n\n#define tlb_remove_pud_tlb_entry(tlb, pudp, address)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttlb_flush_pud_range(tlb, address, HPAGE_PUD_SIZE);\t\\\n\t\t__tlb_remove_pud_tlb_entry(tlb, pudp, address);\t\t\\\n\t} while (0)\n\n \n\n#ifndef pte_free_tlb\n#define pte_free_tlb(tlb, ptep, address)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\ttlb_flush_pmd_range(tlb, address, PAGE_SIZE);\t\\\n\t\ttlb->freed_tables = 1;\t\t\t\t\\\n\t\t__pte_free_tlb(tlb, ptep, address);\t\t\\\n\t} while (0)\n#endif\n\n#ifndef pmd_free_tlb\n#define pmd_free_tlb(tlb, pmdp, address)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\ttlb_flush_pud_range(tlb, address, PAGE_SIZE);\t\\\n\t\ttlb->freed_tables = 1;\t\t\t\t\\\n\t\t__pmd_free_tlb(tlb, pmdp, address);\t\t\\\n\t} while (0)\n#endif\n\n#ifndef pud_free_tlb\n#define pud_free_tlb(tlb, pudp, address)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\ttlb_flush_p4d_range(tlb, address, PAGE_SIZE);\t\\\n\t\ttlb->freed_tables = 1;\t\t\t\t\\\n\t\t__pud_free_tlb(tlb, pudp, address);\t\t\\\n\t} while (0)\n#endif\n\n#ifndef p4d_free_tlb\n#define p4d_free_tlb(tlb, pudp, address)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\t__tlb_adjust_range(tlb, address, PAGE_SIZE);\t\\\n\t\ttlb->freed_tables = 1;\t\t\t\t\\\n\t\t__p4d_free_tlb(tlb, pudp, address);\t\t\\\n\t} while (0)\n#endif\n\n#ifndef pte_needs_flush\nstatic inline bool pte_needs_flush(pte_t oldpte, pte_t newpte)\n{\n\treturn true;\n}\n#endif\n\n#ifndef huge_pmd_needs_flush\nstatic inline bool huge_pmd_needs_flush(pmd_t oldpmd, pmd_t newpmd)\n{\n\treturn true;\n}\n#endif\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}