{
  "module_name": "unaligned.h",
  "hash_id": "73840e5e01d72b3ebb36bbe9402cb522e7dcc866cf9c9fa0cbc528c986fe3528",
  "original_prompt": "Ingested from linux-6.6.14/include/asm-generic/unaligned.h",
  "human_readable_source": " \n#ifndef __ASM_GENERIC_UNALIGNED_H\n#define __ASM_GENERIC_UNALIGNED_H\n\n \n#include <linux/unaligned/packed_struct.h>\n#include <asm/byteorder.h>\n\n#define __get_unaligned_t(type, ptr) ({\t\t\t\t\t\t\\\n\tconst struct { type x; } __packed *__pptr = (typeof(__pptr))(ptr);\t\\\n\t__pptr->x;\t\t\t\t\t\t\t\t\\\n})\n\n#define __put_unaligned_t(type, val, ptr) do {\t\t\t\t\t\\\n\tstruct { type x; } __packed *__pptr = (typeof(__pptr))(ptr);\t\t\\\n\t__pptr->x = (val);\t\t\t\t\t\t\t\\\n} while (0)\n\n#define get_unaligned(ptr)\t__get_unaligned_t(typeof(*(ptr)), (ptr))\n#define put_unaligned(val, ptr) __put_unaligned_t(typeof(*(ptr)), (val), (ptr))\n\nstatic inline u16 get_unaligned_le16(const void *p)\n{\n\treturn le16_to_cpu(__get_unaligned_t(__le16, p));\n}\n\nstatic inline u32 get_unaligned_le32(const void *p)\n{\n\treturn le32_to_cpu(__get_unaligned_t(__le32, p));\n}\n\nstatic inline u64 get_unaligned_le64(const void *p)\n{\n\treturn le64_to_cpu(__get_unaligned_t(__le64, p));\n}\n\nstatic inline void put_unaligned_le16(u16 val, void *p)\n{\n\t__put_unaligned_t(__le16, cpu_to_le16(val), p);\n}\n\nstatic inline void put_unaligned_le32(u32 val, void *p)\n{\n\t__put_unaligned_t(__le32, cpu_to_le32(val), p);\n}\n\nstatic inline void put_unaligned_le64(u64 val, void *p)\n{\n\t__put_unaligned_t(__le64, cpu_to_le64(val), p);\n}\n\nstatic inline u16 get_unaligned_be16(const void *p)\n{\n\treturn be16_to_cpu(__get_unaligned_t(__be16, p));\n}\n\nstatic inline u32 get_unaligned_be32(const void *p)\n{\n\treturn be32_to_cpu(__get_unaligned_t(__be32, p));\n}\n\nstatic inline u64 get_unaligned_be64(const void *p)\n{\n\treturn be64_to_cpu(__get_unaligned_t(__be64, p));\n}\n\nstatic inline void put_unaligned_be16(u16 val, void *p)\n{\n\t__put_unaligned_t(__be16, cpu_to_be16(val), p);\n}\n\nstatic inline void put_unaligned_be32(u32 val, void *p)\n{\n\t__put_unaligned_t(__be32, cpu_to_be32(val), p);\n}\n\nstatic inline void put_unaligned_be64(u64 val, void *p)\n{\n\t__put_unaligned_t(__be64, cpu_to_be64(val), p);\n}\n\nstatic inline u32 __get_unaligned_be24(const u8 *p)\n{\n\treturn p[0] << 16 | p[1] << 8 | p[2];\n}\n\nstatic inline u32 get_unaligned_be24(const void *p)\n{\n\treturn __get_unaligned_be24(p);\n}\n\nstatic inline u32 __get_unaligned_le24(const u8 *p)\n{\n\treturn p[0] | p[1] << 8 | p[2] << 16;\n}\n\nstatic inline u32 get_unaligned_le24(const void *p)\n{\n\treturn __get_unaligned_le24(p);\n}\n\nstatic inline void __put_unaligned_be24(const u32 val, u8 *p)\n{\n\t*p++ = val >> 16;\n\t*p++ = val >> 8;\n\t*p++ = val;\n}\n\nstatic inline void put_unaligned_be24(const u32 val, void *p)\n{\n\t__put_unaligned_be24(val, p);\n}\n\nstatic inline void __put_unaligned_le24(const u32 val, u8 *p)\n{\n\t*p++ = val;\n\t*p++ = val >> 8;\n\t*p++ = val >> 16;\n}\n\nstatic inline void put_unaligned_le24(const u32 val, void *p)\n{\n\t__put_unaligned_le24(val, p);\n}\n\nstatic inline void __put_unaligned_be48(const u64 val, u8 *p)\n{\n\t*p++ = val >> 40;\n\t*p++ = val >> 32;\n\t*p++ = val >> 24;\n\t*p++ = val >> 16;\n\t*p++ = val >> 8;\n\t*p++ = val;\n}\n\nstatic inline void put_unaligned_be48(const u64 val, void *p)\n{\n\t__put_unaligned_be48(val, p);\n}\n\nstatic inline u64 __get_unaligned_be48(const u8 *p)\n{\n\treturn (u64)p[0] << 40 | (u64)p[1] << 32 | (u64)p[2] << 24 |\n\t\tp[3] << 16 | p[4] << 8 | p[5];\n}\n\nstatic inline u64 get_unaligned_be48(const void *p)\n{\n\treturn __get_unaligned_be48(p);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}