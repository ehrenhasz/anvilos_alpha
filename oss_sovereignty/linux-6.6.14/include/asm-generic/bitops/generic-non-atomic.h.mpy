{
  "module_name": "generic-non-atomic.h",
  "hash_id": "6de05409c7546ccc42fb11d2411e49718292dffdb6ce1e58bcc12bdd91714c03",
  "original_prompt": "Ingested from linux-6.6.14/include/asm-generic/bitops/generic-non-atomic.h",
  "human_readable_source": " \n\n#ifndef __ASM_GENERIC_BITOPS_GENERIC_NON_ATOMIC_H\n#define __ASM_GENERIC_BITOPS_GENERIC_NON_ATOMIC_H\n\n#include <linux/bits.h>\n#include <asm/barrier.h>\n\n#ifndef _LINUX_BITOPS_H\n#error only <linux/bitops.h> can be included directly\n#endif\n\n \n\n \nstatic __always_inline void\ngeneric___set_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\tunsigned long mask = BIT_MASK(nr);\n\tunsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);\n\n\t*p  |= mask;\n}\n\nstatic __always_inline void\ngeneric___clear_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\tunsigned long mask = BIT_MASK(nr);\n\tunsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);\n\n\t*p &= ~mask;\n}\n\n \nstatic __always_inline void\ngeneric___change_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\tunsigned long mask = BIT_MASK(nr);\n\tunsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);\n\n\t*p ^= mask;\n}\n\n \nstatic __always_inline bool\ngeneric___test_and_set_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\tunsigned long mask = BIT_MASK(nr);\n\tunsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);\n\tunsigned long old = *p;\n\n\t*p = old | mask;\n\treturn (old & mask) != 0;\n}\n\n \nstatic __always_inline bool\ngeneric___test_and_clear_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\tunsigned long mask = BIT_MASK(nr);\n\tunsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);\n\tunsigned long old = *p;\n\n\t*p = old & ~mask;\n\treturn (old & mask) != 0;\n}\n\n \nstatic __always_inline bool\ngeneric___test_and_change_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\tunsigned long mask = BIT_MASK(nr);\n\tunsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);\n\tunsigned long old = *p;\n\n\t*p = old ^ mask;\n\treturn (old & mask) != 0;\n}\n\n \nstatic __always_inline bool\ngeneric_test_bit(unsigned long nr, const volatile unsigned long *addr)\n{\n\t \n\treturn 1UL & (addr[BIT_WORD(nr)] >> (nr & (BITS_PER_LONG-1)));\n}\n\n \nstatic __always_inline bool\ngeneric_test_bit_acquire(unsigned long nr, const volatile unsigned long *addr)\n{\n\tunsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);\n\treturn 1UL & (smp_load_acquire(p) >> (nr & (BITS_PER_LONG-1)));\n}\n\n \n#define const___set_bit\t\t\tgeneric___set_bit\n#define const___clear_bit\t\tgeneric___clear_bit\n#define const___change_bit\t\tgeneric___change_bit\n#define const___test_and_set_bit\tgeneric___test_and_set_bit\n#define const___test_and_clear_bit\tgeneric___test_and_clear_bit\n#define const___test_and_change_bit\tgeneric___test_and_change_bit\n#define const_test_bit_acquire\t\tgeneric_test_bit_acquire\n\n \nstatic __always_inline bool\nconst_test_bit(unsigned long nr, const volatile unsigned long *addr)\n{\n\tconst unsigned long *p = (const unsigned long *)addr + BIT_WORD(nr);\n\tunsigned long mask = BIT_MASK(nr);\n\tunsigned long val = *p;\n\n\treturn !!(val & mask);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}