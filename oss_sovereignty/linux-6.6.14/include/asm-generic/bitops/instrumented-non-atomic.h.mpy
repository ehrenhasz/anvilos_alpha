{
  "module_name": "instrumented-non-atomic.h",
  "hash_id": "f5eff989cad3a2e2b0b2832214fc98c737392476d8ddd1e735f37a585412a351",
  "original_prompt": "Ingested from linux-6.6.14/include/asm-generic/bitops/instrumented-non-atomic.h",
  "human_readable_source": " \n\n \n#ifndef _ASM_GENERIC_BITOPS_INSTRUMENTED_NON_ATOMIC_H\n#define _ASM_GENERIC_BITOPS_INSTRUMENTED_NON_ATOMIC_H\n\n#include <linux/instrumented.h>\n\n \nstatic __always_inline void\n___set_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\tinstrument_write(addr + BIT_WORD(nr), sizeof(long));\n\tarch___set_bit(nr, addr);\n}\n\n \nstatic __always_inline void\n___clear_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\tinstrument_write(addr + BIT_WORD(nr), sizeof(long));\n\tarch___clear_bit(nr, addr);\n}\n\n \nstatic __always_inline void\n___change_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\tinstrument_write(addr + BIT_WORD(nr), sizeof(long));\n\tarch___change_bit(nr, addr);\n}\n\nstatic __always_inline void __instrument_read_write_bitop(long nr, volatile unsigned long *addr)\n{\n\tif (IS_ENABLED(CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC)) {\n\t\t \n\t\tkcsan_check_read(addr + BIT_WORD(nr), sizeof(long));\n\t\t \n\t\tinstrument_write(addr + BIT_WORD(nr), sizeof(long));\n\t} else {\n\t\tinstrument_read_write(addr + BIT_WORD(nr), sizeof(long));\n\t}\n}\n\n \nstatic __always_inline bool\n___test_and_set_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\t__instrument_read_write_bitop(nr, addr);\n\treturn arch___test_and_set_bit(nr, addr);\n}\n\n \nstatic __always_inline bool\n___test_and_clear_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\t__instrument_read_write_bitop(nr, addr);\n\treturn arch___test_and_clear_bit(nr, addr);\n}\n\n \nstatic __always_inline bool\n___test_and_change_bit(unsigned long nr, volatile unsigned long *addr)\n{\n\t__instrument_read_write_bitop(nr, addr);\n\treturn arch___test_and_change_bit(nr, addr);\n}\n\n \nstatic __always_inline bool\n_test_bit(unsigned long nr, const volatile unsigned long *addr)\n{\n\tinstrument_atomic_read(addr + BIT_WORD(nr), sizeof(long));\n\treturn arch_test_bit(nr, addr);\n}\n\n \nstatic __always_inline bool\n_test_bit_acquire(unsigned long nr, const volatile unsigned long *addr)\n{\n\tinstrument_atomic_read(addr + BIT_WORD(nr), sizeof(long));\n\treturn arch_test_bit_acquire(nr, addr);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}