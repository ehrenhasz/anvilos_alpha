{
  "module_name": "simple_card_utils.h",
  "hash_id": "d5df4e8d8e90c2c68efae3206ae1a8317999ac734f27c8b927d2a19ff70fd9a1",
  "original_prompt": "Ingested from linux-6.6.14/include/sound/simple_card_utils.h",
  "human_readable_source": " \n\n#ifndef __SIMPLE_CARD_UTILS_H\n#define __SIMPLE_CARD_UTILS_H\n\n#include <linux/clk.h>\n#include <sound/soc.h>\n\n#define asoc_simple_init_hp(card, sjack, prefix) \\\n\tasoc_simple_init_jack(card, sjack, 1, prefix, NULL)\n#define asoc_simple_init_mic(card, sjack, prefix) \\\n\tasoc_simple_init_jack(card, sjack, 0, prefix, NULL)\n\nstruct asoc_simple_tdm_width_map {\n\tu8 sample_bits;\n\tu8 slot_count;\n\tu16 slot_width;\n};\n\nstruct asoc_simple_dai {\n\tconst char *name;\n\tunsigned int sysclk;\n\tint clk_direction;\n\tint slots;\n\tint slot_width;\n\tunsigned int tx_slot_mask;\n\tunsigned int rx_slot_mask;\n\tstruct clk *clk;\n\tbool clk_fixed;\n\tstruct asoc_simple_tdm_width_map *tdm_width_map;\n\tint n_tdm_widths;\n};\n\nstruct asoc_simple_data {\n\tu32 convert_rate;\n\tu32 convert_channels;\n\tconst char *convert_sample_format;\n};\n\nstruct asoc_simple_jack {\n\tstruct snd_soc_jack jack;\n\tstruct snd_soc_jack_pin pin;\n\tstruct snd_soc_jack_gpio gpio;\n};\n\nstruct prop_nums {\n\tint cpus;\n\tint codecs;\n\tint platforms;\n};\n\nstruct asoc_simple_priv {\n\tstruct snd_soc_card snd_card;\n\tstruct simple_dai_props {\n\t\tstruct asoc_simple_dai *cpu_dai;\n\t\tstruct asoc_simple_dai *codec_dai;\n\t\tstruct asoc_simple_data adata;\n\t\tstruct snd_soc_codec_conf *codec_conf;\n\t\tstruct prop_nums num;\n\t\tunsigned int mclk_fs;\n\t} *dai_props;\n\tstruct asoc_simple_jack hp_jack;\n\tstruct asoc_simple_jack mic_jack;\n\tstruct snd_soc_jack *aux_jacks;\n\tstruct snd_soc_dai_link *dai_link;\n\tstruct asoc_simple_dai *dais;\n\tstruct snd_soc_dai_link_component *dlcs;\n\tstruct snd_soc_codec_conf *codec_conf;\n\tstruct gpio_desc *pa_gpio;\n\tconst struct snd_soc_ops *ops;\n\tunsigned int dpcm_selectable:1;\n\tunsigned int force_dpcm:1;\n};\n#define simple_priv_to_card(priv)\t(&(priv)->snd_card)\n#define simple_priv_to_props(priv, i)\t((priv)->dai_props + (i))\n#define simple_priv_to_dev(priv)\t(simple_priv_to_card(priv)->dev)\n#define simple_priv_to_link(priv, i)\t(simple_priv_to_card(priv)->dai_link + (i))\n\n#define simple_props_to_dlc_cpu(props, i)\t((props)->cpus + i)\n#define simple_props_to_dlc_codec(props, i)\t((props)->codecs + i)\n#define simple_props_to_dlc_platform(props, i)\t((props)->platforms + i)\n\n#define simple_props_to_dai_cpu(props, i)\t((props)->cpu_dai + i)\n#define simple_props_to_dai_codec(props, i)\t((props)->codec_dai + i)\n#define simple_props_to_codec_conf(props, i)\t((props)->codec_conf + i)\n\n#define for_each_prop_dlc_cpus(props, i, cpu)\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < (props)->num.cpus) &&\t\t\t\t\\\n\t\t     ((cpu) = simple_props_to_dlc_cpu(props, i));\t\\\n\t     (i)++)\n#define for_each_prop_dlc_codecs(props, i, codec)\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < (props)->num.codecs) &&\t\t\t\t\\\n\t\t     ((codec) = simple_props_to_dlc_codec(props, i));\t\\\n\t     (i)++)\n#define for_each_prop_dlc_platforms(props, i, platform)\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < (props)->num.platforms) &&\t\t\t\t\\\n\t\t     ((platform) = simple_props_to_dlc_platform(props, i)); \\\n\t     (i)++)\n#define for_each_prop_codec_conf(props, i, conf)\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < (props)->num.codecs) &&\t\t\t\t\\\n\t\t     (props)->codec_conf &&\t\t\t\t\\\n\t\t     ((conf) = simple_props_to_codec_conf(props, i));\t\\\n\t     (i)++)\n\n#define for_each_prop_dai_cpu(props, i, cpu)\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < (props)->num.cpus) &&\t\t\t\t\\\n\t\t     ((cpu) = simple_props_to_dai_cpu(props, i));\t\\\n\t     (i)++)\n#define for_each_prop_dai_codec(props, i, codec)\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < (props)->num.codecs) &&\t\t\t\t\\\n\t\t     ((codec) = simple_props_to_dai_codec(props, i));\t\\\n\t     (i)++)\n\n#define SNDRV_MAX_LINKS 512\n\nstruct link_info {\n\tint link;  \n\tint cpu;   \n\tstruct prop_nums num[SNDRV_MAX_LINKS];\n};\n\nint asoc_simple_parse_daifmt(struct device *dev,\n\t\t\t     struct device_node *node,\n\t\t\t     struct device_node *codec,\n\t\t\t     char *prefix,\n\t\t\t     unsigned int *retfmt);\nint asoc_simple_parse_tdm_width_map(struct device *dev, struct device_node *np,\n\t\t\t\t    struct asoc_simple_dai *dai);\n\n__printf(3, 4)\nint asoc_simple_set_dailink_name(struct device *dev,\n\t\t\t\t struct snd_soc_dai_link *dai_link,\n\t\t\t\t const char *fmt, ...);\nint asoc_simple_parse_card_name(struct snd_soc_card *card,\n\t\t\t\tchar *prefix);\n\nint asoc_simple_parse_clk(struct device *dev,\n\t\t\t  struct device_node *node,\n\t\t\t  struct asoc_simple_dai *simple_dai,\n\t\t\t  struct snd_soc_dai_link_component *dlc);\nint asoc_simple_startup(struct snd_pcm_substream *substream);\nvoid asoc_simple_shutdown(struct snd_pcm_substream *substream);\nint asoc_simple_hw_params(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_pcm_hw_params *params);\nint asoc_simple_dai_init(struct snd_soc_pcm_runtime *rtd);\nint asoc_simple_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t   struct snd_pcm_hw_params *params);\n\n#define asoc_simple_parse_tdm(np, dai)\t\t\t\\\n\tsnd_soc_of_parse_tdm_slot(np,\t&(dai)->tx_slot_mask,\t\\\n\t\t\t\t\t&(dai)->rx_slot_mask,\t\\\n\t\t\t\t\t&(dai)->slots,\t\t\\\n\t\t\t\t\t&(dai)->slot_width);\n\nvoid asoc_simple_canonicalize_platform(struct snd_soc_dai_link_component *platforms,\n\t\t\t\t       struct snd_soc_dai_link_component *cpus);\nvoid asoc_simple_canonicalize_cpu(struct snd_soc_dai_link_component *cpus,\n\t\t\t\t  int is_single_links);\n\nvoid asoc_simple_clean_reference(struct snd_soc_card *card);\n\nvoid asoc_simple_parse_convert(struct device_node *np, char *prefix,\n\t\t\t       struct asoc_simple_data *data);\nbool asoc_simple_is_convert_required(const struct asoc_simple_data *data);\n\nint asoc_simple_parse_routing(struct snd_soc_card *card,\n\t\t\t\t      char *prefix);\nint asoc_simple_parse_widgets(struct snd_soc_card *card,\n\t\t\t\t      char *prefix);\nint asoc_simple_parse_pin_switches(struct snd_soc_card *card,\n\t\t\t\t   char *prefix);\n\nint asoc_simple_init_jack(struct snd_soc_card *card,\n\t\t\t       struct asoc_simple_jack *sjack,\n\t\t\t       int is_hp, char *prefix, char *pin);\nint asoc_simple_init_aux_jacks(struct asoc_simple_priv *priv,\n\t\t\t\tchar *prefix);\nint asoc_simple_init_priv(struct asoc_simple_priv *priv,\n\t\t\t       struct link_info *li);\nint asoc_simple_remove(struct platform_device *pdev);\n\nint asoc_graph_card_probe(struct snd_soc_card *card);\nint asoc_graph_is_ports0(struct device_node *port);\nint asoc_graph_parse_dai(struct device *dev, struct device_node *ep,\n\t\t\t struct snd_soc_dai_link_component *dlc, int *is_single_link);\n\n#ifdef DEBUG\nstatic inline void asoc_simple_debug_dai(struct asoc_simple_priv *priv,\n\t\t\t\t\t char *name,\n\t\t\t\t\t struct asoc_simple_dai *dai)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\n\t \n\tif (!dai)\n\t\treturn;\n\n\tif (dai->name)\n\t\tdev_dbg(dev, \"%s dai name = %s\\n\",\n\t\t\tname, dai->name);\n\n\tif (dai->slots)\n\t\tdev_dbg(dev, \"%s slots = %d\\n\", name, dai->slots);\n\tif (dai->slot_width)\n\t\tdev_dbg(dev, \"%s slot width = %d\\n\", name, dai->slot_width);\n\tif (dai->tx_slot_mask)\n\t\tdev_dbg(dev, \"%s tx slot mask = %d\\n\", name, dai->tx_slot_mask);\n\tif (dai->rx_slot_mask)\n\t\tdev_dbg(dev, \"%s rx slot mask = %d\\n\", name, dai->rx_slot_mask);\n\tif (dai->clk)\n\t\tdev_dbg(dev, \"%s clk %luHz\\n\", name, clk_get_rate(dai->clk));\n\tif (dai->sysclk)\n\t\tdev_dbg(dev, \"%s sysclk = %dHz\\n\",\n\t\t\tname, dai->sysclk);\n\tif (dai->clk || dai->sysclk)\n\t\tdev_dbg(dev, \"%s direction = %s\\n\",\n\t\t\tname, dai->clk_direction ? \"OUT\" : \"IN\");\n}\n\nstatic inline void asoc_simple_debug_info(struct asoc_simple_priv *priv)\n{\n\tstruct snd_soc_card *card = simple_priv_to_card(priv);\n\tstruct device *dev = simple_priv_to_dev(priv);\n\n\tint i;\n\n\tif (card->name)\n\t\tdev_dbg(dev, \"Card Name: %s\\n\", card->name);\n\n\tfor (i = 0; i < card->num_links; i++) {\n\t\tstruct simple_dai_props *props = simple_priv_to_props(priv, i);\n\t\tstruct snd_soc_dai_link *link = simple_priv_to_link(priv, i);\n\t\tstruct asoc_simple_dai *dai;\n\t\tstruct snd_soc_codec_conf *cnf;\n\t\tint j;\n\n\t\tdev_dbg(dev, \"DAI%d\\n\", i);\n\n\t\tdev_dbg(dev, \"cpu num = %d\\n\", link->num_cpus);\n\t\tfor_each_prop_dai_cpu(props, j, dai)\n\t\t\tasoc_simple_debug_dai(priv, \"cpu\", dai);\n\t\tdev_dbg(dev, \"codec num = %d\\n\", link->num_codecs);\n\t\tfor_each_prop_dai_codec(props, j, dai)\n\t\t\tasoc_simple_debug_dai(priv, \"codec\", dai);\n\n\t\tif (link->name)\n\t\t\tdev_dbg(dev, \"dai name = %s\\n\", link->name);\n\t\tif (link->dai_fmt)\n\t\t\tdev_dbg(dev, \"dai format = %04x\\n\", link->dai_fmt);\n\t\tif (props->adata.convert_rate)\n\t\t\tdev_dbg(dev, \"convert_rate = %d\\n\", props->adata.convert_rate);\n\t\tif (props->adata.convert_channels)\n\t\t\tdev_dbg(dev, \"convert_channels = %d\\n\", props->adata.convert_channels);\n\t\tfor_each_prop_codec_conf(props, j, cnf)\n\t\t\tif (cnf->name_prefix)\n\t\t\t\tdev_dbg(dev, \"name prefix = %s\\n\", cnf->name_prefix);\n\t\tif (props->mclk_fs)\n\t\t\tdev_dbg(dev, \"mclk-fs = %d\\n\", props->mclk_fs);\n\t}\n}\n#else\n#define  asoc_simple_debug_info(priv)\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}