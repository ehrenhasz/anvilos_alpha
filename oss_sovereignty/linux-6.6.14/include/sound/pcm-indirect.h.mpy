{
  "module_name": "pcm-indirect.h",
  "hash_id": "ea851771ea6930a11dcce139a2b30ba12cf06a140c07e4d34e045253b2251355",
  "original_prompt": "Ingested from linux-6.6.14/include/sound/pcm-indirect.h",
  "human_readable_source": " \n \n\n#ifndef __SOUND_PCM_INDIRECT_H\n#define __SOUND_PCM_INDIRECT_H\n\n#include <sound/pcm.h>\n\nstruct snd_pcm_indirect {\n\tunsigned int hw_buffer_size;\t \n\tunsigned int hw_queue_size;\t \n\tunsigned int hw_data;\t \n\tunsigned int hw_io;\t \n\tint hw_ready;\t\t \n\tunsigned int sw_buffer_size;\t \n\tunsigned int sw_data;\t \n\tunsigned int sw_io;\t \n\tint sw_ready;\t\t \n\tsnd_pcm_uframes_t appl_ptr;\t \n};\n\ntypedef void (*snd_pcm_indirect_copy_t)(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_indirect *rec, size_t bytes);\n\n \nstatic inline int\nsnd_pcm_indirect_playback_transfer(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_indirect *rec,\n\t\t\t\t   snd_pcm_indirect_copy_t copy)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t appl_ptr = runtime->control->appl_ptr;\n\tsnd_pcm_sframes_t diff = appl_ptr - rec->appl_ptr;\n\tint qsize;\n\n\tif (diff) {\n\t\tif (diff < -(snd_pcm_sframes_t) (runtime->boundary / 2))\n\t\t\tdiff += runtime->boundary;\n\t\tif (diff < 0)\n\t\t\treturn -EPIPE;\n\t\trec->sw_ready += (int)frames_to_bytes(runtime, diff);\n\t\trec->appl_ptr = appl_ptr;\n\t}\n\tqsize = rec->hw_queue_size ? rec->hw_queue_size : rec->hw_buffer_size;\n\twhile (rec->hw_ready < qsize && rec->sw_ready > 0) {\n\t\tunsigned int hw_to_end = rec->hw_buffer_size - rec->hw_data;\n\t\tunsigned int sw_to_end = rec->sw_buffer_size - rec->sw_data;\n\t\tunsigned int bytes = qsize - rec->hw_ready;\n\t\tif (rec->sw_ready < (int)bytes)\n\t\t\tbytes = rec->sw_ready;\n\t\tif (hw_to_end < bytes)\n\t\t\tbytes = hw_to_end;\n\t\tif (sw_to_end < bytes)\n\t\t\tbytes = sw_to_end;\n\t\tif (! bytes)\n\t\t\tbreak;\n\t\tcopy(substream, rec, bytes);\n\t\trec->hw_data += bytes;\n\t\tif (rec->hw_data == rec->hw_buffer_size)\n\t\t\trec->hw_data = 0;\n\t\trec->sw_data += bytes;\n\t\tif (rec->sw_data == rec->sw_buffer_size)\n\t\t\trec->sw_data = 0;\n\t\trec->hw_ready += bytes;\n\t\trec->sw_ready -= bytes;\n\t}\n\treturn 0;\n}\n\n \nstatic inline snd_pcm_uframes_t\nsnd_pcm_indirect_playback_pointer(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_indirect *rec, unsigned int ptr)\n{\n\tint bytes = ptr - rec->hw_io;\n\tint err;\n\n\tif (bytes < 0)\n\t\tbytes += rec->hw_buffer_size;\n\trec->hw_io = ptr;\n\trec->hw_ready -= bytes;\n\trec->sw_io += bytes;\n\tif (rec->sw_io >= rec->sw_buffer_size)\n\t\trec->sw_io -= rec->sw_buffer_size;\n\tif (substream->ops->ack) {\n\t\terr = substream->ops->ack(substream);\n\t\tif (err == -EPIPE)\n\t\t\treturn SNDRV_PCM_POS_XRUN;\n\t}\n\treturn bytes_to_frames(substream->runtime, rec->sw_io);\n}\n\n\n \nstatic inline int\nsnd_pcm_indirect_capture_transfer(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_indirect *rec,\n\t\t\t\t  snd_pcm_indirect_copy_t copy)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t appl_ptr = runtime->control->appl_ptr;\n\tsnd_pcm_sframes_t diff = appl_ptr - rec->appl_ptr;\n\n\tif (diff) {\n\t\tif (diff < -(snd_pcm_sframes_t) (runtime->boundary / 2))\n\t\t\tdiff += runtime->boundary;\n\t\tif (diff < 0)\n\t\t\treturn -EPIPE;\n\t\trec->sw_ready -= frames_to_bytes(runtime, diff);\n\t\trec->appl_ptr = appl_ptr;\n\t}\n\twhile (rec->hw_ready > 0 && \n\t       rec->sw_ready < (int)rec->sw_buffer_size) {\n\t\tsize_t hw_to_end = rec->hw_buffer_size - rec->hw_data;\n\t\tsize_t sw_to_end = rec->sw_buffer_size - rec->sw_data;\n\t\tsize_t bytes = rec->sw_buffer_size - rec->sw_ready;\n\t\tif (rec->hw_ready < (int)bytes)\n\t\t\tbytes = rec->hw_ready;\n\t\tif (hw_to_end < bytes)\n\t\t\tbytes = hw_to_end;\n\t\tif (sw_to_end < bytes)\n\t\t\tbytes = sw_to_end;\n\t\tif (! bytes)\n\t\t\tbreak;\n\t\tcopy(substream, rec, bytes);\n\t\trec->hw_data += bytes;\n\t\tif ((int)rec->hw_data == rec->hw_buffer_size)\n\t\t\trec->hw_data = 0;\n\t\trec->sw_data += bytes;\n\t\tif (rec->sw_data == rec->sw_buffer_size)\n\t\t\trec->sw_data = 0;\n\t\trec->hw_ready -= bytes;\n\t\trec->sw_ready += bytes;\n\t}\n\treturn 0;\n}\n\n \nstatic inline snd_pcm_uframes_t\nsnd_pcm_indirect_capture_pointer(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_indirect *rec, unsigned int ptr)\n{\n\tint qsize;\n\tint bytes = ptr - rec->hw_io;\n\tint err;\n\n\tif (bytes < 0)\n\t\tbytes += rec->hw_buffer_size;\n\trec->hw_io = ptr;\n\trec->hw_ready += bytes;\n\tqsize = rec->hw_queue_size ? rec->hw_queue_size : rec->hw_buffer_size;\n\tif (rec->hw_ready > qsize)\n\t\treturn SNDRV_PCM_POS_XRUN;\n\trec->sw_io += bytes;\n\tif (rec->sw_io >= rec->sw_buffer_size)\n\t\trec->sw_io -= rec->sw_buffer_size;\n\tif (substream->ops->ack) {\n\t\terr = substream->ops->ack(substream);\n\t\tif (err == -EPIPE)\n\t\t\treturn SNDRV_PCM_POS_XRUN;\n\t}\n\treturn bytes_to_frames(substream->runtime, rec->sw_io);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}