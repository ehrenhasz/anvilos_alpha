{
  "module_name": "control.h",
  "hash_id": "eb55df279021a25d312c1709bbd7b348199db7f065eab1e9ef87a1219cba1103",
  "original_prompt": "Ingested from linux-6.6.14/include/sound/control.h",
  "human_readable_source": " \n#ifndef __SOUND_CONTROL_H\n#define __SOUND_CONTROL_H\n\n \n\n#include <linux/wait.h>\n#include <linux/nospec.h>\n#include <sound/asound.h>\n\n#define snd_kcontrol_chip(kcontrol) ((kcontrol)->private_data)\n\nstruct snd_kcontrol;\ntypedef int (snd_kcontrol_info_t) (struct snd_kcontrol * kcontrol, struct snd_ctl_elem_info * uinfo);\ntypedef int (snd_kcontrol_get_t) (struct snd_kcontrol * kcontrol, struct snd_ctl_elem_value * ucontrol);\ntypedef int (snd_kcontrol_put_t) (struct snd_kcontrol * kcontrol, struct snd_ctl_elem_value * ucontrol);\ntypedef int (snd_kcontrol_tlv_rw_t)(struct snd_kcontrol *kcontrol,\n\t\t\t\t    int op_flag,  \n\t\t\t\t    unsigned int size,\n\t\t\t\t    unsigned int __user *tlv);\n\n \n#ifdef CONFIG_SND_CTL_DEBUG\n#define SNDRV_CTL_ELEM_ACCESS_SKIP_CHECK\t(1 << 24)\n#define snd_ctl_skip_validation(info) \\\n\t((info)->access & SNDRV_CTL_ELEM_ACCESS_SKIP_CHECK)\n#else\n#define SNDRV_CTL_ELEM_ACCESS_SKIP_CHECK\t0\n#define snd_ctl_skip_validation(info)\t\ttrue\n#endif\n\n \n#define SNDRV_CTL_ELEM_ACCESS_LED_SHIFT\t\t25\n#define SNDRV_CTL_ELEM_ACCESS_LED_MASK\t\t(7<<25)  \n#define SNDRV_CTL_ELEM_ACCESS_SPK_LED\t\t(1<<25)  \n#define SNDRV_CTL_ELEM_ACCESS_MIC_LED\t\t(2<<25)  \n\nenum {\n\tSNDRV_CTL_TLV_OP_READ = 0,\n\tSNDRV_CTL_TLV_OP_WRITE = 1,\n\tSNDRV_CTL_TLV_OP_CMD = -1,\n};\n\nstruct snd_kcontrol_new {\n\tsnd_ctl_elem_iface_t iface;\t \n\tunsigned int device;\t\t \n\tunsigned int subdevice;\t\t \n\tconst char *name;\t\t \n\tunsigned int index;\t\t \n\tunsigned int access;\t\t \n\tunsigned int count;\t\t \n\tsnd_kcontrol_info_t *info;\n\tsnd_kcontrol_get_t *get;\n\tsnd_kcontrol_put_t *put;\n\tunion {\n\t\tsnd_kcontrol_tlv_rw_t *c;\n\t\tconst unsigned int *p;\n\t} tlv;\n\tunsigned long private_value;\n};\n\nstruct snd_kcontrol_volatile {\n\tstruct snd_ctl_file *owner;\t \n\tunsigned int access;\t \n};\n\nstruct snd_kcontrol {\n\tstruct list_head list;\t\t \n\tstruct snd_ctl_elem_id id;\n\tunsigned int count;\t\t \n\tsnd_kcontrol_info_t *info;\n\tsnd_kcontrol_get_t *get;\n\tsnd_kcontrol_put_t *put;\n\tunion {\n\t\tsnd_kcontrol_tlv_rw_t *c;\n\t\tconst unsigned int *p;\n\t} tlv;\n\tunsigned long private_value;\n\tvoid *private_data;\n\tvoid (*private_free)(struct snd_kcontrol *kcontrol);\n\tstruct snd_kcontrol_volatile vd[];\t \n};\n\n#define snd_kcontrol(n) list_entry(n, struct snd_kcontrol, list)\n\nstruct snd_kctl_event {\n\tstruct list_head list;\t \n\tstruct snd_ctl_elem_id id;\n\tunsigned int mask;\n};\n\n#define snd_kctl_event(n) list_entry(n, struct snd_kctl_event, list)\n\nstruct pid;\n\nenum {\n\tSND_CTL_SUBDEV_PCM,\n\tSND_CTL_SUBDEV_RAWMIDI,\n\tSND_CTL_SUBDEV_ITEMS,\n};\n\nstruct snd_ctl_file {\n\tstruct list_head list;\t\t \n\tstruct snd_card *card;\n\tstruct pid *pid;\n\tint preferred_subdevice[SND_CTL_SUBDEV_ITEMS];\n\twait_queue_head_t change_sleep;\n\tspinlock_t read_lock;\n\tstruct snd_fasync *fasync;\n\tint subscribed;\t\t\t \n\tstruct list_head events;\t \n};\n\nstruct snd_ctl_layer_ops {\n\tstruct snd_ctl_layer_ops *next;\n\tconst char *module_name;\n\tvoid (*lregister)(struct snd_card *card);\n\tvoid (*ldisconnect)(struct snd_card *card);\n\tvoid (*lnotify)(struct snd_card *card, unsigned int mask, struct snd_kcontrol *kctl, unsigned int ioff);\n};\n\n#define snd_ctl_file(n) list_entry(n, struct snd_ctl_file, list)\n\ntypedef int (*snd_kctl_ioctl_func_t) (struct snd_card * card,\n\t\t\t\t      struct snd_ctl_file * control,\n\t\t\t\t      unsigned int cmd, unsigned long arg);\n\nvoid snd_ctl_notify(struct snd_card * card, unsigned int mask, struct snd_ctl_elem_id * id);\nvoid snd_ctl_notify_one(struct snd_card * card, unsigned int mask, struct snd_kcontrol * kctl, unsigned int ioff);\n\nstruct snd_kcontrol *snd_ctl_new1(const struct snd_kcontrol_new * kcontrolnew, void * private_data);\nvoid snd_ctl_free_one(struct snd_kcontrol * kcontrol);\nint snd_ctl_add(struct snd_card * card, struct snd_kcontrol * kcontrol);\nint snd_ctl_remove(struct snd_card * card, struct snd_kcontrol * kcontrol);\nint snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol, bool add_on_replace);\nint snd_ctl_remove_id(struct snd_card * card, struct snd_ctl_elem_id *id);\nint snd_ctl_rename_id(struct snd_card * card, struct snd_ctl_elem_id *src_id, struct snd_ctl_elem_id *dst_id);\nvoid snd_ctl_rename(struct snd_card *card, struct snd_kcontrol *kctl, const char *name);\nint snd_ctl_activate_id(struct snd_card *card, struct snd_ctl_elem_id *id, int active);\nstruct snd_kcontrol *snd_ctl_find_numid_locked(struct snd_card *card, unsigned int numid);\nstruct snd_kcontrol *snd_ctl_find_numid(struct snd_card *card, unsigned int numid);\nstruct snd_kcontrol *snd_ctl_find_id_locked(struct snd_card *card, const struct snd_ctl_elem_id *id);\nstruct snd_kcontrol *snd_ctl_find_id(struct snd_card *card, const struct snd_ctl_elem_id *id);\n\n \nstatic inline struct snd_kcontrol *\nsnd_ctl_find_id_mixer(struct snd_card *card, const char *name)\n{\n\tstruct snd_ctl_elem_id id = {};\n\n\tid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tstrscpy(id.name, name, sizeof(id.name));\n\treturn snd_ctl_find_id(card, &id);\n}\n\nint snd_ctl_create(struct snd_card *card);\n\nint snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn);\nint snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn);\n#ifdef CONFIG_COMPAT\nint snd_ctl_register_ioctl_compat(snd_kctl_ioctl_func_t fcn);\nint snd_ctl_unregister_ioctl_compat(snd_kctl_ioctl_func_t fcn);\n#else\n#define snd_ctl_register_ioctl_compat(fcn)\n#define snd_ctl_unregister_ioctl_compat(fcn)\n#endif\n\nint snd_ctl_request_layer(const char *module_name);\nvoid snd_ctl_register_layer(struct snd_ctl_layer_ops *lops);\nvoid snd_ctl_disconnect_layer(struct snd_ctl_layer_ops *lops);\n\nint snd_ctl_get_preferred_subdevice(struct snd_card *card, int type);\n\nstatic inline unsigned int snd_ctl_get_ioffnum(struct snd_kcontrol *kctl, struct snd_ctl_elem_id *id)\n{\n\tunsigned int ioff = id->numid - kctl->id.numid;\n\treturn array_index_nospec(ioff, kctl->count);\n}\n\nstatic inline unsigned int snd_ctl_get_ioffidx(struct snd_kcontrol *kctl, struct snd_ctl_elem_id *id)\n{\n\tunsigned int ioff = id->index - kctl->id.index;\n\treturn array_index_nospec(ioff, kctl->count);\n}\n\nstatic inline unsigned int snd_ctl_get_ioff(struct snd_kcontrol *kctl, struct snd_ctl_elem_id *id)\n{\n\tif (id->numid) {\n\t\treturn snd_ctl_get_ioffnum(kctl, id);\n\t} else {\n\t\treturn snd_ctl_get_ioffidx(kctl, id);\n\t}\n}\n\nstatic inline struct snd_ctl_elem_id *snd_ctl_build_ioff(struct snd_ctl_elem_id *dst_id,\n\t\t\t\t\t\t    struct snd_kcontrol *src_kctl,\n\t\t\t\t\t\t    unsigned int offset)\n{\n\t*dst_id = src_kctl->id;\n\tdst_id->index += offset;\n\tdst_id->numid += offset;\n\treturn dst_id;\n}\n\n \nint snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo);\nint snd_ctl_boolean_stereo_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo);\nint snd_ctl_enum_info(struct snd_ctl_elem_info *info, unsigned int channels,\n\t\t      unsigned int items, const char *const names[]);\n\n \nstruct snd_kcontrol *snd_ctl_make_virtual_master(char *name,\n\t\t\t\t\t\t const unsigned int *tlv);\nint _snd_ctl_add_follower(struct snd_kcontrol *master,\n\t\t\t  struct snd_kcontrol *follower,\n\t\t\t  unsigned int flags);\n \n#define SND_CTL_FOLLOWER_NEED_UPDATE\t(1 << 0)\n\n \nstatic inline int\nsnd_ctl_add_follower(struct snd_kcontrol *master, struct snd_kcontrol *follower)\n{\n\treturn _snd_ctl_add_follower(master, follower, 0);\n}\n\nint snd_ctl_add_followers(struct snd_card *card, struct snd_kcontrol *master,\n\t\t\t  const char * const *list);\n\n \nstatic inline int\nsnd_ctl_add_follower_uncached(struct snd_kcontrol *master,\n\t\t\t      struct snd_kcontrol *follower)\n{\n\treturn _snd_ctl_add_follower(master, follower, SND_CTL_FOLLOWER_NEED_UPDATE);\n}\n\nint snd_ctl_add_vmaster_hook(struct snd_kcontrol *kctl,\n\t\t\t     void (*hook)(void *private_data, int),\n\t\t\t     void *private_data);\nvoid snd_ctl_sync_vmaster(struct snd_kcontrol *kctl, bool hook_only);\n#define snd_ctl_sync_vmaster_hook(kctl)\tsnd_ctl_sync_vmaster(kctl, true)\nint snd_ctl_apply_vmaster_followers(struct snd_kcontrol *kctl,\n\t\t\t\t    int (*func)(struct snd_kcontrol *vfollower,\n\t\t\t\t\t\tstruct snd_kcontrol *follower,\n\t\t\t\t\t\tvoid *arg),\n\t\t\t\t    void *arg);\n\n \n#define SND_CTL_LAYER_MODULE_LED\t\"snd-ctl-led\"\n\n#if IS_MODULE(CONFIG_SND_CTL_LED)\nstatic inline int snd_ctl_led_request(void) { return snd_ctl_request_layer(SND_CTL_LAYER_MODULE_LED); }\n#else\nstatic inline int snd_ctl_led_request(void) { return 0; }\n#endif\n\n \nstruct snd_kcontrol *\nsnd_kctl_jack_new(const char *name, struct snd_card *card);\nvoid snd_kctl_jack_report(struct snd_card *card,\n\t\t\t  struct snd_kcontrol *kctl, bool status);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}