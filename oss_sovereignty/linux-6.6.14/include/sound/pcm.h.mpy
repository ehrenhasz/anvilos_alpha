{
  "module_name": "pcm.h",
  "hash_id": "bbc835f6b46abf8446a77502f8aef8439325dd43f9547957178ae98cccb5d4ae",
  "original_prompt": "Ingested from linux-6.6.14/include/sound/pcm.h",
  "human_readable_source": " \n#ifndef __SOUND_PCM_H\n#define __SOUND_PCM_H\n\n \n\n#include <sound/asound.h>\n#include <sound/memalloc.h>\n#include <sound/minors.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/bitops.h>\n#include <linux/pm_qos.h>\n#include <linux/refcount.h>\n#include <linux/uio.h>\n\n#define snd_pcm_substream_chip(substream) ((substream)->private_data)\n#define snd_pcm_chip(pcm) ((pcm)->private_data)\n\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n#include <sound/pcm_oss.h>\n#endif\n\n \n\nstruct snd_pcm_hardware {\n\tunsigned int info;\t\t \n\tu64 formats;\t\t\t \n\tunsigned int rates;\t\t \n\tunsigned int rate_min;\t\t \n\tunsigned int rate_max;\t\t \n\tunsigned int channels_min;\t \n\tunsigned int channels_max;\t \n\tsize_t buffer_bytes_max;\t \n\tsize_t period_bytes_min;\t \n\tsize_t period_bytes_max;\t \n\tunsigned int periods_min;\t \n\tunsigned int periods_max;\t \n\tsize_t fifo_size;\t\t \n};\n\nstruct snd_pcm_status64;\nstruct snd_pcm_substream;\n\nstruct snd_pcm_audio_tstamp_config;  \nstruct snd_pcm_audio_tstamp_report;\n\nstruct snd_pcm_ops {\n\tint (*open)(struct snd_pcm_substream *substream);\n\tint (*close)(struct snd_pcm_substream *substream);\n\tint (*ioctl)(struct snd_pcm_substream * substream,\n\t\t     unsigned int cmd, void *arg);\n\tint (*hw_params)(struct snd_pcm_substream *substream,\n\t\t\t struct snd_pcm_hw_params *params);\n\tint (*hw_free)(struct snd_pcm_substream *substream);\n\tint (*prepare)(struct snd_pcm_substream *substream);\n\tint (*trigger)(struct snd_pcm_substream *substream, int cmd);\n\tint (*sync_stop)(struct snd_pcm_substream *substream);\n\tsnd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);\n\tint (*get_time_info)(struct snd_pcm_substream *substream,\n\t\t\tstruct timespec64 *system_ts, struct timespec64 *audio_ts,\n\t\t\tstruct snd_pcm_audio_tstamp_config *audio_tstamp_config,\n\t\t\tstruct snd_pcm_audio_tstamp_report *audio_tstamp_report);\n\tint (*fill_silence)(struct snd_pcm_substream *substream, int channel,\n\t\t\t    unsigned long pos, unsigned long bytes);\n\tint (*copy)(struct snd_pcm_substream *substream, int channel,\n\t\t    unsigned long pos, struct iov_iter *iter, unsigned long bytes);\n\tstruct page *(*page)(struct snd_pcm_substream *substream,\n\t\t\t     unsigned long offset);\n\tint (*mmap)(struct snd_pcm_substream *substream, struct vm_area_struct *vma);\n\tint (*ack)(struct snd_pcm_substream *substream);\n};\n\n \n\n#if defined(CONFIG_SND_DYNAMIC_MINORS)\n#define SNDRV_PCM_DEVICES\t(SNDRV_OS_MINORS-2)\n#else\n#define SNDRV_PCM_DEVICES\t8\n#endif\n\n#define SNDRV_PCM_IOCTL1_RESET\t\t0\n \n#define SNDRV_PCM_IOCTL1_CHANNEL_INFO\t2\n \n#define SNDRV_PCM_IOCTL1_FIFO_SIZE\t4\n\n#define SNDRV_PCM_TRIGGER_STOP\t\t0\n#define SNDRV_PCM_TRIGGER_START\t\t1\n#define SNDRV_PCM_TRIGGER_PAUSE_PUSH\t3\n#define SNDRV_PCM_TRIGGER_PAUSE_RELEASE\t4\n#define SNDRV_PCM_TRIGGER_SUSPEND\t5\n#define SNDRV_PCM_TRIGGER_RESUME\t6\n#define SNDRV_PCM_TRIGGER_DRAIN\t\t7\n\n#define SNDRV_PCM_POS_XRUN\t\t((snd_pcm_uframes_t)-1)\n\n \n#define SNDRV_PCM_RATE_5512\t\t(1U<<0)\t\t \n#define SNDRV_PCM_RATE_8000\t\t(1U<<1)\t\t \n#define SNDRV_PCM_RATE_11025\t\t(1U<<2)\t\t \n#define SNDRV_PCM_RATE_16000\t\t(1U<<3)\t\t \n#define SNDRV_PCM_RATE_22050\t\t(1U<<4)\t\t \n#define SNDRV_PCM_RATE_32000\t\t(1U<<5)\t\t \n#define SNDRV_PCM_RATE_44100\t\t(1U<<6)\t\t \n#define SNDRV_PCM_RATE_48000\t\t(1U<<7)\t\t \n#define SNDRV_PCM_RATE_64000\t\t(1U<<8)\t\t \n#define SNDRV_PCM_RATE_88200\t\t(1U<<9)\t\t \n#define SNDRV_PCM_RATE_96000\t\t(1U<<10)\t \n#define SNDRV_PCM_RATE_176400\t\t(1U<<11)\t \n#define SNDRV_PCM_RATE_192000\t\t(1U<<12)\t \n#define SNDRV_PCM_RATE_352800\t\t(1U<<13)\t \n#define SNDRV_PCM_RATE_384000\t\t(1U<<14)\t \n\n#define SNDRV_PCM_RATE_CONTINUOUS\t(1U<<30)\t \n#define SNDRV_PCM_RATE_KNOT\t\t(1U<<31)\t \n\n#define SNDRV_PCM_RATE_8000_44100\t(SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_11025|\\\n\t\t\t\t\t SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_22050|\\\n\t\t\t\t\t SNDRV_PCM_RATE_32000|SNDRV_PCM_RATE_44100)\n#define SNDRV_PCM_RATE_8000_48000\t(SNDRV_PCM_RATE_8000_44100|SNDRV_PCM_RATE_48000)\n#define SNDRV_PCM_RATE_8000_96000\t(SNDRV_PCM_RATE_8000_48000|SNDRV_PCM_RATE_64000|\\\n\t\t\t\t\t SNDRV_PCM_RATE_88200|SNDRV_PCM_RATE_96000)\n#define SNDRV_PCM_RATE_8000_192000\t(SNDRV_PCM_RATE_8000_96000|SNDRV_PCM_RATE_176400|\\\n\t\t\t\t\t SNDRV_PCM_RATE_192000)\n#define SNDRV_PCM_RATE_8000_384000\t(SNDRV_PCM_RATE_8000_192000|\\\n\t\t\t\t\t SNDRV_PCM_RATE_352800|\\\n\t\t\t\t\t SNDRV_PCM_RATE_384000)\n#define _SNDRV_PCM_FMTBIT(fmt)\t\t(1ULL << (__force int)SNDRV_PCM_FORMAT_##fmt)\n#define SNDRV_PCM_FMTBIT_S8\t\t_SNDRV_PCM_FMTBIT(S8)\n#define SNDRV_PCM_FMTBIT_U8\t\t_SNDRV_PCM_FMTBIT(U8)\n#define SNDRV_PCM_FMTBIT_S16_LE\t\t_SNDRV_PCM_FMTBIT(S16_LE)\n#define SNDRV_PCM_FMTBIT_S16_BE\t\t_SNDRV_PCM_FMTBIT(S16_BE)\n#define SNDRV_PCM_FMTBIT_U16_LE\t\t_SNDRV_PCM_FMTBIT(U16_LE)\n#define SNDRV_PCM_FMTBIT_U16_BE\t\t_SNDRV_PCM_FMTBIT(U16_BE)\n#define SNDRV_PCM_FMTBIT_S24_LE\t\t_SNDRV_PCM_FMTBIT(S24_LE)\n#define SNDRV_PCM_FMTBIT_S24_BE\t\t_SNDRV_PCM_FMTBIT(S24_BE)\n#define SNDRV_PCM_FMTBIT_U24_LE\t\t_SNDRV_PCM_FMTBIT(U24_LE)\n#define SNDRV_PCM_FMTBIT_U24_BE\t\t_SNDRV_PCM_FMTBIT(U24_BE)\n\n\n\n#define SNDRV_PCM_FMTBIT_S32_LE\t\t_SNDRV_PCM_FMTBIT(S32_LE)\n#define SNDRV_PCM_FMTBIT_S32_BE\t\t_SNDRV_PCM_FMTBIT(S32_BE)\n#define SNDRV_PCM_FMTBIT_U32_LE\t\t_SNDRV_PCM_FMTBIT(U32_LE)\n#define SNDRV_PCM_FMTBIT_U32_BE\t\t_SNDRV_PCM_FMTBIT(U32_BE)\n#define SNDRV_PCM_FMTBIT_FLOAT_LE\t_SNDRV_PCM_FMTBIT(FLOAT_LE)\n#define SNDRV_PCM_FMTBIT_FLOAT_BE\t_SNDRV_PCM_FMTBIT(FLOAT_BE)\n#define SNDRV_PCM_FMTBIT_FLOAT64_LE\t_SNDRV_PCM_FMTBIT(FLOAT64_LE)\n#define SNDRV_PCM_FMTBIT_FLOAT64_BE\t_SNDRV_PCM_FMTBIT(FLOAT64_BE)\n#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE _SNDRV_PCM_FMTBIT(IEC958_SUBFRAME_LE)\n#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE _SNDRV_PCM_FMTBIT(IEC958_SUBFRAME_BE)\n#define SNDRV_PCM_FMTBIT_MU_LAW\t\t_SNDRV_PCM_FMTBIT(MU_LAW)\n#define SNDRV_PCM_FMTBIT_A_LAW\t\t_SNDRV_PCM_FMTBIT(A_LAW)\n#define SNDRV_PCM_FMTBIT_IMA_ADPCM\t_SNDRV_PCM_FMTBIT(IMA_ADPCM)\n#define SNDRV_PCM_FMTBIT_MPEG\t\t_SNDRV_PCM_FMTBIT(MPEG)\n#define SNDRV_PCM_FMTBIT_GSM\t\t_SNDRV_PCM_FMTBIT(GSM)\n#define SNDRV_PCM_FMTBIT_S20_LE\t_SNDRV_PCM_FMTBIT(S20_LE)\n#define SNDRV_PCM_FMTBIT_U20_LE\t_SNDRV_PCM_FMTBIT(U20_LE)\n#define SNDRV_PCM_FMTBIT_S20_BE\t_SNDRV_PCM_FMTBIT(S20_BE)\n#define SNDRV_PCM_FMTBIT_U20_BE\t_SNDRV_PCM_FMTBIT(U20_BE)\n#define SNDRV_PCM_FMTBIT_SPECIAL\t_SNDRV_PCM_FMTBIT(SPECIAL)\n#define SNDRV_PCM_FMTBIT_S24_3LE\t_SNDRV_PCM_FMTBIT(S24_3LE)\n#define SNDRV_PCM_FMTBIT_U24_3LE\t_SNDRV_PCM_FMTBIT(U24_3LE)\n#define SNDRV_PCM_FMTBIT_S24_3BE\t_SNDRV_PCM_FMTBIT(S24_3BE)\n#define SNDRV_PCM_FMTBIT_U24_3BE\t_SNDRV_PCM_FMTBIT(U24_3BE)\n#define SNDRV_PCM_FMTBIT_S20_3LE\t_SNDRV_PCM_FMTBIT(S20_3LE)\n#define SNDRV_PCM_FMTBIT_U20_3LE\t_SNDRV_PCM_FMTBIT(U20_3LE)\n#define SNDRV_PCM_FMTBIT_S20_3BE\t_SNDRV_PCM_FMTBIT(S20_3BE)\n#define SNDRV_PCM_FMTBIT_U20_3BE\t_SNDRV_PCM_FMTBIT(U20_3BE)\n#define SNDRV_PCM_FMTBIT_S18_3LE\t_SNDRV_PCM_FMTBIT(S18_3LE)\n#define SNDRV_PCM_FMTBIT_U18_3LE\t_SNDRV_PCM_FMTBIT(U18_3LE)\n#define SNDRV_PCM_FMTBIT_S18_3BE\t_SNDRV_PCM_FMTBIT(S18_3BE)\n#define SNDRV_PCM_FMTBIT_U18_3BE\t_SNDRV_PCM_FMTBIT(U18_3BE)\n#define SNDRV_PCM_FMTBIT_G723_24\t_SNDRV_PCM_FMTBIT(G723_24)\n#define SNDRV_PCM_FMTBIT_G723_24_1B\t_SNDRV_PCM_FMTBIT(G723_24_1B)\n#define SNDRV_PCM_FMTBIT_G723_40\t_SNDRV_PCM_FMTBIT(G723_40)\n#define SNDRV_PCM_FMTBIT_G723_40_1B\t_SNDRV_PCM_FMTBIT(G723_40_1B)\n#define SNDRV_PCM_FMTBIT_DSD_U8\t\t_SNDRV_PCM_FMTBIT(DSD_U8)\n#define SNDRV_PCM_FMTBIT_DSD_U16_LE\t_SNDRV_PCM_FMTBIT(DSD_U16_LE)\n#define SNDRV_PCM_FMTBIT_DSD_U32_LE\t_SNDRV_PCM_FMTBIT(DSD_U32_LE)\n#define SNDRV_PCM_FMTBIT_DSD_U16_BE\t_SNDRV_PCM_FMTBIT(DSD_U16_BE)\n#define SNDRV_PCM_FMTBIT_DSD_U32_BE\t_SNDRV_PCM_FMTBIT(DSD_U32_BE)\n\n#ifdef SNDRV_LITTLE_ENDIAN\n#define SNDRV_PCM_FMTBIT_S16\t\tSNDRV_PCM_FMTBIT_S16_LE\n#define SNDRV_PCM_FMTBIT_U16\t\tSNDRV_PCM_FMTBIT_U16_LE\n#define SNDRV_PCM_FMTBIT_S24\t\tSNDRV_PCM_FMTBIT_S24_LE\n#define SNDRV_PCM_FMTBIT_U24\t\tSNDRV_PCM_FMTBIT_U24_LE\n#define SNDRV_PCM_FMTBIT_S32\t\tSNDRV_PCM_FMTBIT_S32_LE\n#define SNDRV_PCM_FMTBIT_U32\t\tSNDRV_PCM_FMTBIT_U32_LE\n#define SNDRV_PCM_FMTBIT_FLOAT\t\tSNDRV_PCM_FMTBIT_FLOAT_LE\n#define SNDRV_PCM_FMTBIT_FLOAT64\tSNDRV_PCM_FMTBIT_FLOAT64_LE\n#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE\n#define SNDRV_PCM_FMTBIT_S20\t\tSNDRV_PCM_FMTBIT_S20_LE\n#define SNDRV_PCM_FMTBIT_U20\t\tSNDRV_PCM_FMTBIT_U20_LE\n#endif\n#ifdef SNDRV_BIG_ENDIAN\n#define SNDRV_PCM_FMTBIT_S16\t\tSNDRV_PCM_FMTBIT_S16_BE\n#define SNDRV_PCM_FMTBIT_U16\t\tSNDRV_PCM_FMTBIT_U16_BE\n#define SNDRV_PCM_FMTBIT_S24\t\tSNDRV_PCM_FMTBIT_S24_BE\n#define SNDRV_PCM_FMTBIT_U24\t\tSNDRV_PCM_FMTBIT_U24_BE\n#define SNDRV_PCM_FMTBIT_S32\t\tSNDRV_PCM_FMTBIT_S32_BE\n#define SNDRV_PCM_FMTBIT_U32\t\tSNDRV_PCM_FMTBIT_U32_BE\n#define SNDRV_PCM_FMTBIT_FLOAT\t\tSNDRV_PCM_FMTBIT_FLOAT_BE\n#define SNDRV_PCM_FMTBIT_FLOAT64\tSNDRV_PCM_FMTBIT_FLOAT64_BE\n#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE\n#define SNDRV_PCM_FMTBIT_S20\t\tSNDRV_PCM_FMTBIT_S20_BE\n#define SNDRV_PCM_FMTBIT_U20\t\tSNDRV_PCM_FMTBIT_U20_BE\n#endif\n\nstruct snd_pcm_file {\n\tstruct snd_pcm_substream *substream;\n\tint no_compat_mmap;\n\tunsigned int user_pversion;\t \n};\n\nstruct snd_pcm_hw_rule;\ntypedef int (*snd_pcm_hw_rule_func_t)(struct snd_pcm_hw_params *params,\n\t\t\t\t      struct snd_pcm_hw_rule *rule);\n\nstruct snd_pcm_hw_rule {\n\tunsigned int cond;\n\tint var;\n\tint deps[5];\n\n\tsnd_pcm_hw_rule_func_t func;\n\tvoid *private;\n};\n\nstruct snd_pcm_hw_constraints {\n\tstruct snd_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK - \n\t\t\t SNDRV_PCM_HW_PARAM_FIRST_MASK + 1];\n\tstruct snd_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL -\n\t\t\t     SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];\n\tunsigned int rules_num;\n\tunsigned int rules_all;\n\tstruct snd_pcm_hw_rule *rules;\n};\n\nstatic inline struct snd_mask *constrs_mask(struct snd_pcm_hw_constraints *constrs,\n\t\t\t\t\t    snd_pcm_hw_param_t var)\n{\n\treturn &constrs->masks[var - SNDRV_PCM_HW_PARAM_FIRST_MASK];\n}\n\nstatic inline struct snd_interval *constrs_interval(struct snd_pcm_hw_constraints *constrs,\n\t\t\t\t\t\t    snd_pcm_hw_param_t var)\n{\n\treturn &constrs->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];\n}\n\nstruct snd_ratnum {\n\tunsigned int num;\n\tunsigned int den_min, den_max, den_step;\n};\n\nstruct snd_ratden {\n\tunsigned int num_min, num_max, num_step;\n\tunsigned int den;\n};\n\nstruct snd_pcm_hw_constraint_ratnums {\n\tint nrats;\n\tconst struct snd_ratnum *rats;\n};\n\nstruct snd_pcm_hw_constraint_ratdens {\n\tint nrats;\n\tconst struct snd_ratden *rats;\n};\n\nstruct snd_pcm_hw_constraint_list {\n\tconst unsigned int *list;\n\tunsigned int count;\n\tunsigned int mask;\n};\n\nstruct snd_pcm_hw_constraint_ranges {\n\tunsigned int count;\n\tconst struct snd_interval *ranges;\n\tunsigned int mask;\n};\n\n \nstruct snd_pcm_audio_tstamp_config {\n\t \n\tu32 type_requested:4;\n\tu32 report_delay:1;  \n};\n\nstatic inline void snd_pcm_unpack_audio_tstamp_config(__u32 data,\n\t\t\t\t\t\tstruct snd_pcm_audio_tstamp_config *config)\n{\n\tconfig->type_requested = data & 0xF;\n\tconfig->report_delay = (data >> 4) & 1;\n}\n\n \nstruct snd_pcm_audio_tstamp_report {\n\t \n\n\t \n\tu32 valid:1;\n\n\t \n\tu32 actual_type:4;\n\n\t \n\tu32 accuracy_report:1;  \n\tu32 accuracy;  \n};\n\nstatic inline void snd_pcm_pack_audio_tstamp_report(__u32 *data, __u32 *accuracy,\n\t\t\t\t\t\tconst struct snd_pcm_audio_tstamp_report *report)\n{\n\tu32 tmp;\n\n\ttmp = report->accuracy_report;\n\ttmp <<= 4;\n\ttmp |= report->actual_type;\n\ttmp <<= 1;\n\ttmp |= report->valid;\n\n\t*data &= 0xffff;  \n\t*data |= (tmp << 16);\n\t*accuracy = report->accuracy;\n}\n\n\nstruct snd_pcm_runtime {\n\t \n\tsnd_pcm_state_t state;\t\t \n\tsnd_pcm_state_t suspended_state;  \n\tstruct snd_pcm_substream *trigger_master;\n\tstruct timespec64 trigger_tstamp;\t \n\tbool trigger_tstamp_latched;      \n\tint overrange;\n\tsnd_pcm_uframes_t avail_max;\n\tsnd_pcm_uframes_t hw_ptr_base;\t \n\tsnd_pcm_uframes_t hw_ptr_interrupt;  \n\tunsigned long hw_ptr_jiffies;\t \n\tunsigned long hw_ptr_buffer_jiffies;  \n\tsnd_pcm_sframes_t delay;\t \n\tu64 hw_ptr_wrap;                 \n\n\t \n\tsnd_pcm_access_t access;\t \n\tsnd_pcm_format_t format;\t \n\tsnd_pcm_subformat_t subformat;\t \n\tunsigned int rate;\t\t \n\tunsigned int channels;\t\t \n\tsnd_pcm_uframes_t period_size;\t \n\tunsigned int periods;\t\t \n\tsnd_pcm_uframes_t buffer_size;\t \n\tsnd_pcm_uframes_t min_align;\t \n\tsize_t byte_align;\n\tunsigned int frame_bits;\n\tunsigned int sample_bits;\n\tunsigned int info;\n\tunsigned int rate_num;\n\tunsigned int rate_den;\n\tunsigned int no_period_wakeup: 1;\n\n\t \n\tint tstamp_mode;\n  \tunsigned int period_step;\n\tsnd_pcm_uframes_t start_threshold;\n\tsnd_pcm_uframes_t stop_threshold;\n\tsnd_pcm_uframes_t silence_threshold;\n\tsnd_pcm_uframes_t silence_size;\n\tsnd_pcm_uframes_t boundary;\n\n\t \n\tsnd_pcm_uframes_t silence_start;  \n\tsnd_pcm_uframes_t silence_filled;  \n\n\tunion snd_pcm_sync_id sync;\t \n\n\t \n\tstruct snd_pcm_mmap_status *status;\n\tstruct snd_pcm_mmap_control *control;\n\n\t \n\tsnd_pcm_uframes_t twake; \t \n\twait_queue_head_t sleep;\t \n\twait_queue_head_t tsleep;\t \n\tstruct snd_fasync *fasync;\n\tbool stop_operating;\t\t \n\tstruct mutex buffer_mutex;\t \n\tatomic_t buffer_accessing;\t \n\n\t \n\tvoid *private_data;\n\tvoid (*private_free)(struct snd_pcm_runtime *runtime);\n\n\t \n\tstruct snd_pcm_hardware hw;\n\tstruct snd_pcm_hw_constraints hw_constraints;\n\n\t \n\tunsigned int timer_resolution;\t \n\tint tstamp_type;\t\t \n\n\t            \n\tunsigned char *dma_area;\t \n\tdma_addr_t dma_addr;\t\t \n\tsize_t dma_bytes;\t\t \n\n\tstruct snd_dma_buffer *dma_buffer_p;\t \n\tunsigned int buffer_changed:1;\t \n\n\t \n\tstruct snd_pcm_audio_tstamp_config audio_tstamp_config;\n\tstruct snd_pcm_audio_tstamp_report audio_tstamp_report;\n\tstruct timespec64 driver_tstamp;\n\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n\t \n\tstruct snd_pcm_oss_runtime oss;\n#endif\n};\n\nstruct snd_pcm_group {\t\t \n\tspinlock_t lock;\n\tstruct mutex mutex;\n\tstruct list_head substreams;\n\trefcount_t refs;\n};\n\nstruct pid;\n\nstruct snd_pcm_substream {\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_str *pstr;\n\tvoid *private_data;\t\t \n\tint number;\n\tchar name[32];\t\t\t \n\tint stream;\t\t\t \n\tstruct pm_qos_request latency_pm_qos_req;  \n\tsize_t buffer_bytes_max;\t \n\tstruct snd_dma_buffer dma_buffer;\n\tsize_t dma_max;\n\t \n\tconst struct snd_pcm_ops *ops;\n\t \n\tstruct snd_pcm_runtime *runtime;\n         \n\tstruct snd_timer *timer;\t\t \n\tunsigned timer_running: 1;\t \n\tlong wait_time;\t \n\t \n\tstruct snd_pcm_substream *next;\n\t \n\tstruct list_head link_list;\t \n\tstruct snd_pcm_group self_group;\t \n\tstruct snd_pcm_group *group;\t\t \n\t \n\tint ref_count;\n\tatomic_t mmap_count;\n\tunsigned int f_flags;\n\tvoid (*pcm_release)(struct snd_pcm_substream *);\n\tstruct pid *pid;\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n\t \n\tstruct snd_pcm_oss_substream oss;\n#endif\n#ifdef CONFIG_SND_VERBOSE_PROCFS\n\tstruct snd_info_entry *proc_root;\n#endif  \n\t \n\tunsigned int hw_opened: 1;\n\tunsigned int managed_buffer_alloc:1;\n};\n\n#define SUBSTREAM_BUSY(substream) ((substream)->ref_count > 0)\n\n\nstruct snd_pcm_str {\n\tint stream;\t\t\t\t \n\tstruct snd_pcm *pcm;\n\t \n\tunsigned int substream_count;\n\tunsigned int substream_opened;\n\tstruct snd_pcm_substream *substream;\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n\t \n\tstruct snd_pcm_oss_stream oss;\n#endif\n#ifdef CONFIG_SND_VERBOSE_PROCFS\n\tstruct snd_info_entry *proc_root;\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n\tunsigned int xrun_debug;\t \n#endif\n#endif\n\tstruct snd_kcontrol *chmap_kctl;  \n\tstruct device *dev;\n};\n\nstruct snd_pcm {\n\tstruct snd_card *card;\n\tstruct list_head list;\n\tint device;  \n\tunsigned int info_flags;\n\tunsigned short dev_class;\n\tunsigned short dev_subclass;\n\tchar id[64];\n\tchar name[80];\n\tstruct snd_pcm_str streams[2];\n\tstruct mutex open_mutex;\n\twait_queue_head_t open_wait;\n\tvoid *private_data;\n\tvoid (*private_free) (struct snd_pcm *pcm);\n\tbool internal;  \n\tbool nonatomic;  \n\tbool no_device_suspend;  \n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n\tstruct snd_pcm_oss oss;\n#endif\n};\n\n \n\nextern const struct file_operations snd_pcm_f_ops[2];\n\nint snd_pcm_new(struct snd_card *card, const char *id, int device,\n\t\tint playback_count, int capture_count,\n\t\tstruct snd_pcm **rpcm);\nint snd_pcm_new_internal(struct snd_card *card, const char *id, int device,\n\t\tint playback_count, int capture_count,\n\t\tstruct snd_pcm **rpcm);\nint snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count);\n\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\nstruct snd_pcm_notify {\n\tint (*n_register) (struct snd_pcm * pcm);\n\tint (*n_disconnect) (struct snd_pcm * pcm);\n\tint (*n_unregister) (struct snd_pcm * pcm);\n\tstruct list_head list;\n};\nint snd_pcm_notify(struct snd_pcm_notify *notify, int nfree);\n#endif\n\n \n\nint snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info);\nint snd_pcm_info_user(struct snd_pcm_substream *substream,\n\t\t      struct snd_pcm_info __user *info);\nint snd_pcm_status64(struct snd_pcm_substream *substream,\n\t\t     struct snd_pcm_status64 *status);\nint snd_pcm_start(struct snd_pcm_substream *substream);\nint snd_pcm_stop(struct snd_pcm_substream *substream, snd_pcm_state_t status);\nint snd_pcm_drain_done(struct snd_pcm_substream *substream);\nint snd_pcm_stop_xrun(struct snd_pcm_substream *substream);\n#ifdef CONFIG_PM\nint snd_pcm_suspend_all(struct snd_pcm *pcm);\n#else\nstatic inline int snd_pcm_suspend_all(struct snd_pcm *pcm)\n{\n\treturn 0;\n}\n#endif\nint snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg);\nint snd_pcm_open_substream(struct snd_pcm *pcm, int stream, struct file *file,\n\t\t\t   struct snd_pcm_substream **rsubstream);\nvoid snd_pcm_release_substream(struct snd_pcm_substream *substream);\nint snd_pcm_attach_substream(struct snd_pcm *pcm, int stream, struct file *file,\n\t\t\t     struct snd_pcm_substream **rsubstream);\nvoid snd_pcm_detach_substream(struct snd_pcm_substream *substream);\nint snd_pcm_mmap_data(struct snd_pcm_substream *substream, struct file *file, struct vm_area_struct *area);\n\n\n#ifdef CONFIG_SND_DEBUG\nvoid snd_pcm_debug_name(struct snd_pcm_substream *substream,\n\t\t\t   char *name, size_t len);\n#else\nstatic inline void\nsnd_pcm_debug_name(struct snd_pcm_substream *substream, char *buf, size_t size)\n{\n\t*buf = 0;\n}\n#endif\n\n \n\n \nstatic inline int snd_pcm_stream_linked(struct snd_pcm_substream *substream)\n{\n\treturn substream->group != &substream->self_group;\n}\n\nvoid snd_pcm_stream_lock(struct snd_pcm_substream *substream);\nvoid snd_pcm_stream_unlock(struct snd_pcm_substream *substream);\nvoid snd_pcm_stream_lock_irq(struct snd_pcm_substream *substream);\nvoid snd_pcm_stream_unlock_irq(struct snd_pcm_substream *substream);\nunsigned long _snd_pcm_stream_lock_irqsave(struct snd_pcm_substream *substream);\nunsigned long _snd_pcm_stream_lock_irqsave_nested(struct snd_pcm_substream *substream);\n\n \n#define snd_pcm_stream_lock_irqsave(substream, flags)\t\t \\\n\tdo {\t\t\t\t\t\t\t \\\n\t\ttypecheck(unsigned long, flags);\t\t \\\n\t\tflags = _snd_pcm_stream_lock_irqsave(substream); \\\n\t} while (0)\nvoid snd_pcm_stream_unlock_irqrestore(struct snd_pcm_substream *substream,\n\t\t\t\t      unsigned long flags);\n\n \n#define snd_pcm_stream_lock_irqsave_nested(substream, flags)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\t\t\\\n\t\tflags = _snd_pcm_stream_lock_irqsave_nested(substream); \\\n\t} while (0)\n\n \n#define snd_pcm_group_for_each_entry(s, substream) \\\n\tlist_for_each_entry(s, &substream->group->substreams, link_list)\n\n#define for_each_pcm_streams(stream)\t\t\t\\\n\tfor (stream  = SNDRV_PCM_STREAM_PLAYBACK;\t\\\n\t     stream <= SNDRV_PCM_STREAM_LAST;\t\t\\\n\t     stream++)\n\n \nstatic inline int snd_pcm_running(struct snd_pcm_substream *substream)\n{\n\treturn (substream->runtime->state == SNDRV_PCM_STATE_RUNNING ||\n\t\t(substream->runtime->state == SNDRV_PCM_STATE_DRAINING &&\n\t\t substream->stream == SNDRV_PCM_STREAM_PLAYBACK));\n}\n\n \nstatic inline void __snd_pcm_set_state(struct snd_pcm_runtime *runtime,\n\t\t\t\t       snd_pcm_state_t state)\n{\n\truntime->state = state;\n\truntime->status->state = state;  \n}\n\n \nstatic inline ssize_t bytes_to_samples(struct snd_pcm_runtime *runtime, ssize_t size)\n{\n\treturn size * 8 / runtime->sample_bits;\n}\n\n \nstatic inline snd_pcm_sframes_t bytes_to_frames(struct snd_pcm_runtime *runtime, ssize_t size)\n{\n\treturn size * 8 / runtime->frame_bits;\n}\n\n \nstatic inline ssize_t samples_to_bytes(struct snd_pcm_runtime *runtime, ssize_t size)\n{\n\treturn size * runtime->sample_bits / 8;\n}\n\n \nstatic inline ssize_t frames_to_bytes(struct snd_pcm_runtime *runtime, snd_pcm_sframes_t size)\n{\n\treturn size * runtime->frame_bits / 8;\n}\n\n \nstatic inline int frame_aligned(struct snd_pcm_runtime *runtime, ssize_t bytes)\n{\n\treturn bytes % runtime->byte_align == 0;\n}\n\n \nstatic inline size_t snd_pcm_lib_buffer_bytes(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\treturn frames_to_bytes(runtime, runtime->buffer_size);\n}\n\n \nstatic inline size_t snd_pcm_lib_period_bytes(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\treturn frames_to_bytes(runtime, runtime->period_size);\n}\n\n \nstatic inline snd_pcm_uframes_t snd_pcm_playback_avail(struct snd_pcm_runtime *runtime)\n{\n\tsnd_pcm_sframes_t avail = runtime->status->hw_ptr + runtime->buffer_size - runtime->control->appl_ptr;\n\tif (avail < 0)\n\t\tavail += runtime->boundary;\n\telse if ((snd_pcm_uframes_t) avail >= runtime->boundary)\n\t\tavail -= runtime->boundary;\n\treturn avail;\n}\n\n \nstatic inline snd_pcm_uframes_t snd_pcm_capture_avail(struct snd_pcm_runtime *runtime)\n{\n\tsnd_pcm_sframes_t avail = runtime->status->hw_ptr - runtime->control->appl_ptr;\n\tif (avail < 0)\n\t\tavail += runtime->boundary;\n\treturn avail;\n}\n\n \nstatic inline snd_pcm_sframes_t snd_pcm_playback_hw_avail(struct snd_pcm_runtime *runtime)\n{\n\treturn runtime->buffer_size - snd_pcm_playback_avail(runtime);\n}\n\n \nstatic inline snd_pcm_sframes_t snd_pcm_capture_hw_avail(struct snd_pcm_runtime *runtime)\n{\n\treturn runtime->buffer_size - snd_pcm_capture_avail(runtime);\n}\n\n \nstatic inline int snd_pcm_playback_ready(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\treturn snd_pcm_playback_avail(runtime) >= runtime->control->avail_min;\n}\n\n \nstatic inline int snd_pcm_capture_ready(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\treturn snd_pcm_capture_avail(runtime) >= runtime->control->avail_min;\n}\n\n \nstatic inline int snd_pcm_playback_data(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\t\n\tif (runtime->stop_threshold >= runtime->boundary)\n\t\treturn 1;\n\treturn snd_pcm_playback_avail(runtime) < runtime->buffer_size;\n}\n\n \nstatic inline int snd_pcm_playback_empty(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\treturn snd_pcm_playback_avail(runtime) >= runtime->buffer_size;\n}\n\n \nstatic inline int snd_pcm_capture_empty(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\treturn snd_pcm_capture_avail(runtime) == 0;\n}\n\n \nstatic inline void snd_pcm_trigger_done(struct snd_pcm_substream *substream, \n\t\t\t\t\tstruct snd_pcm_substream *master)\n{\n\tsubstream->runtime->trigger_master = master;\n}\n\nstatic inline int hw_is_mask(int var)\n{\n\treturn var >= SNDRV_PCM_HW_PARAM_FIRST_MASK &&\n\t\tvar <= SNDRV_PCM_HW_PARAM_LAST_MASK;\n}\n\nstatic inline int hw_is_interval(int var)\n{\n\treturn var >= SNDRV_PCM_HW_PARAM_FIRST_INTERVAL &&\n\t\tvar <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL;\n}\n\nstatic inline struct snd_mask *hw_param_mask(struct snd_pcm_hw_params *params,\n\t\t\t\t     snd_pcm_hw_param_t var)\n{\n\treturn &params->masks[var - SNDRV_PCM_HW_PARAM_FIRST_MASK];\n}\n\nstatic inline struct snd_interval *hw_param_interval(struct snd_pcm_hw_params *params,\n\t\t\t\t\t     snd_pcm_hw_param_t var)\n{\n\treturn &params->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];\n}\n\nstatic inline const struct snd_mask *hw_param_mask_c(const struct snd_pcm_hw_params *params,\n\t\t\t\t\t     snd_pcm_hw_param_t var)\n{\n\treturn &params->masks[var - SNDRV_PCM_HW_PARAM_FIRST_MASK];\n}\n\nstatic inline const struct snd_interval *hw_param_interval_c(const struct snd_pcm_hw_params *params,\n\t\t\t\t\t\t     snd_pcm_hw_param_t var)\n{\n\treturn &params->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];\n}\n\n \nstatic inline unsigned int params_channels(const struct snd_pcm_hw_params *p)\n{\n\treturn hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_CHANNELS)->min;\n}\n\n \nstatic inline unsigned int params_rate(const struct snd_pcm_hw_params *p)\n{\n\treturn hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_RATE)->min;\n}\n\n \nstatic inline unsigned int params_period_size(const struct snd_pcm_hw_params *p)\n{\n\treturn hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_PERIOD_SIZE)->min;\n}\n\n \nstatic inline unsigned int params_periods(const struct snd_pcm_hw_params *p)\n{\n\treturn hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_PERIODS)->min;\n}\n\n \nstatic inline unsigned int params_buffer_size(const struct snd_pcm_hw_params *p)\n{\n\treturn hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_BUFFER_SIZE)->min;\n}\n\n \nstatic inline unsigned int params_buffer_bytes(const struct snd_pcm_hw_params *p)\n{\n\treturn hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_BUFFER_BYTES)->min;\n}\n\nint snd_interval_refine(struct snd_interval *i, const struct snd_interval *v);\nint snd_interval_list(struct snd_interval *i, unsigned int count,\n\t\t      const unsigned int *list, unsigned int mask);\nint snd_interval_ranges(struct snd_interval *i, unsigned int count,\n\t\t\tconst struct snd_interval *list, unsigned int mask);\nint snd_interval_ratnum(struct snd_interval *i,\n\t\t\tunsigned int rats_count, const struct snd_ratnum *rats,\n\t\t\tunsigned int *nump, unsigned int *denp);\n\nvoid _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params);\nvoid _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params, snd_pcm_hw_param_t var);\n\nint snd_pcm_hw_refine(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params);\n\nint snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\t\t\t\t u_int64_t mask);\nint snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\t\t\t\t unsigned int min, unsigned int max);\nint snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var);\nint snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime, \n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var,\n\t\t\t       const struct snd_pcm_hw_constraint_list *l);\nint snd_pcm_hw_constraint_ranges(struct snd_pcm_runtime *runtime,\n\t\t\t\t unsigned int cond,\n\t\t\t\t snd_pcm_hw_param_t var,\n\t\t\t\t const struct snd_pcm_hw_constraint_ranges *r);\nint snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, \n\t\t\t\t  unsigned int cond,\n\t\t\t\t  snd_pcm_hw_param_t var,\n\t\t\t\t  const struct snd_pcm_hw_constraint_ratnums *r);\nint snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, \n\t\t\t\t  unsigned int cond,\n\t\t\t\t  snd_pcm_hw_param_t var,\n\t\t\t\t  const struct snd_pcm_hw_constraint_ratdens *r);\nint snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime, \n\t\t\t\t unsigned int cond,\n\t\t\t\t unsigned int width,\n\t\t\t\t unsigned int msbits);\nint snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var,\n\t\t\t       unsigned long step);\nint snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var);\nint snd_pcm_hw_rule_noresample(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int base_rate);\nint snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime,\n\t\t\tunsigned int cond,\n\t\t\tint var,\n\t\t\tsnd_pcm_hw_rule_func_t func, void *private,\n\t\t\tint dep, ...);\n\n \nstatic inline int snd_pcm_hw_constraint_single(\n\tstruct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\tunsigned int val)\n{\n\treturn snd_pcm_hw_constraint_minmax(runtime, var, val, val);\n}\n\nint snd_pcm_format_signed(snd_pcm_format_t format);\nint snd_pcm_format_unsigned(snd_pcm_format_t format);\nint snd_pcm_format_linear(snd_pcm_format_t format);\nint snd_pcm_format_little_endian(snd_pcm_format_t format);\nint snd_pcm_format_big_endian(snd_pcm_format_t format);\n#if 0  \n \nint snd_pcm_format_cpu_endian(snd_pcm_format_t format);\n#endif  \n#ifdef SNDRV_LITTLE_ENDIAN\n#define snd_pcm_format_cpu_endian(format) snd_pcm_format_little_endian(format)\n#else\n#define snd_pcm_format_cpu_endian(format) snd_pcm_format_big_endian(format)\n#endif\nint snd_pcm_format_width(snd_pcm_format_t format);\t\t\t \nint snd_pcm_format_physical_width(snd_pcm_format_t format);\t\t \nssize_t snd_pcm_format_size(snd_pcm_format_t format, size_t samples);\nconst unsigned char *snd_pcm_format_silence_64(snd_pcm_format_t format);\nint snd_pcm_format_set_silence(snd_pcm_format_t format, void *buf, unsigned int frames);\n\nvoid snd_pcm_set_ops(struct snd_pcm * pcm, int direction,\n\t\t     const struct snd_pcm_ops *ops);\nvoid snd_pcm_set_sync(struct snd_pcm_substream *substream);\nint snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,\n\t\t      unsigned int cmd, void *arg);                      \nvoid snd_pcm_period_elapsed_under_stream_lock(struct snd_pcm_substream *substream);\nvoid snd_pcm_period_elapsed(struct snd_pcm_substream *substream);\nsnd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,\n\t\t\t\t     void *buf, bool interleaved,\n\t\t\t\t     snd_pcm_uframes_t frames, bool in_kernel);\n\nstatic inline snd_pcm_sframes_t\nsnd_pcm_lib_write(struct snd_pcm_substream *substream,\n\t\t  const void __user *buf, snd_pcm_uframes_t frames)\n{\n\treturn __snd_pcm_lib_xfer(substream, (void __force *)buf, true, frames, false);\n}\n\nstatic inline snd_pcm_sframes_t\nsnd_pcm_lib_read(struct snd_pcm_substream *substream,\n\t\t void __user *buf, snd_pcm_uframes_t frames)\n{\n\treturn __snd_pcm_lib_xfer(substream, (void __force *)buf, true, frames, false);\n}\n\nstatic inline snd_pcm_sframes_t\nsnd_pcm_lib_writev(struct snd_pcm_substream *substream,\n\t\t   void __user **bufs, snd_pcm_uframes_t frames)\n{\n\treturn __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);\n}\n\nstatic inline snd_pcm_sframes_t\nsnd_pcm_lib_readv(struct snd_pcm_substream *substream,\n\t\t  void __user **bufs, snd_pcm_uframes_t frames)\n{\n\treturn __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);\n}\n\nstatic inline snd_pcm_sframes_t\nsnd_pcm_kernel_write(struct snd_pcm_substream *substream,\n\t\t     const void *buf, snd_pcm_uframes_t frames)\n{\n\treturn __snd_pcm_lib_xfer(substream, (void *)buf, true, frames, true);\n}\n\nstatic inline snd_pcm_sframes_t\nsnd_pcm_kernel_read(struct snd_pcm_substream *substream,\n\t\t    void *buf, snd_pcm_uframes_t frames)\n{\n\treturn __snd_pcm_lib_xfer(substream, buf, true, frames, true);\n}\n\nstatic inline snd_pcm_sframes_t\nsnd_pcm_kernel_writev(struct snd_pcm_substream *substream,\n\t\t      void **bufs, snd_pcm_uframes_t frames)\n{\n\treturn __snd_pcm_lib_xfer(substream, bufs, false, frames, true);\n}\n\nstatic inline snd_pcm_sframes_t\nsnd_pcm_kernel_readv(struct snd_pcm_substream *substream,\n\t\t     void **bufs, snd_pcm_uframes_t frames)\n{\n\treturn __snd_pcm_lib_xfer(substream, bufs, false, frames, true);\n}\n\nint snd_pcm_hw_limit_rates(struct snd_pcm_hardware *hw);\n\nstatic inline int\nsnd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime)\n{\n\treturn snd_pcm_hw_limit_rates(&runtime->hw);\n}\n\nunsigned int snd_pcm_rate_to_rate_bit(unsigned int rate);\nunsigned int snd_pcm_rate_bit_to_rate(unsigned int rate_bit);\nunsigned int snd_pcm_rate_mask_intersect(unsigned int rates_a,\n\t\t\t\t\t unsigned int rates_b);\nunsigned int snd_pcm_rate_range_to_bits(unsigned int rate_min,\n\t\t\t\t\tunsigned int rate_max);\n\n \nstatic inline void snd_pcm_set_runtime_buffer(struct snd_pcm_substream *substream,\n\t\t\t\t\t      struct snd_dma_buffer *bufp)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (bufp) {\n\t\truntime->dma_buffer_p = bufp;\n\t\truntime->dma_area = bufp->area;\n\t\truntime->dma_addr = bufp->addr;\n\t\truntime->dma_bytes = bufp->bytes;\n\t} else {\n\t\truntime->dma_buffer_p = NULL;\n\t\truntime->dma_area = NULL;\n\t\truntime->dma_addr = 0;\n\t\truntime->dma_bytes = 0;\n\t}\n}\n\n \nstatic inline void snd_pcm_gettime(struct snd_pcm_runtime *runtime,\n\t\t\t\t   struct timespec64 *tv)\n{\n\tswitch (runtime->tstamp_type) {\n\tcase SNDRV_PCM_TSTAMP_TYPE_MONOTONIC:\n\t\tktime_get_ts64(tv);\n\t\tbreak;\n\tcase SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW:\n\t\tktime_get_raw_ts64(tv);\n\t\tbreak;\n\tdefault:\n\t\tktime_get_real_ts64(tv);\n\t\tbreak;\n\t}\n}\n\n \n\nvoid snd_pcm_lib_preallocate_free(struct snd_pcm_substream *substream);\nvoid snd_pcm_lib_preallocate_free_for_all(struct snd_pcm *pcm);\nvoid snd_pcm_lib_preallocate_pages(struct snd_pcm_substream *substream,\n\t\t\t\t  int type, struct device *data,\n\t\t\t\t  size_t size, size_t max);\nvoid snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm,\n\t\t\t\t\t  int type, void *data,\n\t\t\t\t\t  size_t size, size_t max);\nint snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream, size_t size);\nint snd_pcm_lib_free_pages(struct snd_pcm_substream *substream);\n\nint snd_pcm_set_managed_buffer(struct snd_pcm_substream *substream, int type,\n\t\t\t       struct device *data, size_t size, size_t max);\nint snd_pcm_set_managed_buffer_all(struct snd_pcm *pcm, int type,\n\t\t\t\t   struct device *data,\n\t\t\t\t   size_t size, size_t max);\n\n \nstatic inline int __must_check\nsnd_pcm_set_fixed_buffer(struct snd_pcm_substream *substream, int type,\n\t\t\t\t struct device *data, size_t size)\n{\n\treturn snd_pcm_set_managed_buffer(substream, type, data, size, 0);\n}\n\n \nstatic inline int __must_check\nsnd_pcm_set_fixed_buffer_all(struct snd_pcm *pcm, int type,\n\t\t\t     struct device *data, size_t size)\n{\n\treturn snd_pcm_set_managed_buffer_all(pcm, type, data, size, 0);\n}\n\nint _snd_pcm_lib_alloc_vmalloc_buffer(struct snd_pcm_substream *substream,\n\t\t\t\t      size_t size, gfp_t gfp_flags);\nint snd_pcm_lib_free_vmalloc_buffer(struct snd_pcm_substream *substream);\nstruct page *snd_pcm_lib_get_vmalloc_page(struct snd_pcm_substream *substream,\n\t\t\t\t\t  unsigned long offset);\n \nstatic inline int snd_pcm_lib_alloc_vmalloc_buffer\n\t\t\t(struct snd_pcm_substream *substream, size_t size)\n{\n\treturn _snd_pcm_lib_alloc_vmalloc_buffer(substream, size,\n\t\t\t\t\t\t GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO);\n}\n\n \nstatic inline int snd_pcm_lib_alloc_vmalloc_32_buffer\n\t\t\t(struct snd_pcm_substream *substream, size_t size)\n{\n\treturn _snd_pcm_lib_alloc_vmalloc_buffer(substream, size,\n\t\t\t\t\t\t GFP_KERNEL | GFP_DMA32 | __GFP_ZERO);\n}\n\n#define snd_pcm_get_dma_buf(substream) ((substream)->runtime->dma_buffer_p)\n\n \nstatic inline dma_addr_t\nsnd_pcm_sgbuf_get_addr(struct snd_pcm_substream *substream, unsigned int ofs)\n{\n\treturn snd_sgbuf_get_addr(snd_pcm_get_dma_buf(substream), ofs);\n}\n\n \nstatic inline unsigned int\nsnd_pcm_sgbuf_get_chunk_size(struct snd_pcm_substream *substream,\n\t\t\t     unsigned int ofs, unsigned int size)\n{\n\treturn snd_sgbuf_get_chunk_size(snd_pcm_get_dma_buf(substream), ofs, size);\n}\n\n \nstatic inline void snd_pcm_mmap_data_open(struct vm_area_struct *area)\n{\n\tstruct snd_pcm_substream *substream = (struct snd_pcm_substream *)area->vm_private_data;\n\tatomic_inc(&substream->mmap_count);\n}\n\n \nstatic inline void snd_pcm_mmap_data_close(struct vm_area_struct *area)\n{\n\tstruct snd_pcm_substream *substream = (struct snd_pcm_substream *)area->vm_private_data;\n\tatomic_dec(&substream->mmap_count);\n}\n\nint snd_pcm_lib_default_mmap(struct snd_pcm_substream *substream,\n\t\t\t     struct vm_area_struct *area);\n \n#if defined(CONFIG_X86) || defined(CONFIG_PPC) || defined(CONFIG_ALPHA)\n#define SNDRV_PCM_INFO_MMAP_IOMEM\tSNDRV_PCM_INFO_MMAP\nint snd_pcm_lib_mmap_iomem(struct snd_pcm_substream *substream, struct vm_area_struct *area);\n#else\n#define SNDRV_PCM_INFO_MMAP_IOMEM\t0\n#define snd_pcm_lib_mmap_iomem\tNULL\n#endif\n\n \nstatic inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)\n{\n\t*max = dma < 4 ? 64 * 1024 : 128 * 1024;\n}\n\n \n\n#define SNDRV_PCM_DEFAULT_CON_SPDIF\t(IEC958_AES0_CON_EMPHASIS_NONE|\\\n\t\t\t\t\t (IEC958_AES1_CON_ORIGINAL<<8)|\\\n\t\t\t\t\t (IEC958_AES1_CON_PCM_CODER<<8)|\\\n\t\t\t\t\t (IEC958_AES3_CON_FS_48000<<24))\n\nconst char *snd_pcm_format_name(snd_pcm_format_t format);\n\n \nstatic inline const char *snd_pcm_direction_name(int direction)\n{\n\tif (direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn \"Playback\";\n\telse\n\t\treturn \"Capture\";\n}\n\n \nstatic inline const char *snd_pcm_stream_str(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_direction_name(substream->stream);\n}\n\n \n \nstruct snd_pcm_chmap_elem {\n\tunsigned char channels;\n\tunsigned char map[15];\n};\n\n \nstruct snd_pcm_chmap {\n\tstruct snd_pcm *pcm;\t \n\tint stream;\t\t \n\tstruct snd_kcontrol *kctl;\n\tconst struct snd_pcm_chmap_elem *chmap;\n\tunsigned int max_channels;\n\tunsigned int channel_mask;\t \n\tvoid *private_data;\t \n};\n\n \nstatic inline struct snd_pcm_substream *\nsnd_pcm_chmap_substream(struct snd_pcm_chmap *info, unsigned int idx)\n{\n\tstruct snd_pcm_substream *s;\n\tfor (s = info->pcm->streams[info->stream].substream; s; s = s->next)\n\t\tif (s->number == idx)\n\t\t\treturn s;\n\treturn NULL;\n}\n\n \nextern const struct snd_pcm_chmap_elem snd_pcm_std_chmaps[];\n \nextern const struct snd_pcm_chmap_elem snd_pcm_alt_chmaps[];\n\n \n#define SND_PCM_CHMAP_MASK_24\t((1U << 2) | (1U << 4))\n#define SND_PCM_CHMAP_MASK_246\t(SND_PCM_CHMAP_MASK_24 | (1U << 6))\n#define SND_PCM_CHMAP_MASK_2468\t(SND_PCM_CHMAP_MASK_246 | (1U << 8))\n\nint snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,\n\t\t\t   const struct snd_pcm_chmap_elem *chmap,\n\t\t\t   int max_channels,\n\t\t\t   unsigned long private_value,\n\t\t\t   struct snd_pcm_chmap **info_ret);\n\n \nstatic inline u64 pcm_format_to_bits(snd_pcm_format_t pcm_format)\n{\n\treturn 1ULL << (__force int) pcm_format;\n}\n\n \n#define pcm_for_each_format(f)\t\t\t\t\t\t\\\n\tfor ((f) = SNDRV_PCM_FORMAT_FIRST;\t\t\t\t\\\n\t     (__force int)(f) <= (__force int)SNDRV_PCM_FORMAT_LAST;\t\\\n\t     (f) = (__force snd_pcm_format_t)((__force int)(f) + 1))\n\n \n#define pcm_err(pcm, fmt, args...) \\\n\tdev_err((pcm)->card->dev, fmt, ##args)\n#define pcm_warn(pcm, fmt, args...) \\\n\tdev_warn((pcm)->card->dev, fmt, ##args)\n#define pcm_dbg(pcm, fmt, args...) \\\n\tdev_dbg((pcm)->card->dev, fmt, ##args)\n\n \nint copy_to_iter_fromio(struct iov_iter *itert, const void __iomem *src,\n\t\t\tsize_t count);\nint copy_from_iter_toio(void __iomem *dst, struct iov_iter *iter, size_t count);\n\nstruct snd_pcm_status64 {\n\tsnd_pcm_state_t state;\t\t \n\tu8 rsvd[4];\n\ts64 trigger_tstamp_sec;\t\t \n\ts64 trigger_tstamp_nsec;\n\ts64 tstamp_sec;\t\t\t \n\ts64 tstamp_nsec;\n\tsnd_pcm_uframes_t appl_ptr;\t \n\tsnd_pcm_uframes_t hw_ptr;\t \n\tsnd_pcm_sframes_t delay;\t \n\tsnd_pcm_uframes_t avail;\t \n\tsnd_pcm_uframes_t avail_max;\t \n\tsnd_pcm_uframes_t overrange;\t \n\tsnd_pcm_state_t suspended_state;  \n\t__u32 audio_tstamp_data;\t  \n\ts64 audio_tstamp_sec;\t\t \n\ts64 audio_tstamp_nsec;\n\ts64 driver_tstamp_sec;\t\t \n\ts64 driver_tstamp_nsec;\n\t__u32 audio_tstamp_accuracy;\t \n\tunsigned char reserved[52-4*sizeof(s64)];  \n};\n\n#define SNDRV_PCM_IOCTL_STATUS64\t_IOR('A', 0x20, struct snd_pcm_status64)\n#define SNDRV_PCM_IOCTL_STATUS_EXT64\t_IOWR('A', 0x24, struct snd_pcm_status64)\n\nstruct snd_pcm_status32 {\n\tsnd_pcm_state_t state;\t\t \n\ts32 trigger_tstamp_sec;\t \n\ts32 trigger_tstamp_nsec;\n\ts32 tstamp_sec;\t\t \n\ts32 tstamp_nsec;\n\tu32 appl_ptr;\t\t \n\tu32 hw_ptr;\t\t \n\ts32 delay;\t\t \n\tu32 avail;\t\t \n\tu32 avail_max;\t\t \n\tu32 overrange;\t\t \n\tsnd_pcm_state_t suspended_state;\t \n\tu32 audio_tstamp_data;\t \n\ts32 audio_tstamp_sec;\t \n\ts32 audio_tstamp_nsec;\n\ts32 driver_tstamp_sec;\t \n\ts32 driver_tstamp_nsec;\n\tu32 audio_tstamp_accuracy;\t \n\tunsigned char reserved[52-4*sizeof(s32)];  \n};\n\n#define SNDRV_PCM_IOCTL_STATUS32\t_IOR('A', 0x20, struct snd_pcm_status32)\n#define SNDRV_PCM_IOCTL_STATUS_EXT32\t_IOWR('A', 0x24, struct snd_pcm_status32)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}