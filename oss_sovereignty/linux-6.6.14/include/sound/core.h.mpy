{
  "module_name": "core.h",
  "hash_id": "8d0a8be4bd314632f60c466bd13a0994cb5c5c6e98ce0d850193b6a569fe317b",
  "original_prompt": "Ingested from linux-6.6.14/include/sound/core.h",
  "human_readable_source": " \n#ifndef __SOUND_CORE_H\n#define __SOUND_CORE_H\n\n \n\n#include <linux/device.h>\n#include <linux/sched.h>\t\t \n#include <linux/mutex.h>\t\t \n#include <linux/rwsem.h>\t\t \n#include <linux/pm.h>\t\t\t \n#include <linux/stringify.h>\n#include <linux/printk.h>\n#include <linux/xarray.h>\n\n \n#ifdef CONFIG_SND_DYNAMIC_MINORS\n#define SNDRV_CARDS CONFIG_SND_MAX_CARDS\n#else\n#define SNDRV_CARDS 8\t\t \n#endif\n\n#define CONFIG_SND_MAJOR\t116\t \n\n \nstruct pci_dev;\nstruct module;\nstruct completion;\n\n \n\n \nenum snd_device_type {\n\tSNDRV_DEV_LOWLEVEL,\n\tSNDRV_DEV_INFO,\n\tSNDRV_DEV_BUS,\n\tSNDRV_DEV_CODEC,\n\tSNDRV_DEV_PCM,\n\tSNDRV_DEV_COMPRESS,\n\tSNDRV_DEV_RAWMIDI,\n\tSNDRV_DEV_TIMER,\n\tSNDRV_DEV_SEQUENCER,\n\tSNDRV_DEV_HWDEP,\n\tSNDRV_DEV_JACK,\n\tSNDRV_DEV_CONTROL,\t \n};\n\nenum snd_device_state {\n\tSNDRV_DEV_BUILD,\n\tSNDRV_DEV_REGISTERED,\n\tSNDRV_DEV_DISCONNECTED,\n};\n\nstruct snd_device;\n\nstruct snd_device_ops {\n\tint (*dev_free)(struct snd_device *dev);\n\tint (*dev_register)(struct snd_device *dev);\n\tint (*dev_disconnect)(struct snd_device *dev);\n};\n\nstruct snd_device {\n\tstruct list_head list;\t\t \n\tstruct snd_card *card;\t\t \n\tenum snd_device_state state;\t \n\tenum snd_device_type type;\t \n\tvoid *device_data;\t\t \n\tconst struct snd_device_ops *ops;\t \n};\n\n#define snd_device(n) list_entry(n, struct snd_device, list)\n\n \n\nstruct snd_card {\n\tint number;\t\t\t \n\n\tchar id[16];\t\t\t \n\tchar driver[16];\t\t \n\tchar shortname[32];\t\t \n\tchar longname[80];\t\t \n\tchar irq_descr[32];\t\t \n\tchar mixername[80];\t\t \n\tchar components[128];\t\t \n\tstruct module *module;\t\t \n\n\tvoid *private_data;\t\t \n\tvoid (*private_free) (struct snd_card *card);  \n\tstruct list_head devices;\t \n\n\tstruct device *ctl_dev;\t\t \n\tunsigned int last_numid;\t \n\tstruct rw_semaphore controls_rwsem;\t \n\trwlock_t ctl_files_rwlock;\t \n\tint controls_count;\t\t \n\tsize_t user_ctl_alloc_size;\t\n\tstruct list_head controls;\t \n\tstruct list_head ctl_files;\t \n#ifdef CONFIG_SND_CTL_FAST_LOOKUP\n\tstruct xarray ctl_numids;\t \n\tstruct xarray ctl_hash;\t\t \n\tbool ctl_hash_collision;\t \n#endif\n\n\tstruct snd_info_entry *proc_root;\t \n\tstruct proc_dir_entry *proc_root_link;\t \n\n\tstruct list_head files_list;\t \n\tstruct snd_shutdown_f_ops *s_f_ops;  \n\tspinlock_t files_lock;\t\t \n\tint shutdown;\t\t\t \n\tstruct completion *release_completion;\n\tstruct device *dev;\t\t \n\tstruct device card_dev;\t\t \n\tconst struct attribute_group *dev_groups[4];  \n\tbool registered;\t\t \n\tbool managed;\t\t\t \n\tbool releasing;\t\t\t \n\tint sync_irq;\t\t\t \n\twait_queue_head_t remove_sleep;\n\n\tsize_t total_pcm_alloc_bytes;\t \n\tstruct mutex memory_mutex;\t \n#ifdef CONFIG_SND_DEBUG\n\tstruct dentry *debugfs_root;     \n#endif\n\n#ifdef CONFIG_PM\n\tunsigned int power_state;\t \n\tatomic_t power_ref;\n\twait_queue_head_t power_sleep;\n\twait_queue_head_t power_ref_sleep;\n#endif\n\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tstruct snd_mixer_oss *mixer_oss;\n\tint mixer_oss_change_count;\n#endif\n};\n\n#define dev_to_snd_card(p)\tcontainer_of(p, struct snd_card, card_dev)\n\n#ifdef CONFIG_PM\nstatic inline unsigned int snd_power_get_state(struct snd_card *card)\n{\n\treturn READ_ONCE(card->power_state);\n}\n\nstatic inline void snd_power_change_state(struct snd_card *card, unsigned int state)\n{\n\tWRITE_ONCE(card->power_state, state);\n\twake_up(&card->power_sleep);\n}\n\n \nstatic inline void snd_power_ref(struct snd_card *card)\n{\n\tatomic_inc(&card->power_ref);\n}\n\n \nstatic inline void snd_power_unref(struct snd_card *card)\n{\n\tif (atomic_dec_and_test(&card->power_ref))\n\t\twake_up(&card->power_ref_sleep);\n}\n\n \nstatic inline void snd_power_sync_ref(struct snd_card *card)\n{\n\twait_event(card->power_ref_sleep, !atomic_read(&card->power_ref));\n}\n\n \nint snd_power_wait(struct snd_card *card);\nint snd_power_ref_and_wait(struct snd_card *card);\n\n#else  \n\nstatic inline int snd_power_wait(struct snd_card *card) { return 0; }\nstatic inline void snd_power_ref(struct snd_card *card) {}\nstatic inline void snd_power_unref(struct snd_card *card) {}\nstatic inline int snd_power_ref_and_wait(struct snd_card *card) { return 0; }\nstatic inline void snd_power_sync_ref(struct snd_card *card) {}\n#define snd_power_get_state(card)\t({ (void)(card); SNDRV_CTL_POWER_D0; })\n#define snd_power_change_state(card, state)\tdo { (void)(card); } while (0)\n\n#endif  \n\nstruct snd_minor {\n\tint type;\t\t\t \n\tint card;\t\t\t \n\tint device;\t\t\t \n\tconst struct file_operations *f_ops;\t \n\tvoid *private_data;\t\t \n\tstruct device *dev;\t\t \n\tstruct snd_card *card_ptr;\t \n};\n\n \nstatic inline struct device *snd_card_get_device_link(struct snd_card *card)\n{\n\treturn card ? &card->card_dev : NULL;\n}\n\n \n\nextern int snd_major;\nextern int snd_ecards_limit;\nextern const struct class sound_class;\n#ifdef CONFIG_SND_DEBUG\nextern struct dentry *sound_debugfs_root;\n#endif\n\nvoid snd_request_card(int card);\n\nint snd_device_alloc(struct device **dev_p, struct snd_card *card);\n\nint snd_register_device(int type, struct snd_card *card, int dev,\n\t\t\tconst struct file_operations *f_ops,\n\t\t\tvoid *private_data, struct device *device);\nint snd_unregister_device(struct device *dev);\nvoid *snd_lookup_minor_data(unsigned int minor, int type);\n\n#ifdef CONFIG_SND_OSSEMUL\nint snd_register_oss_device(int type, struct snd_card *card, int dev,\n\t\t\t    const struct file_operations *f_ops, void *private_data);\nint snd_unregister_oss_device(int type, struct snd_card *card, int dev);\nvoid *snd_lookup_oss_minor_data(unsigned int minor, int type);\n#endif\n\nint snd_minor_info_init(void);\n\n \n\n#ifdef CONFIG_SND_OSSEMUL\nint snd_minor_info_oss_init(void);\n#else\nstatic inline int snd_minor_info_oss_init(void) { return 0; }\n#endif\n\n \n\nint copy_to_user_fromio(void __user *dst, const volatile void __iomem *src, size_t count);\nint copy_from_user_toio(volatile void __iomem *dst, const void __user *src, size_t count);\n\n \n\nint snd_card_locked(int card);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n#define SND_MIXER_OSS_NOTIFY_REGISTER\t0\n#define SND_MIXER_OSS_NOTIFY_DISCONNECT\t1\n#define SND_MIXER_OSS_NOTIFY_FREE\t2\nextern int (*snd_mixer_oss_notify_callback)(struct snd_card *card, int cmd);\n#endif\n\nint snd_card_new(struct device *parent, int idx, const char *xid,\n\t\t struct module *module, int extra_size,\n\t\t struct snd_card **card_ret);\nint snd_devm_card_new(struct device *parent, int idx, const char *xid,\n\t\t      struct module *module, size_t extra_size,\n\t\t      struct snd_card **card_ret);\n\nvoid snd_card_disconnect(struct snd_card *card);\nvoid snd_card_disconnect_sync(struct snd_card *card);\nvoid snd_card_free(struct snd_card *card);\nvoid snd_card_free_when_closed(struct snd_card *card);\nint snd_card_free_on_error(struct device *dev, int ret);\nvoid snd_card_set_id(struct snd_card *card, const char *id);\nint snd_card_register(struct snd_card *card);\nint snd_card_info_init(void);\nint snd_card_add_dev_attr(struct snd_card *card,\n\t\t\t  const struct attribute_group *group);\nint snd_component_add(struct snd_card *card, const char *component);\nint snd_card_file_add(struct snd_card *card, struct file *file);\nint snd_card_file_remove(struct snd_card *card, struct file *file);\n\nstruct snd_card *snd_card_ref(int card);\n\n \nstatic inline void snd_card_unref(struct snd_card *card)\n{\n\tput_device(&card->card_dev);\n}\n\n#define snd_card_set_dev(card, devptr) ((card)->dev = (devptr))\n\n \n\nint snd_device_new(struct snd_card *card, enum snd_device_type type,\n\t\t   void *device_data, const struct snd_device_ops *ops);\nint snd_device_register(struct snd_card *card, void *device_data);\nint snd_device_register_all(struct snd_card *card);\nvoid snd_device_disconnect(struct snd_card *card, void *device_data);\nvoid snd_device_disconnect_all(struct snd_card *card);\nvoid snd_device_free(struct snd_card *card, void *device_data);\nvoid snd_device_free_all(struct snd_card *card);\nint snd_device_get_state(struct snd_card *card, void *device_data);\n\n \n\n#ifdef CONFIG_ISA_DMA_API\n#define DMA_MODE_NO_ENABLE\t0x0100\n\nvoid snd_dma_program(unsigned long dma, unsigned long addr, unsigned int size, unsigned short mode);\nvoid snd_dma_disable(unsigned long dma);\nunsigned int snd_dma_pointer(unsigned long dma, unsigned int size);\nint snd_devm_request_dma(struct device *dev, int dma, const char *name);\n#endif\n\n \nstruct resource;\nvoid release_and_free_resource(struct resource *res);\n\n \n\n \nenum {\n\tSND_PR_ALWAYS,\n\tSND_PR_DEBUG,\n\tSND_PR_VERBOSE,\n};\n\n#if defined(CONFIG_SND_DEBUG) || defined(CONFIG_SND_VERBOSE_PRINTK)\n__printf(4, 5)\nvoid __snd_printk(unsigned int level, const char *file, int line,\n\t\t  const char *format, ...);\n#else\n#define __snd_printk(level, file, line, format, ...) \\\n\tprintk(format, ##__VA_ARGS__)\n#endif\n\n \n#define snd_printk(fmt, ...) \\\n\t__snd_printk(0, __FILE__, __LINE__, fmt, ##__VA_ARGS__)\n\n#ifdef CONFIG_SND_DEBUG\n \n#define snd_printd(fmt, ...) \\\n\t__snd_printk(1, __FILE__, __LINE__, fmt, ##__VA_ARGS__)\n#define _snd_printd(level, fmt, ...) \\\n\t__snd_printk(level, __FILE__, __LINE__, fmt, ##__VA_ARGS__)\n\n \n#define snd_BUG()\t\tWARN(1, \"BUG?\\n\")\n\n \n#define snd_printd_ratelimit() printk_ratelimit()\n\n \n#define snd_BUG_ON(cond)\tWARN_ON((cond))\n\n#else  \n\n__printf(1, 2)\nstatic inline void snd_printd(const char *format, ...) {}\n__printf(2, 3)\nstatic inline void _snd_printd(int level, const char *format, ...) {}\n\n#define snd_BUG()\t\t\tdo { } while (0)\n\n#define snd_BUG_ON(condition) ({ \\\n\tint __ret_warn_on = !!(condition); \\\n\tunlikely(__ret_warn_on); \\\n})\n\nstatic inline bool snd_printd_ratelimit(void) { return false; }\n\n#endif  \n\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n \n#define snd_printdd(format, ...) \\\n\t__snd_printk(2, __FILE__, __LINE__, format, ##__VA_ARGS__)\n#else\n__printf(1, 2)\nstatic inline void snd_printdd(const char *format, ...) {}\n#endif\n\n\n#define SNDRV_OSS_VERSION         ((3<<16)|(8<<8)|(1<<4)|(0))\t \n\n \n#if IS_ENABLED(CONFIG_GAMEPORT)\n#define gameport_set_dev_parent(gp,xdev) ((gp)->dev.parent = (xdev))\n#define gameport_set_port_data(gp,r) ((gp)->port_data = (r))\n#define gameport_get_port_data(gp) (gp)->port_data\n#endif\n\n \nstruct snd_pci_quirk {\n\tunsigned short subvendor;\t \n\tunsigned short subdevice;\t \n\tunsigned short subdevice_mask;\t \n\tint value;\t\t\t \n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tconst char *name;\t\t \n#endif\n};\n\n#define _SND_PCI_QUIRK_ID_MASK(vend, mask, dev)\t\\\n\t.subvendor = (vend), .subdevice = (dev), .subdevice_mask = (mask)\n#define _SND_PCI_QUIRK_ID(vend, dev) \\\n\t_SND_PCI_QUIRK_ID_MASK(vend, 0xffff, dev)\n#define SND_PCI_QUIRK_ID(vend,dev) {_SND_PCI_QUIRK_ID(vend, dev)}\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n#define SND_PCI_QUIRK(vend,dev,xname,val) \\\n\t{_SND_PCI_QUIRK_ID(vend, dev), .value = (val), .name = (xname)}\n#define SND_PCI_QUIRK_VENDOR(vend, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, 0, 0), .value = (val), .name = (xname)}\n#define SND_PCI_QUIRK_MASK(vend, mask, dev, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, mask, dev),\t\t\t\\\n\t\t\t.value = (val), .name = (xname)}\n#define snd_pci_quirk_name(q)\t((q)->name)\n#else\n#define SND_PCI_QUIRK(vend,dev,xname,val) \\\n\t{_SND_PCI_QUIRK_ID(vend, dev), .value = (val)}\n#define SND_PCI_QUIRK_MASK(vend, mask, dev, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, mask, dev), .value = (val)}\n#define SND_PCI_QUIRK_VENDOR(vend, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, 0, 0), .value = (val)}\n#define snd_pci_quirk_name(q)\t\"\"\n#endif\n\n#ifdef CONFIG_PCI\nconst struct snd_pci_quirk *\nsnd_pci_quirk_lookup(struct pci_dev *pci, const struct snd_pci_quirk *list);\n\nconst struct snd_pci_quirk *\nsnd_pci_quirk_lookup_id(u16 vendor, u16 device,\n\t\t\tconst struct snd_pci_quirk *list);\n#else\nstatic inline const struct snd_pci_quirk *\nsnd_pci_quirk_lookup(struct pci_dev *pci, const struct snd_pci_quirk *list)\n{\n\treturn NULL;\n}\n\nstatic inline const struct snd_pci_quirk *\nsnd_pci_quirk_lookup_id(u16 vendor, u16 device,\n\t\t\tconst struct snd_pci_quirk *list)\n{\n\treturn NULL;\n}\n#endif\n\n \nstruct snd_fasync;\n\nint snd_fasync_helper(int fd, struct file *file, int on,\n\t\t      struct snd_fasync **fasyncp);\nvoid snd_kill_fasync(struct snd_fasync *fasync, int signal, int poll);\nvoid snd_fasync_free(struct snd_fasync *fasync);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}