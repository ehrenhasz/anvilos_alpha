{
  "module_name": "soc.h",
  "hash_id": "2bcc6a0e49a295d0035a82e7d85ba0ed3ecf8475b485d62e3707380695c99297",
  "original_prompt": "Ingested from linux-6.6.14/include/sound/soc.h",
  "human_readable_source": " \n\n#ifndef __LINUX_SND_SOC_H\n#define __LINUX_SND_SOC_H\n\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/notifier.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/regmap.h>\n#include <linux/log2.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/compress_driver.h>\n#include <sound/control.h>\n#include <sound/ac97_codec.h>\n\n \n#define SOC_DOUBLE_VALUE(xreg, shift_left, shift_right, xmax, xinvert, xautodisable) \\\n\t((unsigned long)&(struct soc_mixer_control) \\\n\t{.reg = xreg, .rreg = xreg, .shift = shift_left, \\\n\t.rshift = shift_right, .max = xmax, \\\n\t.invert = xinvert, .autodisable = xautodisable})\n#define SOC_DOUBLE_S_VALUE(xreg, shift_left, shift_right, xmin, xmax, xsign_bit, xinvert, xautodisable) \\\n\t((unsigned long)&(struct soc_mixer_control) \\\n\t{.reg = xreg, .rreg = xreg, .shift = shift_left, \\\n\t.rshift = shift_right, .min = xmin, .max = xmax, \\\n\t.sign_bit = xsign_bit, .invert = xinvert, .autodisable = xautodisable})\n#define SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert, xautodisable) \\\n\tSOC_DOUBLE_VALUE(xreg, xshift, xshift, xmax, xinvert, xautodisable)\n#define SOC_SINGLE_VALUE_EXT(xreg, xmax, xinvert) \\\n\t((unsigned long)&(struct soc_mixer_control) \\\n\t{.reg = xreg, .max = xmax, .invert = xinvert})\n#define SOC_DOUBLE_R_VALUE(xlreg, xrreg, xshift, xmax, xinvert) \\\n\t((unsigned long)&(struct soc_mixer_control) \\\n\t{.reg = xlreg, .rreg = xrreg, .shift = xshift, .rshift = xshift, \\\n\t.max = xmax, .invert = xinvert})\n#define SOC_DOUBLE_R_S_VALUE(xlreg, xrreg, xshift, xmin, xmax, xsign_bit, xinvert) \\\n\t((unsigned long)&(struct soc_mixer_control) \\\n\t{.reg = xlreg, .rreg = xrreg, .shift = xshift, .rshift = xshift, \\\n\t.max = xmax, .min = xmin, .sign_bit = xsign_bit, \\\n\t.invert = xinvert})\n#define SOC_DOUBLE_R_RANGE_VALUE(xlreg, xrreg, xshift, xmin, xmax, xinvert) \\\n\t((unsigned long)&(struct soc_mixer_control) \\\n\t{.reg = xlreg, .rreg = xrreg, .shift = xshift, .rshift = xshift, \\\n\t.min = xmin, .max = xmax, .invert = xinvert})\n#define SOC_SINGLE(xname, reg, shift, max, invert) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\\\n\t.put = snd_soc_put_volsw, \\\n\t.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) }\n#define SOC_SINGLE_RANGE(xname, xreg, xshift, xmin, xmax, xinvert) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\\\n\t.info = snd_soc_info_volsw_range, .get = snd_soc_get_volsw_range, \\\n\t.put = snd_soc_put_volsw_range, \\\n\t.private_value = (unsigned long)&(struct soc_mixer_control) \\\n\t\t{.reg = xreg, .rreg = xreg, .shift = xshift, \\\n\t\t .rshift = xshift,  .min = xmin, .max = xmax, \\\n\t\t .invert = xinvert} }\n#define SOC_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\\\n\t.put = snd_soc_put_volsw, \\\n\t.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) }\n#define SOC_SINGLE_SX_TLV(xname, xreg, xshift, xmin, xmax, tlv_array) \\\n{       .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\tSNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p  = (tlv_array),\\\n\t.info = snd_soc_info_volsw_sx, \\\n\t.get = snd_soc_get_volsw_sx,\\\n\t.put = snd_soc_put_volsw_sx, \\\n\t.private_value = (unsigned long)&(struct soc_mixer_control) \\\n\t\t{.reg = xreg, .rreg = xreg, \\\n\t\t.shift = xshift, .rshift = xshift, \\\n\t\t.max = xmax, .min = xmin} }\n#define SOC_SINGLE_RANGE_TLV(xname, xreg, xshift, xmin, xmax, xinvert, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw_range, \\\n\t.get = snd_soc_get_volsw_range, .put = snd_soc_put_volsw_range, \\\n\t.private_value = (unsigned long)&(struct soc_mixer_control) \\\n\t\t{.reg = xreg, .rreg = xreg, .shift = xshift, \\\n\t\t .rshift = xshift, .min = xmin, .max = xmax, \\\n\t\t .invert = xinvert} }\n#define SOC_DOUBLE(xname, reg, shift_left, shift_right, max, invert) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\\\n\t.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \\\n\t.put = snd_soc_put_volsw, \\\n\t.private_value = SOC_DOUBLE_VALUE(reg, shift_left, shift_right, \\\n\t\t\t\t\t  max, invert, 0) }\n#define SOC_DOUBLE_STS(xname, reg, shift_left, shift_right, max, invert) \\\n{\t\t\t\t\t\t\t\t\t\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\t\t\\\n\t.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\t\t\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\t\t\t\t\\\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\t\t\t\t\\\n\t.private_value = SOC_DOUBLE_VALUE(reg, shift_left, shift_right,\t\\\n\t\t\t\t\t  max, invert, 0) }\n#define SOC_DOUBLE_R(xname, reg_left, reg_right, xshift, xmax, xinvert) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = snd_soc_get_volsw, .put = snd_soc_put_volsw, \\\n\t.private_value = SOC_DOUBLE_R_VALUE(reg_left, reg_right, xshift, \\\n\t\t\t\t\t    xmax, xinvert) }\n#define SOC_DOUBLE_R_RANGE(xname, reg_left, reg_right, xshift, xmin, \\\n\t\t\t   xmax, xinvert)\t\t\\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\\\n\t.info = snd_soc_info_volsw_range, \\\n\t.get = snd_soc_get_volsw_range, .put = snd_soc_put_volsw_range, \\\n\t.private_value = SOC_DOUBLE_R_RANGE_VALUE(reg_left, reg_right, \\\n\t\t\t\t\t    xshift, xmin, xmax, xinvert) }\n#define SOC_DOUBLE_TLV(xname, reg, shift_left, shift_right, max, invert, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \\\n\t.put = snd_soc_put_volsw, \\\n\t.private_value = SOC_DOUBLE_VALUE(reg, shift_left, shift_right, \\\n\t\t\t\t\t  max, invert, 0) }\n#define SOC_DOUBLE_SX_TLV(xname, xreg, shift_left, shift_right, xmin, xmax, tlv_array) \\\n{       .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\tSNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p  = (tlv_array), \\\n\t.info = snd_soc_info_volsw_sx, \\\n\t.get = snd_soc_get_volsw_sx, \\\n\t.put = snd_soc_put_volsw_sx, \\\n\t.private_value = (unsigned long)&(struct soc_mixer_control) \\\n\t\t{.reg = xreg, .rreg = xreg, \\\n\t\t.shift = shift_left, .rshift = shift_right, \\\n\t\t.max = xmax, .min = xmin} }\n#define SOC_DOUBLE_R_TLV(xname, reg_left, reg_right, xshift, xmax, xinvert, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = snd_soc_get_volsw, .put = snd_soc_put_volsw, \\\n\t.private_value = SOC_DOUBLE_R_VALUE(reg_left, reg_right, xshift, \\\n\t\t\t\t\t    xmax, xinvert) }\n#define SOC_DOUBLE_R_RANGE_TLV(xname, reg_left, reg_right, xshift, xmin, \\\n\t\t\t       xmax, xinvert, tlv_array)\t\t\\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw_range, \\\n\t.get = snd_soc_get_volsw_range, .put = snd_soc_put_volsw_range, \\\n\t.private_value = SOC_DOUBLE_R_RANGE_VALUE(reg_left, reg_right, \\\n\t\t\t\t\t    xshift, xmin, xmax, xinvert) }\n#define SOC_DOUBLE_R_SX_TLV(xname, xreg, xrreg, xshift, xmin, xmax, tlv_array) \\\n{       .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\tSNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p  = (tlv_array), \\\n\t.info = snd_soc_info_volsw_sx, \\\n\t.get = snd_soc_get_volsw_sx, \\\n\t.put = snd_soc_put_volsw_sx, \\\n\t.private_value = (unsigned long)&(struct soc_mixer_control) \\\n\t\t{.reg = xreg, .rreg = xrreg, \\\n\t\t.shift = xshift, .rshift = xshift, \\\n\t\t.max = xmax, .min = xmin} }\n#define SOC_DOUBLE_R_S_TLV(xname, reg_left, reg_right, xshift, xmin, xmax, xsign_bit, xinvert, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = snd_soc_get_volsw, .put = snd_soc_put_volsw, \\\n\t.private_value = SOC_DOUBLE_R_S_VALUE(reg_left, reg_right, xshift, \\\n\t\t\t\t\t    xmin, xmax, xsign_bit, xinvert) }\n#define SOC_SINGLE_S_TLV(xname, xreg, xshift, xmin, xmax, xsign_bit, xinvert, tlv_array) \\\n\tSOC_DOUBLE_R_S_TLV(xname, xreg, xreg, xshift, xmin, xmax, xsign_bit, xinvert, tlv_array)\n#define SOC_SINGLE_S8_TLV(xname, xreg, xmin, xmax, tlv_array) \\\n{\t.iface  = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t  SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p  = (tlv_array), \\\n\t.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\\\n\t.put = snd_soc_put_volsw, \\\n\t.private_value = (unsigned long)&(struct soc_mixer_control) \\\n\t{.reg = xreg, .rreg = xreg,  \\\n\t .min = xmin, .max = xmax, \\\n\t.sign_bit = 7,} }\n#define SOC_DOUBLE_S8_TLV(xname, xreg, xmin, xmax, tlv_array) \\\n{\t.iface  = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t  SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p  = (tlv_array), \\\n\t.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\\\n\t.put = snd_soc_put_volsw, \\\n\t.private_value = SOC_DOUBLE_S_VALUE(xreg, 0, 8, xmin, xmax, 7, 0, 0) }\n#define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xitems, xtexts) \\\n{\t.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \\\n\t.items = xitems, .texts = xtexts, \\\n\t.mask = xitems ? roundup_pow_of_two(xitems) - 1 : 0}\n#define SOC_ENUM_SINGLE(xreg, xshift, xitems, xtexts) \\\n\tSOC_ENUM_DOUBLE(xreg, xshift, xshift, xitems, xtexts)\n#define SOC_ENUM_SINGLE_EXT(xitems, xtexts) \\\n{\t.items = xitems, .texts = xtexts }\n#define SOC_VALUE_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, xitems, xtexts, xvalues) \\\n{\t.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \\\n\t.mask = xmask, .items = xitems, .texts = xtexts, .values = xvalues}\n#define SOC_VALUE_ENUM_SINGLE(xreg, xshift, xmask, xitems, xtexts, xvalues) \\\n\tSOC_VALUE_ENUM_DOUBLE(xreg, xshift, xshift, xmask, xitems, xtexts, xvalues)\n#define SOC_VALUE_ENUM_SINGLE_AUTODISABLE(xreg, xshift, xmask, xitems, xtexts, xvalues) \\\n{\t.reg = xreg, .shift_l = xshift, .shift_r = xshift, \\\n\t.mask = xmask, .items = xitems, .texts = xtexts, \\\n\t.values = xvalues, .autodisable = 1}\n#define SOC_ENUM_SINGLE_VIRT(xitems, xtexts) \\\n\tSOC_ENUM_SINGLE(SND_SOC_NOPM, 0, xitems, xtexts)\n#define SOC_ENUM(xname, xenum) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\\\n\t.info = snd_soc_info_enum_double, \\\n\t.get = snd_soc_get_enum_double, .put = snd_soc_put_enum_double, \\\n\t.private_value = (unsigned long)&xenum }\n#define SOC_SINGLE_EXT(xname, xreg, xshift, xmax, xinvert,\\\n\t xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert, 0) }\n#define SOC_DOUBLE_EXT(xname, reg, shift_left, shift_right, max, invert,\\\n\t xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\\\n\t.info = snd_soc_info_volsw, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = \\\n\t\tSOC_DOUBLE_VALUE(reg, shift_left, shift_right, max, invert, 0) }\n#define SOC_DOUBLE_R_EXT(xname, reg_left, reg_right, xshift, xmax, xinvert,\\\n\t xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = SOC_DOUBLE_R_VALUE(reg_left, reg_right, xshift, \\\n\t\t\t\t\t    xmax, xinvert) }\n#define SOC_SINGLE_EXT_TLV(xname, xreg, xshift, xmax, xinvert,\\\n\t xhandler_get, xhandler_put, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert, 0) }\n#define SOC_SINGLE_RANGE_EXT_TLV(xname, xreg, xshift, xmin, xmax, xinvert, \\\n\t\t\t\t xhandler_get, xhandler_put, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw_range, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = (unsigned long)&(struct soc_mixer_control) \\\n\t\t{.reg = xreg, .rreg = xreg, .shift = xshift, \\\n\t\t .rshift = xshift, .min = xmin, .max = xmax, \\\n\t\t .invert = xinvert} }\n#define SOC_DOUBLE_EXT_TLV(xname, xreg, shift_left, shift_right, xmax, xinvert,\\\n\t xhandler_get, xhandler_put, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = SOC_DOUBLE_VALUE(xreg, shift_left, shift_right, \\\n\t\t\t\t\t  xmax, xinvert, 0) }\n#define SOC_DOUBLE_R_EXT_TLV(xname, reg_left, reg_right, xshift, xmax, xinvert,\\\n\t xhandler_get, xhandler_put, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = SOC_DOUBLE_R_VALUE(reg_left, reg_right, xshift, \\\n\t\t\t\t\t    xmax, xinvert) }\n#define SOC_DOUBLE_R_S_EXT_TLV(xname, reg_left, reg_right, xshift, xmin, xmax, \\\n\t\t\t       xsign_bit, xinvert, xhandler_get, xhandler_put, \\\n\t\t\t       tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t  SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = SOC_DOUBLE_R_S_VALUE(reg_left, reg_right, xshift, \\\n\t\t\t\t\t      xmin, xmax, xsign_bit, xinvert) }\n#define SOC_SINGLE_S_EXT_TLV(xname, xreg, xshift, xmin, xmax, \\\n\t\t\t     xsign_bit, xinvert, xhandler_get, xhandler_put, \\\n\t\t\t     tlv_array) \\\n\tSOC_DOUBLE_R_S_EXT_TLV(xname, xreg, xreg, xshift, xmin, xmax, \\\n\t\t\t       xsign_bit, xinvert, xhandler_get, xhandler_put, \\\n\t\t\t       tlv_array)\n#define SOC_SINGLE_BOOL_EXT(xname, xdata, xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = snd_soc_info_bool_ext, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = xdata }\n#define SOC_ENUM_EXT(xname, xenum, xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = snd_soc_info_enum_double, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = (unsigned long)&xenum }\n#define SOC_VALUE_ENUM_EXT(xname, xenum, xhandler_get, xhandler_put) \\\n\tSOC_ENUM_EXT(xname, xenum, xhandler_get, xhandler_put)\n\n#define SND_SOC_BYTES(xname, xbase, xregs)\t\t      \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,   \\\n\t.info = snd_soc_bytes_info, .get = snd_soc_bytes_get, \\\n\t.put = snd_soc_bytes_put, .private_value =\t      \\\n\t\t((unsigned long)&(struct soc_bytes)           \\\n\t\t{.base = xbase, .num_regs = xregs }) }\n#define SND_SOC_BYTES_E(xname, xbase, xregs, xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = snd_soc_bytes_info, .get = xhandler_get, \\\n\t.put = xhandler_put, .private_value = \\\n\t\t((unsigned long)&(struct soc_bytes) \\\n\t\t{.base = xbase, .num_regs = xregs }) }\n\n#define SND_SOC_BYTES_MASK(xname, xbase, xregs, xmask)\t      \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,   \\\n\t.info = snd_soc_bytes_info, .get = snd_soc_bytes_get, \\\n\t.put = snd_soc_bytes_put, .private_value =\t      \\\n\t\t((unsigned long)&(struct soc_bytes)           \\\n\t\t{.base = xbase, .num_regs = xregs,\t      \\\n\t\t .mask = xmask }) }\n\n \n#define SND_SOC_BYTES_EXT(xname, xcount, xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = snd_soc_bytes_info_ext, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = (unsigned long)&(struct soc_bytes_ext) \\\n\t\t{.max = xcount} }\n#define SND_SOC_BYTES_TLV(xname, xcount, xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE | \\\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK, \\\n\t.tlv.c = (snd_soc_bytes_tlv_callback), \\\n\t.info = snd_soc_bytes_info_ext, \\\n\t.private_value = (unsigned long)&(struct soc_bytes_ext) \\\n\t\t{.max = xcount, .get = xhandler_get, .put = xhandler_put, } }\n#define SOC_SINGLE_XR_SX(xname, xregbase, xregcount, xnbits, \\\n\t\txmin, xmax, xinvert) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.info = snd_soc_info_xr_sx, .get = snd_soc_get_xr_sx, \\\n\t.put = snd_soc_put_xr_sx, \\\n\t.private_value = (unsigned long)&(struct soc_mreg_control) \\\n\t\t{.regbase = xregbase, .regcount = xregcount, .nbits = xnbits, \\\n\t\t.invert = xinvert, .min = xmin, .max = xmax} }\n\n#define SOC_SINGLE_STROBE(xname, xreg, xshift, xinvert) \\\n\tSOC_SINGLE_EXT(xname, xreg, xshift, 1, xinvert, \\\n\t\tsnd_soc_get_strobe, snd_soc_put_strobe)\n\n \n#define SOC_ENUM_DOUBLE_DECL(name, xreg, xshift_l, xshift_r, xtexts) \\\n\tconst struct soc_enum name = SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, \\\n\t\t\t\t\t\tARRAY_SIZE(xtexts), xtexts)\n#define SOC_ENUM_SINGLE_DECL(name, xreg, xshift, xtexts) \\\n\tSOC_ENUM_DOUBLE_DECL(name, xreg, xshift, xshift, xtexts)\n#define SOC_ENUM_SINGLE_EXT_DECL(name, xtexts) \\\n\tconst struct soc_enum name = SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(xtexts), xtexts)\n#define SOC_VALUE_ENUM_DOUBLE_DECL(name, xreg, xshift_l, xshift_r, xmask, xtexts, xvalues) \\\n\tconst struct soc_enum name = SOC_VALUE_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, \\\n\t\t\t\t\t\t\tARRAY_SIZE(xtexts), xtexts, xvalues)\n#define SOC_VALUE_ENUM_SINGLE_DECL(name, xreg, xshift, xmask, xtexts, xvalues) \\\n\tSOC_VALUE_ENUM_DOUBLE_DECL(name, xreg, xshift, xshift, xmask, xtexts, xvalues)\n\n#define SOC_VALUE_ENUM_SINGLE_AUTODISABLE_DECL(name, xreg, xshift, xmask, xtexts, xvalues) \\\n\tconst struct soc_enum name = SOC_VALUE_ENUM_SINGLE_AUTODISABLE(xreg, \\\n\t\txshift, xmask, ARRAY_SIZE(xtexts), xtexts, xvalues)\n\n#define SOC_ENUM_SINGLE_VIRT_DECL(name, xtexts) \\\n\tconst struct soc_enum name = SOC_ENUM_SINGLE_VIRT(ARRAY_SIZE(xtexts), xtexts)\n\nstruct device_node;\nstruct snd_jack;\nstruct snd_soc_card;\nstruct snd_soc_pcm_stream;\nstruct snd_soc_ops;\nstruct snd_soc_pcm_runtime;\nstruct snd_soc_dai;\nstruct snd_soc_dai_driver;\nstruct snd_soc_dai_link;\nstruct snd_soc_component;\nstruct snd_soc_component_driver;\nstruct soc_enum;\nstruct snd_soc_jack;\nstruct snd_soc_jack_zone;\nstruct snd_soc_jack_pin;\n#include <sound/soc-dapm.h>\n#include <sound/soc-dpcm.h>\n#include <sound/soc-topology.h>\n\nstruct snd_soc_jack_gpio;\n\nenum snd_soc_pcm_subclass {\n\tSND_SOC_PCM_CLASS_PCM\t= 0,\n\tSND_SOC_PCM_CLASS_BE\t= 1,\n};\n\nint snd_soc_register_card(struct snd_soc_card *card);\nvoid snd_soc_unregister_card(struct snd_soc_card *card);\nint devm_snd_soc_register_card(struct device *dev, struct snd_soc_card *card);\n#ifdef CONFIG_PM_SLEEP\nint snd_soc_suspend(struct device *dev);\nint snd_soc_resume(struct device *dev);\n#else\nstatic inline int snd_soc_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic inline int snd_soc_resume(struct device *dev)\n{\n\treturn 0;\n}\n#endif\nint snd_soc_poweroff(struct device *dev);\nint snd_soc_component_initialize(struct snd_soc_component *component,\n\t\t\t\t const struct snd_soc_component_driver *driver,\n\t\t\t\t struct device *dev);\nint snd_soc_add_component(struct snd_soc_component *component,\n\t\t\t  struct snd_soc_dai_driver *dai_drv,\n\t\t\t  int num_dai);\nint snd_soc_register_component(struct device *dev,\n\t\t\t const struct snd_soc_component_driver *component_driver,\n\t\t\t struct snd_soc_dai_driver *dai_drv, int num_dai);\nint devm_snd_soc_register_component(struct device *dev,\n\t\t\t const struct snd_soc_component_driver *component_driver,\n\t\t\t struct snd_soc_dai_driver *dai_drv, int num_dai);\nvoid snd_soc_unregister_component(struct device *dev);\nvoid snd_soc_unregister_component_by_driver(struct device *dev,\n\t\t\t const struct snd_soc_component_driver *component_driver);\nstruct snd_soc_component *snd_soc_lookup_component_nolocked(struct device *dev,\n\t\t\t\t\t\t\t    const char *driver_name);\nstruct snd_soc_component *snd_soc_lookup_component(struct device *dev,\n\t\t\t\t\t\t   const char *driver_name);\n\nint soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num);\n#ifdef CONFIG_SND_SOC_COMPRESS\nint snd_soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num);\n#else\nstatic inline int snd_soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)\n{\n\treturn 0;\n}\n#endif\n\nvoid snd_soc_disconnect_sync(struct device *dev);\n\nstruct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,\n\t\t\t\tstruct snd_soc_dai_link *dai_link);\n\nbool snd_soc_runtime_ignore_pmdown_time(struct snd_soc_pcm_runtime *rtd);\n\nvoid snd_soc_runtime_action(struct snd_soc_pcm_runtime *rtd,\n\t\t\t    int stream, int action);\nstatic inline void snd_soc_runtime_activate(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t     int stream)\n{\n\tsnd_soc_runtime_action(rtd, stream, 1);\n}\nstatic inline void snd_soc_runtime_deactivate(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t       int stream)\n{\n\tsnd_soc_runtime_action(rtd, stream, -1);\n}\n\nint snd_soc_runtime_calc_hw(struct snd_soc_pcm_runtime *rtd,\n\t\t\t    struct snd_pcm_hardware *hw, int stream);\n\nint snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,\n\tunsigned int dai_fmt);\n\n#ifdef CONFIG_DMI\nint snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour);\n#else\nstatic inline int snd_soc_set_dmi_name(struct snd_soc_card *card,\n\t\t\t\t       const char *flavour)\n{\n\treturn 0;\n}\n#endif\n\n \nint snd_soc_calc_frame_size(int sample_size, int channels, int tdm_slots);\nint snd_soc_params_to_frame_size(struct snd_pcm_hw_params *params);\nint snd_soc_calc_bclk(int fs, int sample_size, int channels, int tdm_slots);\nint snd_soc_params_to_bclk(struct snd_pcm_hw_params *parms);\nint snd_soc_tdm_params_to_bclk(struct snd_pcm_hw_params *params,\n\t\t\t       int tdm_width, int tdm_slots, int slot_multiple);\n\n \nint snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,\n\tconst struct snd_pcm_hardware *hw);\n\nstruct snd_ac97 *snd_soc_alloc_ac97_component(struct snd_soc_component *component);\nstruct snd_ac97 *snd_soc_new_ac97_component(struct snd_soc_component *component,\n\tunsigned int id, unsigned int id_mask);\nvoid snd_soc_free_ac97_component(struct snd_ac97 *ac97);\n\n#ifdef CONFIG_SND_SOC_AC97_BUS\nint snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops);\nint snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,\n\t\tstruct platform_device *pdev);\n\nextern struct snd_ac97_bus_ops *soc_ac97_ops;\n#else\nstatic inline int snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,\n\tstruct platform_device *pdev)\n{\n\treturn 0;\n}\n\nstatic inline int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)\n{\n\treturn 0;\n}\n#endif\n\n \nstruct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,\n\t\t\t\t  void *data, const char *long_name,\n\t\t\t\t  const char *prefix);\nint snd_soc_add_component_controls(struct snd_soc_component *component,\n\tconst struct snd_kcontrol_new *controls, unsigned int num_controls);\nint snd_soc_add_card_controls(struct snd_soc_card *soc_card,\n\tconst struct snd_kcontrol_new *controls, int num_controls);\nint snd_soc_add_dai_controls(struct snd_soc_dai *dai,\n\tconst struct snd_kcontrol_new *controls, int num_controls);\nint snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo);\nint snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\nint snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\nint snd_soc_info_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo);\nint snd_soc_info_volsw_sx(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_info *uinfo);\n#define snd_soc_info_bool_ext\t\tsnd_ctl_boolean_mono_info\nint snd_soc_get_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\nint snd_soc_put_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\n#define snd_soc_get_volsw_2r snd_soc_get_volsw\n#define snd_soc_put_volsw_2r snd_soc_put_volsw\nint snd_soc_get_volsw_sx(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\nint snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\nint snd_soc_info_volsw_range(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo);\nint snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\nint snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\nint snd_soc_limit_volume(struct snd_soc_card *card,\n\tconst char *name, int max);\nint snd_soc_bytes_info(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_info *uinfo);\nint snd_soc_bytes_get(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol);\nint snd_soc_bytes_put(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol);\nint snd_soc_bytes_info_ext(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *ucontrol);\nint snd_soc_bytes_tlv_callback(struct snd_kcontrol *kcontrol, int op_flag,\n\tunsigned int size, unsigned int __user *tlv);\nint snd_soc_info_xr_sx(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo);\nint snd_soc_get_xr_sx(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\nint snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\nint snd_soc_get_strobe(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\nint snd_soc_put_strobe(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol);\n\nenum snd_soc_trigger_order {\n\t\t\t\t\t\t \n\tSND_SOC_TRIGGER_ORDER_DEFAULT\t= 0,\t \n\tSND_SOC_TRIGGER_ORDER_LDC,\t\t \n\n\tSND_SOC_TRIGGER_ORDER_MAX,\n};\n\n \nstruct snd_soc_pcm_stream {\n\tconst char *stream_name;\n\tu64 formats;\t\t\t \n\tunsigned int rates;\t\t \n\tunsigned int rate_min;\t\t \n\tunsigned int rate_max;\t\t \n\tunsigned int channels_min;\t \n\tunsigned int channels_max;\t \n\tunsigned int sig_bits;\t\t \n};\n\n \nstruct snd_soc_ops {\n\tint (*startup)(struct snd_pcm_substream *);\n\tvoid (*shutdown)(struct snd_pcm_substream *);\n\tint (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);\n\tint (*hw_free)(struct snd_pcm_substream *);\n\tint (*prepare)(struct snd_pcm_substream *);\n\tint (*trigger)(struct snd_pcm_substream *, int);\n};\n\nstruct snd_soc_compr_ops {\n\tint (*startup)(struct snd_compr_stream *);\n\tvoid (*shutdown)(struct snd_compr_stream *);\n\tint (*set_params)(struct snd_compr_stream *);\n};\n\nstruct snd_soc_component*\nsnd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,\n\t\t       const char *driver_name);\n\nstruct snd_soc_dai_link_component {\n\tconst char *name;\n\tstruct device_node *of_node;\n\tconst char *dai_name;\n\tstruct of_phandle_args *dai_args;\n};\n\nstruct snd_soc_dai_link_codec_ch_map {\n\tunsigned int connected_cpu_id;\n\tunsigned int ch_mask;\n};\n\nstruct snd_soc_dai_link {\n\t \n\tconst char *name;\t\t\t \n\tconst char *stream_name;\t\t \n\n\t \n\t \n\tstruct snd_soc_dai_link_component *cpus;\n\tunsigned int num_cpus;\n\n\t \n\t \n\tstruct snd_soc_dai_link_component *codecs;\n\tunsigned int num_codecs;\n\n\tstruct snd_soc_dai_link_codec_ch_map *codec_ch_maps;\n\t \n\tstruct snd_soc_dai_link_component *platforms;\n\tunsigned int num_platforms;\n\n\tint id;\t \n\n\t \n\tconst struct snd_soc_pcm_stream *c2c_params;\n\tunsigned int num_c2c_params;\n\n\tunsigned int dai_fmt;            \n\n\tenum snd_soc_dpcm_trigger trigger[2];  \n\n\t \n\tint (*init)(struct snd_soc_pcm_runtime *rtd);\n\n\t \n\tvoid (*exit)(struct snd_soc_pcm_runtime *rtd);\n\n\t \n\tint (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *rtd,\n\t\t\tstruct snd_pcm_hw_params *params);\n\n\t \n\tconst struct snd_soc_ops *ops;\n\tconst struct snd_soc_compr_ops *compr_ops;\n\n\t \n\tenum snd_soc_trigger_order trigger_start;\n\tenum snd_soc_trigger_order trigger_stop;\n\n\t \n\tunsigned int nonatomic:1;\n\n\t \n\tunsigned int playback_only:1;\n\tunsigned int capture_only:1;\n\n\t \n\tunsigned int ignore_suspend:1;\n\n\t \n\tunsigned int symmetric_rate:1;\n\tunsigned int symmetric_channels:1;\n\tunsigned int symmetric_sample_bits:1;\n\n\t \n\tunsigned int no_pcm:1;\n\n\t \n\tunsigned int dynamic:1;\n\n\t \n\tunsigned int dpcm_capture:1;\n\tunsigned int dpcm_playback:1;\n\n\t \n\tunsigned int dpcm_merged_format:1;\n\t \n\tunsigned int dpcm_merged_chan:1;\n\t \n\tunsigned int dpcm_merged_rate:1;\n\n\t \n\tunsigned int ignore_pmdown_time:1;\n\n\t \n\tunsigned int ignore:1;\n\n#ifdef CONFIG_SND_SOC_TOPOLOGY\n\tstruct snd_soc_dobj dobj;  \n#endif\n};\n\nstatic inline struct snd_soc_dai_link_component*\nasoc_link_to_cpu(struct snd_soc_dai_link *link, int n) {\n\treturn &(link)->cpus[n];\n}\n\nstatic inline struct snd_soc_dai_link_component*\nasoc_link_to_codec(struct snd_soc_dai_link *link, int n) {\n\treturn &(link)->codecs[n];\n}\n\nstatic inline struct snd_soc_dai_link_component*\nasoc_link_to_platform(struct snd_soc_dai_link *link, int n) {\n\treturn &(link)->platforms[n];\n}\n\n#define for_each_link_codecs(link, i, codec)\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < link->num_codecs) &&\t\t\t\t\\\n\t\t     ((codec) = asoc_link_to_codec(link, i));\t\t\\\n\t     (i)++)\n\n#define for_each_link_platforms(link, i, platform)\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < link->num_platforms) &&\t\t\t\t\\\n\t\t     ((platform) = asoc_link_to_platform(link, i));\t\\\n\t     (i)++)\n\n#define for_each_link_cpus(link, i, cpu)\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < link->num_cpus) &&\t\t\t\t\t\\\n\t\t     ((cpu) = asoc_link_to_cpu(link, i));\t\t\\\n\t     (i)++)\n\n \n\n#define SND_SOC_DAILINK_REG1(name)\t SND_SOC_DAILINK_REG3(name##_cpus, name##_codecs, name##_platforms)\n#define SND_SOC_DAILINK_REG2(cpu, codec) SND_SOC_DAILINK_REG3(cpu, codec, null_dailink_component)\n#define SND_SOC_DAILINK_REG3(cpu, codec, platform)\t\\\n\t.cpus\t\t= cpu,\t\t\t\t\\\n\t.num_cpus\t= ARRAY_SIZE(cpu),\t\t\\\n\t.codecs\t\t= codec,\t\t\t\\\n\t.num_codecs\t= ARRAY_SIZE(codec),\t\t\\\n\t.platforms\t= platform,\t\t\t\\\n\t.num_platforms\t= ARRAY_SIZE(platform)\n\n#define SND_SOC_DAILINK_REGx(_1, _2, _3, func, ...) func\n#define SND_SOC_DAILINK_REG(...) \\\n\tSND_SOC_DAILINK_REGx(__VA_ARGS__,\t\t\\\n\t\t\tSND_SOC_DAILINK_REG3,\t\\\n\t\t\tSND_SOC_DAILINK_REG2,\t\\\n\t\t\tSND_SOC_DAILINK_REG1)(__VA_ARGS__)\n\n#define SND_SOC_DAILINK_DEF(name, def...)\t\t\\\n\tstatic struct snd_soc_dai_link_component name[]\t= { def }\n\n#define SND_SOC_DAILINK_DEFS(name, cpu, codec, platform...)\t\\\n\tSND_SOC_DAILINK_DEF(name##_cpus, cpu);\t\t\t\\\n\tSND_SOC_DAILINK_DEF(name##_codecs, codec);\t\t\\\n\tSND_SOC_DAILINK_DEF(name##_platforms, platform)\n\n#define DAILINK_COMP_ARRAY(param...)\tparam\n#define COMP_EMPTY()\t\t\t{ }\n#define COMP_CPU(_dai)\t\t\t{ .dai_name = _dai, }\n#define COMP_CODEC(_name, _dai)\t\t{ .name = _name, .dai_name = _dai, }\n#define COMP_PLATFORM(_name)\t\t{ .name = _name }\n#define COMP_AUX(_name)\t\t\t{ .name = _name }\n#define COMP_CODEC_CONF(_name)\t\t{ .name = _name }\n#define COMP_DUMMY()\t\t\t{ .name = \"snd-soc-dummy\", .dai_name = \"snd-soc-dummy-dai\", }\n\nextern struct snd_soc_dai_link_component null_dailink_component[0];\nextern struct snd_soc_dai_link_component asoc_dummy_dlc;\n\n\nstruct snd_soc_codec_conf {\n\t \n\tstruct snd_soc_dai_link_component dlc;\n\n\t \n\tconst char *name_prefix;\n};\n\nstruct snd_soc_aux_dev {\n\t \n\tstruct snd_soc_dai_link_component dlc;\n\n\t \n\tint (*init)(struct snd_soc_component *component);\n};\n\n \nstruct snd_soc_card {\n\tconst char *name;\n\tconst char *long_name;\n\tconst char *driver_name;\n\tconst char *components;\n#ifdef CONFIG_DMI\n\tchar dmi_longname[80];\n#endif  \n\n#ifdef CONFIG_PCI\n\t \n\tunsigned short pci_subsystem_vendor;\n\tunsigned short pci_subsystem_device;\n\tbool pci_subsystem_set;\n#endif  \n\n\tchar topology_shortname[32];\n\n\tstruct device *dev;\n\tstruct snd_card *snd_card;\n\tstruct module *owner;\n\n\tstruct mutex mutex;\n\tstruct mutex dapm_mutex;\n\n\t \n\tstruct mutex pcm_mutex;\n\tenum snd_soc_pcm_subclass pcm_subclass;\n\n\tint (*probe)(struct snd_soc_card *card);\n\tint (*late_probe)(struct snd_soc_card *card);\n\tvoid (*fixup_controls)(struct snd_soc_card *card);\n\tint (*remove)(struct snd_soc_card *card);\n\n\t \n\tint (*suspend_pre)(struct snd_soc_card *card);\n\tint (*suspend_post)(struct snd_soc_card *card);\n\tint (*resume_pre)(struct snd_soc_card *card);\n\tint (*resume_post)(struct snd_soc_card *card);\n\n\t \n\tint (*set_bias_level)(struct snd_soc_card *,\n\t\t\t      struct snd_soc_dapm_context *dapm,\n\t\t\t      enum snd_soc_bias_level level);\n\tint (*set_bias_level_post)(struct snd_soc_card *,\n\t\t\t\t   struct snd_soc_dapm_context *dapm,\n\t\t\t\t   enum snd_soc_bias_level level);\n\n\tint (*add_dai_link)(struct snd_soc_card *,\n\t\t\t    struct snd_soc_dai_link *link);\n\tvoid (*remove_dai_link)(struct snd_soc_card *,\n\t\t\t    struct snd_soc_dai_link *link);\n\n\tlong pmdown_time;\n\n\t \n\tstruct snd_soc_dai_link *dai_link;   \n\tint num_links;   \n\n\tstruct list_head rtd_list;\n\tint num_rtd;\n\n\t \n\tstruct snd_soc_codec_conf *codec_conf;\n\tint num_configs;\n\n\t \n\tstruct snd_soc_aux_dev *aux_dev;\n\tint num_aux_devs;\n\tstruct list_head aux_comp_list;\n\n\tconst struct snd_kcontrol_new *controls;\n\tint num_controls;\n\n\t \n\tconst struct snd_soc_dapm_widget *dapm_widgets;\n\tint num_dapm_widgets;\n\tconst struct snd_soc_dapm_route *dapm_routes;\n\tint num_dapm_routes;\n\tconst struct snd_soc_dapm_widget *of_dapm_widgets;\n\tint num_of_dapm_widgets;\n\tconst struct snd_soc_dapm_route *of_dapm_routes;\n\tint num_of_dapm_routes;\n\n\t \n\tstruct list_head component_dev_list;\n\tstruct list_head list;\n\n\tstruct list_head widgets;\n\tstruct list_head paths;\n\tstruct list_head dapm_list;\n\tstruct list_head dapm_dirty;\n\n\t \n\tstruct list_head dobj_list;\n\n\t \n\tstruct snd_soc_dapm_context dapm;\n\tstruct snd_soc_dapm_stats dapm_stats;\n\tstruct snd_soc_dapm_update *update;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *debugfs_card_root;\n#endif\n#ifdef CONFIG_PM_SLEEP\n\tstruct work_struct deferred_resume_work;\n#endif\n\tu32 pop_time;\n\n\t \n\tunsigned int instantiated:1;\n\tunsigned int topology_shortname_created:1;\n\tunsigned int fully_routed:1;\n\tunsigned int disable_route_checks:1;\n\tunsigned int probed:1;\n\tunsigned int component_chaining:1;\n\n\tvoid *drvdata;\n};\n#define for_each_card_prelinks(card, i, link)\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < (card)->num_links) && ((link) = &(card)->dai_link[i]); \\\n\t     (i)++)\n#define for_each_card_pre_auxs(card, i, aux)\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < (card)->num_aux_devs) && ((aux) = &(card)->aux_dev[i]); \\\n\t     (i)++)\n\n#define for_each_card_rtds(card, rtd)\t\t\t\\\n\tlist_for_each_entry(rtd, &(card)->rtd_list, list)\n#define for_each_card_rtds_safe(card, rtd, _rtd)\t\\\n\tlist_for_each_entry_safe(rtd, _rtd, &(card)->rtd_list, list)\n\n#define for_each_card_auxs(card, component)\t\t\t\\\n\tlist_for_each_entry(component, &card->aux_comp_list, card_aux_list)\n#define for_each_card_auxs_safe(card, component, _comp)\t\\\n\tlist_for_each_entry_safe(component, _comp,\t\\\n\t\t\t\t &card->aux_comp_list, card_aux_list)\n\n#define for_each_card_components(card, component)\t\t\t\\\n\tlist_for_each_entry(component, &(card)->component_dev_list, card_list)\n\n#define for_each_card_dapms(card, dapm)\t\t\t\t\t\\\n\tlist_for_each_entry(dapm, &card->dapm_list, list)\n\n#define for_each_card_widgets(card, w)\\\n\tlist_for_each_entry(w, &card->widgets, list)\n#define for_each_card_widgets_safe(card, w, _w)\t\\\n\tlist_for_each_entry_safe(w, _w, &card->widgets, list)\n\n\nstatic inline int snd_soc_card_is_instantiated(struct snd_soc_card *card)\n{\n\treturn card && card->instantiated;\n}\n\n \nstruct snd_soc_pcm_runtime {\n\tstruct device *dev;\n\tstruct snd_soc_card *card;\n\tstruct snd_soc_dai_link *dai_link;\n\tstruct snd_pcm_ops ops;\n\n\tunsigned int c2c_params_select;  \n\n\t \n\tstruct snd_soc_dpcm_runtime dpcm[SNDRV_PCM_STREAM_LAST + 1];\n\tstruct snd_soc_dapm_widget *c2c_widget[SNDRV_PCM_STREAM_LAST + 1];\n\n\tlong pmdown_time;\n\n\t \n\tstruct snd_pcm *pcm;\n\tstruct snd_compr *compr;\n\n\t \n\tstruct snd_soc_dai **dais;\n\n\tstruct delayed_work delayed_work;\n\tvoid (*close_delayed_work_func)(struct snd_soc_pcm_runtime *rtd);\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *debugfs_dpcm_root;\n#endif\n\n\tunsigned int num;  \n\tstruct list_head list;  \n\n\t \n\tstruct snd_pcm_substream *mark_startup;\n\tstruct snd_pcm_substream *mark_hw_params;\n\tstruct snd_pcm_substream *mark_trigger;\n\tstruct snd_compr_stream  *mark_compr_startup;\n\n\t \n\tunsigned int pop_wait:1;\n\tunsigned int fe_compr:1;  \n\n\tbool initialized;\n\n\tint num_components;\n\tstruct snd_soc_component *components[];  \n};\n \n#define asoc_rtd_to_cpu(rtd, n)   (rtd)->dais[n]\n#define asoc_rtd_to_codec(rtd, n) (rtd)->dais[n + (rtd)->dai_link->num_cpus]\n#define asoc_substream_to_rtd(substream) \\\n\t(struct snd_soc_pcm_runtime *)snd_pcm_substream_chip(substream)\n\n#define for_each_rtd_components(rtd, i, component)\t\t\t\\\n\tfor ((i) = 0, component = NULL;\t\t\t\t\t\\\n\t     ((i) < rtd->num_components) && ((component) = rtd->components[i]);\\\n\t     (i)++)\n#define for_each_rtd_cpu_dais(rtd, i, dai)\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < rtd->dai_link->num_cpus) && ((dai) = asoc_rtd_to_cpu(rtd, i)); \\\n\t     (i)++)\n#define for_each_rtd_codec_dais(rtd, i, dai)\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < rtd->dai_link->num_codecs) && ((dai) = asoc_rtd_to_codec(rtd, i)); \\\n\t     (i)++)\n#define for_each_rtd_dais(rtd, i, dai)\t\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < (rtd)->dai_link->num_cpus + (rtd)->dai_link->num_codecs) &&\t\\\n\t\t     ((dai) = (rtd)->dais[i]);\t\t\t\t\\\n\t     (i)++)\n\nvoid snd_soc_close_delayed_work(struct snd_soc_pcm_runtime *rtd);\n\n \nstruct soc_mixer_control {\n\tint min, max, platform_max;\n\tint reg, rreg;\n\tunsigned int shift, rshift;\n\tunsigned int sign_bit;\n\tunsigned int invert:1;\n\tunsigned int autodisable:1;\n#ifdef CONFIG_SND_SOC_TOPOLOGY\n\tstruct snd_soc_dobj dobj;\n#endif\n};\n\nstruct soc_bytes {\n\tint base;\n\tint num_regs;\n\tu32 mask;\n};\n\nstruct soc_bytes_ext {\n\tint max;\n#ifdef CONFIG_SND_SOC_TOPOLOGY\n\tstruct snd_soc_dobj dobj;\n#endif\n\t \n\tint (*get)(struct snd_kcontrol *kcontrol, unsigned int __user *bytes,\n\t\t\tunsigned int size);\n\tint (*put)(struct snd_kcontrol *kcontrol, const unsigned int __user *bytes,\n\t\t\tunsigned int size);\n};\n\n \nstruct soc_mreg_control {\n\tlong min, max;\n\tunsigned int regbase, regcount, nbits, invert;\n};\n\n \nstruct soc_enum {\n\tint reg;\n\tunsigned char shift_l;\n\tunsigned char shift_r;\n\tunsigned int items;\n\tunsigned int mask;\n\tconst char * const *texts;\n\tconst unsigned int *values;\n\tunsigned int autodisable:1;\n#ifdef CONFIG_SND_SOC_TOPOLOGY\n\tstruct snd_soc_dobj dobj;\n#endif\n};\n\nstatic inline bool snd_soc_volsw_is_stereo(struct soc_mixer_control *mc)\n{\n\tif (mc->reg == mc->rreg && mc->shift == mc->rshift)\n\t\treturn false;\n\t \n\treturn true;\n}\n\nstatic inline unsigned int snd_soc_enum_val_to_item(struct soc_enum *e,\n\tunsigned int val)\n{\n\tunsigned int i;\n\n\tif (!e->values)\n\t\treturn val;\n\n\tfor (i = 0; i < e->items; i++)\n\t\tif (val == e->values[i])\n\t\t\treturn i;\n\n\treturn 0;\n}\n\nstatic inline unsigned int snd_soc_enum_item_to_val(struct soc_enum *e,\n\tunsigned int item)\n{\n\tif (!e->values)\n\t\treturn item;\n\n\treturn e->values[item];\n}\n\n \nstatic inline struct snd_soc_component *snd_soc_kcontrol_component(\n\tstruct snd_kcontrol *kcontrol)\n{\n\treturn snd_kcontrol_chip(kcontrol);\n}\n\nint snd_soc_util_init(void);\nvoid snd_soc_util_exit(void);\n\nint snd_soc_of_parse_card_name(struct snd_soc_card *card,\n\t\t\t       const char *propname);\nint snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,\n\t\t\t\t\t  const char *propname);\nint snd_soc_of_parse_pin_switches(struct snd_soc_card *card, const char *prop);\nint snd_soc_of_get_slot_mask(struct device_node *np,\n\t\t\t     const char *prop_name,\n\t\t\t     unsigned int *mask);\nint snd_soc_of_parse_tdm_slot(struct device_node *np,\n\t\t\t      unsigned int *tx_mask,\n\t\t\t      unsigned int *rx_mask,\n\t\t\t      unsigned int *slots,\n\t\t\t      unsigned int *slot_width);\nvoid snd_soc_of_parse_node_prefix(struct device_node *np,\n\t\t\t\t   struct snd_soc_codec_conf *codec_conf,\n\t\t\t\t   struct device_node *of_node,\n\t\t\t\t   const char *propname);\nstatic inline\nvoid snd_soc_of_parse_audio_prefix(struct snd_soc_card *card,\n\t\t\t\t   struct snd_soc_codec_conf *codec_conf,\n\t\t\t\t   struct device_node *of_node,\n\t\t\t\t   const char *propname)\n{\n\tsnd_soc_of_parse_node_prefix(card->dev->of_node,\n\t\t\t\t     codec_conf, of_node, propname);\n}\n\nint snd_soc_of_parse_audio_routing(struct snd_soc_card *card,\n\t\t\t\t   const char *propname);\nint snd_soc_of_parse_aux_devs(struct snd_soc_card *card, const char *propname);\n\nunsigned int snd_soc_daifmt_clock_provider_flipped(unsigned int dai_fmt);\nunsigned int snd_soc_daifmt_clock_provider_from_bitmap(unsigned int bit_frame);\n\nunsigned int snd_soc_daifmt_parse_format(struct device_node *np, const char *prefix);\nunsigned int snd_soc_daifmt_parse_clock_provider_raw(struct device_node *np,\n\t\t\t\t\t\t     const char *prefix,\n\t\t\t\t\t\t     struct device_node **bitclkmaster,\n\t\t\t\t\t\t     struct device_node **framemaster);\n#define snd_soc_daifmt_parse_clock_provider_as_bitmap(np, prefix)\t\\\n\tsnd_soc_daifmt_parse_clock_provider_raw(np, prefix, NULL, NULL)\n#define snd_soc_daifmt_parse_clock_provider_as_phandle\t\t\t\\\n\tsnd_soc_daifmt_parse_clock_provider_raw\n#define snd_soc_daifmt_parse_clock_provider_as_flag(np, prefix)\t\t\\\n\tsnd_soc_daifmt_clock_provider_from_bitmap(\t\t\t\\\n\t\tsnd_soc_daifmt_parse_clock_provider_as_bitmap(np, prefix))\n\nint snd_soc_get_stream_cpu(struct snd_soc_dai_link *dai_link, int stream);\nint snd_soc_get_dlc(const struct of_phandle_args *args,\n\t\t    struct snd_soc_dai_link_component *dlc);\nint snd_soc_of_get_dlc(struct device_node *of_node,\n\t\t       struct of_phandle_args *args,\n\t\t       struct snd_soc_dai_link_component *dlc,\n\t\t       int index);\nint snd_soc_get_dai_id(struct device_node *ep);\nint snd_soc_get_dai_name(const struct of_phandle_args *args,\n\t\t\t const char **dai_name);\nint snd_soc_of_get_dai_name(struct device_node *of_node,\n\t\t\t    const char **dai_name, int index);\nint snd_soc_of_get_dai_link_codecs(struct device *dev,\n\t\t\t\t   struct device_node *of_node,\n\t\t\t\t   struct snd_soc_dai_link *dai_link);\nvoid snd_soc_of_put_dai_link_codecs(struct snd_soc_dai_link *dai_link);\nint snd_soc_of_get_dai_link_cpus(struct device *dev,\n\t\t\t\t struct device_node *of_node,\n\t\t\t\t struct snd_soc_dai_link *dai_link);\nvoid snd_soc_of_put_dai_link_cpus(struct snd_soc_dai_link *dai_link);\n\nint snd_soc_add_pcm_runtimes(struct snd_soc_card *card,\n\t\t\t     struct snd_soc_dai_link *dai_link,\n\t\t\t     int num_dai_link);\nvoid snd_soc_remove_pcm_runtime(struct snd_soc_card *card,\n\t\t\t\tstruct snd_soc_pcm_runtime *rtd);\n\nvoid snd_soc_dlc_use_cpu_as_platform(struct snd_soc_dai_link_component *platforms,\n\t\t\t\t     struct snd_soc_dai_link_component *cpus);\nstruct of_phandle_args *snd_soc_copy_dai_args(struct device *dev,\n\t\t\t\t\t      struct of_phandle_args *args);\nstruct snd_soc_dai *snd_soc_get_dai_via_args(struct of_phandle_args *dai_args);\nstruct snd_soc_dai *snd_soc_register_dai(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_soc_dai_driver *dai_drv,\n\t\t\t\t\t bool legacy_dai_naming);\nstruct snd_soc_dai *devm_snd_soc_register_dai(struct device *dev,\n\t\t\t\t\t      struct snd_soc_component *component,\n\t\t\t\t\t      struct snd_soc_dai_driver *dai_drv,\n\t\t\t\t\t      bool legacy_dai_naming);\nvoid snd_soc_unregister_dai(struct snd_soc_dai *dai);\n\nstruct snd_soc_dai *snd_soc_find_dai(\n\tconst struct snd_soc_dai_link_component *dlc);\nstruct snd_soc_dai *snd_soc_find_dai_with_mutex(\n\tconst struct snd_soc_dai_link_component *dlc);\n\n#include <sound/soc-dai.h>\n\nstatic inline\nint snd_soc_fixup_dai_links_platform_name(struct snd_soc_card *card,\n\t\t\t\t\t  const char *platform_name)\n{\n\tstruct snd_soc_dai_link *dai_link;\n\tconst char *name;\n\tint i;\n\n\tif (!platform_name)  \n\t\treturn 0;\n\n\t \n\tfor_each_card_prelinks(card, i, dai_link) {\n\t\t \n\t\tif (dai_link->num_platforms != 1)\n\t\t\treturn -EINVAL;\n\n\t\tif (!dai_link->platforms)\n\t\t\treturn -EINVAL;\n\n\t\tname = devm_kstrdup(card->dev, platform_name, GFP_KERNEL);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tdai_link->platforms->name = name;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nextern struct dentry *snd_soc_debugfs_root;\n#endif\n\nextern const struct dev_pm_ops snd_soc_pm_ops;\n\n \nenum snd_soc_dapm_subclass {\n\tSND_SOC_DAPM_CLASS_ROOT\t\t= 0,\n\tSND_SOC_DAPM_CLASS_RUNTIME\t= 1,\n};\n\nstatic inline void _snd_soc_dapm_mutex_lock_root_c(struct snd_soc_card *card)\n{\n\tmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_ROOT);\n}\n\nstatic inline void _snd_soc_dapm_mutex_lock_c(struct snd_soc_card *card)\n{\n\tmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\n}\n\nstatic inline void _snd_soc_dapm_mutex_unlock_c(struct snd_soc_card *card)\n{\n\tmutex_unlock(&card->dapm_mutex);\n}\n\nstatic inline void _snd_soc_dapm_mutex_assert_held_c(struct snd_soc_card *card)\n{\n\tlockdep_assert_held(&card->dapm_mutex);\n}\n\nstatic inline void _snd_soc_dapm_mutex_lock_root_d(struct snd_soc_dapm_context *dapm)\n{\n\t_snd_soc_dapm_mutex_lock_root_c(dapm->card);\n}\n\nstatic inline void _snd_soc_dapm_mutex_lock_d(struct snd_soc_dapm_context *dapm)\n{\n\t_snd_soc_dapm_mutex_lock_c(dapm->card);\n}\n\nstatic inline void _snd_soc_dapm_mutex_unlock_d(struct snd_soc_dapm_context *dapm)\n{\n\t_snd_soc_dapm_mutex_unlock_c(dapm->card);\n}\n\nstatic inline void _snd_soc_dapm_mutex_assert_held_d(struct snd_soc_dapm_context *dapm)\n{\n\t_snd_soc_dapm_mutex_assert_held_c(dapm->card);\n}\n\n#define snd_soc_dapm_mutex_lock_root(x) _Generic((x),\t\t\t\\\n\tstruct snd_soc_card * :\t\t_snd_soc_dapm_mutex_lock_root_c, \\\n\tstruct snd_soc_dapm_context * :\t_snd_soc_dapm_mutex_lock_root_d)(x)\n#define snd_soc_dapm_mutex_lock(x) _Generic((x),\t\t\t\\\n\tstruct snd_soc_card * :\t\t_snd_soc_dapm_mutex_lock_c,\t\\\n\tstruct snd_soc_dapm_context * :\t_snd_soc_dapm_mutex_lock_d)(x)\n#define snd_soc_dapm_mutex_unlock(x) _Generic((x),\t\t\t\\\n\tstruct snd_soc_card * :\t\t_snd_soc_dapm_mutex_unlock_c,\t\\\n\tstruct snd_soc_dapm_context * :\t_snd_soc_dapm_mutex_unlock_d)(x)\n#define snd_soc_dapm_mutex_assert_held(x) _Generic((x),\t\t\t\\\n\tstruct snd_soc_card * :\t\t_snd_soc_dapm_mutex_assert_held_c, \\\n\tstruct snd_soc_dapm_context * :\t_snd_soc_dapm_mutex_assert_held_d)(x)\n\n \nstatic inline void _snd_soc_dpcm_mutex_lock_c(struct snd_soc_card *card)\n{\n\tmutex_lock_nested(&card->pcm_mutex, card->pcm_subclass);\n}\n\nstatic inline void _snd_soc_dpcm_mutex_unlock_c(struct snd_soc_card *card)\n{\n\tmutex_unlock(&card->pcm_mutex);\n}\n\nstatic inline void _snd_soc_dpcm_mutex_assert_held_c(struct snd_soc_card *card)\n{\n\tlockdep_assert_held(&card->pcm_mutex);\n}\n\nstatic inline void _snd_soc_dpcm_mutex_lock_r(struct snd_soc_pcm_runtime *rtd)\n{\n\t_snd_soc_dpcm_mutex_lock_c(rtd->card);\n}\n\nstatic inline void _snd_soc_dpcm_mutex_unlock_r(struct snd_soc_pcm_runtime *rtd)\n{\n\t_snd_soc_dpcm_mutex_unlock_c(rtd->card);\n}\n\nstatic inline void _snd_soc_dpcm_mutex_assert_held_r(struct snd_soc_pcm_runtime *rtd)\n{\n\t_snd_soc_dpcm_mutex_assert_held_c(rtd->card);\n}\n\n#define snd_soc_dpcm_mutex_lock(x) _Generic((x),\t\t\t\\\n\t struct snd_soc_card * :\t_snd_soc_dpcm_mutex_lock_c,\t\\\n\t struct snd_soc_pcm_runtime * :\t_snd_soc_dpcm_mutex_lock_r)(x)\n\n#define snd_soc_dpcm_mutex_unlock(x) _Generic((x),\t\t\t\\\n\t struct snd_soc_card * :\t_snd_soc_dpcm_mutex_unlock_c,\t\\\n\t struct snd_soc_pcm_runtime * :\t_snd_soc_dpcm_mutex_unlock_r)(x)\n\n#define snd_soc_dpcm_mutex_assert_held(x) _Generic((x),\t\t\\\n\tstruct snd_soc_card * :\t\t_snd_soc_dpcm_mutex_assert_held_c, \\\n\tstruct snd_soc_pcm_runtime * :\t_snd_soc_dpcm_mutex_assert_held_r)(x)\n\n#include <sound/soc-component.h>\n#include <sound/soc-card.h>\n#include <sound/soc-jack.h>\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}