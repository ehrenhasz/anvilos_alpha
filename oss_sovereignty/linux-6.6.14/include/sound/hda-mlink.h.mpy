{
  "module_name": "hda-mlink.h",
  "hash_id": "6283bfbd0a57fbedd9463a462ed33147027ddcfbe6bb011e74ef40c79b0a90d9",
  "original_prompt": "Ingested from linux-6.6.14/include/sound/hda-mlink.h",
  "human_readable_source": " \n \n\nstruct hdac_bus;\nstruct hdac_ext_link;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_MLINK)\n\nint hda_bus_ml_init(struct hdac_bus *bus);\nvoid hda_bus_ml_free(struct hdac_bus *bus);\n\nint hdac_bus_eml_get_count(struct hdac_bus *bus, bool alt, int elid);\nvoid hdac_bus_eml_enable_interrupt(struct hdac_bus *bus, bool alt, int elid, bool enable);\nbool hdac_bus_eml_check_interrupt(struct hdac_bus *bus, bool alt, int elid);\n\nint hdac_bus_eml_set_syncprd_unlocked(struct hdac_bus *bus, bool alt, int elid, u32 syncprd);\nint hdac_bus_eml_sdw_set_syncprd_unlocked(struct hdac_bus *bus, u32 syncprd);\n\nint hdac_bus_eml_wait_syncpu_unlocked(struct hdac_bus *bus, bool alt, int elid);\nint hdac_bus_eml_sdw_wait_syncpu_unlocked(struct hdac_bus *bus);\n\nvoid hdac_bus_eml_sync_arm_unlocked(struct hdac_bus *bus, bool alt, int elid, int sublink);\nvoid hdac_bus_eml_sdw_sync_arm_unlocked(struct hdac_bus *bus, int sublink);\n\nint hdac_bus_eml_sync_go_unlocked(struct hdac_bus *bus, bool alt, int elid);\nint hdac_bus_eml_sdw_sync_go_unlocked(struct hdac_bus *bus);\n\nbool hdac_bus_eml_check_cmdsync_unlocked(struct hdac_bus *bus, bool alt, int elid);\nbool hdac_bus_eml_sdw_check_cmdsync_unlocked(struct hdac_bus *bus);\n\nint hdac_bus_eml_power_up(struct hdac_bus *bus, bool alt, int elid, int sublink);\nint hdac_bus_eml_power_up_unlocked(struct hdac_bus *bus, bool alt, int elid, int sublink);\n\nint hdac_bus_eml_power_down(struct hdac_bus *bus, bool alt, int elid, int sublink);\nint hdac_bus_eml_power_down_unlocked(struct hdac_bus *bus, bool alt, int elid, int sublink);\n\nint hdac_bus_eml_sdw_power_up_unlocked(struct hdac_bus *bus, int sublink);\nint hdac_bus_eml_sdw_power_down_unlocked(struct hdac_bus *bus, int sublink);\n\nint hdac_bus_eml_sdw_get_lsdiid_unlocked(struct hdac_bus *bus, int sublink, u16 *lsdiid);\nint hdac_bus_eml_sdw_set_lsdiid(struct hdac_bus *bus, int sublink, int dev_num);\n\nint hdac_bus_eml_sdw_map_stream_ch(struct hdac_bus *bus, int sublink, int y,\n\t\t\t\t   int channel_mask, int stream_id, int dir);\n\nvoid hda_bus_ml_put_all(struct hdac_bus *bus);\nvoid hda_bus_ml_reset_losidv(struct hdac_bus *bus);\nint hda_bus_ml_resume(struct hdac_bus *bus);\nint hda_bus_ml_suspend(struct hdac_bus *bus);\n\nstruct hdac_ext_link *hdac_bus_eml_ssp_get_hlink(struct hdac_bus *bus);\nstruct hdac_ext_link *hdac_bus_eml_dmic_get_hlink(struct hdac_bus *bus);\nstruct hdac_ext_link *hdac_bus_eml_sdw_get_hlink(struct hdac_bus *bus);\n\nstruct mutex *hdac_bus_eml_get_mutex(struct hdac_bus *bus, bool alt, int elid);\n\nint hdac_bus_eml_enable_offload(struct hdac_bus *bus, bool alt, int elid, bool enable);\n\n#else\n\nstatic inline int\nhda_bus_ml_init(struct hdac_bus *bus) { return 0; }\n\nstatic inline void hda_bus_ml_free(struct hdac_bus *bus) { }\n\nstatic inline int\nhdac_bus_eml_get_count(struct hdac_bus *bus, bool alt, int elid) { return 0; }\n\nstatic inline void\nhdac_bus_eml_enable_interrupt(struct hdac_bus *bus, bool alt, int elid, bool enable) { }\n\nstatic inline bool\nhdac_bus_eml_check_interrupt(struct hdac_bus *bus, bool alt, int elid) { return false; }\n\nstatic inline int\nhdac_bus_eml_set_syncprd_unlocked(struct hdac_bus *bus, bool alt, int elid, u32 syncprd)\n{\n\treturn 0;\n}\n\nstatic inline int\nhdac_bus_eml_sdw_set_syncprd_unlocked(struct hdac_bus *bus, u32 syncprd)\n{\n\treturn 0;\n}\n\nstatic inline int\nhdac_bus_eml_wait_syncpu_unlocked(struct hdac_bus *bus, bool alt, int elid)\n{\n\treturn 0;\n}\n\nstatic inline int\nhdac_bus_eml_sdw_wait_syncpu_unlocked(struct hdac_bus *bus) { return 0; }\n\nstatic inline void\nhdac_bus_eml_sync_arm_unlocked(struct hdac_bus *bus, bool alt, int elid, int sublink) { }\n\nstatic inline void\nhdac_bus_eml_sdw_sync_arm_unlocked(struct hdac_bus *bus, int sublink) { }\n\nstatic inline int\nhdac_bus_eml_sync_go_unlocked(struct hdac_bus *bus, bool alt, int elid) { return 0; }\n\nstatic inline int\nhdac_bus_eml_sdw_sync_go_unlocked(struct hdac_bus *bus) { return 0; }\n\nstatic inline bool\nhdac_bus_eml_check_cmdsync_unlocked(struct hdac_bus *bus, bool alt, int elid) { return false; }\n\nstatic inline bool\nhdac_bus_eml_sdw_check_cmdsync_unlocked(struct hdac_bus *bus) { return false; }\n\nstatic inline int\nhdac_bus_eml_power_up(struct hdac_bus *bus, bool alt, int elid, int sublink)\n{\n\treturn 0;\n}\n\nstatic inline int\nhdac_bus_eml_power_up_unlocked(struct hdac_bus *bus, bool alt, int elid, int sublink)\n{\n\treturn 0;\n}\n\nstatic inline int\nhdac_bus_eml_power_down(struct hdac_bus *bus, bool alt, int elid, int sublink)\n{\n\treturn 0;\n}\n\nstatic inline int\nhdac_bus_eml_power_down_unlocked(struct hdac_bus *bus, bool alt, int elid, int sublink)\n{\n\treturn 0;\n}\n\nstatic inline int\nhdac_bus_eml_sdw_power_up_unlocked(struct hdac_bus *bus, int sublink) { return 0; }\n\nstatic inline int\nhdac_bus_eml_sdw_power_down_unlocked(struct hdac_bus *bus, int sublink) { return 0; }\n\nstatic inline int\nhdac_bus_eml_sdw_get_lsdiid_unlocked(struct hdac_bus *bus, int sublink, u16 *lsdiid) { return 0; }\n\nstatic inline int\nhdac_bus_eml_sdw_set_lsdiid(struct hdac_bus *bus, int sublink, int dev_num) { return 0; }\n\nstatic inline int\nhdac_bus_eml_sdw_map_stream_ch(struct hdac_bus *bus, int sublink, int y,\n\t\t\t       int channel_mask, int stream_id, int dir)\n{\n\treturn 0;\n}\n\nstatic inline void hda_bus_ml_put_all(struct hdac_bus *bus) { }\nstatic inline void hda_bus_ml_reset_losidv(struct hdac_bus *bus) { }\nstatic inline int hda_bus_ml_resume(struct hdac_bus *bus) { return 0; }\nstatic inline int hda_bus_ml_suspend(struct hdac_bus *bus) { return 0; }\n\nstatic inline struct hdac_ext_link *\nhdac_bus_eml_ssp_get_hlink(struct hdac_bus *bus) { return NULL; }\n\nstatic inline struct hdac_ext_link *\nhdac_bus_eml_dmic_get_hlink(struct hdac_bus *bus) { return NULL; }\n\nstatic inline struct hdac_ext_link *\nhdac_bus_eml_sdw_get_hlink(struct hdac_bus *bus) { return NULL; }\n\nstatic inline struct mutex *\nhdac_bus_eml_get_mutex(struct hdac_bus *bus, bool alt, int elid) { return NULL; }\n\nstatic inline int\nhdac_bus_eml_enable_offload(struct hdac_bus *bus, bool alt, int elid, bool enable)\n{\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}