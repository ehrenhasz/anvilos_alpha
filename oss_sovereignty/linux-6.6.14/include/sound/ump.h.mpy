{
  "module_name": "ump.h",
  "hash_id": "03871c1e6f0d06a1f8b2e5a380137704bc8df818554ee82172ae6decbc20b4be",
  "original_prompt": "Ingested from linux-6.6.14/include/sound/ump.h",
  "human_readable_source": " \n \n#ifndef __SOUND_UMP_H\n#define __SOUND_UMP_H\n\n#include <sound/rawmidi.h>\n\nstruct snd_ump_endpoint;\nstruct snd_ump_block;\nstruct snd_ump_ops;\nstruct ump_cvt_to_ump;\nstruct snd_seq_ump_ops;\n\nstruct snd_ump_endpoint {\n\tstruct snd_rawmidi core;\t \n\n\tstruct snd_ump_endpoint_info info;\n\n\tconst struct snd_ump_ops *ops;\t \n\tstruct snd_rawmidi_substream *substreams[2];\t \n\n\tvoid *private_data;\n\tvoid (*private_free)(struct snd_ump_endpoint *ump);\n\n\t \n\tu32 stream_wait_for;\t \n\tbool stream_finished;\t \n\tbool parsed;\t\t \n\tbool no_process_stream;\t \n\twait_queue_head_t stream_wait;\n\tstruct snd_rawmidi_file stream_rfile;\n\n\tstruct list_head block_list;\t \n\n\t \n\tu32 input_buf[4];\n\tint input_buf_head;\n\tint input_pending;\n\n\tstruct mutex open_mutex;\n\n#if IS_ENABLED(CONFIG_SND_UMP_LEGACY_RAWMIDI)\n\tspinlock_t legacy_locks[2];\n\tstruct snd_rawmidi *legacy_rmidi;\n\tstruct snd_rawmidi_substream *legacy_substreams[2][SNDRV_UMP_MAX_GROUPS];\n\tunsigned char legacy_mapping[SNDRV_UMP_MAX_GROUPS];\n\n\t \n\tint legacy_out_opens;\n\tstruct snd_rawmidi_file legacy_out_rfile;\n\tstruct ump_cvt_to_ump *out_cvts;\n#endif\n\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n\tstruct snd_seq_device *seq_dev;\n\tconst struct snd_seq_ump_ops *seq_ops;\n\tvoid *seq_client;\n#endif\n};\n\n \nstruct snd_ump_ops {\n\tint (*open)(struct snd_ump_endpoint *ump, int dir);\n\tvoid (*close)(struct snd_ump_endpoint *ump, int dir);\n\tvoid (*trigger)(struct snd_ump_endpoint *ump, int dir, int up);\n\tvoid (*drain)(struct snd_ump_endpoint *ump, int dir);\n};\n\n \nstruct snd_seq_ump_ops {\n\tvoid (*input_receive)(struct snd_ump_endpoint *ump,\n\t\t\t      const u32 *data, int words);\n\tint (*notify_fb_change)(struct snd_ump_endpoint *ump,\n\t\t\t\tstruct snd_ump_block *fb);\n\tint (*switch_protocol)(struct snd_ump_endpoint *ump);\n};\n\nstruct snd_ump_block {\n\tstruct snd_ump_block_info info;\n\tstruct snd_ump_endpoint *ump;\n\n\tvoid *private_data;\n\tvoid (*private_free)(struct snd_ump_block *blk);\n\n\tstruct list_head list;\n};\n\n#define rawmidi_to_ump(rmidi)\tcontainer_of(rmidi, struct snd_ump_endpoint, core)\n\nint snd_ump_endpoint_new(struct snd_card *card, char *id, int device,\n\t\t\t int output, int input,\n\t\t\t struct snd_ump_endpoint **ump_ret);\nint snd_ump_parse_endpoint(struct snd_ump_endpoint *ump);\nint snd_ump_block_new(struct snd_ump_endpoint *ump, unsigned int blk,\n\t\t      unsigned int direction, unsigned int first_group,\n\t\t      unsigned int num_groups, struct snd_ump_block **blk_ret);\nint snd_ump_receive(struct snd_ump_endpoint *ump, const u32 *buffer, int count);\nint snd_ump_transmit(struct snd_ump_endpoint *ump, u32 *buffer, int count);\n\n#if IS_ENABLED(CONFIG_SND_UMP_LEGACY_RAWMIDI)\nint snd_ump_attach_legacy_rawmidi(struct snd_ump_endpoint *ump,\n\t\t\t\t  char *id, int device);\n#else\nstatic inline int snd_ump_attach_legacy_rawmidi(struct snd_ump_endpoint *ump,\n\t\t\t\t\t\tchar *id, int device)\n{\n\treturn 0;\n}\n#endif\n\nint snd_ump_receive_ump_val(struct snd_ump_endpoint *ump, u32 val);\nint snd_ump_switch_protocol(struct snd_ump_endpoint *ump, unsigned int protocol);\n\n \n\n \nenum {\n\tUMP_MSG_TYPE_UTILITY\t\t\t= 0x00,\n\tUMP_MSG_TYPE_SYSTEM\t\t\t= 0x01,\n\tUMP_MSG_TYPE_MIDI1_CHANNEL_VOICE\t= 0x02,\n\tUMP_MSG_TYPE_DATA\t\t\t= 0x03,\n\tUMP_MSG_TYPE_MIDI2_CHANNEL_VOICE\t= 0x04,\n\tUMP_MSG_TYPE_EXTENDED_DATA\t\t= 0x05,\n\tUMP_MSG_TYPE_FLEX_DATA\t\t\t= 0x0d,\n\tUMP_MSG_TYPE_STREAM\t\t\t= 0x0f,\n};\n\n \nenum {\n\tUMP_SYSEX_STATUS_SINGLE\t\t\t= 0,\n\tUMP_SYSEX_STATUS_START\t\t\t= 1,\n\tUMP_SYSEX_STATUS_CONTINUE\t\t= 2,\n\tUMP_SYSEX_STATUS_END\t\t\t= 3,\n};\n\n \nenum {\n\tUMP_UTILITY_MSG_STATUS_NOOP\t\t= 0x00,\n\tUMP_UTILITY_MSG_STATUS_JR_CLOCK\t\t= 0x01,\n\tUMP_UTILITY_MSG_STATUS_JR_TSTAMP\t= 0x02,\n\tUMP_UTILITY_MSG_STATUS_DCTPQ\t\t= 0x03,\n\tUMP_UTILITY_MSG_STATUS_DC\t\t= 0x04,\n};\n\n \nenum {\n\tUMP_STREAM_MSG_STATUS_EP_DISCOVERY\t= 0x00,\n\tUMP_STREAM_MSG_STATUS_EP_INFO\t\t= 0x01,\n\tUMP_STREAM_MSG_STATUS_DEVICE_INFO\t= 0x02,\n\tUMP_STREAM_MSG_STATUS_EP_NAME\t\t= 0x03,\n\tUMP_STREAM_MSG_STATUS_PRODUCT_ID\t= 0x04,\n\tUMP_STREAM_MSG_STATUS_STREAM_CFG_REQUEST = 0x05,\n\tUMP_STREAM_MSG_STATUS_STREAM_CFG\t= 0x06,\n\tUMP_STREAM_MSG_STATUS_FB_DISCOVERY\t= 0x10,\n\tUMP_STREAM_MSG_STATUS_FB_INFO\t\t= 0x11,\n\tUMP_STREAM_MSG_STATUS_FB_NAME\t\t= 0x12,\n\tUMP_STREAM_MSG_STATUS_START_CLIP\t= 0x20,\n\tUMP_STREAM_MSG_STATUS_END_CLIP\t\t= 0x21,\n};\n\n \nenum {\n\tUMP_STREAM_MSG_REQUEST_EP_INFO\t\t= (1U << 0),\n\tUMP_STREAM_MSG_REQUEST_DEVICE_INFO\t= (1U << 1),\n\tUMP_STREAM_MSG_REQUEST_EP_NAME\t\t= (1U << 2),\n\tUMP_STREAM_MSG_REQUEST_PRODUCT_ID\t= (1U << 3),\n\tUMP_STREAM_MSG_REQUEST_STREAM_CFG\t= (1U << 4),\n};\n\n \nenum {\n\tUMP_STREAM_MSG_REQUEST_FB_INFO\t\t= (1U << 0),\n\tUMP_STREAM_MSG_REQUEST_FB_NAME\t\t= (1U << 1),\n};\n\n \nenum {\n\tUMP_STREAM_MSG_EP_INFO_CAP_TXJR\t\t= (1U << 0),  \n\tUMP_STREAM_MSG_EP_INFO_CAP_RXJR\t\t= (1U << 1),  \n\tUMP_STREAM_MSG_EP_INFO_CAP_MIDI1\t= (1U << 8),  \n\tUMP_STREAM_MSG_EP_INFO_CAP_MIDI2\t= (1U << 9),  \n};\n\n \nenum {\n\tUMP_STREAM_MSG_FORMAT_SINGLE\t\t= 0,\n\tUMP_STREAM_MSG_FORMAT_START\t\t= 1,\n\tUMP_STREAM_MSG_FORMAT_CONTINUE\t\t= 2,\n\tUMP_STREAM_MSG_FORMAT_END\t\t= 3,\n};\n\n \n \nstatic inline unsigned char ump_message_type(u32 data)\n{\n\treturn data >> 28;\n}\n\n \nstatic inline unsigned char ump_message_group(u32 data)\n{\n\treturn (data >> 24) & 0x0f;\n}\n\n \nstatic inline unsigned char ump_message_status_code(u32 data)\n{\n\treturn (data >> 20) & 0x0f;\n}\n\n \nstatic inline unsigned char ump_message_channel(u32 data)\n{\n\treturn (data >> 16) & 0x0f;\n}\n\n \nstatic inline unsigned char ump_message_status_channel(u32 data)\n{\n\treturn (data >> 16) & 0xff;\n}\n\n \nstatic inline u32 ump_compose(unsigned char type, unsigned char group,\n\t\t\t      unsigned char status, unsigned char channel)\n{\n\treturn ((u32)type << 28) | ((u32)group << 24) | ((u32)status << 20) |\n\t\t((u32)channel << 16);\n}\n\n \nstatic inline unsigned char ump_sysex_message_status(u32 data)\n{\n\treturn (data >> 20) & 0xf;\n}\n\n \nstatic inline unsigned char ump_sysex_message_length(u32 data)\n{\n\treturn (data >> 16) & 0xf;\n}\n\n \nstatic inline unsigned char ump_stream_message_format(u32 data)\n{\n\treturn (data >> 26) & 0x03;\n}\n\nstatic inline unsigned int ump_stream_message_status(u32 data)\n{\n\treturn (data >> 16) & 0x3ff;\n}\n\nstatic inline u32 ump_stream_compose(unsigned char status, unsigned short form)\n{\n\treturn (UMP_MSG_TYPE_STREAM << 28) | ((u32)form << 26) |\n\t\t((u32)status << 16);\n}\n\n#define ump_is_groupless_msg(type) \\\n\t((type) == UMP_MSG_TYPE_UTILITY || (type) == UMP_MSG_TYPE_STREAM)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}