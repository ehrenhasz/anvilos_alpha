{
  "module_name": "vmwgfx_drm.h",
  "hash_id": "4f7c7fe10714cdeb1482f113881eca146de35d37a09edb5d0d04eec20218495f",
  "original_prompt": "Ingested from linux-6.6.14/include/uapi/drm/vmwgfx_drm.h",
  "human_readable_source": " \n\n#ifndef __VMWGFX_DRM_H__\n#define __VMWGFX_DRM_H__\n\n#include \"drm.h\"\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n#define DRM_VMW_MAX_SURFACE_FACES 6\n#define DRM_VMW_MAX_MIP_LEVELS 24\n\n\n#define DRM_VMW_GET_PARAM            0\n#define DRM_VMW_ALLOC_DMABUF         1\n#define DRM_VMW_ALLOC_BO             1\n#define DRM_VMW_UNREF_DMABUF         2\n#define DRM_VMW_HANDLE_CLOSE         2\n#define DRM_VMW_CURSOR_BYPASS        3\n \n#define DRM_VMW_CONTROL_STREAM       4\n#define DRM_VMW_CLAIM_STREAM         5\n#define DRM_VMW_UNREF_STREAM         6\n \n#define DRM_VMW_CREATE_CONTEXT       7\n#define DRM_VMW_UNREF_CONTEXT        8\n#define DRM_VMW_CREATE_SURFACE       9\n#define DRM_VMW_UNREF_SURFACE        10\n#define DRM_VMW_REF_SURFACE          11\n#define DRM_VMW_EXECBUF              12\n#define DRM_VMW_GET_3D_CAP           13\n#define DRM_VMW_FENCE_WAIT           14\n#define DRM_VMW_FENCE_SIGNALED       15\n#define DRM_VMW_FENCE_UNREF          16\n#define DRM_VMW_FENCE_EVENT          17\n#define DRM_VMW_PRESENT              18\n#define DRM_VMW_PRESENT_READBACK     19\n#define DRM_VMW_UPDATE_LAYOUT        20\n#define DRM_VMW_CREATE_SHADER        21\n#define DRM_VMW_UNREF_SHADER         22\n#define DRM_VMW_GB_SURFACE_CREATE    23\n#define DRM_VMW_GB_SURFACE_REF       24\n#define DRM_VMW_SYNCCPU              25\n#define DRM_VMW_CREATE_EXTENDED_CONTEXT 26\n#define DRM_VMW_GB_SURFACE_CREATE_EXT   27\n#define DRM_VMW_GB_SURFACE_REF_EXT      28\n#define DRM_VMW_MSG                     29\n#define DRM_VMW_MKSSTAT_RESET           30\n#define DRM_VMW_MKSSTAT_ADD             31\n#define DRM_VMW_MKSSTAT_REMOVE          32\n\n \n \n\n#define DRM_VMW_PARAM_NUM_STREAMS      0\n#define DRM_VMW_PARAM_NUM_FREE_STREAMS 1\n#define DRM_VMW_PARAM_3D               2\n#define DRM_VMW_PARAM_HW_CAPS          3\n#define DRM_VMW_PARAM_FIFO_CAPS        4\n#define DRM_VMW_PARAM_MAX_FB_SIZE      5\n#define DRM_VMW_PARAM_FIFO_HW_VERSION  6\n#define DRM_VMW_PARAM_MAX_SURF_MEMORY  7\n#define DRM_VMW_PARAM_3D_CAPS_SIZE     8\n#define DRM_VMW_PARAM_MAX_MOB_MEMORY   9\n#define DRM_VMW_PARAM_MAX_MOB_SIZE     10\n#define DRM_VMW_PARAM_SCREEN_TARGET    11\n#define DRM_VMW_PARAM_DX               12\n#define DRM_VMW_PARAM_HW_CAPS2         13\n#define DRM_VMW_PARAM_SM4_1            14\n#define DRM_VMW_PARAM_SM5              15\n#define DRM_VMW_PARAM_GL43             16\n#define DRM_VMW_PARAM_DEVICE_ID        17\n\n \nenum drm_vmw_handle_type {\n\tDRM_VMW_HANDLE_LEGACY = 0,\n\tDRM_VMW_HANDLE_PRIME = 1\n};\n\n \n\nstruct drm_vmw_getparam_arg {\n\t__u64 value;\n\t__u32 param;\n\t__u32 pad64;\n};\n\n \n \n\n \n\nstruct drm_vmw_context_arg {\n\t__s32 cid;\n\t__u32 pad64;\n};\n\n \n \n\n \n \n\n \n\nstruct drm_vmw_surface_create_req {\n\t__u32 flags;\n\t__u32 format;\n\t__u32 mip_levels[DRM_VMW_MAX_SURFACE_FACES];\n\t__u64 size_addr;\n\t__s32 shareable;\n\t__s32 scanout;\n};\n\n \n\nstruct drm_vmw_surface_arg {\n\t__s32 sid;\n\tenum drm_vmw_handle_type handle_type;\n};\n\n \n\nstruct drm_vmw_size {\n\t__u32 width;\n\t__u32 height;\n\t__u32 depth;\n\t__u32 pad64;\n};\n\n \n\nunion drm_vmw_surface_create_arg {\n\tstruct drm_vmw_surface_arg rep;\n\tstruct drm_vmw_surface_create_req req;\n};\n\n \n \n\n \n\nunion drm_vmw_surface_reference_arg {\n\tstruct drm_vmw_surface_create_req rep;\n\tstruct drm_vmw_surface_arg req;\n};\n\n \n \n\n \n \n\n \n\n#define DRM_VMW_EXECBUF_VERSION 2\n\n#define DRM_VMW_EXECBUF_FLAG_IMPORT_FENCE_FD (1 << 0)\n#define DRM_VMW_EXECBUF_FLAG_EXPORT_FENCE_FD (1 << 1)\n\nstruct drm_vmw_execbuf_arg {\n\t__u64 commands;\n\t__u32 command_size;\n\t__u32 throttle_us;\n\t__u64 fence_rep;\n\t__u32 version;\n\t__u32 flags;\n\t__u32 context_handle;\n\t__s32 imported_fence_fd;\n};\n\n \n\nstruct drm_vmw_fence_rep {\n\t__u32 handle;\n\t__u32 mask;\n\t__u32 seqno;\n\t__u32 passed_seqno;\n\t__s32 fd;\n\t__s32 error;\n};\n\n \n \n\n \n\nstruct drm_vmw_alloc_bo_req {\n\t__u32 size;\n\t__u32 pad64;\n};\n#define drm_vmw_alloc_dmabuf_req drm_vmw_alloc_bo_req\n\n \n\nstruct drm_vmw_bo_rep {\n\t__u64 map_handle;\n\t__u32 handle;\n\t__u32 cur_gmr_id;\n\t__u32 cur_gmr_offset;\n\t__u32 pad64;\n};\n#define drm_vmw_dmabuf_rep drm_vmw_bo_rep\n\n \n\nunion drm_vmw_alloc_bo_arg {\n\tstruct drm_vmw_alloc_bo_req req;\n\tstruct drm_vmw_bo_rep rep;\n};\n#define drm_vmw_alloc_dmabuf_arg drm_vmw_alloc_bo_arg\n\n \n \n\n \n\nstruct drm_vmw_rect {\n\t__s32 x;\n\t__s32 y;\n\t__u32 w;\n\t__u32 h;\n};\n\n \n\nstruct drm_vmw_control_stream_arg {\n\t__u32 stream_id;\n\t__u32 enabled;\n\n\t__u32 flags;\n\t__u32 color_key;\n\n\t__u32 handle;\n\t__u32 offset;\n\t__s32 format;\n\t__u32 size;\n\t__u32 width;\n\t__u32 height;\n\t__u32 pitch[3];\n\n\t__u32 pad64;\n\tstruct drm_vmw_rect src;\n\tstruct drm_vmw_rect dst;\n};\n\n \n \n\n#define DRM_VMW_CURSOR_BYPASS_ALL    (1 << 0)\n#define DRM_VMW_CURSOR_BYPASS_FLAGS       (1)\n\n \n\nstruct drm_vmw_cursor_bypass_arg {\n\t__u32 flags;\n\t__u32 crtc_id;\n\t__s32 xpos;\n\t__s32 ypos;\n\t__s32 xhot;\n\t__s32 yhot;\n};\n\n \n \n\n \n\nstruct drm_vmw_stream_arg {\n\t__u32 stream_id;\n\t__u32 pad64;\n};\n\n \n \n\n \n \n\n \n\nstruct drm_vmw_get_3d_cap_arg {\n\t__u64 buffer;\n\t__u32 max_size;\n\t__u32 pad64;\n};\n\n \n \n\n#define DRM_VMW_FENCE_FLAG_EXEC   (1 << 0)\n#define DRM_VMW_FENCE_FLAG_QUERY  (1 << 1)\n\n#define DRM_VMW_WAIT_OPTION_UNREF (1 << 0)\n\n \n\nstruct drm_vmw_fence_wait_arg {\n\t__u32 handle;\n\t__s32  cookie_valid;\n\t__u64 kernel_cookie;\n\t__u64 timeout_us;\n\t__s32 lazy;\n\t__s32 flags;\n\t__s32 wait_options;\n\t__s32 pad64;\n};\n\n \n \n\n \n\nstruct drm_vmw_fence_signaled_arg {\n\t __u32 handle;\n\t __u32 flags;\n\t __s32 signaled;\n\t __u32 passed_seqno;\n\t __u32 signaled_flags;\n\t __u32 pad64;\n};\n\n \n \n\n \n\nstruct drm_vmw_fence_arg {\n\t __u32 handle;\n\t __u32 pad64;\n};\n\n\n \n \n\n \n#define DRM_VMW_EVENT_FENCE_SIGNALED 0x80000000\n\nstruct drm_vmw_event_fence {\n\tstruct drm_event base;\n\t__u64 user_data;\n\t__u32 tv_sec;\n\t__u32 tv_usec;\n};\n\n \n \n#define DRM_VMW_FE_FLAG_REQ_TIME (1 << 0)\n\n \nstruct drm_vmw_fence_event_arg {\n\t__u64 fence_rep;\n\t__u64 user_data;\n\t__u32 handle;\n\t__u32 flags;\n};\n\n\n \n \n\n \n\nstruct drm_vmw_present_arg {\n\t__u32 fb_id;\n\t__u32 sid;\n\t__s32 dest_x;\n\t__s32 dest_y;\n\t__u64 clips_ptr;\n\t__u32 num_clips;\n\t__u32 pad64;\n};\n\n\n \n \n\n \n\nstruct drm_vmw_present_readback_arg {\n\t __u32 fb_id;\n\t __u32 num_clips;\n\t __u64 clips_ptr;\n\t __u64 fence_rep;\n};\n\n \n \n\n \nstruct drm_vmw_update_layout_arg {\n\t__u32 num_outputs;\n\t__u32 pad64;\n\t__u64 rects;\n};\n\n\n \n \n\n \nenum drm_vmw_shader_type {\n\tdrm_vmw_shader_type_vs = 0,\n\tdrm_vmw_shader_type_ps,\n};\n\n\n \nstruct drm_vmw_shader_create_arg {\n\tenum drm_vmw_shader_type shader_type;\n\t__u32 size;\n\t__u32 buffer_handle;\n\t__u32 shader_handle;\n\t__u64 offset;\n};\n\n \n \n\n \nstruct drm_vmw_shader_arg {\n\t__u32 handle;\n\t__u32 pad64;\n};\n\n \n \n\n \nenum drm_vmw_surface_flags {\n\tdrm_vmw_surface_flag_shareable = (1 << 0),\n\tdrm_vmw_surface_flag_scanout = (1 << 1),\n\tdrm_vmw_surface_flag_create_buffer = (1 << 2),\n\tdrm_vmw_surface_flag_coherent = (1 << 3),\n};\n\n \nstruct drm_vmw_gb_surface_create_req {\n\t__u32 svga3d_flags;\n\t__u32 format;\n\t__u32 mip_levels;\n\tenum drm_vmw_surface_flags drm_surface_flags;\n\t__u32 multisample_count;\n\t__u32 autogen_filter;\n\t__u32 buffer_handle;\n\t__u32 array_size;\n\tstruct drm_vmw_size base_size;\n};\n\n \nstruct drm_vmw_gb_surface_create_rep {\n\t__u32 handle;\n\t__u32 backup_size;\n\t__u32 buffer_handle;\n\t__u32 buffer_size;\n\t__u64 buffer_map_handle;\n};\n\n \nunion drm_vmw_gb_surface_create_arg {\n\tstruct drm_vmw_gb_surface_create_rep rep;\n\tstruct drm_vmw_gb_surface_create_req req;\n};\n\n \n \n\n \nstruct drm_vmw_gb_surface_ref_rep {\n\tstruct drm_vmw_gb_surface_create_req creq;\n\tstruct drm_vmw_gb_surface_create_rep crep;\n};\n\n \nunion drm_vmw_gb_surface_reference_arg {\n\tstruct drm_vmw_gb_surface_ref_rep rep;\n\tstruct drm_vmw_surface_arg req;\n};\n\n\n \n \n\n \nenum drm_vmw_synccpu_flags {\n\tdrm_vmw_synccpu_read = (1 << 0),\n\tdrm_vmw_synccpu_write = (1 << 1),\n\tdrm_vmw_synccpu_dontblock = (1 << 2),\n\tdrm_vmw_synccpu_allow_cs = (1 << 3)\n};\n\n \nenum drm_vmw_synccpu_op {\n\tdrm_vmw_synccpu_grab,\n\tdrm_vmw_synccpu_release\n};\n\n \nstruct drm_vmw_synccpu_arg {\n\tenum drm_vmw_synccpu_op op;\n\tenum drm_vmw_synccpu_flags flags;\n\t__u32 handle;\n\t__u32 pad64;\n};\n\n \n \nenum drm_vmw_extended_context {\n\tdrm_vmw_context_legacy,\n\tdrm_vmw_context_dx\n};\n\n \nunion drm_vmw_extended_context_arg {\n\tenum drm_vmw_extended_context req;\n\tstruct drm_vmw_context_arg rep;\n};\n\n \n \n\n \nstruct drm_vmw_handle_close_arg {\n\t__u32 handle;\n\t__u32 pad64;\n};\n#define drm_vmw_unref_dmabuf_arg drm_vmw_handle_close_arg\n\n \n \n\n \nenum drm_vmw_surface_version {\n\tdrm_vmw_gb_surface_v1,\n};\n\n \nstruct drm_vmw_gb_surface_create_ext_req {\n\tstruct drm_vmw_gb_surface_create_req base;\n\tenum drm_vmw_surface_version version;\n\t__u32 svga3d_flags_upper_32_bits;\n\t__u32 multisample_pattern;\n\t__u32 quality_level;\n\t__u32 buffer_byte_stride;\n\t__u32 must_be_zero;\n};\n\n \nunion drm_vmw_gb_surface_create_ext_arg {\n\tstruct drm_vmw_gb_surface_create_rep rep;\n\tstruct drm_vmw_gb_surface_create_ext_req req;\n};\n\n \n \n\n \nstruct drm_vmw_gb_surface_ref_ext_rep {\n\tstruct drm_vmw_gb_surface_create_ext_req creq;\n\tstruct drm_vmw_gb_surface_create_rep crep;\n};\n\n \nunion drm_vmw_gb_surface_reference_ext_arg {\n\tstruct drm_vmw_gb_surface_ref_ext_rep rep;\n\tstruct drm_vmw_surface_arg req;\n};\n\n \nstruct drm_vmw_msg_arg {\n\t__u64 send;\n\t__u64 receive;\n\t__s32 send_only;\n\t__u32 receive_len;\n};\n\n \nstruct drm_vmw_mksstat_add_arg {\n\t__u64 stat;\n\t__u64 info;\n\t__u64 strs;\n\t__u64 stat_len;\n\t__u64 info_len;\n\t__u64 strs_len;\n\t__u64 description;\n\t__u64 id;\n};\n\n \nstruct drm_vmw_mksstat_remove_arg {\n\t__u64 id;\n};\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}