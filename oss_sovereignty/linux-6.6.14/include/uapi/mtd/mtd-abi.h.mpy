{
  "module_name": "mtd-abi.h",
  "hash_id": "032d24057a0e1efc8580d09129f4f4e0f2328cba1970a9d37b090c2867effe3f",
  "original_prompt": "Ingested from linux-6.6.14/include/uapi/mtd/mtd-abi.h",
  "human_readable_source": " \n \n\n#ifndef __MTD_ABI_H__\n#define __MTD_ABI_H__\n\n#include <linux/types.h>\n\nstruct erase_info_user {\n\t__u32 start;\n\t__u32 length;\n};\n\nstruct erase_info_user64 {\n\t__u64 start;\n\t__u64 length;\n};\n\nstruct mtd_oob_buf {\n\t__u32 start;\n\t__u32 length;\n\tunsigned char __user *ptr;\n};\n\nstruct mtd_oob_buf64 {\n\t__u64 start;\n\t__u32 pad;\n\t__u32 length;\n\t__u64 usr_ptr;\n};\n\n \nenum {\n\tMTD_OPS_PLACE_OOB = 0,\n\tMTD_OPS_AUTO_OOB = 1,\n\tMTD_OPS_RAW = 2,\n};\n\n \nstruct mtd_write_req {\n\t__u64 start;\n\t__u64 len;\n\t__u64 ooblen;\n\t__u64 usr_data;\n\t__u64 usr_oob;\n\t__u8 mode;\n\t__u8 padding[7];\n};\n\n \nstruct mtd_read_req_ecc_stats {\n\t__u32 uncorrectable_errors;\n\t__u32 corrected_bitflips;\n\t__u32 max_bitflips;\n};\n\n \nstruct mtd_read_req {\n\t__u64 start;\n\t__u64 len;\n\t__u64 ooblen;\n\t__u64 usr_data;\n\t__u64 usr_oob;\n\t__u8 mode;\n\t__u8 padding[7];\n\tstruct mtd_read_req_ecc_stats ecc_stats;\n};\n\n#define MTD_ABSENT\t\t0\n#define MTD_RAM\t\t\t1\n#define MTD_ROM\t\t\t2\n#define MTD_NORFLASH\t\t3\n#define MTD_NANDFLASH\t\t4\t \n#define MTD_DATAFLASH\t\t6\n#define MTD_UBIVOLUME\t\t7\n#define MTD_MLCNANDFLASH\t8\t \n\n#define MTD_WRITEABLE\t\t0x400\t \n#define MTD_BIT_WRITEABLE\t0x800\t \n#define MTD_NO_ERASE\t\t0x1000\t \n#define MTD_POWERUP_LOCK\t0x2000\t \n#define MTD_SLC_ON_MLC_EMULATION 0x4000\t \n\n \n#define MTD_CAP_ROM\t\t0\n#define MTD_CAP_RAM\t\t(MTD_WRITEABLE | MTD_BIT_WRITEABLE | MTD_NO_ERASE)\n#define MTD_CAP_NORFLASH\t(MTD_WRITEABLE | MTD_BIT_WRITEABLE)\n#define MTD_CAP_NANDFLASH\t(MTD_WRITEABLE)\n#define MTD_CAP_NVRAM\t\t(MTD_WRITEABLE | MTD_BIT_WRITEABLE | MTD_NO_ERASE)\n\n \n#define MTD_NANDECC_OFF\t\t0\t \n#define MTD_NANDECC_PLACE\t1\t \n#define MTD_NANDECC_AUTOPLACE\t2\t \n#define MTD_NANDECC_PLACEONLY\t3\t \n#define MTD_NANDECC_AUTOPL_USR \t4\t \n\n \n#define MTD_OTP_OFF\t\t0\n#define MTD_OTP_FACTORY\t\t1\n#define MTD_OTP_USER\t\t2\n\nstruct mtd_info_user {\n\t__u8 type;\n\t__u32 flags;\n\t__u32 size;\t \n\t__u32 erasesize;\n\t__u32 writesize;\n\t__u32 oobsize;\t \n\t__u64 padding;\t \n};\n\nstruct region_info_user {\n\t__u32 offset;\t\t \n\t__u32 erasesize;\t \n\t__u32 numblocks;\t \n\t__u32 regionindex;\n};\n\nstruct otp_info {\n\t__u32 start;\n\t__u32 length;\n\t__u32 locked;\n};\n\n \n\n \n#define MEMGETINFO\t\t_IOR('M', 1, struct mtd_info_user)\n \n#define MEMERASE\t\t_IOW('M', 2, struct erase_info_user)\n \n#define MEMWRITEOOB\t\t_IOWR('M', 3, struct mtd_oob_buf)\n \n#define MEMREADOOB\t\t_IOWR('M', 4, struct mtd_oob_buf)\n \n#define MEMLOCK\t\t\t_IOW('M', 5, struct erase_info_user)\n \n#define MEMUNLOCK\t\t_IOW('M', 6, struct erase_info_user)\n \n#define MEMGETREGIONCOUNT\t_IOR('M', 7, int)\n \n#define MEMGETREGIONINFO\t_IOWR('M', 8, struct region_info_user)\n \n#define MEMGETOOBSEL\t\t_IOR('M', 10, struct nand_oobinfo)\n \n#define MEMGETBADBLOCK\t\t_IOW('M', 11, __kernel_loff_t)\n \n#define MEMSETBADBLOCK\t\t_IOW('M', 12, __kernel_loff_t)\n \n#define OTPSELECT\t\t_IOR('M', 13, int)\n \n#define OTPGETREGIONCOUNT\t_IOW('M', 14, int)\n \n#define OTPGETREGIONINFO\t_IOW('M', 15, struct otp_info)\n \n#define OTPLOCK\t\t\t_IOR('M', 16, struct otp_info)\n \n#define ECCGETLAYOUT\t\t_IOR('M', 17, struct nand_ecclayout_user)\n \n#define ECCGETSTATS\t\t_IOR('M', 18, struct mtd_ecc_stats)\n \n#define MTDFILEMODE\t\t_IO('M', 19)\n \n#define MEMERASE64\t\t_IOW('M', 20, struct erase_info_user64)\n \n#define MEMWRITEOOB64\t\t_IOWR('M', 21, struct mtd_oob_buf64)\n \n#define MEMREADOOB64\t\t_IOWR('M', 22, struct mtd_oob_buf64)\n \n#define MEMISLOCKED\t\t_IOR('M', 23, struct erase_info_user)\n \n#define MEMWRITE\t\t_IOWR('M', 24, struct mtd_write_req)\n \n#define OTPERASE\t\t_IOW('M', 25, struct otp_info)\n \n#define MEMREAD\t\t\t_IOWR('M', 26, struct mtd_read_req)\n\n \nstruct nand_oobinfo {\n\t__u32 useecc;\n\t__u32 eccbytes;\n\t__u32 oobfree[8][2];\n\t__u32 eccpos[32];\n};\n\nstruct nand_oobfree {\n\t__u32 offset;\n\t__u32 length;\n};\n\n#define MTD_MAX_OOBFREE_ENTRIES\t8\n#define MTD_MAX_ECCPOS_ENTRIES\t64\n \nstruct nand_ecclayout_user {\n\t__u32 eccbytes;\n\t__u32 eccpos[MTD_MAX_ECCPOS_ENTRIES];\n\t__u32 oobavail;\n\tstruct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];\n};\n\n \nstruct mtd_ecc_stats {\n\t__u32 corrected;\n\t__u32 failed;\n\t__u32 badblocks;\n\t__u32 bbtblocks;\n};\n\n \nenum mtd_file_modes {\n\tMTD_FILE_MODE_NORMAL = MTD_OTP_OFF,\n\tMTD_FILE_MODE_OTP_FACTORY = MTD_OTP_FACTORY,\n\tMTD_FILE_MODE_OTP_USER = MTD_OTP_USER,\n\tMTD_FILE_MODE_RAW,\n};\n\nstatic inline int mtd_type_is_nand_user(const struct mtd_info_user *mtd)\n{\n\treturn mtd->type == MTD_NANDFLASH || mtd->type == MTD_MLCNANDFLASH;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}