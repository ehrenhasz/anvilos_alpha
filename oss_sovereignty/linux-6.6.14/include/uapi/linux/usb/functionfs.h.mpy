{
  "module_name": "functionfs.h",
  "hash_id": "619989cce04143dfd24e483c9592c384253c1d6b397f30fb03479a7d090c0112",
  "original_prompt": "Ingested from linux-6.6.14/include/uapi/linux/usb/functionfs.h",
  "human_readable_source": " \n#ifndef _UAPI__LINUX_FUNCTIONFS_H__\n#define _UAPI__LINUX_FUNCTIONFS_H__\n\n\n#include <linux/types.h>\n#include <linux/ioctl.h>\n\n#include <linux/usb/ch9.h>\n\n\nenum {\n\tFUNCTIONFS_DESCRIPTORS_MAGIC = 1,\n\tFUNCTIONFS_STRINGS_MAGIC = 2,\n\tFUNCTIONFS_DESCRIPTORS_MAGIC_V2 = 3,\n};\n\nenum functionfs_flags {\n\tFUNCTIONFS_HAS_FS_DESC = 1,\n\tFUNCTIONFS_HAS_HS_DESC = 2,\n\tFUNCTIONFS_HAS_SS_DESC = 4,\n\tFUNCTIONFS_HAS_MS_OS_DESC = 8,\n\tFUNCTIONFS_VIRTUAL_ADDR = 16,\n\tFUNCTIONFS_EVENTFD = 32,\n\tFUNCTIONFS_ALL_CTRL_RECIP = 64,\n\tFUNCTIONFS_CONFIG0_SETUP = 128,\n};\n\n \nstruct usb_endpoint_descriptor_no_audio {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bEndpointAddress;\n\t__u8  bmAttributes;\n\t__le16 wMaxPacketSize;\n\t__u8  bInterval;\n} __attribute__((packed));\n\nstruct usb_functionfs_descs_head_v2 {\n\t__le32 magic;\n\t__le32 length;\n\t__le32 flags;\n\t \n} __attribute__((packed));\n\n \nstruct usb_functionfs_descs_head {\n\t__le32 magic;\n\t__le32 length;\n\t__le32 fs_count;\n\t__le32 hs_count;\n} __attribute__((packed, deprecated));\n\n \nstruct usb_os_desc_header {\n\t__u8\tinterface;\n\t__le32\tdwLength;\n\t__le16\tbcdVersion;\n\t__le16\twIndex;\n\tunion {\n\t\tstruct {\n\t\t\t__u8\tbCount;\n\t\t\t__u8\tReserved;\n\t\t};\n\t\t__le16\twCount;\n\t};\n} __attribute__((packed));\n\nstruct usb_ext_compat_desc {\n\t__u8\tbFirstInterfaceNumber;\n\t__u8\tReserved1;\n\t__u8\tCompatibleID[8];\n\t__u8\tSubCompatibleID[8];\n\t__u8\tReserved2[6];\n};\n\nstruct usb_ext_prop_desc {\n\t__le32\tdwSize;\n\t__le32\tdwPropertyDataType;\n\t__le16\twPropertyNameLength;\n} __attribute__((packed));\n\n#ifndef __KERNEL__\n\n \n\nstruct usb_functionfs_strings_head {\n\t__le32 magic;\n\t__le32 length;\n\t__le32 str_count;\n\t__le32 lang_count;\n} __attribute__((packed));\n\n \n\n#endif\n\n\n \n\nenum usb_functionfs_event_type {\n\tFUNCTIONFS_BIND,\n\tFUNCTIONFS_UNBIND,\n\n\tFUNCTIONFS_ENABLE,\n\tFUNCTIONFS_DISABLE,\n\n\tFUNCTIONFS_SETUP,\n\n\tFUNCTIONFS_SUSPEND,\n\tFUNCTIONFS_RESUME\n};\n\n \nstruct usb_functionfs_event {\n\tunion {\n\t\t \n\t\tstruct usb_ctrlrequest\tsetup;\n\t} __attribute__((packed)) u;\n\n\t \n\t__u8\t\t\t\ttype;\n\t__u8\t\t\t\t_pad[3];\n} __attribute__((packed));\n\n\n \n \n\n \n#define\tFUNCTIONFS_FIFO_STATUS\t_IO('g', 1)\n\n \n#define\tFUNCTIONFS_FIFO_FLUSH\t_IO('g', 2)\n\n \n#define\tFUNCTIONFS_CLEAR_HALT\t_IO('g', 3)\n\n \n\n \n#define\tFUNCTIONFS_INTERFACE_REVMAP\t_IO('g', 128)\n\n \n#define\tFUNCTIONFS_ENDPOINT_REVMAP\t_IO('g', 129)\n\n \n#define\tFUNCTIONFS_ENDPOINT_DESC\t_IOR('g', 130, \\\n\t\t\t\t\t     struct usb_endpoint_descriptor)\n\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}