{
  "module_name": "vboxguest.h",
  "hash_id": "0f6f16baabee3a7a47c30dd1ccd7a81ab84ca1b8a42ed7fa24c3bc5d23aa1fad",
  "original_prompt": "Ingested from linux-6.6.14/include/uapi/linux/vboxguest.h",
  "human_readable_source": " \n \n\n#ifndef __UAPI_VBOXGUEST_H__\n#define __UAPI_VBOXGUEST_H__\n\n#include <asm/bitsperlong.h>\n#include <linux/ioctl.h>\n#include <linux/vbox_err.h>\n#include <linux/vbox_vmmdev_types.h>\n\n \n#define VBG_IOCTL_HDR_VERSION\t\t0x10001\n \n#define VBG_IOCTL_HDR_TYPE_DEFAULT\t\t0\n\n \nstruct vbg_ioctl_hdr {\n\t \n\t__u32 size_in;\n\t \n\t__u32 version;\n\t \n\t__u32 type;\n\t \n\t__s32 rc;\n\t \n\t__u32 size_out;\n\t \n\t__u32 reserved;\n};\nVMMDEV_ASSERT_SIZE(vbg_ioctl_hdr, 24);\n\n\n \n#define VBG_IOC_VERSION\t\t0x00010000u\n\n \nstruct vbg_ioctl_driver_version_info {\n\t \n\tstruct vbg_ioctl_hdr hdr;\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\t__u32 req_version;\n\t\t\t \n\t\t\t__u32 min_version;\n\t\t\t \n\t\t\t__u32 reserved1;\n\t\t\t \n\t\t\t__u32 reserved2;\n\t\t} in;\n\t\tstruct {\n\t\t\t \n\t\t\t__u32 session_version;\n\t\t\t \n\t\t\t__u32 driver_version;\n\t\t\t \n\t\t\t__u32 driver_revision;\n\t\t\t \n\t\t\t__u32 reserved1;\n\t\t\t \n\t\t\t__u32 reserved2;\n\t\t} out;\n\t} u;\n};\nVMMDEV_ASSERT_SIZE(vbg_ioctl_driver_version_info, 24 + 20);\n\n#define VBG_IOCTL_DRIVER_VERSION_INFO \\\n\t_IOWR('V', 0, struct vbg_ioctl_driver_version_info)\n\n\n \n#define VBG_IOCTL_VMMDEV_REQUEST(s)\t_IOC(_IOC_READ | _IOC_WRITE, 'V', 2, s)\n\n\n \n#define VBG_IOCTL_VMMDEV_REQUEST_BIG\t_IO('V', 3)\n\n\n \nstruct vbg_ioctl_hgcm_connect {\n\tstruct vbg_ioctl_hdr hdr;\n\tunion {\n\t\tstruct {\n\t\t\tstruct vmmdev_hgcm_service_location loc;\n\t\t} in;\n\t\tstruct {\n\t\t\t__u32 client_id;\n\t\t} out;\n\t} u;\n};\nVMMDEV_ASSERT_SIZE(vbg_ioctl_hgcm_connect, 24 + 132);\n\n#define VBG_IOCTL_HGCM_CONNECT \\\n\t_IOWR('V', 4, struct vbg_ioctl_hgcm_connect)\n\n\n \nstruct vbg_ioctl_hgcm_disconnect {\n\tstruct vbg_ioctl_hdr hdr;\n\tunion {\n\t\tstruct {\n\t\t\t__u32 client_id;\n\t\t} in;\n\t} u;\n};\nVMMDEV_ASSERT_SIZE(vbg_ioctl_hgcm_disconnect, 24 + 4);\n\n#define VBG_IOCTL_HGCM_DISCONNECT \\\n\t_IOWR('V', 5, struct vbg_ioctl_hgcm_disconnect)\n\n\n \nstruct vbg_ioctl_hgcm_call {\n\t \n\tstruct vbg_ioctl_hdr hdr;\n\t \n\t__u32 client_id;\n\t \n\t__u32 function;\n\t \n\t__u32 timeout_ms;\n\t \n\t__u8 interruptible;\n\t \n\t__u8 reserved;\n\t \n\t__u16 parm_count;\n\t \n};\nVMMDEV_ASSERT_SIZE(vbg_ioctl_hgcm_call, 24 + 16);\n\n#define VBG_IOCTL_HGCM_CALL_32(s)\t_IOC(_IOC_READ | _IOC_WRITE, 'V', 6, s)\n#define VBG_IOCTL_HGCM_CALL_64(s)\t_IOC(_IOC_READ | _IOC_WRITE, 'V', 7, s)\n#if __BITS_PER_LONG == 64\n#define VBG_IOCTL_HGCM_CALL(s)\t\tVBG_IOCTL_HGCM_CALL_64(s)\n#else\n#define VBG_IOCTL_HGCM_CALL(s)\t\tVBG_IOCTL_HGCM_CALL_32(s)\n#endif\n\n\n \nstruct vbg_ioctl_log {\n\t \n\tstruct vbg_ioctl_hdr hdr;\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\tchar msg[1];\n\t\t} in;\n\t} u;\n};\n\n#define VBG_IOCTL_LOG(s)\t\t_IO('V', 9)\n\n\n \nstruct vbg_ioctl_wait_for_events {\n\t \n\tstruct vbg_ioctl_hdr hdr;\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\t__u32 timeout_ms;\n\t\t\t \n\t\t\t__u32 events;\n\t\t} in;\n\t\tstruct {\n\t\t\t \n\t\t\t__u32 events;\n\t\t} out;\n\t} u;\n};\nVMMDEV_ASSERT_SIZE(vbg_ioctl_wait_for_events, 24 + 8);\n\n#define VBG_IOCTL_WAIT_FOR_EVENTS \\\n\t_IOWR('V', 10, struct vbg_ioctl_wait_for_events)\n\n\n \n#define VBG_IOCTL_INTERRUPT_ALL_WAIT_FOR_EVENTS \\\n\t_IOWR('V', 11, struct vbg_ioctl_hdr)\n\n\n \nstruct vbg_ioctl_change_filter {\n\t \n\tstruct vbg_ioctl_hdr hdr;\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\t__u32 or_mask;\n\t\t\t \n\t\t\t__u32 not_mask;\n\t\t} in;\n\t} u;\n};\nVMMDEV_ASSERT_SIZE(vbg_ioctl_change_filter, 24 + 8);\n\n \n#define VBG_IOCTL_CHANGE_FILTER_MASK \\\n\t_IOWR('V', 12, struct vbg_ioctl_change_filter)\n\n\n \nstruct vbg_ioctl_acquire_guest_caps {\n\t \n\tstruct vbg_ioctl_hdr hdr;\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\t__u32 flags;\n\t\t\t \n\t\t\t__u32 or_mask;\n\t\t\t \n\t\t\t__u32 not_mask;\n\t\t} in;\n\t} u;\n};\nVMMDEV_ASSERT_SIZE(vbg_ioctl_acquire_guest_caps, 24 + 12);\n\n#define VBGL_IOC_AGC_FLAGS_CONFIG_ACQUIRE_MODE\t\t0x00000001\n#define VBGL_IOC_AGC_FLAGS_VALID_MASK\t\t\t0x00000001\n\n#define VBG_IOCTL_ACQUIRE_GUEST_CAPABILITIES \\\n\t_IOWR('V', 13, struct vbg_ioctl_acquire_guest_caps)\n\n\n \nstruct vbg_ioctl_set_guest_caps {\n\t \n\tstruct vbg_ioctl_hdr hdr;\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\t__u32 or_mask;\n\t\t\t \n\t\t\t__u32 not_mask;\n\t\t} in;\n\t\tstruct {\n\t\t\t \n\t\t\t__u32 session_caps;\n\t\t\t \n\t\t\t__u32 global_caps;\n\t\t} out;\n\t} u;\n};\nVMMDEV_ASSERT_SIZE(vbg_ioctl_set_guest_caps, 24 + 8);\n\n#define VBG_IOCTL_CHANGE_GUEST_CAPABILITIES \\\n\t_IOWR('V', 14, struct vbg_ioctl_set_guest_caps)\n\n\n \nstruct vbg_ioctl_check_balloon {\n\t \n\tstruct vbg_ioctl_hdr hdr;\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\t__u32 balloon_chunks;\n\t\t\t \n\t\t\t__u8 handle_in_r3;\n\t\t\t \n\t\t\t__u8 padding[3];\n\t\t} out;\n\t} u;\n};\nVMMDEV_ASSERT_SIZE(vbg_ioctl_check_balloon, 24 + 8);\n\n \n#define VBG_IOCTL_CHECK_BALLOON \\\n\t_IOWR('V', 17, struct vbg_ioctl_check_balloon)\n\n\n \nstruct vbg_ioctl_write_coredump {\n\tstruct vbg_ioctl_hdr hdr;\n\tunion {\n\t\tstruct {\n\t\t\t__u32 flags;  \n\t\t} in;\n\t} u;\n};\nVMMDEV_ASSERT_SIZE(vbg_ioctl_write_coredump, 24 + 4);\n\n#define VBG_IOCTL_WRITE_CORE_DUMP \\\n\t_IOWR('V', 19, struct vbg_ioctl_write_coredump)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}