{
  "module_name": "kfd_ioctl.h",
  "hash_id": "f5dd87ec37d34804f9881fa5569e6997e07ac66c2d47e0d0585568b74a71eed3",
  "original_prompt": "Ingested from linux-6.6.14/include/uapi/linux/kfd_ioctl.h",
  "human_readable_source": " \n\n#ifndef KFD_IOCTL_H_INCLUDED\n#define KFD_IOCTL_H_INCLUDED\n\n#include <drm/drm.h>\n#include <linux/ioctl.h>\n\n \n#define KFD_IOCTL_MAJOR_VERSION 1\n#define KFD_IOCTL_MINOR_VERSION 14\n\nstruct kfd_ioctl_get_version_args {\n\t__u32 major_version;\t \n\t__u32 minor_version;\t \n};\n\n \n#define KFD_IOC_QUEUE_TYPE_COMPUTE\t\t0x0\n#define KFD_IOC_QUEUE_TYPE_SDMA\t\t\t0x1\n#define KFD_IOC_QUEUE_TYPE_COMPUTE_AQL\t\t0x2\n#define KFD_IOC_QUEUE_TYPE_SDMA_XGMI\t\t0x3\n\n#define KFD_MAX_QUEUE_PERCENTAGE\t100\n#define KFD_MAX_QUEUE_PRIORITY\t\t15\n\nstruct kfd_ioctl_create_queue_args {\n\t__u64 ring_base_address;\t \n\t__u64 write_pointer_address;\t \n\t__u64 read_pointer_address;\t \n\t__u64 doorbell_offset;\t \n\n\t__u32 ring_size;\t\t \n\t__u32 gpu_id;\t\t \n\t__u32 queue_type;\t\t \n\t__u32 queue_percentage;\t \n\t__u32 queue_priority;\t \n\t__u32 queue_id;\t\t \n\n\t__u64 eop_buffer_address;\t \n\t__u64 eop_buffer_size;\t \n\t__u64 ctx_save_restore_address;  \n\t__u32 ctx_save_restore_size;\t \n\t__u32 ctl_stack_size;\t\t \n};\n\nstruct kfd_ioctl_destroy_queue_args {\n\t__u32 queue_id;\t\t \n\t__u32 pad;\n};\n\nstruct kfd_ioctl_update_queue_args {\n\t__u64 ring_base_address;\t \n\n\t__u32 queue_id;\t\t \n\t__u32 ring_size;\t\t \n\t__u32 queue_percentage;\t \n\t__u32 queue_priority;\t \n};\n\nstruct kfd_ioctl_set_cu_mask_args {\n\t__u32 queue_id;\t\t \n\t__u32 num_cu_mask;\t\t \n\t__u64 cu_mask_ptr;\t\t \n};\n\nstruct kfd_ioctl_get_queue_wave_state_args {\n\t__u64 ctl_stack_address;\t \n\t__u32 ctl_stack_used_size;\t \n\t__u32 save_area_used_size;\t \n\t__u32 queue_id;\t\t\t \n\t__u32 pad;\n};\n\nstruct kfd_ioctl_get_available_memory_args {\n\t__u64 available;\t \n\t__u32 gpu_id;\t\t \n\t__u32 pad;\n};\n\nstruct kfd_dbg_device_info_entry {\n\t__u64 exception_status;\n\t__u64 lds_base;\n\t__u64 lds_limit;\n\t__u64 scratch_base;\n\t__u64 scratch_limit;\n\t__u64 gpuvm_base;\n\t__u64 gpuvm_limit;\n\t__u32 gpu_id;\n\t__u32 location_id;\n\t__u32 vendor_id;\n\t__u32 device_id;\n\t__u32 revision_id;\n\t__u32 subsystem_vendor_id;\n\t__u32 subsystem_device_id;\n\t__u32 fw_version;\n\t__u32 gfx_target_version;\n\t__u32 simd_count;\n\t__u32 max_waves_per_simd;\n\t__u32 array_count;\n\t__u32 simd_arrays_per_engine;\n\t__u32 num_xcc;\n\t__u32 capability;\n\t__u32 debug_prop;\n};\n\n \n#define KFD_IOC_CACHE_POLICY_COHERENT 0\n#define KFD_IOC_CACHE_POLICY_NONCOHERENT 1\n\nstruct kfd_ioctl_set_memory_policy_args {\n\t__u64 alternate_aperture_base;\t \n\t__u64 alternate_aperture_size;\t \n\n\t__u32 gpu_id;\t\t\t \n\t__u32 default_policy;\t\t \n\t__u32 alternate_policy;\t\t \n\t__u32 pad;\n};\n\n \n\nstruct kfd_ioctl_get_clock_counters_args {\n\t__u64 gpu_clock_counter;\t \n\t__u64 cpu_clock_counter;\t \n\t__u64 system_clock_counter;\t \n\t__u64 system_clock_freq;\t \n\n\t__u32 gpu_id;\t\t \n\t__u32 pad;\n};\n\nstruct kfd_process_device_apertures {\n\t__u64 lds_base;\t\t \n\t__u64 lds_limit;\t\t \n\t__u64 scratch_base;\t\t \n\t__u64 scratch_limit;\t\t \n\t__u64 gpuvm_base;\t\t \n\t__u64 gpuvm_limit;\t\t \n\t__u32 gpu_id;\t\t \n\t__u32 pad;\n};\n\n \n#define NUM_OF_SUPPORTED_GPUS 7\nstruct kfd_ioctl_get_process_apertures_args {\n\tstruct kfd_process_device_apertures\n\t\t\tprocess_apertures[NUM_OF_SUPPORTED_GPUS]; \n\n\t \n\t__u32 num_of_nodes;\n\t__u32 pad;\n};\n\nstruct kfd_ioctl_get_process_apertures_new_args {\n\t \n\t__u64 kfd_process_device_apertures_ptr;\n\t \n\t__u32 num_of_nodes;\n\t__u32 pad;\n};\n\n#define MAX_ALLOWED_NUM_POINTS    100\n#define MAX_ALLOWED_AW_BUFF_SIZE 4096\n#define MAX_ALLOWED_WAC_BUFF_SIZE  128\n\nstruct kfd_ioctl_dbg_register_args {\n\t__u32 gpu_id;\t\t \n\t__u32 pad;\n};\n\nstruct kfd_ioctl_dbg_unregister_args {\n\t__u32 gpu_id;\t\t \n\t__u32 pad;\n};\n\nstruct kfd_ioctl_dbg_address_watch_args {\n\t__u64 content_ptr;\t\t \n\t__u32 gpu_id;\t\t \n\t__u32 buf_size_in_bytes;\t \n};\n\nstruct kfd_ioctl_dbg_wave_control_args {\n\t__u64 content_ptr;\t\t \n\t__u32 gpu_id;\t\t \n\t__u32 buf_size_in_bytes;\t \n};\n\n#define KFD_INVALID_FD     0xffffffff\n\n \n#define KFD_IOC_EVENT_SIGNAL\t\t\t0\n#define KFD_IOC_EVENT_NODECHANGE\t\t1\n#define KFD_IOC_EVENT_DEVICESTATECHANGE\t\t2\n#define KFD_IOC_EVENT_HW_EXCEPTION\t\t3\n#define KFD_IOC_EVENT_SYSTEM_EVENT\t\t4\n#define KFD_IOC_EVENT_DEBUG_EVENT\t\t5\n#define KFD_IOC_EVENT_PROFILE_EVENT\t\t6\n#define KFD_IOC_EVENT_QUEUE_EVENT\t\t7\n#define KFD_IOC_EVENT_MEMORY\t\t\t8\n\n#define KFD_IOC_WAIT_RESULT_COMPLETE\t\t0\n#define KFD_IOC_WAIT_RESULT_TIMEOUT\t\t1\n#define KFD_IOC_WAIT_RESULT_FAIL\t\t2\n\n#define KFD_SIGNAL_EVENT_LIMIT\t\t\t4096\n\n \n#define KFD_HW_EXCEPTION_WHOLE_GPU_RESET\t0\n#define KFD_HW_EXCEPTION_PER_ENGINE_RESET\t1\n\n \n#define KFD_HW_EXCEPTION_GPU_HANG\t0\n#define KFD_HW_EXCEPTION_ECC\t\t1\n\n \n#define KFD_MEM_ERR_NO_RAS\t\t0\n#define KFD_MEM_ERR_SRAM_ECC\t\t1\n#define KFD_MEM_ERR_POISON_CONSUMED\t2\n#define KFD_MEM_ERR_GPU_HANG\t\t3\n\nstruct kfd_ioctl_create_event_args {\n\t__u64 event_page_offset;\t \n\t__u32 event_trigger_data;\t \n\t__u32 event_type;\t\t \n\t__u32 auto_reset;\t\t \n\t__u32 node_id;\t\t \n\t__u32 event_id;\t\t \n\t__u32 event_slot_index;\t \n};\n\nstruct kfd_ioctl_destroy_event_args {\n\t__u32 event_id;\t\t \n\t__u32 pad;\n};\n\nstruct kfd_ioctl_set_event_args {\n\t__u32 event_id;\t\t \n\t__u32 pad;\n};\n\nstruct kfd_ioctl_reset_event_args {\n\t__u32 event_id;\t\t \n\t__u32 pad;\n};\n\nstruct kfd_memory_exception_failure {\n\t__u32 NotPresent;\t \n\t__u32 ReadOnly;\t \n\t__u32 NoExecute;\t \n\t__u32 imprecise;\t \n};\n\n \nstruct kfd_hsa_memory_exception_data {\n\tstruct kfd_memory_exception_failure failure;\n\t__u64 va;\n\t__u32 gpu_id;\n\t__u32 ErrorType;  \n};\n\n \nstruct kfd_hsa_hw_exception_data {\n\t__u32 reset_type;\n\t__u32 reset_cause;\n\t__u32 memory_lost;\n\t__u32 gpu_id;\n};\n\n \nstruct kfd_hsa_signal_event_data {\n\t__u64 last_event_age;\t \n};\n\n \nstruct kfd_event_data {\n\tunion {\n\t\t \n\t\tstruct kfd_hsa_memory_exception_data memory_exception_data;\n\t\tstruct kfd_hsa_hw_exception_data hw_exception_data;\n\t\t \n\t\tstruct kfd_hsa_signal_event_data signal_event_data;\n\t};\n\t__u64 kfd_event_data_ext;\t \n\t__u32 event_id;\t\t \n\t__u32 pad;\n};\n\nstruct kfd_ioctl_wait_events_args {\n\t__u64 events_ptr;\t\t \n\t__u32 num_events;\t\t \n\t__u32 wait_for_all;\t\t \n\t__u32 timeout;\t\t \n\t__u32 wait_result;\t\t \n};\n\nstruct kfd_ioctl_set_scratch_backing_va_args {\n\t__u64 va_addr;\t \n\t__u32 gpu_id;\t \n\t__u32 pad;\n};\n\nstruct kfd_ioctl_get_tile_config_args {\n\t \n\t__u64 tile_config_ptr;\n\t \n\t__u64 macro_tile_config_ptr;\n\t \n\t__u32 num_tile_configs;\n\t \n\t__u32 num_macro_tile_configs;\n\n\t__u32 gpu_id;\t\t \n\t__u32 gb_addr_config;\t \n\t__u32 num_banks;\t\t \n\t__u32 num_ranks;\t\t \n\t \n};\n\nstruct kfd_ioctl_set_trap_handler_args {\n\t__u64 tba_addr;\t\t \n\t__u64 tma_addr;\t\t \n\t__u32 gpu_id;\t\t \n\t__u32 pad;\n};\n\nstruct kfd_ioctl_acquire_vm_args {\n\t__u32 drm_fd;\t \n\t__u32 gpu_id;\t \n};\n\n \n#define KFD_IOC_ALLOC_MEM_FLAGS_VRAM\t\t(1 << 0)\n#define KFD_IOC_ALLOC_MEM_FLAGS_GTT\t\t(1 << 1)\n#define KFD_IOC_ALLOC_MEM_FLAGS_USERPTR\t\t(1 << 2)\n#define KFD_IOC_ALLOC_MEM_FLAGS_DOORBELL\t(1 << 3)\n#define KFD_IOC_ALLOC_MEM_FLAGS_MMIO_REMAP\t(1 << 4)\n \n#define KFD_IOC_ALLOC_MEM_FLAGS_WRITABLE\t(1 << 31)\n#define KFD_IOC_ALLOC_MEM_FLAGS_EXECUTABLE\t(1 << 30)\n#define KFD_IOC_ALLOC_MEM_FLAGS_PUBLIC\t\t(1 << 29)\n#define KFD_IOC_ALLOC_MEM_FLAGS_NO_SUBSTITUTE\t(1 << 28)\n#define KFD_IOC_ALLOC_MEM_FLAGS_AQL_QUEUE_MEM\t(1 << 27)\n#define KFD_IOC_ALLOC_MEM_FLAGS_COHERENT\t(1 << 26)\n#define KFD_IOC_ALLOC_MEM_FLAGS_UNCACHED\t(1 << 25)\n\n \nstruct kfd_ioctl_alloc_memory_of_gpu_args {\n\t__u64 va_addr;\t\t \n\t__u64 size;\t\t \n\t__u64 handle;\t\t \n\t__u64 mmap_offset;\t \n\t__u32 gpu_id;\t\t \n\t__u32 flags;\n};\n\n \nstruct kfd_ioctl_free_memory_of_gpu_args {\n\t__u64 handle;\t\t \n};\n\n \nstruct kfd_ioctl_map_memory_to_gpu_args {\n\t__u64 handle;\t\t\t \n\t__u64 device_ids_array_ptr;\t \n\t__u32 n_devices;\t\t \n\t__u32 n_success;\t\t \n};\n\n \nstruct kfd_ioctl_unmap_memory_from_gpu_args {\n\t__u64 handle;\t\t\t \n\t__u64 device_ids_array_ptr;\t \n\t__u32 n_devices;\t\t \n\t__u32 n_success;\t\t \n};\n\n \nstruct kfd_ioctl_alloc_queue_gws_args {\n\t__u32 queue_id;\t\t \n\t__u32 num_gws;\t\t \n\t__u32 first_gws;\t \n\t__u32 pad;\n};\n\nstruct kfd_ioctl_get_dmabuf_info_args {\n\t__u64 size;\t\t \n\t__u64 metadata_ptr;\t \n\t__u32 metadata_size;\t \n\t__u32 gpu_id;\t \n\t__u32 flags;\t\t \n\t__u32 dmabuf_fd;\t \n};\n\nstruct kfd_ioctl_import_dmabuf_args {\n\t__u64 va_addr;\t \n\t__u64 handle;\t \n\t__u32 gpu_id;\t \n\t__u32 dmabuf_fd;\t \n};\n\nstruct kfd_ioctl_export_dmabuf_args {\n\t__u64 handle;\t\t \n\t__u32 flags;\t\t \n\t__u32 dmabuf_fd;\t \n};\n\n \nenum kfd_smi_event {\n\tKFD_SMI_EVENT_NONE = 0,  \n\tKFD_SMI_EVENT_VMFAULT = 1,  \n\tKFD_SMI_EVENT_THERMAL_THROTTLE = 2,\n\tKFD_SMI_EVENT_GPU_PRE_RESET = 3,\n\tKFD_SMI_EVENT_GPU_POST_RESET = 4,\n\tKFD_SMI_EVENT_MIGRATE_START = 5,\n\tKFD_SMI_EVENT_MIGRATE_END = 6,\n\tKFD_SMI_EVENT_PAGE_FAULT_START = 7,\n\tKFD_SMI_EVENT_PAGE_FAULT_END = 8,\n\tKFD_SMI_EVENT_QUEUE_EVICTION = 9,\n\tKFD_SMI_EVENT_QUEUE_RESTORE = 10,\n\tKFD_SMI_EVENT_UNMAP_FROM_GPU = 11,\n\n\t \n\tKFD_SMI_EVENT_ALL_PROCESS = 64\n};\n\nenum KFD_MIGRATE_TRIGGERS {\n\tKFD_MIGRATE_TRIGGER_PREFETCH,\n\tKFD_MIGRATE_TRIGGER_PAGEFAULT_GPU,\n\tKFD_MIGRATE_TRIGGER_PAGEFAULT_CPU,\n\tKFD_MIGRATE_TRIGGER_TTM_EVICTION\n};\n\nenum KFD_QUEUE_EVICTION_TRIGGERS {\n\tKFD_QUEUE_EVICTION_TRIGGER_SVM,\n\tKFD_QUEUE_EVICTION_TRIGGER_USERPTR,\n\tKFD_QUEUE_EVICTION_TRIGGER_TTM,\n\tKFD_QUEUE_EVICTION_TRIGGER_SUSPEND,\n\tKFD_QUEUE_EVICTION_CRIU_CHECKPOINT,\n\tKFD_QUEUE_EVICTION_CRIU_RESTORE\n};\n\nenum KFD_SVM_UNMAP_TRIGGERS {\n\tKFD_SVM_UNMAP_TRIGGER_MMU_NOTIFY,\n\tKFD_SVM_UNMAP_TRIGGER_MMU_NOTIFY_MIGRATE,\n\tKFD_SVM_UNMAP_TRIGGER_UNMAP_FROM_CPU\n};\n\n#define KFD_SMI_EVENT_MASK_FROM_INDEX(i) (1ULL << ((i) - 1))\n#define KFD_SMI_EVENT_MSG_SIZE\t96\n\nstruct kfd_ioctl_smi_events_args {\n\t__u32 gpuid;\t \n\t__u32 anon_fd;\t \n};\n\n \n\nenum kfd_criu_op {\n\tKFD_CRIU_OP_PROCESS_INFO,\n\tKFD_CRIU_OP_CHECKPOINT,\n\tKFD_CRIU_OP_UNPAUSE,\n\tKFD_CRIU_OP_RESTORE,\n\tKFD_CRIU_OP_RESUME,\n};\n\n \nstruct kfd_ioctl_criu_args {\n\t__u64 devices;\t\t \n\t__u64 bos;\t\t \n\t__u64 priv_data;\t \n\t__u64 priv_data_size;\t \n\t__u32 num_devices;\t \n\t__u32 num_bos;\t\t \n\t__u32 num_objects;\t \n\t__u32 pid;\t\t \n\t__u32 op;\n};\n\nstruct kfd_criu_device_bucket {\n\t__u32 user_gpu_id;\n\t__u32 actual_gpu_id;\n\t__u32 drm_fd;\n\t__u32 pad;\n};\n\nstruct kfd_criu_bo_bucket {\n\t__u64 addr;\n\t__u64 size;\n\t__u64 offset;\n\t__u64 restored_offset;     \n\t__u32 gpu_id;              \n\t__u32 alloc_flags;\n\t__u32 dmabuf_fd;\n\t__u32 pad;\n};\n\n \n \n\n \nenum kfd_mmio_remap {\n\tKFD_MMIO_REMAP_HDP_MEM_FLUSH_CNTL = 0,\n\tKFD_MMIO_REMAP_HDP_REG_FLUSH_CNTL = 4,\n};\n\n \n#define KFD_IOCTL_SVM_FLAG_HOST_ACCESS 0x00000001\n \n#define KFD_IOCTL_SVM_FLAG_COHERENT    0x00000002\n \n#define KFD_IOCTL_SVM_FLAG_HIVE_LOCAL  0x00000004\n \n#define KFD_IOCTL_SVM_FLAG_GPU_RO      0x00000008\n \n#define KFD_IOCTL_SVM_FLAG_GPU_EXEC    0x00000010\n \n#define KFD_IOCTL_SVM_FLAG_GPU_READ_MOSTLY     0x00000020\n \n#define KFD_IOCTL_SVM_FLAG_GPU_ALWAYS_MAPPED   0x00000040\n\n \nenum kfd_ioctl_svm_op {\n\tKFD_IOCTL_SVM_OP_SET_ATTR,\n\tKFD_IOCTL_SVM_OP_GET_ATTR\n};\n\n \nenum kfd_ioctl_svm_location {\n\tKFD_IOCTL_SVM_LOCATION_SYSMEM = 0,\n\tKFD_IOCTL_SVM_LOCATION_UNDEFINED = 0xffffffff\n};\n\n \nenum kfd_ioctl_svm_attr_type {\n\tKFD_IOCTL_SVM_ATTR_PREFERRED_LOC,\n\tKFD_IOCTL_SVM_ATTR_PREFETCH_LOC,\n\tKFD_IOCTL_SVM_ATTR_ACCESS,\n\tKFD_IOCTL_SVM_ATTR_ACCESS_IN_PLACE,\n\tKFD_IOCTL_SVM_ATTR_NO_ACCESS,\n\tKFD_IOCTL_SVM_ATTR_SET_FLAGS,\n\tKFD_IOCTL_SVM_ATTR_CLR_FLAGS,\n\tKFD_IOCTL_SVM_ATTR_GRANULARITY\n};\n\n \nstruct kfd_ioctl_svm_attribute {\n\t__u32 type;\n\t__u32 value;\n};\n\n \nstruct kfd_ioctl_svm_args {\n\t__u64 start_addr;\n\t__u64 size;\n\t__u32 op;\n\t__u32 nattr;\n\t \n\tstruct kfd_ioctl_svm_attribute attrs[];\n};\n\n \nstruct kfd_ioctl_set_xnack_mode_args {\n\t__s32 xnack_enabled;\n};\n\n \nenum kfd_dbg_trap_override_mode {\n\tKFD_DBG_TRAP_OVERRIDE_OR = 0,\n\tKFD_DBG_TRAP_OVERRIDE_REPLACE = 1\n};\n\n \nenum kfd_dbg_trap_mask {\n\tKFD_DBG_TRAP_MASK_FP_INVALID = 1,\n\tKFD_DBG_TRAP_MASK_FP_INPUT_DENORMAL = 2,\n\tKFD_DBG_TRAP_MASK_FP_DIVIDE_BY_ZERO = 4,\n\tKFD_DBG_TRAP_MASK_FP_OVERFLOW = 8,\n\tKFD_DBG_TRAP_MASK_FP_UNDERFLOW = 16,\n\tKFD_DBG_TRAP_MASK_FP_INEXACT = 32,\n\tKFD_DBG_TRAP_MASK_INT_DIVIDE_BY_ZERO = 64,\n\tKFD_DBG_TRAP_MASK_DBG_ADDRESS_WATCH = 128,\n\tKFD_DBG_TRAP_MASK_DBG_MEMORY_VIOLATION = 256,\n\tKFD_DBG_TRAP_MASK_TRAP_ON_WAVE_START = (1 << 30),\n\tKFD_DBG_TRAP_MASK_TRAP_ON_WAVE_END = (1 << 31)\n};\n\n \nenum kfd_dbg_trap_wave_launch_mode {\n\tKFD_DBG_TRAP_WAVE_LAUNCH_MODE_NORMAL = 0,\n\tKFD_DBG_TRAP_WAVE_LAUNCH_MODE_HALT = 1,\n\tKFD_DBG_TRAP_WAVE_LAUNCH_MODE_DEBUG = 3\n};\n\n \nenum kfd_dbg_trap_address_watch_mode {\n\tKFD_DBG_TRAP_ADDRESS_WATCH_MODE_READ = 0,\n\tKFD_DBG_TRAP_ADDRESS_WATCH_MODE_NONREAD = 1,\n\tKFD_DBG_TRAP_ADDRESS_WATCH_MODE_ATOMIC = 2,\n\tKFD_DBG_TRAP_ADDRESS_WATCH_MODE_ALL = 3\n};\n\n \nenum kfd_dbg_trap_flags {\n\tKFD_DBG_TRAP_FLAG_SINGLE_MEM_OP = 1,\n};\n\n \nenum kfd_dbg_trap_exception_code {\n\tEC_NONE = 0,\n\t \n\tEC_QUEUE_WAVE_ABORT = 1,\n\tEC_QUEUE_WAVE_TRAP = 2,\n\tEC_QUEUE_WAVE_MATH_ERROR = 3,\n\tEC_QUEUE_WAVE_ILLEGAL_INSTRUCTION = 4,\n\tEC_QUEUE_WAVE_MEMORY_VIOLATION = 5,\n\tEC_QUEUE_WAVE_APERTURE_VIOLATION = 6,\n\tEC_QUEUE_PACKET_DISPATCH_DIM_INVALID = 16,\n\tEC_QUEUE_PACKET_DISPATCH_GROUP_SEGMENT_SIZE_INVALID = 17,\n\tEC_QUEUE_PACKET_DISPATCH_CODE_INVALID = 18,\n\tEC_QUEUE_PACKET_RESERVED = 19,\n\tEC_QUEUE_PACKET_UNSUPPORTED = 20,\n\tEC_QUEUE_PACKET_DISPATCH_WORK_GROUP_SIZE_INVALID = 21,\n\tEC_QUEUE_PACKET_DISPATCH_REGISTER_INVALID = 22,\n\tEC_QUEUE_PACKET_VENDOR_UNSUPPORTED = 23,\n\tEC_QUEUE_PREEMPTION_ERROR = 30,\n\tEC_QUEUE_NEW = 31,\n\t \n\tEC_DEVICE_QUEUE_DELETE = 32,\n\tEC_DEVICE_MEMORY_VIOLATION = 33,\n\tEC_DEVICE_RAS_ERROR = 34,\n\tEC_DEVICE_FATAL_HALT = 35,\n\tEC_DEVICE_NEW = 36,\n\t \n\tEC_PROCESS_RUNTIME = 48,\n\tEC_PROCESS_DEVICE_REMOVE = 49,\n\tEC_MAX\n};\n\n \n#define KFD_EC_MASK(ecode)\t(1ULL << (ecode - 1))\n\n \n#define KFD_EC_MASK_QUEUE\t(KFD_EC_MASK(EC_QUEUE_WAVE_ABORT) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_WAVE_TRAP) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_WAVE_MATH_ERROR) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_WAVE_ILLEGAL_INSTRUCTION) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_WAVE_MEMORY_VIOLATION) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_WAVE_APERTURE_VIOLATION) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_PACKET_DISPATCH_DIM_INVALID) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_PACKET_DISPATCH_GROUP_SEGMENT_SIZE_INVALID) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_PACKET_DISPATCH_CODE_INVALID) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_PACKET_RESERVED) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_PACKET_UNSUPPORTED) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_PACKET_DISPATCH_WORK_GROUP_SIZE_INVALID) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_PACKET_DISPATCH_REGISTER_INVALID) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_PACKET_VENDOR_UNSUPPORTED)\t|\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_PREEMPTION_ERROR)\t|\t\\\n\t\t\t\t KFD_EC_MASK(EC_QUEUE_NEW))\n#define KFD_EC_MASK_DEVICE\t(KFD_EC_MASK(EC_DEVICE_QUEUE_DELETE) |\t\t\\\n\t\t\t\t KFD_EC_MASK(EC_DEVICE_RAS_ERROR) |\t\t\\\n\t\t\t\t KFD_EC_MASK(EC_DEVICE_FATAL_HALT) |\t\t\\\n\t\t\t\t KFD_EC_MASK(EC_DEVICE_MEMORY_VIOLATION) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_DEVICE_NEW))\n#define KFD_EC_MASK_PROCESS\t(KFD_EC_MASK(EC_PROCESS_RUNTIME) |\t\\\n\t\t\t\t KFD_EC_MASK(EC_PROCESS_DEVICE_REMOVE))\n\n \n#define KFD_DBG_EC_TYPE_IS_QUEUE(ecode)\t\t\t\t\t\\\n\t\t\t(!!(KFD_EC_MASK(ecode) & KFD_EC_MASK_QUEUE))\n#define KFD_DBG_EC_TYPE_IS_DEVICE(ecode)\t\t\t\t\\\n\t\t\t(!!(KFD_EC_MASK(ecode) & KFD_EC_MASK_DEVICE))\n#define KFD_DBG_EC_TYPE_IS_PROCESS(ecode)\t\t\t\t\\\n\t\t\t(!!(KFD_EC_MASK(ecode) & KFD_EC_MASK_PROCESS))\n\n\n \nenum kfd_dbg_runtime_state {\n\tDEBUG_RUNTIME_STATE_DISABLED = 0,\n\tDEBUG_RUNTIME_STATE_ENABLED = 1,\n\tDEBUG_RUNTIME_STATE_ENABLED_BUSY = 2,\n\tDEBUG_RUNTIME_STATE_ENABLED_ERROR = 3\n};\n\n \nstruct kfd_runtime_info {\n\t__u64 r_debug;\n\t__u32 runtime_state;\n\t__u32 ttmp_setup;\n};\n\n \n#define KFD_RUNTIME_ENABLE_MODE_ENABLE_MASK\t1\n#define KFD_RUNTIME_ENABLE_MODE_TTMP_SAVE_MASK\t2\n\n \nstruct kfd_ioctl_runtime_enable_args {\n\t__u64 r_debug;\n\t__u32 mode_mask;\n\t__u32 capabilities_mask;\n};\n\n \nstruct kfd_queue_snapshot_entry {\n\t__u64 exception_status;\n\t__u64 ring_base_address;\n\t__u64 write_pointer_address;\n\t__u64 read_pointer_address;\n\t__u64 ctx_save_restore_address;\n\t__u32 queue_id;\n\t__u32 gpu_id;\n\t__u32 ring_size;\n\t__u32 queue_type;\n\t__u32 ctx_save_restore_area_size;\n\t__u32 reserved;\n};\n\n \n#define KFD_DBG_QUEUE_ERROR_BIT\t\t30\n#define KFD_DBG_QUEUE_INVALID_BIT\t31\n#define KFD_DBG_QUEUE_ERROR_MASK\t(1 << KFD_DBG_QUEUE_ERROR_BIT)\n#define KFD_DBG_QUEUE_INVALID_MASK\t(1 << KFD_DBG_QUEUE_INVALID_BIT)\n\n \nstruct kfd_context_save_area_header {\n\tstruct {\n\t\t__u32 control_stack_offset;\n\t\t__u32 control_stack_size;\n\t\t__u32 wave_state_offset;\n\t\t__u32 wave_state_size;\n\t} wave_state;\n\t__u32 debug_offset;\n\t__u32 debug_size;\n\t__u64 err_payload_addr;\n\t__u32 err_event_id;\n\t__u32 reserved1;\n};\n\n \nenum kfd_dbg_trap_operations {\n\tKFD_IOC_DBG_TRAP_ENABLE = 0,\n\tKFD_IOC_DBG_TRAP_DISABLE = 1,\n\tKFD_IOC_DBG_TRAP_SEND_RUNTIME_EVENT = 2,\n\tKFD_IOC_DBG_TRAP_SET_EXCEPTIONS_ENABLED = 3,\n\tKFD_IOC_DBG_TRAP_SET_WAVE_LAUNCH_OVERRIDE = 4,   \n\tKFD_IOC_DBG_TRAP_SET_WAVE_LAUNCH_MODE = 5,       \n\tKFD_IOC_DBG_TRAP_SUSPEND_QUEUES = 6,\t\t \n\tKFD_IOC_DBG_TRAP_RESUME_QUEUES = 7,\t\t \n\tKFD_IOC_DBG_TRAP_SET_NODE_ADDRESS_WATCH = 8,\t \n\tKFD_IOC_DBG_TRAP_CLEAR_NODE_ADDRESS_WATCH = 9,\t \n\tKFD_IOC_DBG_TRAP_SET_FLAGS = 10,\n\tKFD_IOC_DBG_TRAP_QUERY_DEBUG_EVENT = 11,\n\tKFD_IOC_DBG_TRAP_QUERY_EXCEPTION_INFO = 12,\n\tKFD_IOC_DBG_TRAP_GET_QUEUE_SNAPSHOT = 13,\n\tKFD_IOC_DBG_TRAP_GET_DEVICE_SNAPSHOT = 14\n};\n\n \nstruct kfd_ioctl_dbg_trap_enable_args {\n\t__u64 exception_mask;\n\t__u64 rinfo_ptr;\n\t__u32 rinfo_size;\n\t__u32 dbg_fd;\n};\n\n \nstruct kfd_ioctl_dbg_trap_send_runtime_event_args {\n\t__u64 exception_mask;\n\t__u32 gpu_id;\n\t__u32 queue_id;\n};\n\n \nstruct kfd_ioctl_dbg_trap_set_exceptions_enabled_args {\n\t__u64 exception_mask;\n};\n\n \nstruct kfd_ioctl_dbg_trap_set_wave_launch_override_args {\n\t__u32 override_mode;\n\t__u32 enable_mask;\n\t__u32 support_request_mask;\n\t__u32 pad;\n};\n\n \nstruct kfd_ioctl_dbg_trap_set_wave_launch_mode_args {\n\t__u32 launch_mode;\n\t__u32 pad;\n};\n\n \nstruct kfd_ioctl_dbg_trap_suspend_queues_args {\n\t__u64 exception_mask;\n\t__u64 queue_array_ptr;\n\t__u32 num_queues;\n\t__u32 grace_period;\n};\n\n \nstruct kfd_ioctl_dbg_trap_resume_queues_args {\n\t__u64 queue_array_ptr;\n\t__u32 num_queues;\n\t__u32 pad;\n};\n\n \nstruct kfd_ioctl_dbg_trap_set_node_address_watch_args {\n\t__u64 address;\n\t__u32 mode;\n\t__u32 mask;\n\t__u32 gpu_id;\n\t__u32 id;\n};\n\n \nstruct kfd_ioctl_dbg_trap_clear_node_address_watch_args {\n\t__u32 gpu_id;\n\t__u32 id;\n};\n\n \nstruct kfd_ioctl_dbg_trap_set_flags_args {\n\t__u32 flags;\n\t__u32 pad;\n};\n\n \nstruct kfd_ioctl_dbg_trap_query_debug_event_args {\n\t__u64 exception_mask;\n\t__u32 gpu_id;\n\t__u32 queue_id;\n};\n\n \nstruct kfd_ioctl_dbg_trap_query_exception_info_args {\n\t__u64 info_ptr;\n\t__u32 info_size;\n\t__u32 source_id;\n\t__u32 exception_code;\n\t__u32 clear_exception;\n};\n\n \nstruct kfd_ioctl_dbg_trap_queue_snapshot_args {\n\t__u64 exception_mask;\n\t__u64 snapshot_buf_ptr;\n\t__u32 num_queues;\n\t__u32 entry_size;\n};\n\n \nstruct kfd_ioctl_dbg_trap_device_snapshot_args {\n\t__u64 exception_mask;\n\t__u64 snapshot_buf_ptr;\n\t__u32 num_devices;\n\t__u32 entry_size;\n};\n\n \nstruct kfd_ioctl_dbg_trap_args {\n\t__u32 pid;\n\t__u32 op;\n\n\tunion {\n\t\tstruct kfd_ioctl_dbg_trap_enable_args enable;\n\t\tstruct kfd_ioctl_dbg_trap_send_runtime_event_args send_runtime_event;\n\t\tstruct kfd_ioctl_dbg_trap_set_exceptions_enabled_args set_exceptions_enabled;\n\t\tstruct kfd_ioctl_dbg_trap_set_wave_launch_override_args launch_override;\n\t\tstruct kfd_ioctl_dbg_trap_set_wave_launch_mode_args launch_mode;\n\t\tstruct kfd_ioctl_dbg_trap_suspend_queues_args suspend_queues;\n\t\tstruct kfd_ioctl_dbg_trap_resume_queues_args resume_queues;\n\t\tstruct kfd_ioctl_dbg_trap_set_node_address_watch_args set_node_address_watch;\n\t\tstruct kfd_ioctl_dbg_trap_clear_node_address_watch_args clear_node_address_watch;\n\t\tstruct kfd_ioctl_dbg_trap_set_flags_args set_flags;\n\t\tstruct kfd_ioctl_dbg_trap_query_debug_event_args query_debug_event;\n\t\tstruct kfd_ioctl_dbg_trap_query_exception_info_args query_exception_info;\n\t\tstruct kfd_ioctl_dbg_trap_queue_snapshot_args queue_snapshot;\n\t\tstruct kfd_ioctl_dbg_trap_device_snapshot_args device_snapshot;\n\t};\n};\n\n#define AMDKFD_IOCTL_BASE 'K'\n#define AMDKFD_IO(nr)\t\t\t_IO(AMDKFD_IOCTL_BASE, nr)\n#define AMDKFD_IOR(nr, type)\t\t_IOR(AMDKFD_IOCTL_BASE, nr, type)\n#define AMDKFD_IOW(nr, type)\t\t_IOW(AMDKFD_IOCTL_BASE, nr, type)\n#define AMDKFD_IOWR(nr, type)\t\t_IOWR(AMDKFD_IOCTL_BASE, nr, type)\n\n#define AMDKFD_IOC_GET_VERSION\t\t\t\\\n\t\tAMDKFD_IOR(0x01, struct kfd_ioctl_get_version_args)\n\n#define AMDKFD_IOC_CREATE_QUEUE\t\t\t\\\n\t\tAMDKFD_IOWR(0x02, struct kfd_ioctl_create_queue_args)\n\n#define AMDKFD_IOC_DESTROY_QUEUE\t\t\\\n\t\tAMDKFD_IOWR(0x03, struct kfd_ioctl_destroy_queue_args)\n\n#define AMDKFD_IOC_SET_MEMORY_POLICY\t\t\\\n\t\tAMDKFD_IOW(0x04, struct kfd_ioctl_set_memory_policy_args)\n\n#define AMDKFD_IOC_GET_CLOCK_COUNTERS\t\t\\\n\t\tAMDKFD_IOWR(0x05, struct kfd_ioctl_get_clock_counters_args)\n\n#define AMDKFD_IOC_GET_PROCESS_APERTURES\t\\\n\t\tAMDKFD_IOR(0x06, struct kfd_ioctl_get_process_apertures_args)\n\n#define AMDKFD_IOC_UPDATE_QUEUE\t\t\t\\\n\t\tAMDKFD_IOW(0x07, struct kfd_ioctl_update_queue_args)\n\n#define AMDKFD_IOC_CREATE_EVENT\t\t\t\\\n\t\tAMDKFD_IOWR(0x08, struct kfd_ioctl_create_event_args)\n\n#define AMDKFD_IOC_DESTROY_EVENT\t\t\\\n\t\tAMDKFD_IOW(0x09, struct kfd_ioctl_destroy_event_args)\n\n#define AMDKFD_IOC_SET_EVENT\t\t\t\\\n\t\tAMDKFD_IOW(0x0A, struct kfd_ioctl_set_event_args)\n\n#define AMDKFD_IOC_RESET_EVENT\t\t\t\\\n\t\tAMDKFD_IOW(0x0B, struct kfd_ioctl_reset_event_args)\n\n#define AMDKFD_IOC_WAIT_EVENTS\t\t\t\\\n\t\tAMDKFD_IOWR(0x0C, struct kfd_ioctl_wait_events_args)\n\n#define AMDKFD_IOC_DBG_REGISTER_DEPRECATED\t\\\n\t\tAMDKFD_IOW(0x0D, struct kfd_ioctl_dbg_register_args)\n\n#define AMDKFD_IOC_DBG_UNREGISTER_DEPRECATED\t\\\n\t\tAMDKFD_IOW(0x0E, struct kfd_ioctl_dbg_unregister_args)\n\n#define AMDKFD_IOC_DBG_ADDRESS_WATCH_DEPRECATED\t\\\n\t\tAMDKFD_IOW(0x0F, struct kfd_ioctl_dbg_address_watch_args)\n\n#define AMDKFD_IOC_DBG_WAVE_CONTROL_DEPRECATED\t\\\n\t\tAMDKFD_IOW(0x10, struct kfd_ioctl_dbg_wave_control_args)\n\n#define AMDKFD_IOC_SET_SCRATCH_BACKING_VA\t\\\n\t\tAMDKFD_IOWR(0x11, struct kfd_ioctl_set_scratch_backing_va_args)\n\n#define AMDKFD_IOC_GET_TILE_CONFIG                                      \\\n\t\tAMDKFD_IOWR(0x12, struct kfd_ioctl_get_tile_config_args)\n\n#define AMDKFD_IOC_SET_TRAP_HANDLER\t\t\\\n\t\tAMDKFD_IOW(0x13, struct kfd_ioctl_set_trap_handler_args)\n\n#define AMDKFD_IOC_GET_PROCESS_APERTURES_NEW\t\\\n\t\tAMDKFD_IOWR(0x14,\t\t\\\n\t\t\tstruct kfd_ioctl_get_process_apertures_new_args)\n\n#define AMDKFD_IOC_ACQUIRE_VM\t\t\t\\\n\t\tAMDKFD_IOW(0x15, struct kfd_ioctl_acquire_vm_args)\n\n#define AMDKFD_IOC_ALLOC_MEMORY_OF_GPU\t\t\\\n\t\tAMDKFD_IOWR(0x16, struct kfd_ioctl_alloc_memory_of_gpu_args)\n\n#define AMDKFD_IOC_FREE_MEMORY_OF_GPU\t\t\\\n\t\tAMDKFD_IOW(0x17, struct kfd_ioctl_free_memory_of_gpu_args)\n\n#define AMDKFD_IOC_MAP_MEMORY_TO_GPU\t\t\\\n\t\tAMDKFD_IOWR(0x18, struct kfd_ioctl_map_memory_to_gpu_args)\n\n#define AMDKFD_IOC_UNMAP_MEMORY_FROM_GPU\t\\\n\t\tAMDKFD_IOWR(0x19, struct kfd_ioctl_unmap_memory_from_gpu_args)\n\n#define AMDKFD_IOC_SET_CU_MASK\t\t\\\n\t\tAMDKFD_IOW(0x1A, struct kfd_ioctl_set_cu_mask_args)\n\n#define AMDKFD_IOC_GET_QUEUE_WAVE_STATE\t\t\\\n\t\tAMDKFD_IOWR(0x1B, struct kfd_ioctl_get_queue_wave_state_args)\n\n#define AMDKFD_IOC_GET_DMABUF_INFO\t\t\\\n\t\tAMDKFD_IOWR(0x1C, struct kfd_ioctl_get_dmabuf_info_args)\n\n#define AMDKFD_IOC_IMPORT_DMABUF\t\t\\\n\t\tAMDKFD_IOWR(0x1D, struct kfd_ioctl_import_dmabuf_args)\n\n#define AMDKFD_IOC_ALLOC_QUEUE_GWS\t\t\\\n\t\tAMDKFD_IOWR(0x1E, struct kfd_ioctl_alloc_queue_gws_args)\n\n#define AMDKFD_IOC_SMI_EVENTS\t\t\t\\\n\t\tAMDKFD_IOWR(0x1F, struct kfd_ioctl_smi_events_args)\n\n#define AMDKFD_IOC_SVM\tAMDKFD_IOWR(0x20, struct kfd_ioctl_svm_args)\n\n#define AMDKFD_IOC_SET_XNACK_MODE\t\t\\\n\t\tAMDKFD_IOWR(0x21, struct kfd_ioctl_set_xnack_mode_args)\n\n#define AMDKFD_IOC_CRIU_OP\t\t\t\\\n\t\tAMDKFD_IOWR(0x22, struct kfd_ioctl_criu_args)\n\n#define AMDKFD_IOC_AVAILABLE_MEMORY\t\t\\\n\t\tAMDKFD_IOWR(0x23, struct kfd_ioctl_get_available_memory_args)\n\n#define AMDKFD_IOC_EXPORT_DMABUF\t\t\\\n\t\tAMDKFD_IOWR(0x24, struct kfd_ioctl_export_dmabuf_args)\n\n#define AMDKFD_IOC_RUNTIME_ENABLE\t\t\\\n\t\tAMDKFD_IOWR(0x25, struct kfd_ioctl_runtime_enable_args)\n\n#define AMDKFD_IOC_DBG_TRAP\t\t\t\\\n\t\tAMDKFD_IOWR(0x26, struct kfd_ioctl_dbg_trap_args)\n\n#define AMDKFD_COMMAND_START\t\t0x01\n#define AMDKFD_COMMAND_END\t\t0x27\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}