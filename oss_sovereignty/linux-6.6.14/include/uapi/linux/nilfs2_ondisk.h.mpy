{
  "module_name": "nilfs2_ondisk.h",
  "hash_id": "7b8e87005a1ff39ff090770577650741f823fb1b3cc9176931c7c6156dc9e6de",
  "original_prompt": "Ingested from linux-6.6.14/include/uapi/linux/nilfs2_ondisk.h",
  "human_readable_source": " \n \n \n\n#ifndef _LINUX_NILFS2_ONDISK_H\n#define _LINUX_NILFS2_ONDISK_H\n\n#include <linux/types.h>\n#include <linux/magic.h>\n#include <asm/byteorder.h>\n\n#define NILFS_INODE_BMAP_SIZE\t7\n\n \nstruct nilfs_inode {\n\t__le64\ti_blocks;\n\t__le64\ti_size;\n\t__le64\ti_ctime;\n\t__le64\ti_mtime;\n\t__le32\ti_ctime_nsec;\n\t__le32\ti_mtime_nsec;\n\t__le32\ti_uid;\n\t__le32\ti_gid;\n\t__le16\ti_mode;\n\t__le16\ti_links_count;\n\t__le32\ti_flags;\n\t__le64\ti_bmap[NILFS_INODE_BMAP_SIZE];\n#define i_device_code\ti_bmap[0]\n\t__le64\ti_xattr;\n\t__le32\ti_generation;\n\t__le32\ti_pad;\n};\n\n#define NILFS_MIN_INODE_SIZE\t\t128\n\n \nstruct nilfs_super_root {\n\t__le32 sr_sum;\n\t__le16 sr_bytes;\n\t__le16 sr_flags;\n\t__le64 sr_nongc_ctime;\n\tstruct nilfs_inode sr_dat;\n\tstruct nilfs_inode sr_cpfile;\n\tstruct nilfs_inode sr_sufile;\n};\n\n#define NILFS_SR_MDT_OFFSET(inode_size, i)  \\\n\t((unsigned long)&((struct nilfs_super_root *)0)->sr_dat + \\\n\t\t\t(inode_size) * (i))\n#define NILFS_SR_DAT_OFFSET(inode_size)     NILFS_SR_MDT_OFFSET(inode_size, 0)\n#define NILFS_SR_CPFILE_OFFSET(inode_size)  NILFS_SR_MDT_OFFSET(inode_size, 1)\n#define NILFS_SR_SUFILE_OFFSET(inode_size)  NILFS_SR_MDT_OFFSET(inode_size, 2)\n#define NILFS_SR_BYTES(inode_size)\t    NILFS_SR_MDT_OFFSET(inode_size, 3)\n\n \n#define NILFS_DFL_MAX_MNT_COUNT\t\t50       \n\n \n#define NILFS_VALID_FS\t\t\t0x0001   \n#define NILFS_ERROR_FS\t\t\t0x0002   \n#define NILFS_RESIZE_FS\t\t\t0x0004\t \n\n \n#define NILFS_MOUNT_ERROR_MODE\t\t0x0070   \n#define NILFS_MOUNT_ERRORS_CONT\t\t0x0010   \n#define NILFS_MOUNT_ERRORS_RO\t\t0x0020   \n#define NILFS_MOUNT_ERRORS_PANIC\t0x0040   \n#define NILFS_MOUNT_BARRIER\t\t0x1000   \n#define NILFS_MOUNT_STRICT_ORDER\t0x2000   \n#define NILFS_MOUNT_NORECOVERY\t\t0x4000   \n#define NILFS_MOUNT_DISCARD\t\t0x8000   \n\n\n \nstruct nilfs_super_block {\n \t__le32\ts_rev_level;\t\t \n\t__le16\ts_minor_rev_level;\t \n\t__le16\ts_magic;\t\t \n\n\t__le16  s_bytes;\t\t \n\t__le16  s_flags;\t\t \n\t__le32  s_crc_seed;\t\t \n \t__le32\ts_sum;\t\t\t \n\n\t__le32\ts_log_block_size;\t \n\t__le64  s_nsegments;\t\t \n \t__le64  s_dev_size;\t\t \n\t__le64\ts_first_data_block;\t \n \t__le32  s_blocks_per_segment;    \n\t__le32\ts_r_segments_percentage;  \n\n\t__le64  s_last_cno;\t\t \n \t__le64  s_last_pseg;\t\t \n\t__le64  s_last_seq;              \n \t__le64\ts_free_blocks_count;\t \n\n\t__le64\ts_ctime;\t\t \n \t__le64\ts_mtime;\t\t \n\t__le64\ts_wtime;\t\t \n \t__le16\ts_mnt_count;\t\t \n\t__le16\ts_max_mnt_count;\t \n\t__le16\ts_state;\t\t \n\t__le16\ts_errors;\t\t \n\t__le64\ts_lastcheck;\t\t \n\n \t__le32\ts_checkinterval;\t \n\t__le32\ts_creator_os;\t\t \n\t__le16\ts_def_resuid;\t\t \n\t__le16\ts_def_resgid;\t\t \n\t__le32\ts_first_ino;\t\t \n\n \t__le16  s_inode_size;\t\t \n\t__le16  s_dat_entry_size;        \n\t__le16  s_checkpoint_size;       \n\t__le16\ts_segment_usage_size;\t \n\n \t__u8\ts_uuid[16];\t\t \n \tchar\ts_volume_name[80];\t \n\n \t__le32  s_c_interval;            \n\t__le32  s_c_block_max;           \n \t__le64  s_feature_compat;\t \n\t__le64  s_feature_compat_ro;\t \n\t__le64  s_feature_incompat;\t \n\t__u32\ts_reserved[186];\t \n};\n\n \n#define NILFS_OS_LINUX\t\t0\n \n\n \n#define NILFS_CURRENT_REV\t2\t \n#define NILFS_MINOR_REV\t\t0\t \n#define NILFS_MIN_SUPP_REV\t2\t \n\n \n#define NILFS_FEATURE_COMPAT_RO_BLOCK_COUNT\t0x00000001ULL\n\n#define NILFS_FEATURE_COMPAT_SUPP\t0ULL\n#define NILFS_FEATURE_COMPAT_RO_SUPP\tNILFS_FEATURE_COMPAT_RO_BLOCK_COUNT\n#define NILFS_FEATURE_INCOMPAT_SUPP\t0ULL\n\n \n#define NILFS_SB_BYTES  \\\n\t((long)&((struct nilfs_super_block *)0)->s_reserved)\n\n \n#define NILFS_ROOT_INO\t\t2\t \n#define NILFS_DAT_INO\t\t3\t \n#define NILFS_CPFILE_INO\t4\t \n#define NILFS_SUFILE_INO\t5\t \n#define NILFS_IFILE_INO\t\t6\t \n#define NILFS_ATIME_INO\t\t7\t \n#define NILFS_XATTR_INO\t\t8\t \n#define NILFS_SKETCH_INO\t10\t \n#define NILFS_USER_INO\t\t11\t \n\n#define NILFS_SB_OFFSET_BYTES\t1024\t \n\n#define NILFS_SEG_MIN_BLOCKS\t16\t \n#define NILFS_PSEG_MIN_BLOCKS\t2\t \n#define NILFS_MIN_NRSVSEGS\t8\t \n\n \n#define NILFS_ROOT_METADATA_FILE(ino) \\\n\t((ino) >= NILFS_DAT_INO && (ino) <= NILFS_SUFILE_INO)\n\n \n#define NILFS_SB2_OFFSET_BYTES(devsize)\t((((devsize) >> 12) - 1) << 12)\n\n \n#define NILFS_LINK_MAX\t\t32000\n\n \n\n#define NILFS_NAME_LEN 255\n\n \n#define NILFS_MIN_BLOCK_SIZE\t\t1024\n#define NILFS_MAX_BLOCK_SIZE\t\t65536\n\n \nstruct nilfs_dir_entry {\n\t__le64\tinode;\t\t\t \n\t__le16\trec_len;\t\t \n\t__u8\tname_len;\t\t \n\t__u8\tfile_type;\t\t \n\tchar\tname[NILFS_NAME_LEN];\t \n\tchar    pad;\n};\n\n \nenum {\n\tNILFS_FT_UNKNOWN,\n\tNILFS_FT_REG_FILE,\n\tNILFS_FT_DIR,\n\tNILFS_FT_CHRDEV,\n\tNILFS_FT_BLKDEV,\n\tNILFS_FT_FIFO,\n\tNILFS_FT_SOCK,\n\tNILFS_FT_SYMLINK,\n\tNILFS_FT_MAX\n};\n\n \n#define NILFS_DIR_PAD\t\t\t8\n#define NILFS_DIR_ROUND\t\t\t(NILFS_DIR_PAD - 1)\n#define NILFS_DIR_REC_LEN(name_len)\t(((name_len) + 12 + NILFS_DIR_ROUND) & \\\n\t\t\t\t\t~NILFS_DIR_ROUND)\n#define NILFS_MAX_REC_LEN\t\t((1 << 16) - 1)\n\n \nstruct nilfs_finfo {\n\t__le64 fi_ino;\n\t__le64 fi_cno;\n\t__le32 fi_nblocks;\n\t__le32 fi_ndatablk;\n};\n\n \nstruct nilfs_binfo_v {\n\t__le64 bi_vblocknr;\n\t__le64 bi_blkoff;\n};\n\n \nstruct nilfs_binfo_dat {\n\t__le64 bi_blkoff;\n\t__u8 bi_level;\n\t__u8 bi_pad[7];\n};\n\n \nunion nilfs_binfo {\n\tstruct nilfs_binfo_v bi_v;\n\tstruct nilfs_binfo_dat bi_dat;\n};\n\n \nstruct nilfs_segment_summary {\n\t__le32 ss_datasum;\n\t__le32 ss_sumsum;\n\t__le32 ss_magic;\n\t__le16 ss_bytes;\n\t__le16 ss_flags;\n\t__le64 ss_seq;\n\t__le64 ss_create;\n\t__le64 ss_next;\n\t__le32 ss_nblocks;\n\t__le32 ss_nfinfo;\n\t__le32 ss_sumbytes;\n\t__le32 ss_pad;\n\t__le64 ss_cno;\n\t \n};\n\n#define NILFS_SEGSUM_MAGIC\t0x1eaffa11   \n\n \n#define NILFS_SS_LOGBGN 0x0001   \n#define NILFS_SS_LOGEND 0x0002   \n#define NILFS_SS_SR     0x0004   \n#define NILFS_SS_SYNDT  0x0008   \n#define NILFS_SS_GC     0x0010   \n\n \nstruct nilfs_btree_node {\n\t__u8 bn_flags;\n\t__u8 bn_level;\n\t__le16 bn_nchildren;\n\t__le32 bn_pad;\n};\n\n \n#define NILFS_BTREE_NODE_ROOT   0x01\n\n \n#define NILFS_BTREE_LEVEL_DATA          0\n#define NILFS_BTREE_LEVEL_NODE_MIN      (NILFS_BTREE_LEVEL_DATA + 1)\n#define NILFS_BTREE_LEVEL_MAX           14\t \n\n \nstruct nilfs_direct_node {\n\t__u8 dn_flags;\n\t__u8 pad[7];\n};\n\n \nstruct nilfs_palloc_group_desc {\n\t__le32 pg_nfrees;\n};\n\n \nstruct nilfs_dat_entry {\n\t__le64 de_blocknr;\n\t__le64 de_start;\n\t__le64 de_end;\n\t__le64 de_rsv;\n};\n\n#define NILFS_MIN_DAT_ENTRY_SIZE\t32\n\n \nstruct nilfs_snapshot_list {\n\t__le64 ssl_next;\n\t__le64 ssl_prev;\n};\n\n \nstruct nilfs_checkpoint {\n\t__le32 cp_flags;\n\t__le32 cp_checkpoints_count;\n\tstruct nilfs_snapshot_list cp_snapshot_list;\n\t__le64 cp_cno;\n\t__le64 cp_create;\n\t__le64 cp_nblk_inc;\n\t__le64 cp_inodes_count;\n\t__le64 cp_blocks_count;\n\n\t \n\tstruct nilfs_inode cp_ifile_inode;\n};\n\n#define NILFS_MIN_CHECKPOINT_SIZE\t(64 + NILFS_MIN_INODE_SIZE)\n\n \nenum {\n\tNILFS_CHECKPOINT_SNAPSHOT,\n\tNILFS_CHECKPOINT_INVALID,\n\tNILFS_CHECKPOINT_SKETCH,\n\tNILFS_CHECKPOINT_MINOR,\n};\n\n#define NILFS_CHECKPOINT_FNS(flag, name)\t\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\nnilfs_checkpoint_set_##name(struct nilfs_checkpoint *cp)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tcp->cp_flags = __cpu_to_le32(__le32_to_cpu(cp->cp_flags) |\t\\\n\t\t\t\t     (1UL << NILFS_CHECKPOINT_##flag));\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\nnilfs_checkpoint_clear_##name(struct nilfs_checkpoint *cp)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tcp->cp_flags = __cpu_to_le32(__le32_to_cpu(cp->cp_flags) &\t\\\n\t\t\t\t   ~(1UL << NILFS_CHECKPOINT_##flag));\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline int\t\t\t\t\t\t\t\\\nnilfs_checkpoint_##name(const struct nilfs_checkpoint *cp)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn !!(__le32_to_cpu(cp->cp_flags) &\t\t\t\t\\\n\t\t  (1UL << NILFS_CHECKPOINT_##flag));\t\t\t\\\n}\n\nNILFS_CHECKPOINT_FNS(SNAPSHOT, snapshot)\nNILFS_CHECKPOINT_FNS(INVALID, invalid)\nNILFS_CHECKPOINT_FNS(MINOR, minor)\n\n \nstruct nilfs_cpfile_header {\n\t__le64 ch_ncheckpoints;\n\t__le64 ch_nsnapshots;\n\tstruct nilfs_snapshot_list ch_snapshot_list;\n};\n\n#define NILFS_CPFILE_FIRST_CHECKPOINT_OFFSET\t\t\t\t\\\n\t((sizeof(struct nilfs_cpfile_header) +\t\t\t\t\\\n\t  sizeof(struct nilfs_checkpoint) - 1) /\t\t\t\\\n\t\t\tsizeof(struct nilfs_checkpoint))\n\n \nstruct nilfs_segment_usage {\n\t__le64 su_lastmod;\n\t__le32 su_nblocks;\n\t__le32 su_flags;\n};\n\n#define NILFS_MIN_SEGMENT_USAGE_SIZE\t16\n\n \nenum {\n\tNILFS_SEGMENT_USAGE_ACTIVE,\n\tNILFS_SEGMENT_USAGE_DIRTY,\n\tNILFS_SEGMENT_USAGE_ERROR,\n};\n\n#define NILFS_SEGMENT_USAGE_FNS(flag, name)\t\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\nnilfs_segment_usage_set_##name(struct nilfs_segment_usage *su)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tsu->su_flags = __cpu_to_le32(__le32_to_cpu(su->su_flags) |\t\\\n\t\t\t\t   (1UL << NILFS_SEGMENT_USAGE_##flag));\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\nnilfs_segment_usage_clear_##name(struct nilfs_segment_usage *su)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tsu->su_flags =\t\t\t\t\t\t\t\\\n\t\t__cpu_to_le32(__le32_to_cpu(su->su_flags) &\t\t\\\n\t\t\t    ~(1UL << NILFS_SEGMENT_USAGE_##flag));      \\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline int\t\t\t\t\t\t\t\\\nnilfs_segment_usage_##name(const struct nilfs_segment_usage *su)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn !!(__le32_to_cpu(su->su_flags) &\t\t\t\t\\\n\t\t  (1UL << NILFS_SEGMENT_USAGE_##flag));\t\t\t\\\n}\n\nNILFS_SEGMENT_USAGE_FNS(ACTIVE, active)\nNILFS_SEGMENT_USAGE_FNS(DIRTY, dirty)\nNILFS_SEGMENT_USAGE_FNS(ERROR, error)\n\nstatic inline void\nnilfs_segment_usage_set_clean(struct nilfs_segment_usage *su)\n{\n\tsu->su_lastmod = __cpu_to_le64(0);\n\tsu->su_nblocks = __cpu_to_le32(0);\n\tsu->su_flags = __cpu_to_le32(0);\n}\n\nstatic inline int\nnilfs_segment_usage_clean(const struct nilfs_segment_usage *su)\n{\n\treturn !__le32_to_cpu(su->su_flags);\n}\n\n \nstruct nilfs_sufile_header {\n\t__le64 sh_ncleansegs;\n\t__le64 sh_ndirtysegs;\n\t__le64 sh_last_alloc;\n\t \n};\n\n#define NILFS_SUFILE_FIRST_SEGMENT_USAGE_OFFSET\t\t\t\t\\\n\t((sizeof(struct nilfs_sufile_header) +\t\t\t\t\\\n\t  sizeof(struct nilfs_segment_usage) - 1) /\t\t\t\\\n\t\t\t sizeof(struct nilfs_segment_usage))\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}