{
  "module_name": "binder.h",
  "hash_id": "ff4004a29ba184a3f91b5eb146ccd19f3cc1e9d6f9f51e1d7064b01e5df4ebe0",
  "original_prompt": "Ingested from linux-6.6.14/include/uapi/linux/android/binder.h",
  "human_readable_source": " \n \n\n#ifndef _UAPI_LINUX_BINDER_H\n#define _UAPI_LINUX_BINDER_H\n\n#include <linux/types.h>\n#include <linux/ioctl.h>\n\n#define B_PACK_CHARS(c1, c2, c3, c4) \\\n\t((((c1)<<24)) | (((c2)<<16)) | (((c3)<<8)) | (c4))\n#define B_TYPE_LARGE 0x85\n\nenum {\n\tBINDER_TYPE_BINDER\t= B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE),\n\tBINDER_TYPE_WEAK_BINDER\t= B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE),\n\tBINDER_TYPE_HANDLE\t= B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE),\n\tBINDER_TYPE_WEAK_HANDLE\t= B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE),\n\tBINDER_TYPE_FD\t\t= B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),\n\tBINDER_TYPE_FDA\t\t= B_PACK_CHARS('f', 'd', 'a', B_TYPE_LARGE),\n\tBINDER_TYPE_PTR\t\t= B_PACK_CHARS('p', 't', '*', B_TYPE_LARGE),\n};\n\nenum {\n\tFLAT_BINDER_FLAG_PRIORITY_MASK = 0xff,\n\tFLAT_BINDER_FLAG_ACCEPTS_FDS = 0x100,\n\n\t \n\tFLAT_BINDER_FLAG_TXN_SECURITY_CTX = 0x1000,\n};\n\n#ifdef BINDER_IPC_32BIT\ntypedef __u32 binder_size_t;\ntypedef __u32 binder_uintptr_t;\n#else\ntypedef __u64 binder_size_t;\ntypedef __u64 binder_uintptr_t;\n#endif\n\n \nstruct binder_object_header {\n\t__u32        type;\n};\n\n \nstruct flat_binder_object {\n\tstruct binder_object_header\thdr;\n\t__u32\t\t\t\tflags;\n\n\t \n\tunion {\n\t\tbinder_uintptr_t\tbinder;\t \n\t\t__u32\t\t\thandle;\t \n\t};\n\n\t \n\tbinder_uintptr_t\tcookie;\n};\n\n \nstruct binder_fd_object {\n\tstruct binder_object_header\thdr;\n\t__u32\t\t\t\tpad_flags;\n\tunion {\n\t\tbinder_uintptr_t\tpad_binder;\n\t\t__u32\t\t\tfd;\n\t};\n\n\tbinder_uintptr_t\t\tcookie;\n};\n\n \nstruct binder_buffer_object {\n\tstruct binder_object_header\thdr;\n\t__u32\t\t\t\tflags;\n\tbinder_uintptr_t\t\tbuffer;\n\tbinder_size_t\t\t\tlength;\n\tbinder_size_t\t\t\tparent;\n\tbinder_size_t\t\t\tparent_offset;\n};\n\nenum {\n\tBINDER_BUFFER_FLAG_HAS_PARENT = 0x01,\n};\n\n \nstruct binder_fd_array_object {\n\tstruct binder_object_header\thdr;\n\t__u32\t\t\t\tpad;\n\tbinder_size_t\t\t\tnum_fds;\n\tbinder_size_t\t\t\tparent;\n\tbinder_size_t\t\t\tparent_offset;\n};\n\n \n\nstruct binder_write_read {\n\tbinder_size_t\t\twrite_size;\t \n\tbinder_size_t\t\twrite_consumed;\t \n\tbinder_uintptr_t\twrite_buffer;\n\tbinder_size_t\t\tread_size;\t \n\tbinder_size_t\t\tread_consumed;\t \n\tbinder_uintptr_t\tread_buffer;\n};\n\n \nstruct binder_version {\n\t \n\t__s32       protocol_version;\n};\n\n \n#ifdef BINDER_IPC_32BIT\n#define BINDER_CURRENT_PROTOCOL_VERSION 7\n#else\n#define BINDER_CURRENT_PROTOCOL_VERSION 8\n#endif\n\n \nstruct binder_node_debug_info {\n\tbinder_uintptr_t ptr;\n\tbinder_uintptr_t cookie;\n\t__u32            has_strong_ref;\n\t__u32            has_weak_ref;\n};\n\nstruct binder_node_info_for_ref {\n\t__u32            handle;\n\t__u32            strong_count;\n\t__u32            weak_count;\n\t__u32            reserved1;\n\t__u32            reserved2;\n\t__u32            reserved3;\n};\n\nstruct binder_freeze_info {\n\t__u32            pid;\n\t__u32            enable;\n\t__u32            timeout_ms;\n};\n\nstruct binder_frozen_status_info {\n\t__u32            pid;\n\n\t \n\t__u32            sync_recv;\n\n\t \n\t__u32            async_recv;\n};\n\n \nstruct binder_extended_error {\n\t__u32\tid;\n\t__u32\tcommand;\n\t__s32\tparam;\n};\n\n#define BINDER_WRITE_READ\t\t_IOWR('b', 1, struct binder_write_read)\n#define BINDER_SET_IDLE_TIMEOUT\t\t_IOW('b', 3, __s64)\n#define BINDER_SET_MAX_THREADS\t\t_IOW('b', 5, __u32)\n#define BINDER_SET_IDLE_PRIORITY\t_IOW('b', 6, __s32)\n#define BINDER_SET_CONTEXT_MGR\t\t_IOW('b', 7, __s32)\n#define BINDER_THREAD_EXIT\t\t_IOW('b', 8, __s32)\n#define BINDER_VERSION\t\t\t_IOWR('b', 9, struct binder_version)\n#define BINDER_GET_NODE_DEBUG_INFO\t_IOWR('b', 11, struct binder_node_debug_info)\n#define BINDER_GET_NODE_INFO_FOR_REF\t_IOWR('b', 12, struct binder_node_info_for_ref)\n#define BINDER_SET_CONTEXT_MGR_EXT\t_IOW('b', 13, struct flat_binder_object)\n#define BINDER_FREEZE\t\t\t_IOW('b', 14, struct binder_freeze_info)\n#define BINDER_GET_FROZEN_INFO\t\t_IOWR('b', 15, struct binder_frozen_status_info)\n#define BINDER_ENABLE_ONEWAY_SPAM_DETECTION\t_IOW('b', 16, __u32)\n#define BINDER_GET_EXTENDED_ERROR\t_IOWR('b', 17, struct binder_extended_error)\n\n \n\nenum transaction_flags {\n\tTF_ONE_WAY\t= 0x01,\t \n\tTF_ROOT_OBJECT\t= 0x04,\t \n\tTF_STATUS_CODE\t= 0x08,\t \n\tTF_ACCEPT_FDS\t= 0x10,\t \n\tTF_CLEAR_BUF\t= 0x20,\t \n\tTF_UPDATE_TXN\t= 0x40,\t \n};\n\nstruct binder_transaction_data {\n\t \n\tunion {\n\t\t \n\t\t__u32\thandle;\n\t\t \n\t\tbinder_uintptr_t ptr;\n\t} target;\n\tbinder_uintptr_t\tcookie;\t \n\t__u32\t\tcode;\t\t \n\n\t \n\t__u32\t        flags;\n\t__kernel_pid_t\tsender_pid;\n\t__kernel_uid32_t\tsender_euid;\n\tbinder_size_t\tdata_size;\t \n\tbinder_size_t\toffsets_size;\t \n\n\t \n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\tbinder_uintptr_t\tbuffer;\n\t\t\t \n\t\t\tbinder_uintptr_t\toffsets;\n\t\t} ptr;\n\t\t__u8\tbuf[8];\n\t} data;\n};\n\nstruct binder_transaction_data_secctx {\n\tstruct binder_transaction_data transaction_data;\n\tbinder_uintptr_t secctx;\n};\n\nstruct binder_transaction_data_sg {\n\tstruct binder_transaction_data transaction_data;\n\tbinder_size_t buffers_size;\n};\n\nstruct binder_ptr_cookie {\n\tbinder_uintptr_t ptr;\n\tbinder_uintptr_t cookie;\n};\n\nstruct binder_handle_cookie {\n\t__u32 handle;\n\tbinder_uintptr_t cookie;\n} __packed;\n\nstruct binder_pri_desc {\n\t__s32 priority;\n\t__u32 desc;\n};\n\nstruct binder_pri_ptr_cookie {\n\t__s32 priority;\n\tbinder_uintptr_t ptr;\n\tbinder_uintptr_t cookie;\n};\n\nenum binder_driver_return_protocol {\n\tBR_ERROR = _IOR('r', 0, __s32),\n\t \n\n\tBR_OK = _IO('r', 1),\n\t \n\n\tBR_TRANSACTION_SEC_CTX = _IOR('r', 2,\n\t\t\t\t      struct binder_transaction_data_secctx),\n\t \n\tBR_TRANSACTION = _IOR('r', 2, struct binder_transaction_data),\n\tBR_REPLY = _IOR('r', 3, struct binder_transaction_data),\n\t \n\n\tBR_ACQUIRE_RESULT = _IOR('r', 4, __s32),\n\t \n\n\tBR_DEAD_REPLY = _IO('r', 5),\n\t \n\n\tBR_TRANSACTION_COMPLETE = _IO('r', 6),\n\t \n\n\tBR_INCREFS = _IOR('r', 7, struct binder_ptr_cookie),\n\tBR_ACQUIRE = _IOR('r', 8, struct binder_ptr_cookie),\n\tBR_RELEASE = _IOR('r', 9, struct binder_ptr_cookie),\n\tBR_DECREFS = _IOR('r', 10, struct binder_ptr_cookie),\n\t \n\n\tBR_ATTEMPT_ACQUIRE = _IOR('r', 11, struct binder_pri_ptr_cookie),\n\t \n\n\tBR_NOOP = _IO('r', 12),\n\t \n\n\tBR_SPAWN_LOOPER = _IO('r', 13),\n\t \n\n\tBR_FINISHED = _IO('r', 14),\n\t \n\n\tBR_DEAD_BINDER = _IOR('r', 15, binder_uintptr_t),\n\t \n\tBR_CLEAR_DEATH_NOTIFICATION_DONE = _IOR('r', 16, binder_uintptr_t),\n\t \n\n\tBR_FAILED_REPLY = _IO('r', 17),\n\t \n\n\tBR_FROZEN_REPLY = _IO('r', 18),\n\t \n\n\tBR_ONEWAY_SPAM_SUSPECT = _IO('r', 19),\n\t \n\n\tBR_TRANSACTION_PENDING_FROZEN = _IO('r', 20),\n\t \n};\n\nenum binder_driver_command_protocol {\n\tBC_TRANSACTION = _IOW('c', 0, struct binder_transaction_data),\n\tBC_REPLY = _IOW('c', 1, struct binder_transaction_data),\n\t \n\n\tBC_ACQUIRE_RESULT = _IOW('c', 2, __s32),\n\t \n\n\tBC_FREE_BUFFER = _IOW('c', 3, binder_uintptr_t),\n\t \n\n\tBC_INCREFS = _IOW('c', 4, __u32),\n\tBC_ACQUIRE = _IOW('c', 5, __u32),\n\tBC_RELEASE = _IOW('c', 6, __u32),\n\tBC_DECREFS = _IOW('c', 7, __u32),\n\t \n\n\tBC_INCREFS_DONE = _IOW('c', 8, struct binder_ptr_cookie),\n\tBC_ACQUIRE_DONE = _IOW('c', 9, struct binder_ptr_cookie),\n\t \n\n\tBC_ATTEMPT_ACQUIRE = _IOW('c', 10, struct binder_pri_desc),\n\t \n\n\tBC_REGISTER_LOOPER = _IO('c', 11),\n\t \n\n\tBC_ENTER_LOOPER = _IO('c', 12),\n\tBC_EXIT_LOOPER = _IO('c', 13),\n\t \n\n\tBC_REQUEST_DEATH_NOTIFICATION = _IOW('c', 14,\n\t\t\t\t\t\tstruct binder_handle_cookie),\n\t \n\n\tBC_CLEAR_DEATH_NOTIFICATION = _IOW('c', 15,\n\t\t\t\t\t\tstruct binder_handle_cookie),\n\t \n\n\tBC_DEAD_BINDER_DONE = _IOW('c', 16, binder_uintptr_t),\n\t \n\n\tBC_TRANSACTION_SG = _IOW('c', 17, struct binder_transaction_data_sg),\n\tBC_REPLY_SG = _IOW('c', 18, struct binder_transaction_data_sg),\n\t \n};\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}