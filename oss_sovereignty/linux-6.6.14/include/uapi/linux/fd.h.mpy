{
  "module_name": "fd.h",
  "hash_id": "d1c3e9300513dbd0917c468ede9e0338c7e9572c30393d46eef3ff301e1f2140",
  "original_prompt": "Ingested from linux-6.6.14/include/uapi/linux/fd.h",
  "human_readable_source": " \n#ifndef _UAPI_LINUX_FD_H\n#define _UAPI_LINUX_FD_H\n\n#include <linux/ioctl.h>\n#include <linux/compiler.h>\n\n \n\n \nstruct floppy_struct {\n\tunsigned int\tsize,\t\t \n\t\t\tsect,\t\t \n\t\t\thead,\t\t \n\t\t\ttrack,\t\t \n\t\t\tstretch;\t \n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define FD_STRETCH 1\n#define FD_SWAPSIDES 2\n#define FD_ZEROBASED 4\n#define FD_SECTBASEMASK 0x3FC\n#define FD_MKSECTBASE(s) (((s) ^ 1) << 2)\n#define FD_SECTBASE(floppy) ((((floppy)->stretch & FD_SECTBASEMASK) >> 2) ^ 1)\n\n\tunsigned char\tgap,\t\t \n\n\t\t\trate,\t\t \n#define FD_2M 0x4\n#define FD_SIZECODEMASK 0x38\n#define FD_SIZECODE(floppy) (((((floppy)->rate&FD_SIZECODEMASK)>> 3)+ 2) %8)\n#define FD_SECTSIZE(floppy) ( (floppy)->rate & FD_2M ? \\\n\t\t\t     512 : 128 << FD_SIZECODE(floppy) )\n#define FD_PERP 0x40\n\n\t\t\tspec1,\t\t \n\t\t\tfmt_gap;\t \n\tconst char\t* name;  \n};\n\n\n \n \n\n#define FDCLRPRM _IO(2, 0x41)\n \n\n#define FDSETPRM _IOW(2, 0x42, struct floppy_struct)\n#define FDSETMEDIAPRM FDSETPRM\n \n\n#define FDDEFPRM _IOW(2, 0x43, struct floppy_struct)\n#define FDGETPRM _IOR(2, 0x04, struct floppy_struct)\n#define FDDEFMEDIAPRM FDDEFPRM\n#define FDGETMEDIAPRM FDGETPRM\n \n\n\n#define\tFDMSGON  _IO(2,0x45)\n#define\tFDMSGOFF _IO(2,0x46)\n \n\n\n \n#define FD_FILL_BYTE 0xF6  \n\nstruct format_descr {\n\tunsigned int device,head,track;\n};\n\n#define FDFMTBEG _IO(2,0x47)\n \n#define\tFDFMTTRK _IOW(2,0x48, struct format_descr)\n \n#define FDFMTEND _IO(2,0x49)\n \n\n\n \nstruct floppy_max_errors {\n\tunsigned int\n\t  abort,       \n\t  read_track,  \n\t  reset,       \n\t  recal,       \n\n\t   \n\t  reporting;\n\n};\n\n#define FDSETEMSGTRESH\t_IO(2,0x4a)\n \n\n#define FDFLUSH  _IO(2,0x4b)\n \n\n#define FDSETMAXERRS _IOW(2, 0x4c, struct floppy_max_errors)\n#define FDGETMAXERRS _IOR(2, 0x0e, struct floppy_max_errors)\n \n\n\ntypedef char floppy_drive_name[16];\n#define FDGETDRVTYP _IOR(2, 0x0f, floppy_drive_name)\n \n\n\n \nstruct floppy_drive_params {\n\tsigned char cmos;\t\t \n\n\t \n\tunsigned long max_dtr;\t\t \n\tunsigned long hlt;     \t\t \n\tunsigned long hut;     \t\t \n\tunsigned long srt;     \t\t \n\n\tunsigned long spinup;\t\t \n\tunsigned long spindown;\t\t \n\tunsigned char spindown_offset;\t \n\tunsigned char select_delay;\t \n\tunsigned char rps;\t\t \n\tunsigned char tracks;\t\t \n\tunsigned long timeout;\t\t \n\n\tunsigned char interleave_sect;\t \n\n\tstruct floppy_max_errors max_errors;\n\n\tchar flags;\t\t\t \n \n\n#define FTD_MSG 0x10\n#define FD_BROKEN_DCL 0x20\n#define FD_DEBUG 0x02\n#define FD_SILENT_DCL_CLEAR 0x4\n#define FD_INVERTED_DCL 0x80  \n\n\tchar read_track;\t\t \n\n \n\n#define FD_AUTODETECT_SIZE 8\n\n\tshort autodetect[FD_AUTODETECT_SIZE];  \n\n\tint checkfreq;  \n\tint native_format;  \n};\n\nenum {\n\tFD_NEED_TWADDLE_BIT,\t \n\tFD_VERIFY_BIT,\t\t \n\tFD_DISK_NEWCHANGE_BIT,\t \n\tFD_UNUSED_BIT,\n\tFD_DISK_CHANGED_BIT,\t \n\tFD_DISK_WRITABLE_BIT,\t \n\tFD_OPEN_SHOULD_FAIL_BIT\n};\n\n#define FDSETDRVPRM _IOW(2, 0x90, struct floppy_drive_params)\n#define FDGETDRVPRM _IOR(2, 0x11, struct floppy_drive_params)\n \n\n\n \nstruct floppy_drive_struct {\n\tunsigned long flags;\n \n#define FD_NEED_TWADDLE (1 << FD_NEED_TWADDLE_BIT)\n#define FD_VERIFY (1 << FD_VERIFY_BIT)\n#define FD_DISK_NEWCHANGE (1 << FD_DISK_NEWCHANGE_BIT)\n#define FD_DISK_CHANGED (1 << FD_DISK_CHANGED_BIT)\n#define FD_DISK_WRITABLE (1 << FD_DISK_WRITABLE_BIT)\n\n\tunsigned long spinup_date;\n\tunsigned long select_date;\n\tunsigned long first_read_date;\n\tshort probed_format;\n\tshort track;  \n\tshort maxblock;  \n\tshort maxtrack;  \n\tint generation;  \n\n \n\tint keep_data;\n\n\t \n\tint fd_ref;\n\tint fd_device;\n\tunsigned long last_checked;  \n\n\tchar *dmabuf;\n\tint bufblocks;\n};\n\n#define FDGETDRVSTAT _IOR(2, 0x12, struct floppy_drive_struct)\n#define FDPOLLDRVSTAT _IOR(2, 0x13, struct floppy_drive_struct)\n \n\n\n \nenum reset_mode {\n\tFD_RESET_IF_NEEDED,\t \n\tFD_RESET_IF_RAWCMD,\t \n\tFD_RESET_ALWAYS\t\t \n};\n#define FDRESET _IO(2, 0x54)\n\n\n \nstruct floppy_fdc_state {\n\tint spec1;\t\t \n\tint spec2;\t\t \n\tint dtr;\n\tunsigned char version;\t \n\tunsigned char dor;\n\tunsigned long address;\t \n\tunsigned int rawcmd:2;\n\tunsigned int reset:1;\n\tunsigned int need_configure:1;\n\tunsigned int perp_mode:2;\n\tunsigned int has_fifo:1;\n\tunsigned int driver_version;\t \n#define FD_DRIVER_VERSION 0x100\n \n\n\tunsigned char track[4];\n\t \n\n};\n\n#define FDGETFDCSTAT _IOR(2, 0x15, struct floppy_fdc_state)\n\n\n \nstruct floppy_write_errors {\n\t \n\n\tunsigned int write_errors;   \n\n\t \n\tunsigned long first_error_sector;\n\tint           first_error_generation;\n\tunsigned long last_error_sector;\n\tint           last_error_generation;\n\n\tunsigned int badness;  \n};\n\n#define FDWERRORCLR  _IO(2, 0x56)\n \n#define FDWERRORGET  _IOR(2, 0x17, struct floppy_write_errors)\n \n\n\n \n \n#define FDHAVEBATCHEDRAWCMD\n\nstruct floppy_raw_cmd {\n\tunsigned int flags;\n#define FD_RAW_READ 1\n#define FD_RAW_WRITE 2\n#define FD_RAW_NO_MOTOR 4\n#define FD_RAW_DISK_CHANGE 4  \n#define FD_RAW_INTR 8     \n#define FD_RAW_SPIN 0x10  \n#define FD_RAW_NO_MOTOR_AFTER 0x20  \n#define FD_RAW_NEED_DISK 0x40   \n#define FD_RAW_NEED_SEEK 0x80   \n\n \n#define FD_RAW_MORE 0x100   \n#define FD_RAW_STOP_IF_FAILURE 0x200  \n#define FD_RAW_STOP_IF_SUCCESS 0x400  \n#define FD_RAW_SOFTFAILURE 0x800  \n\n \n#define FD_RAW_FAILURE 0x10000  \n#define FD_RAW_HARDFAILURE 0x20000  \n\n\tvoid __user *data;\n\tchar *kernel_data;  \n\tstruct floppy_raw_cmd *next;  \n\tlong length;  \n\tlong phys_length;  \n\tint buffer_length;  \n\n\tunsigned char rate;\n\n#define FD_RAW_CMD_SIZE 16\n#define FD_RAW_REPLY_SIZE 16\n#define FD_RAW_CMD_FULLSIZE (FD_RAW_CMD_SIZE + 1 + FD_RAW_REPLY_SIZE)\n\n\t \n\n\tunsigned char cmd_count;\n\tunion {\n\t\tstruct {\n\t\t\tunsigned char cmd[FD_RAW_CMD_SIZE];\n\t\t\tunsigned char reply_count;\n\t\t\tunsigned char reply[FD_RAW_REPLY_SIZE];\n\t\t};\n\t\tunsigned char fullcmd[FD_RAW_CMD_FULLSIZE];\n\t};\n\tint track;\n\tint resultcode;\n\n\tint reserved1;\n\tint reserved2;\n};\n\n#define FDRAWCMD _IO(2, 0x58)\n \n\n#define FDTWADDLE _IO(2, 0x59)\n \n\n\n#define FDEJECT _IO(2, 0x5a)\n \n\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}