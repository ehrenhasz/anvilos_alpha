{
  "module_name": "ras_event.h",
  "hash_id": "8085be7dfc908febcb3ae3287c40f10a53e162f72b75dd5c315496c4784056ac",
  "original_prompt": "Ingested from linux-6.6.14/include/ras/ras_event.h",
  "human_readable_source": " \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM ras\n#define TRACE_INCLUDE_FILE ras_event\n\n#if !defined(_TRACE_HW_EVENT_MC_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_HW_EVENT_MC_H\n\n#include <linux/tracepoint.h>\n#include <linux/edac.h>\n#include <linux/ktime.h>\n#include <linux/pci.h>\n#include <linux/aer.h>\n#include <linux/cper.h>\n#include <linux/mm.h>\n\n \n\n \n\n#if defined(CONFIG_ACPI_EXTLOG) || defined(CONFIG_ACPI_EXTLOG_MODULE)\nTRACE_EVENT(extlog_mem_event,\n\tTP_PROTO(struct cper_sec_mem_err *mem,\n\t\t u32 err_seq,\n\t\t const guid_t *fru_id,\n\t\t const char *fru_text,\n\t\t u8 sev),\n\n\tTP_ARGS(mem, err_seq, fru_id, fru_text, sev),\n\n\tTP_STRUCT__entry(\n\t\t__field(u32, err_seq)\n\t\t__field(u8, etype)\n\t\t__field(u8, sev)\n\t\t__field(u64, pa)\n\t\t__field(u8, pa_mask_lsb)\n\t\t__field_struct(guid_t, fru_id)\n\t\t__string(fru_text, fru_text)\n\t\t__field_struct(struct cper_mem_err_compact, data)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->err_seq = err_seq;\n\t\tif (mem->validation_bits & CPER_MEM_VALID_ERROR_TYPE)\n\t\t\t__entry->etype = mem->error_type;\n\t\telse\n\t\t\t__entry->etype = ~0;\n\t\t__entry->sev = sev;\n\t\tif (mem->validation_bits & CPER_MEM_VALID_PA)\n\t\t\t__entry->pa = mem->physical_addr;\n\t\telse\n\t\t\t__entry->pa = ~0ull;\n\n\t\tif (mem->validation_bits & CPER_MEM_VALID_PA_MASK)\n\t\t\t__entry->pa_mask_lsb = (u8)__ffs64(mem->physical_addr_mask);\n\t\telse\n\t\t\t__entry->pa_mask_lsb = ~0;\n\t\t__entry->fru_id = *fru_id;\n\t\t__assign_str(fru_text, fru_text);\n\t\tcper_mem_err_pack(mem, &__entry->data);\n\t),\n\n\tTP_printk(\"{%d} %s error: %s physical addr: %016llx (mask lsb: %x) %sFRU: %pUl %.20s\",\n\t\t  __entry->err_seq,\n\t\t  cper_severity_str(__entry->sev),\n\t\t  cper_mem_err_type_str(__entry->etype),\n\t\t  __entry->pa,\n\t\t  __entry->pa_mask_lsb,\n\t\t  cper_mem_err_unpack(p, &__entry->data),\n\t\t  &__entry->fru_id,\n\t\t  __get_str(fru_text))\n);\n#endif\n\n \n\n \n\n \nTRACE_EVENT(mc_event,\n\n\tTP_PROTO(const unsigned int err_type,\n\t\t const char *error_msg,\n\t\t const char *label,\n\t\t const int error_count,\n\t\t const u8 mc_index,\n\t\t const s8 top_layer,\n\t\t const s8 mid_layer,\n\t\t const s8 low_layer,\n\t\t unsigned long address,\n\t\t const u8 grain_bits,\n\t\t unsigned long syndrome,\n\t\t const char *driver_detail),\n\n\tTP_ARGS(err_type, error_msg, label, error_count, mc_index,\n\t\ttop_layer, mid_layer, low_layer, address, grain_bits,\n\t\tsyndrome, driver_detail),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tunsigned int,\terror_type\t\t)\n\t\t__string(\tmsg,\t\terror_msg\t\t)\n\t\t__string(\tlabel,\t\tlabel\t\t\t)\n\t\t__field(\tu16,\t\terror_count\t\t)\n\t\t__field(\tu8,\t\tmc_index\t\t)\n\t\t__field(\ts8,\t\ttop_layer\t\t)\n\t\t__field(\ts8,\t\tmiddle_layer\t\t)\n\t\t__field(\ts8,\t\tlower_layer\t\t)\n\t\t__field(\tlong,\t\taddress\t\t\t)\n\t\t__field(\tu8,\t\tgrain_bits\t\t)\n\t\t__field(\tlong,\t\tsyndrome\t\t)\n\t\t__string(\tdriver_detail,\tdriver_detail\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->error_type\t\t= err_type;\n\t\t__assign_str(msg, error_msg);\n\t\t__assign_str(label, label);\n\t\t__entry->error_count\t\t= error_count;\n\t\t__entry->mc_index\t\t= mc_index;\n\t\t__entry->top_layer\t\t= top_layer;\n\t\t__entry->middle_layer\t\t= mid_layer;\n\t\t__entry->lower_layer\t\t= low_layer;\n\t\t__entry->address\t\t= address;\n\t\t__entry->grain_bits\t\t= grain_bits;\n\t\t__entry->syndrome\t\t= syndrome;\n\t\t__assign_str(driver_detail, driver_detail);\n\t),\n\n\tTP_printk(\"%d %s error%s:%s%s on %s (mc:%d location:%d:%d:%d address:0x%08lx grain:%d syndrome:0x%08lx%s%s)\",\n\t\t  __entry->error_count,\n\t\t  mc_event_error_type(__entry->error_type),\n\t\t  __entry->error_count > 1 ? \"s\" : \"\",\n\t\t  __get_str(msg)[0] ? \" \" : \"\",\n\t\t  __get_str(msg),\n\t\t  __get_str(label),\n\t\t  __entry->mc_index,\n\t\t  __entry->top_layer,\n\t\t  __entry->middle_layer,\n\t\t  __entry->lower_layer,\n\t\t  __entry->address,\n\t\t  1 << __entry->grain_bits,\n\t\t  __entry->syndrome,\n\t\t  __get_str(driver_detail)[0] ? \" \" : \"\",\n\t\t  __get_str(driver_detail))\n);\n\n \nTRACE_EVENT(arm_event,\n\n\tTP_PROTO(const struct cper_sec_proc_arm *proc),\n\n\tTP_ARGS(proc),\n\n\tTP_STRUCT__entry(\n\t\t__field(u64, mpidr)\n\t\t__field(u64, midr)\n\t\t__field(u32, running_state)\n\t\t__field(u32, psci_state)\n\t\t__field(u8, affinity)\n\t),\n\n\tTP_fast_assign(\n\t\tif (proc->validation_bits & CPER_ARM_VALID_AFFINITY_LEVEL)\n\t\t\t__entry->affinity = proc->affinity_level;\n\t\telse\n\t\t\t__entry->affinity = ~0;\n\t\tif (proc->validation_bits & CPER_ARM_VALID_MPIDR)\n\t\t\t__entry->mpidr = proc->mpidr;\n\t\telse\n\t\t\t__entry->mpidr = 0ULL;\n\t\t__entry->midr = proc->midr;\n\t\tif (proc->validation_bits & CPER_ARM_VALID_RUNNING_STATE) {\n\t\t\t__entry->running_state = proc->running_state;\n\t\t\t__entry->psci_state = proc->psci_state;\n\t\t} else {\n\t\t\t__entry->running_state = ~0;\n\t\t\t__entry->psci_state = ~0;\n\t\t}\n\t),\n\n\tTP_printk(\"affinity level: %d; MPIDR: %016llx; MIDR: %016llx; \"\n\t\t  \"running state: %d; PSCI state: %d\",\n\t\t  __entry->affinity, __entry->mpidr, __entry->midr,\n\t\t  __entry->running_state, __entry->psci_state)\n);\n\n \nTRACE_EVENT(non_standard_event,\n\n\tTP_PROTO(const guid_t *sec_type,\n\t\t const guid_t *fru_id,\n\t\t const char *fru_text,\n\t\t const u8 sev,\n\t\t const u8 *err,\n\t\t const u32 len),\n\n\tTP_ARGS(sec_type, fru_id, fru_text, sev, err, len),\n\n\tTP_STRUCT__entry(\n\t\t__array(char, sec_type, UUID_SIZE)\n\t\t__array(char, fru_id, UUID_SIZE)\n\t\t__string(fru_text, fru_text)\n\t\t__field(u8, sev)\n\t\t__field(u32, len)\n\t\t__dynamic_array(u8, buf, len)\n\t),\n\n\tTP_fast_assign(\n\t\tmemcpy(__entry->sec_type, sec_type, UUID_SIZE);\n\t\tmemcpy(__entry->fru_id, fru_id, UUID_SIZE);\n\t\t__assign_str(fru_text, fru_text);\n\t\t__entry->sev = sev;\n\t\t__entry->len = len;\n\t\tmemcpy(__get_dynamic_array(buf), err, len);\n\t),\n\n\tTP_printk(\"severity: %d; sec type:%pU; FRU: %pU %s; data len:%d; raw data:%s\",\n\t\t  __entry->sev, __entry->sec_type,\n\t\t  __entry->fru_id, __get_str(fru_text),\n\t\t  __entry->len,\n\t\t  __print_hex(__get_dynamic_array(buf), __entry->len))\n);\n\n \n\n#define aer_correctable_errors\t\t\t\t\t\\\n\t{PCI_ERR_COR_RCVR,\t\"Receiver Error\"},\t\t\\\n\t{PCI_ERR_COR_BAD_TLP,\t\"Bad TLP\"},\t\t\t\\\n\t{PCI_ERR_COR_BAD_DLLP,\t\"Bad DLLP\"},\t\t\t\\\n\t{PCI_ERR_COR_REP_ROLL,\t\"RELAY_NUM Rollover\"},\t\t\\\n\t{PCI_ERR_COR_REP_TIMER,\t\"Replay Timer Timeout\"},\t\\\n\t{PCI_ERR_COR_ADV_NFAT,\t\"Advisory Non-Fatal Error\"},\t\\\n\t{PCI_ERR_COR_INTERNAL,\t\"Corrected Internal Error\"},\t\\\n\t{PCI_ERR_COR_LOG_OVER,\t\"Header Log Overflow\"}\n\n#define aer_uncorrectable_errors\t\t\t\t\\\n\t{PCI_ERR_UNC_UND,\t\"Undefined\"},\t\t\t\\\n\t{PCI_ERR_UNC_DLP,\t\"Data Link Protocol Error\"},\t\\\n\t{PCI_ERR_UNC_SURPDN,\t\"Surprise Down Error\"},\t\t\\\n\t{PCI_ERR_UNC_POISON_TLP,\"Poisoned TLP\"},\t\t\\\n\t{PCI_ERR_UNC_FCP,\t\"Flow Control Protocol Error\"},\t\\\n\t{PCI_ERR_UNC_COMP_TIME,\t\"Completion Timeout\"},\t\t\\\n\t{PCI_ERR_UNC_COMP_ABORT,\"Completer Abort\"},\t\t\\\n\t{PCI_ERR_UNC_UNX_COMP,\t\"Unexpected Completion\"},\t\\\n\t{PCI_ERR_UNC_RX_OVER,\t\"Receiver Overflow\"},\t\t\\\n\t{PCI_ERR_UNC_MALF_TLP,\t\"Malformed TLP\"},\t\t\\\n\t{PCI_ERR_UNC_ECRC,\t\"ECRC Error\"},\t\t\t\\\n\t{PCI_ERR_UNC_UNSUP,\t\"Unsupported Request Error\"},\t\\\n\t{PCI_ERR_UNC_ACSV,\t\"ACS Violation\"},\t\t\\\n\t{PCI_ERR_UNC_INTN,\t\"Uncorrectable Internal Error\"},\\\n\t{PCI_ERR_UNC_MCBTLP,\t\"MC Blocked TLP\"},\t\t\\\n\t{PCI_ERR_UNC_ATOMEG,\t\"AtomicOp Egress Blocked\"},\t\\\n\t{PCI_ERR_UNC_TLPPRE,\t\"TLP Prefix Blocked Error\"}\n\nTRACE_EVENT(aer_event,\n\tTP_PROTO(const char *dev_name,\n\t\t const u32 status,\n\t\t const u8 severity,\n\t\t const u8 tlp_header_valid,\n\t\t struct aer_header_log_regs *tlp),\n\n\tTP_ARGS(dev_name, status, severity, tlp_header_valid, tlp),\n\n\tTP_STRUCT__entry(\n\t\t__string(\tdev_name,\tdev_name\t)\n\t\t__field(\tu32,\t\tstatus\t\t)\n\t\t__field(\tu8,\t\tseverity\t)\n\t\t__field(\tu8, \t\ttlp_header_valid)\n\t\t__array(\tu32, \t\ttlp_header, 4\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(dev_name, dev_name);\n\t\t__entry->status\t\t= status;\n\t\t__entry->severity\t= severity;\n\t\t__entry->tlp_header_valid = tlp_header_valid;\n\t\tif (tlp_header_valid) {\n\t\t\t__entry->tlp_header[0] = tlp->dw0;\n\t\t\t__entry->tlp_header[1] = tlp->dw1;\n\t\t\t__entry->tlp_header[2] = tlp->dw2;\n\t\t\t__entry->tlp_header[3] = tlp->dw3;\n\t\t}\n\t),\n\n\tTP_printk(\"%s PCIe Bus Error: severity=%s, %s, TLP Header=%s\\n\",\n\t\t__get_str(dev_name),\n\t\t__entry->severity == AER_CORRECTABLE ? \"Corrected\" :\n\t\t\t__entry->severity == AER_FATAL ?\n\t\t\t\"Fatal\" : \"Uncorrected, non-fatal\",\n\t\t__entry->severity == AER_CORRECTABLE ?\n\t\t__print_flags(__entry->status, \"|\", aer_correctable_errors) :\n\t\t__print_flags(__entry->status, \"|\", aer_uncorrectable_errors),\n\t\t__entry->tlp_header_valid ?\n\t\t\t__print_array(__entry->tlp_header, 4, 4) :\n\t\t\t\"Not available\")\n);\n\n \n\n#ifdef CONFIG_MEMORY_FAILURE\n#define MF_ACTION_RESULT\t\\\n\tEM ( MF_IGNORED, \"Ignored\" )\t\\\n\tEM ( MF_FAILED,  \"Failed\" )\t\\\n\tEM ( MF_DELAYED, \"Delayed\" )\t\\\n\tEMe ( MF_RECOVERED, \"Recovered\" )\n\n#define MF_PAGE_TYPE\t\t\\\n\tEM ( MF_MSG_KERNEL, \"reserved kernel page\" )\t\t\t\\\n\tEM ( MF_MSG_KERNEL_HIGH_ORDER, \"high-order kernel page\" )\t\\\n\tEM ( MF_MSG_SLAB, \"kernel slab page\" )\t\t\t\t\\\n\tEM ( MF_MSG_DIFFERENT_COMPOUND, \"different compound page after locking\" ) \\\n\tEM ( MF_MSG_HUGE, \"huge page\" )\t\t\t\t\t\\\n\tEM ( MF_MSG_FREE_HUGE, \"free huge page\" )\t\t\t\\\n\tEM ( MF_MSG_UNMAP_FAILED, \"unmapping failed page\" )\t\t\\\n\tEM ( MF_MSG_DIRTY_SWAPCACHE, \"dirty swapcache page\" )\t\t\\\n\tEM ( MF_MSG_CLEAN_SWAPCACHE, \"clean swapcache page\" )\t\t\\\n\tEM ( MF_MSG_DIRTY_MLOCKED_LRU, \"dirty mlocked LRU page\" )\t\\\n\tEM ( MF_MSG_CLEAN_MLOCKED_LRU, \"clean mlocked LRU page\" )\t\\\n\tEM ( MF_MSG_DIRTY_UNEVICTABLE_LRU, \"dirty unevictable LRU page\" )\t\\\n\tEM ( MF_MSG_CLEAN_UNEVICTABLE_LRU, \"clean unevictable LRU page\" )\t\\\n\tEM ( MF_MSG_DIRTY_LRU, \"dirty LRU page\" )\t\t\t\\\n\tEM ( MF_MSG_CLEAN_LRU, \"clean LRU page\" )\t\t\t\\\n\tEM ( MF_MSG_TRUNCATED_LRU, \"already truncated LRU page\" )\t\\\n\tEM ( MF_MSG_BUDDY, \"free buddy page\" )\t\t\t\t\\\n\tEM ( MF_MSG_DAX, \"dax page\" )\t\t\t\t\t\\\n\tEM ( MF_MSG_UNSPLIT_THP, \"unsplit thp\" )\t\t\t\\\n\tEMe ( MF_MSG_UNKNOWN, \"unknown page\" )\n\n \n#undef EM\n#undef EMe\n#define EM(a, b) TRACE_DEFINE_ENUM(a);\n#define EMe(a, b)\tTRACE_DEFINE_ENUM(a);\n\nMF_ACTION_RESULT\nMF_PAGE_TYPE\n\n \n#undef EM\n#undef EMe\n#define EM(a, b)\t\t{ a, b },\n#define EMe(a, b)\t{ a, b }\n\nTRACE_EVENT(memory_failure_event,\n\tTP_PROTO(unsigned long pfn,\n\t\t int type,\n\t\t int result),\n\n\tTP_ARGS(pfn, type, result),\n\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long, pfn)\n\t\t__field(int, type)\n\t\t__field(int, result)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->pfn\t= pfn;\n\t\t__entry->type\t= type;\n\t\t__entry->result\t= result;\n\t),\n\n\tTP_printk(\"pfn %#lx: recovery action for %s: %s\",\n\t\t__entry->pfn,\n\t\t__print_symbolic(__entry->type, MF_PAGE_TYPE),\n\t\t__print_symbolic(__entry->result, MF_ACTION_RESULT)\n\t)\n);\n#endif  \n#endif  \n\n \n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}