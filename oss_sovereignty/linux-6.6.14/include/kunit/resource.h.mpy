{
  "module_name": "resource.h",
  "hash_id": "17be2b7157ac3823c325762863d3de132ac40b5a4f2dbc15feaf800775821602",
  "original_prompt": "Ingested from linux-6.6.14/include/kunit/resource.h",
  "human_readable_source": " \n \n\n#ifndef _KUNIT_RESOURCE_H\n#define _KUNIT_RESOURCE_H\n\n#include <kunit/test.h>\n\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\nstruct kunit_resource;\n\ntypedef int (*kunit_resource_init_t)(struct kunit_resource *, void *);\ntypedef void (*kunit_resource_free_t)(struct kunit_resource *);\n\n \nstruct kunit_resource {\n\tvoid *data;\n\tconst char *name;\n\tkunit_resource_free_t free;\n\n\t \n\tstruct kref refcount;\n\tstruct list_head node;\n\tbool should_kfree;\n};\n\n \nstatic inline void kunit_get_resource(struct kunit_resource *res)\n{\n\tkref_get(&res->refcount);\n}\n\n \nstatic inline void kunit_release_resource(struct kref *kref)\n{\n\tstruct kunit_resource *res = container_of(kref, struct kunit_resource,\n\t\t\t\t\t\t  refcount);\n\n\tif (res->free)\n\t\tres->free(res);\n\n\t \n\tif (res->should_kfree)\n\t\tkfree(res);\n}\n\n \nstatic inline void kunit_put_resource(struct kunit_resource *res)\n{\n\tkref_put(&res->refcount, kunit_release_resource);\n}\n\n \nint __kunit_add_resource(struct kunit *test,\n\t\t\t kunit_resource_init_t init,\n\t\t\t kunit_resource_free_t free,\n\t\t\t struct kunit_resource *res,\n\t\t\t void *data);\n\n \nstatic inline int kunit_add_resource(struct kunit *test,\n\t\t\t\t     kunit_resource_init_t init,\n\t\t\t\t     kunit_resource_free_t free,\n\t\t\t\t     struct kunit_resource *res,\n\t\t\t\t     void *data)\n{\n\tres->should_kfree = false;\n\treturn __kunit_add_resource(test, init, free, res, data);\n}\n\nstatic inline struct kunit_resource *\nkunit_find_named_resource(struct kunit *test, const char *name);\n\n \nstatic inline int kunit_add_named_resource(struct kunit *test,\n\t\t\t\t\t   kunit_resource_init_t init,\n\t\t\t\t\t   kunit_resource_free_t free,\n\t\t\t\t\t   struct kunit_resource *res,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   void *data)\n{\n\tstruct kunit_resource *existing;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\texisting = kunit_find_named_resource(test, name);\n\tif (existing) {\n\t\tkunit_put_resource(existing);\n\t\treturn -EEXIST;\n\t}\n\n\tres->name = name;\n\tres->should_kfree = false;\n\n\treturn __kunit_add_resource(test, init, free, res, data);\n}\n\n \nstatic inline struct kunit_resource *\nkunit_alloc_and_get_resource(struct kunit *test,\n\t\t\t     kunit_resource_init_t init,\n\t\t\t     kunit_resource_free_t free,\n\t\t\t     gfp_t internal_gfp,\n\t\t\t     void *context)\n{\n\tstruct kunit_resource *res;\n\tint ret;\n\n\tres = kzalloc(sizeof(*res), internal_gfp);\n\tif (!res)\n\t\treturn NULL;\n\n\tres->should_kfree = true;\n\n\tret = __kunit_add_resource(test, init, free, res, context);\n\tif (!ret) {\n\t\t \n\t\tkunit_get_resource(res);\n\t\treturn res;\n\t}\n\treturn NULL;\n}\n\n \nstatic inline void *kunit_alloc_resource(struct kunit *test,\n\t\t\t\t\t kunit_resource_init_t init,\n\t\t\t\t\t kunit_resource_free_t free,\n\t\t\t\t\t gfp_t internal_gfp,\n\t\t\t\t\t void *context)\n{\n\tstruct kunit_resource *res;\n\n\tres = kzalloc(sizeof(*res), internal_gfp);\n\tif (!res)\n\t\treturn NULL;\n\n\tres->should_kfree = true;\n\tif (!__kunit_add_resource(test, init, free, res, context))\n\t\treturn res->data;\n\n\treturn NULL;\n}\n\ntypedef bool (*kunit_resource_match_t)(struct kunit *test,\n\t\t\t\t       struct kunit_resource *res,\n\t\t\t\t       void *match_data);\n\n \nstatic inline bool kunit_resource_name_match(struct kunit *test,\n\t\t\t\t\t     struct kunit_resource *res,\n\t\t\t\t\t     void *match_name)\n{\n\treturn res->name && strcmp(res->name, match_name) == 0;\n}\n\n \nstatic inline struct kunit_resource *\nkunit_find_resource(struct kunit *test,\n\t\t    kunit_resource_match_t match,\n\t\t    void *match_data)\n{\n\tstruct kunit_resource *res, *found = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&test->lock, flags);\n\n\tlist_for_each_entry_reverse(res, &test->resources, node) {\n\t\tif (match(test, res, (void *)match_data)) {\n\t\t\tfound = res;\n\t\t\tkunit_get_resource(found);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&test->lock, flags);\n\n\treturn found;\n}\n\n \nstatic inline struct kunit_resource *\nkunit_find_named_resource(struct kunit *test,\n\t\t\t  const char *name)\n{\n\treturn kunit_find_resource(test, kunit_resource_name_match,\n\t\t\t\t   (void *)name);\n}\n\n \nint kunit_destroy_resource(struct kunit *test,\n\t\t\t   kunit_resource_match_t match,\n\t\t\t   void *match_data);\n\nstatic inline int kunit_destroy_named_resource(struct kunit *test,\n\t\t\t\t\t       const char *name)\n{\n\treturn kunit_destroy_resource(test, kunit_resource_name_match,\n\t\t\t\t      (void *)name);\n}\n\n \nvoid kunit_remove_resource(struct kunit *test, struct kunit_resource *res);\n\n \ntypedef void (kunit_action_t)(void *);\n\n \nint kunit_add_action(struct kunit *test, kunit_action_t *action, void *ctx);\n\n \nint kunit_add_action_or_reset(struct kunit *test, kunit_action_t *action,\n\t\t\t      void *ctx);\n\n \nvoid kunit_remove_action(struct kunit *test,\n\t\t\t kunit_action_t *action,\n\t\t\t void *ctx);\n\n \nvoid kunit_release_action(struct kunit *test,\n\t\t\t  kunit_action_t *action,\n\t\t\t  void *ctx);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}