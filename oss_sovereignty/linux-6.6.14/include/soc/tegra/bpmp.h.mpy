{
  "module_name": "bpmp.h",
  "hash_id": "f2121e4fcf391df7adbef0a22b278df2a3d16f7511315716e69e9d8067b1eeae",
  "original_prompt": "Ingested from linux-6.6.14/include/soc/tegra/bpmp.h",
  "human_readable_source": " \n \n\n#ifndef __SOC_TEGRA_BPMP_H\n#define __SOC_TEGRA_BPMP_H\n\n#include <linux/iosys-map.h>\n#include <linux/mailbox_client.h>\n#include <linux/pm_domain.h>\n#include <linux/reset-controller.h>\n#include <linux/semaphore.h>\n#include <linux/types.h>\n\n#include <soc/tegra/bpmp-abi.h>\n\nstruct tegra_bpmp_clk;\nstruct tegra_bpmp_ops;\n\nstruct tegra_bpmp_soc {\n\tstruct {\n\t\tstruct {\n\t\t\tunsigned int offset;\n\t\t\tunsigned int count;\n\t\t\tunsigned int timeout;\n\t\t} cpu_tx, thread, cpu_rx;\n\t} channels;\n\n\tconst struct tegra_bpmp_ops *ops;\n\tunsigned int num_resets;\n};\n\nstruct tegra_bpmp_mb_data {\n\tu32 code;\n\tu32 flags;\n\tu8 data[MSG_DATA_MIN_SZ];\n} __packed;\n\n#define tegra_bpmp_mb_read(dst, mb, size) \\\n\tiosys_map_memcpy_from(dst, mb, offsetof(struct tegra_bpmp_mb_data, data), size)\n\n#define tegra_bpmp_mb_write(mb, src, size) \\\n\tiosys_map_memcpy_to(mb, offsetof(struct tegra_bpmp_mb_data, data), src, size)\n\n#define tegra_bpmp_mb_read_field(mb, field) \\\n\tiosys_map_rd_field(mb, 0, struct tegra_bpmp_mb_data, field)\n\n#define tegra_bpmp_mb_write_field(mb, field, value) \\\n\tiosys_map_wr_field(mb, 0, struct tegra_bpmp_mb_data, field, value)\n\nstruct tegra_bpmp_channel {\n\tstruct tegra_bpmp *bpmp;\n\tstruct iosys_map ib;\n\tstruct iosys_map ob;\n\tstruct completion completion;\n\tstruct tegra_ivc *ivc;\n\tunsigned int index;\n};\n\ntypedef void (*tegra_bpmp_mrq_handler_t)(unsigned int mrq,\n\t\t\t\t\t struct tegra_bpmp_channel *channel,\n\t\t\t\t\t void *data);\n\nstruct tegra_bpmp_mrq {\n\tstruct list_head list;\n\tunsigned int mrq;\n\ttegra_bpmp_mrq_handler_t handler;\n\tvoid *data;\n};\n\nstruct tegra_bpmp {\n\tconst struct tegra_bpmp_soc *soc;\n\tstruct device *dev;\n\tvoid *priv;\n\n\tstruct {\n\t\tstruct mbox_client client;\n\t\tstruct mbox_chan *channel;\n\t} mbox;\n\n\tspinlock_t atomic_tx_lock;\n\tstruct tegra_bpmp_channel *tx_channel, *rx_channel, *threaded_channels;\n\n\tstruct {\n\t\tunsigned long *allocated;\n\t\tunsigned long *busy;\n\t\tunsigned int count;\n\t\tstruct semaphore lock;\n\t} threaded;\n\n\tstruct list_head mrqs;\n\tspinlock_t lock;\n\n\tstruct tegra_bpmp_clk **clocks;\n\tunsigned int num_clocks;\n\n\tstruct reset_controller_dev rstc;\n\n\tstruct genpd_onecell_data genpd;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *debugfs_mirror;\n#endif\n\n\tbool suspended;\n};\n\n#define TEGRA_BPMP_MESSAGE_RESET BIT(0)\n\nstruct tegra_bpmp_message {\n\tunsigned int mrq;\n\n\tstruct {\n\t\tconst void *data;\n\t\tsize_t size;\n\t} tx;\n\n\tstruct {\n\t\tvoid *data;\n\t\tsize_t size;\n\t\tint ret;\n\t} rx;\n\n\tunsigned long flags;\n};\n\n#if IS_ENABLED(CONFIG_TEGRA_BPMP)\nstruct tegra_bpmp *tegra_bpmp_get(struct device *dev);\nvoid tegra_bpmp_put(struct tegra_bpmp *bpmp);\nint tegra_bpmp_transfer_atomic(struct tegra_bpmp *bpmp,\n\t\t\t       struct tegra_bpmp_message *msg);\nint tegra_bpmp_transfer(struct tegra_bpmp *bpmp,\n\t\t\tstruct tegra_bpmp_message *msg);\nvoid tegra_bpmp_mrq_return(struct tegra_bpmp_channel *channel, int code,\n\t\t\t   const void *data, size_t size);\n\nint tegra_bpmp_request_mrq(struct tegra_bpmp *bpmp, unsigned int mrq,\n\t\t\t   tegra_bpmp_mrq_handler_t handler, void *data);\nvoid tegra_bpmp_free_mrq(struct tegra_bpmp *bpmp, unsigned int mrq,\n\t\t\t void *data);\nbool tegra_bpmp_mrq_is_supported(struct tegra_bpmp *bpmp, unsigned int mrq);\n#else\nstatic inline struct tegra_bpmp *tegra_bpmp_get(struct device *dev)\n{\n\treturn ERR_PTR(-ENOTSUPP);\n}\nstatic inline void tegra_bpmp_put(struct tegra_bpmp *bpmp)\n{\n}\nstatic inline int tegra_bpmp_transfer_atomic(struct tegra_bpmp *bpmp,\n\t\t\t\t\t     struct tegra_bpmp_message *msg)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int tegra_bpmp_transfer(struct tegra_bpmp *bpmp,\n\t\t\t\t      struct tegra_bpmp_message *msg)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline void tegra_bpmp_mrq_return(struct tegra_bpmp_channel *channel,\n\t\t\t\t\t int code, const void *data,\n\t\t\t\t\t size_t size)\n{\n}\n\nstatic inline int tegra_bpmp_request_mrq(struct tegra_bpmp *bpmp,\n\t\t\t\t\t unsigned int mrq,\n\t\t\t\t\t tegra_bpmp_mrq_handler_t handler,\n\t\t\t\t\t void *data)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline void tegra_bpmp_free_mrq(struct tegra_bpmp *bpmp,\n\t\t\t\t       unsigned int mrq, void *data)\n{\n}\n\nstatic inline bool tegra_bpmp_mrq_is_supported(struct tegra_bpmp *bpmp,\n\t\t\t\t\t      unsigned int mrq)\n{\n\treturn false;\n}\n#endif\n\nvoid tegra_bpmp_handle_rx(struct tegra_bpmp *bpmp);\n\n#if IS_ENABLED(CONFIG_CLK_TEGRA_BPMP)\nint tegra_bpmp_init_clocks(struct tegra_bpmp *bpmp);\n#else\nstatic inline int tegra_bpmp_init_clocks(struct tegra_bpmp *bpmp)\n{\n\treturn 0;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_RESET_TEGRA_BPMP)\nint tegra_bpmp_init_resets(struct tegra_bpmp *bpmp);\n#else\nstatic inline int tegra_bpmp_init_resets(struct tegra_bpmp *bpmp)\n{\n\treturn 0;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_SOC_TEGRA_POWERGATE_BPMP)\nint tegra_bpmp_init_powergates(struct tegra_bpmp *bpmp);\n#else\nstatic inline int tegra_bpmp_init_powergates(struct tegra_bpmp *bpmp)\n{\n\treturn 0;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_DEBUG_FS)\nint tegra_bpmp_init_debugfs(struct tegra_bpmp *bpmp);\n#else\nstatic inline int tegra_bpmp_init_debugfs(struct tegra_bpmp *bpmp)\n{\n\treturn 0;\n}\n#endif\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}