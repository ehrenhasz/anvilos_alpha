{
  "module_name": "smp.h",
  "hash_id": "653a4728799ed8a4e004e159692c26472f2a38a5568a5e3a63df6d8a2950dc70",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/smp.h",
  "human_readable_source": " \n#ifndef __LINUX_SMP_H\n#define __LINUX_SMP_H\n\n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/cpumask.h>\n#include <linux/init.h>\n#include <linux/smp_types.h>\n\ntypedef void (*smp_call_func_t)(void *info);\ntypedef bool (*smp_cond_func_t)(int cpu, void *info);\n\n \nstruct __call_single_data {\n\tstruct __call_single_node node;\n\tsmp_call_func_t func;\n\tvoid *info;\n};\n\n#define CSD_INIT(_func, _info) \\\n\t(struct __call_single_data){ .func = (_func), .info = (_info), }\n\n \ntypedef struct __call_single_data call_single_data_t\n\t__aligned(sizeof(struct __call_single_data));\n\n#define INIT_CSD(_csd, _func, _info)\t\t\\\ndo {\t\t\t\t\t\t\\\n\t*(_csd) = CSD_INIT((_func), (_info));\t\\\n} while (0)\n\n \nextern void __smp_call_single_queue(int cpu, struct llist_node *node);\n\n \nextern unsigned int total_cpus;\n\nint smp_call_function_single(int cpuid, smp_call_func_t func, void *info,\n\t\t\t     int wait);\n\nvoid on_each_cpu_cond_mask(smp_cond_func_t cond_func, smp_call_func_t func,\n\t\t\t   void *info, bool wait, const struct cpumask *mask);\n\nint smp_call_function_single_async(int cpu, struct __call_single_data *csd);\n\n \nvoid __noreturn panic_smp_self_stop(void);\nvoid __noreturn nmi_panic_self_stop(struct pt_regs *regs);\nvoid crash_smp_send_stop(void);\n\n \nstatic inline void on_each_cpu(smp_call_func_t func, void *info, int wait)\n{\n\ton_each_cpu_cond_mask(NULL, func, info, wait, cpu_online_mask);\n}\n\n \nstatic inline void on_each_cpu_mask(const struct cpumask *mask,\n\t\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\ton_each_cpu_cond_mask(NULL, func, info, wait, mask);\n}\n\n \nstatic inline void on_each_cpu_cond(smp_cond_func_t cond_func,\n\t\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\ton_each_cpu_cond_mask(cond_func, func, info, wait, cpu_online_mask);\n}\n\n#ifdef CONFIG_SMP\n\n#include <linux/preempt.h>\n#include <linux/compiler.h>\n#include <linux/thread_info.h>\n#include <asm/smp.h>\n\n \n\n \nextern void smp_send_stop(void);\n\n \nextern void arch_smp_send_reschedule(int cpu);\n \n#define smp_send_reschedule(cpu) ({\t\t  \\\n\ttrace_ipi_send_cpu(cpu, _RET_IP_, NULL);  \\\n\tarch_smp_send_reschedule(cpu);\t\t  \\\n})\n\n \nextern void smp_prepare_cpus(unsigned int max_cpus);\n\n \nextern int __cpu_up(unsigned int cpunum, struct task_struct *tidle);\n\n \nextern void smp_cpus_done(unsigned int max_cpus);\n\n \nvoid smp_call_function(smp_call_func_t func, void *info, int wait);\nvoid smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait);\n\nint smp_call_function_any(const struct cpumask *mask,\n\t\t\t  smp_call_func_t func, void *info, int wait);\n\nvoid kick_all_cpus_sync(void);\nvoid wake_up_all_idle_cpus(void);\n\n \nvoid __init call_function_init(void);\nvoid generic_smp_call_function_single_interrupt(void);\n#define generic_smp_call_function_interrupt \\\n\tgeneric_smp_call_function_single_interrupt\n\n \nvoid smp_prepare_boot_cpu(void);\n\nextern unsigned int setup_max_cpus;\nextern void __init setup_nr_cpu_ids(void);\nextern void __init smp_init(void);\n\nextern int __boot_cpu_id;\n\nstatic inline int get_boot_cpu_id(void)\n{\n\treturn __boot_cpu_id;\n}\n\n#else  \n\nstatic inline void smp_send_stop(void) { }\n\n \n#define raw_smp_processor_id()\t\t\t0\nstatic inline void up_smp_call_function(smp_call_func_t func, void *info)\n{\n}\n#define smp_call_function(func, info, wait) \\\n\t\t\t(up_smp_call_function(func, info))\n\nstatic inline void smp_send_reschedule(int cpu) { }\n#define smp_prepare_boot_cpu()\t\t\tdo {} while (0)\n#define smp_call_function_many(mask, func, info, wait) \\\n\t\t\t(up_smp_call_function(func, info))\nstatic inline void call_function_init(void) { }\n\nstatic inline int\nsmp_call_function_any(const struct cpumask *mask, smp_call_func_t func,\n\t\t      void *info, int wait)\n{\n\treturn smp_call_function_single(0, func, info, wait);\n}\n\nstatic inline void kick_all_cpus_sync(void) {  }\nstatic inline void wake_up_all_idle_cpus(void) {  }\n\n#ifdef CONFIG_UP_LATE_INIT\nextern void __init up_late_init(void);\nstatic inline void smp_init(void) { up_late_init(); }\n#else\nstatic inline void smp_init(void) { }\n#endif\n\nstatic inline int get_boot_cpu_id(void)\n{\n\treturn 0;\n}\n\n#endif  \n\n \n\n \n\n \n#ifndef __smp_processor_id\n#define __smp_processor_id(x) raw_smp_processor_id(x)\n#endif\n\n#ifdef CONFIG_DEBUG_PREEMPT\n  extern unsigned int debug_smp_processor_id(void);\n# define smp_processor_id() debug_smp_processor_id()\n#else\n# define smp_processor_id() __smp_processor_id()\n#endif\n\n#define get_cpu()\t\t({ preempt_disable(); __smp_processor_id(); })\n#define put_cpu()\t\tpreempt_enable()\n\n \nextern void arch_disable_smp_support(void);\n\nextern void arch_thaw_secondary_cpus_begin(void);\nextern void arch_thaw_secondary_cpus_end(void);\n\nvoid smp_setup_processor_id(void);\n\nint smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par,\n\t\t    bool phys);\n\n \nint smpcfd_prepare_cpu(unsigned int cpu);\nint smpcfd_dead_cpu(unsigned int cpu);\nint smpcfd_dying_cpu(unsigned int cpu);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}