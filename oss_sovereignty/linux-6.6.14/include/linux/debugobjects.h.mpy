{
  "module_name": "debugobjects.h",
  "hash_id": "aa44fc42ad5f12c383817b71692d8a7779812c6d2deb95cbc8b033e406b058b2",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/debugobjects.h",
  "human_readable_source": " \n#ifndef _LINUX_DEBUGOBJECTS_H\n#define _LINUX_DEBUGOBJECTS_H\n\n#include <linux/list.h>\n#include <linux/spinlock.h>\n\nenum debug_obj_state {\n\tODEBUG_STATE_NONE,\n\tODEBUG_STATE_INIT,\n\tODEBUG_STATE_INACTIVE,\n\tODEBUG_STATE_ACTIVE,\n\tODEBUG_STATE_DESTROYED,\n\tODEBUG_STATE_NOTAVAILABLE,\n\tODEBUG_STATE_MAX,\n};\n\nstruct debug_obj_descr;\n\n \nstruct debug_obj {\n\tstruct hlist_node\tnode;\n\tenum debug_obj_state\tstate;\n\tunsigned int\t\tastate;\n\tvoid\t\t\t*object;\n\tconst struct debug_obj_descr *descr;\n};\n\n \nstruct debug_obj_descr {\n\tconst char\t\t*name;\n\tvoid *(*debug_hint)(void *addr);\n\tbool (*is_static_object)(void *addr);\n\tbool (*fixup_init)(void *addr, enum debug_obj_state state);\n\tbool (*fixup_activate)(void *addr, enum debug_obj_state state);\n\tbool (*fixup_destroy)(void *addr, enum debug_obj_state state);\n\tbool (*fixup_free)(void *addr, enum debug_obj_state state);\n\tbool (*fixup_assert_init)(void *addr, enum debug_obj_state state);\n};\n\n#ifdef CONFIG_DEBUG_OBJECTS\nextern void debug_object_init      (void *addr, const struct debug_obj_descr *descr);\nextern void\ndebug_object_init_on_stack(void *addr, const struct debug_obj_descr *descr);\nextern int debug_object_activate  (void *addr, const struct debug_obj_descr *descr);\nextern void debug_object_deactivate(void *addr, const struct debug_obj_descr *descr);\nextern void debug_object_destroy   (void *addr, const struct debug_obj_descr *descr);\nextern void debug_object_free      (void *addr, const struct debug_obj_descr *descr);\nextern void debug_object_assert_init(void *addr, const struct debug_obj_descr *descr);\n\n \nextern void\ndebug_object_active_state(void *addr, const struct debug_obj_descr *descr,\n\t\t\t  unsigned int expect, unsigned int next);\n\nextern void debug_objects_early_init(void);\nextern void debug_objects_mem_init(void);\n#else\nstatic inline void\ndebug_object_init      (void *addr, const struct debug_obj_descr *descr) { }\nstatic inline void\ndebug_object_init_on_stack(void *addr, const struct debug_obj_descr *descr) { }\nstatic inline int\ndebug_object_activate  (void *addr, const struct debug_obj_descr *descr) { return 0; }\nstatic inline void\ndebug_object_deactivate(void *addr, const struct debug_obj_descr *descr) { }\nstatic inline void\ndebug_object_destroy   (void *addr, const struct debug_obj_descr *descr) { }\nstatic inline void\ndebug_object_free      (void *addr, const struct debug_obj_descr *descr) { }\nstatic inline void\ndebug_object_assert_init(void *addr, const struct debug_obj_descr *descr) { }\n\nstatic inline void debug_objects_early_init(void) { }\nstatic inline void debug_objects_mem_init(void) { }\n#endif\n\n#ifdef CONFIG_DEBUG_OBJECTS_FREE\nextern void debug_check_no_obj_freed(const void *address, unsigned long size);\n#else\nstatic inline void\ndebug_check_no_obj_freed(const void *address, unsigned long size) { }\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}