{
  "module_name": "entry-common.h",
  "hash_id": "72294ba8d000cebf7001ca04d208b2a057a719af61ebed2f88f91c168446400b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/entry-common.h",
  "human_readable_source": " \n#ifndef __LINUX_ENTRYCOMMON_H\n#define __LINUX_ENTRYCOMMON_H\n\n#include <linux/static_call_types.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/seccomp.h>\n#include <linux/sched.h>\n\n#include <asm/entry-common.h>\n\n \n#ifndef _TIF_PATCH_PENDING\n# define _TIF_PATCH_PENDING\t\t(0)\n#endif\n\n#ifndef _TIF_UPROBE\n# define _TIF_UPROBE\t\t\t(0)\n#endif\n\n \n#ifndef ARCH_SYSCALL_WORK_ENTER\n# define ARCH_SYSCALL_WORK_ENTER\t(0)\n#endif\n\n \n#ifndef ARCH_SYSCALL_WORK_EXIT\n# define ARCH_SYSCALL_WORK_EXIT\t\t(0)\n#endif\n\n#define SYSCALL_WORK_ENTER\t(SYSCALL_WORK_SECCOMP |\t\t\t\\\n\t\t\t\t SYSCALL_WORK_SYSCALL_TRACEPOINT |\t\\\n\t\t\t\t SYSCALL_WORK_SYSCALL_TRACE |\t\t\\\n\t\t\t\t SYSCALL_WORK_SYSCALL_EMU |\t\t\\\n\t\t\t\t SYSCALL_WORK_SYSCALL_AUDIT |\t\t\\\n\t\t\t\t SYSCALL_WORK_SYSCALL_USER_DISPATCH |\t\\\n\t\t\t\t ARCH_SYSCALL_WORK_ENTER)\n#define SYSCALL_WORK_EXIT\t(SYSCALL_WORK_SYSCALL_TRACEPOINT |\t\\\n\t\t\t\t SYSCALL_WORK_SYSCALL_TRACE |\t\t\\\n\t\t\t\t SYSCALL_WORK_SYSCALL_AUDIT |\t\t\\\n\t\t\t\t SYSCALL_WORK_SYSCALL_USER_DISPATCH |\t\\\n\t\t\t\t SYSCALL_WORK_SYSCALL_EXIT_TRAP\t|\t\\\n\t\t\t\t ARCH_SYSCALL_WORK_EXIT)\n\n \n#ifndef ARCH_EXIT_TO_USER_MODE_WORK\n# define ARCH_EXIT_TO_USER_MODE_WORK\t\t(0)\n#endif\n\n#define EXIT_TO_USER_MODE_WORK\t\t\t\t\t\t\\\n\t(_TIF_SIGPENDING | _TIF_NOTIFY_RESUME | _TIF_UPROBE |\t\t\\\n\t _TIF_NEED_RESCHED | _TIF_PATCH_PENDING | _TIF_NOTIFY_SIGNAL |\t\\\n\t ARCH_EXIT_TO_USER_MODE_WORK)\n\n \nstatic __always_inline void arch_enter_from_user_mode(struct pt_regs *regs);\n\n#ifndef arch_enter_from_user_mode\nstatic __always_inline void arch_enter_from_user_mode(struct pt_regs *regs) {}\n#endif\n\n \nvoid enter_from_user_mode(struct pt_regs *regs);\n\n \nvoid syscall_enter_from_user_mode_prepare(struct pt_regs *regs);\n\n \nlong syscall_enter_from_user_mode_work(struct pt_regs *regs, long syscall);\n\n \nlong syscall_enter_from_user_mode(struct pt_regs *regs, long syscall);\n\n \nstatic inline void local_irq_enable_exit_to_user(unsigned long ti_work);\n\n#ifndef local_irq_enable_exit_to_user\nstatic inline void local_irq_enable_exit_to_user(unsigned long ti_work)\n{\n\tlocal_irq_enable();\n}\n#endif\n\n \nstatic inline void local_irq_disable_exit_to_user(void);\n\n#ifndef local_irq_disable_exit_to_user\nstatic inline void local_irq_disable_exit_to_user(void)\n{\n\tlocal_irq_disable();\n}\n#endif\n\n \nstatic inline void arch_exit_to_user_mode_work(struct pt_regs *regs,\n\t\t\t\t\t       unsigned long ti_work);\n\n#ifndef arch_exit_to_user_mode_work\nstatic inline void arch_exit_to_user_mode_work(struct pt_regs *regs,\n\t\t\t\t\t       unsigned long ti_work)\n{\n}\n#endif\n\n \nstatic inline void arch_exit_to_user_mode_prepare(struct pt_regs *regs,\n\t\t\t\t\t\t  unsigned long ti_work);\n\n#ifndef arch_exit_to_user_mode_prepare\nstatic inline void arch_exit_to_user_mode_prepare(struct pt_regs *regs,\n\t\t\t\t\t\t  unsigned long ti_work)\n{\n}\n#endif\n\n \nstatic __always_inline void arch_exit_to_user_mode(void);\n\n#ifndef arch_exit_to_user_mode\nstatic __always_inline void arch_exit_to_user_mode(void) { }\n#endif\n\n \nvoid arch_do_signal_or_restart(struct pt_regs *regs);\n\n \nvoid exit_to_user_mode(void);\n\n \nvoid syscall_exit_to_user_mode_work(struct pt_regs *regs);\n\n \nvoid syscall_exit_to_user_mode(struct pt_regs *regs);\n\n \nvoid irqentry_enter_from_user_mode(struct pt_regs *regs);\n\n \nvoid irqentry_exit_to_user_mode(struct pt_regs *regs);\n\n#ifndef irqentry_state\n \ntypedef struct irqentry_state {\n\tunion {\n\t\tbool\texit_rcu;\n\t\tbool\tlockdep;\n\t};\n} irqentry_state_t;\n#endif\n\n \nirqentry_state_t noinstr irqentry_enter(struct pt_regs *regs);\n\n \nvoid raw_irqentry_exit_cond_resched(void);\n#ifdef CONFIG_PREEMPT_DYNAMIC\n#if defined(CONFIG_HAVE_PREEMPT_DYNAMIC_CALL)\n#define irqentry_exit_cond_resched_dynamic_enabled\traw_irqentry_exit_cond_resched\n#define irqentry_exit_cond_resched_dynamic_disabled\tNULL\nDECLARE_STATIC_CALL(irqentry_exit_cond_resched, raw_irqentry_exit_cond_resched);\n#define irqentry_exit_cond_resched()\tstatic_call(irqentry_exit_cond_resched)()\n#elif defined(CONFIG_HAVE_PREEMPT_DYNAMIC_KEY)\nDECLARE_STATIC_KEY_TRUE(sk_dynamic_irqentry_exit_cond_resched);\nvoid dynamic_irqentry_exit_cond_resched(void);\n#define irqentry_exit_cond_resched()\tdynamic_irqentry_exit_cond_resched()\n#endif\n#else  \n#define irqentry_exit_cond_resched()\traw_irqentry_exit_cond_resched()\n#endif  \n\n \nvoid noinstr irqentry_exit(struct pt_regs *regs, irqentry_state_t state);\n\n \nirqentry_state_t noinstr irqentry_nmi_enter(struct pt_regs *regs);\n\n \nvoid noinstr irqentry_nmi_exit(struct pt_regs *regs, irqentry_state_t irq_state);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}