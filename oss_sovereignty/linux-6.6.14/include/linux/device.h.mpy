{
  "module_name": "device.h",
  "hash_id": "8710e64bb62ebc227805608047392d492f7c3ac232c8630f0f6388bad07b0f65",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/device.h",
  "human_readable_source": "\n \n\n#ifndef _DEVICE_H_\n#define _DEVICE_H_\n\n#include <linux/dev_printk.h>\n#include <linux/energy_model.h>\n#include <linux/ioport.h>\n#include <linux/kobject.h>\n#include <linux/klist.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/pm.h>\n#include <linux/atomic.h>\n#include <linux/uidgid.h>\n#include <linux/gfp.h>\n#include <linux/overflow.h>\n#include <linux/device/bus.h>\n#include <linux/device/class.h>\n#include <linux/device/driver.h>\n#include <linux/cleanup.h>\n#include <asm/device.h>\n\nstruct device;\nstruct device_private;\nstruct device_driver;\nstruct driver_private;\nstruct module;\nstruct class;\nstruct subsys_private;\nstruct device_node;\nstruct fwnode_handle;\nstruct iommu_ops;\nstruct iommu_group;\nstruct dev_pin_info;\nstruct dev_iommu;\nstruct msi_device_data;\n\n \nstruct subsys_interface {\n\tconst char *name;\n\tstruct bus_type *subsys;\n\tstruct list_head node;\n\tint (*add_dev)(struct device *dev, struct subsys_interface *sif);\n\tvoid (*remove_dev)(struct device *dev, struct subsys_interface *sif);\n};\n\nint subsys_interface_register(struct subsys_interface *sif);\nvoid subsys_interface_unregister(struct subsys_interface *sif);\n\nint subsys_system_register(struct bus_type *subsys,\n\t\t\t   const struct attribute_group **groups);\nint subsys_virtual_register(struct bus_type *subsys,\n\t\t\t    const struct attribute_group **groups);\n\n \nstruct device_type {\n\tconst char *name;\n\tconst struct attribute_group **groups;\n\tint (*uevent)(const struct device *dev, struct kobj_uevent_env *env);\n\tchar *(*devnode)(const struct device *dev, umode_t *mode,\n\t\t\t kuid_t *uid, kgid_t *gid);\n\tvoid (*release)(struct device *dev);\n\n\tconst struct dev_pm_ops *pm;\n};\n\n \nstruct device_attribute {\n\tstruct attribute\tattr;\n\tssize_t (*show)(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf);\n\tssize_t (*store)(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count);\n};\n\n \nstruct dev_ext_attribute {\n\tstruct device_attribute attr;\n\tvoid *var;\n};\n\nssize_t device_show_ulong(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf);\nssize_t device_store_ulong(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count);\nssize_t device_show_int(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf);\nssize_t device_store_int(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count);\nssize_t device_show_bool(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf);\nssize_t device_store_bool(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count);\n\n \n#define DEVICE_ATTR(_name, _mode, _show, _store) \\\n\tstruct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)\n\n \n#define DEVICE_ATTR_PREALLOC(_name, _mode, _show, _store) \\\n\tstruct device_attribute dev_attr_##_name = \\\n\t\t__ATTR_PREALLOC(_name, _mode, _show, _store)\n\n \n#define DEVICE_ATTR_RW(_name) \\\n\tstruct device_attribute dev_attr_##_name = __ATTR_RW(_name)\n\n \n#define DEVICE_ATTR_ADMIN_RW(_name) \\\n\tstruct device_attribute dev_attr_##_name = __ATTR_RW_MODE(_name, 0600)\n\n \n#define DEVICE_ATTR_RO(_name) \\\n\tstruct device_attribute dev_attr_##_name = __ATTR_RO(_name)\n\n \n#define DEVICE_ATTR_ADMIN_RO(_name) \\\n\tstruct device_attribute dev_attr_##_name = __ATTR_RO_MODE(_name, 0400)\n\n \n#define DEVICE_ATTR_WO(_name) \\\n\tstruct device_attribute dev_attr_##_name = __ATTR_WO(_name)\n\n \n#define DEVICE_ULONG_ATTR(_name, _mode, _var) \\\n\tstruct dev_ext_attribute dev_attr_##_name = \\\n\t\t{ __ATTR(_name, _mode, device_show_ulong, device_store_ulong), &(_var) }\n\n \n#define DEVICE_INT_ATTR(_name, _mode, _var) \\\n\tstruct dev_ext_attribute dev_attr_##_name = \\\n\t\t{ __ATTR(_name, _mode, device_show_int, device_store_int), &(_var) }\n\n \n#define DEVICE_BOOL_ATTR(_name, _mode, _var) \\\n\tstruct dev_ext_attribute dev_attr_##_name = \\\n\t\t{ __ATTR(_name, _mode, device_show_bool, device_store_bool), &(_var) }\n\n#define DEVICE_ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) \\\n\tstruct device_attribute dev_attr_##_name =\t\t\\\n\t\t__ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store)\n\nint device_create_file(struct device *device,\n\t\t       const struct device_attribute *entry);\nvoid device_remove_file(struct device *dev,\n\t\t\tconst struct device_attribute *attr);\nbool device_remove_file_self(struct device *dev,\n\t\t\t     const struct device_attribute *attr);\nint __must_check device_create_bin_file(struct device *dev,\n\t\t\t\t\tconst struct bin_attribute *attr);\nvoid device_remove_bin_file(struct device *dev,\n\t\t\t    const struct bin_attribute *attr);\n\n \ntypedef void (*dr_release_t)(struct device *dev, void *res);\ntypedef int (*dr_match_t)(struct device *dev, void *res, void *match_data);\n\nvoid *__devres_alloc_node(dr_release_t release, size_t size, gfp_t gfp,\n\t\t\t  int nid, const char *name) __malloc;\n#define devres_alloc(release, size, gfp) \\\n\t__devres_alloc_node(release, size, gfp, NUMA_NO_NODE, #release)\n#define devres_alloc_node(release, size, gfp, nid) \\\n\t__devres_alloc_node(release, size, gfp, nid, #release)\n\nvoid devres_for_each_res(struct device *dev, dr_release_t release,\n\t\t\t dr_match_t match, void *match_data,\n\t\t\t void (*fn)(struct device *, void *, void *),\n\t\t\t void *data);\nvoid devres_free(void *res);\nvoid devres_add(struct device *dev, void *res);\nvoid *devres_find(struct device *dev, dr_release_t release,\n\t\t  dr_match_t match, void *match_data);\nvoid *devres_get(struct device *dev, void *new_res,\n\t\t dr_match_t match, void *match_data);\nvoid *devres_remove(struct device *dev, dr_release_t release,\n\t\t    dr_match_t match, void *match_data);\nint devres_destroy(struct device *dev, dr_release_t release,\n\t\t   dr_match_t match, void *match_data);\nint devres_release(struct device *dev, dr_release_t release,\n\t\t   dr_match_t match, void *match_data);\n\n \nvoid * __must_check devres_open_group(struct device *dev, void *id, gfp_t gfp);\nvoid devres_close_group(struct device *dev, void *id);\nvoid devres_remove_group(struct device *dev, void *id);\nint devres_release_group(struct device *dev, void *id);\n\n \nvoid *devm_kmalloc(struct device *dev, size_t size, gfp_t gfp) __alloc_size(2);\nvoid *devm_krealloc(struct device *dev, void *ptr, size_t size,\n\t\t    gfp_t gfp) __must_check __realloc_size(3);\n__printf(3, 0) char *devm_kvasprintf(struct device *dev, gfp_t gfp,\n\t\t\t\t     const char *fmt, va_list ap) __malloc;\n__printf(3, 4) char *devm_kasprintf(struct device *dev, gfp_t gfp,\n\t\t\t\t    const char *fmt, ...) __malloc;\nstatic inline void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)\n{\n\treturn devm_kmalloc(dev, size, gfp | __GFP_ZERO);\n}\nstatic inline void *devm_kmalloc_array(struct device *dev,\n\t\t\t\t       size_t n, size_t size, gfp_t flags)\n{\n\tsize_t bytes;\n\n\tif (unlikely(check_mul_overflow(n, size, &bytes)))\n\t\treturn NULL;\n\n\treturn devm_kmalloc(dev, bytes, flags);\n}\nstatic inline void *devm_kcalloc(struct device *dev,\n\t\t\t\t size_t n, size_t size, gfp_t flags)\n{\n\treturn devm_kmalloc_array(dev, n, size, flags | __GFP_ZERO);\n}\nstatic inline __realloc_size(3, 4) void * __must_check\ndevm_krealloc_array(struct device *dev, void *p, size_t new_n, size_t new_size, gfp_t flags)\n{\n\tsize_t bytes;\n\n\tif (unlikely(check_mul_overflow(new_n, new_size, &bytes)))\n\t\treturn NULL;\n\n\treturn devm_krealloc(dev, p, bytes, flags);\n}\n\nvoid devm_kfree(struct device *dev, const void *p);\nchar *devm_kstrdup(struct device *dev, const char *s, gfp_t gfp) __malloc;\nconst char *devm_kstrdup_const(struct device *dev, const char *s, gfp_t gfp);\nvoid *devm_kmemdup(struct device *dev, const void *src, size_t len, gfp_t gfp)\n\t__realloc_size(3);\n\nunsigned long devm_get_free_pages(struct device *dev,\n\t\t\t\t  gfp_t gfp_mask, unsigned int order);\nvoid devm_free_pages(struct device *dev, unsigned long addr);\n\n#ifdef CONFIG_HAS_IOMEM\nvoid __iomem *devm_ioremap_resource(struct device *dev,\n\t\t\t\t    const struct resource *res);\nvoid __iomem *devm_ioremap_resource_wc(struct device *dev,\n\t\t\t\t       const struct resource *res);\n\nvoid __iomem *devm_of_iomap(struct device *dev,\n\t\t\t    struct device_node *node, int index,\n\t\t\t    resource_size_t *size);\n#else\n\nstatic inline\nvoid __iomem *devm_ioremap_resource(struct device *dev,\n\t\t\t\t    const struct resource *res)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic inline\nvoid __iomem *devm_ioremap_resource_wc(struct device *dev,\n\t\t\t\t       const struct resource *res)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic inline\nvoid __iomem *devm_of_iomap(struct device *dev,\n\t\t\t    struct device_node *node, int index,\n\t\t\t    resource_size_t *size)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n\n#endif\n\n \nvoid devm_remove_action(struct device *dev, void (*action)(void *), void *data);\nvoid devm_release_action(struct device *dev, void (*action)(void *), void *data);\n\nint __devm_add_action(struct device *dev, void (*action)(void *), void *data, const char *name);\n#define devm_add_action(release, action, data) \\\n\t__devm_add_action(release, action, data, #action)\n\nstatic inline int __devm_add_action_or_reset(struct device *dev, void (*action)(void *),\n\t\t\t\t\t     void *data, const char *name)\n{\n\tint ret;\n\n\tret = __devm_add_action(dev, action, data, name);\n\tif (ret)\n\t\taction(data);\n\n\treturn ret;\n}\n#define devm_add_action_or_reset(release, action, data) \\\n\t__devm_add_action_or_reset(release, action, data, #action)\n\n \n#define devm_alloc_percpu(dev, type)      \\\n\t((typeof(type) __percpu *)__devm_alloc_percpu((dev), sizeof(type), \\\n\t\t\t\t\t\t      __alignof__(type)))\n\nvoid __percpu *__devm_alloc_percpu(struct device *dev, size_t size,\n\t\t\t\t   size_t align);\nvoid devm_free_percpu(struct device *dev, void __percpu *pdata);\n\nstruct device_dma_parameters {\n\t \n\tunsigned int max_segment_size;\n\tunsigned int min_align_mask;\n\tunsigned long segment_boundary_mask;\n};\n\n \nenum device_link_state {\n\tDL_STATE_NONE = -1,\n\tDL_STATE_DORMANT = 0,\n\tDL_STATE_AVAILABLE,\n\tDL_STATE_CONSUMER_PROBE,\n\tDL_STATE_ACTIVE,\n\tDL_STATE_SUPPLIER_UNBIND,\n};\n\n \n#define DL_FLAG_STATELESS\t\tBIT(0)\n#define DL_FLAG_AUTOREMOVE_CONSUMER\tBIT(1)\n#define DL_FLAG_PM_RUNTIME\t\tBIT(2)\n#define DL_FLAG_RPM_ACTIVE\t\tBIT(3)\n#define DL_FLAG_AUTOREMOVE_SUPPLIER\tBIT(4)\n#define DL_FLAG_AUTOPROBE_CONSUMER\tBIT(5)\n#define DL_FLAG_MANAGED\t\t\tBIT(6)\n#define DL_FLAG_SYNC_STATE_ONLY\t\tBIT(7)\n#define DL_FLAG_INFERRED\t\tBIT(8)\n#define DL_FLAG_CYCLE\t\t\tBIT(9)\n\n \nenum dl_dev_state {\n\tDL_DEV_NO_DRIVER = 0,\n\tDL_DEV_PROBING,\n\tDL_DEV_DRIVER_BOUND,\n\tDL_DEV_UNBINDING,\n};\n\n \nenum device_removable {\n\tDEVICE_REMOVABLE_NOT_SUPPORTED = 0,  \n\tDEVICE_REMOVABLE_UNKNOWN,\n\tDEVICE_FIXED,\n\tDEVICE_REMOVABLE,\n};\n\n \nstruct dev_links_info {\n\tstruct list_head suppliers;\n\tstruct list_head consumers;\n\tstruct list_head defer_sync;\n\tenum dl_dev_state status;\n};\n\n \nstruct dev_msi_info {\n#ifdef CONFIG_GENERIC_MSI_IRQ\n\tstruct irq_domain\t*domain;\n\tstruct msi_device_data\t*data;\n#endif\n};\n\n \nenum device_physical_location_panel {\n\tDEVICE_PANEL_TOP,\n\tDEVICE_PANEL_BOTTOM,\n\tDEVICE_PANEL_LEFT,\n\tDEVICE_PANEL_RIGHT,\n\tDEVICE_PANEL_FRONT,\n\tDEVICE_PANEL_BACK,\n\tDEVICE_PANEL_UNKNOWN,\n};\n\n \nenum device_physical_location_vertical_position {\n\tDEVICE_VERT_POS_UPPER,\n\tDEVICE_VERT_POS_CENTER,\n\tDEVICE_VERT_POS_LOWER,\n};\n\n \nenum device_physical_location_horizontal_position {\n\tDEVICE_HORI_POS_LEFT,\n\tDEVICE_HORI_POS_CENTER,\n\tDEVICE_HORI_POS_RIGHT,\n};\n\n \nstruct device_physical_location {\n\tenum device_physical_location_panel panel;\n\tenum device_physical_location_vertical_position vertical_position;\n\tenum device_physical_location_horizontal_position horizontal_position;\n\tbool dock;\n\tbool lid;\n};\n\n \nstruct device {\n\tstruct kobject kobj;\n\tstruct device\t\t*parent;\n\n\tstruct device_private\t*p;\n\n\tconst char\t\t*init_name;  \n\tconst struct device_type *type;\n\n\tconst struct bus_type\t*bus;\t \n\tstruct device_driver *driver;\t \n\tvoid\t\t*platform_data;\t \n\tvoid\t\t*driver_data;\t \n\tstruct mutex\t\tmutex;\t \n\n\tstruct dev_links_info\tlinks;\n\tstruct dev_pm_info\tpower;\n\tstruct dev_pm_domain\t*pm_domain;\n\n#ifdef CONFIG_ENERGY_MODEL\n\tstruct em_perf_domain\t*em_pd;\n#endif\n\n#ifdef CONFIG_PINCTRL\n\tstruct dev_pin_info\t*pins;\n#endif\n\tstruct dev_msi_info\tmsi;\n#ifdef CONFIG_DMA_OPS\n\tconst struct dma_map_ops *dma_ops;\n#endif\n\tu64\t\t*dma_mask;\t \n\tu64\t\tcoherent_dma_mask; \n\tu64\t\tbus_dma_limit;\t \n\tconst struct bus_dma_region *dma_range_map;\n\n\tstruct device_dma_parameters *dma_parms;\n\n\tstruct list_head\tdma_pools;\t \n\n#ifdef CONFIG_DMA_DECLARE_COHERENT\n\tstruct dma_coherent_mem\t*dma_mem;  \n#endif\n#ifdef CONFIG_DMA_CMA\n\tstruct cma *cma_area;\t\t \n#endif\n#ifdef CONFIG_SWIOTLB\n\tstruct io_tlb_mem *dma_io_tlb_mem;\n#endif\n#ifdef CONFIG_SWIOTLB_DYNAMIC\n\tstruct list_head dma_io_tlb_pools;\n\tspinlock_t dma_io_tlb_lock;\n\tbool dma_uses_io_tlb;\n#endif\n\t \n\tstruct dev_archdata\tarchdata;\n\n\tstruct device_node\t*of_node;  \n\tstruct fwnode_handle\t*fwnode;  \n\n#ifdef CONFIG_NUMA\n\tint\t\tnuma_node;\t \n#endif\n\tdev_t\t\t\tdevt;\t \n\tu32\t\t\tid;\t \n\n\tspinlock_t\t\tdevres_lock;\n\tstruct list_head\tdevres_head;\n\n\tconst struct class\t*class;\n\tconst struct attribute_group **groups;\t \n\n\tvoid\t(*release)(struct device *dev);\n\tstruct iommu_group\t*iommu_group;\n\tstruct dev_iommu\t*iommu;\n\n\tstruct device_physical_location *physical_location;\n\n\tenum device_removable\tremovable;\n\n\tbool\t\t\toffline_disabled:1;\n\tbool\t\t\toffline:1;\n\tbool\t\t\tof_node_reused:1;\n\tbool\t\t\tstate_synced:1;\n\tbool\t\t\tcan_match:1;\n#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \\\n    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \\\n    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)\n\tbool\t\t\tdma_coherent:1;\n#endif\n#ifdef CONFIG_DMA_OPS_BYPASS\n\tbool\t\t\tdma_ops_bypass : 1;\n#endif\n};\n\n \nstruct device_link {\n\tstruct device *supplier;\n\tstruct list_head s_node;\n\tstruct device *consumer;\n\tstruct list_head c_node;\n\tstruct device link_dev;\n\tenum device_link_state status;\n\tu32 flags;\n\trefcount_t rpm_active;\n\tstruct kref kref;\n\tstruct work_struct rm_work;\n\tbool supplier_preactivated;  \n};\n\n#define kobj_to_dev(__kobj)\tcontainer_of_const(__kobj, struct device, kobj)\n\n \nstatic inline bool device_iommu_mapped(struct device *dev)\n{\n\treturn (dev->iommu_group != NULL);\n}\n\n \n#include <linux/pm_wakeup.h>\n\n \nstatic inline const char *dev_name(const struct device *dev)\n{\n\t \n\tif (dev->init_name)\n\t\treturn dev->init_name;\n\n\treturn kobject_name(&dev->kobj);\n}\n\n \nstatic inline const char *dev_bus_name(const struct device *dev)\n{\n\treturn dev->bus ? dev->bus->name : (dev->class ? dev->class->name : \"\");\n}\n\n__printf(2, 3) int dev_set_name(struct device *dev, const char *name, ...);\n\n#ifdef CONFIG_NUMA\nstatic inline int dev_to_node(struct device *dev)\n{\n\treturn dev->numa_node;\n}\nstatic inline void set_dev_node(struct device *dev, int node)\n{\n\tdev->numa_node = node;\n}\n#else\nstatic inline int dev_to_node(struct device *dev)\n{\n\treturn NUMA_NO_NODE;\n}\nstatic inline void set_dev_node(struct device *dev, int node)\n{\n}\n#endif\n\nstatic inline struct irq_domain *dev_get_msi_domain(const struct device *dev)\n{\n#ifdef CONFIG_GENERIC_MSI_IRQ\n\treturn dev->msi.domain;\n#else\n\treturn NULL;\n#endif\n}\n\nstatic inline void dev_set_msi_domain(struct device *dev, struct irq_domain *d)\n{\n#ifdef CONFIG_GENERIC_MSI_IRQ\n\tdev->msi.domain = d;\n#endif\n}\n\nstatic inline void *dev_get_drvdata(const struct device *dev)\n{\n\treturn dev->driver_data;\n}\n\nstatic inline void dev_set_drvdata(struct device *dev, void *data)\n{\n\tdev->driver_data = data;\n}\n\nstatic inline struct pm_subsys_data *dev_to_psd(struct device *dev)\n{\n\treturn dev ? dev->power.subsys_data : NULL;\n}\n\nstatic inline unsigned int dev_get_uevent_suppress(const struct device *dev)\n{\n\treturn dev->kobj.uevent_suppress;\n}\n\nstatic inline void dev_set_uevent_suppress(struct device *dev, int val)\n{\n\tdev->kobj.uevent_suppress = val;\n}\n\nstatic inline int device_is_registered(struct device *dev)\n{\n\treturn dev->kobj.state_in_sysfs;\n}\n\nstatic inline void device_enable_async_suspend(struct device *dev)\n{\n\tif (!dev->power.is_prepared)\n\t\tdev->power.async_suspend = true;\n}\n\nstatic inline void device_disable_async_suspend(struct device *dev)\n{\n\tif (!dev->power.is_prepared)\n\t\tdev->power.async_suspend = false;\n}\n\nstatic inline bool device_async_suspend_enabled(struct device *dev)\n{\n\treturn !!dev->power.async_suspend;\n}\n\nstatic inline bool device_pm_not_required(struct device *dev)\n{\n\treturn dev->power.no_pm;\n}\n\nstatic inline void device_set_pm_not_required(struct device *dev)\n{\n\tdev->power.no_pm = true;\n}\n\nstatic inline void dev_pm_syscore_device(struct device *dev, bool val)\n{\n#ifdef CONFIG_PM_SLEEP\n\tdev->power.syscore = val;\n#endif\n}\n\nstatic inline void dev_pm_set_driver_flags(struct device *dev, u32 flags)\n{\n\tdev->power.driver_flags = flags;\n}\n\nstatic inline bool dev_pm_test_driver_flags(struct device *dev, u32 flags)\n{\n\treturn !!(dev->power.driver_flags & flags);\n}\n\nstatic inline void device_lock(struct device *dev)\n{\n\tmutex_lock(&dev->mutex);\n}\n\nstatic inline int device_lock_interruptible(struct device *dev)\n{\n\treturn mutex_lock_interruptible(&dev->mutex);\n}\n\nstatic inline int device_trylock(struct device *dev)\n{\n\treturn mutex_trylock(&dev->mutex);\n}\n\nstatic inline void device_unlock(struct device *dev)\n{\n\tmutex_unlock(&dev->mutex);\n}\n\nDEFINE_GUARD(device, struct device *, device_lock(_T), device_unlock(_T))\n\nstatic inline void device_lock_assert(struct device *dev)\n{\n\tlockdep_assert_held(&dev->mutex);\n}\n\nstatic inline struct device_node *dev_of_node(struct device *dev)\n{\n\tif (!IS_ENABLED(CONFIG_OF) || !dev)\n\t\treturn NULL;\n\treturn dev->of_node;\n}\n\nstatic inline bool dev_has_sync_state(struct device *dev)\n{\n\tif (!dev)\n\t\treturn false;\n\tif (dev->driver && dev->driver->sync_state)\n\t\treturn true;\n\tif (dev->bus && dev->bus->sync_state)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline void dev_set_removable(struct device *dev,\n\t\t\t\t     enum device_removable removable)\n{\n\tdev->removable = removable;\n}\n\nstatic inline bool dev_is_removable(struct device *dev)\n{\n\treturn dev->removable == DEVICE_REMOVABLE;\n}\n\nstatic inline bool dev_removable_is_valid(struct device *dev)\n{\n\treturn dev->removable != DEVICE_REMOVABLE_NOT_SUPPORTED;\n}\n\n \nint __must_check device_register(struct device *dev);\nvoid device_unregister(struct device *dev);\nvoid device_initialize(struct device *dev);\nint __must_check device_add(struct device *dev);\nvoid device_del(struct device *dev);\n\nDEFINE_FREE(device_del, struct device *, if (_T) device_del(_T))\n\nint device_for_each_child(struct device *dev, void *data,\n\t\t\t  int (*fn)(struct device *dev, void *data));\nint device_for_each_child_reverse(struct device *dev, void *data,\n\t\t\t\t  int (*fn)(struct device *dev, void *data));\nstruct device *device_find_child(struct device *dev, void *data,\n\t\t\t\t int (*match)(struct device *dev, void *data));\nstruct device *device_find_child_by_name(struct device *parent,\n\t\t\t\t\t const char *name);\nstruct device *device_find_any_child(struct device *parent);\n\nint device_rename(struct device *dev, const char *new_name);\nint device_move(struct device *dev, struct device *new_parent,\n\t\tenum dpm_order dpm_order);\nint device_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid);\nint device_is_dependent(struct device *dev, void *target);\n\nstatic inline bool device_supports_offline(struct device *dev)\n{\n\treturn dev->bus && dev->bus->offline && dev->bus->online;\n}\n\n#define __device_lock_set_class(dev, name, key)                        \\\ndo {                                                                   \\\n\tstruct device *__d2 __maybe_unused = dev;                      \\\n\tlock_set_class(&__d2->mutex.dep_map, name, key, 0, _THIS_IP_); \\\n} while (0)\n\n \n#ifdef CONFIG_LOCKDEP\n#define device_lock_set_class(dev, key)                                    \\\ndo {                                                                       \\\n\tstruct device *__d = dev;                                          \\\n\tdev_WARN_ONCE(__d, !lockdep_match_class(&__d->mutex,               \\\n\t\t\t\t\t\t&__lockdep_no_validate__), \\\n\t\t \"overriding existing custom lock class\\n\");               \\\n\t__device_lock_set_class(__d, #key, key);                           \\\n} while (0)\n#else\n#define device_lock_set_class(dev, key) __device_lock_set_class(dev, #key, key)\n#endif\n\n \n#define device_lock_reset_class(dev) \\\ndo { \\\n\tstruct device *__d __maybe_unused = dev;                       \\\n\tlock_set_novalidate_class(&__d->mutex.dep_map, \"&dev->mutex\",  \\\n\t\t\t\t  _THIS_IP_);                          \\\n} while (0)\n\nvoid lock_device_hotplug(void);\nvoid unlock_device_hotplug(void);\nint lock_device_hotplug_sysfs(void);\nint device_offline(struct device *dev);\nint device_online(struct device *dev);\nvoid set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode);\nvoid set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode);\nvoid device_set_of_node_from_dev(struct device *dev, const struct device *dev2);\nvoid device_set_node(struct device *dev, struct fwnode_handle *fwnode);\n\nstatic inline int dev_num_vf(struct device *dev)\n{\n\tif (dev->bus && dev->bus->num_vf)\n\t\treturn dev->bus->num_vf(dev);\n\treturn 0;\n}\n\n \nstruct device *__root_device_register(const char *name, struct module *owner);\n\n \n#define root_device_register(name) \\\n\t__root_device_register(name, THIS_MODULE)\n\nvoid root_device_unregister(struct device *root);\n\nstatic inline void *dev_get_platdata(const struct device *dev)\n{\n\treturn dev->platform_data;\n}\n\n \nint __must_check device_driver_attach(struct device_driver *drv,\n\t\t\t\t      struct device *dev);\nint __must_check device_bind_driver(struct device *dev);\nvoid device_release_driver(struct device *dev);\nint  __must_check device_attach(struct device *dev);\nint __must_check driver_attach(struct device_driver *drv);\nvoid device_initial_probe(struct device *dev);\nint __must_check device_reprobe(struct device *dev);\n\nbool device_is_bound(struct device *dev);\n\n \n__printf(5, 6) struct device *\ndevice_create(const struct class *cls, struct device *parent, dev_t devt,\n\t      void *drvdata, const char *fmt, ...);\n__printf(6, 7) struct device *\ndevice_create_with_groups(const struct class *cls, struct device *parent, dev_t devt,\n\t\t\t  void *drvdata, const struct attribute_group **groups,\n\t\t\t  const char *fmt, ...);\nvoid device_destroy(const struct class *cls, dev_t devt);\n\nint __must_check device_add_groups(struct device *dev,\n\t\t\t\t   const struct attribute_group **groups);\nvoid device_remove_groups(struct device *dev,\n\t\t\t  const struct attribute_group **groups);\n\nstatic inline int __must_check device_add_group(struct device *dev,\n\t\t\t\t\tconst struct attribute_group *grp)\n{\n\tconst struct attribute_group *groups[] = { grp, NULL };\n\n\treturn device_add_groups(dev, groups);\n}\n\nstatic inline void device_remove_group(struct device *dev,\n\t\t\t\t       const struct attribute_group *grp)\n{\n\tconst struct attribute_group *groups[] = { grp, NULL };\n\n\treturn device_remove_groups(dev, groups);\n}\n\nint __must_check devm_device_add_groups(struct device *dev,\n\t\t\t\t\tconst struct attribute_group **groups);\nint __must_check devm_device_add_group(struct device *dev,\n\t\t\t\t       const struct attribute_group *grp);\n\n \n \nextern int (*platform_notify)(struct device *dev);\n\nextern int (*platform_notify_remove)(struct device *dev);\n\n\n \nstruct device *get_device(struct device *dev);\nvoid put_device(struct device *dev);\n\nDEFINE_FREE(put_device, struct device *, if (_T) put_device(_T))\n\nbool kill_device(struct device *dev);\n\n#ifdef CONFIG_DEVTMPFS\nint devtmpfs_mount(void);\n#else\nstatic inline int devtmpfs_mount(void) { return 0; }\n#endif\n\n \nvoid device_shutdown(void);\n\n \nconst char *dev_driver_string(const struct device *dev);\n\n \nstruct device_link *device_link_add(struct device *consumer,\n\t\t\t\t    struct device *supplier, u32 flags);\nvoid device_link_del(struct device_link *link);\nvoid device_link_remove(void *consumer, struct device *supplier);\nvoid device_links_supplier_sync_state_pause(void);\nvoid device_links_supplier_sync_state_resume(void);\n\n \n#define MODULE_ALIAS_CHARDEV(major,minor) \\\n\tMODULE_ALIAS(\"char-major-\" __stringify(major) \"-\" __stringify(minor))\n#define MODULE_ALIAS_CHARDEV_MAJOR(major) \\\n\tMODULE_ALIAS(\"char-major-\" __stringify(major) \"-*\")\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}