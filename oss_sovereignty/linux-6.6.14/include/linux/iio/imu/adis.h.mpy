{
  "module_name": "adis.h",
  "hash_id": "bdf0959ae1c0e6231ddbe50ea74de8a53be0eb2af52e49ba4e9c94984c8f7114",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/iio/imu/adis.h",
  "human_readable_source": " \n \n\n#ifndef __IIO_ADIS_H__\n#define __IIO_ADIS_H__\n\n#include <linux/spi/spi.h>\n#include <linux/interrupt.h>\n#include <linux/iio/types.h>\n\n#define ADIS_WRITE_REG(reg) ((0x80 | (reg)))\n#define ADIS_READ_REG(reg) ((reg) & 0x7f)\n\n#define ADIS_PAGE_SIZE 0x80\n#define ADIS_REG_PAGE_ID 0x00\n\nstruct adis;\n\n \nstruct adis_timeout {\n\tu16 reset_ms;\n\tu16 sw_reset_ms;\n\tu16 self_test_ms;\n};\n\n \nstruct adis_data {\n\tunsigned int read_delay;\n\tunsigned int write_delay;\n\tunsigned int cs_change_delay;\n\n\tunsigned int glob_cmd_reg;\n\tunsigned int msc_ctrl_reg;\n\tunsigned int diag_stat_reg;\n\tunsigned int prod_id_reg;\n\n\tunsigned int prod_id;\n\n\tunsigned int self_test_mask;\n\tunsigned int self_test_reg;\n\tbool self_test_no_autoclear;\n\tconst struct adis_timeout *timeouts;\n\n\tconst char * const *status_error_msgs;\n\tunsigned int status_error_mask;\n\n\tint (*enable_irq)(struct adis *adis, bool enable);\n\tbool unmasked_drdy;\n\n\tbool has_paging;\n\n\tunsigned int burst_reg_cmd;\n\tunsigned int burst_len;\n\tunsigned int burst_max_len;\n\tunsigned int burst_max_speed_hz;\n};\n\n \nstruct adis {\n\tstruct spi_device\t*spi;\n\tstruct iio_trigger\t*trig;\n\n\tconst struct adis_data\t*data;\n\tunsigned int\t\tburst_extra_len;\n\t \n\tstruct mutex\t\tstate_lock;\n\tstruct spi_message\tmsg;\n\tstruct spi_transfer\t*xfer;\n\tunsigned int\t\tcurrent_page;\n\tunsigned long\t\tirq_flag;\n\tvoid\t\t\t*buffer;\n\n\tu8\t\t\ttx[10] ____cacheline_aligned;\n\tu8\t\t\trx[4];\n};\n\nint adis_init(struct adis *adis, struct iio_dev *indio_dev,\n\t      struct spi_device *spi, const struct adis_data *data);\nint __adis_reset(struct adis *adis);\n\n \nstatic inline int adis_reset(struct adis *adis)\n{\n\tint ret;\n\n\tmutex_lock(&adis->state_lock);\n\tret = __adis_reset(adis);\n\tmutex_unlock(&adis->state_lock);\n\n\treturn ret;\n}\n\nint __adis_write_reg(struct adis *adis, unsigned int reg,\n\t\t     unsigned int val, unsigned int size);\nint __adis_read_reg(struct adis *adis, unsigned int reg,\n\t\t    unsigned int *val, unsigned int size);\n\n \nstatic inline int __adis_write_reg_8(struct adis *adis, unsigned int reg,\n\t\t\t\t     u8 val)\n{\n\treturn __adis_write_reg(adis, reg, val, 1);\n}\n\n \nstatic inline int __adis_write_reg_16(struct adis *adis, unsigned int reg,\n\t\t\t\t      u16 val)\n{\n\treturn __adis_write_reg(adis, reg, val, 2);\n}\n\n \nstatic inline int __adis_write_reg_32(struct adis *adis, unsigned int reg,\n\t\t\t\t      u32 val)\n{\n\treturn __adis_write_reg(adis, reg, val, 4);\n}\n\n \nstatic inline int __adis_read_reg_16(struct adis *adis, unsigned int reg,\n\t\t\t\t     u16 *val)\n{\n\tunsigned int tmp;\n\tint ret;\n\n\tret = __adis_read_reg(adis, reg, &tmp, 2);\n\tif (ret == 0)\n\t\t*val = tmp;\n\n\treturn ret;\n}\n\n \nstatic inline int __adis_read_reg_32(struct adis *adis, unsigned int reg,\n\t\t\t\t     u32 *val)\n{\n\tunsigned int tmp;\n\tint ret;\n\n\tret = __adis_read_reg(adis, reg, &tmp, 4);\n\tif (ret == 0)\n\t\t*val = tmp;\n\n\treturn ret;\n}\n\n \nstatic inline int adis_write_reg(struct adis *adis, unsigned int reg,\n\t\t\t\t unsigned int val, unsigned int size)\n{\n\tint ret;\n\n\tmutex_lock(&adis->state_lock);\n\tret = __adis_write_reg(adis, reg, val, size);\n\tmutex_unlock(&adis->state_lock);\n\n\treturn ret;\n}\n\n \nstatic int adis_read_reg(struct adis *adis, unsigned int reg,\n\t\t\t unsigned int *val, unsigned int size)\n{\n\tint ret;\n\n\tmutex_lock(&adis->state_lock);\n\tret = __adis_read_reg(adis, reg, val, size);\n\tmutex_unlock(&adis->state_lock);\n\n\treturn ret;\n}\n\n \nstatic inline int adis_write_reg_8(struct adis *adis, unsigned int reg,\n\t\t\t\t   u8 val)\n{\n\treturn adis_write_reg(adis, reg, val, 1);\n}\n\n \nstatic inline int adis_write_reg_16(struct adis *adis, unsigned int reg,\n\t\t\t\t    u16 val)\n{\n\treturn adis_write_reg(adis, reg, val, 2);\n}\n\n \nstatic inline int adis_write_reg_32(struct adis *adis, unsigned int reg,\n\t\t\t\t    u32 val)\n{\n\treturn adis_write_reg(adis, reg, val, 4);\n}\n\n \nstatic inline int adis_read_reg_16(struct adis *adis, unsigned int reg,\n\t\t\t\t   u16 *val)\n{\n\tunsigned int tmp;\n\tint ret;\n\n\tret = adis_read_reg(adis, reg, &tmp, 2);\n\tif (ret == 0)\n\t\t*val = tmp;\n\n\treturn ret;\n}\n\n \nstatic inline int adis_read_reg_32(struct adis *adis, unsigned int reg,\n\t\t\t\t   u32 *val)\n{\n\tunsigned int tmp;\n\tint ret;\n\n\tret = adis_read_reg(adis, reg, &tmp, 4);\n\tif (ret == 0)\n\t\t*val = tmp;\n\n\treturn ret;\n}\n\nint __adis_update_bits_base(struct adis *adis, unsigned int reg, const u32 mask,\n\t\t\t    const u32 val, u8 size);\n \nstatic inline int adis_update_bits_base(struct adis *adis, unsigned int reg,\n\t\t\t\t\tconst u32 mask, const u32 val, u8 size)\n{\n\tint ret;\n\n\tmutex_lock(&adis->state_lock);\n\tret = __adis_update_bits_base(adis, reg, mask, val, size);\n\tmutex_unlock(&adis->state_lock);\n\treturn ret;\n}\n\n \n#define adis_update_bits(adis, reg, mask, val) ({\t\t\t\\\n\tBUILD_BUG_ON(sizeof(val) != 2 && sizeof(val) != 4);\t\t\\\n\tadis_update_bits_base(adis, reg, mask, val, sizeof(val));\t\\\n})\n\n \n#define __adis_update_bits(adis, reg, mask, val) ({\t\t\t\\\n\tBUILD_BUG_ON(sizeof(val) != 2 && sizeof(val) != 4);\t\t\\\n\t__adis_update_bits_base(adis, reg, mask, val, sizeof(val));\t\\\n})\n\nint __adis_check_status(struct adis *adis);\nint __adis_initial_startup(struct adis *adis);\nint __adis_enable_irq(struct adis *adis, bool enable);\n\nstatic inline int adis_enable_irq(struct adis *adis, bool enable)\n{\n\tint ret;\n\n\tmutex_lock(&adis->state_lock);\n\tret = __adis_enable_irq(adis, enable);\n\tmutex_unlock(&adis->state_lock);\n\n\treturn ret;\n}\n\nstatic inline int adis_check_status(struct adis *adis)\n{\n\tint ret;\n\n\tmutex_lock(&adis->state_lock);\n\tret = __adis_check_status(adis);\n\tmutex_unlock(&adis->state_lock);\n\n\treturn ret;\n}\n\nstatic inline void adis_dev_lock(struct adis *adis)\n{\n\tmutex_lock(&adis->state_lock);\n}\n\nstatic inline void adis_dev_unlock(struct adis *adis)\n{\n\tmutex_unlock(&adis->state_lock);\n}\n\nint adis_single_conversion(struct iio_dev *indio_dev,\n\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t   unsigned int error_mask, int *val);\n\n#define ADIS_VOLTAGE_CHAN(addr, si, chan, name, info_all, bits) { \\\n\t.type = IIO_VOLTAGE, \\\n\t.indexed = 1, \\\n\t.channel = (chan), \\\n\t.extend_name = name, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_all = info_all, \\\n\t.address = (addr), \\\n\t.scan_index = (si), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\n#define ADIS_SUPPLY_CHAN(addr, si, info_all, bits) \\\n\tADIS_VOLTAGE_CHAN(addr, si, 0, \"supply\", info_all, bits)\n\n#define ADIS_AUX_ADC_CHAN(addr, si, info_all, bits) \\\n\tADIS_VOLTAGE_CHAN(addr, si, 1, NULL, info_all, bits)\n\n#define ADIS_TEMP_CHAN(addr, si, info_all, bits) { \\\n\t.type = IIO_TEMP, \\\n\t.indexed = 1, \\\n\t.channel = 0, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_OFFSET), \\\n\t.info_mask_shared_by_all = info_all, \\\n\t.address = (addr), \\\n\t.scan_index = (si), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\n#define ADIS_MOD_CHAN(_type, mod, addr, si, info_sep, info_all, bits) { \\\n\t.type = (_type), \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_ ## mod, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t (info_sep), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_all = info_all, \\\n\t.address = (addr), \\\n\t.scan_index = (si), \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\n#define ADIS_ACCEL_CHAN(mod, addr, si, info_sep, info_all, bits) \\\n\tADIS_MOD_CHAN(IIO_ACCEL, mod, addr, si, info_sep, info_all, bits)\n\n#define ADIS_GYRO_CHAN(mod, addr, si, info_sep, info_all, bits)\t\t\\\n\tADIS_MOD_CHAN(IIO_ANGL_VEL, mod, addr, si, info_sep, info_all, bits)\n\n#define ADIS_INCLI_CHAN(mod, addr, si, info_sep, info_all, bits) \\\n\tADIS_MOD_CHAN(IIO_INCLI, mod, addr, si, info_sep, info_all, bits)\n\n#define ADIS_ROT_CHAN(mod, addr, si, info_sep, info_all, bits) \\\n\tADIS_MOD_CHAN(IIO_ROT, mod, addr, si, info_sep, info_all, bits)\n\n#ifdef CONFIG_IIO_ADIS_LIB_BUFFER\n\nint\ndevm_adis_setup_buffer_and_trigger(struct adis *adis, struct iio_dev *indio_dev,\n\t\t\t\t   irq_handler_t trigger_handler);\n\nint devm_adis_probe_trigger(struct adis *adis, struct iio_dev *indio_dev);\n\nint adis_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t  const unsigned long *scan_mask);\n\n#else  \n\nstatic inline int\ndevm_adis_setup_buffer_and_trigger(struct adis *adis, struct iio_dev *indio_dev,\n\t\t\t\t   irq_handler_t trigger_handler)\n{\n\treturn 0;\n}\n\nstatic inline int devm_adis_probe_trigger(struct adis *adis,\n\t\t\t\t\t  struct iio_dev *indio_dev)\n{\n\treturn 0;\n}\n\n#define adis_update_scan_mode NULL\n\n#endif  \n\n#ifdef CONFIG_DEBUG_FS\n\nint adis_debugfs_reg_access(struct iio_dev *indio_dev,\n\t\t\t    unsigned int reg, unsigned int writeval,\n\t\t\t    unsigned int *readval);\n\n#else\n\n#define adis_debugfs_reg_access NULL\n\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}