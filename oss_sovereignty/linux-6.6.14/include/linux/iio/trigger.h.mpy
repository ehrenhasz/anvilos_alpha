{
  "module_name": "trigger.h",
  "hash_id": "71f13395967e52d2fb63fa250114693240672fee4cb0d98e4f1d58957a81468e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/iio/trigger.h",
  "human_readable_source": " \n \n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n\n#ifndef _IIO_TRIGGER_H_\n#define _IIO_TRIGGER_H_\n\n#ifdef CONFIG_IIO_TRIGGER\nstruct iio_subirq {\n\tbool enabled;\n};\n\nstruct iio_dev;\nstruct iio_trigger;\n\n \nstruct iio_trigger_ops {\n\tint (*set_trigger_state)(struct iio_trigger *trig, bool state);\n\tvoid (*reenable)(struct iio_trigger *trig);\n\tint (*validate_device)(struct iio_trigger *trig,\n\t\t\t       struct iio_dev *indio_dev);\n};\n\n\n \nstruct iio_trigger {\n\tconst struct iio_trigger_ops\t*ops;\n\tstruct module\t\t\t*owner;\n\tint\t\t\t\tid;\n\tconst char\t\t\t*name;\n\tstruct device\t\t\tdev;\n\n\tstruct list_head\t\tlist;\n\tstruct list_head\t\talloc_list;\n\tatomic_t\t\t\tuse_count;\n\n\tstruct irq_chip\t\t\tsubirq_chip;\n\tint\t\t\t\tsubirq_base;\n\n\tstruct iio_subirq subirqs[CONFIG_IIO_CONSUMERS_PER_TRIGGER];\n\tunsigned long pool[BITS_TO_LONGS(CONFIG_IIO_CONSUMERS_PER_TRIGGER)];\n\tstruct mutex\t\t\tpool_lock;\n\tbool\t\t\t\tattached_own_device;\n\tstruct work_struct\t\treenable_work;\n};\n\n\nstatic inline struct iio_trigger *to_iio_trigger(struct device *d)\n{\n\treturn container_of(d, struct iio_trigger, dev);\n}\n\nstatic inline void iio_trigger_put(struct iio_trigger *trig)\n{\n\tmodule_put(trig->owner);\n\tput_device(&trig->dev);\n}\n\nstatic inline struct iio_trigger *iio_trigger_get(struct iio_trigger *trig)\n{\n\tget_device(&trig->dev);\n\n\tWARN_ONCE(list_empty(&trig->list),\n\t\t  \"Getting non-registered iio trigger %s is prohibited\\n\",\n\t\t  trig->name);\n\n\t__module_get(trig->owner);\n\n\treturn trig;\n}\n\n \nstatic inline void iio_trigger_set_drvdata(struct iio_trigger *trig, void *data)\n{\n\tdev_set_drvdata(&trig->dev, data);\n}\n\n \nstatic inline void *iio_trigger_get_drvdata(struct iio_trigger *trig)\n{\n\treturn dev_get_drvdata(&trig->dev);\n}\n\n \nint iio_trigger_register(struct iio_trigger *trig_info);\n\nint devm_iio_trigger_register(struct device *dev,\n\t\t\t      struct iio_trigger *trig_info);\n\n \nvoid iio_trigger_unregister(struct iio_trigger *trig_info);\n\n \nint iio_trigger_set_immutable(struct iio_dev *indio_dev, struct iio_trigger *trig);\n\nvoid iio_trigger_poll(struct iio_trigger *trig);\nvoid iio_trigger_poll_nested(struct iio_trigger *trig);\n\nirqreturn_t iio_trigger_generic_data_rdy_poll(int irq, void *private);\n\n#define iio_trigger_alloc(parent, fmt, ...) \\\n\t__iio_trigger_alloc((parent), THIS_MODULE, (fmt), ##__VA_ARGS__)\n\n__printf(3, 4)\nstruct iio_trigger *__iio_trigger_alloc(struct device *parent,\n\t\t\t\t\tstruct module *this_mod,\n\t\t\t\t\tconst char *fmt, ...);\nvoid iio_trigger_free(struct iio_trigger *trig);\n\n \nbool iio_trigger_using_own(struct iio_dev *indio_dev);\n\nint iio_validate_own_trigger(struct iio_dev *idev, struct iio_trigger *trig);\nint iio_trigger_validate_own_device(struct iio_trigger *trig,\n\t\t\t\t     struct iio_dev *indio_dev);\n\n#else\nstruct iio_trigger;\nstruct iio_trigger_ops;\n#endif\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}