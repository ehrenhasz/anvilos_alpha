{
  "module_name": "x_tables.h",
  "hash_id": "afd9103a2584944c078bb658caa547d11d22f9e6e2e1ee7711063d2b30b3a170",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/netfilter/x_tables.h",
  "human_readable_source": " \n#ifndef _X_TABLES_H\n#define _X_TABLES_H\n\n\n#include <linux/netdevice.h>\n#include <linux/static_key.h>\n#include <linux/netfilter.h>\n#include <uapi/linux/netfilter/x_tables.h>\n\n \n#define NF_INVF(ptr, flag, boolean)\t\t\t\t\t\\\n\t((boolean) ^ !!((ptr)->invflags & (flag)))\n\n \nstruct xt_action_param {\n\tunion {\n\t\tconst struct xt_match *match;\n\t\tconst struct xt_target *target;\n\t};\n\tunion {\n\t\tconst void *matchinfo, *targinfo;\n\t};\n\tconst struct nf_hook_state *state;\n\tunsigned int thoff;\n\tu16 fragoff;\n\tbool hotdrop;\n};\n\nstatic inline struct net *xt_net(const struct xt_action_param *par)\n{\n\treturn par->state->net;\n}\n\nstatic inline struct net_device *xt_in(const struct xt_action_param *par)\n{\n\treturn par->state->in;\n}\n\nstatic inline const char *xt_inname(const struct xt_action_param *par)\n{\n\treturn par->state->in->name;\n}\n\nstatic inline struct net_device *xt_out(const struct xt_action_param *par)\n{\n\treturn par->state->out;\n}\n\nstatic inline const char *xt_outname(const struct xt_action_param *par)\n{\n\treturn par->state->out->name;\n}\n\nstatic inline unsigned int xt_hooknum(const struct xt_action_param *par)\n{\n\treturn par->state->hook;\n}\n\nstatic inline u_int8_t xt_family(const struct xt_action_param *par)\n{\n\treturn par->state->pf;\n}\n\n \nstruct xt_mtchk_param {\n\tstruct net *net;\n\tconst char *table;\n\tconst void *entryinfo;\n\tconst struct xt_match *match;\n\tvoid *matchinfo;\n\tunsigned int hook_mask;\n\tu_int8_t family;\n\tbool nft_compat;\n};\n\n \nstruct xt_mtdtor_param {\n\tstruct net *net;\n\tconst struct xt_match *match;\n\tvoid *matchinfo;\n\tu_int8_t family;\n};\n\n \nstruct xt_tgchk_param {\n\tstruct net *net;\n\tconst char *table;\n\tconst void *entryinfo;\n\tconst struct xt_target *target;\n\tvoid *targinfo;\n\tunsigned int hook_mask;\n\tu_int8_t family;\n\tbool nft_compat;\n};\n\n \nstruct xt_tgdtor_param {\n\tstruct net *net;\n\tconst struct xt_target *target;\n\tvoid *targinfo;\n\tu_int8_t family;\n};\n\nstruct xt_match {\n\tstruct list_head list;\n\n\tconst char name[XT_EXTENSION_MAXNAMELEN];\n\tu_int8_t revision;\n\n\t \n\t \n\tbool (*match)(const struct sk_buff *skb,\n\t\t      struct xt_action_param *);\n\n\t \n\tint (*checkentry)(const struct xt_mtchk_param *);\n\n\t \n\tvoid (*destroy)(const struct xt_mtdtor_param *);\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\t \n\tvoid (*compat_from_user)(void *dst, const void *src);\n\tint (*compat_to_user)(void __user *dst, const void *src);\n#endif\n\t \n\tstruct module *me;\n\n\tconst char *table;\n\tunsigned int matchsize;\n\tunsigned int usersize;\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\tunsigned int compatsize;\n#endif\n\tunsigned int hooks;\n\tunsigned short proto;\n\n\tunsigned short family;\n};\n\n \nstruct xt_target {\n\tstruct list_head list;\n\n\tconst char name[XT_EXTENSION_MAXNAMELEN];\n\tu_int8_t revision;\n\n\t \n\tunsigned int (*target)(struct sk_buff *skb,\n\t\t\t       const struct xt_action_param *);\n\n\t \n\t \n\tint (*checkentry)(const struct xt_tgchk_param *);\n\n\t \n\tvoid (*destroy)(const struct xt_tgdtor_param *);\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\t \n\tvoid (*compat_from_user)(void *dst, const void *src);\n\tint (*compat_to_user)(void __user *dst, const void *src);\n#endif\n\t \n\tstruct module *me;\n\n\tconst char *table;\n\tunsigned int targetsize;\n\tunsigned int usersize;\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\tunsigned int compatsize;\n#endif\n\tunsigned int hooks;\n\tunsigned short proto;\n\n\tunsigned short family;\n};\n\n \nstruct xt_table {\n\tstruct list_head list;\n\n\t \n\tunsigned int valid_hooks;\n\n\t \n\tstruct xt_table_info *private;\n\n\t \n\tstruct nf_hook_ops *ops;\n\n\t \n\tstruct module *me;\n\n\tu_int8_t af;\t\t \n\tint priority;\t\t \n\n\t \n\tconst char name[XT_TABLE_MAXNAMELEN];\n};\n\n#include <linux/netfilter_ipv4.h>\n\n \nstruct xt_table_info {\n\t \n\tunsigned int size;\n\t \n\tunsigned int number;\n\t \n\tunsigned int initial_entries;\n\n\t \n\tunsigned int hook_entry[NF_INET_NUMHOOKS];\n\tunsigned int underflow[NF_INET_NUMHOOKS];\n\n\t \n\tunsigned int stacksize;\n\tvoid ***jumpstack;\n\n\tunsigned char entries[] __aligned(8);\n};\n\nint xt_register_target(struct xt_target *target);\nvoid xt_unregister_target(struct xt_target *target);\nint xt_register_targets(struct xt_target *target, unsigned int n);\nvoid xt_unregister_targets(struct xt_target *target, unsigned int n);\n\nint xt_register_match(struct xt_match *target);\nvoid xt_unregister_match(struct xt_match *target);\nint xt_register_matches(struct xt_match *match, unsigned int n);\nvoid xt_unregister_matches(struct xt_match *match, unsigned int n);\n\nint xt_check_entry_offsets(const void *base, const char *elems,\n\t\t\t   unsigned int target_offset,\n\t\t\t   unsigned int next_offset);\n\nint xt_check_table_hooks(const struct xt_table_info *info, unsigned int valid_hooks);\n\nunsigned int *xt_alloc_entry_offsets(unsigned int size);\nbool xt_find_jump_offset(const unsigned int *offsets,\n\t\t\t unsigned int target, unsigned int size);\n\nint xt_check_proc_name(const char *name, unsigned int size);\n\nint xt_check_match(struct xt_mtchk_param *, unsigned int size, u16 proto,\n\t\t   bool inv_proto);\nint xt_check_target(struct xt_tgchk_param *, unsigned int size, u16 proto,\n\t\t    bool inv_proto);\n\nint xt_match_to_user(const struct xt_entry_match *m,\n\t\t     struct xt_entry_match __user *u);\nint xt_target_to_user(const struct xt_entry_target *t,\n\t\t      struct xt_entry_target __user *u);\nint xt_data_to_user(void __user *dst, const void *src,\n\t\t    int usersize, int size, int aligned_size);\n\nvoid *xt_copy_counters(sockptr_t arg, unsigned int len,\n\t\t       struct xt_counters_info *info);\nstruct xt_counters *xt_counters_alloc(unsigned int counters);\n\nstruct xt_table *xt_register_table(struct net *net,\n\t\t\t\t   const struct xt_table *table,\n\t\t\t\t   struct xt_table_info *bootstrap,\n\t\t\t\t   struct xt_table_info *newinfo);\nvoid *xt_unregister_table(struct xt_table *table);\n\nstruct xt_table_info *xt_replace_table(struct xt_table *table,\n\t\t\t\t       unsigned int num_counters,\n\t\t\t\t       struct xt_table_info *newinfo,\n\t\t\t\t       int *error);\n\nstruct xt_match *xt_find_match(u8 af, const char *name, u8 revision);\nstruct xt_match *xt_request_find_match(u8 af, const char *name, u8 revision);\nstruct xt_target *xt_request_find_target(u8 af, const char *name, u8 revision);\nint xt_find_revision(u8 af, const char *name, u8 revision, int target,\n\t\t     int *err);\n\nstruct xt_table *xt_find_table(struct net *net, u8 af, const char *name);\nstruct xt_table *xt_find_table_lock(struct net *net, u_int8_t af,\n\t\t\t\t    const char *name);\nstruct xt_table *xt_request_find_table_lock(struct net *net, u_int8_t af,\n\t\t\t\t\t    const char *name);\nvoid xt_table_unlock(struct xt_table *t);\n\nint xt_proto_init(struct net *net, u_int8_t af);\nvoid xt_proto_fini(struct net *net, u_int8_t af);\n\nstruct xt_table_info *xt_alloc_table_info(unsigned int size);\nvoid xt_free_table_info(struct xt_table_info *info);\n\n \nDECLARE_PER_CPU(seqcount_t, xt_recseq);\n\n \nextern struct static_key xt_tee_enabled;\n\n \nstatic inline unsigned int xt_write_recseq_begin(void)\n{\n\tunsigned int addend;\n\n\t \n\taddend = (__this_cpu_read(xt_recseq.sequence) + 1) & 1;\n\n\t \n\t__this_cpu_add(xt_recseq.sequence, addend);\n\tsmp_mb();\n\n\treturn addend;\n}\n\n \nstatic inline void xt_write_recseq_end(unsigned int addend)\n{\n\t \n\tsmp_wmb();\n\t__this_cpu_add(xt_recseq.sequence, addend);\n}\n\n \nstatic inline unsigned long ifname_compare_aligned(const char *_a,\n\t\t\t\t\t\t   const char *_b,\n\t\t\t\t\t\t   const char *_mask)\n{\n\tconst unsigned long *a = (const unsigned long *)_a;\n\tconst unsigned long *b = (const unsigned long *)_b;\n\tconst unsigned long *mask = (const unsigned long *)_mask;\n\tunsigned long ret;\n\n\tret = (a[0] ^ b[0]) & mask[0];\n\tif (IFNAMSIZ > sizeof(unsigned long))\n\t\tret |= (a[1] ^ b[1]) & mask[1];\n\tif (IFNAMSIZ > 2 * sizeof(unsigned long))\n\t\tret |= (a[2] ^ b[2]) & mask[2];\n\tif (IFNAMSIZ > 3 * sizeof(unsigned long))\n\t\tret |= (a[3] ^ b[3]) & mask[3];\n\tBUILD_BUG_ON(IFNAMSIZ > 4 * sizeof(unsigned long));\n\treturn ret;\n}\n\nstruct xt_percpu_counter_alloc_state {\n\tunsigned int off;\n\tconst char __percpu *mem;\n};\n\nbool xt_percpu_counter_alloc(struct xt_percpu_counter_alloc_state *state,\n\t\t\t     struct xt_counters *counter);\nvoid xt_percpu_counter_free(struct xt_counters *cnt);\n\nstatic inline struct xt_counters *\nxt_get_this_cpu_counter(struct xt_counters *cnt)\n{\n\tif (nr_cpu_ids > 1)\n\t\treturn this_cpu_ptr((void __percpu *) (unsigned long) cnt->pcnt);\n\n\treturn cnt;\n}\n\nstatic inline struct xt_counters *\nxt_get_per_cpu_counter(struct xt_counters *cnt, unsigned int cpu)\n{\n\tif (nr_cpu_ids > 1)\n\t\treturn per_cpu_ptr((void __percpu *) (unsigned long) cnt->pcnt, cpu);\n\n\treturn cnt;\n}\n\nstruct nf_hook_ops *xt_hook_ops_alloc(const struct xt_table *, nf_hookfn *);\n\nint xt_register_template(const struct xt_table *t, int(*table_init)(struct net *net));\nvoid xt_unregister_template(const struct xt_table *t);\n\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n#include <net/compat.h>\n\nstruct compat_xt_entry_match {\n\tunion {\n\t\tstruct {\n\t\t\tu_int16_t match_size;\n\t\t\tchar name[XT_FUNCTION_MAXNAMELEN - 1];\n\t\t\tu_int8_t revision;\n\t\t} user;\n\t\tstruct {\n\t\t\tu_int16_t match_size;\n\t\t\tcompat_uptr_t match;\n\t\t} kernel;\n\t\tu_int16_t match_size;\n\t} u;\n\tunsigned char data[];\n};\n\nstruct compat_xt_entry_target {\n\tunion {\n\t\tstruct {\n\t\t\tu_int16_t target_size;\n\t\t\tchar name[XT_FUNCTION_MAXNAMELEN - 1];\n\t\t\tu_int8_t revision;\n\t\t} user;\n\t\tstruct {\n\t\t\tu_int16_t target_size;\n\t\t\tcompat_uptr_t target;\n\t\t} kernel;\n\t\tu_int16_t target_size;\n\t} u;\n\tunsigned char data[];\n};\n\n \n\nstruct compat_xt_counters {\n\tcompat_u64 pcnt, bcnt;\t\t\t \n};\n\nstruct compat_xt_counters_info {\n\tchar name[XT_TABLE_MAXNAMELEN];\n\tcompat_uint_t num_counters;\n\tstruct compat_xt_counters counters[];\n};\n\nstruct _compat_xt_align {\n\t__u8 u8;\n\t__u16 u16;\n\t__u32 u32;\n\tcompat_u64 u64;\n};\n\n#define COMPAT_XT_ALIGN(s) __ALIGN_KERNEL((s), __alignof__(struct _compat_xt_align))\n\nvoid xt_compat_lock(u_int8_t af);\nvoid xt_compat_unlock(u_int8_t af);\n\nint xt_compat_add_offset(u_int8_t af, unsigned int offset, int delta);\nvoid xt_compat_flush_offsets(u_int8_t af);\nint xt_compat_init_offsets(u8 af, unsigned int number);\nint xt_compat_calc_jump(u_int8_t af, unsigned int offset);\n\nint xt_compat_match_offset(const struct xt_match *match);\nvoid xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,\n\t\t\t      unsigned int *size);\nint xt_compat_match_to_user(const struct xt_entry_match *m,\n\t\t\t    void __user **dstptr, unsigned int *size);\n\nint xt_compat_target_offset(const struct xt_target *target);\nvoid xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,\n\t\t\t\tunsigned int *size);\nint xt_compat_target_to_user(const struct xt_entry_target *t,\n\t\t\t     void __user **dstptr, unsigned int *size);\nint xt_compat_check_entry_offsets(const void *base, const char *elems,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset);\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}