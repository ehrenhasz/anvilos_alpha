{
  "module_name": "ip_set.h",
  "hash_id": "7bf4e637fe13c8fd92b9b487912bdd578926dc9ee5526039d39d191ef1a2b93f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/netfilter/ipset/ip_set.h",
  "human_readable_source": " \n \n#ifndef _IP_SET_H\n#define _IP_SET_H\n\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <net/netlink.h>\n#include <uapi/linux/netfilter/ipset/ip_set.h>\n\n#define _IP_SET_MODULE_DESC(a, b, c)\t\t\\\n\tMODULE_DESCRIPTION(a \" type of IP sets, revisions \" b \"-\" c)\n#define IP_SET_MODULE_DESC(a, b, c)\t\t\\\n\t_IP_SET_MODULE_DESC(a, __stringify(b), __stringify(c))\n\n \nenum ip_set_feature {\n\tIPSET_TYPE_IP_FLAG = 0,\n\tIPSET_TYPE_IP = (1 << IPSET_TYPE_IP_FLAG),\n\tIPSET_TYPE_PORT_FLAG = 1,\n\tIPSET_TYPE_PORT = (1 << IPSET_TYPE_PORT_FLAG),\n\tIPSET_TYPE_MAC_FLAG = 2,\n\tIPSET_TYPE_MAC = (1 << IPSET_TYPE_MAC_FLAG),\n\tIPSET_TYPE_IP2_FLAG = 3,\n\tIPSET_TYPE_IP2 = (1 << IPSET_TYPE_IP2_FLAG),\n\tIPSET_TYPE_NAME_FLAG = 4,\n\tIPSET_TYPE_NAME = (1 << IPSET_TYPE_NAME_FLAG),\n\tIPSET_TYPE_IFACE_FLAG = 5,\n\tIPSET_TYPE_IFACE = (1 << IPSET_TYPE_IFACE_FLAG),\n\tIPSET_TYPE_MARK_FLAG = 6,\n\tIPSET_TYPE_MARK = (1 << IPSET_TYPE_MARK_FLAG),\n\tIPSET_TYPE_NOMATCH_FLAG = 7,\n\tIPSET_TYPE_NOMATCH = (1 << IPSET_TYPE_NOMATCH_FLAG),\n\t \n\tIPSET_DUMP_LAST_FLAG = 8,\n\tIPSET_DUMP_LAST = (1 << IPSET_DUMP_LAST_FLAG),\n};\n\n \nenum ip_set_extension {\n\tIPSET_EXT_BIT_TIMEOUT = 0,\n\tIPSET_EXT_TIMEOUT = (1 << IPSET_EXT_BIT_TIMEOUT),\n\tIPSET_EXT_BIT_COUNTER = 1,\n\tIPSET_EXT_COUNTER = (1 << IPSET_EXT_BIT_COUNTER),\n\tIPSET_EXT_BIT_COMMENT = 2,\n\tIPSET_EXT_COMMENT = (1 << IPSET_EXT_BIT_COMMENT),\n\tIPSET_EXT_BIT_SKBINFO = 3,\n\tIPSET_EXT_SKBINFO = (1 << IPSET_EXT_BIT_SKBINFO),\n\t \n\tIPSET_EXT_BIT_DESTROY = 7,\n\tIPSET_EXT_DESTROY = (1 << IPSET_EXT_BIT_DESTROY),\n};\n\n#define SET_WITH_TIMEOUT(s)\t((s)->extensions & IPSET_EXT_TIMEOUT)\n#define SET_WITH_COUNTER(s)\t((s)->extensions & IPSET_EXT_COUNTER)\n#define SET_WITH_COMMENT(s)\t((s)->extensions & IPSET_EXT_COMMENT)\n#define SET_WITH_SKBINFO(s)\t((s)->extensions & IPSET_EXT_SKBINFO)\n#define SET_WITH_FORCEADD(s)\t((s)->flags & IPSET_CREATE_FLAG_FORCEADD)\n\n \nenum ip_set_ext_id {\n\tIPSET_EXT_ID_COUNTER = 0,\n\tIPSET_EXT_ID_TIMEOUT,\n\tIPSET_EXT_ID_SKBINFO,\n\tIPSET_EXT_ID_COMMENT,\n\tIPSET_EXT_ID_MAX,\n};\n\nstruct ip_set;\n\n \nstruct ip_set_ext_type {\n\t \n\tvoid (*destroy)(struct ip_set *set, void *ext);\n\tenum ip_set_extension type;\n\tenum ipset_cadt_flags flag;\n\t \n\tu8 len;\n\tu8 align;\n};\n\nextern const struct ip_set_ext_type ip_set_extensions[];\n\nstruct ip_set_counter {\n\tatomic64_t bytes;\n\tatomic64_t packets;\n};\n\nstruct ip_set_comment_rcu {\n\tstruct rcu_head rcu;\n\tchar str[];\n};\n\nstruct ip_set_comment {\n\tstruct ip_set_comment_rcu __rcu *c;\n};\n\nstruct ip_set_skbinfo {\n\tu32 skbmark;\n\tu32 skbmarkmask;\n\tu32 skbprio;\n\tu16 skbqueue;\n\tu16 __pad;\n};\n\nstruct ip_set_ext {\n\tstruct ip_set_skbinfo skbinfo;\n\tu64 packets;\n\tu64 bytes;\n\tchar *comment;\n\tu32 timeout;\n\tu8 packets_op;\n\tu8 bytes_op;\n\tbool target;\n};\n\n#define ext_timeout(e, s)\t\\\n((unsigned long *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_TIMEOUT]))\n#define ext_counter(e, s)\t\\\n((struct ip_set_counter *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_COUNTER]))\n#define ext_comment(e, s)\t\\\n((struct ip_set_comment *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_COMMENT]))\n#define ext_skbinfo(e, s)\t\\\n((struct ip_set_skbinfo *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_SKBINFO]))\n\ntypedef int (*ipset_adtfn)(struct ip_set *set, void *value,\n\t\t\t   const struct ip_set_ext *ext,\n\t\t\t   struct ip_set_ext *mext, u32 cmdflags);\n\n \nstruct ip_set_adt_opt {\n\tu8 family;\t\t \n\tu8 dim;\t\t\t \n\tu8 flags;\t\t \n\tu32 cmdflags;\t\t \n\tstruct ip_set_ext ext;\t \n};\n\n \nstruct ip_set_type_variant {\n\t \n\tint (*kadt)(struct ip_set *set, const struct sk_buff *skb,\n\t\t    const struct xt_action_param *par,\n\t\t    enum ipset_adt adt, struct ip_set_adt_opt *opt);\n\n\t \n\tint (*uadt)(struct ip_set *set, struct nlattr *tb[],\n\t\t    enum ipset_adt adt, u32 *lineno, u32 flags, bool retried);\n\n\t \n\tipset_adtfn adt[IPSET_ADT_MAX];\n\n\t \n\tint (*resize)(struct ip_set *set, bool retried);\n\t \n\tvoid (*destroy)(struct ip_set *set);\n\t \n\tvoid (*flush)(struct ip_set *set);\n\t \n\tvoid (*expire)(struct ip_set *set);\n\t \n\tint (*head)(struct ip_set *set, struct sk_buff *skb);\n\t \n\tint (*list)(const struct ip_set *set, struct sk_buff *skb,\n\t\t    struct netlink_callback *cb);\n\t \n\tvoid (*uref)(struct ip_set *set, struct netlink_callback *cb,\n\t\t     bool start);\n\n\t \n\tbool (*same_set)(const struct ip_set *a, const struct ip_set *b);\n\t \n\tbool region_lock;\n};\n\nstruct ip_set_region {\n\tspinlock_t lock;\t \n\tsize_t ext_size;\t \n\tu32 elements;\t\t \n};\n\n \n#define IPSET_MAX_RANGE\t\t(1<<14)\n\n \n#define IPSET_REVISION_MAX\t9\n\n \nstruct ip_set_type {\n\tstruct list_head list;\n\n\t \n\tchar name[IPSET_MAXNAMELEN];\n\t \n\tu8 protocol;\n\t \n\tu8 dimension;\n\t \n\tu8 family;\n\t \n\tu8 revision_min, revision_max;\n\t \n\tu8 create_flags[IPSET_REVISION_MAX+1];\n\t \n\tu16 features;\n\n\t \n\tint (*create)(struct net *net, struct ip_set *set,\n\t\t      struct nlattr *tb[], u32 flags);\n\n\t \n\tconst struct nla_policy create_policy[IPSET_ATTR_CREATE_MAX + 1];\n\tconst struct nla_policy adt_policy[IPSET_ATTR_ADT_MAX + 1];\n\n\t \n\tstruct module *me;\n};\n\n \nextern int ip_set_type_register(struct ip_set_type *set_type);\nextern void ip_set_type_unregister(struct ip_set_type *set_type);\n\n \nstruct ip_set {\n\t \n\tchar name[IPSET_MAXNAMELEN];\n\t \n\tspinlock_t lock;\n\t \n\tu32 ref;\n\t \n\tu32 ref_netlink;\n\t \n\tstruct ip_set_type *type;\n\t \n\tconst struct ip_set_type_variant *variant;\n\t \n\tu8 family;\n\t \n\tu8 revision;\n\t \n\tu8 extensions;\n\t \n\tu8 flags;\n\t \n\tu32 timeout;\n\t \n\tu32 elements;\n\t \n\tsize_t ext_size;\n\t \n\tsize_t dsize;\n\t \n\tsize_t offset[IPSET_EXT_ID_MAX];\n\t \n\tvoid *data;\n};\n\nstatic inline void\nip_set_ext_destroy(struct ip_set *set, void *data)\n{\n\t \n\tif (SET_WITH_COMMENT(set)) {\n\t\tstruct ip_set_comment *c = ext_comment(data, set);\n\n\t\tip_set_extensions[IPSET_EXT_ID_COMMENT].destroy(set, c);\n\t}\n}\n\nint ip_set_put_flags(struct sk_buff *skb, struct ip_set *set);\n\n \nenum {\n\tIPSET_CB_NET = 0,\t \n\tIPSET_CB_PROTO,\t\t \n\tIPSET_CB_DUMP,\t\t \n\tIPSET_CB_INDEX,\t\t \n\tIPSET_CB_PRIVATE,\t \n\tIPSET_CB_ARG0,\t\t \n};\n\n \nextern ip_set_id_t ip_set_get_byname(struct net *net,\n\t\t\t\t     const char *name, struct ip_set **set);\nextern void ip_set_put_byindex(struct net *net, ip_set_id_t index);\nextern void ip_set_name_byindex(struct net *net, ip_set_id_t index, char *name);\nextern ip_set_id_t ip_set_nfnl_get_byindex(struct net *net, ip_set_id_t index);\nextern void ip_set_nfnl_put(struct net *net, ip_set_id_t index);\n\n \n\nextern int ip_set_add(ip_set_id_t id, const struct sk_buff *skb,\n\t\t      const struct xt_action_param *par,\n\t\t      struct ip_set_adt_opt *opt);\nextern int ip_set_del(ip_set_id_t id, const struct sk_buff *skb,\n\t\t      const struct xt_action_param *par,\n\t\t      struct ip_set_adt_opt *opt);\nextern int ip_set_test(ip_set_id_t id, const struct sk_buff *skb,\n\t\t       const struct xt_action_param *par,\n\t\t       struct ip_set_adt_opt *opt);\n\n \nextern void *ip_set_alloc(size_t size);\nextern void ip_set_free(void *members);\nextern int ip_set_get_ipaddr4(struct nlattr *nla,  __be32 *ipaddr);\nextern int ip_set_get_ipaddr6(struct nlattr *nla, union nf_inet_addr *ipaddr);\nextern size_t ip_set_elem_len(struct ip_set *set, struct nlattr *tb[],\n\t\t\t      size_t len, size_t align);\nextern int ip_set_get_extensions(struct ip_set *set, struct nlattr *tb[],\n\t\t\t\t struct ip_set_ext *ext);\nextern int ip_set_put_extensions(struct sk_buff *skb, const struct ip_set *set,\n\t\t\t\t const void *e, bool active);\nextern bool ip_set_match_extensions(struct ip_set *set,\n\t\t\t\t    const struct ip_set_ext *ext,\n\t\t\t\t    struct ip_set_ext *mext,\n\t\t\t\t    u32 flags, void *data);\n\nstatic inline int\nip_set_get_hostipaddr4(struct nlattr *nla, u32 *ipaddr)\n{\n\t__be32 ip;\n\tint ret = ip_set_get_ipaddr4(nla, &ip);\n\n\tif (ret)\n\t\treturn ret;\n\t*ipaddr = ntohl(ip);\n\treturn 0;\n}\n\n \nstatic inline bool\nip_set_eexist(int ret, u32 flags)\n{\n\treturn ret == -IPSET_ERR_EXIST && (flags & IPSET_FLAG_EXIST);\n}\n\n \nstatic inline bool\nip_set_enomatch(int ret, u32 flags, enum ipset_adt adt, struct ip_set *set)\n{\n\treturn adt == IPSET_TEST &&\n\t       (set->type->features & IPSET_TYPE_NOMATCH) &&\n\t       ((flags >> 16) & IPSET_FLAG_NOMATCH) &&\n\t       (ret > 0 || ret == -ENOTEMPTY);\n}\n\n \nstatic inline bool\nip_set_attr_netorder(struct nlattr *tb[], int type)\n{\n\treturn tb[type] && (tb[type]->nla_type & NLA_F_NET_BYTEORDER);\n}\n\nstatic inline bool\nip_set_optattr_netorder(struct nlattr *tb[], int type)\n{\n\treturn !tb[type] || (tb[type]->nla_type & NLA_F_NET_BYTEORDER);\n}\n\n \nstatic inline u32\nip_set_get_h32(const struct nlattr *attr)\n{\n\treturn ntohl(nla_get_be32(attr));\n}\n\nstatic inline u16\nip_set_get_h16(const struct nlattr *attr)\n{\n\treturn ntohs(nla_get_be16(attr));\n}\n\nstatic inline int nla_put_ipaddr4(struct sk_buff *skb, int type, __be32 ipaddr)\n{\n\tstruct nlattr *__nested = nla_nest_start(skb, type);\n\tint ret;\n\n\tif (!__nested)\n\t\treturn -EMSGSIZE;\n\tret = nla_put_in_addr(skb, IPSET_ATTR_IPADDR_IPV4, ipaddr);\n\tif (!ret)\n\t\tnla_nest_end(skb, __nested);\n\treturn ret;\n}\n\nstatic inline int nla_put_ipaddr6(struct sk_buff *skb, int type,\n\t\t\t\t  const struct in6_addr *ipaddrptr)\n{\n\tstruct nlattr *__nested = nla_nest_start(skb, type);\n\tint ret;\n\n\tif (!__nested)\n\t\treturn -EMSGSIZE;\n\tret = nla_put_in6_addr(skb, IPSET_ATTR_IPADDR_IPV6, ipaddrptr);\n\tif (!ret)\n\t\tnla_nest_end(skb, __nested);\n\treturn ret;\n}\n\n \nstatic inline __be32\nip4addr(const struct sk_buff *skb, bool src)\n{\n\treturn src ? ip_hdr(skb)->saddr : ip_hdr(skb)->daddr;\n}\n\nstatic inline void\nip4addrptr(const struct sk_buff *skb, bool src, __be32 *addr)\n{\n\t*addr = src ? ip_hdr(skb)->saddr : ip_hdr(skb)->daddr;\n}\n\nstatic inline void\nip6addrptr(const struct sk_buff *skb, bool src, struct in6_addr *addr)\n{\n\tmemcpy(addr, src ? &ipv6_hdr(skb)->saddr : &ipv6_hdr(skb)->daddr,\n\t       sizeof(*addr));\n}\n\n \n#define IPSET_GC_TIME\t\t\t(3 * 60)\n\n \n#define IPSET_GC_PERIOD(timeout) \\\n\t((timeout/3) ? min_t(u32, (timeout)/3, IPSET_GC_TIME) : 1)\n\n \n#define IPSET_ELEM_PERMANENT\t0\n\n \n#define IPSET_NO_TIMEOUT\tUINT_MAX\n\n \n#define IPSET_MAX_TIMEOUT\t(UINT_MAX >> 1)/MSEC_PER_SEC\n\n#define ip_set_adt_opt_timeout(opt, set)\t\\\n((opt)->ext.timeout != IPSET_NO_TIMEOUT ? (opt)->ext.timeout : (set)->timeout)\n\nstatic inline unsigned int\nip_set_timeout_uget(struct nlattr *tb)\n{\n\tunsigned int timeout = ip_set_get_h32(tb);\n\n\t \n\tif (timeout > IPSET_MAX_TIMEOUT)\n\t\ttimeout = IPSET_MAX_TIMEOUT;\n\n\treturn timeout;\n}\n\nstatic inline bool\nip_set_timeout_expired(const unsigned long *t)\n{\n\treturn *t != IPSET_ELEM_PERMANENT && time_is_before_jiffies(*t);\n}\n\nstatic inline void\nip_set_timeout_set(unsigned long *timeout, u32 value)\n{\n\tunsigned long t;\n\n\tif (!value) {\n\t\t*timeout = IPSET_ELEM_PERMANENT;\n\t\treturn;\n\t}\n\n\tt = msecs_to_jiffies(value * MSEC_PER_SEC) + jiffies;\n\tif (t == IPSET_ELEM_PERMANENT)\n\t\t \n\t\tt--;\n\t*timeout = t;\n}\n\nvoid ip_set_init_comment(struct ip_set *set, struct ip_set_comment *comment,\n\t\t\t const struct ip_set_ext *ext);\n\nstatic inline void\nip_set_init_counter(struct ip_set_counter *counter,\n\t\t    const struct ip_set_ext *ext)\n{\n\tif (ext->bytes != ULLONG_MAX)\n\t\tatomic64_set(&(counter)->bytes, (long long)(ext->bytes));\n\tif (ext->packets != ULLONG_MAX)\n\t\tatomic64_set(&(counter)->packets, (long long)(ext->packets));\n}\n\nstatic inline void\nip_set_init_skbinfo(struct ip_set_skbinfo *skbinfo,\n\t\t    const struct ip_set_ext *ext)\n{\n\t*skbinfo = ext->skbinfo;\n}\n\nstatic inline void\nnf_inet_addr_mask_inplace(union nf_inet_addr *a1,\n\t\t\t  const union nf_inet_addr *mask)\n{\n\ta1->all[0] &= mask->all[0];\n\ta1->all[1] &= mask->all[1];\n\ta1->all[2] &= mask->all[2];\n\ta1->all[3] &= mask->all[3];\n}\n\n#define IP_SET_INIT_KEXT(skb, opt, set)\t\t\t\\\n\t{ .bytes = (skb)->len, .packets = 1, .target = true,\\\n\t  .timeout = ip_set_adt_opt_timeout(opt, set) }\n\n#define IP_SET_INIT_UEXT(set)\t\t\t\t\\\n\t{ .bytes = ULLONG_MAX, .packets = ULLONG_MAX,\t\\\n\t  .timeout = (set)->timeout }\n\n#define IPSET_CONCAT(a, b)\t\ta##b\n#define IPSET_TOKEN(a, b)\t\tIPSET_CONCAT(a, b)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}