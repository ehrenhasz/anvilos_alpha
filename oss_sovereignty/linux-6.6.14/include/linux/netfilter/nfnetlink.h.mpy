{
  "module_name": "nfnetlink.h",
  "hash_id": "e0a3d185bd50daf5e95419c7b5ff39f57d24446ee67c4d61a874432588213de0",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/netfilter/nfnetlink.h",
  "human_readable_source": " \n#ifndef _NFNETLINK_H\n#define _NFNETLINK_H\n\n#include <linux/netlink.h>\n#include <linux/capability.h>\n#include <net/netlink.h>\n#include <uapi/linux/netfilter/nfnetlink.h>\n\nstruct nfnl_info {\n\tstruct net\t\t*net;\n\tstruct sock\t\t*sk;\n\tconst struct nlmsghdr\t*nlh;\n\tconst struct nfgenmsg\t*nfmsg;\n\tstruct netlink_ext_ack\t*extack;\n};\n\nenum nfnl_callback_type {\n\tNFNL_CB_UNSPEC\t= 0,\n\tNFNL_CB_MUTEX,\n\tNFNL_CB_RCU,\n\tNFNL_CB_BATCH,\n};\n\nstruct nfnl_callback {\n\tint (*call)(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t    const struct nlattr * const cda[]);\n\tconst struct nla_policy\t*policy;\n\tenum nfnl_callback_type\ttype;\n\t__u16\t\t\tattr_count;\n};\n\nenum nfnl_abort_action {\n\tNFNL_ABORT_NONE\t\t= 0,\n\tNFNL_ABORT_AUTOLOAD,\n\tNFNL_ABORT_VALIDATE,\n};\n\nstruct nfnetlink_subsystem {\n\tconst char *name;\n\t__u8 subsys_id;\t\t\t \n\t__u8 cb_count;\t\t\t \n\tconst struct nfnl_callback *cb;\t \n\tstruct module *owner;\n\tint (*commit)(struct net *net, struct sk_buff *skb);\n\tint (*abort)(struct net *net, struct sk_buff *skb,\n\t\t     enum nfnl_abort_action action);\n\tbool (*valid_genid)(struct net *net, u32 genid);\n};\n\nint nfnetlink_subsys_register(const struct nfnetlink_subsystem *n);\nint nfnetlink_subsys_unregister(const struct nfnetlink_subsystem *n);\n\nint nfnetlink_has_listeners(struct net *net, unsigned int group);\nint nfnetlink_send(struct sk_buff *skb, struct net *net, u32 portid,\n\t\t   unsigned int group, int echo, gfp_t flags);\nint nfnetlink_set_err(struct net *net, u32 portid, u32 group, int error);\nint nfnetlink_unicast(struct sk_buff *skb, struct net *net, u32 portid);\nvoid nfnetlink_broadcast(struct net *net, struct sk_buff *skb, __u32 portid,\n\t\t\t __u32 group, gfp_t allocation);\n\nstatic inline u16 nfnl_msg_type(u8 subsys, u8 msg_type)\n{\n\treturn subsys << 8 | msg_type;\n}\n\nstatic inline void nfnl_fill_hdr(struct nlmsghdr *nlh, u8 family, u8 version,\n\t\t\t\t __be16 res_id)\n{\n\tstruct nfgenmsg *nfmsg;\n\n\tnfmsg = nlmsg_data(nlh);\n\tnfmsg->nfgen_family = family;\n\tnfmsg->version = version;\n\tnfmsg->res_id = res_id;\n}\n\nstatic inline struct nlmsghdr *nfnl_msg_put(struct sk_buff *skb, u32 portid,\n\t\t\t\t\t    u32 seq, int type, int flags,\n\t\t\t\t\t    u8 family, u8 version,\n\t\t\t\t\t    __be16 res_id)\n{\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, portid, seq, type, sizeof(struct nfgenmsg), flags);\n\tif (!nlh)\n\t\treturn NULL;\n\n\tnfnl_fill_hdr(nlh, family, version, res_id);\n\n\treturn nlh;\n}\n\nvoid nfnl_lock(__u8 subsys_id);\nvoid nfnl_unlock(__u8 subsys_id);\n#ifdef CONFIG_PROVE_LOCKING\nbool lockdep_nfnl_is_held(__u8 subsys_id);\n#else\nstatic inline bool lockdep_nfnl_is_held(__u8 subsys_id)\n{\n\treturn true;\n}\n#endif  \n\n#define MODULE_ALIAS_NFNL_SUBSYS(subsys) \\\n\tMODULE_ALIAS(\"nfnetlink-subsys-\" __stringify(subsys))\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}