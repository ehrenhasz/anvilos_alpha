{
  "module_name": "spinlock_rt.h",
  "hash_id": "141885196a3eb8251decb5b5f62f8bb87f452f7e460076383b88207d66af3a5b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/spinlock_rt.h",
  "human_readable_source": "\n#ifndef __LINUX_SPINLOCK_RT_H\n#define __LINUX_SPINLOCK_RT_H\n\n#ifndef __LINUX_INSIDE_SPINLOCK_H\n#error Do not include directly. Use spinlock.h\n#endif\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nextern void __rt_spin_lock_init(spinlock_t *lock, const char *name,\n\t\t\t\tstruct lock_class_key *key, bool percpu);\n#else\nstatic inline void __rt_spin_lock_init(spinlock_t *lock, const char *name,\n\t\t\t\tstruct lock_class_key *key, bool percpu)\n{\n}\n#endif\n\n#define spin_lock_init(slock)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\trt_mutex_base_init(&(slock)->lock);\t\t\t\\\n\t__rt_spin_lock_init(slock, #slock, &__key, false);\t\\\n} while (0)\n\n#define local_spin_lock_init(slock)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\trt_mutex_base_init(&(slock)->lock);\t\t\t\\\n\t__rt_spin_lock_init(slock, #slock, &__key, true);\t\\\n} while (0)\n\nextern void rt_spin_lock(spinlock_t *lock);\nextern void rt_spin_lock_nested(spinlock_t *lock, int subclass);\nextern void rt_spin_lock_nest_lock(spinlock_t *lock, struct lockdep_map *nest_lock);\nextern void rt_spin_unlock(spinlock_t *lock);\nextern void rt_spin_lock_unlock(spinlock_t *lock);\nextern int rt_spin_trylock_bh(spinlock_t *lock);\nextern int rt_spin_trylock(spinlock_t *lock);\n\nstatic __always_inline void spin_lock(spinlock_t *lock)\n{\n\trt_spin_lock(lock);\n}\n\n#ifdef CONFIG_LOCKDEP\n# define __spin_lock_nested(lock, subclass)\t\t\t\t\\\n\trt_spin_lock_nested(lock, subclass)\n\n# define __spin_lock_nest_lock(lock, nest_lock)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttypecheck(struct lockdep_map *, &(nest_lock)->dep_map);\t\\\n\t\trt_spin_lock_nest_lock(lock, &(nest_lock)->dep_map);\t\\\n\t} while (0)\n# define __spin_lock_irqsave_nested(lock, flags, subclass)\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\t\\\n\t\tflags = 0;\t\t\t\t\t\\\n\t\t__spin_lock_nested(lock, subclass);\t\t\\\n\t} while (0)\n\n#else\n  \n# define __spin_lock_nested(lock, subclass)\tspin_lock(((void)(subclass), (lock)))\n# define __spin_lock_nest_lock(lock, subclass)\tspin_lock(((void)(subclass), (lock)))\n# define __spin_lock_irqsave_nested(lock, flags, subclass)\t\\\n\tspin_lock_irqsave(((void)(subclass), (lock)), flags)\n#endif\n\n#define spin_lock_nested(lock, subclass)\t\t\\\n\t__spin_lock_nested(lock, subclass)\n\n#define spin_lock_nest_lock(lock, nest_lock)\t\t\\\n\t__spin_lock_nest_lock(lock, nest_lock)\n\n#define spin_lock_irqsave_nested(lock, flags, subclass)\t\\\n\t__spin_lock_irqsave_nested(lock, flags, subclass)\n\nstatic __always_inline void spin_lock_bh(spinlock_t *lock)\n{\n\t \n\tlocal_bh_disable();\n\trt_spin_lock(lock);\n}\n\nstatic __always_inline void spin_lock_irq(spinlock_t *lock)\n{\n\trt_spin_lock(lock);\n}\n\n#define spin_lock_irqsave(lock, flags)\t\t\t \\\n\tdo {\t\t\t\t\t\t \\\n\t\ttypecheck(unsigned long, flags);\t \\\n\t\tflags = 0;\t\t\t\t \\\n\t\tspin_lock(lock);\t\t\t \\\n\t} while (0)\n\nstatic __always_inline void spin_unlock(spinlock_t *lock)\n{\n\trt_spin_unlock(lock);\n}\n\nstatic __always_inline void spin_unlock_bh(spinlock_t *lock)\n{\n\trt_spin_unlock(lock);\n\tlocal_bh_enable();\n}\n\nstatic __always_inline void spin_unlock_irq(spinlock_t *lock)\n{\n\trt_spin_unlock(lock);\n}\n\nstatic __always_inline void spin_unlock_irqrestore(spinlock_t *lock,\n\t\t\t\t\t\t   unsigned long flags)\n{\n\trt_spin_unlock(lock);\n}\n\n#define spin_trylock(lock)\t\t\t\t\\\n\t__cond_lock(lock, rt_spin_trylock(lock))\n\n#define spin_trylock_bh(lock)\t\t\t\t\\\n\t__cond_lock(lock, rt_spin_trylock_bh(lock))\n\n#define spin_trylock_irq(lock)\t\t\t\t\\\n\t__cond_lock(lock, rt_spin_trylock(lock))\n\n#define __spin_trylock_irqsave(lock, flags)\t\t\\\n({\t\t\t\t\t\t\t\\\n\tint __locked;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\n\ttypecheck(unsigned long, flags);\t\t\\\n\tflags = 0;\t\t\t\t\t\\\n\t__locked = spin_trylock(lock);\t\t\t\\\n\t__locked;\t\t\t\t\t\\\n})\n\n#define spin_trylock_irqsave(lock, flags)\t\t\\\n\t__cond_lock(lock, __spin_trylock_irqsave(lock, flags))\n\n#define spin_is_contended(lock)\t\t(((void)(lock), 0))\n\nstatic inline int spin_is_locked(spinlock_t *lock)\n{\n\treturn rt_mutex_base_is_locked(&lock->lock);\n}\n\n#define assert_spin_locked(lock) BUG_ON(!spin_is_locked(lock))\n\n#include <linux/rwlock_rt.h>\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}