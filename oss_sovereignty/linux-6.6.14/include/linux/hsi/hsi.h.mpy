{
  "module_name": "hsi.h",
  "hash_id": "c41120bd67d754c984b940871f10ba3204813d41256714eeea78b236fd5eb361",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/hsi/hsi.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_HSI_H__\n#define __LINUX_HSI_H__\n\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/scatterlist.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n\n \n#define HSI_MSG_READ\t0\n#define HSI_MSG_WRITE\t1\n\n \nenum {\n\tHSI_MODE_STREAM\t= 1,\n\tHSI_MODE_FRAME,\n};\n\nenum {\n\tHSI_FLOW_SYNC,\t \n\tHSI_FLOW_PIPE,\t \n};\n\nenum {\n\tHSI_ARB_RR,\t \n\tHSI_ARB_PRIO,\t \n};\n\n#define HSI_MAX_CHANNELS\t16\n\n \nenum {\n\tHSI_STATUS_COMPLETED,\t \n\tHSI_STATUS_PENDING,\t \n\tHSI_STATUS_PROCEEDING,\t \n\tHSI_STATUS_QUEUED,\t \n\tHSI_STATUS_ERROR,\t \n};\n\n \nenum {\n\tHSI_EVENT_START_RX,\n\tHSI_EVENT_STOP_RX,\n};\n\n \nstruct hsi_channel {\n\tunsigned int\tid;\n\tconst char\t*name;\n};\n\n \nstruct hsi_config {\n\tunsigned int\t\tmode;\n\tstruct hsi_channel\t*channels;\n\tunsigned int\t\tnum_channels;\n\tunsigned int\t\tnum_hw_channels;\n\tunsigned int\t\tspeed;\n\tunion {\n\t\tunsigned int\tflow;\t\t \n\t\tunsigned int\tarb_mode;\t \n\t};\n};\n\n \nstruct hsi_board_info {\n\tconst char\t\t*name;\n\tunsigned int\t\thsi_id;\n\tunsigned int\t\tport;\n\tstruct hsi_config\ttx_cfg;\n\tstruct hsi_config\trx_cfg;\n\tvoid\t\t\t*platform_data;\n\tstruct dev_archdata\t*archdata;\n};\n\n#ifdef CONFIG_HSI_BOARDINFO\nextern int hsi_register_board_info(struct hsi_board_info const *info,\n\t\t\t\t\t\t\tunsigned int len);\n#else\nstatic inline int hsi_register_board_info(struct hsi_board_info const *info,\n\t\t\t\t\t\t\tunsigned int len)\n{\n\treturn 0;\n}\n#endif  \n\n \nstruct hsi_client {\n\tstruct device\t\tdevice;\n\tstruct hsi_config\ttx_cfg;\n\tstruct hsi_config\trx_cfg;\n\t \n\tvoid\t\t\t(*ehandler)(struct hsi_client *, unsigned long);\n\tunsigned int\t\tpclaimed:1;\n\tstruct notifier_block\tnb;\n};\n\n#define to_hsi_client(dev) container_of(dev, struct hsi_client, device)\n\nstatic inline void hsi_client_set_drvdata(struct hsi_client *cl, void *data)\n{\n\tdev_set_drvdata(&cl->device, data);\n}\n\nstatic inline void *hsi_client_drvdata(struct hsi_client *cl)\n{\n\treturn dev_get_drvdata(&cl->device);\n}\n\nint hsi_register_port_event(struct hsi_client *cl,\n\t\t\tvoid (*handler)(struct hsi_client *, unsigned long));\nint hsi_unregister_port_event(struct hsi_client *cl);\n\n \nstruct hsi_client_driver {\n\tstruct device_driver\tdriver;\n};\n\n#define to_hsi_client_driver(drv) container_of(drv, struct hsi_client_driver,\\\n\t\t\t\t\t\t\t\t\tdriver)\n\nint hsi_register_client_driver(struct hsi_client_driver *drv);\n\nstatic inline void hsi_unregister_client_driver(struct hsi_client_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\n\n \nstruct hsi_msg {\n\tstruct list_head\tlink;\n\tstruct hsi_client\t*cl;\n\tstruct sg_table\t\tsgt;\n\tvoid\t\t\t*context;\n\n\tvoid\t\t\t(*complete)(struct hsi_msg *msg);\n\tvoid\t\t\t(*destructor)(struct hsi_msg *msg);\n\n\tint\t\t\tstatus;\n\tunsigned int\t\tactual_len;\n\tunsigned int\t\tchannel;\n\tunsigned int\t\tttype:1;\n\tunsigned int\t\tbreak_frame:1;\n};\n\nstruct hsi_msg *hsi_alloc_msg(unsigned int n_frag, gfp_t flags);\nvoid hsi_free_msg(struct hsi_msg *msg);\n\n \nstruct hsi_port {\n\tstruct device\t\t\tdevice;\n\tstruct hsi_config\t\ttx_cfg;\n\tstruct hsi_config\t\trx_cfg;\n\tunsigned int\t\t\tnum;\n\tunsigned int\t\t\tshared:1;\n\tint\t\t\t\tclaimed;\n\tstruct mutex\t\t\tlock;\n\tint\t\t\t\t(*async)(struct hsi_msg *msg);\n\tint\t\t\t\t(*setup)(struct hsi_client *cl);\n\tint\t\t\t\t(*flush)(struct hsi_client *cl);\n\tint\t\t\t\t(*start_tx)(struct hsi_client *cl);\n\tint\t\t\t\t(*stop_tx)(struct hsi_client *cl);\n\tint\t\t\t\t(*release)(struct hsi_client *cl);\n\t \n\tstruct blocking_notifier_head\tn_head;\n};\n\n#define to_hsi_port(dev) container_of(dev, struct hsi_port, device)\n#define hsi_get_port(cl) to_hsi_port((cl)->device.parent)\n\nint hsi_event(struct hsi_port *port, unsigned long event);\nint hsi_claim_port(struct hsi_client *cl, unsigned int share);\nvoid hsi_release_port(struct hsi_client *cl);\n\nstatic inline int hsi_port_claimed(struct hsi_client *cl)\n{\n\treturn cl->pclaimed;\n}\n\nstatic inline void hsi_port_set_drvdata(struct hsi_port *port, void *data)\n{\n\tdev_set_drvdata(&port->device, data);\n}\n\nstatic inline void *hsi_port_drvdata(struct hsi_port *port)\n{\n\treturn dev_get_drvdata(&port->device);\n}\n\n \nstruct hsi_controller {\n\tstruct device\t\tdevice;\n\tstruct module\t\t*owner;\n\tunsigned int\t\tid;\n\tunsigned int\t\tnum_ports;\n\tstruct hsi_port\t\t**port;\n};\n\n#define to_hsi_controller(dev) container_of(dev, struct hsi_controller, device)\n\nstruct hsi_controller *hsi_alloc_controller(unsigned int n_ports, gfp_t flags);\nvoid hsi_put_controller(struct hsi_controller *hsi);\nint hsi_register_controller(struct hsi_controller *hsi);\nvoid hsi_unregister_controller(struct hsi_controller *hsi);\nstruct hsi_client *hsi_new_client(struct hsi_port *port,\n\t\t\t\t\t\tstruct hsi_board_info *info);\nint hsi_remove_client(struct device *dev, void *data);\nvoid hsi_port_unregister_clients(struct hsi_port *port);\n\n#ifdef CONFIG_OF\nvoid hsi_add_clients_from_dt(struct hsi_port *port,\n\t\t\t     struct device_node *clients);\n#else\nstatic inline void hsi_add_clients_from_dt(struct hsi_port *port,\n\t\t\t\t\t   struct device_node *clients)\n{\n\treturn;\n}\n#endif\n\nstatic inline void hsi_controller_set_drvdata(struct hsi_controller *hsi,\n\t\t\t\t\t\t\t\tvoid *data)\n{\n\tdev_set_drvdata(&hsi->device, data);\n}\n\nstatic inline void *hsi_controller_drvdata(struct hsi_controller *hsi)\n{\n\treturn dev_get_drvdata(&hsi->device);\n}\n\nstatic inline struct hsi_port *hsi_find_port_num(struct hsi_controller *hsi,\n\t\t\t\t\t\t\tunsigned int num)\n{\n\treturn (num < hsi->num_ports) ? hsi->port[num] : NULL;\n}\n\n \nint hsi_async(struct hsi_client *cl, struct hsi_msg *msg);\n\nint hsi_get_channel_id_by_name(struct hsi_client *cl, char *name);\n\n \nstatic inline unsigned int hsi_id(struct hsi_client *cl)\n{\n\treturn\tto_hsi_controller(cl->device.parent->parent)->id;\n}\n\n \nstatic inline unsigned int hsi_port_id(struct hsi_client *cl)\n{\n\treturn\tto_hsi_port(cl->device.parent)->num;\n}\n\n \nstatic inline int hsi_setup(struct hsi_client *cl)\n{\n\tif (!hsi_port_claimed(cl))\n\t\treturn -EACCES;\n\treturn\thsi_get_port(cl)->setup(cl);\n}\n\n \nstatic inline int hsi_flush(struct hsi_client *cl)\n{\n\tif (!hsi_port_claimed(cl))\n\t\treturn -EACCES;\n\treturn hsi_get_port(cl)->flush(cl);\n}\n\n \nstatic inline int hsi_async_read(struct hsi_client *cl, struct hsi_msg *msg)\n{\n\tmsg->ttype = HSI_MSG_READ;\n\treturn hsi_async(cl, msg);\n}\n\n \nstatic inline int hsi_async_write(struct hsi_client *cl, struct hsi_msg *msg)\n{\n\tmsg->ttype = HSI_MSG_WRITE;\n\treturn hsi_async(cl, msg);\n}\n\n \nstatic inline int hsi_start_tx(struct hsi_client *cl)\n{\n\tif (!hsi_port_claimed(cl))\n\t\treturn -EACCES;\n\treturn hsi_get_port(cl)->start_tx(cl);\n}\n\n \nstatic inline int hsi_stop_tx(struct hsi_client *cl)\n{\n\tif (!hsi_port_claimed(cl))\n\t\treturn -EACCES;\n\treturn hsi_get_port(cl)->stop_tx(cl);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}