{
  "module_name": "uprobes.h",
  "hash_id": "d74763049887aed01f9f36f338c2b4237b05b9bc1c2cfa63bb1e41eb1cb747f3",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/uprobes.h",
  "human_readable_source": " \n#ifndef _LINUX_UPROBES_H\n#define _LINUX_UPROBES_H\n \n\n#include <linux/errno.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n\nstruct vm_area_struct;\nstruct mm_struct;\nstruct inode;\nstruct notifier_block;\nstruct page;\n\n#define UPROBE_HANDLER_REMOVE\t\t1\n#define UPROBE_HANDLER_MASK\t\t1\n\n#define MAX_URETPROBE_DEPTH\t\t64\n\nenum uprobe_filter_ctx {\n\tUPROBE_FILTER_REGISTER,\n\tUPROBE_FILTER_UNREGISTER,\n\tUPROBE_FILTER_MMAP,\n};\n\nstruct uprobe_consumer {\n\tint (*handler)(struct uprobe_consumer *self, struct pt_regs *regs);\n\tint (*ret_handler)(struct uprobe_consumer *self,\n\t\t\t\tunsigned long func,\n\t\t\t\tstruct pt_regs *regs);\n\tbool (*filter)(struct uprobe_consumer *self,\n\t\t\t\tenum uprobe_filter_ctx ctx,\n\t\t\t\tstruct mm_struct *mm);\n\n\tstruct uprobe_consumer *next;\n};\n\n#ifdef CONFIG_UPROBES\n#include <asm/uprobes.h>\n\nenum uprobe_task_state {\n\tUTASK_RUNNING,\n\tUTASK_SSTEP,\n\tUTASK_SSTEP_ACK,\n\tUTASK_SSTEP_TRAPPED,\n};\n\n \nstruct uprobe_task {\n\tenum uprobe_task_state\t\tstate;\n\n\tunion {\n\t\tstruct {\n\t\t\tstruct arch_uprobe_task\tautask;\n\t\t\tunsigned long\t\tvaddr;\n\t\t};\n\n\t\tstruct {\n\t\t\tstruct callback_head\tdup_xol_work;\n\t\t\tunsigned long\t\tdup_xol_addr;\n\t\t};\n\t};\n\n\tstruct uprobe\t\t\t*active_uprobe;\n\tunsigned long\t\t\txol_vaddr;\n\n\tstruct return_instance\t\t*return_instances;\n\tunsigned int\t\t\tdepth;\n};\n\nstruct return_instance {\n\tstruct uprobe\t\t*uprobe;\n\tunsigned long\t\tfunc;\n\tunsigned long\t\tstack;\t\t \n\tunsigned long\t\torig_ret_vaddr;  \n\tbool\t\t\tchained;\t \n\n\tstruct return_instance\t*next;\t\t \n};\n\nenum rp_check {\n\tRP_CHECK_CALL,\n\tRP_CHECK_CHAIN_CALL,\n\tRP_CHECK_RET,\n};\n\nstruct xol_area;\n\nstruct uprobes_state {\n\tstruct xol_area\t\t*xol_area;\n};\n\nextern void __init uprobes_init(void);\nextern int set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);\nextern int set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);\nextern bool is_swbp_insn(uprobe_opcode_t *insn);\nextern bool is_trap_insn(uprobe_opcode_t *insn);\nextern unsigned long uprobe_get_swbp_addr(struct pt_regs *regs);\nextern unsigned long uprobe_get_trap_addr(struct pt_regs *regs);\nextern int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr, uprobe_opcode_t);\nextern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);\nextern int uprobe_register_refctr(struct inode *inode, loff_t offset, loff_t ref_ctr_offset, struct uprobe_consumer *uc);\nextern int uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool);\nextern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);\nextern int uprobe_mmap(struct vm_area_struct *vma);\nextern void uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end);\nextern void uprobe_start_dup_mmap(void);\nextern void uprobe_end_dup_mmap(void);\nextern void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm);\nextern void uprobe_free_utask(struct task_struct *t);\nextern void uprobe_copy_process(struct task_struct *t, unsigned long flags);\nextern int uprobe_post_sstep_notifier(struct pt_regs *regs);\nextern int uprobe_pre_sstep_notifier(struct pt_regs *regs);\nextern void uprobe_notify_resume(struct pt_regs *regs);\nextern bool uprobe_deny_signal(void);\nextern bool arch_uprobe_skip_sstep(struct arch_uprobe *aup, struct pt_regs *regs);\nextern void uprobe_clear_state(struct mm_struct *mm);\nextern int  arch_uprobe_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long addr);\nextern int  arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs);\nextern int  arch_uprobe_post_xol(struct arch_uprobe *aup, struct pt_regs *regs);\nextern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);\nextern int  arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val, void *data);\nextern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);\nextern unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs);\nextern bool arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx, struct pt_regs *regs);\nextern bool arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs);\nextern void arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t\t void *src, unsigned long len);\n#else  \nstruct uprobes_state {\n};\n\nstatic inline void uprobes_init(void)\n{\n}\n\n#define uprobe_get_trap_addr(regs)\tinstruction_pointer(regs)\n\nstatic inline int\nuprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)\n{\n\treturn -ENOSYS;\n}\nstatic inline int uprobe_register_refctr(struct inode *inode, loff_t offset, loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\treturn -ENOSYS;\n}\nstatic inline int\nuprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool add)\n{\n\treturn -ENOSYS;\n}\nstatic inline void\nuprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)\n{\n}\nstatic inline int uprobe_mmap(struct vm_area_struct *vma)\n{\n\treturn 0;\n}\nstatic inline void\nuprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n}\nstatic inline void uprobe_start_dup_mmap(void)\n{\n}\nstatic inline void uprobe_end_dup_mmap(void)\n{\n}\nstatic inline void\nuprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm)\n{\n}\nstatic inline void uprobe_notify_resume(struct pt_regs *regs)\n{\n}\nstatic inline bool uprobe_deny_signal(void)\n{\n\treturn false;\n}\nstatic inline void uprobe_free_utask(struct task_struct *t)\n{\n}\nstatic inline void uprobe_copy_process(struct task_struct *t, unsigned long flags)\n{\n}\nstatic inline void uprobe_clear_state(struct mm_struct *mm)\n{\n}\n#endif  \n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}