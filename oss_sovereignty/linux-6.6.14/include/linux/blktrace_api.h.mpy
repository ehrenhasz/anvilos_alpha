{
  "module_name": "blktrace_api.h",
  "hash_id": "d288c6c088abdda4032bfa0b3fb04c5ce350103ae0f75b695c66724df5011686",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/blktrace_api.h",
  "human_readable_source": " \n#ifndef BLKTRACE_H\n#define BLKTRACE_H\n\n#include <linux/blk-mq.h>\n#include <linux/relay.h>\n#include <linux/compat.h>\n#include <uapi/linux/blktrace_api.h>\n#include <linux/list.h>\n#include <linux/blk_types.h>\n\n#if defined(CONFIG_BLK_DEV_IO_TRACE)\n\n#include <linux/sysfs.h>\n\nstruct blk_trace {\n\tint trace_state;\n\tstruct rchan *rchan;\n\tunsigned long __percpu *sequence;\n\tunsigned char __percpu *msg_data;\n\tu16 act_mask;\n\tu64 start_lba;\n\tu64 end_lba;\n\tu32 pid;\n\tu32 dev;\n\tstruct dentry *dir;\n\tstruct list_head running_list;\n\tatomic_t dropped;\n};\n\nextern int blk_trace_ioctl(struct block_device *, unsigned, char __user *);\nextern void blk_trace_shutdown(struct request_queue *);\n__printf(3, 4) void __blk_trace_note_message(struct blk_trace *bt,\n\t\tstruct cgroup_subsys_state *css, const char *fmt, ...);\n\n \n#define blk_add_cgroup_trace_msg(q, css, fmt, ...)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct blk_trace *bt;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\trcu_read_lock();\t\t\t\t\t\\\n\t\tbt = rcu_dereference((q)->blk_trace);\t\t\t\\\n\t\tif (unlikely(bt))\t\t\t\t\t\\\n\t\t\t__blk_trace_note_message(bt, css, fmt, ##__VA_ARGS__);\\\n\t\trcu_read_unlock();\t\t\t\t\t\\\n\t} while (0)\n#define blk_add_trace_msg(q, fmt, ...)\t\t\t\t\t\\\n\tblk_add_cgroup_trace_msg(q, NULL, fmt, ##__VA_ARGS__)\n#define BLK_TN_MAX_MSG\t\t128\n\nstatic inline bool blk_trace_note_message_enabled(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\tbool ret;\n\n\trcu_read_lock();\n\tbt = rcu_dereference(q->blk_trace);\n\tret = bt && (bt->act_mask & BLK_TC_NOTIFY);\n\trcu_read_unlock();\n\treturn ret;\n}\n\nextern void blk_add_driver_data(struct request *rq, void *data, size_t len);\nextern int blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t   struct block_device *bdev,\n\t\t\t   char __user *arg);\nextern int blk_trace_startstop(struct request_queue *q, int start);\nextern int blk_trace_remove(struct request_queue *q);\n\n#else  \n# define blk_trace_ioctl(bdev, cmd, arg)\t\t(-ENOTTY)\n# define blk_trace_shutdown(q)\t\t\t\tdo { } while (0)\n# define blk_add_driver_data(rq, data, len)\t\tdo {} while (0)\n# define blk_trace_setup(q, name, dev, bdev, arg)\t(-ENOTTY)\n# define blk_trace_startstop(q, start)\t\t\t(-ENOTTY)\n# define blk_add_trace_msg(q, fmt, ...)\t\t\tdo { } while (0)\n# define blk_add_cgroup_trace_msg(q, cg, fmt, ...)\tdo { } while (0)\n# define blk_trace_note_message_enabled(q)\t\t(false)\n\nstatic inline int blk_trace_remove(struct request_queue *q)\n{\n\treturn -ENOTTY;\n}\n#endif  \n\n#ifdef CONFIG_COMPAT\n\nstruct compat_blk_user_trace_setup {\n\tchar name[BLKTRACE_BDEV_SIZE];\n\tu16 act_mask;\n\tu32 buf_size;\n\tu32 buf_nr;\n\tcompat_u64 start_lba;\n\tcompat_u64 end_lba;\n\tu32 pid;\n};\n#define BLKTRACESETUP32 _IOWR(0x12, 115, struct compat_blk_user_trace_setup)\n\n#endif\n\nvoid blk_fill_rwbs(char *rwbs, blk_opf_t opf);\n\nstatic inline sector_t blk_rq_trace_sector(struct request *rq)\n{\n\t \n\tif (blk_rq_is_passthrough(rq) || blk_rq_pos(rq) == (sector_t)-1)\n\t\treturn 0;\n\treturn blk_rq_pos(rq);\n}\n\nstatic inline unsigned int blk_rq_trace_nr_sectors(struct request *rq)\n{\n\treturn blk_rq_is_passthrough(rq) ? 0 : blk_rq_sectors(rq);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}