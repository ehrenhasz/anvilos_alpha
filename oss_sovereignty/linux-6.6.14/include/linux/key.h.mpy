{
  "module_name": "key.h",
  "hash_id": "4a48e32f316be3753713d2dcc5ef360c7d5c7f585eada25c39df538faf2ad5b1",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/key.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_KEY_H\n#define _LINUX_KEY_H\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <linux/rcupdate.h>\n#include <linux/sysctl.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n#include <linux/assoc_array.h>\n#include <linux/refcount.h>\n#include <linux/time64.h>\n\n#ifdef __KERNEL__\n#include <linux/uidgid.h>\n\n \ntypedef int32_t key_serial_t;\n\n \ntypedef uint32_t key_perm_t;\n\nstruct key;\nstruct net;\n\n#ifdef CONFIG_KEYS\n\n#undef KEY_DEBUGGING\n\n#define KEY_POS_VIEW\t0x01000000\t \n#define KEY_POS_READ\t0x02000000\t \n#define KEY_POS_WRITE\t0x04000000\t \n#define KEY_POS_SEARCH\t0x08000000\t \n#define KEY_POS_LINK\t0x10000000\t \n#define KEY_POS_SETATTR\t0x20000000\t \n#define KEY_POS_ALL\t0x3f000000\n\n#define KEY_USR_VIEW\t0x00010000\t \n#define KEY_USR_READ\t0x00020000\n#define KEY_USR_WRITE\t0x00040000\n#define KEY_USR_SEARCH\t0x00080000\n#define KEY_USR_LINK\t0x00100000\n#define KEY_USR_SETATTR\t0x00200000\n#define KEY_USR_ALL\t0x003f0000\n\n#define KEY_GRP_VIEW\t0x00000100\t \n#define KEY_GRP_READ\t0x00000200\n#define KEY_GRP_WRITE\t0x00000400\n#define KEY_GRP_SEARCH\t0x00000800\n#define KEY_GRP_LINK\t0x00001000\n#define KEY_GRP_SETATTR\t0x00002000\n#define KEY_GRP_ALL\t0x00003f00\n\n#define KEY_OTH_VIEW\t0x00000001\t \n#define KEY_OTH_READ\t0x00000002\n#define KEY_OTH_WRITE\t0x00000004\n#define KEY_OTH_SEARCH\t0x00000008\n#define KEY_OTH_LINK\t0x00000010\n#define KEY_OTH_SETATTR\t0x00000020\n#define KEY_OTH_ALL\t0x0000003f\n\n#define KEY_PERM_UNDEF\t0xffffffff\n\n \nenum key_need_perm {\n\tKEY_NEED_UNSPECIFIED,\t \n\tKEY_NEED_VIEW,\t\t \n\tKEY_NEED_READ,\t\t \n\tKEY_NEED_WRITE,\t\t \n\tKEY_NEED_SEARCH,\t \n\tKEY_NEED_LINK,\t\t \n\tKEY_NEED_SETATTR,\t \n\tKEY_NEED_UNLINK,\t \n\tKEY_SYSADMIN_OVERRIDE,\t \n\tKEY_AUTHTOKEN_OVERRIDE,\t \n\tKEY_DEFER_PERM_CHECK,\t \n};\n\nenum key_lookup_flag {\n\tKEY_LOOKUP_CREATE = 0x01,\n\tKEY_LOOKUP_PARTIAL = 0x02,\n\tKEY_LOOKUP_ALL = (KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL),\n};\n\nstruct seq_file;\nstruct user_struct;\nstruct signal_struct;\nstruct cred;\n\nstruct key_type;\nstruct key_owner;\nstruct key_tag;\nstruct keyring_list;\nstruct keyring_name;\n\nstruct key_tag {\n\tstruct rcu_head\t\trcu;\n\trefcount_t\t\tusage;\n\tbool\t\t\tremoved;\t \n};\n\nstruct keyring_index_key {\n\t \n\tunsigned long\t\thash;\t\t\t \n\tunion {\n\t\tstruct {\n#ifdef __LITTLE_ENDIAN  \n\t\t\tu16\tdesc_len;\n\t\t\tchar\tdesc[sizeof(long) - 2];\t \n#else\n\t\t\tchar\tdesc[sizeof(long) - 2];\t \n\t\t\tu16\tdesc_len;\n#endif\n\t\t};\n\t\tunsigned long x;\n\t};\n\tstruct key_type\t\t*type;\n\tstruct key_tag\t\t*domain_tag;\t \n\tconst char\t\t*description;\n};\n\nunion key_payload {\n\tvoid __rcu\t\t*rcu_data0;\n\tvoid\t\t\t*data[4];\n};\n\n \n \ntypedef struct __key_reference_with_attributes *key_ref_t;\n\nstatic inline key_ref_t make_key_ref(const struct key *key,\n\t\t\t\t     bool possession)\n{\n\treturn (key_ref_t) ((unsigned long) key | possession);\n}\n\nstatic inline struct key *key_ref_to_ptr(const key_ref_t key_ref)\n{\n\treturn (struct key *) ((unsigned long) key_ref & ~1UL);\n}\n\nstatic inline bool is_key_possessed(const key_ref_t key_ref)\n{\n\treturn (unsigned long) key_ref & 1UL;\n}\n\ntypedef int (*key_restrict_link_func_t)(struct key *dest_keyring,\n\t\t\t\t\tconst struct key_type *type,\n\t\t\t\t\tconst union key_payload *payload,\n\t\t\t\t\tstruct key *restriction_key);\n\nstruct key_restriction {\n\tkey_restrict_link_func_t check;\n\tstruct key *key;\n\tstruct key_type *keytype;\n};\n\nenum key_state {\n\tKEY_IS_UNINSTANTIATED,\n\tKEY_IS_POSITIVE,\t\t \n};\n\n \n \nstruct key {\n\trefcount_t\t\tusage;\t\t \n\tkey_serial_t\t\tserial;\t\t \n\tunion {\n\t\tstruct list_head graveyard_link;\n\t\tstruct rb_node\tserial_node;\n\t};\n#ifdef CONFIG_KEY_NOTIFICATIONS\n\tstruct watch_list\t*watchers;\t \n#endif\n\tstruct rw_semaphore\tsem;\t\t \n\tstruct key_user\t\t*user;\t\t \n\tvoid\t\t\t*security;\t \n\tunion {\n\t\ttime64_t\texpiry;\t\t \n\t\ttime64_t\trevoked_at;\t \n\t};\n\ttime64_t\t\tlast_used_at;\t \n\tkuid_t\t\t\tuid;\n\tkgid_t\t\t\tgid;\n\tkey_perm_t\t\tperm;\t\t \n\tunsigned short\t\tquotalen;\t \n\tunsigned short\t\tdatalen;\t \n\tshort\t\t\tstate;\t\t \n\n#ifdef KEY_DEBUGGING\n\tunsigned\t\tmagic;\n#define KEY_DEBUG_MAGIC\t\t0x18273645u\n#endif\n\n\tunsigned long\t\tflags;\t\t \n#define KEY_FLAG_DEAD\t\t0\t \n#define KEY_FLAG_REVOKED\t1\t \n#define KEY_FLAG_IN_QUOTA\t2\t \n#define KEY_FLAG_USER_CONSTRUCT\t3\t \n#define KEY_FLAG_ROOT_CAN_CLEAR\t4\t \n#define KEY_FLAG_INVALIDATED\t5\t \n#define KEY_FLAG_BUILTIN\t6\t \n#define KEY_FLAG_ROOT_CAN_INVAL\t7\t \n#define KEY_FLAG_KEEP\t\t8\t \n#define KEY_FLAG_UID_KEYRING\t9\t \n\n\t \n\tunion {\n\t\tstruct keyring_index_key index_key;\n\t\tstruct {\n\t\t\tunsigned long\thash;\n\t\t\tunsigned long\tlen_desc;\n\t\t\tstruct key_type\t*type;\t\t \n\t\t\tstruct key_tag\t*domain_tag;\t \n\t\t\tchar\t\t*description;\n\t\t};\n\t};\n\n\t \n\tunion {\n\t\tunion key_payload payload;\n\t\tstruct {\n\t\t\t \n\t\t\tstruct list_head name_link;\n\t\t\tstruct assoc_array keys;\n\t\t};\n\t};\n\n\t \n\tstruct key_restriction *restrict_link;\n};\n\nextern struct key *key_alloc(struct key_type *type,\n\t\t\t     const char *desc,\n\t\t\t     kuid_t uid, kgid_t gid,\n\t\t\t     const struct cred *cred,\n\t\t\t     key_perm_t perm,\n\t\t\t     unsigned long flags,\n\t\t\t     struct key_restriction *restrict_link);\n\n\n#define KEY_ALLOC_IN_QUOTA\t\t0x0000\t \n#define KEY_ALLOC_QUOTA_OVERRUN\t\t0x0001\t \n#define KEY_ALLOC_NOT_IN_QUOTA\t\t0x0002\t \n#define KEY_ALLOC_BUILT_IN\t\t0x0004\t \n#define KEY_ALLOC_BYPASS_RESTRICTION\t0x0008\t \n#define KEY_ALLOC_UID_KEYRING\t\t0x0010\t \n#define KEY_ALLOC_SET_KEEP\t\t0x0020\t \n\nextern void key_revoke(struct key *key);\nextern void key_invalidate(struct key *key);\nextern void key_put(struct key *key);\nextern bool key_put_tag(struct key_tag *tag);\nextern void key_remove_domain(struct key_tag *domain_tag);\n\nstatic inline struct key *__key_get(struct key *key)\n{\n\trefcount_inc(&key->usage);\n\treturn key;\n}\n\nstatic inline struct key *key_get(struct key *key)\n{\n\treturn key ? __key_get(key) : key;\n}\n\nstatic inline void key_ref_put(key_ref_t key_ref)\n{\n\tkey_put(key_ref_to_ptr(key_ref));\n}\n\nextern struct key *request_key_tag(struct key_type *type,\n\t\t\t\t   const char *description,\n\t\t\t\t   struct key_tag *domain_tag,\n\t\t\t\t   const char *callout_info);\n\nextern struct key *request_key_rcu(struct key_type *type,\n\t\t\t\t   const char *description,\n\t\t\t\t   struct key_tag *domain_tag);\n\nextern struct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t\t    const char *description,\n\t\t\t\t\t    struct key_tag *domain_tag,\n\t\t\t\t\t    const void *callout_info,\n\t\t\t\t\t    size_t callout_len,\n\t\t\t\t\t    void *aux);\n\n \nstatic inline struct key *request_key(struct key_type *type,\n\t\t\t\t      const char *description,\n\t\t\t\t      const char *callout_info)\n{\n\treturn request_key_tag(type, description, NULL, callout_info);\n}\n\n#ifdef CONFIG_NET\n \n#define request_key_net(type, description, net, callout_info) \\\n\trequest_key_tag(type, description, net->key_domain, callout_info)\n\n \n#define request_key_net_rcu(type, description, net) \\\n\trequest_key_rcu(type, description, net->key_domain)\n#endif  \n\nextern int wait_for_key_construction(struct key *key, bool intr);\n\nextern int key_validate(const struct key *key);\n\nextern key_ref_t key_create(key_ref_t keyring,\n\t\t\t    const char *type,\n\t\t\t    const char *description,\n\t\t\t    const void *payload,\n\t\t\t    size_t plen,\n\t\t\t    key_perm_t perm,\n\t\t\t    unsigned long flags);\n\nextern key_ref_t key_create_or_update(key_ref_t keyring,\n\t\t\t\t      const char *type,\n\t\t\t\t      const char *description,\n\t\t\t\t      const void *payload,\n\t\t\t\t      size_t plen,\n\t\t\t\t      key_perm_t perm,\n\t\t\t\t      unsigned long flags);\n\nextern int key_update(key_ref_t key,\n\t\t      const void *payload,\n\t\t      size_t plen);\n\nextern int key_link(struct key *keyring,\n\t\t    struct key *key);\n\nextern int key_move(struct key *key,\n\t\t    struct key *from_keyring,\n\t\t    struct key *to_keyring,\n\t\t    unsigned int flags);\n\nextern int key_unlink(struct key *keyring,\n\t\t      struct key *key);\n\nextern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t\t const struct cred *cred,\n\t\t\t\t key_perm_t perm,\n\t\t\t\t unsigned long flags,\n\t\t\t\t struct key_restriction *restrict_link,\n\t\t\t\t struct key *dest);\n\nextern int restrict_link_reject(struct key *keyring,\n\t\t\t\tconst struct key_type *type,\n\t\t\t\tconst union key_payload *payload,\n\t\t\t\tstruct key *restriction_key);\n\nextern int keyring_clear(struct key *keyring);\n\nextern key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t\tstruct key_type *type,\n\t\t\t\tconst char *description,\n\t\t\t\tbool recurse);\n\nextern int keyring_add_key(struct key *keyring,\n\t\t\t   struct key *key);\n\nextern int keyring_restrict(key_ref_t keyring, const char *type,\n\t\t\t    const char *restriction);\n\nextern struct key *key_lookup(key_serial_t id);\n\nstatic inline key_serial_t key_serial(const struct key *key)\n{\n\treturn key ? key->serial : 0;\n}\n\nextern void key_set_timeout(struct key *, unsigned);\n\nextern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,\n\t\t\t\t enum key_need_perm need_perm);\nextern void key_free_user_ns(struct user_namespace *);\n\nstatic inline short key_read_state(const struct key *key)\n{\n\t \n\treturn smp_load_acquire(&key->state);\n}\n\n \nstatic inline bool key_is_positive(const struct key *key)\n{\n\treturn key_read_state(key) == KEY_IS_POSITIVE;\n}\n\nstatic inline bool key_is_negative(const struct key *key)\n{\n\treturn key_read_state(key) < 0;\n}\n\n#define dereference_key_rcu(KEY)\t\t\t\t\t\\\n\t(rcu_dereference((KEY)->payload.rcu_data0))\n\n#define dereference_key_locked(KEY)\t\t\t\t\t\\\n\t(rcu_dereference_protected((KEY)->payload.rcu_data0,\t\t\\\n\t\t\t\t   rwsem_is_locked(&((struct key *)(KEY))->sem)))\n\n#define rcu_assign_keypointer(KEY, PAYLOAD)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\trcu_assign_pointer((KEY)->payload.rcu_data0, (PAYLOAD));\t\\\n} while (0)\n\n \nextern int install_thread_keyring_to_cred(struct cred *cred);\nextern void key_fsuid_changed(struct cred *new_cred);\nextern void key_fsgid_changed(struct cred *new_cred);\nextern void key_init(void);\n\n#else  \n\n#define key_validate(k)\t\t\t0\n#define key_serial(k)\t\t\t0\n#define key_get(k) \t\t\t({ NULL; })\n#define key_revoke(k)\t\t\tdo { } while(0)\n#define key_invalidate(k)\t\tdo { } while(0)\n#define key_put(k)\t\t\tdo { } while(0)\n#define key_ref_put(k)\t\t\tdo { } while(0)\n#define make_key_ref(k, p)\t\tNULL\n#define key_ref_to_ptr(k)\t\tNULL\n#define is_key_possessed(k)\t\t0\n#define key_fsuid_changed(c)\t\tdo { } while(0)\n#define key_fsgid_changed(c)\t\tdo { } while(0)\n#define key_init()\t\t\tdo { } while(0)\n#define key_free_user_ns(ns)\t\tdo { } while(0)\n#define key_remove_domain(d)\t\tdo { } while(0)\n\n#endif  \n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}