{
  "module_name": "genl_magic_func.h",
  "hash_id": "4b7ded185db2d7cd3d23748f2b27b432435ad360a2ac8e59d4981aa3de395727",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/genl_magic_func.h",
  "human_readable_source": " \n#ifndef GENL_MAGIC_FUNC_H\n#define GENL_MAGIC_FUNC_H\n\n#include <linux/args.h>\n#include <linux/build_bug.h>\n#include <linux/genl_magic_struct.h>\n\n \n#undef GENL_mc_group\n#define GENL_mc_group(group)\n\n#undef GENL_notification\n#define GENL_notification(op_name, op_num, mcast_group, tla_list)\n\n#undef GENL_op\n#define GENL_op(op_name, op_num, handler, tla_list)\n\n#undef GENL_struct\n#define GENL_struct(tag_name, tag_number, s_name, s_fields)\t\t\\\n\t[tag_name] = { .type = NLA_NESTED },\n\nstatic struct nla_policy CONCATENATE(GENL_MAGIC_FAMILY, _tla_nl_policy)[] = {\n#include GENL_MAGIC_INCLUDE_FILE\n};\n\n#undef GENL_struct\n#define GENL_struct(tag_name, tag_number, s_name, s_fields)\t\t\\\nstatic struct nla_policy s_name ## _nl_policy[] __read_mostly =\t\t\\\n{ s_fields };\n\n#undef __field\n#define __field(attr_nr, attr_flag, name, nla_type, _type, __get,\t\\\n\t\t __put, __is_signed)\t\t\t\t\t\\\n\t[attr_nr] = { .type = nla_type },\n\n#undef __array\n#define __array(attr_nr, attr_flag, name, nla_type, _type, maxlen,\t\\\n\t\t__get, __put, __is_signed)\t\t\t\t\\\n\t[attr_nr] = { .type = nla_type,\t\t\t\t\t\\\n\t\t      .len = maxlen - (nla_type == NLA_NUL_STRING) },\n\n#include GENL_MAGIC_INCLUDE_FILE\n\n#ifndef __KERNEL__\n#ifndef pr_info\n#define pr_info(args...)\tfprintf(stderr, args);\n#endif\n#endif\n\n#ifdef GENL_MAGIC_DEBUG\nstatic void dprint_field(const char *dir, int nla_type,\n\t\tconst char *name, void *valp)\n{\n\t__u64 val = valp ? *(__u32 *)valp : 1;\n\tswitch (nla_type) {\n\tcase NLA_U8:  val = (__u8)val;\n\tcase NLA_U16: val = (__u16)val;\n\tcase NLA_U32: val = (__u32)val;\n\t\tpr_info(\"%s attr %s: %d 0x%08x\\n\", dir,\n\t\t\tname, (int)val, (unsigned)val);\n\t\tbreak;\n\tcase NLA_U64:\n\t\tval = *(__u64*)valp;\n\t\tpr_info(\"%s attr %s: %lld 0x%08llx\\n\", dir,\n\t\t\tname, (long long)val, (unsigned long long)val);\n\t\tbreak;\n\tcase NLA_FLAG:\n\t\tif (val)\n\t\t\tpr_info(\"%s attr %s: set\\n\", dir, name);\n\t\tbreak;\n\t}\n}\n\nstatic void dprint_array(const char *dir, int nla_type,\n\t\tconst char *name, const char *val, unsigned len)\n{\n\tswitch (nla_type) {\n\tcase NLA_NUL_STRING:\n\t\tif (len && val[len-1] == '\\0')\n\t\t\tlen--;\n\t\tpr_info(\"%s attr %s: [len:%u] '%s'\\n\", dir, name, len, val);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tpr_info(\"%s attr %s: [len:%u] %02x%02x%02x%02x ...\\n\",\n\t\t\tdir, name, len, val[0], val[1], val[2], val[3]);\n\t}\n}\n\n#define DPRINT_TLA(a, op, b) pr_info(\"%s %s %s\\n\", a, op, b);\n\n \n#define DPRINT_FIELD(dir, nla_type, name, s, nla)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (s)\t\t\t\t\t\t\t\\\n\t\t\tdprint_field(dir, nla_type, #name, &s->name);\t\\\n\t\telse if (nla)\t\t\t\t\t\t\\\n\t\t\tdprint_field(dir, nla_type, #name,\t\t\\\n\t\t\t\t(nla_type == NLA_FLAG) ? NULL\t\t\\\n\t\t\t\t\t\t: nla_data(nla));\t\\\n\t} while (0)\n\n#define\tDPRINT_ARRAY(dir, nla_type, name, s, nla)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (s)\t\t\t\t\t\t\t\\\n\t\t\tdprint_array(dir, nla_type, #name,\t\t\\\n\t\t\t\t\ts->name, s->name ## _len);\t\\\n\t\telse if (nla)\t\t\t\t\t\t\\\n\t\t\tdprint_array(dir, nla_type, #name,\t\t\\\n\t\t\t\t\tnla_data(nla), nla_len(nla));\t\\\n\t} while (0)\n#else\n#define DPRINT_TLA(a, op, b) do {} while (0)\n#define DPRINT_FIELD(dir, nla_type, name, s, nla) do {} while (0)\n#define\tDPRINT_ARRAY(dir, nla_type, name, s, nla) do {} while (0)\n#endif\n\n \n\n \nstatic struct nlattr *nested_attr_tb[128];\n\n#undef GENL_struct\n#define GENL_struct(tag_name, tag_number, s_name, s_fields)\t\t\\\n \t\t\\\nstatic int __ ## s_name ## _from_attrs(struct s_name *s,\t\t\\\n\t\tstruct genl_info *info, bool exclude_invariants)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tconst int maxtype = ARRAY_SIZE(s_name ## _nl_policy)-1;\t\t\\\n\tstruct nlattr *tla = info->attrs[tag_number];\t\t\t\\\n\tstruct nlattr **ntb = nested_attr_tb;\t\t\t\t\\\n\tstruct nlattr *nla;\t\t\t\t\t\t\\\n\tint err;\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(ARRAY_SIZE(s_name ## _nl_policy) > ARRAY_SIZE(nested_attr_tb));\t\\\n\tif (!tla)\t\t\t\t\t\t\t\\\n\t\treturn -ENOMSG;\t\t\t\t\t\t\\\n\tDPRINT_TLA(#s_name, \"<=-\", #tag_name);\t\t\t\t\\\n\terr = drbd_nla_parse_nested(ntb, maxtype, tla, s_name ## _nl_policy);\t\\\n\tif (err)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ts_fields\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t__attribute__((unused))\t\t\\\nstatic int s_name ## _from_attrs(struct s_name *s,\t\t\t\\\n\t\t\t\t\t\tstruct genl_info *info)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn __ ## s_name ## _from_attrs(s, info, false);\t\t\\\n}\t\t\t\t\t__attribute__((unused))\t\t\\\nstatic int s_name ## _from_attrs_for_change(struct s_name *s,\t\t\\\n\t\t\t\t\t\tstruct genl_info *info)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn __ ## s_name ## _from_attrs(s, info, true);\t\t\\\n}\t\t\t\t\t__attribute__((unused))\t\t\\\n\n#define __assign(attr_nr, attr_flag, name, nla_type, type, assignment...)\t\\\n\t\tnla = ntb[attr_nr];\t\t\t\t\t\t\\\n\t\tif (nla) {\t\t\t\t\t\t\\\n\t\t\tif (exclude_invariants && !!((attr_flag) & DRBD_F_INVARIANT)) {\t\t\\\n\t\t\t\tpr_info(\"<< must not change invariant attr: %s\\n\", #name);\t\\\n\t\t\t\treturn -EEXIST;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tassignment;\t\t\t\t\t\\\n\t\t} else if (exclude_invariants && !!((attr_flag) & DRBD_F_INVARIANT)) {\t\t\\\n\t\t\t \t\t\\\n\t\t\t \t\t\t\\\n\t\t} else if ((attr_flag) & DRBD_F_REQUIRED) {\t\t\\\n\t\t\tpr_info(\"<< missing attr: %s\\n\", #name);\t\\\n\t\t\treturn -ENOMSG;\t\t\t\t\t\\\n\t\t}\n\n#undef __field\n#define __field(attr_nr, attr_flag, name, nla_type, type, __get, __put,\t\\\n\t\t__is_signed)\t\t\t\t\t\t\\\n\t__assign(attr_nr, attr_flag, name, nla_type, type,\t\t\\\n\t\t\tif (s)\t\t\t\t\t\t\\\n\t\t\t\ts->name = __get(nla);\t\t\t\\\n\t\t\tDPRINT_FIELD(\"<<\", nla_type, name, s, nla))\n\n \n#undef __array\n#define __array(attr_nr, attr_flag, name, nla_type, type, maxlen,\t\\\n\t\t__get, __put, __is_signed)\t\t\t\t\\\n\t__assign(attr_nr, attr_flag, name, nla_type, type,\t\t\\\n\t\t\tif (s)\t\t\t\t\t\t\\\n\t\t\t\ts->name ## _len =\t\t\t\\\n\t\t\t\t\t__get(s->name, nla, maxlen);\t\\\n\t\t\tDPRINT_ARRAY(\"<<\", nla_type, name, s, nla))\n\n#include GENL_MAGIC_INCLUDE_FILE\n\n#undef GENL_struct\n#define GENL_struct(tag_name, tag_number, s_name, s_fields)\n\n \nstatic const char *CONCATENATE(GENL_MAGIC_FAMILY, _genl_cmd_to_str)(__u8 cmd)\n{\n\tswitch (cmd) {\n#undef GENL_op\n#define GENL_op(op_name, op_num, handler, tla_list)\t\t\\\n\tcase op_num: return #op_name;\n#include GENL_MAGIC_INCLUDE_FILE\n\tdefault:\n\t\t     return \"unknown\";\n\t}\n}\n\n#ifdef __KERNEL__\n#include <linux/stringify.h>\n \n\n#undef GENL_op\n#define GENL_op(op_name, op_num, handler, tla_list)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\thandler\t\t\t\t\t\t\t\\\n\t.cmd = op_name,\t\t\t\t\t\t\\\n},\n\n#define ZZZ_genl_ops\t\tCONCATENATE(GENL_MAGIC_FAMILY, _genl_ops)\nstatic struct genl_ops ZZZ_genl_ops[] __read_mostly = {\n#include GENL_MAGIC_INCLUDE_FILE\n};\n\n#undef GENL_op\n#define GENL_op(op_name, op_num, handler, tla_list)\n\n \n#define ZZZ_genl_family\t\tCONCATENATE(GENL_MAGIC_FAMILY, _genl_family)\nstatic struct genl_family ZZZ_genl_family;\n \n#define ZZZ_genl_mcgrps\t\tCONCATENATE(GENL_MAGIC_FAMILY, _genl_mcgrps)\nstatic const struct genl_multicast_group ZZZ_genl_mcgrps[] = {\n#undef GENL_mc_group\n#define GENL_mc_group(group) { .name = #group, },\n#include GENL_MAGIC_INCLUDE_FILE\n};\n\nenum CONCATENATE(GENL_MAGIC_FAMILY, group_ids) {\n#undef GENL_mc_group\n#define GENL_mc_group(group) CONCATENATE(GENL_MAGIC_FAMILY, _group_ ## group),\n#include GENL_MAGIC_INCLUDE_FILE\n};\n\n#undef GENL_mc_group\n#define GENL_mc_group(group)\t\t\t\t\t\t\\\nstatic int CONCATENATE(GENL_MAGIC_FAMILY, _genl_multicast_ ## group)(\t\\\n\tstruct sk_buff *skb, gfp_t flags)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned int group_id =\t\t\t\t\t\t\\\n\t\tCONCATENATE(GENL_MAGIC_FAMILY, _group_ ## group);\t\t\\\n\treturn genlmsg_multicast(&ZZZ_genl_family, skb, 0,\t\t\\\n\t\t\t\t group_id, flags);\t\t\t\\\n}\n\n#include GENL_MAGIC_INCLUDE_FILE\n\n#undef GENL_mc_group\n#define GENL_mc_group(group)\n\nstatic struct genl_family ZZZ_genl_family __ro_after_init = {\n\t.name = __stringify(GENL_MAGIC_FAMILY),\n\t.version = GENL_MAGIC_VERSION,\n#ifdef GENL_MAGIC_FAMILY_HDRSZ\n\t.hdrsize = NLA_ALIGN(GENL_MAGIC_FAMILY_HDRSZ),\n#endif\n\t.maxattr = ARRAY_SIZE(CONCATENATE(GENL_MAGIC_FAMILY, _tla_nl_policy))-1,\n\t.policy\t= CONCATENATE(GENL_MAGIC_FAMILY, _tla_nl_policy),\n\t.ops = ZZZ_genl_ops,\n\t.n_ops = ARRAY_SIZE(ZZZ_genl_ops),\n\t.mcgrps = ZZZ_genl_mcgrps,\n\t.resv_start_op = 42,  \n\t.n_mcgrps = ARRAY_SIZE(ZZZ_genl_mcgrps),\n\t.module = THIS_MODULE,\n};\n\nint CONCATENATE(GENL_MAGIC_FAMILY, _genl_register)(void)\n{\n\treturn genl_register_family(&ZZZ_genl_family);\n}\n\nvoid CONCATENATE(GENL_MAGIC_FAMILY, _genl_unregister)(void)\n{\n\tgenl_unregister_family(&ZZZ_genl_family);\n}\n\n \n\n#undef GENL_op\n#define GENL_op(op_name, op_num, handler, tla_list)\n\n#undef GENL_struct\n#define GENL_struct(tag_name, tag_number, s_name, s_fields)\t\t\\\nstatic int s_name ## _to_skb(struct sk_buff *skb, struct s_name *s,\t\\\n\t\tconst bool exclude_sensitive)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct nlattr *tla = nla_nest_start(skb, tag_number);\t\t\\\n\tif (!tla)\t\t\t\t\t\t\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\tDPRINT_TLA(#s_name, \"-=>\", #tag_name);\t\t\t\t\\\n\ts_fields\t\t\t\t\t\t\t\\\n\tnla_nest_end(skb, tla);\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nnla_put_failure:\t\t\t\t\t\t\t\\\n\tif (tla)\t\t\t\t\t\t\t\\\n\t\tnla_nest_cancel(skb, tla);\t\t\t\t\\\n        return -EMSGSIZE;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline int s_name ## _to_priv_skb(struct sk_buff *skb,\t\t\\\n\t\tstruct s_name *s)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn s_name ## _to_skb(skb, s, 0);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline int s_name ## _to_unpriv_skb(struct sk_buff *skb,\t\t\\\n\t\tstruct s_name *s)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn s_name ## _to_skb(skb, s, 1);\t\t\t\t\\\n}\n\n\n#undef __field\n#define __field(attr_nr, attr_flag, name, nla_type, type, __get, __put,\t\\\n\t\t__is_signed)\t\t\t\t\t\t\\\n\tif (!exclude_sensitive || !((attr_flag) & DRBD_F_SENSITIVE)) {\t\\\n\t\tDPRINT_FIELD(\">>\", nla_type, name, s, NULL);\t\t\\\n\t\tif (__put(skb, attr_nr, s->name))\t\t\t\\\n\t\t\tgoto nla_put_failure;\t\t\t\t\\\n\t}\n\n#undef __array\n#define __array(attr_nr, attr_flag, name, nla_type, type, maxlen,\t\\\n\t\t__get, __put, __is_signed)\t\t\t\t\\\n\tif (!exclude_sensitive || !((attr_flag) & DRBD_F_SENSITIVE)) {\t\\\n\t\tDPRINT_ARRAY(\">>\",nla_type, name, s, NULL);\t\t\\\n\t\tif (__put(skb, attr_nr, min_t(int, maxlen,\t\t\\\n\t\t\ts->name ## _len + (nla_type == NLA_NUL_STRING)),\\\n\t\t\t\t\t\ts->name))\t\t\\\n\t\t\tgoto nla_put_failure;\t\t\t\t\\\n\t}\n\n#include GENL_MAGIC_INCLUDE_FILE\n\n\n \n\n#undef __field\n#define __field(attr_nr, attr_flag, name, nla_type, type, __get, __put,\t\\\n\t\t__is_signed)\n#undef __array\n#define __array(attr_nr, attr_flag, name, nla_type, type, maxlen,\t\\\n\t\t__get, __put, __is_signed)\n#undef __u32_field_def\n#define __u32_field_def(attr_nr, attr_flag, name, default)\t\t\\\n\tx->name = default;\n#undef __s32_field_def\n#define __s32_field_def(attr_nr, attr_flag, name, default)\t\t\\\n\tx->name = default;\n#undef __flg_field_def\n#define __flg_field_def(attr_nr, attr_flag, name, default)\t\t\\\n\tx->name = default;\n#undef __str_field_def\n#define __str_field_def(attr_nr, attr_flag, name, maxlen)\t\t\\\n\tmemset(x->name, 0, sizeof(x->name));\t\t\t\t\\\n\tx->name ## _len = 0;\n#undef GENL_struct\n#define GENL_struct(tag_name, tag_number, s_name, s_fields)\t\t\\\nstatic void set_ ## s_name ## _defaults(struct s_name *x) __attribute__((unused)); \\\nstatic void set_ ## s_name ## _defaults(struct s_name *x) {\t\\\ns_fields\t\t\t\t\t\t\t\t\\\n}\n\n#include GENL_MAGIC_INCLUDE_FILE\n\n#endif  \n\n \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}