{
  "module_name": "netlink.h",
  "hash_id": "8dcf6bfd57256d7f0017bf0314fd93a4e68e1b148e836f4b87ee8778e7e67840",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/netlink.h",
  "human_readable_source": " \n#ifndef __LINUX_NETLINK_H\n#define __LINUX_NETLINK_H\n\n\n#include <linux/capability.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <net/scm.h>\n#include <uapi/linux/netlink.h>\n\nstruct net;\n\nvoid do_trace_netlink_extack(const char *msg);\n\nstatic inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)\n{\n\treturn (struct nlmsghdr *)skb->data;\n}\n\nenum netlink_skb_flags {\n\tNETLINK_SKB_DST\t\t= 0x8,\t \n};\n\nstruct netlink_skb_parms {\n\tstruct scm_creds\tcreds;\t\t \n\t__u32\t\t\tportid;\n\t__u32\t\t\tdst_group;\n\t__u32\t\t\tflags;\n\tstruct sock\t\t*sk;\n\tbool\t\t\tnsid_is_set;\n\tint\t\t\tnsid;\n};\n\n#define NETLINK_CB(skb)\t\t(*(struct netlink_skb_parms*)&((skb)->cb))\n#define NETLINK_CREDS(skb)\t(&NETLINK_CB((skb)).creds)\n\n\nvoid netlink_table_grab(void);\nvoid netlink_table_ungrab(void);\n\n#define NL_CFG_F_NONROOT_RECV\t(1 << 0)\n#define NL_CFG_F_NONROOT_SEND\t(1 << 1)\n\n \nstruct netlink_kernel_cfg {\n\tunsigned int\tgroups;\n\tunsigned int\tflags;\n\tvoid\t\t(*input)(struct sk_buff *skb);\n\tstruct mutex\t*cb_mutex;\n\tint\t\t(*bind)(struct net *net, int group);\n\tvoid\t\t(*unbind)(struct net *net, int group);\n\tvoid            (*release) (struct sock *sk, unsigned long *groups);\n};\n\nstruct sock *__netlink_kernel_create(struct net *net, int unit,\n\t\t\t\t\t    struct module *module,\n\t\t\t\t\t    struct netlink_kernel_cfg *cfg);\nstatic inline struct sock *\nnetlink_kernel_create(struct net *net, int unit, struct netlink_kernel_cfg *cfg)\n{\n\treturn __netlink_kernel_create(net, unit, THIS_MODULE, cfg);\n}\n\n \n#define NETLINK_MAX_COOKIE_LEN\t20\n#define NETLINK_MAX_FMTMSG_LEN\t80\n\n \nstruct netlink_ext_ack {\n\tconst char *_msg;\n\tconst struct nlattr *bad_attr;\n\tconst struct nla_policy *policy;\n\tconst struct nlattr *miss_nest;\n\tu16 miss_type;\n\tu8 cookie[NETLINK_MAX_COOKIE_LEN];\n\tu8 cookie_len;\n\tchar _msg_buf[NETLINK_MAX_FMTMSG_LEN];\n};\n\n \n#define NL_SET_ERR_MSG(extack, msg) do {\t\t\\\n\tstatic const char __msg[] = msg;\t\t\\\n\tstruct netlink_ext_ack *__extack = (extack);\t\\\n\t\t\t\t\t\t\t\\\n\tdo_trace_netlink_extack(__msg);\t\t\t\\\n\t\t\t\t\t\t\t\\\n\tif (__extack)\t\t\t\t\t\\\n\t\t__extack->_msg = __msg;\t\t\t\\\n} while (0)\n\n \n#define NL_SET_ERR_MSG_FMT(extack, fmt, args...) do {\t\t\t       \\\n\tstruct netlink_ext_ack *__extack = (extack);\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\tif (!__extack)\t\t\t\t\t\t\t       \\\n\t\tbreak;\t\t\t\t\t\t\t       \\\n\tif (snprintf(__extack->_msg_buf, NETLINK_MAX_FMTMSG_LEN,\t       \\\n\t\t     \"%s\" fmt \"%s\", \"\", ##args, \"\") >=\t\t\t       \\\n\t    NETLINK_MAX_FMTMSG_LEN)\t\t\t\t\t       \\\n\t\tnet_warn_ratelimited(\"%s\" fmt \"%s\", \"truncated extack: \",      \\\n\t\t\t\t     ##args, \"\\n\");\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\tdo_trace_netlink_extack(__extack->_msg_buf);\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t__extack->_msg = __extack->_msg_buf;\t\t\t\t       \\\n} while (0)\n\n#define NL_SET_ERR_MSG_MOD(extack, msg)\t\t\t\\\n\tNL_SET_ERR_MSG((extack), KBUILD_MODNAME \": \" msg)\n\n#define NL_SET_ERR_MSG_FMT_MOD(extack, fmt, args...)\t\\\n\tNL_SET_ERR_MSG_FMT((extack), KBUILD_MODNAME \": \" fmt, ##args)\n\n#define NL_SET_ERR_MSG_WEAK(extack, msg) do {\t\t\\\n\tif ((extack) && !(extack)->_msg)\t\t\\\n\t\tNL_SET_ERR_MSG((extack), msg);\t\t\\\n} while (0)\n\n#define NL_SET_ERR_MSG_WEAK_MOD(extack, msg) do {\t\\\n\tif ((extack) && !(extack)->_msg)\t\t\\\n\t\tNL_SET_ERR_MSG_MOD((extack), msg);\t\\\n} while (0)\n\n#define NL_SET_BAD_ATTR_POLICY(extack, attr, pol) do {\t\\\n\tif ((extack)) {\t\t\t\t\t\\\n\t\t(extack)->bad_attr = (attr);\t\t\\\n\t\t(extack)->policy = (pol);\t\t\\\n\t}\t\t\t\t\t\t\\\n} while (0)\n\n#define NL_SET_BAD_ATTR(extack, attr) NL_SET_BAD_ATTR_POLICY(extack, attr, NULL)\n\n#define NL_SET_ERR_MSG_ATTR_POL(extack, attr, pol, msg) do {\t\\\n\tstatic const char __msg[] = msg;\t\t\t\\\n\tstruct netlink_ext_ack *__extack = (extack);\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tdo_trace_netlink_extack(__msg);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (__extack) {\t\t\t\t\t\t\\\n\t\t__extack->_msg = __msg;\t\t\t\t\\\n\t\t__extack->bad_attr = (attr);\t\t\t\\\n\t\t__extack->policy = (pol);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n} while (0)\n\n#define NL_SET_ERR_MSG_ATTR_POL_FMT(extack, attr, pol, fmt, args...) do {\t\\\n\tstruct netlink_ext_ack *__extack = (extack);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (!__extack)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (snprintf(__extack->_msg_buf, NETLINK_MAX_FMTMSG_LEN,\t\t\\\n\t\t     \"%s\" fmt \"%s\", \"\", ##args, \"\") >=\t\t\t\t\\\n\t    NETLINK_MAX_FMTMSG_LEN)\t\t\t\t\t\t\\\n\t\tnet_warn_ratelimited(\"%s\" fmt \"%s\", \"truncated extack: \",       \\\n\t\t\t\t     ##args, \"\\n\");\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tdo_trace_netlink_extack(__extack->_msg_buf);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t__extack->_msg = __extack->_msg_buf;\t\t\t\t\t\\\n\t__extack->bad_attr = (attr);\t\t\t\t\t\t\\\n\t__extack->policy = (pol);\t\t\t\t\t\t\\\n} while (0)\n\n#define NL_SET_ERR_MSG_ATTR(extack, attr, msg)\t\t\\\n\tNL_SET_ERR_MSG_ATTR_POL(extack, attr, NULL, msg)\n\n#define NL_SET_ERR_MSG_ATTR_FMT(extack, attr, msg, args...) \\\n\tNL_SET_ERR_MSG_ATTR_POL_FMT(extack, attr, NULL, msg, ##args)\n\n#define NL_SET_ERR_ATTR_MISS(extack, nest, type)  do {\t\\\n\tstruct netlink_ext_ack *__extack = (extack);\t\\\n\t\t\t\t\t\t\t\\\n\tif (__extack) {\t\t\t\t\t\\\n\t\t__extack->miss_nest = (nest);\t\t\\\n\t\t__extack->miss_type = (type);\t\t\\\n\t}\t\t\t\t\t\t\\\n} while (0)\n\n#define NL_REQ_ATTR_CHECK(extack, nest, tb, type) ({\t\t\\\n\tstruct nlattr **__tb = (tb);\t\t\t\t\\\n\tu32 __attr = (type);\t\t\t\t\t\\\n\tint __retval;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t__retval = !__tb[__attr];\t\t\t\t\\\n\tif (__retval)\t\t\t\t\t\t\\\n\t\tNL_SET_ERR_ATTR_MISS((extack), (nest), __attr);\t\\\n\t__retval;\t\t\t\t\t\t\\\n})\n\nstatic inline void nl_set_extack_cookie_u64(struct netlink_ext_ack *extack,\n\t\t\t\t\t    u64 cookie)\n{\n\tif (!extack)\n\t\treturn;\n\tmemcpy(extack->cookie, &cookie, sizeof(cookie));\n\textack->cookie_len = sizeof(cookie);\n}\n\nvoid netlink_kernel_release(struct sock *sk);\nint __netlink_change_ngroups(struct sock *sk, unsigned int groups);\nint netlink_change_ngroups(struct sock *sk, unsigned int groups);\nvoid __netlink_clear_multicast_users(struct sock *sk, unsigned int group);\nvoid netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err,\n\t\t const struct netlink_ext_ack *extack);\nint netlink_has_listeners(struct sock *sk, unsigned int group);\nbool netlink_strict_get_check(struct sk_buff *skb);\n\nint netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);\nint netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 portid,\n\t\t      __u32 group, gfp_t allocation);\nint netlink_broadcast_filtered(struct sock *ssk, struct sk_buff *skb,\n\t\t\t       __u32 portid, __u32 group, gfp_t allocation,\n\t\t\t       int (*filter)(struct sock *dsk,\n\t\t\t\t\t     struct sk_buff *skb, void *data),\n\t\t\t       void *filter_data);\nint netlink_set_err(struct sock *ssk, __u32 portid, __u32 group, int code);\nint netlink_register_notifier(struct notifier_block *nb);\nint netlink_unregister_notifier(struct notifier_block *nb);\n\n \nstruct sock *netlink_getsockbyfilp(struct file *filp);\nint netlink_attachskb(struct sock *sk, struct sk_buff *skb,\n\t\t      long *timeo, struct sock *ssk);\nvoid netlink_detachskb(struct sock *sk, struct sk_buff *skb);\nint netlink_sendskb(struct sock *sk, struct sk_buff *skb);\n\nstatic inline struct sk_buff *\nnetlink_skb_clone(struct sk_buff *skb, gfp_t gfp_mask)\n{\n\tstruct sk_buff *nskb;\n\n\tnskb = skb_clone(skb, gfp_mask);\n\tif (!nskb)\n\t\treturn NULL;\n\n\t \n\tif (is_vmalloc_addr(skb->head))\n\t\tnskb->destructor = skb->destructor;\n\n\treturn nskb;\n}\n\n \n#if PAGE_SIZE < 8192UL\n#define NLMSG_GOODSIZE\tSKB_WITH_OVERHEAD(PAGE_SIZE)\n#else\n#define NLMSG_GOODSIZE\tSKB_WITH_OVERHEAD(8192UL)\n#endif\n\n#define NLMSG_DEFAULT_SIZE (NLMSG_GOODSIZE - NLMSG_HDRLEN)\n\n\nstruct netlink_callback {\n\tstruct sk_buff\t\t*skb;\n\tconst struct nlmsghdr\t*nlh;\n\tint\t\t\t(*dump)(struct sk_buff * skb,\n\t\t\t\t\tstruct netlink_callback *cb);\n\tint\t\t\t(*done)(struct netlink_callback *cb);\n\tvoid\t\t\t*data;\n\t \n\tstruct module\t\t*module;\n\tstruct netlink_ext_ack\t*extack;\n\tu16\t\t\tfamily;\n\tu16\t\t\tanswer_flags;\n\tu32\t\t\tmin_dump_alloc;\n\tunsigned int\t\tprev_seq, seq;\n\tbool\t\t\tstrict_check;\n\tunion {\n\t\tu8\t\tctx[48];\n\n\t\t \n\t\tlong\t\targs[6];\n\t};\n};\n\n#define NL_ASSERT_DUMP_CTX_FITS(type_name)\t\t\t\t\\\n\tBUILD_BUG_ON(sizeof(type_name) >\t\t\t\t\\\n\t\t     sizeof_field(struct netlink_callback, ctx))\n\nstruct netlink_notify {\n\tstruct net *net;\n\tu32 portid;\n\tint protocol;\n};\n\nstruct nlmsghdr *\n__nlmsg_put(struct sk_buff *skb, u32 portid, u32 seq, int type, int len, int flags);\n\nstruct netlink_dump_control {\n\tint (*start)(struct netlink_callback *);\n\tint (*dump)(struct sk_buff *skb, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n\tstruct netlink_ext_ack *extack;\n\tvoid *data;\n\tstruct module *module;\n\tu32 min_dump_alloc;\n};\n\nint __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,\n\t\t\t\tconst struct nlmsghdr *nlh,\n\t\t\t\tstruct netlink_dump_control *control);\nstatic inline int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,\n\t\t\t\t     const struct nlmsghdr *nlh,\n\t\t\t\t     struct netlink_dump_control *control)\n{\n\tif (!control->module)\n\t\tcontrol->module = THIS_MODULE;\n\n\treturn __netlink_dump_start(ssk, skb, nlh, control);\n}\n\nstruct netlink_tap {\n\tstruct net_device *dev;\n\tstruct module *module;\n\tstruct list_head list;\n};\n\nint netlink_add_tap(struct netlink_tap *nt);\nint netlink_remove_tap(struct netlink_tap *nt);\n\nbool __netlink_ns_capable(const struct netlink_skb_parms *nsp,\n\t\t\t  struct user_namespace *ns, int cap);\nbool netlink_ns_capable(const struct sk_buff *skb,\n\t\t\tstruct user_namespace *ns, int cap);\nbool netlink_capable(const struct sk_buff *skb, int cap);\nbool netlink_net_capable(const struct sk_buff *skb, int cap);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}