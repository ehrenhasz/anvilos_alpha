{
  "module_name": "skb.h",
  "hash_id": "f690afcb2545b7654c8a76fdca151fc9f5e2f38272c25b9b5a6f75bbb3e309fb",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/can/skb.h",
  "human_readable_source": " \n \n\n#ifndef _CAN_SKB_H\n#define _CAN_SKB_H\n\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/can.h>\n#include <net/sock.h>\n\nvoid can_flush_echo_skb(struct net_device *dev);\nint can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,\n\t\t     unsigned int idx, unsigned int frame_len);\nstruct sk_buff *__can_get_echo_skb(struct net_device *dev, unsigned int idx,\n\t\t\t\t   unsigned int *len_ptr,\n\t\t\t\t   unsigned int *frame_len_ptr);\nunsigned int __must_check can_get_echo_skb(struct net_device *dev,\n\t\t\t\t\t   unsigned int idx,\n\t\t\t\t\t   unsigned int *frame_len_ptr);\nvoid can_free_echo_skb(struct net_device *dev, unsigned int idx,\n\t\t       unsigned int *frame_len_ptr);\nstruct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf);\nstruct sk_buff *alloc_canfd_skb(struct net_device *dev,\n\t\t\t\tstruct canfd_frame **cfd);\nstruct sk_buff *alloc_canxl_skb(struct net_device *dev,\n\t\t\t\tstruct canxl_frame **cxl,\n\t\t\t\tunsigned int data_len);\nstruct sk_buff *alloc_can_err_skb(struct net_device *dev,\n\t\t\t\t  struct can_frame **cf);\nbool can_dropped_invalid_skb(struct net_device *dev, struct sk_buff *skb);\n\n \n\n \nstruct can_skb_priv {\n\tint ifindex;\n\tint skbcnt;\n\tunsigned int frame_len;\n\tstruct can_frame cf[];\n};\n\nstatic inline struct can_skb_priv *can_skb_prv(struct sk_buff *skb)\n{\n\treturn (struct can_skb_priv *)(skb->head);\n}\n\nstatic inline void can_skb_reserve(struct sk_buff *skb)\n{\n\tskb_reserve(skb, sizeof(struct can_skb_priv));\n}\n\nstatic inline void can_skb_set_owner(struct sk_buff *skb, struct sock *sk)\n{\n\t \n\tif (sk && refcount_inc_not_zero(&sk->sk_refcnt)) {\n\t\tskb->destructor = sock_efree;\n\t\tskb->sk = sk;\n\t}\n}\n\n \nstatic inline struct sk_buff *can_create_echo_skb(struct sk_buff *skb)\n{\n\tstruct sk_buff *nskb;\n\n\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (unlikely(!nskb)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tcan_skb_set_owner(nskb, skb->sk);\n\tconsume_skb(skb);\n\treturn nskb;\n}\n\nstatic inline bool can_is_can_skb(const struct sk_buff *skb)\n{\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\n\t \n\treturn (skb->len == CAN_MTU && cf->len <= CAN_MAX_DLEN);\n}\n\nstatic inline bool can_is_canfd_skb(const struct sk_buff *skb)\n{\n\tstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\n\n\t \n\treturn (skb->len == CANFD_MTU && cfd->len <= CANFD_MAX_DLEN);\n}\n\nstatic inline bool can_is_canxl_skb(const struct sk_buff *skb)\n{\n\tconst struct canxl_frame *cxl = (struct canxl_frame *)skb->data;\n\n\tif (skb->len < CANXL_HDR_SIZE + CANXL_MIN_DLEN || skb->len > CANXL_MTU)\n\t\treturn false;\n\n\t \n\tif (skb->len != CANXL_HDR_SIZE + cxl->len)\n\t\treturn false;\n\n\treturn cxl->flags & CANXL_XLF;\n}\n\n \nstatic inline unsigned int can_skb_get_len_val(struct sk_buff *skb)\n{\n\tconst struct canxl_frame *cxl = (struct canxl_frame *)skb->data;\n\tconst struct canfd_frame *cfd = (struct canfd_frame *)skb->data;\n\n\tif (can_is_canxl_skb(skb))\n\t\treturn cxl->len;\n\n\treturn cfd->len;\n}\n\n \nstatic inline unsigned int can_skb_get_data_len(struct sk_buff *skb)\n{\n\tunsigned int len = can_skb_get_len_val(skb);\n\tconst struct can_frame *cf = (struct can_frame *)skb->data;\n\n\t \n\tif (can_is_can_skb(skb) && cf->can_id & CAN_RTR_FLAG)\n\t\treturn 0;\n\n\treturn len;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}