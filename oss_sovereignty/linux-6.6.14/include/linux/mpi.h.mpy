{
  "module_name": "mpi.h",
  "hash_id": "c61f85583270890817f43e568ff662720e383f204dc64e56cb1a0b6b598e0b2f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mpi.h",
  "human_readable_source": " \n \n\n#ifndef G10_MPI_H\n#define G10_MPI_H\n\n#include <linux/types.h>\n#include <linux/scatterlist.h>\n\n#define BYTES_PER_MPI_LIMB\t(BITS_PER_LONG / 8)\n#define BITS_PER_MPI_LIMB\tBITS_PER_LONG\n\ntypedef unsigned long int mpi_limb_t;\ntypedef signed long int mpi_limb_signed_t;\n\nstruct gcry_mpi {\n\tint alloced;\t\t \n\tint nlimbs;\t\t \n\tint nbits;\t\t \n\tint sign;\t\t \n\tunsigned flags;\t\t \n\t \n\t \n\tmpi_limb_t *d;\t\t \n};\n\ntypedef struct gcry_mpi *MPI;\n\n#define mpi_get_nlimbs(a)     ((a)->nlimbs)\n#define mpi_has_sign(a)       ((a)->sign)\n\n \nMPI mpi_alloc(unsigned nlimbs);\nvoid mpi_clear(MPI a);\nvoid mpi_free(MPI a);\nint mpi_resize(MPI a, unsigned nlimbs);\n\nstatic inline MPI mpi_new(unsigned int nbits)\n{\n\treturn mpi_alloc((nbits + BITS_PER_MPI_LIMB - 1) / BITS_PER_MPI_LIMB);\n}\n\nMPI mpi_copy(MPI a);\nMPI mpi_alloc_like(MPI a);\nvoid mpi_snatch(MPI w, MPI u);\nMPI mpi_set(MPI w, MPI u);\nMPI mpi_set_ui(MPI w, unsigned long u);\nMPI mpi_alloc_set_ui(unsigned long u);\nvoid mpi_swap_cond(MPI a, MPI b, unsigned long swap);\n\n \n#define MPI_NUMBER_OF_CONSTANTS 6\nenum gcry_mpi_constants {\n\tMPI_C_ZERO,\n\tMPI_C_ONE,\n\tMPI_C_TWO,\n\tMPI_C_THREE,\n\tMPI_C_FOUR,\n\tMPI_C_EIGHT\n};\n\nMPI mpi_const(enum gcry_mpi_constants no);\n\n \n\n \nenum gcry_mpi_format {\n\tGCRYMPI_FMT_NONE = 0,\n\tGCRYMPI_FMT_STD = 1,     \n\tGCRYMPI_FMT_PGP = 2,     \n\tGCRYMPI_FMT_SSH = 3,     \n\tGCRYMPI_FMT_HEX = 4,     \n\tGCRYMPI_FMT_USG = 5,     \n\tGCRYMPI_FMT_OPAQUE = 8   \n};\n\nMPI mpi_read_raw_data(const void *xbuffer, size_t nbytes);\nMPI mpi_read_from_buffer(const void *buffer, unsigned *ret_nread);\nint mpi_fromstr(MPI val, const char *str);\nMPI mpi_scanval(const char *string);\nMPI mpi_read_raw_from_sgl(struct scatterlist *sgl, unsigned int len);\nvoid *mpi_get_buffer(MPI a, unsigned *nbytes, int *sign);\nint mpi_read_buffer(MPI a, uint8_t *buf, unsigned buf_len, unsigned *nbytes,\n\t\t    int *sign);\nint mpi_write_to_sgl(MPI a, struct scatterlist *sg, unsigned nbytes,\n\t\t     int *sign);\nint mpi_print(enum gcry_mpi_format format, unsigned char *buffer,\n\t\t\tsize_t buflen, size_t *nwritten, MPI a);\n\n \nvoid mpi_mod(MPI rem, MPI dividend, MPI divisor);\n\n \nstruct barrett_ctx_s;\ntypedef struct barrett_ctx_s *mpi_barrett_t;\n\nmpi_barrett_t mpi_barrett_init(MPI m, int copy);\nvoid mpi_barrett_free(mpi_barrett_t ctx);\nvoid mpi_mod_barrett(MPI r, MPI x, mpi_barrett_t ctx);\nvoid mpi_mul_barrett(MPI w, MPI u, MPI v, mpi_barrett_t ctx);\n\n \nint mpi_powm(MPI res, MPI base, MPI exp, MPI mod);\n\n \nint mpi_cmp_ui(MPI u, ulong v);\nint mpi_cmp(MPI u, MPI v);\nint mpi_cmpabs(MPI u, MPI v);\n\n \nint mpi_sub_ui(MPI w, MPI u, unsigned long vval);\n\n \nvoid mpi_normalize(MPI a);\nunsigned mpi_get_nbits(MPI a);\nint mpi_test_bit(MPI a, unsigned int n);\nvoid mpi_set_bit(MPI a, unsigned int n);\nvoid mpi_set_highbit(MPI a, unsigned int n);\nvoid mpi_clear_highbit(MPI a, unsigned int n);\nvoid mpi_clear_bit(MPI a, unsigned int n);\nvoid mpi_rshift_limbs(MPI a, unsigned int count);\nvoid mpi_rshift(MPI x, MPI a, unsigned int n);\nvoid mpi_lshift_limbs(MPI a, unsigned int count);\nvoid mpi_lshift(MPI x, MPI a, unsigned int n);\n\n \nvoid mpi_add_ui(MPI w, MPI u, unsigned long v);\nvoid mpi_add(MPI w, MPI u, MPI v);\nvoid mpi_sub(MPI w, MPI u, MPI v);\nvoid mpi_addm(MPI w, MPI u, MPI v, MPI m);\nvoid mpi_subm(MPI w, MPI u, MPI v, MPI m);\n\n \nvoid mpi_mul(MPI w, MPI u, MPI v);\nvoid mpi_mulm(MPI w, MPI u, MPI v, MPI m);\n\n \nvoid mpi_tdiv_r(MPI rem, MPI num, MPI den);\nvoid mpi_fdiv_r(MPI rem, MPI dividend, MPI divisor);\nvoid mpi_fdiv_q(MPI quot, MPI dividend, MPI divisor);\n\n \nint mpi_invm(MPI x, MPI a, MPI n);\n\n \n\n \nstruct gcry_mpi_point {\n\tMPI x;\n\tMPI y;\n\tMPI z;\n};\n\ntypedef struct gcry_mpi_point *MPI_POINT;\n\n \nenum gcry_mpi_ec_models {\n\t \n\tMPI_EC_WEIERSTRASS = 0,\n\t \n\tMPI_EC_MONTGOMERY,\n\t \n\tMPI_EC_EDWARDS\n};\n\n \nenum ecc_dialects {\n\tECC_DIALECT_STANDARD = 0,\n\tECC_DIALECT_ED25519,\n\tECC_DIALECT_SAFECURVE\n};\n\n \nstruct mpi_ec_ctx {\n\tenum gcry_mpi_ec_models model;  \n\tenum ecc_dialects dialect;      \n\tint flags;                      \n\tunsigned int nbits;             \n\n\t \n\tMPI p;          \n\tMPI a;          \n\tMPI b;          \n\tMPI_POINT G;    \n\tMPI n;          \n\tunsigned int h;        \n\n\t \n\tMPI_POINT Q;    \n\tMPI d;          \n\n\tconst char *name;       \n\n\t \n\tstruct {\n\t\tstruct {\n\t\t\tunsigned int a_is_pminus3:1;\n\t\t\tunsigned int two_inv_p:1;\n\t\t} valid;  \n\n\t\tint a_is_pminus3;   \n\n\t\tMPI two_inv_p;\n\n\t\tmpi_barrett_t p_barrett;\n\n\t\t \n\t\tMPI scratch[11];\n\n\t\t \n\t\t \n\t\t \n\t\t \n\t} t;\n\n\t \n\tvoid (*addm)(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx);\n\tvoid (*subm)(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ec);\n\tvoid (*mulm)(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx);\n\tvoid (*pow2)(MPI w, const MPI b, struct mpi_ec_ctx *ctx);\n\tvoid (*mul2)(MPI w, MPI u, struct mpi_ec_ctx *ctx);\n};\n\nvoid mpi_ec_init(struct mpi_ec_ctx *ctx, enum gcry_mpi_ec_models model,\n\t\t\tenum ecc_dialects dialect,\n\t\t\tint flags, MPI p, MPI a, MPI b);\nvoid mpi_ec_deinit(struct mpi_ec_ctx *ctx);\nMPI_POINT mpi_point_new(unsigned int nbits);\nvoid mpi_point_release(MPI_POINT p);\nvoid mpi_point_init(MPI_POINT p);\nvoid mpi_point_free_parts(MPI_POINT p);\nint mpi_ec_get_affine(MPI x, MPI y, MPI_POINT point, struct mpi_ec_ctx *ctx);\nvoid mpi_ec_add_points(MPI_POINT result,\n\t\t\tMPI_POINT p1, MPI_POINT p2,\n\t\t\tstruct mpi_ec_ctx *ctx);\nvoid mpi_ec_mul_point(MPI_POINT result,\n\t\t\tMPI scalar, MPI_POINT point,\n\t\t\tstruct mpi_ec_ctx *ctx);\nint mpi_ec_curve_point(MPI_POINT point, struct mpi_ec_ctx *ctx);\n\n \n\n \nstatic inline unsigned int mpi_get_size(MPI a)\n{\n\treturn a->nlimbs * BYTES_PER_MPI_LIMB;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}