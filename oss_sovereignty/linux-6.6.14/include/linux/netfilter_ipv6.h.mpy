{
  "module_name": "netfilter_ipv6.h",
  "hash_id": "9ef5dfe1272dccf4d9178a4320720bfb595974d885c6b859a85cc548ec40fdb9",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/netfilter_ipv6.h",
  "human_readable_source": " \n#ifndef __LINUX_IP6_NETFILTER_H\n#define __LINUX_IP6_NETFILTER_H\n\n#include <uapi/linux/netfilter_ipv6.h>\n#include <net/tcp.h>\n\n \nstatic inline int\nnf_ip6_ext_hdr(u8 nexthdr)\n{\treturn (nexthdr == IPPROTO_HOPOPTS) ||\n\t       (nexthdr == IPPROTO_ROUTING) ||\n\t       (nexthdr == IPPROTO_FRAGMENT) ||\n\t       (nexthdr == IPPROTO_ESP) ||\n\t       (nexthdr == IPPROTO_AH) ||\n\t       (nexthdr == IPPROTO_NONE) ||\n\t       (nexthdr == IPPROTO_DSTOPTS);\n}\n\n \nstruct ip6_rt_info {\n\tstruct in6_addr daddr;\n\tstruct in6_addr saddr;\n\tu_int32_t mark;\n};\n\nstruct nf_queue_entry;\nstruct nf_bridge_frag_data;\n\n \nstruct nf_ipv6_ops {\n#if IS_MODULE(CONFIG_IPV6)\n\tint (*chk_addr)(struct net *net, const struct in6_addr *addr,\n\t\t\tconst struct net_device *dev, int strict);\n\tint (*route_me_harder)(struct net *net, struct sock *sk, struct sk_buff *skb);\n\tint (*dev_get_saddr)(struct net *net, const struct net_device *dev,\n\t\t       const struct in6_addr *daddr, unsigned int srcprefs,\n\t\t       struct in6_addr *saddr);\n\tint (*route)(struct net *net, struct dst_entry **dst, struct flowi *fl,\n\t\t     bool strict);\n\tu32 (*cookie_init_sequence)(const struct ipv6hdr *iph,\n\t\t\t\t    const struct tcphdr *th, u16 *mssp);\n\tint (*cookie_v6_check)(const struct ipv6hdr *iph,\n\t\t\t       const struct tcphdr *th, __u32 cookie);\n#endif\n\tvoid (*route_input)(struct sk_buff *skb);\n\tint (*fragment)(struct net *net, struct sock *sk, struct sk_buff *skb,\n\t\t\tint (*output)(struct net *, struct sock *, struct sk_buff *));\n\tint (*reroute)(struct sk_buff *skb, const struct nf_queue_entry *entry);\n#if IS_MODULE(CONFIG_IPV6)\n\tint (*br_fragment)(struct net *net, struct sock *sk,\n\t\t\t   struct sk_buff *skb,\n\t\t\t   struct nf_bridge_frag_data *data,\n\t\t\t   int (*output)(struct net *, struct sock *sk,\n\t\t\t\t\t const struct nf_bridge_frag_data *data,\n\t\t\t\t\t struct sk_buff *));\n#endif\n};\n\n#ifdef CONFIG_NETFILTER\n#include <net/addrconf.h>\n\nextern const struct nf_ipv6_ops __rcu *nf_ipv6_ops;\nstatic inline const struct nf_ipv6_ops *nf_get_ipv6_ops(void)\n{\n\treturn rcu_dereference(nf_ipv6_ops);\n}\n\nstatic inline int nf_ipv6_chk_addr(struct net *net, const struct in6_addr *addr,\n\t\t\t\t   const struct net_device *dev, int strict)\n{\n#if IS_MODULE(CONFIG_IPV6)\n\tconst struct nf_ipv6_ops *v6_ops = nf_get_ipv6_ops();\n\n\tif (!v6_ops)\n\t\treturn 1;\n\n\treturn v6_ops->chk_addr(net, addr, dev, strict);\n#elif IS_BUILTIN(CONFIG_IPV6)\n\treturn ipv6_chk_addr(net, addr, dev, strict);\n#else\n\treturn 1;\n#endif\n}\n\nint __nf_ip6_route(struct net *net, struct dst_entry **dst,\n\t\t\t       struct flowi *fl, bool strict);\n\nstatic inline int nf_ip6_route(struct net *net, struct dst_entry **dst,\n\t\t\t       struct flowi *fl, bool strict)\n{\n#if IS_MODULE(CONFIG_IPV6)\n\tconst struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();\n\n\tif (v6ops)\n\t\treturn v6ops->route(net, dst, fl, strict);\n\n\treturn -EHOSTUNREACH;\n#endif\n#if IS_BUILTIN(CONFIG_IPV6)\n\treturn __nf_ip6_route(net, dst, fl, strict);\n#else\n\treturn -EHOSTUNREACH;\n#endif\n}\n\n#include <net/netfilter/ipv6/nf_defrag_ipv6.h>\n\nint br_ip6_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,\n\t\t    struct nf_bridge_frag_data *data,\n\t\t    int (*output)(struct net *, struct sock *sk,\n\t\t\t\t  const struct nf_bridge_frag_data *data,\n\t\t\t\t  struct sk_buff *));\n\nstatic inline int nf_br_ip6_fragment(struct net *net, struct sock *sk,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     struct nf_bridge_frag_data *data,\n\t\t\t\t     int (*output)(struct net *, struct sock *sk,\n\t\t\t\t\t\t   const struct nf_bridge_frag_data *data,\n\t\t\t\t\t\t   struct sk_buff *))\n{\n#if IS_MODULE(CONFIG_IPV6)\n\tconst struct nf_ipv6_ops *v6_ops = nf_get_ipv6_ops();\n\n\tif (!v6_ops)\n\t\treturn 1;\n\n\treturn v6_ops->br_fragment(net, sk, skb, data, output);\n#elif IS_BUILTIN(CONFIG_IPV6)\n\treturn br_ip6_fragment(net, sk, skb, data, output);\n#else\n\treturn 1;\n#endif\n}\n\nint ip6_route_me_harder(struct net *net, struct sock *sk, struct sk_buff *skb);\n\nstatic inline int nf_ip6_route_me_harder(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n#if IS_MODULE(CONFIG_IPV6)\n\tconst struct nf_ipv6_ops *v6_ops = nf_get_ipv6_ops();\n\n\tif (!v6_ops)\n\t\treturn -EHOSTUNREACH;\n\n\treturn v6_ops->route_me_harder(net, sk, skb);\n#elif IS_BUILTIN(CONFIG_IPV6)\n\treturn ip6_route_me_harder(net, sk, skb);\n#else\n\treturn -EHOSTUNREACH;\n#endif\n}\n\nstatic inline u32 nf_ipv6_cookie_init_sequence(const struct ipv6hdr *iph,\n\t\t\t\t\t       const struct tcphdr *th,\n\t\t\t\t\t       u16 *mssp)\n{\n#if IS_ENABLED(CONFIG_SYN_COOKIES)\n#if IS_MODULE(CONFIG_IPV6)\n\tconst struct nf_ipv6_ops *v6_ops = nf_get_ipv6_ops();\n\n\tif (v6_ops)\n\t\treturn v6_ops->cookie_init_sequence(iph, th, mssp);\n#elif IS_BUILTIN(CONFIG_IPV6)\n\treturn __cookie_v6_init_sequence(iph, th, mssp);\n#endif\n#endif\n\treturn 0;\n}\n\nstatic inline int nf_cookie_v6_check(const struct ipv6hdr *iph,\n\t\t\t\t     const struct tcphdr *th, __u32 cookie)\n{\n#if IS_ENABLED(CONFIG_SYN_COOKIES)\n#if IS_MODULE(CONFIG_IPV6)\n\tconst struct nf_ipv6_ops *v6_ops = nf_get_ipv6_ops();\n\n\tif (v6_ops)\n\t\treturn v6_ops->cookie_v6_check(iph, th, cookie);\n#elif IS_BUILTIN(CONFIG_IPV6)\n\treturn __cookie_v6_check(iph, th, cookie);\n#endif\n#endif\n\treturn 0;\n}\n\n__sum16 nf_ip6_checksum(struct sk_buff *skb, unsigned int hook,\n\t\t\tunsigned int dataoff, u_int8_t protocol);\n\nint nf_ip6_check_hbh_len(struct sk_buff *skb, u32 *plen);\n\nint ipv6_netfilter_init(void);\nvoid ipv6_netfilter_fini(void);\n\n#else  \nstatic inline int ipv6_netfilter_init(void) { return 0; }\nstatic inline void ipv6_netfilter_fini(void) { return; }\nstatic inline const struct nf_ipv6_ops *nf_get_ipv6_ops(void) { return NULL; }\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}