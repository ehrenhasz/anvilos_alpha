{
  "module_name": "netfilter_netdev.h",
  "hash_id": "6b0068cefe451258274f3632ccd3e0c2da9913a8102d5c04613da15aecf6e89f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/netfilter_netdev.h",
  "human_readable_source": " \n#ifndef _NETFILTER_NETDEV_H_\n#define _NETFILTER_NETDEV_H_\n\n#include <linux/netfilter.h>\n#include <linux/netdevice.h>\n\n#ifdef CONFIG_NETFILTER_INGRESS\nstatic inline bool nf_hook_ingress_active(const struct sk_buff *skb)\n{\n#ifdef CONFIG_JUMP_LABEL\n\tif (!static_key_false(&nf_hooks_needed[NFPROTO_NETDEV][NF_NETDEV_INGRESS]))\n\t\treturn false;\n#endif\n\treturn rcu_access_pointer(skb->dev->nf_hooks_ingress);\n}\n\n \nstatic inline int nf_hook_ingress(struct sk_buff *skb)\n{\n\tstruct nf_hook_entries *e = rcu_dereference(skb->dev->nf_hooks_ingress);\n\tstruct nf_hook_state state;\n\tint ret;\n\n\t \n\tif (unlikely(!e))\n\t\treturn 0;\n\n\tnf_hook_state_init(&state, NF_NETDEV_INGRESS,\n\t\t\t   NFPROTO_NETDEV, skb->dev, NULL, NULL,\n\t\t\t   dev_net(skb->dev), NULL);\n\tret = nf_hook_slow(skb, &state, e, 0);\n\tif (ret == 0)\n\t\treturn -1;\n\n\treturn ret;\n}\n\n#else  \nstatic inline int nf_hook_ingress_active(struct sk_buff *skb)\n{\n\treturn 0;\n}\n\nstatic inline int nf_hook_ingress(struct sk_buff *skb)\n{\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_NETFILTER_EGRESS\nstatic inline bool nf_hook_egress_active(void)\n{\n#ifdef CONFIG_JUMP_LABEL\n\tif (!static_key_false(&nf_hooks_needed[NFPROTO_NETDEV][NF_NETDEV_EGRESS]))\n\t\treturn false;\n#endif\n\treturn true;\n}\n\n \nstatic inline struct sk_buff *nf_hook_egress(struct sk_buff *skb, int *rc,\n\t\t\t\t\t     struct net_device *dev)\n{\n\tstruct nf_hook_entries *e;\n\tstruct nf_hook_state state;\n\tint ret;\n\n#ifdef CONFIG_NETFILTER_SKIP_EGRESS\n\tif (skb->nf_skip_egress)\n\t\treturn skb;\n#endif\n\n\te = rcu_dereference_check(dev->nf_hooks_egress, rcu_read_lock_bh_held());\n\tif (!e)\n\t\treturn skb;\n\n\tnf_hook_state_init(&state, NF_NETDEV_EGRESS,\n\t\t\t   NFPROTO_NETDEV, NULL, dev, NULL,\n\t\t\t   dev_net(dev), NULL);\n\n\t \n\trcu_read_lock();\n\tret = nf_hook_slow(skb, &state, e, 0);\n\trcu_read_unlock();\n\n\tif (ret == 1) {\n\t\treturn skb;\n\t} else if (ret < 0) {\n\t\t*rc = NET_XMIT_DROP;\n\t\treturn NULL;\n\t} else {  \n\t\t*rc = NET_XMIT_SUCCESS;\n\t\treturn NULL;\n\t}\n}\n#else  \nstatic inline bool nf_hook_egress_active(void)\n{\n\treturn false;\n}\n\nstatic inline struct sk_buff *nf_hook_egress(struct sk_buff *skb, int *rc,\n\t\t\t\t\t     struct net_device *dev)\n{\n\treturn skb;\n}\n#endif  \n\nstatic inline void nf_skip_egress(struct sk_buff *skb, bool skip)\n{\n#ifdef CONFIG_NETFILTER_SKIP_EGRESS\n\tskb->nf_skip_egress = skip;\n#endif\n}\n\nstatic inline void nf_hook_netdev_init(struct net_device *dev)\n{\n#ifdef CONFIG_NETFILTER_INGRESS\n\tRCU_INIT_POINTER(dev->nf_hooks_ingress, NULL);\n#endif\n#ifdef CONFIG_NETFILTER_EGRESS\n\tRCU_INIT_POINTER(dev->nf_hooks_egress, NULL);\n#endif\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}