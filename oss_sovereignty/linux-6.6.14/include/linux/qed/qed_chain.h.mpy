{
  "module_name": "qed_chain.h",
  "hash_id": "28aed72004d834a38d16925dd13bd739603a5bb4790471e183e7e318bf64751b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/qed/qed_chain.h",
  "human_readable_source": " \n \n\n#ifndef _QED_CHAIN_H\n#define _QED_CHAIN_H\n\n#include <linux/types.h>\n#include <asm/byteorder.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/qed/common_hsi.h>\n\nenum qed_chain_mode {\n\t \n\tQED_CHAIN_MODE_NEXT_PTR,\n\n\t \n\tQED_CHAIN_MODE_SINGLE,\n\n\t \n\tQED_CHAIN_MODE_PBL,\n};\n\nenum qed_chain_use_mode {\n\tQED_CHAIN_USE_TO_PRODUCE,\t\t\t \n\tQED_CHAIN_USE_TO_CONSUME,\t\t\t \n\tQED_CHAIN_USE_TO_CONSUME_PRODUCE,\t\t \n};\n\nenum qed_chain_cnt_type {\n\t \n\tQED_CHAIN_CNT_TYPE_U16,\n\n\t \n\tQED_CHAIN_CNT_TYPE_U32,\n};\n\nstruct qed_chain_next {\n\tstruct regpair\t\t\t\t\tnext_phys;\n\tvoid\t\t\t\t\t\t*next_virt;\n};\n\nstruct qed_chain_pbl_u16 {\n\tu16\t\t\t\t\t\tprod_page_idx;\n\tu16\t\t\t\t\t\tcons_page_idx;\n};\n\nstruct qed_chain_pbl_u32 {\n\tu32\t\t\t\t\t\tprod_page_idx;\n\tu32\t\t\t\t\t\tcons_page_idx;\n};\n\nstruct qed_chain_u16 {\n\t \n\tu16\t\t\t\t\t\tprod_idx;\n\tu16\t\t\t\t\t\tcons_idx;\n};\n\nstruct qed_chain_u32 {\n\t \n\tu32\t\t\t\t\t\tprod_idx;\n\tu32\t\t\t\t\t\tcons_idx;\n};\n\nstruct addr_tbl_entry {\n\tvoid\t\t\t\t\t\t*virt_addr;\n\tdma_addr_t\t\t\t\t\tdma_map;\n};\n\nstruct qed_chain {\n\t \n\n\t \n\tvoid\t\t\t\t\t\t*p_prod_elem;\n\tvoid\t\t\t\t\t\t*p_cons_elem;\n\n\t \n\n\tstruct {\n\t\t \n\t\tstruct addr_tbl_entry\t\t\t*pp_addr_tbl;\n\n\t\tunion {\n\t\t\tstruct qed_chain_pbl_u16\tu16;\n\t\t\tstruct qed_chain_pbl_u32\tu32;\n\t\t}\t\t\t\t\tc;\n\t}\t\t\t\t\t\tpbl;\n\n\tunion {\n\t\tstruct qed_chain_u16\t\t\tchain16;\n\t\tstruct qed_chain_u32\t\t\tchain32;\n\t}\t\t\t\t\t\tu;\n\n\t \n\tu32\t\t\t\t\t\tcapacity;\n\tu32\t\t\t\t\t\tpage_cnt;\n\n\tenum qed_chain_mode\t\t\t\tmode;\n\n\t \n\tu16\t\t\t\t\t\telem_per_page;\n\tu16\t\t\t\t\t\telem_per_page_mask;\n\tu16\t\t\t\t\t\telem_size;\n\tu16\t\t\t\t\t\tnext_page_mask;\n\tu16\t\t\t\t\t\tusable_per_page;\n\tu8\t\t\t\t\t\telem_unusable;\n\n\tenum qed_chain_cnt_type\t\t\t\tcnt_type;\n\n\t \n\n\tu32\t\t\t\t\t\tpage_size;\n\n\t \n\tstruct {\n\t\t__le64\t\t\t\t\t*table_virt;\n\t\tdma_addr_t\t\t\t\ttable_phys;\n\t\tsize_t\t\t\t\t\ttable_size;\n\t}\t\t\t\t\t\tpbl_sp;\n\n\t \n\tvoid\t\t\t\t\t\t*p_virt_addr;\n\tdma_addr_t\t\t\t\t\tp_phys_addr;\n\n\t \n\tu32\t\t\t\t\t\tsize;\n\n\tenum qed_chain_use_mode\t\t\t\tintended_use;\n\n\tbool\t\t\t\t\t\tb_external_pbl;\n};\n\nstruct qed_chain_init_params {\n\tenum qed_chain_mode\t\t\t\tmode;\n\tenum qed_chain_use_mode\t\t\t\tintended_use;\n\tenum qed_chain_cnt_type\t\t\t\tcnt_type;\n\n\tu32\t\t\t\t\t\tpage_size;\n\tu32\t\t\t\t\t\tnum_elems;\n\tsize_t\t\t\t\t\t\telem_size;\n\n\tvoid\t\t\t\t\t\t*ext_pbl_virt;\n\tdma_addr_t\t\t\t\t\text_pbl_phys;\n};\n\n#define QED_CHAIN_PAGE_SIZE\t\t\t\tSZ_4K\n\n#define ELEMS_PER_PAGE(elem_size, page_size)\t\t\t\t     \\\n\t((page_size) / (elem_size))\n\n#define UNUSABLE_ELEMS_PER_PAGE(elem_size, mode)\t\t\t     \\\n\t(((mode) == QED_CHAIN_MODE_NEXT_PTR) ?\t\t\t\t     \\\n\t (u8)(1 + ((sizeof(struct qed_chain_next) - 1) / (elem_size))) :     \\\n\t 0)\n\n#define USABLE_ELEMS_PER_PAGE(elem_size, page_size, mode)\t\t     \\\n\t((u32)(ELEMS_PER_PAGE((elem_size), (page_size)) -\t\t     \\\n\t       UNUSABLE_ELEMS_PER_PAGE((elem_size), (mode))))\n\n#define QED_CHAIN_PAGE_CNT(elem_cnt, elem_size, page_size, mode)\t     \\\n\tDIV_ROUND_UP((elem_cnt),\t\t\t\t\t     \\\n\t\t     USABLE_ELEMS_PER_PAGE((elem_size), (page_size), (mode)))\n\n#define is_chain_u16(p)\t\t\t\t\t\t\t     \\\n\t((p)->cnt_type == QED_CHAIN_CNT_TYPE_U16)\n#define is_chain_u32(p)\t\t\t\t\t\t\t     \\\n\t((p)->cnt_type == QED_CHAIN_CNT_TYPE_U32)\n\n \n\nstatic inline u16 qed_chain_get_prod_idx(const struct qed_chain *chain)\n{\n\treturn chain->u.chain16.prod_idx;\n}\n\nstatic inline u16 qed_chain_get_cons_idx(const struct qed_chain *chain)\n{\n\treturn chain->u.chain16.cons_idx;\n}\n\nstatic inline u32 qed_chain_get_prod_idx_u32(const struct qed_chain *chain)\n{\n\treturn chain->u.chain32.prod_idx;\n}\n\nstatic inline u32 qed_chain_get_cons_idx_u32(const struct qed_chain *chain)\n{\n\treturn chain->u.chain32.cons_idx;\n}\n\nstatic inline u16 qed_chain_get_elem_used(const struct qed_chain *chain)\n{\n\tu32 prod = qed_chain_get_prod_idx(chain);\n\tu32 cons = qed_chain_get_cons_idx(chain);\n\tu16 elem_per_page = chain->elem_per_page;\n\tu16 used;\n\n\tif (prod < cons)\n\t\tprod += (u32)U16_MAX + 1;\n\n\tused = (u16)(prod - cons);\n\tif (chain->mode == QED_CHAIN_MODE_NEXT_PTR)\n\t\tused -= (u16)(prod / elem_per_page - cons / elem_per_page);\n\n\treturn used;\n}\n\nstatic inline u16 qed_chain_get_elem_left(const struct qed_chain *chain)\n{\n\treturn (u16)(chain->capacity - qed_chain_get_elem_used(chain));\n}\n\nstatic inline u32 qed_chain_get_elem_used_u32(const struct qed_chain *chain)\n{\n\tu64 prod = qed_chain_get_prod_idx_u32(chain);\n\tu64 cons = qed_chain_get_cons_idx_u32(chain);\n\tu16 elem_per_page = chain->elem_per_page;\n\tu32 used;\n\n\tif (prod < cons)\n\t\tprod += (u64)U32_MAX + 1;\n\n\tused = (u32)(prod - cons);\n\tif (chain->mode == QED_CHAIN_MODE_NEXT_PTR)\n\t\tused -= (u32)(prod / elem_per_page - cons / elem_per_page);\n\n\treturn used;\n}\n\nstatic inline u32 qed_chain_get_elem_left_u32(const struct qed_chain *chain)\n{\n\treturn chain->capacity - qed_chain_get_elem_used_u32(chain);\n}\n\nstatic inline u16 qed_chain_get_usable_per_page(const struct qed_chain *chain)\n{\n\treturn chain->usable_per_page;\n}\n\nstatic inline u8 qed_chain_get_unusable_per_page(const struct qed_chain *chain)\n{\n\treturn chain->elem_unusable;\n}\n\nstatic inline u32 qed_chain_get_page_cnt(const struct qed_chain *chain)\n{\n\treturn chain->page_cnt;\n}\n\nstatic inline dma_addr_t qed_chain_get_pbl_phys(const struct qed_chain *chain)\n{\n\treturn chain->pbl_sp.table_phys;\n}\n\n \nstatic inline void\nqed_chain_advance_page(struct qed_chain *p_chain,\n\t\t       void **p_next_elem, void *idx_to_inc, void *page_to_inc)\n{\n\tstruct qed_chain_next *p_next = NULL;\n\tu32 page_index = 0;\n\n\tswitch (p_chain->mode) {\n\tcase QED_CHAIN_MODE_NEXT_PTR:\n\t\tp_next = *p_next_elem;\n\t\t*p_next_elem = p_next->next_virt;\n\t\tif (is_chain_u16(p_chain))\n\t\t\t*(u16 *)idx_to_inc += p_chain->elem_unusable;\n\t\telse\n\t\t\t*(u32 *)idx_to_inc += p_chain->elem_unusable;\n\t\tbreak;\n\tcase QED_CHAIN_MODE_SINGLE:\n\t\t*p_next_elem = p_chain->p_virt_addr;\n\t\tbreak;\n\n\tcase QED_CHAIN_MODE_PBL:\n\t\tif (is_chain_u16(p_chain)) {\n\t\t\tif (++(*(u16 *)page_to_inc) == p_chain->page_cnt)\n\t\t\t\t*(u16 *)page_to_inc = 0;\n\t\t\tpage_index = *(u16 *)page_to_inc;\n\t\t} else {\n\t\t\tif (++(*(u32 *)page_to_inc) == p_chain->page_cnt)\n\t\t\t\t*(u32 *)page_to_inc = 0;\n\t\t\tpage_index = *(u32 *)page_to_inc;\n\t\t}\n\t\t*p_next_elem = p_chain->pbl.pp_addr_tbl[page_index].virt_addr;\n\t}\n}\n\n#define is_unusable_idx(p, idx)\t\\\n\t(((p)->u.chain16.idx & (p)->elem_per_page_mask) == (p)->usable_per_page)\n\n#define is_unusable_idx_u32(p, idx) \\\n\t(((p)->u.chain32.idx & (p)->elem_per_page_mask) == (p)->usable_per_page)\n#define is_unusable_next_idx(p, idx)\t\t\t\t \\\n\t((((p)->u.chain16.idx + 1) & (p)->elem_per_page_mask) == \\\n\t (p)->usable_per_page)\n\n#define is_unusable_next_idx_u32(p, idx)\t\t\t \\\n\t((((p)->u.chain32.idx + 1) & (p)->elem_per_page_mask) == \\\n\t (p)->usable_per_page)\n\n#define test_and_skip(p, idx)\t\t\t\t\t\t   \\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (is_chain_u16(p)) {\t\t\t\t\t   \\\n\t\t\tif (is_unusable_idx(p, idx))\t\t\t   \\\n\t\t\t\t(p)->u.chain16.idx += (p)->elem_unusable;  \\\n\t\t} else {\t\t\t\t\t\t   \\\n\t\t\tif (is_unusable_idx_u32(p, idx))\t\t   \\\n\t\t\t\t(p)->u.chain32.idx += (p)->elem_unusable;  \\\n\t\t}\t\t\t\t\t\\\n\t} while (0)\n\n \nstatic inline void qed_chain_return_produced(struct qed_chain *p_chain)\n{\n\tif (is_chain_u16(p_chain))\n\t\tp_chain->u.chain16.cons_idx++;\n\telse\n\t\tp_chain->u.chain32.cons_idx++;\n\ttest_and_skip(p_chain, cons_idx);\n}\n\n \nstatic inline void *qed_chain_produce(struct qed_chain *p_chain)\n{\n\tvoid *p_ret = NULL, *p_prod_idx, *p_prod_page_idx;\n\n\tif (is_chain_u16(p_chain)) {\n\t\tif ((p_chain->u.chain16.prod_idx &\n\t\t     p_chain->elem_per_page_mask) == p_chain->next_page_mask) {\n\t\t\tp_prod_idx = &p_chain->u.chain16.prod_idx;\n\t\t\tp_prod_page_idx = &p_chain->pbl.c.u16.prod_page_idx;\n\t\t\tqed_chain_advance_page(p_chain, &p_chain->p_prod_elem,\n\t\t\t\t\t       p_prod_idx, p_prod_page_idx);\n\t\t}\n\t\tp_chain->u.chain16.prod_idx++;\n\t} else {\n\t\tif ((p_chain->u.chain32.prod_idx &\n\t\t     p_chain->elem_per_page_mask) == p_chain->next_page_mask) {\n\t\t\tp_prod_idx = &p_chain->u.chain32.prod_idx;\n\t\t\tp_prod_page_idx = &p_chain->pbl.c.u32.prod_page_idx;\n\t\t\tqed_chain_advance_page(p_chain, &p_chain->p_prod_elem,\n\t\t\t\t\t       p_prod_idx, p_prod_page_idx);\n\t\t}\n\t\tp_chain->u.chain32.prod_idx++;\n\t}\n\n\tp_ret = p_chain->p_prod_elem;\n\tp_chain->p_prod_elem = (void *)(((u8 *)p_chain->p_prod_elem) +\n\t\t\t\t\tp_chain->elem_size);\n\n\treturn p_ret;\n}\n\n \nstatic inline u32 qed_chain_get_capacity(struct qed_chain *p_chain)\n{\n\treturn p_chain->capacity;\n}\n\n \nstatic inline void qed_chain_recycle_consumed(struct qed_chain *p_chain)\n{\n\ttest_and_skip(p_chain, prod_idx);\n\tif (is_chain_u16(p_chain))\n\t\tp_chain->u.chain16.prod_idx++;\n\telse\n\t\tp_chain->u.chain32.prod_idx++;\n}\n\n \nstatic inline void *qed_chain_consume(struct qed_chain *p_chain)\n{\n\tvoid *p_ret = NULL, *p_cons_idx, *p_cons_page_idx;\n\n\tif (is_chain_u16(p_chain)) {\n\t\tif ((p_chain->u.chain16.cons_idx &\n\t\t     p_chain->elem_per_page_mask) == p_chain->next_page_mask) {\n\t\t\tp_cons_idx = &p_chain->u.chain16.cons_idx;\n\t\t\tp_cons_page_idx = &p_chain->pbl.c.u16.cons_page_idx;\n\t\t\tqed_chain_advance_page(p_chain, &p_chain->p_cons_elem,\n\t\t\t\t\t       p_cons_idx, p_cons_page_idx);\n\t\t}\n\t\tp_chain->u.chain16.cons_idx++;\n\t} else {\n\t\tif ((p_chain->u.chain32.cons_idx &\n\t\t     p_chain->elem_per_page_mask) == p_chain->next_page_mask) {\n\t\t\tp_cons_idx = &p_chain->u.chain32.cons_idx;\n\t\t\tp_cons_page_idx = &p_chain->pbl.c.u32.cons_page_idx;\n\t\t\tqed_chain_advance_page(p_chain, &p_chain->p_cons_elem,\n\t\t\t\t\t       p_cons_idx, p_cons_page_idx);\n\t\t}\n\t\tp_chain->u.chain32.cons_idx++;\n\t}\n\n\tp_ret = p_chain->p_cons_elem;\n\tp_chain->p_cons_elem = (void *)(((u8 *)p_chain->p_cons_elem) +\n\t\t\t\t\tp_chain->elem_size);\n\n\treturn p_ret;\n}\n\n \nstatic inline void qed_chain_reset(struct qed_chain *p_chain)\n{\n\tu32 i;\n\n\tif (is_chain_u16(p_chain)) {\n\t\tp_chain->u.chain16.prod_idx = 0;\n\t\tp_chain->u.chain16.cons_idx = 0;\n\t} else {\n\t\tp_chain->u.chain32.prod_idx = 0;\n\t\tp_chain->u.chain32.cons_idx = 0;\n\t}\n\tp_chain->p_cons_elem = p_chain->p_virt_addr;\n\tp_chain->p_prod_elem = p_chain->p_virt_addr;\n\n\tif (p_chain->mode == QED_CHAIN_MODE_PBL) {\n\t\t \n\t\tu32 reset_val = p_chain->page_cnt - 1;\n\n\t\tif (is_chain_u16(p_chain)) {\n\t\t\tp_chain->pbl.c.u16.prod_page_idx = (u16)reset_val;\n\t\t\tp_chain->pbl.c.u16.cons_page_idx = (u16)reset_val;\n\t\t} else {\n\t\t\tp_chain->pbl.c.u32.prod_page_idx = reset_val;\n\t\t\tp_chain->pbl.c.u32.cons_page_idx = reset_val;\n\t\t}\n\t}\n\n\tswitch (p_chain->intended_use) {\n\tcase QED_CHAIN_USE_TO_CONSUME:\n\t\t \n\t\tfor (i = 0; i < p_chain->capacity; i++)\n\t\t\tqed_chain_recycle_consumed(p_chain);\n\t\tbreak;\n\n\tcase QED_CHAIN_USE_TO_CONSUME_PRODUCE:\n\tcase QED_CHAIN_USE_TO_PRODUCE:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\n \nstatic inline void *qed_chain_get_last_elem(struct qed_chain *p_chain)\n{\n\tstruct qed_chain_next *p_next = NULL;\n\tvoid *p_virt_addr = NULL;\n\tu32 size, last_page_idx;\n\n\tif (!p_chain->p_virt_addr)\n\t\tgoto out;\n\n\tswitch (p_chain->mode) {\n\tcase QED_CHAIN_MODE_NEXT_PTR:\n\t\tsize = p_chain->elem_size * p_chain->usable_per_page;\n\t\tp_virt_addr = p_chain->p_virt_addr;\n\t\tp_next = (struct qed_chain_next *)((u8 *)p_virt_addr + size);\n\t\twhile (p_next->next_virt != p_chain->p_virt_addr) {\n\t\t\tp_virt_addr = p_next->next_virt;\n\t\t\tp_next = (struct qed_chain_next *)((u8 *)p_virt_addr +\n\t\t\t\t\t\t\t   size);\n\t\t}\n\t\tbreak;\n\tcase QED_CHAIN_MODE_SINGLE:\n\t\tp_virt_addr = p_chain->p_virt_addr;\n\t\tbreak;\n\tcase QED_CHAIN_MODE_PBL:\n\t\tlast_page_idx = p_chain->page_cnt - 1;\n\t\tp_virt_addr = p_chain->pbl.pp_addr_tbl[last_page_idx].virt_addr;\n\t\tbreak;\n\t}\n\t \n\tsize = p_chain->elem_size * (p_chain->usable_per_page - 1);\n\tp_virt_addr = (u8 *)p_virt_addr + size;\nout:\n\treturn p_virt_addr;\n}\n\n \nstatic inline void qed_chain_set_prod(struct qed_chain *p_chain,\n\t\t\t\t      u32 prod_idx, void *p_prod_elem)\n{\n\tif (p_chain->mode == QED_CHAIN_MODE_PBL) {\n\t\tu32 cur_prod, page_mask, page_cnt, page_diff;\n\n\t\tcur_prod = is_chain_u16(p_chain) ? p_chain->u.chain16.prod_idx :\n\t\t\t   p_chain->u.chain32.prod_idx;\n\n\t\t \n\t\tpage_mask = ~p_chain->elem_per_page_mask;\n\n\t\t \n\t\tpage_diff = (((cur_prod - 1) & page_mask) -\n\t\t\t     ((prod_idx - 1) & page_mask)) /\n\t\t\t    p_chain->elem_per_page;\n\n\t\tpage_cnt = qed_chain_get_page_cnt(p_chain);\n\t\tif (is_chain_u16(p_chain))\n\t\t\tp_chain->pbl.c.u16.prod_page_idx =\n\t\t\t\t(p_chain->pbl.c.u16.prod_page_idx -\n\t\t\t\t page_diff + page_cnt) % page_cnt;\n\t\telse\n\t\t\tp_chain->pbl.c.u32.prod_page_idx =\n\t\t\t\t(p_chain->pbl.c.u32.prod_page_idx -\n\t\t\t\t page_diff + page_cnt) % page_cnt;\n\t}\n\n\tif (is_chain_u16(p_chain))\n\t\tp_chain->u.chain16.prod_idx = (u16) prod_idx;\n\telse\n\t\tp_chain->u.chain32.prod_idx = prod_idx;\n\tp_chain->p_prod_elem = p_prod_elem;\n}\n\n \nstatic inline void qed_chain_pbl_zero_mem(struct qed_chain *p_chain)\n{\n\tu32 i, page_cnt;\n\n\tif (p_chain->mode != QED_CHAIN_MODE_PBL)\n\t\treturn;\n\n\tpage_cnt = qed_chain_get_page_cnt(p_chain);\n\n\tfor (i = 0; i < page_cnt; i++)\n\t\tmemset(p_chain->pbl.pp_addr_tbl[i].virt_addr, 0,\n\t\t       p_chain->page_size);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}