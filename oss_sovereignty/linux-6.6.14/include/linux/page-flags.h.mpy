{
  "module_name": "page-flags.h",
  "hash_id": "96240531a20e1f4d5706e2f035c16116d85fdd38c53fc7c2631c9626f48c3571",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/page-flags.h",
  "human_readable_source": " \n \n\n#ifndef PAGE_FLAGS_H\n#define PAGE_FLAGS_H\n\n#include <linux/types.h>\n#include <linux/bug.h>\n#include <linux/mmdebug.h>\n#ifndef __GENERATING_BOUNDS_H\n#include <linux/mm_types.h>\n#include <generated/bounds.h>\n#endif  \n\n \n\n \nenum pageflags {\n\tPG_locked,\t\t \n\tPG_writeback,\t\t \n\tPG_referenced,\n\tPG_uptodate,\n\tPG_dirty,\n\tPG_lru,\n\tPG_head,\t\t \n\tPG_waiters,\t\t \n\tPG_active,\n\tPG_workingset,\n\tPG_error,\n\tPG_slab,\n\tPG_owner_priv_1,\t \n\tPG_arch_1,\n\tPG_reserved,\n\tPG_private,\t\t \n\tPG_private_2,\t\t \n\tPG_mappedtodisk,\t \n\tPG_reclaim,\t\t \n\tPG_swapbacked,\t\t \n\tPG_unevictable,\t\t \n#ifdef CONFIG_MMU\n\tPG_mlocked,\t\t \n#endif\n#ifdef CONFIG_ARCH_USES_PG_UNCACHED\n\tPG_uncached,\t\t \n#endif\n#ifdef CONFIG_MEMORY_FAILURE\n\tPG_hwpoison,\t\t \n#endif\n#if defined(CONFIG_PAGE_IDLE_FLAG) && defined(CONFIG_64BIT)\n\tPG_young,\n\tPG_idle,\n#endif\n#ifdef CONFIG_ARCH_USES_PG_ARCH_X\n\tPG_arch_2,\n\tPG_arch_3,\n#endif\n\t__NR_PAGEFLAGS,\n\n\tPG_readahead = PG_reclaim,\n\n\t \n\tPG_anon_exclusive = PG_mappedtodisk,\n\n\t \n\tPG_checked = PG_owner_priv_1,\n\n\t \n\tPG_swapcache = PG_owner_priv_1,\t \n\n\t \n\tPG_fscache = PG_private_2,\t \n\n\t \n\t \n\tPG_pinned = PG_owner_priv_1,\n\t \n\tPG_savepinned = PG_dirty,\n\t \n\tPG_foreign = PG_owner_priv_1,\n\t \n\tPG_xen_remapped = PG_owner_priv_1,\n\n\t \n\tPG_isolated = PG_reclaim,\n\n\t \n\tPG_reported = PG_uptodate,\n\n#ifdef CONFIG_MEMORY_HOTPLUG\n\t \n\tPG_vmemmap_self_hosted = PG_owner_priv_1,\n#endif\n\n\t \n\n\t \n\tPG_has_hwpoisoned = PG_error,\n\tPG_hugetlb = PG_active,\n\tPG_large_rmappable = PG_workingset,  \n};\n\n#define PAGEFLAGS_MASK\t\t((1UL << NR_PAGEFLAGS) - 1)\n\n#ifndef __GENERATING_BOUNDS_H\n\n#ifdef CONFIG_HUGETLB_PAGE_OPTIMIZE_VMEMMAP\nDECLARE_STATIC_KEY_FALSE(hugetlb_optimize_vmemmap_key);\n\n \nstatic __always_inline const struct page *page_fixed_fake_head(const struct page *page)\n{\n\tif (!static_branch_unlikely(&hugetlb_optimize_vmemmap_key))\n\t\treturn page;\n\n\t \n\tif (IS_ALIGNED((unsigned long)page, PAGE_SIZE) &&\n\t    test_bit(PG_head, &page->flags)) {\n\t\t \n\t\tunsigned long head = READ_ONCE(page[1].compound_head);\n\n\t\tif (likely(head & 1))\n\t\t\treturn (const struct page *)(head - 1);\n\t}\n\treturn page;\n}\n#else\nstatic inline const struct page *page_fixed_fake_head(const struct page *page)\n{\n\treturn page;\n}\n#endif\n\nstatic __always_inline int page_is_fake_head(struct page *page)\n{\n\treturn page_fixed_fake_head(page) != page;\n}\n\nstatic inline unsigned long _compound_head(const struct page *page)\n{\n\tunsigned long head = READ_ONCE(page->compound_head);\n\n\tif (unlikely(head & 1))\n\t\treturn head - 1;\n\treturn (unsigned long)page_fixed_fake_head(page);\n}\n\n#define compound_head(page)\t((typeof(page))_compound_head(page))\n\n \n#define page_folio(p)\t\t(_Generic((p),\t\t\t\t\\\n\tconst struct page *:\t(const struct folio *)_compound_head(p), \\\n\tstruct page *:\t\t(struct folio *)_compound_head(p)))\n\n \n#define folio_page(folio, n)\tnth_page(&(folio)->page, n)\n\nstatic __always_inline int PageTail(struct page *page)\n{\n\treturn READ_ONCE(page->compound_head) & 1 || page_is_fake_head(page);\n}\n\nstatic __always_inline int PageCompound(struct page *page)\n{\n\treturn test_bit(PG_head, &page->flags) ||\n\t       READ_ONCE(page->compound_head) & 1;\n}\n\n#define\tPAGE_POISON_PATTERN\t-1l\nstatic inline int PagePoisoned(const struct page *page)\n{\n\treturn READ_ONCE(page->flags) == PAGE_POISON_PATTERN;\n}\n\n#ifdef CONFIG_DEBUG_VM\nvoid page_init_poison(struct page *page, size_t size);\n#else\nstatic inline void page_init_poison(struct page *page, size_t size)\n{\n}\n#endif\n\nstatic unsigned long *folio_flags(struct folio *folio, unsigned n)\n{\n\tstruct page *page = &folio->page;\n\n\tVM_BUG_ON_PGFLAGS(PageTail(page), page);\n\tVM_BUG_ON_PGFLAGS(n > 0 && !test_bit(PG_head, &page->flags), page);\n\treturn &page[n].flags;\n}\n\n \n#define PF_POISONED_CHECK(page) ({\t\t\t\t\t\\\n\t\tVM_BUG_ON_PGFLAGS(PagePoisoned(page), page);\t\t\\\n\t\tpage; })\n#define PF_ANY(page, enforce)\tPF_POISONED_CHECK(page)\n#define PF_HEAD(page, enforce)\tPF_POISONED_CHECK(compound_head(page))\n#define PF_ONLY_HEAD(page, enforce) ({\t\t\t\t\t\\\n\t\tVM_BUG_ON_PGFLAGS(PageTail(page), page);\t\t\\\n\t\tPF_POISONED_CHECK(page); })\n#define PF_NO_TAIL(page, enforce) ({\t\t\t\t\t\\\n\t\tVM_BUG_ON_PGFLAGS(enforce && PageTail(page), page);\t\\\n\t\tPF_POISONED_CHECK(compound_head(page)); })\n#define PF_NO_COMPOUND(page, enforce) ({\t\t\t\t\\\n\t\tVM_BUG_ON_PGFLAGS(enforce && PageCompound(page), page);\t\\\n\t\tPF_POISONED_CHECK(page); })\n#define PF_SECOND(page, enforce) ({\t\t\t\t\t\\\n\t\tVM_BUG_ON_PGFLAGS(!PageHead(page), page);\t\t\\\n\t\tPF_POISONED_CHECK(&page[1]); })\n\n \n#define FOLIO_PF_ANY\t\t0\n#define FOLIO_PF_HEAD\t\t0\n#define FOLIO_PF_ONLY_HEAD\t0\n#define FOLIO_PF_NO_TAIL\t0\n#define FOLIO_PF_NO_COMPOUND\t0\n#define FOLIO_PF_SECOND\t\t1\n\n \n#define TESTPAGEFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline bool folio_test_##lname(struct folio *folio)\t\\\n{ return test_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); }\t\\\nstatic __always_inline int Page##uname(struct page *page)\t\t\\\n{ return test_bit(PG_##lname, &policy(page, 0)->flags); }\n\n#define SETPAGEFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline\t\t\t\t\t\t\t\\\nvoid folio_set_##lname(struct folio *folio)\t\t\t\t\\\n{ set_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); }\t\t\\\nstatic __always_inline void SetPage##uname(struct page *page)\t\t\\\n{ set_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define CLEARPAGEFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline\t\t\t\t\t\t\t\\\nvoid folio_clear_##lname(struct folio *folio)\t\t\t\t\\\n{ clear_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); }\t\t\\\nstatic __always_inline void ClearPage##uname(struct page *page)\t\t\\\n{ clear_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define __SETPAGEFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline\t\t\t\t\t\t\t\\\nvoid __folio_set_##lname(struct folio *folio)\t\t\t\t\\\n{ __set_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); }\t\t\\\nstatic __always_inline void __SetPage##uname(struct page *page)\t\t\\\n{ __set_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define __CLEARPAGEFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline\t\t\t\t\t\t\t\\\nvoid __folio_clear_##lname(struct folio *folio)\t\t\t\t\\\n{ __clear_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); }\t\\\nstatic __always_inline void __ClearPage##uname(struct page *page)\t\\\n{ __clear_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define TESTSETFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline\t\t\t\t\t\t\t\\\nbool folio_test_set_##lname(struct folio *folio)\t\t\t\\\n{ return test_and_set_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); } \\\nstatic __always_inline int TestSetPage##uname(struct page *page)\t\\\n{ return test_and_set_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define TESTCLEARFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline\t\t\t\t\t\t\t\\\nbool folio_test_clear_##lname(struct folio *folio)\t\t\t\\\n{ return test_and_clear_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); } \\\nstatic __always_inline int TestClearPage##uname(struct page *page)\t\\\n{ return test_and_clear_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define PAGEFLAG(uname, lname, policy)\t\t\t\t\t\\\n\tTESTPAGEFLAG(uname, lname, policy)\t\t\t\t\\\n\tSETPAGEFLAG(uname, lname, policy)\t\t\t\t\\\n\tCLEARPAGEFLAG(uname, lname, policy)\n\n#define __PAGEFLAG(uname, lname, policy)\t\t\t\t\\\n\tTESTPAGEFLAG(uname, lname, policy)\t\t\t\t\\\n\t__SETPAGEFLAG(uname, lname, policy)\t\t\t\t\\\n\t__CLEARPAGEFLAG(uname, lname, policy)\n\n#define TESTSCFLAG(uname, lname, policy)\t\t\t\t\\\n\tTESTSETFLAG(uname, lname, policy)\t\t\t\t\\\n\tTESTCLEARFLAG(uname, lname, policy)\n\n#define TESTPAGEFLAG_FALSE(uname, lname)\t\t\t\t\\\nstatic inline bool folio_test_##lname(const struct folio *folio) { return false; } \\\nstatic inline int Page##uname(const struct page *page) { return 0; }\n\n#define SETPAGEFLAG_NOOP(uname, lname)\t\t\t\t\t\\\nstatic inline void folio_set_##lname(struct folio *folio) { }\t\t\\\nstatic inline void SetPage##uname(struct page *page) {  }\n\n#define CLEARPAGEFLAG_NOOP(uname, lname)\t\t\t\t\\\nstatic inline void folio_clear_##lname(struct folio *folio) { }\t\t\\\nstatic inline void ClearPage##uname(struct page *page) {  }\n\n#define __CLEARPAGEFLAG_NOOP(uname, lname)\t\t\t\t\\\nstatic inline void __folio_clear_##lname(struct folio *folio) { }\t\\\nstatic inline void __ClearPage##uname(struct page *page) {  }\n\n#define TESTSETFLAG_FALSE(uname, lname)\t\t\t\t\t\\\nstatic inline bool folio_test_set_##lname(struct folio *folio)\t\t\\\n{ return 0; }\t\t\t\t\t\t\t\t\\\nstatic inline int TestSetPage##uname(struct page *page) { return 0; }\n\n#define TESTCLEARFLAG_FALSE(uname, lname)\t\t\t\t\\\nstatic inline bool folio_test_clear_##lname(struct folio *folio)\t\\\n{ return 0; }\t\t\t\t\t\t\t\t\\\nstatic inline int TestClearPage##uname(struct page *page) { return 0; }\n\n#define PAGEFLAG_FALSE(uname, lname) TESTPAGEFLAG_FALSE(uname, lname)\t\\\n\tSETPAGEFLAG_NOOP(uname, lname) CLEARPAGEFLAG_NOOP(uname, lname)\n\n#define TESTSCFLAG_FALSE(uname, lname)\t\t\t\t\t\\\n\tTESTSETFLAG_FALSE(uname, lname) TESTCLEARFLAG_FALSE(uname, lname)\n\n__PAGEFLAG(Locked, locked, PF_NO_TAIL)\nPAGEFLAG(Waiters, waiters, PF_ONLY_HEAD)\nPAGEFLAG(Error, error, PF_NO_TAIL) TESTCLEARFLAG(Error, error, PF_NO_TAIL)\nPAGEFLAG(Referenced, referenced, PF_HEAD)\n\tTESTCLEARFLAG(Referenced, referenced, PF_HEAD)\n\t__SETPAGEFLAG(Referenced, referenced, PF_HEAD)\nPAGEFLAG(Dirty, dirty, PF_HEAD) TESTSCFLAG(Dirty, dirty, PF_HEAD)\n\t__CLEARPAGEFLAG(Dirty, dirty, PF_HEAD)\nPAGEFLAG(LRU, lru, PF_HEAD) __CLEARPAGEFLAG(LRU, lru, PF_HEAD)\n\tTESTCLEARFLAG(LRU, lru, PF_HEAD)\nPAGEFLAG(Active, active, PF_HEAD) __CLEARPAGEFLAG(Active, active, PF_HEAD)\n\tTESTCLEARFLAG(Active, active, PF_HEAD)\nPAGEFLAG(Workingset, workingset, PF_HEAD)\n\tTESTCLEARFLAG(Workingset, workingset, PF_HEAD)\n__PAGEFLAG(Slab, slab, PF_NO_TAIL)\nPAGEFLAG(Checked, checked, PF_NO_COMPOUND)\t    \n\n \nPAGEFLAG(Pinned, pinned, PF_NO_COMPOUND)\n\tTESTSCFLAG(Pinned, pinned, PF_NO_COMPOUND)\nPAGEFLAG(SavePinned, savepinned, PF_NO_COMPOUND);\nPAGEFLAG(Foreign, foreign, PF_NO_COMPOUND);\nPAGEFLAG(XenRemapped, xen_remapped, PF_NO_COMPOUND)\n\tTESTCLEARFLAG(XenRemapped, xen_remapped, PF_NO_COMPOUND)\n\nPAGEFLAG(Reserved, reserved, PF_NO_COMPOUND)\n\t__CLEARPAGEFLAG(Reserved, reserved, PF_NO_COMPOUND)\n\t__SETPAGEFLAG(Reserved, reserved, PF_NO_COMPOUND)\nPAGEFLAG(SwapBacked, swapbacked, PF_NO_TAIL)\n\t__CLEARPAGEFLAG(SwapBacked, swapbacked, PF_NO_TAIL)\n\t__SETPAGEFLAG(SwapBacked, swapbacked, PF_NO_TAIL)\n\n \nPAGEFLAG(Private, private, PF_ANY)\nPAGEFLAG(Private2, private_2, PF_ANY) TESTSCFLAG(Private2, private_2, PF_ANY)\nPAGEFLAG(OwnerPriv1, owner_priv_1, PF_ANY)\n\tTESTCLEARFLAG(OwnerPriv1, owner_priv_1, PF_ANY)\n\n \nTESTPAGEFLAG(Writeback, writeback, PF_NO_TAIL)\n\tTESTSCFLAG(Writeback, writeback, PF_NO_TAIL)\nPAGEFLAG(MappedToDisk, mappedtodisk, PF_NO_TAIL)\n\n \nPAGEFLAG(Reclaim, reclaim, PF_NO_TAIL)\n\tTESTCLEARFLAG(Reclaim, reclaim, PF_NO_TAIL)\nPAGEFLAG(Readahead, readahead, PF_NO_COMPOUND)\n\tTESTCLEARFLAG(Readahead, readahead, PF_NO_COMPOUND)\n\n#ifdef CONFIG_HIGHMEM\n \n#define PageHighMem(__p) is_highmem_idx(page_zonenum(__p))\n#define folio_test_highmem(__f)\tis_highmem_idx(folio_zonenum(__f))\n#else\nPAGEFLAG_FALSE(HighMem, highmem)\n#endif\n\n#ifdef CONFIG_SWAP\nstatic __always_inline bool folio_test_swapcache(struct folio *folio)\n{\n\treturn folio_test_swapbacked(folio) &&\n\t\t\ttest_bit(PG_swapcache, folio_flags(folio, 0));\n}\n\nstatic __always_inline bool PageSwapCache(struct page *page)\n{\n\treturn folio_test_swapcache(page_folio(page));\n}\n\nSETPAGEFLAG(SwapCache, swapcache, PF_NO_TAIL)\nCLEARPAGEFLAG(SwapCache, swapcache, PF_NO_TAIL)\n#else\nPAGEFLAG_FALSE(SwapCache, swapcache)\n#endif\n\nPAGEFLAG(Unevictable, unevictable, PF_HEAD)\n\t__CLEARPAGEFLAG(Unevictable, unevictable, PF_HEAD)\n\tTESTCLEARFLAG(Unevictable, unevictable, PF_HEAD)\n\n#ifdef CONFIG_MMU\nPAGEFLAG(Mlocked, mlocked, PF_NO_TAIL)\n\t__CLEARPAGEFLAG(Mlocked, mlocked, PF_NO_TAIL)\n\tTESTSCFLAG(Mlocked, mlocked, PF_NO_TAIL)\n#else\nPAGEFLAG_FALSE(Mlocked, mlocked) __CLEARPAGEFLAG_NOOP(Mlocked, mlocked)\n\tTESTSCFLAG_FALSE(Mlocked, mlocked)\n#endif\n\n#ifdef CONFIG_ARCH_USES_PG_UNCACHED\nPAGEFLAG(Uncached, uncached, PF_NO_COMPOUND)\n#else\nPAGEFLAG_FALSE(Uncached, uncached)\n#endif\n\n#ifdef CONFIG_MEMORY_FAILURE\nPAGEFLAG(HWPoison, hwpoison, PF_ANY)\nTESTSCFLAG(HWPoison, hwpoison, PF_ANY)\n#define __PG_HWPOISON (1UL << PG_hwpoison)\n#define MAGIC_HWPOISON\t0x48575053U\t \nextern void SetPageHWPoisonTakenOff(struct page *page);\nextern void ClearPageHWPoisonTakenOff(struct page *page);\nextern bool take_page_off_buddy(struct page *page);\nextern bool put_page_back_buddy(struct page *page);\n#else\nPAGEFLAG_FALSE(HWPoison, hwpoison)\n#define __PG_HWPOISON 0\n#endif\n\n#if defined(CONFIG_PAGE_IDLE_FLAG) && defined(CONFIG_64BIT)\nTESTPAGEFLAG(Young, young, PF_ANY)\nSETPAGEFLAG(Young, young, PF_ANY)\nTESTCLEARFLAG(Young, young, PF_ANY)\nPAGEFLAG(Idle, idle, PF_ANY)\n#endif\n\n \n__PAGEFLAG(Reported, reported, PF_NO_COMPOUND)\n\n#ifdef CONFIG_MEMORY_HOTPLUG\nPAGEFLAG(VmemmapSelfHosted, vmemmap_self_hosted, PF_ANY)\n#else\nPAGEFLAG_FALSE(VmemmapSelfHosted, vmemmap_self_hosted)\n#endif\n\n \n#define PAGE_MAPPING_ANON\t0x1\n#define PAGE_MAPPING_MOVABLE\t0x2\n#define PAGE_MAPPING_KSM\t(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)\n#define PAGE_MAPPING_FLAGS\t(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)\n\n \n#define PAGE_MAPPING_DAX_SHARED\t((void *)0x1)\n\nstatic __always_inline bool folio_mapping_flags(struct folio *folio)\n{\n\treturn ((unsigned long)folio->mapping & PAGE_MAPPING_FLAGS) != 0;\n}\n\nstatic __always_inline int PageMappingFlags(struct page *page)\n{\n\treturn ((unsigned long)page->mapping & PAGE_MAPPING_FLAGS) != 0;\n}\n\nstatic __always_inline bool folio_test_anon(struct folio *folio)\n{\n\treturn ((unsigned long)folio->mapping & PAGE_MAPPING_ANON) != 0;\n}\n\nstatic __always_inline bool PageAnon(struct page *page)\n{\n\treturn folio_test_anon(page_folio(page));\n}\n\nstatic __always_inline bool __folio_test_movable(const struct folio *folio)\n{\n\treturn ((unsigned long)folio->mapping & PAGE_MAPPING_FLAGS) ==\n\t\t\tPAGE_MAPPING_MOVABLE;\n}\n\nstatic __always_inline int __PageMovable(struct page *page)\n{\n\treturn ((unsigned long)page->mapping & PAGE_MAPPING_FLAGS) ==\n\t\t\t\tPAGE_MAPPING_MOVABLE;\n}\n\n#ifdef CONFIG_KSM\n \nstatic __always_inline bool folio_test_ksm(struct folio *folio)\n{\n\treturn ((unsigned long)folio->mapping & PAGE_MAPPING_FLAGS) ==\n\t\t\t\tPAGE_MAPPING_KSM;\n}\n\nstatic __always_inline bool PageKsm(struct page *page)\n{\n\treturn folio_test_ksm(page_folio(page));\n}\n#else\nTESTPAGEFLAG_FALSE(Ksm, ksm)\n#endif\n\nu64 stable_page_flags(struct page *page);\n\n \nstatic inline bool folio_test_uptodate(struct folio *folio)\n{\n\tbool ret = test_bit(PG_uptodate, folio_flags(folio, 0));\n\t \n\tif (ret)\n\t\tsmp_rmb();\n\n\treturn ret;\n}\n\nstatic inline int PageUptodate(struct page *page)\n{\n\treturn folio_test_uptodate(page_folio(page));\n}\n\nstatic __always_inline void __folio_mark_uptodate(struct folio *folio)\n{\n\tsmp_wmb();\n\t__set_bit(PG_uptodate, folio_flags(folio, 0));\n}\n\nstatic __always_inline void folio_mark_uptodate(struct folio *folio)\n{\n\t \n\tsmp_wmb();\n\tset_bit(PG_uptodate, folio_flags(folio, 0));\n}\n\nstatic __always_inline void __SetPageUptodate(struct page *page)\n{\n\t__folio_mark_uptodate((struct folio *)page);\n}\n\nstatic __always_inline void SetPageUptodate(struct page *page)\n{\n\tfolio_mark_uptodate((struct folio *)page);\n}\n\nCLEARPAGEFLAG(Uptodate, uptodate, PF_NO_TAIL)\n\nbool __folio_start_writeback(struct folio *folio, bool keep_write);\nbool set_page_writeback(struct page *page);\n\n#define folio_start_writeback(folio)\t\t\t\\\n\t__folio_start_writeback(folio, false)\n#define folio_start_writeback_keepwrite(folio)\t\\\n\t__folio_start_writeback(folio, true)\n\nstatic inline bool test_set_page_writeback(struct page *page)\n{\n\treturn set_page_writeback(page);\n}\n\nstatic __always_inline bool folio_test_head(struct folio *folio)\n{\n\treturn test_bit(PG_head, folio_flags(folio, FOLIO_PF_ANY));\n}\n\nstatic __always_inline int PageHead(struct page *page)\n{\n\tPF_POISONED_CHECK(page);\n\treturn test_bit(PG_head, &page->flags) && !page_is_fake_head(page);\n}\n\n__SETPAGEFLAG(Head, head, PF_ANY)\n__CLEARPAGEFLAG(Head, head, PF_ANY)\nCLEARPAGEFLAG(Head, head, PF_ANY)\n\n \nstatic inline bool folio_test_large(struct folio *folio)\n{\n\treturn folio_test_head(folio);\n}\n\nstatic __always_inline void set_compound_head(struct page *page, struct page *head)\n{\n\tWRITE_ONCE(page->compound_head, (unsigned long)head + 1);\n}\n\nstatic __always_inline void clear_compound_head(struct page *page)\n{\n\tWRITE_ONCE(page->compound_head, 0);\n}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline void ClearPageCompound(struct page *page)\n{\n\tBUG_ON(!PageHead(page));\n\tClearPageHead(page);\n}\nPAGEFLAG(LargeRmappable, large_rmappable, PF_SECOND)\n#else\nTESTPAGEFLAG_FALSE(LargeRmappable, large_rmappable)\n#endif\n\n#define PG_head_mask ((1UL << PG_head))\n\n#ifdef CONFIG_HUGETLB_PAGE\nint PageHuge(struct page *page);\nSETPAGEFLAG(HugeTLB, hugetlb, PF_SECOND)\nCLEARPAGEFLAG(HugeTLB, hugetlb, PF_SECOND)\n\n \nstatic inline bool folio_test_hugetlb(struct folio *folio)\n{\n\treturn folio_test_large(folio) &&\n\t\ttest_bit(PG_hugetlb, folio_flags(folio, 1));\n}\n#else\nTESTPAGEFLAG_FALSE(Huge, hugetlb)\n#endif\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n \nstatic inline int PageTransHuge(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\treturn PageHead(page);\n}\n\n \nstatic inline int PageTransCompound(struct page *page)\n{\n\treturn PageCompound(page);\n}\n\n \nstatic inline int PageTransTail(struct page *page)\n{\n\treturn PageTail(page);\n}\n#else\nTESTPAGEFLAG_FALSE(TransHuge, transhuge)\nTESTPAGEFLAG_FALSE(TransCompound, transcompound)\nTESTPAGEFLAG_FALSE(TransCompoundMap, transcompoundmap)\nTESTPAGEFLAG_FALSE(TransTail, transtail)\n#endif\n\n#if defined(CONFIG_MEMORY_FAILURE) && defined(CONFIG_TRANSPARENT_HUGEPAGE)\n \nPAGEFLAG(HasHWPoisoned, has_hwpoisoned, PF_SECOND)\n\tTESTSCFLAG(HasHWPoisoned, has_hwpoisoned, PF_SECOND)\n#else\nPAGEFLAG_FALSE(HasHWPoisoned, has_hwpoisoned)\n\tTESTSCFLAG_FALSE(HasHWPoisoned, has_hwpoisoned)\n#endif\n\n \nstatic inline bool is_page_hwpoison(struct page *page)\n{\n\tif (PageHWPoison(page))\n\t\treturn true;\n\treturn PageHuge(page) && PageHWPoison(compound_head(page));\n}\n\n \n\n#define PAGE_TYPE_BASE\t0xf0000000\n \n#define PAGE_MAPCOUNT_RESERVE\t-128\n#define PG_buddy\t0x00000080\n#define PG_offline\t0x00000100\n#define PG_table\t0x00000200\n#define PG_guard\t0x00000400\n\n#define PageType(page, flag)\t\t\t\t\t\t\\\n\t((page->page_type & (PAGE_TYPE_BASE | flag)) == PAGE_TYPE_BASE)\n#define folio_test_type(folio, flag)\t\t\t\t\t\\\n\t((folio->page.page_type & (PAGE_TYPE_BASE | flag)) == PAGE_TYPE_BASE)\n\nstatic inline int page_type_has_type(unsigned int page_type)\n{\n\treturn (int)page_type < PAGE_MAPCOUNT_RESERVE;\n}\n\nstatic inline int page_has_type(struct page *page)\n{\n\treturn page_type_has_type(page->page_type);\n}\n\n#define PAGE_TYPE_OPS(uname, lname, fname)\t\t\t\t\\\nstatic __always_inline int Page##uname(const struct page *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn PageType(page, PG_##lname);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline int folio_test_##fname(const struct folio *folio)\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn folio_test_type(folio, PG_##lname);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline void __SetPage##uname(struct page *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tVM_BUG_ON_PAGE(!PageType(page, 0), page);\t\t\t\\\n\tpage->page_type &= ~PG_##lname;\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline void __folio_set_##fname(struct folio *folio)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tVM_BUG_ON_FOLIO(!folio_test_type(folio, 0), folio);\t\t\\\n\tfolio->page.page_type &= ~PG_##lname;\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline void __ClearPage##uname(struct page *page)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tVM_BUG_ON_PAGE(!Page##uname(page), page);\t\t\t\\\n\tpage->page_type |= PG_##lname;\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline void __folio_clear_##fname(struct folio *folio)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tVM_BUG_ON_FOLIO(!folio_test_##fname(folio), folio);\t\t\\\n\tfolio->page.page_type |= PG_##lname;\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n \nPAGE_TYPE_OPS(Buddy, buddy, buddy)\n\n \nPAGE_TYPE_OPS(Offline, offline, offline)\n\nextern void page_offline_freeze(void);\nextern void page_offline_thaw(void);\nextern void page_offline_begin(void);\nextern void page_offline_end(void);\n\n \nPAGE_TYPE_OPS(Table, table, pgtable)\n\n \nPAGE_TYPE_OPS(Guard, guard, guard)\n\nextern bool is_free_buddy_page(struct page *page);\n\nPAGEFLAG(Isolated, isolated, PF_ANY);\n\nstatic __always_inline int PageAnonExclusive(struct page *page)\n{\n\tVM_BUG_ON_PGFLAGS(!PageAnon(page), page);\n\tVM_BUG_ON_PGFLAGS(PageHuge(page) && !PageHead(page), page);\n\treturn test_bit(PG_anon_exclusive, &PF_ANY(page, 1)->flags);\n}\n\nstatic __always_inline void SetPageAnonExclusive(struct page *page)\n{\n\tVM_BUG_ON_PGFLAGS(!PageAnon(page) || PageKsm(page), page);\n\tVM_BUG_ON_PGFLAGS(PageHuge(page) && !PageHead(page), page);\n\tset_bit(PG_anon_exclusive, &PF_ANY(page, 1)->flags);\n}\n\nstatic __always_inline void ClearPageAnonExclusive(struct page *page)\n{\n\tVM_BUG_ON_PGFLAGS(!PageAnon(page) || PageKsm(page), page);\n\tVM_BUG_ON_PGFLAGS(PageHuge(page) && !PageHead(page), page);\n\tclear_bit(PG_anon_exclusive, &PF_ANY(page, 1)->flags);\n}\n\nstatic __always_inline void __ClearPageAnonExclusive(struct page *page)\n{\n\tVM_BUG_ON_PGFLAGS(!PageAnon(page), page);\n\tVM_BUG_ON_PGFLAGS(PageHuge(page) && !PageHead(page), page);\n\t__clear_bit(PG_anon_exclusive, &PF_ANY(page, 1)->flags);\n}\n\n#ifdef CONFIG_MMU\n#define __PG_MLOCKED\t\t(1UL << PG_mlocked)\n#else\n#define __PG_MLOCKED\t\t0\n#endif\n\n \n#define PAGE_FLAGS_CHECK_AT_FREE\t\t\t\t\\\n\t(1UL << PG_lru\t\t| 1UL << PG_locked\t|\t\\\n\t 1UL << PG_private\t| 1UL << PG_private_2\t|\t\\\n\t 1UL << PG_writeback\t| 1UL << PG_reserved\t|\t\\\n\t 1UL << PG_slab\t\t| 1UL << PG_active \t|\t\\\n\t 1UL << PG_unevictable\t| __PG_MLOCKED | LRU_GEN_MASK)\n\n \n#define PAGE_FLAGS_CHECK_AT_PREP\t\\\n\t((PAGEFLAGS_MASK & ~__PG_HWPOISON) | LRU_GEN_MASK | LRU_REFS_MASK)\n\n \n#define PAGE_FLAGS_SECOND\t\t\t\t\t\t\\\n\t(0xffUL  \t\t| 1UL << PG_has_hwpoisoned |\t\\\n\t 1UL << PG_hugetlb\t\t| 1UL << PG_large_rmappable)\n\n#define PAGE_FLAGS_PRIVATE\t\t\t\t\\\n\t(1UL << PG_private | 1UL << PG_private_2)\n \nstatic inline int page_has_private(struct page *page)\n{\n\treturn !!(page->flags & PAGE_FLAGS_PRIVATE);\n}\n\nstatic inline bool folio_has_private(struct folio *folio)\n{\n\treturn page_has_private(&folio->page);\n}\n\n#undef PF_ANY\n#undef PF_HEAD\n#undef PF_ONLY_HEAD\n#undef PF_NO_TAIL\n#undef PF_NO_COMPOUND\n#undef PF_SECOND\n#endif  \n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}