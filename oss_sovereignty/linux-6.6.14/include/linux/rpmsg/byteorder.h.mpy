{
  "module_name": "byteorder.h",
  "hash_id": "9f3aeafbdb4ba48ac29ae7ec18e1a8b506742f2ec40a1850eb9d143f14ee22c8",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/rpmsg/byteorder.h",
  "human_readable_source": " \n \n#ifndef _LINUX_RPMSG_BYTEORDER_H\n#define _LINUX_RPMSG_BYTEORDER_H\n#include <linux/types.h>\n#include <uapi/linux/rpmsg_types.h>\n\nstatic inline bool rpmsg_is_little_endian(void)\n{\n#ifdef __LITTLE_ENDIAN\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\nstatic inline u16 __rpmsg16_to_cpu(bool little_endian, __rpmsg16 val)\n{\n\tif (little_endian)\n\t\treturn le16_to_cpu((__force __le16)val);\n\telse\n\t\treturn be16_to_cpu((__force __be16)val);\n}\n\nstatic inline __rpmsg16 __cpu_to_rpmsg16(bool little_endian, u16 val)\n{\n\tif (little_endian)\n\t\treturn (__force __rpmsg16)cpu_to_le16(val);\n\telse\n\t\treturn (__force __rpmsg16)cpu_to_be16(val);\n}\n\nstatic inline u32 __rpmsg32_to_cpu(bool little_endian, __rpmsg32 val)\n{\n\tif (little_endian)\n\t\treturn le32_to_cpu((__force __le32)val);\n\telse\n\t\treturn be32_to_cpu((__force __be32)val);\n}\n\nstatic inline __rpmsg32 __cpu_to_rpmsg32(bool little_endian, u32 val)\n{\n\tif (little_endian)\n\t\treturn (__force __rpmsg32)cpu_to_le32(val);\n\telse\n\t\treturn (__force __rpmsg32)cpu_to_be32(val);\n}\n\nstatic inline u64 __rpmsg64_to_cpu(bool little_endian, __rpmsg64 val)\n{\n\tif (little_endian)\n\t\treturn le64_to_cpu((__force __le64)val);\n\telse\n\t\treturn be64_to_cpu((__force __be64)val);\n}\n\nstatic inline __rpmsg64 __cpu_to_rpmsg64(bool little_endian, u64 val)\n{\n\tif (little_endian)\n\t\treturn (__force __rpmsg64)cpu_to_le64(val);\n\telse\n\t\treturn (__force __rpmsg64)cpu_to_be64(val);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}