{
  "module_name": "lockd.h",
  "hash_id": "a4f76734ced37c0af2e3dd06912df736e5b737e7cedf5385dec45471ad50cf13",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/lockd/lockd.h",
  "human_readable_source": " \n \n\n#ifndef LINUX_LOCKD_LOCKD_H\n#define LINUX_LOCKD_LOCKD_H\n\n \n\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <net/ipv6.h>\n#include <linux/fs.h>\n#include <linux/kref.h>\n#include <linux/refcount.h>\n#include <linux/utsname.h>\n#include <linux/lockd/bind.h>\n#include <linux/lockd/xdr.h>\n#ifdef CONFIG_LOCKD_V4\n#include <linux/lockd/xdr4.h>\n#endif\n#include <linux/lockd/debug.h>\n#include <linux/sunrpc/svc.h>\n\n \n#define LOCKD_VERSION\t\t\"0.5\"\n\n \n#define LOCKD_DFLT_TIMEO\t10\n\n \nstruct nlm_host {\n\tstruct hlist_node\th_hash;\t\t \n\tstruct sockaddr_storage\th_addr;\t\t \n\tsize_t\t\t\th_addrlen;\n\tstruct sockaddr_storage\th_srcaddr;\t \n\tsize_t\t\t\th_srcaddrlen;\n\tstruct rpc_clnt\t\t*h_rpcclnt;\t \n\tchar\t\t\t*h_name;\t\t \n\tu32\t\t\th_version;\t \n\tunsigned short\t\th_proto;\t \n\tunsigned short\t\th_reclaiming : 1,\n\t\t\t\th_server     : 1,  \n\t\t\t\th_noresvport : 1,\n\t\t\t\th_inuse      : 1;\n\twait_queue_head_t\th_gracewait;\t \n\tstruct rw_semaphore\th_rwsem;\t \n\tu32\t\t\th_state;\t \n\tu32\t\t\th_nsmstate;\t \n\tu32\t\t\th_pidcount;\t \n\trefcount_t\t\th_count;\t \n\tstruct mutex\t\th_mutex;\t \n\tunsigned long\t\th_nextrebind;\t \n\tunsigned long\t\th_expires;\t \n\tstruct list_head\th_lockowners;\t \n\tspinlock_t\t\th_lock;\n\tstruct list_head\th_granted;\t \n\tstruct list_head\th_reclaim;\t \n\tstruct nsm_handle\t*h_nsmhandle;\t \n\tchar\t\t\t*h_addrbuf;\t \n\tstruct net\t\t*net;\t\t \n\tconst struct cred\t*h_cred;\n\tchar\t\t\tnodename[UNX_MAXNODENAME + 1];\n\tconst struct nlmclnt_operations\t*h_nlmclnt_ops;\t \n};\n\n \n#define NSM_ADDRBUF\t\t((8 * 4 + 7) + (1 + 10) + 1)\n\nstruct nsm_handle {\n\tstruct list_head\tsm_link;\n\trefcount_t\t\tsm_count;\n\tchar\t\t\t*sm_mon_name;\n\tchar\t\t\t*sm_name;\n\tstruct sockaddr_storage\tsm_addr;\n\tsize_t\t\t\tsm_addrlen;\n\tunsigned int\t\tsm_monitored : 1,\n\t\t\t\tsm_sticky : 1;\t \n\tstruct nsm_private\tsm_priv;\n\tchar\t\t\tsm_addrbuf[NSM_ADDRBUF];\n};\n\n \nstatic inline struct sockaddr *nlm_addr(const struct nlm_host *host)\n{\n\treturn (struct sockaddr *)&host->h_addr;\n}\n\nstatic inline struct sockaddr *nlm_srcaddr(const struct nlm_host *host)\n{\n\treturn (struct sockaddr *)&host->h_srcaddr;\n}\n\n \nstruct nlm_lockowner {\n\tstruct list_head list;\n\trefcount_t count;\n\n\tstruct nlm_host *host;\n\tfl_owner_t owner;\n\tuint32_t pid;\n};\n\n \nstruct nlm_wait {\n\tstruct list_head\tb_list;\t\t \n\twait_queue_head_t\tb_wait;\t\t \n\tstruct nlm_host\t\t*b_host;\n\tstruct file_lock\t*b_lock;\t \n\t__be32\t\t\tb_status;\t \n};\n\n \n#define NLMCLNT_OHSIZE\t\t((__NEW_UTS_LEN) + 10u)\nstruct nlm_rqst {\n\trefcount_t\t\ta_count;\n\tunsigned int\t\ta_flags;\t \n\tstruct nlm_host *\ta_host;\t\t \n\tstruct nlm_args\t\ta_args;\t\t \n\tstruct nlm_res\t\ta_res;\t\t \n\tstruct nlm_block *\ta_block;\n\tunsigned int\t\ta_retries;\t \n\tu8\t\t\ta_owner[NLMCLNT_OHSIZE];\n\tvoid *\ta_callback_data;  \n};\n\n \nstruct nlm_file {\n\tstruct hlist_node\tf_list;\t\t \n\tstruct nfs_fh\t\tf_handle;\t \n\tstruct file *\t\tf_file[2];\t \n\tstruct nlm_share *\tf_shares;\t \n\tstruct list_head\tf_blocks;\t \n\tunsigned int\t\tf_locks;\t \n\tunsigned int\t\tf_count;\t \n\tstruct mutex\t\tf_mutex;\t \n};\n\n \n#define NLM_NEVER\t\t(~(unsigned long) 0)\n \n#define NLM_TIMEOUT\t\t(7 * HZ)\n\nstruct nlm_block {\n\tstruct kref\t\tb_count;\t \n\tstruct list_head\tb_list;\t\t \n\tstruct list_head\tb_flist;\t \n\tstruct nlm_rqst\t*\tb_call;\t\t \n\tstruct svc_serv *\tb_daemon;\t \n\tstruct nlm_host *\tb_host;\t\t \n\tunsigned long\t\tb_when;\t\t \n\tunsigned int\t\tb_id;\t\t \n\tunsigned char\t\tb_granted;\t \n\tstruct nlm_file *\tb_file;\t\t \n\tstruct cache_req *\tb_cache_req;\t \n\tstruct cache_deferred_req * b_deferred_req;\n\tunsigned int\t\tb_flags;\t \n#define B_QUEUED\t\t1\t \n#define B_GOT_CALLBACK\t\t2\t \n#define B_TIMED_OUT\t\t4\t \n};\n\n \nextern const struct rpc_program\tnlm_program;\nextern const struct svc_procedure nlmsvc_procedures[24];\n#ifdef CONFIG_LOCKD_V4\nextern const struct svc_procedure nlmsvc_procedures4[24];\n#endif\nextern int\t\t\tnlmsvc_grace_period;\nextern unsigned long\t\tnlmsvc_timeout;\nextern bool\t\t\tnsm_use_hostnames;\nextern u32\t\t\tnsm_local_state;\n\nextern struct timer_list\tnlmsvc_retry;\n\n \nstruct nlm_rqst * nlm_alloc_call(struct nlm_host *host);\nint\t\t  nlm_async_call(struct nlm_rqst *, u32, const struct rpc_call_ops *);\nint\t\t  nlm_async_reply(struct nlm_rqst *, u32, const struct rpc_call_ops *);\nvoid\t\t  nlmclnt_release_call(struct nlm_rqst *);\nvoid\t\t  nlmclnt_prepare_block(struct nlm_wait *block, struct nlm_host *host,\n\t\t\t\t\tstruct file_lock *fl);\nvoid\t\t  nlmclnt_queue_block(struct nlm_wait *block);\n__be32\t\t  nlmclnt_dequeue_block(struct nlm_wait *block);\nint\t\t  nlmclnt_wait(struct nlm_wait *block, struct nlm_rqst *req, long timeout);\n__be32\t\t  nlmclnt_grant(const struct sockaddr *addr,\n\t\t\t\tconst struct nlm_lock *lock);\nvoid\t\t  nlmclnt_recovery(struct nlm_host *);\nint\t\t  nlmclnt_reclaim(struct nlm_host *, struct file_lock *,\n\t\t\t\t  struct nlm_rqst *);\nvoid\t\t  nlmclnt_next_cookie(struct nlm_cookie *);\n\n \nstruct nlm_host  *nlmclnt_lookup_host(const struct sockaddr *sap,\n\t\t\t\t\tconst size_t salen,\n\t\t\t\t\tconst unsigned short protocol,\n\t\t\t\t\tconst u32 version,\n\t\t\t\t\tconst char *hostname,\n\t\t\t\t\tint noresvport,\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct cred *cred);\nvoid\t\t  nlmclnt_release_host(struct nlm_host *);\nstruct nlm_host  *nlmsvc_lookup_host(const struct svc_rqst *rqstp,\n\t\t\t\t\tconst char *hostname,\n\t\t\t\t\tconst size_t hostname_len);\nvoid\t\t  nlmsvc_release_host(struct nlm_host *);\nstruct rpc_clnt * nlm_bind_host(struct nlm_host *);\nvoid\t\t  nlm_rebind_host(struct nlm_host *);\nstruct nlm_host * nlm_get_host(struct nlm_host *);\nvoid\t\t  nlm_shutdown_hosts(void);\nvoid\t\t  nlm_shutdown_hosts_net(struct net *net);\nvoid\t\t  nlm_host_rebooted(const struct net *net,\n\t\t\t\t\tconst struct nlm_reboot *);\n\n \nint\t\t  nsm_monitor(const struct nlm_host *host);\nvoid\t\t  nsm_unmonitor(const struct nlm_host *host);\n\nstruct nsm_handle *nsm_get_handle(const struct net *net,\n\t\t\t\t\tconst struct sockaddr *sap,\n\t\t\t\t\tconst size_t salen,\n\t\t\t\t\tconst char *hostname,\n\t\t\t\t\tconst size_t hostname_len);\nstruct nsm_handle *nsm_reboot_lookup(const struct net *net,\n\t\t\t\t\tconst struct nlm_reboot *info);\nvoid\t\t  nsm_release(struct nsm_handle *nsm);\n\n \ntypedef int\t  (*nlm_host_match_fn_t)(void *cur, struct nlm_host *ref);\n\n \nint\t\t  lock_to_openmode(struct file_lock *);\n__be32\t\t  nlmsvc_lock(struct svc_rqst *, struct nlm_file *,\n\t\t\t      struct nlm_host *, struct nlm_lock *, int,\n\t\t\t      struct nlm_cookie *, int);\n__be32\t\t  nlmsvc_unlock(struct net *net, struct nlm_file *, struct nlm_lock *);\n__be32\t\t  nlmsvc_testlock(struct svc_rqst *, struct nlm_file *,\n\t\t\tstruct nlm_host *, struct nlm_lock *,\n\t\t\tstruct nlm_lock *, struct nlm_cookie *);\n__be32\t\t  nlmsvc_cancel_blocked(struct net *net, struct nlm_file *, struct nlm_lock *);\nvoid\t\t  nlmsvc_retry_blocked(void);\nvoid\t\t  nlmsvc_traverse_blocks(struct nlm_host *, struct nlm_file *,\n\t\t\t\t\tnlm_host_match_fn_t match);\nvoid\t\t  nlmsvc_grant_reply(struct nlm_cookie *, __be32);\nvoid\t\t  nlmsvc_release_call(struct nlm_rqst *);\nvoid\t\t  nlmsvc_locks_init_private(struct file_lock *, struct nlm_host *, pid_t);\n\n \n__be32\t\t  nlm_lookup_file(struct svc_rqst *, struct nlm_file **,\n\t\t\t\t\tstruct nlm_lock *);\nvoid\t\t  nlm_release_file(struct nlm_file *);\nvoid\t\t  nlmsvc_put_lockowner(struct nlm_lockowner *);\nvoid\t\t  nlmsvc_release_lockowner(struct nlm_lock *);\nvoid\t\t  nlmsvc_mark_resources(struct net *);\nvoid\t\t  nlmsvc_free_host_resources(struct nlm_host *);\nvoid\t\t  nlmsvc_invalidate_all(void);\n\n \nint           nlmsvc_unlock_all_by_sb(struct super_block *sb);\nint           nlmsvc_unlock_all_by_ip(struct sockaddr *server_addr);\n\nstatic inline struct file *nlmsvc_file_file(struct nlm_file *file)\n{\n\treturn file->f_file[O_RDONLY] ?\n\t       file->f_file[O_RDONLY] : file->f_file[O_WRONLY];\n}\n\nstatic inline struct inode *nlmsvc_file_inode(struct nlm_file *file)\n{\n\treturn file_inode(nlmsvc_file_file(file));\n}\n\nstatic inline int __nlm_privileged_request4(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in *sin = (struct sockaddr_in *)sap;\n\n\tif (ntohs(sin->sin_port) > 1023)\n\t\treturn 0;\n\n\treturn ipv4_is_loopback(sin->sin_addr.s_addr);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline int __nlm_privileged_request6(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\n\tif (ntohs(sin6->sin6_port) > 1023)\n\t\treturn 0;\n\n\tif (ipv6_addr_type(&sin6->sin6_addr) & IPV6_ADDR_MAPPED)\n\t\treturn ipv4_is_loopback(sin6->sin6_addr.s6_addr32[3]);\n\n\treturn ipv6_addr_type(&sin6->sin6_addr) & IPV6_ADDR_LOOPBACK;\n}\n#else\t \nstatic inline int __nlm_privileged_request6(const struct sockaddr *sap)\n{\n\treturn 0;\n}\n#endif\t \n\n \nstatic inline int nlm_privileged_requester(const struct svc_rqst *rqstp)\n{\n\tconst struct sockaddr *sap = svc_addr(rqstp);\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\treturn __nlm_privileged_request4(sap);\n\tcase AF_INET6:\n\t\treturn __nlm_privileged_request6(sap);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic inline int nlm_compare_locks(const struct file_lock *fl1,\n\t\t\t\t    const struct file_lock *fl2)\n{\n\treturn file_inode(fl1->fl_file) == file_inode(fl2->fl_file)\n\t     && fl1->fl_pid   == fl2->fl_pid\n\t     && fl1->fl_owner == fl2->fl_owner\n\t     && fl1->fl_start == fl2->fl_start\n\t     && fl1->fl_end   == fl2->fl_end\n\t     &&(fl1->fl_type  == fl2->fl_type || fl2->fl_type == F_UNLCK);\n}\n\nextern const struct lock_manager_operations nlmsvc_lock_operations;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}