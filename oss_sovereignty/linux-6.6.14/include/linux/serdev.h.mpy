{
  "module_name": "serdev.h",
  "hash_id": "824a0a38ecd2c08156086532e4bc433219306d2be227dd1d4e40772c26e12ad6",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/serdev.h",
  "human_readable_source": " \n \n#ifndef _LINUX_SERDEV_H\n#define _LINUX_SERDEV_H\n\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/iopoll.h>\n#include <linux/uaccess.h>\n#include <linux/termios.h>\n#include <linux/delay.h>\n\nstruct serdev_controller;\nstruct serdev_device;\n\n \n\n \nstruct serdev_device_ops {\n\tint (*receive_buf)(struct serdev_device *, const unsigned char *, size_t);\n\tvoid (*write_wakeup)(struct serdev_device *);\n};\n\n \nstruct serdev_device {\n\tstruct device dev;\n\tint nr;\n\tstruct serdev_controller *ctrl;\n\tconst struct serdev_device_ops *ops;\n\tstruct completion write_comp;\n\tstruct mutex write_lock;\n};\n\nstatic inline struct serdev_device *to_serdev_device(struct device *d)\n{\n\treturn container_of(d, struct serdev_device, dev);\n}\n\n \nstruct serdev_device_driver {\n\tstruct device_driver driver;\n\tint\t(*probe)(struct serdev_device *);\n\tvoid\t(*remove)(struct serdev_device *);\n};\n\nstatic inline struct serdev_device_driver *to_serdev_device_driver(struct device_driver *d)\n{\n\treturn container_of(d, struct serdev_device_driver, driver);\n}\n\nenum serdev_parity {\n\tSERDEV_PARITY_NONE,\n\tSERDEV_PARITY_EVEN,\n\tSERDEV_PARITY_ODD,\n};\n\n \nstruct serdev_controller_ops {\n\tint (*write_buf)(struct serdev_controller *, const unsigned char *, size_t);\n\tvoid (*write_flush)(struct serdev_controller *);\n\tint (*write_room)(struct serdev_controller *);\n\tint (*open)(struct serdev_controller *);\n\tvoid (*close)(struct serdev_controller *);\n\tvoid (*set_flow_control)(struct serdev_controller *, bool);\n\tint (*set_parity)(struct serdev_controller *, enum serdev_parity);\n\tunsigned int (*set_baudrate)(struct serdev_controller *, unsigned int);\n\tvoid (*wait_until_sent)(struct serdev_controller *, long);\n\tint (*get_tiocm)(struct serdev_controller *);\n\tint (*set_tiocm)(struct serdev_controller *, unsigned int, unsigned int);\n\tint (*break_ctl)(struct serdev_controller *ctrl, unsigned int break_state);\n};\n\n \nstruct serdev_controller {\n\tstruct device\t\tdev;\n\tunsigned int\t\tnr;\n\tstruct serdev_device\t*serdev;\n\tconst struct serdev_controller_ops *ops;\n};\n\nstatic inline struct serdev_controller *to_serdev_controller(struct device *d)\n{\n\treturn container_of(d, struct serdev_controller, dev);\n}\n\nstatic inline void *serdev_device_get_drvdata(const struct serdev_device *serdev)\n{\n\treturn dev_get_drvdata(&serdev->dev);\n}\n\nstatic inline void serdev_device_set_drvdata(struct serdev_device *serdev, void *data)\n{\n\tdev_set_drvdata(&serdev->dev, data);\n}\n\n \nstatic inline void serdev_device_put(struct serdev_device *serdev)\n{\n\tif (serdev)\n\t\tput_device(&serdev->dev);\n}\n\nstatic inline void serdev_device_set_client_ops(struct serdev_device *serdev,\n\t\t\t\t\t      const struct serdev_device_ops *ops)\n{\n\tserdev->ops = ops;\n}\n\nstatic inline\nvoid *serdev_controller_get_drvdata(const struct serdev_controller *ctrl)\n{\n\treturn ctrl ? dev_get_drvdata(&ctrl->dev) : NULL;\n}\n\nstatic inline void serdev_controller_set_drvdata(struct serdev_controller *ctrl,\n\t\t\t\t\t       void *data)\n{\n\tdev_set_drvdata(&ctrl->dev, data);\n}\n\n \nstatic inline void serdev_controller_put(struct serdev_controller *ctrl)\n{\n\tif (ctrl)\n\t\tput_device(&ctrl->dev);\n}\n\nstruct serdev_device *serdev_device_alloc(struct serdev_controller *);\nint serdev_device_add(struct serdev_device *);\nvoid serdev_device_remove(struct serdev_device *);\n\nstruct serdev_controller *serdev_controller_alloc(struct device *, size_t);\nint serdev_controller_add(struct serdev_controller *);\nvoid serdev_controller_remove(struct serdev_controller *);\n\nstatic inline void serdev_controller_write_wakeup(struct serdev_controller *ctrl)\n{\n\tstruct serdev_device *serdev = ctrl->serdev;\n\n\tif (!serdev || !serdev->ops->write_wakeup)\n\t\treturn;\n\n\tserdev->ops->write_wakeup(serdev);\n}\n\nstatic inline int serdev_controller_receive_buf(struct serdev_controller *ctrl,\n\t\t\t\t\t      const unsigned char *data,\n\t\t\t\t\t      size_t count)\n{\n\tstruct serdev_device *serdev = ctrl->serdev;\n\n\tif (!serdev || !serdev->ops->receive_buf)\n\t\treturn 0;\n\n\treturn serdev->ops->receive_buf(serdev, data, count);\n}\n\n#if IS_ENABLED(CONFIG_SERIAL_DEV_BUS)\n\nint serdev_device_open(struct serdev_device *);\nvoid serdev_device_close(struct serdev_device *);\nint devm_serdev_device_open(struct device *, struct serdev_device *);\nunsigned int serdev_device_set_baudrate(struct serdev_device *, unsigned int);\nvoid serdev_device_set_flow_control(struct serdev_device *, bool);\nint serdev_device_write_buf(struct serdev_device *, const unsigned char *, size_t);\nvoid serdev_device_wait_until_sent(struct serdev_device *, long);\nint serdev_device_get_tiocm(struct serdev_device *);\nint serdev_device_set_tiocm(struct serdev_device *, int, int);\nint serdev_device_break_ctl(struct serdev_device *serdev, int break_state);\nvoid serdev_device_write_wakeup(struct serdev_device *);\nint serdev_device_write(struct serdev_device *, const unsigned char *, size_t, long);\nvoid serdev_device_write_flush(struct serdev_device *);\nint serdev_device_write_room(struct serdev_device *);\n\n \nint __serdev_device_driver_register(struct serdev_device_driver *, struct module *);\n#define serdev_device_driver_register(sdrv) \\\n\t__serdev_device_driver_register(sdrv, THIS_MODULE)\n\n \nstatic inline void serdev_device_driver_unregister(struct serdev_device_driver *sdrv)\n{\n\tif (sdrv)\n\t\tdriver_unregister(&sdrv->driver);\n}\n\n#define module_serdev_device_driver(__serdev_device_driver) \\\n\tmodule_driver(__serdev_device_driver, serdev_device_driver_register, \\\n\t\t\tserdev_device_driver_unregister)\n\n#else\n\nstatic inline int serdev_device_open(struct serdev_device *sdev)\n{\n\treturn -ENODEV;\n}\nstatic inline void serdev_device_close(struct serdev_device *sdev) {}\nstatic inline unsigned int serdev_device_set_baudrate(struct serdev_device *sdev, unsigned int baudrate)\n{\n\treturn 0;\n}\nstatic inline void serdev_device_set_flow_control(struct serdev_device *sdev, bool enable) {}\nstatic inline int serdev_device_write_buf(struct serdev_device *serdev,\n\t\t\t\t\t  const unsigned char *buf,\n\t\t\t\t\t  size_t count)\n{\n\treturn -ENODEV;\n}\nstatic inline void serdev_device_wait_until_sent(struct serdev_device *sdev, long timeout) {}\nstatic inline int serdev_device_get_tiocm(struct serdev_device *serdev)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int serdev_device_set_tiocm(struct serdev_device *serdev, int set, int clear)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int serdev_device_break_ctl(struct serdev_device *serdev, int break_state)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int serdev_device_write(struct serdev_device *sdev, const unsigned char *buf,\n\t\t\t\t      size_t count, unsigned long timeout)\n{\n\treturn -ENODEV;\n}\nstatic inline void serdev_device_write_flush(struct serdev_device *sdev) {}\nstatic inline int serdev_device_write_room(struct serdev_device *sdev)\n{\n\treturn 0;\n}\n\n#define serdev_device_driver_register(x)\n#define serdev_device_driver_unregister(x)\n\n#endif  \n\nstatic inline bool serdev_device_get_cts(struct serdev_device *serdev)\n{\n\tint status = serdev_device_get_tiocm(serdev);\n\treturn !!(status & TIOCM_CTS);\n}\n\nstatic inline int serdev_device_wait_for_cts(struct serdev_device *serdev, bool state, int timeout_ms)\n{\n\tbool signal;\n\n\treturn readx_poll_timeout(serdev_device_get_cts, serdev, signal, signal == state,\n\t\t\t\t  2000, timeout_ms * 1000);\n}\n\nstatic inline int serdev_device_set_rts(struct serdev_device *serdev, bool enable)\n{\n\tif (enable)\n\t\treturn serdev_device_set_tiocm(serdev, TIOCM_RTS, 0);\n\telse\n\t\treturn serdev_device_set_tiocm(serdev, 0, TIOCM_RTS);\n}\n\nint serdev_device_set_parity(struct serdev_device *serdev,\n\t\t\t     enum serdev_parity parity);\n\n \nstruct tty_port;\nstruct tty_driver;\n\n#ifdef CONFIG_SERIAL_DEV_CTRL_TTYPORT\nstruct device *serdev_tty_port_register(struct tty_port *port,\n\t\t\t\t\tstruct device *parent,\n\t\t\t\t\tstruct tty_driver *drv, int idx);\nint serdev_tty_port_unregister(struct tty_port *port);\n#else\nstatic inline struct device *serdev_tty_port_register(struct tty_port *port,\n\t\t\t\t\t   struct device *parent,\n\t\t\t\t\t   struct tty_driver *drv, int idx)\n{\n\treturn ERR_PTR(-ENODEV);\n}\nstatic inline int serdev_tty_port_unregister(struct tty_port *port)\n{\n\treturn -ENODEV;\n}\n#endif  \n\nstruct acpi_resource;\nstruct acpi_resource_uart_serialbus;\n\n#ifdef CONFIG_ACPI\nbool serdev_acpi_get_uart_resource(struct acpi_resource *ares,\n\t\t\t\t   struct acpi_resource_uart_serialbus **uart);\n#else\nstatic inline bool serdev_acpi_get_uart_resource(struct acpi_resource *ares,\n\t\t\t\t\t\t struct acpi_resource_uart_serialbus **uart)\n{\n\treturn false;\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}