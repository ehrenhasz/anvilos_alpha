{
  "module_name": "rtmutex.h",
  "hash_id": "f641514a86a048ff8603ffdb0f258370c5902645aad4a0c33a02e9a21320deb0",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/rtmutex.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_RT_MUTEX_H\n#define __LINUX_RT_MUTEX_H\n\n#include <linux/compiler.h>\n#include <linux/linkage.h>\n#include <linux/rbtree_types.h>\n#include <linux/spinlock_types_raw.h>\n\nextern int max_lock_depth;  \n\nstruct rt_mutex_base {\n\traw_spinlock_t\t\twait_lock;\n\tstruct rb_root_cached   waiters;\n\tstruct task_struct\t*owner;\n};\n\n#define __RT_MUTEX_BASE_INITIALIZER(rtbasename)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.wait_lock = __RAW_SPIN_LOCK_UNLOCKED(rtbasename.wait_lock),\t\\\n\t.waiters = RB_ROOT_CACHED,\t\t\t\t\t\\\n\t.owner = NULL\t\t\t\t\t\t\t\\\n}\n\n \nstatic inline bool rt_mutex_base_is_locked(struct rt_mutex_base *lock)\n{\n\treturn READ_ONCE(lock->owner) != NULL;\n}\n\nextern void rt_mutex_base_init(struct rt_mutex_base *rtb);\n\n \nstruct rt_mutex {\n\tstruct rt_mutex_base\trtmutex;\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tstruct lockdep_map\tdep_map;\n#endif\n};\n\nstruct rt_mutex_waiter;\nstruct hrtimer_sleeper;\n\n#ifdef CONFIG_DEBUG_RT_MUTEXES\nextern void rt_mutex_debug_task_free(struct task_struct *tsk);\n#else\nstatic inline void rt_mutex_debug_task_free(struct task_struct *tsk) { }\n#endif\n\n#define rt_mutex_init(mutex) \\\ndo { \\\n\tstatic struct lock_class_key __key; \\\n\t__rt_mutex_init(mutex, __func__, &__key); \\\n} while (0)\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n#define __DEP_MAP_RT_MUTEX_INITIALIZER(mutexname)\t\\\n\t.dep_map = {\t\t\t\t\t\\\n\t\t.name = #mutexname,\t\t\t\\\n\t\t.wait_type_inner = LD_WAIT_SLEEP,\t\\\n\t}\n#else\n#define __DEP_MAP_RT_MUTEX_INITIALIZER(mutexname)\n#endif\n\n#define __RT_MUTEX_INITIALIZER(mutexname)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.rtmutex = __RT_MUTEX_BASE_INITIALIZER(mutexname.rtmutex),\t\\\n\t__DEP_MAP_RT_MUTEX_INITIALIZER(mutexname)\t\t\t\\\n}\n\n#define DEFINE_RT_MUTEX(mutexname) \\\n\tstruct rt_mutex mutexname = __RT_MUTEX_INITIALIZER(mutexname)\n\nextern void __rt_mutex_init(struct rt_mutex *lock, const char *name, struct lock_class_key *key);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nextern void rt_mutex_lock_nested(struct rt_mutex *lock, unsigned int subclass);\nextern void _rt_mutex_lock_nest_lock(struct rt_mutex *lock, struct lockdep_map *nest_lock);\n#define rt_mutex_lock(lock) rt_mutex_lock_nested(lock, 0)\n#define rt_mutex_lock_nest_lock(lock, nest_lock)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttypecheck(struct lockdep_map *, &(nest_lock)->dep_map);\t\\\n\t\t_rt_mutex_lock_nest_lock(lock, &(nest_lock)->dep_map);\t\\\n\t} while (0)\n\n#else\nextern void rt_mutex_lock(struct rt_mutex *lock);\n#define rt_mutex_lock_nested(lock, subclass) rt_mutex_lock(lock)\n#define rt_mutex_lock_nest_lock(lock, nest_lock) rt_mutex_lock(lock)\n#endif\n\nextern int rt_mutex_lock_interruptible(struct rt_mutex *lock);\nextern int rt_mutex_lock_killable(struct rt_mutex *lock);\nextern int rt_mutex_trylock(struct rt_mutex *lock);\n\nextern void rt_mutex_unlock(struct rt_mutex *lock);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}