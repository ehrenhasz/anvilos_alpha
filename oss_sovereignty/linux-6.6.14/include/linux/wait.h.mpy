{
  "module_name": "wait.h",
  "hash_id": "6165a745208a8b8667df014f91b2b04edf8300b28adfbdba1eb0f1c2f0ca1224",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/wait.h",
  "human_readable_source": " \n#ifndef _LINUX_WAIT_H\n#define _LINUX_WAIT_H\n \n#include <linux/list.h>\n#include <linux/stddef.h>\n#include <linux/spinlock.h>\n\n#include <asm/current.h>\n#include <uapi/linux/wait.h>\n\ntypedef struct wait_queue_entry wait_queue_entry_t;\n\ntypedef int (*wait_queue_func_t)(struct wait_queue_entry *wq_entry, unsigned mode, int flags, void *key);\nint default_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int flags, void *key);\n\n \n#define WQ_FLAG_EXCLUSIVE\t0x01\n#define WQ_FLAG_WOKEN\t\t0x02\n#define WQ_FLAG_BOOKMARK\t0x04\n#define WQ_FLAG_CUSTOM\t\t0x08\n#define WQ_FLAG_DONE\t\t0x10\n#define WQ_FLAG_PRIORITY\t0x20\n\n \nstruct wait_queue_entry {\n\tunsigned int\t\tflags;\n\tvoid\t\t\t*private;\n\twait_queue_func_t\tfunc;\n\tstruct list_head\tentry;\n};\n\nstruct wait_queue_head {\n\tspinlock_t\t\tlock;\n\tstruct list_head\thead;\n};\ntypedef struct wait_queue_head wait_queue_head_t;\n\nstruct task_struct;\n\n \n\n#define __WAITQUEUE_INITIALIZER(name, tsk) {\t\t\t\t\t\\\n\t.private\t= tsk,\t\t\t\t\t\t\t\\\n\t.func\t\t= default_wake_function,\t\t\t\t\\\n\t.entry\t\t= { NULL, NULL } }\n\n#define DECLARE_WAITQUEUE(name, tsk)\t\t\t\t\t\t\\\n\tstruct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk)\n\n#define __WAIT_QUEUE_HEAD_INITIALIZER(name) {\t\t\t\t\t\\\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(name.lock),\t\t\t\\\n\t.head\t\t= LIST_HEAD_INIT(name.head) }\n\n#define DECLARE_WAIT_QUEUE_HEAD(name) \\\n\tstruct wait_queue_head name = __WAIT_QUEUE_HEAD_INITIALIZER(name)\n\nextern void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *);\n\n#define init_waitqueue_head(wq_head)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\tstatic struct lock_class_key __key;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\t__init_waitqueue_head((wq_head), #wq_head, &__key);\t\t\\\n\t} while (0)\n\n#ifdef CONFIG_LOCKDEP\n# define __WAIT_QUEUE_HEAD_INIT_ONSTACK(name) \\\n\t({ init_waitqueue_head(&name); name; })\n# define DECLARE_WAIT_QUEUE_HEAD_ONSTACK(name) \\\n\tstruct wait_queue_head name = __WAIT_QUEUE_HEAD_INIT_ONSTACK(name)\n#else\n# define DECLARE_WAIT_QUEUE_HEAD_ONSTACK(name) DECLARE_WAIT_QUEUE_HEAD(name)\n#endif\n\nstatic inline void init_waitqueue_entry(struct wait_queue_entry *wq_entry, struct task_struct *p)\n{\n\twq_entry->flags\t\t= 0;\n\twq_entry->private\t= p;\n\twq_entry->func\t\t= default_wake_function;\n}\n\nstatic inline void\ninit_waitqueue_func_entry(struct wait_queue_entry *wq_entry, wait_queue_func_t func)\n{\n\twq_entry->flags\t\t= 0;\n\twq_entry->private\t= NULL;\n\twq_entry->func\t\t= func;\n}\n\n \nstatic inline int waitqueue_active(struct wait_queue_head *wq_head)\n{\n\treturn !list_empty(&wq_head->head);\n}\n\n \nstatic inline bool wq_has_single_sleeper(struct wait_queue_head *wq_head)\n{\n\treturn list_is_singular(&wq_head->head);\n}\n\n \nstatic inline bool wq_has_sleeper(struct wait_queue_head *wq_head)\n{\n\t \n\tsmp_mb();\n\treturn waitqueue_active(wq_head);\n}\n\nextern void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);\nextern void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);\nextern void add_wait_queue_priority(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);\nextern void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);\n\nstatic inline void __add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tstruct list_head *head = &wq_head->head;\n\tstruct wait_queue_entry *wq;\n\n\tlist_for_each_entry(wq, &wq_head->head, entry) {\n\t\tif (!(wq->flags & WQ_FLAG_PRIORITY))\n\t\t\tbreak;\n\t\thead = &wq->entry;\n\t}\n\tlist_add(&wq_entry->entry, head);\n}\n\n \nstatic inline void\n__add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\t__add_wait_queue(wq_head, wq_entry);\n}\n\nstatic inline void __add_wait_queue_entry_tail(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tlist_add_tail(&wq_entry->entry, &wq_head->head);\n}\n\nstatic inline void\n__add_wait_queue_entry_tail_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n}\n\nstatic inline void\n__remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tlist_del(&wq_entry->entry);\n}\n\nint __wake_up(struct wait_queue_head *wq_head, unsigned int mode, int nr, void *key);\nvoid __wake_up_on_current_cpu(struct wait_queue_head *wq_head, unsigned int mode, void *key);\nvoid __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);\nvoid __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark);\nvoid __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);\nvoid __wake_up_locked_sync_key(struct wait_queue_head *wq_head, unsigned int mode, void *key);\nvoid __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr);\nvoid __wake_up_sync(struct wait_queue_head *wq_head, unsigned int mode);\nvoid __wake_up_pollfree(struct wait_queue_head *wq_head);\n\n#define wake_up(x)\t\t\t__wake_up(x, TASK_NORMAL, 1, NULL)\n#define wake_up_nr(x, nr)\t\t__wake_up(x, TASK_NORMAL, nr, NULL)\n#define wake_up_all(x)\t\t\t__wake_up(x, TASK_NORMAL, 0, NULL)\n#define wake_up_locked(x)\t\t__wake_up_locked((x), TASK_NORMAL, 1)\n#define wake_up_all_locked(x)\t\t__wake_up_locked((x), TASK_NORMAL, 0)\n\n#define wake_up_interruptible(x)\t__wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)\n#define wake_up_interruptible_nr(x, nr)\t__wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)\n#define wake_up_interruptible_all(x)\t__wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)\n#define wake_up_interruptible_sync(x)\t__wake_up_sync((x), TASK_INTERRUPTIBLE)\n\n \n#define poll_to_key(m) ((void *)(__force uintptr_t)(__poll_t)(m))\n#define key_to_poll(m) ((__force __poll_t)(uintptr_t)(void *)(m))\n#define wake_up_poll(x, m)\t\t\t\t\t\t\t\\\n\t__wake_up(x, TASK_NORMAL, 1, poll_to_key(m))\n#define wake_up_poll_on_current_cpu(x, m)\t\t\t\t\t\\\n\t__wake_up_on_current_cpu(x, TASK_NORMAL, poll_to_key(m))\n#define wake_up_locked_poll(x, m)\t\t\t\t\t\t\\\n\t__wake_up_locked_key((x), TASK_NORMAL, poll_to_key(m))\n#define wake_up_interruptible_poll(x, m)\t\t\t\t\t\\\n\t__wake_up(x, TASK_INTERRUPTIBLE, 1, poll_to_key(m))\n#define wake_up_interruptible_sync_poll(x, m)\t\t\t\t\t\\\n\t__wake_up_sync_key((x), TASK_INTERRUPTIBLE, poll_to_key(m))\n#define wake_up_interruptible_sync_poll_locked(x, m)\t\t\t\t\\\n\t__wake_up_locked_sync_key((x), TASK_INTERRUPTIBLE, poll_to_key(m))\n\n \nstatic inline void wake_up_pollfree(struct wait_queue_head *wq_head)\n{\n\t \n\tif (waitqueue_active(wq_head))\n\t\t__wake_up_pollfree(wq_head);\n}\n\n#define ___wait_cond_timeout(condition)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tbool __cond = (condition);\t\t\t\t\t\t\\\n\tif (__cond && !__ret)\t\t\t\t\t\t\t\\\n\t\t__ret = 1;\t\t\t\t\t\t\t\\\n\t__cond || !__ret;\t\t\t\t\t\t\t\\\n})\n\n#define ___wait_is_interruptible(state)\t\t\t\t\t\t\\\n\t(!__builtin_constant_p(state) ||\t\t\t\t\t\\\n\t (state & (TASK_INTERRUPTIBLE | TASK_WAKEKILL)))\n\nextern void init_wait_entry(struct wait_queue_entry *wq_entry, int flags);\n\n \n\n#define ___wait_event(wq_head, condition, state, exclusive, ret, cmd)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\t__label__ __out;\t\t\t\t\t\t\t\\\n\tstruct wait_queue_entry __wq_entry;\t\t\t\t\t\\\n\tlong __ret = ret;\t \t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tinit_wait_entry(&__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : 0);\t\\\n\tfor (;;) {\t\t\t\t\t\t\t\t\\\n\t\tlong __int = prepare_to_wait_event(&wq_head, &__wq_entry, state);\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (condition)\t\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (___wait_is_interruptible(state) && __int) {\t\t\t\\\n\t\t\t__ret = __int;\t\t\t\t\t\t\\\n\t\t\tgoto __out;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tcmd;\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\tfinish_wait(&wq_head, &__wq_entry);\t\t\t\t\t\\\n__out:\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event(wq_head, condition)\t\t\t\t\t\\\n\t(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,\t\\\n\t\t\t    schedule())\n\n \n#define wait_event(wq_head, condition)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__wait_event(wq_head, condition);\t\t\t\t\t\\\n} while (0)\n\n#define __io_wait_event(wq_head, condition)\t\t\t\t\t\\\n\t(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,\t\\\n\t\t\t    io_schedule())\n\n \n#define io_wait_event(wq_head, condition)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__io_wait_event(wq_head, condition);\t\t\t\t\t\\\n} while (0)\n\n#define __wait_event_freezable(wq_head, condition)\t\t\t\t\\\n\t___wait_event(wq_head, condition, (TASK_INTERRUPTIBLE|TASK_FREEZABLE),\t\\\n\t\t\t0, 0, schedule())\n\n \n#define wait_event_freezable(wq_head, condition)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_freezable(wq_head, condition);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_timeout(wq_head, condition, timeout)\t\t\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      TASK_UNINTERRUPTIBLE, 0, timeout,\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n \n#define wait_event_timeout(wq_head, condition, timeout)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_timeout(wq_head, condition, timeout);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_freezable_timeout(wq_head, condition, timeout)\t\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      (TASK_INTERRUPTIBLE|TASK_FREEZABLE), 0, timeout,\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n \n#define wait_event_freezable_timeout(wq_head, condition, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_freezable_timeout(wq_head, condition, timeout); \\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_exclusive_cmd(wq_head, condition, cmd1, cmd2)\t\t\\\n\t(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 1, 0,\t\\\n\t\t\t    cmd1; schedule(); cmd2)\n \n#define wait_event_exclusive_cmd(wq_head, condition, cmd1, cmd2)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__wait_event_exclusive_cmd(wq_head, condition, cmd1, cmd2);\t\t\\\n} while (0)\n\n#define __wait_event_cmd(wq_head, condition, cmd1, cmd2)\t\t\t\\\n\t(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,\t\\\n\t\t\t    cmd1; schedule(); cmd2)\n\n \n#define wait_event_cmd(wq_head, condition, cmd1, cmd2)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__wait_event_cmd(wq_head, condition, cmd1, cmd2);\t\t\t\\\n} while (0)\n\n#define __wait_event_interruptible(wq_head, condition)\t\t\t\t\\\n\t___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,\t\t\\\n\t\t      schedule())\n\n \n#define wait_event_interruptible(wq_head, condition)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_interruptible(wq_head, condition);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_interruptible_timeout(wq_head, condition, timeout)\t\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      TASK_INTERRUPTIBLE, 0, timeout,\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n \n#define wait_event_interruptible_timeout(wq_head, condition, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_interruptible_timeout(wq_head,\t\t\\\n\t\t\t\t\t\tcondition, timeout);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_hrtimeout(wq_head, condition, timeout, state)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tstruct hrtimer_sleeper __t;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\thrtimer_init_sleeper_on_stack(&__t, CLOCK_MONOTONIC,\t\t\t\\\n\t\t\t\t      HRTIMER_MODE_REL);\t\t\t\\\n\tif ((timeout) != KTIME_MAX) {\t\t\t\t\t\t\\\n\t\thrtimer_set_expires_range_ns(&__t.timer, timeout,\t\t\\\n\t\t\t\t\tcurrent->timer_slack_ns);\t\t\\\n\t\thrtimer_sleeper_start_expires(&__t, HRTIMER_MODE_REL);\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t__ret = ___wait_event(wq_head, condition, state, 0, 0,\t\t\t\\\n\t\tif (!__t.task) {\t\t\t\t\t\t\\\n\t\t\t__ret = -ETIME;\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t\tschedule());\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\thrtimer_cancel(&__t.timer);\t\t\t\t\t\t\\\n\tdestroy_hrtimer_on_stack(&__t.timer);\t\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n \n#define wait_event_hrtimeout(wq_head, condition, timeout)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_hrtimeout(wq_head, condition, timeout,\t\\\n\t\t\t\t\t       TASK_UNINTERRUPTIBLE);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n \n#define wait_event_interruptible_hrtimeout(wq, condition, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_hrtimeout(wq, condition, timeout,\t\t\\\n\t\t\t\t\t       TASK_INTERRUPTIBLE);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_interruptible_exclusive(wq, condition)\t\t\t\\\n\t___wait_event(wq, condition, TASK_INTERRUPTIBLE, 1, 0,\t\t\t\\\n\t\t      schedule())\n\n#define wait_event_interruptible_exclusive(wq, condition)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_interruptible_exclusive(wq, condition);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_killable_exclusive(wq, condition)\t\t\t\t\\\n\t___wait_event(wq, condition, TASK_KILLABLE, 1, 0,\t\t\t\\\n\t\t      schedule())\n\n#define wait_event_killable_exclusive(wq, condition)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_killable_exclusive(wq, condition);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n\n#define __wait_event_freezable_exclusive(wq, condition)\t\t\t\t\\\n\t___wait_event(wq, condition, (TASK_INTERRUPTIBLE|TASK_FREEZABLE), 1, 0,\\\n\t\t\tschedule())\n\n#define wait_event_freezable_exclusive(wq, condition)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_freezable_exclusive(wq, condition);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n \n#define wait_event_idle(wq_head, condition)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t___wait_event(wq_head, condition, TASK_IDLE, 0, 0, schedule());\t\\\n} while (0)\n\n \n#define wait_event_idle_exclusive(wq_head, condition)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t___wait_event(wq_head, condition, TASK_IDLE, 1, 0, schedule());\t\\\n} while (0)\n\n#define __wait_event_idle_timeout(wq_head, condition, timeout)\t\t\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      TASK_IDLE, 0, timeout,\t\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n \n#define wait_event_idle_timeout(wq_head, condition, timeout)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_idle_timeout(wq_head, condition, timeout);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_idle_exclusive_timeout(wq_head, condition, timeout)\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      TASK_IDLE, 1, timeout,\t\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n \n#define wait_event_idle_exclusive_timeout(wq_head, condition, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_idle_exclusive_timeout(wq_head, condition, timeout);\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\nextern int do_wait_intr(wait_queue_head_t *, wait_queue_entry_t *);\nextern int do_wait_intr_irq(wait_queue_head_t *, wait_queue_entry_t *);\n\n#define __wait_event_interruptible_locked(wq, condition, exclusive, fn)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret;\t\t\t\t\t\t\t\t\\\n\tDEFINE_WAIT(__wait);\t\t\t\t\t\t\t\\\n\tif (exclusive)\t\t\t\t\t\t\t\t\\\n\t\t__wait.flags |= WQ_FLAG_EXCLUSIVE;\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\t__ret = fn(&(wq), &__wait);\t\t\t\t\t\\\n\t\tif (__ret)\t\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\t\\\n\t} while (!(condition));\t\t\t\t\t\t\t\\\n\t__remove_wait_queue(&(wq), &__wait);\t\t\t\t\t\\\n\t__set_current_state(TASK_RUNNING);\t\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n\n \n#define wait_event_interruptible_locked(wq, condition)\t\t\t\t\\\n\t((condition)\t\t\t\t\t\t\t\t\\\n\t ? 0 : __wait_event_interruptible_locked(wq, condition, 0, do_wait_intr))\n\n \n#define wait_event_interruptible_locked_irq(wq, condition)\t\t\t\\\n\t((condition)\t\t\t\t\t\t\t\t\\\n\t ? 0 : __wait_event_interruptible_locked(wq, condition, 0, do_wait_intr_irq))\n\n \n#define wait_event_interruptible_exclusive_locked(wq, condition)\t\t\\\n\t((condition)\t\t\t\t\t\t\t\t\\\n\t ? 0 : __wait_event_interruptible_locked(wq, condition, 1, do_wait_intr))\n\n \n#define wait_event_interruptible_exclusive_locked_irq(wq, condition)\t\t\\\n\t((condition)\t\t\t\t\t\t\t\t\\\n\t ? 0 : __wait_event_interruptible_locked(wq, condition, 1, do_wait_intr_irq))\n\n\n#define __wait_event_killable(wq, condition)\t\t\t\t\t\\\n\t___wait_event(wq, condition, TASK_KILLABLE, 0, 0, schedule())\n\n \n#define wait_event_killable(wq_head, condition)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_killable(wq_head, condition);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_state(wq, condition, state)\t\t\t\t\\\n\t___wait_event(wq, condition, state, 0, 0, schedule())\n\n \n#define wait_event_state(wq_head, condition, state)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_state(wq_head, condition, state);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_killable_timeout(wq_head, condition, timeout)\t\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      TASK_KILLABLE, 0, timeout,\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n \n#define wait_event_killable_timeout(wq_head, condition, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_killable_timeout(wq_head,\t\t\t\\\n\t\t\t\t\t\tcondition, timeout);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n\n#define __wait_event_lock_irq(wq_head, condition, lock, cmd)\t\t\t\\\n\t(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,\t\\\n\t\t\t    spin_unlock_irq(&lock);\t\t\t\t\\\n\t\t\t    cmd;\t\t\t\t\t\t\\\n\t\t\t    schedule();\t\t\t\t\t\t\\\n\t\t\t    spin_lock_irq(&lock))\n\n \n#define wait_event_lock_irq_cmd(wq_head, condition, lock, cmd)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__wait_event_lock_irq(wq_head, condition, lock, cmd);\t\t\t\\\n} while (0)\n\n \n#define wait_event_lock_irq(wq_head, condition, lock)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t__wait_event_lock_irq(wq_head, condition, lock, );\t\t\t\\\n} while (0)\n\n\n#define __wait_event_interruptible_lock_irq(wq_head, condition, lock, cmd)\t\\\n\t___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,\t\t\\\n\t\t      spin_unlock_irq(&lock);\t\t\t\t\t\\\n\t\t      cmd;\t\t\t\t\t\t\t\\\n\t\t      schedule();\t\t\t\t\t\t\\\n\t\t      spin_lock_irq(&lock))\n\n \n#define wait_event_interruptible_lock_irq_cmd(wq_head, condition, lock, cmd)\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_interruptible_lock_irq(wq_head,\t\t\\\n\t\t\t\t\t\tcondition, lock, cmd);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n \n#define wait_event_interruptible_lock_irq(wq_head, condition, lock)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\t\\\n\t\t__ret = __wait_event_interruptible_lock_irq(wq_head,\t\t\\\n\t\t\t\t\t\tcondition, lock,);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_event_lock_irq_timeout(wq_head, condition, lock, timeout, state)\t\\\n\t___wait_event(wq_head, ___wait_cond_timeout(condition),\t\t\t\\\n\t\t      state, 0, timeout,\t\t\t\t\t\\\n\t\t      spin_unlock_irq(&lock);\t\t\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret);\t\t\t\t\\\n\t\t      spin_lock_irq(&lock));\n\n \n#define wait_event_interruptible_lock_irq_timeout(wq_head, condition, lock,\t\\\n\t\t\t\t\t\t  timeout)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_lock_irq_timeout(\t\t\t\t\\\n\t\t\t\t\twq_head, condition, lock, timeout,\t\\\n\t\t\t\t\tTASK_INTERRUPTIBLE);\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define wait_event_lock_irq_timeout(wq_head, condition, lock, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\t\\\n\t\t__ret = __wait_event_lock_irq_timeout(\t\t\t\t\\\n\t\t\t\t\twq_head, condition, lock, timeout,\t\\\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\t\\\n})\n\n \nvoid prepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);\nbool prepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);\nlong prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);\nlong wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout);\nint woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);\nint autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);\n\n#define DEFINE_WAIT_FUNC(name, function)\t\t\t\t\t\\\n\tstruct wait_queue_entry name = {\t\t\t\t\t\\\n\t\t.private\t= current,\t\t\t\t\t\\\n\t\t.func\t\t= function,\t\t\t\t\t\\\n\t\t.entry\t\t= LIST_HEAD_INIT((name).entry),\t\t\t\\\n\t}\n\n#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)\n\n#define init_wait(wait)\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\t(wait)->private = current;\t\t\t\t\t\\\n\t\t(wait)->func = autoremove_wake_function;\t\t\t\\\n\t\tINIT_LIST_HEAD(&(wait)->entry);\t\t\t\t\t\\\n\t\t(wait)->flags = 0;\t\t\t\t\t\t\\\n\t} while (0)\n\ntypedef int (*task_call_f)(struct task_struct *p, void *arg);\nextern int task_call_func(struct task_struct *p, task_call_f func, void *arg);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}