{
  "module_name": "interval_tree_generic.h",
  "hash_id": "2f845fab36407b0350f5273cde954d9298fe21b09f551a47b2f71c88189b11f3",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/interval_tree_generic.h",
  "human_readable_source": " \n \n\n#include <linux/rbtree_augmented.h>\n\n \n\n#define INTERVAL_TREE_DEFINE(ITSTRUCT, ITRB, ITTYPE, ITSUBTREE,\t\t      \\\n\t\t\t     ITSTART, ITLAST, ITSTATIC, ITPREFIX)\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n \t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nRB_DECLARE_CALLBACKS_MAX(static, ITPREFIX ## _augment,\t\t\t      \\\n\t\t\t ITSTRUCT, ITRB, ITTYPE, ITSUBTREE, ITLAST)\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n \t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nITSTATIC void ITPREFIX ## _insert(ITSTRUCT *node,\t\t\t      \\\n\t\t\t\t  struct rb_root_cached *root)\t \t      \\\n{\t\t\t\t\t\t\t\t\t      \\\n\tstruct rb_node **link = &root->rb_root.rb_node, *rb_parent = NULL;    \\\n\tITTYPE start = ITSTART(node), last = ITLAST(node);\t\t      \\\n\tITSTRUCT *parent;\t\t\t\t\t\t      \\\n\tbool leftmost = true;\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\twhile (*link) {\t\t\t\t\t\t\t      \\\n\t\trb_parent = *link;\t\t\t\t\t      \\\n\t\tparent = rb_entry(rb_parent, ITSTRUCT, ITRB);\t\t      \\\n\t\tif (parent->ITSUBTREE < last)\t\t\t\t      \\\n\t\t\tparent->ITSUBTREE = last;\t\t\t      \\\n\t\tif (start < ITSTART(parent))\t\t\t\t      \\\n\t\t\tlink = &parent->ITRB.rb_left;\t\t\t      \\\n\t\telse {\t\t\t\t\t\t\t      \\\n\t\t\tlink = &parent->ITRB.rb_right;\t\t\t      \\\n\t\t\tleftmost = false;\t\t\t\t      \\\n\t\t}\t\t\t\t\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tnode->ITSUBTREE = last;\t\t\t\t\t\t      \\\n\trb_link_node(&node->ITRB, rb_parent, link);\t\t\t      \\\n\trb_insert_augmented_cached(&node->ITRB, root,\t\t\t      \\\n\t\t\t\t   leftmost, &ITPREFIX ## _augment);\t      \\\n}\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nITSTATIC void ITPREFIX ## _remove(ITSTRUCT *node,\t\t\t      \\\n\t\t\t\t  struct rb_root_cached *root)\t\t      \\\n{\t\t\t\t\t\t\t\t\t      \\\n\trb_erase_augmented_cached(&node->ITRB, root, &ITPREFIX ## _augment);  \\\n}\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n \t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nstatic ITSTRUCT *\t\t\t\t\t\t\t      \\\nITPREFIX ## _subtree_search(ITSTRUCT *node, ITTYPE start, ITTYPE last)\t      \\\n{\t\t\t\t\t\t\t\t\t      \\\n\twhile (true) {\t\t\t\t\t\t\t      \\\n\t\t \t\t\t\t\t\t\t      \\\n\t\tif (node->ITRB.rb_left) {\t\t\t\t      \\\n\t\t\tITSTRUCT *left = rb_entry(node->ITRB.rb_left,\t      \\\n\t\t\t\t\t\t  ITSTRUCT, ITRB);\t      \\\n\t\t\tif (start <= left->ITSUBTREE) {\t\t\t      \\\n\t\t\t\t \t\t\t\t\t      \\\n\t\t\t\tnode = left;\t\t\t\t      \\\n\t\t\t\tcontinue;\t\t\t\t      \\\n\t\t\t}\t\t\t\t\t\t      \\\n\t\t}\t\t\t\t\t\t\t      \\\n\t\tif (ITSTART(node) <= last) {\t\t \t      \\\n\t\t\tif (start <= ITLAST(node))\t \t      \\\n\t\t\t\treturn node;\t   \\\n\t\t\tif (node->ITRB.rb_right) {\t\t\t      \\\n\t\t\t\tnode = rb_entry(node->ITRB.rb_right,\t      \\\n\t\t\t\t\t\tITSTRUCT, ITRB);\t      \\\n\t\t\t\tif (start <= node->ITSUBTREE)\t\t      \\\n\t\t\t\t\tcontinue;\t\t\t      \\\n\t\t\t}\t\t\t\t\t\t      \\\n\t\t}\t\t\t\t\t\t\t      \\\n\t\treturn NULL;\t \t\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n}\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nITSTATIC ITSTRUCT *\t\t\t\t\t\t\t      \\\nITPREFIX ## _iter_first(struct rb_root_cached *root,\t\t\t      \\\n\t\t\tITTYPE start, ITTYPE last)\t\t\t      \\\n{\t\t\t\t\t\t\t\t\t      \\\n\tITSTRUCT *node, *leftmost;\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (!root->rb_root.rb_node)\t\t\t\t\t      \\\n\t\treturn NULL;\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\t \t\t\t\t\t\t\t\t      \\\n\tnode = rb_entry(root->rb_root.rb_node, ITSTRUCT, ITRB);\t\t      \\\n\tif (node->ITSUBTREE < start)\t\t\t\t\t      \\\n\t\treturn NULL;\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tleftmost = rb_entry(root->rb_leftmost, ITSTRUCT, ITRB);\t\t      \\\n\tif (ITSTART(leftmost) > last)\t\t\t\t\t      \\\n\t\treturn NULL;\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\treturn ITPREFIX ## _subtree_search(node, start, last);\t\t      \\\n}\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\nITSTATIC ITSTRUCT *\t\t\t\t\t\t\t      \\\nITPREFIX ## _iter_next(ITSTRUCT *node, ITTYPE start, ITTYPE last)\t      \\\n{\t\t\t\t\t\t\t\t\t      \\\n\tstruct rb_node *rb = node->ITRB.rb_right, *prev;\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\twhile (true) {\t\t\t\t\t\t\t      \\\n\t\t \t\t\t\t\t\t\t      \\\n\t\tif (rb) {\t\t\t\t\t\t      \\\n\t\t\tITSTRUCT *right = rb_entry(rb, ITSTRUCT, ITRB);\t      \\\n\t\t\tif (start <= right->ITSUBTREE)\t\t\t      \\\n\t\t\t\treturn ITPREFIX ## _subtree_search(right,     \\\n\t\t\t\t\t\t\t\tstart, last); \\\n\t\t}\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\t\t  \\\n\t\tdo {\t\t\t\t\t\t\t      \\\n\t\t\trb = rb_parent(&node->ITRB);\t\t\t      \\\n\t\t\tif (!rb)\t\t\t\t\t      \\\n\t\t\t\treturn NULL;\t\t\t\t      \\\n\t\t\tprev = &node->ITRB;\t\t\t\t      \\\n\t\t\tnode = rb_entry(rb, ITSTRUCT, ITRB);\t\t      \\\n\t\t\trb = node->ITRB.rb_right;\t\t\t      \\\n\t\t} while (prev == rb);\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\t\t \t\t      \\\n\t\tif (last < ITSTART(node))\t\t \t      \\\n\t\t\treturn NULL;\t\t\t\t\t      \\\n\t\telse if (start <= ITLAST(node))\t\t \t      \\\n\t\t\treturn node;\t\t\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}