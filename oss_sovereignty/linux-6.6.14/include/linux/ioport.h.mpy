{
  "module_name": "ioport.h",
  "hash_id": "1cbc8a4b784beb5222e801821506608b6781bd64311ce57c72eea6a7e2c45ad2",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ioport.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_IOPORT_H\n#define _LINUX_IOPORT_H\n\n#ifndef __ASSEMBLY__\n#include <linux/bits.h>\n#include <linux/compiler.h>\n#include <linux/minmax.h>\n#include <linux/types.h>\n \nstruct resource {\n\tresource_size_t start;\n\tresource_size_t end;\n\tconst char *name;\n\tunsigned long flags;\n\tunsigned long desc;\n\tstruct resource *parent, *sibling, *child;\n};\n\n \n#define IORESOURCE_BITS\t\t0x000000ff\t \n\n#define IORESOURCE_TYPE_BITS\t0x00001f00\t \n#define IORESOURCE_IO\t\t0x00000100\t \n#define IORESOURCE_MEM\t\t0x00000200\n#define IORESOURCE_REG\t\t0x00000300\t \n#define IORESOURCE_IRQ\t\t0x00000400\n#define IORESOURCE_DMA\t\t0x00000800\n#define IORESOURCE_BUS\t\t0x00001000\n\n#define IORESOURCE_PREFETCH\t0x00002000\t \n#define IORESOURCE_READONLY\t0x00004000\n#define IORESOURCE_CACHEABLE\t0x00008000\n#define IORESOURCE_RANGELENGTH\t0x00010000\n#define IORESOURCE_SHADOWABLE\t0x00020000\n\n#define IORESOURCE_SIZEALIGN\t0x00040000\t \n#define IORESOURCE_STARTALIGN\t0x00080000\t \n\n#define IORESOURCE_MEM_64\t0x00100000\n#define IORESOURCE_WINDOW\t0x00200000\t \n#define IORESOURCE_MUXED\t0x00400000\t \n\n#define IORESOURCE_EXT_TYPE_BITS 0x01000000\t \n#define IORESOURCE_SYSRAM\t0x01000000\t \n\n \n#define IORESOURCE_SYSRAM_DRIVER_MANAGED\t0x02000000  \n#define IORESOURCE_SYSRAM_MERGEABLE\t\t0x04000000  \n\n#define IORESOURCE_EXCLUSIVE\t0x08000000\t \n\n#define IORESOURCE_DISABLED\t0x10000000\n#define IORESOURCE_UNSET\t0x20000000\t \n#define IORESOURCE_AUTO\t\t0x40000000\n#define IORESOURCE_BUSY\t\t0x80000000\t \n\n \n#define IORESOURCE_SYSTEM_RAM\t\t(IORESOURCE_MEM|IORESOURCE_SYSRAM)\n\n \n#define IORESOURCE_IRQ_HIGHEDGE\t\t(1<<0)\n#define IORESOURCE_IRQ_LOWEDGE\t\t(1<<1)\n#define IORESOURCE_IRQ_HIGHLEVEL\t(1<<2)\n#define IORESOURCE_IRQ_LOWLEVEL\t\t(1<<3)\n#define IORESOURCE_IRQ_SHAREABLE\t(1<<4)\n#define IORESOURCE_IRQ_OPTIONAL\t\t(1<<5)\n#define IORESOURCE_IRQ_WAKECAPABLE\t(1<<6)\n\n \n#define IORESOURCE_DMA_TYPE_MASK\t(3<<0)\n#define IORESOURCE_DMA_8BIT\t\t(0<<0)\n#define IORESOURCE_DMA_8AND16BIT\t(1<<0)\n#define IORESOURCE_DMA_16BIT\t\t(2<<0)\n\n#define IORESOURCE_DMA_MASTER\t\t(1<<2)\n#define IORESOURCE_DMA_BYTE\t\t(1<<3)\n#define IORESOURCE_DMA_WORD\t\t(1<<4)\n\n#define IORESOURCE_DMA_SPEED_MASK\t(3<<6)\n#define IORESOURCE_DMA_COMPATIBLE\t(0<<6)\n#define IORESOURCE_DMA_TYPEA\t\t(1<<6)\n#define IORESOURCE_DMA_TYPEB\t\t(2<<6)\n#define IORESOURCE_DMA_TYPEF\t\t(3<<6)\n\n \n#define IORESOURCE_MEM_WRITEABLE\t(1<<0)\t \n#define IORESOURCE_MEM_CACHEABLE\t(1<<1)\t \n#define IORESOURCE_MEM_RANGELENGTH\t(1<<2)\t \n#define IORESOURCE_MEM_TYPE_MASK\t(3<<3)\n#define IORESOURCE_MEM_8BIT\t\t(0<<3)\n#define IORESOURCE_MEM_16BIT\t\t(1<<3)\n#define IORESOURCE_MEM_8AND16BIT\t(2<<3)\n#define IORESOURCE_MEM_32BIT\t\t(3<<3)\n#define IORESOURCE_MEM_SHADOWABLE\t(1<<5)\t \n#define IORESOURCE_MEM_EXPANSIONROM\t(1<<6)\n#define IORESOURCE_MEM_NONPOSTED\t(1<<7)\n\n \n#define IORESOURCE_IO_16BIT_ADDR\t(1<<0)\n#define IORESOURCE_IO_FIXED\t\t(1<<1)\n#define IORESOURCE_IO_SPARSE\t\t(1<<2)\n\n \n#define IORESOURCE_ROM_ENABLE\t\t(1<<0)\t \n#define IORESOURCE_ROM_SHADOW\t\t(1<<1)\t \n\n \n#define IORESOURCE_PCI_FIXED\t\t(1<<4)\t \n#define IORESOURCE_PCI_EA_BEI\t\t(1<<5)\t \n\n \nenum {\n\tIORES_DESC_NONE\t\t\t\t= 0,\n\tIORES_DESC_CRASH_KERNEL\t\t\t= 1,\n\tIORES_DESC_ACPI_TABLES\t\t\t= 2,\n\tIORES_DESC_ACPI_NV_STORAGE\t\t= 3,\n\tIORES_DESC_PERSISTENT_MEMORY\t\t= 4,\n\tIORES_DESC_PERSISTENT_MEMORY_LEGACY\t= 5,\n\tIORES_DESC_DEVICE_PRIVATE_MEMORY\t= 6,\n\tIORES_DESC_RESERVED\t\t\t= 7,\n\tIORES_DESC_SOFT_RESERVED\t\t= 8,\n\tIORES_DESC_CXL\t\t\t\t= 9,\n};\n\n \nenum {\n\tIORES_MAP_SYSTEM_RAM\t\t= BIT(0),\n\tIORES_MAP_ENCRYPTED\t\t= BIT(1),\n};\n\n \n#define DEFINE_RES_NAMED(_start, _size, _name, _flags)\t\t\t\\\n(struct resource) {\t\t\t\t\t\t\t\\\n\t\t.start = (_start),\t\t\t\t\t\\\n\t\t.end = (_start) + (_size) - 1,\t\t\t\t\\\n\t\t.name = (_name),\t\t\t\t\t\\\n\t\t.flags = (_flags),\t\t\t\t\t\\\n\t\t.desc = IORES_DESC_NONE,\t\t\t\t\\\n\t}\n\n#define DEFINE_RES_IO_NAMED(_start, _size, _name)\t\t\t\\\n\tDEFINE_RES_NAMED((_start), (_size), (_name), IORESOURCE_IO)\n#define DEFINE_RES_IO(_start, _size)\t\t\t\t\t\\\n\tDEFINE_RES_IO_NAMED((_start), (_size), NULL)\n\n#define DEFINE_RES_MEM_NAMED(_start, _size, _name)\t\t\t\\\n\tDEFINE_RES_NAMED((_start), (_size), (_name), IORESOURCE_MEM)\n#define DEFINE_RES_MEM(_start, _size)\t\t\t\t\t\\\n\tDEFINE_RES_MEM_NAMED((_start), (_size), NULL)\n\n#define DEFINE_RES_REG_NAMED(_start, _size, _name)\t\t\t\\\n\tDEFINE_RES_NAMED((_start), (_size), (_name), IORESOURCE_REG)\n#define DEFINE_RES_REG(_start, _size)\t\t\t\t\t\\\n\tDEFINE_RES_REG_NAMED((_start), (_size), NULL)\n\n#define DEFINE_RES_IRQ_NAMED(_irq, _name)\t\t\t\t\\\n\tDEFINE_RES_NAMED((_irq), 1, (_name), IORESOURCE_IRQ)\n#define DEFINE_RES_IRQ(_irq)\t\t\t\t\t\t\\\n\tDEFINE_RES_IRQ_NAMED((_irq), NULL)\n\n#define DEFINE_RES_DMA_NAMED(_dma, _name)\t\t\t\t\\\n\tDEFINE_RES_NAMED((_dma), 1, (_name), IORESOURCE_DMA)\n#define DEFINE_RES_DMA(_dma)\t\t\t\t\t\t\\\n\tDEFINE_RES_DMA_NAMED((_dma), NULL)\n\n \nextern struct resource ioport_resource;\nextern struct resource iomem_resource;\n\nextern struct resource *request_resource_conflict(struct resource *root, struct resource *new);\nextern int request_resource(struct resource *root, struct resource *new);\nextern int release_resource(struct resource *new);\nvoid release_child_resources(struct resource *new);\nextern void reserve_region_with_split(struct resource *root,\n\t\t\t     resource_size_t start, resource_size_t end,\n\t\t\t     const char *name);\nextern struct resource *insert_resource_conflict(struct resource *parent, struct resource *new);\nextern int insert_resource(struct resource *parent, struct resource *new);\nextern void insert_resource_expand_to_fit(struct resource *root, struct resource *new);\nextern int remove_resource(struct resource *old);\nextern void arch_remove_reservations(struct resource *avail);\nextern int allocate_resource(struct resource *root, struct resource *new,\n\t\t\t     resource_size_t size, resource_size_t min,\n\t\t\t     resource_size_t max, resource_size_t align,\n\t\t\t     resource_size_t (*alignf)(void *,\n\t\t\t\t\t\t       const struct resource *,\n\t\t\t\t\t\t       resource_size_t,\n\t\t\t\t\t\t       resource_size_t),\n\t\t\t     void *alignf_data);\nstruct resource *lookup_resource(struct resource *root, resource_size_t start);\nint adjust_resource(struct resource *res, resource_size_t start,\n\t\t    resource_size_t size);\nresource_size_t resource_alignment(struct resource *res);\nstatic inline resource_size_t resource_size(const struct resource *res)\n{\n\treturn res->end - res->start + 1;\n}\nstatic inline unsigned long resource_type(const struct resource *res)\n{\n\treturn res->flags & IORESOURCE_TYPE_BITS;\n}\nstatic inline unsigned long resource_ext_type(const struct resource *res)\n{\n\treturn res->flags & IORESOURCE_EXT_TYPE_BITS;\n}\n \nstatic inline bool resource_contains(struct resource *r1, struct resource *r2)\n{\n\tif (resource_type(r1) != resource_type(r2))\n\t\treturn false;\n\tif (r1->flags & IORESOURCE_UNSET || r2->flags & IORESOURCE_UNSET)\n\t\treturn false;\n\treturn r1->start <= r2->start && r1->end >= r2->end;\n}\n\n \nstatic inline bool resource_overlaps(struct resource *r1, struct resource *r2)\n{\n       return r1->start <= r2->end && r1->end >= r2->start;\n}\n\nstatic inline bool\nresource_intersection(struct resource *r1, struct resource *r2, struct resource *r)\n{\n\tif (!resource_overlaps(r1, r2))\n\t\treturn false;\n\tr->start = max(r1->start, r2->start);\n\tr->end = min(r1->end, r2->end);\n\treturn true;\n}\n\nstatic inline bool\nresource_union(struct resource *r1, struct resource *r2, struct resource *r)\n{\n\tif (!resource_overlaps(r1, r2))\n\t\treturn false;\n\tr->start = min(r1->start, r2->start);\n\tr->end = max(r1->end, r2->end);\n\treturn true;\n}\n\n \n#define request_region(start,n,name)\t\t__request_region(&ioport_resource, (start), (n), (name), 0)\n#define request_muxed_region(start,n,name)\t__request_region(&ioport_resource, (start), (n), (name), IORESOURCE_MUXED)\n#define __request_mem_region(start,n,name, excl) __request_region(&iomem_resource, (start), (n), (name), excl)\n#define request_mem_region(start,n,name) __request_region(&iomem_resource, (start), (n), (name), 0)\n#define request_mem_region_muxed(start, n, name) \\\n\t__request_region(&iomem_resource, (start), (n), (name), IORESOURCE_MUXED)\n#define request_mem_region_exclusive(start,n,name) \\\n\t__request_region(&iomem_resource, (start), (n), (name), IORESOURCE_EXCLUSIVE)\n#define rename_region(region, newname) do { (region)->name = (newname); } while (0)\n\nextern struct resource * __request_region(struct resource *,\n\t\t\t\t\tresource_size_t start,\n\t\t\t\t\tresource_size_t n,\n\t\t\t\t\tconst char *name, int flags);\n\n \n#define release_region(start,n)\t__release_region(&ioport_resource, (start), (n))\n#define release_mem_region(start,n)\t__release_region(&iomem_resource, (start), (n))\n\nextern void __release_region(struct resource *, resource_size_t,\n\t\t\t\tresource_size_t);\n#ifdef CONFIG_MEMORY_HOTREMOVE\nextern void release_mem_region_adjustable(resource_size_t, resource_size_t);\n#endif\n#ifdef CONFIG_MEMORY_HOTPLUG\nextern void merge_system_ram_resource(struct resource *res);\n#endif\n\n \nstruct device;\n\nextern int devm_request_resource(struct device *dev, struct resource *root,\n\t\t\t\t struct resource *new);\nextern void devm_release_resource(struct device *dev, struct resource *new);\n\n#define devm_request_region(dev,start,n,name) \\\n\t__devm_request_region(dev, &ioport_resource, (start), (n), (name))\n#define devm_request_mem_region(dev,start,n,name) \\\n\t__devm_request_region(dev, &iomem_resource, (start), (n), (name))\n\nextern struct resource * __devm_request_region(struct device *dev,\n\t\t\t\tstruct resource *parent, resource_size_t start,\n\t\t\t\tresource_size_t n, const char *name);\n\n#define devm_release_region(dev, start, n) \\\n\t__devm_release_region(dev, &ioport_resource, (start), (n))\n#define devm_release_mem_region(dev, start, n) \\\n\t__devm_release_region(dev, &iomem_resource, (start), (n))\n\nextern void __devm_release_region(struct device *dev, struct resource *parent,\n\t\t\t\t  resource_size_t start, resource_size_t n);\nextern int iomem_map_sanity_check(resource_size_t addr, unsigned long size);\nextern bool iomem_is_exclusive(u64 addr);\nextern bool resource_is_exclusive(struct resource *resource, u64 addr,\n\t\t\t\t  resource_size_t size);\n\nextern int\nwalk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\tvoid *arg, int (*func)(unsigned long, unsigned long, void *));\nextern int\nwalk_mem_res(u64 start, u64 end, void *arg,\n\t     int (*func)(struct resource *, void *));\nextern int\nwalk_system_ram_res(u64 start, u64 end, void *arg,\n\t\t    int (*func)(struct resource *, void *));\nextern int\nwalk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start, u64 end,\n\t\t    void *arg, int (*func)(struct resource *, void *));\n\nstruct resource *devm_request_free_mem_region(struct device *dev,\n\t\tstruct resource *base, unsigned long size);\nstruct resource *request_free_mem_region(struct resource *base,\n\t\tunsigned long size, const char *name);\nstruct resource *alloc_free_mem_region(struct resource *base,\n\t\tunsigned long size, unsigned long align, const char *name);\n\nstatic inline void irqresource_disabled(struct resource *res, u32 irq)\n{\n\tres->start = irq;\n\tres->end = irq;\n\tres->flags |= IORESOURCE_IRQ | IORESOURCE_DISABLED | IORESOURCE_UNSET;\n}\n\nextern struct address_space *iomem_get_mapping(void);\n\n#endif  \n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}