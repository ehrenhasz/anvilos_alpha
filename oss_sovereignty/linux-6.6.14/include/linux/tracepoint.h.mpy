{
  "module_name": "tracepoint.h",
  "hash_id": "299ab738a3cb3e9acf7be8435bc4e27aa206b5bfe54fe9bbee1a83fb8bf7750b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/tracepoint.h",
  "human_readable_source": " \n#ifndef _LINUX_TRACEPOINT_H\n#define _LINUX_TRACEPOINT_H\n\n \n\n#include <linux/smp.h>\n#include <linux/srcu.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/cpumask.h>\n#include <linux/rcupdate.h>\n#include <linux/tracepoint-defs.h>\n#include <linux/static_call.h>\n\nstruct module;\nstruct tracepoint;\nstruct notifier_block;\n\nstruct trace_eval_map {\n\tconst char\t\t*system;\n\tconst char\t\t*eval_string;\n\tunsigned long\t\teval_value;\n};\n\n#define TRACEPOINT_DEFAULT_PRIO\t10\n\nextern struct srcu_struct tracepoint_srcu;\n\nextern int\ntracepoint_probe_register(struct tracepoint *tp, void *probe, void *data);\nextern int\ntracepoint_probe_register_prio(struct tracepoint *tp, void *probe, void *data,\n\t\t\t       int prio);\nextern int\ntracepoint_probe_register_prio_may_exist(struct tracepoint *tp, void *probe, void *data,\n\t\t\t\t\t int prio);\nextern int\ntracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data);\nstatic inline int\ntracepoint_probe_register_may_exist(struct tracepoint *tp, void *probe,\n\t\t\t\t    void *data)\n{\n\treturn tracepoint_probe_register_prio_may_exist(tp, probe, data,\n\t\t\t\t\t\t\tTRACEPOINT_DEFAULT_PRIO);\n}\nextern void\nfor_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv);\n\n#ifdef CONFIG_MODULES\nstruct tp_module {\n\tstruct list_head list;\n\tstruct module *mod;\n};\n\nbool trace_module_has_bad_taint(struct module *mod);\nextern int register_tracepoint_module_notifier(struct notifier_block *nb);\nextern int unregister_tracepoint_module_notifier(struct notifier_block *nb);\n#else\nstatic inline bool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn false;\n}\nstatic inline\nint register_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\treturn 0;\n}\nstatic inline\nint unregister_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\treturn 0;\n}\n#endif  \n\n \n#ifdef CONFIG_TRACEPOINTS\nstatic inline void tracepoint_synchronize_unregister(void)\n{\n\tsynchronize_srcu(&tracepoint_srcu);\n\tsynchronize_rcu();\n}\n#else\nstatic inline void tracepoint_synchronize_unregister(void)\n{ }\n#endif\n\n#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS\nextern int syscall_regfunc(void);\nextern void syscall_unregfunc(void);\n#endif  \n\n#ifndef PARAMS\n#define PARAMS(args...) args\n#endif\n\n#define TRACE_DEFINE_ENUM(x)\n#define TRACE_DEFINE_SIZEOF(x)\n\n#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS\nstatic inline struct tracepoint *tracepoint_ptr_deref(tracepoint_ptr_t *p)\n{\n\treturn offset_to_ptr(p);\n}\n\n#define __TRACEPOINT_ENTRY(name)\t\t\t\t\t\\\n\tasm(\"\t.section \\\"__tracepoints_ptrs\\\", \\\"a\\\"\t\t\\n\"\t\\\n\t    \"\t.balign 4\t\t\t\t\t\\n\"\t\\\n\t    \"\t.long \t__tracepoint_\" #name \" - .\t\t\\n\"\t\\\n\t    \"\t.previous\t\t\t\t\t\\n\")\n#else\nstatic inline struct tracepoint *tracepoint_ptr_deref(tracepoint_ptr_t *p)\n{\n\treturn *p;\n}\n\n#define __TRACEPOINT_ENTRY(name)\t\t\t\t\t \\\n\tstatic tracepoint_ptr_t __tracepoint_ptr_##name __used\t\t \\\n\t__section(\"__tracepoints_ptrs\") = &__tracepoint_##name\n#endif\n\n#endif  \n\n \n\n#ifndef DECLARE_TRACE\n\n#define TP_PROTO(args...)\targs\n#define TP_ARGS(args...)\targs\n#define TP_CONDITION(args...)\targs\n\n \n#if defined(CONFIG_TRACEPOINTS) && !defined(NOTRACE)\n#define TRACEPOINTS_ENABLED\n#endif\n\n#ifdef TRACEPOINTS_ENABLED\n\n#ifdef CONFIG_HAVE_STATIC_CALL\n#define __DO_TRACE_CALL(name, args)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct tracepoint_func *it_func_ptr;\t\t\t\\\n\t\tvoid *__data;\t\t\t\t\t\t\\\n\t\tit_func_ptr =\t\t\t\t\t\t\\\n\t\t\trcu_dereference_raw((&__tracepoint_##name)->funcs); \\\n\t\tif (it_func_ptr) {\t\t\t\t\t\\\n\t\t\t__data = (it_func_ptr)->data;\t\t\t\\\n\t\t\tstatic_call(tp_func_##name)(__data, args);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n#else\n#define __DO_TRACE_CALL(name, args)\t__traceiter_##name(NULL, args)\n#endif  \n\n \n#ifdef CONFIG_ARCH_WANTS_NO_INSTR\n#define RCUIDLE_COND(rcuidle)\t(rcuidle)\n#else\n \n#define RCUIDLE_COND(rcuidle)\t(rcuidle && in_nmi())\n#endif\n\n \n#define __DO_TRACE(name, args, cond, rcuidle)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint __maybe_unused __idx = 0;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (!(cond))\t\t\t\t\t\t\\\n\t\t\treturn;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (WARN_ON_ONCE(RCUIDLE_COND(rcuidle)))\t\t\\\n\t\t\treturn;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t \t\t\\\n\t\tpreempt_disable_notrace();\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t \t\t\t\t\t\t\t\\\n\t\tif (rcuidle) {\t\t\t\t\t\t\\\n\t\t\t__idx = srcu_read_lock_notrace(&tracepoint_srcu);\\\n\t\t\tct_irq_enter_irqson();\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__DO_TRACE_CALL(name, TP_ARGS(args));\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (rcuidle) {\t\t\t\t\t\t\\\n\t\t\tct_irq_exit_irqson();\t\t\t\t\\\n\t\t\tsrcu_read_unlock_notrace(&tracepoint_srcu, __idx);\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tpreempt_enable_notrace();\t\t\t\t\\\n\t} while (0)\n\n#ifndef MODULE\n#define __DECLARE_TRACE_RCU(name, proto, args, cond)\t\t\t\\\n\tstatic inline void trace_##name##_rcuidle(proto)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tif (static_key_false(&__tracepoint_##name.key))\t\t\\\n\t\t\t__DO_TRACE(name,\t\t\t\t\\\n\t\t\t\tTP_ARGS(args),\t\t\t\t\\\n\t\t\t\tTP_CONDITION(cond), 1);\t\t\t\\\n\t}\n#else\n#define __DECLARE_TRACE_RCU(name, proto, args, cond)\n#endif\n\n \n#define __DECLARE_TRACE(name, proto, args, cond, data_proto)\t\t\\\n\textern int __traceiter_##name(data_proto);\t\t\t\\\n\tDECLARE_STATIC_CALL(tp_func_##name, __traceiter_##name);\t\\\n\textern struct tracepoint __tracepoint_##name;\t\t\t\\\n\tstatic inline void trace_##name(proto)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tif (static_key_false(&__tracepoint_##name.key))\t\t\\\n\t\t\t__DO_TRACE(name,\t\t\t\t\\\n\t\t\t\tTP_ARGS(args),\t\t\t\t\\\n\t\t\t\tTP_CONDITION(cond), 0);\t\t\t\\\n\t\tif (IS_ENABLED(CONFIG_LOCKDEP) && (cond)) {\t\t\\\n\t\t\tWARN_ON_ONCE(!rcu_is_watching());\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t__DECLARE_TRACE_RCU(name, PARAMS(proto), PARAMS(args),\t\t\\\n\t\t\t    PARAMS(cond))\t\t\t\t\\\n\tstatic inline int\t\t\t\t\t\t\\\n\tregister_trace_##name(void (*probe)(data_proto), void *data)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn tracepoint_probe_register(&__tracepoint_##name,\t\\\n\t\t\t\t\t\t(void *)probe, data);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic inline int\t\t\t\t\t\t\\\n\tregister_trace_prio_##name(void (*probe)(data_proto), void *data,\\\n\t\t\t\t   int prio)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn tracepoint_probe_register_prio(&__tracepoint_##name, \\\n\t\t\t\t\t      (void *)probe, data, prio); \\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic inline int\t\t\t\t\t\t\\\n\tunregister_trace_##name(void (*probe)(data_proto), void *data)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn tracepoint_probe_unregister(&__tracepoint_##name,\\\n\t\t\t\t\t\t(void *)probe, data);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic inline void\t\t\t\t\t\t\\\n\tcheck_trace_callback_type_##name(void (*cb)(data_proto))\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic inline bool\t\t\t\t\t\t\\\n\ttrace_##name##_enabled(void)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn static_key_false(&__tracepoint_##name.key);\t\\\n\t}\n\n \n#define DEFINE_TRACE_FN(_name, _reg, _unreg, proto, args)\t\t\\\n\tstatic const char __tpstrtab_##_name[]\t\t\t\t\\\n\t__section(\"__tracepoints_strings\") = #_name;\t\t\t\\\n\textern struct static_call_key STATIC_CALL_KEY(tp_func_##_name);\t\\\n\tint __traceiter_##_name(void *__data, proto);\t\t\t\\\n\tvoid __probestub_##_name(void *__data, proto);\t\t\t\\\n\tstruct tracepoint __tracepoint_##_name\t__used\t\t\t\\\n\t__section(\"__tracepoints\") = {\t\t\t\t\t\\\n\t\t.name = __tpstrtab_##_name,\t\t\t\t\\\n\t\t.key = STATIC_KEY_INIT_FALSE,\t\t\t\t\\\n\t\t.static_call_key = &STATIC_CALL_KEY(tp_func_##_name),\t\\\n\t\t.static_call_tramp = STATIC_CALL_TRAMP_ADDR(tp_func_##_name), \\\n\t\t.iterator = &__traceiter_##_name,\t\t\t\\\n\t\t.probestub = &__probestub_##_name,\t\t\t\\\n\t\t.regfunc = _reg,\t\t\t\t\t\\\n\t\t.unregfunc = _unreg,\t\t\t\t\t\\\n\t\t.funcs = NULL };\t\t\t\t\t\\\n\t__TRACEPOINT_ENTRY(_name);\t\t\t\t\t\\\n\tint __traceiter_##_name(void *__data, proto)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tstruct tracepoint_func *it_func_ptr;\t\t\t\\\n\t\tvoid *it_func;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tit_func_ptr =\t\t\t\t\t\t\\\n\t\t\trcu_dereference_raw((&__tracepoint_##_name)->funcs); \\\n\t\tif (it_func_ptr) {\t\t\t\t\t\\\n\t\t\tdo {\t\t\t\t\t\t\\\n\t\t\t\tit_func = READ_ONCE((it_func_ptr)->func); \\\n\t\t\t\t__data = (it_func_ptr)->data;\t\t\\\n\t\t\t\t((void(*)(void *, proto))(it_func))(__data, args); \\\n\t\t\t} while ((++it_func_ptr)->func);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tvoid __probestub_##_name(void *__data, proto)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tDEFINE_STATIC_CALL(tp_func_##_name, __traceiter_##_name);\n\n#define DEFINE_TRACE(name, proto, args)\t\t\\\n\tDEFINE_TRACE_FN(name, NULL, NULL, PARAMS(proto), PARAMS(args));\n\n#define EXPORT_TRACEPOINT_SYMBOL_GPL(name)\t\t\t\t\\\n\tEXPORT_SYMBOL_GPL(__tracepoint_##name);\t\t\t\t\\\n\tEXPORT_SYMBOL_GPL(__traceiter_##name);\t\t\t\t\\\n\tEXPORT_STATIC_CALL_GPL(tp_func_##name)\n#define EXPORT_TRACEPOINT_SYMBOL(name)\t\t\t\t\t\\\n\tEXPORT_SYMBOL(__tracepoint_##name);\t\t\t\t\\\n\tEXPORT_SYMBOL(__traceiter_##name);\t\t\t\t\\\n\tEXPORT_STATIC_CALL(tp_func_##name)\n\n\n#else  \n#define __DECLARE_TRACE(name, proto, args, cond, data_proto)\t\t\\\n\tstatic inline void trace_##name(proto)\t\t\t\t\\\n\t{ }\t\t\t\t\t\t\t\t\\\n\tstatic inline void trace_##name##_rcuidle(proto)\t\t\\\n\t{ }\t\t\t\t\t\t\t\t\\\n\tstatic inline int\t\t\t\t\t\t\\\n\tregister_trace_##name(void (*probe)(data_proto),\t\t\\\n\t\t\t      void *data)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn -ENOSYS;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic inline int\t\t\t\t\t\t\\\n\tunregister_trace_##name(void (*probe)(data_proto),\t\t\\\n\t\t\t\tvoid *data)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn -ENOSYS;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic inline void check_trace_callback_type_##name(void (*cb)(data_proto)) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic inline bool\t\t\t\t\t\t\\\n\ttrace_##name##_enabled(void)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn false;\t\t\t\t\t\t\\\n\t}\n\n#define DEFINE_TRACE_FN(name, reg, unreg, proto, args)\n#define DEFINE_TRACE(name, proto, args)\n#define EXPORT_TRACEPOINT_SYMBOL_GPL(name)\n#define EXPORT_TRACEPOINT_SYMBOL(name)\n\n#endif  \n\n#ifdef CONFIG_TRACING\n \n#define tracepoint_string(str)\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tstatic const char *___tp_str __tracepoint_string = str; \\\n\t\t___tp_str;\t\t\t\t\t\t\\\n\t})\n#define __tracepoint_string\t__used __section(\"__tracepoint_str\")\n#else\n \n# define tracepoint_string(str) str\n# define __tracepoint_string\n#endif\n\n#define DECLARE_TRACE(name, proto, args)\t\t\t\t\\\n\t__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),\t\t\\\n\t\t\tcpu_online(raw_smp_processor_id()),\t\t\\\n\t\t\tPARAMS(void *__data, proto))\n\n#define DECLARE_TRACE_CONDITION(name, proto, args, cond)\t\t\\\n\t__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),\t\t\\\n\t\t\tcpu_online(raw_smp_processor_id()) && (PARAMS(cond)), \\\n\t\t\tPARAMS(void *__data, proto))\n\n#define TRACE_EVENT_FLAGS(event, flag)\n\n#define TRACE_EVENT_PERF_PERM(event, expr...)\n\n#endif  \n\n#ifndef TRACE_EVENT\n \n\n#define DECLARE_EVENT_CLASS(name, proto, args, tstruct, assign, print)\n#define DEFINE_EVENT(template, name, proto, args)\t\t\\\n\tDECLARE_TRACE(name, PARAMS(proto), PARAMS(args))\n#define DEFINE_EVENT_FN(template, name, proto, args, reg, unreg)\\\n\tDECLARE_TRACE(name, PARAMS(proto), PARAMS(args))\n#define DEFINE_EVENT_PRINT(template, name, proto, args, print)\t\\\n\tDECLARE_TRACE(name, PARAMS(proto), PARAMS(args))\n#define DEFINE_EVENT_CONDITION(template, name, proto,\t\t\\\n\t\t\t       args, cond)\t\t\t\\\n\tDECLARE_TRACE_CONDITION(name, PARAMS(proto),\t\t\\\n\t\t\t\tPARAMS(args), PARAMS(cond))\n\n#define TRACE_EVENT(name, proto, args, struct, assign, print)\t\\\n\tDECLARE_TRACE(name, PARAMS(proto), PARAMS(args))\n#define TRACE_EVENT_FN(name, proto, args, struct,\t\t\\\n\t\tassign, print, reg, unreg)\t\t\t\\\n\tDECLARE_TRACE(name, PARAMS(proto), PARAMS(args))\n#define TRACE_EVENT_FN_COND(name, proto, args, cond, struct,\t\t\\\n\t\tassign, print, reg, unreg)\t\t\t\\\n\tDECLARE_TRACE_CONDITION(name, PARAMS(proto),\t\\\n\t\t\tPARAMS(args), PARAMS(cond))\n#define TRACE_EVENT_CONDITION(name, proto, args, cond,\t\t\\\n\t\t\t      struct, assign, print)\t\t\\\n\tDECLARE_TRACE_CONDITION(name, PARAMS(proto),\t\t\\\n\t\t\t\tPARAMS(args), PARAMS(cond))\n\n#define TRACE_EVENT_FLAGS(event, flag)\n\n#define TRACE_EVENT_PERF_PERM(event, expr...)\n\n#define DECLARE_EVENT_NOP(name, proto, args)\t\t\t\t\\\n\tstatic inline void trace_##name(proto)\t\t\t\t\\\n\t{ }\t\t\t\t\t\t\t\t\\\n\tstatic inline bool trace_##name##_enabled(void)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn false;\t\t\t\t\t\t\\\n\t}\n\n#define TRACE_EVENT_NOP(name, proto, args, struct, assign, print)\t\\\n\tDECLARE_EVENT_NOP(name, PARAMS(proto), PARAMS(args))\n\n#define DECLARE_EVENT_CLASS_NOP(name, proto, args, tstruct, assign, print)\n#define DEFINE_EVENT_NOP(template, name, proto, args)\t\t\t\\\n\tDECLARE_EVENT_NOP(name, PARAMS(proto), PARAMS(args))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}