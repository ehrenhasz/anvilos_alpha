{
  "module_name": "jiffies.h",
  "hash_id": "6790a27cdc3200ae991364f9d5d4bb09a625bc46be737ea4a60c85f53b6a81cd",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/jiffies.h",
  "human_readable_source": " \n#ifndef _LINUX_JIFFIES_H\n#define _LINUX_JIFFIES_H\n\n#include <linux/cache.h>\n#include <linux/limits.h>\n#include <linux/math64.h>\n#include <linux/minmax.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <vdso/jiffies.h>\n#include <asm/param.h>\t\t\t \n#include <generated/timeconst.h>\n\n \n#if HZ >= 12 && HZ < 24\n# define SHIFT_HZ\t4\n#elif HZ >= 24 && HZ < 48\n# define SHIFT_HZ\t5\n#elif HZ >= 48 && HZ < 96\n# define SHIFT_HZ\t6\n#elif HZ >= 96 && HZ < 192\n# define SHIFT_HZ\t7\n#elif HZ >= 192 && HZ < 384\n# define SHIFT_HZ\t8\n#elif HZ >= 384 && HZ < 768\n# define SHIFT_HZ\t9\n#elif HZ >= 768 && HZ < 1536\n# define SHIFT_HZ\t10\n#elif HZ >= 1536 && HZ < 3072\n# define SHIFT_HZ\t11\n#elif HZ >= 3072 && HZ < 6144\n# define SHIFT_HZ\t12\n#elif HZ >= 6144 && HZ < 12288\n# define SHIFT_HZ\t13\n#else\n# error Invalid value of HZ.\n#endif\n\n \n#define SH_DIV(NOM,DEN,LSH) (   (((NOM) / (DEN)) << (LSH))              \\\n                             + ((((NOM) % (DEN)) << (LSH)) + (DEN) / 2) / (DEN))\n\n \n#define LATCH ((CLOCK_TICK_RATE + HZ/2) / HZ)\t \n\nextern int register_refined_jiffies(long clock_tick_rate);\n\n \n#define TICK_USEC ((USEC_PER_SEC + HZ/2) / HZ)\n\n \n#define USER_TICK_USEC ((1000000UL + USER_HZ/2) / USER_HZ)\n\n#ifndef __jiffy_arch_data\n#define __jiffy_arch_data\n#endif\n\n \nextern u64 __cacheline_aligned_in_smp jiffies_64;\nextern unsigned long volatile __cacheline_aligned_in_smp __jiffy_arch_data jiffies;\n\n#if (BITS_PER_LONG < 64)\nu64 get_jiffies_64(void);\n#else\n \nstatic inline u64 get_jiffies_64(void)\n{\n\treturn (u64)jiffies;\n}\n#endif\n\n \n\n \n#define time_after(a,b)\t\t\\\n\t(typecheck(unsigned long, a) && \\\n\t typecheck(unsigned long, b) && \\\n\t ((long)((b) - (a)) < 0))\n \n#define time_before(a,b)\ttime_after(b,a)\n\n \n#define time_after_eq(a,b)\t\\\n\t(typecheck(unsigned long, a) && \\\n\t typecheck(unsigned long, b) && \\\n\t ((long)((a) - (b)) >= 0))\n \n#define time_before_eq(a,b)\ttime_after_eq(b,a)\n\n \n#define time_in_range(a,b,c) \\\n\t(time_after_eq(a,b) && \\\n\t time_before_eq(a,c))\n\n \n#define time_in_range_open(a,b,c) \\\n\t(time_after_eq(a,b) && \\\n\t time_before(a,c))\n\n \n\n \n#define time_after64(a,b)\t\\\n\t(typecheck(__u64, a) &&\t\\\n\t typecheck(__u64, b) && \\\n\t ((__s64)((b) - (a)) < 0))\n \n#define time_before64(a,b)\ttime_after64(b,a)\n\n \n#define time_after_eq64(a,b)\t\\\n\t(typecheck(__u64, a) && \\\n\t typecheck(__u64, b) && \\\n\t ((__s64)((a) - (b)) >= 0))\n \n#define time_before_eq64(a,b)\ttime_after_eq64(b,a)\n\n \n#define time_in_range64(a, b, c) \\\n\t(time_after_eq64(a, b) && \\\n\t time_before_eq64(a, c))\n\n \n\n \n#define time_is_before_jiffies(a) time_after(jiffies, a)\n \n#define time_is_before_jiffies64(a) time_after64(get_jiffies_64(), a)\n\n \n#define time_is_after_jiffies(a) time_before(jiffies, a)\n \n#define time_is_after_jiffies64(a) time_before64(get_jiffies_64(), a)\n\n \n#define time_is_before_eq_jiffies(a) time_after_eq(jiffies, a)\n \n#define time_is_before_eq_jiffies64(a) time_after_eq64(get_jiffies_64(), a)\n\n \n#define time_is_after_eq_jiffies(a) time_before_eq(jiffies, a)\n \n#define time_is_after_eq_jiffies64(a) time_before_eq64(get_jiffies_64(), a)\n\n \n#define INITIAL_JIFFIES ((unsigned long)(unsigned int) (-300*HZ))\n\n \n#define MAX_JIFFY_OFFSET ((LONG_MAX >> 1)-1)\n\nextern unsigned long preset_lpj;\n\n \n\n \n\n#define SEC_JIFFIE_SC (31 - SHIFT_HZ)\n#if !((((NSEC_PER_SEC << 2) / TICK_NSEC) << (SEC_JIFFIE_SC - 2)) & 0x80000000)\n#undef SEC_JIFFIE_SC\n#define SEC_JIFFIE_SC (32 - SHIFT_HZ)\n#endif\n#define NSEC_JIFFIE_SC (SEC_JIFFIE_SC + 29)\n#define SEC_CONVERSION ((unsigned long)((((u64)NSEC_PER_SEC << SEC_JIFFIE_SC) +\\\n                                TICK_NSEC -1) / (u64)TICK_NSEC))\n\n#define NSEC_CONVERSION ((unsigned long)((((u64)1 << NSEC_JIFFIE_SC) +\\\n                                        TICK_NSEC -1) / (u64)TICK_NSEC))\n \n#if BITS_PER_LONG < 64\n# define MAX_SEC_IN_JIFFIES \\\n\t(long)((u64)((u64)MAX_JIFFY_OFFSET * TICK_NSEC) / NSEC_PER_SEC)\n#else\t \n# define MAX_SEC_IN_JIFFIES \\\n\t(SH_DIV((MAX_JIFFY_OFFSET >> SEC_JIFFIE_SC) * TICK_NSEC, NSEC_PER_SEC, 1) - 1)\n\n#endif\n\n \nextern unsigned int jiffies_to_msecs(const unsigned long j);\nextern unsigned int jiffies_to_usecs(const unsigned long j);\n\n \nstatic inline u64 jiffies_to_nsecs(const unsigned long j)\n{\n\treturn (u64)jiffies_to_usecs(j) * NSEC_PER_USEC;\n}\n\nextern u64 jiffies64_to_nsecs(u64 j);\nextern u64 jiffies64_to_msecs(u64 j);\n\nextern unsigned long __msecs_to_jiffies(const unsigned int m);\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n \nstatic inline unsigned long _msecs_to_jiffies(const unsigned int m)\n{\n\treturn (m + (MSEC_PER_SEC / HZ) - 1) / (MSEC_PER_SEC / HZ);\n}\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n \nstatic inline unsigned long _msecs_to_jiffies(const unsigned int m)\n{\n\tif (m > jiffies_to_msecs(MAX_JIFFY_OFFSET))\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn m * (HZ / MSEC_PER_SEC);\n}\n#else\n \nstatic inline unsigned long _msecs_to_jiffies(const unsigned int m)\n{\n\tif (HZ > MSEC_PER_SEC && m > jiffies_to_msecs(MAX_JIFFY_OFFSET))\n\t\treturn MAX_JIFFY_OFFSET;\n\n\treturn (MSEC_TO_HZ_MUL32 * m + MSEC_TO_HZ_ADJ32) >> MSEC_TO_HZ_SHR32;\n}\n#endif\n \nstatic __always_inline unsigned long msecs_to_jiffies(const unsigned int m)\n{\n\tif (__builtin_constant_p(m)) {\n\t\tif ((int)m < 0)\n\t\t\treturn MAX_JIFFY_OFFSET;\n\t\treturn _msecs_to_jiffies(m);\n\t} else {\n\t\treturn __msecs_to_jiffies(m);\n\t}\n}\n\nextern unsigned long __usecs_to_jiffies(const unsigned int u);\n#if !(USEC_PER_SEC % HZ)\nstatic inline unsigned long _usecs_to_jiffies(const unsigned int u)\n{\n\treturn (u + (USEC_PER_SEC / HZ) - 1) / (USEC_PER_SEC / HZ);\n}\n#else\nstatic inline unsigned long _usecs_to_jiffies(const unsigned int u)\n{\n\treturn (USEC_TO_HZ_MUL32 * u + USEC_TO_HZ_ADJ32)\n\t\t>> USEC_TO_HZ_SHR32;\n}\n#endif\n\n \nstatic __always_inline unsigned long usecs_to_jiffies(const unsigned int u)\n{\n\tif (__builtin_constant_p(u)) {\n\t\tif (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))\n\t\t\treturn MAX_JIFFY_OFFSET;\n\t\treturn _usecs_to_jiffies(u);\n\t} else {\n\t\treturn __usecs_to_jiffies(u);\n\t}\n}\n\nextern unsigned long timespec64_to_jiffies(const struct timespec64 *value);\nextern void jiffies_to_timespec64(const unsigned long jiffies,\n\t\t\t\t  struct timespec64 *value);\nextern clock_t jiffies_to_clock_t(unsigned long x);\n\nstatic inline clock_t jiffies_delta_to_clock_t(long delta)\n{\n\treturn jiffies_to_clock_t(max(0L, delta));\n}\n\nstatic inline unsigned int jiffies_delta_to_msecs(long delta)\n{\n\treturn jiffies_to_msecs(max(0L, delta));\n}\n\nextern unsigned long clock_t_to_jiffies(unsigned long x);\nextern u64 jiffies_64_to_clock_t(u64 x);\nextern u64 nsec_to_clock_t(u64 x);\nextern u64 nsecs_to_jiffies64(u64 n);\nextern unsigned long nsecs_to_jiffies(u64 n);\n\n#define TIMESTAMP_SIZE\t30\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}