{
  "module_name": "tpm.h",
  "hash_id": "84aa565208ddcca3672da8b59905daf3917707205312e5c449f76afe06baf95f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/tpm.h",
  "human_readable_source": " \n \n#ifndef __LINUX_TPM_H__\n#define __LINUX_TPM_H__\n\n#include <linux/hw_random.h>\n#include <linux/acpi.h>\n#include <linux/cdev.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <crypto/hash_info.h>\n\n#define TPM_DIGEST_SIZE 20\t \n#define TPM_MAX_DIGEST_SIZE SHA512_DIGEST_SIZE\n\nstruct tpm_chip;\nstruct trusted_key_payload;\nstruct trusted_key_options;\n\n \nenum tpm_algorithms {\n\tTPM_ALG_ERROR\t\t= 0x0000,\n\tTPM_ALG_SHA1\t\t= 0x0004,\n\tTPM_ALG_KEYEDHASH\t= 0x0008,\n\tTPM_ALG_SHA256\t\t= 0x000B,\n\tTPM_ALG_SHA384\t\t= 0x000C,\n\tTPM_ALG_SHA512\t\t= 0x000D,\n\tTPM_ALG_NULL\t\t= 0x0010,\n\tTPM_ALG_SM3_256\t\t= 0x0012,\n};\n\n \n#define TPM_MAX_HASHES\t5\n\nstruct tpm_digest {\n\tu16 alg_id;\n\tu8 digest[TPM_MAX_DIGEST_SIZE];\n} __packed;\n\nstruct tpm_bank_info {\n\tu16 alg_id;\n\tu16 digest_size;\n\tu16 crypto_id;\n};\n\nenum TPM_OPS_FLAGS {\n\tTPM_OPS_AUTO_STARTUP = BIT(0),\n};\n\nstruct tpm_class_ops {\n\tunsigned int flags;\n\tconst u8 req_complete_mask;\n\tconst u8 req_complete_val;\n\tbool (*req_canceled)(struct tpm_chip *chip, u8 status);\n\tint (*recv) (struct tpm_chip *chip, u8 *buf, size_t len);\n\tint (*send) (struct tpm_chip *chip, u8 *buf, size_t len);\n\tvoid (*cancel) (struct tpm_chip *chip);\n\tu8 (*status) (struct tpm_chip *chip);\n\tvoid (*update_timeouts)(struct tpm_chip *chip,\n\t\t\t\tunsigned long *timeout_cap);\n\tvoid (*update_durations)(struct tpm_chip *chip,\n\t\t\t\t unsigned long *duration_cap);\n\tint (*go_idle)(struct tpm_chip *chip);\n\tint (*cmd_ready)(struct tpm_chip *chip);\n\tint (*request_locality)(struct tpm_chip *chip, int loc);\n\tint (*relinquish_locality)(struct tpm_chip *chip, int loc);\n\tvoid (*clk_enable)(struct tpm_chip *chip, bool value);\n};\n\n#define TPM_NUM_EVENT_LOG_FILES\t\t3\n\n \nenum tpm_duration {\n\tTPM_SHORT = 0,\n\tTPM_MEDIUM = 1,\n\tTPM_LONG = 2,\n\tTPM_LONG_LONG = 3,\n\tTPM_UNDEFINED,\n\tTPM_NUM_DURATIONS = TPM_UNDEFINED,\n};\n\n#define TPM_PPI_VERSION_LEN\t\t3\n\nstruct tpm_space {\n\tu32 context_tbl[3];\n\tu8 *context_buf;\n\tu32 session_tbl[3];\n\tu8 *session_buf;\n\tu32 buf_size;\n};\n\nstruct tpm_bios_log {\n\tvoid *bios_event_log;\n\tvoid *bios_event_log_end;\n};\n\nstruct tpm_chip_seqops {\n\tstruct tpm_chip *chip;\n\tconst struct seq_operations *seqops;\n};\n\nstruct tpm_chip {\n\tstruct device dev;\n\tstruct device devs;\n\tstruct cdev cdev;\n\tstruct cdev cdevs;\n\n\t \n\tstruct rw_semaphore ops_sem;\n\tconst struct tpm_class_ops *ops;\n\n\tstruct tpm_bios_log log;\n\tstruct tpm_chip_seqops bin_log_seqops;\n\tstruct tpm_chip_seqops ascii_log_seqops;\n\n\tunsigned int flags;\n\n\tint dev_num;\t\t \n\tunsigned long is_open;\t \n\n\tchar hwrng_name[64];\n\tstruct hwrng hwrng;\n\n\tstruct mutex tpm_mutex;\t \n\n\tunsigned long timeout_a;  \n\tunsigned long timeout_b;  \n\tunsigned long timeout_c;  \n\tunsigned long timeout_d;  \n\tbool timeout_adjusted;\n\tunsigned long duration[TPM_NUM_DURATIONS];  \n\tbool duration_adjusted;\n\n\tstruct dentry *bios_dir[TPM_NUM_EVENT_LOG_FILES];\n\n\tconst struct attribute_group *groups[3 + TPM_MAX_HASHES];\n\tunsigned int groups_cnt;\n\n\tu32 nr_allocated_banks;\n\tstruct tpm_bank_info *allocated_banks;\n#ifdef CONFIG_ACPI\n\tacpi_handle acpi_dev_handle;\n\tchar ppi_version[TPM_PPI_VERSION_LEN + 1];\n#endif  \n\n\tstruct tpm_space work_space;\n\tu32 last_cc;\n\tu32 nr_commands;\n\tu32 *cc_attrs_tbl;\n\n\t \n\tint locality;\n};\n\n#define TPM_HEADER_SIZE\t\t10\n\nenum tpm2_const {\n\tTPM2_PLATFORM_PCR       =     24,\n\tTPM2_PCR_SELECT_MIN     = ((TPM2_PLATFORM_PCR + 7) / 8),\n};\n\nenum tpm2_timeouts {\n\tTPM2_TIMEOUT_A          =    750,\n\tTPM2_TIMEOUT_B          =   2000,\n\tTPM2_TIMEOUT_C          =    200,\n\tTPM2_TIMEOUT_D          =     30,\n\tTPM2_DURATION_SHORT     =     20,\n\tTPM2_DURATION_MEDIUM    =    750,\n\tTPM2_DURATION_LONG      =   2000,\n\tTPM2_DURATION_LONG_LONG = 300000,\n\tTPM2_DURATION_DEFAULT   = 120000,\n};\n\nenum tpm2_structures {\n\tTPM2_ST_NO_SESSIONS\t= 0x8001,\n\tTPM2_ST_SESSIONS\t= 0x8002,\n};\n\n \n#define TSS2_RC_LAYER_SHIFT\t 16\n#define TSS2_RESMGR_TPM_RC_LAYER (11 << TSS2_RC_LAYER_SHIFT)\n\nenum tpm2_return_codes {\n\tTPM2_RC_SUCCESS\t\t= 0x0000,\n\tTPM2_RC_HASH\t\t= 0x0083,  \n\tTPM2_RC_HANDLE\t\t= 0x008B,\n\tTPM2_RC_INITIALIZE\t= 0x0100,  \n\tTPM2_RC_FAILURE\t\t= 0x0101,\n\tTPM2_RC_DISABLED\t= 0x0120,\n\tTPM2_RC_UPGRADE\t\t= 0x012D,\n\tTPM2_RC_COMMAND_CODE    = 0x0143,\n\tTPM2_RC_TESTING\t\t= 0x090A,  \n\tTPM2_RC_REFERENCE_H0\t= 0x0910,\n\tTPM2_RC_RETRY\t\t= 0x0922,\n};\n\nenum tpm2_command_codes {\n\tTPM2_CC_FIRST\t\t        = 0x011F,\n\tTPM2_CC_HIERARCHY_CONTROL       = 0x0121,\n\tTPM2_CC_HIERARCHY_CHANGE_AUTH   = 0x0129,\n\tTPM2_CC_CREATE_PRIMARY          = 0x0131,\n\tTPM2_CC_SEQUENCE_COMPLETE       = 0x013E,\n\tTPM2_CC_SELF_TEST\t        = 0x0143,\n\tTPM2_CC_STARTUP\t\t        = 0x0144,\n\tTPM2_CC_SHUTDOWN\t        = 0x0145,\n\tTPM2_CC_NV_READ                 = 0x014E,\n\tTPM2_CC_CREATE\t\t        = 0x0153,\n\tTPM2_CC_LOAD\t\t        = 0x0157,\n\tTPM2_CC_SEQUENCE_UPDATE         = 0x015C,\n\tTPM2_CC_UNSEAL\t\t        = 0x015E,\n\tTPM2_CC_CONTEXT_LOAD\t        = 0x0161,\n\tTPM2_CC_CONTEXT_SAVE\t        = 0x0162,\n\tTPM2_CC_FLUSH_CONTEXT\t        = 0x0165,\n\tTPM2_CC_VERIFY_SIGNATURE        = 0x0177,\n\tTPM2_CC_GET_CAPABILITY\t        = 0x017A,\n\tTPM2_CC_GET_RANDOM\t        = 0x017B,\n\tTPM2_CC_PCR_READ\t        = 0x017E,\n\tTPM2_CC_PCR_EXTEND\t        = 0x0182,\n\tTPM2_CC_EVENT_SEQUENCE_COMPLETE = 0x0185,\n\tTPM2_CC_HASH_SEQUENCE_START     = 0x0186,\n\tTPM2_CC_CREATE_LOADED           = 0x0191,\n\tTPM2_CC_LAST\t\t        = 0x0193,  \n};\n\nenum tpm2_permanent_handles {\n\tTPM2_RS_PW\t\t= 0x40000009,\n};\n\nenum tpm2_capabilities {\n\tTPM2_CAP_HANDLES\t= 1,\n\tTPM2_CAP_COMMANDS\t= 2,\n\tTPM2_CAP_PCRS\t\t= 5,\n\tTPM2_CAP_TPM_PROPERTIES = 6,\n};\n\nenum tpm2_properties {\n\tTPM_PT_TOTAL_COMMANDS\t= 0x0129,\n};\n\nenum tpm2_startup_types {\n\tTPM2_SU_CLEAR\t= 0x0000,\n\tTPM2_SU_STATE\t= 0x0001,\n};\n\nenum tpm2_cc_attrs {\n\tTPM2_CC_ATTR_CHANDLES\t= 25,\n\tTPM2_CC_ATTR_RHANDLE\t= 28,\n\tTPM2_CC_ATTR_VENDOR\t= 29,\n};\n\n#define TPM_VID_INTEL    0x8086\n#define TPM_VID_WINBOND  0x1050\n#define TPM_VID_STM      0x104A\n#define TPM_VID_ATML     0x1114\n\nenum tpm_chip_flags {\n\tTPM_CHIP_FLAG_BOOTSTRAPPED\t\t= BIT(0),\n\tTPM_CHIP_FLAG_TPM2\t\t\t= BIT(1),\n\tTPM_CHIP_FLAG_IRQ\t\t\t= BIT(2),\n\tTPM_CHIP_FLAG_VIRTUAL\t\t\t= BIT(3),\n\tTPM_CHIP_FLAG_HAVE_TIMEOUTS\t\t= BIT(4),\n\tTPM_CHIP_FLAG_ALWAYS_POWERED\t\t= BIT(5),\n\tTPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED\t= BIT(6),\n\tTPM_CHIP_FLAG_FIRMWARE_UPGRADE\t\t= BIT(7),\n\tTPM_CHIP_FLAG_SUSPENDED\t\t\t= BIT(8),\n\tTPM_CHIP_FLAG_HWRNG_DISABLED\t\t= BIT(9),\n};\n\n#define to_tpm_chip(d) container_of(d, struct tpm_chip, dev)\n\nstruct tpm_header {\n\t__be16 tag;\n\t__be32 length;\n\tunion {\n\t\t__be32 ordinal;\n\t\t__be32 return_code;\n\t};\n} __packed;\n\n \n\nenum tpm_buf_flags {\n\tTPM_BUF_OVERFLOW\t= BIT(0),\n};\n\nstruct tpm_buf {\n\tunsigned int flags;\n\tu8 *data;\n};\n\nenum tpm2_object_attributes {\n\tTPM2_OA_FIXED_TPM\t\t= BIT(1),\n\tTPM2_OA_FIXED_PARENT\t\t= BIT(4),\n\tTPM2_OA_USER_WITH_AUTH\t\t= BIT(6),\n};\n\nenum tpm2_session_attributes {\n\tTPM2_SA_CONTINUE_SESSION\t= BIT(0),\n};\n\nstruct tpm2_hash {\n\tunsigned int crypto_id;\n\tunsigned int tpm_id;\n};\n\nstatic inline void tpm_buf_reset(struct tpm_buf *buf, u16 tag, u32 ordinal)\n{\n\tstruct tpm_header *head = (struct tpm_header *)buf->data;\n\n\thead->tag = cpu_to_be16(tag);\n\thead->length = cpu_to_be32(sizeof(*head));\n\thead->ordinal = cpu_to_be32(ordinal);\n}\n\nstatic inline int tpm_buf_init(struct tpm_buf *buf, u16 tag, u32 ordinal)\n{\n\tbuf->data = (u8 *)__get_free_page(GFP_KERNEL);\n\tif (!buf->data)\n\t\treturn -ENOMEM;\n\n\tbuf->flags = 0;\n\ttpm_buf_reset(buf, tag, ordinal);\n\treturn 0;\n}\n\nstatic inline void tpm_buf_destroy(struct tpm_buf *buf)\n{\n\tfree_page((unsigned long)buf->data);\n}\n\nstatic inline u32 tpm_buf_length(struct tpm_buf *buf)\n{\n\tstruct tpm_header *head = (struct tpm_header *)buf->data;\n\n\treturn be32_to_cpu(head->length);\n}\n\nstatic inline u16 tpm_buf_tag(struct tpm_buf *buf)\n{\n\tstruct tpm_header *head = (struct tpm_header *)buf->data;\n\n\treturn be16_to_cpu(head->tag);\n}\n\nstatic inline void tpm_buf_append(struct tpm_buf *buf,\n\t\t\t\t  const unsigned char *new_data,\n\t\t\t\t  unsigned int new_len)\n{\n\tstruct tpm_header *head = (struct tpm_header *)buf->data;\n\tu32 len = tpm_buf_length(buf);\n\n\t \n\tif (buf->flags & TPM_BUF_OVERFLOW)\n\t\treturn;\n\n\tif ((len + new_len) > PAGE_SIZE) {\n\t\tWARN(1, \"tpm_buf: overflow\\n\");\n\t\tbuf->flags |= TPM_BUF_OVERFLOW;\n\t\treturn;\n\t}\n\n\tmemcpy(&buf->data[len], new_data, new_len);\n\thead->length = cpu_to_be32(len + new_len);\n}\n\nstatic inline void tpm_buf_append_u8(struct tpm_buf *buf, const u8 value)\n{\n\ttpm_buf_append(buf, &value, 1);\n}\n\nstatic inline void tpm_buf_append_u16(struct tpm_buf *buf, const u16 value)\n{\n\t__be16 value2 = cpu_to_be16(value);\n\n\ttpm_buf_append(buf, (u8 *) &value2, 2);\n}\n\nstatic inline void tpm_buf_append_u32(struct tpm_buf *buf, const u32 value)\n{\n\t__be32 value2 = cpu_to_be32(value);\n\n\ttpm_buf_append(buf, (u8 *) &value2, 4);\n}\n\n \nstatic inline bool tpm_is_firmware_upgrade(struct tpm_chip *chip)\n{\n\treturn chip->flags & TPM_CHIP_FLAG_FIRMWARE_UPGRADE;\n}\n\nstatic inline u32 tpm2_rc_value(u32 rc)\n{\n\treturn (rc & BIT(7)) ? rc & 0xff : rc;\n}\n\n#if defined(CONFIG_TCG_TPM) || defined(CONFIG_TCG_TPM_MODULE)\n\nextern int tpm_is_tpm2(struct tpm_chip *chip);\nextern __must_check int tpm_try_get_ops(struct tpm_chip *chip);\nextern void tpm_put_ops(struct tpm_chip *chip);\nextern ssize_t tpm_transmit_cmd(struct tpm_chip *chip, struct tpm_buf *buf,\n\t\t\t\tsize_t min_rsp_body_length, const char *desc);\nextern int tpm_pcr_read(struct tpm_chip *chip, u32 pcr_idx,\n\t\t\tstruct tpm_digest *digest);\nextern int tpm_pcr_extend(struct tpm_chip *chip, u32 pcr_idx,\n\t\t\t  struct tpm_digest *digests);\nextern int tpm_send(struct tpm_chip *chip, void *cmd, size_t buflen);\nextern int tpm_get_random(struct tpm_chip *chip, u8 *data, size_t max);\nextern struct tpm_chip *tpm_default_chip(void);\nvoid tpm2_flush_context(struct tpm_chip *chip, u32 handle);\n#else\nstatic inline int tpm_is_tpm2(struct tpm_chip *chip)\n{\n\treturn -ENODEV;\n}\nstatic inline int tpm_pcr_read(struct tpm_chip *chip, int pcr_idx,\n\t\t\t       struct tpm_digest *digest)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int tpm_pcr_extend(struct tpm_chip *chip, u32 pcr_idx,\n\t\t\t\t struct tpm_digest *digests)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int tpm_send(struct tpm_chip *chip, void *cmd, size_t buflen)\n{\n\treturn -ENODEV;\n}\nstatic inline int tpm_get_random(struct tpm_chip *chip, u8 *data, size_t max)\n{\n\treturn -ENODEV;\n}\n\nstatic inline struct tpm_chip *tpm_default_chip(void)\n{\n\treturn NULL;\n}\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}