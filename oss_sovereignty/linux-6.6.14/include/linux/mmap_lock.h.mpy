{
  "module_name": "mmap_lock.h",
  "hash_id": "a278897c0b9d60ed494386d500e202ffe3679b9cb490d9a3e8c1a7e2c76c84b5",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mmap_lock.h",
  "human_readable_source": "#ifndef _LINUX_MMAP_LOCK_H\n#define _LINUX_MMAP_LOCK_H\n\n#include <linux/lockdep.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/rwsem.h>\n#include <linux/tracepoint-defs.h>\n#include <linux/types.h>\n\n#define MMAP_LOCK_INITIALIZER(name) \\\n\t.mmap_lock = __RWSEM_INITIALIZER((name).mmap_lock),\n\nDECLARE_TRACEPOINT(mmap_lock_start_locking);\nDECLARE_TRACEPOINT(mmap_lock_acquire_returned);\nDECLARE_TRACEPOINT(mmap_lock_released);\n\n#ifdef CONFIG_TRACING\n\nvoid __mmap_lock_do_trace_start_locking(struct mm_struct *mm, bool write);\nvoid __mmap_lock_do_trace_acquire_returned(struct mm_struct *mm, bool write,\n\t\t\t\t\t   bool success);\nvoid __mmap_lock_do_trace_released(struct mm_struct *mm, bool write);\n\nstatic inline void __mmap_lock_trace_start_locking(struct mm_struct *mm,\n\t\t\t\t\t\t   bool write)\n{\n\tif (tracepoint_enabled(mmap_lock_start_locking))\n\t\t__mmap_lock_do_trace_start_locking(mm, write);\n}\n\nstatic inline void __mmap_lock_trace_acquire_returned(struct mm_struct *mm,\n\t\t\t\t\t\t      bool write, bool success)\n{\n\tif (tracepoint_enabled(mmap_lock_acquire_returned))\n\t\t__mmap_lock_do_trace_acquire_returned(mm, write, success);\n}\n\nstatic inline void __mmap_lock_trace_released(struct mm_struct *mm, bool write)\n{\n\tif (tracepoint_enabled(mmap_lock_released))\n\t\t__mmap_lock_do_trace_released(mm, write);\n}\n\n#else  \n\nstatic inline void __mmap_lock_trace_start_locking(struct mm_struct *mm,\n\t\t\t\t\t\t   bool write)\n{\n}\n\nstatic inline void __mmap_lock_trace_acquire_returned(struct mm_struct *mm,\n\t\t\t\t\t\t      bool write, bool success)\n{\n}\n\nstatic inline void __mmap_lock_trace_released(struct mm_struct *mm, bool write)\n{\n}\n\n#endif  \n\nstatic inline void mmap_assert_locked(struct mm_struct *mm)\n{\n\tlockdep_assert_held(&mm->mmap_lock);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_lock), mm);\n}\n\nstatic inline void mmap_assert_write_locked(struct mm_struct *mm)\n{\n\tlockdep_assert_held_write(&mm->mmap_lock);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_lock), mm);\n}\n\n#ifdef CONFIG_PER_VMA_LOCK\n \nstatic inline void vma_end_write_all(struct mm_struct *mm)\n{\n\tmmap_assert_write_locked(mm);\n\t \n\tsmp_store_release(&mm->mm_lock_seq, mm->mm_lock_seq + 1);\n}\n#else\nstatic inline void vma_end_write_all(struct mm_struct *mm) {}\n#endif\n\nstatic inline void mmap_init_lock(struct mm_struct *mm)\n{\n\tinit_rwsem(&mm->mmap_lock);\n}\n\nstatic inline void mmap_write_lock(struct mm_struct *mm)\n{\n\t__mmap_lock_trace_start_locking(mm, true);\n\tdown_write(&mm->mmap_lock);\n\t__mmap_lock_trace_acquire_returned(mm, true, true);\n}\n\nstatic inline void mmap_write_lock_nested(struct mm_struct *mm, int subclass)\n{\n\t__mmap_lock_trace_start_locking(mm, true);\n\tdown_write_nested(&mm->mmap_lock, subclass);\n\t__mmap_lock_trace_acquire_returned(mm, true, true);\n}\n\nstatic inline int mmap_write_lock_killable(struct mm_struct *mm)\n{\n\tint ret;\n\n\t__mmap_lock_trace_start_locking(mm, true);\n\tret = down_write_killable(&mm->mmap_lock);\n\t__mmap_lock_trace_acquire_returned(mm, true, ret == 0);\n\treturn ret;\n}\n\nstatic inline void mmap_write_unlock(struct mm_struct *mm)\n{\n\t__mmap_lock_trace_released(mm, true);\n\tvma_end_write_all(mm);\n\tup_write(&mm->mmap_lock);\n}\n\nstatic inline void mmap_write_downgrade(struct mm_struct *mm)\n{\n\t__mmap_lock_trace_acquire_returned(mm, false, true);\n\tvma_end_write_all(mm);\n\tdowngrade_write(&mm->mmap_lock);\n}\n\nstatic inline void mmap_read_lock(struct mm_struct *mm)\n{\n\t__mmap_lock_trace_start_locking(mm, false);\n\tdown_read(&mm->mmap_lock);\n\t__mmap_lock_trace_acquire_returned(mm, false, true);\n}\n\nstatic inline int mmap_read_lock_killable(struct mm_struct *mm)\n{\n\tint ret;\n\n\t__mmap_lock_trace_start_locking(mm, false);\n\tret = down_read_killable(&mm->mmap_lock);\n\t__mmap_lock_trace_acquire_returned(mm, false, ret == 0);\n\treturn ret;\n}\n\nstatic inline bool mmap_read_trylock(struct mm_struct *mm)\n{\n\tbool ret;\n\n\t__mmap_lock_trace_start_locking(mm, false);\n\tret = down_read_trylock(&mm->mmap_lock) != 0;\n\t__mmap_lock_trace_acquire_returned(mm, false, ret);\n\treturn ret;\n}\n\nstatic inline void mmap_read_unlock(struct mm_struct *mm)\n{\n\t__mmap_lock_trace_released(mm, false);\n\tup_read(&mm->mmap_lock);\n}\n\nstatic inline void mmap_read_unlock_non_owner(struct mm_struct *mm)\n{\n\t__mmap_lock_trace_released(mm, false);\n\tup_read_non_owner(&mm->mmap_lock);\n}\n\nstatic inline int mmap_lock_is_contended(struct mm_struct *mm)\n{\n\treturn rwsem_is_contended(&mm->mmap_lock);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}