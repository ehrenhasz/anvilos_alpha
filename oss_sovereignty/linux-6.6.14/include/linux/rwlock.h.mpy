{
  "module_name": "rwlock.h",
  "hash_id": "ba0cd656fd5df3c8b0e7a4ca35fc69c2bd560f6bce34a35e820ad10ad0aebe7a",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/rwlock.h",
  "human_readable_source": "#ifndef __LINUX_RWLOCK_H\n#define __LINUX_RWLOCK_H\n\n#ifndef __LINUX_INSIDE_SPINLOCK_H\n# error \"please don't include this file directly\"\n#endif\n\n \n\n#ifdef CONFIG_DEBUG_SPINLOCK\n  extern void __rwlock_init(rwlock_t *lock, const char *name,\n\t\t\t    struct lock_class_key *key);\n# define rwlock_init(lock)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t__rwlock_init((lock), #lock, &__key);\t\t\t\\\n} while (0)\n#else\n# define rwlock_init(lock)\t\t\t\t\t\\\n\tdo { *(lock) = __RW_LOCK_UNLOCKED(lock); } while (0)\n#endif\n\n#ifdef CONFIG_DEBUG_SPINLOCK\n extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n extern int do_raw_read_trylock(rwlock_t *lock);\n extern void do_raw_read_unlock(rwlock_t *lock) __releases(lock);\n extern void do_raw_write_lock(rwlock_t *lock) __acquires(lock);\n extern int do_raw_write_trylock(rwlock_t *lock);\n extern void do_raw_write_unlock(rwlock_t *lock) __releases(lock);\n#else\n# define do_raw_read_lock(rwlock)\tdo {__acquire(lock); arch_read_lock(&(rwlock)->raw_lock); } while (0)\n# define do_raw_read_trylock(rwlock)\tarch_read_trylock(&(rwlock)->raw_lock)\n# define do_raw_read_unlock(rwlock)\tdo {arch_read_unlock(&(rwlock)->raw_lock); __release(lock); } while (0)\n# define do_raw_write_lock(rwlock)\tdo {__acquire(lock); arch_write_lock(&(rwlock)->raw_lock); } while (0)\n# define do_raw_write_trylock(rwlock)\tarch_write_trylock(&(rwlock)->raw_lock)\n# define do_raw_write_unlock(rwlock)\tdo {arch_write_unlock(&(rwlock)->raw_lock); __release(lock); } while (0)\n#endif\n\n \n#define read_trylock(lock)\t__cond_lock(lock, _raw_read_trylock(lock))\n#define write_trylock(lock)\t__cond_lock(lock, _raw_write_trylock(lock))\n\n#define write_lock(lock)\t_raw_write_lock(lock)\n#define read_lock(lock)\t\t_raw_read_lock(lock)\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n#define write_lock_nested(lock, subclass)\t_raw_write_lock_nested(lock, subclass)\n#else\n#define write_lock_nested(lock, subclass)\t_raw_write_lock(lock)\n#endif\n\n#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n\n#define read_lock_irqsave(lock, flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\\\n\t\tflags = _raw_read_lock_irqsave(lock);\t\\\n\t} while (0)\n#define write_lock_irqsave(lock, flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\\\n\t\tflags = _raw_write_lock_irqsave(lock);\t\\\n\t} while (0)\n\n#else\n\n#define read_lock_irqsave(lock, flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\\\n\t\t_raw_read_lock_irqsave(lock, flags);\t\\\n\t} while (0)\n#define write_lock_irqsave(lock, flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\\\n\t\t_raw_write_lock_irqsave(lock, flags);\t\\\n\t} while (0)\n\n#endif\n\n#define read_lock_irq(lock)\t\t_raw_read_lock_irq(lock)\n#define read_lock_bh(lock)\t\t_raw_read_lock_bh(lock)\n#define write_lock_irq(lock)\t\t_raw_write_lock_irq(lock)\n#define write_lock_bh(lock)\t\t_raw_write_lock_bh(lock)\n#define read_unlock(lock)\t\t_raw_read_unlock(lock)\n#define write_unlock(lock)\t\t_raw_write_unlock(lock)\n#define read_unlock_irq(lock)\t\t_raw_read_unlock_irq(lock)\n#define write_unlock_irq(lock)\t\t_raw_write_unlock_irq(lock)\n\n#define read_unlock_irqrestore(lock, flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\t\\\n\t\t_raw_read_unlock_irqrestore(lock, flags);\t\\\n\t} while (0)\n#define read_unlock_bh(lock)\t\t_raw_read_unlock_bh(lock)\n\n#define write_unlock_irqrestore(lock, flags)\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\\\n\t\t_raw_write_unlock_irqrestore(lock, flags);\t\\\n\t} while (0)\n#define write_unlock_bh(lock)\t\t_raw_write_unlock_bh(lock)\n\n#define write_trylock_irqsave(lock, flags) \\\n({ \\\n\tlocal_irq_save(flags); \\\n\twrite_trylock(lock) ? \\\n\t1 : ({ local_irq_restore(flags); 0; }); \\\n})\n\n#ifdef arch_rwlock_is_contended\n#define rwlock_is_contended(lock) \\\n\t arch_rwlock_is_contended(&(lock)->raw_lock)\n#else\n#define rwlock_is_contended(lock)\t((void)(lock), 0)\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}