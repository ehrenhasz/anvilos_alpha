{
  "module_name": "crush.h",
  "hash_id": "caf86d49181d3f479b5b6a936545838e9ad61b238d94edc6ae5b15483b9585ba",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/crush/crush.h",
  "human_readable_source": " \n#ifndef CEPH_CRUSH_CRUSH_H\n#define CEPH_CRUSH_CRUSH_H\n\n#ifdef __KERNEL__\n# include <linux/rbtree.h>\n# include <linux/types.h>\n#else\n# include \"crush_compat.h\"\n#endif\n\n \n\n\n#define CRUSH_MAGIC 0x00010000ul    \n\n#define CRUSH_MAX_DEPTH 10   \n#define CRUSH_MAX_RULESET (1<<8)   \n#define CRUSH_MAX_RULES CRUSH_MAX_RULESET   \n\n#define CRUSH_MAX_DEVICE_WEIGHT (100u * 0x10000u)\n#define CRUSH_MAX_BUCKET_WEIGHT (65535u * 0x10000u)\n\n#define CRUSH_ITEM_UNDEF  0x7ffffffe   \n#define CRUSH_ITEM_NONE   0x7fffffff   \n\n \nstruct crush_rule_step {\n\t__u32 op;\n\t__s32 arg1;\n\t__s32 arg2;\n};\n\n \nenum {\n\tCRUSH_RULE_NOOP = 0,\n\tCRUSH_RULE_TAKE = 1,           \n\tCRUSH_RULE_CHOOSE_FIRSTN = 2,  \n\t\t\t\t       \n\tCRUSH_RULE_CHOOSE_INDEP = 3,   \n\tCRUSH_RULE_EMIT = 4,           \n\tCRUSH_RULE_CHOOSELEAF_FIRSTN = 6,\n\tCRUSH_RULE_CHOOSELEAF_INDEP = 7,\n\n\tCRUSH_RULE_SET_CHOOSE_TRIES = 8,  \n\tCRUSH_RULE_SET_CHOOSELEAF_TRIES = 9,  \n\tCRUSH_RULE_SET_CHOOSE_LOCAL_TRIES = 10,\n\tCRUSH_RULE_SET_CHOOSE_LOCAL_FALLBACK_TRIES = 11,\n\tCRUSH_RULE_SET_CHOOSELEAF_VARY_R = 12,\n\tCRUSH_RULE_SET_CHOOSELEAF_STABLE = 13\n};\n\n \n#define CRUSH_CHOOSE_N            0\n#define CRUSH_CHOOSE_N_MINUS(x)   (-(x))\n\n \nstruct crush_rule_mask {\n\t__u8 ruleset;\n\t__u8 type;\n\t__u8 min_size;\n\t__u8 max_size;\n};\n\nstruct crush_rule {\n\t__u32 len;\n\tstruct crush_rule_mask mask;\n\tstruct crush_rule_step steps[];\n};\n\n#define crush_rule_size(len) (sizeof(struct crush_rule) + \\\n\t\t\t      (len)*sizeof(struct crush_rule_step))\n\n\n\n \nenum {\n\tCRUSH_BUCKET_UNIFORM = 1,\n\tCRUSH_BUCKET_LIST = 2,\n\tCRUSH_BUCKET_TREE = 3,\n\tCRUSH_BUCKET_STRAW = 4,\n\tCRUSH_BUCKET_STRAW2 = 5,\n};\nextern const char *crush_bucket_alg_name(int alg);\n\n \n#define CRUSH_LEGACY_ALLOWED_BUCKET_ALGS (\t\\\n\t\t(1 << CRUSH_BUCKET_UNIFORM) |\t\\\n\t\t(1 << CRUSH_BUCKET_LIST) |\t\\\n\t\t(1 << CRUSH_BUCKET_STRAW))\n\nstruct crush_bucket {\n\t__s32 id;         \n\t__u16 type;       \n\t__u8 alg;         \n\t__u8 hash;        \n\t__u32 weight;     \n\t__u32 size;       \n\t__s32 *items;\n\n};\n\n \nstruct crush_weight_set {\n\t__u32 *weights;  \n\t__u32 size;      \n};\n\n \nstruct crush_choose_arg {\n\t__s32 *ids;             \n\t__u32 ids_size;         \n\tstruct crush_weight_set *weight_set;  \n\t__u32 weight_set_size;  \n};\n\n \nstruct crush_choose_arg_map {\n#ifdef __KERNEL__\n\tstruct rb_node node;\n\ts64 choose_args_index;\n#endif\n\tstruct crush_choose_arg *args;  \n\t__u32 size;                     \n};\n\nstruct crush_bucket_uniform {\n\tstruct crush_bucket h;\n\t__u32 item_weight;   \n};\n\nstruct crush_bucket_list {\n\tstruct crush_bucket h;\n\t__u32 *item_weights;   \n\t__u32 *sum_weights;    \n};\n\nstruct crush_bucket_tree {\n\tstruct crush_bucket h;   \n\t__u8 num_nodes;\n\t__u32 *node_weights;\n};\n\nstruct crush_bucket_straw {\n\tstruct crush_bucket h;\n\t__u32 *item_weights;    \n\t__u32 *straws;          \n};\n\nstruct crush_bucket_straw2 {\n\tstruct crush_bucket h;\n\t__u32 *item_weights;    \n};\n\n\n\n \nstruct crush_map {\n\tstruct crush_bucket **buckets;\n\tstruct crush_rule **rules;\n\n\t__s32 max_buckets;\n\t__u32 max_rules;\n\t__s32 max_devices;\n\n\t \n\t__u32 choose_local_tries;\n\t \n\t__u32 choose_local_fallback_tries;\n\t \n\t__u32 choose_total_tries;\n\t \n\t__u32 chooseleaf_descend_once;\n\n\t \n\t__u8 chooseleaf_vary_r;\n\n\t \n\t__u8 chooseleaf_stable;\n\n\t \n\tsize_t working_size;\n\n#ifndef __KERNEL__\n\t \n\t__u8 straw_calc_version;\n\n\t \n\t__u32 allowed_bucket_algs;\n\n\t__u32 *choose_tries;\n#else\n\t \n\tstruct rb_root type_names;\n\n\t \n\tstruct rb_root names;\n\n\t \n\tstruct rb_root choose_args;\n#endif\n};\n\n\n \nextern int crush_get_bucket_item_weight(const struct crush_bucket *b, int pos);\nextern void crush_destroy_bucket_uniform(struct crush_bucket_uniform *b);\nextern void crush_destroy_bucket_list(struct crush_bucket_list *b);\nextern void crush_destroy_bucket_tree(struct crush_bucket_tree *b);\nextern void crush_destroy_bucket_straw(struct crush_bucket_straw *b);\nextern void crush_destroy_bucket_straw2(struct crush_bucket_straw2 *b);\nextern void crush_destroy_bucket(struct crush_bucket *b);\nextern void crush_destroy_rule(struct crush_rule *r);\nextern void crush_destroy(struct crush_map *map);\n\nstatic inline int crush_calc_tree_node(int i)\n{\n\treturn ((i+1) << 1)-1;\n}\n\n \nstruct crush_work_bucket {\n\t__u32 perm_x;  \n\t__u32 perm_n;  \n\t__u32 *perm;   \n};\n\nstruct crush_work {\n\tstruct crush_work_bucket **work;  \n#ifdef __KERNEL__\n\tstruct list_head item;\n#endif\n};\n\n#ifdef __KERNEL__\n \nvoid clear_crush_names(struct rb_root *root);\nvoid clear_choose_args(struct crush_map *c);\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}