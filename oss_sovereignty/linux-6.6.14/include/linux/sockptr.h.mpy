{
  "module_name": "sockptr.h",
  "hash_id": "9ffcfdb3e8992e52e8e23eae1bd288956e9853ab26307f9976a661a9c600a06b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/sockptr.h",
  "human_readable_source": " \n \n#ifndef _LINUX_SOCKPTR_H\n#define _LINUX_SOCKPTR_H\n\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\ntypedef struct {\n\tunion {\n\t\tvoid\t\t*kernel;\n\t\tvoid __user\t*user;\n\t};\n\tbool\t\tis_kernel : 1;\n} sockptr_t;\n\nstatic inline bool sockptr_is_kernel(sockptr_t sockptr)\n{\n\treturn sockptr.is_kernel;\n}\n\nstatic inline sockptr_t KERNEL_SOCKPTR(void *p)\n{\n\treturn (sockptr_t) { .kernel = p, .is_kernel = true };\n}\n\nstatic inline sockptr_t USER_SOCKPTR(void __user *p)\n{\n\treturn (sockptr_t) { .user = p };\n}\n\nstatic inline bool sockptr_is_null(sockptr_t sockptr)\n{\n\tif (sockptr_is_kernel(sockptr))\n\t\treturn !sockptr.kernel;\n\treturn !sockptr.user;\n}\n\nstatic inline int copy_from_sockptr_offset(void *dst, sockptr_t src,\n\t\tsize_t offset, size_t size)\n{\n\tif (!sockptr_is_kernel(src))\n\t\treturn copy_from_user(dst, src.user + offset, size);\n\tmemcpy(dst, src.kernel + offset, size);\n\treturn 0;\n}\n\nstatic inline int copy_from_sockptr(void *dst, sockptr_t src, size_t size)\n{\n\treturn copy_from_sockptr_offset(dst, src, 0, size);\n}\n\nstatic inline int copy_to_sockptr_offset(sockptr_t dst, size_t offset,\n\t\tconst void *src, size_t size)\n{\n\tif (!sockptr_is_kernel(dst))\n\t\treturn copy_to_user(dst.user + offset, src, size);\n\tmemcpy(dst.kernel + offset, src, size);\n\treturn 0;\n}\n\nstatic inline int copy_to_sockptr(sockptr_t dst, const void *src, size_t size)\n{\n\treturn copy_to_sockptr_offset(dst, 0, src, size);\n}\n\nstatic inline void *memdup_sockptr(sockptr_t src, size_t len)\n{\n\tvoid *p = kmalloc_track_caller(len, GFP_USER | __GFP_NOWARN);\n\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (copy_from_sockptr(p, src, len)) {\n\t\tkfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\treturn p;\n}\n\nstatic inline void *memdup_sockptr_nul(sockptr_t src, size_t len)\n{\n\tchar *p = kmalloc_track_caller(len + 1, GFP_KERNEL);\n\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (copy_from_sockptr(p, src, len)) {\n\t\tkfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\tp[len] = '\\0';\n\treturn p;\n}\n\nstatic inline long strncpy_from_sockptr(char *dst, sockptr_t src, size_t count)\n{\n\tif (sockptr_is_kernel(src)) {\n\t\tsize_t len = min(strnlen(src.kernel, count - 1) + 1, count);\n\n\t\tmemcpy(dst, src.kernel, len);\n\t\treturn len;\n\t}\n\treturn strncpy_from_user(dst, src.user, count);\n}\n\nstatic inline int check_zeroed_sockptr(sockptr_t src, size_t offset,\n\t\t\t\t       size_t size)\n{\n\tif (!sockptr_is_kernel(src))\n\t\treturn check_zeroed_user(src.user + offset, size);\n\treturn memchr_inv(src.kernel + offset, 0, size) == NULL;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}