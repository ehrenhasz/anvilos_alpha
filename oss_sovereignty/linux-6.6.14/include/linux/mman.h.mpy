{
  "module_name": "mman.h",
  "hash_id": "9e6ecc09e3443a1d8403efe1dd6880808029210df48e3b908742b90cd5b7096c",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mman.h",
  "human_readable_source": " \n#ifndef _LINUX_MMAN_H\n#define _LINUX_MMAN_H\n\n#include <linux/mm.h>\n#include <linux/percpu_counter.h>\n\n#include <linux/atomic.h>\n#include <uapi/linux/mman.h>\n\n \n#ifndef MAP_32BIT\n#define MAP_32BIT 0\n#endif\n#ifndef MAP_ABOVE4G\n#define MAP_ABOVE4G 0\n#endif\n#ifndef MAP_HUGE_2MB\n#define MAP_HUGE_2MB 0\n#endif\n#ifndef MAP_HUGE_1GB\n#define MAP_HUGE_1GB 0\n#endif\n#ifndef MAP_UNINITIALIZED\n#define MAP_UNINITIALIZED 0\n#endif\n#ifndef MAP_SYNC\n#define MAP_SYNC 0\n#endif\n\n \n#define LEGACY_MAP_MASK (MAP_SHARED \\\n\t\t| MAP_PRIVATE \\\n\t\t| MAP_FIXED \\\n\t\t| MAP_ANONYMOUS \\\n\t\t| MAP_DENYWRITE \\\n\t\t| MAP_EXECUTABLE \\\n\t\t| MAP_UNINITIALIZED \\\n\t\t| MAP_GROWSDOWN \\\n\t\t| MAP_LOCKED \\\n\t\t| MAP_NORESERVE \\\n\t\t| MAP_POPULATE \\\n\t\t| MAP_NONBLOCK \\\n\t\t| MAP_STACK \\\n\t\t| MAP_HUGETLB \\\n\t\t| MAP_32BIT \\\n\t\t| MAP_ABOVE4G \\\n\t\t| MAP_HUGE_2MB \\\n\t\t| MAP_HUGE_1GB)\n\nextern int sysctl_overcommit_memory;\nextern int sysctl_overcommit_ratio;\nextern unsigned long sysctl_overcommit_kbytes;\nextern struct percpu_counter vm_committed_as;\n\n#ifdef CONFIG_SMP\nextern s32 vm_committed_as_batch;\nextern void mm_compute_batch(int overcommit_policy);\n#else\n#define vm_committed_as_batch 0\nstatic inline void mm_compute_batch(int overcommit_policy)\n{\n}\n#endif\n\nunsigned long vm_memory_committed(void);\n\nstatic inline void vm_acct_memory(long pages)\n{\n\tpercpu_counter_add_batch(&vm_committed_as, pages, vm_committed_as_batch);\n}\n\nstatic inline void vm_unacct_memory(long pages)\n{\n\tvm_acct_memory(-pages);\n}\n\n \n\n#ifndef arch_calc_vm_prot_bits\n#define arch_calc_vm_prot_bits(prot, pkey) 0\n#endif\n\n#ifndef arch_calc_vm_flag_bits\n#define arch_calc_vm_flag_bits(flags) 0\n#endif\n\n#ifndef arch_validate_prot\n \nstatic inline bool arch_validate_prot(unsigned long prot, unsigned long addr)\n{\n\treturn (prot & ~(PROT_READ | PROT_WRITE | PROT_EXEC | PROT_SEM)) == 0;\n}\n#define arch_validate_prot arch_validate_prot\n#endif\n\n#ifndef arch_validate_flags\n \nstatic inline bool arch_validate_flags(unsigned long flags)\n{\n\treturn true;\n}\n#define arch_validate_flags arch_validate_flags\n#endif\n\n \n#define _calc_vm_trans(x, bit1, bit2) \\\n  ((!(bit1) || !(bit2)) ? 0 : \\\n  ((bit1) <= (bit2) ? ((x) & (bit1)) * ((bit2) / (bit1)) \\\n   : ((x) & (bit1)) / ((bit1) / (bit2))))\n\n \nstatic inline unsigned long\ncalc_vm_prot_bits(unsigned long prot, unsigned long pkey)\n{\n\treturn _calc_vm_trans(prot, PROT_READ,  VM_READ ) |\n\t       _calc_vm_trans(prot, PROT_WRITE, VM_WRITE) |\n\t       _calc_vm_trans(prot, PROT_EXEC,  VM_EXEC) |\n\t       arch_calc_vm_prot_bits(prot, pkey);\n}\n\n \nstatic inline unsigned long\ncalc_vm_flag_bits(unsigned long flags)\n{\n\treturn _calc_vm_trans(flags, MAP_GROWSDOWN,  VM_GROWSDOWN ) |\n\t       _calc_vm_trans(flags, MAP_LOCKED,     VM_LOCKED    ) |\n\t       _calc_vm_trans(flags, MAP_SYNC,\t     VM_SYNC      ) |\n\t       arch_calc_vm_flag_bits(flags);\n}\n\nunsigned long vm_commit_limit(void);\n\n \nstatic inline bool map_deny_write_exec(struct vm_area_struct *vma,  unsigned long vm_flags)\n{\n\tif (!test_bit(MMF_HAS_MDWE, &current->mm->flags))\n\t\treturn false;\n\n\tif ((vm_flags & VM_EXEC) && (vm_flags & VM_WRITE))\n\t\treturn true;\n\n\tif (!(vma->vm_flags & VM_EXEC) && (vm_flags & VM_EXEC))\n\t\treturn true;\n\n\treturn false;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}