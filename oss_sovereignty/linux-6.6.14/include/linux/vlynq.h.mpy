{
  "module_name": "vlynq.h",
  "hash_id": "39b643f691b25899149dd01b0e3287e37933eccd1fc974b4a6eafe6a017083b7",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/vlynq.h",
  "human_readable_source": " \n \n\n#ifndef __VLYNQ_H__\n#define __VLYNQ_H__\n\n#include <linux/device.h>\n#include <linux/types.h>\n\nstruct module;\n\n#define VLYNQ_NUM_IRQS 32\n\nstruct vlynq_mapping {\n\tu32 size;\n\tu32 offset;\n};\n\nenum vlynq_divisor {\n\tvlynq_div_auto = 0,\n\tvlynq_ldiv1,\n\tvlynq_ldiv2,\n\tvlynq_ldiv3,\n\tvlynq_ldiv4,\n\tvlynq_ldiv5,\n\tvlynq_ldiv6,\n\tvlynq_ldiv7,\n\tvlynq_ldiv8,\n\tvlynq_rdiv1,\n\tvlynq_rdiv2,\n\tvlynq_rdiv3,\n\tvlynq_rdiv4,\n\tvlynq_rdiv5,\n\tvlynq_rdiv6,\n\tvlynq_rdiv7,\n\tvlynq_rdiv8,\n\tvlynq_div_external\n};\n\nstruct vlynq_device_id {\n\tu32 id;\n\tenum vlynq_divisor divisor;\n\tunsigned long driver_data;\n};\n\nstruct vlynq_regs;\nstruct vlynq_device {\n\tu32 id, dev_id;\n\tint local_irq;\n\tint remote_irq;\n\tenum vlynq_divisor divisor;\n\tu32 regs_start, regs_end;\n\tu32 mem_start, mem_end;\n\tu32 irq_start, irq_end;\n\tint irq;\n\tint enabled;\n\tstruct vlynq_regs *local;\n\tstruct vlynq_regs *remote;\n\tstruct device dev;\n};\n\nstruct vlynq_driver {\n\tchar *name;\n\tstruct vlynq_device_id *id_table;\n\tint (*probe)(struct vlynq_device *dev, struct vlynq_device_id *id);\n\tvoid (*remove)(struct vlynq_device *dev);\n\tstruct device_driver driver;\n};\n\nstruct plat_vlynq_ops {\n\tint (*on)(struct vlynq_device *dev);\n\tvoid (*off)(struct vlynq_device *dev);\n};\n\nstatic inline struct vlynq_driver *to_vlynq_driver(struct device_driver *drv)\n{\n\treturn container_of(drv, struct vlynq_driver, driver);\n}\n\nstatic inline struct vlynq_device *to_vlynq_device(struct device *device)\n{\n\treturn container_of(device, struct vlynq_device, dev);\n}\n\nextern struct bus_type vlynq_bus_type;\n\nextern int __vlynq_register_driver(struct vlynq_driver *driver,\n\t\t\t\t   struct module *owner);\n\nstatic inline int vlynq_register_driver(struct vlynq_driver *driver)\n{\n\treturn __vlynq_register_driver(driver, THIS_MODULE);\n}\n\nstatic inline void *vlynq_get_drvdata(struct vlynq_device *dev)\n{\n\treturn dev_get_drvdata(&dev->dev);\n}\n\nstatic inline void vlynq_set_drvdata(struct vlynq_device *dev, void *data)\n{\n\tdev_set_drvdata(&dev->dev, data);\n}\n\nstatic inline u32 vlynq_mem_start(struct vlynq_device *dev)\n{\n\treturn dev->mem_start;\n}\n\nstatic inline u32 vlynq_mem_end(struct vlynq_device *dev)\n{\n\treturn dev->mem_end;\n}\n\nstatic inline u32 vlynq_mem_len(struct vlynq_device *dev)\n{\n\treturn dev->mem_end - dev->mem_start + 1;\n}\n\nstatic inline int vlynq_virq_to_irq(struct vlynq_device *dev, int virq)\n{\n\tint irq = dev->irq_start + virq;\n\tif ((irq < dev->irq_start) || (irq > dev->irq_end))\n\t\treturn -EINVAL;\n\n\treturn irq;\n}\n\nstatic inline int vlynq_irq_to_virq(struct vlynq_device *dev, int irq)\n{\n\tif ((irq < dev->irq_start) || (irq > dev->irq_end))\n\t\treturn -EINVAL;\n\n\treturn irq - dev->irq_start;\n}\n\nextern void vlynq_unregister_driver(struct vlynq_driver *driver);\nextern int vlynq_enable_device(struct vlynq_device *dev);\nextern void vlynq_disable_device(struct vlynq_device *dev);\nextern int vlynq_set_local_mapping(struct vlynq_device *dev, u32 tx_offset,\n\t\t\t\t   struct vlynq_mapping *mapping);\nextern int vlynq_set_remote_mapping(struct vlynq_device *dev, u32 tx_offset,\n\t\t\t\t    struct vlynq_mapping *mapping);\nextern int vlynq_set_local_irq(struct vlynq_device *dev, int virq);\nextern int vlynq_set_remote_irq(struct vlynq_device *dev, int virq);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}