{
  "module_name": "async_tx.h",
  "hash_id": "c032ba5fa9af6445cffb2d0ed2b0becbf18f182f32c775404302bbdb1bec9c51",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/async_tx.h",
  "human_readable_source": " \n \n#ifndef _ASYNC_TX_H_\n#define _ASYNC_TX_H_\n#include <linux/dmaengine.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n\n \n#ifdef CONFIG_HAS_DMA\n#define __async_inline\n#else\n#define __async_inline __always_inline\n#endif\n\n \nstruct dma_chan_ref {\n\tstruct dma_chan *chan;\n\tstruct list_head node;\n\tstruct rcu_head rcu;\n\tatomic_t count;\n};\n\n \nenum async_tx_flags {\n\tASYNC_TX_XOR_ZERO_DST\t = (1 << 0),\n\tASYNC_TX_XOR_DROP_DST\t = (1 << 1),\n\tASYNC_TX_ACK\t\t = (1 << 2),\n\tASYNC_TX_FENCE\t\t = (1 << 3),\n\tASYNC_TX_PQ_XOR_DST\t = (1 << 4),\n};\n\n \nstruct async_submit_ctl {\n\tenum async_tx_flags flags;\n\tstruct dma_async_tx_descriptor *depend_tx;\n\tdma_async_tx_callback cb_fn;\n\tvoid *cb_param;\n\tvoid *scribble;\n};\n\n#if defined(CONFIG_DMA_ENGINE) && !defined(CONFIG_ASYNC_TX_CHANNEL_SWITCH)\n#define async_tx_issue_pending_all dma_issue_pending_all\n\n \nstatic inline void async_tx_issue_pending(struct dma_async_tx_descriptor *tx)\n{\n\tif (likely(tx)) {\n\t\tstruct dma_chan *chan = tx->chan;\n\t\tstruct dma_device *dma = chan->device;\n\n\t\tdma->device_issue_pending(chan);\n\t}\n}\n#ifdef CONFIG_ARCH_HAS_ASYNC_TX_FIND_CHANNEL\n#include <asm/async_tx.h>\n#else\n#define async_tx_find_channel(dep, type, dst, dst_count, src, src_count, len) \\\n\t __async_tx_find_channel(dep, type)\nstruct dma_chan *\n__async_tx_find_channel(struct async_submit_ctl *submit,\n\t\t\tenum dma_transaction_type tx_type);\n#endif  \n#else\nstatic inline void async_tx_issue_pending_all(void)\n{\n\tdo { } while (0);\n}\n\nstatic inline void async_tx_issue_pending(struct dma_async_tx_descriptor *tx)\n{\n\tdo { } while (0);\n}\n\nstatic inline struct dma_chan *\nasync_tx_find_channel(struct async_submit_ctl *submit,\n\t\t      enum dma_transaction_type tx_type, struct page **dst,\n\t\t      int dst_count, struct page **src, int src_count,\n\t\t      size_t len)\n{\n\treturn NULL;\n}\n#endif\n\n \nstatic inline void\nasync_tx_sync_epilog(struct async_submit_ctl *submit)\n{\n\tif (submit->cb_fn)\n\t\tsubmit->cb_fn(submit->cb_param);\n}\n\ntypedef union {\n\tunsigned long addr;\n\tstruct page *page;\n\tdma_addr_t dma;\n} addr_conv_t;\n\nstatic inline void\ninit_async_submit(struct async_submit_ctl *args, enum async_tx_flags flags,\n\t\t  struct dma_async_tx_descriptor *tx,\n\t\t  dma_async_tx_callback cb_fn, void *cb_param,\n\t\t  addr_conv_t *scribble)\n{\n\targs->flags = flags;\n\targs->depend_tx = tx;\n\targs->cb_fn = cb_fn;\n\targs->cb_param = cb_param;\n\targs->scribble = scribble;\n}\n\nvoid async_tx_submit(struct dma_chan *chan, struct dma_async_tx_descriptor *tx,\n\t\t     struct async_submit_ctl *submit);\n\nstruct dma_async_tx_descriptor *\nasync_xor(struct page *dest, struct page **src_list, unsigned int offset,\n\t  int src_cnt, size_t len, struct async_submit_ctl *submit);\n\nstruct dma_async_tx_descriptor *\nasync_xor_offs(struct page *dest, unsigned int offset,\n\t\tstruct page **src_list, unsigned int *src_offset,\n\t\tint src_cnt, size_t len, struct async_submit_ctl *submit);\n\nstruct dma_async_tx_descriptor *\nasync_xor_val(struct page *dest, struct page **src_list, unsigned int offset,\n\t      int src_cnt, size_t len, enum sum_check_flags *result,\n\t      struct async_submit_ctl *submit);\n\nstruct dma_async_tx_descriptor *\nasync_xor_val_offs(struct page *dest, unsigned int offset,\n\t\tstruct page **src_list, unsigned int *src_offset,\n\t\tint src_cnt, size_t len, enum sum_check_flags *result,\n\t\tstruct async_submit_ctl *submit);\n\nstruct dma_async_tx_descriptor *\nasync_memcpy(struct page *dest, struct page *src, unsigned int dest_offset,\n\t     unsigned int src_offset, size_t len,\n\t     struct async_submit_ctl *submit);\n\nstruct dma_async_tx_descriptor *async_trigger_callback(struct async_submit_ctl *submit);\n\nstruct dma_async_tx_descriptor *\nasync_gen_syndrome(struct page **blocks, unsigned int *offsets, int src_cnt,\n\t\t   size_t len, struct async_submit_ctl *submit);\n\nstruct dma_async_tx_descriptor *\nasync_syndrome_val(struct page **blocks, unsigned int *offsets, int src_cnt,\n\t\t   size_t len, enum sum_check_flags *pqres, struct page *spare,\n\t\t   unsigned int s_off, struct async_submit_ctl *submit);\n\nstruct dma_async_tx_descriptor *\nasync_raid6_2data_recov(int src_num, size_t bytes, int faila, int failb,\n\t\t\tstruct page **ptrs, unsigned int *offs,\n\t\t\tstruct async_submit_ctl *submit);\n\nstruct dma_async_tx_descriptor *\nasync_raid6_datap_recov(int src_num, size_t bytes, int faila,\n\t\t\tstruct page **ptrs, unsigned int *offs,\n\t\t\tstruct async_submit_ctl *submit);\n\nvoid async_tx_quiesce(struct dma_async_tx_descriptor **tx);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}