{
  "module_name": "psi_types.h",
  "hash_id": "d76595c239d919baa757d8d1c5b83a66099355f92ee2a04279afb06f80ab3ffe",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/psi_types.h",
  "human_readable_source": " \n#ifndef _LINUX_PSI_TYPES_H\n#define _LINUX_PSI_TYPES_H\n\n#include <linux/kthread.h>\n#include <linux/seqlock.h>\n#include <linux/types.h>\n#include <linux/kref.h>\n#include <linux/wait.h>\n\n#ifdef CONFIG_PSI\n\n \nenum psi_task_count {\n\tNR_IOWAIT,\n\tNR_MEMSTALL,\n\tNR_RUNNING,\n\t \n\tNR_MEMSTALL_RUNNING,\n\tNR_PSI_TASK_COUNTS = 4,\n};\n\n \n#define TSK_IOWAIT\t(1 << NR_IOWAIT)\n#define TSK_MEMSTALL\t(1 << NR_MEMSTALL)\n#define TSK_RUNNING\t(1 << NR_RUNNING)\n#define TSK_MEMSTALL_RUNNING\t(1 << NR_MEMSTALL_RUNNING)\n\n \n#define TSK_ONCPU\t(1 << NR_PSI_TASK_COUNTS)\n\n \nenum psi_res {\n\tPSI_IO,\n\tPSI_MEM,\n\tPSI_CPU,\n#ifdef CONFIG_IRQ_TIME_ACCOUNTING\n\tPSI_IRQ,\n#endif\n\tNR_PSI_RESOURCES,\n};\n\n \nenum psi_states {\n\tPSI_IO_SOME,\n\tPSI_IO_FULL,\n\tPSI_MEM_SOME,\n\tPSI_MEM_FULL,\n\tPSI_CPU_SOME,\n\tPSI_CPU_FULL,\n#ifdef CONFIG_IRQ_TIME_ACCOUNTING\n\tPSI_IRQ_FULL,\n#endif\n\t \n\tPSI_NONIDLE,\n\tNR_PSI_STATES,\n};\n\n \n#define PSI_ONCPU\t(1 << NR_PSI_STATES)\n\n \n#define PSI_STATE_RESCHEDULE\t(1 << (NR_PSI_STATES + 1))\n\nenum psi_aggregators {\n\tPSI_AVGS = 0,\n\tPSI_POLL,\n\tNR_PSI_AGGREGATORS,\n};\n\nstruct psi_group_cpu {\n\t \n\n\t \n\tseqcount_t seq ____cacheline_aligned_in_smp;\n\n\t \n\tunsigned int tasks[NR_PSI_TASK_COUNTS];\n\n\t \n\tu32 state_mask;\n\n\t \n\tu32 times[NR_PSI_STATES];\n\n\t \n\tu64 state_start;\n\n\t \n\n\t \n\tu32 times_prev[NR_PSI_AGGREGATORS][NR_PSI_STATES]\n\t\t\t____cacheline_aligned_in_smp;\n};\n\n \nstruct psi_window {\n\t \n\tu64 size;\n\n\t \n\tu64 start_time;\n\n\t \n\tu64 start_value;\n\n\t \n\tu64 prev_growth;\n};\n\nstruct psi_trigger {\n\t \n\tenum psi_states state;\n\n\t \n\tu64 threshold;\n\n\t \n\tstruct list_head node;\n\n\t \n\tstruct psi_group *group;\n\n\t \n\twait_queue_head_t event_wait;\n\n\t \n\tstruct kernfs_open_file *of;\n\n\t \n\tint event;\n\n\t \n\tstruct psi_window win;\n\n\t \n\tu64 last_event_time;\n\n\t \n\tbool pending_event;\n\n\t \n\tenum psi_aggregators aggregator;\n};\n\nstruct psi_group {\n\tstruct psi_group *parent;\n\tbool enabled;\n\n\t \n\tstruct mutex avgs_lock;\n\n\t \n\tstruct psi_group_cpu __percpu *pcpu;\n\n\t \n\tu64 avg_total[NR_PSI_STATES - 1];\n\tu64 avg_last_update;\n\tu64 avg_next_update;\n\n\t \n\tstruct delayed_work avgs_work;\n\n\t \n\tstruct list_head avg_triggers;\n\tu32 avg_nr_triggers[NR_PSI_STATES - 1];\n\n\t \n\tu64 total[NR_PSI_AGGREGATORS][NR_PSI_STATES - 1];\n\tunsigned long avg[NR_PSI_STATES - 1][3];\n\n\t \n\tstruct task_struct __rcu *rtpoll_task;\n\tstruct timer_list rtpoll_timer;\n\twait_queue_head_t rtpoll_wait;\n\tatomic_t rtpoll_wakeup;\n\tatomic_t rtpoll_scheduled;\n\n\t \n\tstruct mutex rtpoll_trigger_lock;\n\n\t \n\tstruct list_head rtpoll_triggers;\n\tu32 rtpoll_nr_triggers[NR_PSI_STATES - 1];\n\tu32 rtpoll_states;\n\tu64 rtpoll_min_period;\n\n\t \n\tu64 rtpoll_total[NR_PSI_STATES - 1];\n\tu64 rtpoll_next_update;\n\tu64 rtpoll_until;\n};\n\n#else  \n\n#define NR_PSI_RESOURCES\t0\n\nstruct psi_group { };\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}