{
  "module_name": "pipe_fs_i.h",
  "hash_id": "b5058e347b4c4b0493d6b958e4dab0fb4d0b933504ab4cc7aedc093dce20fe93",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/pipe_fs_i.h",
  "human_readable_source": " \n#ifndef _LINUX_PIPE_FS_I_H\n#define _LINUX_PIPE_FS_I_H\n\n#define PIPE_DEF_BUFFERS\t16\n\n#define PIPE_BUF_FLAG_LRU\t0x01\t \n#define PIPE_BUF_FLAG_ATOMIC\t0x02\t \n#define PIPE_BUF_FLAG_GIFT\t0x04\t \n#define PIPE_BUF_FLAG_PACKET\t0x08\t \n#define PIPE_BUF_FLAG_CAN_MERGE\t0x10\t \n#define PIPE_BUF_FLAG_WHOLE\t0x20\t \n#ifdef CONFIG_WATCH_QUEUE\n#define PIPE_BUF_FLAG_LOSS\t0x40\t \n#endif\n\n \nstruct pipe_buffer {\n\tstruct page *page;\n\tunsigned int offset, len;\n\tconst struct pipe_buf_operations *ops;\n\tunsigned int flags;\n\tunsigned long private;\n};\n\n \nstruct pipe_inode_info {\n\tstruct mutex mutex;\n\twait_queue_head_t rd_wait, wr_wait;\n\tunsigned int head;\n\tunsigned int tail;\n\tunsigned int max_usage;\n\tunsigned int ring_size;\n#ifdef CONFIG_WATCH_QUEUE\n\tbool note_loss;\n#endif\n\tunsigned int nr_accounted;\n\tunsigned int readers;\n\tunsigned int writers;\n\tunsigned int files;\n\tunsigned int r_counter;\n\tunsigned int w_counter;\n\tbool poll_usage;\n\tstruct page *tmp_page;\n\tstruct fasync_struct *fasync_readers;\n\tstruct fasync_struct *fasync_writers;\n\tstruct pipe_buffer *bufs;\n\tstruct user_struct *user;\n#ifdef CONFIG_WATCH_QUEUE\n\tstruct watch_queue *watch_queue;\n#endif\n};\n\n \nstruct pipe_buf_operations {\n\t \n\tint (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);\n\n\t \n\tvoid (*release)(struct pipe_inode_info *, struct pipe_buffer *);\n\n\t \n\tbool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);\n\n\t \n\tbool (*get)(struct pipe_inode_info *, struct pipe_buffer *);\n};\n\n \nstatic inline bool pipe_empty(unsigned int head, unsigned int tail)\n{\n\treturn head == tail;\n}\n\n \nstatic inline unsigned int pipe_occupancy(unsigned int head, unsigned int tail)\n{\n\treturn head - tail;\n}\n\n \nstatic inline bool pipe_full(unsigned int head, unsigned int tail,\n\t\t\t     unsigned int limit)\n{\n\treturn pipe_occupancy(head, tail) >= limit;\n}\n\n \nstatic inline struct pipe_buffer *pipe_buf(const struct pipe_inode_info *pipe,\n\t\t\t\t\t   unsigned int slot)\n{\n\treturn &pipe->bufs[slot & (pipe->ring_size - 1)];\n}\n\n \nstatic inline struct pipe_buffer *pipe_head_buf(const struct pipe_inode_info *pipe)\n{\n\treturn pipe_buf(pipe, pipe->head);\n}\n\n \nstatic inline __must_check bool pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\treturn buf->ops->get(pipe, buf);\n}\n\n \nstatic inline void pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tconst struct pipe_buf_operations *ops = buf->ops;\n\n\tbuf->ops = NULL;\n\tops->release(pipe, buf);\n}\n\n \nstatic inline int pipe_buf_confirm(struct pipe_inode_info *pipe,\n\t\t\t\t   struct pipe_buffer *buf)\n{\n\tif (!buf->ops->confirm)\n\t\treturn 0;\n\treturn buf->ops->confirm(pipe, buf);\n}\n\n \nstatic inline bool pipe_buf_try_steal(struct pipe_inode_info *pipe,\n\t\tstruct pipe_buffer *buf)\n{\n\tif (!buf->ops->try_steal)\n\t\treturn false;\n\treturn buf->ops->try_steal(pipe, buf);\n}\n\nstatic inline void pipe_discard_from(struct pipe_inode_info *pipe,\n\t\tunsigned int old_head)\n{\n\tunsigned int mask = pipe->ring_size - 1;\n\n\twhile (pipe->head > old_head)\n\t\tpipe_buf_release(pipe, &pipe->bufs[--pipe->head & mask]);\n}\n\n \n#define PIPE_SIZE\t\tPAGE_SIZE\n\n \nvoid pipe_lock(struct pipe_inode_info *);\nvoid pipe_unlock(struct pipe_inode_info *);\nvoid pipe_double_lock(struct pipe_inode_info *, struct pipe_inode_info *);\n\n \nvoid pipe_wait_readable(struct pipe_inode_info *);\nvoid pipe_wait_writable(struct pipe_inode_info *);\n\nstruct pipe_inode_info *alloc_pipe_info(void);\nvoid free_pipe_info(struct pipe_inode_info *);\n\n \nbool generic_pipe_buf_get(struct pipe_inode_info *, struct pipe_buffer *);\nbool generic_pipe_buf_try_steal(struct pipe_inode_info *, struct pipe_buffer *);\nvoid generic_pipe_buf_release(struct pipe_inode_info *, struct pipe_buffer *);\n\nextern const struct pipe_buf_operations nosteal_pipe_buf_ops;\n\nunsigned long account_pipe_buffers(struct user_struct *user,\n\t\t\t\t   unsigned long old, unsigned long new);\nbool too_many_pipe_buffers_soft(unsigned long user_bufs);\nbool too_many_pipe_buffers_hard(unsigned long user_bufs);\nbool pipe_is_unprivileged_user(void);\n\n \nint pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots);\nlong pipe_fcntl(struct file *, unsigned int, unsigned int arg);\nstruct pipe_inode_info *get_pipe_info(struct file *file, bool for_splice);\n\nint create_pipe_files(struct file **, int);\nunsigned int round_pipe_size(unsigned int size);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}