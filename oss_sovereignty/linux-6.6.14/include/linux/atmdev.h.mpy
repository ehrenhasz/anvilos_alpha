{
  "module_name": "atmdev.h",
  "hash_id": "b3b00845cd062e22720ae86a40385d3527454ade120c8d5638923cf5027848a1",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/atmdev.h",
  "human_readable_source": " \n \n#ifndef LINUX_ATMDEV_H\n#define LINUX_ATMDEV_H\n\n\n#include <linux/wait.h>  \n#include <linux/time.h>  \n#include <linux/net.h>\n#include <linux/bug.h>\n#include <linux/skbuff.h>  \n#include <linux/uio.h>\n#include <net/sock.h>\n#include <linux/atomic.h>\n#include <linux/refcount.h>\n#include <uapi/linux/atmdev.h>\n\n#ifdef CONFIG_PROC_FS\n#include <linux/proc_fs.h>\n\nextern struct proc_dir_entry *atm_proc_root;\n#endif\n\n#ifdef CONFIG_COMPAT\n#include <linux/compat.h>\nstruct compat_atm_iobuf {\n\tint length;\n\tcompat_uptr_t buffer;\n};\n#endif\n\nstruct k_atm_aal_stats {\n#define __HANDLE_ITEM(i) atomic_t i\n\t__AAL_STAT_ITEMS\n#undef __HANDLE_ITEM\n};\n\n\nstruct k_atm_dev_stats {\n\tstruct k_atm_aal_stats aal0;\n\tstruct k_atm_aal_stats aal34;\n\tstruct k_atm_aal_stats aal5;\n};\n\nstruct device;\n\nenum {\n\tATM_VF_ADDR,\t\t \n\tATM_VF_READY,\t\t \n\tATM_VF_PARTIAL,\t\t \n\tATM_VF_REGIS,\t\t \n\tATM_VF_BOUND,\t\t \n\tATM_VF_RELEASED,\t \n\tATM_VF_HASQOS,\t\t \n\tATM_VF_LISTEN,\t\t \n\tATM_VF_META,\t\t \n\tATM_VF_SESSION,\t\t \n\tATM_VF_HASSAP,\t\t \n\tATM_VF_CLOSE,\t\t \n\tATM_VF_WAITING,\t\t \n\tATM_VF_IS_CLIP,\t\t \n};\n\n\n#define ATM_VF2VS(flags) \\\n    (test_bit(ATM_VF_READY,&(flags)) ? ATM_VS_CONNECTED : \\\n     test_bit(ATM_VF_RELEASED,&(flags)) ? ATM_VS_CLOSING : \\\n     test_bit(ATM_VF_LISTEN,&(flags)) ? ATM_VS_LISTEN : \\\n     test_bit(ATM_VF_REGIS,&(flags)) ? ATM_VS_INUSE : \\\n     test_bit(ATM_VF_BOUND,&(flags)) ? ATM_VS_BOUND : ATM_VS_IDLE)\n\n\nenum {\n\tATM_DF_REMOVED,\t\t \n};\n\n\n#define ATM_PHY_SIG_LOST    0\t \n#define ATM_PHY_SIG_UNKNOWN 1\t \n#define ATM_PHY_SIG_FOUND   2\t \n\n#define ATM_ATMOPT_CLP\t1\t \n\nstruct atm_vcc {\n\t \n\tstruct sock\tsk;\n\tunsigned long\tflags;\t\t \n\tshort\t\tvpi;\t\t \n\t\t\t\t\t \n\tint \t\tvci;\n\tunsigned long\taal_options;\t \n\tunsigned long\tatm_options;\t \n\tstruct atm_dev\t*dev;\t\t \n\tstruct atm_qos\tqos;\t\t \n\tstruct atm_sap\tsap;\t\t \n\tvoid (*release_cb)(struct atm_vcc *vcc);  \n\tvoid (*push)(struct atm_vcc *vcc,struct sk_buff *skb);\n\tvoid (*pop)(struct atm_vcc *vcc,struct sk_buff *skb);  \n\tint (*push_oam)(struct atm_vcc *vcc,void *cell);\n\tint (*send)(struct atm_vcc *vcc,struct sk_buff *skb);\n\tvoid\t\t*dev_data;\t \n\tvoid\t\t*proto_data;\t \n\tstruct k_atm_aal_stats *stats;\t \n\tstruct module *owner;\t\t \n\t \n\tshort\t\titf;\t\t \n\tstruct sockaddr_atmsvc local;\n\tstruct sockaddr_atmsvc remote;\n\t \n\tstruct atm_vcc\t*session;\t \n\t \n\tvoid\t\t*user_back;\t \n\t\t\t\t\t \n\t\t\t\t\t \n};\n\nstatic inline struct atm_vcc *atm_sk(struct sock *sk)\n{\n\treturn (struct atm_vcc *)sk;\n}\n\nstatic inline struct atm_vcc *ATM_SD(struct socket *sock)\n{\n\treturn atm_sk(sock->sk);\n}\n\nstatic inline struct sock *sk_atm(struct atm_vcc *vcc)\n{\n\treturn (struct sock *)vcc;\n}\n\nstruct atm_dev_addr {\n\tstruct sockaddr_atmsvc addr;\t \n\tstruct list_head entry;\t\t \n};\n\nenum atm_addr_type_t { ATM_ADDR_LOCAL, ATM_ADDR_LECS };\n\nstruct atm_dev {\n\tconst struct atmdev_ops *ops;\t \n\tconst struct atmphy_ops *phy;\t \n\t\t\t\t\t \n\tconst char\t*type;\t\t \n\tint\t\tnumber;\t\t \n\tvoid\t\t*dev_data;\t \n\tvoid\t\t*phy_data;\t \n\tunsigned long\tflags;\t\t \n\tstruct list_head local;\t\t \n\tstruct list_head lecs;\t\t \n\tunsigned char\tesi[ESI_LEN];\t \n\tstruct atm_cirange ci_range;\t \n\tstruct k_atm_dev_stats stats;\t \n\tchar\t\tsignal;\t\t \n\tint\t\tlink_rate;\t \n\trefcount_t\trefcnt;\t\t \n\tspinlock_t\tlock;\t\t \n#ifdef CONFIG_PROC_FS\n\tstruct proc_dir_entry *proc_entry;  \n\tchar *proc_name;\t\t \n#endif\n\tstruct device class_dev;\t \n\tstruct list_head dev_list;\t \n};\n\n \n \n\n#define ATM_OF_IMMED  1\t\t \n#define ATM_OF_INRATE 2\t\t \n\nstruct atmdev_ops {  \n\tvoid (*dev_close)(struct atm_dev *dev);\n\tint (*open)(struct atm_vcc *vcc);\n\tvoid (*close)(struct atm_vcc *vcc);\n\tint (*ioctl)(struct atm_dev *dev,unsigned int cmd,void __user *arg);\n#ifdef CONFIG_COMPAT\n\tint (*compat_ioctl)(struct atm_dev *dev,unsigned int cmd,\n\t\t\t    void __user *arg);\n#endif\n\tint (*send)(struct atm_vcc *vcc,struct sk_buff *skb);\n\tint (*send_bh)(struct atm_vcc *vcc, struct sk_buff *skb);\n\tint (*send_oam)(struct atm_vcc *vcc,void *cell,int flags);\n\tvoid (*phy_put)(struct atm_dev *dev,unsigned char value,\n\t    unsigned long addr);\n\tunsigned char (*phy_get)(struct atm_dev *dev,unsigned long addr);\n\tint (*change_qos)(struct atm_vcc *vcc,struct atm_qos *qos,int flags);\n\tint (*proc_read)(struct atm_dev *dev,loff_t *pos,char *page);\n\tstruct module *owner;\n};\n\nstruct atmphy_ops {\n\tint (*start)(struct atm_dev *dev);\n\tint (*ioctl)(struct atm_dev *dev,unsigned int cmd,void __user *arg);\n\tvoid (*interrupt)(struct atm_dev *dev);\n\tint (*stop)(struct atm_dev *dev);\n};\n\nstruct atm_skb_data {\n\tstruct atm_vcc\t*vcc;\t\t \n\tunsigned long\tatm_options;\t \n\tunsigned int\tacct_truesize;   \n} __packed;\n\n#define VCC_HTABLE_SIZE 32\n\nextern struct hlist_head vcc_hash[VCC_HTABLE_SIZE];\nextern rwlock_t vcc_sklist_lock;\n\n#define ATM_SKB(skb) (((struct atm_skb_data *) (skb)->cb))\n\nstruct atm_dev *atm_dev_register(const char *type, struct device *parent,\n\t\t\t\t const struct atmdev_ops *ops,\n\t\t\t\t int number,  \n\t\t\t\t unsigned long *flags);\nstruct atm_dev *atm_dev_lookup(int number);\nvoid atm_dev_deregister(struct atm_dev *dev);\n\n \nvoid atm_dev_signal_change(struct atm_dev *dev, char signal);\n\nvoid vcc_insert_socket(struct sock *sk);\n\nvoid atm_dev_release_vccs(struct atm_dev *dev);\n\nstatic inline void atm_account_tx(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\t \n\trefcount_add(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);\n\tATM_SKB(skb)->acct_truesize = skb->truesize;\n\tATM_SKB(skb)->atm_options = vcc->atm_options;\n}\n\nstatic inline void atm_force_charge(struct atm_vcc *vcc,int truesize)\n{\n\tatomic_add(truesize, &sk_atm(vcc)->sk_rmem_alloc);\n}\n\n\nstatic inline void atm_return(struct atm_vcc *vcc,int truesize)\n{\n\tatomic_sub(truesize, &sk_atm(vcc)->sk_rmem_alloc);\n}\n\n\nstatic inline int atm_may_send(struct atm_vcc *vcc,unsigned int size)\n{\n\treturn (size + refcount_read(&sk_atm(vcc)->sk_wmem_alloc)) <\n\t       sk_atm(vcc)->sk_sndbuf;\n}\n\n\nstatic inline void atm_dev_hold(struct atm_dev *dev)\n{\n\trefcount_inc(&dev->refcnt);\n}\n\n\nstatic inline void atm_dev_put(struct atm_dev *dev)\n{\n\tif (refcount_dec_and_test(&dev->refcnt)) {\n\t\tBUG_ON(!test_bit(ATM_DF_REMOVED, &dev->flags));\n\t\tif (dev->ops->dev_close)\n\t\t\tdev->ops->dev_close(dev);\n\t\tput_device(&dev->class_dev);\n\t}\n}\n\n\nint atm_charge(struct atm_vcc *vcc,int truesize);\nstruct sk_buff *atm_alloc_charge(struct atm_vcc *vcc,int pdu_size,\n    gfp_t gfp_flags);\nint atm_pcr_goal(const struct atm_trafprm *tp);\n\nvoid vcc_release_async(struct atm_vcc *vcc, int reply);\n\nstruct atm_ioctl {\n\tstruct module *owner;\n\t \n\tint (*ioctl)(struct socket *, unsigned int cmd, unsigned long arg);\n\tstruct list_head list;\n};\n\n \nvoid register_atm_ioctl(struct atm_ioctl *);\n\n \nvoid deregister_atm_ioctl(struct atm_ioctl *);\n\n\n \nint register_atmdevice_notifier(struct notifier_block *nb);\nvoid unregister_atmdevice_notifier(struct notifier_block *nb);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}