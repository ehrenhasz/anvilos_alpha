{
  "module_name": "pm.h",
  "hash_id": "ea2632affb2f9496871867790c2e3d9b9ee36d3bb47f5c04a20ef865aaacc332",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/pm.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_PM_H\n#define _LINUX_PM_H\n\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/completion.h>\n\n \nextern void (*pm_power_off)(void);\n\nstruct device;  \n#ifdef CONFIG_VT_CONSOLE_SLEEP\nextern void pm_vt_switch_required(struct device *dev, bool required);\nextern void pm_vt_switch_unregister(struct device *dev);\n#else\nstatic inline void pm_vt_switch_required(struct device *dev, bool required)\n{\n}\nstatic inline void pm_vt_switch_unregister(struct device *dev)\n{\n}\n#endif  \n\n#ifdef CONFIG_CXL_SUSPEND\nbool cxl_mem_active(void);\n#else\nstatic inline bool cxl_mem_active(void)\n{\n\treturn false;\n}\n#endif\n\n \n\n\n#ifdef CONFIG_PM\nextern const char power_group_name[];\t\t \n#else\n#define power_group_name\tNULL\n#endif\n\ntypedef struct pm_message {\n\tint event;\n} pm_message_t;\n\n \nstruct dev_pm_ops {\n\tint (*prepare)(struct device *dev);\n\tvoid (*complete)(struct device *dev);\n\tint (*suspend)(struct device *dev);\n\tint (*resume)(struct device *dev);\n\tint (*freeze)(struct device *dev);\n\tint (*thaw)(struct device *dev);\n\tint (*poweroff)(struct device *dev);\n\tint (*restore)(struct device *dev);\n\tint (*suspend_late)(struct device *dev);\n\tint (*resume_early)(struct device *dev);\n\tint (*freeze_late)(struct device *dev);\n\tint (*thaw_early)(struct device *dev);\n\tint (*poweroff_late)(struct device *dev);\n\tint (*restore_early)(struct device *dev);\n\tint (*suspend_noirq)(struct device *dev);\n\tint (*resume_noirq)(struct device *dev);\n\tint (*freeze_noirq)(struct device *dev);\n\tint (*thaw_noirq)(struct device *dev);\n\tint (*poweroff_noirq)(struct device *dev);\n\tint (*restore_noirq)(struct device *dev);\n\tint (*runtime_suspend)(struct device *dev);\n\tint (*runtime_resume)(struct device *dev);\n\tint (*runtime_idle)(struct device *dev);\n};\n\n#define SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\t.suspend = pm_sleep_ptr(suspend_fn), \\\n\t.resume = pm_sleep_ptr(resume_fn), \\\n\t.freeze = pm_sleep_ptr(suspend_fn), \\\n\t.thaw = pm_sleep_ptr(resume_fn), \\\n\t.poweroff = pm_sleep_ptr(suspend_fn), \\\n\t.restore = pm_sleep_ptr(resume_fn),\n\n#define LATE_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\t.suspend_late = pm_sleep_ptr(suspend_fn), \\\n\t.resume_early = pm_sleep_ptr(resume_fn), \\\n\t.freeze_late = pm_sleep_ptr(suspend_fn), \\\n\t.thaw_early = pm_sleep_ptr(resume_fn), \\\n\t.poweroff_late = pm_sleep_ptr(suspend_fn), \\\n\t.restore_early = pm_sleep_ptr(resume_fn),\n\n#define NOIRQ_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\t.suspend_noirq = pm_sleep_ptr(suspend_fn), \\\n\t.resume_noirq = pm_sleep_ptr(resume_fn), \\\n\t.freeze_noirq = pm_sleep_ptr(suspend_fn), \\\n\t.thaw_noirq = pm_sleep_ptr(resume_fn), \\\n\t.poweroff_noirq = pm_sleep_ptr(suspend_fn), \\\n\t.restore_noirq = pm_sleep_ptr(resume_fn),\n\n#define RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \\\n\t.runtime_suspend = suspend_fn, \\\n\t.runtime_resume = resume_fn, \\\n\t.runtime_idle = idle_fn,\n\n#ifdef CONFIG_PM_SLEEP\n#define SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\tSYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)\n#else\n#define SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)\n#endif\n\n#ifdef CONFIG_PM_SLEEP\n#define SET_LATE_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\tLATE_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)\n#else\n#define SET_LATE_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)\n#endif\n\n#ifdef CONFIG_PM_SLEEP\n#define SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)\n#else\n#define SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)\n#endif\n\n#ifdef CONFIG_PM\n#define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \\\n\tRUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn)\n#else\n#define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn)\n#endif\n\n#define _DEFINE_DEV_PM_OPS(name, \\\n\t\t\t   suspend_fn, resume_fn, \\\n\t\t\t   runtime_suspend_fn, runtime_resume_fn, idle_fn) \\\nconst struct dev_pm_ops name = { \\\n\tSYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\tRUNTIME_PM_OPS(runtime_suspend_fn, runtime_resume_fn, idle_fn) \\\n}\n\n#define _EXPORT_PM_OPS(name, license, ns)\t\t\t\t\\\n\tconst struct dev_pm_ops name;\t\t\t\t\t\\\n\t__EXPORT_SYMBOL(name, license, ns);\t\t\t\t\\\n\tconst struct dev_pm_ops name\n\n#define _DISCARD_PM_OPS(name, license, ns)\t\t\t\t\\\n\tstatic __maybe_unused const struct dev_pm_ops __static_##name\n\n#ifdef CONFIG_PM\n#define _EXPORT_DEV_PM_OPS(name, license, ns)\t\t_EXPORT_PM_OPS(name, license, ns)\n#define EXPORT_PM_FN_GPL(name)\t\t\t\tEXPORT_SYMBOL_GPL(name)\n#define EXPORT_PM_FN_NS_GPL(name, ns)\t\t\tEXPORT_SYMBOL_NS_GPL(name, ns)\n#else\n#define _EXPORT_DEV_PM_OPS(name, license, ns)\t\t_DISCARD_PM_OPS(name, license, ns)\n#define EXPORT_PM_FN_GPL(name)\n#define EXPORT_PM_FN_NS_GPL(name, ns)\n#endif\n\n#ifdef CONFIG_PM_SLEEP\n#define _EXPORT_DEV_SLEEP_PM_OPS(name, license, ns)\t_EXPORT_PM_OPS(name, license, ns)\n#else\n#define _EXPORT_DEV_SLEEP_PM_OPS(name, license, ns)\t_DISCARD_PM_OPS(name, license, ns)\n#endif\n\n#define EXPORT_DEV_PM_OPS(name)\t\t\t\t_EXPORT_DEV_PM_OPS(name, \"\", \"\")\n#define EXPORT_GPL_DEV_PM_OPS(name)\t\t\t_EXPORT_DEV_PM_OPS(name, \"GPL\", \"\")\n#define EXPORT_NS_DEV_PM_OPS(name, ns)\t\t\t_EXPORT_DEV_PM_OPS(name, \"\", #ns)\n#define EXPORT_NS_GPL_DEV_PM_OPS(name, ns)\t\t_EXPORT_DEV_PM_OPS(name, \"GPL\", #ns)\n\n#define EXPORT_DEV_SLEEP_PM_OPS(name)\t\t\t_EXPORT_DEV_SLEEP_PM_OPS(name, \"\", \"\")\n#define EXPORT_GPL_DEV_SLEEP_PM_OPS(name)\t\t_EXPORT_DEV_SLEEP_PM_OPS(name, \"GPL\", \"\")\n#define EXPORT_NS_DEV_SLEEP_PM_OPS(name, ns)\t\t_EXPORT_DEV_SLEEP_PM_OPS(name, \"\", #ns)\n#define EXPORT_NS_GPL_DEV_SLEEP_PM_OPS(name, ns)\t_EXPORT_DEV_SLEEP_PM_OPS(name, \"GPL\", #ns)\n\n \n#define DEFINE_SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \\\n\t_DEFINE_DEV_PM_OPS(name, suspend_fn, resume_fn, NULL, NULL, NULL)\n\n#define EXPORT_SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \\\n\tEXPORT_DEV_SLEEP_PM_OPS(name) = { \\\n\t\tSYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\t}\n#define EXPORT_GPL_SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \\\n\tEXPORT_GPL_DEV_SLEEP_PM_OPS(name) = { \\\n\t\tSYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\t}\n#define EXPORT_NS_SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn, ns)\t\\\n\tEXPORT_NS_DEV_SLEEP_PM_OPS(name, ns) = { \\\n\t\tSYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\t}\n#define EXPORT_NS_GPL_SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn, ns)\t\\\n\tEXPORT_NS_GPL_DEV_SLEEP_PM_OPS(name, ns) = { \\\n\t\tSYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\t}\n\n \n#define SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \\\nconst struct dev_pm_ops __maybe_unused name = { \\\n\tSET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n}\n\n \n#define UNIVERSAL_DEV_PM_OPS(name, suspend_fn, resume_fn, idle_fn) \\\nconst struct dev_pm_ops __maybe_unused name = { \\\n\tSET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n\tSET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \\\n}\n\n \n#define DEFINE_NOIRQ_DEV_PM_OPS(name, suspend_fn, resume_fn) \\\nconst struct dev_pm_ops name = { \\\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\\n}\n\n#define pm_ptr(_ptr) PTR_IF(IS_ENABLED(CONFIG_PM), (_ptr))\n#define pm_sleep_ptr(_ptr) PTR_IF(IS_ENABLED(CONFIG_PM_SLEEP), (_ptr))\n\n \n\n#define PM_EVENT_INVALID\t(-1)\n#define PM_EVENT_ON\t\t0x0000\n#define PM_EVENT_FREEZE\t\t0x0001\n#define PM_EVENT_SUSPEND\t0x0002\n#define PM_EVENT_HIBERNATE\t0x0004\n#define PM_EVENT_QUIESCE\t0x0008\n#define PM_EVENT_RESUME\t\t0x0010\n#define PM_EVENT_THAW\t\t0x0020\n#define PM_EVENT_RESTORE\t0x0040\n#define PM_EVENT_RECOVER\t0x0080\n#define PM_EVENT_USER\t\t0x0100\n#define PM_EVENT_REMOTE\t\t0x0200\n#define PM_EVENT_AUTO\t\t0x0400\n\n#define PM_EVENT_SLEEP\t\t(PM_EVENT_SUSPEND | PM_EVENT_HIBERNATE)\n#define PM_EVENT_USER_SUSPEND\t(PM_EVENT_USER | PM_EVENT_SUSPEND)\n#define PM_EVENT_USER_RESUME\t(PM_EVENT_USER | PM_EVENT_RESUME)\n#define PM_EVENT_REMOTE_RESUME\t(PM_EVENT_REMOTE | PM_EVENT_RESUME)\n#define PM_EVENT_AUTO_SUSPEND\t(PM_EVENT_AUTO | PM_EVENT_SUSPEND)\n#define PM_EVENT_AUTO_RESUME\t(PM_EVENT_AUTO | PM_EVENT_RESUME)\n\n#define PMSG_INVALID\t((struct pm_message){ .event = PM_EVENT_INVALID, })\n#define PMSG_ON\t\t((struct pm_message){ .event = PM_EVENT_ON, })\n#define PMSG_FREEZE\t((struct pm_message){ .event = PM_EVENT_FREEZE, })\n#define PMSG_QUIESCE\t((struct pm_message){ .event = PM_EVENT_QUIESCE, })\n#define PMSG_SUSPEND\t((struct pm_message){ .event = PM_EVENT_SUSPEND, })\n#define PMSG_HIBERNATE\t((struct pm_message){ .event = PM_EVENT_HIBERNATE, })\n#define PMSG_RESUME\t((struct pm_message){ .event = PM_EVENT_RESUME, })\n#define PMSG_THAW\t((struct pm_message){ .event = PM_EVENT_THAW, })\n#define PMSG_RESTORE\t((struct pm_message){ .event = PM_EVENT_RESTORE, })\n#define PMSG_RECOVER\t((struct pm_message){ .event = PM_EVENT_RECOVER, })\n#define PMSG_USER_SUSPEND\t((struct pm_message) \\\n\t\t\t\t\t{ .event = PM_EVENT_USER_SUSPEND, })\n#define PMSG_USER_RESUME\t((struct pm_message) \\\n\t\t\t\t\t{ .event = PM_EVENT_USER_RESUME, })\n#define PMSG_REMOTE_RESUME\t((struct pm_message) \\\n\t\t\t\t\t{ .event = PM_EVENT_REMOTE_RESUME, })\n#define PMSG_AUTO_SUSPEND\t((struct pm_message) \\\n\t\t\t\t\t{ .event = PM_EVENT_AUTO_SUSPEND, })\n#define PMSG_AUTO_RESUME\t((struct pm_message) \\\n\t\t\t\t\t{ .event = PM_EVENT_AUTO_RESUME, })\n\n#define PMSG_IS_AUTO(msg)\t(((msg).event & PM_EVENT_AUTO) != 0)\n\n \n\nenum rpm_status {\n\tRPM_INVALID = -1,\n\tRPM_ACTIVE = 0,\n\tRPM_RESUMING,\n\tRPM_SUSPENDED,\n\tRPM_SUSPENDING,\n};\n\n \n\nenum rpm_request {\n\tRPM_REQ_NONE = 0,\n\tRPM_REQ_IDLE,\n\tRPM_REQ_SUSPEND,\n\tRPM_REQ_AUTOSUSPEND,\n\tRPM_REQ_RESUME,\n};\n\nstruct wakeup_source;\nstruct wake_irq;\nstruct pm_domain_data;\n\nstruct pm_subsys_data {\n\tspinlock_t lock;\n\tunsigned int refcount;\n#ifdef CONFIG_PM_CLK\n\tunsigned int clock_op_might_sleep;\n\tstruct mutex clock_mutex;\n\tstruct list_head clock_list;\n#endif\n#ifdef CONFIG_PM_GENERIC_DOMAINS\n\tstruct pm_domain_data *domain_data;\n#endif\n};\n\n \n#define DPM_FLAG_NO_DIRECT_COMPLETE\tBIT(0)\n#define DPM_FLAG_SMART_PREPARE\t\tBIT(1)\n#define DPM_FLAG_SMART_SUSPEND\t\tBIT(2)\n#define DPM_FLAG_MAY_SKIP_RESUME\tBIT(3)\n\nstruct dev_pm_info {\n\tpm_message_t\t\tpower_state;\n\tunsigned int\t\tcan_wakeup:1;\n\tunsigned int\t\tasync_suspend:1;\n\tbool\t\t\tin_dpm_list:1;\t \n\tbool\t\t\tis_prepared:1;\t \n\tbool\t\t\tis_suspended:1;\t \n\tbool\t\t\tis_noirq_suspended:1;\n\tbool\t\t\tis_late_suspended:1;\n\tbool\t\t\tno_pm:1;\n\tbool\t\t\tearly_init:1;\t \n\tbool\t\t\tdirect_complete:1;\t \n\tu32\t\t\tdriver_flags;\n\tspinlock_t\t\tlock;\n#ifdef CONFIG_PM_SLEEP\n\tstruct list_head\tentry;\n\tstruct completion\tcompletion;\n\tstruct wakeup_source\t*wakeup;\n\tbool\t\t\twakeup_path:1;\n\tbool\t\t\tsyscore:1;\n\tbool\t\t\tno_pm_callbacks:1;\t \n\tunsigned int\t\tmust_resume:1;\t \n\tunsigned int\t\tmay_skip_resume:1;\t \n#else\n\tunsigned int\t\tshould_wakeup:1;\n#endif\n#ifdef CONFIG_PM\n\tstruct hrtimer\t\tsuspend_timer;\n\tu64\t\t\ttimer_expires;\n\tstruct work_struct\twork;\n\twait_queue_head_t\twait_queue;\n\tstruct wake_irq\t\t*wakeirq;\n\tatomic_t\t\tusage_count;\n\tatomic_t\t\tchild_count;\n\tunsigned int\t\tdisable_depth:3;\n\tunsigned int\t\tidle_notification:1;\n\tunsigned int\t\trequest_pending:1;\n\tunsigned int\t\tdeferred_resume:1;\n\tunsigned int\t\tneeds_force_resume:1;\n\tunsigned int\t\truntime_auto:1;\n\tbool\t\t\tignore_children:1;\n\tunsigned int\t\tno_callbacks:1;\n\tunsigned int\t\tirq_safe:1;\n\tunsigned int\t\tuse_autosuspend:1;\n\tunsigned int\t\ttimer_autosuspends:1;\n\tunsigned int\t\tmemalloc_noio:1;\n\tunsigned int\t\tlinks_count;\n\tenum rpm_request\trequest;\n\tenum rpm_status\t\truntime_status;\n\tenum rpm_status\t\tlast_status;\n\tint\t\t\truntime_error;\n\tint\t\t\tautosuspend_delay;\n\tu64\t\t\tlast_busy;\n\tu64\t\t\tactive_time;\n\tu64\t\t\tsuspended_time;\n\tu64\t\t\taccounting_timestamp;\n#endif\n\tstruct pm_subsys_data\t*subsys_data;   \n\tvoid (*set_latency_tolerance)(struct device *, s32);\n\tstruct dev_pm_qos\t*qos;\n};\n\nextern int dev_pm_get_subsys_data(struct device *dev);\nextern void dev_pm_put_subsys_data(struct device *dev);\n\n \nstruct dev_pm_domain {\n\tstruct dev_pm_ops\tops;\n\tint (*start)(struct device *dev);\n\tvoid (*detach)(struct device *dev, bool power_off);\n\tint (*activate)(struct device *dev);\n\tvoid (*sync)(struct device *dev);\n\tvoid (*dismiss)(struct device *dev);\n};\n\n \n\n \n#define PM_EVENT_PRETHAW PM_EVENT_QUIESCE\n\n \n\n#ifdef CONFIG_PM_SLEEP\nextern void device_pm_lock(void);\nextern void dpm_resume_start(pm_message_t state);\nextern void dpm_resume_end(pm_message_t state);\nextern void dpm_resume_noirq(pm_message_t state);\nextern void dpm_resume_early(pm_message_t state);\nextern void dpm_resume(pm_message_t state);\nextern void dpm_complete(pm_message_t state);\n\nextern void device_pm_unlock(void);\nextern int dpm_suspend_end(pm_message_t state);\nextern int dpm_suspend_start(pm_message_t state);\nextern int dpm_suspend_noirq(pm_message_t state);\nextern int dpm_suspend_late(pm_message_t state);\nextern int dpm_suspend(pm_message_t state);\nextern int dpm_prepare(pm_message_t state);\n\nextern void __suspend_report_result(const char *function, struct device *dev, void *fn, int ret);\n\n#define suspend_report_result(dev, fn, ret)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t__suspend_report_result(__func__, dev, fn, ret);\t\\\n\t} while (0)\n\nextern int device_pm_wait_for_dev(struct device *sub, struct device *dev);\nextern void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *));\n\nextern int pm_generic_prepare(struct device *dev);\nextern int pm_generic_suspend_late(struct device *dev);\nextern int pm_generic_suspend_noirq(struct device *dev);\nextern int pm_generic_suspend(struct device *dev);\nextern int pm_generic_resume_early(struct device *dev);\nextern int pm_generic_resume_noirq(struct device *dev);\nextern int pm_generic_resume(struct device *dev);\nextern int pm_generic_freeze_noirq(struct device *dev);\nextern int pm_generic_freeze_late(struct device *dev);\nextern int pm_generic_freeze(struct device *dev);\nextern int pm_generic_thaw_noirq(struct device *dev);\nextern int pm_generic_thaw_early(struct device *dev);\nextern int pm_generic_thaw(struct device *dev);\nextern int pm_generic_restore_noirq(struct device *dev);\nextern int pm_generic_restore_early(struct device *dev);\nextern int pm_generic_restore(struct device *dev);\nextern int pm_generic_poweroff_noirq(struct device *dev);\nextern int pm_generic_poweroff_late(struct device *dev);\nextern int pm_generic_poweroff(struct device *dev);\nextern void pm_generic_complete(struct device *dev);\n\nextern bool dev_pm_skip_resume(struct device *dev);\nextern bool dev_pm_skip_suspend(struct device *dev);\n\n#else  \n\n#define device_pm_lock() do {} while (0)\n#define device_pm_unlock() do {} while (0)\n\nstatic inline int dpm_suspend_start(pm_message_t state)\n{\n\treturn 0;\n}\n\n#define suspend_report_result(dev, fn, ret)\tdo {} while (0)\n\nstatic inline int device_pm_wait_for_dev(struct device *a, struct device *b)\n{\n\treturn 0;\n}\n\nstatic inline void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *))\n{\n}\n\n#define pm_generic_prepare\t\tNULL\n#define pm_generic_suspend_late\t\tNULL\n#define pm_generic_suspend_noirq\tNULL\n#define pm_generic_suspend\t\tNULL\n#define pm_generic_resume_early\t\tNULL\n#define pm_generic_resume_noirq\t\tNULL\n#define pm_generic_resume\t\tNULL\n#define pm_generic_freeze_noirq\t\tNULL\n#define pm_generic_freeze_late\t\tNULL\n#define pm_generic_freeze\t\tNULL\n#define pm_generic_thaw_noirq\t\tNULL\n#define pm_generic_thaw_early\t\tNULL\n#define pm_generic_thaw\t\t\tNULL\n#define pm_generic_restore_noirq\tNULL\n#define pm_generic_restore_early\tNULL\n#define pm_generic_restore\t\tNULL\n#define pm_generic_poweroff_noirq\tNULL\n#define pm_generic_poweroff_late\tNULL\n#define pm_generic_poweroff\t\tNULL\n#define pm_generic_complete\t\tNULL\n#endif  \n\n \nenum dpm_order {\n\tDPM_ORDER_NONE,\n\tDPM_ORDER_DEV_AFTER_PARENT,\n\tDPM_ORDER_PARENT_BEFORE_DEV,\n\tDPM_ORDER_DEV_LAST,\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}