{
  "module_name": "firewire.h",
  "hash_id": "b5946333b9fc244fc2363c6d95be7f6519ad0984ee0bf08377858d3a6659fb32",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/firewire.h",
  "human_readable_source": " \n#ifndef _LINUX_FIREWIRE_H\n#define _LINUX_FIREWIRE_H\n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sysfs.h>\n#include <linux/timer.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n\n#define CSR_REGISTER_BASE\t\t0xfffff0000000ULL\n\n \n#define CSR_STATE_CLEAR\t\t\t0x0\n#define CSR_STATE_SET\t\t\t0x4\n#define CSR_NODE_IDS\t\t\t0x8\n#define CSR_RESET_START\t\t\t0xc\n#define CSR_SPLIT_TIMEOUT_HI\t\t0x18\n#define CSR_SPLIT_TIMEOUT_LO\t\t0x1c\n#define CSR_CYCLE_TIME\t\t\t0x200\n#define CSR_BUS_TIME\t\t\t0x204\n#define CSR_BUSY_TIMEOUT\t\t0x210\n#define CSR_PRIORITY_BUDGET\t\t0x218\n#define CSR_BUS_MANAGER_ID\t\t0x21c\n#define CSR_BANDWIDTH_AVAILABLE\t\t0x220\n#define CSR_CHANNELS_AVAILABLE\t\t0x224\n#define CSR_CHANNELS_AVAILABLE_HI\t0x224\n#define CSR_CHANNELS_AVAILABLE_LO\t0x228\n#define CSR_MAINT_UTILITY\t\t0x230\n#define CSR_BROADCAST_CHANNEL\t\t0x234\n#define CSR_CONFIG_ROM\t\t\t0x400\n#define CSR_CONFIG_ROM_END\t\t0x800\n#define CSR_OMPR\t\t\t0x900\n#define CSR_OPCR(i)\t\t\t(0x904 + (i) * 4)\n#define CSR_IMPR\t\t\t0x980\n#define CSR_IPCR(i)\t\t\t(0x984 + (i) * 4)\n#define CSR_FCP_COMMAND\t\t\t0xB00\n#define CSR_FCP_RESPONSE\t\t0xD00\n#define CSR_FCP_END\t\t\t0xF00\n#define CSR_TOPOLOGY_MAP\t\t0x1000\n#define CSR_TOPOLOGY_MAP_END\t\t0x1400\n#define CSR_SPEED_MAP\t\t\t0x2000\n#define CSR_SPEED_MAP_END\t\t0x3000\n\n#define CSR_OFFSET\t\t0x40\n#define CSR_LEAF\t\t0x80\n#define CSR_DIRECTORY\t\t0xc0\n\n#define CSR_DESCRIPTOR\t\t0x01\n#define CSR_VENDOR\t\t0x03\n#define CSR_HARDWARE_VERSION\t0x04\n#define CSR_UNIT\t\t0x11\n#define CSR_SPECIFIER_ID\t0x12\n#define CSR_VERSION\t\t0x13\n#define CSR_DEPENDENT_INFO\t0x14\n#define CSR_MODEL\t\t0x17\n#define CSR_DIRECTORY_ID\t0x20\n\nstruct fw_csr_iterator {\n\tconst u32 *p;\n\tconst u32 *end;\n};\n\nvoid fw_csr_iterator_init(struct fw_csr_iterator *ci, const u32 *p);\nint fw_csr_iterator_next(struct fw_csr_iterator *ci, int *key, int *value);\nint fw_csr_string(const u32 *directory, int key, char *buf, size_t size);\n\nextern struct bus_type fw_bus_type;\n\nstruct fw_card_driver;\nstruct fw_node;\n\nstruct fw_card {\n\tconst struct fw_card_driver *driver;\n\tstruct device *device;\n\tstruct kref kref;\n\tstruct completion done;\n\n\tint node_id;\n\tint generation;\n\tint current_tlabel;\n\tu64 tlabel_mask;\n\tstruct list_head transaction_list;\n\tu64 reset_jiffies;\n\n\tu32 split_timeout_hi;\n\tu32 split_timeout_lo;\n\tunsigned int split_timeout_cycles;\n\tunsigned int split_timeout_jiffies;\n\n\tunsigned long long guid;\n\tunsigned max_receive;\n\tint link_speed;\n\tint config_rom_generation;\n\n\tspinlock_t lock;  \n\tstruct fw_node *local_node;\n\tstruct fw_node *root_node;\n\tstruct fw_node *irm_node;\n\tu8 color;  \n\tint gap_count;\n\tbool beta_repeaters_present;\n\n\tint index;\n\tstruct list_head link;\n\n\tstruct list_head phy_receiver_list;\n\n\tstruct delayed_work br_work;  \n\tbool br_short;\n\n\tstruct delayed_work bm_work;  \n\tint bm_retries;\n\tint bm_generation;\n\tint bm_node_id;\n\tbool bm_abdicate;\n\n\tbool priority_budget_implemented;\t \n\tbool broadcast_channel_auto_allocated;\t \n\n\tbool broadcast_channel_allocated;\n\tu32 broadcast_channel;\n\t__be32 topology_map[(CSR_TOPOLOGY_MAP_END - CSR_TOPOLOGY_MAP) / 4];\n\n\t__be32 maint_utility_register;\n};\n\nstatic inline struct fw_card *fw_card_get(struct fw_card *card)\n{\n\tkref_get(&card->kref);\n\n\treturn card;\n}\n\nvoid fw_card_release(struct kref *kref);\n\nstatic inline void fw_card_put(struct fw_card *card)\n{\n\tkref_put(&card->kref, fw_card_release);\n}\n\nint fw_card_read_cycle_time(struct fw_card *card, u32 *cycle_time);\n\nstruct fw_attribute_group {\n\tstruct attribute_group *groups[2];\n\tstruct attribute_group group;\n\tstruct attribute *attrs[13];\n};\n\nenum fw_device_state {\n\tFW_DEVICE_INITIALIZING,\n\tFW_DEVICE_RUNNING,\n\tFW_DEVICE_GONE,\n\tFW_DEVICE_SHUTDOWN,\n};\n\n \nstruct fw_device {\n\tatomic_t state;\n\tstruct fw_node *node;\n\tint node_id;\n\tint generation;\n\tunsigned max_speed;\n\tstruct fw_card *card;\n\tstruct device device;\n\n\tstruct mutex client_list_mutex;\n\tstruct list_head client_list;\n\n\tconst u32 *config_rom;\n\tsize_t config_rom_length;\n\tint config_rom_retries;\n\tunsigned is_local:1;\n\tunsigned max_rec:4;\n\tunsigned cmc:1;\n\tunsigned irmc:1;\n\tunsigned bc_implemented:2;\n\n\twork_func_t workfn;\n\tstruct delayed_work work;\n\tstruct fw_attribute_group attribute_group;\n};\n\n#define fw_device(dev)\tcontainer_of_const(dev, struct fw_device, device)\n\nstatic inline int fw_device_is_shutdown(struct fw_device *device)\n{\n\treturn atomic_read(&device->state) == FW_DEVICE_SHUTDOWN;\n}\n\nint fw_device_enable_phys_dma(struct fw_device *device);\n\n \nstruct fw_unit {\n\tstruct device device;\n\tconst u32 *directory;\n\tstruct fw_attribute_group attribute_group;\n};\n\n#define fw_unit(dev)\tcontainer_of_const(dev, struct fw_unit, device)\n\nstatic inline struct fw_unit *fw_unit_get(struct fw_unit *unit)\n{\n\tget_device(&unit->device);\n\n\treturn unit;\n}\n\nstatic inline void fw_unit_put(struct fw_unit *unit)\n{\n\tput_device(&unit->device);\n}\n\n#define fw_parent_device(unit)\tfw_device(unit->device.parent)\n\nstruct ieee1394_device_id;\n\nstruct fw_driver {\n\tstruct device_driver driver;\n\tint (*probe)(struct fw_unit *unit, const struct ieee1394_device_id *id);\n\t \n\tvoid (*update)(struct fw_unit *unit);\n\tvoid (*remove)(struct fw_unit *unit);\n\tconst struct ieee1394_device_id *id_table;\n};\n\nstruct fw_packet;\nstruct fw_request;\n\ntypedef void (*fw_packet_callback_t)(struct fw_packet *packet,\n\t\t\t\t     struct fw_card *card, int status);\ntypedef void (*fw_transaction_callback_t)(struct fw_card *card, int rcode,\n\t\t\t\t\t  void *data, size_t length,\n\t\t\t\t\t  void *callback_data);\ntypedef void (*fw_transaction_callback_with_tstamp_t)(struct fw_card *card, int rcode,\n\t\t\t\t\tu32 request_tstamp, u32 response_tstamp, void *data,\n\t\t\t\t\tsize_t length, void *callback_data);\n\nunion fw_transaction_callback {\n\tfw_transaction_callback_t without_tstamp;\n\tfw_transaction_callback_with_tstamp_t with_tstamp;\n};\n\n \ntypedef void (*fw_address_callback_t)(struct fw_card *card,\n\t\t\t\t      struct fw_request *request,\n\t\t\t\t      int tcode, int destination, int source,\n\t\t\t\t      int generation,\n\t\t\t\t      unsigned long long offset,\n\t\t\t\t      void *data, size_t length,\n\t\t\t\t      void *callback_data);\n\nstruct fw_packet {\n\tint speed;\n\tint generation;\n\tu32 header[4];\n\tsize_t header_length;\n\tvoid *payload;\n\tsize_t payload_length;\n\tdma_addr_t payload_bus;\n\tbool payload_mapped;\n\tu32 timestamp;\n\n\t \n\tfw_packet_callback_t callback;\n\tint ack;\n\tstruct list_head link;\n\tvoid *driver_data;\n};\n\nstruct fw_transaction {\n\tint node_id;  \n\tint tlabel;\n\tstruct list_head link;\n\tstruct fw_card *card;\n\tbool is_split_transaction;\n\tstruct timer_list split_timeout_timer;\n\tu32 split_timeout_cycle;\n\n\tstruct fw_packet packet;\n\n\t \n\tunion fw_transaction_callback callback;\n\tbool with_tstamp;\n\tvoid *callback_data;\n};\n\nstruct fw_address_handler {\n\tu64 offset;\n\tu64 length;\n\tfw_address_callback_t address_callback;\n\tvoid *callback_data;\n\tstruct list_head link;\n};\n\nstruct fw_address_region {\n\tu64 start;\n\tu64 end;\n};\n\nextern const struct fw_address_region fw_high_memory_region;\n\nint fw_core_add_address_handler(struct fw_address_handler *handler,\n\t\t\t\tconst struct fw_address_region *region);\nvoid fw_core_remove_address_handler(struct fw_address_handler *handler);\nvoid fw_send_response(struct fw_card *card,\n\t\t      struct fw_request *request, int rcode);\nint fw_get_request_speed(struct fw_request *request);\nu32 fw_request_get_timestamp(const struct fw_request *request);\n\nvoid __fw_send_request(struct fw_card *card, struct fw_transaction *t, int tcode,\n\t\tint destination_id, int generation, int speed, unsigned long long offset,\n\t\tvoid *payload, size_t length, union fw_transaction_callback callback,\n\t\tbool with_tstamp, void *callback_data);\n\n \nstatic inline void fw_send_request(struct fw_card *card, struct fw_transaction *t, int tcode,\n\t\t\t\t   int destination_id, int generation, int speed,\n\t\t\t\t   unsigned long long offset, void *payload, size_t length,\n\t\t\t\t   fw_transaction_callback_t callback, void *callback_data)\n{\n\tunion fw_transaction_callback cb = {\n\t\t.without_tstamp = callback,\n\t};\n\t__fw_send_request(card, t, tcode, destination_id, generation, speed, offset, payload,\n\t\t\t  length, cb, false, callback_data);\n}\n\n \nstatic inline void fw_send_request_with_tstamp(struct fw_card *card, struct fw_transaction *t,\n\tint tcode, int destination_id, int generation, int speed, unsigned long long offset,\n\tvoid *payload, size_t length, fw_transaction_callback_with_tstamp_t callback,\n\tvoid *callback_data)\n{\n\tunion fw_transaction_callback cb = {\n\t\t.with_tstamp = callback,\n\t};\n\t__fw_send_request(card, t, tcode, destination_id, generation, speed, offset, payload,\n\t\t\t  length, cb, true, callback_data);\n}\n\nint fw_cancel_transaction(struct fw_card *card,\n\t\t\t  struct fw_transaction *transaction);\nint fw_run_transaction(struct fw_card *card, int tcode, int destination_id,\n\t\t       int generation, int speed, unsigned long long offset,\n\t\t       void *payload, size_t length);\nconst char *fw_rcode_string(int rcode);\n\nstatic inline int fw_stream_packet_destination_id(int tag, int channel, int sy)\n{\n\treturn tag << 14 | channel << 8 | sy;\n}\n\nvoid fw_schedule_bus_reset(struct fw_card *card, bool delayed,\n\t\t\t   bool short_reset);\n\nstruct fw_descriptor {\n\tstruct list_head link;\n\tsize_t length;\n\tu32 immediate;\n\tu32 key;\n\tconst u32 *data;\n};\n\nint fw_core_add_descriptor(struct fw_descriptor *desc);\nvoid fw_core_remove_descriptor(struct fw_descriptor *desc);\n\n \nstruct fw_iso_packet {\n\tu16 payload_length;\t \n\tu32 interrupt:1;\t \n\tu32 skip:1;\t\t \n\t\t\t\t \n\tu32 tag:2;\t\t \n\tu32 sy:4;\t\t \n\tu32 header_length:8;\t \n\tu32 header[];\t\t \n};\n\n#define FW_ISO_CONTEXT_TRANSMIT\t\t\t0\n#define FW_ISO_CONTEXT_RECEIVE\t\t\t1\n#define FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL\t2\n\n#define FW_ISO_CONTEXT_MATCH_TAG0\t 1\n#define FW_ISO_CONTEXT_MATCH_TAG1\t 2\n#define FW_ISO_CONTEXT_MATCH_TAG2\t 4\n#define FW_ISO_CONTEXT_MATCH_TAG3\t 8\n#define FW_ISO_CONTEXT_MATCH_ALL_TAGS\t15\n\n \nstruct fw_iso_buffer {\n\tenum dma_data_direction direction;\n\tstruct page **pages;\n\tint page_count;\n\tint page_count_mapped;\n};\n\nint fw_iso_buffer_init(struct fw_iso_buffer *buffer, struct fw_card *card,\n\t\t       int page_count, enum dma_data_direction direction);\nvoid fw_iso_buffer_destroy(struct fw_iso_buffer *buffer, struct fw_card *card);\nsize_t fw_iso_buffer_lookup(struct fw_iso_buffer *buffer, dma_addr_t completed);\n\nstruct fw_iso_context;\ntypedef void (*fw_iso_callback_t)(struct fw_iso_context *context,\n\t\t\t\t  u32 cycle, size_t header_length,\n\t\t\t\t  void *header, void *data);\ntypedef void (*fw_iso_mc_callback_t)(struct fw_iso_context *context,\n\t\t\t\t     dma_addr_t completed, void *data);\n\nunion fw_iso_callback {\n\tfw_iso_callback_t sc;\n\tfw_iso_mc_callback_t mc;\n};\n\nstruct fw_iso_context {\n\tstruct fw_card *card;\n\tint type;\n\tint channel;\n\tint speed;\n\tbool drop_overflow_headers;\n\tsize_t header_size;\n\tunion fw_iso_callback callback;\n\tvoid *callback_data;\n};\n\nstruct fw_iso_context *fw_iso_context_create(struct fw_card *card,\n\t\tint type, int channel, int speed, size_t header_size,\n\t\tfw_iso_callback_t callback, void *callback_data);\nint fw_iso_context_set_channels(struct fw_iso_context *ctx, u64 *channels);\nint fw_iso_context_queue(struct fw_iso_context *ctx,\n\t\t\t struct fw_iso_packet *packet,\n\t\t\t struct fw_iso_buffer *buffer,\n\t\t\t unsigned long payload);\nvoid fw_iso_context_queue_flush(struct fw_iso_context *ctx);\nint fw_iso_context_flush_completions(struct fw_iso_context *ctx);\nint fw_iso_context_start(struct fw_iso_context *ctx,\n\t\t\t int cycle, int sync, int tags);\nint fw_iso_context_stop(struct fw_iso_context *ctx);\nvoid fw_iso_context_destroy(struct fw_iso_context *ctx);\nvoid fw_iso_resource_manage(struct fw_card *card, int generation,\n\t\t\t    u64 channels_mask, int *channel, int *bandwidth,\n\t\t\t    bool allocate);\n\nextern struct workqueue_struct *fw_workqueue;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}