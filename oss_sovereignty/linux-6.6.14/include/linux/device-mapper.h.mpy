{
  "module_name": "device-mapper.h",
  "hash_id": "6bfe51a5cb23dd100db3b4fe4189f0a011a8419bfb5249e5e0c7f35153d22ca8",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/device-mapper.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_DEVICE_MAPPER_H\n#define _LINUX_DEVICE_MAPPER_H\n\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/dm-ioctl.h>\n#include <linux/math64.h>\n#include <linux/ratelimit.h>\n\nstruct dm_dev;\nstruct dm_target;\nstruct dm_table;\nstruct dm_report_zones_args;\nstruct mapped_device;\nstruct bio_vec;\nenum dax_access_mode;\n\n \nenum dm_queue_mode {\n\tDM_TYPE_NONE\t\t = 0,\n\tDM_TYPE_BIO_BASED\t = 1,\n\tDM_TYPE_REQUEST_BASED\t = 2,\n\tDM_TYPE_DAX_BIO_BASED\t = 3,\n};\n\ntypedef enum { STATUSTYPE_INFO, STATUSTYPE_TABLE, STATUSTYPE_IMA } status_type_t;\n\nunion map_info {\n\tvoid *ptr;\n};\n\n \ntypedef int (*dm_ctr_fn) (struct dm_target *target,\n\t\t\t  unsigned int argc, char **argv);\n\n \ntypedef void (*dm_dtr_fn) (struct dm_target *ti);\n\n \ntypedef int (*dm_map_fn) (struct dm_target *ti, struct bio *bio);\ntypedef int (*dm_clone_and_map_request_fn) (struct dm_target *ti,\n\t\t\t\t\t    struct request *rq,\n\t\t\t\t\t    union map_info *map_context,\n\t\t\t\t\t    struct request **clone);\ntypedef void (*dm_release_clone_request_fn) (struct request *clone,\n\t\t\t\t\t     union map_info *map_context);\n\n \ntypedef int (*dm_endio_fn) (struct dm_target *ti,\n\t\t\t    struct bio *bio, blk_status_t *error);\ntypedef int (*dm_request_endio_fn) (struct dm_target *ti,\n\t\t\t\t    struct request *clone, blk_status_t error,\n\t\t\t\t    union map_info *map_context);\n\ntypedef void (*dm_presuspend_fn) (struct dm_target *ti);\ntypedef void (*dm_presuspend_undo_fn) (struct dm_target *ti);\ntypedef void (*dm_postsuspend_fn) (struct dm_target *ti);\ntypedef int (*dm_preresume_fn) (struct dm_target *ti);\ntypedef void (*dm_resume_fn) (struct dm_target *ti);\n\ntypedef void (*dm_status_fn) (struct dm_target *ti, status_type_t status_type,\n\t\t\t      unsigned int status_flags, char *result, unsigned int maxlen);\n\ntypedef int (*dm_message_fn) (struct dm_target *ti, unsigned int argc, char **argv,\n\t\t\t      char *result, unsigned int maxlen);\n\ntypedef int (*dm_prepare_ioctl_fn) (struct dm_target *ti, struct block_device **bdev);\n\n#ifdef CONFIG_BLK_DEV_ZONED\ntypedef int (*dm_report_zones_fn) (struct dm_target *ti,\n\t\t\t\t   struct dm_report_zones_args *args,\n\t\t\t\t   unsigned int nr_zones);\n#else\n \ntypedef int (*dm_report_zones_fn) (struct dm_target *dummy);\n#endif\n\n \ntypedef int (*iterate_devices_callout_fn) (struct dm_target *ti,\n\t\t\t\t\t   struct dm_dev *dev,\n\t\t\t\t\t   sector_t start, sector_t len,\n\t\t\t\t\t   void *data);\n\n \ntypedef int (*dm_iterate_devices_fn) (struct dm_target *ti,\n\t\t\t\t      iterate_devices_callout_fn fn,\n\t\t\t\t      void *data);\n\ntypedef void (*dm_io_hints_fn) (struct dm_target *ti,\n\t\t\t\tstruct queue_limits *limits);\n\n \ntypedef int (*dm_busy_fn) (struct dm_target *ti);\n\n \ntypedef long (*dm_dax_direct_access_fn) (struct dm_target *ti, pgoff_t pgoff,\n\t\tlong nr_pages, enum dax_access_mode node, void **kaddr,\n\t\tpfn_t *pfn);\ntypedef int (*dm_dax_zero_page_range_fn)(struct dm_target *ti, pgoff_t pgoff,\n\t\tsize_t nr_pages);\n\n \ntypedef size_t (*dm_dax_recovery_write_fn)(struct dm_target *ti, pgoff_t pgoff,\n\t\tvoid *addr, size_t bytes, struct iov_iter *i);\n\nvoid dm_error(const char *message);\n\nstruct dm_dev {\n\tstruct block_device *bdev;\n\tstruct dax_device *dax_dev;\n\tblk_mode_t mode;\n\tchar name[16];\n};\n\n \nint dm_get_device(struct dm_target *ti, const char *path, blk_mode_t mode,\n\t\t  struct dm_dev **result);\nvoid dm_put_device(struct dm_target *ti, struct dm_dev *d);\n\n \n\nstruct target_type {\n\tuint64_t features;\n\tconst char *name;\n\tstruct module *module;\n\tunsigned int version[3];\n\tdm_ctr_fn ctr;\n\tdm_dtr_fn dtr;\n\tdm_map_fn map;\n\tdm_clone_and_map_request_fn clone_and_map_rq;\n\tdm_release_clone_request_fn release_clone_rq;\n\tdm_endio_fn end_io;\n\tdm_request_endio_fn rq_end_io;\n\tdm_presuspend_fn presuspend;\n\tdm_presuspend_undo_fn presuspend_undo;\n\tdm_postsuspend_fn postsuspend;\n\tdm_preresume_fn preresume;\n\tdm_resume_fn resume;\n\tdm_status_fn status;\n\tdm_message_fn message;\n\tdm_prepare_ioctl_fn prepare_ioctl;\n\tdm_report_zones_fn report_zones;\n\tdm_busy_fn busy;\n\tdm_iterate_devices_fn iterate_devices;\n\tdm_io_hints_fn io_hints;\n\tdm_dax_direct_access_fn direct_access;\n\tdm_dax_zero_page_range_fn dax_zero_page_range;\n\tdm_dax_recovery_write_fn dax_recovery_write;\n\n\t \n\tstruct list_head list;\n};\n\n \n\n \n#define DM_TARGET_SINGLETON\t\t0x00000001\n#define dm_target_needs_singleton(type)\t((type)->features & DM_TARGET_SINGLETON)\n\n \n#define DM_TARGET_ALWAYS_WRITEABLE\t0x00000002\n#define dm_target_always_writeable(type) \\\n\t\t((type)->features & DM_TARGET_ALWAYS_WRITEABLE)\n\n \n#define DM_TARGET_IMMUTABLE\t\t0x00000004\n#define dm_target_is_immutable(type)\t((type)->features & DM_TARGET_IMMUTABLE)\n\n \n#define DM_TARGET_WILDCARD\t\t0x00000008\n#define dm_target_is_wildcard(type)\t((type)->features & DM_TARGET_WILDCARD)\n\n \n#define DM_TARGET_INTEGRITY\t\t0x00000010\n#define dm_target_has_integrity(type)\t((type)->features & DM_TARGET_INTEGRITY)\n\n \n#define DM_TARGET_PASSES_INTEGRITY\t0x00000020\n#define dm_target_passes_integrity(type) ((type)->features & DM_TARGET_PASSES_INTEGRITY)\n\n \n#ifdef CONFIG_BLK_DEV_ZONED\n#define DM_TARGET_ZONED_HM\t\t0x00000040\n#define dm_target_supports_zoned_hm(type) ((type)->features & DM_TARGET_ZONED_HM)\n#else\n#define DM_TARGET_ZONED_HM\t\t0x00000000\n#define dm_target_supports_zoned_hm(type) (false)\n#endif\n\n \n#define DM_TARGET_NOWAIT\t\t0x00000080\n#define dm_target_supports_nowait(type) ((type)->features & DM_TARGET_NOWAIT)\n\n \n#define DM_TARGET_PASSES_CRYPTO\t\t0x00000100\n#define dm_target_passes_crypto(type) ((type)->features & DM_TARGET_PASSES_CRYPTO)\n\n#ifdef CONFIG_BLK_DEV_ZONED\n#define DM_TARGET_MIXED_ZONED_MODEL\t0x00000200\n#define dm_target_supports_mixed_zoned_model(type) \\\n\t((type)->features & DM_TARGET_MIXED_ZONED_MODEL)\n#else\n#define DM_TARGET_MIXED_ZONED_MODEL\t0x00000000\n#define dm_target_supports_mixed_zoned_model(type) (false)\n#endif\n\nstruct dm_target {\n\tstruct dm_table *table;\n\tstruct target_type *type;\n\n\t \n\tsector_t begin;\n\tsector_t len;\n\n\t \n\tuint32_t max_io_len;\n\n\t \n\tunsigned int num_flush_bios;\n\n\t \n\tunsigned int num_discard_bios;\n\n\t \n\tunsigned int num_secure_erase_bios;\n\n\t \n\tunsigned int num_write_zeroes_bios;\n\n\t \n\tunsigned int per_io_data_size;\n\n\t \n\tvoid *private;\n\n\t \n\tchar *error;\n\n\t \n\tbool flush_supported:1;\n\n\t \n\tbool discards_supported:1;\n\n\t \n\tbool max_discard_granularity:1;\n\n\t \n\tbool max_secure_erase_granularity:1;\n\n\t \n\tbool max_write_zeroes_granularity:1;\n\n\t \n\tbool limit_swap_bios:1;\n\n\t \n\tbool emulate_zone_append:1;\n\n\t \n\tbool accounts_remapped_io:1;\n\n\t \n\tbool needs_bio_set_dev:1;\n};\n\nvoid *dm_per_bio_data(struct bio *bio, size_t data_size);\nstruct bio *dm_bio_from_per_bio_data(void *data, size_t data_size);\nunsigned int dm_bio_get_target_bio_nr(const struct bio *bio);\n\nu64 dm_start_time_ns_from_clone(struct bio *bio);\n\nint dm_register_target(struct target_type *t);\nvoid dm_unregister_target(struct target_type *t);\n\n \nstruct dm_arg_set {\n\tunsigned int argc;\n\tchar **argv;\n};\n\n \nstruct dm_arg {\n\tunsigned int min;\n\tunsigned int max;\n\tchar *error;\n};\n\n \nint dm_read_arg(const struct dm_arg *arg, struct dm_arg_set *arg_set,\n\t\tunsigned int *value, char **error);\n\n \nint dm_read_arg_group(const struct dm_arg *arg, struct dm_arg_set *arg_set,\n\t\t      unsigned int *num_args, char **error);\n\n \nconst char *dm_shift_arg(struct dm_arg_set *as);\n\n \nvoid dm_consume_args(struct dm_arg_set *as, unsigned int num_args);\n\n \n\n \n#define DM_ANY_MINOR (-1)\nint dm_create(int minor, struct mapped_device **md);\n\n \nstruct mapped_device *dm_get_md(dev_t dev);\nvoid dm_get(struct mapped_device *md);\nint dm_hold(struct mapped_device *md);\nvoid dm_put(struct mapped_device *md);\n\n \nvoid dm_set_mdptr(struct mapped_device *md, void *ptr);\nvoid *dm_get_mdptr(struct mapped_device *md);\n\n \nint dm_suspend(struct mapped_device *md, unsigned int suspend_flags);\nint dm_resume(struct mapped_device *md);\n\n \nuint32_t dm_get_event_nr(struct mapped_device *md);\nint dm_wait_event(struct mapped_device *md, int event_nr);\nuint32_t dm_next_uevent_seq(struct mapped_device *md);\nvoid dm_uevent_add(struct mapped_device *md, struct list_head *elist);\n\n \nconst char *dm_device_name(struct mapped_device *md);\nint dm_copy_name_and_uuid(struct mapped_device *md, char *name, char *uuid);\nstruct gendisk *dm_disk(struct mapped_device *md);\nint dm_suspended(struct dm_target *ti);\nint dm_post_suspending(struct dm_target *ti);\nint dm_noflush_suspending(struct dm_target *ti);\nvoid dm_accept_partial_bio(struct bio *bio, unsigned int n_sectors);\nvoid dm_submit_bio_remap(struct bio *clone, struct bio *tgt_clone);\nunion map_info *dm_get_rq_mapinfo(struct request *rq);\n\n#ifdef CONFIG_BLK_DEV_ZONED\nstruct dm_report_zones_args {\n\tstruct dm_target *tgt;\n\tsector_t next_sector;\n\n\tvoid *orig_data;\n\treport_zones_cb orig_cb;\n\tunsigned int zone_idx;\n\n\t \n\tsector_t start;\n};\nint dm_report_zones(struct block_device *bdev, sector_t start, sector_t sector,\n\t\t    struct dm_report_zones_args *args, unsigned int nr_zones);\n#endif  \n\n \nint __init dm_early_create(struct dm_ioctl *dmi,\n\t\t\t   struct dm_target_spec **spec_array,\n\t\t\t   char **target_params_array);\n\n \nint dm_get_geometry(struct mapped_device *md, struct hd_geometry *geo);\nint dm_set_geometry(struct mapped_device *md, struct hd_geometry *geo);\n\n \n\n \nint dm_table_create(struct dm_table **result, blk_mode_t mode,\n\t\t    unsigned int num_targets, struct mapped_device *md);\n\n \nint dm_table_add_target(struct dm_table *t, const char *type,\n\t\t\tsector_t start, sector_t len, char *params);\n\n \nvoid dm_table_set_type(struct dm_table *t, enum dm_queue_mode type);\n\n \nint dm_table_complete(struct dm_table *t);\n\n \nvoid dm_table_destroy(struct dm_table *t);\n\n \nint __must_check dm_set_target_max_io_len(struct dm_target *ti, sector_t len);\n\n \nstruct dm_table *dm_get_live_table(struct mapped_device *md, int *srcu_idx);\nvoid dm_put_live_table(struct mapped_device *md, int srcu_idx);\nvoid dm_sync_table(struct mapped_device *md);\n\n \nsector_t dm_table_get_size(struct dm_table *t);\nblk_mode_t dm_table_get_mode(struct dm_table *t);\nstruct mapped_device *dm_table_get_md(struct dm_table *t);\nconst char *dm_table_device_name(struct dm_table *t);\n\n \nvoid dm_table_event(struct dm_table *t);\n\n \nvoid dm_table_run_md_queue_async(struct dm_table *t);\n\n \nstruct dm_table *dm_swap_table(struct mapped_device *md,\n\t\t\t       struct dm_table *t);\n\n \nvoid dm_destroy_crypto_profile(struct blk_crypto_profile *profile);\n\n \n#define DM_NAME \"device-mapper\"\n\n#define DM_FMT(fmt) DM_NAME \": \" DM_MSG_PREFIX \": \" fmt \"\\n\"\n\n#define DMCRIT(fmt, ...) pr_crit(DM_FMT(fmt), ##__VA_ARGS__)\n\n#define DMERR(fmt, ...) pr_err(DM_FMT(fmt), ##__VA_ARGS__)\n#define DMERR_LIMIT(fmt, ...) pr_err_ratelimited(DM_FMT(fmt), ##__VA_ARGS__)\n#define DMWARN(fmt, ...) pr_warn(DM_FMT(fmt), ##__VA_ARGS__)\n#define DMWARN_LIMIT(fmt, ...) pr_warn_ratelimited(DM_FMT(fmt), ##__VA_ARGS__)\n#define DMINFO(fmt, ...) pr_info(DM_FMT(fmt), ##__VA_ARGS__)\n#define DMINFO_LIMIT(fmt, ...) pr_info_ratelimited(DM_FMT(fmt), ##__VA_ARGS__)\n\n#define DMDEBUG(fmt, ...) pr_debug(DM_FMT(fmt), ##__VA_ARGS__)\n#define DMDEBUG_LIMIT(fmt, ...) pr_debug_ratelimited(DM_FMT(fmt), ##__VA_ARGS__)\n\n#define DMEMIT(x...) (sz += ((sz >= maxlen) ? 0 : scnprintf(result + sz, maxlen - sz, x)))\n\n#define DMEMIT_TARGET_NAME_VERSION(y) \\\n\t\tDMEMIT(\"target_name=%s,target_version=%u.%u.%u\", \\\n\t\t       (y)->name, (y)->version[0], (y)->version[1], (y)->version[2])\n\n \n#define module_dm(name) \\\nstatic int __init dm_##name##_init(void) \\\n{ \\\n\treturn dm_register_target(&(name##_target)); \\\n} \\\nmodule_init(dm_##name##_init) \\\nstatic void __exit dm_##name##_exit(void) \\\n{ \\\n\tdm_unregister_target(&(name##_target)); \\\n} \\\nmodule_exit(dm_##name##_exit)\n\n \n#define DM_ENDIO_DONE\t\t0\n#define DM_ENDIO_INCOMPLETE\t1\n#define DM_ENDIO_REQUEUE\t2\n#define DM_ENDIO_DELAY_REQUEUE\t3\n\n \n#define DM_MAPIO_SUBMITTED\t0\n#define DM_MAPIO_REMAPPED\t1\n#define DM_MAPIO_REQUEUE\tDM_ENDIO_REQUEUE\n#define DM_MAPIO_DELAY_REQUEUE\tDM_ENDIO_DELAY_REQUEUE\n#define DM_MAPIO_KILL\t\t4\n\n#define dm_sector_div64(x, y)( \\\n{ \\\n\tu64 _res; \\\n\t(x) = div64_u64_rem(x, y, &_res); \\\n\t_res; \\\n} \\\n)\n\n \n#define dm_div_up(n, sz) (((n) + (sz) - 1) / (sz))\n\n#define dm_sector_div_up(n, sz) ( \\\n{ \\\n\tsector_t _r = ((n) + (sz) - 1); \\\n\tsector_div(_r, (sz)); \\\n\t_r; \\\n} \\\n)\n\n \n#define dm_round_up(n, sz) (dm_div_up((n), (sz)) * (sz))\n\n \n#define dm_target_offset(ti, sector) ((sector) - (ti)->begin)\n\nstatic inline sector_t to_sector(unsigned long long n)\n{\n\treturn (n >> SECTOR_SHIFT);\n}\n\nstatic inline unsigned long to_bytes(sector_t n)\n{\n\treturn (n << SECTOR_SHIFT);\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}