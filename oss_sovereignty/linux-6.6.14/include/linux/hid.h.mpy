{
  "module_name": "hid.h",
  "hash_id": "54ea306f598711b6be6eff808511e97a1e53a5a449a4bca005f7d0f6455dd1e9",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/hid.h",
  "human_readable_source": " \n \n \n#ifndef __HID_H\n#define __HID_H\n\n\n#include <linux/bitops.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/mod_devicetable.h>  \n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/input.h>\n#include <linux/semaphore.h>\n#include <linux/mutex.h>\n#include <linux/power_supply.h>\n#include <uapi/linux/hid.h>\n#include <linux/hid_bpf.h>\n\n \n\nstruct hid_item {\n\tunsigned  format;\n\t__u8      size;\n\t__u8      type;\n\t__u8      tag;\n\tunion {\n\t    __u8   u8;\n\t    __s8   s8;\n\t    __u16  u16;\n\t    __s16  s16;\n\t    __u32  u32;\n\t    __s32  s32;\n\t    __u8  *longdata;\n\t} data;\n};\n\n \n\n#define HID_ITEM_FORMAT_SHORT\t0\n#define HID_ITEM_FORMAT_LONG\t1\n\n \n\n#define HID_ITEM_TAG_LONG\t15\n\n \n\n#define HID_ITEM_TYPE_MAIN\t\t0\n#define HID_ITEM_TYPE_GLOBAL\t\t1\n#define HID_ITEM_TYPE_LOCAL\t\t2\n#define HID_ITEM_TYPE_RESERVED\t\t3\n\n \n\n#define HID_MAIN_ITEM_TAG_INPUT\t\t\t8\n#define HID_MAIN_ITEM_TAG_OUTPUT\t\t9\n#define HID_MAIN_ITEM_TAG_FEATURE\t\t11\n#define HID_MAIN_ITEM_TAG_BEGIN_COLLECTION\t10\n#define HID_MAIN_ITEM_TAG_END_COLLECTION\t12\n\n \n\n#define HID_MAIN_ITEM_CONSTANT\t\t0x001\n#define HID_MAIN_ITEM_VARIABLE\t\t0x002\n#define HID_MAIN_ITEM_RELATIVE\t\t0x004\n#define HID_MAIN_ITEM_WRAP\t\t0x008\n#define HID_MAIN_ITEM_NONLINEAR\t\t0x010\n#define HID_MAIN_ITEM_NO_PREFERRED\t0x020\n#define HID_MAIN_ITEM_NULL_STATE\t0x040\n#define HID_MAIN_ITEM_VOLATILE\t\t0x080\n#define HID_MAIN_ITEM_BUFFERED_BYTE\t0x100\n\n \n\n#define HID_COLLECTION_PHYSICAL\t\t0\n#define HID_COLLECTION_APPLICATION\t1\n#define HID_COLLECTION_LOGICAL\t\t2\n#define HID_COLLECTION_NAMED_ARRAY\t4\n\n \n\n#define HID_GLOBAL_ITEM_TAG_USAGE_PAGE\t\t0\n#define HID_GLOBAL_ITEM_TAG_LOGICAL_MINIMUM\t1\n#define HID_GLOBAL_ITEM_TAG_LOGICAL_MAXIMUM\t2\n#define HID_GLOBAL_ITEM_TAG_PHYSICAL_MINIMUM\t3\n#define HID_GLOBAL_ITEM_TAG_PHYSICAL_MAXIMUM\t4\n#define HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT\t5\n#define HID_GLOBAL_ITEM_TAG_UNIT\t\t6\n#define HID_GLOBAL_ITEM_TAG_REPORT_SIZE\t\t7\n#define HID_GLOBAL_ITEM_TAG_REPORT_ID\t\t8\n#define HID_GLOBAL_ITEM_TAG_REPORT_COUNT\t9\n#define HID_GLOBAL_ITEM_TAG_PUSH\t\t10\n#define HID_GLOBAL_ITEM_TAG_POP\t\t\t11\n\n \n\n#define HID_LOCAL_ITEM_TAG_USAGE\t\t0\n#define HID_LOCAL_ITEM_TAG_USAGE_MINIMUM\t1\n#define HID_LOCAL_ITEM_TAG_USAGE_MAXIMUM\t2\n#define HID_LOCAL_ITEM_TAG_DESIGNATOR_INDEX\t3\n#define HID_LOCAL_ITEM_TAG_DESIGNATOR_MINIMUM\t4\n#define HID_LOCAL_ITEM_TAG_DESIGNATOR_MAXIMUM\t5\n#define HID_LOCAL_ITEM_TAG_STRING_INDEX\t\t7\n#define HID_LOCAL_ITEM_TAG_STRING_MINIMUM\t8\n#define HID_LOCAL_ITEM_TAG_STRING_MAXIMUM\t9\n#define HID_LOCAL_ITEM_TAG_DELIMITER\t\t10\n\n \n\n#define HID_USAGE_PAGE\t\t0xffff0000\n\n#define HID_UP_UNDEFINED\t0x00000000\n#define HID_UP_GENDESK\t\t0x00010000\n#define HID_UP_SIMULATION\t0x00020000\n#define HID_UP_GENDEVCTRLS\t0x00060000\n#define HID_UP_KEYBOARD\t\t0x00070000\n#define HID_UP_LED\t\t0x00080000\n#define HID_UP_BUTTON\t\t0x00090000\n#define HID_UP_ORDINAL\t\t0x000a0000\n#define HID_UP_TELEPHONY\t0x000b0000\n#define HID_UP_CONSUMER\t\t0x000c0000\n#define HID_UP_DIGITIZER\t0x000d0000\n#define HID_UP_PID\t\t0x000f0000\n#define HID_UP_BATTERY\t\t0x00850000\n#define HID_UP_CAMERA\t\t0x00900000\n#define HID_UP_HPVENDOR         0xff7f0000\n#define HID_UP_HPVENDOR2        0xff010000\n#define HID_UP_MSVENDOR\t\t0xff000000\n#define HID_UP_CUSTOM\t\t0x00ff0000\n#define HID_UP_LOGIVENDOR\t0xffbc0000\n#define HID_UP_LOGIVENDOR2   0xff090000\n#define HID_UP_LOGIVENDOR3   0xff430000\n#define HID_UP_LNVENDOR\t\t0xffa00000\n#define HID_UP_SENSOR\t\t0x00200000\n#define HID_UP_ASUSVENDOR\t0xff310000\n#define HID_UP_GOOGLEVENDOR\t0xffd10000\n\n#define HID_USAGE\t\t0x0000ffff\n\n#define HID_GD_POINTER\t\t0x00010001\n#define HID_GD_MOUSE\t\t0x00010002\n#define HID_GD_JOYSTICK\t\t0x00010004\n#define HID_GD_GAMEPAD\t\t0x00010005\n#define HID_GD_KEYBOARD\t\t0x00010006\n#define HID_GD_KEYPAD\t\t0x00010007\n#define HID_GD_MULTIAXIS\t0x00010008\n \n#define HID_GD_WIRELESS_RADIO_CTLS\t0x0001000c\n \n#define HID_GD_SYSTEM_MULTIAXIS\t0x0001000e\n\n#define HID_GD_X\t\t0x00010030\n#define HID_GD_Y\t\t0x00010031\n#define HID_GD_Z\t\t0x00010032\n#define HID_GD_RX\t\t0x00010033\n#define HID_GD_RY\t\t0x00010034\n#define HID_GD_RZ\t\t0x00010035\n#define HID_GD_SLIDER\t\t0x00010036\n#define HID_GD_DIAL\t\t0x00010037\n#define HID_GD_WHEEL\t\t0x00010038\n#define HID_GD_HATSWITCH\t0x00010039\n#define HID_GD_BUFFER\t\t0x0001003a\n#define HID_GD_BYTECOUNT\t0x0001003b\n#define HID_GD_MOTION\t\t0x0001003c\n#define HID_GD_START\t\t0x0001003d\n#define HID_GD_SELECT\t\t0x0001003e\n#define HID_GD_VX\t\t0x00010040\n#define HID_GD_VY\t\t0x00010041\n#define HID_GD_VZ\t\t0x00010042\n#define HID_GD_VBRX\t\t0x00010043\n#define HID_GD_VBRY\t\t0x00010044\n#define HID_GD_VBRZ\t\t0x00010045\n#define HID_GD_VNO\t\t0x00010046\n#define HID_GD_FEATURE\t\t0x00010047\n#define HID_GD_RESOLUTION_MULTIPLIER\t0x00010048\n#define HID_GD_SYSTEM_CONTROL\t0x00010080\n#define HID_GD_UP\t\t0x00010090\n#define HID_GD_DOWN\t\t0x00010091\n#define HID_GD_RIGHT\t\t0x00010092\n#define HID_GD_LEFT\t\t0x00010093\n \n#define HID_GD_RFKILL_BTN\t0x000100c6\n#define HID_GD_RFKILL_LED\t0x000100c7\n#define HID_GD_RFKILL_SWITCH\t0x000100c8\n\n#define HID_DC_BATTERYSTRENGTH\t0x00060020\n\n#define HID_CP_CONSUMER_CONTROL\t0x000c0001\n#define HID_CP_AC_PAN\t\t0x000c0238\n\n#define HID_DG_DIGITIZER\t0x000d0001\n#define HID_DG_PEN\t\t0x000d0002\n#define HID_DG_LIGHTPEN\t\t0x000d0003\n#define HID_DG_TOUCHSCREEN\t0x000d0004\n#define HID_DG_TOUCHPAD\t\t0x000d0005\n#define HID_DG_WHITEBOARD\t0x000d0006\n#define HID_DG_STYLUS\t\t0x000d0020\n#define HID_DG_PUCK\t\t0x000d0021\n#define HID_DG_FINGER\t\t0x000d0022\n#define HID_DG_TIPPRESSURE\t0x000d0030\n#define HID_DG_BARRELPRESSURE\t0x000d0031\n#define HID_DG_INRANGE\t\t0x000d0032\n#define HID_DG_TOUCH\t\t0x000d0033\n#define HID_DG_UNTOUCH\t\t0x000d0034\n#define HID_DG_TAP\t\t0x000d0035\n#define HID_DG_TRANSDUCER_INDEX\t0x000d0038\n#define HID_DG_TABLETFUNCTIONKEY\t0x000d0039\n#define HID_DG_PROGRAMCHANGEKEY\t0x000d003a\n#define HID_DG_BATTERYSTRENGTH\t0x000d003b\n#define HID_DG_INVERT\t\t0x000d003c\n#define HID_DG_TILT_X\t\t0x000d003d\n#define HID_DG_TILT_Y\t\t0x000d003e\n#define HID_DG_TWIST\t\t0x000d0041\n#define HID_DG_TIPSWITCH\t0x000d0042\n#define HID_DG_TIPSWITCH2\t0x000d0043\n#define HID_DG_BARRELSWITCH\t0x000d0044\n#define HID_DG_ERASER\t\t0x000d0045\n#define HID_DG_TABLETPICK\t0x000d0046\n#define HID_DG_PEN_COLOR\t\t\t0x000d005c\n#define HID_DG_PEN_LINE_WIDTH\t\t\t0x000d005e\n#define HID_DG_PEN_LINE_STYLE\t\t\t0x000d0070\n#define HID_DG_PEN_LINE_STYLE_INK\t\t0x000d0072\n#define HID_DG_PEN_LINE_STYLE_PENCIL\t\t0x000d0073\n#define HID_DG_PEN_LINE_STYLE_HIGHLIGHTER\t0x000d0074\n#define HID_DG_PEN_LINE_STYLE_CHISEL_MARKER\t0x000d0075\n#define HID_DG_PEN_LINE_STYLE_BRUSH\t\t0x000d0076\n#define HID_DG_PEN_LINE_STYLE_NO_PREFERENCE\t0x000d0077\n\n#define HID_CP_CONSUMERCONTROL\t0x000c0001\n#define HID_CP_NUMERICKEYPAD\t0x000c0002\n#define HID_CP_PROGRAMMABLEBUTTONS\t0x000c0003\n#define HID_CP_MICROPHONE\t0x000c0004\n#define HID_CP_HEADPHONE\t0x000c0005\n#define HID_CP_GRAPHICEQUALIZER\t0x000c0006\n#define HID_CP_FUNCTIONBUTTONS\t0x000c0036\n#define HID_CP_SELECTION\t0x000c0080\n#define HID_CP_MEDIASELECTION\t0x000c0087\n#define HID_CP_SELECTDISC\t0x000c00ba\n#define HID_CP_VOLUMEUP\t\t0x000c00e9\n#define HID_CP_VOLUMEDOWN\t0x000c00ea\n#define HID_CP_PLAYBACKSPEED\t0x000c00f1\n#define HID_CP_PROXIMITY\t0x000c0109\n#define HID_CP_SPEAKERSYSTEM\t0x000c0160\n#define HID_CP_CHANNELLEFT\t0x000c0161\n#define HID_CP_CHANNELRIGHT\t0x000c0162\n#define HID_CP_CHANNELCENTER\t0x000c0163\n#define HID_CP_CHANNELFRONT\t0x000c0164\n#define HID_CP_CHANNELCENTERFRONT\t0x000c0165\n#define HID_CP_CHANNELSIDE\t0x000c0166\n#define HID_CP_CHANNELSURROUND\t0x000c0167\n#define HID_CP_CHANNELLOWFREQUENCYENHANCEMENT\t0x000c0168\n#define HID_CP_CHANNELTOP\t0x000c0169\n#define HID_CP_CHANNELUNKNOWN\t0x000c016a\n#define HID_CP_APPLICATIONLAUNCHBUTTONS\t0x000c0180\n#define HID_CP_GENERICGUIAPPLICATIONCONTROLS\t0x000c0200\n\n#define HID_DG_DEVICECONFIG\t0x000d000e\n#define HID_DG_DEVICESETTINGS\t0x000d0023\n#define HID_DG_AZIMUTH\t\t0x000d003f\n#define HID_DG_CONFIDENCE\t0x000d0047\n#define HID_DG_WIDTH\t\t0x000d0048\n#define HID_DG_HEIGHT\t\t0x000d0049\n#define HID_DG_CONTACTID\t0x000d0051\n#define HID_DG_INPUTMODE\t0x000d0052\n#define HID_DG_DEVICEINDEX\t0x000d0053\n#define HID_DG_CONTACTCOUNT\t0x000d0054\n#define HID_DG_CONTACTMAX\t0x000d0055\n#define HID_DG_SCANTIME\t\t0x000d0056\n#define HID_DG_SURFACESWITCH\t0x000d0057\n#define HID_DG_BUTTONSWITCH\t0x000d0058\n#define HID_DG_BUTTONTYPE\t0x000d0059\n#define HID_DG_BARRELSWITCH2\t0x000d005a\n#define HID_DG_TOOLSERIALNUMBER\t0x000d005b\n#define HID_DG_LATENCYMODE\t0x000d0060\n\n#define HID_BAT_ABSOLUTESTATEOFCHARGE\t0x00850065\n#define HID_BAT_CHARGING\t\t0x00850044\n\n#define HID_VD_ASUS_CUSTOM_MEDIA_KEYS\t0xff310076\n\n \n\n#define HID_CONNECT_HIDINPUT\t\tBIT(0)\n#define HID_CONNECT_HIDINPUT_FORCE\tBIT(1)\n#define HID_CONNECT_HIDRAW\t\tBIT(2)\n#define HID_CONNECT_HIDDEV\t\tBIT(3)\n#define HID_CONNECT_HIDDEV_FORCE\tBIT(4)\n#define HID_CONNECT_FF\t\t\tBIT(5)\n#define HID_CONNECT_DRIVER\t\tBIT(6)\n#define HID_CONNECT_DEFAULT\t(HID_CONNECT_HIDINPUT|HID_CONNECT_HIDRAW| \\\n\t\tHID_CONNECT_HIDDEV|HID_CONNECT_FF)\n\n \n\n \n#define MAX_USBHID_BOOT_QUIRKS 4\n\n \n \n#define HID_QUIRK_NOTOUCH\t\t\tBIT(1)\n#define HID_QUIRK_IGNORE\t\t\tBIT(2)\n#define HID_QUIRK_NOGET\t\t\t\tBIT(3)\n#define HID_QUIRK_HIDDEV_FORCE\t\t\tBIT(4)\n#define HID_QUIRK_BADPAD\t\t\tBIT(5)\n#define HID_QUIRK_MULTI_INPUT\t\t\tBIT(6)\n#define HID_QUIRK_HIDINPUT_FORCE\t\tBIT(7)\n \n \n#define HID_QUIRK_ALWAYS_POLL\t\t\tBIT(10)\n#define HID_QUIRK_INPUT_PER_APP\t\t\tBIT(11)\n#define HID_QUIRK_X_INVERT\t\t\tBIT(12)\n#define HID_QUIRK_Y_INVERT\t\t\tBIT(13)\n#define HID_QUIRK_SKIP_OUTPUT_REPORTS\t\tBIT(16)\n#define HID_QUIRK_SKIP_OUTPUT_REPORT_ID\t\tBIT(17)\n#define HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP\tBIT(18)\n#define HID_QUIRK_HAVE_SPECIAL_DRIVER\t\tBIT(19)\n#define HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE\tBIT(20)\n#define HID_QUIRK_NOINVERT\t\t\tBIT(21)\n#define HID_QUIRK_FULLSPEED_INTERVAL\t\tBIT(28)\n#define HID_QUIRK_NO_INIT_REPORTS\t\tBIT(29)\n#define HID_QUIRK_NO_IGNORE\t\t\tBIT(30)\n#define HID_QUIRK_NO_INPUT_SYNC\t\t\tBIT(31)\n\n \n#define HID_GROUP_GENERIC\t\t\t0x0001\n#define HID_GROUP_MULTITOUCH\t\t\t0x0002\n#define HID_GROUP_SENSOR_HUB\t\t\t0x0003\n#define HID_GROUP_MULTITOUCH_WIN_8\t\t0x0004\n\n \n#define HID_GROUP_RMI\t\t\t\t0x0100\n#define HID_GROUP_WACOM\t\t\t\t0x0101\n#define HID_GROUP_LOGITECH_DJ_DEVICE\t\t0x0102\n#define HID_GROUP_STEAM\t\t\t\t0x0103\n#define HID_GROUP_LOGITECH_27MHZ_DEVICE\t\t0x0104\n#define HID_GROUP_VIVALDI\t\t\t0x0105\n\n \n#define HID_REPORT_PROTOCOL\t1\n#define HID_BOOT_PROTOCOL\t0\n\n \n\nstruct hid_global {\n\tunsigned usage_page;\n\t__s32    logical_minimum;\n\t__s32    logical_maximum;\n\t__s32    physical_minimum;\n\t__s32    physical_maximum;\n\t__s32    unit_exponent;\n\tunsigned unit;\n\tunsigned report_id;\n\tunsigned report_size;\n\tunsigned report_count;\n};\n\n \n\n#define HID_MAX_USAGES\t\t\t12288\n#define HID_DEFAULT_NUM_COLLECTIONS\t16\n\nstruct hid_local {\n\tunsigned usage[HID_MAX_USAGES];  \n\tu8 usage_size[HID_MAX_USAGES];  \n\tunsigned collection_index[HID_MAX_USAGES];  \n\tunsigned usage_index;\n\tunsigned usage_minimum;\n\tunsigned delimiter_depth;\n\tunsigned delimiter_branch;\n};\n\n \n\nstruct hid_collection {\n\tint parent_idx;  \n\tunsigned type;\n\tunsigned usage;\n\tunsigned level;\n};\n\nstruct hid_usage {\n\tunsigned  hid;\t\t\t \n\tunsigned  collection_index;\t \n\tunsigned  usage_index;\t\t \n\t__s8\t  resolution_multiplier; \n\t \n\t__s8\t  wheel_factor;\t\t \n\t__u16     code;\t\t\t \n\t__u8      type;\t\t\t \n\t__s8\t  hat_min;\t\t \n\t__s8\t  hat_max;\t\t \n\t__s8\t  hat_dir;\t\t \n\t__s16\t  wheel_accumulated;\t \n};\n\nstruct hid_input;\n\nstruct hid_field {\n\tunsigned  physical;\t\t \n\tunsigned  logical;\t\t \n\tunsigned  application;\t\t \n\tstruct hid_usage *usage;\t \n\tunsigned  maxusage;\t\t \n\tunsigned  flags;\t\t \n\tunsigned  report_offset;\t \n\tunsigned  report_size;\t\t \n\tunsigned  report_count;\t\t \n\tunsigned  report_type;\t\t \n\t__s32    *value;\t\t \n\t__s32    *new_value;\t\t \n\t__s32    *usages_priorities;\t \n\t__s32     logical_minimum;\n\t__s32     logical_maximum;\n\t__s32     physical_minimum;\n\t__s32     physical_maximum;\n\t__s32     unit_exponent;\n\tunsigned  unit;\n\tbool      ignored;\t\t \n\tstruct hid_report *report;\t \n\tunsigned index;\t\t\t \n\t \n\tstruct hid_input *hidinput;\t \n\t__u16 dpad;\t\t\t \n\tunsigned int slot_idx;\t\t \n};\n\n#define HID_MAX_FIELDS 256\n\nstruct hid_field_entry {\n\tstruct list_head list;\n\tstruct hid_field *field;\n\tunsigned int index;\n\t__s32 priority;\n};\n\nstruct hid_report {\n\tstruct list_head list;\n\tstruct list_head hidinput_list;\n\tstruct list_head field_entry_list;\t\t \n\tunsigned int id;\t\t\t\t \n\tenum hid_report_type type;\t\t\t \n\tunsigned int application;\t\t\t \n\tstruct hid_field *field[HID_MAX_FIELDS];\t \n\tstruct hid_field_entry *field_entries;\t\t \n\tunsigned maxfield;\t\t\t\t \n\tunsigned size;\t\t\t\t\t \n\tstruct hid_device *device;\t\t\t \n\n\t \n\tbool tool_active;\t\t\t\t \n\tunsigned int tool;\t\t\t\t \n};\n\n#define HID_MAX_IDS 256\n\nstruct hid_report_enum {\n\tunsigned numbered;\n\tstruct list_head report_list;\n\tstruct hid_report *report_id_hash[HID_MAX_IDS];\n};\n\n#define HID_MIN_BUFFER_SIZE\t64\t\t \n#define HID_MAX_BUFFER_SIZE\t16384\t\t \n#define HID_CONTROL_FIFO_SIZE\t256\t\t \n#define HID_OUTPUT_FIFO_SIZE\t64\n\nstruct hid_control_fifo {\n\tunsigned char dir;\n\tstruct hid_report *report;\n\tchar *raw_report;\n};\n\nstruct hid_output_fifo {\n\tstruct hid_report *report;\n\tchar *raw_report;\n};\n\n#define HID_CLAIMED_INPUT\tBIT(0)\n#define HID_CLAIMED_HIDDEV\tBIT(1)\n#define HID_CLAIMED_HIDRAW\tBIT(2)\n#define HID_CLAIMED_DRIVER\tBIT(3)\n\n#define HID_STAT_ADDED\t\tBIT(0)\n#define HID_STAT_PARSED\t\tBIT(1)\n#define HID_STAT_DUP_DETECTED\tBIT(2)\n#define HID_STAT_REPROBED\tBIT(3)\n\nstruct hid_input {\n\tstruct list_head list;\n\tstruct hid_report *report;\n\tstruct input_dev *input;\n\tconst char *name;\n\tstruct list_head reports;\t \n\tunsigned int application;\t \n\tbool registered;\n};\n\nenum hid_type {\n\tHID_TYPE_OTHER = 0,\n\tHID_TYPE_USBMOUSE,\n\tHID_TYPE_USBNONE\n};\n\nenum hid_battery_status {\n\tHID_BATTERY_UNKNOWN = 0,\n\tHID_BATTERY_QUERIED,\t\t \n\tHID_BATTERY_REPORTED,\t\t \n};\n\nstruct hid_driver;\nstruct hid_ll_driver;\n\nstruct hid_device {\t\t\t\t\t\t\t \n\t__u8 *dev_rdesc;\n\tunsigned dev_rsize;\n\t__u8 *rdesc;\n\tunsigned rsize;\n\tstruct hid_collection *collection;\t\t\t\t \n\tunsigned collection_size;\t\t\t\t\t \n\tunsigned maxcollection;\t\t\t\t\t\t \n\tunsigned maxapplication;\t\t\t\t\t \n\t__u16 bus;\t\t\t\t\t\t\t \n\t__u16 group;\t\t\t\t\t\t\t \n\t__u32 vendor;\t\t\t\t\t\t\t \n\t__u32 product;\t\t\t\t\t\t\t \n\t__u32 version;\t\t\t\t\t\t\t \n\tenum hid_type type;\t\t\t\t\t\t \n\tunsigned country;\t\t\t\t\t\t \n\tstruct hid_report_enum report_enum[HID_REPORT_TYPES];\n\tstruct work_struct led_work;\t\t\t\t\t \n\n\tstruct semaphore driver_input_lock;\t\t\t\t \n\tstruct device dev;\t\t\t\t\t\t \n\tstruct hid_driver *driver;\n\tvoid *devres_group_id;\t\t\t\t\t\t \n\n\tconst struct hid_ll_driver *ll_driver;\n\tstruct mutex ll_open_lock;\n\tunsigned int ll_open_count;\n\n#ifdef CONFIG_HID_BATTERY_STRENGTH\n\t \n\tstruct power_supply *battery;\n\t__s32 battery_capacity;\n\t__s32 battery_min;\n\t__s32 battery_max;\n\t__s32 battery_report_type;\n\t__s32 battery_report_id;\n\t__s32 battery_charge_status;\n\tenum hid_battery_status battery_status;\n\tbool battery_avoid_query;\n\tktime_t battery_ratelimit_time;\n#endif\n\n\tunsigned long status;\t\t\t\t\t\t \n\tunsigned claimed;\t\t\t\t\t\t \n\tunsigned quirks;\t\t\t\t\t\t \n\tunsigned initial_quirks;\t\t\t\t\t \n\tbool io_started;\t\t\t\t\t\t \n\n\tstruct list_head inputs;\t\t\t\t\t \n\tvoid *hiddev;\t\t\t\t\t\t\t \n\tvoid *hidraw;\n\n\tchar name[128];\t\t\t\t\t\t\t \n\tchar phys[64];\t\t\t\t\t\t\t \n\tchar uniq[64];\t\t\t\t\t\t\t \n\n\tvoid *driver_data;\n\n\t \n\tint (*ff_init)(struct hid_device *);\n\n\t \n\tint (*hiddev_connect)(struct hid_device *, unsigned int);\n\tvoid (*hiddev_disconnect)(struct hid_device *);\n\tvoid (*hiddev_hid_event) (struct hid_device *, struct hid_field *field,\n\t\t\t\t  struct hid_usage *, __s32);\n\tvoid (*hiddev_report_event) (struct hid_device *, struct hid_report *);\n\n\t \n\tunsigned short debug;\n\tstruct dentry *debug_dir;\n\tstruct dentry *debug_rdesc;\n\tstruct dentry *debug_events;\n\tstruct list_head debug_list;\n\tspinlock_t  debug_list_lock;\n\twait_queue_head_t debug_wait;\n\tstruct kref\t\t\tref;\n\n\tunsigned int id;\t\t\t\t\t\t \n\n#ifdef CONFIG_BPF\n\tstruct hid_bpf bpf;\t\t\t\t\t\t \n#endif  \n};\n\nvoid hiddev_free(struct kref *ref);\n\n#define to_hid_device(pdev) \\\n\tcontainer_of(pdev, struct hid_device, dev)\n\nstatic inline void *hid_get_drvdata(struct hid_device *hdev)\n{\n\treturn dev_get_drvdata(&hdev->dev);\n}\n\nstatic inline void hid_set_drvdata(struct hid_device *hdev, void *data)\n{\n\tdev_set_drvdata(&hdev->dev, data);\n}\n\n#define HID_GLOBAL_STACK_SIZE 4\n#define HID_COLLECTION_STACK_SIZE 4\n\n#define HID_SCAN_FLAG_MT_WIN_8\t\t\tBIT(0)\n#define HID_SCAN_FLAG_VENDOR_SPECIFIC\t\tBIT(1)\n#define HID_SCAN_FLAG_GD_POINTER\t\tBIT(2)\n\nstruct hid_parser {\n\tstruct hid_global     global;\n\tstruct hid_global     global_stack[HID_GLOBAL_STACK_SIZE];\n\tunsigned int          global_stack_ptr;\n\tstruct hid_local      local;\n\tunsigned int         *collection_stack;\n\tunsigned int          collection_stack_ptr;\n\tunsigned int          collection_stack_size;\n\tstruct hid_device    *device;\n\tunsigned int          scan_flags;\n};\n\nstruct hid_class_descriptor {\n\t__u8  bDescriptorType;\n\t__le16 wDescriptorLength;\n} __attribute__ ((packed));\n\nstruct hid_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__le16 bcdHID;\n\t__u8  bCountryCode;\n\t__u8  bNumDescriptors;\n\n\tstruct hid_class_descriptor desc[1];\n} __attribute__ ((packed));\n\n#define HID_DEVICE(b, g, ven, prod)\t\t\t\t\t\\\n\t.bus = (b), .group = (g), .vendor = (ven), .product = (prod)\n#define HID_USB_DEVICE(ven, prod)\t\t\t\t\\\n\t.bus = BUS_USB, .vendor = (ven), .product = (prod)\n#define HID_BLUETOOTH_DEVICE(ven, prod)\t\t\t\t\t\\\n\t.bus = BUS_BLUETOOTH, .vendor = (ven), .product = (prod)\n#define HID_I2C_DEVICE(ven, prod)\t\t\t\t\\\n\t.bus = BUS_I2C, .vendor = (ven), .product = (prod)\n\n#define HID_REPORT_ID(rep) \\\n\t.report_type = (rep)\n#define HID_USAGE_ID(uhid, utype, ucode) \\\n\t.usage_hid = (uhid), .usage_type = (utype), .usage_code = (ucode)\n \n#define HID_TERMINATOR\t\t(HID_ANY_ID - 1)\n\nstruct hid_report_id {\n\t__u32 report_type;\n};\nstruct hid_usage_id {\n\t__u32 usage_hid;\n\t__u32 usage_type;\n\t__u32 usage_code;\n};\n\n \nstruct hid_driver {\n\tchar *name;\n\tconst struct hid_device_id *id_table;\n\n\tstruct list_head dyn_list;\n\tspinlock_t dyn_lock;\n\n\tbool (*match)(struct hid_device *dev, bool ignore_special_driver);\n\tint (*probe)(struct hid_device *dev, const struct hid_device_id *id);\n\tvoid (*remove)(struct hid_device *dev);\n\n\tconst struct hid_report_id *report_table;\n\tint (*raw_event)(struct hid_device *hdev, struct hid_report *report,\n\t\t\tu8 *data, int size);\n\tconst struct hid_usage_id *usage_table;\n\tint (*event)(struct hid_device *hdev, struct hid_field *field,\n\t\t\tstruct hid_usage *usage, __s32 value);\n\tvoid (*report)(struct hid_device *hdev, struct hid_report *report);\n\n\t__u8 *(*report_fixup)(struct hid_device *hdev, __u8 *buf,\n\t\t\tunsigned int *size);\n\n\tint (*input_mapping)(struct hid_device *hdev,\n\t\t\tstruct hid_input *hidinput, struct hid_field *field,\n\t\t\tstruct hid_usage *usage, unsigned long **bit, int *max);\n\tint (*input_mapped)(struct hid_device *hdev,\n\t\t\tstruct hid_input *hidinput, struct hid_field *field,\n\t\t\tstruct hid_usage *usage, unsigned long **bit, int *max);\n\tint (*input_configured)(struct hid_device *hdev,\n\t\t\t\tstruct hid_input *hidinput);\n\tvoid (*feature_mapping)(struct hid_device *hdev,\n\t\t\tstruct hid_field *field,\n\t\t\tstruct hid_usage *usage);\n#ifdef CONFIG_PM\n\tint (*suspend)(struct hid_device *hdev, pm_message_t message);\n\tint (*resume)(struct hid_device *hdev);\n\tint (*reset_resume)(struct hid_device *hdev);\n#endif\n \n\tstruct device_driver driver;\n};\n\n#define to_hid_driver(pdrv) \\\n\tcontainer_of(pdrv, struct hid_driver, driver)\n\n \nstruct hid_ll_driver {\n\tint (*start)(struct hid_device *hdev);\n\tvoid (*stop)(struct hid_device *hdev);\n\n\tint (*open)(struct hid_device *hdev);\n\tvoid (*close)(struct hid_device *hdev);\n\n\tint (*power)(struct hid_device *hdev, int level);\n\n\tint (*parse)(struct hid_device *hdev);\n\n\tvoid (*request)(struct hid_device *hdev,\n\t\t\tstruct hid_report *report, int reqtype);\n\n\tint (*wait)(struct hid_device *hdev);\n\n\tint (*raw_request) (struct hid_device *hdev, unsigned char reportnum,\n\t\t\t    __u8 *buf, size_t len, unsigned char rtype,\n\t\t\t    int reqtype);\n\n\tint (*output_report) (struct hid_device *hdev, __u8 *buf, size_t len);\n\n\tint (*idle)(struct hid_device *hdev, int report, int idle, int reqtype);\n\tbool (*may_wakeup)(struct hid_device *hdev);\n\n\tunsigned int max_buffer_size;\n};\n\nextern bool hid_is_usb(const struct hid_device *hdev);\n\n#define\tPM_HINT_FULLON\t1<<5\n#define PM_HINT_NORMAL\t1<<1\n\n \n \n#define IS_INPUT_APPLICATION(a) \\\n\t\t(((a >= HID_UP_GENDESK) && (a <= HID_GD_MULTIAXIS)) \\\n\t\t|| ((a >= HID_DG_DIGITIZER) && (a <= HID_DG_WHITEBOARD)) \\\n\t\t|| (a == HID_GD_SYSTEM_CONTROL) || (a == HID_CP_CONSUMER_CONTROL) \\\n\t\t|| (a == HID_GD_WIRELESS_RADIO_CTLS))\n\n \n\nextern bool hid_ignore(struct hid_device *);\nextern int hid_add_device(struct hid_device *);\nextern void hid_destroy_device(struct hid_device *);\n\nextern struct bus_type hid_bus_type;\n\nextern int __must_check __hid_register_driver(struct hid_driver *,\n\t\tstruct module *, const char *mod_name);\n\n \n#define hid_register_driver(driver) \\\n\t__hid_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)\n\nextern void hid_unregister_driver(struct hid_driver *);\n\n \n#define module_hid_driver(__hid_driver) \\\n\tmodule_driver(__hid_driver, hid_register_driver, \\\n\t\t      hid_unregister_driver)\n\nextern void hidinput_hid_event(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);\nextern void hidinput_report_event(struct hid_device *hid, struct hid_report *report);\nextern int hidinput_connect(struct hid_device *hid, unsigned int force);\nextern void hidinput_disconnect(struct hid_device *);\n\nint hid_set_field(struct hid_field *, unsigned, __s32);\nint hid_input_report(struct hid_device *hid, enum hid_report_type type, u8 *data, u32 size,\n\t\t     int interrupt);\nstruct hid_field *hidinput_get_led_field(struct hid_device *hid);\nunsigned int hidinput_count_leds(struct hid_device *hid);\n__s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code);\nvoid hid_output_report(struct hid_report *report, __u8 *data);\nint __hid_request(struct hid_device *hid, struct hid_report *rep, enum hid_class_request reqtype);\nu8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags);\nstruct hid_device *hid_allocate_device(void);\nstruct hid_report *hid_register_report(struct hid_device *device,\n\t\t\t\t       enum hid_report_type type, unsigned int id,\n\t\t\t\t       unsigned int application);\nint hid_parse_report(struct hid_device *hid, __u8 *start, unsigned size);\nstruct hid_report *hid_validate_values(struct hid_device *hid,\n\t\t\t\t       enum hid_report_type type, unsigned int id,\n\t\t\t\t       unsigned int field_index,\n\t\t\t\t       unsigned int report_counts);\n\nvoid hid_setup_resolution_multiplier(struct hid_device *hid);\nint hid_open_report(struct hid_device *device);\nint hid_check_keys_pressed(struct hid_device *hid);\nint hid_connect(struct hid_device *hid, unsigned int connect_mask);\nvoid hid_disconnect(struct hid_device *hid);\nbool hid_match_one_id(const struct hid_device *hdev,\n\t\t      const struct hid_device_id *id);\nconst struct hid_device_id *hid_match_id(const struct hid_device *hdev,\n\t\t\t\t\t const struct hid_device_id *id);\nconst struct hid_device_id *hid_match_device(struct hid_device *hdev,\n\t\t\t\t\t     struct hid_driver *hdrv);\nbool hid_compare_device_paths(struct hid_device *hdev_a,\n\t\t\t      struct hid_device *hdev_b, char separator);\ns32 hid_snto32(__u32 value, unsigned n);\n__u32 hid_field_extract(const struct hid_device *hid, __u8 *report,\n\t\t     unsigned offset, unsigned n);\n\n#ifdef CONFIG_PM\nint hid_driver_suspend(struct hid_device *hdev, pm_message_t state);\nint hid_driver_reset_resume(struct hid_device *hdev);\nint hid_driver_resume(struct hid_device *hdev);\n#else\nstatic inline int hid_driver_suspend(struct hid_device *hdev, pm_message_t state) { return 0; }\nstatic inline int hid_driver_reset_resume(struct hid_device *hdev) { return 0; }\nstatic inline int hid_driver_resume(struct hid_device *hdev) { return 0; }\n#endif\n\n \nstatic inline void hid_device_io_start(struct hid_device *hid) {\n\tif (hid->io_started) {\n\t\tdev_warn(&hid->dev, \"io already started\\n\");\n\t\treturn;\n\t}\n\thid->io_started = true;\n\tup(&hid->driver_input_lock);\n}\n\n \nstatic inline void hid_device_io_stop(struct hid_device *hid) {\n\tif (!hid->io_started) {\n\t\tdev_warn(&hid->dev, \"io already stopped\\n\");\n\t\treturn;\n\t}\n\thid->io_started = false;\n\tdown(&hid->driver_input_lock);\n}\n\n \nstatic inline void hid_map_usage(struct hid_input *hidinput,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max,\n\t\t__u8 type, unsigned int c)\n{\n\tstruct input_dev *input = hidinput->input;\n\tunsigned long *bmap = NULL;\n\tunsigned int limit = 0;\n\n\tswitch (type) {\n\tcase EV_ABS:\n\t\tbmap = input->absbit;\n\t\tlimit = ABS_MAX;\n\t\tbreak;\n\tcase EV_REL:\n\t\tbmap = input->relbit;\n\t\tlimit = REL_MAX;\n\t\tbreak;\n\tcase EV_KEY:\n\t\tbmap = input->keybit;\n\t\tlimit = KEY_MAX;\n\t\tbreak;\n\tcase EV_LED:\n\t\tbmap = input->ledbit;\n\t\tlimit = LED_MAX;\n\t\tbreak;\n\tcase EV_MSC:\n\t\tbmap = input->mscbit;\n\t\tlimit = MSC_MAX;\n\t\tbreak;\n\t}\n\n\tif (unlikely(c > limit || !bmap)) {\n\t\tpr_warn_ratelimited(\"%s: Invalid code %d type %d\\n\",\n\t\t\t\t    input->name, c, type);\n\t\t*bit = NULL;\n\t\treturn;\n\t}\n\n\tusage->type = type;\n\tusage->code = c;\n\t*max = limit;\n\t*bit = bmap;\n}\n\n \nstatic inline void hid_map_usage_clear(struct hid_input *hidinput,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max,\n\t\t__u8 type, __u16 c)\n{\n\thid_map_usage(hidinput, usage, bit, max, type, c);\n\tif (*bit)\n\t\tclear_bit(usage->code, *bit);\n}\n\n \nstatic inline int __must_check hid_parse(struct hid_device *hdev)\n{\n\treturn hid_open_report(hdev);\n}\n\nint __must_check hid_hw_start(struct hid_device *hdev,\n\t\t\t      unsigned int connect_mask);\nvoid hid_hw_stop(struct hid_device *hdev);\nint __must_check hid_hw_open(struct hid_device *hdev);\nvoid hid_hw_close(struct hid_device *hdev);\nvoid hid_hw_request(struct hid_device *hdev,\n\t\t    struct hid_report *report, enum hid_class_request reqtype);\nint hid_hw_raw_request(struct hid_device *hdev,\n\t\t       unsigned char reportnum, __u8 *buf,\n\t\t       size_t len, enum hid_report_type rtype,\n\t\t       enum hid_class_request reqtype);\nint hid_hw_output_report(struct hid_device *hdev, __u8 *buf, size_t len);\n\n \n\nstatic inline int hid_hw_power(struct hid_device *hdev, int level)\n{\n\treturn hdev->ll_driver->power ? hdev->ll_driver->power(hdev, level) : 0;\n}\n\n\n \nstatic inline int hid_hw_idle(struct hid_device *hdev, int report, int idle,\n\t\tenum hid_class_request reqtype)\n{\n\tif (hdev->ll_driver->idle)\n\t\treturn hdev->ll_driver->idle(hdev, report, idle, reqtype);\n\n\treturn 0;\n}\n\n \nstatic inline bool hid_hw_may_wakeup(struct hid_device *hdev)\n{\n\tif (hdev->ll_driver->may_wakeup)\n\t\treturn hdev->ll_driver->may_wakeup(hdev);\n\n\tif (hdev->dev.parent)\n\t\treturn device_may_wakeup(hdev->dev.parent);\n\n\treturn false;\n}\n\n \nstatic inline void hid_hw_wait(struct hid_device *hdev)\n{\n\tif (hdev->ll_driver->wait)\n\t\thdev->ll_driver->wait(hdev);\n}\n\n \nstatic inline u32 hid_report_len(struct hid_report *report)\n{\n\treturn DIV_ROUND_UP(report->size, 8) + (report->id > 0);\n}\n\nint hid_report_raw_event(struct hid_device *hid, enum hid_report_type type, u8 *data, u32 size,\n\t\t\t int interrupt);\n\n \nunsigned long hid_lookup_quirk(const struct hid_device *hdev);\nint hid_quirks_init(char **quirks_param, __u16 bus, int count);\nvoid hid_quirks_exit(__u16 bus);\n\n#ifdef CONFIG_HID_PID\nint hid_pidff_init(struct hid_device *hid);\n#else\n#define hid_pidff_init NULL\n#endif\n\n#define dbg_hid(fmt, ...) pr_debug(\"%s: \" fmt, __FILE__, ##__VA_ARGS__)\n\n#define hid_err(hid, fmt, ...)\t\t\t\t\\\n\tdev_err(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_notice(hid, fmt, ...)\t\t\t\\\n\tdev_notice(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_warn(hid, fmt, ...)\t\t\t\t\\\n\tdev_warn(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_info(hid, fmt, ...)\t\t\t\t\\\n\tdev_info(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_dbg(hid, fmt, ...)\t\t\t\t\\\n\tdev_dbg(&(hid)->dev, fmt, ##__VA_ARGS__)\n\n#define hid_err_once(hid, fmt, ...)\t\t\t\\\n\tdev_err_once(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_notice_once(hid, fmt, ...)\t\t\t\\\n\tdev_notice_once(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_warn_once(hid, fmt, ...)\t\t\t\\\n\tdev_warn_once(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_info_once(hid, fmt, ...)\t\t\t\\\n\tdev_info_once(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_dbg_once(hid, fmt, ...)\t\t\t\\\n\tdev_dbg_once(&(hid)->dev, fmt, ##__VA_ARGS__)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}