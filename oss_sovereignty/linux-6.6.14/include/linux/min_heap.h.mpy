{
  "module_name": "min_heap.h",
  "hash_id": "91b5ed319f9ca04805c373f5d566301968c141e78fe66728246fc7ba52fbd1c5",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/min_heap.h",
  "human_readable_source": " \n#ifndef _LINUX_MIN_HEAP_H\n#define _LINUX_MIN_HEAP_H\n\n#include <linux/bug.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n \nstruct min_heap {\n\tvoid *data;\n\tint nr;\n\tint size;\n};\n\n \nstruct min_heap_callbacks {\n\tint elem_size;\n\tbool (*less)(const void *lhs, const void *rhs);\n\tvoid (*swp)(void *lhs, void *rhs);\n};\n\n \nstatic __always_inline\nvoid min_heapify(struct min_heap *heap, int pos,\n\t\tconst struct min_heap_callbacks *func)\n{\n\tvoid *left, *right, *parent, *smallest;\n\tvoid *data = heap->data;\n\n\tfor (;;) {\n\t\tif (pos * 2 + 1 >= heap->nr)\n\t\t\tbreak;\n\n\t\tleft = data + ((pos * 2 + 1) * func->elem_size);\n\t\tparent = data + (pos * func->elem_size);\n\t\tsmallest = parent;\n\t\tif (func->less(left, smallest))\n\t\t\tsmallest = left;\n\n\t\tif (pos * 2 + 2 < heap->nr) {\n\t\t\tright = data + ((pos * 2 + 2) * func->elem_size);\n\t\t\tif (func->less(right, smallest))\n\t\t\t\tsmallest = right;\n\t\t}\n\t\tif (smallest == parent)\n\t\t\tbreak;\n\t\tfunc->swp(smallest, parent);\n\t\tif (smallest == left)\n\t\t\tpos = (pos * 2) + 1;\n\t\telse\n\t\t\tpos = (pos * 2) + 2;\n\t}\n}\n\n \nstatic __always_inline\nvoid min_heapify_all(struct min_heap *heap,\n\t\tconst struct min_heap_callbacks *func)\n{\n\tint i;\n\n\tfor (i = heap->nr / 2; i >= 0; i--)\n\t\tmin_heapify(heap, i, func);\n}\n\n \nstatic __always_inline\nvoid min_heap_pop(struct min_heap *heap,\n\t\tconst struct min_heap_callbacks *func)\n{\n\tvoid *data = heap->data;\n\n\tif (WARN_ONCE(heap->nr <= 0, \"Popping an empty heap\"))\n\t\treturn;\n\n\t \n\theap->nr--;\n\tmemcpy(data, data + (heap->nr * func->elem_size), func->elem_size);\n\tmin_heapify(heap, 0, func);\n}\n\n \nstatic __always_inline\nvoid min_heap_pop_push(struct min_heap *heap,\n\t\tconst void *element,\n\t\tconst struct min_heap_callbacks *func)\n{\n\tmemcpy(heap->data, element, func->elem_size);\n\tmin_heapify(heap, 0, func);\n}\n\n \nstatic __always_inline\nvoid min_heap_push(struct min_heap *heap, const void *element,\n\t\tconst struct min_heap_callbacks *func)\n{\n\tvoid *data = heap->data;\n\tvoid *child, *parent;\n\tint pos;\n\n\tif (WARN_ONCE(heap->nr >= heap->size, \"Pushing on a full heap\"))\n\t\treturn;\n\n\t \n\tpos = heap->nr;\n\tmemcpy(data + (pos * func->elem_size), element, func->elem_size);\n\theap->nr++;\n\n\t \n\tfor (; pos > 0; pos = (pos - 1) / 2) {\n\t\tchild = data + (pos * func->elem_size);\n\t\tparent = data + ((pos - 1) / 2) * func->elem_size;\n\t\tif (func->less(parent, child))\n\t\t\tbreak;\n\t\tfunc->swp(parent, child);\n\t}\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}