{
  "module_name": "module.h",
  "hash_id": "c21d1e6a597388f30a0670fedf2e564b02e04b38bdce65d71e9b44ffdbfba18d",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/module.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_MODULE_H\n#define _LINUX_MODULE_H\n\n#include <linux/list.h>\n#include <linux/stat.h>\n#include <linux/buildid.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/kmod.h>\n#include <linux/init.h>\n#include <linux/elf.h>\n#include <linux/stringify.h>\n#include <linux/kobject.h>\n#include <linux/moduleparam.h>\n#include <linux/jump_label.h>\n#include <linux/export.h>\n#include <linux/rbtree_latch.h>\n#include <linux/error-injection.h>\n#include <linux/tracepoint-defs.h>\n#include <linux/srcu.h>\n#include <linux/static_call_types.h>\n#include <linux/dynamic_debug.h>\n\n#include <linux/percpu.h>\n#include <asm/module.h>\n\n#define MODULE_NAME_LEN MAX_PARAM_PREFIX_LEN\n\nstruct modversion_info {\n\tunsigned long crc;\n\tchar name[MODULE_NAME_LEN];\n};\n\nstruct module;\nstruct exception_table_entry;\n\nstruct module_kobject {\n\tstruct kobject kobj;\n\tstruct module *mod;\n\tstruct kobject *drivers_dir;\n\tstruct module_param_attrs *mp;\n\tstruct completion *kobj_completion;\n} __randomize_layout;\n\nstruct module_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct module_attribute *, struct module_kobject *,\n\t\t\tchar *);\n\tssize_t (*store)(struct module_attribute *, struct module_kobject *,\n\t\t\t const char *, size_t count);\n\tvoid (*setup)(struct module *, const char *);\n\tint (*test)(struct module *);\n\tvoid (*free)(struct module *);\n};\n\nstruct module_version_attribute {\n\tstruct module_attribute mattr;\n\tconst char *module_name;\n\tconst char *version;\n};\n\nextern ssize_t __modver_version_show(struct module_attribute *,\n\t\t\t\t     struct module_kobject *, char *);\n\nextern struct module_attribute module_uevent;\n\n \nextern int init_module(void);\nextern void cleanup_module(void);\n\n#ifndef MODULE\n \n#define module_init(x)\t__initcall(x);\n\n \n#define module_exit(x)\t__exitcall(x);\n\n#else  \n\n \n#define early_initcall(fn)\t\tmodule_init(fn)\n#define core_initcall(fn)\t\tmodule_init(fn)\n#define core_initcall_sync(fn)\t\tmodule_init(fn)\n#define postcore_initcall(fn)\t\tmodule_init(fn)\n#define postcore_initcall_sync(fn)\tmodule_init(fn)\n#define arch_initcall(fn)\t\tmodule_init(fn)\n#define subsys_initcall(fn)\t\tmodule_init(fn)\n#define subsys_initcall_sync(fn)\tmodule_init(fn)\n#define fs_initcall(fn)\t\t\tmodule_init(fn)\n#define fs_initcall_sync(fn)\t\tmodule_init(fn)\n#define rootfs_initcall(fn)\t\tmodule_init(fn)\n#define device_initcall(fn)\t\tmodule_init(fn)\n#define device_initcall_sync(fn)\tmodule_init(fn)\n#define late_initcall(fn)\t\tmodule_init(fn)\n#define late_initcall_sync(fn)\t\tmodule_init(fn)\n\n#define console_initcall(fn)\t\tmodule_init(fn)\n\n \n#define module_init(initfn)\t\t\t\t\t\\\n\tstatic inline initcall_t __maybe_unused __inittest(void)\t\t\\\n\t{ return initfn; }\t\t\t\t\t\\\n\tint init_module(void) __copy(initfn)\t\t\t\\\n\t\t__attribute__((alias(#initfn)));\t\t\\\n\t___ADDRESSABLE(init_module, __initdata);\n\n \n#define module_exit(exitfn)\t\t\t\t\t\\\n\tstatic inline exitcall_t __maybe_unused __exittest(void)\t\t\\\n\t{ return exitfn; }\t\t\t\t\t\\\n\tvoid cleanup_module(void) __copy(exitfn)\t\t\\\n\t\t__attribute__((alias(#exitfn)));\t\t\\\n\t___ADDRESSABLE(cleanup_module, __exitdata);\n\n#endif\n\n \n#ifdef CONFIG_MODULES\n#define __init_or_module\n#define __initdata_or_module\n#define __initconst_or_module\n#define __INIT_OR_MODULE\t.text\n#define __INITDATA_OR_MODULE\t.data\n#define __INITRODATA_OR_MODULE\t.section \".rodata\",\"a\",%progbits\n#else\n#define __init_or_module __init\n#define __initdata_or_module __initdata\n#define __initconst_or_module __initconst\n#define __INIT_OR_MODULE __INIT\n#define __INITDATA_OR_MODULE __INITDATA\n#define __INITRODATA_OR_MODULE __INITRODATA\n#endif  \n\n \n#define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)\n\n \n#define MODULE_ALIAS(_alias) MODULE_INFO(alias, _alias)\n\n \n#define MODULE_SOFTDEP(_softdep) MODULE_INFO(softdep, _softdep)\n\n \n#ifdef MODULE\n#define MODULE_FILE\n#else\n#define MODULE_FILE\tMODULE_INFO(file, KBUILD_MODFILE);\n#endif\n\n \n#define MODULE_LICENSE(_license) MODULE_FILE MODULE_INFO(license, _license)\n\n \n#define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)\n\n \n#define MODULE_DESCRIPTION(_description) MODULE_INFO(description, _description)\n\n#ifdef MODULE\n \n#define MODULE_DEVICE_TABLE(type, name)\t\t\t\t\t\\\nextern typeof(name) __mod_##type##__##name##_device_table\t\t\\\n  __attribute__ ((unused, alias(__stringify(name))))\n#else   \n#define MODULE_DEVICE_TABLE(type, name)\n#endif\n\n \n\n#if defined(MODULE) || !defined(CONFIG_SYSFS)\n#define MODULE_VERSION(_version) MODULE_INFO(version, _version)\n#else\n#define MODULE_VERSION(_version)\t\t\t\t\t\\\n\tMODULE_INFO(version, _version);\t\t\t\t\t\\\n\tstatic struct module_version_attribute __modver_attr\t\t\\\n\t\t__used __section(\"__modver\")\t\t\t\t\\\n\t\t__aligned(__alignof__(struct module_version_attribute)) \\\n\t\t= {\t\t\t\t\t\t\t\\\n\t\t\t.mattr\t= {\t\t\t\t\t\\\n\t\t\t\t.attr\t= {\t\t\t\t\\\n\t\t\t\t\t.name\t= \"version\",\t\t\\\n\t\t\t\t\t.mode\t= S_IRUGO,\t\t\\\n\t\t\t\t},\t\t\t\t\t\\\n\t\t\t\t.show\t= __modver_version_show,\t\\\n\t\t\t},\t\t\t\t\t\t\\\n\t\t\t.module_name\t= KBUILD_MODNAME,\t\t\\\n\t\t\t.version\t= _version,\t\t\t\\\n\t\t}\n#endif\n\n \n#define MODULE_FIRMWARE(_firmware) MODULE_INFO(firmware, _firmware)\n\n#define MODULE_IMPORT_NS(ns)\tMODULE_INFO(import_ns, __stringify(ns))\n\nstruct notifier_block;\n\n#ifdef CONFIG_MODULES\n\nextern int modules_disabled;  \n \nvoid *__symbol_get(const char *symbol);\nvoid *__symbol_get_gpl(const char *symbol);\n#define symbol_get(x) ((typeof(&x))(__symbol_get(__stringify(x))))\n\n \nstruct module_use {\n\tstruct list_head source_list;\n\tstruct list_head target_list;\n\tstruct module *source, *target;\n};\n\nenum module_state {\n\tMODULE_STATE_LIVE,\t \n\tMODULE_STATE_COMING,\t \n\tMODULE_STATE_GOING,\t \n\tMODULE_STATE_UNFORMED,\t \n};\n\nstruct mod_tree_node {\n\tstruct module *mod;\n\tstruct latch_tree_node node;\n};\n\nenum mod_mem_type {\n\tMOD_TEXT = 0,\n\tMOD_DATA,\n\tMOD_RODATA,\n\tMOD_RO_AFTER_INIT,\n\tMOD_INIT_TEXT,\n\tMOD_INIT_DATA,\n\tMOD_INIT_RODATA,\n\n\tMOD_MEM_NUM_TYPES,\n\tMOD_INVALID = -1,\n};\n\n#define mod_mem_type_is_init(type)\t\\\n\t((type) == MOD_INIT_TEXT ||\t\\\n\t (type) == MOD_INIT_DATA ||\t\\\n\t (type) == MOD_INIT_RODATA)\n\n#define mod_mem_type_is_core(type) (!mod_mem_type_is_init(type))\n\n#define mod_mem_type_is_text(type)\t\\\n\t ((type) == MOD_TEXT ||\t\t\\\n\t  (type) == MOD_INIT_TEXT)\n\n#define mod_mem_type_is_data(type) (!mod_mem_type_is_text(type))\n\n#define mod_mem_type_is_core_data(type)\t\\\n\t(mod_mem_type_is_core(type) &&\t\\\n\t mod_mem_type_is_data(type))\n\n#define for_each_mod_mem_type(type)\t\t\t\\\n\tfor (enum mod_mem_type (type) = 0;\t\t\\\n\t     (type) < MOD_MEM_NUM_TYPES; (type)++)\n\n#define for_class_mod_mem_type(type, class)\t\t\\\n\tfor_each_mod_mem_type(type)\t\t\t\\\n\t\tif (mod_mem_type_is_##class(type))\n\nstruct module_memory {\n\tvoid *base;\n\tunsigned int size;\n\n#ifdef CONFIG_MODULES_TREE_LOOKUP\n\tstruct mod_tree_node mtn;\n#endif\n};\n\n#ifdef CONFIG_MODULES_TREE_LOOKUP\n \n#define __module_memory_align ____cacheline_aligned\n#else\n#define __module_memory_align\n#endif\n\nstruct mod_kallsyms {\n\tElf_Sym *symtab;\n\tunsigned int num_symtab;\n\tchar *strtab;\n\tchar *typetab;\n};\n\n#ifdef CONFIG_LIVEPATCH\n \nstruct klp_modinfo {\n\tElf_Ehdr hdr;\n\tElf_Shdr *sechdrs;\n\tchar *secstrings;\n\tunsigned int symndx;\n};\n#endif\n\nstruct module {\n\tenum module_state state;\n\n\t \n\tstruct list_head list;\n\n\t \n\tchar name[MODULE_NAME_LEN];\n\n#ifdef CONFIG_STACKTRACE_BUILD_ID\n\t \n\tunsigned char build_id[BUILD_ID_SIZE_MAX];\n#endif\n\n\t \n\tstruct module_kobject mkobj;\n\tstruct module_attribute *modinfo_attrs;\n\tconst char *version;\n\tconst char *srcversion;\n\tstruct kobject *holders_dir;\n\n\t \n\tconst struct kernel_symbol *syms;\n\tconst s32 *crcs;\n\tunsigned int num_syms;\n\n#ifdef CONFIG_ARCH_USES_CFI_TRAPS\n\ts32 *kcfi_traps;\n\ts32 *kcfi_traps_end;\n#endif\n\n\t \n#ifdef CONFIG_SYSFS\n\tstruct mutex param_lock;\n#endif\n\tstruct kernel_param *kp;\n\tunsigned int num_kp;\n\n\t \n\tunsigned int num_gpl_syms;\n\tconst struct kernel_symbol *gpl_syms;\n\tconst s32 *gpl_crcs;\n\tbool using_gplonly_symbols;\n\n#ifdef CONFIG_MODULE_SIG\n\t \n\tbool sig_ok;\n#endif\n\n\tbool async_probe_requested;\n\n\t \n\tunsigned int num_exentries;\n\tstruct exception_table_entry *extable;\n\n\t \n\tint (*init)(void);\n\n\tstruct module_memory mem[MOD_MEM_NUM_TYPES] __module_memory_align;\n\n\t \n\tstruct mod_arch_specific arch;\n\n\tunsigned long taints;\t \n\n#ifdef CONFIG_GENERIC_BUG\n\t \n\tunsigned num_bugs;\n\tstruct list_head bug_list;\n\tstruct bug_entry *bug_table;\n#endif\n\n#ifdef CONFIG_KALLSYMS\n\t \n\tstruct mod_kallsyms __rcu *kallsyms;\n\tstruct mod_kallsyms core_kallsyms;\n\n\t \n\tstruct module_sect_attrs *sect_attrs;\n\n\t \n\tstruct module_notes_attrs *notes_attrs;\n#endif\n\n\t \n\tchar *args;\n\n#ifdef CONFIG_SMP\n\t \n\tvoid __percpu *percpu;\n\tunsigned int percpu_size;\n#endif\n\tvoid *noinstr_text_start;\n\tunsigned int noinstr_text_size;\n\n#ifdef CONFIG_TRACEPOINTS\n\tunsigned int num_tracepoints;\n\ttracepoint_ptr_t *tracepoints_ptrs;\n#endif\n#ifdef CONFIG_TREE_SRCU\n\tunsigned int num_srcu_structs;\n\tstruct srcu_struct **srcu_struct_ptrs;\n#endif\n#ifdef CONFIG_BPF_EVENTS\n\tunsigned int num_bpf_raw_events;\n\tstruct bpf_raw_event_map *bpf_raw_events;\n#endif\n#ifdef CONFIG_DEBUG_INFO_BTF_MODULES\n\tunsigned int btf_data_size;\n\tvoid *btf_data;\n#endif\n#ifdef CONFIG_JUMP_LABEL\n\tstruct jump_entry *jump_entries;\n\tunsigned int num_jump_entries;\n#endif\n#ifdef CONFIG_TRACING\n\tunsigned int num_trace_bprintk_fmt;\n\tconst char **trace_bprintk_fmt_start;\n#endif\n#ifdef CONFIG_EVENT_TRACING\n\tstruct trace_event_call **trace_events;\n\tunsigned int num_trace_events;\n\tstruct trace_eval_map **trace_evals;\n\tunsigned int num_trace_evals;\n#endif\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\n\tunsigned int num_ftrace_callsites;\n\tunsigned long *ftrace_callsites;\n#endif\n#ifdef CONFIG_KPROBES\n\tvoid *kprobes_text_start;\n\tunsigned int kprobes_text_size;\n\tunsigned long *kprobe_blacklist;\n\tunsigned int num_kprobe_blacklist;\n#endif\n#ifdef CONFIG_HAVE_STATIC_CALL_INLINE\n\tint num_static_call_sites;\n\tstruct static_call_site *static_call_sites;\n#endif\n#if IS_ENABLED(CONFIG_KUNIT)\n\tint num_kunit_suites;\n\tstruct kunit_suite **kunit_suites;\n#endif\n\n\n#ifdef CONFIG_LIVEPATCH\n\tbool klp;  \n\tbool klp_alive;\n\n\t \n\tstruct klp_modinfo *klp_info;\n#endif\n\n#ifdef CONFIG_PRINTK_INDEX\n\tunsigned int printk_index_size;\n\tstruct pi_entry **printk_index_start;\n#endif\n\n#ifdef CONFIG_MODULE_UNLOAD\n\t \n\tstruct list_head source_list;\n\t \n\tstruct list_head target_list;\n\n\t \n\tvoid (*exit)(void);\n\n\tatomic_t refcnt;\n#endif\n\n#ifdef CONFIG_CONSTRUCTORS\n\t \n\tctor_fn_t *ctors;\n\tunsigned int num_ctors;\n#endif\n\n#ifdef CONFIG_FUNCTION_ERROR_INJECTION\n\tstruct error_injection_entry *ei_funcs;\n\tunsigned int num_ei_funcs;\n#endif\n#ifdef CONFIG_DYNAMIC_DEBUG_CORE\n\tstruct _ddebug_info dyndbg_info;\n#endif\n} ____cacheline_aligned __randomize_layout;\n#ifndef MODULE_ARCH_INIT\n#define MODULE_ARCH_INIT {}\n#endif\n\n#ifndef HAVE_ARCH_KALLSYMS_SYMBOL_VALUE\nstatic inline unsigned long kallsyms_symbol_value(const Elf_Sym *sym)\n{\n\treturn sym->st_value;\n}\n#endif\n\n \nstatic inline bool module_is_live(struct module *mod)\n{\n\treturn mod->state != MODULE_STATE_GOING;\n}\n\nstruct module *__module_text_address(unsigned long addr);\nstruct module *__module_address(unsigned long addr);\nbool is_module_address(unsigned long addr);\nbool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr);\nbool is_module_percpu_address(unsigned long addr);\nbool is_module_text_address(unsigned long addr);\n\nstatic inline bool within_module_mem_type(unsigned long addr,\n\t\t\t\t\t  const struct module *mod,\n\t\t\t\t\t  enum mod_mem_type type)\n{\n\tunsigned long base, size;\n\n\tbase = (unsigned long)mod->mem[type].base;\n\tsize = mod->mem[type].size;\n\treturn addr - base < size;\n}\n\nstatic inline bool within_module_core(unsigned long addr,\n\t\t\t\t      const struct module *mod)\n{\n\tfor_class_mod_mem_type(type, core) {\n\t\tif (within_module_mem_type(addr, mod, type))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline bool within_module_init(unsigned long addr,\n\t\t\t\t      const struct module *mod)\n{\n\tfor_class_mod_mem_type(type, init) {\n\t\tif (within_module_mem_type(addr, mod, type))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline bool within_module(unsigned long addr, const struct module *mod)\n{\n\treturn within_module_init(addr, mod) || within_module_core(addr, mod);\n}\n\n \nstruct module *find_module(const char *name);\n\nextern void __noreturn __module_put_and_kthread_exit(struct module *mod,\n\t\t\tlong code);\n#define module_put_and_kthread_exit(code) __module_put_and_kthread_exit(THIS_MODULE, code)\n\n#ifdef CONFIG_MODULE_UNLOAD\nint module_refcount(struct module *mod);\nvoid __symbol_put(const char *symbol);\n#define symbol_put(x) __symbol_put(__stringify(x))\nvoid symbol_put_addr(void *addr);\n\n \nextern void __module_get(struct module *module);\n\n \nextern bool try_module_get(struct module *module);\n\n \nextern void module_put(struct module *module);\n\n#else  \nstatic inline bool try_module_get(struct module *module)\n{\n\treturn !module || module_is_live(module);\n}\nstatic inline void module_put(struct module *module)\n{\n}\nstatic inline void __module_get(struct module *module)\n{\n}\n#define symbol_put(x) do { } while (0)\n#define symbol_put_addr(p) do { } while (0)\n\n#endif  \n\n \n#define module_name(mod)\t\t\t\\\n({\t\t\t\t\t\t\\\n\tstruct module *__mod = (mod);\t\t\\\n\t__mod ? __mod->name : \"kernel\";\t\t\\\n})\n\n \nvoid *dereference_module_function_descriptor(struct module *mod, void *ptr);\n\nint register_module_notifier(struct notifier_block *nb);\nint unregister_module_notifier(struct notifier_block *nb);\n\nextern void print_modules(void);\n\nstatic inline bool module_requested_async_probing(struct module *module)\n{\n\treturn module && module->async_probe_requested;\n}\n\nstatic inline bool is_livepatch_module(struct module *mod)\n{\n#ifdef CONFIG_LIVEPATCH\n\treturn mod->klp;\n#else\n\treturn false;\n#endif\n}\n\nvoid set_module_sig_enforced(void);\n\n#else  \n\nstatic inline struct module *__module_address(unsigned long addr)\n{\n\treturn NULL;\n}\n\nstatic inline struct module *__module_text_address(unsigned long addr)\n{\n\treturn NULL;\n}\n\nstatic inline bool is_module_address(unsigned long addr)\n{\n\treturn false;\n}\n\nstatic inline bool is_module_percpu_address(unsigned long addr)\n{\n\treturn false;\n}\n\nstatic inline bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)\n{\n\treturn false;\n}\n\nstatic inline bool is_module_text_address(unsigned long addr)\n{\n\treturn false;\n}\n\nstatic inline bool within_module_core(unsigned long addr,\n\t\t\t\t      const struct module *mod)\n{\n\treturn false;\n}\n\nstatic inline bool within_module_init(unsigned long addr,\n\t\t\t\t      const struct module *mod)\n{\n\treturn false;\n}\n\nstatic inline bool within_module(unsigned long addr, const struct module *mod)\n{\n\treturn false;\n}\n\n \n#define symbol_get(x) ({ extern typeof(x) x __attribute__((weak,visibility(\"hidden\"))); &(x); })\n#define symbol_put(x) do { } while (0)\n#define symbol_put_addr(x) do { } while (0)\n\nstatic inline void __module_get(struct module *module)\n{\n}\n\nstatic inline bool try_module_get(struct module *module)\n{\n\treturn true;\n}\n\nstatic inline void module_put(struct module *module)\n{\n}\n\n#define module_name(mod) \"kernel\"\n\nstatic inline int register_module_notifier(struct notifier_block *nb)\n{\n\t \n\treturn 0;\n}\n\nstatic inline int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn 0;\n}\n\n#define module_put_and_kthread_exit(code) kthread_exit(code)\n\nstatic inline void print_modules(void)\n{\n}\n\nstatic inline bool module_requested_async_probing(struct module *module)\n{\n\treturn false;\n}\n\n\nstatic inline void set_module_sig_enforced(void)\n{\n}\n\n \nstatic inline\nvoid *dereference_module_function_descriptor(struct module *mod, void *ptr)\n{\n\treturn ptr;\n}\n\n#endif  \n\n#ifdef CONFIG_SYSFS\nextern struct kset *module_kset;\nextern const struct kobj_type module_ktype;\n#endif  \n\n#define symbol_request(x) try_then_request_module(symbol_get(x), \"symbol:\" #x)\n\n \n\n#define __MODULE_STRING(x) __stringify(x)\n\n#ifdef CONFIG_GENERIC_BUG\nvoid module_bug_finalize(const Elf_Ehdr *, const Elf_Shdr *,\n\t\t\t struct module *);\nvoid module_bug_cleanup(struct module *);\n\n#else\t \n\nstatic inline void module_bug_finalize(const Elf_Ehdr *hdr,\n\t\t\t\t\tconst Elf_Shdr *sechdrs,\n\t\t\t\t\tstruct module *mod)\n{\n}\nstatic inline void module_bug_cleanup(struct module *mod) {}\n#endif\t \n\n#ifdef CONFIG_RETPOLINE\nextern bool retpoline_module_ok(bool has_retpoline);\n#else\nstatic inline bool retpoline_module_ok(bool has_retpoline)\n{\n\treturn true;\n}\n#endif\n\n#ifdef CONFIG_MODULE_SIG\nbool is_module_sig_enforced(void);\n\nstatic inline bool module_sig_ok(struct module *module)\n{\n\treturn module->sig_ok;\n}\n#else\t \nstatic inline bool is_module_sig_enforced(void)\n{\n\treturn false;\n}\n\nstatic inline bool module_sig_ok(struct module *module)\n{\n\treturn true;\n}\n#endif\t \n\n#if defined(CONFIG_MODULES) && defined(CONFIG_KALLSYMS)\nint module_kallsyms_on_each_symbol(const char *modname,\n\t\t\t\t   int (*fn)(void *, const char *, unsigned long),\n\t\t\t\t   void *data);\n\n \nconst char *module_address_lookup(unsigned long addr,\n\t\t\t\t  unsigned long *symbolsize,\n\t\t\t\t  unsigned long *offset,\n\t\t\t\t  char **modname, const unsigned char **modbuildid,\n\t\t\t\t  char *namebuf);\nint lookup_module_symbol_name(unsigned long addr, char *symname);\nint lookup_module_symbol_attrs(unsigned long addr,\n\t\t\t       unsigned long *size,\n\t\t\t       unsigned long *offset,\n\t\t\t       char *modname,\n\t\t\t       char *name);\n\n \nint module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t       char *name, char *module_name, int *exported);\n\n \nunsigned long module_kallsyms_lookup_name(const char *name);\n\nunsigned long find_kallsyms_symbol_value(struct module *mod, const char *name);\n\n#else\t \n\nstatic inline int module_kallsyms_on_each_symbol(const char *modname,\n\t\t\t\t\t\t int (*fn)(void *, const char *, unsigned long),\n\t\t\t\t\t\t void *data)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic inline const char *module_address_lookup(unsigned long addr,\n\t\t\t\t\t\tunsigned long *symbolsize,\n\t\t\t\t\t\tunsigned long *offset,\n\t\t\t\t\t\tchar **modname,\n\t\t\t\t\t\tconst unsigned char **modbuildid,\n\t\t\t\t\t\tchar *namebuf)\n{\n\treturn NULL;\n}\n\nstatic inline int lookup_module_symbol_name(unsigned long addr, char *symname)\n{\n\treturn -ERANGE;\n}\n\nstatic inline int module_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t\t     char *type, char *name,\n\t\t\t\t     char *module_name, int *exported)\n{\n\treturn -ERANGE;\n}\n\nstatic inline unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\treturn 0;\n}\n\nstatic inline unsigned long find_kallsyms_symbol_value(struct module *mod,\n\t\t\t\t\t\t       const char *name)\n{\n\treturn 0;\n}\n\n#endif   \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}