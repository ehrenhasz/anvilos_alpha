{
  "module_name": "mroute_base.h",
  "hash_id": "2fa82ed704bc1e6c5dd0508a6ca1983dc1d775e0283ac6acccb8af24e0cd6f12",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mroute_base.h",
  "human_readable_source": "#ifndef __LINUX_MROUTE_BASE_H\n#define __LINUX_MROUTE_BASE_H\n\n#include <linux/netdevice.h>\n#include <linux/rhashtable-types.h>\n#include <linux/spinlock.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/fib_notifier.h>\n#include <net/ip_fib.h>\n\n \nstruct vif_device {\n\tstruct net_device __rcu *dev;\n\tnetdevice_tracker dev_tracker;\n\tunsigned long bytes_in, bytes_out;\n\tunsigned long pkt_in, pkt_out;\n\tunsigned long rate_limit;\n\tunsigned char threshold;\n\tunsigned short flags;\n\tint link;\n\n\t \n\tstruct netdev_phys_item_id dev_parent_id;\n\t__be32 local, remote;\n};\n\nstruct vif_entry_notifier_info {\n\tstruct fib_notifier_info info;\n\tstruct net_device *dev;\n\tunsigned short vif_index;\n\tunsigned short vif_flags;\n\tu32 tb_id;\n};\n\nstatic inline int mr_call_vif_notifier(struct notifier_block *nb,\n\t\t\t\t       unsigned short family,\n\t\t\t\t       enum fib_event_type event_type,\n\t\t\t\t       struct vif_device *vif,\n\t\t\t\t       struct net_device *vif_dev,\n\t\t\t\t       unsigned short vif_index, u32 tb_id,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct vif_entry_notifier_info info = {\n\t\t.info = {\n\t\t\t.family = family,\n\t\t\t.extack = extack,\n\t\t},\n\t\t.dev = vif_dev,\n\t\t.vif_index = vif_index,\n\t\t.vif_flags = vif->flags,\n\t\t.tb_id = tb_id,\n\t};\n\n\treturn call_fib_notifier(nb, event_type, &info.info);\n}\n\nstatic inline int mr_call_vif_notifiers(struct net *net,\n\t\t\t\t\tunsigned short family,\n\t\t\t\t\tenum fib_event_type event_type,\n\t\t\t\t\tstruct vif_device *vif,\n\t\t\t\t\tstruct net_device *vif_dev,\n\t\t\t\t\tunsigned short vif_index, u32 tb_id,\n\t\t\t\t\tunsigned int *ipmr_seq)\n{\n\tstruct vif_entry_notifier_info info = {\n\t\t.info = {\n\t\t\t.family = family,\n\t\t},\n\t\t.dev = vif_dev,\n\t\t.vif_index = vif_index,\n\t\t.vif_flags = vif->flags,\n\t\t.tb_id = tb_id,\n\t};\n\n\tASSERT_RTNL();\n\t(*ipmr_seq)++;\n\treturn call_fib_notifiers(net, event_type, &info.info);\n}\n\n#ifndef MAXVIFS\n \n#define MAXVIFS\t32\n#endif\n\n \n#define VIF_EXISTS(_mrt, _idx) (!!rcu_access_pointer((_mrt)->vif_table[_idx].dev))\n\n \nenum {\n\tMFC_STATIC = BIT(0),\n\tMFC_OFFLOAD = BIT(1),\n};\n\n \nstruct mr_mfc {\n\tstruct rhlist_head mnode;\n\tunsigned short mfc_parent;\n\tint mfc_flags;\n\n\tunion {\n\t\tstruct {\n\t\t\tunsigned long expires;\n\t\t\tstruct sk_buff_head unresolved;\n\t\t} unres;\n\t\tstruct {\n\t\t\tunsigned long last_assert;\n\t\t\tint minvif;\n\t\t\tint maxvif;\n\t\t\tunsigned long bytes;\n\t\t\tunsigned long pkt;\n\t\t\tunsigned long wrong_if;\n\t\t\tunsigned long lastuse;\n\t\t\tunsigned char ttls[MAXVIFS];\n\t\t\trefcount_t refcount;\n\t\t} res;\n\t} mfc_un;\n\tstruct list_head list;\n\tstruct rcu_head\trcu;\n\tvoid (*free)(struct rcu_head *head);\n};\n\nstatic inline void mr_cache_put(struct mr_mfc *c)\n{\n\tif (refcount_dec_and_test(&c->mfc_un.res.refcount))\n\t\tcall_rcu(&c->rcu, c->free);\n}\n\nstatic inline void mr_cache_hold(struct mr_mfc *c)\n{\n\trefcount_inc(&c->mfc_un.res.refcount);\n}\n\nstruct mfc_entry_notifier_info {\n\tstruct fib_notifier_info info;\n\tstruct mr_mfc *mfc;\n\tu32 tb_id;\n};\n\nstatic inline int mr_call_mfc_notifier(struct notifier_block *nb,\n\t\t\t\t       unsigned short family,\n\t\t\t\t       enum fib_event_type event_type,\n\t\t\t\t       struct mr_mfc *mfc, u32 tb_id,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mfc_entry_notifier_info info = {\n\t\t.info = {\n\t\t\t.family = family,\n\t\t\t.extack = extack,\n\t\t},\n\t\t.mfc = mfc,\n\t\t.tb_id = tb_id\n\t};\n\n\treturn call_fib_notifier(nb, event_type, &info.info);\n}\n\nstatic inline int mr_call_mfc_notifiers(struct net *net,\n\t\t\t\t\tunsigned short family,\n\t\t\t\t\tenum fib_event_type event_type,\n\t\t\t\t\tstruct mr_mfc *mfc, u32 tb_id,\n\t\t\t\t\tunsigned int *ipmr_seq)\n{\n\tstruct mfc_entry_notifier_info info = {\n\t\t.info = {\n\t\t\t.family = family,\n\t\t},\n\t\t.mfc = mfc,\n\t\t.tb_id = tb_id\n\t};\n\n\tASSERT_RTNL();\n\t(*ipmr_seq)++;\n\treturn call_fib_notifiers(net, event_type, &info.info);\n}\n\nstruct mr_table;\n\n \nstruct mr_table_ops {\n\tconst struct rhashtable_params *rht_params;\n\tvoid *cmparg_any;\n};\n\n \nstruct mr_table {\n\tstruct list_head\tlist;\n\tpossible_net_t\t\tnet;\n\tstruct mr_table_ops\tops;\n\tu32\t\t\tid;\n\tstruct sock __rcu\t*mroute_sk;\n\tstruct timer_list\tipmr_expire_timer;\n\tstruct list_head\tmfc_unres_queue;\n\tstruct vif_device\tvif_table[MAXVIFS];\n\tstruct rhltable\t\tmfc_hash;\n\tstruct list_head\tmfc_cache_list;\n\tint\t\t\tmaxvif;\n\tatomic_t\t\tcache_resolve_queue_len;\n\tbool\t\t\tmroute_do_assert;\n\tbool\t\t\tmroute_do_pim;\n\tbool\t\t\tmroute_do_wrvifwhole;\n\tint\t\t\tmroute_reg_vif_num;\n};\n\n#ifdef CONFIG_IP_MROUTE_COMMON\nvoid vif_device_init(struct vif_device *v,\n\t\t     struct net_device *dev,\n\t\t     unsigned long rate_limit,\n\t\t     unsigned char threshold,\n\t\t     unsigned short flags,\n\t\t     unsigned short get_iflink_mask);\n\nstruct mr_table *\nmr_table_alloc(struct net *net, u32 id,\n\t       struct mr_table_ops *ops,\n\t       void (*expire_func)(struct timer_list *t),\n\t       void (*table_set)(struct mr_table *mrt,\n\t\t\t\t struct net *net));\n\n \nvoid *mr_mfc_find_parent(struct mr_table *mrt,\n\t\t\t void *hasharg, int parent);\nvoid *mr_mfc_find_any_parent(struct mr_table *mrt, int vifi);\nvoid *mr_mfc_find_any(struct mr_table *mrt, int vifi, void *hasharg);\n\nint mr_fill_mroute(struct mr_table *mrt, struct sk_buff *skb,\n\t\t   struct mr_mfc *c, struct rtmsg *rtm);\nint mr_table_dump(struct mr_table *mrt, struct sk_buff *skb,\n\t\t  struct netlink_callback *cb,\n\t\t  int (*fill)(struct mr_table *mrt, struct sk_buff *skb,\n\t\t\t      u32 portid, u32 seq, struct mr_mfc *c,\n\t\t\t      int cmd, int flags),\n\t\t  spinlock_t *lock, struct fib_dump_filter *filter);\nint mr_rtm_dumproute(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t     struct mr_table *(*iter)(struct net *net,\n\t\t\t\t\t      struct mr_table *mrt),\n\t\t     int (*fill)(struct mr_table *mrt,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t u32 portid, u32 seq, struct mr_mfc *c,\n\t\t\t\t int cmd, int flags),\n\t\t     spinlock_t *lock, struct fib_dump_filter *filter);\n\nint mr_dump(struct net *net, struct notifier_block *nb, unsigned short family,\n\t    int (*rules_dump)(struct net *net,\n\t\t\t      struct notifier_block *nb,\n\t\t\t      struct netlink_ext_ack *extack),\n\t    struct mr_table *(*mr_iter)(struct net *net,\n\t\t\t\t\tstruct mr_table *mrt),\n\t    struct netlink_ext_ack *extack);\n#else\nstatic inline void vif_device_init(struct vif_device *v,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   unsigned long rate_limit,\n\t\t\t\t   unsigned char threshold,\n\t\t\t\t   unsigned short flags,\n\t\t\t\t   unsigned short get_iflink_mask)\n{\n}\n\nstatic inline void *mr_mfc_find_parent(struct mr_table *mrt,\n\t\t\t\t       void *hasharg, int parent)\n{\n\treturn NULL;\n}\n\nstatic inline void *mr_mfc_find_any_parent(struct mr_table *mrt,\n\t\t\t\t\t   int vifi)\n{\n\treturn NULL;\n}\n\nstatic inline struct mr_mfc *mr_mfc_find_any(struct mr_table *mrt,\n\t\t\t\t\t     int vifi, void *hasharg)\n{\n\treturn NULL;\n}\n\nstatic inline int mr_fill_mroute(struct mr_table *mrt, struct sk_buff *skb,\n\t\t\t\t struct mr_mfc *c, struct rtmsg *rtm)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int\nmr_rtm_dumproute(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t struct mr_table *(*iter)(struct net *net,\n\t\t\t\t\t  struct mr_table *mrt),\n\t\t int (*fill)(struct mr_table *mrt,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     u32 portid, u32 seq, struct mr_mfc *c,\n\t\t\t     int cmd, int flags),\n\t\t spinlock_t *lock, struct fib_dump_filter *filter)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int mr_dump(struct net *net, struct notifier_block *nb,\n\t\t\t  unsigned short family,\n\t\t\t  int (*rules_dump)(struct net *net,\n\t\t\t\t\t    struct notifier_block *nb,\n\t\t\t\t\t    struct netlink_ext_ack *extack),\n\t\t\t  struct mr_table *(*mr_iter)(struct net *net,\n\t\t\t\t\t\t      struct mr_table *mrt),\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn -EINVAL;\n}\n#endif\n\nstatic inline void *mr_mfc_find(struct mr_table *mrt, void *hasharg)\n{\n\treturn mr_mfc_find_parent(mrt, hasharg, -1);\n}\n\n#ifdef CONFIG_PROC_FS\nstruct mr_vif_iter {\n\tstruct seq_net_private p;\n\tstruct mr_table *mrt;\n\tint ct;\n};\n\nstruct mr_mfc_iter {\n\tstruct seq_net_private p;\n\tstruct mr_table *mrt;\n\tstruct list_head *cache;\n\n\t \n\tspinlock_t *lock;\n};\n\n#ifdef CONFIG_IP_MROUTE_COMMON\nvoid *mr_vif_seq_idx(struct net *net, struct mr_vif_iter *iter, loff_t pos);\nvoid *mr_vif_seq_next(struct seq_file *seq, void *v, loff_t *pos);\n\nstatic inline void *mr_vif_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos ? mr_vif_seq_idx(seq_file_net(seq),\n\t\t\t\t     seq->private, *pos - 1)\n\t\t    : SEQ_START_TOKEN;\n}\n\n \nvoid *mr_mfc_seq_idx(struct net *net,\n\t\t     struct mr_mfc_iter *it, loff_t pos);\nvoid *mr_mfc_seq_next(struct seq_file *seq, void *v,\n\t\t      loff_t *pos);\n\nstatic inline void *mr_mfc_seq_start(struct seq_file *seq, loff_t *pos,\n\t\t\t\t     struct mr_table *mrt, spinlock_t *lock)\n{\n\tstruct mr_mfc_iter *it = seq->private;\n\n\tit->mrt = mrt;\n\tit->cache = NULL;\n\tit->lock = lock;\n\n\treturn *pos ? mr_mfc_seq_idx(seq_file_net(seq),\n\t\t\t\t     seq->private, *pos - 1)\n\t\t    : SEQ_START_TOKEN;\n}\n\nstatic inline void mr_mfc_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct mr_mfc_iter *it = seq->private;\n\tstruct mr_table *mrt = it->mrt;\n\n\tif (it->cache == &mrt->mfc_unres_queue)\n\t\tspin_unlock_bh(it->lock);\n\telse if (it->cache == &mrt->mfc_cache_list)\n\t\trcu_read_unlock();\n}\n#else\nstatic inline void *mr_vif_seq_idx(struct net *net, struct mr_vif_iter *iter,\n\t\t\t\t   loff_t pos)\n{\n\treturn NULL;\n}\n\nstatic inline void *mr_vif_seq_next(struct seq_file *seq,\n\t\t\t\t    void *v, loff_t *pos)\n{\n\treturn NULL;\n}\n\nstatic inline void *mr_vif_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn NULL;\n}\n\nstatic inline void *mr_mfc_seq_idx(struct net *net,\n\t\t\t\t   struct mr_mfc_iter *it, loff_t pos)\n{\n\treturn NULL;\n}\n\nstatic inline void *mr_mfc_seq_next(struct seq_file *seq, void *v,\n\t\t\t\t    loff_t *pos)\n{\n\treturn NULL;\n}\n\nstatic inline void *mr_mfc_seq_start(struct seq_file *seq, loff_t *pos,\n\t\t\t\t     struct mr_table *mrt, spinlock_t *lock)\n{\n\treturn NULL;\n}\n\nstatic inline void mr_mfc_seq_stop(struct seq_file *seq, void *v)\n{\n}\n#endif\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}