{
  "module_name": "lsm_hook_defs.h",
  "hash_id": "17093ec06545db5aec2b59d2e51325d0728d01b8f68bbdfcd5df44b72b9a4fb6",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/lsm_hook_defs.h",
  "human_readable_source": " \n\n \n\n \nLSM_HOOK(int, 0, binder_set_context_mgr, const struct cred *mgr)\nLSM_HOOK(int, 0, binder_transaction, const struct cred *from,\n\t const struct cred *to)\nLSM_HOOK(int, 0, binder_transfer_binder, const struct cred *from,\n\t const struct cred *to)\nLSM_HOOK(int, 0, binder_transfer_file, const struct cred *from,\n\t const struct cred *to, const struct file *file)\nLSM_HOOK(int, 0, ptrace_access_check, struct task_struct *child,\n\t unsigned int mode)\nLSM_HOOK(int, 0, ptrace_traceme, struct task_struct *parent)\nLSM_HOOK(int, 0, capget, const struct task_struct *target, kernel_cap_t *effective,\n\t kernel_cap_t *inheritable, kernel_cap_t *permitted)\nLSM_HOOK(int, 0, capset, struct cred *new, const struct cred *old,\n\t const kernel_cap_t *effective, const kernel_cap_t *inheritable,\n\t const kernel_cap_t *permitted)\nLSM_HOOK(int, 0, capable, const struct cred *cred, struct user_namespace *ns,\n\t int cap, unsigned int opts)\nLSM_HOOK(int, 0, quotactl, int cmds, int type, int id, struct super_block *sb)\nLSM_HOOK(int, 0, quota_on, struct dentry *dentry)\nLSM_HOOK(int, 0, syslog, int type)\nLSM_HOOK(int, 0, settime, const struct timespec64 *ts,\n\t const struct timezone *tz)\nLSM_HOOK(int, 1, vm_enough_memory, struct mm_struct *mm, long pages)\nLSM_HOOK(int, 0, bprm_creds_for_exec, struct linux_binprm *bprm)\nLSM_HOOK(int, 0, bprm_creds_from_file, struct linux_binprm *bprm, struct file *file)\nLSM_HOOK(int, 0, bprm_check_security, struct linux_binprm *bprm)\nLSM_HOOK(void, LSM_RET_VOID, bprm_committing_creds, struct linux_binprm *bprm)\nLSM_HOOK(void, LSM_RET_VOID, bprm_committed_creds, struct linux_binprm *bprm)\nLSM_HOOK(int, 0, fs_context_submount, struct fs_context *fc, struct super_block *reference)\nLSM_HOOK(int, 0, fs_context_dup, struct fs_context *fc,\n\t struct fs_context *src_sc)\nLSM_HOOK(int, -ENOPARAM, fs_context_parse_param, struct fs_context *fc,\n\t struct fs_parameter *param)\nLSM_HOOK(int, 0, sb_alloc_security, struct super_block *sb)\nLSM_HOOK(void, LSM_RET_VOID, sb_delete, struct super_block *sb)\nLSM_HOOK(void, LSM_RET_VOID, sb_free_security, struct super_block *sb)\nLSM_HOOK(void, LSM_RET_VOID, sb_free_mnt_opts, void *mnt_opts)\nLSM_HOOK(int, 0, sb_eat_lsm_opts, char *orig, void **mnt_opts)\nLSM_HOOK(int, 0, sb_mnt_opts_compat, struct super_block *sb, void *mnt_opts)\nLSM_HOOK(int, 0, sb_remount, struct super_block *sb, void *mnt_opts)\nLSM_HOOK(int, 0, sb_kern_mount, struct super_block *sb)\nLSM_HOOK(int, 0, sb_show_options, struct seq_file *m, struct super_block *sb)\nLSM_HOOK(int, 0, sb_statfs, struct dentry *dentry)\nLSM_HOOK(int, 0, sb_mount, const char *dev_name, const struct path *path,\n\t const char *type, unsigned long flags, void *data)\nLSM_HOOK(int, 0, sb_umount, struct vfsmount *mnt, int flags)\nLSM_HOOK(int, 0, sb_pivotroot, const struct path *old_path,\n\t const struct path *new_path)\nLSM_HOOK(int, 0, sb_set_mnt_opts, struct super_block *sb, void *mnt_opts,\n\t unsigned long kern_flags, unsigned long *set_kern_flags)\nLSM_HOOK(int, 0, sb_clone_mnt_opts, const struct super_block *oldsb,\n\t struct super_block *newsb, unsigned long kern_flags,\n\t unsigned long *set_kern_flags)\nLSM_HOOK(int, 0, move_mount, const struct path *from_path,\n\t const struct path *to_path)\nLSM_HOOK(int, -EOPNOTSUPP, dentry_init_security, struct dentry *dentry,\n\t int mode, const struct qstr *name, const char **xattr_name,\n\t void **ctx, u32 *ctxlen)\nLSM_HOOK(int, 0, dentry_create_files_as, struct dentry *dentry, int mode,\n\t struct qstr *name, const struct cred *old, struct cred *new)\n\n#ifdef CONFIG_SECURITY_PATH\nLSM_HOOK(int, 0, path_unlink, const struct path *dir, struct dentry *dentry)\nLSM_HOOK(int, 0, path_mkdir, const struct path *dir, struct dentry *dentry,\n\t umode_t mode)\nLSM_HOOK(int, 0, path_rmdir, const struct path *dir, struct dentry *dentry)\nLSM_HOOK(int, 0, path_mknod, const struct path *dir, struct dentry *dentry,\n\t umode_t mode, unsigned int dev)\nLSM_HOOK(int, 0, path_truncate, const struct path *path)\nLSM_HOOK(int, 0, path_symlink, const struct path *dir, struct dentry *dentry,\n\t const char *old_name)\nLSM_HOOK(int, 0, path_link, struct dentry *old_dentry,\n\t const struct path *new_dir, struct dentry *new_dentry)\nLSM_HOOK(int, 0, path_rename, const struct path *old_dir,\n\t struct dentry *old_dentry, const struct path *new_dir,\n\t struct dentry *new_dentry, unsigned int flags)\nLSM_HOOK(int, 0, path_chmod, const struct path *path, umode_t mode)\nLSM_HOOK(int, 0, path_chown, const struct path *path, kuid_t uid, kgid_t gid)\nLSM_HOOK(int, 0, path_chroot, const struct path *path)\n#endif  \n\n \nLSM_HOOK(int, 0, path_notify, const struct path *path, u64 mask,\n\t unsigned int obj_type)\nLSM_HOOK(int, 0, inode_alloc_security, struct inode *inode)\nLSM_HOOK(void, LSM_RET_VOID, inode_free_security, struct inode *inode)\nLSM_HOOK(int, -EOPNOTSUPP, inode_init_security, struct inode *inode,\n\t struct inode *dir, const struct qstr *qstr, struct xattr *xattrs,\n\t int *xattr_count)\nLSM_HOOK(int, 0, inode_init_security_anon, struct inode *inode,\n\t const struct qstr *name, const struct inode *context_inode)\nLSM_HOOK(int, 0, inode_create, struct inode *dir, struct dentry *dentry,\n\t umode_t mode)\nLSM_HOOK(int, 0, inode_link, struct dentry *old_dentry, struct inode *dir,\n\t struct dentry *new_dentry)\nLSM_HOOK(int, 0, inode_unlink, struct inode *dir, struct dentry *dentry)\nLSM_HOOK(int, 0, inode_symlink, struct inode *dir, struct dentry *dentry,\n\t const char *old_name)\nLSM_HOOK(int, 0, inode_mkdir, struct inode *dir, struct dentry *dentry,\n\t umode_t mode)\nLSM_HOOK(int, 0, inode_rmdir, struct inode *dir, struct dentry *dentry)\nLSM_HOOK(int, 0, inode_mknod, struct inode *dir, struct dentry *dentry,\n\t umode_t mode, dev_t dev)\nLSM_HOOK(int, 0, inode_rename, struct inode *old_dir, struct dentry *old_dentry,\n\t struct inode *new_dir, struct dentry *new_dentry)\nLSM_HOOK(int, 0, inode_readlink, struct dentry *dentry)\nLSM_HOOK(int, 0, inode_follow_link, struct dentry *dentry, struct inode *inode,\n\t bool rcu)\nLSM_HOOK(int, 0, inode_permission, struct inode *inode, int mask)\nLSM_HOOK(int, 0, inode_setattr, struct dentry *dentry, struct iattr *attr)\nLSM_HOOK(int, 0, inode_getattr, const struct path *path)\nLSM_HOOK(int, 0, inode_setxattr, struct mnt_idmap *idmap,\n\t struct dentry *dentry, const char *name, const void *value,\n\t size_t size, int flags)\nLSM_HOOK(void, LSM_RET_VOID, inode_post_setxattr, struct dentry *dentry,\n\t const char *name, const void *value, size_t size, int flags)\nLSM_HOOK(int, 0, inode_getxattr, struct dentry *dentry, const char *name)\nLSM_HOOK(int, 0, inode_listxattr, struct dentry *dentry)\nLSM_HOOK(int, 0, inode_removexattr, struct mnt_idmap *idmap,\n\t struct dentry *dentry, const char *name)\nLSM_HOOK(int, 0, inode_set_acl, struct mnt_idmap *idmap,\n\t struct dentry *dentry, const char *acl_name, struct posix_acl *kacl)\nLSM_HOOK(int, 0, inode_get_acl, struct mnt_idmap *idmap,\n\t struct dentry *dentry, const char *acl_name)\nLSM_HOOK(int, 0, inode_remove_acl, struct mnt_idmap *idmap,\n\t struct dentry *dentry, const char *acl_name)\nLSM_HOOK(int, 0, inode_need_killpriv, struct dentry *dentry)\nLSM_HOOK(int, 0, inode_killpriv, struct mnt_idmap *idmap,\n\t struct dentry *dentry)\nLSM_HOOK(int, -EOPNOTSUPP, inode_getsecurity, struct mnt_idmap *idmap,\n\t struct inode *inode, const char *name, void **buffer, bool alloc)\nLSM_HOOK(int, -EOPNOTSUPP, inode_setsecurity, struct inode *inode,\n\t const char *name, const void *value, size_t size, int flags)\nLSM_HOOK(int, 0, inode_listsecurity, struct inode *inode, char *buffer,\n\t size_t buffer_size)\nLSM_HOOK(void, LSM_RET_VOID, inode_getsecid, struct inode *inode, u32 *secid)\nLSM_HOOK(int, 0, inode_copy_up, struct dentry *src, struct cred **new)\nLSM_HOOK(int, -EOPNOTSUPP, inode_copy_up_xattr, const char *name)\nLSM_HOOK(int, 0, kernfs_init_security, struct kernfs_node *kn_dir,\n\t struct kernfs_node *kn)\nLSM_HOOK(int, 0, file_permission, struct file *file, int mask)\nLSM_HOOK(int, 0, file_alloc_security, struct file *file)\nLSM_HOOK(void, LSM_RET_VOID, file_free_security, struct file *file)\nLSM_HOOK(int, 0, file_ioctl, struct file *file, unsigned int cmd,\n\t unsigned long arg)\nLSM_HOOK(int, 0, mmap_addr, unsigned long addr)\nLSM_HOOK(int, 0, mmap_file, struct file *file, unsigned long reqprot,\n\t unsigned long prot, unsigned long flags)\nLSM_HOOK(int, 0, file_mprotect, struct vm_area_struct *vma,\n\t unsigned long reqprot, unsigned long prot)\nLSM_HOOK(int, 0, file_lock, struct file *file, unsigned int cmd)\nLSM_HOOK(int, 0, file_fcntl, struct file *file, unsigned int cmd,\n\t unsigned long arg)\nLSM_HOOK(void, LSM_RET_VOID, file_set_fowner, struct file *file)\nLSM_HOOK(int, 0, file_send_sigiotask, struct task_struct *tsk,\n\t struct fown_struct *fown, int sig)\nLSM_HOOK(int, 0, file_receive, struct file *file)\nLSM_HOOK(int, 0, file_open, struct file *file)\nLSM_HOOK(int, 0, file_truncate, struct file *file)\nLSM_HOOK(int, 0, task_alloc, struct task_struct *task,\n\t unsigned long clone_flags)\nLSM_HOOK(void, LSM_RET_VOID, task_free, struct task_struct *task)\nLSM_HOOK(int, 0, cred_alloc_blank, struct cred *cred, gfp_t gfp)\nLSM_HOOK(void, LSM_RET_VOID, cred_free, struct cred *cred)\nLSM_HOOK(int, 0, cred_prepare, struct cred *new, const struct cred *old,\n\t gfp_t gfp)\nLSM_HOOK(void, LSM_RET_VOID, cred_transfer, struct cred *new,\n\t const struct cred *old)\nLSM_HOOK(void, LSM_RET_VOID, cred_getsecid, const struct cred *c, u32 *secid)\nLSM_HOOK(int, 0, kernel_act_as, struct cred *new, u32 secid)\nLSM_HOOK(int, 0, kernel_create_files_as, struct cred *new, struct inode *inode)\nLSM_HOOK(int, 0, kernel_module_request, char *kmod_name)\nLSM_HOOK(int, 0, kernel_load_data, enum kernel_load_data_id id, bool contents)\nLSM_HOOK(int, 0, kernel_post_load_data, char *buf, loff_t size,\n\t enum kernel_load_data_id id, char *description)\nLSM_HOOK(int, 0, kernel_read_file, struct file *file,\n\t enum kernel_read_file_id id, bool contents)\nLSM_HOOK(int, 0, kernel_post_read_file, struct file *file, char *buf,\n\t loff_t size, enum kernel_read_file_id id)\nLSM_HOOK(int, 0, task_fix_setuid, struct cred *new, const struct cred *old,\n\t int flags)\nLSM_HOOK(int, 0, task_fix_setgid, struct cred *new, const struct cred * old,\n\t int flags)\nLSM_HOOK(int, 0, task_fix_setgroups, struct cred *new, const struct cred * old)\nLSM_HOOK(int, 0, task_setpgid, struct task_struct *p, pid_t pgid)\nLSM_HOOK(int, 0, task_getpgid, struct task_struct *p)\nLSM_HOOK(int, 0, task_getsid, struct task_struct *p)\nLSM_HOOK(void, LSM_RET_VOID, current_getsecid_subj, u32 *secid)\nLSM_HOOK(void, LSM_RET_VOID, task_getsecid_obj,\n\t struct task_struct *p, u32 *secid)\nLSM_HOOK(int, 0, task_setnice, struct task_struct *p, int nice)\nLSM_HOOK(int, 0, task_setioprio, struct task_struct *p, int ioprio)\nLSM_HOOK(int, 0, task_getioprio, struct task_struct *p)\nLSM_HOOK(int, 0, task_prlimit, const struct cred *cred,\n\t const struct cred *tcred, unsigned int flags)\nLSM_HOOK(int, 0, task_setrlimit, struct task_struct *p, unsigned int resource,\n\t struct rlimit *new_rlim)\nLSM_HOOK(int, 0, task_setscheduler, struct task_struct *p)\nLSM_HOOK(int, 0, task_getscheduler, struct task_struct *p)\nLSM_HOOK(int, 0, task_movememory, struct task_struct *p)\nLSM_HOOK(int, 0, task_kill, struct task_struct *p, struct kernel_siginfo *info,\n\t int sig, const struct cred *cred)\nLSM_HOOK(int, -ENOSYS, task_prctl, int option, unsigned long arg2,\n\t unsigned long arg3, unsigned long arg4, unsigned long arg5)\nLSM_HOOK(void, LSM_RET_VOID, task_to_inode, struct task_struct *p,\n\t struct inode *inode)\nLSM_HOOK(int, 0, userns_create, const struct cred *cred)\nLSM_HOOK(int, 0, ipc_permission, struct kern_ipc_perm *ipcp, short flag)\nLSM_HOOK(void, LSM_RET_VOID, ipc_getsecid, struct kern_ipc_perm *ipcp,\n\t u32 *secid)\nLSM_HOOK(int, 0, msg_msg_alloc_security, struct msg_msg *msg)\nLSM_HOOK(void, LSM_RET_VOID, msg_msg_free_security, struct msg_msg *msg)\nLSM_HOOK(int, 0, msg_queue_alloc_security, struct kern_ipc_perm *perm)\nLSM_HOOK(void, LSM_RET_VOID, msg_queue_free_security,\n\t struct kern_ipc_perm *perm)\nLSM_HOOK(int, 0, msg_queue_associate, struct kern_ipc_perm *perm, int msqflg)\nLSM_HOOK(int, 0, msg_queue_msgctl, struct kern_ipc_perm *perm, int cmd)\nLSM_HOOK(int, 0, msg_queue_msgsnd, struct kern_ipc_perm *perm,\n\t struct msg_msg *msg, int msqflg)\nLSM_HOOK(int, 0, msg_queue_msgrcv, struct kern_ipc_perm *perm,\n\t struct msg_msg *msg, struct task_struct *target, long type, int mode)\nLSM_HOOK(int, 0, shm_alloc_security, struct kern_ipc_perm *perm)\nLSM_HOOK(void, LSM_RET_VOID, shm_free_security, struct kern_ipc_perm *perm)\nLSM_HOOK(int, 0, shm_associate, struct kern_ipc_perm *perm, int shmflg)\nLSM_HOOK(int, 0, shm_shmctl, struct kern_ipc_perm *perm, int cmd)\nLSM_HOOK(int, 0, shm_shmat, struct kern_ipc_perm *perm, char __user *shmaddr,\n\t int shmflg)\nLSM_HOOK(int, 0, sem_alloc_security, struct kern_ipc_perm *perm)\nLSM_HOOK(void, LSM_RET_VOID, sem_free_security, struct kern_ipc_perm *perm)\nLSM_HOOK(int, 0, sem_associate, struct kern_ipc_perm *perm, int semflg)\nLSM_HOOK(int, 0, sem_semctl, struct kern_ipc_perm *perm, int cmd)\nLSM_HOOK(int, 0, sem_semop, struct kern_ipc_perm *perm, struct sembuf *sops,\n\t unsigned nsops, int alter)\nLSM_HOOK(int, 0, netlink_send, struct sock *sk, struct sk_buff *skb)\nLSM_HOOK(void, LSM_RET_VOID, d_instantiate, struct dentry *dentry,\n\t struct inode *inode)\nLSM_HOOK(int, -EINVAL, getprocattr, struct task_struct *p, const char *name,\n\t char **value)\nLSM_HOOK(int, -EINVAL, setprocattr, const char *name, void *value, size_t size)\nLSM_HOOK(int, 0, ismaclabel, const char *name)\nLSM_HOOK(int, -EOPNOTSUPP, secid_to_secctx, u32 secid, char **secdata,\n\t u32 *seclen)\nLSM_HOOK(int, 0, secctx_to_secid, const char *secdata, u32 seclen, u32 *secid)\nLSM_HOOK(void, LSM_RET_VOID, release_secctx, char *secdata, u32 seclen)\nLSM_HOOK(void, LSM_RET_VOID, inode_invalidate_secctx, struct inode *inode)\nLSM_HOOK(int, 0, inode_notifysecctx, struct inode *inode, void *ctx, u32 ctxlen)\nLSM_HOOK(int, 0, inode_setsecctx, struct dentry *dentry, void *ctx, u32 ctxlen)\nLSM_HOOK(int, -EOPNOTSUPP, inode_getsecctx, struct inode *inode, void **ctx,\n\t u32 *ctxlen)\n\n#if defined(CONFIG_SECURITY) && defined(CONFIG_WATCH_QUEUE)\nLSM_HOOK(int, 0, post_notification, const struct cred *w_cred,\n\t const struct cred *cred, struct watch_notification *n)\n#endif  \n\n#if defined(CONFIG_SECURITY) && defined(CONFIG_KEY_NOTIFICATIONS)\nLSM_HOOK(int, 0, watch_key, struct key *key)\n#endif  \n\n#ifdef CONFIG_SECURITY_NETWORK\nLSM_HOOK(int, 0, unix_stream_connect, struct sock *sock, struct sock *other,\n\t struct sock *newsk)\nLSM_HOOK(int, 0, unix_may_send, struct socket *sock, struct socket *other)\nLSM_HOOK(int, 0, socket_create, int family, int type, int protocol, int kern)\nLSM_HOOK(int, 0, socket_post_create, struct socket *sock, int family, int type,\n\t int protocol, int kern)\nLSM_HOOK(int, 0, socket_socketpair, struct socket *socka, struct socket *sockb)\nLSM_HOOK(int, 0, socket_bind, struct socket *sock, struct sockaddr *address,\n\t int addrlen)\nLSM_HOOK(int, 0, socket_connect, struct socket *sock, struct sockaddr *address,\n\t int addrlen)\nLSM_HOOK(int, 0, socket_listen, struct socket *sock, int backlog)\nLSM_HOOK(int, 0, socket_accept, struct socket *sock, struct socket *newsock)\nLSM_HOOK(int, 0, socket_sendmsg, struct socket *sock, struct msghdr *msg,\n\t int size)\nLSM_HOOK(int, 0, socket_recvmsg, struct socket *sock, struct msghdr *msg,\n\t int size, int flags)\nLSM_HOOK(int, 0, socket_getsockname, struct socket *sock)\nLSM_HOOK(int, 0, socket_getpeername, struct socket *sock)\nLSM_HOOK(int, 0, socket_getsockopt, struct socket *sock, int level, int optname)\nLSM_HOOK(int, 0, socket_setsockopt, struct socket *sock, int level, int optname)\nLSM_HOOK(int, 0, socket_shutdown, struct socket *sock, int how)\nLSM_HOOK(int, 0, socket_sock_rcv_skb, struct sock *sk, struct sk_buff *skb)\nLSM_HOOK(int, 0, socket_getpeersec_stream, struct socket *sock,\n\t sockptr_t optval, sockptr_t optlen, unsigned int len)\nLSM_HOOK(int, 0, socket_getpeersec_dgram, struct socket *sock,\n\t struct sk_buff *skb, u32 *secid)\nLSM_HOOK(int, 0, sk_alloc_security, struct sock *sk, int family, gfp_t priority)\nLSM_HOOK(void, LSM_RET_VOID, sk_free_security, struct sock *sk)\nLSM_HOOK(void, LSM_RET_VOID, sk_clone_security, const struct sock *sk,\n\t struct sock *newsk)\nLSM_HOOK(void, LSM_RET_VOID, sk_getsecid, const struct sock *sk, u32 *secid)\nLSM_HOOK(void, LSM_RET_VOID, sock_graft, struct sock *sk, struct socket *parent)\nLSM_HOOK(int, 0, inet_conn_request, const struct sock *sk, struct sk_buff *skb,\n\t struct request_sock *req)\nLSM_HOOK(void, LSM_RET_VOID, inet_csk_clone, struct sock *newsk,\n\t const struct request_sock *req)\nLSM_HOOK(void, LSM_RET_VOID, inet_conn_established, struct sock *sk,\n\t struct sk_buff *skb)\nLSM_HOOK(int, 0, secmark_relabel_packet, u32 secid)\nLSM_HOOK(void, LSM_RET_VOID, secmark_refcount_inc, void)\nLSM_HOOK(void, LSM_RET_VOID, secmark_refcount_dec, void)\nLSM_HOOK(void, LSM_RET_VOID, req_classify_flow, const struct request_sock *req,\n\t struct flowi_common *flic)\nLSM_HOOK(int, 0, tun_dev_alloc_security, void **security)\nLSM_HOOK(void, LSM_RET_VOID, tun_dev_free_security, void *security)\nLSM_HOOK(int, 0, tun_dev_create, void)\nLSM_HOOK(int, 0, tun_dev_attach_queue, void *security)\nLSM_HOOK(int, 0, tun_dev_attach, struct sock *sk, void *security)\nLSM_HOOK(int, 0, tun_dev_open, void *security)\nLSM_HOOK(int, 0, sctp_assoc_request, struct sctp_association *asoc,\n\t struct sk_buff *skb)\nLSM_HOOK(int, 0, sctp_bind_connect, struct sock *sk, int optname,\n\t struct sockaddr *address, int addrlen)\nLSM_HOOK(void, LSM_RET_VOID, sctp_sk_clone, struct sctp_association *asoc,\n\t struct sock *sk, struct sock *newsk)\nLSM_HOOK(int, 0, sctp_assoc_established, struct sctp_association *asoc,\n\t struct sk_buff *skb)\nLSM_HOOK(int, 0, mptcp_add_subflow, struct sock *sk, struct sock *ssk)\n#endif  \n\n#ifdef CONFIG_SECURITY_INFINIBAND\nLSM_HOOK(int, 0, ib_pkey_access, void *sec, u64 subnet_prefix, u16 pkey)\nLSM_HOOK(int, 0, ib_endport_manage_subnet, void *sec, const char *dev_name,\n\t u8 port_num)\nLSM_HOOK(int, 0, ib_alloc_security, void **sec)\nLSM_HOOK(void, LSM_RET_VOID, ib_free_security, void *sec)\n#endif  \n\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\nLSM_HOOK(int, 0, xfrm_policy_alloc_security, struct xfrm_sec_ctx **ctxp,\n\t struct xfrm_user_sec_ctx *sec_ctx, gfp_t gfp)\nLSM_HOOK(int, 0, xfrm_policy_clone_security, struct xfrm_sec_ctx *old_ctx,\n\t struct xfrm_sec_ctx **new_ctx)\nLSM_HOOK(void, LSM_RET_VOID, xfrm_policy_free_security,\n\t struct xfrm_sec_ctx *ctx)\nLSM_HOOK(int, 0, xfrm_policy_delete_security, struct xfrm_sec_ctx *ctx)\nLSM_HOOK(int, 0, xfrm_state_alloc, struct xfrm_state *x,\n\t struct xfrm_user_sec_ctx *sec_ctx)\nLSM_HOOK(int, 0, xfrm_state_alloc_acquire, struct xfrm_state *x,\n\t struct xfrm_sec_ctx *polsec, u32 secid)\nLSM_HOOK(void, LSM_RET_VOID, xfrm_state_free_security, struct xfrm_state *x)\nLSM_HOOK(int, 0, xfrm_state_delete_security, struct xfrm_state *x)\nLSM_HOOK(int, 0, xfrm_policy_lookup, struct xfrm_sec_ctx *ctx, u32 fl_secid)\nLSM_HOOK(int, 1, xfrm_state_pol_flow_match, struct xfrm_state *x,\n\t struct xfrm_policy *xp, const struct flowi_common *flic)\nLSM_HOOK(int, 0, xfrm_decode_session, struct sk_buff *skb, u32 *secid,\n\t int ckall)\n#endif  \n\n \n#ifdef CONFIG_KEYS\nLSM_HOOK(int, 0, key_alloc, struct key *key, const struct cred *cred,\n\t unsigned long flags)\nLSM_HOOK(void, LSM_RET_VOID, key_free, struct key *key)\nLSM_HOOK(int, 0, key_permission, key_ref_t key_ref, const struct cred *cred,\n\t enum key_need_perm need_perm)\nLSM_HOOK(int, 0, key_getsecurity, struct key *key, char **buffer)\n#endif  \n\n#ifdef CONFIG_AUDIT\nLSM_HOOK(int, 0, audit_rule_init, u32 field, u32 op, char *rulestr,\n\t void **lsmrule)\nLSM_HOOK(int, 0, audit_rule_known, struct audit_krule *krule)\nLSM_HOOK(int, 0, audit_rule_match, u32 secid, u32 field, u32 op, void *lsmrule)\nLSM_HOOK(void, LSM_RET_VOID, audit_rule_free, void *lsmrule)\n#endif  \n\n#ifdef CONFIG_BPF_SYSCALL\nLSM_HOOK(int, 0, bpf, int cmd, union bpf_attr *attr, unsigned int size)\nLSM_HOOK(int, 0, bpf_map, struct bpf_map *map, fmode_t fmode)\nLSM_HOOK(int, 0, bpf_prog, struct bpf_prog *prog)\nLSM_HOOK(int, 0, bpf_map_alloc_security, struct bpf_map *map)\nLSM_HOOK(void, LSM_RET_VOID, bpf_map_free_security, struct bpf_map *map)\nLSM_HOOK(int, 0, bpf_prog_alloc_security, struct bpf_prog_aux *aux)\nLSM_HOOK(void, LSM_RET_VOID, bpf_prog_free_security, struct bpf_prog_aux *aux)\n#endif  \n\nLSM_HOOK(int, 0, locked_down, enum lockdown_reason what)\n\n#ifdef CONFIG_PERF_EVENTS\nLSM_HOOK(int, 0, perf_event_open, struct perf_event_attr *attr, int type)\nLSM_HOOK(int, 0, perf_event_alloc, struct perf_event *event)\nLSM_HOOK(void, LSM_RET_VOID, perf_event_free, struct perf_event *event)\nLSM_HOOK(int, 0, perf_event_read, struct perf_event *event)\nLSM_HOOK(int, 0, perf_event_write, struct perf_event *event)\n#endif  \n\n#ifdef CONFIG_IO_URING\nLSM_HOOK(int, 0, uring_override_creds, const struct cred *new)\nLSM_HOOK(int, 0, uring_sqpoll, void)\nLSM_HOOK(int, 0, uring_cmd, struct io_uring_cmd *ioucmd)\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}