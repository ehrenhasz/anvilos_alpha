{
  "module_name": "ipmi_smi.h",
  "hash_id": "48abf3a80f0b4f79af6bb7964b28a3c0a5d1bed38b5a51cacf17329cd66456db",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ipmi_smi.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_IPMI_SMI_H\n#define __LINUX_IPMI_SMI_H\n\n#include <linux/ipmi_msgdefs.h>\n#include <linux/proc_fs.h>\n#include <linux/platform_device.h>\n#include <linux/ipmi.h>\n\nstruct device;\n\n \n\n \nstruct ipmi_smi;\n\n \n#define IPMI_WATCH_MASK_CHECK_MESSAGES\t(1 << 0)\n#define IPMI_WATCH_MASK_CHECK_WATCHDOG\t(1 << 1)\n#define IPMI_WATCH_MASK_CHECK_COMMANDS\t(1 << 2)\n\n \n\nenum ipmi_smi_msg_type {\n\tIPMI_SMI_MSG_TYPE_NORMAL = 0,\n\tIPMI_SMI_MSG_TYPE_IPMB_DIRECT\n};\n\n \nstruct ipmi_smi_msg {\n\tstruct list_head link;\n\n\tenum ipmi_smi_msg_type type;\n\n\tlong    msgid;\n\tvoid    *user_data;\n\n\tint           data_size;\n\tunsigned char data[IPMI_MAX_MSG_LENGTH];\n\n\tint           rsp_size;\n\tunsigned char rsp[IPMI_MAX_MSG_LENGTH];\n\n\t \n\tvoid (*done)(struct ipmi_smi_msg *msg);\n};\n\n#define INIT_IPMI_SMI_MSG(done_handler) \\\n{\t\t\t\t\t\t\\\n\t.done = done_handler,\t\t\t\\\n\t.type = IPMI_SMI_MSG_TYPE_NORMAL\t\\\n}\n\nstruct ipmi_smi_handlers {\n\tstruct module *owner;\n\n\t \n#define IPMI_SMI_CAN_HANDLE_IPMB_DIRECT\t\t(1 << 0)\n\tunsigned int flags;\n\n\t \n\tint (*start_processing)(void            *send_info,\n\t\t\t\tstruct ipmi_smi *new_intf);\n\n\t \n\tvoid (*shutdown)(void *send_info);\n\n\t \n\tint (*get_smi_info)(void *send_info, struct ipmi_smi_info *data);\n\n\t \n\tvoid (*sender)(void                *send_info,\n\t\t       struct ipmi_smi_msg *msg);\n\n\t \n\tvoid (*request_events)(void *send_info);\n\n\t \n\tvoid (*set_need_watch)(void *send_info, unsigned int watch_mask);\n\n\t \n\tvoid (*flush_messages)(void *send_info);\n\n\t \n\tvoid (*set_run_to_completion)(void *send_info, bool run_to_completion);\n\n\t \n\tvoid (*poll)(void *send_info);\n\n\t \n\tvoid (*set_maintenance_mode)(void *send_info, bool enable);\n};\n\nstruct ipmi_device_id {\n\tunsigned char device_id;\n\tunsigned char device_revision;\n\tunsigned char firmware_revision_1;\n\tunsigned char firmware_revision_2;\n\tunsigned char ipmi_version;\n\tunsigned char additional_device_support;\n\tunsigned int  manufacturer_id;\n\tunsigned int  product_id;\n\tunsigned char aux_firmware_revision[4];\n\tunsigned int  aux_firmware_revision_set : 1;\n};\n\n#define ipmi_version_major(v) ((v)->ipmi_version & 0xf)\n#define ipmi_version_minor(v) ((v)->ipmi_version >> 4)\n\n \nstatic inline int ipmi_demangle_device_id(uint8_t netfn, uint8_t cmd,\n\t\t\t\t\t  const unsigned char *data,\n\t\t\t\t\t  unsigned int data_len,\n\t\t\t\t\t  struct ipmi_device_id *id)\n{\n\tif (data_len < 7)\n\t\treturn -EINVAL;\n\tif (netfn != IPMI_NETFN_APP_RESPONSE || cmd != IPMI_GET_DEVICE_ID_CMD)\n\t\t \n\t\treturn -EINVAL;\n\tif (data[0] != 0)\n\t\t \n\t\treturn -EINVAL;\n\n\tdata++;\n\tdata_len--;\n\n\tid->device_id = data[0];\n\tid->device_revision = data[1];\n\tid->firmware_revision_1 = data[2];\n\tid->firmware_revision_2 = data[3];\n\tid->ipmi_version = data[4];\n\tid->additional_device_support = data[5];\n\tif (data_len >= 11) {\n\t\tid->manufacturer_id = (data[6] | (data[7] << 8) |\n\t\t\t\t       (data[8] << 16));\n\t\tid->product_id = data[9] | (data[10] << 8);\n\t} else {\n\t\tid->manufacturer_id = 0;\n\t\tid->product_id = 0;\n\t}\n\tif (data_len >= 15) {\n\t\tmemcpy(id->aux_firmware_revision, data+11, 4);\n\t\tid->aux_firmware_revision_set = 1;\n\t} else\n\t\tid->aux_firmware_revision_set = 0;\n\n\treturn 0;\n}\n\n \nint ipmi_add_smi(struct module            *owner,\n\t\t const struct ipmi_smi_handlers *handlers,\n\t\t void                     *send_info,\n\t\t struct device            *dev,\n\t\t unsigned char            slave_addr);\n\n#define ipmi_register_smi(handlers, send_info, dev, slave_addr) \\\n\tipmi_add_smi(THIS_MODULE, handlers, send_info, dev, slave_addr)\n\n \nvoid ipmi_unregister_smi(struct ipmi_smi *intf);\n\n \nvoid ipmi_smi_msg_received(struct ipmi_smi     *intf,\n\t\t\t   struct ipmi_smi_msg *msg);\n\n \nvoid ipmi_smi_watchdog_pretimeout(struct ipmi_smi *intf);\n\nstruct ipmi_smi_msg *ipmi_alloc_smi_msg(void);\nstatic inline void ipmi_free_smi_msg(struct ipmi_smi_msg *msg)\n{\n\tmsg->done(msg);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}