{
  "module_name": "libnvdimm.h",
  "hash_id": "a7e959c1f8c18a6c0f501bb7e3079b06b378aeac24038d0748fc4f7f39578348",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/libnvdimm.h",
  "human_readable_source": " \n \n#ifndef __LIBNVDIMM_H__\n#define __LIBNVDIMM_H__\n#include <linux/kernel.h>\n#include <linux/sizes.h>\n#include <linux/types.h>\n#include <linux/uuid.h>\n#include <linux/spinlock.h>\n#include <linux/bio.h>\n\nstruct badrange_entry {\n\tu64 start;\n\tu64 length;\n\tstruct list_head list;\n};\n\nstruct badrange {\n\tstruct list_head list;\n\tspinlock_t lock;\n};\n\nenum {\n\t \n\tNDD_UNARMED = 1,\n\t \n\tNDD_LOCKED = 2,\n\t \n\tNDD_SECURITY_OVERWRITE = 3,\n\t \n\tNDD_WORK_PENDING = 4,\n\t \n\tNDD_LABELING = 6,\n\t \n\tNDD_INCOHERENT = 7,\n\n\t \n\tNDD_REGISTER_SYNC = 8,\n\n\t \n\tND_IOCTL_MAX_BUFLEN = SZ_4M,\n\tND_CMD_MAX_ELEM = 5,\n\tND_CMD_MAX_ENVELOPE = 256,\n\tND_MAX_MAPPINGS = 32,\n\n\t \n\tND_REGION_PAGEMAP = 0,\n\t \n\tND_REGION_PERSIST_CACHE = 1,\n\t \n\tND_REGION_PERSIST_MEMCTRL = 2,\n\n\t \n\tND_REGION_ASYNC = 3,\n\n\t \n\tND_REGION_CXL = 4,\n\n\t \n\tDPA_RESOURCE_ADJUSTED = 1 << 0,\n};\n\nstruct nvdimm;\nstruct nvdimm_bus_descriptor;\ntypedef int (*ndctl_fn)(struct nvdimm_bus_descriptor *nd_desc,\n\t\tstruct nvdimm *nvdimm, unsigned int cmd, void *buf,\n\t\tunsigned int buf_len, int *cmd_rc);\n\nstruct device_node;\nstruct nvdimm_bus_descriptor {\n\tconst struct attribute_group **attr_groups;\n\tunsigned long cmd_mask;\n\tunsigned long dimm_family_mask;\n\tunsigned long bus_family_mask;\n\tstruct module *module;\n\tchar *provider_name;\n\tstruct device_node *of_node;\n\tndctl_fn ndctl;\n\tint (*flush_probe)(struct nvdimm_bus_descriptor *nd_desc);\n\tint (*clear_to_send)(struct nvdimm_bus_descriptor *nd_desc,\n\t\t\tstruct nvdimm *nvdimm, unsigned int cmd, void *data);\n\tconst struct nvdimm_bus_fw_ops *fw_ops;\n};\n\nstruct nd_cmd_desc {\n\tint in_num;\n\tint out_num;\n\tu32 in_sizes[ND_CMD_MAX_ELEM];\n\tint out_sizes[ND_CMD_MAX_ELEM];\n};\n\nstruct nd_interleave_set {\n\t \n\tu64 cookie1;\n\t \n\tu64 cookie2;\n\t \n\tu64 altcookie;\n\n\tguid_t type_guid;\n};\n\nstruct nd_mapping_desc {\n\tstruct nvdimm *nvdimm;\n\tu64 start;\n\tu64 size;\n\tint position;\n};\n\nstruct nd_region;\nstruct nd_region_desc {\n\tstruct resource *res;\n\tstruct nd_mapping_desc *mapping;\n\tu16 num_mappings;\n\tconst struct attribute_group **attr_groups;\n\tstruct nd_interleave_set *nd_set;\n\tvoid *provider_data;\n\tint num_lanes;\n\tint numa_node;\n\tint target_node;\n\tunsigned long flags;\n\tint memregion;\n\tstruct device_node *of_node;\n\tint (*flush)(struct nd_region *nd_region, struct bio *bio);\n};\n\nstruct device;\nvoid *devm_nvdimm_memremap(struct device *dev, resource_size_t offset,\n\t\tsize_t size, unsigned long flags);\nstatic inline void __iomem *devm_nvdimm_ioremap(struct device *dev,\n\t\tresource_size_t offset, size_t size)\n{\n\treturn (void __iomem *) devm_nvdimm_memremap(dev, offset, size, 0);\n}\n\nstruct nvdimm_bus;\n\n \nenum nvdimm_security_bits {\n\tNVDIMM_SECURITY_DISABLED,\n\tNVDIMM_SECURITY_UNLOCKED,\n\tNVDIMM_SECURITY_LOCKED,\n\tNVDIMM_SECURITY_FROZEN,\n\tNVDIMM_SECURITY_OVERWRITE,\n};\n\n#define NVDIMM_PASSPHRASE_LEN\t\t32\n#define NVDIMM_KEY_DESC_LEN\t\t22\n\nstruct nvdimm_key_data {\n\tu8 data[NVDIMM_PASSPHRASE_LEN];\n};\n\nenum nvdimm_passphrase_type {\n\tNVDIMM_USER,\n\tNVDIMM_MASTER,\n};\n\nstruct nvdimm_security_ops {\n\tunsigned long (*get_flags)(struct nvdimm *nvdimm,\n\t\t\tenum nvdimm_passphrase_type pass_type);\n\tint (*freeze)(struct nvdimm *nvdimm);\n\tint (*change_key)(struct nvdimm *nvdimm,\n\t\t\tconst struct nvdimm_key_data *old_data,\n\t\t\tconst struct nvdimm_key_data *new_data,\n\t\t\tenum nvdimm_passphrase_type pass_type);\n\tint (*unlock)(struct nvdimm *nvdimm,\n\t\t\tconst struct nvdimm_key_data *key_data);\n\tint (*disable)(struct nvdimm *nvdimm,\n\t\t\tconst struct nvdimm_key_data *key_data);\n\tint (*erase)(struct nvdimm *nvdimm,\n\t\t\tconst struct nvdimm_key_data *key_data,\n\t\t\tenum nvdimm_passphrase_type pass_type);\n\tint (*overwrite)(struct nvdimm *nvdimm,\n\t\t\tconst struct nvdimm_key_data *key_data);\n\tint (*query_overwrite)(struct nvdimm *nvdimm);\n\tint (*disable_master)(struct nvdimm *nvdimm,\n\t\t\t      const struct nvdimm_key_data *key_data);\n};\n\nenum nvdimm_fwa_state {\n\tNVDIMM_FWA_INVALID,\n\tNVDIMM_FWA_IDLE,\n\tNVDIMM_FWA_ARMED,\n\tNVDIMM_FWA_BUSY,\n\tNVDIMM_FWA_ARM_OVERFLOW,\n};\n\nenum nvdimm_fwa_trigger {\n\tNVDIMM_FWA_ARM,\n\tNVDIMM_FWA_DISARM,\n};\n\nenum nvdimm_fwa_capability {\n\tNVDIMM_FWA_CAP_INVALID,\n\tNVDIMM_FWA_CAP_NONE,\n\tNVDIMM_FWA_CAP_QUIESCE,\n\tNVDIMM_FWA_CAP_LIVE,\n};\n\nenum nvdimm_fwa_result {\n\tNVDIMM_FWA_RESULT_INVALID,\n\tNVDIMM_FWA_RESULT_NONE,\n\tNVDIMM_FWA_RESULT_SUCCESS,\n\tNVDIMM_FWA_RESULT_NOTSTAGED,\n\tNVDIMM_FWA_RESULT_NEEDRESET,\n\tNVDIMM_FWA_RESULT_FAIL,\n};\n\nstruct nvdimm_bus_fw_ops {\n\tenum nvdimm_fwa_state (*activate_state)\n\t\t(struct nvdimm_bus_descriptor *nd_desc);\n\tenum nvdimm_fwa_capability (*capability)\n\t\t(struct nvdimm_bus_descriptor *nd_desc);\n\tint (*activate)(struct nvdimm_bus_descriptor *nd_desc);\n};\n\nstruct nvdimm_fw_ops {\n\tenum nvdimm_fwa_state (*activate_state)(struct nvdimm *nvdimm);\n\tenum nvdimm_fwa_result (*activate_result)(struct nvdimm *nvdimm);\n\tint (*arm)(struct nvdimm *nvdimm, enum nvdimm_fwa_trigger arg);\n};\n\nvoid badrange_init(struct badrange *badrange);\nint badrange_add(struct badrange *badrange, u64 addr, u64 length);\nvoid badrange_forget(struct badrange *badrange, phys_addr_t start,\n\t\tunsigned int len);\nint nvdimm_bus_add_badrange(struct nvdimm_bus *nvdimm_bus, u64 addr,\n\t\tu64 length);\nstruct nvdimm_bus *nvdimm_bus_register(struct device *parent,\n\t\tstruct nvdimm_bus_descriptor *nfit_desc);\nvoid nvdimm_bus_unregister(struct nvdimm_bus *nvdimm_bus);\nstruct nvdimm_bus *to_nvdimm_bus(struct device *dev);\nstruct nvdimm_bus *nvdimm_to_bus(struct nvdimm *nvdimm);\nstruct nvdimm *to_nvdimm(struct device *dev);\nstruct nd_region *to_nd_region(struct device *dev);\nstruct device *nd_region_dev(struct nd_region *nd_region);\nstruct nvdimm_bus_descriptor *to_nd_desc(struct nvdimm_bus *nvdimm_bus);\nstruct device *to_nvdimm_bus_dev(struct nvdimm_bus *nvdimm_bus);\nconst char *nvdimm_name(struct nvdimm *nvdimm);\nstruct kobject *nvdimm_kobj(struct nvdimm *nvdimm);\nunsigned long nvdimm_cmd_mask(struct nvdimm *nvdimm);\nvoid *nvdimm_provider_data(struct nvdimm *nvdimm);\nstruct nvdimm *__nvdimm_create(struct nvdimm_bus *nvdimm_bus,\n\t\tvoid *provider_data, const struct attribute_group **groups,\n\t\tunsigned long flags, unsigned long cmd_mask, int num_flush,\n\t\tstruct resource *flush_wpq, const char *dimm_id,\n\t\tconst struct nvdimm_security_ops *sec_ops,\n\t\tconst struct nvdimm_fw_ops *fw_ops);\nstatic inline struct nvdimm *nvdimm_create(struct nvdimm_bus *nvdimm_bus,\n\t\tvoid *provider_data, const struct attribute_group **groups,\n\t\tunsigned long flags, unsigned long cmd_mask, int num_flush,\n\t\tstruct resource *flush_wpq)\n{\n\treturn __nvdimm_create(nvdimm_bus, provider_data, groups, flags,\n\t\t\tcmd_mask, num_flush, flush_wpq, NULL, NULL, NULL);\n}\nvoid nvdimm_delete(struct nvdimm *nvdimm);\nvoid nvdimm_region_delete(struct nd_region *nd_region);\n\nconst struct nd_cmd_desc *nd_cmd_dimm_desc(int cmd);\nconst struct nd_cmd_desc *nd_cmd_bus_desc(int cmd);\nu32 nd_cmd_in_size(struct nvdimm *nvdimm, int cmd,\n\t\tconst struct nd_cmd_desc *desc, int idx, void *buf);\nu32 nd_cmd_out_size(struct nvdimm *nvdimm, int cmd,\n\t\tconst struct nd_cmd_desc *desc, int idx, const u32 *in_field,\n\t\tconst u32 *out_field, unsigned long remainder);\nint nvdimm_bus_check_dimm_count(struct nvdimm_bus *nvdimm_bus, int dimm_count);\nstruct nd_region *nvdimm_pmem_region_create(struct nvdimm_bus *nvdimm_bus,\n\t\tstruct nd_region_desc *ndr_desc);\nstruct nd_region *nvdimm_blk_region_create(struct nvdimm_bus *nvdimm_bus,\n\t\tstruct nd_region_desc *ndr_desc);\nstruct nd_region *nvdimm_volatile_region_create(struct nvdimm_bus *nvdimm_bus,\n\t\tstruct nd_region_desc *ndr_desc);\nvoid *nd_region_provider_data(struct nd_region *nd_region);\nunsigned int nd_region_acquire_lane(struct nd_region *nd_region);\nvoid nd_region_release_lane(struct nd_region *nd_region, unsigned int lane);\nu64 nd_fletcher64(void *addr, size_t len, bool le);\nint nvdimm_flush(struct nd_region *nd_region, struct bio *bio);\nint generic_nvdimm_flush(struct nd_region *nd_region);\nint nvdimm_has_flush(struct nd_region *nd_region);\nint nvdimm_has_cache(struct nd_region *nd_region);\nint nvdimm_in_overwrite(struct nvdimm *nvdimm);\nbool is_nvdimm_sync(struct nd_region *nd_region);\n\nstatic inline int nvdimm_ctl(struct nvdimm *nvdimm, unsigned int cmd, void *buf,\n\t\tunsigned int buf_len, int *cmd_rc)\n{\n\tstruct nvdimm_bus *nvdimm_bus = nvdimm_to_bus(nvdimm);\n\tstruct nvdimm_bus_descriptor *nd_desc = to_nd_desc(nvdimm_bus);\n\n\treturn nd_desc->ndctl(nd_desc, nvdimm, cmd, buf, buf_len, cmd_rc);\n}\n\n#ifdef CONFIG_ARCH_HAS_PMEM_API\n#define ARCH_MEMREMAP_PMEM MEMREMAP_WB\nvoid arch_wb_cache_pmem(void *addr, size_t size);\nvoid arch_invalidate_pmem(void *addr, size_t size);\n#else\n#define ARCH_MEMREMAP_PMEM MEMREMAP_WT\nstatic inline void arch_wb_cache_pmem(void *addr, size_t size)\n{\n}\nstatic inline void arch_invalidate_pmem(void *addr, size_t size)\n{\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}