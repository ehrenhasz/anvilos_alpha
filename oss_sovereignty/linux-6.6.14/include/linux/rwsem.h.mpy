{
  "module_name": "rwsem.h",
  "hash_id": "bbcc51714e41d8688808a5d8330afc7741ed26790c90544d3267dff8fa4c92e1",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/rwsem.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_RWSEM_H\n#define _LINUX_RWSEM_H\n\n#include <linux/linkage.h>\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/atomic.h>\n#include <linux/err.h>\n#include <linux/cleanup.h>\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n# define __RWSEM_DEP_MAP_INIT(lockname)\t\t\t\\\n\t.dep_map = {\t\t\t\t\t\\\n\t\t.name = #lockname,\t\t\t\\\n\t\t.wait_type_inner = LD_WAIT_SLEEP,\t\\\n\t},\n#else\n# define __RWSEM_DEP_MAP_INIT(lockname)\n#endif\n\n#ifndef CONFIG_PREEMPT_RT\n\n#ifdef CONFIG_RWSEM_SPIN_ON_OWNER\n#include <linux/osq_lock.h>\n#endif\n\n \nstruct rw_semaphore {\n\tatomic_long_t count;\n\t \n\tatomic_long_t owner;\n#ifdef CONFIG_RWSEM_SPIN_ON_OWNER\n\tstruct optimistic_spin_queue osq;  \n#endif\n\traw_spinlock_t wait_lock;\n\tstruct list_head wait_list;\n#ifdef CONFIG_DEBUG_RWSEMS\n\tvoid *magic;\n#endif\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tstruct lockdep_map\tdep_map;\n#endif\n};\n\n \nstatic inline int rwsem_is_locked(struct rw_semaphore *sem)\n{\n\treturn atomic_long_read(&sem->count) != 0;\n}\n\n#define RWSEM_UNLOCKED_VALUE\t\t0L\n#define __RWSEM_COUNT_INIT(name)\t.count = ATOMIC_LONG_INIT(RWSEM_UNLOCKED_VALUE)\n\n \n\n#ifdef CONFIG_DEBUG_RWSEMS\n# define __RWSEM_DEBUG_INIT(lockname) .magic = &lockname,\n#else\n# define __RWSEM_DEBUG_INIT(lockname)\n#endif\n\n#ifdef CONFIG_RWSEM_SPIN_ON_OWNER\n#define __RWSEM_OPT_INIT(lockname) .osq = OSQ_LOCK_UNLOCKED,\n#else\n#define __RWSEM_OPT_INIT(lockname)\n#endif\n\n#define __RWSEM_INITIALIZER(name)\t\t\t\t\\\n\t{ __RWSEM_COUNT_INIT(name),\t\t\t\t\\\n\t  .owner = ATOMIC_LONG_INIT(0),\t\t\t\t\\\n\t  __RWSEM_OPT_INIT(name)\t\t\t\t\\\n\t  .wait_lock = __RAW_SPIN_LOCK_UNLOCKED(name.wait_lock),\\\n\t  .wait_list = LIST_HEAD_INIT((name).wait_list),\t\\\n\t  __RWSEM_DEBUG_INIT(name)\t\t\t\t\\\n\t  __RWSEM_DEP_MAP_INIT(name) }\n\n#define DECLARE_RWSEM(name) \\\n\tstruct rw_semaphore name = __RWSEM_INITIALIZER(name)\n\nextern void __init_rwsem(struct rw_semaphore *sem, const char *name,\n\t\t\t struct lock_class_key *key);\n\n#define init_rwsem(sem)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n} while (0)\n\n \nstatic inline int rwsem_is_contended(struct rw_semaphore *sem)\n{\n\treturn !list_empty(&sem->wait_list);\n}\n\n#else  \n\n#include <linux/rwbase_rt.h>\n\nstruct rw_semaphore {\n\tstruct rwbase_rt\trwbase;\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tstruct lockdep_map\tdep_map;\n#endif\n};\n\n#define __RWSEM_INITIALIZER(name)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.rwbase = __RWBASE_INITIALIZER(name),\t\t\\\n\t\t__RWSEM_DEP_MAP_INIT(name)\t\t\t\\\n\t}\n\n#define DECLARE_RWSEM(lockname) \\\n\tstruct rw_semaphore lockname = __RWSEM_INITIALIZER(lockname)\n\nextern void  __init_rwsem(struct rw_semaphore *rwsem, const char *name,\n\t\t\t  struct lock_class_key *key);\n\n#define init_rwsem(sem)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n} while (0)\n\nstatic __always_inline int rwsem_is_locked(struct rw_semaphore *sem)\n{\n\treturn rw_base_is_locked(&sem->rwbase);\n}\n\nstatic __always_inline int rwsem_is_contended(struct rw_semaphore *sem)\n{\n\treturn rw_base_is_contended(&sem->rwbase);\n}\n\n#endif  \n\n \n\n \nextern void down_read(struct rw_semaphore *sem);\nextern int __must_check down_read_interruptible(struct rw_semaphore *sem);\nextern int __must_check down_read_killable(struct rw_semaphore *sem);\n\n \nextern int down_read_trylock(struct rw_semaphore *sem);\n\n \nextern void down_write(struct rw_semaphore *sem);\nextern int __must_check down_write_killable(struct rw_semaphore *sem);\n\n \nextern int down_write_trylock(struct rw_semaphore *sem);\n\n \nextern void up_read(struct rw_semaphore *sem);\n\n \nextern void up_write(struct rw_semaphore *sem);\n\nDEFINE_GUARD(rwsem_read, struct rw_semaphore *, down_read(_T), up_read(_T))\nDEFINE_GUARD(rwsem_write, struct rw_semaphore *, down_write(_T), up_write(_T))\n\nDEFINE_FREE(up_read, struct rw_semaphore *, if (_T) up_read(_T))\nDEFINE_FREE(up_write, struct rw_semaphore *, if (_T) up_write(_T))\n\n\n \nextern void downgrade_write(struct rw_semaphore *sem);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n \nextern void down_read_nested(struct rw_semaphore *sem, int subclass);\nextern int __must_check down_read_killable_nested(struct rw_semaphore *sem, int subclass);\nextern void down_write_nested(struct rw_semaphore *sem, int subclass);\nextern int down_write_killable_nested(struct rw_semaphore *sem, int subclass);\nextern void _down_write_nest_lock(struct rw_semaphore *sem, struct lockdep_map *nest_lock);\n\n# define down_write_nest_lock(sem, nest_lock)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\ttypecheck(struct lockdep_map *, &(nest_lock)->dep_map);\t\\\n\t_down_write_nest_lock(sem, &(nest_lock)->dep_map);\t\\\n} while (0)\n\n \nextern void down_read_non_owner(struct rw_semaphore *sem);\nextern void up_read_non_owner(struct rw_semaphore *sem);\n#else\n# define down_read_nested(sem, subclass)\t\tdown_read(sem)\n# define down_read_killable_nested(sem, subclass)\tdown_read_killable(sem)\n# define down_write_nest_lock(sem, nest_lock)\tdown_write(sem)\n# define down_write_nested(sem, subclass)\tdown_write(sem)\n# define down_write_killable_nested(sem, subclass)\tdown_write_killable(sem)\n# define down_read_non_owner(sem)\t\tdown_read(sem)\n# define up_read_non_owner(sem)\t\t\tup_read(sem)\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}