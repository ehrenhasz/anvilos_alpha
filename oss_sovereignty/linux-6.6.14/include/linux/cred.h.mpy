{
  "module_name": "cred.h",
  "hash_id": "a0b0c82b10406170c3094479a0c63b57f1d126e122d3e3b2ccd391bfcf0274cf",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/cred.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_CRED_H\n#define _LINUX_CRED_H\n\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/key.h>\n#include <linux/atomic.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n\nstruct cred;\nstruct inode;\n\n \nstruct group_info {\n\tatomic_t\tusage;\n\tint\t\tngroups;\n\tkgid_t\t\tgid[];\n} __randomize_layout;\n\n \nstatic inline struct group_info *get_group_info(struct group_info *gi)\n{\n\tatomic_inc(&gi->usage);\n\treturn gi;\n}\n\n \n#define put_group_info(group_info)\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (atomic_dec_and_test(&(group_info)->usage))\t\\\n\t\tgroups_free(group_info);\t\t\\\n} while (0)\n\n#ifdef CONFIG_MULTIUSER\nextern struct group_info *groups_alloc(int);\nextern void groups_free(struct group_info *);\n\nextern int in_group_p(kgid_t);\nextern int in_egroup_p(kgid_t);\nextern int groups_search(const struct group_info *, kgid_t);\n\nextern int set_current_groups(struct group_info *);\nextern void set_groups(struct cred *, struct group_info *);\nextern bool may_setgroups(void);\nextern void groups_sort(struct group_info *);\n#else\nstatic inline void groups_free(struct group_info *group_info)\n{\n}\n\nstatic inline int in_group_p(kgid_t grp)\n{\n        return 1;\n}\nstatic inline int in_egroup_p(kgid_t grp)\n{\n        return 1;\n}\nstatic inline int groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\treturn 1;\n}\n#endif\n\n \nstruct cred {\n\tatomic_long_t\tusage;\n\tkuid_t\t\tuid;\t\t \n\tkgid_t\t\tgid;\t\t \n\tkuid_t\t\tsuid;\t\t \n\tkgid_t\t\tsgid;\t\t \n\tkuid_t\t\teuid;\t\t \n\tkgid_t\t\tegid;\t\t \n\tkuid_t\t\tfsuid;\t\t \n\tkgid_t\t\tfsgid;\t\t \n\tunsigned\tsecurebits;\t \n\tkernel_cap_t\tcap_inheritable;  \n\tkernel_cap_t\tcap_permitted;\t \n\tkernel_cap_t\tcap_effective;\t \n\tkernel_cap_t\tcap_bset;\t \n\tkernel_cap_t\tcap_ambient;\t \n#ifdef CONFIG_KEYS\n\tunsigned char\tjit_keyring;\t \n\tstruct key\t*session_keyring;  \n\tstruct key\t*process_keyring;  \n\tstruct key\t*thread_keyring;  \n\tstruct key\t*request_key_auth;  \n#endif\n#ifdef CONFIG_SECURITY\n\tvoid\t\t*security;\t \n#endif\n\tstruct user_struct *user;\t \n\tstruct user_namespace *user_ns;  \n\tstruct ucounts *ucounts;\n\tstruct group_info *group_info;\t \n\t \n\tunion {\n\t\tint non_rcu;\t\t\t \n\t\tstruct rcu_head\trcu;\t\t \n\t};\n} __randomize_layout;\n\nextern void __put_cred(struct cred *);\nextern void exit_creds(struct task_struct *);\nextern int copy_creds(struct task_struct *, unsigned long);\nextern const struct cred *get_task_cred(struct task_struct *);\nextern struct cred *cred_alloc_blank(void);\nextern struct cred *prepare_creds(void);\nextern struct cred *prepare_exec_creds(void);\nextern int commit_creds(struct cred *);\nextern void abort_creds(struct cred *);\nextern const struct cred *override_creds(const struct cred *);\nextern void revert_creds(const struct cred *);\nextern struct cred *prepare_kernel_cred(struct task_struct *);\nextern int set_security_override(struct cred *, u32);\nextern int set_security_override_from_ctx(struct cred *, const char *);\nextern int set_create_files_as(struct cred *, struct inode *);\nextern int cred_fscmp(const struct cred *, const struct cred *);\nextern void __init cred_init(void);\nextern int set_cred_ucounts(struct cred *);\n\nstatic inline bool cap_ambient_invariant_ok(const struct cred *cred)\n{\n\treturn cap_issubset(cred->cap_ambient,\n\t\t\t    cap_intersect(cred->cap_permitted,\n\t\t\t\t\t  cred->cap_inheritable));\n}\n\n \nstatic inline struct cred *get_new_cred(struct cred *cred)\n{\n\tatomic_long_inc(&cred->usage);\n\treturn cred;\n}\n\n \nstatic inline const struct cred *get_cred(const struct cred *cred)\n{\n\tstruct cred *nonconst_cred = (struct cred *) cred;\n\tif (!cred)\n\t\treturn cred;\n\tnonconst_cred->non_rcu = 0;\n\treturn get_new_cred(nonconst_cred);\n}\n\nstatic inline const struct cred *get_cred_rcu(const struct cred *cred)\n{\n\tstruct cred *nonconst_cred = (struct cred *) cred;\n\tif (!cred)\n\t\treturn NULL;\n\tif (!atomic_long_inc_not_zero(&nonconst_cred->usage))\n\t\treturn NULL;\n\tnonconst_cred->non_rcu = 0;\n\treturn cred;\n}\n\n \nstatic inline void put_cred(const struct cred *_cred)\n{\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tif (cred) {\n\t\tif (atomic_long_dec_and_test(&(cred)->usage))\n\t\t\t__put_cred(cred);\n\t}\n}\n\n \n#define current_cred() \\\n\trcu_dereference_protected(current->cred, 1)\n\n \n#define current_real_cred() \\\n\trcu_dereference_protected(current->real_cred, 1)\n\n \n#define __task_cred(task)\t\\\n\trcu_dereference((task)->real_cred)\n\n \n#define get_current_cred()\t\t\t\t\\\n\t(get_cred(current_cred()))\n\n \n#define get_current_user()\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tstruct user_struct *__u;\t\t\t\\\n\tconst struct cred *__cred;\t\t\t\\\n\t__cred = current_cred();\t\t\t\\\n\t__u = get_uid(__cred->user);\t\t\t\\\n\t__u;\t\t\t\t\t\t\\\n})\n\n \n#define get_current_groups()\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tstruct group_info *__groups;\t\t\t\\\n\tconst struct cred *__cred;\t\t\t\\\n\t__cred = current_cred();\t\t\t\\\n\t__groups = get_group_info(__cred->group_info);\t\\\n\t__groups;\t\t\t\t\t\\\n})\n\n#define task_cred_xxx(task, xxx)\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\t__typeof__(((struct cred *)NULL)->xxx) ___val;\t\\\n\trcu_read_lock();\t\t\t\t\\\n\t___val = __task_cred((task))->xxx;\t\t\\\n\trcu_read_unlock();\t\t\t\t\\\n\t___val;\t\t\t\t\t\t\\\n})\n\n#define task_uid(task)\t\t(task_cred_xxx((task), uid))\n#define task_euid(task)\t\t(task_cred_xxx((task), euid))\n#define task_ucounts(task)\t(task_cred_xxx((task), ucounts))\n\n#define current_cred_xxx(xxx)\t\t\t\\\n({\t\t\t\t\t\t\\\n\tcurrent_cred()->xxx;\t\t\t\\\n})\n\n#define current_uid()\t\t(current_cred_xxx(uid))\n#define current_gid()\t\t(current_cred_xxx(gid))\n#define current_euid()\t\t(current_cred_xxx(euid))\n#define current_egid()\t\t(current_cred_xxx(egid))\n#define current_suid()\t\t(current_cred_xxx(suid))\n#define current_sgid()\t\t(current_cred_xxx(sgid))\n#define current_fsuid() \t(current_cred_xxx(fsuid))\n#define current_fsgid() \t(current_cred_xxx(fsgid))\n#define current_cap()\t\t(current_cred_xxx(cap_effective))\n#define current_user()\t\t(current_cred_xxx(user))\n#define current_ucounts()\t(current_cred_xxx(ucounts))\n\nextern struct user_namespace init_user_ns;\n#ifdef CONFIG_USER_NS\n#define current_user_ns()\t(current_cred_xxx(user_ns))\n#else\nstatic inline struct user_namespace *current_user_ns(void)\n{\n\treturn &init_user_ns;\n}\n#endif\n\n\n#define current_uid_gid(_uid, _gid)\t\t\\\ndo {\t\t\t\t\t\t\\\n\tconst struct cred *__cred;\t\t\\\n\t__cred = current_cred();\t\t\\\n\t*(_uid) = __cred->uid;\t\t\t\\\n\t*(_gid) = __cred->gid;\t\t\t\\\n} while(0)\n\n#define current_euid_egid(_euid, _egid)\t\t\\\ndo {\t\t\t\t\t\t\\\n\tconst struct cred *__cred;\t\t\\\n\t__cred = current_cred();\t\t\\\n\t*(_euid) = __cred->euid;\t\t\\\n\t*(_egid) = __cred->egid;\t\t\\\n} while(0)\n\n#define current_fsuid_fsgid(_fsuid, _fsgid)\t\\\ndo {\t\t\t\t\t\t\\\n\tconst struct cred *__cred;\t\t\\\n\t__cred = current_cred();\t\t\\\n\t*(_fsuid) = __cred->fsuid;\t\t\\\n\t*(_fsgid) = __cred->fsgid;\t\t\\\n} while(0)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}