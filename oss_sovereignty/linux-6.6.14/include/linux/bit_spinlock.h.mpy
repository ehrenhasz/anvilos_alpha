{
  "module_name": "bit_spinlock.h",
  "hash_id": "9a8b20692074f3bb167927b1d612c2f916189c6097c9758304c8aac8131f9510",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/bit_spinlock.h",
  "human_readable_source": " \n#ifndef __LINUX_BIT_SPINLOCK_H\n#define __LINUX_BIT_SPINLOCK_H\n\n#include <linux/kernel.h>\n#include <linux/preempt.h>\n#include <linux/atomic.h>\n#include <linux/bug.h>\n\n \nstatic inline void bit_spin_lock(int bitnum, unsigned long *addr)\n{\n\t \n\tpreempt_disable();\n#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n\twhile (unlikely(test_and_set_bit_lock(bitnum, addr))) {\n\t\tpreempt_enable();\n\t\tdo {\n\t\t\tcpu_relax();\n\t\t} while (test_bit(bitnum, addr));\n\t\tpreempt_disable();\n\t}\n#endif\n\t__acquire(bitlock);\n}\n\n \nstatic inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n{\n\tpreempt_disable();\n#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n\tif (unlikely(test_and_set_bit_lock(bitnum, addr))) {\n\t\tpreempt_enable();\n\t\treturn 0;\n\t}\n#endif\n\t__acquire(bitlock);\n\treturn 1;\n}\n\n \nstatic inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n{\n#ifdef CONFIG_DEBUG_SPINLOCK\n\tBUG_ON(!test_bit(bitnum, addr));\n#endif\n#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n\tclear_bit_unlock(bitnum, addr);\n#endif\n\tpreempt_enable();\n\t__release(bitlock);\n}\n\n \nstatic inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n{\n#ifdef CONFIG_DEBUG_SPINLOCK\n\tBUG_ON(!test_bit(bitnum, addr));\n#endif\n#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n\t__clear_bit_unlock(bitnum, addr);\n#endif\n\tpreempt_enable();\n\t__release(bitlock);\n}\n\n \nstatic inline int bit_spin_is_locked(int bitnum, unsigned long *addr)\n{\n#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n\treturn test_bit(bitnum, addr);\n#elif defined CONFIG_PREEMPT_COUNT\n\treturn preempt_count();\n#else\n\treturn 1;\n#endif\n}\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}