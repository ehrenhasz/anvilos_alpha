{
  "module_name": "scatterlist.h",
  "hash_id": "c060300ec5dfb4f850d0e1971b6094f81db9e09573d0b2d239f9f5dd916bbc48",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/scatterlist.h",
  "human_readable_source": " \n#ifndef _LINUX_SCATTERLIST_H\n#define _LINUX_SCATTERLIST_H\n\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/bug.h>\n#include <linux/mm.h>\n#include <asm/io.h>\n\nstruct scatterlist {\n\tunsigned long\tpage_link;\n\tunsigned int\toffset;\n\tunsigned int\tlength;\n\tdma_addr_t\tdma_address;\n#ifdef CONFIG_NEED_SG_DMA_LENGTH\n\tunsigned int\tdma_length;\n#endif\n#ifdef CONFIG_NEED_SG_DMA_FLAGS\n\tunsigned int    dma_flags;\n#endif\n};\n\n \n#define sg_dma_address(sg)\t((sg)->dma_address)\n\n#ifdef CONFIG_NEED_SG_DMA_LENGTH\n#define sg_dma_len(sg)\t\t((sg)->dma_length)\n#else\n#define sg_dma_len(sg)\t\t((sg)->length)\n#endif\n\nstruct sg_table {\n\tstruct scatterlist *sgl;\t \n\tunsigned int nents;\t\t \n\tunsigned int orig_nents;\t \n};\n\nstruct sg_append_table {\n\tstruct sg_table sgt;\t\t \n\tstruct scatterlist *prv;\t \n\tunsigned int total_nents;\t \n};\n\n \n\n#define SG_CHAIN\t0x01UL\n#define SG_END\t\t0x02UL\n\n \n#define SG_PAGE_LINK_MASK (SG_CHAIN | SG_END)\n\nstatic inline unsigned int __sg_flags(struct scatterlist *sg)\n{\n\treturn sg->page_link & SG_PAGE_LINK_MASK;\n}\n\nstatic inline struct scatterlist *sg_chain_ptr(struct scatterlist *sg)\n{\n\treturn (struct scatterlist *)(sg->page_link & ~SG_PAGE_LINK_MASK);\n}\n\nstatic inline bool sg_is_chain(struct scatterlist *sg)\n{\n\treturn __sg_flags(sg) & SG_CHAIN;\n}\n\nstatic inline bool sg_is_last(struct scatterlist *sg)\n{\n\treturn __sg_flags(sg) & SG_END;\n}\n\n \nstatic inline void sg_assign_page(struct scatterlist *sg, struct page *page)\n{\n\tunsigned long page_link = sg->page_link & (SG_CHAIN | SG_END);\n\n\t \n\tBUG_ON((unsigned long)page & SG_PAGE_LINK_MASK);\n#ifdef CONFIG_DEBUG_SG\n\tBUG_ON(sg_is_chain(sg));\n#endif\n\tsg->page_link = page_link | (unsigned long) page;\n}\n\n \nstatic inline void sg_set_page(struct scatterlist *sg, struct page *page,\n\t\t\t       unsigned int len, unsigned int offset)\n{\n\tsg_assign_page(sg, page);\n\tsg->offset = offset;\n\tsg->length = len;\n}\n\n \nstatic inline void sg_set_folio(struct scatterlist *sg, struct folio *folio,\n\t\t\t       size_t len, size_t offset)\n{\n\tWARN_ON_ONCE(len > UINT_MAX);\n\tWARN_ON_ONCE(offset > UINT_MAX);\n\tsg_assign_page(sg, &folio->page);\n\tsg->offset = offset;\n\tsg->length = len;\n}\n\nstatic inline struct page *sg_page(struct scatterlist *sg)\n{\n#ifdef CONFIG_DEBUG_SG\n\tBUG_ON(sg_is_chain(sg));\n#endif\n\treturn (struct page *)((sg)->page_link & ~SG_PAGE_LINK_MASK);\n}\n\n \nstatic inline void sg_set_buf(struct scatterlist *sg, const void *buf,\n\t\t\t      unsigned int buflen)\n{\n#ifdef CONFIG_DEBUG_SG\n\tBUG_ON(!virt_addr_valid(buf));\n#endif\n\tsg_set_page(sg, virt_to_page(buf), buflen, offset_in_page(buf));\n}\n\n \n#define for_each_sg(sglist, sg, nr, __i)\t\\\n\tfor (__i = 0, sg = (sglist); __i < (nr); __i++, sg = sg_next(sg))\n\n \n#define for_each_sgtable_sg(sgt, sg, i)\t\t\\\n\tfor_each_sg((sgt)->sgl, sg, (sgt)->orig_nents, i)\n\n \n#define for_each_sgtable_dma_sg(sgt, sg, i)\t\\\n\tfor_each_sg((sgt)->sgl, sg, (sgt)->nents, i)\n\nstatic inline void __sg_chain(struct scatterlist *chain_sg,\n\t\t\t      struct scatterlist *sgl)\n{\n\t \n\tchain_sg->offset = 0;\n\tchain_sg->length = 0;\n\n\t \n\tchain_sg->page_link = ((unsigned long) sgl | SG_CHAIN) & ~SG_END;\n}\n\n \nstatic inline void sg_chain(struct scatterlist *prv, unsigned int prv_nents,\n\t\t\t    struct scatterlist *sgl)\n{\n\t__sg_chain(&prv[prv_nents - 1], sgl);\n}\n\n \nstatic inline void sg_mark_end(struct scatterlist *sg)\n{\n\t \n\tsg->page_link |= SG_END;\n\tsg->page_link &= ~SG_CHAIN;\n}\n\n \nstatic inline void sg_unmark_end(struct scatterlist *sg)\n{\n\tsg->page_link &= ~SG_END;\n}\n\n \n#ifdef CONFIG_NEED_SG_DMA_FLAGS\n\n#define SG_DMA_BUS_ADDRESS\t(1 << 0)\n#define SG_DMA_SWIOTLB\t\t(1 << 1)\n\n \nstatic inline bool sg_dma_is_bus_address(struct scatterlist *sg)\n{\n\treturn sg->dma_flags & SG_DMA_BUS_ADDRESS;\n}\n\n \nstatic inline void sg_dma_mark_bus_address(struct scatterlist *sg)\n{\n\tsg->dma_flags |= SG_DMA_BUS_ADDRESS;\n}\n\n \nstatic inline void sg_dma_unmark_bus_address(struct scatterlist *sg)\n{\n\tsg->dma_flags &= ~SG_DMA_BUS_ADDRESS;\n}\n\n \nstatic inline bool sg_dma_is_swiotlb(struct scatterlist *sg)\n{\n\treturn sg->dma_flags & SG_DMA_SWIOTLB;\n}\n\n \nstatic inline void sg_dma_mark_swiotlb(struct scatterlist *sg)\n{\n\tsg->dma_flags |= SG_DMA_SWIOTLB;\n}\n\n#else\n\nstatic inline bool sg_dma_is_bus_address(struct scatterlist *sg)\n{\n\treturn false;\n}\nstatic inline void sg_dma_mark_bus_address(struct scatterlist *sg)\n{\n}\nstatic inline void sg_dma_unmark_bus_address(struct scatterlist *sg)\n{\n}\nstatic inline bool sg_dma_is_swiotlb(struct scatterlist *sg)\n{\n\treturn false;\n}\nstatic inline void sg_dma_mark_swiotlb(struct scatterlist *sg)\n{\n}\n\n#endif\t \n\n \nstatic inline dma_addr_t sg_phys(struct scatterlist *sg)\n{\n\treturn page_to_phys(sg_page(sg)) + sg->offset;\n}\n\n \nstatic inline void *sg_virt(struct scatterlist *sg)\n{\n\treturn page_address(sg_page(sg)) + sg->offset;\n}\n\n \nstatic inline void sg_init_marker(struct scatterlist *sgl,\n\t\t\t\t  unsigned int nents)\n{\n\tsg_mark_end(&sgl[nents - 1]);\n}\n\nint sg_nents(struct scatterlist *sg);\nint sg_nents_for_len(struct scatterlist *sg, u64 len);\nstruct scatterlist *sg_next(struct scatterlist *);\nstruct scatterlist *sg_last(struct scatterlist *s, unsigned int);\nvoid sg_init_table(struct scatterlist *, unsigned int);\nvoid sg_init_one(struct scatterlist *, const void *, unsigned int);\nint sg_split(struct scatterlist *in, const int in_mapped_nents,\n\t     const off_t skip, const int nb_splits,\n\t     const size_t *split_sizes,\n\t     struct scatterlist **out, int *out_mapped_nents,\n\t     gfp_t gfp_mask);\n\ntypedef struct scatterlist *(sg_alloc_fn)(unsigned int, gfp_t);\ntypedef void (sg_free_fn)(struct scatterlist *, unsigned int);\n\nvoid __sg_free_table(struct sg_table *, unsigned int, unsigned int,\n\t\t     sg_free_fn *, unsigned int);\nvoid sg_free_table(struct sg_table *);\nvoid sg_free_append_table(struct sg_append_table *sgt);\nint __sg_alloc_table(struct sg_table *, unsigned int, unsigned int,\n\t\t     struct scatterlist *, unsigned int, gfp_t, sg_alloc_fn *);\nint sg_alloc_table(struct sg_table *, unsigned int, gfp_t);\nint sg_alloc_append_table_from_pages(struct sg_append_table *sgt,\n\t\t\t\t     struct page **pages, unsigned int n_pages,\n\t\t\t\t     unsigned int offset, unsigned long size,\n\t\t\t\t     unsigned int max_segment,\n\t\t\t\t     unsigned int left_pages, gfp_t gfp_mask);\nint sg_alloc_table_from_pages_segment(struct sg_table *sgt, struct page **pages,\n\t\t\t\t      unsigned int n_pages, unsigned int offset,\n\t\t\t\t      unsigned long size,\n\t\t\t\t      unsigned int max_segment, gfp_t gfp_mask);\n\n \nstatic inline int sg_alloc_table_from_pages(struct sg_table *sgt,\n\t\t\t\t\t    struct page **pages,\n\t\t\t\t\t    unsigned int n_pages,\n\t\t\t\t\t    unsigned int offset,\n\t\t\t\t\t    unsigned long size, gfp_t gfp_mask)\n{\n\treturn sg_alloc_table_from_pages_segment(sgt, pages, n_pages, offset,\n\t\t\t\t\t\t size, UINT_MAX, gfp_mask);\n}\n\n#ifdef CONFIG_SGL_ALLOC\nstruct scatterlist *sgl_alloc_order(unsigned long long length,\n\t\t\t\t    unsigned int order, bool chainable,\n\t\t\t\t    gfp_t gfp, unsigned int *nent_p);\nstruct scatterlist *sgl_alloc(unsigned long long length, gfp_t gfp,\n\t\t\t      unsigned int *nent_p);\nvoid sgl_free_n_order(struct scatterlist *sgl, int nents, int order);\nvoid sgl_free_order(struct scatterlist *sgl, int order);\nvoid sgl_free(struct scatterlist *sgl);\n#endif  \n\nsize_t sg_copy_buffer(struct scatterlist *sgl, unsigned int nents, void *buf,\n\t\t      size_t buflen, off_t skip, bool to_buffer);\n\nsize_t sg_copy_from_buffer(struct scatterlist *sgl, unsigned int nents,\n\t\t\t   const void *buf, size_t buflen);\nsize_t sg_copy_to_buffer(struct scatterlist *sgl, unsigned int nents,\n\t\t\t void *buf, size_t buflen);\n\nsize_t sg_pcopy_from_buffer(struct scatterlist *sgl, unsigned int nents,\n\t\t\t    const void *buf, size_t buflen, off_t skip);\nsize_t sg_pcopy_to_buffer(struct scatterlist *sgl, unsigned int nents,\n\t\t\t  void *buf, size_t buflen, off_t skip);\nsize_t sg_zero_buffer(struct scatterlist *sgl, unsigned int nents,\n\t\t       size_t buflen, off_t skip);\n\n \n#define SG_MAX_SINGLE_ALLOC\t\t(PAGE_SIZE / sizeof(struct scatterlist))\n\n \n#define SG_CHUNK_SIZE\t128\n\n \n#ifdef CONFIG_ARCH_NO_SG_CHAIN\n#define SG_MAX_SEGMENTS\tSG_CHUNK_SIZE\n#else\n#define SG_MAX_SEGMENTS\t2048\n#endif\n\n#ifdef CONFIG_SG_POOL\nvoid sg_free_table_chained(struct sg_table *table,\n\t\t\t   unsigned nents_first_chunk);\nint sg_alloc_table_chained(struct sg_table *table, int nents,\n\t\t\t   struct scatterlist *first_chunk,\n\t\t\t   unsigned nents_first_chunk);\n#endif\n\n \nstruct sg_page_iter {\n\tstruct scatterlist\t*sg;\t\t \n\tunsigned int\t\tsg_pgoffset;\t \n\n\t \n\tunsigned int\t\t__nents;\t \n\tint\t\t\t__pg_advance;\t \n};\n\n \nstruct sg_dma_page_iter {\n\tstruct sg_page_iter base;\n};\n\nbool __sg_page_iter_next(struct sg_page_iter *piter);\nbool __sg_page_iter_dma_next(struct sg_dma_page_iter *dma_iter);\nvoid __sg_page_iter_start(struct sg_page_iter *piter,\n\t\t\t  struct scatterlist *sglist, unsigned int nents,\n\t\t\t  unsigned long pgoffset);\n \nstatic inline struct page *sg_page_iter_page(struct sg_page_iter *piter)\n{\n\treturn nth_page(sg_page(piter->sg), piter->sg_pgoffset);\n}\n\n \nstatic inline dma_addr_t\nsg_page_iter_dma_address(struct sg_dma_page_iter *dma_iter)\n{\n\treturn sg_dma_address(dma_iter->base.sg) +\n\t       (dma_iter->base.sg_pgoffset << PAGE_SHIFT);\n}\n\n \n#define for_each_sg_page(sglist, piter, nents, pgoffset)\t\t   \\\n\tfor (__sg_page_iter_start((piter), (sglist), (nents), (pgoffset)); \\\n\t     __sg_page_iter_next(piter);)\n\n \n#define for_each_sg_dma_page(sglist, dma_iter, dma_nents, pgoffset)            \\\n\tfor (__sg_page_iter_start(&(dma_iter)->base, sglist, dma_nents,        \\\n\t\t\t\t  pgoffset);                                   \\\n\t     __sg_page_iter_dma_next(dma_iter);)\n\n \n#define for_each_sgtable_page(sgt, piter, pgoffset)\t\\\n\tfor_each_sg_page((sgt)->sgl, piter, (sgt)->orig_nents, pgoffset)\n\n \n#define for_each_sgtable_dma_page(sgt, dma_iter, pgoffset)\t\\\n\tfor_each_sg_dma_page((sgt)->sgl, dma_iter, (sgt)->nents, pgoffset)\n\n\n \n\n#define SG_MITER_ATOMIC\t\t(1 << 0)\t  \n#define SG_MITER_TO_SG\t\t(1 << 1)\t \n#define SG_MITER_FROM_SG\t(1 << 2)\t \n\nstruct sg_mapping_iter {\n\t \n\tstruct page\t\t*page;\t\t \n\tvoid\t\t\t*addr;\t\t \n\tsize_t\t\t\tlength;\t\t \n\tsize_t\t\t\tconsumed;\t \n\tstruct sg_page_iter\tpiter;\t\t \n\n\t \n\tunsigned int\t\t__offset;\t \n\tunsigned int\t\t__remaining;\t \n\tunsigned int\t\t__flags;\n};\n\nvoid sg_miter_start(struct sg_mapping_iter *miter, struct scatterlist *sgl,\n\t\t    unsigned int nents, unsigned int flags);\nbool sg_miter_skip(struct sg_mapping_iter *miter, off_t offset);\nbool sg_miter_next(struct sg_mapping_iter *miter);\nvoid sg_miter_stop(struct sg_mapping_iter *miter);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}