{
  "module_name": "fsnotify_backend.h",
  "hash_id": "014615a9fc0a58ee950d68510be53964cc7025942236958dc662aa2d8d227951",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fsnotify_backend.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_FSNOTIFY_BACKEND_H\n#define __LINUX_FSNOTIFY_BACKEND_H\n\n#ifdef __KERNEL__\n\n#include <linux/idr.h>  \n#include <linux/fs.h>  \n#include <linux/list.h>\n#include <linux/path.h>  \n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/user_namespace.h>\n#include <linux/refcount.h>\n#include <linux/mempool.h>\n#include <linux/sched/mm.h>\n\n \n#define FS_ACCESS\t\t0x00000001\t \n#define FS_MODIFY\t\t0x00000002\t \n#define FS_ATTRIB\t\t0x00000004\t \n#define FS_CLOSE_WRITE\t\t0x00000008\t \n#define FS_CLOSE_NOWRITE\t0x00000010\t \n#define FS_OPEN\t\t\t0x00000020\t \n#define FS_MOVED_FROM\t\t0x00000040\t \n#define FS_MOVED_TO\t\t0x00000080\t \n#define FS_CREATE\t\t0x00000100\t \n#define FS_DELETE\t\t0x00000200\t \n#define FS_DELETE_SELF\t\t0x00000400\t \n#define FS_MOVE_SELF\t\t0x00000800\t \n#define FS_OPEN_EXEC\t\t0x00001000\t \n\n#define FS_UNMOUNT\t\t0x00002000\t \n#define FS_Q_OVERFLOW\t\t0x00004000\t \n#define FS_ERROR\t\t0x00008000\t \n\n \n#define FS_IN_IGNORED\t\t0x00008000\t \n\n#define FS_OPEN_PERM\t\t0x00010000\t \n#define FS_ACCESS_PERM\t\t0x00020000\t \n#define FS_OPEN_EXEC_PERM\t0x00040000\t \n\n \n#define FS_EVENT_ON_CHILD\t0x08000000\n\n#define FS_RENAME\t\t0x10000000\t \n#define FS_DN_MULTISHOT\t\t0x20000000\t \n#define FS_ISDIR\t\t0x40000000\t \n\n#define FS_MOVE\t\t\t(FS_MOVED_FROM | FS_MOVED_TO)\n\n \n#define ALL_FSNOTIFY_DIRENT_EVENTS (FS_CREATE | FS_DELETE | FS_MOVE | FS_RENAME)\n\n#define ALL_FSNOTIFY_PERM_EVENTS (FS_OPEN_PERM | FS_ACCESS_PERM | \\\n\t\t\t\t  FS_OPEN_EXEC_PERM)\n\n \n#define FS_EVENTS_POSS_ON_CHILD   (ALL_FSNOTIFY_PERM_EVENTS | \\\n\t\t\t\t   FS_ACCESS | FS_MODIFY | FS_ATTRIB | \\\n\t\t\t\t   FS_CLOSE_WRITE | FS_CLOSE_NOWRITE | \\\n\t\t\t\t   FS_OPEN | FS_OPEN_EXEC)\n\n \n#define FS_EVENTS_POSS_TO_PARENT (FS_EVENTS_POSS_ON_CHILD)\n\n \n#define ALL_FSNOTIFY_EVENTS (ALL_FSNOTIFY_DIRENT_EVENTS | \\\n\t\t\t     FS_EVENTS_POSS_ON_CHILD | \\\n\t\t\t     FS_DELETE_SELF | FS_MOVE_SELF | \\\n\t\t\t     FS_UNMOUNT | FS_Q_OVERFLOW | FS_IN_IGNORED | \\\n\t\t\t     FS_ERROR)\n\n \n#define ALL_FSNOTIFY_FLAGS  (FS_ISDIR | FS_EVENT_ON_CHILD | FS_DN_MULTISHOT)\n\n#define ALL_FSNOTIFY_BITS   (ALL_FSNOTIFY_EVENTS | ALL_FSNOTIFY_FLAGS)\n\nstruct fsnotify_group;\nstruct fsnotify_event;\nstruct fsnotify_mark;\nstruct fsnotify_event_private_data;\nstruct fsnotify_fname;\nstruct fsnotify_iter_info;\n\nstruct mem_cgroup;\n\n \nstruct fsnotify_ops {\n\tint (*handle_event)(struct fsnotify_group *group, u32 mask,\n\t\t\t    const void *data, int data_type, struct inode *dir,\n\t\t\t    const struct qstr *file_name, u32 cookie,\n\t\t\t    struct fsnotify_iter_info *iter_info);\n\tint (*handle_inode_event)(struct fsnotify_mark *mark, u32 mask,\n\t\t\t    struct inode *inode, struct inode *dir,\n\t\t\t    const struct qstr *file_name, u32 cookie);\n\tvoid (*free_group_priv)(struct fsnotify_group *group);\n\tvoid (*freeing_mark)(struct fsnotify_mark *mark, struct fsnotify_group *group);\n\tvoid (*free_event)(struct fsnotify_group *group, struct fsnotify_event *event);\n\t \n\tvoid (*free_mark)(struct fsnotify_mark *mark);\n};\n\n \nstruct fsnotify_event {\n\tstruct list_head list;\n};\n\n \nstruct fsnotify_group {\n\tconst struct fsnotify_ops *ops;\t \n\n\t \n\trefcount_t refcnt;\t\t \n\n\t \n\tspinlock_t notification_lock;\t\t \n\tstruct list_head notification_list;\t \n\twait_queue_head_t notification_waitq;\t \n\tunsigned int q_len;\t\t\t \n\tunsigned int max_events;\t\t \n\t \n\t#define FS_PRIO_0\t0  \n\t#define FS_PRIO_1\t1  \n\t#define FS_PRIO_2\t2  \n\tunsigned int priority;\n\tbool shutdown;\t\t \n\n#define FSNOTIFY_GROUP_USER\t0x01  \n#define FSNOTIFY_GROUP_DUPS\t0x02  \n#define FSNOTIFY_GROUP_NOFS\t0x04  \n\tint flags;\n\tunsigned int owner_flags;\t \n\n\t \n\tstruct mutex mark_mutex;\t \n\tatomic_t user_waits;\t\t \n\tstruct list_head marks_list;\t \n\n\tstruct fasync_struct *fsn_fa;     \n\n\tstruct fsnotify_event *overflow_event;\t \n\n\tstruct mem_cgroup *memcg;\t \n\n\t \n\tunion {\n\t\tvoid *private;\n#ifdef CONFIG_INOTIFY_USER\n\t\tstruct inotify_group_private_data {\n\t\t\tspinlock_t\tidr_lock;\n\t\t\tstruct idr      idr;\n\t\t\tstruct ucounts *ucounts;\n\t\t} inotify_data;\n#endif\n#ifdef CONFIG_FANOTIFY\n\t\tstruct fanotify_group_private_data {\n\t\t\t \n\t\t\tstruct hlist_head *merge_hash;\n\t\t\t \n\t\t\tstruct list_head access_list;\n\t\t\twait_queue_head_t access_waitq;\n\t\t\tint flags;            \n\t\t\tint f_flags;  \n\t\t\tstruct ucounts *ucounts;\n\t\t\tmempool_t error_events_pool;\n\t\t} fanotify_data;\n#endif  \n\t};\n};\n\n \nstatic inline void fsnotify_group_lock(struct fsnotify_group *group)\n{\n\tmutex_lock(&group->mark_mutex);\n\tif (group->flags & FSNOTIFY_GROUP_NOFS)\n\t\tgroup->owner_flags = memalloc_nofs_save();\n}\n\nstatic inline void fsnotify_group_unlock(struct fsnotify_group *group)\n{\n\tif (group->flags & FSNOTIFY_GROUP_NOFS)\n\t\tmemalloc_nofs_restore(group->owner_flags);\n\tmutex_unlock(&group->mark_mutex);\n}\n\nstatic inline void fsnotify_group_assert_locked(struct fsnotify_group *group)\n{\n\tWARN_ON_ONCE(!mutex_is_locked(&group->mark_mutex));\n\tif (group->flags & FSNOTIFY_GROUP_NOFS)\n\t\tWARN_ON_ONCE(!(current->flags & PF_MEMALLOC_NOFS));\n}\n\n \nenum fsnotify_data_type {\n\tFSNOTIFY_EVENT_NONE,\n\tFSNOTIFY_EVENT_PATH,\n\tFSNOTIFY_EVENT_INODE,\n\tFSNOTIFY_EVENT_DENTRY,\n\tFSNOTIFY_EVENT_ERROR,\n};\n\nstruct fs_error_report {\n\tint error;\n\tstruct inode *inode;\n\tstruct super_block *sb;\n};\n\nstatic inline struct inode *fsnotify_data_inode(const void *data, int data_type)\n{\n\tswitch (data_type) {\n\tcase FSNOTIFY_EVENT_INODE:\n\t\treturn (struct inode *)data;\n\tcase FSNOTIFY_EVENT_DENTRY:\n\t\treturn d_inode(data);\n\tcase FSNOTIFY_EVENT_PATH:\n\t\treturn d_inode(((const struct path *)data)->dentry);\n\tcase FSNOTIFY_EVENT_ERROR:\n\t\treturn ((struct fs_error_report *)data)->inode;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic inline struct dentry *fsnotify_data_dentry(const void *data, int data_type)\n{\n\tswitch (data_type) {\n\tcase FSNOTIFY_EVENT_DENTRY:\n\t\t \n\t\treturn (struct dentry *)data;\n\tcase FSNOTIFY_EVENT_PATH:\n\t\treturn ((const struct path *)data)->dentry;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic inline const struct path *fsnotify_data_path(const void *data,\n\t\t\t\t\t\t    int data_type)\n{\n\tswitch (data_type) {\n\tcase FSNOTIFY_EVENT_PATH:\n\t\treturn data;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic inline struct super_block *fsnotify_data_sb(const void *data,\n\t\t\t\t\t\t   int data_type)\n{\n\tswitch (data_type) {\n\tcase FSNOTIFY_EVENT_INODE:\n\t\treturn ((struct inode *)data)->i_sb;\n\tcase FSNOTIFY_EVENT_DENTRY:\n\t\treturn ((struct dentry *)data)->d_sb;\n\tcase FSNOTIFY_EVENT_PATH:\n\t\treturn ((const struct path *)data)->dentry->d_sb;\n\tcase FSNOTIFY_EVENT_ERROR:\n\t\treturn ((struct fs_error_report *) data)->sb;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic inline struct fs_error_report *fsnotify_data_error_report(\n\t\t\t\t\t\t\tconst void *data,\n\t\t\t\t\t\t\tint data_type)\n{\n\tswitch (data_type) {\n\tcase FSNOTIFY_EVENT_ERROR:\n\t\treturn (struct fs_error_report *) data;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \nenum fsnotify_iter_type {\n\tFSNOTIFY_ITER_TYPE_INODE,\n\tFSNOTIFY_ITER_TYPE_VFSMOUNT,\n\tFSNOTIFY_ITER_TYPE_SB,\n\tFSNOTIFY_ITER_TYPE_PARENT,\n\tFSNOTIFY_ITER_TYPE_INODE2,\n\tFSNOTIFY_ITER_TYPE_COUNT\n};\n\n \nenum fsnotify_obj_type {\n\tFSNOTIFY_OBJ_TYPE_ANY = -1,\n\tFSNOTIFY_OBJ_TYPE_INODE,\n\tFSNOTIFY_OBJ_TYPE_VFSMOUNT,\n\tFSNOTIFY_OBJ_TYPE_SB,\n\tFSNOTIFY_OBJ_TYPE_COUNT,\n\tFSNOTIFY_OBJ_TYPE_DETACHED = FSNOTIFY_OBJ_TYPE_COUNT\n};\n\nstatic inline bool fsnotify_valid_obj_type(unsigned int obj_type)\n{\n\treturn (obj_type < FSNOTIFY_OBJ_TYPE_COUNT);\n}\n\nstruct fsnotify_iter_info {\n\tstruct fsnotify_mark *marks[FSNOTIFY_ITER_TYPE_COUNT];\n\tstruct fsnotify_group *current_group;\n\tunsigned int report_mask;\n\tint srcu_idx;\n};\n\nstatic inline bool fsnotify_iter_should_report_type(\n\t\tstruct fsnotify_iter_info *iter_info, int iter_type)\n{\n\treturn (iter_info->report_mask & (1U << iter_type));\n}\n\nstatic inline void fsnotify_iter_set_report_type(\n\t\tstruct fsnotify_iter_info *iter_info, int iter_type)\n{\n\titer_info->report_mask |= (1U << iter_type);\n}\n\nstatic inline struct fsnotify_mark *fsnotify_iter_mark(\n\t\tstruct fsnotify_iter_info *iter_info, int iter_type)\n{\n\tif (fsnotify_iter_should_report_type(iter_info, iter_type))\n\t\treturn iter_info->marks[iter_type];\n\treturn NULL;\n}\n\nstatic inline int fsnotify_iter_step(struct fsnotify_iter_info *iter, int type,\n\t\t\t\t     struct fsnotify_mark **markp)\n{\n\twhile (type < FSNOTIFY_ITER_TYPE_COUNT) {\n\t\t*markp = fsnotify_iter_mark(iter, type);\n\t\tif (*markp)\n\t\t\tbreak;\n\t\ttype++;\n\t}\n\treturn type;\n}\n\n#define FSNOTIFY_ITER_FUNCS(name, NAME) \\\nstatic inline struct fsnotify_mark *fsnotify_iter_##name##_mark( \\\n\t\tstruct fsnotify_iter_info *iter_info) \\\n{ \\\n\treturn fsnotify_iter_mark(iter_info, FSNOTIFY_ITER_TYPE_##NAME); \\\n}\n\nFSNOTIFY_ITER_FUNCS(inode, INODE)\nFSNOTIFY_ITER_FUNCS(parent, PARENT)\nFSNOTIFY_ITER_FUNCS(vfsmount, VFSMOUNT)\nFSNOTIFY_ITER_FUNCS(sb, SB)\n\n#define fsnotify_foreach_iter_type(type) \\\n\tfor (type = 0; type < FSNOTIFY_ITER_TYPE_COUNT; type++)\n#define fsnotify_foreach_iter_mark_type(iter, mark, type) \\\n\tfor (type = 0; \\\n\t     type = fsnotify_iter_step(iter, type, &mark), \\\n\t     type < FSNOTIFY_ITER_TYPE_COUNT; \\\n\t     type++)\n\n \nstruct fsnotify_mark_connector;\ntypedef struct fsnotify_mark_connector __rcu *fsnotify_connp_t;\n\n \nstruct fsnotify_mark_connector {\n\tspinlock_t lock;\n\tunsigned short type;\t \n#define FSNOTIFY_CONN_FLAG_HAS_FSID\t0x01\n#define FSNOTIFY_CONN_FLAG_HAS_IREF\t0x02\n\tunsigned short flags;\t \n\t__kernel_fsid_t fsid;\t \n\tunion {\n\t\t \n\t\tfsnotify_connp_t *obj;\n\t\t \n\t\tstruct fsnotify_mark_connector *destroy_next;\n\t};\n\tstruct hlist_head list;\n};\n\n \nstruct fsnotify_mark {\n\t \n\t__u32 mask;\n\t \n\trefcount_t refcnt;\n\t \n\tstruct fsnotify_group *group;\n\t \n\tstruct list_head g_list;\n\t \n\tspinlock_t lock;\n\t \n\tstruct hlist_node obj_list;\n\t \n\tstruct fsnotify_mark_connector *connector;\n\t \n\t__u32 ignore_mask;\n\t \n#define FSNOTIFY_MARK_FLAG_ALIVE\t\t0x0001\n#define FSNOTIFY_MARK_FLAG_ATTACHED\t\t0x0002\n\t \n#define FSNOTIFY_MARK_FLAG_EXCL_UNLINK\t\t0x0010\n#define FSNOTIFY_MARK_FLAG_IN_ONESHOT\t\t0x0020\n\t \n#define FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY\t0x0100\n#define FSNOTIFY_MARK_FLAG_NO_IREF\t\t0x0200\n#define FSNOTIFY_MARK_FLAG_HAS_IGNORE_FLAGS\t0x0400\n\tunsigned int flags;\t\t \n};\n\n#ifdef CONFIG_FSNOTIFY\n\n \n\n \nextern int fsnotify(__u32 mask, const void *data, int data_type,\n\t\t    struct inode *dir, const struct qstr *name,\n\t\t    struct inode *inode, u32 cookie);\nextern int __fsnotify_parent(struct dentry *dentry, __u32 mask, const void *data,\n\t\t\t   int data_type);\nextern void __fsnotify_inode_delete(struct inode *inode);\nextern void __fsnotify_vfsmount_delete(struct vfsmount *mnt);\nextern void fsnotify_sb_delete(struct super_block *sb);\nextern u32 fsnotify_get_cookie(void);\n\nstatic inline __u32 fsnotify_parent_needed_mask(__u32 mask)\n{\n\t \n\tif (!(mask & FS_EVENT_ON_CHILD))\n\t\treturn 0;\n\t \n\treturn mask & FS_EVENTS_POSS_TO_PARENT;\n}\n\nstatic inline int fsnotify_inode_watches_children(struct inode *inode)\n{\n\t \n\tif (!(inode->i_fsnotify_mask & FS_EVENT_ON_CHILD))\n\t\treturn 0;\n\t \n\treturn inode->i_fsnotify_mask & FS_EVENTS_POSS_ON_CHILD;\n}\n\n \nstatic inline void fsnotify_update_flags(struct dentry *dentry)\n{\n\tassert_spin_locked(&dentry->d_lock);\n\n\t \n\tif (fsnotify_inode_watches_children(dentry->d_parent->d_inode))\n\t\tdentry->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\telse\n\t\tdentry->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n}\n\n \n\n \nextern struct fsnotify_group *fsnotify_alloc_group(\n\t\t\t\tconst struct fsnotify_ops *ops,\n\t\t\t\tint flags);\n \nextern void fsnotify_get_group(struct fsnotify_group *group);\n \nextern void fsnotify_put_group(struct fsnotify_group *group);\n \nextern void fsnotify_group_stop_queueing(struct fsnotify_group *group);\n \nextern void fsnotify_destroy_group(struct fsnotify_group *group);\n \nextern int fsnotify_fasync(int fd, struct file *file, int on);\n \nextern void fsnotify_destroy_event(struct fsnotify_group *group,\n\t\t\t\t   struct fsnotify_event *event);\n \nextern int fsnotify_insert_event(struct fsnotify_group *group,\n\t\t\t\t struct fsnotify_event *event,\n\t\t\t\t int (*merge)(struct fsnotify_group *,\n\t\t\t\t\t      struct fsnotify_event *),\n\t\t\t\t void (*insert)(struct fsnotify_group *,\n\t\t\t\t\t\tstruct fsnotify_event *));\n\nstatic inline int fsnotify_add_event(struct fsnotify_group *group,\n\t\t\t\t     struct fsnotify_event *event,\n\t\t\t\t     int (*merge)(struct fsnotify_group *,\n\t\t\t\t\t\t  struct fsnotify_event *))\n{\n\treturn fsnotify_insert_event(group, event, merge, NULL);\n}\n\n \nstatic inline void fsnotify_queue_overflow(struct fsnotify_group *group)\n{\n\tfsnotify_add_event(group, group->overflow_event, NULL);\n}\n\nstatic inline bool fsnotify_is_overflow_event(u32 mask)\n{\n\treturn mask & FS_Q_OVERFLOW;\n}\n\nstatic inline bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)\n{\n\tassert_spin_locked(&group->notification_lock);\n\n\treturn list_empty(&group->notification_list);\n}\n\nextern bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group);\n \nextern struct fsnotify_event *fsnotify_peek_first_event(struct fsnotify_group *group);\n \nextern struct fsnotify_event *fsnotify_remove_first_event(struct fsnotify_group *group);\n \nextern void fsnotify_remove_queued_event(struct fsnotify_group *group,\n\t\t\t\t\t struct fsnotify_event *event);\n\n \n\n \nstatic inline __u32 fsnotify_ignore_mask(struct fsnotify_mark *mark)\n{\n\t__u32 ignore_mask = mark->ignore_mask;\n\n\t \n\tif (mark->flags & FSNOTIFY_MARK_FLAG_HAS_IGNORE_FLAGS)\n\t\treturn ignore_mask;\n\n\t \n\tignore_mask |= FS_ISDIR;\n\tignore_mask &= ~FS_EVENT_ON_CHILD;\n\tignore_mask |= mark->mask & FS_EVENT_ON_CHILD;\n\n\treturn ignore_mask;\n}\n\n \nstatic inline __u32 fsnotify_ignored_events(struct fsnotify_mark *mark)\n{\n\treturn mark->ignore_mask & ALL_FSNOTIFY_EVENTS;\n}\n\n \nstatic inline bool fsnotify_mask_applicable(__u32 mask, bool is_dir,\n\t\t\t\t\t    int iter_type)\n{\n\t \n\tif (is_dir && !(mask & FS_ISDIR))\n\t\treturn false;\n\n\t \n\tif (iter_type == FSNOTIFY_ITER_TYPE_PARENT &&\n\t    !(mask & FS_EVENT_ON_CHILD))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic inline __u32 fsnotify_effective_ignore_mask(struct fsnotify_mark *mark,\n\t\t\t\t\t\t   bool is_dir, int iter_type)\n{\n\t__u32 ignore_mask = fsnotify_ignored_events(mark);\n\n\tif (!ignore_mask)\n\t\treturn 0;\n\n\t \n\tif (!is_dir && iter_type != FSNOTIFY_ITER_TYPE_PARENT)\n\t\treturn ignore_mask;\n\n\tignore_mask = fsnotify_ignore_mask(mark);\n\tif (!fsnotify_mask_applicable(ignore_mask, is_dir, iter_type))\n\t\treturn 0;\n\n\treturn ignore_mask & ALL_FSNOTIFY_EVENTS;\n}\n\n \nstatic inline __u32 fsnotify_calc_mask(struct fsnotify_mark *mark)\n{\n\t__u32 mask = mark->mask;\n\n\tif (!fsnotify_ignored_events(mark))\n\t\treturn mask;\n\n\t \n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\n\t\tmask |= FS_MODIFY;\n\n\t \n\treturn mask | mark->ignore_mask;\n}\n\n \nextern __u32 fsnotify_conn_mask(struct fsnotify_mark_connector *conn);\n \nextern void fsnotify_recalc_mask(struct fsnotify_mark_connector *conn);\nextern void fsnotify_init_mark(struct fsnotify_mark *mark,\n\t\t\t       struct fsnotify_group *group);\n \nextern struct fsnotify_mark *fsnotify_find_mark(fsnotify_connp_t *connp,\n\t\t\t\t\t\tstruct fsnotify_group *group);\n \nextern int fsnotify_add_mark(struct fsnotify_mark *mark,\n\t\t\t     fsnotify_connp_t *connp, unsigned int obj_type,\n\t\t\t     int add_flags, __kernel_fsid_t *fsid);\nextern int fsnotify_add_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t    fsnotify_connp_t *connp,\n\t\t\t\t    unsigned int obj_type, int add_flags,\n\t\t\t\t    __kernel_fsid_t *fsid);\n\n \nstatic inline int fsnotify_add_inode_mark(struct fsnotify_mark *mark,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  int add_flags)\n{\n\treturn fsnotify_add_mark(mark, &inode->i_fsnotify_marks,\n\t\t\t\t FSNOTIFY_OBJ_TYPE_INODE, add_flags, NULL);\n}\nstatic inline int fsnotify_add_inode_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int add_flags)\n{\n\treturn fsnotify_add_mark_locked(mark, &inode->i_fsnotify_marks,\n\t\t\t\t\tFSNOTIFY_OBJ_TYPE_INODE, add_flags,\n\t\t\t\t\tNULL);\n}\n\n \nextern void fsnotify_destroy_mark(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group);\n \nextern void fsnotify_detach_mark(struct fsnotify_mark *mark);\n \nextern void fsnotify_free_mark(struct fsnotify_mark *mark);\n \nextern void fsnotify_wait_marks_destroyed(void);\n \nextern void fsnotify_clear_marks_by_group(struct fsnotify_group *group,\n\t\t\t\t\t  unsigned int obj_type);\n \nstatic inline void fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group)\n{\n\tfsnotify_clear_marks_by_group(group, FSNOTIFY_OBJ_TYPE_VFSMOUNT);\n}\n \nstatic inline void fsnotify_clear_inode_marks_by_group(struct fsnotify_group *group)\n{\n\tfsnotify_clear_marks_by_group(group, FSNOTIFY_OBJ_TYPE_INODE);\n}\n \nstatic inline void fsnotify_clear_sb_marks_by_group(struct fsnotify_group *group)\n{\n\tfsnotify_clear_marks_by_group(group, FSNOTIFY_OBJ_TYPE_SB);\n}\nextern void fsnotify_get_mark(struct fsnotify_mark *mark);\nextern void fsnotify_put_mark(struct fsnotify_mark *mark);\nextern void fsnotify_finish_user_wait(struct fsnotify_iter_info *iter_info);\nextern bool fsnotify_prepare_user_wait(struct fsnotify_iter_info *iter_info);\n\nstatic inline void fsnotify_init_event(struct fsnotify_event *event)\n{\n\tINIT_LIST_HEAD(&event->list);\n}\n\n#else\n\nstatic inline int fsnotify(__u32 mask, const void *data, int data_type,\n\t\t\t   struct inode *dir, const struct qstr *name,\n\t\t\t   struct inode *inode, u32 cookie)\n{\n\treturn 0;\n}\n\nstatic inline int __fsnotify_parent(struct dentry *dentry, __u32 mask,\n\t\t\t\t  const void *data, int data_type)\n{\n\treturn 0;\n}\n\nstatic inline void __fsnotify_inode_delete(struct inode *inode)\n{}\n\nstatic inline void __fsnotify_vfsmount_delete(struct vfsmount *mnt)\n{}\n\nstatic inline void fsnotify_sb_delete(struct super_block *sb)\n{}\n\nstatic inline void fsnotify_update_flags(struct dentry *dentry)\n{}\n\nstatic inline u32 fsnotify_get_cookie(void)\n{\n\treturn 0;\n}\n\nstatic inline void fsnotify_unmount_inodes(struct super_block *sb)\n{}\n\n#endif\t \n\n#endif\t \n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}