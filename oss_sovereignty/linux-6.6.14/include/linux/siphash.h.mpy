{
  "module_name": "siphash.h",
  "hash_id": "bf2b6f7f9e7e42f3c75a611b88848ccd52387915491ca98d2cf7b14c29627b44",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/siphash.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_SIPHASH_H\n#define _LINUX_SIPHASH_H\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n\n#define SIPHASH_ALIGNMENT __alignof__(u64)\ntypedef struct {\n\tu64 key[2];\n} siphash_key_t;\n\n#define siphash_aligned_key_t siphash_key_t __aligned(16)\n\nstatic inline bool siphash_key_is_zero(const siphash_key_t *key)\n{\n\treturn !(key->key[0] | key->key[1]);\n}\n\nu64 __siphash_aligned(const void *data, size_t len, const siphash_key_t *key);\nu64 __siphash_unaligned(const void *data, size_t len, const siphash_key_t *key);\n\nu64 siphash_1u64(const u64 a, const siphash_key_t *key);\nu64 siphash_2u64(const u64 a, const u64 b, const siphash_key_t *key);\nu64 siphash_3u64(const u64 a, const u64 b, const u64 c,\n\t\t const siphash_key_t *key);\nu64 siphash_4u64(const u64 a, const u64 b, const u64 c, const u64 d,\n\t\t const siphash_key_t *key);\nu64 siphash_1u32(const u32 a, const siphash_key_t *key);\nu64 siphash_3u32(const u32 a, const u32 b, const u32 c,\n\t\t const siphash_key_t *key);\n\nstatic inline u64 siphash_2u32(const u32 a, const u32 b,\n\t\t\t       const siphash_key_t *key)\n{\n\treturn siphash_1u64((u64)b << 32 | a, key);\n}\nstatic inline u64 siphash_4u32(const u32 a, const u32 b, const u32 c,\n\t\t\t       const u32 d, const siphash_key_t *key)\n{\n\treturn siphash_2u64((u64)b << 32 | a, (u64)d << 32 | c, key);\n}\n\n\nstatic inline u64 ___siphash_aligned(const __le64 *data, size_t len,\n\t\t\t\t     const siphash_key_t *key)\n{\n\tif (__builtin_constant_p(len) && len == 4)\n\t\treturn siphash_1u32(le32_to_cpup((const __le32 *)data), key);\n\tif (__builtin_constant_p(len) && len == 8)\n\t\treturn siphash_1u64(le64_to_cpu(data[0]), key);\n\tif (__builtin_constant_p(len) && len == 16)\n\t\treturn siphash_2u64(le64_to_cpu(data[0]), le64_to_cpu(data[1]),\n\t\t\t\t    key);\n\tif (__builtin_constant_p(len) && len == 24)\n\t\treturn siphash_3u64(le64_to_cpu(data[0]), le64_to_cpu(data[1]),\n\t\t\t\t    le64_to_cpu(data[2]), key);\n\tif (__builtin_constant_p(len) && len == 32)\n\t\treturn siphash_4u64(le64_to_cpu(data[0]), le64_to_cpu(data[1]),\n\t\t\t\t    le64_to_cpu(data[2]), le64_to_cpu(data[3]),\n\t\t\t\t    key);\n\treturn __siphash_aligned(data, len, key);\n}\n\n \nstatic inline u64 siphash(const void *data, size_t len,\n\t\t\t  const siphash_key_t *key)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) ||\n\t    !IS_ALIGNED((unsigned long)data, SIPHASH_ALIGNMENT))\n\t\treturn __siphash_unaligned(data, len, key);\n\treturn ___siphash_aligned(data, len, key);\n}\n\n#define HSIPHASH_ALIGNMENT __alignof__(unsigned long)\ntypedef struct {\n\tunsigned long key[2];\n} hsiphash_key_t;\n\nu32 __hsiphash_aligned(const void *data, size_t len,\n\t\t       const hsiphash_key_t *key);\nu32 __hsiphash_unaligned(const void *data, size_t len,\n\t\t\t const hsiphash_key_t *key);\n\nu32 hsiphash_1u32(const u32 a, const hsiphash_key_t *key);\nu32 hsiphash_2u32(const u32 a, const u32 b, const hsiphash_key_t *key);\nu32 hsiphash_3u32(const u32 a, const u32 b, const u32 c,\n\t\t  const hsiphash_key_t *key);\nu32 hsiphash_4u32(const u32 a, const u32 b, const u32 c, const u32 d,\n\t\t  const hsiphash_key_t *key);\n\nstatic inline u32 ___hsiphash_aligned(const __le32 *data, size_t len,\n\t\t\t\t      const hsiphash_key_t *key)\n{\n\tif (__builtin_constant_p(len) && len == 4)\n\t\treturn hsiphash_1u32(le32_to_cpu(data[0]), key);\n\tif (__builtin_constant_p(len) && len == 8)\n\t\treturn hsiphash_2u32(le32_to_cpu(data[0]), le32_to_cpu(data[1]),\n\t\t\t\t     key);\n\tif (__builtin_constant_p(len) && len == 12)\n\t\treturn hsiphash_3u32(le32_to_cpu(data[0]), le32_to_cpu(data[1]),\n\t\t\t\t     le32_to_cpu(data[2]), key);\n\tif (__builtin_constant_p(len) && len == 16)\n\t\treturn hsiphash_4u32(le32_to_cpu(data[0]), le32_to_cpu(data[1]),\n\t\t\t\t     le32_to_cpu(data[2]), le32_to_cpu(data[3]),\n\t\t\t\t     key);\n\treturn __hsiphash_aligned(data, len, key);\n}\n\n \nstatic inline u32 hsiphash(const void *data, size_t len,\n\t\t\t   const hsiphash_key_t *key)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) ||\n\t    !IS_ALIGNED((unsigned long)data, HSIPHASH_ALIGNMENT))\n\t\treturn __hsiphash_unaligned(data, len, key);\n\treturn ___hsiphash_aligned(data, len, key);\n}\n\n \n\n#define SIPHASH_PERMUTATION(a, b, c, d) ( \\\n\t(a) += (b), (b) = rol64((b), 13), (b) ^= (a), (a) = rol64((a), 32), \\\n\t(c) += (d), (d) = rol64((d), 16), (d) ^= (c), \\\n\t(a) += (d), (d) = rol64((d), 21), (d) ^= (a), \\\n\t(c) += (b), (b) = rol64((b), 17), (b) ^= (c), (c) = rol64((c), 32))\n\n#define SIPHASH_CONST_0 0x736f6d6570736575ULL\n#define SIPHASH_CONST_1 0x646f72616e646f6dULL\n#define SIPHASH_CONST_2 0x6c7967656e657261ULL\n#define SIPHASH_CONST_3 0x7465646279746573ULL\n\n#define HSIPHASH_PERMUTATION(a, b, c, d) ( \\\n\t(a) += (b), (b) = rol32((b), 5), (b) ^= (a), (a) = rol32((a), 16), \\\n\t(c) += (d), (d) = rol32((d), 8), (d) ^= (c), \\\n\t(a) += (d), (d) = rol32((d), 7), (d) ^= (a), \\\n\t(c) += (b), (b) = rol32((b), 13), (b) ^= (c), (c) = rol32((c), 16))\n\n#define HSIPHASH_CONST_0 0U\n#define HSIPHASH_CONST_1 0U\n#define HSIPHASH_CONST_2 0x6c796765U\n#define HSIPHASH_CONST_3 0x74656462U\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}