{
  "module_name": "host.h",
  "hash_id": "3bcfd4d2fc187e9066e218d4619c1e02bedc9eac1dac6f0013af766c336c036a",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mmc/host.h",
  "human_readable_source": " \n \n#ifndef LINUX_MMC_HOST_H\n#define LINUX_MMC_HOST_H\n\n#include <linux/sched.h>\n#include <linux/device.h>\n#include <linux/fault-inject.h>\n\n#include <linux/mmc/core.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/pm.h>\n#include <linux/dma-direction.h>\n#include <linux/blk-crypto-profile.h>\n\nstruct mmc_ios {\n\tunsigned int\tclock;\t\t\t \n\tunsigned short\tvdd;\n\tunsigned int\tpower_delay_ms;\t\t \n\n \n\n\tunsigned char\tbus_mode;\t\t \n\n#define MMC_BUSMODE_OPENDRAIN\t1\n#define MMC_BUSMODE_PUSHPULL\t2\n\n\tunsigned char\tchip_select;\t\t \n\n#define MMC_CS_DONTCARE\t\t0\n#define MMC_CS_HIGH\t\t1\n#define MMC_CS_LOW\t\t2\n\n\tunsigned char\tpower_mode;\t\t \n\n#define MMC_POWER_OFF\t\t0\n#define MMC_POWER_UP\t\t1\n#define MMC_POWER_ON\t\t2\n#define MMC_POWER_UNDEFINED\t3\n\n\tunsigned char\tbus_width;\t\t \n\n#define MMC_BUS_WIDTH_1\t\t0\n#define MMC_BUS_WIDTH_4\t\t2\n#define MMC_BUS_WIDTH_8\t\t3\n\n\tunsigned char\ttiming;\t\t\t \n\n#define MMC_TIMING_LEGACY\t0\n#define MMC_TIMING_MMC_HS\t1\n#define MMC_TIMING_SD_HS\t2\n#define MMC_TIMING_UHS_SDR12\t3\n#define MMC_TIMING_UHS_SDR25\t4\n#define MMC_TIMING_UHS_SDR50\t5\n#define MMC_TIMING_UHS_SDR104\t6\n#define MMC_TIMING_UHS_DDR50\t7\n#define MMC_TIMING_MMC_DDR52\t8\n#define MMC_TIMING_MMC_HS200\t9\n#define MMC_TIMING_MMC_HS400\t10\n#define MMC_TIMING_SD_EXP\t11\n#define MMC_TIMING_SD_EXP_1_2V\t12\n\n\tunsigned char\tsignal_voltage;\t\t \n\n#define MMC_SIGNAL_VOLTAGE_330\t0\n#define MMC_SIGNAL_VOLTAGE_180\t1\n#define MMC_SIGNAL_VOLTAGE_120\t2\n\n\tunsigned char\tdrv_type;\t\t \n\n#define MMC_SET_DRIVER_TYPE_B\t0\n#define MMC_SET_DRIVER_TYPE_A\t1\n#define MMC_SET_DRIVER_TYPE_C\t2\n#define MMC_SET_DRIVER_TYPE_D\t3\n\n\tbool enhanced_strobe;\t\t\t \n};\n\nstruct mmc_clk_phase {\n\tbool valid;\n\tu16 in_deg;\n\tu16 out_deg;\n};\n\n#define MMC_NUM_CLK_PHASES (MMC_TIMING_MMC_HS400 + 1)\nstruct mmc_clk_phase_map {\n\tstruct mmc_clk_phase phase[MMC_NUM_CLK_PHASES];\n};\n\nstruct mmc_host;\n\nenum mmc_err_stat {\n\tMMC_ERR_CMD_TIMEOUT,\n\tMMC_ERR_CMD_CRC,\n\tMMC_ERR_DAT_TIMEOUT,\n\tMMC_ERR_DAT_CRC,\n\tMMC_ERR_AUTO_CMD,\n\tMMC_ERR_ADMA,\n\tMMC_ERR_TUNING,\n\tMMC_ERR_CMDQ_RED,\n\tMMC_ERR_CMDQ_GCE,\n\tMMC_ERR_CMDQ_ICCE,\n\tMMC_ERR_REQ_TIMEOUT,\n\tMMC_ERR_CMDQ_REQ_TIMEOUT,\n\tMMC_ERR_ICE_CFG,\n\tMMC_ERR_CTRL_TIMEOUT,\n\tMMC_ERR_UNEXPECTED_IRQ,\n\tMMC_ERR_MAX,\n};\n\nstruct mmc_host_ops {\n\t \n\tvoid\t(*post_req)(struct mmc_host *host, struct mmc_request *req,\n\t\t\t    int err);\n\tvoid\t(*pre_req)(struct mmc_host *host, struct mmc_request *req);\n\tvoid\t(*request)(struct mmc_host *host, struct mmc_request *req);\n\t \n\tint\t(*request_atomic)(struct mmc_host *host,\n\t\t\t\t  struct mmc_request *req);\n\n\t \n\n\t \n\tvoid\t(*set_ios)(struct mmc_host *host, struct mmc_ios *ios);\n\n\t \n\tint\t(*get_ro)(struct mmc_host *host);\n\n\t \n\tint\t(*get_cd)(struct mmc_host *host);\n\n\tvoid\t(*enable_sdio_irq)(struct mmc_host *host, int enable);\n\t \n\tvoid\t(*ack_sdio_irq)(struct mmc_host *host);\n\n\t \n\tvoid\t(*init_card)(struct mmc_host *host, struct mmc_card *card);\n\n\tint\t(*start_signal_voltage_switch)(struct mmc_host *host, struct mmc_ios *ios);\n\n\t \n\tint\t(*card_busy)(struct mmc_host *host);\n\n\t \n\tint\t(*execute_tuning)(struct mmc_host *host, u32 opcode);\n\n\t \n\tint\t(*prepare_hs400_tuning)(struct mmc_host *host, struct mmc_ios *ios);\n\n\t \n\tint\t(*execute_hs400_tuning)(struct mmc_host *host, struct mmc_card *card);\n\n\t \n\tint\t(*prepare_sd_hs_tuning)(struct mmc_host *host, struct mmc_card *card);\n\n\t \n\tint\t(*execute_sd_hs_tuning)(struct mmc_host *host, struct mmc_card *card);\n\n\t \n\tint\t(*hs400_prepare_ddr)(struct mmc_host *host);\n\n\t \n\tvoid\t(*hs400_downgrade)(struct mmc_host *host);\n\n\t \n\tvoid\t(*hs400_complete)(struct mmc_host *host);\n\n\t \n\tvoid\t(*hs400_enhanced_strobe)(struct mmc_host *host,\n\t\t\t\t\t struct mmc_ios *ios);\n\tint\t(*select_drive_strength)(struct mmc_card *card,\n\t\t\t\t\t unsigned int max_dtr, int host_drv,\n\t\t\t\t\t int card_drv, int *drv_type);\n\t \n\tvoid\t(*card_hw_reset)(struct mmc_host *host);\n\tvoid\t(*card_event)(struct mmc_host *host);\n\n\t \n\tint\t(*multi_io_quirk)(struct mmc_card *card,\n\t\t\t\t  unsigned int direction, int blk_size);\n\n\t \n\tint\t(*init_sd_express)(struct mmc_host *host, struct mmc_ios *ios);\n};\n\nstruct mmc_cqe_ops {\n\t \n\tint\t(*cqe_enable)(struct mmc_host *host, struct mmc_card *card);\n\t \n\tvoid\t(*cqe_disable)(struct mmc_host *host);\n\t \n\tint\t(*cqe_request)(struct mmc_host *host, struct mmc_request *mrq);\n\t \n\tvoid\t(*cqe_post_req)(struct mmc_host *host, struct mmc_request *mrq);\n\t \n\tvoid\t(*cqe_off)(struct mmc_host *host);\n\t \n\tint\t(*cqe_wait_for_idle)(struct mmc_host *host);\n\t \n\tbool\t(*cqe_timeout)(struct mmc_host *host, struct mmc_request *mrq,\n\t\t\t       bool *recovery_needed);\n\t \n\tvoid\t(*cqe_recovery_start)(struct mmc_host *host);\n\t \n\tvoid\t(*cqe_recovery_finish)(struct mmc_host *host);\n};\n\nstruct mmc_async_req {\n\t \n\tstruct mmc_request\t*mrq;\n\t \n\tenum mmc_blk_status (*err_check)(struct mmc_card *, struct mmc_async_req *);\n};\n\n \nstruct mmc_slot {\n\tint cd_irq;\n\tbool cd_wake_enabled;\n\tvoid *handler_priv;\n};\n\n \nstruct mmc_context_info {\n\tbool\t\t\tis_done_rcv;\n\tbool\t\t\tis_new_req;\n\tbool\t\t\tis_waiting_last_req;\n\twait_queue_head_t\twait;\n};\n\nstruct regulator;\nstruct mmc_pwrseq;\n\nstruct mmc_supply {\n\tstruct regulator *vmmc;\t\t \n\tstruct regulator *vqmmc;\t \n};\n\nstruct mmc_ctx {\n\tstruct task_struct *task;\n};\n\nstruct mmc_host {\n\tstruct device\t\t*parent;\n\tstruct device\t\tclass_dev;\n\tint\t\t\tindex;\n\tconst struct mmc_host_ops *ops;\n\tstruct mmc_pwrseq\t*pwrseq;\n\tunsigned int\t\tf_min;\n\tunsigned int\t\tf_max;\n\tunsigned int\t\tf_init;\n\tu32\t\t\tocr_avail;\n\tu32\t\t\tocr_avail_sdio;\t \n\tu32\t\t\tocr_avail_sd;\t \n\tu32\t\t\tocr_avail_mmc;\t \n\tstruct wakeup_source\t*ws;\t\t \n\tu32\t\t\tmax_current_330;\n\tu32\t\t\tmax_current_300;\n\tu32\t\t\tmax_current_180;\n\n#define MMC_VDD_165_195\t\t0x00000080\t \n#define MMC_VDD_20_21\t\t0x00000100\t \n#define MMC_VDD_21_22\t\t0x00000200\t \n#define MMC_VDD_22_23\t\t0x00000400\t \n#define MMC_VDD_23_24\t\t0x00000800\t \n#define MMC_VDD_24_25\t\t0x00001000\t \n#define MMC_VDD_25_26\t\t0x00002000\t \n#define MMC_VDD_26_27\t\t0x00004000\t \n#define MMC_VDD_27_28\t\t0x00008000\t \n#define MMC_VDD_28_29\t\t0x00010000\t \n#define MMC_VDD_29_30\t\t0x00020000\t \n#define MMC_VDD_30_31\t\t0x00040000\t \n#define MMC_VDD_31_32\t\t0x00080000\t \n#define MMC_VDD_32_33\t\t0x00100000\t \n#define MMC_VDD_33_34\t\t0x00200000\t \n#define MMC_VDD_34_35\t\t0x00400000\t \n#define MMC_VDD_35_36\t\t0x00800000\t \n\n\tu32\t\t\tcaps;\t\t \n\n#define MMC_CAP_4_BIT_DATA\t(1 << 0)\t \n#define MMC_CAP_MMC_HIGHSPEED\t(1 << 1)\t \n#define MMC_CAP_SD_HIGHSPEED\t(1 << 2)\t \n#define MMC_CAP_SDIO_IRQ\t(1 << 3)\t \n#define MMC_CAP_SPI\t\t(1 << 4)\t \n#define MMC_CAP_NEEDS_POLL\t(1 << 5)\t \n#define MMC_CAP_8_BIT_DATA\t(1 << 6)\t \n#define MMC_CAP_AGGRESSIVE_PM\t(1 << 7)\t \n#define MMC_CAP_NONREMOVABLE\t(1 << 8)\t \n#define MMC_CAP_WAIT_WHILE_BUSY\t(1 << 9)\t \n#define MMC_CAP_3_3V_DDR\t(1 << 11)\t \n#define MMC_CAP_1_8V_DDR\t(1 << 12)\t \n#define MMC_CAP_1_2V_DDR\t(1 << 13)\t \n#define MMC_CAP_DDR\t\t(MMC_CAP_3_3V_DDR | MMC_CAP_1_8V_DDR | \\\n\t\t\t\t MMC_CAP_1_2V_DDR)\n#define MMC_CAP_POWER_OFF_CARD\t(1 << 14)\t \n#define MMC_CAP_BUS_WIDTH_TEST\t(1 << 15)\t \n#define MMC_CAP_UHS_SDR12\t(1 << 16)\t \n#define MMC_CAP_UHS_SDR25\t(1 << 17)\t \n#define MMC_CAP_UHS_SDR50\t(1 << 18)\t \n#define MMC_CAP_UHS_SDR104\t(1 << 19)\t \n#define MMC_CAP_UHS_DDR50\t(1 << 20)\t \n#define MMC_CAP_UHS\t\t(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | \\\n\t\t\t\t MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | \\\n\t\t\t\t MMC_CAP_UHS_DDR50)\n#define MMC_CAP_SYNC_RUNTIME_PM\t(1 << 21)\t \n#define MMC_CAP_NEED_RSP_BUSY\t(1 << 22)\t \n#define MMC_CAP_DRIVER_TYPE_A\t(1 << 23)\t \n#define MMC_CAP_DRIVER_TYPE_C\t(1 << 24)\t \n#define MMC_CAP_DRIVER_TYPE_D\t(1 << 25)\t \n#define MMC_CAP_DONE_COMPLETE\t(1 << 27)\t \n#define MMC_CAP_CD_WAKE\t\t(1 << 28)\t \n#define MMC_CAP_CMD_DURING_TFR\t(1 << 29)\t \n#define MMC_CAP_CMD23\t\t(1 << 30)\t \n#define MMC_CAP_HW_RESET\t(1 << 31)\t \n\n\tu32\t\t\tcaps2;\t\t \n\n#define MMC_CAP2_BOOTPART_NOACC\t(1 << 0)\t \n#define MMC_CAP2_FULL_PWR_CYCLE\t(1 << 2)\t \n#define MMC_CAP2_FULL_PWR_CYCLE_IN_SUSPEND (1 << 3)  \n#define MMC_CAP2_HS200_1_8V_SDR\t(1 << 5)         \n#define MMC_CAP2_HS200_1_2V_SDR\t(1 << 6)         \n#define MMC_CAP2_HS200\t\t(MMC_CAP2_HS200_1_8V_SDR | \\\n\t\t\t\t MMC_CAP2_HS200_1_2V_SDR)\n#define MMC_CAP2_SD_EXP\t\t(1 << 7)\t \n#define MMC_CAP2_SD_EXP_1_2V\t(1 << 8)\t \n#define MMC_CAP2_CD_ACTIVE_HIGH\t(1 << 10)\t \n#define MMC_CAP2_RO_ACTIVE_HIGH\t(1 << 11)\t \n#define MMC_CAP2_NO_PRESCAN_POWERUP (1 << 14)\t \n#define MMC_CAP2_HS400_1_8V\t(1 << 15)\t \n#define MMC_CAP2_HS400_1_2V\t(1 << 16)\t \n#define MMC_CAP2_HS400\t\t(MMC_CAP2_HS400_1_8V | \\\n\t\t\t\t MMC_CAP2_HS400_1_2V)\n#define MMC_CAP2_HSX00_1_8V\t(MMC_CAP2_HS200_1_8V_SDR | MMC_CAP2_HS400_1_8V)\n#define MMC_CAP2_HSX00_1_2V\t(MMC_CAP2_HS200_1_2V_SDR | MMC_CAP2_HS400_1_2V)\n#define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)\n#define MMC_CAP2_NO_WRITE_PROTECT (1 << 18)\t \n#define MMC_CAP2_NO_SDIO\t(1 << 19)\t \n#define MMC_CAP2_HS400_ES\t(1 << 20)\t \n#define MMC_CAP2_NO_SD\t\t(1 << 21)\t \n#define MMC_CAP2_NO_MMC\t\t(1 << 22)\t \n#define MMC_CAP2_CQE\t\t(1 << 23)\t \n#define MMC_CAP2_CQE_DCMD\t(1 << 24)\t \n#define MMC_CAP2_AVOID_3_3V\t(1 << 25)\t \n#define MMC_CAP2_MERGE_CAPABLE\t(1 << 26)\t \n#ifdef CONFIG_MMC_CRYPTO\n#define MMC_CAP2_CRYPTO\t\t(1 << 27)\t \n#else\n#define MMC_CAP2_CRYPTO\t\t0\n#endif\n#define MMC_CAP2_ALT_GPT_TEGRA\t(1 << 28)\t \n\n\tint\t\t\tfixed_drv_type;\t \n\n\tmmc_pm_flag_t\t\tpm_caps;\t \n\n\t \n\tunsigned int\t\tmax_seg_size;\t \n\tunsigned short\t\tmax_segs;\t \n\tunsigned short\t\tunused;\n\tunsigned int\t\tmax_req_size;\t \n\tunsigned int\t\tmax_blk_size;\t \n\tunsigned int\t\tmax_blk_count;\t \n\tunsigned int\t\tmax_busy_timeout;  \n\n\t \n\tspinlock_t\t\tlock;\t\t \n\n\tstruct mmc_ios\t\tios;\t\t \n\n\t \n\tunsigned int\t\tuse_spi_crc:1;\n\tunsigned int\t\tclaimed:1;\t \n\tunsigned int\t\tdoing_init_tune:1;  \n\tunsigned int\t\tcan_retune:1;\t \n\tunsigned int\t\tdoing_retune:1;\t \n\tunsigned int\t\tretune_now:1;\t \n\tunsigned int\t\tretune_paused:1;  \n\tunsigned int\t\tretune_crc_disable:1;  \n\tunsigned int\t\tcan_dma_map_merge:1;  \n\tunsigned int\t\tvqmmc_enabled:1;  \n\n\tint\t\t\trescan_disable;\t \n\tint\t\t\trescan_entered;\t \n\n\tint\t\t\tneed_retune;\t \n\tint\t\t\thold_retune;\t \n\tunsigned int\t\tretune_period;\t \n\tstruct timer_list\tretune_timer;\t \n\n\tbool\t\t\ttrigger_card_event;  \n\n\tstruct mmc_card\t\t*card;\t\t \n\n\twait_queue_head_t\twq;\n\tstruct mmc_ctx\t\t*claimer;\t \n\tint\t\t\tclaim_cnt;\t \n\tstruct mmc_ctx\t\tdefault_ctx;\t \n\n\tstruct delayed_work\tdetect;\n\tint\t\t\tdetect_change;\t \n\tstruct mmc_slot\t\tslot;\n\n\tconst struct mmc_bus_ops *bus_ops;\t \n\n\tunsigned int\t\tsdio_irqs;\n\tstruct task_struct\t*sdio_irq_thread;\n\tstruct work_struct\tsdio_irq_work;\n\tbool\t\t\tsdio_irq_pending;\n\tatomic_t\t\tsdio_irq_thread_abort;\n\n\tmmc_pm_flag_t\t\tpm_flags;\t \n\n\tstruct led_trigger\t*led;\t\t \n\n#ifdef CONFIG_REGULATOR\n\tbool\t\t\tregulator_enabled;  \n#endif\n\tstruct mmc_supply\tsupply;\n\n\tstruct dentry\t\t*debugfs_root;\n\n\t \n\tstruct mmc_request\t*ongoing_mrq;\n\n#ifdef CONFIG_FAIL_MMC_REQUEST\n\tstruct fault_attr\tfail_mmc_request;\n#endif\n\n\tunsigned int\t\tactual_clock;\t \n\n\tunsigned int\t\tslotno;\t \n\n\tint\t\t\tdsr_req;\t \n\tu32\t\t\tdsr;\t \n\n\t \n\tconst struct mmc_cqe_ops *cqe_ops;\n\tvoid\t\t\t*cqe_private;\n\tint\t\t\tcqe_qdepth;\n\tbool\t\t\tcqe_enabled;\n\tbool\t\t\tcqe_on;\n\n\t \n#ifdef CONFIG_MMC_CRYPTO\n\tstruct blk_crypto_profile crypto_profile;\n#endif\n\n\t \n\tbool\t\t\thsq_enabled;\n\n\tu32\t\t\terr_stats[MMC_ERR_MAX];\n\tunsigned long\t\tprivate[] ____cacheline_aligned;\n};\n\nstruct device_node;\n\nstruct mmc_host *mmc_alloc_host(int extra, struct device *);\nstruct mmc_host *devm_mmc_alloc_host(struct device *dev, int extra);\nint mmc_add_host(struct mmc_host *);\nvoid mmc_remove_host(struct mmc_host *);\nvoid mmc_free_host(struct mmc_host *);\nvoid mmc_of_parse_clk_phase(struct mmc_host *host,\n\t\t\t    struct mmc_clk_phase_map *map);\nint mmc_of_parse(struct mmc_host *host);\nint mmc_of_parse_voltage(struct mmc_host *host, u32 *mask);\n\nstatic inline void *mmc_priv(struct mmc_host *host)\n{\n\treturn (void *)host->private;\n}\n\nstatic inline struct mmc_host *mmc_from_priv(void *priv)\n{\n\treturn container_of(priv, struct mmc_host, private);\n}\n\n#define mmc_host_is_spi(host)\t((host)->caps & MMC_CAP_SPI)\n\n#define mmc_dev(x)\t((x)->parent)\n#define mmc_classdev(x)\t(&(x)->class_dev)\n#define mmc_hostname(x)\t(dev_name(&(x)->class_dev))\n\nvoid mmc_detect_change(struct mmc_host *, unsigned long delay);\nvoid mmc_request_done(struct mmc_host *, struct mmc_request *);\nvoid mmc_command_done(struct mmc_host *host, struct mmc_request *mrq);\n\nvoid mmc_cqe_request_done(struct mmc_host *host, struct mmc_request *mrq);\n\n \nstatic inline bool sdio_irq_claimed(struct mmc_host *host)\n{\n\treturn host->sdio_irqs > 0;\n}\n\nstatic inline void mmc_signal_sdio_irq(struct mmc_host *host)\n{\n\thost->ops->enable_sdio_irq(host, 0);\n\thost->sdio_irq_pending = true;\n\tif (host->sdio_irq_thread)\n\t\twake_up_process(host->sdio_irq_thread);\n}\n\nvoid sdio_signal_irq(struct mmc_host *host);\n\n#ifdef CONFIG_REGULATOR\nint mmc_regulator_set_ocr(struct mmc_host *mmc,\n\t\t\tstruct regulator *supply,\n\t\t\tunsigned short vdd_bit);\nint mmc_regulator_set_vqmmc(struct mmc_host *mmc, struct mmc_ios *ios);\n#else\nstatic inline int mmc_regulator_set_ocr(struct mmc_host *mmc,\n\t\t\t\t struct regulator *supply,\n\t\t\t\t unsigned short vdd_bit)\n{\n\treturn 0;\n}\n\nstatic inline int mmc_regulator_set_vqmmc(struct mmc_host *mmc,\n\t\t\t\t\t  struct mmc_ios *ios)\n{\n\treturn -EINVAL;\n}\n#endif\n\nint mmc_regulator_get_supply(struct mmc_host *mmc);\nint mmc_regulator_enable_vqmmc(struct mmc_host *mmc);\nvoid mmc_regulator_disable_vqmmc(struct mmc_host *mmc);\n\nstatic inline int mmc_card_is_removable(struct mmc_host *host)\n{\n\treturn !(host->caps & MMC_CAP_NONREMOVABLE);\n}\n\nstatic inline int mmc_card_keep_power(struct mmc_host *host)\n{\n\treturn host->pm_flags & MMC_PM_KEEP_POWER;\n}\n\nstatic inline int mmc_card_wake_sdio_irq(struct mmc_host *host)\n{\n\treturn host->pm_flags & MMC_PM_WAKE_SDIO_IRQ;\n}\n\n \nstatic inline int mmc_card_hs(struct mmc_card *card)\n{\n\treturn card->host->ios.timing == MMC_TIMING_SD_HS ||\n\t\tcard->host->ios.timing == MMC_TIMING_MMC_HS;\n}\n\n \nstatic inline int mmc_card_uhs(struct mmc_card *card)\n{\n\treturn card->host->ios.timing >= MMC_TIMING_UHS_SDR12 &&\n\t\tcard->host->ios.timing <= MMC_TIMING_UHS_DDR50;\n}\n\nvoid mmc_retune_timer_stop(struct mmc_host *host);\n\nstatic inline void mmc_retune_needed(struct mmc_host *host)\n{\n\tif (host->can_retune)\n\t\thost->need_retune = 1;\n}\n\nstatic inline bool mmc_can_retune(struct mmc_host *host)\n{\n\treturn host->can_retune == 1;\n}\n\nstatic inline bool mmc_doing_retune(struct mmc_host *host)\n{\n\treturn host->doing_retune == 1;\n}\n\nstatic inline bool mmc_doing_tune(struct mmc_host *host)\n{\n\treturn host->doing_retune == 1 || host->doing_init_tune == 1;\n}\n\nstatic inline enum dma_data_direction mmc_get_dma_dir(struct mmc_data *data)\n{\n\treturn data->flags & MMC_DATA_WRITE ? DMA_TO_DEVICE : DMA_FROM_DEVICE;\n}\n\nstatic inline void mmc_debugfs_err_stats_inc(struct mmc_host *host,\n\t\t\t\t\t     enum mmc_err_stat stat)\n{\n\thost->err_stats[stat] += 1;\n}\n\nint mmc_sd_switch(struct mmc_card *card, int mode, int group, u8 value, u8 *resp);\nint mmc_send_status(struct mmc_card *card, u32 *status);\nint mmc_send_tuning(struct mmc_host *host, u32 opcode, int *cmd_error);\nint mmc_send_abort_tuning(struct mmc_host *host, u32 opcode);\nint mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}