{
  "module_name": "card.h",
  "hash_id": "38667228956dc6f07670a21cdf3027e439816d6b61fca5e917703b856861607f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mmc/card.h",
  "human_readable_source": " \n \n#ifndef LINUX_MMC_CARD_H\n#define LINUX_MMC_CARD_H\n\n#include <linux/device.h>\n#include <linux/mod_devicetable.h>\n\nstruct mmc_cid {\n\tunsigned int\t\tmanfid;\n\tchar\t\t\tprod_name[8];\n\tunsigned char\t\tprv;\n\tunsigned int\t\tserial;\n\tunsigned short\t\toemid;\n\tunsigned short\t\tyear;\n\tunsigned char\t\thwrev;\n\tunsigned char\t\tfwrev;\n\tunsigned char\t\tmonth;\n};\n\nstruct mmc_csd {\n\tunsigned char\t\tstructure;\n\tunsigned char\t\tmmca_vsn;\n\tunsigned short\t\tcmdclass;\n\tunsigned short\t\ttaac_clks;\n\tunsigned int\t\ttaac_ns;\n\tunsigned int\t\tc_size;\n\tunsigned int\t\tr2w_factor;\n\tunsigned int\t\tmax_dtr;\n\tunsigned int\t\terase_size;\t\t \n\tunsigned int\t\tread_blkbits;\n\tunsigned int\t\twrite_blkbits;\n\tunsigned int\t\tcapacity;\n\tunsigned int\t\tread_partial:1,\n\t\t\t\tread_misalign:1,\n\t\t\t\twrite_partial:1,\n\t\t\t\twrite_misalign:1,\n\t\t\t\tdsr_imp:1;\n};\n\nstruct mmc_ext_csd {\n\tu8\t\t\trev;\n\tu8\t\t\terase_group_def;\n\tu8\t\t\tsec_feature_support;\n\tu8\t\t\trel_sectors;\n\tu8\t\t\trel_param;\n\tbool\t\t\tenhanced_rpmb_supported;\n\tu8\t\t\tpart_config;\n\tu8\t\t\tcache_ctrl;\n\tu8\t\t\trst_n_function;\n\tu8\t\t\tmax_packed_writes;\n\tu8\t\t\tmax_packed_reads;\n\tu8\t\t\tpacked_event_en;\n\tunsigned int\t\tpart_time;\t\t \n\tunsigned int\t\tsa_timeout;\t\t \n\tunsigned int\t\tgeneric_cmd6_time;\t \n\tunsigned int            power_off_longtime;      \n\tu8\t\t\tpower_off_notification;\t \n\tunsigned int\t\ths_max_dtr;\n\tunsigned int\t\ths200_max_dtr;\n#define MMC_HIGH_26_MAX_DTR\t26000000\n#define MMC_HIGH_52_MAX_DTR\t52000000\n#define MMC_HIGH_DDR_MAX_DTR\t52000000\n#define MMC_HS200_MAX_DTR\t200000000\n\tunsigned int\t\tsectors;\n\tunsigned int\t\thc_erase_size;\t\t \n\tunsigned int\t\thc_erase_timeout;\t \n\tunsigned int\t\tsec_trim_mult;\t \n\tunsigned int\t\tsec_erase_mult;\t \n\tunsigned int\t\ttrim_timeout;\t\t \n\tbool\t\t\tpartition_setting_completed;\t \n\tunsigned long long\tenhanced_area_offset;\t \n\tunsigned int\t\tenhanced_area_size;\t \n\tunsigned int\t\tcache_size;\t\t \n\tbool\t\t\thpi_en;\t\t\t \n\tbool\t\t\thpi;\t\t\t \n\tunsigned int\t\thpi_cmd;\t\t \n\tbool\t\t\tbkops;\t\t \n\tbool\t\t\tman_bkops_en;\t \n\tbool\t\t\tauto_bkops_en;\t \n\tunsigned int            data_sector_size;        \n\tunsigned int            data_tag_unit_size;      \n\tunsigned int\t\tboot_ro_lock;\t\t \n\tbool\t\t\tboot_ro_lockable;\n\tbool\t\t\tffu_capable;\t \n\tbool\t\t\tcmdq_en;\t \n\tbool\t\t\tcmdq_support;\t \n\tunsigned int\t\tcmdq_depth;\t \n#define MMC_FIRMWARE_LEN 8\n\tu8\t\t\tfwrev[MMC_FIRMWARE_LEN];   \n\tu8\t\t\traw_exception_status;\t \n\tu8\t\t\traw_partition_support;\t \n\tu8\t\t\traw_rpmb_size_mult;\t \n\tu8\t\t\traw_erased_mem_count;\t \n\tu8\t\t\tstrobe_support;\t\t \n\tu8\t\t\traw_ext_csd_structure;\t \n\tu8\t\t\traw_card_type;\t\t \n\tu8\t\t\traw_driver_strength;\t \n\tu8\t\t\tout_of_int_time;\t \n\tu8\t\t\traw_pwr_cl_52_195;\t \n\tu8\t\t\traw_pwr_cl_26_195;\t \n\tu8\t\t\traw_pwr_cl_52_360;\t \n\tu8\t\t\traw_pwr_cl_26_360;\t \n\tu8\t\t\traw_s_a_timeout;\t \n\tu8\t\t\traw_hc_erase_gap_size;\t \n\tu8\t\t\traw_erase_timeout_mult;\t \n\tu8\t\t\traw_hc_erase_grp_size;\t \n\tu8\t\t\traw_boot_mult;\t\t \n\tu8\t\t\traw_sec_trim_mult;\t \n\tu8\t\t\traw_sec_erase_mult;\t \n\tu8\t\t\traw_sec_feature_support; \n\tu8\t\t\traw_trim_mult;\t\t \n\tu8\t\t\traw_pwr_cl_200_195;\t \n\tu8\t\t\traw_pwr_cl_200_360;\t \n\tu8\t\t\traw_pwr_cl_ddr_52_195;\t \n\tu8\t\t\traw_pwr_cl_ddr_52_360;\t \n\tu8\t\t\traw_pwr_cl_ddr_200_360;\t \n\tu8\t\t\traw_bkops_status;\t \n\tu8\t\t\traw_sectors[4];\t\t \n\tu8\t\t\tpre_eol_info;\t\t \n\tu8\t\t\tdevice_life_time_est_typ_a;\t \n\tu8\t\t\tdevice_life_time_est_typ_b;\t \n\n\tunsigned int            feature_support;\n#define MMC_DISCARD_FEATURE\tBIT(0)                   \n};\n\nstruct sd_scr {\n\tunsigned char\t\tsda_vsn;\n\tunsigned char\t\tsda_spec3;\n\tunsigned char\t\tsda_spec4;\n\tunsigned char\t\tsda_specx;\n\tunsigned char\t\tbus_widths;\n#define SD_SCR_BUS_WIDTH_1\t(1<<0)\n#define SD_SCR_BUS_WIDTH_4\t(1<<2)\n\tunsigned char\t\tcmds;\n#define SD_SCR_CMD20_SUPPORT   (1<<0)\n#define SD_SCR_CMD23_SUPPORT   (1<<1)\n#define SD_SCR_CMD48_SUPPORT   (1<<2)\n#define SD_SCR_CMD58_SUPPORT   (1<<3)\n};\n\nstruct sd_ssr {\n\tunsigned int\t\tau;\t\t\t \n\tunsigned int\t\terase_timeout;\t\t \n\tunsigned int\t\terase_offset;\t\t \n};\n\nstruct sd_switch_caps {\n\tunsigned int\t\ths_max_dtr;\n\tunsigned int\t\tuhs_max_dtr;\n#define HIGH_SPEED_MAX_DTR\t50000000\n#define UHS_SDR104_MAX_DTR\t208000000\n#define UHS_SDR50_MAX_DTR\t100000000\n#define UHS_DDR50_MAX_DTR\t50000000\n#define UHS_SDR25_MAX_DTR\tUHS_DDR50_MAX_DTR\n#define UHS_SDR12_MAX_DTR\t25000000\n#define DEFAULT_SPEED_MAX_DTR\tUHS_SDR12_MAX_DTR\n\tunsigned int\t\tsd3_bus_mode;\n#define UHS_SDR12_BUS_SPEED\t0\n#define HIGH_SPEED_BUS_SPEED\t1\n#define UHS_SDR25_BUS_SPEED\t1\n#define UHS_SDR50_BUS_SPEED\t2\n#define UHS_SDR104_BUS_SPEED\t3\n#define UHS_DDR50_BUS_SPEED\t4\n\n#define SD_MODE_HIGH_SPEED\t(1 << HIGH_SPEED_BUS_SPEED)\n#define SD_MODE_UHS_SDR12\t(1 << UHS_SDR12_BUS_SPEED)\n#define SD_MODE_UHS_SDR25\t(1 << UHS_SDR25_BUS_SPEED)\n#define SD_MODE_UHS_SDR50\t(1 << UHS_SDR50_BUS_SPEED)\n#define SD_MODE_UHS_SDR104\t(1 << UHS_SDR104_BUS_SPEED)\n#define SD_MODE_UHS_DDR50\t(1 << UHS_DDR50_BUS_SPEED)\n\tunsigned int\t\tsd3_drv_type;\n#define SD_DRIVER_TYPE_B\t0x01\n#define SD_DRIVER_TYPE_A\t0x02\n#define SD_DRIVER_TYPE_C\t0x04\n#define SD_DRIVER_TYPE_D\t0x08\n\tunsigned int\t\tsd3_curr_limit;\n#define SD_SET_CURRENT_LIMIT_200\t0\n#define SD_SET_CURRENT_LIMIT_400\t1\n#define SD_SET_CURRENT_LIMIT_600\t2\n#define SD_SET_CURRENT_LIMIT_800\t3\n#define SD_SET_CURRENT_NO_CHANGE\t(-1)\n\n#define SD_MAX_CURRENT_200\t(1 << SD_SET_CURRENT_LIMIT_200)\n#define SD_MAX_CURRENT_400\t(1 << SD_SET_CURRENT_LIMIT_400)\n#define SD_MAX_CURRENT_600\t(1 << SD_SET_CURRENT_LIMIT_600)\n#define SD_MAX_CURRENT_800\t(1 << SD_SET_CURRENT_LIMIT_800)\n};\n\nstruct sd_ext_reg {\n\tu8\t\t\tfno;\n\tu8\t\t\tpage;\n\tu16\t\t\toffset;\n\tu8\t\t\trev;\n\tu8\t\t\tfeature_enabled;\n\tu8\t\t\tfeature_support;\n \n#define SD_EXT_POWER_OFF_NOTIFY\t(1<<0)\n#define SD_EXT_POWER_SUSTENANCE\t(1<<1)\n#define SD_EXT_POWER_DOWN_MODE\t(1<<2)\n \n#define SD_EXT_PERF_FX_EVENT\t(1<<0)\n#define SD_EXT_PERF_CARD_MAINT\t(1<<1)\n#define SD_EXT_PERF_HOST_MAINT\t(1<<2)\n#define SD_EXT_PERF_CACHE\t(1<<3)\n#define SD_EXT_PERF_CMD_QUEUE\t(1<<4)\n};\n\nstruct sdio_cccr {\n\tunsigned int\t\tsdio_vsn;\n\tunsigned int\t\tsd_vsn;\n\tunsigned int\t\tmulti_block:1,\n\t\t\t\tlow_speed:1,\n\t\t\t\twide_bus:1,\n\t\t\t\thigh_power:1,\n\t\t\t\thigh_speed:1,\n\t\t\t\tdisable_cd:1,\n\t\t\t\tenable_async_irq:1;\n};\n\nstruct sdio_cis {\n\tunsigned short\t\tvendor;\n\tunsigned short\t\tdevice;\n\tunsigned short\t\tblksize;\n\tunsigned int\t\tmax_dtr;\n};\n\nstruct mmc_host;\nstruct sdio_func;\nstruct sdio_func_tuple;\nstruct mmc_queue_req;\n\n#define SDIO_MAX_FUNCS\t\t7\n\n \n#define MMC_NUM_BOOT_PARTITION\t2\n#define MMC_NUM_GP_PARTITION\t4\n#define MMC_NUM_PHY_PARTITION\t7\n#define MAX_MMC_PART_NAME_LEN\t20\n\n \nstruct mmc_part {\n\tu64\t\tsize;\t \n\tunsigned int\tpart_cfg;\t \n\tchar\tname[MAX_MMC_PART_NAME_LEN];\n\tbool\tforce_ro;\t \n\tunsigned int\tarea_type;\n#define MMC_BLK_DATA_AREA_MAIN\t(1<<0)\n#define MMC_BLK_DATA_AREA_BOOT\t(1<<1)\n#define MMC_BLK_DATA_AREA_GP\t(1<<2)\n#define MMC_BLK_DATA_AREA_RPMB\t(1<<3)\n};\n\n \nstruct mmc_card {\n\tstruct mmc_host\t\t*host;\t\t \n\tstruct device\t\tdev;\t\t \n\tu32\t\t\tocr;\t\t \n\tunsigned int\t\trca;\t\t \n\tunsigned int\t\ttype;\t\t \n#define MMC_TYPE_MMC\t\t0\t\t \n#define MMC_TYPE_SD\t\t1\t\t \n#define MMC_TYPE_SDIO\t\t2\t\t \n#define MMC_TYPE_SD_COMBO\t3\t\t \n\tunsigned int\t\tstate;\t\t \n\tunsigned int\t\tquirks; \t \n\tunsigned int\t\tquirk_max_rate;\t \n#define MMC_QUIRK_LENIENT_FN0\t(1<<0)\t\t \n#define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)\t \n\t\t\t\t\t\t \n#define MMC_QUIRK_NONSTD_SDIO\t(1<<2)\t\t \n\t\t\t\t\t\t \n#define MMC_QUIRK_NONSTD_FUNC_IF (1<<4)\t\t \n#define MMC_QUIRK_DISABLE_CD\t(1<<5)\t\t \n#define MMC_QUIRK_INAND_CMD38\t(1<<6)\t\t \n#define MMC_QUIRK_BLK_NO_CMD23\t(1<<7)\t\t \n#define MMC_QUIRK_BROKEN_BYTE_MODE_512 (1<<8)\t \n\t\t\t\t\t\t \n#define MMC_QUIRK_LONG_READ_TIME (1<<9)\t\t \n#define MMC_QUIRK_SEC_ERASE_TRIM_BROKEN (1<<10)\t \n#define MMC_QUIRK_BROKEN_IRQ_POLLING\t(1<<11)\t \n#define MMC_QUIRK_TRIM_BROKEN\t(1<<12)\t\t \n#define MMC_QUIRK_BROKEN_HPI\t(1<<13)\t\t \n#define MMC_QUIRK_BROKEN_SD_DISCARD\t(1<<14)\t \n#define MMC_QUIRK_BROKEN_SD_CACHE\t(1<<15)\t \n#define MMC_QUIRK_BROKEN_CACHE_FLUSH\t(1<<16)\t \n\n\tbool\t\t\twritten_flag;\t \n\tbool\t\t\treenable_cmdq;\t \n\n\tunsigned int\t\terase_size;\t \n \tunsigned int\t\terase_shift;\t \n \tunsigned int\t\tpref_erase;\t \n\tunsigned int\t\teg_boundary;\t \n\tunsigned int\t\terase_arg;\t \n \tu8\t\t\terased_byte;\t \n\n\tu32\t\t\traw_cid[4];\t \n\tu32\t\t\traw_csd[4];\t \n\tu32\t\t\traw_scr[2];\t \n\tu32\t\t\traw_ssr[16];\t \n\tstruct mmc_cid\t\tcid;\t\t \n\tstruct mmc_csd\t\tcsd;\t\t \n\tstruct mmc_ext_csd\text_csd;\t \n\tstruct sd_scr\t\tscr;\t\t \n\tstruct sd_ssr\t\tssr;\t\t \n\tstruct sd_switch_caps\tsw_caps;\t \n\tstruct sd_ext_reg\text_power;\t \n\tstruct sd_ext_reg\text_perf;\t \n\n\tunsigned int\t\tsdio_funcs;\t \n\tatomic_t\t\tsdio_funcs_probed;  \n\tstruct sdio_cccr\tcccr;\t\t \n\tstruct sdio_cis\t\tcis;\t\t \n\tstruct sdio_func\t*sdio_func[SDIO_MAX_FUNCS];  \n\tstruct sdio_func\t*sdio_single_irq;  \n\tu8\t\t\tmajor_rev;\t \n\tu8\t\t\tminor_rev;\t \n\tunsigned\t\tnum_info;\t \n\tconst char\t\t**info;\t\t \n\tstruct sdio_func_tuple\t*tuples;\t \n\n\tunsigned int\t\tsd_bus_speed;\t \n\tunsigned int\t\tmmc_avail_type;\t \n\tunsigned int\t\tdrive_strength;\t \n\n\tstruct dentry\t\t*debugfs_root;\n\tstruct mmc_part\tpart[MMC_NUM_PHY_PARTITION];  \n\tunsigned int    nr_parts;\n\n\tstruct workqueue_struct *complete_wq;\t \n};\n\nstatic inline bool mmc_large_sector(struct mmc_card *card)\n{\n\treturn card->ext_csd.data_sector_size == 4096;\n}\n\nstatic inline int mmc_card_enable_async_irq(struct mmc_card *card)\n{\n\treturn card->cccr.enable_async_irq;\n}\n\nbool mmc_card_is_blockaddr(struct mmc_card *card);\n\n#define mmc_card_mmc(c)\t\t((c)->type == MMC_TYPE_MMC)\n#define mmc_card_sd(c)\t\t((c)->type == MMC_TYPE_SD)\n#define mmc_card_sdio(c)\t((c)->type == MMC_TYPE_SDIO)\n#define mmc_card_sd_combo(c)\t((c)->type == MMC_TYPE_SD_COMBO)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}