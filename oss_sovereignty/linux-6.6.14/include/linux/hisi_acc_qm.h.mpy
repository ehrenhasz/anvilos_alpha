{
  "module_name": "hisi_acc_qm.h",
  "hash_id": "4f53ea1375b883728f432f54d065e1cb8f6ec0f0b691ddb9545fce72f8fb5ef4",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/hisi_acc_qm.h",
  "human_readable_source": " \n \n#ifndef HISI_ACC_QM_H\n#define HISI_ACC_QM_H\n\n#include <linux/bitfield.h>\n#include <linux/debugfs.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#define QM_QNUM_V1\t\t\t4096\n#define QM_QNUM_V2\t\t\t1024\n#define QM_MAX_VFS_NUM_V2\t\t63\n\n \n#define QM_ARUSER_M_CFG_1\t\t0x100088\n#define AXUSER_SNOOP_ENABLE\t\tBIT(30)\n#define AXUSER_CMD_TYPE\t\t\tGENMASK(14, 12)\n#define AXUSER_CMD_SMMU_NORMAL\t\t1\n#define AXUSER_NS\t\t\tBIT(6)\n#define AXUSER_NO\t\t\tBIT(5)\n#define AXUSER_FP\t\t\tBIT(4)\n#define AXUSER_SSV\t\t\tBIT(0)\n#define AXUSER_BASE\t\t\t(AXUSER_SNOOP_ENABLE |\t\t\\\n\t\t\t\t\tFIELD_PREP(AXUSER_CMD_TYPE,\t\\\n\t\t\t\t\tAXUSER_CMD_SMMU_NORMAL) |\t\\\n\t\t\t\t\tAXUSER_NS | AXUSER_NO | AXUSER_FP)\n#define QM_ARUSER_M_CFG_ENABLE\t\t0x100090\n#define ARUSER_M_CFG_ENABLE\t\t0xfffffffe\n#define QM_AWUSER_M_CFG_1\t\t0x100098\n#define QM_AWUSER_M_CFG_ENABLE\t\t0x1000a0\n#define AWUSER_M_CFG_ENABLE\t\t0xfffffffe\n#define QM_WUSER_M_CFG_ENABLE\t\t0x1000a8\n#define WUSER_M_CFG_ENABLE\t\t0xffffffff\n\n \n#define QM_MB_CMD_SQC                   0x0\n#define QM_MB_CMD_CQC                   0x1\n#define QM_MB_CMD_EQC                   0x2\n#define QM_MB_CMD_AEQC                  0x3\n#define QM_MB_CMD_SQC_BT                0x4\n#define QM_MB_CMD_CQC_BT                0x5\n#define QM_MB_CMD_SQC_VFT_V2            0x6\n#define QM_MB_CMD_STOP_QP               0x8\n#define QM_MB_CMD_SRC                   0xc\n#define QM_MB_CMD_DST                   0xd\n\n#define QM_MB_CMD_SEND_BASE\t\t0x300\n#define QM_MB_EVENT_SHIFT               8\n#define QM_MB_BUSY_SHIFT\t\t13\n#define QM_MB_OP_SHIFT\t\t\t14\n#define QM_MB_CMD_DATA_ADDR_L\t\t0x304\n#define QM_MB_CMD_DATA_ADDR_H\t\t0x308\n#define QM_MB_MAX_WAIT_CNT\t\t6000\n\n \n#define QM_DOORBELL_CMD_SQ              0\n#define QM_DOORBELL_CMD_CQ              1\n#define QM_DOORBELL_CMD_EQ              2\n#define QM_DOORBELL_CMD_AEQ             3\n\n#define QM_DOORBELL_SQ_CQ_BASE_V2\t0x1000\n#define QM_DOORBELL_EQ_AEQ_BASE_V2\t0x2000\n#define QM_QP_MAX_NUM_SHIFT             11\n#define QM_DB_CMD_SHIFT_V2\t\t12\n#define QM_DB_RAND_SHIFT_V2\t\t16\n#define QM_DB_INDEX_SHIFT_V2\t\t32\n#define QM_DB_PRIORITY_SHIFT_V2\t\t48\n#define QM_VF_STATE\t\t\t0x60\n\n \n#define QM_CACHE_CTL\t\t\t0x100050\n#define SQC_CACHE_ENABLE\t\tBIT(0)\n#define CQC_CACHE_ENABLE\t\tBIT(1)\n#define SQC_CACHE_WB_ENABLE\t\tBIT(4)\n#define SQC_CACHE_WB_THRD\t\tGENMASK(10, 5)\n#define CQC_CACHE_WB_ENABLE\t\tBIT(11)\n#define CQC_CACHE_WB_THRD\t\tGENMASK(17, 12)\n#define QM_AXI_M_CFG\t\t\t0x1000ac\n#define AXI_M_CFG\t\t\t0xffff\n#define QM_AXI_M_CFG_ENABLE\t\t0x1000b0\n#define AM_CFG_SINGLE_PORT_MAX_TRANS\t0x300014\n#define AXI_M_CFG_ENABLE\t\t0xffffffff\n#define QM_PEH_AXUSER_CFG\t\t0x1000cc\n#define QM_PEH_AXUSER_CFG_ENABLE\t0x1000d0\n#define PEH_AXUSER_CFG\t\t\t0x401001\n#define PEH_AXUSER_CFG_ENABLE\t\t0xffffffff\n\n#define QM_MIN_QNUM                     2\n#define HISI_ACC_SGL_SGE_NR_MAX\t\t255\n#define QM_SHAPER_CFG\t\t\t0x100164\n#define QM_SHAPER_ENABLE\t\tBIT(30)\n#define QM_SHAPER_TYPE1_OFFSET\t\t10\n\n \n#define QM_DOORBELL_PAGE_NR\t\t1\n\n \n#define UACCE_MODE_NOUACCE\t\t0  \n#define UACCE_MODE_SVA\t\t\t1  \n#define UACCE_MODE_DESC\t\"0(default) means only register to crypto, 1 means both register to crypto and uacce\"\n\nenum qm_stop_reason {\n\tQM_NORMAL,\n\tQM_SOFT_RESET,\n\tQM_DOWN,\n};\n\nenum qm_state {\n\tQM_INIT = 0,\n\tQM_START,\n\tQM_CLOSE,\n\tQM_STOP,\n};\n\nenum qp_state {\n\tQP_INIT = 1,\n\tQP_START,\n\tQP_STOP,\n\tQP_CLOSE,\n};\n\nenum qm_hw_ver {\n\tQM_HW_V1 = 0x20,\n\tQM_HW_V2 = 0x21,\n\tQM_HW_V3 = 0x30,\n};\n\nenum qm_fun_type {\n\tQM_HW_PF,\n\tQM_HW_VF,\n};\n\nenum qm_debug_file {\n\tCURRENT_QM,\n\tCURRENT_Q,\n\tCLEAR_ENABLE,\n\tDEBUG_FILE_NUM,\n};\n\nenum qm_vf_state {\n\tQM_READY = 0,\n\tQM_NOT_READY,\n};\n\nenum qm_misc_ctl_bits {\n\tQM_DRIVER_REMOVING = 0x0,\n\tQM_RST_SCHED,\n\tQM_RESETTING,\n\tQM_MODULE_PARAM,\n};\n\nenum qm_cap_bits {\n\tQM_SUPPORT_DB_ISOLATION = 0x0,\n\tQM_SUPPORT_FUNC_QOS,\n\tQM_SUPPORT_STOP_QP,\n\tQM_SUPPORT_MB_COMMAND,\n\tQM_SUPPORT_SVA_PREFETCH,\n\tQM_SUPPORT_RPM,\n};\n\nstruct qm_dev_alg {\n\tu64 alg_msk;\n\tconst char *alg;\n};\n\nstruct dfx_diff_registers {\n\tu32 *regs;\n\tu32 reg_offset;\n\tu32 reg_len;\n};\n\nstruct qm_dfx {\n\tatomic64_t err_irq_cnt;\n\tatomic64_t aeq_irq_cnt;\n\tatomic64_t abnormal_irq_cnt;\n\tatomic64_t create_qp_err_cnt;\n\tatomic64_t mb_err_cnt;\n};\n\nstruct debugfs_file {\n\tenum qm_debug_file index;\n\tstruct mutex lock;\n\tstruct qm_debug *debug;\n};\n\nstruct qm_debug {\n\tu32 curr_qm_qp_num;\n\tu32 sqe_mask_offset;\n\tu32 sqe_mask_len;\n\tstruct qm_dfx dfx;\n\tstruct dentry *debug_root;\n\tstruct dentry *qm_d;\n\tstruct debugfs_file files[DEBUG_FILE_NUM];\n\tunsigned int *qm_last_words;\n\t \n\tunsigned int *last_words;\n\tstruct dfx_diff_registers *qm_diff_regs;\n\tstruct dfx_diff_registers *acc_diff_regs;\n};\n\nstruct qm_shaper_factor {\n\tu32 func_qos;\n\tu64 cir_b;\n\tu64 cir_u;\n\tu64 cir_s;\n\tu64 cbs_s;\n};\n\nstruct qm_dma {\n\tvoid *va;\n\tdma_addr_t dma;\n\tsize_t size;\n};\n\nstruct hisi_qm_status {\n\tu32 eq_head;\n\tbool eqc_phase;\n\tu32 aeq_head;\n\tbool aeqc_phase;\n\tatomic_t flags;\n\tint stop_reason;\n};\n\nstruct hisi_qm;\n\nstruct hisi_qm_err_info {\n\tchar *acpi_rst;\n\tu32 msi_wr_port;\n\tu32 ecc_2bits_mask;\n\tu32 qm_shutdown_mask;\n\tu32 dev_shutdown_mask;\n\tu32 qm_reset_mask;\n\tu32 dev_reset_mask;\n\tu32 ce;\n\tu32 nfe;\n\tu32 fe;\n};\n\nstruct hisi_qm_err_status {\n\tu32 is_qm_ecc_mbit;\n\tu32 is_dev_ecc_mbit;\n};\n\nstruct hisi_qm_err_ini {\n\tint (*hw_init)(struct hisi_qm *qm);\n\tvoid (*hw_err_enable)(struct hisi_qm *qm);\n\tvoid (*hw_err_disable)(struct hisi_qm *qm);\n\tu32 (*get_dev_hw_err_status)(struct hisi_qm *qm);\n\tvoid (*clear_dev_hw_err_status)(struct hisi_qm *qm, u32 err_sts);\n\tvoid (*open_axi_master_ooo)(struct hisi_qm *qm);\n\tvoid (*close_axi_master_ooo)(struct hisi_qm *qm);\n\tvoid (*open_sva_prefetch)(struct hisi_qm *qm);\n\tvoid (*close_sva_prefetch)(struct hisi_qm *qm);\n\tvoid (*log_dev_hw_err)(struct hisi_qm *qm, u32 err_sts);\n\tvoid (*show_last_dfx_regs)(struct hisi_qm *qm);\n\tvoid (*err_info_init)(struct hisi_qm *qm);\n};\n\nstruct hisi_qm_cap_info {\n\tu32 type;\n\t \n\tu32 offset;\n\t \n\tu32 shift;\n\tu32 mask;\n\tu32 v1_val;\n\tu32 v2_val;\n\tu32 v3_val;\n};\n\nstruct hisi_qm_cap_record {\n\tu32 type;\n\tu32 cap_val;\n};\n\nstruct hisi_qm_cap_tables {\n\tstruct hisi_qm_cap_record *qm_cap_table;\n\tstruct hisi_qm_cap_record *dev_cap_table;\n};\n\nstruct hisi_qm_list {\n\tstruct mutex lock;\n\tstruct list_head list;\n\tint (*register_to_crypto)(struct hisi_qm *qm);\n\tvoid (*unregister_from_crypto)(struct hisi_qm *qm);\n};\n\nstruct hisi_qm_poll_data {\n\tstruct hisi_qm *qm;\n\tstruct work_struct work;\n\tu16 *qp_finish_id;\n\tu16 eqe_num;\n};\n\n \nstruct qm_err_isolate {\n\tstruct mutex isolate_lock;\n\tu32 err_threshold;\n\tbool is_isolate;\n\tstruct list_head qm_hw_errs;\n};\n\nstruct hisi_qm {\n\tenum qm_hw_ver ver;\n\tenum qm_fun_type fun_type;\n\tconst char *dev_name;\n\tstruct pci_dev *pdev;\n\tvoid __iomem *io_base;\n\tvoid __iomem *db_io_base;\n\n\t \n\tu32 cap_ver;\n\tu32 sqe_size;\n\tu32 qp_base;\n\tu32 qp_num;\n\tu32 qp_in_used;\n\tu32 ctrl_qp_num;\n\tu32 max_qp_num;\n\tu32 vfs_num;\n\tu32 db_interval;\n\tu16 eq_depth;\n\tu16 aeq_depth;\n\tstruct list_head list;\n\tstruct hisi_qm_list *qm_list;\n\n\tstruct qm_dma qdma;\n\tstruct qm_sqc *sqc;\n\tstruct qm_cqc *cqc;\n\tstruct qm_eqe *eqe;\n\tstruct qm_aeqe *aeqe;\n\tdma_addr_t sqc_dma;\n\tdma_addr_t cqc_dma;\n\tdma_addr_t eqe_dma;\n\tdma_addr_t aeqe_dma;\n\n\tstruct hisi_qm_status status;\n\tconst struct hisi_qm_err_ini *err_ini;\n\tstruct hisi_qm_err_info err_info;\n\tstruct hisi_qm_err_status err_status;\n\t \n\tunsigned long misc_ctl;\n\t \n\tunsigned long caps;\n\n\tstruct rw_semaphore qps_lock;\n\tstruct idr qp_idr;\n\tstruct hisi_qp *qp_array;\n\tstruct hisi_qm_poll_data *poll_data;\n\n\tstruct mutex mailbox_lock;\n\n\tconst struct hisi_qm_hw_ops *ops;\n\n\tstruct qm_debug debug;\n\n\tu32 error_mask;\n\n\tstruct workqueue_struct *wq;\n\tstruct work_struct rst_work;\n\tstruct work_struct cmd_process;\n\n\tbool use_sva;\n\n\tresource_size_t phys_base;\n\tresource_size_t db_phys_base;\n\tstruct uacce_device *uacce;\n\tint mode;\n\tstruct qm_shaper_factor *factor;\n\tu32 mb_qos;\n\tu32 type_rate;\n\tstruct qm_err_isolate isolate_data;\n\n\tstruct hisi_qm_cap_tables cap_tables;\n};\n\nstruct hisi_qp_status {\n\tatomic_t used;\n\tu16 sq_tail;\n\tu16 cq_head;\n\tbool cqc_phase;\n\tatomic_t flags;\n};\n\nstruct hisi_qp_ops {\n\tint (*fill_sqe)(void *sqe, void *q_parm, void *d_parm);\n};\n\nstruct hisi_qp {\n\tu32 qp_id;\n\tu16 sq_depth;\n\tu16 cq_depth;\n\tu8 alg_type;\n\tu8 req_type;\n\n\tstruct qm_dma qdma;\n\tvoid *sqe;\n\tstruct qm_cqe *cqe;\n\tdma_addr_t sqe_dma;\n\tdma_addr_t cqe_dma;\n\n\tstruct hisi_qp_status qp_status;\n\tstruct hisi_qp_ops *hw_ops;\n\tvoid *qp_ctx;\n\tvoid (*req_cb)(struct hisi_qp *qp, void *data);\n\tvoid (*event_cb)(struct hisi_qp *qp);\n\n\tstruct hisi_qm *qm;\n\tbool is_resetting;\n\tbool is_in_kernel;\n\tu16 pasid;\n\tstruct uacce_queue *uacce_q;\n};\n\nstatic inline int q_num_set(const char *val, const struct kernel_param *kp,\n\t\t\t    unsigned int device)\n{\n\tstruct pci_dev *pdev;\n\tu32 n, q_num;\n\tint ret;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_HUAWEI, device, NULL);\n\tif (!pdev) {\n\t\tq_num = min_t(u32, QM_QNUM_V1, QM_QNUM_V2);\n\t\tpr_info(\"No device found currently, suppose queue number is %u\\n\",\n\t\t\tq_num);\n\t} else {\n\t\tif (pdev->revision == QM_HW_V1)\n\t\t\tq_num = QM_QNUM_V1;\n\t\telse\n\t\t\tq_num = QM_QNUM_V2;\n\n\t\tpci_dev_put(pdev);\n\t}\n\n\tret = kstrtou32(val, 10, &n);\n\tif (ret || n < QM_MIN_QNUM || n > q_num)\n\t\treturn -EINVAL;\n\n\treturn param_set_int(val, kp);\n}\n\nstatic inline int vfs_num_set(const char *val, const struct kernel_param *kp)\n{\n\tu32 n;\n\tint ret;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tret = kstrtou32(val, 10, &n);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (n > QM_MAX_VFS_NUM_V2)\n\t\treturn -EINVAL;\n\n\treturn param_set_int(val, kp);\n}\n\nstatic inline int mode_set(const char *val, const struct kernel_param *kp)\n{\n\tu32 n;\n\tint ret;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tret = kstrtou32(val, 10, &n);\n\tif (ret != 0 || (n != UACCE_MODE_SVA &&\n\t\t\t n != UACCE_MODE_NOUACCE))\n\t\treturn -EINVAL;\n\n\treturn param_set_int(val, kp);\n}\n\nstatic inline int uacce_mode_set(const char *val, const struct kernel_param *kp)\n{\n\treturn mode_set(val, kp);\n}\n\nstatic inline void hisi_qm_init_list(struct hisi_qm_list *qm_list)\n{\n\tINIT_LIST_HEAD(&qm_list->list);\n\tmutex_init(&qm_list->lock);\n}\n\nint hisi_qm_init(struct hisi_qm *qm);\nvoid hisi_qm_uninit(struct hisi_qm *qm);\nint hisi_qm_start(struct hisi_qm *qm);\nint hisi_qm_stop(struct hisi_qm *qm, enum qm_stop_reason r);\nint hisi_qm_start_qp(struct hisi_qp *qp, unsigned long arg);\nint hisi_qm_stop_qp(struct hisi_qp *qp);\nint hisi_qp_send(struct hisi_qp *qp, const void *msg);\nvoid hisi_qm_debug_init(struct hisi_qm *qm);\nvoid hisi_qm_debug_regs_clear(struct hisi_qm *qm);\nint hisi_qm_sriov_enable(struct pci_dev *pdev, int max_vfs);\nint hisi_qm_sriov_disable(struct pci_dev *pdev, bool is_frozen);\nint hisi_qm_sriov_configure(struct pci_dev *pdev, int num_vfs);\nvoid hisi_qm_dev_err_init(struct hisi_qm *qm);\nvoid hisi_qm_dev_err_uninit(struct hisi_qm *qm);\nint hisi_qm_regs_debugfs_init(struct hisi_qm *qm,\n\t\t\t  struct dfx_diff_registers *dregs, u32 reg_len);\nvoid hisi_qm_regs_debugfs_uninit(struct hisi_qm *qm, u32 reg_len);\nvoid hisi_qm_acc_diff_regs_dump(struct hisi_qm *qm, struct seq_file *s,\n\t\t\t\tstruct dfx_diff_registers *dregs, u32 regs_len);\n\npci_ers_result_t hisi_qm_dev_err_detected(struct pci_dev *pdev,\n\t\t\t\t\t  pci_channel_state_t state);\npci_ers_result_t hisi_qm_dev_slot_reset(struct pci_dev *pdev);\nvoid hisi_qm_reset_prepare(struct pci_dev *pdev);\nvoid hisi_qm_reset_done(struct pci_dev *pdev);\n\nint hisi_qm_wait_mb_ready(struct hisi_qm *qm);\nint hisi_qm_mb(struct hisi_qm *qm, u8 cmd, dma_addr_t dma_addr, u16 queue,\n\t       bool op);\n\nstruct hisi_acc_sgl_pool;\nstruct hisi_acc_hw_sgl *hisi_acc_sg_buf_map_to_hw_sgl(struct device *dev,\n\tstruct scatterlist *sgl, struct hisi_acc_sgl_pool *pool,\n\tu32 index, dma_addr_t *hw_sgl_dma);\nvoid hisi_acc_sg_buf_unmap(struct device *dev, struct scatterlist *sgl,\n\t\t\t   struct hisi_acc_hw_sgl *hw_sgl);\nstruct hisi_acc_sgl_pool *hisi_acc_create_sgl_pool(struct device *dev,\n\t\t\t\t\t\t   u32 count, u32 sge_nr);\nvoid hisi_acc_free_sgl_pool(struct device *dev,\n\t\t\t    struct hisi_acc_sgl_pool *pool);\nint hisi_qm_alloc_qps_node(struct hisi_qm_list *qm_list, int qp_num,\n\t\t\t   u8 alg_type, int node, struct hisi_qp **qps);\nvoid hisi_qm_free_qps(struct hisi_qp **qps, int qp_num);\nvoid hisi_qm_dev_shutdown(struct pci_dev *pdev);\nvoid hisi_qm_wait_task_finish(struct hisi_qm *qm, struct hisi_qm_list *qm_list);\nint hisi_qm_alg_register(struct hisi_qm *qm, struct hisi_qm_list *qm_list);\nvoid hisi_qm_alg_unregister(struct hisi_qm *qm, struct hisi_qm_list *qm_list);\nint hisi_qm_resume(struct device *dev);\nint hisi_qm_suspend(struct device *dev);\nvoid hisi_qm_pm_uninit(struct hisi_qm *qm);\nvoid hisi_qm_pm_init(struct hisi_qm *qm);\nint hisi_qm_get_dfx_access(struct hisi_qm *qm);\nvoid hisi_qm_put_dfx_access(struct hisi_qm *qm);\nvoid hisi_qm_regs_dump(struct seq_file *s, struct debugfs_regset32 *regset);\nu32 hisi_qm_get_hw_info(struct hisi_qm *qm,\n\t\t\tconst struct hisi_qm_cap_info *info_table,\n\t\t\tu32 index, bool is_read);\nint hisi_qm_set_algs(struct hisi_qm *qm, u64 alg_msk, const struct qm_dev_alg *dev_algs,\n\t\t     u32 dev_algs_size);\n\n \nstruct pci_driver *hisi_sec_get_pf_driver(void);\nstruct pci_driver *hisi_hpre_get_pf_driver(void);\nstruct pci_driver *hisi_zip_get_pf_driver(void);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}