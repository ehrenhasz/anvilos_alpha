{
  "module_name": "rculist.h",
  "hash_id": "deb588a753d15aa0482a273f4638b51f2f443d304cd18c9e83e3d7373e7b5ded",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/rculist.h",
  "human_readable_source": " \n#ifndef _LINUX_RCULIST_H\n#define _LINUX_RCULIST_H\n\n#ifdef __KERNEL__\n\n \n#include <linux/list.h>\n#include <linux/rcupdate.h>\n\n \nstatic inline void INIT_LIST_HEAD_RCU(struct list_head *list)\n{\n\tWRITE_ONCE(list->next, list);\n\tWRITE_ONCE(list->prev, list);\n}\n\n \n#define list_next_rcu(list)\t(*((struct list_head __rcu **)(&(list)->next)))\n\n \n#define list_tail_rcu(head)\t(*((struct list_head __rcu **)(&(head)->prev)))\n\n \n\n#define check_arg_count_one(dummy)\n\n#ifdef CONFIG_PROVE_RCU_LIST\n#define __list_check_rcu(dummy, cond, extra...)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\tcheck_arg_count_one(extra);\t\t\t\t\t\\\n\tRCU_LOCKDEP_WARN(!(cond) && !rcu_read_lock_any_held(),\t\t\\\n\t\t\t \"RCU-list traversed in non-reader section!\");\t\\\n\t})\n\n#define __list_check_srcu(cond)\t\t\t\t\t \\\n\t({\t\t\t\t\t\t\t\t \\\n\tRCU_LOCKDEP_WARN(!(cond),\t\t\t\t\t \\\n\t\t\"RCU-list traversed without holding the required lock!\");\\\n\t})\n#else\n#define __list_check_rcu(dummy, cond, extra...)\t\t\t\t\\\n\t({ check_arg_count_one(extra); })\n\n#define __list_check_srcu(cond) ({ })\n#endif\n\n \nstatic inline void __list_add_rcu(struct list_head *new,\n\t\tstruct list_head *prev, struct list_head *next)\n{\n\tif (!__list_add_valid(new, prev, next))\n\t\treturn;\n\n\tnew->next = next;\n\tnew->prev = prev;\n\trcu_assign_pointer(list_next_rcu(prev), new);\n\tnext->prev = new;\n}\n\n \nstatic inline void list_add_rcu(struct list_head *new, struct list_head *head)\n{\n\t__list_add_rcu(new, head, head->next);\n}\n\n \nstatic inline void list_add_tail_rcu(struct list_head *new,\n\t\t\t\t\tstruct list_head *head)\n{\n\t__list_add_rcu(new, head->prev, head);\n}\n\n \nstatic inline void list_del_rcu(struct list_head *entry)\n{\n\t__list_del_entry(entry);\n\tentry->prev = LIST_POISON2;\n}\n\n \nstatic inline void hlist_del_init_rcu(struct hlist_node *n)\n{\n\tif (!hlist_unhashed(n)) {\n\t\t__hlist_del(n);\n\t\tWRITE_ONCE(n->pprev, NULL);\n\t}\n}\n\n \nstatic inline void list_replace_rcu(struct list_head *old,\n\t\t\t\tstruct list_head *new)\n{\n\tnew->next = old->next;\n\tnew->prev = old->prev;\n\trcu_assign_pointer(list_next_rcu(new->prev), new);\n\tnew->next->prev = new;\n\told->prev = LIST_POISON2;\n}\n\n \nstatic inline void __list_splice_init_rcu(struct list_head *list,\n\t\t\t\t\t  struct list_head *prev,\n\t\t\t\t\t  struct list_head *next,\n\t\t\t\t\t  void (*sync)(void))\n{\n\tstruct list_head *first = list->next;\n\tstruct list_head *last = list->prev;\n\n\t \n\n\tINIT_LIST_HEAD_RCU(list);\n\n\t \n\n\tsync();\n\tASSERT_EXCLUSIVE_ACCESS(*first);\n\tASSERT_EXCLUSIVE_ACCESS(*last);\n\n\t \n\n\tlast->next = next;\n\trcu_assign_pointer(list_next_rcu(prev), first);\n\tfirst->prev = prev;\n\tnext->prev = last;\n}\n\n \nstatic inline void list_splice_init_rcu(struct list_head *list,\n\t\t\t\t\tstruct list_head *head,\n\t\t\t\t\tvoid (*sync)(void))\n{\n\tif (!list_empty(list))\n\t\t__list_splice_init_rcu(list, head, head->next, sync);\n}\n\n \nstatic inline void list_splice_tail_init_rcu(struct list_head *list,\n\t\t\t\t\t     struct list_head *head,\n\t\t\t\t\t     void (*sync)(void))\n{\n\tif (!list_empty(list))\n\t\t__list_splice_init_rcu(list, head->prev, head, sync);\n}\n\n \n#define list_entry_rcu(ptr, type, member) \\\n\tcontainer_of(READ_ONCE(ptr), type, member)\n\n \n\n \n#define list_first_or_null_rcu(ptr, type, member) \\\n({ \\\n\tstruct list_head *__ptr = (ptr); \\\n\tstruct list_head *__next = READ_ONCE(__ptr->next); \\\n\tlikely(__ptr != __next) ? list_entry_rcu(__next, type, member) : NULL; \\\n})\n\n \n#define list_next_or_null_rcu(head, ptr, type, member) \\\n({ \\\n\tstruct list_head *__head = (head); \\\n\tstruct list_head *__ptr = (ptr); \\\n\tstruct list_head *__next = READ_ONCE(__ptr->next); \\\n\tlikely(__next != __head) ? list_entry_rcu(__next, type, \\\n\t\t\t\t\t\t  member) : NULL; \\\n})\n\n \n#define list_for_each_entry_rcu(pos, head, member, cond...)\t\t\\\n\tfor (__list_check_rcu(dummy, ## cond, 0),\t\t\t\\\n\t     pos = list_entry_rcu((head)->next, typeof(*pos), member);\t\\\n\t\t&pos->member != (head);\t\t\t\t\t\\\n\t\tpos = list_entry_rcu(pos->member.next, typeof(*pos), member))\n\n \n#define list_for_each_entry_srcu(pos, head, member, cond)\t\t\\\n\tfor (__list_check_srcu(cond),\t\t\t\t\t\\\n\t     pos = list_entry_rcu((head)->next, typeof(*pos), member);\t\\\n\t\t&pos->member != (head);\t\t\t\t\t\\\n\t\tpos = list_entry_rcu(pos->member.next, typeof(*pos), member))\n\n \n#define list_entry_lockless(ptr, type, member) \\\n\tcontainer_of((typeof(ptr))READ_ONCE(ptr), type, member)\n\n \n#define list_for_each_entry_lockless(pos, head, member) \\\n\tfor (pos = list_entry_lockless((head)->next, typeof(*pos), member); \\\n\t     &pos->member != (head); \\\n\t     pos = list_entry_lockless(pos->member.next, typeof(*pos), member))\n\n \n#define list_for_each_entry_continue_rcu(pos, head, member) \t\t\\\n\tfor (pos = list_entry_rcu(pos->member.next, typeof(*pos), member); \\\n\t     &pos->member != (head);\t\\\n\t     pos = list_entry_rcu(pos->member.next, typeof(*pos), member))\n\n \n#define list_for_each_entry_from_rcu(pos, head, member)\t\t\t\\\n\tfor (; &(pos)->member != (head);\t\t\t\t\t\\\n\t\tpos = list_entry_rcu(pos->member.next, typeof(*(pos)), member))\n\n \nstatic inline void hlist_del_rcu(struct hlist_node *n)\n{\n\t__hlist_del(n);\n\tWRITE_ONCE(n->pprev, LIST_POISON2);\n}\n\n \nstatic inline void hlist_replace_rcu(struct hlist_node *old,\n\t\t\t\t\tstruct hlist_node *new)\n{\n\tstruct hlist_node *next = old->next;\n\n\tnew->next = next;\n\tWRITE_ONCE(new->pprev, old->pprev);\n\trcu_assign_pointer(*(struct hlist_node __rcu **)new->pprev, new);\n\tif (next)\n\t\tWRITE_ONCE(new->next->pprev, &new->next);\n\tWRITE_ONCE(old->pprev, LIST_POISON2);\n}\n\n \nstatic inline void hlists_swap_heads_rcu(struct hlist_head *left, struct hlist_head *right)\n{\n\tstruct hlist_node *node1 = left->first;\n\tstruct hlist_node *node2 = right->first;\n\n\trcu_assign_pointer(left->first, node2);\n\trcu_assign_pointer(right->first, node1);\n\tWRITE_ONCE(node2->pprev, &left->first);\n\tWRITE_ONCE(node1->pprev, &right->first);\n}\n\n \n#define hlist_first_rcu(head)\t(*((struct hlist_node __rcu **)(&(head)->first)))\n#define hlist_next_rcu(node)\t(*((struct hlist_node __rcu **)(&(node)->next)))\n#define hlist_pprev_rcu(node)\t(*((struct hlist_node __rcu **)((node)->pprev)))\n\n \nstatic inline void hlist_add_head_rcu(struct hlist_node *n,\n\t\t\t\t\tstruct hlist_head *h)\n{\n\tstruct hlist_node *first = h->first;\n\n\tn->next = first;\n\tWRITE_ONCE(n->pprev, &h->first);\n\trcu_assign_pointer(hlist_first_rcu(h), n);\n\tif (first)\n\t\tWRITE_ONCE(first->pprev, &n->next);\n}\n\n \nstatic inline void hlist_add_tail_rcu(struct hlist_node *n,\n\t\t\t\t      struct hlist_head *h)\n{\n\tstruct hlist_node *i, *last = NULL;\n\n\t \n\tfor (i = h->first; i; i = i->next)\n\t\tlast = i;\n\n\tif (last) {\n\t\tn->next = last->next;\n\t\tWRITE_ONCE(n->pprev, &last->next);\n\t\trcu_assign_pointer(hlist_next_rcu(last), n);\n\t} else {\n\t\thlist_add_head_rcu(n, h);\n\t}\n}\n\n \nstatic inline void hlist_add_before_rcu(struct hlist_node *n,\n\t\t\t\t\tstruct hlist_node *next)\n{\n\tWRITE_ONCE(n->pprev, next->pprev);\n\tn->next = next;\n\trcu_assign_pointer(hlist_pprev_rcu(n), n);\n\tWRITE_ONCE(next->pprev, &n->next);\n}\n\n \nstatic inline void hlist_add_behind_rcu(struct hlist_node *n,\n\t\t\t\t\tstruct hlist_node *prev)\n{\n\tn->next = prev->next;\n\tWRITE_ONCE(n->pprev, &prev->next);\n\trcu_assign_pointer(hlist_next_rcu(prev), n);\n\tif (n->next)\n\t\tWRITE_ONCE(n->next->pprev, &n->next);\n}\n\n#define __hlist_for_each_rcu(pos, head)\t\t\t\t\\\n\tfor (pos = rcu_dereference(hlist_first_rcu(head));\t\\\n\t     pos;\t\t\t\t\t\t\\\n\t     pos = rcu_dereference(hlist_next_rcu(pos)))\n\n \n#define hlist_for_each_entry_rcu(pos, head, member, cond...)\t\t\\\n\tfor (__list_check_rcu(dummy, ## cond, 0),\t\t\t\\\n\t     pos = hlist_entry_safe(rcu_dereference_raw(hlist_first_rcu(head)),\\\n\t\t\ttypeof(*(pos)), member);\t\t\t\\\n\t\tpos;\t\t\t\t\t\t\t\\\n\t\tpos = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(\\\n\t\t\t&(pos)->member)), typeof(*(pos)), member))\n\n \n#define hlist_for_each_entry_srcu(pos, head, member, cond)\t\t\\\n\tfor (__list_check_srcu(cond),\t\t\t\t\t\\\n\t     pos = hlist_entry_safe(rcu_dereference_raw(hlist_first_rcu(head)),\\\n\t\t\ttypeof(*(pos)), member);\t\t\t\\\n\t\tpos;\t\t\t\t\t\t\t\\\n\t\tpos = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(\\\n\t\t\t&(pos)->member)), typeof(*(pos)), member))\n\n \n#define hlist_for_each_entry_rcu_notrace(pos, head, member)\t\t\t\\\n\tfor (pos = hlist_entry_safe(rcu_dereference_raw_check(hlist_first_rcu(head)),\\\n\t\t\ttypeof(*(pos)), member);\t\t\t\\\n\t\tpos;\t\t\t\t\t\t\t\\\n\t\tpos = hlist_entry_safe(rcu_dereference_raw_check(hlist_next_rcu(\\\n\t\t\t&(pos)->member)), typeof(*(pos)), member))\n\n \n#define hlist_for_each_entry_rcu_bh(pos, head, member)\t\t\t\\\n\tfor (pos = hlist_entry_safe(rcu_dereference_bh(hlist_first_rcu(head)),\\\n\t\t\ttypeof(*(pos)), member);\t\t\t\\\n\t\tpos;\t\t\t\t\t\t\t\\\n\t\tpos = hlist_entry_safe(rcu_dereference_bh(hlist_next_rcu(\\\n\t\t\t&(pos)->member)), typeof(*(pos)), member))\n\n \n#define hlist_for_each_entry_continue_rcu(pos, member)\t\t\t\\\n\tfor (pos = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu( \\\n\t\t\t&(pos)->member)), typeof(*(pos)), member);\t\\\n\t     pos;\t\t\t\t\t\t\t\\\n\t     pos = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(\t\\\n\t\t\t&(pos)->member)), typeof(*(pos)), member))\n\n \n#define hlist_for_each_entry_continue_rcu_bh(pos, member)\t\t\\\n\tfor (pos = hlist_entry_safe(rcu_dereference_bh(hlist_next_rcu(  \\\n\t\t\t&(pos)->member)), typeof(*(pos)), member);\t\\\n\t     pos;\t\t\t\t\t\t\t\\\n\t     pos = hlist_entry_safe(rcu_dereference_bh(hlist_next_rcu(\t\\\n\t\t\t&(pos)->member)), typeof(*(pos)), member))\n\n \n#define hlist_for_each_entry_from_rcu(pos, member)\t\t\t\\\n\tfor (; pos;\t\t\t\t\t\t\t\\\n\t     pos = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(\t\\\n\t\t\t&(pos)->member)), typeof(*(pos)), member))\n\n#endif\t \n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}