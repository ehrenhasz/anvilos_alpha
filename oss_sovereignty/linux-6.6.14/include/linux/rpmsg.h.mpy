{
  "module_name": "rpmsg.h",
  "hash_id": "2a54a389ceee639fe50885fee7df47fbd8140c9daf61ce5e1343e153d2ef9c62",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/rpmsg.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_RPMSG_H\n#define _LINUX_RPMSG_H\n\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/mod_devicetable.h>\n#include <linux/kref.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/rpmsg/byteorder.h>\n#include <uapi/linux/rpmsg.h>\n\nstruct rpmsg_device;\nstruct rpmsg_endpoint;\nstruct rpmsg_device_ops;\nstruct rpmsg_endpoint_ops;\n\n \nstruct rpmsg_channel_info {\n\tchar name[RPMSG_NAME_SIZE];\n\tu32 src;\n\tu32 dst;\n};\n\n \nstruct rpmsg_device {\n\tstruct device dev;\n\tstruct rpmsg_device_id id;\n\tconst char *driver_override;\n\tu32 src;\n\tu32 dst;\n\tstruct rpmsg_endpoint *ept;\n\tbool announce;\n\tbool little_endian;\n\n\tconst struct rpmsg_device_ops *ops;\n};\n\ntypedef int (*rpmsg_rx_cb_t)(struct rpmsg_device *, void *, int, void *, u32);\ntypedef int (*rpmsg_flowcontrol_cb_t)(struct rpmsg_device *, void *, bool);\n\n \nstruct rpmsg_endpoint {\n\tstruct rpmsg_device *rpdev;\n\tstruct kref refcount;\n\trpmsg_rx_cb_t cb;\n\trpmsg_flowcontrol_cb_t flow_cb;\n\tstruct mutex cb_lock;\n\tu32 addr;\n\tvoid *priv;\n\n\tconst struct rpmsg_endpoint_ops *ops;\n};\n\n \nstruct rpmsg_driver {\n\tstruct device_driver drv;\n\tconst struct rpmsg_device_id *id_table;\n\tint (*probe)(struct rpmsg_device *dev);\n\tvoid (*remove)(struct rpmsg_device *dev);\n\tint (*callback)(struct rpmsg_device *, void *, int, void *, u32);\n\tint (*flowcontrol)(struct rpmsg_device *, void *, bool);\n};\n\nstatic inline u16 rpmsg16_to_cpu(struct rpmsg_device *rpdev, __rpmsg16 val)\n{\n\tif (!rpdev)\n\t\treturn __rpmsg16_to_cpu(rpmsg_is_little_endian(), val);\n\telse\n\t\treturn __rpmsg16_to_cpu(rpdev->little_endian, val);\n}\n\nstatic inline __rpmsg16 cpu_to_rpmsg16(struct rpmsg_device *rpdev, u16 val)\n{\n\tif (!rpdev)\n\t\treturn __cpu_to_rpmsg16(rpmsg_is_little_endian(), val);\n\telse\n\t\treturn __cpu_to_rpmsg16(rpdev->little_endian, val);\n}\n\nstatic inline u32 rpmsg32_to_cpu(struct rpmsg_device *rpdev, __rpmsg32 val)\n{\n\tif (!rpdev)\n\t\treturn __rpmsg32_to_cpu(rpmsg_is_little_endian(), val);\n\telse\n\t\treturn __rpmsg32_to_cpu(rpdev->little_endian, val);\n}\n\nstatic inline __rpmsg32 cpu_to_rpmsg32(struct rpmsg_device *rpdev, u32 val)\n{\n\tif (!rpdev)\n\t\treturn __cpu_to_rpmsg32(rpmsg_is_little_endian(), val);\n\telse\n\t\treturn __cpu_to_rpmsg32(rpdev->little_endian, val);\n}\n\nstatic inline u64 rpmsg64_to_cpu(struct rpmsg_device *rpdev, __rpmsg64 val)\n{\n\tif (!rpdev)\n\t\treturn __rpmsg64_to_cpu(rpmsg_is_little_endian(), val);\n\telse\n\t\treturn __rpmsg64_to_cpu(rpdev->little_endian, val);\n}\n\nstatic inline __rpmsg64 cpu_to_rpmsg64(struct rpmsg_device *rpdev, u64 val)\n{\n\tif (!rpdev)\n\t\treturn __cpu_to_rpmsg64(rpmsg_is_little_endian(), val);\n\telse\n\t\treturn __cpu_to_rpmsg64(rpdev->little_endian, val);\n}\n\n#if IS_ENABLED(CONFIG_RPMSG)\n\nint rpmsg_register_device_override(struct rpmsg_device *rpdev,\n\t\t\t\t   const char *driver_override);\nint rpmsg_register_device(struct rpmsg_device *rpdev);\nint rpmsg_unregister_device(struct device *parent,\n\t\t\t    struct rpmsg_channel_info *chinfo);\nint __register_rpmsg_driver(struct rpmsg_driver *drv, struct module *owner);\nvoid unregister_rpmsg_driver(struct rpmsg_driver *drv);\nvoid rpmsg_destroy_ept(struct rpmsg_endpoint *);\nstruct rpmsg_endpoint *rpmsg_create_ept(struct rpmsg_device *,\n\t\t\t\t\trpmsg_rx_cb_t cb, void *priv,\n\t\t\t\t\tstruct rpmsg_channel_info chinfo);\n\nint rpmsg_send(struct rpmsg_endpoint *ept, void *data, int len);\nint rpmsg_sendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst);\nint rpmsg_send_offchannel(struct rpmsg_endpoint *ept, u32 src, u32 dst,\n\t\t\t  void *data, int len);\n\nint rpmsg_trysend(struct rpmsg_endpoint *ept, void *data, int len);\nint rpmsg_trysendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst);\nint rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src, u32 dst,\n\t\t\t     void *data, int len);\n\n__poll_t rpmsg_poll(struct rpmsg_endpoint *ept, struct file *filp,\n\t\t\tpoll_table *wait);\n\nssize_t rpmsg_get_mtu(struct rpmsg_endpoint *ept);\n\nint rpmsg_set_flow_control(struct rpmsg_endpoint *ept, bool pause, u32 dst);\n\n#else\n\nstatic inline int rpmsg_register_device_override(struct rpmsg_device *rpdev,\n\t\t\t\t\t\t const char *driver_override)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int rpmsg_register_device(struct rpmsg_device *rpdev)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int rpmsg_unregister_device(struct device *parent,\n\t\t\t\t\t  struct rpmsg_channel_info *chinfo)\n{\n\t \n\tWARN_ON(1);\n\n\treturn -ENXIO;\n}\n\nstatic inline int __register_rpmsg_driver(struct rpmsg_driver *drv,\n\t\t\t\t\t  struct module *owner)\n{\n\t \n\tWARN_ON(1);\n\n\treturn -ENXIO;\n}\n\nstatic inline void unregister_rpmsg_driver(struct rpmsg_driver *drv)\n{\n\t \n\tWARN_ON(1);\n}\n\nstatic inline void rpmsg_destroy_ept(struct rpmsg_endpoint *ept)\n{\n\t \n\tWARN_ON(1);\n}\n\nstatic inline struct rpmsg_endpoint *rpmsg_create_ept(struct rpmsg_device *rpdev,\n\t\t\t\t\t\t      rpmsg_rx_cb_t cb,\n\t\t\t\t\t\t      void *priv,\n\t\t\t\t\t\t      struct rpmsg_channel_info chinfo)\n{\n\t \n\tWARN_ON(1);\n\n\treturn NULL;\n}\n\nstatic inline int rpmsg_send(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\t \n\tWARN_ON(1);\n\n\treturn -ENXIO;\n}\n\nstatic inline int rpmsg_sendto(struct rpmsg_endpoint *ept, void *data, int len,\n\t\t\t       u32 dst)\n{\n\t \n\tWARN_ON(1);\n\n\treturn -ENXIO;\n\n}\n\nstatic inline int rpmsg_send_offchannel(struct rpmsg_endpoint *ept, u32 src,\n\t\t\t\t\tu32 dst, void *data, int len)\n{\n\t \n\tWARN_ON(1);\n\n\treturn -ENXIO;\n}\n\nstatic inline int rpmsg_trysend(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\t \n\tWARN_ON(1);\n\n\treturn -ENXIO;\n}\n\nstatic inline int rpmsg_trysendto(struct rpmsg_endpoint *ept, void *data,\n\t\t\t\t  int len, u32 dst)\n{\n\t \n\tWARN_ON(1);\n\n\treturn -ENXIO;\n}\n\nstatic inline int rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src,\n\t\t\t\t\t   u32 dst, void *data, int len)\n{\n\t \n\tWARN_ON(1);\n\n\treturn -ENXIO;\n}\n\nstatic inline __poll_t rpmsg_poll(struct rpmsg_endpoint *ept,\n\t\t\t\t      struct file *filp, poll_table *wait)\n{\n\t \n\tWARN_ON(1);\n\n\treturn 0;\n}\n\nstatic inline ssize_t rpmsg_get_mtu(struct rpmsg_endpoint *ept)\n{\n\t \n\tWARN_ON(1);\n\n\treturn -ENXIO;\n}\n\nstatic inline int rpmsg_set_flow_control(struct rpmsg_endpoint *ept, bool pause, u32 dst)\n{\n\t \n\tWARN_ON(1);\n\n\treturn -ENXIO;\n}\n\n#endif  \n\n \n#define register_rpmsg_driver(drv) \\\n\t__register_rpmsg_driver(drv, THIS_MODULE)\n\n \n#define module_rpmsg_driver(__rpmsg_driver) \\\n\tmodule_driver(__rpmsg_driver, register_rpmsg_driver, \\\n\t\t\tunregister_rpmsg_driver)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}