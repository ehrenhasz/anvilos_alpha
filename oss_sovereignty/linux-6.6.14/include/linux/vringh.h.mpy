{
  "module_name": "vringh.h",
  "hash_id": "5033f93d56c931b42627a0cb2b593617314c121372c28da953c06ba499194db2",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/vringh.h",
  "human_readable_source": " \n \n#ifndef _LINUX_VRINGH_H\n#define _LINUX_VRINGH_H\n#include <uapi/linux/virtio_ring.h>\n#include <linux/virtio_byteorder.h>\n#include <linux/uio.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#if IS_REACHABLE(CONFIG_VHOST_IOTLB)\n#include <linux/dma-direction.h>\n#include <linux/vhost_iotlb.h>\n#endif\n#include <asm/barrier.h>\n\n \nstruct vringh {\n\t \n\tbool little_endian;\n\n\t \n\tbool event_indices;\n\n\t \n\tbool weak_barriers;\n\n\t \n\tbool use_va;\n\n\t \n\tu16 last_avail_idx;\n\n\t \n\tu16 last_used_idx;\n\n\t \n\tu32 completed;\n\n\t \n\tstruct vring vring;\n\n\t \n\tstruct vhost_iotlb *iotlb;\n\n\t \n\tspinlock_t *iotlb_lock;\n\n\t \n\tvoid (*notify)(struct vringh *);\n};\n\nstruct virtio_device;\ntypedef void vrh_callback_t(struct virtio_device *, struct vringh *);\n\n \nstruct vringh_config_ops {\n\tint (*find_vrhs)(struct virtio_device *vdev, unsigned nhvrs,\n\t\t\t struct vringh *vrhs[], vrh_callback_t *callbacks[]);\n\tvoid (*del_vrhs)(struct virtio_device *vdev);\n};\n\n \nstruct vringh_range {\n\tu64 start, end_incl;\n\tu64 offset;\n};\n\n \nstruct vringh_iov {\n\tstruct iovec *iov;\n\tsize_t consumed;  \n\tunsigned i, used, max_num;\n};\n\n \nstruct vringh_kiov {\n\tstruct kvec *iov;\n\tsize_t consumed;  \n\tunsigned i, used, max_num;\n};\n\n \n#define VRINGH_IOV_ALLOCATED 0x8000000\n\n \nint vringh_init_user(struct vringh *vrh, u64 features,\n\t\t     unsigned int num, bool weak_barriers,\n\t\t     vring_desc_t __user *desc,\n\t\t     vring_avail_t __user *avail,\n\t\t     vring_used_t __user *used);\n\nstatic inline void vringh_iov_init(struct vringh_iov *iov,\n\t\t\t\t   struct iovec *iovec, unsigned num)\n{\n\tiov->used = iov->i = 0;\n\tiov->consumed = 0;\n\tiov->max_num = num;\n\tiov->iov = iovec;\n}\n\nstatic inline void vringh_iov_reset(struct vringh_iov *iov)\n{\n\tiov->iov[iov->i].iov_len += iov->consumed;\n\tiov->iov[iov->i].iov_base -= iov->consumed;\n\tiov->consumed = 0;\n\tiov->i = 0;\n}\n\nstatic inline void vringh_iov_cleanup(struct vringh_iov *iov)\n{\n\tif (iov->max_num & VRINGH_IOV_ALLOCATED)\n\t\tkfree(iov->iov);\n\tiov->max_num = iov->used = iov->i = iov->consumed = 0;\n\tiov->iov = NULL;\n}\n\n \nint vringh_getdesc_user(struct vringh *vrh,\n\t\t\tstruct vringh_iov *riov,\n\t\t\tstruct vringh_iov *wiov,\n\t\t\tbool (*getrange)(struct vringh *vrh,\n\t\t\t\t\t u64 addr, struct vringh_range *r),\n\t\t\tu16 *head);\n\n \nssize_t vringh_iov_pull_user(struct vringh_iov *riov, void *dst, size_t len);\n\n \nssize_t vringh_iov_push_user(struct vringh_iov *wiov,\n\t\t\t     const void *src, size_t len);\n\n \nint vringh_complete_user(struct vringh *vrh, u16 head, u32 len);\nint vringh_complete_multi_user(struct vringh *vrh,\n\t\t\t       const struct vring_used_elem used[],\n\t\t\t       unsigned num_used);\n\n \nvoid vringh_abandon_user(struct vringh *vrh, unsigned int num);\n\n \nint vringh_need_notify_user(struct vringh *vrh);\n\nbool vringh_notify_enable_user(struct vringh *vrh);\nvoid vringh_notify_disable_user(struct vringh *vrh);\n\n \nint vringh_init_kern(struct vringh *vrh, u64 features,\n\t\t     unsigned int num, bool weak_barriers,\n\t\t     struct vring_desc *desc,\n\t\t     struct vring_avail *avail,\n\t\t     struct vring_used *used);\n\nstatic inline void vringh_kiov_init(struct vringh_kiov *kiov,\n\t\t\t\t    struct kvec *kvec, unsigned num)\n{\n\tkiov->used = kiov->i = 0;\n\tkiov->consumed = 0;\n\tkiov->max_num = num;\n\tkiov->iov = kvec;\n}\n\nstatic inline void vringh_kiov_reset(struct vringh_kiov *kiov)\n{\n\tkiov->iov[kiov->i].iov_len += kiov->consumed;\n\tkiov->iov[kiov->i].iov_base -= kiov->consumed;\n\tkiov->consumed = 0;\n\tkiov->i = 0;\n}\n\nstatic inline void vringh_kiov_cleanup(struct vringh_kiov *kiov)\n{\n\tif (kiov->max_num & VRINGH_IOV_ALLOCATED)\n\t\tkfree(kiov->iov);\n\tkiov->max_num = kiov->used = kiov->i = kiov->consumed = 0;\n\tkiov->iov = NULL;\n}\n\nstatic inline size_t vringh_kiov_length(struct vringh_kiov *kiov)\n{\n\tsize_t len = 0;\n\tint i;\n\n\tfor (i = kiov->i; i < kiov->used; i++)\n\t\tlen += kiov->iov[i].iov_len;\n\n\treturn len;\n}\n\nvoid vringh_kiov_advance(struct vringh_kiov *kiov, size_t len);\n\nint vringh_getdesc_kern(struct vringh *vrh,\n\t\t\tstruct vringh_kiov *riov,\n\t\t\tstruct vringh_kiov *wiov,\n\t\t\tu16 *head,\n\t\t\tgfp_t gfp);\n\nssize_t vringh_iov_pull_kern(struct vringh_kiov *riov, void *dst, size_t len);\nssize_t vringh_iov_push_kern(struct vringh_kiov *wiov,\n\t\t\t     const void *src, size_t len);\nvoid vringh_abandon_kern(struct vringh *vrh, unsigned int num);\nint vringh_complete_kern(struct vringh *vrh, u16 head, u32 len);\n\nbool vringh_notify_enable_kern(struct vringh *vrh);\nvoid vringh_notify_disable_kern(struct vringh *vrh);\n\nint vringh_need_notify_kern(struct vringh *vrh);\n\n \nstatic inline void vringh_notify(struct vringh *vrh)\n{\n\tif (vrh->notify)\n\t\tvrh->notify(vrh);\n}\n\nstatic inline bool vringh_is_little_endian(const struct vringh *vrh)\n{\n\treturn vrh->little_endian ||\n\t\tvirtio_legacy_is_little_endian();\n}\n\nstatic inline u16 vringh16_to_cpu(const struct vringh *vrh, __virtio16 val)\n{\n\treturn __virtio16_to_cpu(vringh_is_little_endian(vrh), val);\n}\n\nstatic inline __virtio16 cpu_to_vringh16(const struct vringh *vrh, u16 val)\n{\n\treturn __cpu_to_virtio16(vringh_is_little_endian(vrh), val);\n}\n\nstatic inline u32 vringh32_to_cpu(const struct vringh *vrh, __virtio32 val)\n{\n\treturn __virtio32_to_cpu(vringh_is_little_endian(vrh), val);\n}\n\nstatic inline __virtio32 cpu_to_vringh32(const struct vringh *vrh, u32 val)\n{\n\treturn __cpu_to_virtio32(vringh_is_little_endian(vrh), val);\n}\n\nstatic inline u64 vringh64_to_cpu(const struct vringh *vrh, __virtio64 val)\n{\n\treturn __virtio64_to_cpu(vringh_is_little_endian(vrh), val);\n}\n\nstatic inline __virtio64 cpu_to_vringh64(const struct vringh *vrh, u64 val)\n{\n\treturn __cpu_to_virtio64(vringh_is_little_endian(vrh), val);\n}\n\n#if IS_REACHABLE(CONFIG_VHOST_IOTLB)\n\nvoid vringh_set_iotlb(struct vringh *vrh, struct vhost_iotlb *iotlb,\n\t\t      spinlock_t *iotlb_lock);\n\nint vringh_init_iotlb(struct vringh *vrh, u64 features,\n\t\t      unsigned int num, bool weak_barriers,\n\t\t      struct vring_desc *desc,\n\t\t      struct vring_avail *avail,\n\t\t      struct vring_used *used);\n\nint vringh_init_iotlb_va(struct vringh *vrh, u64 features,\n\t\t\t unsigned int num, bool weak_barriers,\n\t\t\t struct vring_desc *desc,\n\t\t\t struct vring_avail *avail,\n\t\t\t struct vring_used *used);\n\nint vringh_getdesc_iotlb(struct vringh *vrh,\n\t\t\t struct vringh_kiov *riov,\n\t\t\t struct vringh_kiov *wiov,\n\t\t\t u16 *head,\n\t\t\t gfp_t gfp);\n\nssize_t vringh_iov_pull_iotlb(struct vringh *vrh,\n\t\t\t      struct vringh_kiov *riov,\n\t\t\t      void *dst, size_t len);\nssize_t vringh_iov_push_iotlb(struct vringh *vrh,\n\t\t\t      struct vringh_kiov *wiov,\n\t\t\t      const void *src, size_t len);\n\nvoid vringh_abandon_iotlb(struct vringh *vrh, unsigned int num);\n\nint vringh_complete_iotlb(struct vringh *vrh, u16 head, u32 len);\n\nbool vringh_notify_enable_iotlb(struct vringh *vrh);\nvoid vringh_notify_disable_iotlb(struct vringh *vrh);\n\nint vringh_need_notify_iotlb(struct vringh *vrh);\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}