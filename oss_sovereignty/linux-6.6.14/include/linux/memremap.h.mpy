{
  "module_name": "memremap.h",
  "hash_id": "0e1c0f17f165055d88ada96229f9664e51f1ca0b4a9932497519596e981ea4c9",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/memremap.h",
  "human_readable_source": " \n#ifndef _LINUX_MEMREMAP_H_\n#define _LINUX_MEMREMAP_H_\n\n#include <linux/mmzone.h>\n#include <linux/range.h>\n#include <linux/ioport.h>\n#include <linux/percpu-refcount.h>\n\nstruct resource;\nstruct device;\n\n \nstruct vmem_altmap {\n\tunsigned long base_pfn;\n\tconst unsigned long end_pfn;\n\tconst unsigned long reserve;\n\tunsigned long free;\n\tunsigned long align;\n\tunsigned long alloc;\n};\n\n \nenum memory_type {\n\t \n\tMEMORY_DEVICE_PRIVATE = 1,\n\tMEMORY_DEVICE_COHERENT,\n\tMEMORY_DEVICE_FS_DAX,\n\tMEMORY_DEVICE_GENERIC,\n\tMEMORY_DEVICE_PCI_P2PDMA,\n};\n\nstruct dev_pagemap_ops {\n\t \n\tvoid (*page_free)(struct page *page);\n\n\t \n\tvm_fault_t (*migrate_to_ram)(struct vm_fault *vmf);\n\n\t \n\tint (*memory_failure)(struct dev_pagemap *pgmap, unsigned long pfn,\n\t\t\t      unsigned long nr_pages, int mf_flags);\n};\n\n#define PGMAP_ALTMAP_VALID\t(1 << 0)\n\n \nstruct dev_pagemap {\n\tstruct vmem_altmap altmap;\n\tstruct percpu_ref ref;\n\tstruct completion done;\n\tenum memory_type type;\n\tunsigned int flags;\n\tunsigned long vmemmap_shift;\n\tconst struct dev_pagemap_ops *ops;\n\tvoid *owner;\n\tint nr_range;\n\tunion {\n\t\tstruct range range;\n\t\tDECLARE_FLEX_ARRAY(struct range, ranges);\n\t};\n};\n\nstatic inline bool pgmap_has_memory_failure(struct dev_pagemap *pgmap)\n{\n\treturn pgmap->ops && pgmap->ops->memory_failure;\n}\n\nstatic inline struct vmem_altmap *pgmap_altmap(struct dev_pagemap *pgmap)\n{\n\tif (pgmap->flags & PGMAP_ALTMAP_VALID)\n\t\treturn &pgmap->altmap;\n\treturn NULL;\n}\n\nstatic inline unsigned long pgmap_vmemmap_nr(struct dev_pagemap *pgmap)\n{\n\treturn 1 << pgmap->vmemmap_shift;\n}\n\nstatic inline bool is_device_private_page(const struct page *page)\n{\n\treturn IS_ENABLED(CONFIG_DEVICE_PRIVATE) &&\n\t\tis_zone_device_page(page) &&\n\t\tpage->pgmap->type == MEMORY_DEVICE_PRIVATE;\n}\n\nstatic inline bool folio_is_device_private(const struct folio *folio)\n{\n\treturn is_device_private_page(&folio->page);\n}\n\nstatic inline bool is_pci_p2pdma_page(const struct page *page)\n{\n\treturn IS_ENABLED(CONFIG_PCI_P2PDMA) &&\n\t\tis_zone_device_page(page) &&\n\t\tpage->pgmap->type == MEMORY_DEVICE_PCI_P2PDMA;\n}\n\nstatic inline bool is_device_coherent_page(const struct page *page)\n{\n\treturn is_zone_device_page(page) &&\n\t\tpage->pgmap->type == MEMORY_DEVICE_COHERENT;\n}\n\nstatic inline bool folio_is_device_coherent(const struct folio *folio)\n{\n\treturn is_device_coherent_page(&folio->page);\n}\n\n#ifdef CONFIG_ZONE_DEVICE\nvoid zone_device_page_init(struct page *page);\nvoid *memremap_pages(struct dev_pagemap *pgmap, int nid);\nvoid memunmap_pages(struct dev_pagemap *pgmap);\nvoid *devm_memremap_pages(struct device *dev, struct dev_pagemap *pgmap);\nvoid devm_memunmap_pages(struct device *dev, struct dev_pagemap *pgmap);\nstruct dev_pagemap *get_dev_pagemap(unsigned long pfn,\n\t\tstruct dev_pagemap *pgmap);\nbool pgmap_pfn_valid(struct dev_pagemap *pgmap, unsigned long pfn);\n\nunsigned long vmem_altmap_offset(struct vmem_altmap *altmap);\nvoid vmem_altmap_free(struct vmem_altmap *altmap, unsigned long nr_pfns);\nunsigned long memremap_compat_align(void);\n#else\nstatic inline void *devm_memremap_pages(struct device *dev,\n\t\tstruct dev_pagemap *pgmap)\n{\n\t \n\tWARN_ON_ONCE(1);\n\treturn ERR_PTR(-ENXIO);\n}\n\nstatic inline void devm_memunmap_pages(struct device *dev,\n\t\tstruct dev_pagemap *pgmap)\n{\n}\n\nstatic inline struct dev_pagemap *get_dev_pagemap(unsigned long pfn,\n\t\tstruct dev_pagemap *pgmap)\n{\n\treturn NULL;\n}\n\nstatic inline bool pgmap_pfn_valid(struct dev_pagemap *pgmap, unsigned long pfn)\n{\n\treturn false;\n}\n\nstatic inline unsigned long vmem_altmap_offset(struct vmem_altmap *altmap)\n{\n\treturn 0;\n}\n\nstatic inline void vmem_altmap_free(struct vmem_altmap *altmap,\n\t\tunsigned long nr_pfns)\n{\n}\n\n \nstatic inline unsigned long memremap_compat_align(void)\n{\n\treturn PAGE_SIZE;\n}\n#endif  \n\nstatic inline void put_dev_pagemap(struct dev_pagemap *pgmap)\n{\n\tif (pgmap)\n\t\tpercpu_ref_put(&pgmap->ref);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}