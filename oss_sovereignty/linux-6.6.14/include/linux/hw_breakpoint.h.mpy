{
  "module_name": "hw_breakpoint.h",
  "hash_id": "8de66a2a82e9fa33f4591cc765527dd0302830a14ecd98182befabd284f1dde6",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/hw_breakpoint.h",
  "human_readable_source": " \n#ifndef _LINUX_HW_BREAKPOINT_H\n#define _LINUX_HW_BREAKPOINT_H\n\n#include <linux/perf_event.h>\n#include <uapi/linux/hw_breakpoint.h>\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\nenum bp_type_idx {\n\tTYPE_INST\t= 0,\n#if defined(CONFIG_HAVE_MIXED_BREAKPOINTS_REGS)\n\tTYPE_DATA\t= 0,\n#else\n\tTYPE_DATA\t= 1,\n#endif\n\tTYPE_MAX\n};\n\nextern int __init init_hw_breakpoint(void);\n\nstatic inline void hw_breakpoint_init(struct perf_event_attr *attr)\n{\n\tmemset(attr, 0, sizeof(*attr));\n\n\tattr->type = PERF_TYPE_BREAKPOINT;\n\tattr->size = sizeof(*attr);\n\t \n\tattr->pinned = 1;\n\tattr->sample_period = 1;\n}\n\nstatic inline void ptrace_breakpoint_init(struct perf_event_attr *attr)\n{\n\thw_breakpoint_init(attr);\n\tattr->exclude_kernel = 1;\n}\n\nstatic inline unsigned long hw_breakpoint_addr(struct perf_event *bp)\n{\n\treturn bp->attr.bp_addr;\n}\n\nstatic inline int hw_breakpoint_type(struct perf_event *bp)\n{\n\treturn bp->attr.bp_type;\n}\n\nstatic inline unsigned long hw_breakpoint_len(struct perf_event *bp)\n{\n\treturn bp->attr.bp_len;\n}\n\nextern struct perf_event *\nregister_user_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context,\n\t\t\t    struct task_struct *tsk);\n\n \nextern int\nmodify_user_hw_breakpoint(struct perf_event *bp, struct perf_event_attr *attr);\nextern int\nmodify_user_hw_breakpoint_check(struct perf_event *bp, struct perf_event_attr *attr,\n\t\t\t\tbool check);\n\n \nextern struct perf_event *\nregister_wide_hw_breakpoint_cpu(struct perf_event_attr *attr,\n\t\t\t\tperf_overflow_handler_t\ttriggered,\n\t\t\t\tvoid *context,\n\t\t\t\tint cpu);\n\nextern struct perf_event * __percpu *\nregister_wide_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context);\n\nextern int register_perf_hw_breakpoint(struct perf_event *bp);\nextern void unregister_hw_breakpoint(struct perf_event *bp);\nextern void unregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events);\nextern bool hw_breakpoint_is_used(void);\n\nextern int dbg_reserve_bp_slot(struct perf_event *bp);\nextern int dbg_release_bp_slot(struct perf_event *bp);\nextern int reserve_bp_slot(struct perf_event *bp);\nextern void release_bp_slot(struct perf_event *bp);\n\nextern void flush_ptrace_hw_breakpoint(struct task_struct *tsk);\n\nstatic inline struct arch_hw_breakpoint *counter_arch_bp(struct perf_event *bp)\n{\n\treturn &bp->hw.info;\n}\n\n#else  \n\nstatic inline int __init init_hw_breakpoint(void) { return 0; }\n\nstatic inline struct perf_event *\nregister_user_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context,\n\t\t\t    struct task_struct *tsk)\t{ return NULL; }\nstatic inline int\nmodify_user_hw_breakpoint(struct perf_event *bp,\n\t\t\t  struct perf_event_attr *attr)\t{ return -ENOSYS; }\nstatic inline int\nmodify_user_hw_breakpoint_check(struct perf_event *bp, struct perf_event_attr *attr,\n\t\t\t\tbool check)\t{ return -ENOSYS; }\n\nstatic inline struct perf_event *\nregister_wide_hw_breakpoint_cpu(struct perf_event_attr *attr,\n\t\t\t\tperf_overflow_handler_t\t triggered,\n\t\t\t\tvoid *context,\n\t\t\t\tint cpu)\t\t{ return NULL; }\nstatic inline struct perf_event * __percpu *\nregister_wide_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context)\t\t{ return NULL; }\nstatic inline int\nregister_perf_hw_breakpoint(struct perf_event *bp)\t{ return -ENOSYS; }\nstatic inline void unregister_hw_breakpoint(struct perf_event *bp)\t{ }\nstatic inline void\nunregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events)\t{ }\nstatic inline bool hw_breakpoint_is_used(void)\t\t{ return false; }\n\nstatic inline int\nreserve_bp_slot(struct perf_event *bp)\t\t\t{return -ENOSYS; }\nstatic inline void release_bp_slot(struct perf_event *bp) \t\t{ }\n\nstatic inline void flush_ptrace_hw_breakpoint(struct task_struct *tsk)\t{ }\n\nstatic inline struct arch_hw_breakpoint *counter_arch_bp(struct perf_event *bp)\n{\n\treturn NULL;\n}\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}