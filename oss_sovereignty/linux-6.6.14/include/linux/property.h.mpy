{
  "module_name": "property.h",
  "hash_id": "7041984d59a90f4ef367bab3e18b54ed09899748d8a6d368bb356a747ec17741",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/property.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_PROPERTY_H_\n#define _LINUX_PROPERTY_H_\n\n#include <linux/bits.h>\n#include <linux/fwnode.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstruct device;\n\nenum dev_prop_type {\n\tDEV_PROP_U8,\n\tDEV_PROP_U16,\n\tDEV_PROP_U32,\n\tDEV_PROP_U64,\n\tDEV_PROP_STRING,\n\tDEV_PROP_REF,\n};\n\nenum dev_dma_attr {\n\tDEV_DMA_NOT_SUPPORTED,\n\tDEV_DMA_NON_COHERENT,\n\tDEV_DMA_COHERENT,\n};\n\nconst struct fwnode_handle *__dev_fwnode_const(const struct device *dev);\nstruct fwnode_handle *__dev_fwnode(struct device *dev);\n#define dev_fwnode(dev)\t\t\t\t\t\t\t\\\n\t_Generic((dev),\t\t\t\t\t\t\t\\\n\t\t const struct device *: __dev_fwnode_const,\t\\\n\t\t struct device *: __dev_fwnode)(dev)\n\nbool device_property_present(const struct device *dev, const char *propname);\nint device_property_read_u8_array(const struct device *dev, const char *propname,\n\t\t\t\t  u8 *val, size_t nval);\nint device_property_read_u16_array(const struct device *dev, const char *propname,\n\t\t\t\t   u16 *val, size_t nval);\nint device_property_read_u32_array(const struct device *dev, const char *propname,\n\t\t\t\t   u32 *val, size_t nval);\nint device_property_read_u64_array(const struct device *dev, const char *propname,\n\t\t\t\t   u64 *val, size_t nval);\nint device_property_read_string_array(const struct device *dev, const char *propname,\n\t\t\t\t      const char **val, size_t nval);\nint device_property_read_string(const struct device *dev, const char *propname,\n\t\t\t\tconst char **val);\nint device_property_match_string(const struct device *dev,\n\t\t\t\t const char *propname, const char *string);\n\nbool fwnode_property_present(const struct fwnode_handle *fwnode,\n\t\t\t     const char *propname);\nint fwnode_property_read_u8_array(const struct fwnode_handle *fwnode,\n\t\t\t\t  const char *propname, u8 *val,\n\t\t\t\t  size_t nval);\nint fwnode_property_read_u16_array(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *propname, u16 *val,\n\t\t\t\t   size_t nval);\nint fwnode_property_read_u32_array(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *propname, u32 *val,\n\t\t\t\t   size_t nval);\nint fwnode_property_read_u64_array(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *propname, u64 *val,\n\t\t\t\t   size_t nval);\nint fwnode_property_read_string_array(const struct fwnode_handle *fwnode,\n\t\t\t\t      const char *propname, const char **val,\n\t\t\t\t      size_t nval);\nint fwnode_property_read_string(const struct fwnode_handle *fwnode,\n\t\t\t\tconst char *propname, const char **val);\nint fwnode_property_match_string(const struct fwnode_handle *fwnode,\n\t\t\t\t const char *propname, const char *string);\n\nbool fwnode_device_is_available(const struct fwnode_handle *fwnode);\n\nstatic inline\nbool fwnode_device_is_compatible(const struct fwnode_handle *fwnode, const char *compat)\n{\n\treturn fwnode_property_match_string(fwnode, \"compatible\", compat) >= 0;\n}\n\n \nstatic inline bool device_is_compatible(const struct device *dev, const char *compat)\n{\n\treturn fwnode_device_is_compatible(dev_fwnode(dev), compat);\n}\n\nint fwnode_property_get_reference_args(const struct fwnode_handle *fwnode,\n\t\t\t\t       const char *prop, const char *nargs_prop,\n\t\t\t\t       unsigned int nargs, unsigned int index,\n\t\t\t\t       struct fwnode_reference_args *args);\n\nstruct fwnode_handle *fwnode_find_reference(const struct fwnode_handle *fwnode,\n\t\t\t\t\t    const char *name,\n\t\t\t\t\t    unsigned int index);\n\nconst char *fwnode_get_name(const struct fwnode_handle *fwnode);\nconst char *fwnode_get_name_prefix(const struct fwnode_handle *fwnode);\n\nstruct fwnode_handle *fwnode_get_parent(const struct fwnode_handle *fwnode);\nstruct fwnode_handle *fwnode_get_next_parent(struct fwnode_handle *fwnode);\n\n#define fwnode_for_each_parent_node(fwnode, parent)\t\t\\\n\tfor (parent = fwnode_get_parent(fwnode); parent;\t\\\n\t     parent = fwnode_get_next_parent(parent))\n\nstruct device *fwnode_get_next_parent_dev(const struct fwnode_handle *fwnode);\nunsigned int fwnode_count_parents(const struct fwnode_handle *fwn);\nstruct fwnode_handle *fwnode_get_nth_parent(struct fwnode_handle *fwn,\n\t\t\t\t\t    unsigned int depth);\nbool fwnode_is_ancestor_of(const struct fwnode_handle *ancestor, const struct fwnode_handle *child);\nstruct fwnode_handle *fwnode_get_next_child_node(\n\tconst struct fwnode_handle *fwnode, struct fwnode_handle *child);\nstruct fwnode_handle *fwnode_get_next_available_child_node(\n\tconst struct fwnode_handle *fwnode, struct fwnode_handle *child);\n\n#define fwnode_for_each_child_node(fwnode, child)\t\t\t\\\n\tfor (child = fwnode_get_next_child_node(fwnode, NULL); child;\t\\\n\t     child = fwnode_get_next_child_node(fwnode, child))\n\n#define fwnode_for_each_available_child_node(fwnode, child)\t\t       \\\n\tfor (child = fwnode_get_next_available_child_node(fwnode, NULL); child;\\\n\t     child = fwnode_get_next_available_child_node(fwnode, child))\n\nstruct fwnode_handle *device_get_next_child_node(const struct device *dev,\n\t\t\t\t\t\t struct fwnode_handle *child);\n\n#define device_for_each_child_node(dev, child)\t\t\t\t\\\n\tfor (child = device_get_next_child_node(dev, NULL); child;\t\\\n\t     child = device_get_next_child_node(dev, child))\n\nstruct fwnode_handle *fwnode_get_named_child_node(const struct fwnode_handle *fwnode,\n\t\t\t\t\t\t  const char *childname);\nstruct fwnode_handle *device_get_named_child_node(const struct device *dev,\n\t\t\t\t\t\t  const char *childname);\n\nstruct fwnode_handle *fwnode_handle_get(struct fwnode_handle *fwnode);\nvoid fwnode_handle_put(struct fwnode_handle *fwnode);\n\nint fwnode_irq_get(const struct fwnode_handle *fwnode, unsigned int index);\nint fwnode_irq_get_byname(const struct fwnode_handle *fwnode, const char *name);\n\nunsigned int device_get_child_node_count(const struct device *dev);\n\nstatic inline bool device_property_read_bool(const struct device *dev,\n\t\t\t\t\t     const char *propname)\n{\n\treturn device_property_present(dev, propname);\n}\n\nstatic inline int device_property_read_u8(const struct device *dev,\n\t\t\t\t\t  const char *propname, u8 *val)\n{\n\treturn device_property_read_u8_array(dev, propname, val, 1);\n}\n\nstatic inline int device_property_read_u16(const struct device *dev,\n\t\t\t\t\t   const char *propname, u16 *val)\n{\n\treturn device_property_read_u16_array(dev, propname, val, 1);\n}\n\nstatic inline int device_property_read_u32(const struct device *dev,\n\t\t\t\t\t   const char *propname, u32 *val)\n{\n\treturn device_property_read_u32_array(dev, propname, val, 1);\n}\n\nstatic inline int device_property_read_u64(const struct device *dev,\n\t\t\t\t\t   const char *propname, u64 *val)\n{\n\treturn device_property_read_u64_array(dev, propname, val, 1);\n}\n\nstatic inline int device_property_count_u8(const struct device *dev, const char *propname)\n{\n\treturn device_property_read_u8_array(dev, propname, NULL, 0);\n}\n\nstatic inline int device_property_count_u16(const struct device *dev, const char *propname)\n{\n\treturn device_property_read_u16_array(dev, propname, NULL, 0);\n}\n\nstatic inline int device_property_count_u32(const struct device *dev, const char *propname)\n{\n\treturn device_property_read_u32_array(dev, propname, NULL, 0);\n}\n\nstatic inline int device_property_count_u64(const struct device *dev, const char *propname)\n{\n\treturn device_property_read_u64_array(dev, propname, NULL, 0);\n}\n\nstatic inline int device_property_string_array_count(const struct device *dev,\n\t\t\t\t\t\t     const char *propname)\n{\n\treturn device_property_read_string_array(dev, propname, NULL, 0);\n}\n\nstatic inline bool fwnode_property_read_bool(const struct fwnode_handle *fwnode,\n\t\t\t\t\t     const char *propname)\n{\n\treturn fwnode_property_present(fwnode, propname);\n}\n\nstatic inline int fwnode_property_read_u8(const struct fwnode_handle *fwnode,\n\t\t\t\t\t  const char *propname, u8 *val)\n{\n\treturn fwnode_property_read_u8_array(fwnode, propname, val, 1);\n}\n\nstatic inline int fwnode_property_read_u16(const struct fwnode_handle *fwnode,\n\t\t\t\t\t   const char *propname, u16 *val)\n{\n\treturn fwnode_property_read_u16_array(fwnode, propname, val, 1);\n}\n\nstatic inline int fwnode_property_read_u32(const struct fwnode_handle *fwnode,\n\t\t\t\t\t   const char *propname, u32 *val)\n{\n\treturn fwnode_property_read_u32_array(fwnode, propname, val, 1);\n}\n\nstatic inline int fwnode_property_read_u64(const struct fwnode_handle *fwnode,\n\t\t\t\t\t   const char *propname, u64 *val)\n{\n\treturn fwnode_property_read_u64_array(fwnode, propname, val, 1);\n}\n\nstatic inline int fwnode_property_count_u8(const struct fwnode_handle *fwnode,\n\t\t\t\t\t   const char *propname)\n{\n\treturn fwnode_property_read_u8_array(fwnode, propname, NULL, 0);\n}\n\nstatic inline int fwnode_property_count_u16(const struct fwnode_handle *fwnode,\n\t\t\t\t\t    const char *propname)\n{\n\treturn fwnode_property_read_u16_array(fwnode, propname, NULL, 0);\n}\n\nstatic inline int fwnode_property_count_u32(const struct fwnode_handle *fwnode,\n\t\t\t\t\t    const char *propname)\n{\n\treturn fwnode_property_read_u32_array(fwnode, propname, NULL, 0);\n}\n\nstatic inline int fwnode_property_count_u64(const struct fwnode_handle *fwnode,\n\t\t\t\t\t    const char *propname)\n{\n\treturn fwnode_property_read_u64_array(fwnode, propname, NULL, 0);\n}\n\nstatic inline int\nfwnode_property_string_array_count(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *propname)\n{\n\treturn fwnode_property_read_string_array(fwnode, propname, NULL, 0);\n}\n\nstruct software_node;\n\n \nstruct software_node_ref_args {\n\tconst struct software_node *node;\n\tunsigned int nargs;\n\tu64 args[NR_FWNODE_REFERENCE_ARGS];\n};\n\n#define SOFTWARE_NODE_REFERENCE(_ref_, ...)\t\t\t\\\n(const struct software_node_ref_args) {\t\t\t\t\\\n\t.node = _ref_,\t\t\t\t\t\t\\\n\t.nargs = ARRAY_SIZE(((u64[]){ 0, ##__VA_ARGS__ })) - 1,\t\\\n\t.args = { __VA_ARGS__ },\t\t\t\t\\\n}\n\n \nstruct property_entry {\n\tconst char *name;\n\tsize_t length;\n\tbool is_inline;\n\tenum dev_prop_type type;\n\tunion {\n\t\tconst void *pointer;\n\t\tunion {\n\t\t\tu8 u8_data[sizeof(u64) / sizeof(u8)];\n\t\t\tu16 u16_data[sizeof(u64) / sizeof(u16)];\n\t\t\tu32 u32_data[sizeof(u64) / sizeof(u32)];\n\t\t\tu64 u64_data[sizeof(u64) / sizeof(u64)];\n\t\t\tconst char *str[sizeof(u64) / sizeof(char *)];\n\t\t} value;\n\t};\n};\n\n \n#define __PROPERTY_ENTRY_ARRAY_LEN(_name_, _elem_, _Type_, _val_, _len_)\t\t\\\n(struct property_entry) {\t\t\t\t\t\t\t\t\\\n\t.name = _name_,\t\t\t\t\t\t\t\t\t\\\n\t.length = (_len_) * sizeof_field(struct property_entry, value._elem_[0]),\t\\\n\t.type = DEV_PROP_##_Type_,\t\t\t\t\t\t\t\\\n\t{ .pointer = _val_ },\t\t\t\t\t\t\t\t\\\n}\n\n#define PROPERTY_ENTRY_U8_ARRAY_LEN(_name_, _val_, _len_)\t\t\\\n\t__PROPERTY_ENTRY_ARRAY_LEN(_name_, u8_data, U8, _val_, _len_)\n#define PROPERTY_ENTRY_U16_ARRAY_LEN(_name_, _val_, _len_)\t\t\\\n\t__PROPERTY_ENTRY_ARRAY_LEN(_name_, u16_data, U16, _val_, _len_)\n#define PROPERTY_ENTRY_U32_ARRAY_LEN(_name_, _val_, _len_)\t\t\\\n\t__PROPERTY_ENTRY_ARRAY_LEN(_name_, u32_data, U32, _val_, _len_)\n#define PROPERTY_ENTRY_U64_ARRAY_LEN(_name_, _val_, _len_)\t\t\\\n\t__PROPERTY_ENTRY_ARRAY_LEN(_name_, u64_data, U64, _val_, _len_)\n#define PROPERTY_ENTRY_STRING_ARRAY_LEN(_name_, _val_, _len_)\t\t\\\n\t__PROPERTY_ENTRY_ARRAY_LEN(_name_, str, STRING, _val_, _len_)\n\n#define PROPERTY_ENTRY_REF_ARRAY_LEN(_name_, _val_, _len_)\t\t\\\n(struct property_entry) {\t\t\t\t\t\t\\\n\t.name = _name_,\t\t\t\t\t\t\t\\\n\t.length = (_len_) * sizeof(struct software_node_ref_args),\t\\\n\t.type = DEV_PROP_REF,\t\t\t\t\t\t\\\n\t{ .pointer = _val_ },\t\t\t\t\t\t\\\n}\n\n#define PROPERTY_ENTRY_U8_ARRAY(_name_, _val_)\t\t\t\t\\\n\tPROPERTY_ENTRY_U8_ARRAY_LEN(_name_, _val_, ARRAY_SIZE(_val_))\n#define PROPERTY_ENTRY_U16_ARRAY(_name_, _val_)\t\t\t\t\\\n\tPROPERTY_ENTRY_U16_ARRAY_LEN(_name_, _val_, ARRAY_SIZE(_val_))\n#define PROPERTY_ENTRY_U32_ARRAY(_name_, _val_)\t\t\t\t\\\n\tPROPERTY_ENTRY_U32_ARRAY_LEN(_name_, _val_, ARRAY_SIZE(_val_))\n#define PROPERTY_ENTRY_U64_ARRAY(_name_, _val_)\t\t\t\t\\\n\tPROPERTY_ENTRY_U64_ARRAY_LEN(_name_, _val_, ARRAY_SIZE(_val_))\n#define PROPERTY_ENTRY_STRING_ARRAY(_name_, _val_)\t\t\t\\\n\tPROPERTY_ENTRY_STRING_ARRAY_LEN(_name_, _val_, ARRAY_SIZE(_val_))\n#define PROPERTY_ENTRY_REF_ARRAY(_name_, _val_)\t\t\t\t\\\n\tPROPERTY_ENTRY_REF_ARRAY_LEN(_name_, _val_, ARRAY_SIZE(_val_))\n\n#define __PROPERTY_ENTRY_ELEMENT(_name_, _elem_, _Type_, _val_)\t\t\\\n(struct property_entry) {\t\t\t\t\t\t\\\n\t.name = _name_,\t\t\t\t\t\t\t\\\n\t.length = sizeof_field(struct property_entry, value._elem_[0]),\t\\\n\t.is_inline = true,\t\t\t\t\t\t\\\n\t.type = DEV_PROP_##_Type_,\t\t\t\t\t\\\n\t{ .value = { ._elem_[0] = _val_ } },\t\t\t\t\\\n}\n\n#define PROPERTY_ENTRY_U8(_name_, _val_)\t\t\t\t\\\n\t__PROPERTY_ENTRY_ELEMENT(_name_, u8_data, U8, _val_)\n#define PROPERTY_ENTRY_U16(_name_, _val_)\t\t\t\t\\\n\t__PROPERTY_ENTRY_ELEMENT(_name_, u16_data, U16, _val_)\n#define PROPERTY_ENTRY_U32(_name_, _val_)\t\t\t\t\\\n\t__PROPERTY_ENTRY_ELEMENT(_name_, u32_data, U32, _val_)\n#define PROPERTY_ENTRY_U64(_name_, _val_)\t\t\t\t\\\n\t__PROPERTY_ENTRY_ELEMENT(_name_, u64_data, U64, _val_)\n#define PROPERTY_ENTRY_STRING(_name_, _val_)\t\t\t\t\\\n\t__PROPERTY_ENTRY_ELEMENT(_name_, str, STRING, _val_)\n\n#define PROPERTY_ENTRY_REF(_name_, _ref_, ...)\t\t\t\t\\\n(struct property_entry) {\t\t\t\t\t\t\\\n\t.name = _name_,\t\t\t\t\t\t\t\\\n\t.length = sizeof(struct software_node_ref_args),\t\t\\\n\t.type = DEV_PROP_REF,\t\t\t\t\t\t\\\n\t{ .pointer = &SOFTWARE_NODE_REFERENCE(_ref_, ##__VA_ARGS__), },\t\\\n}\n\n#define PROPERTY_ENTRY_BOOL(_name_)\t\t\\\n(struct property_entry) {\t\t\t\\\n\t.name = _name_,\t\t\t\t\\\n\t.is_inline = true,\t\t\t\\\n}\n\nstruct property_entry *\nproperty_entries_dup(const struct property_entry *properties);\nvoid property_entries_free(const struct property_entry *properties);\n\nbool device_dma_supported(const struct device *dev);\nenum dev_dma_attr device_get_dma_attr(const struct device *dev);\n\nconst void *device_get_match_data(const struct device *dev);\n\nint device_get_phy_mode(struct device *dev);\nint fwnode_get_phy_mode(const struct fwnode_handle *fwnode);\n\nvoid __iomem *fwnode_iomap(struct fwnode_handle *fwnode, int index);\n\nstruct fwnode_handle *fwnode_graph_get_next_endpoint(\n\tconst struct fwnode_handle *fwnode, struct fwnode_handle *prev);\nstruct fwnode_handle *\nfwnode_graph_get_port_parent(const struct fwnode_handle *fwnode);\nstruct fwnode_handle *fwnode_graph_get_remote_port_parent(\n\tconst struct fwnode_handle *fwnode);\nstruct fwnode_handle *fwnode_graph_get_remote_port(\n\tconst struct fwnode_handle *fwnode);\nstruct fwnode_handle *fwnode_graph_get_remote_endpoint(\n\tconst struct fwnode_handle *fwnode);\n\nstatic inline bool fwnode_graph_is_endpoint(const struct fwnode_handle *fwnode)\n{\n\treturn fwnode_property_present(fwnode, \"remote-endpoint\");\n}\n\n \n#define FWNODE_GRAPH_ENDPOINT_NEXT\tBIT(0)\n#define FWNODE_GRAPH_DEVICE_DISABLED\tBIT(1)\n\nstruct fwnode_handle *\nfwnode_graph_get_endpoint_by_id(const struct fwnode_handle *fwnode,\n\t\t\t\tu32 port, u32 endpoint, unsigned long flags);\nunsigned int fwnode_graph_get_endpoint_count(const struct fwnode_handle *fwnode,\n\t\t\t\t\t     unsigned long flags);\n\n#define fwnode_graph_for_each_endpoint(fwnode, child)\t\t\t\t\\\n\tfor (child = fwnode_graph_get_next_endpoint(fwnode, NULL); child;\t\\\n\t     child = fwnode_graph_get_next_endpoint(fwnode, child))\n\nint fwnode_graph_parse_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t\tstruct fwnode_endpoint *endpoint);\n\ntypedef void *(*devcon_match_fn_t)(const struct fwnode_handle *fwnode, const char *id,\n\t\t\t\t   void *data);\n\nvoid *fwnode_connection_find_match(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *con_id, void *data,\n\t\t\t\t   devcon_match_fn_t match);\n\nstatic inline void *device_connection_find_match(const struct device *dev,\n\t\t\t\t\t\t const char *con_id, void *data,\n\t\t\t\t\t\t devcon_match_fn_t match)\n{\n\treturn fwnode_connection_find_match(dev_fwnode(dev), con_id, data, match);\n}\n\nint fwnode_connection_find_matches(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *con_id, void *data,\n\t\t\t\t   devcon_match_fn_t match,\n\t\t\t\t   void **matches, unsigned int matches_len);\n\n \n \n\n \nstruct software_node {\n\tconst char *name;\n\tconst struct software_node *parent;\n\tconst struct property_entry *properties;\n};\n\nbool is_software_node(const struct fwnode_handle *fwnode);\nconst struct software_node *\nto_software_node(const struct fwnode_handle *fwnode);\nstruct fwnode_handle *software_node_fwnode(const struct software_node *node);\n\nconst struct software_node *\nsoftware_node_find_by_name(const struct software_node *parent,\n\t\t\t   const char *name);\n\nint software_node_register_node_group(const struct software_node **node_group);\nvoid software_node_unregister_node_group(const struct software_node **node_group);\n\nint software_node_register(const struct software_node *node);\nvoid software_node_unregister(const struct software_node *node);\n\nstruct fwnode_handle *\nfwnode_create_software_node(const struct property_entry *properties,\n\t\t\t    const struct fwnode_handle *parent);\nvoid fwnode_remove_software_node(struct fwnode_handle *fwnode);\n\nint device_add_software_node(struct device *dev, const struct software_node *node);\nvoid device_remove_software_node(struct device *dev);\n\nint device_create_managed_software_node(struct device *dev,\n\t\t\t\t\tconst struct property_entry *properties,\n\t\t\t\t\tconst struct software_node *parent);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}