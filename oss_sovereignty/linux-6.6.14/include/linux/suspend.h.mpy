{
  "module_name": "suspend.h",
  "hash_id": "154212a408dee6324e45e764ba6f91d1fb3a10ef9e58c7faae182cce0bd11a8d",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/suspend.h",
  "human_readable_source": " \n#ifndef _LINUX_SUSPEND_H\n#define _LINUX_SUSPEND_H\n\n#include <linux/swap.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/pm.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <asm/errno.h>\n\n#ifdef CONFIG_VT\nextern void pm_set_vt_switch(int);\n#else\nstatic inline void pm_set_vt_switch(int do_switch)\n{\n}\n#endif\n\n#ifdef CONFIG_VT_CONSOLE_SLEEP\nextern void pm_prepare_console(void);\nextern void pm_restore_console(void);\n#else\nstatic inline void pm_prepare_console(void)\n{\n}\n\nstatic inline void pm_restore_console(void)\n{\n}\n#endif\n\ntypedef int __bitwise suspend_state_t;\n\n#define PM_SUSPEND_ON\t\t((__force suspend_state_t) 0)\n#define PM_SUSPEND_TO_IDLE\t((__force suspend_state_t) 1)\n#define PM_SUSPEND_STANDBY\t((__force suspend_state_t) 2)\n#define PM_SUSPEND_MEM\t\t((__force suspend_state_t) 3)\n#define PM_SUSPEND_MIN\t\tPM_SUSPEND_TO_IDLE\n#define PM_SUSPEND_MAX\t\t((__force suspend_state_t) 4)\n\nenum suspend_stat_step {\n\tSUSPEND_FREEZE = 1,\n\tSUSPEND_PREPARE,\n\tSUSPEND_SUSPEND,\n\tSUSPEND_SUSPEND_LATE,\n\tSUSPEND_SUSPEND_NOIRQ,\n\tSUSPEND_RESUME_NOIRQ,\n\tSUSPEND_RESUME_EARLY,\n\tSUSPEND_RESUME\n};\n\nstruct suspend_stats {\n\tint\tsuccess;\n\tint\tfail;\n\tint\tfailed_freeze;\n\tint\tfailed_prepare;\n\tint\tfailed_suspend;\n\tint\tfailed_suspend_late;\n\tint\tfailed_suspend_noirq;\n\tint\tfailed_resume;\n\tint\tfailed_resume_early;\n\tint\tfailed_resume_noirq;\n#define\tREC_FAILED_NUM\t2\n\tint\tlast_failed_dev;\n\tchar\tfailed_devs[REC_FAILED_NUM][40];\n\tint\tlast_failed_errno;\n\tint\terrno[REC_FAILED_NUM];\n\tint\tlast_failed_step;\n\tu64\tlast_hw_sleep;\n\tu64\ttotal_hw_sleep;\n\tu64\tmax_hw_sleep;\n\tenum suspend_stat_step\tfailed_steps[REC_FAILED_NUM];\n};\n\nextern struct suspend_stats suspend_stats;\n\nstatic inline void dpm_save_failed_dev(const char *name)\n{\n\tstrscpy(suspend_stats.failed_devs[suspend_stats.last_failed_dev],\n\t\tname,\n\t\tsizeof(suspend_stats.failed_devs[0]));\n\tsuspend_stats.last_failed_dev++;\n\tsuspend_stats.last_failed_dev %= REC_FAILED_NUM;\n}\n\nstatic inline void dpm_save_failed_errno(int err)\n{\n\tsuspend_stats.errno[suspend_stats.last_failed_errno] = err;\n\tsuspend_stats.last_failed_errno++;\n\tsuspend_stats.last_failed_errno %= REC_FAILED_NUM;\n}\n\nstatic inline void dpm_save_failed_step(enum suspend_stat_step step)\n{\n\tsuspend_stats.failed_steps[suspend_stats.last_failed_step] = step;\n\tsuspend_stats.last_failed_step++;\n\tsuspend_stats.last_failed_step %= REC_FAILED_NUM;\n}\n\n \nstruct platform_suspend_ops {\n\tint (*valid)(suspend_state_t state);\n\tint (*begin)(suspend_state_t state);\n\tint (*prepare)(void);\n\tint (*prepare_late)(void);\n\tint (*enter)(suspend_state_t state);\n\tvoid (*wake)(void);\n\tvoid (*finish)(void);\n\tbool (*suspend_again)(void);\n\tvoid (*end)(void);\n\tvoid (*recover)(void);\n};\n\nstruct platform_s2idle_ops {\n\tint (*begin)(void);\n\tint (*prepare)(void);\n\tint (*prepare_late)(void);\n\tvoid (*check)(void);\n\tbool (*wake)(void);\n\tvoid (*restore_early)(void);\n\tvoid (*restore)(void);\n\tvoid (*end)(void);\n};\n\n#ifdef CONFIG_SUSPEND\nextern suspend_state_t pm_suspend_target_state;\nextern suspend_state_t mem_sleep_current;\nextern suspend_state_t mem_sleep_default;\n\n \nextern void suspend_set_ops(const struct platform_suspend_ops *ops);\nextern int suspend_valid_only_mem(suspend_state_t state);\n\nextern unsigned int pm_suspend_global_flags;\n\n#define PM_SUSPEND_FLAG_FW_SUSPEND\tBIT(0)\n#define PM_SUSPEND_FLAG_FW_RESUME\tBIT(1)\n#define PM_SUSPEND_FLAG_NO_PLATFORM\tBIT(2)\n\nstatic inline void pm_suspend_clear_flags(void)\n{\n\tpm_suspend_global_flags = 0;\n}\n\nstatic inline void pm_set_suspend_via_firmware(void)\n{\n\tpm_suspend_global_flags |= PM_SUSPEND_FLAG_FW_SUSPEND;\n}\n\nstatic inline void pm_set_resume_via_firmware(void)\n{\n\tpm_suspend_global_flags |= PM_SUSPEND_FLAG_FW_RESUME;\n}\n\nstatic inline void pm_set_suspend_no_platform(void)\n{\n\tpm_suspend_global_flags |= PM_SUSPEND_FLAG_NO_PLATFORM;\n}\n\n \nstatic inline bool pm_suspend_via_firmware(void)\n{\n\treturn !!(pm_suspend_global_flags & PM_SUSPEND_FLAG_FW_SUSPEND);\n}\n\n \nstatic inline bool pm_resume_via_firmware(void)\n{\n\treturn !!(pm_suspend_global_flags & PM_SUSPEND_FLAG_FW_RESUME);\n}\n\n \nstatic inline bool pm_suspend_no_platform(void)\n{\n\treturn !!(pm_suspend_global_flags & PM_SUSPEND_FLAG_NO_PLATFORM);\n}\n\n \nenum s2idle_states {\n\tS2IDLE_STATE_NONE,       \n\tS2IDLE_STATE_ENTER,      \n\tS2IDLE_STATE_WAKE,       \n};\n\nextern enum s2idle_states __read_mostly s2idle_state;\n\nstatic inline bool idle_should_enter_s2idle(void)\n{\n\treturn unlikely(s2idle_state == S2IDLE_STATE_ENTER);\n}\n\nextern bool pm_suspend_default_s2idle(void);\nextern void __init pm_states_init(void);\nextern void s2idle_set_ops(const struct platform_s2idle_ops *ops);\nextern void s2idle_wake(void);\n\n \nextern void arch_suspend_disable_irqs(void);\n\n \nextern void arch_suspend_enable_irqs(void);\n\nextern int pm_suspend(suspend_state_t state);\nextern bool sync_on_suspend_enabled;\n#else  \n#define suspend_valid_only_mem\tNULL\n\n#define pm_suspend_target_state\t(PM_SUSPEND_ON)\n\nstatic inline void pm_suspend_clear_flags(void) {}\nstatic inline void pm_set_suspend_via_firmware(void) {}\nstatic inline void pm_set_resume_via_firmware(void) {}\nstatic inline bool pm_suspend_via_firmware(void) { return false; }\nstatic inline bool pm_resume_via_firmware(void) { return false; }\nstatic inline bool pm_suspend_no_platform(void) { return false; }\nstatic inline bool pm_suspend_default_s2idle(void) { return false; }\n\nstatic inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}\nstatic inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }\nstatic inline bool sync_on_suspend_enabled(void) { return true; }\nstatic inline bool idle_should_enter_s2idle(void) { return false; }\nstatic inline void __init pm_states_init(void) {}\nstatic inline void s2idle_set_ops(const struct platform_s2idle_ops *ops) {}\nstatic inline void s2idle_wake(void) {}\n#endif  \n\n \nstruct pbe {\n\tvoid *address;\t\t \n\tvoid *orig_address;\t \n\tstruct pbe *next;\n};\n\n \nstruct platform_hibernation_ops {\n\tint (*begin)(pm_message_t stage);\n\tvoid (*end)(void);\n\tint (*pre_snapshot)(void);\n\tvoid (*finish)(void);\n\tint (*prepare)(void);\n\tint (*enter)(void);\n\tvoid (*leave)(void);\n\tint (*pre_restore)(void);\n\tvoid (*restore_cleanup)(void);\n\tvoid (*recover)(void);\n};\n\n#ifdef CONFIG_HIBERNATION\n \nextern void register_nosave_region(unsigned long b, unsigned long e);\nextern int swsusp_page_is_forbidden(struct page *);\nextern void swsusp_set_page_free(struct page *);\nextern void swsusp_unset_page_free(struct page *);\nextern unsigned long get_safe_page(gfp_t gfp_mask);\nextern asmlinkage int swsusp_arch_suspend(void);\nextern asmlinkage int swsusp_arch_resume(void);\n\nextern u32 swsusp_hardware_signature;\nextern void hibernation_set_ops(const struct platform_hibernation_ops *ops);\nextern int hibernate(void);\nextern bool system_entering_hibernation(void);\nextern bool hibernation_available(void);\nasmlinkage int swsusp_save(void);\nextern struct pbe *restore_pblist;\nint pfn_is_nosave(unsigned long pfn);\n\nint hibernate_quiet_exec(int (*func)(void *data), void *data);\nint hibernate_resume_nonboot_cpu_disable(void);\nint arch_hibernation_header_save(void *addr, unsigned int max_size);\nint arch_hibernation_header_restore(void *addr);\n\n#else  \nstatic inline void register_nosave_region(unsigned long b, unsigned long e) {}\nstatic inline int swsusp_page_is_forbidden(struct page *p) { return 0; }\nstatic inline void swsusp_set_page_free(struct page *p) {}\nstatic inline void swsusp_unset_page_free(struct page *p) {}\n\nstatic inline void hibernation_set_ops(const struct platform_hibernation_ops *ops) {}\nstatic inline int hibernate(void) { return -ENOSYS; }\nstatic inline bool system_entering_hibernation(void) { return false; }\nstatic inline bool hibernation_available(void) { return false; }\n\nstatic inline int hibernate_quiet_exec(int (*func)(void *data), void *data) {\n\treturn -ENOTSUPP;\n}\n#endif  \n\nint arch_resume_nosmt(void);\n\n#ifdef CONFIG_HIBERNATION_SNAPSHOT_DEV\nint is_hibernate_resume_dev(dev_t dev);\n#else\nstatic inline int is_hibernate_resume_dev(dev_t dev) { return 0; }\n#endif\n\n \n#define PM_HIBERNATION_PREPARE\t0x0001  \n#define PM_POST_HIBERNATION\t0x0002  \n#define PM_SUSPEND_PREPARE\t0x0003  \n#define PM_POST_SUSPEND\t\t0x0004  \n#define PM_RESTORE_PREPARE\t0x0005  \n#define PM_POST_RESTORE\t\t0x0006  \n\nextern struct mutex system_transition_mutex;\n\n#ifdef CONFIG_PM_SLEEP\nvoid save_processor_state(void);\nvoid restore_processor_state(void);\n\n \nextern int register_pm_notifier(struct notifier_block *nb);\nextern int unregister_pm_notifier(struct notifier_block *nb);\nextern void ksys_sync_helper(void);\nextern void pm_report_hw_sleep_time(u64 t);\nextern void pm_report_max_hw_sleep(u64 t);\n\n#define pm_notifier(fn, pri) {\t\t\t\t\\\n\tstatic struct notifier_block fn##_nb =\t\t\t\\\n\t\t{ .notifier_call = fn, .priority = pri };\t\\\n\tregister_pm_notifier(&fn##_nb);\t\t\t\\\n}\n\n \nextern bool events_check_enabled;\n\nstatic inline bool pm_suspended_storage(void)\n{\n\treturn !gfp_has_io_fs(gfp_allowed_mask);\n}\n\nextern bool pm_wakeup_pending(void);\nextern void pm_system_wakeup(void);\nextern void pm_system_cancel_wakeup(void);\nextern void pm_wakeup_clear(unsigned int irq_number);\nextern void pm_system_irq_wakeup(unsigned int irq_number);\nextern unsigned int pm_wakeup_irq(void);\nextern bool pm_get_wakeup_count(unsigned int *count, bool block);\nextern bool pm_save_wakeup_count(unsigned int count);\nextern void pm_wakep_autosleep_enabled(bool set);\nextern void pm_print_active_wakeup_sources(void);\n\nextern unsigned int lock_system_sleep(void);\nextern void unlock_system_sleep(unsigned int);\n\n#else  \n\nstatic inline int register_pm_notifier(struct notifier_block *nb)\n{\n\treturn 0;\n}\n\nstatic inline int unregister_pm_notifier(struct notifier_block *nb)\n{\n\treturn 0;\n}\n\nstatic inline void pm_report_hw_sleep_time(u64 t) {};\nstatic inline void pm_report_max_hw_sleep(u64 t) {};\n\nstatic inline void ksys_sync_helper(void) {}\n\n#define pm_notifier(fn, pri)\tdo { (void)(fn); } while (0)\n\nstatic inline bool pm_suspended_storage(void) { return false; }\nstatic inline bool pm_wakeup_pending(void) { return false; }\nstatic inline void pm_system_wakeup(void) {}\nstatic inline void pm_wakeup_clear(bool reset) {}\nstatic inline void pm_system_irq_wakeup(unsigned int irq_number) {}\n\nstatic inline unsigned int lock_system_sleep(void) { return 0; }\nstatic inline void unlock_system_sleep(unsigned int flags) {}\n\n#endif  \n\n#ifdef CONFIG_PM_SLEEP_DEBUG\nextern bool pm_print_times_enabled;\nextern bool pm_debug_messages_on;\nextern bool pm_debug_messages_should_print(void);\nstatic inline int pm_dyn_debug_messages_on(void)\n{\n#ifdef CONFIG_DYNAMIC_DEBUG\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n#ifndef pr_fmt\n#define pr_fmt(fmt) \"PM: \" fmt\n#endif\n#define __pm_pr_dbg(fmt, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (pm_debug_messages_should_print())\t\t\\\n\t\t\tprintk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__);\t\\\n\t\telse if (pm_dyn_debug_messages_on())\t\t\\\n\t\t\tpr_debug(fmt, ##__VA_ARGS__);\t\\\n\t} while (0)\n#define __pm_deferred_pr_dbg(fmt, ...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (pm_debug_messages_should_print())\t\t\\\n\t\t\tprintk_deferred(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__);\t\\\n\t} while (0)\n#else\n#define pm_print_times_enabled\t(false)\n#define pm_debug_messages_on\t(false)\n\n#include <linux/printk.h>\n\n#define __pm_pr_dbg(fmt, ...) \\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#define __pm_deferred_pr_dbg(fmt, ...) \\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\n \n#define pm_pr_dbg(fmt, ...) \\\n\t__pm_pr_dbg(fmt, ##__VA_ARGS__)\n\n#define pm_deferred_pr_dbg(fmt, ...) \\\n\t__pm_deferred_pr_dbg(fmt, ##__VA_ARGS__)\n\n#ifdef CONFIG_PM_AUTOSLEEP\n\n \nvoid queue_up_suspend_work(void);\n\n#else  \n\nstatic inline void queue_up_suspend_work(void) {}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}