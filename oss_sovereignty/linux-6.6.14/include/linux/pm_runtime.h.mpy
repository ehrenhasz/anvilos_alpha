{
  "module_name": "pm_runtime.h",
  "hash_id": "b255ffa9aff831626f8734d3ff10d686c107df1400433cd33d3dcdc2d7396454",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/pm_runtime.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_PM_RUNTIME_H\n#define _LINUX_PM_RUNTIME_H\n\n#include <linux/device.h>\n#include <linux/notifier.h>\n#include <linux/pm.h>\n\n#include <linux/jiffies.h>\n\n \n#define RPM_ASYNC\t\t0x01\t \n#define RPM_NOWAIT\t\t0x02\t \n#define RPM_GET_PUT\t\t0x04\t \n#define RPM_AUTO\t\t0x08\t \n\n \n#define DEFINE_RUNTIME_DEV_PM_OPS(name, suspend_fn, resume_fn, idle_fn) \\\n\t_DEFINE_DEV_PM_OPS(name, pm_runtime_force_suspend, \\\n\t\t\t   pm_runtime_force_resume, suspend_fn, \\\n\t\t\t   resume_fn, idle_fn)\n\n#define EXPORT_RUNTIME_DEV_PM_OPS(name, suspend_fn, resume_fn, idle_fn) \\\n\tEXPORT_DEV_PM_OPS(name) = { \\\n\t\tRUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \\\n\t}\n#define EXPORT_GPL_RUNTIME_DEV_PM_OPS(name, suspend_fn, resume_fn, idle_fn) \\\n\tEXPORT_GPL_DEV_PM_OPS(name) = { \\\n\t\tRUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \\\n\t}\n#define EXPORT_NS_RUNTIME_DEV_PM_OPS(name, suspend_fn, resume_fn, idle_fn, ns) \\\n\tEXPORT_NS_DEV_PM_OPS(name, ns) = { \\\n\t\tRUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \\\n\t}\n#define EXPORT_NS_GPL_RUNTIME_DEV_PM_OPS(name, suspend_fn, resume_fn, idle_fn, ns) \\\n\tEXPORT_NS_GPL_DEV_PM_OPS(name, ns) = { \\\n\t\tRUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \\\n\t}\n\n#ifdef CONFIG_PM\nextern struct workqueue_struct *pm_wq;\n\nstatic inline bool queue_pm_work(struct work_struct *work)\n{\n\treturn queue_work(pm_wq, work);\n}\n\nextern int pm_generic_runtime_suspend(struct device *dev);\nextern int pm_generic_runtime_resume(struct device *dev);\nextern int pm_runtime_force_suspend(struct device *dev);\nextern int pm_runtime_force_resume(struct device *dev);\n\nextern int __pm_runtime_idle(struct device *dev, int rpmflags);\nextern int __pm_runtime_suspend(struct device *dev, int rpmflags);\nextern int __pm_runtime_resume(struct device *dev, int rpmflags);\nextern int pm_runtime_get_if_active(struct device *dev, bool ign_usage_count);\nextern int pm_schedule_suspend(struct device *dev, unsigned int delay);\nextern int __pm_runtime_set_status(struct device *dev, unsigned int status);\nextern int pm_runtime_barrier(struct device *dev);\nextern void pm_runtime_enable(struct device *dev);\nextern void __pm_runtime_disable(struct device *dev, bool check_resume);\nextern void pm_runtime_allow(struct device *dev);\nextern void pm_runtime_forbid(struct device *dev);\nextern void pm_runtime_no_callbacks(struct device *dev);\nextern void pm_runtime_irq_safe(struct device *dev);\nextern void __pm_runtime_use_autosuspend(struct device *dev, bool use);\nextern void pm_runtime_set_autosuspend_delay(struct device *dev, int delay);\nextern u64 pm_runtime_autosuspend_expiration(struct device *dev);\nextern void pm_runtime_set_memalloc_noio(struct device *dev, bool enable);\nextern void pm_runtime_get_suppliers(struct device *dev);\nextern void pm_runtime_put_suppliers(struct device *dev);\nextern void pm_runtime_new_link(struct device *dev);\nextern void pm_runtime_drop_link(struct device_link *link);\nextern void pm_runtime_release_supplier(struct device_link *link);\n\nextern int devm_pm_runtime_enable(struct device *dev);\n\n \nstatic inline int pm_runtime_get_if_in_use(struct device *dev)\n{\n\treturn pm_runtime_get_if_active(dev, false);\n}\n\n \nstatic inline void pm_suspend_ignore_children(struct device *dev, bool enable)\n{\n\tdev->power.ignore_children = enable;\n}\n\n \nstatic inline void pm_runtime_get_noresume(struct device *dev)\n{\n\tatomic_inc(&dev->power.usage_count);\n}\n\n \nstatic inline void pm_runtime_put_noidle(struct device *dev)\n{\n\tatomic_add_unless(&dev->power.usage_count, -1, 0);\n}\n\n \nstatic inline bool pm_runtime_suspended(struct device *dev)\n{\n\treturn dev->power.runtime_status == RPM_SUSPENDED\n\t\t&& !dev->power.disable_depth;\n}\n\n \nstatic inline bool pm_runtime_active(struct device *dev)\n{\n\treturn dev->power.runtime_status == RPM_ACTIVE\n\t\t|| dev->power.disable_depth;\n}\n\n \nstatic inline bool pm_runtime_status_suspended(struct device *dev)\n{\n\treturn dev->power.runtime_status == RPM_SUSPENDED;\n}\n\n \nstatic inline bool pm_runtime_enabled(struct device *dev)\n{\n\treturn !dev->power.disable_depth;\n}\n\n \nstatic inline bool pm_runtime_has_no_callbacks(struct device *dev)\n{\n\treturn dev->power.no_callbacks;\n}\n\n \nstatic inline void pm_runtime_mark_last_busy(struct device *dev)\n{\n\tWRITE_ONCE(dev->power.last_busy, ktime_get_mono_fast_ns());\n}\n\n \nstatic inline bool pm_runtime_is_irq_safe(struct device *dev)\n{\n\treturn dev->power.irq_safe;\n}\n\nextern u64 pm_runtime_suspended_time(struct device *dev);\n\n#else  \n\nstatic inline bool queue_pm_work(struct work_struct *work) { return false; }\n\nstatic inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }\nstatic inline int pm_generic_runtime_resume(struct device *dev) { return 0; }\nstatic inline int pm_runtime_force_suspend(struct device *dev) { return 0; }\nstatic inline int pm_runtime_force_resume(struct device *dev) { return 0; }\n\nstatic inline int __pm_runtime_idle(struct device *dev, int rpmflags)\n{\n\treturn -ENOSYS;\n}\nstatic inline int __pm_runtime_suspend(struct device *dev, int rpmflags)\n{\n\treturn -ENOSYS;\n}\nstatic inline int __pm_runtime_resume(struct device *dev, int rpmflags)\n{\n\treturn 1;\n}\nstatic inline int pm_schedule_suspend(struct device *dev, unsigned int delay)\n{\n\treturn -ENOSYS;\n}\nstatic inline int pm_runtime_get_if_in_use(struct device *dev)\n{\n\treturn -EINVAL;\n}\nstatic inline int pm_runtime_get_if_active(struct device *dev,\n\t\t\t\t\t   bool ign_usage_count)\n{\n\treturn -EINVAL;\n}\nstatic inline int __pm_runtime_set_status(struct device *dev,\n\t\t\t\t\t    unsigned int status) { return 0; }\nstatic inline int pm_runtime_barrier(struct device *dev) { return 0; }\nstatic inline void pm_runtime_enable(struct device *dev) {}\nstatic inline void __pm_runtime_disable(struct device *dev, bool c) {}\nstatic inline void pm_runtime_allow(struct device *dev) {}\nstatic inline void pm_runtime_forbid(struct device *dev) {}\n\nstatic inline int devm_pm_runtime_enable(struct device *dev) { return 0; }\n\nstatic inline void pm_suspend_ignore_children(struct device *dev, bool enable) {}\nstatic inline void pm_runtime_get_noresume(struct device *dev) {}\nstatic inline void pm_runtime_put_noidle(struct device *dev) {}\nstatic inline bool pm_runtime_suspended(struct device *dev) { return false; }\nstatic inline bool pm_runtime_active(struct device *dev) { return true; }\nstatic inline bool pm_runtime_status_suspended(struct device *dev) { return false; }\nstatic inline bool pm_runtime_enabled(struct device *dev) { return false; }\n\nstatic inline void pm_runtime_no_callbacks(struct device *dev) {}\nstatic inline void pm_runtime_irq_safe(struct device *dev) {}\nstatic inline bool pm_runtime_is_irq_safe(struct device *dev) { return false; }\n\nstatic inline bool pm_runtime_has_no_callbacks(struct device *dev) { return false; }\nstatic inline void pm_runtime_mark_last_busy(struct device *dev) {}\nstatic inline void __pm_runtime_use_autosuspend(struct device *dev,\n\t\t\t\t\t\tbool use) {}\nstatic inline void pm_runtime_set_autosuspend_delay(struct device *dev,\n\t\t\t\t\t\tint delay) {}\nstatic inline u64 pm_runtime_autosuspend_expiration(\n\t\t\t\tstruct device *dev) { return 0; }\nstatic inline void pm_runtime_set_memalloc_noio(struct device *dev,\n\t\t\t\t\t\tbool enable){}\nstatic inline void pm_runtime_get_suppliers(struct device *dev) {}\nstatic inline void pm_runtime_put_suppliers(struct device *dev) {}\nstatic inline void pm_runtime_new_link(struct device *dev) {}\nstatic inline void pm_runtime_drop_link(struct device_link *link) {}\nstatic inline void pm_runtime_release_supplier(struct device_link *link) {}\n\n#endif  \n\n \nstatic inline int pm_runtime_idle(struct device *dev)\n{\n\treturn __pm_runtime_idle(dev, 0);\n}\n\n \nstatic inline int pm_runtime_suspend(struct device *dev)\n{\n\treturn __pm_runtime_suspend(dev, 0);\n}\n\n \nstatic inline int pm_runtime_autosuspend(struct device *dev)\n{\n\treturn __pm_runtime_suspend(dev, RPM_AUTO);\n}\n\n \nstatic inline int pm_runtime_resume(struct device *dev)\n{\n\treturn __pm_runtime_resume(dev, 0);\n}\n\n \nstatic inline int pm_request_idle(struct device *dev)\n{\n\treturn __pm_runtime_idle(dev, RPM_ASYNC);\n}\n\n \nstatic inline int pm_request_resume(struct device *dev)\n{\n\treturn __pm_runtime_resume(dev, RPM_ASYNC);\n}\n\n \nstatic inline int pm_request_autosuspend(struct device *dev)\n{\n\treturn __pm_runtime_suspend(dev, RPM_ASYNC | RPM_AUTO);\n}\n\n \nstatic inline int pm_runtime_get(struct device *dev)\n{\n\treturn __pm_runtime_resume(dev, RPM_GET_PUT | RPM_ASYNC);\n}\n\n \nstatic inline int pm_runtime_get_sync(struct device *dev)\n{\n\treturn __pm_runtime_resume(dev, RPM_GET_PUT);\n}\n\n \nstatic inline int pm_runtime_resume_and_get(struct device *dev)\n{\n\tint ret;\n\n\tret = __pm_runtime_resume(dev, RPM_GET_PUT);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int pm_runtime_put(struct device *dev)\n{\n\treturn __pm_runtime_idle(dev, RPM_GET_PUT | RPM_ASYNC);\n}\n\n \nstatic inline int pm_runtime_put_autosuspend(struct device *dev)\n{\n\treturn __pm_runtime_suspend(dev,\n\t    RPM_GET_PUT | RPM_ASYNC | RPM_AUTO);\n}\n\n \nstatic inline int pm_runtime_put_sync(struct device *dev)\n{\n\treturn __pm_runtime_idle(dev, RPM_GET_PUT);\n}\n\n \nstatic inline int pm_runtime_put_sync_suspend(struct device *dev)\n{\n\treturn __pm_runtime_suspend(dev, RPM_GET_PUT);\n}\n\n \nstatic inline int pm_runtime_put_sync_autosuspend(struct device *dev)\n{\n\treturn __pm_runtime_suspend(dev, RPM_GET_PUT | RPM_AUTO);\n}\n\n \nstatic inline int pm_runtime_set_active(struct device *dev)\n{\n\treturn __pm_runtime_set_status(dev, RPM_ACTIVE);\n}\n\n \nstatic inline int pm_runtime_set_suspended(struct device *dev)\n{\n\treturn __pm_runtime_set_status(dev, RPM_SUSPENDED);\n}\n\n \nstatic inline void pm_runtime_disable(struct device *dev)\n{\n\t__pm_runtime_disable(dev, true);\n}\n\n \nstatic inline void pm_runtime_use_autosuspend(struct device *dev)\n{\n\t__pm_runtime_use_autosuspend(dev, true);\n}\n\n \nstatic inline void pm_runtime_dont_use_autosuspend(struct device *dev)\n{\n\t__pm_runtime_use_autosuspend(dev, false);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}