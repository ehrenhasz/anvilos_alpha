{
  "module_name": "parport_pc.h",
  "hash_id": "b317eea78565a884ec663265082f8b68b842e9af2bb6256147d6ae4a240e5eb7",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/parport_pc.h",
  "human_readable_source": " \n#ifndef __LINUX_PARPORT_PC_H\n#define __LINUX_PARPORT_PC_H\n\n#include <asm/io.h>\n\n \n\n#define ECONTROL(p) ((p)->base_hi + 0x2)\n#define CONFIGB(p)  ((p)->base_hi + 0x1)\n#define CONFIGA(p)  ((p)->base_hi + 0x0)\n#define FIFO(p)     ((p)->base_hi + 0x0)\n#define EPPDATA(p)  ((p)->base    + 0x4)\n#define EPPADDR(p)  ((p)->base    + 0x3)\n#define CONTROL(p)  ((p)->base    + 0x2)\n#define STATUS(p)   ((p)->base    + 0x1)\n#define DATA(p)     ((p)->base    + 0x0)\n\nstruct parport_pc_private {\n\t \n\tunsigned char ctr;\n\n\t \n\tunsigned char ctr_writable;\n\n\t \n\tint ecr;\n\n\t \n\tunsigned char ecr_writable;\n\n\t \n\tint fifo_depth;\n\n\t \n\tint pword;\n\n\t \n\tint readIntrThreshold;\n\tint writeIntrThreshold;\n\n\t \n\tchar *dma_buf;\n\tdma_addr_t dma_handle;\n\tstruct list_head list;\n\tstruct parport *port;\n};\n\nstruct parport_pc_via_data\n{\n\t \n\tu8 via_pci_parport_irq_reg;\n\t \n\tu8 via_pci_parport_dma_reg;\n\t \n\tu8 via_pci_superio_config_reg;\n\tu8 via_pci_superio_config_data;\n\t \n\tu8 viacfg_function;\n\t \n\tu8 viacfg_parport_control;\n\t \n\tu8 viacfg_parport_base;\n};\n\nstatic __inline__ void parport_pc_write_data(struct parport *p, unsigned char d)\n{\n#ifdef DEBUG_PARPORT\n\tprintk (KERN_DEBUG \"parport_pc_write_data(%p,0x%02x)\\n\", p, d);\n#endif\n\toutb(d, DATA(p));\n}\n\nstatic __inline__ unsigned char parport_pc_read_data(struct parport *p)\n{\n\tunsigned char val = inb (DATA (p));\n#ifdef DEBUG_PARPORT\n\tprintk (KERN_DEBUG \"parport_pc_read_data(%p) = 0x%02x\\n\",\n\t\tp, val);\n#endif\n\treturn val;\n}\n\n#ifdef DEBUG_PARPORT\nstatic inline void dump_parport_state (char *str, struct parport *p)\n{\n\t \n\tunsigned char ecr = inb (ECONTROL (p));\n\tunsigned char dcr = inb (CONTROL (p));\n\tunsigned char dsr = inb (STATUS (p));\n\tstatic const char *const ecr_modes[] = {\"SPP\", \"PS2\", \"PPFIFO\", \"ECP\", \"xXx\", \"yYy\", \"TST\", \"CFG\"};\n\tconst struct parport_pc_private *priv = p->physport->private_data;\n\tint i;\n\n\tprintk (KERN_DEBUG \"*** parport state (%s): ecr=[%s\", str, ecr_modes[(ecr & 0xe0) >> 5]);\n\tif (ecr & 0x10) printk (\",nErrIntrEn\");\n\tif (ecr & 0x08) printk (\",dmaEn\");\n\tif (ecr & 0x04) printk (\",serviceIntr\");\n\tif (ecr & 0x02) printk (\",f_full\");\n\tif (ecr & 0x01) printk (\",f_empty\");\n\tfor (i=0; i<2; i++) {\n\t\tprintk (\"]  dcr(%s)=[\", i ? \"soft\" : \"hard\");\n\t\tdcr = i ? priv->ctr : inb (CONTROL (p));\n\t\n\t\tif (dcr & 0x20) {\n\t\t\tprintk (\"rev\");\n\t\t} else {\n\t\t\tprintk (\"fwd\");\n\t\t}\n\t\tif (dcr & 0x10) printk (\",ackIntEn\");\n\t\tif (!(dcr & 0x08)) printk (\",N-SELECT-IN\");\n\t\tif (dcr & 0x04) printk (\",N-INIT\");\n\t\tif (!(dcr & 0x02)) printk (\",N-AUTOFD\");\n\t\tif (!(dcr & 0x01)) printk (\",N-STROBE\");\n\t}\n\tprintk (\"]  dsr=[\");\n\tif (!(dsr & 0x80)) printk (\"BUSY\");\n\tif (dsr & 0x40) printk (\",N-ACK\");\n\tif (dsr & 0x20) printk (\",PERROR\");\n\tif (dsr & 0x10) printk (\",SELECT\");\n\tif (dsr & 0x08) printk (\",N-FAULT\");\n\tprintk (\"]\\n\");\n\treturn;\n}\n#else\t \n#define dump_parport_state(args...)\n#endif\t \n\n \nstatic __inline__ unsigned char __parport_pc_frob_control (struct parport *p,\n\t\t\t\t\t\t\t   unsigned char mask,\n\t\t\t\t\t\t\t   unsigned char val)\n{\n\tstruct parport_pc_private *priv = p->physport->private_data;\n\tunsigned char ctr = priv->ctr;\n#ifdef DEBUG_PARPORT\n\tprintk (KERN_DEBUG\n\t\t\"__parport_pc_frob_control(%02x,%02x): %02x -> %02x\\n\",\n\t\tmask, val, ctr, ((ctr & ~mask) ^ val) & priv->ctr_writable);\n#endif\n\tctr = (ctr & ~mask) ^ val;\n\tctr &= priv->ctr_writable;  \n\toutb (ctr, CONTROL (p));\n\tpriv->ctr = ctr;\t \n\treturn ctr;\n}\n\nstatic __inline__ void parport_pc_data_reverse (struct parport *p)\n{\n\t__parport_pc_frob_control (p, 0x20, 0x20);\n}\n\nstatic __inline__ void parport_pc_data_forward (struct parport *p)\n{\n\t__parport_pc_frob_control (p, 0x20, 0x00);\n}\n\nstatic __inline__ void parport_pc_write_control (struct parport *p,\n\t\t\t\t\t\t unsigned char d)\n{\n\tconst unsigned char wm = (PARPORT_CONTROL_STROBE |\n\t\t\t\t  PARPORT_CONTROL_AUTOFD |\n\t\t\t\t  PARPORT_CONTROL_INIT |\n\t\t\t\t  PARPORT_CONTROL_SELECT);\n\n\t \n\tif (d & 0x20) {\n\t\tprintk (KERN_DEBUG \"%s (%s): use data_reverse for this!\\n\",\n\t\t\tp->name, p->cad->name);\n\t\tparport_pc_data_reverse (p);\n\t}\n\n\t__parport_pc_frob_control (p, wm, d & wm);\n}\n\nstatic __inline__ unsigned char parport_pc_read_control(struct parport *p)\n{\n\tconst unsigned char rm = (PARPORT_CONTROL_STROBE |\n\t\t\t\t  PARPORT_CONTROL_AUTOFD |\n\t\t\t\t  PARPORT_CONTROL_INIT |\n\t\t\t\t  PARPORT_CONTROL_SELECT);\n\tconst struct parport_pc_private *priv = p->physport->private_data;\n\treturn priv->ctr & rm;  \n}\n\nstatic __inline__ unsigned char parport_pc_frob_control (struct parport *p,\n\t\t\t\t\t\t\t unsigned char mask,\n\t\t\t\t\t\t\t unsigned char val)\n{\n\tconst unsigned char wm = (PARPORT_CONTROL_STROBE |\n\t\t\t\t  PARPORT_CONTROL_AUTOFD |\n\t\t\t\t  PARPORT_CONTROL_INIT |\n\t\t\t\t  PARPORT_CONTROL_SELECT);\n\n\t \n\tif (mask & 0x20) {\n\t\tprintk (KERN_DEBUG \"%s (%s): use data_%s for this!\\n\",\n\t\t\tp->name, p->cad->name,\n\t\t\t(val & 0x20) ? \"reverse\" : \"forward\");\n\t\tif (val & 0x20)\n\t\t\tparport_pc_data_reverse (p);\n\t\telse\n\t\t\tparport_pc_data_forward (p);\n\t}\n\n\t \n\tmask &= wm;\n\tval &= wm;\n\n\treturn __parport_pc_frob_control (p, mask, val);\n}\n\nstatic __inline__ unsigned char parport_pc_read_status(struct parport *p)\n{\n\treturn inb(STATUS(p));\n}\n\n\nstatic __inline__ void parport_pc_disable_irq(struct parport *p)\n{\n\t__parport_pc_frob_control (p, 0x10, 0x00);\n}\n\nstatic __inline__ void parport_pc_enable_irq(struct parport *p)\n{\n\t__parport_pc_frob_control (p, 0x10, 0x10);\n}\n\nextern void parport_pc_release_resources(struct parport *p);\n\nextern int parport_pc_claim_resources(struct parport *p);\n\n \nextern struct parport *parport_pc_probe_port(unsigned long base,\n\t\t\t\t\t     unsigned long base_hi,\n\t\t\t\t\t     int irq, int dma,\n\t\t\t\t\t     struct device *dev,\n\t\t\t\t\t     int irqflags);\nextern void parport_pc_unregister_port(struct parport *p);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}