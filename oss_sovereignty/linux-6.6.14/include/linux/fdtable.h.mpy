{
  "module_name": "fdtable.h",
  "hash_id": "8ea1ce55177298107e4ecff7e780ff6f96be38fd8fb45e022c1c453df8d8e0bd",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fdtable.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_FDTABLE_H\n#define __LINUX_FDTABLE_H\n\n#include <linux/posix_types.h>\n#include <linux/compiler.h>\n#include <linux/spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/nospec.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\n#include <linux/atomic.h>\n\n \n#define NR_OPEN_DEFAULT BITS_PER_LONG\n#define NR_OPEN_MAX ~0U\n\nstruct fdtable {\n\tunsigned int max_fds;\n\tstruct file __rcu **fd;       \n\tunsigned long *close_on_exec;\n\tunsigned long *open_fds;\n\tunsigned long *full_fds_bits;\n\tstruct rcu_head rcu;\n};\n\nstatic inline bool close_on_exec(unsigned int fd, const struct fdtable *fdt)\n{\n\treturn test_bit(fd, fdt->close_on_exec);\n}\n\nstatic inline bool fd_is_open(unsigned int fd, const struct fdtable *fdt)\n{\n\treturn test_bit(fd, fdt->open_fds);\n}\n\n \nstruct files_struct {\n   \n\tatomic_t count;\n\tbool resize_in_progress;\n\twait_queue_head_t resize_wait;\n\n\tstruct fdtable __rcu *fdt;\n\tstruct fdtable fdtab;\n   \n\tspinlock_t file_lock ____cacheline_aligned_in_smp;\n\tunsigned int next_fd;\n\tunsigned long close_on_exec_init[1];\n\tunsigned long open_fds_init[1];\n\tunsigned long full_fds_bits_init[1];\n\tstruct file __rcu * fd_array[NR_OPEN_DEFAULT];\n};\n\nstruct file_operations;\nstruct vfsmount;\nstruct dentry;\n\n#define rcu_dereference_check_fdtable(files, fdtfd) \\\n\trcu_dereference_check((fdtfd), lockdep_is_held(&(files)->file_lock))\n\n#define files_fdtable(files) \\\n\trcu_dereference_check_fdtable((files), (files)->fdt)\n\n \nstatic inline struct file *files_lookup_fd_raw(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\n\tif (fd < fdt->max_fds) {\n\t\tfd = array_index_nospec(fd, fdt->max_fds);\n\t\treturn rcu_dereference_raw(fdt->fd[fd]);\n\t}\n\treturn NULL;\n}\n\nstatic inline struct file *files_lookup_fd_locked(struct files_struct *files, unsigned int fd)\n{\n\tRCU_LOCKDEP_WARN(!lockdep_is_held(&files->file_lock),\n\t\t\t   \"suspicious rcu_dereference_check() usage\");\n\treturn files_lookup_fd_raw(files, fd);\n}\n\nstatic inline struct file *files_lookup_fd_rcu(struct files_struct *files, unsigned int fd)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t   \"suspicious rcu_dereference_check() usage\");\n\treturn files_lookup_fd_raw(files, fd);\n}\n\nstatic inline struct file *lookup_fd_rcu(unsigned int fd)\n{\n\treturn files_lookup_fd_rcu(current->files, fd);\n}\n\nstruct file *task_lookup_fd_rcu(struct task_struct *task, unsigned int fd);\nstruct file *task_lookup_next_fd_rcu(struct task_struct *task, unsigned int *fd);\n\nstruct task_struct;\n\nvoid put_files_struct(struct files_struct *fs);\nint unshare_files(void);\nstruct files_struct *dup_fd(struct files_struct *, unsigned, int *) __latent_entropy;\nvoid do_close_on_exec(struct files_struct *);\nint iterate_fd(struct files_struct *, unsigned,\n\t\tint (*)(const void *, struct file *, unsigned),\n\t\tconst void *);\n\nextern int close_fd(unsigned int fd);\nextern int __close_range(unsigned int fd, unsigned int max_fd, unsigned int flags);\nextern struct file *close_fd_get_file(unsigned int fd);\nextern int unshare_fd(unsigned long unshare_flags, unsigned int max_fds,\n\t\t      struct files_struct **new_fdp);\n\nextern struct kmem_cache *files_cachep;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}