{
  "module_name": "libata.h",
  "hash_id": "37911e43b7a63fe57a1b636bacf90bd0dddad26a7c20935904b4d1c411ac835f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/libata.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_LIBATA_H__\n#define __LINUX_LIBATA_H__\n\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/io.h>\n#include <linux/ata.h>\n#include <linux/workqueue.h>\n#include <scsi/scsi_host.h>\n#include <linux/acpi.h>\n#include <linux/cdrom.h>\n#include <linux/sched.h>\n#include <linux/async.h>\n\n \n#ifdef CONFIG_ATA_NONSTANDARD\n#include <asm/libata-portmap.h>\n#else\n#define ATA_PRIMARY_IRQ(dev)\t14\n#define ATA_SECONDARY_IRQ(dev)\t15\n#endif\n\n \n#undef ATA_IRQ_TRAP\t\t \n\n\n#define ata_print_version_once(dev, version)\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tstatic bool __print_once;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (!__print_once) {\t\t\t\t\t\\\n\t\t__print_once = true;\t\t\t\t\\\n\t\tata_print_version(dev, version);\t\t\\\n\t}\t\t\t\t\t\t\t\\\n})\n\n \n#define ATA_TAG_POISON\t\t0xfafbfcfdU\n\nenum {\n\t \n\tLIBATA_MAX_PRD\t\t= ATA_MAX_PRD / 2,\n\tLIBATA_DUMB_MAX_PRD\t= ATA_MAX_PRD / 4,\t \n\tATA_DEF_QUEUE\t\t= 1,\n\tATA_MAX_QUEUE\t\t= 32,\n\tATA_TAG_INTERNAL\t= ATA_MAX_QUEUE,\n\tATA_SHORT_PAUSE\t\t= 16,\n\n\tATAPI_MAX_DRAIN\t\t= 16 << 10,\n\n\tATA_ALL_DEVICES\t\t= (1 << ATA_MAX_DEVICES) - 1,\n\n\tATA_SHT_EMULATED\t= 1,\n\tATA_SHT_THIS_ID\t\t= -1,\n\n\t \n\tATA_TFLAG_LBA48\t\t= (1 << 0),  \n\tATA_TFLAG_ISADDR\t= (1 << 1),  \n\tATA_TFLAG_DEVICE\t= (1 << 2),  \n\tATA_TFLAG_WRITE\t\t= (1 << 3),  \n\tATA_TFLAG_LBA\t\t= (1 << 4),  \n\tATA_TFLAG_FUA\t\t= (1 << 5),  \n\tATA_TFLAG_POLLING\t= (1 << 6),  \n\n\t \n\tATA_DFLAG_LBA\t\t= (1 << 0),  \n\tATA_DFLAG_LBA48\t\t= (1 << 1),  \n\tATA_DFLAG_CDB_INTR\t= (1 << 2),  \n\tATA_DFLAG_NCQ\t\t= (1 << 3),  \n\tATA_DFLAG_FLUSH_EXT\t= (1 << 4),  \n\tATA_DFLAG_ACPI_PENDING\t= (1 << 5),  \n\tATA_DFLAG_ACPI_FAILED\t= (1 << 6),  \n\tATA_DFLAG_AN\t\t= (1 << 7),  \n\tATA_DFLAG_TRUSTED\t= (1 << 8),  \n\tATA_DFLAG_FUA\t\t= (1 << 9),  \n\tATA_DFLAG_DMADIR\t= (1 << 10),  \n\tATA_DFLAG_NCQ_SEND_RECV = (1 << 11),  \n\tATA_DFLAG_NCQ_PRIO\t= (1 << 12),  \n\tATA_DFLAG_CDL\t\t= (1 << 13),  \n\tATA_DFLAG_CFG_MASK\t= (1 << 14) - 1,\n\n\tATA_DFLAG_PIO\t\t= (1 << 14),  \n\tATA_DFLAG_NCQ_OFF\t= (1 << 15),  \n\tATA_DFLAG_SLEEPING\t= (1 << 16),  \n\tATA_DFLAG_DUBIOUS_XFER\t= (1 << 17),  \n\tATA_DFLAG_NO_UNLOAD\t= (1 << 18),  \n\tATA_DFLAG_UNLOCK_HPA\t= (1 << 19),  \n\tATA_DFLAG_INIT_MASK\t= (1 << 20) - 1,\n\n\tATA_DFLAG_NCQ_PRIO_ENABLED = (1 << 20),  \n\tATA_DFLAG_CDL_ENABLED\t= (1 << 21),  \n\tATA_DFLAG_DETACH\t= (1 << 24),\n\tATA_DFLAG_DETACHED\t= (1 << 25),\n\tATA_DFLAG_DA\t\t= (1 << 26),  \n\tATA_DFLAG_DEVSLP\t= (1 << 27),  \n\tATA_DFLAG_ACPI_DISABLED = (1 << 28),  \n\tATA_DFLAG_D_SENSE\t= (1 << 29),  \n\tATA_DFLAG_ZAC\t\t= (1 << 30),  \n\n\tATA_DFLAG_FEATURES_MASK\t= (ATA_DFLAG_TRUSTED | ATA_DFLAG_DA |\t\\\n\t\t\t\t   ATA_DFLAG_DEVSLP | ATA_DFLAG_NCQ_SEND_RECV | \\\n\t\t\t\t   ATA_DFLAG_NCQ_PRIO | ATA_DFLAG_FUA | \\\n\t\t\t\t   ATA_DFLAG_CDL),\n\n\tATA_DEV_UNKNOWN\t\t= 0,\t \n\tATA_DEV_ATA\t\t= 1,\t \n\tATA_DEV_ATA_UNSUP\t= 2,\t \n\tATA_DEV_ATAPI\t\t= 3,\t \n\tATA_DEV_ATAPI_UNSUP\t= 4,\t \n\tATA_DEV_PMP\t\t= 5,\t \n\tATA_DEV_PMP_UNSUP\t= 6,\t \n\tATA_DEV_SEMB\t\t= 7,\t \n\tATA_DEV_SEMB_UNSUP\t= 8,\t \n\tATA_DEV_ZAC\t\t= 9,\t \n\tATA_DEV_ZAC_UNSUP\t= 10,\t \n\tATA_DEV_NONE\t\t= 11,\t \n\n\t \n\t \n\tATA_LFLAG_NO_HRST\t= (1 << 1),  \n\tATA_LFLAG_NO_SRST\t= (1 << 2),  \n\tATA_LFLAG_ASSUME_ATA\t= (1 << 3),  \n\tATA_LFLAG_ASSUME_SEMB\t= (1 << 4),  \n\tATA_LFLAG_ASSUME_CLASS\t= ATA_LFLAG_ASSUME_ATA | ATA_LFLAG_ASSUME_SEMB,\n\tATA_LFLAG_NO_RETRY\t= (1 << 5),  \n\tATA_LFLAG_DISABLED\t= (1 << 6),  \n\tATA_LFLAG_SW_ACTIVITY\t= (1 << 7),  \n\tATA_LFLAG_NO_LPM\t= (1 << 8),  \n\tATA_LFLAG_RST_ONCE\t= (1 << 9),  \n\tATA_LFLAG_CHANGED\t= (1 << 10),  \n\tATA_LFLAG_NO_DEBOUNCE_DELAY = (1 << 11),  \n\n\t \n\tATA_FLAG_SLAVE_POSS\t= (1 << 0),  \n\t\t\t\t\t     \n\tATA_FLAG_SATA\t\t= (1 << 1),\n\tATA_FLAG_NO_LPM\t\t= (1 << 2),  \n\tATA_FLAG_NO_LOG_PAGE\t= (1 << 5),  \n\tATA_FLAG_NO_ATAPI\t= (1 << 6),  \n\tATA_FLAG_PIO_DMA\t= (1 << 7),  \n\tATA_FLAG_PIO_LBA48\t= (1 << 8),  \n\tATA_FLAG_PIO_POLLING\t= (1 << 9),  \n\tATA_FLAG_NCQ\t\t= (1 << 10),  \n\tATA_FLAG_NO_POWEROFF_SPINDOWN = (1 << 11),  \n\tATA_FLAG_NO_HIBERNATE_SPINDOWN = (1 << 12),  \n\tATA_FLAG_DEBUGMSG\t= (1 << 13),\n\tATA_FLAG_FPDMA_AA\t\t= (1 << 14),  \n\tATA_FLAG_IGN_SIMPLEX\t= (1 << 15),  \n\tATA_FLAG_NO_IORDY\t= (1 << 16),  \n\tATA_FLAG_ACPI_SATA\t= (1 << 17),  \n\tATA_FLAG_AN\t\t= (1 << 18),  \n\tATA_FLAG_PMP\t\t= (1 << 19),  \n\tATA_FLAG_FPDMA_AUX\t= (1 << 20),  \n\tATA_FLAG_EM\t\t= (1 << 21),  \n\tATA_FLAG_SW_ACTIVITY\t= (1 << 22),  \n\tATA_FLAG_NO_DIPM\t= (1 << 23),  \n\tATA_FLAG_SAS_HOST\t= (1 << 24),  \n\n\t \n\n\n\t \n\tATA_PFLAG_EH_PENDING\t= (1 << 0),  \n\tATA_PFLAG_EH_IN_PROGRESS = (1 << 1),  \n\tATA_PFLAG_FROZEN\t= (1 << 2),  \n\tATA_PFLAG_RECOVERED\t= (1 << 3),  \n\tATA_PFLAG_LOADING\t= (1 << 4),  \n\tATA_PFLAG_SCSI_HOTPLUG\t= (1 << 6),  \n\tATA_PFLAG_INITIALIZING\t= (1 << 7),  \n\tATA_PFLAG_RESETTING\t= (1 << 8),  \n\tATA_PFLAG_UNLOADING\t= (1 << 9),  \n\tATA_PFLAG_UNLOADED\t= (1 << 10),  \n\n\tATA_PFLAG_RESUMING\t= (1 << 16),   \n\tATA_PFLAG_SUSPENDED\t= (1 << 17),  \n\tATA_PFLAG_PM_PENDING\t= (1 << 18),  \n\tATA_PFLAG_INIT_GTM_VALID = (1 << 19),  \n\n\tATA_PFLAG_PIO32\t\t= (1 << 20),   \n\tATA_PFLAG_PIO32CHANGE\t= (1 << 21),   \n\tATA_PFLAG_EXTERNAL\t= (1 << 22),   \n\n\t \n\tATA_QCFLAG_ACTIVE\t= (1 << 0),  \n\tATA_QCFLAG_DMAMAP\t= (1 << 1),  \n\tATA_QCFLAG_RTF_FILLED\t= (1 << 2),  \n\tATA_QCFLAG_IO\t\t= (1 << 3),  \n\tATA_QCFLAG_RESULT_TF\t= (1 << 4),  \n\tATA_QCFLAG_CLEAR_EXCL\t= (1 << 5),  \n\tATA_QCFLAG_QUIET\t= (1 << 6),  \n\tATA_QCFLAG_RETRY\t= (1 << 7),  \n\tATA_QCFLAG_HAS_CDL\t= (1 << 8),  \n\n\tATA_QCFLAG_EH\t\t= (1 << 16),  \n\tATA_QCFLAG_SENSE_VALID\t= (1 << 17),  \n\tATA_QCFLAG_EH_SCHEDULED = (1 << 18),  \n\tATA_QCFLAG_EH_SUCCESS_CMD = (1 << 19),  \n\n\t \n\tATA_HOST_SIMPLEX\t= (1 << 0),\t \n\tATA_HOST_STARTED\t= (1 << 1),\t \n\tATA_HOST_PARALLEL_SCAN\t= (1 << 2),\t \n\tATA_HOST_IGNORE_ATA\t= (1 << 3),\t \n\n\tATA_HOST_NO_PART\t= (1 << 4),  \n\tATA_HOST_NO_SSC\t\t= (1 << 5),  \n\tATA_HOST_NO_DEVSLP\t= (1 << 6),  \n\n\t \n\n\t \n\tATA_TMOUT_BOOT\t\t= 30000,\t \n\tATA_TMOUT_BOOT_QUICK\t=  7000,\t \n\tATA_TMOUT_INTERNAL_QUICK = 5000,\n\tATA_TMOUT_MAX_PARK\t= 30000,\n\n\t \n\tATA_TMOUT_FF_WAIT_LONG\t=  2000,\n\tATA_TMOUT_FF_WAIT\t=   800,\n\n\t \n\tATA_WAIT_AFTER_RESET\t=  150,\n\n\t \n\tATA_TMOUT_PMP_SRST_WAIT\t= 10000,\n\n\t \n\tATA_TMOUT_SPURIOUS_PHY\t= 10000,\n\n\t \n\tBUS_UNKNOWN\t\t= 0,\n\tBUS_DMA\t\t\t= 1,\n\tBUS_IDLE\t\t= 2,\n\tBUS_NOINTR\t\t= 3,\n\tBUS_NODATA\t\t= 4,\n\tBUS_TIMER\t\t= 5,\n\tBUS_PIO\t\t\t= 6,\n\tBUS_EDD\t\t\t= 7,\n\tBUS_IDENTIFY\t\t= 8,\n\tBUS_PACKET\t\t= 9,\n\n\t \n\tPORT_UNKNOWN\t\t= 0,\n\tPORT_ENABLED\t\t= 1,\n\tPORT_DISABLED\t\t= 2,\n\n\t \n\tATA_NR_PIO_MODES\t= 7,\n\tATA_NR_MWDMA_MODES\t= 5,\n\tATA_NR_UDMA_MODES\t= 8,\n\n\tATA_SHIFT_PIO\t\t= 0,\n\tATA_SHIFT_MWDMA\t\t= ATA_SHIFT_PIO + ATA_NR_PIO_MODES,\n\tATA_SHIFT_UDMA\t\t= ATA_SHIFT_MWDMA + ATA_NR_MWDMA_MODES,\n\tATA_SHIFT_PRIO\t\t= 6,\n\n\tATA_PRIO_HIGH\t\t= 2,\n\t \n\tATA_DMA_PAD_SZ\t\t= 4,\n\n\t \n\tATA_ERING_SIZE\t\t= 32,\n\n\t \n\tATA_DEFER_LINK\t\t= 1,\n\tATA_DEFER_PORT\t\t= 2,\n\n\t \n\tATA_EH_DESC_LEN\t\t= 80,\n\n\t \n\tATA_EH_REVALIDATE\t= (1 << 0),\n\tATA_EH_SOFTRESET\t= (1 << 1),  \n\tATA_EH_HARDRESET\t= (1 << 2),  \n\tATA_EH_RESET\t\t= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,\n\tATA_EH_ENABLE_LINK\t= (1 << 3),\n\tATA_EH_PARK\t\t= (1 << 5),  \n\tATA_EH_GET_SUCCESS_SENSE = (1 << 6),  \n\tATA_EH_SET_ACTIVE\t= (1 << 7),  \n\n\tATA_EH_PERDEV_MASK\t= ATA_EH_REVALIDATE | ATA_EH_PARK |\n\t\t\t\t  ATA_EH_GET_SUCCESS_SENSE | ATA_EH_SET_ACTIVE,\n\tATA_EH_ALL_ACTIONS\t= ATA_EH_REVALIDATE | ATA_EH_RESET |\n\t\t\t\t  ATA_EH_ENABLE_LINK,\n\n\t \n\tATA_EHI_HOTPLUGGED\t= (1 << 0),   \n\tATA_EHI_NO_AUTOPSY\t= (1 << 2),   \n\tATA_EHI_QUIET\t\t= (1 << 3),   \n\tATA_EHI_NO_RECOVERY\t= (1 << 4),   \n\n\tATA_EHI_DID_SOFTRESET\t= (1 << 16),  \n\tATA_EHI_DID_HARDRESET\t= (1 << 17),  \n\tATA_EHI_PRINTINFO\t= (1 << 18),  \n\tATA_EHI_SETMODE\t\t= (1 << 19),  \n\tATA_EHI_POST_SETMODE\t= (1 << 20),  \n\n\tATA_EHI_DID_RESET\t= ATA_EHI_DID_SOFTRESET | ATA_EHI_DID_HARDRESET,\n\n\t \n\tATA_EHI_TO_SLAVE_MASK\t= ATA_EHI_NO_AUTOPSY | ATA_EHI_QUIET,\n\n\t \n\tATA_EH_MAX_TRIES\t= 5,\n\n\t \n\tATA_LINK_RESUME_TRIES\t= 5,\n\n\t \n\tATA_EH_DEV_TRIES\t= 3,\n\tATA_EH_PMP_TRIES\t= 5,\n\tATA_EH_PMP_LINK_TRIES\t= 3,\n\n\tSATA_PMP_RW_TIMEOUT\t= 3000,\t\t \n\n\t \n\tATA_EH_CMD_TIMEOUT_TABLE_SIZE = 8,\n\n\t \n\n\tATA_HORKAGE_DIAGNOSTIC\t= (1 << 0),\t \n\tATA_HORKAGE_NODMA\t= (1 << 1),\t \n\tATA_HORKAGE_NONCQ\t= (1 << 2),\t \n\tATA_HORKAGE_MAX_SEC_128\t= (1 << 3),\t \n\tATA_HORKAGE_BROKEN_HPA\t= (1 << 4),\t \n\tATA_HORKAGE_DISABLE\t= (1 << 5),\t \n\tATA_HORKAGE_HPA_SIZE\t= (1 << 6),\t \n\tATA_HORKAGE_IVB\t\t= (1 << 8),\t \n\tATA_HORKAGE_STUCK_ERR\t= (1 << 9),\t \n\tATA_HORKAGE_BRIDGE_OK\t= (1 << 10),\t \n\tATA_HORKAGE_ATAPI_MOD16_DMA = (1 << 11),  \n\tATA_HORKAGE_FIRMWARE_WARN = (1 << 12),\t \n\tATA_HORKAGE_1_5_GBPS\t= (1 << 13),\t \n\tATA_HORKAGE_NOSETXFER\t= (1 << 14),\t \n\tATA_HORKAGE_BROKEN_FPDMA_AA\t= (1 << 15),\t \n\tATA_HORKAGE_DUMP_ID\t= (1 << 16),\t \n\tATA_HORKAGE_MAX_SEC_LBA48 = (1 << 17),\t \n\tATA_HORKAGE_ATAPI_DMADIR = (1 << 18),\t \n\tATA_HORKAGE_NO_NCQ_TRIM\t= (1 << 19),\t \n\tATA_HORKAGE_NOLPM\t= (1 << 20),\t \n\tATA_HORKAGE_WD_BROKEN_LPM = (1 << 21),\t \n\tATA_HORKAGE_ZERO_AFTER_TRIM = (1 << 22), \n\tATA_HORKAGE_NO_DMA_LOG\t= (1 << 23),\t \n\tATA_HORKAGE_NOTRIM\t= (1 << 24),\t \n\tATA_HORKAGE_MAX_SEC_1024 = (1 << 25),\t \n\tATA_HORKAGE_MAX_TRIM_128M = (1 << 26),\t \n\tATA_HORKAGE_NO_NCQ_ON_ATI = (1 << 27),\t \n\tATA_HORKAGE_NO_ID_DEV_LOG = (1 << 28),\t \n\tATA_HORKAGE_NO_LOG_DIR\t= (1 << 29),\t \n\tATA_HORKAGE_NO_FUA\t= (1 << 30),\t \n\n\t  \n\tATA_DMA_MASK_ATA\t= (1 << 0),\t \n\tATA_DMA_MASK_ATAPI\t= (1 << 1),\t \n\tATA_DMA_MASK_CFA\t= (1 << 2),\t \n\n\t \n\tATAPI_READ\t\t= 0,\t\t \n\tATAPI_WRITE\t\t= 1,\t\t \n\tATAPI_READ_CD\t\t= 2,\t\t \n\tATAPI_PASS_THRU\t\t= 3,\t\t \n\tATAPI_MISC\t\t= 4,\t\t \n\n\t \n\tATA_TIMING_SETUP\t= (1 << 0),\n\tATA_TIMING_ACT8B\t= (1 << 1),\n\tATA_TIMING_REC8B\t= (1 << 2),\n\tATA_TIMING_CYC8B\t= (1 << 3),\n\tATA_TIMING_8BIT\t\t= ATA_TIMING_ACT8B | ATA_TIMING_REC8B |\n\t\t\t\t  ATA_TIMING_CYC8B,\n\tATA_TIMING_ACTIVE\t= (1 << 4),\n\tATA_TIMING_RECOVER\t= (1 << 5),\n\tATA_TIMING_DMACK_HOLD\t= (1 << 6),\n\tATA_TIMING_CYCLE\t= (1 << 7),\n\tATA_TIMING_UDMA\t\t= (1 << 8),\n\tATA_TIMING_ALL\t\t= ATA_TIMING_SETUP | ATA_TIMING_ACT8B |\n\t\t\t\t  ATA_TIMING_REC8B | ATA_TIMING_CYC8B |\n\t\t\t\t  ATA_TIMING_ACTIVE | ATA_TIMING_RECOVER |\n\t\t\t\t  ATA_TIMING_DMACK_HOLD | ATA_TIMING_CYCLE |\n\t\t\t\t  ATA_TIMING_UDMA,\n\n\t \n\tATA_ACPI_FILTER_SETXFER\t= 1 << 0,\n\tATA_ACPI_FILTER_LOCK\t= 1 << 1,\n\tATA_ACPI_FILTER_DIPM\t= 1 << 2,\n\tATA_ACPI_FILTER_FPDMA_OFFSET = 1 << 3,\t \n\tATA_ACPI_FILTER_FPDMA_AA = 1 << 4,\t \n\n\tATA_ACPI_FILTER_DEFAULT\t= ATA_ACPI_FILTER_SETXFER |\n\t\t\t\t  ATA_ACPI_FILTER_LOCK |\n\t\t\t\t  ATA_ACPI_FILTER_DIPM,\n};\n\nenum ata_xfer_mask {\n\tATA_MASK_PIO\t\t= ((1U << ATA_NR_PIO_MODES) - 1) << ATA_SHIFT_PIO,\n\tATA_MASK_MWDMA\t\t= ((1U << ATA_NR_MWDMA_MODES) - 1) << ATA_SHIFT_MWDMA,\n\tATA_MASK_UDMA\t\t= ((1U << ATA_NR_UDMA_MODES) - 1) << ATA_SHIFT_UDMA,\n};\n\nenum hsm_task_states {\n\tHSM_ST_IDLE,\t\t \n\tHSM_ST_FIRST,\t\t \n\tHSM_ST,\t\t\t \n\tHSM_ST_LAST,\t\t \n\tHSM_ST_ERR,\t\t \n};\n\nenum ata_completion_errors {\n\tAC_ERR_OK\t\t= 0,\t     \n\tAC_ERR_DEV\t\t= (1 << 0),  \n\tAC_ERR_HSM\t\t= (1 << 1),  \n\tAC_ERR_TIMEOUT\t\t= (1 << 2),  \n\tAC_ERR_MEDIA\t\t= (1 << 3),  \n\tAC_ERR_ATA_BUS\t\t= (1 << 4),  \n\tAC_ERR_HOST_BUS\t\t= (1 << 5),  \n\tAC_ERR_SYSTEM\t\t= (1 << 6),  \n\tAC_ERR_INVALID\t\t= (1 << 7),  \n\tAC_ERR_OTHER\t\t= (1 << 8),  \n\tAC_ERR_NODEV_HINT\t= (1 << 9),  \n\tAC_ERR_NCQ\t\t= (1 << 10),  \n};\n\n \nenum ata_lpm_policy {\n\tATA_LPM_UNKNOWN,\n\tATA_LPM_MAX_POWER,\n\tATA_LPM_MED_POWER,\n\tATA_LPM_MED_POWER_WITH_DIPM,  \n\tATA_LPM_MIN_POWER_WITH_PARTIAL,  \n\tATA_LPM_MIN_POWER,  \n};\n\nenum ata_lpm_hints {\n\tATA_LPM_EMPTY\t\t= (1 << 0),  \n\tATA_LPM_HIPM\t\t= (1 << 1),  \n\tATA_LPM_WAKE_ONLY\t= (1 << 2),  \n};\n\n \nstruct scsi_device;\nstruct ata_port_operations;\nstruct ata_port;\nstruct ata_link;\nstruct ata_queued_cmd;\n\n \ntypedef void (*ata_qc_cb_t) (struct ata_queued_cmd *qc);\ntypedef int (*ata_prereset_fn_t)(struct ata_link *link, unsigned long deadline);\ntypedef int (*ata_reset_fn_t)(struct ata_link *link, unsigned int *classes,\n\t\t\t      unsigned long deadline);\ntypedef void (*ata_postreset_fn_t)(struct ata_link *link, unsigned int *classes);\n\nextern struct device_attribute dev_attr_unload_heads;\n#ifdef CONFIG_SATA_HOST\nextern struct device_attribute dev_attr_link_power_management_policy;\nextern struct device_attribute dev_attr_ncq_prio_supported;\nextern struct device_attribute dev_attr_ncq_prio_enable;\nextern struct device_attribute dev_attr_em_message_type;\nextern struct device_attribute dev_attr_em_message;\nextern struct device_attribute dev_attr_sw_activity;\n#endif\n\nenum sw_activity {\n\tOFF,\n\tBLINK_ON,\n\tBLINK_OFF,\n};\n\nstruct ata_taskfile {\n\tunsigned long\t\tflags;\t\t \n\tu8\t\t\tprotocol;\t \n\n\tu8\t\t\tctl;\t\t \n\n\tu8\t\t\thob_feature;\t \n\tu8\t\t\thob_nsect;\t \n\tu8\t\t\thob_lbal;\n\tu8\t\t\thob_lbam;\n\tu8\t\t\thob_lbah;\n\n\tunion {\n\t\tu8\t\terror;\n\t\tu8\t\tfeature;\n\t};\n\tu8\t\t\tnsect;\n\tu8\t\t\tlbal;\n\tu8\t\t\tlbam;\n\tu8\t\t\tlbah;\n\n\tu8\t\t\tdevice;\n\n\tunion {\n\t\tu8\t\tstatus;\n\t\tu8\t\tcommand;\n\t};\n\n\tu32\t\t\tauxiliary;\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n};\n\n#ifdef CONFIG_ATA_SFF\nstruct ata_ioports {\n\tvoid __iomem\t\t*cmd_addr;\n\tvoid __iomem\t\t*data_addr;\n\tvoid __iomem\t\t*error_addr;\n\tvoid __iomem\t\t*feature_addr;\n\tvoid __iomem\t\t*nsect_addr;\n\tvoid __iomem\t\t*lbal_addr;\n\tvoid __iomem\t\t*lbam_addr;\n\tvoid __iomem\t\t*lbah_addr;\n\tvoid __iomem\t\t*device_addr;\n\tvoid __iomem\t\t*status_addr;\n\tvoid __iomem\t\t*command_addr;\n\tvoid __iomem\t\t*altstatus_addr;\n\tvoid __iomem\t\t*ctl_addr;\n#ifdef CONFIG_ATA_BMDMA\n\tvoid __iomem\t\t*bmdma_addr;\n#endif  \n\tvoid __iomem\t\t*scr_addr;\n};\n#endif  \n\nstruct ata_host {\n\tspinlock_t\t\tlock;\n\tstruct device \t\t*dev;\n\tvoid __iomem * const\t*iomap;\n\tunsigned int\t\tn_ports;\n\tunsigned int\t\tn_tags;\t\t\t \n\tvoid\t\t\t*private_data;\n\tstruct ata_port_operations *ops;\n\tunsigned long\t\tflags;\n\tstruct kref\t\tkref;\n\n\tstruct mutex\t\teh_mutex;\n\tstruct task_struct\t*eh_owner;\n\n\tstruct ata_port\t\t*simplex_claimed;\t \n\tstruct ata_port\t\t*ports[];\n};\n\nstruct ata_queued_cmd {\n\tstruct ata_port\t\t*ap;\n\tstruct ata_device\t*dev;\n\n\tstruct scsi_cmnd\t*scsicmd;\n\tvoid\t\t\t(*scsidone)(struct scsi_cmnd *);\n\n\tstruct ata_taskfile\ttf;\n\tu8\t\t\tcdb[ATAPI_CDB_LEN];\n\n\tunsigned long\t\tflags;\t\t \n\tunsigned int\t\ttag;\t\t \n\tunsigned int\t\thw_tag;\t\t \n\tunsigned int\t\tn_elem;\n\tunsigned int\t\torig_n_elem;\n\n\tint\t\t\tdma_dir;\n\n\tunsigned int\t\tsect_size;\n\n\tunsigned int\t\tnbytes;\n\tunsigned int\t\textrabytes;\n\tunsigned int\t\tcurbytes;\n\n\tstruct scatterlist\tsgent;\n\n\tstruct scatterlist\t*sg;\n\n\tstruct scatterlist\t*cursg;\n\tunsigned int\t\tcursg_ofs;\n\n\tunsigned int\t\terr_mask;\n\tstruct ata_taskfile\tresult_tf;\n\tata_qc_cb_t\t\tcomplete_fn;\n\n\tvoid\t\t\t*private_data;\n\tvoid\t\t\t*lldd_task;\n};\n\nstruct ata_port_stats {\n\tunsigned long\t\tunhandled_irq;\n\tunsigned long\t\tidle_irq;\n\tunsigned long\t\trw_reqbuf;\n};\n\nstruct ata_ering_entry {\n\tunsigned int\t\teflags;\n\tunsigned int\t\terr_mask;\n\tu64\t\t\ttimestamp;\n};\n\nstruct ata_ering {\n\tint\t\t\tcursor;\n\tstruct ata_ering_entry\tring[ATA_ERING_SIZE];\n};\n\nstruct ata_cpr {\n\tu8\t\t\tnum;\n\tu8\t\t\tnum_storage_elements;\n\tu64\t\t\tstart_lba;\n\tu64\t\t\tnum_lbas;\n};\n\nstruct ata_cpr_log {\n\tu8\t\t\tnr_cpr;\n\tstruct ata_cpr\t\tcpr[];\n};\n\nstruct ata_device {\n\tstruct ata_link\t\t*link;\n\tunsigned int\t\tdevno;\t\t \n\tunsigned int\t\thorkage;\t \n\tunsigned long\t\tflags;\t\t \n\tstruct scsi_device\t*sdev;\t\t \n\tvoid\t\t\t*private_data;\n#ifdef CONFIG_ATA_ACPI\n\tunion acpi_object\t*gtf_cache;\n\tunsigned int\t\tgtf_filter;\n#endif\n#ifdef CONFIG_SATA_ZPODD\n\tvoid\t\t\t*zpodd;\n#endif\n\tstruct device\t\ttdev;\n\t \n\tu64\t\t\tn_sectors;\t \n\tu64\t\t\tn_native_sectors;  \n\tunsigned int\t\tclass;\t\t \n\tunsigned long\t\tunpark_deadline;\n\n\tu8\t\t\tpio_mode;\n\tu8\t\t\tdma_mode;\n\tu8\t\t\txfer_mode;\n\tunsigned int\t\txfer_shift;\t \n\n\tunsigned int\t\tmulti_count;\t \n\tunsigned int\t\tmax_sectors;\t \n\tunsigned int\t\tcdb_len;\n\n\t \n\tunsigned int\t\tpio_mask;\n\tunsigned int\t\tmwdma_mask;\n\tunsigned int\t\tudma_mask;\n\n\t \n\tu16\t\t\tcylinders;\t \n\tu16\t\t\theads;\t\t \n\tu16\t\t\tsectors;\t \n\n\tunion {\n\t\tu16\t\tid[ATA_ID_WORDS];  \n\t\tu32\t\tgscr[SATA_PMP_GSCR_DWORDS];  \n\t} ____cacheline_aligned;\n\n\t \n\tu8\t\t\tdevslp_timing[ATA_LOG_DEVSLP_SIZE];\n\n\t \n\tu8\t\t\tncq_send_recv_cmds[ATA_LOG_NCQ_SEND_RECV_SIZE];\n\tu8\t\t\tncq_non_data_cmds[ATA_LOG_NCQ_NON_DATA_SIZE];\n\n\t \n\tu32\t\t\tzac_zoned_cap;\n\tu32\t\t\tzac_zones_optimal_open;\n\tu32\t\t\tzac_zones_optimal_nonseq;\n\tu32\t\t\tzac_zones_max_open;\n\n\t \n\tstruct ata_cpr_log\t*cpr_log;\n\n\t \n\tu8\t\t\tcdl[ATA_LOG_CDL_SIZE];\n\n\t \n\tint\t\t\tspdn_cnt;\n\t \n\tstruct ata_ering\tering;\n};\n\n \n#define ATA_DEVICE_CLEAR_BEGIN\t\toffsetof(struct ata_device, n_sectors)\n#define ATA_DEVICE_CLEAR_END\t\toffsetof(struct ata_device, ering)\n\nstruct ata_eh_info {\n\tstruct ata_device\t*dev;\t\t \n\tu32\t\t\tserror;\t\t \n\tunsigned int\t\terr_mask;\t \n\tunsigned int\t\taction;\t\t \n\tunsigned int\t\tdev_action[ATA_MAX_DEVICES];  \n\tunsigned int\t\tflags;\t\t \n\n\tunsigned int\t\tprobe_mask;\n\n\tchar\t\t\tdesc[ATA_EH_DESC_LEN];\n\tint\t\t\tdesc_len;\n};\n\nstruct ata_eh_context {\n\tstruct ata_eh_info\ti;\n\tint\t\t\ttries[ATA_MAX_DEVICES];\n\tint\t\t\tcmd_timeout_idx[ATA_MAX_DEVICES]\n\t\t\t\t\t       [ATA_EH_CMD_TIMEOUT_TABLE_SIZE];\n\tunsigned int\t\tclasses[ATA_MAX_DEVICES];\n\tunsigned int\t\tdid_probe_mask;\n\tunsigned int\t\tunloaded_mask;\n\tunsigned int\t\tsaved_ncq_enabled;\n\tu8\t\t\tsaved_xfer_mode[ATA_MAX_DEVICES];\n\t \n\tunsigned long\t\tlast_reset;\n};\n\nstruct ata_acpi_drive\n{\n\tu32 pio;\n\tu32 dma;\n} __packed;\n\nstruct ata_acpi_gtm {\n\tstruct ata_acpi_drive drive[2];\n\tu32 flags;\n} __packed;\n\nstruct ata_link {\n\tstruct ata_port\t\t*ap;\n\tint\t\t\tpmp;\t\t \n\n\tstruct device\t\ttdev;\n\tunsigned int\t\tactive_tag;\t \n\tu32\t\t\tsactive;\t \n\n\tunsigned int\t\tflags;\t\t \n\n\tu32\t\t\tsaved_scontrol;\t \n\tunsigned int\t\thw_sata_spd_limit;\n\tunsigned int\t\tsata_spd_limit;\n\tunsigned int\t\tsata_spd;\t \n\tenum ata_lpm_policy\tlpm_policy;\n\n\t \n\tstruct ata_eh_info\teh_info;\n\t \n\tstruct ata_eh_context\teh_context;\n\n\tstruct ata_device\tdevice[ATA_MAX_DEVICES];\n\n\tunsigned long\t\tlast_lpm_change;  \n};\n#define ATA_LINK_CLEAR_BEGIN\t\toffsetof(struct ata_link, active_tag)\n#define ATA_LINK_CLEAR_END\t\toffsetof(struct ata_link, device[0])\n\nstruct ata_port {\n\tstruct Scsi_Host\t*scsi_host;  \n\tstruct ata_port_operations *ops;\n\tspinlock_t\t\t*lock;\n\t \n\tunsigned long\t\tflags;\t \n\t \n\tunsigned int\t\tpflags;  \n\tunsigned int\t\tprint_id;  \n\tunsigned int            local_port_no;  \n\tunsigned int\t\tport_no;  \n\n#ifdef CONFIG_ATA_SFF\n\tstruct ata_ioports\tioaddr;\t \n\tu8\t\t\tctl;\t \n\tu8\t\t\tlast_ctl;\t \n\tstruct ata_link*\tsff_pio_task_link;  \n\tstruct delayed_work\tsff_pio_task;\n#ifdef CONFIG_ATA_BMDMA\n\tstruct ata_bmdma_prd\t*bmdma_prd;\t \n\tdma_addr_t\t\tbmdma_prd_dma;\t \n#endif  \n#endif  \n\n\tunsigned int\t\tpio_mask;\n\tunsigned int\t\tmwdma_mask;\n\tunsigned int\t\tudma_mask;\n\tunsigned int\t\tcbl;\t \n\n\tstruct ata_queued_cmd\tqcmd[ATA_MAX_QUEUE + 1];\n\tu64\t\t\tqc_active;\n\tint\t\t\tnr_active_links;  \n\n\tstruct ata_link\t\tlink;\t\t \n\tstruct ata_link\t\t*slave_link;\t \n\n\tint\t\t\tnr_pmp_links;\t \n\tstruct ata_link\t\t*pmp_link;\t \n\tstruct ata_link\t\t*excl_link;\t \n\n\tstruct ata_port_stats\tstats;\n\tstruct ata_host\t\t*host;\n\tstruct device \t\t*dev;\n\tstruct device\t\ttdev;\n\n\tstruct mutex\t\tscsi_scan_mutex;\n\tstruct delayed_work\thotplug_task;\n\tstruct delayed_work\tscsi_rescan_task;\n\n\tunsigned int\t\thsm_task_state;\n\n\tstruct list_head\teh_done_q;\n\twait_queue_head_t\teh_wait_q;\n\tint\t\t\teh_tries;\n\tstruct completion\tpark_req_pending;\n\n\tpm_message_t\t\tpm_mesg;\n\tenum ata_lpm_policy\ttarget_lpm_policy;\n\n\tstruct timer_list\tfastdrain_timer;\n\tunsigned int\t\tfastdrain_cnt;\n\n\tasync_cookie_t\t\tcookie;\n\n\tint\t\t\tem_message_type;\n\tvoid\t\t\t*private_data;\n\n#ifdef CONFIG_ATA_ACPI\n\tstruct ata_acpi_gtm\t__acpi_init_gtm;  \n#endif\n\t \n\tu8\t\t\t*ncq_sense_buf;\n\tu8\t\t\tsector_buf[ATA_SECT_SIZE] ____cacheline_aligned;\n};\n\n \n#define ATA_OP_NULL\t\t(void *)(unsigned long)(-ENOENT)\n\nstruct ata_port_operations {\n\t \n\tint (*qc_defer)(struct ata_queued_cmd *qc);\n\tint (*check_atapi_dma)(struct ata_queued_cmd *qc);\n\tenum ata_completion_errors (*qc_prep)(struct ata_queued_cmd *qc);\n\tunsigned int (*qc_issue)(struct ata_queued_cmd *qc);\n\tvoid (*qc_fill_rtf)(struct ata_queued_cmd *qc);\n\tvoid (*qc_ncq_fill_rtf)(struct ata_port *ap, u64 done_mask);\n\n\t \n\tint  (*cable_detect)(struct ata_port *ap);\n\tunsigned int (*mode_filter)(struct ata_device *dev, unsigned int xfer_mask);\n\tvoid (*set_piomode)(struct ata_port *ap, struct ata_device *dev);\n\tvoid (*set_dmamode)(struct ata_port *ap, struct ata_device *dev);\n\tint  (*set_mode)(struct ata_link *link, struct ata_device **r_failed_dev);\n\tunsigned int (*read_id)(struct ata_device *dev, struct ata_taskfile *tf,\n\t\t\t\t__le16 *id);\n\n\tvoid (*dev_config)(struct ata_device *dev);\n\n\tvoid (*freeze)(struct ata_port *ap);\n\tvoid (*thaw)(struct ata_port *ap);\n\tata_prereset_fn_t\tprereset;\n\tata_reset_fn_t\t\tsoftreset;\n\tata_reset_fn_t\t\thardreset;\n\tata_postreset_fn_t\tpostreset;\n\tata_prereset_fn_t\tpmp_prereset;\n\tata_reset_fn_t\t\tpmp_softreset;\n\tata_reset_fn_t\t\tpmp_hardreset;\n\tata_postreset_fn_t\tpmp_postreset;\n\tvoid (*error_handler)(struct ata_port *ap);\n\tvoid (*lost_interrupt)(struct ata_port *ap);\n\tvoid (*post_internal_cmd)(struct ata_queued_cmd *qc);\n\tvoid (*sched_eh)(struct ata_port *ap);\n\tvoid (*end_eh)(struct ata_port *ap);\n\n\t \n\tint  (*scr_read)(struct ata_link *link, unsigned int sc_reg, u32 *val);\n\tint  (*scr_write)(struct ata_link *link, unsigned int sc_reg, u32 val);\n\tvoid (*pmp_attach)(struct ata_port *ap);\n\tvoid (*pmp_detach)(struct ata_port *ap);\n\tint  (*set_lpm)(struct ata_link *link, enum ata_lpm_policy policy,\n\t\t\tunsigned hints);\n\n\t \n\tint  (*port_suspend)(struct ata_port *ap, pm_message_t mesg);\n\tint  (*port_resume)(struct ata_port *ap);\n\tint  (*port_start)(struct ata_port *ap);\n\tvoid (*port_stop)(struct ata_port *ap);\n\tvoid (*host_stop)(struct ata_host *host);\n\n#ifdef CONFIG_ATA_SFF\n\t \n\tvoid (*sff_dev_select)(struct ata_port *ap, unsigned int device);\n\tvoid (*sff_set_devctl)(struct ata_port *ap, u8 ctl);\n\tu8   (*sff_check_status)(struct ata_port *ap);\n\tu8   (*sff_check_altstatus)(struct ata_port *ap);\n\tvoid (*sff_tf_load)(struct ata_port *ap, const struct ata_taskfile *tf);\n\tvoid (*sff_tf_read)(struct ata_port *ap, struct ata_taskfile *tf);\n\tvoid (*sff_exec_command)(struct ata_port *ap,\n\t\t\t\t const struct ata_taskfile *tf);\n\tunsigned int (*sff_data_xfer)(struct ata_queued_cmd *qc,\n\t\t\tunsigned char *buf, unsigned int buflen, int rw);\n\tvoid (*sff_irq_on)(struct ata_port *);\n\tbool (*sff_irq_check)(struct ata_port *);\n\tvoid (*sff_irq_clear)(struct ata_port *);\n\tvoid (*sff_drain_fifo)(struct ata_queued_cmd *qc);\n\n#ifdef CONFIG_ATA_BMDMA\n\tvoid (*bmdma_setup)(struct ata_queued_cmd *qc);\n\tvoid (*bmdma_start)(struct ata_queued_cmd *qc);\n\tvoid (*bmdma_stop)(struct ata_queued_cmd *qc);\n\tu8   (*bmdma_status)(struct ata_port *ap);\n#endif  \n#endif  \n\n\tssize_t (*em_show)(struct ata_port *ap, char *buf);\n\tssize_t (*em_store)(struct ata_port *ap, const char *message,\n\t\t\t    size_t size);\n\tssize_t (*sw_activity_show)(struct ata_device *dev, char *buf);\n\tssize_t (*sw_activity_store)(struct ata_device *dev,\n\t\t\t\t     enum sw_activity val);\n\tssize_t (*transmit_led_message)(struct ata_port *ap, u32 state,\n\t\t\t\t\tssize_t size);\n\n\t \n\tconst struct ata_port_operations\t*inherits;\n};\n\nstruct ata_port_info {\n\tunsigned long\t\tflags;\n\tunsigned long\t\tlink_flags;\n\tunsigned int\t\tpio_mask;\n\tunsigned int\t\tmwdma_mask;\n\tunsigned int\t\tudma_mask;\n\tstruct ata_port_operations *port_ops;\n\tvoid \t\t\t*private_data;\n};\n\nstruct ata_timing {\n\tunsigned short mode;\t\t \n\tunsigned short setup;\t\t \n\tunsigned short act8b;\t\t \n\tunsigned short rec8b;\t\t \n\tunsigned short cyc8b;\t\t \n\tunsigned short active;\t\t \n\tunsigned short recover;\t\t \n\tunsigned short dmack_hold;\t \n\tunsigned short cycle;\t\t \n\tunsigned short udma;\t\t \n};\n\n \nextern struct ata_port_operations ata_dummy_port_ops;\nextern const struct ata_port_info ata_dummy_port_info;\n\nstatic inline bool ata_is_atapi(u8 prot)\n{\n\treturn prot & ATA_PROT_FLAG_ATAPI;\n}\n\nstatic inline bool ata_is_pio(u8 prot)\n{\n\treturn prot & ATA_PROT_FLAG_PIO;\n}\n\nstatic inline bool ata_is_dma(u8 prot)\n{\n\treturn prot & ATA_PROT_FLAG_DMA;\n}\n\nstatic inline bool ata_is_ncq(u8 prot)\n{\n\treturn prot & ATA_PROT_FLAG_NCQ;\n}\n\nstatic inline bool ata_is_data(u8 prot)\n{\n\treturn prot & (ATA_PROT_FLAG_PIO | ATA_PROT_FLAG_DMA);\n}\n\nstatic inline int is_multi_taskfile(struct ata_taskfile *tf)\n{\n\treturn (tf->command == ATA_CMD_READ_MULTI) ||\n\t       (tf->command == ATA_CMD_WRITE_MULTI) ||\n\t       (tf->command == ATA_CMD_READ_MULTI_EXT) ||\n\t       (tf->command == ATA_CMD_WRITE_MULTI_EXT) ||\n\t       (tf->command == ATA_CMD_WRITE_MULTI_FUA_EXT);\n}\n\nstatic inline int ata_port_is_dummy(struct ata_port *ap)\n{\n\treturn ap->ops == &ata_dummy_port_ops;\n}\n\nstatic inline bool ata_port_is_frozen(const struct ata_port *ap)\n{\n\treturn ap->pflags & ATA_PFLAG_FROZEN;\n}\n\nextern int ata_std_prereset(struct ata_link *link, unsigned long deadline);\nextern int ata_wait_after_reset(struct ata_link *link, unsigned long deadline,\n\t\t\t\tint (*check_ready)(struct ata_link *link));\nextern int sata_std_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t      unsigned long deadline);\nextern void ata_std_postreset(struct ata_link *link, unsigned int *classes);\n\nextern struct ata_host *ata_host_alloc(struct device *dev, int max_ports);\nextern struct ata_host *ata_host_alloc_pinfo(struct device *dev,\n\t\t\tconst struct ata_port_info * const * ppi, int n_ports);\nextern void ata_host_get(struct ata_host *host);\nextern void ata_host_put(struct ata_host *host);\nextern int ata_host_start(struct ata_host *host);\nextern int ata_host_register(struct ata_host *host,\n\t\t\t     const struct scsi_host_template *sht);\nextern int ata_host_activate(struct ata_host *host, int irq,\n\t\t\t     irq_handler_t irq_handler, unsigned long irq_flags,\n\t\t\t     const struct scsi_host_template *sht);\nextern void ata_host_detach(struct ata_host *host);\nextern void ata_host_init(struct ata_host *, struct device *, struct ata_port_operations *);\nextern int ata_scsi_detect(struct scsi_host_template *sht);\nextern int ata_scsi_ioctl(struct scsi_device *dev, unsigned int cmd,\n\t\t\t  void __user *arg);\n#ifdef CONFIG_COMPAT\n#define ATA_SCSI_COMPAT_IOCTL .compat_ioctl = ata_scsi_ioctl,\n#else\n#define ATA_SCSI_COMPAT_IOCTL  \n#endif\nextern int ata_scsi_queuecmd(struct Scsi_Host *h, struct scsi_cmnd *cmd);\n#if IS_REACHABLE(CONFIG_ATA)\nbool ata_scsi_dma_need_drain(struct request *rq);\n#else\n#define ata_scsi_dma_need_drain NULL\n#endif\nextern int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *dev,\n\t\t\t    unsigned int cmd, void __user *arg);\nextern bool ata_link_online(struct ata_link *link);\nextern bool ata_link_offline(struct ata_link *link);\n#ifdef CONFIG_PM\nextern void ata_host_suspend(struct ata_host *host, pm_message_t mesg);\nextern void ata_host_resume(struct ata_host *host);\nextern void ata_sas_port_suspend(struct ata_port *ap);\nextern void ata_sas_port_resume(struct ata_port *ap);\n#else\nstatic inline void ata_sas_port_suspend(struct ata_port *ap)\n{\n}\nstatic inline void ata_sas_port_resume(struct ata_port *ap)\n{\n}\n#endif\nextern int ata_ratelimit(void);\nextern void ata_msleep(struct ata_port *ap, unsigned int msecs);\nextern u32 ata_wait_register(struct ata_port *ap, void __iomem *reg, u32 mask,\n\t\t\t     u32 val, unsigned int interval, unsigned int timeout);\nextern int atapi_cmd_type(u8 opcode);\nextern unsigned int ata_pack_xfermask(unsigned int pio_mask,\n\t\t\t\t      unsigned int mwdma_mask,\n\t\t\t\t      unsigned int udma_mask);\nextern void ata_unpack_xfermask(unsigned int xfer_mask,\n\t\t\t\tunsigned int *pio_mask,\n\t\t\t\tunsigned int *mwdma_mask,\n\t\t\t\tunsigned int *udma_mask);\nextern u8 ata_xfer_mask2mode(unsigned int xfer_mask);\nextern unsigned int ata_xfer_mode2mask(u8 xfer_mode);\nextern int ata_xfer_mode2shift(u8 xfer_mode);\nextern const char *ata_mode_string(unsigned int xfer_mask);\nextern unsigned int ata_id_xfermask(const u16 *id);\nextern int ata_std_qc_defer(struct ata_queued_cmd *qc);\nextern enum ata_completion_errors ata_noop_qc_prep(struct ata_queued_cmd *qc);\nextern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,\n\t\t unsigned int n_elem);\nextern unsigned int ata_dev_classify(const struct ata_taskfile *tf);\nextern unsigned int ata_port_classify(struct ata_port *ap,\n\t\t\t\t      const struct ata_taskfile *tf);\nextern void ata_dev_disable(struct ata_device *adev);\nextern void ata_id_string(const u16 *id, unsigned char *s,\n\t\t\t  unsigned int ofs, unsigned int len);\nextern void ata_id_c_string(const u16 *id, unsigned char *s,\n\t\t\t    unsigned int ofs, unsigned int len);\nextern unsigned int ata_do_dev_read_id(struct ata_device *dev,\n\t\t\t\t       struct ata_taskfile *tf, __le16 *id);\nextern void ata_qc_complete(struct ata_queued_cmd *qc);\nextern u64 ata_qc_get_active(struct ata_port *ap);\nextern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd);\nextern int ata_std_bios_param(struct scsi_device *sdev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      sector_t capacity, int geom[]);\nextern void ata_scsi_unlock_native_capacity(struct scsi_device *sdev);\nextern int ata_scsi_slave_alloc(struct scsi_device *sdev);\nextern int ata_scsi_slave_config(struct scsi_device *sdev);\nextern void ata_scsi_slave_destroy(struct scsi_device *sdev);\nextern int ata_scsi_change_queue_depth(struct scsi_device *sdev,\n\t\t\t\t       int queue_depth);\nextern int ata_change_queue_depth(struct ata_port *ap, struct scsi_device *sdev,\n\t\t\t\t  int queue_depth);\nextern struct ata_device *ata_dev_pair(struct ata_device *adev);\nextern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);\nextern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);\nextern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);\n\n \n#ifdef CONFIG_SATA_HOST\nextern const unsigned int sata_deb_timing_normal[];\nextern const unsigned int sata_deb_timing_hotplug[];\nextern const unsigned int sata_deb_timing_long[];\n\nstatic inline const unsigned int *\nsata_ehc_deb_timing(struct ata_eh_context *ehc)\n{\n\tif (ehc->i.flags & ATA_EHI_HOTPLUGGED)\n\t\treturn sata_deb_timing_hotplug;\n\telse\n\t\treturn sata_deb_timing_normal;\n}\n\nextern int sata_scr_valid(struct ata_link *link);\nextern int sata_scr_read(struct ata_link *link, int reg, u32 *val);\nextern int sata_scr_write(struct ata_link *link, int reg, u32 val);\nextern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);\nextern int sata_set_spd(struct ata_link *link);\nextern int sata_link_hardreset(struct ata_link *link,\n\t\t\tconst unsigned int *timing, unsigned long deadline,\n\t\t\tbool *online, int (*check_ready)(struct ata_link *));\nextern int sata_link_resume(struct ata_link *link, const unsigned int *params,\n\t\t\t    unsigned long deadline);\nextern int ata_eh_read_sense_success_ncq_log(struct ata_link *link);\nextern void ata_eh_analyze_ncq_error(struct ata_link *link);\n#else\nstatic inline const unsigned int *\nsata_ehc_deb_timing(struct ata_eh_context *ehc)\n{\n\treturn NULL;\n}\nstatic inline int sata_scr_valid(struct ata_link *link) { return 0; }\nstatic inline int sata_scr_read(struct ata_link *link, int reg, u32 *val)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int sata_scr_write(struct ata_link *link, int reg, u32 val)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int sata_scr_write_flush(struct ata_link *link, int reg, u32 val)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int sata_set_spd(struct ata_link *link) { return -EOPNOTSUPP; }\nstatic inline int sata_link_hardreset(struct ata_link *link,\n\t\t\t\t      const unsigned int *timing,\n\t\t\t\t      unsigned long deadline,\n\t\t\t\t      bool *online,\n\t\t\t\t      int (*check_ready)(struct ata_link *))\n{\n\tif (online)\n\t\t*online = false;\n\treturn -EOPNOTSUPP;\n}\nstatic inline int sata_link_resume(struct ata_link *link,\n\t\t\t\t   const unsigned int *params,\n\t\t\t\t   unsigned long deadline)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int ata_eh_read_sense_success_ncq_log(struct ata_link *link)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline void ata_eh_analyze_ncq_error(struct ata_link *link) { }\n#endif\nextern int sata_link_debounce(struct ata_link *link,\n\t\t\t      const unsigned int *params, unsigned long deadline);\nextern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,\n\t\t\t     bool spm_wakeup);\nextern int ata_slave_link_init(struct ata_port *ap);\nextern struct ata_port *ata_sas_port_alloc(struct ata_host *,\n\t\t\t\t\t   struct ata_port_info *, struct Scsi_Host *);\nextern void ata_port_probe(struct ata_port *ap);\nextern int ata_sas_tport_add(struct device *parent, struct ata_port *ap);\nextern void ata_sas_tport_delete(struct ata_port *ap);\nextern int ata_sas_slave_configure(struct scsi_device *, struct ata_port *);\nextern int ata_sas_queuecmd(struct scsi_cmnd *cmd, struct ata_port *ap);\nextern void ata_tf_to_fis(const struct ata_taskfile *tf,\n\t\t\t  u8 pmp, int is_cmd, u8 *fis);\nextern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);\nextern int ata_qc_complete_multiple(struct ata_port *ap, u64 qc_active);\nextern bool sata_lpm_ignore_phy_events(struct ata_link *link);\nextern int sata_async_notification(struct ata_port *ap);\n\nextern int ata_cable_40wire(struct ata_port *ap);\nextern int ata_cable_80wire(struct ata_port *ap);\nextern int ata_cable_sata(struct ata_port *ap);\nextern int ata_cable_ignore(struct ata_port *ap);\nextern int ata_cable_unknown(struct ata_port *ap);\n\n \nextern unsigned int ata_pio_need_iordy(const struct ata_device *);\nextern u8 ata_timing_cycle2mode(unsigned int xfer_shift, int cycle);\n\n \n#ifdef CONFIG_PCI\nstruct pci_dev;\n\nstruct pci_bits {\n\tunsigned int\t\treg;\t \n\tunsigned int\t\twidth;\t \n\tunsigned long\t\tmask;\n\tunsigned long\t\tval;\n};\n\nextern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);\nextern void ata_pci_shutdown_one(struct pci_dev *pdev);\nextern void ata_pci_remove_one(struct pci_dev *pdev);\n\n#ifdef CONFIG_PM\nextern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);\nextern int __must_check ata_pci_device_do_resume(struct pci_dev *pdev);\nextern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);\nextern int ata_pci_device_resume(struct pci_dev *pdev);\n#endif  \n#endif  \n\nstruct platform_device;\n\nextern void ata_platform_remove_one(struct platform_device *pdev);\n\n \n#ifdef CONFIG_ATA_ACPI\nstatic inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)\n{\n\tif (ap->pflags & ATA_PFLAG_INIT_GTM_VALID)\n\t\treturn &ap->__acpi_init_gtm;\n\treturn NULL;\n}\nint ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm);\nint ata_acpi_gtm(struct ata_port *ap, struct ata_acpi_gtm *stm);\nunsigned int ata_acpi_gtm_xfermask(struct ata_device *dev,\n\t\t\t\t   const struct ata_acpi_gtm *gtm);\nint ata_acpi_cbl_80wire(struct ata_port *ap, const struct ata_acpi_gtm *gtm);\n#else\nstatic inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)\n{\n\treturn NULL;\n}\n\nstatic inline int ata_acpi_stm(const struct ata_port *ap,\n\t\t\t       struct ata_acpi_gtm *stm)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int ata_acpi_gtm(const struct ata_port *ap,\n\t\t\t       struct ata_acpi_gtm *stm)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline unsigned int ata_acpi_gtm_xfermask(struct ata_device *dev,\n\t\t\t\t\tconst struct ata_acpi_gtm *gtm)\n{\n\treturn 0;\n}\n\nstatic inline int ata_acpi_cbl_80wire(struct ata_port *ap,\n\t\t\t\t      const struct ata_acpi_gtm *gtm)\n{\n\treturn 0;\n}\n#endif\n\n \nextern void ata_port_schedule_eh(struct ata_port *ap);\nextern void ata_port_wait_eh(struct ata_port *ap);\nextern int ata_link_abort(struct ata_link *link);\nextern int ata_port_abort(struct ata_port *ap);\nextern int ata_port_freeze(struct ata_port *ap);\n\nextern void ata_eh_freeze_port(struct ata_port *ap);\nextern void ata_eh_thaw_port(struct ata_port *ap);\n\nextern void ata_eh_qc_complete(struct ata_queued_cmd *qc);\nextern void ata_eh_qc_retry(struct ata_queued_cmd *qc);\n\nextern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,\n\t\t      ata_reset_fn_t softreset, ata_reset_fn_t hardreset,\n\t\t      ata_postreset_fn_t postreset);\nextern void ata_std_error_handler(struct ata_port *ap);\nextern void ata_std_sched_eh(struct ata_port *ap);\nextern void ata_std_end_eh(struct ata_port *ap);\nextern int ata_link_nr_enabled(struct ata_link *link);\n\n \nextern const struct ata_port_operations ata_base_port_ops;\nextern const struct ata_port_operations sata_port_ops;\nextern const struct attribute_group *ata_common_sdev_groups[];\n\n \n#define __ATA_BASE_SHT(drv_name)\t\t\t\t\\\n\t.module\t\t\t= THIS_MODULE,\t\t\t\\\n\t.name\t\t\t= drv_name,\t\t\t\\\n\t.ioctl\t\t\t= ata_scsi_ioctl,\t\t\\\n\tATA_SCSI_COMPAT_IOCTL\t\t\t\t\t\\\n\t.queuecommand\t\t= ata_scsi_queuecmd,\t\t\\\n\t.dma_need_drain\t\t= ata_scsi_dma_need_drain,\t\\\n\t.this_id\t\t= ATA_SHT_THIS_ID,\t\t\\\n\t.emulated\t\t= ATA_SHT_EMULATED,\t\t\\\n\t.proc_name\t\t= drv_name,\t\t\t\\\n\t.slave_alloc\t\t= ata_scsi_slave_alloc,\t\t\\\n\t.slave_destroy\t\t= ata_scsi_slave_destroy,\t\\\n\t.bios_param\t\t= ata_std_bios_param,\t\t\\\n\t.unlock_native_capacity\t= ata_scsi_unlock_native_capacity,\\\n\t.max_sectors\t\t= ATA_MAX_SECTORS_LBA48\n\n#define ATA_SUBBASE_SHT(drv_name)\t\t\t\t\\\n\t__ATA_BASE_SHT(drv_name),\t\t\t\t\\\n\t.can_queue\t\t= ATA_DEF_QUEUE,\t\t\\\n\t.tag_alloc_policy\t= BLK_TAG_ALLOC_RR,\t\t\\\n\t.slave_configure\t= ata_scsi_slave_config\n\n#define ATA_SUBBASE_SHT_QD(drv_name, drv_qd)\t\t\t\\\n\t__ATA_BASE_SHT(drv_name),\t\t\t\t\\\n\t.can_queue\t\t= drv_qd,\t\t\t\\\n\t.tag_alloc_policy\t= BLK_TAG_ALLOC_RR,\t\t\\\n\t.slave_configure\t= ata_scsi_slave_config\n\n#define ATA_BASE_SHT(drv_name)\t\t\t\t\t\\\n\tATA_SUBBASE_SHT(drv_name),\t\t\t\t\\\n\t.sdev_groups\t\t= ata_common_sdev_groups\n\n#ifdef CONFIG_SATA_HOST\nextern const struct attribute_group *ata_ncq_sdev_groups[];\n\n#define ATA_NCQ_SHT(drv_name)\t\t\t\t\t\\\n\tATA_SUBBASE_SHT(drv_name),\t\t\t\t\\\n\t.sdev_groups\t\t= ata_ncq_sdev_groups,\t\t\\\n\t.change_queue_depth\t= ata_scsi_change_queue_depth\n\n#define ATA_NCQ_SHT_QD(drv_name, drv_qd)\t\t\t\\\n\tATA_SUBBASE_SHT_QD(drv_name, drv_qd),\t\t\t\\\n\t.sdev_groups\t\t= ata_ncq_sdev_groups,\t\t\\\n\t.change_queue_depth\t= ata_scsi_change_queue_depth\n#endif\n\n \n#ifdef CONFIG_SATA_PMP\nstatic inline bool sata_pmp_supported(struct ata_port *ap)\n{\n\treturn ap->flags & ATA_FLAG_PMP;\n}\n\nstatic inline bool sata_pmp_attached(struct ata_port *ap)\n{\n\treturn ap->nr_pmp_links != 0;\n}\n\nstatic inline bool ata_is_host_link(const struct ata_link *link)\n{\n\treturn link == &link->ap->link || link == link->ap->slave_link;\n}\n#else  \nstatic inline bool sata_pmp_supported(struct ata_port *ap)\n{\n\treturn false;\n}\n\nstatic inline bool sata_pmp_attached(struct ata_port *ap)\n{\n\treturn false;\n}\n\nstatic inline bool ata_is_host_link(const struct ata_link *link)\n{\n\treturn true;\n}\n#endif  \n\nstatic inline int sata_srst_pmp(struct ata_link *link)\n{\n\tif (sata_pmp_supported(link->ap) && ata_is_host_link(link))\n\t\treturn SATA_PMP_CTRL_PORT;\n\treturn link->pmp;\n}\n\n#define ata_port_printk(level, ap, fmt, ...)\t\t\t\\\n\tpr_ ## level (\"ata%u: \" fmt, (ap)->print_id, ##__VA_ARGS__)\n\n#define ata_port_err(ap, fmt, ...)\t\t\t\t\\\n\tata_port_printk(err, ap, fmt, ##__VA_ARGS__)\n#define ata_port_warn(ap, fmt, ...)\t\t\t\t\\\n\tata_port_printk(warn, ap, fmt, ##__VA_ARGS__)\n#define ata_port_notice(ap, fmt, ...)\t\t\t\t\\\n\tata_port_printk(notice, ap, fmt, ##__VA_ARGS__)\n#define ata_port_info(ap, fmt, ...)\t\t\t\t\\\n\tata_port_printk(info, ap, fmt, ##__VA_ARGS__)\n#define ata_port_dbg(ap, fmt, ...)\t\t\t\t\\\n\tata_port_printk(debug, ap, fmt, ##__VA_ARGS__)\n\n#define ata_link_printk(level, link, fmt, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (sata_pmp_attached((link)->ap) ||\t\t\t\\\n\t    (link)->ap->slave_link)\t\t\t\t\\\n\t\tpr_ ## level (\"ata%u.%02u: \" fmt,\t\t\\\n\t\t\t      (link)->ap->print_id,\t\t\\\n\t\t\t      (link)->pmp,\t\t\t\\\n\t\t\t      ##__VA_ARGS__);\t\t\t\\\n        else\t\t\t\t\t\t\t\\\n\t\tpr_ ## level (\"ata%u: \" fmt,\t\t\t\\\n\t\t\t      (link)->ap->print_id,\t\t\\\n\t\t\t      ##__VA_ARGS__);\t\t\t\\\n} while (0)\n\n#define ata_link_err(link, fmt, ...)\t\t\t\t\\\n\tata_link_printk(err, link, fmt, ##__VA_ARGS__)\n#define ata_link_warn(link, fmt, ...)\t\t\t\t\\\n\tata_link_printk(warn, link, fmt, ##__VA_ARGS__)\n#define ata_link_notice(link, fmt, ...)\t\t\t\t\\\n\tata_link_printk(notice, link, fmt, ##__VA_ARGS__)\n#define ata_link_info(link, fmt, ...)\t\t\t\t\\\n\tata_link_printk(info, link, fmt, ##__VA_ARGS__)\n#define ata_link_dbg(link, fmt, ...)\t\t\t\t\\\n\tata_link_printk(debug, link, fmt, ##__VA_ARGS__)\n\n#define ata_dev_printk(level, dev, fmt, ...)\t\t\t\\\n        pr_ ## level(\"ata%u.%02u: \" fmt,\t\t\t\\\n               (dev)->link->ap->print_id,\t\t\t\\\n\t       (dev)->link->pmp + (dev)->devno,\t\t\t\\\n\t       ##__VA_ARGS__)\n\n#define ata_dev_err(dev, fmt, ...)\t\t\t\t\\\n\tata_dev_printk(err, dev, fmt, ##__VA_ARGS__)\n#define ata_dev_warn(dev, fmt, ...)\t\t\t\t\\\n\tata_dev_printk(warn, dev, fmt, ##__VA_ARGS__)\n#define ata_dev_notice(dev, fmt, ...)\t\t\t\t\\\n\tata_dev_printk(notice, dev, fmt, ##__VA_ARGS__)\n#define ata_dev_info(dev, fmt, ...)\t\t\t\t\\\n\tata_dev_printk(info, dev, fmt, ##__VA_ARGS__)\n#define ata_dev_dbg(dev, fmt, ...)\t\t\t\t\\\n\tata_dev_printk(debug, dev, fmt, ##__VA_ARGS__)\n\nvoid ata_print_version(const struct device *dev, const char *version);\n\n \nextern __printf(2, 3)\nvoid __ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...);\nextern __printf(2, 3)\nvoid ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...);\nextern void ata_ehi_clear_desc(struct ata_eh_info *ehi);\n\nstatic inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)\n{\n\tehi->probe_mask |= (1 << ATA_MAX_DEVICES) - 1;\n\tehi->flags |= ATA_EHI_HOTPLUGGED;\n\tehi->action |= ATA_EH_RESET | ATA_EH_ENABLE_LINK;\n\tehi->err_mask |= AC_ERR_ATA_BUS;\n}\n\n \nextern __printf(2, 3)\nvoid ata_port_desc(struct ata_port *ap, const char *fmt, ...);\n#ifdef CONFIG_PCI\nextern void ata_port_pbar_desc(struct ata_port *ap, int bar, ssize_t offset,\n\t\t\t       const char *name);\n#endif\n\nstatic inline bool ata_tag_internal(unsigned int tag)\n{\n\treturn tag == ATA_TAG_INTERNAL;\n}\n\nstatic inline bool ata_tag_valid(unsigned int tag)\n{\n\treturn tag < ATA_MAX_QUEUE || ata_tag_internal(tag);\n}\n\n#define __ata_qc_for_each(ap, qc, tag, max_tag, fn)\t\t\\\n\tfor ((tag) = 0; (tag) < (max_tag) &&\t\t\t\\\n\t     ({ qc = fn((ap), (tag)); 1; }); (tag)++)\t\t\\\n\n \n#define ata_qc_for_each_raw(ap, qc, tag)\t\t\t\t\t\\\n\t__ata_qc_for_each(ap, qc, tag, ATA_MAX_QUEUE, __ata_qc_from_tag)\n\n \n#define ata_qc_for_each(ap, qc, tag)\t\t\t\t\t\\\n\t__ata_qc_for_each(ap, qc, tag, ATA_MAX_QUEUE, ata_qc_from_tag)\n\n \n#define ata_qc_for_each_with_internal(ap, qc, tag)\t\t\t\\\n\t__ata_qc_for_each(ap, qc, tag, ATA_MAX_QUEUE + 1, ata_qc_from_tag)\n\n \nstatic inline unsigned int ata_class_enabled(unsigned int class)\n{\n\treturn class == ATA_DEV_ATA || class == ATA_DEV_ATAPI ||\n\t\tclass == ATA_DEV_PMP || class == ATA_DEV_SEMB ||\n\t\tclass == ATA_DEV_ZAC;\n}\n\nstatic inline unsigned int ata_class_disabled(unsigned int class)\n{\n\treturn class == ATA_DEV_ATA_UNSUP || class == ATA_DEV_ATAPI_UNSUP ||\n\t\tclass == ATA_DEV_PMP_UNSUP || class == ATA_DEV_SEMB_UNSUP ||\n\t\tclass == ATA_DEV_ZAC_UNSUP;\n}\n\nstatic inline unsigned int ata_class_absent(unsigned int class)\n{\n\treturn !ata_class_enabled(class) && !ata_class_disabled(class);\n}\n\nstatic inline unsigned int ata_dev_enabled(const struct ata_device *dev)\n{\n\treturn ata_class_enabled(dev->class);\n}\n\nstatic inline unsigned int ata_dev_disabled(const struct ata_device *dev)\n{\n\treturn ata_class_disabled(dev->class);\n}\n\nstatic inline unsigned int ata_dev_absent(const struct ata_device *dev)\n{\n\treturn ata_class_absent(dev->class);\n}\n\n \nstatic inline int ata_link_max_devices(const struct ata_link *link)\n{\n\tif (ata_is_host_link(link) && link->ap->flags & ATA_FLAG_SLAVE_POSS)\n\t\treturn 2;\n\treturn 1;\n}\n\nstatic inline int ata_link_active(struct ata_link *link)\n{\n\treturn ata_tag_valid(link->active_tag) || link->sactive;\n}\n\n \nenum ata_link_iter_mode {\n\tATA_LITER_EDGE,\t\t \n\tATA_LITER_HOST_FIRST,\t \n\tATA_LITER_PMP_FIRST,\t \n};\n\nenum ata_dev_iter_mode {\n\tATA_DITER_ENABLED,\n\tATA_DITER_ENABLED_REVERSE,\n\tATA_DITER_ALL,\n\tATA_DITER_ALL_REVERSE,\n};\n\nextern struct ata_link *ata_link_next(struct ata_link *link,\n\t\t\t\t      struct ata_port *ap,\n\t\t\t\t      enum ata_link_iter_mode mode);\n\nextern struct ata_device *ata_dev_next(struct ata_device *dev,\n\t\t\t\t       struct ata_link *link,\n\t\t\t\t       enum ata_dev_iter_mode mode);\n\n \n#define ata_for_each_link(link, ap, mode) \\\n\tfor ((link) = ata_link_next(NULL, (ap), ATA_LITER_##mode); (link); \\\n\t     (link) = ata_link_next((link), (ap), ATA_LITER_##mode))\n\n#define ata_for_each_dev(dev, link, mode) \\\n\tfor ((dev) = ata_dev_next(NULL, (link), ATA_DITER_##mode); (dev); \\\n\t     (dev) = ata_dev_next((dev), (link), ATA_DITER_##mode))\n\n \nstatic inline bool ata_ncq_supported(struct ata_device *dev)\n{\n\tif (!IS_ENABLED(CONFIG_SATA_HOST))\n\t\treturn false;\n\treturn (dev->flags & (ATA_DFLAG_PIO | ATA_DFLAG_NCQ)) == ATA_DFLAG_NCQ;\n}\n\n \nstatic inline bool ata_ncq_enabled(struct ata_device *dev)\n{\n\treturn ata_ncq_supported(dev) && !(dev->flags & ATA_DFLAG_NCQ_OFF);\n}\n\nstatic inline bool ata_fpdma_dsm_supported(struct ata_device *dev)\n{\n\treturn (dev->flags & ATA_DFLAG_NCQ_SEND_RECV) &&\n\t\t(dev->ncq_send_recv_cmds[ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET] &\n\t\t ATA_LOG_NCQ_SEND_RECV_DSM_TRIM);\n}\n\nstatic inline bool ata_fpdma_read_log_supported(struct ata_device *dev)\n{\n\treturn (dev->flags & ATA_DFLAG_NCQ_SEND_RECV) &&\n\t\t(dev->ncq_send_recv_cmds[ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET] &\n\t\t ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED);\n}\n\nstatic inline bool ata_fpdma_zac_mgmt_in_supported(struct ata_device *dev)\n{\n\treturn (dev->flags & ATA_DFLAG_NCQ_SEND_RECV) &&\n\t\t(dev->ncq_send_recv_cmds[ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET] &\n\t\tATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED);\n}\n\nstatic inline bool ata_fpdma_zac_mgmt_out_supported(struct ata_device *dev)\n{\n\treturn (dev->ncq_non_data_cmds[ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET] &\n\t\tATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT);\n}\n\nstatic inline void ata_qc_set_polling(struct ata_queued_cmd *qc)\n{\n\tqc->tf.ctl |= ATA_NIEN;\n}\n\nstatic inline struct ata_queued_cmd *__ata_qc_from_tag(struct ata_port *ap,\n\t\t\t\t\t\t       unsigned int tag)\n{\n\tif (ata_tag_valid(tag))\n\t\treturn &ap->qcmd[tag];\n\treturn NULL;\n}\n\nstatic inline struct ata_queued_cmd *ata_qc_from_tag(struct ata_port *ap,\n\t\t\t\t\t\t     unsigned int tag)\n{\n\tstruct ata_queued_cmd *qc = __ata_qc_from_tag(ap, tag);\n\n\tif (unlikely(!qc))\n\t\treturn qc;\n\n\tif ((qc->flags & (ATA_QCFLAG_ACTIVE |\n\t\t\t  ATA_QCFLAG_EH)) == ATA_QCFLAG_ACTIVE)\n\t\treturn qc;\n\n\treturn NULL;\n}\n\nstatic inline unsigned int ata_qc_raw_nbytes(struct ata_queued_cmd *qc)\n{\n\treturn qc->nbytes - min(qc->extrabytes, qc->nbytes);\n}\n\nstatic inline void ata_tf_init(struct ata_device *dev, struct ata_taskfile *tf)\n{\n\tmemset(tf, 0, sizeof(*tf));\n\n#ifdef CONFIG_ATA_SFF\n\ttf->ctl = dev->link->ap->ctl;\n#else\n\ttf->ctl = ATA_DEVCTL_OBS;\n#endif\n\tif (dev->devno == 0)\n\t\ttf->device = ATA_DEVICE_OBS;\n\telse\n\t\ttf->device = ATA_DEVICE_OBS | ATA_DEV1;\n}\n\nstatic inline void ata_qc_reinit(struct ata_queued_cmd *qc)\n{\n\tqc->dma_dir = DMA_NONE;\n\tqc->sg = NULL;\n\tqc->flags = 0;\n\tqc->cursg = NULL;\n\tqc->cursg_ofs = 0;\n\tqc->nbytes = qc->extrabytes = qc->curbytes = 0;\n\tqc->n_elem = 0;\n\tqc->err_mask = 0;\n\tqc->sect_size = ATA_SECT_SIZE;\n\n\tata_tf_init(qc->dev, &qc->tf);\n\n\t \n\tqc->result_tf.command = ATA_DRDY;\n\tqc->result_tf.feature = 0;\n}\n\nstatic inline int ata_try_flush_cache(const struct ata_device *dev)\n{\n\treturn ata_id_wcache_enabled(dev->id) ||\n\t       ata_id_has_flush(dev->id) ||\n\t       ata_id_has_flush_ext(dev->id);\n}\n\nstatic inline unsigned int ac_err_mask(u8 status)\n{\n\tif (status & (ATA_BUSY | ATA_DRQ))\n\t\treturn AC_ERR_HSM;\n\tif (status & (ATA_ERR | ATA_DF))\n\t\treturn AC_ERR_DEV;\n\treturn 0;\n}\n\nstatic inline unsigned int __ac_err_mask(u8 status)\n{\n\tunsigned int mask = ac_err_mask(status);\n\tif (mask == 0)\n\t\treturn AC_ERR_OTHER;\n\treturn mask;\n}\n\nstatic inline struct ata_port *ata_shost_to_port(struct Scsi_Host *host)\n{\n\treturn *(struct ata_port **)&host->hostdata[0];\n}\n\nstatic inline int ata_check_ready(u8 status)\n{\n\tif (!(status & ATA_BUSY))\n\t\treturn 1;\n\n\t \n\tif (status == 0xff)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic inline unsigned long ata_deadline(unsigned long from_jiffies,\n\t\t\t\t\t unsigned int timeout_msecs)\n{\n\treturn from_jiffies + msecs_to_jiffies(timeout_msecs);\n}\n\n \n\nstatic inline int ata_using_mwdma(struct ata_device *adev)\n{\n\tif (adev->dma_mode >= XFER_MW_DMA_0 && adev->dma_mode <= XFER_MW_DMA_4)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int ata_using_udma(struct ata_device *adev)\n{\n\tif (adev->dma_mode >= XFER_UDMA_0 && adev->dma_mode <= XFER_UDMA_7)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int ata_dma_enabled(struct ata_device *adev)\n{\n\treturn (adev->dma_mode == 0xFF ? 0 : 1);\n}\n\n \nextern const struct ata_timing *ata_timing_find_mode(u8 xfer_mode);\nextern int ata_timing_compute(struct ata_device *, unsigned short,\n\t\t\t      struct ata_timing *, int, int);\nextern void ata_timing_merge(const struct ata_timing *,\n\t\t\t     const struct ata_timing *, struct ata_timing *,\n\t\t\t     unsigned int);\n\n \n#ifdef CONFIG_SATA_PMP\n\nextern const struct ata_port_operations sata_pmp_port_ops;\n\nextern int sata_pmp_qc_defer_cmd_switch(struct ata_queued_cmd *qc);\nextern void sata_pmp_error_handler(struct ata_port *ap);\n\n#else  \n\n#define sata_pmp_port_ops\t\tsata_port_ops\n#define sata_pmp_qc_defer_cmd_switch\tata_std_qc_defer\n#define sata_pmp_error_handler\t\tata_std_error_handler\n\n#endif  \n\n\n \n#ifdef CONFIG_ATA_SFF\n\nextern const struct ata_port_operations ata_sff_port_ops;\nextern const struct ata_port_operations ata_bmdma32_port_ops;\n\n \n#define ATA_PIO_SHT(drv_name)\t\t\t\t\t\\\n\tATA_BASE_SHT(drv_name),\t\t\t\t\t\\\n\t.sg_tablesize\t\t= LIBATA_MAX_PRD,\t\t\\\n\t.dma_boundary\t\t= ATA_DMA_BOUNDARY\n\nextern void ata_sff_dev_select(struct ata_port *ap, unsigned int device);\nextern u8 ata_sff_check_status(struct ata_port *ap);\nextern void ata_sff_pause(struct ata_port *ap);\nextern void ata_sff_dma_pause(struct ata_port *ap);\nextern int ata_sff_wait_ready(struct ata_link *link, unsigned long deadline);\nextern void ata_sff_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);\nextern void ata_sff_tf_read(struct ata_port *ap, struct ata_taskfile *tf);\nextern void ata_sff_exec_command(struct ata_port *ap,\n\t\t\t\t const struct ata_taskfile *tf);\nextern unsigned int ata_sff_data_xfer(struct ata_queued_cmd *qc,\n\t\t\tunsigned char *buf, unsigned int buflen, int rw);\nextern unsigned int ata_sff_data_xfer32(struct ata_queued_cmd *qc,\n\t\t\tunsigned char *buf, unsigned int buflen, int rw);\nextern void ata_sff_irq_on(struct ata_port *ap);\nextern void ata_sff_irq_clear(struct ata_port *ap);\nextern int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,\n\t\t\t    u8 status, int in_wq);\nextern void ata_sff_queue_work(struct work_struct *work);\nextern void ata_sff_queue_delayed_work(struct delayed_work *dwork,\n\t\tunsigned long delay);\nextern void ata_sff_queue_pio_task(struct ata_link *link, unsigned long delay);\nextern unsigned int ata_sff_qc_issue(struct ata_queued_cmd *qc);\nextern void ata_sff_qc_fill_rtf(struct ata_queued_cmd *qc);\nextern unsigned int ata_sff_port_intr(struct ata_port *ap,\n\t\t\t\t      struct ata_queued_cmd *qc);\nextern irqreturn_t ata_sff_interrupt(int irq, void *dev_instance);\nextern void ata_sff_lost_interrupt(struct ata_port *ap);\nextern void ata_sff_freeze(struct ata_port *ap);\nextern void ata_sff_thaw(struct ata_port *ap);\nextern int ata_sff_prereset(struct ata_link *link, unsigned long deadline);\nextern unsigned int ata_sff_dev_classify(struct ata_device *dev, int present,\n\t\t\t\t\t  u8 *r_err);\nextern int ata_sff_wait_after_reset(struct ata_link *link, unsigned int devmask,\n\t\t\t\t    unsigned long deadline);\nextern int ata_sff_softreset(struct ata_link *link, unsigned int *classes,\n\t\t\t     unsigned long deadline);\nextern int sata_sff_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t       unsigned long deadline);\nextern void ata_sff_postreset(struct ata_link *link, unsigned int *classes);\nextern void ata_sff_drain_fifo(struct ata_queued_cmd *qc);\nextern void ata_sff_error_handler(struct ata_port *ap);\nextern void ata_sff_std_ports(struct ata_ioports *ioaddr);\n#ifdef CONFIG_PCI\nextern int ata_pci_sff_init_host(struct ata_host *host);\nextern int ata_pci_sff_prepare_host(struct pci_dev *pdev,\n\t\t\t\t    const struct ata_port_info * const * ppi,\n\t\t\t\t    struct ata_host **r_host);\nextern int ata_pci_sff_activate_host(struct ata_host *host,\n\t\t\t\t     irq_handler_t irq_handler,\n\t\t\t\t     const struct scsi_host_template *sht);\nextern int ata_pci_sff_init_one(struct pci_dev *pdev,\n\t\tconst struct ata_port_info * const * ppi,\n\t\tconst struct scsi_host_template *sht, void *host_priv, int hflags);\n#endif  \n\n#ifdef CONFIG_ATA_BMDMA\n\nextern const struct ata_port_operations ata_bmdma_port_ops;\n\n#define ATA_BMDMA_SHT(drv_name)\t\t\t\t\t\\\n\tATA_BASE_SHT(drv_name),\t\t\t\t\t\\\n\t.sg_tablesize\t\t= LIBATA_MAX_PRD,\t\t\\\n\t.dma_boundary\t\t= ATA_DMA_BOUNDARY\n\nextern enum ata_completion_errors ata_bmdma_qc_prep(struct ata_queued_cmd *qc);\nextern unsigned int ata_bmdma_qc_issue(struct ata_queued_cmd *qc);\nextern enum ata_completion_errors ata_bmdma_dumb_qc_prep(struct ata_queued_cmd *qc);\nextern unsigned int ata_bmdma_port_intr(struct ata_port *ap,\n\t\t\t\t      struct ata_queued_cmd *qc);\nextern irqreturn_t ata_bmdma_interrupt(int irq, void *dev_instance);\nextern void ata_bmdma_error_handler(struct ata_port *ap);\nextern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);\nextern void ata_bmdma_irq_clear(struct ata_port *ap);\nextern void ata_bmdma_setup(struct ata_queued_cmd *qc);\nextern void ata_bmdma_start(struct ata_queued_cmd *qc);\nextern void ata_bmdma_stop(struct ata_queued_cmd *qc);\nextern u8 ata_bmdma_status(struct ata_port *ap);\nextern int ata_bmdma_port_start(struct ata_port *ap);\nextern int ata_bmdma_port_start32(struct ata_port *ap);\n\n#ifdef CONFIG_PCI\nextern int ata_pci_bmdma_clear_simplex(struct pci_dev *pdev);\nextern void ata_pci_bmdma_init(struct ata_host *host);\nextern int ata_pci_bmdma_prepare_host(struct pci_dev *pdev,\n\t\t\t\t      const struct ata_port_info * const * ppi,\n\t\t\t\t      struct ata_host **r_host);\nextern int ata_pci_bmdma_init_one(struct pci_dev *pdev,\n\t\t\t\t  const struct ata_port_info * const * ppi,\n\t\t\t\t  const struct scsi_host_template *sht,\n\t\t\t\t  void *host_priv, int hflags);\n#endif  \n#endif  \n\n \nstatic inline u8 ata_sff_busy_wait(struct ata_port *ap, unsigned int bits,\n\t\t\t\t   unsigned int max)\n{\n\tu8 status;\n\n\tdo {\n\t\tudelay(10);\n\t\tstatus = ap->ops->sff_check_status(ap);\n\t\tmax--;\n\t} while (status != 0xff && (status & bits) && (max > 0));\n\n\treturn status;\n}\n\n \nstatic inline u8 ata_wait_idle(struct ata_port *ap)\n{\n\tu8 status = ata_sff_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);\n\n\tif (status != 0xff && (status & (ATA_BUSY | ATA_DRQ)))\n\t\tata_port_dbg(ap, \"abnormal Status 0x%X\\n\", status);\n\n\treturn status;\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}