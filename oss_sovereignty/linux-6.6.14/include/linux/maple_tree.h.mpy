{
  "module_name": "maple_tree.h",
  "hash_id": "59fc3d5774f18b63fa43256bd27290dfec5d15ba0c26cbaefb71721791213d48",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/maple_tree.h",
  "human_readable_source": " \n#ifndef _LINUX_MAPLE_TREE_H\n#define _LINUX_MAPLE_TREE_H\n \n\n#include <linux/kernel.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n \n\n \n#if defined(CONFIG_64BIT) || defined(BUILD_VDSO32_64)\n \n#define MAPLE_NODE_SLOTS\t31\t \n#define MAPLE_RANGE64_SLOTS\t16\t \n#define MAPLE_ARANGE64_SLOTS\t10\t \n#define MAPLE_ALLOC_SLOTS\t(MAPLE_NODE_SLOTS - 1)\n#else\n \n#define MAPLE_NODE_SLOTS\t63\t \n#define MAPLE_RANGE64_SLOTS\t32\t \n#define MAPLE_ARANGE64_SLOTS\t21\t \n#define MAPLE_ALLOC_SLOTS\t(MAPLE_NODE_SLOTS - 2)\n#endif  \n\n#define MAPLE_NODE_MASK\t\t255UL\n\n \n\n \nstruct maple_metadata {\n\tunsigned char end;\n\tunsigned char gap;\n};\n\n \n\nstruct maple_range_64 {\n\tstruct maple_pnode *parent;\n\tunsigned long pivot[MAPLE_RANGE64_SLOTS - 1];\n\tunion {\n\t\tvoid __rcu *slot[MAPLE_RANGE64_SLOTS];\n\t\tstruct {\n\t\t\tvoid __rcu *pad[MAPLE_RANGE64_SLOTS - 1];\n\t\t\tstruct maple_metadata meta;\n\t\t};\n\t};\n};\n\n \nstruct maple_arange_64 {\n\tstruct maple_pnode *parent;\n\tunsigned long pivot[MAPLE_ARANGE64_SLOTS - 1];\n\tvoid __rcu *slot[MAPLE_ARANGE64_SLOTS];\n\tunsigned long gap[MAPLE_ARANGE64_SLOTS];\n\tstruct maple_metadata meta;\n};\n\nstruct maple_alloc {\n\tunsigned long total;\n\tunsigned char node_count;\n\tunsigned int request_count;\n\tstruct maple_alloc *slot[MAPLE_ALLOC_SLOTS];\n};\n\nstruct maple_topiary {\n\tstruct maple_pnode *parent;\n\tstruct maple_enode *next;  \n};\n\nenum maple_type {\n\tmaple_dense,\n\tmaple_leaf_64,\n\tmaple_range_64,\n\tmaple_arange_64,\n};\n\n\n \n#define MT_FLAGS_ALLOC_RANGE\t0x01\n#define MT_FLAGS_USE_RCU\t0x02\n#define MT_FLAGS_HEIGHT_OFFSET\t0x02\n#define MT_FLAGS_HEIGHT_MASK\t0x7C\n#define MT_FLAGS_LOCK_MASK\t0x300\n#define MT_FLAGS_LOCK_IRQ\t0x100\n#define MT_FLAGS_LOCK_BH\t0x200\n#define MT_FLAGS_LOCK_EXTERN\t0x300\n\n#define MAPLE_HEIGHT_MAX\t31\n\n\n#define MAPLE_NODE_TYPE_MASK\t0x0F\n#define MAPLE_NODE_TYPE_SHIFT\t0x03\n\n#define MAPLE_RESERVED_RANGE\t4096\n\n#ifdef CONFIG_LOCKDEP\ntypedef struct lockdep_map *lockdep_map_p;\n#define mt_lock_is_held(mt)                                             \\\n\t(!(mt)->ma_external_lock || lock_is_held((mt)->ma_external_lock))\n\n#define mt_write_lock_is_held(mt)\t\t\t\t\t\\\n\t(!(mt)->ma_external_lock ||\t\t\t\t\t\\\n\t lock_is_held_type((mt)->ma_external_lock, 0))\n\n#define mt_set_external_lock(mt, lock)\t\t\t\t\t\\\n\t(mt)->ma_external_lock = &(lock)->dep_map\n\n#define mt_on_stack(mt)\t\t\t(mt).ma_external_lock = NULL\n#else\ntypedef struct {   } lockdep_map_p;\n#define mt_lock_is_held(mt)\t\t1\n#define mt_write_lock_is_held(mt)\t1\n#define mt_set_external_lock(mt, lock)\tdo { } while (0)\n#define mt_on_stack(mt)\t\t\tdo { } while (0)\n#endif\n\n \nstruct maple_tree {\n\tunion {\n\t\tspinlock_t\tma_lock;\n\t\tlockdep_map_p\tma_external_lock;\n\t};\n\tunsigned int\tma_flags;\n\tvoid __rcu      *ma_root;\n};\n\n \n#define MTREE_INIT(name, __flags) {\t\t\t\t\t\\\n\t.ma_lock = __SPIN_LOCK_UNLOCKED((name).ma_lock),\t\t\\\n\t.ma_flags = __flags,\t\t\t\t\t\t\\\n\t.ma_root = NULL,\t\t\t\t\t\t\\\n}\n\n \n#ifdef CONFIG_LOCKDEP\n#define MTREE_INIT_EXT(name, __flags, __lock) {\t\t\t\t\\\n\t.ma_external_lock = &(__lock).dep_map,\t\t\t\t\\\n\t.ma_flags = (__flags),\t\t\t\t\t\t\\\n\t.ma_root = NULL,\t\t\t\t\t\t\\\n}\n#else\n#define MTREE_INIT_EXT(name, __flags, __lock)\tMTREE_INIT(name, __flags)\n#endif\n\n#define DEFINE_MTREE(name)\t\t\t\t\t\t\\\n\tstruct maple_tree name = MTREE_INIT(name, 0)\n\n#define mtree_lock(mt)\t\tspin_lock((&(mt)->ma_lock))\n#define mtree_unlock(mt)\tspin_unlock((&(mt)->ma_lock))\n\n \n\nstruct maple_node {\n\tunion {\n\t\tstruct {\n\t\t\tstruct maple_pnode *parent;\n\t\t\tvoid __rcu *slot[MAPLE_NODE_SLOTS];\n\t\t};\n\t\tstruct {\n\t\t\tvoid *pad;\n\t\t\tstruct rcu_head rcu;\n\t\t\tstruct maple_enode *piv_parent;\n\t\t\tunsigned char parent_slot;\n\t\t\tenum maple_type type;\n\t\t\tunsigned char slot_len;\n\t\t\tunsigned int ma_flags;\n\t\t};\n\t\tstruct maple_range_64 mr64;\n\t\tstruct maple_arange_64 ma64;\n\t\tstruct maple_alloc alloc;\n\t};\n};\n\n \nstruct ma_topiary {\n\tstruct maple_enode *head;\n\tstruct maple_enode *tail;\n\tstruct maple_tree *mtree;\n};\n\nvoid *mtree_load(struct maple_tree *mt, unsigned long index);\n\nint mtree_insert(struct maple_tree *mt, unsigned long index,\n\t\tvoid *entry, gfp_t gfp);\nint mtree_insert_range(struct maple_tree *mt, unsigned long first,\n\t\tunsigned long last, void *entry, gfp_t gfp);\nint mtree_alloc_range(struct maple_tree *mt, unsigned long *startp,\n\t\tvoid *entry, unsigned long size, unsigned long min,\n\t\tunsigned long max, gfp_t gfp);\nint mtree_alloc_rrange(struct maple_tree *mt, unsigned long *startp,\n\t\tvoid *entry, unsigned long size, unsigned long min,\n\t\tunsigned long max, gfp_t gfp);\n\nint mtree_store_range(struct maple_tree *mt, unsigned long first,\n\t\t      unsigned long last, void *entry, gfp_t gfp);\nint mtree_store(struct maple_tree *mt, unsigned long index,\n\t\tvoid *entry, gfp_t gfp);\nvoid *mtree_erase(struct maple_tree *mt, unsigned long index);\n\nvoid mtree_destroy(struct maple_tree *mt);\nvoid __mt_destroy(struct maple_tree *mt);\n\n \nstatic inline bool mtree_empty(const struct maple_tree *mt)\n{\n\treturn mt->ma_root == NULL;\n}\n\n \n\n \nstruct ma_state {\n\tstruct maple_tree *tree;\t \n\tunsigned long index;\t\t \n\tunsigned long last;\t\t \n\tstruct maple_enode *node;\t \n\tunsigned long min;\t\t \n\tunsigned long max;\t\t \n\tstruct maple_alloc *alloc;\t \n\tunsigned char depth;\t\t \n\tunsigned char offset;\n\tunsigned char mas_flags;\n};\n\nstruct ma_wr_state {\n\tstruct ma_state *mas;\n\tstruct maple_node *node;\t \n\tunsigned long r_min;\t\t \n\tunsigned long r_max;\t\t \n\tenum maple_type type;\t\t \n\tunsigned char offset_end;\t \n\tunsigned char node_end;\t\t \n\tunsigned long *pivots;\t\t \n\tunsigned long end_piv;\t\t \n\tvoid __rcu **slots;\t\t \n\tvoid *entry;\t\t\t \n\tvoid *content;\t\t\t \n};\n\n#define mas_lock(mas)           spin_lock(&((mas)->tree->ma_lock))\n#define mas_unlock(mas)         spin_unlock(&((mas)->tree->ma_lock))\n\n\n \n#define MAS_START\t((struct maple_enode *)1UL)\n#define MAS_ROOT\t((struct maple_enode *)5UL)\n#define MAS_NONE\t((struct maple_enode *)9UL)\n#define MAS_PAUSE\t((struct maple_enode *)17UL)\n#define MAS_OVERFLOW\t((struct maple_enode *)33UL)\n#define MAS_UNDERFLOW\t((struct maple_enode *)65UL)\n#define MA_ERROR(err) \\\n\t\t((struct maple_enode *)(((unsigned long)err << 2) | 2UL))\n\n#define MA_STATE(name, mt, first, end)\t\t\t\t\t\\\n\tstruct ma_state name = {\t\t\t\t\t\\\n\t\t.tree = mt,\t\t\t\t\t\t\\\n\t\t.index = first,\t\t\t\t\t\t\\\n\t\t.last = end,\t\t\t\t\t\t\\\n\t\t.node = MAS_START,\t\t\t\t\t\\\n\t\t.min = 0,\t\t\t\t\t\t\\\n\t\t.max = ULONG_MAX,\t\t\t\t\t\\\n\t\t.alloc = NULL,\t\t\t\t\t\t\\\n\t\t.mas_flags = 0,\t\t\t\t\t\t\\\n\t}\n\n#define MA_WR_STATE(name, ma_state, wr_entry)\t\t\t\t\\\n\tstruct ma_wr_state name = {\t\t\t\t\t\\\n\t\t.mas = ma_state,\t\t\t\t\t\\\n\t\t.content = NULL,\t\t\t\t\t\\\n\t\t.entry = wr_entry,\t\t\t\t\t\\\n\t}\n\n#define MA_TOPIARY(name, tree)\t\t\t\t\t\t\\\n\tstruct ma_topiary name = {\t\t\t\t\t\\\n\t\t.head = NULL,\t\t\t\t\t\t\\\n\t\t.tail = NULL,\t\t\t\t\t\t\\\n\t\t.mtree = tree,\t\t\t\t\t\t\\\n\t}\n\nvoid *mas_walk(struct ma_state *mas);\nvoid *mas_store(struct ma_state *mas, void *entry);\nvoid *mas_erase(struct ma_state *mas);\nint mas_store_gfp(struct ma_state *mas, void *entry, gfp_t gfp);\nvoid mas_store_prealloc(struct ma_state *mas, void *entry);\nvoid *mas_find(struct ma_state *mas, unsigned long max);\nvoid *mas_find_range(struct ma_state *mas, unsigned long max);\nvoid *mas_find_rev(struct ma_state *mas, unsigned long min);\nvoid *mas_find_range_rev(struct ma_state *mas, unsigned long max);\nint mas_preallocate(struct ma_state *mas, void *entry, gfp_t gfp);\nbool mas_is_err(struct ma_state *mas);\n\nbool mas_nomem(struct ma_state *mas, gfp_t gfp);\nvoid mas_pause(struct ma_state *mas);\nvoid maple_tree_init(void);\nvoid mas_destroy(struct ma_state *mas);\nint mas_expected_entries(struct ma_state *mas, unsigned long nr_entries);\n\nvoid *mas_prev(struct ma_state *mas, unsigned long min);\nvoid *mas_prev_range(struct ma_state *mas, unsigned long max);\nvoid *mas_next(struct ma_state *mas, unsigned long max);\nvoid *mas_next_range(struct ma_state *mas, unsigned long max);\n\nint mas_empty_area(struct ma_state *mas, unsigned long min, unsigned long max,\n\t\t   unsigned long size);\n \nint mas_empty_area_rev(struct ma_state *mas, unsigned long min,\n\t\t       unsigned long max, unsigned long size);\n\nstatic inline void mas_init(struct ma_state *mas, struct maple_tree *tree,\n\t\t\t    unsigned long addr)\n{\n\tmemset(mas, 0, sizeof(struct ma_state));\n\tmas->tree = tree;\n\tmas->index = mas->last = addr;\n\tmas->max = ULONG_MAX;\n\tmas->node = MAS_START;\n}\n\n \nstatic inline bool mas_is_none(const struct ma_state *mas)\n{\n\treturn mas->node == MAS_NONE;\n}\n\n \nstatic inline bool mas_is_paused(const struct ma_state *mas)\n{\n\treturn mas->node == MAS_PAUSE;\n}\n\n \nstatic inline bool mas_is_active(struct ma_state *mas)\n{\n\tif ((unsigned long)mas->node >= MAPLE_RESERVED_RANGE)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic inline void mas_reset(struct ma_state *mas)\n{\n\tmas->node = MAS_START;\n}\n\n \n#define mas_for_each(__mas, __entry, __max) \\\n\twhile (((__entry) = mas_find((__mas), (__max))) != NULL)\n \nstatic inline void __mas_set_range(struct ma_state *mas, unsigned long start,\n\t\tunsigned long last)\n{\n\tmas->index = start;\n\tmas->last = last;\n}\n\n \nstatic inline\nvoid mas_set_range(struct ma_state *mas, unsigned long start, unsigned long last)\n{\n\t__mas_set_range(mas, start, last);\n\tmas->node = MAS_START;\n}\n\n \nstatic inline void mas_set(struct ma_state *mas, unsigned long index)\n{\n\n\tmas_set_range(mas, index, index);\n}\n\nstatic inline bool mt_external_lock(const struct maple_tree *mt)\n{\n\treturn (mt->ma_flags & MT_FLAGS_LOCK_MASK) == MT_FLAGS_LOCK_EXTERN;\n}\n\n \nstatic inline void mt_init_flags(struct maple_tree *mt, unsigned int flags)\n{\n\tmt->ma_flags = flags;\n\tif (!mt_external_lock(mt))\n\t\tspin_lock_init(&mt->ma_lock);\n\trcu_assign_pointer(mt->ma_root, NULL);\n}\n\n \nstatic inline void mt_init(struct maple_tree *mt)\n{\n\tmt_init_flags(mt, 0);\n}\n\nstatic inline bool mt_in_rcu(struct maple_tree *mt)\n{\n#ifdef CONFIG_MAPLE_RCU_DISABLED\n\treturn false;\n#endif\n\treturn mt->ma_flags & MT_FLAGS_USE_RCU;\n}\n\n \nstatic inline void mt_clear_in_rcu(struct maple_tree *mt)\n{\n\tif (!mt_in_rcu(mt))\n\t\treturn;\n\n\tif (mt_external_lock(mt)) {\n\t\tWARN_ON(!mt_lock_is_held(mt));\n\t\tmt->ma_flags &= ~MT_FLAGS_USE_RCU;\n\t} else {\n\t\tmtree_lock(mt);\n\t\tmt->ma_flags &= ~MT_FLAGS_USE_RCU;\n\t\tmtree_unlock(mt);\n\t}\n}\n\n \nstatic inline void mt_set_in_rcu(struct maple_tree *mt)\n{\n\tif (mt_in_rcu(mt))\n\t\treturn;\n\n\tif (mt_external_lock(mt)) {\n\t\tWARN_ON(!mt_lock_is_held(mt));\n\t\tmt->ma_flags |= MT_FLAGS_USE_RCU;\n\t} else {\n\t\tmtree_lock(mt);\n\t\tmt->ma_flags |= MT_FLAGS_USE_RCU;\n\t\tmtree_unlock(mt);\n\t}\n}\n\nstatic inline unsigned int mt_height(const struct maple_tree *mt)\n{\n\treturn (mt->ma_flags & MT_FLAGS_HEIGHT_MASK) >> MT_FLAGS_HEIGHT_OFFSET;\n}\n\nvoid *mt_find(struct maple_tree *mt, unsigned long *index, unsigned long max);\nvoid *mt_find_after(struct maple_tree *mt, unsigned long *index,\n\t\t    unsigned long max);\nvoid *mt_prev(struct maple_tree *mt, unsigned long index,  unsigned long min);\nvoid *mt_next(struct maple_tree *mt, unsigned long index, unsigned long max);\n\n \n#define mt_for_each(__tree, __entry, __index, __max) \\\n\tfor (__entry = mt_find(__tree, &(__index), __max); \\\n\t\t__entry; __entry = mt_find_after(__tree, &(__index), __max))\n\n\n#ifdef CONFIG_DEBUG_MAPLE_TREE\nenum mt_dump_format {\n\tmt_dump_dec,\n\tmt_dump_hex,\n};\n\nextern atomic_t maple_tree_tests_run;\nextern atomic_t maple_tree_tests_passed;\n\nvoid mt_dump(const struct maple_tree *mt, enum mt_dump_format format);\nvoid mas_dump(const struct ma_state *mas);\nvoid mas_wr_dump(const struct ma_wr_state *wr_mas);\nvoid mt_validate(struct maple_tree *mt);\nvoid mt_cache_shrink(void);\n#define MT_BUG_ON(__tree, __x) do {\t\t\t\t\t\\\n\tatomic_inc(&maple_tree_tests_run);\t\t\t\t\\\n\tif (__x) {\t\t\t\t\t\t\t\\\n\t\tpr_info(\"BUG at %s:%d (%u)\\n\",\t\t\t\t\\\n\t\t__func__, __LINE__, __x);\t\t\t\t\\\n\t\tmt_dump(__tree, mt_dump_hex);\t\t\t\t\\\n\t\tpr_info(\"Pass: %u Run:%u\\n\",\t\t\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_passed),\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_run));\t\t\\\n\t\tdump_stack();\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tatomic_inc(&maple_tree_tests_passed);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define MAS_BUG_ON(__mas, __x) do {\t\t\t\t\t\\\n\tatomic_inc(&maple_tree_tests_run);\t\t\t\t\\\n\tif (__x) {\t\t\t\t\t\t\t\\\n\t\tpr_info(\"BUG at %s:%d (%u)\\n\",\t\t\t\t\\\n\t\t__func__, __LINE__, __x);\t\t\t\t\\\n\t\tmas_dump(__mas);\t\t\t\t\t\\\n\t\tmt_dump((__mas)->tree, mt_dump_hex);\t\t\t\\\n\t\tpr_info(\"Pass: %u Run:%u\\n\",\t\t\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_passed),\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_run));\t\t\\\n\t\tdump_stack();\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tatomic_inc(&maple_tree_tests_passed);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define MAS_WR_BUG_ON(__wrmas, __x) do {\t\t\t\t\\\n\tatomic_inc(&maple_tree_tests_run);\t\t\t\t\\\n\tif (__x) {\t\t\t\t\t\t\t\\\n\t\tpr_info(\"BUG at %s:%d (%u)\\n\",\t\t\t\t\\\n\t\t__func__, __LINE__, __x);\t\t\t\t\\\n\t\tmas_wr_dump(__wrmas);\t\t\t\t\t\\\n\t\tmas_dump((__wrmas)->mas);\t\t\t\t\\\n\t\tmt_dump((__wrmas)->mas->tree, mt_dump_hex);\t\t\\\n\t\tpr_info(\"Pass: %u Run:%u\\n\",\t\t\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_passed),\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_run));\t\t\\\n\t\tdump_stack();\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tatomic_inc(&maple_tree_tests_passed);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define MT_WARN_ON(__tree, __x)  ({\t\t\t\t\t\\\n\tint ret = !!(__x);\t\t\t\t\t\t\\\n\tatomic_inc(&maple_tree_tests_run);\t\t\t\t\\\n\tif (ret) {\t\t\t\t\t\t\t\\\n\t\tpr_info(\"WARN at %s:%d (%u)\\n\",\t\t\t\t\\\n\t\t__func__, __LINE__, __x);\t\t\t\t\\\n\t\tmt_dump(__tree, mt_dump_hex);\t\t\t\t\\\n\t\tpr_info(\"Pass: %u Run:%u\\n\",\t\t\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_passed),\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_run));\t\t\\\n\t\tdump_stack();\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tatomic_inc(&maple_tree_tests_passed);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tunlikely(ret);\t\t\t\t\t\t\t\\\n})\n\n#define MAS_WARN_ON(__mas, __x) ({\t\t\t\t\t\\\n\tint ret = !!(__x);\t\t\t\t\t\t\\\n\tatomic_inc(&maple_tree_tests_run);\t\t\t\t\\\n\tif (ret) {\t\t\t\t\t\t\t\\\n\t\tpr_info(\"WARN at %s:%d (%u)\\n\",\t\t\t\t\\\n\t\t__func__, __LINE__, __x);\t\t\t\t\\\n\t\tmas_dump(__mas);\t\t\t\t\t\\\n\t\tmt_dump((__mas)->tree, mt_dump_hex);\t\t\t\\\n\t\tpr_info(\"Pass: %u Run:%u\\n\",\t\t\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_passed),\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_run));\t\t\\\n\t\tdump_stack();\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tatomic_inc(&maple_tree_tests_passed);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tunlikely(ret);\t\t\t\t\t\t\t\\\n})\n\n#define MAS_WR_WARN_ON(__wrmas, __x) ({\t\t\t\t\t\\\n\tint ret = !!(__x);\t\t\t\t\t\t\\\n\tatomic_inc(&maple_tree_tests_run);\t\t\t\t\\\n\tif (ret) {\t\t\t\t\t\t\t\\\n\t\tpr_info(\"WARN at %s:%d (%u)\\n\",\t\t\t\t\\\n\t\t__func__, __LINE__, __x);\t\t\t\t\\\n\t\tmas_wr_dump(__wrmas);\t\t\t\t\t\\\n\t\tmas_dump((__wrmas)->mas);\t\t\t\t\\\n\t\tmt_dump((__wrmas)->mas->tree, mt_dump_hex);\t\t\\\n\t\tpr_info(\"Pass: %u Run:%u\\n\",\t\t\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_passed),\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_run));\t\t\\\n\t\tdump_stack();\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tatomic_inc(&maple_tree_tests_passed);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tunlikely(ret);\t\t\t\t\t\t\t\\\n})\n#else\n#define MT_BUG_ON(__tree, __x)\t\tBUG_ON(__x)\n#define MAS_BUG_ON(__mas, __x)\t\tBUG_ON(__x)\n#define MAS_WR_BUG_ON(__mas, __x)\tBUG_ON(__x)\n#define MT_WARN_ON(__tree, __x)\t\tWARN_ON(__x)\n#define MAS_WARN_ON(__mas, __x)\t\tWARN_ON(__x)\n#define MAS_WR_WARN_ON(__mas, __x)\tWARN_ON(__x)\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}