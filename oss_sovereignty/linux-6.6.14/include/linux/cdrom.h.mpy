{
  "module_name": "cdrom.h",
  "hash_id": "8eec3ee093fb9c267065831fa0b624ab2bf9314f3dd34d37db71236e27713dee",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/cdrom.h",
  "human_readable_source": " \n \n#ifndef\t_LINUX_CDROM_H\n#define\t_LINUX_CDROM_H\n\n#include <linux/fs.h>\t\t \n#include <linux/list.h>\n#include <linux/blkdev.h>\n#include <scsi/scsi_common.h>\n#include <uapi/linux/cdrom.h>\n\nstruct packet_command\n{\n\tunsigned char \t\tcmd[CDROM_PACKET_SIZE];\n\tunsigned char \t\t*buffer;\n\tunsigned int \t\tbuflen;\n\tint\t\t\tstat;\n\tstruct scsi_sense_hdr\t*sshdr;\n\tunsigned char\t\tdata_direction;\n\tint\t\t\tquiet;\n\tint\t\t\ttimeout;\n\tvoid\t\t\t*reserved[1];\n};\n\n \n#define CDDA_OLD\t\t0\t \n#define CDDA_BPC_SINGLE\t\t1\t \n#define CDDA_BPC_FULL\t\t2\t \n\n \nstruct cdrom_device_info {\n\tconst struct cdrom_device_ops *ops;  \n\tstruct list_head list;\t\t \n\tstruct gendisk *disk;\t\t \n\tvoid *handle;\t\t         \n \n\tint mask;                        \n\tint speed;\t\t\t \n\tint capacity;\t\t\t \n \n\tunsigned int options\t: 30;\t \n\tunsigned mc_flags\t: 2;\t \n\tunsigned int vfs_events;\t \n\tunsigned int ioctl_events;\t \n    \tint use_count;                   \n    \tchar name[20];                   \n \n        __u8 sanyo_slot\t\t: 2;\t \n        __u8 keeplocked\t\t: 1;\t \n        __u8 reserved\t\t: 5;\t \n\tint cdda_method;\t\t \n\t__u8 last_sense;\n\t__u8 media_written;\t\t \n\tunsigned short mmc3_profile;\t \n\tint (*exit)(struct cdrom_device_info *);\n\tint mrw_mode_page;\n\tbool opened_for_data;\n\t__s64 last_media_change_ms;\n};\n\nstruct cdrom_device_ops {\n \n\tint (*open) (struct cdrom_device_info *, int);\n\tvoid (*release) (struct cdrom_device_info *);\n\tint (*drive_status) (struct cdrom_device_info *, int);\n\tunsigned int (*check_events) (struct cdrom_device_info *cdi,\n\t\t\t\t      unsigned int clearing, int slot);\n\tint (*tray_move) (struct cdrom_device_info *, int);\n\tint (*lock_door) (struct cdrom_device_info *, int);\n\tint (*select_speed) (struct cdrom_device_info *, int);\n\tint (*get_last_session) (struct cdrom_device_info *,\n\t\t\t\t struct cdrom_multisession *);\n\tint (*get_mcn) (struct cdrom_device_info *,\n\t\t\tstruct cdrom_mcn *);\n\t \n\tint (*reset) (struct cdrom_device_info *);\n\t \n\tint (*audio_ioctl) (struct cdrom_device_info *,unsigned int, void *);\n\n\t \n\tint (*generic_packet) (struct cdrom_device_info *,\n\t\t\t       struct packet_command *);\n\tint (*read_cdda_bpc)(struct cdrom_device_info *cdi, void __user *ubuf,\n\t\t\t       u32 lba, u32 nframes, u8 *last_sense);\n \n\tconst int capability;    \n};\n\nint cdrom_multisession(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_multisession *info);\nint cdrom_read_tocentry(struct cdrom_device_info *cdi,\n\t\tstruct cdrom_tocentry *entry);\n\n \nint cdrom_open(struct cdrom_device_info *cdi, blk_mode_t mode);\nvoid cdrom_release(struct cdrom_device_info *cdi);\nint cdrom_ioctl(struct cdrom_device_info *cdi, struct block_device *bdev,\n\t\tunsigned int cmd, unsigned long arg);\nextern unsigned int cdrom_check_events(struct cdrom_device_info *cdi,\n\t\t\t\t       unsigned int clearing);\n\nextern int register_cdrom(struct gendisk *disk, struct cdrom_device_info *cdi);\nextern void unregister_cdrom(struct cdrom_device_info *cdi);\n\ntypedef struct {\n    int data;\n    int audio;\n    int cdi;\n    int xa;\n    long error;\n} tracktype;\n\nextern int cdrom_get_last_written(struct cdrom_device_info *cdi, long *last_written);\nextern int cdrom_number_of_slots(struct cdrom_device_info *cdi);\nextern int cdrom_mode_select(struct cdrom_device_info *cdi,\n\t\t\t     struct packet_command *cgc);\nextern int cdrom_mode_sense(struct cdrom_device_info *cdi,\n\t\t\t    struct packet_command *cgc,\n\t\t\t    int page_code, int page_control);\nextern void init_cdrom_command(struct packet_command *cgc,\n\t\t\t       void *buffer, int len, int type);\nextern int cdrom_dummy_generic_packet(struct cdrom_device_info *cdi,\n\t\t\t\t      struct packet_command *cgc);\n\n \n#define CDROM_MAX_SLOTS\t256\n\nstruct cdrom_mechstat_header {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t__u8 fault         : 1;\n\t__u8 changer_state : 2;\n\t__u8 curslot       : 5;\n\t__u8 mech_state    : 3;\n\t__u8 door_open     : 1;\n\t__u8 reserved1     : 4;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\t__u8 curslot       : 5;\n\t__u8 changer_state : 2;\n\t__u8 fault         : 1;\n\t__u8 reserved1     : 4;\n\t__u8 door_open     : 1;\n\t__u8 mech_state    : 3;\n#endif\n\t__u8     curlba[3];\n\t__u8     nslots;\n\t__u16 slot_tablelen;\n};\n\nstruct cdrom_slot {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t__u8 disc_present : 1;\n\t__u8 reserved1    : 6;\n\t__u8 change       : 1;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\t__u8 change       : 1;\n\t__u8 reserved1    : 6;\n\t__u8 disc_present : 1;\n#endif\n\t__u8 reserved2[3];\n};\n\nstruct cdrom_changer_info {\n\tstruct cdrom_mechstat_header hdr;\n\tstruct cdrom_slot slots[CDROM_MAX_SLOTS];\n};\n\ntypedef enum {\n\tmechtype_caddy = 0,\n\tmechtype_tray  = 1,\n\tmechtype_popup = 2,\n\tmechtype_individual_changer = 4,\n\tmechtype_cartridge_changer  = 5\n} mechtype_t;\n\ntypedef struct {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t__u8 ps\t\t\t: 1;\n\t__u8 reserved1\t\t: 1;\n\t__u8 page_code\t\t: 6;\n        __u8 page_length;\n\t__u8 reserved2\t\t: 1;\n\t__u8 bufe\t\t: 1;\n\t__u8 ls_v\t\t: 1;\n\t__u8 test_write\t\t: 1;\n        __u8 write_type\t\t: 4;\n\t__u8 multi_session\t: 2;  \n\t__u8 fp\t\t\t: 1;\n\t__u8 copy\t\t: 1;\n\t__u8 track_mode\t\t: 4;\n\t__u8 reserved3\t\t: 4;\n\t__u8 data_block_type\t: 4;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\t__u8 page_code\t\t: 6;\n\t__u8 reserved1\t\t: 1;\n\t__u8 ps\t\t\t: 1;\n        __u8 page_length;\n        __u8 write_type\t\t: 4;\n\t__u8 test_write\t\t: 1;\n\t__u8 ls_v\t\t: 1;\n\t__u8 bufe\t\t: 1;\n\t__u8 reserved2\t\t: 1;\n\t__u8 track_mode\t\t: 4;\n\t__u8 copy\t\t: 1;\n\t__u8 fp\t\t\t: 1;\n\t__u8 multi_session\t: 2;  \n\t__u8 data_block_type\t: 4;\n\t__u8 reserved3\t\t: 4;\n#endif\n\t__u8 link_size;\n\t__u8 reserved4;\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t__u8 reserved5\t\t: 2;\n\t__u8 app_code\t\t: 6;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\t__u8 app_code\t\t: 6;\n\t__u8 reserved5\t\t: 2;\n#endif\n\t__u8 session_format;\n\t__u8 reserved6;\n\t__be32 packet_size;\n\t__u16 audio_pause;\n\t__u8 mcn[16];\n\t__u8 isrc[16];\n\t__u8 subhdr0;\n\t__u8 subhdr1;\n\t__u8 subhdr2;\n\t__u8 subhdr3;\n} __attribute__((packed)) write_param_page;\n\nstruct modesel_head\n{\n\t__u8\treserved1;\n\t__u8\tmedium;\n\t__u8\treserved2;\n\t__u8\tblock_desc_length;\n\t__u8\tdensity;\n\t__u8\tnumber_of_blocks_hi;\n\t__u8\tnumber_of_blocks_med;\n\t__u8\tnumber_of_blocks_lo;\n\t__u8\treserved3;\n\t__u8\tblock_length_hi;\n\t__u8\tblock_length_med;\n\t__u8\tblock_length_lo;\n};\n\ntypedef struct {\n\t__u16 report_key_length;\n\t__u8 reserved1;\n\t__u8 reserved2;\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t__u8 type_code\t\t\t: 2;\n\t__u8 vra\t\t\t: 3;\n\t__u8 ucca\t\t\t: 3;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\t__u8 ucca\t\t\t: 3;\n\t__u8 vra\t\t\t: 3;\n\t__u8 type_code\t\t\t: 2;\n#endif\n\t__u8 region_mask;\n\t__u8 rpc_scheme;\n\t__u8 reserved3;\n} rpc_state_t;\n\nstruct event_header {\n\t__be16 data_len;\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t__u8 nea\t\t: 1;\n\t__u8 reserved1\t\t: 4;\n\t__u8 notification_class\t: 3;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\t__u8 notification_class\t: 3;\n\t__u8 reserved1\t\t: 4;\n\t__u8 nea\t\t: 1;\n#endif\n\t__u8 supp_event_class;\n};\n\nstruct media_event_desc {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t__u8 reserved1\t\t: 4;\n\t__u8 media_event_code\t: 4;\n\t__u8 reserved2\t\t: 6;\n\t__u8 media_present\t: 1;\n\t__u8 door_open\t\t: 1;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\t__u8 media_event_code\t: 4;\n\t__u8 reserved1\t\t: 4;\n\t__u8 door_open\t\t: 1;\n\t__u8 media_present\t: 1;\n\t__u8 reserved2\t\t: 6;\n#endif\n\t__u8 start_slot;\n\t__u8 end_slot;\n};\n\nextern int cdrom_get_media_event(struct cdrom_device_info *cdi, struct media_event_desc *med);\n\nstatic inline void lba_to_msf(int lba, u8 *m, u8 *s, u8 *f)\n{\n\tlba += CD_MSF_OFFSET;\n\tlba &= 0xffffff;   \n\t*m = lba / (CD_SECS * CD_FRAMES);\n\tlba %= (CD_SECS * CD_FRAMES);\n\t*s = lba / CD_FRAMES;\n\t*f = lba % CD_FRAMES;\n}\n\nstatic inline int msf_to_lba(u8 m, u8 s, u8 f)\n{\n\treturn (((m * CD_SECS) + s) * CD_FRAMES + f) - CD_MSF_OFFSET;\n}\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}