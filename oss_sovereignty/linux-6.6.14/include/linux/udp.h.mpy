{
  "module_name": "udp.h",
  "hash_id": "a260acf6b7e60778fdfa21c0583858861cbf01316ca8aab017e8d54327eb4a8d",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/udp.h",
  "human_readable_source": " \n \n#ifndef _LINUX_UDP_H\n#define _LINUX_UDP_H\n\n#include <net/inet_sock.h>\n#include <linux/skbuff.h>\n#include <net/netns/hash.h>\n#include <uapi/linux/udp.h>\n\nstatic inline struct udphdr *udp_hdr(const struct sk_buff *skb)\n{\n\treturn (struct udphdr *)skb_transport_header(skb);\n}\n\n#define UDP_HTABLE_SIZE_MIN_PERNET\t128\n#define UDP_HTABLE_SIZE_MIN\t\t(CONFIG_BASE_SMALL ? 128 : 256)\n#define UDP_HTABLE_SIZE_MAX\t\t65536\n\nstatic inline u32 udp_hashfn(const struct net *net, u32 num, u32 mask)\n{\n\treturn (num + net_hash_mix(net)) & mask;\n}\n\nenum {\n\tUDP_FLAGS_CORK,\t\t \n\tUDP_FLAGS_NO_CHECK6_TX,  \n\tUDP_FLAGS_NO_CHECK6_RX,  \n\tUDP_FLAGS_GRO_ENABLED,\t \n\tUDP_FLAGS_ACCEPT_FRAGLIST,\n\tUDP_FLAGS_ACCEPT_L4,\n\tUDP_FLAGS_ENCAP_ENABLED,  \n\tUDP_FLAGS_UDPLITE_SEND_CC,  \n\tUDP_FLAGS_UDPLITE_RECV_CC,  \n};\n\nstruct udp_sock {\n\t \n\tstruct inet_sock inet;\n#define udp_port_hash\t\tinet.sk.__sk_common.skc_u16hashes[0]\n#define udp_portaddr_hash\tinet.sk.__sk_common.skc_u16hashes[1]\n#define udp_portaddr_node\tinet.sk.__sk_common.skc_portaddr_node\n\n\tunsigned long\t udp_flags;\n\n\tint\t\t pending;\t \n\t__u8\t\t encap_type;\t \n\n\t \n\t__u16\t\t len;\t\t \n\t__u16\t\t gso_size;\n\t \n\t__u16\t\t pcslen;\n\t__u16\t\t pcrlen;\n\t \n\tint (*encap_rcv)(struct sock *sk, struct sk_buff *skb);\n\tvoid (*encap_err_rcv)(struct sock *sk, struct sk_buff *skb, int err,\n\t\t\t      __be16 port, u32 info, u8 *payload);\n\tint (*encap_err_lookup)(struct sock *sk, struct sk_buff *skb);\n\tvoid (*encap_destroy)(struct sock *sk);\n\n\t \n\tstruct sk_buff *\t(*gro_receive)(struct sock *sk,\n\t\t\t\t\t       struct list_head *head,\n\t\t\t\t\t       struct sk_buff *skb);\n\tint\t\t\t(*gro_complete)(struct sock *sk,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tint nhoff);\n\n\t \n\tstruct sk_buff_head\treader_queue ____cacheline_aligned_in_smp;\n\n\t \n\tint\t\tforward_deficit;\n\n\t \n\tint\t\tforward_threshold;\n};\n\n#define udp_test_bit(nr, sk)\t\t\t\\\n\ttest_bit(UDP_FLAGS_##nr, &udp_sk(sk)->udp_flags)\n#define udp_set_bit(nr, sk)\t\t\t\\\n\tset_bit(UDP_FLAGS_##nr, &udp_sk(sk)->udp_flags)\n#define udp_test_and_set_bit(nr, sk)\t\t\\\n\ttest_and_set_bit(UDP_FLAGS_##nr, &udp_sk(sk)->udp_flags)\n#define udp_clear_bit(nr, sk)\t\t\t\\\n\tclear_bit(UDP_FLAGS_##nr, &udp_sk(sk)->udp_flags)\n#define udp_assign_bit(nr, sk, val)\t\t\\\n\tassign_bit(UDP_FLAGS_##nr, &udp_sk(sk)->udp_flags, val)\n\n#define UDP_MAX_SEGMENTS\t(1 << 6UL)\n\n#define udp_sk(ptr) container_of_const(ptr, struct udp_sock, inet.sk)\n\nstatic inline void udp_set_no_check6_tx(struct sock *sk, bool val)\n{\n\tudp_assign_bit(NO_CHECK6_TX, sk, val);\n}\n\nstatic inline void udp_set_no_check6_rx(struct sock *sk, bool val)\n{\n\tudp_assign_bit(NO_CHECK6_RX, sk, val);\n}\n\nstatic inline bool udp_get_no_check6_tx(const struct sock *sk)\n{\n\treturn udp_test_bit(NO_CHECK6_TX, sk);\n}\n\nstatic inline bool udp_get_no_check6_rx(const struct sock *sk)\n{\n\treturn udp_test_bit(NO_CHECK6_RX, sk);\n}\n\nstatic inline void udp_cmsg_recv(struct msghdr *msg, struct sock *sk,\n\t\t\t\t struct sk_buff *skb)\n{\n\tint gso_size;\n\n\tif (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_L4) {\n\t\tgso_size = skb_shinfo(skb)->gso_size;\n\t\tput_cmsg(msg, SOL_UDP, UDP_GRO, sizeof(gso_size), &gso_size);\n\t}\n}\n\nstatic inline bool udp_unexpected_gso(struct sock *sk, struct sk_buff *skb)\n{\n\tif (!skb_is_gso(skb))\n\t\treturn false;\n\n\tif (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_L4 &&\n\t    !udp_test_bit(ACCEPT_L4, sk))\n\t\treturn true;\n\n\tif (skb_shinfo(skb)->gso_type & SKB_GSO_FRAGLIST &&\n\t    !udp_test_bit(ACCEPT_FRAGLIST, sk))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline void udp_allow_gso(struct sock *sk)\n{\n\tudp_set_bit(ACCEPT_L4, sk);\n\tudp_set_bit(ACCEPT_FRAGLIST, sk);\n}\n\n#define udp_portaddr_for_each_entry(__sk, list) \\\n\thlist_for_each_entry(__sk, list, __sk_common.skc_portaddr_node)\n\n#define udp_portaddr_for_each_entry_rcu(__sk, list) \\\n\thlist_for_each_entry_rcu(__sk, list, __sk_common.skc_portaddr_node)\n\n#define IS_UDPLITE(__sk) (__sk->sk_protocol == IPPROTO_UDPLITE)\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}