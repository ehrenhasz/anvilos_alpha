{
  "module_name": "user_namespace.h",
  "hash_id": "b4604a7b06d8fc2c324a8b0088af503e613e6554889f843f2c06436cfd793fd8",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/user_namespace.h",
  "human_readable_source": " \n#ifndef _LINUX_USER_NAMESPACE_H\n#define _LINUX_USER_NAMESPACE_H\n\n#include <linux/kref.h>\n#include <linux/nsproxy.h>\n#include <linux/ns_common.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/rwsem.h>\n#include <linux/sysctl.h>\n#include <linux/err.h>\n\n#define UID_GID_MAP_MAX_BASE_EXTENTS 5\n#define UID_GID_MAP_MAX_EXTENTS 340\n\nstruct uid_gid_extent {\n\tu32 first;\n\tu32 lower_first;\n\tu32 count;\n};\n\nstruct uid_gid_map {  \n\tu32 nr_extents;\n\tunion {\n\t\tstruct uid_gid_extent extent[UID_GID_MAP_MAX_BASE_EXTENTS];\n\t\tstruct {\n\t\t\tstruct uid_gid_extent *forward;\n\t\t\tstruct uid_gid_extent *reverse;\n\t\t};\n\t};\n};\n\n#define USERNS_SETGROUPS_ALLOWED 1UL\n\n#define USERNS_INIT_FLAGS USERNS_SETGROUPS_ALLOWED\n\nstruct ucounts;\n\nenum ucount_type {\n\tUCOUNT_USER_NAMESPACES,\n\tUCOUNT_PID_NAMESPACES,\n\tUCOUNT_UTS_NAMESPACES,\n\tUCOUNT_IPC_NAMESPACES,\n\tUCOUNT_NET_NAMESPACES,\n\tUCOUNT_MNT_NAMESPACES,\n\tUCOUNT_CGROUP_NAMESPACES,\n\tUCOUNT_TIME_NAMESPACES,\n#ifdef CONFIG_INOTIFY_USER\n\tUCOUNT_INOTIFY_INSTANCES,\n\tUCOUNT_INOTIFY_WATCHES,\n#endif\n#ifdef CONFIG_FANOTIFY\n\tUCOUNT_FANOTIFY_GROUPS,\n\tUCOUNT_FANOTIFY_MARKS,\n#endif\n\tUCOUNT_COUNTS,\n};\n\nenum rlimit_type {\n\tUCOUNT_RLIMIT_NPROC,\n\tUCOUNT_RLIMIT_MSGQUEUE,\n\tUCOUNT_RLIMIT_SIGPENDING,\n\tUCOUNT_RLIMIT_MEMLOCK,\n\tUCOUNT_RLIMIT_COUNTS,\n};\n\nstruct user_namespace {\n\tstruct uid_gid_map\tuid_map;\n\tstruct uid_gid_map\tgid_map;\n\tstruct uid_gid_map\tprojid_map;\n\tstruct user_namespace\t*parent;\n\tint\t\t\tlevel;\n\tkuid_t\t\t\towner;\n\tkgid_t\t\t\tgroup;\n\tstruct ns_common\tns;\n\tunsigned long\t\tflags;\n\t \n\tbool\t\t\tparent_could_setfcap;\n\n#ifdef CONFIG_KEYS\n\t \n\tstruct list_head\tkeyring_name_list;\n\tstruct key\t\t*user_keyring_register;\n\tstruct rw_semaphore\tkeyring_sem;\n#endif\n\n\t \n#ifdef CONFIG_PERSISTENT_KEYRINGS\n\tstruct key\t\t*persistent_keyring_register;\n#endif\n\tstruct work_struct\twork;\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table_set\tset;\n\tstruct ctl_table_header *sysctls;\n#endif\n\tstruct ucounts\t\t*ucounts;\n\tlong ucount_max[UCOUNT_COUNTS];\n\tlong rlimit_max[UCOUNT_RLIMIT_COUNTS];\n} __randomize_layout;\n\nstruct ucounts {\n\tstruct hlist_node node;\n\tstruct user_namespace *ns;\n\tkuid_t uid;\n\tatomic_t count;\n\tatomic_long_t ucount[UCOUNT_COUNTS];\n\tatomic_long_t rlimit[UCOUNT_RLIMIT_COUNTS];\n};\n\nextern struct user_namespace init_user_ns;\nextern struct ucounts init_ucounts;\n\nbool setup_userns_sysctls(struct user_namespace *ns);\nvoid retire_userns_sysctls(struct user_namespace *ns);\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid, enum ucount_type type);\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type);\nstruct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid);\nstruct ucounts * __must_check get_ucounts(struct ucounts *ucounts);\nvoid put_ucounts(struct ucounts *ucounts);\n\nstatic inline long get_rlimit_value(struct ucounts *ucounts, enum rlimit_type type)\n{\n\treturn atomic_long_read(&ucounts->rlimit[type]);\n}\n\nlong inc_rlimit_ucounts(struct ucounts *ucounts, enum rlimit_type type, long v);\nbool dec_rlimit_ucounts(struct ucounts *ucounts, enum rlimit_type type, long v);\nlong inc_rlimit_get_ucounts(struct ucounts *ucounts, enum rlimit_type type);\nvoid dec_rlimit_put_ucounts(struct ucounts *ucounts, enum rlimit_type type);\nbool is_rlimit_overlimit(struct ucounts *ucounts, enum rlimit_type type, unsigned long max);\n\nstatic inline long get_userns_rlimit_max(struct user_namespace *ns, enum rlimit_type type)\n{\n\treturn READ_ONCE(ns->rlimit_max[type]);\n}\n\nstatic inline void set_userns_rlimit_max(struct user_namespace *ns,\n\t\tenum rlimit_type type, unsigned long max)\n{\n\tns->rlimit_max[type] = max <= LONG_MAX ? max : LONG_MAX;\n}\n\n#ifdef CONFIG_USER_NS\n\nstatic inline struct user_namespace *get_user_ns(struct user_namespace *ns)\n{\n\tif (ns)\n\t\trefcount_inc(&ns->ns.count);\n\treturn ns;\n}\n\nextern int create_user_ns(struct cred *new);\nextern int unshare_userns(unsigned long unshare_flags, struct cred **new_cred);\nextern void __put_user_ns(struct user_namespace *ns);\n\nstatic inline void put_user_ns(struct user_namespace *ns)\n{\n\tif (ns && refcount_dec_and_test(&ns->ns.count))\n\t\t__put_user_ns(ns);\n}\n\nstruct seq_operations;\nextern const struct seq_operations proc_uid_seq_operations;\nextern const struct seq_operations proc_gid_seq_operations;\nextern const struct seq_operations proc_projid_seq_operations;\nextern ssize_t proc_uid_map_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t proc_gid_map_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t proc_projid_map_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t proc_setgroups_write(struct file *, const char __user *, size_t, loff_t *);\nextern int proc_setgroups_show(struct seq_file *m, void *v);\nextern bool userns_may_setgroups(const struct user_namespace *ns);\nextern bool in_userns(const struct user_namespace *ancestor,\n\t\t       const struct user_namespace *child);\nextern bool current_in_userns(const struct user_namespace *target_ns);\nstruct ns_common *ns_get_owner(struct ns_common *ns);\n#else\n\nstatic inline struct user_namespace *get_user_ns(struct user_namespace *ns)\n{\n\treturn &init_user_ns;\n}\n\nstatic inline int create_user_ns(struct cred *new)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int unshare_userns(unsigned long unshare_flags,\n\t\t\t\t struct cred **new_cred)\n{\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic inline void put_user_ns(struct user_namespace *ns)\n{\n}\n\nstatic inline bool userns_may_setgroups(const struct user_namespace *ns)\n{\n\treturn true;\n}\n\nstatic inline bool in_userns(const struct user_namespace *ancestor,\n\t\t\t     const struct user_namespace *child)\n{\n\treturn true;\n}\n\nstatic inline bool current_in_userns(const struct user_namespace *target_ns)\n{\n\treturn true;\n}\n\nstatic inline struct ns_common *ns_get_owner(struct ns_common *ns)\n{\n\treturn ERR_PTR(-EPERM);\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}