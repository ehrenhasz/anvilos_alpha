{
  "module_name": "pm_qos.h",
  "hash_id": "0a6c971a33d2d774a2a8a30d62ecaf6ac127c584a98ff071f59be5c75c271ae6",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/pm_qos.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_PM_QOS_H\n#define _LINUX_PM_QOS_H\n\n#include <linux/plist.h>\n#include <linux/notifier.h>\n#include <linux/device.h>\n\nenum pm_qos_flags_status {\n\tPM_QOS_FLAGS_UNDEFINED = -1,\n\tPM_QOS_FLAGS_NONE,\n\tPM_QOS_FLAGS_SOME,\n\tPM_QOS_FLAGS_ALL,\n};\n\n#define PM_QOS_DEFAULT_VALUE\t(-1)\n#define PM_QOS_LATENCY_ANY\tS32_MAX\n#define PM_QOS_LATENCY_ANY_NS\t((s64)PM_QOS_LATENCY_ANY * NSEC_PER_USEC)\n\n#define PM_QOS_CPU_LATENCY_DEFAULT_VALUE\t(2000 * USEC_PER_SEC)\n#define PM_QOS_RESUME_LATENCY_DEFAULT_VALUE\tPM_QOS_LATENCY_ANY\n#define PM_QOS_RESUME_LATENCY_NO_CONSTRAINT\tPM_QOS_LATENCY_ANY\n#define PM_QOS_RESUME_LATENCY_NO_CONSTRAINT_NS\tPM_QOS_LATENCY_ANY_NS\n#define PM_QOS_LATENCY_TOLERANCE_DEFAULT_VALUE\t0\n#define PM_QOS_MIN_FREQUENCY_DEFAULT_VALUE\t0\n#define PM_QOS_MAX_FREQUENCY_DEFAULT_VALUE\tFREQ_QOS_MAX_DEFAULT_VALUE\n#define PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT\t(-1)\n\n#define PM_QOS_FLAG_NO_POWER_OFF\t(1 << 0)\n\nenum pm_qos_type {\n\tPM_QOS_UNITIALIZED,\n\tPM_QOS_MAX,\t\t \n\tPM_QOS_MIN,\t\t \n};\n\n \nstruct pm_qos_constraints {\n\tstruct plist_head list;\n\ts32 target_value;\t \n\ts32 default_value;\n\ts32 no_constraint_value;\n\tenum pm_qos_type type;\n\tstruct blocking_notifier_head *notifiers;\n};\n\nstruct pm_qos_request {\n\tstruct plist_node node;\n\tstruct pm_qos_constraints *qos;\n};\n\nstruct pm_qos_flags_request {\n\tstruct list_head node;\n\ts32 flags;\t \n};\n\nstruct pm_qos_flags {\n\tstruct list_head list;\n\ts32 effective_flags;\t \n};\n\n\n#define FREQ_QOS_MIN_DEFAULT_VALUE\t0\n#define FREQ_QOS_MAX_DEFAULT_VALUE\tS32_MAX\n\nenum freq_qos_req_type {\n\tFREQ_QOS_MIN = 1,\n\tFREQ_QOS_MAX,\n};\n\nstruct freq_constraints {\n\tstruct pm_qos_constraints min_freq;\n\tstruct blocking_notifier_head min_freq_notifiers;\n\tstruct pm_qos_constraints max_freq;\n\tstruct blocking_notifier_head max_freq_notifiers;\n};\n\nstruct freq_qos_request {\n\tenum freq_qos_req_type type;\n\tstruct plist_node pnode;\n\tstruct freq_constraints *qos;\n};\n\n\nenum dev_pm_qos_req_type {\n\tDEV_PM_QOS_RESUME_LATENCY = 1,\n\tDEV_PM_QOS_LATENCY_TOLERANCE,\n\tDEV_PM_QOS_MIN_FREQUENCY,\n\tDEV_PM_QOS_MAX_FREQUENCY,\n\tDEV_PM_QOS_FLAGS,\n};\n\nstruct dev_pm_qos_request {\n\tenum dev_pm_qos_req_type type;\n\tunion {\n\t\tstruct plist_node pnode;\n\t\tstruct pm_qos_flags_request flr;\n\t\tstruct freq_qos_request freq;\n\t} data;\n\tstruct device *dev;\n};\n\nstruct dev_pm_qos {\n\tstruct pm_qos_constraints resume_latency;\n\tstruct pm_qos_constraints latency_tolerance;\n\tstruct freq_constraints freq;\n\tstruct pm_qos_flags flags;\n\tstruct dev_pm_qos_request *resume_latency_req;\n\tstruct dev_pm_qos_request *latency_tolerance_req;\n\tstruct dev_pm_qos_request *flags_req;\n};\n\n \nenum pm_qos_req_action {\n\tPM_QOS_ADD_REQ,\t\t \n\tPM_QOS_UPDATE_REQ,\t \n\tPM_QOS_REMOVE_REQ\t \n};\n\nstatic inline int dev_pm_qos_request_active(struct dev_pm_qos_request *req)\n{\n\treturn req->dev != NULL;\n}\n\ns32 pm_qos_read_value(struct pm_qos_constraints *c);\nint pm_qos_update_target(struct pm_qos_constraints *c, struct plist_node *node,\n\t\t\t enum pm_qos_req_action action, int value);\nbool pm_qos_update_flags(struct pm_qos_flags *pqf,\n\t\t\t struct pm_qos_flags_request *req,\n\t\t\t enum pm_qos_req_action action, s32 val);\n\n#ifdef CONFIG_CPU_IDLE\ns32 cpu_latency_qos_limit(void);\nbool cpu_latency_qos_request_active(struct pm_qos_request *req);\nvoid cpu_latency_qos_add_request(struct pm_qos_request *req, s32 value);\nvoid cpu_latency_qos_update_request(struct pm_qos_request *req, s32 new_value);\nvoid cpu_latency_qos_remove_request(struct pm_qos_request *req);\n#else\nstatic inline s32 cpu_latency_qos_limit(void) { return INT_MAX; }\nstatic inline bool cpu_latency_qos_request_active(struct pm_qos_request *req)\n{\n\treturn false;\n}\nstatic inline void cpu_latency_qos_add_request(struct pm_qos_request *req,\n\t\t\t\t\t       s32 value) {}\nstatic inline void cpu_latency_qos_update_request(struct pm_qos_request *req,\n\t\t\t\t\t\t  s32 new_value) {}\nstatic inline void cpu_latency_qos_remove_request(struct pm_qos_request *req) {}\n#endif\n\n#ifdef CONFIG_PM\nenum pm_qos_flags_status __dev_pm_qos_flags(struct device *dev, s32 mask);\nenum pm_qos_flags_status dev_pm_qos_flags(struct device *dev, s32 mask);\ns32 __dev_pm_qos_resume_latency(struct device *dev);\ns32 dev_pm_qos_read_value(struct device *dev, enum dev_pm_qos_req_type type);\nint dev_pm_qos_add_request(struct device *dev, struct dev_pm_qos_request *req,\n\t\t\t   enum dev_pm_qos_req_type type, s32 value);\nint dev_pm_qos_update_request(struct dev_pm_qos_request *req, s32 new_value);\nint dev_pm_qos_remove_request(struct dev_pm_qos_request *req);\nint dev_pm_qos_add_notifier(struct device *dev,\n\t\t\t    struct notifier_block *notifier,\n\t\t\t    enum dev_pm_qos_req_type type);\nint dev_pm_qos_remove_notifier(struct device *dev,\n\t\t\t       struct notifier_block *notifier,\n\t\t\t       enum dev_pm_qos_req_type type);\nvoid dev_pm_qos_constraints_init(struct device *dev);\nvoid dev_pm_qos_constraints_destroy(struct device *dev);\nint dev_pm_qos_add_ancestor_request(struct device *dev,\n\t\t\t\t    struct dev_pm_qos_request *req,\n\t\t\t\t    enum dev_pm_qos_req_type type, s32 value);\nint dev_pm_qos_expose_latency_limit(struct device *dev, s32 value);\nvoid dev_pm_qos_hide_latency_limit(struct device *dev);\nint dev_pm_qos_expose_flags(struct device *dev, s32 value);\nvoid dev_pm_qos_hide_flags(struct device *dev);\nint dev_pm_qos_update_flags(struct device *dev, s32 mask, bool set);\ns32 dev_pm_qos_get_user_latency_tolerance(struct device *dev);\nint dev_pm_qos_update_user_latency_tolerance(struct device *dev, s32 val);\nint dev_pm_qos_expose_latency_tolerance(struct device *dev);\nvoid dev_pm_qos_hide_latency_tolerance(struct device *dev);\n\nstatic inline s32 dev_pm_qos_requested_resume_latency(struct device *dev)\n{\n\treturn dev->power.qos->resume_latency_req->data.pnode.prio;\n}\n\nstatic inline s32 dev_pm_qos_requested_flags(struct device *dev)\n{\n\treturn dev->power.qos->flags_req->data.flr.flags;\n}\n\nstatic inline s32 dev_pm_qos_raw_resume_latency(struct device *dev)\n{\n\treturn IS_ERR_OR_NULL(dev->power.qos) ?\n\t\tPM_QOS_RESUME_LATENCY_NO_CONSTRAINT :\n\t\tpm_qos_read_value(&dev->power.qos->resume_latency);\n}\n#else\nstatic inline enum pm_qos_flags_status __dev_pm_qos_flags(struct device *dev,\n\t\t\t\t\t\t\t  s32 mask)\n\t\t\t{ return PM_QOS_FLAGS_UNDEFINED; }\nstatic inline enum pm_qos_flags_status dev_pm_qos_flags(struct device *dev,\n\t\t\t\t\t\t\ts32 mask)\n\t\t\t{ return PM_QOS_FLAGS_UNDEFINED; }\nstatic inline s32 __dev_pm_qos_resume_latency(struct device *dev)\n\t\t\t{ return PM_QOS_RESUME_LATENCY_NO_CONSTRAINT; }\nstatic inline s32 dev_pm_qos_read_value(struct device *dev,\n\t\t\t\t\tenum dev_pm_qos_req_type type)\n{\n\tswitch (type) {\n\tcase DEV_PM_QOS_RESUME_LATENCY:\n\t\treturn PM_QOS_RESUME_LATENCY_NO_CONSTRAINT;\n\tcase DEV_PM_QOS_MIN_FREQUENCY:\n\t\treturn PM_QOS_MIN_FREQUENCY_DEFAULT_VALUE;\n\tcase DEV_PM_QOS_MAX_FREQUENCY:\n\t\treturn PM_QOS_MAX_FREQUENCY_DEFAULT_VALUE;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n}\n\nstatic inline int dev_pm_qos_add_request(struct device *dev,\n\t\t\t\t\t struct dev_pm_qos_request *req,\n\t\t\t\t\t enum dev_pm_qos_req_type type,\n\t\t\t\t\t s32 value)\n\t\t\t{ return 0; }\nstatic inline int dev_pm_qos_update_request(struct dev_pm_qos_request *req,\n\t\t\t\t\t    s32 new_value)\n\t\t\t{ return 0; }\nstatic inline int dev_pm_qos_remove_request(struct dev_pm_qos_request *req)\n\t\t\t{ return 0; }\nstatic inline int dev_pm_qos_add_notifier(struct device *dev,\n\t\t\t\t\t  struct notifier_block *notifier,\n\t\t\t\t\t  enum dev_pm_qos_req_type type)\n\t\t\t{ return 0; }\nstatic inline int dev_pm_qos_remove_notifier(struct device *dev,\n\t\t\t\t\t     struct notifier_block *notifier,\n\t\t\t\t\t     enum dev_pm_qos_req_type type)\n\t\t\t{ return 0; }\nstatic inline void dev_pm_qos_constraints_init(struct device *dev)\n{\n\tdev->power.power_state = PMSG_ON;\n}\nstatic inline void dev_pm_qos_constraints_destroy(struct device *dev)\n{\n\tdev->power.power_state = PMSG_INVALID;\n}\nstatic inline int dev_pm_qos_add_ancestor_request(struct device *dev,\n\t\t\t\t\t\t  struct dev_pm_qos_request *req,\n\t\t\t\t\t\t  enum dev_pm_qos_req_type type,\n\t\t\t\t\t\t  s32 value)\n\t\t\t{ return 0; }\nstatic inline int dev_pm_qos_expose_latency_limit(struct device *dev, s32 value)\n\t\t\t{ return 0; }\nstatic inline void dev_pm_qos_hide_latency_limit(struct device *dev) {}\nstatic inline int dev_pm_qos_expose_flags(struct device *dev, s32 value)\n\t\t\t{ return 0; }\nstatic inline void dev_pm_qos_hide_flags(struct device *dev) {}\nstatic inline int dev_pm_qos_update_flags(struct device *dev, s32 m, bool set)\n\t\t\t{ return 0; }\nstatic inline s32 dev_pm_qos_get_user_latency_tolerance(struct device *dev)\n\t\t\t{ return PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT; }\nstatic inline int dev_pm_qos_update_user_latency_tolerance(struct device *dev, s32 val)\n\t\t\t{ return 0; }\nstatic inline int dev_pm_qos_expose_latency_tolerance(struct device *dev)\n\t\t\t{ return 0; }\nstatic inline void dev_pm_qos_hide_latency_tolerance(struct device *dev) {}\n\nstatic inline s32 dev_pm_qos_requested_resume_latency(struct device *dev)\n{\n\treturn PM_QOS_RESUME_LATENCY_NO_CONSTRAINT;\n}\nstatic inline s32 dev_pm_qos_requested_flags(struct device *dev) { return 0; }\nstatic inline s32 dev_pm_qos_raw_resume_latency(struct device *dev)\n{\n\treturn PM_QOS_RESUME_LATENCY_NO_CONSTRAINT;\n}\n#endif\n\nstatic inline int freq_qos_request_active(struct freq_qos_request *req)\n{\n\treturn !IS_ERR_OR_NULL(req->qos);\n}\n\nvoid freq_constraints_init(struct freq_constraints *qos);\n\ns32 freq_qos_read_value(struct freq_constraints *qos,\n\t\t\tenum freq_qos_req_type type);\n\nint freq_qos_add_request(struct freq_constraints *qos,\n\t\t\t struct freq_qos_request *req,\n\t\t\t enum freq_qos_req_type type, s32 value);\nint freq_qos_update_request(struct freq_qos_request *req, s32 new_value);\nint freq_qos_remove_request(struct freq_qos_request *req);\nint freq_qos_apply(struct freq_qos_request *req,\n\t\t   enum pm_qos_req_action action, s32 value);\n\nint freq_qos_add_notifier(struct freq_constraints *qos,\n\t\t\t  enum freq_qos_req_type type,\n\t\t\t  struct notifier_block *notifier);\nint freq_qos_remove_notifier(struct freq_constraints *qos,\n\t\t\t     enum freq_qos_req_type type,\n\t\t\t     struct notifier_block *notifier);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}