{
  "module_name": "ptp_classify.h",
  "hash_id": "1042575c8ba7356761018e99487924de59f71a95bf4662db3b83528d0b1f41f6",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ptp_classify.h",
  "human_readable_source": " \n \n\n#ifndef _PTP_CLASSIFY_H_\n#define _PTP_CLASSIFY_H_\n\n#include <asm/unaligned.h>\n#include <linux/ip.h>\n#include <linux/ktime.h>\n#include <linux/skbuff.h>\n#include <linux/udp.h>\n#include <net/checksum.h>\n\n#define PTP_CLASS_NONE  0x00  \n#define PTP_CLASS_V1    0x01  \n#define PTP_CLASS_V2    0x02  \n#define PTP_CLASS_VMASK 0x0f  \n#define PTP_CLASS_IPV4  0x10  \n#define PTP_CLASS_IPV6  0x20  \n#define PTP_CLASS_L2    0x40  \n#define PTP_CLASS_PMASK\t0x70  \n#define PTP_CLASS_VLAN\t0x80  \n\n#define PTP_CLASS_V1_IPV4 (PTP_CLASS_V1 | PTP_CLASS_IPV4)\n#define PTP_CLASS_V1_IPV6 (PTP_CLASS_V1 | PTP_CLASS_IPV6)  \n#define PTP_CLASS_V2_IPV4 (PTP_CLASS_V2 | PTP_CLASS_IPV4)\n#define PTP_CLASS_V2_IPV6 (PTP_CLASS_V2 | PTP_CLASS_IPV6)\n#define PTP_CLASS_V2_L2   (PTP_CLASS_V2 | PTP_CLASS_L2)\n#define PTP_CLASS_V2_VLAN (PTP_CLASS_V2 | PTP_CLASS_VLAN)\n#define PTP_CLASS_L4      (PTP_CLASS_IPV4 | PTP_CLASS_IPV6)\n\n#define PTP_MSGTYPE_SYNC        0x0\n#define PTP_MSGTYPE_DELAY_REQ   0x1\n#define PTP_MSGTYPE_PDELAY_REQ  0x2\n#define PTP_MSGTYPE_PDELAY_RESP 0x3\n\n#define PTP_EV_PORT 319\n#define PTP_GEN_PORT 320\n#define PTP_GEN_BIT 0x08  \n\n#define OFF_PTP_SOURCE_UUID\t22  \n#define OFF_PTP_SEQUENCE_ID\t30\n\n \n#define PTP_FLAG_TWOSTEP\tBIT(1)\n\n \n#define IP6_HLEN\t40\n#define UDP_HLEN\t8\n#define OFF_IHL\t\t14\n#define IPV4_HLEN(data) (((struct iphdr *)(data + OFF_IHL))->ihl << 2)\n\nstruct clock_identity {\n\tu8 id[8];\n} __packed;\n\nstruct port_identity {\n\tstruct clock_identity\tclock_identity;\n\t__be16\t\t\tport_number;\n} __packed;\n\nstruct ptp_header {\n\tu8\t\t\ttsmt;   \n\tu8\t\t\tver;    \n\t__be16\t\t\tmessage_length;\n\tu8\t\t\tdomain_number;\n\tu8\t\t\treserved1;\n\tu8\t\t\tflag_field[2];\n\t__be64\t\t\tcorrection;\n\t__be32\t\t\treserved2;\n\tstruct port_identity\tsource_port_identity;\n\t__be16\t\t\tsequence_id;\n\tu8\t\t\tcontrol;\n\tu8\t\t\tlog_message_interval;\n} __packed;\n\n#if defined(CONFIG_NET_PTP_CLASSIFY)\n \nunsigned int ptp_classify_raw(const struct sk_buff *skb);\n\n \nstruct ptp_header *ptp_parse_header(struct sk_buff *skb, unsigned int type);\n\n \nstatic inline u8 ptp_get_msgtype(const struct ptp_header *hdr,\n\t\t\t\t unsigned int type)\n{\n\tu8 msgtype;\n\n\tif (unlikely(type & PTP_CLASS_V1)) {\n\t\t \n\t\tmsgtype = hdr->control;\n\t} else {\n\t\tmsgtype = hdr->tsmt & 0x0f;\n\t}\n\n\treturn msgtype;\n}\n\n \nstatic inline __wsum ptp_check_diff8(__be64 old, __be64 new, __wsum oldsum)\n{\n\t__be64 diff[2] = { ~old, new };\n\n\treturn csum_partial(diff, sizeof(diff), oldsum);\n}\n\n \nstatic inline\nvoid ptp_header_update_correction(struct sk_buff *skb, unsigned int type,\n\t\t\t\t  struct ptp_header *hdr, s64 correction)\n{\n\t__be64 correction_old;\n\tstruct udphdr *uhdr;\n\n\t \n\tmemcpy(&correction_old,  &hdr->correction, sizeof(correction_old));\n\n\t \n\tput_unaligned_be64((u64)correction, &hdr->correction);\n\n\tswitch (type & PTP_CLASS_PMASK) {\n\tcase PTP_CLASS_IPV4:\n\tcase PTP_CLASS_IPV6:\n\t\t \n\t\tuhdr = (struct udphdr *)((char *)hdr - sizeof(struct udphdr));\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tuhdr->check = csum_fold(ptp_check_diff8(correction_old,\n\t\t\t\t\t\thdr->correction,\n\t\t\t\t\t\t~csum_unfold(uhdr->check)));\n\tif (!uhdr->check)\n\t\tuhdr->check = CSUM_MANGLED_0;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n}\n\n \nbool ptp_msg_is_sync(struct sk_buff *skb, unsigned int type);\n\nvoid __init ptp_classifier_init(void);\n#else\nstatic inline void ptp_classifier_init(void)\n{\n}\nstatic inline unsigned int ptp_classify_raw(struct sk_buff *skb)\n{\n\treturn PTP_CLASS_NONE;\n}\nstatic inline struct ptp_header *ptp_parse_header(struct sk_buff *skb,\n\t\t\t\t\t\t  unsigned int type)\n{\n\treturn NULL;\n}\nstatic inline u8 ptp_get_msgtype(const struct ptp_header *hdr,\n\t\t\t\t unsigned int type)\n{\n\t \n\treturn PTP_MSGTYPE_SYNC;\n}\nstatic inline bool ptp_msg_is_sync(struct sk_buff *skb, unsigned int type)\n{\n\treturn false;\n}\n\nstatic inline\nvoid ptp_header_update_correction(struct sk_buff *skb, unsigned int type,\n\t\t\t\t  struct ptp_header *hdr, s64 correction)\n{\n}\n#endif\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}