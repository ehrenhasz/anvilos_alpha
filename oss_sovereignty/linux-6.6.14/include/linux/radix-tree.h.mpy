{
  "module_name": "radix-tree.h",
  "hash_id": "5ea748b0407df48df7b1cccb08a6e74dde44156fb8805bdeeb0f58ced9ff9bf2",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/radix-tree.h",
  "human_readable_source": " \n \n#ifndef _LINUX_RADIX_TREE_H\n#define _LINUX_RADIX_TREE_H\n\n#include <linux/bitops.h>\n#include <linux/gfp_types.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/math.h>\n#include <linux/percpu.h>\n#include <linux/preempt.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/xarray.h>\n#include <linux/local_lock.h>\n\n \n#define radix_tree_root\t\txarray\n#define radix_tree_node\t\txa_node\n\nstruct radix_tree_preload {\n\tlocal_lock_t lock;\n\tunsigned nr;\n\t \n\tstruct radix_tree_node *nodes;\n};\nDECLARE_PER_CPU(struct radix_tree_preload, radix_tree_preloads);\n\n \n#define RADIX_TREE_ENTRY_MASK\t\t3UL\n#define RADIX_TREE_INTERNAL_NODE\t2UL\n\nstatic inline bool radix_tree_is_internal_node(void *ptr)\n{\n\treturn ((unsigned long)ptr & RADIX_TREE_ENTRY_MASK) ==\n\t\t\t\tRADIX_TREE_INTERNAL_NODE;\n}\n\n \n\n#define RADIX_TREE_MAP_SHIFT\tXA_CHUNK_SHIFT\n#define RADIX_TREE_MAP_SIZE\t(1UL << RADIX_TREE_MAP_SHIFT)\n#define RADIX_TREE_MAP_MASK\t(RADIX_TREE_MAP_SIZE-1)\n\n#define RADIX_TREE_MAX_TAGS\tXA_MAX_MARKS\n#define RADIX_TREE_TAG_LONGS\tXA_MARK_LONGS\n\n#define RADIX_TREE_INDEX_BITS  (8   * sizeof(unsigned long))\n#define RADIX_TREE_MAX_PATH (DIV_ROUND_UP(RADIX_TREE_INDEX_BITS, \\\n\t\t\t\t\t  RADIX_TREE_MAP_SHIFT))\n\n \n#define ROOT_IS_IDR\t((__force gfp_t)4)\n \n#define ROOT_TAG_SHIFT\t(__GFP_BITS_SHIFT)\n\n#define RADIX_TREE_INIT(name, mask)\tXARRAY_INIT(name, mask)\n\n#define RADIX_TREE(name, mask) \\\n\tstruct radix_tree_root name = RADIX_TREE_INIT(name, mask)\n\n#define INIT_RADIX_TREE(root, mask) xa_init_flags(root, mask)\n\nstatic inline bool radix_tree_empty(const struct radix_tree_root *root)\n{\n\treturn root->xa_head == NULL;\n}\n\n \nstruct radix_tree_iter {\n\tunsigned long\tindex;\n\tunsigned long\tnext_index;\n\tunsigned long\ttags;\n\tstruct radix_tree_node *node;\n};\n\n \n\n \nstatic inline void *radix_tree_deref_slot(void __rcu **slot)\n{\n\treturn rcu_dereference(*slot);\n}\n\n \nstatic inline void *radix_tree_deref_slot_protected(void __rcu **slot,\n\t\t\t\t\t\t\tspinlock_t *treelock)\n{\n\treturn rcu_dereference_protected(*slot, lockdep_is_held(treelock));\n}\n\n \nstatic inline int radix_tree_deref_retry(void *arg)\n{\n\treturn unlikely(radix_tree_is_internal_node(arg));\n}\n\n \nstatic inline int radix_tree_exception(void *arg)\n{\n\treturn unlikely((unsigned long)arg & RADIX_TREE_ENTRY_MASK);\n}\n\nint radix_tree_insert(struct radix_tree_root *, unsigned long index,\n\t\t\tvoid *);\nvoid *__radix_tree_lookup(const struct radix_tree_root *, unsigned long index,\n\t\t\t  struct radix_tree_node **nodep, void __rcu ***slotp);\nvoid *radix_tree_lookup(const struct radix_tree_root *, unsigned long);\nvoid __rcu **radix_tree_lookup_slot(const struct radix_tree_root *,\n\t\t\t\t\tunsigned long index);\nvoid __radix_tree_replace(struct radix_tree_root *, struct radix_tree_node *,\n\t\t\t  void __rcu **slot, void *entry);\nvoid radix_tree_iter_replace(struct radix_tree_root *,\n\t\tconst struct radix_tree_iter *, void __rcu **slot, void *entry);\nvoid radix_tree_replace_slot(struct radix_tree_root *,\n\t\t\t     void __rcu **slot, void *entry);\nvoid radix_tree_iter_delete(struct radix_tree_root *,\n\t\t\tstruct radix_tree_iter *iter, void __rcu **slot);\nvoid *radix_tree_delete_item(struct radix_tree_root *, unsigned long, void *);\nvoid *radix_tree_delete(struct radix_tree_root *, unsigned long);\nunsigned int radix_tree_gang_lookup(const struct radix_tree_root *,\n\t\t\tvoid **results, unsigned long first_index,\n\t\t\tunsigned int max_items);\nint radix_tree_preload(gfp_t gfp_mask);\nint radix_tree_maybe_preload(gfp_t gfp_mask);\nvoid radix_tree_init(void);\nvoid *radix_tree_tag_set(struct radix_tree_root *,\n\t\t\tunsigned long index, unsigned int tag);\nvoid *radix_tree_tag_clear(struct radix_tree_root *,\n\t\t\tunsigned long index, unsigned int tag);\nint radix_tree_tag_get(const struct radix_tree_root *,\n\t\t\tunsigned long index, unsigned int tag);\nvoid radix_tree_iter_tag_clear(struct radix_tree_root *,\n\t\tconst struct radix_tree_iter *iter, unsigned int tag);\nunsigned int radix_tree_gang_lookup_tag(const struct radix_tree_root *,\n\t\tvoid **results, unsigned long first_index,\n\t\tunsigned int max_items, unsigned int tag);\nunsigned int radix_tree_gang_lookup_tag_slot(const struct radix_tree_root *,\n\t\tvoid __rcu ***results, unsigned long first_index,\n\t\tunsigned int max_items, unsigned int tag);\nint radix_tree_tagged(const struct radix_tree_root *, unsigned int tag);\n\nstatic inline void radix_tree_preload_end(void)\n{\n\tlocal_unlock(&radix_tree_preloads.lock);\n}\n\nvoid __rcu **idr_get_free(struct radix_tree_root *root,\n\t\t\t      struct radix_tree_iter *iter, gfp_t gfp,\n\t\t\t      unsigned long max);\n\nenum {\n\tRADIX_TREE_ITER_TAG_MASK = 0x0f,\t \n\tRADIX_TREE_ITER_TAGGED   = 0x10,\t \n\tRADIX_TREE_ITER_CONTIG   = 0x20,\t \n};\n\n \nstatic __always_inline void __rcu **\nradix_tree_iter_init(struct radix_tree_iter *iter, unsigned long start)\n{\n\t \n\titer->index = 0;\n\titer->next_index = start;\n\treturn NULL;\n}\n\n \nvoid __rcu **radix_tree_next_chunk(const struct radix_tree_root *,\n\t\t\t     struct radix_tree_iter *iter, unsigned flags);\n\n \nstatic inline void __rcu **\nradix_tree_iter_lookup(const struct radix_tree_root *root,\n\t\t\tstruct radix_tree_iter *iter, unsigned long index)\n{\n\tradix_tree_iter_init(iter, index);\n\treturn radix_tree_next_chunk(root, iter, RADIX_TREE_ITER_CONTIG);\n}\n\n \nstatic inline __must_check\nvoid __rcu **radix_tree_iter_retry(struct radix_tree_iter *iter)\n{\n\titer->next_index = iter->index;\n\titer->tags = 0;\n\treturn NULL;\n}\n\nstatic inline unsigned long\n__radix_tree_iter_add(struct radix_tree_iter *iter, unsigned long slots)\n{\n\treturn iter->index + slots;\n}\n\n \nvoid __rcu **__must_check radix_tree_iter_resume(void __rcu **slot,\n\t\t\t\t\tstruct radix_tree_iter *iter);\n\n \nstatic __always_inline long\nradix_tree_chunk_size(struct radix_tree_iter *iter)\n{\n\treturn iter->next_index - iter->index;\n}\n\n \nstatic __always_inline void __rcu **radix_tree_next_slot(void __rcu **slot,\n\t\t\t\tstruct radix_tree_iter *iter, unsigned flags)\n{\n\tif (flags & RADIX_TREE_ITER_TAGGED) {\n\t\titer->tags >>= 1;\n\t\tif (unlikely(!iter->tags))\n\t\t\treturn NULL;\n\t\tif (likely(iter->tags & 1ul)) {\n\t\t\titer->index = __radix_tree_iter_add(iter, 1);\n\t\t\tslot++;\n\t\t\tgoto found;\n\t\t}\n\t\tif (!(flags & RADIX_TREE_ITER_CONTIG)) {\n\t\t\tunsigned offset = __ffs(iter->tags);\n\n\t\t\titer->tags >>= offset++;\n\t\t\titer->index = __radix_tree_iter_add(iter, offset);\n\t\t\tslot += offset;\n\t\t\tgoto found;\n\t\t}\n\t} else {\n\t\tlong count = radix_tree_chunk_size(iter);\n\n\t\twhile (--count > 0) {\n\t\t\tslot++;\n\t\t\titer->index = __radix_tree_iter_add(iter, 1);\n\n\t\t\tif (likely(*slot))\n\t\t\t\tgoto found;\n\t\t\tif (flags & RADIX_TREE_ITER_CONTIG) {\n\t\t\t\t \n\t\t\t\titer->next_index = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n\n found:\n\treturn slot;\n}\n\n \n#define radix_tree_for_each_slot(slot, root, iter, start)\t\t\\\n\tfor (slot = radix_tree_iter_init(iter, start) ;\t\t\t\\\n\t     slot || (slot = radix_tree_next_chunk(root, iter, 0)) ;\t\\\n\t     slot = radix_tree_next_slot(slot, iter, 0))\n\n \n#define radix_tree_for_each_tagged(slot, root, iter, start, tag)\t\\\n\tfor (slot = radix_tree_iter_init(iter, start) ;\t\t\t\\\n\t     slot || (slot = radix_tree_next_chunk(root, iter,\t\t\\\n\t\t\t      RADIX_TREE_ITER_TAGGED | tag)) ;\t\t\\\n\t     slot = radix_tree_next_slot(slot, iter,\t\t\t\\\n\t\t\t\tRADIX_TREE_ITER_TAGGED | tag))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}