{
  "module_name": "nfs_page.h",
  "hash_id": "b5222dc7b4f418d86c9fdfa171000aec3edf7a975a7bd2379d017223885a1dff",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/nfs_page.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_NFS_PAGE_H\n#define _LINUX_NFS_PAGE_H\n\n\n#include <linux/list.h>\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/nfs_xdr.h>\n\n#include <linux/kref.h>\n\n \nenum {\n\tPG_BUSY = 0,\t\t \n\tPG_MAPPED,\t\t \n\tPG_FOLIO,\t\t \n\tPG_CLEAN,\t\t \n\tPG_COMMIT_TO_DS,\t \n\tPG_INODE_REF,\t\t \n\tPG_HEADLOCK,\t\t \n\tPG_TEARDOWN,\t\t \n\tPG_UNLOCKPAGE,\t\t \n\tPG_UPTODATE,\t\t \n\tPG_WB_END,\t\t \n\tPG_REMOVE,\t\t \n\tPG_CONTENDED1,\t\t \n\tPG_CONTENDED2,\t\t \n};\n\nstruct nfs_inode;\nstruct nfs_page {\n\tstruct list_head\twb_list;\t \n\tunion {\n\t\tstruct page\t*wb_page;\t \n\t\tstruct folio\t*wb_folio;\n\t};\n\tstruct nfs_lock_context\t*wb_lock_context;\t \n\tpgoff_t\t\t\twb_index;\t \n\tunsigned int\t\twb_offset,\t \n\t\t\t\twb_pgbase,\t \n\t\t\t\twb_bytes;\t \n\tstruct kref\t\twb_kref;\t \n\tunsigned long\t\twb_flags;\n\tstruct nfs_write_verifier\twb_verf;\t \n\tstruct nfs_page\t\t*wb_this_page;   \n\tstruct nfs_page\t\t*wb_head;        \n\tunsigned short\t\twb_nio;\t\t \n};\n\nstruct nfs_pgio_mirror;\nstruct nfs_pageio_descriptor;\nstruct nfs_pageio_ops {\n\tvoid\t(*pg_init)(struct nfs_pageio_descriptor *, struct nfs_page *);\n\tsize_t\t(*pg_test)(struct nfs_pageio_descriptor *, struct nfs_page *,\n\t\t\t   struct nfs_page *);\n\tint\t(*pg_doio)(struct nfs_pageio_descriptor *);\n\tunsigned int\t(*pg_get_mirror_count)(struct nfs_pageio_descriptor *,\n\t\t\t\t       struct nfs_page *);\n\tvoid\t(*pg_cleanup)(struct nfs_pageio_descriptor *);\n\tstruct nfs_pgio_mirror *\n\t\t(*pg_get_mirror)(struct nfs_pageio_descriptor *, u32);\n\tu32\t(*pg_set_mirror)(struct nfs_pageio_descriptor *, u32);\n};\n\nstruct nfs_rw_ops {\n\tstruct nfs_pgio_header *(*rw_alloc_header)(void);\n\tvoid (*rw_free_header)(struct nfs_pgio_header *);\n\tint  (*rw_done)(struct rpc_task *, struct nfs_pgio_header *,\n\t\t\tstruct inode *);\n\tvoid (*rw_result)(struct rpc_task *, struct nfs_pgio_header *);\n\tvoid (*rw_initiate)(struct nfs_pgio_header *, struct rpc_message *,\n\t\t\t    const struct nfs_rpc_ops *,\n\t\t\t    struct rpc_task_setup *, int);\n};\n\nstruct nfs_pgio_mirror {\n\tstruct list_head\tpg_list;\n\tunsigned long\t\tpg_bytes_written;\n\tsize_t\t\t\tpg_count;\n\tsize_t\t\t\tpg_bsize;\n\tunsigned int\t\tpg_base;\n\tunsigned char\t\tpg_recoalesce : 1;\n};\n\nstruct nfs_pageio_descriptor {\n\tstruct inode\t\t*pg_inode;\n\tconst struct nfs_pageio_ops *pg_ops;\n\tconst struct nfs_rw_ops *pg_rw_ops;\n\tint \t\t\tpg_ioflags;\n\tint\t\t\tpg_error;\n\tconst struct rpc_call_ops *pg_rpc_callops;\n\tconst struct nfs_pgio_completion_ops *pg_completion_ops;\n\tstruct pnfs_layout_segment *pg_lseg;\n\tstruct nfs_io_completion *pg_io_completion;\n\tstruct nfs_direct_req\t*pg_dreq;\n#ifdef CONFIG_NFS_FSCACHE\n\tvoid\t\t\t*pg_netfs;\n#endif\n\tunsigned int\t\tpg_bsize;\t \n\n\tu32\t\t\tpg_mirror_count;\n\tstruct nfs_pgio_mirror\t*pg_mirrors;\n\tstruct nfs_pgio_mirror\tpg_mirrors_static[1];\n\tstruct nfs_pgio_mirror\t*pg_mirrors_dynamic;\n\tu32\t\t\tpg_mirror_idx;\t \n\tunsigned short\t\tpg_maxretrans;\n\tunsigned char\t\tpg_moreio : 1;\n};\n\n \n#define NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX 16\n\n#define NFS_WBACK_BUSY(req)\t(test_bit(PG_BUSY,&(req)->wb_flags))\n\nextern struct nfs_page *nfs_page_create_from_page(struct nfs_open_context *ctx,\n\t\t\t\t\t\t  struct page *page,\n\t\t\t\t\t\t  unsigned int pgbase,\n\t\t\t\t\t\t  loff_t offset,\n\t\t\t\t\t\t  unsigned int count);\nextern struct nfs_page *nfs_page_create_from_folio(struct nfs_open_context *ctx,\n\t\t\t\t\t\t   struct folio *folio,\n\t\t\t\t\t\t   unsigned int offset,\n\t\t\t\t\t\t   unsigned int count);\nextern\tvoid nfs_release_request(struct nfs_page *);\n\n\nextern\tvoid nfs_pageio_init(struct nfs_pageio_descriptor *desc,\n\t\t\t     struct inode *inode,\n\t\t\t     const struct nfs_pageio_ops *pg_ops,\n\t\t\t     const struct nfs_pgio_completion_ops *compl_ops,\n\t\t\t     const struct nfs_rw_ops *rw_ops,\n\t\t\t     size_t bsize,\n\t\t\t     int how);\nextern\tint nfs_pageio_add_request(struct nfs_pageio_descriptor *,\n\t\t\t\t   struct nfs_page *);\nextern  int nfs_pageio_resend(struct nfs_pageio_descriptor *,\n\t\t\t      struct nfs_pgio_header *);\nextern\tvoid nfs_pageio_complete(struct nfs_pageio_descriptor *desc);\nextern\tvoid nfs_pageio_cond_complete(struct nfs_pageio_descriptor *, pgoff_t);\nextern size_t nfs_generic_pg_test(struct nfs_pageio_descriptor *desc,\n\t\t\t\tstruct nfs_page *prev,\n\t\t\t\tstruct nfs_page *req);\nextern  int nfs_wait_on_request(struct nfs_page *);\nextern\tvoid nfs_unlock_request(struct nfs_page *req);\nextern\tvoid nfs_unlock_and_release_request(struct nfs_page *);\nextern\tstruct nfs_page *nfs_page_group_lock_head(struct nfs_page *req);\nextern\tint nfs_page_group_lock_subrequests(struct nfs_page *head);\nextern void nfs_join_page_group(struct nfs_page *head,\n\t\t\t\tstruct nfs_commit_info *cinfo,\n\t\t\t\tstruct inode *inode);\nextern int nfs_page_group_lock(struct nfs_page *);\nextern void nfs_page_group_unlock(struct nfs_page *);\nextern bool nfs_page_group_sync_on_bit(struct nfs_page *, unsigned int);\nextern\tint nfs_page_set_headlock(struct nfs_page *req);\nextern void nfs_page_clear_headlock(struct nfs_page *req);\nextern bool nfs_async_iocounter_wait(struct rpc_task *, struct nfs_lock_context *);\n\n \nstatic inline struct folio *nfs_page_to_folio(const struct nfs_page *req)\n{\n\tif (test_bit(PG_FOLIO, &req->wb_flags))\n\t\treturn req->wb_folio;\n\treturn NULL;\n}\n\n \nstatic inline struct page *nfs_page_to_page(const struct nfs_page *req,\n\t\t\t\t\t    size_t pgbase)\n{\n\tstruct folio *folio = nfs_page_to_folio(req);\n\n\tif (folio == NULL)\n\t\treturn req->wb_page;\n\treturn folio_page(folio, pgbase >> PAGE_SHIFT);\n}\n\n \nstatic inline struct inode *nfs_page_to_inode(const struct nfs_page *req)\n{\n\tstruct folio *folio = nfs_page_to_folio(req);\n\n\tif (folio == NULL)\n\t\treturn page_file_mapping(req->wb_page)->host;\n\treturn folio_file_mapping(folio)->host;\n}\n\n \nstatic inline size_t nfs_page_max_length(const struct nfs_page *req)\n{\n\tstruct folio *folio = nfs_page_to_folio(req);\n\n\tif (folio == NULL)\n\t\treturn PAGE_SIZE;\n\treturn folio_size(folio);\n}\n\n \nstatic inline int\nnfs_lock_request(struct nfs_page *req)\n{\n\treturn !test_and_set_bit(PG_BUSY, &req->wb_flags);\n}\n\n \nstatic inline void\nnfs_list_add_request(struct nfs_page *req, struct list_head *head)\n{\n\tlist_add_tail(&req->wb_list, head);\n}\n\n \nstatic inline void\nnfs_list_move_request(struct nfs_page *req, struct list_head *head)\n{\n\tlist_move_tail(&req->wb_list, head);\n}\n\n \nstatic inline void\nnfs_list_remove_request(struct nfs_page *req)\n{\n\tif (list_empty(&req->wb_list))\n\t\treturn;\n\tlist_del_init(&req->wb_list);\n}\n\nstatic inline struct nfs_page *\nnfs_list_entry(struct list_head *head)\n{\n\treturn list_entry(head, struct nfs_page, wb_list);\n}\n\nstatic inline loff_t req_offset(const struct nfs_page *req)\n{\n\treturn (((loff_t)req->wb_index) << PAGE_SHIFT) + req->wb_offset;\n}\n\nstatic inline struct nfs_open_context *\nnfs_req_openctx(struct nfs_page *req)\n{\n\treturn req->wb_lock_context->open_context;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}