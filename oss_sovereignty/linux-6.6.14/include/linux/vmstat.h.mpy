{
  "module_name": "vmstat.h",
  "hash_id": "d44b9a4a42dc98bfa9d69f41c0d0e5e4341fb2c55f4986daae5140c5c68d5e1a",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/vmstat.h",
  "human_readable_source": " \n#ifndef _LINUX_VMSTAT_H\n#define _LINUX_VMSTAT_H\n\n#include <linux/types.h>\n#include <linux/percpu.h>\n#include <linux/mmzone.h>\n#include <linux/vm_event_item.h>\n#include <linux/atomic.h>\n#include <linux/static_key.h>\n#include <linux/mmdebug.h>\n\nextern int sysctl_stat_interval;\n\n#ifdef CONFIG_NUMA\n#define ENABLE_NUMA_STAT   1\n#define DISABLE_NUMA_STAT   0\nextern int sysctl_vm_numa_stat;\nDECLARE_STATIC_KEY_TRUE(vm_numa_stat_key);\nint sysctl_vm_numa_stat_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *length, loff_t *ppos);\n#endif\n\nstruct reclaim_stat {\n\tunsigned nr_dirty;\n\tunsigned nr_unqueued_dirty;\n\tunsigned nr_congested;\n\tunsigned nr_writeback;\n\tunsigned nr_immediate;\n\tunsigned nr_pageout;\n\tunsigned nr_activate[ANON_AND_FILE];\n\tunsigned nr_ref_keep;\n\tunsigned nr_unmap_fail;\n\tunsigned nr_lazyfree_fail;\n};\n\nenum writeback_stat_item {\n\tNR_DIRTY_THRESHOLD,\n\tNR_DIRTY_BG_THRESHOLD,\n\tNR_VM_WRITEBACK_STAT_ITEMS,\n};\n\n#ifdef CONFIG_VM_EVENT_COUNTERS\n \n\nstruct vm_event_state {\n\tunsigned long event[NR_VM_EVENT_ITEMS];\n};\n\nDECLARE_PER_CPU(struct vm_event_state, vm_event_states);\n\n \nstatic inline void __count_vm_event(enum vm_event_item item)\n{\n\traw_cpu_inc(vm_event_states.event[item]);\n}\n\nstatic inline void count_vm_event(enum vm_event_item item)\n{\n\tthis_cpu_inc(vm_event_states.event[item]);\n}\n\nstatic inline void __count_vm_events(enum vm_event_item item, long delta)\n{\n\traw_cpu_add(vm_event_states.event[item], delta);\n}\n\nstatic inline void count_vm_events(enum vm_event_item item, long delta)\n{\n\tthis_cpu_add(vm_event_states.event[item], delta);\n}\n\nextern void all_vm_events(unsigned long *);\n\nextern void vm_events_fold_cpu(int cpu);\n\n#else\n\n \nstatic inline void count_vm_event(enum vm_event_item item)\n{\n}\nstatic inline void count_vm_events(enum vm_event_item item, long delta)\n{\n}\nstatic inline void __count_vm_event(enum vm_event_item item)\n{\n}\nstatic inline void __count_vm_events(enum vm_event_item item, long delta)\n{\n}\nstatic inline void all_vm_events(unsigned long *ret)\n{\n}\nstatic inline void vm_events_fold_cpu(int cpu)\n{\n}\n\n#endif  \n\n#ifdef CONFIG_NUMA_BALANCING\n#define count_vm_numa_event(x)     count_vm_event(x)\n#define count_vm_numa_events(x, y) count_vm_events(x, y)\n#else\n#define count_vm_numa_event(x) do {} while (0)\n#define count_vm_numa_events(x, y) do { (void)(y); } while (0)\n#endif  \n\n#ifdef CONFIG_DEBUG_TLBFLUSH\n#define count_vm_tlb_event(x)\t   count_vm_event(x)\n#define count_vm_tlb_events(x, y)  count_vm_events(x, y)\n#else\n#define count_vm_tlb_event(x)     do {} while (0)\n#define count_vm_tlb_events(x, y) do { (void)(y); } while (0)\n#endif\n\n#ifdef CONFIG_PER_VMA_LOCK_STATS\n#define count_vm_vma_lock_event(x) count_vm_event(x)\n#else\n#define count_vm_vma_lock_event(x) do {} while (0)\n#endif\n\n#define __count_zid_vm_events(item, zid, delta) \\\n\t__count_vm_events(item##_NORMAL - ZONE_NORMAL + zid, delta)\n\n \nextern atomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS];\nextern atomic_long_t vm_node_stat[NR_VM_NODE_STAT_ITEMS];\nextern atomic_long_t vm_numa_event[NR_VM_NUMA_EVENT_ITEMS];\n\n#ifdef CONFIG_NUMA\nstatic inline void zone_numa_event_add(long x, struct zone *zone,\n\t\t\t\tenum numa_stat_item item)\n{\n\tatomic_long_add(x, &zone->vm_numa_event[item]);\n\tatomic_long_add(x, &vm_numa_event[item]);\n}\n\nstatic inline unsigned long zone_numa_event_state(struct zone *zone,\n\t\t\t\t\tenum numa_stat_item item)\n{\n\treturn atomic_long_read(&zone->vm_numa_event[item]);\n}\n\nstatic inline unsigned long\nglobal_numa_event_state(enum numa_stat_item item)\n{\n\treturn atomic_long_read(&vm_numa_event[item]);\n}\n#endif  \n\nstatic inline void zone_page_state_add(long x, struct zone *zone,\n\t\t\t\t enum zone_stat_item item)\n{\n\tatomic_long_add(x, &zone->vm_stat[item]);\n\tatomic_long_add(x, &vm_zone_stat[item]);\n}\n\nstatic inline void node_page_state_add(long x, struct pglist_data *pgdat,\n\t\t\t\t enum node_stat_item item)\n{\n\tatomic_long_add(x, &pgdat->vm_stat[item]);\n\tatomic_long_add(x, &vm_node_stat[item]);\n}\n\nstatic inline unsigned long global_zone_page_state(enum zone_stat_item item)\n{\n\tlong x = atomic_long_read(&vm_zone_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}\n\nstatic inline\nunsigned long global_node_page_state_pages(enum node_stat_item item)\n{\n\tlong x = atomic_long_read(&vm_node_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}\n\nstatic inline unsigned long global_node_page_state(enum node_stat_item item)\n{\n\tVM_WARN_ON_ONCE(vmstat_item_in_bytes(item));\n\n\treturn global_node_page_state_pages(item);\n}\n\nstatic inline unsigned long zone_page_state(struct zone *zone,\n\t\t\t\t\tenum zone_stat_item item)\n{\n\tlong x = atomic_long_read(&zone->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}\n\n \nstatic inline unsigned long zone_page_state_snapshot(struct zone *zone,\n\t\t\t\t\tenum zone_stat_item item)\n{\n\tlong x = atomic_long_read(&zone->vm_stat[item]);\n\n#ifdef CONFIG_SMP\n\tint cpu;\n\tfor_each_online_cpu(cpu)\n\t\tx += per_cpu_ptr(zone->per_cpu_zonestats, cpu)->vm_stat_diff[item];\n\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}\n\n#ifdef CONFIG_NUMA\n \nstatic inline void\n__count_numa_event(struct zone *zone, enum numa_stat_item item)\n{\n\tstruct per_cpu_zonestat __percpu *pzstats = zone->per_cpu_zonestats;\n\n\traw_cpu_inc(pzstats->vm_numa_event[item]);\n}\n\nstatic inline void\n__count_numa_events(struct zone *zone, enum numa_stat_item item, long delta)\n{\n\tstruct per_cpu_zonestat __percpu *pzstats = zone->per_cpu_zonestats;\n\n\traw_cpu_add(pzstats->vm_numa_event[item], delta);\n}\n\nextern unsigned long sum_zone_node_page_state(int node,\n\t\t\t\t\t      enum zone_stat_item item);\nextern unsigned long sum_zone_numa_event_state(int node, enum numa_stat_item item);\nextern unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\t\t\tenum node_stat_item item);\nextern unsigned long node_page_state_pages(struct pglist_data *pgdat,\n\t\t\t\t\t   enum node_stat_item item);\nextern void fold_vm_numa_events(void);\n#else\n#define sum_zone_node_page_state(node, item) global_zone_page_state(item)\n#define node_page_state(node, item) global_node_page_state(item)\n#define node_page_state_pages(node, item) global_node_page_state_pages(item)\nstatic inline void fold_vm_numa_events(void)\n{\n}\n#endif  \n\n#ifdef CONFIG_SMP\nvoid __mod_zone_page_state(struct zone *, enum zone_stat_item item, long);\nvoid __inc_zone_page_state(struct page *, enum zone_stat_item);\nvoid __dec_zone_page_state(struct page *, enum zone_stat_item);\n\nvoid __mod_node_page_state(struct pglist_data *, enum node_stat_item item, long);\nvoid __inc_node_page_state(struct page *, enum node_stat_item);\nvoid __dec_node_page_state(struct page *, enum node_stat_item);\n\nvoid mod_zone_page_state(struct zone *, enum zone_stat_item, long);\nvoid inc_zone_page_state(struct page *, enum zone_stat_item);\nvoid dec_zone_page_state(struct page *, enum zone_stat_item);\n\nvoid mod_node_page_state(struct pglist_data *, enum node_stat_item, long);\nvoid inc_node_page_state(struct page *, enum node_stat_item);\nvoid dec_node_page_state(struct page *, enum node_stat_item);\n\nextern void inc_node_state(struct pglist_data *, enum node_stat_item);\nextern void __inc_zone_state(struct zone *, enum zone_stat_item);\nextern void __inc_node_state(struct pglist_data *, enum node_stat_item);\nextern void dec_zone_state(struct zone *, enum zone_stat_item);\nextern void __dec_zone_state(struct zone *, enum zone_stat_item);\nextern void __dec_node_state(struct pglist_data *, enum node_stat_item);\n\nvoid quiet_vmstat(void);\nvoid cpu_vm_stats_fold(int cpu);\nvoid refresh_zone_stat_thresholds(void);\n\nstruct ctl_table;\nint vmstat_refresh(struct ctl_table *, int write, void *buffer, size_t *lenp,\n\t\tloff_t *ppos);\n\nvoid drain_zonestat(struct zone *zone, struct per_cpu_zonestat *);\n\nint calculate_pressure_threshold(struct zone *zone);\nint calculate_normal_threshold(struct zone *zone);\nvoid set_pgdat_percpu_threshold(pg_data_t *pgdat,\n\t\t\t\tint (*calculate_pressure)(struct zone *));\n#else  \n\n \nstatic inline void __mod_zone_page_state(struct zone *zone,\n\t\t\tenum zone_stat_item item, long delta)\n{\n\tzone_page_state_add(delta, zone, item);\n}\n\nstatic inline void __mod_node_page_state(struct pglist_data *pgdat,\n\t\t\tenum node_stat_item item, int delta)\n{\n\tif (vmstat_item_in_bytes(item)) {\n\t\t \n\t\tVM_WARN_ON_ONCE(delta & (PAGE_SIZE - 1));\n\t\tdelta >>= PAGE_SHIFT;\n\t}\n\n\tnode_page_state_add(delta, pgdat, item);\n}\n\nstatic inline void __inc_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tatomic_long_inc(&zone->vm_stat[item]);\n\tatomic_long_inc(&vm_zone_stat[item]);\n}\n\nstatic inline void __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tatomic_long_inc(&pgdat->vm_stat[item]);\n\tatomic_long_inc(&vm_node_stat[item]);\n}\n\nstatic inline void __dec_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tatomic_long_dec(&zone->vm_stat[item]);\n\tatomic_long_dec(&vm_zone_stat[item]);\n}\n\nstatic inline void __dec_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tatomic_long_dec(&pgdat->vm_stat[item]);\n\tatomic_long_dec(&vm_node_stat[item]);\n}\n\nstatic inline void __inc_zone_page_state(struct page *page,\n\t\t\tenum zone_stat_item item)\n{\n\t__inc_zone_state(page_zone(page), item);\n}\n\nstatic inline void __inc_node_page_state(struct page *page,\n\t\t\tenum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}\n\n\nstatic inline void __dec_zone_page_state(struct page *page,\n\t\t\tenum zone_stat_item item)\n{\n\t__dec_zone_state(page_zone(page), item);\n}\n\nstatic inline void __dec_node_page_state(struct page *page,\n\t\t\tenum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}\n\n\n \n#define inc_zone_page_state __inc_zone_page_state\n#define dec_zone_page_state __dec_zone_page_state\n#define mod_zone_page_state __mod_zone_page_state\n\n#define inc_node_page_state __inc_node_page_state\n#define dec_node_page_state __dec_node_page_state\n#define mod_node_page_state __mod_node_page_state\n\n#define inc_zone_state __inc_zone_state\n#define inc_node_state __inc_node_state\n#define dec_zone_state __dec_zone_state\n\n#define set_pgdat_percpu_threshold(pgdat, callback) { }\n\nstatic inline void refresh_zone_stat_thresholds(void) { }\nstatic inline void cpu_vm_stats_fold(int cpu) { }\nstatic inline void quiet_vmstat(void) { }\n\nstatic inline void drain_zonestat(struct zone *zone,\n\t\t\tstruct per_cpu_zonestat *pzstats) { }\n#endif\t\t \n\nstatic inline void __zone_stat_mod_folio(struct folio *folio,\n\t\tenum zone_stat_item item, long nr)\n{\n\t__mod_zone_page_state(folio_zone(folio), item, nr);\n}\n\nstatic inline void __zone_stat_add_folio(struct folio *folio,\n\t\tenum zone_stat_item item)\n{\n\t__mod_zone_page_state(folio_zone(folio), item, folio_nr_pages(folio));\n}\n\nstatic inline void __zone_stat_sub_folio(struct folio *folio,\n\t\tenum zone_stat_item item)\n{\n\t__mod_zone_page_state(folio_zone(folio), item, -folio_nr_pages(folio));\n}\n\nstatic inline void zone_stat_mod_folio(struct folio *folio,\n\t\tenum zone_stat_item item, long nr)\n{\n\tmod_zone_page_state(folio_zone(folio), item, nr);\n}\n\nstatic inline void zone_stat_add_folio(struct folio *folio,\n\t\tenum zone_stat_item item)\n{\n\tmod_zone_page_state(folio_zone(folio), item, folio_nr_pages(folio));\n}\n\nstatic inline void zone_stat_sub_folio(struct folio *folio,\n\t\tenum zone_stat_item item)\n{\n\tmod_zone_page_state(folio_zone(folio), item, -folio_nr_pages(folio));\n}\n\nstatic inline void __node_stat_mod_folio(struct folio *folio,\n\t\tenum node_stat_item item, long nr)\n{\n\t__mod_node_page_state(folio_pgdat(folio), item, nr);\n}\n\nstatic inline void __node_stat_add_folio(struct folio *folio,\n\t\tenum node_stat_item item)\n{\n\t__mod_node_page_state(folio_pgdat(folio), item, folio_nr_pages(folio));\n}\n\nstatic inline void __node_stat_sub_folio(struct folio *folio,\n\t\tenum node_stat_item item)\n{\n\t__mod_node_page_state(folio_pgdat(folio), item, -folio_nr_pages(folio));\n}\n\nstatic inline void node_stat_mod_folio(struct folio *folio,\n\t\tenum node_stat_item item, long nr)\n{\n\tmod_node_page_state(folio_pgdat(folio), item, nr);\n}\n\nstatic inline void node_stat_add_folio(struct folio *folio,\n\t\tenum node_stat_item item)\n{\n\tmod_node_page_state(folio_pgdat(folio), item, folio_nr_pages(folio));\n}\n\nstatic inline void node_stat_sub_folio(struct folio *folio,\n\t\tenum node_stat_item item)\n{\n\tmod_node_page_state(folio_pgdat(folio), item, -folio_nr_pages(folio));\n}\n\nstatic inline void __mod_zone_freepage_state(struct zone *zone, int nr_pages,\n\t\t\t\t\t     int migratetype)\n{\n\t__mod_zone_page_state(zone, NR_FREE_PAGES, nr_pages);\n\tif (is_migrate_cma(migratetype))\n\t\t__mod_zone_page_state(zone, NR_FREE_CMA_PAGES, nr_pages);\n}\n\nextern const char * const vmstat_text[];\n\nstatic inline const char *zone_stat_name(enum zone_stat_item item)\n{\n\treturn vmstat_text[item];\n}\n\n#ifdef CONFIG_NUMA\nstatic inline const char *numa_stat_name(enum numa_stat_item item)\n{\n\treturn vmstat_text[NR_VM_ZONE_STAT_ITEMS +\n\t\t\t   item];\n}\n#endif  \n\nstatic inline const char *node_stat_name(enum node_stat_item item)\n{\n\treturn vmstat_text[NR_VM_ZONE_STAT_ITEMS +\n\t\t\t   NR_VM_NUMA_EVENT_ITEMS +\n\t\t\t   item];\n}\n\nstatic inline const char *lru_list_name(enum lru_list lru)\n{\n\treturn node_stat_name(NR_LRU_BASE + lru) + 3; \n}\n\nstatic inline const char *writeback_stat_name(enum writeback_stat_item item)\n{\n\treturn vmstat_text[NR_VM_ZONE_STAT_ITEMS +\n\t\t\t   NR_VM_NUMA_EVENT_ITEMS +\n\t\t\t   NR_VM_NODE_STAT_ITEMS +\n\t\t\t   item];\n}\n\n#if defined(CONFIG_VM_EVENT_COUNTERS) || defined(CONFIG_MEMCG)\nstatic inline const char *vm_event_name(enum vm_event_item item)\n{\n\treturn vmstat_text[NR_VM_ZONE_STAT_ITEMS +\n\t\t\t   NR_VM_NUMA_EVENT_ITEMS +\n\t\t\t   NR_VM_NODE_STAT_ITEMS +\n\t\t\t   NR_VM_WRITEBACK_STAT_ITEMS +\n\t\t\t   item];\n}\n#endif  \n\n#ifdef CONFIG_MEMCG\n\nvoid __mod_lruvec_state(struct lruvec *lruvec, enum node_stat_item idx,\n\t\t\tint val);\n\nstatic inline void mod_lruvec_state(struct lruvec *lruvec,\n\t\t\t\t    enum node_stat_item idx, int val)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_lruvec_state(lruvec, idx, val);\n\tlocal_irq_restore(flags);\n}\n\nvoid __mod_lruvec_page_state(struct page *page,\n\t\t\t     enum node_stat_item idx, int val);\n\nstatic inline void mod_lruvec_page_state(struct page *page,\n\t\t\t\t\t enum node_stat_item idx, int val)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_lruvec_page_state(page, idx, val);\n\tlocal_irq_restore(flags);\n}\n\n#else\n\nstatic inline void __mod_lruvec_state(struct lruvec *lruvec,\n\t\t\t\t      enum node_stat_item idx, int val)\n{\n\t__mod_node_page_state(lruvec_pgdat(lruvec), idx, val);\n}\n\nstatic inline void mod_lruvec_state(struct lruvec *lruvec,\n\t\t\t\t    enum node_stat_item idx, int val)\n{\n\tmod_node_page_state(lruvec_pgdat(lruvec), idx, val);\n}\n\nstatic inline void __mod_lruvec_page_state(struct page *page,\n\t\t\t\t\t   enum node_stat_item idx, int val)\n{\n\t__mod_node_page_state(page_pgdat(page), idx, val);\n}\n\nstatic inline void mod_lruvec_page_state(struct page *page,\n\t\t\t\t\t enum node_stat_item idx, int val)\n{\n\tmod_node_page_state(page_pgdat(page), idx, val);\n}\n\n#endif  \n\nstatic inline void __inc_lruvec_page_state(struct page *page,\n\t\t\t\t\t   enum node_stat_item idx)\n{\n\t__mod_lruvec_page_state(page, idx, 1);\n}\n\nstatic inline void __dec_lruvec_page_state(struct page *page,\n\t\t\t\t\t   enum node_stat_item idx)\n{\n\t__mod_lruvec_page_state(page, idx, -1);\n}\n\nstatic inline void __lruvec_stat_mod_folio(struct folio *folio,\n\t\t\t\t\t   enum node_stat_item idx, int val)\n{\n\t__mod_lruvec_page_state(&folio->page, idx, val);\n}\n\nstatic inline void __lruvec_stat_add_folio(struct folio *folio,\n\t\t\t\t\t   enum node_stat_item idx)\n{\n\t__lruvec_stat_mod_folio(folio, idx, folio_nr_pages(folio));\n}\n\nstatic inline void __lruvec_stat_sub_folio(struct folio *folio,\n\t\t\t\t\t   enum node_stat_item idx)\n{\n\t__lruvec_stat_mod_folio(folio, idx, -folio_nr_pages(folio));\n}\n\nstatic inline void inc_lruvec_page_state(struct page *page,\n\t\t\t\t\t enum node_stat_item idx)\n{\n\tmod_lruvec_page_state(page, idx, 1);\n}\n\nstatic inline void dec_lruvec_page_state(struct page *page,\n\t\t\t\t\t enum node_stat_item idx)\n{\n\tmod_lruvec_page_state(page, idx, -1);\n}\n\nstatic inline void lruvec_stat_mod_folio(struct folio *folio,\n\t\t\t\t\t enum node_stat_item idx, int val)\n{\n\tmod_lruvec_page_state(&folio->page, idx, val);\n}\n\nstatic inline void lruvec_stat_add_folio(struct folio *folio,\n\t\t\t\t\t enum node_stat_item idx)\n{\n\tlruvec_stat_mod_folio(folio, idx, folio_nr_pages(folio));\n}\n\nstatic inline void lruvec_stat_sub_folio(struct folio *folio,\n\t\t\t\t\t enum node_stat_item idx)\n{\n\tlruvec_stat_mod_folio(folio, idx, -folio_nr_pages(folio));\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}