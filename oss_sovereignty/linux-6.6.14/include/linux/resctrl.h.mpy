{
  "module_name": "resctrl.h",
  "hash_id": "43a3c5b5851c67eaa3b256e6c9a09296aef910d4021cf63cdebab7343444c6e5",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/resctrl.h",
  "human_readable_source": " \n#ifndef _RESCTRL_H\n#define _RESCTRL_H\n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/pid.h>\n\n#ifdef CONFIG_PROC_CPU_RESCTRL\n\nint proc_resctrl_show(struct seq_file *m,\n\t\t      struct pid_namespace *ns,\n\t\t      struct pid *pid,\n\t\t      struct task_struct *tsk);\n\n#endif\n\n \n#define MBA_MAX_MBPS   U32_MAX\n\n \nenum resctrl_conf_type {\n\tCDP_NONE,\n\tCDP_CODE,\n\tCDP_DATA,\n};\n\n#define CDP_NUM_TYPES\t(CDP_DATA + 1)\n\n \nenum resctrl_event_id {\n\tQOS_L3_OCCUP_EVENT_ID\t\t= 0x01,\n\tQOS_L3_MBM_TOTAL_EVENT_ID\t= 0x02,\n\tQOS_L3_MBM_LOCAL_EVENT_ID\t= 0x03,\n};\n\n \nstruct resctrl_staged_config {\n\tu32\t\t\tnew_ctrl;\n\tbool\t\t\thave_new_ctrl;\n};\n\n \nstruct rdt_domain {\n\tstruct list_head\t\tlist;\n\tint\t\t\t\tid;\n\tstruct cpumask\t\t\tcpu_mask;\n\tunsigned long\t\t\t*rmid_busy_llc;\n\tstruct mbm_state\t\t*mbm_total;\n\tstruct mbm_state\t\t*mbm_local;\n\tstruct delayed_work\t\tmbm_over;\n\tstruct delayed_work\t\tcqm_limbo;\n\tint\t\t\t\tmbm_work_cpu;\n\tint\t\t\t\tcqm_work_cpu;\n\tstruct pseudo_lock_region\t*plr;\n\tstruct resctrl_staged_config\tstaged_config[CDP_NUM_TYPES];\n\tu32\t\t\t\t*mbps_val;\n};\n\n \nstruct resctrl_cache {\n\tunsigned int\tcbm_len;\n\tunsigned int\tmin_cbm_bits;\n\tunsigned int\tshareable_bits;\n\tbool\t\tarch_has_sparse_bitmaps;\n\tbool\t\tarch_has_per_cpu_cfg;\n};\n\n \nenum membw_throttle_mode {\n\tTHREAD_THROTTLE_UNDEFINED = 0,\n\tTHREAD_THROTTLE_MAX,\n\tTHREAD_THROTTLE_PER_THREAD,\n};\n\n \nstruct resctrl_membw {\n\tu32\t\t\t\tmin_bw;\n\tu32\t\t\t\tbw_gran;\n\tu32\t\t\t\tdelay_linear;\n\tbool\t\t\t\tarch_needs_linear;\n\tenum membw_throttle_mode\tthrottle_mode;\n\tbool\t\t\t\tmba_sc;\n\tu32\t\t\t\t*mb_map;\n};\n\nstruct rdt_parse_data;\nstruct resctrl_schema;\n\n \nstruct rdt_resource {\n\tint\t\t\trid;\n\tbool\t\t\talloc_capable;\n\tbool\t\t\tmon_capable;\n\tint\t\t\tnum_rmid;\n\tint\t\t\tcache_level;\n\tstruct resctrl_cache\tcache;\n\tstruct resctrl_membw\tmembw;\n\tstruct list_head\tdomains;\n\tchar\t\t\t*name;\n\tint\t\t\tdata_width;\n\tu32\t\t\tdefault_ctrl;\n\tconst char\t\t*format_str;\n\tint\t\t\t(*parse_ctrlval)(struct rdt_parse_data *data,\n\t\t\t\t\t\t struct resctrl_schema *s,\n\t\t\t\t\t\t struct rdt_domain *d);\n\tstruct list_head\tevt_list;\n\tunsigned long\t\tfflags;\n\tbool\t\t\tcdp_capable;\n};\n\n \nstruct resctrl_schema {\n\tstruct list_head\t\tlist;\n\tchar\t\t\t\tname[8];\n\tenum resctrl_conf_type\t\tconf_type;\n\tstruct rdt_resource\t\t*res;\n\tu32\t\t\t\tnum_closid;\n};\n\n \nu32 resctrl_arch_get_num_closid(struct rdt_resource *r);\nint resctrl_arch_update_domains(struct rdt_resource *r, u32 closid);\n\n \nint resctrl_arch_update_one(struct rdt_resource *r, struct rdt_domain *d,\n\t\t\t    u32 closid, enum resctrl_conf_type t, u32 cfg_val);\n\nu32 resctrl_arch_get_config(struct rdt_resource *r, struct rdt_domain *d,\n\t\t\t    u32 closid, enum resctrl_conf_type type);\nint resctrl_online_domain(struct rdt_resource *r, struct rdt_domain *d);\nvoid resctrl_offline_domain(struct rdt_resource *r, struct rdt_domain *d);\n\n \nint resctrl_arch_rmid_read(struct rdt_resource *r, struct rdt_domain *d,\n\t\t\t   u32 rmid, enum resctrl_event_id eventid, u64 *val);\n\n \nvoid resctrl_arch_reset_rmid(struct rdt_resource *r, struct rdt_domain *d,\n\t\t\t     u32 rmid, enum resctrl_event_id eventid);\n\n \nvoid resctrl_arch_reset_rmid_all(struct rdt_resource *r, struct rdt_domain *d);\n\nextern unsigned int resctrl_rmid_realloc_threshold;\nextern unsigned int resctrl_rmid_realloc_limit;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}