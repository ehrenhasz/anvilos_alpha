{
  "module_name": "atalk.h",
  "hash_id": "4094b6da1a2a7190404e998f500b20ea6a847e2e9159f801d0abd862ac599ffe",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/atalk.h",
  "human_readable_source": " \n#ifndef __LINUX_ATALK_H__\n#define __LINUX_ATALK_H__\n\n\n#include <net/sock.h>\n#include <uapi/linux/atalk.h>\n\nstruct atalk_route {\n\tstruct net_device  *dev;\n\tstruct atalk_addr  target;\n\tstruct atalk_addr  gateway;\n\tint\t\t   flags;\n\tstruct atalk_route *next;\n};\n\n \nstruct atalk_iface {\n\tstruct net_device\t*dev;\n\tstruct atalk_addr\taddress;\n\tint\t\t\tstatus;\n#define ATIF_PROBE\t1\t\t \n#define ATIF_PROBE_FAIL\t2\t\t \n\tstruct atalk_netrange\tnets;\n\tstruct atalk_iface\t*next;\n};\n\t\nstruct atalk_sock {\n\t \n\tstruct sock\tsk;\n\t__be16\t\tdest_net;\n\t__be16\t\tsrc_net;\n\tunsigned char\tdest_node;\n\tunsigned char\tsrc_node;\n\tunsigned char\tdest_port;\n\tunsigned char\tsrc_port;\n};\n\nstatic inline struct atalk_sock *at_sk(struct sock *sk)\n{\n\treturn (struct atalk_sock *)sk;\n}\n\nstruct ddpehdr {\n\t__be16\tdeh_len_hops;\t \n\t__be16\tdeh_sum;\n\t__be16\tdeh_dnet;\n\t__be16\tdeh_snet;\n\t__u8\tdeh_dnode;\n\t__u8\tdeh_snode;\n\t__u8\tdeh_dport;\n\t__u8\tdeh_sport;\n\t \n};\n\nstatic __inline__ struct ddpehdr *ddp_hdr(struct sk_buff *skb)\n{\n\treturn (struct ddpehdr *)skb_transport_header(skb);\n}\n\n \nstruct elapaarp {\n\t__be16\thw_type;\n#define AARP_HW_TYPE_ETHERNET\t\t1\n#define AARP_HW_TYPE_TOKENRING\t\t2\n\t__be16\tpa_type;\n\t__u8\thw_len;\n\t__u8\tpa_len;\n#define AARP_PA_ALEN\t\t\t4\n\t__be16\tfunction;\n#define AARP_REQUEST\t\t\t1\n#define AARP_REPLY\t\t\t2\n#define AARP_PROBE\t\t\t3\n\t__u8\thw_src[ETH_ALEN];\n\t__u8\tpa_src_zero;\n\t__be16\tpa_src_net;\n\t__u8\tpa_src_node;\n\t__u8\thw_dst[ETH_ALEN];\n\t__u8\tpa_dst_zero;\n\t__be16\tpa_dst_net;\n\t__u8\tpa_dst_node;\n} __attribute__ ((packed));\n\nstatic __inline__ struct elapaarp *aarp_hdr(struct sk_buff *skb)\n{\n\treturn (struct elapaarp *)skb_transport_header(skb);\n}\n\n \n#define AARP_EXPIRY_TIME\t(5 * 60 * HZ)\n \n#define AARP_HASH_SIZE\t\t16\n \n#define AARP_TICK_TIME\t\t(HZ / 5)\n \n#define AARP_RETRANSMIT_LIMIT\t10\n \n#define AARP_RESOLVE_TIME\t(10 * HZ)\n\nextern struct datalink_proto *ddp_dl, *aarp_dl;\nextern int aarp_proto_init(void);\n\n \n\n \n#if IS_ENABLED(CONFIG_ATALK)\nstatic inline struct atalk_iface *atalk_find_dev(struct net_device *dev)\n{\n\treturn dev->atalk_ptr;\n}\n#endif\n\nextern struct atalk_addr *atalk_find_dev_addr(struct net_device *dev);\nextern struct net_device *atrtr_get_dev(struct atalk_addr *sa);\nextern int\t\t aarp_send_ddp(struct net_device *dev,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       struct atalk_addr *sa, void *hwaddr);\nextern void\t\t aarp_device_down(struct net_device *dev);\nextern void\t\t aarp_probe_network(struct atalk_iface *atif);\nextern int \t\t aarp_proxy_probe_network(struct atalk_iface *atif,\n\t\t\t\t     struct atalk_addr *sa);\nextern void\t\t aarp_proxy_remove(struct net_device *dev,\n\t\t\t\t\t   struct atalk_addr *sa);\n\nextern void\t\taarp_cleanup_module(void);\n\nextern struct hlist_head atalk_sockets;\nextern rwlock_t atalk_sockets_lock;\n\nextern struct atalk_route *atalk_routes;\nextern rwlock_t atalk_routes_lock;\n\nextern struct atalk_iface *atalk_interfaces;\nextern rwlock_t atalk_interfaces_lock;\n\nextern struct atalk_route atrtr_default;\n\nstruct aarp_iter_state {\n\tint bucket;\n\tstruct aarp_entry **table;\n};\n\nextern const struct seq_operations aarp_seq_ops;\n\nextern int sysctl_aarp_expiry_time;\nextern int sysctl_aarp_tick_time;\nextern int sysctl_aarp_retransmit_limit;\nextern int sysctl_aarp_resolve_time;\n\n#ifdef CONFIG_SYSCTL\nextern int atalk_register_sysctl(void);\nextern void atalk_unregister_sysctl(void);\n#else\nstatic inline int atalk_register_sysctl(void)\n{\n\treturn 0;\n}\nstatic inline void atalk_unregister_sysctl(void)\n{\n}\n#endif\n\n#ifdef CONFIG_PROC_FS\nextern int atalk_proc_init(void);\nextern void atalk_proc_exit(void);\n#else\nstatic inline int atalk_proc_init(void)\n{\n\treturn 0;\n}\nstatic inline void atalk_proc_exit(void)\n{\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}