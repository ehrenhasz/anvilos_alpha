{
  "module_name": "device.h",
  "hash_id": "3098b895f1015dda5d354dee727c72aa8d727d44b4d4836b34c446fe66b5e1eb",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mlx4/device.h",
  "human_readable_source": " \n\n#ifndef MLX4_DEVICE_H\n#define MLX4_DEVICE_H\n\n#include <linux/auxiliary_bus.h>\n#include <linux/if_ether.h>\n#include <linux/pci.h>\n#include <linux/completion.h>\n#include <linux/radix-tree.h>\n#include <linux/cpu_rmap.h>\n#include <linux/crash_dump.h>\n\n#include <linux/refcount.h>\n\n#include <linux/timecounter.h>\n\n#define DEFAULT_UAR_PAGE_SHIFT  12\n\n#define MAX_MSIX\t\t128\n#define MIN_MSIX_P_PORT\t\t5\n#define MLX4_IS_LEGACY_EQ_MODE(dev_cap) ((dev_cap).num_comp_vectors < \\\n\t\t\t\t\t (dev_cap).num_ports * MIN_MSIX_P_PORT)\n\n#define MLX4_MAX_100M_UNITS_VAL\t\t255\t \n#define MLX4_RATELIMIT_100M_UNITS\t3\t \n#define MLX4_RATELIMIT_1G_UNITS\t\t4\t \n#define MLX4_RATELIMIT_DEFAULT\t\t0x00ff\n\n#define MLX4_ROCE_MAX_GIDS\t128\n#define MLX4_ROCE_PF_GIDS\t16\n\nenum {\n\tMLX4_FLAG_MSI_X\t\t= 1 << 0,\n\tMLX4_FLAG_OLD_PORT_CMDS\t= 1 << 1,\n\tMLX4_FLAG_MASTER\t= 1 << 2,\n\tMLX4_FLAG_SLAVE\t\t= 1 << 3,\n\tMLX4_FLAG_SRIOV\t\t= 1 << 4,\n\tMLX4_FLAG_OLD_REG_MAC\t= 1 << 6,\n\tMLX4_FLAG_BONDED\t= 1 << 7,\n\tMLX4_FLAG_SECURE_HOST\t= 1 << 8,\n};\n\nenum {\n\tMLX4_PORT_CAP_IS_SM\t= 1 << 1,\n\tMLX4_PORT_CAP_DEV_MGMT_SUP = 1 << 19,\n};\n\nenum {\n\tMLX4_MAX_PORTS\t\t= 2,\n\tMLX4_MAX_PORT_PKEYS\t= 128,\n\tMLX4_MAX_PORT_GIDS\t= 128\n};\n\n \n#define MLX4_RESERVED_QKEY_BASE  (0xFFFF0000)\n#define MLX4_RESERVED_QKEY_MASK  (0xFFFF0000)\n\nenum {\n\tMLX4_BOARD_ID_LEN = 64\n};\n\nenum {\n\tMLX4_MAX_NUM_PF\t\t= 16,\n\tMLX4_MAX_NUM_VF\t\t= 126,\n\tMLX4_MAX_NUM_VF_P_PORT  = 64,\n\tMLX4_MFUNC_MAX\t\t= 128,\n\tMLX4_MAX_EQ_NUM\t\t= 1024,\n\tMLX4_MFUNC_EQ_NUM\t= 4,\n\tMLX4_MFUNC_MAX_EQES     = 8,\n\tMLX4_MFUNC_EQE_MASK     = (MLX4_MFUNC_MAX_EQES - 1)\n};\n\n \nenum {\n\tMLX4_STEERING_MODE_A0,\n\tMLX4_STEERING_MODE_B0,\n\tMLX4_STEERING_MODE_DEVICE_MANAGED\n};\n\nenum {\n\tMLX4_STEERING_DMFS_A0_DEFAULT,\n\tMLX4_STEERING_DMFS_A0_DYNAMIC,\n\tMLX4_STEERING_DMFS_A0_STATIC,\n\tMLX4_STEERING_DMFS_A0_DISABLE,\n\tMLX4_STEERING_DMFS_A0_NOT_SUPPORTED\n};\n\nstatic inline const char *mlx4_steering_mode_str(int steering_mode)\n{\n\tswitch (steering_mode) {\n\tcase MLX4_STEERING_MODE_A0:\n\t\treturn \"A0 steering\";\n\n\tcase MLX4_STEERING_MODE_B0:\n\t\treturn \"B0 steering\";\n\n\tcase MLX4_STEERING_MODE_DEVICE_MANAGED:\n\t\treturn \"Device managed flow steering\";\n\n\tdefault:\n\t\treturn \"Unrecognize steering mode\";\n\t}\n}\n\nenum {\n\tMLX4_TUNNEL_OFFLOAD_MODE_NONE,\n\tMLX4_TUNNEL_OFFLOAD_MODE_VXLAN\n};\n\nenum {\n\tMLX4_DEV_CAP_FLAG_RC\t\t= 1LL <<  0,\n\tMLX4_DEV_CAP_FLAG_UC\t\t= 1LL <<  1,\n\tMLX4_DEV_CAP_FLAG_UD\t\t= 1LL <<  2,\n\tMLX4_DEV_CAP_FLAG_XRC\t\t= 1LL <<  3,\n\tMLX4_DEV_CAP_FLAG_SRQ\t\t= 1LL <<  6,\n\tMLX4_DEV_CAP_FLAG_IPOIB_CSUM\t= 1LL <<  7,\n\tMLX4_DEV_CAP_FLAG_BAD_PKEY_CNTR\t= 1LL <<  8,\n\tMLX4_DEV_CAP_FLAG_BAD_QKEY_CNTR\t= 1LL <<  9,\n\tMLX4_DEV_CAP_FLAG_DPDP\t\t= 1LL << 12,\n\tMLX4_DEV_CAP_FLAG_BLH\t\t= 1LL << 15,\n\tMLX4_DEV_CAP_FLAG_MEM_WINDOW\t= 1LL << 16,\n\tMLX4_DEV_CAP_FLAG_APM\t\t= 1LL << 17,\n\tMLX4_DEV_CAP_FLAG_ATOMIC\t= 1LL << 18,\n\tMLX4_DEV_CAP_FLAG_RAW_MCAST\t= 1LL << 19,\n\tMLX4_DEV_CAP_FLAG_UD_AV_PORT\t= 1LL << 20,\n\tMLX4_DEV_CAP_FLAG_UD_MCAST\t= 1LL << 21,\n\tMLX4_DEV_CAP_FLAG_IBOE\t\t= 1LL << 30,\n\tMLX4_DEV_CAP_FLAG_UC_LOOPBACK\t= 1LL << 32,\n\tMLX4_DEV_CAP_FLAG_FCS_KEEP\t= 1LL << 34,\n\tMLX4_DEV_CAP_FLAG_WOL_PORT1\t= 1LL << 37,\n\tMLX4_DEV_CAP_FLAG_WOL_PORT2\t= 1LL << 38,\n\tMLX4_DEV_CAP_FLAG_UDP_RSS\t= 1LL << 40,\n\tMLX4_DEV_CAP_FLAG_VEP_UC_STEER\t= 1LL << 41,\n\tMLX4_DEV_CAP_FLAG_VEP_MC_STEER\t= 1LL << 42,\n\tMLX4_DEV_CAP_FLAG_COUNTERS\t= 1LL << 48,\n\tMLX4_DEV_CAP_FLAG_RSS_IP_FRAG   = 1LL << 52,\n\tMLX4_DEV_CAP_FLAG_SET_ETH_SCHED = 1LL << 53,\n\tMLX4_DEV_CAP_FLAG_SENSE_SUPPORT\t= 1LL << 55,\n\tMLX4_DEV_CAP_FLAG_PORT_MNG_CHG_EV = 1LL << 59,\n\tMLX4_DEV_CAP_FLAG_64B_EQE\t= 1LL << 61,\n\tMLX4_DEV_CAP_FLAG_64B_CQE\t= 1LL << 62\n};\n\nenum {\n\tMLX4_DEV_CAP_FLAG2_RSS\t\t\t= 1LL <<  0,\n\tMLX4_DEV_CAP_FLAG2_RSS_TOP\t\t= 1LL <<  1,\n\tMLX4_DEV_CAP_FLAG2_RSS_XOR\t\t= 1LL <<  2,\n\tMLX4_DEV_CAP_FLAG2_FS_EN\t\t= 1LL <<  3,\n\tMLX4_DEV_CAP_FLAG2_REASSIGN_MAC_EN\t= 1LL <<  4,\n\tMLX4_DEV_CAP_FLAG2_TS\t\t\t= 1LL <<  5,\n\tMLX4_DEV_CAP_FLAG2_VLAN_CONTROL\t\t= 1LL <<  6,\n\tMLX4_DEV_CAP_FLAG2_FSM\t\t\t= 1LL <<  7,\n\tMLX4_DEV_CAP_FLAG2_UPDATE_QP\t\t= 1LL <<  8,\n\tMLX4_DEV_CAP_FLAG2_DMFS_IPOIB\t\t= 1LL <<  9,\n\tMLX4_DEV_CAP_FLAG2_VXLAN_OFFLOADS\t= 1LL <<  10,\n\tMLX4_DEV_CAP_FLAG2_MAD_DEMUX\t\t= 1LL <<  11,\n\tMLX4_DEV_CAP_FLAG2_CQE_STRIDE\t\t= 1LL <<  12,\n\tMLX4_DEV_CAP_FLAG2_EQE_STRIDE\t\t= 1LL <<  13,\n\tMLX4_DEV_CAP_FLAG2_ETH_PROT_CTRL        = 1LL <<  14,\n\tMLX4_DEV_CAP_FLAG2_ETH_BACKPL_AN_REP\t= 1LL <<  15,\n\tMLX4_DEV_CAP_FLAG2_CONFIG_DEV\t\t= 1LL <<  16,\n\tMLX4_DEV_CAP_FLAG2_SYS_EQS\t\t= 1LL <<  17,\n\tMLX4_DEV_CAP_FLAG2_80_VFS\t\t= 1LL <<  18,\n\tMLX4_DEV_CAP_FLAG2_FS_A0\t\t= 1LL <<  19,\n\tMLX4_DEV_CAP_FLAG2_RECOVERABLE_ERROR_EVENT = 1LL << 20,\n\tMLX4_DEV_CAP_FLAG2_PORT_REMAP\t\t= 1LL <<  21,\n\tMLX4_DEV_CAP_FLAG2_QCN\t\t\t= 1LL <<  22,\n\tMLX4_DEV_CAP_FLAG2_QP_RATE_LIMIT\t= 1LL <<  23,\n\tMLX4_DEV_CAP_FLAG2_FLOWSTATS_EN         = 1LL <<  24,\n\tMLX4_DEV_CAP_FLAG2_QOS_VPP\t\t= 1LL <<  25,\n\tMLX4_DEV_CAP_FLAG2_ETS_CFG\t\t= 1LL <<  26,\n\tMLX4_DEV_CAP_FLAG2_PORT_BEACON\t\t= 1LL <<  27,\n\tMLX4_DEV_CAP_FLAG2_IGNORE_FCS\t\t= 1LL <<  28,\n\tMLX4_DEV_CAP_FLAG2_PHV_EN\t\t= 1LL <<  29,\n\tMLX4_DEV_CAP_FLAG2_SKIP_OUTER_VLAN\t= 1LL <<  30,\n\tMLX4_DEV_CAP_FLAG2_UPDATE_QP_SRC_CHECK_LB = 1ULL << 31,\n\tMLX4_DEV_CAP_FLAG2_LB_SRC_CHK           = 1ULL << 32,\n\tMLX4_DEV_CAP_FLAG2_ROCE_V1_V2\t\t= 1ULL <<  33,\n\tMLX4_DEV_CAP_FLAG2_DMFS_UC_MC_SNIFFER   = 1ULL <<  34,\n\tMLX4_DEV_CAP_FLAG2_DIAG_PER_PORT\t= 1ULL <<  35,\n\tMLX4_DEV_CAP_FLAG2_SVLAN_BY_QP          = 1ULL <<  36,\n\tMLX4_DEV_CAP_FLAG2_SL_TO_VL_CHANGE_EVENT = 1ULL << 37,\n\tMLX4_DEV_CAP_FLAG2_USER_MAC_EN\t\t= 1ULL << 38,\n\tMLX4_DEV_CAP_FLAG2_DRIVER_VERSION_TO_FW = 1ULL << 39,\n\tMLX4_DEV_CAP_FLAG2_SW_CQ_INIT           = 1ULL << 40,\n};\n\nenum {\n\tMLX4_QUERY_FUNC_FLAGS_BF_RES_QP\t\t= 1LL << 0,\n\tMLX4_QUERY_FUNC_FLAGS_A0_RES_QP\t\t= 1LL << 1\n};\n\nenum {\n\tMLX4_VF_CAP_FLAG_RESET\t\t\t= 1 << 0\n};\n\n \nenum {\n\tMLX4_RESERVE_A0_QP\t= 1 << 6,\n\tMLX4_RESERVE_ETH_BF_QP\t= 1 << 7,\n};\n\nenum {\n\tMLX4_DEV_CAP_64B_EQE_ENABLED\t= 1LL << 0,\n\tMLX4_DEV_CAP_64B_CQE_ENABLED\t= 1LL << 1,\n\tMLX4_DEV_CAP_CQE_STRIDE_ENABLED\t= 1LL << 2,\n\tMLX4_DEV_CAP_EQE_STRIDE_ENABLED\t= 1LL << 3\n};\n\nenum {\n\tMLX4_FUNC_CAP_64B_EQE_CQE\t= 1L << 0,\n\tMLX4_FUNC_CAP_EQE_CQE_STRIDE\t= 1L << 1,\n\tMLX4_FUNC_CAP_DMFS_A0_STATIC\t= 1L << 2\n};\n\n\n#define MLX4_ATTR_EXTENDED_PORT_INFO\tcpu_to_be16(0xff90)\n\nenum {\n\tMLX4_BMME_FLAG_WIN_TYPE_2B\t= 1 <<  1,\n\tMLX4_BMME_FLAG_LOCAL_INV\t= 1 <<  6,\n\tMLX4_BMME_FLAG_REMOTE_INV\t= 1 <<  7,\n\tMLX4_BMME_FLAG_TYPE_2_WIN\t= 1 <<  9,\n\tMLX4_BMME_FLAG_RESERVED_LKEY\t= 1 << 10,\n\tMLX4_BMME_FLAG_FAST_REG_WR\t= 1 << 11,\n\tMLX4_BMME_FLAG_ROCE_V1_V2\t= 1 << 19,\n\tMLX4_BMME_FLAG_PORT_REMAP\t= 1 << 24,\n\tMLX4_BMME_FLAG_VSD_INIT2RTR\t= 1 << 28,\n};\n\nenum {\n\tMLX4_FLAG_PORT_REMAP\t\t= MLX4_BMME_FLAG_PORT_REMAP,\n\tMLX4_FLAG_ROCE_V1_V2\t\t= MLX4_BMME_FLAG_ROCE_V1_V2\n};\n\nenum mlx4_event {\n\tMLX4_EVENT_TYPE_COMP\t\t   = 0x00,\n\tMLX4_EVENT_TYPE_PATH_MIG\t   = 0x01,\n\tMLX4_EVENT_TYPE_COMM_EST\t   = 0x02,\n\tMLX4_EVENT_TYPE_SQ_DRAINED\t   = 0x03,\n\tMLX4_EVENT_TYPE_SRQ_QP_LAST_WQE\t   = 0x13,\n\tMLX4_EVENT_TYPE_SRQ_LIMIT\t   = 0x14,\n\tMLX4_EVENT_TYPE_CQ_ERROR\t   = 0x04,\n\tMLX4_EVENT_TYPE_WQ_CATAS_ERROR\t   = 0x05,\n\tMLX4_EVENT_TYPE_EEC_CATAS_ERROR\t   = 0x06,\n\tMLX4_EVENT_TYPE_PATH_MIG_FAILED\t   = 0x07,\n\tMLX4_EVENT_TYPE_WQ_INVAL_REQ_ERROR = 0x10,\n\tMLX4_EVENT_TYPE_WQ_ACCESS_ERROR\t   = 0x11,\n\tMLX4_EVENT_TYPE_SRQ_CATAS_ERROR\t   = 0x12,\n\tMLX4_EVENT_TYPE_LOCAL_CATAS_ERROR  = 0x08,\n\tMLX4_EVENT_TYPE_PORT_CHANGE\t   = 0x09,\n\tMLX4_EVENT_TYPE_EQ_OVERFLOW\t   = 0x0f,\n\tMLX4_EVENT_TYPE_ECC_DETECT\t   = 0x0e,\n\tMLX4_EVENT_TYPE_CMD\t\t   = 0x0a,\n\tMLX4_EVENT_TYPE_VEP_UPDATE\t   = 0x19,\n\tMLX4_EVENT_TYPE_COMM_CHANNEL\t   = 0x18,\n\tMLX4_EVENT_TYPE_OP_REQUIRED\t   = 0x1a,\n\tMLX4_EVENT_TYPE_FATAL_WARNING\t   = 0x1b,\n\tMLX4_EVENT_TYPE_FLR_EVENT\t   = 0x1c,\n\tMLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT = 0x1d,\n\tMLX4_EVENT_TYPE_RECOVERABLE_ERROR_EVENT  = 0x3e,\n\tMLX4_EVENT_TYPE_NONE\t\t   = 0xff,\n};\n\nenum {\n\tMLX4_PORT_CHANGE_SUBTYPE_DOWN\t= 1,\n\tMLX4_PORT_CHANGE_SUBTYPE_ACTIVE\t= 4\n};\n\nenum {\n\tMLX4_RECOVERABLE_ERROR_EVENT_SUBTYPE_BAD_CABLE\t\t= 1,\n\tMLX4_RECOVERABLE_ERROR_EVENT_SUBTYPE_UNSUPPORTED_CABLE\t= 2,\n};\n\nenum {\n\tMLX4_FATAL_WARNING_SUBTYPE_WARMING = 0,\n};\n\nenum slave_port_state {\n\tSLAVE_PORT_DOWN = 0,\n\tSLAVE_PENDING_UP,\n\tSLAVE_PORT_UP,\n};\n\nenum slave_port_gen_event {\n\tSLAVE_PORT_GEN_EVENT_DOWN = 0,\n\tSLAVE_PORT_GEN_EVENT_UP,\n\tSLAVE_PORT_GEN_EVENT_NONE,\n};\n\nenum slave_port_state_event {\n\tMLX4_PORT_STATE_DEV_EVENT_PORT_DOWN,\n\tMLX4_PORT_STATE_DEV_EVENT_PORT_UP,\n\tMLX4_PORT_STATE_IB_PORT_STATE_EVENT_GID_VALID,\n\tMLX4_PORT_STATE_IB_EVENT_GID_INVALID,\n};\n\nenum {\n\tMLX4_PERM_LOCAL_READ\t= 1 << 10,\n\tMLX4_PERM_LOCAL_WRITE\t= 1 << 11,\n\tMLX4_PERM_REMOTE_READ\t= 1 << 12,\n\tMLX4_PERM_REMOTE_WRITE\t= 1 << 13,\n\tMLX4_PERM_ATOMIC\t= 1 << 14,\n\tMLX4_PERM_BIND_MW\t= 1 << 15,\n\tMLX4_PERM_MASK\t\t= 0xFC00\n};\n\nenum {\n\tMLX4_OPCODE_NOP\t\t\t= 0x00,\n\tMLX4_OPCODE_SEND_INVAL\t\t= 0x01,\n\tMLX4_OPCODE_RDMA_WRITE\t\t= 0x08,\n\tMLX4_OPCODE_RDMA_WRITE_IMM\t= 0x09,\n\tMLX4_OPCODE_SEND\t\t= 0x0a,\n\tMLX4_OPCODE_SEND_IMM\t\t= 0x0b,\n\tMLX4_OPCODE_LSO\t\t\t= 0x0e,\n\tMLX4_OPCODE_RDMA_READ\t\t= 0x10,\n\tMLX4_OPCODE_ATOMIC_CS\t\t= 0x11,\n\tMLX4_OPCODE_ATOMIC_FA\t\t= 0x12,\n\tMLX4_OPCODE_MASKED_ATOMIC_CS\t= 0x14,\n\tMLX4_OPCODE_MASKED_ATOMIC_FA\t= 0x15,\n\tMLX4_OPCODE_BIND_MW\t\t= 0x18,\n\tMLX4_OPCODE_FMR\t\t\t= 0x19,\n\tMLX4_OPCODE_LOCAL_INVAL\t\t= 0x1b,\n\tMLX4_OPCODE_CONFIG_CMD\t\t= 0x1f,\n\n\tMLX4_RECV_OPCODE_RDMA_WRITE_IMM\t= 0x00,\n\tMLX4_RECV_OPCODE_SEND\t\t= 0x01,\n\tMLX4_RECV_OPCODE_SEND_IMM\t= 0x02,\n\tMLX4_RECV_OPCODE_SEND_INVAL\t= 0x03,\n\n\tMLX4_CQE_OPCODE_ERROR\t\t= 0x1e,\n\tMLX4_CQE_OPCODE_RESIZE\t\t= 0x16,\n};\n\nenum {\n\tMLX4_STAT_RATE_OFFSET\t= 5\n};\n\nenum mlx4_protocol {\n\tMLX4_PROT_IB_IPV6 = 0,\n\tMLX4_PROT_ETH,\n\tMLX4_PROT_IB_IPV4,\n\tMLX4_PROT_FCOE\n};\n\nenum {\n\tMLX4_MTT_FLAG_PRESENT\t\t= 1\n};\n\nenum mlx4_qp_region {\n\tMLX4_QP_REGION_FW = 0,\n\tMLX4_QP_REGION_RSS_RAW_ETH,\n\tMLX4_QP_REGION_BOTTOM = MLX4_QP_REGION_RSS_RAW_ETH,\n\tMLX4_QP_REGION_ETH_ADDR,\n\tMLX4_QP_REGION_FC_ADDR,\n\tMLX4_QP_REGION_FC_EXCH,\n\tMLX4_NUM_QP_REGION\n};\n\nenum mlx4_port_type {\n\tMLX4_PORT_TYPE_NONE\t= 0,\n\tMLX4_PORT_TYPE_IB\t= 1,\n\tMLX4_PORT_TYPE_ETH\t= 2,\n\tMLX4_PORT_TYPE_AUTO\t= 3\n};\n\nenum mlx4_special_vlan_idx {\n\tMLX4_NO_VLAN_IDX        = 0,\n\tMLX4_VLAN_MISS_IDX,\n\tMLX4_VLAN_REGULAR\n};\n\nenum mlx4_steer_type {\n\tMLX4_MC_STEER = 0,\n\tMLX4_UC_STEER,\n\tMLX4_NUM_STEERS\n};\n\nenum mlx4_resource_usage {\n\tMLX4_RES_USAGE_NONE,\n\tMLX4_RES_USAGE_DRIVER,\n\tMLX4_RES_USAGE_USER_VERBS,\n};\n\nenum {\n\tMLX4_NUM_FEXCH          = 64 * 1024,\n};\n\nenum {\n\tMLX4_MAX_FAST_REG_PAGES = 511,\n};\n\nenum {\n\t \n\tMLX4_MAX_SGE_RD\t= (512 - 16 - 16) / 16\n};\n\nenum {\n\tMLX4_DEV_PMC_SUBTYPE_GUID_INFO\t = 0x14,\n\tMLX4_DEV_PMC_SUBTYPE_PORT_INFO\t = 0x15,\n\tMLX4_DEV_PMC_SUBTYPE_PKEY_TABLE\t = 0x16,\n\tMLX4_DEV_PMC_SUBTYPE_SL_TO_VL_MAP = 0x17,\n};\n\n \nenum {\n\tMLX4_EQ_PORT_INFO_MSTR_SM_LID_CHANGE_MASK\t= 1 << 0,\n\tMLX4_EQ_PORT_INFO_GID_PFX_CHANGE_MASK\t\t= 1 << 1,\n\tMLX4_EQ_PORT_INFO_LID_CHANGE_MASK\t\t= 1 << 2,\n\tMLX4_EQ_PORT_INFO_CLIENT_REREG_MASK\t\t= 1 << 3,\n\tMLX4_EQ_PORT_INFO_MSTR_SM_SL_CHANGE_MASK\t= 1 << 4,\n};\n\nunion sl2vl_tbl_to_u64 {\n\tu8\tsl8[8];\n\tu64\tsl64;\n};\n\nenum {\n\tMLX4_DEVICE_STATE_UP\t\t\t= 1 << 0,\n\tMLX4_DEVICE_STATE_INTERNAL_ERROR\t= 1 << 1,\n};\n\nenum {\n\tMLX4_INTERFACE_STATE_UP\t\t= 1 << 0,\n\tMLX4_INTERFACE_STATE_DELETION\t= 1 << 1,\n\tMLX4_INTERFACE_STATE_NOWAIT\t= 1 << 2,\n};\n\n#define MSTR_SM_CHANGE_MASK (MLX4_EQ_PORT_INFO_MSTR_SM_SL_CHANGE_MASK | \\\n\t\t\t     MLX4_EQ_PORT_INFO_MSTR_SM_LID_CHANGE_MASK)\n\nenum mlx4_module_id {\n\tMLX4_MODULE_ID_SFP              = 0x3,\n\tMLX4_MODULE_ID_QSFP             = 0xC,\n\tMLX4_MODULE_ID_QSFP_PLUS        = 0xD,\n\tMLX4_MODULE_ID_QSFP28           = 0x11,\n};\n\nenum {  \n\tMLX4_QP_RATE_LIMIT_NONE\t\t= 0,\n\tMLX4_QP_RATE_LIMIT_KBS\t\t= 1,\n\tMLX4_QP_RATE_LIMIT_MBS\t\t= 2,\n\tMLX4_QP_RATE_LIMIT_GBS\t\t= 3\n};\n\nstruct mlx4_rate_limit_caps {\n\tu16\tnum_rates;  \n\tu8\tmin_unit;\n\tu16\tmin_val;\n\tu8\tmax_unit;\n\tu16\tmax_val;\n};\n\nstatic inline u64 mlx4_fw_ver(u64 major, u64 minor, u64 subminor)\n{\n\treturn (major << 32) | (minor << 16) | subminor;\n}\n\nstruct mlx4_phys_caps {\n\tu32\t\t\tgid_phys_table_len[MLX4_MAX_PORTS + 1];\n\tu32\t\t\tpkey_phys_table_len[MLX4_MAX_PORTS + 1];\n\tu32\t\t\tnum_phys_eqs;\n\tu32\t\t\tbase_sqpn;\n\tu32\t\t\tbase_proxy_sqpn;\n\tu32\t\t\tbase_tunnel_sqpn;\n};\n\nstruct mlx4_spec_qps {\n\tu32 qp0_qkey;\n\tu32 qp0_proxy;\n\tu32 qp0_tunnel;\n\tu32 qp1_proxy;\n\tu32 qp1_tunnel;\n};\n\nstruct mlx4_caps {\n\tu64\t\t\tfw_ver;\n\tu32\t\t\tfunction;\n\tint\t\t\tnum_ports;\n\tint\t\t\tvl_cap[MLX4_MAX_PORTS + 1];\n\tint\t\t\tib_mtu_cap[MLX4_MAX_PORTS + 1];\n\t__be32\t\t\tib_port_def_cap[MLX4_MAX_PORTS + 1];\n\tu64\t\t\tdef_mac[MLX4_MAX_PORTS + 1];\n\tint\t\t\teth_mtu_cap[MLX4_MAX_PORTS + 1];\n\tint\t\t\tgid_table_len[MLX4_MAX_PORTS + 1];\n\tint\t\t\tpkey_table_len[MLX4_MAX_PORTS + 1];\n\tint\t\t\ttrans_type[MLX4_MAX_PORTS + 1];\n\tint\t\t\tvendor_oui[MLX4_MAX_PORTS + 1];\n\tint\t\t\twavelength[MLX4_MAX_PORTS + 1];\n\tu64\t\t\ttrans_code[MLX4_MAX_PORTS + 1];\n\tint\t\t\tlocal_ca_ack_delay;\n\tint\t\t\tnum_uars;\n\tu32\t\t\tuar_page_size;\n\tint\t\t\tbf_reg_size;\n\tint\t\t\tbf_regs_per_page;\n\tint\t\t\tmax_sq_sg;\n\tint\t\t\tmax_rq_sg;\n\tint\t\t\tnum_qps;\n\tint\t\t\tmax_wqes;\n\tint\t\t\tmax_sq_desc_sz;\n\tint\t\t\tmax_rq_desc_sz;\n\tint\t\t\tmax_qp_init_rdma;\n\tint\t\t\tmax_qp_dest_rdma;\n\tint\t\t\tmax_tc_eth;\n\tstruct mlx4_spec_qps   *spec_qps;\n\tint\t\t\tnum_srqs;\n\tint\t\t\tmax_srq_wqes;\n\tint\t\t\tmax_srq_sge;\n\tint\t\t\treserved_srqs;\n\tint\t\t\tnum_cqs;\n\tint\t\t\tmax_cqes;\n\tint\t\t\treserved_cqs;\n\tint\t\t\tnum_sys_eqs;\n\tint\t\t\tnum_eqs;\n\tint\t\t\treserved_eqs;\n\tint\t\t\tnum_comp_vectors;\n\tint\t\t\tnum_mpts;\n\tint\t\t\tnum_mtts;\n\tint\t\t\tfmr_reserved_mtts;\n\tint\t\t\treserved_mtts;\n\tint\t\t\treserved_mrws;\n\tint\t\t\treserved_uars;\n\tint\t\t\tnum_mgms;\n\tint\t\t\tnum_amgms;\n\tint\t\t\treserved_mcgs;\n\tint\t\t\tnum_qp_per_mgm;\n\tint\t\t\tsteering_mode;\n\tint\t\t\tdmfs_high_steer_mode;\n\tint\t\t\tfs_log_max_ucast_qp_range_size;\n\tint\t\t\tnum_pds;\n\tint\t\t\treserved_pds;\n\tint\t\t\tmax_xrcds;\n\tint\t\t\treserved_xrcds;\n\tint\t\t\tmtt_entry_sz;\n\tu32\t\t\tmax_msg_sz;\n\tu32\t\t\tpage_size_cap;\n\tu64\t\t\tflags;\n\tu64\t\t\tflags2;\n\tu32\t\t\tbmme_flags;\n\tu32\t\t\treserved_lkey;\n\tu16\t\t\tstat_rate_support;\n\tu8\t\t\tport_width_cap[MLX4_MAX_PORTS + 1];\n\tint\t\t\tmax_gso_sz;\n\tint\t\t\tmax_rss_tbl_sz;\n\tint                     reserved_qps_cnt[MLX4_NUM_QP_REGION];\n\tint\t\t\treserved_qps;\n\tint                     reserved_qps_base[MLX4_NUM_QP_REGION];\n\tint                     log_num_macs;\n\tint                     log_num_vlans;\n\tenum mlx4_port_type\tport_type[MLX4_MAX_PORTS + 1];\n\tu8\t\t\tsupported_type[MLX4_MAX_PORTS + 1];\n\tu8                      suggested_type[MLX4_MAX_PORTS + 1];\n\tu8                      default_sense[MLX4_MAX_PORTS + 1];\n\tu32\t\t\tport_mask[MLX4_MAX_PORTS + 1];\n\tenum mlx4_port_type\tpossible_type[MLX4_MAX_PORTS + 1];\n\tu32\t\t\tmax_counters;\n\tu8\t\t\tport_ib_mtu[MLX4_MAX_PORTS + 1];\n\tu16\t\t\tsqp_demux;\n\tu32\t\t\teqe_size;\n\tu32\t\t\tcqe_size;\n\tu8\t\t\teqe_factor;\n\tu32\t\t\tuserspace_caps;  \n\tu32\t\t\tfunction_caps;   \n\tu16\t\t\thca_core_clock;\n\tu64\t\t\tphys_port_id[MLX4_MAX_PORTS + 1];\n\tint\t\t\ttunnel_offload_mode;\n\tu8\t\t\trx_checksum_flags_port[MLX4_MAX_PORTS + 1];\n\tu8\t\t\tphv_bit[MLX4_MAX_PORTS + 1];\n\tu8\t\t\talloc_res_qp_mask;\n\tu32\t\t\tdmfs_high_rate_qpn_base;\n\tu32\t\t\tdmfs_high_rate_qpn_range;\n\tu32\t\t\tvf_caps;\n\tbool\t\t\twol_port[MLX4_MAX_PORTS + 1];\n\tstruct mlx4_rate_limit_caps rl_caps;\n\tu32\t\t\thealth_buffer_addrs;\n\tbool\t\t\tmap_clock_to_user;\n};\n\nstruct mlx4_buf_list {\n\tvoid\t\t       *buf;\n\tdma_addr_t\t\tmap;\n};\n\nstruct mlx4_buf {\n\tstruct mlx4_buf_list\tdirect;\n\tstruct mlx4_buf_list   *page_list;\n\tint\t\t\tnbufs;\n\tint\t\t\tnpages;\n\tint\t\t\tpage_shift;\n};\n\nstruct mlx4_mtt {\n\tu32\t\t\toffset;\n\tint\t\t\torder;\n\tint\t\t\tpage_shift;\n};\n\nenum {\n\tMLX4_DB_PER_PAGE = PAGE_SIZE / 4\n};\n\nstruct mlx4_db_pgdir {\n\tstruct list_head\tlist;\n\tDECLARE_BITMAP(order0, MLX4_DB_PER_PAGE);\n\tDECLARE_BITMAP(order1, MLX4_DB_PER_PAGE / 2);\n\tunsigned long\t       *bits[2];\n\t__be32\t\t       *db_page;\n\tdma_addr_t\t\tdb_dma;\n};\n\nstruct mlx4_ib_user_db_page;\n\nstruct mlx4_db {\n\t__be32\t\t\t*db;\n\tunion {\n\t\tstruct mlx4_db_pgdir\t\t*pgdir;\n\t\tstruct mlx4_ib_user_db_page\t*user_page;\n\t}\t\t\tu;\n\tdma_addr_t\t\tdma;\n\tint\t\t\tindex;\n\tint\t\t\torder;\n};\n\nstruct mlx4_hwq_resources {\n\tstruct mlx4_db\t\tdb;\n\tstruct mlx4_mtt\t\tmtt;\n\tstruct mlx4_buf\t\tbuf;\n};\n\nstruct mlx4_mr {\n\tstruct mlx4_mtt\t\tmtt;\n\tu64\t\t\tiova;\n\tu64\t\t\tsize;\n\tu32\t\t\tkey;\n\tu32\t\t\tpd;\n\tu32\t\t\taccess;\n\tint\t\t\tenabled;\n};\n\nenum mlx4_mw_type {\n\tMLX4_MW_TYPE_1 = 1,\n\tMLX4_MW_TYPE_2 = 2,\n};\n\nstruct mlx4_mw {\n\tu32\t\t\tkey;\n\tu32\t\t\tpd;\n\tenum mlx4_mw_type\ttype;\n\tint\t\t\tenabled;\n};\n\nstruct mlx4_uar {\n\tunsigned long\t\tpfn;\n\tint\t\t\tindex;\n\tstruct list_head\tbf_list;\n\tunsigned\t\tfree_bf_bmap;\n\tvoid __iomem\t       *map;\n\tvoid __iomem\t       *bf_map;\n};\n\nstruct mlx4_bf {\n\tunsigned int\t\toffset;\n\tint\t\t\tbuf_size;\n\tstruct mlx4_uar\t       *uar;\n\tvoid __iomem\t       *reg;\n};\n\nstruct mlx4_cq {\n\tvoid (*comp)\t\t(struct mlx4_cq *);\n\tvoid (*event)\t\t(struct mlx4_cq *, enum mlx4_event);\n\n\tstruct mlx4_uar\t       *uar;\n\n\tu32\t\t\tcons_index;\n\n\tu16                     irq;\n\t__be32\t\t       *set_ci_db;\n\t__be32\t\t       *arm_db;\n\tint\t\t\tarm_sn;\n\n\tint\t\t\tcqn;\n\tunsigned\t\tvector;\n\n\trefcount_t\t\trefcount;\n\tstruct completion\tfree;\n\tstruct {\n\t\tstruct list_head list;\n\t\tvoid (*comp)(struct mlx4_cq *);\n\t\tvoid\t\t*priv;\n\t} tasklet_ctx;\n\tint\t\treset_notify_added;\n\tstruct list_head\treset_notify;\n\tu8\t\t\tusage;\n};\n\nstruct mlx4_qp {\n\tvoid (*event)\t\t(struct mlx4_qp *, enum mlx4_event);\n\n\tint\t\t\tqpn;\n\n\trefcount_t\t\trefcount;\n\tstruct completion\tfree;\n\tu8\t\t\tusage;\n};\n\nstruct mlx4_srq {\n\tvoid (*event)\t\t(struct mlx4_srq *, enum mlx4_event);\n\n\tint\t\t\tsrqn;\n\tint\t\t\tmax;\n\tint\t\t\tmax_gs;\n\tint\t\t\twqe_shift;\n\n\trefcount_t\t\trefcount;\n\tstruct completion\tfree;\n};\n\nstruct mlx4_av {\n\t__be32\t\t\tport_pd;\n\tu8\t\t\treserved1;\n\tu8\t\t\tg_slid;\n\t__be16\t\t\tdlid;\n\tu8\t\t\treserved2;\n\tu8\t\t\tgid_index;\n\tu8\t\t\tstat_rate;\n\tu8\t\t\thop_limit;\n\t__be32\t\t\tsl_tclass_flowlabel;\n\tu8\t\t\tdgid[16];\n};\n\nstruct mlx4_eth_av {\n\t__be32\t\tport_pd;\n\tu8\t\treserved1;\n\tu8\t\tsmac_idx;\n\tu16\t\treserved2;\n\tu8\t\treserved3;\n\tu8\t\tgid_index;\n\tu8\t\tstat_rate;\n\tu8\t\thop_limit;\n\t__be32\t\tsl_tclass_flowlabel;\n\tu8\t\tdgid[16];\n\tu8\t\ts_mac[6];\n\tu8\t\treserved4[2];\n\t__be16\t\tvlan;\n\tu8\t\tmac[ETH_ALEN];\n};\n\nunion mlx4_ext_av {\n\tstruct mlx4_av\t\tib;\n\tstruct mlx4_eth_av\teth;\n};\n\n \n#define ASSIGN_32BIT_COUNTER(counter, value) do {\t\\\n\tif ((value) > U32_MAX)\t\t\t\t\\\n\t\tcounter = cpu_to_be32(U32_MAX);\t\t\\\n\telse\t\t\t\t\t\t\\\n\t\tcounter = cpu_to_be32(value);\t\t\\\n} while (0)\n\nstruct mlx4_counter {\n\tu8\treserved1[3];\n\tu8\tcounter_mode;\n\t__be32\tnum_ifc;\n\tu32\treserved2[2];\n\t__be64\trx_frames;\n\t__be64\trx_bytes;\n\t__be64\ttx_frames;\n\t__be64\ttx_bytes;\n};\n\nstruct mlx4_quotas {\n\tint qp;\n\tint cq;\n\tint srq;\n\tint mpt;\n\tint mtt;\n\tint counter;\n\tint xrcd;\n};\n\nstruct mlx4_vf_dev {\n\tu8\t\t\tmin_port;\n\tu8\t\t\tn_ports;\n};\n\nstruct mlx4_fw_crdump {\n\tbool snapshot_enable;\n\tstruct devlink_region *region_crspace;\n\tstruct devlink_region *region_fw_health;\n};\n\nenum mlx4_pci_status {\n\tMLX4_PCI_STATUS_DISABLED,\n\tMLX4_PCI_STATUS_ENABLED,\n};\n\nstruct mlx4_dev_persistent {\n\tstruct pci_dev\t       *pdev;\n\tstruct mlx4_dev\t       *dev;\n\tint                     nvfs[MLX4_MAX_PORTS + 1];\n\tint\t\t\tnum_vfs;\n\tenum mlx4_port_type curr_port_type[MLX4_MAX_PORTS + 1];\n\tenum mlx4_port_type curr_port_poss_type[MLX4_MAX_PORTS + 1];\n\tstruct work_struct      catas_work;\n\tstruct workqueue_struct *catas_wq;\n\tstruct mutex\tdevice_state_mutex;  \n\tu8\t\tstate;\n\tstruct mutex\tinterface_state_mutex;  \n\tu8\tinterface_state;\n\tstruct mutex\t\tpci_status_mutex;  \n\tenum mlx4_pci_status\tpci_status;\n\tstruct mlx4_fw_crdump\tcrdump;\n};\n\nstruct mlx4_dev {\n\tstruct mlx4_dev_persistent *persist;\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnum_slaves;\n\tstruct mlx4_caps\tcaps;\n\tstruct mlx4_phys_caps\tphys_caps;\n\tstruct mlx4_quotas\tquotas;\n\tstruct radix_tree_root\tqp_table_tree;\n\tu8\t\t\trev_id;\n\tu8\t\t\tport_random_macs;\n\tchar\t\t\tboard_id[MLX4_BOARD_ID_LEN];\n\tint\t\t\tnuma_node;\n\tint\t\t\toper_log_mgm_entry_size;\n\tu64\t\t\tregid_promisc_array[MLX4_MAX_PORTS + 1];\n\tu64\t\t\tregid_allmulti_array[MLX4_MAX_PORTS + 1];\n\tstruct mlx4_vf_dev     *dev_vfs;\n\tu8  uar_page_shift;\n};\n\nstruct mlx4_adev {\n\tstruct auxiliary_device adev;\n\tstruct mlx4_dev *mdev;\n\tint idx;\n};\n\nstruct mlx4_clock_params {\n\tu64 offset;\n\tu8 bar;\n\tu8 size;\n};\n\nstruct mlx4_eqe {\n\tu8\t\t\treserved1;\n\tu8\t\t\ttype;\n\tu8\t\t\treserved2;\n\tu8\t\t\tsubtype;\n\tunion {\n\t\tu32\t\traw[6];\n\t\tstruct {\n\t\t\t__be32\tcqn;\n\t\t} __packed comp;\n\t\tstruct {\n\t\t\tu16\treserved1;\n\t\t\t__be16\ttoken;\n\t\t\tu32\treserved2;\n\t\t\tu8\treserved3[3];\n\t\t\tu8\tstatus;\n\t\t\t__be64\tout_param;\n\t\t} __packed cmd;\n\t\tstruct {\n\t\t\t__be32\tqpn;\n\t\t} __packed qp;\n\t\tstruct {\n\t\t\t__be32\tsrqn;\n\t\t} __packed srq;\n\t\tstruct {\n\t\t\t__be32\tcqn;\n\t\t\tu32\treserved1;\n\t\t\tu8\treserved2[3];\n\t\t\tu8\tsyndrome;\n\t\t} __packed cq_err;\n\t\tstruct {\n\t\t\tu32\treserved1[2];\n\t\t\t__be32\tport;\n\t\t} __packed port_change;\n\t\tstruct {\n\t\t\t#define COMM_CHANNEL_BIT_ARRAY_SIZE\t4\n\t\t\tu32 reserved;\n\t\t\tu32 bit_vec[COMM_CHANNEL_BIT_ARRAY_SIZE];\n\t\t} __packed comm_channel_arm;\n\t\tstruct {\n\t\t\tu8\tport;\n\t\t\tu8\treserved[3];\n\t\t\t__be64\tmac;\n\t\t} __packed mac_update;\n\t\tstruct {\n\t\t\t__be32\tslave_id;\n\t\t} __packed flr_event;\n\t\tstruct {\n\t\t\t__be16  current_temperature;\n\t\t\t__be16  warning_threshold;\n\t\t} __packed warming;\n\t\tstruct {\n\t\t\tu8 reserved[3];\n\t\t\tu8 port;\n\t\t\tunion {\n\t\t\t\tstruct {\n\t\t\t\t\t__be16 mstr_sm_lid;\n\t\t\t\t\t__be16 port_lid;\n\t\t\t\t\t__be32 changed_attr;\n\t\t\t\t\tu8 reserved[3];\n\t\t\t\t\tu8 mstr_sm_sl;\n\t\t\t\t\t__be64 gid_prefix;\n\t\t\t\t} __packed port_info;\n\t\t\t\tstruct {\n\t\t\t\t\t__be32 block_ptr;\n\t\t\t\t\t__be32 tbl_entries_mask;\n\t\t\t\t} __packed tbl_change_info;\n\t\t\t\tstruct {\n\t\t\t\t\tu8 sl2vl_table[8];\n\t\t\t\t} __packed sl2vl_tbl_change_info;\n\t\t\t} params;\n\t\t} __packed port_mgmt_change;\n\t\tstruct {\n\t\t\tu8 reserved[3];\n\t\t\tu8 port;\n\t\t\tu32 reserved1[5];\n\t\t} __packed bad_cable;\n\t}\t\t\tevent;\n\tu8\t\t\tslave_id;\n\tu8\t\t\treserved3[2];\n\tu8\t\t\towner;\n} __packed;\n\nstruct mlx4_init_port_param {\n\tint\t\t\tset_guid0;\n\tint\t\t\tset_node_guid;\n\tint\t\t\tset_si_guid;\n\tu16\t\t\tmtu;\n\tint\t\t\tport_width_cap;\n\tu16\t\t\tvl_cap;\n\tu16\t\t\tmax_gid;\n\tu16\t\t\tmax_pkey;\n\tu64\t\t\tguid0;\n\tu64\t\t\tnode_guid;\n\tu64\t\t\tsi_guid;\n};\n\n#define MAD_IFC_DATA_SZ 192\n \nstruct mlx4_mad_ifc {\n\tu8\tbase_version;\n\tu8\tmgmt_class;\n\tu8\tclass_version;\n\tu8\tmethod;\n\t__be16\tstatus;\n\t__be16\tclass_specific;\n\t__be64\ttid;\n\t__be16\tattr_id;\n\t__be16\tresv;\n\t__be32\tattr_mod;\n\t__be64\tmkey;\n\t__be16\tdr_slid;\n\t__be16\tdr_dlid;\n\tu8\treserved[28];\n\tu8\tdata[MAD_IFC_DATA_SZ];\n} __packed;\n\n#define mlx4_foreach_port(port, dev, type)\t\t\t\t\\\n\tfor ((port) = 1; (port) <= (dev)->caps.num_ports; (port)++)\t\\\n\t\tif ((type) == (dev)->caps.port_mask[(port)])\n\n#define mlx4_foreach_ib_transport_port(port, dev)                         \\\n\tfor ((port) = 1; (port) <= (dev)->caps.num_ports; (port)++)       \\\n\t\tif (((dev)->caps.port_mask[port] == MLX4_PORT_TYPE_IB) || \\\n\t\t    ((dev)->caps.port_mask[port] == MLX4_PORT_TYPE_ETH))\n\n#define MLX4_INVALID_SLAVE_ID\t0xFF\n#define MLX4_SINK_COUNTER_INDEX(dev)\t(dev->caps.max_counters - 1)\n\nvoid handle_port_mgmt_change_event(struct work_struct *work);\n\nstatic inline int mlx4_master_func_num(struct mlx4_dev *dev)\n{\n\treturn dev->caps.function;\n}\n\nstatic inline int mlx4_is_master(struct mlx4_dev *dev)\n{\n\treturn dev->flags & MLX4_FLAG_MASTER;\n}\n\nstatic inline int mlx4_num_reserved_sqps(struct mlx4_dev *dev)\n{\n\treturn dev->phys_caps.base_sqpn + 8 +\n\t\t16 * MLX4_MFUNC_MAX * !!mlx4_is_master(dev);\n}\n\nstatic inline int mlx4_is_qp_reserved(struct mlx4_dev *dev, u32 qpn)\n{\n\treturn (qpn < dev->phys_caps.base_sqpn + 8 +\n\t\t16 * MLX4_MFUNC_MAX * !!mlx4_is_master(dev) &&\n\t\tqpn >= dev->phys_caps.base_sqpn) ||\n\t       (qpn < dev->caps.reserved_qps_cnt[MLX4_QP_REGION_FW]);\n}\n\nstatic inline int mlx4_is_guest_proxy(struct mlx4_dev *dev, int slave, u32 qpn)\n{\n\tint guest_proxy_base = dev->phys_caps.base_proxy_sqpn + slave * 8;\n\n\tif (qpn >= guest_proxy_base && qpn < guest_proxy_base + 8)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline int mlx4_is_mfunc(struct mlx4_dev *dev)\n{\n\treturn dev->flags & (MLX4_FLAG_SLAVE | MLX4_FLAG_MASTER);\n}\n\nstatic inline int mlx4_is_slave(struct mlx4_dev *dev)\n{\n\treturn dev->flags & MLX4_FLAG_SLAVE;\n}\n\nstatic inline int mlx4_is_eth(struct mlx4_dev *dev, int port)\n{\n\treturn dev->caps.port_type[port] == MLX4_PORT_TYPE_IB ? 0 : 1;\n}\n\nint mlx4_buf_alloc(struct mlx4_dev *dev, int size, int max_direct,\n\t\t   struct mlx4_buf *buf);\nvoid mlx4_buf_free(struct mlx4_dev *dev, int size, struct mlx4_buf *buf);\nstatic inline void *mlx4_buf_offset(struct mlx4_buf *buf, int offset)\n{\n\tif (buf->nbufs == 1)\n\t\treturn buf->direct.buf + offset;\n\telse\n\t\treturn buf->page_list[offset >> PAGE_SHIFT].buf +\n\t\t\t(offset & (PAGE_SIZE - 1));\n}\n\nstatic inline int mlx4_is_bonded(struct mlx4_dev *dev)\n{\n\treturn !!(dev->flags & MLX4_FLAG_BONDED);\n}\n\nstatic inline int mlx4_is_mf_bonded(struct mlx4_dev *dev)\n{\n\treturn (mlx4_is_bonded(dev) && mlx4_is_mfunc(dev));\n}\n\nint mlx4_queue_bond_work(struct mlx4_dev *dev, int is_bonded, u8 v2p_p1,\n\t\t\t u8 v2p_p2);\n\nint mlx4_pd_alloc(struct mlx4_dev *dev, u32 *pdn);\nvoid mlx4_pd_free(struct mlx4_dev *dev, u32 pdn);\nint mlx4_xrcd_alloc(struct mlx4_dev *dev, u32 *xrcdn);\nvoid mlx4_xrcd_free(struct mlx4_dev *dev, u32 xrcdn);\n\nint mlx4_uar_alloc(struct mlx4_dev *dev, struct mlx4_uar *uar);\nvoid mlx4_uar_free(struct mlx4_dev *dev, struct mlx4_uar *uar);\nint mlx4_bf_alloc(struct mlx4_dev *dev, struct mlx4_bf *bf, int node);\nvoid mlx4_bf_free(struct mlx4_dev *dev, struct mlx4_bf *bf);\n\nint mlx4_mtt_init(struct mlx4_dev *dev, int npages, int page_shift,\n\t\t  struct mlx4_mtt *mtt);\nvoid mlx4_mtt_cleanup(struct mlx4_dev *dev, struct mlx4_mtt *mtt);\nu64 mlx4_mtt_addr(struct mlx4_dev *dev, struct mlx4_mtt *mtt);\n\nint mlx4_mr_alloc(struct mlx4_dev *dev, u32 pd, u64 iova, u64 size, u32 access,\n\t\t  int npages, int page_shift, struct mlx4_mr *mr);\nint mlx4_mr_free(struct mlx4_dev *dev, struct mlx4_mr *mr);\nint mlx4_mr_enable(struct mlx4_dev *dev, struct mlx4_mr *mr);\nint mlx4_mw_alloc(struct mlx4_dev *dev, u32 pd, enum mlx4_mw_type type,\n\t\t  struct mlx4_mw *mw);\nvoid mlx4_mw_free(struct mlx4_dev *dev, struct mlx4_mw *mw);\nint mlx4_mw_enable(struct mlx4_dev *dev, struct mlx4_mw *mw);\nint mlx4_write_mtt(struct mlx4_dev *dev, struct mlx4_mtt *mtt,\n\t\t   int start_index, int npages, u64 *page_list);\nint mlx4_buf_write_mtt(struct mlx4_dev *dev, struct mlx4_mtt *mtt,\n\t\t       struct mlx4_buf *buf);\n\nint mlx4_db_alloc(struct mlx4_dev *dev, struct mlx4_db *db, int order);\nvoid mlx4_db_free(struct mlx4_dev *dev, struct mlx4_db *db);\n\nint mlx4_alloc_hwq_res(struct mlx4_dev *dev, struct mlx4_hwq_resources *wqres,\n\t\t       int size);\nvoid mlx4_free_hwq_res(struct mlx4_dev *mdev, struct mlx4_hwq_resources *wqres,\n\t\t       int size);\n\nint mlx4_cq_alloc(struct mlx4_dev *dev, int nent, struct mlx4_mtt *mtt,\n\t\t  struct mlx4_uar *uar, u64 db_rec, struct mlx4_cq *cq,\n\t\t  unsigned int vector, int collapsed, int timestamp_en,\n\t\t  void *buf_addr, bool user_cq);\nvoid mlx4_cq_free(struct mlx4_dev *dev, struct mlx4_cq *cq);\nint mlx4_qp_reserve_range(struct mlx4_dev *dev, int cnt, int align,\n\t\t\t  int *base, u8 flags, u8 usage);\nvoid mlx4_qp_release_range(struct mlx4_dev *dev, int base_qpn, int cnt);\n\nint mlx4_qp_alloc(struct mlx4_dev *dev, int qpn, struct mlx4_qp *qp);\nvoid mlx4_qp_free(struct mlx4_dev *dev, struct mlx4_qp *qp);\n\nint mlx4_srq_alloc(struct mlx4_dev *dev, u32 pdn, u32 cqn, u16 xrcdn,\n\t\t   struct mlx4_mtt *mtt, u64 db_rec, struct mlx4_srq *srq);\nvoid mlx4_srq_free(struct mlx4_dev *dev, struct mlx4_srq *srq);\nint mlx4_srq_arm(struct mlx4_dev *dev, struct mlx4_srq *srq, int limit_watermark);\nint mlx4_srq_query(struct mlx4_dev *dev, struct mlx4_srq *srq, int *limit_watermark);\n\nint mlx4_INIT_PORT(struct mlx4_dev *dev, int port);\nint mlx4_CLOSE_PORT(struct mlx4_dev *dev, int port);\n\nint mlx4_unicast_attach(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16],\n\t\t\tint block_mcast_loopback, enum mlx4_protocol prot);\nint mlx4_unicast_detach(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16],\n\t\t\tenum mlx4_protocol prot);\nint mlx4_multicast_attach(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16],\n\t\t\t  u8 port, int block_mcast_loopback,\n\t\t\t  enum mlx4_protocol protocol, u64 *reg_id);\nint mlx4_multicast_detach(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16],\n\t\t\t  enum mlx4_protocol protocol, u64 reg_id);\n\nenum {\n\tMLX4_DOMAIN_UVERBS\t= 0x1000,\n\tMLX4_DOMAIN_ETHTOOL     = 0x2000,\n\tMLX4_DOMAIN_RFS         = 0x3000,\n\tMLX4_DOMAIN_NIC    = 0x5000,\n};\n\nenum mlx4_net_trans_rule_id {\n\tMLX4_NET_TRANS_RULE_ID_ETH = 0,\n\tMLX4_NET_TRANS_RULE_ID_IB,\n\tMLX4_NET_TRANS_RULE_ID_IPV6,\n\tMLX4_NET_TRANS_RULE_ID_IPV4,\n\tMLX4_NET_TRANS_RULE_ID_TCP,\n\tMLX4_NET_TRANS_RULE_ID_UDP,\n\tMLX4_NET_TRANS_RULE_ID_VXLAN,\n\tMLX4_NET_TRANS_RULE_NUM,  \n};\n\nextern const u16 __sw_id_hw[];\n\nstatic inline int map_hw_to_sw_id(u16 header_id)\n{\n\n\tint i;\n\tfor (i = 0; i < MLX4_NET_TRANS_RULE_NUM; i++) {\n\t\tif (header_id == __sw_id_hw[i])\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nenum mlx4_net_trans_promisc_mode {\n\tMLX4_FS_REGULAR = 1,\n\tMLX4_FS_ALL_DEFAULT,\n\tMLX4_FS_MC_DEFAULT,\n\tMLX4_FS_MIRROR_RX_PORT,\n\tMLX4_FS_MIRROR_SX_PORT,\n\tMLX4_FS_UC_SNIFFER,\n\tMLX4_FS_MC_SNIFFER,\n\tMLX4_FS_MODE_NUM,  \n};\n\nstruct mlx4_spec_eth {\n\tu8\tdst_mac[ETH_ALEN];\n\tu8\tdst_mac_msk[ETH_ALEN];\n\tu8\tsrc_mac[ETH_ALEN];\n\tu8\tsrc_mac_msk[ETH_ALEN];\n\tu8\tether_type_enable;\n\t__be16\tether_type;\n\t__be16\tvlan_id_msk;\n\t__be16\tvlan_id;\n};\n\nstruct mlx4_spec_tcp_udp {\n\t__be16 dst_port;\n\t__be16 dst_port_msk;\n\t__be16 src_port;\n\t__be16 src_port_msk;\n};\n\nstruct mlx4_spec_ipv4 {\n\t__be32 dst_ip;\n\t__be32 dst_ip_msk;\n\t__be32 src_ip;\n\t__be32 src_ip_msk;\n};\n\nstruct mlx4_spec_ib {\n\t__be32  l3_qpn;\n\t__be32\tqpn_msk;\n\tu8\tdst_gid[16];\n\tu8\tdst_gid_msk[16];\n};\n\nstruct mlx4_spec_vxlan {\n\t__be32 vni;\n\t__be32 vni_mask;\n\n};\n\nstruct mlx4_spec_list {\n\tstruct\tlist_head list;\n\tenum\tmlx4_net_trans_rule_id id;\n\tunion {\n\t\tstruct mlx4_spec_eth eth;\n\t\tstruct mlx4_spec_ib ib;\n\t\tstruct mlx4_spec_ipv4 ipv4;\n\t\tstruct mlx4_spec_tcp_udp tcp_udp;\n\t\tstruct mlx4_spec_vxlan vxlan;\n\t};\n};\n\nenum mlx4_net_trans_hw_rule_queue {\n\tMLX4_NET_TRANS_Q_FIFO,\n\tMLX4_NET_TRANS_Q_LIFO,\n};\n\nstruct mlx4_net_trans_rule {\n\tstruct\tlist_head list;\n\tenum\tmlx4_net_trans_hw_rule_queue queue_mode;\n\tbool\texclusive;\n\tbool\tallow_loopback;\n\tenum\tmlx4_net_trans_promisc_mode promisc_mode;\n\tu8\tport;\n\tu16\tpriority;\n\tu32\tqpn;\n};\n\nstruct mlx4_net_trans_rule_hw_ctrl {\n\t__be16 prio;\n\tu8 type;\n\tu8 flags;\n\tu8 rsvd1;\n\tu8 funcid;\n\tu8 vep;\n\tu8 port;\n\t__be32 qpn;\n\t__be32 rsvd2;\n};\n\nstruct mlx4_net_trans_rule_hw_ib {\n\tu8 size;\n\tu8 rsvd1;\n\t__be16 id;\n\tu32 rsvd2;\n\t__be32 l3_qpn;\n\t__be32 qpn_mask;\n\tu8 dst_gid[16];\n\tu8 dst_gid_msk[16];\n} __packed;\n\nstruct mlx4_net_trans_rule_hw_eth {\n\tu8\tsize;\n\tu8\trsvd;\n\t__be16\tid;\n\tu8\trsvd1[6];\n\tu8\tdst_mac[6];\n\tu16\trsvd2;\n\tu8\tdst_mac_msk[6];\n\tu16\trsvd3;\n\tu8\tsrc_mac[6];\n\tu16\trsvd4;\n\tu8\tsrc_mac_msk[6];\n\tu8      rsvd5;\n\tu8      ether_type_enable;\n\t__be16  ether_type;\n\t__be16  vlan_tag_msk;\n\t__be16  vlan_tag;\n} __packed;\n\nstruct mlx4_net_trans_rule_hw_tcp_udp {\n\tu8\tsize;\n\tu8\trsvd;\n\t__be16\tid;\n\t__be16\trsvd1[3];\n\t__be16\tdst_port;\n\t__be16\trsvd2;\n\t__be16\tdst_port_msk;\n\t__be16\trsvd3;\n\t__be16\tsrc_port;\n\t__be16\trsvd4;\n\t__be16\tsrc_port_msk;\n} __packed;\n\nstruct mlx4_net_trans_rule_hw_ipv4 {\n\tu8\tsize;\n\tu8\trsvd;\n\t__be16\tid;\n\t__be32\trsvd1;\n\t__be32\tdst_ip;\n\t__be32\tdst_ip_msk;\n\t__be32\tsrc_ip;\n\t__be32\tsrc_ip_msk;\n} __packed;\n\nstruct mlx4_net_trans_rule_hw_vxlan {\n\tu8\tsize;\n\tu8\trsvd;\n\t__be16\tid;\n\t__be32\trsvd1;\n\t__be32\tvni;\n\t__be32\tvni_mask;\n} __packed;\n\nstruct _rule_hw {\n\tunion {\n\t\tstruct {\n\t\t\tu8 size;\n\t\t\tu8 rsvd;\n\t\t\t__be16 id;\n\t\t};\n\t\tstruct mlx4_net_trans_rule_hw_eth eth;\n\t\tstruct mlx4_net_trans_rule_hw_ib ib;\n\t\tstruct mlx4_net_trans_rule_hw_ipv4 ipv4;\n\t\tstruct mlx4_net_trans_rule_hw_tcp_udp tcp_udp;\n\t\tstruct mlx4_net_trans_rule_hw_vxlan vxlan;\n\t};\n};\n\nenum {\n\tVXLAN_STEER_BY_OUTER_MAC\t= 1 << 0,\n\tVXLAN_STEER_BY_OUTER_VLAN\t= 1 << 1,\n\tVXLAN_STEER_BY_VSID_VNI\t\t= 1 << 2,\n\tVXLAN_STEER_BY_INNER_MAC\t= 1 << 3,\n\tVXLAN_STEER_BY_INNER_VLAN\t= 1 << 4,\n};\n\nenum {\n\tMLX4_OP_MOD_QUERY_TRANSPORT_CI_ERRORS = 0x2,\n};\n\nint mlx4_flow_steer_promisc_add(struct mlx4_dev *dev, u8 port, u32 qpn,\n\t\t\t\tenum mlx4_net_trans_promisc_mode mode);\nint mlx4_flow_steer_promisc_remove(struct mlx4_dev *dev, u8 port,\n\t\t\t\t   enum mlx4_net_trans_promisc_mode mode);\nint mlx4_multicast_promisc_add(struct mlx4_dev *dev, u32 qpn, u8 port);\nint mlx4_multicast_promisc_remove(struct mlx4_dev *dev, u32 qpn, u8 port);\nint mlx4_unicast_promisc_add(struct mlx4_dev *dev, u32 qpn, u8 port);\nint mlx4_unicast_promisc_remove(struct mlx4_dev *dev, u32 qpn, u8 port);\nint mlx4_SET_MCAST_FLTR(struct mlx4_dev *dev, u8 port, u64 mac, u64 clear, u8 mode);\n\nint mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac);\nvoid mlx4_unregister_mac(struct mlx4_dev *dev, u8 port, u64 mac);\nint mlx4_get_base_qpn(struct mlx4_dev *dev, u8 port);\nint __mlx4_replace_mac(struct mlx4_dev *dev, u8 port, int qpn, u64 new_mac);\nint mlx4_SET_PORT_general(struct mlx4_dev *dev, u8 port, int mtu,\n\t\t\t  u8 pptx, u8 pfctx, u8 pprx, u8 pfcrx);\nint mlx4_SET_PORT_user_mac(struct mlx4_dev *dev, u8 port, u8 *user_mac);\nint mlx4_SET_PORT_user_mtu(struct mlx4_dev *dev, u8 port, u16 user_mtu);\nint mlx4_SET_PORT_qpn_calc(struct mlx4_dev *dev, u8 port, u32 base_qpn,\n\t\t\t   u8 promisc);\nint mlx4_SET_PORT_BEACON(struct mlx4_dev *dev, u8 port, u16 time);\nint mlx4_SET_PORT_fcs_check(struct mlx4_dev *dev, u8 port,\n\t\t\t    u8 ignore_fcs_value);\nint mlx4_SET_PORT_VXLAN(struct mlx4_dev *dev, u8 port, u8 steering, int enable);\nint set_phv_bit(struct mlx4_dev *dev, u8 port, int new_val);\nint get_phv_bit(struct mlx4_dev *dev, u8 port, int *phv);\nint mlx4_get_is_vlan_offload_disabled(struct mlx4_dev *dev, u8 port,\n\t\t\t\t      bool *vlan_offload_disabled);\nvoid mlx4_handle_eth_header_mcast_prio(struct mlx4_net_trans_rule_hw_ctrl *ctrl,\n\t\t\t\t       struct _rule_hw *eth_header);\nint mlx4_find_cached_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *idx);\nint mlx4_find_cached_vlan(struct mlx4_dev *dev, u8 port, u16 vid, int *idx);\nint mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index);\nvoid mlx4_unregister_vlan(struct mlx4_dev *dev, u8 port, u16 vlan);\n\nint mlx4_SYNC_TPT(struct mlx4_dev *dev);\nint mlx4_test_interrupt(struct mlx4_dev *dev, int vector);\nint mlx4_test_async(struct mlx4_dev *dev);\nint mlx4_query_diag_counters(struct mlx4_dev *dev, u8 op_modifier,\n\t\t\t     const u32 offset[], u32 value[],\n\t\t\t     size_t array_len, u8 port);\nu32 mlx4_get_eqs_per_port(struct mlx4_dev *dev, u8 port);\nbool mlx4_is_eq_vector_valid(struct mlx4_dev *dev, u8 port, int vector);\nstruct cpu_rmap *mlx4_get_cpu_rmap(struct mlx4_dev *dev, int port);\nint mlx4_assign_eq(struct mlx4_dev *dev, u8 port, int *vector);\nvoid mlx4_release_eq(struct mlx4_dev *dev, int vec);\n\nint mlx4_is_eq_shared(struct mlx4_dev *dev, int vector);\nint mlx4_eq_get_irq(struct mlx4_dev *dev, int vec);\n\nint mlx4_get_phys_port_id(struct mlx4_dev *dev);\nint mlx4_wol_read(struct mlx4_dev *dev, u64 *config, int port);\nint mlx4_wol_write(struct mlx4_dev *dev, u64 config, int port);\n\nint mlx4_counter_alloc(struct mlx4_dev *dev, u32 *idx, u8 usage);\nvoid mlx4_counter_free(struct mlx4_dev *dev, u32 idx);\nint mlx4_get_default_counter_index(struct mlx4_dev *dev, int port);\n\nvoid mlx4_set_admin_guid(struct mlx4_dev *dev, __be64 guid, int entry,\n\t\t\t int port);\n__be64 mlx4_get_admin_guid(struct mlx4_dev *dev, int entry, int port);\nvoid mlx4_set_random_admin_guid(struct mlx4_dev *dev, int entry, int port);\nint mlx4_flow_attach(struct mlx4_dev *dev,\n\t\t     struct mlx4_net_trans_rule *rule, u64 *reg_id);\nint mlx4_flow_detach(struct mlx4_dev *dev, u64 reg_id);\nint mlx4_map_sw_to_hw_steering_mode(struct mlx4_dev *dev,\n\t\t\t\t    enum mlx4_net_trans_promisc_mode flow_type);\nint mlx4_map_sw_to_hw_steering_id(struct mlx4_dev *dev,\n\t\t\t\t  enum mlx4_net_trans_rule_id id);\nint mlx4_hw_rule_sz(struct mlx4_dev *dev, enum mlx4_net_trans_rule_id id);\n\nint mlx4_tunnel_steer_add(struct mlx4_dev *dev, const unsigned char *addr,\n\t\t\t  int port, int qpn, u16 prio, u64 *reg_id);\n\nvoid mlx4_sync_pkey_table(struct mlx4_dev *dev, int slave, int port,\n\t\t\t  int i, int val);\n\nint mlx4_get_parav_qkey(struct mlx4_dev *dev, u32 qpn, u32 *qkey);\n\nint mlx4_is_slave_active(struct mlx4_dev *dev, int slave);\nint mlx4_gen_pkey_eqe(struct mlx4_dev *dev, int slave, u8 port);\nint mlx4_gen_guid_change_eqe(struct mlx4_dev *dev, int slave, u8 port);\nint mlx4_gen_slaves_port_mgt_ev(struct mlx4_dev *dev, u8 port, int attr);\nint mlx4_gen_port_state_change_eqe(struct mlx4_dev *dev, int slave, u8 port, u8 port_subtype_change);\nenum slave_port_state mlx4_get_slave_port_state(struct mlx4_dev *dev, int slave, u8 port);\nint set_and_calc_slave_port_state(struct mlx4_dev *dev, int slave, u8 port, int event, enum slave_port_gen_event *gen_event);\n\nvoid mlx4_put_slave_node_guid(struct mlx4_dev *dev, int slave, __be64 guid);\n__be64 mlx4_get_slave_node_guid(struct mlx4_dev *dev, int slave);\n\nint mlx4_get_slave_from_roce_gid(struct mlx4_dev *dev, int port, u8 *gid,\n\t\t\t\t int *slave_id);\nint mlx4_get_roce_gid_from_slave(struct mlx4_dev *dev, int port, int slave_id,\n\t\t\t\t u8 *gid);\n\nint mlx4_FLOW_STEERING_IB_UC_QP_RANGE(struct mlx4_dev *dev, u32 min_range_qpn,\n\t\t\t\t      u32 max_range_qpn);\n\nu64 mlx4_read_clock(struct mlx4_dev *dev);\n\nstruct mlx4_active_ports {\n\tDECLARE_BITMAP(ports, MLX4_MAX_PORTS);\n};\n \nstruct mlx4_active_ports mlx4_get_active_ports(struct mlx4_dev *dev, int slave);\n\n \n \n \nint mlx4_slave_convert_port(struct mlx4_dev *dev, int slave, int port);\n\nstruct mlx4_slaves_pport {\n\tDECLARE_BITMAP(slaves, MLX4_MFUNC_MAX);\n};\n \nstruct mlx4_slaves_pport mlx4_phys_to_slaves_pport(struct mlx4_dev *dev,\n\t\t\t\t\t\t   int port);\n\n \n \nstruct mlx4_slaves_pport mlx4_phys_to_slaves_pport_actv(\n\t\tstruct mlx4_dev *dev,\n\t\tconst struct mlx4_active_ports *crit_ports);\n\n \nint mlx4_phys_to_slave_port(struct mlx4_dev *dev, int slave, int port);\n\nint mlx4_get_base_gid_ix(struct mlx4_dev *dev, int slave, int port);\n\nint mlx4_config_vxlan_port(struct mlx4_dev *dev, __be16 udp_port);\nint mlx4_disable_rx_port_check(struct mlx4_dev *dev, bool dis);\nint mlx4_config_roce_v2_port(struct mlx4_dev *dev, u16 udp_port);\nint mlx4_virt2phy_port_map(struct mlx4_dev *dev, u32 port1, u32 port2);\nint mlx4_vf_smi_enabled(struct mlx4_dev *dev, int slave, int port);\nint mlx4_vf_get_enable_smi_admin(struct mlx4_dev *dev, int slave, int port);\nint mlx4_vf_set_enable_smi_admin(struct mlx4_dev *dev, int slave, int port,\n\t\t\t\t int enable);\n\nstruct mlx4_mpt_entry;\nint mlx4_mr_hw_get_mpt(struct mlx4_dev *dev, struct mlx4_mr *mmr,\n\t\t       struct mlx4_mpt_entry ***mpt_entry);\nint mlx4_mr_hw_write_mpt(struct mlx4_dev *dev, struct mlx4_mr *mmr,\n\t\t\t struct mlx4_mpt_entry **mpt_entry);\nint mlx4_mr_hw_change_pd(struct mlx4_dev *dev, struct mlx4_mpt_entry *mpt_entry,\n\t\t\t u32 pdn);\nint mlx4_mr_hw_change_access(struct mlx4_dev *dev,\n\t\t\t     struct mlx4_mpt_entry *mpt_entry,\n\t\t\t     u32 access);\nvoid mlx4_mr_hw_put_mpt(struct mlx4_dev *dev,\n\t\t\tstruct mlx4_mpt_entry **mpt_entry);\nvoid mlx4_mr_rereg_mem_cleanup(struct mlx4_dev *dev, struct mlx4_mr *mr);\nint mlx4_mr_rereg_mem_write(struct mlx4_dev *dev, struct mlx4_mr *mr,\n\t\t\t    u64 iova, u64 size, int npages,\n\t\t\t    int page_shift, struct mlx4_mpt_entry *mpt_entry);\n\nint mlx4_get_module_info(struct mlx4_dev *dev, u8 port,\n\t\t\t u16 offset, u16 size, u8 *data);\nint mlx4_max_tc(struct mlx4_dev *dev);\n\n \nstatic inline bool mlx4_low_memory_profile(void)\n{\n\treturn is_kdump_kernel();\n}\n\n \nenum mlx4_access_reg_method {\n\tMLX4_ACCESS_REG_QUERY = 0x1,\n\tMLX4_ACCESS_REG_WRITE = 0x2,\n};\n\n \nenum mlx4_ptys_proto {\n\tMLX4_PTYS_IB = 1<<0,\n\tMLX4_PTYS_EN = 1<<2,\n};\n\nenum mlx4_ptys_flags {\n\tMLX4_PTYS_AN_DISABLE_CAP   = 1 << 5,\n\tMLX4_PTYS_AN_DISABLE_ADMIN = 1 << 6,\n};\n\nstruct mlx4_ptys_reg {\n\tu8 flags;\n\tu8 local_port;\n\tu8 resrvd2;\n\tu8 proto_mask;\n\t__be32 resrvd3[2];\n\t__be32 eth_proto_cap;\n\t__be16 ib_width_cap;\n\t__be16 ib_speed_cap;\n\t__be32 resrvd4;\n\t__be32 eth_proto_admin;\n\t__be16 ib_width_admin;\n\t__be16 ib_speed_admin;\n\t__be32 resrvd5;\n\t__be32 eth_proto_oper;\n\t__be16 ib_width_oper;\n\t__be16 ib_speed_oper;\n\t__be32 resrvd6;\n\t__be32 eth_proto_lp_adv;\n} __packed;\n\nint mlx4_ACCESS_PTYS_REG(struct mlx4_dev *dev,\n\t\t\t enum mlx4_access_reg_method method,\n\t\t\t struct mlx4_ptys_reg *ptys_reg);\n\nint mlx4_get_internal_clock_params(struct mlx4_dev *dev,\n\t\t\t\t   struct mlx4_clock_params *params);\n\nstatic inline int mlx4_to_hw_uar_index(struct mlx4_dev *dev, int index)\n{\n\treturn (index << (PAGE_SHIFT - dev->uar_page_shift));\n}\n\nstatic inline int mlx4_get_num_reserved_uar(struct mlx4_dev *dev)\n{\n\t \n\treturn (128 >> (PAGE_SHIFT - dev->uar_page_shift));\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}