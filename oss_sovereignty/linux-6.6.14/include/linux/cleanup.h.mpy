{
  "module_name": "cleanup.h",
  "hash_id": "a7c2c5c1c076436d2c532423cf34b60bf7be25b1fdaed9be25cc70797529df0c",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/cleanup.h",
  "human_readable_source": " \n#ifndef __LINUX_GUARDS_H\n#define __LINUX_GUARDS_H\n\n#include <linux/compiler.h>\n\n \n\n#define DEFINE_FREE(_name, _type, _free) \\\n\tstatic inline void __free_##_name(void *p) { _type _T = *(_type *)p; _free; }\n\n#define __free(_name)\t__cleanup(__free_##_name)\n\n#define no_free_ptr(p) \\\n\t({ __auto_type __ptr = (p); (p) = NULL; __ptr; })\n\n#define return_ptr(p)\treturn no_free_ptr(p)\n\n\n \n\n#define DEFINE_CLASS(_name, _type, _exit, _init, _init_args...)\t\t\\\ntypedef _type class_##_name##_t;\t\t\t\t\t\\\nstatic inline void class_##_name##_destructor(_type *p)\t\t\t\\\n{ _type _T = *p; _exit; }\t\t\t\t\t\t\\\nstatic inline _type class_##_name##_constructor(_init_args)\t\t\\\n{ _type t = _init; return t; }\n\n#define EXTEND_CLASS(_name, ext, _init, _init_args...)\t\t\t\\\ntypedef class_##_name##_t class_##_name##ext##_t;\t\t\t\\\nstatic inline void class_##_name##ext##_destructor(class_##_name##_t *p)\\\n{ class_##_name##_destructor(p); }\t\t\t\t\t\\\nstatic inline class_##_name##_t class_##_name##ext##_constructor(_init_args) \\\n{ class_##_name##_t t = _init; return t; }\n\n#define CLASS(_name, var)\t\t\t\t\t\t\\\n\tclass_##_name##_t var __cleanup(class_##_name##_destructor) =\t\\\n\t\tclass_##_name##_constructor\n\n\n \n\n#define DEFINE_GUARD(_name, _type, _lock, _unlock) \\\n\tDEFINE_CLASS(_name, _type, _unlock, ({ _lock; _T; }), _type _T)\n\n#define guard(_name) \\\n\tCLASS(_name, __UNIQUE_ID(guard))\n\n#define scoped_guard(_name, args...)\t\t\t\t\t\\\n\tfor (CLASS(_name, scope)(args),\t\t\t\t\t\\\n\t     *done = NULL; !done; done = (void *)1)\n\n \n\n#define __DEFINE_UNLOCK_GUARD(_name, _type, _unlock, ...)\t\t\\\ntypedef struct {\t\t\t\t\t\t\t\\\n\t_type *lock;\t\t\t\t\t\t\t\\\n\t__VA_ARGS__;\t\t\t\t\t\t\t\\\n} class_##_name##_t;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline void class_##_name##_destructor(class_##_name##_t *_T)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (_T->lock) { _unlock; }\t\t\t\t\t\\\n}\n\n\n#define __DEFINE_LOCK_GUARD_1(_name, _type, _lock)\t\t\t\\\nstatic inline class_##_name##_t class_##_name##_constructor(_type *l)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tclass_##_name##_t _t = { .lock = l }, *_T = &_t;\t\t\\\n\t_lock;\t\t\t\t\t\t\t\t\\\n\treturn _t;\t\t\t\t\t\t\t\\\n}\n\n#define __DEFINE_LOCK_GUARD_0(_name, _lock)\t\t\t\t\\\nstatic inline class_##_name##_t class_##_name##_constructor(void)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tclass_##_name##_t _t = { .lock = (void*)1 },\t\t\t\\\n\t\t\t *_T __maybe_unused = &_t;\t\t\t\\\n\t_lock;\t\t\t\t\t\t\t\t\\\n\treturn _t;\t\t\t\t\t\t\t\\\n}\n\n#define DEFINE_LOCK_GUARD_1(_name, _type, _lock, _unlock, ...)\t\t\\\n__DEFINE_UNLOCK_GUARD(_name, _type, _unlock, __VA_ARGS__)\t\t\\\n__DEFINE_LOCK_GUARD_1(_name, _type, _lock)\n\n#define DEFINE_LOCK_GUARD_0(_name, _lock, _unlock, ...)\t\t\t\\\n__DEFINE_UNLOCK_GUARD(_name, void, _unlock, __VA_ARGS__)\t\t\\\n__DEFINE_LOCK_GUARD_0(_name, _lock)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}