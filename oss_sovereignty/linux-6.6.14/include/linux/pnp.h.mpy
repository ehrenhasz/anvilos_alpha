{
  "module_name": "pnp.h",
  "hash_id": "5b7e27be9f4cafc182f57853eee7b749c6b7d46939be1f25cf5218342aa6a309",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/pnp.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_PNP_H\n#define _LINUX_PNP_H\n\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/errno.h>\n#include <linux/mod_devicetable.h>\n#include <linux/console.h>\n\n#define PNP_NAME_LEN\t\t50\n\nstruct pnp_protocol;\nstruct pnp_dev;\n\n \n#ifdef CONFIG_PNP\nstruct resource *pnp_get_resource(struct pnp_dev *dev, unsigned long type,\n\t\t\t\tunsigned int num);\n#else\nstatic inline struct resource *pnp_get_resource(struct pnp_dev *dev,\n\t\t\tunsigned long type, unsigned int num)\n{\n\treturn NULL;\n}\n#endif\n\nstatic inline int pnp_resource_valid(struct resource *res)\n{\n\tif (res)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int pnp_resource_enabled(struct resource *res)\n{\n\tif (res && !(res->flags & IORESOURCE_DISABLED))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline resource_size_t pnp_resource_len(struct resource *res)\n{\n\tif (res->start == 0 && res->end == 0)\n\t\treturn 0;\n\treturn resource_size(res);\n}\n\n\nstatic inline resource_size_t pnp_port_start(struct pnp_dev *dev,\n\t\t\t\t\t     unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_IO, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn res->start;\n\treturn 0;\n}\n\nstatic inline resource_size_t pnp_port_end(struct pnp_dev *dev,\n\t\t\t\t\t   unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_IO, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn res->end;\n\treturn 0;\n}\n\nstatic inline unsigned long pnp_port_flags(struct pnp_dev *dev,\n\t\t\t\t\t   unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_IO, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn res->flags;\n\treturn IORESOURCE_IO | IORESOURCE_AUTO;\n}\n\nstatic inline int pnp_port_valid(struct pnp_dev *dev, unsigned int bar)\n{\n\treturn pnp_resource_valid(pnp_get_resource(dev, IORESOURCE_IO, bar));\n}\n\nstatic inline resource_size_t pnp_port_len(struct pnp_dev *dev,\n\t\t\t\t\t   unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_IO, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn pnp_resource_len(res);\n\treturn 0;\n}\n\n\nstatic inline resource_size_t pnp_mem_start(struct pnp_dev *dev,\n\t\t\t\t\t    unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_MEM, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn res->start;\n\treturn 0;\n}\n\nstatic inline resource_size_t pnp_mem_end(struct pnp_dev *dev,\n\t\t\t\t\t  unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_MEM, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn res->end;\n\treturn 0;\n}\n\nstatic inline unsigned long pnp_mem_flags(struct pnp_dev *dev, unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_MEM, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn res->flags;\n\treturn IORESOURCE_MEM | IORESOURCE_AUTO;\n}\n\nstatic inline int pnp_mem_valid(struct pnp_dev *dev, unsigned int bar)\n{\n\treturn pnp_resource_valid(pnp_get_resource(dev, IORESOURCE_MEM, bar));\n}\n\nstatic inline resource_size_t pnp_mem_len(struct pnp_dev *dev,\n\t\t\t\t\t  unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_MEM, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn pnp_resource_len(res);\n\treturn 0;\n}\n\n\nstatic inline resource_size_t pnp_irq(struct pnp_dev *dev, unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_IRQ, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn res->start;\n\treturn -1;\n}\n\nstatic inline unsigned long pnp_irq_flags(struct pnp_dev *dev, unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_IRQ, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn res->flags;\n\treturn IORESOURCE_IRQ | IORESOURCE_AUTO;\n}\n\nstatic inline int pnp_irq_valid(struct pnp_dev *dev, unsigned int bar)\n{\n\treturn pnp_resource_valid(pnp_get_resource(dev, IORESOURCE_IRQ, bar));\n}\n\n\nstatic inline resource_size_t pnp_dma(struct pnp_dev *dev, unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_DMA, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn res->start;\n\treturn -1;\n}\n\nstatic inline unsigned long pnp_dma_flags(struct pnp_dev *dev, unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, IORESOURCE_DMA, bar);\n\n\tif (pnp_resource_valid(res))\n\t\treturn res->flags;\n\treturn IORESOURCE_DMA | IORESOURCE_AUTO;\n}\n\nstatic inline int pnp_dma_valid(struct pnp_dev *dev, unsigned int bar)\n{\n\treturn pnp_resource_valid(pnp_get_resource(dev, IORESOURCE_DMA, bar));\n}\n\n\n \n\nstruct pnp_card {\n\tstruct device dev;\t\t \n\tunsigned char number;\t\t \n\tstruct list_head global_list;\t \n\tstruct list_head protocol_list;\t \n\tstruct list_head devices;\t \n\n\tstruct pnp_protocol *protocol;\n\tstruct pnp_id *id;\t\t \n\n\tchar name[PNP_NAME_LEN];\t \n\tunsigned char pnpver;\t\t \n\tunsigned char productver;\t \n\tunsigned int serial;\t\t \n\tunsigned char checksum;\t\t \n\tstruct proc_dir_entry *procdir;\t \n};\n\n#define global_to_pnp_card(n) list_entry(n, struct pnp_card, global_list)\n#define protocol_to_pnp_card(n) list_entry(n, struct pnp_card, protocol_list)\n#define to_pnp_card(n) container_of(n, struct pnp_card, dev)\n#define pnp_for_each_card(card)\t\\\n\tlist_for_each_entry(card, &pnp_cards, global_list)\n\nstruct pnp_card_link {\n\tstruct pnp_card *card;\n\tstruct pnp_card_driver *driver;\n\tvoid *driver_data;\n\tpm_message_t pm_state;\n};\n\nstatic inline void *pnp_get_card_drvdata(struct pnp_card_link *pcard)\n{\n\treturn pcard->driver_data;\n}\n\nstatic inline void pnp_set_card_drvdata(struct pnp_card_link *pcard, void *data)\n{\n\tpcard->driver_data = data;\n}\n\nstruct pnp_dev {\n\tstruct device dev;\t\t \n\tu64 dma_mask;\n\tunsigned int number;\t\t \n\tint status;\n\n\tstruct list_head global_list;\t \n\tstruct list_head protocol_list;\t \n\tstruct list_head card_list;\t \n\tstruct list_head rdev_list;\t \n\n\tstruct pnp_protocol *protocol;\n\tstruct pnp_card *card;\t \n\tstruct pnp_driver *driver;\n\tstruct pnp_card_link *card_link;\n\n\tstruct pnp_id *id;\t\t \n\n\tint active;\n\tint capabilities;\n\tunsigned int num_dependent_sets;\n\tstruct list_head resources;\n\tstruct list_head options;\n\n\tchar name[PNP_NAME_LEN];\t \n\tint flags;\t\t\t \n\tstruct proc_dir_entry *procent;\t \n\tvoid *data;\n};\n\n#define global_to_pnp_dev(n) list_entry(n, struct pnp_dev, global_list)\n#define card_to_pnp_dev(n) list_entry(n, struct pnp_dev, card_list)\n#define protocol_to_pnp_dev(n) list_entry(n, struct pnp_dev, protocol_list)\n#define\tto_pnp_dev(n) container_of(n, struct pnp_dev, dev)\n#define pnp_for_each_dev(dev) list_for_each_entry(dev, &pnp_global, global_list)\n#define card_for_each_dev(card, dev)\t\\\n\tlist_for_each_entry(dev, &(card)->devices, card_list)\n#define pnp_dev_name(dev) (dev)->name\n\nstatic inline void *pnp_get_drvdata(struct pnp_dev *pdev)\n{\n\treturn dev_get_drvdata(&pdev->dev);\n}\n\nstatic inline void pnp_set_drvdata(struct pnp_dev *pdev, void *data)\n{\n\tdev_set_drvdata(&pdev->dev, data);\n}\n\nstruct pnp_fixup {\n\tchar id[7];\n\tvoid (*quirk_function) (struct pnp_dev * dev);\t \n};\n\n \n#define PNP_CONFIG_NORMAL\t0x0001\n#define PNP_CONFIG_FORCE\t0x0002\t \n\n \n#define PNP_READ\t\t0x0001\n#define PNP_WRITE\t\t0x0002\n#define PNP_DISABLE\t\t0x0004\n#define PNP_CONFIGURABLE\t0x0008\n#define PNP_REMOVABLE\t\t0x0010\n#define PNP_CONSOLE\t\t0x0020\n\n#define pnp_can_read(dev)\t(((dev)->protocol->get) && \\\n\t\t\t\t ((dev)->capabilities & PNP_READ))\n#define pnp_can_write(dev)\t(((dev)->protocol->set) && \\\n\t\t\t\t ((dev)->capabilities & PNP_WRITE))\n#define pnp_can_disable(dev)\t(((dev)->protocol->disable) &&\t\t  \\\n\t\t\t\t ((dev)->capabilities & PNP_DISABLE) &&\t  \\\n\t\t\t\t (!((dev)->capabilities & PNP_CONSOLE) || \\\n\t\t\t\t  console_suspend_enabled))\n#define pnp_can_configure(dev)\t((!(dev)->active) && \\\n\t\t\t\t ((dev)->capabilities & PNP_CONFIGURABLE))\n#define pnp_can_suspend(dev)\t(((dev)->protocol->suspend) &&\t\t  \\\n\t\t\t\t (!((dev)->capabilities & PNP_CONSOLE) || \\\n\t\t\t\t  console_suspend_enabled))\n\n\n#ifdef CONFIG_ISAPNP\nextern struct pnp_protocol isapnp_protocol;\n#define pnp_device_is_isapnp(dev) ((dev)->protocol == (&isapnp_protocol))\n#else\n#define pnp_device_is_isapnp(dev) 0\n#endif\nextern struct mutex pnp_res_mutex;\n\n#ifdef CONFIG_PNPBIOS\nextern struct pnp_protocol pnpbios_protocol;\nextern bool arch_pnpbios_disabled(void);\n#define pnp_device_is_pnpbios(dev) ((dev)->protocol == (&pnpbios_protocol))\n#else\n#define pnp_device_is_pnpbios(dev) 0\n#define arch_pnpbios_disabled()\tfalse\n#endif\n\n#ifdef CONFIG_PNPACPI\nextern struct pnp_protocol pnpacpi_protocol;\n\nstatic inline struct acpi_device *pnp_acpi_device(struct pnp_dev *dev)\n{\n\tif (dev->protocol == &pnpacpi_protocol)\n\t\treturn dev->data;\n\treturn NULL;\n}\n#else\n#define pnp_acpi_device(dev) 0\n#endif\n\n \n#define PNP_READY\t\t0x0000\n#define PNP_ATTACHED\t\t0x0001\n#define PNP_BUSY\t\t0x0002\n#define PNP_FAULTY\t\t0x0004\n\n \n\n#define isapnp_card_number(dev)\t((dev)->card ? (dev)->card->number : -1)\n#define isapnp_csn_number(dev)  ((dev)->number)\n\n \n\nstruct pnp_id {\n\tchar id[PNP_ID_LEN];\n\tstruct pnp_id *next;\n};\n\nstruct pnp_driver {\n\tconst char *name;\n\tconst struct pnp_device_id *id_table;\n\tunsigned int flags;\n\tint (*probe) (struct pnp_dev *dev, const struct pnp_device_id *dev_id);\n\tvoid (*remove) (struct pnp_dev *dev);\n\tvoid (*shutdown) (struct pnp_dev *dev);\n\tint (*suspend) (struct pnp_dev *dev, pm_message_t state);\n\tint (*resume) (struct pnp_dev *dev);\n\tstruct device_driver driver;\n};\n\n#define\tto_pnp_driver(drv) container_of(drv, struct pnp_driver, driver)\n\nstruct pnp_card_driver {\n\tstruct list_head global_list;\n\tchar *name;\n\tconst struct pnp_card_device_id *id_table;\n\tunsigned int flags;\n\tint (*probe) (struct pnp_card_link *card,\n\t\t      const struct pnp_card_device_id *card_id);\n\tvoid (*remove) (struct pnp_card_link *card);\n\tint (*suspend) (struct pnp_card_link *card, pm_message_t state);\n\tint (*resume) (struct pnp_card_link *card);\n\tstruct pnp_driver link;\n};\n\n#define\tto_pnp_card_driver(drv) container_of(drv, struct pnp_card_driver, link)\n\n \n#define PNP_DRIVER_RES_DO_NOT_CHANGE\t0x0001\t \n#define PNP_DRIVER_RES_DISABLE\t\t0x0003\t \n\n \n\nstruct pnp_protocol {\n\tstruct list_head protocol_list;\n\tchar *name;\n\n\t \n\tint (*get) (struct pnp_dev *dev);\n\tint (*set) (struct pnp_dev *dev);\n\tint (*disable) (struct pnp_dev *dev);\n\n\t \n\tbool (*can_wakeup) (struct pnp_dev *dev);\n\tint (*suspend) (struct pnp_dev * dev, pm_message_t state);\n\tint (*resume) (struct pnp_dev * dev);\n\n\t \n\tunsigned char number;\t \n\tstruct device dev;\t \n\tstruct list_head cards;\n\tstruct list_head devices;\n};\n\n#define to_pnp_protocol(n) list_entry(n, struct pnp_protocol, protocol_list)\n#define protocol_for_each_card(protocol, card)\t\\\n\tlist_for_each_entry(card, &(protocol)->cards, protocol_list)\n#define protocol_for_each_dev(protocol, dev)\t\\\n\tlist_for_each_entry(dev, &(protocol)->devices, protocol_list)\n\nextern struct bus_type pnp_bus_type;\n\n#if defined(CONFIG_PNP)\n\n \nint pnp_device_attach(struct pnp_dev *pnp_dev);\nvoid pnp_device_detach(struct pnp_dev *pnp_dev);\nextern struct list_head pnp_global;\nextern int pnp_platform_devices;\n\n \nstruct pnp_dev *pnp_request_card_device(struct pnp_card_link *clink,\n\t\t\t\t\tconst char *id, struct pnp_dev *from);\nvoid pnp_release_card_device(struct pnp_dev *dev);\nint pnp_register_card_driver(struct pnp_card_driver *drv);\nvoid pnp_unregister_card_driver(struct pnp_card_driver *drv);\nextern struct list_head pnp_cards;\n\n \nint pnp_possible_config(struct pnp_dev *dev, int type, resource_size_t base,\n\t\t\tresource_size_t size);\nint pnp_auto_config_dev(struct pnp_dev *dev);\nint pnp_start_dev(struct pnp_dev *dev);\nint pnp_stop_dev(struct pnp_dev *dev);\nint pnp_activate_dev(struct pnp_dev *dev);\nint pnp_disable_dev(struct pnp_dev *dev);\nint pnp_range_reserved(resource_size_t start, resource_size_t end);\n\n \nint pnp_is_active(struct pnp_dev *dev);\nint compare_pnp_id(struct pnp_id *pos, const char *id);\nint pnp_register_driver(struct pnp_driver *drv);\nvoid pnp_unregister_driver(struct pnp_driver *drv);\n\n#else\n\n \nstatic inline int pnp_device_attach(struct pnp_dev *pnp_dev) { return -ENODEV; }\nstatic inline void pnp_device_detach(struct pnp_dev *pnp_dev) { }\n\n#define pnp_platform_devices 0\n\n \nstatic inline struct pnp_dev *pnp_request_card_device(struct pnp_card_link *clink, const char *id, struct pnp_dev *from) { return NULL; }\nstatic inline void pnp_release_card_device(struct pnp_dev *dev) { }\nstatic inline int pnp_register_card_driver(struct pnp_card_driver *drv) { return -ENODEV; }\nstatic inline void pnp_unregister_card_driver(struct pnp_card_driver *drv) { }\n\n \nstatic inline int pnp_possible_config(struct pnp_dev *dev, int type,\n\t\t\t\t      resource_size_t base,\n\t\t\t\t      resource_size_t size) { return 0; }\nstatic inline int pnp_auto_config_dev(struct pnp_dev *dev) { return -ENODEV; }\nstatic inline int pnp_start_dev(struct pnp_dev *dev) { return -ENODEV; }\nstatic inline int pnp_stop_dev(struct pnp_dev *dev) { return -ENODEV; }\nstatic inline int pnp_activate_dev(struct pnp_dev *dev) { return -ENODEV; }\nstatic inline int pnp_disable_dev(struct pnp_dev *dev) { return -ENODEV; }\nstatic inline int pnp_range_reserved(resource_size_t start, resource_size_t end) { return 0;}\n\n \nstatic inline int pnp_is_active(struct pnp_dev *dev) { return 0; }\nstatic inline int compare_pnp_id(struct pnp_id *pos, const char *id) { return -ENODEV; }\nstatic inline int pnp_register_driver(struct pnp_driver *drv) { return -ENODEV; }\nstatic inline void pnp_unregister_driver(struct pnp_driver *drv) { }\n\n#endif  \n\n \n#define module_pnp_driver(__pnp_driver) \\\n\tmodule_driver(__pnp_driver, pnp_register_driver, \\\n\t\t\t\t    pnp_unregister_driver)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}