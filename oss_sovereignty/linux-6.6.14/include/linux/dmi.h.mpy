{
  "module_name": "dmi.h",
  "hash_id": "df2fb8dc28ba2c2f7d66ae1314d3ef5df6e00edff70c8a115fdcc736834500b3",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/dmi.h",
  "human_readable_source": " \n#ifndef __DMI_H__\n#define __DMI_H__\n\n#include <linux/list.h>\n#include <linux/kobject.h>\n#include <linux/mod_devicetable.h>\n\n \n\nenum dmi_device_type {\n\tDMI_DEV_TYPE_ANY = 0,\n\tDMI_DEV_TYPE_OTHER,\n\tDMI_DEV_TYPE_UNKNOWN,\n\tDMI_DEV_TYPE_VIDEO,\n\tDMI_DEV_TYPE_SCSI,\n\tDMI_DEV_TYPE_ETHERNET,\n\tDMI_DEV_TYPE_TOKENRING,\n\tDMI_DEV_TYPE_SOUND,\n\tDMI_DEV_TYPE_PATA,\n\tDMI_DEV_TYPE_SATA,\n\tDMI_DEV_TYPE_SAS,\n\tDMI_DEV_TYPE_IPMI = -1,\n\tDMI_DEV_TYPE_OEM_STRING = -2,\n\tDMI_DEV_TYPE_DEV_ONBOARD = -3,\n\tDMI_DEV_TYPE_DEV_SLOT = -4,\n};\n\nenum dmi_entry_type {\n\tDMI_ENTRY_BIOS = 0,\n\tDMI_ENTRY_SYSTEM,\n\tDMI_ENTRY_BASEBOARD,\n\tDMI_ENTRY_CHASSIS,\n\tDMI_ENTRY_PROCESSOR,\n\tDMI_ENTRY_MEM_CONTROLLER,\n\tDMI_ENTRY_MEM_MODULE,\n\tDMI_ENTRY_CACHE,\n\tDMI_ENTRY_PORT_CONNECTOR,\n\tDMI_ENTRY_SYSTEM_SLOT,\n\tDMI_ENTRY_ONBOARD_DEVICE,\n\tDMI_ENTRY_OEMSTRINGS,\n\tDMI_ENTRY_SYSCONF,\n\tDMI_ENTRY_BIOS_LANG,\n\tDMI_ENTRY_GROUP_ASSOC,\n\tDMI_ENTRY_SYSTEM_EVENT_LOG,\n\tDMI_ENTRY_PHYS_MEM_ARRAY,\n\tDMI_ENTRY_MEM_DEVICE,\n\tDMI_ENTRY_32_MEM_ERROR,\n\tDMI_ENTRY_MEM_ARRAY_MAPPED_ADDR,\n\tDMI_ENTRY_MEM_DEV_MAPPED_ADDR,\n\tDMI_ENTRY_BUILTIN_POINTING_DEV,\n\tDMI_ENTRY_PORTABLE_BATTERY,\n\tDMI_ENTRY_SYSTEM_RESET,\n\tDMI_ENTRY_HW_SECURITY,\n\tDMI_ENTRY_SYSTEM_POWER_CONTROLS,\n\tDMI_ENTRY_VOLTAGE_PROBE,\n\tDMI_ENTRY_COOLING_DEV,\n\tDMI_ENTRY_TEMP_PROBE,\n\tDMI_ENTRY_ELECTRICAL_CURRENT_PROBE,\n\tDMI_ENTRY_OOB_REMOTE_ACCESS,\n\tDMI_ENTRY_BIS_ENTRY,\n\tDMI_ENTRY_SYSTEM_BOOT,\n\tDMI_ENTRY_MGMT_DEV,\n\tDMI_ENTRY_MGMT_DEV_COMPONENT,\n\tDMI_ENTRY_MGMT_DEV_THRES,\n\tDMI_ENTRY_MEM_CHANNEL,\n\tDMI_ENTRY_IPMI_DEV,\n\tDMI_ENTRY_SYS_POWER_SUPPLY,\n\tDMI_ENTRY_ADDITIONAL,\n\tDMI_ENTRY_ONBOARD_DEV_EXT,\n\tDMI_ENTRY_MGMT_CONTROLLER_HOST,\n\tDMI_ENTRY_INACTIVE = 126,\n\tDMI_ENTRY_END_OF_TABLE = 127,\n};\n\nstruct dmi_header {\n\tu8 type;\n\tu8 length;\n\tu16 handle;\n} __packed;\n\nstruct dmi_device {\n\tstruct list_head list;\n\tint type;\n\tconst char *name;\n\tvoid *device_data;\t \n};\n\n#ifdef CONFIG_DMI\n\nstruct dmi_dev_onboard {\n\tstruct dmi_device dev;\n\tint instance;\n\tint segment;\n\tint bus;\n\tint devfn;\n};\n\nextern struct kobject *dmi_kobj;\nextern int dmi_check_system(const struct dmi_system_id *list);\nconst struct dmi_system_id *dmi_first_match(const struct dmi_system_id *list);\nextern const char * dmi_get_system_info(int field);\nextern const struct dmi_device * dmi_find_device(int type, const char *name,\n\tconst struct dmi_device *from);\nextern void dmi_setup(void);\nextern bool dmi_get_date(int field, int *yearp, int *monthp, int *dayp);\nextern int dmi_get_bios_year(void);\nextern int dmi_name_in_vendors(const char *str);\nextern int dmi_name_in_serial(const char *str);\nextern int dmi_available;\nextern int dmi_walk(void (*decode)(const struct dmi_header *, void *),\n\tvoid *private_data);\nextern bool dmi_match(enum dmi_field f, const char *str);\nextern void dmi_memdev_name(u16 handle, const char **bank, const char **device);\nextern u64 dmi_memdev_size(u16 handle);\nextern u8 dmi_memdev_type(u16 handle);\nextern u16 dmi_memdev_handle(int slot);\n\n#else\n\nstatic inline int dmi_check_system(const struct dmi_system_id *list) { return 0; }\nstatic inline const char * dmi_get_system_info(int field) { return NULL; }\nstatic inline const struct dmi_device * dmi_find_device(int type, const char *name,\n\tconst struct dmi_device *from) { return NULL; }\nstatic inline void dmi_setup(void) { }\nstatic inline bool dmi_get_date(int field, int *yearp, int *monthp, int *dayp)\n{\n\tif (yearp)\n\t\t*yearp = 0;\n\tif (monthp)\n\t\t*monthp = 0;\n\tif (dayp)\n\t\t*dayp = 0;\n\treturn false;\n}\nstatic inline int dmi_get_bios_year(void) { return -ENXIO; }\nstatic inline int dmi_name_in_vendors(const char *s) { return 0; }\nstatic inline int dmi_name_in_serial(const char *s) { return 0; }\n#define dmi_available 0\nstatic inline int dmi_walk(void (*decode)(const struct dmi_header *, void *),\n\tvoid *private_data) { return -ENXIO; }\nstatic inline bool dmi_match(enum dmi_field f, const char *str)\n\t{ return false; }\nstatic inline void dmi_memdev_name(u16 handle, const char **bank,\n\t\tconst char **device) { }\nstatic inline u64 dmi_memdev_size(u16 handle) { return ~0ul; }\nstatic inline u8 dmi_memdev_type(u16 handle) { return 0x0; }\nstatic inline u16 dmi_memdev_handle(int slot) { return 0xffff; }\nstatic inline const struct dmi_system_id *\n\tdmi_first_match(const struct dmi_system_id *list) { return NULL; }\n\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}