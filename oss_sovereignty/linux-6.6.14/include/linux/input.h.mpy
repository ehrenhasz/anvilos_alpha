{
  "module_name": "input.h",
  "hash_id": "71c48f3c824b58007a949e3a50ed82e6896fb864f593b202f4fb15decdd2c296",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/input.h",
  "human_readable_source": " \n \n#ifndef _INPUT_H\n#define _INPUT_H\n\n#include <linux/time.h>\n#include <linux/list.h>\n#include <uapi/linux/input.h>\n \n#define ABS_MT_FIRST\t\tABS_MT_TOUCH_MAJOR\n#define ABS_MT_LAST\t\tABS_MT_TOOL_Y\n\n \n\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/timer.h>\n#include <linux/mod_devicetable.h>\n\nstruct input_dev_poller;\n\n \nstruct input_value {\n\t__u16 type;\n\t__u16 code;\n\t__s32 value;\n};\n\nenum input_clock_type {\n\tINPUT_CLK_REAL = 0,\n\tINPUT_CLK_MONO,\n\tINPUT_CLK_BOOT,\n\tINPUT_CLK_MAX\n};\n\n \nstruct input_dev {\n\tconst char *name;\n\tconst char *phys;\n\tconst char *uniq;\n\tstruct input_id id;\n\n\tunsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\n\n\tunsigned long evbit[BITS_TO_LONGS(EV_CNT)];\n\tunsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\n\tunsigned long relbit[BITS_TO_LONGS(REL_CNT)];\n\tunsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\n\tunsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\n\tunsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\n\tunsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\n\tunsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\n\tunsigned long swbit[BITS_TO_LONGS(SW_CNT)];\n\n\tunsigned int hint_events_per_packet;\n\n\tunsigned int keycodemax;\n\tunsigned int keycodesize;\n\tvoid *keycode;\n\n\tint (*setkeycode)(struct input_dev *dev,\n\t\t\t  const struct input_keymap_entry *ke,\n\t\t\t  unsigned int *old_keycode);\n\tint (*getkeycode)(struct input_dev *dev,\n\t\t\t  struct input_keymap_entry *ke);\n\n\tstruct ff_device *ff;\n\n\tstruct input_dev_poller *poller;\n\n\tunsigned int repeat_key;\n\tstruct timer_list timer;\n\n\tint rep[REP_CNT];\n\n\tstruct input_mt *mt;\n\n\tstruct input_absinfo *absinfo;\n\n\tunsigned long key[BITS_TO_LONGS(KEY_CNT)];\n\tunsigned long led[BITS_TO_LONGS(LED_CNT)];\n\tunsigned long snd[BITS_TO_LONGS(SND_CNT)];\n\tunsigned long sw[BITS_TO_LONGS(SW_CNT)];\n\n\tint (*open)(struct input_dev *dev);\n\tvoid (*close)(struct input_dev *dev);\n\tint (*flush)(struct input_dev *dev, struct file *file);\n\tint (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\n\n\tstruct input_handle __rcu *grab;\n\n\tspinlock_t event_lock;\n\tstruct mutex mutex;\n\n\tunsigned int users;\n\tbool going_away;\n\n\tstruct device dev;\n\n\tstruct list_head\th_list;\n\tstruct list_head\tnode;\n\n\tunsigned int num_vals;\n\tunsigned int max_vals;\n\tstruct input_value *vals;\n\n\tbool devres_managed;\n\n\tktime_t timestamp[INPUT_CLK_MAX];\n\n\tbool inhibited;\n};\n#define to_input_dev(d) container_of(d, struct input_dev, dev)\n\n \n\n#if EV_MAX != INPUT_DEVICE_ID_EV_MAX\n#error \"EV_MAX and INPUT_DEVICE_ID_EV_MAX do not match\"\n#endif\n\n#if KEY_MIN_INTERESTING != INPUT_DEVICE_ID_KEY_MIN_INTERESTING\n#error \"KEY_MIN_INTERESTING and INPUT_DEVICE_ID_KEY_MIN_INTERESTING do not match\"\n#endif\n\n#if KEY_MAX != INPUT_DEVICE_ID_KEY_MAX\n#error \"KEY_MAX and INPUT_DEVICE_ID_KEY_MAX do not match\"\n#endif\n\n#if REL_MAX != INPUT_DEVICE_ID_REL_MAX\n#error \"REL_MAX and INPUT_DEVICE_ID_REL_MAX do not match\"\n#endif\n\n#if ABS_MAX != INPUT_DEVICE_ID_ABS_MAX\n#error \"ABS_MAX and INPUT_DEVICE_ID_ABS_MAX do not match\"\n#endif\n\n#if MSC_MAX != INPUT_DEVICE_ID_MSC_MAX\n#error \"MSC_MAX and INPUT_DEVICE_ID_MSC_MAX do not match\"\n#endif\n\n#if LED_MAX != INPUT_DEVICE_ID_LED_MAX\n#error \"LED_MAX and INPUT_DEVICE_ID_LED_MAX do not match\"\n#endif\n\n#if SND_MAX != INPUT_DEVICE_ID_SND_MAX\n#error \"SND_MAX and INPUT_DEVICE_ID_SND_MAX do not match\"\n#endif\n\n#if FF_MAX != INPUT_DEVICE_ID_FF_MAX\n#error \"FF_MAX and INPUT_DEVICE_ID_FF_MAX do not match\"\n#endif\n\n#if SW_MAX != INPUT_DEVICE_ID_SW_MAX\n#error \"SW_MAX and INPUT_DEVICE_ID_SW_MAX do not match\"\n#endif\n\n#if INPUT_PROP_MAX != INPUT_DEVICE_ID_PROP_MAX\n#error \"INPUT_PROP_MAX and INPUT_DEVICE_ID_PROP_MAX do not match\"\n#endif\n\n#define INPUT_DEVICE_ID_MATCH_DEVICE \\\n\t(INPUT_DEVICE_ID_MATCH_BUS | INPUT_DEVICE_ID_MATCH_VENDOR | INPUT_DEVICE_ID_MATCH_PRODUCT)\n#define INPUT_DEVICE_ID_MATCH_DEVICE_AND_VERSION \\\n\t(INPUT_DEVICE_ID_MATCH_DEVICE | INPUT_DEVICE_ID_MATCH_VERSION)\n\nstruct input_handle;\n\n \nstruct input_handler {\n\n\tvoid *private;\n\n\tvoid (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);\n\tvoid (*events)(struct input_handle *handle,\n\t\t       const struct input_value *vals, unsigned int count);\n\tbool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);\n\tbool (*match)(struct input_handler *handler, struct input_dev *dev);\n\tint (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);\n\tvoid (*disconnect)(struct input_handle *handle);\n\tvoid (*start)(struct input_handle *handle);\n\n\tbool legacy_minors;\n\tint minor;\n\tconst char *name;\n\n\tconst struct input_device_id *id_table;\n\n\tstruct list_head\th_list;\n\tstruct list_head\tnode;\n};\n\n \nstruct input_handle {\n\n\tvoid *private;\n\n\tint open;\n\tconst char *name;\n\n\tstruct input_dev *dev;\n\tstruct input_handler *handler;\n\n\tstruct list_head\td_node;\n\tstruct list_head\th_node;\n};\n\nstruct input_dev __must_check *input_allocate_device(void);\nstruct input_dev __must_check *devm_input_allocate_device(struct device *);\nvoid input_free_device(struct input_dev *dev);\n\nstatic inline struct input_dev *input_get_device(struct input_dev *dev)\n{\n\treturn dev ? to_input_dev(get_device(&dev->dev)) : NULL;\n}\n\nstatic inline void input_put_device(struct input_dev *dev)\n{\n\tif (dev)\n\t\tput_device(&dev->dev);\n}\n\nstatic inline void *input_get_drvdata(struct input_dev *dev)\n{\n\treturn dev_get_drvdata(&dev->dev);\n}\n\nstatic inline void input_set_drvdata(struct input_dev *dev, void *data)\n{\n\tdev_set_drvdata(&dev->dev, data);\n}\n\nint __must_check input_register_device(struct input_dev *);\nvoid input_unregister_device(struct input_dev *);\n\nvoid input_reset_device(struct input_dev *);\n\nint input_setup_polling(struct input_dev *dev,\n\t\t\tvoid (*poll_fn)(struct input_dev *dev));\nvoid input_set_poll_interval(struct input_dev *dev, unsigned int interval);\nvoid input_set_min_poll_interval(struct input_dev *dev, unsigned int interval);\nvoid input_set_max_poll_interval(struct input_dev *dev, unsigned int interval);\nint input_get_poll_interval(struct input_dev *dev);\n\nint __must_check input_register_handler(struct input_handler *);\nvoid input_unregister_handler(struct input_handler *);\n\nint __must_check input_get_new_minor(int legacy_base, unsigned int legacy_num,\n\t\t\t\t     bool allow_dynamic);\nvoid input_free_minor(unsigned int minor);\n\nint input_handler_for_each_handle(struct input_handler *, void *data,\n\t\t\t\t  int (*fn)(struct input_handle *, void *));\n\nint input_register_handle(struct input_handle *);\nvoid input_unregister_handle(struct input_handle *);\n\nint input_grab_device(struct input_handle *);\nvoid input_release_device(struct input_handle *);\n\nint input_open_device(struct input_handle *);\nvoid input_close_device(struct input_handle *);\n\nint input_flush_device(struct input_handle *handle, struct file *file);\n\nvoid input_set_timestamp(struct input_dev *dev, ktime_t timestamp);\nktime_t *input_get_timestamp(struct input_dev *dev);\n\nvoid input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);\nvoid input_inject_event(struct input_handle *handle, unsigned int type, unsigned int code, int value);\n\nstatic inline void input_report_key(struct input_dev *dev, unsigned int code, int value)\n{\n\tinput_event(dev, EV_KEY, code, !!value);\n}\n\nstatic inline void input_report_rel(struct input_dev *dev, unsigned int code, int value)\n{\n\tinput_event(dev, EV_REL, code, value);\n}\n\nstatic inline void input_report_abs(struct input_dev *dev, unsigned int code, int value)\n{\n\tinput_event(dev, EV_ABS, code, value);\n}\n\nstatic inline void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)\n{\n\tinput_event(dev, EV_FF_STATUS, code, value);\n}\n\nstatic inline void input_report_switch(struct input_dev *dev, unsigned int code, int value)\n{\n\tinput_event(dev, EV_SW, code, !!value);\n}\n\nstatic inline void input_sync(struct input_dev *dev)\n{\n\tinput_event(dev, EV_SYN, SYN_REPORT, 0);\n}\n\nstatic inline void input_mt_sync(struct input_dev *dev)\n{\n\tinput_event(dev, EV_SYN, SYN_MT_REPORT, 0);\n}\n\nvoid input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code);\n\n \nstatic inline void input_set_events_per_packet(struct input_dev *dev, int n_events)\n{\n\tdev->hint_events_per_packet = n_events;\n}\n\nvoid input_alloc_absinfo(struct input_dev *dev);\nvoid input_set_abs_params(struct input_dev *dev, unsigned int axis,\n\t\t\t  int min, int max, int fuzz, int flat);\nvoid input_copy_abs(struct input_dev *dst, unsigned int dst_axis,\n\t\t    const struct input_dev *src, unsigned int src_axis);\n\n#define INPUT_GENERATE_ABS_ACCESSORS(_suffix, _item)\t\t\t\\\nstatic inline int input_abs_get_##_suffix(struct input_dev *dev,\t\\\n\t\t\t\t\t  unsigned int axis)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn dev->absinfo ? dev->absinfo[axis]._item : 0;\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline void input_abs_set_##_suffix(struct input_dev *dev,\t\\\n\t\t\t\t\t   unsigned int axis, int val)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tinput_alloc_absinfo(dev);\t\t\t\t\t\\\n\tif (dev->absinfo)\t\t\t\t\t\t\\\n\t\tdev->absinfo[axis]._item = val;\t\t\t\t\\\n}\n\nINPUT_GENERATE_ABS_ACCESSORS(val, value)\nINPUT_GENERATE_ABS_ACCESSORS(min, minimum)\nINPUT_GENERATE_ABS_ACCESSORS(max, maximum)\nINPUT_GENERATE_ABS_ACCESSORS(fuzz, fuzz)\nINPUT_GENERATE_ABS_ACCESSORS(flat, flat)\nINPUT_GENERATE_ABS_ACCESSORS(res, resolution)\n\nint input_scancode_to_scalar(const struct input_keymap_entry *ke,\n\t\t\t     unsigned int *scancode);\n\nint input_get_keycode(struct input_dev *dev, struct input_keymap_entry *ke);\nint input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke);\n\nbool input_match_device_id(const struct input_dev *dev,\n\t\t\t   const struct input_device_id *id);\n\nvoid input_enable_softrepeat(struct input_dev *dev, int delay, int period);\n\nbool input_device_enabled(struct input_dev *dev);\n\nextern struct class input_class;\n\n \nstruct ff_device {\n\tint (*upload)(struct input_dev *dev, struct ff_effect *effect,\n\t\t      struct ff_effect *old);\n\tint (*erase)(struct input_dev *dev, int effect_id);\n\n\tint (*playback)(struct input_dev *dev, int effect_id, int value);\n\tvoid (*set_gain)(struct input_dev *dev, u16 gain);\n\tvoid (*set_autocenter)(struct input_dev *dev, u16 magnitude);\n\n\tvoid (*destroy)(struct ff_device *);\n\n\tvoid *private;\n\n\tunsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\n\n\tstruct mutex mutex;\n\n\tint max_effects;\n\tstruct ff_effect *effects;\n\tstruct file *effect_owners[];\n};\n\nint input_ff_create(struct input_dev *dev, unsigned int max_effects);\nvoid input_ff_destroy(struct input_dev *dev);\n\nint input_ff_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);\n\nint input_ff_upload(struct input_dev *dev, struct ff_effect *effect, struct file *file);\nint input_ff_erase(struct input_dev *dev, int effect_id, struct file *file);\nint input_ff_flush(struct input_dev *dev, struct file *file);\n\nint input_ff_create_memless(struct input_dev *dev, void *data,\n\t\tint (*play_effect)(struct input_dev *, void *, struct ff_effect *));\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}