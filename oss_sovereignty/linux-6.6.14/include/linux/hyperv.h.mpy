{
  "module_name": "hyperv.h",
  "hash_id": "11cad74b0ebbf3e50bc1019fb3f8ef27811d71158f93277d37f125c7c43cf03e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/hyperv.h",
  "human_readable_source": " \n \n\n#ifndef _HYPERV_H\n#define _HYPERV_H\n\n#include <uapi/linux/hyperv.h>\n\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/scatterlist.h>\n#include <linux/list.h>\n#include <linux/timer.h>\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/interrupt.h>\n#include <linux/reciprocal_div.h>\n#include <asm/hyperv-tlfs.h>\n\n#define MAX_PAGE_BUFFER_COUNT\t\t\t\t32\n#define MAX_MULTIPAGE_BUFFER_COUNT\t\t\t32  \n\n#pragma pack(push, 1)\n\n \nenum hv_gpadl_type {\n\tHV_GPADL_BUFFER,\n\tHV_GPADL_RING\n};\n\n \nstruct hv_page_buffer {\n\tu32 len;\n\tu32 offset;\n\tu64 pfn;\n};\n\n \nstruct hv_multipage_buffer {\n\t \n\tu32 len;\n\tu32 offset;\n\tu64 pfn_array[MAX_MULTIPAGE_BUFFER_COUNT];\n};\n\n \nstruct hv_mpb_array {\n\t \n\tu32 len;\n\tu32 offset;\n\tu64 pfn_array[];\n};\n\n \n#define MAX_PAGE_BUFFER_PACKET\t\t(0x18 +\t\t\t\\\n\t\t\t\t\t(sizeof(struct hv_page_buffer) * \\\n\t\t\t\t\t MAX_PAGE_BUFFER_COUNT))\n#define MAX_MULTIPAGE_BUFFER_PACKET\t(0x18 +\t\t\t\\\n\t\t\t\t\t sizeof(struct hv_multipage_buffer))\n\n\n#pragma pack(pop)\n\nstruct hv_ring_buffer {\n\t \n\tu32 write_index;\n\n\t \n\tu32 read_index;\n\n\tu32 interrupt_mask;\n\n\t \n\tu32 pending_send_sz;\n\tu32 reserved1[12];\n\tunion {\n\t\tstruct {\n\t\t\tu32 feat_pending_send_sz:1;\n\t\t};\n\t\tu32 value;\n\t} feature_bits;\n\n\t \n\tu8\treserved2[PAGE_SIZE - 68];\n\n\t \n\tu8 buffer[];\n} __packed;\n\n \n#define VMBUS_RING_SIZE(payload_sz) PAGE_ALIGN(sizeof(struct hv_ring_buffer) + \\\n\t\t\t\t\t       (payload_sz))\n\nstruct hv_ring_buffer_info {\n\tstruct hv_ring_buffer *ring_buffer;\n\tu32 ring_size;\t\t\t \n\tstruct reciprocal_value ring_size_div10_reciprocal;\n\tspinlock_t ring_lock;\n\n\tu32 ring_datasize;\t\t \n\tu32 priv_read_index;\n\t \n\tstruct mutex ring_buffer_mutex;\n\n\t \n\tvoid *pkt_buffer;\n\tu32 pkt_buffer_size;\n};\n\n\nstatic inline u32 hv_get_bytes_to_read(const struct hv_ring_buffer_info *rbi)\n{\n\tu32 read_loc, write_loc, dsize, read;\n\n\tdsize = rbi->ring_datasize;\n\tread_loc = rbi->ring_buffer->read_index;\n\twrite_loc = READ_ONCE(rbi->ring_buffer->write_index);\n\n\tread = write_loc >= read_loc ? (write_loc - read_loc) :\n\t\t(dsize - read_loc) + write_loc;\n\n\treturn read;\n}\n\nstatic inline u32 hv_get_bytes_to_write(const struct hv_ring_buffer_info *rbi)\n{\n\tu32 read_loc, write_loc, dsize, write;\n\n\tdsize = rbi->ring_datasize;\n\tread_loc = READ_ONCE(rbi->ring_buffer->read_index);\n\twrite_loc = rbi->ring_buffer->write_index;\n\n\twrite = write_loc >= read_loc ? dsize - (write_loc - read_loc) :\n\t\tread_loc - write_loc;\n\treturn write;\n}\n\nstatic inline u32 hv_get_avail_to_write_percent(\n\t\tconst struct hv_ring_buffer_info *rbi)\n{\n\tu32 avail_write = hv_get_bytes_to_write(rbi);\n\n\treturn reciprocal_divide(\n\t\t\t(avail_write  << 3) + (avail_write << 1),\n\t\t\trbi->ring_size_div10_reciprocal);\n}\n\n \n\n#define VERSION_WS2008  ((0 << 16) | (13))\n#define VERSION_WIN7    ((1 << 16) | (1))\n#define VERSION_WIN8    ((2 << 16) | (4))\n#define VERSION_WIN8_1    ((3 << 16) | (0))\n#define VERSION_WIN10 ((4 << 16) | (0))\n#define VERSION_WIN10_V4_1 ((4 << 16) | (1))\n#define VERSION_WIN10_V5 ((5 << 16) | (0))\n#define VERSION_WIN10_V5_1 ((5 << 16) | (1))\n#define VERSION_WIN10_V5_2 ((5 << 16) | (2))\n#define VERSION_WIN10_V5_3 ((5 << 16) | (3))\n\n \n#define MAX_PIPE_DATA_PAYLOAD\t\t(sizeof(u8) * 16384)\n\n \n#define VMBUS_PIPE_TYPE_BYTE\t\t0x00000000\n#define VMBUS_PIPE_TYPE_MESSAGE\t\t0x00000004\n\n \n#define MAX_USER_DEFINED_BYTES\t\t120\n\n \n#define MAX_PIPE_USER_DEFINED_BYTES\t116\n\n \nstruct vmbus_channel_offer {\n\tguid_t if_type;\n\tguid_t if_instance;\n\n\t \n\tu64 reserved1;\n\tu64 reserved2;\n\n\tu16 chn_flags;\n\tu16 mmio_megabytes;\t\t \n\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\tunsigned char user_def[MAX_USER_DEFINED_BYTES];\n\t\t} std;\n\n\t\t \n\t\tstruct {\n\t\t\tu32  pipe_mode;\n\t\t\tunsigned char user_def[MAX_PIPE_USER_DEFINED_BYTES];\n\t\t} pipe;\n\t} u;\n\t \n\tu16 sub_channel_index;\n\tu16 reserved3;\n} __packed;\n\n \n#define VMBUS_CHANNEL_ENUMERATE_DEVICE_INTERFACE\t1\n#define VMBUS_CHANNEL_SERVER_SUPPORTS_TRANSFER_PAGES\t2\n#define VMBUS_CHANNEL_SERVER_SUPPORTS_GPADLS\t\t4\n#define VMBUS_CHANNEL_NAMED_PIPE_MODE\t\t\t0x10\n#define VMBUS_CHANNEL_LOOPBACK_OFFER\t\t\t0x100\n#define VMBUS_CHANNEL_PARENT_OFFER\t\t\t0x200\n#define VMBUS_CHANNEL_REQUEST_MONITORED_NOTIFICATION\t0x400\n#define VMBUS_CHANNEL_TLNPI_PROVIDER_OFFER\t\t0x2000\n\nstruct vmpacket_descriptor {\n\tu16 type;\n\tu16 offset8;\n\tu16 len8;\n\tu16 flags;\n\tu64 trans_id;\n} __packed;\n\nstruct vmpacket_header {\n\tu32 prev_pkt_start_offset;\n\tstruct vmpacket_descriptor descriptor;\n} __packed;\n\nstruct vmtransfer_page_range {\n\tu32 byte_count;\n\tu32 byte_offset;\n} __packed;\n\nstruct vmtransfer_page_packet_header {\n\tstruct vmpacket_descriptor d;\n\tu16 xfer_pageset_id;\n\tu8  sender_owns_set;\n\tu8 reserved;\n\tu32 range_cnt;\n\tstruct vmtransfer_page_range ranges[];\n} __packed;\n\nstruct vmgpadl_packet_header {\n\tstruct vmpacket_descriptor d;\n\tu32 gpadl;\n\tu32 reserved;\n} __packed;\n\nstruct vmadd_remove_transfer_page_set {\n\tstruct vmpacket_descriptor d;\n\tu32 gpadl;\n\tu16 xfer_pageset_id;\n\tu16 reserved;\n} __packed;\n\n \nstruct gpa_range {\n\tu32 byte_count;\n\tu32 byte_offset;\n\tu64 pfn_array[];\n};\n\n \nstruct vmestablish_gpadl {\n\tstruct vmpacket_descriptor d;\n\tu32 gpadl;\n\tu32 range_cnt;\n\tstruct gpa_range range[1];\n} __packed;\n\n \nstruct vmteardown_gpadl {\n\tstruct vmpacket_descriptor d;\n\tu32 gpadl;\n\tu32 reserved;\t \n} __packed;\n\n \nstruct vmdata_gpa_direct {\n\tstruct vmpacket_descriptor d;\n\tu32 reserved;\n\tu32 range_cnt;\n\tstruct gpa_range range[1];\n} __packed;\n\n \nstruct vmadditional_data {\n\tstruct vmpacket_descriptor d;\n\tu64 total_bytes;\n\tu32 offset;\n\tu32 byte_cnt;\n\tunsigned char data[1];\n} __packed;\n\nunion vmpacket_largest_possible_header {\n\tstruct vmpacket_descriptor simple_hdr;\n\tstruct vmtransfer_page_packet_header xfer_page_hdr;\n\tstruct vmgpadl_packet_header gpadl_hdr;\n\tstruct vmadd_remove_transfer_page_set add_rm_xfer_page_hdr;\n\tstruct vmestablish_gpadl establish_gpadl_hdr;\n\tstruct vmteardown_gpadl teardown_gpadl_hdr;\n\tstruct vmdata_gpa_direct data_gpa_direct_hdr;\n};\n\n#define VMPACKET_DATA_START_ADDRESS(__packet)\t\\\n\t(void *)(((unsigned char *)__packet) +\t\\\n\t ((struct vmpacket_descriptor)__packet)->offset8 * 8)\n\n#define VMPACKET_DATA_LENGTH(__packet)\t\t\\\n\t((((struct vmpacket_descriptor)__packet)->len8 -\t\\\n\t  ((struct vmpacket_descriptor)__packet)->offset8) * 8)\n\n#define VMPACKET_TRANSFER_MODE(__packet)\t\\\n\t(((struct IMPACT)__packet)->type)\n\nenum vmbus_packet_type {\n\tVM_PKT_INVALID\t\t\t\t= 0x0,\n\tVM_PKT_SYNCH\t\t\t\t= 0x1,\n\tVM_PKT_ADD_XFER_PAGESET\t\t\t= 0x2,\n\tVM_PKT_RM_XFER_PAGESET\t\t\t= 0x3,\n\tVM_PKT_ESTABLISH_GPADL\t\t\t= 0x4,\n\tVM_PKT_TEARDOWN_GPADL\t\t\t= 0x5,\n\tVM_PKT_DATA_INBAND\t\t\t= 0x6,\n\tVM_PKT_DATA_USING_XFER_PAGES\t\t= 0x7,\n\tVM_PKT_DATA_USING_GPADL\t\t\t= 0x8,\n\tVM_PKT_DATA_USING_GPA_DIRECT\t\t= 0x9,\n\tVM_PKT_CANCEL_REQUEST\t\t\t= 0xa,\n\tVM_PKT_COMP\t\t\t\t= 0xb,\n\tVM_PKT_DATA_USING_ADDITIONAL_PKT\t= 0xc,\n\tVM_PKT_ADDITIONAL_DATA\t\t\t= 0xd\n};\n\n#define VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED\t1\n\n\n \nenum vmbus_channel_message_type {\n\tCHANNELMSG_INVALID\t\t\t=  0,\n\tCHANNELMSG_OFFERCHANNEL\t\t=  1,\n\tCHANNELMSG_RESCIND_CHANNELOFFER\t=  2,\n\tCHANNELMSG_REQUESTOFFERS\t\t=  3,\n\tCHANNELMSG_ALLOFFERS_DELIVERED\t=  4,\n\tCHANNELMSG_OPENCHANNEL\t\t=  5,\n\tCHANNELMSG_OPENCHANNEL_RESULT\t\t=  6,\n\tCHANNELMSG_CLOSECHANNEL\t\t=  7,\n\tCHANNELMSG_GPADL_HEADER\t\t=  8,\n\tCHANNELMSG_GPADL_BODY\t\t\t=  9,\n\tCHANNELMSG_GPADL_CREATED\t\t= 10,\n\tCHANNELMSG_GPADL_TEARDOWN\t\t= 11,\n\tCHANNELMSG_GPADL_TORNDOWN\t\t= 12,\n\tCHANNELMSG_RELID_RELEASED\t\t= 13,\n\tCHANNELMSG_INITIATE_CONTACT\t\t= 14,\n\tCHANNELMSG_VERSION_RESPONSE\t\t= 15,\n\tCHANNELMSG_UNLOAD\t\t\t= 16,\n\tCHANNELMSG_UNLOAD_RESPONSE\t\t= 17,\n\tCHANNELMSG_18\t\t\t\t= 18,\n\tCHANNELMSG_19\t\t\t\t= 19,\n\tCHANNELMSG_20\t\t\t\t= 20,\n\tCHANNELMSG_TL_CONNECT_REQUEST\t\t= 21,\n\tCHANNELMSG_MODIFYCHANNEL\t\t= 22,\n\tCHANNELMSG_TL_CONNECT_RESULT\t\t= 23,\n\tCHANNELMSG_MODIFYCHANNEL_RESPONSE\t= 24,\n\tCHANNELMSG_COUNT\n};\n\n \n#define INVALID_RELID\tU32_MAX\n\nstruct vmbus_channel_message_header {\n\tenum vmbus_channel_message_type msgtype;\n\tu32 padding;\n} __packed;\n\n \nstruct vmbus_channel_query_vmbus_version {\n\tstruct vmbus_channel_message_header header;\n\tu32 version;\n} __packed;\n\n \nstruct vmbus_channel_version_supported {\n\tstruct vmbus_channel_message_header header;\n\tu8 version_supported;\n} __packed;\n\n \nstruct vmbus_channel_offer_channel {\n\tstruct vmbus_channel_message_header header;\n\tstruct vmbus_channel_offer offer;\n\tu32 child_relid;\n\tu8 monitorid;\n\t \n\tu8 monitor_allocated:1;\n\tu8 reserved:7;\n\t \n\tu16 is_dedicated_interrupt:1;\n\tu16 reserved1:15;\n\tu32 connection_id;\n} __packed;\n\n \nstruct vmbus_channel_rescind_offer {\n\tstruct vmbus_channel_message_header header;\n\tu32 child_relid;\n} __packed;\n\n \n\n \nstruct vmbus_channel_open_channel {\n\tstruct vmbus_channel_message_header header;\n\n\t \n\tu32 child_relid;\n\n\t \n\tu32 openid;\n\n\t \n\tu32 ringbuffer_gpadlhandle;\n\n\t \n\tu32 target_vp;\n\n\t \n\tu32 downstream_ringbuffer_pageoffset;\n\n\t \n\tunsigned char userdata[MAX_USER_DEFINED_BYTES];\n} __packed;\n\n \nstruct vmbus_channel_open_result {\n\tstruct vmbus_channel_message_header header;\n\tu32 child_relid;\n\tu32 openid;\n\tu32 status;\n} __packed;\n\n \nstruct vmbus_channel_modifychannel_response {\n\tstruct vmbus_channel_message_header header;\n\tu32 child_relid;\n\tu32 status;\n} __packed;\n\n \nstruct vmbus_channel_close_channel {\n\tstruct vmbus_channel_message_header header;\n\tu32 child_relid;\n} __packed;\n\n \n#define GPADL_TYPE_RING_BUFFER\t\t1\n#define GPADL_TYPE_SERVER_SAVE_AREA\t2\n#define GPADL_TYPE_TRANSACTION\t\t8\n\n \nstruct vmbus_channel_gpadl_header {\n\tstruct vmbus_channel_message_header header;\n\tu32 child_relid;\n\tu32 gpadl;\n\tu16 range_buflen;\n\tu16 rangecount;\n\tstruct gpa_range range[];\n} __packed;\n\n \nstruct vmbus_channel_gpadl_body {\n\tstruct vmbus_channel_message_header header;\n\tu32 msgnumber;\n\tu32 gpadl;\n\tu64 pfn[];\n} __packed;\n\nstruct vmbus_channel_gpadl_created {\n\tstruct vmbus_channel_message_header header;\n\tu32 child_relid;\n\tu32 gpadl;\n\tu32 creation_status;\n} __packed;\n\nstruct vmbus_channel_gpadl_teardown {\n\tstruct vmbus_channel_message_header header;\n\tu32 child_relid;\n\tu32 gpadl;\n} __packed;\n\nstruct vmbus_channel_gpadl_torndown {\n\tstruct vmbus_channel_message_header header;\n\tu32 gpadl;\n} __packed;\n\nstruct vmbus_channel_relid_released {\n\tstruct vmbus_channel_message_header header;\n\tu32 child_relid;\n} __packed;\n\nstruct vmbus_channel_initiate_contact {\n\tstruct vmbus_channel_message_header header;\n\tu32 vmbus_version_requested;\n\tu32 target_vcpu;  \n\tunion {\n\t\tu64 interrupt_page;\n\t\tstruct {\n\t\t\tu8\tmsg_sint;\n\t\t\tu8\tmsg_vtl;\n\t\t\tu8\treserved[6];\n\t\t};\n\t};\n\tu64 monitor_page1;\n\tu64 monitor_page2;\n} __packed;\n\n \nstruct vmbus_channel_tl_connect_request {\n\tstruct vmbus_channel_message_header header;\n\tguid_t guest_endpoint_id;\n\tguid_t host_service_id;\n} __packed;\n\n \nstruct vmbus_channel_modifychannel {\n\tstruct vmbus_channel_message_header header;\n\tu32 child_relid;\n\tu32 target_vp;\n} __packed;\n\nstruct vmbus_channel_version_response {\n\tstruct vmbus_channel_message_header header;\n\tu8 version_supported;\n\n\tu8 connection_state;\n\tu16 padding;\n\n\t \n\tu32 msg_conn_id;\n} __packed;\n\nenum vmbus_channel_state {\n\tCHANNEL_OFFER_STATE,\n\tCHANNEL_OPENING_STATE,\n\tCHANNEL_OPEN_STATE,\n\tCHANNEL_OPENED_STATE,\n};\n\n \nstruct vmbus_channel_msginfo {\n\t \n\tstruct list_head msglistentry;\n\n\t \n\tstruct list_head submsglist;\n\n\t \n\tstruct completion  waitevent;\n\tstruct vmbus_channel *waiting_channel;\n\tunion {\n\t\tstruct vmbus_channel_version_supported version_supported;\n\t\tstruct vmbus_channel_open_result open_result;\n\t\tstruct vmbus_channel_gpadl_torndown gpadl_torndown;\n\t\tstruct vmbus_channel_gpadl_created gpadl_created;\n\t\tstruct vmbus_channel_version_response version_response;\n\t\tstruct vmbus_channel_modifychannel_response modify_response;\n\t} response;\n\n\tu32 msgsize;\n\t \n\tunsigned char msg[];\n};\n\nstruct vmbus_close_msg {\n\tstruct vmbus_channel_msginfo info;\n\tstruct vmbus_channel_close_channel msg;\n};\n\n \nunion hv_connection_id {\n\tu32 asu32;\n\tstruct {\n\t\tu32 id:24;\n\t\tu32 reserved:8;\n\t} u;\n};\n\nenum vmbus_device_type {\n\tHV_IDE = 0,\n\tHV_SCSI,\n\tHV_FC,\n\tHV_NIC,\n\tHV_ND,\n\tHV_PCIE,\n\tHV_FB,\n\tHV_KBD,\n\tHV_MOUSE,\n\tHV_KVP,\n\tHV_TS,\n\tHV_HB,\n\tHV_SHUTDOWN,\n\tHV_FCOPY,\n\tHV_BACKUP,\n\tHV_DM,\n\tHV_UNKNOWN,\n};\n\n \nstruct vmbus_requestor {\n\tu64 *req_arr;\n\tunsigned long *req_bitmap;  \n\tu32 size;\n\tu64 next_request_id;\n\tspinlock_t req_lock;  \n};\n\n#define VMBUS_NO_RQSTOR U64_MAX\n#define VMBUS_RQST_ERROR (U64_MAX - 1)\n#define VMBUS_RQST_ADDR_ANY U64_MAX\n \n#define VMBUS_RQST_ID_NO_RESPONSE (U64_MAX - 2)\n \n#define VMBUS_RQST_INIT (U64_MAX - 2)\n#define VMBUS_RQST_RESET (U64_MAX - 3)\n\nstruct vmbus_device {\n\tu16  dev_type;\n\tguid_t guid;\n\tbool perf_device;\n\tbool allowed_in_isolated;\n};\n\n#define VMBUS_DEFAULT_MAX_PKT_SIZE 4096\n\nstruct vmbus_gpadl {\n\tu32 gpadl_handle;\n\tu32 size;\n\tvoid *buffer;\n};\n\nstruct vmbus_channel {\n\tstruct list_head listentry;\n\n\tstruct hv_device *device_obj;\n\n\tenum vmbus_channel_state state;\n\n\tstruct vmbus_channel_offer_channel offermsg;\n\t \n\tu8 monitor_grp;\n\tu8 monitor_bit;\n\n\tbool rescind;  \n\tbool rescind_ref;  \n\tstruct completion rescind_event;\n\n\tstruct vmbus_gpadl ringbuffer_gpadlhandle;\n\n\t \n\tstruct page *ringbuffer_page;\n\tu32 ringbuffer_pagecount;\n\tu32 ringbuffer_send_offset;\n\tstruct hv_ring_buffer_info outbound;\t \n\tstruct hv_ring_buffer_info inbound;\t \n\n\tstruct vmbus_close_msg close_msg;\n\n\t \n\tu64\tinterrupts;\t \n\tu64\tsig_events;\t \n\n\t \n\tu64 intr_out_empty;\n\n\t \n\tbool out_full_flag;\n\n\t \n\tstruct tasklet_struct callback_event;\n\tvoid (*onchannel_callback)(void *context);\n\tvoid *channel_callback_context;\n\n\tvoid (*change_target_cpu_callback)(struct vmbus_channel *channel,\n\t\t\tu32 old, u32 new);\n\n\t \n\tspinlock_t sched_lock;\n\n\t \n\tenum hv_callback_mode {\n\t\tHV_CALL_BATCHED,\n\t\tHV_CALL_DIRECT,\n\t\tHV_CALL_ISR\n\t} callback_mode;\n\n\tbool is_dedicated_interrupt;\n\tu64 sig_event;\n\n\t \n\tu32 target_cpu;\n\t \n\n\t \n\tvoid (*sc_creation_callback)(struct vmbus_channel *new_sc);\n\n\t \n\tvoid (*chn_rescind_callback)(struct vmbus_channel *channel);\n\n\t \n\tstruct list_head sc_list;\n\t \n\tstruct vmbus_channel *primary_channel;\n\t \n\tvoid *per_channel_state;\n\n\t \n\tstruct rcu_head rcu;\n\n\t \n\tstruct kobject\t\t\tkobj;\n\n\t \n\tbool low_latency;\n\n\tbool probe_done;\n\n\t \n\tu16 device_id;\n\n\t \n\tstruct work_struct add_channel_work;\n\n\t \n\tu64 intr_in_full;\n\n\t \n\tu64 out_full_total;\n\n\t \n\tu64 out_full_first;\n\n\t \n\tbool fuzz_testing_state;\n\n\t \n\tu32 fuzz_testing_interrupt_delay;\n\tu32 fuzz_testing_message_delay;\n\n\t \n\tu64 (*next_request_id_callback)(struct vmbus_channel *channel, u64 rqst_addr);\n\t \n\tu64 (*request_addr_callback)(struct vmbus_channel *channel, u64 rqst_id);\n\n\t \n\tstruct vmbus_requestor requestor;\n\tu32 rqstor_size;\n\n\t \n\tu32 max_pkt_size;\n};\n\n#define lock_requestor(channel, flags)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstruct vmbus_requestor *rqstor = &(channel)->requestor;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tspin_lock_irqsave(&rqstor->req_lock, flags);\t\t\t\\\n} while (0)\n\nstatic __always_inline void unlock_requestor(struct vmbus_channel *channel,\n\t\t\t\t\t     unsigned long flags)\n{\n\tstruct vmbus_requestor *rqstor = &channel->requestor;\n\n\tspin_unlock_irqrestore(&rqstor->req_lock, flags);\n}\n\nu64 vmbus_next_request_id(struct vmbus_channel *channel, u64 rqst_addr);\nu64 __vmbus_request_addr_match(struct vmbus_channel *channel, u64 trans_id,\n\t\t\t       u64 rqst_addr);\nu64 vmbus_request_addr_match(struct vmbus_channel *channel, u64 trans_id,\n\t\t\t     u64 rqst_addr);\nu64 vmbus_request_addr(struct vmbus_channel *channel, u64 trans_id);\n\nstatic inline bool is_hvsock_offer(const struct vmbus_channel_offer_channel *o)\n{\n\treturn !!(o->offer.chn_flags & VMBUS_CHANNEL_TLNPI_PROVIDER_OFFER);\n}\n\nstatic inline bool is_hvsock_channel(const struct vmbus_channel *c)\n{\n\treturn is_hvsock_offer(&c->offermsg);\n}\n\nstatic inline bool is_sub_channel(const struct vmbus_channel *c)\n{\n\treturn c->offermsg.offer.sub_channel_index != 0;\n}\n\nstatic inline void set_channel_read_mode(struct vmbus_channel *c,\n\t\t\t\t\tenum hv_callback_mode mode)\n{\n\tc->callback_mode = mode;\n}\n\nstatic inline void set_per_channel_state(struct vmbus_channel *c, void *s)\n{\n\tc->per_channel_state = s;\n}\n\nstatic inline void *get_per_channel_state(struct vmbus_channel *c)\n{\n\treturn c->per_channel_state;\n}\n\nstatic inline void set_channel_pending_send_size(struct vmbus_channel *c,\n\t\t\t\t\t\t u32 size)\n{\n\tunsigned long flags;\n\n\tif (size) {\n\t\tspin_lock_irqsave(&c->outbound.ring_lock, flags);\n\t\t++c->out_full_total;\n\n\t\tif (!c->out_full_flag) {\n\t\t\t++c->out_full_first;\n\t\t\tc->out_full_flag = true;\n\t\t}\n\t\tspin_unlock_irqrestore(&c->outbound.ring_lock, flags);\n\t} else {\n\t\tc->out_full_flag = false;\n\t}\n\n\tc->outbound.ring_buffer->pending_send_sz = size;\n}\n\nvoid vmbus_onmessage(struct vmbus_channel_message_header *hdr);\n\nint vmbus_request_offers(void);\n\n \n\nvoid vmbus_set_sc_create_callback(struct vmbus_channel *primary_channel,\n\t\t\tvoid (*sc_cr_cb)(struct vmbus_channel *new_sc));\n\nvoid vmbus_set_chn_rescind_callback(struct vmbus_channel *channel,\n\t\tvoid (*chn_rescind_cb)(struct vmbus_channel *));\n\n \nstruct vmbus_channel_packet_page_buffer {\n\tu16 type;\n\tu16 dataoffset8;\n\tu16 length8;\n\tu16 flags;\n\tu64 transactionid;\n\tu32 reserved;\n\tu32 rangecount;\n\tstruct hv_page_buffer range[MAX_PAGE_BUFFER_COUNT];\n} __packed;\n\n \nstruct vmbus_channel_packet_multipage_buffer {\n\tu16 type;\n\tu16 dataoffset8;\n\tu16 length8;\n\tu16 flags;\n\tu64 transactionid;\n\tu32 reserved;\n\tu32 rangecount;\t\t \n\tstruct hv_multipage_buffer range;\n} __packed;\n\n \nstruct vmbus_packet_mpb_array {\n\tu16 type;\n\tu16 dataoffset8;\n\tu16 length8;\n\tu16 flags;\n\tu64 transactionid;\n\tu32 reserved;\n\tu32 rangecount;          \n\tstruct hv_mpb_array range;\n} __packed;\n\nint vmbus_alloc_ring(struct vmbus_channel *channel,\n\t\t     u32 send_size, u32 recv_size);\nvoid vmbus_free_ring(struct vmbus_channel *channel);\n\nint vmbus_connect_ring(struct vmbus_channel *channel,\n\t\t       void (*onchannel_callback)(void *context),\n\t\t       void *context);\nint vmbus_disconnect_ring(struct vmbus_channel *channel);\n\nextern int vmbus_open(struct vmbus_channel *channel,\n\t\t\t    u32 send_ringbuffersize,\n\t\t\t    u32 recv_ringbuffersize,\n\t\t\t    void *userdata,\n\t\t\t    u32 userdatalen,\n\t\t\t    void (*onchannel_callback)(void *context),\n\t\t\t    void *context);\n\nextern void vmbus_close(struct vmbus_channel *channel);\n\nextern int vmbus_sendpacket_getid(struct vmbus_channel *channel,\n\t\t\t\t  void *buffer,\n\t\t\t\t  u32 bufferLen,\n\t\t\t\t  u64 requestid,\n\t\t\t\t  u64 *trans_id,\n\t\t\t\t  enum vmbus_packet_type type,\n\t\t\t\t  u32 flags);\nextern int vmbus_sendpacket(struct vmbus_channel *channel,\n\t\t\t\t  void *buffer,\n\t\t\t\t  u32 bufferLen,\n\t\t\t\t  u64 requestid,\n\t\t\t\t  enum vmbus_packet_type type,\n\t\t\t\t  u32 flags);\n\nextern int vmbus_sendpacket_pagebuffer(struct vmbus_channel *channel,\n\t\t\t\t\t    struct hv_page_buffer pagebuffers[],\n\t\t\t\t\t    u32 pagecount,\n\t\t\t\t\t    void *buffer,\n\t\t\t\t\t    u32 bufferlen,\n\t\t\t\t\t    u64 requestid);\n\nextern int vmbus_sendpacket_mpb_desc(struct vmbus_channel *channel,\n\t\t\t\t     struct vmbus_packet_mpb_array *mpb,\n\t\t\t\t     u32 desc_size,\n\t\t\t\t     void *buffer,\n\t\t\t\t     u32 bufferlen,\n\t\t\t\t     u64 requestid);\n\nextern int vmbus_establish_gpadl(struct vmbus_channel *channel,\n\t\t\t\t      void *kbuffer,\n\t\t\t\t      u32 size,\n\t\t\t\t      struct vmbus_gpadl *gpadl);\n\nextern int vmbus_teardown_gpadl(struct vmbus_channel *channel,\n\t\t\t\t     struct vmbus_gpadl *gpadl);\n\nvoid vmbus_reset_channel_cb(struct vmbus_channel *channel);\n\nextern int vmbus_recvpacket(struct vmbus_channel *channel,\n\t\t\t\t  void *buffer,\n\t\t\t\t  u32 bufferlen,\n\t\t\t\t  u32 *buffer_actual_len,\n\t\t\t\t  u64 *requestid);\n\nextern int vmbus_recvpacket_raw(struct vmbus_channel *channel,\n\t\t\t\t     void *buffer,\n\t\t\t\t     u32 bufferlen,\n\t\t\t\t     u32 *buffer_actual_len,\n\t\t\t\t     u64 *requestid);\n\n \nstruct hv_driver {\n\tconst char *name;\n\n\t \n\tbool hvsock;\n\n\t \n\tguid_t dev_type;\n\tconst struct hv_vmbus_device_id *id_table;\n\n\tstruct device_driver driver;\n\n\t \n\tstruct  {\n\t\tspinlock_t lock;\n\t\tstruct list_head list;\n\t} dynids;\n\n\tint (*probe)(struct hv_device *, const struct hv_vmbus_device_id *);\n\tvoid (*remove)(struct hv_device *dev);\n\tvoid (*shutdown)(struct hv_device *);\n\n\tint (*suspend)(struct hv_device *);\n\tint (*resume)(struct hv_device *);\n\n};\n\n \nstruct hv_device {\n\t \n\tguid_t dev_type;\n\n\t \n\tguid_t dev_instance;\n\tu16 vendor_id;\n\tu16 device_id;\n\n\tstruct device device;\n\t \n\tconst char *driver_override;\n\n\tstruct vmbus_channel *channel;\n\tstruct kset\t     *channels_kset;\n\tstruct device_dma_parameters dma_parms;\n\tu64 dma_mask;\n\n\t \n\tstruct dentry *debug_dir;\n\n};\n\n\n#define device_to_hv_device(d)\tcontainer_of_const(d, struct hv_device, device)\n\nstatic inline struct hv_driver *drv_to_hv_drv(struct device_driver *d)\n{\n\treturn container_of(d, struct hv_driver, driver);\n}\n\nstatic inline void hv_set_drvdata(struct hv_device *dev, void *data)\n{\n\tdev_set_drvdata(&dev->device, data);\n}\n\nstatic inline void *hv_get_drvdata(struct hv_device *dev)\n{\n\treturn dev_get_drvdata(&dev->device);\n}\n\nstruct hv_ring_buffer_debug_info {\n\tu32 current_interrupt_mask;\n\tu32 current_read_index;\n\tu32 current_write_index;\n\tu32 bytes_avail_toread;\n\tu32 bytes_avail_towrite;\n};\n\n\nint hv_ringbuffer_get_debuginfo(struct hv_ring_buffer_info *ring_info,\n\t\t\t\tstruct hv_ring_buffer_debug_info *debug_info);\n\nbool hv_ringbuffer_spinlock_busy(struct vmbus_channel *channel);\n\n \n#define vmbus_driver_register(driver)\t\\\n\t__vmbus_driver_register(driver, THIS_MODULE, KBUILD_MODNAME)\nint __must_check __vmbus_driver_register(struct hv_driver *hv_driver,\n\t\t\t\t\t struct module *owner,\n\t\t\t\t\t const char *mod_name);\nvoid vmbus_driver_unregister(struct hv_driver *hv_driver);\n\nvoid vmbus_hvsock_device_unregister(struct vmbus_channel *channel);\n\nint vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,\n\t\t\tresource_size_t min, resource_size_t max,\n\t\t\tresource_size_t size, resource_size_t align,\n\t\t\tbool fb_overlap_ok);\nvoid vmbus_free_mmio(resource_size_t start, resource_size_t size);\n\n \n\n \n#define HV_NIC_GUID \\\n\t.guid = GUID_INIT(0xf8615163, 0xdf3e, 0x46c5, 0x91, 0x3f, \\\n\t\t\t  0xf2, 0xd2, 0xf9, 0x65, 0xed, 0x0e)\n\n \n#define HV_IDE_GUID \\\n\t.guid = GUID_INIT(0x32412632, 0x86cb, 0x44a2, 0x9b, 0x5c, \\\n\t\t\t  0x50, 0xd1, 0x41, 0x73, 0x54, 0xf5)\n\n \n#define HV_SCSI_GUID \\\n\t.guid = GUID_INIT(0xba6163d9, 0x04a1, 0x4d29, 0xb6, 0x05, \\\n\t\t\t  0x72, 0xe2, 0xff, 0xb1, 0xdc, 0x7f)\n\n \n#define HV_SHUTDOWN_GUID \\\n\t.guid = GUID_INIT(0x0e0b6031, 0x5213, 0x4934, 0x81, 0x8b, \\\n\t\t\t  0x38, 0xd9, 0x0c, 0xed, 0x39, 0xdb)\n\n \n#define HV_TS_GUID \\\n\t.guid = GUID_INIT(0x9527e630, 0xd0ae, 0x497b, 0xad, 0xce, \\\n\t\t\t  0xe8, 0x0a, 0xb0, 0x17, 0x5c, 0xaf)\n\n \n#define HV_HEART_BEAT_GUID \\\n\t.guid = GUID_INIT(0x57164f39, 0x9115, 0x4e78, 0xab, 0x55, \\\n\t\t\t  0x38, 0x2f, 0x3b, 0xd5, 0x42, 0x2d)\n\n \n#define HV_KVP_GUID \\\n\t.guid = GUID_INIT(0xa9a0f4e7, 0x5a45, 0x4d96, 0xb8, 0x27, \\\n\t\t\t  0x8a, 0x84, 0x1e, 0x8c, 0x03, 0xe6)\n\n \n#define HV_DM_GUID \\\n\t.guid = GUID_INIT(0x525074dc, 0x8985, 0x46e2, 0x80, 0x57, \\\n\t\t\t  0xa3, 0x07, 0xdc, 0x18, 0xa5, 0x02)\n\n \n#define HV_MOUSE_GUID \\\n\t.guid = GUID_INIT(0xcfa8b69e, 0x5b4a, 0x4cc0, 0xb9, 0x8b, \\\n\t\t\t  0x8b, 0xa1, 0xa1, 0xf3, 0xf9, 0x5a)\n\n \n#define HV_KBD_GUID \\\n\t.guid = GUID_INIT(0xf912ad6d, 0x2b17, 0x48ea, 0xbd, 0x65, \\\n\t\t\t  0xf9, 0x27, 0xa6, 0x1c, 0x76, 0x84)\n\n \n#define HV_VSS_GUID \\\n\t.guid = GUID_INIT(0x35fa2e29, 0xea23, 0x4236, 0x96, 0xae, \\\n\t\t\t  0x3a, 0x6e, 0xba, 0xcb, 0xa4, 0x40)\n \n#define HV_SYNTHVID_GUID \\\n\t.guid = GUID_INIT(0xda0a7802, 0xe377, 0x4aac, 0x8e, 0x77, \\\n\t\t\t  0x05, 0x58, 0xeb, 0x10, 0x73, 0xf8)\n\n \n#define HV_SYNTHFC_GUID \\\n\t.guid = GUID_INIT(0x2f9bcc4a, 0x0069, 0x4af3, 0xb7, 0x6b, \\\n\t\t\t  0x6f, 0xd0, 0xbe, 0x52, 0x8c, 0xda)\n\n \n\n#define HV_FCOPY_GUID \\\n\t.guid = GUID_INIT(0x34d14be3, 0xdee4, 0x41c8, 0x9a, 0xe7, \\\n\t\t\t  0x6b, 0x17, 0x49, 0x77, 0xc1, 0x92)\n\n \n#define HV_ND_GUID \\\n\t.guid = GUID_INIT(0x8c2eaf3d, 0x32a7, 0x4b09, 0xab, 0x99, \\\n\t\t\t  0xbd, 0x1f, 0x1c, 0x86, 0xb5, 0x01)\n\n \n\n#define HV_PCIE_GUID \\\n\t.guid = GUID_INIT(0x44c4f61d, 0x4444, 0x4400, 0x9d, 0x52, \\\n\t\t\t  0x80, 0x2e, 0x27, 0xed, 0xe1, 0x9f)\n\n \n\n#define HV_AVMA1_GUID \\\n\t.guid = GUID_INIT(0xf8e65716, 0x3cb3, 0x4a06, 0x9a, 0x60, \\\n\t\t\t  0x18, 0x89, 0xc5, 0xcc, 0xca, 0xb5)\n\n#define HV_AVMA2_GUID \\\n\t.guid = GUID_INIT(0x3375baf4, 0x9e15, 0x4b30, 0xb7, 0x65, \\\n\t\t\t  0x67, 0xac, 0xb1, 0x0d, 0x60, 0x7b)\n\n#define HV_RDV_GUID \\\n\t.guid = GUID_INIT(0x276aacf4, 0xac15, 0x426c, 0x98, 0xdd, \\\n\t\t\t  0x75, 0x21, 0xad, 0x3f, 0x01, 0xfe)\n\n#define HV_IMC_GUID \\\n\t.guid = GUID_INIT(0xc376c1c3, 0xd276, 0x48d2, 0x90, 0xa9, \\\n\t\t\t  0xc0, 0x47, 0x48, 0x07, 0x2c, 0x60)\n\n \n\n#define ICMSGTYPE_NEGOTIATE\t\t0\n#define ICMSGTYPE_HEARTBEAT\t\t1\n#define ICMSGTYPE_KVPEXCHANGE\t\t2\n#define ICMSGTYPE_SHUTDOWN\t\t3\n#define ICMSGTYPE_TIMESYNC\t\t4\n#define ICMSGTYPE_VSS\t\t\t5\n#define ICMSGTYPE_FCOPY\t\t\t7\n\n#define ICMSGHDRFLAG_TRANSACTION\t1\n#define ICMSGHDRFLAG_REQUEST\t\t2\n#define ICMSGHDRFLAG_RESPONSE\t\t4\n\n\n \n\nstruct hv_util_service {\n\tu8 *recv_buffer;\n\tvoid *channel;\n\tvoid (*util_cb)(void *);\n\tint (*util_init)(struct hv_util_service *);\n\tvoid (*util_deinit)(void);\n\tint (*util_pre_suspend)(void);\n\tint (*util_pre_resume)(void);\n};\n\nstruct vmbuspipe_hdr {\n\tu32 flags;\n\tu32 msgsize;\n} __packed;\n\nstruct ic_version {\n\tu16 major;\n\tu16 minor;\n} __packed;\n\nstruct icmsg_hdr {\n\tstruct ic_version icverframe;\n\tu16 icmsgtype;\n\tstruct ic_version icvermsg;\n\tu16 icmsgsize;\n\tu32 status;\n\tu8 ictransaction_id;\n\tu8 icflags;\n\tu8 reserved[2];\n} __packed;\n\n#define IC_VERSION_NEGOTIATION_MAX_VER_COUNT 100\n#define ICMSG_HDR (sizeof(struct vmbuspipe_hdr) + sizeof(struct icmsg_hdr))\n#define ICMSG_NEGOTIATE_PKT_SIZE(icframe_vercnt, icmsg_vercnt) \\\n\t(ICMSG_HDR + sizeof(struct icmsg_negotiate) + \\\n\t (((icframe_vercnt) + (icmsg_vercnt)) * sizeof(struct ic_version)))\n\nstruct icmsg_negotiate {\n\tu16 icframe_vercnt;\n\tu16 icmsg_vercnt;\n\tu32 reserved;\n\tstruct ic_version icversion_data[];  \n} __packed;\n\nstruct shutdown_msg_data {\n\tu32 reason_code;\n\tu32 timeout_seconds;\n\tu32 flags;\n\tu8  display_message[2048];\n} __packed;\n\nstruct heartbeat_msg_data {\n\tu64 seq_num;\n\tu32 reserved[8];\n} __packed;\n\n \n#define ICTIMESYNCFLAG_PROBE\t0\n#define ICTIMESYNCFLAG_SYNC\t1\n#define ICTIMESYNCFLAG_SAMPLE\t2\n\n#ifdef __x86_64__\n#define WLTIMEDELTA\t116444736000000000L\t \n#else\n#define WLTIMEDELTA\t116444736000000000LL\n#endif\n\nstruct ictimesync_data {\n\tu64 parenttime;\n\tu64 childtime;\n\tu64 roundtriptime;\n\tu8 flags;\n} __packed;\n\nstruct ictimesync_ref_data {\n\tu64 parenttime;\n\tu64 vmreferencetime;\n\tu8 flags;\n\tchar leapflags;\n\tchar stratum;\n\tu8 reserved[3];\n} __packed;\n\nstruct hyperv_service_callback {\n\tu8 msg_type;\n\tchar *log_msg;\n\tguid_t data;\n\tstruct vmbus_channel *channel;\n\tvoid (*callback)(void *context);\n};\n\nstruct hv_dma_range {\n\tdma_addr_t dma;\n\tu32 mapping_size;\n};\n\n#define MAX_SRV_VER\t0x7ffffff\nextern bool vmbus_prep_negotiate_resp(struct icmsg_hdr *icmsghdrp, u8 *buf, u32 buflen,\n\t\t\t\tconst int *fw_version, int fw_vercnt,\n\t\t\t\tconst int *srv_version, int srv_vercnt,\n\t\t\t\tint *nego_fw_version, int *nego_srv_version);\n\nvoid hv_process_channel_removal(struct vmbus_channel *channel);\n\nvoid vmbus_setevent(struct vmbus_channel *channel);\n \n\nextern __u32 vmbus_proto_version;\n\nint vmbus_send_tl_connect_request(const guid_t *shv_guest_servie_id,\n\t\t\t\t  const guid_t *shv_host_servie_id);\nint vmbus_send_modifychannel(struct vmbus_channel *channel, u32 target_vp);\nvoid vmbus_set_event(struct vmbus_channel *channel);\n\n \nstatic inline void *\nhv_get_ring_buffer(const struct hv_ring_buffer_info *ring_info)\n{\n\treturn ring_info->ring_buffer->buffer;\n}\n\n \nstatic inline void hv_begin_read(struct hv_ring_buffer_info *rbi)\n{\n\trbi->ring_buffer->interrupt_mask = 1;\n\n\t \n\tvirt_mb();\n}\n\n \nstatic inline u32 hv_end_read(struct hv_ring_buffer_info *rbi)\n{\n\n\trbi->ring_buffer->interrupt_mask = 0;\n\n\t \n\tvirt_mb();\n\n\t \n\treturn hv_get_bytes_to_read(rbi);\n}\n\n \n\n \nstatic inline void *hv_pkt_data(const struct vmpacket_descriptor *desc)\n{\n\treturn (void *)((unsigned long)desc + (desc->offset8 << 3));\n}\n\n \nstatic inline u32 hv_pkt_datalen(const struct vmpacket_descriptor *desc)\n{\n\treturn (desc->len8 << 3) - (desc->offset8 << 3);\n}\n\n \nstatic inline u32 hv_pkt_len(const struct vmpacket_descriptor *desc)\n{\n\treturn desc->len8 << 3;\n}\n\nstruct vmpacket_descriptor *\nhv_pkt_iter_first(struct vmbus_channel *channel);\n\nstruct vmpacket_descriptor *\n__hv_pkt_iter_next(struct vmbus_channel *channel,\n\t\t   const struct vmpacket_descriptor *pkt);\n\nvoid hv_pkt_iter_close(struct vmbus_channel *channel);\n\nstatic inline struct vmpacket_descriptor *\nhv_pkt_iter_next(struct vmbus_channel *channel,\n\t\t const struct vmpacket_descriptor *pkt)\n{\n\tstruct vmpacket_descriptor *nxt;\n\n\tnxt = __hv_pkt_iter_next(channel, pkt);\n\tif (!nxt)\n\t\thv_pkt_iter_close(channel);\n\n\treturn nxt;\n}\n\n#define foreach_vmbus_pkt(pkt, channel) \\\n\tfor (pkt = hv_pkt_iter_first(channel); pkt; \\\n\t    pkt = hv_pkt_iter_next(channel, pkt))\n\n \n#define HV_CONFIG_BLOCK_SIZE_MAX 128\n\nint hyperv_read_cfg_blk(struct pci_dev *dev, void *buf, unsigned int buf_len,\n\t\t\tunsigned int block_id, unsigned int *bytes_returned);\nint hyperv_write_cfg_blk(struct pci_dev *dev, void *buf, unsigned int len,\n\t\t\t unsigned int block_id);\nint hyperv_reg_block_invalidate(struct pci_dev *dev, void *context,\n\t\t\t\tvoid (*block_invalidate)(void *context,\n\t\t\t\t\t\t\t u64 block_mask));\n\nstruct hyperv_pci_block_ops {\n\tint (*read_block)(struct pci_dev *dev, void *buf, unsigned int buf_len,\n\t\t\t  unsigned int block_id, unsigned int *bytes_returned);\n\tint (*write_block)(struct pci_dev *dev, void *buf, unsigned int len,\n\t\t\t   unsigned int block_id);\n\tint (*reg_blk_invalidate)(struct pci_dev *dev, void *context,\n\t\t\t\t  void (*block_invalidate)(void *context,\n\t\t\t\t\t\t\t   u64 block_mask));\n};\n\nextern struct hyperv_pci_block_ops hvpci_block_ops;\n\nstatic inline unsigned long virt_to_hvpfn(void *addr)\n{\n\tphys_addr_t paddr;\n\n\tif (is_vmalloc_addr(addr))\n\t\tpaddr = page_to_phys(vmalloc_to_page(addr)) +\n\t\t\t\t     offset_in_page(addr);\n\telse\n\t\tpaddr = __pa(addr);\n\n\treturn  paddr >> HV_HYP_PAGE_SHIFT;\n}\n\n#define NR_HV_HYP_PAGES_IN_PAGE\t(PAGE_SIZE / HV_HYP_PAGE_SIZE)\n#define offset_in_hvpage(ptr)\t((unsigned long)(ptr) & ~HV_HYP_PAGE_MASK)\n#define HVPFN_UP(x)\t(((x) + HV_HYP_PAGE_SIZE-1) >> HV_HYP_PAGE_SHIFT)\n#define HVPFN_DOWN(x)\t((x) >> HV_HYP_PAGE_SHIFT)\n#define page_to_hvpfn(page)\t(page_to_pfn(page) * NR_HV_HYP_PAGES_IN_PAGE)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}