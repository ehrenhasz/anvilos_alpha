{
  "module_name": "rwlock_rt.h",
  "hash_id": "c4c8f9778b7dbb6640e4dd5e378599f6c404fb30e524e2d98f4035885d1514ef",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/rwlock_rt.h",
  "human_readable_source": "\n#ifndef __LINUX_RWLOCK_RT_H\n#define __LINUX_RWLOCK_RT_H\n\n#ifndef __LINUX_SPINLOCK_RT_H\n#error Do not #include directly. Use <linux/spinlock.h>.\n#endif\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nextern void __rt_rwlock_init(rwlock_t *rwlock, const char *name,\n\t\t\t     struct lock_class_key *key);\n#else\nstatic inline void __rt_rwlock_init(rwlock_t *rwlock, char *name,\n\t\t\t\t    struct lock_class_key *key)\n{\n}\n#endif\n\n#define rwlock_init(rwl)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\\\n\t\t\t\t\t\t\t\\\n\tinit_rwbase_rt(&(rwl)->rwbase);\t\t\t\\\n\t__rt_rwlock_init(rwl, #rwl, &__key);\t\t\\\n} while (0)\n\nextern void rt_read_lock(rwlock_t *rwlock);\nextern int rt_read_trylock(rwlock_t *rwlock);\nextern void rt_read_unlock(rwlock_t *rwlock);\nextern void rt_write_lock(rwlock_t *rwlock);\nextern void rt_write_lock_nested(rwlock_t *rwlock, int subclass);\nextern int rt_write_trylock(rwlock_t *rwlock);\nextern void rt_write_unlock(rwlock_t *rwlock);\n\nstatic __always_inline void read_lock(rwlock_t *rwlock)\n{\n\trt_read_lock(rwlock);\n}\n\nstatic __always_inline void read_lock_bh(rwlock_t *rwlock)\n{\n\tlocal_bh_disable();\n\trt_read_lock(rwlock);\n}\n\nstatic __always_inline void read_lock_irq(rwlock_t *rwlock)\n{\n\trt_read_lock(rwlock);\n}\n\n#define read_lock_irqsave(lock, flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\\\n\t\trt_read_lock(lock);\t\t\t\\\n\t\tflags = 0;\t\t\t\t\\\n\t} while (0)\n\n#define read_trylock(lock)\t__cond_lock(lock, rt_read_trylock(lock))\n\nstatic __always_inline void read_unlock(rwlock_t *rwlock)\n{\n\trt_read_unlock(rwlock);\n}\n\nstatic __always_inline void read_unlock_bh(rwlock_t *rwlock)\n{\n\trt_read_unlock(rwlock);\n\tlocal_bh_enable();\n}\n\nstatic __always_inline void read_unlock_irq(rwlock_t *rwlock)\n{\n\trt_read_unlock(rwlock);\n}\n\nstatic __always_inline void read_unlock_irqrestore(rwlock_t *rwlock,\n\t\t\t\t\t\t   unsigned long flags)\n{\n\trt_read_unlock(rwlock);\n}\n\nstatic __always_inline void write_lock(rwlock_t *rwlock)\n{\n\trt_write_lock(rwlock);\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic __always_inline void write_lock_nested(rwlock_t *rwlock, int subclass)\n{\n\trt_write_lock_nested(rwlock, subclass);\n}\n#else\n#define write_lock_nested(lock, subclass)\trt_write_lock(((void)(subclass), (lock)))\n#endif\n\nstatic __always_inline void write_lock_bh(rwlock_t *rwlock)\n{\n\tlocal_bh_disable();\n\trt_write_lock(rwlock);\n}\n\nstatic __always_inline void write_lock_irq(rwlock_t *rwlock)\n{\n\trt_write_lock(rwlock);\n}\n\n#define write_lock_irqsave(lock, flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\\\n\t\trt_write_lock(lock);\t\t\t\\\n\t\tflags = 0;\t\t\t\t\\\n\t} while (0)\n\n#define write_trylock(lock)\t__cond_lock(lock, rt_write_trylock(lock))\n\n#define write_trylock_irqsave(lock, flags)\t\t\\\n({\t\t\t\t\t\t\t\\\n\tint __locked;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\n\ttypecheck(unsigned long, flags);\t\t\\\n\tflags = 0;\t\t\t\t\t\\\n\t__locked = write_trylock(lock);\t\t\t\\\n\t__locked;\t\t\t\t\t\\\n})\n\nstatic __always_inline void write_unlock(rwlock_t *rwlock)\n{\n\trt_write_unlock(rwlock);\n}\n\nstatic __always_inline void write_unlock_bh(rwlock_t *rwlock)\n{\n\trt_write_unlock(rwlock);\n\tlocal_bh_enable();\n}\n\nstatic __always_inline void write_unlock_irq(rwlock_t *rwlock)\n{\n\trt_write_unlock(rwlock);\n}\n\nstatic __always_inline void write_unlock_irqrestore(rwlock_t *rwlock,\n\t\t\t\t\t\t    unsigned long flags)\n{\n\trt_write_unlock(rwlock);\n}\n\n#define rwlock_is_contended(lock)\t\t(((void)(lock), 0))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}