{
  "module_name": "swait.h",
  "hash_id": "b114f6df6831a04ad6357d693ed045a94269af3c33cf4c4fb5b6010d21d01a67",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/swait.h",
  "human_readable_source": " \n#ifndef _LINUX_SWAIT_H\n#define _LINUX_SWAIT_H\n\n#include <linux/list.h>\n#include <linux/stddef.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n#include <asm/current.h>\n\n \n\nstruct task_struct;\n\nstruct swait_queue_head {\n\traw_spinlock_t\t\tlock;\n\tstruct list_head\ttask_list;\n};\n\nstruct swait_queue {\n\tstruct task_struct\t*task;\n\tstruct list_head\ttask_list;\n};\n\n#define __SWAITQUEUE_INITIALIZER(name) {\t\t\t\t\\\n\t.task\t\t= current,\t\t\t\t\t\\\n\t.task_list\t= LIST_HEAD_INIT((name).task_list),\t\t\\\n}\n\n#define DECLARE_SWAITQUEUE(name)\t\t\t\t\t\\\n\tstruct swait_queue name = __SWAITQUEUE_INITIALIZER(name)\n\n#define __SWAIT_QUEUE_HEAD_INITIALIZER(name) {\t\t\t\t\\\n\t.lock\t\t= __RAW_SPIN_LOCK_UNLOCKED(name.lock),\t\t\\\n\t.task_list\t= LIST_HEAD_INIT((name).task_list),\t\t\\\n}\n\n#define DECLARE_SWAIT_QUEUE_HEAD(name)\t\t\t\t\t\\\n\tstruct swait_queue_head name = __SWAIT_QUEUE_HEAD_INITIALIZER(name)\n\nextern void __init_swait_queue_head(struct swait_queue_head *q, const char *name,\n\t\t\t\t    struct lock_class_key *key);\n\n#define init_swait_queue_head(q)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tstatic struct lock_class_key __key;\t\t\\\n\t\t__init_swait_queue_head((q), #q, &__key);\t\\\n\t} while (0)\n\n#ifdef CONFIG_LOCKDEP\n# define __SWAIT_QUEUE_HEAD_INIT_ONSTACK(name)\t\t\t\\\n\t({ init_swait_queue_head(&name); name; })\n# define DECLARE_SWAIT_QUEUE_HEAD_ONSTACK(name)\t\t\t\\\n\tstruct swait_queue_head name = __SWAIT_QUEUE_HEAD_INIT_ONSTACK(name)\n#else\n# define DECLARE_SWAIT_QUEUE_HEAD_ONSTACK(name)\t\t\t\\\n\tDECLARE_SWAIT_QUEUE_HEAD(name)\n#endif\n\n \nstatic inline int swait_active(struct swait_queue_head *wq)\n{\n\treturn !list_empty(&wq->task_list);\n}\n\n \nstatic inline bool swq_has_sleeper(struct swait_queue_head *wq)\n{\n\t \n\tsmp_mb();\n\treturn swait_active(wq);\n}\n\nextern void swake_up_one(struct swait_queue_head *q);\nextern void swake_up_all(struct swait_queue_head *q);\nextern void swake_up_locked(struct swait_queue_head *q, int wake_flags);\n\nextern void prepare_to_swait_exclusive(struct swait_queue_head *q, struct swait_queue *wait, int state);\nextern long prepare_to_swait_event(struct swait_queue_head *q, struct swait_queue *wait, int state);\n\nextern void __finish_swait(struct swait_queue_head *q, struct swait_queue *wait);\nextern void finish_swait(struct swait_queue_head *q, struct swait_queue *wait);\n\n \n#define ___swait_event(wq, condition, state, ret, cmd)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__label__ __out;\t\t\t\t\t\t\\\n\tstruct swait_queue __wait;\t\t\t\t\t\\\n\tlong __ret = ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tINIT_LIST_HEAD(&__wait.task_list);\t\t\t\t\\\n\tfor (;;) {\t\t\t\t\t\t\t\\\n\t\tlong __int = prepare_to_swait_event(&wq, &__wait, state);\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (condition)\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (___wait_is_interruptible(state) && __int) {\t\t\\\n\t\t\t__ret = __int;\t\t\t\t\t\\\n\t\t\tgoto __out;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tcmd;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tfinish_swait(&wq, &__wait);\t\t\t\t\t\\\n__out:\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define __swait_event(wq, condition)\t\t\t\t\t\\\n\t(void)___swait_event(wq, condition, TASK_UNINTERRUPTIBLE, 0,\t\\\n\t\t\t    schedule())\n\n#define swait_event_exclusive(wq, condition)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\t__swait_event(wq, condition);\t\t\t\t\t\\\n} while (0)\n\n#define __swait_event_timeout(wq, condition, timeout)\t\t\t\\\n\t___swait_event(wq, ___wait_cond_timeout(condition),\t\t\\\n\t\t      TASK_UNINTERRUPTIBLE, timeout,\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n#define swait_event_timeout_exclusive(wq, condition, timeout)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\\\n\t\t__ret = __swait_event_timeout(wq, condition, timeout);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define __swait_event_interruptible(wq, condition)\t\t\t\\\n\t___swait_event(wq, condition, TASK_INTERRUPTIBLE, 0,\t\t\\\n\t\t      schedule())\n\n#define swait_event_interruptible_exclusive(wq, condition)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\\\n\t\t__ret = __swait_event_interruptible(wq, condition);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define __swait_event_interruptible_timeout(wq, condition, timeout)\t\\\n\t___swait_event(wq, ___wait_cond_timeout(condition),\t\t\\\n\t\t      TASK_INTERRUPTIBLE, timeout,\t\t\t\\\n\t\t      __ret = schedule_timeout(__ret))\n\n#define swait_event_interruptible_timeout_exclusive(wq, condition, timeout)\\\n({\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\\\n\t\t__ret = __swait_event_interruptible_timeout(wq,\t\t\\\n\t\t\t\t\t\tcondition, timeout);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define __swait_event_idle(wq, condition)\t\t\t\t\\\n\t(void)___swait_event(wq, condition, TASK_IDLE, 0, schedule())\n\n \n#define swait_event_idle_exclusive(wq, condition)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\t__swait_event_idle(wq, condition);\t\t\t\t\\\n} while (0)\n\n#define __swait_event_idle_timeout(wq, condition, timeout)\t\t\\\n\t___swait_event(wq, ___wait_cond_timeout(condition),\t\t\\\n\t\t       TASK_IDLE, timeout,\t\t\t\t\\\n\t\t       __ret = schedule_timeout(__ret))\n\n \n#define swait_event_idle_timeout_exclusive(wq, condition, timeout)\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\\\n\t\t__ret = __swait_event_idle_timeout(wq,\t\t\t\\\n\t\t\t\t\t\t   condition, timeout);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}