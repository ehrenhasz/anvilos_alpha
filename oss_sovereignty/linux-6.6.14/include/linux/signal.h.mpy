{
  "module_name": "signal.h",
  "hash_id": "066416f2b051df72e678bde60e7d157d49fa4199e58c753c6cc9cbfad23b126e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/signal.h",
  "human_readable_source": " \n#ifndef _LINUX_SIGNAL_H\n#define _LINUX_SIGNAL_H\n\n#include <linux/bug.h>\n#include <linux/signal_types.h>\n#include <linux/string.h>\n\nstruct task_struct;\n\n \nextern int print_fatal_signals;\n\nstatic inline void copy_siginfo(kernel_siginfo_t *to,\n\t\t\t\tconst kernel_siginfo_t *from)\n{\n\tmemcpy(to, from, sizeof(*to));\n}\n\nstatic inline void clear_siginfo(kernel_siginfo_t *info)\n{\n\tmemset(info, 0, sizeof(*info));\n}\n\n#define SI_EXPANSION_SIZE (sizeof(struct siginfo) - sizeof(struct kernel_siginfo))\n\nstatic inline void copy_siginfo_to_external(siginfo_t *to,\n\t\t\t\t\t    const kernel_siginfo_t *from)\n{\n\tmemcpy(to, from, sizeof(*from));\n\tmemset(((char *)to) + sizeof(struct kernel_siginfo), 0,\n\t\tSI_EXPANSION_SIZE);\n}\n\nint copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from);\nint copy_siginfo_from_user(kernel_siginfo_t *to, const siginfo_t __user *from);\n\nenum siginfo_layout {\n\tSIL_KILL,\n\tSIL_TIMER,\n\tSIL_POLL,\n\tSIL_FAULT,\n\tSIL_FAULT_TRAPNO,\n\tSIL_FAULT_MCEERR,\n\tSIL_FAULT_BNDERR,\n\tSIL_FAULT_PKUERR,\n\tSIL_FAULT_PERF_EVENT,\n\tSIL_CHLD,\n\tSIL_RT,\n\tSIL_SYS,\n};\n\nenum siginfo_layout siginfo_layout(unsigned sig, int si_code);\n\n \n\n#ifndef __HAVE_ARCH_SIG_BITOPS\n#include <linux/bitops.h>\n\n \nstatic inline void sigaddset(sigset_t *set, int _sig)\n{\n\tunsigned long sig = _sig - 1;\n\tif (_NSIG_WORDS == 1)\n\t\tset->sig[0] |= 1UL << sig;\n\telse\n\t\tset->sig[sig / _NSIG_BPW] |= 1UL << (sig % _NSIG_BPW);\n}\n\nstatic inline void sigdelset(sigset_t *set, int _sig)\n{\n\tunsigned long sig = _sig - 1;\n\tif (_NSIG_WORDS == 1)\n\t\tset->sig[0] &= ~(1UL << sig);\n\telse\n\t\tset->sig[sig / _NSIG_BPW] &= ~(1UL << (sig % _NSIG_BPW));\n}\n\nstatic inline int sigismember(sigset_t *set, int _sig)\n{\n\tunsigned long sig = _sig - 1;\n\tif (_NSIG_WORDS == 1)\n\t\treturn 1 & (set->sig[0] >> sig);\n\telse\n\t\treturn 1 & (set->sig[sig / _NSIG_BPW] >> (sig % _NSIG_BPW));\n}\n\n#endif  \n\nstatic inline int sigisemptyset(sigset_t *set)\n{\n\tswitch (_NSIG_WORDS) {\n\tcase 4:\n\t\treturn (set->sig[3] | set->sig[2] |\n\t\t\tset->sig[1] | set->sig[0]) == 0;\n\tcase 2:\n\t\treturn (set->sig[1] | set->sig[0]) == 0;\n\tcase 1:\n\t\treturn set->sig[0] == 0;\n\tdefault:\n\t\tBUILD_BUG();\n\t\treturn 0;\n\t}\n}\n\nstatic inline int sigequalsets(const sigset_t *set1, const sigset_t *set2)\n{\n\tswitch (_NSIG_WORDS) {\n\tcase 4:\n\t\treturn\t(set1->sig[3] == set2->sig[3]) &&\n\t\t\t(set1->sig[2] == set2->sig[2]) &&\n\t\t\t(set1->sig[1] == set2->sig[1]) &&\n\t\t\t(set1->sig[0] == set2->sig[0]);\n\tcase 2:\n\t\treturn\t(set1->sig[1] == set2->sig[1]) &&\n\t\t\t(set1->sig[0] == set2->sig[0]);\n\tcase 1:\n\t\treturn\tset1->sig[0] == set2->sig[0];\n\t}\n\treturn 0;\n}\n\n#define sigmask(sig)\t(1UL << ((sig) - 1))\n\n#ifndef __HAVE_ARCH_SIG_SETOPS\n\n#define _SIG_SET_BINOP(name, op)\t\t\t\t\t\\\nstatic inline void name(sigset_t *r, const sigset_t *a, const sigset_t *b) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long a0, a1, a2, a3, b0, b1, b2, b3;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tswitch (_NSIG_WORDS) {\t\t\t\t\t\t\\\n\tcase 4:\t\t\t\t\t\t\t\t\\\n\t\ta3 = a->sig[3]; a2 = a->sig[2];\t\t\t\t\\\n\t\tb3 = b->sig[3]; b2 = b->sig[2];\t\t\t\t\\\n\t\tr->sig[3] = op(a3, b3);\t\t\t\t\t\\\n\t\tr->sig[2] = op(a2, b2);\t\t\t\t\t\\\n\t\tfallthrough;\t\t\t\t\t\t\\\n\tcase 2:\t\t\t\t\t\t\t\t\\\n\t\ta1 = a->sig[1]; b1 = b->sig[1];\t\t\t\t\\\n\t\tr->sig[1] = op(a1, b1);\t\t\t\t\t\\\n\t\tfallthrough;\t\t\t\t\t\t\\\n\tcase 1:\t\t\t\t\t\t\t\t\\\n\t\ta0 = a->sig[0]; b0 = b->sig[0];\t\t\t\t\\\n\t\tr->sig[0] = op(a0, b0);\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\tBUILD_BUG();\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n#define _sig_or(x,y)\t((x) | (y))\n_SIG_SET_BINOP(sigorsets, _sig_or)\n\n#define _sig_and(x,y)\t((x) & (y))\n_SIG_SET_BINOP(sigandsets, _sig_and)\n\n#define _sig_andn(x,y)\t((x) & ~(y))\n_SIG_SET_BINOP(sigandnsets, _sig_andn)\n\n#undef _SIG_SET_BINOP\n#undef _sig_or\n#undef _sig_and\n#undef _sig_andn\n\n#define _SIG_SET_OP(name, op)\t\t\t\t\t\t\\\nstatic inline void name(sigset_t *set)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tswitch (_NSIG_WORDS) {\t\t\t\t\t\t\\\n\tcase 4:\tset->sig[3] = op(set->sig[3]);\t\t\t\t\\\n\t\tset->sig[2] = op(set->sig[2]);\t\t\t\t\\\n\t\tfallthrough;\t\t\t\t\t\t\\\n\tcase 2:\tset->sig[1] = op(set->sig[1]);\t\t\t\t\\\n\t\tfallthrough;\t\t\t\t\t\t\\\n\tcase 1:\tset->sig[0] = op(set->sig[0]);\t\t\t\t\\\n\t\t    break;\t\t\t\t\t\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\tBUILD_BUG();\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n#define _sig_not(x)\t(~(x))\n_SIG_SET_OP(signotset, _sig_not)\n\n#undef _SIG_SET_OP\n#undef _sig_not\n\nstatic inline void sigemptyset(sigset_t *set)\n{\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tmemset(set, 0, sizeof(sigset_t));\n\t\tbreak;\n\tcase 2: set->sig[1] = 0;\n\t\tfallthrough;\n\tcase 1:\tset->sig[0] = 0;\n\t\tbreak;\n\t}\n}\n\nstatic inline void sigfillset(sigset_t *set)\n{\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tmemset(set, -1, sizeof(sigset_t));\n\t\tbreak;\n\tcase 2: set->sig[1] = -1;\n\t\tfallthrough;\n\tcase 1:\tset->sig[0] = -1;\n\t\tbreak;\n\t}\n}\n\n \n\nstatic inline void sigaddsetmask(sigset_t *set, unsigned long mask)\n{\n\tset->sig[0] |= mask;\n}\n\nstatic inline void sigdelsetmask(sigset_t *set, unsigned long mask)\n{\n\tset->sig[0] &= ~mask;\n}\n\nstatic inline int sigtestsetmask(sigset_t *set, unsigned long mask)\n{\n\treturn (set->sig[0] & mask) != 0;\n}\n\nstatic inline void siginitset(sigset_t *set, unsigned long mask)\n{\n\tset->sig[0] = mask;\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tmemset(&set->sig[1], 0, sizeof(long)*(_NSIG_WORDS-1));\n\t\tbreak;\n\tcase 2: set->sig[1] = 0;\n\t\tbreak;\n\tcase 1: ;\n\t}\n}\n\nstatic inline void siginitsetinv(sigset_t *set, unsigned long mask)\n{\n\tset->sig[0] = ~mask;\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tmemset(&set->sig[1], -1, sizeof(long)*(_NSIG_WORDS-1));\n\t\tbreak;\n\tcase 2: set->sig[1] = -1;\n\t\tbreak;\n\tcase 1: ;\n\t}\n}\n\n#endif  \n\nstatic inline void init_sigpending(struct sigpending *sig)\n{\n\tsigemptyset(&sig->signal);\n\tINIT_LIST_HEAD(&sig->list);\n}\n\nextern void flush_sigqueue(struct sigpending *queue);\n\n \nstatic inline int valid_signal(unsigned long sig)\n{\n\treturn sig <= _NSIG ? 1 : 0;\n}\n\nstruct timespec;\nstruct pt_regs;\nenum pid_type;\n\nextern int next_signal(struct sigpending *pending, sigset_t *mask);\nextern int do_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\t\tstruct task_struct *p, enum pid_type type);\nextern int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\t       struct task_struct *p, enum pid_type type);\nextern int send_signal_locked(int sig, struct kernel_siginfo *info,\n\t\t\t      struct task_struct *p, enum pid_type type);\nextern int sigprocmask(int, sigset_t *, sigset_t *);\nextern void set_current_blocked(sigset_t *);\nextern void __set_current_blocked(const sigset_t *);\nextern int show_unhandled_signals;\n\nextern bool get_signal(struct ksignal *ksig);\nextern void signal_setup_done(int failed, struct ksignal *ksig, int stepping);\nextern void exit_signals(struct task_struct *tsk);\nextern void kernel_sigaction(int, __sighandler_t);\n\n#define SIG_KTHREAD ((__force __sighandler_t)2)\n#define SIG_KTHREAD_KERNEL ((__force __sighandler_t)3)\n\nstatic inline void allow_signal(int sig)\n{\n\t \n\tkernel_sigaction(sig, SIG_KTHREAD);\n}\n\nstatic inline void allow_kernel_signal(int sig)\n{\n\t \n\tkernel_sigaction(sig, SIG_KTHREAD_KERNEL);\n}\n\nstatic inline void disallow_signal(int sig)\n{\n\tkernel_sigaction(sig, SIG_IGN);\n}\n\nextern struct kmem_cache *sighand_cachep;\n\nextern bool unhandled_signal(struct task_struct *tsk, int sig);\n\n \n\n#ifdef SIGEMT\n#define SIGEMT_MASK\trt_sigmask(SIGEMT)\n#else\n#define SIGEMT_MASK\t0\n#endif\n\n#if SIGRTMIN > BITS_PER_LONG\n#define rt_sigmask(sig)\t(1ULL << ((sig)-1))\n#else\n#define rt_sigmask(sig)\tsigmask(sig)\n#endif\n\n#define siginmask(sig, mask) \\\n\t((sig) > 0 && (sig) < SIGRTMIN && (rt_sigmask(sig) & (mask)))\n\n#define SIG_KERNEL_ONLY_MASK (\\\n\trt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP))\n\n#define SIG_KERNEL_STOP_MASK (\\\n\trt_sigmask(SIGSTOP)   |  rt_sigmask(SIGTSTP)   | \\\n\trt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   )\n\n#define SIG_KERNEL_COREDUMP_MASK (\\\n        rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \\\n\trt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \\\n        rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \\\n\trt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \\\n        rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \\\n\tSIGEMT_MASK\t\t\t\t       )\n\n#define SIG_KERNEL_IGNORE_MASK (\\\n        rt_sigmask(SIGCONT)   |  rt_sigmask(SIGCHLD)   | \\\n\trt_sigmask(SIGWINCH)  |  rt_sigmask(SIGURG)    )\n\n#define SIG_SPECIFIC_SICODES_MASK (\\\n\trt_sigmask(SIGILL)    |  rt_sigmask(SIGFPE)    | \\\n\trt_sigmask(SIGSEGV)   |  rt_sigmask(SIGBUS)    | \\\n\trt_sigmask(SIGTRAP)   |  rt_sigmask(SIGCHLD)   | \\\n\trt_sigmask(SIGPOLL)   |  rt_sigmask(SIGSYS)    | \\\n\tSIGEMT_MASK                                    )\n\n#define sig_kernel_only(sig)\t\tsiginmask(sig, SIG_KERNEL_ONLY_MASK)\n#define sig_kernel_coredump(sig)\tsiginmask(sig, SIG_KERNEL_COREDUMP_MASK)\n#define sig_kernel_ignore(sig)\t\tsiginmask(sig, SIG_KERNEL_IGNORE_MASK)\n#define sig_kernel_stop(sig)\t\tsiginmask(sig, SIG_KERNEL_STOP_MASK)\n#define sig_specific_sicodes(sig)\tsiginmask(sig, SIG_SPECIFIC_SICODES_MASK)\n\n#define sig_fatal(t, signr) \\\n\t(!siginmask(signr, SIG_KERNEL_IGNORE_MASK|SIG_KERNEL_STOP_MASK) && \\\n\t (t)->sighand->action[(signr)-1].sa.sa_handler == SIG_DFL)\n\nvoid signals_init(void);\n\nint restore_altstack(const stack_t __user *);\nint __save_altstack(stack_t __user *, unsigned long);\n\n#define unsafe_save_altstack(uss, sp, label) do { \\\n\tstack_t __user *__uss = uss; \\\n\tstruct task_struct *t = current; \\\n\tunsafe_put_user((void __user *)t->sas_ss_sp, &__uss->ss_sp, label); \\\n\tunsafe_put_user(t->sas_ss_flags, &__uss->ss_flags, label); \\\n\tunsafe_put_user(t->sas_ss_size, &__uss->ss_size, label); \\\n} while (0);\n\n#ifdef CONFIG_DYNAMIC_SIGFRAME\nbool sigaltstack_size_valid(size_t ss_size);\n#else\nstatic inline bool sigaltstack_size_valid(size_t size) { return true; }\n#endif  \n\n#ifdef CONFIG_PROC_FS\nstruct seq_file;\nextern void render_sigset_t(struct seq_file *, const char *, sigset_t *);\n#endif\n\n#ifndef arch_untagged_si_addr\n \nstatic inline void __user *arch_untagged_si_addr(void __user *addr,\n\t\t\t\t\t\t unsigned long sig,\n\t\t\t\t\t\t unsigned long si_code)\n{\n\treturn addr;\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}