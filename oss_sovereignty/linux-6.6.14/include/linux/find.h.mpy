{
  "module_name": "find.h",
  "hash_id": "78a03f7701e49bf7ef4774d31d6f1e13b484e3e2493643f5a9e27d6290d8567b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/find.h",
  "human_readable_source": " \n#ifndef __LINUX_FIND_H_\n#define __LINUX_FIND_H_\n\n#ifndef __LINUX_BITMAP_H\n#error only <linux/bitmap.h> can be included directly\n#endif\n\n#include <linux/bitops.h>\n\nunsigned long _find_next_bit(const unsigned long *addr1, unsigned long nbits,\n\t\t\t\tunsigned long start);\nunsigned long _find_next_and_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t\tunsigned long nbits, unsigned long start);\nunsigned long _find_next_andnot_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t\tunsigned long nbits, unsigned long start);\nunsigned long _find_next_or_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t\tunsigned long nbits, unsigned long start);\nunsigned long _find_next_zero_bit(const unsigned long *addr, unsigned long nbits,\n\t\t\t\t\t unsigned long start);\nextern unsigned long _find_first_bit(const unsigned long *addr, unsigned long size);\nunsigned long __find_nth_bit(const unsigned long *addr, unsigned long size, unsigned long n);\nunsigned long __find_nth_and_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\tunsigned long size, unsigned long n);\nunsigned long __find_nth_andnot_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t\tunsigned long size, unsigned long n);\nunsigned long __find_nth_and_andnot_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t\tconst unsigned long *addr3, unsigned long size,\n\t\t\t\t\tunsigned long n);\nextern unsigned long _find_first_and_bit(const unsigned long *addr1,\n\t\t\t\t\t const unsigned long *addr2, unsigned long size);\nextern unsigned long _find_first_zero_bit(const unsigned long *addr, unsigned long size);\nextern unsigned long _find_last_bit(const unsigned long *addr, unsigned long size);\n\n#ifdef __BIG_ENDIAN\nunsigned long _find_first_zero_bit_le(const unsigned long *addr, unsigned long size);\nunsigned long _find_next_zero_bit_le(const  unsigned long *addr, unsigned\n\t\t\t\t\tlong size, unsigned long offset);\nunsigned long _find_next_bit_le(const unsigned long *addr, unsigned\n\t\t\t\tlong size, unsigned long offset);\n#endif\n\n#ifndef find_next_bit\n \nstatic inline\nunsigned long find_next_bit(const unsigned long *addr, unsigned long size,\n\t\t\t    unsigned long offset)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val;\n\n\t\tif (unlikely(offset >= size))\n\t\t\treturn size;\n\n\t\tval = *addr & GENMASK(size - 1, offset);\n\t\treturn val ? __ffs(val) : size;\n\t}\n\n\treturn _find_next_bit(addr, size, offset);\n}\n#endif\n\n#ifndef find_next_and_bit\n \nstatic inline\nunsigned long find_next_and_bit(const unsigned long *addr1,\n\t\tconst unsigned long *addr2, unsigned long size,\n\t\tunsigned long offset)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val;\n\n\t\tif (unlikely(offset >= size))\n\t\t\treturn size;\n\n\t\tval = *addr1 & *addr2 & GENMASK(size - 1, offset);\n\t\treturn val ? __ffs(val) : size;\n\t}\n\n\treturn _find_next_and_bit(addr1, addr2, size, offset);\n}\n#endif\n\n#ifndef find_next_andnot_bit\n \nstatic inline\nunsigned long find_next_andnot_bit(const unsigned long *addr1,\n\t\tconst unsigned long *addr2, unsigned long size,\n\t\tunsigned long offset)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val;\n\n\t\tif (unlikely(offset >= size))\n\t\t\treturn size;\n\n\t\tval = *addr1 & ~*addr2 & GENMASK(size - 1, offset);\n\t\treturn val ? __ffs(val) : size;\n\t}\n\n\treturn _find_next_andnot_bit(addr1, addr2, size, offset);\n}\n#endif\n\n#ifndef find_next_or_bit\n \nstatic inline\nunsigned long find_next_or_bit(const unsigned long *addr1,\n\t\tconst unsigned long *addr2, unsigned long size,\n\t\tunsigned long offset)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val;\n\n\t\tif (unlikely(offset >= size))\n\t\t\treturn size;\n\n\t\tval = (*addr1 | *addr2) & GENMASK(size - 1, offset);\n\t\treturn val ? __ffs(val) : size;\n\t}\n\n\treturn _find_next_or_bit(addr1, addr2, size, offset);\n}\n#endif\n\n#ifndef find_next_zero_bit\n \nstatic inline\nunsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\t\t\t\t unsigned long offset)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val;\n\n\t\tif (unlikely(offset >= size))\n\t\t\treturn size;\n\n\t\tval = *addr | ~GENMASK(size - 1, offset);\n\t\treturn val == ~0UL ? size : ffz(val);\n\t}\n\n\treturn _find_next_zero_bit(addr, size, offset);\n}\n#endif\n\n#ifndef find_first_bit\n \nstatic inline\nunsigned long find_first_bit(const unsigned long *addr, unsigned long size)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val = *addr & GENMASK(size - 1, 0);\n\n\t\treturn val ? __ffs(val) : size;\n\t}\n\n\treturn _find_first_bit(addr, size);\n}\n#endif\n\n \nstatic inline\nunsigned long find_nth_bit(const unsigned long *addr, unsigned long size, unsigned long n)\n{\n\tif (n >= size)\n\t\treturn size;\n\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val =  *addr & GENMASK(size - 1, 0);\n\n\t\treturn val ? fns(val, n) : size;\n\t}\n\n\treturn __find_nth_bit(addr, size, n);\n}\n\n \nstatic inline\nunsigned long find_nth_and_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\tunsigned long size, unsigned long n)\n{\n\tif (n >= size)\n\t\treturn size;\n\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val =  *addr1 & *addr2 & GENMASK(size - 1, 0);\n\n\t\treturn val ? fns(val, n) : size;\n\t}\n\n\treturn __find_nth_and_bit(addr1, addr2, size, n);\n}\n\n \nstatic inline\nunsigned long find_nth_andnot_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\tunsigned long size, unsigned long n)\n{\n\tif (n >= size)\n\t\treturn size;\n\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val =  *addr1 & (~*addr2) & GENMASK(size - 1, 0);\n\n\t\treturn val ? fns(val, n) : size;\n\t}\n\n\treturn __find_nth_andnot_bit(addr1, addr2, size, n);\n}\n\n \nstatic __always_inline\nunsigned long find_nth_and_andnot_bit(const unsigned long *addr1,\n\t\t\t\t\tconst unsigned long *addr2,\n\t\t\t\t\tconst unsigned long *addr3,\n\t\t\t\t\tunsigned long size, unsigned long n)\n{\n\tif (n >= size)\n\t\treturn size;\n\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val =  *addr1 & *addr2 & (~*addr3) & GENMASK(size - 1, 0);\n\n\t\treturn val ? fns(val, n) : size;\n\t}\n\n\treturn __find_nth_and_andnot_bit(addr1, addr2, addr3, size, n);\n}\n\n#ifndef find_first_and_bit\n \nstatic inline\nunsigned long find_first_and_bit(const unsigned long *addr1,\n\t\t\t\t const unsigned long *addr2,\n\t\t\t\t unsigned long size)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val = *addr1 & *addr2 & GENMASK(size - 1, 0);\n\n\t\treturn val ? __ffs(val) : size;\n\t}\n\n\treturn _find_first_and_bit(addr1, addr2, size);\n}\n#endif\n\n#ifndef find_first_zero_bit\n \nstatic inline\nunsigned long find_first_zero_bit(const unsigned long *addr, unsigned long size)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val = *addr | ~GENMASK(size - 1, 0);\n\n\t\treturn val == ~0UL ? size : ffz(val);\n\t}\n\n\treturn _find_first_zero_bit(addr, size);\n}\n#endif\n\n#ifndef find_last_bit\n \nstatic inline\nunsigned long find_last_bit(const unsigned long *addr, unsigned long size)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val = *addr & GENMASK(size - 1, 0);\n\n\t\treturn val ? __fls(val) : size;\n\t}\n\n\treturn _find_last_bit(addr, size);\n}\n#endif\n\n \nstatic inline\nunsigned long find_next_and_bit_wrap(const unsigned long *addr1,\n\t\t\t\t\tconst unsigned long *addr2,\n\t\t\t\t\tunsigned long size, unsigned long offset)\n{\n\tunsigned long bit = find_next_and_bit(addr1, addr2, size, offset);\n\n\tif (bit < size)\n\t\treturn bit;\n\n\tbit = find_first_and_bit(addr1, addr2, offset);\n\treturn bit < offset ? bit : size;\n}\n\n \nstatic inline\nunsigned long find_next_bit_wrap(const unsigned long *addr,\n\t\t\t\t\tunsigned long size, unsigned long offset)\n{\n\tunsigned long bit = find_next_bit(addr, size, offset);\n\n\tif (bit < size)\n\t\treturn bit;\n\n\tbit = find_first_bit(addr, offset);\n\treturn bit < offset ? bit : size;\n}\n\n \nstatic inline\nunsigned long __for_each_wrap(const unsigned long *bitmap, unsigned long size,\n\t\t\t\t unsigned long start, unsigned long n)\n{\n\tunsigned long bit;\n\n\t \n\tif (n > start) {\n\t\t \n\t\tbit = find_next_bit(bitmap, size, n);\n\t\tif (bit < size)\n\t\t\treturn bit;\n\n\t\t \n\t\tn = 0;\n\t}\n\n\t \n\tbit = find_next_bit(bitmap, start, n);\n\treturn bit < start ? bit : size;\n}\n\n \nextern unsigned long find_next_clump8(unsigned long *clump,\n\t\t\t\t      const unsigned long *addr,\n\t\t\t\t      unsigned long size, unsigned long offset);\n\n#define find_first_clump8(clump, bits, size) \\\n\tfind_next_clump8((clump), (bits), (size), 0)\n\n#if defined(__LITTLE_ENDIAN)\n\nstatic inline unsigned long find_next_zero_bit_le(const void *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_zero_bit(addr, size, offset);\n}\n\nstatic inline unsigned long find_next_bit_le(const void *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_bit(addr, size, offset);\n}\n\nstatic inline unsigned long find_first_zero_bit_le(const void *addr,\n\t\tunsigned long size)\n{\n\treturn find_first_zero_bit(addr, size);\n}\n\n#elif defined(__BIG_ENDIAN)\n\n#ifndef find_next_zero_bit_le\nstatic inline\nunsigned long find_next_zero_bit_le(const void *addr, unsigned\n\t\tlong size, unsigned long offset)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val = *(const unsigned long *)addr;\n\n\t\tif (unlikely(offset >= size))\n\t\t\treturn size;\n\n\t\tval = swab(val) | ~GENMASK(size - 1, offset);\n\t\treturn val == ~0UL ? size : ffz(val);\n\t}\n\n\treturn _find_next_zero_bit_le(addr, size, offset);\n}\n#endif\n\n#ifndef find_first_zero_bit_le\nstatic inline\nunsigned long find_first_zero_bit_le(const void *addr, unsigned long size)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val = swab(*(const unsigned long *)addr) | ~GENMASK(size - 1, 0);\n\n\t\treturn val == ~0UL ? size : ffz(val);\n\t}\n\n\treturn _find_first_zero_bit_le(addr, size);\n}\n#endif\n\n#ifndef find_next_bit_le\nstatic inline\nunsigned long find_next_bit_le(const void *addr, unsigned\n\t\tlong size, unsigned long offset)\n{\n\tif (small_const_nbits(size)) {\n\t\tunsigned long val = *(const unsigned long *)addr;\n\n\t\tif (unlikely(offset >= size))\n\t\t\treturn size;\n\n\t\tval = swab(val) & GENMASK(size - 1, offset);\n\t\treturn val ? __ffs(val) : size;\n\t}\n\n\treturn _find_next_bit_le(addr, size, offset);\n}\n#endif\n\n#else\n#error \"Please fix <asm/byteorder.h>\"\n#endif\n\n#define for_each_set_bit(bit, addr, size) \\\n\tfor ((bit) = 0; (bit) = find_next_bit((addr), (size), (bit)), (bit) < (size); (bit)++)\n\n#define for_each_and_bit(bit, addr1, addr2, size) \\\n\tfor ((bit) = 0;\t\t\t\t\t\t\t\t\t\\\n\t     (bit) = find_next_and_bit((addr1), (addr2), (size), (bit)), (bit) < (size);\\\n\t     (bit)++)\n\n#define for_each_andnot_bit(bit, addr1, addr2, size) \\\n\tfor ((bit) = 0;\t\t\t\t\t\t\t\t\t\\\n\t     (bit) = find_next_andnot_bit((addr1), (addr2), (size), (bit)), (bit) < (size);\\\n\t     (bit)++)\n\n#define for_each_or_bit(bit, addr1, addr2, size) \\\n\tfor ((bit) = 0;\t\t\t\t\t\t\t\t\t\\\n\t     (bit) = find_next_or_bit((addr1), (addr2), (size), (bit)), (bit) < (size);\\\n\t     (bit)++)\n\n \n#define for_each_set_bit_from(bit, addr, size) \\\n\tfor (; (bit) = find_next_bit((addr), (size), (bit)), (bit) < (size); (bit)++)\n\n#define for_each_clear_bit(bit, addr, size) \\\n\tfor ((bit) = 0;\t\t\t\t\t\t\t\t\t\\\n\t     (bit) = find_next_zero_bit((addr), (size), (bit)), (bit) < (size);\t\t\\\n\t     (bit)++)\n\n \n#define for_each_clear_bit_from(bit, addr, size) \\\n\tfor (; (bit) = find_next_zero_bit((addr), (size), (bit)), (bit) < (size); (bit)++)\n\n \n#define for_each_set_bitrange(b, e, addr, size)\t\t\t\\\n\tfor ((b) = 0;\t\t\t\t\t\t\\\n\t     (b) = find_next_bit((addr), (size), b),\t\t\\\n\t     (e) = find_next_zero_bit((addr), (size), (b) + 1),\t\\\n\t     (b) < (size);\t\t\t\t\t\\\n\t     (b) = (e) + 1)\n\n \n#define for_each_set_bitrange_from(b, e, addr, size)\t\t\\\n\tfor (;\t\t\t\t\t\t\t\\\n\t     (b) = find_next_bit((addr), (size), (b)),\t\t\\\n\t     (e) = find_next_zero_bit((addr), (size), (b) + 1),\t\\\n\t     (b) < (size);\t\t\t\t\t\\\n\t     (b) = (e) + 1)\n\n \n#define for_each_clear_bitrange(b, e, addr, size)\t\t\\\n\tfor ((b) = 0;\t\t\t\t\t\t\\\n\t     (b) = find_next_zero_bit((addr), (size), (b)),\t\\\n\t     (e) = find_next_bit((addr), (size), (b) + 1),\t\\\n\t     (b) < (size);\t\t\t\t\t\\\n\t     (b) = (e) + 1)\n\n \n#define for_each_clear_bitrange_from(b, e, addr, size)\t\t\\\n\tfor (;\t\t\t\t\t\t\t\\\n\t     (b) = find_next_zero_bit((addr), (size), (b)),\t\\\n\t     (e) = find_next_bit((addr), (size), (b) + 1),\t\\\n\t     (b) < (size);\t\t\t\t\t\\\n\t     (b) = (e) + 1)\n\n \n#define for_each_set_bit_wrap(bit, addr, size, start) \\\n\tfor ((bit) = find_next_bit_wrap((addr), (size), (start));\t\t\\\n\t     (bit) < (size);\t\t\t\t\t\t\t\\\n\t     (bit) = __for_each_wrap((addr), (size), (start), (bit) + 1))\n\n \n#define for_each_set_clump8(start, clump, bits, size) \\\n\tfor ((start) = find_first_clump8(&(clump), (bits), (size)); \\\n\t     (start) < (size); \\\n\t     (start) = find_next_clump8(&(clump), (bits), (size), (start) + 8))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}