{
  "module_name": "string.h",
  "hash_id": "d6a9213a279d5df6571c87981397e8b11c5576c8c7f1985585a2909dfda523d0",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/string.h",
  "human_readable_source": " \n#ifndef _LINUX_STRING_H_\n#define _LINUX_STRING_H_\n\n#include <linux/compiler.h>\t \n#include <linux/types.h>\t \n#include <linux/stddef.h>\t \n#include <linux/err.h>\t\t \n#include <linux/errno.h>\t \n#include <linux/overflow.h>\t \n#include <linux/stdarg.h>\n#include <uapi/linux/string.h>\n\nextern char *strndup_user(const char __user *, long);\nextern void *memdup_user(const void __user *, size_t);\nextern void *vmemdup_user(const void __user *, size_t);\nextern void *memdup_user_nul(const void __user *, size_t);\n\n \nstatic inline void *memdup_array_user(const void __user *src, size_t n, size_t size)\n{\n\tsize_t nbytes;\n\n\tif (check_mul_overflow(n, size, &nbytes))\n\t\treturn ERR_PTR(-EOVERFLOW);\n\n\treturn memdup_user(src, nbytes);\n}\n\n \nstatic inline void *vmemdup_array_user(const void __user *src, size_t n, size_t size)\n{\n\tsize_t nbytes;\n\n\tif (check_mul_overflow(n, size, &nbytes))\n\t\treturn ERR_PTR(-EOVERFLOW);\n\n\treturn vmemdup_user(src, nbytes);\n}\n\n \n#include <asm/string.h>\n\n#ifndef __HAVE_ARCH_STRCPY\nextern char * strcpy(char *,const char *);\n#endif\n#ifndef __HAVE_ARCH_STRNCPY\nextern char * strncpy(char *,const char *, __kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_STRLCPY\nsize_t strlcpy(char *, const char *, size_t);\n#endif\n#ifndef __HAVE_ARCH_STRSCPY\nssize_t strscpy(char *, const char *, size_t);\n#endif\n\n \nssize_t strscpy_pad(char *dest, const char *src, size_t count);\n\n#ifndef __HAVE_ARCH_STRCAT\nextern char * strcat(char *, const char *);\n#endif\n#ifndef __HAVE_ARCH_STRNCAT\nextern char * strncat(char *, const char *, __kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_STRLCAT\nextern size_t strlcat(char *, const char *, __kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_STRCMP\nextern int strcmp(const char *,const char *);\n#endif\n#ifndef __HAVE_ARCH_STRNCMP\nextern int strncmp(const char *,const char *,__kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_STRCASECMP\nextern int strcasecmp(const char *s1, const char *s2);\n#endif\n#ifndef __HAVE_ARCH_STRNCASECMP\nextern int strncasecmp(const char *s1, const char *s2, size_t n);\n#endif\n#ifndef __HAVE_ARCH_STRCHR\nextern char * strchr(const char *,int);\n#endif\n#ifndef __HAVE_ARCH_STRCHRNUL\nextern char * strchrnul(const char *,int);\n#endif\nextern char * strnchrnul(const char *, size_t, int);\n#ifndef __HAVE_ARCH_STRNCHR\nextern char * strnchr(const char *, size_t, int);\n#endif\n#ifndef __HAVE_ARCH_STRRCHR\nextern char * strrchr(const char *,int);\n#endif\nextern char * __must_check skip_spaces(const char *);\n\nextern char *strim(char *);\n\nstatic inline __must_check char *strstrip(char *str)\n{\n\treturn strim(str);\n}\n\n#ifndef __HAVE_ARCH_STRSTR\nextern char * strstr(const char *, const char *);\n#endif\n#ifndef __HAVE_ARCH_STRNSTR\nextern char * strnstr(const char *, const char *, size_t);\n#endif\n#ifndef __HAVE_ARCH_STRLEN\nextern __kernel_size_t strlen(const char *);\n#endif\n#ifndef __HAVE_ARCH_STRNLEN\nextern __kernel_size_t strnlen(const char *,__kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_STRPBRK\nextern char * strpbrk(const char *,const char *);\n#endif\n#ifndef __HAVE_ARCH_STRSEP\nextern char * strsep(char **,const char *);\n#endif\n#ifndef __HAVE_ARCH_STRSPN\nextern __kernel_size_t strspn(const char *,const char *);\n#endif\n#ifndef __HAVE_ARCH_STRCSPN\nextern __kernel_size_t strcspn(const char *,const char *);\n#endif\n\n#ifndef __HAVE_ARCH_MEMSET\nextern void * memset(void *,int,__kernel_size_t);\n#endif\n\n#ifndef __HAVE_ARCH_MEMSET16\nextern void *memset16(uint16_t *, uint16_t, __kernel_size_t);\n#endif\n\n#ifndef __HAVE_ARCH_MEMSET32\nextern void *memset32(uint32_t *, uint32_t, __kernel_size_t);\n#endif\n\n#ifndef __HAVE_ARCH_MEMSET64\nextern void *memset64(uint64_t *, uint64_t, __kernel_size_t);\n#endif\n\nstatic inline void *memset_l(unsigned long *p, unsigned long v,\n\t\t__kernel_size_t n)\n{\n\tif (BITS_PER_LONG == 32)\n\t\treturn memset32((uint32_t *)p, v, n);\n\telse\n\t\treturn memset64((uint64_t *)p, v, n);\n}\n\nstatic inline void *memset_p(void **p, void *v, __kernel_size_t n)\n{\n\tif (BITS_PER_LONG == 32)\n\t\treturn memset32((uint32_t *)p, (uintptr_t)v, n);\n\telse\n\t\treturn memset64((uint64_t *)p, (uintptr_t)v, n);\n}\n\nextern void **__memcat_p(void **a, void **b);\n#define memcat_p(a, b) ({\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(a), *(b)),\t\t\\\n\t\t\t \"type mismatch in memcat_p()\");\t\\\n\t(typeof(*a) *)__memcat_p((void **)(a), (void **)(b));\t\\\n})\n\n#ifndef __HAVE_ARCH_MEMCPY\nextern void * memcpy(void *,const void *,__kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_MEMMOVE\nextern void * memmove(void *,const void *,__kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_MEMSCAN\nextern void * memscan(void *,int,__kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_MEMCMP\nextern int memcmp(const void *,const void *,__kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_BCMP\nextern int bcmp(const void *,const void *,__kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_MEMCHR\nextern void * memchr(const void *,int,__kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_MEMCPY_FLUSHCACHE\nstatic inline void memcpy_flushcache(void *dst, const void *src, size_t cnt)\n{\n\tmemcpy(dst, src, cnt);\n}\n#endif\n\nvoid *memchr_inv(const void *s, int c, size_t n);\nchar *strreplace(char *str, char old, char new);\n\nextern void kfree_const(const void *x);\n\nextern char *kstrdup(const char *s, gfp_t gfp) __malloc;\nextern const char *kstrdup_const(const char *s, gfp_t gfp);\nextern char *kstrndup(const char *s, size_t len, gfp_t gfp);\nextern void *kmemdup(const void *src, size_t len, gfp_t gfp) __realloc_size(2);\nextern void *kvmemdup(const void *src, size_t len, gfp_t gfp) __realloc_size(2);\nextern char *kmemdup_nul(const char *s, size_t len, gfp_t gfp);\n\nextern char **argv_split(gfp_t gfp, const char *str, int *argcp);\nextern void argv_free(char **argv);\n\nextern bool sysfs_streq(const char *s1, const char *s2);\nint match_string(const char * const *array, size_t n, const char *string);\nint __sysfs_match_string(const char * const *array, size_t n, const char *s);\n\n \n#define sysfs_match_string(_a, _s) __sysfs_match_string(_a, ARRAY_SIZE(_a), _s)\n\n#ifdef CONFIG_BINARY_PRINTF\nint vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args);\nint bstr_printf(char *buf, size_t size, const char *fmt, const u32 *bin_buf);\nint bprintf(u32 *bin_buf, size_t size, const char *fmt, ...) __printf(3, 4);\n#endif\n\nextern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,\n\t\t\t\t       const void *from, size_t available);\n\nint ptr_to_hashval(const void *ptr, unsigned long *hashval_out);\n\n \nstatic inline bool strstarts(const char *str, const char *prefix)\n{\n\treturn strncmp(str, prefix, strlen(prefix)) == 0;\n}\n\nsize_t memweight(const void *ptr, size_t bytes);\n\n \nstatic inline void memzero_explicit(void *s, size_t count)\n{\n\tmemset(s, 0, count);\n\tbarrier_data(s);\n}\n\n \nstatic inline const char *kbasename(const char *path)\n{\n\tconst char *tail = strrchr(path, '/');\n\treturn tail ? tail + 1 : path;\n}\n\n#if !defined(__NO_FORTIFY) && defined(__OPTIMIZE__) && defined(CONFIG_FORTIFY_SOURCE)\n#include <linux/fortify-string.h>\n#endif\n#ifndef unsafe_memcpy\n#define unsafe_memcpy(dst, src, bytes, justification)\t\t\\\n\tmemcpy(dst, src, bytes)\n#endif\n\nvoid memcpy_and_pad(void *dest, size_t dest_len, const void *src, size_t count,\n\t\t    int pad);\n\n \n#define strtomem_pad(dest, src, pad)\tdo {\t\t\t\t\\\n\tconst size_t _dest_len = __builtin_object_size(dest, 1);\t\\\n\tconst size_t _src_len = __builtin_object_size(src, 1);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(!__builtin_constant_p(_dest_len) ||\t\t\\\n\t\t     _dest_len == (size_t)-1);\t\t\t\t\\\n\tmemcpy_and_pad(dest, _dest_len, src,\t\t\t\t\\\n\t\t       strnlen(src, min(_src_len, _dest_len)), pad);\t\\\n} while (0)\n\n \n#define strtomem(dest, src)\tdo {\t\t\t\t\t\\\n\tconst size_t _dest_len = __builtin_object_size(dest, 1);\t\\\n\tconst size_t _src_len = __builtin_object_size(src, 1);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(!__builtin_constant_p(_dest_len) ||\t\t\\\n\t\t     _dest_len == (size_t)-1);\t\t\t\t\\\n\tmemcpy(dest, src, strnlen(src, min(_src_len, _dest_len)));\t\\\n} while (0)\n\n \n#define memset_after(obj, v, member)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tu8 *__ptr = (u8 *)(obj);\t\t\t\t\t\\\n\ttypeof(v) __val = (v);\t\t\t\t\t\t\\\n\tmemset(__ptr + offsetofend(typeof(*(obj)), member), __val,\t\\\n\t       sizeof(*(obj)) - offsetofend(typeof(*(obj)), member));\t\\\n})\n\n \n#define memset_startat(obj, v, member)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tu8 *__ptr = (u8 *)(obj);\t\t\t\t\t\\\n\ttypeof(v) __val = (v);\t\t\t\t\t\t\\\n\tmemset(__ptr + offsetof(typeof(*(obj)), member), __val,\t\t\\\n\t       sizeof(*(obj)) - offsetof(typeof(*(obj)), member));\t\\\n})\n\n \nstatic __always_inline size_t str_has_prefix(const char *str, const char *prefix)\n{\n\tsize_t len = strlen(prefix);\n\treturn strncmp(str, prefix, len) == 0 ? len : 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}