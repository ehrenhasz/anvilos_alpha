{
  "module_name": "seqlock.h",
  "hash_id": "2530927775af9b117865ac2732204679f58033c0292a8d2cbfb794e213fc760e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/seqlock.h",
  "human_readable_source": " \n#ifndef __LINUX_SEQLOCK_H\n#define __LINUX_SEQLOCK_H\n\n \n\n#include <linux/compiler.h>\n#include <linux/kcsan-checks.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/preempt.h>\n#include <linux/spinlock.h>\n\n#include <asm/processor.h>\n\n \n#define KCSAN_SEQLOCK_REGION_MAX 1000\n\n \ntypedef struct seqcount {\n\tunsigned sequence;\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tstruct lockdep_map dep_map;\n#endif\n} seqcount_t;\n\nstatic inline void __seqcount_init(seqcount_t *s, const char *name,\n\t\t\t\t\t  struct lock_class_key *key)\n{\n\t \n\tlockdep_init_map(&s->dep_map, name, key, 0);\n\ts->sequence = 0;\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\n# define SEQCOUNT_DEP_MAP_INIT(lockname)\t\t\t\t\\\n\t\t.dep_map = { .name = #lockname }\n\n \n# define seqcount_init(s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic struct lock_class_key __key;\t\t\t\\\n\t\t__seqcount_init((s), #s, &__key);\t\t\t\\\n\t} while (0)\n\nstatic inline void seqcount_lockdep_reader_access(const seqcount_t *s)\n{\n\tseqcount_t *l = (seqcount_t *)s;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tseqcount_acquire_read(&l->dep_map, 0, 0, _RET_IP_);\n\tseqcount_release(&l->dep_map, _RET_IP_);\n\tlocal_irq_restore(flags);\n}\n\n#else\n# define SEQCOUNT_DEP_MAP_INIT(lockname)\n# define seqcount_init(s) __seqcount_init(s, NULL, NULL)\n# define seqcount_lockdep_reader_access(x)\n#endif\n\n \n#define SEQCNT_ZERO(name) { .sequence = 0, SEQCOUNT_DEP_MAP_INIT(name) }\n\n \n\n \n#if defined(CONFIG_LOCKDEP) || defined(CONFIG_PREEMPT_RT)\n#define __SEQ_LOCK(expr)\texpr\n#else\n#define __SEQ_LOCK(expr)\n#endif\n\n \n\n \n\n#define seqcount_LOCKNAME_init(s, _lock, lockname)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tseqcount_##lockname##_t *____s = (s);\t\t\t\\\n\t\tseqcount_init(&____s->seqcount);\t\t\t\\\n\t\t__SEQ_LOCK(____s->lock = (_lock));\t\t\t\\\n\t} while (0)\n\n#define seqcount_raw_spinlock_init(s, lock)\tseqcount_LOCKNAME_init(s, lock, raw_spinlock)\n#define seqcount_spinlock_init(s, lock)\t\tseqcount_LOCKNAME_init(s, lock, spinlock)\n#define seqcount_rwlock_init(s, lock)\t\tseqcount_LOCKNAME_init(s, lock, rwlock)\n#define seqcount_mutex_init(s, lock)\t\tseqcount_LOCKNAME_init(s, lock, mutex)\n\n \n#define SEQCOUNT_LOCKNAME(lockname, locktype, preemptible, lockmember, lockbase, lock_acquire) \\\ntypedef struct seqcount_##lockname {\t\t\t\t\t\\\n\tseqcount_t\t\tseqcount;\t\t\t\t\\\n\t__SEQ_LOCK(locktype\t*lock);\t\t\t\t\t\\\n} seqcount_##lockname##_t;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline seqcount_t *\t\t\t\t\t\\\n__seqprop_##lockname##_ptr(seqcount_##lockname##_t *s)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn &s->seqcount;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline unsigned\t\t\t\t\t\t\\\n__seqprop_##lockname##_sequence(const seqcount_##lockname##_t *s)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned seq = READ_ONCE(s->seqcount.sequence);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\t\t\t\t\\\n\t\treturn seq;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (preemptible && unlikely(seq & 1)) {\t\t\t\t\\\n\t\t__SEQ_LOCK(lock_acquire);\t\t\t\t\\\n\t\t__SEQ_LOCK(lockbase##_unlock(s->lock));\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t \t\t\t\t\t\t\t\\\n\t\tseq = READ_ONCE(s->seqcount.sequence);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn seq;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline bool\t\t\t\t\t\t\\\n__seqprop_##lockname##_preemptible(const seqcount_##lockname##_t *s)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\t\t\t\t\\\n\t\treturn preemptible;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\\\n\treturn false;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline void\t\t\t\t\t\t\\\n__seqprop_##lockname##_assert(const seqcount_##lockname##_t *s)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__SEQ_LOCK(lockdep_assert_held(lockmember));\t\t\t\\\n}\n\n \n\nstatic inline seqcount_t *__seqprop_ptr(seqcount_t *s)\n{\n\treturn s;\n}\n\nstatic inline unsigned __seqprop_sequence(const seqcount_t *s)\n{\n\treturn READ_ONCE(s->sequence);\n}\n\nstatic inline bool __seqprop_preemptible(const seqcount_t *s)\n{\n\treturn false;\n}\n\nstatic inline void __seqprop_assert(const seqcount_t *s)\n{\n\tlockdep_assert_preemption_disabled();\n}\n\n#define __SEQ_RT\tIS_ENABLED(CONFIG_PREEMPT_RT)\n\nSEQCOUNT_LOCKNAME(raw_spinlock, raw_spinlock_t,  false,    s->lock,        raw_spin, raw_spin_lock(s->lock))\nSEQCOUNT_LOCKNAME(spinlock,     spinlock_t,      __SEQ_RT, s->lock,        spin,     spin_lock(s->lock))\nSEQCOUNT_LOCKNAME(rwlock,       rwlock_t,        __SEQ_RT, s->lock,        read,     read_lock(s->lock))\nSEQCOUNT_LOCKNAME(mutex,        struct mutex,    true,     s->lock,        mutex,    mutex_lock(s->lock))\n\n \n\n#define SEQCOUNT_LOCKNAME_ZERO(seq_name, assoc_lock) {\t\t\t\\\n\t.seqcount\t\t= SEQCNT_ZERO(seq_name.seqcount),\t\\\n\t__SEQ_LOCK(.lock\t= (assoc_lock))\t\t\t\t\\\n}\n\n#define SEQCNT_RAW_SPINLOCK_ZERO(name, lock)\tSEQCOUNT_LOCKNAME_ZERO(name, lock)\n#define SEQCNT_SPINLOCK_ZERO(name, lock)\tSEQCOUNT_LOCKNAME_ZERO(name, lock)\n#define SEQCNT_RWLOCK_ZERO(name, lock)\t\tSEQCOUNT_LOCKNAME_ZERO(name, lock)\n#define SEQCNT_MUTEX_ZERO(name, lock)\t\tSEQCOUNT_LOCKNAME_ZERO(name, lock)\n#define SEQCNT_WW_MUTEX_ZERO(name, lock) \tSEQCOUNT_LOCKNAME_ZERO(name, lock)\n\n#define __seqprop_case(s, lockname, prop)\t\t\t\t\\\n\tseqcount_##lockname##_t: __seqprop_##lockname##_##prop((void *)(s))\n\n#define __seqprop(s, prop) _Generic(*(s),\t\t\t\t\\\n\tseqcount_t:\t\t__seqprop_##prop((void *)(s)),\t\t\\\n\t__seqprop_case((s),\traw_spinlock,\tprop),\t\t\t\\\n\t__seqprop_case((s),\tspinlock,\tprop),\t\t\t\\\n\t__seqprop_case((s),\trwlock,\t\tprop),\t\t\t\\\n\t__seqprop_case((s),\tmutex,\t\tprop))\n\n#define seqprop_ptr(s)\t\t\t__seqprop(s, ptr)\n#define seqprop_sequence(s)\t\t__seqprop(s, sequence)\n#define seqprop_preemptible(s)\t\t__seqprop(s, preemptible)\n#define seqprop_assert(s)\t\t__seqprop(s, assert)\n\n \n#define __read_seqcount_begin(s)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tunsigned __seq;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\twhile ((__seq = seqprop_sequence(s)) & 1)\t\t\t\\\n\t\tcpu_relax();\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tkcsan_atomic_next(KCSAN_SEQLOCK_REGION_MAX);\t\t\t\\\n\t__seq;\t\t\t\t\t\t\t\t\\\n})\n\n \n#define raw_read_seqcount_begin(s)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tunsigned _seq = __read_seqcount_begin(s);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tsmp_rmb();\t\t\t\t\t\t\t\\\n\t_seq;\t\t\t\t\t\t\t\t\\\n})\n\n \n#define read_seqcount_begin(s)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tseqcount_lockdep_reader_access(seqprop_ptr(s));\t\t\t\\\n\traw_read_seqcount_begin(s);\t\t\t\t\t\\\n})\n\n \n#define raw_read_seqcount(s)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tunsigned __seq = seqprop_sequence(s);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tsmp_rmb();\t\t\t\t\t\t\t\\\n\tkcsan_atomic_next(KCSAN_SEQLOCK_REGION_MAX);\t\t\t\\\n\t__seq;\t\t\t\t\t\t\t\t\\\n})\n\n \n#define raw_seqcount_begin(s)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\t\t\\\n\traw_read_seqcount(s) & ~1;\t\t\t\t\t\\\n})\n\n \n#define __read_seqcount_retry(s, start)\t\t\t\t\t\\\n\tdo___read_seqcount_retry(seqprop_ptr(s), start)\n\nstatic inline int do___read_seqcount_retry(const seqcount_t *s, unsigned start)\n{\n\tkcsan_atomic_next(0);\n\treturn unlikely(READ_ONCE(s->sequence) != start);\n}\n\n \n#define read_seqcount_retry(s, start)\t\t\t\t\t\\\n\tdo_read_seqcount_retry(seqprop_ptr(s), start)\n\nstatic inline int do_read_seqcount_retry(const seqcount_t *s, unsigned start)\n{\n\tsmp_rmb();\n\treturn do___read_seqcount_retry(s, start);\n}\n\n \n#define raw_write_seqcount_begin(s)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (seqprop_preemptible(s))\t\t\t\t\t\\\n\t\tpreempt_disable();\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdo_raw_write_seqcount_begin(seqprop_ptr(s));\t\t\t\\\n} while (0)\n\nstatic inline void do_raw_write_seqcount_begin(seqcount_t *s)\n{\n\tkcsan_nestable_atomic_begin();\n\ts->sequence++;\n\tsmp_wmb();\n}\n\n \n#define raw_write_seqcount_end(s)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tdo_raw_write_seqcount_end(seqprop_ptr(s));\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (seqprop_preemptible(s))\t\t\t\t\t\\\n\t\tpreempt_enable();\t\t\t\t\t\\\n} while (0)\n\nstatic inline void do_raw_write_seqcount_end(seqcount_t *s)\n{\n\tsmp_wmb();\n\ts->sequence++;\n\tkcsan_nestable_atomic_end();\n}\n\n \n#define write_seqcount_begin_nested(s, subclass)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tseqprop_assert(s);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (seqprop_preemptible(s))\t\t\t\t\t\\\n\t\tpreempt_disable();\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdo_write_seqcount_begin_nested(seqprop_ptr(s), subclass);\t\\\n} while (0)\n\nstatic inline void do_write_seqcount_begin_nested(seqcount_t *s, int subclass)\n{\n\tseqcount_acquire(&s->dep_map, subclass, 0, _RET_IP_);\n\tdo_raw_write_seqcount_begin(s);\n}\n\n \n#define write_seqcount_begin(s)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tseqprop_assert(s);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (seqprop_preemptible(s))\t\t\t\t\t\\\n\t\tpreempt_disable();\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdo_write_seqcount_begin(seqprop_ptr(s));\t\t\t\\\n} while (0)\n\nstatic inline void do_write_seqcount_begin(seqcount_t *s)\n{\n\tdo_write_seqcount_begin_nested(s, 0);\n}\n\n \n#define write_seqcount_end(s)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tdo_write_seqcount_end(seqprop_ptr(s));\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (seqprop_preemptible(s))\t\t\t\t\t\\\n\t\tpreempt_enable();\t\t\t\t\t\\\n} while (0)\n\nstatic inline void do_write_seqcount_end(seqcount_t *s)\n{\n\tseqcount_release(&s->dep_map, _RET_IP_);\n\tdo_raw_write_seqcount_end(s);\n}\n\n \n#define raw_write_seqcount_barrier(s)\t\t\t\t\t\\\n\tdo_raw_write_seqcount_barrier(seqprop_ptr(s))\n\nstatic inline void do_raw_write_seqcount_barrier(seqcount_t *s)\n{\n\tkcsan_nestable_atomic_begin();\n\ts->sequence++;\n\tsmp_wmb();\n\ts->sequence++;\n\tkcsan_nestable_atomic_end();\n}\n\n \n#define write_seqcount_invalidate(s)\t\t\t\t\t\\\n\tdo_write_seqcount_invalidate(seqprop_ptr(s))\n\nstatic inline void do_write_seqcount_invalidate(seqcount_t *s)\n{\n\tsmp_wmb();\n\tkcsan_nestable_atomic_begin();\n\ts->sequence+=2;\n\tkcsan_nestable_atomic_end();\n}\n\n \ntypedef struct {\n\tseqcount_t seqcount;\n} seqcount_latch_t;\n\n \n#define SEQCNT_LATCH_ZERO(seq_name) {\t\t\t\t\t\\\n\t.seqcount\t\t= SEQCNT_ZERO(seq_name.seqcount),\t\\\n}\n\n \n#define seqcount_latch_init(s) seqcount_init(&(s)->seqcount)\n\n \nstatic __always_inline unsigned raw_read_seqcount_latch(const seqcount_latch_t *s)\n{\n\t \n\treturn READ_ONCE(s->seqcount.sequence);\n}\n\n \nstatic __always_inline int\nraw_read_seqcount_latch_retry(const seqcount_latch_t *s, unsigned start)\n{\n\tsmp_rmb();\n\treturn unlikely(READ_ONCE(s->seqcount.sequence) != start);\n}\n\n \nstatic inline void raw_write_seqcount_latch(seqcount_latch_t *s)\n{\n\tsmp_wmb();\t \n\ts->seqcount.sequence++;\n\tsmp_wmb();       \n}\n\n \ntypedef struct {\n\t \n\tseqcount_spinlock_t seqcount;\n\tspinlock_t lock;\n} seqlock_t;\n\n#define __SEQLOCK_UNLOCKED(lockname)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.seqcount = SEQCNT_SPINLOCK_ZERO(lockname, &(lockname).lock), \\\n\t\t.lock =\t__SPIN_LOCK_UNLOCKED(lockname)\t\t\t\\\n\t}\n\n \n#define seqlock_init(sl)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tspin_lock_init(&(sl)->lock);\t\t\t\t\\\n\t\tseqcount_spinlock_init(&(sl)->seqcount, &(sl)->lock);\t\\\n\t} while (0)\n\n \n#define DEFINE_SEQLOCK(sl) \\\n\t\tseqlock_t sl = __SEQLOCK_UNLOCKED(sl)\n\n \nstatic inline unsigned read_seqbegin(const seqlock_t *sl)\n{\n\tunsigned ret = read_seqcount_begin(&sl->seqcount);\n\n\tkcsan_atomic_next(0);   \n\tkcsan_flat_atomic_begin();\n\treturn ret;\n}\n\n \nstatic inline unsigned read_seqretry(const seqlock_t *sl, unsigned start)\n{\n\t \n\tkcsan_flat_atomic_end();\n\n\treturn read_seqcount_retry(&sl->seqcount, start);\n}\n\n \n\n \nstatic inline void write_seqlock(seqlock_t *sl)\n{\n\tspin_lock(&sl->lock);\n\tdo_write_seqcount_begin(&sl->seqcount.seqcount);\n}\n\n \nstatic inline void write_sequnlock(seqlock_t *sl)\n{\n\tdo_write_seqcount_end(&sl->seqcount.seqcount);\n\tspin_unlock(&sl->lock);\n}\n\n \nstatic inline void write_seqlock_bh(seqlock_t *sl)\n{\n\tspin_lock_bh(&sl->lock);\n\tdo_write_seqcount_begin(&sl->seqcount.seqcount);\n}\n\n \nstatic inline void write_sequnlock_bh(seqlock_t *sl)\n{\n\tdo_write_seqcount_end(&sl->seqcount.seqcount);\n\tspin_unlock_bh(&sl->lock);\n}\n\n \nstatic inline void write_seqlock_irq(seqlock_t *sl)\n{\n\tspin_lock_irq(&sl->lock);\n\tdo_write_seqcount_begin(&sl->seqcount.seqcount);\n}\n\n \nstatic inline void write_sequnlock_irq(seqlock_t *sl)\n{\n\tdo_write_seqcount_end(&sl->seqcount.seqcount);\n\tspin_unlock_irq(&sl->lock);\n}\n\nstatic inline unsigned long __write_seqlock_irqsave(seqlock_t *sl)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sl->lock, flags);\n\tdo_write_seqcount_begin(&sl->seqcount.seqcount);\n\treturn flags;\n}\n\n \n#define write_seqlock_irqsave(lock, flags)\t\t\t\t\\\n\tdo { flags = __write_seqlock_irqsave(lock); } while (0)\n\n \nstatic inline void\nwrite_sequnlock_irqrestore(seqlock_t *sl, unsigned long flags)\n{\n\tdo_write_seqcount_end(&sl->seqcount.seqcount);\n\tspin_unlock_irqrestore(&sl->lock, flags);\n}\n\n \nstatic inline void read_seqlock_excl(seqlock_t *sl)\n{\n\tspin_lock(&sl->lock);\n}\n\n \nstatic inline void read_sequnlock_excl(seqlock_t *sl)\n{\n\tspin_unlock(&sl->lock);\n}\n\n \nstatic inline void read_seqlock_excl_bh(seqlock_t *sl)\n{\n\tspin_lock_bh(&sl->lock);\n}\n\n \nstatic inline void read_sequnlock_excl_bh(seqlock_t *sl)\n{\n\tspin_unlock_bh(&sl->lock);\n}\n\n \nstatic inline void read_seqlock_excl_irq(seqlock_t *sl)\n{\n\tspin_lock_irq(&sl->lock);\n}\n\n \nstatic inline void read_sequnlock_excl_irq(seqlock_t *sl)\n{\n\tspin_unlock_irq(&sl->lock);\n}\n\nstatic inline unsigned long __read_seqlock_excl_irqsave(seqlock_t *sl)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sl->lock, flags);\n\treturn flags;\n}\n\n \n#define read_seqlock_excl_irqsave(lock, flags)\t\t\t\t\\\n\tdo { flags = __read_seqlock_excl_irqsave(lock); } while (0)\n\n \nstatic inline void\nread_sequnlock_excl_irqrestore(seqlock_t *sl, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&sl->lock, flags);\n}\n\n \nstatic inline void read_seqbegin_or_lock(seqlock_t *lock, int *seq)\n{\n\tif (!(*seq & 1))\t \n\t\t*seq = read_seqbegin(lock);\n\telse\t\t\t \n\t\tread_seqlock_excl(lock);\n}\n\n \nstatic inline int need_seqretry(seqlock_t *lock, int seq)\n{\n\treturn !(seq & 1) && read_seqretry(lock, seq);\n}\n\n \nstatic inline void done_seqretry(seqlock_t *lock, int seq)\n{\n\tif (seq & 1)\n\t\tread_sequnlock_excl(lock);\n}\n\n \nstatic inline unsigned long\nread_seqbegin_or_lock_irqsave(seqlock_t *lock, int *seq)\n{\n\tunsigned long flags = 0;\n\n\tif (!(*seq & 1))\t \n\t\t*seq = read_seqbegin(lock);\n\telse\t\t\t \n\t\tread_seqlock_excl_irqsave(lock, flags);\n\n\treturn flags;\n}\n\n \nstatic inline void\ndone_seqretry_irqrestore(seqlock_t *lock, int seq, unsigned long flags)\n{\n\tif (seq & 1)\n\t\tread_sequnlock_excl_irqrestore(lock, flags);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}