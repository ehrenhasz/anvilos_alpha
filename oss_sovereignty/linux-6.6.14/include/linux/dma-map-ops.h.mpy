{
  "module_name": "dma-map-ops.h",
  "hash_id": "47cee33b1c4f875f18c1c3e36bfda6f71fd50858e2b6a29f6408e35b9eb22274",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/dma-map-ops.h",
  "human_readable_source": " \n \n#ifndef _LINUX_DMA_MAP_OPS_H\n#define _LINUX_DMA_MAP_OPS_H\n\n#include <linux/dma-mapping.h>\n#include <linux/pgtable.h>\n#include <linux/slab.h>\n\nstruct cma;\n\n \n#define DMA_F_PCI_P2PDMA_SUPPORTED     (1 << 0)\n\nstruct dma_map_ops {\n\tunsigned int flags;\n\n\tvoid *(*alloc)(struct device *dev, size_t size,\n\t\t\tdma_addr_t *dma_handle, gfp_t gfp,\n\t\t\tunsigned long attrs);\n\tvoid (*free)(struct device *dev, size_t size, void *vaddr,\n\t\t\tdma_addr_t dma_handle, unsigned long attrs);\n\tstruct page *(*alloc_pages)(struct device *dev, size_t size,\n\t\t\tdma_addr_t *dma_handle, enum dma_data_direction dir,\n\t\t\tgfp_t gfp);\n\tvoid (*free_pages)(struct device *dev, size_t size, struct page *vaddr,\n\t\t\tdma_addr_t dma_handle, enum dma_data_direction dir);\n\tstruct sg_table *(*alloc_noncontiguous)(struct device *dev, size_t size,\n\t\t\tenum dma_data_direction dir, gfp_t gfp,\n\t\t\tunsigned long attrs);\n\tvoid (*free_noncontiguous)(struct device *dev, size_t size,\n\t\t\tstruct sg_table *sgt, enum dma_data_direction dir);\n\tint (*mmap)(struct device *, struct vm_area_struct *,\n\t\t\tvoid *, dma_addr_t, size_t, unsigned long attrs);\n\n\tint (*get_sgtable)(struct device *dev, struct sg_table *sgt,\n\t\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\t\tunsigned long attrs);\n\n\tdma_addr_t (*map_page)(struct device *dev, struct page *page,\n\t\t\tunsigned long offset, size_t size,\n\t\t\tenum dma_data_direction dir, unsigned long attrs);\n\tvoid (*unmap_page)(struct device *dev, dma_addr_t dma_handle,\n\t\t\tsize_t size, enum dma_data_direction dir,\n\t\t\tunsigned long attrs);\n\t \n\tint (*map_sg)(struct device *dev, struct scatterlist *sg, int nents,\n\t\t\tenum dma_data_direction dir, unsigned long attrs);\n\tvoid (*unmap_sg)(struct device *dev, struct scatterlist *sg, int nents,\n\t\t\tenum dma_data_direction dir, unsigned long attrs);\n\tdma_addr_t (*map_resource)(struct device *dev, phys_addr_t phys_addr,\n\t\t\tsize_t size, enum dma_data_direction dir,\n\t\t\tunsigned long attrs);\n\tvoid (*unmap_resource)(struct device *dev, dma_addr_t dma_handle,\n\t\t\tsize_t size, enum dma_data_direction dir,\n\t\t\tunsigned long attrs);\n\tvoid (*sync_single_for_cpu)(struct device *dev, dma_addr_t dma_handle,\n\t\t\tsize_t size, enum dma_data_direction dir);\n\tvoid (*sync_single_for_device)(struct device *dev,\n\t\t\tdma_addr_t dma_handle, size_t size,\n\t\t\tenum dma_data_direction dir);\n\tvoid (*sync_sg_for_cpu)(struct device *dev, struct scatterlist *sg,\n\t\t\tint nents, enum dma_data_direction dir);\n\tvoid (*sync_sg_for_device)(struct device *dev, struct scatterlist *sg,\n\t\t\tint nents, enum dma_data_direction dir);\n\tvoid (*cache_sync)(struct device *dev, void *vaddr, size_t size,\n\t\t\tenum dma_data_direction direction);\n\tint (*dma_supported)(struct device *dev, u64 mask);\n\tu64 (*get_required_mask)(struct device *dev);\n\tsize_t (*max_mapping_size)(struct device *dev);\n\tsize_t (*opt_mapping_size)(void);\n\tunsigned long (*get_merge_boundary)(struct device *dev);\n};\n\n#ifdef CONFIG_DMA_OPS\n#include <asm/dma-mapping.h>\n\nstatic inline const struct dma_map_ops *get_dma_ops(struct device *dev)\n{\n\tif (dev->dma_ops)\n\t\treturn dev->dma_ops;\n\treturn get_arch_dma_ops();\n}\n\nstatic inline void set_dma_ops(struct device *dev,\n\t\t\t       const struct dma_map_ops *dma_ops)\n{\n\tdev->dma_ops = dma_ops;\n}\n#else  \nstatic inline const struct dma_map_ops *get_dma_ops(struct device *dev)\n{\n\treturn NULL;\n}\nstatic inline void set_dma_ops(struct device *dev,\n\t\t\t       const struct dma_map_ops *dma_ops)\n{\n}\n#endif  \n\n#ifdef CONFIG_DMA_CMA\nextern struct cma *dma_contiguous_default_area;\n\nstatic inline struct cma *dev_get_cma_area(struct device *dev)\n{\n\tif (dev && dev->cma_area)\n\t\treturn dev->cma_area;\n\treturn dma_contiguous_default_area;\n}\n\nvoid dma_contiguous_reserve(phys_addr_t addr_limit);\nint __init dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t base,\n\t\tphys_addr_t limit, struct cma **res_cma, bool fixed);\n\nstruct page *dma_alloc_from_contiguous(struct device *dev, size_t count,\n\t\t\t\t       unsigned int order, bool no_warn);\nbool dma_release_from_contiguous(struct device *dev, struct page *pages,\n\t\t\t\t int count);\nstruct page *dma_alloc_contiguous(struct device *dev, size_t size, gfp_t gfp);\nvoid dma_free_contiguous(struct device *dev, struct page *page, size_t size);\n\nvoid dma_contiguous_early_fixup(phys_addr_t base, unsigned long size);\n#else  \nstatic inline struct cma *dev_get_cma_area(struct device *dev)\n{\n\treturn NULL;\n}\nstatic inline void dma_contiguous_reserve(phys_addr_t limit)\n{\n}\nstatic inline int dma_contiguous_reserve_area(phys_addr_t size,\n\t\tphys_addr_t base, phys_addr_t limit, struct cma **res_cma,\n\t\tbool fixed)\n{\n\treturn -ENOSYS;\n}\nstatic inline struct page *dma_alloc_from_contiguous(struct device *dev,\n\t\tsize_t count, unsigned int order, bool no_warn)\n{\n\treturn NULL;\n}\nstatic inline bool dma_release_from_contiguous(struct device *dev,\n\t\tstruct page *pages, int count)\n{\n\treturn false;\n}\n \nstatic inline struct page *dma_alloc_contiguous(struct device *dev, size_t size,\n\t\tgfp_t gfp)\n{\n\treturn NULL;\n}\nstatic inline void dma_free_contiguous(struct device *dev, struct page *page,\n\t\tsize_t size)\n{\n\t__free_pages(page, get_order(size));\n}\n#endif  \n\n#ifdef CONFIG_DMA_DECLARE_COHERENT\nint dma_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,\n\t\tdma_addr_t device_addr, size_t size);\nvoid dma_release_coherent_memory(struct device *dev);\nint dma_alloc_from_dev_coherent(struct device *dev, ssize_t size,\n\t\tdma_addr_t *dma_handle, void **ret);\nint dma_release_from_dev_coherent(struct device *dev, int order, void *vaddr);\nint dma_mmap_from_dev_coherent(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, size_t size, int *ret);\n#else\nstatic inline int dma_declare_coherent_memory(struct device *dev,\n\t\tphys_addr_t phys_addr, dma_addr_t device_addr, size_t size)\n{\n\treturn -ENOSYS;\n}\n\n#define dma_alloc_from_dev_coherent(dev, size, handle, ret) (0)\n#define dma_release_from_dev_coherent(dev, order, vaddr) (0)\n#define dma_mmap_from_dev_coherent(dev, vma, vaddr, order, ret) (0)\nstatic inline void dma_release_coherent_memory(struct device *dev) { }\n#endif  \n\n#ifdef CONFIG_DMA_GLOBAL_POOL\nvoid *dma_alloc_from_global_coherent(struct device *dev, ssize_t size,\n\t\tdma_addr_t *dma_handle);\nint dma_release_from_global_coherent(int order, void *vaddr);\nint dma_mmap_from_global_coherent(struct vm_area_struct *vma, void *cpu_addr,\n\t\tsize_t size, int *ret);\nint dma_init_global_coherent(phys_addr_t phys_addr, size_t size);\n#else\nstatic inline void *dma_alloc_from_global_coherent(struct device *dev,\n\t\tssize_t size, dma_addr_t *dma_handle)\n{\n\treturn NULL;\n}\nstatic inline int dma_release_from_global_coherent(int order, void *vaddr)\n{\n\treturn 0;\n}\nstatic inline int dma_mmap_from_global_coherent(struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, size_t size, int *ret)\n{\n\treturn 0;\n}\n#endif  \n\n \nstruct dma_sgt_handle {\n\tstruct sg_table sgt;\n\tstruct page **pages;\n};\n#define sgt_handle(sgt) \\\n\tcontainer_of((sgt), struct dma_sgt_handle, sgt)\n\nint dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs);\nint dma_common_mmap(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs);\nstruct page *dma_common_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp);\nvoid dma_common_free_pages(struct device *dev, size_t size, struct page *vaddr,\n\t\tdma_addr_t dma_handle, enum dma_data_direction dir);\n\nstruct page **dma_common_find_pages(void *cpu_addr);\nvoid *dma_common_contiguous_remap(struct page *page, size_t size, pgprot_t prot,\n\t\tconst void *caller);\nvoid *dma_common_pages_remap(struct page **pages, size_t size, pgprot_t prot,\n\t\tconst void *caller);\nvoid dma_common_free_remap(void *cpu_addr, size_t size);\n\nstruct page *dma_alloc_from_pool(struct device *dev, size_t size,\n\t\tvoid **cpu_addr, gfp_t flags,\n\t\tbool (*phys_addr_ok)(struct device *, phys_addr_t, size_t));\nbool dma_free_from_pool(struct device *dev, void *start, size_t size);\n\nint dma_direct_set_offset(struct device *dev, phys_addr_t cpu_start,\n\t\tdma_addr_t dma_start, u64 size);\n\n#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \\\n\tdefined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \\\n\tdefined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)\nextern bool dma_default_coherent;\nstatic inline bool dev_is_dma_coherent(struct device *dev)\n{\n\treturn dev->dma_coherent;\n}\n#else\n#define dma_default_coherent true\n\nstatic inline bool dev_is_dma_coherent(struct device *dev)\n{\n\treturn true;\n}\n#endif  \n\n \nstatic inline bool dma_kmalloc_safe(struct device *dev,\n\t\t\t\t    enum dma_data_direction dir)\n{\n\t \n\tif (!IS_ENABLED(CONFIG_DMA_BOUNCE_UNALIGNED_KMALLOC))\n\t\treturn true;\n\n\t \n\tif (dev_is_dma_coherent(dev) || dir == DMA_TO_DEVICE)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic inline bool dma_kmalloc_size_aligned(size_t size)\n{\n\t \n\tif (size >= 2 * ARCH_DMA_MINALIGN ||\n\t    IS_ALIGNED(kmalloc_size_roundup(size), dma_get_cache_alignment()))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic inline bool dma_kmalloc_needs_bounce(struct device *dev, size_t size,\n\t\t\t\t\t    enum dma_data_direction dir)\n{\n\treturn !dma_kmalloc_safe(dev, dir) && !dma_kmalloc_size_aligned(size);\n}\n\nvoid *arch_dma_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,\n\t\tgfp_t gfp, unsigned long attrs);\nvoid arch_dma_free(struct device *dev, size_t size, void *cpu_addr,\n\t\tdma_addr_t dma_addr, unsigned long attrs);\n\n#ifdef CONFIG_ARCH_HAS_DMA_SET_MASK\nvoid arch_dma_set_mask(struct device *dev, u64 mask);\n#else\n#define arch_dma_set_mask(dev, mask)\tdo { } while (0)\n#endif\n\n#ifdef CONFIG_MMU\n \n#ifndef pgprot_dmacoherent\n#define pgprot_dmacoherent(prot)\tpgprot_noncached(prot)\n#endif\n\npgprot_t dma_pgprot(struct device *dev, pgprot_t prot, unsigned long attrs);\n#else\nstatic inline pgprot_t dma_pgprot(struct device *dev, pgprot_t prot,\n\t\tunsigned long attrs)\n{\n\treturn prot;\t \n}\n#endif  \n\n#ifdef CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE\nvoid arch_sync_dma_for_device(phys_addr_t paddr, size_t size,\n\t\tenum dma_data_direction dir);\n#else\nstatic inline void arch_sync_dma_for_device(phys_addr_t paddr, size_t size,\n\t\tenum dma_data_direction dir)\n{\n}\n#endif  \n\n#ifdef CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU\nvoid arch_sync_dma_for_cpu(phys_addr_t paddr, size_t size,\n\t\tenum dma_data_direction dir);\n#else\nstatic inline void arch_sync_dma_for_cpu(phys_addr_t paddr, size_t size,\n\t\tenum dma_data_direction dir)\n{\n}\n#endif  \n\n#ifdef CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL\nvoid arch_sync_dma_for_cpu_all(void);\n#else\nstatic inline void arch_sync_dma_for_cpu_all(void)\n{\n}\n#endif  \n\n#ifdef CONFIG_ARCH_HAS_DMA_PREP_COHERENT\nvoid arch_dma_prep_coherent(struct page *page, size_t size);\n#else\nstatic inline void arch_dma_prep_coherent(struct page *page, size_t size)\n{\n}\n#endif  \n\n#ifdef CONFIG_ARCH_HAS_DMA_MARK_CLEAN\nvoid arch_dma_mark_clean(phys_addr_t paddr, size_t size);\n#else\nstatic inline void arch_dma_mark_clean(phys_addr_t paddr, size_t size)\n{\n}\n#endif  \n\nvoid *arch_dma_set_uncached(void *addr, size_t size);\nvoid arch_dma_clear_uncached(void *addr, size_t size);\n\n#ifdef CONFIG_ARCH_HAS_DMA_MAP_DIRECT\nbool arch_dma_map_page_direct(struct device *dev, phys_addr_t addr);\nbool arch_dma_unmap_page_direct(struct device *dev, dma_addr_t dma_handle);\nbool arch_dma_map_sg_direct(struct device *dev, struct scatterlist *sg,\n\t\tint nents);\nbool arch_dma_unmap_sg_direct(struct device *dev, struct scatterlist *sg,\n\t\tint nents);\n#else\n#define arch_dma_map_page_direct(d, a)\t\t(false)\n#define arch_dma_unmap_page_direct(d, a)\t(false)\n#define arch_dma_map_sg_direct(d, s, n)\t\t(false)\n#define arch_dma_unmap_sg_direct(d, s, n)\t(false)\n#endif\n\n#ifdef CONFIG_ARCH_HAS_SETUP_DMA_OPS\nvoid arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,\n\t\tconst struct iommu_ops *iommu, bool coherent);\n#else\nstatic inline void arch_setup_dma_ops(struct device *dev, u64 dma_base,\n\t\tu64 size, const struct iommu_ops *iommu, bool coherent)\n{\n}\n#endif  \n\n#ifdef CONFIG_ARCH_HAS_TEARDOWN_DMA_OPS\nvoid arch_teardown_dma_ops(struct device *dev);\n#else\nstatic inline void arch_teardown_dma_ops(struct device *dev)\n{\n}\n#endif  \n\n#ifdef CONFIG_DMA_API_DEBUG\nvoid dma_debug_add_bus(struct bus_type *bus);\nvoid debug_dma_dump_mappings(struct device *dev);\n#else\nstatic inline void dma_debug_add_bus(struct bus_type *bus)\n{\n}\nstatic inline void debug_dma_dump_mappings(struct device *dev)\n{\n}\n#endif  \n\nextern const struct dma_map_ops dma_dummy_ops;\n\nenum pci_p2pdma_map_type {\n\t \n\tPCI_P2PDMA_MAP_UNKNOWN = 0,\n\n\t \n\tPCI_P2PDMA_MAP_NOT_SUPPORTED,\n\n\t \n\tPCI_P2PDMA_MAP_BUS_ADDR,\n\n\t \n\tPCI_P2PDMA_MAP_THRU_HOST_BRIDGE,\n};\n\nstruct pci_p2pdma_map_state {\n\tstruct dev_pagemap *pgmap;\n\tint map;\n\tu64 bus_off;\n};\n\n#ifdef CONFIG_PCI_P2PDMA\nenum pci_p2pdma_map_type\npci_p2pdma_map_segment(struct pci_p2pdma_map_state *state, struct device *dev,\n\t\t       struct scatterlist *sg);\n#else  \nstatic inline enum pci_p2pdma_map_type\npci_p2pdma_map_segment(struct pci_p2pdma_map_state *state, struct device *dev,\n\t\t       struct scatterlist *sg)\n{\n\treturn PCI_P2PDMA_MAP_NOT_SUPPORTED;\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}