{
  "module_name": "bitmap.h",
  "hash_id": "7829870c9ac5a4b6d4429ee3725f081db0d73a8d2c5e3956f50f6ad097a48651",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/bitmap.h",
  "human_readable_source": " \n#ifndef __LINUX_BITMAP_H\n#define __LINUX_BITMAP_H\n\n#ifndef __ASSEMBLY__\n\n#include <linux/align.h>\n#include <linux/bitops.h>\n#include <linux/find.h>\n#include <linux/limits.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct device;\n\n \n\n \n\n \n\n \n\n \nunsigned long *bitmap_alloc(unsigned int nbits, gfp_t flags);\nunsigned long *bitmap_zalloc(unsigned int nbits, gfp_t flags);\nunsigned long *bitmap_alloc_node(unsigned int nbits, gfp_t flags, int node);\nunsigned long *bitmap_zalloc_node(unsigned int nbits, gfp_t flags, int node);\nvoid bitmap_free(const unsigned long *bitmap);\n\n \nunsigned long *devm_bitmap_alloc(struct device *dev,\n\t\t\t\t unsigned int nbits, gfp_t flags);\nunsigned long *devm_bitmap_zalloc(struct device *dev,\n\t\t\t\t  unsigned int nbits, gfp_t flags);\n\n \n\nbool __bitmap_equal(const unsigned long *bitmap1,\n\t\t    const unsigned long *bitmap2, unsigned int nbits);\nbool __pure __bitmap_or_equal(const unsigned long *src1,\n\t\t\t      const unsigned long *src2,\n\t\t\t      const unsigned long *src3,\n\t\t\t      unsigned int nbits);\nvoid __bitmap_complement(unsigned long *dst, const unsigned long *src,\n\t\t\t unsigned int nbits);\nvoid __bitmap_shift_right(unsigned long *dst, const unsigned long *src,\n\t\t\t  unsigned int shift, unsigned int nbits);\nvoid __bitmap_shift_left(unsigned long *dst, const unsigned long *src,\n\t\t\t unsigned int shift, unsigned int nbits);\nvoid bitmap_cut(unsigned long *dst, const unsigned long *src,\n\t\tunsigned int first, unsigned int cut, unsigned int nbits);\nbool __bitmap_and(unsigned long *dst, const unsigned long *bitmap1,\n\t\t const unsigned long *bitmap2, unsigned int nbits);\nvoid __bitmap_or(unsigned long *dst, const unsigned long *bitmap1,\n\t\t const unsigned long *bitmap2, unsigned int nbits);\nvoid __bitmap_xor(unsigned long *dst, const unsigned long *bitmap1,\n\t\t  const unsigned long *bitmap2, unsigned int nbits);\nbool __bitmap_andnot(unsigned long *dst, const unsigned long *bitmap1,\n\t\t    const unsigned long *bitmap2, unsigned int nbits);\nvoid __bitmap_replace(unsigned long *dst,\n\t\t      const unsigned long *old, const unsigned long *new,\n\t\t      const unsigned long *mask, unsigned int nbits);\nbool __bitmap_intersects(const unsigned long *bitmap1,\n\t\t\t const unsigned long *bitmap2, unsigned int nbits);\nbool __bitmap_subset(const unsigned long *bitmap1,\n\t\t     const unsigned long *bitmap2, unsigned int nbits);\nunsigned int __bitmap_weight(const unsigned long *bitmap, unsigned int nbits);\nunsigned int __bitmap_weight_and(const unsigned long *bitmap1,\n\t\t\t\t const unsigned long *bitmap2, unsigned int nbits);\nvoid __bitmap_set(unsigned long *map, unsigned int start, int len);\nvoid __bitmap_clear(unsigned long *map, unsigned int start, int len);\n\nunsigned long bitmap_find_next_zero_area_off(unsigned long *map,\n\t\t\t\t\t     unsigned long size,\n\t\t\t\t\t     unsigned long start,\n\t\t\t\t\t     unsigned int nr,\n\t\t\t\t\t     unsigned long align_mask,\n\t\t\t\t\t     unsigned long align_offset);\n\n \nstatic inline unsigned long\nbitmap_find_next_zero_area(unsigned long *map,\n\t\t\t   unsigned long size,\n\t\t\t   unsigned long start,\n\t\t\t   unsigned int nr,\n\t\t\t   unsigned long align_mask)\n{\n\treturn bitmap_find_next_zero_area_off(map, size, start, nr,\n\t\t\t\t\t      align_mask, 0);\n}\n\nint bitmap_parse(const char *buf, unsigned int buflen,\n\t\t\tunsigned long *dst, int nbits);\nint bitmap_parse_user(const char __user *ubuf, unsigned int ulen,\n\t\t\tunsigned long *dst, int nbits);\nint bitmap_parselist(const char *buf, unsigned long *maskp,\n\t\t\tint nmaskbits);\nint bitmap_parselist_user(const char __user *ubuf, unsigned int ulen,\n\t\t\tunsigned long *dst, int nbits);\nvoid bitmap_remap(unsigned long *dst, const unsigned long *src,\n\t\tconst unsigned long *old, const unsigned long *new, unsigned int nbits);\nint bitmap_bitremap(int oldbit,\n\t\tconst unsigned long *old, const unsigned long *new, int bits);\nvoid bitmap_onto(unsigned long *dst, const unsigned long *orig,\n\t\tconst unsigned long *relmap, unsigned int bits);\nvoid bitmap_fold(unsigned long *dst, const unsigned long *orig,\n\t\tunsigned int sz, unsigned int nbits);\nint bitmap_find_free_region(unsigned long *bitmap, unsigned int bits, int order);\nvoid bitmap_release_region(unsigned long *bitmap, unsigned int pos, int order);\nint bitmap_allocate_region(unsigned long *bitmap, unsigned int pos, int order);\n\n#ifdef __BIG_ENDIAN\nvoid bitmap_copy_le(unsigned long *dst, const unsigned long *src, unsigned int nbits);\n#else\n#define bitmap_copy_le bitmap_copy\n#endif\nint bitmap_print_to_pagebuf(bool list, char *buf,\n\t\t\t\t   const unsigned long *maskp, int nmaskbits);\n\nextern int bitmap_print_bitmask_to_buf(char *buf, const unsigned long *maskp,\n\t\t\t\t      int nmaskbits, loff_t off, size_t count);\n\nextern int bitmap_print_list_to_buf(char *buf, const unsigned long *maskp,\n\t\t\t\t      int nmaskbits, loff_t off, size_t count);\n\n#define BITMAP_FIRST_WORD_MASK(start) (~0UL << ((start) & (BITS_PER_LONG - 1)))\n#define BITMAP_LAST_WORD_MASK(nbits) (~0UL >> (-(nbits) & (BITS_PER_LONG - 1)))\n\nstatic inline void bitmap_zero(unsigned long *dst, unsigned int nbits)\n{\n\tunsigned int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);\n\n\tif (small_const_nbits(nbits))\n\t\t*dst = 0;\n\telse\n\t\tmemset(dst, 0, len);\n}\n\nstatic inline void bitmap_fill(unsigned long *dst, unsigned int nbits)\n{\n\tunsigned int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);\n\n\tif (small_const_nbits(nbits))\n\t\t*dst = ~0UL;\n\telse\n\t\tmemset(dst, 0xff, len);\n}\n\nstatic inline void bitmap_copy(unsigned long *dst, const unsigned long *src,\n\t\t\tunsigned int nbits)\n{\n\tunsigned int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);\n\n\tif (small_const_nbits(nbits))\n\t\t*dst = *src;\n\telse\n\t\tmemcpy(dst, src, len);\n}\n\n \nstatic inline void bitmap_copy_clear_tail(unsigned long *dst,\n\t\tconst unsigned long *src, unsigned int nbits)\n{\n\tbitmap_copy(dst, src, nbits);\n\tif (nbits % BITS_PER_LONG)\n\t\tdst[nbits / BITS_PER_LONG] &= BITMAP_LAST_WORD_MASK(nbits);\n}\n\n \n#if BITS_PER_LONG == 64\nvoid bitmap_from_arr32(unsigned long *bitmap, const u32 *buf,\n\t\t\t\t\t\t\tunsigned int nbits);\nvoid bitmap_to_arr32(u32 *buf, const unsigned long *bitmap,\n\t\t\t\t\t\t\tunsigned int nbits);\n#else\n#define bitmap_from_arr32(bitmap, buf, nbits)\t\t\t\\\n\tbitmap_copy_clear_tail((unsigned long *) (bitmap),\t\\\n\t\t\t(const unsigned long *) (buf), (nbits))\n#define bitmap_to_arr32(buf, bitmap, nbits)\t\t\t\\\n\tbitmap_copy_clear_tail((unsigned long *) (buf),\t\t\\\n\t\t\t(const unsigned long *) (bitmap), (nbits))\n#endif\n\n \n#if BITS_PER_LONG == 32\nvoid bitmap_from_arr64(unsigned long *bitmap, const u64 *buf, unsigned int nbits);\nvoid bitmap_to_arr64(u64 *buf, const unsigned long *bitmap, unsigned int nbits);\n#else\n#define bitmap_from_arr64(bitmap, buf, nbits)\t\t\t\\\n\tbitmap_copy_clear_tail((unsigned long *)(bitmap), (const unsigned long *)(buf), (nbits))\n#define bitmap_to_arr64(buf, bitmap, nbits)\t\t\t\\\n\tbitmap_copy_clear_tail((unsigned long *)(buf), (const unsigned long *)(bitmap), (nbits))\n#endif\n\nstatic inline bool bitmap_and(unsigned long *dst, const unsigned long *src1,\n\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn (*dst = *src1 & *src2 & BITMAP_LAST_WORD_MASK(nbits)) != 0;\n\treturn __bitmap_and(dst, src1, src2, nbits);\n}\n\nstatic inline void bitmap_or(unsigned long *dst, const unsigned long *src1,\n\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = *src1 | *src2;\n\telse\n\t\t__bitmap_or(dst, src1, src2, nbits);\n}\n\nstatic inline void bitmap_xor(unsigned long *dst, const unsigned long *src1,\n\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = *src1 ^ *src2;\n\telse\n\t\t__bitmap_xor(dst, src1, src2, nbits);\n}\n\nstatic inline bool bitmap_andnot(unsigned long *dst, const unsigned long *src1,\n\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn (*dst = *src1 & ~(*src2) & BITMAP_LAST_WORD_MASK(nbits)) != 0;\n\treturn __bitmap_andnot(dst, src1, src2, nbits);\n}\n\nstatic inline void bitmap_complement(unsigned long *dst, const unsigned long *src,\n\t\t\tunsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = ~(*src);\n\telse\n\t\t__bitmap_complement(dst, src, nbits);\n}\n\n#ifdef __LITTLE_ENDIAN\n#define BITMAP_MEM_ALIGNMENT 8\n#else\n#define BITMAP_MEM_ALIGNMENT (8 * sizeof(unsigned long))\n#endif\n#define BITMAP_MEM_MASK (BITMAP_MEM_ALIGNMENT - 1)\n\nstatic inline bool bitmap_equal(const unsigned long *src1,\n\t\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn !((*src1 ^ *src2) & BITMAP_LAST_WORD_MASK(nbits));\n\tif (__builtin_constant_p(nbits & BITMAP_MEM_MASK) &&\n\t    IS_ALIGNED(nbits, BITMAP_MEM_ALIGNMENT))\n\t\treturn !memcmp(src1, src2, nbits / 8);\n\treturn __bitmap_equal(src1, src2, nbits);\n}\n\n \nstatic inline bool bitmap_or_equal(const unsigned long *src1,\n\t\t\t\t   const unsigned long *src2,\n\t\t\t\t   const unsigned long *src3,\n\t\t\t\t   unsigned int nbits)\n{\n\tif (!small_const_nbits(nbits))\n\t\treturn __bitmap_or_equal(src1, src2, src3, nbits);\n\n\treturn !(((*src1 | *src2) ^ *src3) & BITMAP_LAST_WORD_MASK(nbits));\n}\n\nstatic inline bool bitmap_intersects(const unsigned long *src1,\n\t\t\t\t     const unsigned long *src2,\n\t\t\t\t     unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn ((*src1 & *src2) & BITMAP_LAST_WORD_MASK(nbits)) != 0;\n\telse\n\t\treturn __bitmap_intersects(src1, src2, nbits);\n}\n\nstatic inline bool bitmap_subset(const unsigned long *src1,\n\t\t\t\t const unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn ! ((*src1 & ~(*src2)) & BITMAP_LAST_WORD_MASK(nbits));\n\telse\n\t\treturn __bitmap_subset(src1, src2, nbits);\n}\n\nstatic inline bool bitmap_empty(const unsigned long *src, unsigned nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn ! (*src & BITMAP_LAST_WORD_MASK(nbits));\n\n\treturn find_first_bit(src, nbits) == nbits;\n}\n\nstatic inline bool bitmap_full(const unsigned long *src, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn ! (~(*src) & BITMAP_LAST_WORD_MASK(nbits));\n\n\treturn find_first_zero_bit(src, nbits) == nbits;\n}\n\nstatic __always_inline\nunsigned int bitmap_weight(const unsigned long *src, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn hweight_long(*src & BITMAP_LAST_WORD_MASK(nbits));\n\treturn __bitmap_weight(src, nbits);\n}\n\nstatic __always_inline\nunsigned long bitmap_weight_and(const unsigned long *src1,\n\t\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn hweight_long(*src1 & *src2 & BITMAP_LAST_WORD_MASK(nbits));\n\treturn __bitmap_weight_and(src1, src2, nbits);\n}\n\nstatic __always_inline void bitmap_set(unsigned long *map, unsigned int start,\n\t\tunsigned int nbits)\n{\n\tif (__builtin_constant_p(nbits) && nbits == 1)\n\t\t__set_bit(start, map);\n\telse if (small_const_nbits(start + nbits))\n\t\t*map |= GENMASK(start + nbits - 1, start);\n\telse if (__builtin_constant_p(start & BITMAP_MEM_MASK) &&\n\t\t IS_ALIGNED(start, BITMAP_MEM_ALIGNMENT) &&\n\t\t __builtin_constant_p(nbits & BITMAP_MEM_MASK) &&\n\t\t IS_ALIGNED(nbits, BITMAP_MEM_ALIGNMENT))\n\t\tmemset((char *)map + start / 8, 0xff, nbits / 8);\n\telse\n\t\t__bitmap_set(map, start, nbits);\n}\n\nstatic __always_inline void bitmap_clear(unsigned long *map, unsigned int start,\n\t\tunsigned int nbits)\n{\n\tif (__builtin_constant_p(nbits) && nbits == 1)\n\t\t__clear_bit(start, map);\n\telse if (small_const_nbits(start + nbits))\n\t\t*map &= ~GENMASK(start + nbits - 1, start);\n\telse if (__builtin_constant_p(start & BITMAP_MEM_MASK) &&\n\t\t IS_ALIGNED(start, BITMAP_MEM_ALIGNMENT) &&\n\t\t __builtin_constant_p(nbits & BITMAP_MEM_MASK) &&\n\t\t IS_ALIGNED(nbits, BITMAP_MEM_ALIGNMENT))\n\t\tmemset((char *)map + start / 8, 0, nbits / 8);\n\telse\n\t\t__bitmap_clear(map, start, nbits);\n}\n\nstatic inline void bitmap_shift_right(unsigned long *dst, const unsigned long *src,\n\t\t\t\tunsigned int shift, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = (*src & BITMAP_LAST_WORD_MASK(nbits)) >> shift;\n\telse\n\t\t__bitmap_shift_right(dst, src, shift, nbits);\n}\n\nstatic inline void bitmap_shift_left(unsigned long *dst, const unsigned long *src,\n\t\t\t\tunsigned int shift, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = (*src << shift) & BITMAP_LAST_WORD_MASK(nbits);\n\telse\n\t\t__bitmap_shift_left(dst, src, shift, nbits);\n}\n\nstatic inline void bitmap_replace(unsigned long *dst,\n\t\t\t\t  const unsigned long *old,\n\t\t\t\t  const unsigned long *new,\n\t\t\t\t  const unsigned long *mask,\n\t\t\t\t  unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = (*old & ~(*mask)) | (*new & *mask);\n\telse\n\t\t__bitmap_replace(dst, old, new, mask, nbits);\n}\n\nstatic inline void bitmap_next_set_region(unsigned long *bitmap,\n\t\t\t\t\t  unsigned int *rs, unsigned int *re,\n\t\t\t\t\t  unsigned int end)\n{\n\t*rs = find_next_bit(bitmap, end, *rs);\n\t*re = find_next_zero_bit(bitmap, end, *rs + 1);\n}\n\n \n#if __BITS_PER_LONG == 64\n#define BITMAP_FROM_U64(n) (n)\n#else\n#define BITMAP_FROM_U64(n) ((unsigned long) ((u64)(n) & ULONG_MAX)), \\\n\t\t\t\t((unsigned long) ((u64)(n) >> 32))\n#endif\n\n \nstatic inline void bitmap_from_u64(unsigned long *dst, u64 mask)\n{\n\tbitmap_from_arr64(dst, &mask, 64);\n}\n\n \nstatic inline unsigned long bitmap_get_value8(const unsigned long *map,\n\t\t\t\t\t      unsigned long start)\n{\n\tconst size_t index = BIT_WORD(start);\n\tconst unsigned long offset = start % BITS_PER_LONG;\n\n\treturn (map[index] >> offset) & 0xFF;\n}\n\n \nstatic inline void bitmap_set_value8(unsigned long *map, unsigned long value,\n\t\t\t\t     unsigned long start)\n{\n\tconst size_t index = BIT_WORD(start);\n\tconst unsigned long offset = start % BITS_PER_LONG;\n\n\tmap[index] &= ~(0xFFUL << offset);\n\tmap[index] |= value << offset;\n}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}