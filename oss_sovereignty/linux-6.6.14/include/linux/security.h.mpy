{
  "module_name": "security.h",
  "hash_id": "e7597e2718ee4027f0cd950f78e6d7f7fa41eead812cf1ec723e03abd3220087",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/security.h",
  "human_readable_source": " \n\n#ifndef __LINUX_SECURITY_H\n#define __LINUX_SECURITY_H\n\n#include <linux/kernel_read_file.h>\n#include <linux/key.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/sockptr.h>\n\nstruct linux_binprm;\nstruct cred;\nstruct rlimit;\nstruct kernel_siginfo;\nstruct sembuf;\nstruct kern_ipc_perm;\nstruct audit_context;\nstruct super_block;\nstruct inode;\nstruct dentry;\nstruct file;\nstruct vfsmount;\nstruct path;\nstruct qstr;\nstruct iattr;\nstruct fown_struct;\nstruct file_operations;\nstruct msg_msg;\nstruct xattr;\nstruct kernfs_node;\nstruct xfrm_sec_ctx;\nstruct mm_struct;\nstruct fs_context;\nstruct fs_parameter;\nenum fs_value_type;\nstruct watch;\nstruct watch_notification;\n\n \n#define CAP_OPT_NONE 0x0\n \n#define CAP_OPT_NOAUDIT BIT(1)\n \n#define CAP_OPT_INSETID BIT(2)\n\n \n#define SECURITY_LSM_NATIVE_LABELS\t1\n\nstruct ctl_table;\nstruct audit_krule;\nstruct user_namespace;\nstruct timezone;\n\nenum lsm_event {\n\tLSM_POLICY_CHANGE,\n};\n\n \nenum lockdown_reason {\n\tLOCKDOWN_NONE,\n\tLOCKDOWN_MODULE_SIGNATURE,\n\tLOCKDOWN_DEV_MEM,\n\tLOCKDOWN_EFI_TEST,\n\tLOCKDOWN_KEXEC,\n\tLOCKDOWN_HIBERNATION,\n\tLOCKDOWN_PCI_ACCESS,\n\tLOCKDOWN_IOPORT,\n\tLOCKDOWN_MSR,\n\tLOCKDOWN_ACPI_TABLES,\n\tLOCKDOWN_DEVICE_TREE,\n\tLOCKDOWN_PCMCIA_CIS,\n\tLOCKDOWN_TIOCSSERIAL,\n\tLOCKDOWN_MODULE_PARAMETERS,\n\tLOCKDOWN_MMIOTRACE,\n\tLOCKDOWN_DEBUGFS,\n\tLOCKDOWN_XMON_WR,\n\tLOCKDOWN_BPF_WRITE_USER,\n\tLOCKDOWN_DBG_WRITE_KERNEL,\n\tLOCKDOWN_RTAS_ERROR_INJECTION,\n\tLOCKDOWN_INTEGRITY_MAX,\n\tLOCKDOWN_KCORE,\n\tLOCKDOWN_KPROBES,\n\tLOCKDOWN_BPF_READ_KERNEL,\n\tLOCKDOWN_DBG_READ_KERNEL,\n\tLOCKDOWN_PERF,\n\tLOCKDOWN_TRACEFS,\n\tLOCKDOWN_XMON_RW,\n\tLOCKDOWN_XFRM_SECRET,\n\tLOCKDOWN_CONFIDENTIALITY_MAX,\n};\n\nextern const char *const lockdown_reasons[LOCKDOWN_CONFIDENTIALITY_MAX+1];\n\n \nextern int cap_capable(const struct cred *cred, struct user_namespace *ns,\n\t\t       int cap, unsigned int opts);\nextern int cap_settime(const struct timespec64 *ts, const struct timezone *tz);\nextern int cap_ptrace_access_check(struct task_struct *child, unsigned int mode);\nextern int cap_ptrace_traceme(struct task_struct *parent);\nextern int cap_capget(const struct task_struct *target, kernel_cap_t *effective,\n\t\t      kernel_cap_t *inheritable, kernel_cap_t *permitted);\nextern int cap_capset(struct cred *new, const struct cred *old,\n\t\t      const kernel_cap_t *effective,\n\t\t      const kernel_cap_t *inheritable,\n\t\t      const kernel_cap_t *permitted);\nextern int cap_bprm_creds_from_file(struct linux_binprm *bprm, struct file *file);\nint cap_inode_setxattr(struct dentry *dentry, const char *name,\n\t\t       const void *value, size_t size, int flags);\nint cap_inode_removexattr(struct mnt_idmap *idmap,\n\t\t\t  struct dentry *dentry, const char *name);\nint cap_inode_need_killpriv(struct dentry *dentry);\nint cap_inode_killpriv(struct mnt_idmap *idmap, struct dentry *dentry);\nint cap_inode_getsecurity(struct mnt_idmap *idmap,\n\t\t\t  struct inode *inode, const char *name, void **buffer,\n\t\t\t  bool alloc);\nextern int cap_mmap_addr(unsigned long addr);\nextern int cap_mmap_file(struct file *file, unsigned long reqprot,\n\t\t\t unsigned long prot, unsigned long flags);\nextern int cap_task_fix_setuid(struct cred *new, const struct cred *old, int flags);\nextern int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t\t  unsigned long arg4, unsigned long arg5);\nextern int cap_task_setscheduler(struct task_struct *p);\nextern int cap_task_setioprio(struct task_struct *p, int ioprio);\nextern int cap_task_setnice(struct task_struct *p, int nice);\nextern int cap_vm_enough_memory(struct mm_struct *mm, long pages);\n\nstruct msghdr;\nstruct sk_buff;\nstruct sock;\nstruct sockaddr;\nstruct socket;\nstruct flowi_common;\nstruct dst_entry;\nstruct xfrm_selector;\nstruct xfrm_policy;\nstruct xfrm_state;\nstruct xfrm_user_sec_ctx;\nstruct seq_file;\nstruct sctp_association;\n\n#ifdef CONFIG_MMU\nextern unsigned long mmap_min_addr;\nextern unsigned long dac_mmap_min_addr;\n#else\n#define mmap_min_addr\t\t0UL\n#define dac_mmap_min_addr\t0UL\n#endif\n\n \n \n#define LSM_SETID_ID\t1\n\n \n#define LSM_SETID_RE\t2\n\n \n#define LSM_SETID_RES\t4\n\n \n#define LSM_SETID_FS\t8\n\n \n#define LSM_PRLIMIT_READ  1\n#define LSM_PRLIMIT_WRITE 2\n\n \nstruct sched_param;\nstruct request_sock;\n\n \n#define LSM_UNSAFE_SHARE\t1\n#define LSM_UNSAFE_PTRACE\t2\n#define LSM_UNSAFE_NO_NEW_PRIVS\t4\n\n#ifdef CONFIG_MMU\nextern int mmap_min_addr_handler(struct ctl_table *table, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos);\n#endif\n\n \ntypedef int (*initxattrs) (struct inode *inode,\n\t\t\t   const struct xattr *xattr_array, void *fs_data);\n\n\n \n#define __data_id_enumify(ENUM, dummy) LOADING_ ## ENUM,\n#define __data_id_stringify(dummy, str) #str,\n\nenum kernel_load_data_id {\n\t__kernel_read_file_id(__data_id_enumify)\n};\n\nstatic const char * const kernel_load_data_str[] = {\n\t__kernel_read_file_id(__data_id_stringify)\n};\n\nstatic inline const char *kernel_load_data_id_str(enum kernel_load_data_id id)\n{\n\tif ((unsigned)id >= LOADING_MAX_ID)\n\t\treturn kernel_load_data_str[LOADING_UNKNOWN];\n\n\treturn kernel_load_data_str[id];\n}\n\n#ifdef CONFIG_SECURITY\n\nint call_blocking_lsm_notifier(enum lsm_event event, void *data);\nint register_blocking_lsm_notifier(struct notifier_block *nb);\nint unregister_blocking_lsm_notifier(struct notifier_block *nb);\n\n \nextern int security_init(void);\nextern int early_security_init(void);\n\n \nint security_binder_set_context_mgr(const struct cred *mgr);\nint security_binder_transaction(const struct cred *from,\n\t\t\t\tconst struct cred *to);\nint security_binder_transfer_binder(const struct cred *from,\n\t\t\t\t    const struct cred *to);\nint security_binder_transfer_file(const struct cred *from,\n\t\t\t\t  const struct cred *to, const struct file *file);\nint security_ptrace_access_check(struct task_struct *child, unsigned int mode);\nint security_ptrace_traceme(struct task_struct *parent);\nint security_capget(const struct task_struct *target,\n\t\t    kernel_cap_t *effective,\n\t\t    kernel_cap_t *inheritable,\n\t\t    kernel_cap_t *permitted);\nint security_capset(struct cred *new, const struct cred *old,\n\t\t    const kernel_cap_t *effective,\n\t\t    const kernel_cap_t *inheritable,\n\t\t    const kernel_cap_t *permitted);\nint security_capable(const struct cred *cred,\n\t\t       struct user_namespace *ns,\n\t\t       int cap,\n\t\t       unsigned int opts);\nint security_quotactl(int cmds, int type, int id, struct super_block *sb);\nint security_quota_on(struct dentry *dentry);\nint security_syslog(int type);\nint security_settime64(const struct timespec64 *ts, const struct timezone *tz);\nint security_vm_enough_memory_mm(struct mm_struct *mm, long pages);\nint security_bprm_creds_for_exec(struct linux_binprm *bprm);\nint security_bprm_creds_from_file(struct linux_binprm *bprm, struct file *file);\nint security_bprm_check(struct linux_binprm *bprm);\nvoid security_bprm_committing_creds(struct linux_binprm *bprm);\nvoid security_bprm_committed_creds(struct linux_binprm *bprm);\nint security_fs_context_submount(struct fs_context *fc, struct super_block *reference);\nint security_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc);\nint security_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param);\nint security_sb_alloc(struct super_block *sb);\nvoid security_sb_delete(struct super_block *sb);\nvoid security_sb_free(struct super_block *sb);\nvoid security_free_mnt_opts(void **mnt_opts);\nint security_sb_eat_lsm_opts(char *options, void **mnt_opts);\nint security_sb_mnt_opts_compat(struct super_block *sb, void *mnt_opts);\nint security_sb_remount(struct super_block *sb, void *mnt_opts);\nint security_sb_kern_mount(struct super_block *sb);\nint security_sb_show_options(struct seq_file *m, struct super_block *sb);\nint security_sb_statfs(struct dentry *dentry);\nint security_sb_mount(const char *dev_name, const struct path *path,\n\t\t      const char *type, unsigned long flags, void *data);\nint security_sb_umount(struct vfsmount *mnt, int flags);\nint security_sb_pivotroot(const struct path *old_path, const struct path *new_path);\nint security_sb_set_mnt_opts(struct super_block *sb,\n\t\t\t\tvoid *mnt_opts,\n\t\t\t\tunsigned long kern_flags,\n\t\t\t\tunsigned long *set_kern_flags);\nint security_sb_clone_mnt_opts(const struct super_block *oldsb,\n\t\t\t\tstruct super_block *newsb,\n\t\t\t\tunsigned long kern_flags,\n\t\t\t\tunsigned long *set_kern_flags);\nint security_move_mount(const struct path *from_path, const struct path *to_path);\nint security_dentry_init_security(struct dentry *dentry, int mode,\n\t\t\t\t  const struct qstr *name,\n\t\t\t\t  const char **xattr_name, void **ctx,\n\t\t\t\t  u32 *ctxlen);\nint security_dentry_create_files_as(struct dentry *dentry, int mode,\n\t\t\t\t\tstruct qstr *name,\n\t\t\t\t\tconst struct cred *old,\n\t\t\t\t\tstruct cred *new);\nint security_path_notify(const struct path *path, u64 mask,\n\t\t\t\t\tunsigned int obj_type);\nint security_inode_alloc(struct inode *inode);\nvoid security_inode_free(struct inode *inode);\nint security_inode_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\t const struct qstr *qstr,\n\t\t\t\t initxattrs initxattrs, void *fs_data);\nint security_inode_init_security_anon(struct inode *inode,\n\t\t\t\t      const struct qstr *name,\n\t\t\t\t      const struct inode *context_inode);\nint security_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode);\nint security_inode_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t struct dentry *new_dentry);\nint security_inode_unlink(struct inode *dir, struct dentry *dentry);\nint security_inode_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t   const char *old_name);\nint security_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode);\nint security_inode_rmdir(struct inode *dir, struct dentry *dentry);\nint security_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev);\nint security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t  struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t  unsigned int flags);\nint security_inode_readlink(struct dentry *dentry);\nint security_inode_follow_link(struct dentry *dentry, struct inode *inode,\n\t\t\t       bool rcu);\nint security_inode_permission(struct inode *inode, int mask);\nint security_inode_setattr(struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry, struct iattr *attr);\nint security_inode_getattr(const struct path *path);\nint security_inode_setxattr(struct mnt_idmap *idmap,\n\t\t\t    struct dentry *dentry, const char *name,\n\t\t\t    const void *value, size_t size, int flags);\nint security_inode_set_acl(struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry, const char *acl_name,\n\t\t\t   struct posix_acl *kacl);\nint security_inode_get_acl(struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry, const char *acl_name);\nint security_inode_remove_acl(struct mnt_idmap *idmap,\n\t\t\t      struct dentry *dentry, const char *acl_name);\nvoid security_inode_post_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t  const void *value, size_t size, int flags);\nint security_inode_getxattr(struct dentry *dentry, const char *name);\nint security_inode_listxattr(struct dentry *dentry);\nint security_inode_removexattr(struct mnt_idmap *idmap,\n\t\t\t       struct dentry *dentry, const char *name);\nint security_inode_need_killpriv(struct dentry *dentry);\nint security_inode_killpriv(struct mnt_idmap *idmap, struct dentry *dentry);\nint security_inode_getsecurity(struct mnt_idmap *idmap,\n\t\t\t       struct inode *inode, const char *name,\n\t\t\t       void **buffer, bool alloc);\nint security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags);\nint security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size);\nvoid security_inode_getsecid(struct inode *inode, u32 *secid);\nint security_inode_copy_up(struct dentry *src, struct cred **new);\nint security_inode_copy_up_xattr(const char *name);\nint security_kernfs_init_security(struct kernfs_node *kn_dir,\n\t\t\t\t  struct kernfs_node *kn);\nint security_file_permission(struct file *file, int mask);\nint security_file_alloc(struct file *file);\nvoid security_file_free(struct file *file);\nint security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\nint security_mmap_file(struct file *file, unsigned long prot,\n\t\t\tunsigned long flags);\nint security_mmap_addr(unsigned long addr);\nint security_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,\n\t\t\t   unsigned long prot);\nint security_file_lock(struct file *file, unsigned int cmd);\nint security_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg);\nvoid security_file_set_fowner(struct file *file);\nint security_file_send_sigiotask(struct task_struct *tsk,\n\t\t\t\t struct fown_struct *fown, int sig);\nint security_file_receive(struct file *file);\nint security_file_open(struct file *file);\nint security_file_truncate(struct file *file);\nint security_task_alloc(struct task_struct *task, unsigned long clone_flags);\nvoid security_task_free(struct task_struct *task);\nint security_cred_alloc_blank(struct cred *cred, gfp_t gfp);\nvoid security_cred_free(struct cred *cred);\nint security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp);\nvoid security_transfer_creds(struct cred *new, const struct cred *old);\nvoid security_cred_getsecid(const struct cred *c, u32 *secid);\nint security_kernel_act_as(struct cred *new, u32 secid);\nint security_kernel_create_files_as(struct cred *new, struct inode *inode);\nint security_kernel_module_request(char *kmod_name);\nint security_kernel_load_data(enum kernel_load_data_id id, bool contents);\nint security_kernel_post_load_data(char *buf, loff_t size,\n\t\t\t\t   enum kernel_load_data_id id,\n\t\t\t\t   char *description);\nint security_kernel_read_file(struct file *file, enum kernel_read_file_id id,\n\t\t\t      bool contents);\nint security_kernel_post_read_file(struct file *file, char *buf, loff_t size,\n\t\t\t\t   enum kernel_read_file_id id);\nint security_task_fix_setuid(struct cred *new, const struct cred *old,\n\t\t\t     int flags);\nint security_task_fix_setgid(struct cred *new, const struct cred *old,\n\t\t\t     int flags);\nint security_task_fix_setgroups(struct cred *new, const struct cred *old);\nint security_task_setpgid(struct task_struct *p, pid_t pgid);\nint security_task_getpgid(struct task_struct *p);\nint security_task_getsid(struct task_struct *p);\nvoid security_current_getsecid_subj(u32 *secid);\nvoid security_task_getsecid_obj(struct task_struct *p, u32 *secid);\nint security_task_setnice(struct task_struct *p, int nice);\nint security_task_setioprio(struct task_struct *p, int ioprio);\nint security_task_getioprio(struct task_struct *p);\nint security_task_prlimit(const struct cred *cred, const struct cred *tcred,\n\t\t\t  unsigned int flags);\nint security_task_setrlimit(struct task_struct *p, unsigned int resource,\n\t\tstruct rlimit *new_rlim);\nint security_task_setscheduler(struct task_struct *p);\nint security_task_getscheduler(struct task_struct *p);\nint security_task_movememory(struct task_struct *p);\nint security_task_kill(struct task_struct *p, struct kernel_siginfo *info,\n\t\t\tint sig, const struct cred *cred);\nint security_task_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t\tunsigned long arg4, unsigned long arg5);\nvoid security_task_to_inode(struct task_struct *p, struct inode *inode);\nint security_create_user_ns(const struct cred *cred);\nint security_ipc_permission(struct kern_ipc_perm *ipcp, short flag);\nvoid security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid);\nint security_msg_msg_alloc(struct msg_msg *msg);\nvoid security_msg_msg_free(struct msg_msg *msg);\nint security_msg_queue_alloc(struct kern_ipc_perm *msq);\nvoid security_msg_queue_free(struct kern_ipc_perm *msq);\nint security_msg_queue_associate(struct kern_ipc_perm *msq, int msqflg);\nint security_msg_queue_msgctl(struct kern_ipc_perm *msq, int cmd);\nint security_msg_queue_msgsnd(struct kern_ipc_perm *msq,\n\t\t\t      struct msg_msg *msg, int msqflg);\nint security_msg_queue_msgrcv(struct kern_ipc_perm *msq, struct msg_msg *msg,\n\t\t\t      struct task_struct *target, long type, int mode);\nint security_shm_alloc(struct kern_ipc_perm *shp);\nvoid security_shm_free(struct kern_ipc_perm *shp);\nint security_shm_associate(struct kern_ipc_perm *shp, int shmflg);\nint security_shm_shmctl(struct kern_ipc_perm *shp, int cmd);\nint security_shm_shmat(struct kern_ipc_perm *shp, char __user *shmaddr, int shmflg);\nint security_sem_alloc(struct kern_ipc_perm *sma);\nvoid security_sem_free(struct kern_ipc_perm *sma);\nint security_sem_associate(struct kern_ipc_perm *sma, int semflg);\nint security_sem_semctl(struct kern_ipc_perm *sma, int cmd);\nint security_sem_semop(struct kern_ipc_perm *sma, struct sembuf *sops,\n\t\t\tunsigned nsops, int alter);\nvoid security_d_instantiate(struct dentry *dentry, struct inode *inode);\nint security_getprocattr(struct task_struct *p, const char *lsm, const char *name,\n\t\t\t char **value);\nint security_setprocattr(const char *lsm, const char *name, void *value,\n\t\t\t size_t size);\nint security_netlink_send(struct sock *sk, struct sk_buff *skb);\nint security_ismaclabel(const char *name);\nint security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen);\nint security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid);\nvoid security_release_secctx(char *secdata, u32 seclen);\nvoid security_inode_invalidate_secctx(struct inode *inode);\nint security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen);\nint security_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen);\nint security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen);\nint security_locked_down(enum lockdown_reason what);\n#else  \n\nstatic inline int call_blocking_lsm_notifier(enum lsm_event event, void *data)\n{\n\treturn 0;\n}\n\nstatic inline int register_blocking_lsm_notifier(struct notifier_block *nb)\n{\n\treturn 0;\n}\n\nstatic inline  int unregister_blocking_lsm_notifier(struct notifier_block *nb)\n{\n\treturn 0;\n}\n\nstatic inline void security_free_mnt_opts(void **mnt_opts)\n{\n}\n\n \n\nstatic inline int security_init(void)\n{\n\treturn 0;\n}\n\nstatic inline int early_security_init(void)\n{\n\treturn 0;\n}\n\nstatic inline int security_binder_set_context_mgr(const struct cred *mgr)\n{\n\treturn 0;\n}\n\nstatic inline int security_binder_transaction(const struct cred *from,\n\t\t\t\t\t      const struct cred *to)\n{\n\treturn 0;\n}\n\nstatic inline int security_binder_transfer_binder(const struct cred *from,\n\t\t\t\t\t\t  const struct cred *to)\n{\n\treturn 0;\n}\n\nstatic inline int security_binder_transfer_file(const struct cred *from,\n\t\t\t\t\t\tconst struct cred *to,\n\t\t\t\t\t\tconst struct file *file)\n{\n\treturn 0;\n}\n\nstatic inline int security_ptrace_access_check(struct task_struct *child,\n\t\t\t\t\t     unsigned int mode)\n{\n\treturn cap_ptrace_access_check(child, mode);\n}\n\nstatic inline int security_ptrace_traceme(struct task_struct *parent)\n{\n\treturn cap_ptrace_traceme(parent);\n}\n\nstatic inline int security_capget(const struct task_struct *target,\n\t\t\t\t   kernel_cap_t *effective,\n\t\t\t\t   kernel_cap_t *inheritable,\n\t\t\t\t   kernel_cap_t *permitted)\n{\n\treturn cap_capget(target, effective, inheritable, permitted);\n}\n\nstatic inline int security_capset(struct cred *new,\n\t\t\t\t   const struct cred *old,\n\t\t\t\t   const kernel_cap_t *effective,\n\t\t\t\t   const kernel_cap_t *inheritable,\n\t\t\t\t   const kernel_cap_t *permitted)\n{\n\treturn cap_capset(new, old, effective, inheritable, permitted);\n}\n\nstatic inline int security_capable(const struct cred *cred,\n\t\t\t\t   struct user_namespace *ns,\n\t\t\t\t   int cap,\n\t\t\t\t   unsigned int opts)\n{\n\treturn cap_capable(cred, ns, cap, opts);\n}\n\nstatic inline int security_quotactl(int cmds, int type, int id,\n\t\t\t\t     struct super_block *sb)\n{\n\treturn 0;\n}\n\nstatic inline int security_quota_on(struct dentry *dentry)\n{\n\treturn 0;\n}\n\nstatic inline int security_syslog(int type)\n{\n\treturn 0;\n}\n\nstatic inline int security_settime64(const struct timespec64 *ts,\n\t\t\t\t     const struct timezone *tz)\n{\n\treturn cap_settime(ts, tz);\n}\n\nstatic inline int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)\n{\n\treturn __vm_enough_memory(mm, pages, cap_vm_enough_memory(mm, pages));\n}\n\nstatic inline int security_bprm_creds_for_exec(struct linux_binprm *bprm)\n{\n\treturn 0;\n}\n\nstatic inline int security_bprm_creds_from_file(struct linux_binprm *bprm,\n\t\t\t\t\t\tstruct file *file)\n{\n\treturn cap_bprm_creds_from_file(bprm, file);\n}\n\nstatic inline int security_bprm_check(struct linux_binprm *bprm)\n{\n\treturn 0;\n}\n\nstatic inline void security_bprm_committing_creds(struct linux_binprm *bprm)\n{\n}\n\nstatic inline void security_bprm_committed_creds(struct linux_binprm *bprm)\n{\n}\n\nstatic inline int security_fs_context_submount(struct fs_context *fc,\n\t\t\t\t\t   struct super_block *reference)\n{\n\treturn 0;\n}\nstatic inline int security_fs_context_dup(struct fs_context *fc,\n\t\t\t\t\t  struct fs_context *src_fc)\n{\n\treturn 0;\n}\nstatic inline int security_fs_context_parse_param(struct fs_context *fc,\n\t\t\t\t\t\t  struct fs_parameter *param)\n{\n\treturn -ENOPARAM;\n}\n\nstatic inline int security_sb_alloc(struct super_block *sb)\n{\n\treturn 0;\n}\n\nstatic inline void security_sb_delete(struct super_block *sb)\n{ }\n\nstatic inline void security_sb_free(struct super_block *sb)\n{ }\n\nstatic inline int security_sb_eat_lsm_opts(char *options,\n\t\t\t\t\t   void **mnt_opts)\n{\n\treturn 0;\n}\n\nstatic inline int security_sb_remount(struct super_block *sb,\n\t\t\t\t      void *mnt_opts)\n{\n\treturn 0;\n}\n\nstatic inline int security_sb_mnt_opts_compat(struct super_block *sb,\n\t\t\t\t\t      void *mnt_opts)\n{\n\treturn 0;\n}\n\n\nstatic inline int security_sb_kern_mount(struct super_block *sb)\n{\n\treturn 0;\n}\n\nstatic inline int security_sb_show_options(struct seq_file *m,\n\t\t\t\t\t   struct super_block *sb)\n{\n\treturn 0;\n}\n\nstatic inline int security_sb_statfs(struct dentry *dentry)\n{\n\treturn 0;\n}\n\nstatic inline int security_sb_mount(const char *dev_name, const struct path *path,\n\t\t\t\t    const char *type, unsigned long flags,\n\t\t\t\t    void *data)\n{\n\treturn 0;\n}\n\nstatic inline int security_sb_umount(struct vfsmount *mnt, int flags)\n{\n\treturn 0;\n}\n\nstatic inline int security_sb_pivotroot(const struct path *old_path,\n\t\t\t\t\tconst struct path *new_path)\n{\n\treturn 0;\n}\n\nstatic inline int security_sb_set_mnt_opts(struct super_block *sb,\n\t\t\t\t\t   void *mnt_opts,\n\t\t\t\t\t   unsigned long kern_flags,\n\t\t\t\t\t   unsigned long *set_kern_flags)\n{\n\treturn 0;\n}\n\nstatic inline int security_sb_clone_mnt_opts(const struct super_block *oldsb,\n\t\t\t\t\t      struct super_block *newsb,\n\t\t\t\t\t      unsigned long kern_flags,\n\t\t\t\t\t      unsigned long *set_kern_flags)\n{\n\treturn 0;\n}\n\nstatic inline int security_move_mount(const struct path *from_path,\n\t\t\t\t      const struct path *to_path)\n{\n\treturn 0;\n}\n\nstatic inline int security_path_notify(const struct path *path, u64 mask,\n\t\t\t\tunsigned int obj_type)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_alloc(struct inode *inode)\n{\n\treturn 0;\n}\n\nstatic inline void security_inode_free(struct inode *inode)\n{ }\n\nstatic inline int security_dentry_init_security(struct dentry *dentry,\n\t\t\t\t\t\t int mode,\n\t\t\t\t\t\t const struct qstr *name,\n\t\t\t\t\t\t const char **xattr_name,\n\t\t\t\t\t\t void **ctx,\n\t\t\t\t\t\t u32 *ctxlen)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int security_dentry_create_files_as(struct dentry *dentry,\n\t\t\t\t\t\t  int mode, struct qstr *name,\n\t\t\t\t\t\t  const struct cred *old,\n\t\t\t\t\t\t  struct cred *new)\n{\n\treturn 0;\n}\n\n\nstatic inline int security_inode_init_security(struct inode *inode,\n\t\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\t\tconst struct qstr *qstr,\n\t\t\t\t\t\tconst initxattrs xattrs,\n\t\t\t\t\t\tvoid *fs_data)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_init_security_anon(struct inode *inode,\n\t\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t\t    const struct inode *context_inode)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_create(struct inode *dir,\n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t umode_t mode)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_link(struct dentry *old_dentry,\n\t\t\t\t       struct inode *dir,\n\t\t\t\t       struct dentry *new_dentry)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_unlink(struct inode *dir,\n\t\t\t\t\t struct dentry *dentry)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_symlink(struct inode *dir,\n\t\t\t\t\t  struct dentry *dentry,\n\t\t\t\t\t  const char *old_name)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_mkdir(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tint mode)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_rmdir(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_mknod(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tint mode, dev_t dev)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_rename(struct inode *old_dir,\n\t\t\t\t\t struct dentry *old_dentry,\n\t\t\t\t\t struct inode *new_dir,\n\t\t\t\t\t struct dentry *new_dentry,\n\t\t\t\t\t unsigned int flags)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_readlink(struct dentry *dentry)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_follow_link(struct dentry *dentry,\n\t\t\t\t\t     struct inode *inode,\n\t\t\t\t\t     bool rcu)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_permission(struct inode *inode, int mask)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_setattr(struct mnt_idmap *idmap,\n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t struct iattr *attr)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_getattr(const struct path *path)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_setxattr(struct mnt_idmap *idmap,\n\t\tstruct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\treturn cap_inode_setxattr(dentry, name, value, size, flags);\n}\n\nstatic inline int security_inode_set_acl(struct mnt_idmap *idmap,\n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const char *acl_name,\n\t\t\t\t\t struct posix_acl *kacl)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_get_acl(struct mnt_idmap *idmap,\n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const char *acl_name)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_remove_acl(struct mnt_idmap *idmap,\n\t\t\t\t\t    struct dentry *dentry,\n\t\t\t\t\t    const char *acl_name)\n{\n\treturn 0;\n}\n\nstatic inline void security_inode_post_setxattr(struct dentry *dentry,\n\t\tconst char *name, const void *value, size_t size, int flags)\n{ }\n\nstatic inline int security_inode_getxattr(struct dentry *dentry,\n\t\t\tconst char *name)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_listxattr(struct dentry *dentry)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_removexattr(struct mnt_idmap *idmap,\n\t\t\t\t\t     struct dentry *dentry,\n\t\t\t\t\t     const char *name)\n{\n\treturn cap_inode_removexattr(idmap, dentry, name);\n}\n\nstatic inline int security_inode_need_killpriv(struct dentry *dentry)\n{\n\treturn cap_inode_need_killpriv(dentry);\n}\n\nstatic inline int security_inode_killpriv(struct mnt_idmap *idmap,\n\t\t\t\t\t  struct dentry *dentry)\n{\n\treturn cap_inode_killpriv(idmap, dentry);\n}\n\nstatic inline int security_inode_getsecurity(struct mnt_idmap *idmap,\n\t\t\t\t\t     struct inode *inode,\n\t\t\t\t\t     const char *name, void **buffer,\n\t\t\t\t\t     bool alloc)\n{\n\treturn cap_inode_getsecurity(idmap, inode, name, buffer, alloc);\n}\n\nstatic inline int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)\n{\n\treturn 0;\n}\n\nstatic inline void security_inode_getsecid(struct inode *inode, u32 *secid)\n{\n\t*secid = 0;\n}\n\nstatic inline int security_inode_copy_up(struct dentry *src, struct cred **new)\n{\n\treturn 0;\n}\n\nstatic inline int security_kernfs_init_security(struct kernfs_node *kn_dir,\n\t\t\t\t\t\tstruct kernfs_node *kn)\n{\n\treturn 0;\n}\n\nstatic inline int security_inode_copy_up_xattr(const char *name)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int security_file_permission(struct file *file, int mask)\n{\n\treturn 0;\n}\n\nstatic inline int security_file_alloc(struct file *file)\n{\n\treturn 0;\n}\n\nstatic inline void security_file_free(struct file *file)\n{ }\n\nstatic inline int security_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n{\n\treturn 0;\n}\n\nstatic inline int security_mmap_file(struct file *file, unsigned long prot,\n\t\t\t\t     unsigned long flags)\n{\n\treturn 0;\n}\n\nstatic inline int security_mmap_addr(unsigned long addr)\n{\n\treturn cap_mmap_addr(addr);\n}\n\nstatic inline int security_file_mprotect(struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long reqprot,\n\t\t\t\t\t unsigned long prot)\n{\n\treturn 0;\n}\n\nstatic inline int security_file_lock(struct file *file, unsigned int cmd)\n{\n\treturn 0;\n}\n\nstatic inline int security_file_fcntl(struct file *file, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n{\n\treturn 0;\n}\n\nstatic inline void security_file_set_fowner(struct file *file)\n{\n\treturn;\n}\n\nstatic inline int security_file_send_sigiotask(struct task_struct *tsk,\n\t\t\t\t\t       struct fown_struct *fown,\n\t\t\t\t\t       int sig)\n{\n\treturn 0;\n}\n\nstatic inline int security_file_receive(struct file *file)\n{\n\treturn 0;\n}\n\nstatic inline int security_file_open(struct file *file)\n{\n\treturn 0;\n}\n\nstatic inline int security_file_truncate(struct file *file)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_alloc(struct task_struct *task,\n\t\t\t\t      unsigned long clone_flags)\n{\n\treturn 0;\n}\n\nstatic inline void security_task_free(struct task_struct *task)\n{ }\n\nstatic inline int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\treturn 0;\n}\n\nstatic inline void security_cred_free(struct cred *cred)\n{ }\n\nstatic inline int security_prepare_creds(struct cred *new,\n\t\t\t\t\t const struct cred *old,\n\t\t\t\t\t gfp_t gfp)\n{\n\treturn 0;\n}\n\nstatic inline void security_transfer_creds(struct cred *new,\n\t\t\t\t\t   const struct cred *old)\n{\n}\n\nstatic inline void security_cred_getsecid(const struct cred *c, u32 *secid)\n{\n\t*secid = 0;\n}\n\nstatic inline int security_kernel_act_as(struct cred *cred, u32 secid)\n{\n\treturn 0;\n}\n\nstatic inline int security_kernel_create_files_as(struct cred *cred,\n\t\t\t\t\t\t  struct inode *inode)\n{\n\treturn 0;\n}\n\nstatic inline int security_kernel_module_request(char *kmod_name)\n{\n\treturn 0;\n}\n\nstatic inline int security_kernel_load_data(enum kernel_load_data_id id, bool contents)\n{\n\treturn 0;\n}\n\nstatic inline int security_kernel_post_load_data(char *buf, loff_t size,\n\t\t\t\t\t\t enum kernel_load_data_id id,\n\t\t\t\t\t\t char *description)\n{\n\treturn 0;\n}\n\nstatic inline int security_kernel_read_file(struct file *file,\n\t\t\t\t\t    enum kernel_read_file_id id,\n\t\t\t\t\t    bool contents)\n{\n\treturn 0;\n}\n\nstatic inline int security_kernel_post_read_file(struct file *file,\n\t\t\t\t\t\t char *buf, loff_t size,\n\t\t\t\t\t\t enum kernel_read_file_id id)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_fix_setuid(struct cred *new,\n\t\t\t\t\t   const struct cred *old,\n\t\t\t\t\t   int flags)\n{\n\treturn cap_task_fix_setuid(new, old, flags);\n}\n\nstatic inline int security_task_fix_setgid(struct cred *new,\n\t\t\t\t\t   const struct cred *old,\n\t\t\t\t\t   int flags)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_fix_setgroups(struct cred *new,\n\t\t\t\t\t   const struct cred *old)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_setpgid(struct task_struct *p, pid_t pgid)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_getpgid(struct task_struct *p)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_getsid(struct task_struct *p)\n{\n\treturn 0;\n}\n\nstatic inline void security_current_getsecid_subj(u32 *secid)\n{\n\t*secid = 0;\n}\n\nstatic inline void security_task_getsecid_obj(struct task_struct *p, u32 *secid)\n{\n\t*secid = 0;\n}\n\nstatic inline int security_task_setnice(struct task_struct *p, int nice)\n{\n\treturn cap_task_setnice(p, nice);\n}\n\nstatic inline int security_task_setioprio(struct task_struct *p, int ioprio)\n{\n\treturn cap_task_setioprio(p, ioprio);\n}\n\nstatic inline int security_task_getioprio(struct task_struct *p)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_prlimit(const struct cred *cred,\n\t\t\t\t\tconst struct cred *tcred,\n\t\t\t\t\tunsigned int flags)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_setrlimit(struct task_struct *p,\n\t\t\t\t\t  unsigned int resource,\n\t\t\t\t\t  struct rlimit *new_rlim)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_setscheduler(struct task_struct *p)\n{\n\treturn cap_task_setscheduler(p);\n}\n\nstatic inline int security_task_getscheduler(struct task_struct *p)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_movememory(struct task_struct *p)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_kill(struct task_struct *p,\n\t\t\t\t     struct kernel_siginfo *info, int sig,\n\t\t\t\t     const struct cred *cred)\n{\n\treturn 0;\n}\n\nstatic inline int security_task_prctl(int option, unsigned long arg2,\n\t\t\t\t      unsigned long arg3,\n\t\t\t\t      unsigned long arg4,\n\t\t\t\t      unsigned long arg5)\n{\n\treturn cap_task_prctl(option, arg2, arg3, arg4, arg5);\n}\n\nstatic inline void security_task_to_inode(struct task_struct *p, struct inode *inode)\n{ }\n\nstatic inline int security_create_user_ns(const struct cred *cred)\n{\n\treturn 0;\n}\n\nstatic inline int security_ipc_permission(struct kern_ipc_perm *ipcp,\n\t\t\t\t\t  short flag)\n{\n\treturn 0;\n}\n\nstatic inline void security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)\n{\n\t*secid = 0;\n}\n\nstatic inline int security_msg_msg_alloc(struct msg_msg *msg)\n{\n\treturn 0;\n}\n\nstatic inline void security_msg_msg_free(struct msg_msg *msg)\n{ }\n\nstatic inline int security_msg_queue_alloc(struct kern_ipc_perm *msq)\n{\n\treturn 0;\n}\n\nstatic inline void security_msg_queue_free(struct kern_ipc_perm *msq)\n{ }\n\nstatic inline int security_msg_queue_associate(struct kern_ipc_perm *msq,\n\t\t\t\t\t       int msqflg)\n{\n\treturn 0;\n}\n\nstatic inline int security_msg_queue_msgctl(struct kern_ipc_perm *msq, int cmd)\n{\n\treturn 0;\n}\n\nstatic inline int security_msg_queue_msgsnd(struct kern_ipc_perm *msq,\n\t\t\t\t\t    struct msg_msg *msg, int msqflg)\n{\n\treturn 0;\n}\n\nstatic inline int security_msg_queue_msgrcv(struct kern_ipc_perm *msq,\n\t\t\t\t\t    struct msg_msg *msg,\n\t\t\t\t\t    struct task_struct *target,\n\t\t\t\t\t    long type, int mode)\n{\n\treturn 0;\n}\n\nstatic inline int security_shm_alloc(struct kern_ipc_perm *shp)\n{\n\treturn 0;\n}\n\nstatic inline void security_shm_free(struct kern_ipc_perm *shp)\n{ }\n\nstatic inline int security_shm_associate(struct kern_ipc_perm *shp,\n\t\t\t\t\t int shmflg)\n{\n\treturn 0;\n}\n\nstatic inline int security_shm_shmctl(struct kern_ipc_perm *shp, int cmd)\n{\n\treturn 0;\n}\n\nstatic inline int security_shm_shmat(struct kern_ipc_perm *shp,\n\t\t\t\t     char __user *shmaddr, int shmflg)\n{\n\treturn 0;\n}\n\nstatic inline int security_sem_alloc(struct kern_ipc_perm *sma)\n{\n\treturn 0;\n}\n\nstatic inline void security_sem_free(struct kern_ipc_perm *sma)\n{ }\n\nstatic inline int security_sem_associate(struct kern_ipc_perm *sma, int semflg)\n{\n\treturn 0;\n}\n\nstatic inline int security_sem_semctl(struct kern_ipc_perm *sma, int cmd)\n{\n\treturn 0;\n}\n\nstatic inline int security_sem_semop(struct kern_ipc_perm *sma,\n\t\t\t\t     struct sembuf *sops, unsigned nsops,\n\t\t\t\t     int alter)\n{\n\treturn 0;\n}\n\nstatic inline void security_d_instantiate(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode)\n{ }\n\nstatic inline int security_getprocattr(struct task_struct *p, const char *lsm,\n\t\t\t\t       const char *name, char **value)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int security_setprocattr(const char *lsm, char *name,\n\t\t\t\t       void *value, size_t size)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int security_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\treturn 0;\n}\n\nstatic inline int security_ismaclabel(const char *name)\n{\n\treturn 0;\n}\n\nstatic inline int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int security_secctx_to_secid(const char *secdata,\n\t\t\t\t\t   u32 seclen,\n\t\t\t\t\t   u32 *secid)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void security_release_secctx(char *secdata, u32 seclen)\n{\n}\n\nstatic inline void security_inode_invalidate_secctx(struct inode *inode)\n{\n}\n\nstatic inline int security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int security_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int security_locked_down(enum lockdown_reason what)\n{\n\treturn 0;\n}\n#endif\t \n\n#if defined(CONFIG_SECURITY) && defined(CONFIG_WATCH_QUEUE)\nint security_post_notification(const struct cred *w_cred,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct watch_notification *n);\n#else\nstatic inline int security_post_notification(const struct cred *w_cred,\n\t\t\t\t\t     const struct cred *cred,\n\t\t\t\t\t     struct watch_notification *n)\n{\n\treturn 0;\n}\n#endif\n\n#if defined(CONFIG_SECURITY) && defined(CONFIG_KEY_NOTIFICATIONS)\nint security_watch_key(struct key *key);\n#else\nstatic inline int security_watch_key(struct key *key)\n{\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_SECURITY_NETWORK\n\nint security_unix_stream_connect(struct sock *sock, struct sock *other, struct sock *newsk);\nint security_unix_may_send(struct socket *sock,  struct socket *other);\nint security_socket_create(int family, int type, int protocol, int kern);\nint security_socket_post_create(struct socket *sock, int family,\n\t\t\t\tint type, int protocol, int kern);\nint security_socket_socketpair(struct socket *socka, struct socket *sockb);\nint security_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen);\nint security_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen);\nint security_socket_listen(struct socket *sock, int backlog);\nint security_socket_accept(struct socket *sock, struct socket *newsock);\nint security_socket_sendmsg(struct socket *sock, struct msghdr *msg, int size);\nint security_socket_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    int size, int flags);\nint security_socket_getsockname(struct socket *sock);\nint security_socket_getpeername(struct socket *sock);\nint security_socket_getsockopt(struct socket *sock, int level, int optname);\nint security_socket_setsockopt(struct socket *sock, int level, int optname);\nint security_socket_shutdown(struct socket *sock, int how);\nint security_sock_rcv_skb(struct sock *sk, struct sk_buff *skb);\nint security_socket_getpeersec_stream(struct socket *sock, sockptr_t optval,\n\t\t\t\t      sockptr_t optlen, unsigned int len);\nint security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb, u32 *secid);\nint security_sk_alloc(struct sock *sk, int family, gfp_t priority);\nvoid security_sk_free(struct sock *sk);\nvoid security_sk_clone(const struct sock *sk, struct sock *newsk);\nvoid security_sk_classify_flow(const struct sock *sk,\n\t\t\t       struct flowi_common *flic);\nvoid security_req_classify_flow(const struct request_sock *req,\n\t\t\t\tstruct flowi_common *flic);\nvoid security_sock_graft(struct sock*sk, struct socket *parent);\nint security_inet_conn_request(const struct sock *sk,\n\t\t\tstruct sk_buff *skb, struct request_sock *req);\nvoid security_inet_csk_clone(struct sock *newsk,\n\t\t\tconst struct request_sock *req);\nvoid security_inet_conn_established(struct sock *sk,\n\t\t\tstruct sk_buff *skb);\nint security_secmark_relabel_packet(u32 secid);\nvoid security_secmark_refcount_inc(void);\nvoid security_secmark_refcount_dec(void);\nint security_tun_dev_alloc_security(void **security);\nvoid security_tun_dev_free_security(void *security);\nint security_tun_dev_create(void);\nint security_tun_dev_attach_queue(void *security);\nint security_tun_dev_attach(struct sock *sk, void *security);\nint security_tun_dev_open(void *security);\nint security_sctp_assoc_request(struct sctp_association *asoc, struct sk_buff *skb);\nint security_sctp_bind_connect(struct sock *sk, int optname,\n\t\t\t       struct sockaddr *address, int addrlen);\nvoid security_sctp_sk_clone(struct sctp_association *asoc, struct sock *sk,\n\t\t\t    struct sock *newsk);\nint security_sctp_assoc_established(struct sctp_association *asoc,\n\t\t\t\t    struct sk_buff *skb);\nint security_mptcp_add_subflow(struct sock *sk, struct sock *ssk);\n\n#else\t \nstatic inline int security_unix_stream_connect(struct sock *sock,\n\t\t\t\t\t       struct sock *other,\n\t\t\t\t\t       struct sock *newsk)\n{\n\treturn 0;\n}\n\nstatic inline int security_unix_may_send(struct socket *sock,\n\t\t\t\t\t struct socket *other)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_create(int family, int type,\n\t\t\t\t\t int protocol, int kern)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_post_create(struct socket *sock,\n\t\t\t\t\t      int family,\n\t\t\t\t\t      int type,\n\t\t\t\t\t      int protocol, int kern)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_socketpair(struct socket *socka,\n\t\t\t\t\t     struct socket *sockb)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_bind(struct socket *sock,\n\t\t\t\t       struct sockaddr *address,\n\t\t\t\t       int addrlen)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_connect(struct socket *sock,\n\t\t\t\t\t  struct sockaddr *address,\n\t\t\t\t\t  int addrlen)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_listen(struct socket *sock, int backlog)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_accept(struct socket *sock,\n\t\t\t\t\t struct socket *newsock)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_sendmsg(struct socket *sock,\n\t\t\t\t\t  struct msghdr *msg, int size)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_recvmsg(struct socket *sock,\n\t\t\t\t\t  struct msghdr *msg, int size,\n\t\t\t\t\t  int flags)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_getsockname(struct socket *sock)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_getpeername(struct socket *sock)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_getsockopt(struct socket *sock,\n\t\t\t\t\t     int level, int optname)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_setsockopt(struct socket *sock,\n\t\t\t\t\t     int level, int optname)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_shutdown(struct socket *sock, int how)\n{\n\treturn 0;\n}\nstatic inline int security_sock_rcv_skb(struct sock *sk,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\treturn 0;\n}\n\nstatic inline int security_socket_getpeersec_stream(struct socket *sock,\n\t\t\t\t\t\t    sockptr_t optval,\n\t\t\t\t\t\t    sockptr_t optlen,\n\t\t\t\t\t\t    unsigned int len)\n{\n\treturn -ENOPROTOOPT;\n}\n\nstatic inline int security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb, u32 *secid)\n{\n\treturn -ENOPROTOOPT;\n}\n\nstatic inline int security_sk_alloc(struct sock *sk, int family, gfp_t priority)\n{\n\treturn 0;\n}\n\nstatic inline void security_sk_free(struct sock *sk)\n{\n}\n\nstatic inline void security_sk_clone(const struct sock *sk, struct sock *newsk)\n{\n}\n\nstatic inline void security_sk_classify_flow(const struct sock *sk,\n\t\t\t\t\t     struct flowi_common *flic)\n{\n}\n\nstatic inline void security_req_classify_flow(const struct request_sock *req,\n\t\t\t\t\t      struct flowi_common *flic)\n{\n}\n\nstatic inline void security_sock_graft(struct sock *sk, struct socket *parent)\n{\n}\n\nstatic inline int security_inet_conn_request(const struct sock *sk,\n\t\t\tstruct sk_buff *skb, struct request_sock *req)\n{\n\treturn 0;\n}\n\nstatic inline void security_inet_csk_clone(struct sock *newsk,\n\t\t\tconst struct request_sock *req)\n{\n}\n\nstatic inline void security_inet_conn_established(struct sock *sk,\n\t\t\tstruct sk_buff *skb)\n{\n}\n\nstatic inline int security_secmark_relabel_packet(u32 secid)\n{\n\treturn 0;\n}\n\nstatic inline void security_secmark_refcount_inc(void)\n{\n}\n\nstatic inline void security_secmark_refcount_dec(void)\n{\n}\n\nstatic inline int security_tun_dev_alloc_security(void **security)\n{\n\treturn 0;\n}\n\nstatic inline void security_tun_dev_free_security(void *security)\n{\n}\n\nstatic inline int security_tun_dev_create(void)\n{\n\treturn 0;\n}\n\nstatic inline int security_tun_dev_attach_queue(void *security)\n{\n\treturn 0;\n}\n\nstatic inline int security_tun_dev_attach(struct sock *sk, void *security)\n{\n\treturn 0;\n}\n\nstatic inline int security_tun_dev_open(void *security)\n{\n\treturn 0;\n}\n\nstatic inline int security_sctp_assoc_request(struct sctp_association *asoc,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\treturn 0;\n}\n\nstatic inline int security_sctp_bind_connect(struct sock *sk, int optname,\n\t\t\t\t\t     struct sockaddr *address,\n\t\t\t\t\t     int addrlen)\n{\n\treturn 0;\n}\n\nstatic inline void security_sctp_sk_clone(struct sctp_association *asoc,\n\t\t\t\t\t  struct sock *sk,\n\t\t\t\t\t  struct sock *newsk)\n{\n}\n\nstatic inline int security_sctp_assoc_established(struct sctp_association *asoc,\n\t\t\t\t\t\t  struct sk_buff *skb)\n{\n\treturn 0;\n}\n\nstatic inline int security_mptcp_add_subflow(struct sock *sk, struct sock *ssk)\n{\n\treturn 0;\n}\n#endif\t \n\n#ifdef CONFIG_SECURITY_INFINIBAND\nint security_ib_pkey_access(void *sec, u64 subnet_prefix, u16 pkey);\nint security_ib_endport_manage_subnet(void *sec, const char *name, u8 port_num);\nint security_ib_alloc_security(void **sec);\nvoid security_ib_free_security(void *sec);\n#else\t \nstatic inline int security_ib_pkey_access(void *sec, u64 subnet_prefix, u16 pkey)\n{\n\treturn 0;\n}\n\nstatic inline int security_ib_endport_manage_subnet(void *sec, const char *dev_name, u8 port_num)\n{\n\treturn 0;\n}\n\nstatic inline int security_ib_alloc_security(void **sec)\n{\n\treturn 0;\n}\n\nstatic inline void security_ib_free_security(void *sec)\n{\n}\n#endif\t \n\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n\nint security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,\n\t\t\t       struct xfrm_user_sec_ctx *sec_ctx, gfp_t gfp);\nint security_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx, struct xfrm_sec_ctx **new_ctxp);\nvoid security_xfrm_policy_free(struct xfrm_sec_ctx *ctx);\nint security_xfrm_policy_delete(struct xfrm_sec_ctx *ctx);\nint security_xfrm_state_alloc(struct xfrm_state *x, struct xfrm_user_sec_ctx *sec_ctx);\nint security_xfrm_state_alloc_acquire(struct xfrm_state *x,\n\t\t\t\t      struct xfrm_sec_ctx *polsec, u32 secid);\nint security_xfrm_state_delete(struct xfrm_state *x);\nvoid security_xfrm_state_free(struct xfrm_state *x);\nint security_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid);\nint security_xfrm_state_pol_flow_match(struct xfrm_state *x,\n\t\t\t\t       struct xfrm_policy *xp,\n\t\t\t\t       const struct flowi_common *flic);\nint security_xfrm_decode_session(struct sk_buff *skb, u32 *secid);\nvoid security_skb_classify_flow(struct sk_buff *skb, struct flowi_common *flic);\n\n#else\t \n\nstatic inline int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,\n\t\t\t\t\t     struct xfrm_user_sec_ctx *sec_ctx,\n\t\t\t\t\t     gfp_t gfp)\n{\n\treturn 0;\n}\n\nstatic inline int security_xfrm_policy_clone(struct xfrm_sec_ctx *old, struct xfrm_sec_ctx **new_ctxp)\n{\n\treturn 0;\n}\n\nstatic inline void security_xfrm_policy_free(struct xfrm_sec_ctx *ctx)\n{\n}\n\nstatic inline int security_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)\n{\n\treturn 0;\n}\n\nstatic inline int security_xfrm_state_alloc(struct xfrm_state *x,\n\t\t\t\t\tstruct xfrm_user_sec_ctx *sec_ctx)\n{\n\treturn 0;\n}\n\nstatic inline int security_xfrm_state_alloc_acquire(struct xfrm_state *x,\n\t\t\t\t\tstruct xfrm_sec_ctx *polsec, u32 secid)\n{\n\treturn 0;\n}\n\nstatic inline void security_xfrm_state_free(struct xfrm_state *x)\n{\n}\n\nstatic inline int security_xfrm_state_delete(struct xfrm_state *x)\n{\n\treturn 0;\n}\n\nstatic inline int security_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid)\n{\n\treturn 0;\n}\n\nstatic inline int security_xfrm_state_pol_flow_match(struct xfrm_state *x,\n\t\t\t\t\t\t     struct xfrm_policy *xp,\n\t\t\t\t\t\t     const struct flowi_common *flic)\n{\n\treturn 1;\n}\n\nstatic inline int security_xfrm_decode_session(struct sk_buff *skb, u32 *secid)\n{\n\treturn 0;\n}\n\nstatic inline void security_skb_classify_flow(struct sk_buff *skb,\n\t\t\t\t\t      struct flowi_common *flic)\n{\n}\n\n#endif\t \n\n#ifdef CONFIG_SECURITY_PATH\nint security_path_unlink(const struct path *dir, struct dentry *dentry);\nint security_path_mkdir(const struct path *dir, struct dentry *dentry, umode_t mode);\nint security_path_rmdir(const struct path *dir, struct dentry *dentry);\nint security_path_mknod(const struct path *dir, struct dentry *dentry, umode_t mode,\n\t\t\tunsigned int dev);\nint security_path_truncate(const struct path *path);\nint security_path_symlink(const struct path *dir, struct dentry *dentry,\n\t\t\t  const char *old_name);\nint security_path_link(struct dentry *old_dentry, const struct path *new_dir,\n\t\t       struct dentry *new_dentry);\nint security_path_rename(const struct path *old_dir, struct dentry *old_dentry,\n\t\t\t const struct path *new_dir, struct dentry *new_dentry,\n\t\t\t unsigned int flags);\nint security_path_chmod(const struct path *path, umode_t mode);\nint security_path_chown(const struct path *path, kuid_t uid, kgid_t gid);\nint security_path_chroot(const struct path *path);\n#else\t \nstatic inline int security_path_unlink(const struct path *dir, struct dentry *dentry)\n{\n\treturn 0;\n}\n\nstatic inline int security_path_mkdir(const struct path *dir, struct dentry *dentry,\n\t\t\t\t      umode_t mode)\n{\n\treturn 0;\n}\n\nstatic inline int security_path_rmdir(const struct path *dir, struct dentry *dentry)\n{\n\treturn 0;\n}\n\nstatic inline int security_path_mknod(const struct path *dir, struct dentry *dentry,\n\t\t\t\t      umode_t mode, unsigned int dev)\n{\n\treturn 0;\n}\n\nstatic inline int security_path_truncate(const struct path *path)\n{\n\treturn 0;\n}\n\nstatic inline int security_path_symlink(const struct path *dir, struct dentry *dentry,\n\t\t\t\t\tconst char *old_name)\n{\n\treturn 0;\n}\n\nstatic inline int security_path_link(struct dentry *old_dentry,\n\t\t\t\t     const struct path *new_dir,\n\t\t\t\t     struct dentry *new_dentry)\n{\n\treturn 0;\n}\n\nstatic inline int security_path_rename(const struct path *old_dir,\n\t\t\t\t       struct dentry *old_dentry,\n\t\t\t\t       const struct path *new_dir,\n\t\t\t\t       struct dentry *new_dentry,\n\t\t\t\t       unsigned int flags)\n{\n\treturn 0;\n}\n\nstatic inline int security_path_chmod(const struct path *path, umode_t mode)\n{\n\treturn 0;\n}\n\nstatic inline int security_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n{\n\treturn 0;\n}\n\nstatic inline int security_path_chroot(const struct path *path)\n{\n\treturn 0;\n}\n#endif\t \n\n#ifdef CONFIG_KEYS\n#ifdef CONFIG_SECURITY\n\nint security_key_alloc(struct key *key, const struct cred *cred, unsigned long flags);\nvoid security_key_free(struct key *key);\nint security_key_permission(key_ref_t key_ref, const struct cred *cred,\n\t\t\t    enum key_need_perm need_perm);\nint security_key_getsecurity(struct key *key, char **_buffer);\n\n#else\n\nstatic inline int security_key_alloc(struct key *key,\n\t\t\t\t     const struct cred *cred,\n\t\t\t\t     unsigned long flags)\n{\n\treturn 0;\n}\n\nstatic inline void security_key_free(struct key *key)\n{\n}\n\nstatic inline int security_key_permission(key_ref_t key_ref,\n\t\t\t\t\t  const struct cred *cred,\n\t\t\t\t\t  enum key_need_perm need_perm)\n{\n\treturn 0;\n}\n\nstatic inline int security_key_getsecurity(struct key *key, char **_buffer)\n{\n\t*_buffer = NULL;\n\treturn 0;\n}\n\n#endif\n#endif  \n\n#ifdef CONFIG_AUDIT\n#ifdef CONFIG_SECURITY\nint security_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule);\nint security_audit_rule_known(struct audit_krule *krule);\nint security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule);\nvoid security_audit_rule_free(void *lsmrule);\n\n#else\n\nstatic inline int security_audit_rule_init(u32 field, u32 op, char *rulestr,\n\t\t\t\t\t   void **lsmrule)\n{\n\treturn 0;\n}\n\nstatic inline int security_audit_rule_known(struct audit_krule *krule)\n{\n\treturn 0;\n}\n\nstatic inline int security_audit_rule_match(u32 secid, u32 field, u32 op,\n\t\t\t\t\t    void *lsmrule)\n{\n\treturn 0;\n}\n\nstatic inline void security_audit_rule_free(void *lsmrule)\n{ }\n\n#endif  \n#endif  \n\n#ifdef CONFIG_SECURITYFS\n\nextern struct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t\t     struct dentry *parent, void *data,\n\t\t\t\t\t     const struct file_operations *fops);\nextern struct dentry *securityfs_create_dir(const char *name, struct dentry *parent);\nstruct dentry *securityfs_create_symlink(const char *name,\n\t\t\t\t\t struct dentry *parent,\n\t\t\t\t\t const char *target,\n\t\t\t\t\t const struct inode_operations *iops);\nextern void securityfs_remove(struct dentry *dentry);\n\n#else  \n\nstatic inline struct dentry *securityfs_create_dir(const char *name,\n\t\t\t\t\t\t   struct dentry *parent)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic inline struct dentry *securityfs_create_file(const char *name,\n\t\t\t\t\t\t    umode_t mode,\n\t\t\t\t\t\t    struct dentry *parent,\n\t\t\t\t\t\t    void *data,\n\t\t\t\t\t\t    const struct file_operations *fops)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic inline struct dentry *securityfs_create_symlink(const char *name,\n\t\t\t\t\tstruct dentry *parent,\n\t\t\t\t\tconst char *target,\n\t\t\t\t\tconst struct inode_operations *iops)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic inline void securityfs_remove(struct dentry *dentry)\n{}\n\n#endif\n\n#ifdef CONFIG_BPF_SYSCALL\nunion bpf_attr;\nstruct bpf_map;\nstruct bpf_prog;\nstruct bpf_prog_aux;\n#ifdef CONFIG_SECURITY\nextern int security_bpf(int cmd, union bpf_attr *attr, unsigned int size);\nextern int security_bpf_map(struct bpf_map *map, fmode_t fmode);\nextern int security_bpf_prog(struct bpf_prog *prog);\nextern int security_bpf_map_alloc(struct bpf_map *map);\nextern void security_bpf_map_free(struct bpf_map *map);\nextern int security_bpf_prog_alloc(struct bpf_prog_aux *aux);\nextern void security_bpf_prog_free(struct bpf_prog_aux *aux);\n#else\nstatic inline int security_bpf(int cmd, union bpf_attr *attr,\n\t\t\t\t\t     unsigned int size)\n{\n\treturn 0;\n}\n\nstatic inline int security_bpf_map(struct bpf_map *map, fmode_t fmode)\n{\n\treturn 0;\n}\n\nstatic inline int security_bpf_prog(struct bpf_prog *prog)\n{\n\treturn 0;\n}\n\nstatic inline int security_bpf_map_alloc(struct bpf_map *map)\n{\n\treturn 0;\n}\n\nstatic inline void security_bpf_map_free(struct bpf_map *map)\n{ }\n\nstatic inline int security_bpf_prog_alloc(struct bpf_prog_aux *aux)\n{\n\treturn 0;\n}\n\nstatic inline void security_bpf_prog_free(struct bpf_prog_aux *aux)\n{ }\n#endif  \n#endif  \n\n#ifdef CONFIG_PERF_EVENTS\nstruct perf_event_attr;\nstruct perf_event;\n\n#ifdef CONFIG_SECURITY\nextern int security_perf_event_open(struct perf_event_attr *attr, int type);\nextern int security_perf_event_alloc(struct perf_event *event);\nextern void security_perf_event_free(struct perf_event *event);\nextern int security_perf_event_read(struct perf_event *event);\nextern int security_perf_event_write(struct perf_event *event);\n#else\nstatic inline int security_perf_event_open(struct perf_event_attr *attr,\n\t\t\t\t\t   int type)\n{\n\treturn 0;\n}\n\nstatic inline int security_perf_event_alloc(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline void security_perf_event_free(struct perf_event *event)\n{\n}\n\nstatic inline int security_perf_event_read(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline int security_perf_event_write(struct perf_event *event)\n{\n\treturn 0;\n}\n#endif  \n#endif  \n\n#ifdef CONFIG_IO_URING\n#ifdef CONFIG_SECURITY\nextern int security_uring_override_creds(const struct cred *new);\nextern int security_uring_sqpoll(void);\nextern int security_uring_cmd(struct io_uring_cmd *ioucmd);\n#else\nstatic inline int security_uring_override_creds(const struct cred *new)\n{\n\treturn 0;\n}\nstatic inline int security_uring_sqpoll(void)\n{\n\treturn 0;\n}\nstatic inline int security_uring_cmd(struct io_uring_cmd *ioucmd)\n{\n\treturn 0;\n}\n#endif  \n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}