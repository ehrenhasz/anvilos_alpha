{
  "module_name": "idr.h",
  "hash_id": "060b5486ab74eb8e1fbd7b76e5cf901247b2f71f458c6fe6e42b4ef1ab672c6a",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/idr.h",
  "human_readable_source": " \n \n\n#ifndef __IDR_H__\n#define __IDR_H__\n\n#include <linux/radix-tree.h>\n#include <linux/gfp.h>\n#include <linux/percpu.h>\n\nstruct idr {\n\tstruct radix_tree_root\tidr_rt;\n\tunsigned int\t\tidr_base;\n\tunsigned int\t\tidr_next;\n};\n\n \n#define IDR_FREE\t0\n\n \n#define IDR_RT_MARKER\t(ROOT_IS_IDR | (__force gfp_t)\t\t\t\\\n\t\t\t\t\t(1 << (ROOT_TAG_SHIFT + IDR_FREE)))\n\n#define IDR_INIT_BASE(name, base) {\t\t\t\t\t\\\n\t.idr_rt = RADIX_TREE_INIT(name, IDR_RT_MARKER),\t\t\t\\\n\t.idr_base = (base),\t\t\t\t\t\t\\\n\t.idr_next = 0,\t\t\t\t\t\t\t\\\n}\n\n \n#define IDR_INIT(name)\tIDR_INIT_BASE(name, 0)\n\n \n#define DEFINE_IDR(name)\tstruct idr name = IDR_INIT(name)\n\n \nstatic inline unsigned int idr_get_cursor(const struct idr *idr)\n{\n\treturn READ_ONCE(idr->idr_next);\n}\n\n \nstatic inline void idr_set_cursor(struct idr *idr, unsigned int val)\n{\n\tWRITE_ONCE(idr->idr_next, val);\n}\n\n \n\n#define idr_lock(idr)\t\txa_lock(&(idr)->idr_rt)\n#define idr_unlock(idr)\t\txa_unlock(&(idr)->idr_rt)\n#define idr_lock_bh(idr)\txa_lock_bh(&(idr)->idr_rt)\n#define idr_unlock_bh(idr)\txa_unlock_bh(&(idr)->idr_rt)\n#define idr_lock_irq(idr)\txa_lock_irq(&(idr)->idr_rt)\n#define idr_unlock_irq(idr)\txa_unlock_irq(&(idr)->idr_rt)\n#define idr_lock_irqsave(idr, flags) \\\n\t\t\t\txa_lock_irqsave(&(idr)->idr_rt, flags)\n#define idr_unlock_irqrestore(idr, flags) \\\n\t\t\t\txa_unlock_irqrestore(&(idr)->idr_rt, flags)\n\nvoid idr_preload(gfp_t gfp_mask);\n\nint idr_alloc(struct idr *, void *ptr, int start, int end, gfp_t);\nint __must_check idr_alloc_u32(struct idr *, void *ptr, u32 *id,\n\t\t\t\tunsigned long max, gfp_t);\nint idr_alloc_cyclic(struct idr *, void *ptr, int start, int end, gfp_t);\nvoid *idr_remove(struct idr *, unsigned long id);\nvoid *idr_find(const struct idr *, unsigned long id);\nint idr_for_each(const struct idr *,\n\t\t int (*fn)(int id, void *p, void *data), void *data);\nvoid *idr_get_next(struct idr *, int *nextid);\nvoid *idr_get_next_ul(struct idr *, unsigned long *nextid);\nvoid *idr_replace(struct idr *, void *, unsigned long id);\nvoid idr_destroy(struct idr *);\n\n \nstatic inline void idr_init_base(struct idr *idr, int base)\n{\n\tINIT_RADIX_TREE(&idr->idr_rt, IDR_RT_MARKER);\n\tidr->idr_base = base;\n\tidr->idr_next = 0;\n}\n\n \nstatic inline void idr_init(struct idr *idr)\n{\n\tidr_init_base(idr, 0);\n}\n\n \nstatic inline bool idr_is_empty(const struct idr *idr)\n{\n\treturn radix_tree_empty(&idr->idr_rt) &&\n\t\tradix_tree_tagged(&idr->idr_rt, IDR_FREE);\n}\n\n \nstatic inline void idr_preload_end(void)\n{\n\tlocal_unlock(&radix_tree_preloads.lock);\n}\n\n \n#define idr_for_each_entry(idr, entry, id)\t\t\t\\\n\tfor (id = 0; ((entry) = idr_get_next(idr, &(id))) != NULL; id += 1U)\n\n \n#define idr_for_each_entry_ul(idr, entry, tmp, id)\t\t\t\\\n\tfor (tmp = 0, id = 0;\t\t\t\t\t\t\\\n\t     ((entry) = tmp <= id ? idr_get_next_ul(idr, &(id)) : NULL) != NULL; \\\n\t     tmp = id, ++id)\n\n \n#define idr_for_each_entry_continue(idr, entry, id)\t\t\t\\\n\tfor ((entry) = idr_get_next((idr), &(id));\t\t\t\\\n\t     entry;\t\t\t\t\t\t\t\\\n\t     ++id, (entry) = idr_get_next((idr), &(id)))\n\n \n#define idr_for_each_entry_continue_ul(idr, entry, tmp, id)\t\t\\\n\tfor (tmp = id;\t\t\t\t\t\t\t\\\n\t     ((entry) = tmp <= id ? idr_get_next_ul(idr, &(id)) : NULL) != NULL; \\\n\t     tmp = id, ++id)\n\n \n#define IDA_CHUNK_SIZE\t\t128\t \n#define IDA_BITMAP_LONGS\t(IDA_CHUNK_SIZE / sizeof(long))\n#define IDA_BITMAP_BITS \t(IDA_BITMAP_LONGS * sizeof(long) * 8)\n\nstruct ida_bitmap {\n\tunsigned long\t\tbitmap[IDA_BITMAP_LONGS];\n};\n\nstruct ida {\n\tstruct xarray xa;\n};\n\n#define IDA_INIT_FLAGS\t(XA_FLAGS_LOCK_IRQ | XA_FLAGS_ALLOC)\n\n#define IDA_INIT(name)\t{\t\t\t\t\t\t\\\n\t.xa = XARRAY_INIT(name, IDA_INIT_FLAGS)\t\t\t\t\\\n}\n#define DEFINE_IDA(name)\tstruct ida name = IDA_INIT(name)\n\nint ida_alloc_range(struct ida *, unsigned int min, unsigned int max, gfp_t);\nvoid ida_free(struct ida *, unsigned int id);\nvoid ida_destroy(struct ida *ida);\n\n \nstatic inline int ida_alloc(struct ida *ida, gfp_t gfp)\n{\n\treturn ida_alloc_range(ida, 0, ~0, gfp);\n}\n\n \nstatic inline int ida_alloc_min(struct ida *ida, unsigned int min, gfp_t gfp)\n{\n\treturn ida_alloc_range(ida, min, ~0, gfp);\n}\n\n \nstatic inline int ida_alloc_max(struct ida *ida, unsigned int max, gfp_t gfp)\n{\n\treturn ida_alloc_range(ida, 0, max, gfp);\n}\n\nstatic inline void ida_init(struct ida *ida)\n{\n\txa_init_flags(&ida->xa, IDA_INIT_FLAGS);\n}\n\n \n#define ida_simple_get(ida, start, end, gfp)\t\\\n\t\t\tida_alloc_range(ida, start, (end) - 1, gfp)\n#define ida_simple_remove(ida, id)\tida_free(ida, id)\n\nstatic inline bool ida_is_empty(const struct ida *ida)\n{\n\treturn xa_empty(&ida->xa);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}