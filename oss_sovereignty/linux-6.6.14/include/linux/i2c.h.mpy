{
  "module_name": "i2c.h",
  "hash_id": "b2c9f0fc7165a85679d1169c2db0efc60b41d1a76632e8b2dfcdd156d860c22b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/i2c.h",
  "human_readable_source": " \n \n#ifndef _LINUX_I2C_H\n#define _LINUX_I2C_H\n\n#include <linux/acpi.h>\t\t \n#include <linux/bits.h>\n#include <linux/mod_devicetable.h>\n#include <linux/device.h>\t \n#include <linux/sched.h>\t \n#include <linux/mutex.h>\n#include <linux/regulator/consumer.h>\n#include <linux/rtmutex.h>\n#include <linux/irqdomain.h>\t\t \n#include <linux/of.h>\t\t \n#include <linux/swab.h>\t\t \n#include <uapi/linux/i2c.h>\n\nextern struct bus_type i2c_bus_type;\nextern struct device_type i2c_adapter_type;\nextern struct device_type i2c_client_type;\n\n \n\nstruct i2c_msg;\nstruct i2c_algorithm;\nstruct i2c_adapter;\nstruct i2c_client;\nstruct i2c_driver;\nstruct i2c_device_identity;\nunion i2c_smbus_data;\nstruct i2c_board_info;\nenum i2c_slave_event;\ntypedef int (*i2c_slave_cb_t)(struct i2c_client *client,\n\t\t\t      enum i2c_slave_event event, u8 *val);\n\n \n#define I2C_MAX_STANDARD_MODE_FREQ\t100000\n#define I2C_MAX_FAST_MODE_FREQ\t\t400000\n#define I2C_MAX_FAST_MODE_PLUS_FREQ\t1000000\n#define I2C_MAX_TURBO_MODE_FREQ\t\t1400000\n#define I2C_MAX_HIGH_SPEED_MODE_FREQ\t3400000\n#define I2C_MAX_ULTRA_FAST_MODE_FREQ\t5000000\n\nstruct module;\nstruct property_entry;\n\n#if IS_ENABLED(CONFIG_I2C)\n \nconst char *i2c_freq_mode_string(u32 bus_freq_hz);\n\n \nint i2c_transfer_buffer_flags(const struct i2c_client *client,\n\t\t\t      char *buf, int count, u16 flags);\n\n \nstatic inline int i2c_master_recv(const struct i2c_client *client,\n\t\t\t\t  char *buf, int count)\n{\n\treturn i2c_transfer_buffer_flags(client, buf, count, I2C_M_RD);\n};\n\n \nstatic inline int i2c_master_recv_dmasafe(const struct i2c_client *client,\n\t\t\t\t\t  char *buf, int count)\n{\n\treturn i2c_transfer_buffer_flags(client, buf, count,\n\t\t\t\t\t I2C_M_RD | I2C_M_DMA_SAFE);\n};\n\n \nstatic inline int i2c_master_send(const struct i2c_client *client,\n\t\t\t\t  const char *buf, int count)\n{\n\treturn i2c_transfer_buffer_flags(client, (char *)buf, count, 0);\n};\n\n \nstatic inline int i2c_master_send_dmasafe(const struct i2c_client *client,\n\t\t\t\t\t  const char *buf, int count)\n{\n\treturn i2c_transfer_buffer_flags(client, (char *)buf, count,\n\t\t\t\t\t I2C_M_DMA_SAFE);\n};\n\n \nint i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);\n \nint __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);\n\n \ns32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\n\t\t   unsigned short flags, char read_write, u8 command,\n\t\t   int protocol, union i2c_smbus_data *data);\n\n \ns32 __i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\n\t\t     unsigned short flags, char read_write, u8 command,\n\t\t     int protocol, union i2c_smbus_data *data);\n\n \n\nu8 i2c_smbus_pec(u8 crc, u8 *p, size_t count);\ns32 i2c_smbus_read_byte(const struct i2c_client *client);\ns32 i2c_smbus_write_byte(const struct i2c_client *client, u8 value);\ns32 i2c_smbus_read_byte_data(const struct i2c_client *client, u8 command);\ns32 i2c_smbus_write_byte_data(const struct i2c_client *client,\n\t\t\t      u8 command, u8 value);\ns32 i2c_smbus_read_word_data(const struct i2c_client *client, u8 command);\ns32 i2c_smbus_write_word_data(const struct i2c_client *client,\n\t\t\t      u8 command, u16 value);\n\nstatic inline s32\ni2c_smbus_read_word_swapped(const struct i2c_client *client, u8 command)\n{\n\ts32 value = i2c_smbus_read_word_data(client, command);\n\n\treturn (value < 0) ? value : swab16(value);\n}\n\nstatic inline s32\ni2c_smbus_write_word_swapped(const struct i2c_client *client,\n\t\t\t     u8 command, u16 value)\n{\n\treturn i2c_smbus_write_word_data(client, command, swab16(value));\n}\n\n \ns32 i2c_smbus_read_block_data(const struct i2c_client *client,\n\t\t\t      u8 command, u8 *values);\ns32 i2c_smbus_write_block_data(const struct i2c_client *client,\n\t\t\t       u8 command, u8 length, const u8 *values);\n \ns32 i2c_smbus_read_i2c_block_data(const struct i2c_client *client,\n\t\t\t\t  u8 command, u8 length, u8 *values);\ns32 i2c_smbus_write_i2c_block_data(const struct i2c_client *client,\n\t\t\t\t   u8 command, u8 length, const u8 *values);\ns32 i2c_smbus_read_i2c_block_data_or_emulated(const struct i2c_client *client,\n\t\t\t\t\t      u8 command, u8 length,\n\t\t\t\t\t      u8 *values);\nint i2c_get_device_id(const struct i2c_client *client,\n\t\t      struct i2c_device_identity *id);\nconst struct i2c_device_id *i2c_client_get_device_id(const struct i2c_client *client);\n#endif  \n\n \nstruct i2c_device_identity {\n\tu16 manufacturer_id;\n#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS                0\n#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_1              1\n#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_2              2\n#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_3              3\n#define I2C_DEVICE_ID_RAMTRON_INTERNATIONAL             4\n#define I2C_DEVICE_ID_ANALOG_DEVICES                    5\n#define I2C_DEVICE_ID_STMICROELECTRONICS                6\n#define I2C_DEVICE_ID_ON_SEMICONDUCTOR                  7\n#define I2C_DEVICE_ID_SPRINTEK_CORPORATION              8\n#define I2C_DEVICE_ID_ESPROS_PHOTONICS_AG               9\n#define I2C_DEVICE_ID_FUJITSU_SEMICONDUCTOR            10\n#define I2C_DEVICE_ID_FLIR                             11\n#define I2C_DEVICE_ID_O2MICRO                          12\n#define I2C_DEVICE_ID_ATMEL                            13\n#define I2C_DEVICE_ID_NONE                         0xffff\n\tu16 part_id;\n\tu8 die_revision;\n};\n\nenum i2c_alert_protocol {\n\tI2C_PROTOCOL_SMBUS_ALERT,\n\tI2C_PROTOCOL_SMBUS_HOST_NOTIFY,\n};\n\n \nenum i2c_driver_flags {\n\tI2C_DRV_ACPI_WAIVE_D0_PROBE = BIT(0),\n};\n\n \nstruct i2c_driver {\n\tunsigned int class;\n\n\t \n\tint (*probe)(struct i2c_client *client);\n\tvoid (*remove)(struct i2c_client *client);\n\n\n\t \n\tvoid (*shutdown)(struct i2c_client *client);\n\n\t \n\tvoid (*alert)(struct i2c_client *client, enum i2c_alert_protocol protocol,\n\t\t      unsigned int data);\n\n\t \n\tint (*command)(struct i2c_client *client, unsigned int cmd, void *arg);\n\n\tstruct device_driver driver;\n\tconst struct i2c_device_id *id_table;\n\n\t \n\tint (*detect)(struct i2c_client *client, struct i2c_board_info *info);\n\tconst unsigned short *address_list;\n\tstruct list_head clients;\n\n\tu32 flags;\n};\n#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)\n\n \nstruct i2c_client {\n\tunsigned short flags;\t\t \n#define I2C_CLIENT_PEC\t\t0x04\t \n#define I2C_CLIENT_TEN\t\t0x10\t \n\t\t\t\t\t \n#define I2C_CLIENT_SLAVE\t0x20\t \n#define I2C_CLIENT_HOST_NOTIFY\t0x40\t \n#define I2C_CLIENT_WAKE\t\t0x80\t \n#define I2C_CLIENT_SCCB\t\t0x9000\t \n\t\t\t\t\t \n\n\tunsigned short addr;\t\t \n\t\t\t\t\t \n\t\t\t\t\t \n\tchar name[I2C_NAME_SIZE];\n\tstruct i2c_adapter *adapter;\t \n\tstruct device dev;\t\t \n\tint init_irq;\t\t\t \n\tint irq;\t\t\t \n\tstruct list_head detected;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\ti2c_slave_cb_t slave_cb;\t \n#endif\n\tvoid *devres_group_id;\t\t \n};\n#define to_i2c_client(d) container_of(d, struct i2c_client, dev)\n\nstruct i2c_adapter *i2c_verify_adapter(struct device *dev);\nconst struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,\n\t\t\t\t\t const struct i2c_client *client);\n\nconst void *i2c_get_match_data(const struct i2c_client *client);\n\nstatic inline struct i2c_client *kobj_to_i2c_client(struct kobject *kobj)\n{\n\tstruct device * const dev = kobj_to_dev(kobj);\n\treturn to_i2c_client(dev);\n}\n\nstatic inline void *i2c_get_clientdata(const struct i2c_client *client)\n{\n\treturn dev_get_drvdata(&client->dev);\n}\n\nstatic inline void i2c_set_clientdata(struct i2c_client *client, void *data)\n{\n\tdev_set_drvdata(&client->dev, data);\n}\n\n \n\nenum i2c_slave_event {\n\tI2C_SLAVE_READ_REQUESTED,\n\tI2C_SLAVE_WRITE_REQUESTED,\n\tI2C_SLAVE_READ_PROCESSED,\n\tI2C_SLAVE_WRITE_RECEIVED,\n\tI2C_SLAVE_STOP,\n};\n\nint i2c_slave_register(struct i2c_client *client, i2c_slave_cb_t slave_cb);\nint i2c_slave_unregister(struct i2c_client *client);\nint i2c_slave_event(struct i2c_client *client,\n\t\t    enum i2c_slave_event event, u8 *val);\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\nbool i2c_detect_slave_mode(struct device *dev);\n#else\nstatic inline bool i2c_detect_slave_mode(struct device *dev) { return false; }\n#endif\n\n \nstruct i2c_board_info {\n\tchar\t\ttype[I2C_NAME_SIZE];\n\tunsigned short\tflags;\n\tunsigned short\taddr;\n\tconst char\t*dev_name;\n\tvoid\t\t*platform_data;\n\tstruct device_node *of_node;\n\tstruct fwnode_handle *fwnode;\n\tconst struct software_node *swnode;\n\tconst struct resource *resources;\n\tunsigned int\tnum_resources;\n\tint\t\tirq;\n};\n\n \n#define I2C_BOARD_INFO(dev_type, dev_addr) \\\n\t.type = dev_type, .addr = (dev_addr)\n\n\n#if IS_ENABLED(CONFIG_I2C)\n \nstruct i2c_client *\ni2c_new_client_device(struct i2c_adapter *adap, struct i2c_board_info const *info);\n\n \nstruct i2c_client *\ni2c_new_scanned_device(struct i2c_adapter *adap,\n\t\t       struct i2c_board_info *info,\n\t\t       unsigned short const *addr_list,\n\t\t       int (*probe)(struct i2c_adapter *adap, unsigned short addr));\n\n \nint i2c_probe_func_quick_read(struct i2c_adapter *adap, unsigned short addr);\n\nstruct i2c_client *\ni2c_new_dummy_device(struct i2c_adapter *adapter, u16 address);\n\nstruct i2c_client *\ndevm_i2c_new_dummy_device(struct device *dev, struct i2c_adapter *adap, u16 address);\n\nstruct i2c_client *\ni2c_new_ancillary_device(struct i2c_client *client,\n\t\t\t const char *name,\n\t\t\t u16 default_addr);\n\nvoid i2c_unregister_device(struct i2c_client *client);\n\nstruct i2c_client *i2c_verify_client(struct device *dev);\n#else\nstatic inline struct i2c_client *i2c_verify_client(struct device *dev)\n{\n\treturn NULL;\n}\n#endif  \n\n \n#ifdef CONFIG_I2C_BOARDINFO\nint\ni2c_register_board_info(int busnum, struct i2c_board_info const *info,\n\t\t\tunsigned n);\n#else\nstatic inline int\ni2c_register_board_info(int busnum, struct i2c_board_info const *info,\n\t\t\tunsigned n)\n{\n\treturn 0;\n}\n#endif  \n\n \nstruct i2c_algorithm {\n\t \n\tint (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t   int num);\n\tint (*master_xfer_atomic)(struct i2c_adapter *adap,\n\t\t\t\t   struct i2c_msg *msgs, int num);\n\tint (*smbus_xfer)(struct i2c_adapter *adap, u16 addr,\n\t\t\t  unsigned short flags, char read_write,\n\t\t\t  u8 command, int size, union i2c_smbus_data *data);\n\tint (*smbus_xfer_atomic)(struct i2c_adapter *adap, u16 addr,\n\t\t\t\t unsigned short flags, char read_write,\n\t\t\t\t u8 command, int size, union i2c_smbus_data *data);\n\n\t \n\tu32 (*functionality)(struct i2c_adapter *adap);\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tint (*reg_slave)(struct i2c_client *client);\n\tint (*unreg_slave)(struct i2c_client *client);\n#endif\n};\n\n \nstruct i2c_lock_operations {\n\tvoid (*lock_bus)(struct i2c_adapter *adapter, unsigned int flags);\n\tint (*trylock_bus)(struct i2c_adapter *adapter, unsigned int flags);\n\tvoid (*unlock_bus)(struct i2c_adapter *adapter, unsigned int flags);\n};\n\n \nstruct i2c_timings {\n\tu32 bus_freq_hz;\n\tu32 scl_rise_ns;\n\tu32 scl_fall_ns;\n\tu32 scl_int_delay_ns;\n\tu32 sda_fall_ns;\n\tu32 sda_hold_ns;\n\tu32 digital_filter_width_ns;\n\tu32 analog_filter_cutoff_freq_hz;\n};\n\n \nstruct i2c_bus_recovery_info {\n\tint (*recover_bus)(struct i2c_adapter *adap);\n\n\tint (*get_scl)(struct i2c_adapter *adap);\n\tvoid (*set_scl)(struct i2c_adapter *adap, int val);\n\tint (*get_sda)(struct i2c_adapter *adap);\n\tvoid (*set_sda)(struct i2c_adapter *adap, int val);\n\tint (*get_bus_free)(struct i2c_adapter *adap);\n\n\tvoid (*prepare_recovery)(struct i2c_adapter *adap);\n\tvoid (*unprepare_recovery)(struct i2c_adapter *adap);\n\n\t \n\tstruct gpio_desc *scl_gpiod;\n\tstruct gpio_desc *sda_gpiod;\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pins_default;\n\tstruct pinctrl_state *pins_gpio;\n};\n\nint i2c_recover_bus(struct i2c_adapter *adap);\n\n \nint i2c_generic_scl_recovery(struct i2c_adapter *adap);\n\n \n\nstruct i2c_adapter_quirks {\n\tu64 flags;\n\tint max_num_msgs;\n\tu16 max_write_len;\n\tu16 max_read_len;\n\tu16 max_comb_1st_msg_len;\n\tu16 max_comb_2nd_msg_len;\n};\n\n \n#define I2C_AQ_COMB\t\t\tBIT(0)\n \n#define I2C_AQ_COMB_WRITE_FIRST\t\tBIT(1)\n \n#define I2C_AQ_COMB_READ_SECOND\t\tBIT(2)\n \n#define I2C_AQ_COMB_SAME_ADDR\t\tBIT(3)\n \n#define I2C_AQ_COMB_WRITE_THEN_READ\t(I2C_AQ_COMB | I2C_AQ_COMB_WRITE_FIRST | \\\n\t\t\t\t\t I2C_AQ_COMB_READ_SECOND | I2C_AQ_COMB_SAME_ADDR)\n \n#define I2C_AQ_NO_CLK_STRETCH\t\tBIT(4)\n \n#define I2C_AQ_NO_ZERO_LEN_READ\t\tBIT(5)\n#define I2C_AQ_NO_ZERO_LEN_WRITE\tBIT(6)\n#define I2C_AQ_NO_ZERO_LEN\t\t(I2C_AQ_NO_ZERO_LEN_READ | I2C_AQ_NO_ZERO_LEN_WRITE)\n \n#define I2C_AQ_NO_REP_START\t\tBIT(7)\n\n \nstruct i2c_adapter {\n\tstruct module *owner;\n\tunsigned int class;\t\t   \n\tconst struct i2c_algorithm *algo;  \n\tvoid *algo_data;\n\n\t \n\tconst struct i2c_lock_operations *lock_ops;\n\tstruct rt_mutex bus_lock;\n\tstruct rt_mutex mux_lock;\n\n\tint timeout;\t\t\t \n\tint retries;\n\tstruct device dev;\t\t \n\tunsigned long locked_flags;\t \n#define I2C_ALF_IS_SUSPENDED\t\t0\n#define I2C_ALF_SUSPEND_REPORTED\t1\n\n\tint nr;\n\tchar name[48];\n\tstruct completion dev_released;\n\n\tstruct mutex userspace_clients_lock;\n\tstruct list_head userspace_clients;\n\n\tstruct i2c_bus_recovery_info *bus_recovery_info;\n\tconst struct i2c_adapter_quirks *quirks;\n\n\tstruct irq_domain *host_notify_domain;\n\tstruct regulator *bus_regulator;\n};\n#define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)\n\nstatic inline void *i2c_get_adapdata(const struct i2c_adapter *adap)\n{\n\treturn dev_get_drvdata(&adap->dev);\n}\n\nstatic inline void i2c_set_adapdata(struct i2c_adapter *adap, void *data)\n{\n\tdev_set_drvdata(&adap->dev, data);\n}\n\nstatic inline struct i2c_adapter *\ni2c_parent_is_i2c_adapter(const struct i2c_adapter *adapter)\n{\n#if IS_ENABLED(CONFIG_I2C_MUX)\n\tstruct device *parent = adapter->dev.parent;\n\n\tif (parent != NULL && parent->type == &i2c_adapter_type)\n\t\treturn to_i2c_adapter(parent);\n\telse\n#endif\n\t\treturn NULL;\n}\n\nint i2c_for_each_dev(void *data, int (*fn)(struct device *dev, void *data));\n\n \n#define I2C_LOCK_ROOT_ADAPTER BIT(0)\n#define I2C_LOCK_SEGMENT      BIT(1)\n\n \nstatic inline void\ni2c_lock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\tadapter->lock_ops->lock_bus(adapter, flags);\n}\n\n \nstatic inline int\ni2c_trylock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\treturn adapter->lock_ops->trylock_bus(adapter, flags);\n}\n\n \nstatic inline void\ni2c_unlock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\tadapter->lock_ops->unlock_bus(adapter, flags);\n}\n\n \nstatic inline void i2c_mark_adapter_suspended(struct i2c_adapter *adap)\n{\n\ti2c_lock_bus(adap, I2C_LOCK_ROOT_ADAPTER);\n\tset_bit(I2C_ALF_IS_SUSPENDED, &adap->locked_flags);\n\ti2c_unlock_bus(adap, I2C_LOCK_ROOT_ADAPTER);\n}\n\n \nstatic inline void i2c_mark_adapter_resumed(struct i2c_adapter *adap)\n{\n\ti2c_lock_bus(adap, I2C_LOCK_ROOT_ADAPTER);\n\tclear_bit(I2C_ALF_IS_SUSPENDED, &adap->locked_flags);\n\ti2c_unlock_bus(adap, I2C_LOCK_ROOT_ADAPTER);\n}\n\n \n#define I2C_CLASS_HWMON\t\t(1<<0)\t \n#define I2C_CLASS_DDC\t\t(1<<3)\t \n#define I2C_CLASS_SPD\t\t(1<<7)\t \n \n#define I2C_CLASS_DEPRECATED\t(1<<8)\n\n \n#define I2C_CLIENT_END\t\t0xfffeU\n\n \n#define I2C_ADDRS(addr, addrs...) \\\n\t((const unsigned short []){ addr, ## addrs, I2C_CLIENT_END })\n\n\n \n\n \n#if IS_ENABLED(CONFIG_I2C)\nint i2c_add_adapter(struct i2c_adapter *adap);\nint devm_i2c_add_adapter(struct device *dev, struct i2c_adapter *adapter);\nvoid i2c_del_adapter(struct i2c_adapter *adap);\nint i2c_add_numbered_adapter(struct i2c_adapter *adap);\n\nint i2c_register_driver(struct module *owner, struct i2c_driver *driver);\nvoid i2c_del_driver(struct i2c_driver *driver);\n\n \n#define i2c_add_driver(driver) \\\n\ti2c_register_driver(THIS_MODULE, driver)\n\nstatic inline bool i2c_client_has_driver(struct i2c_client *client)\n{\n\treturn !IS_ERR_OR_NULL(client) && client->dev.driver;\n}\n\n \nvoid i2c_clients_command(struct i2c_adapter *adap,\n\t\t\t unsigned int cmd, void *arg);\n\nstruct i2c_adapter *i2c_get_adapter(int nr);\nvoid i2c_put_adapter(struct i2c_adapter *adap);\nunsigned int i2c_adapter_depth(struct i2c_adapter *adapter);\n\nvoid i2c_parse_fw_timings(struct device *dev, struct i2c_timings *t, bool use_defaults);\n\n \nstatic inline u32 i2c_get_functionality(struct i2c_adapter *adap)\n{\n\treturn adap->algo->functionality(adap);\n}\n\n \nstatic inline int i2c_check_functionality(struct i2c_adapter *adap, u32 func)\n{\n\treturn (func & i2c_get_functionality(adap)) == func;\n}\n\n \nstatic inline bool i2c_check_quirks(struct i2c_adapter *adap, u64 quirks)\n{\n\tif (!adap->quirks)\n\t\treturn false;\n\treturn (adap->quirks->flags & quirks) == quirks;\n}\n\n \nstatic inline int i2c_adapter_id(struct i2c_adapter *adap)\n{\n\treturn adap->nr;\n}\n\nstatic inline u8 i2c_8bit_addr_from_msg(const struct i2c_msg *msg)\n{\n\treturn (msg->addr << 1) | (msg->flags & I2C_M_RD ? 1 : 0);\n}\n\nu8 *i2c_get_dma_safe_msg_buf(struct i2c_msg *msg, unsigned int threshold);\nvoid i2c_put_dma_safe_msg_buf(u8 *buf, struct i2c_msg *msg, bool xferred);\n\nint i2c_handle_smbus_host_notify(struct i2c_adapter *adap, unsigned short addr);\n \n#define module_i2c_driver(__i2c_driver) \\\n\tmodule_driver(__i2c_driver, i2c_add_driver, \\\n\t\t\ti2c_del_driver)\n\n \n#define builtin_i2c_driver(__i2c_driver) \\\n\tbuiltin_driver(__i2c_driver, i2c_add_driver)\n\n#endif  \n\n \nstruct i2c_client *i2c_find_device_by_fwnode(struct fwnode_handle *fwnode);\n\n \nstruct i2c_adapter *i2c_find_adapter_by_fwnode(struct fwnode_handle *fwnode);\n\n \nstruct i2c_adapter *i2c_get_adapter_by_fwnode(struct fwnode_handle *fwnode);\n\n#if IS_ENABLED(CONFIG_OF)\n \nstatic inline struct i2c_client *of_find_i2c_device_by_node(struct device_node *node)\n{\n\treturn i2c_find_device_by_fwnode(of_fwnode_handle(node));\n}\n\n \nstatic inline struct i2c_adapter *of_find_i2c_adapter_by_node(struct device_node *node)\n{\n\treturn i2c_find_adapter_by_fwnode(of_fwnode_handle(node));\n}\n\n \nstatic inline struct i2c_adapter *of_get_i2c_adapter_by_node(struct device_node *node)\n{\n\treturn i2c_get_adapter_by_fwnode(of_fwnode_handle(node));\n}\n\nconst struct of_device_id\n*i2c_of_match_device(const struct of_device_id *matches,\n\t\t     struct i2c_client *client);\n\nint of_i2c_get_board_info(struct device *dev, struct device_node *node,\n\t\t\t  struct i2c_board_info *info);\n\n#else\n\nstatic inline struct i2c_client *of_find_i2c_device_by_node(struct device_node *node)\n{\n\treturn NULL;\n}\n\nstatic inline struct i2c_adapter *of_find_i2c_adapter_by_node(struct device_node *node)\n{\n\treturn NULL;\n}\n\nstatic inline struct i2c_adapter *of_get_i2c_adapter_by_node(struct device_node *node)\n{\n\treturn NULL;\n}\n\nstatic inline const struct of_device_id\n*i2c_of_match_device(const struct of_device_id *matches,\n\t\t     struct i2c_client *client)\n{\n\treturn NULL;\n}\n\nstatic inline int of_i2c_get_board_info(struct device *dev,\n\t\t\t\t\tstruct device_node *node,\n\t\t\t\t\tstruct i2c_board_info *info)\n{\n\treturn -ENOTSUPP;\n}\n\n#endif  \n\nstruct acpi_resource;\nstruct acpi_resource_i2c_serialbus;\n\n#if IS_ENABLED(CONFIG_ACPI)\nbool i2c_acpi_get_i2c_resource(struct acpi_resource *ares,\n\t\t\t       struct acpi_resource_i2c_serialbus **i2c);\nint i2c_acpi_client_count(struct acpi_device *adev);\nu32 i2c_acpi_find_bus_speed(struct device *dev);\nstruct i2c_client *i2c_acpi_new_device_by_fwnode(struct fwnode_handle *fwnode,\n\t\t\t\t\t\t int index,\n\t\t\t\t\t\t struct i2c_board_info *info);\nstruct i2c_adapter *i2c_acpi_find_adapter_by_handle(acpi_handle handle);\nbool i2c_acpi_waive_d0_probe(struct device *dev);\n#else\nstatic inline bool i2c_acpi_get_i2c_resource(struct acpi_resource *ares,\n\t\t\t\t\t     struct acpi_resource_i2c_serialbus **i2c)\n{\n\treturn false;\n}\nstatic inline int i2c_acpi_client_count(struct acpi_device *adev)\n{\n\treturn 0;\n}\nstatic inline u32 i2c_acpi_find_bus_speed(struct device *dev)\n{\n\treturn 0;\n}\nstatic inline struct i2c_client *i2c_acpi_new_device_by_fwnode(\n\t\t\t\t\tstruct fwnode_handle *fwnode, int index,\n\t\t\t\t\tstruct i2c_board_info *info)\n{\n\treturn ERR_PTR(-ENODEV);\n}\nstatic inline struct i2c_adapter *i2c_acpi_find_adapter_by_handle(acpi_handle handle)\n{\n\treturn NULL;\n}\nstatic inline bool i2c_acpi_waive_d0_probe(struct device *dev)\n{\n\treturn false;\n}\n#endif  \n\nstatic inline struct i2c_client *i2c_acpi_new_device(struct device *dev,\n\t\t\t\t\t\t     int index,\n\t\t\t\t\t\t     struct i2c_board_info *info)\n{\n\treturn i2c_acpi_new_device_by_fwnode(dev_fwnode(dev), index, info);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}