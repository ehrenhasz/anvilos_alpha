{
  "module_name": "local_lock_internal.h",
  "hash_id": "729b9c1c531bdeb92e728ce0c29b21bf2678ac47a884cd379c1a19bbfb27ce94",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/local_lock_internal.h",
  "human_readable_source": " \n#ifndef _LINUX_LOCAL_LOCK_H\n# error \"Do not include directly, include linux/local_lock.h\"\n#endif\n\n#include <linux/percpu-defs.h>\n#include <linux/lockdep.h>\n\n#ifndef CONFIG_PREEMPT_RT\n\ntypedef struct {\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tstruct lockdep_map\tdep_map;\n\tstruct task_struct\t*owner;\n#endif\n} local_lock_t;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n# define LOCAL_LOCK_DEBUG_INIT(lockname)\t\t\\\n\t.dep_map = {\t\t\t\t\t\\\n\t\t.name = #lockname,\t\t\t\\\n\t\t.wait_type_inner = LD_WAIT_CONFIG,\t\\\n\t\t.lock_type = LD_LOCK_PERCPU,\t\t\\\n\t},\t\t\t\t\t\t\\\n\t.owner = NULL,\n\nstatic inline void local_lock_acquire(local_lock_t *l)\n{\n\tlock_map_acquire(&l->dep_map);\n\tDEBUG_LOCKS_WARN_ON(l->owner);\n\tl->owner = current;\n}\n\nstatic inline void local_lock_release(local_lock_t *l)\n{\n\tDEBUG_LOCKS_WARN_ON(l->owner != current);\n\tl->owner = NULL;\n\tlock_map_release(&l->dep_map);\n}\n\nstatic inline void local_lock_debug_init(local_lock_t *l)\n{\n\tl->owner = NULL;\n}\n#else  \n# define LOCAL_LOCK_DEBUG_INIT(lockname)\nstatic inline void local_lock_acquire(local_lock_t *l) { }\nstatic inline void local_lock_release(local_lock_t *l) { }\nstatic inline void local_lock_debug_init(local_lock_t *l) { }\n#endif  \n\n#define INIT_LOCAL_LOCK(lockname)\t{ LOCAL_LOCK_DEBUG_INIT(lockname) }\n\n#define __local_lock_init(lock)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\\\n\tlockdep_init_map_type(&(lock)->dep_map, #lock, &__key,  \\\n\t\t\t      0, LD_WAIT_CONFIG, LD_WAIT_INV,\t\\\n\t\t\t      LD_LOCK_PERCPU);\t\t\t\\\n\tlocal_lock_debug_init(lock);\t\t\t\t\\\n} while (0)\n\n#define __local_lock(lock)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tpreempt_disable();\t\t\t\t\\\n\t\tlocal_lock_acquire(this_cpu_ptr(lock));\t\t\\\n\t} while (0)\n\n#define __local_lock_irq(lock)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tlocal_irq_disable();\t\t\t\t\\\n\t\tlocal_lock_acquire(this_cpu_ptr(lock));\t\t\\\n\t} while (0)\n\n#define __local_lock_irqsave(lock, flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tlocal_irq_save(flags);\t\t\t\t\\\n\t\tlocal_lock_acquire(this_cpu_ptr(lock));\t\t\\\n\t} while (0)\n\n#define __local_unlock(lock)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tlocal_lock_release(this_cpu_ptr(lock));\t\t\\\n\t\tpreempt_enable();\t\t\t\t\\\n\t} while (0)\n\n#define __local_unlock_irq(lock)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tlocal_lock_release(this_cpu_ptr(lock));\t\t\\\n\t\tlocal_irq_enable();\t\t\t\t\\\n\t} while (0)\n\n#define __local_unlock_irqrestore(lock, flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tlocal_lock_release(this_cpu_ptr(lock));\t\t\\\n\t\tlocal_irq_restore(flags);\t\t\t\\\n\t} while (0)\n\n#else  \n\n \ntypedef spinlock_t local_lock_t;\n\n#define INIT_LOCAL_LOCK(lockname) __LOCAL_SPIN_LOCK_UNLOCKED((lockname))\n\n#define __local_lock_init(l)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tlocal_spin_lock_init((l));\t\t\t\\\n\t} while (0)\n\n#define __local_lock(__lock)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tmigrate_disable();\t\t\t\t\\\n\t\tspin_lock(this_cpu_ptr((__lock)));\t\t\\\n\t} while (0)\n\n#define __local_lock_irq(lock)\t\t\t__local_lock(lock)\n\n#define __local_lock_irqsave(lock, flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\t\\\n\t\tflags = 0;\t\t\t\t\t\\\n\t\t__local_lock(lock);\t\t\t\t\\\n\t} while (0)\n\n#define __local_unlock(__lock)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tspin_unlock(this_cpu_ptr((__lock)));\t\t\\\n\t\tmigrate_enable();\t\t\t\t\\\n\t} while (0)\n\n#define __local_unlock_irq(lock)\t\t__local_unlock(lock)\n\n#define __local_unlock_irqrestore(lock, flags)\t__local_unlock(lock)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}