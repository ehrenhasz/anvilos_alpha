{
  "module_name": "irq.h",
  "hash_id": "59d56212c1229083be786c9dc7e942925d94dd96a0fc9470bc7715c62a546afb",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/irq.h",
  "human_readable_source": " \n#ifndef _LINUX_IRQ_H\n#define _LINUX_IRQ_H\n\n \n\n#include <linux/cache.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/irqhandler.h>\n#include <linux/irqreturn.h>\n#include <linux/irqnr.h>\n#include <linux/topology.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include <asm/irq.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n\nstruct seq_file;\nstruct module;\nstruct msi_msg;\nstruct irq_affinity_desc;\nenum irqchip_irq_state;\n\n \nenum {\n\tIRQ_TYPE_NONE\t\t= 0x00000000,\n\tIRQ_TYPE_EDGE_RISING\t= 0x00000001,\n\tIRQ_TYPE_EDGE_FALLING\t= 0x00000002,\n\tIRQ_TYPE_EDGE_BOTH\t= (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING),\n\tIRQ_TYPE_LEVEL_HIGH\t= 0x00000004,\n\tIRQ_TYPE_LEVEL_LOW\t= 0x00000008,\n\tIRQ_TYPE_LEVEL_MASK\t= (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH),\n\tIRQ_TYPE_SENSE_MASK\t= 0x0000000f,\n\tIRQ_TYPE_DEFAULT\t= IRQ_TYPE_SENSE_MASK,\n\n\tIRQ_TYPE_PROBE\t\t= 0x00000010,\n\n\tIRQ_LEVEL\t\t= (1 <<  8),\n\tIRQ_PER_CPU\t\t= (1 <<  9),\n\tIRQ_NOPROBE\t\t= (1 << 10),\n\tIRQ_NOREQUEST\t\t= (1 << 11),\n\tIRQ_NOAUTOEN\t\t= (1 << 12),\n\tIRQ_NO_BALANCING\t= (1 << 13),\n\tIRQ_MOVE_PCNTXT\t\t= (1 << 14),\n\tIRQ_NESTED_THREAD\t= (1 << 15),\n\tIRQ_NOTHREAD\t\t= (1 << 16),\n\tIRQ_PER_CPU_DEVID\t= (1 << 17),\n\tIRQ_IS_POLLED\t\t= (1 << 18),\n\tIRQ_DISABLE_UNLAZY\t= (1 << 19),\n\tIRQ_HIDDEN\t\t= (1 << 20),\n\tIRQ_NO_DEBUG\t\t= (1 << 21),\n};\n\n#define IRQF_MODIFY_MASK\t\\\n\t(IRQ_TYPE_SENSE_MASK | IRQ_NOPROBE | IRQ_NOREQUEST | \\\n\t IRQ_NOAUTOEN | IRQ_MOVE_PCNTXT | IRQ_LEVEL | IRQ_NO_BALANCING | \\\n\t IRQ_PER_CPU | IRQ_NESTED_THREAD | IRQ_NOTHREAD | IRQ_PER_CPU_DEVID | \\\n\t IRQ_IS_POLLED | IRQ_DISABLE_UNLAZY | IRQ_HIDDEN)\n\n#define IRQ_NO_BALANCING_MASK\t(IRQ_PER_CPU | IRQ_NO_BALANCING)\n\n \nenum {\n\tIRQ_SET_MASK_OK = 0,\n\tIRQ_SET_MASK_OK_NOCOPY,\n\tIRQ_SET_MASK_OK_DONE,\n};\n\nstruct msi_desc;\nstruct irq_domain;\n\n \nstruct irq_common_data {\n\tunsigned int\t\t__private state_use_accessors;\n#ifdef CONFIG_NUMA\n\tunsigned int\t\tnode;\n#endif\n\tvoid\t\t\t*handler_data;\n\tstruct msi_desc\t\t*msi_desc;\n#ifdef CONFIG_SMP\n\tcpumask_var_t\t\taffinity;\n#endif\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tcpumask_var_t\t\teffective_affinity;\n#endif\n#ifdef CONFIG_GENERIC_IRQ_IPI\n\tunsigned int\t\tipi_offset;\n#endif\n};\n\n \nstruct irq_data {\n\tu32\t\t\tmask;\n\tunsigned int\t\tirq;\n\tunsigned long\t\thwirq;\n\tstruct irq_common_data\t*common;\n\tstruct irq_chip\t\t*chip;\n\tstruct irq_domain\t*domain;\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tstruct irq_data\t\t*parent_data;\n#endif\n\tvoid\t\t\t*chip_data;\n};\n\n \nenum {\n\tIRQD_TRIGGER_MASK\t\t= 0xf,\n\tIRQD_SETAFFINITY_PENDING\t= BIT(8),\n\tIRQD_ACTIVATED\t\t\t= BIT(9),\n\tIRQD_NO_BALANCING\t\t= BIT(10),\n\tIRQD_PER_CPU\t\t\t= BIT(11),\n\tIRQD_AFFINITY_SET\t\t= BIT(12),\n\tIRQD_LEVEL\t\t\t= BIT(13),\n\tIRQD_WAKEUP_STATE\t\t= BIT(14),\n\tIRQD_MOVE_PCNTXT\t\t= BIT(15),\n\tIRQD_IRQ_DISABLED\t\t= BIT(16),\n\tIRQD_IRQ_MASKED\t\t\t= BIT(17),\n\tIRQD_IRQ_INPROGRESS\t\t= BIT(18),\n\tIRQD_WAKEUP_ARMED\t\t= BIT(19),\n\tIRQD_FORWARDED_TO_VCPU\t\t= BIT(20),\n\tIRQD_AFFINITY_MANAGED\t\t= BIT(21),\n\tIRQD_IRQ_STARTED\t\t= BIT(22),\n\tIRQD_MANAGED_SHUTDOWN\t\t= BIT(23),\n\tIRQD_SINGLE_TARGET\t\t= BIT(24),\n\tIRQD_DEFAULT_TRIGGER_SET\t= BIT(25),\n\tIRQD_CAN_RESERVE\t\t= BIT(26),\n\tIRQD_HANDLE_ENFORCE_IRQCTX\t= BIT(27),\n\tIRQD_AFFINITY_ON_ACTIVATE\t= BIT(28),\n\tIRQD_IRQ_ENABLED_ON_SUSPEND\t= BIT(29),\n\tIRQD_RESEND_WHEN_IN_PROGRESS    = BIT(30),\n};\n\n#define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)\n\nstatic inline bool irqd_is_setaffinity_pending(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_SETAFFINITY_PENDING;\n}\n\nstatic inline bool irqd_is_per_cpu(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_PER_CPU;\n}\n\nstatic inline bool irqd_can_balance(struct irq_data *d)\n{\n\treturn !(__irqd_to_state(d) & (IRQD_PER_CPU | IRQD_NO_BALANCING));\n}\n\nstatic inline bool irqd_affinity_was_set(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_AFFINITY_SET;\n}\n\nstatic inline void irqd_mark_affinity_was_set(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_AFFINITY_SET;\n}\n\nstatic inline bool irqd_trigger_type_was_set(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_DEFAULT_TRIGGER_SET;\n}\n\nstatic inline u32 irqd_get_trigger_type(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_TRIGGER_MASK;\n}\n\n \nstatic inline void irqd_set_trigger_type(struct irq_data *d, u32 type)\n{\n\t__irqd_to_state(d) &= ~IRQD_TRIGGER_MASK;\n\t__irqd_to_state(d) |= type & IRQD_TRIGGER_MASK;\n\t__irqd_to_state(d) |= IRQD_DEFAULT_TRIGGER_SET;\n}\n\nstatic inline bool irqd_is_level_type(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_LEVEL;\n}\n\n \nstatic inline void irqd_set_single_target(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_SINGLE_TARGET;\n}\n\nstatic inline bool irqd_is_single_target(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_SINGLE_TARGET;\n}\n\nstatic inline void irqd_set_handle_enforce_irqctx(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_HANDLE_ENFORCE_IRQCTX;\n}\n\nstatic inline bool irqd_is_handle_enforce_irqctx(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_HANDLE_ENFORCE_IRQCTX;\n}\n\nstatic inline bool irqd_is_enabled_on_suspend(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_IRQ_ENABLED_ON_SUSPEND;\n}\n\nstatic inline bool irqd_is_wakeup_set(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_WAKEUP_STATE;\n}\n\nstatic inline bool irqd_can_move_in_process_context(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_MOVE_PCNTXT;\n}\n\nstatic inline bool irqd_irq_disabled(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_IRQ_DISABLED;\n}\n\nstatic inline bool irqd_irq_masked(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_IRQ_MASKED;\n}\n\nstatic inline bool irqd_irq_inprogress(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_IRQ_INPROGRESS;\n}\n\nstatic inline bool irqd_is_wakeup_armed(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_WAKEUP_ARMED;\n}\n\nstatic inline bool irqd_is_forwarded_to_vcpu(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_FORWARDED_TO_VCPU;\n}\n\nstatic inline void irqd_set_forwarded_to_vcpu(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_FORWARDED_TO_VCPU;\n}\n\nstatic inline void irqd_clr_forwarded_to_vcpu(struct irq_data *d)\n{\n\t__irqd_to_state(d) &= ~IRQD_FORWARDED_TO_VCPU;\n}\n\nstatic inline bool irqd_affinity_is_managed(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_AFFINITY_MANAGED;\n}\n\nstatic inline bool irqd_is_activated(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_ACTIVATED;\n}\n\nstatic inline void irqd_set_activated(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_ACTIVATED;\n}\n\nstatic inline void irqd_clr_activated(struct irq_data *d)\n{\n\t__irqd_to_state(d) &= ~IRQD_ACTIVATED;\n}\n\nstatic inline bool irqd_is_started(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_IRQ_STARTED;\n}\n\nstatic inline bool irqd_is_managed_and_shutdown(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_MANAGED_SHUTDOWN;\n}\n\nstatic inline void irqd_set_can_reserve(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_CAN_RESERVE;\n}\n\nstatic inline void irqd_clr_can_reserve(struct irq_data *d)\n{\n\t__irqd_to_state(d) &= ~IRQD_CAN_RESERVE;\n}\n\nstatic inline bool irqd_can_reserve(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_CAN_RESERVE;\n}\n\nstatic inline void irqd_set_affinity_on_activate(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_AFFINITY_ON_ACTIVATE;\n}\n\nstatic inline bool irqd_affinity_on_activate(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_AFFINITY_ON_ACTIVATE;\n}\n\nstatic inline void irqd_set_resend_when_in_progress(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_RESEND_WHEN_IN_PROGRESS;\n}\n\nstatic inline bool irqd_needs_resend_when_in_progress(struct irq_data *d)\n{\n\treturn __irqd_to_state(d) & IRQD_RESEND_WHEN_IN_PROGRESS;\n}\n\n#undef __irqd_to_state\n\nstatic inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)\n{\n\treturn d->hwirq;\n}\n\n \nstruct irq_chip {\n\tconst char\t*name;\n\tunsigned int\t(*irq_startup)(struct irq_data *data);\n\tvoid\t\t(*irq_shutdown)(struct irq_data *data);\n\tvoid\t\t(*irq_enable)(struct irq_data *data);\n\tvoid\t\t(*irq_disable)(struct irq_data *data);\n\n\tvoid\t\t(*irq_ack)(struct irq_data *data);\n\tvoid\t\t(*irq_mask)(struct irq_data *data);\n\tvoid\t\t(*irq_mask_ack)(struct irq_data *data);\n\tvoid\t\t(*irq_unmask)(struct irq_data *data);\n\tvoid\t\t(*irq_eoi)(struct irq_data *data);\n\n\tint\t\t(*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force);\n\tint\t\t(*irq_retrigger)(struct irq_data *data);\n\tint\t\t(*irq_set_type)(struct irq_data *data, unsigned int flow_type);\n\tint\t\t(*irq_set_wake)(struct irq_data *data, unsigned int on);\n\n\tvoid\t\t(*irq_bus_lock)(struct irq_data *data);\n\tvoid\t\t(*irq_bus_sync_unlock)(struct irq_data *data);\n\n#ifdef CONFIG_DEPRECATED_IRQ_CPU_ONOFFLINE\n\tvoid\t\t(*irq_cpu_online)(struct irq_data *data);\n\tvoid\t\t(*irq_cpu_offline)(struct irq_data *data);\n#endif\n\tvoid\t\t(*irq_suspend)(struct irq_data *data);\n\tvoid\t\t(*irq_resume)(struct irq_data *data);\n\tvoid\t\t(*irq_pm_shutdown)(struct irq_data *data);\n\n\tvoid\t\t(*irq_calc_mask)(struct irq_data *data);\n\n\tvoid\t\t(*irq_print_chip)(struct irq_data *data, struct seq_file *p);\n\tint\t\t(*irq_request_resources)(struct irq_data *data);\n\tvoid\t\t(*irq_release_resources)(struct irq_data *data);\n\n\tvoid\t\t(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);\n\tvoid\t\t(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);\n\n\tint\t\t(*irq_get_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool *state);\n\tint\t\t(*irq_set_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool state);\n\n\tint\t\t(*irq_set_vcpu_affinity)(struct irq_data *data, void *vcpu_info);\n\n\tvoid\t\t(*ipi_send_single)(struct irq_data *data, unsigned int cpu);\n\tvoid\t\t(*ipi_send_mask)(struct irq_data *data, const struct cpumask *dest);\n\n\tint\t\t(*irq_nmi_setup)(struct irq_data *data);\n\tvoid\t\t(*irq_nmi_teardown)(struct irq_data *data);\n\n\tunsigned long\tflags;\n};\n\n \nenum {\n\tIRQCHIP_SET_TYPE_MASKED\t\t\t= (1 <<  0),\n\tIRQCHIP_EOI_IF_HANDLED\t\t\t= (1 <<  1),\n\tIRQCHIP_MASK_ON_SUSPEND\t\t\t= (1 <<  2),\n\tIRQCHIP_ONOFFLINE_ENABLED\t\t= (1 <<  3),\n\tIRQCHIP_SKIP_SET_WAKE\t\t\t= (1 <<  4),\n\tIRQCHIP_ONESHOT_SAFE\t\t\t= (1 <<  5),\n\tIRQCHIP_EOI_THREADED\t\t\t= (1 <<  6),\n\tIRQCHIP_SUPPORTS_LEVEL_MSI\t\t= (1 <<  7),\n\tIRQCHIP_SUPPORTS_NMI\t\t\t= (1 <<  8),\n\tIRQCHIP_ENABLE_WAKEUP_ON_SUSPEND\t= (1 <<  9),\n\tIRQCHIP_AFFINITY_PRE_STARTUP\t\t= (1 << 10),\n\tIRQCHIP_IMMUTABLE\t\t\t= (1 << 11),\n};\n\n#include <linux/irqdesc.h>\n\n \n#include <asm/hw_irq.h>\n\n#ifndef NR_IRQS_LEGACY\n# define NR_IRQS_LEGACY 0\n#endif\n\n#ifndef ARCH_IRQ_INIT_FLAGS\n# define ARCH_IRQ_INIT_FLAGS\t0\n#endif\n\n#define IRQ_DEFAULT_INIT_FLAGS\tARCH_IRQ_INIT_FLAGS\n\nstruct irqaction;\nextern int setup_percpu_irq(unsigned int irq, struct irqaction *new);\nextern void remove_percpu_irq(unsigned int irq, struct irqaction *act);\n\n#ifdef CONFIG_DEPRECATED_IRQ_CPU_ONOFFLINE\nextern void irq_cpu_online(void);\nextern void irq_cpu_offline(void);\n#endif\nextern int irq_set_affinity_locked(struct irq_data *data,\n\t\t\t\t   const struct cpumask *cpumask, bool force);\nextern int irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info);\n\n#if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_IRQ_MIGRATION)\nextern void irq_migrate_all_off_this_cpu(void);\nextern int irq_affinity_online_cpu(unsigned int cpu);\n#else\n# define irq_affinity_online_cpu\tNULL\n#endif\n\n#if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)\nvoid __irq_move_irq(struct irq_data *data);\nstatic inline void irq_move_irq(struct irq_data *data)\n{\n\tif (unlikely(irqd_is_setaffinity_pending(data)))\n\t\t__irq_move_irq(data);\n}\nvoid irq_move_masked_irq(struct irq_data *data);\nvoid irq_force_complete_move(struct irq_desc *desc);\n#else\nstatic inline void irq_move_irq(struct irq_data *data) { }\nstatic inline void irq_move_masked_irq(struct irq_data *data) { }\nstatic inline void irq_force_complete_move(struct irq_desc *desc) { }\n#endif\n\nextern int no_irq_affinity;\n\n#ifdef CONFIG_HARDIRQS_SW_RESEND\nint irq_set_parent(int irq, int parent_irq);\n#else\nstatic inline int irq_set_parent(int irq, int parent_irq)\n{\n\treturn 0;\n}\n#endif\n\n \nextern void handle_level_irq(struct irq_desc *desc);\nextern void handle_fasteoi_irq(struct irq_desc *desc);\nextern void handle_edge_irq(struct irq_desc *desc);\nextern void handle_edge_eoi_irq(struct irq_desc *desc);\nextern void handle_simple_irq(struct irq_desc *desc);\nextern void handle_untracked_irq(struct irq_desc *desc);\nextern void handle_percpu_irq(struct irq_desc *desc);\nextern void handle_percpu_devid_irq(struct irq_desc *desc);\nextern void handle_bad_irq(struct irq_desc *desc);\nextern void handle_nested_irq(unsigned int irq);\n\nextern void handle_fasteoi_nmi(struct irq_desc *desc);\nextern void handle_percpu_devid_fasteoi_nmi(struct irq_desc *desc);\n\nextern int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg);\nextern int irq_chip_pm_get(struct irq_data *data);\nextern int irq_chip_pm_put(struct irq_data *data);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\nextern void handle_fasteoi_ack_irq(struct irq_desc *desc);\nextern void handle_fasteoi_mask_irq(struct irq_desc *desc);\nextern int irq_chip_set_parent_state(struct irq_data *data,\n\t\t\t\t     enum irqchip_irq_state which,\n\t\t\t\t     bool val);\nextern int irq_chip_get_parent_state(struct irq_data *data,\n\t\t\t\t     enum irqchip_irq_state which,\n\t\t\t\t     bool *state);\nextern void irq_chip_enable_parent(struct irq_data *data);\nextern void irq_chip_disable_parent(struct irq_data *data);\nextern void irq_chip_ack_parent(struct irq_data *data);\nextern int irq_chip_retrigger_hierarchy(struct irq_data *data);\nextern void irq_chip_mask_parent(struct irq_data *data);\nextern void irq_chip_mask_ack_parent(struct irq_data *data);\nextern void irq_chip_unmask_parent(struct irq_data *data);\nextern void irq_chip_eoi_parent(struct irq_data *data);\nextern int irq_chip_set_affinity_parent(struct irq_data *data,\n\t\t\t\t\tconst struct cpumask *dest,\n\t\t\t\t\tbool force);\nextern int irq_chip_set_wake_parent(struct irq_data *data, unsigned int on);\nextern int irq_chip_set_vcpu_affinity_parent(struct irq_data *data,\n\t\t\t\t\t     void *vcpu_info);\nextern int irq_chip_set_type_parent(struct irq_data *data, unsigned int type);\nextern int irq_chip_request_resources_parent(struct irq_data *data);\nextern void irq_chip_release_resources_parent(struct irq_data *data);\n#endif\n\n \nextern void note_interrupt(struct irq_desc *desc, irqreturn_t action_ret);\n\n\n \nextern int noirqdebug_setup(char *str);\n\n \nextern int can_request_irq(unsigned int irq, unsigned long irqflags);\n\n \nextern struct irq_chip no_irq_chip;\nextern struct irq_chip dummy_irq_chip;\n\nextern void\nirq_set_chip_and_handler_name(unsigned int irq, const struct irq_chip *chip,\n\t\t\t      irq_flow_handler_t handle, const char *name);\n\nstatic inline void irq_set_chip_and_handler(unsigned int irq,\n\t\t\t\t\t    const struct irq_chip *chip,\n\t\t\t\t\t    irq_flow_handler_t handle)\n{\n\tirq_set_chip_and_handler_name(irq, chip, handle, NULL);\n}\n\nextern int irq_set_percpu_devid(unsigned int irq);\nextern int irq_set_percpu_devid_partition(unsigned int irq,\n\t\t\t\t\t  const struct cpumask *affinity);\nextern int irq_get_percpu_devid_partition(unsigned int irq,\n\t\t\t\t\t  struct cpumask *affinity);\n\nextern void\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name);\n\nstatic inline void\nirq_set_handler(unsigned int irq, irq_flow_handler_t handle)\n{\n\t__irq_set_handler(irq, handle, 0, NULL);\n}\n\n \nstatic inline void\nirq_set_chained_handler(unsigned int irq, irq_flow_handler_t handle)\n{\n\t__irq_set_handler(irq, handle, 1, NULL);\n}\n\n \nvoid\nirq_set_chained_handler_and_data(unsigned int irq, irq_flow_handler_t handle,\n\t\t\t\t void *data);\n\nvoid irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set);\n\nstatic inline void irq_set_status_flags(unsigned int irq, unsigned long set)\n{\n\tirq_modify_status(irq, 0, set);\n}\n\nstatic inline void irq_clear_status_flags(unsigned int irq, unsigned long clr)\n{\n\tirq_modify_status(irq, clr, 0);\n}\n\nstatic inline void irq_set_noprobe(unsigned int irq)\n{\n\tirq_modify_status(irq, 0, IRQ_NOPROBE);\n}\n\nstatic inline void irq_set_probe(unsigned int irq)\n{\n\tirq_modify_status(irq, IRQ_NOPROBE, 0);\n}\n\nstatic inline void irq_set_nothread(unsigned int irq)\n{\n\tirq_modify_status(irq, 0, IRQ_NOTHREAD);\n}\n\nstatic inline void irq_set_thread(unsigned int irq)\n{\n\tirq_modify_status(irq, IRQ_NOTHREAD, 0);\n}\n\nstatic inline void irq_set_nested_thread(unsigned int irq, bool nest)\n{\n\tif (nest)\n\t\tirq_set_status_flags(irq, IRQ_NESTED_THREAD);\n\telse\n\t\tirq_clear_status_flags(irq, IRQ_NESTED_THREAD);\n}\n\nstatic inline void irq_set_percpu_devid_flags(unsigned int irq)\n{\n\tirq_set_status_flags(irq,\n\t\t\t     IRQ_NOAUTOEN | IRQ_PER_CPU | IRQ_NOTHREAD |\n\t\t\t     IRQ_NOPROBE | IRQ_PER_CPU_DEVID);\n}\n\n \nextern int irq_set_chip(unsigned int irq, const struct irq_chip *chip);\nextern int irq_set_handler_data(unsigned int irq, void *data);\nextern int irq_set_chip_data(unsigned int irq, void *data);\nextern int irq_set_irq_type(unsigned int irq, unsigned int type);\nextern int irq_set_msi_desc(unsigned int irq, struct msi_desc *entry);\nextern int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,\n\t\t\t\tstruct msi_desc *entry);\nextern struct irq_data *irq_get_irq_data(unsigned int irq);\n\nstatic inline struct irq_chip *irq_get_chip(unsigned int irq)\n{\n\tstruct irq_data *d = irq_get_irq_data(irq);\n\treturn d ? d->chip : NULL;\n}\n\nstatic inline struct irq_chip *irq_data_get_irq_chip(struct irq_data *d)\n{\n\treturn d->chip;\n}\n\nstatic inline void *irq_get_chip_data(unsigned int irq)\n{\n\tstruct irq_data *d = irq_get_irq_data(irq);\n\treturn d ? d->chip_data : NULL;\n}\n\nstatic inline void *irq_data_get_irq_chip_data(struct irq_data *d)\n{\n\treturn d->chip_data;\n}\n\nstatic inline void *irq_get_handler_data(unsigned int irq)\n{\n\tstruct irq_data *d = irq_get_irq_data(irq);\n\treturn d ? d->common->handler_data : NULL;\n}\n\nstatic inline void *irq_data_get_irq_handler_data(struct irq_data *d)\n{\n\treturn d->common->handler_data;\n}\n\nstatic inline struct msi_desc *irq_get_msi_desc(unsigned int irq)\n{\n\tstruct irq_data *d = irq_get_irq_data(irq);\n\treturn d ? d->common->msi_desc : NULL;\n}\n\nstatic inline struct msi_desc *irq_data_get_msi_desc(struct irq_data *d)\n{\n\treturn d->common->msi_desc;\n}\n\nstatic inline u32 irq_get_trigger_type(unsigned int irq)\n{\n\tstruct irq_data *d = irq_get_irq_data(irq);\n\treturn d ? irqd_get_trigger_type(d) : 0;\n}\n\nstatic inline int irq_common_data_get_node(struct irq_common_data *d)\n{\n#ifdef CONFIG_NUMA\n\treturn d->node;\n#else\n\treturn 0;\n#endif\n}\n\nstatic inline int irq_data_get_node(struct irq_data *d)\n{\n\treturn irq_common_data_get_node(d->common);\n}\n\nstatic inline\nconst struct cpumask *irq_data_get_affinity_mask(struct irq_data *d)\n{\n#ifdef CONFIG_SMP\n\treturn d->common->affinity;\n#else\n\treturn cpumask_of(0);\n#endif\n}\n\nstatic inline void irq_data_update_affinity(struct irq_data *d,\n\t\t\t\t\t    const struct cpumask *m)\n{\n#ifdef CONFIG_SMP\n\tcpumask_copy(d->common->affinity, m);\n#endif\n}\n\nstatic inline const struct cpumask *irq_get_affinity_mask(int irq)\n{\n\tstruct irq_data *d = irq_get_irq_data(irq);\n\n\treturn d ? irq_data_get_affinity_mask(d) : NULL;\n}\n\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\nstatic inline\nconst struct cpumask *irq_data_get_effective_affinity_mask(struct irq_data *d)\n{\n\treturn d->common->effective_affinity;\n}\nstatic inline void irq_data_update_effective_affinity(struct irq_data *d,\n\t\t\t\t\t\t      const struct cpumask *m)\n{\n\tcpumask_copy(d->common->effective_affinity, m);\n}\n#else\nstatic inline void irq_data_update_effective_affinity(struct irq_data *d,\n\t\t\t\t\t\t      const struct cpumask *m)\n{\n}\nstatic inline\nconst struct cpumask *irq_data_get_effective_affinity_mask(struct irq_data *d)\n{\n\treturn irq_data_get_affinity_mask(d);\n}\n#endif\n\nstatic inline\nconst struct cpumask *irq_get_effective_affinity_mask(unsigned int irq)\n{\n\tstruct irq_data *d = irq_get_irq_data(irq);\n\n\treturn d ? irq_data_get_effective_affinity_mask(d) : NULL;\n}\n\nunsigned int arch_dynirq_lower_bound(unsigned int from);\n\nint __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,\n\t\t      struct module *owner,\n\t\t      const struct irq_affinity_desc *affinity);\n\nint __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,\n\t\t\t   unsigned int cnt, int node, struct module *owner,\n\t\t\t   const struct irq_affinity_desc *affinity);\n\n \n#define irq_alloc_descs(irq, from, cnt, node)\t\\\n\t__irq_alloc_descs(irq, from, cnt, node, THIS_MODULE, NULL)\n\n#define irq_alloc_desc(node)\t\t\t\\\n\tirq_alloc_descs(-1, 1, 1, node)\n\n#define irq_alloc_desc_at(at, node)\t\t\\\n\tirq_alloc_descs(at, at, 1, node)\n\n#define irq_alloc_desc_from(from, node)\t\t\\\n\tirq_alloc_descs(-1, from, 1, node)\n\n#define irq_alloc_descs_from(from, cnt, node)\t\\\n\tirq_alloc_descs(-1, from, cnt, node)\n\n#define devm_irq_alloc_descs(dev, irq, from, cnt, node)\t\t\\\n\t__devm_irq_alloc_descs(dev, irq, from, cnt, node, THIS_MODULE, NULL)\n\n#define devm_irq_alloc_desc(dev, node)\t\t\t\t\\\n\tdevm_irq_alloc_descs(dev, -1, 1, 1, node)\n\n#define devm_irq_alloc_desc_at(dev, at, node)\t\t\t\\\n\tdevm_irq_alloc_descs(dev, at, at, 1, node)\n\n#define devm_irq_alloc_desc_from(dev, from, node)\t\t\\\n\tdevm_irq_alloc_descs(dev, -1, from, 1, node)\n\n#define devm_irq_alloc_descs_from(dev, from, cnt, node)\t\t\\\n\tdevm_irq_alloc_descs(dev, -1, from, cnt, node)\n\nvoid irq_free_descs(unsigned int irq, unsigned int cnt);\nstatic inline void irq_free_desc(unsigned int irq)\n{\n\tirq_free_descs(irq, 1);\n}\n\n#ifdef CONFIG_GENERIC_IRQ_LEGACY\nvoid irq_init_desc(unsigned int irq);\n#endif\n\n \nstruct irq_chip_regs {\n\tunsigned long\t\tenable;\n\tunsigned long\t\tdisable;\n\tunsigned long\t\tmask;\n\tunsigned long\t\tack;\n\tunsigned long\t\teoi;\n\tunsigned long\t\ttype;\n\tunsigned long\t\tpolarity;\n};\n\n \nstruct irq_chip_type {\n\tstruct irq_chip\t\tchip;\n\tstruct irq_chip_regs\tregs;\n\tirq_flow_handler_t\thandler;\n\tu32\t\t\ttype;\n\tu32\t\t\tmask_cache_priv;\n\tu32\t\t\t*mask_cache;\n};\n\n \nstruct irq_chip_generic {\n\traw_spinlock_t\t\tlock;\n\tvoid __iomem\t\t*reg_base;\n\tu32\t\t\t(*reg_readl)(void __iomem *addr);\n\tvoid\t\t\t(*reg_writel)(u32 val, void __iomem *addr);\n\tvoid\t\t\t(*suspend)(struct irq_chip_generic *gc);\n\tvoid\t\t\t(*resume)(struct irq_chip_generic *gc);\n\tunsigned int\t\tirq_base;\n\tunsigned int\t\tirq_cnt;\n\tu32\t\t\tmask_cache;\n\tu32\t\t\ttype_cache;\n\tu32\t\t\tpolarity_cache;\n\tu32\t\t\twake_enabled;\n\tu32\t\t\twake_active;\n\tunsigned int\t\tnum_ct;\n\tvoid\t\t\t*private;\n\tunsigned long\t\tinstalled;\n\tunsigned long\t\tunused;\n\tstruct irq_domain\t*domain;\n\tstruct list_head\tlist;\n\tstruct irq_chip_type\tchip_types[];\n};\n\n \nenum irq_gc_flags {\n\tIRQ_GC_INIT_MASK_CACHE\t\t= 1 << 0,\n\tIRQ_GC_INIT_NESTED_LOCK\t\t= 1 << 1,\n\tIRQ_GC_MASK_CACHE_PER_TYPE\t= 1 << 2,\n\tIRQ_GC_NO_MASK\t\t\t= 1 << 3,\n\tIRQ_GC_BE_IO\t\t\t= 1 << 4,\n};\n\n \nstruct irq_domain_chip_generic {\n\tunsigned int\t\tirqs_per_chip;\n\tunsigned int\t\tnum_chips;\n\tunsigned int\t\tirq_flags_to_clear;\n\tunsigned int\t\tirq_flags_to_set;\n\tenum irq_gc_flags\tgc_flags;\n\tstruct irq_chip_generic\t*gc[];\n};\n\n \nvoid irq_gc_noop(struct irq_data *d);\nvoid irq_gc_mask_disable_reg(struct irq_data *d);\nvoid irq_gc_mask_set_bit(struct irq_data *d);\nvoid irq_gc_mask_clr_bit(struct irq_data *d);\nvoid irq_gc_unmask_enable_reg(struct irq_data *d);\nvoid irq_gc_ack_set_bit(struct irq_data *d);\nvoid irq_gc_ack_clr_bit(struct irq_data *d);\nvoid irq_gc_mask_disable_and_ack_set(struct irq_data *d);\nvoid irq_gc_eoi(struct irq_data *d);\nint irq_gc_set_wake(struct irq_data *d, unsigned int on);\n\n \nint irq_map_generic_chip(struct irq_domain *d, unsigned int virq,\n\t\t\t irq_hw_number_t hw_irq);\nvoid irq_unmap_generic_chip(struct irq_domain *d, unsigned int virq);\nstruct irq_chip_generic *\nirq_alloc_generic_chip(const char *name, int nr_ct, unsigned int irq_base,\n\t\t       void __iomem *reg_base, irq_flow_handler_t handler);\nvoid irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk,\n\t\t\t    enum irq_gc_flags flags, unsigned int clr,\n\t\t\t    unsigned int set);\nint irq_setup_alt_chip(struct irq_data *d, unsigned int type);\nvoid irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,\n\t\t\t     unsigned int clr, unsigned int set);\n\nstruct irq_chip_generic *\ndevm_irq_alloc_generic_chip(struct device *dev, const char *name, int num_ct,\n\t\t\t    unsigned int irq_base, void __iomem *reg_base,\n\t\t\t    irq_flow_handler_t handler);\nint devm_irq_setup_generic_chip(struct device *dev, struct irq_chip_generic *gc,\n\t\t\t\tu32 msk, enum irq_gc_flags flags,\n\t\t\t\tunsigned int clr, unsigned int set);\n\nstruct irq_chip_generic *irq_get_domain_generic_chip(struct irq_domain *d, unsigned int hw_irq);\n\nint __irq_alloc_domain_generic_chips(struct irq_domain *d, int irqs_per_chip,\n\t\t\t\t     int num_ct, const char *name,\n\t\t\t\t     irq_flow_handler_t handler,\n\t\t\t\t     unsigned int clr, unsigned int set,\n\t\t\t\t     enum irq_gc_flags flags);\n\n#define irq_alloc_domain_generic_chips(d, irqs_per_chip, num_ct, name,\t\\\n\t\t\t\t       handler,\tclr, set, flags)\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tMAYBE_BUILD_BUG_ON(irqs_per_chip > 32);\t\t\t\t\\\n\t__irq_alloc_domain_generic_chips(d, irqs_per_chip, num_ct, name,\\\n\t\t\t\t\t handler, clr, set, flags);\t\\\n})\n\nstatic inline void irq_free_generic_chip(struct irq_chip_generic *gc)\n{\n\tkfree(gc);\n}\n\nstatic inline void irq_destroy_generic_chip(struct irq_chip_generic *gc,\n\t\t\t\t\t    u32 msk, unsigned int clr,\n\t\t\t\t\t    unsigned int set)\n{\n\tirq_remove_generic_chip(gc, msk, clr, set);\n\tirq_free_generic_chip(gc);\n}\n\nstatic inline struct irq_chip_type *irq_data_get_chip_type(struct irq_data *d)\n{\n\treturn container_of(d->chip, struct irq_chip_type, chip);\n}\n\n#define IRQ_MSK(n) (u32)((n) < 32 ? ((1 << (n)) - 1) : UINT_MAX)\n\n#ifdef CONFIG_SMP\nstatic inline void irq_gc_lock(struct irq_chip_generic *gc)\n{\n\traw_spin_lock(&gc->lock);\n}\n\nstatic inline void irq_gc_unlock(struct irq_chip_generic *gc)\n{\n\traw_spin_unlock(&gc->lock);\n}\n#else\nstatic inline void irq_gc_lock(struct irq_chip_generic *gc) { }\nstatic inline void irq_gc_unlock(struct irq_chip_generic *gc) { }\n#endif\n\n \n#define irq_gc_lock_irqsave(gc, flags)\t\\\n\traw_spin_lock_irqsave(&(gc)->lock, flags)\n\n#define irq_gc_unlock_irqrestore(gc, flags)\t\\\n\traw_spin_unlock_irqrestore(&(gc)->lock, flags)\n\nstatic inline void irq_reg_writel(struct irq_chip_generic *gc,\n\t\t\t\t  u32 val, int reg_offset)\n{\n\tif (gc->reg_writel)\n\t\tgc->reg_writel(val, gc->reg_base + reg_offset);\n\telse\n\t\twritel(val, gc->reg_base + reg_offset);\n}\n\nstatic inline u32 irq_reg_readl(struct irq_chip_generic *gc,\n\t\t\t\tint reg_offset)\n{\n\tif (gc->reg_readl)\n\t\treturn gc->reg_readl(gc->reg_base + reg_offset);\n\telse\n\t\treturn readl(gc->reg_base + reg_offset);\n}\n\nstruct irq_matrix;\nstruct irq_matrix *irq_alloc_matrix(unsigned int matrix_bits,\n\t\t\t\t    unsigned int alloc_start,\n\t\t\t\t    unsigned int alloc_end);\nvoid irq_matrix_online(struct irq_matrix *m);\nvoid irq_matrix_offline(struct irq_matrix *m);\nvoid irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit, bool replace);\nint irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk);\nvoid irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk);\nint irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,\n\t\t\t\tunsigned int *mapped_cpu);\nvoid irq_matrix_reserve(struct irq_matrix *m);\nvoid irq_matrix_remove_reserved(struct irq_matrix *m);\nint irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,\n\t\t     bool reserved, unsigned int *mapped_cpu);\nvoid irq_matrix_free(struct irq_matrix *m, unsigned int cpu,\n\t\t     unsigned int bit, bool managed);\nvoid irq_matrix_assign(struct irq_matrix *m, unsigned int bit);\nunsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown);\nunsigned int irq_matrix_allocated(struct irq_matrix *m);\nunsigned int irq_matrix_reserved(struct irq_matrix *m);\nvoid irq_matrix_debug_show(struct seq_file *sf, struct irq_matrix *m, int ind);\n\n \n#define INVALID_HWIRQ\t(~0UL)\nirq_hw_number_t ipi_get_hwirq(unsigned int irq, unsigned int cpu);\nint __ipi_send_single(struct irq_desc *desc, unsigned int cpu);\nint __ipi_send_mask(struct irq_desc *desc, const struct cpumask *dest);\nint ipi_send_single(unsigned int virq, unsigned int cpu);\nint ipi_send_mask(unsigned int virq, const struct cpumask *dest);\n\nvoid ipi_mux_process(void);\nint ipi_mux_create(unsigned int nr_ipi, void (*mux_send)(unsigned int cpu));\n\n#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER\n \nint __init set_handle_irq(void (*handle_irq)(struct pt_regs *));\n\n \nextern void (*handle_arch_irq)(struct pt_regs *) __ro_after_init;\nasmlinkage void generic_handle_arch_irq(struct pt_regs *regs);\n#else\n#ifndef set_handle_irq\n#define set_handle_irq(handle_irq)\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\t(void)handle_irq;\t\t\\\n\t\tWARN_ON(1);\t\t\t\\\n\t} while (0)\n#endif\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}