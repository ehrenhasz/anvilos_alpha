{
  "module_name": "highmem-internal.h",
  "hash_id": "5272861a6f41a234983ef3138fe526a65ad4679cde6aa50077f1d1dc781bef5d",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/highmem-internal.h",
  "human_readable_source": " \n#ifndef _LINUX_HIGHMEM_INTERNAL_H\n#define _LINUX_HIGHMEM_INTERNAL_H\n\n \n#ifdef CONFIG_KMAP_LOCAL\nvoid *__kmap_local_pfn_prot(unsigned long pfn, pgprot_t prot);\nvoid *__kmap_local_page_prot(struct page *page, pgprot_t prot);\nvoid kunmap_local_indexed(const void *vaddr);\nvoid kmap_local_fork(struct task_struct *tsk);\nvoid __kmap_local_sched_out(void);\nvoid __kmap_local_sched_in(void);\nstatic inline void kmap_assert_nomap(void)\n{\n\tDEBUG_LOCKS_WARN_ON(current->kmap_ctrl.idx);\n}\n#else\nstatic inline void kmap_local_fork(struct task_struct *tsk) { }\nstatic inline void kmap_assert_nomap(void) { }\n#endif\n\n#ifdef CONFIG_HIGHMEM\n#include <asm/highmem.h>\n\n#ifndef ARCH_HAS_KMAP_FLUSH_TLB\nstatic inline void kmap_flush_tlb(unsigned long addr) { }\n#endif\n\n#ifndef kmap_prot\n#define kmap_prot PAGE_KERNEL\n#endif\n\nvoid *kmap_high(struct page *page);\nvoid kunmap_high(struct page *page);\nvoid __kmap_flush_unused(void);\nstruct page *__kmap_to_page(void *addr);\n\nstatic inline void *kmap(struct page *page)\n{\n\tvoid *addr;\n\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\taddr = page_address(page);\n\telse\n\t\taddr = kmap_high(page);\n\tkmap_flush_tlb((unsigned long)addr);\n\treturn addr;\n}\n\nstatic inline void kunmap(struct page *page)\n{\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n\nstatic inline struct page *kmap_to_page(void *addr)\n{\n\treturn __kmap_to_page(addr);\n}\n\nstatic inline void kmap_flush_unused(void)\n{\n\t__kmap_flush_unused();\n}\n\nstatic inline void *kmap_local_page(struct page *page)\n{\n\treturn __kmap_local_page_prot(page, kmap_prot);\n}\n\nstatic inline void *kmap_local_folio(struct folio *folio, size_t offset)\n{\n\tstruct page *page = folio_page(folio, offset / PAGE_SIZE);\n\treturn __kmap_local_page_prot(page, kmap_prot) + offset % PAGE_SIZE;\n}\n\nstatic inline void *kmap_local_page_prot(struct page *page, pgprot_t prot)\n{\n\treturn __kmap_local_page_prot(page, prot);\n}\n\nstatic inline void *kmap_local_pfn(unsigned long pfn)\n{\n\treturn __kmap_local_pfn_prot(pfn, kmap_prot);\n}\n\nstatic inline void __kunmap_local(const void *vaddr)\n{\n\tkunmap_local_indexed(vaddr);\n}\n\nstatic inline void *kmap_atomic_prot(struct page *page, pgprot_t prot)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tmigrate_disable();\n\telse\n\t\tpreempt_disable();\n\n\tpagefault_disable();\n\treturn __kmap_local_page_prot(page, prot);\n}\n\nstatic inline void *kmap_atomic(struct page *page)\n{\n\treturn kmap_atomic_prot(page, kmap_prot);\n}\n\nstatic inline void *kmap_atomic_pfn(unsigned long pfn)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tmigrate_disable();\n\telse\n\t\tpreempt_disable();\n\n\tpagefault_disable();\n\treturn __kmap_local_pfn_prot(pfn, kmap_prot);\n}\n\nstatic inline void __kunmap_atomic(const void *addr)\n{\n\tkunmap_local_indexed(addr);\n\tpagefault_enable();\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tmigrate_enable();\n\telse\n\t\tpreempt_enable();\n}\n\nunsigned int __nr_free_highpages(void);\nextern atomic_long_t _totalhigh_pages;\n\nstatic inline unsigned int nr_free_highpages(void)\n{\n\treturn __nr_free_highpages();\n}\n\nstatic inline unsigned long totalhigh_pages(void)\n{\n\treturn (unsigned long)atomic_long_read(&_totalhigh_pages);\n}\n\nstatic inline void totalhigh_pages_add(long count)\n{\n\tatomic_long_add(count, &_totalhigh_pages);\n}\n\nstatic inline bool is_kmap_addr(const void *x)\n{\n\tunsigned long addr = (unsigned long)x;\n\n\treturn (addr >= PKMAP_ADDR(0) && addr < PKMAP_ADDR(LAST_PKMAP)) ||\n\t\t(addr >= __fix_to_virt(FIX_KMAP_END) &&\n\t\t addr < __fix_to_virt(FIX_KMAP_BEGIN));\n}\n#else  \n\nstatic inline struct page *kmap_to_page(void *addr)\n{\n\treturn virt_to_page(addr);\n}\n\nstatic inline void *kmap(struct page *page)\n{\n\tmight_sleep();\n\treturn page_address(page);\n}\n\nstatic inline void kunmap_high(struct page *page) { }\nstatic inline void kmap_flush_unused(void) { }\n\nstatic inline void kunmap(struct page *page)\n{\n#ifdef ARCH_HAS_FLUSH_ON_KUNMAP\n\tkunmap_flush_on_unmap(page_address(page));\n#endif\n}\n\nstatic inline void *kmap_local_page(struct page *page)\n{\n\treturn page_address(page);\n}\n\nstatic inline void *kmap_local_folio(struct folio *folio, size_t offset)\n{\n\treturn page_address(&folio->page) + offset;\n}\n\nstatic inline void *kmap_local_page_prot(struct page *page, pgprot_t prot)\n{\n\treturn kmap_local_page(page);\n}\n\nstatic inline void *kmap_local_pfn(unsigned long pfn)\n{\n\treturn kmap_local_page(pfn_to_page(pfn));\n}\n\nstatic inline void __kunmap_local(const void *addr)\n{\n#ifdef ARCH_HAS_FLUSH_ON_KUNMAP\n\tkunmap_flush_on_unmap(PTR_ALIGN_DOWN(addr, PAGE_SIZE));\n#endif\n}\n\nstatic inline void *kmap_atomic(struct page *page)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tmigrate_disable();\n\telse\n\t\tpreempt_disable();\n\tpagefault_disable();\n\treturn page_address(page);\n}\n\nstatic inline void *kmap_atomic_prot(struct page *page, pgprot_t prot)\n{\n\treturn kmap_atomic(page);\n}\n\nstatic inline void *kmap_atomic_pfn(unsigned long pfn)\n{\n\treturn kmap_atomic(pfn_to_page(pfn));\n}\n\nstatic inline void __kunmap_atomic(const void *addr)\n{\n#ifdef ARCH_HAS_FLUSH_ON_KUNMAP\n\tkunmap_flush_on_unmap(PTR_ALIGN_DOWN(addr, PAGE_SIZE));\n#endif\n\tpagefault_enable();\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tmigrate_enable();\n\telse\n\t\tpreempt_enable();\n}\n\nstatic inline unsigned int nr_free_highpages(void) { return 0; }\nstatic inline unsigned long totalhigh_pages(void) { return 0UL; }\n\nstatic inline bool is_kmap_addr(const void *x)\n{\n\treturn false;\n}\n\n#endif  \n\n \n#define kunmap_atomic(__addr)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(__same_type((__addr), struct page *));\t\\\n\t__kunmap_atomic(__addr);\t\t\t\t\\\n} while (0)\n\n \n#define kunmap_local(__addr)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(__same_type((__addr), struct page *));\t\\\n\t__kunmap_local(__addr);\t\t\t\t\t\\\n} while (0)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}