{
  "module_name": "edac.h",
  "hash_id": "9556ed96d914bc6fab747e1f9a2390a0bd87746eb63416bb0b33dd0a50e57bd7",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/edac.h",
  "human_readable_source": " \n#ifndef _LINUX_EDAC_H_\n#define _LINUX_EDAC_H_\n\n#include <linux/atomic.h>\n#include <linux/device.h>\n#include <linux/completion.h>\n#include <linux/workqueue.h>\n#include <linux/debugfs.h>\n#include <linux/numa.h>\n\n#define EDAC_DEVICE_NAME_LEN\t31\n\nstruct device;\n\n#define EDAC_OPSTATE_INVAL\t-1\n#define EDAC_OPSTATE_POLL\t0\n#define EDAC_OPSTATE_NMI\t1\n#define EDAC_OPSTATE_INT\t2\n\nextern int edac_op_state;\n\nstruct bus_type *edac_get_sysfs_subsys(void);\n\nstatic inline void opstate_init(void)\n{\n\tswitch (edac_op_state) {\n\tcase EDAC_OPSTATE_POLL:\n\tcase EDAC_OPSTATE_NMI:\n\t\tbreak;\n\tdefault:\n\t\tedac_op_state = EDAC_OPSTATE_POLL;\n\t}\n\treturn;\n}\n\n \n#define EDAC_MC_LABEL_LEN\t31\n\n \n#define LOCATION_SIZE 256\n\n \n#define EDAC_MAX_LABELS\t\t8\n\n \n#define OTHER_LABEL \" or \"\n\n \nenum dev_type {\n\tDEV_UNKNOWN = 0,\n\tDEV_X1,\n\tDEV_X2,\n\tDEV_X4,\n\tDEV_X8,\n\tDEV_X16,\n\tDEV_X32,\t\t \n\tDEV_X64\t\t\t \n};\n\n#define DEV_FLAG_UNKNOWN\tBIT(DEV_UNKNOWN)\n#define DEV_FLAG_X1\t\tBIT(DEV_X1)\n#define DEV_FLAG_X2\t\tBIT(DEV_X2)\n#define DEV_FLAG_X4\t\tBIT(DEV_X4)\n#define DEV_FLAG_X8\t\tBIT(DEV_X8)\n#define DEV_FLAG_X16\t\tBIT(DEV_X16)\n#define DEV_FLAG_X32\t\tBIT(DEV_X32)\n#define DEV_FLAG_X64\t\tBIT(DEV_X64)\n\n \nenum hw_event_mc_err_type {\n\tHW_EVENT_ERR_CORRECTED,\n\tHW_EVENT_ERR_UNCORRECTED,\n\tHW_EVENT_ERR_DEFERRED,\n\tHW_EVENT_ERR_FATAL,\n\tHW_EVENT_ERR_INFO,\n};\n\nstatic inline char *mc_event_error_type(const unsigned int err_type)\n{\n\tswitch (err_type) {\n\tcase HW_EVENT_ERR_CORRECTED:\n\t\treturn \"Corrected\";\n\tcase HW_EVENT_ERR_UNCORRECTED:\n\t\treturn \"Uncorrected\";\n\tcase HW_EVENT_ERR_DEFERRED:\n\t\treturn \"Deferred\";\n\tcase HW_EVENT_ERR_FATAL:\n\t\treturn \"Fatal\";\n\tdefault:\n\tcase HW_EVENT_ERR_INFO:\n\t\treturn \"Info\";\n\t}\n}\n\n \nenum mem_type {\n\tMEM_EMPTY = 0,\n\tMEM_RESERVED,\n\tMEM_UNKNOWN,\n\tMEM_FPM,\n\tMEM_EDO,\n\tMEM_BEDO,\n\tMEM_SDR,\n\tMEM_RDR,\n\tMEM_DDR,\n\tMEM_RDDR,\n\tMEM_RMBS,\n\tMEM_DDR2,\n\tMEM_FB_DDR2,\n\tMEM_RDDR2,\n\tMEM_XDR,\n\tMEM_DDR3,\n\tMEM_RDDR3,\n\tMEM_LRDDR3,\n\tMEM_LPDDR3,\n\tMEM_DDR4,\n\tMEM_RDDR4,\n\tMEM_LRDDR4,\n\tMEM_LPDDR4,\n\tMEM_DDR5,\n\tMEM_RDDR5,\n\tMEM_LRDDR5,\n\tMEM_NVDIMM,\n\tMEM_WIO2,\n\tMEM_HBM2,\n};\n\n#define MEM_FLAG_EMPTY\t\tBIT(MEM_EMPTY)\n#define MEM_FLAG_RESERVED\tBIT(MEM_RESERVED)\n#define MEM_FLAG_UNKNOWN\tBIT(MEM_UNKNOWN)\n#define MEM_FLAG_FPM\t\tBIT(MEM_FPM)\n#define MEM_FLAG_EDO\t\tBIT(MEM_EDO)\n#define MEM_FLAG_BEDO\t\tBIT(MEM_BEDO)\n#define MEM_FLAG_SDR\t\tBIT(MEM_SDR)\n#define MEM_FLAG_RDR\t\tBIT(MEM_RDR)\n#define MEM_FLAG_DDR\t\tBIT(MEM_DDR)\n#define MEM_FLAG_RDDR\t\tBIT(MEM_RDDR)\n#define MEM_FLAG_RMBS\t\tBIT(MEM_RMBS)\n#define MEM_FLAG_DDR2\t\tBIT(MEM_DDR2)\n#define MEM_FLAG_FB_DDR2\tBIT(MEM_FB_DDR2)\n#define MEM_FLAG_RDDR2\t\tBIT(MEM_RDDR2)\n#define MEM_FLAG_XDR\t\tBIT(MEM_XDR)\n#define MEM_FLAG_DDR3\t\tBIT(MEM_DDR3)\n#define MEM_FLAG_RDDR3\t\tBIT(MEM_RDDR3)\n#define MEM_FLAG_LPDDR3\t\tBIT(MEM_LPDDR3)\n#define MEM_FLAG_DDR4\t\tBIT(MEM_DDR4)\n#define MEM_FLAG_RDDR4\t\tBIT(MEM_RDDR4)\n#define MEM_FLAG_LRDDR4\t\tBIT(MEM_LRDDR4)\n#define MEM_FLAG_LPDDR4\t\tBIT(MEM_LPDDR4)\n#define MEM_FLAG_DDR5\t\tBIT(MEM_DDR5)\n#define MEM_FLAG_RDDR5\t\tBIT(MEM_RDDR5)\n#define MEM_FLAG_LRDDR5\t\tBIT(MEM_LRDDR5)\n#define MEM_FLAG_NVDIMM\t\tBIT(MEM_NVDIMM)\n#define MEM_FLAG_WIO2\t\tBIT(MEM_WIO2)\n#define MEM_FLAG_HBM2\t\tBIT(MEM_HBM2)\n\n \nenum edac_type {\n\tEDAC_UNKNOWN =\t0,\n\tEDAC_NONE,\n\tEDAC_RESERVED,\n\tEDAC_PARITY,\n\tEDAC_EC,\n\tEDAC_SECDED,\n\tEDAC_S2ECD2ED,\n\tEDAC_S4ECD4ED,\n\tEDAC_S8ECD8ED,\n\tEDAC_S16ECD16ED,\n};\n\n#define EDAC_FLAG_UNKNOWN\tBIT(EDAC_UNKNOWN)\n#define EDAC_FLAG_NONE\t\tBIT(EDAC_NONE)\n#define EDAC_FLAG_PARITY\tBIT(EDAC_PARITY)\n#define EDAC_FLAG_EC\t\tBIT(EDAC_EC)\n#define EDAC_FLAG_SECDED\tBIT(EDAC_SECDED)\n#define EDAC_FLAG_S2ECD2ED\tBIT(EDAC_S2ECD2ED)\n#define EDAC_FLAG_S4ECD4ED\tBIT(EDAC_S4ECD4ED)\n#define EDAC_FLAG_S8ECD8ED\tBIT(EDAC_S8ECD8ED)\n#define EDAC_FLAG_S16ECD16ED\tBIT(EDAC_S16ECD16ED)\n\n \nenum scrub_type {\n\tSCRUB_UNKNOWN =\t0,\n\tSCRUB_NONE,\n\tSCRUB_SW_PROG,\n\tSCRUB_SW_SRC,\n\tSCRUB_SW_PROG_SRC,\n\tSCRUB_SW_TUNABLE,\n\tSCRUB_HW_PROG,\n\tSCRUB_HW_SRC,\n\tSCRUB_HW_PROG_SRC,\n\tSCRUB_HW_TUNABLE\n};\n\n#define SCRUB_FLAG_SW_PROG\tBIT(SCRUB_SW_PROG)\n#define SCRUB_FLAG_SW_SRC\tBIT(SCRUB_SW_SRC)\n#define SCRUB_FLAG_SW_PROG_SRC\tBIT(SCRUB_SW_PROG_SRC)\n#define SCRUB_FLAG_SW_TUN\tBIT(SCRUB_SW_SCRUB_TUNABLE)\n#define SCRUB_FLAG_HW_PROG\tBIT(SCRUB_HW_PROG)\n#define SCRUB_FLAG_HW_SRC\tBIT(SCRUB_HW_SRC)\n#define SCRUB_FLAG_HW_PROG_SRC\tBIT(SCRUB_HW_PROG_SRC)\n#define SCRUB_FLAG_HW_TUN\tBIT(SCRUB_HW_TUNABLE)\n\n \n\n \n#define\tOP_ALLOC\t\t0x100\n#define OP_RUNNING_POLL\t\t0x201\n#define OP_RUNNING_INTERRUPT\t0x202\n#define OP_RUNNING_POLL_INTR\t0x203\n#define OP_OFFLINE\t\t0x300\n\n \nenum edac_mc_layer_type {\n\tEDAC_MC_LAYER_BRANCH,\n\tEDAC_MC_LAYER_CHANNEL,\n\tEDAC_MC_LAYER_SLOT,\n\tEDAC_MC_LAYER_CHIP_SELECT,\n\tEDAC_MC_LAYER_ALL_MEM,\n};\n\n \nstruct edac_mc_layer {\n\tenum edac_mc_layer_type\ttype;\n\tunsigned\t\tsize;\n\tbool\t\t\tis_virt_csrow;\n};\n\n \n#define EDAC_MAX_LAYERS\t\t3\n\nstruct dimm_info {\n\tstruct device dev;\n\n\tchar label[EDAC_MC_LABEL_LEN + 1];\t \n\n\t \n\tunsigned int location[EDAC_MAX_LAYERS];\n\n\tstruct mem_ctl_info *mci;\t \n\tunsigned int idx;\t\t \n\n\tu32 grain;\t\t \n\tenum dev_type dtype;\t \n\tenum mem_type mtype;\t \n\tenum edac_type edac_mode;\t \n\n\tu32 nr_pages;\t\t\t \n\n\tunsigned int csrow, cschannel;\t \n\n\tu16 smbios_handle;               \n\n\tu32 ce_count;\n\tu32 ue_count;\n};\n\n \nstruct rank_info {\n\tint chan_idx;\n\tstruct csrow_info *csrow;\n\tstruct dimm_info *dimm;\n\n\tu32 ce_count;\t\t \n};\n\nstruct csrow_info {\n\tstruct device dev;\n\n\t \n\tunsigned long first_page;\t \n\tunsigned long last_page;\t \n\tunsigned long page_mask;\t \n\n\tint csrow_idx;\t\t\t \n\n\tu32 ue_count;\t\t \n\tu32 ce_count;\t\t \n\n\tstruct mem_ctl_info *mci;\t \n\n\t \n\tu32 nr_channels;\n\tstruct rank_info **channels;\n};\n\n \nstruct errcount_attribute_data {\n\tint n_layers;\n\tint pos[EDAC_MAX_LAYERS];\n\tint layer0, layer1, layer2;\n};\n\n \nstruct edac_raw_error_desc {\n\tchar location[LOCATION_SIZE];\n\tchar label[(EDAC_MC_LABEL_LEN + 1 + sizeof(OTHER_LABEL)) * EDAC_MAX_LABELS];\n\tlong grain;\n\n\tu16 error_count;\n\tenum hw_event_mc_err_type type;\n\tint top_layer;\n\tint mid_layer;\n\tint low_layer;\n\tunsigned long page_frame_number;\n\tunsigned long offset_in_page;\n\tunsigned long syndrome;\n\tconst char *msg;\n\tconst char *other_detail;\n};\n\n \nstruct mem_ctl_info {\n\tstruct device\t\t\tdev;\n\tstruct bus_type\t\t\t*bus;\n\n\tstruct list_head link;\t \n\n\tstruct module *owner;\t \n\n\tunsigned long mtype_cap;\t \n\tunsigned long edac_ctl_cap;\t \n\tunsigned long edac_cap;\t \n\tunsigned long scrub_cap;\t \n\tenum scrub_type scrub_mode;\t \n\n\t \n\tint (*set_sdram_scrub_rate) (struct mem_ctl_info * mci, u32 bw);\n\n\t \n\tint (*get_sdram_scrub_rate) (struct mem_ctl_info * mci);\n\n\n\t \n\tvoid (*edac_check) (struct mem_ctl_info * mci);\n\n\t \n\t \n\tunsigned long (*ctl_page_to_phys) (struct mem_ctl_info * mci,\n\t\t\t\t\t   unsigned long page);\n\tint mc_idx;\n\tstruct csrow_info **csrows;\n\tunsigned int nr_csrows, num_cschannel;\n\n\t \n\tunsigned int n_layers;\n\tstruct edac_mc_layer *layers;\n\tbool csbased;\n\n\t \n\tunsigned int tot_dimms;\n\tstruct dimm_info **dimms;\n\n\t \n\tstruct device *pdev;\n\tconst char *mod_name;\n\tconst char *ctl_name;\n\tconst char *dev_name;\n\tvoid *pvt_info;\n\tunsigned long start_time;\t \n\n\t \n\tu32 ce_noinfo_count, ue_noinfo_count;\n\tu32 ue_mc, ce_mc;\n\n\tstruct completion complete;\n\n\t \n\tconst struct mcidev_sysfs_attribute *mc_driver_sysfs_attributes;\n\n\t \n\tstruct delayed_work work;\n\n\t \n\tstruct edac_raw_error_desc error_desc;\n\n\t \n\tint op_state;\n\n\tstruct dentry *debugfs;\n\tu8 fake_inject_layer[EDAC_MAX_LAYERS];\n\tbool fake_inject_ue;\n\tu16 fake_inject_count;\n};\n\n#define mci_for_each_dimm(mci, dimm)\t\t\t\t\\\n\tfor ((dimm) = (mci)->dimms[0];\t\t\t\t\\\n\t     (dimm);\t\t\t\t\t\t\\\n\t     (dimm) = (dimm)->idx + 1 < (mci)->tot_dimms\t\\\n\t\t     ? (mci)->dimms[(dimm)->idx + 1]\t\t\\\n\t\t     : NULL)\n\n \nstatic inline struct dimm_info *edac_get_dimm(struct mem_ctl_info *mci,\n\tint layer0, int layer1, int layer2)\n{\n\tint index;\n\n\tif (layer0 < 0\n\t    || (mci->n_layers > 1 && layer1 < 0)\n\t    || (mci->n_layers > 2 && layer2 < 0))\n\t\treturn NULL;\n\n\tindex = layer0;\n\n\tif (mci->n_layers > 1)\n\t\tindex = index * mci->layers[1].size + layer1;\n\n\tif (mci->n_layers > 2)\n\t\tindex = index * mci->layers[2].size + layer2;\n\n\tif (index < 0 || index >= mci->tot_dimms)\n\t\treturn NULL;\n\n\tif (WARN_ON_ONCE(mci->dimms[index]->idx != index))\n\t\treturn NULL;\n\n\treturn mci->dimms[index];\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}