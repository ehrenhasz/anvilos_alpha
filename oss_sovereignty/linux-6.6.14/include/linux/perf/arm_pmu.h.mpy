{
  "module_name": "arm_pmu.h",
  "hash_id": "09afb6e9fa61704f1533c135a61bd7abd03a3c321c887d662b1f25dd7622a195",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/perf/arm_pmu.h",
  "human_readable_source": " \n \n\n#ifndef __ARM_PMU_H__\n#define __ARM_PMU_H__\n\n#include <linux/interrupt.h>\n#include <linux/perf_event.h>\n#include <linux/platform_device.h>\n#include <linux/sysfs.h>\n#include <asm/cputype.h>\n\n#ifdef CONFIG_ARM_PMU\n\n \n#define ARMPMU_MAX_HWEVENTS\t\t32\n\n \n#define ARMPMU_EVT_64BIT\t\t0x00001  \n#define ARMPMU_EVT_47BIT\t\t0x00002  \n#define ARMPMU_EVT_63BIT\t\t0x00004  \n\nstatic_assert((PERF_EVENT_FLAG_ARCH & ARMPMU_EVT_64BIT) == ARMPMU_EVT_64BIT);\nstatic_assert((PERF_EVENT_FLAG_ARCH & ARMPMU_EVT_47BIT) == ARMPMU_EVT_47BIT);\nstatic_assert((PERF_EVENT_FLAG_ARCH & ARMPMU_EVT_63BIT) == ARMPMU_EVT_63BIT);\n\n#define HW_OP_UNSUPPORTED\t\t0xFFFF\n#define C(_x)\t\t\t\tPERF_COUNT_HW_CACHE_##_x\n#define CACHE_OP_UNSUPPORTED\t\t0xFFFF\n\n#define PERF_MAP_ALL_UNSUPPORTED\t\t\t\t\t\\\n\t[0 ... PERF_COUNT_HW_MAX - 1] = HW_OP_UNSUPPORTED\n\n#define PERF_CACHE_MAP_ALL_UNSUPPORTED\t\t\t\t\t\\\n[0 ... C(MAX) - 1] = {\t\t\t\t\t\t\t\\\n\t[0 ... C(OP_MAX) - 1] = {\t\t\t\t\t\\\n\t\t[0 ... C(RESULT_MAX) - 1] = CACHE_OP_UNSUPPORTED,\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n \nstruct pmu_hw_events {\n\t \n\tstruct perf_event\t*events[ARMPMU_MAX_HWEVENTS];\n\n\t \n\tDECLARE_BITMAP(used_mask, ARMPMU_MAX_HWEVENTS);\n\n\t \n\traw_spinlock_t\t\tpmu_lock;\n\n\t \n\tstruct arm_pmu\t\t*percpu_pmu;\n\n\tint irq;\n};\n\nenum armpmu_attr_groups {\n\tARMPMU_ATTR_GROUP_COMMON,\n\tARMPMU_ATTR_GROUP_EVENTS,\n\tARMPMU_ATTR_GROUP_FORMATS,\n\tARMPMU_ATTR_GROUP_CAPS,\n\tARMPMU_NR_ATTR_GROUPS\n};\n\nstruct arm_pmu {\n\tstruct pmu\tpmu;\n\tcpumask_t\tsupported_cpus;\n\tchar\t\t*name;\n\tint\t\tpmuver;\n\tirqreturn_t\t(*handle_irq)(struct arm_pmu *pmu);\n\tvoid\t\t(*enable)(struct perf_event *event);\n\tvoid\t\t(*disable)(struct perf_event *event);\n\tint\t\t(*get_event_idx)(struct pmu_hw_events *hw_events,\n\t\t\t\t\t struct perf_event *event);\n\tvoid\t\t(*clear_event_idx)(struct pmu_hw_events *hw_events,\n\t\t\t\t\t struct perf_event *event);\n\tint\t\t(*set_event_filter)(struct hw_perf_event *evt,\n\t\t\t\t\t    struct perf_event_attr *attr);\n\tu64\t\t(*read_counter)(struct perf_event *event);\n\tvoid\t\t(*write_counter)(struct perf_event *event, u64 val);\n\tvoid\t\t(*start)(struct arm_pmu *);\n\tvoid\t\t(*stop)(struct arm_pmu *);\n\tvoid\t\t(*reset)(void *);\n\tint\t\t(*map_event)(struct perf_event *event);\n\tint\t\tnum_events;\n\tbool\t\tsecure_access;  \n#define ARMV8_PMUV3_MAX_COMMON_EVENTS\t\t0x40\n\tDECLARE_BITMAP(pmceid_bitmap, ARMV8_PMUV3_MAX_COMMON_EVENTS);\n#define ARMV8_PMUV3_EXT_COMMON_EVENT_BASE\t0x4000\n\tDECLARE_BITMAP(pmceid_ext_bitmap, ARMV8_PMUV3_MAX_COMMON_EVENTS);\n\tstruct platform_device\t*plat_device;\n\tstruct pmu_hw_events\t__percpu *hw_events;\n\tstruct hlist_node\tnode;\n\tstruct notifier_block\tcpu_pm_nb;\n\t \n\tconst struct attribute_group *attr_groups[ARMPMU_NR_ATTR_GROUPS + 1];\n\t \n\tu64\t\treg_pmmir;\n\n\t \n\tunsigned long acpi_cpuid;\n};\n\n#define to_arm_pmu(p) (container_of(p, struct arm_pmu, pmu))\n\nu64 armpmu_event_update(struct perf_event *event);\n\nint armpmu_event_set_period(struct perf_event *event);\n\nint armpmu_map_event(struct perf_event *event,\n\t\t     const unsigned (*event_map)[PERF_COUNT_HW_MAX],\n\t\t     const unsigned (*cache_map)[PERF_COUNT_HW_CACHE_MAX]\n\t\t\t\t\t\t[PERF_COUNT_HW_CACHE_OP_MAX]\n\t\t\t\t\t\t[PERF_COUNT_HW_CACHE_RESULT_MAX],\n\t\t     u32 raw_event_mask);\n\ntypedef int (*armpmu_init_fn)(struct arm_pmu *);\n\nstruct pmu_probe_info {\n\tunsigned int cpuid;\n\tunsigned int mask;\n\tarmpmu_init_fn init;\n};\n\n#define PMU_PROBE(_cpuid, _mask, _fn)\t\\\n{\t\t\t\t\t\\\n\t.cpuid = (_cpuid),\t\t\\\n\t.mask = (_mask),\t\t\\\n\t.init = (_fn),\t\t\t\\\n}\n\n#define ARM_PMU_PROBE(_cpuid, _fn) \\\n\tPMU_PROBE(_cpuid, ARM_CPU_PART_MASK, _fn)\n\n#define ARM_PMU_XSCALE_MASK\t((0xff << 24) | ARM_CPU_XSCALE_ARCH_MASK)\n\n#define XSCALE_PMU_PROBE(_version, _fn) \\\n\tPMU_PROBE(ARM_CPU_IMP_INTEL << 24 | _version, ARM_PMU_XSCALE_MASK, _fn)\n\nint arm_pmu_device_probe(struct platform_device *pdev,\n\t\t\t const struct of_device_id *of_table,\n\t\t\t const struct pmu_probe_info *probe_table);\n\n#ifdef CONFIG_ACPI\nint arm_pmu_acpi_probe(armpmu_init_fn init_fn);\n#else\nstatic inline int arm_pmu_acpi_probe(armpmu_init_fn init_fn) { return 0; }\n#endif\n\n#ifdef CONFIG_KVM\nvoid kvm_host_pmu_init(struct arm_pmu *pmu);\n#else\n#define kvm_host_pmu_init(x)\tdo { } while(0)\n#endif\n\nbool arm_pmu_irq_is_nmi(void);\n\n \nstruct arm_pmu *armpmu_alloc(void);\nvoid armpmu_free(struct arm_pmu *pmu);\nint armpmu_register(struct arm_pmu *pmu);\nint armpmu_request_irq(int irq, int cpu);\nvoid armpmu_free_irq(int irq, int cpu);\n\n#define ARMV8_PMU_PDEV_NAME \"armv8-pmu\"\n\n#endif  \n\n#define ARMV8_SPE_PDEV_NAME \"arm,spe-v1\"\n#define ARMV8_TRBE_PDEV_NAME \"arm,trbe\"\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}