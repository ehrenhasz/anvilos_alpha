{
  "module_name": "mtd.h",
  "hash_id": "26d3e6e1b6594017791c8f266f820f11d11c07c878a38e917454ce66253457ca",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mtd/mtd.h",
  "human_readable_source": " \n \n\n#ifndef __MTD_MTD_H__\n#define __MTD_MTD_H__\n\n#include <linux/types.h>\n#include <linux/uio.h>\n#include <linux/list.h>\n#include <linux/notifier.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/nvmem-provider.h>\n\n#include <mtd/mtd-abi.h>\n\n#include <asm/div64.h>\n\n#define MTD_FAIL_ADDR_UNKNOWN -1LL\n\nstruct mtd_info;\n\n \nstruct erase_info {\n\tuint64_t addr;\n\tuint64_t len;\n\tuint64_t fail_addr;\n};\n\nstruct mtd_erase_region_info {\n\tuint64_t offset;\t\t \n\tuint32_t erasesize;\t\t \n\tuint32_t numblocks;\t\t \n\tunsigned long *lockmap;\t\t \n};\n\nstruct mtd_req_stats {\n\tunsigned int uncorrectable_errors;\n\tunsigned int corrected_bitflips;\n\tunsigned int max_bitflips;\n};\n\n \nstruct mtd_oob_ops {\n\tunsigned int\tmode;\n\tsize_t\t\tlen;\n\tsize_t\t\tretlen;\n\tsize_t\t\tooblen;\n\tsize_t\t\toobretlen;\n\tuint32_t\tooboffs;\n\tuint8_t\t\t*datbuf;\n\tuint8_t\t\t*oobbuf;\n\tstruct mtd_req_stats *stats;\n};\n\n \nstruct mtd_oob_region {\n\tu32 offset;\n\tu32 length;\n};\n\n \nstruct mtd_ooblayout_ops {\n\tint (*ecc)(struct mtd_info *mtd, int section,\n\t\t   struct mtd_oob_region *oobecc);\n\tint (*free)(struct mtd_info *mtd, int section,\n\t\t    struct mtd_oob_region *oobfree);\n};\n\n \nstruct mtd_pairing_info {\n\tint pair;\n\tint group;\n};\n\n \nstruct mtd_pairing_scheme {\n\tint ngroups;\n\tint (*get_info)(struct mtd_info *mtd, int wunit,\n\t\t\tstruct mtd_pairing_info *info);\n\tint (*get_wunit)(struct mtd_info *mtd,\n\t\t\t const struct mtd_pairing_info *info);\n};\n\nstruct module;\t \n\n \nstruct mtd_debug_info {\n\tstruct dentry *dfs_dir;\n};\n\n \nstruct mtd_part {\n\tstruct list_head node;\n\tu64 offset;\n\tu64 size;\n\tu32 flags;\n};\n\n \nstruct mtd_master {\n\tstruct mutex partitions_lock;\n\tstruct mutex chrdev_lock;\n\tunsigned int suspended : 1;\n};\n\nstruct mtd_info {\n\tu_char type;\n\tuint32_t flags;\n\tuint64_t size;\t  \n\n\t \n\tuint32_t erasesize;\n\t \n\tuint32_t writesize;\n\n\t \n\tuint32_t writebufsize;\n\n\tuint32_t oobsize;   \n\tuint32_t oobavail;  \n\n\t \n\tunsigned int erasesize_shift;\n\tunsigned int writesize_shift;\n\t \n\tunsigned int erasesize_mask;\n\tunsigned int writesize_mask;\n\n\t \n\tunsigned int bitflip_threshold;\n\n\t \n\tconst char *name;\n\tint index;\n\n\t \n\tconst struct mtd_ooblayout_ops *ooblayout;\n\n\t \n\tconst struct mtd_pairing_scheme *pairing;\n\n\t \n\tunsigned int ecc_step_size;\n\n\t \n\tunsigned int ecc_strength;\n\n\t \n\tint numeraseregions;\n\tstruct mtd_erase_region_info *eraseregions;\n\n\t \n\tint (*_erase) (struct mtd_info *mtd, struct erase_info *instr);\n\tint (*_point) (struct mtd_info *mtd, loff_t from, size_t len,\n\t\t       size_t *retlen, void **virt, resource_size_t *phys);\n\tint (*_unpoint) (struct mtd_info *mtd, loff_t from, size_t len);\n\tint (*_read) (struct mtd_info *mtd, loff_t from, size_t len,\n\t\t      size_t *retlen, u_char *buf);\n\tint (*_write) (struct mtd_info *mtd, loff_t to, size_t len,\n\t\t       size_t *retlen, const u_char *buf);\n\tint (*_panic_write) (struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t     size_t *retlen, const u_char *buf);\n\tint (*_read_oob) (struct mtd_info *mtd, loff_t from,\n\t\t\t  struct mtd_oob_ops *ops);\n\tint (*_write_oob) (struct mtd_info *mtd, loff_t to,\n\t\t\t   struct mtd_oob_ops *ops);\n\tint (*_get_fact_prot_info) (struct mtd_info *mtd, size_t len,\n\t\t\t\t    size_t *retlen, struct otp_info *buf);\n\tint (*_read_fact_prot_reg) (struct mtd_info *mtd, loff_t from,\n\t\t\t\t    size_t len, size_t *retlen, u_char *buf);\n\tint (*_get_user_prot_info) (struct mtd_info *mtd, size_t len,\n\t\t\t\t    size_t *retlen, struct otp_info *buf);\n\tint (*_read_user_prot_reg) (struct mtd_info *mtd, loff_t from,\n\t\t\t\t    size_t len, size_t *retlen, u_char *buf);\n\tint (*_write_user_prot_reg) (struct mtd_info *mtd, loff_t to,\n\t\t\t\t     size_t len, size_t *retlen,\n\t\t\t\t     const u_char *buf);\n\tint (*_lock_user_prot_reg) (struct mtd_info *mtd, loff_t from,\n\t\t\t\t    size_t len);\n\tint (*_erase_user_prot_reg) (struct mtd_info *mtd, loff_t from,\n\t\t\t\t     size_t len);\n\tint (*_writev) (struct mtd_info *mtd, const struct kvec *vecs,\n\t\t\tunsigned long count, loff_t to, size_t *retlen);\n\tvoid (*_sync) (struct mtd_info *mtd);\n\tint (*_lock) (struct mtd_info *mtd, loff_t ofs, uint64_t len);\n\tint (*_unlock) (struct mtd_info *mtd, loff_t ofs, uint64_t len);\n\tint (*_is_locked) (struct mtd_info *mtd, loff_t ofs, uint64_t len);\n\tint (*_block_isreserved) (struct mtd_info *mtd, loff_t ofs);\n\tint (*_block_isbad) (struct mtd_info *mtd, loff_t ofs);\n\tint (*_block_markbad) (struct mtd_info *mtd, loff_t ofs);\n\tint (*_max_bad_blocks) (struct mtd_info *mtd, loff_t ofs, size_t len);\n\tint (*_suspend) (struct mtd_info *mtd);\n\tvoid (*_resume) (struct mtd_info *mtd);\n\tvoid (*_reboot) (struct mtd_info *mtd);\n\t \n\tint (*_get_device) (struct mtd_info *mtd);\n\tvoid (*_put_device) (struct mtd_info *mtd);\n\n\t \n\tbool oops_panic_write;\n\n\tstruct notifier_block reboot_notifier;   \n\n\t \n\tstruct mtd_ecc_stats ecc_stats;\n\t \n\tint subpage_sft;\n\n\tvoid *priv;\n\n\tstruct module *owner;\n\tstruct device dev;\n\tstruct kref refcnt;\n\tstruct mtd_debug_info dbg;\n\tstruct nvmem_device *nvmem;\n\tstruct nvmem_device *otp_user_nvmem;\n\tstruct nvmem_device *otp_factory_nvmem;\n\n\t \n\tstruct mtd_info *parent;\n\n\t \n\tstruct list_head partitions;\n\n\tstruct mtd_part part;\n\tstruct mtd_master master;\n};\n\nstatic inline struct mtd_info *mtd_get_master(struct mtd_info *mtd)\n{\n\twhile (mtd->parent)\n\t\tmtd = mtd->parent;\n\n\treturn mtd;\n}\n\nstatic inline u64 mtd_get_master_ofs(struct mtd_info *mtd, u64 ofs)\n{\n\twhile (mtd->parent) {\n\t\tofs += mtd->part.offset;\n\t\tmtd = mtd->parent;\n\t}\n\n\treturn ofs;\n}\n\nstatic inline bool mtd_is_partition(const struct mtd_info *mtd)\n{\n\treturn mtd->parent;\n}\n\nstatic inline bool mtd_has_partitions(const struct mtd_info *mtd)\n{\n\treturn !list_empty(&mtd->partitions);\n}\n\nint mtd_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t      struct mtd_oob_region *oobecc);\nint mtd_ooblayout_find_eccregion(struct mtd_info *mtd, int eccbyte,\n\t\t\t\t int *section,\n\t\t\t\t struct mtd_oob_region *oobregion);\nint mtd_ooblayout_get_eccbytes(struct mtd_info *mtd, u8 *eccbuf,\n\t\t\t       const u8 *oobbuf, int start, int nbytes);\nint mtd_ooblayout_set_eccbytes(struct mtd_info *mtd, const u8 *eccbuf,\n\t\t\t       u8 *oobbuf, int start, int nbytes);\nint mtd_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t       struct mtd_oob_region *oobfree);\nint mtd_ooblayout_get_databytes(struct mtd_info *mtd, u8 *databuf,\n\t\t\t\tconst u8 *oobbuf, int start, int nbytes);\nint mtd_ooblayout_set_databytes(struct mtd_info *mtd, const u8 *databuf,\n\t\t\t\tu8 *oobbuf, int start, int nbytes);\nint mtd_ooblayout_count_freebytes(struct mtd_info *mtd);\nint mtd_ooblayout_count_eccbytes(struct mtd_info *mtd);\n\nstatic inline void mtd_set_ooblayout(struct mtd_info *mtd,\n\t\t\t\t     const struct mtd_ooblayout_ops *ooblayout)\n{\n\tmtd->ooblayout = ooblayout;\n}\n\nstatic inline void mtd_set_pairing_scheme(struct mtd_info *mtd,\n\t\t\t\tconst struct mtd_pairing_scheme *pairing)\n{\n\tmtd->pairing = pairing;\n}\n\nstatic inline void mtd_set_of_node(struct mtd_info *mtd,\n\t\t\t\t   struct device_node *np)\n{\n\tmtd->dev.of_node = np;\n\tif (!mtd->name)\n\t\tof_property_read_string(np, \"label\", &mtd->name);\n}\n\nstatic inline struct device_node *mtd_get_of_node(struct mtd_info *mtd)\n{\n\treturn dev_of_node(&mtd->dev);\n}\n\nstatic inline u32 mtd_oobavail(struct mtd_info *mtd, struct mtd_oob_ops *ops)\n{\n\treturn ops->mode == MTD_OPS_AUTO_OOB ? mtd->oobavail : mtd->oobsize;\n}\n\nstatic inline int mtd_max_bad_blocks(struct mtd_info *mtd,\n\t\t\t\t     loff_t ofs, size_t len)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (!master->_max_bad_blocks)\n\t\treturn -ENOTSUPP;\n\n\tif (mtd->size < (len + ofs) || ofs < 0)\n\t\treturn -EINVAL;\n\n\treturn master->_max_bad_blocks(master, mtd_get_master_ofs(mtd, ofs),\n\t\t\t\t       len);\n}\n\nint mtd_wunit_to_pairing_info(struct mtd_info *mtd, int wunit,\n\t\t\t      struct mtd_pairing_info *info);\nint mtd_pairing_info_to_wunit(struct mtd_info *mtd,\n\t\t\t      const struct mtd_pairing_info *info);\nint mtd_pairing_groups(struct mtd_info *mtd);\nint mtd_erase(struct mtd_info *mtd, struct erase_info *instr);\nint mtd_point(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,\n\t      void **virt, resource_size_t *phys);\nint mtd_unpoint(struct mtd_info *mtd, loff_t from, size_t len);\nunsigned long mtd_get_unmapped_area(struct mtd_info *mtd, unsigned long len,\n\t\t\t\t    unsigned long offset, unsigned long flags);\nint mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,\n\t     u_char *buf);\nint mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,\n\t      const u_char *buf);\nint mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,\n\t\t    const u_char *buf);\n\nint mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops);\nint mtd_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops);\n\nint mtd_get_fact_prot_info(struct mtd_info *mtd, size_t len, size_t *retlen,\n\t\t\t   struct otp_info *buf);\nint mtd_read_fact_prot_reg(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t   size_t *retlen, u_char *buf);\nint mtd_get_user_prot_info(struct mtd_info *mtd, size_t len, size_t *retlen,\n\t\t\t   struct otp_info *buf);\nint mtd_read_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t   size_t *retlen, u_char *buf);\nint mtd_write_user_prot_reg(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t    size_t *retlen, const u_char *buf);\nint mtd_lock_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len);\nint mtd_erase_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len);\n\nint mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,\n\t       unsigned long count, loff_t to, size_t *retlen);\n\nstatic inline void mtd_sync(struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (master->_sync)\n\t\tmaster->_sync(master);\n}\n\nint mtd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nint mtd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nint mtd_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nint mtd_block_isreserved(struct mtd_info *mtd, loff_t ofs);\nint mtd_block_isbad(struct mtd_info *mtd, loff_t ofs);\nint mtd_block_markbad(struct mtd_info *mtd, loff_t ofs);\n\nstatic inline int mtd_suspend(struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint ret;\n\n\tif (master->master.suspended)\n\t\treturn 0;\n\n\tret = master->_suspend ? master->_suspend(master) : 0;\n\tif (ret)\n\t\treturn ret;\n\n\tmaster->master.suspended = 1;\n\treturn 0;\n}\n\nstatic inline void mtd_resume(struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (!master->master.suspended)\n\t\treturn;\n\n\tif (master->_resume)\n\t\tmaster->_resume(master);\n\n\tmaster->master.suspended = 0;\n}\n\nstatic inline uint32_t mtd_div_by_eb(uint64_t sz, struct mtd_info *mtd)\n{\n\tif (mtd->erasesize_shift)\n\t\treturn sz >> mtd->erasesize_shift;\n\tdo_div(sz, mtd->erasesize);\n\treturn sz;\n}\n\nstatic inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)\n{\n\tif (mtd->erasesize_shift)\n\t\treturn sz & mtd->erasesize_mask;\n\treturn do_div(sz, mtd->erasesize);\n}\n\n \nstatic inline void mtd_align_erase_req(struct mtd_info *mtd,\n\t\t\t\t       struct erase_info *req)\n{\n\tu32 mod;\n\n\tif (WARN_ON(!mtd->erasesize))\n\t\treturn;\n\n\tmod = mtd_mod_by_eb(req->addr, mtd);\n\tif (mod) {\n\t\treq->addr -= mod;\n\t\treq->len += mod;\n\t}\n\n\tmod = mtd_mod_by_eb(req->addr + req->len, mtd);\n\tif (mod)\n\t\treq->len += mtd->erasesize - mod;\n}\n\nstatic inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)\n{\n\tif (mtd->writesize_shift)\n\t\treturn sz >> mtd->writesize_shift;\n\tdo_div(sz, mtd->writesize);\n\treturn sz;\n}\n\nstatic inline uint32_t mtd_mod_by_ws(uint64_t sz, struct mtd_info *mtd)\n{\n\tif (mtd->writesize_shift)\n\t\treturn sz & mtd->writesize_mask;\n\treturn do_div(sz, mtd->writesize);\n}\n\nstatic inline int mtd_wunit_per_eb(struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\treturn master->erasesize / mtd->writesize;\n}\n\nstatic inline int mtd_offset_to_wunit(struct mtd_info *mtd, loff_t offs)\n{\n\treturn mtd_div_by_ws(mtd_mod_by_eb(offs, mtd), mtd);\n}\n\nstatic inline loff_t mtd_wunit_to_offset(struct mtd_info *mtd, loff_t base,\n\t\t\t\t\t int wunit)\n{\n\treturn base + (wunit * mtd->writesize);\n}\n\n\nstatic inline int mtd_has_oob(const struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master((struct mtd_info *)mtd);\n\n\treturn master->_read_oob && master->_write_oob;\n}\n\nstatic inline int mtd_type_is_nand(const struct mtd_info *mtd)\n{\n\treturn mtd->type == MTD_NANDFLASH || mtd->type == MTD_MLCNANDFLASH;\n}\n\nstatic inline int mtd_can_have_bb(const struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master((struct mtd_info *)mtd);\n\n\treturn !!master->_block_isbad;\n}\n\n\t \n\nstruct mtd_partition;\nstruct mtd_part_parser_data;\n\nextern int mtd_device_parse_register(struct mtd_info *mtd,\n\t\t\t\t     const char * const *part_probe_types,\n\t\t\t\t     struct mtd_part_parser_data *parser_data,\n\t\t\t\t     const struct mtd_partition *defparts,\n\t\t\t\t     int defnr_parts);\n#define mtd_device_register(master, parts, nr_parts)\t\\\n\tmtd_device_parse_register(master, NULL, NULL, parts, nr_parts)\nextern int mtd_device_unregister(struct mtd_info *master);\nextern struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num);\nextern int __get_mtd_device(struct mtd_info *mtd);\nextern void __put_mtd_device(struct mtd_info *mtd);\nextern struct mtd_info *of_get_mtd_device_by_node(struct device_node *np);\nextern struct mtd_info *get_mtd_device_nm(const char *name);\nextern void put_mtd_device(struct mtd_info *mtd);\n\n\nstruct mtd_notifier {\n\tvoid (*add)(struct mtd_info *mtd);\n\tvoid (*remove)(struct mtd_info *mtd);\n\tstruct list_head list;\n};\n\n\nextern void register_mtd_user (struct mtd_notifier *new);\nextern int unregister_mtd_user (struct mtd_notifier *old);\nvoid *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size);\n\nstatic inline int mtd_is_bitflip(int err) {\n\treturn err == -EUCLEAN;\n}\n\nstatic inline int mtd_is_eccerr(int err) {\n\treturn err == -EBADMSG;\n}\n\nstatic inline int mtd_is_bitflip_or_eccerr(int err) {\n\treturn mtd_is_bitflip(err) || mtd_is_eccerr(err);\n}\n\nunsigned mtd_mmap_capabilities(struct mtd_info *mtd);\n\n#ifdef CONFIG_DEBUG_FS\nbool mtd_check_expert_analysis_mode(void);\n#else\nstatic inline bool mtd_check_expert_analysis_mode(void) { return false; }\n#endif\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}