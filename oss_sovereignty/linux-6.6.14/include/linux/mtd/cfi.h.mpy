{
  "module_name": "cfi.h",
  "hash_id": "51b02c5bb312c089bacc578ac3c4ec9977765047595e150f6f4deb337a49dc63",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mtd/cfi.h",
  "human_readable_source": " \n \n\n#ifndef __MTD_CFI_H__\n#define __MTD_CFI_H__\n\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/bug.h>\n#include <linux/interrupt.h>\n#include <linux/mtd/flashchip.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/cfi_endian.h>\n#include <linux/mtd/xip.h>\n\n#ifdef CONFIG_MTD_CFI_I1\n#define cfi_interleave(cfi) 1\n#define cfi_interleave_is_1(cfi) (cfi_interleave(cfi) == 1)\n#else\n#define cfi_interleave_is_1(cfi) (0)\n#endif\n\n#ifdef CONFIG_MTD_CFI_I2\n# ifdef cfi_interleave\n#  undef cfi_interleave\n#  define cfi_interleave(cfi) ((cfi)->interleave)\n# else\n#  define cfi_interleave(cfi) 2\n# endif\n#define cfi_interleave_is_2(cfi) (cfi_interleave(cfi) == 2)\n#else\n#define cfi_interleave_is_2(cfi) (0)\n#endif\n\n#ifdef CONFIG_MTD_CFI_I4\n# ifdef cfi_interleave\n#  undef cfi_interleave\n#  define cfi_interleave(cfi) ((cfi)->interleave)\n# else\n#  define cfi_interleave(cfi) 4\n# endif\n#define cfi_interleave_is_4(cfi) (cfi_interleave(cfi) == 4)\n#else\n#define cfi_interleave_is_4(cfi) (0)\n#endif\n\n#ifdef CONFIG_MTD_CFI_I8\n# ifdef cfi_interleave\n#  undef cfi_interleave\n#  define cfi_interleave(cfi) ((cfi)->interleave)\n# else\n#  define cfi_interleave(cfi) 8\n# endif\n#define cfi_interleave_is_8(cfi) (cfi_interleave(cfi) == 8)\n#else\n#define cfi_interleave_is_8(cfi) (0)\n#endif\n\n#ifndef cfi_interleave\n#warning No CONFIG_MTD_CFI_Ix selected. No NOR chip support can work.\nstatic inline int cfi_interleave(void *cfi)\n{\n\tBUG();\n\treturn 0;\n}\n#endif\n\nstatic inline int cfi_interleave_supported(int i)\n{\n\tswitch (i) {\n#ifdef CONFIG_MTD_CFI_I1\n\tcase 1:\n#endif\n#ifdef CONFIG_MTD_CFI_I2\n\tcase 2:\n#endif\n#ifdef CONFIG_MTD_CFI_I4\n\tcase 4:\n#endif\n#ifdef CONFIG_MTD_CFI_I8\n\tcase 8:\n#endif\n\t\treturn 1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n \n#define CFI_DEVICETYPE_X8  (8 / 8)\n#define CFI_DEVICETYPE_X16 (16 / 8)\n#define CFI_DEVICETYPE_X32 (32 / 8)\n#define CFI_DEVICETYPE_X64 (64 / 8)\n\n\n \n#define CFI_INTERFACE_X8_ASYNC\t\t0x0000\n#define CFI_INTERFACE_X16_ASYNC\t\t0x0001\n#define CFI_INTERFACE_X8_BY_X16_ASYNC\t0x0002\n#define CFI_INTERFACE_X32_ASYNC\t\t0x0003\n#define CFI_INTERFACE_X16_BY_X32_ASYNC\t0x0005\n#define CFI_INTERFACE_NOT_ALLOWED\t0xffff\n\n\n \n\n \nstruct cfi_ident {\n\tuint8_t  qry[3];\n\tuint16_t P_ID;\n\tuint16_t P_ADR;\n\tuint16_t A_ID;\n\tuint16_t A_ADR;\n\tuint8_t  VccMin;\n\tuint8_t  VccMax;\n\tuint8_t  VppMin;\n\tuint8_t  VppMax;\n\tuint8_t  WordWriteTimeoutTyp;\n\tuint8_t  BufWriteTimeoutTyp;\n\tuint8_t  BlockEraseTimeoutTyp;\n\tuint8_t  ChipEraseTimeoutTyp;\n\tuint8_t  WordWriteTimeoutMax;\n\tuint8_t  BufWriteTimeoutMax;\n\tuint8_t  BlockEraseTimeoutMax;\n\tuint8_t  ChipEraseTimeoutMax;\n\tuint8_t  DevSize;\n\tuint16_t InterfaceDesc;\n\tuint16_t MaxBufWriteSize;\n\tuint8_t  NumEraseRegions;\n\tuint32_t EraseRegionInfo[];  \n} __packed;\n\n \n\nstruct cfi_extquery {\n\tuint8_t  pri[3];\n\tuint8_t  MajorVersion;\n\tuint8_t  MinorVersion;\n} __packed;\n\n \n\nstruct cfi_pri_intelext {\n\tuint8_t  pri[3];\n\tuint8_t  MajorVersion;\n\tuint8_t  MinorVersion;\n\tuint32_t FeatureSupport;  \n\tuint8_t  SuspendCmdSupport;\n\tuint16_t BlkStatusRegMask;\n\tuint8_t  VccOptimal;\n\tuint8_t  VppOptimal;\n\tuint8_t  NumProtectionFields;\n\tuint16_t ProtRegAddr;\n\tuint8_t  FactProtRegSize;\n\tuint8_t  UserProtRegSize;\n\tuint8_t  extra[];\n} __packed;\n\nstruct cfi_intelext_otpinfo {\n\tuint32_t ProtRegAddr;\n\tuint16_t FactGroups;\n\tuint8_t  FactProtRegSize;\n\tuint16_t UserGroups;\n\tuint8_t  UserProtRegSize;\n} __packed;\n\nstruct cfi_intelext_blockinfo {\n\tuint16_t NumIdentBlocks;\n\tuint16_t BlockSize;\n\tuint16_t MinBlockEraseCycles;\n\tuint8_t  BitsPerCell;\n\tuint8_t  BlockCap;\n} __packed;\n\nstruct cfi_intelext_regioninfo {\n\tuint16_t NumIdentPartitions;\n\tuint8_t  NumOpAllowed;\n\tuint8_t  NumOpAllowedSimProgMode;\n\tuint8_t  NumOpAllowedSimEraMode;\n\tuint8_t  NumBlockTypes;\n\tstruct cfi_intelext_blockinfo BlockTypes[1];\n} __packed;\n\nstruct cfi_intelext_programming_regioninfo {\n\tuint8_t  ProgRegShift;\n\tuint8_t  Reserved1;\n\tuint8_t  ControlValid;\n\tuint8_t  Reserved2;\n\tuint8_t  ControlInvalid;\n\tuint8_t  Reserved3;\n} __packed;\n\n \n\nstruct cfi_pri_amdstd {\n\tuint8_t  pri[3];\n\tuint8_t  MajorVersion;\n\tuint8_t  MinorVersion;\n\tuint8_t  SiliconRevision;  \n\tuint8_t  EraseSuspend;\n\tuint8_t  BlkProt;\n\tuint8_t  TmpBlkUnprotect;\n\tuint8_t  BlkProtUnprot;\n\tuint8_t  SimultaneousOps;\n\tuint8_t  BurstMode;\n\tuint8_t  PageMode;\n\tuint8_t  VppMin;\n\tuint8_t  VppMax;\n\tuint8_t  TopBottom;\n\t \n\tuint8_t  ProgramSuspend;\n\tuint8_t  UnlockBypass;\n\tuint8_t  SecureSiliconSector;\n\tuint8_t  SoftwareFeatures;\n#define CFI_POLL_STATUS_REG\tBIT(0)\n#define CFI_POLL_DQ\t\tBIT(1)\n} __packed;\n\n \n\nstruct cfi_pri_atmel {\n\tuint8_t pri[3];\n\tuint8_t MajorVersion;\n\tuint8_t MinorVersion;\n\tuint8_t Features;\n\tuint8_t BottomBoot;\n\tuint8_t BurstMode;\n\tuint8_t PageMode;\n} __packed;\n\nstruct cfi_pri_query {\n\tuint8_t  NumFields;\n\tuint32_t ProtField[1];  \n} __packed;\n\nstruct cfi_bri_query {\n\tuint8_t  PageModeReadCap;\n\tuint8_t  NumFields;\n\tuint32_t ConfField[1];  \n} __packed;\n\n#define P_ID_NONE               0x0000\n#define P_ID_INTEL_EXT          0x0001\n#define P_ID_AMD_STD            0x0002\n#define P_ID_INTEL_STD          0x0003\n#define P_ID_AMD_EXT            0x0004\n#define P_ID_WINBOND            0x0006\n#define P_ID_ST_ADV             0x0020\n#define P_ID_MITSUBISHI_STD     0x0100\n#define P_ID_MITSUBISHI_EXT     0x0101\n#define P_ID_SST_PAGE           0x0102\n#define P_ID_SST_OLD            0x0701\n#define P_ID_INTEL_PERFORMANCE  0x0200\n#define P_ID_INTEL_DATA         0x0210\n#define P_ID_RESERVED           0xffff\n\n\n#define CFI_MODE_CFI\t1\n#define CFI_MODE_JEDEC\t0\n\nstruct cfi_private {\n\tuint16_t cmdset;\n\tvoid *cmdset_priv;\n\tint interleave;\n\tint device_type;\n\tint cfi_mode;\t\t \n\tint addr_unlock1;\n\tint addr_unlock2;\n\tstruct mtd_info *(*cmdset_setup)(struct map_info *);\n\tstruct cfi_ident *cfiq;  \n\tint mfr, id;\n\tint numchips;\n\tmap_word sector_erase_cmd;\n\tunsigned long chipshift;  \n\tconst char *im_name;\t  \n\tunsigned long quirks;\n\tstruct flchip chips[];   \n};\n\nuint32_t cfi_build_cmd_addr(uint32_t cmd_ofs,\n\t\t\t\tstruct map_info *map, struct cfi_private *cfi);\n\nmap_word cfi_build_cmd(u_long cmd, struct map_info *map, struct cfi_private *cfi);\n#define CMD(x)  cfi_build_cmd((x), map, cfi)\n\nunsigned long cfi_merge_status(map_word val, struct map_info *map,\n\t\t\t\t\t   struct cfi_private *cfi);\n#define MERGESTATUS(x) cfi_merge_status((x), map, cfi)\n\nuint32_t cfi_send_gen_cmd(u_char cmd, uint32_t cmd_addr, uint32_t base,\n\t\t\t\tstruct map_info *map, struct cfi_private *cfi,\n\t\t\t\tint type, map_word *prev_val);\n\nstatic inline uint8_t cfi_read_query(struct map_info *map, uint32_t addr)\n{\n\tmap_word val = map_read(map, addr);\n\n\tif (map_bankwidth_is_1(map)) {\n\t\treturn val.x[0];\n\t} else if (map_bankwidth_is_2(map)) {\n\t\treturn cfi16_to_cpu(map, val.x[0]);\n\t} else {\n\t\t \n\t\treturn cfi32_to_cpu(map, val.x[0]);\n\t}\n}\n\nstatic inline uint16_t cfi_read_query16(struct map_info *map, uint32_t addr)\n{\n\tmap_word val = map_read(map, addr);\n\n\tif (map_bankwidth_is_1(map)) {\n\t\treturn val.x[0] & 0xff;\n\t} else if (map_bankwidth_is_2(map)) {\n\t\treturn cfi16_to_cpu(map, val.x[0]);\n\t} else {\n\t\t \n\t\treturn cfi32_to_cpu(map, val.x[0]);\n\t}\n}\n\nvoid cfi_udelay(int us);\n\nint __xipram cfi_qry_present(struct map_info *map, __u32 base,\n\t\t\t     struct cfi_private *cfi);\nint __xipram cfi_qry_mode_on(uint32_t base, struct map_info *map,\n\t\t\t     struct cfi_private *cfi);\nvoid __xipram cfi_qry_mode_off(uint32_t base, struct map_info *map,\n\t\t\t       struct cfi_private *cfi);\n\nstruct cfi_extquery *cfi_read_pri(struct map_info *map, uint16_t adr, uint16_t size,\n\t\t\t     const char* name);\nstruct cfi_fixup {\n\tuint16_t mfr;\n\tuint16_t id;\n\tvoid (*fixup)(struct mtd_info *mtd);\n};\n\n#define CFI_MFR_ANY\t\t0xFFFF\n#define CFI_ID_ANY\t\t0xFFFF\n#define CFI_MFR_CONTINUATION\t0x007F\n\n#define CFI_MFR_AMD\t\t0x0001\n#define CFI_MFR_AMIC\t\t0x0037\n#define CFI_MFR_ATMEL\t\t0x001F\n#define CFI_MFR_EON\t\t0x001C\n#define CFI_MFR_FUJITSU\t\t0x0004\n#define CFI_MFR_HYUNDAI\t\t0x00AD\n#define CFI_MFR_INTEL\t\t0x0089\n#define CFI_MFR_MACRONIX\t0x00C2\n#define CFI_MFR_NEC\t\t0x0010\n#define CFI_MFR_PMC\t\t0x009D\n#define CFI_MFR_SAMSUNG\t\t0x00EC\n#define CFI_MFR_SHARP\t\t0x00B0\n#define CFI_MFR_SST\t\t0x00BF\n#define CFI_MFR_ST\t\t0x0020  \n#define CFI_MFR_MICRON\t\t0x002C  \n#define CFI_MFR_TOSHIBA\t\t0x0098\n#define CFI_MFR_WINBOND\t\t0x00DA\n\nvoid cfi_fixup(struct mtd_info *mtd, struct cfi_fixup* fixups);\n\ntypedef int (*varsize_frob_t)(struct map_info *map, struct flchip *chip,\n\t\t\t      unsigned long adr, int len, void *thunk);\n\nint cfi_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,\n\tloff_t ofs, size_t len, void *thunk);\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}