{
  "module_name": "rawnand.h",
  "hash_id": "81abaec8c67aa6410169981530fa69e9c13f0a70b0762b0cb11f337f562d6085",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mtd/rawnand.h",
  "human_readable_source": " \n \n#ifndef __LINUX_MTD_RAWNAND_H\n#define __LINUX_MTD_RAWNAND_H\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/nand.h>\n#include <linux/mtd/flashchip.h>\n#include <linux/mtd/bbm.h>\n#include <linux/mtd/jedec.h>\n#include <linux/mtd/onfi.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/types.h>\n\nstruct nand_chip;\nstruct gpio_desc;\n\n \n#define NAND_MAX_CHIPS\t\t8\n\n \n \n#define NAND_NCE\t\t0x01\n \n#define NAND_CLE\t\t0x02\n \n#define NAND_ALE\t\t0x04\n\n#define NAND_CTRL_CLE\t\t(NAND_NCE | NAND_CLE)\n#define NAND_CTRL_ALE\t\t(NAND_NCE | NAND_ALE)\n#define NAND_CTRL_CHANGE\t0x80\n\n \n#define NAND_CMD_READ0\t\t0\n#define NAND_CMD_READ1\t\t1\n#define NAND_CMD_RNDOUT\t\t5\n#define NAND_CMD_PAGEPROG\t0x10\n#define NAND_CMD_READOOB\t0x50\n#define NAND_CMD_ERASE1\t\t0x60\n#define NAND_CMD_STATUS\t\t0x70\n#define NAND_CMD_SEQIN\t\t0x80\n#define NAND_CMD_RNDIN\t\t0x85\n#define NAND_CMD_READID\t\t0x90\n#define NAND_CMD_ERASE2\t\t0xd0\n#define NAND_CMD_PARAM\t\t0xec\n#define NAND_CMD_GET_FEATURES\t0xee\n#define NAND_CMD_SET_FEATURES\t0xef\n#define NAND_CMD_RESET\t\t0xff\n\n \n#define NAND_CMD_READSTART\t0x30\n#define NAND_CMD_READCACHESEQ\t0x31\n#define NAND_CMD_READCACHEEND\t0x3f\n#define NAND_CMD_RNDOUTSTART\t0xE0\n#define NAND_CMD_CACHEDPROG\t0x15\n\n#define NAND_CMD_NONE\t\t-1\n\n \n#define NAND_STATUS_FAIL\t0x01\n#define NAND_STATUS_FAIL_N1\t0x02\n#define NAND_STATUS_TRUE_READY\t0x20\n#define NAND_STATUS_READY\t0x40\n#define NAND_STATUS_WP\t\t0x80\n\n#define NAND_DATA_IFACE_CHECK_ONLY\t-1\n\n \n \n#define NAND_ECC_READ\t\t0\n \n#define NAND_ECC_WRITE\t\t1\n \n#define NAND_ECC_READSYN\t2\n\n \n#define NAND_ECC_GENERIC_ERASED_CHECK\tBIT(0)\n\n \n\n \n#define NAND_BUSWIDTH_16\tBIT(1)\n\n \n#define NAND_ECC_SOFT_HAMMING_SM_ORDER\tBIT(2)\n\n \n#define NAND_CACHEPRG\t\tBIT(3)\n \n#define NAND_SAMSUNG_LP_OPTIONS NAND_CACHEPRG\n\n \n#define NAND_NEED_READRDY\tBIT(8)\n\n \n#define NAND_NO_SUBPAGE_WRITE\tBIT(9)\n\n \n#define NAND_BROKEN_XD\t\tBIT(10)\n\n \n#define NAND_ROM\t\tBIT(11)\n\n \n#define NAND_SUBPAGE_READ\tBIT(12)\n \n#define NAND_HAS_SUBPAGE_READ(chip) ((chip->options & NAND_SUBPAGE_READ))\n\n \n#define NAND_NEED_SCRAMBLING\tBIT(13)\n\n \n#define NAND_ROW_ADDR_3\t\tBIT(14)\n\n \n \n#define NAND_SKIP_BBTSCAN\tBIT(16)\n \n#define NAND_SCAN_SILENT_NODEV\tBIT(18)\n\n \n#define NAND_BUSWIDTH_AUTO      BIT(19)\n\n \n#define NAND_USES_DMA\t\tBIT(20)\n\n \n#define NAND_WAIT_TCCS\t\tBIT(21)\n\n \n#define NAND_IS_BOOT_MEDIUM\tBIT(22)\n\n \n#define NAND_KEEP_TIMINGS\tBIT(23)\n\n \n#define NAND_BBM_FIRSTPAGE\tBIT(24)\n#define NAND_BBM_SECONDPAGE\tBIT(25)\n#define NAND_BBM_LASTPAGE\tBIT(26)\n\n \n#define NAND_NO_BBM_QUIRK\tBIT(27)\n\n \n#define NAND_CI_CHIPNR_MSK\t0x03\n#define NAND_CI_CELLTYPE_MSK\t0x0C\n#define NAND_CI_CELLTYPE_SHIFT\t2\n\n \n#define NAND_BBM_POS_SMALL\t\t5\n#define NAND_BBM_POS_LARGE\t\t0\n\n \nstruct nand_parameters {\n\t \n\tconst char *model;\n\tbool supports_set_get_features;\n\tbool supports_read_cache;\n\tDECLARE_BITMAP(set_feature_list, ONFI_FEATURE_NUMBER);\n\tDECLARE_BITMAP(get_feature_list, ONFI_FEATURE_NUMBER);\n\n\t \n\tstruct onfi_params *onfi;\n};\n\n \n#define NAND_MAX_ID_LEN 8\n\n \nstruct nand_id {\n\tu8 data[NAND_MAX_ID_LEN];\n\tint len;\n};\n\n \nstruct nand_ecc_step_info {\n\tint stepsize;\n\tconst int *strengths;\n\tint nstrengths;\n};\n\n \nstruct nand_ecc_caps {\n\tconst struct nand_ecc_step_info *stepinfos;\n\tint nstepinfos;\n\tint (*calc_ecc_bytes)(int step_size, int strength);\n};\n\n \n#define NAND_ECC_CAPS_SINGLE(__name, __calc, __step, ...)\t\\\nstatic const int __name##_strengths[] = { __VA_ARGS__ };\t\\\nstatic const struct nand_ecc_step_info __name##_stepinfo = {\t\\\n\t.stepsize = __step,\t\t\t\t\t\\\n\t.strengths = __name##_strengths,\t\t\t\\\n\t.nstrengths = ARRAY_SIZE(__name##_strengths),\t\t\\\n};\t\t\t\t\t\t\t\t\\\nstatic const struct nand_ecc_caps __name = {\t\t\t\\\n\t.stepinfos = &__name##_stepinfo,\t\t\t\\\n\t.nstepinfos = 1,\t\t\t\t\t\\\n\t.calc_ecc_bytes = __calc,\t\t\t\t\\\n}\n\n \nstruct nand_ecc_ctrl {\n\tenum nand_ecc_engine_type engine_type;\n\tenum nand_ecc_placement placement;\n\tenum nand_ecc_algo algo;\n\tint steps;\n\tint size;\n\tint bytes;\n\tint total;\n\tint strength;\n\tint prepad;\n\tint postpad;\n\tunsigned int options;\n\tu8 *calc_buf;\n\tu8 *code_buf;\n\tvoid (*hwctl)(struct nand_chip *chip, int mode);\n\tint (*calculate)(struct nand_chip *chip, const uint8_t *dat,\n\t\t\t uint8_t *ecc_code);\n\tint (*correct)(struct nand_chip *chip, uint8_t *dat, uint8_t *read_ecc,\n\t\t       uint8_t *calc_ecc);\n\tint (*read_page_raw)(struct nand_chip *chip, uint8_t *buf,\n\t\t\t     int oob_required, int page);\n\tint (*write_page_raw)(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t      int oob_required, int page);\n\tint (*read_page)(struct nand_chip *chip, uint8_t *buf,\n\t\t\t int oob_required, int page);\n\tint (*read_subpage)(struct nand_chip *chip, uint32_t offs,\n\t\t\t    uint32_t len, uint8_t *buf, int page);\n\tint (*write_subpage)(struct nand_chip *chip, uint32_t offset,\n\t\t\t     uint32_t data_len, const uint8_t *data_buf,\n\t\t\t     int oob_required, int page);\n\tint (*write_page)(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t  int oob_required, int page);\n\tint (*write_oob_raw)(struct nand_chip *chip, int page);\n\tint (*read_oob_raw)(struct nand_chip *chip, int page);\n\tint (*read_oob)(struct nand_chip *chip, int page);\n\tint (*write_oob)(struct nand_chip *chip, int page);\n};\n\n \nstruct nand_sdr_timings {\n\tu64 tBERS_max;\n\tu32 tCCS_min;\n\tu64 tPROG_max;\n\tu64 tR_max;\n\tu32 tALH_min;\n\tu32 tADL_min;\n\tu32 tALS_min;\n\tu32 tAR_min;\n\tu32 tCEA_max;\n\tu32 tCEH_min;\n\tu32 tCH_min;\n\tu32 tCHZ_max;\n\tu32 tCLH_min;\n\tu32 tCLR_min;\n\tu32 tCLS_min;\n\tu32 tCOH_min;\n\tu32 tCS_min;\n\tu32 tDH_min;\n\tu32 tDS_min;\n\tu32 tFEAT_max;\n\tu32 tIR_min;\n\tu32 tITC_max;\n\tu32 tRC_min;\n\tu32 tREA_max;\n\tu32 tREH_min;\n\tu32 tRHOH_min;\n\tu32 tRHW_min;\n\tu32 tRHZ_max;\n\tu32 tRLOH_min;\n\tu32 tRP_min;\n\tu32 tRR_min;\n\tu64 tRST_max;\n\tu32 tWB_max;\n\tu32 tWC_min;\n\tu32 tWH_min;\n\tu32 tWHR_min;\n\tu32 tWP_min;\n\tu32 tWW_min;\n};\n\n \nstruct nand_nvddr_timings {\n\tu64 tBERS_max;\n\tu32 tCCS_min;\n\tu64 tPROG_max;\n\tu64 tR_max;\n\tu32 tAC_min;\n\tu32 tAC_max;\n\tu32 tADL_min;\n\tu32 tCAD_min;\n\tu32 tCAH_min;\n\tu32 tCALH_min;\n\tu32 tCALS_min;\n\tu32 tCAS_min;\n\tu32 tCEH_min;\n\tu32 tCH_min;\n\tu32 tCK_min;\n\tu32 tCS_min;\n\tu32 tDH_min;\n\tu32 tDQSCK_min;\n\tu32 tDQSCK_max;\n\tu32 tDQSD_min;\n\tu32 tDQSD_max;\n\tu32 tDQSHZ_max;\n\tu32 tDQSQ_max;\n\tu32 tDS_min;\n\tu32 tDSC_min;\n\tu32 tFEAT_max;\n\tu32 tITC_max;\n\tu32 tQHS_max;\n\tu32 tRHW_min;\n\tu32 tRR_min;\n\tu32 tRST_max;\n\tu32 tWB_max;\n\tu32 tWHR_min;\n\tu32 tWRCK_min;\n\tu32 tWW_min;\n};\n\n \n#define NAND_COMMON_TIMING_PS(conf, timing_name)\t\t\\\n\tnand_interface_is_sdr(conf) ?\t\t\t\t\\\n\t\tnand_get_sdr_timings(conf)->timing_name :\t\\\n\t\tnand_get_nvddr_timings(conf)->timing_name\n\n#define NAND_COMMON_TIMING_MS(conf, timing_name) \\\n\tPSEC_TO_MSEC(NAND_COMMON_TIMING_PS((conf), timing_name))\n\n#define NAND_COMMON_TIMING_NS(conf, timing_name) \\\n\tPSEC_TO_NSEC(NAND_COMMON_TIMING_PS((conf), timing_name))\n\n \nenum nand_interface_type {\n\tNAND_SDR_IFACE,\n\tNAND_NVDDR_IFACE,\n};\n\n \nstruct nand_interface_config {\n\tenum nand_interface_type type;\n\tstruct nand_timings {\n\t\tunsigned int mode;\n\t\tunion {\n\t\t\tstruct nand_sdr_timings sdr;\n\t\t\tstruct nand_nvddr_timings nvddr;\n\t\t};\n\t} timings;\n};\n\n \nstatic bool nand_interface_is_sdr(const struct nand_interface_config *conf)\n{\n\treturn conf->type == NAND_SDR_IFACE;\n}\n\n \nstatic bool nand_interface_is_nvddr(const struct nand_interface_config *conf)\n{\n\treturn conf->type == NAND_NVDDR_IFACE;\n}\n\n \nstatic inline const struct nand_sdr_timings *\nnand_get_sdr_timings(const struct nand_interface_config *conf)\n{\n\tif (!nand_interface_is_sdr(conf))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn &conf->timings.sdr;\n}\n\n \nstatic inline const struct nand_nvddr_timings *\nnand_get_nvddr_timings(const struct nand_interface_config *conf)\n{\n\tif (!nand_interface_is_nvddr(conf))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn &conf->timings.nvddr;\n}\n\n \nstruct nand_op_cmd_instr {\n\tu8 opcode;\n};\n\n \nstruct nand_op_addr_instr {\n\tunsigned int naddrs;\n\tconst u8 *addrs;\n};\n\n \nstruct nand_op_data_instr {\n\tunsigned int len;\n\tunion {\n\t\tvoid *in;\n\t\tconst void *out;\n\t} buf;\n\tbool force_8bit;\n};\n\n \nstruct nand_op_waitrdy_instr {\n\tunsigned int timeout_ms;\n};\n\n \nenum nand_op_instr_type {\n\tNAND_OP_CMD_INSTR,\n\tNAND_OP_ADDR_INSTR,\n\tNAND_OP_DATA_IN_INSTR,\n\tNAND_OP_DATA_OUT_INSTR,\n\tNAND_OP_WAITRDY_INSTR,\n};\n\n \nstruct nand_op_instr {\n\tenum nand_op_instr_type type;\n\tunion {\n\t\tstruct nand_op_cmd_instr cmd;\n\t\tstruct nand_op_addr_instr addr;\n\t\tstruct nand_op_data_instr data;\n\t\tstruct nand_op_waitrdy_instr waitrdy;\n\t} ctx;\n\tunsigned int delay_ns;\n};\n\n \n#define __DIVIDE(dividend, divisor) ({\t\t\t\t\t\t\\\n\t(__typeof__(dividend))(sizeof(dividend) <= sizeof(unsigned long) ?\t\\\n\t\t\t       DIV_ROUND_UP(dividend, divisor) :\t\t\\\n\t\t\t       DIV_ROUND_UP_ULL(dividend, divisor)); \t\t\\\n\t})\n#define PSEC_TO_NSEC(x) __DIVIDE(x, 1000)\n#define PSEC_TO_MSEC(x) __DIVIDE(x, 1000000000)\n\n#define NAND_OP_CMD(id, ns)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_CMD_INSTR,\t\t\t\t\\\n\t\t.ctx.cmd.opcode = id,\t\t\t\t\t\\\n\t\t.delay_ns = ns,\t\t\t\t\t\t\\\n\t}\n\n#define NAND_OP_ADDR(ncycles, cycles, ns)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_ADDR_INSTR,\t\t\t\t\\\n\t\t.ctx.addr = {\t\t\t\t\t\t\\\n\t\t\t.naddrs = ncycles,\t\t\t\t\\\n\t\t\t.addrs = cycles,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.delay_ns = ns,\t\t\t\t\t\t\\\n\t}\n\n#define NAND_OP_DATA_IN(l, b, ns)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_DATA_IN_INSTR,\t\t\t\t\\\n\t\t.ctx.data = {\t\t\t\t\t\t\\\n\t\t\t.len = l,\t\t\t\t\t\\\n\t\t\t.buf.in = b,\t\t\t\t\t\\\n\t\t\t.force_8bit = false,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.delay_ns = ns,\t\t\t\t\t\t\\\n\t}\n\n#define NAND_OP_DATA_OUT(l, b, ns)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_DATA_OUT_INSTR,\t\t\t\t\\\n\t\t.ctx.data = {\t\t\t\t\t\t\\\n\t\t\t.len = l,\t\t\t\t\t\\\n\t\t\t.buf.out = b,\t\t\t\t\t\\\n\t\t\t.force_8bit = false,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.delay_ns = ns,\t\t\t\t\t\t\\\n\t}\n\n#define NAND_OP_8BIT_DATA_IN(l, b, ns)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_DATA_IN_INSTR,\t\t\t\t\\\n\t\t.ctx.data = {\t\t\t\t\t\t\\\n\t\t\t.len = l,\t\t\t\t\t\\\n\t\t\t.buf.in = b,\t\t\t\t\t\\\n\t\t\t.force_8bit = true,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.delay_ns = ns,\t\t\t\t\t\t\\\n\t}\n\n#define NAND_OP_8BIT_DATA_OUT(l, b, ns)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_DATA_OUT_INSTR,\t\t\t\t\\\n\t\t.ctx.data = {\t\t\t\t\t\t\\\n\t\t\t.len = l,\t\t\t\t\t\\\n\t\t\t.buf.out = b,\t\t\t\t\t\\\n\t\t\t.force_8bit = true,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.delay_ns = ns,\t\t\t\t\t\t\\\n\t}\n\n#define NAND_OP_WAIT_RDY(tout_ms, ns)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_WAITRDY_INSTR,\t\t\t\t\\\n\t\t.ctx.waitrdy.timeout_ms = tout_ms,\t\t\t\\\n\t\t.delay_ns = ns,\t\t\t\t\t\t\\\n\t}\n\n \nstruct nand_subop {\n\tunsigned int cs;\n\tconst struct nand_op_instr *instrs;\n\tunsigned int ninstrs;\n\tunsigned int first_instr_start_off;\n\tunsigned int last_instr_end_off;\n};\n\nunsigned int nand_subop_get_addr_start_off(const struct nand_subop *subop,\n\t\t\t\t\t   unsigned int op_id);\nunsigned int nand_subop_get_num_addr_cyc(const struct nand_subop *subop,\n\t\t\t\t\t unsigned int op_id);\nunsigned int nand_subop_get_data_start_off(const struct nand_subop *subop,\n\t\t\t\t\t   unsigned int op_id);\nunsigned int nand_subop_get_data_len(const struct nand_subop *subop,\n\t\t\t\t     unsigned int op_id);\n\n \nstruct nand_op_parser_addr_constraints {\n\tunsigned int maxcycles;\n};\n\n \nstruct nand_op_parser_data_constraints {\n\tunsigned int maxlen;\n};\n\n \nstruct nand_op_parser_pattern_elem {\n\tenum nand_op_instr_type type;\n\tbool optional;\n\tunion {\n\t\tstruct nand_op_parser_addr_constraints addr;\n\t\tstruct nand_op_parser_data_constraints data;\n\t} ctx;\n};\n\n#define NAND_OP_PARSER_PAT_CMD_ELEM(_opt)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_CMD_INSTR,\t\t\t\\\n\t\t.optional = _opt,\t\t\t\t\\\n\t}\n\n#define NAND_OP_PARSER_PAT_ADDR_ELEM(_opt, _maxcycles)\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_ADDR_INSTR,\t\t\t\\\n\t\t.optional = _opt,\t\t\t\t\\\n\t\t.ctx.addr.maxcycles = _maxcycles,\t\t\\\n\t}\n\n#define NAND_OP_PARSER_PAT_DATA_IN_ELEM(_opt, _maxlen)\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_DATA_IN_INSTR,\t\t\t\\\n\t\t.optional = _opt,\t\t\t\t\\\n\t\t.ctx.data.maxlen = _maxlen,\t\t\t\\\n\t}\n\n#define NAND_OP_PARSER_PAT_DATA_OUT_ELEM(_opt, _maxlen)\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_DATA_OUT_INSTR,\t\t\t\\\n\t\t.optional = _opt,\t\t\t\t\\\n\t\t.ctx.data.maxlen = _maxlen,\t\t\t\\\n\t}\n\n#define NAND_OP_PARSER_PAT_WAITRDY_ELEM(_opt)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = NAND_OP_WAITRDY_INSTR,\t\t\t\\\n\t\t.optional = _opt,\t\t\t\t\\\n\t}\n\n \nstruct nand_op_parser_pattern {\n\tconst struct nand_op_parser_pattern_elem *elems;\n\tunsigned int nelems;\n\tint (*exec)(struct nand_chip *chip, const struct nand_subop *subop);\n};\n\n#define NAND_OP_PARSER_PATTERN(_exec, ...)\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t.exec = _exec,\t\t\t\t\t\t\t\t\t\\\n\t\t.elems = (const struct nand_op_parser_pattern_elem[]) { __VA_ARGS__ },\t\t\\\n\t\t.nelems = sizeof((struct nand_op_parser_pattern_elem[]) { __VA_ARGS__ }) /\t\\\n\t\t\t  sizeof(struct nand_op_parser_pattern_elem),\t\t\t\t\\\n\t}\n\n \nstruct nand_op_parser {\n\tconst struct nand_op_parser_pattern *patterns;\n\tunsigned int npatterns;\n};\n\n#define NAND_OP_PARSER(...)\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t.patterns = (const struct nand_op_parser_pattern[]) { __VA_ARGS__ },\t\t\\\n\t\t.npatterns = sizeof((struct nand_op_parser_pattern[]) { __VA_ARGS__ }) /\t\\\n\t\t\t     sizeof(struct nand_op_parser_pattern),\t\t\t\t\\\n\t}\n\n \nstruct nand_operation {\n\tunsigned int cs;\n\tconst struct nand_op_instr *instrs;\n\tunsigned int ninstrs;\n};\n\n#define NAND_OPERATION(_cs, _instrs)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.cs = _cs,\t\t\t\t\t\\\n\t\t.instrs = _instrs,\t\t\t\t\\\n\t\t.ninstrs = ARRAY_SIZE(_instrs),\t\t\t\\\n\t}\n\nint nand_op_parser_exec_op(struct nand_chip *chip,\n\t\t\t   const struct nand_op_parser *parser,\n\t\t\t   const struct nand_operation *op, bool check_only);\n\nstatic inline void nand_op_trace(const char *prefix,\n\t\t\t\t const struct nand_op_instr *instr)\n{\n#if IS_ENABLED(CONFIG_DYNAMIC_DEBUG) || defined(DEBUG)\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\tpr_debug(\"%sCMD      [0x%02x]\\n\", prefix,\n\t\t\t instr->ctx.cmd.opcode);\n\t\tbreak;\n\tcase NAND_OP_ADDR_INSTR:\n\t\tpr_debug(\"%sADDR     [%d cyc: %*ph]\\n\", prefix,\n\t\t\t instr->ctx.addr.naddrs,\n\t\t\t instr->ctx.addr.naddrs < 64 ?\n\t\t\t instr->ctx.addr.naddrs : 64,\n\t\t\t instr->ctx.addr.addrs);\n\t\tbreak;\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tpr_debug(\"%sDATA_IN  [%d B%s]\\n\", prefix,\n\t\t\t instr->ctx.data.len,\n\t\t\t instr->ctx.data.force_8bit ?\n\t\t\t \", force 8-bit\" : \"\");\n\t\tbreak;\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tpr_debug(\"%sDATA_OUT [%d B%s]\\n\", prefix,\n\t\t\t instr->ctx.data.len,\n\t\t\t instr->ctx.data.force_8bit ?\n\t\t\t \", force 8-bit\" : \"\");\n\t\tbreak;\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\tpr_debug(\"%sWAITRDY  [max %d ms]\\n\", prefix,\n\t\t\t instr->ctx.waitrdy.timeout_ms);\n\t\tbreak;\n\t}\n#endif\n}\n\n \nstruct nand_controller_ops {\n\tint (*attach_chip)(struct nand_chip *chip);\n\tvoid (*detach_chip)(struct nand_chip *chip);\n\tint (*exec_op)(struct nand_chip *chip,\n\t\t       const struct nand_operation *op,\n\t\t       bool check_only);\n\tint (*setup_interface)(struct nand_chip *chip, int chipnr,\n\t\t\t       const struct nand_interface_config *conf);\n};\n\n \nstruct nand_controller {\n\tstruct mutex lock;\n\tconst struct nand_controller_ops *ops;\n\tstruct {\n\t\tunsigned int data_only_read: 1;\n\t\tunsigned int cont_read: 1;\n\t} supported_op;\n};\n\nstatic inline void nand_controller_init(struct nand_controller *nfc)\n{\n\tmutex_init(&nfc->lock);\n}\n\n \nstruct nand_legacy {\n\tvoid __iomem *IO_ADDR_R;\n\tvoid __iomem *IO_ADDR_W;\n\tvoid (*select_chip)(struct nand_chip *chip, int cs);\n\tu8 (*read_byte)(struct nand_chip *chip);\n\tvoid (*write_byte)(struct nand_chip *chip, u8 byte);\n\tvoid (*write_buf)(struct nand_chip *chip, const u8 *buf, int len);\n\tvoid (*read_buf)(struct nand_chip *chip, u8 *buf, int len);\n\tvoid (*cmd_ctrl)(struct nand_chip *chip, int dat, unsigned int ctrl);\n\tvoid (*cmdfunc)(struct nand_chip *chip, unsigned command, int column,\n\t\t\tint page_addr);\n\tint (*dev_ready)(struct nand_chip *chip);\n\tint (*waitfunc)(struct nand_chip *chip);\n\tint (*block_bad)(struct nand_chip *chip, loff_t ofs);\n\tint (*block_markbad)(struct nand_chip *chip, loff_t ofs);\n\tint (*set_features)(struct nand_chip *chip, int feature_addr,\n\t\t\t    u8 *subfeature_para);\n\tint (*get_features)(struct nand_chip *chip, int feature_addr,\n\t\t\t    u8 *subfeature_para);\n\tint chip_delay;\n\tstruct nand_controller dummy_controller;\n};\n\n \nstruct nand_chip_ops {\n\tint (*suspend)(struct nand_chip *chip);\n\tvoid (*resume)(struct nand_chip *chip);\n\tint (*lock_area)(struct nand_chip *chip, loff_t ofs, uint64_t len);\n\tint (*unlock_area)(struct nand_chip *chip, loff_t ofs, uint64_t len);\n\tint (*setup_read_retry)(struct nand_chip *chip, int retry_mode);\n\tint (*choose_interface_config)(struct nand_chip *chip,\n\t\t\t\t       struct nand_interface_config *iface);\n};\n\n \nstruct nand_manufacturer {\n\tconst struct nand_manufacturer_desc *desc;\n\tvoid *priv;\n};\n\n \nstruct nand_secure_region {\n\tu64 offset;\n\tu64 size;\n};\n\n \nstruct nand_chip {\n\tstruct nand_device base;\n\tstruct nand_id id;\n\tstruct nand_parameters parameters;\n\tstruct nand_manufacturer manufacturer;\n\tstruct nand_chip_ops ops;\n\tstruct nand_legacy legacy;\n\tunsigned int options;\n\n\t \n\tconst struct nand_interface_config *current_interface_config;\n\tstruct nand_interface_config *best_interface_config;\n\n\t \n\tunsigned int bbt_erase_shift;\n\tunsigned int bbt_options;\n\tunsigned int badblockpos;\n\tunsigned int badblockbits;\n\tstruct nand_bbt_descr *bbt_td;\n\tstruct nand_bbt_descr *bbt_md;\n\tstruct nand_bbt_descr *badblock_pattern;\n\tu8 *bbt;\n\n\t \n\tunsigned int page_shift;\n\tunsigned int phys_erase_shift;\n\tunsigned int chip_shift;\n\tunsigned int pagemask;\n\tunsigned int subpagesize;\n\n\t \n\tu8 *data_buf;\n\tu8 *oob_poi;\n\tstruct {\n\t\tunsigned int bitflips;\n\t\tint page;\n\t} pagecache;\n\tunsigned long buf_align;\n\n\t \n\tstruct mutex lock;\n\tunsigned int suspended : 1;\n\twait_queue_head_t resume_wq;\n\tint cur_cs;\n\tint read_retries;\n\tstruct nand_secure_region *secure_regions;\n\tu8 nr_secure_regions;\n\tstruct {\n\t\tbool ongoing;\n\t\tunsigned int first_page;\n\t\tunsigned int last_page;\n\t} cont_read;\n\n\t \n\tstruct nand_controller *controller;\n\tstruct nand_ecc_ctrl ecc;\n\tvoid *priv;\n};\n\nstatic inline struct nand_chip *mtd_to_nand(struct mtd_info *mtd)\n{\n\treturn container_of(mtd, struct nand_chip, base.mtd);\n}\n\nstatic inline struct mtd_info *nand_to_mtd(struct nand_chip *chip)\n{\n\treturn &chip->base.mtd;\n}\n\nstatic inline void *nand_get_controller_data(struct nand_chip *chip)\n{\n\treturn chip->priv;\n}\n\nstatic inline void nand_set_controller_data(struct nand_chip *chip, void *priv)\n{\n\tchip->priv = priv;\n}\n\nstatic inline void nand_set_manufacturer_data(struct nand_chip *chip,\n\t\t\t\t\t      void *priv)\n{\n\tchip->manufacturer.priv = priv;\n}\n\nstatic inline void *nand_get_manufacturer_data(struct nand_chip *chip)\n{\n\treturn chip->manufacturer.priv;\n}\n\nstatic inline void nand_set_flash_node(struct nand_chip *chip,\n\t\t\t\t       struct device_node *np)\n{\n\tmtd_set_of_node(nand_to_mtd(chip), np);\n}\n\nstatic inline struct device_node *nand_get_flash_node(struct nand_chip *chip)\n{\n\treturn mtd_get_of_node(nand_to_mtd(chip));\n}\n\n \nstatic inline const struct nand_interface_config *\nnand_get_interface_config(struct nand_chip *chip)\n{\n\treturn chip->current_interface_config;\n}\n\n \n#define LEGACY_ID_NAND(nm, devid, chipsz, erasesz, opts)          \\\n\t{ .name = (nm), {{ .dev_id = (devid) }}, .pagesize = 512, \\\n\t  .chipsize = (chipsz), .erasesize = (erasesz), .options = (opts) }\n\n \n#define EXTENDED_ID_NAND(nm, devid, chipsz, opts)                      \\\n\t{ .name = (nm), {{ .dev_id = (devid) }}, .chipsize = (chipsz), \\\n\t  .options = (opts) }\n\n#define NAND_ECC_INFO(_strength, _step)\t\\\n\t\t\t{ .strength_ds = (_strength), .step_ds = (_step) }\n#define NAND_ECC_STRENGTH(type)\t\t((type)->ecc.strength_ds)\n#define NAND_ECC_STEP(type)\t\t((type)->ecc.step_ds)\n\n \nstruct nand_flash_dev {\n\tchar *name;\n\tunion {\n\t\tstruct {\n\t\t\tuint8_t mfr_id;\n\t\t\tuint8_t dev_id;\n\t\t};\n\t\tuint8_t id[NAND_MAX_ID_LEN];\n\t};\n\tunsigned int pagesize;\n\tunsigned int chipsize;\n\tunsigned int erasesize;\n\tunsigned int options;\n\tuint16_t id_len;\n\tuint16_t oobsize;\n\tstruct {\n\t\tuint16_t strength_ds;\n\t\tuint16_t step_ds;\n\t} ecc;\n};\n\nint nand_create_bbt(struct nand_chip *chip);\n\n \nstatic inline bool nand_is_slc(struct nand_chip *chip)\n{\n\tWARN(nanddev_bits_per_cell(&chip->base) == 0,\n\t     \"chip->bits_per_cell is used uninitialized\\n\");\n\treturn nanddev_bits_per_cell(&chip->base) == 1;\n}\n\n \nstatic inline int nand_opcode_8bits(unsigned int command)\n{\n\tswitch (command) {\n\tcase NAND_CMD_READID:\n\tcase NAND_CMD_PARAM:\n\tcase NAND_CMD_GET_FEATURES:\n\tcase NAND_CMD_SET_FEATURES:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint rawnand_sw_hamming_init(struct nand_chip *chip);\nint rawnand_sw_hamming_calculate(struct nand_chip *chip,\n\t\t\t\t const unsigned char *buf,\n\t\t\t\t unsigned char *code);\nint rawnand_sw_hamming_correct(struct nand_chip *chip,\n\t\t\t       unsigned char *buf,\n\t\t\t       unsigned char *read_ecc,\n\t\t\t       unsigned char *calc_ecc);\nvoid rawnand_sw_hamming_cleanup(struct nand_chip *chip);\nint rawnand_sw_bch_init(struct nand_chip *chip);\nint rawnand_sw_bch_correct(struct nand_chip *chip, unsigned char *buf,\n\t\t\t   unsigned char *read_ecc, unsigned char *calc_ecc);\nvoid rawnand_sw_bch_cleanup(struct nand_chip *chip);\n\nint nand_check_erased_ecc_chunk(void *data, int datalen,\n\t\t\t\tvoid *ecc, int ecclen,\n\t\t\t\tvoid *extraoob, int extraooblen,\n\t\t\t\tint threshold);\n\nint nand_ecc_choose_conf(struct nand_chip *chip,\n\t\t\t const struct nand_ecc_caps *caps, int oobavail);\n\n \nint nand_write_oob_std(struct nand_chip *chip, int page);\n\n \nint nand_read_oob_std(struct nand_chip *chip, int page);\n\n \nint nand_get_set_features_notsupp(struct nand_chip *chip, int addr,\n\t\t\t\t  u8 *subfeature_param);\n\n \nint nand_read_page_raw(struct nand_chip *chip, uint8_t *buf, int oob_required,\n\t\t       int page);\nint nand_monolithic_read_page_raw(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t  int oob_required, int page);\n\n \nint nand_write_page_raw(struct nand_chip *chip, const uint8_t *buf,\n\t\t\tint oob_required, int page);\nint nand_monolithic_write_page_raw(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t   int oob_required, int page);\n\n \nint nand_reset(struct nand_chip *chip, int chipnr);\n\n \nint nand_reset_op(struct nand_chip *chip);\nint nand_readid_op(struct nand_chip *chip, u8 addr, void *buf,\n\t\t   unsigned int len);\nint nand_status_op(struct nand_chip *chip, u8 *status);\nint nand_exit_status_op(struct nand_chip *chip);\nint nand_erase_op(struct nand_chip *chip, unsigned int eraseblock);\nint nand_read_page_op(struct nand_chip *chip, unsigned int page,\n\t\t      unsigned int offset_in_page, void *buf, unsigned int len);\nint nand_change_read_column_op(struct nand_chip *chip,\n\t\t\t       unsigned int offset_in_page, void *buf,\n\t\t\t       unsigned int len, bool force_8bit);\nint nand_read_oob_op(struct nand_chip *chip, unsigned int page,\n\t\t     unsigned int offset_in_page, void *buf, unsigned int len);\nint nand_prog_page_begin_op(struct nand_chip *chip, unsigned int page,\n\t\t\t    unsigned int offset_in_page, const void *buf,\n\t\t\t    unsigned int len);\nint nand_prog_page_end_op(struct nand_chip *chip);\nint nand_prog_page_op(struct nand_chip *chip, unsigned int page,\n\t\t      unsigned int offset_in_page, const void *buf,\n\t\t      unsigned int len);\nint nand_change_write_column_op(struct nand_chip *chip,\n\t\t\t\tunsigned int offset_in_page, const void *buf,\n\t\t\t\tunsigned int len, bool force_8bit);\nint nand_read_data_op(struct nand_chip *chip, void *buf, unsigned int len,\n\t\t      bool force_8bit, bool check_only);\nint nand_write_data_op(struct nand_chip *chip, const void *buf,\n\t\t       unsigned int len, bool force_8bit);\nint nand_read_page_hwecc_oob_first(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t   int oob_required, int page);\n\n \nint nand_scan_with_ids(struct nand_chip *chip, unsigned int max_chips,\n\t\t       struct nand_flash_dev *ids);\n\nstatic inline int nand_scan(struct nand_chip *chip, unsigned int max_chips)\n{\n\treturn nand_scan_with_ids(chip, max_chips, NULL);\n}\n\n \nvoid nand_wait_ready(struct nand_chip *chip);\n\n \nvoid nand_cleanup(struct nand_chip *chip);\n\n \nint nand_soft_waitrdy(struct nand_chip *chip, unsigned long timeout_ms);\nint nand_gpio_waitrdy(struct nand_chip *chip, struct gpio_desc *gpiod,\n\t\t      unsigned long timeout_ms);\n\n \nvoid nand_select_target(struct nand_chip *chip, unsigned int cs);\nvoid nand_deselect_target(struct nand_chip *chip);\n\n \nvoid nand_extract_bits(u8 *dst, unsigned int dst_off, const u8 *src,\n\t\t       unsigned int src_off, unsigned int nbits);\n\n \nstatic inline void *nand_get_data_buf(struct nand_chip *chip)\n{\n\tchip->pagecache.page = -1;\n\n\treturn chip->data_buf;\n}\n\n \nint rawnand_dt_parse_gpio_cs(struct device *dev, struct gpio_desc ***cs_array,\n\t\t\t     unsigned int *ncs_array);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}