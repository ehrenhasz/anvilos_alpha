{
  "module_name": "sh_flctl.h",
  "hash_id": "32e905469366d476aabbd90ad56128c9f94e74dbd8a1658c41a2e51acd8eca87",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mtd/sh_flctl.h",
  "human_readable_source": " \n\n#ifndef __SH_FLCTL_H__\n#define __SH_FLCTL_H__\n\n#include <linux/completion.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/pm_qos.h>\n\n \n#define FLCMNCR(f)\t\t(f->reg + 0x0)\n#define FLCMDCR(f)\t\t(f->reg + 0x4)\n#define FLCMCDR(f)\t\t(f->reg + 0x8)\n#define FLADR(f)\t\t(f->reg + 0xC)\n#define FLADR2(f)\t\t(f->reg + 0x3C)\n#define FLDATAR(f)\t\t(f->reg + 0x10)\n#define FLDTCNTR(f)\t\t(f->reg + 0x14)\n#define FLINTDMACR(f)\t\t(f->reg + 0x18)\n#define FLBSYTMR(f)\t\t(f->reg + 0x1C)\n#define FLBSYCNT(f)\t\t(f->reg + 0x20)\n#define FLDTFIFO(f)\t\t(f->reg + 0x24)\n#define FLECFIFO(f)\t\t(f->reg + 0x28)\n#define FLTRCR(f)\t\t(f->reg + 0x2C)\n#define FLHOLDCR(f)\t\t(f->reg + 0x38)\n#define\tFL4ECCRESULT0(f)\t(f->reg + 0x80)\n#define\tFL4ECCRESULT1(f)\t(f->reg + 0x84)\n#define\tFL4ECCRESULT2(f)\t(f->reg + 0x88)\n#define\tFL4ECCRESULT3(f)\t(f->reg + 0x8C)\n#define\tFL4ECCCR(f)\t\t(f->reg + 0x90)\n#define\tFL4ECCCNT(f)\t\t(f->reg + 0x94)\n#define\tFLERRADR(f)\t\t(f->reg + 0x98)\n\n \n#define _4ECCCNTEN\t(0x1 << 24)\n#define _4ECCEN\t\t(0x1 << 23)\n#define _4ECCCORRECT\t(0x1 << 22)\n#define SHBUSSEL\t(0x1 << 20)\n#define SEL_16BIT\t(0x1 << 19)\n#define SNAND_E\t\t(0x1 << 18)\t \n#define QTSEL_E\t\t(0x1 << 17)\n#define ENDIAN\t\t(0x1 << 16)\t \n#define FCKSEL_E\t(0x1 << 15)\n#define ACM_SACCES_MODE\t(0x01 << 10)\n#define NANWF_E\t\t(0x1 << 9)\n#define SE_D\t\t(0x1 << 8)\t \n#define\tCE1_ENABLE\t(0x1 << 4)\t \n#define\tCE0_ENABLE\t(0x1 << 3)\t \n#define\tTYPESEL_SET\t(0x1 << 0)\n\n \n#define PULSE3\t(0x1 << 27)\n#define PULSE2\t(0x1 << 17)\n#define PULSE1\t(0x1 << 15)\n#define PULSE0\t(0x1 << 9)\n#define CLK_8B_0_5\t\t\tPULSE1\n#define CLK_8B_1\t\t\t0x0\n#define CLK_8B_1_5\t\t\t(PULSE1 | PULSE2)\n#define CLK_8B_2\t\t\tPULSE0\n#define CLK_8B_3\t\t\t(PULSE0 | PULSE1 | PULSE2)\n#define CLK_8B_4\t\t\t(PULSE0 | PULSE2)\n#define CLK_16B_6L_2H\t\t\tPULSE0\n#define CLK_16B_9L_3H\t\t\t(PULSE0 | PULSE1 | PULSE2)\n#define CLK_16B_12L_4H\t\t\t(PULSE0 | PULSE2)\n\n \n#define ADRCNT2_E\t(0x1 << 31)\t \n#define ADRMD_E\t\t(0x1 << 26)\t \n#define CDSRC_E\t\t(0x1 << 25)\t \n#define DOSR_E\t\t(0x1 << 24)\t \n#define SELRW\t\t(0x1 << 21)\t \n#define DOADR_E\t\t(0x1 << 20)\t \n#define ADRCNT_1\t(0x00 << 18)\t \n#define ADRCNT_2\t(0x01 << 18)\t \n#define ADRCNT_3\t(0x02 << 18)\t \n#define ADRCNT_4\t(0x03 << 18)\t \n#define DOCMD2_E\t(0x1 << 17)\t \n#define DOCMD1_E\t(0x1 << 16)\t \n\n \n#define ESTERINTE\t(0x1 << 24)\t \n#define AC1CLR\t\t(0x1 << 19)\t \n#define AC0CLR\t\t(0x1 << 18)\t \n#define DREQ0EN\t\t(0x1 << 16)\t \n#define ECERB\t\t(0x1 << 9)\t \n#define STERB\t\t(0x1 << 8)\t \n#define STERINTE\t(0x1 << 4)\t \n\n \n#define TRSTRT\t\t(0x1 << 0)\t \n#define TREND\t\t(0x1 << 1)\t \n\n \n#define HOLDEN\t\t(0x1 << 0)\n\n \n#define\t_4ECCFA\t\t(0x1 << 2)\t \n#define\t_4ECCEND\t(0x1 << 1)\t \n#define\t_4ECCEXST\t(0x1 << 0)\t \n\n#define LOOP_TIMEOUT_MAX\t0x00010000\n\nenum flctl_ecc_res_t {\n\tFL_SUCCESS,\n\tFL_REPAIRABLE,\n\tFL_ERROR,\n\tFL_TIMEOUT\n};\n\nstruct dma_chan;\n\nstruct sh_flctl {\n\tstruct nand_chip\tchip;\n\tstruct platform_device\t*pdev;\n\tstruct dev_pm_qos_request pm_qos;\n\tvoid __iomem\t\t*reg;\n\tresource_size_t\t\tfifo;\n\n\tuint8_t\tdone_buff[2048 + 64];\t \n\tint\tread_bytes;\n\tunsigned int index;\n\tint\tseqin_column;\t\t \n\tint\tseqin_page_addr;\t \n\tuint32_t seqin_read_cmd;\t\t \n\tint\terase1_page_addr;\t \n\tuint32_t erase_ADRCNT;\t\t \n\tuint32_t rw_ADRCNT;\t \n\tuint32_t flcmncr_base;\t \n\tuint32_t flintdmacr_base;\t \n\n\tunsigned page_size:1;\t \n\tunsigned hwecc:1;\t \n\tunsigned holden:1;\t \n\tunsigned qos_request:1;\t \n\n\t \n\tstruct dma_chan\t\t*chan_fifo0_rx;\n\tstruct dma_chan\t\t*chan_fifo0_tx;\n\tstruct completion\tdma_complete;\n};\n\nstruct sh_flctl_platform_data {\n\tstruct mtd_partition\t*parts;\n\tint\t\t\tnr_parts;\n\tunsigned long\t\tflcmncr_val;\n\n\tunsigned has_hwecc:1;\n\tunsigned use_holden:1;\n\n\tunsigned int            slave_id_fifo0_tx;\n\tunsigned int            slave_id_fifo0_rx;\n};\n\nstatic inline struct sh_flctl *mtd_to_flctl(struct mtd_info *mtdinfo)\n{\n\treturn container_of(mtd_to_nand(mtdinfo), struct sh_flctl, chip);\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}