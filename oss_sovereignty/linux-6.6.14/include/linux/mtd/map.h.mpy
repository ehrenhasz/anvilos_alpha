{
  "module_name": "map.h",
  "hash_id": "253567306f65b9a5d2131b21d4e6386952a780ae1c424c38ba91144401c06617",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mtd/map.h",
  "human_readable_source": " \n \n\n \n\n#ifndef __LINUX_MTD_MAP_H__\n#define __LINUX_MTD_MAP_H__\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_1\n#define map_bankwidth(map) 1\n#define map_bankwidth_is_1(map) (map_bankwidth(map) == 1)\n#define map_bankwidth_is_large(map) (0)\n#define map_words(map) (1)\n#define MAX_MAP_BANKWIDTH 1\n#else\n#define map_bankwidth_is_1(map) (0)\n#endif\n\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_2\n# ifdef map_bankwidth\n#  undef map_bankwidth\n#  define map_bankwidth(map) ((map)->bankwidth)\n# else\n#  define map_bankwidth(map) 2\n#  define map_bankwidth_is_large(map) (0)\n#  define map_words(map) (1)\n# endif\n#define map_bankwidth_is_2(map) (map_bankwidth(map) == 2)\n#undef MAX_MAP_BANKWIDTH\n#define MAX_MAP_BANKWIDTH 2\n#else\n#define map_bankwidth_is_2(map) (0)\n#endif\n\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_4\n# ifdef map_bankwidth\n#  undef map_bankwidth\n#  define map_bankwidth(map) ((map)->bankwidth)\n# else\n#  define map_bankwidth(map) 4\n#  define map_bankwidth_is_large(map) (0)\n#  define map_words(map) (1)\n# endif\n#define map_bankwidth_is_4(map) (map_bankwidth(map) == 4)\n#undef MAX_MAP_BANKWIDTH\n#define MAX_MAP_BANKWIDTH 4\n#else\n#define map_bankwidth_is_4(map) (0)\n#endif\n\n \n\n#define map_calc_words(map) ((map_bankwidth(map) + (sizeof(unsigned long)-1)) / sizeof(unsigned long))\n\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_8\n# ifdef map_bankwidth\n#  undef map_bankwidth\n#  define map_bankwidth(map) ((map)->bankwidth)\n#  if BITS_PER_LONG < 64\n#   undef map_bankwidth_is_large\n#   define map_bankwidth_is_large(map) (map_bankwidth(map) > BITS_PER_LONG/8)\n#   undef map_words\n#   define map_words(map) map_calc_words(map)\n#  endif\n# else\n#  define map_bankwidth(map) 8\n#  define map_bankwidth_is_large(map) (BITS_PER_LONG < 64)\n#  define map_words(map) map_calc_words(map)\n# endif\n#define map_bankwidth_is_8(map) (map_bankwidth(map) == 8)\n#undef MAX_MAP_BANKWIDTH\n#define MAX_MAP_BANKWIDTH 8\n#else\n#define map_bankwidth_is_8(map) (0)\n#endif\n\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_16\n# ifdef map_bankwidth\n#  undef map_bankwidth\n#  define map_bankwidth(map) ((map)->bankwidth)\n#  undef map_bankwidth_is_large\n#  define map_bankwidth_is_large(map) (map_bankwidth(map) > BITS_PER_LONG/8)\n#  undef map_words\n#  define map_words(map) map_calc_words(map)\n# else\n#  define map_bankwidth(map) 16\n#  define map_bankwidth_is_large(map) (1)\n#  define map_words(map) map_calc_words(map)\n# endif\n#define map_bankwidth_is_16(map) (map_bankwidth(map) == 16)\n#undef MAX_MAP_BANKWIDTH\n#define MAX_MAP_BANKWIDTH 16\n#else\n#define map_bankwidth_is_16(map) (0)\n#endif\n\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_32\n \n# undef map_bankwidth\n# define map_bankwidth(map) ((map)->bankwidth)\n# undef map_bankwidth_is_large\n# define map_bankwidth_is_large(map) (map_bankwidth(map) > BITS_PER_LONG/8)\n# undef map_words\n# define map_words(map) map_calc_words(map)\n#define map_bankwidth_is_32(map) (map_bankwidth(map) == 32)\n#undef MAX_MAP_BANKWIDTH\n#define MAX_MAP_BANKWIDTH 32\n#else\n#define map_bankwidth_is_32(map) (0)\n#endif\n\n#ifndef map_bankwidth\n#ifdef CONFIG_MTD\n#warning \"No CONFIG_MTD_MAP_BANK_WIDTH_xx selected. No NOR chip support can work\"\n#endif\nstatic inline int map_bankwidth(void *map)\n{\n\tBUG();\n\treturn 0;\n}\n#define map_bankwidth_is_large(map) (0)\n#define map_words(map) (0)\n#define MAX_MAP_BANKWIDTH 1\n#endif\n\nstatic inline int map_bankwidth_supported(int w)\n{\n\tswitch (w) {\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_1\n\tcase 1:\n#endif\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_2\n\tcase 2:\n#endif\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_4\n\tcase 4:\n#endif\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_8\n\tcase 8:\n#endif\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_16\n\tcase 16:\n#endif\n#ifdef CONFIG_MTD_MAP_BANK_WIDTH_32\n\tcase 32:\n#endif\n\t\treturn 1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n#define MAX_MAP_LONGS (((MAX_MAP_BANKWIDTH * 8) + BITS_PER_LONG - 1) / BITS_PER_LONG)\n\ntypedef union {\n\tunsigned long x[MAX_MAP_LONGS];\n} map_word;\n\n \n\nstruct map_info {\n\tconst char *name;\n\tunsigned long size;\n\tresource_size_t phys;\n#define NO_XIP (-1UL)\n\n\tvoid __iomem *virt;\n\tvoid *cached;\n\n\tint swap;  \n\tint bankwidth;  \n\n#ifdef CONFIG_MTD_COMPLEX_MAPPINGS\n\tmap_word (*read)(struct map_info *, unsigned long);\n\tvoid (*copy_from)(struct map_info *, void *, unsigned long, ssize_t);\n\n\tvoid (*write)(struct map_info *, const map_word, unsigned long);\n\tvoid (*copy_to)(struct map_info *, unsigned long, const void *, ssize_t);\n\n\t \n#endif\n\t \n\tvoid (*inval_cache)(struct map_info *, unsigned long, ssize_t);\n\n\t \n\tvoid (*set_vpp)(struct map_info *, int);\n\n\tunsigned long pfow_base;\n\tunsigned long map_priv_1;\n\tunsigned long map_priv_2;\n\tstruct device_node *device_node;\n\tvoid *fldrv_priv;\n\tstruct mtd_chip_driver *fldrv;\n};\n\nstruct mtd_chip_driver {\n\tstruct mtd_info *(*probe)(struct map_info *map);\n\tvoid (*destroy)(struct mtd_info *);\n\tstruct module *module;\n\tchar *name;\n\tstruct list_head list;\n};\n\nvoid register_mtd_chip_driver(struct mtd_chip_driver *);\nvoid unregister_mtd_chip_driver(struct mtd_chip_driver *);\n\nstruct mtd_info *do_map_probe(const char *name, struct map_info *map);\nvoid map_destroy(struct mtd_info *mtd);\n\n#define ENABLE_VPP(map) do { if (map->set_vpp) map->set_vpp(map, 1); } while (0)\n#define DISABLE_VPP(map) do { if (map->set_vpp) map->set_vpp(map, 0); } while (0)\n\n#define INVALIDATE_CACHED_RANGE(map, from, size) \\\n\tdo { if (map->inval_cache) map->inval_cache(map, from, size); } while (0)\n\n#define map_word_equal(map, val1, val2)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint i, ret = 1;\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < map_words(map); i++)\t\t\t\t\\\n\t\tif ((val1).x[i] != (val2).x[i]) {\t\t\t\\\n\t\t\tret = 0;\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\t\\\n})\n\n#define map_word_and(map, val1, val2)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tmap_word r;\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < map_words(map); i++)\t\t\t\t\\\n\t\tr.x[i] = (val1).x[i] & (val2).x[i];\t\t\t\\\n\tr;\t\t\t\t\t\t\t\t\\\n})\n\n#define map_word_clr(map, val1, val2)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tmap_word r;\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < map_words(map); i++)\t\t\t\t\\\n\t\tr.x[i] = (val1).x[i] & ~(val2).x[i];\t\t\t\\\n\tr;\t\t\t\t\t\t\t\t\\\n})\n\n#define map_word_or(map, val1, val2)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tmap_word r;\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < map_words(map); i++)\t\t\t\t\\\n\t\tr.x[i] = (val1).x[i] | (val2).x[i];\t\t\t\\\n\tr;\t\t\t\t\t\t\t\t\\\n})\n\n#define map_word_andequal(map, val1, val2, val3)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint i, ret = 1;\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < map_words(map); i++) {\t\t\t\t\\\n\t\tif (((val1).x[i] & (val2).x[i]) != (val3).x[i]) {\t\\\n\t\t\tret = 0;\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\t\\\n})\n\n#define map_word_bitsset(map, val1, val2)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint i, ret = 0;\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < map_words(map); i++) {\t\t\t\t\\\n\t\tif ((val1).x[i] & (val2).x[i]) {\t\t\t\\\n\t\t\tret = 1;\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\t\\\n})\n\nstatic inline map_word map_word_load(struct map_info *map, const void *ptr)\n{\n\tmap_word r;\n\n\tif (map_bankwidth_is_1(map))\n\t\tr.x[0] = *(unsigned char *)ptr;\n\telse if (map_bankwidth_is_2(map))\n\t\tr.x[0] = get_unaligned((uint16_t *)ptr);\n\telse if (map_bankwidth_is_4(map))\n\t\tr.x[0] = get_unaligned((uint32_t *)ptr);\n#if BITS_PER_LONG >= 64\n\telse if (map_bankwidth_is_8(map))\n\t\tr.x[0] = get_unaligned((uint64_t *)ptr);\n#endif\n\telse if (map_bankwidth_is_large(map))\n\t\tmemcpy(r.x, ptr, map->bankwidth);\n\telse\n\t\tBUG();\n\n\treturn r;\n}\n\nstatic inline map_word map_word_load_partial(struct map_info *map, map_word orig, const unsigned char *buf, int start, int len)\n{\n\tint i;\n\n\tif (map_bankwidth_is_large(map)) {\n\t\tchar *dest = (char *)&orig;\n\n\t\tmemcpy(dest+start, buf, len);\n\t} else {\n\t\tfor (i = start; i < start+len; i++) {\n\t\t\tint bitpos;\n\n#ifdef __LITTLE_ENDIAN\n\t\t\tbitpos = i * 8;\n#else  \n\t\t\tbitpos = (map_bankwidth(map) - 1 - i) * 8;\n#endif\n\t\t\torig.x[0] &= ~(0xff << bitpos);\n\t\t\torig.x[0] |= (unsigned long)buf[i-start] << bitpos;\n\t\t}\n\t}\n\treturn orig;\n}\n\n#if BITS_PER_LONG < 64\n#define MAP_FF_LIMIT 4\n#else\n#define MAP_FF_LIMIT 8\n#endif\n\nstatic inline map_word map_word_ff(struct map_info *map)\n{\n\tmap_word r;\n\tint i;\n\n\tif (map_bankwidth(map) < MAP_FF_LIMIT) {\n\t\tint bw = 8 * map_bankwidth(map);\n\n\t\tr.x[0] = (1UL << bw) - 1;\n\t} else {\n\t\tfor (i = 0; i < map_words(map); i++)\n\t\t\tr.x[i] = ~0UL;\n\t}\n\treturn r;\n}\n\nstatic inline map_word inline_map_read(struct map_info *map, unsigned long ofs)\n{\n\tmap_word r;\n\n\tif (map_bankwidth_is_1(map))\n\t\tr.x[0] = __raw_readb(map->virt + ofs);\n\telse if (map_bankwidth_is_2(map))\n\t\tr.x[0] = __raw_readw(map->virt + ofs);\n\telse if (map_bankwidth_is_4(map))\n\t\tr.x[0] = __raw_readl(map->virt + ofs);\n#if BITS_PER_LONG >= 64\n\telse if (map_bankwidth_is_8(map))\n\t\tr.x[0] = __raw_readq(map->virt + ofs);\n#endif\n\telse if (map_bankwidth_is_large(map))\n\t\tmemcpy_fromio(r.x, map->virt + ofs, map->bankwidth);\n\telse\n\t\tBUG();\n\n\treturn r;\n}\n\nstatic inline void inline_map_write(struct map_info *map, const map_word datum, unsigned long ofs)\n{\n\tif (map_bankwidth_is_1(map))\n\t\t__raw_writeb(datum.x[0], map->virt + ofs);\n\telse if (map_bankwidth_is_2(map))\n\t\t__raw_writew(datum.x[0], map->virt + ofs);\n\telse if (map_bankwidth_is_4(map))\n\t\t__raw_writel(datum.x[0], map->virt + ofs);\n#if BITS_PER_LONG >= 64\n\telse if (map_bankwidth_is_8(map))\n\t\t__raw_writeq(datum.x[0], map->virt + ofs);\n#endif\n\telse if (map_bankwidth_is_large(map))\n\t\tmemcpy_toio(map->virt+ofs, datum.x, map->bankwidth);\n\telse\n\t\tBUG();\n\tmb();\n}\n\nstatic inline void inline_map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)\n{\n\tif (map->cached)\n\t\tmemcpy(to, (char *)map->cached + from, len);\n\telse\n\t\tmemcpy_fromio(to, map->virt + from, len);\n}\n\nstatic inline void inline_map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)\n{\n\tmemcpy_toio(map->virt + to, from, len);\n}\n\n#ifdef CONFIG_MTD_COMPLEX_MAPPINGS\n#define map_read(map, ofs) (map)->read(map, ofs)\n#define map_copy_from(map, to, from, len) (map)->copy_from(map, to, from, len)\n#define map_write(map, datum, ofs) (map)->write(map, datum, ofs)\n#define map_copy_to(map, to, from, len) (map)->copy_to(map, to, from, len)\n\nextern void simple_map_init(struct map_info *);\n#define map_is_linear(map) (map->phys != NO_XIP)\n\n#else\n#define map_read(map, ofs) inline_map_read(map, ofs)\n#define map_copy_from(map, to, from, len) inline_map_copy_from(map, to, from, len)\n#define map_write(map, datum, ofs) inline_map_write(map, datum, ofs)\n#define map_copy_to(map, to, from, len) inline_map_copy_to(map, to, from, len)\n\n\n#define simple_map_init(map) BUG_ON(!map_bankwidth_supported((map)->bankwidth))\n#define map_is_linear(map) ({ (void)(map); 1; })\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}