{
  "module_name": "fsnotify.h",
  "hash_id": "939b7ee84e26622d18370abd582cb0120fca7c64bdfab43d1b8935edab1f9db1",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fsnotify.h",
  "human_readable_source": " \n#ifndef _LINUX_FS_NOTIFY_H\n#define _LINUX_FS_NOTIFY_H\n\n \n\n#include <linux/fsnotify_backend.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/bug.h>\n\n \nstatic inline int fsnotify_name(__u32 mask, const void *data, int data_type,\n\t\t\t\tstruct inode *dir, const struct qstr *name,\n\t\t\t\tu32 cookie)\n{\n\tif (atomic_long_read(&dir->i_sb->s_fsnotify_connectors) == 0)\n\t\treturn 0;\n\n\treturn fsnotify(mask, data, data_type, dir, name, NULL, cookie);\n}\n\nstatic inline void fsnotify_dirent(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   __u32 mask)\n{\n\tfsnotify_name(mask, dentry, FSNOTIFY_EVENT_DENTRY, dir, &dentry->d_name, 0);\n}\n\nstatic inline void fsnotify_inode(struct inode *inode, __u32 mask)\n{\n\tif (atomic_long_read(&inode->i_sb->s_fsnotify_connectors) == 0)\n\t\treturn;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tmask |= FS_ISDIR;\n\n\tfsnotify(mask, inode, FSNOTIFY_EVENT_INODE, NULL, NULL, inode, 0);\n}\n\n \nstatic inline int fsnotify_parent(struct dentry *dentry, __u32 mask,\n\t\t\t\t  const void *data, int data_type)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (atomic_long_read(&inode->i_sb->s_fsnotify_connectors) == 0)\n\t\treturn 0;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tmask |= FS_ISDIR;\n\n\t\t \n\t\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\t\tgoto notify_child;\n\t}\n\n\t \n\tif (IS_ROOT(dentry))\n\t\tgoto notify_child;\n\n\treturn __fsnotify_parent(dentry, mask, data, data_type);\n\nnotify_child:\n\treturn fsnotify(mask, data, data_type, NULL, NULL, inode, 0);\n}\n\n \nstatic inline void fsnotify_dentry(struct dentry *dentry, __u32 mask)\n{\n\tfsnotify_parent(dentry, mask, dentry, FSNOTIFY_EVENT_DENTRY);\n}\n\nstatic inline int fsnotify_file(struct file *file, __u32 mask)\n{\n\tconst struct path *path;\n\n\tif (file->f_mode & FMODE_NONOTIFY)\n\t\treturn 0;\n\n\t \n\tpath = file_real_path(file);\n\treturn fsnotify_parent(path->dentry, mask, path, FSNOTIFY_EVENT_PATH);\n}\n\n \nstatic inline int fsnotify_perm(struct file *file, int mask)\n{\n\tint ret;\n\t__u32 fsnotify_mask = 0;\n\n\tif (!(mask & (MAY_READ | MAY_OPEN)))\n\t\treturn 0;\n\n\tif (mask & MAY_OPEN) {\n\t\tfsnotify_mask = FS_OPEN_PERM;\n\n\t\tif (file->f_flags & __FMODE_EXEC) {\n\t\t\tret = fsnotify_file(file, FS_OPEN_EXEC_PERM);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (mask & MAY_READ) {\n\t\tfsnotify_mask = FS_ACCESS_PERM;\n\t}\n\n\treturn fsnotify_file(file, fsnotify_mask);\n}\n\n \nstatic inline void fsnotify_link_count(struct inode *inode)\n{\n\tfsnotify_inode(inode, FS_ATTRIB);\n}\n\n \nstatic inline void fsnotify_move(struct inode *old_dir, struct inode *new_dir,\n\t\t\t\t const struct qstr *old_name,\n\t\t\t\t int isdir, struct inode *target,\n\t\t\t\t struct dentry *moved)\n{\n\tstruct inode *source = moved->d_inode;\n\tu32 fs_cookie = fsnotify_get_cookie();\n\t__u32 old_dir_mask = FS_MOVED_FROM;\n\t__u32 new_dir_mask = FS_MOVED_TO;\n\t__u32 rename_mask = FS_RENAME;\n\tconst struct qstr *new_name = &moved->d_name;\n\n\tif (isdir) {\n\t\told_dir_mask |= FS_ISDIR;\n\t\tnew_dir_mask |= FS_ISDIR;\n\t\trename_mask |= FS_ISDIR;\n\t}\n\n\t \n\tfsnotify_name(rename_mask, moved, FSNOTIFY_EVENT_DENTRY,\n\t\t      old_dir, old_name, 0);\n\n\tfsnotify_name(old_dir_mask, source, FSNOTIFY_EVENT_INODE,\n\t\t      old_dir, old_name, fs_cookie);\n\tfsnotify_name(new_dir_mask, source, FSNOTIFY_EVENT_INODE,\n\t\t      new_dir, new_name, fs_cookie);\n\n\tif (target)\n\t\tfsnotify_link_count(target);\n\tfsnotify_inode(source, FS_MOVE_SELF);\n\taudit_inode_child(new_dir, moved, AUDIT_TYPE_CHILD_CREATE);\n}\n\n \nstatic inline void fsnotify_inode_delete(struct inode *inode)\n{\n\t__fsnotify_inode_delete(inode);\n}\n\n \nstatic inline void fsnotify_vfsmount_delete(struct vfsmount *mnt)\n{\n\t__fsnotify_vfsmount_delete(mnt);\n}\n\n \nstatic inline void fsnotify_inoderemove(struct inode *inode)\n{\n\tfsnotify_inode(inode, FS_DELETE_SELF);\n\t__fsnotify_inode_delete(inode);\n}\n\n \nstatic inline void fsnotify_create(struct inode *dir, struct dentry *dentry)\n{\n\taudit_inode_child(dir, dentry, AUDIT_TYPE_CHILD_CREATE);\n\n\tfsnotify_dirent(dir, dentry, FS_CREATE);\n}\n\n \nstatic inline void fsnotify_link(struct inode *dir, struct inode *inode,\n\t\t\t\t struct dentry *new_dentry)\n{\n\tfsnotify_link_count(inode);\n\taudit_inode_child(dir, new_dentry, AUDIT_TYPE_CHILD_CREATE);\n\n\tfsnotify_name(FS_CREATE, inode, FSNOTIFY_EVENT_INODE,\n\t\t      dir, &new_dentry->d_name, 0);\n}\n\n \nstatic inline void fsnotify_delete(struct inode *dir, struct inode *inode,\n\t\t\t\t   struct dentry *dentry)\n{\n\t__u32 mask = FS_DELETE;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tmask |= FS_ISDIR;\n\n\tfsnotify_name(mask, inode, FSNOTIFY_EVENT_INODE, dir, &dentry->d_name,\n\t\t      0);\n}\n\n \nstatic inline void d_delete_notify(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tihold(inode);\n\td_delete(dentry);\n\tfsnotify_delete(dir, inode, dentry);\n\tiput(inode);\n}\n\n \nstatic inline void fsnotify_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tif (WARN_ON_ONCE(d_is_negative(dentry)))\n\t\treturn;\n\n\tfsnotify_delete(dir, d_inode(dentry), dentry);\n}\n\n \nstatic inline void fsnotify_mkdir(struct inode *dir, struct dentry *dentry)\n{\n\taudit_inode_child(dir, dentry, AUDIT_TYPE_CHILD_CREATE);\n\n\tfsnotify_dirent(dir, dentry, FS_CREATE | FS_ISDIR);\n}\n\n \nstatic inline void fsnotify_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tif (WARN_ON_ONCE(d_is_negative(dentry)))\n\t\treturn;\n\n\tfsnotify_delete(dir, d_inode(dentry), dentry);\n}\n\n \nstatic inline void fsnotify_access(struct file *file)\n{\n\tfsnotify_file(file, FS_ACCESS);\n}\n\n \nstatic inline void fsnotify_modify(struct file *file)\n{\n\tfsnotify_file(file, FS_MODIFY);\n}\n\n \nstatic inline void fsnotify_open(struct file *file)\n{\n\t__u32 mask = FS_OPEN;\n\n\tif (file->f_flags & __FMODE_EXEC)\n\t\tmask |= FS_OPEN_EXEC;\n\n\tfsnotify_file(file, mask);\n}\n\n \nstatic inline void fsnotify_close(struct file *file)\n{\n\t__u32 mask = (file->f_mode & FMODE_WRITE) ? FS_CLOSE_WRITE :\n\t\t\t\t\t\t    FS_CLOSE_NOWRITE;\n\n\tfsnotify_file(file, mask);\n}\n\n \nstatic inline void fsnotify_xattr(struct dentry *dentry)\n{\n\tfsnotify_dentry(dentry, FS_ATTRIB);\n}\n\n \nstatic inline void fsnotify_change(struct dentry *dentry, unsigned int ia_valid)\n{\n\t__u32 mask = 0;\n\n\tif (ia_valid & ATTR_UID)\n\t\tmask |= FS_ATTRIB;\n\tif (ia_valid & ATTR_GID)\n\t\tmask |= FS_ATTRIB;\n\tif (ia_valid & ATTR_SIZE)\n\t\tmask |= FS_MODIFY;\n\n\t \n\tif ((ia_valid & (ATTR_ATIME | ATTR_MTIME)) == (ATTR_ATIME | ATTR_MTIME))\n\t\tmask |= FS_ATTRIB;\n\telse if (ia_valid & ATTR_ATIME)\n\t\tmask |= FS_ACCESS;\n\telse if (ia_valid & ATTR_MTIME)\n\t\tmask |= FS_MODIFY;\n\n\tif (ia_valid & ATTR_MODE)\n\t\tmask |= FS_ATTRIB;\n\n\tif (mask)\n\t\tfsnotify_dentry(dentry, mask);\n}\n\nstatic inline int fsnotify_sb_error(struct super_block *sb, struct inode *inode,\n\t\t\t\t    int error)\n{\n\tstruct fs_error_report report = {\n\t\t.error = error,\n\t\t.inode = inode,\n\t\t.sb = sb,\n\t};\n\n\treturn fsnotify(FS_ERROR, &report, FSNOTIFY_EVENT_ERROR,\n\t\t\tNULL, NULL, NULL, 0);\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}