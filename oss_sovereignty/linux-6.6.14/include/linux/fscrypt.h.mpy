{
  "module_name": "fscrypt.h",
  "hash_id": "22135f0a3b34c9f7136668573c47bf2b1a2ab62f9eab1ae1a6e3582fb9875602",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fscrypt.h",
  "human_readable_source": " \n \n#ifndef _LINUX_FSCRYPT_H\n#define _LINUX_FSCRYPT_H\n\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <uapi/linux/fscrypt.h>\n\n \n#define FSCRYPT_CONTENTS_ALIGNMENT 16\n\nunion fscrypt_policy;\nstruct fscrypt_info;\nstruct fs_parameter;\nstruct seq_file;\n\nstruct fscrypt_str {\n\tunsigned char *name;\n\tu32 len;\n};\n\nstruct fscrypt_name {\n\tconst struct qstr *usr_fname;\n\tstruct fscrypt_str disk_name;\n\tu32 hash;\n\tu32 minor_hash;\n\tstruct fscrypt_str crypto_buf;\n\tbool is_nokey_name;\n};\n\n#define FSTR_INIT(n, l)\t\t{ .name = n, .len = l }\n#define FSTR_TO_QSTR(f)\t\tQSTR_INIT((f)->name, (f)->len)\n#define fname_name(p)\t\t((p)->disk_name.name)\n#define fname_len(p)\t\t((p)->disk_name.len)\n\n \n#define FSCRYPT_SET_CONTEXT_MAX_SIZE\t40\n\n#ifdef CONFIG_FS_ENCRYPTION\n\n \n#define FS_CFLG_OWN_PAGES (1U << 1)\n\n \nstruct fscrypt_operations {\n\n\t \n\tunsigned int flags;\n\n\t \n\tconst char *key_prefix;\n\n\t \n\tint (*get_context)(struct inode *inode, void *ctx, size_t len);\n\n\t \n\tint (*set_context)(struct inode *inode, const void *ctx, size_t len,\n\t\t\t   void *fs_data);\n\n\t \n\tconst union fscrypt_policy *(*get_dummy_policy)(struct super_block *sb);\n\n\t \n\tbool (*empty_dir)(struct inode *inode);\n\n\t \n\tbool (*has_stable_inodes)(struct super_block *sb);\n\n\t \n\tvoid (*get_ino_and_lblk_bits)(struct super_block *sb,\n\t\t\t\t      int *ino_bits_ret, int *lblk_bits_ret);\n\n\t \n\tstruct block_device **(*get_devices)(struct super_block *sb,\n\t\t\t\t\t     unsigned int *num_devs);\n};\n\nstatic inline struct fscrypt_info *fscrypt_get_info(const struct inode *inode)\n{\n\t \n\treturn smp_load_acquire(&inode->i_crypt_info);\n}\n\n \nstatic inline bool fscrypt_needs_contents_encryption(const struct inode *inode)\n{\n\treturn IS_ENCRYPTED(inode) && S_ISREG(inode->i_mode);\n}\n\n \nstatic inline void fscrypt_handle_d_move(struct dentry *dentry)\n{\n\tdentry->d_flags &= ~DCACHE_NOKEY_NAME;\n}\n\n \nstatic inline bool fscrypt_is_nokey_name(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_NOKEY_NAME;\n}\n\n \nvoid fscrypt_enqueue_decrypt_work(struct work_struct *);\n\nstruct page *fscrypt_encrypt_pagecache_blocks(struct page *page,\n\t\t\t\t\t      unsigned int len,\n\t\t\t\t\t      unsigned int offs,\n\t\t\t\t\t      gfp_t gfp_flags);\nint fscrypt_encrypt_block_inplace(const struct inode *inode, struct page *page,\n\t\t\t\t  unsigned int len, unsigned int offs,\n\t\t\t\t  u64 lblk_num, gfp_t gfp_flags);\n\nint fscrypt_decrypt_pagecache_blocks(struct folio *folio, size_t len,\n\t\t\t\t     size_t offs);\nint fscrypt_decrypt_block_inplace(const struct inode *inode, struct page *page,\n\t\t\t\t  unsigned int len, unsigned int offs,\n\t\t\t\t  u64 lblk_num);\n\nstatic inline bool fscrypt_is_bounce_page(struct page *page)\n{\n\treturn page->mapping == NULL;\n}\n\nstatic inline struct page *fscrypt_pagecache_page(struct page *bounce_page)\n{\n\treturn (struct page *)page_private(bounce_page);\n}\n\nstatic inline bool fscrypt_is_bounce_folio(struct folio *folio)\n{\n\treturn folio->mapping == NULL;\n}\n\nstatic inline struct folio *fscrypt_pagecache_folio(struct folio *bounce_folio)\n{\n\treturn bounce_folio->private;\n}\n\nvoid fscrypt_free_bounce_page(struct page *bounce_page);\n\n \nint fscrypt_ioctl_set_policy(struct file *filp, const void __user *arg);\nint fscrypt_ioctl_get_policy(struct file *filp, void __user *arg);\nint fscrypt_ioctl_get_policy_ex(struct file *filp, void __user *arg);\nint fscrypt_ioctl_get_nonce(struct file *filp, void __user *arg);\nint fscrypt_has_permitted_context(struct inode *parent, struct inode *child);\nint fscrypt_context_for_new_inode(void *ctx, struct inode *inode);\nint fscrypt_set_context(struct inode *inode, void *fs_data);\n\nstruct fscrypt_dummy_policy {\n\tconst union fscrypt_policy *policy;\n};\n\nint fscrypt_parse_test_dummy_encryption(const struct fs_parameter *param,\n\t\t\t\t    struct fscrypt_dummy_policy *dummy_policy);\nbool fscrypt_dummy_policies_equal(const struct fscrypt_dummy_policy *p1,\n\t\t\t\t  const struct fscrypt_dummy_policy *p2);\nvoid fscrypt_show_test_dummy_encryption(struct seq_file *seq, char sep,\n\t\t\t\t\tstruct super_block *sb);\nstatic inline bool\nfscrypt_is_dummy_policy_set(const struct fscrypt_dummy_policy *dummy_policy)\n{\n\treturn dummy_policy->policy != NULL;\n}\nstatic inline void\nfscrypt_free_dummy_policy(struct fscrypt_dummy_policy *dummy_policy)\n{\n\tkfree(dummy_policy->policy);\n\tdummy_policy->policy = NULL;\n}\n\n \nvoid fscrypt_destroy_keyring(struct super_block *sb);\nint fscrypt_ioctl_add_key(struct file *filp, void __user *arg);\nint fscrypt_ioctl_remove_key(struct file *filp, void __user *arg);\nint fscrypt_ioctl_remove_key_all_users(struct file *filp, void __user *arg);\nint fscrypt_ioctl_get_key_status(struct file *filp, void __user *arg);\n\n \nint fscrypt_prepare_new_inode(struct inode *dir, struct inode *inode,\n\t\t\t      bool *encrypt_ret);\nvoid fscrypt_put_encryption_info(struct inode *inode);\nvoid fscrypt_free_inode(struct inode *inode);\nint fscrypt_drop_inode(struct inode *inode);\n\n \nint fscrypt_fname_encrypt(const struct inode *inode, const struct qstr *iname,\n\t\t\t  u8 *out, unsigned int olen);\nbool fscrypt_fname_encrypted_size(const struct inode *inode, u32 orig_len,\n\t\t\t\t  u32 max_len, u32 *encrypted_len_ret);\nint fscrypt_setup_filename(struct inode *inode, const struct qstr *iname,\n\t\t\t   int lookup, struct fscrypt_name *fname);\n\nstatic inline void fscrypt_free_filename(struct fscrypt_name *fname)\n{\n\tkfree(fname->crypto_buf.name);\n}\n\nint fscrypt_fname_alloc_buffer(u32 max_encrypted_len,\n\t\t\t       struct fscrypt_str *crypto_str);\nvoid fscrypt_fname_free_buffer(struct fscrypt_str *crypto_str);\nint fscrypt_fname_disk_to_usr(const struct inode *inode,\n\t\t\t      u32 hash, u32 minor_hash,\n\t\t\t      const struct fscrypt_str *iname,\n\t\t\t      struct fscrypt_str *oname);\nbool fscrypt_match_name(const struct fscrypt_name *fname,\n\t\t\tconst u8 *de_name, u32 de_name_len);\nu64 fscrypt_fname_siphash(const struct inode *dir, const struct qstr *name);\nint fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags);\n\n \nbool fscrypt_decrypt_bio(struct bio *bio);\nint fscrypt_zeroout_range(const struct inode *inode, pgoff_t lblk,\n\t\t\t  sector_t pblk, unsigned int len);\n\n \nint fscrypt_file_open(struct inode *inode, struct file *filp);\nint __fscrypt_prepare_link(struct inode *inode, struct inode *dir,\n\t\t\t   struct dentry *dentry);\nint __fscrypt_prepare_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t     unsigned int flags);\nint __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct fscrypt_name *fname);\nint fscrypt_prepare_lookup_partial(struct inode *dir, struct dentry *dentry);\nint __fscrypt_prepare_readdir(struct inode *dir);\nint __fscrypt_prepare_setattr(struct dentry *dentry, struct iattr *attr);\nint fscrypt_prepare_setflags(struct inode *inode,\n\t\t\t     unsigned int oldflags, unsigned int flags);\nint fscrypt_prepare_symlink(struct inode *dir, const char *target,\n\t\t\t    unsigned int len, unsigned int max_len,\n\t\t\t    struct fscrypt_str *disk_link);\nint __fscrypt_encrypt_symlink(struct inode *inode, const char *target,\n\t\t\t      unsigned int len, struct fscrypt_str *disk_link);\nconst char *fscrypt_get_symlink(struct inode *inode, const void *caddr,\n\t\t\t\tunsigned int max_size,\n\t\t\t\tstruct delayed_call *done);\nint fscrypt_symlink_getattr(const struct path *path, struct kstat *stat);\nstatic inline void fscrypt_set_ops(struct super_block *sb,\n\t\t\t\t   const struct fscrypt_operations *s_cop)\n{\n\tsb->s_cop = s_cop;\n}\n#else   \n\nstatic inline struct fscrypt_info *fscrypt_get_info(const struct inode *inode)\n{\n\treturn NULL;\n}\n\nstatic inline bool fscrypt_needs_contents_encryption(const struct inode *inode)\n{\n\treturn false;\n}\n\nstatic inline void fscrypt_handle_d_move(struct dentry *dentry)\n{\n}\n\nstatic inline bool fscrypt_is_nokey_name(const struct dentry *dentry)\n{\n\treturn false;\n}\n\n \nstatic inline void fscrypt_enqueue_decrypt_work(struct work_struct *work)\n{\n}\n\nstatic inline struct page *fscrypt_encrypt_pagecache_blocks(struct page *page,\n\t\t\t\t\t\t\t    unsigned int len,\n\t\t\t\t\t\t\t    unsigned int offs,\n\t\t\t\t\t\t\t    gfp_t gfp_flags)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n\nstatic inline int fscrypt_encrypt_block_inplace(const struct inode *inode,\n\t\t\t\t\t\tstruct page *page,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int offs, u64 lblk_num,\n\t\t\t\t\t\tgfp_t gfp_flags)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fscrypt_decrypt_pagecache_blocks(struct folio *folio,\n\t\t\t\t\t\t   size_t len, size_t offs)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fscrypt_decrypt_block_inplace(const struct inode *inode,\n\t\t\t\t\t\tstruct page *page,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int offs, u64 lblk_num)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline bool fscrypt_is_bounce_page(struct page *page)\n{\n\treturn false;\n}\n\nstatic inline struct page *fscrypt_pagecache_page(struct page *bounce_page)\n{\n\tWARN_ON_ONCE(1);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic inline bool fscrypt_is_bounce_folio(struct folio *folio)\n{\n\treturn false;\n}\n\nstatic inline struct folio *fscrypt_pagecache_folio(struct folio *bounce_folio)\n{\n\tWARN_ON_ONCE(1);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic inline void fscrypt_free_bounce_page(struct page *bounce_page)\n{\n}\n\n \nstatic inline int fscrypt_ioctl_set_policy(struct file *filp,\n\t\t\t\t\t   const void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fscrypt_ioctl_get_policy(struct file *filp, void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fscrypt_ioctl_get_policy_ex(struct file *filp,\n\t\t\t\t\t      void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fscrypt_ioctl_get_nonce(struct file *filp, void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fscrypt_has_permitted_context(struct inode *parent,\n\t\t\t\t\t\tstruct inode *child)\n{\n\treturn 0;\n}\n\nstatic inline int fscrypt_set_context(struct inode *inode, void *fs_data)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstruct fscrypt_dummy_policy {\n};\n\nstatic inline int\nfscrypt_parse_test_dummy_encryption(const struct fs_parameter *param,\n\t\t\t\t    struct fscrypt_dummy_policy *dummy_policy)\n{\n\treturn -EINVAL;\n}\n\nstatic inline bool\nfscrypt_dummy_policies_equal(const struct fscrypt_dummy_policy *p1,\n\t\t\t     const struct fscrypt_dummy_policy *p2)\n{\n\treturn true;\n}\n\nstatic inline void fscrypt_show_test_dummy_encryption(struct seq_file *seq,\n\t\t\t\t\t\t      char sep,\n\t\t\t\t\t\t      struct super_block *sb)\n{\n}\n\nstatic inline bool\nfscrypt_is_dummy_policy_set(const struct fscrypt_dummy_policy *dummy_policy)\n{\n\treturn false;\n}\n\nstatic inline void\nfscrypt_free_dummy_policy(struct fscrypt_dummy_policy *dummy_policy)\n{\n}\n\n \nstatic inline void fscrypt_destroy_keyring(struct super_block *sb)\n{\n}\n\nstatic inline int fscrypt_ioctl_add_key(struct file *filp, void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fscrypt_ioctl_remove_key(struct file *filp, void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fscrypt_ioctl_remove_key_all_users(struct file *filp,\n\t\t\t\t\t\t     void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fscrypt_ioctl_get_key_status(struct file *filp,\n\t\t\t\t\t       void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \n\nstatic inline int fscrypt_prepare_new_inode(struct inode *dir,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    bool *encrypt_ret)\n{\n\tif (IS_ENCRYPTED(dir))\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\nstatic inline void fscrypt_put_encryption_info(struct inode *inode)\n{\n\treturn;\n}\n\nstatic inline void fscrypt_free_inode(struct inode *inode)\n{\n}\n\nstatic inline int fscrypt_drop_inode(struct inode *inode)\n{\n\treturn 0;\n}\n\n  \nstatic inline int fscrypt_setup_filename(struct inode *dir,\n\t\t\t\t\t const struct qstr *iname,\n\t\t\t\t\t int lookup, struct fscrypt_name *fname)\n{\n\tif (IS_ENCRYPTED(dir))\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(fname, 0, sizeof(*fname));\n\tfname->usr_fname = iname;\n\tfname->disk_name.name = (unsigned char *)iname->name;\n\tfname->disk_name.len = iname->len;\n\treturn 0;\n}\n\nstatic inline void fscrypt_free_filename(struct fscrypt_name *fname)\n{\n\treturn;\n}\n\nstatic inline int fscrypt_fname_alloc_buffer(u32 max_encrypted_len,\n\t\t\t\t\t     struct fscrypt_str *crypto_str)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void fscrypt_fname_free_buffer(struct fscrypt_str *crypto_str)\n{\n\treturn;\n}\n\nstatic inline int fscrypt_fname_disk_to_usr(const struct inode *inode,\n\t\t\t\t\t    u32 hash, u32 minor_hash,\n\t\t\t\t\t    const struct fscrypt_str *iname,\n\t\t\t\t\t    struct fscrypt_str *oname)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline bool fscrypt_match_name(const struct fscrypt_name *fname,\n\t\t\t\t      const u8 *de_name, u32 de_name_len)\n{\n\t \n\tif (de_name_len != fname->disk_name.len)\n\t\treturn false;\n\treturn !memcmp(de_name, fname->disk_name.name, fname->disk_name.len);\n}\n\nstatic inline u64 fscrypt_fname_siphash(const struct inode *dir,\n\t\t\t\t\tconst struct qstr *name)\n{\n\tWARN_ON_ONCE(1);\n\treturn 0;\n}\n\nstatic inline int fscrypt_d_revalidate(struct dentry *dentry,\n\t\t\t\t       unsigned int flags)\n{\n\treturn 1;\n}\n\n \nstatic inline bool fscrypt_decrypt_bio(struct bio *bio)\n{\n\treturn true;\n}\n\nstatic inline int fscrypt_zeroout_range(const struct inode *inode, pgoff_t lblk,\n\t\t\t\t\tsector_t pblk, unsigned int len)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \n\nstatic inline int fscrypt_file_open(struct inode *inode, struct file *filp)\n{\n\tif (IS_ENCRYPTED(inode))\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\nstatic inline int __fscrypt_prepare_link(struct inode *inode, struct inode *dir,\n\t\t\t\t\t struct dentry *dentry)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int __fscrypt_prepare_rename(struct inode *old_dir,\n\t\t\t\t\t   struct dentry *old_dentry,\n\t\t\t\t\t   struct inode *new_dir,\n\t\t\t\t\t   struct dentry *new_dentry,\n\t\t\t\t\t   unsigned int flags)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int __fscrypt_prepare_lookup(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   struct fscrypt_name *fname)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fscrypt_prepare_lookup_partial(struct inode *dir,\n\t\t\t\t\t\t struct dentry *dentry)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int __fscrypt_prepare_readdir(struct inode *dir)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int __fscrypt_prepare_setattr(struct dentry *dentry,\n\t\t\t\t\t    struct iattr *attr)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fscrypt_prepare_setflags(struct inode *inode,\n\t\t\t\t\t   unsigned int oldflags,\n\t\t\t\t\t   unsigned int flags)\n{\n\treturn 0;\n}\n\nstatic inline int fscrypt_prepare_symlink(struct inode *dir,\n\t\t\t\t\t  const char *target,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int max_len,\n\t\t\t\t\t  struct fscrypt_str *disk_link)\n{\n\tif (IS_ENCRYPTED(dir))\n\t\treturn -EOPNOTSUPP;\n\tdisk_link->name = (unsigned char *)target;\n\tdisk_link->len = len + 1;\n\tif (disk_link->len > max_len)\n\t\treturn -ENAMETOOLONG;\n\treturn 0;\n}\n\nstatic inline int __fscrypt_encrypt_symlink(struct inode *inode,\n\t\t\t\t\t    const char *target,\n\t\t\t\t\t    unsigned int len,\n\t\t\t\t\t    struct fscrypt_str *disk_link)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline const char *fscrypt_get_symlink(struct inode *inode,\n\t\t\t\t\t      const void *caddr,\n\t\t\t\t\t      unsigned int max_size,\n\t\t\t\t\t      struct delayed_call *done)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n\nstatic inline int fscrypt_symlink_getattr(const struct path *path,\n\t\t\t\t\t  struct kstat *stat)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void fscrypt_set_ops(struct super_block *sb,\n\t\t\t\t   const struct fscrypt_operations *s_cop)\n{\n}\n\n#endif\t \n\n \n#ifdef CONFIG_FS_ENCRYPTION_INLINE_CRYPT\n\nbool __fscrypt_inode_uses_inline_crypto(const struct inode *inode);\n\nvoid fscrypt_set_bio_crypt_ctx(struct bio *bio,\n\t\t\t       const struct inode *inode, u64 first_lblk,\n\t\t\t       gfp_t gfp_mask);\n\nvoid fscrypt_set_bio_crypt_ctx_bh(struct bio *bio,\n\t\t\t\t  const struct buffer_head *first_bh,\n\t\t\t\t  gfp_t gfp_mask);\n\nbool fscrypt_mergeable_bio(struct bio *bio, const struct inode *inode,\n\t\t\t   u64 next_lblk);\n\nbool fscrypt_mergeable_bio_bh(struct bio *bio,\n\t\t\t      const struct buffer_head *next_bh);\n\nbool fscrypt_dio_supported(struct inode *inode);\n\nu64 fscrypt_limit_io_blocks(const struct inode *inode, u64 lblk, u64 nr_blocks);\n\n#else  \n\nstatic inline bool __fscrypt_inode_uses_inline_crypto(const struct inode *inode)\n{\n\treturn false;\n}\n\nstatic inline void fscrypt_set_bio_crypt_ctx(struct bio *bio,\n\t\t\t\t\t     const struct inode *inode,\n\t\t\t\t\t     u64 first_lblk, gfp_t gfp_mask) { }\n\nstatic inline void fscrypt_set_bio_crypt_ctx_bh(\n\t\t\t\t\t struct bio *bio,\n\t\t\t\t\t const struct buffer_head *first_bh,\n\t\t\t\t\t gfp_t gfp_mask) { }\n\nstatic inline bool fscrypt_mergeable_bio(struct bio *bio,\n\t\t\t\t\t const struct inode *inode,\n\t\t\t\t\t u64 next_lblk)\n{\n\treturn true;\n}\n\nstatic inline bool fscrypt_mergeable_bio_bh(struct bio *bio,\n\t\t\t\t\t    const struct buffer_head *next_bh)\n{\n\treturn true;\n}\n\nstatic inline bool fscrypt_dio_supported(struct inode *inode)\n{\n\treturn !fscrypt_needs_contents_encryption(inode);\n}\n\nstatic inline u64 fscrypt_limit_io_blocks(const struct inode *inode, u64 lblk,\n\t\t\t\t\t  u64 nr_blocks)\n{\n\treturn nr_blocks;\n}\n#endif  \n\n \nstatic inline bool fscrypt_inode_uses_inline_crypto(const struct inode *inode)\n{\n\treturn fscrypt_needs_contents_encryption(inode) &&\n\t       __fscrypt_inode_uses_inline_crypto(inode);\n}\n\n \nstatic inline bool fscrypt_inode_uses_fs_layer_crypto(const struct inode *inode)\n{\n\treturn fscrypt_needs_contents_encryption(inode) &&\n\t       !__fscrypt_inode_uses_inline_crypto(inode);\n}\n\n \nstatic inline bool fscrypt_has_encryption_key(const struct inode *inode)\n{\n\treturn fscrypt_get_info(inode) != NULL;\n}\n\n \nstatic inline int fscrypt_prepare_link(struct dentry *old_dentry,\n\t\t\t\t       struct inode *dir,\n\t\t\t\t       struct dentry *dentry)\n{\n\tif (IS_ENCRYPTED(dir))\n\t\treturn __fscrypt_prepare_link(d_inode(old_dentry), dir, dentry);\n\treturn 0;\n}\n\n \nstatic inline int fscrypt_prepare_rename(struct inode *old_dir,\n\t\t\t\t\t struct dentry *old_dentry,\n\t\t\t\t\t struct inode *new_dir,\n\t\t\t\t\t struct dentry *new_dentry,\n\t\t\t\t\t unsigned int flags)\n{\n\tif (IS_ENCRYPTED(old_dir) || IS_ENCRYPTED(new_dir))\n\t\treturn __fscrypt_prepare_rename(old_dir, old_dentry,\n\t\t\t\t\t\tnew_dir, new_dentry, flags);\n\treturn 0;\n}\n\n \nstatic inline int fscrypt_prepare_lookup(struct inode *dir,\n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t struct fscrypt_name *fname)\n{\n\tif (IS_ENCRYPTED(dir))\n\t\treturn __fscrypt_prepare_lookup(dir, dentry, fname);\n\n\tmemset(fname, 0, sizeof(*fname));\n\tfname->usr_fname = &dentry->d_name;\n\tfname->disk_name.name = (unsigned char *)dentry->d_name.name;\n\tfname->disk_name.len = dentry->d_name.len;\n\treturn 0;\n}\n\n \nstatic inline int fscrypt_prepare_readdir(struct inode *dir)\n{\n\tif (IS_ENCRYPTED(dir))\n\t\treturn __fscrypt_prepare_readdir(dir);\n\treturn 0;\n}\n\n \nstatic inline int fscrypt_prepare_setattr(struct dentry *dentry,\n\t\t\t\t\t  struct iattr *attr)\n{\n\tif (IS_ENCRYPTED(d_inode(dentry)))\n\t\treturn __fscrypt_prepare_setattr(dentry, attr);\n\treturn 0;\n}\n\n \nstatic inline int fscrypt_encrypt_symlink(struct inode *inode,\n\t\t\t\t\t  const char *target,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  struct fscrypt_str *disk_link)\n{\n\tif (IS_ENCRYPTED(inode))\n\t\treturn __fscrypt_encrypt_symlink(inode, target, len, disk_link);\n\treturn 0;\n}\n\n \nstatic inline void fscrypt_finalize_bounce_page(struct page **pagep)\n{\n\tstruct page *page = *pagep;\n\n\tif (fscrypt_is_bounce_page(page)) {\n\t\t*pagep = fscrypt_pagecache_page(page);\n\t\tfscrypt_free_bounce_page(page);\n\t}\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}