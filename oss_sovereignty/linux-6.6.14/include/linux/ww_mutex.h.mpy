{
  "module_name": "ww_mutex.h",
  "hash_id": "738f9f35665f85d31d8f3de4ac897e83b2ec86d507bb7517eef7a22eec8d5493",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ww_mutex.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_WW_MUTEX_H\n#define __LINUX_WW_MUTEX_H\n\n#include <linux/mutex.h>\n#include <linux/rtmutex.h>\n\n#if defined(CONFIG_DEBUG_MUTEXES) || \\\n   (defined(CONFIG_PREEMPT_RT) && defined(CONFIG_DEBUG_RT_MUTEXES))\n#define DEBUG_WW_MUTEXES\n#endif\n\n#ifndef CONFIG_PREEMPT_RT\n#define WW_MUTEX_BASE\t\t\tmutex\n#define ww_mutex_base_init(l,n,k)\t__mutex_init(l,n,k)\n#define ww_mutex_base_is_locked(b)\tmutex_is_locked((b))\n#else\n#define WW_MUTEX_BASE\t\t\trt_mutex\n#define ww_mutex_base_init(l,n,k)\t__rt_mutex_init(l,n,k)\n#define ww_mutex_base_is_locked(b)\trt_mutex_base_is_locked(&(b)->rtmutex)\n#endif\n\nstruct ww_class {\n\tatomic_long_t stamp;\n\tstruct lock_class_key acquire_key;\n\tstruct lock_class_key mutex_key;\n\tconst char *acquire_name;\n\tconst char *mutex_name;\n\tunsigned int is_wait_die;\n};\n\nstruct ww_mutex {\n\tstruct WW_MUTEX_BASE base;\n\tstruct ww_acquire_ctx *ctx;\n#ifdef DEBUG_WW_MUTEXES\n\tstruct ww_class *ww_class;\n#endif\n};\n\nstruct ww_acquire_ctx {\n\tstruct task_struct *task;\n\tunsigned long stamp;\n\tunsigned int acquired;\n\tunsigned short wounded;\n\tunsigned short is_wait_die;\n#ifdef DEBUG_WW_MUTEXES\n\tunsigned int done_acquire;\n\tstruct ww_class *ww_class;\n\tvoid *contending_lock;\n#endif\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tstruct lockdep_map dep_map;\n#endif\n#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH\n\tunsigned int deadlock_inject_interval;\n\tunsigned int deadlock_inject_countdown;\n#endif\n};\n\n#define __WW_CLASS_INITIALIZER(ww_class, _is_wait_die)\t    \\\n\t\t{ .stamp = ATOMIC_LONG_INIT(0) \\\n\t\t, .acquire_name = #ww_class \"_acquire\" \\\n\t\t, .mutex_name = #ww_class \"_mutex\" \\\n\t\t, .is_wait_die = _is_wait_die }\n\n#define DEFINE_WD_CLASS(classname) \\\n\tstruct ww_class classname = __WW_CLASS_INITIALIZER(classname, 1)\n\n#define DEFINE_WW_CLASS(classname) \\\n\tstruct ww_class classname = __WW_CLASS_INITIALIZER(classname, 0)\n\n \nstatic inline void ww_mutex_init(struct ww_mutex *lock,\n\t\t\t\t struct ww_class *ww_class)\n{\n\tww_mutex_base_init(&lock->base, ww_class->mutex_name, &ww_class->mutex_key);\n\tlock->ctx = NULL;\n#ifdef DEBUG_WW_MUTEXES\n\tlock->ww_class = ww_class;\n#endif\n}\n\n \nstatic inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n\t\t\t\t   struct ww_class *ww_class)\n{\n\tctx->task = current;\n\tctx->stamp = atomic_long_inc_return_relaxed(&ww_class->stamp);\n\tctx->acquired = 0;\n\tctx->wounded = false;\n\tctx->is_wait_die = ww_class->is_wait_die;\n#ifdef DEBUG_WW_MUTEXES\n\tctx->ww_class = ww_class;\n\tctx->done_acquire = 0;\n\tctx->contending_lock = NULL;\n#endif\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tdebug_check_no_locks_freed((void *)ctx, sizeof(*ctx));\n\tlockdep_init_map(&ctx->dep_map, ww_class->acquire_name,\n\t\t\t &ww_class->acquire_key, 0);\n\tmutex_acquire(&ctx->dep_map, 0, 0, _RET_IP_);\n#endif\n#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH\n\tctx->deadlock_inject_interval = 1;\n\tctx->deadlock_inject_countdown = ctx->stamp & 0xf;\n#endif\n}\n\n \nstatic inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n{\n#ifdef DEBUG_WW_MUTEXES\n\tlockdep_assert_held(ctx);\n\n\tDEBUG_LOCKS_WARN_ON(ctx->done_acquire);\n\tctx->done_acquire = 1;\n#endif\n}\n\n \nstatic inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tmutex_release(&ctx->dep_map, _THIS_IP_);\n#endif\n#ifdef DEBUG_WW_MUTEXES\n\tDEBUG_LOCKS_WARN_ON(ctx->acquired);\n\tif (!IS_ENABLED(CONFIG_PROVE_LOCKING))\n\t\t \n\t\tctx->done_acquire = 1;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_LOCK_ALLOC))\n\t\t \n\t\tctx->acquired = ~0U;\n#endif\n}\n\n \nextern int   ww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx);\n\n \nextern int __must_check ww_mutex_lock_interruptible(struct ww_mutex *lock,\n\t\t\t\t\t\t    struct ww_acquire_ctx *ctx);\n\n \nstatic inline void\nww_mutex_lock_slow(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tint ret;\n#ifdef DEBUG_WW_MUTEXES\n\tDEBUG_LOCKS_WARN_ON(!ctx->contending_lock);\n#endif\n\tret = ww_mutex_lock(lock, ctx);\n\t(void)ret;\n}\n\n \nstatic inline int __must_check\nww_mutex_lock_slow_interruptible(struct ww_mutex *lock,\n\t\t\t\t struct ww_acquire_ctx *ctx)\n{\n#ifdef DEBUG_WW_MUTEXES\n\tDEBUG_LOCKS_WARN_ON(!ctx->contending_lock);\n#endif\n\treturn ww_mutex_lock_interruptible(lock, ctx);\n}\n\nextern void ww_mutex_unlock(struct ww_mutex *lock);\n\nextern int __must_check ww_mutex_trylock(struct ww_mutex *lock,\n\t\t\t\t\t struct ww_acquire_ctx *ctx);\n\n \nstatic inline void ww_mutex_destroy(struct ww_mutex *lock)\n{\n#ifndef CONFIG_PREEMPT_RT\n\tmutex_destroy(&lock->base);\n#endif\n}\n\n \nstatic inline bool ww_mutex_is_locked(struct ww_mutex *lock)\n{\n\treturn ww_mutex_base_is_locked(&lock->base);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}