{
  "module_name": "ktime.h",
  "hash_id": "d454e579bb16669df3ce76cc5aaece72ba9d4d06176fb2227ff4b28772cc93aa",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ktime.h",
  "human_readable_source": " \n#ifndef _LINUX_KTIME_H\n#define _LINUX_KTIME_H\n\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <asm/bug.h>\n\n \ntypedef s64\tktime_t;\n\n \nstatic inline ktime_t ktime_set(const s64 secs, const unsigned long nsecs)\n{\n\tif (unlikely(secs >= KTIME_SEC_MAX))\n\t\treturn KTIME_MAX;\n\n\treturn secs * NSEC_PER_SEC + (s64)nsecs;\n}\n\n \n#define ktime_sub(lhs, rhs)\t((lhs) - (rhs))\n\n \n#define ktime_add(lhs, rhs)\t((lhs) + (rhs))\n\n \n#define ktime_add_unsafe(lhs, rhs)\t((u64) (lhs) + (rhs))\n\n \n#define ktime_add_ns(kt, nsval)\t\t((kt) + (nsval))\n\n \n#define ktime_sub_ns(kt, nsval)\t\t((kt) - (nsval))\n\n \nstatic inline ktime_t timespec64_to_ktime(struct timespec64 ts)\n{\n\treturn ktime_set(ts.tv_sec, ts.tv_nsec);\n}\n\n \n#define ktime_to_timespec64(kt)\t\tns_to_timespec64((kt))\n\n \nstatic inline s64 ktime_to_ns(const ktime_t kt)\n{\n\treturn kt;\n}\n\n \nstatic inline int ktime_compare(const ktime_t cmp1, const ktime_t cmp2)\n{\n\tif (cmp1 < cmp2)\n\t\treturn -1;\n\tif (cmp1 > cmp2)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic inline bool ktime_after(const ktime_t cmp1, const ktime_t cmp2)\n{\n\treturn ktime_compare(cmp1, cmp2) > 0;\n}\n\n \nstatic inline bool ktime_before(const ktime_t cmp1, const ktime_t cmp2)\n{\n\treturn ktime_compare(cmp1, cmp2) < 0;\n}\n\n#if BITS_PER_LONG < 64\nextern s64 __ktime_divns(const ktime_t kt, s64 div);\nstatic inline s64 ktime_divns(const ktime_t kt, s64 div)\n{\n\t \n\tBUG_ON(div < 0);\n\tif (__builtin_constant_p(div) && !(div >> 32)) {\n\t\ts64 ns = kt;\n\t\tu64 tmp = ns < 0 ? -ns : ns;\n\n\t\tdo_div(tmp, div);\n\t\treturn ns < 0 ? -tmp : tmp;\n\t} else {\n\t\treturn __ktime_divns(kt, div);\n\t}\n}\n#else  \nstatic inline s64 ktime_divns(const ktime_t kt, s64 div)\n{\n\t \n\tWARN_ON(div < 0);\n\treturn kt / div;\n}\n#endif\n\nstatic inline s64 ktime_to_us(const ktime_t kt)\n{\n\treturn ktime_divns(kt, NSEC_PER_USEC);\n}\n\nstatic inline s64 ktime_to_ms(const ktime_t kt)\n{\n\treturn ktime_divns(kt, NSEC_PER_MSEC);\n}\n\nstatic inline s64 ktime_us_delta(const ktime_t later, const ktime_t earlier)\n{\n       return ktime_to_us(ktime_sub(later, earlier));\n}\n\nstatic inline s64 ktime_ms_delta(const ktime_t later, const ktime_t earlier)\n{\n\treturn ktime_to_ms(ktime_sub(later, earlier));\n}\n\nstatic inline ktime_t ktime_add_us(const ktime_t kt, const u64 usec)\n{\n\treturn ktime_add_ns(kt, usec * NSEC_PER_USEC);\n}\n\nstatic inline ktime_t ktime_add_ms(const ktime_t kt, const u64 msec)\n{\n\treturn ktime_add_ns(kt, msec * NSEC_PER_MSEC);\n}\n\nstatic inline ktime_t ktime_sub_us(const ktime_t kt, const u64 usec)\n{\n\treturn ktime_sub_ns(kt, usec * NSEC_PER_USEC);\n}\n\nstatic inline ktime_t ktime_sub_ms(const ktime_t kt, const u64 msec)\n{\n\treturn ktime_sub_ns(kt, msec * NSEC_PER_MSEC);\n}\n\nextern ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs);\n\n \nstatic inline __must_check bool ktime_to_timespec64_cond(const ktime_t kt,\n\t\t\t\t\t\t       struct timespec64 *ts)\n{\n\tif (kt) {\n\t\t*ts = ktime_to_timespec64(kt);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n#include <vdso/ktime.h>\n\nstatic inline ktime_t ns_to_ktime(u64 ns)\n{\n\treturn ns;\n}\n\nstatic inline ktime_t ms_to_ktime(u64 ms)\n{\n\treturn ms * NSEC_PER_MSEC;\n}\n\n# include <linux/timekeeping.h>\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}