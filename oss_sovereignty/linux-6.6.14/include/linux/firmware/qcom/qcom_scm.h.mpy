{
  "module_name": "qcom_scm.h",
  "hash_id": "023f9196ddf0a0aa72003f20dc644277d8d4e863d6dc80f8d274b9b93c1beea2",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/firmware/qcom/qcom_scm.h",
  "human_readable_source": " \n \n#ifndef __QCOM_SCM_H\n#define __QCOM_SCM_H\n\n#include <linux/err.h>\n#include <linux/types.h>\n#include <linux/cpumask.h>\n\n#include <dt-bindings/firmware/qcom,scm.h>\n\n#define QCOM_SCM_VERSION(major, minor)\t(((major) << 16) | ((minor) & 0xFF))\n#define QCOM_SCM_CPU_PWR_DOWN_L2_ON\t0x0\n#define QCOM_SCM_CPU_PWR_DOWN_L2_OFF\t0x1\n#define QCOM_SCM_HDCP_MAX_REQ_CNT\t5\n\nstruct qcom_scm_hdcp_req {\n\tu32 addr;\n\tu32 val;\n};\n\nstruct qcom_scm_vmperm {\n\tint vmid;\n\tint perm;\n};\n\nenum qcom_scm_ocmem_client {\n\tQCOM_SCM_OCMEM_UNUSED_ID = 0x0,\n\tQCOM_SCM_OCMEM_GRAPHICS_ID,\n\tQCOM_SCM_OCMEM_VIDEO_ID,\n\tQCOM_SCM_OCMEM_LP_AUDIO_ID,\n\tQCOM_SCM_OCMEM_SENSORS_ID,\n\tQCOM_SCM_OCMEM_OTHER_OS_ID,\n\tQCOM_SCM_OCMEM_DEBUG_ID,\n};\n\nenum qcom_scm_sec_dev_id {\n\tQCOM_SCM_MDSS_DEV_ID    = 1,\n\tQCOM_SCM_OCMEM_DEV_ID   = 5,\n\tQCOM_SCM_PCIE0_DEV_ID   = 11,\n\tQCOM_SCM_PCIE1_DEV_ID   = 12,\n\tQCOM_SCM_GFX_DEV_ID     = 18,\n\tQCOM_SCM_UFS_DEV_ID     = 19,\n\tQCOM_SCM_ICE_DEV_ID     = 20,\n};\n\nenum qcom_scm_ice_cipher {\n\tQCOM_SCM_ICE_CIPHER_AES_128_XTS = 0,\n\tQCOM_SCM_ICE_CIPHER_AES_128_CBC = 1,\n\tQCOM_SCM_ICE_CIPHER_AES_256_XTS = 3,\n\tQCOM_SCM_ICE_CIPHER_AES_256_CBC = 4,\n};\n\n#define QCOM_SCM_PERM_READ       0x4\n#define QCOM_SCM_PERM_WRITE      0x2\n#define QCOM_SCM_PERM_EXEC       0x1\n#define QCOM_SCM_PERM_RW (QCOM_SCM_PERM_READ | QCOM_SCM_PERM_WRITE)\n#define QCOM_SCM_PERM_RWX (QCOM_SCM_PERM_RW | QCOM_SCM_PERM_EXEC)\n\nextern bool qcom_scm_is_available(void);\n\nextern int qcom_scm_set_cold_boot_addr(void *entry);\nextern int qcom_scm_set_warm_boot_addr(void *entry);\nextern void qcom_scm_cpu_power_down(u32 flags);\nextern int qcom_scm_set_remote_state(u32 state, u32 id);\n\nstruct qcom_scm_pas_metadata {\n\tvoid *ptr;\n\tdma_addr_t phys;\n\tssize_t size;\n};\n\nextern int qcom_scm_pas_init_image(u32 peripheral, const void *metadata,\n\t\t\t\t   size_t size,\n\t\t\t\t   struct qcom_scm_pas_metadata *ctx);\nextern void qcom_scm_pas_metadata_release(struct qcom_scm_pas_metadata *ctx);\nextern int qcom_scm_pas_mem_setup(u32 peripheral, phys_addr_t addr,\n\t\t\t\t  phys_addr_t size);\nextern int qcom_scm_pas_auth_and_reset(u32 peripheral);\nextern int qcom_scm_pas_shutdown(u32 peripheral);\nextern bool qcom_scm_pas_supported(u32 peripheral);\n\nextern int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val);\nextern int qcom_scm_io_writel(phys_addr_t addr, unsigned int val);\n\nextern bool qcom_scm_restore_sec_cfg_available(void);\nextern int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare);\nextern int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size);\nextern int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare);\nextern int qcom_scm_iommu_set_cp_pool_size(u32 spare, u32 size);\nextern int qcom_scm_mem_protect_video_var(u32 cp_start, u32 cp_size,\n\t\t\t\t\t  u32 cp_nonpixel_start,\n\t\t\t\t\t  u32 cp_nonpixel_size);\nextern int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,\n\t\t\t       u64 *src,\n\t\t\t       const struct qcom_scm_vmperm *newvm,\n\t\t\t       unsigned int dest_cnt);\n\nextern bool qcom_scm_ocmem_lock_available(void);\nextern int qcom_scm_ocmem_lock(enum qcom_scm_ocmem_client id, u32 offset,\n\t\t\t       u32 size, u32 mode);\nextern int qcom_scm_ocmem_unlock(enum qcom_scm_ocmem_client id, u32 offset,\n\t\t\t\t u32 size);\n\nextern bool qcom_scm_ice_available(void);\nextern int qcom_scm_ice_invalidate_key(u32 index);\nextern int qcom_scm_ice_set_key(u32 index, const u8 *key, u32 key_size,\n\t\t\t\tenum qcom_scm_ice_cipher cipher,\n\t\t\t\tu32 data_unit_size);\n\nextern bool qcom_scm_hdcp_available(void);\nextern int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,\n\t\t\t     u32 *resp);\n\nextern int qcom_scm_iommu_set_pt_format(u32 sec_id, u32 ctx_num, u32 pt_fmt);\nextern int qcom_scm_qsmmu500_wait_safe_toggle(bool en);\n\nextern int qcom_scm_lmh_dcvsh(u32 payload_fn, u32 payload_reg, u32 payload_val,\n\t\t\t      u64 limit_node, u32 node_id, u64 version);\nextern int qcom_scm_lmh_profile_change(u32 profile_id);\nextern bool qcom_scm_lmh_dcvsh_available(void);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}