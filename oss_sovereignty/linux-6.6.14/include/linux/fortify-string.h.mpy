{
  "module_name": "fortify-string.h",
  "hash_id": "f2d6505ccd2b70dbecbf15c05964c79b05c78477a273bfb0020fa7b5d1f12911",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fortify-string.h",
  "human_readable_source": " \n#ifndef _LINUX_FORTIFY_STRING_H_\n#define _LINUX_FORTIFY_STRING_H_\n\n#include <linux/bug.h>\n#include <linux/const.h>\n#include <linux/limits.h>\n\n#define __FORTIFY_INLINE extern __always_inline __gnu_inline __overloadable\n#define __RENAME(x) __asm__(#x)\n\nvoid fortify_panic(const char *name) __noreturn __cold;\nvoid __read_overflow(void) __compiletime_error(\"detected read beyond size of object (1st parameter)\");\nvoid __read_overflow2(void) __compiletime_error(\"detected read beyond size of object (2nd parameter)\");\nvoid __read_overflow2_field(size_t avail, size_t wanted) __compiletime_warning(\"detected read beyond size of field (2nd parameter); maybe use struct_group()?\");\nvoid __write_overflow(void) __compiletime_error(\"detected write beyond size of object (1st parameter)\");\nvoid __write_overflow_field(size_t avail, size_t wanted) __compiletime_warning(\"detected write beyond size of field (1st parameter); maybe use struct_group()?\");\n\n#define __compiletime_strlen(p)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tchar *__p = (char *)(p);\t\t\t\t\\\n\tsize_t __ret = SIZE_MAX;\t\t\t\t\\\n\tconst size_t __p_size = __member_size(p);\t\t\\\n\tif (__p_size != SIZE_MAX &&\t\t\t\t\\\n\t    __builtin_constant_p(*__p)) {\t\t\t\\\n\t\tsize_t __p_len = __p_size - 1;\t\t\t\\\n\t\tif (__builtin_constant_p(__p[__p_len]) &&\t\\\n\t\t    __p[__p_len] == '\\0')\t\t\t\\\n\t\t\t__ret = __builtin_strlen(__p);\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\\\n})\n\n#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)\nextern void *__underlying_memchr(const void *p, int c, __kernel_size_t size) __RENAME(memchr);\nextern int __underlying_memcmp(const void *p, const void *q, __kernel_size_t size) __RENAME(memcmp);\nextern void *__underlying_memcpy(void *p, const void *q, __kernel_size_t size) __RENAME(memcpy);\nextern void *__underlying_memmove(void *p, const void *q, __kernel_size_t size) __RENAME(memmove);\nextern void *__underlying_memset(void *p, int c, __kernel_size_t size) __RENAME(memset);\nextern char *__underlying_strcat(char *p, const char *q) __RENAME(strcat);\nextern char *__underlying_strcpy(char *p, const char *q) __RENAME(strcpy);\nextern __kernel_size_t __underlying_strlen(const char *p) __RENAME(strlen);\nextern char *__underlying_strncat(char *p, const char *q, __kernel_size_t count) __RENAME(strncat);\nextern char *__underlying_strncpy(char *p, const char *q, __kernel_size_t size) __RENAME(strncpy);\n#else\n\n#if defined(__SANITIZE_MEMORY__)\n \n#include <linux/kmsan_string.h>\n#define __underlying_memcpy\t__msan_memcpy\n#define __underlying_memmove\t__msan_memmove\n#define __underlying_memset\t__msan_memset\n#else\n#define __underlying_memcpy\t__builtin_memcpy\n#define __underlying_memmove\t__builtin_memmove\n#define __underlying_memset\t__builtin_memset\n#endif\n\n#define __underlying_memchr\t__builtin_memchr\n#define __underlying_memcmp\t__builtin_memcmp\n#define __underlying_strcat\t__builtin_strcat\n#define __underlying_strcpy\t__builtin_strcpy\n#define __underlying_strlen\t__builtin_strlen\n#define __underlying_strncat\t__builtin_strncat\n#define __underlying_strncpy\t__builtin_strncpy\n#endif\n\n \n#define unsafe_memcpy(dst, src, bytes, justification)\t\t\\\n\t__underlying_memcpy(dst, src, bytes)\n\n \n#if __has_builtin(__builtin_dynamic_object_size)\n#define POS\t\t\t__pass_dynamic_object_size(1)\n#define POS0\t\t\t__pass_dynamic_object_size(0)\n#define __struct_size(p)\t__builtin_dynamic_object_size(p, 0)\n#define __member_size(p)\t__builtin_dynamic_object_size(p, 1)\n#else\n#define POS\t\t\t__pass_object_size(1)\n#define POS0\t\t\t__pass_object_size(0)\n#define __struct_size(p)\t__builtin_object_size(p, 0)\n#define __member_size(p)\t__builtin_object_size(p, 1)\n#endif\n\n#define __compiletime_lessthan(bounds, length)\t(\t\\\n\t__builtin_constant_p((bounds) < (length)) &&\t\\\n\t(bounds) < (length)\t\t\t\t\\\n)\n\n \n__FORTIFY_INLINE __diagnose_as(__builtin_strncpy, 1, 2, 3)\nchar *strncpy(char * const POS p, const char *q, __kernel_size_t size)\n{\n\tconst size_t p_size = __member_size(p);\n\n\tif (__compiletime_lessthan(p_size, size))\n\t\t__write_overflow();\n\tif (p_size < size)\n\t\tfortify_panic(__func__);\n\treturn __underlying_strncpy(p, q, size);\n}\n\nextern __kernel_size_t __real_strnlen(const char *, __kernel_size_t) __RENAME(strnlen);\n \n__FORTIFY_INLINE __kernel_size_t strnlen(const char * const POS p, __kernel_size_t maxlen)\n{\n\tconst size_t p_size = __member_size(p);\n\tconst size_t p_len = __compiletime_strlen(p);\n\tsize_t ret;\n\n\t \n\tif (__builtin_constant_p(maxlen) && p_len != SIZE_MAX) {\n\t\t \n\t\tif (maxlen >= p_size)\n\t\t\treturn p_len;\n\t}\n\n\t \n\tret = __real_strnlen(p, maxlen < p_size ? maxlen : p_size);\n\tif (p_size <= ret && maxlen != ret)\n\t\tfortify_panic(__func__);\n\treturn ret;\n}\n\n \n \n#define strlen(p)\t\t\t\t\t\t\t\\\n\t__builtin_choose_expr(__is_constexpr(__builtin_strlen(p)),\t\\\n\t\t__builtin_strlen(p), __fortify_strlen(p))\n__FORTIFY_INLINE __diagnose_as(__builtin_strlen, 1)\n__kernel_size_t __fortify_strlen(const char * const POS p)\n{\n\tconst size_t p_size = __member_size(p);\n\t__kernel_size_t ret;\n\n\t \n\tif (p_size == SIZE_MAX)\n\t\treturn __underlying_strlen(p);\n\tret = strnlen(p, p_size);\n\tif (p_size <= ret)\n\t\tfortify_panic(__func__);\n\treturn ret;\n}\n\n \nextern size_t __real_strlcpy(char *, const char *, size_t) __RENAME(strlcpy);\n \n__FORTIFY_INLINE size_t strlcpy(char * const POS p, const char * const POS q, size_t size)\n{\n\tconst size_t p_size = __member_size(p);\n\tconst size_t q_size = __member_size(q);\n\tsize_t q_len;\t \n\tsize_t len;\t \n\n\tif (p_size == SIZE_MAX && q_size == SIZE_MAX)\n\t\treturn __real_strlcpy(p, q, size);\n\tq_len = strlen(q);\n\tlen = (q_len >= size) ? size - 1 : q_len;\n\tif (__builtin_constant_p(size) && __builtin_constant_p(q_len) && size) {\n\t\t \n\t\tif (len >= p_size)\n\t\t\t__write_overflow();\n\t}\n\tif (size) {\n\t\tif (len >= p_size)\n\t\t\tfortify_panic(__func__);\n\t\t__underlying_memcpy(p, q, len);\n\t\tp[len] = '\\0';\n\t}\n\treturn q_len;\n}\n\n \nextern ssize_t __real_strscpy(char *, const char *, size_t) __RENAME(strscpy);\n \n__FORTIFY_INLINE ssize_t strscpy(char * const POS p, const char * const POS q, size_t size)\n{\n\t \n\tconst size_t p_size = __member_size(p);\n\tconst size_t q_size = __member_size(q);\n\tsize_t len;\n\n\t \n\tif (p_size == SIZE_MAX && q_size == SIZE_MAX)\n\t\treturn __real_strscpy(p, q, size);\n\n\t \n\tif (__compiletime_lessthan(p_size, size))\n\t\t__write_overflow();\n\n\t \n\tif (__compiletime_lessthan(p_size, SIZE_MAX)) {\n\t\tlen = __compiletime_strlen(q);\n\n\t\tif (len < SIZE_MAX && __compiletime_lessthan(len, size)) {\n\t\t\t__underlying_memcpy(p, q, len + 1);\n\t\t\treturn len;\n\t\t}\n\t}\n\n\t \n\tlen = strnlen(q, size);\n\t \n\tlen = len == size ? size : len + 1;\n\n\t \n\tif (len > p_size)\n\t\tfortify_panic(__func__);\n\n\t \n\treturn __real_strscpy(p, q, len);\n}\n\n \nextern size_t __real_strlcat(char *p, const char *q, size_t avail) __RENAME(strlcat);\n \n__FORTIFY_INLINE\nsize_t strlcat(char * const POS p, const char * const POS q, size_t avail)\n{\n\tconst size_t p_size = __member_size(p);\n\tconst size_t q_size = __member_size(q);\n\tsize_t p_len, copy_len;\n\tsize_t actual, wanted;\n\n\t \n\tif (p_size == SIZE_MAX && q_size == SIZE_MAX)\n\t\treturn __real_strlcat(p, q, avail);\n\n\tp_len = strnlen(p, avail);\n\tcopy_len = strlen(q);\n\twanted = actual = p_len + copy_len;\n\n\t \n\tif (avail <= p_len)\n\t\treturn wanted;\n\n\t \n\tif (p_size <= p_len)\n\t\tfortify_panic(__func__);\n\n\tif (actual >= avail) {\n\t\tcopy_len = avail - p_len - 1;\n\t\tactual = p_len + copy_len;\n\t}\n\n\t \n\tif (p_size <= actual)\n\t\tfortify_panic(__func__);\n\t__underlying_memcpy(p + p_len, q, copy_len);\n\tp[actual] = '\\0';\n\n\treturn wanted;\n}\n\n \n \n__FORTIFY_INLINE __diagnose_as(__builtin_strcat, 1, 2)\nchar *strcat(char * const POS p, const char *q)\n{\n\tconst size_t p_size = __member_size(p);\n\n\tif (strlcat(p, q, p_size) >= p_size)\n\t\tfortify_panic(__func__);\n\treturn p;\n}\n\n \n \n__FORTIFY_INLINE __diagnose_as(__builtin_strncat, 1, 2, 3)\nchar *strncat(char * const POS p, const char * const POS q, __kernel_size_t count)\n{\n\tconst size_t p_size = __member_size(p);\n\tconst size_t q_size = __member_size(q);\n\tsize_t p_len, copy_len;\n\n\tif (p_size == SIZE_MAX && q_size == SIZE_MAX)\n\t\treturn __underlying_strncat(p, q, count);\n\tp_len = strlen(p);\n\tcopy_len = strnlen(q, count);\n\tif (p_size < p_len + copy_len + 1)\n\t\tfortify_panic(__func__);\n\t__underlying_memcpy(p + p_len, q, copy_len);\n\tp[p_len + copy_len] = '\\0';\n\treturn p;\n}\n\n__FORTIFY_INLINE void fortify_memset_chk(__kernel_size_t size,\n\t\t\t\t\t const size_t p_size,\n\t\t\t\t\t const size_t p_size_field)\n{\n\tif (__builtin_constant_p(size)) {\n\t\t \n\n\t\t \n\t\tif (__compiletime_lessthan(p_size_field, p_size) &&\n\t\t    __compiletime_lessthan(p_size, size))\n\t\t\t__write_overflow();\n\n\t\t \n\t\tif (__compiletime_lessthan(p_size_field, size))\n\t\t\t__write_overflow_field(p_size_field, size);\n\t}\n\t \n\n\t \n\tif (p_size != SIZE_MAX && p_size < size)\n\t\tfortify_panic(\"memset\");\n}\n\n#define __fortify_memset_chk(p, c, size, p_size, p_size_field) ({\t\\\n\tsize_t __fortify_size = (size_t)(size);\t\t\t\t\\\n\tfortify_memset_chk(__fortify_size, p_size, p_size_field),\t\\\n\t__underlying_memset(p, c, __fortify_size);\t\t\t\\\n})\n\n \n#ifndef CONFIG_KMSAN\n#define memset(p, c, s) __fortify_memset_chk(p, c, s,\t\t\t\\\n\t\t__struct_size(p), __member_size(p))\n#endif\n\n \n__FORTIFY_INLINE bool fortify_memcpy_chk(__kernel_size_t size,\n\t\t\t\t\t const size_t p_size,\n\t\t\t\t\t const size_t q_size,\n\t\t\t\t\t const size_t p_size_field,\n\t\t\t\t\t const size_t q_size_field,\n\t\t\t\t\t const char *func)\n{\n\tif (__builtin_constant_p(size)) {\n\t\t \n\n\t\t \n\t\tif (__compiletime_lessthan(p_size_field, p_size) &&\n\t\t    __compiletime_lessthan(p_size, size))\n\t\t\t__write_overflow();\n\t\tif (__compiletime_lessthan(q_size_field, q_size) &&\n\t\t    __compiletime_lessthan(q_size, size))\n\t\t\t__read_overflow2();\n\n\t\t \n\t\tif (__compiletime_lessthan(p_size_field, size))\n\t\t\t__write_overflow_field(p_size_field, size);\n\t\t \n\t\tif ((IS_ENABLED(KBUILD_EXTRA_WARN1) ||\n\t\t     __compiletime_lessthan(p_size_field, size)) &&\n\t\t    __compiletime_lessthan(q_size_field, size))\n\t\t\t__read_overflow2_field(q_size_field, size);\n\t}\n\t \n\n\t \n\tif ((p_size != SIZE_MAX && p_size < size) ||\n\t    (q_size != SIZE_MAX && q_size < size))\n\t\tfortify_panic(func);\n\n\t \n\tif (p_size_field != 0 && p_size_field != SIZE_MAX &&\n\t    p_size != p_size_field && p_size_field < size)\n\t\treturn true;\n\n\treturn false;\n}\n\n#define __fortify_memcpy_chk(p, q, size, p_size, q_size,\t\t\\\n\t\t\t     p_size_field, q_size_field, op) ({\t\t\\\n\tconst size_t __fortify_size = (size_t)(size);\t\t\t\\\n\tconst size_t __p_size = (p_size);\t\t\t\t\\\n\tconst size_t __q_size = (q_size);\t\t\t\t\\\n\tconst size_t __p_size_field = (p_size_field);\t\t\t\\\n\tconst size_t __q_size_field = (q_size_field);\t\t\t\\\n\tWARN_ONCE(fortify_memcpy_chk(__fortify_size, __p_size,\t\t\\\n\t\t\t\t     __q_size, __p_size_field,\t\t\\\n\t\t\t\t     __q_size_field, #op),\t\t\\\n\t\t  #op \": detected field-spanning write (size %zu) of single %s (size %zu)\\n\", \\\n\t\t  __fortify_size,\t\t\t\t\t\\\n\t\t  \"field \\\"\" #p \"\\\" at \" __FILE__ \":\" __stringify(__LINE__), \\\n\t\t  __p_size_field);\t\t\t\t\t\\\n\t__underlying_##op(p, q, __fortify_size);\t\t\t\\\n})\n\n \n\n \n#define memcpy(p, q, s)  __fortify_memcpy_chk(p, q, s,\t\t\t\\\n\t\t__struct_size(p), __struct_size(q),\t\t\t\\\n\t\t__member_size(p), __member_size(q),\t\t\t\\\n\t\tmemcpy)\n#define memmove(p, q, s)  __fortify_memcpy_chk(p, q, s,\t\t\t\\\n\t\t__struct_size(p), __struct_size(q),\t\t\t\\\n\t\t__member_size(p), __member_size(q),\t\t\t\\\n\t\tmemmove)\n\nextern void *__real_memscan(void *, int, __kernel_size_t) __RENAME(memscan);\n__FORTIFY_INLINE void *memscan(void * const POS0 p, int c, __kernel_size_t size)\n{\n\tconst size_t p_size = __struct_size(p);\n\n\tif (__compiletime_lessthan(p_size, size))\n\t\t__read_overflow();\n\tif (p_size < size)\n\t\tfortify_panic(__func__);\n\treturn __real_memscan(p, c, size);\n}\n\n__FORTIFY_INLINE __diagnose_as(__builtin_memcmp, 1, 2, 3)\nint memcmp(const void * const POS0 p, const void * const POS0 q, __kernel_size_t size)\n{\n\tconst size_t p_size = __struct_size(p);\n\tconst size_t q_size = __struct_size(q);\n\n\tif (__builtin_constant_p(size)) {\n\t\tif (__compiletime_lessthan(p_size, size))\n\t\t\t__read_overflow();\n\t\tif (__compiletime_lessthan(q_size, size))\n\t\t\t__read_overflow2();\n\t}\n\tif (p_size < size || q_size < size)\n\t\tfortify_panic(__func__);\n\treturn __underlying_memcmp(p, q, size);\n}\n\n__FORTIFY_INLINE __diagnose_as(__builtin_memchr, 1, 2, 3)\nvoid *memchr(const void * const POS0 p, int c, __kernel_size_t size)\n{\n\tconst size_t p_size = __struct_size(p);\n\n\tif (__compiletime_lessthan(p_size, size))\n\t\t__read_overflow();\n\tif (p_size < size)\n\t\tfortify_panic(__func__);\n\treturn __underlying_memchr(p, c, size);\n}\n\nvoid *__real_memchr_inv(const void *s, int c, size_t n) __RENAME(memchr_inv);\n__FORTIFY_INLINE void *memchr_inv(const void * const POS0 p, int c, size_t size)\n{\n\tconst size_t p_size = __struct_size(p);\n\n\tif (__compiletime_lessthan(p_size, size))\n\t\t__read_overflow();\n\tif (p_size < size)\n\t\tfortify_panic(__func__);\n\treturn __real_memchr_inv(p, c, size);\n}\n\nextern void *__real_kmemdup(const void *src, size_t len, gfp_t gfp) __RENAME(kmemdup)\n\t\t\t\t\t\t\t\t    __realloc_size(2);\n__FORTIFY_INLINE void *kmemdup(const void * const POS0 p, size_t size, gfp_t gfp)\n{\n\tconst size_t p_size = __struct_size(p);\n\n\tif (__compiletime_lessthan(p_size, size))\n\t\t__read_overflow();\n\tif (p_size < size)\n\t\tfortify_panic(__func__);\n\treturn __real_kmemdup(p, size, gfp);\n}\n\n \n \n__FORTIFY_INLINE __diagnose_as(__builtin_strcpy, 1, 2)\nchar *strcpy(char * const POS p, const char * const POS q)\n{\n\tconst size_t p_size = __member_size(p);\n\tconst size_t q_size = __member_size(q);\n\tsize_t size;\n\n\t \n\tif (__builtin_constant_p(p_size) &&\n\t    __builtin_constant_p(q_size) &&\n\t    p_size == SIZE_MAX && q_size == SIZE_MAX)\n\t\treturn __underlying_strcpy(p, q);\n\tsize = strlen(q) + 1;\n\t \n\tif (__compiletime_lessthan(p_size, size))\n\t\t__write_overflow();\n\t \n\tif (p_size < size)\n\t\tfortify_panic(__func__);\n\t__underlying_memcpy(p, q, size);\n\treturn p;\n}\n\n \n#undef __underlying_memchr\n#undef __underlying_memcmp\n#undef __underlying_strcat\n#undef __underlying_strcpy\n#undef __underlying_strlen\n#undef __underlying_strncat\n#undef __underlying_strncpy\n\n#undef POS\n#undef POS0\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}