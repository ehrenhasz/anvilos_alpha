{
  "module_name": "if_macvlan.h",
  "hash_id": "b8a3a4edec5cb3adbfdffbd7fbe3518705907ec98a57ae7fa45c273a8effbc79",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/if_macvlan.h",
  "human_readable_source": " \n#ifndef _LINUX_IF_MACVLAN_H\n#define _LINUX_IF_MACVLAN_H\n\n#include <linux/if_link.h>\n#include <linux/if_vlan.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <net/netlink.h>\n#include <linux/u64_stats_sync.h>\n\nstruct macvlan_port;\n\n#define MACVLAN_MC_FILTER_BITS\t8\n#define MACVLAN_MC_FILTER_SZ\t(1 << MACVLAN_MC_FILTER_BITS)\n\nstruct macvlan_dev {\n\tstruct net_device\t*dev;\n\tstruct list_head\tlist;\n\tstruct hlist_node\thlist;\n\tstruct macvlan_port\t*port;\n\tstruct net_device\t*lowerdev;\n\tnetdevice_tracker\tdev_tracker;\n\tvoid\t\t\t*accel_priv;\n\tstruct vlan_pcpu_stats __percpu *pcpu_stats;\n\n\tDECLARE_BITMAP(mc_filter, MACVLAN_MC_FILTER_SZ);\n\n\tnetdev_features_t\tset_features;\n\tenum macvlan_mode\tmode;\n\tu16\t\t\tflags;\n\tunsigned int\t\tmacaddr_count;\n\tu32\t\t\tbc_queue_len_req;\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\tstruct netpoll\t\t*netpoll;\n#endif\n};\n\nstatic inline void macvlan_count_rx(const struct macvlan_dev *vlan,\n\t\t\t\t    unsigned int len, bool success,\n\t\t\t\t    bool multicast)\n{\n\tif (likely(success)) {\n\t\tstruct vlan_pcpu_stats *pcpu_stats;\n\n\t\tpcpu_stats = get_cpu_ptr(vlan->pcpu_stats);\n\t\tu64_stats_update_begin(&pcpu_stats->syncp);\n\t\tu64_stats_inc(&pcpu_stats->rx_packets);\n\t\tu64_stats_add(&pcpu_stats->rx_bytes, len);\n\t\tif (multicast)\n\t\t\tu64_stats_inc(&pcpu_stats->rx_multicast);\n\t\tu64_stats_update_end(&pcpu_stats->syncp);\n\t\tput_cpu_ptr(vlan->pcpu_stats);\n\t} else {\n\t\tthis_cpu_inc(vlan->pcpu_stats->rx_errors);\n\t}\n}\n\nextern void macvlan_common_setup(struct net_device *dev);\n\nextern int macvlan_common_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t\t  struct nlattr *tb[], struct nlattr *data[],\n\t\t\t\t  struct netlink_ext_ack *extack);\n\nextern void macvlan_dellink(struct net_device *dev, struct list_head *head);\n\nextern int macvlan_link_register(struct rtnl_link_ops *ops);\n\n#if IS_ENABLED(CONFIG_MACVLAN)\nstatic inline struct net_device *\nmacvlan_dev_real_dev(const struct net_device *dev)\n{\n\tstruct macvlan_dev *macvlan = netdev_priv(dev);\n\n\treturn macvlan->lowerdev;\n}\n#else\nstatic inline struct net_device *\nmacvlan_dev_real_dev(const struct net_device *dev)\n{\n\tBUG();\n\treturn NULL;\n}\n#endif\n\nstatic inline void *macvlan_accel_priv(struct net_device *dev)\n{\n\tstruct macvlan_dev *macvlan = netdev_priv(dev);\n\n\treturn macvlan->accel_priv;\n}\n\nstatic inline bool macvlan_supports_dest_filter(struct net_device *dev)\n{\n\tstruct macvlan_dev *macvlan = netdev_priv(dev);\n\n\treturn macvlan->mode == MACVLAN_MODE_PRIVATE ||\n\t       macvlan->mode == MACVLAN_MODE_VEPA ||\n\t       macvlan->mode == MACVLAN_MODE_BRIDGE;\n}\n\nstatic inline int macvlan_release_l2fw_offload(struct net_device *dev)\n{\n\tstruct macvlan_dev *macvlan = netdev_priv(dev);\n\n\tmacvlan->accel_priv = NULL;\n\treturn dev_uc_add(macvlan->lowerdev, dev->dev_addr);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}