{
  "module_name": "cs5535.h",
  "hash_id": "a003c948ce9a2cf6fd939727cd609a2aea43536f350d57c7bbbb0ce12c6215ff",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/cs5535.h",
  "human_readable_source": " \n \n\n#ifndef _CS5535_H\n#define _CS5535_H\n\n#include <asm/msr.h>\n\n \n#define MSR_GLIU_P2D_RO0\t0x10000029\n\n#define MSR_LX_GLD_MSR_CONFIG\t0x48002001\n#define MSR_LX_MSR_PADSEL\t0x48002011\t \n#define MSR_GLCP_SYS_RSTPLL\t0x4C000014\n#define MSR_GLCP_DOTPLL\t\t0x4C000015\n\n#define MSR_LBAR_SMB\t\t0x5140000B\n#define MSR_LBAR_GPIO\t\t0x5140000C\n#define MSR_LBAR_MFGPT\t\t0x5140000D\n#define MSR_LBAR_ACPI\t\t0x5140000E\n#define MSR_LBAR_PMS\t\t0x5140000F\n\n#define MSR_DIVIL_SOFT_RESET\t0x51400017\n\n#define MSR_PIC_YSEL_LOW\t0x51400020\n#define MSR_PIC_YSEL_HIGH\t0x51400021\n#define MSR_PIC_ZSEL_LOW\t0x51400022\n#define MSR_PIC_ZSEL_HIGH\t0x51400023\n#define MSR_PIC_IRQM_LPC\t0x51400025\n\n#define MSR_MFGPT_IRQ\t\t0x51400028\n#define MSR_MFGPT_NR\t\t0x51400029\n#define MSR_MFGPT_SETUP\t\t0x5140002B\n\n#define MSR_RTC_DOMA_OFFSET\t0x51400055\n#define MSR_RTC_MONA_OFFSET\t0x51400056\n#define MSR_RTC_CEN_OFFSET\t0x51400057\n\n#define MSR_LX_SPARE_MSR\t0x80000011\t \n\n#define MSR_GX_GLD_MSR_CONFIG\t0xC0002001\n#define MSR_GX_MSR_PADSEL\t0xC0002011\n\nstatic inline int cs5535_pic_unreqz_select_high(unsigned int group,\n\t\t\t\t\t\tunsigned int irq)\n{\n\tuint32_t lo, hi;\n\n\trdmsr(MSR_PIC_ZSEL_HIGH, lo, hi);\n\tlo &= ~(0xF << (group * 4));\n\tlo |= (irq & 0xF) << (group * 4);\n\twrmsr(MSR_PIC_ZSEL_HIGH, lo, hi);\n\treturn 0;\n}\n\n \n#define CS5536_PIC_INT_SEL1\t0x4d0\n#define CS5536_PIC_INT_SEL2\t0x4d1\n\n \n#define LBAR_GPIO_SIZE\t\t0xFF\n#define LBAR_MFGPT_SIZE\t\t0x40\n#define LBAR_ACPI_SIZE\t\t0x40\n#define LBAR_PMS_SIZE\t\t0x80\n\n \n#define CS5536_PM_SCLK\t\t0x10\n#define CS5536_PM_IN_SLPCTL\t0x20\n#define CS5536_PM_WKXD\t\t0x34\n#define CS5536_PM_WKD\t\t0x30\n#define CS5536_PM_SSC\t\t0x54\n\n \n#define CS5536_PM1_STS\t\t0x00\n#define CS5536_PM1_EN\t\t0x02\n#define CS5536_PM1_CNT\t\t0x08\n#define CS5536_PM_GPE0_STS\t0x18\n#define CS5536_PM_GPE0_EN\t0x1c\n\n \n#define CS5536_WAK_FLAG\t\t(1 << 15)\n#define CS5536_RTC_FLAG\t\t(1 << 10)\n#define CS5536_PWRBTN_FLAG\t(1 << 8)\n\n \n#define CS5536_PM_PWRBTN\t(1 << 8)\n#define CS5536_PM_RTC\t\t(1 << 10)\n\n \n#define CS5536_GPIOM7_PME_FLAG\t(1 << 31)\n#define CS5536_GPIOM6_PME_FLAG\t(1 << 30)\n\n \n#define CS5536_GPIOM7_PME_EN\t(1 << 31)\n#define CS5536_GPIOM6_PME_EN\t(1 << 30)\n\n \n#define VSA_VRC_INDEX\t\t0xAC1C\n#define VSA_VRC_DATA\t\t0xAC1E\n#define VSA_VR_UNLOCK\t\t0xFC53   \n#define VSA_VR_SIGNATURE\t0x0003\n#define VSA_VR_MEM_SIZE\t\t0x0200\n#define AMD_VSA_SIG\t\t0x4132   \n#define GSW_VSA_SIG\t\t0x534d   \n\n#include <linux/io.h>\n\nstatic inline int cs5535_has_vsa2(void)\n{\n\tstatic int has_vsa2 = -1;\n\n\tif (has_vsa2 == -1) {\n\t\tuint16_t val;\n\n\t\t \n\t\toutw(VSA_VR_UNLOCK, VSA_VRC_INDEX);\n\t\toutw(VSA_VR_SIGNATURE, VSA_VRC_INDEX);\n\n\t\tval = inw(VSA_VRC_DATA);\n\t\thas_vsa2 = (val == AMD_VSA_SIG || val == GSW_VSA_SIG);\n\t}\n\n\treturn has_vsa2;\n}\n\n \n#define GPIO_OUTPUT_VAL\t\t0x00\n#define GPIO_OUTPUT_ENABLE\t0x04\n#define GPIO_OUTPUT_OPEN_DRAIN\t0x08\n#define GPIO_OUTPUT_INVERT\t0x0C\n#define GPIO_OUTPUT_AUX1\t0x10\n#define GPIO_OUTPUT_AUX2\t0x14\n#define GPIO_PULL_UP\t\t0x18\n#define GPIO_PULL_DOWN\t\t0x1C\n#define GPIO_INPUT_ENABLE\t0x20\n#define GPIO_INPUT_INVERT\t0x24\n#define GPIO_INPUT_FILTER\t0x28\n#define GPIO_INPUT_EVENT_COUNT\t0x2C\n#define GPIO_READ_BACK\t\t0x30\n#define GPIO_INPUT_AUX1\t\t0x34\n#define GPIO_EVENTS_ENABLE\t0x38\n#define GPIO_LOCK_ENABLE\t0x3C\n#define GPIO_POSITIVE_EDGE_EN\t0x40\n#define GPIO_NEGATIVE_EDGE_EN\t0x44\n#define GPIO_POSITIVE_EDGE_STS\t0x48\n#define GPIO_NEGATIVE_EDGE_STS\t0x4C\n\n#define GPIO_FLTR7_AMOUNT\t0xD8\n\n#define GPIO_MAP_X\t\t0xE0\n#define GPIO_MAP_Y\t\t0xE4\n#define GPIO_MAP_Z\t\t0xE8\n#define GPIO_MAP_W\t\t0xEC\n\n#define GPIO_FE7_SEL\t\t0xF7\n\nvoid cs5535_gpio_set(unsigned offset, unsigned int reg);\nvoid cs5535_gpio_clear(unsigned offset, unsigned int reg);\nint cs5535_gpio_isset(unsigned offset, unsigned int reg);\nint cs5535_gpio_set_irq(unsigned group, unsigned irq);\nvoid cs5535_gpio_setup_event(unsigned offset, int pair, int pme);\n\n \n\n#define MFGPT_MAX_TIMERS\t8\n#define MFGPT_TIMER_ANY\t\t(-1)\n\n#define MFGPT_DOMAIN_WORKING\t1\n#define MFGPT_DOMAIN_STANDBY\t2\n#define MFGPT_DOMAIN_ANY\t(MFGPT_DOMAIN_WORKING | MFGPT_DOMAIN_STANDBY)\n\n#define MFGPT_CMP1\t\t0\n#define MFGPT_CMP2\t\t1\n\n#define MFGPT_EVENT_IRQ\t\t0\n#define MFGPT_EVENT_NMI\t\t1\n#define MFGPT_EVENT_RESET\t3\n\n#define MFGPT_REG_CMP1\t\t0\n#define MFGPT_REG_CMP2\t\t2\n#define MFGPT_REG_COUNTER\t4\n#define MFGPT_REG_SETUP\t\t6\n\n#define MFGPT_SETUP_CNTEN\t(1 << 15)\n#define MFGPT_SETUP_CMP2\t(1 << 14)\n#define MFGPT_SETUP_CMP1\t(1 << 13)\n#define MFGPT_SETUP_SETUP\t(1 << 12)\n#define MFGPT_SETUP_STOPEN\t(1 << 11)\n#define MFGPT_SETUP_EXTEN\t(1 << 10)\n#define MFGPT_SETUP_REVEN\t(1 << 5)\n#define MFGPT_SETUP_CLKSEL\t(1 << 4)\n\nstruct cs5535_mfgpt_timer;\n\nextern uint16_t cs5535_mfgpt_read(struct cs5535_mfgpt_timer *timer,\n\t\tuint16_t reg);\nextern void cs5535_mfgpt_write(struct cs5535_mfgpt_timer *timer, uint16_t reg,\n\t\tuint16_t value);\n\nextern int cs5535_mfgpt_toggle_event(struct cs5535_mfgpt_timer *timer, int cmp,\n\t\tint event, int enable);\nextern int cs5535_mfgpt_set_irq(struct cs5535_mfgpt_timer *timer, int cmp,\n\t\tint *irq, int enable);\nextern struct cs5535_mfgpt_timer *cs5535_mfgpt_alloc_timer(int timer,\n\t\tint domain);\nextern void cs5535_mfgpt_free_timer(struct cs5535_mfgpt_timer *timer);\n\nstatic inline int cs5535_mfgpt_setup_irq(struct cs5535_mfgpt_timer *timer,\n\t\tint cmp, int *irq)\n{\n\treturn cs5535_mfgpt_set_irq(timer, cmp, irq, 1);\n}\n\nstatic inline int cs5535_mfgpt_release_irq(struct cs5535_mfgpt_timer *timer,\n\t\tint cmp, int *irq)\n{\n\treturn cs5535_mfgpt_set_irq(timer, cmp, irq, 0);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}