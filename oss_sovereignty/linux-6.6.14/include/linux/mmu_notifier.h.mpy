{
  "module_name": "mmu_notifier.h",
  "hash_id": "63c65f13a42ded2f3f80c1429bfcfb7f6b6811b97ec0fb60e105cb6cfabb4da9",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mmu_notifier.h",
  "human_readable_source": " \n#ifndef _LINUX_MMU_NOTIFIER_H\n#define _LINUX_MMU_NOTIFIER_H\n\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mm_types.h>\n#include <linux/mmap_lock.h>\n#include <linux/srcu.h>\n#include <linux/interval_tree.h>\n\nstruct mmu_notifier_subscriptions;\nstruct mmu_notifier;\nstruct mmu_notifier_range;\nstruct mmu_interval_notifier;\n\n \nenum mmu_notifier_event {\n\tMMU_NOTIFY_UNMAP = 0,\n\tMMU_NOTIFY_CLEAR,\n\tMMU_NOTIFY_PROTECTION_VMA,\n\tMMU_NOTIFY_PROTECTION_PAGE,\n\tMMU_NOTIFY_SOFT_DIRTY,\n\tMMU_NOTIFY_RELEASE,\n\tMMU_NOTIFY_MIGRATE,\n\tMMU_NOTIFY_EXCLUSIVE,\n};\n\n#define MMU_NOTIFIER_RANGE_BLOCKABLE (1 << 0)\n\nstruct mmu_notifier_ops {\n\t \n\tvoid (*release)(struct mmu_notifier *subscription,\n\t\t\tstruct mm_struct *mm);\n\n\t \n\tint (*clear_flush_young)(struct mmu_notifier *subscription,\n\t\t\t\t struct mm_struct *mm,\n\t\t\t\t unsigned long start,\n\t\t\t\t unsigned long end);\n\n\t \n\tint (*clear_young)(struct mmu_notifier *subscription,\n\t\t\t   struct mm_struct *mm,\n\t\t\t   unsigned long start,\n\t\t\t   unsigned long end);\n\n\t \n\tint (*test_young)(struct mmu_notifier *subscription,\n\t\t\t  struct mm_struct *mm,\n\t\t\t  unsigned long address);\n\n\t \n\tvoid (*change_pte)(struct mmu_notifier *subscription,\n\t\t\t   struct mm_struct *mm,\n\t\t\t   unsigned long address,\n\t\t\t   pte_t pte);\n\n\t \n\tint (*invalidate_range_start)(struct mmu_notifier *subscription,\n\t\t\t\t      const struct mmu_notifier_range *range);\n\tvoid (*invalidate_range_end)(struct mmu_notifier *subscription,\n\t\t\t\t     const struct mmu_notifier_range *range);\n\n\t \n\tvoid (*arch_invalidate_secondary_tlbs)(\n\t\t\t\t\tstruct mmu_notifier *subscription,\n\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end);\n\n\t \n\tstruct mmu_notifier *(*alloc_notifier)(struct mm_struct *mm);\n\tvoid (*free_notifier)(struct mmu_notifier *subscription);\n};\n\n \nstruct mmu_notifier {\n\tstruct hlist_node hlist;\n\tconst struct mmu_notifier_ops *ops;\n\tstruct mm_struct *mm;\n\tstruct rcu_head rcu;\n\tunsigned int users;\n};\n\n \nstruct mmu_interval_notifier_ops {\n\tbool (*invalidate)(struct mmu_interval_notifier *interval_sub,\n\t\t\t   const struct mmu_notifier_range *range,\n\t\t\t   unsigned long cur_seq);\n};\n\nstruct mmu_interval_notifier {\n\tstruct interval_tree_node interval_tree;\n\tconst struct mmu_interval_notifier_ops *ops;\n\tstruct mm_struct *mm;\n\tstruct hlist_node deferred_item;\n\tunsigned long invalidate_seq;\n};\n\n#ifdef CONFIG_MMU_NOTIFIER\n\n#ifdef CONFIG_LOCKDEP\nextern struct lockdep_map __mmu_notifier_invalidate_range_start_map;\n#endif\n\nstruct mmu_notifier_range {\n\tstruct mm_struct *mm;\n\tunsigned long start;\n\tunsigned long end;\n\tunsigned flags;\n\tenum mmu_notifier_event event;\n\tvoid *owner;\n};\n\nstatic inline int mm_has_notifiers(struct mm_struct *mm)\n{\n\treturn unlikely(mm->notifier_subscriptions);\n}\n\nstruct mmu_notifier *mmu_notifier_get_locked(const struct mmu_notifier_ops *ops,\n\t\t\t\t\t     struct mm_struct *mm);\nstatic inline struct mmu_notifier *\nmmu_notifier_get(const struct mmu_notifier_ops *ops, struct mm_struct *mm)\n{\n\tstruct mmu_notifier *ret;\n\n\tmmap_write_lock(mm);\n\tret = mmu_notifier_get_locked(ops, mm);\n\tmmap_write_unlock(mm);\n\treturn ret;\n}\nvoid mmu_notifier_put(struct mmu_notifier *subscription);\nvoid mmu_notifier_synchronize(void);\n\nextern int mmu_notifier_register(struct mmu_notifier *subscription,\n\t\t\t\t struct mm_struct *mm);\nextern int __mmu_notifier_register(struct mmu_notifier *subscription,\n\t\t\t\t   struct mm_struct *mm);\nextern void mmu_notifier_unregister(struct mmu_notifier *subscription,\n\t\t\t\t    struct mm_struct *mm);\n\nunsigned long\nmmu_interval_read_begin(struct mmu_interval_notifier *interval_sub);\nint mmu_interval_notifier_insert(struct mmu_interval_notifier *interval_sub,\n\t\t\t\t struct mm_struct *mm, unsigned long start,\n\t\t\t\t unsigned long length,\n\t\t\t\t const struct mmu_interval_notifier_ops *ops);\nint mmu_interval_notifier_insert_locked(\n\tstruct mmu_interval_notifier *interval_sub, struct mm_struct *mm,\n\tunsigned long start, unsigned long length,\n\tconst struct mmu_interval_notifier_ops *ops);\nvoid mmu_interval_notifier_remove(struct mmu_interval_notifier *interval_sub);\n\n \nstatic inline void\nmmu_interval_set_seq(struct mmu_interval_notifier *interval_sub,\n\t\t     unsigned long cur_seq)\n{\n\tWRITE_ONCE(interval_sub->invalidate_seq, cur_seq);\n}\n\n \nstatic inline bool\nmmu_interval_read_retry(struct mmu_interval_notifier *interval_sub,\n\t\t\tunsigned long seq)\n{\n\treturn interval_sub->invalidate_seq != seq;\n}\n\n \nstatic inline bool\nmmu_interval_check_retry(struct mmu_interval_notifier *interval_sub,\n\t\t\t unsigned long seq)\n{\n\t \n\treturn READ_ONCE(interval_sub->invalidate_seq) != seq;\n}\n\nextern void __mmu_notifier_subscriptions_destroy(struct mm_struct *mm);\nextern void __mmu_notifier_release(struct mm_struct *mm);\nextern int __mmu_notifier_clear_flush_young(struct mm_struct *mm,\n\t\t\t\t\t  unsigned long start,\n\t\t\t\t\t  unsigned long end);\nextern int __mmu_notifier_clear_young(struct mm_struct *mm,\n\t\t\t\t      unsigned long start,\n\t\t\t\t      unsigned long end);\nextern int __mmu_notifier_test_young(struct mm_struct *mm,\n\t\t\t\t     unsigned long address);\nextern void __mmu_notifier_change_pte(struct mm_struct *mm,\n\t\t\t\t      unsigned long address, pte_t pte);\nextern int __mmu_notifier_invalidate_range_start(struct mmu_notifier_range *r);\nextern void __mmu_notifier_invalidate_range_end(struct mmu_notifier_range *r);\nextern void __mmu_notifier_arch_invalidate_secondary_tlbs(struct mm_struct *mm,\n\t\t\t\t\tunsigned long start, unsigned long end);\nextern bool\nmmu_notifier_range_update_to_read_only(const struct mmu_notifier_range *range);\n\nstatic inline bool\nmmu_notifier_range_blockable(const struct mmu_notifier_range *range)\n{\n\treturn (range->flags & MMU_NOTIFIER_RANGE_BLOCKABLE);\n}\n\nstatic inline void mmu_notifier_release(struct mm_struct *mm)\n{\n\tif (mm_has_notifiers(mm))\n\t\t__mmu_notifier_release(mm);\n}\n\nstatic inline int mmu_notifier_clear_flush_young(struct mm_struct *mm,\n\t\t\t\t\t  unsigned long start,\n\t\t\t\t\t  unsigned long end)\n{\n\tif (mm_has_notifiers(mm))\n\t\treturn __mmu_notifier_clear_flush_young(mm, start, end);\n\treturn 0;\n}\n\nstatic inline int mmu_notifier_clear_young(struct mm_struct *mm,\n\t\t\t\t\t   unsigned long start,\n\t\t\t\t\t   unsigned long end)\n{\n\tif (mm_has_notifiers(mm))\n\t\treturn __mmu_notifier_clear_young(mm, start, end);\n\treturn 0;\n}\n\nstatic inline int mmu_notifier_test_young(struct mm_struct *mm,\n\t\t\t\t\t  unsigned long address)\n{\n\tif (mm_has_notifiers(mm))\n\t\treturn __mmu_notifier_test_young(mm, address);\n\treturn 0;\n}\n\nstatic inline void mmu_notifier_change_pte(struct mm_struct *mm,\n\t\t\t\t\t   unsigned long address, pte_t pte)\n{\n\tif (mm_has_notifiers(mm))\n\t\t__mmu_notifier_change_pte(mm, address, pte);\n}\n\nstatic inline void\nmmu_notifier_invalidate_range_start(struct mmu_notifier_range *range)\n{\n\tmight_sleep();\n\n\tlock_map_acquire(&__mmu_notifier_invalidate_range_start_map);\n\tif (mm_has_notifiers(range->mm)) {\n\t\trange->flags |= MMU_NOTIFIER_RANGE_BLOCKABLE;\n\t\t__mmu_notifier_invalidate_range_start(range);\n\t}\n\tlock_map_release(&__mmu_notifier_invalidate_range_start_map);\n}\n\nstatic inline int\nmmu_notifier_invalidate_range_start_nonblock(struct mmu_notifier_range *range)\n{\n\tint ret = 0;\n\n\tlock_map_acquire(&__mmu_notifier_invalidate_range_start_map);\n\tif (mm_has_notifiers(range->mm)) {\n\t\trange->flags &= ~MMU_NOTIFIER_RANGE_BLOCKABLE;\n\t\tret = __mmu_notifier_invalidate_range_start(range);\n\t}\n\tlock_map_release(&__mmu_notifier_invalidate_range_start_map);\n\treturn ret;\n}\n\nstatic inline void\nmmu_notifier_invalidate_range_end(struct mmu_notifier_range *range)\n{\n\tif (mmu_notifier_range_blockable(range))\n\t\tmight_sleep();\n\n\tif (mm_has_notifiers(range->mm))\n\t\t__mmu_notifier_invalidate_range_end(range);\n}\n\nstatic inline void mmu_notifier_arch_invalidate_secondary_tlbs(struct mm_struct *mm,\n\t\t\t\t\tunsigned long start, unsigned long end)\n{\n\tif (mm_has_notifiers(mm))\n\t\t__mmu_notifier_arch_invalidate_secondary_tlbs(mm, start, end);\n}\n\nstatic inline void mmu_notifier_subscriptions_init(struct mm_struct *mm)\n{\n\tmm->notifier_subscriptions = NULL;\n}\n\nstatic inline void mmu_notifier_subscriptions_destroy(struct mm_struct *mm)\n{\n\tif (mm_has_notifiers(mm))\n\t\t__mmu_notifier_subscriptions_destroy(mm);\n}\n\n\nstatic inline void mmu_notifier_range_init(struct mmu_notifier_range *range,\n\t\t\t\t\t   enum mmu_notifier_event event,\n\t\t\t\t\t   unsigned flags,\n\t\t\t\t\t   struct mm_struct *mm,\n\t\t\t\t\t   unsigned long start,\n\t\t\t\t\t   unsigned long end)\n{\n\trange->event = event;\n\trange->mm = mm;\n\trange->start = start;\n\trange->end = end;\n\trange->flags = flags;\n}\n\nstatic inline void mmu_notifier_range_init_owner(\n\t\t\tstruct mmu_notifier_range *range,\n\t\t\tenum mmu_notifier_event event, unsigned int flags,\n\t\t\tstruct mm_struct *mm, unsigned long start,\n\t\t\tunsigned long end, void *owner)\n{\n\tmmu_notifier_range_init(range, event, flags, mm, start, end);\n\trange->owner = owner;\n}\n\n#define ptep_clear_flush_young_notify(__vma, __address, __ptep)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __young;\t\t\t\t\t\t\t\\\n\tstruct vm_area_struct *___vma = __vma;\t\t\t\t\\\n\tunsigned long ___address = __address;\t\t\t\t\\\n\t__young = ptep_clear_flush_young(___vma, ___address, __ptep);\t\\\n\t__young |= mmu_notifier_clear_flush_young(___vma->vm_mm,\t\\\n\t\t\t\t\t\t  ___address,\t\t\\\n\t\t\t\t\t\t  ___address +\t\t\\\n\t\t\t\t\t\t\tPAGE_SIZE);\t\\\n\t__young;\t\t\t\t\t\t\t\\\n})\n\n#define pmdp_clear_flush_young_notify(__vma, __address, __pmdp)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __young;\t\t\t\t\t\t\t\\\n\tstruct vm_area_struct *___vma = __vma;\t\t\t\t\\\n\tunsigned long ___address = __address;\t\t\t\t\\\n\t__young = pmdp_clear_flush_young(___vma, ___address, __pmdp);\t\\\n\t__young |= mmu_notifier_clear_flush_young(___vma->vm_mm,\t\\\n\t\t\t\t\t\t  ___address,\t\t\\\n\t\t\t\t\t\t  ___address +\t\t\\\n\t\t\t\t\t\t\tPMD_SIZE);\t\\\n\t__young;\t\t\t\t\t\t\t\\\n})\n\n#define ptep_clear_young_notify(__vma, __address, __ptep)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __young;\t\t\t\t\t\t\t\\\n\tstruct vm_area_struct *___vma = __vma;\t\t\t\t\\\n\tunsigned long ___address = __address;\t\t\t\t\\\n\t__young = ptep_test_and_clear_young(___vma, ___address, __ptep);\\\n\t__young |= mmu_notifier_clear_young(___vma->vm_mm, ___address,\t\\\n\t\t\t\t\t    ___address + PAGE_SIZE);\t\\\n\t__young;\t\t\t\t\t\t\t\\\n})\n\n#define pmdp_clear_young_notify(__vma, __address, __pmdp)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __young;\t\t\t\t\t\t\t\\\n\tstruct vm_area_struct *___vma = __vma;\t\t\t\t\\\n\tunsigned long ___address = __address;\t\t\t\t\\\n\t__young = pmdp_test_and_clear_young(___vma, ___address, __pmdp);\\\n\t__young |= mmu_notifier_clear_young(___vma->vm_mm, ___address,\t\\\n\t\t\t\t\t    ___address + PMD_SIZE);\t\\\n\t__young;\t\t\t\t\t\t\t\\\n})\n\n \n#define set_pte_at_notify(__mm, __address, __ptep, __pte)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct mm_struct *___mm = __mm;\t\t\t\t\t\\\n\tunsigned long ___address = __address;\t\t\t\t\\\n\tpte_t ___pte = __pte;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmmu_notifier_change_pte(___mm, ___address, ___pte);\t\t\\\n\tset_pte_at(___mm, ___address, __ptep, ___pte);\t\t\t\\\n})\n\n#else  \n\nstruct mmu_notifier_range {\n\tunsigned long start;\n\tunsigned long end;\n};\n\nstatic inline void _mmu_notifier_range_init(struct mmu_notifier_range *range,\n\t\t\t\t\t    unsigned long start,\n\t\t\t\t\t    unsigned long end)\n{\n\trange->start = start;\n\trange->end = end;\n}\n\n#define mmu_notifier_range_init(range,event,flags,mm,start,end)  \\\n\t_mmu_notifier_range_init(range, start, end)\n#define mmu_notifier_range_init_owner(range, event, flags, mm, start, \\\n\t\t\t\t\tend, owner) \\\n\t_mmu_notifier_range_init(range, start, end)\n\nstatic inline bool\nmmu_notifier_range_blockable(const struct mmu_notifier_range *range)\n{\n\treturn true;\n}\n\nstatic inline int mm_has_notifiers(struct mm_struct *mm)\n{\n\treturn 0;\n}\n\nstatic inline void mmu_notifier_release(struct mm_struct *mm)\n{\n}\n\nstatic inline int mmu_notifier_clear_flush_young(struct mm_struct *mm,\n\t\t\t\t\t  unsigned long start,\n\t\t\t\t\t  unsigned long end)\n{\n\treturn 0;\n}\n\nstatic inline int mmu_notifier_test_young(struct mm_struct *mm,\n\t\t\t\t\t  unsigned long address)\n{\n\treturn 0;\n}\n\nstatic inline void mmu_notifier_change_pte(struct mm_struct *mm,\n\t\t\t\t\t   unsigned long address, pte_t pte)\n{\n}\n\nstatic inline void\nmmu_notifier_invalidate_range_start(struct mmu_notifier_range *range)\n{\n}\n\nstatic inline int\nmmu_notifier_invalidate_range_start_nonblock(struct mmu_notifier_range *range)\n{\n\treturn 0;\n}\n\nstatic inline\nvoid mmu_notifier_invalidate_range_end(struct mmu_notifier_range *range)\n{\n}\n\nstatic inline void mmu_notifier_arch_invalidate_secondary_tlbs(struct mm_struct *mm,\n\t\t\t\t  unsigned long start, unsigned long end)\n{\n}\n\nstatic inline void mmu_notifier_subscriptions_init(struct mm_struct *mm)\n{\n}\n\nstatic inline void mmu_notifier_subscriptions_destroy(struct mm_struct *mm)\n{\n}\n\n#define mmu_notifier_range_update_to_read_only(r) false\n\n#define ptep_clear_flush_young_notify ptep_clear_flush_young\n#define pmdp_clear_flush_young_notify pmdp_clear_flush_young\n#define ptep_clear_young_notify ptep_test_and_clear_young\n#define pmdp_clear_young_notify pmdp_test_and_clear_young\n#define\tptep_clear_flush_notify ptep_clear_flush\n#define pmdp_huge_clear_flush_notify pmdp_huge_clear_flush\n#define pudp_huge_clear_flush_notify pudp_huge_clear_flush\n#define set_pte_at_notify set_pte_at\n\nstatic inline void mmu_notifier_synchronize(void)\n{\n}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}