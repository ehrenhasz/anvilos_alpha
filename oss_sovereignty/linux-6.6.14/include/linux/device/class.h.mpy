{
  "module_name": "class.h",
  "hash_id": "32368818ca67b8fd2eb9c35094a79ca6271218b0a57648ae86e8aa3aed7101b7",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/device/class.h",
  "human_readable_source": "\n \n\n#ifndef _DEVICE_CLASS_H_\n#define _DEVICE_CLASS_H_\n\n#include <linux/kobject.h>\n#include <linux/klist.h>\n#include <linux/pm.h>\n#include <linux/device/bus.h>\n\nstruct device;\nstruct fwnode_handle;\n\n \nstruct class {\n\tconst char\t\t*name;\n\n\tconst struct attribute_group\t**class_groups;\n\tconst struct attribute_group\t**dev_groups;\n\n\tint (*dev_uevent)(const struct device *dev, struct kobj_uevent_env *env);\n\tchar *(*devnode)(const struct device *dev, umode_t *mode);\n\n\tvoid (*class_release)(const struct class *class);\n\tvoid (*dev_release)(struct device *dev);\n\n\tint (*shutdown_pre)(struct device *dev);\n\n\tconst struct kobj_ns_type_operations *ns_type;\n\tconst void *(*namespace)(const struct device *dev);\n\n\tvoid (*get_ownership)(const struct device *dev, kuid_t *uid, kgid_t *gid);\n\n\tconst struct dev_pm_ops *pm;\n};\n\nstruct class_dev_iter {\n\tstruct klist_iter\t\tki;\n\tconst struct device_type\t*type;\n\tstruct subsys_private\t\t*sp;\n};\n\nint __must_check class_register(const struct class *class);\nvoid class_unregister(const struct class *class);\nbool class_is_registered(const struct class *class);\n\nstruct class_compat;\nstruct class_compat *class_compat_register(const char *name);\nvoid class_compat_unregister(struct class_compat *cls);\nint class_compat_create_link(struct class_compat *cls, struct device *dev,\n\t\t\t     struct device *device_link);\nvoid class_compat_remove_link(struct class_compat *cls, struct device *dev,\n\t\t\t      struct device *device_link);\n\nvoid class_dev_iter_init(struct class_dev_iter *iter, const struct class *class,\n\t\t\t const struct device *start, const struct device_type *type);\nstruct device *class_dev_iter_next(struct class_dev_iter *iter);\nvoid class_dev_iter_exit(struct class_dev_iter *iter);\n\nint class_for_each_device(const struct class *class, const struct device *start, void *data,\n\t\t\t  int (*fn)(struct device *dev, void *data));\nstruct device *class_find_device(const struct class *class, const struct device *start,\n\t\t\t\t const void *data, int (*match)(struct device *, const void *));\n\n \nstatic inline struct device *class_find_device_by_name(const struct class *class,\n\t\t\t\t\t\t       const char *name)\n{\n\treturn class_find_device(class, NULL, name, device_match_name);\n}\n\n \nstatic inline struct device *class_find_device_by_of_node(const struct class *class,\n\t\t\t\t\t\t\t  const struct device_node *np)\n{\n\treturn class_find_device(class, NULL, np, device_match_of_node);\n}\n\n \nstatic inline struct device *class_find_device_by_fwnode(const struct class *class,\n\t\t\t\t\t\t\t const struct fwnode_handle *fwnode)\n{\n\treturn class_find_device(class, NULL, fwnode, device_match_fwnode);\n}\n\n \nstatic inline struct device *class_find_device_by_devt(const struct class *class,\n\t\t\t\t\t\t       dev_t devt)\n{\n\treturn class_find_device(class, NULL, &devt, device_match_devt);\n}\n\n#ifdef CONFIG_ACPI\nstruct acpi_device;\n \nstatic inline struct device *class_find_device_by_acpi_dev(const struct class *class,\n\t\t\t\t\t\t\t   const struct acpi_device *adev)\n{\n\treturn class_find_device(class, NULL, adev, device_match_acpi_dev);\n}\n#else\nstatic inline struct device *class_find_device_by_acpi_dev(const struct class *class,\n\t\t\t\t\t\t\t   const void *adev)\n{\n\treturn NULL;\n}\n#endif\n\nstruct class_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(const struct class *class, const struct class_attribute *attr,\n\t\t\tchar *buf);\n\tssize_t (*store)(const struct class *class, const struct class_attribute *attr,\n\t\t\t const char *buf, size_t count);\n};\n\n#define CLASS_ATTR_RW(_name) \\\n\tstruct class_attribute class_attr_##_name = __ATTR_RW(_name)\n#define CLASS_ATTR_RO(_name) \\\n\tstruct class_attribute class_attr_##_name = __ATTR_RO(_name)\n#define CLASS_ATTR_WO(_name) \\\n\tstruct class_attribute class_attr_##_name = __ATTR_WO(_name)\n\nint __must_check class_create_file_ns(const struct class *class, const struct class_attribute *attr,\n\t\t\t\t      const void *ns);\nvoid class_remove_file_ns(const struct class *class, const struct class_attribute *attr,\n\t\t\t  const void *ns);\n\nstatic inline int __must_check class_create_file(const struct class *class,\n\t\t\t\t\t\t const struct class_attribute *attr)\n{\n\treturn class_create_file_ns(class, attr, NULL);\n}\n\nstatic inline void class_remove_file(const struct class *class,\n\t\t\t\t     const struct class_attribute *attr)\n{\n\treturn class_remove_file_ns(class, attr, NULL);\n}\n\n \nstruct class_attribute_string {\n\tstruct class_attribute attr;\n\tchar *str;\n};\n\n \n#define _CLASS_ATTR_STRING(_name, _mode, _str) \\\n\t{ __ATTR(_name, _mode, show_class_attr_string, NULL), _str }\n#define CLASS_ATTR_STRING(_name, _mode, _str) \\\n\tstruct class_attribute_string class_attr_##_name = \\\n\t\t_CLASS_ATTR_STRING(_name, _mode, _str)\n\nssize_t show_class_attr_string(const struct class *class, const struct class_attribute *attr,\n\t\t\t       char *buf);\n\nstruct class_interface {\n\tstruct list_head\tnode;\n\tconst struct class\t*class;\n\n\tint (*add_dev)\t\t(struct device *dev);\n\tvoid (*remove_dev)\t(struct device *dev);\n};\n\nint __must_check class_interface_register(struct class_interface *);\nvoid class_interface_unregister(struct class_interface *);\n\nstruct class * __must_check class_create(const char *name);\nvoid class_destroy(const struct class *cls);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}