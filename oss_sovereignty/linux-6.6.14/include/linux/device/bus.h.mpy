{
  "module_name": "bus.h",
  "hash_id": "257f7e670b1f176032b78d0b4d03f9666486732144a3d2b38f648e7d4770441e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/device/bus.h",
  "human_readable_source": "\n \n\n#ifndef _DEVICE_BUS_H_\n#define _DEVICE_BUS_H_\n\n#include <linux/kobject.h>\n#include <linux/klist.h>\n#include <linux/pm.h>\n\nstruct device_driver;\nstruct fwnode_handle;\n\n \nstruct bus_type {\n\tconst char\t\t*name;\n\tconst char\t\t*dev_name;\n\tconst struct attribute_group **bus_groups;\n\tconst struct attribute_group **dev_groups;\n\tconst struct attribute_group **drv_groups;\n\n\tint (*match)(struct device *dev, struct device_driver *drv);\n\tint (*uevent)(const struct device *dev, struct kobj_uevent_env *env);\n\tint (*probe)(struct device *dev);\n\tvoid (*sync_state)(struct device *dev);\n\tvoid (*remove)(struct device *dev);\n\tvoid (*shutdown)(struct device *dev);\n\n\tint (*online)(struct device *dev);\n\tint (*offline)(struct device *dev);\n\n\tint (*suspend)(struct device *dev, pm_message_t state);\n\tint (*resume)(struct device *dev);\n\n\tint (*num_vf)(struct device *dev);\n\n\tint (*dma_configure)(struct device *dev);\n\tvoid (*dma_cleanup)(struct device *dev);\n\n\tconst struct dev_pm_ops *pm;\n\n\tconst struct iommu_ops *iommu_ops;\n\n\tbool need_parent_lock;\n};\n\nint __must_check bus_register(const struct bus_type *bus);\n\nvoid bus_unregister(const struct bus_type *bus);\n\nint __must_check bus_rescan_devices(const struct bus_type *bus);\n\nstruct bus_attribute {\n\tstruct attribute\tattr;\n\tssize_t (*show)(const struct bus_type *bus, char *buf);\n\tssize_t (*store)(const struct bus_type *bus, const char *buf, size_t count);\n};\n\n#define BUS_ATTR_RW(_name) \\\n\tstruct bus_attribute bus_attr_##_name = __ATTR_RW(_name)\n#define BUS_ATTR_RO(_name) \\\n\tstruct bus_attribute bus_attr_##_name = __ATTR_RO(_name)\n#define BUS_ATTR_WO(_name) \\\n\tstruct bus_attribute bus_attr_##_name = __ATTR_WO(_name)\n\nint __must_check bus_create_file(const struct bus_type *bus, struct bus_attribute *attr);\nvoid bus_remove_file(const struct bus_type *bus, struct bus_attribute *attr);\n\n \nint device_match_name(struct device *dev, const void *name);\nint device_match_of_node(struct device *dev, const void *np);\nint device_match_fwnode(struct device *dev, const void *fwnode);\nint device_match_devt(struct device *dev, const void *pdevt);\nint device_match_acpi_dev(struct device *dev, const void *adev);\nint device_match_acpi_handle(struct device *dev, const void *handle);\nint device_match_any(struct device *dev, const void *unused);\n\n \nint bus_for_each_dev(const struct bus_type *bus, struct device *start, void *data,\n\t\t     int (*fn)(struct device *dev, void *data));\nstruct device *bus_find_device(const struct bus_type *bus, struct device *start,\n\t\t\t       const void *data,\n\t\t\t       int (*match)(struct device *dev, const void *data));\n \nstatic inline struct device *bus_find_device_by_name(const struct bus_type *bus,\n\t\t\t\t\t\t     struct device *start,\n\t\t\t\t\t\t     const char *name)\n{\n\treturn bus_find_device(bus, start, name, device_match_name);\n}\n\n \nstatic inline struct device *\nbus_find_device_by_of_node(const struct bus_type *bus, const struct device_node *np)\n{\n\treturn bus_find_device(bus, NULL, np, device_match_of_node);\n}\n\n \nstatic inline struct device *\nbus_find_device_by_fwnode(const struct bus_type *bus, const struct fwnode_handle *fwnode)\n{\n\treturn bus_find_device(bus, NULL, fwnode, device_match_fwnode);\n}\n\n \nstatic inline struct device *bus_find_device_by_devt(const struct bus_type *bus,\n\t\t\t\t\t\t     dev_t devt)\n{\n\treturn bus_find_device(bus, NULL, &devt, device_match_devt);\n}\n\n \nstatic inline struct device *\nbus_find_next_device(const struct bus_type *bus,struct device *cur)\n{\n\treturn bus_find_device(bus, cur, NULL, device_match_any);\n}\n\n#ifdef CONFIG_ACPI\nstruct acpi_device;\n\n \nstatic inline struct device *\nbus_find_device_by_acpi_dev(const struct bus_type *bus, const struct acpi_device *adev)\n{\n\treturn bus_find_device(bus, NULL, adev, device_match_acpi_dev);\n}\n#else\nstatic inline struct device *\nbus_find_device_by_acpi_dev(const struct bus_type *bus, const void *adev)\n{\n\treturn NULL;\n}\n#endif\n\nint bus_for_each_drv(const struct bus_type *bus, struct device_driver *start,\n\t\t     void *data, int (*fn)(struct device_driver *, void *));\nvoid bus_sort_breadthfirst(struct bus_type *bus,\n\t\t\t   int (*compare)(const struct device *a,\n\t\t\t\t\t  const struct device *b));\n \nstruct notifier_block;\n\nint bus_register_notifier(const struct bus_type *bus, struct notifier_block *nb);\nint bus_unregister_notifier(const struct bus_type *bus, struct notifier_block *nb);\n\n \nenum bus_notifier_event {\n\tBUS_NOTIFY_ADD_DEVICE,\n\tBUS_NOTIFY_DEL_DEVICE,\n\tBUS_NOTIFY_REMOVED_DEVICE,\n\tBUS_NOTIFY_BIND_DRIVER,\n\tBUS_NOTIFY_BOUND_DRIVER,\n\tBUS_NOTIFY_UNBIND_DRIVER,\n\tBUS_NOTIFY_UNBOUND_DRIVER,\n\tBUS_NOTIFY_DRIVER_NOT_BOUND,\n};\n\nstruct kset *bus_get_kset(const struct bus_type *bus);\nstruct device *bus_get_dev_root(const struct bus_type *bus);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}