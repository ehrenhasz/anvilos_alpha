{
  "module_name": "timekeeping.h",
  "hash_id": "d5d4bed0568736a7c2f42fee811f13de3a2bd61b90293a6c9ef98fc14c479abc",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/timekeeping.h",
  "human_readable_source": " \n#ifndef _LINUX_TIMEKEEPING_H\n#define _LINUX_TIMEKEEPING_H\n\n#include <linux/errno.h>\n#include <linux/clocksource_ids.h>\n\n \n\nvoid timekeeping_init(void);\nextern int timekeeping_suspended;\n\n \nextern void legacy_timer_tick(unsigned long ticks);\n\n \nextern int do_settimeofday64(const struct timespec64 *ts);\nextern int do_sys_settimeofday64(const struct timespec64 *tv,\n\t\t\t\t const struct timezone *tz);\n\n \n\n\n \nextern void ktime_get_raw_ts64(struct timespec64 *ts);\nextern void ktime_get_ts64(struct timespec64 *ts);\nextern void ktime_get_real_ts64(struct timespec64 *tv);\nextern void ktime_get_coarse_ts64(struct timespec64 *ts);\nextern void ktime_get_coarse_real_ts64(struct timespec64 *ts);\n\nvoid getboottime64(struct timespec64 *ts);\n\n \nextern time64_t ktime_get_seconds(void);\nextern time64_t __ktime_get_real_seconds(void);\nextern time64_t ktime_get_real_seconds(void);\n\n \n\nenum tk_offsets {\n\tTK_OFFS_REAL,\n\tTK_OFFS_BOOT,\n\tTK_OFFS_TAI,\n\tTK_OFFS_MAX,\n};\n\nextern ktime_t ktime_get(void);\nextern ktime_t ktime_get_with_offset(enum tk_offsets offs);\nextern ktime_t ktime_get_coarse_with_offset(enum tk_offsets offs);\nextern ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs);\nextern ktime_t ktime_get_raw(void);\nextern u32 ktime_get_resolution_ns(void);\n\n \nstatic inline ktime_t ktime_get_real(void)\n{\n\treturn ktime_get_with_offset(TK_OFFS_REAL);\n}\n\nstatic inline ktime_t ktime_get_coarse_real(void)\n{\n\treturn ktime_get_coarse_with_offset(TK_OFFS_REAL);\n}\n\n \nstatic inline ktime_t ktime_get_boottime(void)\n{\n\treturn ktime_get_with_offset(TK_OFFS_BOOT);\n}\n\nstatic inline ktime_t ktime_get_coarse_boottime(void)\n{\n\treturn ktime_get_coarse_with_offset(TK_OFFS_BOOT);\n}\n\n \nstatic inline ktime_t ktime_get_clocktai(void)\n{\n\treturn ktime_get_with_offset(TK_OFFS_TAI);\n}\n\nstatic inline ktime_t ktime_get_coarse_clocktai(void)\n{\n\treturn ktime_get_coarse_with_offset(TK_OFFS_TAI);\n}\n\nstatic inline ktime_t ktime_get_coarse(void)\n{\n\tstruct timespec64 ts;\n\n\tktime_get_coarse_ts64(&ts);\n\treturn timespec64_to_ktime(ts);\n}\n\nstatic inline u64 ktime_get_coarse_ns(void)\n{\n\treturn ktime_to_ns(ktime_get_coarse());\n}\n\nstatic inline u64 ktime_get_coarse_real_ns(void)\n{\n\treturn ktime_to_ns(ktime_get_coarse_real());\n}\n\nstatic inline u64 ktime_get_coarse_boottime_ns(void)\n{\n\treturn ktime_to_ns(ktime_get_coarse_boottime());\n}\n\nstatic inline u64 ktime_get_coarse_clocktai_ns(void)\n{\n\treturn ktime_to_ns(ktime_get_coarse_clocktai());\n}\n\n \nstatic inline ktime_t ktime_mono_to_real(ktime_t mono)\n{\n\treturn ktime_mono_to_any(mono, TK_OFFS_REAL);\n}\n\nstatic inline u64 ktime_get_ns(void)\n{\n\treturn ktime_to_ns(ktime_get());\n}\n\nstatic inline u64 ktime_get_real_ns(void)\n{\n\treturn ktime_to_ns(ktime_get_real());\n}\n\nstatic inline u64 ktime_get_boottime_ns(void)\n{\n\treturn ktime_to_ns(ktime_get_boottime());\n}\n\nstatic inline u64 ktime_get_clocktai_ns(void)\n{\n\treturn ktime_to_ns(ktime_get_clocktai());\n}\n\nstatic inline u64 ktime_get_raw_ns(void)\n{\n\treturn ktime_to_ns(ktime_get_raw());\n}\n\nextern u64 ktime_get_mono_fast_ns(void);\nextern u64 ktime_get_raw_fast_ns(void);\nextern u64 ktime_get_boot_fast_ns(void);\nextern u64 ktime_get_tai_fast_ns(void);\nextern u64 ktime_get_real_fast_ns(void);\n\n \nstatic inline void ktime_get_boottime_ts64(struct timespec64 *ts)\n{\n\t*ts = ktime_to_timespec64(ktime_get_boottime());\n}\n\nstatic inline void ktime_get_coarse_boottime_ts64(struct timespec64 *ts)\n{\n\t*ts = ktime_to_timespec64(ktime_get_coarse_boottime());\n}\n\nstatic inline time64_t ktime_get_boottime_seconds(void)\n{\n\treturn ktime_divns(ktime_get_coarse_boottime(), NSEC_PER_SEC);\n}\n\nstatic inline void ktime_get_clocktai_ts64(struct timespec64 *ts)\n{\n\t*ts = ktime_to_timespec64(ktime_get_clocktai());\n}\n\nstatic inline void ktime_get_coarse_clocktai_ts64(struct timespec64 *ts)\n{\n\t*ts = ktime_to_timespec64(ktime_get_coarse_clocktai());\n}\n\nstatic inline time64_t ktime_get_clocktai_seconds(void)\n{\n\treturn ktime_divns(ktime_get_coarse_clocktai(), NSEC_PER_SEC);\n}\n\n \nextern bool timekeeping_rtc_skipsuspend(void);\nextern bool timekeeping_rtc_skipresume(void);\n\nextern void timekeeping_inject_sleeptime64(const struct timespec64 *delta);\n\n \nstruct ktime_timestamps {\n\tu64\t\tmono;\n\tu64\t\tboot;\n\tu64\t\treal;\n};\n\n \nstruct system_time_snapshot {\n\tu64\t\t\tcycles;\n\tktime_t\t\t\treal;\n\tktime_t\t\t\traw;\n\tenum clocksource_ids\tcs_id;\n\tunsigned int\t\tclock_was_set_seq;\n\tu8\t\t\tcs_was_changed_seq;\n};\n\n \nstruct system_device_crosststamp {\n\tktime_t device;\n\tktime_t sys_realtime;\n\tktime_t sys_monoraw;\n};\n\n \nstruct system_counterval_t {\n\tu64\t\t\tcycles;\n\tstruct clocksource\t*cs;\n};\n\n \nextern int get_device_system_crosststamp(\n\t\t\tint (*get_time_fn)(ktime_t *device_time,\n\t\t\t\tstruct system_counterval_t *system_counterval,\n\t\t\t\tvoid *ctx),\n\t\t\tvoid *ctx,\n\t\t\tstruct system_time_snapshot *history,\n\t\t\tstruct system_device_crosststamp *xtstamp);\n\n \nextern void ktime_get_snapshot(struct system_time_snapshot *systime_snapshot);\n\n \nextern void ktime_get_fast_timestamps(struct ktime_timestamps *snap);\n\n \nextern int persistent_clock_is_local;\n\nextern void read_persistent_clock64(struct timespec64 *ts);\nvoid read_persistent_wall_and_boot_offset(struct timespec64 *wall_clock,\n\t\t\t\t\t  struct timespec64 *boot_offset);\n#ifdef CONFIG_GENERIC_CMOS_UPDATE\nextern int update_persistent_clock64(struct timespec64 now);\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}