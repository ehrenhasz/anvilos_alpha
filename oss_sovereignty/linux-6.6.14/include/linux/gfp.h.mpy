{
  "module_name": "gfp.h",
  "hash_id": "8d4cdda38aae0c8e1799ccd54c979e9fcb0a5ebeb4c66bbb4c888dd5b6369e7d",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/gfp.h",
  "human_readable_source": " \n#ifndef __LINUX_GFP_H\n#define __LINUX_GFP_H\n\n#include <linux/gfp_types.h>\n\n#include <linux/mmzone.h>\n#include <linux/topology.h>\n\nstruct vm_area_struct;\n\n \n#define GFP_MOVABLE_MASK (__GFP_RECLAIMABLE|__GFP_MOVABLE)\n#define GFP_MOVABLE_SHIFT 3\n\nstatic inline int gfp_migratetype(const gfp_t gfp_flags)\n{\n\tVM_WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);\n\tBUILD_BUG_ON((1UL << GFP_MOVABLE_SHIFT) != ___GFP_MOVABLE);\n\tBUILD_BUG_ON((___GFP_MOVABLE >> GFP_MOVABLE_SHIFT) != MIGRATE_MOVABLE);\n\tBUILD_BUG_ON((___GFP_RECLAIMABLE >> GFP_MOVABLE_SHIFT) != MIGRATE_RECLAIMABLE);\n\tBUILD_BUG_ON(((___GFP_MOVABLE | ___GFP_RECLAIMABLE) >>\n\t\t      GFP_MOVABLE_SHIFT) != MIGRATE_HIGHATOMIC);\n\n\tif (unlikely(page_group_by_mobility_disabled))\n\t\treturn MIGRATE_UNMOVABLE;\n\n\t \n\treturn (__force unsigned long)(gfp_flags & GFP_MOVABLE_MASK) >> GFP_MOVABLE_SHIFT;\n}\n#undef GFP_MOVABLE_MASK\n#undef GFP_MOVABLE_SHIFT\n\nstatic inline bool gfpflags_allow_blocking(const gfp_t gfp_flags)\n{\n\treturn !!(gfp_flags & __GFP_DIRECT_RECLAIM);\n}\n\n#ifdef CONFIG_HIGHMEM\n#define OPT_ZONE_HIGHMEM ZONE_HIGHMEM\n#else\n#define OPT_ZONE_HIGHMEM ZONE_NORMAL\n#endif\n\n#ifdef CONFIG_ZONE_DMA\n#define OPT_ZONE_DMA ZONE_DMA\n#else\n#define OPT_ZONE_DMA ZONE_NORMAL\n#endif\n\n#ifdef CONFIG_ZONE_DMA32\n#define OPT_ZONE_DMA32 ZONE_DMA32\n#else\n#define OPT_ZONE_DMA32 ZONE_NORMAL\n#endif\n\n \n\n#if defined(CONFIG_ZONE_DEVICE) && (MAX_NR_ZONES-1) <= 4\n \n#define GFP_ZONES_SHIFT 2\n#else\n#define GFP_ZONES_SHIFT ZONES_SHIFT\n#endif\n\n#if 16 * GFP_ZONES_SHIFT > BITS_PER_LONG\n#error GFP_ZONES_SHIFT too large to create GFP_ZONE_TABLE integer\n#endif\n\n#define GFP_ZONE_TABLE ( \\\n\t(ZONE_NORMAL << 0 * GFP_ZONES_SHIFT)\t\t\t\t       \\\n\t| (OPT_ZONE_DMA << ___GFP_DMA * GFP_ZONES_SHIFT)\t\t       \\\n\t| (OPT_ZONE_HIGHMEM << ___GFP_HIGHMEM * GFP_ZONES_SHIFT)\t       \\\n\t| (OPT_ZONE_DMA32 << ___GFP_DMA32 * GFP_ZONES_SHIFT)\t\t       \\\n\t| (ZONE_NORMAL << ___GFP_MOVABLE * GFP_ZONES_SHIFT)\t\t       \\\n\t| (OPT_ZONE_DMA << (___GFP_MOVABLE | ___GFP_DMA) * GFP_ZONES_SHIFT)    \\\n\t| (ZONE_MOVABLE << (___GFP_MOVABLE | ___GFP_HIGHMEM) * GFP_ZONES_SHIFT)\\\n\t| (OPT_ZONE_DMA32 << (___GFP_MOVABLE | ___GFP_DMA32) * GFP_ZONES_SHIFT)\\\n)\n\n \n#define GFP_ZONE_BAD ( \\\n\t1 << (___GFP_DMA | ___GFP_HIGHMEM)\t\t\t\t      \\\n\t| 1 << (___GFP_DMA | ___GFP_DMA32)\t\t\t\t      \\\n\t| 1 << (___GFP_DMA32 | ___GFP_HIGHMEM)\t\t\t\t      \\\n\t| 1 << (___GFP_DMA | ___GFP_DMA32 | ___GFP_HIGHMEM)\t\t      \\\n\t| 1 << (___GFP_MOVABLE | ___GFP_HIGHMEM | ___GFP_DMA)\t\t      \\\n\t| 1 << (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA)\t\t      \\\n\t| 1 << (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_HIGHMEM)\t\t      \\\n\t| 1 << (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA | ___GFP_HIGHMEM)  \\\n)\n\nstatic inline enum zone_type gfp_zone(gfp_t flags)\n{\n\tenum zone_type z;\n\tint bit = (__force int) (flags & GFP_ZONEMASK);\n\n\tz = (GFP_ZONE_TABLE >> (bit * GFP_ZONES_SHIFT)) &\n\t\t\t\t\t ((1 << GFP_ZONES_SHIFT) - 1);\n\tVM_BUG_ON((GFP_ZONE_BAD >> bit) & 1);\n\treturn z;\n}\n\n \n\nstatic inline int gfp_zonelist(gfp_t flags)\n{\n#ifdef CONFIG_NUMA\n\tif (unlikely(flags & __GFP_THISNODE))\n\t\treturn ZONELIST_NOFALLBACK;\n#endif\n\treturn ZONELIST_FALLBACK;\n}\n\n \nstatic inline struct zonelist *node_zonelist(int nid, gfp_t flags)\n{\n\treturn NODE_DATA(nid)->node_zonelists + gfp_zonelist(flags);\n}\n\n#ifndef HAVE_ARCH_FREE_PAGE\nstatic inline void arch_free_page(struct page *page, int order) { }\n#endif\n#ifndef HAVE_ARCH_ALLOC_PAGE\nstatic inline void arch_alloc_page(struct page *page, int order) { }\n#endif\n\nstruct page *__alloc_pages(gfp_t gfp, unsigned int order, int preferred_nid,\n\t\tnodemask_t *nodemask);\nstruct folio *__folio_alloc(gfp_t gfp, unsigned int order, int preferred_nid,\n\t\tnodemask_t *nodemask);\n\nunsigned long __alloc_pages_bulk(gfp_t gfp, int preferred_nid,\n\t\t\t\tnodemask_t *nodemask, int nr_pages,\n\t\t\t\tstruct list_head *page_list,\n\t\t\t\tstruct page **page_array);\n\nunsigned long alloc_pages_bulk_array_mempolicy(gfp_t gfp,\n\t\t\t\tunsigned long nr_pages,\n\t\t\t\tstruct page **page_array);\n\n \nstatic inline unsigned long\nalloc_pages_bulk_list(gfp_t gfp, unsigned long nr_pages, struct list_head *list)\n{\n\treturn __alloc_pages_bulk(gfp, numa_mem_id(), NULL, nr_pages, list, NULL);\n}\n\nstatic inline unsigned long\nalloc_pages_bulk_array(gfp_t gfp, unsigned long nr_pages, struct page **page_array)\n{\n\treturn __alloc_pages_bulk(gfp, numa_mem_id(), NULL, nr_pages, NULL, page_array);\n}\n\nstatic inline unsigned long\nalloc_pages_bulk_array_node(gfp_t gfp, int nid, unsigned long nr_pages, struct page **page_array)\n{\n\tif (nid == NUMA_NO_NODE)\n\t\tnid = numa_mem_id();\n\n\treturn __alloc_pages_bulk(gfp, nid, NULL, nr_pages, NULL, page_array);\n}\n\nstatic inline void warn_if_node_offline(int this_node, gfp_t gfp_mask)\n{\n\tgfp_t warn_gfp = gfp_mask & (__GFP_THISNODE|__GFP_NOWARN);\n\n\tif (warn_gfp != (__GFP_THISNODE|__GFP_NOWARN))\n\t\treturn;\n\n\tif (node_online(this_node))\n\t\treturn;\n\n\tpr_warn(\"%pGg allocation from offline node %d\\n\", &gfp_mask, this_node);\n\tdump_stack();\n}\n\n \nstatic inline struct page *\n__alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)\n{\n\tVM_BUG_ON(nid < 0 || nid >= MAX_NUMNODES);\n\twarn_if_node_offline(nid, gfp_mask);\n\n\treturn __alloc_pages(gfp_mask, order, nid, NULL);\n}\n\nstatic inline\nstruct folio *__folio_alloc_node(gfp_t gfp, unsigned int order, int nid)\n{\n\tVM_BUG_ON(nid < 0 || nid >= MAX_NUMNODES);\n\twarn_if_node_offline(nid, gfp);\n\n\treturn __folio_alloc(gfp, order, nid, NULL);\n}\n\n \nstatic inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,\n\t\t\t\t\t\tunsigned int order)\n{\n\tif (nid == NUMA_NO_NODE)\n\t\tnid = numa_mem_id();\n\n\treturn __alloc_pages_node(nid, gfp_mask, order);\n}\n\n#ifdef CONFIG_NUMA\nstruct page *alloc_pages(gfp_t gfp, unsigned int order);\nstruct folio *folio_alloc(gfp_t gfp, unsigned order);\nstruct folio *vma_alloc_folio(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, bool hugepage);\n#else\nstatic inline struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\treturn alloc_pages_node(numa_node_id(), gfp_mask, order);\n}\nstatic inline struct folio *folio_alloc(gfp_t gfp, unsigned int order)\n{\n\treturn __folio_alloc_node(gfp, order, numa_node_id());\n}\n#define vma_alloc_folio(gfp, order, vma, addr, hugepage)\t\t\\\n\tfolio_alloc(gfp, order)\n#endif\n#define alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)\nstatic inline struct page *alloc_page_vma(gfp_t gfp,\n\t\tstruct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct folio *folio = vma_alloc_folio(gfp, 0, vma, addr, false);\n\n\treturn &folio->page;\n}\n\nextern unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order);\nextern unsigned long get_zeroed_page(gfp_t gfp_mask);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask) __alloc_size(1);\nvoid free_pages_exact(void *virt, size_t size);\n__meminit void *alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask) __alloc_size(2);\n\n#define __get_free_page(gfp_mask) \\\n\t\t__get_free_pages((gfp_mask), 0)\n\n#define __get_dma_pages(gfp_mask, order) \\\n\t\t__get_free_pages((gfp_mask) | GFP_DMA, (order))\n\nextern void __free_pages(struct page *page, unsigned int order);\nextern void free_pages(unsigned long addr, unsigned int order);\n\nstruct page_frag_cache;\nextern void __page_frag_cache_drain(struct page *page, unsigned int count);\nextern void *page_frag_alloc_align(struct page_frag_cache *nc,\n\t\t\t\t   unsigned int fragsz, gfp_t gfp_mask,\n\t\t\t\t   unsigned int align_mask);\n\nstatic inline void *page_frag_alloc(struct page_frag_cache *nc,\n\t\t\t     unsigned int fragsz, gfp_t gfp_mask)\n{\n\treturn page_frag_alloc_align(nc, fragsz, gfp_mask, ~0u);\n}\n\nextern void page_frag_free(void *addr);\n\n#define __free_page(page) __free_pages((page), 0)\n#define free_page(addr) free_pages((addr), 0)\n\nvoid page_alloc_init_cpuhp(void);\nvoid drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp);\nvoid drain_all_pages(struct zone *zone);\nvoid drain_local_pages(struct zone *zone);\n\nvoid page_alloc_init_late(void);\n\n \nextern gfp_t gfp_allowed_mask;\n\n \nbool gfp_pfmemalloc_allowed(gfp_t gfp_mask);\n\nstatic inline bool gfp_has_io_fs(gfp_t gfp)\n{\n\treturn (gfp & (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS);\n}\n\nextern gfp_t vma_thp_gfp_mask(struct vm_area_struct *vma);\n\n#ifdef CONFIG_CONTIG_ALLOC\n \nextern int alloc_contig_range(unsigned long start, unsigned long end,\n\t\t\t      unsigned migratetype, gfp_t gfp_mask);\nextern struct page *alloc_contig_pages(unsigned long nr_pages, gfp_t gfp_mask,\n\t\t\t\t       int nid, nodemask_t *nodemask);\n#endif\nvoid free_contig_range(unsigned long pfn, unsigned long nr_pages);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}