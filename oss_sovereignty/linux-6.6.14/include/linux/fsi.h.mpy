{
  "module_name": "fsi.h",
  "hash_id": "b7d0283fef6382c79e82a072baead0b7b0e7c664209e3a8a4fce7bd0e1923f6c",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fsi.h",
  "human_readable_source": " \n \n\n#ifndef LINUX_FSI_H\n#define LINUX_FSI_H\n\n#include <linux/device.h>\n\nstruct fsi_device {\n\tstruct device\t\tdev;\n\tu8\t\t\tengine_type;\n\tu8\t\t\tversion;\n\tu8\t\t\tunit;\n\tstruct fsi_slave\t*slave;\n\tuint32_t\t\taddr;\n\tuint32_t\t\tsize;\n};\n\nextern int fsi_device_read(struct fsi_device *dev, uint32_t addr,\n\t\tvoid *val, size_t size);\nextern int fsi_device_write(struct fsi_device *dev, uint32_t addr,\n\t\tconst void *val, size_t size);\nextern int fsi_device_peek(struct fsi_device *dev, void *val);\n\nstruct fsi_device_id {\n\tu8\tengine_type;\n\tu8\tversion;\n};\n\n#define FSI_VERSION_ANY\t\t0\n\n#define FSI_DEVICE(t) \\\n\t.engine_type = (t), .version = FSI_VERSION_ANY,\n\n#define FSI_DEVICE_VERSIONED(t, v) \\\n\t.engine_type = (t), .version = (v),\n\nstruct fsi_driver {\n\tstruct device_driver\t\tdrv;\n\tconst struct fsi_device_id\t*id_table;\n};\n\n#define to_fsi_dev(devp) container_of(devp, struct fsi_device, dev)\n#define to_fsi_drv(drvp) container_of(drvp, struct fsi_driver, drv)\n\nextern int fsi_driver_register(struct fsi_driver *fsi_drv);\nextern void fsi_driver_unregister(struct fsi_driver *fsi_drv);\n\n \n#define module_fsi_driver(__fsi_driver) \\\n\t\tmodule_driver(__fsi_driver, fsi_driver_register, \\\n\t\t\t\tfsi_driver_unregister)\n\n \nextern int fsi_slave_claim_range(struct fsi_slave *slave,\n\t\tuint32_t addr, uint32_t size);\nextern void fsi_slave_release_range(struct fsi_slave *slave,\n\t\tuint32_t addr, uint32_t size);\nextern int fsi_slave_read(struct fsi_slave *slave, uint32_t addr,\n\t\tvoid *val, size_t size);\nextern int fsi_slave_write(struct fsi_slave *slave, uint32_t addr,\n\t\tconst void *val, size_t size);\n\nextern struct bus_type fsi_bus_type;\nextern const struct device_type fsi_cdev_type;\n\nenum fsi_dev_type {\n\tfsi_dev_cfam,\n\tfsi_dev_sbefifo,\n\tfsi_dev_scom,\n\tfsi_dev_occ\n};\n\nextern int fsi_get_new_minor(struct fsi_device *fdev, enum fsi_dev_type type,\n\t\t\t     dev_t *out_dev, int *out_index);\nextern void fsi_free_minor(dev_t dev);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}