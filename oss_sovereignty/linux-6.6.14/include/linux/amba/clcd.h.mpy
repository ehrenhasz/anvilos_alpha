{
  "module_name": "clcd.h",
  "hash_id": "d8aafb70eed97a2358096e8bb17f6e96fa780869df0489d8f97649ed43682c84",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/amba/clcd.h",
  "human_readable_source": " \n#include <linux/fb.h>\n#include <linux/amba/clcd-regs.h>\n\nenum {\n\t \n\tCLCD_CAP_RGB444\t\t= (1 << 0),\n\tCLCD_CAP_RGB5551\t= (1 << 1),\n\tCLCD_CAP_RGB565\t\t= (1 << 2),\n\tCLCD_CAP_RGB888\t\t= (1 << 3),\n\tCLCD_CAP_BGR444\t\t= (1 << 4),\n\tCLCD_CAP_BGR5551\t= (1 << 5),\n\tCLCD_CAP_BGR565\t\t= (1 << 6),\n\tCLCD_CAP_BGR888\t\t= (1 << 7),\n\n\t \n\tCLCD_CAP_444\t\t= CLCD_CAP_RGB444 | CLCD_CAP_BGR444,\n\tCLCD_CAP_5551\t\t= CLCD_CAP_RGB5551 | CLCD_CAP_BGR5551,\n\tCLCD_CAP_565\t\t= CLCD_CAP_RGB565 | CLCD_CAP_BGR565,\n\tCLCD_CAP_888\t\t= CLCD_CAP_RGB888 | CLCD_CAP_BGR888,\n\n\t \n\tCLCD_CAP_RGB\t\t= CLCD_CAP_RGB444 | CLCD_CAP_RGB5551 |\n\t\t\t\t  CLCD_CAP_RGB565 | CLCD_CAP_RGB888,\n\tCLCD_CAP_BGR\t\t= CLCD_CAP_BGR444 | CLCD_CAP_BGR5551 |\n\t\t\t\t  CLCD_CAP_BGR565 | CLCD_CAP_BGR888,\n\n\tCLCD_CAP_ALL\t\t= CLCD_CAP_BGR | CLCD_CAP_RGB,\n};\n\nstruct backlight_device;\n\nstruct clcd_panel {\n\tstruct fb_videomode\tmode;\n\tsigned short\t\twidth;\t \n\tsigned short\t\theight;\t \n\tu32\t\t\ttim2;\n\tu32\t\t\ttim3;\n\tu32\t\t\tcntl;\n\tu32\t\t\tcaps;\n\tunsigned int\t\tbpp:8,\n\t\t\t\tfixedtimings:1,\n\t\t\t\tgrayscale:1;\n\tunsigned int\t\tconnector;\n\tstruct backlight_device\t*backlight;\n\t \n\tbool\t\t\tbgr_connection;\n};\n\nstruct clcd_regs {\n\tu32\t\t\ttim0;\n\tu32\t\t\ttim1;\n\tu32\t\t\ttim2;\n\tu32\t\t\ttim3;\n\tu32\t\t\tcntl;\n\tunsigned long\t\tpixclock;\n};\n\nstruct clcd_fb;\n\n \nstruct clcd_board {\n\tconst char *name;\n\n\t \n\tu32\tcaps;\n\n\t \n\tint\t(*check)(struct clcd_fb *fb, struct fb_var_screeninfo *var);\n\n\t \n\tvoid\t(*decode)(struct clcd_fb *fb, struct clcd_regs *regs);\n\n\t \n\tvoid\t(*disable)(struct clcd_fb *);\n\n\t \n\tvoid\t(*enable)(struct clcd_fb *);\n\n\t \n\tint\t(*setup)(struct clcd_fb *);\n\n\t \n\tint\t(*mmap)(struct clcd_fb *, struct vm_area_struct *);\n\n\t \n\tvoid\t(*remove)(struct clcd_fb *);\n};\n\nstruct amba_device;\nstruct clk;\n\n \nstruct clcd_fb {\n\tstruct fb_info\t\tfb;\n\tstruct amba_device\t*dev;\n\tstruct clk\t\t*clk;\n\tstruct clcd_panel\t*panel;\n\tstruct clcd_board\t*board;\n\tvoid\t\t\t*board_data;\n\tvoid __iomem\t\t*regs;\n\tu16\t\t\toff_ienb;\n\tu16\t\t\toff_cntl;\n\tu32\t\t\tclcd_cntl;\n\tu32\t\t\tcmap[16];\n\tbool\t\t\tclk_enabled;\n};\n\nstatic inline void clcdfb_decode(struct clcd_fb *fb, struct clcd_regs *regs)\n{\n\tstruct fb_var_screeninfo *var = &fb->fb.var;\n\tu32 val, cpl;\n\n\t \n\tval = ((var->xres / 16) - 1) << 2;\n\tval |= (var->hsync_len - 1) << 8;\n\tval |= (var->right_margin - 1) << 16;\n\tval |= (var->left_margin - 1) << 24;\n\tregs->tim0 = val;\n\n\tval = var->yres;\n\tif (fb->panel->cntl & CNTL_LCDDUAL)\n\t\tval /= 2;\n\tval -= 1;\n\tval |= (var->vsync_len - 1) << 10;\n\tval |= var->lower_margin << 16;\n\tval |= var->upper_margin << 24;\n\tregs->tim1 = val;\n\n\tval = fb->panel->tim2;\n\tval |= var->sync & FB_SYNC_HOR_HIGH_ACT  ? 0 : TIM2_IHS;\n\tval |= var->sync & FB_SYNC_VERT_HIGH_ACT ? 0 : TIM2_IVS;\n\n\tcpl = var->xres_virtual;\n\tif (fb->panel->cntl & CNTL_LCDTFT)\t   \n\t\t ;\n\telse if (!var->grayscale)\t\t   \n\t\tcpl = cpl * 8 / 3;\n\telse if (fb->panel->cntl & CNTL_LCDMONO8)  \n\t\tcpl /= 8;\n\telse\t\t\t\t\t   \n\t\tcpl /= 4;\n\n\tregs->tim2 = val | ((cpl - 1) << 16);\n\n\tregs->tim3 = fb->panel->tim3;\n\n\tval = fb->panel->cntl;\n\tif (var->grayscale)\n\t\tval |= CNTL_LCDBW;\n\n\tif (fb->panel->caps && fb->board->caps && var->bits_per_pixel >= 16) {\n\t\t \n\t\tif (var->red.offset == 0)\n\t\t\tval &= ~CNTL_BGR;\n\t\telse\n\t\t\tval |= CNTL_BGR;\n\t\tif (fb->panel->bgr_connection)\n\t\t\tval ^= CNTL_BGR;\n\t}\n\n\tswitch (var->bits_per_pixel) {\n\tcase 1:\n\t\tval |= CNTL_LCDBPP1;\n\t\tbreak;\n\tcase 2:\n\t\tval |= CNTL_LCDBPP2;\n\t\tbreak;\n\tcase 4:\n\t\tval |= CNTL_LCDBPP4;\n\t\tbreak;\n\tcase 8:\n\t\tval |= CNTL_LCDBPP8;\n\t\tbreak;\n\tcase 16:\n\t\t \n\t\tif (amba_part(fb->dev) == 0x110 ||\n\t\t    var->green.length == 5)\n\t\t\tval |= CNTL_LCDBPP16;\n\t\telse if (var->green.length == 6)\n\t\t\tval |= CNTL_LCDBPP16_565;\n\t\telse\n\t\t\tval |= CNTL_LCDBPP16_444;\n\t\tbreak;\n\tcase 32:\n\t\tval |= CNTL_LCDBPP24;\n\t\tbreak;\n\t}\n\n\tregs->cntl = val;\n\tregs->pixclock = var->pixclock;\n}\n\nstatic inline int clcdfb_check(struct clcd_fb *fb, struct fb_var_screeninfo *var)\n{\n\tvar->xres_virtual = var->xres = (var->xres + 15) & ~15;\n\tvar->yres_virtual = var->yres = (var->yres + 1) & ~1;\n\n#define CHECK(e,l,h) (var->e < l || var->e > h)\n\tif (CHECK(right_margin, (5+1), 256) ||\t \n\t    CHECK(left_margin, (5+1), 256) ||\t \n\t    CHECK(hsync_len, (5+1), 256) ||\n\t    var->xres > 4096 ||\n\t    var->lower_margin > 255 ||\t\t \n\t    var->upper_margin > 255 ||\t\t \n\t    var->vsync_len > 32 ||\n\t    var->yres > 1024)\n\t\treturn -EINVAL;\n#undef CHECK\n\n\t \n\t \n\n\t \n\tif (var->grayscale != fb->fb.var.grayscale ||\n\t    (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)\n\t\treturn -EINVAL;\n\n#define CHECK(e) (var->e != fb->fb.var.e)\n\tif (fb->panel->fixedtimings &&\n\t    (CHECK(xres)\t\t||\n\t     CHECK(yres)\t\t||\n\t     CHECK(bits_per_pixel)\t||\n\t     CHECK(pixclock)\t\t||\n\t     CHECK(left_margin)\t\t||\n\t     CHECK(right_margin)\t||\n\t     CHECK(upper_margin)\t||\n\t     CHECK(lower_margin)\t||\n\t     CHECK(hsync_len)\t\t||\n\t     CHECK(vsync_len)\t\t||\n\t     CHECK(sync)))\n\t\treturn -EINVAL;\n#undef CHECK\n\n\tvar->nonstd = 0;\n\tvar->accel_flags = 0;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}