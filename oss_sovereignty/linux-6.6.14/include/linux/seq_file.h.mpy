{
  "module_name": "seq_file.h",
  "hash_id": "6d9b53a74365a92987c533f043c16bd250d29b1ca36fa04961e83b3ac1d63226",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/seq_file.h",
  "human_readable_source": " \n#ifndef _LINUX_SEQ_FILE_H\n#define _LINUX_SEQ_FILE_H\n\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/string_helpers.h>\n#include <linux/bug.h>\n#include <linux/mutex.h>\n#include <linux/cpumask.h>\n#include <linux/nodemask.h>\n#include <linux/fs.h>\n#include <linux/cred.h>\n\nstruct seq_operations;\n\nstruct seq_file {\n\tchar *buf;\n\tsize_t size;\n\tsize_t from;\n\tsize_t count;\n\tsize_t pad_until;\n\tloff_t index;\n\tloff_t read_pos;\n\tstruct mutex lock;\n\tconst struct seq_operations *op;\n\tint poll_event;\n\tconst struct file *file;\n\tvoid *private;\n};\n\nstruct seq_operations {\n\tvoid * (*start) (struct seq_file *m, loff_t *pos);\n\tvoid (*stop) (struct seq_file *m, void *v);\n\tvoid * (*next) (struct seq_file *m, void *v, loff_t *pos);\n\tint (*show) (struct seq_file *m, void *v);\n};\n\n#define SEQ_SKIP 1\n\n \nstatic inline bool seq_has_overflowed(struct seq_file *m)\n{\n\treturn m->count == m->size;\n}\n\n \nstatic inline size_t seq_get_buf(struct seq_file *m, char **bufp)\n{\n\tBUG_ON(m->count > m->size);\n\tif (m->count < m->size)\n\t\t*bufp = m->buf + m->count;\n\telse\n\t\t*bufp = NULL;\n\n\treturn m->size - m->count;\n}\n\n \nstatic inline void seq_commit(struct seq_file *m, int num)\n{\n\tif (num < 0) {\n\t\tm->count = m->size;\n\t} else {\n\t\tBUG_ON(m->count + num > m->size);\n\t\tm->count += num;\n\t}\n}\n\n \nstatic inline void seq_setwidth(struct seq_file *m, size_t size)\n{\n\tm->pad_until = m->count + size;\n}\nvoid seq_pad(struct seq_file *m, char c);\n\nchar *mangle_path(char *s, const char *p, const char *esc);\nint seq_open(struct file *, const struct seq_operations *);\nssize_t seq_read(struct file *, char __user *, size_t, loff_t *);\nssize_t seq_read_iter(struct kiocb *iocb, struct iov_iter *iter);\nloff_t seq_lseek(struct file *, loff_t, int);\nint seq_release(struct inode *, struct file *);\nint seq_write(struct seq_file *seq, const void *data, size_t len);\n\n__printf(2, 0)\nvoid seq_vprintf(struct seq_file *m, const char *fmt, va_list args);\n__printf(2, 3)\nvoid seq_printf(struct seq_file *m, const char *fmt, ...);\nvoid seq_putc(struct seq_file *m, char c);\nvoid seq_puts(struct seq_file *m, const char *s);\nvoid seq_put_decimal_ull_width(struct seq_file *m, const char *delimiter,\n\t\t\t       unsigned long long num, unsigned int width);\nvoid seq_put_decimal_ull(struct seq_file *m, const char *delimiter,\n\t\t\t unsigned long long num);\nvoid seq_put_decimal_ll(struct seq_file *m, const char *delimiter, long long num);\nvoid seq_put_hex_ll(struct seq_file *m, const char *delimiter,\n\t\t    unsigned long long v, unsigned int width);\n\nvoid seq_escape_mem(struct seq_file *m, const char *src, size_t len,\n\t\t    unsigned int flags, const char *esc);\n\nstatic inline void seq_escape_str(struct seq_file *m, const char *src,\n\t\t\t\t  unsigned int flags, const char *esc)\n{\n\tseq_escape_mem(m, src, strlen(src), flags, esc);\n}\n\n \nstatic inline void seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tseq_escape_str(m, s, ESCAPE_OCTAL, esc);\n}\n\nvoid seq_hex_dump(struct seq_file *m, const char *prefix_str, int prefix_type,\n\t\t  int rowsize, int groupsize, const void *buf, size_t len,\n\t\t  bool ascii);\n\nint seq_path(struct seq_file *, const struct path *, const char *);\nint seq_file_path(struct seq_file *, struct file *, const char *);\nint seq_dentry(struct seq_file *, struct dentry *, const char *);\nint seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc);\n\nvoid *single_start(struct seq_file *, loff_t *);\nint single_open(struct file *, int (*)(struct seq_file *, void *), void *);\nint single_open_size(struct file *, int (*)(struct seq_file *, void *), void *, size_t);\nint single_release(struct inode *, struct file *);\nvoid *__seq_open_private(struct file *, const struct seq_operations *, int);\nint seq_open_private(struct file *, const struct seq_operations *, int);\nint seq_release_private(struct inode *, struct file *);\n\n#ifdef CONFIG_BINARY_PRINTF\nvoid seq_bprintf(struct seq_file *m, const char *f, const u32 *binary);\n#endif\n\n#define DEFINE_SEQ_ATTRIBUTE(__name)\t\t\t\t\t\\\nstatic int __name ## _open(struct inode *inode, struct file *file)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint ret = seq_open(file, &__name ## _sops);\t\t\t\\\n\tif (!ret && inode->i_private) {\t\t\t\t\t\\\n\t\tstruct seq_file *seq_f = file->private_data;\t\t\\\n\t\tseq_f->private = inode->i_private;\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic const struct file_operations __name ## _fops = {\t\t\t\\\n\t.owner\t\t= THIS_MODULE,\t\t\t\t\t\\\n\t.open\t\t= __name ## _open,\t\t\t\t\\\n\t.read\t\t= seq_read,\t\t\t\t\t\\\n\t.llseek\t\t= seq_lseek,\t\t\t\t\t\\\n\t.release\t= seq_release,\t\t\t\t\t\\\n}\n\n#define DEFINE_SHOW_ATTRIBUTE(__name)\t\t\t\t\t\\\nstatic int __name ## _open(struct inode *inode, struct file *file)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn single_open(file, __name ## _show, inode->i_private);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic const struct file_operations __name ## _fops = {\t\t\t\\\n\t.owner\t\t= THIS_MODULE,\t\t\t\t\t\\\n\t.open\t\t= __name ## _open,\t\t\t\t\\\n\t.read\t\t= seq_read,\t\t\t\t\t\\\n\t.llseek\t\t= seq_lseek,\t\t\t\t\t\\\n\t.release\t= single_release,\t\t\t\t\\\n}\n\n#define DEFINE_PROC_SHOW_ATTRIBUTE(__name)\t\t\t\t\\\nstatic int __name ## _open(struct inode *inode, struct file *file)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn single_open(file, __name ## _show, pde_data(inode));\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic const struct proc_ops __name ## _proc_ops = {\t\t\t\\\n\t.proc_open\t= __name ## _open,\t\t\t\t\\\n\t.proc_read\t= seq_read,\t\t\t\t\t\\\n\t.proc_lseek\t= seq_lseek,\t\t\t\t\t\\\n\t.proc_release\t= single_release,\t\t\t\t\\\n}\n\nstatic inline struct user_namespace *seq_user_ns(struct seq_file *seq)\n{\n#ifdef CONFIG_USER_NS\n\treturn seq->file->f_cred->user_ns;\n#else\n\textern struct user_namespace init_user_ns;\n\treturn &init_user_ns;\n#endif\n}\n\n \nstatic inline void seq_show_option(struct seq_file *m, const char *name,\n\t\t\t\t   const char *value)\n{\n\tseq_putc(m, ',');\n\tseq_escape(m, name, \",= \\t\\n\\\\\");\n\tif (value) {\n\t\tseq_putc(m, '=');\n\t\tseq_escape(m, value, \", \\t\\n\\\\\");\n\t}\n}\n\n \n#define seq_show_option_n(m, name, value, length) {\t\\\n\tchar val_buf[length + 1];\t\t\t\\\n\tmemcpy(val_buf, value, length);\t\t\t\\\n\tval_buf[length] = '\\0';\t\t\t\t\\\n\tseq_show_option(m, name, val_buf);\t\t\\\n}\n\n#define SEQ_START_TOKEN ((void *)1)\n \n\nextern struct list_head *seq_list_start(struct list_head *head,\n\t\tloff_t pos);\nextern struct list_head *seq_list_start_head(struct list_head *head,\n\t\tloff_t pos);\nextern struct list_head *seq_list_next(void *v, struct list_head *head,\n\t\tloff_t *ppos);\n\nextern struct list_head *seq_list_start_rcu(struct list_head *head, loff_t pos);\nextern struct list_head *seq_list_start_head_rcu(struct list_head *head, loff_t pos);\nextern struct list_head *seq_list_next_rcu(void *v, struct list_head *head, loff_t *ppos);\n\n \n\nextern struct hlist_node *seq_hlist_start(struct hlist_head *head,\n\t\t\t\t\t  loff_t pos);\nextern struct hlist_node *seq_hlist_start_head(struct hlist_head *head,\n\t\t\t\t\t       loff_t pos);\nextern struct hlist_node *seq_hlist_next(void *v, struct hlist_head *head,\n\t\t\t\t\t loff_t *ppos);\n\nextern struct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,\n\t\t\t\t\t      loff_t pos);\nextern struct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,\n\t\t\t\t\t\t   loff_t pos);\nextern struct hlist_node *seq_hlist_next_rcu(void *v,\n\t\t\t\t\t\t   struct hlist_head *head,\n\t\t\t\t\t\t   loff_t *ppos);\n\n \nextern struct hlist_node *seq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos);\n\nextern struct hlist_node *seq_hlist_next_percpu(void *v, struct hlist_head __percpu *head, int *cpu, loff_t *pos);\n\nvoid seq_file_init(void);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}