{
  "module_name": "btf.h",
  "hash_id": "d076af38bf56571a89d2ec9eb29500cf6ddbda14e07d9868768dc31d7555f3db",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/btf.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_BTF_H\n#define _LINUX_BTF_H 1\n\n#include <linux/types.h>\n#include <linux/bpfptr.h>\n#include <linux/bsearch.h>\n#include <linux/btf_ids.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n\n#define BTF_TYPE_EMIT(type) ((void)(type *)0)\n#define BTF_TYPE_EMIT_ENUM(enum_val) ((void)enum_val)\n\n \n#define KF_ACQUIRE\t(1 << 0)  \n#define KF_RELEASE\t(1 << 1)  \n#define KF_RET_NULL\t(1 << 2)  \n \n#define KF_TRUSTED_ARGS (1 << 4)  \n#define KF_SLEEPABLE    (1 << 5)  \n#define KF_DESTRUCTIVE  (1 << 6)  \n#define KF_RCU          (1 << 7)  \n \n#define KF_ITER_NEW     (1 << 8)  \n#define KF_ITER_NEXT    (1 << 9)  \n#define KF_ITER_DESTROY (1 << 10)  \n\n \n#define __bpf_kfunc __used noinline\n\n \n#define stringify_struct(x)\t\t\t\\\n\t({ BUILD_BUG_ON(sizeof(struct x) < 0);\t\\\n\t   __stringify(x); })\n\nstruct btf;\nstruct btf_member;\nstruct btf_type;\nunion bpf_attr;\nstruct btf_show;\nstruct btf_id_set;\nstruct bpf_prog;\n\ntypedef int (*btf_kfunc_filter_t)(const struct bpf_prog *prog, u32 kfunc_id);\n\nstruct btf_kfunc_id_set {\n\tstruct module *owner;\n\tstruct btf_id_set8 *set;\n\tbtf_kfunc_filter_t filter;\n};\n\nstruct btf_id_dtor_kfunc {\n\tu32 btf_id;\n\tu32 kfunc_btf_id;\n};\n\nstruct btf_struct_meta {\n\tu32 btf_id;\n\tstruct btf_record *record;\n};\n\nstruct btf_struct_metas {\n\tu32 cnt;\n\tstruct btf_struct_meta types[];\n};\n\nextern const struct file_operations btf_fops;\n\nvoid btf_get(struct btf *btf);\nvoid btf_put(struct btf *btf);\nint btf_new_fd(const union bpf_attr *attr, bpfptr_t uattr, u32 uattr_sz);\nstruct btf *btf_get_by_fd(int fd);\nint btf_get_info_by_fd(const struct btf *btf,\n\t\t       const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr);\n \nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id,\n\t\t\t\t\tu32 *ret_size);\n\n \n#define BTF_SHOW_COMPACT\tBTF_F_COMPACT\n#define BTF_SHOW_NONAME\t\tBTF_F_NONAME\n#define BTF_SHOW_PTR_RAW\tBTF_F_PTR_RAW\n#define BTF_SHOW_ZERO\t\tBTF_F_ZERO\n#define BTF_SHOW_UNSAFE\t\t(1ULL << 4)\n\nvoid btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m);\nint btf_type_seq_show_flags(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t    struct seq_file *m, u64 flags);\n\n \nint btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags);\n\nint btf_get_fd_by_id(u32 id);\nu32 btf_obj_id(const struct btf *btf);\nbool btf_is_kernel(const struct btf *btf);\nbool btf_is_module(const struct btf *btf);\nstruct module *btf_try_get_module(const struct btf *btf);\nu32 btf_nr_types(const struct btf *btf);\nbool btf_member_is_reg_int(const struct btf *btf, const struct btf_type *s,\n\t\t\t   const struct btf_member *m,\n\t\t\t   u32 expected_offset, u32 expected_size);\nstruct btf_record *btf_parse_fields(const struct btf *btf, const struct btf_type *t,\n\t\t\t\t    u32 field_mask, u32 value_size);\nint btf_check_and_fixup_fields(const struct btf *btf, struct btf_record *rec);\nbool btf_type_is_void(const struct btf_type *t);\ns32 btf_find_by_name_kind(const struct btf *btf, const char *name, u8 kind);\ns32 bpf_find_btf_id(const char *name, u32 kind, struct btf **btf_p);\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id);\nconst struct btf_type *btf_type_resolve_ptr(const struct btf *btf,\n\t\t\t\t\t    u32 id, u32 *res_id);\nconst struct btf_type *btf_type_resolve_func_ptr(const struct btf *btf,\n\t\t\t\t\t\t u32 id, u32 *res_id);\nconst struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size);\nconst char *btf_type_str(const struct btf_type *t);\n\n#define for_each_member(i, struct_type, member)\t\t\t\\\n\tfor (i = 0, member = btf_type_member(struct_type);\t\\\n\t     i < btf_type_vlen(struct_type);\t\t\t\\\n\t     i++, member++)\n\n#define for_each_vsi(i, datasec_type, member)\t\t\t\\\n\tfor (i = 0, member = btf_type_var_secinfo(datasec_type);\t\\\n\t     i < btf_type_vlen(datasec_type);\t\t\t\\\n\t     i++, member++)\n\nstatic inline bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}\n\nstatic inline bool btf_type_is_int(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_INT;\n}\n\nstatic inline bool btf_type_is_small_int(const struct btf_type *t)\n{\n\treturn btf_type_is_int(t) && t->size <= sizeof(u64);\n}\n\nstatic inline u8 btf_int_encoding(const struct btf_type *t)\n{\n\treturn BTF_INT_ENCODING(*(u32 *)(t + 1));\n}\n\nstatic inline bool btf_type_is_signed_int(const struct btf_type *t)\n{\n\treturn btf_type_is_int(t) && (btf_int_encoding(t) & BTF_INT_SIGNED);\n}\n\nstatic inline bool btf_type_is_enum(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ENUM;\n}\n\nstatic inline bool btf_is_any_enum(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ENUM ||\n\t       BTF_INFO_KIND(t->info) == BTF_KIND_ENUM64;\n}\n\nstatic inline bool btf_kind_core_compat(const struct btf_type *t1,\n\t\t\t\t\tconst struct btf_type *t2)\n{\n\treturn BTF_INFO_KIND(t1->info) == BTF_INFO_KIND(t2->info) ||\n\t       (btf_is_any_enum(t1) && btf_is_any_enum(t2));\n}\n\nstatic inline bool str_is_empty(const char *s)\n{\n\treturn !s || !s[0];\n}\n\nstatic inline u16 btf_kind(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info);\n}\n\nstatic inline bool btf_is_enum(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_ENUM;\n}\n\nstatic inline bool btf_is_enum64(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_ENUM64;\n}\n\nstatic inline u64 btf_enum64_value(const struct btf_enum64 *e)\n{\n\treturn ((u64)e->val_hi32 << 32) | e->val_lo32;\n}\n\nstatic inline bool btf_is_composite(const struct btf_type *t)\n{\n\tu16 kind = btf_kind(t);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}\n\nstatic inline bool btf_is_array(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_ARRAY;\n}\n\nstatic inline bool btf_is_int(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_INT;\n}\n\nstatic inline bool btf_is_ptr(const struct btf_type *t)\n{\n\treturn btf_kind(t) == BTF_KIND_PTR;\n}\n\nstatic inline u8 btf_int_offset(const struct btf_type *t)\n{\n\treturn BTF_INT_OFFSET(*(u32 *)(t + 1));\n}\n\nstatic inline bool btf_type_is_scalar(const struct btf_type *t)\n{\n\treturn btf_type_is_int(t) || btf_type_is_enum(t);\n}\n\nstatic inline bool btf_type_is_typedef(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_TYPEDEF;\n}\n\nstatic inline bool btf_type_is_volatile(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_VOLATILE;\n}\n\nstatic inline bool btf_type_is_func(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_FUNC;\n}\n\nstatic inline bool btf_type_is_func_proto(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_FUNC_PROTO;\n}\n\nstatic inline bool btf_type_is_var(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_VAR;\n}\n\nstatic inline bool btf_type_is_type_tag(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_TYPE_TAG;\n}\n\n \nstatic inline bool btf_type_is_struct(const struct btf_type *t)\n{\n\tu8 kind = BTF_INFO_KIND(t->info);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}\n\nstatic inline bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}\n\nstatic inline bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}\n\nstatic inline u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}\n\nstatic inline u16 btf_vlen(const struct btf_type *t)\n{\n\treturn btf_type_vlen(t);\n}\n\nstatic inline u16 btf_func_linkage(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}\n\nstatic inline bool btf_type_kflag(const struct btf_type *t)\n{\n\treturn BTF_INFO_KFLAG(t->info);\n}\n\nstatic inline u32 __btf_member_bit_offset(const struct btf_type *struct_type,\n\t\t\t\t\t  const struct btf_member *member)\n{\n\treturn btf_type_kflag(struct_type) ? BTF_MEMBER_BIT_OFFSET(member->offset)\n\t\t\t\t\t   : member->offset;\n}\n\nstatic inline u32 __btf_member_bitfield_size(const struct btf_type *struct_type,\n\t\t\t\t\t     const struct btf_member *member)\n{\n\treturn btf_type_kflag(struct_type) ? BTF_MEMBER_BITFIELD_SIZE(member->offset)\n\t\t\t\t\t   : 0;\n}\n\nstatic inline struct btf_member *btf_members(const struct btf_type *t)\n{\n\treturn (struct btf_member *)(t + 1);\n}\n\nstatic inline u32 btf_member_bit_offset(const struct btf_type *t, u32 member_idx)\n{\n\tconst struct btf_member *m = btf_members(t) + member_idx;\n\n\treturn __btf_member_bit_offset(t, m);\n}\n\nstatic inline u32 btf_member_bitfield_size(const struct btf_type *t, u32 member_idx)\n{\n\tconst struct btf_member *m = btf_members(t) + member_idx;\n\n\treturn __btf_member_bitfield_size(t, m);\n}\n\nstatic inline const struct btf_member *btf_type_member(const struct btf_type *t)\n{\n\treturn (const struct btf_member *)(t + 1);\n}\n\nstatic inline struct btf_array *btf_array(const struct btf_type *t)\n{\n\treturn (struct btf_array *)(t + 1);\n}\n\nstatic inline struct btf_enum *btf_enum(const struct btf_type *t)\n{\n\treturn (struct btf_enum *)(t + 1);\n}\n\nstatic inline struct btf_enum64 *btf_enum64(const struct btf_type *t)\n{\n\treturn (struct btf_enum64 *)(t + 1);\n}\n\nstatic inline const struct btf_var_secinfo *btf_type_var_secinfo(\n\t\tconst struct btf_type *t)\n{\n\treturn (const struct btf_var_secinfo *)(t + 1);\n}\n\nstatic inline struct btf_param *btf_params(const struct btf_type *t)\n{\n\treturn (struct btf_param *)(t + 1);\n}\n\nstatic inline int btf_id_cmp_func(const void *a, const void *b)\n{\n\tconst int *pa = a, *pb = b;\n\n\treturn *pa - *pb;\n}\n\nstatic inline bool btf_id_set_contains(const struct btf_id_set *set, u32 id)\n{\n\treturn bsearch(&id, set->ids, set->cnt, sizeof(u32), btf_id_cmp_func) != NULL;\n}\n\nstatic inline void *btf_id_set8_contains(const struct btf_id_set8 *set, u32 id)\n{\n\treturn bsearch(&id, set->pairs, set->cnt, sizeof(set->pairs[0]), btf_id_cmp_func);\n}\n\nstruct bpf_verifier_log;\n\n#ifdef CONFIG_BPF_SYSCALL\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id);\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset);\nstruct btf *btf_parse_vmlinux(void);\nstruct btf *bpf_prog_get_target_btf(const struct bpf_prog *prog);\nu32 *btf_kfunc_id_set_contains(const struct btf *btf, u32 kfunc_btf_id,\n\t\t\t       const struct bpf_prog *prog);\nu32 *btf_kfunc_is_modify_return(const struct btf *btf, u32 kfunc_btf_id,\n\t\t\t\tconst struct bpf_prog *prog);\nint register_btf_kfunc_id_set(enum bpf_prog_type prog_type,\n\t\t\t      const struct btf_kfunc_id_set *s);\nint register_btf_fmodret_id_set(const struct btf_kfunc_id_set *kset);\ns32 btf_find_dtor_kfunc(struct btf *btf, u32 btf_id);\nint register_btf_id_dtor_kfuncs(const struct btf_id_dtor_kfunc *dtors, u32 add_cnt,\n\t\t\t\tstruct module *owner);\nstruct btf_struct_meta *btf_find_struct_meta(const struct btf *btf, u32 btf_id);\nconst struct btf_member *\nbtf_get_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, enum bpf_prog_type prog_type,\n\t\t      int arg);\nint get_kern_ctx_btf_id(struct bpf_verifier_log *log, enum bpf_prog_type prog_type);\nbool btf_types_are_same(const struct btf *btf1, u32 id1,\n\t\t\tconst struct btf *btf2, u32 id2);\n#else\nstatic inline const struct btf_type *btf_type_by_id(const struct btf *btf,\n\t\t\t\t\t\t    u32 type_id)\n{\n\treturn NULL;\n}\nstatic inline const char *btf_name_by_offset(const struct btf *btf,\n\t\t\t\t\t     u32 offset)\n{\n\treturn NULL;\n}\nstatic inline u32 *btf_kfunc_id_set_contains(const struct btf *btf,\n\t\t\t\t\t     u32 kfunc_btf_id,\n\t\t\t\t\t     struct bpf_prog *prog)\n\n{\n\treturn NULL;\n}\nstatic inline int register_btf_kfunc_id_set(enum bpf_prog_type prog_type,\n\t\t\t\t\t    const struct btf_kfunc_id_set *s)\n{\n\treturn 0;\n}\nstatic inline s32 btf_find_dtor_kfunc(struct btf *btf, u32 btf_id)\n{\n\treturn -ENOENT;\n}\nstatic inline int register_btf_id_dtor_kfuncs(const struct btf_id_dtor_kfunc *dtors,\n\t\t\t\t\t      u32 add_cnt, struct module *owner)\n{\n\treturn 0;\n}\nstatic inline struct btf_struct_meta *btf_find_struct_meta(const struct btf *btf, u32 btf_id)\n{\n\treturn NULL;\n}\nstatic inline const struct btf_member *\nbtf_get_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, enum bpf_prog_type prog_type,\n\t\t      int arg)\n{\n\treturn NULL;\n}\nstatic inline int get_kern_ctx_btf_id(struct bpf_verifier_log *log,\n\t\t\t\t      enum bpf_prog_type prog_type) {\n\treturn -EINVAL;\n}\nstatic inline bool btf_types_are_same(const struct btf *btf1, u32 id1,\n\t\t\t\t      const struct btf *btf2, u32 id2)\n{\n\treturn false;\n}\n#endif\n\nstatic inline bool btf_type_is_struct_ptr(struct btf *btf, const struct btf_type *t)\n{\n\tif (!btf_type_is_ptr(t))\n\t\treturn false;\n\n\tt = btf_type_skip_modifiers(btf, t->type, NULL);\n\n\treturn btf_type_is_struct(t);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}