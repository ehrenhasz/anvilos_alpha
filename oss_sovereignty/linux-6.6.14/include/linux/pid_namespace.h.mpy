{
  "module_name": "pid_namespace.h",
  "hash_id": "bf9d1e7272b13352ee7c28b1ae5f81bf85c1fcd8b94fecb77eec6b30f100e225",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/pid_namespace.h",
  "human_readable_source": " \n#ifndef _LINUX_PID_NS_H\n#define _LINUX_PID_NS_H\n\n#include <linux/sched.h>\n#include <linux/bug.h>\n#include <linux/mm.h>\n#include <linux/workqueue.h>\n#include <linux/threads.h>\n#include <linux/nsproxy.h>\n#include <linux/ns_common.h>\n#include <linux/idr.h>\n\n \n#define MAX_PID_NS_LEVEL 32\n\nstruct fs_pin;\n\n#if defined(CONFIG_SYSCTL) && defined(CONFIG_MEMFD_CREATE)\n \n#define MEMFD_NOEXEC_SCOPE_EXEC\t\t\t0  \n#define MEMFD_NOEXEC_SCOPE_NOEXEC_SEAL\t\t1  \n#define MEMFD_NOEXEC_SCOPE_NOEXEC_ENFORCED\t2  \n#endif\n\nstruct pid_namespace {\n\tstruct idr idr;\n\tstruct rcu_head rcu;\n\tunsigned int pid_allocated;\n\tstruct task_struct *child_reaper;\n\tstruct kmem_cache *pid_cachep;\n\tunsigned int level;\n\tstruct pid_namespace *parent;\n#ifdef CONFIG_BSD_PROCESS_ACCT\n\tstruct fs_pin *bacct;\n#endif\n\tstruct user_namespace *user_ns;\n\tstruct ucounts *ucounts;\n\tint reboot;\t \n\tstruct ns_common ns;\n#if defined(CONFIG_SYSCTL) && defined(CONFIG_MEMFD_CREATE)\n\tint memfd_noexec_scope;\n#endif\n} __randomize_layout;\n\nextern struct pid_namespace init_pid_ns;\n\n#define PIDNS_ADDING (1U << 31)\n\n#ifdef CONFIG_PID_NS\nstatic inline struct pid_namespace *get_pid_ns(struct pid_namespace *ns)\n{\n\tif (ns != &init_pid_ns)\n\t\trefcount_inc(&ns->ns.count);\n\treturn ns;\n}\n\n#if defined(CONFIG_SYSCTL) && defined(CONFIG_MEMFD_CREATE)\nstatic inline int pidns_memfd_noexec_scope(struct pid_namespace *ns)\n{\n\tint scope = MEMFD_NOEXEC_SCOPE_EXEC;\n\n\tfor (; ns; ns = ns->parent)\n\t\tscope = max(scope, READ_ONCE(ns->memfd_noexec_scope));\n\n\treturn scope;\n}\n#else\nstatic inline int pidns_memfd_noexec_scope(struct pid_namespace *ns)\n{\n\treturn 0;\n}\n#endif\n\nextern struct pid_namespace *copy_pid_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct pid_namespace *ns);\nextern void zap_pid_ns_processes(struct pid_namespace *pid_ns);\nextern int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd);\nextern void put_pid_ns(struct pid_namespace *ns);\n\n#else  \n#include <linux/err.h>\n\nstatic inline struct pid_namespace *get_pid_ns(struct pid_namespace *ns)\n{\n\treturn ns;\n}\n\nstatic inline int pidns_memfd_noexec_scope(struct pid_namespace *ns)\n{\n\treturn 0;\n}\n\nstatic inline struct pid_namespace *copy_pid_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct pid_namespace *ns)\n{\n\tif (flags & CLONE_NEWPID)\n\t\tns = ERR_PTR(-EINVAL);\n\treturn ns;\n}\n\nstatic inline void put_pid_ns(struct pid_namespace *ns)\n{\n}\n\nstatic inline void zap_pid_ns_processes(struct pid_namespace *ns)\n{\n\tBUG();\n}\n\nstatic inline int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)\n{\n\treturn 0;\n}\n#endif  \n\nextern struct pid_namespace *task_active_pid_ns(struct task_struct *tsk);\nvoid pidhash_init(void);\nvoid pid_idr_init(void);\n\nstatic inline bool task_is_in_init_pid_ns(struct task_struct *tsk)\n{\n\treturn task_active_pid_ns(tsk) == &init_pid_ns;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}