{
  "module_name": "fs.h",
  "hash_id": "504498d6af126a9bf86f8a7c14569cefe17dabd5d92ce06abf44fd7b62abe6b2",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fs.h",
  "human_readable_source": " \n#ifndef _LINUX_FS_H\n#define _LINUX_FS_H\n\n#include <linux/linkage.h>\n#include <linux/wait_bit.h>\n#include <linux/kdev_t.h>\n#include <linux/dcache.h>\n#include <linux/path.h>\n#include <linux/stat.h>\n#include <linux/cache.h>\n#include <linux/list.h>\n#include <linux/list_lru.h>\n#include <linux/llist.h>\n#include <linux/radix-tree.h>\n#include <linux/xarray.h>\n#include <linux/rbtree.h>\n#include <linux/init.h>\n#include <linux/pid.h>\n#include <linux/bug.h>\n#include <linux/mutex.h>\n#include <linux/rwsem.h>\n#include <linux/mm_types.h>\n#include <linux/capability.h>\n#include <linux/semaphore.h>\n#include <linux/fcntl.h>\n#include <linux/rculist_bl.h>\n#include <linux/atomic.h>\n#include <linux/shrinker.h>\n#include <linux/migrate_mode.h>\n#include <linux/uidgid.h>\n#include <linux/lockdep.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/workqueue.h>\n#include <linux/delayed_call.h>\n#include <linux/uuid.h>\n#include <linux/errseq.h>\n#include <linux/ioprio.h>\n#include <linux/fs_types.h>\n#include <linux/build_bug.h>\n#include <linux/stddef.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/mnt_idmapping.h>\n#include <linux/slab.h>\n\n#include <asm/byteorder.h>\n#include <uapi/linux/fs.h>\n\nstruct backing_dev_info;\nstruct bdi_writeback;\nstruct bio;\nstruct io_comp_batch;\nstruct export_operations;\nstruct fiemap_extent_info;\nstruct hd_geometry;\nstruct iovec;\nstruct kiocb;\nstruct kobject;\nstruct pipe_inode_info;\nstruct poll_table_struct;\nstruct kstatfs;\nstruct vm_area_struct;\nstruct vfsmount;\nstruct cred;\nstruct swap_info_struct;\nstruct seq_file;\nstruct workqueue_struct;\nstruct iov_iter;\nstruct fscrypt_info;\nstruct fscrypt_operations;\nstruct fsverity_info;\nstruct fsverity_operations;\nstruct fs_context;\nstruct fs_parameter_spec;\nstruct fileattr;\nstruct iomap_ops;\n\nextern void __init inode_init(void);\nextern void __init inode_init_early(void);\nextern void __init files_init(void);\nextern void __init files_maxfiles_init(void);\n\nextern unsigned long get_max_files(void);\nextern unsigned int sysctl_nr_open;\n\ntypedef __kernel_rwf_t rwf_t;\n\nstruct buffer_head;\ntypedef int (get_block_t)(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create);\ntypedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,\n\t\t\tssize_t bytes, void *private);\n\n#define MAY_EXEC\t\t0x00000001\n#define MAY_WRITE\t\t0x00000002\n#define MAY_READ\t\t0x00000004\n#define MAY_APPEND\t\t0x00000008\n#define MAY_ACCESS\t\t0x00000010\n#define MAY_OPEN\t\t0x00000020\n#define MAY_CHDIR\t\t0x00000040\n \n#define MAY_NOT_BLOCK\t\t0x00000080\n\n \n\n \n#define FMODE_READ\t\t((__force fmode_t)0x1)\n \n#define FMODE_WRITE\t\t((__force fmode_t)0x2)\n \n#define FMODE_LSEEK\t\t((__force fmode_t)0x4)\n \n#define FMODE_PREAD\t\t((__force fmode_t)0x8)\n \n#define FMODE_PWRITE\t\t((__force fmode_t)0x10)\n \n#define FMODE_EXEC\t\t((__force fmode_t)0x20)\n \n#define FMODE_32BITHASH         ((__force fmode_t)0x200)\n \n#define FMODE_64BITHASH         ((__force fmode_t)0x400)\n\n \n#define FMODE_NOCMTIME\t\t((__force fmode_t)0x800)\n\n \n#define FMODE_RANDOM\t\t((__force fmode_t)0x1000)\n\n \n#define FMODE_UNSIGNED_OFFSET\t((__force fmode_t)0x2000)\n\n \n#define FMODE_PATH\t\t((__force fmode_t)0x4000)\n\n \n#define FMODE_ATOMIC_POS\t((__force fmode_t)0x8000)\n \n#define FMODE_WRITER\t\t((__force fmode_t)0x10000)\n \n#define FMODE_CAN_READ          ((__force fmode_t)0x20000)\n \n#define FMODE_CAN_WRITE         ((__force fmode_t)0x40000)\n\n#define FMODE_OPENED\t\t((__force fmode_t)0x80000)\n#define FMODE_CREATED\t\t((__force fmode_t)0x100000)\n\n \n#define FMODE_STREAM\t\t((__force fmode_t)0x200000)\n\n \n#define\tFMODE_CAN_ODIRECT\t((__force fmode_t)0x400000)\n\n#define\tFMODE_NOREUSE\t\t((__force fmode_t)0x800000)\n\n \n#define FMODE_DIO_PARALLEL_WRITE\t((__force fmode_t)0x1000000)\n\n \n#define FMODE_BACKING\t\t((__force fmode_t)0x2000000)\n\n \n#define FMODE_NONOTIFY\t\t((__force fmode_t)0x4000000)\n\n \n#define FMODE_NOWAIT\t\t((__force fmode_t)0x8000000)\n\n \n#define FMODE_NEED_UNMOUNT\t((__force fmode_t)0x10000000)\n\n \n#define FMODE_NOACCOUNT\t\t((__force fmode_t)0x20000000)\n\n \n#define FMODE_BUF_RASYNC\t((__force fmode_t)0x40000000)\n\n \n#define FMODE_BUF_WASYNC\t((__force fmode_t)0x80000000)\n\n \n#define ATTR_MODE\t(1 << 0)\n#define ATTR_UID\t(1 << 1)\n#define ATTR_GID\t(1 << 2)\n#define ATTR_SIZE\t(1 << 3)\n#define ATTR_ATIME\t(1 << 4)\n#define ATTR_MTIME\t(1 << 5)\n#define ATTR_CTIME\t(1 << 6)\n#define ATTR_ATIME_SET\t(1 << 7)\n#define ATTR_MTIME_SET\t(1 << 8)\n#define ATTR_FORCE\t(1 << 9)  \n#define ATTR_KILL_SUID\t(1 << 11)\n#define ATTR_KILL_SGID\t(1 << 12)\n#define ATTR_FILE\t(1 << 13)\n#define ATTR_KILL_PRIV\t(1 << 14)\n#define ATTR_OPEN\t(1 << 15)  \n#define ATTR_TIMES_SET\t(1 << 16)\n#define ATTR_TOUCH\t(1 << 17)\n\n \n#define WHITEOUT_MODE 0\n#define WHITEOUT_DEV 0\n\n \nstruct iattr {\n\tunsigned int\tia_valid;\n\tumode_t\t\tia_mode;\n\t \n\tunion {\n\t\tkuid_t\t\tia_uid;\n\t\tvfsuid_t\tia_vfsuid;\n\t};\n\tunion {\n\t\tkgid_t\t\tia_gid;\n\t\tvfsgid_t\tia_vfsgid;\n\t};\n\tloff_t\t\tia_size;\n\tstruct timespec64 ia_atime;\n\tstruct timespec64 ia_mtime;\n\tstruct timespec64 ia_ctime;\n\n\t \n\tstruct file\t*ia_file;\n};\n\n \n#include <linux/quota.h>\n\n \n#define FILESYSTEM_MAX_STACK_DEPTH 2\n\n \n\nenum positive_aop_returns {\n\tAOP_WRITEPAGE_ACTIVATE\t= 0x80000,\n\tAOP_TRUNCATED_PAGE\t= 0x80001,\n};\n\n \nstruct page;\nstruct address_space;\nstruct writeback_control;\nstruct readahead_control;\n\n \nenum rw_hint {\n\tWRITE_LIFE_NOT_SET\t= 0,\n\tWRITE_LIFE_NONE\t\t= RWH_WRITE_LIFE_NONE,\n\tWRITE_LIFE_SHORT\t= RWH_WRITE_LIFE_SHORT,\n\tWRITE_LIFE_MEDIUM\t= RWH_WRITE_LIFE_MEDIUM,\n\tWRITE_LIFE_LONG\t\t= RWH_WRITE_LIFE_LONG,\n\tWRITE_LIFE_EXTREME\t= RWH_WRITE_LIFE_EXTREME,\n};\n\n \n#define IOCB_HIPRI\t\t(__force int) RWF_HIPRI\n#define IOCB_DSYNC\t\t(__force int) RWF_DSYNC\n#define IOCB_SYNC\t\t(__force int) RWF_SYNC\n#define IOCB_NOWAIT\t\t(__force int) RWF_NOWAIT\n#define IOCB_APPEND\t\t(__force int) RWF_APPEND\n\n \n#define IOCB_EVENTFD\t\t(1 << 16)\n#define IOCB_DIRECT\t\t(1 << 17)\n#define IOCB_WRITE\t\t(1 << 18)\n \n#define IOCB_WAITQ\t\t(1 << 19)\n#define IOCB_NOIO\t\t(1 << 20)\n \n#define IOCB_ALLOC_CACHE\t(1 << 21)\n \n#define IOCB_DIO_CALLER_COMP\t(1 << 22)\n\n \n#define TRACE_IOCB_STRINGS \\\n\t{ IOCB_HIPRI,\t\t\"HIPRI\" }, \\\n\t{ IOCB_DSYNC,\t\t\"DSYNC\" }, \\\n\t{ IOCB_SYNC,\t\t\"SYNC\" }, \\\n\t{ IOCB_NOWAIT,\t\t\"NOWAIT\" }, \\\n\t{ IOCB_APPEND,\t\t\"APPEND\" }, \\\n\t{ IOCB_EVENTFD,\t\t\"EVENTFD\"}, \\\n\t{ IOCB_DIRECT,\t\t\"DIRECT\" }, \\\n\t{ IOCB_WRITE,\t\t\"WRITE\" }, \\\n\t{ IOCB_WAITQ,\t\t\"WAITQ\" }, \\\n\t{ IOCB_NOIO,\t\t\"NOIO\" }, \\\n\t{ IOCB_ALLOC_CACHE,\t\"ALLOC_CACHE\" }, \\\n\t{ IOCB_DIO_CALLER_COMP,\t\"CALLER_COMP\" }\n\nstruct kiocb {\n\tstruct file\t\t*ki_filp;\n\tloff_t\t\t\tki_pos;\n\tvoid (*ki_complete)(struct kiocb *iocb, long ret);\n\tvoid\t\t\t*private;\n\tint\t\t\tki_flags;\n\tu16\t\t\tki_ioprio;  \n\tunion {\n\t\t \n\t\tstruct wait_page_queue\t*ki_waitq;\n\t\t \n\t\tssize_t (*dio_complete)(void *data);\n\t};\n};\n\nstatic inline bool is_sync_kiocb(struct kiocb *kiocb)\n{\n\treturn kiocb->ki_complete == NULL;\n}\n\nstruct address_space_operations {\n\tint (*writepage)(struct page *page, struct writeback_control *wbc);\n\tint (*read_folio)(struct file *, struct folio *);\n\n\t \n\tint (*writepages)(struct address_space *, struct writeback_control *);\n\n\t \n\tbool (*dirty_folio)(struct address_space *, struct folio *);\n\n\tvoid (*readahead)(struct readahead_control *);\n\n\tint (*write_begin)(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len,\n\t\t\t\tstruct page **pagep, void **fsdata);\n\tint (*write_end)(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata);\n\n\t \n\tsector_t (*bmap)(struct address_space *, sector_t);\n\tvoid (*invalidate_folio) (struct folio *, size_t offset, size_t len);\n\tbool (*release_folio)(struct folio *, gfp_t);\n\tvoid (*free_folio)(struct folio *folio);\n\tssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);\n\t \n\tint (*migrate_folio)(struct address_space *, struct folio *dst,\n\t\t\tstruct folio *src, enum migrate_mode);\n\tint (*launder_folio)(struct folio *);\n\tbool (*is_partially_uptodate) (struct folio *, size_t from,\n\t\t\tsize_t count);\n\tvoid (*is_dirty_writeback) (struct folio *, bool *dirty, bool *wb);\n\tint (*error_remove_page)(struct address_space *, struct page *);\n\n\t \n\tint (*swap_activate)(struct swap_info_struct *sis, struct file *file,\n\t\t\t\tsector_t *span);\n\tvoid (*swap_deactivate)(struct file *file);\n\tint (*swap_rw)(struct kiocb *iocb, struct iov_iter *iter);\n};\n\nextern const struct address_space_operations empty_aops;\n\n \nstruct address_space {\n\tstruct inode\t\t*host;\n\tstruct xarray\t\ti_pages;\n\tstruct rw_semaphore\tinvalidate_lock;\n\tgfp_t\t\t\tgfp_mask;\n\tatomic_t\t\ti_mmap_writable;\n#ifdef CONFIG_READ_ONLY_THP_FOR_FS\n\t \n\tatomic_t\t\tnr_thps;\n#endif\n\tstruct rb_root_cached\ti_mmap;\n\tunsigned long\t\tnrpages;\n\tpgoff_t\t\t\twriteback_index;\n\tconst struct address_space_operations *a_ops;\n\tunsigned long\t\tflags;\n\tstruct rw_semaphore\ti_mmap_rwsem;\n\terrseq_t\t\twb_err;\n\tspinlock_t\t\tprivate_lock;\n\tstruct list_head\tprivate_list;\n\tvoid\t\t\t*private_data;\n} __attribute__((aligned(sizeof(long)))) __randomize_layout;\n\t \n\n \n#define PAGECACHE_TAG_DIRTY\tXA_MARK_0\n#define PAGECACHE_TAG_WRITEBACK\tXA_MARK_1\n#define PAGECACHE_TAG_TOWRITE\tXA_MARK_2\n\n \nstatic inline bool mapping_tagged(struct address_space *mapping, xa_mark_t tag)\n{\n\treturn xa_marked(&mapping->i_pages, tag);\n}\n\nstatic inline void i_mmap_lock_write(struct address_space *mapping)\n{\n\tdown_write(&mapping->i_mmap_rwsem);\n}\n\nstatic inline int i_mmap_trylock_write(struct address_space *mapping)\n{\n\treturn down_write_trylock(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_unlock_write(struct address_space *mapping)\n{\n\tup_write(&mapping->i_mmap_rwsem);\n}\n\nstatic inline int i_mmap_trylock_read(struct address_space *mapping)\n{\n\treturn down_read_trylock(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_lock_read(struct address_space *mapping)\n{\n\tdown_read(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_unlock_read(struct address_space *mapping)\n{\n\tup_read(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_assert_locked(struct address_space *mapping)\n{\n\tlockdep_assert_held(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_assert_write_locked(struct address_space *mapping)\n{\n\tlockdep_assert_held_write(&mapping->i_mmap_rwsem);\n}\n\n \nstatic inline int mapping_mapped(struct address_space *mapping)\n{\n\treturn\t!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root);\n}\n\n \nstatic inline int mapping_writably_mapped(struct address_space *mapping)\n{\n\treturn atomic_read(&mapping->i_mmap_writable) > 0;\n}\n\nstatic inline int mapping_map_writable(struct address_space *mapping)\n{\n\treturn atomic_inc_unless_negative(&mapping->i_mmap_writable) ?\n\t\t0 : -EPERM;\n}\n\nstatic inline void mapping_unmap_writable(struct address_space *mapping)\n{\n\tatomic_dec(&mapping->i_mmap_writable);\n}\n\nstatic inline int mapping_deny_writable(struct address_space *mapping)\n{\n\treturn atomic_dec_unless_positive(&mapping->i_mmap_writable) ?\n\t\t0 : -EBUSY;\n}\n\nstatic inline void mapping_allow_writable(struct address_space *mapping)\n{\n\tatomic_inc(&mapping->i_mmap_writable);\n}\n\n \n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n#include <linux/seqlock.h>\n#define __NEED_I_SIZE_ORDERED\n#define i_size_ordered_init(inode) seqcount_init(&inode->i_size_seqcount)\n#else\n#define i_size_ordered_init(inode) do { } while (0)\n#endif\n\nstruct posix_acl;\n#define ACL_NOT_CACHED ((void *)(-1))\n \n#define ACL_DONT_CACHE ((void *)(-3))\n\nstatic inline struct posix_acl *\nuncached_acl_sentinel(struct task_struct *task)\n{\n\treturn (void *)task + 1;\n}\n\nstatic inline bool\nis_uncached_acl(struct posix_acl *acl)\n{\n\treturn (long)acl & 1;\n}\n\n#define IOP_FASTPERM\t0x0001\n#define IOP_LOOKUP\t0x0002\n#define IOP_NOFOLLOW\t0x0004\n#define IOP_XATTR\t0x0008\n#define IOP_DEFAULT_READLINK\t0x0010\n\nstruct fsnotify_mark_connector;\n\n \nstruct inode {\n\tumode_t\t\t\ti_mode;\n\tunsigned short\t\ti_opflags;\n\tkuid_t\t\t\ti_uid;\n\tkgid_t\t\t\ti_gid;\n\tunsigned int\t\ti_flags;\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl\t*i_acl;\n\tstruct posix_acl\t*i_default_acl;\n#endif\n\n\tconst struct inode_operations\t*i_op;\n\tstruct super_block\t*i_sb;\n\tstruct address_space\t*i_mapping;\n\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*i_security;\n#endif\n\n\t \n\tunsigned long\t\ti_ino;\n\t \n\tunion {\n\t\tconst unsigned int i_nlink;\n\t\tunsigned int __i_nlink;\n\t};\n\tdev_t\t\t\ti_rdev;\n\tloff_t\t\t\ti_size;\n\tstruct timespec64\ti_atime;\n\tstruct timespec64\ti_mtime;\n\tstruct timespec64\t__i_ctime;  \n\tspinlock_t\t\ti_lock;\t \n\tunsigned short          i_bytes;\n\tu8\t\t\ti_blkbits;\n\tu8\t\t\ti_write_hint;\n\tblkcnt_t\t\ti_blocks;\n\n#ifdef __NEED_I_SIZE_ORDERED\n\tseqcount_t\t\ti_size_seqcount;\n#endif\n\n\t \n\tunsigned long\t\ti_state;\n\tstruct rw_semaphore\ti_rwsem;\n\n\tunsigned long\t\tdirtied_when;\t \n\tunsigned long\t\tdirtied_time_when;\n\n\tstruct hlist_node\ti_hash;\n\tstruct list_head\ti_io_list;\t \n#ifdef CONFIG_CGROUP_WRITEBACK\n\tstruct bdi_writeback\t*i_wb;\t\t \n\n\t \n\tint\t\t\ti_wb_frn_winner;\n\tu16\t\t\ti_wb_frn_avg_time;\n\tu16\t\t\ti_wb_frn_history;\n#endif\n\tstruct list_head\ti_lru;\t\t \n\tstruct list_head\ti_sb_list;\n\tstruct list_head\ti_wb_list;\t \n\tunion {\n\t\tstruct hlist_head\ti_dentry;\n\t\tstruct rcu_head\t\ti_rcu;\n\t};\n\tatomic64_t\t\ti_version;\n\tatomic64_t\t\ti_sequence;  \n\tatomic_t\t\ti_count;\n\tatomic_t\t\ti_dio_count;\n\tatomic_t\t\ti_writecount;\n#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)\n\tatomic_t\t\ti_readcount;  \n#endif\n\tunion {\n\t\tconst struct file_operations\t*i_fop;\t \n\t\tvoid (*free_inode)(struct inode *);\n\t};\n\tstruct file_lock_context\t*i_flctx;\n\tstruct address_space\ti_data;\n\tstruct list_head\ti_devices;\n\tunion {\n\t\tstruct pipe_inode_info\t*i_pipe;\n\t\tstruct cdev\t\t*i_cdev;\n\t\tchar\t\t\t*i_link;\n\t\tunsigned\t\ti_dir_seq;\n\t};\n\n\t__u32\t\t\ti_generation;\n\n#ifdef CONFIG_FSNOTIFY\n\t__u32\t\t\ti_fsnotify_mask;  \n\tstruct fsnotify_mark_connector __rcu\t*i_fsnotify_marks;\n#endif\n\n#ifdef CONFIG_FS_ENCRYPTION\n\tstruct fscrypt_info\t*i_crypt_info;\n#endif\n\n#ifdef CONFIG_FS_VERITY\n\tstruct fsverity_info\t*i_verity_info;\n#endif\n\n\tvoid\t\t\t*i_private;  \n} __randomize_layout;\n\nstruct timespec64 timestamp_truncate(struct timespec64 t, struct inode *inode);\n\nstatic inline unsigned int i_blocksize(const struct inode *node)\n{\n\treturn (1 << node->i_blkbits);\n}\n\nstatic inline int inode_unhashed(struct inode *inode)\n{\n\treturn hlist_unhashed(&inode->i_hash);\n}\n\n \nstatic inline void inode_fake_hash(struct inode *inode)\n{\n\thlist_add_fake(&inode->i_hash);\n}\n\n \nenum inode_i_mutex_lock_class\n{\n\tI_MUTEX_NORMAL,\n\tI_MUTEX_PARENT,\n\tI_MUTEX_CHILD,\n\tI_MUTEX_XATTR,\n\tI_MUTEX_NONDIR2,\n\tI_MUTEX_PARENT2,\n};\n\nstatic inline void inode_lock(struct inode *inode)\n{\n\tdown_write(&inode->i_rwsem);\n}\n\nstatic inline void inode_unlock(struct inode *inode)\n{\n\tup_write(&inode->i_rwsem);\n}\n\nstatic inline void inode_lock_shared(struct inode *inode)\n{\n\tdown_read(&inode->i_rwsem);\n}\n\nstatic inline void inode_unlock_shared(struct inode *inode)\n{\n\tup_read(&inode->i_rwsem);\n}\n\nstatic inline int inode_trylock(struct inode *inode)\n{\n\treturn down_write_trylock(&inode->i_rwsem);\n}\n\nstatic inline int inode_trylock_shared(struct inode *inode)\n{\n\treturn down_read_trylock(&inode->i_rwsem);\n}\n\nstatic inline int inode_is_locked(struct inode *inode)\n{\n\treturn rwsem_is_locked(&inode->i_rwsem);\n}\n\nstatic inline void inode_lock_nested(struct inode *inode, unsigned subclass)\n{\n\tdown_write_nested(&inode->i_rwsem, subclass);\n}\n\nstatic inline void inode_lock_shared_nested(struct inode *inode, unsigned subclass)\n{\n\tdown_read_nested(&inode->i_rwsem, subclass);\n}\n\nstatic inline void filemap_invalidate_lock(struct address_space *mapping)\n{\n\tdown_write(&mapping->invalidate_lock);\n}\n\nstatic inline void filemap_invalidate_unlock(struct address_space *mapping)\n{\n\tup_write(&mapping->invalidate_lock);\n}\n\nstatic inline void filemap_invalidate_lock_shared(struct address_space *mapping)\n{\n\tdown_read(&mapping->invalidate_lock);\n}\n\nstatic inline int filemap_invalidate_trylock_shared(\n\t\t\t\t\tstruct address_space *mapping)\n{\n\treturn down_read_trylock(&mapping->invalidate_lock);\n}\n\nstatic inline void filemap_invalidate_unlock_shared(\n\t\t\t\t\tstruct address_space *mapping)\n{\n\tup_read(&mapping->invalidate_lock);\n}\n\nvoid lock_two_nondirectories(struct inode *, struct inode*);\nvoid unlock_two_nondirectories(struct inode *, struct inode*);\n\nvoid filemap_invalidate_lock_two(struct address_space *mapping1,\n\t\t\t\t struct address_space *mapping2);\nvoid filemap_invalidate_unlock_two(struct address_space *mapping1,\n\t\t\t\t   struct address_space *mapping2);\n\n\n \nstatic inline loff_t i_size_read(const struct inode *inode)\n{\n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n\tloff_t i_size;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&inode->i_size_seqcount);\n\t\ti_size = inode->i_size;\n\t} while (read_seqcount_retry(&inode->i_size_seqcount, seq));\n\treturn i_size;\n#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPTION)\n\tloff_t i_size;\n\n\tpreempt_disable();\n\ti_size = inode->i_size;\n\tpreempt_enable();\n\treturn i_size;\n#else\n\treturn inode->i_size;\n#endif\n}\n\n \nstatic inline void i_size_write(struct inode *inode, loff_t i_size)\n{\n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n\tpreempt_disable();\n\twrite_seqcount_begin(&inode->i_size_seqcount);\n\tinode->i_size = i_size;\n\twrite_seqcount_end(&inode->i_size_seqcount);\n\tpreempt_enable();\n#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPTION)\n\tpreempt_disable();\n\tinode->i_size = i_size;\n\tpreempt_enable();\n#else\n\tinode->i_size = i_size;\n#endif\n}\n\nstatic inline unsigned iminor(const struct inode *inode)\n{\n\treturn MINOR(inode->i_rdev);\n}\n\nstatic inline unsigned imajor(const struct inode *inode)\n{\n\treturn MAJOR(inode->i_rdev);\n}\n\nstruct fown_struct {\n\trwlock_t lock;           \n\tstruct pid *pid;\t \n\tenum pid_type pid_type;\t \n\tkuid_t uid, euid;\t \n\tint signum;\t\t \n};\n\n \nstruct file_ra_state {\n\tpgoff_t start;\n\tunsigned int size;\n\tunsigned int async_size;\n\tunsigned int ra_pages;\n\tunsigned int mmap_miss;\n\tloff_t prev_pos;\n};\n\n \nstatic inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n{\n\treturn (index >= ra->start &&\n\t\tindex <  ra->start + ra->size);\n}\n\n \nstruct file {\n\tunion {\n\t\tstruct llist_node\tf_llist;\n\t\tstruct rcu_head \tf_rcuhead;\n\t\tunsigned int \t\tf_iocb_flags;\n\t};\n\n\t \n\tspinlock_t\t\tf_lock;\n\tfmode_t\t\t\tf_mode;\n\tatomic_long_t\t\tf_count;\n\tstruct mutex\t\tf_pos_lock;\n\tloff_t\t\t\tf_pos;\n\tunsigned int\t\tf_flags;\n\tstruct fown_struct\tf_owner;\n\tconst struct cred\t*f_cred;\n\tstruct file_ra_state\tf_ra;\n\tstruct path\t\tf_path;\n\tstruct inode\t\t*f_inode;\t \n\tconst struct file_operations\t*f_op;\n\n\tu64\t\t\tf_version;\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*f_security;\n#endif\n\t \n\tvoid\t\t\t*private_data;\n\n#ifdef CONFIG_EPOLL\n\t \n\tstruct hlist_head\t*f_ep;\n#endif  \n\tstruct address_space\t*f_mapping;\n\terrseq_t\t\tf_wb_err;\n\terrseq_t\t\tf_sb_err;  \n} __randomize_layout\n  __attribute__((aligned(4)));\t \n\nstruct file_handle {\n\t__u32 handle_bytes;\n\tint handle_type;\n\t \n\tunsigned char f_handle[];\n};\n\nstatic inline struct file *get_file(struct file *f)\n{\n\tatomic_long_inc(&f->f_count);\n\treturn f;\n}\n#define get_file_rcu(x) atomic_long_inc_not_zero(&(x)->f_count)\n#define file_count(x)\tatomic_long_read(&(x)->f_count)\n\n#define\tMAX_NON_LFS\t((1UL<<31) - 1)\n\n  \n#if BITS_PER_LONG==32\n#define MAX_LFS_FILESIZE\t((loff_t)ULONG_MAX << PAGE_SHIFT)\n#elif BITS_PER_LONG==64\n#define MAX_LFS_FILESIZE \t((loff_t)LLONG_MAX)\n#endif\n\n \ntypedef void *fl_owner_t;\n\nstruct file_lock;\n\n \n#ifndef OFFSET_MAX\n#define OFFSET_MAX\ttype_max(loff_t)\n#define OFFT_OFFSET_MAX\ttype_max(off_t)\n#endif\n\nextern void send_sigio(struct fown_struct *fown, int fd, int band);\n\nstatic inline struct inode *file_inode(const struct file *f)\n{\n\treturn f->f_inode;\n}\n\nstatic inline struct dentry *file_dentry(const struct file *file)\n{\n\treturn d_real(file->f_path.dentry, file_inode(file));\n}\n\nstruct fasync_struct {\n\trwlock_t\t\tfa_lock;\n\tint\t\t\tmagic;\n\tint\t\t\tfa_fd;\n\tstruct fasync_struct\t*fa_next;  \n\tstruct file\t\t*fa_file;\n\tstruct rcu_head\t\tfa_rcu;\n};\n\n#define FASYNC_MAGIC 0x4601\n\n \nextern int fasync_helper(int, struct file *, int, struct fasync_struct **);\nextern struct fasync_struct *fasync_insert_entry(int, struct file *, struct fasync_struct **, struct fasync_struct *);\nextern int fasync_remove_entry(struct file *, struct fasync_struct **);\nextern struct fasync_struct *fasync_alloc(void);\nextern void fasync_free(struct fasync_struct *);\n\n \nextern void kill_fasync(struct fasync_struct **, int, int);\n\nextern void __f_setown(struct file *filp, struct pid *, enum pid_type, int force);\nextern int f_setown(struct file *filp, int who, int force);\nextern void f_delown(struct file *filp);\nextern pid_t f_getown(struct file *filp);\nextern int send_sigurg(struct fown_struct *fown);\n\n \n#define SB_RDONLY       BIT(0)\t \n#define SB_NOSUID       BIT(1)\t \n#define SB_NODEV        BIT(2)\t \n#define SB_NOEXEC       BIT(3)\t \n#define SB_SYNCHRONOUS  BIT(4)\t \n#define SB_MANDLOCK     BIT(6)\t \n#define SB_DIRSYNC      BIT(7)\t \n#define SB_NOATIME      BIT(10)\t \n#define SB_NODIRATIME   BIT(11)\t \n#define SB_SILENT       BIT(15)\n#define SB_POSIXACL     BIT(16)\t \n#define SB_INLINECRYPT  BIT(17)\t \n#define SB_KERNMOUNT    BIT(22)\t \n#define SB_I_VERSION    BIT(23)\t \n#define SB_LAZYTIME     BIT(25)\t \n\n \n#define SB_DEAD         BIT(21)\n#define SB_DYING        BIT(24)\n#define SB_SUBMOUNT     BIT(26)\n#define SB_FORCE        BIT(27)\n#define SB_NOSEC        BIT(28)\n#define SB_BORN         BIT(29)\n#define SB_ACTIVE       BIT(30)\n#define SB_NOUSER       BIT(31)\n\n \n#define SB_ENC_STRICT_MODE_FL\t(1 << 0)\n\n#define sb_has_strict_encoding(sb) \\\n\t(sb->s_encoding_flags & SB_ENC_STRICT_MODE_FL)\n\n \n\n#define MNT_FORCE\t0x00000001\t \n#define MNT_DETACH\t0x00000002\t \n#define MNT_EXPIRE\t0x00000004\t \n#define UMOUNT_NOFOLLOW\t0x00000008\t \n#define UMOUNT_UNUSED\t0x80000000\t \n\n \n#define SB_I_CGROUPWB\t0x00000001\t \n#define SB_I_NOEXEC\t0x00000002\t \n#define SB_I_NODEV\t0x00000004\t \n#define SB_I_STABLE_WRITES 0x00000008\t \n\n \n#define SB_I_USERNS_VISIBLE\t\t0x00000010  \n#define SB_I_IMA_UNVERIFIABLE_SIGNATURE\t0x00000020\n#define SB_I_UNTRUSTED_MOUNTER\t\t0x00000040\n\n#define SB_I_SKIP_SYNC\t0x00000100\t \n#define SB_I_PERSB_BDI\t0x00000200\t \n#define SB_I_TS_EXPIRY_WARNED 0x00000400  \n#define SB_I_RETIRED\t0x00000800\t \n\n \nenum {\n\tSB_UNFROZEN = 0,\t\t \n\tSB_FREEZE_WRITE\t= 1,\t\t \n\tSB_FREEZE_PAGEFAULT = 2,\t \n\tSB_FREEZE_FS = 3,\t\t \n\tSB_FREEZE_COMPLETE = 4,\t\t \n};\n\n#define SB_FREEZE_LEVELS (SB_FREEZE_COMPLETE - 1)\n\nstruct sb_writers {\n\tunsigned short\t\t\tfrozen;\t\t \n\tunsigned short\t\t\tfreeze_holders;\t \n\tstruct percpu_rw_semaphore\trw_sem[SB_FREEZE_LEVELS];\n};\n\nstruct super_block {\n\tstruct list_head\ts_list;\t\t \n\tdev_t\t\t\ts_dev;\t\t \n\tunsigned char\t\ts_blocksize_bits;\n\tunsigned long\t\ts_blocksize;\n\tloff_t\t\t\ts_maxbytes;\t \n\tstruct file_system_type\t*s_type;\n\tconst struct super_operations\t*s_op;\n\tconst struct dquot_operations\t*dq_op;\n\tconst struct quotactl_ops\t*s_qcop;\n\tconst struct export_operations *s_export_op;\n\tunsigned long\t\ts_flags;\n\tunsigned long\t\ts_iflags;\t \n\tunsigned long\t\ts_magic;\n\tstruct dentry\t\t*s_root;\n\tstruct rw_semaphore\ts_umount;\n\tint\t\t\ts_count;\n\tatomic_t\t\ts_active;\n#ifdef CONFIG_SECURITY\n\tvoid                    *s_security;\n#endif\n\tconst struct xattr_handler **s_xattr;\n#ifdef CONFIG_FS_ENCRYPTION\n\tconst struct fscrypt_operations\t*s_cop;\n\tstruct fscrypt_keyring\t*s_master_keys;  \n#endif\n#ifdef CONFIG_FS_VERITY\n\tconst struct fsverity_operations *s_vop;\n#endif\n#if IS_ENABLED(CONFIG_UNICODE)\n\tstruct unicode_map *s_encoding;\n\t__u16 s_encoding_flags;\n#endif\n\tstruct hlist_bl_head\ts_roots;\t \n\tstruct list_head\ts_mounts;\t \n\tstruct block_device\t*s_bdev;\n\tstruct backing_dev_info *s_bdi;\n\tstruct mtd_info\t\t*s_mtd;\n\tstruct hlist_node\ts_instances;\n\tunsigned int\t\ts_quota_types;\t \n\tstruct quota_info\ts_dquot;\t \n\n\tstruct sb_writers\ts_writers;\n\n\t \n\tvoid\t\t\t*s_fs_info;\t \n\n\t \n\tu32\t\t\ts_time_gran;\n\t \n\ttime64_t\t\t   s_time_min;\n\ttime64_t\t\t   s_time_max;\n#ifdef CONFIG_FSNOTIFY\n\t__u32\t\t\ts_fsnotify_mask;\n\tstruct fsnotify_mark_connector __rcu\t*s_fsnotify_marks;\n#endif\n\n\tchar\t\t\ts_id[32];\t \n\tuuid_t\t\t\ts_uuid;\t\t \n\n\tunsigned int\t\ts_max_links;\n\n\t \n\tstruct mutex s_vfs_rename_mutex;\t \n\n\t \n\tconst char *s_subtype;\n\n\tconst struct dentry_operations *s_d_op;  \n\n\tstruct shrinker s_shrink;\t \n\n\t \n\tatomic_long_t s_remove_count;\n\n\t \n\tatomic_long_t s_fsnotify_connectors;\n\n\t \n\tint s_readonly_remount;\n\n\t \n\terrseq_t s_wb_err;\n\n\t \n\tstruct workqueue_struct *s_dio_done_wq;\n\tstruct hlist_head s_pins;\n\n\t \n\tstruct user_namespace *s_user_ns;\n\n\t \n\tstruct list_lru\t\ts_dentry_lru;\n\tstruct list_lru\t\ts_inode_lru;\n\tstruct rcu_head\t\trcu;\n\tstruct work_struct\tdestroy_work;\n\n\tstruct mutex\t\ts_sync_lock;\t \n\n\t \n\tint s_stack_depth;\n\n\t \n\tspinlock_t\t\ts_inode_list_lock ____cacheline_aligned_in_smp;\n\tstruct list_head\ts_inodes;\t \n\n\tspinlock_t\t\ts_inode_wblist_lock;\n\tstruct list_head\ts_inodes_wb;\t \n} __randomize_layout;\n\nstatic inline struct user_namespace *i_user_ns(const struct inode *inode)\n{\n\treturn inode->i_sb->s_user_ns;\n}\n\n \nstatic inline uid_t i_uid_read(const struct inode *inode)\n{\n\treturn from_kuid(i_user_ns(inode), inode->i_uid);\n}\n\nstatic inline gid_t i_gid_read(const struct inode *inode)\n{\n\treturn from_kgid(i_user_ns(inode), inode->i_gid);\n}\n\nstatic inline void i_uid_write(struct inode *inode, uid_t uid)\n{\n\tinode->i_uid = make_kuid(i_user_ns(inode), uid);\n}\n\nstatic inline void i_gid_write(struct inode *inode, gid_t gid)\n{\n\tinode->i_gid = make_kgid(i_user_ns(inode), gid);\n}\n\n \nstatic inline vfsuid_t i_uid_into_vfsuid(struct mnt_idmap *idmap,\n\t\t\t\t\t const struct inode *inode)\n{\n\treturn make_vfsuid(idmap, i_user_ns(inode), inode->i_uid);\n}\n\n \nstatic inline bool i_uid_needs_update(struct mnt_idmap *idmap,\n\t\t\t\t      const struct iattr *attr,\n\t\t\t\t      const struct inode *inode)\n{\n\treturn ((attr->ia_valid & ATTR_UID) &&\n\t\t!vfsuid_eq(attr->ia_vfsuid,\n\t\t\t   i_uid_into_vfsuid(idmap, inode)));\n}\n\n \nstatic inline void i_uid_update(struct mnt_idmap *idmap,\n\t\t\t\tconst struct iattr *attr,\n\t\t\t\tstruct inode *inode)\n{\n\tif (attr->ia_valid & ATTR_UID)\n\t\tinode->i_uid = from_vfsuid(idmap, i_user_ns(inode),\n\t\t\t\t\t   attr->ia_vfsuid);\n}\n\n \nstatic inline vfsgid_t i_gid_into_vfsgid(struct mnt_idmap *idmap,\n\t\t\t\t\t const struct inode *inode)\n{\n\treturn make_vfsgid(idmap, i_user_ns(inode), inode->i_gid);\n}\n\n \nstatic inline bool i_gid_needs_update(struct mnt_idmap *idmap,\n\t\t\t\t      const struct iattr *attr,\n\t\t\t\t      const struct inode *inode)\n{\n\treturn ((attr->ia_valid & ATTR_GID) &&\n\t\t!vfsgid_eq(attr->ia_vfsgid,\n\t\t\t   i_gid_into_vfsgid(idmap, inode)));\n}\n\n \nstatic inline void i_gid_update(struct mnt_idmap *idmap,\n\t\t\t\tconst struct iattr *attr,\n\t\t\t\tstruct inode *inode)\n{\n\tif (attr->ia_valid & ATTR_GID)\n\t\tinode->i_gid = from_vfsgid(idmap, i_user_ns(inode),\n\t\t\t\t\t   attr->ia_vfsgid);\n}\n\n \nstatic inline void inode_fsuid_set(struct inode *inode,\n\t\t\t\t   struct mnt_idmap *idmap)\n{\n\tinode->i_uid = mapped_fsuid(idmap, i_user_ns(inode));\n}\n\n \nstatic inline void inode_fsgid_set(struct inode *inode,\n\t\t\t\t   struct mnt_idmap *idmap)\n{\n\tinode->i_gid = mapped_fsgid(idmap, i_user_ns(inode));\n}\n\n \nstatic inline bool fsuidgid_has_mapping(struct super_block *sb,\n\t\t\t\t\tstruct mnt_idmap *idmap)\n{\n\tstruct user_namespace *fs_userns = sb->s_user_ns;\n\tkuid_t kuid;\n\tkgid_t kgid;\n\n\tkuid = mapped_fsuid(idmap, fs_userns);\n\tif (!uid_valid(kuid))\n\t\treturn false;\n\tkgid = mapped_fsgid(idmap, fs_userns);\n\tif (!gid_valid(kgid))\n\t\treturn false;\n\treturn kuid_has_mapping(fs_userns, kuid) &&\n\t       kgid_has_mapping(fs_userns, kgid);\n}\n\nstruct timespec64 current_time(struct inode *inode);\nstruct timespec64 inode_set_ctime_current(struct inode *inode);\n\nstatic inline time64_t inode_get_atime_sec(const struct inode *inode)\n{\n\treturn inode->i_atime.tv_sec;\n}\n\nstatic inline long inode_get_atime_nsec(const struct inode *inode)\n{\n\treturn inode->i_atime.tv_nsec;\n}\n\nstatic inline struct timespec64 inode_get_atime(const struct inode *inode)\n{\n\treturn inode->i_atime;\n}\n\nstatic inline struct timespec64 inode_set_atime_to_ts(struct inode *inode,\n\t\t\t\t\t\t      struct timespec64 ts)\n{\n\tinode->i_atime = ts;\n\treturn ts;\n}\n\nstatic inline struct timespec64 inode_set_atime(struct inode *inode,\n\t\t\t\t\t\ttime64_t sec, long nsec)\n{\n\tstruct timespec64 ts = { .tv_sec  = sec,\n\t\t\t\t .tv_nsec = nsec };\n\treturn inode_set_atime_to_ts(inode, ts);\n}\n\nstatic inline time64_t inode_get_mtime_sec(const struct inode *inode)\n{\n\treturn inode->i_mtime.tv_sec;\n}\n\nstatic inline long inode_get_mtime_nsec(const struct inode *inode)\n{\n\treturn inode->i_mtime.tv_nsec;\n}\n\nstatic inline struct timespec64 inode_get_mtime(const struct inode *inode)\n{\n\treturn inode->i_mtime;\n}\n\nstatic inline struct timespec64 inode_set_mtime_to_ts(struct inode *inode,\n\t\t\t\t\t\t      struct timespec64 ts)\n{\n\tinode->i_mtime = ts;\n\treturn ts;\n}\n\nstatic inline struct timespec64 inode_set_mtime(struct inode *inode,\n\t\t\t\t\t\ttime64_t sec, long nsec)\n{\n\tstruct timespec64 ts = { .tv_sec  = sec,\n\t\t\t\t .tv_nsec = nsec };\n\treturn inode_set_mtime_to_ts(inode, ts);\n}\n\nstatic inline time64_t inode_get_ctime_sec(const struct inode *inode)\n{\n\treturn inode->__i_ctime.tv_sec;\n}\n\nstatic inline long inode_get_ctime_nsec(const struct inode *inode)\n{\n\treturn inode->__i_ctime.tv_nsec;\n}\n\nstatic inline struct timespec64 inode_get_ctime(const struct inode *inode)\n{\n\treturn inode->__i_ctime;\n}\n\nstatic inline struct timespec64 inode_set_ctime_to_ts(struct inode *inode,\n\t\t\t\t\t\t      struct timespec64 ts)\n{\n\tinode->__i_ctime = ts;\n\treturn ts;\n}\n\n \nstatic inline struct timespec64 inode_set_ctime(struct inode *inode,\n\t\t\t\t\t\ttime64_t sec, long nsec)\n{\n\tstruct timespec64 ts = { .tv_sec  = sec,\n\t\t\t\t .tv_nsec = nsec };\n\n\treturn inode_set_ctime_to_ts(inode, ts);\n}\n\nstruct timespec64 simple_inode_init_ts(struct inode *inode);\n\n \n\n \nstatic inline void __sb_end_write(struct super_block *sb, int level)\n{\n\tpercpu_up_read(sb->s_writers.rw_sem + level-1);\n}\n\nstatic inline void __sb_start_write(struct super_block *sb, int level)\n{\n\tpercpu_down_read(sb->s_writers.rw_sem + level - 1);\n}\n\nstatic inline bool __sb_start_write_trylock(struct super_block *sb, int level)\n{\n\treturn percpu_down_read_trylock(sb->s_writers.rw_sem + level - 1);\n}\n\n#define __sb_writers_acquired(sb, lev)\t\\\n\tpercpu_rwsem_acquire(&(sb)->s_writers.rw_sem[(lev)-1], 1, _THIS_IP_)\n#define __sb_writers_release(sb, lev)\t\\\n\tpercpu_rwsem_release(&(sb)->s_writers.rw_sem[(lev)-1], 1, _THIS_IP_)\n\nstatic inline bool sb_write_started(const struct super_block *sb)\n{\n\treturn lockdep_is_held_type(sb->s_writers.rw_sem + SB_FREEZE_WRITE - 1, 1);\n}\n\n \nstatic inline void sb_end_write(struct super_block *sb)\n{\n\t__sb_end_write(sb, SB_FREEZE_WRITE);\n}\n\n \nstatic inline void sb_end_pagefault(struct super_block *sb)\n{\n\t__sb_end_write(sb, SB_FREEZE_PAGEFAULT);\n}\n\n \nstatic inline void sb_end_intwrite(struct super_block *sb)\n{\n\t__sb_end_write(sb, SB_FREEZE_FS);\n}\n\n \nstatic inline void sb_start_write(struct super_block *sb)\n{\n\t__sb_start_write(sb, SB_FREEZE_WRITE);\n}\n\nstatic inline bool sb_start_write_trylock(struct super_block *sb)\n{\n\treturn __sb_start_write_trylock(sb, SB_FREEZE_WRITE);\n}\n\n \nstatic inline void sb_start_pagefault(struct super_block *sb)\n{\n\t__sb_start_write(sb, SB_FREEZE_PAGEFAULT);\n}\n\n \nstatic inline void sb_start_intwrite(struct super_block *sb)\n{\n\t__sb_start_write(sb, SB_FREEZE_FS);\n}\n\nstatic inline bool sb_start_intwrite_trylock(struct super_block *sb)\n{\n\treturn __sb_start_write_trylock(sb, SB_FREEZE_FS);\n}\n\nbool inode_owner_or_capable(struct mnt_idmap *idmap,\n\t\t\t    const struct inode *inode);\n\n \nint vfs_create(struct mnt_idmap *, struct inode *,\n\t       struct dentry *, umode_t, bool);\nint vfs_mkdir(struct mnt_idmap *, struct inode *,\n\t      struct dentry *, umode_t);\nint vfs_mknod(struct mnt_idmap *, struct inode *, struct dentry *,\n              umode_t, dev_t);\nint vfs_symlink(struct mnt_idmap *, struct inode *,\n\t\tstruct dentry *, const char *);\nint vfs_link(struct dentry *, struct mnt_idmap *, struct inode *,\n\t     struct dentry *, struct inode **);\nint vfs_rmdir(struct mnt_idmap *, struct inode *, struct dentry *);\nint vfs_unlink(struct mnt_idmap *, struct inode *, struct dentry *,\n\t       struct inode **);\n\n \nstruct renamedata {\n\tstruct mnt_idmap *old_mnt_idmap;\n\tstruct inode *old_dir;\n\tstruct dentry *old_dentry;\n\tstruct mnt_idmap *new_mnt_idmap;\n\tstruct inode *new_dir;\n\tstruct dentry *new_dentry;\n\tstruct inode **delegated_inode;\n\tunsigned int flags;\n} __randomize_layout;\n\nint vfs_rename(struct renamedata *);\n\nstatic inline int vfs_whiteout(struct mnt_idmap *idmap,\n\t\t\t       struct inode *dir, struct dentry *dentry)\n{\n\treturn vfs_mknod(idmap, dir, dentry, S_IFCHR | WHITEOUT_MODE,\n\t\t\t WHITEOUT_DEV);\n}\n\nstruct file *kernel_tmpfile_open(struct mnt_idmap *idmap,\n\t\t\t\t const struct path *parentpath,\n\t\t\t\t umode_t mode, int open_flag,\n\t\t\t\t const struct cred *cred);\nstruct file *kernel_file_open(const struct path *path, int flags,\n\t\t\t      struct inode *inode, const struct cred *cred);\n\nint vfs_mkobj(struct dentry *, umode_t,\n\t\tint (*f)(struct dentry *, umode_t, void *),\n\t\tvoid *);\n\nint vfs_fchown(struct file *file, uid_t user, gid_t group);\nint vfs_fchmod(struct file *file, umode_t mode);\nint vfs_utimes(const struct path *path, struct timespec64 *times);\n\nextern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\n\n#ifdef CONFIG_COMPAT\nextern long compat_ptr_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\tunsigned long arg);\n#else\n#define compat_ptr_ioctl NULL\n#endif\n\n \nvoid inode_init_owner(struct mnt_idmap *idmap, struct inode *inode,\n\t\t      const struct inode *dir, umode_t mode);\nextern bool may_open_dev(const struct path *path);\numode_t mode_strip_sgid(struct mnt_idmap *idmap,\n\t\t\tconst struct inode *dir, umode_t mode);\n\n \nstruct dir_context;\ntypedef bool (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64,\n\t\t\t unsigned);\n\nstruct dir_context {\n\tfilldir_t actor;\n\tloff_t pos;\n};\n\n \n#define NOMMU_MAP_COPY\t\t0x00000001\n#define NOMMU_MAP_DIRECT\t0x00000008\n#define NOMMU_MAP_READ\t\tVM_MAYREAD\n#define NOMMU_MAP_WRITE\t\tVM_MAYWRITE\n#define NOMMU_MAP_EXEC\t\tVM_MAYEXEC\n\n#define NOMMU_VMFLAGS \\\n\t(NOMMU_MAP_READ | NOMMU_MAP_WRITE | NOMMU_MAP_EXEC)\n\n \n#define REMAP_FILE_DEDUP\t\t(1 << 0)\n#define REMAP_FILE_CAN_SHORTEN\t\t(1 << 1)\n\n \n#define REMAP_FILE_ADVISORY\t\t(REMAP_FILE_CAN_SHORTEN)\n\n \n#define COPY_FILE_SPLICE\t\t(1 << 0)\n\nstruct iov_iter;\nstruct io_uring_cmd;\nstruct offset_ctx;\n\nstruct file_operations {\n\tstruct module *owner;\n\tloff_t (*llseek) (struct file *, loff_t, int);\n\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\tssize_t (*read_iter) (struct kiocb *, struct iov_iter *);\n\tssize_t (*write_iter) (struct kiocb *, struct iov_iter *);\n\tint (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *,\n\t\t\tunsigned int flags);\n\tint (*iterate_shared) (struct file *, struct dir_context *);\n\t__poll_t (*poll) (struct file *, struct poll_table_struct *);\n\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n\tint (*mmap) (struct file *, struct vm_area_struct *);\n\tunsigned long mmap_supported_flags;\n\tint (*open) (struct inode *, struct file *);\n\tint (*flush) (struct file *, fl_owner_t id);\n\tint (*release) (struct inode *, struct file *);\n\tint (*fsync) (struct file *, loff_t, loff_t, int datasync);\n\tint (*fasync) (int, struct file *, int);\n\tint (*lock) (struct file *, int, struct file_lock *);\n\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\tint (*check_flags)(int);\n\tint (*flock) (struct file *, int, struct file_lock *);\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n\tvoid (*splice_eof)(struct file *file);\n\tint (*setlease)(struct file *, int, struct file_lock **, void **);\n\tlong (*fallocate)(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len);\n\tvoid (*show_fdinfo)(struct seq_file *m, struct file *f);\n#ifndef CONFIG_MMU\n\tunsigned (*mmap_capabilities)(struct file *);\n#endif\n\tssize_t (*copy_file_range)(struct file *, loff_t, struct file *,\n\t\t\tloff_t, size_t, unsigned int);\n\tloff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   loff_t len, unsigned int remap_flags);\n\tint (*fadvise)(struct file *, loff_t, loff_t, int);\n\tint (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags);\n\tint (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *,\n\t\t\t\tunsigned int poll_flags);\n} __randomize_layout;\n\n \nint wrap_directory_iterator(struct file *, struct dir_context *,\n\t\t\t    int (*) (struct file *, struct dir_context *));\n#define WRAP_DIR_ITER(x) \\\n\tstatic int shared_##x(struct file *file , struct dir_context *ctx) \\\n\t{ return wrap_directory_iterator(file, ctx, x); }\n\nstruct inode_operations {\n\tstruct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);\n\tconst char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *);\n\tint (*permission) (struct mnt_idmap *, struct inode *, int);\n\tstruct posix_acl * (*get_inode_acl)(struct inode *, int, bool);\n\n\tint (*readlink) (struct dentry *, char __user *,int);\n\n\tint (*create) (struct mnt_idmap *, struct inode *,struct dentry *,\n\t\t       umode_t, bool);\n\tint (*link) (struct dentry *,struct inode *,struct dentry *);\n\tint (*unlink) (struct inode *,struct dentry *);\n\tint (*symlink) (struct mnt_idmap *, struct inode *,struct dentry *,\n\t\t\tconst char *);\n\tint (*mkdir) (struct mnt_idmap *, struct inode *,struct dentry *,\n\t\t      umode_t);\n\tint (*rmdir) (struct inode *,struct dentry *);\n\tint (*mknod) (struct mnt_idmap *, struct inode *,struct dentry *,\n\t\t      umode_t,dev_t);\n\tint (*rename) (struct mnt_idmap *, struct inode *, struct dentry *,\n\t\t\tstruct inode *, struct dentry *, unsigned int);\n\tint (*setattr) (struct mnt_idmap *, struct dentry *, struct iattr *);\n\tint (*getattr) (struct mnt_idmap *, const struct path *,\n\t\t\tstruct kstat *, u32, unsigned int);\n\tssize_t (*listxattr) (struct dentry *, char *, size_t);\n\tint (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,\n\t\t      u64 len);\n\tint (*update_time)(struct inode *, int);\n\tint (*atomic_open)(struct inode *, struct dentry *,\n\t\t\t   struct file *, unsigned open_flag,\n\t\t\t   umode_t create_mode);\n\tint (*tmpfile) (struct mnt_idmap *, struct inode *,\n\t\t\tstruct file *, umode_t);\n\tstruct posix_acl *(*get_acl)(struct mnt_idmap *, struct dentry *,\n\t\t\t\t     int);\n\tint (*set_acl)(struct mnt_idmap *, struct dentry *,\n\t\t       struct posix_acl *, int);\n\tint (*fileattr_set)(struct mnt_idmap *idmap,\n\t\t\t    struct dentry *dentry, struct fileattr *fa);\n\tint (*fileattr_get)(struct dentry *dentry, struct fileattr *fa);\n\tstruct offset_ctx *(*get_offset_ctx)(struct inode *inode);\n} ____cacheline_aligned;\n\nstatic inline ssize_t call_read_iter(struct file *file, struct kiocb *kio,\n\t\t\t\t     struct iov_iter *iter)\n{\n\treturn file->f_op->read_iter(kio, iter);\n}\n\nstatic inline ssize_t call_write_iter(struct file *file, struct kiocb *kio,\n\t\t\t\t      struct iov_iter *iter)\n{\n\treturn file->f_op->write_iter(kio, iter);\n}\n\nstatic inline int call_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn file->f_op->mmap(file, vma);\n}\n\nextern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);\nextern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,\n\t\t\t\t   loff_t, size_t, unsigned int);\nextern ssize_t generic_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t       struct file *file_out, loff_t pos_out,\n\t\t\t\t       size_t len, unsigned int flags);\nint __generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,\n\t\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t\t    loff_t *len, unsigned int remap_flags,\n\t\t\t\t    const struct iomap_ops *dax_read_ops);\nint generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,\n\t\t\t\t  struct file *file_out, loff_t pos_out,\n\t\t\t\t  loff_t *count, unsigned int remap_flags);\nextern loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t  struct file *file_out, loff_t pos_out,\n\t\t\t\t  loff_t len, unsigned int remap_flags);\nextern loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   loff_t len, unsigned int remap_flags);\nextern int vfs_dedupe_file_range(struct file *file,\n\t\t\t\t struct file_dedupe_range *same);\nextern loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,\n\t\t\t\t\tstruct file *dst_file, loff_t dst_pos,\n\t\t\t\t\tloff_t len, unsigned int remap_flags);\n\nenum freeze_holder {\n\tFREEZE_HOLDER_KERNEL\t= (1U << 0),\n\tFREEZE_HOLDER_USERSPACE\t= (1U << 1),\n};\n\nstruct super_operations {\n   \tstruct inode *(*alloc_inode)(struct super_block *sb);\n\tvoid (*destroy_inode)(struct inode *);\n\tvoid (*free_inode)(struct inode *);\n\n   \tvoid (*dirty_inode) (struct inode *, int flags);\n\tint (*write_inode) (struct inode *, struct writeback_control *wbc);\n\tint (*drop_inode) (struct inode *);\n\tvoid (*evict_inode) (struct inode *);\n\tvoid (*put_super) (struct super_block *);\n\tint (*sync_fs)(struct super_block *sb, int wait);\n\tint (*freeze_super) (struct super_block *, enum freeze_holder who);\n\tint (*freeze_fs) (struct super_block *);\n\tint (*thaw_super) (struct super_block *, enum freeze_holder who);\n\tint (*unfreeze_fs) (struct super_block *);\n\tint (*statfs) (struct dentry *, struct kstatfs *);\n\tint (*remount_fs) (struct super_block *, int *, char *);\n\tvoid (*umount_begin) (struct super_block *);\n\n\tint (*show_options)(struct seq_file *, struct dentry *);\n\tint (*show_devname)(struct seq_file *, struct dentry *);\n\tint (*show_path)(struct seq_file *, struct dentry *);\n\tint (*show_stats)(struct seq_file *, struct dentry *);\n#ifdef CONFIG_QUOTA\n\tssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);\n\tssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);\n\tstruct dquot **(*get_dquots)(struct inode *);\n#endif\n\tlong (*nr_cached_objects)(struct super_block *,\n\t\t\t\t  struct shrink_control *);\n\tlong (*free_cached_objects)(struct super_block *,\n\t\t\t\t    struct shrink_control *);\n\tvoid (*shutdown)(struct super_block *sb);\n};\n\n \n#define S_SYNC\t\t(1 << 0)   \n#define S_NOATIME\t(1 << 1)   \n#define S_APPEND\t(1 << 2)   \n#define S_IMMUTABLE\t(1 << 3)   \n#define S_DEAD\t\t(1 << 4)   \n#define S_NOQUOTA\t(1 << 5)   \n#define S_DIRSYNC\t(1 << 6)   \n#define S_NOCMTIME\t(1 << 7)   \n#define S_SWAPFILE\t(1 << 8)   \n#define S_PRIVATE\t(1 << 9)   \n#define S_IMA\t\t(1 << 10)  \n#define S_AUTOMOUNT\t(1 << 11)  \n#define S_NOSEC\t\t(1 << 12)  \n#ifdef CONFIG_FS_DAX\n#define S_DAX\t\t(1 << 13)  \n#else\n#define S_DAX\t\t0\t   \n#endif\n#define S_ENCRYPTED\t(1 << 14)  \n#define S_CASEFOLD\t(1 << 15)  \n#define S_VERITY\t(1 << 16)  \n#define S_KERNEL_FILE\t(1 << 17)  \n\n \n#define __IS_FLG(inode, flg)\t((inode)->i_sb->s_flags & (flg))\n\nstatic inline bool sb_rdonly(const struct super_block *sb) { return sb->s_flags & SB_RDONLY; }\n#define IS_RDONLY(inode)\tsb_rdonly((inode)->i_sb)\n#define IS_SYNC(inode)\t\t(__IS_FLG(inode, SB_SYNCHRONOUS) || \\\n\t\t\t\t\t((inode)->i_flags & S_SYNC))\n#define IS_DIRSYNC(inode)\t(__IS_FLG(inode, SB_SYNCHRONOUS|SB_DIRSYNC) || \\\n\t\t\t\t\t((inode)->i_flags & (S_SYNC|S_DIRSYNC)))\n#define IS_MANDLOCK(inode)\t__IS_FLG(inode, SB_MANDLOCK)\n#define IS_NOATIME(inode)\t__IS_FLG(inode, SB_RDONLY|SB_NOATIME)\n#define IS_I_VERSION(inode)\t__IS_FLG(inode, SB_I_VERSION)\n\n#define IS_NOQUOTA(inode)\t((inode)->i_flags & S_NOQUOTA)\n#define IS_APPEND(inode)\t((inode)->i_flags & S_APPEND)\n#define IS_IMMUTABLE(inode)\t((inode)->i_flags & S_IMMUTABLE)\n#define IS_POSIXACL(inode)\t__IS_FLG(inode, SB_POSIXACL)\n\n#define IS_DEADDIR(inode)\t((inode)->i_flags & S_DEAD)\n#define IS_NOCMTIME(inode)\t((inode)->i_flags & S_NOCMTIME)\n#define IS_SWAPFILE(inode)\t((inode)->i_flags & S_SWAPFILE)\n#define IS_PRIVATE(inode)\t((inode)->i_flags & S_PRIVATE)\n#define IS_IMA(inode)\t\t((inode)->i_flags & S_IMA)\n#define IS_AUTOMOUNT(inode)\t((inode)->i_flags & S_AUTOMOUNT)\n#define IS_NOSEC(inode)\t\t((inode)->i_flags & S_NOSEC)\n#define IS_DAX(inode)\t\t((inode)->i_flags & S_DAX)\n#define IS_ENCRYPTED(inode)\t((inode)->i_flags & S_ENCRYPTED)\n#define IS_CASEFOLDED(inode)\t((inode)->i_flags & S_CASEFOLD)\n#define IS_VERITY(inode)\t((inode)->i_flags & S_VERITY)\n\n#define IS_WHITEOUT(inode)\t(S_ISCHR(inode->i_mode) && \\\n\t\t\t\t (inode)->i_rdev == WHITEOUT_DEV)\n\nstatic inline bool HAS_UNMAPPED_ID(struct mnt_idmap *idmap,\n\t\t\t\t   struct inode *inode)\n{\n\treturn !vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) ||\n\t       !vfsgid_valid(i_gid_into_vfsgid(idmap, inode));\n}\n\nstatic inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)\n{\n\t*kiocb = (struct kiocb) {\n\t\t.ki_filp = filp,\n\t\t.ki_flags = filp->f_iocb_flags,\n\t\t.ki_ioprio = get_current_ioprio(),\n\t};\n}\n\nstatic inline void kiocb_clone(struct kiocb *kiocb, struct kiocb *kiocb_src,\n\t\t\t       struct file *filp)\n{\n\t*kiocb = (struct kiocb) {\n\t\t.ki_filp = filp,\n\t\t.ki_flags = kiocb_src->ki_flags,\n\t\t.ki_ioprio = kiocb_src->ki_ioprio,\n\t\t.ki_pos = kiocb_src->ki_pos,\n\t};\n}\n\n \n#define I_DIRTY_SYNC\t\t(1 << 0)\n#define I_DIRTY_DATASYNC\t(1 << 1)\n#define I_DIRTY_PAGES\t\t(1 << 2)\n#define __I_NEW\t\t\t3\n#define I_NEW\t\t\t(1 << __I_NEW)\n#define I_WILL_FREE\t\t(1 << 4)\n#define I_FREEING\t\t(1 << 5)\n#define I_CLEAR\t\t\t(1 << 6)\n#define __I_SYNC\t\t7\n#define I_SYNC\t\t\t(1 << __I_SYNC)\n#define I_REFERENCED\t\t(1 << 8)\n#define __I_DIO_WAKEUP\t\t9\n#define I_DIO_WAKEUP\t\t(1 << __I_DIO_WAKEUP)\n#define I_LINKABLE\t\t(1 << 10)\n#define I_DIRTY_TIME\t\t(1 << 11)\n#define I_WB_SWITCH\t\t(1 << 13)\n#define I_OVL_INUSE\t\t(1 << 14)\n#define I_CREATING\t\t(1 << 15)\n#define I_DONTCACHE\t\t(1 << 16)\n#define I_SYNC_QUEUED\t\t(1 << 17)\n#define I_PINNING_FSCACHE_WB\t(1 << 18)\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n#define I_DIRTY (I_DIRTY_INODE | I_DIRTY_PAGES)\n#define I_DIRTY_ALL (I_DIRTY | I_DIRTY_TIME)\n\nextern void __mark_inode_dirty(struct inode *, int);\nstatic inline void mark_inode_dirty(struct inode *inode)\n{\n\t__mark_inode_dirty(inode, I_DIRTY);\n}\n\nstatic inline void mark_inode_dirty_sync(struct inode *inode)\n{\n\t__mark_inode_dirty(inode, I_DIRTY_SYNC);\n}\n\n \nstatic inline bool inode_is_dirtytime_only(struct inode *inode)\n{\n\treturn (inode->i_state & (I_DIRTY_TIME | I_NEW |\n\t\t\t\t  I_FREEING | I_WILL_FREE)) == I_DIRTY_TIME;\n}\n\nextern void inc_nlink(struct inode *inode);\nextern void drop_nlink(struct inode *inode);\nextern void clear_nlink(struct inode *inode);\nextern void set_nlink(struct inode *inode, unsigned int nlink);\n\nstatic inline void inode_inc_link_count(struct inode *inode)\n{\n\tinc_nlink(inode);\n\tmark_inode_dirty(inode);\n}\n\nstatic inline void inode_dec_link_count(struct inode *inode)\n{\n\tdrop_nlink(inode);\n\tmark_inode_dirty(inode);\n}\n\nenum file_time_flags {\n\tS_ATIME = 1,\n\tS_MTIME = 2,\n\tS_CTIME = 4,\n\tS_VERSION = 8,\n};\n\nextern bool atime_needs_update(const struct path *, struct inode *);\nextern void touch_atime(const struct path *);\nint inode_update_time(struct inode *inode, int flags);\n\nstatic inline void file_accessed(struct file *file)\n{\n\tif (!(file->f_flags & O_NOATIME))\n\t\ttouch_atime(&file->f_path);\n}\n\nextern int file_modified(struct file *file);\nint kiocb_modified(struct kiocb *iocb);\n\nint sync_inode_metadata(struct inode *inode, int wait);\n\nstruct file_system_type {\n\tconst char *name;\n\tint fs_flags;\n#define FS_REQUIRES_DEV\t\t1 \n#define FS_BINARY_MOUNTDATA\t2\n#define FS_HAS_SUBTYPE\t\t4\n#define FS_USERNS_MOUNT\t\t8\t \n#define FS_DISALLOW_NOTIFY_PERM\t16\t \n#define FS_ALLOW_IDMAP         32       \n#define FS_RENAME_DOES_D_MOVE\t32768\t \n\tint (*init_fs_context)(struct fs_context *);\n\tconst struct fs_parameter_spec *parameters;\n\tstruct dentry *(*mount) (struct file_system_type *, int,\n\t\t       const char *, void *);\n\tvoid (*kill_sb) (struct super_block *);\n\tstruct module *owner;\n\tstruct file_system_type * next;\n\tstruct hlist_head fs_supers;\n\n\tstruct lock_class_key s_lock_key;\n\tstruct lock_class_key s_umount_key;\n\tstruct lock_class_key s_vfs_rename_key;\n\tstruct lock_class_key s_writers_key[SB_FREEZE_LEVELS];\n\n\tstruct lock_class_key i_lock_key;\n\tstruct lock_class_key i_mutex_key;\n\tstruct lock_class_key invalidate_lock_key;\n\tstruct lock_class_key i_mutex_dir_key;\n};\n\n#define MODULE_ALIAS_FS(NAME) MODULE_ALIAS(\"fs-\" NAME)\n\nextern struct dentry *mount_bdev(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data,\n\tint (*fill_super)(struct super_block *, void *, int));\nextern struct dentry *mount_single(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int));\nextern struct dentry *mount_nodev(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int));\nextern struct dentry *mount_subtree(struct vfsmount *mnt, const char *path);\nvoid retire_super(struct super_block *sb);\nvoid generic_shutdown_super(struct super_block *sb);\nvoid kill_block_super(struct super_block *sb);\nvoid kill_anon_super(struct super_block *sb);\nvoid kill_litter_super(struct super_block *sb);\nvoid deactivate_super(struct super_block *sb);\nvoid deactivate_locked_super(struct super_block *sb);\nint set_anon_super(struct super_block *s, void *data);\nint set_anon_super_fc(struct super_block *s, struct fs_context *fc);\nint get_anon_bdev(dev_t *);\nvoid free_anon_bdev(dev_t);\nstruct super_block *sget_fc(struct fs_context *fc,\n\t\t\t    int (*test)(struct super_block *, struct fs_context *),\n\t\t\t    int (*set)(struct super_block *, struct fs_context *));\nstruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags, void *data);\nstruct super_block *sget_dev(struct fs_context *fc, dev_t dev);\n\n \n#define fops_get(fops) \\\n\t(((fops) && try_module_get((fops)->owner) ? (fops) : NULL))\n#define fops_put(fops) \\\n\tdo { if (fops) module_put((fops)->owner); } while(0)\n \n#define replace_fops(f, fops) \\\n\tdo {\t\\\n\t\tstruct file *__file = (f); \\\n\t\tfops_put(__file->f_op); \\\n\t\tBUG_ON(!(__file->f_op = (fops))); \\\n\t} while(0)\n\nextern int register_filesystem(struct file_system_type *);\nextern int unregister_filesystem(struct file_system_type *);\nextern int vfs_statfs(const struct path *, struct kstatfs *);\nextern int user_statfs(const char __user *, struct kstatfs *);\nextern int fd_statfs(int, struct kstatfs *);\nint freeze_super(struct super_block *super, enum freeze_holder who);\nint thaw_super(struct super_block *super, enum freeze_holder who);\nextern __printf(2, 3)\nint super_setup_bdi_name(struct super_block *sb, char *fmt, ...);\nextern int super_setup_bdi(struct super_block *sb);\n\nextern int current_umask(void);\n\nextern void ihold(struct inode * inode);\nextern void iput(struct inode *);\nint inode_update_timestamps(struct inode *inode, int flags);\nint generic_update_time(struct inode *, int);\n\n \nextern struct kobject *fs_kobj;\n\n#define MAX_RW_COUNT (INT_MAX & PAGE_MASK)\n\n \nstruct audit_names;\nstruct filename {\n\tconst char\t\t*name;\t \n\tconst __user char\t*uptr;\t \n\tatomic_t\t\trefcnt;\n\tstruct audit_names\t*aname;\n\tconst char\t\tiname[];\n};\nstatic_assert(offsetof(struct filename, iname) % sizeof(long) == 0);\n\nstatic inline struct mnt_idmap *file_mnt_idmap(struct file *file)\n{\n\treturn mnt_idmap(file->f_path.mnt);\n}\n\n \nstatic inline bool is_idmapped_mnt(const struct vfsmount *mnt)\n{\n\treturn mnt_idmap(mnt) != &nop_mnt_idmap;\n}\n\nextern long vfs_truncate(const struct path *, loff_t);\nint do_truncate(struct mnt_idmap *, struct dentry *, loff_t start,\n\t\tunsigned int time_attrs, struct file *filp);\nextern int vfs_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\tloff_t len);\nextern long do_sys_open(int dfd, const char __user *filename, int flags,\n\t\t\tumode_t mode);\nextern struct file *file_open_name(struct filename *, int, umode_t);\nextern struct file *filp_open(const char *, int, umode_t);\nextern struct file *file_open_root(const struct path *,\n\t\t\t\t   const char *, int, umode_t);\nstatic inline struct file *file_open_root_mnt(struct vfsmount *mnt,\n\t\t\t\t   const char *name, int flags, umode_t mode)\n{\n\treturn file_open_root(&(struct path){.mnt = mnt, .dentry = mnt->mnt_root},\n\t\t\t      name, flags, mode);\n}\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *creds);\nstruct file *dentry_create(const struct path *path, int flags, umode_t mode,\n\t\t\t   const struct cred *cred);\nstruct file *backing_file_open(const struct path *path, int flags,\n\t\t\t       const struct path *real_path,\n\t\t\t       const struct cred *cred);\nstruct path *backing_file_real_path(struct file *f);\n\n \nstatic inline const struct path *file_real_path(struct file *f)\n{\n\tif (unlikely(f->f_mode & FMODE_BACKING))\n\t\treturn backing_file_real_path(f);\n\treturn &f->f_path;\n}\n\nstatic inline struct file *file_clone_open(struct file *file)\n{\n\treturn dentry_open(&file->f_path, file->f_flags, file->f_cred);\n}\nextern int filp_close(struct file *, fl_owner_t id);\n\nextern struct filename *getname_flags(const char __user *, int, int *);\nextern struct filename *getname_uflags(const char __user *, int);\nextern struct filename *getname(const char __user *);\nextern struct filename *getname_kernel(const char *);\nextern void putname(struct filename *name);\n\nextern int finish_open(struct file *file, struct dentry *dentry,\n\t\t\tint (*open)(struct inode *, struct file *));\nextern int finish_no_open(struct file *file, struct dentry *dentry);\n\n \nstatic inline int finish_open_simple(struct file *file, int error)\n{\n\tif (error)\n\t\treturn error;\n\n\treturn finish_open(file, file->f_path.dentry, NULL);\n}\n\n \nextern void __init vfs_caches_init_early(void);\nextern void __init vfs_caches_init(void);\n\nextern struct kmem_cache *names_cachep;\n\n#define __getname()\t\tkmem_cache_alloc(names_cachep, GFP_KERNEL)\n#define __putname(name)\t\tkmem_cache_free(names_cachep, (void *)(name))\n\nextern struct super_block *blockdev_superblock;\nstatic inline bool sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn IS_ENABLED(CONFIG_BLOCK) && sb == blockdev_superblock;\n}\n\nvoid emergency_thaw_all(void);\nextern int sync_filesystem(struct super_block *);\nextern const struct file_operations def_blk_fops;\nextern const struct file_operations def_chr_fops;\n\n \n#define CHRDEV_MAJOR_MAX 512\n \n#define CHRDEV_MAJOR_DYN_END 234\n \n#define CHRDEV_MAJOR_DYN_EXT_START 511\n#define CHRDEV_MAJOR_DYN_EXT_END 384\n\nextern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);\nextern int register_chrdev_region(dev_t, unsigned, const char *);\nextern int __register_chrdev(unsigned int major, unsigned int baseminor,\n\t\t\t     unsigned int count, const char *name,\n\t\t\t     const struct file_operations *fops);\nextern void __unregister_chrdev(unsigned int major, unsigned int baseminor,\n\t\t\t\tunsigned int count, const char *name);\nextern void unregister_chrdev_region(dev_t, unsigned);\nextern void chrdev_show(struct seq_file *,off_t);\n\nstatic inline int register_chrdev(unsigned int major, const char *name,\n\t\t\t\t  const struct file_operations *fops)\n{\n\treturn __register_chrdev(major, 0, 256, name, fops);\n}\n\nstatic inline void unregister_chrdev(unsigned int major, const char *name)\n{\n\t__unregister_chrdev(major, 0, 256, name);\n}\n\nextern void init_special_inode(struct inode *, umode_t, dev_t);\n\n \nextern void make_bad_inode(struct inode *);\nextern bool is_bad_inode(struct inode *);\n\nextern int __must_check file_fdatawait_range(struct file *file, loff_t lstart,\n\t\t\t\t\t\tloff_t lend);\nextern int __must_check file_check_and_advance_wb_err(struct file *file);\nextern int __must_check file_write_and_wait_range(struct file *file,\n\t\t\t\t\t\tloff_t start, loff_t end);\n\nstatic inline int file_write_and_wait(struct file *file)\n{\n\treturn file_write_and_wait_range(file, 0, LLONG_MAX);\n}\n\nextern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,\n\t\t\t   int datasync);\nextern int vfs_fsync(struct file *file, int datasync);\n\nextern int sync_file_range(struct file *file, loff_t offset, loff_t nbytes,\n\t\t\t\tunsigned int flags);\n\nstatic inline bool iocb_is_dsync(const struct kiocb *iocb)\n{\n\treturn (iocb->ki_flags & IOCB_DSYNC) ||\n\t\tIS_SYNC(iocb->ki_filp->f_mapping->host);\n}\n\n \nstatic inline ssize_t generic_write_sync(struct kiocb *iocb, ssize_t count)\n{\n\tif (iocb_is_dsync(iocb)) {\n\t\tint ret = vfs_fsync_range(iocb->ki_filp,\n\t\t\t\tiocb->ki_pos - count, iocb->ki_pos - 1,\n\t\t\t\t(iocb->ki_flags & IOCB_SYNC) ? 0 : 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nextern void emergency_sync(void);\nextern void emergency_remount(void);\n\n#ifdef CONFIG_BLOCK\nextern int bmap(struct inode *inode, sector_t *block);\n#else\nstatic inline int bmap(struct inode *inode,  sector_t *block)\n{\n\treturn -EINVAL;\n}\n#endif\n\nint notify_change(struct mnt_idmap *, struct dentry *,\n\t\t  struct iattr *, struct inode **);\nint inode_permission(struct mnt_idmap *, struct inode *, int);\nint generic_permission(struct mnt_idmap *, struct inode *, int);\nstatic inline int file_permission(struct file *file, int mask)\n{\n\treturn inode_permission(file_mnt_idmap(file),\n\t\t\t\tfile_inode(file), mask);\n}\nstatic inline int path_permission(const struct path *path, int mask)\n{\n\treturn inode_permission(mnt_idmap(path->mnt),\n\t\t\t\td_inode(path->dentry), mask);\n}\nint __check_sticky(struct mnt_idmap *idmap, struct inode *dir,\n\t\t   struct inode *inode);\n\nstatic inline bool execute_ok(struct inode *inode)\n{\n\treturn (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode);\n}\n\nstatic inline bool inode_wrong_type(const struct inode *inode, umode_t mode)\n{\n\treturn (inode->i_mode ^ mode) & S_IFMT;\n}\n\n \nstatic inline void file_start_write(struct file *file)\n{\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tsb_start_write(file_inode(file)->i_sb);\n}\n\nstatic inline bool file_start_write_trylock(struct file *file)\n{\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn true;\n\treturn sb_start_write_trylock(file_inode(file)->i_sb);\n}\n\n \nstatic inline void file_end_write(struct file *file)\n{\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tsb_end_write(file_inode(file)->i_sb);\n}\n\n \nstatic inline void kiocb_start_write(struct kiocb *iocb)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\tsb_start_write(inode->i_sb);\n\t \n\t__sb_writers_release(inode->i_sb, SB_FREEZE_WRITE);\n}\n\n \nstatic inline void kiocb_end_write(struct kiocb *iocb)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\t \n\t__sb_writers_acquired(inode->i_sb, SB_FREEZE_WRITE);\n\tsb_end_write(inode->i_sb);\n}\n\n \nstatic inline int get_write_access(struct inode *inode)\n{\n\treturn atomic_inc_unless_negative(&inode->i_writecount) ? 0 : -ETXTBSY;\n}\nstatic inline int deny_write_access(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\treturn atomic_dec_unless_positive(&inode->i_writecount) ? 0 : -ETXTBSY;\n}\nstatic inline void put_write_access(struct inode * inode)\n{\n\tatomic_dec(&inode->i_writecount);\n}\nstatic inline void allow_write_access(struct file *file)\n{\n\tif (file)\n\t\tatomic_inc(&file_inode(file)->i_writecount);\n}\nstatic inline bool inode_is_open_for_write(const struct inode *inode)\n{\n\treturn atomic_read(&inode->i_writecount) > 0;\n}\n\n#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)\nstatic inline void i_readcount_dec(struct inode *inode)\n{\n\tBUG_ON(atomic_dec_return(&inode->i_readcount) < 0);\n}\nstatic inline void i_readcount_inc(struct inode *inode)\n{\n\tatomic_inc(&inode->i_readcount);\n}\n#else\nstatic inline void i_readcount_dec(struct inode *inode)\n{\n\treturn;\n}\nstatic inline void i_readcount_inc(struct inode *inode)\n{\n\treturn;\n}\n#endif\nextern int do_pipe_flags(int *, int);\n\nextern ssize_t kernel_read(struct file *, void *, size_t, loff_t *);\nssize_t __kernel_read(struct file *file, void *buf, size_t count, loff_t *pos);\nextern ssize_t kernel_write(struct file *, const void *, size_t, loff_t *);\nextern ssize_t __kernel_write(struct file *, const void *, size_t, loff_t *);\nextern struct file * open_exec(const char *);\n \n \nextern bool is_subdir(struct dentry *, struct dentry *);\nextern bool path_is_under(const struct path *, const struct path *);\n\nextern char *file_path(struct file *, char *, int);\n\n#include <linux/err.h>\n\n \nextern loff_t default_llseek(struct file *file, loff_t offset, int whence);\n\nextern loff_t vfs_llseek(struct file *file, loff_t offset, int whence);\n\nextern int inode_init_always(struct super_block *, struct inode *);\nextern void inode_init_once(struct inode *);\nextern void address_space_init_once(struct address_space *mapping);\nextern struct inode * igrab(struct inode *);\nextern ino_t iunique(struct super_block *, ino_t);\nextern int inode_needs_sync(struct inode *inode);\nextern int generic_delete_inode(struct inode *inode);\nstatic inline int generic_drop_inode(struct inode *inode)\n{\n\treturn !inode->i_nlink || inode_unhashed(inode);\n}\nextern void d_mark_dontcache(struct inode *inode);\n\nextern struct inode *ilookup5_nowait(struct super_block *sb,\n\t\tunsigned long hashval, int (*test)(struct inode *, void *),\n\t\tvoid *data);\nextern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data);\nextern struct inode *ilookup(struct super_block *sb, unsigned long ino);\n\nextern struct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *),\n\t\tvoid *data);\nextern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);\nextern struct inode * iget_locked(struct super_block *, unsigned long);\nextern struct inode *find_inode_nowait(struct super_block *,\n\t\t\t\t       unsigned long,\n\t\t\t\t       int (*match)(struct inode *,\n\t\t\t\t\t\t    unsigned long, void *),\n\t\t\t\t       void *data);\nextern struct inode *find_inode_rcu(struct super_block *, unsigned long,\n\t\t\t\t    int (*)(struct inode *, void *), void *);\nextern struct inode *find_inode_by_ino_rcu(struct super_block *, unsigned long);\nextern int insert_inode_locked4(struct inode *, unsigned long, int (*test)(struct inode *, void *), void *);\nextern int insert_inode_locked(struct inode *);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nextern void lockdep_annotate_inode_mutex_key(struct inode *inode);\n#else\nstatic inline void lockdep_annotate_inode_mutex_key(struct inode *inode) { };\n#endif\nextern void unlock_new_inode(struct inode *);\nextern void discard_new_inode(struct inode *);\nextern unsigned int get_next_ino(void);\nextern void evict_inodes(struct super_block *sb);\nvoid dump_mapping(const struct address_space *);\n\n \nstatic inline bool is_zero_ino(ino_t ino)\n{\n\treturn (u32)ino == 0;\n}\n\nextern void __iget(struct inode * inode);\nextern void iget_failed(struct inode *);\nextern void clear_inode(struct inode *);\nextern void __destroy_inode(struct inode *);\nextern struct inode *new_inode_pseudo(struct super_block *sb);\nextern struct inode *new_inode(struct super_block *sb);\nextern void free_inode_nonrcu(struct inode *inode);\nextern int setattr_should_drop_suidgid(struct mnt_idmap *, struct inode *);\nextern int file_remove_privs(struct file *);\nint setattr_should_drop_sgid(struct mnt_idmap *idmap,\n\t\t\t     const struct inode *inode);\n\n \nstatic inline void *\nalloc_inode_sb(struct super_block *sb, struct kmem_cache *cache, gfp_t gfp)\n{\n\treturn kmem_cache_alloc_lru(cache, &sb->s_inode_lru, gfp);\n}\n\nextern void __insert_inode_hash(struct inode *, unsigned long hashval);\nstatic inline void insert_inode_hash(struct inode *inode)\n{\n\t__insert_inode_hash(inode, inode->i_ino);\n}\n\nextern void __remove_inode_hash(struct inode *);\nstatic inline void remove_inode_hash(struct inode *inode)\n{\n\tif (!inode_unhashed(inode) && !hlist_fake(&inode->i_hash))\n\t\t__remove_inode_hash(inode);\n}\n\nextern void inode_sb_list_add(struct inode *inode);\nextern void inode_add_lru(struct inode *inode);\n\nextern int sb_set_blocksize(struct super_block *, int);\nextern int sb_min_blocksize(struct super_block *, int);\n\nextern int generic_file_mmap(struct file *, struct vm_area_struct *);\nextern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);\nextern ssize_t generic_write_checks(struct kiocb *, struct iov_iter *);\nint generic_write_checks_count(struct kiocb *iocb, loff_t *count);\nextern int generic_write_check_limits(struct file *file, loff_t pos,\n\t\tloff_t *count);\nextern int generic_file_rw_checks(struct file *file_in, struct file *file_out);\nssize_t filemap_read(struct kiocb *iocb, struct iov_iter *to,\n\t\tssize_t already_read);\nextern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);\nextern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);\nextern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);\nextern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *);\nssize_t generic_perform_write(struct kiocb *, struct iov_iter *);\nssize_t direct_write_fallback(struct kiocb *iocb, struct iov_iter *iter,\n\t\tssize_t direct_written, ssize_t buffered_written);\n\nssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags);\nssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags);\nssize_t vfs_iocb_iter_read(struct file *file, struct kiocb *iocb,\n\t\t\t   struct iov_iter *iter);\nssize_t vfs_iocb_iter_write(struct file *file, struct kiocb *iocb,\n\t\t\t    struct iov_iter *iter);\n\n \nssize_t filemap_splice_read(struct file *in, loff_t *ppos,\n\t\t\t    struct pipe_inode_info *pipe,\n\t\t\t    size_t len, unsigned int flags);\nssize_t copy_splice_read(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe,\n\t\t\t size_t len, unsigned int flags);\nextern ssize_t iter_file_splice_write(struct pipe_inode_info *,\n\t\tstruct file *, loff_t *, size_t, unsigned int);\nextern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\tloff_t *opos, size_t len, unsigned int flags);\n\n\nextern void\nfile_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);\nextern loff_t noop_llseek(struct file *file, loff_t offset, int whence);\n#define no_llseek NULL\nextern loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize);\nextern loff_t generic_file_llseek(struct file *file, loff_t offset, int whence);\nextern loff_t generic_file_llseek_size(struct file *file, loff_t offset,\n\t\tint whence, loff_t maxsize, loff_t eof);\nextern loff_t fixed_size_llseek(struct file *file, loff_t offset,\n\t\tint whence, loff_t size);\nextern loff_t no_seek_end_llseek_size(struct file *, loff_t, int, loff_t);\nextern loff_t no_seek_end_llseek(struct file *, loff_t, int);\nint rw_verify_area(int, struct file *, const loff_t *, size_t);\nextern int generic_file_open(struct inode * inode, struct file * filp);\nextern int nonseekable_open(struct inode * inode, struct file * filp);\nextern int stream_open(struct inode * inode, struct file * filp);\n\n#ifdef CONFIG_BLOCK\ntypedef void (dio_submit_t)(struct bio *bio, struct inode *inode,\n\t\t\t    loff_t file_offset);\n\nenum {\n\t \n\tDIO_LOCKING\t= 0x01,\n\n\t \n\tDIO_SKIP_HOLES\t= 0x02,\n};\n\nssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,\n\t\t\t     struct block_device *bdev, struct iov_iter *iter,\n\t\t\t     get_block_t get_block,\n\t\t\t     dio_iodone_t end_io,\n\t\t\t     int flags);\n\nstatic inline ssize_t blockdev_direct_IO(struct kiocb *iocb,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t struct iov_iter *iter,\n\t\t\t\t\t get_block_t get_block)\n{\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev, iter,\n\t\t\tget_block, NULL, DIO_LOCKING | DIO_SKIP_HOLES);\n}\n#endif\n\nvoid inode_dio_wait(struct inode *inode);\n\n \nstatic inline void inode_dio_begin(struct inode *inode)\n{\n\tatomic_inc(&inode->i_dio_count);\n}\n\n \nstatic inline void inode_dio_end(struct inode *inode)\n{\n\tif (atomic_dec_and_test(&inode->i_dio_count))\n\t\twake_up_bit(&inode->i_state, __I_DIO_WAKEUP);\n}\n\nextern void inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t\t    unsigned int mask);\n\nextern const struct file_operations generic_ro_fops;\n\n#define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))\n\nextern int readlink_copy(char __user *, int, const char *);\nextern int page_readlink(struct dentry *, char __user *, int);\nextern const char *page_get_link(struct dentry *, struct inode *,\n\t\t\t\t struct delayed_call *);\nextern void page_put_link(void *);\nextern int page_symlink(struct inode *inode, const char *symname, int len);\nextern const struct inode_operations page_symlink_inode_operations;\nextern void kfree_link(void *);\nvoid generic_fillattr(struct mnt_idmap *, u32, struct inode *, struct kstat *);\nvoid generic_fill_statx_attr(struct inode *inode, struct kstat *stat);\nextern int vfs_getattr_nosec(const struct path *, struct kstat *, u32, unsigned int);\nextern int vfs_getattr(const struct path *, struct kstat *, u32, unsigned int);\nvoid __inode_add_bytes(struct inode *inode, loff_t bytes);\nvoid inode_add_bytes(struct inode *inode, loff_t bytes);\nvoid __inode_sub_bytes(struct inode *inode, loff_t bytes);\nvoid inode_sub_bytes(struct inode *inode, loff_t bytes);\nstatic inline loff_t __inode_get_bytes(struct inode *inode)\n{\n\treturn (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;\n}\nloff_t inode_get_bytes(struct inode *inode);\nvoid inode_set_bytes(struct inode *inode, loff_t bytes);\nconst char *simple_get_link(struct dentry *, struct inode *,\n\t\t\t    struct delayed_call *);\nextern const struct inode_operations simple_symlink_inode_operations;\n\nextern int iterate_dir(struct file *, struct dir_context *);\n\nint vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,\n\t\tint flags);\nint vfs_fstat(int fd, struct kstat *stat);\n\nstatic inline int vfs_stat(const char __user *filename, struct kstat *stat)\n{\n\treturn vfs_fstatat(AT_FDCWD, filename, stat, 0);\n}\nstatic inline int vfs_lstat(const char __user *name, struct kstat *stat)\n{\n\treturn vfs_fstatat(AT_FDCWD, name, stat, AT_SYMLINK_NOFOLLOW);\n}\n\nextern const char *vfs_get_link(struct dentry *, struct delayed_call *);\nextern int vfs_readlink(struct dentry *, char __user *, int);\n\nextern struct file_system_type *get_filesystem(struct file_system_type *fs);\nextern void put_filesystem(struct file_system_type *fs);\nextern struct file_system_type *get_fs_type(const char *name);\nextern struct super_block *get_active_super(struct block_device *bdev);\nextern void drop_super(struct super_block *sb);\nextern void drop_super_exclusive(struct super_block *sb);\nextern void iterate_supers(void (*)(struct super_block *, void *), void *);\nextern void iterate_supers_type(struct file_system_type *,\n\t\t\t        void (*)(struct super_block *, void *), void *);\n\nextern int dcache_dir_open(struct inode *, struct file *);\nextern int dcache_dir_close(struct inode *, struct file *);\nextern loff_t dcache_dir_lseek(struct file *, loff_t, int);\nextern int dcache_readdir(struct file *, struct dir_context *);\nextern int simple_setattr(struct mnt_idmap *, struct dentry *,\n\t\t\t  struct iattr *);\nextern int simple_getattr(struct mnt_idmap *, const struct path *,\n\t\t\t  struct kstat *, u32, unsigned int);\nextern int simple_statfs(struct dentry *, struct kstatfs *);\nextern int simple_open(struct inode *inode, struct file *file);\nextern int simple_link(struct dentry *, struct inode *, struct dentry *);\nextern int simple_unlink(struct inode *, struct dentry *);\nextern int simple_rmdir(struct inode *, struct dentry *);\nvoid simple_rename_timestamp(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry);\nextern int simple_rename_exchange(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t\t  struct inode *new_dir, struct dentry *new_dentry);\nextern int simple_rename(struct mnt_idmap *, struct inode *,\n\t\t\t struct dentry *, struct inode *, struct dentry *,\n\t\t\t unsigned int);\nextern void simple_recursive_removal(struct dentry *,\n                              void (*callback)(struct dentry *));\nextern int noop_fsync(struct file *, loff_t, loff_t, int);\nextern ssize_t noop_direct_IO(struct kiocb *iocb, struct iov_iter *iter);\nextern int simple_empty(struct dentry *);\nextern int simple_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata);\nextern const struct address_space_operations ram_aops;\nextern int always_delete_dentry(const struct dentry *);\nextern struct inode *alloc_anon_inode(struct super_block *);\nextern int simple_nosetlease(struct file *, int, struct file_lock **, void **);\nextern const struct dentry_operations simple_dentry_operations;\n\nextern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned int flags);\nextern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);\nextern const struct file_operations simple_dir_operations;\nextern const struct inode_operations simple_dir_inode_operations;\nextern void make_empty_dir_inode(struct inode *inode);\nextern bool is_empty_dir_inode(struct inode *inode);\nstruct tree_descr { const char *name; const struct file_operations *ops; int mode; };\nstruct dentry *d_alloc_name(struct dentry *, const char *);\nextern int simple_fill_super(struct super_block *, unsigned long,\n\t\t\t     const struct tree_descr *);\nextern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int *count);\nextern void simple_release_fs(struct vfsmount **mount, int *count);\n\nextern ssize_t simple_read_from_buffer(void __user *to, size_t count,\n\t\t\tloff_t *ppos, const void *from, size_t available);\nextern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,\n\t\tconst void __user *from, size_t count);\n\nstruct offset_ctx {\n\tstruct xarray\t\txa;\n\tu32\t\t\tnext_offset;\n};\n\nvoid simple_offset_init(struct offset_ctx *octx);\nint simple_offset_add(struct offset_ctx *octx, struct dentry *dentry);\nvoid simple_offset_remove(struct offset_ctx *octx, struct dentry *dentry);\nint simple_offset_rename_exchange(struct inode *old_dir,\n\t\t\t\t  struct dentry *old_dentry,\n\t\t\t\t  struct inode *new_dir,\n\t\t\t\t  struct dentry *new_dentry);\nvoid simple_offset_destroy(struct offset_ctx *octx);\n\nextern const struct file_operations simple_offset_dir_operations;\n\nextern int __generic_file_fsync(struct file *, loff_t, loff_t, int);\nextern int generic_file_fsync(struct file *, loff_t, loff_t, int);\n\nextern int generic_check_addressable(unsigned, u64);\n\nextern void generic_set_encrypted_ci_d_ops(struct dentry *dentry);\n\nint may_setattr(struct mnt_idmap *idmap, struct inode *inode,\n\t\tunsigned int ia_valid);\nint setattr_prepare(struct mnt_idmap *, struct dentry *, struct iattr *);\nextern int inode_newsize_ok(const struct inode *, loff_t offset);\nvoid setattr_copy(struct mnt_idmap *, struct inode *inode,\n\t\t  const struct iattr *attr);\n\nextern int file_update_time(struct file *file);\n\nstatic inline bool vma_is_dax(const struct vm_area_struct *vma)\n{\n\treturn vma->vm_file && IS_DAX(vma->vm_file->f_mapping->host);\n}\n\nstatic inline bool vma_is_fsdax(struct vm_area_struct *vma)\n{\n\tstruct inode *inode;\n\n\tif (!IS_ENABLED(CONFIG_FS_DAX) || !vma->vm_file)\n\t\treturn false;\n\tif (!vma_is_dax(vma))\n\t\treturn false;\n\tinode = file_inode(vma->vm_file);\n\tif (S_ISCHR(inode->i_mode))\n\t\treturn false;  \n\treturn true;\n}\n\nstatic inline int iocb_flags(struct file *file)\n{\n\tint res = 0;\n\tif (file->f_flags & O_APPEND)\n\t\tres |= IOCB_APPEND;\n\tif (file->f_flags & O_DIRECT)\n\t\tres |= IOCB_DIRECT;\n\tif (file->f_flags & O_DSYNC)\n\t\tres |= IOCB_DSYNC;\n\tif (file->f_flags & __O_SYNC)\n\t\tres |= IOCB_SYNC;\n\treturn res;\n}\n\nstatic inline int kiocb_set_rw_flags(struct kiocb *ki, rwf_t flags)\n{\n\tint kiocb_flags = 0;\n\n\t \n\tBUILD_BUG_ON((__force int) RWF_SUPPORTED & IOCB_EVENTFD);\n\n\tif (!flags)\n\t\treturn 0;\n\tif (unlikely(flags & ~RWF_SUPPORTED))\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & RWF_NOWAIT) {\n\t\tif (!(ki->ki_filp->f_mode & FMODE_NOWAIT))\n\t\t\treturn -EOPNOTSUPP;\n\t\tkiocb_flags |= IOCB_NOIO;\n\t}\n\tkiocb_flags |= (__force int) (flags & RWF_SUPPORTED);\n\tif (flags & RWF_SYNC)\n\t\tkiocb_flags |= IOCB_DSYNC;\n\n\tki->ki_flags |= kiocb_flags;\n\treturn 0;\n}\n\nstatic inline ino_t parent_ino(struct dentry *dentry)\n{\n\tino_t res;\n\n\t \n\tspin_lock(&dentry->d_lock);\n\tres = dentry->d_parent->d_inode->i_ino;\n\tspin_unlock(&dentry->d_lock);\n\treturn res;\n}\n\n \n\n \nstruct simple_transaction_argresp {\n\tssize_t size;\n\tchar data[];\n};\n\n#define SIMPLE_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct simple_transaction_argresp))\n\nchar *simple_transaction_get(struct file *file, const char __user *buf,\n\t\t\t\tsize_t size);\nssize_t simple_transaction_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t size, loff_t *pos);\nint simple_transaction_release(struct inode *inode, struct file *file);\n\nvoid simple_transaction_set(struct file *file, size_t n);\n\n \n#define DEFINE_SIMPLE_ATTRIBUTE_XSIGNED(__fops, __get, __set, __fmt, __is_signed)\t\\\nstatic int __fops ## _open(struct inode *inode, struct file *file)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__simple_attr_check_format(__fmt, 0ull);\t\t\t\\\n\treturn simple_attr_open(inode, file, __get, __set, __fmt);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic const struct file_operations __fops = {\t\t\t\t\\\n\t.owner\t = THIS_MODULE,\t\t\t\t\t\t\\\n\t.open\t = __fops ## _open,\t\t\t\t\t\\\n\t.release = simple_attr_release,\t\t\t\t\t\\\n\t.read\t = simple_attr_read,\t\t\t\t\t\\\n\t.write\t = (__is_signed) ? simple_attr_write_signed : simple_attr_write,\t\\\n\t.llseek\t = generic_file_llseek,\t\t\t\t\t\\\n}\n\n#define DEFINE_SIMPLE_ATTRIBUTE(__fops, __get, __set, __fmt)\t\t\\\n\tDEFINE_SIMPLE_ATTRIBUTE_XSIGNED(__fops, __get, __set, __fmt, false)\n\n#define DEFINE_SIMPLE_ATTRIBUTE_SIGNED(__fops, __get, __set, __fmt)\t\\\n\tDEFINE_SIMPLE_ATTRIBUTE_XSIGNED(__fops, __get, __set, __fmt, true)\n\nstatic inline __printf(1, 2)\nvoid __simple_attr_check_format(const char *fmt, ...)\n{\n\t \n}\n\nint simple_attr_open(struct inode *inode, struct file *file,\n\t\t     int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t     const char *fmt);\nint simple_attr_release(struct inode *inode, struct file *file);\nssize_t simple_attr_read(struct file *file, char __user *buf,\n\t\t\t size_t len, loff_t *ppos);\nssize_t simple_attr_write(struct file *file, const char __user *buf,\n\t\t\t  size_t len, loff_t *ppos);\nssize_t simple_attr_write_signed(struct file *file, const char __user *buf,\n\t\t\t\t size_t len, loff_t *ppos);\n\nstruct ctl_table;\nint __init list_bdev_fs_names(char *buf, size_t size);\n\n#define __FMODE_EXEC\t\t((__force int) FMODE_EXEC)\n#define __FMODE_NONOTIFY\t((__force int) FMODE_NONOTIFY)\n\n#define ACC_MODE(x) (\"\\004\\002\\006\\006\"[(x)&O_ACCMODE])\n#define OPEN_FMODE(flag) ((__force fmode_t)(((flag + 1) & O_ACCMODE) | \\\n\t\t\t\t\t    (flag & __FMODE_NONOTIFY)))\n\nstatic inline bool is_sxid(umode_t mode)\n{\n\treturn mode & (S_ISUID | S_ISGID);\n}\n\nstatic inline int check_sticky(struct mnt_idmap *idmap,\n\t\t\t       struct inode *dir, struct inode *inode)\n{\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\n\treturn __check_sticky(idmap, dir, inode);\n}\n\nstatic inline void inode_has_no_xattr(struct inode *inode)\n{\n\tif (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & SB_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n}\n\nstatic inline bool is_root_inode(struct inode *inode)\n{\n\treturn inode == inode->i_sb->s_root->d_inode;\n}\n\nstatic inline bool dir_emit(struct dir_context *ctx,\n\t\t\t    const char *name, int namelen,\n\t\t\t    u64 ino, unsigned type)\n{\n\treturn ctx->actor(ctx, name, namelen, ctx->pos, ino, type);\n}\nstatic inline bool dir_emit_dot(struct file *file, struct dir_context *ctx)\n{\n\treturn ctx->actor(ctx, \".\", 1, ctx->pos,\n\t\t\t  file->f_path.dentry->d_inode->i_ino, DT_DIR);\n}\nstatic inline bool dir_emit_dotdot(struct file *file, struct dir_context *ctx)\n{\n\treturn ctx->actor(ctx, \"..\", 2, ctx->pos,\n\t\t\t  parent_ino(file->f_path.dentry), DT_DIR);\n}\nstatic inline bool dir_emit_dots(struct file *file, struct dir_context *ctx)\n{\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\treturn false;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\treturn false;\n\t\tctx->pos = 2;\n\t}\n\treturn true;\n}\nstatic inline bool dir_relax(struct inode *inode)\n{\n\tinode_unlock(inode);\n\tinode_lock(inode);\n\treturn !IS_DEADDIR(inode);\n}\n\nstatic inline bool dir_relax_shared(struct inode *inode)\n{\n\tinode_unlock_shared(inode);\n\tinode_lock_shared(inode);\n\treturn !IS_DEADDIR(inode);\n}\n\nextern bool path_noexec(const struct path *path);\nextern void inode_nohighmem(struct inode *inode);\n\n \nextern int vfs_fadvise(struct file *file, loff_t offset, loff_t len,\n\t\t       int advice);\nextern int generic_fadvise(struct file *file, loff_t offset, loff_t len,\n\t\t\t   int advice);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}