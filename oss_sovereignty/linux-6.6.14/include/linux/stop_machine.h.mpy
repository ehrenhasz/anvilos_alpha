{
  "module_name": "stop_machine.h",
  "hash_id": "b7be4a9f6ef4f89f948308bbaed037a0983e7215b5485fd9163201d997a477e2",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/stop_machine.h",
  "human_readable_source": " \n#ifndef _LINUX_STOP_MACHINE\n#define _LINUX_STOP_MACHINE\n\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/list.h>\n\n \ntypedef int (*cpu_stop_fn_t)(void *arg);\n\n#ifdef CONFIG_SMP\n\nstruct cpu_stop_work {\n\tstruct list_head\tlist;\t\t \n\tcpu_stop_fn_t\t\tfn;\n\tunsigned long\t\tcaller;\n\tvoid\t\t\t*arg;\n\tstruct cpu_stop_done\t*done;\n};\n\nint stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg);\nint stop_two_cpus(unsigned int cpu1, unsigned int cpu2, cpu_stop_fn_t fn, void *arg);\nbool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,\n\t\t\t struct cpu_stop_work *work_buf);\nvoid stop_machine_park(int cpu);\nvoid stop_machine_unpark(int cpu);\nvoid stop_machine_yield(const struct cpumask *cpumask);\n\nextern void print_stop_info(const char *log_lvl, struct task_struct *task);\n\n#else\t \n\n#include <linux/workqueue.h>\n\nstruct cpu_stop_work {\n\tstruct work_struct\twork;\n\tcpu_stop_fn_t\t\tfn;\n\tvoid\t\t\t*arg;\n};\n\nstatic inline int stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)\n{\n\tint ret = -ENOENT;\n\tpreempt_disable();\n\tif (cpu == smp_processor_id())\n\t\tret = fn(arg);\n\tpreempt_enable();\n\treturn ret;\n}\n\nstatic void stop_one_cpu_nowait_workfn(struct work_struct *work)\n{\n\tstruct cpu_stop_work *stwork =\n\t\tcontainer_of(work, struct cpu_stop_work, work);\n\tpreempt_disable();\n\tstwork->fn(stwork->arg);\n\tpreempt_enable();\n}\n\nstatic inline bool stop_one_cpu_nowait(unsigned int cpu,\n\t\t\t\t       cpu_stop_fn_t fn, void *arg,\n\t\t\t\t       struct cpu_stop_work *work_buf)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tINIT_WORK(&work_buf->work, stop_one_cpu_nowait_workfn);\n\t\twork_buf->fn = fn;\n\t\twork_buf->arg = arg;\n\t\tschedule_work(&work_buf->work);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline void print_stop_info(const char *log_lvl, struct task_struct *task) { }\n\n#endif\t \n\n \n#if defined(CONFIG_SMP) || defined(CONFIG_HOTPLUG_CPU)\n\n \nint stop_machine(cpu_stop_fn_t fn, void *data, const struct cpumask *cpus);\n\n \nint stop_machine_cpuslocked(cpu_stop_fn_t fn, void *data, const struct cpumask *cpus);\n\n \nint stop_core_cpuslocked(unsigned int cpu, cpu_stop_fn_t fn, void *data);\n\nint stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t\t   const struct cpumask *cpus);\n#else\t \n\nstatic __always_inline int stop_machine_cpuslocked(cpu_stop_fn_t fn, void *data,\n\t\t\t\t\t  const struct cpumask *cpus)\n{\n\tunsigned long flags;\n\tint ret;\n\tlocal_irq_save(flags);\n\tret = fn(data);\n\tlocal_irq_restore(flags);\n\treturn ret;\n}\n\nstatic __always_inline int\nstop_machine(cpu_stop_fn_t fn, void *data, const struct cpumask *cpus)\n{\n\treturn stop_machine_cpuslocked(fn, data, cpus);\n}\n\nstatic __always_inline int\nstop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t       const struct cpumask *cpus)\n{\n\treturn stop_machine(fn, data, cpus);\n}\n\n#endif\t \n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}