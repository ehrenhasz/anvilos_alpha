{
  "module_name": "mc.h",
  "hash_id": "5ef50669ab5b57ad4c67d27c5e3df16a332202cc5caacb1aa17a51fe38c067d0",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fsl/mc.h",
  "human_readable_source": " \n \n#ifndef _FSL_MC_H_\n#define _FSL_MC_H_\n\n#include <linux/device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/interrupt.h>\n#include <uapi/linux/fsl_mc.h>\n\n#define FSL_MC_VENDOR_FREESCALE\t0x1957\n\nstruct irq_domain;\nstruct msi_domain_info;\n\nstruct fsl_mc_device;\nstruct fsl_mc_io;\n\n \nstruct fsl_mc_driver {\n\tstruct device_driver driver;\n\tconst struct fsl_mc_device_id *match_id_table;\n\tint (*probe)(struct fsl_mc_device *dev);\n\tvoid (*remove)(struct fsl_mc_device *dev);\n\tvoid (*shutdown)(struct fsl_mc_device *dev);\n\tint (*suspend)(struct fsl_mc_device *dev, pm_message_t state);\n\tint (*resume)(struct fsl_mc_device *dev);\n\tbool driver_managed_dma;\n};\n\n#define to_fsl_mc_driver(_drv) \\\n\tcontainer_of(_drv, struct fsl_mc_driver, driver)\n\n \nenum fsl_mc_pool_type {\n\tFSL_MC_POOL_DPMCP = 0x0,     \n\tFSL_MC_POOL_DPBP,\t     \n\tFSL_MC_POOL_DPCON,\t     \n\tFSL_MC_POOL_IRQ,\n\n\t \n\tFSL_MC_NUM_POOL_TYPES\n};\n\n \nstruct fsl_mc_resource {\n\tenum fsl_mc_pool_type type;\n\ts32 id;\n\tvoid *data;\n\tstruct fsl_mc_resource_pool *parent_pool;\n\tstruct list_head node;\n};\n\n \nstruct fsl_mc_device_irq {\n\tunsigned int virq;\n\tstruct fsl_mc_device *mc_dev;\n\tu8 dev_irq_index;\n\tstruct fsl_mc_resource resource;\n};\n\n#define to_fsl_mc_irq(_mc_resource) \\\n\tcontainer_of(_mc_resource, struct fsl_mc_device_irq, resource)\n\n \n#define FSL_MC_OBJ_STATE_OPEN\t\t0x00000001\n \n#define FSL_MC_OBJ_STATE_PLUGGED\t0x00000002\n\n \n#define FSL_MC_OBJ_FLAG_NO_MEM_SHAREABILITY\t0x0001\n\n \nstruct fsl_mc_obj_desc {\n\tchar type[16];\n\tint id;\n\tu16 vendor;\n\tu16 ver_major;\n\tu16 ver_minor;\n\tu8 irq_count;\n\tu8 region_count;\n\tu32 state;\n\tchar label[16];\n\tu16 flags;\n};\n\n \n#define FSL_MC_IS_DPRC\t0x0001\n\n \n \n#define FSL_MC_REGION_CACHEABLE\t0x00000001\n\n \n#define FSL_MC_REGION_SHAREABLE\t0x00000002\n\n \nstruct fsl_mc_device {\n\tstruct device dev;\n\tu64 dma_mask;\n\tu16 flags;\n\tu32 icid;\n\tu16 mc_handle;\n\tstruct fsl_mc_io *mc_io;\n\tstruct fsl_mc_obj_desc obj_desc;\n\tstruct resource *regions;\n\tstruct fsl_mc_device_irq **irqs;\n\tstruct fsl_mc_resource *resource;\n\tstruct device_link *consumer_link;\n\tconst char *driver_override;\n};\n\n#define to_fsl_mc_device(_dev) \\\n\tcontainer_of(_dev, struct fsl_mc_device, dev)\n\nstruct mc_cmd_header {\n\tu8 src_id;\n\tu8 flags_hw;\n\tu8 status;\n\tu8 flags_sw;\n\t__le16 token;\n\t__le16 cmd_id;\n};\n\nenum mc_cmd_status {\n\tMC_CMD_STATUS_OK = 0x0,  \n\tMC_CMD_STATUS_READY = 0x1,  \n\tMC_CMD_STATUS_AUTH_ERR = 0x3,  \n\tMC_CMD_STATUS_NO_PRIVILEGE = 0x4,  \n\tMC_CMD_STATUS_DMA_ERR = 0x5,  \n\tMC_CMD_STATUS_CONFIG_ERR = 0x6,  \n\tMC_CMD_STATUS_TIMEOUT = 0x7,  \n\tMC_CMD_STATUS_NO_RESOURCE = 0x8,  \n\tMC_CMD_STATUS_NO_MEMORY = 0x9,  \n\tMC_CMD_STATUS_BUSY = 0xA,  \n\tMC_CMD_STATUS_UNSUPPORTED_OP = 0xB,  \n\tMC_CMD_STATUS_INVALID_STATE = 0xC  \n};\n\n \n\n \n#define MC_CMD_FLAG_PRI\t\t0x80\n \n#define MC_CMD_FLAG_INTR_DIS\t0x01\n\nstatic inline __le64 mc_encode_cmd_header(u16 cmd_id,\n\t\t\t\t\t  u32 cmd_flags,\n\t\t\t\t\t  u16 token)\n{\n\t__le64 header = 0;\n\tstruct mc_cmd_header *hdr = (struct mc_cmd_header *)&header;\n\n\thdr->cmd_id = cpu_to_le16(cmd_id);\n\thdr->token  = cpu_to_le16(token);\n\thdr->status = MC_CMD_STATUS_READY;\n\tif (cmd_flags & MC_CMD_FLAG_PRI)\n\t\thdr->flags_hw = MC_CMD_FLAG_PRI;\n\tif (cmd_flags & MC_CMD_FLAG_INTR_DIS)\n\t\thdr->flags_sw = MC_CMD_FLAG_INTR_DIS;\n\n\treturn header;\n}\n\nstatic inline u16 mc_cmd_hdr_read_token(struct fsl_mc_command *cmd)\n{\n\tstruct mc_cmd_header *hdr = (struct mc_cmd_header *)&cmd->header;\n\tu16 token = le16_to_cpu(hdr->token);\n\n\treturn token;\n}\n\nstruct mc_rsp_create {\n\t__le32 object_id;\n};\n\nstruct mc_rsp_api_ver {\n\t__le16 major_ver;\n\t__le16 minor_ver;\n};\n\nstatic inline u32 mc_cmd_read_object_id(struct fsl_mc_command *cmd)\n{\n\tstruct mc_rsp_create *rsp_params;\n\n\trsp_params = (struct mc_rsp_create *)cmd->params;\n\treturn le32_to_cpu(rsp_params->object_id);\n}\n\nstatic inline void mc_cmd_read_api_version(struct fsl_mc_command *cmd,\n\t\t\t\t\t   u16 *major_ver,\n\t\t\t\t\t   u16 *minor_ver)\n{\n\tstruct mc_rsp_api_ver *rsp_params;\n\n\trsp_params = (struct mc_rsp_api_ver *)cmd->params;\n\t*major_ver = le16_to_cpu(rsp_params->major_ver);\n\t*minor_ver = le16_to_cpu(rsp_params->minor_ver);\n}\n\n \n#define FSL_MC_IO_ATOMIC_CONTEXT_PORTAL\t0x0001\n\n \nstruct fsl_mc_io {\n\tstruct device *dev;\n\tu16 flags;\n\tu32 portal_size;\n\tphys_addr_t portal_phys_addr;\n\tvoid __iomem *portal_virt_addr;\n\tstruct fsl_mc_device *dpmcp_dev;\n\tunion {\n\t\t \n\t\tstruct mutex mutex;  \n\n\t\t \n\t\traw_spinlock_t spinlock;  \n\t};\n};\n\nint mc_send_command(struct fsl_mc_io *mc_io, struct fsl_mc_command *cmd);\n\n#ifdef CONFIG_FSL_MC_BUS\n#define dev_is_fsl_mc(_dev) ((_dev)->bus == &fsl_mc_bus_type)\n#else\n \n#define dev_is_fsl_mc(_dev) (0)\n#endif\n\n \n#define fsl_mc_is_cont_dev(_dev) (to_fsl_mc_device(_dev)->flags & \\\n\tFSL_MC_IS_DPRC)\n\n \n#define fsl_mc_cont_dev(_dev) (fsl_mc_is_cont_dev(_dev) ? \\\n\t(_dev) : (_dev)->parent)\n\n \n#define module_fsl_mc_driver(__fsl_mc_driver) \\\n\tmodule_driver(__fsl_mc_driver, fsl_mc_driver_register, \\\n\t\t      fsl_mc_driver_unregister)\n\n \n#define fsl_mc_driver_register(drv) \\\n\t__fsl_mc_driver_register(drv, THIS_MODULE)\n\nint __must_check __fsl_mc_driver_register(struct fsl_mc_driver *fsl_mc_driver,\n\t\t\t\t\t  struct module *owner);\n\nvoid fsl_mc_driver_unregister(struct fsl_mc_driver *driver);\n\n \nstruct fsl_mc_version {\n\tu32 major;\n\tu32 minor;\n\tu32 revision;\n};\n\nstruct fsl_mc_version *fsl_mc_get_version(void);\n\nint __must_check fsl_mc_portal_allocate(struct fsl_mc_device *mc_dev,\n\t\t\t\t\tu16 mc_io_flags,\n\t\t\t\t\tstruct fsl_mc_io **new_mc_io);\n\nvoid fsl_mc_portal_free(struct fsl_mc_io *mc_io);\n\nint fsl_mc_portal_reset(struct fsl_mc_io *mc_io);\n\nint __must_check fsl_mc_object_allocate(struct fsl_mc_device *mc_dev,\n\t\t\t\t\tenum fsl_mc_pool_type pool_type,\n\t\t\t\t\tstruct fsl_mc_device **new_mc_adev);\n\nvoid fsl_mc_object_free(struct fsl_mc_device *mc_adev);\n\nstruct irq_domain *fsl_mc_msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t\tstruct msi_domain_info *info,\n\t\t\t\t\t\tstruct irq_domain *parent);\n\nint __must_check fsl_mc_allocate_irqs(struct fsl_mc_device *mc_dev);\n\nvoid fsl_mc_free_irqs(struct fsl_mc_device *mc_dev);\n\nstruct fsl_mc_device *fsl_mc_get_endpoint(struct fsl_mc_device *mc_dev,\n\t\t\t\t\t  u16 if_id);\n\nextern struct bus_type fsl_mc_bus_type;\n\nextern struct device_type fsl_mc_bus_dprc_type;\nextern struct device_type fsl_mc_bus_dpni_type;\nextern struct device_type fsl_mc_bus_dpio_type;\nextern struct device_type fsl_mc_bus_dpsw_type;\nextern struct device_type fsl_mc_bus_dpbp_type;\nextern struct device_type fsl_mc_bus_dpcon_type;\nextern struct device_type fsl_mc_bus_dpmcp_type;\nextern struct device_type fsl_mc_bus_dpmac_type;\nextern struct device_type fsl_mc_bus_dprtc_type;\nextern struct device_type fsl_mc_bus_dpseci_type;\nextern struct device_type fsl_mc_bus_dpdmux_type;\nextern struct device_type fsl_mc_bus_dpdcei_type;\nextern struct device_type fsl_mc_bus_dpaiop_type;\nextern struct device_type fsl_mc_bus_dpci_type;\nextern struct device_type fsl_mc_bus_dpdmai_type;\n\nstatic inline bool is_fsl_mc_bus_dprc(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dprc_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpni(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpni_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpio(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpio_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpsw(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpsw_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpdmux(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpdmux_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpbp(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpbp_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpcon(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpcon_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpmcp(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpmcp_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpmac(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpmac_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dprtc(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dprtc_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpseci(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpseci_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpdcei(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpdcei_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpaiop(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpaiop_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpci(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpci_type;\n}\n\nstatic inline bool is_fsl_mc_bus_dpdmai(const struct fsl_mc_device *mc_dev)\n{\n\treturn mc_dev->dev.type == &fsl_mc_bus_dpdmai_type;\n}\n\n#define DPRC_RESET_OPTION_NON_RECURSIVE                0x00000001\nint dprc_reset_container(struct fsl_mc_io *mc_io,\n\t\t\t u32 cmd_flags,\n\t\t\t u16 token,\n\t\t\t int child_container_id,\n\t\t\t u32 options);\n\nint dprc_scan_container(struct fsl_mc_device *mc_bus_dev,\n\t\t\tbool alloc_interrupts);\n\nvoid dprc_remove_devices(struct fsl_mc_device *mc_bus_dev,\n\t\t\t struct fsl_mc_obj_desc *obj_desc_array,\n\t\t\t int num_child_objects_in_mc);\n\nint dprc_cleanup(struct fsl_mc_device *mc_dev);\n\nint dprc_setup(struct fsl_mc_device *mc_dev);\n\n \n#define FSL_MC_IRQ_POOL_MAX_TOTAL_IRQS\t256\n\nint fsl_mc_populate_irq_pool(struct fsl_mc_device *mc_bus_dev,\n\t\t\t     unsigned int irq_count);\n\nvoid fsl_mc_cleanup_irq_pool(struct fsl_mc_device *mc_bus_dev);\n\n \n\nint dpbp_open(struct fsl_mc_io *mc_io,\n\t      u32 cmd_flags,\n\t      int dpbp_id,\n\t      u16 *token);\n\nint dpbp_close(struct fsl_mc_io *mc_io,\n\t       u32 cmd_flags,\n\t       u16 token);\n\nint dpbp_enable(struct fsl_mc_io *mc_io,\n\t\tu32 cmd_flags,\n\t\tu16 token);\n\nint dpbp_disable(struct fsl_mc_io *mc_io,\n\t\t u32 cmd_flags,\n\t\t u16 token);\n\nint dpbp_reset(struct fsl_mc_io *mc_io,\n\t       u32 cmd_flags,\n\t       u16 token);\n\n \nstruct dpbp_attr {\n\tint id;\n\tu16 bpid;\n};\n\nint dpbp_get_attributes(struct fsl_mc_io *mc_io,\n\t\t\tu32 cmd_flags,\n\t\t\tu16 token,\n\t\t\tstruct dpbp_attr *attr);\n\n \n\n \n#define DPCON_INVALID_DPIO_ID\t\t(int)(-1)\n\nint dpcon_open(struct fsl_mc_io *mc_io,\n\t       u32 cmd_flags,\n\t       int dpcon_id,\n\t       u16 *token);\n\nint dpcon_close(struct fsl_mc_io *mc_io,\n\t\tu32 cmd_flags,\n\t\tu16 token);\n\nint dpcon_enable(struct fsl_mc_io *mc_io,\n\t\t u32 cmd_flags,\n\t\t u16 token);\n\nint dpcon_disable(struct fsl_mc_io *mc_io,\n\t\t  u32 cmd_flags,\n\t\t  u16 token);\n\nint dpcon_reset(struct fsl_mc_io *mc_io,\n\t\tu32 cmd_flags,\n\t\tu16 token);\n\nint fsl_mc_obj_open(struct fsl_mc_io *mc_io,\n\t\t    u32 cmd_flags,\n\t\t    int obj_id,\n\t\t    char *obj_type,\n\t\t    u16 *token);\n\nint fsl_mc_obj_close(struct fsl_mc_io *mc_io,\n\t\t     u32 cmd_flags,\n\t\t     u16 token);\n\nint fsl_mc_obj_reset(struct fsl_mc_io *mc_io,\n\t\t     u32 cmd_flags,\n\t\t     u16 token);\n\n \nstruct dpcon_attr {\n\tint id;\n\tu16 qbman_ch_id;\n\tu8 num_priorities;\n};\n\nint dpcon_get_attributes(struct fsl_mc_io *mc_io,\n\t\t\t u32 cmd_flags,\n\t\t\t u16 token,\n\t\t\t struct dpcon_attr *attr);\n\n \nstruct dpcon_notification_cfg {\n\tint dpio_id;\n\tu8 priority;\n\tu64 user_ctx;\n};\n\nint dpcon_set_notification(struct fsl_mc_io *mc_io,\n\t\t\t   u32 cmd_flags,\n\t\t\t   u16 token,\n\t\t\t   struct dpcon_notification_cfg *cfg);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}