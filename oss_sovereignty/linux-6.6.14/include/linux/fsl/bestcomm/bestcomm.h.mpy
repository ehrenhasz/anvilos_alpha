{
  "module_name": "bestcomm.h",
  "hash_id": "b1e4b1b2020fb376dde5bc097897029107e759cd8676fb12b9dfcdf0babaeac8",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fsl/bestcomm/bestcomm.h",
  "human_readable_source": " \n\n#ifndef __BESTCOMM_H__\n#define __BESTCOMM_H__\n\n \nstruct bcom_bd {\n\tu32\tstatus;\n\tu32\tdata[];\t \n};\n\n \n \n \n\n \nstruct bcom_task {\n\tunsigned int\ttasknum;\n\tunsigned int\tflags;\n\tint\t\tirq;\n\n\tstruct bcom_bd\t*bd;\n\tphys_addr_t\tbd_pa;\n\tvoid\t\t**cookie;\n\tunsigned short\tindex;\n\tunsigned short\toutdex;\n\tunsigned int\tnum_bd;\n\tunsigned int\tbd_size;\n\n\tvoid*\t\tpriv;\n};\n\n#define BCOM_FLAGS_NONE         0x00000000ul\n#define BCOM_FLAGS_ENABLE_TASK  (1ul <<  0)\n\n \nextern void bcom_enable(struct bcom_task *tsk);\n\n \nextern void bcom_disable(struct bcom_task *tsk);\n\n\n \nstatic inline int\nbcom_get_task_irq(struct bcom_task *tsk) {\n\treturn tsk->irq;\n}\n\n \n \n \n\n#define BCOM_BD_READY\t0x40000000ul\n\n \nstatic inline int\n_bcom_next_index(struct bcom_task *tsk)\n{\n\treturn ((tsk->index + 1) == tsk->num_bd) ? 0 : tsk->index + 1;\n}\n\n \nstatic inline int\n_bcom_next_outdex(struct bcom_task *tsk)\n{\n\treturn ((tsk->outdex + 1) == tsk->num_bd) ? 0 : tsk->outdex + 1;\n}\n\n \nstatic inline int\nbcom_queue_empty(struct bcom_task *tsk)\n{\n\treturn tsk->index == tsk->outdex;\n}\n\n \nstatic inline int\nbcom_queue_full(struct bcom_task *tsk)\n{\n\treturn tsk->outdex == _bcom_next_index(tsk);\n}\n\n \nstatic inline struct bcom_bd\n*bcom_get_bd(struct bcom_task *tsk, unsigned int index)\n{\n\t \n\treturn ((void *)tsk->bd) + (index * tsk->bd_size);\n}\n\n \nstatic inline int\nbcom_buffer_done(struct bcom_task *tsk)\n{\n\tstruct bcom_bd *bd;\n\tif (bcom_queue_empty(tsk))\n\t\treturn 0;\n\n\tbd = bcom_get_bd(tsk, tsk->outdex);\n\treturn !(bd->status & BCOM_BD_READY);\n}\n\n \nstatic inline struct bcom_bd *\nbcom_prepare_next_buffer(struct bcom_task *tsk)\n{\n\tstruct bcom_bd *bd;\n\n\tbd = bcom_get_bd(tsk, tsk->index);\n\tbd->status = 0;\t \n\treturn bd;\n}\n\nstatic inline void\nbcom_submit_next_buffer(struct bcom_task *tsk, void *cookie)\n{\n\tstruct bcom_bd *bd = bcom_get_bd(tsk, tsk->index);\n\n\ttsk->cookie[tsk->index] = cookie;\n\tmb();\t \n\tbd->status |= BCOM_BD_READY;\n\ttsk->index = _bcom_next_index(tsk);\n\tif (tsk->flags & BCOM_FLAGS_ENABLE_TASK)\n\t\tbcom_enable(tsk);\n}\n\nstatic inline void *\nbcom_retrieve_buffer(struct bcom_task *tsk, u32 *p_status, struct bcom_bd **p_bd)\n{\n\tvoid *cookie = tsk->cookie[tsk->outdex];\n\tstruct bcom_bd *bd = bcom_get_bd(tsk, tsk->outdex);\n\n\tif (p_status)\n\t\t*p_status = bd->status;\n\tif (p_bd)\n\t\t*p_bd = bd;\n\ttsk->outdex = _bcom_next_outdex(tsk);\n\treturn cookie;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}