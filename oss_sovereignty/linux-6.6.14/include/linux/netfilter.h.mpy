{
  "module_name": "netfilter.h",
  "hash_id": "faffe566da26f9e0e44b62c65b04a92e8ed4edb7b6c52b49d81219f8938a7818",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/netfilter.h",
  "human_readable_source": " \n#ifndef __LINUX_NETFILTER_H\n#define __LINUX_NETFILTER_H\n\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/net.h>\n#include <linux/if.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/static_key.h>\n#include <linux/module.h>\n#include <linux/netfilter_defs.h>\n#include <linux/netdevice.h>\n#include <linux/sockptr.h>\n#include <net/net_namespace.h>\n\nstatic inline int NF_DROP_GETERR(int verdict)\n{\n\treturn -(verdict >> NF_VERDICT_QBITS);\n}\n\nstatic inline int nf_inet_addr_cmp(const union nf_inet_addr *a1,\n\t\t\t\t   const union nf_inet_addr *a2)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul1 = (const unsigned long *)a1;\n\tconst unsigned long *ul2 = (const unsigned long *)a2;\n\n\treturn ((ul1[0] ^ ul2[0]) | (ul1[1] ^ ul2[1])) == 0UL;\n#else\n\treturn a1->all[0] == a2->all[0] &&\n\t       a1->all[1] == a2->all[1] &&\n\t       a1->all[2] == a2->all[2] &&\n\t       a1->all[3] == a2->all[3];\n#endif\n}\n\nstatic inline void nf_inet_addr_mask(const union nf_inet_addr *a1,\n\t\t\t\t     union nf_inet_addr *result,\n\t\t\t\t     const union nf_inet_addr *mask)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ua = (const unsigned long *)a1;\n\tunsigned long *ur = (unsigned long *)result;\n\tconst unsigned long *um = (const unsigned long *)mask;\n\n\tur[0] = ua[0] & um[0];\n\tur[1] = ua[1] & um[1];\n#else\n\tresult->all[0] = a1->all[0] & mask->all[0];\n\tresult->all[1] = a1->all[1] & mask->all[1];\n\tresult->all[2] = a1->all[2] & mask->all[2];\n\tresult->all[3] = a1->all[3] & mask->all[3];\n#endif\n}\n\nint netfilter_init(void);\n\nstruct sk_buff;\n\nstruct nf_hook_ops;\n\nstruct sock;\n\nstruct nf_hook_state {\n\tu8 hook;\n\tu8 pf;\n\tstruct net_device *in;\n\tstruct net_device *out;\n\tstruct sock *sk;\n\tstruct net *net;\n\tint (*okfn)(struct net *, struct sock *, struct sk_buff *);\n};\n\ntypedef unsigned int nf_hookfn(void *priv,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       const struct nf_hook_state *state);\nenum nf_hook_ops_type {\n\tNF_HOOK_OP_UNDEFINED,\n\tNF_HOOK_OP_NF_TABLES,\n\tNF_HOOK_OP_BPF,\n};\n\nstruct nf_hook_ops {\n\t \n\tnf_hookfn\t\t*hook;\n\tstruct net_device\t*dev;\n\tvoid\t\t\t*priv;\n\tu8\t\t\tpf;\n\tenum nf_hook_ops_type\thook_ops_type:8;\n\tunsigned int\t\thooknum;\n\t \n\tint\t\t\tpriority;\n};\n\nstruct nf_hook_entry {\n\tnf_hookfn\t\t\t*hook;\n\tvoid\t\t\t\t*priv;\n};\n\nstruct nf_hook_entries_rcu_head {\n\tstruct rcu_head head;\n\tvoid\t*allocation;\n};\n\nstruct nf_hook_entries {\n\tu16\t\t\t\tnum_hook_entries;\n\t \n\tstruct nf_hook_entry\t\thooks[];\n\n\t \n};\n\n#ifdef CONFIG_NETFILTER\nstatic inline struct nf_hook_ops **nf_hook_entries_get_hook_ops(const struct nf_hook_entries *e)\n{\n\tunsigned int n = e->num_hook_entries;\n\tconst void *hook_end;\n\n\thook_end = &e->hooks[n];  \n\n\treturn (struct nf_hook_ops **)hook_end;\n}\n\nstatic inline int\nnf_hook_entry_hookfn(const struct nf_hook_entry *entry, struct sk_buff *skb,\n\t\t     struct nf_hook_state *state)\n{\n\treturn entry->hook(entry->priv, skb, state);\n}\n\nstatic inline void nf_hook_state_init(struct nf_hook_state *p,\n\t\t\t\t      unsigned int hook,\n\t\t\t\t      u_int8_t pf,\n\t\t\t\t      struct net_device *indev,\n\t\t\t\t      struct net_device *outdev,\n\t\t\t\t      struct sock *sk,\n\t\t\t\t      struct net *net,\n\t\t\t\t      int (*okfn)(struct net *, struct sock *, struct sk_buff *))\n{\n\tp->hook = hook;\n\tp->pf = pf;\n\tp->in = indev;\n\tp->out = outdev;\n\tp->sk = sk;\n\tp->net = net;\n\tp->okfn = okfn;\n}\n\n\n\nstruct nf_sockopt_ops {\n\tstruct list_head list;\n\n\tu_int8_t pf;\n\n\t \n\tint set_optmin;\n\tint set_optmax;\n\tint (*set)(struct sock *sk, int optval, sockptr_t arg,\n\t\t   unsigned int len);\n\tint get_optmin;\n\tint get_optmax;\n\tint (*get)(struct sock *sk, int optval, void __user *user, int *len);\n\t \n\tstruct module *owner;\n};\n\n \nint nf_register_net_hook(struct net *net, const struct nf_hook_ops *ops);\nvoid nf_unregister_net_hook(struct net *net, const struct nf_hook_ops *ops);\nint nf_register_net_hooks(struct net *net, const struct nf_hook_ops *reg,\n\t\t\t  unsigned int n);\nvoid nf_unregister_net_hooks(struct net *net, const struct nf_hook_ops *reg,\n\t\t\t     unsigned int n);\n\n \nint nf_register_sockopt(struct nf_sockopt_ops *reg);\nvoid nf_unregister_sockopt(struct nf_sockopt_ops *reg);\n\n#ifdef CONFIG_JUMP_LABEL\nextern struct static_key nf_hooks_needed[NFPROTO_NUMPROTO][NF_MAX_HOOKS];\n#endif\n\nint nf_hook_slow(struct sk_buff *skb, struct nf_hook_state *state,\n\t\t const struct nf_hook_entries *e, unsigned int i);\n\nvoid nf_hook_slow_list(struct list_head *head, struct nf_hook_state *state,\n\t\t       const struct nf_hook_entries *e);\n \nstatic inline int nf_hook(u_int8_t pf, unsigned int hook, struct net *net,\n\t\t\t  struct sock *sk, struct sk_buff *skb,\n\t\t\t  struct net_device *indev, struct net_device *outdev,\n\t\t\t  int (*okfn)(struct net *, struct sock *, struct sk_buff *))\n{\n\tstruct nf_hook_entries *hook_head = NULL;\n\tint ret = 1;\n\n#ifdef CONFIG_JUMP_LABEL\n\tif (__builtin_constant_p(pf) &&\n\t    __builtin_constant_p(hook) &&\n\t    !static_key_false(&nf_hooks_needed[pf][hook]))\n\t\treturn 1;\n#endif\n\n\trcu_read_lock();\n\tswitch (pf) {\n\tcase NFPROTO_IPV4:\n\t\thook_head = rcu_dereference(net->nf.hooks_ipv4[hook]);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\thook_head = rcu_dereference(net->nf.hooks_ipv6[hook]);\n\t\tbreak;\n\tcase NFPROTO_ARP:\n#ifdef CONFIG_NETFILTER_FAMILY_ARP\n\t\tif (WARN_ON_ONCE(hook >= ARRAY_SIZE(net->nf.hooks_arp)))\n\t\t\tbreak;\n\t\thook_head = rcu_dereference(net->nf.hooks_arp[hook]);\n#endif\n\t\tbreak;\n\tcase NFPROTO_BRIDGE:\n#ifdef CONFIG_NETFILTER_FAMILY_BRIDGE\n\t\thook_head = rcu_dereference(net->nf.hooks_bridge[hook]);\n#endif\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\tif (hook_head) {\n\t\tstruct nf_hook_state state;\n\n\t\tnf_hook_state_init(&state, hook, pf, indev, outdev,\n\t\t\t\t   sk, net, okfn);\n\n\t\tret = nf_hook_slow(skb, &state, hook_head, 0);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n \n\n \n\nstatic inline int\nNF_HOOK_COND(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk,\n\t     struct sk_buff *skb, struct net_device *in, struct net_device *out,\n\t     int (*okfn)(struct net *, struct sock *, struct sk_buff *),\n\t     bool cond)\n{\n\tint ret;\n\n\tif (!cond ||\n\t    ((ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn)) == 1))\n\t\tret = okfn(net, sk, skb);\n\treturn ret;\n}\n\nstatic inline int\nNF_HOOK(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk, struct sk_buff *skb,\n\tstruct net_device *in, struct net_device *out,\n\tint (*okfn)(struct net *, struct sock *, struct sk_buff *))\n{\n\tint ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);\n\tif (ret == 1)\n\t\tret = okfn(net, sk, skb);\n\treturn ret;\n}\n\nstatic inline void\nNF_HOOK_LIST(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk,\n\t     struct list_head *head, struct net_device *in, struct net_device *out,\n\t     int (*okfn)(struct net *, struct sock *, struct sk_buff *))\n{\n\tstruct nf_hook_entries *hook_head = NULL;\n\n#ifdef CONFIG_JUMP_LABEL\n\tif (__builtin_constant_p(pf) &&\n\t    __builtin_constant_p(hook) &&\n\t    !static_key_false(&nf_hooks_needed[pf][hook]))\n\t\treturn;\n#endif\n\n\trcu_read_lock();\n\tswitch (pf) {\n\tcase NFPROTO_IPV4:\n\t\thook_head = rcu_dereference(net->nf.hooks_ipv4[hook]);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\thook_head = rcu_dereference(net->nf.hooks_ipv6[hook]);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\tif (hook_head) {\n\t\tstruct nf_hook_state state;\n\n\t\tnf_hook_state_init(&state, hook, pf, in, out, sk, net, okfn);\n\n\t\tnf_hook_slow_list(head, &state, hook_head);\n\t}\n\trcu_read_unlock();\n}\n\n \nint nf_setsockopt(struct sock *sk, u_int8_t pf, int optval, sockptr_t opt,\n\t\t  unsigned int len);\nint nf_getsockopt(struct sock *sk, u_int8_t pf, int optval, char __user *opt,\n\t\t  int *len);\n\nstruct flowi;\nstruct nf_queue_entry;\n\n__sum16 nf_checksum(struct sk_buff *skb, unsigned int hook,\n\t\t    unsigned int dataoff, u_int8_t protocol,\n\t\t    unsigned short family);\n\n__sum16 nf_checksum_partial(struct sk_buff *skb, unsigned int hook,\n\t\t\t    unsigned int dataoff, unsigned int len,\n\t\t\t    u_int8_t protocol, unsigned short family);\nint nf_route(struct net *net, struct dst_entry **dst, struct flowi *fl,\n\t     bool strict, unsigned short family);\nint nf_reroute(struct sk_buff *skb, struct nf_queue_entry *entry);\n\n#include <net/flow.h>\n\nstruct nf_conn;\nenum nf_nat_manip_type;\nstruct nlattr;\nenum ip_conntrack_dir;\n\nstruct nf_nat_hook {\n\tint (*parse_nat_setup)(struct nf_conn *ct, enum nf_nat_manip_type manip,\n\t\t\t       const struct nlattr *attr);\n\tvoid (*decode_session)(struct sk_buff *skb, struct flowi *fl);\n\tunsigned int (*manip_pkt)(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t\t  enum nf_nat_manip_type mtype,\n\t\t\t\t  enum ip_conntrack_dir dir);\n\tvoid (*remove_nat_bysrc)(struct nf_conn *ct);\n};\n\nextern const struct nf_nat_hook __rcu *nf_nat_hook;\n\nstatic inline void\nnf_nat_decode_session(struct sk_buff *skb, struct flowi *fl, u_int8_t family)\n{\n#if IS_ENABLED(CONFIG_NF_NAT)\n\tconst struct nf_nat_hook *nat_hook;\n\n\trcu_read_lock();\n\tnat_hook = rcu_dereference(nf_nat_hook);\n\tif (nat_hook && nat_hook->decode_session)\n\t\tnat_hook->decode_session(skb, fl);\n\trcu_read_unlock();\n#endif\n}\n\n#else  \nstatic inline int\nNF_HOOK_COND(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk,\n\t     struct sk_buff *skb, struct net_device *in, struct net_device *out,\n\t     int (*okfn)(struct net *, struct sock *, struct sk_buff *),\n\t     bool cond)\n{\n\treturn okfn(net, sk, skb);\n}\n\nstatic inline int\nNF_HOOK(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk,\n\tstruct sk_buff *skb, struct net_device *in, struct net_device *out,\n\tint (*okfn)(struct net *, struct sock *, struct sk_buff *))\n{\n\treturn okfn(net, sk, skb);\n}\n\nstatic inline void\nNF_HOOK_LIST(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk,\n\t     struct list_head *head, struct net_device *in, struct net_device *out,\n\t     int (*okfn)(struct net *, struct sock *, struct sk_buff *))\n{\n\t \n}\n\nstatic inline int nf_hook(u_int8_t pf, unsigned int hook, struct net *net,\n\t\t\t  struct sock *sk, struct sk_buff *skb,\n\t\t\t  struct net_device *indev, struct net_device *outdev,\n\t\t\t  int (*okfn)(struct net *, struct sock *, struct sk_buff *))\n{\n\treturn 1;\n}\nstruct flowi;\nstatic inline void\nnf_nat_decode_session(struct sk_buff *skb, struct flowi *fl, u_int8_t family)\n{\n}\n#endif  \n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#include <linux/netfilter/nf_conntrack_zones_common.h>\n\nvoid nf_ct_attach(struct sk_buff *, const struct sk_buff *);\nvoid nf_ct_set_closing(struct nf_conntrack *nfct);\nstruct nf_conntrack_tuple;\nbool nf_ct_get_tuple_skb(struct nf_conntrack_tuple *dst_tuple,\n\t\t\t const struct sk_buff *skb);\n#else\nstatic inline void nf_ct_attach(struct sk_buff *new, struct sk_buff *skb) {}\nstatic inline void nf_ct_set_closing(struct nf_conntrack *nfct) {}\nstruct nf_conntrack_tuple;\nstatic inline bool nf_ct_get_tuple_skb(struct nf_conntrack_tuple *dst_tuple,\n\t\t\t\t       const struct sk_buff *skb)\n{\n\treturn false;\n}\n#endif\n\nstruct nf_conn;\nenum ip_conntrack_info;\n\nstruct nf_ct_hook {\n\tint (*update)(struct net *net, struct sk_buff *skb);\n\tvoid (*destroy)(struct nf_conntrack *);\n\tbool (*get_tuple_skb)(struct nf_conntrack_tuple *,\n\t\t\t      const struct sk_buff *);\n\tvoid (*attach)(struct sk_buff *nskb, const struct sk_buff *skb);\n\tvoid (*set_closing)(struct nf_conntrack *nfct);\n};\nextern const struct nf_ct_hook __rcu *nf_ct_hook;\n\nstruct nlattr;\n\nstruct nfnl_ct_hook {\n\tsize_t (*build_size)(const struct nf_conn *ct);\n\tint (*build)(struct sk_buff *skb, struct nf_conn *ct,\n\t\t     enum ip_conntrack_info ctinfo,\n\t\t     u_int16_t ct_attr, u_int16_t ct_info_attr);\n\tint (*parse)(const struct nlattr *attr, struct nf_conn *ct);\n\tint (*attach_expect)(const struct nlattr *attr, struct nf_conn *ct,\n\t\t\t     u32 portid, u32 report);\n\tvoid (*seq_adjust)(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t   enum ip_conntrack_info ctinfo, s32 off);\n};\nextern const struct nfnl_ct_hook __rcu *nfnl_ct_hook;\n\nstruct nf_defrag_hook {\n\tstruct module *owner;\n\tint (*enable)(struct net *net);\n\tvoid (*disable)(struct net *net);\n};\n\nextern const struct nf_defrag_hook __rcu *nf_defrag_v4_hook;\nextern const struct nf_defrag_hook __rcu *nf_defrag_v6_hook;\n\n \nDECLARE_PER_CPU(bool, nf_skb_duplicated);\n\n \nextern u8 nf_ctnetlink_has_listener;\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}