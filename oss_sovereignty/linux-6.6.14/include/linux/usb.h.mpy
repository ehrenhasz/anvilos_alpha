{
  "module_name": "usb.h",
  "hash_id": "a968980744a34bac04fdebfafc847eafdd4dcaf487ec56bdffa8ca9377ef89f8",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/usb.h",
  "human_readable_source": " \n#ifndef __LINUX_USB_H\n#define __LINUX_USB_H\n\n#include <linux/mod_devicetable.h>\n#include <linux/usb/ch9.h>\n\n#define USB_MAJOR\t\t\t180\n#define USB_DEVICE_MAJOR\t\t189\n\n\n#ifdef __KERNEL__\n\n#include <linux/errno.h>         \n#include <linux/delay.h>\t \n#include <linux/interrupt.h>\t \n#include <linux/list.h>\t\t \n#include <linux/kref.h>\t\t \n#include <linux/device.h>\t \n#include <linux/fs.h>\t\t \n#include <linux/completion.h>\t \n#include <linux/sched.h>\t \n#include <linux/mutex.h>\t \n#include <linux/pm_runtime.h>\t \n\nstruct usb_device;\nstruct usb_driver;\n\n \n\n \n\nstruct ep_device;\n\n \nstruct usb_host_endpoint {\n\tstruct usb_endpoint_descriptor\t\tdesc;\n\tstruct usb_ss_ep_comp_descriptor\tss_ep_comp;\n\tstruct usb_ssp_isoc_ep_comp_descriptor\tssp_isoc_ep_comp;\n\tstruct list_head\t\turb_list;\n\tvoid\t\t\t\t*hcpriv;\n\tstruct ep_device\t\t*ep_dev;\t \n\n\tunsigned char *extra;    \n\tint extralen;\n\tint enabled;\n\tint streams;\n};\n\n \nstruct usb_host_interface {\n\tstruct usb_interface_descriptor\tdesc;\n\n\tint extralen;\n\tunsigned char *extra;    \n\n\t \n\tstruct usb_host_endpoint *endpoint;\n\n\tchar *string;\t\t \n};\n\nenum usb_interface_condition {\n\tUSB_INTERFACE_UNBOUND = 0,\n\tUSB_INTERFACE_BINDING,\n\tUSB_INTERFACE_BOUND,\n\tUSB_INTERFACE_UNBINDING,\n};\n\nint __must_check\nusb_find_common_endpoints(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out);\n\nint __must_check\nusb_find_common_endpoints_reverse(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out);\n\nstatic inline int __must_check\nusb_find_bulk_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in)\n{\n\treturn usb_find_common_endpoints(alt, bulk_in, NULL, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_bulk_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_out)\n{\n\treturn usb_find_common_endpoints(alt, NULL, bulk_out, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_int_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_in)\n{\n\treturn usb_find_common_endpoints(alt, NULL, NULL, int_in, NULL);\n}\n\nstatic inline int __must_check\nusb_find_int_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\treturn usb_find_common_endpoints(alt, NULL, NULL, NULL, int_out);\n}\n\nstatic inline int __must_check\nusb_find_last_bulk_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in)\n{\n\treturn usb_find_common_endpoints_reverse(alt, bulk_in, NULL, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_bulk_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_out)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, bulk_out, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_int_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_in)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, NULL, int_in, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_int_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, NULL, NULL, int_out);\n}\n\nenum usb_wireless_status {\n\tUSB_WIRELESS_STATUS_NA = 0,\n\tUSB_WIRELESS_STATUS_DISCONNECTED,\n\tUSB_WIRELESS_STATUS_CONNECTED,\n};\n\n \nstruct usb_interface {\n\t \n\tstruct usb_host_interface *altsetting;\n\n\tstruct usb_host_interface *cur_altsetting;\t \n\tunsigned num_altsetting;\t \n\n\t \n\tstruct usb_interface_assoc_descriptor *intf_assoc;\n\n\tint minor;\t\t\t \n\tenum usb_interface_condition condition;\t\t \n\tunsigned sysfs_files_created:1;\t \n\tunsigned ep_devs_created:1;\t \n\tunsigned unregistering:1;\t \n\tunsigned needs_remote_wakeup:1;\t \n\tunsigned needs_altsetting0:1;\t \n\tunsigned needs_binding:1;\t \n\tunsigned resetting_device:1;\t \n\tunsigned authorized:1;\t\t \n\tenum usb_wireless_status wireless_status;\n\tstruct work_struct wireless_status_work;\n\n\tstruct device dev;\t\t \n\tstruct device *usb_dev;\n\tstruct work_struct reset_ws;\t \n};\n\n#define to_usb_interface(__dev)\tcontainer_of_const(__dev, struct usb_interface, dev)\n\nstatic inline void *usb_get_intfdata(struct usb_interface *intf)\n{\n\treturn dev_get_drvdata(&intf->dev);\n}\n\n \nstatic inline void usb_set_intfdata(struct usb_interface *intf, void *data)\n{\n\tdev_set_drvdata(&intf->dev, data);\n}\n\nstruct usb_interface *usb_get_intf(struct usb_interface *intf);\nvoid usb_put_intf(struct usb_interface *intf);\n\n \n#define USB_MAXENDPOINTS\t30\n \n#define USB_MAXINTERFACES\t32\n#define USB_MAXIADS\t\t(USB_MAXINTERFACES/2)\n\nbool usb_check_bulk_endpoints(\n\t\tconst struct usb_interface *intf, const u8 *ep_addrs);\nbool usb_check_int_endpoints(\n\t\tconst struct usb_interface *intf, const u8 *ep_addrs);\n\n \n#define USB_RESUME_TIMEOUT\t40  \n\n \nstruct usb_interface_cache {\n\tunsigned num_altsetting;\t \n\tstruct kref ref;\t\t \n\n\t \n\tstruct usb_host_interface altsetting[];\n};\n#define\tref_to_usb_interface_cache(r) \\\n\t\tcontainer_of(r, struct usb_interface_cache, ref)\n#define\taltsetting_to_usb_interface_cache(a) \\\n\t\tcontainer_of(a, struct usb_interface_cache, altsetting[0])\n\n \nstruct usb_host_config {\n\tstruct usb_config_descriptor\tdesc;\n\n\tchar *string;\t\t \n\n\t \n\tstruct usb_interface_assoc_descriptor *intf_assoc[USB_MAXIADS];\n\n\t \n\tstruct usb_interface *interface[USB_MAXINTERFACES];\n\n\t \n\tstruct usb_interface_cache *intf_cache[USB_MAXINTERFACES];\n\n\tunsigned char *extra;    \n\tint extralen;\n};\n\n \nstruct usb_host_bos {\n\tstruct usb_bos_descriptor\t*desc;\n\n\tstruct usb_ext_cap_descriptor\t*ext_cap;\n\tstruct usb_ss_cap_descriptor\t*ss_cap;\n\tstruct usb_ssp_cap_descriptor\t*ssp_cap;\n\tstruct usb_ss_container_id_descriptor\t*ss_id;\n\tstruct usb_ptm_cap_descriptor\t*ptm_cap;\n};\n\nint __usb_get_extra_descriptor(char *buffer, unsigned size,\n\tunsigned char type, void **ptr, size_t min);\n#define usb_get_extra_descriptor(ifpoint, type, ptr) \\\n\t\t\t\t__usb_get_extra_descriptor((ifpoint)->extra, \\\n\t\t\t\t(ifpoint)->extralen, \\\n\t\t\t\ttype, (void **)ptr, sizeof(**(ptr)))\n\n \n\n \nstruct usb_devmap {\n\tunsigned long devicemap[128 / (8*sizeof(unsigned long))];\n};\n\n \nstruct usb_bus {\n\tstruct device *controller;\t \n\tstruct device *sysdev;\t\t \n\tint busnum;\t\t\t \n\tconst char *bus_name;\t\t \n\tu8 uses_pio_for_control;\t \n\tu8 otg_port;\t\t\t \n\tunsigned is_b_host:1;\t\t \n\tunsigned b_hnp_enable:1;\t \n\tunsigned no_stop_on_short:1;     \n\tunsigned no_sg_constraint:1;\t \n\tunsigned sg_tablesize;\t\t \n\n\tint devnum_next;\t\t \n\tstruct mutex devnum_next_mutex;  \n\n\tstruct usb_devmap devmap;\t \n\tstruct usb_device *root_hub;\t \n\tstruct usb_bus *hs_companion;\t \n\n\tint bandwidth_allocated;\t \n\tint bandwidth_int_reqs;\t\t \n\tint bandwidth_isoc_reqs;\t \n\n\tunsigned resuming_ports;\t \n\n#if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)\n\tstruct mon_bus *mon_bus;\t \n\tint monitored;\t\t\t \n#endif\n};\n\nstruct usb_dev_state;\n\n \n\nstruct usb_tt;\n\nenum usb_port_connect_type {\n\tUSB_PORT_CONNECT_TYPE_UNKNOWN = 0,\n\tUSB_PORT_CONNECT_TYPE_HOT_PLUG,\n\tUSB_PORT_CONNECT_TYPE_HARD_WIRED,\n\tUSB_PORT_NOT_USED,\n};\n\n \n\n \n#define USB_PORT_QUIRK_OLD_SCHEME\tBIT(0)\n\n \n#define USB_PORT_QUIRK_FAST_ENUM\tBIT(1)\n\n \nstruct usb2_lpm_parameters {\n\t \n\tunsigned int besl;\n\n\t \n\tint timeout;\n};\n\n \nstruct usb3_lpm_parameters {\n\t \n\tunsigned int mel;\n\t \n\tunsigned int pel;\n\n\t \n\tunsigned int sel;\n\t \n\tint timeout;\n};\n\n \nstruct usb_device {\n\tint\t\tdevnum;\n\tchar\t\tdevpath[16];\n\tu32\t\troute;\n\tenum usb_device_state\tstate;\n\tenum usb_device_speed\tspeed;\n\tunsigned int\t\trx_lanes;\n\tunsigned int\t\ttx_lanes;\n\tenum usb_ssp_rate\tssp_rate;\n\n\tstruct usb_tt\t*tt;\n\tint\t\tttport;\n\n\tunsigned int toggle[2];\n\n\tstruct usb_device *parent;\n\tstruct usb_bus *bus;\n\tstruct usb_host_endpoint ep0;\n\n\tstruct device dev;\n\n\tstruct usb_device_descriptor descriptor;\n\tstruct usb_host_bos *bos;\n\tstruct usb_host_config *config;\n\n\tstruct usb_host_config *actconfig;\n\tstruct usb_host_endpoint *ep_in[16];\n\tstruct usb_host_endpoint *ep_out[16];\n\n\tchar **rawdescriptors;\n\n\tunsigned short bus_mA;\n\tu8 portnum;\n\tu8 level;\n\tu8 devaddr;\n\n\tunsigned can_submit:1;\n\tunsigned persist_enabled:1;\n\tunsigned reset_in_progress:1;\n\tunsigned have_langid:1;\n\tunsigned authorized:1;\n\tunsigned authenticated:1;\n\tunsigned lpm_capable:1;\n\tunsigned lpm_devinit_allow:1;\n\tunsigned usb2_hw_lpm_capable:1;\n\tunsigned usb2_hw_lpm_besl_capable:1;\n\tunsigned usb2_hw_lpm_enabled:1;\n\tunsigned usb2_hw_lpm_allowed:1;\n\tunsigned usb3_lpm_u1_enabled:1;\n\tunsigned usb3_lpm_u2_enabled:1;\n\tint string_langid;\n\n\t \n\tchar *product;\n\tchar *manufacturer;\n\tchar *serial;\n\n\tstruct list_head filelist;\n\n\tint maxchild;\n\n\tu32 quirks;\n\tatomic_t urbnum;\n\n\tunsigned long active_duration;\n\n\tunsigned long connect_time;\n\n\tunsigned do_remote_wakeup:1;\n\tunsigned reset_resume:1;\n\tunsigned port_is_suspended:1;\n\n\tint slot_id;\n\tstruct usb2_lpm_parameters l1_params;\n\tstruct usb3_lpm_parameters u1_params;\n\tstruct usb3_lpm_parameters u2_params;\n\tunsigned lpm_disable_count;\n\n\tu16 hub_delay;\n\tunsigned use_generic_driver:1;\n};\n\n#define to_usb_device(__dev)\tcontainer_of_const(__dev, struct usb_device, dev)\n\nstatic inline struct usb_device *__intf_to_usbdev(struct usb_interface *intf)\n{\n\treturn to_usb_device(intf->dev.parent);\n}\nstatic inline const struct usb_device *__intf_to_usbdev_const(const struct usb_interface *intf)\n{\n\treturn to_usb_device((const struct device *)intf->dev.parent);\n}\n\n#define interface_to_usbdev(intf)\t\t\t\t\t\\\n\t_Generic((intf),\t\t\t\t\t\t\\\n\t\t const struct usb_interface *: __intf_to_usbdev_const,\t\\\n\t\t struct usb_interface *: __intf_to_usbdev)(intf)\n\nextern struct usb_device *usb_get_dev(struct usb_device *dev);\nextern void usb_put_dev(struct usb_device *dev);\nextern struct usb_device *usb_hub_find_child(struct usb_device *hdev,\n\tint port1);\n\n \n#define usb_hub_for_each_child(hdev, port1, child) \\\n\tfor (port1 = 1,\tchild =\tusb_hub_find_child(hdev, port1); \\\n\t\t\tport1 <= hdev->maxchild; \\\n\t\t\tchild = usb_hub_find_child(hdev, ++port1)) \\\n\t\tif (!child) continue; else\n\n \n#define usb_lock_device(udev)\t\t\tdevice_lock(&(udev)->dev)\n#define usb_unlock_device(udev)\t\t\tdevice_unlock(&(udev)->dev)\n#define usb_lock_device_interruptible(udev)\tdevice_lock_interruptible(&(udev)->dev)\n#define usb_trylock_device(udev)\t\tdevice_trylock(&(udev)->dev)\nextern int usb_lock_device_for_reset(struct usb_device *udev,\n\t\t\t\t     const struct usb_interface *iface);\n\n \nextern int usb_reset_device(struct usb_device *dev);\nextern void usb_queue_reset_device(struct usb_interface *dev);\n\nextern struct device *usb_intf_get_dma_device(struct usb_interface *intf);\n\n#ifdef CONFIG_ACPI\nextern int usb_acpi_set_power_state(struct usb_device *hdev, int index,\n\tbool enable);\nextern bool usb_acpi_power_manageable(struct usb_device *hdev, int index);\nextern int usb_acpi_port_lpm_incapable(struct usb_device *hdev, int index);\n#else\nstatic inline int usb_acpi_set_power_state(struct usb_device *hdev, int index,\n\tbool enable) { return 0; }\nstatic inline bool usb_acpi_power_manageable(struct usb_device *hdev, int index)\n\t{ return true; }\nstatic inline int usb_acpi_port_lpm_incapable(struct usb_device *hdev, int index)\n\t{ return 0; }\n#endif\n\n \n#ifdef CONFIG_PM\nextern void usb_enable_autosuspend(struct usb_device *udev);\nextern void usb_disable_autosuspend(struct usb_device *udev);\n\nextern int usb_autopm_get_interface(struct usb_interface *intf);\nextern void usb_autopm_put_interface(struct usb_interface *intf);\nextern int usb_autopm_get_interface_async(struct usb_interface *intf);\nextern void usb_autopm_put_interface_async(struct usb_interface *intf);\nextern void usb_autopm_get_interface_no_resume(struct usb_interface *intf);\nextern void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);\n\nstatic inline void usb_mark_last_busy(struct usb_device *udev)\n{\n\tpm_runtime_mark_last_busy(&udev->dev);\n}\n\n#else\n\nstatic inline int usb_enable_autosuspend(struct usb_device *udev)\n{ return 0; }\nstatic inline int usb_disable_autosuspend(struct usb_device *udev)\n{ return 0; }\n\nstatic inline int usb_autopm_get_interface(struct usb_interface *intf)\n{ return 0; }\nstatic inline int usb_autopm_get_interface_async(struct usb_interface *intf)\n{ return 0; }\n\nstatic inline void usb_autopm_put_interface(struct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_put_interface_async(struct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_get_interface_no_resume(\n\t\tstruct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_put_interface_no_suspend(\n\t\tstruct usb_interface *intf)\n{ }\nstatic inline void usb_mark_last_busy(struct usb_device *udev)\n{ }\n#endif\n\nextern int usb_disable_lpm(struct usb_device *udev);\nextern void usb_enable_lpm(struct usb_device *udev);\n \nextern int usb_unlocked_disable_lpm(struct usb_device *udev);\nextern void usb_unlocked_enable_lpm(struct usb_device *udev);\n\nextern int usb_disable_ltm(struct usb_device *udev);\nextern void usb_enable_ltm(struct usb_device *udev);\n\nstatic inline bool usb_device_supports_ltm(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER || !udev->bos || !udev->bos->ss_cap)\n\t\treturn false;\n\treturn udev->bos->ss_cap->bmAttributes & USB_LTM_SUPPORT;\n}\n\nstatic inline bool usb_device_no_sg_constraint(struct usb_device *udev)\n{\n\treturn udev && udev->bus && udev->bus->no_sg_constraint;\n}\n\n\n \n\n \nextern int usb_get_current_frame_number(struct usb_device *usb_dev);\n\n \nextern int usb_alloc_streams(struct usb_interface *interface,\n\t\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\t\tunsigned int num_streams, gfp_t mem_flags);\n\n \nextern int usb_free_streams(struct usb_interface *interface,\n\t\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\t\tgfp_t mem_flags);\n\n \nextern int usb_driver_claim_interface(struct usb_driver *driver,\n\t\t\tstruct usb_interface *iface, void *data);\n\n \nstatic inline int usb_interface_claimed(struct usb_interface *iface)\n{\n\treturn (iface->dev.driver != NULL);\n}\n\nextern void usb_driver_release_interface(struct usb_driver *driver,\n\t\t\tstruct usb_interface *iface);\n\nint usb_set_wireless_status(struct usb_interface *iface,\n\t\t\tenum usb_wireless_status status);\n\nconst struct usb_device_id *usb_match_id(struct usb_interface *interface,\n\t\t\t\t\t const struct usb_device_id *id);\nextern int usb_match_one_id(struct usb_interface *interface,\n\t\t\t    const struct usb_device_id *id);\n\nextern int usb_for_each_dev(void *data, int (*fn)(struct usb_device *, void *));\nextern struct usb_interface *usb_find_interface(struct usb_driver *drv,\n\t\tint minor);\nextern struct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,\n\t\tunsigned ifnum);\nextern struct usb_host_interface *usb_altnum_to_altsetting(\n\t\tconst struct usb_interface *intf, unsigned int altnum);\nextern struct usb_host_interface *usb_find_alt_setting(\n\t\tstruct usb_host_config *config,\n\t\tunsigned int iface_num,\n\t\tunsigned int alt_num);\n\n \nint usb_hub_claim_port(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state *owner);\nint usb_hub_release_port(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state *owner);\n\n \nstatic inline int usb_make_path(struct usb_device *dev, char *buf, size_t size)\n{\n\tint actual;\n\tactual = snprintf(buf, size, \"usb-%s-%s\", dev->bus->bus_name,\n\t\t\t  dev->devpath);\n\treturn (actual >= (int)size) ? -1 : actual;\n}\n\n \n\n#define USB_DEVICE_ID_MATCH_DEVICE \\\n\t\t(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)\n#define USB_DEVICE_ID_MATCH_DEV_RANGE \\\n\t\t(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)\n#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION \\\n\t\t(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)\n#define USB_DEVICE_ID_MATCH_DEV_INFO \\\n\t\t(USB_DEVICE_ID_MATCH_DEV_CLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_DEV_SUBCLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_DEV_PROTOCOL)\n#define USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t(USB_DEVICE_ID_MATCH_INT_CLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_INT_SUBCLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_INT_PROTOCOL)\n\n \n#define USB_DEVICE(vend, prod) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod)\n \n#define USB_DEVICE_VER(vend, prod, lo, hi) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bcdDevice_lo = (lo), \\\n\t.bcdDevice_hi = (hi)\n\n \n#define USB_DEVICE_INTERFACE_CLASS(vend, prod, cl) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_CLASS, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceClass = (cl)\n\n \n#define USB_DEVICE_INTERFACE_PROTOCOL(vend, prod, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_PROTOCOL, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceProtocol = (pr)\n\n \n#define USB_DEVICE_INTERFACE_NUMBER(vend, prod, num) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_NUMBER, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceNumber = (num)\n\n \n#define USB_DEVICE_INFO(cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, \\\n\t.bDeviceClass = (cl), \\\n\t.bDeviceSubClass = (sc), \\\n\t.bDeviceProtocol = (pr)\n\n \n#define USB_INTERFACE_INFO(cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n \n#define USB_DEVICE_AND_INTERFACE_INFO(vend, prod, cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t| USB_DEVICE_ID_MATCH_DEVICE, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n \n#define USB_VENDOR_AND_INTERFACE_INFO(vend, cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t| USB_DEVICE_ID_MATCH_VENDOR, \\\n\t.idVendor = (vend), \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n \n\n \nstruct usb_dynids {\n\tspinlock_t lock;\n\tstruct list_head list;\n};\n\nstruct usb_dynid {\n\tstruct list_head node;\n\tstruct usb_device_id id;\n};\n\nextern ssize_t usb_store_new_id(struct usb_dynids *dynids,\n\t\t\t\tconst struct usb_device_id *id_table,\n\t\t\t\tstruct device_driver *driver,\n\t\t\t\tconst char *buf, size_t count);\n\nextern ssize_t usb_show_dynids(struct usb_dynids *dynids, char *buf);\n\n \nstruct usbdrv_wrap {\n\tstruct device_driver driver;\n\tint for_devices;\n};\n\n \nstruct usb_driver {\n\tconst char *name;\n\n\tint (*probe) (struct usb_interface *intf,\n\t\t      const struct usb_device_id *id);\n\n\tvoid (*disconnect) (struct usb_interface *intf);\n\n\tint (*unlocked_ioctl) (struct usb_interface *intf, unsigned int code,\n\t\t\tvoid *buf);\n\n\tint (*suspend) (struct usb_interface *intf, pm_message_t message);\n\tint (*resume) (struct usb_interface *intf);\n\tint (*reset_resume)(struct usb_interface *intf);\n\n\tint (*pre_reset)(struct usb_interface *intf);\n\tint (*post_reset)(struct usb_interface *intf);\n\n\tconst struct usb_device_id *id_table;\n\tconst struct attribute_group **dev_groups;\n\n\tstruct usb_dynids dynids;\n\tstruct usbdrv_wrap drvwrap;\n\tunsigned int no_dynamic_id:1;\n\tunsigned int supports_autosuspend:1;\n\tunsigned int disable_hub_initiated_lpm:1;\n\tunsigned int soft_unbind:1;\n};\n#define\tto_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)\n\n \nstruct usb_device_driver {\n\tconst char *name;\n\n\tbool (*match) (struct usb_device *udev);\n\tint (*probe) (struct usb_device *udev);\n\tvoid (*disconnect) (struct usb_device *udev);\n\n\tint (*suspend) (struct usb_device *udev, pm_message_t message);\n\tint (*resume) (struct usb_device *udev, pm_message_t message);\n\tconst struct attribute_group **dev_groups;\n\tstruct usbdrv_wrap drvwrap;\n\tconst struct usb_device_id *id_table;\n\tunsigned int supports_autosuspend:1;\n\tunsigned int generic_subclass:1;\n};\n#define\tto_usb_device_driver(d) container_of(d, struct usb_device_driver, \\\n\t\tdrvwrap.driver)\n\n \nstruct usb_class_driver {\n\tchar *name;\n\tchar *(*devnode)(const struct device *dev, umode_t *mode);\n\tconst struct file_operations *fops;\n\tint minor_base;\n};\n\n \nextern int usb_register_driver(struct usb_driver *, struct module *,\n\t\t\t       const char *);\n\n \n#define usb_register(driver) \\\n\tusb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)\n\nextern void usb_deregister(struct usb_driver *);\n\n \n#define module_usb_driver(__usb_driver) \\\n\tmodule_driver(__usb_driver, usb_register, \\\n\t\t       usb_deregister)\n\nextern int usb_register_device_driver(struct usb_device_driver *,\n\t\t\tstruct module *);\nextern void usb_deregister_device_driver(struct usb_device_driver *);\n\nextern int usb_register_dev(struct usb_interface *intf,\n\t\t\t    struct usb_class_driver *class_driver);\nextern void usb_deregister_dev(struct usb_interface *intf,\n\t\t\t       struct usb_class_driver *class_driver);\n\nextern int usb_disabled(void);\n\n \n\n \n\n \n#define URB_SHORT_NOT_OK\t0x0001\t \n#define URB_ISO_ASAP\t\t0x0002\t \n#define URB_NO_TRANSFER_DMA_MAP\t0x0004\t \n#define URB_ZERO_PACKET\t\t0x0040\t \n#define URB_NO_INTERRUPT\t0x0080\t \n#define URB_FREE_BUFFER\t\t0x0100\t \n\n \n#define URB_DIR_IN\t\t0x0200\t \n#define URB_DIR_OUT\t\t0\n#define URB_DIR_MASK\t\tURB_DIR_IN\n\n#define URB_DMA_MAP_SINGLE\t0x00010000\t \n#define URB_DMA_MAP_PAGE\t0x00020000\t \n#define URB_DMA_MAP_SG\t\t0x00040000\t \n#define URB_MAP_LOCAL\t\t0x00080000\t \n#define URB_SETUP_MAP_SINGLE\t0x00100000\t \n#define URB_SETUP_MAP_LOCAL\t0x00200000\t \n#define URB_DMA_SG_COMBINED\t0x00400000\t \n#define URB_ALIGNED_TEMP_BUFFER\t0x00800000\t \n\nstruct usb_iso_packet_descriptor {\n\tunsigned int offset;\n\tunsigned int length;\t\t \n\tunsigned int actual_length;\n\tint status;\n};\n\nstruct urb;\n\nstruct usb_anchor {\n\tstruct list_head urb_list;\n\twait_queue_head_t wait;\n\tspinlock_t lock;\n\tatomic_t suspend_wakeups;\n\tunsigned int poisoned:1;\n};\n\nstatic inline void init_usb_anchor(struct usb_anchor *anchor)\n{\n\tmemset(anchor, 0, sizeof(*anchor));\n\tINIT_LIST_HEAD(&anchor->urb_list);\n\tinit_waitqueue_head(&anchor->wait);\n\tspin_lock_init(&anchor->lock);\n}\n\ntypedef void (*usb_complete_t)(struct urb *);\n\n \nstruct urb {\n\t \n\tstruct kref kref;\t\t \n\tint unlinked;\t\t\t \n\tvoid *hcpriv;\t\t\t \n\tatomic_t use_count;\t\t \n\tatomic_t reject;\t\t \n\n\t \n\tstruct list_head urb_list;\t \n\tstruct list_head anchor_list;\t \n\tstruct usb_anchor *anchor;\n\tstruct usb_device *dev;\t\t \n\tstruct usb_host_endpoint *ep;\t \n\tunsigned int pipe;\t\t \n\tunsigned int stream_id;\t\t \n\tint status;\t\t\t \n\tunsigned int transfer_flags;\t \n\tvoid *transfer_buffer;\t\t \n\tdma_addr_t transfer_dma;\t \n\tstruct scatterlist *sg;\t\t \n\tint num_mapped_sgs;\t\t \n\tint num_sgs;\t\t\t \n\tu32 transfer_buffer_length;\t \n\tu32 actual_length;\t\t \n\tunsigned char *setup_packet;\t \n\tdma_addr_t setup_dma;\t\t \n\tint start_frame;\t\t \n\tint number_of_packets;\t\t \n\tint interval;\t\t\t \n\tint error_count;\t\t \n\tvoid *context;\t\t\t \n\tusb_complete_t complete;\t \n\tstruct usb_iso_packet_descriptor iso_frame_desc[];\n\t\t\t\t\t \n};\n\n \n\n \nstatic inline void usb_fill_control_urb(struct urb *urb,\n\t\t\t\t\tstruct usb_device *dev,\n\t\t\t\t\tunsigned int pipe,\n\t\t\t\t\tunsigned char *setup_packet,\n\t\t\t\t\tvoid *transfer_buffer,\n\t\t\t\t\tint buffer_length,\n\t\t\t\t\tusb_complete_t complete_fn,\n\t\t\t\t\tvoid *context)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->setup_packet = setup_packet;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n}\n\n \nstatic inline void usb_fill_bulk_urb(struct urb *urb,\n\t\t\t\t     struct usb_device *dev,\n\t\t\t\t     unsigned int pipe,\n\t\t\t\t     void *transfer_buffer,\n\t\t\t\t     int buffer_length,\n\t\t\t\t     usb_complete_t complete_fn,\n\t\t\t\t     void *context)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n}\n\n \nstatic inline void usb_fill_int_urb(struct urb *urb,\n\t\t\t\t    struct usb_device *dev,\n\t\t\t\t    unsigned int pipe,\n\t\t\t\t    void *transfer_buffer,\n\t\t\t\t    int buffer_length,\n\t\t\t\t    usb_complete_t complete_fn,\n\t\t\t\t    void *context,\n\t\t\t\t    int interval)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n\n\tif (dev->speed == USB_SPEED_HIGH || dev->speed >= USB_SPEED_SUPER) {\n\t\t \n\t\tinterval = clamp(interval, 1, 16);\n\n\t\turb->interval = 1 << (interval - 1);\n\t} else {\n\t\turb->interval = interval;\n\t}\n\n\turb->start_frame = -1;\n}\n\nextern void usb_init_urb(struct urb *urb);\nextern struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags);\nextern void usb_free_urb(struct urb *urb);\n#define usb_put_urb usb_free_urb\nextern struct urb *usb_get_urb(struct urb *urb);\nextern int usb_submit_urb(struct urb *urb, gfp_t mem_flags);\nextern int usb_unlink_urb(struct urb *urb);\nextern void usb_kill_urb(struct urb *urb);\nextern void usb_poison_urb(struct urb *urb);\nextern void usb_unpoison_urb(struct urb *urb);\nextern void usb_block_urb(struct urb *urb);\nextern void usb_kill_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_poison_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_unpoison_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_unlink_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_anchor_suspend_wakeups(struct usb_anchor *anchor);\nextern void usb_anchor_resume_wakeups(struct usb_anchor *anchor);\nextern void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor);\nextern void usb_unanchor_urb(struct urb *urb);\nextern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,\n\t\t\t\t\t unsigned int timeout);\nextern struct urb *usb_get_from_anchor(struct usb_anchor *anchor);\nextern void usb_scuttle_anchored_urbs(struct usb_anchor *anchor);\nextern int usb_anchor_empty(struct usb_anchor *anchor);\n\n#define usb_unblock_urb\tusb_unpoison_urb\n\n \nstatic inline int usb_urb_dir_in(struct urb *urb)\n{\n\treturn (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_IN;\n}\n\n \nstatic inline int usb_urb_dir_out(struct urb *urb)\n{\n\treturn (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_OUT;\n}\n\nint usb_pipe_type_check(struct usb_device *dev, unsigned int pipe);\nint usb_urb_ep_type_check(const struct urb *urb);\n\nvoid *usb_alloc_coherent(struct usb_device *dev, size_t size,\n\tgfp_t mem_flags, dma_addr_t *dma);\nvoid usb_free_coherent(struct usb_device *dev, size_t size,\n\tvoid *addr, dma_addr_t dma);\n\n#if 0\nstruct urb *usb_buffer_map(struct urb *urb);\nvoid usb_buffer_dmasync(struct urb *urb);\nvoid usb_buffer_unmap(struct urb *urb);\n#endif\n\nstruct scatterlist;\nint usb_buffer_map_sg(const struct usb_device *dev, int is_in,\n\t\t      struct scatterlist *sg, int nents);\n#if 0\nvoid usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,\n\t\t\t   struct scatterlist *sg, int n_hw_ents);\n#endif\nvoid usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,\n\t\t\t struct scatterlist *sg, int n_hw_ents);\n\n \n\nextern int usb_control_msg(struct usb_device *dev, unsigned int pipe,\n\t__u8 request, __u8 requesttype, __u16 value, __u16 index,\n\tvoid *data, __u16 size, int timeout);\nextern int usb_interrupt_msg(struct usb_device *usb_dev, unsigned int pipe,\n\tvoid *data, int len, int *actual_length, int timeout);\nextern int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,\n\tvoid *data, int len, int *actual_length,\n\tint timeout);\n\n \nint usb_control_msg_send(struct usb_device *dev, __u8 endpoint, __u8 request,\n\t\t\t __u8 requesttype, __u16 value, __u16 index,\n\t\t\t const void *data, __u16 size, int timeout,\n\t\t\t gfp_t memflags);\nint usb_control_msg_recv(struct usb_device *dev, __u8 endpoint, __u8 request,\n\t\t\t __u8 requesttype, __u16 value, __u16 index,\n\t\t\t void *data, __u16 size, int timeout,\n\t\t\t gfp_t memflags);\nextern int usb_get_descriptor(struct usb_device *dev, unsigned char desctype,\n\tunsigned char descindex, void *buf, int size);\nextern int usb_get_status(struct usb_device *dev,\n\tint recip, int type, int target, void *data);\n\nstatic inline int usb_get_std_status(struct usb_device *dev,\n\tint recip, int target, void *data)\n{\n\treturn usb_get_status(dev, recip, USB_STATUS_TYPE_STANDARD, target,\n\t\tdata);\n}\n\nstatic inline int usb_get_ptm_status(struct usb_device *dev, void *data)\n{\n\treturn usb_get_status(dev, USB_RECIP_DEVICE, USB_STATUS_TYPE_PTM,\n\t\t0, data);\n}\n\nextern int usb_string(struct usb_device *dev, int index,\n\tchar *buf, size_t size);\nextern char *usb_cache_string(struct usb_device *udev, int index);\n\n \nextern int usb_clear_halt(struct usb_device *dev, int pipe);\nextern int usb_reset_configuration(struct usb_device *dev);\nextern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);\nextern void usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr);\n\n \nextern int usb_driver_set_configuration(struct usb_device *udev, int config);\n\n \nextern int usb_choose_configuration(struct usb_device *udev);\nextern int usb_set_configuration(struct usb_device *dev, int configuration);\n\n \n#define USB_CTRL_GET_TIMEOUT\t5000\n#define USB_CTRL_SET_TIMEOUT\t5000\n\n\n \nstruct usb_sg_request {\n\tint\t\t\tstatus;\n\tsize_t\t\t\tbytes;\n\n\t \n\tspinlock_t\t\tlock;\n\n\tstruct usb_device\t*dev;\n\tint\t\t\tpipe;\n\n\tint\t\t\tentries;\n\tstruct urb\t\t**urbs;\n\n\tint\t\t\tcount;\n\tstruct completion\tcomplete;\n};\n\nint usb_sg_init(\n\tstruct usb_sg_request\t*io,\n\tstruct usb_device\t*dev,\n\tunsigned\t\tpipe,\n\tunsigned\t\tperiod,\n\tstruct scatterlist\t*sg,\n\tint\t\t\tnents,\n\tsize_t\t\t\tlength,\n\tgfp_t\t\t\tmem_flags\n);\nvoid usb_sg_cancel(struct usb_sg_request *io);\nvoid usb_sg_wait(struct usb_sg_request *io);\n\n\n \n\n \n\n \n \n#define PIPE_ISOCHRONOUS\t\t0\n#define PIPE_INTERRUPT\t\t\t1\n#define PIPE_CONTROL\t\t\t2\n#define PIPE_BULK\t\t\t3\n\n#define usb_pipein(pipe)\t((pipe) & USB_DIR_IN)\n#define usb_pipeout(pipe)\t(!usb_pipein(pipe))\n\n#define usb_pipedevice(pipe)\t(((pipe) >> 8) & 0x7f)\n#define usb_pipeendpoint(pipe)\t(((pipe) >> 15) & 0xf)\n\n#define usb_pipetype(pipe)\t(((pipe) >> 30) & 3)\n#define usb_pipeisoc(pipe)\t(usb_pipetype((pipe)) == PIPE_ISOCHRONOUS)\n#define usb_pipeint(pipe)\t(usb_pipetype((pipe)) == PIPE_INTERRUPT)\n#define usb_pipecontrol(pipe)\t(usb_pipetype((pipe)) == PIPE_CONTROL)\n#define usb_pipebulk(pipe)\t(usb_pipetype((pipe)) == PIPE_BULK)\n\nstatic inline unsigned int __create_pipe(struct usb_device *dev,\n\t\tunsigned int endpoint)\n{\n\treturn (dev->devnum << 8) | (endpoint << 15);\n}\n\n \n#define usb_sndctrlpipe(dev, endpoint)\t\\\n\t((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvctrlpipe(dev, endpoint)\t\\\n\t((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndisocpipe(dev, endpoint)\t\\\n\t((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvisocpipe(dev, endpoint)\t\\\n\t((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndbulkpipe(dev, endpoint)\t\\\n\t((PIPE_BULK << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvbulkpipe(dev, endpoint)\t\\\n\t((PIPE_BULK << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndintpipe(dev, endpoint)\t\\\n\t((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvintpipe(dev, endpoint)\t\\\n\t((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n\nstatic inline struct usb_host_endpoint *\nusb_pipe_endpoint(struct usb_device *dev, unsigned int pipe)\n{\n\tstruct usb_host_endpoint **eps;\n\teps = usb_pipein(pipe) ? dev->ep_in : dev->ep_out;\n\treturn eps[usb_pipeendpoint(pipe)];\n}\n\nstatic inline u16 usb_maxpacket(struct usb_device *udev, int pipe)\n{\n\tstruct usb_host_endpoint *ep = usb_pipe_endpoint(udev, pipe);\n\n\tif (!ep)\n\t\treturn 0;\n\n\t \n\treturn usb_endpoint_maxp(&ep->desc);\n}\n\n \nstatic inline int usb_translate_errors(int error_code)\n{\n\tswitch (error_code) {\n\tcase 0:\n\tcase -ENOMEM:\n\tcase -ENODEV:\n\tcase -EOPNOTSUPP:\n\t\treturn error_code;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\n \n#define USB_DEVICE_ADD\t\t0x0001\n#define USB_DEVICE_REMOVE\t0x0002\n#define USB_BUS_ADD\t\t0x0003\n#define USB_BUS_REMOVE\t\t0x0004\nextern void usb_register_notify(struct notifier_block *nb);\nextern void usb_unregister_notify(struct notifier_block *nb);\n\n \nextern struct dentry *usb_debug_root;\n\n \nenum usb_led_event {\n\tUSB_LED_EVENT_HOST = 0,\n\tUSB_LED_EVENT_GADGET = 1,\n};\n\n#ifdef CONFIG_USB_LED_TRIG\nextern void usb_led_activity(enum usb_led_event ev);\n#else\nstatic inline void usb_led_activity(enum usb_led_event ev) {}\n#endif\n\n#endif   \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}