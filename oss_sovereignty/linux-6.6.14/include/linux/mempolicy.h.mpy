{
  "module_name": "mempolicy.h",
  "hash_id": "839dbce084b0df391cb5d36583340c92790f65f49f45785b07ac2d677cfaf8a8",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mempolicy.h",
  "human_readable_source": " \n \n#ifndef _LINUX_MEMPOLICY_H\n#define _LINUX_MEMPOLICY_H 1\n\n#include <linux/sched.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/nodemask.h>\n#include <linux/pagemap.h>\n#include <uapi/linux/mempolicy.h>\n\nstruct mm_struct;\n\n#ifdef CONFIG_NUMA\n\n \nstruct mempolicy {\n\tatomic_t refcnt;\n\tunsigned short mode; \t \n\tunsigned short flags;\t \n\tnodemask_t nodes;\t \n\tint home_node;\t\t \n\n\tunion {\n\t\tnodemask_t cpuset_mems_allowed;\t \n\t\tnodemask_t user_nodemask;\t \n\t} w;\n};\n\n \n\nextern void __mpol_put(struct mempolicy *pol);\nstatic inline void mpol_put(struct mempolicy *pol)\n{\n\tif (pol)\n\t\t__mpol_put(pol);\n}\n\n \nstatic inline int mpol_needs_cond_ref(struct mempolicy *pol)\n{\n\treturn (pol && (pol->flags & MPOL_F_SHARED));\n}\n\nstatic inline void mpol_cond_put(struct mempolicy *pol)\n{\n\tif (mpol_needs_cond_ref(pol))\n\t\t__mpol_put(pol);\n}\n\nextern struct mempolicy *__mpol_dup(struct mempolicy *pol);\nstatic inline struct mempolicy *mpol_dup(struct mempolicy *pol)\n{\n\tif (pol)\n\t\tpol = __mpol_dup(pol);\n\treturn pol;\n}\n\n#define vma_policy(vma) ((vma)->vm_policy)\n\nstatic inline void mpol_get(struct mempolicy *pol)\n{\n\tif (pol)\n\t\tatomic_inc(&pol->refcnt);\n}\n\nextern bool __mpol_equal(struct mempolicy *a, struct mempolicy *b);\nstatic inline bool mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (a == b)\n\t\treturn true;\n\treturn __mpol_equal(a, b);\n}\n\n \n\nstruct sp_node {\n\tstruct rb_node nd;\n\tunsigned long start, end;\n\tstruct mempolicy *policy;\n};\n\nstruct shared_policy {\n\tstruct rb_root root;\n\trwlock_t lock;\n};\n\nint vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst);\nvoid mpol_shared_policy_init(struct shared_policy *sp, struct mempolicy *mpol);\nint mpol_set_shared_policy(struct shared_policy *info,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tstruct mempolicy *new);\nvoid mpol_free_shared_policy(struct shared_policy *p);\nstruct mempolicy *mpol_shared_policy_lookup(struct shared_policy *sp,\n\t\t\t\t\t    unsigned long idx);\n\nstruct mempolicy *get_task_policy(struct task_struct *p);\nstruct mempolicy *__get_vma_policy(struct vm_area_struct *vma,\n\t\tunsigned long addr);\nbool vma_policy_mof(struct vm_area_struct *vma);\n\nextern void numa_default_policy(void);\nextern void numa_policy_init(void);\nextern void mpol_rebind_task(struct task_struct *tsk, const nodemask_t *new);\nextern void mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new);\n\nextern int huge_node(struct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask);\nextern bool init_nodemask_of_mempolicy(nodemask_t *mask);\nextern bool mempolicy_in_oom_domain(struct task_struct *tsk,\n\t\t\t\tconst nodemask_t *mask);\nextern nodemask_t *policy_nodemask(gfp_t gfp, struct mempolicy *policy);\n\nextern unsigned int mempolicy_slab_node(void);\n\nextern enum zone_type policy_zone;\n\nstatic inline void check_highest_zone(enum zone_type k)\n{\n\tif (k > policy_zone && k != ZONE_MOVABLE)\n\t\tpolicy_zone = k;\n}\n\nint do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags);\n\n\n#ifdef CONFIG_TMPFS\nextern int mpol_parse_str(char *str, struct mempolicy **mpol);\n#endif\n\nextern void mpol_to_str(char *buffer, int maxlen, struct mempolicy *pol);\n\n \nextern bool vma_migratable(struct vm_area_struct *vma);\n\nextern int mpol_misplaced(struct page *, struct vm_area_struct *, unsigned long);\nextern void mpol_put_task_policy(struct task_struct *);\n\nstatic inline bool mpol_is_preferred_many(struct mempolicy *pol)\n{\n\treturn  (pol->mode == MPOL_PREFERRED_MANY);\n}\n\nextern bool apply_policy_zone(struct mempolicy *policy, enum zone_type zone);\n\n#else\n\nstruct mempolicy {};\n\nstatic inline bool mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\treturn true;\n}\n\nstatic inline void mpol_put(struct mempolicy *p)\n{\n}\n\nstatic inline void mpol_cond_put(struct mempolicy *pol)\n{\n}\n\nstatic inline void mpol_get(struct mempolicy *pol)\n{\n}\n\nstruct shared_policy {};\n\nstatic inline void mpol_shared_policy_init(struct shared_policy *sp,\n\t\t\t\t\t\tstruct mempolicy *mpol)\n{\n}\n\nstatic inline void mpol_free_shared_policy(struct shared_policy *p)\n{\n}\n\nstatic inline struct mempolicy *\nmpol_shared_policy_lookup(struct shared_policy *sp, unsigned long idx)\n{\n\treturn NULL;\n}\n\n#define vma_policy(vma) NULL\n\nstatic inline int\nvma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)\n{\n\treturn 0;\n}\n\nstatic inline void numa_policy_init(void)\n{\n}\n\nstatic inline void numa_default_policy(void)\n{\n}\n\nstatic inline void mpol_rebind_task(struct task_struct *tsk,\n\t\t\t\tconst nodemask_t *new)\n{\n}\n\nstatic inline void mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new)\n{\n}\n\nstatic inline int huge_node(struct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\t*mpol = NULL;\n\t*nodemask = NULL;\n\treturn 0;\n}\n\nstatic inline bool init_nodemask_of_mempolicy(nodemask_t *m)\n{\n\treturn false;\n}\n\nstatic inline int do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t\t\t   const nodemask_t *to, int flags)\n{\n\treturn 0;\n}\n\nstatic inline void check_highest_zone(int k)\n{\n}\n\n#ifdef CONFIG_TMPFS\nstatic inline int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\treturn 1;\t \n}\n#endif\n\nstatic inline int mpol_misplaced(struct page *page, struct vm_area_struct *vma,\n\t\t\t\t unsigned long address)\n{\n\treturn -1;  \n}\n\nstatic inline void mpol_put_task_policy(struct task_struct *task)\n{\n}\n\nstatic inline bool mpol_is_preferred_many(struct mempolicy *pol)\n{\n\treturn  false;\n}\n\n#endif  \n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}