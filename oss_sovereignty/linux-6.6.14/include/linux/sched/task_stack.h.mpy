{
  "module_name": "task_stack.h",
  "hash_id": "5628a8ad7446542b364f2f40c91d277f104e529ba983c7c32087b4d82305f51a",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/sched/task_stack.h",
  "human_readable_source": " \n#ifndef _LINUX_SCHED_TASK_STACK_H\n#define _LINUX_SCHED_TASK_STACK_H\n\n \n\n#include <linux/sched.h>\n#include <linux/magic.h>\n\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\n \nstatic __always_inline void *task_stack_page(const struct task_struct *task)\n{\n\treturn task->stack;\n}\n\n#define setup_thread_stack(new,old)\tdo { } while(0)\n\nstatic __always_inline unsigned long *end_of_stack(const struct task_struct *task)\n{\n#ifdef CONFIG_STACK_GROWSUP\n\treturn (unsigned long *)((unsigned long)task->stack + THREAD_SIZE) - 1;\n#else\n\treturn task->stack;\n#endif\n}\n\n#elif !defined(__HAVE_THREAD_FUNCTIONS)\n\n#define task_stack_page(task)\t((void *)(task)->stack)\n\nstatic inline void setup_thread_stack(struct task_struct *p, struct task_struct *org)\n{\n\t*task_thread_info(p) = *task_thread_info(org);\n\ttask_thread_info(p)->task = p;\n}\n\n \nstatic inline unsigned long *end_of_stack(struct task_struct *p)\n{\n#ifdef CONFIG_STACK_GROWSUP\n\treturn (unsigned long *)((unsigned long)task_thread_info(p) + THREAD_SIZE) - 1;\n#else\n\treturn (unsigned long *)(task_thread_info(p) + 1);\n#endif\n}\n\n#endif\n\n#ifdef CONFIG_THREAD_INFO_IN_TASK\nstatic inline void *try_get_task_stack(struct task_struct *tsk)\n{\n\treturn refcount_inc_not_zero(&tsk->stack_refcount) ?\n\t\ttask_stack_page(tsk) : NULL;\n}\n\nextern void put_task_stack(struct task_struct *tsk);\n#else\nstatic inline void *try_get_task_stack(struct task_struct *tsk)\n{\n\treturn task_stack_page(tsk);\n}\n\nstatic inline void put_task_stack(struct task_struct *tsk) {}\n#endif\n\nvoid exit_task_stack_account(struct task_struct *tsk);\n\n#define task_stack_end_corrupted(task) \\\n\t\t(*(end_of_stack(task)) != STACK_END_MAGIC)\n\nstatic inline int object_is_on_stack(const void *obj)\n{\n\tvoid *stack = task_stack_page(current);\n\n\treturn (obj >= stack) && (obj < (stack + THREAD_SIZE));\n}\n\nextern void thread_stack_cache_init(void);\n\n#ifdef CONFIG_DEBUG_STACK_USAGE\nstatic inline unsigned long stack_not_used(struct task_struct *p)\n{\n\tunsigned long *n = end_of_stack(p);\n\n\tdo { \t \n# ifdef CONFIG_STACK_GROWSUP\n\t\tn--;\n# else\n\t\tn++;\n# endif\n\t} while (!*n);\n\n# ifdef CONFIG_STACK_GROWSUP\n\treturn (unsigned long)end_of_stack(p) - (unsigned long)n;\n# else\n\treturn (unsigned long)n - (unsigned long)end_of_stack(p);\n# endif\n}\n#endif\nextern void set_task_stack_end_magic(struct task_struct *tsk);\n\n#ifndef __HAVE_ARCH_KSTACK_END\nstatic inline int kstack_end(void *addr)\n{\n\t \n\treturn !(((unsigned long)addr+sizeof(void*)-1) & (THREAD_SIZE-sizeof(void*)));\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}