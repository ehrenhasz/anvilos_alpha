{
  "module_name": "hdlcdrv.h",
  "hash_id": "df25c8bc2df6391c9a0442c8df50f141d406c88969cbfc194494d5a5b450fb64",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/hdlcdrv.h",
  "human_readable_source": " \n \n#ifndef _HDLCDRV_H\n#define _HDLCDRV_H\n\n\n#include <linux/netdevice.h>\n#include <linux/if.h>\n#include <linux/spinlock.h>\n#include <uapi/linux/hdlcdrv.h>\n\n#define HDLCDRV_MAGIC      0x5ac6e778\n#define HDLCDRV_HDLCBUFFER  32  \n#define HDLCDRV_BITBUFFER  256  \n#undef HDLCDRV_LOOPBACK   \n#define HDLCDRV_DEBUG\n\n \n#define HDLCDRV_MAXFLEN             400\t\n\n\nstruct hdlcdrv_hdlcbuffer {\n\tspinlock_t lock;\n\tunsigned rd, wr;\n\tunsigned short buf[HDLCDRV_HDLCBUFFER];\n};\n\n#ifdef HDLCDRV_DEBUG\nstruct hdlcdrv_bitbuffer {\n\tunsigned int rd;\n\tunsigned int wr;\n\tunsigned int shreg;\n\tunsigned char buffer[HDLCDRV_BITBUFFER];\n};\n\nstatic inline void hdlcdrv_add_bitbuffer(struct hdlcdrv_bitbuffer *buf, \n\t\t\t\t\t unsigned int bit)\n{\n\tunsigned char new;\n\n\tnew = buf->shreg & 1;\n\tbuf->shreg >>= 1;\n\tbuf->shreg |= (!!bit) << 7;\n\tif (new) {\n\t\tbuf->buffer[buf->wr] = buf->shreg;\n\t\tbuf->wr = (buf->wr+1) % sizeof(buf->buffer);\n\t\tbuf->shreg = 0x80;\n\t}\n}\n\nstatic inline void hdlcdrv_add_bitbuffer_word(struct hdlcdrv_bitbuffer *buf, \n\t\t\t\t\t      unsigned int bits)\n{\n\tbuf->buffer[buf->wr] = bits & 0xff;\n\tbuf->wr = (buf->wr+1) % sizeof(buf->buffer);\n\tbuf->buffer[buf->wr] = (bits >> 8) & 0xff;\n\tbuf->wr = (buf->wr+1) % sizeof(buf->buffer);\n\n}\n#endif  \n\n \n \n\nstruct hdlcdrv_ops {\n\t \n\tconst char *drvname;\n\tconst char *drvinfo;\n\t \n\tint (*open)(struct net_device *);\n\tint (*close)(struct net_device *);\n\tint (*ioctl)(struct net_device *, void __user *,\n\t\t     struct hdlcdrv_ioctl *, int);\n};\n\nstruct hdlcdrv_state {\n\tint magic;\n\tint opened;\n\n\tconst struct hdlcdrv_ops *ops;\n\n\tstruct {\n\t\tint bitrate;\n\t} par;\n\n\tstruct hdlcdrv_pttoutput {\n\t\tint dma2;\n\t\tint seriobase;\n\t\tint pariobase;\n\t\tint midiiobase;\n\t\tunsigned int flags;\n\t} ptt_out;\n\n\tstruct hdlcdrv_channel_params ch_params;\n\n\tstruct hdlcdrv_hdlcrx {\n\t\tstruct hdlcdrv_hdlcbuffer hbuf;\n\t\tunsigned long in_hdlc_rx;\n\t\t \n\t\tint rx_state;\t\n\t\tunsigned int bitstream;\n\t\tunsigned int bitbuf;\n\t\tint numbits;\n\t\tunsigned char dcd;\n\t\t\n\t\tint len;\n\t\tunsigned char *bp;\n\t\tunsigned char buffer[HDLCDRV_MAXFLEN+2];\n\t} hdlcrx;\n\n\tstruct hdlcdrv_hdlctx {\n\t\tstruct hdlcdrv_hdlcbuffer hbuf;\n\t\tunsigned long in_hdlc_tx;\n\t\t \n\t\tint tx_state;\t\n\t\tint numflags;\n\t\tunsigned int bitstream;\n\t\tunsigned char ptt;\n\t\tint calibrate;\n\t\tint slotcnt;\n\n\t\tunsigned int bitbuf;\n\t\tint numbits;\n\t\t\n\t\tint len;\n\t\tunsigned char *bp;\n\t\tunsigned char buffer[HDLCDRV_MAXFLEN+2];\n\t} hdlctx;\n\n#ifdef HDLCDRV_DEBUG\n\tstruct hdlcdrv_bitbuffer bitbuf_channel;\n\tstruct hdlcdrv_bitbuffer bitbuf_hdlc;\n#endif  \n\n\tint ptt_keyed;\n\n\t \n\tstruct sk_buff *skb;\n};\n\n\n \n\nstatic inline int hdlcdrv_hbuf_full(struct hdlcdrv_hdlcbuffer *hb) \n{\n\tunsigned long flags;\n\tint ret;\n\t\n\tspin_lock_irqsave(&hb->lock, flags);\n\tret = !((HDLCDRV_HDLCBUFFER - 1 + hb->rd - hb->wr) % HDLCDRV_HDLCBUFFER);\n\tspin_unlock_irqrestore(&hb->lock, flags);\n\treturn ret;\n}\n\n \n\nstatic inline int hdlcdrv_hbuf_empty(struct hdlcdrv_hdlcbuffer *hb)\n{\n\tunsigned long flags;\n\tint ret;\n\t\n\tspin_lock_irqsave(&hb->lock, flags);\n\tret = (hb->rd == hb->wr);\n\tspin_unlock_irqrestore(&hb->lock, flags);\n\treturn ret;\n}\n\n \n\nstatic inline unsigned short hdlcdrv_hbuf_get(struct hdlcdrv_hdlcbuffer *hb)\n{\n\tunsigned long flags;\n\tunsigned short val;\n\tunsigned newr;\n\n\tspin_lock_irqsave(&hb->lock, flags);\n\tif (hb->rd == hb->wr)\n\t\tval = 0;\n\telse {\n\t\tnewr = (hb->rd+1) % HDLCDRV_HDLCBUFFER;\n\t\tval = hb->buf[hb->rd];\n\t\thb->rd = newr;\n\t}\n\tspin_unlock_irqrestore(&hb->lock, flags);\n\treturn val;\n}\n\n \n\nstatic inline void hdlcdrv_hbuf_put(struct hdlcdrv_hdlcbuffer *hb, \n\t\t\t\t    unsigned short val)\n{\n\tunsigned newp;\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&hb->lock, flags);\n\tnewp = (hb->wr+1) % HDLCDRV_HDLCBUFFER;\n\tif (newp != hb->rd) { \n\t\thb->buf[hb->wr] = val & 0xffff;\n\t\thb->wr = newp;\n\t}\n\tspin_unlock_irqrestore(&hb->lock, flags);\n}\n\n \n\nstatic inline void hdlcdrv_putbits(struct hdlcdrv_state *s, unsigned int bits)\n{\n\thdlcdrv_hbuf_put(&s->hdlcrx.hbuf, bits);\n}\n\nstatic inline unsigned int hdlcdrv_getbits(struct hdlcdrv_state *s)\n{\n\tunsigned int ret;\n\n\tif (hdlcdrv_hbuf_empty(&s->hdlctx.hbuf)) {\n\t\tif (s->hdlctx.calibrate > 0)\n\t\t\ts->hdlctx.calibrate--;\n\t\telse\n\t\t\ts->hdlctx.ptt = 0;\n\t\tret = 0;\n\t} else \n\t\tret = hdlcdrv_hbuf_get(&s->hdlctx.hbuf);\n#ifdef HDLCDRV_LOOPBACK\n\thdlcdrv_hbuf_put(&s->hdlcrx.hbuf, ret);\n#endif  \n\treturn ret;\n}\n\nstatic inline void hdlcdrv_channelbit(struct hdlcdrv_state *s, unsigned int bit)\n{\n#ifdef HDLCDRV_DEBUG\n\thdlcdrv_add_bitbuffer(&s->bitbuf_channel, bit);\n#endif  \n}\n\nstatic inline void hdlcdrv_setdcd(struct hdlcdrv_state *s, int dcd)\n{\n\ts->hdlcrx.dcd = !!dcd;\n}\n\nstatic inline int hdlcdrv_ptt(struct hdlcdrv_state *s)\n{\n\treturn s->hdlctx.ptt || (s->hdlctx.calibrate > 0);\n}\n\n \n\nvoid hdlcdrv_receiver(struct net_device *, struct hdlcdrv_state *);\nvoid hdlcdrv_transmitter(struct net_device *, struct hdlcdrv_state *);\nvoid hdlcdrv_arbitrate(struct net_device *, struct hdlcdrv_state *);\nstruct net_device *hdlcdrv_register(const struct hdlcdrv_ops *ops,\n\t\t\t\t    unsigned int privsize, const char *ifname,\n\t\t\t\t    unsigned int baseaddr, unsigned int irq, \n\t\t\t\t    unsigned int dma);\nvoid hdlcdrv_unregister(struct net_device *dev);\n\n \n\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}