{
  "module_name": "posix-timers.h",
  "hash_id": "233735faa9ea754e8bcacaa33083f31fbaead664f2f87e6f833ac1d9841dcf76",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/posix-timers.h",
  "human_readable_source": " \n#ifndef _linux_POSIX_TIMERS_H\n#define _linux_POSIX_TIMERS_H\n\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/timerqueue.h>\n\nstruct kernel_siginfo;\nstruct task_struct;\n\n \n#define CPUCLOCK_PID(clock)\t\t((pid_t) ~((clock) >> 3))\n#define CPUCLOCK_PERTHREAD(clock) \\\n\t(((clock) & (clockid_t) CPUCLOCK_PERTHREAD_MASK) != 0)\n\n#define CPUCLOCK_PERTHREAD_MASK\t4\n#define CPUCLOCK_WHICH(clock)\t((clock) & (clockid_t) CPUCLOCK_CLOCK_MASK)\n#define CPUCLOCK_CLOCK_MASK\t3\n#define CPUCLOCK_PROF\t\t0\n#define CPUCLOCK_VIRT\t\t1\n#define CPUCLOCK_SCHED\t\t2\n#define CPUCLOCK_MAX\t\t3\n#define CLOCKFD\t\t\tCPUCLOCK_MAX\n#define CLOCKFD_MASK\t\t(CPUCLOCK_PERTHREAD_MASK|CPUCLOCK_CLOCK_MASK)\n\nstatic inline clockid_t make_process_cpuclock(const unsigned int pid,\n\t\tconst clockid_t clock)\n{\n\treturn ((~pid) << 3) | clock;\n}\nstatic inline clockid_t make_thread_cpuclock(const unsigned int tid,\n\t\tconst clockid_t clock)\n{\n\treturn make_process_cpuclock(tid, clock | CPUCLOCK_PERTHREAD_MASK);\n}\n\nstatic inline clockid_t fd_to_clockid(const int fd)\n{\n\treturn make_process_cpuclock((unsigned int) fd, CLOCKFD);\n}\n\nstatic inline int clockid_to_fd(const clockid_t clk)\n{\n\treturn ~(clk >> 3);\n}\n\n#ifdef CONFIG_POSIX_TIMERS\n\n \nstruct cpu_timer {\n\tstruct timerqueue_node\t\tnode;\n\tstruct timerqueue_head\t\t*head;\n\tstruct pid\t\t\t*pid;\n\tstruct list_head\t\telist;\n\tint\t\t\t\tfiring;\n\tstruct task_struct __rcu\t*handling;\n};\n\nstatic inline bool cpu_timer_enqueue(struct timerqueue_head *head,\n\t\t\t\t     struct cpu_timer *ctmr)\n{\n\tctmr->head = head;\n\treturn timerqueue_add(head, &ctmr->node);\n}\n\nstatic inline bool cpu_timer_queued(struct cpu_timer *ctmr)\n{\n\treturn !!ctmr->head;\n}\n\nstatic inline bool cpu_timer_dequeue(struct cpu_timer *ctmr)\n{\n\tif (cpu_timer_queued(ctmr)) {\n\t\ttimerqueue_del(ctmr->head, &ctmr->node);\n\t\tctmr->head = NULL;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline u64 cpu_timer_getexpires(struct cpu_timer *ctmr)\n{\n\treturn ctmr->node.expires;\n}\n\nstatic inline void cpu_timer_setexpires(struct cpu_timer *ctmr, u64 exp)\n{\n\tctmr->node.expires = exp;\n}\n\n \nstruct posix_cputimer_base {\n\tu64\t\t\tnextevt;\n\tstruct timerqueue_head\ttqhead;\n};\n\n \nstruct posix_cputimers {\n\tstruct posix_cputimer_base\tbases[CPUCLOCK_MAX];\n\tunsigned int\t\t\ttimers_active;\n\tunsigned int\t\t\texpiry_active;\n};\n\n \nstruct posix_cputimers_work {\n\tstruct callback_head\twork;\n\tstruct mutex\t\tmutex;\n\tunsigned int\t\tscheduled;\n};\n\nstatic inline void posix_cputimers_init(struct posix_cputimers *pct)\n{\n\tmemset(pct, 0, sizeof(*pct));\n\tpct->bases[0].nextevt = U64_MAX;\n\tpct->bases[1].nextevt = U64_MAX;\n\tpct->bases[2].nextevt = U64_MAX;\n}\n\nvoid posix_cputimers_group_init(struct posix_cputimers *pct, u64 cpu_limit);\n\nstatic inline void posix_cputimers_rt_watchdog(struct posix_cputimers *pct,\n\t\t\t\t\t       u64 runtime)\n{\n\tpct->bases[CPUCLOCK_SCHED].nextevt = runtime;\n}\n\n \n#define INIT_CPU_TIMERBASE(b) {\t\t\t\t\t\t\\\n\t.nextevt\t= U64_MAX,\t\t\t\t\t\\\n}\n\n#define INIT_CPU_TIMERBASES(b) {\t\t\t\t\t\\\n\tINIT_CPU_TIMERBASE(b[0]),\t\t\t\t\t\\\n\tINIT_CPU_TIMERBASE(b[1]),\t\t\t\t\t\\\n\tINIT_CPU_TIMERBASE(b[2]),\t\t\t\t\t\\\n}\n\n#define INIT_CPU_TIMERS(s)\t\t\t\t\t\t\\\n\t.posix_cputimers = {\t\t\t\t\t\t\\\n\t\t.bases = INIT_CPU_TIMERBASES(s.posix_cputimers.bases),\t\\\n\t},\n#else\nstruct posix_cputimers { };\nstruct cpu_timer { };\n#define INIT_CPU_TIMERS(s)\nstatic inline void posix_cputimers_init(struct posix_cputimers *pct) { }\nstatic inline void posix_cputimers_group_init(struct posix_cputimers *pct,\n\t\t\t\t\t      u64 cpu_limit) { }\n#endif\n\n#ifdef CONFIG_POSIX_CPU_TIMERS_TASK_WORK\nvoid clear_posix_cputimers_work(struct task_struct *p);\nvoid posix_cputimers_init_work(void);\n#else\nstatic inline void clear_posix_cputimers_work(struct task_struct *p) { }\nstatic inline void posix_cputimers_init_work(void) { }\n#endif\n\n#define REQUEUE_PENDING 1\n\n \nstruct k_itimer {\n\tstruct list_head\tlist;\n\tstruct hlist_node\tt_hash;\n\tspinlock_t\t\tit_lock;\n\tconst struct k_clock\t*kclock;\n\tclockid_t\t\tit_clock;\n\ttimer_t\t\t\tit_id;\n\tint\t\t\tit_active;\n\ts64\t\t\tit_overrun;\n\ts64\t\t\tit_overrun_last;\n\tint\t\t\tit_requeue_pending;\n\tint\t\t\tit_sigev_notify;\n\tktime_t\t\t\tit_interval;\n\tstruct signal_struct\t*it_signal;\n\tunion {\n\t\tstruct pid\t\t*it_pid;\n\t\tstruct task_struct\t*it_process;\n\t};\n\tstruct sigqueue\t\t*sigq;\n\tunion {\n\t\tstruct {\n\t\t\tstruct hrtimer\ttimer;\n\t\t} real;\n\t\tstruct cpu_timer\tcpu;\n\t\tstruct {\n\t\t\tstruct alarm\talarmtimer;\n\t\t} alarm;\n\t} it;\n\tstruct rcu_head\t\trcu;\n};\n\nvoid run_posix_cpu_timers(void);\nvoid posix_cpu_timers_exit(struct task_struct *task);\nvoid posix_cpu_timers_exit_group(struct task_struct *task);\nvoid set_process_cpu_timer(struct task_struct *task, unsigned int clock_idx,\n\t\t\t   u64 *newval, u64 *oldval);\n\nint update_rlimit_cpu(struct task_struct *task, unsigned long rlim_new);\n\nvoid posixtimer_rearm(struct kernel_siginfo *info);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}