{
  "module_name": "dynamic_debug.h",
  "hash_id": "f2b06866b27fc15d1b688d72240e68683a940db91aae801d17c89d850ed3f1de",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/dynamic_debug.h",
  "human_readable_source": " \n#ifndef _DYNAMIC_DEBUG_H\n#define _DYNAMIC_DEBUG_H\n\n#if defined(CONFIG_JUMP_LABEL)\n#include <linux/jump_label.h>\n#endif\n\n#include <linux/build_bug.h>\n\n \nstruct _ddebug {\n\t \n\tconst char *modname;\n\tconst char *function;\n\tconst char *filename;\n\tconst char *format;\n\tunsigned int lineno:18;\n#define CLS_BITS 6\n\tunsigned int class_id:CLS_BITS;\n#define _DPRINTK_CLASS_DFLT\t\t((1 << CLS_BITS) - 1)\n\t \n#define _DPRINTK_FLAGS_NONE\t0\n#define _DPRINTK_FLAGS_PRINT\t(1<<0)  \n#define _DPRINTK_FLAGS_INCL_MODNAME\t(1<<1)\n#define _DPRINTK_FLAGS_INCL_FUNCNAME\t(1<<2)\n#define _DPRINTK_FLAGS_INCL_LINENO\t(1<<3)\n#define _DPRINTK_FLAGS_INCL_TID\t\t(1<<4)\n#define _DPRINTK_FLAGS_INCL_SOURCENAME\t(1<<5)\n\n#define _DPRINTK_FLAGS_INCL_ANY\t\t\\\n\t(_DPRINTK_FLAGS_INCL_MODNAME | _DPRINTK_FLAGS_INCL_FUNCNAME |\\\n\t _DPRINTK_FLAGS_INCL_LINENO  | _DPRINTK_FLAGS_INCL_TID |\\\n\t _DPRINTK_FLAGS_INCL_SOURCENAME)\n\n#if defined DEBUG\n#define _DPRINTK_FLAGS_DEFAULT _DPRINTK_FLAGS_PRINT\n#else\n#define _DPRINTK_FLAGS_DEFAULT 0\n#endif\n\tunsigned int flags:8;\n#ifdef CONFIG_JUMP_LABEL\n\tunion {\n\t\tstruct static_key_true dd_key_true;\n\t\tstruct static_key_false dd_key_false;\n\t} key;\n#endif\n} __attribute__((aligned(8)));\n\nenum class_map_type {\n\tDD_CLASS_TYPE_DISJOINT_BITS,\n\t \n\tDD_CLASS_TYPE_LEVEL_NUM,\n\t \n\tDD_CLASS_TYPE_DISJOINT_NAMES,\n\t \n\tDD_CLASS_TYPE_LEVEL_NAMES,\n\t \n};\n\nstruct ddebug_class_map {\n\tstruct list_head link;\n\tstruct module *mod;\n\tconst char *mod_name;\t \n\tconst char **class_names;\n\tconst int length;\n\tconst int base;\t\t \n\tenum class_map_type map_type;\n};\n\n \n#define DECLARE_DYNDBG_CLASSMAP(_var, _maptype, _base, ...)\t\t\\\n\tstatic const char *_var##_classnames[] = { __VA_ARGS__ };\t\\\n\tstatic struct ddebug_class_map __aligned(8) __used\t\t\\\n\t\t__section(\"__dyndbg_classes\") _var = {\t\t\t\\\n\t\t.mod = THIS_MODULE,\t\t\t\t\t\\\n\t\t.mod_name = KBUILD_MODNAME,\t\t\t\t\\\n\t\t.base = _base,\t\t\t\t\t\t\\\n\t\t.map_type = _maptype,\t\t\t\t\t\\\n\t\t.length = NUM_TYPE_ARGS(char*, __VA_ARGS__),\t\t\\\n\t\t.class_names = _var##_classnames,\t\t\t\\\n\t}\n#define NUM_TYPE_ARGS(eltype, ...)\t\t\t\t\\\n        (sizeof((eltype[]){__VA_ARGS__}) / sizeof(eltype))\n\n \nstruct _ddebug_info {\n\tstruct _ddebug *descs;\n\tstruct ddebug_class_map *classes;\n\tunsigned int num_descs;\n\tunsigned int num_classes;\n};\n\nstruct ddebug_class_param {\n\tunion {\n\t\tunsigned long *bits;\n\t\tunsigned int *lvl;\n\t};\n\tchar flags[8];\n\tconst struct ddebug_class_map *map;\n};\n\n \n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n\nextern __printf(2, 3)\nvoid __dynamic_pr_debug(struct _ddebug *descriptor, const char *fmt, ...);\n\nstruct device;\n\nextern __printf(3, 4)\nvoid __dynamic_dev_dbg(struct _ddebug *descriptor, const struct device *dev,\n\t\t       const char *fmt, ...);\n\nstruct net_device;\n\nextern __printf(3, 4)\nvoid __dynamic_netdev_dbg(struct _ddebug *descriptor,\n\t\t\t  const struct net_device *dev,\n\t\t\t  const char *fmt, ...);\n\nstruct ib_device;\n\nextern __printf(3, 4)\nvoid __dynamic_ibdev_dbg(struct _ddebug *descriptor,\n\t\t\t const struct ib_device *ibdev,\n\t\t\t const char *fmt, ...);\n\n#define DEFINE_DYNAMIC_DEBUG_METADATA_CLS(name, cls, fmt)\t\\\n\tstatic struct _ddebug  __aligned(8)\t\t\t\\\n\t__section(\"__dyndbg\") name = {\t\t\t\t\\\n\t\t.modname = KBUILD_MODNAME,\t\t\t\\\n\t\t.function = __func__,\t\t\t\t\\\n\t\t.filename = __FILE__,\t\t\t\t\\\n\t\t.format = (fmt),\t\t\t\t\\\n\t\t.lineno = __LINE__,\t\t\t\t\\\n\t\t.flags = _DPRINTK_FLAGS_DEFAULT,\t\t\\\n\t\t.class_id = cls,\t\t\t\t\\\n\t\t_DPRINTK_KEY_INIT\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(cls > _DPRINTK_CLASS_DFLT,\t\t\\\n\t\t\t \"classid value overflow\")\n\n#define DEFINE_DYNAMIC_DEBUG_METADATA(name, fmt)\t\t\\\n\tDEFINE_DYNAMIC_DEBUG_METADATA_CLS(name, _DPRINTK_CLASS_DFLT, fmt)\n\n#ifdef CONFIG_JUMP_LABEL\n\n#ifdef DEBUG\n\n#define _DPRINTK_KEY_INIT .key.dd_key_true = (STATIC_KEY_TRUE_INIT)\n\n#define DYNAMIC_DEBUG_BRANCH(descriptor) \\\n\tstatic_branch_likely(&descriptor.key.dd_key_true)\n#else\n#define _DPRINTK_KEY_INIT .key.dd_key_false = (STATIC_KEY_FALSE_INIT)\n\n#define DYNAMIC_DEBUG_BRANCH(descriptor) \\\n\tstatic_branch_unlikely(&descriptor.key.dd_key_false)\n#endif\n\n#else  \n\n#define _DPRINTK_KEY_INIT\n\n#ifdef DEBUG\n#define DYNAMIC_DEBUG_BRANCH(descriptor) \\\n\tlikely(descriptor.flags & _DPRINTK_FLAGS_PRINT)\n#else\n#define DYNAMIC_DEBUG_BRANCH(descriptor) \\\n\tunlikely(descriptor.flags & _DPRINTK_FLAGS_PRINT)\n#endif\n\n#endif  \n\n \n#define __dynamic_func_call_cls(id, cls, fmt, func, ...) do {\t\\\n\tDEFINE_DYNAMIC_DEBUG_METADATA_CLS(id, cls, fmt);\t\\\n\tif (DYNAMIC_DEBUG_BRANCH(id))\t\t\t\t\\\n\t\tfunc(&id, ##__VA_ARGS__);\t\t\t\\\n} while (0)\n#define __dynamic_func_call(id, fmt, func, ...)\t\t\t\t\\\n\t__dynamic_func_call_cls(id, _DPRINTK_CLASS_DFLT, fmt,\t\t\\\n\t\t\t\tfunc, ##__VA_ARGS__)\n\n#define __dynamic_func_call_cls_no_desc(id, cls, fmt, func, ...) do {\t\\\n\tDEFINE_DYNAMIC_DEBUG_METADATA_CLS(id, cls, fmt);\t\t\\\n\tif (DYNAMIC_DEBUG_BRANCH(id))\t\t\t\t\t\\\n\t\tfunc(__VA_ARGS__);\t\t\t\t\t\\\n} while (0)\n#define __dynamic_func_call_no_desc(id, fmt, func, ...)\t\t\t\\\n\t__dynamic_func_call_cls_no_desc(id, _DPRINTK_CLASS_DFLT,\t\\\n\t\t\t\t\tfmt, func, ##__VA_ARGS__)\n\n \n#define _dynamic_func_call_cls(cls, fmt, func, ...)\t\t\t\\\n\t__dynamic_func_call_cls(__UNIQUE_ID(ddebug), cls, fmt, func, ##__VA_ARGS__)\n#define _dynamic_func_call(fmt, func, ...)\t\t\t\t\\\n\t_dynamic_func_call_cls(_DPRINTK_CLASS_DFLT, fmt, func, ##__VA_ARGS__)\n\n \n#define _dynamic_func_call_cls_no_desc(cls, fmt, func, ...)\t\t\\\n\t__dynamic_func_call_cls_no_desc(__UNIQUE_ID(ddebug), cls, fmt,\t\\\n\t\t\t\t\tfunc, ##__VA_ARGS__)\n#define _dynamic_func_call_no_desc(fmt, func, ...)\t\t\t\\\n\t_dynamic_func_call_cls_no_desc(_DPRINTK_CLASS_DFLT, fmt,\t\\\n\t\t\t\t       func, ##__VA_ARGS__)\n\n#define dynamic_pr_debug_cls(cls, fmt, ...)\t\t\t\t\\\n\t_dynamic_func_call_cls(cls, fmt, __dynamic_pr_debug,\t\t\\\n\t\t\t   pr_fmt(fmt), ##__VA_ARGS__)\n\n#define dynamic_pr_debug(fmt, ...)\t\t\t\t\\\n\t_dynamic_func_call(fmt, __dynamic_pr_debug,\t\t\\\n\t\t\t   pr_fmt(fmt), ##__VA_ARGS__)\n\n#define dynamic_dev_dbg(dev, fmt, ...)\t\t\t\t\\\n\t_dynamic_func_call(fmt, __dynamic_dev_dbg, \t\t\\\n\t\t\t   dev, fmt, ##__VA_ARGS__)\n\n#define dynamic_netdev_dbg(dev, fmt, ...)\t\t\t\\\n\t_dynamic_func_call(fmt, __dynamic_netdev_dbg,\t\t\\\n\t\t\t   dev, fmt, ##__VA_ARGS__)\n\n#define dynamic_ibdev_dbg(dev, fmt, ...)\t\t\t\\\n\t_dynamic_func_call(fmt, __dynamic_ibdev_dbg,\t\t\\\n\t\t\t   dev, fmt, ##__VA_ARGS__)\n\n#define dynamic_hex_dump(prefix_str, prefix_type, rowsize,\t\t\\\n\t\t\t groupsize, buf, len, ascii)\t\t\t\\\n\t_dynamic_func_call_no_desc(__builtin_constant_p(prefix_str) ? prefix_str : \"hexdump\", \\\n\t\t\t\t   print_hex_dump,\t\t\t\\\n\t\t\t\t   KERN_DEBUG, prefix_str, prefix_type,\t\\\n\t\t\t\t   rowsize, groupsize, buf, len, ascii)\n\n \n#define __pr_debug_cls(cls, fmt, ...) do {\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__builtin_constant_p(cls),\t\t\\\n\t\t\t \"expecting constant class int/enum\");\t\\\n\tdynamic_pr_debug_cls(cls, fmt, ##__VA_ARGS__);\t\t\\\n\t} while (0)\n\n#else  \n\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/printk.h>\n\n#define DEFINE_DYNAMIC_DEBUG_METADATA(name, fmt)\n#define DYNAMIC_DEBUG_BRANCH(descriptor) false\n\n#define dynamic_pr_debug(fmt, ...)\t\t\t\t\t\\\n\tdo { if (0) printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__); } while (0)\n#define dynamic_dev_dbg(dev, fmt, ...)\t\t\t\t\t\\\n\tdo { if (0) dev_printk(KERN_DEBUG, dev, fmt, ##__VA_ARGS__); } while (0)\n#define dynamic_hex_dump(prefix_str, prefix_type, rowsize,\t\t\\\n\t\t\t groupsize, buf, len, ascii)\t\t\t\\\n\tdo { if (0)\t\t\t\t\t\t\t\\\n\t\tprint_hex_dump(KERN_DEBUG, prefix_str, prefix_type,\t\\\n\t\t\t\trowsize, groupsize, buf, len, ascii);\t\\\n\t} while (0)\n\n#endif  \n\n\n#ifdef CONFIG_DYNAMIC_DEBUG_CORE\n\nextern int ddebug_dyndbg_module_param_cb(char *param, char *val,\n\t\t\t\t\tconst char *modname);\nstruct kernel_param;\nint param_set_dyndbg_classes(const char *instr, const struct kernel_param *kp);\nint param_get_dyndbg_classes(char *buffer, const struct kernel_param *kp);\n\n#else\n\nstatic inline int ddebug_dyndbg_module_param_cb(char *param, char *val,\n\t\t\t\t\t\tconst char *modname)\n{\n\tif (!strcmp(param, \"dyndbg\")) {\n\t\t \n\t\tprintk(KERN_WARNING \"dyndbg param is supported only in \"\n\t\t\t\"CONFIG_DYNAMIC_DEBUG builds\\n\");\n\t\treturn 0;  \n\t}\n\treturn -EINVAL;\n}\n\nstruct kernel_param;\nstatic inline int param_set_dyndbg_classes(const char *instr, const struct kernel_param *kp)\n{ return 0; }\nstatic inline int param_get_dyndbg_classes(char *buffer, const struct kernel_param *kp)\n{ return 0; }\n\n#endif\n\n\nextern const struct kernel_param_ops param_ops_dyndbg_classes;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}