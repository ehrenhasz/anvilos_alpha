{
  "module_name": "namei.h",
  "hash_id": "31f2fad54ac4c0065be19ef6f95902de90f7eb5409e6d6c12da2a8bea76dd628",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/namei.h",
  "human_readable_source": " \n#ifndef _LINUX_NAMEI_H\n#define _LINUX_NAMEI_H\n\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/path.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n\nenum { MAX_NESTED_LINKS = 8 };\n\n#define MAXSYMLINKS 40\n\n \nenum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT};\n\n \n#define LOOKUP_FOLLOW\t\t0x0001\t \n#define LOOKUP_DIRECTORY\t0x0002\t \n#define LOOKUP_AUTOMOUNT\t0x0004   \n#define LOOKUP_EMPTY\t\t0x4000\t \n#define LOOKUP_DOWN\t\t0x8000\t \n#define LOOKUP_MOUNTPOINT\t0x0080\t \n\n#define LOOKUP_REVAL\t\t0x0020\t \n#define LOOKUP_RCU\t\t0x0040\t \n\n \n#define LOOKUP_OPEN\t\t0x0100\t \n#define LOOKUP_CREATE\t\t0x0200\t \n#define LOOKUP_EXCL\t\t0x0400\t \n#define LOOKUP_RENAME_TARGET\t0x0800\t \n\n \n#define LOOKUP_PARENT\t\t0x0010\n\n \n#define LOOKUP_NO_SYMLINKS\t0x010000  \n#define LOOKUP_NO_MAGICLINKS\t0x020000  \n#define LOOKUP_NO_XDEV\t\t0x040000  \n#define LOOKUP_BENEATH\t\t0x080000  \n#define LOOKUP_IN_ROOT\t\t0x100000  \n#define LOOKUP_CACHED\t\t0x200000  \n \n#define LOOKUP_IS_SCOPED (LOOKUP_BENEATH | LOOKUP_IN_ROOT)\n\nextern int path_pts(struct path *path);\n\nextern int user_path_at_empty(int, const char __user *, unsigned, struct path *, int *empty);\n\nstatic inline int user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}\n\nstruct dentry *lookup_one_qstr_excl(const struct qstr *name,\n\t\t\t\t    struct dentry *base,\n\t\t\t\t    unsigned int flags);\nextern int kern_path(const char *, unsigned, struct path *);\n\nextern struct dentry *kern_path_create(int, const char *, struct path *, unsigned int);\nextern struct dentry *user_path_create(int, const char __user *, struct path *, unsigned int);\nextern void done_path_create(struct path *, struct dentry *);\nextern struct dentry *kern_path_locked(const char *, struct path *);\nint vfs_path_parent_lookup(struct filename *filename, unsigned int flags,\n\t\t\t   struct path *parent, struct qstr *last, int *type,\n\t\t\t   const struct path *root);\nint vfs_path_lookup(struct dentry *, struct vfsmount *, const char *,\n\t\t    unsigned int, struct path *);\n\nextern struct dentry *try_lookup_one_len(const char *, struct dentry *, int);\nextern struct dentry *lookup_one_len(const char *, struct dentry *, int);\nextern struct dentry *lookup_one_len_unlocked(const char *, struct dentry *, int);\nextern struct dentry *lookup_positive_unlocked(const char *, struct dentry *, int);\nstruct dentry *lookup_one(struct mnt_idmap *, const char *, struct dentry *, int);\nstruct dentry *lookup_one_unlocked(struct mnt_idmap *idmap,\n\t\t\t\t   const char *name, struct dentry *base,\n\t\t\t\t   int len);\nstruct dentry *lookup_one_positive_unlocked(struct mnt_idmap *idmap,\n\t\t\t\t\t    const char *name,\n\t\t\t\t\t    struct dentry *base, int len);\n\nextern int follow_down_one(struct path *);\nextern int follow_down(struct path *path, unsigned int flags);\nextern int follow_up(struct path *);\n\nextern struct dentry *lock_rename(struct dentry *, struct dentry *);\nextern struct dentry *lock_rename_child(struct dentry *, struct dentry *);\nextern void unlock_rename(struct dentry *, struct dentry *);\n\nextern int __must_check nd_jump_link(const struct path *path);\n\nstatic inline void nd_terminate_link(void *name, size_t len, size_t maxlen)\n{\n\t((char *) name)[min(len, maxlen)] = '\\0';\n}\n\n \nstatic inline bool\nretry_estale(const long error, const unsigned int flags)\n{\n\treturn error == -ESTALE && !(flags & LOOKUP_REVAL);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}