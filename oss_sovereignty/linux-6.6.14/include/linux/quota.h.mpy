{
  "module_name": "quota.h",
  "hash_id": "bc8ad4ba419611ede27dd0cac7f2027f5a0450f549d11658c7be0cbb774540f0",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/quota.h",
  "human_readable_source": " \n#ifndef _LINUX_QUOTA_\n#define _LINUX_QUOTA_\n\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n#include <linux/percpu_counter.h>\n\n#include <linux/dqblk_xfs.h>\n#include <linux/dqblk_v1.h>\n#include <linux/dqblk_v2.h>\n\n#include <linux/atomic.h>\n#include <linux/uidgid.h>\n#include <linux/projid.h>\n#include <uapi/linux/quota.h>\n\n#undef USRQUOTA\n#undef GRPQUOTA\n#undef PRJQUOTA\nenum quota_type {\n\tUSRQUOTA = 0,\t\t \n\tGRPQUOTA = 1,\t\t \n\tPRJQUOTA = 2,\t\t \n};\n\n \n#define QTYPE_MASK_USR (1 << USRQUOTA)\n#define QTYPE_MASK_GRP (1 << GRPQUOTA)\n#define QTYPE_MASK_PRJ (1 << PRJQUOTA)\n\ntypedef __kernel_uid32_t qid_t;  \ntypedef long long qsize_t;\t \n\nstruct kqid {\t\t\t \n\tunion {\n\t\tkuid_t uid;\n\t\tkgid_t gid;\n\t\tkprojid_t projid;\n\t};\n\tenum quota_type type;   \n};\n\nextern bool qid_eq(struct kqid left, struct kqid right);\nextern bool qid_lt(struct kqid left, struct kqid right);\nextern qid_t from_kqid(struct user_namespace *to, struct kqid qid);\nextern qid_t from_kqid_munged(struct user_namespace *to, struct kqid qid);\nextern bool qid_valid(struct kqid qid);\n\n \nstatic inline struct kqid make_kqid(struct user_namespace *from,\n\t\t\t\t    enum quota_type type, qid_t qid)\n{\n\tstruct kqid kqid;\n\n\tkqid.type = type;\n\tswitch (type) {\n\tcase USRQUOTA:\n\t\tkqid.uid = make_kuid(from, qid);\n\t\tbreak;\n\tcase GRPQUOTA:\n\t\tkqid.gid = make_kgid(from, qid);\n\t\tbreak;\n\tcase PRJQUOTA:\n\t\tkqid.projid = make_kprojid(from, qid);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn kqid;\n}\n\n \nstatic inline struct kqid make_kqid_invalid(enum quota_type type)\n{\n\tstruct kqid kqid;\n\n\tkqid.type = type;\n\tswitch (type) {\n\tcase USRQUOTA:\n\t\tkqid.uid = INVALID_UID;\n\t\tbreak;\n\tcase GRPQUOTA:\n\t\tkqid.gid = INVALID_GID;\n\t\tbreak;\n\tcase PRJQUOTA:\n\t\tkqid.projid = INVALID_PROJID;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn kqid;\n}\n\n \nstatic inline struct kqid make_kqid_uid(kuid_t uid)\n{\n\tstruct kqid kqid;\n\tkqid.type = USRQUOTA;\n\tkqid.uid = uid;\n\treturn kqid;\n}\n\n \nstatic inline struct kqid make_kqid_gid(kgid_t gid)\n{\n\tstruct kqid kqid;\n\tkqid.type = GRPQUOTA;\n\tkqid.gid = gid;\n\treturn kqid;\n}\n\n \nstatic inline struct kqid make_kqid_projid(kprojid_t projid)\n{\n\tstruct kqid kqid;\n\tkqid.type = PRJQUOTA;\n\tkqid.projid = projid;\n\treturn kqid;\n}\n\n \nstatic inline bool qid_has_mapping(struct user_namespace *ns, struct kqid qid)\n{\n\treturn from_kqid(ns, qid) != (qid_t) -1;\n}\n\n\nextern spinlock_t dq_data_lock;\n\n \n#define DQUOT_INIT_ALLOC max(V1_INIT_ALLOC, V2_INIT_ALLOC)\n#define DQUOT_INIT_REWRITE max(V1_INIT_REWRITE, V2_INIT_REWRITE)\n#define DQUOT_DEL_ALLOC max(V1_DEL_ALLOC, V2_DEL_ALLOC)\n#define DQUOT_DEL_REWRITE max(V1_DEL_REWRITE, V2_DEL_REWRITE)\n\n \nstruct mem_dqblk {\n\tqsize_t dqb_bhardlimit;\t \n\tqsize_t dqb_bsoftlimit;\t \n\tqsize_t dqb_curspace;\t \n\tqsize_t dqb_rsvspace;    \n\tqsize_t dqb_ihardlimit;\t \n\tqsize_t dqb_isoftlimit;\t \n\tqsize_t dqb_curinodes;\t \n\ttime64_t dqb_btime;\t \n\ttime64_t dqb_itime;\t \n};\n\n \nstruct quota_format_type;\n\nstruct mem_dqinfo {\n\tstruct quota_format_type *dqi_format;\n\tint dqi_fmt_id;\t\t \n\tstruct list_head dqi_dirty_list;\t \n\tunsigned long dqi_flags;\t \n\tunsigned int dqi_bgrace;\t \n\tunsigned int dqi_igrace;\t \n\tqsize_t dqi_max_spc_limit;\t \n\tqsize_t dqi_max_ino_limit;\t \n\tvoid *dqi_priv;\n};\n\nstruct super_block;\n\n \n#define DQF_GETINFO_MASK (DQF_ROOT_SQUASH | DQF_SYS_FILE)\n \n#define DQF_SETINFO_MASK DQF_ROOT_SQUASH\n\nenum {\n\tDQF_INFO_DIRTY_B = DQF_PRIVATE,\n};\n#define DQF_INFO_DIRTY (1 << DQF_INFO_DIRTY_B)\t \n\nextern void mark_info_dirty(struct super_block *sb, int type);\nstatic inline int info_dirty(struct mem_dqinfo *info)\n{\n\treturn test_bit(DQF_INFO_DIRTY_B, &info->dqi_flags);\n}\n\nenum {\n\tDQST_LOOKUPS,\n\tDQST_DROPS,\n\tDQST_READS,\n\tDQST_WRITES,\n\tDQST_CACHE_HITS,\n\tDQST_ALLOC_DQUOTS,\n\tDQST_FREE_DQUOTS,\n\tDQST_SYNCS,\n\t_DQST_DQSTAT_LAST\n};\n\nstruct dqstats {\n\tunsigned long stat[_DQST_DQSTAT_LAST];\n\tstruct percpu_counter counter[_DQST_DQSTAT_LAST];\n};\n\nextern struct dqstats dqstats;\n\nstatic inline void dqstats_inc(unsigned int type)\n{\n\tpercpu_counter_inc(&dqstats.counter[type]);\n}\n\nstatic inline void dqstats_dec(unsigned int type)\n{\n\tpercpu_counter_dec(&dqstats.counter[type]);\n}\n\n#define DQ_MOD_B\t0\t \n#define DQ_BLKS_B\t1\t \n#define DQ_INODES_B\t2\t \n#define DQ_FAKE_B\t3\t \n#define DQ_READ_B\t4\t \n#define DQ_ACTIVE_B\t5\t \n#define DQ_RELEASING_B\t6\t \n#define DQ_LASTSET_B\t7\t \n\nstruct dquot {\n\tstruct hlist_node dq_hash;\t \n\tstruct list_head dq_inuse;\t \n\tstruct list_head dq_free;\t \n\tstruct list_head dq_dirty;\t \n\tstruct mutex dq_lock;\t\t \n\tspinlock_t dq_dqb_lock;\t\t \n\tatomic_t dq_count;\t\t \n\tstruct super_block *dq_sb;\t \n\tstruct kqid dq_id;\t\t \n\tloff_t dq_off;\t\t\t \n\tunsigned long dq_flags;\t\t \n\tstruct mem_dqblk dq_dqb;\t \n};\n\n \nstruct quota_format_ops {\n\tint (*check_quota_file)(struct super_block *sb, int type);\t \n\tint (*read_file_info)(struct super_block *sb, int type);\t \n\tint (*write_file_info)(struct super_block *sb, int type);\t \n\tint (*free_file_info)(struct super_block *sb, int type);\t \n\tint (*read_dqblk)(struct dquot *dquot);\t\t \n\tint (*commit_dqblk)(struct dquot *dquot);\t \n\tint (*release_dqblk)(struct dquot *dquot);\t \n\tint (*get_next_id)(struct super_block *sb, struct kqid *qid);\t \n};\n\n \nstruct dquot_operations {\n\tint (*write_dquot) (struct dquot *);\t\t \n\tstruct dquot *(*alloc_dquot)(struct super_block *, int);\t \n\tvoid (*destroy_dquot)(struct dquot *);\t\t \n\tint (*acquire_dquot) (struct dquot *);\t\t \n\tint (*release_dquot) (struct dquot *);\t\t \n\tint (*mark_dirty) (struct dquot *);\t\t \n\tint (*write_info) (struct super_block *, int);\t \n\t \n\tqsize_t *(*get_reserved_space) (struct inode *);\n\tint (*get_projid) (struct inode *, kprojid_t *); \n\t \n\tint (*get_inode_usage) (struct inode *, qsize_t *);\n\t \n\tint (*get_next_id) (struct super_block *sb, struct kqid *qid);\n};\n\nstruct path;\n\n \nstruct qc_dqblk {\n\tint d_fieldmask;\t \n\tu64 d_spc_hardlimit;\t \n\tu64 d_spc_softlimit;\t \n\tu64 d_ino_hardlimit;\t \n\tu64 d_ino_softlimit;\t \n\tu64 d_space;\t\t \n\tu64 d_ino_count;\t \n\ts64 d_ino_timer;\t \n\t\t\t\t \n\ts64 d_spc_timer;\t \n\tint d_ino_warns;\t \n\tint d_spc_warns;\t \n\tu64 d_rt_spc_hardlimit;\t \n\tu64 d_rt_spc_softlimit;\t \n\tu64 d_rt_space;\t\t \n\ts64 d_rt_spc_timer;\t \n\tint d_rt_spc_warns;\t \n};\n\n \n#define\tQC_INO_SOFT\t(1<<0)\n#define\tQC_INO_HARD\t(1<<1)\n#define\tQC_SPC_SOFT\t(1<<2)\n#define\tQC_SPC_HARD\t(1<<3)\n#define\tQC_RT_SPC_SOFT\t(1<<4)\n#define\tQC_RT_SPC_HARD\t(1<<5)\n#define QC_LIMIT_MASK (QC_INO_SOFT | QC_INO_HARD | QC_SPC_SOFT | QC_SPC_HARD | \\\n\t\t       QC_RT_SPC_SOFT | QC_RT_SPC_HARD)\n#define\tQC_SPC_TIMER\t(1<<6)\n#define\tQC_INO_TIMER\t(1<<7)\n#define\tQC_RT_SPC_TIMER\t(1<<8)\n#define QC_TIMER_MASK (QC_SPC_TIMER | QC_INO_TIMER | QC_RT_SPC_TIMER)\n#define\tQC_SPC_WARNS\t(1<<9)\n#define\tQC_INO_WARNS\t(1<<10)\n#define\tQC_RT_SPC_WARNS\t(1<<11)\n#define QC_WARNS_MASK (QC_SPC_WARNS | QC_INO_WARNS | QC_RT_SPC_WARNS)\n#define\tQC_SPACE\t(1<<12)\n#define\tQC_INO_COUNT\t(1<<13)\n#define\tQC_RT_SPACE\t(1<<14)\n#define QC_ACCT_MASK (QC_SPACE | QC_INO_COUNT | QC_RT_SPACE)\n#define QC_FLAGS\t(1<<15)\n\n#define QCI_SYSFILE\t\t(1 << 0)\t \n#define QCI_ROOT_SQUASH\t\t(1 << 1)\t \n#define QCI_ACCT_ENABLED\t(1 << 2)\t \n#define QCI_LIMITS_ENFORCED\t(1 << 3)\t \n\n \nstruct qc_type_state {\n\tunsigned int flags;\t\t \n\tunsigned int spc_timelimit;\t \n\tunsigned int ino_timelimit;\t \n\tunsigned int rt_spc_timelimit;\t \n\tunsigned int spc_warnlimit;\t \n\tunsigned int ino_warnlimit;\t \n\tunsigned int rt_spc_warnlimit;\t \n\tunsigned long long ino;\t\t \n\tblkcnt_t blocks;\t\t \n\tblkcnt_t nextents;\t\t \n};\n\nstruct qc_state {\n\tunsigned int s_incoredqs;\t \n\tstruct qc_type_state s_state[MAXQUOTAS];   \n};\n\n \nstruct qc_info {\n\tint i_fieldmask;\t \n\tunsigned int i_flags;\t\t \n\tunsigned int i_spc_timelimit;\t \n\tunsigned int i_ino_timelimit;\t \n\tunsigned int i_rt_spc_timelimit; \n\tunsigned int i_spc_warnlimit;\t \n\tunsigned int i_ino_warnlimit;\t \n\tunsigned int i_rt_spc_warnlimit;\t \n};\n\n \nstruct quotactl_ops {\n\tint (*quota_on)(struct super_block *, int, int, const struct path *);\n\tint (*quota_off)(struct super_block *, int);\n\tint (*quota_enable)(struct super_block *, unsigned int);\n\tint (*quota_disable)(struct super_block *, unsigned int);\n\tint (*quota_sync)(struct super_block *, int);\n\tint (*set_info)(struct super_block *, int, struct qc_info *);\n\tint (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);\n\tint (*get_nextdqblk)(struct super_block *, struct kqid *,\n\t\t\t     struct qc_dqblk *);\n\tint (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);\n\tint (*get_state)(struct super_block *, struct qc_state *);\n\tint (*rm_xquota)(struct super_block *, unsigned int);\n};\n\nstruct quota_format_type {\n\tint qf_fmt_id;\t \n\tconst struct quota_format_ops *qf_ops;\t \n\tstruct module *qf_owner;\t\t \n\tstruct quota_format_type *qf_next;\n};\n\n \nenum {\n\t_DQUOT_USAGE_ENABLED = 0,\t\t \n\t_DQUOT_LIMITS_ENABLED,\t\t\t \n\t_DQUOT_SUSPENDED,\t\t\t \n\t_DQUOT_STATE_FLAGS\n};\n#define DQUOT_USAGE_ENABLED\t(1 << _DQUOT_USAGE_ENABLED * MAXQUOTAS)\n#define DQUOT_LIMITS_ENABLED\t(1 << _DQUOT_LIMITS_ENABLED * MAXQUOTAS)\n#define DQUOT_SUSPENDED\t\t(1 << _DQUOT_SUSPENDED * MAXQUOTAS)\n#define DQUOT_STATE_FLAGS\t(DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED | \\\n\t\t\t\t DQUOT_SUSPENDED)\n \n#define DQUOT_STATE_LAST\t(_DQUOT_STATE_FLAGS * MAXQUOTAS)\n#define DQUOT_QUOTA_SYS_FILE\t(1 << DQUOT_STATE_LAST)\n\t\t\t\t\t\t \n#define DQUOT_NEGATIVE_USAGE\t(1 << (DQUOT_STATE_LAST + 1))\n\t\t\t\t\t        \n \n#define DQUOT_NOLIST_DIRTY\t(1 << (DQUOT_STATE_LAST + 2))\n\nstatic inline unsigned int dquot_state_flag(unsigned int flags, int type)\n{\n\treturn flags << type;\n}\n\nstatic inline unsigned int dquot_generic_flag(unsigned int flags, int type)\n{\n\treturn (flags >> type) & DQUOT_STATE_FLAGS;\n}\n\n \nstatic __always_inline unsigned dquot_state_types(unsigned flags, unsigned flag)\n{\n\tBUILD_BUG_ON_NOT_POWER_OF_2(flag);\n\treturn (flags / flag) & ((1 << MAXQUOTAS) - 1);\n}\n\n#ifdef CONFIG_QUOTA_NETLINK_INTERFACE\nextern void quota_send_warning(struct kqid qid, dev_t dev,\n\t\t\t       const char warntype);\n#else\nstatic inline void quota_send_warning(struct kqid qid, dev_t dev,\n\t\t\t\t      const char warntype)\n{\n\treturn;\n}\n#endif  \n\nstruct quota_info {\n\tunsigned int flags;\t\t\t \n\tstruct rw_semaphore dqio_sem;\t\t \n\tstruct inode *files[MAXQUOTAS];\t\t \n\tstruct mem_dqinfo info[MAXQUOTAS];\t \n\tconst struct quota_format_ops *ops[MAXQUOTAS];\t \n};\n\nint register_quota_format(struct quota_format_type *fmt);\nvoid unregister_quota_format(struct quota_format_type *fmt);\n\nstruct quota_module_name {\n\tint qm_fmt_id;\n\tchar *qm_mod_name;\n};\n\n#define INIT_QUOTA_MODULE_NAMES {\\\n\t{QFMT_VFS_OLD, \"quota_v1\"},\\\n\t{QFMT_VFS_V0, \"quota_v2\"},\\\n\t{QFMT_VFS_V1, \"quota_v2\"},\\\n\t{0, NULL}}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}