{
  "module_name": "rbtree_latch.h",
  "hash_id": "c7012d2615de543da5091e143015d1b46af89bccc90e80f54700b9afb7bea6cd",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/rbtree_latch.h",
  "human_readable_source": " \n \n\n#ifndef RB_TREE_LATCH_H\n#define RB_TREE_LATCH_H\n\n#include <linux/rbtree.h>\n#include <linux/seqlock.h>\n#include <linux/rcupdate.h>\n\nstruct latch_tree_node {\n\tstruct rb_node node[2];\n};\n\nstruct latch_tree_root {\n\tseqcount_latch_t\tseq;\n\tstruct rb_root\t\ttree[2];\n};\n\n \nstruct latch_tree_ops {\n\tbool (*less)(struct latch_tree_node *a, struct latch_tree_node *b);\n\tint  (*comp)(void *key,                 struct latch_tree_node *b);\n};\n\nstatic __always_inline struct latch_tree_node *\n__lt_from_rb(struct rb_node *node, int idx)\n{\n\treturn container_of(node, struct latch_tree_node, node[idx]);\n}\n\nstatic __always_inline void\n__lt_insert(struct latch_tree_node *ltn, struct latch_tree_root *ltr, int idx,\n\t    bool (*less)(struct latch_tree_node *a, struct latch_tree_node *b))\n{\n\tstruct rb_root *root = &ltr->tree[idx];\n\tstruct rb_node **link = &root->rb_node;\n\tstruct rb_node *node = &ltn->node[idx];\n\tstruct rb_node *parent = NULL;\n\tstruct latch_tree_node *ltp;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tltp = __lt_from_rb(parent, idx);\n\n\t\tif (less(ltn, ltp))\n\t\t\tlink = &parent->rb_left;\n\t\telse\n\t\t\tlink = &parent->rb_right;\n\t}\n\n\trb_link_node_rcu(node, parent, link);\n\trb_insert_color(node, root);\n}\n\nstatic __always_inline void\n__lt_erase(struct latch_tree_node *ltn, struct latch_tree_root *ltr, int idx)\n{\n\trb_erase(&ltn->node[idx], &ltr->tree[idx]);\n}\n\nstatic __always_inline struct latch_tree_node *\n__lt_find(void *key, struct latch_tree_root *ltr, int idx,\n\t  int (*comp)(void *key, struct latch_tree_node *node))\n{\n\tstruct rb_node *node = rcu_dereference_raw(ltr->tree[idx].rb_node);\n\tstruct latch_tree_node *ltn;\n\tint c;\n\n\twhile (node) {\n\t\tltn = __lt_from_rb(node, idx);\n\t\tc = comp(key, ltn);\n\n\t\tif (c < 0)\n\t\t\tnode = rcu_dereference_raw(node->rb_left);\n\t\telse if (c > 0)\n\t\t\tnode = rcu_dereference_raw(node->rb_right);\n\t\telse\n\t\t\treturn ltn;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic __always_inline void\nlatch_tree_insert(struct latch_tree_node *node,\n\t\t  struct latch_tree_root *root,\n\t\t  const struct latch_tree_ops *ops)\n{\n\traw_write_seqcount_latch(&root->seq);\n\t__lt_insert(node, root, 0, ops->less);\n\traw_write_seqcount_latch(&root->seq);\n\t__lt_insert(node, root, 1, ops->less);\n}\n\n \nstatic __always_inline void\nlatch_tree_erase(struct latch_tree_node *node,\n\t\t struct latch_tree_root *root,\n\t\t const struct latch_tree_ops *ops)\n{\n\traw_write_seqcount_latch(&root->seq);\n\t__lt_erase(node, root, 0);\n\traw_write_seqcount_latch(&root->seq);\n\t__lt_erase(node, root, 1);\n}\n\n \nstatic __always_inline struct latch_tree_node *\nlatch_tree_find(void *key, struct latch_tree_root *root,\n\t\tconst struct latch_tree_ops *ops)\n{\n\tstruct latch_tree_node *node;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&root->seq);\n\t\tnode = __lt_find(key, root, seq & 1, ops->comp);\n\t} while (raw_read_seqcount_latch_retry(&root->seq, seq));\n\n\treturn node;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}