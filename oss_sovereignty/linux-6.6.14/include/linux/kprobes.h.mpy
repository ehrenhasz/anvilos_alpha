{
  "module_name": "kprobes.h",
  "hash_id": "6d4016c08ab4bc342a38c53be3afa475619e12bfb11d196bc950b5d200d69920",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/kprobes.h",
  "human_readable_source": " \n#ifndef _LINUX_KPROBES_H\n#define _LINUX_KPROBES_H\n \n#include <linux/compiler.h>\n#include <linux/linkage.h>\n#include <linux/list.h>\n#include <linux/notifier.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/ftrace.h>\n#include <linux/refcount.h>\n#include <linux/freelist.h>\n#include <linux/rethook.h>\n#include <asm/kprobes.h>\n\n#ifdef CONFIG_KPROBES\n\n \n#define KPROBE_HIT_ACTIVE\t0x00000001\n#define KPROBE_HIT_SS\t\t0x00000002\n#define KPROBE_REENTER\t\t0x00000004\n#define KPROBE_HIT_SSDONE\t0x00000008\n\n#else  \n#include <asm-generic/kprobes.h>\ntypedef int kprobe_opcode_t;\nstruct arch_specific_insn {\n\tint dummy;\n};\n#endif  \n\nstruct kprobe;\nstruct pt_regs;\nstruct kretprobe;\nstruct kretprobe_instance;\ntypedef int (*kprobe_pre_handler_t) (struct kprobe *, struct pt_regs *);\ntypedef void (*kprobe_post_handler_t) (struct kprobe *, struct pt_regs *,\n\t\t\t\t       unsigned long flags);\ntypedef int (*kretprobe_handler_t) (struct kretprobe_instance *,\n\t\t\t\t    struct pt_regs *);\n\nstruct kprobe {\n\tstruct hlist_node hlist;\n\n\t \n\tstruct list_head list;\n\n\t \n\tunsigned long nmissed;\n\n\t \n\tkprobe_opcode_t *addr;\n\n\t \n\tconst char *symbol_name;\n\n\t \n\tunsigned int offset;\n\n\t \n\tkprobe_pre_handler_t pre_handler;\n\n\t \n\tkprobe_post_handler_t post_handler;\n\n\t \n\tkprobe_opcode_t opcode;\n\n\t \n\tstruct arch_specific_insn ainsn;\n\n\t \n\tu32 flags;\n};\n\n \n#define KPROBE_FLAG_GONE\t1  \n#define KPROBE_FLAG_DISABLED\t2  \n#define KPROBE_FLAG_OPTIMIZED\t4  \n#define KPROBE_FLAG_FTRACE\t8  \n#define KPROBE_FLAG_ON_FUNC_ENTRY\t16  \n\n \nstatic inline bool kprobe_gone(struct kprobe *p)\n{\n\treturn p->flags & KPROBE_FLAG_GONE;\n}\n\n \nstatic inline bool kprobe_disabled(struct kprobe *p)\n{\n\treturn p->flags & (KPROBE_FLAG_DISABLED | KPROBE_FLAG_GONE);\n}\n\n \nstatic inline bool kprobe_optimized(struct kprobe *p)\n{\n\treturn p->flags & KPROBE_FLAG_OPTIMIZED;\n}\n\n \nstatic inline bool kprobe_ftrace(struct kprobe *p)\n{\n\treturn p->flags & KPROBE_FLAG_FTRACE;\n}\n\n \nstruct kretprobe_holder {\n\tstruct kretprobe __rcu *rp;\n\trefcount_t\t\tref;\n};\n\nstruct kretprobe {\n\tstruct kprobe kp;\n\tkretprobe_handler_t handler;\n\tkretprobe_handler_t entry_handler;\n\tint maxactive;\n\tint nmissed;\n\tsize_t data_size;\n#ifdef CONFIG_KRETPROBE_ON_RETHOOK\n\tstruct rethook *rh;\n#else\n\tstruct freelist_head freelist;\n\tstruct kretprobe_holder *rph;\n#endif\n};\n\n#define KRETPROBE_MAX_DATA_SIZE\t4096\n\nstruct kretprobe_instance {\n#ifdef CONFIG_KRETPROBE_ON_RETHOOK\n\tstruct rethook_node node;\n#else\n\tunion {\n\t\tstruct freelist_node freelist;\n\t\tstruct rcu_head rcu;\n\t};\n\tstruct llist_node llist;\n\tstruct kretprobe_holder *rph;\n\tkprobe_opcode_t *ret_addr;\n\tvoid *fp;\n#endif\n\tchar data[];\n};\n\nstruct kretprobe_blackpoint {\n\tconst char *name;\n\tvoid *addr;\n};\n\nstruct kprobe_blacklist_entry {\n\tstruct list_head list;\n\tunsigned long start_addr;\n\tunsigned long end_addr;\n};\n\n#ifdef CONFIG_KPROBES\nDECLARE_PER_CPU(struct kprobe *, current_kprobe);\nDECLARE_PER_CPU(struct kprobe_ctlblk, kprobe_ctlblk);\n\nextern void kprobe_busy_begin(void);\nextern void kprobe_busy_end(void);\n\n#ifdef CONFIG_KRETPROBES\n \nextern int arch_trampoline_kprobe(struct kprobe *p);\n\n#ifdef CONFIG_KRETPROBE_ON_RETHOOK\nstatic nokprobe_inline struct kretprobe *get_kretprobe(struct kretprobe_instance *ri)\n{\n\t \n\treturn (struct kretprobe *)ri->node.rethook->data;\n}\nstatic nokprobe_inline unsigned long get_kretprobe_retaddr(struct kretprobe_instance *ri)\n{\n\treturn ri->node.ret_addr;\n}\n#else\nextern void arch_prepare_kretprobe(struct kretprobe_instance *ri,\n\t\t\t\t   struct pt_regs *regs);\nvoid arch_kretprobe_fixup_return(struct pt_regs *regs,\n\t\t\t\t kprobe_opcode_t *correct_ret_addr);\n\nvoid __kretprobe_trampoline(void);\n \nstatic nokprobe_inline void *kretprobe_trampoline_addr(void)\n{\n\treturn dereference_kernel_function_descriptor(__kretprobe_trampoline);\n}\n\n \nunsigned long __kretprobe_trampoline_handler(struct pt_regs *regs,\n\t\t\t\t\t     void *frame_pointer);\n\nstatic nokprobe_inline\nunsigned long kretprobe_trampoline_handler(struct pt_regs *regs,\n\t\t\t\t\t   void *frame_pointer)\n{\n\tunsigned long ret;\n\t \n\tkprobe_busy_begin();\n\tret = __kretprobe_trampoline_handler(regs, frame_pointer);\n\tkprobe_busy_end();\n\n\treturn ret;\n}\n\nstatic nokprobe_inline struct kretprobe *get_kretprobe(struct kretprobe_instance *ri)\n{\n\treturn rcu_dereference_check(ri->rph->rp, rcu_read_lock_any_held());\n}\n\nstatic nokprobe_inline unsigned long get_kretprobe_retaddr(struct kretprobe_instance *ri)\n{\n\treturn (unsigned long)ri->ret_addr;\n}\n#endif  \n\n#else  \nstatic inline void arch_prepare_kretprobe(struct kretprobe *rp,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n}\nstatic inline int arch_trampoline_kprobe(struct kprobe *p)\n{\n\treturn 0;\n}\n#endif  \n\n \nextern unsigned long __start_kprobe_blacklist[];\nextern unsigned long __stop_kprobe_blacklist[];\n\nextern struct kretprobe_blackpoint kretprobe_blacklist[];\n\n#ifdef CONFIG_KPROBES_SANITY_TEST\nextern int init_test_probes(void);\n#else  \nstatic inline int init_test_probes(void)\n{\n\treturn 0;\n}\n#endif  \n\nextern int arch_prepare_kprobe(struct kprobe *p);\nextern void arch_arm_kprobe(struct kprobe *p);\nextern void arch_disarm_kprobe(struct kprobe *p);\nextern int arch_init_kprobes(void);\nextern void kprobes_inc_nmissed_count(struct kprobe *p);\nextern bool arch_within_kprobe_blacklist(unsigned long addr);\nextern int arch_populate_kprobe_blacklist(void);\nextern int kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset);\n\nextern bool within_kprobe_blacklist(unsigned long addr);\nextern int kprobe_add_ksym_blacklist(unsigned long entry);\nextern int kprobe_add_area_blacklist(unsigned long start, unsigned long end);\n\nstruct kprobe_insn_cache {\n\tstruct mutex mutex;\n\tvoid *(*alloc)(void);\t \n\tvoid (*free)(void *);\t \n\tconst char *sym;\t \n\tstruct list_head pages;  \n\tsize_t insn_size;\t \n\tint nr_garbage;\n};\n\n#ifdef __ARCH_WANT_KPROBES_INSN_SLOT\nextern kprobe_opcode_t *__get_insn_slot(struct kprobe_insn_cache *c);\nextern void __free_insn_slot(struct kprobe_insn_cache *c,\n\t\t\t     kprobe_opcode_t *slot, int dirty);\n \nextern bool __is_insn_slot_addr(struct kprobe_insn_cache *c,\n\t\t\t\tunsigned long addr);\n\n#define DEFINE_INSN_CACHE_OPS(__name)\t\t\t\t\t\\\nextern struct kprobe_insn_cache kprobe_##__name##_slots;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline kprobe_opcode_t *get_##__name##_slot(void)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn __get_insn_slot(&kprobe_##__name##_slots);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline void free_##__name##_slot(kprobe_opcode_t *slot, int dirty)\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__free_insn_slot(&kprobe_##__name##_slots, slot, dirty);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic inline bool is_kprobe_##__name##_slot(unsigned long addr)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn __is_insn_slot_addr(&kprobe_##__name##_slots, addr);\t\\\n}\n#define KPROBE_INSN_PAGE_SYM\t\t\"kprobe_insn_page\"\n#define KPROBE_OPTINSN_PAGE_SYM\t\t\"kprobe_optinsn_page\"\nint kprobe_cache_get_kallsym(struct kprobe_insn_cache *c, unsigned int *symnum,\n\t\t\t     unsigned long *value, char *type, char *sym);\n#else  \n#define DEFINE_INSN_CACHE_OPS(__name)\t\t\t\t\t\\\nstatic inline bool is_kprobe_##__name##_slot(unsigned long addr)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n#endif\n\nDEFINE_INSN_CACHE_OPS(insn);\n\n#ifdef CONFIG_OPTPROBES\n \nstruct optimized_kprobe {\n\tstruct kprobe kp;\n\tstruct list_head list;\t \n\tstruct arch_optimized_insn optinsn;\n};\n\n \nextern int arch_prepared_optinsn(struct arch_optimized_insn *optinsn);\nextern int arch_check_optimized_kprobe(struct optimized_kprobe *op);\nextern int arch_prepare_optimized_kprobe(struct optimized_kprobe *op,\n\t\t\t\t\t struct kprobe *orig);\nextern void arch_remove_optimized_kprobe(struct optimized_kprobe *op);\nextern void arch_optimize_kprobes(struct list_head *oplist);\nextern void arch_unoptimize_kprobes(struct list_head *oplist,\n\t\t\t\t    struct list_head *done_list);\nextern void arch_unoptimize_kprobe(struct optimized_kprobe *op);\nextern int arch_within_optimized_kprobe(struct optimized_kprobe *op,\n\t\t\t\t\tkprobe_opcode_t *addr);\n\nextern void opt_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nDEFINE_INSN_CACHE_OPS(optinsn);\n\nextern void wait_for_kprobe_optimizer(void);\nbool optprobe_queued_unopt(struct optimized_kprobe *op);\nbool kprobe_disarmed(struct kprobe *p);\n#else  \nstatic inline void wait_for_kprobe_optimizer(void) { }\n#endif  \n\n#ifdef CONFIG_KPROBES_ON_FTRACE\nextern void kprobe_ftrace_handler(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t  struct ftrace_ops *ops, struct ftrace_regs *fregs);\nextern int arch_prepare_kprobe_ftrace(struct kprobe *p);\n#else\nstatic inline int arch_prepare_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -EINVAL;\n}\n#endif  \n\n \nstruct kprobe *get_kprobe(void *addr);\n\n \nstatic inline struct kprobe *kprobe_running(void)\n{\n\treturn __this_cpu_read(current_kprobe);\n}\n\nstatic inline void reset_current_kprobe(void)\n{\n\t__this_cpu_write(current_kprobe, NULL);\n}\n\nstatic inline struct kprobe_ctlblk *get_kprobe_ctlblk(void)\n{\n\treturn this_cpu_ptr(&kprobe_ctlblk);\n}\n\nkprobe_opcode_t *kprobe_lookup_name(const char *name, unsigned int offset);\nkprobe_opcode_t *arch_adjust_kprobe_addr(unsigned long addr, unsigned long offset, bool *on_func_entry);\n\nint register_kprobe(struct kprobe *p);\nvoid unregister_kprobe(struct kprobe *p);\nint register_kprobes(struct kprobe **kps, int num);\nvoid unregister_kprobes(struct kprobe **kps, int num);\n\nint register_kretprobe(struct kretprobe *rp);\nvoid unregister_kretprobe(struct kretprobe *rp);\nint register_kretprobes(struct kretprobe **rps, int num);\nvoid unregister_kretprobes(struct kretprobe **rps, int num);\n\n#if defined(CONFIG_KRETPROBE_ON_RETHOOK) || !defined(CONFIG_KRETPROBES)\n#define kprobe_flush_task(tk)\tdo {} while (0)\n#else\nvoid kprobe_flush_task(struct task_struct *tk);\n#endif\n\nvoid kprobe_free_init_mem(void);\n\nint disable_kprobe(struct kprobe *kp);\nint enable_kprobe(struct kprobe *kp);\n\nvoid dump_kprobe(struct kprobe *kp);\n\nvoid *alloc_insn_page(void);\n\nvoid *alloc_optinsn_page(void);\nvoid free_optinsn_page(void *page);\n\nint kprobe_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t       char *sym);\n\nint arch_kprobe_get_kallsym(unsigned int *symnum, unsigned long *value,\n\t\t\t    char *type, char *sym);\n#else  \n\nstatic inline int kprobe_fault_handler(struct pt_regs *regs, int trapnr)\n{\n\treturn 0;\n}\nstatic inline struct kprobe *get_kprobe(void *addr)\n{\n\treturn NULL;\n}\nstatic inline struct kprobe *kprobe_running(void)\n{\n\treturn NULL;\n}\n#define kprobe_busy_begin()\tdo {} while (0)\n#define kprobe_busy_end()\tdo {} while (0)\n\nstatic inline int register_kprobe(struct kprobe *p)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int register_kprobes(struct kprobe **kps, int num)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline void unregister_kprobe(struct kprobe *p)\n{\n}\nstatic inline void unregister_kprobes(struct kprobe **kps, int num)\n{\n}\nstatic inline int register_kretprobe(struct kretprobe *rp)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int register_kretprobes(struct kretprobe **rps, int num)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline void unregister_kretprobe(struct kretprobe *rp)\n{\n}\nstatic inline void unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}\nstatic inline void kprobe_flush_task(struct task_struct *tk)\n{\n}\nstatic inline void kprobe_free_init_mem(void)\n{\n}\nstatic inline int disable_kprobe(struct kprobe *kp)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int enable_kprobe(struct kprobe *kp)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline bool within_kprobe_blacklist(unsigned long addr)\n{\n\treturn true;\n}\nstatic inline int kprobe_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t\t     char *type, char *sym)\n{\n\treturn -ERANGE;\n}\n#endif  \n\nstatic inline int disable_kretprobe(struct kretprobe *rp)\n{\n\treturn disable_kprobe(&rp->kp);\n}\nstatic inline int enable_kretprobe(struct kretprobe *rp)\n{\n\treturn enable_kprobe(&rp->kp);\n}\n\n#ifndef CONFIG_KPROBES\nstatic inline bool is_kprobe_insn_slot(unsigned long addr)\n{\n\treturn false;\n}\n#endif  \n\n#ifndef CONFIG_OPTPROBES\nstatic inline bool is_kprobe_optinsn_slot(unsigned long addr)\n{\n\treturn false;\n}\n#endif  \n\n#ifdef CONFIG_KRETPROBES\n#ifdef CONFIG_KRETPROBE_ON_RETHOOK\nstatic nokprobe_inline bool is_kretprobe_trampoline(unsigned long addr)\n{\n\treturn is_rethook_trampoline(addr);\n}\n\nstatic nokprobe_inline\nunsigned long kretprobe_find_ret_addr(struct task_struct *tsk, void *fp,\n\t\t\t\t      struct llist_node **cur)\n{\n\treturn rethook_find_ret_addr(tsk, (unsigned long)fp, cur);\n}\n#else\nstatic nokprobe_inline bool is_kretprobe_trampoline(unsigned long addr)\n{\n\treturn (void *)addr == kretprobe_trampoline_addr();\n}\n\nunsigned long kretprobe_find_ret_addr(struct task_struct *tsk, void *fp,\n\t\t\t\t      struct llist_node **cur);\n#endif\n#else\nstatic nokprobe_inline bool is_kretprobe_trampoline(unsigned long addr)\n{\n\treturn false;\n}\n\nstatic nokprobe_inline\nunsigned long kretprobe_find_ret_addr(struct task_struct *tsk, void *fp,\n\t\t\t\t      struct llist_node **cur)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic nokprobe_inline bool kprobe_page_fault(struct pt_regs *regs,\n\t\t\t\t\t      unsigned int trap)\n{\n\tif (!IS_ENABLED(CONFIG_KPROBES))\n\t\treturn false;\n\tif (user_mode(regs))\n\t\treturn false;\n\t \n\tif (preemptible())\n\t\treturn false;\n\tif (!kprobe_running())\n\t\treturn false;\n\treturn kprobe_fault_handler(regs, trap);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}