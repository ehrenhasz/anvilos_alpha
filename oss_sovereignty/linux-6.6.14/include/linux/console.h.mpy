{
  "module_name": "console.h",
  "hash_id": "4572e899cd87565e28a13cab722d88f290f487861293da5cab2b6ab68ea9c57f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/console.h",
  "human_readable_source": " \n\n#ifndef _LINUX_CONSOLE_H_\n#define _LINUX_CONSOLE_H_ 1\n\n#include <linux/atomic.h>\n#include <linux/bits.h>\n#include <linux/rculist.h>\n#include <linux/types.h>\n\nstruct vc_data;\nstruct console_font_op;\nstruct console_font;\nstruct module;\nstruct tty_struct;\nstruct notifier_block;\n\nenum con_scroll {\n\tSM_UP,\n\tSM_DOWN,\n};\n\nenum vc_intensity;\n\n \nstruct consw {\n\tstruct module *owner;\n\tconst char *(*con_startup)(void);\n\tvoid\t(*con_init)(struct vc_data *vc, int init);\n\tvoid\t(*con_deinit)(struct vc_data *vc);\n\tvoid\t(*con_clear)(struct vc_data *vc, int sy, int sx, int height,\n\t\t\tint width);\n\tvoid\t(*con_putc)(struct vc_data *vc, int c, int ypos, int xpos);\n\tvoid\t(*con_putcs)(struct vc_data *vc, const unsigned short *s,\n\t\t\tint count, int ypos, int xpos);\n\tvoid\t(*con_cursor)(struct vc_data *vc, int mode);\n\tbool\t(*con_scroll)(struct vc_data *vc, unsigned int top,\n\t\t\tunsigned int bottom, enum con_scroll dir,\n\t\t\tunsigned int lines);\n\tint\t(*con_switch)(struct vc_data *vc);\n\tint\t(*con_blank)(struct vc_data *vc, int blank, int mode_switch);\n\tint\t(*con_font_set)(struct vc_data *vc, struct console_font *font,\n\t\t\tunsigned int vpitch, unsigned int flags);\n\tint\t(*con_font_get)(struct vc_data *vc, struct console_font *font,\n\t\t\tunsigned int vpitch);\n\tint\t(*con_font_default)(struct vc_data *vc,\n\t\t\tstruct console_font *font, char *name);\n\tint     (*con_resize)(struct vc_data *vc, unsigned int width,\n\t\t\tunsigned int height, unsigned int user);\n\tvoid\t(*con_set_palette)(struct vc_data *vc,\n\t\t\tconst unsigned char *table);\n\tvoid\t(*con_scrolldelta)(struct vc_data *vc, int lines);\n\tint\t(*con_set_origin)(struct vc_data *vc);\n\tvoid\t(*con_save_screen)(struct vc_data *vc);\n\tu8\t(*con_build_attr)(struct vc_data *vc, u8 color,\n\t\t\tenum vc_intensity intensity,\n\t\t\tbool blink, bool underline, bool reverse, bool italic);\n\tvoid\t(*con_invert_region)(struct vc_data *vc, u16 *p, int count);\n\tu16    *(*con_screen_pos)(const struct vc_data *vc, int offset);\n\tunsigned long (*con_getxy)(struct vc_data *vc, unsigned long position,\n\t\t\tint *px, int *py);\n\t \n\tvoid\t(*con_flush_scrollback)(struct vc_data *vc);\n\t \n\tint\t(*con_debug_enter)(struct vc_data *vc);\n\t \n\tint\t(*con_debug_leave)(struct vc_data *vc);\n};\n\nextern const struct consw *conswitchp;\n\nextern const struct consw dummy_con;\t \nextern const struct consw vga_con;\t \nextern const struct consw newport_con;\t \n\nint con_is_bound(const struct consw *csw);\nint do_unregister_con_driver(const struct consw *csw);\nint do_take_over_console(const struct consw *sw, int first, int last, int deflt);\nvoid give_up_console(const struct consw *sw);\n#ifdef CONFIG_HW_CONSOLE\nint con_debug_enter(struct vc_data *vc);\nint con_debug_leave(void);\n#else\nstatic inline int con_debug_enter(struct vc_data *vc)\n{\n\treturn 0;\n}\nstatic inline int con_debug_leave(void)\n{\n\treturn 0;\n}\n#endif\n\n \n#define CM_DRAW     (1)\n#define CM_ERASE    (2)\n#define CM_MOVE     (3)\n\n \n\n \nenum cons_flags {\n\tCON_PRINTBUFFER\t\t= BIT(0),\n\tCON_CONSDEV\t\t= BIT(1),\n\tCON_ENABLED\t\t= BIT(2),\n\tCON_BOOT\t\t= BIT(3),\n\tCON_ANYTIME\t\t= BIT(4),\n\tCON_BRL\t\t\t= BIT(5),\n\tCON_EXTENDED\t\t= BIT(6),\n\tCON_SUSPENDED\t\t= BIT(7),\n};\n\n \nstruct console {\n\tchar\t\t\tname[16];\n\tvoid\t\t\t(*write)(struct console *co, const char *s, unsigned int count);\n\tint\t\t\t(*read)(struct console *co, char *s, unsigned int count);\n\tstruct tty_driver\t*(*device)(struct console *co, int *index);\n\tvoid\t\t\t(*unblank)(void);\n\tint\t\t\t(*setup)(struct console *co, char *options);\n\tint\t\t\t(*exit)(struct console *co);\n\tint\t\t\t(*match)(struct console *co, char *name, int idx, char *options);\n\tshort\t\t\tflags;\n\tshort\t\t\tindex;\n\tint\t\t\tcflag;\n\tuint\t\t\tispeed;\n\tuint\t\t\tospeed;\n\tu64\t\t\tseq;\n\tunsigned long\t\tdropped;\n\tvoid\t\t\t*data;\n\tstruct hlist_node\tnode;\n};\n\n#ifdef CONFIG_LOCKDEP\nextern void lockdep_assert_console_list_lock_held(void);\n#else\nstatic inline void lockdep_assert_console_list_lock_held(void)\n{\n}\n#endif\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nextern bool console_srcu_read_lock_is_held(void);\n#else\nstatic inline bool console_srcu_read_lock_is_held(void)\n{\n\treturn 1;\n}\n#endif\n\nextern int console_srcu_read_lock(void);\nextern void console_srcu_read_unlock(int cookie);\n\nextern void console_list_lock(void) __acquires(console_mutex);\nextern void console_list_unlock(void) __releases(console_mutex);\n\nextern struct hlist_head console_list;\n\n \nstatic inline short console_srcu_read_flags(const struct console *con)\n{\n\tWARN_ON_ONCE(!console_srcu_read_lock_is_held());\n\n\t \n\treturn data_race(READ_ONCE(con->flags));\n}\n\n \nstatic inline void console_srcu_write_flags(struct console *con, short flags)\n{\n\tlockdep_assert_console_list_lock_held();\n\n\t \n\tWRITE_ONCE(con->flags, flags);\n}\n\n \nstatic inline bool console_is_registered_locked(const struct console *con)\n{\n\tlockdep_assert_console_list_lock_held();\n\treturn !hlist_unhashed(&con->node);\n}\n\n \nstatic inline bool console_is_registered(const struct console *con)\n{\n\tbool ret;\n\n\tconsole_list_lock();\n\tret = console_is_registered_locked(con);\n\tconsole_list_unlock();\n\treturn ret;\n}\n\n \n#define for_each_console_srcu(con)\t\t\t\t\t\\\n\thlist_for_each_entry_srcu(con, &console_list, node,\t\t\\\n\t\t\t\t  console_srcu_read_lock_is_held())\n\n \n#define for_each_console(con)\t\t\t\t\t\t\\\n\tlockdep_assert_console_list_lock_held();\t\t\t\\\n\thlist_for_each_entry(con, &console_list, node)\n\nextern int console_set_on_cmdline;\nextern struct console *early_console;\n\nenum con_flush_mode {\n\tCONSOLE_FLUSH_PENDING,\n\tCONSOLE_REPLAY_ALL,\n};\n\nextern int add_preferred_console(char *name, int idx, char *options);\nextern void console_force_preferred_locked(struct console *con);\nextern void register_console(struct console *);\nextern int unregister_console(struct console *);\nextern void console_lock(void);\nextern int console_trylock(void);\nextern void console_unlock(void);\nextern void console_conditional_schedule(void);\nextern void console_unblank(void);\nextern void console_flush_on_panic(enum con_flush_mode mode);\nextern struct tty_driver *console_device(int *);\nextern void console_stop(struct console *);\nextern void console_start(struct console *);\nextern int is_console_locked(void);\nextern int braille_register_console(struct console *, int index,\n\t\tchar *console_options, char *braille_options);\nextern int braille_unregister_console(struct console *);\n#ifdef CONFIG_TTY\nextern void console_sysfs_notify(void);\n#else\nstatic inline void console_sysfs_notify(void)\n{ }\n#endif\nextern bool console_suspend_enabled;\n\n \nextern void suspend_console(void);\nextern void resume_console(void);\n\nint mda_console_init(void);\n\nvoid vcs_make_sysfs(int index);\nvoid vcs_remove_sysfs(int index);\n\n \n#define WARN_CONSOLE_UNLOCKED()\t\t\t\t\t\t\\\n\tWARN_ON(!atomic_read(&ignore_console_lock_warning) &&\t\t\\\n\t\t!is_console_locked() && !oops_in_progress)\n \nextern atomic_t ignore_console_lock_warning;\n\n \n#define VESA_NO_BLANKING        0\n#define VESA_VSYNC_SUSPEND      1\n#define VESA_HSYNC_SUSPEND      2\n#define VESA_POWERDOWN          3\n\nextern void console_init(void);\n\n \nvoid dummycon_register_output_notifier(struct notifier_block *nb);\nvoid dummycon_unregister_output_notifier(struct notifier_block *nb);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}