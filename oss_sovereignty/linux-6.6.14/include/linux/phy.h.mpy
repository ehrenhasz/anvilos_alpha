{
  "module_name": "phy.h",
  "hash_id": "1e7ecc71d9519e17d6ac35e71377b5d841aed04e2019c663e6e60a56cf96b983",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/phy.h",
  "human_readable_source": " \n \n\n#ifndef __PHY_H\n#define __PHY_H\n\n#include <linux/compiler.h>\n#include <linux/spinlock.h>\n#include <linux/ethtool.h>\n#include <linux/leds.h>\n#include <linux/linkmode.h>\n#include <linux/netlink.h>\n#include <linux/mdio.h>\n#include <linux/mii.h>\n#include <linux/mii_timestamper.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/mod_devicetable.h>\n#include <linux/u64_stats_sync.h>\n#include <linux/irqreturn.h>\n#include <linux/iopoll.h>\n#include <linux/refcount.h>\n\n#include <linux/atomic.h>\n\n#define PHY_DEFAULT_FEATURES\t(SUPPORTED_Autoneg | \\\n\t\t\t\t SUPPORTED_TP | \\\n\t\t\t\t SUPPORTED_MII)\n\n#define PHY_10BT_FEATURES\t(SUPPORTED_10baseT_Half | \\\n\t\t\t\t SUPPORTED_10baseT_Full)\n\n#define PHY_100BT_FEATURES\t(SUPPORTED_100baseT_Half | \\\n\t\t\t\t SUPPORTED_100baseT_Full)\n\n#define PHY_1000BT_FEATURES\t(SUPPORTED_1000baseT_Half | \\\n\t\t\t\t SUPPORTED_1000baseT_Full)\n\nextern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_features) __ro_after_init;\nextern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_t1_features) __ro_after_init;\nextern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_t1s_p2mp_features) __ro_after_init;\nextern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_features) __ro_after_init;\nextern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_fibre_features) __ro_after_init;\nextern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_all_ports_features) __ro_after_init;\nextern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_features) __ro_after_init;\nextern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_fec_features) __ro_after_init;\nextern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_full_features) __ro_after_init;\nextern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_eee_cap1_features) __ro_after_init;\n\n#define PHY_BASIC_FEATURES ((unsigned long *)&phy_basic_features)\n#define PHY_BASIC_T1_FEATURES ((unsigned long *)&phy_basic_t1_features)\n#define PHY_BASIC_T1S_P2MP_FEATURES ((unsigned long *)&phy_basic_t1s_p2mp_features)\n#define PHY_GBIT_FEATURES ((unsigned long *)&phy_gbit_features)\n#define PHY_GBIT_FIBRE_FEATURES ((unsigned long *)&phy_gbit_fibre_features)\n#define PHY_GBIT_ALL_PORTS_FEATURES ((unsigned long *)&phy_gbit_all_ports_features)\n#define PHY_10GBIT_FEATURES ((unsigned long *)&phy_10gbit_features)\n#define PHY_10GBIT_FEC_FEATURES ((unsigned long *)&phy_10gbit_fec_features)\n#define PHY_10GBIT_FULL_FEATURES ((unsigned long *)&phy_10gbit_full_features)\n#define PHY_EEE_CAP1_FEATURES ((unsigned long *)&phy_eee_cap1_features)\n\nextern const int phy_basic_ports_array[3];\nextern const int phy_fibre_port_array[1];\nextern const int phy_all_ports_features_array[7];\nextern const int phy_10_100_features_array[4];\nextern const int phy_basic_t1_features_array[3];\nextern const int phy_basic_t1s_p2mp_features_array[2];\nextern const int phy_gbit_features_array[2];\nextern const int phy_10gbit_features_array[1];\n\n \n#define PHY_POLL\t\t-1\n#define PHY_MAC_INTERRUPT\t-2\n\n#define PHY_IS_INTERNAL\t\t0x00000001\n#define PHY_RST_AFTER_CLK_EN\t0x00000002\n#define PHY_POLL_CABLE_TEST\t0x00000004\n#define PHY_ALWAYS_CALL_SUSPEND\t0x00000008\n#define MDIO_DEVICE_IS_PHY\t0x80000000\n\n \ntypedef enum {\n\tPHY_INTERFACE_MODE_NA,\n\tPHY_INTERFACE_MODE_INTERNAL,\n\tPHY_INTERFACE_MODE_MII,\n\tPHY_INTERFACE_MODE_GMII,\n\tPHY_INTERFACE_MODE_SGMII,\n\tPHY_INTERFACE_MODE_TBI,\n\tPHY_INTERFACE_MODE_REVMII,\n\tPHY_INTERFACE_MODE_RMII,\n\tPHY_INTERFACE_MODE_REVRMII,\n\tPHY_INTERFACE_MODE_RGMII,\n\tPHY_INTERFACE_MODE_RGMII_ID,\n\tPHY_INTERFACE_MODE_RGMII_RXID,\n\tPHY_INTERFACE_MODE_RGMII_TXID,\n\tPHY_INTERFACE_MODE_RTBI,\n\tPHY_INTERFACE_MODE_SMII,\n\tPHY_INTERFACE_MODE_XGMII,\n\tPHY_INTERFACE_MODE_XLGMII,\n\tPHY_INTERFACE_MODE_MOCA,\n\tPHY_INTERFACE_MODE_PSGMII,\n\tPHY_INTERFACE_MODE_QSGMII,\n\tPHY_INTERFACE_MODE_TRGMII,\n\tPHY_INTERFACE_MODE_100BASEX,\n\tPHY_INTERFACE_MODE_1000BASEX,\n\tPHY_INTERFACE_MODE_2500BASEX,\n\tPHY_INTERFACE_MODE_5GBASER,\n\tPHY_INTERFACE_MODE_RXAUI,\n\tPHY_INTERFACE_MODE_XAUI,\n\t \n\tPHY_INTERFACE_MODE_10GBASER,\n\tPHY_INTERFACE_MODE_25GBASER,\n\tPHY_INTERFACE_MODE_USXGMII,\n\t \n\tPHY_INTERFACE_MODE_10GKR,\n\tPHY_INTERFACE_MODE_QUSGMII,\n\tPHY_INTERFACE_MODE_1000BASEKX,\n\tPHY_INTERFACE_MODE_MAX,\n} phy_interface_t;\n\n \n#define DECLARE_PHY_INTERFACE_MASK(name) \\\n\tDECLARE_BITMAP(name, PHY_INTERFACE_MODE_MAX)\n\nstatic inline void phy_interface_zero(unsigned long *intf)\n{\n\tbitmap_zero(intf, PHY_INTERFACE_MODE_MAX);\n}\n\nstatic inline bool phy_interface_empty(const unsigned long *intf)\n{\n\treturn bitmap_empty(intf, PHY_INTERFACE_MODE_MAX);\n}\n\nstatic inline void phy_interface_and(unsigned long *dst, const unsigned long *a,\n\t\t\t\t     const unsigned long *b)\n{\n\tbitmap_and(dst, a, b, PHY_INTERFACE_MODE_MAX);\n}\n\nstatic inline void phy_interface_or(unsigned long *dst, const unsigned long *a,\n\t\t\t\t    const unsigned long *b)\n{\n\tbitmap_or(dst, a, b, PHY_INTERFACE_MODE_MAX);\n}\n\nstatic inline void phy_interface_set_rgmii(unsigned long *intf)\n{\n\t__set_bit(PHY_INTERFACE_MODE_RGMII, intf);\n\t__set_bit(PHY_INTERFACE_MODE_RGMII_ID, intf);\n\t__set_bit(PHY_INTERFACE_MODE_RGMII_RXID, intf);\n\t__set_bit(PHY_INTERFACE_MODE_RGMII_TXID, intf);\n}\n\n \nunsigned int phy_supported_speeds(struct phy_device *phy,\n\t\t\t\t      unsigned int *speeds,\n\t\t\t\t      unsigned int size);\n\n \nstatic inline const char *phy_modes(phy_interface_t interface)\n{\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_NA:\n\t\treturn \"\";\n\tcase PHY_INTERFACE_MODE_INTERNAL:\n\t\treturn \"internal\";\n\tcase PHY_INTERFACE_MODE_MII:\n\t\treturn \"mii\";\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\treturn \"gmii\";\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\treturn \"sgmii\";\n\tcase PHY_INTERFACE_MODE_TBI:\n\t\treturn \"tbi\";\n\tcase PHY_INTERFACE_MODE_REVMII:\n\t\treturn \"rev-mii\";\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\treturn \"rmii\";\n\tcase PHY_INTERFACE_MODE_REVRMII:\n\t\treturn \"rev-rmii\";\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\treturn \"rgmii\";\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\treturn \"rgmii-id\";\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\treturn \"rgmii-rxid\";\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\treturn \"rgmii-txid\";\n\tcase PHY_INTERFACE_MODE_RTBI:\n\t\treturn \"rtbi\";\n\tcase PHY_INTERFACE_MODE_SMII:\n\t\treturn \"smii\";\n\tcase PHY_INTERFACE_MODE_XGMII:\n\t\treturn \"xgmii\";\n\tcase PHY_INTERFACE_MODE_XLGMII:\n\t\treturn \"xlgmii\";\n\tcase PHY_INTERFACE_MODE_MOCA:\n\t\treturn \"moca\";\n\tcase PHY_INTERFACE_MODE_PSGMII:\n\t\treturn \"psgmii\";\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\treturn \"qsgmii\";\n\tcase PHY_INTERFACE_MODE_TRGMII:\n\t\treturn \"trgmii\";\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\treturn \"1000base-x\";\n\tcase PHY_INTERFACE_MODE_1000BASEKX:\n\t\treturn \"1000base-kx\";\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\treturn \"2500base-x\";\n\tcase PHY_INTERFACE_MODE_5GBASER:\n\t\treturn \"5gbase-r\";\n\tcase PHY_INTERFACE_MODE_RXAUI:\n\t\treturn \"rxaui\";\n\tcase PHY_INTERFACE_MODE_XAUI:\n\t\treturn \"xaui\";\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\treturn \"10gbase-r\";\n\tcase PHY_INTERFACE_MODE_25GBASER:\n\t\treturn \"25gbase-r\";\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\treturn \"usxgmii\";\n\tcase PHY_INTERFACE_MODE_10GKR:\n\t\treturn \"10gbase-kr\";\n\tcase PHY_INTERFACE_MODE_100BASEX:\n\t\treturn \"100base-x\";\n\tcase PHY_INTERFACE_MODE_QUSGMII:\n\t\treturn \"qusgmii\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n#define PHY_INIT_TIMEOUT\t100000\n#define PHY_FORCE_TIMEOUT\t10\n\n#define PHY_MAX_ADDR\t32\n\n \n#define PHY_ID_FMT \"%s:%02x\"\n\n#define MII_BUS_ID_SIZE\t61\n\nstruct device;\nstruct kernel_hwtstamp_config;\nstruct phylink;\nstruct sfp_bus;\nstruct sfp_upstream_ops;\nstruct sk_buff;\n\n \nstruct mdio_bus_stats {\n\tu64_stats_t transfers;\n\tu64_stats_t errors;\n\tu64_stats_t writes;\n\tu64_stats_t reads;\n\t \n\tstruct u64_stats_sync syncp;\n};\n\n \nstruct phy_package_shared {\n\tint addr;\n\trefcount_t refcnt;\n\tunsigned long flags;\n\tsize_t priv_size;\n\n\t \n\t \n\tvoid *priv;\n};\n\n \n#define PHY_SHARED_F_INIT_DONE  0\n#define PHY_SHARED_F_PROBE_DONE 1\n\n \nstruct mii_bus {\n\tstruct module *owner;\n\tconst char *name;\n\tchar id[MII_BUS_ID_SIZE];\n\tvoid *priv;\n\t \n\tint (*read)(struct mii_bus *bus, int addr, int regnum);\n\t \n\tint (*write)(struct mii_bus *bus, int addr, int regnum, u16 val);\n\t \n\tint (*read_c45)(struct mii_bus *bus, int addr, int devnum, int regnum);\n\t \n\tint (*write_c45)(struct mii_bus *bus, int addr, int devnum,\n\t\t\t int regnum, u16 val);\n\t \n\tint (*reset)(struct mii_bus *bus);\n\n\t \n\tstruct mdio_bus_stats stats[PHY_MAX_ADDR];\n\n\t \n\tstruct mutex mdio_lock;\n\n\t \n\tstruct device *parent;\n\t \n\tenum {\n\t\tMDIOBUS_ALLOCATED = 1,\n\t\tMDIOBUS_REGISTERED,\n\t\tMDIOBUS_UNREGISTERED,\n\t\tMDIOBUS_RELEASED,\n\t} state;\n\n\t \n\tstruct device dev;\n\n\t \n\tstruct mdio_device *mdio_map[PHY_MAX_ADDR];\n\n\t \n\tu32 phy_mask;\n\n\t \n\tu32 phy_ignore_ta_mask;\n\n\t \n\tint irq[PHY_MAX_ADDR];\n\n\t \n\tint reset_delay_us;\n\t \n\tint reset_post_delay_us;\n\t \n\tstruct gpio_desc *reset_gpiod;\n\n\t \n\tstruct mutex shared_lock;\n\n\t \n\tstruct phy_package_shared *shared[PHY_MAX_ADDR];\n};\n#define to_mii_bus(d) container_of(d, struct mii_bus, dev)\n\nstruct mii_bus *mdiobus_alloc_size(size_t size);\n\n \nstatic inline struct mii_bus *mdiobus_alloc(void)\n{\n\treturn mdiobus_alloc_size(0);\n}\n\nint __mdiobus_register(struct mii_bus *bus, struct module *owner);\nint __devm_mdiobus_register(struct device *dev, struct mii_bus *bus,\n\t\t\t    struct module *owner);\n#define mdiobus_register(bus) __mdiobus_register(bus, THIS_MODULE)\n#define devm_mdiobus_register(dev, bus) \\\n\t\t__devm_mdiobus_register(dev, bus, THIS_MODULE)\n\nvoid mdiobus_unregister(struct mii_bus *bus);\nvoid mdiobus_free(struct mii_bus *bus);\nstruct mii_bus *devm_mdiobus_alloc_size(struct device *dev, int sizeof_priv);\nstatic inline struct mii_bus *devm_mdiobus_alloc(struct device *dev)\n{\n\treturn devm_mdiobus_alloc_size(dev, 0);\n}\n\nstruct mii_bus *mdio_find_bus(const char *mdio_name);\nstruct phy_device *mdiobus_scan_c22(struct mii_bus *bus, int addr);\n\n#define PHY_INTERRUPT_DISABLED\tfalse\n#define PHY_INTERRUPT_ENABLED\ttrue\n\n \nenum phy_state {\n\tPHY_DOWN = 0,\n\tPHY_READY,\n\tPHY_HALTED,\n\tPHY_ERROR,\n\tPHY_UP,\n\tPHY_RUNNING,\n\tPHY_NOLINK,\n\tPHY_CABLETEST,\n};\n\n#define MDIO_MMD_NUM 32\n\n \nstruct phy_c45_device_ids {\n\tu32 devices_in_package;\n\tu32 mmds_present;\n\tu32 device_ids[MDIO_MMD_NUM];\n};\n\nstruct macsec_context;\nstruct macsec_ops;\n\n \nstruct phy_device {\n\tstruct mdio_device mdio;\n\n\t \n\t \n\tstruct phy_driver *drv;\n\n\tstruct device_link *devlink;\n\n\tu32 phy_id;\n\n\tstruct phy_c45_device_ids c45_ids;\n\tunsigned is_c45:1;\n\tunsigned is_internal:1;\n\tunsigned is_pseudo_fixed_link:1;\n\tunsigned is_gigabit_capable:1;\n\tunsigned has_fixups:1;\n\tunsigned suspended:1;\n\tunsigned suspended_by_mdio_bus:1;\n\tunsigned sysfs_links:1;\n\tunsigned loopback_enabled:1;\n\tunsigned downshifted_rate:1;\n\tunsigned is_on_sfp_module:1;\n\tunsigned mac_managed_pm:1;\n\tunsigned wol_enabled:1;\n\n\tunsigned autoneg:1;\n\t \n\tunsigned link:1;\n\tunsigned autoneg_complete:1;\n\n\t \n\tunsigned interrupts:1;\n\tunsigned irq_suspended:1;\n\tunsigned irq_rerun:1;\n\n\tint rate_matching;\n\n\tenum phy_state state;\n\n\tu32 dev_flags;\n\n\tphy_interface_t interface;\n\n\t \n\tint speed;\n\tint duplex;\n\tint port;\n\tint pause;\n\tint asym_pause;\n\tu8 master_slave_get;\n\tu8 master_slave_set;\n\tu8 master_slave_state;\n\n\t \n\t \n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(supported);\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(lp_advertising);\n\t \n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(adv_old);\n\t \n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(supported_eee);\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising_eee);\n\tbool eee_enabled;\n\n\t \n\tDECLARE_PHY_INTERFACE_MASK(host_interfaces);\n\n\t \n\tu32 eee_broken_modes;\n\n#ifdef CONFIG_LED_TRIGGER_PHY\n\tstruct phy_led_trigger *phy_led_triggers;\n\tunsigned int phy_num_led_triggers;\n\tstruct phy_led_trigger *last_triggered;\n\n\tstruct phy_led_trigger *led_link_trigger;\n#endif\n\tstruct list_head leds;\n\n\t \n\tint irq;\n\n\t \n\t \n\tvoid *priv;\n\n\t \n\t \n\tstruct phy_package_shared *shared;\n\n\t \n\tstruct sk_buff *skb;\n\tvoid *ehdr;\n\tstruct nlattr *nest;\n\n\t \n\tstruct delayed_work state_queue;\n\n\tstruct mutex lock;\n\n\t \n\tbool sfp_bus_attached;\n\tstruct sfp_bus *sfp_bus;\n\tstruct phylink *phylink;\n\tstruct net_device *attached_dev;\n\tstruct mii_timestamper *mii_ts;\n\tstruct pse_control *psec;\n\n\tu8 mdix;\n\tu8 mdix_ctrl;\n\n\tint pma_extable;\n\n\tunsigned int link_down_events;\n\n\tvoid (*phy_link_change)(struct phy_device *phydev, bool up);\n\tvoid (*adjust_link)(struct net_device *dev);\n\n#if IS_ENABLED(CONFIG_MACSEC)\n\t \n\tconst struct macsec_ops *macsec_ops;\n#endif\n};\n\n \n#define PHY_F_NO_IRQ\t\t0x80000000\n\nstatic inline struct phy_device *to_phy_device(const struct device *dev)\n{\n\treturn container_of(to_mdio_device(dev), struct phy_device, mdio);\n}\n\n \nstruct phy_tdr_config {\n\tu32 first;\n\tu32 last;\n\tu32 step;\n\ts8 pair;\n};\n#define PHY_PAIR_ALL -1\n\n \nstruct phy_plca_cfg {\n\tint version;\n\tint enabled;\n\tint node_id;\n\tint node_cnt;\n\tint to_tmr;\n\tint burst_cnt;\n\tint burst_tmr;\n};\n\n \nstruct phy_plca_status {\n\tbool pst;\n};\n\n \nstruct phy_led {\n\tstruct list_head list;\n\tstruct phy_device *phydev;\n\tstruct led_classdev led_cdev;\n\tu8 index;\n};\n\n#define to_phy_led(d) container_of(d, struct phy_led, led_cdev)\n\n \nstruct phy_driver {\n\tstruct mdio_driver_common mdiodrv;\n\tu32 phy_id;\n\tchar *name;\n\tu32 phy_id_mask;\n\tconst unsigned long * const features;\n\tu32 flags;\n\tconst void *driver_data;\n\n\t \n\tint (*soft_reset)(struct phy_device *phydev);\n\n\t \n\tint (*config_init)(struct phy_device *phydev);\n\n\t \n\tint (*probe)(struct phy_device *phydev);\n\n\t \n\tint (*get_features)(struct phy_device *phydev);\n\n\t \n\tint (*get_rate_matching)(struct phy_device *phydev,\n\t\t\t\t   phy_interface_t iface);\n\n\t \n\t \n\tint (*suspend)(struct phy_device *phydev);\n\t \n\tint (*resume)(struct phy_device *phydev);\n\n\t \n\tint (*config_aneg)(struct phy_device *phydev);\n\n\t \n\tint (*aneg_done)(struct phy_device *phydev);\n\n\t \n\tint (*read_status)(struct phy_device *phydev);\n\n\t \n\tint (*config_intr)(struct phy_device *phydev);\n\n\t \n\tirqreturn_t (*handle_interrupt)(struct phy_device *phydev);\n\n\t \n\tvoid (*remove)(struct phy_device *phydev);\n\n\t \n\tint (*match_phy_device)(struct phy_device *phydev);\n\n\t \n\tint (*set_wol)(struct phy_device *dev, struct ethtool_wolinfo *wol);\n\n\t \n\tvoid (*get_wol)(struct phy_device *dev, struct ethtool_wolinfo *wol);\n\n\t \n\tvoid (*link_change_notify)(struct phy_device *dev);\n\n\t \n\tint (*read_mmd)(struct phy_device *dev, int devnum, u16 regnum);\n\n\t \n\tint (*write_mmd)(struct phy_device *dev, int devnum, u16 regnum,\n\t\t\t u16 val);\n\n\t \n\tint (*read_page)(struct phy_device *dev);\n\t \n\tint (*write_page)(struct phy_device *dev, int page);\n\n\t \n\tint (*module_info)(struct phy_device *dev,\n\t\t\t   struct ethtool_modinfo *modinfo);\n\n\t \n\tint (*module_eeprom)(struct phy_device *dev,\n\t\t\t     struct ethtool_eeprom *ee, u8 *data);\n\n\t \n\tint (*cable_test_start)(struct phy_device *dev);\n\n\t \n\tint (*cable_test_tdr_start)(struct phy_device *dev,\n\t\t\t\t    const struct phy_tdr_config *config);\n\n\t \n\tint (*cable_test_get_status)(struct phy_device *dev, bool *finished);\n\n\t \n\t \n\tint (*get_sset_count)(struct phy_device *dev);\n\t \n\tvoid (*get_strings)(struct phy_device *dev, u8 *data);\n\t \n\tvoid (*get_stats)(struct phy_device *dev,\n\t\t\t  struct ethtool_stats *stats, u64 *data);\n\n\t \n\t \n\tint (*get_tunable)(struct phy_device *dev,\n\t\t\t   struct ethtool_tunable *tuna, void *data);\n\t \n\tint (*set_tunable)(struct phy_device *dev,\n\t\t\t    struct ethtool_tunable *tuna,\n\t\t\t    const void *data);\n\t \n\tint (*set_loopback)(struct phy_device *dev, bool enable);\n\t \n\tint (*get_sqi)(struct phy_device *dev);\n\t \n\tint (*get_sqi_max)(struct phy_device *dev);\n\n\t \n\t \n\tint (*get_plca_cfg)(struct phy_device *dev,\n\t\t\t    struct phy_plca_cfg *plca_cfg);\n\t \n\tint (*set_plca_cfg)(struct phy_device *dev,\n\t\t\t    const struct phy_plca_cfg *plca_cfg);\n\t \n\tint (*get_plca_status)(struct phy_device *dev,\n\t\t\t       struct phy_plca_status *plca_st);\n\n\t \n\tint (*led_brightness_set)(struct phy_device *dev,\n\t\t\t\t  u8 index, enum led_brightness value);\n\n\t \n\tint (*led_blink_set)(struct phy_device *dev, u8 index,\n\t\t\t     unsigned long *delay_on,\n\t\t\t     unsigned long *delay_off);\n\t \n\tint (*led_hw_is_supported)(struct phy_device *dev, u8 index,\n\t\t\t\t   unsigned long rules);\n\t \n\tint (*led_hw_control_set)(struct phy_device *dev, u8 index,\n\t\t\t\t  unsigned long rules);\n\t \n\tint (*led_hw_control_get)(struct phy_device *dev, u8 index,\n\t\t\t\t  unsigned long *rules);\n\n};\n#define to_phy_driver(d) container_of(to_mdio_common_driver(d),\t\t\\\n\t\t\t\t      struct phy_driver, mdiodrv)\n\n#define PHY_ANY_ID \"MATCH ANY PHY\"\n#define PHY_ANY_UID 0xffffffff\n\n#define PHY_ID_MATCH_EXACT(id) .phy_id = (id), .phy_id_mask = GENMASK(31, 0)\n#define PHY_ID_MATCH_MODEL(id) .phy_id = (id), .phy_id_mask = GENMASK(31, 4)\n#define PHY_ID_MATCH_VENDOR(id) .phy_id = (id), .phy_id_mask = GENMASK(31, 10)\n\n \nstatic inline bool phy_id_compare(u32 id1, u32 id2, u32 mask)\n{\n\treturn !((id1 ^ id2) & mask);\n}\n\n \nstatic inline bool phydev_id_compare(struct phy_device *phydev, u32 id)\n{\n\treturn phy_id_compare(id, phydev->phy_id, phydev->drv->phy_id_mask);\n}\n\n \nstruct phy_fixup {\n\tstruct list_head list;\n\tchar bus_id[MII_BUS_ID_SIZE + 3];\n\tu32 phy_uid;\n\tu32 phy_uid_mask;\n\tint (*run)(struct phy_device *phydev);\n};\n\nconst char *phy_speed_to_str(int speed);\nconst char *phy_duplex_to_str(unsigned int duplex);\nconst char *phy_rate_matching_to_str(int rate_matching);\n\nint phy_interface_num_ports(phy_interface_t interface);\n\n \nstruct phy_setting {\n\tu32 speed;\n\tu8 duplex;\n\tu8 bit;\n};\n\nconst struct phy_setting *\nphy_lookup_setting(int speed, int duplex, const unsigned long *mask,\n\t\t   bool exact);\nsize_t phy_speeds(unsigned int *speeds, size_t size,\n\t\t  unsigned long *mask);\nvoid of_set_phy_supported(struct phy_device *phydev);\nvoid of_set_phy_eee_broken(struct phy_device *phydev);\nint phy_speed_down_core(struct phy_device *phydev);\n\n \nstatic inline bool phy_is_started(struct phy_device *phydev)\n{\n\treturn phydev->state >= PHY_UP;\n}\n\nvoid phy_resolve_aneg_pause(struct phy_device *phydev);\nvoid phy_resolve_aneg_linkmode(struct phy_device *phydev);\nvoid phy_check_downshift(struct phy_device *phydev);\n\n \nstatic inline int phy_read(struct phy_device *phydev, u32 regnum)\n{\n\treturn mdiobus_read(phydev->mdio.bus, phydev->mdio.addr, regnum);\n}\n\n#define phy_read_poll_timeout(phydev, regnum, val, cond, sleep_us, \\\n\t\t\t\ttimeout_us, sleep_before_read) \\\n({ \\\n\tint __ret, __val; \\\n\t__ret = read_poll_timeout(__val = phy_read, val, \\\n\t\t\t\t  __val < 0 || (cond), \\\n\t\tsleep_us, timeout_us, sleep_before_read, phydev, regnum); \\\n\tif (__val < 0) \\\n\t\t__ret = __val; \\\n\tif (__ret) \\\n\t\tphydev_err(phydev, \"%s failed: %d\\n\", __func__, __ret); \\\n\t__ret; \\\n})\n\n \nstatic inline int __phy_read(struct phy_device *phydev, u32 regnum)\n{\n\treturn __mdiobus_read(phydev->mdio.bus, phydev->mdio.addr, regnum);\n}\n\n \nstatic inline int phy_write(struct phy_device *phydev, u32 regnum, u16 val)\n{\n\treturn mdiobus_write(phydev->mdio.bus, phydev->mdio.addr, regnum, val);\n}\n\n \nstatic inline int __phy_write(struct phy_device *phydev, u32 regnum, u16 val)\n{\n\treturn __mdiobus_write(phydev->mdio.bus, phydev->mdio.addr, regnum,\n\t\t\t       val);\n}\n\n \nstatic inline int __phy_modify_changed(struct phy_device *phydev, u32 regnum,\n\t\t\t\t       u16 mask, u16 set)\n{\n\treturn __mdiobus_modify_changed(phydev->mdio.bus, phydev->mdio.addr,\n\t\t\t\t\tregnum, mask, set);\n}\n\n \nint phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);\n\n \n#define phy_read_mmd_poll_timeout(phydev, devaddr, regnum, val, cond, \\\n\t\t\t\t  sleep_us, timeout_us, sleep_before_read) \\\n({ \\\n\tint __ret, __val; \\\n\t__ret = read_poll_timeout(__val = phy_read_mmd, val, \\\n\t\t\t\t  __val < 0 || (cond), \\\n\t\t\t\t  sleep_us, timeout_us, sleep_before_read, \\\n\t\t\t\t  phydev, devaddr, regnum); \\\n\tif (__val < 0) \\\n\t\t__ret = __val; \\\n\tif (__ret) \\\n\t\tphydev_err(phydev, \"%s failed: %d\\n\", __func__, __ret); \\\n\t__ret; \\\n})\n\n \nint __phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);\n\n \nint phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);\n\n \nint __phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);\n\nint __phy_modify_changed(struct phy_device *phydev, u32 regnum, u16 mask,\n\t\t\t u16 set);\nint phy_modify_changed(struct phy_device *phydev, u32 regnum, u16 mask,\n\t\t       u16 set);\nint __phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);\nint phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);\n\nint __phy_modify_mmd_changed(struct phy_device *phydev, int devad, u32 regnum,\n\t\t\t     u16 mask, u16 set);\nint phy_modify_mmd_changed(struct phy_device *phydev, int devad, u32 regnum,\n\t\t\t   u16 mask, u16 set);\nint __phy_modify_mmd(struct phy_device *phydev, int devad, u32 regnum,\n\t\t     u16 mask, u16 set);\nint phy_modify_mmd(struct phy_device *phydev, int devad, u32 regnum,\n\t\t   u16 mask, u16 set);\n\n \nstatic inline int __phy_set_bits(struct phy_device *phydev, u32 regnum, u16 val)\n{\n\treturn __phy_modify(phydev, regnum, 0, val);\n}\n\n \nstatic inline int __phy_clear_bits(struct phy_device *phydev, u32 regnum,\n\t\t\t\t   u16 val)\n{\n\treturn __phy_modify(phydev, regnum, val, 0);\n}\n\n \nstatic inline int phy_set_bits(struct phy_device *phydev, u32 regnum, u16 val)\n{\n\treturn phy_modify(phydev, regnum, 0, val);\n}\n\n \nstatic inline int phy_clear_bits(struct phy_device *phydev, u32 regnum, u16 val)\n{\n\treturn phy_modify(phydev, regnum, val, 0);\n}\n\n \nstatic inline int __phy_set_bits_mmd(struct phy_device *phydev, int devad,\n\t\tu32 regnum, u16 val)\n{\n\treturn __phy_modify_mmd(phydev, devad, regnum, 0, val);\n}\n\n \nstatic inline int __phy_clear_bits_mmd(struct phy_device *phydev, int devad,\n\t\tu32 regnum, u16 val)\n{\n\treturn __phy_modify_mmd(phydev, devad, regnum, val, 0);\n}\n\n \nstatic inline int phy_set_bits_mmd(struct phy_device *phydev, int devad,\n\t\tu32 regnum, u16 val)\n{\n\treturn phy_modify_mmd(phydev, devad, regnum, 0, val);\n}\n\n \nstatic inline int phy_clear_bits_mmd(struct phy_device *phydev, int devad,\n\t\tu32 regnum, u16 val)\n{\n\treturn phy_modify_mmd(phydev, devad, regnum, val, 0);\n}\n\n \nstatic inline bool phy_interrupt_is_valid(struct phy_device *phydev)\n{\n\treturn phydev->irq != PHY_POLL && phydev->irq != PHY_MAC_INTERRUPT;\n}\n\n \nstatic inline bool phy_polling_mode(struct phy_device *phydev)\n{\n\tif (phydev->state == PHY_CABLETEST)\n\t\tif (phydev->drv->flags & PHY_POLL_CABLE_TEST)\n\t\t\treturn true;\n\n\treturn phydev->irq == PHY_POLL;\n}\n\n \nstatic inline bool phy_has_hwtstamp(struct phy_device *phydev)\n{\n\treturn phydev && phydev->mii_ts && phydev->mii_ts->hwtstamp;\n}\n\n \nstatic inline bool phy_has_rxtstamp(struct phy_device *phydev)\n{\n\treturn phydev && phydev->mii_ts && phydev->mii_ts->rxtstamp;\n}\n\n \nstatic inline bool phy_has_tsinfo(struct phy_device *phydev)\n{\n\treturn phydev && phydev->mii_ts && phydev->mii_ts->ts_info;\n}\n\n \nstatic inline bool phy_has_txtstamp(struct phy_device *phydev)\n{\n\treturn phydev && phydev->mii_ts && phydev->mii_ts->txtstamp;\n}\n\nstatic inline int phy_hwtstamp(struct phy_device *phydev, struct ifreq *ifr)\n{\n\treturn phydev->mii_ts->hwtstamp(phydev->mii_ts, ifr);\n}\n\nstatic inline bool phy_rxtstamp(struct phy_device *phydev, struct sk_buff *skb,\n\t\t\t\tint type)\n{\n\treturn phydev->mii_ts->rxtstamp(phydev->mii_ts, skb, type);\n}\n\nstatic inline int phy_ts_info(struct phy_device *phydev,\n\t\t\t      struct ethtool_ts_info *tsinfo)\n{\n\treturn phydev->mii_ts->ts_info(phydev->mii_ts, tsinfo);\n}\n\nstatic inline void phy_txtstamp(struct phy_device *phydev, struct sk_buff *skb,\n\t\t\t\tint type)\n{\n\tphydev->mii_ts->txtstamp(phydev->mii_ts, skb, type);\n}\n\n \nstatic inline bool phy_is_internal(struct phy_device *phydev)\n{\n\treturn phydev->is_internal;\n}\n\n \nstatic inline bool phy_on_sfp(struct phy_device *phydev)\n{\n\treturn phydev->is_on_sfp_module;\n}\n\n \nstatic inline bool phy_interface_mode_is_rgmii(phy_interface_t mode)\n{\n\treturn mode >= PHY_INTERFACE_MODE_RGMII &&\n\t\tmode <= PHY_INTERFACE_MODE_RGMII_TXID;\n};\n\n \nstatic inline bool phy_interface_mode_is_8023z(phy_interface_t mode)\n{\n\treturn mode == PHY_INTERFACE_MODE_1000BASEX ||\n\t       mode == PHY_INTERFACE_MODE_2500BASEX;\n}\n\n \nstatic inline bool phy_interface_is_rgmii(struct phy_device *phydev)\n{\n\treturn phy_interface_mode_is_rgmii(phydev->interface);\n};\n\n \nstatic inline bool phy_is_pseudo_fixed_link(struct phy_device *phydev)\n{\n\treturn phydev->is_pseudo_fixed_link;\n}\n\nint phy_save_page(struct phy_device *phydev);\nint phy_select_page(struct phy_device *phydev, int page);\nint phy_restore_page(struct phy_device *phydev, int oldpage, int ret);\nint phy_read_paged(struct phy_device *phydev, int page, u32 regnum);\nint phy_write_paged(struct phy_device *phydev, int page, u32 regnum, u16 val);\nint phy_modify_paged_changed(struct phy_device *phydev, int page, u32 regnum,\n\t\t\t     u16 mask, u16 set);\nint phy_modify_paged(struct phy_device *phydev, int page, u32 regnum,\n\t\t     u16 mask, u16 set);\n\nstruct phy_device *phy_device_create(struct mii_bus *bus, int addr, u32 phy_id,\n\t\t\t\t     bool is_c45,\n\t\t\t\t     struct phy_c45_device_ids *c45_ids);\n#if IS_ENABLED(CONFIG_PHYLIB)\nint fwnode_get_phy_id(struct fwnode_handle *fwnode, u32 *phy_id);\nstruct mdio_device *fwnode_mdio_find_device(struct fwnode_handle *fwnode);\nstruct phy_device *fwnode_phy_find_device(struct fwnode_handle *phy_fwnode);\nstruct phy_device *device_phy_find_device(struct device *dev);\nstruct fwnode_handle *fwnode_get_phy_node(const struct fwnode_handle *fwnode);\nstruct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45);\nint phy_device_register(struct phy_device *phy);\nvoid phy_device_free(struct phy_device *phydev);\n#else\nstatic inline int fwnode_get_phy_id(struct fwnode_handle *fwnode, u32 *phy_id)\n{\n\treturn 0;\n}\nstatic inline\nstruct mdio_device *fwnode_mdio_find_device(struct fwnode_handle *fwnode)\n{\n\treturn 0;\n}\n\nstatic inline\nstruct phy_device *fwnode_phy_find_device(struct fwnode_handle *phy_fwnode)\n{\n\treturn NULL;\n}\n\nstatic inline struct phy_device *device_phy_find_device(struct device *dev)\n{\n\treturn NULL;\n}\n\nstatic inline\nstruct fwnode_handle *fwnode_get_phy_node(struct fwnode_handle *fwnode)\n{\n\treturn NULL;\n}\n\nstatic inline\nstruct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45)\n{\n\treturn NULL;\n}\n\nstatic inline int phy_device_register(struct phy_device *phy)\n{\n\treturn 0;\n}\n\nstatic inline void phy_device_free(struct phy_device *phydev) { }\n#endif  \nvoid phy_device_remove(struct phy_device *phydev);\nint phy_get_c45_ids(struct phy_device *phydev);\nint phy_init_hw(struct phy_device *phydev);\nint phy_suspend(struct phy_device *phydev);\nint phy_resume(struct phy_device *phydev);\nint __phy_resume(struct phy_device *phydev);\nint phy_loopback(struct phy_device *phydev, bool enable);\nvoid phy_sfp_attach(void *upstream, struct sfp_bus *bus);\nvoid phy_sfp_detach(void *upstream, struct sfp_bus *bus);\nint phy_sfp_probe(struct phy_device *phydev,\n\t          const struct sfp_upstream_ops *ops);\nstruct phy_device *phy_attach(struct net_device *dev, const char *bus_id,\n\t\t\t      phy_interface_t interface);\nstruct phy_device *phy_find_first(struct mii_bus *bus);\nint phy_attach_direct(struct net_device *dev, struct phy_device *phydev,\n\t\t      u32 flags, phy_interface_t interface);\nint phy_connect_direct(struct net_device *dev, struct phy_device *phydev,\n\t\t       void (*handler)(struct net_device *),\n\t\t       phy_interface_t interface);\nstruct phy_device *phy_connect(struct net_device *dev, const char *bus_id,\n\t\t\t       void (*handler)(struct net_device *),\n\t\t\t       phy_interface_t interface);\nvoid phy_disconnect(struct phy_device *phydev);\nvoid phy_detach(struct phy_device *phydev);\nvoid phy_start(struct phy_device *phydev);\nvoid phy_stop(struct phy_device *phydev);\nint phy_config_aneg(struct phy_device *phydev);\nint phy_start_aneg(struct phy_device *phydev);\nint phy_aneg_done(struct phy_device *phydev);\nint phy_speed_down(struct phy_device *phydev, bool sync);\nint phy_speed_up(struct phy_device *phydev);\nbool phy_check_valid(int speed, int duplex, unsigned long *features);\n\nint phy_restart_aneg(struct phy_device *phydev);\nint phy_reset_after_clk_enable(struct phy_device *phydev);\n\n#if IS_ENABLED(CONFIG_PHYLIB)\nint phy_start_cable_test(struct phy_device *phydev,\n\t\t\t struct netlink_ext_ack *extack);\nint phy_start_cable_test_tdr(struct phy_device *phydev,\n\t\t\t     struct netlink_ext_ack *extack,\n\t\t\t     const struct phy_tdr_config *config);\n#else\nstatic inline\nint phy_start_cable_test(struct phy_device *phydev,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tNL_SET_ERR_MSG(extack, \"Kernel not compiled with PHYLIB support\");\n\treturn -EOPNOTSUPP;\n}\nstatic inline\nint phy_start_cable_test_tdr(struct phy_device *phydev,\n\t\t\t     struct netlink_ext_ack *extack,\n\t\t\t     const struct phy_tdr_config *config)\n{\n\tNL_SET_ERR_MSG(extack, \"Kernel not compiled with PHYLIB support\");\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nstatic inline void phy_device_reset(struct phy_device *phydev, int value)\n{\n\tmdio_device_reset(&phydev->mdio, value);\n}\n\n#define phydev_err(_phydev, format, args...)\t\\\n\tdev_err(&_phydev->mdio.dev, format, ##args)\n\n#define phydev_err_probe(_phydev, err, format, args...)\t\\\n\tdev_err_probe(&_phydev->mdio.dev, err, format, ##args)\n\n#define phydev_info(_phydev, format, args...)\t\\\n\tdev_info(&_phydev->mdio.dev, format, ##args)\n\n#define phydev_warn(_phydev, format, args...)\t\\\n\tdev_warn(&_phydev->mdio.dev, format, ##args)\n\n#define phydev_dbg(_phydev, format, args...)\t\\\n\tdev_dbg(&_phydev->mdio.dev, format, ##args)\n\nstatic inline const char *phydev_name(const struct phy_device *phydev)\n{\n\treturn dev_name(&phydev->mdio.dev);\n}\n\nstatic inline void phy_lock_mdio_bus(struct phy_device *phydev)\n{\n\tmutex_lock(&phydev->mdio.bus->mdio_lock);\n}\n\nstatic inline void phy_unlock_mdio_bus(struct phy_device *phydev)\n{\n\tmutex_unlock(&phydev->mdio.bus->mdio_lock);\n}\n\nvoid phy_attached_print(struct phy_device *phydev, const char *fmt, ...)\n\t__printf(2, 3);\nchar *phy_attached_info_irq(struct phy_device *phydev)\n\t__malloc;\nvoid phy_attached_info(struct phy_device *phydev);\n\n \nint genphy_read_abilities(struct phy_device *phydev);\nint genphy_setup_forced(struct phy_device *phydev);\nint genphy_restart_aneg(struct phy_device *phydev);\nint genphy_check_and_restart_aneg(struct phy_device *phydev, bool restart);\nint genphy_config_eee_advert(struct phy_device *phydev);\nint __genphy_config_aneg(struct phy_device *phydev, bool changed);\nint genphy_aneg_done(struct phy_device *phydev);\nint genphy_update_link(struct phy_device *phydev);\nint genphy_read_lpa(struct phy_device *phydev);\nint genphy_read_status_fixed(struct phy_device *phydev);\nint genphy_read_status(struct phy_device *phydev);\nint genphy_read_master_slave(struct phy_device *phydev);\nint genphy_suspend(struct phy_device *phydev);\nint genphy_resume(struct phy_device *phydev);\nint genphy_loopback(struct phy_device *phydev, bool enable);\nint genphy_soft_reset(struct phy_device *phydev);\nirqreturn_t genphy_handle_interrupt_no_ack(struct phy_device *phydev);\n\nstatic inline int genphy_config_aneg(struct phy_device *phydev)\n{\n\treturn __genphy_config_aneg(phydev, false);\n}\n\nstatic inline int genphy_no_config_intr(struct phy_device *phydev)\n{\n\treturn 0;\n}\nint genphy_read_mmd_unsupported(struct phy_device *phdev, int devad,\n\t\t\t\tu16 regnum);\nint genphy_write_mmd_unsupported(struct phy_device *phdev, int devnum,\n\t\t\t\t u16 regnum, u16 val);\n\n \nint genphy_c37_config_aneg(struct phy_device *phydev);\nint genphy_c37_read_status(struct phy_device *phydev);\n\n \nint genphy_c45_restart_aneg(struct phy_device *phydev);\nint genphy_c45_check_and_restart_aneg(struct phy_device *phydev, bool restart);\nint genphy_c45_aneg_done(struct phy_device *phydev);\nint genphy_c45_read_link(struct phy_device *phydev);\nint genphy_c45_read_lpa(struct phy_device *phydev);\nint genphy_c45_read_pma(struct phy_device *phydev);\nint genphy_c45_pma_setup_forced(struct phy_device *phydev);\nint genphy_c45_pma_baset1_setup_master_slave(struct phy_device *phydev);\nint genphy_c45_an_config_aneg(struct phy_device *phydev);\nint genphy_c45_an_disable_aneg(struct phy_device *phydev);\nint genphy_c45_read_mdix(struct phy_device *phydev);\nint genphy_c45_pma_read_abilities(struct phy_device *phydev);\nint genphy_c45_pma_baset1_read_abilities(struct phy_device *phydev);\nint genphy_c45_read_eee_abilities(struct phy_device *phydev);\nint genphy_c45_pma_baset1_read_master_slave(struct phy_device *phydev);\nint genphy_c45_read_status(struct phy_device *phydev);\nint genphy_c45_baset1_read_status(struct phy_device *phydev);\nint genphy_c45_config_aneg(struct phy_device *phydev);\nint genphy_c45_loopback(struct phy_device *phydev, bool enable);\nint genphy_c45_pma_resume(struct phy_device *phydev);\nint genphy_c45_pma_suspend(struct phy_device *phydev);\nint genphy_c45_fast_retrain(struct phy_device *phydev, bool enable);\nint genphy_c45_plca_get_cfg(struct phy_device *phydev,\n\t\t\t    struct phy_plca_cfg *plca_cfg);\nint genphy_c45_plca_set_cfg(struct phy_device *phydev,\n\t\t\t    const struct phy_plca_cfg *plca_cfg);\nint genphy_c45_plca_get_status(struct phy_device *phydev,\n\t\t\t       struct phy_plca_status *plca_st);\nint genphy_c45_eee_is_active(struct phy_device *phydev, unsigned long *adv,\n\t\t\t     unsigned long *lp, bool *is_enabled);\nint genphy_c45_ethtool_get_eee(struct phy_device *phydev,\n\t\t\t       struct ethtool_eee *data);\nint genphy_c45_ethtool_set_eee(struct phy_device *phydev,\n\t\t\t       struct ethtool_eee *data);\nint genphy_c45_write_eee_adv(struct phy_device *phydev, unsigned long *adv);\nint genphy_c45_an_config_eee_aneg(struct phy_device *phydev);\nint genphy_c45_read_eee_adv(struct phy_device *phydev, unsigned long *adv);\n\n \nextern struct phy_driver genphy_c45_driver;\n\n \nint gen10g_config_aneg(struct phy_device *phydev);\n\nstatic inline int phy_read_status(struct phy_device *phydev)\n{\n\tif (!phydev->drv)\n\t\treturn -EIO;\n\n\tif (phydev->drv->read_status)\n\t\treturn phydev->drv->read_status(phydev);\n\telse\n\t\treturn genphy_read_status(phydev);\n}\n\nvoid phy_driver_unregister(struct phy_driver *drv);\nvoid phy_drivers_unregister(struct phy_driver *drv, int n);\nint phy_driver_register(struct phy_driver *new_driver, struct module *owner);\nint phy_drivers_register(struct phy_driver *new_driver, int n,\n\t\t\t struct module *owner);\nvoid phy_error(struct phy_device *phydev);\nvoid phy_state_machine(struct work_struct *work);\nvoid phy_queue_state_machine(struct phy_device *phydev, unsigned long jiffies);\nvoid phy_trigger_machine(struct phy_device *phydev);\nvoid phy_mac_interrupt(struct phy_device *phydev);\nvoid phy_start_machine(struct phy_device *phydev);\nvoid phy_stop_machine(struct phy_device *phydev);\nvoid phy_ethtool_ksettings_get(struct phy_device *phydev,\n\t\t\t       struct ethtool_link_ksettings *cmd);\nint phy_ethtool_ksettings_set(struct phy_device *phydev,\n\t\t\t      const struct ethtool_link_ksettings *cmd);\nint phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);\nint phy_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);\nint phy_do_ioctl_running(struct net_device *dev, struct ifreq *ifr, int cmd);\nint phy_disable_interrupts(struct phy_device *phydev);\nvoid phy_request_interrupt(struct phy_device *phydev);\nvoid phy_free_interrupt(struct phy_device *phydev);\nvoid phy_print_status(struct phy_device *phydev);\nint phy_get_rate_matching(struct phy_device *phydev,\n\t\t\t    phy_interface_t iface);\nvoid phy_set_max_speed(struct phy_device *phydev, u32 max_speed);\nvoid phy_remove_link_mode(struct phy_device *phydev, u32 link_mode);\nvoid phy_advertise_supported(struct phy_device *phydev);\nvoid phy_support_sym_pause(struct phy_device *phydev);\nvoid phy_support_asym_pause(struct phy_device *phydev);\nvoid phy_set_sym_pause(struct phy_device *phydev, bool rx, bool tx,\n\t\t       bool autoneg);\nvoid phy_set_asym_pause(struct phy_device *phydev, bool rx, bool tx);\nbool phy_validate_pause(struct phy_device *phydev,\n\t\t\tstruct ethtool_pauseparam *pp);\nvoid phy_get_pause(struct phy_device *phydev, bool *tx_pause, bool *rx_pause);\n\ns32 phy_get_internal_delay(struct phy_device *phydev, struct device *dev,\n\t\t\t   const int *delay_values, int size, bool is_rx);\n\nvoid phy_resolve_pause(unsigned long *local_adv, unsigned long *partner_adv,\n\t\t       bool *tx_pause, bool *rx_pause);\n\nint phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,\n\t\t       int (*run)(struct phy_device *));\nint phy_register_fixup_for_id(const char *bus_id,\n\t\t\t      int (*run)(struct phy_device *));\nint phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,\n\t\t\t       int (*run)(struct phy_device *));\n\nint phy_unregister_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask);\nint phy_unregister_fixup_for_id(const char *bus_id);\nint phy_unregister_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask);\n\nint phy_init_eee(struct phy_device *phydev, bool clk_stop_enable);\nint phy_get_eee_err(struct phy_device *phydev);\nint phy_ethtool_set_eee(struct phy_device *phydev, struct ethtool_eee *data);\nint phy_ethtool_get_eee(struct phy_device *phydev, struct ethtool_eee *data);\nint phy_ethtool_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol);\nvoid phy_ethtool_get_wol(struct phy_device *phydev,\n\t\t\t struct ethtool_wolinfo *wol);\nint phy_ethtool_get_link_ksettings(struct net_device *ndev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd);\nint phy_ethtool_set_link_ksettings(struct net_device *ndev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd);\nint phy_ethtool_nway_reset(struct net_device *ndev);\nint phy_package_join(struct phy_device *phydev, int addr, size_t priv_size);\nvoid phy_package_leave(struct phy_device *phydev);\nint devm_phy_package_join(struct device *dev, struct phy_device *phydev,\n\t\t\t  int addr, size_t priv_size);\n\nint __init mdio_bus_init(void);\nvoid mdio_bus_exit(void);\n\nint phy_ethtool_get_strings(struct phy_device *phydev, u8 *data);\nint phy_ethtool_get_sset_count(struct phy_device *phydev);\nint phy_ethtool_get_stats(struct phy_device *phydev,\n\t\t\t  struct ethtool_stats *stats, u64 *data);\nint phy_ethtool_get_plca_cfg(struct phy_device *phydev,\n\t\t\t     struct phy_plca_cfg *plca_cfg);\nint phy_ethtool_set_plca_cfg(struct phy_device *phydev,\n\t\t\t     const struct phy_plca_cfg *plca_cfg,\n\t\t\t     struct netlink_ext_ack *extack);\nint phy_ethtool_get_plca_status(struct phy_device *phydev,\n\t\t\t\tstruct phy_plca_status *plca_st);\n\nint __phy_hwtstamp_get(struct phy_device *phydev,\n\t\t       struct kernel_hwtstamp_config *config);\nint __phy_hwtstamp_set(struct phy_device *phydev,\n\t\t       struct kernel_hwtstamp_config *config,\n\t\t       struct netlink_ext_ack *extack);\n\nstatic inline int phy_package_read(struct phy_device *phydev, u32 regnum)\n{\n\tstruct phy_package_shared *shared = phydev->shared;\n\n\tif (!shared)\n\t\treturn -EIO;\n\n\treturn mdiobus_read(phydev->mdio.bus, shared->addr, regnum);\n}\n\nstatic inline int __phy_package_read(struct phy_device *phydev, u32 regnum)\n{\n\tstruct phy_package_shared *shared = phydev->shared;\n\n\tif (!shared)\n\t\treturn -EIO;\n\n\treturn __mdiobus_read(phydev->mdio.bus, shared->addr, regnum);\n}\n\nstatic inline int phy_package_write(struct phy_device *phydev,\n\t\t\t\t    u32 regnum, u16 val)\n{\n\tstruct phy_package_shared *shared = phydev->shared;\n\n\tif (!shared)\n\t\treturn -EIO;\n\n\treturn mdiobus_write(phydev->mdio.bus, shared->addr, regnum, val);\n}\n\nstatic inline int __phy_package_write(struct phy_device *phydev,\n\t\t\t\t      u32 regnum, u16 val)\n{\n\tstruct phy_package_shared *shared = phydev->shared;\n\n\tif (!shared)\n\t\treturn -EIO;\n\n\treturn __mdiobus_write(phydev->mdio.bus, shared->addr, regnum, val);\n}\n\nstatic inline bool __phy_package_set_once(struct phy_device *phydev,\n\t\t\t\t\t  unsigned int b)\n{\n\tstruct phy_package_shared *shared = phydev->shared;\n\n\tif (!shared)\n\t\treturn false;\n\n\treturn !test_and_set_bit(b, &shared->flags);\n}\n\nstatic inline bool phy_package_init_once(struct phy_device *phydev)\n{\n\treturn __phy_package_set_once(phydev, PHY_SHARED_F_INIT_DONE);\n}\n\nstatic inline bool phy_package_probe_once(struct phy_device *phydev)\n{\n\treturn __phy_package_set_once(phydev, PHY_SHARED_F_PROBE_DONE);\n}\n\nextern struct bus_type mdio_bus_type;\n\nstruct mdio_board_info {\n\tconst char\t*bus_id;\n\tchar\t\tmodalias[MDIO_NAME_SIZE];\n\tint\t\tmdio_addr;\n\tconst void\t*platform_data;\n};\n\n#if IS_ENABLED(CONFIG_MDIO_DEVICE)\nint mdiobus_register_board_info(const struct mdio_board_info *info,\n\t\t\t\tunsigned int n);\n#else\nstatic inline int mdiobus_register_board_info(const struct mdio_board_info *i,\n\t\t\t\t\t      unsigned int n)\n{\n\treturn 0;\n}\n#endif\n\n\n \n#define phy_module_driver(__phy_drivers, __count)\t\t\t\\\nstatic int __init phy_module_init(void)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn phy_drivers_register(__phy_drivers, __count, THIS_MODULE); \\\n}\t\t\t\t\t\t\t\t\t\\\nmodule_init(phy_module_init);\t\t\t\t\t\t\\\nstatic void __exit phy_module_exit(void)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tphy_drivers_unregister(__phy_drivers, __count);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nmodule_exit(phy_module_exit)\n\n#define module_phy_driver(__phy_drivers)\t\t\t\t\\\n\tphy_module_driver(__phy_drivers, ARRAY_SIZE(__phy_drivers))\n\nbool phy_driver_is_genphy(struct phy_device *phydev);\nbool phy_driver_is_genphy_10g(struct phy_device *phydev);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}