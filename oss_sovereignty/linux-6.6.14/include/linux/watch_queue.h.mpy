{
  "module_name": "watch_queue.h",
  "hash_id": "d06d09aacdf89e86c7bad901f69843ccc7c254a59630e87272b42c843b116a45",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/watch_queue.h",
  "human_readable_source": "\n \n\n#ifndef _LINUX_WATCH_QUEUE_H\n#define _LINUX_WATCH_QUEUE_H\n\n#include <uapi/linux/watch_queue.h>\n#include <linux/kref.h>\n#include <linux/rcupdate.h>\n\n#ifdef CONFIG_WATCH_QUEUE\n\nstruct cred;\n\nstruct watch_type_filter {\n\tenum watch_notification_type type;\n\t__u32\t\tsubtype_filter[1];\t \n\t__u32\t\tinfo_filter;\t\t \n\t__u32\t\tinfo_mask;\t\t \n};\n\nstruct watch_filter {\n\tunion {\n\t\tstruct rcu_head\trcu;\n\t\t \n\t\tDECLARE_BITMAP(type_filter, WATCH_TYPE__NR);\n\t};\n\tu32\t\t\tnr_filters;\t \n\tstruct watch_type_filter filters[];\n};\n\nstruct watch_queue {\n\tstruct rcu_head\t\trcu;\n\tstruct watch_filter __rcu *filter;\n\tstruct pipe_inode_info\t*pipe;\t\t \n\tstruct hlist_head\twatches;\t \n\tstruct page\t\t**notes;\t \n\tunsigned long\t\t*notes_bitmap;\t \n\tstruct kref\t\tusage;\t\t \n\tspinlock_t\t\tlock;\n\tunsigned int\t\tnr_notes;\t \n\tunsigned int\t\tnr_pages;\t \n};\n\n \nstruct watch {\n\tunion {\n\t\tstruct rcu_head\trcu;\n\t\tu32\t\tinfo_id;\t \n\t};\n\tstruct watch_queue __rcu *queue;\t \n\tstruct hlist_node\tqueue_node;\t \n\tstruct watch_list __rcu\t*watch_list;\n\tstruct hlist_node\tlist_node;\t \n\tconst struct cred\t*cred;\t\t \n\tvoid\t\t\t*private;\t \n\tu64\t\t\tid;\t\t \n\tstruct kref\t\tusage;\t\t \n};\n\n \nstruct watch_list {\n\tstruct rcu_head\t\trcu;\n\tstruct hlist_head\twatchers;\n\tvoid (*release_watch)(struct watch *);\n\tspinlock_t\t\tlock;\n};\n\nextern void __post_watch_notification(struct watch_list *,\n\t\t\t\t      struct watch_notification *,\n\t\t\t\t      const struct cred *,\n\t\t\t\t      u64);\nextern struct watch_queue *get_watch_queue(int);\nextern void put_watch_queue(struct watch_queue *);\nextern void init_watch(struct watch *, struct watch_queue *);\nextern int add_watch_to_object(struct watch *, struct watch_list *);\nextern int remove_watch_from_object(struct watch_list *, struct watch_queue *, u64, bool);\nextern long watch_queue_set_size(struct pipe_inode_info *, unsigned int);\nextern long watch_queue_set_filter(struct pipe_inode_info *,\n\t\t\t\t   struct watch_notification_filter __user *);\nextern int watch_queue_init(struct pipe_inode_info *);\nextern void watch_queue_clear(struct watch_queue *);\n\nstatic inline void init_watch_list(struct watch_list *wlist,\n\t\t\t\t   void (*release_watch)(struct watch *))\n{\n\tINIT_HLIST_HEAD(&wlist->watchers);\n\tspin_lock_init(&wlist->lock);\n\twlist->release_watch = release_watch;\n}\n\nstatic inline void post_watch_notification(struct watch_list *wlist,\n\t\t\t\t\t   struct watch_notification *n,\n\t\t\t\t\t   const struct cred *cred,\n\t\t\t\t\t   u64 id)\n{\n\tif (unlikely(wlist))\n\t\t__post_watch_notification(wlist, n, cred, id);\n}\n\nstatic inline void remove_watch_list(struct watch_list *wlist, u64 id)\n{\n\tif (wlist) {\n\t\tremove_watch_from_object(wlist, NULL, id, true);\n\t\tkfree_rcu(wlist, rcu);\n\t}\n}\n\n \n#define watch_sizeof(STRUCT) (sizeof(STRUCT) << WATCH_INFO_LENGTH__SHIFT)\n\n#else\nstatic inline int watch_queue_init(struct pipe_inode_info *pipe)\n{\n\treturn -ENOPKG;\n}\n\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}