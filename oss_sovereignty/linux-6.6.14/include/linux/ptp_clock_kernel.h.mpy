{
  "module_name": "ptp_clock_kernel.h",
  "hash_id": "e4ccbaed9a1f615363a5a4ce773c622935d46c50dea793d09767fd0906bbf162",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ptp_clock_kernel.h",
  "human_readable_source": " \n \n\n#ifndef _PTP_CLOCK_KERNEL_H_\n#define _PTP_CLOCK_KERNEL_H_\n\n#include <linux/device.h>\n#include <linux/pps_kernel.h>\n#include <linux/ptp_clock.h>\n#include <linux/timecounter.h>\n#include <linux/skbuff.h>\n\n#define PTP_CLOCK_NAME_LEN\t32\n \n\nstruct ptp_clock_request {\n\tenum {\n\t\tPTP_CLK_REQ_EXTTS,\n\t\tPTP_CLK_REQ_PEROUT,\n\t\tPTP_CLK_REQ_PPS,\n\t} type;\n\tunion {\n\t\tstruct ptp_extts_request extts;\n\t\tstruct ptp_perout_request perout;\n\t};\n};\n\nstruct system_device_crosststamp;\n\n \nstruct ptp_system_timestamp {\n\tstruct timespec64 pre_ts;\n\tstruct timespec64 post_ts;\n};\n\n \n\nstruct ptp_clock_info {\n\tstruct module *owner;\n\tchar name[PTP_CLOCK_NAME_LEN];\n\ts32 max_adj;\n\tint n_alarm;\n\tint n_ext_ts;\n\tint n_per_out;\n\tint n_pins;\n\tint pps;\n\tstruct ptp_pin_desc *pin_config;\n\tint (*adjfine)(struct ptp_clock_info *ptp, long scaled_ppm);\n\tint (*adjphase)(struct ptp_clock_info *ptp, s32 phase);\n\ts32 (*getmaxphase)(struct ptp_clock_info *ptp);\n\tint (*adjtime)(struct ptp_clock_info *ptp, s64 delta);\n\tint (*gettime64)(struct ptp_clock_info *ptp, struct timespec64 *ts);\n\tint (*gettimex64)(struct ptp_clock_info *ptp, struct timespec64 *ts,\n\t\t\t  struct ptp_system_timestamp *sts);\n\tint (*getcrosststamp)(struct ptp_clock_info *ptp,\n\t\t\t      struct system_device_crosststamp *cts);\n\tint (*settime64)(struct ptp_clock_info *p, const struct timespec64 *ts);\n\tint (*getcycles64)(struct ptp_clock_info *ptp, struct timespec64 *ts);\n\tint (*getcyclesx64)(struct ptp_clock_info *ptp, struct timespec64 *ts,\n\t\t\t    struct ptp_system_timestamp *sts);\n\tint (*getcrosscycles)(struct ptp_clock_info *ptp,\n\t\t\t      struct system_device_crosststamp *cts);\n\tint (*enable)(struct ptp_clock_info *ptp,\n\t\t      struct ptp_clock_request *request, int on);\n\tint (*verify)(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t      enum ptp_pin_function func, unsigned int chan);\n\tlong (*do_aux_work)(struct ptp_clock_info *ptp);\n};\n\nstruct ptp_clock;\n\nenum ptp_clock_events {\n\tPTP_CLOCK_ALARM,\n\tPTP_CLOCK_EXTTS,\n\tPTP_CLOCK_PPS,\n\tPTP_CLOCK_PPSUSR,\n};\n\n \n\nstruct ptp_clock_event {\n\tint type;\n\tint index;\n\tunion {\n\t\tu64 timestamp;\n\t\tstruct pps_event_time pps_times;\n\t};\n};\n\n \nstatic inline long scaled_ppm_to_ppb(long ppm)\n{\n\t \n\ts64 ppb = 1 + ppm;\n\n\tppb *= 125;\n\tppb >>= 13;\n\treturn (long)ppb;\n}\n\n \nstatic inline bool diff_by_scaled_ppm(u64 base, long scaled_ppm, u64 *diff)\n{\n\tbool negative = false;\n\n\tif (scaled_ppm < 0) {\n\t\tnegative = true;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\n\t*diff = mul_u64_u64_div_u64(base, (u64)scaled_ppm, 1000000ULL << 16);\n\n\treturn negative;\n}\n\n \nstatic inline u64 adjust_by_scaled_ppm(u64 base, long scaled_ppm)\n{\n\tu64 diff;\n\n\tif (diff_by_scaled_ppm(base, scaled_ppm, &diff))\n\t\treturn base - diff;\n\n\treturn base + diff;\n}\n\n#if IS_ENABLED(CONFIG_PTP_1588_CLOCK)\n\n \n\nextern struct ptp_clock *ptp_clock_register(struct ptp_clock_info *info,\n\t\t\t\t\t    struct device *parent);\n\n \n\nextern int ptp_clock_unregister(struct ptp_clock *ptp);\n\n \n\nextern void ptp_clock_event(struct ptp_clock *ptp,\n\t\t\t    struct ptp_clock_event *event);\n\n \n\nextern int ptp_clock_index(struct ptp_clock *ptp);\n\n \n\nint ptp_find_pin(struct ptp_clock *ptp,\n\t\t enum ptp_pin_function func, unsigned int chan);\n\n \n\nint ptp_find_pin_unlocked(struct ptp_clock *ptp,\n\t\t\t  enum ptp_pin_function func, unsigned int chan);\n\n \n\nint ptp_schedule_worker(struct ptp_clock *ptp, unsigned long delay);\n\n \nvoid ptp_cancel_worker_sync(struct ptp_clock *ptp);\n\n#else\nstatic inline struct ptp_clock *ptp_clock_register(struct ptp_clock_info *info,\n\t\t\t\t\t\t   struct device *parent)\n{ return NULL; }\nstatic inline int ptp_clock_unregister(struct ptp_clock *ptp)\n{ return 0; }\nstatic inline void ptp_clock_event(struct ptp_clock *ptp,\n\t\t\t\t   struct ptp_clock_event *event)\n{ }\nstatic inline int ptp_clock_index(struct ptp_clock *ptp)\n{ return -1; }\nstatic inline int ptp_find_pin(struct ptp_clock *ptp,\n\t\t\t       enum ptp_pin_function func, unsigned int chan)\n{ return -1; }\nstatic inline int ptp_find_pin_unlocked(struct ptp_clock *ptp,\n\t\t\t\t\tenum ptp_pin_function func,\n\t\t\t\t\tunsigned int chan)\n{ return -1; }\nstatic inline int ptp_schedule_worker(struct ptp_clock *ptp,\n\t\t\t\t      unsigned long delay)\n{ return -EOPNOTSUPP; }\nstatic inline void ptp_cancel_worker_sync(struct ptp_clock *ptp)\n{ }\n#endif\n\n#if IS_BUILTIN(CONFIG_PTP_1588_CLOCK)\n \n\n \nint ptp_get_vclocks_index(int pclock_index, int **vclock_index);\n\n \nktime_t ptp_convert_timestamp(const ktime_t *hwtstamp, int vclock_index);\n#else\nstatic inline int ptp_get_vclocks_index(int pclock_index, int **vclock_index)\n{ return 0; }\nstatic inline ktime_t ptp_convert_timestamp(const ktime_t *hwtstamp,\n\t\t\t\t\t    int vclock_index)\n{ return 0; }\n\n#endif\n\nstatic inline void ptp_read_system_prets(struct ptp_system_timestamp *sts)\n{\n\tif (sts)\n\t\tktime_get_real_ts64(&sts->pre_ts);\n}\n\nstatic inline void ptp_read_system_postts(struct ptp_system_timestamp *sts)\n{\n\tif (sts)\n\t\tktime_get_real_ts64(&sts->post_ts);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}