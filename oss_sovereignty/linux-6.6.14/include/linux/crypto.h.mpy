{
  "module_name": "crypto.h",
  "hash_id": "d3a5490a2c965f81fe6e12f39727d4c954891f851a7b32a1fed4a3f1776fb0d2",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/crypto.h",
  "human_readable_source": " \n \n#ifndef _LINUX_CRYPTO_H\n#define _LINUX_CRYPTO_H\n\n#include <linux/completion.h>\n#include <linux/refcount.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n \n#define CRYPTO_ALG_TYPE_MASK\t\t0x0000000f\n#define CRYPTO_ALG_TYPE_CIPHER\t\t0x00000001\n#define CRYPTO_ALG_TYPE_COMPRESS\t0x00000002\n#define CRYPTO_ALG_TYPE_AEAD\t\t0x00000003\n#define CRYPTO_ALG_TYPE_SKCIPHER\t0x00000005\n#define CRYPTO_ALG_TYPE_AKCIPHER\t0x00000006\n#define CRYPTO_ALG_TYPE_SIG\t\t0x00000007\n#define CRYPTO_ALG_TYPE_KPP\t\t0x00000008\n#define CRYPTO_ALG_TYPE_ACOMPRESS\t0x0000000a\n#define CRYPTO_ALG_TYPE_SCOMPRESS\t0x0000000b\n#define CRYPTO_ALG_TYPE_RNG\t\t0x0000000c\n#define CRYPTO_ALG_TYPE_HASH\t\t0x0000000e\n#define CRYPTO_ALG_TYPE_SHASH\t\t0x0000000e\n#define CRYPTO_ALG_TYPE_AHASH\t\t0x0000000f\n\n#define CRYPTO_ALG_TYPE_HASH_MASK\t0x0000000e\n#define CRYPTO_ALG_TYPE_AHASH_MASK\t0x0000000e\n#define CRYPTO_ALG_TYPE_ACOMPRESS_MASK\t0x0000000e\n\n#define CRYPTO_ALG_LARVAL\t\t0x00000010\n#define CRYPTO_ALG_DEAD\t\t\t0x00000020\n#define CRYPTO_ALG_DYING\t\t0x00000040\n#define CRYPTO_ALG_ASYNC\t\t0x00000080\n\n \n#define CRYPTO_ALG_NEED_FALLBACK\t0x00000100\n\n \n\n#define CRYPTO_ALG_TESTED\t\t0x00000400\n\n \n#define CRYPTO_ALG_INSTANCE\t\t0x00000800\n\n \n#define CRYPTO_ALG_KERN_DRIVER_ONLY\t0x00001000\n\n \n#define CRYPTO_ALG_INTERNAL\t\t0x00002000\n\n \n#define CRYPTO_ALG_OPTIONAL_KEY\t\t0x00004000\n\n \n#define CRYPTO_NOLOAD\t\t\t0x00008000\n\n \n#define CRYPTO_ALG_ALLOCATES_MEMORY\t0x00010000\n\n \n#define CRYPTO_ALG_FIPS_INTERNAL\t0x00020000\n\n \n#define CRYPTO_TFM_NEED_KEY\t\t0x00000001\n\n#define CRYPTO_TFM_REQ_MASK\t\t0x000fff00\n#define CRYPTO_TFM_REQ_FORBID_WEAK_KEYS\t0x00000100\n#define CRYPTO_TFM_REQ_MAY_SLEEP\t0x00000200\n#define CRYPTO_TFM_REQ_MAY_BACKLOG\t0x00000400\n\n \n#define CRYPTO_MAX_ALG_NAME\t\t128\n\n \n#define CRYPTO_MINALIGN ARCH_KMALLOC_MINALIGN\n\n#define CRYPTO_MINALIGN_ATTR __attribute__ ((__aligned__(CRYPTO_MINALIGN)))\n\nstruct crypto_tfm;\nstruct crypto_type;\nstruct module;\n\ntypedef void (*crypto_completion_t)(void *req, int err);\n\n \n\nstruct crypto_async_request {\n\tstruct list_head list;\n\tcrypto_completion_t complete;\n\tvoid *data;\n\tstruct crypto_tfm *tfm;\n\n\tu32 flags;\n};\n\n \n\n \nstruct cipher_alg {\n\tunsigned int cia_min_keysize;\n\tunsigned int cia_max_keysize;\n\tint (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key,\n\t                  unsigned int keylen);\n\tvoid (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n\tvoid (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);\n};\n\n \nstruct compress_alg {\n\tint (*coa_compress)(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t    unsigned int slen, u8 *dst, unsigned int *dlen);\n\tint (*coa_decompress)(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t      unsigned int slen, u8 *dst, unsigned int *dlen);\n};\n\n#define cra_cipher\tcra_u.cipher\n#define cra_compress\tcra_u.compress\n\n \nstruct crypto_alg {\n\tstruct list_head cra_list;\n\tstruct list_head cra_users;\n\n\tu32 cra_flags;\n\tunsigned int cra_blocksize;\n\tunsigned int cra_ctxsize;\n\tunsigned int cra_alignmask;\n\n\tint cra_priority;\n\trefcount_t cra_refcnt;\n\n\tchar cra_name[CRYPTO_MAX_ALG_NAME];\n\tchar cra_driver_name[CRYPTO_MAX_ALG_NAME];\n\n\tconst struct crypto_type *cra_type;\n\n\tunion {\n\t\tstruct cipher_alg cipher;\n\t\tstruct compress_alg compress;\n\t} cra_u;\n\n\tint (*cra_init)(struct crypto_tfm *tfm);\n\tvoid (*cra_exit)(struct crypto_tfm *tfm);\n\tvoid (*cra_destroy)(struct crypto_alg *alg);\n\t\n\tstruct module *cra_module;\n} CRYPTO_MINALIGN_ATTR;\n\n \nstruct crypto_wait {\n\tstruct completion completion;\n\tint err;\n};\n\n \n#define DECLARE_CRYPTO_WAIT(_wait) \\\n\tstruct crypto_wait _wait = { \\\n\t\tCOMPLETION_INITIALIZER_ONSTACK((_wait).completion), 0 }\n\n \nvoid crypto_req_done(void *req, int err);\n\nstatic inline int crypto_wait_req(int err, struct crypto_wait *wait)\n{\n\tswitch (err) {\n\tcase -EINPROGRESS:\n\tcase -EBUSY:\n\t\twait_for_completion(&wait->completion);\n\t\treinit_completion(&wait->completion);\n\t\terr = wait->err;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic inline void crypto_init_wait(struct crypto_wait *wait)\n{\n\tinit_completion(&wait->completion);\n}\n\n \nint crypto_has_alg(const char *name, u32 type, u32 mask);\n\n \n\nstruct crypto_tfm {\n\trefcount_t refcnt;\n\n\tu32 crt_flags;\n\n\tint node;\n\t\n\tvoid (*exit)(struct crypto_tfm *tfm);\n\t\n\tstruct crypto_alg *__crt_alg;\n\n\tvoid *__crt_ctx[] CRYPTO_MINALIGN_ATTR;\n};\n\nstruct crypto_comp {\n\tstruct crypto_tfm base;\n};\n\n \n \nstruct crypto_tfm *crypto_alloc_base(const char *alg_name, u32 type, u32 mask);\nvoid crypto_destroy_tfm(void *mem, struct crypto_tfm *tfm);\n\nstatic inline void crypto_free_tfm(struct crypto_tfm *tfm)\n{\n\treturn crypto_destroy_tfm(tfm, tfm);\n}\n\n \nstatic inline const char *crypto_tfm_alg_name(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_name;\n}\n\nstatic inline const char *crypto_tfm_alg_driver_name(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_driver_name;\n}\n\nstatic inline unsigned int crypto_tfm_alg_blocksize(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_blocksize;\n}\n\nstatic inline unsigned int crypto_tfm_alg_alignmask(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_alignmask;\n}\n\nstatic inline u32 crypto_tfm_get_flags(struct crypto_tfm *tfm)\n{\n\treturn tfm->crt_flags;\n}\n\nstatic inline void crypto_tfm_set_flags(struct crypto_tfm *tfm, u32 flags)\n{\n\ttfm->crt_flags |= flags;\n}\n\nstatic inline void crypto_tfm_clear_flags(struct crypto_tfm *tfm, u32 flags)\n{\n\ttfm->crt_flags &= ~flags;\n}\n\nstatic inline unsigned int crypto_tfm_ctx_alignment(void)\n{\n\tstruct crypto_tfm *tfm;\n\treturn __alignof__(tfm->__crt_ctx);\n}\n\nstatic inline struct crypto_comp *__crypto_comp_cast(struct crypto_tfm *tfm)\n{\n\treturn (struct crypto_comp *)tfm;\n}\n\nstatic inline struct crypto_comp *crypto_alloc_comp(const char *alg_name,\n\t\t\t\t\t\t    u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_COMPRESS;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn __crypto_comp_cast(crypto_alloc_base(alg_name, type, mask));\n}\n\nstatic inline struct crypto_tfm *crypto_comp_tfm(struct crypto_comp *tfm)\n{\n\treturn &tfm->base;\n}\n\nstatic inline void crypto_free_comp(struct crypto_comp *tfm)\n{\n\tcrypto_free_tfm(crypto_comp_tfm(tfm));\n}\n\nstatic inline int crypto_has_comp(const char *alg_name, u32 type, u32 mask)\n{\n\ttype &= ~CRYPTO_ALG_TYPE_MASK;\n\ttype |= CRYPTO_ALG_TYPE_COMPRESS;\n\tmask |= CRYPTO_ALG_TYPE_MASK;\n\n\treturn crypto_has_alg(alg_name, type, mask);\n}\n\nstatic inline const char *crypto_comp_name(struct crypto_comp *tfm)\n{\n\treturn crypto_tfm_alg_name(crypto_comp_tfm(tfm));\n}\n\nint crypto_comp_compress(struct crypto_comp *tfm,\n\t\t\t const u8 *src, unsigned int slen,\n\t\t\t u8 *dst, unsigned int *dlen);\n\nint crypto_comp_decompress(struct crypto_comp *tfm,\n\t\t\t   const u8 *src, unsigned int slen,\n\t\t\t   u8 *dst, unsigned int *dlen);\n\n#endif\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}