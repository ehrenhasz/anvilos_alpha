{
  "module_name": "of_mdio.h",
  "hash_id": "8a8be088e02ffedad369b859d9e3a35a25495d557c112cc12e464d6d00e9e61e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/of_mdio.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_OF_MDIO_H\n#define __LINUX_OF_MDIO_H\n\n#include <linux/device.h>\n#include <linux/phy.h>\n#include <linux/of.h>\n\n#if IS_ENABLED(CONFIG_OF_MDIO)\nbool of_mdiobus_child_is_phy(struct device_node *child);\nint __of_mdiobus_register(struct mii_bus *mdio, struct device_node *np,\n\t\t\t  struct module *owner);\n\nstatic inline int of_mdiobus_register(struct mii_bus *mdio,\n\t\t\t\t      struct device_node *np)\n{\n\treturn __of_mdiobus_register(mdio, np, THIS_MODULE);\n}\n\nint __devm_of_mdiobus_register(struct device *dev, struct mii_bus *mdio,\n\t\t\t       struct device_node *np, struct module *owner);\n\nstatic inline int devm_of_mdiobus_register(struct device *dev,\n\t\t\t\t\t   struct mii_bus *mdio,\n\t\t\t\t\t   struct device_node *np)\n{\n\treturn __devm_of_mdiobus_register(dev, mdio, np, THIS_MODULE);\n}\n\nstruct mdio_device *of_mdio_find_device(struct device_node *np);\nstruct phy_device *of_phy_find_device(struct device_node *phy_np);\nstruct phy_device *\nof_phy_connect(struct net_device *dev, struct device_node *phy_np,\n\t       void (*hndlr)(struct net_device *), u32 flags,\n\t       phy_interface_t iface);\nstruct phy_device *\nof_phy_get_and_connect(struct net_device *dev, struct device_node *np,\n\t\t       void (*hndlr)(struct net_device *));\n\nstruct mii_bus *of_mdio_find_bus(struct device_node *mdio_np);\nint of_phy_register_fixed_link(struct device_node *np);\nvoid of_phy_deregister_fixed_link(struct device_node *np);\nbool of_phy_is_fixed_link(struct device_node *np);\nint of_mdiobus_phy_device_register(struct mii_bus *mdio, struct phy_device *phy,\n\t\t\t\t   struct device_node *child, u32 addr);\n\nstatic inline int of_mdio_parse_addr(struct device *dev,\n\t\t\t\t     const struct device_node *np)\n{\n\tu32 addr;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"reg\", &addr);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s has invalid PHY address\\n\", np->full_name);\n\t\treturn ret;\n\t}\n\n\t \n\tif (addr >= PHY_MAX_ADDR) {\n\t\tdev_err(dev, \"%s PHY address %i is too large\\n\",\n\t\t\tnp->full_name, addr);\n\t\treturn -EINVAL;\n\t}\n\n\treturn addr;\n}\n\n#else  \nstatic inline bool of_mdiobus_child_is_phy(struct device_node *child)\n{\n\treturn false;\n}\n\nstatic inline int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)\n{\n\t \n\n\treturn mdiobus_register(mdio);\n}\n\nstatic inline int devm_of_mdiobus_register(struct device *dev,\n\t\t\t\t\t   struct mii_bus *mdio,\n\t\t\t\t\t   struct device_node *np)\n{\n\treturn devm_mdiobus_register(dev, mdio);\n}\n\nstatic inline struct mdio_device *of_mdio_find_device(struct device_node *np)\n{\n\treturn NULL;\n}\n\nstatic inline struct phy_device *of_phy_find_device(struct device_node *phy_np)\n{\n\treturn NULL;\n}\n\nstatic inline struct phy_device *of_phy_connect(struct net_device *dev,\n\t\t\t\t\t\tstruct device_node *phy_np,\n\t\t\t\t\t\tvoid (*hndlr)(struct net_device *),\n\t\t\t\t\t\tu32 flags, phy_interface_t iface)\n{\n\treturn NULL;\n}\n\nstatic inline struct phy_device *\nof_phy_get_and_connect(struct net_device *dev, struct device_node *np,\n\t\t       void (*hndlr)(struct net_device *))\n{\n\treturn NULL;\n}\n\nstatic inline struct mii_bus *of_mdio_find_bus(struct device_node *mdio_np)\n{\n\treturn NULL;\n}\n\nstatic inline int of_mdio_parse_addr(struct device *dev,\n\t\t\t\t     const struct device_node *np)\n{\n\treturn -ENOSYS;\n}\nstatic inline int of_phy_register_fixed_link(struct device_node *np)\n{\n\treturn -ENOSYS;\n}\nstatic inline void of_phy_deregister_fixed_link(struct device_node *np)\n{\n}\nstatic inline bool of_phy_is_fixed_link(struct device_node *np)\n{\n\treturn false;\n}\n\nstatic inline int of_mdiobus_phy_device_register(struct mii_bus *mdio,\n\t\t\t\t\t    struct phy_device *phy,\n\t\t\t\t\t    struct device_node *child, u32 addr)\n{\n\treturn -ENOSYS;\n}\n#endif\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}