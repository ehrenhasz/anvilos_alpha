{
  "module_name": "decode.h",
  "hash_id": "e10e71d6662328b520ee60d105a60f3f5dc2d02df98dd50d467e53c38549a241",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ceph/decode.h",
  "human_readable_source": " \n#ifndef __CEPH_DECODE_H\n#define __CEPH_DECODE_H\n\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <asm/unaligned.h>\n\n#include <linux/ceph/types.h>\n\n \n\nstatic inline u64 ceph_decode_64(void **p)\n{\n\tu64 v = get_unaligned_le64(*p);\n\t*p += sizeof(u64);\n\treturn v;\n}\nstatic inline u32 ceph_decode_32(void **p)\n{\n\tu32 v = get_unaligned_le32(*p);\n\t*p += sizeof(u32);\n\treturn v;\n}\nstatic inline u16 ceph_decode_16(void **p)\n{\n\tu16 v = get_unaligned_le16(*p);\n\t*p += sizeof(u16);\n\treturn v;\n}\nstatic inline u8 ceph_decode_8(void **p)\n{\n\tu8 v = *(u8 *)*p;\n\t(*p)++;\n\treturn v;\n}\nstatic inline void ceph_decode_copy(void **p, void *pv, size_t n)\n{\n\tmemcpy(pv, *p, n);\n\t*p += n;\n}\n\n \nstatic inline bool ceph_has_room(void **p, void *end, size_t n)\n{\n\treturn end >= *p && n <= end - *p;\n}\n\n#define ceph_decode_need(p, end, n, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (!likely(ceph_has_room(p, end, n)))\t\t\\\n\t\t\tgoto bad;\t\t\t\t\\\n\t} while (0)\n\n#define ceph_decode_64_safe(p, end, v, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_decode_need(p, end, sizeof(u64), bad);\t\\\n\t\tv = ceph_decode_64(p);\t\t\t\t\\\n\t} while (0)\n#define ceph_decode_32_safe(p, end, v, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_decode_need(p, end, sizeof(u32), bad);\t\\\n\t\tv = ceph_decode_32(p);\t\t\t\t\\\n\t} while (0)\n#define ceph_decode_16_safe(p, end, v, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_decode_need(p, end, sizeof(u16), bad);\t\\\n\t\tv = ceph_decode_16(p);\t\t\t\t\\\n\t} while (0)\n#define ceph_decode_8_safe(p, end, v, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_decode_need(p, end, sizeof(u8), bad);\t\\\n\t\tv = ceph_decode_8(p);\t\t\t\t\\\n\t} while (0)\n\n#define ceph_decode_copy_safe(p, end, pv, n, bad)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_decode_need(p, end, n, bad);\t\t\\\n\t\tceph_decode_copy(p, pv, n);\t\t\t\\\n\t} while (0)\n\n \nstatic inline char *ceph_extract_encoded_string(void **p, void *end,\n\t\t\t\t\t\tsize_t *lenp, gfp_t gfp)\n{\n\tu32 len;\n\tvoid *sp = *p;\n\tchar *buf;\n\n\tceph_decode_32_safe(&sp, end, len, bad);\n\tif (!ceph_has_room(&sp, end, len))\n\t\tgoto bad;\n\n\tbuf = kmalloc(len + 1, gfp);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len)\n\t\tmemcpy(buf, sp, len);\n\tbuf[len] = '\\0';\n\n\t*p = (char *) *p + sizeof (u32) + len;\n\tif (lenp)\n\t\t*lenp = (size_t) len;\n\n\treturn buf;\n\nbad:\n\treturn ERR_PTR(-ERANGE);\n}\n\n \n#define ceph_decode_skip_n(p, end, n, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_decode_need(p, end, n, bad);\t\t\\\n                *p += n;\t\t\t\t\t\\\n\t} while (0)\n\n#define ceph_decode_skip_64(p, end, bad)\t\t\t\\\nceph_decode_skip_n(p, end, sizeof(u64), bad)\n\n#define ceph_decode_skip_32(p, end, bad)\t\t\t\\\nceph_decode_skip_n(p, end, sizeof(u32), bad)\n\n#define ceph_decode_skip_16(p, end, bad)\t\t\t\\\nceph_decode_skip_n(p, end, sizeof(u16), bad)\n\n#define ceph_decode_skip_8(p, end, bad)\t\t\t\t\\\nceph_decode_skip_n(p, end, sizeof(u8), bad)\n\n#define ceph_decode_skip_string(p, end, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tu32 len;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t\tceph_decode_32_safe(p, end, len, bad);\t\t\\\n\t\tceph_decode_skip_n(p, end, len, bad);\t\t\\\n\t} while (0)\n\n#define ceph_decode_skip_set(p, end, type, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tu32 len;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t\tceph_decode_32_safe(p, end, len, bad);\t\t\\\n\t\twhile (len--)\t\t\t\t\t\\\n\t\t\tceph_decode_skip_##type(p, end, bad);\t\\\n\t} while (0)\n\n#define ceph_decode_skip_map(p, end, ktype, vtype, bad)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tu32 len;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t\tceph_decode_32_safe(p, end, len, bad);\t\t\\\n\t\twhile (len--) {\t\t\t\t\t\\\n\t\t\tceph_decode_skip_##ktype(p, end, bad);\t\\\n\t\t\tceph_decode_skip_##vtype(p, end, bad);\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0)\n\n#define ceph_decode_skip_map_of_map(p, end, ktype1, ktype2, vtype2, bad) \\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tu32 len;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t\tceph_decode_32_safe(p, end, len, bad);\t\t\\\n\t\twhile (len--) {\t\t\t\t\t\\\n\t\t\tceph_decode_skip_##ktype1(p, end, bad);\t\\\n\t\t\tceph_decode_skip_map(p, end, ktype2, vtype2, bad); \\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0)\n\n \nstatic inline void ceph_decode_timespec64(struct timespec64 *ts,\n\t\t\t\t\t  const struct ceph_timespec *tv)\n{\n\t \n\tts->tv_sec = (time64_t)le32_to_cpu(tv->tv_sec);\n\tts->tv_nsec = (long)le32_to_cpu(tv->tv_nsec);\n}\nstatic inline void ceph_encode_timespec64(struct ceph_timespec *tv,\n\t\t\t\t\t  const struct timespec64 *ts)\n{\n\ttv->tv_sec = cpu_to_le32((u32)ts->tv_sec);\n\ttv->tv_nsec = cpu_to_le32((u32)ts->tv_nsec);\n}\n\n \n#define CEPH_ENTITY_ADDR_TYPE_NONE\t0\n#define CEPH_ENTITY_ADDR_TYPE_LEGACY\t__cpu_to_le32(1)\n#define CEPH_ENTITY_ADDR_TYPE_MSGR2\t__cpu_to_le32(2)\n#define CEPH_ENTITY_ADDR_TYPE_ANY\t__cpu_to_le32(3)\n\nstatic inline void ceph_encode_banner_addr(struct ceph_entity_addr *a)\n{\n\t__be16 ss_family = htons(a->in_addr.ss_family);\n\ta->in_addr.ss_family = *(__u16 *)&ss_family;\n\n\t \n\ta->type = CEPH_ENTITY_ADDR_TYPE_NONE;\n}\nstatic inline void ceph_decode_banner_addr(struct ceph_entity_addr *a)\n{\n\t__be16 ss_family = *(__be16 *)&a->in_addr.ss_family;\n\ta->in_addr.ss_family = ntohs(ss_family);\n\tWARN_ON(a->in_addr.ss_family == 512);\n\ta->type = CEPH_ENTITY_ADDR_TYPE_LEGACY;\n}\n\nextern int ceph_decode_entity_addr(void **p, void *end,\n\t\t\t\t   struct ceph_entity_addr *addr);\nint ceph_decode_entity_addrvec(void **p, void *end, bool msgr2,\n\t\t\t       struct ceph_entity_addr *addr);\n\nint ceph_entity_addr_encoding_len(const struct ceph_entity_addr *addr);\nvoid ceph_encode_entity_addr(void **p, const struct ceph_entity_addr *addr);\n\n \nstatic inline void ceph_encode_64(void **p, u64 v)\n{\n\tput_unaligned_le64(v, (__le64 *)*p);\n\t*p += sizeof(u64);\n}\nstatic inline void ceph_encode_32(void **p, u32 v)\n{\n\tput_unaligned_le32(v, (__le32 *)*p);\n\t*p += sizeof(u32);\n}\nstatic inline void ceph_encode_16(void **p, u16 v)\n{\n\tput_unaligned_le16(v, (__le16 *)*p);\n\t*p += sizeof(u16);\n}\nstatic inline void ceph_encode_8(void **p, u8 v)\n{\n\t*(u8 *)*p = v;\n\t(*p)++;\n}\nstatic inline void ceph_encode_copy(void **p, const void *s, int len)\n{\n\tmemcpy(*p, s, len);\n\t*p += len;\n}\n\n \nstatic inline void ceph_encode_filepath(void **p, void *end,\n\t\t\t\t\tu64 ino, const char *path)\n{\n\tu32 len = path ? strlen(path) : 0;\n\tBUG_ON(*p + 1 + sizeof(ino) + sizeof(len) + len > end);\n\tceph_encode_8(p, 1);\n\tceph_encode_64(p, ino);\n\tceph_encode_32(p, len);\n\tif (len)\n\t\tmemcpy(*p, path, len);\n\t*p += len;\n}\n\nstatic inline void ceph_encode_string(void **p, void *end,\n\t\t\t\t      const char *s, u32 len)\n{\n\tBUG_ON(*p + sizeof(len) + len > end);\n\tceph_encode_32(p, len);\n\tif (len)\n\t\tmemcpy(*p, s, len);\n\t*p += len;\n}\n\n \n\n \n#define CEPH_ENCODING_START_BLK_LEN 6\n\n \nstatic inline void ceph_start_encoding(void **p, u8 struct_v, u8 struct_compat,\n\t\t\t\t       u32 struct_len)\n{\n\tceph_encode_8(p, struct_v);\n\tceph_encode_8(p, struct_compat);\n\tceph_encode_32(p, struct_len);\n}\n\n \nstatic inline int ceph_start_decoding(void **p, void *end, u8 v,\n\t\t\t\t      const char *name, u8 *struct_v,\n\t\t\t\t      u32 *struct_len)\n{\n\tu8 struct_compat;\n\n\tceph_decode_need(p, end, CEPH_ENCODING_START_BLK_LEN, bad);\n\t*struct_v = ceph_decode_8(p);\n\tstruct_compat = ceph_decode_8(p);\n\tif (v < struct_compat) {\n\t\tpr_warn(\"got struct_v %d struct_compat %d > %d of %s\\n\",\n\t\t\t*struct_v, struct_compat, v, name);\n\t\treturn -EINVAL;\n\t}\n\n\t*struct_len = ceph_decode_32(p);\n\tceph_decode_need(p, end, *struct_len, bad);\n\treturn 0;\n\nbad:\n\treturn -ERANGE;\n}\n\n#define ceph_encode_need(p, end, n, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (!likely(ceph_has_room(p, end, n)))\t\t\\\n\t\t\tgoto bad;\t\t\t\t\\\n\t} while (0)\n\n#define ceph_encode_64_safe(p, end, v, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_encode_need(p, end, sizeof(u64), bad);\t\\\n\t\tceph_encode_64(p, v);\t\t\t\t\\\n\t} while (0)\n#define ceph_encode_32_safe(p, end, v, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_encode_need(p, end, sizeof(u32), bad);\t\\\n\t\tceph_encode_32(p, v);\t\t\t\t\\\n\t} while (0)\n#define ceph_encode_16_safe(p, end, v, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_encode_need(p, end, sizeof(u16), bad);\t\\\n\t\tceph_encode_16(p, v);\t\t\t\t\\\n\t} while (0)\n#define ceph_encode_8_safe(p, end, v, bad)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_encode_need(p, end, sizeof(u8), bad);\t\\\n\t\tceph_encode_8(p, v);\t\t\t\t\\\n\t} while (0)\n\n#define ceph_encode_copy_safe(p, end, pv, n, bad)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_encode_need(p, end, n, bad);\t\t\\\n\t\tceph_encode_copy(p, pv, n);\t\t\t\\\n\t} while (0)\n#define ceph_encode_string_safe(p, end, s, n, bad)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tceph_encode_need(p, end, n, bad);\t\t\\\n\t\tceph_encode_string(p, end, s, n);\t\t\\\n\t} while (0)\n\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}