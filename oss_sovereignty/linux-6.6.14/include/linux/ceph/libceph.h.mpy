{
  "module_name": "libceph.h",
  "hash_id": "284bc28604e422b9049015cf81dc56ea89ba2dda5520732061c7fe1788fd3d14",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ceph/libceph.h",
  "human_readable_source": " \n#ifndef _FS_CEPH_LIBCEPH_H\n#define _FS_CEPH_LIBCEPH_H\n\n#include <linux/ceph/ceph_debug.h>\n\n#include <asm/unaligned.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/exportfs.h>\n#include <linux/bug.h>\n#include <linux/fs.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/refcount.h>\n\n#include <linux/ceph/types.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/msgpool.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/osd_client.h>\n#include <linux/ceph/ceph_fs.h>\n#include <linux/ceph/string_table.h>\n\n \n#define CEPH_OPT_FSID             (1<<0)\n#define CEPH_OPT_NOSHARE          (1<<1)  \n#define CEPH_OPT_MYIP             (1<<2)  \n#define CEPH_OPT_NOCRC            (1<<3)  \n#define CEPH_OPT_TCP_NODELAY      (1<<4)  \n#define CEPH_OPT_NOMSGSIGN        (1<<5)  \n#define CEPH_OPT_ABORT_ON_FULL    (1<<6)  \n#define CEPH_OPT_RXBOUNCE         (1<<7)  \n\n#define CEPH_OPT_DEFAULT   (CEPH_OPT_TCP_NODELAY)\n\n#define ceph_set_opt(client, opt) \\\n\t(client)->options->flags |= CEPH_OPT_##opt;\n#define ceph_test_opt(client, opt) \\\n\t(!!((client)->options->flags & CEPH_OPT_##opt))\n\nstruct ceph_options {\n\tint flags;\n\tstruct ceph_fsid fsid;\n\tstruct ceph_entity_addr my_addr;\n\tunsigned long mount_timeout;\t\t \n\tunsigned long osd_idle_ttl;\t\t \n\tunsigned long osd_keepalive_timeout;\t \n\tunsigned long osd_request_timeout;\t \n\tu32 read_from_replica;   \n\tint con_modes[2];   \n\n\t \n\n\tstruct ceph_entity_addr *mon_addr;  \n\tint num_mon;\n\tchar *name;\n\tstruct ceph_crypto_key *key;\n\tstruct rb_root crush_locs;\n};\n\n \n#define CEPH_MOUNT_TIMEOUT_DEFAULT\tmsecs_to_jiffies(60 * 1000)\n#define CEPH_OSD_KEEPALIVE_DEFAULT\tmsecs_to_jiffies(5 * 1000)\n#define CEPH_OSD_IDLE_TTL_DEFAULT\tmsecs_to_jiffies(60 * 1000)\n#define CEPH_OSD_REQUEST_TIMEOUT_DEFAULT 0   \n#define CEPH_READ_FROM_REPLICA_DEFAULT\t0   \n\n#define CEPH_MONC_HUNT_INTERVAL\t\tmsecs_to_jiffies(3 * 1000)\n#define CEPH_MONC_PING_INTERVAL\t\tmsecs_to_jiffies(10 * 1000)\n#define CEPH_MONC_PING_TIMEOUT\t\tmsecs_to_jiffies(30 * 1000)\n#define CEPH_MONC_HUNT_BACKOFF\t\t2\n#define CEPH_MONC_HUNT_MAX_MULT\t\t10\n\n#define CEPH_MSG_MAX_CONTROL_LEN (16*1024*1024)\n#define CEPH_MSG_MAX_FRONT_LEN\t(16*1024*1024)\n#define CEPH_MSG_MAX_MIDDLE_LEN\t(16*1024*1024)\n\n \n#define CEPH_MSG_MAX_DATA_LEN\t(64*1024*1024)\n\n#define CEPH_AUTH_NAME_DEFAULT   \"guest\"\n\nstatic inline unsigned long ceph_timeout_jiffies(unsigned long timeout)\n{\n\treturn timeout ?: MAX_SCHEDULE_TIMEOUT;\n}\n\nstruct ceph_mds_client;\n\n \nstruct ceph_client {\n\tstruct ceph_fsid fsid;\n\tbool have_fsid;\n\n\tvoid *private;\n\n\tstruct ceph_options *options;\n\n\tstruct mutex mount_mutex;       \n\twait_queue_head_t auth_wq;\n\tint auth_err;\n\n\tint (*extra_mon_dispatch)(struct ceph_client *, struct ceph_msg *);\n\n\tu64 supported_features;\n\tu64 required_features;\n\n\tstruct ceph_messenger msgr;    \n\tstruct ceph_mon_client monc;\n\tstruct ceph_osd_client osdc;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *debugfs_dir;\n\tstruct dentry *debugfs_monmap;\n\tstruct dentry *debugfs_osdmap;\n\tstruct dentry *debugfs_options;\n#endif\n};\n\n#define from_msgr(ms)\tcontainer_of(ms, struct ceph_client, msgr)\n\nstatic inline bool ceph_msgr2(struct ceph_client *client)\n{\n\treturn client->options->con_modes[0] != CEPH_CON_MODE_UNKNOWN;\n}\n\n \n\n \nstruct ceph_snap_context {\n\trefcount_t nref;\n\tu64 seq;\n\tu32 num_snaps;\n\tu64 snaps[];\n};\n\nextern struct ceph_snap_context *ceph_create_snap_context(u32 snap_count,\n\t\t\t\t\tgfp_t gfp_flags);\nextern struct ceph_snap_context *ceph_get_snap_context(\n\t\t\t\t\tstruct ceph_snap_context *sc);\nextern void ceph_put_snap_context(struct ceph_snap_context *sc);\n\n \nstatic inline int calc_pages_for(u64 off, u64 len)\n{\n\treturn ((off+len+PAGE_SIZE-1) >> PAGE_SHIFT) -\n\t\t(off >> PAGE_SHIFT);\n}\n\n#define RB_BYVAL(a)      (a)\n#define RB_BYPTR(a)      (&(a))\n#define RB_CMP3WAY(a, b) ((a) < (b) ? -1 : (a) > (b))\n\n#define DEFINE_RB_INSDEL_FUNCS2(name, type, keyfld, cmpexp, keyexp, nodefld) \\\nstatic bool __insert_##name(struct rb_root *root, type *t)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct rb_node **n = &root->rb_node;\t\t\t\t\\\n\tstruct rb_node *parent = NULL;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tBUG_ON(!RB_EMPTY_NODE(&t->nodefld));\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\twhile (*n) {\t\t\t\t\t\t\t\\\n\t\ttype *cur = rb_entry(*n, type, nodefld);\t\t\\\n\t\tint cmp;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tparent = *n;\t\t\t\t\t\t\\\n\t\tcmp = cmpexp(keyexp(t->keyfld), keyexp(cur->keyfld));\t\\\n\t\tif (cmp < 0)\t\t\t\t\t\t\\\n\t\t\tn = &(*n)->rb_left;\t\t\t\t\\\n\t\telse if (cmp > 0)\t\t\t\t\t\\\n\t\t\tn = &(*n)->rb_right;\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\treturn false;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\trb_link_node(&t->nodefld, parent, n);\t\t\t\t\\\n\trb_insert_color(&t->nodefld, root);\t\t\t\t\\\n\treturn true;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic void __maybe_unused insert_##name(struct rb_root *root, type *t)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (!__insert_##name(root, t))\t\t\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic void erase_##name(struct rb_root *root, type *t)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tBUG_ON(RB_EMPTY_NODE(&t->nodefld));\t\t\t\t\\\n\trb_erase(&t->nodefld, root);\t\t\t\t\t\\\n\tRB_CLEAR_NODE(&t->nodefld);\t\t\t\t\t\\\n}\n\n \n#define DEFINE_RB_LOOKUP_FUNC2(name, type, keyfld, cmpexp, keyexp,\t\\\n\t\t\t       lookup_param_type, nodefld)\t\t\\\nstatic type *lookup_##name(struct rb_root *root, lookup_param_type key)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct rb_node *n = root->rb_node;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\twhile (n) {\t\t\t\t\t\t\t\\\n\t\ttype *cur = rb_entry(n, type, nodefld);\t\t\t\\\n\t\tint cmp;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tcmp = cmpexp(key, keyexp(cur->keyfld));\t\t\t\\\n\t\tif (cmp < 0)\t\t\t\t\t\t\\\n\t\t\tn = n->rb_left;\t\t\t\t\t\\\n\t\telse if (cmp > 0)\t\t\t\t\t\\\n\t\t\tn = n->rb_right;\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\treturn cur;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn NULL;\t\t\t\t\t\t\t\\\n}\n\n#define DEFINE_RB_FUNCS2(name, type, keyfld, cmpexp, keyexp,\t\t\\\n\t\t\t lookup_param_type, nodefld)\t\t\t\\\nDEFINE_RB_INSDEL_FUNCS2(name, type, keyfld, cmpexp, keyexp, nodefld)\t\\\nDEFINE_RB_LOOKUP_FUNC2(name, type, keyfld, cmpexp, keyexp,\t\t\\\n\t\t       lookup_param_type, nodefld)\n\n \n#define DEFINE_RB_INSDEL_FUNCS(name, type, keyfld, nodefld)\t\t\\\nDEFINE_RB_INSDEL_FUNCS2(name, type, keyfld, RB_CMP3WAY, RB_BYVAL, nodefld)\n\n#define DEFINE_RB_LOOKUP_FUNC(name, type, keyfld, nodefld)\t\t\\\nextern type __lookup_##name##_key;\t\t\t\t\t\\\nDEFINE_RB_LOOKUP_FUNC2(name, type, keyfld, RB_CMP3WAY, RB_BYVAL,\t\\\n\t\t       typeof(__lookup_##name##_key.keyfld), nodefld)\n\n#define DEFINE_RB_FUNCS(name, type, keyfld, nodefld)\t\t\t\\\nDEFINE_RB_INSDEL_FUNCS(name, type, keyfld, nodefld)\t\t\t\\\nDEFINE_RB_LOOKUP_FUNC(name, type, keyfld, nodefld)\n\nextern struct kmem_cache *ceph_inode_cachep;\nextern struct kmem_cache *ceph_cap_cachep;\nextern struct kmem_cache *ceph_cap_snap_cachep;\nextern struct kmem_cache *ceph_cap_flush_cachep;\nextern struct kmem_cache *ceph_dentry_cachep;\nextern struct kmem_cache *ceph_file_cachep;\nextern struct kmem_cache *ceph_dir_file_cachep;\nextern struct kmem_cache *ceph_mds_request_cachep;\nextern mempool_t *ceph_wb_pagevec_pool;\n\n \nextern bool libceph_compatible(void *data);\n\nextern const char *ceph_msg_type_name(int type);\nextern int ceph_check_fsid(struct ceph_client *client, struct ceph_fsid *fsid);\nextern int ceph_parse_fsid(const char *str, struct ceph_fsid *fsid);\n\nstruct fs_parameter;\nstruct fc_log;\nstruct ceph_options *ceph_alloc_options(void);\nint ceph_parse_mon_ips(const char *buf, size_t len, struct ceph_options *opt,\n\t\t       struct fc_log *l, char delim);\nint ceph_parse_param(struct fs_parameter *param, struct ceph_options *opt,\n\t\t     struct fc_log *l);\nint ceph_print_client_options(struct seq_file *m, struct ceph_client *client,\n\t\t\t      bool show_all);\nextern void ceph_destroy_options(struct ceph_options *opt);\nextern int ceph_compare_options(struct ceph_options *new_opt,\n\t\t\t\tstruct ceph_client *client);\nstruct ceph_client *ceph_create_client(struct ceph_options *opt, void *private);\nstruct ceph_entity_addr *ceph_client_addr(struct ceph_client *client);\nu64 ceph_client_gid(struct ceph_client *client);\nextern void ceph_destroy_client(struct ceph_client *client);\nextern void ceph_reset_client_addr(struct ceph_client *client);\nextern int __ceph_open_session(struct ceph_client *client,\n\t\t\t       unsigned long started);\nextern int ceph_open_session(struct ceph_client *client);\nint ceph_wait_for_latest_osdmap(struct ceph_client *client,\n\t\t\t\tunsigned long timeout);\n\n \nextern void ceph_release_page_vector(struct page **pages, int num_pages);\nextern void ceph_put_page_vector(struct page **pages, int num_pages,\n\t\t\t\t bool dirty);\nextern struct page **ceph_alloc_page_vector(int num_pages, gfp_t flags);\nextern int ceph_copy_user_to_page_vector(struct page **pages,\n\t\t\t\t\t const void __user *data,\n\t\t\t\t\t loff_t off, size_t len);\nextern void ceph_copy_to_page_vector(struct page **pages,\n\t\t\t\t    const void *data,\n\t\t\t\t    loff_t off, size_t len);\nextern void ceph_copy_from_page_vector(struct page **pages,\n\t\t\t\t    void *data,\n\t\t\t\t    loff_t off, size_t len);\nextern void ceph_zero_page_vector_range(int off, int len, struct page **pages);\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}