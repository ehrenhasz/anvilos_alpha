{
  "module_name": "messenger.h",
  "hash_id": "c6173a19d296e4e810755f3e71abf96d5b8e71174ea37d44946bee7a208cc609",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ceph/messenger.h",
  "human_readable_source": " \n#ifndef __FS_CEPH_MESSENGER_H\n#define __FS_CEPH_MESSENGER_H\n\n#include <linux/bvec.h>\n#include <linux/crypto.h>\n#include <linux/kref.h>\n#include <linux/mutex.h>\n#include <linux/net.h>\n#include <linux/radix-tree.h>\n#include <linux/uio.h>\n#include <linux/workqueue.h>\n#include <net/net_namespace.h>\n\n#include <linux/ceph/types.h>\n#include <linux/ceph/buffer.h>\n\nstruct ceph_msg;\nstruct ceph_connection;\nstruct ceph_msg_data_cursor;\n\n \nstruct ceph_connection_operations {\n\tstruct ceph_connection *(*get)(struct ceph_connection *);\n\tvoid (*put)(struct ceph_connection *);\n\n\t \n\tvoid (*dispatch) (struct ceph_connection *con, struct ceph_msg *m);\n\n\t \n\tstruct ceph_auth_handshake *(*get_authorizer) (\n\t\t\t\tstruct ceph_connection *con,\n\t\t\t       int *proto, int force_new);\n\tint (*add_authorizer_challenge)(struct ceph_connection *con,\n\t\t\t\t\tvoid *challenge_buf,\n\t\t\t\t\tint challenge_buf_len);\n\tint (*verify_authorizer_reply) (struct ceph_connection *con);\n\tint (*invalidate_authorizer)(struct ceph_connection *con);\n\n\t \n\tvoid (*fault) (struct ceph_connection *con);\n\n\t \n\tvoid (*peer_reset) (struct ceph_connection *con);\n\n\tstruct ceph_msg * (*alloc_msg) (struct ceph_connection *con,\n\t\t\t\t\tstruct ceph_msg_header *hdr,\n\t\t\t\t\tint *skip);\n\n\tvoid (*reencode_message) (struct ceph_msg *msg);\n\n\tint (*sign_message) (struct ceph_msg *msg);\n\tint (*check_message_signature) (struct ceph_msg *msg);\n\n\t \n\tint (*get_auth_request)(struct ceph_connection *con,\n\t\t\t\tvoid *buf, int *buf_len,\n\t\t\t\tvoid **authorizer, int *authorizer_len);\n\tint (*handle_auth_reply_more)(struct ceph_connection *con,\n\t\t\t\t      void *reply, int reply_len,\n\t\t\t\t      void *buf, int *buf_len,\n\t\t\t\t      void **authorizer, int *authorizer_len);\n\tint (*handle_auth_done)(struct ceph_connection *con,\n\t\t\t\tu64 global_id, void *reply, int reply_len,\n\t\t\t\tu8 *session_key, int *session_key_len,\n\t\t\t\tu8 *con_secret, int *con_secret_len);\n\tint (*handle_auth_bad_method)(struct ceph_connection *con,\n\t\t\t\t      int used_proto, int result,\n\t\t\t\t      const int *allowed_protos, int proto_cnt,\n\t\t\t\t      const int *allowed_modes, int mode_cnt);\n\n\t \n\tint (*sparse_read)(struct ceph_connection *con,\n\t\t\t   struct ceph_msg_data_cursor *cursor,\n\t\t\t   char **buf);\n\n};\n\n \n#define ENTITY_NAME(n) ceph_entity_type_name((n).type), le64_to_cpu((n).num)\n\nstruct ceph_messenger {\n\tstruct ceph_entity_inst inst;     \n\tstruct ceph_entity_addr my_enc_addr;\n\n\tatomic_t stopping;\n\tpossible_net_t net;\n\n\t \n\tu32 global_seq;\n\tspinlock_t global_seq_lock;\n};\n\nenum ceph_msg_data_type {\n\tCEPH_MSG_DATA_NONE,\t \n\tCEPH_MSG_DATA_PAGES,\t \n\tCEPH_MSG_DATA_PAGELIST,\t \n#ifdef CONFIG_BLOCK\n\tCEPH_MSG_DATA_BIO,\t \n#endif  \n\tCEPH_MSG_DATA_BVECS,\t \n\tCEPH_MSG_DATA_ITER,\t \n};\n\n#ifdef CONFIG_BLOCK\n\nstruct ceph_bio_iter {\n\tstruct bio *bio;\n\tstruct bvec_iter iter;\n};\n\n#define __ceph_bio_iter_advance_step(it, n, STEP) do {\t\t\t      \\\n\tunsigned int __n = (n), __cur_n;\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\twhile (__n) {\t\t\t\t\t\t\t      \\\n\t\tBUG_ON(!(it)->iter.bi_size);\t\t\t\t      \\\n\t\t__cur_n = min((it)->iter.bi_size, __n);\t\t\t      \\\n\t\t(void)(STEP);\t\t\t\t\t\t      \\\n\t\tbio_advance_iter((it)->bio, &(it)->iter, __cur_n);\t      \\\n\t\tif (!(it)->iter.bi_size && (it)->bio->bi_next) {\t      \\\n\t\t\tdout(\"__ceph_bio_iter_advance_step next bio\\n\");      \\\n\t\t\t(it)->bio = (it)->bio->bi_next;\t\t\t      \\\n\t\t\t(it)->iter = (it)->bio->bi_iter;\t\t      \\\n\t\t}\t\t\t\t\t\t\t      \\\n\t\t__n -= __cur_n;\t\t\t\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n} while (0)\n\n \n#define ceph_bio_iter_advance(it, n)\t\t\t\t\t      \\\n\t__ceph_bio_iter_advance_step(it, n, 0)\n\n \n#define ceph_bio_iter_advance_step(it, n, BVEC_STEP)\t\t\t      \\\n\t__ceph_bio_iter_advance_step(it, n, ({\t\t\t\t      \\\n\t\tstruct bio_vec bv;\t\t\t\t\t      \\\n\t\tstruct bvec_iter __cur_iter;\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\t\t__cur_iter = (it)->iter;\t\t\t\t      \\\n\t\t__cur_iter.bi_size = __cur_n;\t\t\t\t      \\\n\t\t__bio_for_each_segment(bv, (it)->bio, __cur_iter, __cur_iter) \\\n\t\t\t(void)(BVEC_STEP);\t\t\t\t      \\\n\t}))\n\n#endif  \n\nstruct ceph_bvec_iter {\n\tstruct bio_vec *bvecs;\n\tstruct bvec_iter iter;\n};\n\n#define __ceph_bvec_iter_advance_step(it, n, STEP) do {\t\t\t      \\\n\tBUG_ON((n) > (it)->iter.bi_size);\t\t\t\t      \\\n\t(void)(STEP);\t\t\t\t\t\t\t      \\\n\tbvec_iter_advance((it)->bvecs, &(it)->iter, (n));\t\t      \\\n} while (0)\n\n \n#define ceph_bvec_iter_advance(it, n)\t\t\t\t\t      \\\n\t__ceph_bvec_iter_advance_step(it, n, 0)\n\n \n#define ceph_bvec_iter_advance_step(it, n, BVEC_STEP)\t\t\t      \\\n\t__ceph_bvec_iter_advance_step(it, n, ({\t\t\t\t      \\\n\t\tstruct bio_vec bv;\t\t\t\t\t      \\\n\t\tstruct bvec_iter __cur_iter;\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\t\t__cur_iter = (it)->iter;\t\t\t\t      \\\n\t\t__cur_iter.bi_size = (n);\t\t\t\t      \\\n\t\tfor_each_bvec(bv, (it)->bvecs, __cur_iter, __cur_iter)\t      \\\n\t\t\t(void)(BVEC_STEP);\t\t\t\t      \\\n\t}))\n\n#define ceph_bvec_iter_shorten(it, n) do {\t\t\t\t      \\\n\tBUG_ON((n) > (it)->iter.bi_size);\t\t\t\t      \\\n\t(it)->iter.bi_size = (n);\t\t\t\t\t      \\\n} while (0)\n\nstruct ceph_msg_data {\n\tenum ceph_msg_data_type\t\ttype;\n\tunion {\n#ifdef CONFIG_BLOCK\n\t\tstruct {\n\t\t\tstruct ceph_bio_iter\tbio_pos;\n\t\t\tu32\t\t\tbio_length;\n\t\t};\n#endif  \n\t\tstruct ceph_bvec_iter\tbvec_pos;\n\t\tstruct {\n\t\t\tstruct page\t**pages;\n\t\t\tsize_t\t\tlength;\t\t \n\t\t\tunsigned int\talignment;\t \n\t\t\tbool\t\town_pages;\n\t\t};\n\t\tstruct ceph_pagelist\t*pagelist;\n\t\tstruct iov_iter\t\titer;\n\t};\n};\n\nstruct ceph_msg_data_cursor {\n\tsize_t\t\t\ttotal_resid;\t \n\n\tstruct ceph_msg_data\t*data;\t\t \n\tsize_t\t\t\tresid;\t\t \n\tint\t\t\tsr_resid;\t \n\tbool\t\t\tneed_crc;\t \n\tunion {\n#ifdef CONFIG_BLOCK\n\t\tstruct ceph_bio_iter\tbio_iter;\n#endif  \n\t\tstruct bvec_iter\tbvec_iter;\n\t\tstruct {\t\t\t\t \n\t\t\tunsigned int\tpage_offset;\t \n\t\t\tunsigned short\tpage_index;\t \n\t\t\tunsigned short\tpage_count;\t \n\t\t};\n\t\tstruct {\t\t\t\t \n\t\t\tstruct page\t*page;\t\t \n\t\t\tsize_t\t\toffset;\t\t \n\t\t};\n\t\tstruct {\n\t\t\tstruct iov_iter\t\tiov_iter;\n\t\t\tunsigned int\t\tlastlen;\n\t\t};\n\t};\n};\n\n \nstruct ceph_msg {\n\tstruct ceph_msg_header hdr;\t \n\tunion {\n\t\tstruct ceph_msg_footer footer;\t\t \n\t\tstruct ceph_msg_footer_old old_footer;\t \n\t};\n\tstruct kvec front;               \n\tstruct ceph_buffer *middle;\n\n\tsize_t\t\t\t\tdata_length;\n\tstruct ceph_msg_data\t\t*data;\n\tint\t\t\t\tnum_data_items;\n\tint\t\t\t\tmax_data_items;\n\tstruct ceph_msg_data_cursor\tcursor;\n\n\tstruct ceph_connection *con;\n\tstruct list_head list_head;\t \n\n\tstruct kref kref;\n\tbool more_to_follow;\n\tbool needs_out_seq;\n\tbool sparse_read;\n\tint front_alloc_len;\n\n\tstruct ceph_msgpool *pool;\n};\n\n \n#define CEPH_CON_S_CLOSED\t\t1\n#define CEPH_CON_S_PREOPEN\t\t2\n#define CEPH_CON_S_V1_BANNER\t\t3\n#define CEPH_CON_S_V1_CONNECT_MSG\t4\n#define CEPH_CON_S_V2_BANNER_PREFIX\t5\n#define CEPH_CON_S_V2_BANNER_PAYLOAD\t6\n#define CEPH_CON_S_V2_HELLO\t\t7\n#define CEPH_CON_S_V2_AUTH\t\t8\n#define CEPH_CON_S_V2_AUTH_SIGNATURE\t9\n#define CEPH_CON_S_V2_SESSION_CONNECT\t10\n#define CEPH_CON_S_V2_SESSION_RECONNECT\t11\n#define CEPH_CON_S_OPEN\t\t\t12\n#define CEPH_CON_S_STANDBY\t\t13\n\n \n#define CEPH_CON_F_LOSSYTX\t\t0   \n#define CEPH_CON_F_KEEPALIVE_PENDING\t1   \n#define CEPH_CON_F_WRITE_PENDING\t2   \n#define CEPH_CON_F_SOCK_CLOSED\t\t3   \n#define CEPH_CON_F_BACKOFF\t\t4   \n\n \n#define BASE_DELAY_INTERVAL\t(HZ / 4)\n#define MAX_DELAY_INTERVAL\t(15 * HZ)\n\nstruct ceph_connection_v1_info {\n\tstruct kvec out_kvec[8],          \n\t\t*out_kvec_cur;\n\tint out_kvec_left;    \n\tint out_skip;         \n\tint out_kvec_bytes;   \n\tbool out_more;        \n\tbool out_msg_done;\n\n\tstruct ceph_auth_handshake *auth;\n\tint auth_retry;        \n\n\t \n\tu8 in_banner[CEPH_BANNER_MAX_LEN];\n\tstruct ceph_entity_addr actual_peer_addr;\n\tstruct ceph_entity_addr peer_addr_for_me;\n\tstruct ceph_msg_connect out_connect;\n\tstruct ceph_msg_connect_reply in_reply;\n\n\tint in_base_pos;      \n\n\t \n\tstruct kvec in_sr_kvec;  \n\tu64 in_sr_len;\t\t \n\n\t \n\tu8 in_tag;            \n\tstruct ceph_msg_header in_hdr;\n\t__le64 in_temp_ack;   \n\n\t \n\tstruct ceph_msg_header out_hdr;\n\t__le64 out_temp_ack;   \n\tstruct ceph_timespec out_temp_keepalive2;   \n\n\tu32 connect_seq;       \n\tu32 peer_global_seq;   \n};\n\n#define CEPH_CRC_LEN\t\t\t4\n#define CEPH_GCM_KEY_LEN\t\t16\n#define CEPH_GCM_IV_LEN\t\t\tsizeof(struct ceph_gcm_nonce)\n#define CEPH_GCM_BLOCK_LEN\t\t16\n#define CEPH_GCM_TAG_LEN\t\t16\n\n#define CEPH_PREAMBLE_LEN\t\t32\n#define CEPH_PREAMBLE_INLINE_LEN\t48\n#define CEPH_PREAMBLE_PLAIN_LEN\t\tCEPH_PREAMBLE_LEN\n#define CEPH_PREAMBLE_SECURE_LEN\t(CEPH_PREAMBLE_LEN +\t\t\\\n\t\t\t\t\t CEPH_PREAMBLE_INLINE_LEN +\t\\\n\t\t\t\t\t CEPH_GCM_TAG_LEN)\n#define CEPH_EPILOGUE_PLAIN_LEN\t\t(1 + 3 * CEPH_CRC_LEN)\n#define CEPH_EPILOGUE_SECURE_LEN\t(CEPH_GCM_BLOCK_LEN + CEPH_GCM_TAG_LEN)\n\n#define CEPH_FRAME_MAX_SEGMENT_COUNT\t4\n\nstruct ceph_frame_desc {\n\tint fd_tag;   \n\tint fd_seg_cnt;\n\tint fd_lens[CEPH_FRAME_MAX_SEGMENT_COUNT];   \n\tint fd_aligns[CEPH_FRAME_MAX_SEGMENT_COUNT];\n};\n\nstruct ceph_gcm_nonce {\n\t__le32 fixed;\n\t__le64 counter __packed;\n};\n\nstruct ceph_connection_v2_info {\n\tstruct iov_iter in_iter;\n\tstruct kvec in_kvecs[5];   \n\tstruct bio_vec in_bvec;   \n\tint in_kvec_cnt;\n\tint in_state;   \n\n\tstruct iov_iter out_iter;\n\tstruct kvec out_kvecs[8];   \n\tstruct bio_vec out_bvec;   \n\tint out_kvec_cnt;\n\tint out_state;   \n\n\tint out_zero;   \n\tbool out_iter_sendpage;   \n\n\tstruct ceph_frame_desc in_desc;\n\tstruct ceph_msg_data_cursor in_cursor;\n\tstruct ceph_msg_data_cursor out_cursor;\n\n\tstruct crypto_shash *hmac_tfm;   \n\tstruct crypto_aead *gcm_tfm;   \n\tstruct aead_request *gcm_req;\n\tstruct crypto_wait gcm_wait;\n\tstruct ceph_gcm_nonce in_gcm_nonce;\n\tstruct ceph_gcm_nonce out_gcm_nonce;\n\n\tstruct page **in_enc_pages;\n\tint in_enc_page_cnt;\n\tint in_enc_resid;\n\tint in_enc_i;\n\tstruct page **out_enc_pages;\n\tint out_enc_page_cnt;\n\tint out_enc_resid;\n\tint out_enc_i;\n\n\tint con_mode;   \n\n\tvoid *conn_bufs[16];\n\tint conn_buf_cnt;\n\tint data_len_remain;\n\n\tstruct kvec in_sign_kvecs[8];\n\tstruct kvec out_sign_kvecs[8];\n\tint in_sign_kvec_cnt;\n\tint out_sign_kvec_cnt;\n\n\tu64 client_cookie;\n\tu64 server_cookie;\n\tu64 global_seq;\n\tu64 connect_seq;\n\tu64 peer_global_seq;\n\n\tu8 in_buf[CEPH_PREAMBLE_SECURE_LEN];\n\tu8 out_buf[CEPH_PREAMBLE_SECURE_LEN];\n\tstruct {\n\t\tu8 late_status;   \n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tu32 front_crc;\n\t\t\t\tu32 middle_crc;\n\t\t\t\tu32 data_crc;\n\t\t\t} __packed;\n\t\t\tu8 pad[CEPH_GCM_BLOCK_LEN - 1];\n\t\t};\n\t} out_epil;\n};\n\n \nstruct ceph_connection {\n\tvoid *private;\n\n\tconst struct ceph_connection_operations *ops;\n\n\tstruct ceph_messenger *msgr;\n\n\tint state;   \n\tatomic_t sock_state;\n\tstruct socket *sock;\n\n\tunsigned long flags;   \n\tconst char *error_msg;   \n\n\tstruct ceph_entity_name peer_name;  \n\tstruct ceph_entity_addr peer_addr;  \n\tu64 peer_features;\n\n\tstruct mutex mutex;\n\n\t \n\tstruct list_head out_queue;\n\tstruct list_head out_sent;    \n\tu64 out_seq;\t\t      \n\n\tu64 in_seq, in_seq_acked;   \n\n\tstruct ceph_msg *in_msg;\n\tstruct ceph_msg *out_msg;         \n\n\tstruct page *bounce_page;\n\tu32 in_front_crc, in_middle_crc, in_data_crc;   \n\n\tstruct timespec64 last_keepalive_ack;  \n\n\tstruct delayed_work work;\t     \n\tunsigned long       delay;           \n\n\tunion {\n\t\tstruct ceph_connection_v1_info v1;\n\t\tstruct ceph_connection_v2_info v2;\n\t};\n};\n\nextern struct page *ceph_zero_page;\n\nvoid ceph_con_flag_clear(struct ceph_connection *con, unsigned long con_flag);\nvoid ceph_con_flag_set(struct ceph_connection *con, unsigned long con_flag);\nbool ceph_con_flag_test(struct ceph_connection *con, unsigned long con_flag);\nbool ceph_con_flag_test_and_clear(struct ceph_connection *con,\n\t\t\t\t  unsigned long con_flag);\nbool ceph_con_flag_test_and_set(struct ceph_connection *con,\n\t\t\t\tunsigned long con_flag);\n\nvoid ceph_encode_my_addr(struct ceph_messenger *msgr);\n\nint ceph_tcp_connect(struct ceph_connection *con);\nint ceph_con_close_socket(struct ceph_connection *con);\nvoid ceph_con_reset_session(struct ceph_connection *con);\n\nu32 ceph_get_global_seq(struct ceph_messenger *msgr, u32 gt);\nvoid ceph_con_discard_sent(struct ceph_connection *con, u64 ack_seq);\nvoid ceph_con_discard_requeued(struct ceph_connection *con, u64 reconnect_seq);\n\nvoid ceph_msg_data_cursor_init(struct ceph_msg_data_cursor *cursor,\n\t\t\t       struct ceph_msg *msg, size_t length);\nstruct page *ceph_msg_data_next(struct ceph_msg_data_cursor *cursor,\n\t\t\t\tsize_t *page_offset, size_t *length);\nvoid ceph_msg_data_advance(struct ceph_msg_data_cursor *cursor, size_t bytes);\n\nu32 ceph_crc32c_page(u32 crc, struct page *page, unsigned int page_offset,\n\t\t     unsigned int length);\n\nbool ceph_addr_is_blank(const struct ceph_entity_addr *addr);\nint ceph_addr_port(const struct ceph_entity_addr *addr);\nvoid ceph_addr_set_port(struct ceph_entity_addr *addr, int p);\n\nvoid ceph_con_process_message(struct ceph_connection *con);\nint ceph_con_in_msg_alloc(struct ceph_connection *con,\n\t\t\t  struct ceph_msg_header *hdr, int *skip);\nvoid ceph_con_get_out_msg(struct ceph_connection *con);\n\n \nint ceph_con_v1_try_read(struct ceph_connection *con);\nint ceph_con_v1_try_write(struct ceph_connection *con);\nvoid ceph_con_v1_revoke(struct ceph_connection *con);\nvoid ceph_con_v1_revoke_incoming(struct ceph_connection *con);\nbool ceph_con_v1_opened(struct ceph_connection *con);\nvoid ceph_con_v1_reset_session(struct ceph_connection *con);\nvoid ceph_con_v1_reset_protocol(struct ceph_connection *con);\n\n \nint ceph_con_v2_try_read(struct ceph_connection *con);\nint ceph_con_v2_try_write(struct ceph_connection *con);\nvoid ceph_con_v2_revoke(struct ceph_connection *con);\nvoid ceph_con_v2_revoke_incoming(struct ceph_connection *con);\nbool ceph_con_v2_opened(struct ceph_connection *con);\nvoid ceph_con_v2_reset_session(struct ceph_connection *con);\nvoid ceph_con_v2_reset_protocol(struct ceph_connection *con);\n\n\nextern const char *ceph_pr_addr(const struct ceph_entity_addr *addr);\n\nextern int ceph_parse_ips(const char *c, const char *end,\n\t\t\t  struct ceph_entity_addr *addr,\n\t\t\t  int max_count, int *count, char delim);\n\nextern int ceph_msgr_init(void);\nextern void ceph_msgr_exit(void);\nextern void ceph_msgr_flush(void);\n\nextern void ceph_messenger_init(struct ceph_messenger *msgr,\n\t\t\t\tstruct ceph_entity_addr *myaddr);\nextern void ceph_messenger_fini(struct ceph_messenger *msgr);\nextern void ceph_messenger_reset_nonce(struct ceph_messenger *msgr);\n\nextern void ceph_con_init(struct ceph_connection *con, void *private,\n\t\t\tconst struct ceph_connection_operations *ops,\n\t\t\tstruct ceph_messenger *msgr);\nextern void ceph_con_open(struct ceph_connection *con,\n\t\t\t  __u8 entity_type, __u64 entity_num,\n\t\t\t  struct ceph_entity_addr *addr);\nextern bool ceph_con_opened(struct ceph_connection *con);\nextern void ceph_con_close(struct ceph_connection *con);\nextern void ceph_con_send(struct ceph_connection *con, struct ceph_msg *msg);\n\nextern void ceph_msg_revoke(struct ceph_msg *msg);\nextern void ceph_msg_revoke_incoming(struct ceph_msg *msg);\n\nextern void ceph_con_keepalive(struct ceph_connection *con);\nextern bool ceph_con_keepalive_expired(struct ceph_connection *con,\n\t\t\t\t       unsigned long interval);\n\nvoid ceph_msg_data_add_pages(struct ceph_msg *msg, struct page **pages,\n\t\t\t     size_t length, size_t alignment, bool own_pages);\nextern void ceph_msg_data_add_pagelist(struct ceph_msg *msg,\n\t\t\t\tstruct ceph_pagelist *pagelist);\n#ifdef CONFIG_BLOCK\nvoid ceph_msg_data_add_bio(struct ceph_msg *msg, struct ceph_bio_iter *bio_pos,\n\t\t\t   u32 length);\n#endif  \nvoid ceph_msg_data_add_bvecs(struct ceph_msg *msg,\n\t\t\t     struct ceph_bvec_iter *bvec_pos);\nvoid ceph_msg_data_add_iter(struct ceph_msg *msg,\n\t\t\t    struct iov_iter *iter);\n\nstruct ceph_msg *ceph_msg_new2(int type, int front_len, int max_data_items,\n\t\t\t       gfp_t flags, bool can_fail);\nextern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,\n\t\t\t\t     bool can_fail);\n\nextern struct ceph_msg *ceph_msg_get(struct ceph_msg *msg);\nextern void ceph_msg_put(struct ceph_msg *msg);\n\nextern void ceph_msg_dump(struct ceph_msg *msg);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}