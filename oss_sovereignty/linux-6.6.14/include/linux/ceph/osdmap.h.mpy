{
  "module_name": "osdmap.h",
  "hash_id": "a8f8f2ed2a4b13a5224b12bcbaa6c7cab4024ed2da00aae93edcaf617c030935",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ceph/osdmap.h",
  "human_readable_source": " \n#ifndef _FS_CEPH_OSDMAP_H\n#define _FS_CEPH_OSDMAP_H\n\n#include <linux/rbtree.h>\n#include <linux/ceph/types.h>\n#include <linux/ceph/decode.h>\n#include <linux/crush/crush.h>\n\n \nstruct ceph_pg {\n\tuint64_t pool;\n\tuint32_t seed;\n};\n\n#define CEPH_SPG_NOSHARD\t-1\n\nstruct ceph_spg {\n\tstruct ceph_pg pgid;\n\ts8 shard;\n};\n\nint ceph_pg_compare(const struct ceph_pg *lhs, const struct ceph_pg *rhs);\nint ceph_spg_compare(const struct ceph_spg *lhs, const struct ceph_spg *rhs);\n\n#define CEPH_POOL_FLAG_HASHPSPOOL\t(1ULL << 0)  \n#define CEPH_POOL_FLAG_FULL\t\t(1ULL << 1)  \n#define CEPH_POOL_FLAG_FULL_QUOTA\t(1ULL << 10)  \n#define CEPH_POOL_FLAG_NEARFULL\t\t(1ULL << 11)  \n\nstruct ceph_pg_pool_info {\n\tstruct rb_node node;\n\ts64 id;\n\tu8 type;  \n\tu8 size;\n\tu8 min_size;\n\tu8 crush_ruleset;\n\tu8 object_hash;\n\tu32 last_force_request_resend;\n\tu32 pg_num, pgp_num;\n\tint pg_num_mask, pgp_num_mask;\n\ts64 read_tier;\n\ts64 write_tier;  \n\tu64 flags;  \n\tchar *name;\n\n\tbool was_full;   \n};\n\nstatic inline bool ceph_can_shift_osds(struct ceph_pg_pool_info *pool)\n{\n\tswitch (pool->type) {\n\tcase CEPH_POOL_TYPE_REP:\n\t\treturn true;\n\tcase CEPH_POOL_TYPE_EC:\n\t\treturn false;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstruct ceph_object_locator {\n\ts64 pool;\n\tstruct ceph_string *pool_ns;\n};\n\nstatic inline void ceph_oloc_init(struct ceph_object_locator *oloc)\n{\n\toloc->pool = -1;\n\toloc->pool_ns = NULL;\n}\n\nstatic inline bool ceph_oloc_empty(const struct ceph_object_locator *oloc)\n{\n\treturn oloc->pool == -1;\n}\n\nvoid ceph_oloc_copy(struct ceph_object_locator *dest,\n\t\t    const struct ceph_object_locator *src);\nvoid ceph_oloc_destroy(struct ceph_object_locator *oloc);\n\n \n#define CEPH_OID_INLINE_LEN 52\n\n \nstruct ceph_object_id {\n\tchar *name;\n\tchar inline_name[CEPH_OID_INLINE_LEN];\n\tint name_len;\n};\n\n#define __CEPH_OID_INITIALIZER(oid) { .name = (oid).inline_name }\n\n#define CEPH_DEFINE_OID_ONSTACK(oid)\t\t\t\t\\\n\tstruct ceph_object_id oid = __CEPH_OID_INITIALIZER(oid)\n\nstatic inline void ceph_oid_init(struct ceph_object_id *oid)\n{\n\t*oid = (struct ceph_object_id) __CEPH_OID_INITIALIZER(*oid);\n}\n\nstatic inline bool ceph_oid_empty(const struct ceph_object_id *oid)\n{\n\treturn oid->name == oid->inline_name && !oid->name_len;\n}\n\nvoid ceph_oid_copy(struct ceph_object_id *dest,\n\t\t   const struct ceph_object_id *src);\n__printf(2, 3)\nvoid ceph_oid_printf(struct ceph_object_id *oid, const char *fmt, ...);\n__printf(3, 4)\nint ceph_oid_aprintf(struct ceph_object_id *oid, gfp_t gfp,\n\t\t     const char *fmt, ...);\nvoid ceph_oid_destroy(struct ceph_object_id *oid);\n\nstruct workspace_manager {\n\tstruct list_head idle_ws;\n\tspinlock_t ws_lock;\n\t \n\tint free_ws;\n\t \n\tatomic_t total_ws;\n\t \n\twait_queue_head_t ws_wait;\n};\n\nstruct ceph_pg_mapping {\n\tstruct rb_node node;\n\tstruct ceph_pg pgid;\n\n\tunion {\n\t\tstruct {\n\t\t\tint len;\n\t\t\tint osds[];\n\t\t} pg_temp, pg_upmap;\n\t\tstruct {\n\t\t\tint osd;\n\t\t} primary_temp;\n\t\tstruct {\n\t\t\tint len;\n\t\t\tint from_to[][2];\n\t\t} pg_upmap_items;\n\t};\n};\n\nstruct ceph_osdmap {\n\tstruct ceph_fsid fsid;\n\tu32 epoch;\n\tstruct ceph_timespec created, modified;\n\n\tu32 flags;          \n\n\tu32 max_osd;        \n\tu32 *osd_state;     \n\tu32 *osd_weight;    \n\tstruct ceph_entity_addr *osd_addr;\n\n\tstruct rb_root pg_temp;\n\tstruct rb_root primary_temp;\n\n\t \n\tstruct rb_root pg_upmap;\t \n\tstruct rb_root pg_upmap_items;\t \n\n\tu32 *osd_primary_affinity;\n\n\tstruct rb_root pg_pools;\n\tu32 pool_max;\n\n\t \n\tstruct crush_map *crush;\n\n\tstruct workspace_manager crush_wsm;\n};\n\nstatic inline bool ceph_osd_exists(struct ceph_osdmap *map, int osd)\n{\n\treturn osd >= 0 && osd < map->max_osd &&\n\t       (map->osd_state[osd] & CEPH_OSD_EXISTS);\n}\n\nstatic inline bool ceph_osd_is_up(struct ceph_osdmap *map, int osd)\n{\n\treturn ceph_osd_exists(map, osd) &&\n\t       (map->osd_state[osd] & CEPH_OSD_UP);\n}\n\nstatic inline bool ceph_osd_is_down(struct ceph_osdmap *map, int osd)\n{\n\treturn !ceph_osd_is_up(map, osd);\n}\n\nchar *ceph_osdmap_state_str(char *str, int len, u32 state);\nextern u32 ceph_get_primary_affinity(struct ceph_osdmap *map, int osd);\n\nstatic inline struct ceph_entity_addr *ceph_osd_addr(struct ceph_osdmap *map,\n\t\t\t\t\t\t     int osd)\n{\n\tif (osd >= map->max_osd)\n\t\treturn NULL;\n\treturn &map->osd_addr[osd];\n}\n\n#define CEPH_PGID_ENCODING_LEN\t\t(1 + 8 + 4 + 4)\n\nstatic inline int ceph_decode_pgid(void **p, void *end, struct ceph_pg *pgid)\n{\n\t__u8 version;\n\n\tif (!ceph_has_room(p, end, CEPH_PGID_ENCODING_LEN)) {\n\t\tpr_warn(\"incomplete pg encoding\\n\");\n\t\treturn -EINVAL;\n\t}\n\tversion = ceph_decode_8(p);\n\tif (version > 1) {\n\t\tpr_warn(\"do not understand pg encoding %d > 1\\n\",\n\t\t\t(int)version);\n\t\treturn -EINVAL;\n\t}\n\n\tpgid->pool = ceph_decode_64(p);\n\tpgid->seed = ceph_decode_32(p);\n\t*p += 4;\t \n\n\treturn 0;\n}\n\nstruct ceph_osdmap *ceph_osdmap_alloc(void);\nstruct ceph_osdmap *ceph_osdmap_decode(void **p, void *end, bool msgr2);\nstruct ceph_osdmap *osdmap_apply_incremental(void **p, void *end, bool msgr2,\n\t\t\t\t\t     struct ceph_osdmap *map);\nextern void ceph_osdmap_destroy(struct ceph_osdmap *map);\n\nstruct ceph_osds {\n\tint osds[CEPH_PG_MAX_SIZE];\n\tint size;\n\tint primary;  \n};\n\nstatic inline void ceph_osds_init(struct ceph_osds *set)\n{\n\tset->size = 0;\n\tset->primary = -1;\n}\n\nvoid ceph_osds_copy(struct ceph_osds *dest, const struct ceph_osds *src);\n\nbool ceph_pg_is_split(const struct ceph_pg *pgid, u32 old_pg_num,\n\t\t      u32 new_pg_num);\nbool ceph_is_new_interval(const struct ceph_osds *old_acting,\n\t\t\t  const struct ceph_osds *new_acting,\n\t\t\t  const struct ceph_osds *old_up,\n\t\t\t  const struct ceph_osds *new_up,\n\t\t\t  int old_size,\n\t\t\t  int new_size,\n\t\t\t  int old_min_size,\n\t\t\t  int new_min_size,\n\t\t\t  u32 old_pg_num,\n\t\t\t  u32 new_pg_num,\n\t\t\t  bool old_sort_bitwise,\n\t\t\t  bool new_sort_bitwise,\n\t\t\t  bool old_recovery_deletes,\n\t\t\t  bool new_recovery_deletes,\n\t\t\t  const struct ceph_pg *pgid);\nbool ceph_osds_changed(const struct ceph_osds *old_acting,\n\t\t       const struct ceph_osds *new_acting,\n\t\t       bool any_change);\n\nvoid __ceph_object_locator_to_pg(struct ceph_pg_pool_info *pi,\n\t\t\t\t const struct ceph_object_id *oid,\n\t\t\t\t const struct ceph_object_locator *oloc,\n\t\t\t\t struct ceph_pg *raw_pgid);\nint ceph_object_locator_to_pg(struct ceph_osdmap *osdmap,\n\t\t\t      const struct ceph_object_id *oid,\n\t\t\t      const struct ceph_object_locator *oloc,\n\t\t\t      struct ceph_pg *raw_pgid);\n\nvoid ceph_pg_to_up_acting_osds(struct ceph_osdmap *osdmap,\n\t\t\t       struct ceph_pg_pool_info *pi,\n\t\t\t       const struct ceph_pg *raw_pgid,\n\t\t\t       struct ceph_osds *up,\n\t\t\t       struct ceph_osds *acting);\nbool ceph_pg_to_primary_shard(struct ceph_osdmap *osdmap,\n\t\t\t      struct ceph_pg_pool_info *pi,\n\t\t\t      const struct ceph_pg *raw_pgid,\n\t\t\t      struct ceph_spg *spgid);\nint ceph_pg_to_acting_primary(struct ceph_osdmap *osdmap,\n\t\t\t      const struct ceph_pg *raw_pgid);\n\nstruct crush_loc {\n\tchar *cl_type_name;\n\tchar *cl_name;\n};\n\nstruct crush_loc_node {\n\tstruct rb_node cl_node;\n\tstruct crush_loc cl_loc;   \n\tchar cl_data[];\n};\n\nint ceph_parse_crush_location(char *crush_location, struct rb_root *locs);\nint ceph_compare_crush_locs(struct rb_root *locs1, struct rb_root *locs2);\nvoid ceph_clear_crush_locs(struct rb_root *locs);\n\nint ceph_get_crush_locality(struct ceph_osdmap *osdmap, int id,\n\t\t\t    struct rb_root *locs);\n\nextern struct ceph_pg_pool_info *ceph_pg_pool_by_id(struct ceph_osdmap *map,\n\t\t\t\t\t\t    u64 id);\nextern const char *ceph_pg_pool_name_by_id(struct ceph_osdmap *map, u64 id);\nextern int ceph_pg_poolid_by_name(struct ceph_osdmap *map, const char *name);\nu64 ceph_pg_pool_flags(struct ceph_osdmap *map, u64 id);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}