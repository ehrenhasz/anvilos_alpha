{
  "module_name": "filelock.h",
  "hash_id": "02fff873bb12d06db8e05b608b00e1946d4fea1e5befd131c6f993e59c1680da",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/filelock.h",
  "human_readable_source": " \n#ifndef _LINUX_FILELOCK_H\n#define _LINUX_FILELOCK_H\n\n#include <linux/fs.h>\n\n#define FL_POSIX\t1\n#define FL_FLOCK\t2\n#define FL_DELEG\t4\t \n#define FL_ACCESS\t8\t \n#define FL_EXISTS\t16\t \n#define FL_LEASE\t32\t \n#define FL_CLOSE\t64\t \n#define FL_SLEEP\t128\t \n#define FL_DOWNGRADE_PENDING\t256  \n#define FL_UNLOCK_PENDING\t512  \n#define FL_OFDLCK\t1024\t \n#define FL_LAYOUT\t2048\t \n#define FL_RECLAIM\t4096\t \n\n#define FL_CLOSE_POSIX (FL_POSIX | FL_CLOSE)\n\n \n#define FILE_LOCK_DEFERRED 1\n\nstruct file_lock;\n\nstruct file_lock_operations {\n\tvoid (*fl_copy_lock)(struct file_lock *, struct file_lock *);\n\tvoid (*fl_release_private)(struct file_lock *);\n};\n\nstruct lock_manager_operations {\n\tvoid *lm_mod_owner;\n\tfl_owner_t (*lm_get_owner)(fl_owner_t);\n\tvoid (*lm_put_owner)(fl_owner_t);\n\tvoid (*lm_notify)(struct file_lock *);\t \n\tint (*lm_grant)(struct file_lock *, int);\n\tbool (*lm_break)(struct file_lock *);\n\tint (*lm_change)(struct file_lock *, int, struct list_head *);\n\tvoid (*lm_setup)(struct file_lock *, void **);\n\tbool (*lm_breaker_owns_lease)(struct file_lock *);\n\tbool (*lm_lock_expirable)(struct file_lock *cfl);\n\tvoid (*lm_expire_lock)(void);\n};\n\nstruct lock_manager {\n\tstruct list_head list;\n\t \n\tbool block_opens;\n};\n\nstruct net;\nvoid locks_start_grace(struct net *, struct lock_manager *);\nvoid locks_end_grace(struct lock_manager *);\nbool locks_in_grace(struct net *);\nbool opens_in_grace(struct net *);\n\n \n#include <linux/nfs_fs_i.h>\n\n \nstruct file_lock {\n\tstruct file_lock *fl_blocker;\t \n\tstruct list_head fl_list;\t \n\tstruct hlist_node fl_link;\t \n\tstruct list_head fl_blocked_requests;\t \n\tstruct list_head fl_blocked_member;\t \n\tfl_owner_t fl_owner;\n\tunsigned int fl_flags;\n\tunsigned char fl_type;\n\tunsigned int fl_pid;\n\tint fl_link_cpu;\t\t \n\twait_queue_head_t fl_wait;\n\tstruct file *fl_file;\n\tloff_t fl_start;\n\tloff_t fl_end;\n\n\tstruct fasync_struct *\tfl_fasync;  \n\t \n\tunsigned long fl_break_time;\n\tunsigned long fl_downgrade_time;\n\n\tconst struct file_lock_operations *fl_ops;\t \n\tconst struct lock_manager_operations *fl_lmops;\t \n\tunion {\n\t\tstruct nfs_lock_info\tnfs_fl;\n\t\tstruct nfs4_lock_info\tnfs4_fl;\n\t\tstruct {\n\t\t\tstruct list_head link;\t \n\t\t\tint state;\t\t \n\t\t\tunsigned int\tdebug_id;\n\t\t} afs;\n\t\tstruct {\n\t\t\tstruct inode *inode;\n\t\t} ceph;\n\t} fl_u;\n} __randomize_layout;\n\nstruct file_lock_context {\n\tspinlock_t\t\tflc_lock;\n\tstruct list_head\tflc_flock;\n\tstruct list_head\tflc_posix;\n\tstruct list_head\tflc_lease;\n};\n\n#ifdef CONFIG_FILE_LOCKING\nint fcntl_getlk(struct file *, unsigned int, struct flock *);\nint fcntl_setlk(unsigned int, struct file *, unsigned int,\n\t\t\tstruct flock *);\n\n#if BITS_PER_LONG == 32\nint fcntl_getlk64(struct file *, unsigned int, struct flock64 *);\nint fcntl_setlk64(unsigned int, struct file *, unsigned int,\n\t\t\tstruct flock64 *);\n#endif\n\nint fcntl_setlease(unsigned int fd, struct file *filp, int arg);\nint fcntl_getlease(struct file *filp);\n\n \nvoid locks_free_lock_context(struct inode *inode);\nvoid locks_free_lock(struct file_lock *fl);\nvoid locks_init_lock(struct file_lock *);\nstruct file_lock * locks_alloc_lock(void);\nvoid locks_copy_lock(struct file_lock *, struct file_lock *);\nvoid locks_copy_conflock(struct file_lock *, struct file_lock *);\nvoid locks_remove_posix(struct file *, fl_owner_t);\nvoid locks_remove_file(struct file *);\nvoid locks_release_private(struct file_lock *);\nvoid posix_test_lock(struct file *, struct file_lock *);\nint posix_lock_file(struct file *, struct file_lock *, struct file_lock *);\nint locks_delete_block(struct file_lock *);\nint vfs_test_lock(struct file *, struct file_lock *);\nint vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);\nint vfs_cancel_lock(struct file *filp, struct file_lock *fl);\nbool vfs_inode_has_locks(struct inode *inode);\nint locks_lock_inode_wait(struct inode *inode, struct file_lock *fl);\nint __break_lease(struct inode *inode, unsigned int flags, unsigned int type);\nvoid lease_get_mtime(struct inode *, struct timespec64 *time);\nint generic_setlease(struct file *, int, struct file_lock **, void **priv);\nint vfs_setlease(struct file *, int, struct file_lock **, void **);\nint lease_modify(struct file_lock *, int, struct list_head *);\n\nstruct notifier_block;\nint lease_register_notifier(struct notifier_block *);\nvoid lease_unregister_notifier(struct notifier_block *);\n\nstruct files_struct;\nvoid show_fd_locks(struct seq_file *f,\n\t\t\t struct file *filp, struct files_struct *files);\nbool locks_owner_has_blockers(struct file_lock_context *flctx,\n\t\t\tfl_owner_t owner);\n\nstatic inline struct file_lock_context *\nlocks_inode_context(const struct inode *inode)\n{\n\treturn smp_load_acquire(&inode->i_flctx);\n}\n\n#else  \nstatic inline int fcntl_getlk(struct file *file, unsigned int cmd,\n\t\t\t      struct flock __user *user)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int fcntl_setlk(unsigned int fd, struct file *file,\n\t\t\t      unsigned int cmd, struct flock __user *user)\n{\n\treturn -EACCES;\n}\n\n#if BITS_PER_LONG == 32\nstatic inline int fcntl_getlk64(struct file *file, unsigned int cmd,\n\t\t\t\tstruct flock64 *user)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int fcntl_setlk64(unsigned int fd, struct file *file,\n\t\t\t\tunsigned int cmd, struct flock64 *user)\n{\n\treturn -EACCES;\n}\n#endif\nstatic inline int fcntl_setlease(unsigned int fd, struct file *filp, int arg)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int fcntl_getlease(struct file *filp)\n{\n\treturn F_UNLCK;\n}\n\nstatic inline void\nlocks_free_lock_context(struct inode *inode)\n{\n}\n\nstatic inline void locks_init_lock(struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline void locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline void locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\treturn;\n}\n\nstatic inline void locks_remove_file(struct file *filp)\n{\n\treturn;\n}\n\nstatic inline void posix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\t\t  struct file_lock *conflock)\n{\n\treturn -ENOLCK;\n}\n\nstatic inline int locks_delete_block(struct file_lock *waiter)\n{\n\treturn -ENOENT;\n}\n\nstatic inline int vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\treturn 0;\n}\n\nstatic inline int vfs_lock_file(struct file *filp, unsigned int cmd,\n\t\t\t\tstruct file_lock *fl, struct file_lock *conf)\n{\n\treturn -ENOLCK;\n}\n\nstatic inline int vfs_cancel_lock(struct file *filp, struct file_lock *fl)\n{\n\treturn 0;\n}\n\nstatic inline bool vfs_inode_has_locks(struct inode *inode)\n{\n\treturn false;\n}\n\nstatic inline int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\treturn -ENOLCK;\n}\n\nstatic inline int __break_lease(struct inode *inode, unsigned int mode, unsigned int type)\n{\n\treturn 0;\n}\n\nstatic inline void lease_get_mtime(struct inode *inode,\n\t\t\t\t   struct timespec64 *time)\n{\n\treturn;\n}\n\nstatic inline int generic_setlease(struct file *filp, int arg,\n\t\t\t\t    struct file_lock **flp, void **priv)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int vfs_setlease(struct file *filp, int arg,\n\t\t\t       struct file_lock **lease, void **priv)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int lease_modify(struct file_lock *fl, int arg,\n\t\t\t       struct list_head *dispose)\n{\n\treturn -EINVAL;\n}\n\nstruct files_struct;\nstatic inline void show_fd_locks(struct seq_file *f,\n\t\t\tstruct file *filp, struct files_struct *files) {}\nstatic inline bool locks_owner_has_blockers(struct file_lock_context *flctx,\n\t\t\tfl_owner_t owner)\n{\n\treturn false;\n}\n\nstatic inline struct file_lock_context *\nlocks_inode_context(const struct inode *inode)\n{\n\treturn NULL;\n}\n\n#endif  \n\nstatic inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\treturn locks_lock_inode_wait(file_inode(filp), fl);\n}\n\n#ifdef CONFIG_FILE_LOCKING\nstatic inline int break_lease(struct inode *inode, unsigned int mode)\n{\n\t \n\tsmp_mb();\n\tif (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))\n\t\treturn __break_lease(inode, mode, FL_LEASE);\n\treturn 0;\n}\n\nstatic inline int break_deleg(struct inode *inode, unsigned int mode)\n{\n\t \n\tsmp_mb();\n\tif (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))\n\t\treturn __break_lease(inode, mode, FL_DELEG);\n\treturn 0;\n}\n\nstatic inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)\n{\n\tint ret;\n\n\tret = break_deleg(inode, O_WRONLY|O_NONBLOCK);\n\tif (ret == -EWOULDBLOCK && delegated_inode) {\n\t\t*delegated_inode = inode;\n\t\tihold(inode);\n\t}\n\treturn ret;\n}\n\nstatic inline int break_deleg_wait(struct inode **delegated_inode)\n{\n\tint ret;\n\n\tret = break_deleg(*delegated_inode, O_WRONLY);\n\tiput(*delegated_inode);\n\t*delegated_inode = NULL;\n\treturn ret;\n}\n\nstatic inline int break_layout(struct inode *inode, bool wait)\n{\n\tsmp_mb();\n\tif (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))\n\t\treturn __break_lease(inode,\n\t\t\t\twait ? O_WRONLY : O_WRONLY | O_NONBLOCK,\n\t\t\t\tFL_LAYOUT);\n\treturn 0;\n}\n\n#else  \nstatic inline int break_lease(struct inode *inode, unsigned int mode)\n{\n\treturn 0;\n}\n\nstatic inline int break_deleg(struct inode *inode, unsigned int mode)\n{\n\treturn 0;\n}\n\nstatic inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)\n{\n\treturn 0;\n}\n\nstatic inline int break_deleg_wait(struct inode **delegated_inode)\n{\n\tBUG();\n\treturn 0;\n}\n\nstatic inline int break_layout(struct inode *inode, bool wait)\n{\n\treturn 0;\n}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}