{
  "module_name": "ksm.h",
  "hash_id": "de64d9d966d31ecad8f9a109d6f84d7543a274e9e27d125bdfa54a66c5cddef1",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ksm.h",
  "human_readable_source": " \n#ifndef __LINUX_KSM_H\n#define __LINUX_KSM_H\n \n\n#include <linux/bitops.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/rmap.h>\n#include <linux/sched.h>\n#include <linux/sched/coredump.h>\n\n#ifdef CONFIG_KSM\nint ksm_madvise(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long end, int advice, unsigned long *vm_flags);\n\nvoid ksm_add_vma(struct vm_area_struct *vma);\nint ksm_enable_merge_any(struct mm_struct *mm);\nint ksm_disable_merge_any(struct mm_struct *mm);\nint ksm_disable(struct mm_struct *mm);\n\nint __ksm_enter(struct mm_struct *mm);\nvoid __ksm_exit(struct mm_struct *mm);\n \n#define is_ksm_zero_pte(pte)\t(is_zero_pfn(pte_pfn(pte)) && pte_dirty(pte))\n\nextern unsigned long ksm_zero_pages;\n\nstatic inline void ksm_might_unmap_zero_page(struct mm_struct *mm, pte_t pte)\n{\n\tif (is_ksm_zero_pte(pte)) {\n\t\tksm_zero_pages--;\n\t\tmm->ksm_zero_pages--;\n\t}\n}\n\nstatic inline int ksm_fork(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tint ret;\n\n\tif (test_bit(MMF_VM_MERGEABLE, &oldmm->flags)) {\n\t\tret = __ksm_enter(mm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (test_bit(MMF_VM_MERGE_ANY, &oldmm->flags))\n\t\tset_bit(MMF_VM_MERGE_ANY, &mm->flags);\n\n\treturn 0;\n}\n\nstatic inline void ksm_exit(struct mm_struct *mm)\n{\n\tif (test_bit(MMF_VM_MERGEABLE, &mm->flags))\n\t\t__ksm_exit(mm);\n}\n\n \nstruct page *ksm_might_need_to_copy(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address);\n\nvoid rmap_walk_ksm(struct folio *folio, struct rmap_walk_control *rwc);\nvoid folio_migrate_ksm(struct folio *newfolio, struct folio *folio);\n\n#ifdef CONFIG_MEMORY_FAILURE\nvoid collect_procs_ksm(struct page *page, struct list_head *to_kill,\n\t\t       int force_early);\n#endif\n\n#ifdef CONFIG_PROC_FS\nlong ksm_process_profit(struct mm_struct *);\n#endif  \n\n#else   \n\nstatic inline void ksm_add_vma(struct vm_area_struct *vma)\n{\n}\n\nstatic inline int ksm_disable(struct mm_struct *mm)\n{\n\treturn 0;\n}\n\nstatic inline int ksm_fork(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\treturn 0;\n}\n\nstatic inline void ksm_exit(struct mm_struct *mm)\n{\n}\n\nstatic inline void ksm_might_unmap_zero_page(struct mm_struct *mm, pte_t pte)\n{\n}\n\n#ifdef CONFIG_MEMORY_FAILURE\nstatic inline void collect_procs_ksm(struct page *page,\n\t\t\t\t     struct list_head *to_kill, int force_early)\n{\n}\n#endif\n\n#ifdef CONFIG_MMU\nstatic inline int ksm_madvise(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long end, int advice, unsigned long *vm_flags)\n{\n\treturn 0;\n}\n\nstatic inline struct page *ksm_might_need_to_copy(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\treturn page;\n}\n\nstatic inline void rmap_walk_ksm(struct folio *folio,\n\t\t\tstruct rmap_walk_control *rwc)\n{\n}\n\nstatic inline void folio_migrate_ksm(struct folio *newfolio, struct folio *old)\n{\n}\n#endif  \n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}