{
  "module_name": "spinlock_api_up.h",
  "hash_id": "04e7e9e937e08e8923f7a3b3c764ee5e0981612137f380762d17a911af0a90bc",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/spinlock_api_up.h",
  "human_readable_source": "#ifndef __LINUX_SPINLOCK_API_UP_H\n#define __LINUX_SPINLOCK_API_UP_H\n\n#ifndef __LINUX_INSIDE_SPINLOCK_H\n# error \"please don't include this file directly\"\n#endif\n\n \n\n#define in_lock_functions(ADDR)\t\t0\n\n#define assert_raw_spin_locked(lock)\tdo { (void)(lock); } while (0)\n\n \n#define ___LOCK(lock) \\\n  do { __acquire(lock); (void)(lock); } while (0)\n\n#define __LOCK(lock) \\\n  do { preempt_disable(); ___LOCK(lock); } while (0)\n\n#define __LOCK_BH(lock) \\\n  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n\n#define __LOCK_IRQ(lock) \\\n  do { local_irq_disable(); __LOCK(lock); } while (0)\n\n#define __LOCK_IRQSAVE(lock, flags) \\\n  do { local_irq_save(flags); __LOCK(lock); } while (0)\n\n#define ___UNLOCK(lock) \\\n  do { __release(lock); (void)(lock); } while (0)\n\n#define __UNLOCK(lock) \\\n  do { preempt_enable(); ___UNLOCK(lock); } while (0)\n\n#define __UNLOCK_BH(lock) \\\n  do { __local_bh_enable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); \\\n       ___UNLOCK(lock); } while (0)\n\n#define __UNLOCK_IRQ(lock) \\\n  do { local_irq_enable(); __UNLOCK(lock); } while (0)\n\n#define __UNLOCK_IRQRESTORE(lock, flags) \\\n  do { local_irq_restore(flags); __UNLOCK(lock); } while (0)\n\n#define _raw_spin_lock(lock)\t\t\t__LOCK(lock)\n#define _raw_spin_lock_nested(lock, subclass)\t__LOCK(lock)\n#define _raw_read_lock(lock)\t\t\t__LOCK(lock)\n#define _raw_write_lock(lock)\t\t\t__LOCK(lock)\n#define _raw_write_lock_nested(lock, subclass)\t__LOCK(lock)\n#define _raw_spin_lock_bh(lock)\t\t\t__LOCK_BH(lock)\n#define _raw_read_lock_bh(lock)\t\t\t__LOCK_BH(lock)\n#define _raw_write_lock_bh(lock)\t\t__LOCK_BH(lock)\n#define _raw_spin_lock_irq(lock)\t\t__LOCK_IRQ(lock)\n#define _raw_read_lock_irq(lock)\t\t__LOCK_IRQ(lock)\n#define _raw_write_lock_irq(lock)\t\t__LOCK_IRQ(lock)\n#define _raw_spin_lock_irqsave(lock, flags)\t__LOCK_IRQSAVE(lock, flags)\n#define _raw_read_lock_irqsave(lock, flags)\t__LOCK_IRQSAVE(lock, flags)\n#define _raw_write_lock_irqsave(lock, flags)\t__LOCK_IRQSAVE(lock, flags)\n#define _raw_spin_trylock(lock)\t\t\t({ __LOCK(lock); 1; })\n#define _raw_read_trylock(lock)\t\t\t({ __LOCK(lock); 1; })\n#define _raw_write_trylock(lock)\t\t\t({ __LOCK(lock); 1; })\n#define _raw_spin_trylock_bh(lock)\t\t({ __LOCK_BH(lock); 1; })\n#define _raw_spin_unlock(lock)\t\t\t__UNLOCK(lock)\n#define _raw_read_unlock(lock)\t\t\t__UNLOCK(lock)\n#define _raw_write_unlock(lock)\t\t\t__UNLOCK(lock)\n#define _raw_spin_unlock_bh(lock)\t\t__UNLOCK_BH(lock)\n#define _raw_write_unlock_bh(lock)\t\t__UNLOCK_BH(lock)\n#define _raw_read_unlock_bh(lock)\t\t__UNLOCK_BH(lock)\n#define _raw_spin_unlock_irq(lock)\t\t__UNLOCK_IRQ(lock)\n#define _raw_read_unlock_irq(lock)\t\t__UNLOCK_IRQ(lock)\n#define _raw_write_unlock_irq(lock)\t\t__UNLOCK_IRQ(lock)\n#define _raw_spin_unlock_irqrestore(lock, flags) \\\n\t\t\t\t\t__UNLOCK_IRQRESTORE(lock, flags)\n#define _raw_read_unlock_irqrestore(lock, flags) \\\n\t\t\t\t\t__UNLOCK_IRQRESTORE(lock, flags)\n#define _raw_write_unlock_irqrestore(lock, flags) \\\n\t\t\t\t\t__UNLOCK_IRQRESTORE(lock, flags)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}