{
  "module_name": "cgroup.h",
  "hash_id": "c16e65e9b31615dd815af1b47325d48d3495f479c8b8ed5a8ea644be449386dc",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/cgroup.h",
  "human_readable_source": " \n#ifndef _LINUX_CGROUP_H\n#define _LINUX_CGROUP_H\n \n\n#include <linux/sched.h>\n#include <linux/cpumask.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/cgroupstats.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/kernfs.h>\n#include <linux/jump_label.h>\n#include <linux/types.h>\n#include <linux/ns_common.h>\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/refcount.h>\n#include <linux/kernel_stat.h>\n\n#include <linux/cgroup-defs.h>\n\nstruct kernel_clone_args;\n\n#ifdef CONFIG_CGROUPS\n\n \n#define CGROUP_WEIGHT_MIN\t\t1\n#define CGROUP_WEIGHT_DFL\t\t100\n#define CGROUP_WEIGHT_MAX\t\t10000\n\n \n#define CSS_TASK_ITER_PROCS\t\t(1U << 0)\n \n#define CSS_TASK_ITER_THREADED\t\t(1U << 1)\n\n \n#define CSS_TASK_ITER_SKIPPED\t\t(1U << 16)\n\n \nstruct css_task_iter {\n\tstruct cgroup_subsys\t\t*ss;\n\tunsigned int\t\t\tflags;\n\n\tstruct list_head\t\t*cset_pos;\n\tstruct list_head\t\t*cset_head;\n\n\tstruct list_head\t\t*tcset_pos;\n\tstruct list_head\t\t*tcset_head;\n\n\tstruct list_head\t\t*task_pos;\n\n\tstruct list_head\t\t*cur_tasks_head;\n\tstruct css_set\t\t\t*cur_cset;\n\tstruct css_set\t\t\t*cur_dcset;\n\tstruct task_struct\t\t*cur_task;\n\tstruct list_head\t\titers_node;\t \n};\n\nextern struct file_system_type cgroup_fs_type;\nextern struct cgroup_root cgrp_dfl_root;\nextern struct css_set init_css_set;\n\n#define SUBSYS(_x) extern struct cgroup_subsys _x ## _cgrp_subsys;\n#include <linux/cgroup_subsys.h>\n#undef SUBSYS\n\n#define SUBSYS(_x)\t\t\t\t\t\t\t\t\\\n\textern struct static_key_true _x ## _cgrp_subsys_enabled_key;\t\t\\\n\textern struct static_key_true _x ## _cgrp_subsys_on_dfl_key;\n#include <linux/cgroup_subsys.h>\n#undef SUBSYS\n\n \n#define cgroup_subsys_enabled(ss)\t\t\t\t\t\t\\\n\tstatic_branch_likely(&ss ## _enabled_key)\n\n \n#define cgroup_subsys_on_dfl(ss)\t\t\t\t\t\t\\\n\tstatic_branch_likely(&ss ## _on_dfl_key)\n\nbool css_has_online_children(struct cgroup_subsys_state *css);\nstruct cgroup_subsys_state *css_from_id(int id, struct cgroup_subsys *ss);\nstruct cgroup_subsys_state *cgroup_e_css(struct cgroup *cgroup,\n\t\t\t\t\t struct cgroup_subsys *ss);\nstruct cgroup_subsys_state *cgroup_get_e_css(struct cgroup *cgroup,\n\t\t\t\t\t     struct cgroup_subsys *ss);\nstruct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,\n\t\t\t\t\t\t       struct cgroup_subsys *ss);\n\nstruct cgroup *cgroup_get_from_path(const char *path);\nstruct cgroup *cgroup_get_from_fd(int fd);\nstruct cgroup *cgroup_v1v2_get_from_fd(int fd);\n\nint cgroup_attach_task_all(struct task_struct *from, struct task_struct *);\nint cgroup_transfer_tasks(struct cgroup *to, struct cgroup *from);\n\nint cgroup_add_dfl_cftypes(struct cgroup_subsys *ss, struct cftype *cfts);\nint cgroup_add_legacy_cftypes(struct cgroup_subsys *ss, struct cftype *cfts);\nint cgroup_rm_cftypes(struct cftype *cfts);\nvoid cgroup_file_notify(struct cgroup_file *cfile);\nvoid cgroup_file_show(struct cgroup_file *cfile, bool show);\n\nint cgroupstats_build(struct cgroupstats *stats, struct dentry *dentry);\nint proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,\n\t\t     struct pid *pid, struct task_struct *tsk);\n\nvoid cgroup_fork(struct task_struct *p);\nextern int cgroup_can_fork(struct task_struct *p,\n\t\t\t   struct kernel_clone_args *kargs);\nextern void cgroup_cancel_fork(struct task_struct *p,\n\t\t\t       struct kernel_clone_args *kargs);\nextern void cgroup_post_fork(struct task_struct *p,\n\t\t\t     struct kernel_clone_args *kargs);\nvoid cgroup_exit(struct task_struct *p);\nvoid cgroup_release(struct task_struct *p);\nvoid cgroup_free(struct task_struct *p);\n\nint cgroup_init_early(void);\nint cgroup_init(void);\n\nint cgroup_parse_float(const char *input, unsigned dec_shift, s64 *v);\n\n \n\nstruct cgroup_subsys_state *css_next_child(struct cgroup_subsys_state *pos,\n\t\t\t\t\t   struct cgroup_subsys_state *parent);\nstruct cgroup_subsys_state *css_next_descendant_pre(struct cgroup_subsys_state *pos,\n\t\t\t\t\t\t    struct cgroup_subsys_state *css);\nstruct cgroup_subsys_state *css_rightmost_descendant(struct cgroup_subsys_state *pos);\nstruct cgroup_subsys_state *css_next_descendant_post(struct cgroup_subsys_state *pos,\n\t\t\t\t\t\t     struct cgroup_subsys_state *css);\n\nstruct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp);\nstruct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset,\n\t\t\t\t\tstruct cgroup_subsys_state **dst_cssp);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it);\nstruct task_struct *css_task_iter_next(struct css_task_iter *it);\nvoid css_task_iter_end(struct css_task_iter *it);\n\n \n#define css_for_each_child(pos, parent)\t\t\t\t\t\\\n\tfor ((pos) = css_next_child(NULL, (parent)); (pos);\t\t\\\n\t     (pos) = css_next_child((pos), (parent)))\n\n \n#define css_for_each_descendant_pre(pos, css)\t\t\t\t\\\n\tfor ((pos) = css_next_descendant_pre(NULL, (css)); (pos);\t\\\n\t     (pos) = css_next_descendant_pre((pos), (css)))\n\n \n#define css_for_each_descendant_post(pos, css)\t\t\t\t\\\n\tfor ((pos) = css_next_descendant_post(NULL, (css)); (pos);\t\\\n\t     (pos) = css_next_descendant_post((pos), (css)))\n\n \n#define cgroup_taskset_for_each(task, dst_css, tset)\t\t\t\\\n\tfor ((task) = cgroup_taskset_first((tset), &(dst_css));\t\t\\\n\t     (task);\t\t\t\t\t\t\t\\\n\t     (task) = cgroup_taskset_next((tset), &(dst_css)))\n\n \n#define cgroup_taskset_for_each_leader(leader, dst_css, tset)\t\t\\\n\tfor ((leader) = cgroup_taskset_first((tset), &(dst_css));\t\\\n\t     (leader);\t\t\t\t\t\t\t\\\n\t     (leader) = cgroup_taskset_next((tset), &(dst_css)))\t\\\n\t\tif ((leader) != (leader)->group_leader)\t\t\t\\\n\t\t\t;\t\t\t\t\t\t\\\n\t\telse\n\n \n\n#ifdef CONFIG_DEBUG_CGROUP_REF\nvoid css_get(struct cgroup_subsys_state *css);\nvoid css_get_many(struct cgroup_subsys_state *css, unsigned int n);\nbool css_tryget(struct cgroup_subsys_state *css);\nbool css_tryget_online(struct cgroup_subsys_state *css);\nvoid css_put(struct cgroup_subsys_state *css);\nvoid css_put_many(struct cgroup_subsys_state *css, unsigned int n);\n#else\n#define CGROUP_REF_FN_ATTRS\tstatic inline\n#define CGROUP_REF_EXPORT(fn)\n#include <linux/cgroup_refcnt.h>\n#endif\n\nstatic inline u64 cgroup_id(const struct cgroup *cgrp)\n{\n\treturn cgrp->kn->id;\n}\n\n \nstatic inline bool css_is_dying(struct cgroup_subsys_state *css)\n{\n\treturn !(css->flags & CSS_NO_REF) && percpu_ref_is_dying(&css->refcnt);\n}\n\nstatic inline void cgroup_get(struct cgroup *cgrp)\n{\n\tcss_get(&cgrp->self);\n}\n\nstatic inline bool cgroup_tryget(struct cgroup *cgrp)\n{\n\treturn css_tryget(&cgrp->self);\n}\n\nstatic inline void cgroup_put(struct cgroup *cgrp)\n{\n\tcss_put(&cgrp->self);\n}\n\nextern struct mutex cgroup_mutex;\n\nstatic inline void cgroup_lock(void)\n{\n\tmutex_lock(&cgroup_mutex);\n}\n\nstatic inline void cgroup_unlock(void)\n{\n\tmutex_unlock(&cgroup_mutex);\n}\n\n \n#ifdef CONFIG_PROVE_RCU\nextern spinlock_t css_set_lock;\n#define task_css_set_check(task, __c)\t\t\t\t\t\\\n\trcu_dereference_check((task)->cgroups,\t\t\t\t\\\n\t\trcu_read_lock_sched_held() ||\t\t\t\t\\\n\t\tlockdep_is_held(&cgroup_mutex) ||\t\t\t\\\n\t\tlockdep_is_held(&css_set_lock) ||\t\t\t\\\n\t\t((task)->flags & PF_EXITING) || (__c))\n#else\n#define task_css_set_check(task, __c)\t\t\t\t\t\\\n\trcu_dereference((task)->cgroups)\n#endif\n\n \n#define task_css_check(task, subsys_id, __c)\t\t\t\t\\\n\ttask_css_set_check((task), (__c))->subsys[(subsys_id)]\n\n \nstatic inline struct css_set *task_css_set(struct task_struct *task)\n{\n\treturn task_css_set_check(task, false);\n}\n\n \nstatic inline struct cgroup_subsys_state *task_css(struct task_struct *task,\n\t\t\t\t\t\t   int subsys_id)\n{\n\treturn task_css_check(task, subsys_id, false);\n}\n\n \nstatic inline struct cgroup_subsys_state *\ntask_get_css(struct task_struct *task, int subsys_id)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\twhile (true) {\n\t\tcss = task_css(task, subsys_id);\n\t\t \n\t\tif (likely(css_tryget(css)))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\trcu_read_unlock();\n\treturn css;\n}\n\n \nstatic inline bool task_css_is_root(struct task_struct *task, int subsys_id)\n{\n\treturn task_css_check(task, subsys_id, true) ==\n\t\tinit_css_set.subsys[subsys_id];\n}\n\nstatic inline struct cgroup *task_cgroup(struct task_struct *task,\n\t\t\t\t\t int subsys_id)\n{\n\treturn task_css(task, subsys_id)->cgroup;\n}\n\nstatic inline struct cgroup *task_dfl_cgroup(struct task_struct *task)\n{\n\treturn task_css_set(task)->dfl_cgrp;\n}\n\nstatic inline struct cgroup *cgroup_parent(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *parent_css = cgrp->self.parent;\n\n\tif (parent_css)\n\t\treturn container_of(parent_css, struct cgroup, self);\n\treturn NULL;\n}\n\n \nstatic inline bool cgroup_is_descendant(struct cgroup *cgrp,\n\t\t\t\t\tstruct cgroup *ancestor)\n{\n\tif (cgrp->root != ancestor->root || cgrp->level < ancestor->level)\n\t\treturn false;\n\treturn cgrp->ancestors[ancestor->level] == ancestor;\n}\n\n \nstatic inline struct cgroup *cgroup_ancestor(struct cgroup *cgrp,\n\t\t\t\t\t     int ancestor_level)\n{\n\tif (ancestor_level < 0 || ancestor_level > cgrp->level)\n\t\treturn NULL;\n\treturn cgrp->ancestors[ancestor_level];\n}\n\n \nstatic inline bool task_under_cgroup_hierarchy(struct task_struct *task,\n\t\t\t\t\t       struct cgroup *ancestor)\n{\n\tstruct css_set *cset = task_css_set(task);\n\n\treturn cgroup_is_descendant(cset->dfl_cgrp, ancestor);\n}\n\n \nstatic inline bool cgroup_is_populated(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets + cgrp->nr_populated_domain_children +\n\t\tcgrp->nr_populated_threaded_children;\n}\n\n \nstatic inline ino_t cgroup_ino(struct cgroup *cgrp)\n{\n\treturn kernfs_ino(cgrp->kn);\n}\n\n \nstatic inline struct cftype *of_cft(struct kernfs_open_file *of)\n{\n\treturn of->kn->priv;\n}\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of);\n\n \nstatic inline struct cftype *seq_cft(struct seq_file *seq)\n{\n\treturn of_cft(seq->private);\n}\n\nstatic inline struct cgroup_subsys_state *seq_css(struct seq_file *seq)\n{\n\treturn of_css(seq->private);\n}\n\n \n\nstatic inline int cgroup_name(struct cgroup *cgrp, char *buf, size_t buflen)\n{\n\treturn kernfs_name(cgrp->kn, buf, buflen);\n}\n\nstatic inline int cgroup_path(struct cgroup *cgrp, char *buf, size_t buflen)\n{\n\treturn kernfs_path(cgrp->kn, buf, buflen);\n}\n\nstatic inline void pr_cont_cgroup_name(struct cgroup *cgrp)\n{\n\tpr_cont_kernfs_name(cgrp->kn);\n}\n\nstatic inline void pr_cont_cgroup_path(struct cgroup *cgrp)\n{\n\tpr_cont_kernfs_path(cgrp->kn);\n}\n\nbool cgroup_psi_enabled(void);\n\nstatic inline void cgroup_init_kthreadd(void)\n{\n\t \n\tcurrent->no_cgroup_migration = 1;\n}\n\nstatic inline void cgroup_kthread_ready(void)\n{\n\t \n\tcurrent->no_cgroup_migration = 0;\n}\n\nvoid cgroup_path_from_kernfs_id(u64 id, char *buf, size_t buflen);\nstruct cgroup *cgroup_get_from_id(u64 id);\n#else  \n\nstruct cgroup_subsys_state;\nstruct cgroup;\n\nstatic inline u64 cgroup_id(const struct cgroup *cgrp) { return 1; }\nstatic inline void css_get(struct cgroup_subsys_state *css) {}\nstatic inline void css_put(struct cgroup_subsys_state *css) {}\nstatic inline void cgroup_lock(void) {}\nstatic inline void cgroup_unlock(void) {}\nstatic inline int cgroup_attach_task_all(struct task_struct *from,\n\t\t\t\t\t struct task_struct *t) { return 0; }\nstatic inline int cgroupstats_build(struct cgroupstats *stats,\n\t\t\t\t    struct dentry *dentry) { return -EINVAL; }\n\nstatic inline void cgroup_fork(struct task_struct *p) {}\nstatic inline int cgroup_can_fork(struct task_struct *p,\n\t\t\t\t  struct kernel_clone_args *kargs) { return 0; }\nstatic inline void cgroup_cancel_fork(struct task_struct *p,\n\t\t\t\t      struct kernel_clone_args *kargs) {}\nstatic inline void cgroup_post_fork(struct task_struct *p,\n\t\t\t\t    struct kernel_clone_args *kargs) {}\nstatic inline void cgroup_exit(struct task_struct *p) {}\nstatic inline void cgroup_release(struct task_struct *p) {}\nstatic inline void cgroup_free(struct task_struct *p) {}\n\nstatic inline int cgroup_init_early(void) { return 0; }\nstatic inline int cgroup_init(void) { return 0; }\nstatic inline void cgroup_init_kthreadd(void) {}\nstatic inline void cgroup_kthread_ready(void) {}\n\nstatic inline struct cgroup *cgroup_parent(struct cgroup *cgrp)\n{\n\treturn NULL;\n}\n\nstatic inline bool cgroup_psi_enabled(void)\n{\n\treturn false;\n}\n\nstatic inline bool task_under_cgroup_hierarchy(struct task_struct *task,\n\t\t\t\t\t       struct cgroup *ancestor)\n{\n\treturn true;\n}\n\nstatic inline void cgroup_path_from_kernfs_id(u64 id, char *buf, size_t buflen)\n{}\n#endif  \n\n#ifdef CONFIG_CGROUPS\n \nvoid cgroup_rstat_updated(struct cgroup *cgrp, int cpu);\nvoid cgroup_rstat_flush(struct cgroup *cgrp);\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp);\nvoid cgroup_rstat_flush_release(void);\n\n \n#ifdef CONFIG_CGROUP_CPUACCT\nvoid cpuacct_charge(struct task_struct *tsk, u64 cputime);\nvoid cpuacct_account_field(struct task_struct *tsk, int index, u64 val);\n#else\nstatic inline void cpuacct_charge(struct task_struct *tsk, u64 cputime) {}\nstatic inline void cpuacct_account_field(struct task_struct *tsk, int index,\n\t\t\t\t\t u64 val) {}\n#endif\n\nvoid __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec);\nvoid __cgroup_account_cputime_field(struct cgroup *cgrp,\n\t\t\t\t    enum cpu_usage_stat index, u64 delta_exec);\n\nstatic inline void cgroup_account_cputime(struct task_struct *task,\n\t\t\t\t\t  u64 delta_exec)\n{\n\tstruct cgroup *cgrp;\n\n\tcpuacct_charge(task, delta_exec);\n\n\tcgrp = task_dfl_cgroup(task);\n\tif (cgroup_parent(cgrp))\n\t\t__cgroup_account_cputime(cgrp, delta_exec);\n}\n\nstatic inline void cgroup_account_cputime_field(struct task_struct *task,\n\t\t\t\t\t\tenum cpu_usage_stat index,\n\t\t\t\t\t\tu64 delta_exec)\n{\n\tstruct cgroup *cgrp;\n\n\tcpuacct_account_field(task, index, delta_exec);\n\n\tcgrp = task_dfl_cgroup(task);\n\tif (cgroup_parent(cgrp))\n\t\t__cgroup_account_cputime_field(cgrp, index, delta_exec);\n}\n\n#else\t \n\nstatic inline void cgroup_account_cputime(struct task_struct *task,\n\t\t\t\t\t  u64 delta_exec) {}\nstatic inline void cgroup_account_cputime_field(struct task_struct *task,\n\t\t\t\t\t\tenum cpu_usage_stat index,\n\t\t\t\t\t\tu64 delta_exec) {}\n\n#endif\t \n\n \n#ifdef CONFIG_SOCK_CGROUP_DATA\n\nvoid cgroup_sk_alloc(struct sock_cgroup_data *skcd);\nvoid cgroup_sk_clone(struct sock_cgroup_data *skcd);\nvoid cgroup_sk_free(struct sock_cgroup_data *skcd);\n\nstatic inline struct cgroup *sock_cgroup_ptr(struct sock_cgroup_data *skcd)\n{\n\treturn skcd->cgroup;\n}\n\n#else\t \n\nstatic inline void cgroup_sk_alloc(struct sock_cgroup_data *skcd) {}\nstatic inline void cgroup_sk_clone(struct sock_cgroup_data *skcd) {}\nstatic inline void cgroup_sk_free(struct sock_cgroup_data *skcd) {}\n\n#endif\t \n\nstruct cgroup_namespace {\n\tstruct ns_common\tns;\n\tstruct user_namespace\t*user_ns;\n\tstruct ucounts\t\t*ucounts;\n\tstruct css_set          *root_cset;\n};\n\nextern struct cgroup_namespace init_cgroup_ns;\n\n#ifdef CONFIG_CGROUPS\n\nvoid free_cgroup_ns(struct cgroup_namespace *ns);\n\nstruct cgroup_namespace *copy_cgroup_ns(unsigned long flags,\n\t\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\t\tstruct cgroup_namespace *old_ns);\n\nint cgroup_path_ns(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t   struct cgroup_namespace *ns);\n\n#else  \n\nstatic inline void free_cgroup_ns(struct cgroup_namespace *ns) { }\nstatic inline struct cgroup_namespace *\ncopy_cgroup_ns(unsigned long flags, struct user_namespace *user_ns,\n\t       struct cgroup_namespace *old_ns)\n{\n\treturn old_ns;\n}\n\n#endif  \n\nstatic inline void get_cgroup_ns(struct cgroup_namespace *ns)\n{\n\tif (ns)\n\t\trefcount_inc(&ns->ns.count);\n}\n\nstatic inline void put_cgroup_ns(struct cgroup_namespace *ns)\n{\n\tif (ns && refcount_dec_and_test(&ns->ns.count))\n\t\tfree_cgroup_ns(ns);\n}\n\n#ifdef CONFIG_CGROUPS\n\nvoid cgroup_enter_frozen(void);\nvoid cgroup_leave_frozen(bool always_leave);\nvoid cgroup_update_frozen(struct cgroup *cgrp);\nvoid cgroup_freeze(struct cgroup *cgrp, bool freeze);\nvoid cgroup_freezer_migrate_task(struct task_struct *task, struct cgroup *src,\n\t\t\t\t struct cgroup *dst);\n\nstatic inline bool cgroup_task_frozen(struct task_struct *task)\n{\n\treturn task->frozen;\n}\n\n#else  \n\nstatic inline void cgroup_enter_frozen(void) { }\nstatic inline void cgroup_leave_frozen(bool always_leave) { }\nstatic inline bool cgroup_task_frozen(struct task_struct *task)\n{\n\treturn false;\n}\n\n#endif  \n\n#ifdef CONFIG_CGROUP_BPF\nstatic inline void cgroup_bpf_get(struct cgroup *cgrp)\n{\n\tpercpu_ref_get(&cgrp->bpf.refcnt);\n}\n\nstatic inline void cgroup_bpf_put(struct cgroup *cgrp)\n{\n\tpercpu_ref_put(&cgrp->bpf.refcnt);\n}\n\n#else  \n\nstatic inline void cgroup_bpf_get(struct cgroup *cgrp) {}\nstatic inline void cgroup_bpf_put(struct cgroup *cgrp) {}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}