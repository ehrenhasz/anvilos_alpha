{
  "module_name": "if_bridge.h",
  "hash_id": "447f46660fdd568503e51bc095595745eff5ebb4b217229a3c2c65f125e503e4",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/if_bridge.h",
  "human_readable_source": " \n \n#ifndef _LINUX_IF_BRIDGE_H\n#define _LINUX_IF_BRIDGE_H\n\n\n#include <linux/netdevice.h>\n#include <uapi/linux/if_bridge.h>\n#include <linux/bitops.h>\n\nstruct br_ip {\n\tunion {\n\t\t__be32\tip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct in6_addr ip6;\n#endif\n\t} src;\n\tunion {\n\t\t__be32\tip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct in6_addr ip6;\n#endif\n\t\tunsigned char\tmac_addr[ETH_ALEN];\n\t} dst;\n\t__be16\t\tproto;\n\t__u16           vid;\n};\n\nstruct br_ip_list {\n\tstruct list_head list;\n\tstruct br_ip addr;\n};\n\n#define BR_HAIRPIN_MODE\t\tBIT(0)\n#define BR_BPDU_GUARD\t\tBIT(1)\n#define BR_ROOT_BLOCK\t\tBIT(2)\n#define BR_MULTICAST_FAST_LEAVE\tBIT(3)\n#define BR_ADMIN_COST\t\tBIT(4)\n#define BR_LEARNING\t\tBIT(5)\n#define BR_FLOOD\t\tBIT(6)\n#define BR_AUTO_MASK\t\t(BR_FLOOD | BR_LEARNING)\n#define BR_PROMISC\t\tBIT(7)\n#define BR_PROXYARP\t\tBIT(8)\n#define BR_LEARNING_SYNC\tBIT(9)\n#define BR_PROXYARP_WIFI\tBIT(10)\n#define BR_MCAST_FLOOD\t\tBIT(11)\n#define BR_MULTICAST_TO_UNICAST\tBIT(12)\n#define BR_VLAN_TUNNEL\t\tBIT(13)\n#define BR_BCAST_FLOOD\t\tBIT(14)\n#define BR_NEIGH_SUPPRESS\tBIT(15)\n#define BR_ISOLATED\t\tBIT(16)\n#define BR_MRP_AWARE\t\tBIT(17)\n#define BR_MRP_LOST_CONT\tBIT(18)\n#define BR_MRP_LOST_IN_CONT\tBIT(19)\n#define BR_TX_FWD_OFFLOAD\tBIT(20)\n#define BR_PORT_LOCKED\t\tBIT(21)\n#define BR_PORT_MAB\t\tBIT(22)\n#define BR_NEIGH_VLAN_SUPPRESS\tBIT(23)\n\n#define BR_DEFAULT_AGEING_TIME\t(300 * HZ)\n\nstruct net_bridge;\nvoid brioctl_set(int (*hook)(struct net *net, struct net_bridge *br,\n\t\t\t     unsigned int cmd, struct ifreq *ifr,\n\t\t\t     void __user *uarg));\nint br_ioctl_call(struct net *net, struct net_bridge *br, unsigned int cmd,\n\t\t  struct ifreq *ifr, void __user *uarg);\n\n#if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)\nint br_multicast_list_adjacent(struct net_device *dev,\n\t\t\t       struct list_head *br_ip_list);\nbool br_multicast_has_querier_anywhere(struct net_device *dev, int proto);\nbool br_multicast_has_querier_adjacent(struct net_device *dev, int proto);\nbool br_multicast_has_router_adjacent(struct net_device *dev, int proto);\nbool br_multicast_enabled(const struct net_device *dev);\nbool br_multicast_router(const struct net_device *dev);\n#else\nstatic inline int br_multicast_list_adjacent(struct net_device *dev,\n\t\t\t\t\t     struct list_head *br_ip_list)\n{\n\treturn 0;\n}\nstatic inline bool br_multicast_has_querier_anywhere(struct net_device *dev,\n\t\t\t\t\t\t     int proto)\n{\n\treturn false;\n}\nstatic inline bool br_multicast_has_querier_adjacent(struct net_device *dev,\n\t\t\t\t\t\t     int proto)\n{\n\treturn false;\n}\n\nstatic inline bool br_multicast_has_router_adjacent(struct net_device *dev,\n\t\t\t\t\t\t    int proto)\n{\n\treturn true;\n}\n\nstatic inline bool br_multicast_enabled(const struct net_device *dev)\n{\n\treturn false;\n}\nstatic inline bool br_multicast_router(const struct net_device *dev)\n{\n\treturn false;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_VLAN_FILTERING)\nbool br_vlan_enabled(const struct net_device *dev);\nint br_vlan_get_pvid(const struct net_device *dev, u16 *p_pvid);\nint br_vlan_get_pvid_rcu(const struct net_device *dev, u16 *p_pvid);\nint br_vlan_get_proto(const struct net_device *dev, u16 *p_proto);\nint br_vlan_get_info(const struct net_device *dev, u16 vid,\n\t\t     struct bridge_vlan_info *p_vinfo);\nint br_vlan_get_info_rcu(const struct net_device *dev, u16 vid,\n\t\t\t struct bridge_vlan_info *p_vinfo);\nbool br_mst_enabled(const struct net_device *dev);\nint br_mst_get_info(const struct net_device *dev, u16 msti, unsigned long *vids);\nint br_mst_get_state(const struct net_device *dev, u16 msti, u8 *state);\n#else\nstatic inline bool br_vlan_enabled(const struct net_device *dev)\n{\n\treturn false;\n}\n\nstatic inline int br_vlan_get_pvid(const struct net_device *dev, u16 *p_pvid)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int br_vlan_get_proto(const struct net_device *dev, u16 *p_proto)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int br_vlan_get_pvid_rcu(const struct net_device *dev, u16 *p_pvid)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int br_vlan_get_info(const struct net_device *dev, u16 vid,\n\t\t\t\t   struct bridge_vlan_info *p_vinfo)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int br_vlan_get_info_rcu(const struct net_device *dev, u16 vid,\n\t\t\t\t       struct bridge_vlan_info *p_vinfo)\n{\n\treturn -EINVAL;\n}\n\nstatic inline bool br_mst_enabled(const struct net_device *dev)\n{\n\treturn false;\n}\n\nstatic inline int br_mst_get_info(const struct net_device *dev, u16 msti,\n\t\t\t\t  unsigned long *vids)\n{\n\treturn -EINVAL;\n}\nstatic inline int br_mst_get_state(const struct net_device *dev, u16 msti,\n\t\t\t\t   u8 *state)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_BRIDGE)\nstruct net_device *br_fdb_find_port(const struct net_device *br_dev,\n\t\t\t\t    const unsigned char *addr,\n\t\t\t\t    __u16 vid);\nvoid br_fdb_clear_offload(const struct net_device *dev, u16 vid);\nbool br_port_flag_is_set(const struct net_device *dev, unsigned long flag);\nu8 br_port_get_stp_state(const struct net_device *dev);\nclock_t br_get_ageing_time(const struct net_device *br_dev);\n#else\nstatic inline struct net_device *\nbr_fdb_find_port(const struct net_device *br_dev,\n\t\t const unsigned char *addr,\n\t\t __u16 vid)\n{\n\treturn NULL;\n}\n\nstatic inline void br_fdb_clear_offload(const struct net_device *dev, u16 vid)\n{\n}\n\nstatic inline bool\nbr_port_flag_is_set(const struct net_device *dev, unsigned long flag)\n{\n\treturn false;\n}\n\nstatic inline u8 br_port_get_stp_state(const struct net_device *dev)\n{\n\treturn BR_STATE_DISABLED;\n}\n\nstatic inline clock_t br_get_ageing_time(const struct net_device *br_dev)\n{\n\treturn 0;\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}