{
  "module_name": "cpufreq.h",
  "hash_id": "3369059b78307672b09f51a81ae403e9e20ba1e9988896c04cc7ec2a7bc4f818",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/cpufreq.h",
  "human_readable_source": " \n \n#ifndef _LINUX_CPUFREQ_H\n#define _LINUX_CPUFREQ_H\n\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/kobject.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_qos.h>\n#include <linux/spinlock.h>\n#include <linux/sysfs.h>\n#include <linux/minmax.h>\n\n \n \n\n#define CPUFREQ_ETERNAL\t\t\t(-1)\n#define CPUFREQ_NAME_LEN\t\t16\n \n#define CPUFREQ_NAME_PLEN\t\t(CPUFREQ_NAME_LEN + 1)\n\nstruct cpufreq_governor;\n\nenum cpufreq_table_sorting {\n\tCPUFREQ_TABLE_UNSORTED,\n\tCPUFREQ_TABLE_SORTED_ASCENDING,\n\tCPUFREQ_TABLE_SORTED_DESCENDING\n};\n\nstruct cpufreq_cpuinfo {\n\tunsigned int\t\tmax_freq;\n\tunsigned int\t\tmin_freq;\n\n\t \n\tunsigned int\t\ttransition_latency;\n};\n\nstruct cpufreq_policy {\n\t \n\tcpumask_var_t\t\tcpus;\t \n\tcpumask_var_t\t\trelated_cpus;  \n\tcpumask_var_t\t\treal_cpus;  \n\n\tunsigned int\t\tshared_type;  \n\tunsigned int\t\tcpu;     \n\n\tstruct clk\t\t*clk;\n\tstruct cpufreq_cpuinfo\tcpuinfo; \n\n\tunsigned int\t\tmin;     \n\tunsigned int\t\tmax;     \n\tunsigned int\t\tcur;     \n\tunsigned int\t\tsuspend_freq;  \n\n\tunsigned int\t\tpolicy;  \n\tunsigned int\t\tlast_policy;  \n\tstruct cpufreq_governor\t*governor;  \n\tvoid\t\t\t*governor_data;\n\tchar\t\t\tlast_governor[CPUFREQ_NAME_LEN];  \n\n\tstruct work_struct\tupdate;  \n\n\tstruct freq_constraints\tconstraints;\n\tstruct freq_qos_request\t*min_freq_req;\n\tstruct freq_qos_request\t*max_freq_req;\n\n\tstruct cpufreq_frequency_table\t*freq_table;\n\tenum cpufreq_table_sorting freq_table_sorted;\n\n\tstruct list_head        policy_list;\n\tstruct kobject\t\tkobj;\n\tstruct completion\tkobj_unregister;\n\n\t \n\tstruct rw_semaphore\trwsem;\n\n\t \n\tbool\t\t\tfast_switch_possible;\n\tbool\t\t\tfast_switch_enabled;\n\n\t \n\tbool\t\t\tstrict_target;\n\n\t \n\tbool\t\t\tefficiencies_available;\n\n\t \n\tunsigned int\t\ttransition_delay_us;\n\n\t \n\tbool\t\t\tdvfs_possible_from_any_cpu;\n\n\t \n\tbool\t\t\tboost_enabled;\n\n\t  \n\tunsigned int cached_target_freq;\n\tunsigned int cached_resolved_idx;\n\n\t \n\tbool\t\t\ttransition_ongoing;  \n\tspinlock_t\t\ttransition_lock;\n\twait_queue_head_t\ttransition_wait;\n\tstruct task_struct\t*transition_task;  \n\n\t \n\tstruct cpufreq_stats\t*stats;\n\n\t \n\tvoid\t\t\t*driver_data;\n\n\t \n\tstruct thermal_cooling_device *cdev;\n\n\tstruct notifier_block nb_min;\n\tstruct notifier_block nb_max;\n};\n\n \nstruct cpufreq_policy_data {\n\tstruct cpufreq_cpuinfo\t\tcpuinfo;\n\tstruct cpufreq_frequency_table\t*freq_table;\n\tunsigned int\t\t\tcpu;\n\tunsigned int\t\t\tmin;     \n\tunsigned int\t\t\tmax;     \n};\n\nstruct cpufreq_freqs {\n\tstruct cpufreq_policy *policy;\n\tunsigned int old;\n\tunsigned int new;\n\tu8 flags;\t\t \n};\n\n \n#define CPUFREQ_SHARED_TYPE_NONE (0)  \n#define CPUFREQ_SHARED_TYPE_HW\t (1)  \n#define CPUFREQ_SHARED_TYPE_ALL\t (2)  \n#define CPUFREQ_SHARED_TYPE_ANY\t (3)  \n\n#ifdef CONFIG_CPU_FREQ\nstruct cpufreq_policy *cpufreq_cpu_get_raw(unsigned int cpu);\nstruct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);\nvoid cpufreq_cpu_put(struct cpufreq_policy *policy);\n#else\nstatic inline struct cpufreq_policy *cpufreq_cpu_get_raw(unsigned int cpu)\n{\n\treturn NULL;\n}\nstatic inline struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)\n{\n\treturn NULL;\n}\nstatic inline void cpufreq_cpu_put(struct cpufreq_policy *policy) { }\n#endif\n\nstatic inline bool policy_is_inactive(struct cpufreq_policy *policy)\n{\n\treturn cpumask_empty(policy->cpus);\n}\n\nstatic inline bool policy_is_shared(struct cpufreq_policy *policy)\n{\n\treturn cpumask_weight(policy->cpus) > 1;\n}\n\n#ifdef CONFIG_CPU_FREQ\nunsigned int cpufreq_get(unsigned int cpu);\nunsigned int cpufreq_quick_get(unsigned int cpu);\nunsigned int cpufreq_quick_get_max(unsigned int cpu);\nunsigned int cpufreq_get_hw_max_freq(unsigned int cpu);\nvoid disable_cpufreq(void);\n\nu64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);\n\nstruct cpufreq_policy *cpufreq_cpu_acquire(unsigned int cpu);\nvoid cpufreq_cpu_release(struct cpufreq_policy *policy);\nint cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);\nvoid refresh_frequency_limits(struct cpufreq_policy *policy);\nvoid cpufreq_update_policy(unsigned int cpu);\nvoid cpufreq_update_limits(unsigned int cpu);\nbool have_governor_per_policy(void);\nbool cpufreq_supports_freq_invariance(void);\nstruct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);\nvoid cpufreq_enable_fast_switch(struct cpufreq_policy *policy);\nvoid cpufreq_disable_fast_switch(struct cpufreq_policy *policy);\nbool has_target_index(void);\n#else\nstatic inline unsigned int cpufreq_get(unsigned int cpu)\n{\n\treturn 0;\n}\nstatic inline unsigned int cpufreq_quick_get(unsigned int cpu)\n{\n\treturn 0;\n}\nstatic inline unsigned int cpufreq_quick_get_max(unsigned int cpu)\n{\n\treturn 0;\n}\nstatic inline unsigned int cpufreq_get_hw_max_freq(unsigned int cpu)\n{\n\treturn 0;\n}\nstatic inline bool cpufreq_supports_freq_invariance(void)\n{\n\treturn false;\n}\nstatic inline void disable_cpufreq(void) { }\n#endif\n\n#ifdef CONFIG_CPU_FREQ_STAT\nvoid cpufreq_stats_create_table(struct cpufreq_policy *policy);\nvoid cpufreq_stats_free_table(struct cpufreq_policy *policy);\nvoid cpufreq_stats_record_transition(struct cpufreq_policy *policy,\n\t\t\t\t     unsigned int new_freq);\n#else\nstatic inline void cpufreq_stats_create_table(struct cpufreq_policy *policy) { }\nstatic inline void cpufreq_stats_free_table(struct cpufreq_policy *policy) { }\nstatic inline void cpufreq_stats_record_transition(struct cpufreq_policy *policy,\n\t\t\t\t\t\t   unsigned int new_freq) { }\n#endif  \n\n \n\n#define CPUFREQ_RELATION_L 0   \n#define CPUFREQ_RELATION_H 1   \n#define CPUFREQ_RELATION_C 2   \n \n#define CPUFREQ_RELATION_E BIT(2)  \n\n#define CPUFREQ_RELATION_LE (CPUFREQ_RELATION_L | CPUFREQ_RELATION_E)\n#define CPUFREQ_RELATION_HE (CPUFREQ_RELATION_H | CPUFREQ_RELATION_E)\n#define CPUFREQ_RELATION_CE (CPUFREQ_RELATION_C | CPUFREQ_RELATION_E)\n\nstruct freq_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct cpufreq_policy *, char *);\n\tssize_t (*store)(struct cpufreq_policy *, const char *, size_t count);\n};\n\n#define cpufreq_freq_attr_ro(_name)\t\t\\\nstatic struct freq_attr _name =\t\t\t\\\n__ATTR(_name, 0444, show_##_name, NULL)\n\n#define cpufreq_freq_attr_ro_perm(_name, _perm)\t\\\nstatic struct freq_attr _name =\t\t\t\\\n__ATTR(_name, _perm, show_##_name, NULL)\n\n#define cpufreq_freq_attr_rw(_name)\t\t\\\nstatic struct freq_attr _name =\t\t\t\\\n__ATTR(_name, 0644, show_##_name, store_##_name)\n\n#define cpufreq_freq_attr_wo(_name)\t\t\\\nstatic struct freq_attr _name =\t\t\t\\\n__ATTR(_name, 0200, NULL, store_##_name)\n\n#define define_one_global_ro(_name)\t\t\\\nstatic struct kobj_attribute _name =\t\t\\\n__ATTR(_name, 0444, show_##_name, NULL)\n\n#define define_one_global_rw(_name)\t\t\\\nstatic struct kobj_attribute _name =\t\t\\\n__ATTR(_name, 0644, show_##_name, store_##_name)\n\n\nstruct cpufreq_driver {\n\tchar\t\tname[CPUFREQ_NAME_LEN];\n\tu16\t\tflags;\n\tvoid\t\t*driver_data;\n\n\t \n\tint\t\t(*init)(struct cpufreq_policy *policy);\n\tint\t\t(*verify)(struct cpufreq_policy_data *policy);\n\n\t \n\tint\t\t(*setpolicy)(struct cpufreq_policy *policy);\n\n\tint\t\t(*target)(struct cpufreq_policy *policy,\n\t\t\t\t  unsigned int target_freq,\n\t\t\t\t  unsigned int relation);\t \n\tint\t\t(*target_index)(struct cpufreq_policy *policy,\n\t\t\t\t\tunsigned int index);\n\tunsigned int\t(*fast_switch)(struct cpufreq_policy *policy,\n\t\t\t\t       unsigned int target_freq);\n\t \n\tvoid\t\t(*adjust_perf)(unsigned int cpu,\n\t\t\t\t       unsigned long min_perf,\n\t\t\t\t       unsigned long target_perf,\n\t\t\t\t       unsigned long capacity);\n\n\t \n\tunsigned int\t(*get_intermediate)(struct cpufreq_policy *policy,\n\t\t\t\t\t    unsigned int index);\n\tint\t\t(*target_intermediate)(struct cpufreq_policy *policy,\n\t\t\t\t\t       unsigned int index);\n\n\t \n\tunsigned int\t(*get)(unsigned int cpu);\n\n\t \n\tvoid\t\t(*update_limits)(unsigned int cpu);\n\n\t \n\tint\t\t(*bios_limit)(int cpu, unsigned int *limit);\n\n\tint\t\t(*online)(struct cpufreq_policy *policy);\n\tint\t\t(*offline)(struct cpufreq_policy *policy);\n\tint\t\t(*exit)(struct cpufreq_policy *policy);\n\tint\t\t(*suspend)(struct cpufreq_policy *policy);\n\tint\t\t(*resume)(struct cpufreq_policy *policy);\n\n\t \n\tvoid\t\t(*ready)(struct cpufreq_policy *policy);\n\n\tstruct freq_attr **attr;\n\n\t \n\tbool\t\tboost_enabled;\n\tint\t\t(*set_boost)(struct cpufreq_policy *policy, int state);\n\n\t \n\tvoid\t\t(*register_em)(struct cpufreq_policy *policy);\n};\n\n \n\n \n#define CPUFREQ_NEED_UPDATE_LIMITS\t\tBIT(0)\n\n \n#define CPUFREQ_CONST_LOOPS\t\t\tBIT(1)\n\n \n#define CPUFREQ_IS_COOLING_DEV\t\t\tBIT(2)\n\n \n#define CPUFREQ_HAVE_GOVERNOR_PER_POLICY\tBIT(3)\n\n \n#define CPUFREQ_ASYNC_NOTIFICATION\t\tBIT(4)\n\n \n#define CPUFREQ_NEED_INITIAL_FREQ_CHECK\tBIT(5)\n\n \n#define CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING\tBIT(6)\n\nint cpufreq_register_driver(struct cpufreq_driver *driver_data);\nvoid cpufreq_unregister_driver(struct cpufreq_driver *driver_data);\n\nbool cpufreq_driver_test_flags(u16 flags);\nconst char *cpufreq_get_current_driver(void);\nvoid *cpufreq_get_driver_data(void);\n\nstatic inline int cpufreq_thermal_control_enabled(struct cpufreq_driver *drv)\n{\n\treturn IS_ENABLED(CONFIG_CPU_THERMAL) &&\n\t\t(drv->flags & CPUFREQ_IS_COOLING_DEV);\n}\n\nstatic inline void cpufreq_verify_within_limits(struct cpufreq_policy_data *policy,\n\t\t\t\t\t\tunsigned int min,\n\t\t\t\t\t\tunsigned int max)\n{\n\tpolicy->max = clamp(policy->max, min, max);\n\tpolicy->min = clamp(policy->min, min, policy->max);\n}\n\nstatic inline void\ncpufreq_verify_within_cpu_limits(struct cpufreq_policy_data *policy)\n{\n\tcpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,\n\t\t\t\t     policy->cpuinfo.max_freq);\n}\n\n#ifdef CONFIG_CPU_FREQ\nvoid cpufreq_suspend(void);\nvoid cpufreq_resume(void);\nint cpufreq_generic_suspend(struct cpufreq_policy *policy);\n#else\nstatic inline void cpufreq_suspend(void) {}\nstatic inline void cpufreq_resume(void) {}\n#endif\n\n \n\n#define CPUFREQ_TRANSITION_NOTIFIER\t(0)\n#define CPUFREQ_POLICY_NOTIFIER\t\t(1)\n\n \n#define CPUFREQ_PRECHANGE\t\t(0)\n#define CPUFREQ_POSTCHANGE\t\t(1)\n\n \n#define CPUFREQ_CREATE_POLICY\t\t(0)\n#define CPUFREQ_REMOVE_POLICY\t\t(1)\n\n#ifdef CONFIG_CPU_FREQ\nint cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);\nint cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);\n\nvoid cpufreq_freq_transition_begin(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_freqs *freqs);\nvoid cpufreq_freq_transition_end(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_freqs *freqs, int transition_failed);\n\n#else  \nstatic inline int cpufreq_register_notifier(struct notifier_block *nb,\n\t\t\t\t\t\tunsigned int list)\n{\n\treturn 0;\n}\nstatic inline int cpufreq_unregister_notifier(struct notifier_block *nb,\n\t\t\t\t\t\tunsigned int list)\n{\n\treturn 0;\n}\n#endif  \n\n \nstatic inline unsigned long cpufreq_scale(unsigned long old, u_int div,\n\t\tu_int mult)\n{\n#if BITS_PER_LONG == 32\n\tu64 result = ((u64) old) * ((u64) mult);\n\tdo_div(result, div);\n\treturn (unsigned long) result;\n\n#elif BITS_PER_LONG == 64\n\tunsigned long result = old * ((u64) mult);\n\tresult /= div;\n\treturn result;\n#endif\n}\n\n \n\n#define CPUFREQ_POLICY_UNKNOWN\t\t(0)\n \n#define CPUFREQ_POLICY_POWERSAVE\t(1)\n#define CPUFREQ_POLICY_PERFORMANCE\t(2)\n\n \n#define LATENCY_MULTIPLIER\t\t(1000)\n\nstruct cpufreq_governor {\n\tchar\tname[CPUFREQ_NAME_LEN];\n\tint\t(*init)(struct cpufreq_policy *policy);\n\tvoid\t(*exit)(struct cpufreq_policy *policy);\n\tint\t(*start)(struct cpufreq_policy *policy);\n\tvoid\t(*stop)(struct cpufreq_policy *policy);\n\tvoid\t(*limits)(struct cpufreq_policy *policy);\n\tssize_t\t(*show_setspeed)\t(struct cpufreq_policy *policy,\n\t\t\t\t\t char *buf);\n\tint\t(*store_setspeed)\t(struct cpufreq_policy *policy,\n\t\t\t\t\t unsigned int freq);\n\tstruct list_head\tgovernor_list;\n\tstruct module\t\t*owner;\n\tu8\t\t\tflags;\n};\n\n \n\n \n#define CPUFREQ_GOV_DYNAMIC_SWITCHING\tBIT(0)\n\n \n#define CPUFREQ_GOV_STRICT_TARGET\tBIT(1)\n\n\n \nunsigned int cpufreq_driver_fast_switch(struct cpufreq_policy *policy,\n\t\t\t\t\tunsigned int target_freq);\nvoid cpufreq_driver_adjust_perf(unsigned int cpu,\n\t\t\t\tunsigned long min_perf,\n\t\t\t\tunsigned long target_perf,\n\t\t\t\tunsigned long capacity);\nbool cpufreq_driver_has_adjust_perf(void);\nint cpufreq_driver_target(struct cpufreq_policy *policy,\n\t\t\t\t unsigned int target_freq,\n\t\t\t\t unsigned int relation);\nint __cpufreq_driver_target(struct cpufreq_policy *policy,\n\t\t\t\t   unsigned int target_freq,\n\t\t\t\t   unsigned int relation);\nunsigned int cpufreq_driver_resolve_freq(struct cpufreq_policy *policy,\n\t\t\t\t\t unsigned int target_freq);\nunsigned int cpufreq_policy_transition_delay_us(struct cpufreq_policy *policy);\nint cpufreq_register_governor(struct cpufreq_governor *governor);\nvoid cpufreq_unregister_governor(struct cpufreq_governor *governor);\nint cpufreq_start_governor(struct cpufreq_policy *policy);\nvoid cpufreq_stop_governor(struct cpufreq_policy *policy);\n\n#define cpufreq_governor_init(__governor)\t\t\t\\\nstatic int __init __governor##_init(void)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn cpufreq_register_governor(&__governor);\t\\\n}\t\t\t\t\t\t\t\t\\\ncore_initcall(__governor##_init)\n\n#define cpufreq_governor_exit(__governor)\t\t\t\\\nstatic void __exit __governor##_exit(void)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn cpufreq_unregister_governor(&__governor);\t\\\n}\t\t\t\t\t\t\t\t\\\nmodule_exit(__governor##_exit)\n\nstruct cpufreq_governor *cpufreq_default_governor(void);\nstruct cpufreq_governor *cpufreq_fallback_governor(void);\n\nstatic inline void cpufreq_policy_apply_limits(struct cpufreq_policy *policy)\n{\n\tif (policy->max < policy->cur)\n\t\t__cpufreq_driver_target(policy, policy->max,\n\t\t\t\t\tCPUFREQ_RELATION_HE);\n\telse if (policy->min > policy->cur)\n\t\t__cpufreq_driver_target(policy, policy->min,\n\t\t\t\t\tCPUFREQ_RELATION_LE);\n}\n\n \nstruct gov_attr_set {\n\tstruct kobject kobj;\n\tstruct list_head policy_list;\n\tstruct mutex update_lock;\n\tint usage_count;\n};\n\n \nextern const struct sysfs_ops governor_sysfs_ops;\n\nstatic inline struct gov_attr_set *to_gov_attr_set(struct kobject *kobj)\n{\n\treturn container_of(kobj, struct gov_attr_set, kobj);\n}\n\nvoid gov_attr_set_init(struct gov_attr_set *attr_set, struct list_head *list_node);\nvoid gov_attr_set_get(struct gov_attr_set *attr_set, struct list_head *list_node);\nunsigned int gov_attr_set_put(struct gov_attr_set *attr_set, struct list_head *list_node);\n\n \nstruct governor_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct gov_attr_set *attr_set, char *buf);\n\tssize_t (*store)(struct gov_attr_set *attr_set, const char *buf,\n\t\t\t size_t count);\n};\n\n \n\n \n#define CPUFREQ_ENTRY_INVALID\t\t~0u\n#define CPUFREQ_TABLE_END\t\t~1u\n \n#define CPUFREQ_BOOST_FREQ\t\t(1 << 0)\n#define CPUFREQ_INEFFICIENT_FREQ\t(1 << 1)\n\nstruct cpufreq_frequency_table {\n\tunsigned int\tflags;\n\tunsigned int\tdriver_data;  \n\tunsigned int\tfrequency;  \n};\n\n#if defined(CONFIG_CPU_FREQ) && defined(CONFIG_PM_OPP)\nint dev_pm_opp_init_cpufreq_table(struct device *dev,\n\t\t\t\t  struct cpufreq_frequency_table **table);\nvoid dev_pm_opp_free_cpufreq_table(struct device *dev,\n\t\t\t\t   struct cpufreq_frequency_table **table);\n#else\nstatic inline int dev_pm_opp_init_cpufreq_table(struct device *dev,\n\t\t\t\t\t\tstruct cpufreq_frequency_table\n\t\t\t\t\t\t**table)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void dev_pm_opp_free_cpufreq_table(struct device *dev,\n\t\t\t\t\t\t struct cpufreq_frequency_table\n\t\t\t\t\t\t **table)\n{\n}\n#endif\n\n \n\n#define cpufreq_for_each_entry(pos, table)\t\\\n\tfor (pos = table; pos->frequency != CPUFREQ_TABLE_END; pos++)\n\n \n\n#define cpufreq_for_each_entry_idx(pos, table, idx)\t\\\n\tfor (pos = table, idx = 0; pos->frequency != CPUFREQ_TABLE_END; \\\n\t\tpos++, idx++)\n\n \n\n#define cpufreq_for_each_valid_entry(pos, table)\t\t\t\\\n\tfor (pos = table; pos->frequency != CPUFREQ_TABLE_END; pos++)\t\\\n\t\tif (pos->frequency == CPUFREQ_ENTRY_INVALID)\t\t\\\n\t\t\tcontinue;\t\t\t\t\t\\\n\t\telse\n\n \n\n#define cpufreq_for_each_valid_entry_idx(pos, table, idx)\t\t\\\n\tcpufreq_for_each_entry_idx(pos, table, idx)\t\t\t\\\n\t\tif (pos->frequency == CPUFREQ_ENTRY_INVALID)\t\t\\\n\t\t\tcontinue;\t\t\t\t\t\\\n\t\telse\n\n \n\n#define cpufreq_for_each_efficient_entry_idx(pos, table, idx, efficiencies)\t\\\n\tcpufreq_for_each_valid_entry_idx(pos, table, idx)\t\t\t\\\n\t\tif (efficiencies && (pos->flags & CPUFREQ_INEFFICIENT_FREQ))\t\\\n\t\t\tcontinue;\t\t\t\t\t\t\\\n\t\telse\n\n\nint cpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,\n\t\t\t\t    struct cpufreq_frequency_table *table);\n\nint cpufreq_frequency_table_verify(struct cpufreq_policy_data *policy,\n\t\t\t\t   struct cpufreq_frequency_table *table);\nint cpufreq_generic_frequency_table_verify(struct cpufreq_policy_data *policy);\n\nint cpufreq_table_index_unsorted(struct cpufreq_policy *policy,\n\t\t\t\t unsigned int target_freq,\n\t\t\t\t unsigned int relation);\nint cpufreq_frequency_table_get_index(struct cpufreq_policy *policy,\n\t\tunsigned int freq);\n\nssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);\n\n#ifdef CONFIG_CPU_FREQ\nint cpufreq_boost_trigger_state(int state);\nint cpufreq_boost_enabled(void);\nint cpufreq_enable_boost_support(void);\nbool policy_has_boost_freq(struct cpufreq_policy *policy);\n\n \nstatic inline int cpufreq_table_find_index_al(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq,\n\t\t\t\t\t      bool efficiencies)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_efficient_entry_idx(pos, table, idx, efficiencies) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq >= target_freq)\n\t\t\treturn idx;\n\n\t\tbest = idx;\n\t}\n\n\treturn best;\n}\n\n \nstatic inline int cpufreq_table_find_index_dl(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq,\n\t\t\t\t\t      bool efficiencies)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_efficient_entry_idx(pos, table, idx, efficiencies) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq == target_freq)\n\t\t\treturn idx;\n\n\t\tif (freq > target_freq) {\n\t\t\tbest = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (best == -1)\n\t\t\treturn idx;\n\n\t\treturn best;\n\t}\n\n\treturn best;\n}\n\n \nstatic inline int cpufreq_table_find_index_l(struct cpufreq_policy *policy,\n\t\t\t\t\t     unsigned int target_freq,\n\t\t\t\t\t     bool efficiencies)\n{\n\ttarget_freq = clamp_val(target_freq, policy->min, policy->max);\n\n\tif (policy->freq_table_sorted == CPUFREQ_TABLE_SORTED_ASCENDING)\n\t\treturn cpufreq_table_find_index_al(policy, target_freq,\n\t\t\t\t\t\t   efficiencies);\n\telse\n\t\treturn cpufreq_table_find_index_dl(policy, target_freq,\n\t\t\t\t\t\t   efficiencies);\n}\n\n \nstatic inline int cpufreq_table_find_index_ah(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq,\n\t\t\t\t\t      bool efficiencies)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_efficient_entry_idx(pos, table, idx, efficiencies) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq == target_freq)\n\t\t\treturn idx;\n\n\t\tif (freq < target_freq) {\n\t\t\tbest = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (best == -1)\n\t\t\treturn idx;\n\n\t\treturn best;\n\t}\n\n\treturn best;\n}\n\n \nstatic inline int cpufreq_table_find_index_dh(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq,\n\t\t\t\t\t      bool efficiencies)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_efficient_entry_idx(pos, table, idx, efficiencies) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq <= target_freq)\n\t\t\treturn idx;\n\n\t\tbest = idx;\n\t}\n\n\treturn best;\n}\n\n \nstatic inline int cpufreq_table_find_index_h(struct cpufreq_policy *policy,\n\t\t\t\t\t     unsigned int target_freq,\n\t\t\t\t\t     bool efficiencies)\n{\n\ttarget_freq = clamp_val(target_freq, policy->min, policy->max);\n\n\tif (policy->freq_table_sorted == CPUFREQ_TABLE_SORTED_ASCENDING)\n\t\treturn cpufreq_table_find_index_ah(policy, target_freq,\n\t\t\t\t\t\t   efficiencies);\n\telse\n\t\treturn cpufreq_table_find_index_dh(policy, target_freq,\n\t\t\t\t\t\t   efficiencies);\n}\n\n \nstatic inline int cpufreq_table_find_index_ac(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq,\n\t\t\t\t\t      bool efficiencies)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_efficient_entry_idx(pos, table, idx, efficiencies) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq == target_freq)\n\t\t\treturn idx;\n\n\t\tif (freq < target_freq) {\n\t\t\tbest = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (best == -1)\n\t\t\treturn idx;\n\n\t\t \n\t\tif (target_freq - table[best].frequency > freq - target_freq)\n\t\t\treturn idx;\n\n\t\treturn best;\n\t}\n\n\treturn best;\n}\n\n \nstatic inline int cpufreq_table_find_index_dc(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq,\n\t\t\t\t\t      bool efficiencies)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_efficient_entry_idx(pos, table, idx, efficiencies) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq == target_freq)\n\t\t\treturn idx;\n\n\t\tif (freq > target_freq) {\n\t\t\tbest = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (best == -1)\n\t\t\treturn idx;\n\n\t\t \n\t\tif (table[best].frequency - target_freq > target_freq - freq)\n\t\t\treturn idx;\n\n\t\treturn best;\n\t}\n\n\treturn best;\n}\n\n \nstatic inline int cpufreq_table_find_index_c(struct cpufreq_policy *policy,\n\t\t\t\t\t     unsigned int target_freq,\n\t\t\t\t\t     bool efficiencies)\n{\n\ttarget_freq = clamp_val(target_freq, policy->min, policy->max);\n\n\tif (policy->freq_table_sorted == CPUFREQ_TABLE_SORTED_ASCENDING)\n\t\treturn cpufreq_table_find_index_ac(policy, target_freq,\n\t\t\t\t\t\t   efficiencies);\n\telse\n\t\treturn cpufreq_table_find_index_dc(policy, target_freq,\n\t\t\t\t\t\t   efficiencies);\n}\n\nstatic inline int cpufreq_frequency_table_target(struct cpufreq_policy *policy,\n\t\t\t\t\t\t unsigned int target_freq,\n\t\t\t\t\t\t unsigned int relation)\n{\n\tbool efficiencies = policy->efficiencies_available &&\n\t\t\t    (relation & CPUFREQ_RELATION_E);\n\tint idx;\n\n\t \n\trelation &= ~CPUFREQ_RELATION_E;\n\n\tif (unlikely(policy->freq_table_sorted == CPUFREQ_TABLE_UNSORTED))\n\t\treturn cpufreq_table_index_unsorted(policy, target_freq,\n\t\t\t\t\t\t    relation);\nretry:\n\tswitch (relation) {\n\tcase CPUFREQ_RELATION_L:\n\t\tidx = cpufreq_table_find_index_l(policy, target_freq,\n\t\t\t\t\t\t efficiencies);\n\t\tbreak;\n\tcase CPUFREQ_RELATION_H:\n\t\tidx = cpufreq_table_find_index_h(policy, target_freq,\n\t\t\t\t\t\t efficiencies);\n\t\tbreak;\n\tcase CPUFREQ_RELATION_C:\n\t\tidx = cpufreq_table_find_index_c(policy, target_freq,\n\t\t\t\t\t\t efficiencies);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (idx < 0 && efficiencies) {\n\t\tefficiencies = false;\n\t\tgoto retry;\n\t}\n\n\treturn idx;\n}\n\nstatic inline int cpufreq_table_count_valid_entries(const struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_frequency_table *pos;\n\tint count = 0;\n\n\tif (unlikely(!policy->freq_table))\n\t\treturn 0;\n\n\tcpufreq_for_each_valid_entry(pos, policy->freq_table)\n\t\tcount++;\n\n\treturn count;\n}\n\n \n\nstatic inline int\ncpufreq_table_set_inefficient(struct cpufreq_policy *policy,\n\t\t\t      unsigned int frequency)\n{\n\tstruct cpufreq_frequency_table *pos;\n\n\t \n\tif (policy->freq_table_sorted == CPUFREQ_TABLE_UNSORTED)\n\t\treturn -EINVAL;\n\n\tcpufreq_for_each_valid_entry(pos, policy->freq_table) {\n\t\tif (pos->frequency == frequency) {\n\t\t\tpos->flags |= CPUFREQ_INEFFICIENT_FREQ;\n\t\t\tpolicy->efficiencies_available = true;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic inline int parse_perf_domain(int cpu, const char *list_name,\n\t\t\t\t    const char *cell_name,\n\t\t\t\t    struct of_phandle_args *args)\n{\n\tstruct device_node *cpu_np;\n\tint ret;\n\n\tcpu_np = of_cpu_device_node_get(cpu);\n\tif (!cpu_np)\n\t\treturn -ENODEV;\n\n\tret = of_parse_phandle_with_args(cpu_np, list_name, cell_name, 0,\n\t\t\t\t\t args);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tof_node_put(cpu_np);\n\n\treturn 0;\n}\n\nstatic inline int of_perf_domain_get_sharing_cpumask(int pcpu, const char *list_name,\n\t\t\t\t\t\t     const char *cell_name, struct cpumask *cpumask,\n\t\t\t\t\t\t     struct of_phandle_args *pargs)\n{\n\tint cpu, ret;\n\tstruct of_phandle_args args;\n\n\tret = parse_perf_domain(pcpu, list_name, cell_name, pargs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcpumask_set_cpu(pcpu, cpumask);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == pcpu)\n\t\t\tcontinue;\n\n\t\tret = parse_perf_domain(cpu, list_name, cell_name, &args);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (pargs->np == args.np && pargs->args_count == args.args_count &&\n\t\t    !memcmp(pargs->args, args.args, sizeof(args.args[0]) * args.args_count))\n\t\t\tcpumask_set_cpu(cpu, cpumask);\n\n\t\tof_node_put(args.np);\n\t}\n\n\treturn 0;\n}\n#else\nstatic inline int cpufreq_boost_trigger_state(int state)\n{\n\treturn 0;\n}\nstatic inline int cpufreq_boost_enabled(void)\n{\n\treturn 0;\n}\n\nstatic inline int cpufreq_enable_boost_support(void)\n{\n\treturn -EINVAL;\n}\n\nstatic inline bool policy_has_boost_freq(struct cpufreq_policy *policy)\n{\n\treturn false;\n}\n\nstatic inline int\ncpufreq_table_set_inefficient(struct cpufreq_policy *policy,\n\t\t\t      unsigned int frequency)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int of_perf_domain_get_sharing_cpumask(int pcpu, const char *list_name,\n\t\t\t\t\t\t     const char *cell_name, struct cpumask *cpumask,\n\t\t\t\t\t\t     struct of_phandle_args *pargs)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)\nvoid sched_cpufreq_governor_change(struct cpufreq_policy *policy,\n\t\t\tstruct cpufreq_governor *old_gov);\n#else\nstatic inline void sched_cpufreq_governor_change(struct cpufreq_policy *policy,\n\t\t\tstruct cpufreq_governor *old_gov) { }\n#endif\n\nextern unsigned int arch_freq_get_on_cpu(int cpu);\n\n#ifndef arch_set_freq_scale\nstatic __always_inline\nvoid arch_set_freq_scale(const struct cpumask *cpus,\n\t\t\t unsigned long cur_freq,\n\t\t\t unsigned long max_freq)\n{\n}\n#endif\n \nextern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;\nextern struct freq_attr cpufreq_freq_attr_scaling_boost_freqs;\nextern struct freq_attr *cpufreq_generic_attr[];\nint cpufreq_table_validate_and_sort(struct cpufreq_policy *policy);\n\nunsigned int cpufreq_generic_get(unsigned int cpu);\nvoid cpufreq_generic_init(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_frequency_table *table,\n\t\tunsigned int transition_latency);\n\nstatic inline void cpufreq_register_em_with_opp(struct cpufreq_policy *policy)\n{\n\tdev_pm_opp_of_register_em(get_cpu_device(policy->cpu),\n\t\t\t\t  policy->related_cpus);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}