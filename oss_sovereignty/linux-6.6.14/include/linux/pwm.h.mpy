{
  "module_name": "pwm.h",
  "hash_id": "b7e7b3f797d434a28f853f72bf5e9db37eaee8e5c82947cbfdab5fe6ea36aeed",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/pwm.h",
  "human_readable_source": " \n#ifndef __LINUX_PWM_H\n#define __LINUX_PWM_H\n\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n\nstruct pwm_chip;\n\n \nenum pwm_polarity {\n\tPWM_POLARITY_NORMAL,\n\tPWM_POLARITY_INVERSED,\n};\n\n \nstruct pwm_args {\n\tu64 period;\n\tenum pwm_polarity polarity;\n};\n\nenum {\n\tPWMF_REQUESTED = 0,\n\tPWMF_EXPORTED = 1,\n};\n\n \nstruct pwm_state {\n\tu64 period;\n\tu64 duty_cycle;\n\tenum pwm_polarity polarity;\n\tbool enabled;\n\tbool usage_power;\n};\n\n \nstruct pwm_device {\n\tconst char *label;\n\tunsigned long flags;\n\tunsigned int hwpwm;\n\tunsigned int pwm;\n\tstruct pwm_chip *chip;\n\tvoid *chip_data;\n\n\tstruct pwm_args args;\n\tstruct pwm_state state;\n\tstruct pwm_state last;\n};\n\n \nstatic inline void pwm_get_state(const struct pwm_device *pwm,\n\t\t\t\t struct pwm_state *state)\n{\n\t*state = pwm->state;\n}\n\nstatic inline bool pwm_is_enabled(const struct pwm_device *pwm)\n{\n\tstruct pwm_state state;\n\n\tpwm_get_state(pwm, &state);\n\n\treturn state.enabled;\n}\n\nstatic inline void pwm_set_period(struct pwm_device *pwm, u64 period)\n{\n\tif (pwm)\n\t\tpwm->state.period = period;\n}\n\nstatic inline u64 pwm_get_period(const struct pwm_device *pwm)\n{\n\tstruct pwm_state state;\n\n\tpwm_get_state(pwm, &state);\n\n\treturn state.period;\n}\n\nstatic inline void pwm_set_duty_cycle(struct pwm_device *pwm, unsigned int duty)\n{\n\tif (pwm)\n\t\tpwm->state.duty_cycle = duty;\n}\n\nstatic inline u64 pwm_get_duty_cycle(const struct pwm_device *pwm)\n{\n\tstruct pwm_state state;\n\n\tpwm_get_state(pwm, &state);\n\n\treturn state.duty_cycle;\n}\n\nstatic inline enum pwm_polarity pwm_get_polarity(const struct pwm_device *pwm)\n{\n\tstruct pwm_state state;\n\n\tpwm_get_state(pwm, &state);\n\n\treturn state.polarity;\n}\n\nstatic inline void pwm_get_args(const struct pwm_device *pwm,\n\t\t\t\tstruct pwm_args *args)\n{\n\t*args = pwm->args;\n}\n\n \nstatic inline void pwm_init_state(const struct pwm_device *pwm,\n\t\t\t\t  struct pwm_state *state)\n{\n\tstruct pwm_args args;\n\n\t \n\tpwm_get_state(pwm, state);\n\n\t \n\tpwm_get_args(pwm, &args);\n\n\tstate->period = args.period;\n\tstate->polarity = args.polarity;\n\tstate->duty_cycle = 0;\n\tstate->usage_power = false;\n}\n\n \nstatic inline unsigned int\npwm_get_relative_duty_cycle(const struct pwm_state *state, unsigned int scale)\n{\n\tif (!state->period)\n\t\treturn 0;\n\n\treturn DIV_ROUND_CLOSEST_ULL((u64)state->duty_cycle * scale,\n\t\t\t\t     state->period);\n}\n\n \nstatic inline int\npwm_set_relative_duty_cycle(struct pwm_state *state, unsigned int duty_cycle,\n\t\t\t    unsigned int scale)\n{\n\tif (!scale || duty_cycle > scale)\n\t\treturn -EINVAL;\n\n\tstate->duty_cycle = DIV_ROUND_CLOSEST_ULL((u64)duty_cycle *\n\t\t\t\t\t\t  state->period,\n\t\t\t\t\t\t  scale);\n\n\treturn 0;\n}\n\n \nstruct pwm_capture {\n\tunsigned int period;\n\tunsigned int duty_cycle;\n};\n\n \nstruct pwm_ops {\n\tint (*request)(struct pwm_chip *chip, struct pwm_device *pwm);\n\tvoid (*free)(struct pwm_chip *chip, struct pwm_device *pwm);\n\tint (*capture)(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t       struct pwm_capture *result, unsigned long timeout);\n\tint (*apply)(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t     const struct pwm_state *state);\n\tint (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t struct pwm_state *state);\n\tstruct module *owner;\n};\n\n \nstruct pwm_chip {\n\tstruct device *dev;\n\tconst struct pwm_ops *ops;\n\tint base;\n\tunsigned int npwm;\n\n\tstruct pwm_device * (*of_xlate)(struct pwm_chip *chip,\n\t\t\t\t\tconst struct of_phandle_args *args);\n\tunsigned int of_pwm_n_cells;\n\n\t \n\tstruct list_head list;\n\tstruct pwm_device *pwms;\n};\n\n#if IS_ENABLED(CONFIG_PWM)\n \nint pwm_apply_state(struct pwm_device *pwm, const struct pwm_state *state);\nint pwm_adjust_config(struct pwm_device *pwm);\n\n \nstatic inline int pwm_config(struct pwm_device *pwm, int duty_ns,\n\t\t\t     int period_ns)\n{\n\tstruct pwm_state state;\n\n\tif (!pwm)\n\t\treturn -EINVAL;\n\n\tif (duty_ns < 0 || period_ns < 0)\n\t\treturn -EINVAL;\n\n\tpwm_get_state(pwm, &state);\n\tif (state.duty_cycle == duty_ns && state.period == period_ns)\n\t\treturn 0;\n\n\tstate.duty_cycle = duty_ns;\n\tstate.period = period_ns;\n\treturn pwm_apply_state(pwm, &state);\n}\n\n \nstatic inline int pwm_enable(struct pwm_device *pwm)\n{\n\tstruct pwm_state state;\n\n\tif (!pwm)\n\t\treturn -EINVAL;\n\n\tpwm_get_state(pwm, &state);\n\tif (state.enabled)\n\t\treturn 0;\n\n\tstate.enabled = true;\n\treturn pwm_apply_state(pwm, &state);\n}\n\n \nstatic inline void pwm_disable(struct pwm_device *pwm)\n{\n\tstruct pwm_state state;\n\n\tif (!pwm)\n\t\treturn;\n\n\tpwm_get_state(pwm, &state);\n\tif (!state.enabled)\n\t\treturn;\n\n\tstate.enabled = false;\n\tpwm_apply_state(pwm, &state);\n}\n\n \nint pwm_capture(struct pwm_device *pwm, struct pwm_capture *result,\n\t\tunsigned long timeout);\nint pwm_set_chip_data(struct pwm_device *pwm, void *data);\nvoid *pwm_get_chip_data(struct pwm_device *pwm);\n\nint pwmchip_add(struct pwm_chip *chip);\nvoid pwmchip_remove(struct pwm_chip *chip);\n\nint devm_pwmchip_add(struct device *dev, struct pwm_chip *chip);\n\nstruct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,\n\t\t\t\t\t unsigned int index,\n\t\t\t\t\t const char *label);\n\nstruct pwm_device *of_pwm_xlate_with_flags(struct pwm_chip *chip,\n\t\tconst struct of_phandle_args *args);\nstruct pwm_device *of_pwm_single_xlate(struct pwm_chip *chip,\n\t\t\t\t       const struct of_phandle_args *args);\n\nstruct pwm_device *pwm_get(struct device *dev, const char *con_id);\nvoid pwm_put(struct pwm_device *pwm);\n\nstruct pwm_device *devm_pwm_get(struct device *dev, const char *con_id);\nstruct pwm_device *devm_fwnode_pwm_get(struct device *dev,\n\t\t\t\t       struct fwnode_handle *fwnode,\n\t\t\t\t       const char *con_id);\n#else\nstatic inline int pwm_apply_state(struct pwm_device *pwm,\n\t\t\t\t  const struct pwm_state *state)\n{\n\tmight_sleep();\n\treturn -ENOTSUPP;\n}\n\nstatic inline int pwm_adjust_config(struct pwm_device *pwm)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic inline int pwm_config(struct pwm_device *pwm, int duty_ns,\n\t\t\t     int period_ns)\n{\n\tmight_sleep();\n\treturn -EINVAL;\n}\n\nstatic inline int pwm_enable(struct pwm_device *pwm)\n{\n\tmight_sleep();\n\treturn -EINVAL;\n}\n\nstatic inline void pwm_disable(struct pwm_device *pwm)\n{\n\tmight_sleep();\n}\n\nstatic inline int pwm_capture(struct pwm_device *pwm,\n\t\t\t      struct pwm_capture *result,\n\t\t\t      unsigned long timeout)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int pwm_set_chip_data(struct pwm_device *pwm, void *data)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void *pwm_get_chip_data(struct pwm_device *pwm)\n{\n\treturn NULL;\n}\n\nstatic inline int pwmchip_add(struct pwm_chip *chip)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int pwmchip_remove(struct pwm_chip *chip)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int devm_pwmchip_add(struct device *dev, struct pwm_chip *chip)\n{\n\treturn -EINVAL;\n}\n\nstatic inline struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,\n\t\t\t\t\t\t       unsigned int index,\n\t\t\t\t\t\t       const char *label)\n{\n\tmight_sleep();\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic inline struct pwm_device *pwm_get(struct device *dev,\n\t\t\t\t\t const char *consumer)\n{\n\tmight_sleep();\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic inline void pwm_put(struct pwm_device *pwm)\n{\n\tmight_sleep();\n}\n\nstatic inline struct pwm_device *devm_pwm_get(struct device *dev,\n\t\t\t\t\t      const char *consumer)\n{\n\tmight_sleep();\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic inline struct pwm_device *\ndevm_fwnode_pwm_get(struct device *dev, struct fwnode_handle *fwnode,\n\t\t    const char *con_id)\n{\n\tmight_sleep();\n\treturn ERR_PTR(-ENODEV);\n}\n#endif\n\nstatic inline void pwm_apply_args(struct pwm_device *pwm)\n{\n\tstruct pwm_state state = { };\n\n\t \n\n\tstate.enabled = false;\n\tstate.polarity = pwm->args.polarity;\n\tstate.period = pwm->args.period;\n\tstate.usage_power = false;\n\n\tpwm_apply_state(pwm, &state);\n}\n\nstruct pwm_lookup {\n\tstruct list_head list;\n\tconst char *provider;\n\tunsigned int index;\n\tconst char *dev_id;\n\tconst char *con_id;\n\tunsigned int period;\n\tenum pwm_polarity polarity;\n\tconst char *module;  \n};\n\n#define PWM_LOOKUP_WITH_MODULE(_provider, _index, _dev_id, _con_id,\t\\\n\t\t\t       _period, _polarity, _module)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.provider = _provider,\t\t\t\t\t\\\n\t\t.index = _index,\t\t\t\t\t\\\n\t\t.dev_id = _dev_id,\t\t\t\t\t\\\n\t\t.con_id = _con_id,\t\t\t\t\t\\\n\t\t.period = _period,\t\t\t\t\t\\\n\t\t.polarity = _polarity,\t\t\t\t\t\\\n\t\t.module = _module,\t\t\t\t\t\\\n\t}\n\n#define PWM_LOOKUP(_provider, _index, _dev_id, _con_id, _period, _polarity) \\\n\tPWM_LOOKUP_WITH_MODULE(_provider, _index, _dev_id, _con_id, _period, \\\n\t\t\t       _polarity, NULL)\n\n#if IS_ENABLED(CONFIG_PWM)\nvoid pwm_add_table(struct pwm_lookup *table, size_t num);\nvoid pwm_remove_table(struct pwm_lookup *table, size_t num);\n#else\nstatic inline void pwm_add_table(struct pwm_lookup *table, size_t num)\n{\n}\n\nstatic inline void pwm_remove_table(struct pwm_lookup *table, size_t num)\n{\n}\n#endif\n\n#ifdef CONFIG_PWM_SYSFS\nvoid pwmchip_sysfs_export(struct pwm_chip *chip);\nvoid pwmchip_sysfs_unexport(struct pwm_chip *chip);\n#else\nstatic inline void pwmchip_sysfs_export(struct pwm_chip *chip)\n{\n}\n\nstatic inline void pwmchip_sysfs_unexport(struct pwm_chip *chip)\n{\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}