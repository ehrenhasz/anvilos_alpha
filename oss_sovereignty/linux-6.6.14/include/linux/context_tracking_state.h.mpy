{
  "module_name": "context_tracking_state.h",
  "hash_id": "11539bae9da5eb9e92cfec0687699d80ffe9084bb9423d304f2965a71ef24f00",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/context_tracking_state.h",
  "human_readable_source": " \n#ifndef _LINUX_CONTEXT_TRACKING_STATE_H\n#define _LINUX_CONTEXT_TRACKING_STATE_H\n\n#include <linux/percpu.h>\n#include <linux/static_key.h>\n#include <linux/context_tracking_irq.h>\n\n \n#define DYNTICK_IRQ_NONIDLE\t((LONG_MAX / 2) + 1)\n\nenum ctx_state {\n\tCONTEXT_DISABLED\t= -1,\t \n\tCONTEXT_KERNEL\t\t= 0,\n\tCONTEXT_IDLE\t\t= 1,\n\tCONTEXT_USER\t\t= 2,\n\tCONTEXT_GUEST\t\t= 3,\n\tCONTEXT_MAX\t\t= 4,\n};\n\n \n#define RCU_DYNTICKS_IDX CONTEXT_MAX\n\n#define CT_STATE_MASK (CONTEXT_MAX - 1)\n#define CT_DYNTICKS_MASK (~CT_STATE_MASK)\n\nstruct context_tracking {\n#ifdef CONFIG_CONTEXT_TRACKING_USER\n\t \n\tbool active;\n\tint recursion;\n#endif\n#ifdef CONFIG_CONTEXT_TRACKING\n\tatomic_t state;\n#endif\n#ifdef CONFIG_CONTEXT_TRACKING_IDLE\n\tlong dynticks_nesting;\t\t \n\tlong dynticks_nmi_nesting;\t \n#endif\n};\n\n#ifdef CONFIG_CONTEXT_TRACKING\nDECLARE_PER_CPU(struct context_tracking, context_tracking);\n#endif\n\n#ifdef CONFIG_CONTEXT_TRACKING_USER\nstatic __always_inline int __ct_state(void)\n{\n\treturn raw_atomic_read(this_cpu_ptr(&context_tracking.state)) & CT_STATE_MASK;\n}\n#endif\n\n#ifdef CONFIG_CONTEXT_TRACKING_IDLE\nstatic __always_inline int ct_dynticks(void)\n{\n\treturn atomic_read(this_cpu_ptr(&context_tracking.state)) & CT_DYNTICKS_MASK;\n}\n\nstatic __always_inline int ct_dynticks_cpu(int cpu)\n{\n\tstruct context_tracking *ct = per_cpu_ptr(&context_tracking, cpu);\n\n\treturn atomic_read(&ct->state) & CT_DYNTICKS_MASK;\n}\n\nstatic __always_inline int ct_dynticks_cpu_acquire(int cpu)\n{\n\tstruct context_tracking *ct = per_cpu_ptr(&context_tracking, cpu);\n\n\treturn atomic_read_acquire(&ct->state) & CT_DYNTICKS_MASK;\n}\n\nstatic __always_inline long ct_dynticks_nesting(void)\n{\n\treturn __this_cpu_read(context_tracking.dynticks_nesting);\n}\n\nstatic __always_inline long ct_dynticks_nesting_cpu(int cpu)\n{\n\tstruct context_tracking *ct = per_cpu_ptr(&context_tracking, cpu);\n\n\treturn ct->dynticks_nesting;\n}\n\nstatic __always_inline long ct_dynticks_nmi_nesting(void)\n{\n\treturn __this_cpu_read(context_tracking.dynticks_nmi_nesting);\n}\n\nstatic __always_inline long ct_dynticks_nmi_nesting_cpu(int cpu)\n{\n\tstruct context_tracking *ct = per_cpu_ptr(&context_tracking, cpu);\n\n\treturn ct->dynticks_nmi_nesting;\n}\n#endif  \n\n#ifdef CONFIG_CONTEXT_TRACKING_USER\nextern struct static_key_false context_tracking_key;\n\nstatic __always_inline bool context_tracking_enabled(void)\n{\n\treturn static_branch_unlikely(&context_tracking_key);\n}\n\nstatic __always_inline bool context_tracking_enabled_cpu(int cpu)\n{\n\treturn context_tracking_enabled() && per_cpu(context_tracking.active, cpu);\n}\n\nstatic inline bool context_tracking_enabled_this_cpu(void)\n{\n\treturn context_tracking_enabled() && __this_cpu_read(context_tracking.active);\n}\n\n \nstatic __always_inline int ct_state(void)\n{\n\tint ret;\n\n\tif (!context_tracking_enabled())\n\t\treturn CONTEXT_DISABLED;\n\n\tpreempt_disable();\n\tret = __ct_state();\n\tpreempt_enable();\n\n\treturn ret;\n}\n\n#else\nstatic __always_inline bool context_tracking_enabled(void) { return false; }\nstatic __always_inline bool context_tracking_enabled_cpu(int cpu) { return false; }\nstatic __always_inline bool context_tracking_enabled_this_cpu(void) { return false; }\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}