{
  "module_name": "cros_ec_commands.h",
  "hash_id": "5fb8f928501d523fa85dd885041cfde77cc95b94b3c0e070aa2ccb5c53e7d659",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/platform_data/cros_ec_commands.h",
  "human_readable_source": " \n \n\n \n\n#ifndef __CROS_EC_COMMANDS_H\n#define __CROS_EC_COMMANDS_H\n\n#include <linux/bits.h>\n#include <linux/types.h>\n\n#define BUILD_ASSERT(_cond)\n\n \n#define EC_PROTO_VERSION          0x00000002\n\n \n#define EC_VER_MASK(version) BIT(version)\n\n \n#define EC_LPC_ADDR_ACPI_DATA  0x62\n#define EC_LPC_ADDR_ACPI_CMD   0x66\n\n \n#define EC_LPC_ADDR_HOST_DATA  0x200\n#define EC_LPC_ADDR_HOST_CMD   0x204\n\n \n \n#define EC_LPC_ADDR_HOST_ARGS    0x800   \n#define EC_LPC_ADDR_HOST_PARAM   0x804   \n \n#define EC_LPC_ADDR_HOST_PACKET  0x800   \n#define EC_LPC_HOST_PACKET_SIZE  0x100   \n\n \n#define EC_HOST_CMD_REGION0       0x800\n#define EC_HOST_CMD_REGION1       0x880\n#define EC_HOST_CMD_REGION_SIZE    0x80\n#define EC_HOST_CMD_MEC_REGION_SIZE 0x8\n\n \n#define EC_LPC_CMDR_DATA\tBIT(0)   \n#define EC_LPC_CMDR_PENDING\tBIT(1)   \n#define EC_LPC_CMDR_BUSY\tBIT(2)   \n#define EC_LPC_CMDR_CMD\t\tBIT(3)   \n#define EC_LPC_CMDR_ACPI_BRST\tBIT(4)   \n#define EC_LPC_CMDR_SCI\t\tBIT(5)   \n#define EC_LPC_CMDR_SMI\t\tBIT(6)   \n\n#define EC_LPC_ADDR_MEMMAP       0x900\n#define EC_MEMMAP_SIZE         255  \n#define EC_MEMMAP_TEXT_MAX     8    \n\n \n#define EC_MEMMAP_TEMP_SENSOR      0x00  \n#define EC_MEMMAP_FAN              0x10  \n#define EC_MEMMAP_TEMP_SENSOR_B    0x18  \n#define EC_MEMMAP_ID               0x20  \n#define EC_MEMMAP_ID_VERSION       0x22  \n#define EC_MEMMAP_THERMAL_VERSION  0x23  \n#define EC_MEMMAP_BATTERY_VERSION  0x24  \n#define EC_MEMMAP_SWITCHES_VERSION 0x25  \n#define EC_MEMMAP_EVENTS_VERSION   0x26  \n#define EC_MEMMAP_HOST_CMD_FLAGS   0x27  \n \n#define EC_MEMMAP_SWITCHES         0x30\t \n \n#define EC_MEMMAP_HOST_EVENTS      0x34  \n \n#define EC_MEMMAP_BATT_VOLT        0x40  \n#define EC_MEMMAP_BATT_RATE        0x44  \n#define EC_MEMMAP_BATT_CAP         0x48  \n#define EC_MEMMAP_BATT_FLAG        0x4c  \n#define EC_MEMMAP_BATT_COUNT       0x4d  \n#define EC_MEMMAP_BATT_INDEX       0x4e  \n \n#define EC_MEMMAP_BATT_DCAP        0x50  \n#define EC_MEMMAP_BATT_DVLT        0x54  \n#define EC_MEMMAP_BATT_LFCC        0x58  \n#define EC_MEMMAP_BATT_CCNT        0x5c  \n \n#define EC_MEMMAP_BATT_MFGR        0x60  \n#define EC_MEMMAP_BATT_MODEL       0x68  \n#define EC_MEMMAP_BATT_SERIAL      0x70  \n#define EC_MEMMAP_BATT_TYPE        0x78  \n#define EC_MEMMAP_ALS              0x80  \n \n#define EC_MEMMAP_ACC_STATUS       0x90  \n \n#define EC_MEMMAP_ACC_DATA         0x92  \n \n \n \n#define EC_MEMMAP_GYRO_DATA        0xa0  \n \n\n \n#define EC_MEMMAP_NO_ACPI 0xe0\n\n \n#define EC_MEMMAP_ACC_STATUS_SAMPLE_ID_MASK  0x0f\n#define EC_MEMMAP_ACC_STATUS_BUSY_BIT        BIT(4)\n#define EC_MEMMAP_ACC_STATUS_PRESENCE_BIT    BIT(7)\n\n \n#define EC_TEMP_SENSOR_ENTRIES     16\n \n#define EC_TEMP_SENSOR_B_ENTRIES      8\n\n \n#define EC_TEMP_SENSOR_NOT_PRESENT    0xff\n#define EC_TEMP_SENSOR_ERROR          0xfe\n#define EC_TEMP_SENSOR_NOT_POWERED    0xfd\n#define EC_TEMP_SENSOR_NOT_CALIBRATED 0xfc\n \n#define EC_TEMP_SENSOR_OFFSET      200\n\n \n#define EC_ALS_ENTRIES             2\n\n \n#define EC_TEMP_SENSOR_DEFAULT     (296 - EC_TEMP_SENSOR_OFFSET)\n\n#define EC_FAN_SPEED_ENTRIES       4        \n#define EC_FAN_SPEED_NOT_PRESENT   0xffff   \n#define EC_FAN_SPEED_STALLED       0xfffe   \n\n \n#define EC_BATT_FLAG_AC_PRESENT   0x01\n#define EC_BATT_FLAG_BATT_PRESENT 0x02\n#define EC_BATT_FLAG_DISCHARGING  0x04\n#define EC_BATT_FLAG_CHARGING     0x08\n#define EC_BATT_FLAG_LEVEL_CRITICAL 0x10\n \n#define EC_BATT_FLAG_INVALID_DATA 0x20\n\n \n#define EC_SWITCH_LID_OPEN               0x01\n#define EC_SWITCH_POWER_BUTTON_PRESSED   0x02\n#define EC_SWITCH_WRITE_PROTECT_DISABLED 0x04\n \n#define EC_SWITCH_IGNORE1\t\t 0x08\n \n#define EC_SWITCH_DEDICATED_RECOVERY     0x10\n \n#define EC_SWITCH_IGNORE0                0x20\n\n \n \n#define EC_HOST_CMD_FLAG_LPC_ARGS_SUPPORTED  0x01\n \n#define EC_HOST_CMD_FLAG_VERSION_3   0x02\n\n \n#define EC_WIRELESS_SWITCH_ALL       ~0x00   \n#define EC_WIRELESS_SWITCH_WLAN       0x01   \n#define EC_WIRELESS_SWITCH_BLUETOOTH  0x02   \n#define EC_WIRELESS_SWITCH_WWAN       0x04   \n#define EC_WIRELESS_SWITCH_WLAN_POWER 0x08   \n\n \n \n\n \n#define EC_CMD_ACPI_READ 0x0080\n\n \n#define EC_CMD_ACPI_WRITE 0x0081\n\n \n#define EC_CMD_ACPI_BURST_ENABLE 0x0082\n\n \n#define EC_CMD_ACPI_BURST_DISABLE 0x0083\n\n \n#define EC_CMD_ACPI_QUERY_EVENT 0x0084\n\n \n\n \n#define EC_ACPI_MEM_VERSION            0x00\n \n#define EC_ACPI_MEM_TEST               0x01\n \n#define EC_ACPI_MEM_TEST_COMPLIMENT    0x02\n\n \n#define EC_ACPI_MEM_KEYBOARD_BACKLIGHT 0x03\n \n#define EC_ACPI_MEM_FAN_DUTY           0x04\n\n \n#define EC_ACPI_MEM_TEMP_ID            0x05\n#define EC_ACPI_MEM_TEMP_THRESHOLD     0x06\n#define EC_ACPI_MEM_TEMP_COMMIT        0x07\n \n#define EC_ACPI_MEM_TEMP_COMMIT_SELECT_MASK BIT(0)\n#define EC_ACPI_MEM_TEMP_COMMIT_ENABLE_MASK BIT(1)\n \n\n \n#define EC_ACPI_MEM_CHARGING_LIMIT     0x08\n\n \n#define EC_ACPI_MEM_CHARGING_LIMIT_STEP_MA   64\n \n#define EC_ACPI_MEM_CHARGING_LIMIT_DISABLED  0xff\n\n \n#define EC_ACPI_MEM_DEVICE_ORIENTATION 0x09\n#define EC_ACPI_MEM_TBMD_SHIFT         0\n#define EC_ACPI_MEM_TBMD_MASK          0x1\n#define EC_ACPI_MEM_DDPN_SHIFT         1\n#define EC_ACPI_MEM_DDPN_MASK          0x7\n\n \n#define EC_ACPI_MEM_DEVICE_FEATURES0 0x0a\n#define EC_ACPI_MEM_DEVICE_FEATURES1 0x0b\n#define EC_ACPI_MEM_DEVICE_FEATURES2 0x0c\n#define EC_ACPI_MEM_DEVICE_FEATURES3 0x0d\n#define EC_ACPI_MEM_DEVICE_FEATURES4 0x0e\n#define EC_ACPI_MEM_DEVICE_FEATURES5 0x0f\n#define EC_ACPI_MEM_DEVICE_FEATURES6 0x10\n#define EC_ACPI_MEM_DEVICE_FEATURES7 0x11\n\n#define EC_ACPI_MEM_BATTERY_INDEX    0x12\n\n \n#define EC_ACPI_MEM_USB_PORT_POWER 0x13\n\n \n#define EC_ACPI_MEM_MAPPED_BEGIN   0x20\n#define EC_ACPI_MEM_MAPPED_SIZE    0xe0\n\n \n#define EC_ACPI_MEM_VERSION_CURRENT 2\n\n\n \n\n\n \n\n \n#define __ec_align1 __packed\n#define __ec_align2 __packed\n#define __ec_align4 __packed\n#define __ec_align_size1 __packed\n#define __ec_align_offset1 __packed\n#define __ec_align_offset2 __packed\n#define __ec_todo_packed __packed\n#define __ec_todo_unpacked\n\n\n \n \n#define EC_LPC_STATUS_TO_HOST     0x01\n \n#define EC_LPC_STATUS_FROM_HOST   0x02\n \n#define EC_LPC_STATUS_PROCESSING  0x04\n \n#define EC_LPC_STATUS_LAST_CMD    0x08\n \n#define EC_LPC_STATUS_BURST_MODE  0x10\n \n#define EC_LPC_STATUS_SCI_PENDING 0x20\n \n#define EC_LPC_STATUS_SMI_PENDING 0x40\n \n#define EC_LPC_STATUS_RESERVED    0x80\n\n \n#define EC_LPC_STATUS_BUSY_MASK \\\n\t(EC_LPC_STATUS_FROM_HOST | EC_LPC_STATUS_PROCESSING)\n\n \nenum ec_status {\n\tEC_RES_SUCCESS = 0,\n\tEC_RES_INVALID_COMMAND = 1,\n\tEC_RES_ERROR = 2,\n\tEC_RES_INVALID_PARAM = 3,\n\tEC_RES_ACCESS_DENIED = 4,\n\tEC_RES_INVALID_RESPONSE = 5,\n\tEC_RES_INVALID_VERSION = 6,\n\tEC_RES_INVALID_CHECKSUM = 7,\n\tEC_RES_IN_PROGRESS = 8,\t\t \n\tEC_RES_UNAVAILABLE = 9,\t\t \n\tEC_RES_TIMEOUT = 10,\t\t \n\tEC_RES_OVERFLOW = 11,\t\t \n\tEC_RES_INVALID_HEADER = 12,      \n\tEC_RES_REQUEST_TRUNCATED = 13,   \n\tEC_RES_RESPONSE_TOO_BIG = 14,    \n\tEC_RES_BUS_ERROR = 15,\t\t \n\tEC_RES_BUSY = 16,\t\t \n\tEC_RES_INVALID_HEADER_VERSION = 17,   \n\tEC_RES_INVALID_HEADER_CRC = 18,       \n\tEC_RES_INVALID_DATA_CRC = 19,         \n\tEC_RES_DUP_UNAVAILABLE = 20,          \n};\n\n \nenum host_event_code {\n\tEC_HOST_EVENT_LID_CLOSED = 1,\n\tEC_HOST_EVENT_LID_OPEN = 2,\n\tEC_HOST_EVENT_POWER_BUTTON = 3,\n\tEC_HOST_EVENT_AC_CONNECTED = 4,\n\tEC_HOST_EVENT_AC_DISCONNECTED = 5,\n\tEC_HOST_EVENT_BATTERY_LOW = 6,\n\tEC_HOST_EVENT_BATTERY_CRITICAL = 7,\n\tEC_HOST_EVENT_BATTERY = 8,\n\tEC_HOST_EVENT_THERMAL_THRESHOLD = 9,\n\t \n\tEC_HOST_EVENT_DEVICE = 10,\n\tEC_HOST_EVENT_THERMAL = 11,\n\tEC_HOST_EVENT_USB_CHARGER = 12,\n\tEC_HOST_EVENT_KEY_PRESSED = 13,\n\t \n\tEC_HOST_EVENT_INTERFACE_READY = 14,\n\t \n\tEC_HOST_EVENT_KEYBOARD_RECOVERY = 15,\n\n\t \n\tEC_HOST_EVENT_THERMAL_SHUTDOWN = 16,\n\t \n\tEC_HOST_EVENT_BATTERY_SHUTDOWN = 17,\n\n\t \n\tEC_HOST_EVENT_THROTTLE_START = 18,\n\t \n\tEC_HOST_EVENT_THROTTLE_STOP = 19,\n\n\t \n\tEC_HOST_EVENT_HANG_DETECT = 20,\n\t \n\tEC_HOST_EVENT_HANG_REBOOT = 21,\n\n\t \n\tEC_HOST_EVENT_PD_MCU = 22,\n\n\t \n\tEC_HOST_EVENT_BATTERY_STATUS = 23,\n\n\t \n\tEC_HOST_EVENT_PANIC = 24,\n\n\t \n\tEC_HOST_EVENT_KEYBOARD_FASTBOOT = 25,\n\n\t \n\tEC_HOST_EVENT_RTC = 26,\n\n\t \n\tEC_HOST_EVENT_MKBP = 27,\n\n\t \n\tEC_HOST_EVENT_USB_MUX = 28,\n\n\t \n\tEC_HOST_EVENT_MODE_CHANGE = 29,\n\n\t \n\tEC_HOST_EVENT_KEYBOARD_RECOVERY_HW_REINIT = 30,\n\n\t \n\tEC_HOST_EVENT_WOV = 31,\n\n\t \n\tEC_HOST_EVENT_INVALID = 32\n};\n \n#define EC_HOST_EVENT_MASK(event_code) BIT_ULL((event_code) - 1)\n\n \nstruct ec_lpc_host_args {\n\tuint8_t flags;\n\tuint8_t command_version;\n\tuint8_t data_size;\n\tuint8_t checksum;\n} __ec_align4;\n\n \n \n#define EC_HOST_ARGS_FLAG_FROM_HOST 0x01\n \n#define EC_HOST_ARGS_FLAG_TO_HOST   0x02\n\n \n \n\n \n#define EC_SPI_FRAME_START    0xec\n\n \n#define EC_SPI_PAST_END       0xed\n\n \n#define EC_SPI_RX_READY       0xf8\n\n \n#define EC_SPI_RECEIVING      0xf9\n\n \n#define EC_SPI_PROCESSING     0xfa\n\n \n#define EC_SPI_RX_BAD_DATA    0xfb\n\n \n#define EC_SPI_NOT_READY      0xfc\n\n \n#define EC_SPI_OLD_READY      0xfd\n\n \n\n \n#define EC_PROTO2_REQUEST_HEADER_BYTES 3\n#define EC_PROTO2_REQUEST_TRAILER_BYTES 1\n#define EC_PROTO2_REQUEST_OVERHEAD (EC_PROTO2_REQUEST_HEADER_BYTES +\t\\\n\t\t\t\t    EC_PROTO2_REQUEST_TRAILER_BYTES)\n\n#define EC_PROTO2_RESPONSE_HEADER_BYTES 2\n#define EC_PROTO2_RESPONSE_TRAILER_BYTES 1\n#define EC_PROTO2_RESPONSE_OVERHEAD (EC_PROTO2_RESPONSE_HEADER_BYTES +\t\\\n\t\t\t\t     EC_PROTO2_RESPONSE_TRAILER_BYTES)\n\n \n#define EC_PROTO2_MAX_PARAM_SIZE 0xfc\n\n \n#define EC_PROTO2_MAX_REQUEST_SIZE (EC_PROTO2_REQUEST_OVERHEAD +\t\\\n\t\t\t\t    EC_PROTO2_MAX_PARAM_SIZE)\n#define EC_PROTO2_MAX_RESPONSE_SIZE (EC_PROTO2_RESPONSE_OVERHEAD +\t\\\n\t\t\t\t     EC_PROTO2_MAX_PARAM_SIZE)\n\n \n\n \n#define EC_COMMAND_PROTOCOL_3 0xda\n\n#define EC_HOST_REQUEST_VERSION 3\n\n \nstruct ec_host_request {\n\tuint8_t struct_version;\n\tuint8_t checksum;\n\tuint16_t command;\n\tuint8_t command_version;\n\tuint8_t reserved;\n\tuint16_t data_len;\n} __ec_align4;\n\n#define EC_HOST_RESPONSE_VERSION 3\n\n \nstruct ec_host_response {\n\tuint8_t struct_version;\n\tuint8_t checksum;\n\tuint16_t result;\n\tuint16_t data_len;\n\tuint16_t reserved;\n} __ec_align4;\n\n \n\n \n\n \nstruct ec_host_request4 {\n\t \n\tuint8_t fields0;\n\n\t \n\tuint8_t fields1;\n\n\t \n\tuint16_t command;\n\n\t \n\tuint16_t data_len;\n\n\t \n\tuint8_t reserved;\n\n\t \n\tuint8_t header_crc;\n} __ec_align4;\n\n \nstruct ec_host_response4 {\n\t \n\tuint8_t fields0;\n\n\t \n\tuint8_t fields1;\n\n\t \n\tuint16_t result;\n\n\t \n\tuint16_t data_len;\n\n\t \n\tuint8_t reserved;\n\n\t \n\tuint8_t header_crc;\n} __ec_align4;\n\n \n#define EC_PACKET4_0_STRUCT_VERSION_MASK\t0x0f\n#define EC_PACKET4_0_IS_RESPONSE_MASK\t\t0x10\n#define EC_PACKET4_0_SEQ_NUM_SHIFT\t\t5\n#define EC_PACKET4_0_SEQ_NUM_MASK\t\t0x60\n#define EC_PACKET4_0_SEQ_DUP_MASK\t\t0x80\n\n \n#define EC_PACKET4_1_COMMAND_VERSION_MASK\t0x1f   \n#define EC_PACKET4_1_DATA_CRC_PRESENT_MASK\t0x80\n\n \n \n\n \n \n\n \n#define EC_CMD_PROTO_VERSION 0x0000\n\n \nstruct ec_response_proto_version {\n\tuint32_t version;\n} __ec_align4;\n\n \n#define EC_CMD_HELLO 0x0001\n\n \nstruct ec_params_hello {\n\tuint32_t in_data;\n} __ec_align4;\n\n \nstruct ec_response_hello {\n\tuint32_t out_data;\n} __ec_align4;\n\n \n#define EC_CMD_GET_VERSION 0x0002\n\nenum ec_current_image {\n\tEC_IMAGE_UNKNOWN = 0,\n\tEC_IMAGE_RO,\n\tEC_IMAGE_RW\n};\n\n \nstruct ec_response_get_version {\n\tchar version_string_ro[32];\n\tchar version_string_rw[32];\n\tchar reserved[32];\n\tuint32_t current_image;\n} __ec_align4;\n\n \n#define EC_CMD_READ_TEST 0x0003\n\n \nstruct ec_params_read_test {\n\tuint32_t offset;\n\tuint32_t size;\n} __ec_align4;\n\n \nstruct ec_response_read_test {\n\tuint32_t data[32];\n} __ec_align4;\n\n \n#define EC_CMD_GET_BUILD_INFO 0x0004\n\n \n#define EC_CMD_GET_CHIP_INFO 0x0005\n\n \nstruct ec_response_get_chip_info {\n\tchar vendor[32];\n\tchar name[32];\n\tchar revision[32];\n} __ec_align4;\n\n \n#define EC_CMD_GET_BOARD_VERSION 0x0006\n\n \nstruct ec_response_board_version {\n\tuint16_t board_version;\n} __ec_align2;\n\n \n#define EC_CMD_READ_MEMMAP 0x0007\n\n \nstruct ec_params_read_memmap {\n\tuint8_t offset;\n\tuint8_t size;\n} __ec_align1;\n\n \n#define EC_CMD_GET_CMD_VERSIONS 0x0008\n\n \nstruct ec_params_get_cmd_versions {\n\tuint8_t cmd;\n} __ec_align1;\n\n \nstruct ec_params_get_cmd_versions_v1 {\n\tuint16_t cmd;\n} __ec_align2;\n\n \nstruct ec_response_get_cmd_versions {\n\tuint32_t version_mask;\n} __ec_align4;\n\n \n#define EC_CMD_GET_COMMS_STATUS\t\t0x0009\n\n \nenum ec_comms_status {\n\tEC_COMMS_STATUS_PROCESSING\t= BIT(0),\t \n};\n\n \nstruct ec_response_get_comms_status {\n\tuint32_t flags;\t\t \n} __ec_align4;\n\n \n#define EC_CMD_TEST_PROTOCOL\t\t0x000A\n\n \nstruct ec_params_test_protocol {\n\tuint32_t ec_result;\n\tuint32_t ret_len;\n\tuint8_t buf[32];\n} __ec_align4;\n\n \nstruct ec_response_test_protocol {\n\tuint8_t buf[32];\n} __ec_align4;\n\n \n#define EC_CMD_GET_PROTOCOL_INFO\t0x000B\n\n \n \n#define EC_PROTOCOL_INFO_IN_PROGRESS_SUPPORTED BIT(0)\n\n \nstruct ec_response_get_protocol_info {\n\t \n\tuint32_t protocol_versions;\n\tuint16_t max_request_packet_size;\n\tuint16_t max_response_packet_size;\n\tuint32_t flags;\n} __ec_align4;\n\n\n \n \n\n \n#define EC_GSV_SET        0x80000000\n\n \n#define EC_GSV_PARAM_MASK 0x00ffffff\n\nstruct ec_params_get_set_value {\n\tuint32_t flags;\n\tuint32_t value;\n} __ec_align4;\n\nstruct ec_response_get_set_value {\n\tuint32_t flags;\n\tuint32_t value;\n} __ec_align4;\n\n \n#define EC_CMD_GSV_PAUSE_IN_S5\t0x000C\n\n \n \n#define EC_CMD_GET_FEATURES  0x000D\n\n \nenum ec_feature_code {\n\t \n\tEC_FEATURE_LIMITED = 0,\n\t \n\tEC_FEATURE_FLASH = 1,\n\t \n\tEC_FEATURE_PWM_FAN = 2,\n\t \n\tEC_FEATURE_PWM_KEYB = 3,\n\t \n\tEC_FEATURE_LIGHTBAR = 4,\n\t \n\tEC_FEATURE_LED = 5,\n\t \n\tEC_FEATURE_MOTION_SENSE = 6,\n\t \n\tEC_FEATURE_KEYB = 7,\n\t \n\tEC_FEATURE_PSTORE = 8,\n\t \n\tEC_FEATURE_PORT80 = 9,\n\t \n\tEC_FEATURE_THERMAL = 10,\n\t \n\tEC_FEATURE_BKLIGHT_SWITCH = 11,\n\t \n\tEC_FEATURE_WIFI_SWITCH = 12,\n\t \n\tEC_FEATURE_HOST_EVENTS = 13,\n\t \n\tEC_FEATURE_GPIO = 14,\n\t \n\tEC_FEATURE_I2C = 15,\n\t \n\tEC_FEATURE_CHARGER = 16,\n\t \n\tEC_FEATURE_BATTERY = 17,\n\t \n\tEC_FEATURE_SMART_BATTERY = 18,\n\t \n\tEC_FEATURE_HANG_DETECT = 19,\n\t \n\tEC_FEATURE_PMU = 20,\n\t \n\tEC_FEATURE_SUB_MCU = 21,\n\t \n\tEC_FEATURE_USB_PD = 22,\n\t \n\tEC_FEATURE_USB_MUX = 23,\n\t \n\tEC_FEATURE_MOTION_SENSE_FIFO = 24,\n\t \n\tEC_FEATURE_VSTORE = 25,\n\t \n\tEC_FEATURE_USBC_SS_MUX_VIRTUAL = 26,\n\t \n\tEC_FEATURE_RTC = 27,\n\t \n\tEC_FEATURE_FINGERPRINT = 28,\n\t \n\tEC_FEATURE_TOUCHPAD = 29,\n\t \n\tEC_FEATURE_RWSIG = 30,\n\t \n\tEC_FEATURE_DEVICE_EVENT = 31,\n\t \n\tEC_FEATURE_UNIFIED_WAKE_MASKS = 32,\n\t \n\tEC_FEATURE_HOST_EVENT64 = 33,\n\t \n\tEC_FEATURE_EXEC_IN_RAM = 34,\n\t \n\tEC_FEATURE_CEC = 35,\n\t \n\tEC_FEATURE_MOTION_SENSE_TIGHT_TIMESTAMPS = 36,\n\t \n\tEC_FEATURE_REFINED_TABLET_MODE_HYSTERESIS = 37,\n\t \n\tEC_FEATURE_SCP = 39,\n\t \n\tEC_FEATURE_ISH = 40,\n\t \n\tEC_FEATURE_TYPEC_CMD = 41,\n\t \n\tEC_FEATURE_TYPEC_REQUIRE_AP_MODE_ENTRY = 42,\n\t \n\tEC_FEATURE_TYPEC_MUX_REQUIRE_AP_ACK = 43,\n\t \n\tEC_FEATURE_S4_RESIDENCY = 44,\n\t \n\tEC_FEATURE_TYPEC_AP_MUX_SET = 45,\n\t \n\tEC_FEATURE_TYPEC_AP_VDM_SEND = 46,\n};\n\n#define EC_FEATURE_MASK_0(event_code) BIT(event_code % 32)\n#define EC_FEATURE_MASK_1(event_code) BIT(event_code - 32)\n\nstruct ec_response_get_features {\n\tuint32_t flags[2];\n} __ec_align4;\n\n \n \n#define EC_CMD_GET_SKU_ID 0x000E\n\n \n#define EC_CMD_SET_SKU_ID 0x000F\n\nstruct ec_sku_id_info {\n\tuint32_t sku_id;\n} __ec_align4;\n\n \n \n\n \n#define EC_CMD_FLASH_INFO 0x0010\n#define EC_VER_FLASH_INFO 2\n\n \nstruct ec_response_flash_info {\n\tuint32_t flash_size;\n\tuint32_t write_block_size;\n\tuint32_t erase_block_size;\n\tuint32_t protect_block_size;\n} __ec_align4;\n\n \n#define EC_FLASH_INFO_ERASE_TO_0 BIT(0)\n\n \n#define EC_FLASH_INFO_SELECT_REQUIRED BIT(1)\n\n \nstruct ec_response_flash_info_1 {\n\t \n\tuint32_t flash_size;\n\tuint32_t write_block_size;\n\tuint32_t erase_block_size;\n\tuint32_t protect_block_size;\n\n\t \n\tuint32_t write_ideal_size;\n\tuint32_t flags;\n} __ec_align4;\n\nstruct ec_params_flash_info_2 {\n\t \n\tuint16_t num_banks_desc;\n\t \n\tuint8_t reserved[2];\n} __ec_align4;\n\nstruct ec_flash_bank {\n\t \n\tuint16_t count;\n\t \n\tuint8_t size_exp;\n\t \n\tuint8_t write_size_exp;\n\t \n\tuint8_t erase_size_exp;\n\t \n\tuint8_t protect_size_exp;\n\t \n\tuint8_t reserved[2];\n};\n\nstruct ec_response_flash_info_2 {\n\t \n\tuint32_t flash_size;\n\t \n\tuint32_t flags;\n\t \n\tuint32_t write_ideal_size;\n\t \n\tuint16_t num_banks_total;\n\t \n\tuint16_t num_banks_desc;\n\tstruct ec_flash_bank banks[];\n} __ec_align4;\n\n \n#define EC_CMD_FLASH_READ 0x0011\n\n \nstruct ec_params_flash_read {\n\tuint32_t offset;\n\tuint32_t size;\n} __ec_align4;\n\n \n#define EC_CMD_FLASH_WRITE 0x0012\n#define EC_VER_FLASH_WRITE 1\n\n \n#define EC_FLASH_WRITE_VER0_SIZE 64\n\n \nstruct ec_params_flash_write {\n\tuint32_t offset;\n\tuint32_t size;\n\t \n} __ec_align4;\n\n \n#define EC_CMD_FLASH_ERASE 0x0013\n\n \nstruct ec_params_flash_erase {\n\tuint32_t offset;\n\tuint32_t size;\n} __ec_align4;\n\n \nenum ec_flash_erase_cmd {\n\tFLASH_ERASE_SECTOR,      \n\tFLASH_ERASE_SECTOR_ASYNC,   \n\tFLASH_ERASE_GET_RESULT,   \n};\n\n \nstruct ec_params_flash_erase_v1 {\n\tuint8_t  cmd;\n\tuint8_t  reserved;\n\tuint16_t flag;\n\tstruct ec_params_flash_erase params;\n} __ec_align4;\n\n \n#define EC_CMD_FLASH_PROTECT 0x0015\n#define EC_VER_FLASH_PROTECT 1   \n\n \n \n#define EC_FLASH_PROTECT_RO_AT_BOOT         BIT(0)\n \n#define EC_FLASH_PROTECT_RO_NOW             BIT(1)\n \n#define EC_FLASH_PROTECT_ALL_NOW            BIT(2)\n \n#define EC_FLASH_PROTECT_GPIO_ASSERTED      BIT(3)\n \n#define EC_FLASH_PROTECT_ERROR_STUCK        BIT(4)\n \n#define EC_FLASH_PROTECT_ERROR_INCONSISTENT BIT(5)\n \n#define EC_FLASH_PROTECT_ALL_AT_BOOT        BIT(6)\n \n#define EC_FLASH_PROTECT_RW_AT_BOOT         BIT(7)\n \n#define EC_FLASH_PROTECT_RW_NOW             BIT(8)\n \n#define EC_FLASH_PROTECT_ROLLBACK_AT_BOOT   BIT(9)\n \n#define EC_FLASH_PROTECT_ROLLBACK_NOW       BIT(10)\n\n\n \nstruct ec_params_flash_protect {\n\tuint32_t mask;\n\tuint32_t flags;\n} __ec_align4;\n\n \nstruct ec_response_flash_protect {\n\tuint32_t flags;\n\tuint32_t valid_flags;\n\tuint32_t writable_flags;\n} __ec_align4;\n\n \n\n \n#define EC_CMD_FLASH_REGION_INFO 0x0016\n#define EC_VER_FLASH_REGION_INFO 1\n\nenum ec_flash_region {\n\t \n\tEC_FLASH_REGION_RO = 0,\n\t \n\tEC_FLASH_REGION_ACTIVE,\n\t \n\tEC_FLASH_REGION_WP_RO,\n\t \n\tEC_FLASH_REGION_UPDATE,\n\t \n\tEC_FLASH_REGION_COUNT,\n};\n \n#define EC_FLASH_REGION_RW EC_FLASH_REGION_ACTIVE\n\n \nstruct ec_params_flash_region_info {\n\tuint32_t region;\n} __ec_align4;\n\nstruct ec_response_flash_region_info {\n\tuint32_t offset;\n\tuint32_t size;\n} __ec_align4;\n\n \n#define EC_CMD_VBNV_CONTEXT 0x0017\n#define EC_VER_VBNV_CONTEXT 1\n#define EC_VBNV_BLOCK_SIZE 16\n\nenum ec_vbnvcontext_op {\n\tEC_VBNV_CONTEXT_OP_READ,\n\tEC_VBNV_CONTEXT_OP_WRITE,\n};\n\nstruct ec_params_vbnvcontext {\n\tuint32_t op;\n\tuint8_t block[EC_VBNV_BLOCK_SIZE];\n} __ec_align4;\n\nstruct ec_response_vbnvcontext {\n\tuint8_t block[EC_VBNV_BLOCK_SIZE];\n} __ec_align4;\n\n\n \n#define EC_CMD_FLASH_SPI_INFO 0x0018\n\nstruct ec_response_flash_spi_info {\n\t \n\tuint8_t jedec[3];\n\n\t \n\tuint8_t reserved0;\n\n\t \n\tuint8_t mfr_dev_id[2];\n\n\t \n\tuint8_t sr1, sr2;\n} __ec_align1;\n\n\n \n#define EC_CMD_FLASH_SELECT 0x0019\n\n \nstruct ec_params_flash_select {\n\tuint8_t select;\n} __ec_align4;\n\n\n \n \n\n \n#define EC_CMD_PWM_GET_FAN_TARGET_RPM 0x0020\n\nstruct ec_response_pwm_get_fan_rpm {\n\tuint32_t rpm;\n} __ec_align4;\n\n \n#define EC_CMD_PWM_SET_FAN_TARGET_RPM 0x0021\n\n \nstruct ec_params_pwm_set_fan_target_rpm_v0 {\n\tuint32_t rpm;\n} __ec_align4;\n\n \nstruct ec_params_pwm_set_fan_target_rpm_v1 {\n\tuint32_t rpm;\n\tuint8_t fan_idx;\n} __ec_align_size1;\n\n \n \n#define EC_CMD_PWM_GET_KEYBOARD_BACKLIGHT 0x0022\n\nstruct ec_response_pwm_get_keyboard_backlight {\n\tuint8_t percent;\n\tuint8_t enabled;\n} __ec_align1;\n\n \n \n#define EC_CMD_PWM_SET_KEYBOARD_BACKLIGHT 0x0023\n\nstruct ec_params_pwm_set_keyboard_backlight {\n\tuint8_t percent;\n} __ec_align1;\n\n \n#define EC_CMD_PWM_SET_FAN_DUTY 0x0024\n\n \nstruct ec_params_pwm_set_fan_duty_v0 {\n\tuint32_t percent;\n} __ec_align4;\n\n \nstruct ec_params_pwm_set_fan_duty_v1 {\n\tuint32_t percent;\n\tuint8_t fan_idx;\n} __ec_align_size1;\n\n#define EC_CMD_PWM_SET_DUTY 0x0025\n \n#define EC_PWM_MAX_DUTY 0xffff\n\nenum ec_pwm_type {\n\t \n\tEC_PWM_TYPE_GENERIC = 0,\n\t \n\tEC_PWM_TYPE_KB_LIGHT,\n\t \n\tEC_PWM_TYPE_DISPLAY_LIGHT,\n\tEC_PWM_TYPE_COUNT,\n};\n\nstruct ec_params_pwm_set_duty {\n\tuint16_t duty;      \n\tuint8_t pwm_type;   \n\tuint8_t index;      \n} __ec_align4;\n\n#define EC_CMD_PWM_GET_DUTY 0x0026\n\nstruct ec_params_pwm_get_duty {\n\tuint8_t pwm_type;   \n\tuint8_t index;      \n} __ec_align1;\n\nstruct ec_response_pwm_get_duty {\n\tuint16_t duty;      \n} __ec_align2;\n\n \n \n#define EC_CMD_LIGHTBAR_CMD 0x0028\n\nstruct rgb_s {\n\tuint8_t r, g, b;\n} __ec_todo_unpacked;\n\n#define LB_BATTERY_LEVELS 4\n\n \nstruct lightbar_params_v0 {\n\t \n\tint32_t google_ramp_up;\n\tint32_t google_ramp_down;\n\tint32_t s3s0_ramp_up;\n\tint32_t s0_tick_delay[2];\t\t \n\tint32_t s0a_tick_delay[2];\t\t \n\tint32_t s0s3_ramp_down;\n\tint32_t s3_sleep_for;\n\tint32_t s3_ramp_up;\n\tint32_t s3_ramp_down;\n\n\t \n\tuint8_t new_s0;\n\tuint8_t osc_min[2];\t\t\t \n\tuint8_t osc_max[2];\t\t\t \n\tuint8_t w_ofs[2];\t\t\t \n\n\t \n\tuint8_t bright_bl_off_fixed[2];\t\t \n\tuint8_t bright_bl_on_min[2];\t\t \n\tuint8_t bright_bl_on_max[2];\t\t \n\n\t \n\tuint8_t battery_threshold[LB_BATTERY_LEVELS - 1];\n\n\t \n\tuint8_t s0_idx[2][LB_BATTERY_LEVELS];\t \n\tuint8_t s3_idx[2][LB_BATTERY_LEVELS];\t \n\n\t \n\tstruct rgb_s color[8];\t\t\t \n} __ec_todo_packed;\n\nstruct lightbar_params_v1 {\n\t \n\tint32_t google_ramp_up;\n\tint32_t google_ramp_down;\n\tint32_t s3s0_ramp_up;\n\tint32_t s0_tick_delay[2];\t\t \n\tint32_t s0a_tick_delay[2];\t\t \n\tint32_t s0s3_ramp_down;\n\tint32_t s3_sleep_for;\n\tint32_t s3_ramp_up;\n\tint32_t s3_ramp_down;\n\tint32_t s5_ramp_up;\n\tint32_t s5_ramp_down;\n\tint32_t tap_tick_delay;\n\tint32_t tap_gate_delay;\n\tint32_t tap_display_time;\n\n\t \n\tuint8_t tap_pct_red;\n\tuint8_t tap_pct_green;\n\tuint8_t tap_seg_min_on;\n\tuint8_t tap_seg_max_on;\n\tuint8_t tap_seg_osc;\n\tuint8_t tap_idx[3];\n\n\t \n\tuint8_t osc_min[2];\t\t\t \n\tuint8_t osc_max[2];\t\t\t \n\tuint8_t w_ofs[2];\t\t\t \n\n\t \n\tuint8_t bright_bl_off_fixed[2];\t\t \n\tuint8_t bright_bl_on_min[2];\t\t \n\tuint8_t bright_bl_on_max[2];\t\t \n\n\t \n\tuint8_t battery_threshold[LB_BATTERY_LEVELS - 1];\n\n\t \n\tuint8_t s0_idx[2][LB_BATTERY_LEVELS];\t \n\tuint8_t s3_idx[2][LB_BATTERY_LEVELS];\t \n\n\t \n\tuint8_t s5_idx;\n\n\t \n\tstruct rgb_s color[8];\t\t\t \n} __ec_todo_packed;\n\n \n\nstruct lightbar_params_v2_timing {\n\t \n\tint32_t google_ramp_up;\n\tint32_t google_ramp_down;\n\tint32_t s3s0_ramp_up;\n\tint32_t s0_tick_delay[2];\t\t \n\tint32_t s0a_tick_delay[2];\t\t \n\tint32_t s0s3_ramp_down;\n\tint32_t s3_sleep_for;\n\tint32_t s3_ramp_up;\n\tint32_t s3_ramp_down;\n\tint32_t s5_ramp_up;\n\tint32_t s5_ramp_down;\n\tint32_t tap_tick_delay;\n\tint32_t tap_gate_delay;\n\tint32_t tap_display_time;\n} __ec_todo_packed;\n\nstruct lightbar_params_v2_tap {\n\t \n\tuint8_t tap_pct_red;\n\tuint8_t tap_pct_green;\n\tuint8_t tap_seg_min_on;\n\tuint8_t tap_seg_max_on;\n\tuint8_t tap_seg_osc;\n\tuint8_t tap_idx[3];\n} __ec_todo_packed;\n\nstruct lightbar_params_v2_oscillation {\n\t \n\tuint8_t osc_min[2];\t\t\t \n\tuint8_t osc_max[2];\t\t\t \n\tuint8_t w_ofs[2];\t\t\t \n} __ec_todo_packed;\n\nstruct lightbar_params_v2_brightness {\n\t \n\tuint8_t bright_bl_off_fixed[2];\t\t \n\tuint8_t bright_bl_on_min[2];\t\t \n\tuint8_t bright_bl_on_max[2];\t\t \n} __ec_todo_packed;\n\nstruct lightbar_params_v2_thresholds {\n\t \n\tuint8_t battery_threshold[LB_BATTERY_LEVELS - 1];\n} __ec_todo_packed;\n\nstruct lightbar_params_v2_colors {\n\t \n\tuint8_t s0_idx[2][LB_BATTERY_LEVELS];\t \n\tuint8_t s3_idx[2][LB_BATTERY_LEVELS];\t \n\n\t \n\tuint8_t s5_idx;\n\n\t \n\tstruct rgb_s color[8];\t\t\t \n} __ec_todo_packed;\n\n \n#define EC_LB_PROG_LEN 192\nstruct lightbar_program {\n\tuint8_t size;\n\tuint8_t data[EC_LB_PROG_LEN];\n} __ec_todo_unpacked;\n\nstruct ec_params_lightbar {\n\tuint8_t cmd;\t\t       \n\tunion {\n\t\t \n\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t num;\n\t\t} set_brightness, seq, demo;\n\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t ctrl, reg, value;\n\t\t} reg;\n\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t led, red, green, blue;\n\t\t} set_rgb;\n\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t led;\n\t\t} get_rgb;\n\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t enable;\n\t\t} manual_suspend_ctrl;\n\n\t\tstruct lightbar_params_v0 set_params_v0;\n\t\tstruct lightbar_params_v1 set_params_v1;\n\n\t\tstruct lightbar_params_v2_timing set_v2par_timing;\n\t\tstruct lightbar_params_v2_tap set_v2par_tap;\n\t\tstruct lightbar_params_v2_oscillation set_v2par_osc;\n\t\tstruct lightbar_params_v2_brightness set_v2par_bright;\n\t\tstruct lightbar_params_v2_thresholds set_v2par_thlds;\n\t\tstruct lightbar_params_v2_colors set_v2par_colors;\n\n\t\tstruct lightbar_program set_program;\n\t};\n} __ec_todo_packed;\n\nstruct ec_response_lightbar {\n\tunion {\n\t\tstruct __ec_todo_unpacked {\n\t\t\tstruct __ec_todo_unpacked {\n\t\t\t\tuint8_t reg;\n\t\t\t\tuint8_t ic0;\n\t\t\t\tuint8_t ic1;\n\t\t\t} vals[23];\n\t\t} dump;\n\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t num;\n\t\t} get_seq, get_brightness, get_demo;\n\n\t\tstruct lightbar_params_v0 get_params_v0;\n\t\tstruct lightbar_params_v1 get_params_v1;\n\n\n\t\tstruct lightbar_params_v2_timing get_params_v2_timing;\n\t\tstruct lightbar_params_v2_tap get_params_v2_tap;\n\t\tstruct lightbar_params_v2_oscillation get_params_v2_osc;\n\t\tstruct lightbar_params_v2_brightness get_params_v2_bright;\n\t\tstruct lightbar_params_v2_thresholds get_params_v2_thlds;\n\t\tstruct lightbar_params_v2_colors get_params_v2_colors;\n\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint32_t num;\n\t\t\tuint32_t flags;\n\t\t} version;\n\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t red, green, blue;\n\t\t} get_rgb;\n\n\t\t \n\t};\n} __ec_todo_packed;\n\n \nenum lightbar_command {\n\tLIGHTBAR_CMD_DUMP = 0,\n\tLIGHTBAR_CMD_OFF = 1,\n\tLIGHTBAR_CMD_ON = 2,\n\tLIGHTBAR_CMD_INIT = 3,\n\tLIGHTBAR_CMD_SET_BRIGHTNESS = 4,\n\tLIGHTBAR_CMD_SEQ = 5,\n\tLIGHTBAR_CMD_REG = 6,\n\tLIGHTBAR_CMD_SET_RGB = 7,\n\tLIGHTBAR_CMD_GET_SEQ = 8,\n\tLIGHTBAR_CMD_DEMO = 9,\n\tLIGHTBAR_CMD_GET_PARAMS_V0 = 10,\n\tLIGHTBAR_CMD_SET_PARAMS_V0 = 11,\n\tLIGHTBAR_CMD_VERSION = 12,\n\tLIGHTBAR_CMD_GET_BRIGHTNESS = 13,\n\tLIGHTBAR_CMD_GET_RGB = 14,\n\tLIGHTBAR_CMD_GET_DEMO = 15,\n\tLIGHTBAR_CMD_GET_PARAMS_V1 = 16,\n\tLIGHTBAR_CMD_SET_PARAMS_V1 = 17,\n\tLIGHTBAR_CMD_SET_PROGRAM = 18,\n\tLIGHTBAR_CMD_MANUAL_SUSPEND_CTRL = 19,\n\tLIGHTBAR_CMD_SUSPEND = 20,\n\tLIGHTBAR_CMD_RESUME = 21,\n\tLIGHTBAR_CMD_GET_PARAMS_V2_TIMING = 22,\n\tLIGHTBAR_CMD_SET_PARAMS_V2_TIMING = 23,\n\tLIGHTBAR_CMD_GET_PARAMS_V2_TAP = 24,\n\tLIGHTBAR_CMD_SET_PARAMS_V2_TAP = 25,\n\tLIGHTBAR_CMD_GET_PARAMS_V2_OSCILLATION = 26,\n\tLIGHTBAR_CMD_SET_PARAMS_V2_OSCILLATION = 27,\n\tLIGHTBAR_CMD_GET_PARAMS_V2_BRIGHTNESS = 28,\n\tLIGHTBAR_CMD_SET_PARAMS_V2_BRIGHTNESS = 29,\n\tLIGHTBAR_CMD_GET_PARAMS_V2_THRESHOLDS = 30,\n\tLIGHTBAR_CMD_SET_PARAMS_V2_THRESHOLDS = 31,\n\tLIGHTBAR_CMD_GET_PARAMS_V2_COLORS = 32,\n\tLIGHTBAR_CMD_SET_PARAMS_V2_COLORS = 33,\n\tLIGHTBAR_NUM_CMDS\n};\n\n \n \n\n#define EC_CMD_LED_CONTROL 0x0029\n\nenum ec_led_id {\n\t \n\tEC_LED_ID_BATTERY_LED = 0,\n\t \n\tEC_LED_ID_POWER_LED,\n\t \n\tEC_LED_ID_ADAPTER_LED,\n\t \n\tEC_LED_ID_LEFT_LED,\n\t \n\tEC_LED_ID_RIGHT_LED,\n\t \n\tEC_LED_ID_RECOVERY_HW_REINIT_LED,\n\t \n\tEC_LED_ID_SYSRQ_DEBUG_LED,\n\n\tEC_LED_ID_COUNT\n};\n\n \n#define EC_LED_FLAGS_QUERY BIT(0)  \n#define EC_LED_FLAGS_AUTO  BIT(1)  \n\nenum ec_led_colors {\n\tEC_LED_COLOR_RED = 0,\n\tEC_LED_COLOR_GREEN,\n\tEC_LED_COLOR_BLUE,\n\tEC_LED_COLOR_YELLOW,\n\tEC_LED_COLOR_WHITE,\n\tEC_LED_COLOR_AMBER,\n\n\tEC_LED_COLOR_COUNT\n};\n\nstruct ec_params_led_control {\n\tuint8_t led_id;      \n\tuint8_t flags;       \n\n\tuint8_t brightness[EC_LED_COLOR_COUNT];\n} __ec_align1;\n\nstruct ec_response_led_control {\n\t \n\tuint8_t brightness_range[EC_LED_COLOR_COUNT];\n} __ec_align1;\n\n \n \n\n \n\n \n#define EC_CMD_VBOOT_HASH 0x002A\n\nstruct ec_params_vboot_hash {\n\tuint8_t cmd;              \n\tuint8_t hash_type;        \n\tuint8_t nonce_size;       \n\tuint8_t reserved0;        \n\tuint32_t offset;          \n\tuint32_t size;            \n\tuint8_t nonce_data[64];   \n} __ec_align4;\n\nstruct ec_response_vboot_hash {\n\tuint8_t status;           \n\tuint8_t hash_type;        \n\tuint8_t digest_size;      \n\tuint8_t reserved0;        \n\tuint32_t offset;          \n\tuint32_t size;            \n\tuint8_t hash_digest[64];  \n} __ec_align4;\n\nenum ec_vboot_hash_cmd {\n\tEC_VBOOT_HASH_GET = 0,        \n\tEC_VBOOT_HASH_ABORT = 1,      \n\tEC_VBOOT_HASH_START = 2,      \n\tEC_VBOOT_HASH_RECALC = 3,     \n};\n\nenum ec_vboot_hash_type {\n\tEC_VBOOT_HASH_TYPE_SHA256 = 0,  \n};\n\nenum ec_vboot_hash_status {\n\tEC_VBOOT_HASH_STATUS_NONE = 0,  \n\tEC_VBOOT_HASH_STATUS_DONE = 1,  \n\tEC_VBOOT_HASH_STATUS_BUSY = 2,  \n};\n\n \n#define EC_VBOOT_HASH_OFFSET_RO\t\t0xfffffffe\n#define EC_VBOOT_HASH_OFFSET_ACTIVE\t0xfffffffd\n#define EC_VBOOT_HASH_OFFSET_UPDATE\t0xfffffffc\n\n \n#define EC_VBOOT_HASH_OFFSET_RW EC_VBOOT_HASH_OFFSET_ACTIVE\n\n \n \n#define EC_CMD_MOTION_SENSE_CMD 0x002B\n\n \nenum motionsense_command {\n\t \n\tMOTIONSENSE_CMD_DUMP = 0,\n\n\t \n\tMOTIONSENSE_CMD_INFO = 1,\n\n\t \n\tMOTIONSENSE_CMD_EC_RATE = 2,\n\n\t \n\tMOTIONSENSE_CMD_SENSOR_ODR = 3,\n\n\t \n\tMOTIONSENSE_CMD_SENSOR_RANGE = 4,\n\n\t \n\tMOTIONSENSE_CMD_KB_WAKE_ANGLE = 5,\n\n\t \n\tMOTIONSENSE_CMD_DATA = 6,\n\n\t \n\tMOTIONSENSE_CMD_FIFO_INFO = 7,\n\n\t \n\tMOTIONSENSE_CMD_FIFO_FLUSH = 8,\n\n\t \n\tMOTIONSENSE_CMD_FIFO_READ = 9,\n\n\t \n\tMOTIONSENSE_CMD_PERFORM_CALIB = 10,\n\n\t \n\tMOTIONSENSE_CMD_SENSOR_OFFSET = 11,\n\n\t \n\tMOTIONSENSE_CMD_LIST_ACTIVITIES = 12,\n\n\t \n\tMOTIONSENSE_CMD_SET_ACTIVITY = 13,\n\n\t \n\tMOTIONSENSE_CMD_LID_ANGLE = 14,\n\n\t \n\tMOTIONSENSE_CMD_FIFO_INT_ENABLE = 15,\n\n\t \n\tMOTIONSENSE_CMD_SPOOF = 16,\n\n\t \n\tMOTIONSENSE_CMD_TABLET_MODE_LID_ANGLE = 17,\n\n\t \n\tMOTIONSENSE_CMD_SENSOR_SCALE = 18,\n\n\t \n\tMOTIONSENSE_NUM_CMDS\n};\n\n \nenum motionsensor_type {\n\tMOTIONSENSE_TYPE_ACCEL = 0,\n\tMOTIONSENSE_TYPE_GYRO = 1,\n\tMOTIONSENSE_TYPE_MAG = 2,\n\tMOTIONSENSE_TYPE_PROX = 3,\n\tMOTIONSENSE_TYPE_LIGHT = 4,\n\tMOTIONSENSE_TYPE_ACTIVITY = 5,\n\tMOTIONSENSE_TYPE_BARO = 6,\n\tMOTIONSENSE_TYPE_SYNC = 7,\n\tMOTIONSENSE_TYPE_MAX,\n};\n\n \nenum motionsensor_location {\n\tMOTIONSENSE_LOC_BASE = 0,\n\tMOTIONSENSE_LOC_LID = 1,\n\tMOTIONSENSE_LOC_CAMERA = 2,\n\tMOTIONSENSE_LOC_MAX,\n};\n\n \nenum motionsensor_chip {\n\tMOTIONSENSE_CHIP_KXCJ9 = 0,\n\tMOTIONSENSE_CHIP_LSM6DS0 = 1,\n\tMOTIONSENSE_CHIP_BMI160 = 2,\n\tMOTIONSENSE_CHIP_SI1141 = 3,\n\tMOTIONSENSE_CHIP_SI1142 = 4,\n\tMOTIONSENSE_CHIP_SI1143 = 5,\n\tMOTIONSENSE_CHIP_KX022 = 6,\n\tMOTIONSENSE_CHIP_L3GD20H = 7,\n\tMOTIONSENSE_CHIP_BMA255 = 8,\n\tMOTIONSENSE_CHIP_BMP280 = 9,\n\tMOTIONSENSE_CHIP_OPT3001 = 10,\n\tMOTIONSENSE_CHIP_BH1730 = 11,\n\tMOTIONSENSE_CHIP_GPIO = 12,\n\tMOTIONSENSE_CHIP_LIS2DH = 13,\n\tMOTIONSENSE_CHIP_LSM6DSM = 14,\n\tMOTIONSENSE_CHIP_LIS2DE = 15,\n\tMOTIONSENSE_CHIP_LIS2MDL = 16,\n\tMOTIONSENSE_CHIP_LSM6DS3 = 17,\n\tMOTIONSENSE_CHIP_LSM6DSO = 18,\n\tMOTIONSENSE_CHIP_LNG2DM = 19,\n\tMOTIONSENSE_CHIP_MAX,\n};\n\n \nenum motionsensor_orientation {\n\tMOTIONSENSE_ORIENTATION_LANDSCAPE = 0,\n\tMOTIONSENSE_ORIENTATION_PORTRAIT = 1,\n\tMOTIONSENSE_ORIENTATION_UPSIDE_DOWN_PORTRAIT = 2,\n\tMOTIONSENSE_ORIENTATION_UPSIDE_DOWN_LANDSCAPE = 3,\n\tMOTIONSENSE_ORIENTATION_UNKNOWN = 4,\n};\n\nstruct ec_response_motion_sensor_data {\n\t \n\tuint8_t flags;\n\t \n\tuint8_t sensor_num;\n\t \n\tunion {\n\t\tint16_t             data[3];\n\t\tstruct __ec_todo_packed {\n\t\t\tuint16_t    reserved;\n\t\t\tuint32_t    timestamp;\n\t\t};\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t     activity;  \n\t\t\tuint8_t     state;\n\t\t\tint16_t     add_info[2];\n\t\t};\n\t};\n} __ec_todo_packed;\n\n \nstruct ec_response_motion_sense_fifo_info {\n\t \n\tuint16_t size;\n\t \n\tuint16_t count;\n\t \n\tuint32_t timestamp;\n\t \n\tuint16_t total_lost;\n\t \n\tuint16_t lost[];\n} __ec_todo_packed;\n\nstruct ec_response_motion_sense_fifo_data {\n\tuint32_t number_data;\n\tstruct ec_response_motion_sensor_data data[];\n} __ec_todo_packed;\n\n \nenum motionsensor_activity {\n\tMOTIONSENSE_ACTIVITY_RESERVED = 0,\n\tMOTIONSENSE_ACTIVITY_SIG_MOTION = 1,\n\tMOTIONSENSE_ACTIVITY_DOUBLE_TAP = 2,\n\tMOTIONSENSE_ACTIVITY_ORIENTATION = 3,\n};\n\nstruct ec_motion_sense_activity {\n\tuint8_t sensor_num;\n\tuint8_t activity;  \n\tuint8_t enable;    \n\tuint8_t reserved;\n\tuint16_t parameters[3];  \n} __ec_todo_unpacked;\n\n \n#define MOTIONSENSE_MODULE_FLAG_ACTIVE BIT(0)\n\n \n#define MOTIONSENSE_SENSOR_FLAG_PRESENT BIT(0)\n\n \n#define MOTIONSENSE_SENSOR_FLAG_FLUSH BIT(0)\n#define MOTIONSENSE_SENSOR_FLAG_TIMESTAMP BIT(1)\n#define MOTIONSENSE_SENSOR_FLAG_WAKEUP BIT(2)\n#define MOTIONSENSE_SENSOR_FLAG_TABLET_MODE BIT(3)\n#define MOTIONSENSE_SENSOR_FLAG_ODR BIT(4)\n\n \n#define EC_MOTION_SENSE_NO_VALUE -1\n\n#define EC_MOTION_SENSE_INVALID_CALIB_TEMP 0x8000\n\n \n \n#define MOTION_SENSE_SET_OFFSET BIT(0)\n\n \n#define MOTION_SENSE_DEFAULT_SCALE BIT(15)\n\n#define LID_ANGLE_UNRELIABLE 500\n\nenum motionsense_spoof_mode {\n\t \n\tMOTIONSENSE_SPOOF_MODE_DISABLE = 0,\n\n\t \n\tMOTIONSENSE_SPOOF_MODE_CUSTOM,\n\n\t \n\tMOTIONSENSE_SPOOF_MODE_LOCK_CURRENT,\n\n\t \n\tMOTIONSENSE_SPOOF_MODE_QUERY,\n};\n\nstruct ec_params_motion_sense {\n\tuint8_t cmd;\n\tunion {\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tuint8_t max_sensor_count;\n\t\t} dump;\n\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tint16_t data;\n\t\t} kb_wake_angle;\n\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t sensor_num;\n\t\t} info, info_3, data, fifo_flush, perform_calib,\n\t\t\t\tlist_activities;\n\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t sensor_num;\n\n\t\t\t \n\t\t\tuint8_t roundup;\n\n\t\t\tuint16_t reserved;\n\n\t\t\t \n\t\t\tint32_t data;\n\t\t} ec_rate, sensor_odr, sensor_range;\n\n\t\t \n\t\tstruct __ec_todo_packed {\n\t\t\tuint8_t sensor_num;\n\n\t\t\t \n\t\t\tuint16_t flags;\n\n\t\t\t \n\t\t\tint16_t temp;\n\n\t\t\t \n\t\t\tint16_t offset[3];\n\t\t} sensor_offset;\n\n\t\t \n\t\tstruct __ec_todo_packed {\n\t\t\tuint8_t sensor_num;\n\n\t\t\t \n\t\t\tuint16_t flags;\n\n\t\t\t \n\t\t\tint16_t temp;\n\n\t\t\t \n\t\t\tuint16_t scale[3];\n\t\t} sensor_scale;\n\n\n\t\t \n\t\t \n\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tuint32_t max_data_vector;\n\t\t} fifo_read;\n\n\t\tstruct ec_motion_sense_activity set_activity;\n\n\t\t \n\t\t \n\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tint8_t enable;\n\t\t} fifo_int_enable;\n\n\t\t \n\t\tstruct __ec_todo_packed {\n\t\t\tuint8_t sensor_id;\n\n\t\t\t \n\t\t\tuint8_t spoof_enable;\n\n\t\t\t \n\t\t\tuint8_t reserved;\n\n\t\t\t \n\t\t\tint16_t components[3];\n\t\t} spoof;\n\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tint16_t lid_angle;\n\n\t\t\t \n\t\t\tint16_t hys_degree;\n\t\t} tablet_mode_threshold;\n\t};\n} __ec_todo_packed;\n\nstruct ec_response_motion_sense {\n\tunion {\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tuint8_t module_flags;\n\n\t\t\t \n\t\t\tuint8_t sensor_count;\n\n\t\t\t \n\t\t\tDECLARE_FLEX_ARRAY(struct ec_response_motion_sensor_data, sensor);\n\t\t} dump;\n\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tuint8_t type;\n\n\t\t\t \n\t\t\tuint8_t location;\n\n\t\t\t \n\t\t\tuint8_t chip;\n\t\t} info;\n\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tuint8_t type;\n\n\t\t\t \n\t\t\tuint8_t location;\n\n\t\t\t \n\t\t\tuint8_t chip;\n\n\t\t\t \n\t\t\tuint32_t min_frequency;\n\n\t\t\t \n\t\t\tuint32_t max_frequency;\n\n\t\t\t \n\t\t\tuint32_t fifo_max_event_count;\n\t\t} info_3;\n\n\t\t \n\t\tstruct ec_response_motion_sensor_data data;\n\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tint32_t ret;\n\t\t} ec_rate, sensor_odr, sensor_range, kb_wake_angle,\n\t\t  fifo_int_enable, spoof;\n\n\t\t \n\t\tstruct __ec_todo_unpacked  {\n\t\t\tint16_t temp;\n\t\t\tint16_t offset[3];\n\t\t} sensor_offset, perform_calib;\n\n\t\t \n\t\tstruct __ec_todo_unpacked  {\n\t\t\tint16_t temp;\n\t\t\tuint16_t scale[3];\n\t\t} sensor_scale;\n\n\t\tstruct ec_response_motion_sense_fifo_info fifo_info, fifo_flush;\n\n\t\tstruct ec_response_motion_sense_fifo_data fifo_read;\n\n\t\tstruct __ec_todo_packed {\n\t\t\tuint16_t reserved;\n\t\t\tuint32_t enabled;\n\t\t\tuint32_t disabled;\n\t\t} list_activities;\n\n\t\t \n\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tuint16_t value;\n\t\t} lid_angle;\n\n\t\t \n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tuint16_t lid_angle;\n\n\t\t\t \n\t\t\tuint16_t hys_degree;\n\t\t} tablet_mode_threshold;\n\n\t};\n} __ec_todo_packed;\n\n \n \n\n \n#define EC_CMD_FORCE_LID_OPEN 0x002C\n\nstruct ec_params_force_lid_open {\n\tuint8_t enabled;\n} __ec_align1;\n\n \n \n#define EC_CMD_CONFIG_POWER_BUTTON 0x002D\n\nenum ec_config_power_button_flags {\n\t \n\tEC_POWER_BUTTON_ENABLE_PULSE = BIT(0),\n};\n\nstruct ec_params_config_power_button {\n\t \n\tuint8_t flags;\n} __ec_align1;\n\n \n \n\n \n#define EC_CMD_USB_CHARGE_SET_MODE 0x0030\n\nstruct ec_params_usb_charge_set_mode {\n\tuint8_t usb_port_id;\n\tuint8_t mode:7;\n\tuint8_t inhibit_charge:1;\n} __ec_align1;\n\n \n \n\n \n#define EC_PSTORE_SIZE_MAX 64\n\n \n#define EC_CMD_PSTORE_INFO 0x0040\n\nstruct ec_response_pstore_info {\n\t \n\tuint32_t pstore_size;\n\t \n\tuint32_t access_size;\n} __ec_align4;\n\n \n#define EC_CMD_PSTORE_READ 0x0041\n\nstruct ec_params_pstore_read {\n\tuint32_t offset;    \n\tuint32_t size;      \n} __ec_align4;\n\n \n#define EC_CMD_PSTORE_WRITE 0x0042\n\nstruct ec_params_pstore_write {\n\tuint32_t offset;    \n\tuint32_t size;      \n\tuint8_t data[EC_PSTORE_SIZE_MAX];\n} __ec_align4;\n\n \n \n\n \nstruct ec_params_rtc {\n\tuint32_t time;\n} __ec_align4;\n\nstruct ec_response_rtc {\n\tuint32_t time;\n} __ec_align4;\n\n \n#define EC_CMD_RTC_GET_VALUE 0x0044\n#define EC_CMD_RTC_GET_ALARM 0x0045\n\n \n#define EC_CMD_RTC_SET_VALUE 0x0046\n#define EC_CMD_RTC_SET_ALARM 0x0047\n\n \n#define EC_RTC_ALARM_CLEAR 0\n\n \n \n\n \n#define EC_PORT80_SIZE_MAX 32\n\n \n#define EC_CMD_PORT80_LAST_BOOT 0x0048\n#define EC_CMD_PORT80_READ 0x0048\n\nenum ec_port80_subcmd {\n\tEC_PORT80_GET_INFO = 0,\n\tEC_PORT80_READ_BUFFER,\n};\n\nstruct ec_params_port80_read {\n\tuint16_t subcmd;\n\tunion {\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint32_t offset;\n\t\t\tuint32_t num_entries;\n\t\t} read_buffer;\n\t};\n} __ec_todo_packed;\n\nstruct ec_response_port80_read {\n\tunion {\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint32_t writes;\n\t\t\tuint32_t history_size;\n\t\t\tuint32_t last_boot;\n\t\t} get_info;\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint16_t codes[EC_PORT80_SIZE_MAX];\n\t\t} data;\n\t};\n} __ec_todo_packed;\n\nstruct ec_response_port80_last_boot {\n\tuint16_t code;\n} __ec_align2;\n\n \n \n\n \n#define EC_VSTORE_SLOT_SIZE 64\n\n \n#define EC_VSTORE_SLOT_MAX 32\n\n \n#define EC_CMD_VSTORE_INFO 0x0049\nstruct ec_response_vstore_info {\n\t \n\tuint32_t slot_locked;\n\t \n\tuint8_t slot_count;\n} __ec_align_size1;\n\n \n#define EC_CMD_VSTORE_READ 0x004A\n\nstruct ec_params_vstore_read {\n\tuint8_t slot;  \n} __ec_align1;\n\nstruct ec_response_vstore_read {\n\tuint8_t data[EC_VSTORE_SLOT_SIZE];\n} __ec_align1;\n\n \n#define EC_CMD_VSTORE_WRITE 0x004B\n\nstruct ec_params_vstore_write {\n\tuint8_t slot;  \n\tuint8_t data[EC_VSTORE_SLOT_SIZE];\n} __ec_align1;\n\n \n \n\n#define EC_CMD_THERMAL_SET_THRESHOLD 0x0050\n#define EC_CMD_THERMAL_GET_THRESHOLD 0x0051\n\n \n\n \nstruct ec_params_thermal_set_threshold {\n\tuint8_t sensor_type;\n\tuint8_t threshold_id;\n\tuint16_t value;\n} __ec_align2;\n\n \nstruct ec_params_thermal_get_threshold {\n\tuint8_t sensor_type;\n\tuint8_t threshold_id;\n} __ec_align1;\n\nstruct ec_response_thermal_get_threshold {\n\tuint16_t value;\n} __ec_align2;\n\n\n \nenum ec_temp_thresholds {\n\tEC_TEMP_THRESH_WARN = 0,\n\tEC_TEMP_THRESH_HIGH,\n\tEC_TEMP_THRESH_HALT,\n\n\tEC_TEMP_THRESH_COUNT\n};\n\n \nstruct ec_thermal_config {\n\tuint32_t temp_host[EC_TEMP_THRESH_COUNT];  \n\tuint32_t temp_host_release[EC_TEMP_THRESH_COUNT];  \n\tuint32_t temp_fan_off;\t\t \n\tuint32_t temp_fan_max;\t\t \n} __ec_align4;\n\n \nstruct ec_params_thermal_get_threshold_v1 {\n\tuint32_t sensor_num;\n} __ec_align4;\n \n\n \nstruct ec_params_thermal_set_threshold_v1 {\n\tuint32_t sensor_num;\n\tstruct ec_thermal_config cfg;\n} __ec_align4;\n \n\n \n\n \n#define EC_CMD_THERMAL_AUTO_FAN_CTRL 0x0052\n\n \nstruct ec_params_auto_fan_ctrl_v1 {\n\tuint8_t fan_idx;\n} __ec_align1;\n\n \n#define EC_CMD_TMP006_GET_CALIBRATION 0x0053\n#define EC_CMD_TMP006_SET_CALIBRATION 0x0054\n\n \n\n \nstruct ec_params_tmp006_get_calibration {\n\tuint8_t index;\n} __ec_align1;\n\n \nstruct ec_response_tmp006_get_calibration_v0 {\n\tfloat s0;\n\tfloat b0;\n\tfloat b1;\n\tfloat b2;\n} __ec_align4;\n\nstruct ec_params_tmp006_set_calibration_v0 {\n\tuint8_t index;\n\tuint8_t reserved[3];\n\tfloat s0;\n\tfloat b0;\n\tfloat b1;\n\tfloat b2;\n} __ec_align4;\n\n \nstruct ec_response_tmp006_get_calibration_v1 {\n\tuint8_t algorithm;\n\tuint8_t num_params;\n\tuint8_t reserved[2];\n\tfloat val[];\n} __ec_align4;\n\nstruct ec_params_tmp006_set_calibration_v1 {\n\tuint8_t index;\n\tuint8_t algorithm;\n\tuint8_t num_params;\n\tuint8_t reserved;\n\tfloat val[];\n} __ec_align4;\n\n\n \n#define EC_CMD_TMP006_GET_RAW 0x0055\n\nstruct ec_params_tmp006_get_raw {\n\tuint8_t index;\n} __ec_align1;\n\nstruct ec_response_tmp006_get_raw {\n\tint32_t t;   \n\tint32_t v;   \n} __ec_align4;\n\n \n \n\n \n#define EC_CMD_MKBP_STATE 0x0060\n\n \n#define EC_CMD_MKBP_INFO 0x0061\n\nstruct ec_response_mkbp_info {\n\tuint32_t rows;\n\tuint32_t cols;\n\t \n\tuint8_t reserved;\n} __ec_align_size1;\n\nstruct ec_params_mkbp_info {\n\tuint8_t info_type;\n\tuint8_t event_type;\n} __ec_align1;\n\nenum ec_mkbp_info_type {\n\t \n\tEC_MKBP_INFO_KBD = 0,\n\n\t \n\tEC_MKBP_INFO_SUPPORTED = 1,\n\n\t \n\tEC_MKBP_INFO_CURRENT = 2,\n};\n\n \n#define EC_CMD_MKBP_SIMULATE_KEY 0x0062\n\nstruct ec_params_mkbp_simulate_key {\n\tuint8_t col;\n\tuint8_t row;\n\tuint8_t pressed;\n} __ec_align1;\n\n#define EC_CMD_GET_KEYBOARD_ID 0x0063\n\nstruct ec_response_keyboard_id {\n\tuint32_t keyboard_id;\n} __ec_align4;\n\nenum keyboard_id {\n\tKEYBOARD_ID_UNSUPPORTED = 0,\n\tKEYBOARD_ID_UNREADABLE = 0xffffffff,\n};\n\n \n#define EC_CMD_MKBP_SET_CONFIG 0x0064\n#define EC_CMD_MKBP_GET_CONFIG 0x0065\n\n \nenum mkbp_config_flags {\n\tEC_MKBP_FLAGS_ENABLE = 1,\t \n};\n\nenum mkbp_config_valid {\n\tEC_MKBP_VALID_SCAN_PERIOD\t\t= BIT(0),\n\tEC_MKBP_VALID_POLL_TIMEOUT\t\t= BIT(1),\n\tEC_MKBP_VALID_MIN_POST_SCAN_DELAY\t= BIT(3),\n\tEC_MKBP_VALID_OUTPUT_SETTLE\t\t= BIT(4),\n\tEC_MKBP_VALID_DEBOUNCE_DOWN\t\t= BIT(5),\n\tEC_MKBP_VALID_DEBOUNCE_UP\t\t= BIT(6),\n\tEC_MKBP_VALID_FIFO_MAX_DEPTH\t\t= BIT(7),\n};\n\n \nstruct ec_mkbp_config {\n\tuint32_t valid_mask;\t\t \n\tuint8_t flags;\t\t \n\tuint8_t valid_flags;\t\t \n\tuint16_t scan_period_us;\t \n\t \n\tuint32_t poll_timeout_us;\n\t \n\tuint16_t min_post_scan_delay_us;\n\t \n\tuint16_t output_settle_us;\n\tuint16_t debounce_down_us;\t \n\tuint16_t debounce_up_us;\t \n\t \n\tuint8_t fifo_max_depth;\n} __ec_align_size1;\n\nstruct ec_params_mkbp_set_config {\n\tstruct ec_mkbp_config config;\n} __ec_align_size1;\n\nstruct ec_response_mkbp_get_config {\n\tstruct ec_mkbp_config config;\n} __ec_align_size1;\n\n \n#define EC_CMD_KEYSCAN_SEQ_CTRL 0x0066\n\nenum ec_keyscan_seq_cmd {\n\tEC_KEYSCAN_SEQ_STATUS = 0,\t \n\tEC_KEYSCAN_SEQ_CLEAR = 1,\t \n\tEC_KEYSCAN_SEQ_ADD = 2,\t\t \n\tEC_KEYSCAN_SEQ_START = 3,\t \n\tEC_KEYSCAN_SEQ_COLLECT = 4,\t \n};\n\nenum ec_collect_flags {\n\t \n\tEC_KEYSCAN_SEQ_FLAG_DONE\t= BIT(0),\n};\n\nstruct ec_collect_item {\n\tuint8_t flags;\t\t \n} __ec_align1;\n\nstruct ec_params_keyscan_seq_ctrl {\n\tuint8_t cmd;\t \n\tunion {\n\t\tstruct __ec_align1 {\n\t\t\tuint8_t active;\t\t \n\t\t\tuint8_t num_items;\t \n\t\t\t \n\t\t\tuint8_t cur_item;\n\t\t} status;\n\t\tstruct __ec_todo_unpacked {\n\t\t\t \n\t\t\tuint32_t time_us;\n\t\t\tuint8_t scan[0];\t \n\t\t} add;\n\t\tstruct __ec_align1 {\n\t\t\tuint8_t start_item;\t \n\t\t\tuint8_t num_items;\t \n\t\t} collect;\n\t};\n} __ec_todo_packed;\n\nstruct ec_result_keyscan_seq_ctrl {\n\tunion {\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t num_items;\t \n\t\t\t \n\t\t\tstruct ec_collect_item item[0];\n\t\t} collect;\n\t};\n} __ec_todo_packed;\n\n \n#define EC_CMD_GET_NEXT_EVENT 0x0067\n\n#define EC_MKBP_HAS_MORE_EVENTS_SHIFT 7\n\n \n#define EC_MKBP_HAS_MORE_EVENTS BIT(EC_MKBP_HAS_MORE_EVENTS_SHIFT)\n\n \n#define EC_MKBP_EVENT_TYPE_MASK (BIT(EC_MKBP_HAS_MORE_EVENTS_SHIFT) - 1)\n\nenum ec_mkbp_event {\n\t \n\tEC_MKBP_EVENT_KEY_MATRIX = 0,\n\n\t \n\tEC_MKBP_EVENT_HOST_EVENT = 1,\n\n\t \n\tEC_MKBP_EVENT_SENSOR_FIFO = 2,\n\n\t \n\tEC_MKBP_EVENT_BUTTON = 3,\n\n\t \n\tEC_MKBP_EVENT_SWITCH = 4,\n\n\t \n\tEC_MKBP_EVENT_FINGERPRINT = 5,\n\n\t \n\tEC_MKBP_EVENT_SYSRQ = 6,\n\n\t \n\tEC_MKBP_EVENT_HOST_EVENT64 = 7,\n\n\t \n\tEC_MKBP_EVENT_CEC_EVENT = 8,\n\n\t \n\tEC_MKBP_EVENT_CEC_MESSAGE = 9,\n\n\t \n\tEC_MKBP_EVENT_PCHG = 12,\n\n\t \n\tEC_MKBP_EVENT_COUNT,\n};\nBUILD_ASSERT(EC_MKBP_EVENT_COUNT <= EC_MKBP_EVENT_TYPE_MASK);\n\nunion __ec_align_offset1 ec_response_get_next_data {\n\tuint8_t key_matrix[13];\n\n\t \n\tuint32_t host_event;\n\tuint64_t host_event64;\n\n\tstruct __ec_todo_unpacked {\n\t\t \n\t\tuint8_t reserved[3];\n\t\tstruct ec_response_motion_sense_fifo_info info;\n\t} sensor_fifo;\n\n\tuint32_t buttons;\n\n\tuint32_t switches;\n\n\tuint32_t fp_events;\n\n\tuint32_t sysrq;\n\n\t \n\tuint32_t cec_events;\n};\n\nunion __ec_align_offset1 ec_response_get_next_data_v1 {\n\tuint8_t key_matrix[16];\n\n\t \n\tuint32_t host_event;\n\tuint64_t host_event64;\n\n\tstruct __ec_todo_unpacked {\n\t\t \n\t\tuint8_t reserved[3];\n\t\tstruct ec_response_motion_sense_fifo_info info;\n\t} sensor_fifo;\n\n\tuint32_t buttons;\n\n\tuint32_t switches;\n\n\tuint32_t fp_events;\n\n\tuint32_t sysrq;\n\n\t \n\tuint32_t cec_events;\n\n\tuint8_t cec_message[16];\n};\nBUILD_ASSERT(sizeof(union ec_response_get_next_data_v1) == 16);\n\nstruct ec_response_get_next_event {\n\tuint8_t event_type;\n\t \n\tunion ec_response_get_next_data data;\n} __ec_align1;\n\nstruct ec_response_get_next_event_v1 {\n\tuint8_t event_type;\n\t \n\tunion ec_response_get_next_data_v1 data;\n} __ec_align1;\n\n \n \n#define EC_MKBP_POWER_BUTTON\t0\n#define EC_MKBP_VOL_UP\t\t1\n#define EC_MKBP_VOL_DOWN\t2\n#define EC_MKBP_RECOVERY\t3\n#define EC_MKBP_BRI_UP\t\t4\n#define EC_MKBP_BRI_DOWN\t5\n#define EC_MKBP_SCREEN_LOCK\t6\n\n \n#define EC_MKBP_LID_OPEN\t0\n#define EC_MKBP_TABLET_MODE\t1\n#define EC_MKBP_BASE_ATTACHED\t2\n#define EC_MKBP_FRONT_PROXIMITY\t3\n\n \n#define EC_CMD_KEYBOARD_FACTORY_TEST 0x0068\n\nstruct ec_response_keyboard_factory_test {\n\tuint16_t shorted;\t \n} __ec_align2;\n\n \n#define EC_MKBP_FP_RAW_EVENT(fp_events) ((fp_events) & 0x00FFFFFF)\n#define EC_MKBP_FP_ERRCODE(fp_events)   ((fp_events) & 0x0000000F)\n#define EC_MKBP_FP_ENROLL_PROGRESS_OFFSET 4\n#define EC_MKBP_FP_ENROLL_PROGRESS(fpe) (((fpe) & 0x00000FF0) \\\n\t\t\t\t\t >> EC_MKBP_FP_ENROLL_PROGRESS_OFFSET)\n#define EC_MKBP_FP_MATCH_IDX_OFFSET 12\n#define EC_MKBP_FP_MATCH_IDX_MASK 0x0000F000\n#define EC_MKBP_FP_MATCH_IDX(fpe) (((fpe) & EC_MKBP_FP_MATCH_IDX_MASK) \\\n\t\t\t\t\t >> EC_MKBP_FP_MATCH_IDX_OFFSET)\n#define EC_MKBP_FP_ENROLL               BIT(27)\n#define EC_MKBP_FP_MATCH                BIT(28)\n#define EC_MKBP_FP_FINGER_DOWN          BIT(29)\n#define EC_MKBP_FP_FINGER_UP            BIT(30)\n#define EC_MKBP_FP_IMAGE_READY          BIT(31)\n \n#define EC_MKBP_FP_ERR_ENROLL_OK               0\n#define EC_MKBP_FP_ERR_ENROLL_LOW_QUALITY      1\n#define EC_MKBP_FP_ERR_ENROLL_IMMOBILE         2\n#define EC_MKBP_FP_ERR_ENROLL_LOW_COVERAGE     3\n#define EC_MKBP_FP_ERR_ENROLL_INTERNAL         5\n \n#define EC_MKBP_FP_ERR_ENROLL_PROBLEM_MASK     1\n \n#define EC_MKBP_FP_ERR_MATCH_NO                0\n#define EC_MKBP_FP_ERR_MATCH_NO_INTERNAL       6\n#define EC_MKBP_FP_ERR_MATCH_NO_TEMPLATES      7\n#define EC_MKBP_FP_ERR_MATCH_NO_LOW_QUALITY    2\n#define EC_MKBP_FP_ERR_MATCH_NO_LOW_COVERAGE   4\n#define EC_MKBP_FP_ERR_MATCH_YES               1\n#define EC_MKBP_FP_ERR_MATCH_YES_UPDATED       3\n#define EC_MKBP_FP_ERR_MATCH_YES_UPDATE_FAILED 5\n\n\n \n \n\n \n#define EC_CMD_TEMP_SENSOR_GET_INFO 0x0070\n\nstruct ec_params_temp_sensor_get_info {\n\tuint8_t id;\n} __ec_align1;\n\nstruct ec_response_temp_sensor_get_info {\n\tchar sensor_name[32];\n\tuint8_t sensor_type;\n} __ec_align1;\n\n \n\n \n\n \n \n\n\n \n \nstruct ec_params_host_event_mask {\n\tuint32_t mask;\n} __ec_align4;\n\nstruct ec_response_host_event_mask {\n\tuint32_t mask;\n} __ec_align4;\n\n \n#define EC_CMD_HOST_EVENT_GET_B         0x0087\n#define EC_CMD_HOST_EVENT_GET_SMI_MASK  0x0088\n#define EC_CMD_HOST_EVENT_GET_SCI_MASK  0x0089\n#define EC_CMD_HOST_EVENT_GET_WAKE_MASK 0x008D\n\n \n#define EC_CMD_HOST_EVENT_SET_SMI_MASK  0x008A\n#define EC_CMD_HOST_EVENT_SET_SCI_MASK  0x008B\n#define EC_CMD_HOST_EVENT_CLEAR         0x008C\n#define EC_CMD_HOST_EVENT_SET_WAKE_MASK 0x008E\n#define EC_CMD_HOST_EVENT_CLEAR_B       0x008F\n\n \n\nstruct ec_params_host_event {\n\n\t \n\tuint8_t action;\n\n\t \n\tuint8_t mask_type;\n\n\t \n\tuint16_t reserved;\n\n\t \n\tuint64_t value;\n} __ec_align4;\n\n \n\nstruct ec_response_host_event {\n\n\t \n\tuint64_t value;\n} __ec_align4;\n\nenum ec_host_event_action {\n\t \n\tEC_HOST_EVENT_GET,\n\n\t \n\tEC_HOST_EVENT_SET,\n\n\t \n\tEC_HOST_EVENT_CLEAR,\n};\n\nenum ec_host_event_mask_type {\n\n\t \n\tEC_HOST_EVENT_MAIN,\n\n\t \n\tEC_HOST_EVENT_B,\n\n\t \n\tEC_HOST_EVENT_SCI_MASK,\n\n\t \n\tEC_HOST_EVENT_SMI_MASK,\n\n\t \n\tEC_HOST_EVENT_ALWAYS_REPORT_MASK,\n\n\t \n\tEC_HOST_EVENT_ACTIVE_WAKE_MASK,\n\n\t \n\tEC_HOST_EVENT_LAZY_WAKE_MASK_S0IX,\n\n\t \n\tEC_HOST_EVENT_LAZY_WAKE_MASK_S3,\n\n\t \n\tEC_HOST_EVENT_LAZY_WAKE_MASK_S5,\n};\n\n#define EC_CMD_HOST_EVENT       0x00A4\n\n \n \n\n \n#define EC_CMD_SWITCH_ENABLE_BKLIGHT 0x0090\n\nstruct ec_params_switch_enable_backlight {\n\tuint8_t enabled;\n} __ec_align1;\n\n \n#define EC_CMD_SWITCH_ENABLE_WIRELESS 0x0091\n#define EC_VER_SWITCH_ENABLE_WIRELESS 1\n\n \nstruct ec_params_switch_enable_wireless_v0 {\n\tuint8_t enabled;\n} __ec_align1;\n\n \nstruct ec_params_switch_enable_wireless_v1 {\n\t \n\tuint8_t now_flags;\n\n\t \n\tuint8_t now_mask;\n\n\t \n\tuint8_t suspend_flags;\n\n\t \n\tuint8_t suspend_mask;\n} __ec_align1;\n\n \nstruct ec_response_switch_enable_wireless_v1 {\n\t \n\tuint8_t now_flags;\n\n\t \n\tuint8_t suspend_flags;\n} __ec_align1;\n\n \n \n\n \n#define EC_CMD_GPIO_SET 0x0092\n\nstruct ec_params_gpio_set {\n\tchar name[32];\n\tuint8_t val;\n} __ec_align1;\n\n \n#define EC_CMD_GPIO_GET 0x0093\n\n \nstruct ec_params_gpio_get {\n\tchar name[32];\n} __ec_align1;\n\nstruct ec_response_gpio_get {\n\tuint8_t val;\n} __ec_align1;\n\n \nstruct ec_params_gpio_get_v1 {\n\tuint8_t subcmd;\n\tunion {\n\t\tstruct __ec_align1 {\n\t\t\tchar name[32];\n\t\t} get_value_by_name;\n\t\tstruct __ec_align1 {\n\t\t\tuint8_t index;\n\t\t} get_info;\n\t};\n} __ec_align1;\n\nstruct ec_response_gpio_get_v1 {\n\tunion {\n\t\tstruct __ec_align1 {\n\t\t\tuint8_t val;\n\t\t} get_value_by_name, get_count;\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint8_t val;\n\t\t\tchar name[32];\n\t\t\tuint32_t flags;\n\t\t} get_info;\n\t};\n} __ec_todo_packed;\n\nenum gpio_get_subcmd {\n\tEC_GPIO_GET_BY_NAME = 0,\n\tEC_GPIO_GET_COUNT = 1,\n\tEC_GPIO_GET_INFO = 2,\n};\n\n \n \n\n \n\n \n#define EC_CMD_I2C_READ 0x0094\n\nstruct ec_params_i2c_read {\n\tuint16_t addr;  \n\tuint8_t read_size;  \n\tuint8_t port;\n\tuint8_t offset;\n} __ec_align_size1;\n\nstruct ec_response_i2c_read {\n\tuint16_t data;\n} __ec_align2;\n\n \n#define EC_CMD_I2C_WRITE 0x0095\n\nstruct ec_params_i2c_write {\n\tuint16_t data;\n\tuint16_t addr;  \n\tuint8_t write_size;  \n\tuint8_t port;\n\tuint8_t offset;\n} __ec_align_size1;\n\n \n \n\n \n#define EC_CMD_CHARGE_CONTROL 0x0096\n#define EC_VER_CHARGE_CONTROL 1\n\nenum ec_charge_control_mode {\n\tCHARGE_CONTROL_NORMAL = 0,\n\tCHARGE_CONTROL_IDLE,\n\tCHARGE_CONTROL_DISCHARGE,\n};\n\nstruct ec_params_charge_control {\n\tuint32_t mode;   \n} __ec_align4;\n\n \n\n \n#define EC_CMD_CONSOLE_SNAPSHOT 0x0097\n\n \n#define EC_CMD_CONSOLE_READ 0x0098\n\nenum ec_console_read_subcmd {\n\tCONSOLE_READ_NEXT = 0,\n\tCONSOLE_READ_RECENT\n};\n\nstruct ec_params_console_read_v1 {\n\tuint8_t subcmd;  \n} __ec_align1;\n\n \n\n \n#define EC_CMD_BATTERY_CUT_OFF 0x0099\n\n#define EC_BATTERY_CUTOFF_FLAG_AT_SHUTDOWN\tBIT(0)\n\nstruct ec_params_battery_cutoff {\n\tuint8_t flags;\n} __ec_align1;\n\n \n \n\n \n#define EC_CMD_USB_MUX 0x009A\n\nstruct ec_params_usb_mux {\n\tuint8_t mux;\n} __ec_align1;\n\n \n \n\nenum ec_ldo_state {\n\tEC_LDO_STATE_OFF = 0,\t \n\tEC_LDO_STATE_ON = 1,\t \n};\n\n \n#define EC_CMD_LDO_SET 0x009B\n\nstruct ec_params_ldo_set {\n\tuint8_t index;\n\tuint8_t state;\n} __ec_align1;\n\n \n#define EC_CMD_LDO_GET 0x009C\n\nstruct ec_params_ldo_get {\n\tuint8_t index;\n} __ec_align1;\n\nstruct ec_response_ldo_get {\n\tuint8_t state;\n} __ec_align1;\n\n \n \n\n \n#define EC_CMD_POWER_INFO 0x009D\n\nstruct ec_response_power_info {\n\tuint32_t usb_dev_type;\n\tuint16_t voltage_ac;\n\tuint16_t voltage_system;\n\tuint16_t current_system;\n\tuint16_t usb_current_limit;\n} __ec_align4;\n\n \n \n\n#define EC_CMD_I2C_PASSTHRU 0x009E\n\n \n#define EC_I2C_FLAG_READ\tBIT(15)\n\n \n#define EC_I2C_ADDR_MASK\t0x3ff\n\n#define EC_I2C_STATUS_NAK\tBIT(0)  \n#define EC_I2C_STATUS_TIMEOUT\tBIT(1)  \n\n \n#define EC_I2C_STATUS_ERROR\t(EC_I2C_STATUS_NAK | EC_I2C_STATUS_TIMEOUT)\n\nstruct ec_params_i2c_passthru_msg {\n\tuint16_t addr_flags;\t \n\tuint16_t len;\t\t \n} __ec_align2;\n\nstruct ec_params_i2c_passthru {\n\tuint8_t port;\t\t \n\tuint8_t num_msgs;\t \n\tstruct ec_params_i2c_passthru_msg msg[];\n\t \n} __ec_align2;\n\nstruct ec_response_i2c_passthru {\n\tuint8_t i2c_status;\t \n\tuint8_t num_msgs;\t \n\tuint8_t data[];\t\t \n} __ec_align1;\n\n \n \n\n#define EC_CMD_HANG_DETECT 0x009F\n\n \n \n#define EC_HANG_START_ON_POWER_PRESS  BIT(0)\n\n \n#define EC_HANG_START_ON_LID_CLOSE    BIT(1)\n\n  \n#define EC_HANG_START_ON_LID_OPEN     BIT(2)\n\n \n#define EC_HANG_START_ON_RESUME       BIT(3)\n\n \n\n \n#define EC_HANG_STOP_ON_POWER_RELEASE BIT(8)\n\n \n#define EC_HANG_STOP_ON_HOST_COMMAND  BIT(9)\n\n \n#define EC_HANG_STOP_ON_SUSPEND       BIT(10)\n\n \n#define EC_HANG_START_NOW             BIT(30)\n\n \n#define EC_HANG_STOP_NOW              BIT(31)\n\nstruct ec_params_hang_detect {\n\t \n\tuint32_t flags;\n\n\t \n\tuint16_t host_event_timeout_msec;\n\n\t \n\tuint16_t warm_reboot_timeout_msec;\n} __ec_align4;\n\n \n \n\n \n#define EC_CMD_CHARGE_STATE 0x00A0\n\n \nenum charge_state_command {\n\tCHARGE_STATE_CMD_GET_STATE,\n\tCHARGE_STATE_CMD_GET_PARAM,\n\tCHARGE_STATE_CMD_SET_PARAM,\n\tCHARGE_STATE_NUM_CMDS\n};\n\n \nenum charge_state_params {\n\tCS_PARAM_CHG_VOLTAGE,\t       \n\tCS_PARAM_CHG_CURRENT,\t       \n\tCS_PARAM_CHG_INPUT_CURRENT,    \n\tCS_PARAM_CHG_STATUS,\t       \n\tCS_PARAM_CHG_OPTION,\t       \n\tCS_PARAM_LIMIT_POWER,\t       \n\t \n\tCS_NUM_BASE_PARAMS,\n\n\t \n\tCS_PARAM_CUSTOM_PROFILE_MIN = 0x10000,\n\tCS_PARAM_CUSTOM_PROFILE_MAX = 0x1ffff,\n\n\t \n\tCS_PARAM_DEBUG_MIN = 0x20000,\n\tCS_PARAM_DEBUG_CTL_MODE = 0x20000,\n\tCS_PARAM_DEBUG_MANUAL_MODE,\n\tCS_PARAM_DEBUG_SEEMS_DEAD,\n\tCS_PARAM_DEBUG_SEEMS_DISCONNECTED,\n\tCS_PARAM_DEBUG_BATT_REMOVED,\n\tCS_PARAM_DEBUG_MANUAL_CURRENT,\n\tCS_PARAM_DEBUG_MANUAL_VOLTAGE,\n\tCS_PARAM_DEBUG_MAX = 0x2ffff,\n\n\t \n};\n\nstruct ec_params_charge_state {\n\tuint8_t cmd;\t\t\t\t \n\tunion {\n\t\t \n\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint32_t param;\t\t \n\t\t} get_param;\n\n\t\tstruct __ec_todo_unpacked {\n\t\t\tuint32_t param;\t\t \n\t\t\tuint32_t value;\t\t \n\t\t} set_param;\n\t};\n} __ec_todo_packed;\n\nstruct ec_response_charge_state {\n\tunion {\n\t\tstruct __ec_align4 {\n\t\t\tint ac;\n\t\t\tint chg_voltage;\n\t\t\tint chg_current;\n\t\t\tint chg_input_current;\n\t\t\tint batt_state_of_charge;\n\t\t} get_state;\n\n\t\tstruct __ec_align4 {\n\t\t\tuint32_t value;\n\t\t} get_param;\n\n\t\t \n\t};\n} __ec_align4;\n\n\n \n#define EC_CMD_CHARGE_CURRENT_LIMIT 0x00A1\n\nstruct ec_params_current_limit {\n\tuint32_t limit;  \n} __ec_align4;\n\n \n#define EC_CMD_EXTERNAL_POWER_LIMIT 0x00A2\n\n \nstruct ec_params_external_power_limit_v1 {\n\tuint16_t current_lim;  \n\tuint16_t voltage_lim;  \n} __ec_align2;\n\n#define EC_POWER_LIMIT_NONE 0xffff\n\n \n#define EC_CMD_OVERRIDE_DEDICATED_CHARGER_LIMIT 0x00A3\n\nstruct ec_params_dedicated_charger_limit {\n\tuint16_t current_lim;  \n\tuint16_t voltage_lim;  \n} __ec_align2;\n\n \n \n\n \n#define EC_CMD_HIBERNATION_DELAY 0x00A8\n\nstruct ec_params_hibernation_delay {\n\t \n\tuint32_t seconds;\n} __ec_align4;\n\nstruct ec_response_hibernation_delay {\n\t \n\tuint32_t time_g3;\n\n\t \n\tuint32_t time_remaining;\n\n\t \n\tuint32_t hibernate_delay;\n} __ec_align4;\n\n \n#define EC_CMD_HOST_SLEEP_EVENT 0x00A9\n\nenum host_sleep_event {\n\tHOST_SLEEP_EVENT_S3_SUSPEND   = 1,\n\tHOST_SLEEP_EVENT_S3_RESUME    = 2,\n\tHOST_SLEEP_EVENT_S0IX_SUSPEND = 3,\n\tHOST_SLEEP_EVENT_S0IX_RESUME  = 4,\n\t \n\tHOST_SLEEP_EVENT_S3_WAKEABLE_SUSPEND = 5,\n};\n\nstruct ec_params_host_sleep_event {\n\tuint8_t sleep_event;\n} __ec_align1;\n\n \n#define EC_HOST_SLEEP_TIMEOUT_DEFAULT 0\n\n \n#define EC_HOST_SLEEP_TIMEOUT_INFINITE 0xFFFF\n\nstruct ec_params_host_sleep_event_v1 {\n\t \n\tuint8_t sleep_event;\n\n\t \n\tuint8_t reserved;\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tuint16_t sleep_timeout_ms;\n\t\t} suspend_params;\n\n\t\t \n\t};\n} __ec_align2;\n\n \n#define EC_HOST_RESUME_SLEEP_TIMEOUT 0x80000000\n\n \n#define EC_HOST_RESUME_SLEEP_TRANSITIONS_MASK 0x7FFFFFFF\n\nstruct ec_response_host_sleep_event_v1 {\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tuint32_t sleep_transitions;\n\t\t} resume_response;\n\n\t\t \n\t};\n} __ec_align4;\n\n \n \n#define EC_CMD_DEVICE_EVENT 0x00AA\n\nenum ec_device_event {\n\tEC_DEVICE_EVENT_TRACKPAD,\n\tEC_DEVICE_EVENT_DSP,\n\tEC_DEVICE_EVENT_WIFI,\n\tEC_DEVICE_EVENT_WLC,\n};\n\nenum ec_device_event_param {\n\t \n\tEC_DEVICE_EVENT_PARAM_GET_CURRENT_EVENTS,\n\t \n\tEC_DEVICE_EVENT_PARAM_GET_ENABLED_EVENTS,\n\t \n\tEC_DEVICE_EVENT_PARAM_SET_ENABLED_EVENTS,\n};\n\n#define EC_DEVICE_EVENT_MASK(event_code) BIT(event_code % 32)\n\nstruct ec_params_device_event {\n\tuint32_t event_mask;\n\tuint8_t param;\n} __ec_align_size1;\n\nstruct ec_response_device_event {\n\tuint32_t event_mask;\n} __ec_align4;\n\n \n \n\n \n#define EC_CMD_SB_READ_WORD   0x00B0\n#define EC_CMD_SB_WRITE_WORD  0x00B1\n\n \n#define EC_CMD_SB_READ_BLOCK  0x00B2\n#define EC_CMD_SB_WRITE_BLOCK 0x00B3\n\nstruct ec_params_sb_rd {\n\tuint8_t reg;\n} __ec_align1;\n\nstruct ec_response_sb_rd_word {\n\tuint16_t value;\n} __ec_align2;\n\nstruct ec_params_sb_wr_word {\n\tuint8_t reg;\n\tuint16_t value;\n} __ec_align1;\n\nstruct ec_response_sb_rd_block {\n\tuint8_t data[32];\n} __ec_align1;\n\nstruct ec_params_sb_wr_block {\n\tuint8_t reg;\n\tuint16_t data[32];\n} __ec_align1;\n\n \n \n\n#define EC_CMD_BATTERY_VENDOR_PARAM 0x00B4\n\nenum ec_battery_vendor_param_mode {\n\tBATTERY_VENDOR_PARAM_MODE_GET = 0,\n\tBATTERY_VENDOR_PARAM_MODE_SET,\n};\n\nstruct ec_params_battery_vendor_param {\n\tuint32_t param;\n\tuint32_t value;\n\tuint8_t mode;\n} __ec_align_size1;\n\nstruct ec_response_battery_vendor_param {\n\tuint32_t value;\n} __ec_align4;\n\n \n \n#define EC_CMD_SB_FW_UPDATE 0x00B5\n\nenum ec_sb_fw_update_subcmd {\n\tEC_SB_FW_UPDATE_PREPARE  = 0x0,\n\tEC_SB_FW_UPDATE_INFO     = 0x1,  \n\tEC_SB_FW_UPDATE_BEGIN    = 0x2,  \n\tEC_SB_FW_UPDATE_WRITE    = 0x3,  \n\tEC_SB_FW_UPDATE_END      = 0x4,\n\tEC_SB_FW_UPDATE_STATUS   = 0x5,\n\tEC_SB_FW_UPDATE_PROTECT  = 0x6,\n\tEC_SB_FW_UPDATE_MAX      = 0x7,\n};\n\n#define SB_FW_UPDATE_CMD_WRITE_BLOCK_SIZE 32\n#define SB_FW_UPDATE_CMD_STATUS_SIZE 2\n#define SB_FW_UPDATE_CMD_INFO_SIZE 8\n\nstruct ec_sb_fw_update_header {\n\tuint16_t subcmd;   \n\tuint16_t fw_id;    \n} __ec_align4;\n\nstruct ec_params_sb_fw_update {\n\tstruct ec_sb_fw_update_header hdr;\n\tunion {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\tstruct __ec_align4 {\n\t\t\tuint8_t  data[SB_FW_UPDATE_CMD_WRITE_BLOCK_SIZE];\n\t\t} write;\n\t};\n} __ec_align4;\n\nstruct ec_response_sb_fw_update {\n\tunion {\n\t\t \n\t\tstruct __ec_align1 {\n\t\t\tuint8_t data[SB_FW_UPDATE_CMD_INFO_SIZE];\n\t\t} info;\n\n\t\t \n\t\tstruct __ec_align1 {\n\t\t\tuint8_t data[SB_FW_UPDATE_CMD_STATUS_SIZE];\n\t\t} status;\n\t};\n} __ec_align1;\n\n \n#define EC_CMD_ENTERING_MODE 0x00B6\n\nstruct ec_params_entering_mode {\n\tint vboot_mode;\n} __ec_align4;\n\n#define VBOOT_MODE_NORMAL    0\n#define VBOOT_MODE_DEVELOPER 1\n#define VBOOT_MODE_RECOVERY  2\n\n \n \n#define EC_CMD_I2C_PASSTHRU_PROTECT 0x00B7\n\nenum ec_i2c_passthru_protect_subcmd {\n\tEC_CMD_I2C_PASSTHRU_PROTECT_STATUS = 0x0,\n\tEC_CMD_I2C_PASSTHRU_PROTECT_ENABLE = 0x1,\n};\n\nstruct ec_params_i2c_passthru_protect {\n\tuint8_t subcmd;\n\tuint8_t port;\t\t \n} __ec_align1;\n\nstruct ec_response_i2c_passthru_protect {\n\tuint8_t status;\t\t \n} __ec_align1;\n\n\n \n \n\n#define MAX_CEC_MSG_LEN 16\n\n \n#define EC_CMD_CEC_WRITE_MSG 0x00B8\n\n \nstruct ec_params_cec_write {\n\tuint8_t msg[MAX_CEC_MSG_LEN];\n} __ec_align1;\n\n \n#define EC_CMD_CEC_SET 0x00BA\n\n \nstruct ec_params_cec_set {\n\tuint8_t cmd;  \n\tuint8_t val;\n} __ec_align1;\n\n \n#define EC_CMD_CEC_GET 0x00BB\n\n \nstruct ec_params_cec_get {\n\tuint8_t cmd;  \n} __ec_align1;\n\n \nstruct ec_response_cec_get {\n\tuint8_t val;\n} __ec_align1;\n\n \nenum cec_command {\n\t \n\tCEC_CMD_ENABLE,\n\t \n\tCEC_CMD_LOGICAL_ADDRESS,\n};\n\n \nenum mkbp_cec_event {\n\t \n\tEC_MKBP_CEC_SEND_OK\t\t\t= BIT(0),\n\t \n\tEC_MKBP_CEC_SEND_FAILED\t\t\t= BIT(1),\n};\n\n \n\n \n#define EC_CMD_EC_CODEC 0x00BC\n\nenum ec_codec_subcmd {\n\tEC_CODEC_GET_CAPABILITIES = 0x0,\n\tEC_CODEC_GET_SHM_ADDR = 0x1,\n\tEC_CODEC_SET_SHM_ADDR = 0x2,\n\tEC_CODEC_SUBCMD_COUNT,\n};\n\nenum ec_codec_cap {\n\tEC_CODEC_CAP_WOV_AUDIO_SHM = 0,\n\tEC_CODEC_CAP_WOV_LANG_SHM = 1,\n\tEC_CODEC_CAP_LAST = 32,\n};\n\nenum ec_codec_shm_id {\n\tEC_CODEC_SHM_ID_WOV_AUDIO = 0x0,\n\tEC_CODEC_SHM_ID_WOV_LANG = 0x1,\n\tEC_CODEC_SHM_ID_LAST,\n};\n\nenum ec_codec_shm_type {\n\tEC_CODEC_SHM_TYPE_EC_RAM = 0x0,\n\tEC_CODEC_SHM_TYPE_SYSTEM_RAM = 0x1,\n};\n\nstruct __ec_align1 ec_param_ec_codec_get_shm_addr {\n\tuint8_t shm_id;\n\tuint8_t reserved[3];\n};\n\nstruct __ec_align4 ec_param_ec_codec_set_shm_addr {\n\tuint64_t phys_addr;\n\tuint32_t len;\n\tuint8_t shm_id;\n\tuint8_t reserved[3];\n};\n\nstruct __ec_align4 ec_param_ec_codec {\n\tuint8_t cmd;  \n\tuint8_t reserved[3];\n\n\tunion {\n\t\tstruct ec_param_ec_codec_get_shm_addr\n\t\t\t\tget_shm_addr_param;\n\t\tstruct ec_param_ec_codec_set_shm_addr\n\t\t\t\tset_shm_addr_param;\n\t};\n};\n\nstruct __ec_align4 ec_response_ec_codec_get_capabilities {\n\tuint32_t capabilities;\n};\n\nstruct __ec_align4 ec_response_ec_codec_get_shm_addr {\n\tuint64_t phys_addr;\n\tuint32_t len;\n\tuint8_t type;\n\tuint8_t reserved[3];\n};\n\n \n\n \n#define EC_CMD_EC_CODEC_DMIC 0x00BD\n\nenum ec_codec_dmic_subcmd {\n\tEC_CODEC_DMIC_GET_MAX_GAIN = 0x0,\n\tEC_CODEC_DMIC_SET_GAIN_IDX = 0x1,\n\tEC_CODEC_DMIC_GET_GAIN_IDX = 0x2,\n\tEC_CODEC_DMIC_SUBCMD_COUNT,\n};\n\nenum ec_codec_dmic_channel {\n\tEC_CODEC_DMIC_CHANNEL_0 = 0x0,\n\tEC_CODEC_DMIC_CHANNEL_1 = 0x1,\n\tEC_CODEC_DMIC_CHANNEL_2 = 0x2,\n\tEC_CODEC_DMIC_CHANNEL_3 = 0x3,\n\tEC_CODEC_DMIC_CHANNEL_4 = 0x4,\n\tEC_CODEC_DMIC_CHANNEL_5 = 0x5,\n\tEC_CODEC_DMIC_CHANNEL_6 = 0x6,\n\tEC_CODEC_DMIC_CHANNEL_7 = 0x7,\n\tEC_CODEC_DMIC_CHANNEL_COUNT,\n};\n\nstruct __ec_align1 ec_param_ec_codec_dmic_set_gain_idx {\n\tuint8_t channel;  \n\tuint8_t gain;\n\tuint8_t reserved[2];\n};\n\nstruct __ec_align1 ec_param_ec_codec_dmic_get_gain_idx {\n\tuint8_t channel;  \n\tuint8_t reserved[3];\n};\n\nstruct __ec_align4 ec_param_ec_codec_dmic {\n\tuint8_t cmd;  \n\tuint8_t reserved[3];\n\n\tunion {\n\t\tstruct ec_param_ec_codec_dmic_set_gain_idx\n\t\t\t\tset_gain_idx_param;\n\t\tstruct ec_param_ec_codec_dmic_get_gain_idx\n\t\t\t\tget_gain_idx_param;\n\t};\n};\n\nstruct __ec_align1 ec_response_ec_codec_dmic_get_max_gain {\n\tuint8_t max_gain;\n};\n\nstruct __ec_align1 ec_response_ec_codec_dmic_get_gain_idx {\n\tuint8_t gain;\n};\n\n \n\n \n\n#define EC_CMD_EC_CODEC_I2S_RX 0x00BE\n\nenum ec_codec_i2s_rx_subcmd {\n\tEC_CODEC_I2S_RX_ENABLE = 0x0,\n\tEC_CODEC_I2S_RX_DISABLE = 0x1,\n\tEC_CODEC_I2S_RX_SET_SAMPLE_DEPTH = 0x2,\n\tEC_CODEC_I2S_RX_SET_DAIFMT = 0x3,\n\tEC_CODEC_I2S_RX_SET_BCLK = 0x4,\n\tEC_CODEC_I2S_RX_RESET = 0x5,\n\tEC_CODEC_I2S_RX_SUBCMD_COUNT,\n};\n\nenum ec_codec_i2s_rx_sample_depth {\n\tEC_CODEC_I2S_RX_SAMPLE_DEPTH_16 = 0x0,\n\tEC_CODEC_I2S_RX_SAMPLE_DEPTH_24 = 0x1,\n\tEC_CODEC_I2S_RX_SAMPLE_DEPTH_COUNT,\n};\n\nenum ec_codec_i2s_rx_daifmt {\n\tEC_CODEC_I2S_RX_DAIFMT_I2S = 0x0,\n\tEC_CODEC_I2S_RX_DAIFMT_RIGHT_J = 0x1,\n\tEC_CODEC_I2S_RX_DAIFMT_LEFT_J = 0x2,\n\tEC_CODEC_I2S_RX_DAIFMT_COUNT,\n};\n\nstruct __ec_align1 ec_param_ec_codec_i2s_rx_set_sample_depth {\n\tuint8_t depth;\n\tuint8_t reserved[3];\n};\n\nstruct __ec_align1 ec_param_ec_codec_i2s_rx_set_gain {\n\tuint8_t left;\n\tuint8_t right;\n\tuint8_t reserved[2];\n};\n\nstruct __ec_align1 ec_param_ec_codec_i2s_rx_set_daifmt {\n\tuint8_t daifmt;\n\tuint8_t reserved[3];\n};\n\nstruct __ec_align4 ec_param_ec_codec_i2s_rx_set_bclk {\n\tuint32_t bclk;\n};\n\nstruct __ec_align4 ec_param_ec_codec_i2s_rx {\n\tuint8_t cmd;  \n\tuint8_t reserved[3];\n\n\tunion {\n\t\tstruct ec_param_ec_codec_i2s_rx_set_sample_depth\n\t\t\t\tset_sample_depth_param;\n\t\tstruct ec_param_ec_codec_i2s_rx_set_daifmt\n\t\t\t\tset_daifmt_param;\n\t\tstruct ec_param_ec_codec_i2s_rx_set_bclk\n\t\t\t\tset_bclk_param;\n\t};\n};\n\n \n \n\n#define EC_CMD_EC_CODEC_WOV 0x00BF\n\nenum ec_codec_wov_subcmd {\n\tEC_CODEC_WOV_SET_LANG = 0x0,\n\tEC_CODEC_WOV_SET_LANG_SHM = 0x1,\n\tEC_CODEC_WOV_GET_LANG = 0x2,\n\tEC_CODEC_WOV_ENABLE = 0x3,\n\tEC_CODEC_WOV_DISABLE = 0x4,\n\tEC_CODEC_WOV_READ_AUDIO = 0x5,\n\tEC_CODEC_WOV_READ_AUDIO_SHM = 0x6,\n\tEC_CODEC_WOV_SUBCMD_COUNT,\n};\n\n \nstruct __ec_align4 ec_param_ec_codec_wov_set_lang {\n\tuint8_t hash[32];\n\tuint32_t total_len;\n\tuint32_t offset;\n\tuint8_t buf[128];\n\tuint32_t len;\n};\n\nstruct __ec_align4 ec_param_ec_codec_wov_set_lang_shm {\n\tuint8_t hash[32];\n\tuint32_t total_len;\n};\n\nstruct __ec_align4 ec_param_ec_codec_wov {\n\tuint8_t cmd;  \n\tuint8_t reserved[3];\n\n\tunion {\n\t\tstruct ec_param_ec_codec_wov_set_lang\n\t\t\t\tset_lang_param;\n\t\tstruct ec_param_ec_codec_wov_set_lang_shm\n\t\t\t\tset_lang_shm_param;\n\t};\n};\n\nstruct __ec_align4 ec_response_ec_codec_wov_get_lang {\n\tuint8_t hash[32];\n};\n\nstruct __ec_align4 ec_response_ec_codec_wov_read_audio {\n\tuint8_t buf[128];\n\tuint32_t len;\n};\n\nstruct __ec_align4 ec_response_ec_codec_wov_read_audio_shm {\n\tuint32_t offset;\n\tuint32_t len;\n};\n\n \n \n\n \n#define EC_CMD_REBOOT_EC 0x00D2\n\n \nenum ec_reboot_cmd {\n\tEC_REBOOT_CANCEL = 0,         \n\tEC_REBOOT_JUMP_RO = 1,        \n\tEC_REBOOT_JUMP_RW = 2,        \n\t \n\tEC_REBOOT_COLD = 4,           \n\tEC_REBOOT_DISABLE_JUMP = 5,   \n\tEC_REBOOT_HIBERNATE = 6,      \n\tEC_REBOOT_HIBERNATE_CLEAR_AP_OFF = 7,  \n\tEC_REBOOT_COLD_AP_OFF = 8,    \n};\n\n \n#define EC_REBOOT_FLAG_RESERVED0      BIT(0)   \n#define EC_REBOOT_FLAG_ON_AP_SHUTDOWN BIT(1)   \n#define EC_REBOOT_FLAG_SWITCH_RW_SLOT BIT(2)   \n\nstruct ec_params_reboot_ec {\n\tuint8_t cmd;            \n\tuint8_t flags;          \n} __ec_align1;\n\n \n#define EC_CMD_GET_PANIC_INFO 0x00D3\n\n \n \n\n \n#define EC_CMD_REBOOT 0x00D1   \n\n \n#define EC_CMD_RESEND_RESPONSE 0x00DB\n\n \n#define EC_CMD_VERSION0 0x00DC\n\n \n \n\n \n#define EC_CMD_PD_EXCHANGE_STATUS 0x0100\n#define EC_VER_PD_EXCHANGE_STATUS 2\n\nenum pd_charge_state {\n\tPD_CHARGE_NO_CHANGE = 0,  \n\tPD_CHARGE_NONE,           \n\tPD_CHARGE_5V,             \n\tPD_CHARGE_MAX             \n};\n\n \n#define EC_STATUS_HIBERNATING\tBIT(0)\n\nstruct ec_params_pd_status {\n\tuint8_t status;        \n\tint8_t batt_soc;       \n\tuint8_t charge_state;  \n} __ec_align1;\n\n \n#define PD_STATUS_HOST_EVENT      BIT(0)  \n#define PD_STATUS_IN_RW           BIT(1)  \n#define PD_STATUS_JUMPED_TO_IMAGE BIT(2)  \n#define PD_STATUS_TCPC_ALERT_0    BIT(3)  \n#define PD_STATUS_TCPC_ALERT_1    BIT(4)  \n#define PD_STATUS_TCPC_ALERT_2    BIT(5)  \n#define PD_STATUS_TCPC_ALERT_3    BIT(6)  \n#define PD_STATUS_EC_INT_ACTIVE  (PD_STATUS_TCPC_ALERT_0 | \\\n\t\t\t\t      PD_STATUS_TCPC_ALERT_1 | \\\n\t\t\t\t      PD_STATUS_HOST_EVENT)\nstruct ec_response_pd_status {\n\tuint32_t curr_lim_ma;        \n\tuint16_t status;             \n\tint8_t active_charge_port;   \n} __ec_align_size1;\n\n \n#define EC_CMD_PD_HOST_EVENT_STATUS 0x0104\n\n \n#define PD_EVENT_UPDATE_DEVICE     BIT(0)\n#define PD_EVENT_POWER_CHANGE      BIT(1)\n#define PD_EVENT_IDENTITY_RECEIVED BIT(2)\n#define PD_EVENT_DATA_SWAP         BIT(3)\nstruct ec_response_host_event_status {\n\tuint32_t status;       \n} __ec_align4;\n\n \n#define EC_CMD_USB_PD_CONTROL 0x0101\n\nenum usb_pd_control_role {\n\tUSB_PD_CTRL_ROLE_NO_CHANGE = 0,\n\tUSB_PD_CTRL_ROLE_TOGGLE_ON = 1,  \n\tUSB_PD_CTRL_ROLE_TOGGLE_OFF = 2,\n\tUSB_PD_CTRL_ROLE_FORCE_SINK = 3,\n\tUSB_PD_CTRL_ROLE_FORCE_SOURCE = 4,\n\tUSB_PD_CTRL_ROLE_FREEZE = 5,\n\tUSB_PD_CTRL_ROLE_COUNT\n};\n\nenum usb_pd_control_mux {\n\tUSB_PD_CTRL_MUX_NO_CHANGE = 0,\n\tUSB_PD_CTRL_MUX_NONE = 1,\n\tUSB_PD_CTRL_MUX_USB = 2,\n\tUSB_PD_CTRL_MUX_DP = 3,\n\tUSB_PD_CTRL_MUX_DOCK = 4,\n\tUSB_PD_CTRL_MUX_AUTO = 5,\n\tUSB_PD_CTRL_MUX_COUNT\n};\n\nenum usb_pd_control_swap {\n\tUSB_PD_CTRL_SWAP_NONE = 0,\n\tUSB_PD_CTRL_SWAP_DATA = 1,\n\tUSB_PD_CTRL_SWAP_POWER = 2,\n\tUSB_PD_CTRL_SWAP_VCONN = 3,\n\tUSB_PD_CTRL_SWAP_COUNT\n};\n\nstruct ec_params_usb_pd_control {\n\tuint8_t port;\n\tuint8_t role;\n\tuint8_t mux;\n\tuint8_t swap;\n} __ec_align1;\n\n#define PD_CTRL_RESP_ENABLED_COMMS      BIT(0)  \n#define PD_CTRL_RESP_ENABLED_CONNECTED  BIT(1)  \n#define PD_CTRL_RESP_ENABLED_PD_CAPABLE BIT(2)  \n\n#define PD_CTRL_RESP_ROLE_POWER         BIT(0)  \n#define PD_CTRL_RESP_ROLE_DATA          BIT(1)  \n#define PD_CTRL_RESP_ROLE_VCONN         BIT(2)  \n#define PD_CTRL_RESP_ROLE_DR_POWER      BIT(3)  \n#define PD_CTRL_RESP_ROLE_DR_DATA       BIT(4)  \n#define PD_CTRL_RESP_ROLE_USB_COMM      BIT(5)  \n#define PD_CTRL_RESP_ROLE_EXT_POWERED   BIT(6)  \n\nstruct ec_response_usb_pd_control {\n\tuint8_t enabled;\n\tuint8_t role;\n\tuint8_t polarity;\n\tuint8_t state;\n} __ec_align1;\n\nstruct ec_response_usb_pd_control_v1 {\n\tuint8_t enabled;\n\tuint8_t role;\n\tuint8_t polarity;\n\tchar state[32];\n} __ec_align1;\n\n \n#define USBC_PD_CC_NONE\t\t0  \n#define USBC_PD_CC_NO_UFP\t1  \n#define USBC_PD_CC_AUDIO_ACC\t2  \n#define USBC_PD_CC_DEBUG_ACC\t3  \n#define USBC_PD_CC_UFP_ATTACHED\t4  \n#define USBC_PD_CC_DFP_ATTACHED\t5  \n\n \n#define USB_PD_CTRL_ACTIVE_CABLE        BIT(0)\n \n#define USB_PD_CTRL_OPTICAL_CABLE       BIT(1)\n \n#define USB_PD_CTRL_TBT_LEGACY_ADAPTER  BIT(2)\n \n#define USB_PD_CTRL_ACTIVE_LINK_UNIDIR  BIT(3)\n\nstruct ec_response_usb_pd_control_v2 {\n\tuint8_t enabled;\n\tuint8_t role;\n\tuint8_t polarity;\n\tchar state[32];\n\tuint8_t cc_state;\t \n\tuint8_t dp_mode;\t \n\tuint8_t reserved;\t \n\tuint8_t control_flags;\t \n\tuint8_t cable_speed;\t \n\tuint8_t cable_gen;\t \n} __ec_align1;\n\n#define EC_CMD_USB_PD_PORTS 0x0102\n\n \n#define EC_USB_PD_MAX_PORTS 8\n\nstruct ec_response_usb_pd_ports {\n\tuint8_t num_ports;\n} __ec_align1;\n\n#define EC_CMD_USB_PD_POWER_INFO 0x0103\n\n#define PD_POWER_CHARGING_PORT 0xff\nstruct ec_params_usb_pd_power_info {\n\tuint8_t port;\n} __ec_align1;\n\nenum usb_chg_type {\n\tUSB_CHG_TYPE_NONE,\n\tUSB_CHG_TYPE_PD,\n\tUSB_CHG_TYPE_C,\n\tUSB_CHG_TYPE_PROPRIETARY,\n\tUSB_CHG_TYPE_BC12_DCP,\n\tUSB_CHG_TYPE_BC12_CDP,\n\tUSB_CHG_TYPE_BC12_SDP,\n\tUSB_CHG_TYPE_OTHER,\n\tUSB_CHG_TYPE_VBUS,\n\tUSB_CHG_TYPE_UNKNOWN,\n\tUSB_CHG_TYPE_DEDICATED,\n};\nenum usb_power_roles {\n\tUSB_PD_PORT_POWER_DISCONNECTED,\n\tUSB_PD_PORT_POWER_SOURCE,\n\tUSB_PD_PORT_POWER_SINK,\n\tUSB_PD_PORT_POWER_SINK_NOT_CHARGING,\n};\n\nstruct usb_chg_measures {\n\tuint16_t voltage_max;\n\tuint16_t voltage_now;\n\tuint16_t current_max;\n\tuint16_t current_lim;\n} __ec_align2;\n\nstruct ec_response_usb_pd_power_info {\n\tuint8_t role;\n\tuint8_t type;\n\tuint8_t dualrole;\n\tuint8_t reserved1;\n\tstruct usb_chg_measures meas;\n\tuint32_t max_power;\n} __ec_align4;\n\n\n \n#define EC_CMD_CHARGE_PORT_COUNT 0x0105\nstruct ec_response_charge_port_count {\n\tuint8_t port_count;\n} __ec_align1;\n\n \n#define EC_CMD_USB_PD_FW_UPDATE 0x0110\n\nenum usb_pd_fw_update_cmds {\n\tUSB_PD_FW_REBOOT,\n\tUSB_PD_FW_FLASH_ERASE,\n\tUSB_PD_FW_FLASH_WRITE,\n\tUSB_PD_FW_ERASE_SIG,\n};\n\nstruct ec_params_usb_pd_fw_update {\n\tuint16_t dev_id;\n\tuint8_t cmd;\n\tuint8_t port;\n\tuint32_t size;      \n\t \n} __ec_align4;\n\n \n#define EC_CMD_USB_PD_RW_HASH_ENTRY 0x0111\n \n#define PD_RW_HASH_SIZE 20\nstruct ec_params_usb_pd_rw_hash_entry {\n\tuint16_t dev_id;\n\tuint8_t dev_rw_hash[PD_RW_HASH_SIZE];\n\tuint8_t reserved;         \n\tuint32_t current_image;   \n} __ec_align1;\n\n \n#define EC_CMD_USB_PD_DEV_INFO 0x0112\n\nstruct ec_params_usb_pd_info_request {\n\tuint8_t port;\n} __ec_align1;\n\n \n#define EC_CMD_USB_PD_DISCOVERY 0x0113\nstruct ec_params_usb_pd_discovery_entry {\n\tuint16_t vid;   \n\tuint16_t pid;   \n\tuint8_t ptype;  \n} __ec_align_size1;\n\n \n#define EC_CMD_PD_CHARGE_PORT_OVERRIDE 0x0114\n\n \nenum usb_pd_override_ports {\n\tOVERRIDE_DONT_CHARGE = -2,\n\tOVERRIDE_OFF = -1,\n\t \n};\n\nstruct ec_params_charge_port_override {\n\tint16_t override_port;  \n} __ec_align2;\n\n \n#define EC_CMD_PD_GET_LOG_ENTRY 0x0115\n\nstruct ec_response_pd_log {\n\tuint32_t timestamp;  \n\tuint8_t type;        \n\tuint8_t size_port;   \n\tuint16_t data;       \n\tuint8_t payload[];   \n} __ec_align4;\n\n \n#define PD_LOG_TIMESTAMP_SHIFT 10  \n\n#define PD_LOG_SIZE_MASK  0x1f\n#define PD_LOG_PORT_MASK  0xe0\n#define PD_LOG_PORT_SHIFT    5\n#define PD_LOG_PORT_SIZE(port, size) (((port) << PD_LOG_PORT_SHIFT) | \\\n\t\t\t\t      ((size) & PD_LOG_SIZE_MASK))\n#define PD_LOG_PORT(size_port) ((size_port) >> PD_LOG_PORT_SHIFT)\n#define PD_LOG_SIZE(size_port) ((size_port) & PD_LOG_SIZE_MASK)\n\n \n \n#define PD_EVENT_MCU_BASE       0x00\n#define PD_EVENT_MCU_CHARGE             (PD_EVENT_MCU_BASE+0)\n#define PD_EVENT_MCU_CONNECT            (PD_EVENT_MCU_BASE+1)\n \n#define PD_EVENT_MCU_BOARD_CUSTOM       (PD_EVENT_MCU_BASE+2)\n \n#define PD_EVENT_ACC_BASE       0x20\n#define PD_EVENT_ACC_RW_FAIL   (PD_EVENT_ACC_BASE+0)\n#define PD_EVENT_ACC_RW_ERASE  (PD_EVENT_ACC_BASE+1)\n \n#define PD_EVENT_PS_BASE        0x40\n#define PD_EVENT_PS_FAULT      (PD_EVENT_PS_BASE+0)\n \n#define PD_EVENT_VIDEO_BASE     0x60\n#define PD_EVENT_VIDEO_DP_MODE (PD_EVENT_VIDEO_BASE+0)\n#define PD_EVENT_VIDEO_CODEC   (PD_EVENT_VIDEO_BASE+1)\n \n#define PD_EVENT_NO_ENTRY       0xff\n\n \n \n#define CHARGE_FLAGS_DUAL_ROLE         BIT(15)\n \n#define CHARGE_FLAGS_DELAYED_OVERRIDE  BIT(14)\n \n#define CHARGE_FLAGS_OVERRIDE          BIT(13)\n \n#define CHARGE_FLAGS_TYPE_SHIFT               3\n#define CHARGE_FLAGS_TYPE_MASK       (0xf << CHARGE_FLAGS_TYPE_SHIFT)\n \n#define CHARGE_FLAGS_ROLE_MASK         (7 <<  0)\n\n \n#define PS_FAULT_OCP                          1\n#define PS_FAULT_FAST_OCP                     2\n#define PS_FAULT_OVP                          3\n#define PS_FAULT_DISCH                        4\n\n \nstruct mcdp_version {\n\tuint8_t major;\n\tuint8_t minor;\n\tuint16_t build;\n} __ec_align4;\n\nstruct mcdp_info {\n\tuint8_t family[2];\n\tuint8_t chipid[2];\n\tstruct mcdp_version irom;\n\tstruct mcdp_version fw;\n} __ec_align4;\n\n \n#define MCDP_CHIPID(chipid) ((chipid[0] << 8) | chipid[1])\n#define MCDP_FAMILY(family) ((family[0] << 8) | family[1])\n\n \n#define EC_CMD_USB_PD_GET_AMODE 0x0116\nstruct ec_params_usb_pd_get_mode_request {\n\tuint16_t svid_idx;  \n\tuint8_t port;       \n} __ec_align_size1;\n\nstruct ec_params_usb_pd_get_mode_response {\n\tuint16_t svid;    \n\tuint16_t opos;     \n\tuint32_t vdo[6];  \n} __ec_align4;\n\n#define EC_CMD_USB_PD_SET_AMODE 0x0117\n\nenum pd_mode_cmd {\n\tPD_EXIT_MODE = 0,\n\tPD_ENTER_MODE = 1,\n\t \n\tPD_MODE_CMD_COUNT,\n};\n\nstruct ec_params_usb_pd_set_mode_request {\n\tuint32_t cmd;   \n\tuint16_t svid;  \n\tuint8_t opos;   \n\tuint8_t port;   \n} __ec_align4;\n\n \n#define EC_CMD_PD_WRITE_LOG_ENTRY 0x0118\n\nstruct ec_params_pd_write_log_entry {\n\tuint8_t type;  \n\tuint8_t port;  \n} __ec_align1;\n\n\n \n#define EC_CMD_PD_CONTROL 0x0119\n\nenum ec_pd_control_cmd {\n\tPD_SUSPEND = 0,       \n\tPD_RESUME,            \n\tPD_RESET,             \n\tPD_CONTROL_DISABLE,   \n\tPD_CHIP_ON,           \n};\n\nstruct ec_params_pd_control {\n\tuint8_t chip;          \n\tuint8_t subcmd;\n} __ec_align1;\n\n \n#define EC_CMD_USB_PD_MUX_INFO 0x011A\n\nstruct ec_params_usb_pd_mux_info {\n\tuint8_t port;  \n} __ec_align1;\n\n \n#define USB_PD_MUX_NONE               0       \n#define USB_PD_MUX_USB_ENABLED        BIT(0)  \n#define USB_PD_MUX_DP_ENABLED         BIT(1)  \n#define USB_PD_MUX_POLARITY_INVERTED  BIT(2)  \n#define USB_PD_MUX_HPD_IRQ            BIT(3)  \n#define USB_PD_MUX_HPD_LVL            BIT(4)  \n#define USB_PD_MUX_SAFE_MODE          BIT(5)  \n#define USB_PD_MUX_TBT_COMPAT_ENABLED BIT(6)  \n#define USB_PD_MUX_USB4_ENABLED       BIT(7)  \n\nstruct ec_response_usb_pd_mux_info {\n\tuint8_t flags;  \n} __ec_align1;\n\n#define EC_CMD_PD_CHIP_INFO\t\t0x011B\n\nstruct ec_params_pd_chip_info {\n\tuint8_t port;\t \n\tuint8_t renew;\t \n} __ec_align1;\n\nstruct ec_response_pd_chip_info {\n\tuint16_t vendor_id;\n\tuint16_t product_id;\n\tuint16_t device_id;\n\tunion {\n\t\tuint8_t fw_version_string[8];\n\t\tuint64_t fw_version_number;\n\t};\n} __ec_align2;\n\nstruct ec_response_pd_chip_info_v1 {\n\tuint16_t vendor_id;\n\tuint16_t product_id;\n\tuint16_t device_id;\n\tunion {\n\t\tuint8_t fw_version_string[8];\n\t\tuint64_t fw_version_number;\n\t};\n\tunion {\n\t\tuint8_t min_req_fw_version_string[8];\n\t\tuint64_t min_req_fw_version_number;\n\t};\n} __ec_align2;\n\n \n#define EC_CMD_RWSIG_CHECK_STATUS\t0x011C\n\nstruct ec_response_rwsig_check_status {\n\tuint32_t status;\n} __ec_align4;\n\n \n#define EC_CMD_RWSIG_ACTION\t0x011D\n\nenum rwsig_action {\n\tRWSIG_ACTION_ABORT = 0,\t\t \n\tRWSIG_ACTION_CONTINUE = 1,\t \n};\n\nstruct ec_params_rwsig_action {\n\tuint32_t action;\n} __ec_align4;\n\n \n#define EC_CMD_EFS_VERIFY\t0x011E\n\nstruct ec_params_efs_verify {\n\tuint8_t region;\t\t \n} __ec_align1;\n\n \n#define EC_CMD_GET_CROS_BOARD_INFO\t0x011F\n \n#define EC_CMD_SET_CROS_BOARD_INFO\t0x0120\n\nenum cbi_data_tag {\n\tCBI_TAG_BOARD_VERSION = 0,  \n\tCBI_TAG_OEM_ID = 1,         \n\tCBI_TAG_SKU_ID = 2,         \n\tCBI_TAG_DRAM_PART_NUM = 3,  \n\tCBI_TAG_OEM_NAME = 4,       \n\tCBI_TAG_MODEL_ID = 5,       \n\tCBI_TAG_COUNT,\n};\n\n \n#define CBI_GET_RELOAD\t\tBIT(0)\n\nstruct ec_params_get_cbi {\n\tuint32_t tag;\t\t \n\tuint32_t flag;\t\t \n} __ec_align4;\n\n \n#define CBI_SET_NO_SYNC\t\tBIT(0)\n#define CBI_SET_INIT\t\tBIT(1)\n\nstruct ec_params_set_cbi {\n\tuint32_t tag;\t\t \n\tuint32_t flag;\t\t \n\tuint32_t size;\t\t \n\tuint8_t data[];\t\t \n} __ec_align1;\n\n \n#define EC_CMD_GET_UPTIME_INFO 0x0121\n\nstruct ec_response_uptime_info {\n\t \n\tuint32_t time_since_ec_boot_ms;\n\n\t \n\tuint32_t ap_resets_since_ec_boot;\n\n\t \n\tuint32_t ec_reset_flags;\n\n\t \n\tstruct ap_reset_log_entry {\n\t\t \n\t\tuint16_t reset_cause;\n\n\t\t \n\t\tuint16_t reserved;\n\n\t\t \n\t\tuint32_t reset_time_ms;\n\t} recent_ap_reset[4];\n} __ec_align4;\n\n \n#define EC_CMD_ADD_ENTROPY\t0x0122\n\nenum add_entropy_action {\n\t \n\tADD_ENTROPY_ASYNC = 0,\n\t \n\tADD_ENTROPY_RESET_ASYNC = 1,\n\t \n\tADD_ENTROPY_GET_RESULT = 2,\n};\n\nstruct ec_params_rollback_add_entropy {\n\tuint8_t action;\n} __ec_align1;\n\n \n#define EC_CMD_ADC_READ\t\t0x0123\n\nstruct ec_params_adc_read {\n\tuint8_t adc_channel;\n} __ec_align1;\n\nstruct ec_response_adc_read {\n\tint32_t adc_value;\n} __ec_align4;\n\n \n#define EC_CMD_ROLLBACK_INFO\t\t0x0124\n\nstruct ec_response_rollback_info {\n\tint32_t id;  \n\tint32_t rollback_min_version;\n\tint32_t rw_rollback_version;\n} __ec_align4;\n\n\n \n#define EC_CMD_AP_RESET 0x0125\n\n \n#define EC_CMD_PCHG_COUNT 0x0134\n\n#define EC_PCHG_MAX_PORTS 8\n\nstruct ec_response_pchg_count {\n\tuint8_t port_count;\n} __ec_align1;\n\n \n#define EC_CMD_PCHG 0x0135\n\nstruct ec_params_pchg {\n\tuint8_t port;\n} __ec_align1;\n\nstruct ec_response_pchg {\n\tuint32_t error;\t\t\t \n\tuint8_t state;\t\t\t \n\tuint8_t battery_percentage;\n\tuint8_t unused0;\n\tuint8_t unused1;\n\t \n\tuint32_t fw_version;\n\tuint32_t dropped_event_count;\n} __ec_align2;\n\nenum pchg_state {\n\t \n\tPCHG_STATE_RESET = 0,\n\t \n\tPCHG_STATE_INITIALIZED,\n\t \n\tPCHG_STATE_ENABLED,\n\t \n\tPCHG_STATE_DETECTED,\n\t \n\tPCHG_STATE_CHARGING,\n\t \n\tPCHG_STATE_FULL,\n\t \n\tPCHG_STATE_DOWNLOAD,\n\t \n\tPCHG_STATE_DOWNLOADING,\n\t \n\tPCHG_STATE_CONNECTED,\n\t \n\tPCHG_STATE_COUNT,\n};\n\n#define EC_PCHG_STATE_TEXT { \\\n\t[PCHG_STATE_RESET] = \"RESET\", \\\n\t[PCHG_STATE_INITIALIZED] = \"INITIALIZED\", \\\n\t[PCHG_STATE_ENABLED] = \"ENABLED\", \\\n\t[PCHG_STATE_DETECTED] = \"DETECTED\", \\\n\t[PCHG_STATE_CHARGING] = \"CHARGING\", \\\n\t[PCHG_STATE_FULL] = \"FULL\", \\\n\t[PCHG_STATE_DOWNLOAD] = \"DOWNLOAD\", \\\n\t[PCHG_STATE_DOWNLOADING] = \"DOWNLOADING\", \\\n\t[PCHG_STATE_CONNECTED] = \"CONNECTED\", \\\n\t}\n\n \n#define EC_CMD_PCHG_UPDATE 0x0136\n\n \n#define EC_MKBP_PCHG_PORT_SHIFT\t\t28\n \n#define EC_MKBP_PCHG_EVENT_TO_PORT(e)\t(((e) >> EC_MKBP_PCHG_PORT_SHIFT) & 0xf)\n \n#define EC_MKBP_PCHG_EVENT_MASK(e)\t((e) \\\n\t\t\t\t\t& GENMASK(EC_MKBP_PCHG_PORT_SHIFT-1, 0))\n\n#define EC_MKBP_PCHG_UPDATE_OPENED\tBIT(0)\n#define EC_MKBP_PCHG_WRITE_COMPLETE\tBIT(1)\n#define EC_MKBP_PCHG_UPDATE_CLOSED\tBIT(2)\n#define EC_MKBP_PCHG_UPDATE_ERROR\tBIT(3)\n#define EC_MKBP_PCHG_DEVICE_EVENT\tBIT(4)\n\nenum ec_pchg_update_cmd {\n\t \n\tEC_PCHG_UPDATE_CMD_RESET_TO_NORMAL = 0,\n\t \n\tEC_PCHG_UPDATE_CMD_OPEN,\n\t \n\tEC_PCHG_UPDATE_CMD_WRITE,\n\t \n\tEC_PCHG_UPDATE_CMD_CLOSE,\n\t \n\tEC_PCHG_UPDATE_CMD_COUNT,\n};\n\nstruct ec_params_pchg_update {\n\t \n\tuint8_t port;\n\t \n\tuint8_t cmd;\n\t \n\tuint8_t reserved0;\n\tuint8_t reserved1;\n\t \n\tuint32_t version;\n\t \n\tuint32_t crc32;\n\t \n\tuint32_t addr;\n\t \n\tuint32_t size;\n\t \n\tuint8_t data[];\n} __ec_align4;\n\nBUILD_ASSERT(EC_PCHG_UPDATE_CMD_COUNT\n\t     < BIT(sizeof(((struct ec_params_pchg_update *)0)->cmd)*8));\n\nstruct ec_response_pchg_update {\n\t \n\tuint32_t block_size;\n} __ec_align4;\n\n\n \n \n\n \n#define EC_CMD_REGULATOR_GET_INFO 0x012C\n\n \n#define EC_REGULATOR_NAME_MAX_LEN 16\n\n \n#define EC_REGULATOR_VOLTAGE_MAX_COUNT 16\n\nstruct ec_params_regulator_get_info {\n\tuint32_t index;\n} __ec_align4;\n\nstruct ec_response_regulator_get_info {\n\tchar name[EC_REGULATOR_NAME_MAX_LEN];\n\tuint16_t num_voltages;\n\tuint16_t voltages_mv[EC_REGULATOR_VOLTAGE_MAX_COUNT];\n} __ec_align2;\n\n \n#define EC_CMD_REGULATOR_ENABLE 0x012D\n\nstruct ec_params_regulator_enable {\n\tuint32_t index;\n\tuint8_t enable;\n} __ec_align4;\n\n \n#define EC_CMD_REGULATOR_IS_ENABLED 0x012E\n\nstruct ec_params_regulator_is_enabled {\n\tuint32_t index;\n} __ec_align4;\n\nstruct ec_response_regulator_is_enabled {\n\tuint8_t enabled;\n} __ec_align1;\n\n \n#define EC_CMD_REGULATOR_SET_VOLTAGE 0x012F\n\nstruct ec_params_regulator_set_voltage {\n\tuint32_t index;\n\tuint32_t min_mv;\n\tuint32_t max_mv;\n} __ec_align4;\n\n \n#define EC_CMD_REGULATOR_GET_VOLTAGE 0x0130\n\nstruct ec_params_regulator_get_voltage {\n\tuint32_t index;\n} __ec_align4;\n\nstruct ec_response_regulator_get_voltage {\n\tuint32_t voltage_mv;\n} __ec_align4;\n\n \n#define EC_CMD_TYPEC_DISCOVERY 0x0131\n\nenum typec_partner_type {\n\tTYPEC_PARTNER_SOP = 0,\n\tTYPEC_PARTNER_SOP_PRIME = 1,\n};\n\nstruct ec_params_typec_discovery {\n\tuint8_t port;\n\tuint8_t partner_type;  \n} __ec_align1;\n\nstruct svid_mode_info {\n\tuint16_t svid;\n\tuint16_t mode_count;   \n\tuint32_t mode_vdo[6];  \n};\n\nstruct ec_response_typec_discovery {\n\tuint8_t identity_count;     \n\tuint8_t svid_count;\t    \n\tuint16_t reserved;\n\tuint32_t discovery_vdo[6];  \n\tstruct svid_mode_info svids[];\n} __ec_align1;\n\n \n#define EC_CMD_TYPEC_CONTROL 0x0132\n\nenum typec_control_command {\n\tTYPEC_CONTROL_COMMAND_EXIT_MODES,\n\tTYPEC_CONTROL_COMMAND_CLEAR_EVENTS,\n\tTYPEC_CONTROL_COMMAND_ENTER_MODE,\n\tTYPEC_CONTROL_COMMAND_TBT_UFP_REPLY,\n\tTYPEC_CONTROL_COMMAND_USB_MUX_SET,\n\tTYPEC_CONTROL_COMMAND_BIST_SHARE_MODE,\n\tTYPEC_CONTROL_COMMAND_SEND_VDM_REQ,\n};\n\n \nenum typec_tbt_ufp_reply {\n\tTYPEC_TBT_UFP_REPLY_NAK,\n\tTYPEC_TBT_UFP_REPLY_ACK,\n};\n\nstruct typec_usb_mux_set {\n\tuint8_t mux_index;\t \n\tuint8_t mux_flags;\t \n} __ec_align1;\n\n#define VDO_MAX_SIZE 7\n\nstruct typec_vdm_req {\n\t \n\tuint32_t vdm_data[VDO_MAX_SIZE];\n\t \n\tuint8_t vdm_data_objects;\n\t \n\tuint8_t partner_type;\n} __ec_align1;\n\nstruct ec_params_typec_control {\n\tuint8_t port;\n\tuint8_t command;\t \n\tuint16_t reserved;\n\n\t \n\tunion {\n\t\tuint32_t clear_events_mask;\n\t\tuint8_t mode_to_enter;       \n\t\tuint8_t tbt_ufp_reply;       \n\t\tstruct typec_usb_mux_set mux_params;\n\t\t \n\t\tstruct typec_vdm_req vdm_req_params;\n\t\tuint8_t placeholder[128];\n\t};\n} __ec_align1;\n\n \n#define EC_CMD_TYPEC_STATUS 0x0133\n\n \nenum pd_power_role {\n\tPD_ROLE_SINK = 0,\n\tPD_ROLE_SOURCE = 1\n};\n\n \nenum pd_data_role {\n\tPD_ROLE_UFP = 0,\n\tPD_ROLE_DFP = 1,\n\tPD_ROLE_DISCONNECTED = 2,\n};\n\nenum pd_vconn_role {\n\tPD_ROLE_VCONN_OFF = 0,\n\tPD_ROLE_VCONN_SRC = 1,\n};\n\n \nenum tcpc_cc_polarity {\n\t \n\tPOLARITY_CC1 = 0,\n\tPOLARITY_CC2 = 1,\n\n\t \n\tPOLARITY_CC1_DTS = 2,\n\tPOLARITY_CC2_DTS = 3,\n\n\t \n\tPOLARITY_COUNT\n};\n\n#define PD_STATUS_EVENT_SOP_DISC_DONE\t\tBIT(0)\n#define PD_STATUS_EVENT_SOP_PRIME_DISC_DONE\tBIT(1)\n#define PD_STATUS_EVENT_HARD_RESET\t\tBIT(2)\n#define PD_STATUS_EVENT_DISCONNECTED\t\tBIT(3)\n#define PD_STATUS_EVENT_MUX_0_SET_DONE\t\tBIT(4)\n#define PD_STATUS_EVENT_MUX_1_SET_DONE\t\tBIT(5)\n#define PD_STATUS_EVENT_VDM_REQ_REPLY\t\tBIT(6)\n#define PD_STATUS_EVENT_VDM_REQ_FAILED\t\tBIT(7)\n#define PD_STATUS_EVENT_VDM_ATTENTION\t\tBIT(8)\n\nstruct ec_params_typec_status {\n\tuint8_t port;\n} __ec_align1;\n\nstruct ec_response_typec_status {\n\tuint8_t pd_enabled;\t\t \n\tuint8_t dev_connected;\t\t \n\tuint8_t sop_connected;\t\t \n\tuint8_t source_cap_count;\t \n\n\tuint8_t power_role;\t\t \n\tuint8_t data_role;\t\t \n\tuint8_t vconn_role;\t\t \n\tuint8_t sink_cap_count;\t\t \n\n\tuint8_t polarity;\t\t \n\tuint8_t cc_state;\t\t \n\tuint8_t dp_pin;\t\t\t \n\tuint8_t mux_state;\t\t \n\n\tchar tc_state[32];\t\t \n\n\tuint32_t events;\t\t \n\n\t \n\tuint16_t sop_revision;\n\tuint16_t sop_prime_revision;\n\n\tuint32_t source_cap_pdos[7];\t \n\n\tuint32_t sink_cap_pdos[7];\t \n} __ec_align1;\n\n \n#define EC_CMD_TYPEC_VDM_RESPONSE 0x013C\n\nstruct ec_params_typec_vdm_response {\n\tuint8_t port;\n} __ec_align1;\n\nstruct ec_response_typec_vdm_response {\n\t \n\tuint8_t vdm_data_objects;\n\t \n\tuint8_t partner_type;\n\t \n\tuint16_t vdm_response_err;\n\t \n\tuint32_t vdm_response[VDO_MAX_SIZE];\n\t \n\tuint8_t vdm_attention_objects;\n\t \n\tuint8_t vdm_attention_left;\n\t \n\tuint16_t reserved1;\n\t \n\tuint32_t vdm_attention[2];\n} __ec_align1;\n\n#undef VDO_MAX_SIZE\n\n \n \n\n \n \n#define EC_CMD_CR51_BASE 0x0300\n#define EC_CMD_CR51_LAST 0x03FF\n\n \n \n\n \n#define EC_CMD_FP_PASSTHRU 0x0400\n\n#define EC_FP_FLAG_NOT_COMPLETE 0x1\n\nstruct ec_params_fp_passthru {\n\tuint16_t len;\t\t \n\tuint16_t flags;\t\t \n\tuint8_t data[];\t\t \n} __ec_align2;\n\n \n#define EC_CMD_FP_MODE 0x0402\n\n \n#define FP_MODE_DEEPSLEEP      BIT(0)\n \n#define FP_MODE_FINGER_DOWN    BIT(1)\n \n#define FP_MODE_FINGER_UP      BIT(2)\n \n#define FP_MODE_CAPTURE        BIT(3)\n \n#define FP_MODE_ENROLL_SESSION BIT(4)\n \n#define FP_MODE_ENROLL_IMAGE   BIT(5)\n \n#define FP_MODE_MATCH          BIT(6)\n \n#define FP_MODE_RESET_SENSOR   BIT(7)\n \n#define FP_MODE_DONT_CHANGE    BIT(31)\n\n#define FP_VALID_MODES (FP_MODE_DEEPSLEEP      | \\\n\t\t\tFP_MODE_FINGER_DOWN    | \\\n\t\t\tFP_MODE_FINGER_UP      | \\\n\t\t\tFP_MODE_CAPTURE        | \\\n\t\t\tFP_MODE_ENROLL_SESSION | \\\n\t\t\tFP_MODE_ENROLL_IMAGE   | \\\n\t\t\tFP_MODE_MATCH          | \\\n\t\t\tFP_MODE_RESET_SENSOR   | \\\n\t\t\tFP_MODE_DONT_CHANGE)\n\n \n#define FP_MODE_CAPTURE_TYPE_SHIFT 28\n#define FP_MODE_CAPTURE_TYPE_MASK  (0x7 << FP_MODE_CAPTURE_TYPE_SHIFT)\n \nenum fp_capture_type {\n\t \n\tFP_CAPTURE_VENDOR_FORMAT = 0,\n\t \n\tFP_CAPTURE_SIMPLE_IMAGE = 1,\n\t \n\tFP_CAPTURE_PATTERN0 = 2,\n\t \n\tFP_CAPTURE_PATTERN1 = 3,\n\t \n\tFP_CAPTURE_QUALITY_TEST = 4,\n\t \n\tFP_CAPTURE_RESET_TEST = 5,\n\tFP_CAPTURE_TYPE_MAX,\n};\n \n#define FP_CAPTURE_TYPE(mode) (((mode) & FP_MODE_CAPTURE_TYPE_MASK) \\\n\t\t\t\t       >> FP_MODE_CAPTURE_TYPE_SHIFT)\n\nstruct ec_params_fp_mode {\n\tuint32_t mode;  \n} __ec_align4;\n\nstruct ec_response_fp_mode {\n\tuint32_t mode;  \n} __ec_align4;\n\n \n#define EC_CMD_FP_INFO 0x0403\n\n \n#define FP_ERROR_DEAD_PIXELS(errors) ((errors) & 0x3FF)\n \n#define FP_ERROR_DEAD_PIXELS_UNKNOWN (0x3FF)\n \n#define FP_ERROR_NO_IRQ    BIT(12)\n \n#define FP_ERROR_SPI_COMM  BIT(13)\n \n#define FP_ERROR_BAD_HWID  BIT(14)\n \n#define FP_ERROR_INIT_FAIL BIT(15)\n\nstruct ec_response_fp_info_v0 {\n\t \n\tuint32_t vendor_id;\n\tuint32_t product_id;\n\tuint32_t model_id;\n\tuint32_t version;\n\t \n\tuint32_t frame_size;\n\tuint32_t pixel_format;  \n\tuint16_t width;\n\tuint16_t height;\n\tuint16_t bpp;\n\tuint16_t errors;  \n} __ec_align4;\n\nstruct ec_response_fp_info {\n\t \n\tuint32_t vendor_id;\n\tuint32_t product_id;\n\tuint32_t model_id;\n\tuint32_t version;\n\t \n\tuint32_t frame_size;\n\tuint32_t pixel_format;  \n\tuint16_t width;\n\tuint16_t height;\n\tuint16_t bpp;\n\tuint16_t errors;  \n\t \n\tuint32_t template_size;   \n\tuint16_t template_max;    \n\tuint16_t template_valid;  \n\tuint32_t template_dirty;  \n\tuint32_t template_version;  \n} __ec_align4;\n\n \n#define EC_CMD_FP_FRAME 0x0404\n\n \n#define FP_FRAME_INDEX_SHIFT       28\n \n#define FP_FRAME_INDEX_RAW_IMAGE    0\n \n#define FP_FRAME_INDEX_TEMPLATE     1\n#define FP_FRAME_GET_BUFFER_INDEX(offset) ((offset) >> FP_FRAME_INDEX_SHIFT)\n#define FP_FRAME_OFFSET_MASK       0x0FFFFFFF\n\n \n#define FP_TEMPLATE_FORMAT_VERSION 3\n\n \n#define FP_CONTEXT_NONCE_BYTES 12\n#define FP_CONTEXT_USERID_WORDS (32 / sizeof(uint32_t))\n#define FP_CONTEXT_TAG_BYTES 16\n#define FP_CONTEXT_SALT_BYTES 16\n#define FP_CONTEXT_TPM_BYTES 32\n\nstruct ec_fp_template_encryption_metadata {\n\t \n\tuint16_t struct_version;\n\t \n\tuint16_t reserved;\n\t \n\tuint8_t nonce[FP_CONTEXT_NONCE_BYTES];\n\tuint8_t salt[FP_CONTEXT_SALT_BYTES];\n\tuint8_t tag[FP_CONTEXT_TAG_BYTES];\n};\n\nstruct ec_params_fp_frame {\n\t \n\tuint32_t offset;\n\tuint32_t size;\n} __ec_align4;\n\n \n#define EC_CMD_FP_TEMPLATE 0x0405\n\n \n#define FP_TEMPLATE_COMMIT 0x80000000\n\nstruct ec_params_fp_template {\n\tuint32_t offset;\n\tuint32_t size;\n\tuint8_t data[];\n} __ec_align4;\n\n \n#define EC_CMD_FP_CONTEXT 0x0406\n\nstruct ec_params_fp_context {\n\tuint32_t userid[FP_CONTEXT_USERID_WORDS];\n} __ec_align4;\n\n#define EC_CMD_FP_STATS 0x0407\n\n#define FPSTATS_CAPTURE_INV  BIT(0)\n#define FPSTATS_MATCHING_INV BIT(1)\n\nstruct ec_response_fp_stats {\n\tuint32_t capture_time_us;\n\tuint32_t matching_time_us;\n\tuint32_t overall_time_us;\n\tstruct {\n\t\tuint32_t lo;\n\t\tuint32_t hi;\n\t} overall_t0;\n\tuint8_t timestamps_invalid;\n\tint8_t template_matched;\n} __ec_align2;\n\n#define EC_CMD_FP_SEED 0x0408\nstruct ec_params_fp_seed {\n\t \n\tuint16_t struct_version;\n\t \n\tuint16_t reserved;\n\t \n\tuint8_t seed[FP_CONTEXT_TPM_BYTES];\n} __ec_align4;\n\n#define EC_CMD_FP_ENC_STATUS 0x0409\n\n \n#define FP_ENC_STATUS_SEED_SET BIT(0)\n\nstruct ec_response_fp_encryption_status {\n\t \n\tuint32_t valid_flags;\n\t \n\tuint32_t status;\n} __ec_align4;\n\n \n \n\n \n#define EC_CMD_TP_SELF_TEST 0x0500\n\n \n#define EC_CMD_TP_FRAME_INFO 0x0501\n\nstruct ec_response_tp_frame_info {\n\tuint32_t n_frames;\n\tuint32_t frame_sizes[];\n} __ec_align4;\n\n \n#define EC_CMD_TP_FRAME_SNAPSHOT 0x0502\n\n \n#define EC_CMD_TP_FRAME_GET 0x0503\n\nstruct ec_params_tp_frame_get {\n\tuint32_t frame_index;\n\tuint32_t offset;\n\tuint32_t size;\n} __ec_align4;\n\n \n \n\n#define EC_COMM_TEXT_MAX 8\n\n \n#define EC_CMD_BATTERY_GET_STATIC 0x0600\n\n \nstruct ec_params_battery_static_info {\n\tuint8_t index;\n} __ec_align_size1;\n\n \nstruct ec_response_battery_static_info {\n\tuint16_t design_capacity;\n\tuint16_t design_voltage;\n\tchar manufacturer[EC_COMM_TEXT_MAX];\n\tchar model[EC_COMM_TEXT_MAX];\n\tchar serial[EC_COMM_TEXT_MAX];\n\tchar type[EC_COMM_TEXT_MAX];\n\t \n\tuint32_t cycle_count;\n} __ec_align4;\n\n \n#define EC_CMD_BATTERY_GET_DYNAMIC 0x0601\n\n \nstruct ec_params_battery_dynamic_info {\n\tuint8_t index;\n} __ec_align_size1;\n\n \nstruct ec_response_battery_dynamic_info {\n\tint16_t actual_voltage;\n\tint16_t actual_current;\n\tint16_t remaining_capacity;\n\tint16_t full_capacity;\n\tint16_t flags;\n\tint16_t desired_voltage;\n\tint16_t desired_current;\n} __ec_align2;\n\n \n#define EC_CMD_CHARGER_CONTROL 0x0602\n\n \nstruct ec_params_charger_control {\n\tint16_t max_current;\n\tuint16_t otg_voltage;\n\tuint8_t allow_charging;\n} __ec_align_size1;\n\n \n#define EC_CMD_USB_PD_MUX_ACK 0x0603\n\nstruct ec_params_usb_pd_mux_ack {\n\tuint8_t port;  \n} __ec_align1;\n\n \n \n#define EC_CMD_BOARD_SPECIFIC_BASE 0x3E00\n#define EC_CMD_BOARD_SPECIFIC_LAST 0x3FFF\n\n \n#define EC_PRIVATE_HOST_COMMAND_VALUE(command) \\\n\t(EC_CMD_BOARD_SPECIFIC_BASE + (command))\n\n \n \n\n \n#define EC_CMD_PASSTHRU_OFFSET(n) (0x4000 * (n))\n#define EC_CMD_PASSTHRU_MAX(n) (EC_CMD_PASSTHRU_OFFSET(n) + 0x3fff)\n\n \n \n#define EC_HOST_PARAM_SIZE      EC_PROTO2_MAX_PARAM_SIZE\n#define EC_LPC_ADDR_OLD_PARAM   EC_HOST_CMD_REGION1\n#define EC_OLD_PARAM_SIZE       EC_HOST_CMD_REGION_SIZE\n\n\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}