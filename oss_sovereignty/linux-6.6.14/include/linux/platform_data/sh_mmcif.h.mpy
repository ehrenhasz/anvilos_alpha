{
  "module_name": "sh_mmcif.h",
  "hash_id": "ac93fcfbb3152e05700d17b20b847b5f0c06bed56c47aa3698aaa09677069378",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/platform_data/sh_mmcif.h",
  "human_readable_source": " \n \n\n#ifndef LINUX_MMC_SH_MMCIF_H\n#define LINUX_MMC_SH_MMCIF_H\n\n#include <linux/io.h>\n#include <linux/platform_device.h>\n\n \n\nstruct sh_mmcif_plat_data {\n\tunsigned int\t\tslave_id_tx;\t \n\tunsigned int\t\tslave_id_rx;\n\tu8\t\t\tsup_pclk;\t \n\tunsigned long\t\tcaps;\n\tu32\t\t\tocr;\n};\n\n#define MMCIF_CE_CMD_SET\t0x00000000\n#define MMCIF_CE_ARG\t\t0x00000008\n#define MMCIF_CE_ARG_CMD12\t0x0000000C\n#define MMCIF_CE_CMD_CTRL\t0x00000010\n#define MMCIF_CE_BLOCK_SET\t0x00000014\n#define MMCIF_CE_CLK_CTRL\t0x00000018\n#define MMCIF_CE_BUF_ACC\t0x0000001C\n#define MMCIF_CE_RESP3\t\t0x00000020\n#define MMCIF_CE_RESP2\t\t0x00000024\n#define MMCIF_CE_RESP1\t\t0x00000028\n#define MMCIF_CE_RESP0\t\t0x0000002C\n#define MMCIF_CE_RESP_CMD12\t0x00000030\n#define MMCIF_CE_DATA\t\t0x00000034\n#define MMCIF_CE_INT\t\t0x00000040\n#define MMCIF_CE_INT_MASK\t0x00000044\n#define MMCIF_CE_HOST_STS1\t0x00000048\n#define MMCIF_CE_HOST_STS2\t0x0000004C\n#define MMCIF_CE_CLK_CTRL2\t0x00000070\n#define MMCIF_CE_VERSION\t0x0000007C\n\n \n#define BUF_ACC_DMAWEN\t\t(1 << 25)\n#define BUF_ACC_DMAREN\t\t(1 << 24)\n#define BUF_ACC_BUSW_32\t\t(0 << 17)\n#define BUF_ACC_BUSW_16\t\t(1 << 17)\n#define BUF_ACC_ATYP\t\t(1 << 16)\n\n \n#define CLK_ENABLE\t\t(1 << 24)  \n#define CLK_CLEAR\t\t(0xf << 16)\n#define CLK_SUP_PCLK\t\t(0xf << 16)\n#define CLKDIV_4\t\t(1 << 16)  \n#define CLKDIV_256\t\t(7 << 16)  \n#define SRSPTO_256\t\t(2 << 12)  \n#define SRBSYTO_29\t\t(0xf << 8)  \n#define SRWDTO_29\t\t(0xf << 4)  \n#define SCCSTO_29\t\t(0xf << 0)  \n\n \n#define SOFT_RST_ON\t\t(1 << 31)\n#define SOFT_RST_OFF\t\t0\n\nstatic inline u32 sh_mmcif_readl(void __iomem *addr, int reg)\n{\n\treturn __raw_readl(addr + reg);\n}\n\nstatic inline void sh_mmcif_writel(void __iomem *addr, int reg, u32 val)\n{\n\t__raw_writel(val, addr + reg);\n}\n\n#define SH_MMCIF_BBS 512  \n\nstatic inline void sh_mmcif_boot_cmd_send(void __iomem *base,\n\t\t\t\t\t  unsigned long cmd, unsigned long arg)\n{\n\tsh_mmcif_writel(base, MMCIF_CE_INT, 0);\n\tsh_mmcif_writel(base, MMCIF_CE_ARG, arg);\n\tsh_mmcif_writel(base, MMCIF_CE_CMD_SET, cmd);\n}\n\nstatic inline int sh_mmcif_boot_cmd_poll(void __iomem *base, unsigned long mask)\n{\n\tunsigned long tmp;\n\tint cnt;\n\n\tfor (cnt = 0; cnt < 1000000; cnt++) {\n\t\ttmp = sh_mmcif_readl(base, MMCIF_CE_INT);\n\t\tif (tmp & mask) {\n\t\t\tsh_mmcif_writel(base, MMCIF_CE_INT, tmp & ~mask);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic inline int sh_mmcif_boot_cmd(void __iomem *base,\n\t\t\t\t    unsigned long cmd, unsigned long arg)\n{\n\tsh_mmcif_boot_cmd_send(base, cmd, arg);\n\treturn sh_mmcif_boot_cmd_poll(base, 0x00010000);\n}\n\nstatic inline int sh_mmcif_boot_do_read_single(void __iomem *base,\n\t\t\t\t\t       unsigned int block_nr,\n\t\t\t\t\t       unsigned long *buf)\n{\n\tint k;\n\n\t \n\tsh_mmcif_boot_cmd(base, 0x0d400000, 0x00010000);\n\n\tif (sh_mmcif_readl(base, MMCIF_CE_RESP0) != 0x0900)\n\t\treturn -1;\n\n\t \n\tsh_mmcif_boot_cmd(base, 0x11480000, block_nr * SH_MMCIF_BBS);\n\tif (sh_mmcif_boot_cmd_poll(base, 0x00100000) < 0)\n\t\treturn -1;\n\n\tfor (k = 0; k < (SH_MMCIF_BBS / 4); k++)\n\t\tbuf[k] = sh_mmcif_readl(base, MMCIF_CE_DATA);\n\n\treturn 0;\n}\n\nstatic inline int sh_mmcif_boot_do_read(void __iomem *base,\n\t\t\t\t\tunsigned long first_block,\n\t\t\t\t\tunsigned long nr_blocks,\n\t\t\t\t\tvoid *buf)\n{\n\tunsigned long k;\n\tint ret = 0;\n\n\t \n\tsh_mmcif_writel(base, MMCIF_CE_CLK_CTRL,\n\t\t\tCLK_ENABLE | CLKDIV_4 | SRSPTO_256 |\n\t\t\tSRBSYTO_29 | SRWDTO_29 | SCCSTO_29);\n\n\t \n\tsh_mmcif_boot_cmd(base, 0x09806000, 0x00010000);\n\n\t \n\tsh_mmcif_boot_cmd(base, 0x07400000, 0x00010000);\n\n\t \n\tsh_mmcif_boot_cmd(base, 0x10400000, SH_MMCIF_BBS);\n\n\tfor (k = 0; !ret && k < nr_blocks; k++)\n\t\tret = sh_mmcif_boot_do_read_single(base, first_block + k,\n\t\t\t\t\t\t   buf + (k * SH_MMCIF_BBS));\n\n\treturn ret;\n}\n\nstatic inline void sh_mmcif_boot_init(void __iomem *base)\n{\n\t \n\tsh_mmcif_writel(base, MMCIF_CE_VERSION, SOFT_RST_ON);\n\tsh_mmcif_writel(base, MMCIF_CE_VERSION, SOFT_RST_OFF);\n\n\t \n\tsh_mmcif_writel(base, MMCIF_CE_BUF_ACC, BUF_ACC_ATYP);\n\n\t \n\tsh_mmcif_writel(base, MMCIF_CE_BLOCK_SET, SH_MMCIF_BBS);\n\n\t \n\tsh_mmcif_writel(base, MMCIF_CE_CLK_CTRL,\n\t\t\tCLK_ENABLE | CLKDIV_256 | SRSPTO_256 |\n\t\t\tSRBSYTO_29 | SRWDTO_29 | SCCSTO_29);\n\n\t \n\tsh_mmcif_boot_cmd(base, 0x00000040, 0);\n\n\t \n\tdo {\n\t\tsh_mmcif_boot_cmd(base, 0x01405040, 0x40300000);  \n\t} while ((sh_mmcif_readl(base, MMCIF_CE_RESP0) & 0x80000000)\n\t\t != 0x80000000);\n\n\t \n\tsh_mmcif_boot_cmd(base, 0x02806040, 0);\n\n\t \n\tsh_mmcif_boot_cmd(base, 0x03400040, 0x00010000);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}