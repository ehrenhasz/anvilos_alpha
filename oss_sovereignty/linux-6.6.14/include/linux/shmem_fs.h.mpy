{
  "module_name": "shmem_fs.h",
  "hash_id": "11a686ebb12434ca8c826aab9849875d9e372578bd9293b2b6ca1bcda4fc45ee",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/shmem_fs.h",
  "human_readable_source": " \n#ifndef __SHMEM_FS_H\n#define __SHMEM_FS_H\n\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/percpu_counter.h>\n#include <linux/xattr.h>\n#include <linux/fs_parser.h>\n#include <linux/userfaultfd_k.h>\n\n \n\n#ifdef CONFIG_TMPFS_QUOTA\n#define SHMEM_MAXQUOTAS 2\n#endif\n\nstruct shmem_inode_info {\n\tspinlock_t\t\tlock;\n\tunsigned int\t\tseals;\t\t \n\tunsigned long\t\tflags;\n\tunsigned long\t\talloced;\t \n\tunsigned long\t\tswapped;\t \n\tpgoff_t\t\t\tfallocend;\t \n\tstruct list_head        shrinklist;      \n\tstruct list_head\tswaplist;\t \n\tstruct shared_policy\tpolicy;\t\t \n\tstruct simple_xattrs\txattrs;\t\t \n\tatomic_t\t\tstop_eviction;\t \n\tstruct timespec64\ti_crtime;\t \n\tunsigned int\t\tfsflags;\t \n#ifdef CONFIG_TMPFS_QUOTA\n\tstruct dquot\t\t*i_dquot[MAXQUOTAS];\n#endif\n\tstruct offset_ctx\tdir_offsets;\t \n\tstruct inode\t\tvfs_inode;\n};\n\n#define SHMEM_FL_USER_VISIBLE\t\tFS_FL_USER_VISIBLE\n#define SHMEM_FL_USER_MODIFIABLE \\\n\t(FS_IMMUTABLE_FL | FS_APPEND_FL | FS_NODUMP_FL | FS_NOATIME_FL)\n#define SHMEM_FL_INHERITED\t\t(FS_NODUMP_FL | FS_NOATIME_FL)\n\nstruct shmem_quota_limits {\n\tqsize_t usrquota_bhardlimit;  \n\tqsize_t usrquota_ihardlimit;  \n\tqsize_t grpquota_bhardlimit;  \n\tqsize_t grpquota_ihardlimit;  \n};\n\nstruct shmem_sb_info {\n\tunsigned long max_blocks;    \n\tstruct percpu_counter used_blocks;   \n\tunsigned long max_inodes;    \n\tunsigned long free_ispace;   \n\traw_spinlock_t stat_lock;    \n\tumode_t mode;\t\t     \n\tunsigned char huge;\t     \n\tkuid_t uid;\t\t     \n\tkgid_t gid;\t\t     \n\tbool full_inums;\t     \n\tbool noswap;\t\t     \n\tino_t next_ino;\t\t     \n\tino_t __percpu *ino_batch;   \n\tstruct mempolicy *mpol;      \n\tspinlock_t shrinklist_lock;    \n\tstruct list_head shrinklist;   \n\tunsigned long shrinklist_len;  \n\tstruct shmem_quota_limits qlimits;  \n};\n\nstatic inline struct shmem_inode_info *SHMEM_I(struct inode *inode)\n{\n\treturn container_of(inode, struct shmem_inode_info, vfs_inode);\n}\n\n \nextern const struct fs_parameter_spec shmem_fs_parameters[];\nextern void shmem_init(void);\nextern int shmem_init_fs_context(struct fs_context *fc);\nextern struct file *shmem_file_setup(const char *name,\n\t\t\t\t\tloff_t size, unsigned long flags);\nextern struct file *shmem_kernel_file_setup(const char *name, loff_t size,\n\t\t\t\t\t    unsigned long flags);\nextern struct file *shmem_file_setup_with_mnt(struct vfsmount *mnt,\n\t\tconst char *name, loff_t size, unsigned long flags);\nextern int shmem_zero_setup(struct vm_area_struct *);\nextern unsigned long shmem_get_unmapped_area(struct file *, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags);\nextern int shmem_lock(struct file *file, int lock, struct ucounts *ucounts);\n#ifdef CONFIG_SHMEM\nextern const struct address_space_operations shmem_aops;\nstatic inline bool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}\n#else\nstatic inline bool shmem_mapping(struct address_space *mapping)\n{\n\treturn false;\n}\n#endif  \nextern void shmem_unlock_mapping(struct address_space *mapping);\nextern struct page *shmem_read_mapping_page_gfp(struct address_space *mapping,\n\t\t\t\t\tpgoff_t index, gfp_t gfp_mask);\nextern void shmem_truncate_range(struct inode *inode, loff_t start, loff_t end);\nint shmem_unuse(unsigned int type);\n\nextern bool shmem_is_huge(struct inode *inode, pgoff_t index, bool shmem_huge_force,\n\t\t\t  struct mm_struct *mm, unsigned long vm_flags);\n#ifdef CONFIG_SHMEM\nextern unsigned long shmem_swap_usage(struct vm_area_struct *vma);\n#else\nstatic inline unsigned long shmem_swap_usage(struct vm_area_struct *vma)\n{\n\treturn 0;\n}\n#endif\nextern unsigned long shmem_partial_swap_usage(struct address_space *mapping,\n\t\t\t\t\t\tpgoff_t start, pgoff_t end);\n\n \nenum sgp_type {\n\tSGP_READ,\t \n\tSGP_NOALLOC,\t \n\tSGP_CACHE,\t \n\tSGP_WRITE,\t \n\tSGP_FALLOC,\t \n};\n\nint shmem_get_folio(struct inode *inode, pgoff_t index, struct folio **foliop,\n\t\tenum sgp_type sgp);\nstruct folio *shmem_read_folio_gfp(struct address_space *mapping,\n\t\tpgoff_t index, gfp_t gfp);\n\nstatic inline struct folio *shmem_read_folio(struct address_space *mapping,\n\t\tpgoff_t index)\n{\n\treturn shmem_read_folio_gfp(mapping, index, mapping_gfp_mask(mapping));\n}\n\nstatic inline struct page *shmem_read_mapping_page(\n\t\t\t\tstruct address_space *mapping, pgoff_t index)\n{\n\treturn shmem_read_mapping_page_gfp(mapping, index,\n\t\t\t\t\tmapping_gfp_mask(mapping));\n}\n\nstatic inline bool shmem_file(struct file *file)\n{\n\tif (!IS_ENABLED(CONFIG_SHMEM))\n\t\treturn false;\n\tif (!file || !file->f_mapping)\n\t\treturn false;\n\treturn shmem_mapping(file->f_mapping);\n}\n\n \nstatic inline pgoff_t shmem_fallocend(struct inode *inode, pgoff_t eof)\n{\n\treturn max(eof, SHMEM_I(inode)->fallocend);\n}\n\nextern bool shmem_charge(struct inode *inode, long pages);\nextern void shmem_uncharge(struct inode *inode, long pages);\n\n#ifdef CONFIG_USERFAULTFD\n#ifdef CONFIG_SHMEM\nextern int shmem_mfill_atomic_pte(pmd_t *dst_pmd,\n\t\t\t\t  struct vm_area_struct *dst_vma,\n\t\t\t\t  unsigned long dst_addr,\n\t\t\t\t  unsigned long src_addr,\n\t\t\t\t  uffd_flags_t flags,\n\t\t\t\t  struct folio **foliop);\n#else  \n#define shmem_mfill_atomic_pte(dst_pmd, dst_vma, dst_addr, \\\n\t\t\t       src_addr, flags, foliop) ({ BUG(); 0; })\n#endif  \n#endif  \n\n \n#define SHMEM_QUOTA_MAX_SPC_LIMIT 0x7fffffffffffffffLL  \n#define SHMEM_QUOTA_MAX_INO_LIMIT 0x7fffffffffffffffLL\n\n#ifdef CONFIG_TMPFS_QUOTA\nextern const struct dquot_operations shmem_quota_operations;\nextern struct quota_format_type shmem_quota_format;\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}