{
  "module_name": "fs_parser.h",
  "hash_id": "946064f75f103e42bd64076d66ccec19ad144fe351d172ac648625a05c8c762b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fs_parser.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_FS_PARSER_H\n#define _LINUX_FS_PARSER_H\n\n#include <linux/fs_context.h>\n\nstruct path;\n\nstruct constant_table {\n\tconst char\t*name;\n\tint\t\tvalue;\n};\n\nstruct fs_parameter_spec;\nstruct fs_parse_result;\ntypedef int fs_param_type(struct p_log *,\n\t\t\t  const struct fs_parameter_spec *,\n\t\t\t  struct fs_parameter *,\n\t\t\t  struct fs_parse_result *);\n \nfs_param_type fs_param_is_bool, fs_param_is_u32, fs_param_is_s32, fs_param_is_u64,\n\tfs_param_is_enum, fs_param_is_string, fs_param_is_blob, fs_param_is_blockdev,\n\tfs_param_is_path, fs_param_is_fd;\n\n \nstruct fs_parameter_spec {\n\tconst char\t\t*name;\n\tfs_param_type\t\t*type;\t \n\tu8\t\t\topt;\t \n\tunsigned short\t\tflags;\n#define fs_param_neg_with_no\t0x0002\t \n#define fs_param_can_be_empty\t0x0004\t \n#define fs_param_deprecated\t0x0008\t \n\tconst void\t\t*data;\n};\n\n \nstruct fs_parse_result {\n\tbool\t\t\tnegated;\t \n\tunion {\n\t\tbool\t\tboolean;\t \n\t\tint\t\tint_32;\t\t \n\t\tunsigned int\tuint_32;\t \n\t\tu64\t\tuint_64;\t \n\t};\n};\n\nextern int __fs_parse(struct p_log *log,\n\t\t    const struct fs_parameter_spec *desc,\n\t\t    struct fs_parameter *value,\n\t\t    struct fs_parse_result *result);\n\nstatic inline int fs_parse(struct fs_context *fc,\n\t     const struct fs_parameter_spec *desc,\n\t     struct fs_parameter *param,\n\t     struct fs_parse_result *result)\n{\n\treturn __fs_parse(&fc->log, desc, param, result);\n}\n\nextern int fs_lookup_param(struct fs_context *fc,\n\t\t\t   struct fs_parameter *param,\n\t\t\t   bool want_bdev,\n\t\t\t   unsigned int flags,\n\t\t\t   struct path *_path);\n\nextern int lookup_constant(const struct constant_table tbl[], const char *name, int not_found);\n\n#ifdef CONFIG_VALIDATE_FS_PARSER\nextern bool validate_constant_table(const struct constant_table *tbl, size_t tbl_size,\n\t\t\t\t    int low, int high, int special);\nextern bool fs_validate_description(const char *name,\n\t\t\t\t    const struct fs_parameter_spec *desc);\n#else\nstatic inline bool validate_constant_table(const struct constant_table *tbl, size_t tbl_size,\n\t\t\t\t\t   int low, int high, int special)\n{ return true; }\nstatic inline bool fs_validate_description(const char *name,\n\t\t\t\t\t   const struct fs_parameter_spec *desc)\n{ return true; }\n#endif\n\n \n#define __fsparam(TYPE, NAME, OPT, FLAGS, DATA) \\\n\t{ \\\n\t\t.name = NAME, \\\n\t\t.opt = OPT, \\\n\t\t.type = TYPE, \\\n\t\t.flags = FLAGS, \\\n\t\t.data = DATA \\\n\t}\n\n#define fsparam_flag(NAME, OPT)\t__fsparam(NULL, NAME, OPT, 0, NULL)\n#define fsparam_flag_no(NAME, OPT) \\\n\t\t\t__fsparam(NULL, NAME, OPT, fs_param_neg_with_no, NULL)\n#define fsparam_bool(NAME, OPT)\t__fsparam(fs_param_is_bool, NAME, OPT, 0, NULL)\n#define fsparam_u32(NAME, OPT)\t__fsparam(fs_param_is_u32, NAME, OPT, 0, NULL)\n#define fsparam_u32oct(NAME, OPT) \\\n\t\t\t__fsparam(fs_param_is_u32, NAME, OPT, 0, (void *)8)\n#define fsparam_u32hex(NAME, OPT) \\\n\t\t\t__fsparam(fs_param_is_u32_hex, NAME, OPT, 0, (void *)16)\n#define fsparam_s32(NAME, OPT)\t__fsparam(fs_param_is_s32, NAME, OPT, 0, NULL)\n#define fsparam_u64(NAME, OPT)\t__fsparam(fs_param_is_u64, NAME, OPT, 0, NULL)\n#define fsparam_enum(NAME, OPT, array)\t__fsparam(fs_param_is_enum, NAME, OPT, 0, array)\n#define fsparam_string(NAME, OPT) \\\n\t\t\t\t__fsparam(fs_param_is_string, NAME, OPT, 0, NULL)\n#define fsparam_blob(NAME, OPT)\t__fsparam(fs_param_is_blob, NAME, OPT, 0, NULL)\n#define fsparam_bdev(NAME, OPT)\t__fsparam(fs_param_is_blockdev, NAME, OPT, 0, NULL)\n#define fsparam_path(NAME, OPT)\t__fsparam(fs_param_is_path, NAME, OPT, 0, NULL)\n#define fsparam_fd(NAME, OPT)\t__fsparam(fs_param_is_fd, NAME, OPT, 0, NULL)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}