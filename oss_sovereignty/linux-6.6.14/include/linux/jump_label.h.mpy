{
  "module_name": "jump_label.h",
  "hash_id": "c96523e3dbba2ea485b852144f17dafdc3cf02e73662448585399db974f700f3",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/jump_label.h",
  "human_readable_source": " \n#ifndef _LINUX_JUMP_LABEL_H\n#define _LINUX_JUMP_LABEL_H\n\n \n\n#ifndef __ASSEMBLY__\n\n#include <linux/types.h>\n#include <linux/compiler.h>\n\nextern bool static_key_initialized;\n\n#define STATIC_KEY_CHECK_USE(key) WARN(!static_key_initialized,\t\t      \\\n\t\t\t\t    \"%s(): static key '%pS' used before call to jump_label_init()\", \\\n\t\t\t\t    __func__, (key))\n\nstruct static_key {\n\tatomic_t enabled;\n#ifdef CONFIG_JUMP_LABEL\n \n\tunion {\n\t\tunsigned long type;\n\t\tstruct jump_entry *entries;\n\t\tstruct static_key_mod *next;\n\t};\n#endif\t \n};\n\n#endif  \n\n#ifdef CONFIG_JUMP_LABEL\n#include <asm/jump_label.h>\n\n#ifndef __ASSEMBLY__\n#ifdef CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE\n\nstruct jump_entry {\n\ts32 code;\n\ts32 target;\n\tlong key;\t\n};\n\nstatic inline unsigned long jump_entry_code(const struct jump_entry *entry)\n{\n\treturn (unsigned long)&entry->code + entry->code;\n}\n\nstatic inline unsigned long jump_entry_target(const struct jump_entry *entry)\n{\n\treturn (unsigned long)&entry->target + entry->target;\n}\n\nstatic inline struct static_key *jump_entry_key(const struct jump_entry *entry)\n{\n\tlong offset = entry->key & ~3L;\n\n\treturn (struct static_key *)((unsigned long)&entry->key + offset);\n}\n\n#else\n\nstatic inline unsigned long jump_entry_code(const struct jump_entry *entry)\n{\n\treturn entry->code;\n}\n\nstatic inline unsigned long jump_entry_target(const struct jump_entry *entry)\n{\n\treturn entry->target;\n}\n\nstatic inline struct static_key *jump_entry_key(const struct jump_entry *entry)\n{\n\treturn (struct static_key *)((unsigned long)entry->key & ~3UL);\n}\n\n#endif\n\nstatic inline bool jump_entry_is_branch(const struct jump_entry *entry)\n{\n\treturn (unsigned long)entry->key & 1UL;\n}\n\nstatic inline bool jump_entry_is_init(const struct jump_entry *entry)\n{\n\treturn (unsigned long)entry->key & 2UL;\n}\n\nstatic inline void jump_entry_set_init(struct jump_entry *entry, bool set)\n{\n\tif (set)\n\t\tentry->key |= 2;\n\telse\n\t\tentry->key &= ~2;\n}\n\nstatic inline int jump_entry_size(struct jump_entry *entry)\n{\n#ifdef JUMP_LABEL_NOP_SIZE\n\treturn JUMP_LABEL_NOP_SIZE;\n#else\n\treturn arch_jump_entry_size(entry);\n#endif\n}\n\n#endif\n#endif\n\n#ifndef __ASSEMBLY__\n\nenum jump_label_type {\n\tJUMP_LABEL_NOP = 0,\n\tJUMP_LABEL_JMP,\n};\n\nstruct module;\n\n#ifdef CONFIG_JUMP_LABEL\n\n#define JUMP_TYPE_FALSE\t\t0UL\n#define JUMP_TYPE_TRUE\t\t1UL\n#define JUMP_TYPE_LINKED\t2UL\n#define JUMP_TYPE_MASK\t\t3UL\n\nstatic __always_inline bool static_key_false(struct static_key *key)\n{\n\treturn arch_static_branch(key, false);\n}\n\nstatic __always_inline bool static_key_true(struct static_key *key)\n{\n\treturn !arch_static_branch(key, true);\n}\n\nextern struct jump_entry __start___jump_table[];\nextern struct jump_entry __stop___jump_table[];\n\nextern void jump_label_init(void);\nextern void jump_label_lock(void);\nextern void jump_label_unlock(void);\nextern void arch_jump_label_transform(struct jump_entry *entry,\n\t\t\t\t      enum jump_label_type type);\nextern bool arch_jump_label_transform_queue(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type);\nextern void arch_jump_label_transform_apply(void);\nextern int jump_label_text_reserved(void *start, void *end);\nextern bool static_key_slow_inc(struct static_key *key);\nextern bool static_key_fast_inc_not_disabled(struct static_key *key);\nextern void static_key_slow_dec(struct static_key *key);\nextern bool static_key_slow_inc_cpuslocked(struct static_key *key);\nextern void static_key_slow_dec_cpuslocked(struct static_key *key);\nextern int static_key_count(struct static_key *key);\nextern void static_key_enable(struct static_key *key);\nextern void static_key_disable(struct static_key *key);\nextern void static_key_enable_cpuslocked(struct static_key *key);\nextern void static_key_disable_cpuslocked(struct static_key *key);\nextern enum jump_label_type jump_label_init_type(struct jump_entry *entry);\n\n \n#define STATIC_KEY_INIT_TRUE\t\t\t\t\t\\\n\t{ .enabled = { 1 },\t\t\t\t\t\\\n\t  { .type = JUMP_TYPE_TRUE } }\n#define STATIC_KEY_INIT_FALSE\t\t\t\t\t\\\n\t{ .enabled = { 0 },\t\t\t\t\t\\\n\t  { .type = JUMP_TYPE_FALSE } }\n\n#else   \n\n#include <linux/atomic.h>\n#include <linux/bug.h>\n\nstatic __always_inline int static_key_count(struct static_key *key)\n{\n\treturn raw_atomic_read(&key->enabled);\n}\n\nstatic __always_inline void jump_label_init(void)\n{\n\tstatic_key_initialized = true;\n}\n\nstatic __always_inline bool static_key_false(struct static_key *key)\n{\n\tif (unlikely_notrace(static_key_count(key) > 0))\n\t\treturn true;\n\treturn false;\n}\n\nstatic __always_inline bool static_key_true(struct static_key *key)\n{\n\tif (likely_notrace(static_key_count(key) > 0))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool static_key_fast_inc_not_disabled(struct static_key *key)\n{\n\tint v;\n\n\tSTATIC_KEY_CHECK_USE(key);\n\t \n\tv = atomic_read(&key->enabled);\n\tdo {\n\t\tif (v < 0 || (v + 1) < 0)\n\t\t\treturn false;\n\t} while (!likely(atomic_try_cmpxchg(&key->enabled, &v, v + 1)));\n\treturn true;\n}\n#define static_key_slow_inc(key)\tstatic_key_fast_inc_not_disabled(key)\n\nstatic inline void static_key_slow_dec(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tatomic_dec(&key->enabled);\n}\n\n#define static_key_slow_inc_cpuslocked(key) static_key_slow_inc(key)\n#define static_key_slow_dec_cpuslocked(key) static_key_slow_dec(key)\n\nstatic inline int jump_label_text_reserved(void *start, void *end)\n{\n\treturn 0;\n}\n\nstatic inline void jump_label_lock(void) {}\nstatic inline void jump_label_unlock(void) {}\n\nstatic inline void static_key_enable(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\n\tif (atomic_read(&key->enabled) != 0) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 1);\n\t\treturn;\n\t}\n\tatomic_set(&key->enabled, 1);\n}\n\nstatic inline void static_key_disable(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\n\tif (atomic_read(&key->enabled) != 1) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 0);\n\t\treturn;\n\t}\n\tatomic_set(&key->enabled, 0);\n}\n\n#define static_key_enable_cpuslocked(k)\t\tstatic_key_enable((k))\n#define static_key_disable_cpuslocked(k)\tstatic_key_disable((k))\n\n#define STATIC_KEY_INIT_TRUE\t{ .enabled = ATOMIC_INIT(1) }\n#define STATIC_KEY_INIT_FALSE\t{ .enabled = ATOMIC_INIT(0) }\n\n#endif\t \n\n#define STATIC_KEY_INIT STATIC_KEY_INIT_FALSE\n#define jump_label_enabled static_key_enabled\n\n \n\n \n\nstruct static_key_true {\n\tstruct static_key key;\n};\n\nstruct static_key_false {\n\tstruct static_key key;\n};\n\n#define STATIC_KEY_TRUE_INIT  (struct static_key_true) { .key = STATIC_KEY_INIT_TRUE,  }\n#define STATIC_KEY_FALSE_INIT (struct static_key_false){ .key = STATIC_KEY_INIT_FALSE, }\n\n#define DEFINE_STATIC_KEY_TRUE(name)\t\\\n\tstruct static_key_true name = STATIC_KEY_TRUE_INIT\n\n#define DEFINE_STATIC_KEY_TRUE_RO(name)\t\\\n\tstruct static_key_true name __ro_after_init = STATIC_KEY_TRUE_INIT\n\n#define DECLARE_STATIC_KEY_TRUE(name)\t\\\n\textern struct static_key_true name\n\n#define DEFINE_STATIC_KEY_FALSE(name)\t\\\n\tstruct static_key_false name = STATIC_KEY_FALSE_INIT\n\n#define DEFINE_STATIC_KEY_FALSE_RO(name)\t\\\n\tstruct static_key_false name __ro_after_init = STATIC_KEY_FALSE_INIT\n\n#define DECLARE_STATIC_KEY_FALSE(name)\t\\\n\textern struct static_key_false name\n\n#define DEFINE_STATIC_KEY_ARRAY_TRUE(name, count)\t\t\\\n\tstruct static_key_true name[count] = {\t\t\t\\\n\t\t[0 ... (count) - 1] = STATIC_KEY_TRUE_INIT,\t\\\n\t}\n\n#define DEFINE_STATIC_KEY_ARRAY_FALSE(name, count)\t\t\\\n\tstruct static_key_false name[count] = {\t\t\t\\\n\t\t[0 ... (count) - 1] = STATIC_KEY_FALSE_INIT,\t\\\n\t}\n\n#define _DEFINE_STATIC_KEY_1(name)\tDEFINE_STATIC_KEY_TRUE(name)\n#define _DEFINE_STATIC_KEY_0(name)\tDEFINE_STATIC_KEY_FALSE(name)\n#define DEFINE_STATIC_KEY_MAYBE(cfg, name)\t\t\t\\\n\t__PASTE(_DEFINE_STATIC_KEY_, IS_ENABLED(cfg))(name)\n\n#define _DEFINE_STATIC_KEY_RO_1(name)\tDEFINE_STATIC_KEY_TRUE_RO(name)\n#define _DEFINE_STATIC_KEY_RO_0(name)\tDEFINE_STATIC_KEY_FALSE_RO(name)\n#define DEFINE_STATIC_KEY_MAYBE_RO(cfg, name)\t\t\t\\\n\t__PASTE(_DEFINE_STATIC_KEY_RO_, IS_ENABLED(cfg))(name)\n\n#define _DECLARE_STATIC_KEY_1(name)\tDECLARE_STATIC_KEY_TRUE(name)\n#define _DECLARE_STATIC_KEY_0(name)\tDECLARE_STATIC_KEY_FALSE(name)\n#define DECLARE_STATIC_KEY_MAYBE(cfg, name)\t\t\t\\\n\t__PASTE(_DECLARE_STATIC_KEY_, IS_ENABLED(cfg))(name)\n\nextern bool ____wrong_branch_error(void);\n\n#define static_key_enabled(x)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tif (!__builtin_types_compatible_p(typeof(*x), struct static_key) &&\t\\\n\t    !__builtin_types_compatible_p(typeof(*x), struct static_key_true) &&\\\n\t    !__builtin_types_compatible_p(typeof(*x), struct static_key_false))\t\\\n\t\t____wrong_branch_error();\t\t\t\t\t\\\n\tstatic_key_count((struct static_key *)x) > 0;\t\t\t\t\\\n})\n\n#ifdef CONFIG_JUMP_LABEL\n\n \n\n#define static_branch_likely(x)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tbool branch;\t\t\t\t\t\t\t\t\\\n\tif (__builtin_types_compatible_p(typeof(*x), struct static_key_true))\t\\\n\t\tbranch = !arch_static_branch(&(x)->key, true);\t\t\t\\\n\telse if (__builtin_types_compatible_p(typeof(*x), struct static_key_false)) \\\n\t\tbranch = !arch_static_branch_jump(&(x)->key, true);\t\t\\\n\telse\t\t\t\t\t\t\t\t\t\\\n\t\tbranch = ____wrong_branch_error();\t\t\t\t\\\n\tlikely_notrace(branch);\t\t\t\t\t\t\t\t\\\n})\n\n#define static_branch_unlikely(x)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tbool branch;\t\t\t\t\t\t\t\t\\\n\tif (__builtin_types_compatible_p(typeof(*x), struct static_key_true))\t\\\n\t\tbranch = arch_static_branch_jump(&(x)->key, false);\t\t\\\n\telse if (__builtin_types_compatible_p(typeof(*x), struct static_key_false)) \\\n\t\tbranch = arch_static_branch(&(x)->key, false);\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\t\\\n\t\tbranch = ____wrong_branch_error();\t\t\t\t\\\n\tunlikely_notrace(branch);\t\t\t\t\t\t\t\\\n})\n\n#else  \n\n#define static_branch_likely(x)\t\tlikely_notrace(static_key_enabled(&(x)->key))\n#define static_branch_unlikely(x)\tunlikely_notrace(static_key_enabled(&(x)->key))\n\n#endif  \n\n#define static_branch_maybe(config, x)\t\t\t\t\t\\\n\t(IS_ENABLED(config) ? static_branch_likely(x)\t\t\t\\\n\t\t\t    : static_branch_unlikely(x))\n\n \n\n#define static_branch_inc(x)\t\tstatic_key_slow_inc(&(x)->key)\n#define static_branch_dec(x)\t\tstatic_key_slow_dec(&(x)->key)\n#define static_branch_inc_cpuslocked(x)\tstatic_key_slow_inc_cpuslocked(&(x)->key)\n#define static_branch_dec_cpuslocked(x)\tstatic_key_slow_dec_cpuslocked(&(x)->key)\n\n \n\n#define static_branch_enable(x)\t\t\tstatic_key_enable(&(x)->key)\n#define static_branch_disable(x)\t\tstatic_key_disable(&(x)->key)\n#define static_branch_enable_cpuslocked(x)\tstatic_key_enable_cpuslocked(&(x)->key)\n#define static_branch_disable_cpuslocked(x)\tstatic_key_disable_cpuslocked(&(x)->key)\n\n#endif  \n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}