{
  "module_name": "mempool.h",
  "hash_id": "b033047431a0d05373dfd7f0fae09563af005ad76734fa2907409463dbd31be6",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mempool.h",
  "human_readable_source": " \n \n#ifndef _LINUX_MEMPOOL_H\n#define _LINUX_MEMPOOL_H\n\n#include <linux/wait.h>\n#include <linux/compiler.h>\n\nstruct kmem_cache;\n\ntypedef void * (mempool_alloc_t)(gfp_t gfp_mask, void *pool_data);\ntypedef void (mempool_free_t)(void *element, void *pool_data);\n\ntypedef struct mempool_s {\n\tspinlock_t lock;\n\tint min_nr;\t\t \n\tint curr_nr;\t\t \n\tvoid **elements;\n\n\tvoid *pool_data;\n\tmempool_alloc_t *alloc;\n\tmempool_free_t *free;\n\twait_queue_head_t wait;\n} mempool_t;\n\nstatic inline bool mempool_initialized(mempool_t *pool)\n{\n\treturn pool->elements != NULL;\n}\n\nstatic inline bool mempool_is_saturated(mempool_t *pool)\n{\n\treturn READ_ONCE(pool->curr_nr) >= pool->min_nr;\n}\n\nvoid mempool_exit(mempool_t *pool);\nint mempool_init_node(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,\n\t\t      mempool_free_t *free_fn, void *pool_data,\n\t\t      gfp_t gfp_mask, int node_id);\nint mempool_init(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn,\n\t\t mempool_free_t *free_fn, void *pool_data);\n\nextern mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn,\n\t\t\tmempool_free_t *free_fn, void *pool_data);\nextern mempool_t *mempool_create_node(int min_nr, mempool_alloc_t *alloc_fn,\n\t\t\tmempool_free_t *free_fn, void *pool_data,\n\t\t\tgfp_t gfp_mask, int nid);\n\nextern int mempool_resize(mempool_t *pool, int new_min_nr);\nextern void mempool_destroy(mempool_t *pool);\nextern void *mempool_alloc(mempool_t *pool, gfp_t gfp_mask) __malloc;\nextern void mempool_free(void *element, mempool_t *pool);\n\n \nvoid *mempool_alloc_slab(gfp_t gfp_mask, void *pool_data);\nvoid mempool_free_slab(void *element, void *pool_data);\n\nstatic inline int\nmempool_init_slab_pool(mempool_t *pool, int min_nr, struct kmem_cache *kc)\n{\n\treturn mempool_init(pool, min_nr, mempool_alloc_slab,\n\t\t\t    mempool_free_slab, (void *) kc);\n}\n\nstatic inline mempool_t *\nmempool_create_slab_pool(int min_nr, struct kmem_cache *kc)\n{\n\treturn mempool_create(min_nr, mempool_alloc_slab, mempool_free_slab,\n\t\t\t      (void *) kc);\n}\n\n \nvoid *mempool_kmalloc(gfp_t gfp_mask, void *pool_data);\nvoid mempool_kfree(void *element, void *pool_data);\n\nstatic inline int mempool_init_kmalloc_pool(mempool_t *pool, int min_nr, size_t size)\n{\n\treturn mempool_init(pool, min_nr, mempool_kmalloc,\n\t\t\t    mempool_kfree, (void *) size);\n}\n\nstatic inline mempool_t *mempool_create_kmalloc_pool(int min_nr, size_t size)\n{\n\treturn mempool_create(min_nr, mempool_kmalloc, mempool_kfree,\n\t\t\t      (void *) size);\n}\n\n \nvoid *mempool_alloc_pages(gfp_t gfp_mask, void *pool_data);\nvoid mempool_free_pages(void *element, void *pool_data);\n\nstatic inline int mempool_init_page_pool(mempool_t *pool, int min_nr, int order)\n{\n\treturn mempool_init(pool, min_nr, mempool_alloc_pages,\n\t\t\t    mempool_free_pages, (void *)(long)order);\n}\n\nstatic inline mempool_t *mempool_create_page_pool(int min_nr, int order)\n{\n\treturn mempool_create(min_nr, mempool_alloc_pages, mempool_free_pages,\n\t\t\t      (void *)(long)order);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}