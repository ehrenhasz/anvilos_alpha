{
  "module_name": "ntb.h",
  "hash_id": "08857d74edb94e347b60e877f197024aacdbea866046f22e80176ef470666afe",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ntb.h",
  "human_readable_source": " \n\n#ifndef _NTB_H_\n#define _NTB_H_\n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n\nstruct ntb_client;\nstruct ntb_dev;\nstruct ntb_msi;\nstruct pci_dev;\n\n \nenum ntb_topo {\n\tNTB_TOPO_NONE = -1,\n\tNTB_TOPO_PRI,\n\tNTB_TOPO_SEC,\n\tNTB_TOPO_B2B_USD,\n\tNTB_TOPO_B2B_DSD,\n\tNTB_TOPO_SWITCH,\n\tNTB_TOPO_CROSSLINK,\n};\n\nstatic inline int ntb_topo_is_b2b(enum ntb_topo topo)\n{\n\tswitch ((int)topo) {\n\tcase NTB_TOPO_B2B_USD:\n\tcase NTB_TOPO_B2B_DSD:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline char *ntb_topo_string(enum ntb_topo topo)\n{\n\tswitch (topo) {\n\tcase NTB_TOPO_NONE:\t\treturn \"NTB_TOPO_NONE\";\n\tcase NTB_TOPO_PRI:\t\treturn \"NTB_TOPO_PRI\";\n\tcase NTB_TOPO_SEC:\t\treturn \"NTB_TOPO_SEC\";\n\tcase NTB_TOPO_B2B_USD:\t\treturn \"NTB_TOPO_B2B_USD\";\n\tcase NTB_TOPO_B2B_DSD:\t\treturn \"NTB_TOPO_B2B_DSD\";\n\tcase NTB_TOPO_SWITCH:\t\treturn \"NTB_TOPO_SWITCH\";\n\tcase NTB_TOPO_CROSSLINK:\treturn \"NTB_TOPO_CROSSLINK\";\n\t}\n\treturn \"NTB_TOPO_INVALID\";\n}\n\n \nenum ntb_speed {\n\tNTB_SPEED_AUTO = -1,\n\tNTB_SPEED_NONE = 0,\n\tNTB_SPEED_GEN1 = 1,\n\tNTB_SPEED_GEN2 = 2,\n\tNTB_SPEED_GEN3 = 3,\n\tNTB_SPEED_GEN4 = 4\n};\n\n \nenum ntb_width {\n\tNTB_WIDTH_AUTO = -1,\n\tNTB_WIDTH_NONE = 0,\n\tNTB_WIDTH_1 = 1,\n\tNTB_WIDTH_2 = 2,\n\tNTB_WIDTH_4 = 4,\n\tNTB_WIDTH_8 = 8,\n\tNTB_WIDTH_12 = 12,\n\tNTB_WIDTH_16 = 16,\n\tNTB_WIDTH_32 = 32,\n};\n\n \nenum ntb_default_port {\n\tNTB_PORT_PRI_USD,\n\tNTB_PORT_SEC_DSD\n};\n#define NTB_DEF_PEER_CNT\t(1)\n#define NTB_DEF_PEER_IDX\t(0)\n\n \nstruct ntb_client_ops {\n\tint (*probe)(struct ntb_client *client, struct ntb_dev *ntb);\n\tvoid (*remove)(struct ntb_client *client, struct ntb_dev *ntb);\n};\n\nstatic inline int ntb_client_ops_is_valid(const struct ntb_client_ops *ops)\n{\n\t \n\treturn\n\t\tops->probe\t\t\t&&\n\t\tops->remove\t\t\t&&\n\t\t1;\n}\n\n \nstruct ntb_ctx_ops {\n\tvoid (*link_event)(void *ctx);\n\tvoid (*db_event)(void *ctx, int db_vector);\n\tvoid (*msg_event)(void *ctx);\n};\n\nstatic inline int ntb_ctx_ops_is_valid(const struct ntb_ctx_ops *ops)\n{\n\t \n\treturn\n\t\t \n\t\t \n\t\t \n\t\t1;\n}\n\n \nstruct ntb_dev_ops {\n\tint (*port_number)(struct ntb_dev *ntb);\n\tint (*peer_port_count)(struct ntb_dev *ntb);\n\tint (*peer_port_number)(struct ntb_dev *ntb, int pidx);\n\tint (*peer_port_idx)(struct ntb_dev *ntb, int port);\n\n\tu64 (*link_is_up)(struct ntb_dev *ntb,\n\t\t\t  enum ntb_speed *speed, enum ntb_width *width);\n\tint (*link_enable)(struct ntb_dev *ntb,\n\t\t\t   enum ntb_speed max_speed, enum ntb_width max_width);\n\tint (*link_disable)(struct ntb_dev *ntb);\n\n\tint (*mw_count)(struct ntb_dev *ntb, int pidx);\n\tint (*mw_get_align)(struct ntb_dev *ntb, int pidx, int widx,\n\t\t\t    resource_size_t *addr_align,\n\t\t\t    resource_size_t *size_align,\n\t\t\t    resource_size_t *size_max);\n\tint (*mw_set_trans)(struct ntb_dev *ntb, int pidx, int widx,\n\t\t\t    dma_addr_t addr, resource_size_t size);\n\tint (*mw_clear_trans)(struct ntb_dev *ntb, int pidx, int widx);\n\tint (*peer_mw_count)(struct ntb_dev *ntb);\n\tint (*peer_mw_get_addr)(struct ntb_dev *ntb, int widx,\n\t\t\t\tphys_addr_t *base, resource_size_t *size);\n\tint (*peer_mw_set_trans)(struct ntb_dev *ntb, int pidx, int widx,\n\t\t\t\t u64 addr, resource_size_t size);\n\tint (*peer_mw_clear_trans)(struct ntb_dev *ntb, int pidx, int widx);\n\n\tint (*db_is_unsafe)(struct ntb_dev *ntb);\n\tu64 (*db_valid_mask)(struct ntb_dev *ntb);\n\tint (*db_vector_count)(struct ntb_dev *ntb);\n\tu64 (*db_vector_mask)(struct ntb_dev *ntb, int db_vector);\n\n\tu64 (*db_read)(struct ntb_dev *ntb);\n\tint (*db_set)(struct ntb_dev *ntb, u64 db_bits);\n\tint (*db_clear)(struct ntb_dev *ntb, u64 db_bits);\n\n\tu64 (*db_read_mask)(struct ntb_dev *ntb);\n\tint (*db_set_mask)(struct ntb_dev *ntb, u64 db_bits);\n\tint (*db_clear_mask)(struct ntb_dev *ntb, u64 db_bits);\n\n\tint (*peer_db_addr)(struct ntb_dev *ntb,\n\t\t\t    phys_addr_t *db_addr, resource_size_t *db_size,\n\t\t\t\tu64 *db_data, int db_bit);\n\tu64 (*peer_db_read)(struct ntb_dev *ntb);\n\tint (*peer_db_set)(struct ntb_dev *ntb, u64 db_bits);\n\tint (*peer_db_clear)(struct ntb_dev *ntb, u64 db_bits);\n\n\tu64 (*peer_db_read_mask)(struct ntb_dev *ntb);\n\tint (*peer_db_set_mask)(struct ntb_dev *ntb, u64 db_bits);\n\tint (*peer_db_clear_mask)(struct ntb_dev *ntb, u64 db_bits);\n\n\tint (*spad_is_unsafe)(struct ntb_dev *ntb);\n\tint (*spad_count)(struct ntb_dev *ntb);\n\n\tu32 (*spad_read)(struct ntb_dev *ntb, int sidx);\n\tint (*spad_write)(struct ntb_dev *ntb, int sidx, u32 val);\n\n\tint (*peer_spad_addr)(struct ntb_dev *ntb, int pidx, int sidx,\n\t\t\t      phys_addr_t *spad_addr);\n\tu32 (*peer_spad_read)(struct ntb_dev *ntb, int pidx, int sidx);\n\tint (*peer_spad_write)(struct ntb_dev *ntb, int pidx, int sidx,\n\t\t\t       u32 val);\n\n\tint (*msg_count)(struct ntb_dev *ntb);\n\tu64 (*msg_inbits)(struct ntb_dev *ntb);\n\tu64 (*msg_outbits)(struct ntb_dev *ntb);\n\tu64 (*msg_read_sts)(struct ntb_dev *ntb);\n\tint (*msg_clear_sts)(struct ntb_dev *ntb, u64 sts_bits);\n\tint (*msg_set_mask)(struct ntb_dev *ntb, u64 mask_bits);\n\tint (*msg_clear_mask)(struct ntb_dev *ntb, u64 mask_bits);\n\tu32 (*msg_read)(struct ntb_dev *ntb, int *pidx, int midx);\n\tint (*peer_msg_write)(struct ntb_dev *ntb, int pidx, int midx, u32 msg);\n};\n\nstatic inline int ntb_dev_ops_is_valid(const struct ntb_dev_ops *ops)\n{\n\t \n\treturn\n\t\t \n\t\t!ops->peer_port_count == !ops->port_number\t&&\n\t\t!ops->peer_port_number == !ops->port_number\t&&\n\t\t!ops->peer_port_idx == !ops->port_number\t&&\n\n\t\t \n\t\tops->link_is_up\t\t\t\t&&\n\t\tops->link_enable\t\t\t&&\n\t\tops->link_disable\t\t\t&&\n\n\t\t \n\t\tops->mw_count\t\t\t\t&&\n\t\tops->mw_get_align\t\t\t&&\n\t\t(ops->mw_set_trans\t\t\t||\n\t\t ops->peer_mw_set_trans)\t\t&&\n\t\t \n\t\tops->peer_mw_count\t\t\t&&\n\t\tops->peer_mw_get_addr\t\t\t&&\n\t\t \n\n\t\t \n\t\t \n\t\tops->db_valid_mask\t\t\t&&\n\t\t \n\t\t(!ops->db_vector_count == !ops->db_vector_mask)\t&&\n\t\tops->db_read\t\t\t\t&&\n\t\t \n\t\tops->db_clear\t\t\t\t&&\n\t\t \n\t\tops->db_set_mask\t\t\t&&\n\t\tops->db_clear_mask\t\t\t&&\n\t\t \n\t\t \n\t\tops->peer_db_set\t\t\t&&\n\t\t \n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\t \n\t\t!ops->spad_read == !ops->spad_count\t\t&&\n\t\t!ops->spad_write == !ops->spad_count\t\t&&\n\t\t \n\t\t \n\t\t!ops->peer_spad_write == !ops->spad_count\t&&\n\n\t\t \n\t\t!ops->msg_inbits == !ops->msg_count\t\t&&\n\t\t!ops->msg_outbits == !ops->msg_count\t\t&&\n\t\t!ops->msg_read_sts == !ops->msg_count\t\t&&\n\t\t!ops->msg_clear_sts == !ops->msg_count\t\t&&\n\t\t \n\t\t \n\t\t!ops->msg_read == !ops->msg_count\t\t&&\n\t\t!ops->peer_msg_write == !ops->msg_count\t\t&&\n\t\t1;\n}\n\n \nstruct ntb_client {\n\tstruct device_driver\t\tdrv;\n\tconst struct ntb_client_ops\tops;\n};\n#define drv_ntb_client(__drv) container_of((__drv), struct ntb_client, drv)\n\n \nstruct ntb_dev {\n\tstruct device\t\t\tdev;\n\tstruct pci_dev\t\t\t*pdev;\n\tenum ntb_topo\t\t\ttopo;\n\tconst struct ntb_dev_ops\t*ops;\n\tvoid\t\t\t\t*ctx;\n\tconst struct ntb_ctx_ops\t*ctx_ops;\n\n\t \n\n\t \n\tspinlock_t\t\t\tctx_lock;\n\t \n\tstruct completion\t\treleased;\n\n#ifdef CONFIG_NTB_MSI\n\tstruct ntb_msi *msi;\n#endif\n};\n#define dev_ntb(__dev) container_of((__dev), struct ntb_dev, dev)\n\n \n#define ntb_register_client(client) \\\n\t__ntb_register_client((client), THIS_MODULE, KBUILD_MODNAME)\n\nint __ntb_register_client(struct ntb_client *client, struct module *mod,\n\t\t\t  const char *mod_name);\n\n \nvoid ntb_unregister_client(struct ntb_client *client);\n\n#define module_ntb_client(__ntb_client) \\\n\tmodule_driver(__ntb_client, ntb_register_client, \\\n\t\t\tntb_unregister_client)\n\n \nint ntb_register_device(struct ntb_dev *ntb);\n\n \nvoid ntb_unregister_device(struct ntb_dev *ntb);\n\n \nint ntb_set_ctx(struct ntb_dev *ntb, void *ctx,\n\t\tconst struct ntb_ctx_ops *ctx_ops);\n\n \nvoid ntb_clear_ctx(struct ntb_dev *ntb);\n\n \nvoid ntb_link_event(struct ntb_dev *ntb);\n\n \nvoid ntb_db_event(struct ntb_dev *ntb, int vector);\n\n \nvoid ntb_msg_event(struct ntb_dev *ntb);\n\n \nint ntb_default_port_number(struct ntb_dev *ntb);\n\n \nint ntb_default_peer_port_count(struct ntb_dev *ntb);\n\n \nint ntb_default_peer_port_number(struct ntb_dev *ntb, int pidx);\n\n \nint ntb_default_peer_port_idx(struct ntb_dev *ntb, int port);\n\n \nstatic inline int ntb_port_number(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->port_number)\n\t\treturn ntb_default_port_number(ntb);\n\n\treturn ntb->ops->port_number(ntb);\n}\n \nstatic inline int ntb_peer_port_count(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->peer_port_count)\n\t\treturn ntb_default_peer_port_count(ntb);\n\n\treturn ntb->ops->peer_port_count(ntb);\n}\n\n \nstatic inline int ntb_peer_port_number(struct ntb_dev *ntb, int pidx)\n{\n\tif (!ntb->ops->peer_port_number)\n\t\treturn ntb_default_peer_port_number(ntb, pidx);\n\n\treturn ntb->ops->peer_port_number(ntb, pidx);\n}\n\n \nstatic inline int ntb_logical_port_number(struct ntb_dev *ntb)\n{\n\tint lport = ntb_port_number(ntb);\n\tint pidx;\n\n\tif (lport < 0)\n\t\treturn lport;\n\n\tfor (pidx = 0; pidx < ntb_peer_port_count(ntb); pidx++)\n\t\tif (lport <= ntb_peer_port_number(ntb, pidx))\n\t\t\treturn pidx;\n\n\treturn pidx;\n}\n\n \nstatic inline int ntb_peer_logical_port_number(struct ntb_dev *ntb, int pidx)\n{\n\tif (ntb_peer_port_number(ntb, pidx) < ntb_port_number(ntb))\n\t\treturn pidx;\n\telse\n\t\treturn pidx + 1;\n}\n\n \nstatic inline int ntb_peer_port_idx(struct ntb_dev *ntb, int port)\n{\n\tif (!ntb->ops->peer_port_idx)\n\t\treturn ntb_default_peer_port_idx(ntb, port);\n\n\treturn ntb->ops->peer_port_idx(ntb, port);\n}\n\n \nstatic inline u64 ntb_link_is_up(struct ntb_dev *ntb,\n\t\t\t\t enum ntb_speed *speed, enum ntb_width *width)\n{\n\treturn ntb->ops->link_is_up(ntb, speed, width);\n}\n\n \nstatic inline int ntb_link_enable(struct ntb_dev *ntb,\n\t\t\t\t  enum ntb_speed max_speed,\n\t\t\t\t  enum ntb_width max_width)\n{\n\treturn ntb->ops->link_enable(ntb, max_speed, max_width);\n}\n\n \nstatic inline int ntb_link_disable(struct ntb_dev *ntb)\n{\n\treturn ntb->ops->link_disable(ntb);\n}\n\n \nstatic inline int ntb_mw_count(struct ntb_dev *ntb, int pidx)\n{\n\treturn ntb->ops->mw_count(ntb, pidx);\n}\n\n \nstatic inline int ntb_mw_get_align(struct ntb_dev *ntb, int pidx, int widx,\n\t\t\t\t   resource_size_t *addr_align,\n\t\t\t\t   resource_size_t *size_align,\n\t\t\t\t   resource_size_t *size_max)\n{\n\tif (!(ntb_link_is_up(ntb, NULL, NULL) & BIT_ULL(pidx)))\n\t\treturn -ENOTCONN;\n\n\treturn ntb->ops->mw_get_align(ntb, pidx, widx, addr_align, size_align,\n\t\t\t\t      size_max);\n}\n\n \nstatic inline int ntb_mw_set_trans(struct ntb_dev *ntb, int pidx, int widx,\n\t\t\t\t   dma_addr_t addr, resource_size_t size)\n{\n\tif (!ntb->ops->mw_set_trans)\n\t\treturn 0;\n\n\treturn ntb->ops->mw_set_trans(ntb, pidx, widx, addr, size);\n}\n\n \nstatic inline int ntb_mw_clear_trans(struct ntb_dev *ntb, int pidx, int widx)\n{\n\tif (!ntb->ops->mw_clear_trans)\n\t\treturn ntb_mw_set_trans(ntb, pidx, widx, 0, 0);\n\n\treturn ntb->ops->mw_clear_trans(ntb, pidx, widx);\n}\n\n \nstatic inline int ntb_peer_mw_count(struct ntb_dev *ntb)\n{\n\treturn ntb->ops->peer_mw_count(ntb);\n}\n\n \nstatic inline int ntb_peer_mw_get_addr(struct ntb_dev *ntb, int widx,\n\t\t\t\t      phys_addr_t *base, resource_size_t *size)\n{\n\treturn ntb->ops->peer_mw_get_addr(ntb, widx, base, size);\n}\n\n \nstatic inline int ntb_peer_mw_set_trans(struct ntb_dev *ntb, int pidx, int widx,\n\t\t\t\t\tu64 addr, resource_size_t size)\n{\n\tif (!ntb->ops->peer_mw_set_trans)\n\t\treturn 0;\n\n\treturn ntb->ops->peer_mw_set_trans(ntb, pidx, widx, addr, size);\n}\n\n \nstatic inline int ntb_peer_mw_clear_trans(struct ntb_dev *ntb, int pidx,\n\t\t\t\t\t  int widx)\n{\n\tif (!ntb->ops->peer_mw_clear_trans)\n\t\treturn ntb_peer_mw_set_trans(ntb, pidx, widx, 0, 0);\n\n\treturn ntb->ops->peer_mw_clear_trans(ntb, pidx, widx);\n}\n\n \nstatic inline int ntb_db_is_unsafe(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->db_is_unsafe)\n\t\treturn 0;\n\n\treturn ntb->ops->db_is_unsafe(ntb);\n}\n\n \nstatic inline u64 ntb_db_valid_mask(struct ntb_dev *ntb)\n{\n\treturn ntb->ops->db_valid_mask(ntb);\n}\n\n \nstatic inline int ntb_db_vector_count(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->db_vector_count)\n\t\treturn 1;\n\n\treturn ntb->ops->db_vector_count(ntb);\n}\n\n \nstatic inline u64 ntb_db_vector_mask(struct ntb_dev *ntb, int vector)\n{\n\tif (!ntb->ops->db_vector_mask)\n\t\treturn ntb_db_valid_mask(ntb);\n\n\treturn ntb->ops->db_vector_mask(ntb, vector);\n}\n\n \nstatic inline u64 ntb_db_read(struct ntb_dev *ntb)\n{\n\treturn ntb->ops->db_read(ntb);\n}\n\n \nstatic inline int ntb_db_set(struct ntb_dev *ntb, u64 db_bits)\n{\n\tif (!ntb->ops->db_set)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->db_set(ntb, db_bits);\n}\n\n \nstatic inline int ntb_db_clear(struct ntb_dev *ntb, u64 db_bits)\n{\n\treturn ntb->ops->db_clear(ntb, db_bits);\n}\n\n \nstatic inline u64 ntb_db_read_mask(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->db_read_mask)\n\t\treturn 0;\n\n\treturn ntb->ops->db_read_mask(ntb);\n}\n\n \nstatic inline int ntb_db_set_mask(struct ntb_dev *ntb, u64 db_bits)\n{\n\treturn ntb->ops->db_set_mask(ntb, db_bits);\n}\n\n \nstatic inline int ntb_db_clear_mask(struct ntb_dev *ntb, u64 db_bits)\n{\n\treturn ntb->ops->db_clear_mask(ntb, db_bits);\n}\n\n \nstatic inline int ntb_peer_db_addr(struct ntb_dev *ntb,\n\t\t\t\t   phys_addr_t *db_addr,\n\t\t\t\t   resource_size_t *db_size,\n\t\t\t\t   u64 *db_data, int db_bit)\n{\n\tif (!ntb->ops->peer_db_addr)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->peer_db_addr(ntb, db_addr, db_size, db_data, db_bit);\n}\n\n \nstatic inline u64 ntb_peer_db_read(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->peer_db_read)\n\t\treturn 0;\n\n\treturn ntb->ops->peer_db_read(ntb);\n}\n\n \nstatic inline int ntb_peer_db_set(struct ntb_dev *ntb, u64 db_bits)\n{\n\treturn ntb->ops->peer_db_set(ntb, db_bits);\n}\n\n \nstatic inline int ntb_peer_db_clear(struct ntb_dev *ntb, u64 db_bits)\n{\n\tif (!ntb->ops->db_clear)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->peer_db_clear(ntb, db_bits);\n}\n\n \nstatic inline u64 ntb_peer_db_read_mask(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->db_read_mask)\n\t\treturn 0;\n\n\treturn ntb->ops->peer_db_read_mask(ntb);\n}\n\n \nstatic inline int ntb_peer_db_set_mask(struct ntb_dev *ntb, u64 db_bits)\n{\n\tif (!ntb->ops->db_set_mask)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->peer_db_set_mask(ntb, db_bits);\n}\n\n \nstatic inline int ntb_peer_db_clear_mask(struct ntb_dev *ntb, u64 db_bits)\n{\n\tif (!ntb->ops->db_clear_mask)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->peer_db_clear_mask(ntb, db_bits);\n}\n\n \nstatic inline int ntb_spad_is_unsafe(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->spad_is_unsafe)\n\t\treturn 0;\n\n\treturn ntb->ops->spad_is_unsafe(ntb);\n}\n\n \nstatic inline int ntb_spad_count(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->spad_count)\n\t\treturn 0;\n\n\treturn ntb->ops->spad_count(ntb);\n}\n\n \nstatic inline u32 ntb_spad_read(struct ntb_dev *ntb, int sidx)\n{\n\tif (!ntb->ops->spad_read)\n\t\treturn ~(u32)0;\n\n\treturn ntb->ops->spad_read(ntb, sidx);\n}\n\n \nstatic inline int ntb_spad_write(struct ntb_dev *ntb, int sidx, u32 val)\n{\n\tif (!ntb->ops->spad_write)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->spad_write(ntb, sidx, val);\n}\n\n \nstatic inline int ntb_peer_spad_addr(struct ntb_dev *ntb, int pidx, int sidx,\n\t\t\t\t     phys_addr_t *spad_addr)\n{\n\tif (!ntb->ops->peer_spad_addr)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->peer_spad_addr(ntb, pidx, sidx, spad_addr);\n}\n\n \nstatic inline u32 ntb_peer_spad_read(struct ntb_dev *ntb, int pidx, int sidx)\n{\n\tif (!ntb->ops->peer_spad_read)\n\t\treturn ~(u32)0;\n\n\treturn ntb->ops->peer_spad_read(ntb, pidx, sidx);\n}\n\n \nstatic inline int ntb_peer_spad_write(struct ntb_dev *ntb, int pidx, int sidx,\n\t\t\t\t      u32 val)\n{\n\tif (!ntb->ops->peer_spad_write)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->peer_spad_write(ntb, pidx, sidx, val);\n}\n\n \nstatic inline int ntb_msg_count(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->msg_count)\n\t\treturn 0;\n\n\treturn ntb->ops->msg_count(ntb);\n}\n\n \nstatic inline u64 ntb_msg_inbits(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->msg_inbits)\n\t\treturn 0;\n\n\treturn ntb->ops->msg_inbits(ntb);\n}\n\n \nstatic inline u64 ntb_msg_outbits(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->msg_outbits)\n\t\treturn 0;\n\n\treturn ntb->ops->msg_outbits(ntb);\n}\n\n \nstatic inline u64 ntb_msg_read_sts(struct ntb_dev *ntb)\n{\n\tif (!ntb->ops->msg_read_sts)\n\t\treturn 0;\n\n\treturn ntb->ops->msg_read_sts(ntb);\n}\n\n \nstatic inline int ntb_msg_clear_sts(struct ntb_dev *ntb, u64 sts_bits)\n{\n\tif (!ntb->ops->msg_clear_sts)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->msg_clear_sts(ntb, sts_bits);\n}\n\n \nstatic inline int ntb_msg_set_mask(struct ntb_dev *ntb, u64 mask_bits)\n{\n\tif (!ntb->ops->msg_set_mask)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->msg_set_mask(ntb, mask_bits);\n}\n\n \nstatic inline int ntb_msg_clear_mask(struct ntb_dev *ntb, u64 mask_bits)\n{\n\tif (!ntb->ops->msg_clear_mask)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->msg_clear_mask(ntb, mask_bits);\n}\n\n \nstatic inline u32 ntb_msg_read(struct ntb_dev *ntb, int *pidx, int midx)\n{\n\tif (!ntb->ops->msg_read)\n\t\treturn ~(u32)0;\n\n\treturn ntb->ops->msg_read(ntb, pidx, midx);\n}\n\n \nstatic inline int ntb_peer_msg_write(struct ntb_dev *ntb, int pidx, int midx,\n\t\t\t\t     u32 msg)\n{\n\tif (!ntb->ops->peer_msg_write)\n\t\treturn -EINVAL;\n\n\treturn ntb->ops->peer_msg_write(ntb, pidx, midx, msg);\n}\n\n \nstatic inline int ntb_peer_resource_idx(struct ntb_dev *ntb, int pidx)\n{\n\tint local_port, peer_port;\n\n\tif (pidx >= ntb_peer_port_count(ntb))\n\t\treturn -EINVAL;\n\n\tlocal_port = ntb_logical_port_number(ntb);\n\tpeer_port = ntb_peer_logical_port_number(ntb, pidx);\n\n\tif (peer_port < local_port)\n\t\treturn local_port - 1;\n\telse\n\t\treturn local_port;\n}\n\n \nstatic inline int ntb_peer_highest_mw_idx(struct ntb_dev *ntb, int pidx)\n{\n\tint ret;\n\n\tret = ntb_peer_resource_idx(ntb, pidx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ntb_mw_count(ntb, pidx) - ret - 1;\n}\n\nstruct ntb_msi_desc {\n\tu32 addr_offset;\n\tu32 data;\n};\n\n#ifdef CONFIG_NTB_MSI\n\nint ntb_msi_init(struct ntb_dev *ntb, void (*desc_changed)(void *ctx));\nint ntb_msi_setup_mws(struct ntb_dev *ntb);\nvoid ntb_msi_clear_mws(struct ntb_dev *ntb);\nint ntbm_msi_request_threaded_irq(struct ntb_dev *ntb, irq_handler_t handler,\n\t\t\t\t  irq_handler_t thread_fn,\n\t\t\t\t  const char *name, void *dev_id,\n\t\t\t\t  struct ntb_msi_desc *msi_desc);\nvoid ntbm_msi_free_irq(struct ntb_dev *ntb, unsigned int irq, void *dev_id);\nint ntb_msi_peer_trigger(struct ntb_dev *ntb, int peer,\n\t\t\t struct ntb_msi_desc *desc);\nint ntb_msi_peer_addr(struct ntb_dev *ntb, int peer,\n\t\t      struct ntb_msi_desc *desc,\n\t\t      phys_addr_t *msi_addr);\n\n#else  \n\nstatic inline int ntb_msi_init(struct ntb_dev *ntb,\n\t\t\t       void (*desc_changed)(void *ctx))\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int ntb_msi_setup_mws(struct ntb_dev *ntb)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline void ntb_msi_clear_mws(struct ntb_dev *ntb) {}\nstatic inline int ntbm_msi_request_threaded_irq(struct ntb_dev *ntb,\n\t\t\t\t\t\tirq_handler_t handler,\n\t\t\t\t\t\tirq_handler_t thread_fn,\n\t\t\t\t\t\tconst char *name, void *dev_id,\n\t\t\t\t\t\tstruct ntb_msi_desc *msi_desc)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline void ntbm_msi_free_irq(struct ntb_dev *ntb, unsigned int irq,\n\t\t\t\t     void *dev_id) {}\nstatic inline int ntb_msi_peer_trigger(struct ntb_dev *ntb, int peer,\n\t\t\t\t       struct ntb_msi_desc *desc)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline int ntb_msi_peer_addr(struct ntb_dev *ntb, int peer,\n\t\t\t\t    struct ntb_msi_desc *desc,\n\t\t\t\t    phys_addr_t *msi_addr)\n{\n\treturn -EOPNOTSUPP;\n\n}\n\n#endif  \n\nstatic inline int ntbm_msi_request_irq(struct ntb_dev *ntb,\n\t\t\t\t       irq_handler_t handler,\n\t\t\t\t       const char *name, void *dev_id,\n\t\t\t\t       struct ntb_msi_desc *msi_desc)\n{\n\treturn ntbm_msi_request_threaded_irq(ntb, handler, NULL, name,\n\t\t\t\t\t     dev_id, msi_desc);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}