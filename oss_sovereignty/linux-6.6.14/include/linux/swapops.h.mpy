{
  "module_name": "swapops.h",
  "hash_id": "ccbf73c6df3d4c377b6e1fcf67d6b791053be2af215aabf36504fe78abbeefe3",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/swapops.h",
  "human_readable_source": " \n#ifndef _LINUX_SWAPOPS_H\n#define _LINUX_SWAPOPS_H\n\n#include <linux/radix-tree.h>\n#include <linux/bug.h>\n#include <linux/mm_types.h>\n\n#ifdef CONFIG_MMU\n\n#ifdef CONFIG_SWAP\n#include <linux/swapfile.h>\n#endif\t \n\n \n#define SWP_TYPE_SHIFT\t(BITS_PER_XA_VALUE - MAX_SWAPFILES_SHIFT)\n#define SWP_OFFSET_MASK\t((1UL << SWP_TYPE_SHIFT) - 1)\n\n \n#ifdef MAX_PHYSMEM_BITS\n#define SWP_PFN_BITS\t\t(MAX_PHYSMEM_BITS - PAGE_SHIFT)\n#else   \n#define SWP_PFN_BITS\t\tmin_t(int, \\\n\t\t\t\t      sizeof(phys_addr_t) * 8 - PAGE_SHIFT, \\\n\t\t\t\t      SWP_TYPE_SHIFT)\n#endif\t \n#define SWP_PFN_MASK\t\t(BIT(SWP_PFN_BITS) - 1)\n\n \n#define SWP_MIG_YOUNG_BIT\t\t(SWP_PFN_BITS)\n#define SWP_MIG_DIRTY_BIT\t\t(SWP_PFN_BITS + 1)\n#define SWP_MIG_TOTAL_BITS\t\t(SWP_PFN_BITS + 2)\n\n#define SWP_MIG_YOUNG\t\t\tBIT(SWP_MIG_YOUNG_BIT)\n#define SWP_MIG_DIRTY\t\t\tBIT(SWP_MIG_DIRTY_BIT)\n\nstatic inline bool is_pfn_swap_entry(swp_entry_t entry);\n\n \nstatic inline pte_t pte_swp_clear_flags(pte_t pte)\n{\n\tif (pte_swp_exclusive(pte))\n\t\tpte = pte_swp_clear_exclusive(pte);\n\tif (pte_swp_soft_dirty(pte))\n\t\tpte = pte_swp_clear_soft_dirty(pte);\n\tif (pte_swp_uffd_wp(pte))\n\t\tpte = pte_swp_clear_uffd_wp(pte);\n\treturn pte;\n}\n\n \nstatic inline swp_entry_t swp_entry(unsigned long type, pgoff_t offset)\n{\n\tswp_entry_t ret;\n\n\tret.val = (type << SWP_TYPE_SHIFT) | (offset & SWP_OFFSET_MASK);\n\treturn ret;\n}\n\n \nstatic inline unsigned swp_type(swp_entry_t entry)\n{\n\treturn (entry.val >> SWP_TYPE_SHIFT);\n}\n\n \nstatic inline pgoff_t swp_offset(swp_entry_t entry)\n{\n\treturn entry.val & SWP_OFFSET_MASK;\n}\n\n \nstatic inline unsigned long swp_offset_pfn(swp_entry_t entry)\n{\n\tVM_BUG_ON(!is_pfn_swap_entry(entry));\n\treturn swp_offset(entry) & SWP_PFN_MASK;\n}\n\n \nstatic inline int is_swap_pte(pte_t pte)\n{\n\treturn !pte_none(pte) && !pte_present(pte);\n}\n\n \nstatic inline swp_entry_t pte_to_swp_entry(pte_t pte)\n{\n\tswp_entry_t arch_entry;\n\n\tpte = pte_swp_clear_flags(pte);\n\tarch_entry = __pte_to_swp_entry(pte);\n\treturn swp_entry(__swp_type(arch_entry), __swp_offset(arch_entry));\n}\n\n \nstatic inline pte_t swp_entry_to_pte(swp_entry_t entry)\n{\n\tswp_entry_t arch_entry;\n\n\tarch_entry = __swp_entry(swp_type(entry), swp_offset(entry));\n\treturn __swp_entry_to_pte(arch_entry);\n}\n\nstatic inline swp_entry_t radix_to_swp_entry(void *arg)\n{\n\tswp_entry_t entry;\n\n\tentry.val = xa_to_value(arg);\n\treturn entry;\n}\n\nstatic inline void *swp_to_radix_entry(swp_entry_t entry)\n{\n\treturn xa_mk_value(entry.val);\n}\n\n#if IS_ENABLED(CONFIG_DEVICE_PRIVATE)\nstatic inline swp_entry_t make_readable_device_private_entry(pgoff_t offset)\n{\n\treturn swp_entry(SWP_DEVICE_READ, offset);\n}\n\nstatic inline swp_entry_t make_writable_device_private_entry(pgoff_t offset)\n{\n\treturn swp_entry(SWP_DEVICE_WRITE, offset);\n}\n\nstatic inline bool is_device_private_entry(swp_entry_t entry)\n{\n\tint type = swp_type(entry);\n\treturn type == SWP_DEVICE_READ || type == SWP_DEVICE_WRITE;\n}\n\nstatic inline bool is_writable_device_private_entry(swp_entry_t entry)\n{\n\treturn unlikely(swp_type(entry) == SWP_DEVICE_WRITE);\n}\n\nstatic inline swp_entry_t make_readable_device_exclusive_entry(pgoff_t offset)\n{\n\treturn swp_entry(SWP_DEVICE_EXCLUSIVE_READ, offset);\n}\n\nstatic inline swp_entry_t make_writable_device_exclusive_entry(pgoff_t offset)\n{\n\treturn swp_entry(SWP_DEVICE_EXCLUSIVE_WRITE, offset);\n}\n\nstatic inline bool is_device_exclusive_entry(swp_entry_t entry)\n{\n\treturn swp_type(entry) == SWP_DEVICE_EXCLUSIVE_READ ||\n\t\tswp_type(entry) == SWP_DEVICE_EXCLUSIVE_WRITE;\n}\n\nstatic inline bool is_writable_device_exclusive_entry(swp_entry_t entry)\n{\n\treturn unlikely(swp_type(entry) == SWP_DEVICE_EXCLUSIVE_WRITE);\n}\n#else  \nstatic inline swp_entry_t make_readable_device_private_entry(pgoff_t offset)\n{\n\treturn swp_entry(0, 0);\n}\n\nstatic inline swp_entry_t make_writable_device_private_entry(pgoff_t offset)\n{\n\treturn swp_entry(0, 0);\n}\n\nstatic inline bool is_device_private_entry(swp_entry_t entry)\n{\n\treturn false;\n}\n\nstatic inline bool is_writable_device_private_entry(swp_entry_t entry)\n{\n\treturn false;\n}\n\nstatic inline swp_entry_t make_readable_device_exclusive_entry(pgoff_t offset)\n{\n\treturn swp_entry(0, 0);\n}\n\nstatic inline swp_entry_t make_writable_device_exclusive_entry(pgoff_t offset)\n{\n\treturn swp_entry(0, 0);\n}\n\nstatic inline bool is_device_exclusive_entry(swp_entry_t entry)\n{\n\treturn false;\n}\n\nstatic inline bool is_writable_device_exclusive_entry(swp_entry_t entry)\n{\n\treturn false;\n}\n#endif  \n\n#ifdef CONFIG_MIGRATION\nstatic inline int is_migration_entry(swp_entry_t entry)\n{\n\treturn unlikely(swp_type(entry) == SWP_MIGRATION_READ ||\n\t\t\tswp_type(entry) == SWP_MIGRATION_READ_EXCLUSIVE ||\n\t\t\tswp_type(entry) == SWP_MIGRATION_WRITE);\n}\n\nstatic inline int is_writable_migration_entry(swp_entry_t entry)\n{\n\treturn unlikely(swp_type(entry) == SWP_MIGRATION_WRITE);\n}\n\nstatic inline int is_readable_migration_entry(swp_entry_t entry)\n{\n\treturn unlikely(swp_type(entry) == SWP_MIGRATION_READ);\n}\n\nstatic inline int is_readable_exclusive_migration_entry(swp_entry_t entry)\n{\n\treturn unlikely(swp_type(entry) == SWP_MIGRATION_READ_EXCLUSIVE);\n}\n\nstatic inline swp_entry_t make_readable_migration_entry(pgoff_t offset)\n{\n\treturn swp_entry(SWP_MIGRATION_READ, offset);\n}\n\nstatic inline swp_entry_t make_readable_exclusive_migration_entry(pgoff_t offset)\n{\n\treturn swp_entry(SWP_MIGRATION_READ_EXCLUSIVE, offset);\n}\n\nstatic inline swp_entry_t make_writable_migration_entry(pgoff_t offset)\n{\n\treturn swp_entry(SWP_MIGRATION_WRITE, offset);\n}\n\n \nstatic inline bool migration_entry_supports_ad(void)\n{\n#ifdef CONFIG_SWAP\n\treturn swap_migration_ad_supported;\n#else   \n\treturn false;\n#endif\t \n}\n\nstatic inline swp_entry_t make_migration_entry_young(swp_entry_t entry)\n{\n\tif (migration_entry_supports_ad())\n\t\treturn swp_entry(swp_type(entry),\n\t\t\t\t swp_offset(entry) | SWP_MIG_YOUNG);\n\treturn entry;\n}\n\nstatic inline bool is_migration_entry_young(swp_entry_t entry)\n{\n\tif (migration_entry_supports_ad())\n\t\treturn swp_offset(entry) & SWP_MIG_YOUNG;\n\t \n\treturn false;\n}\n\nstatic inline swp_entry_t make_migration_entry_dirty(swp_entry_t entry)\n{\n\tif (migration_entry_supports_ad())\n\t\treturn swp_entry(swp_type(entry),\n\t\t\t\t swp_offset(entry) | SWP_MIG_DIRTY);\n\treturn entry;\n}\n\nstatic inline bool is_migration_entry_dirty(swp_entry_t entry)\n{\n\tif (migration_entry_supports_ad())\n\t\treturn swp_offset(entry) & SWP_MIG_DIRTY;\n\t \n\treturn false;\n}\n\nextern void migration_entry_wait(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\t\tunsigned long address);\nextern void migration_entry_wait_huge(struct vm_area_struct *vma, pte_t *pte);\n#else   \nstatic inline swp_entry_t make_readable_migration_entry(pgoff_t offset)\n{\n\treturn swp_entry(0, 0);\n}\n\nstatic inline swp_entry_t make_readable_exclusive_migration_entry(pgoff_t offset)\n{\n\treturn swp_entry(0, 0);\n}\n\nstatic inline swp_entry_t make_writable_migration_entry(pgoff_t offset)\n{\n\treturn swp_entry(0, 0);\n}\n\nstatic inline int is_migration_entry(swp_entry_t swp)\n{\n\treturn 0;\n}\n\nstatic inline void migration_entry_wait(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\t\tunsigned long address) { }\nstatic inline void migration_entry_wait_huge(struct vm_area_struct *vma,\n\t\t\t\t\tpte_t *pte) { }\nstatic inline int is_writable_migration_entry(swp_entry_t entry)\n{\n\treturn 0;\n}\nstatic inline int is_readable_migration_entry(swp_entry_t entry)\n{\n\treturn 0;\n}\n\nstatic inline swp_entry_t make_migration_entry_young(swp_entry_t entry)\n{\n\treturn entry;\n}\n\nstatic inline bool is_migration_entry_young(swp_entry_t entry)\n{\n\treturn false;\n}\n\nstatic inline swp_entry_t make_migration_entry_dirty(swp_entry_t entry)\n{\n\treturn entry;\n}\n\nstatic inline bool is_migration_entry_dirty(swp_entry_t entry)\n{\n\treturn false;\n}\n#endif\t \n\ntypedef unsigned long pte_marker;\n\n#define  PTE_MARKER_UFFD_WP\t\t\tBIT(0)\n \n#define  PTE_MARKER_POISONED\t\t\tBIT(1)\n#define  PTE_MARKER_MASK\t\t\t(BIT(2) - 1)\n\nstatic inline swp_entry_t make_pte_marker_entry(pte_marker marker)\n{\n\treturn swp_entry(SWP_PTE_MARKER, marker);\n}\n\nstatic inline bool is_pte_marker_entry(swp_entry_t entry)\n{\n\treturn swp_type(entry) == SWP_PTE_MARKER;\n}\n\nstatic inline pte_marker pte_marker_get(swp_entry_t entry)\n{\n\treturn swp_offset(entry) & PTE_MARKER_MASK;\n}\n\nstatic inline bool is_pte_marker(pte_t pte)\n{\n\treturn is_swap_pte(pte) && is_pte_marker_entry(pte_to_swp_entry(pte));\n}\n\nstatic inline pte_t make_pte_marker(pte_marker marker)\n{\n\treturn swp_entry_to_pte(make_pte_marker_entry(marker));\n}\n\nstatic inline swp_entry_t make_poisoned_swp_entry(void)\n{\n\treturn make_pte_marker_entry(PTE_MARKER_POISONED);\n}\n\nstatic inline int is_poisoned_swp_entry(swp_entry_t entry)\n{\n\treturn is_pte_marker_entry(entry) &&\n\t    (pte_marker_get(entry) & PTE_MARKER_POISONED);\n}\n\n \nstatic inline int pte_none_mostly(pte_t pte)\n{\n\treturn pte_none(pte) || is_pte_marker(pte);\n}\n\nstatic inline struct page *pfn_swap_entry_to_page(swp_entry_t entry)\n{\n\tstruct page *p = pfn_to_page(swp_offset_pfn(entry));\n\n\t \n\tBUG_ON(is_migration_entry(entry) && !PageLocked(p));\n\n\treturn p;\n}\n\n \nstatic inline bool is_pfn_swap_entry(swp_entry_t entry)\n{\n\t \n\tBUILD_BUG_ON(SWP_TYPE_SHIFT < SWP_PFN_BITS);\n\n\treturn is_migration_entry(entry) || is_device_private_entry(entry) ||\n\t       is_device_exclusive_entry(entry);\n}\n\nstruct page_vma_mapped_walk;\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\nextern int set_pmd_migration_entry(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *page);\n\nextern void remove_migration_pmd(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *new);\n\nextern void pmd_migration_entry_wait(struct mm_struct *mm, pmd_t *pmd);\n\nstatic inline swp_entry_t pmd_to_swp_entry(pmd_t pmd)\n{\n\tswp_entry_t arch_entry;\n\n\tif (pmd_swp_soft_dirty(pmd))\n\t\tpmd = pmd_swp_clear_soft_dirty(pmd);\n\tif (pmd_swp_uffd_wp(pmd))\n\t\tpmd = pmd_swp_clear_uffd_wp(pmd);\n\tarch_entry = __pmd_to_swp_entry(pmd);\n\treturn swp_entry(__swp_type(arch_entry), __swp_offset(arch_entry));\n}\n\nstatic inline pmd_t swp_entry_to_pmd(swp_entry_t entry)\n{\n\tswp_entry_t arch_entry;\n\n\tarch_entry = __swp_entry(swp_type(entry), swp_offset(entry));\n\treturn __swp_entry_to_pmd(arch_entry);\n}\n\nstatic inline int is_pmd_migration_entry(pmd_t pmd)\n{\n\treturn is_swap_pmd(pmd) && is_migration_entry(pmd_to_swp_entry(pmd));\n}\n#else   \nstatic inline int set_pmd_migration_entry(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *page)\n{\n\tBUILD_BUG();\n}\n\nstatic inline void remove_migration_pmd(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *new)\n{\n\tBUILD_BUG();\n}\n\nstatic inline void pmd_migration_entry_wait(struct mm_struct *m, pmd_t *p) { }\n\nstatic inline swp_entry_t pmd_to_swp_entry(pmd_t pmd)\n{\n\treturn swp_entry(0, 0);\n}\n\nstatic inline pmd_t swp_entry_to_pmd(swp_entry_t entry)\n{\n\treturn __pmd(0);\n}\n\nstatic inline int is_pmd_migration_entry(pmd_t pmd)\n{\n\treturn 0;\n}\n#endif   \n\n#ifdef CONFIG_MEMORY_FAILURE\n\n \nstatic inline swp_entry_t make_hwpoison_entry(struct page *page)\n{\n\tBUG_ON(!PageLocked(page));\n\treturn swp_entry(SWP_HWPOISON, page_to_pfn(page));\n}\n\nstatic inline int is_hwpoison_entry(swp_entry_t entry)\n{\n\treturn swp_type(entry) == SWP_HWPOISON;\n}\n\n#else\n\nstatic inline swp_entry_t make_hwpoison_entry(struct page *page)\n{\n\treturn swp_entry(0, 0);\n}\n\nstatic inline int is_hwpoison_entry(swp_entry_t swp)\n{\n\treturn 0;\n}\n#endif\n\nstatic inline int non_swap_entry(swp_entry_t entry)\n{\n\treturn swp_type(entry) >= MAX_SWAPFILES;\n}\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}