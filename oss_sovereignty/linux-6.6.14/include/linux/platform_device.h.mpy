{
  "module_name": "platform_device.h",
  "hash_id": "e9a4dd6b199f907c45f0b5e064c21d7e3c43cd3b6e008675c4040d6338acc679",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/platform_device.h",
  "human_readable_source": " \n \n\n#ifndef _PLATFORM_DEVICE_H_\n#define _PLATFORM_DEVICE_H_\n\n#include <linux/device.h>\n\n#define PLATFORM_DEVID_NONE\t(-1)\n#define PLATFORM_DEVID_AUTO\t(-2)\n\nstruct irq_affinity;\nstruct mfd_cell;\nstruct property_entry;\nstruct platform_device_id;\n\nstruct platform_device {\n\tconst char\t*name;\n\tint\t\tid;\n\tbool\t\tid_auto;\n\tstruct device\tdev;\n\tu64\t\tplatform_dma_mask;\n\tstruct device_dma_parameters dma_parms;\n\tu32\t\tnum_resources;\n\tstruct resource\t*resource;\n\n\tconst struct platform_device_id\t*id_entry;\n\t \n\tconst char *driver_override;\n\n\t \n\tstruct mfd_cell *mfd_cell;\n\n\t \n\tstruct pdev_archdata\tarchdata;\n};\n\n#define platform_get_device_id(pdev)\t((pdev)->id_entry)\n\n#define dev_is_platform(dev) ((dev)->bus == &platform_bus_type)\n#define to_platform_device(x) container_of((x), struct platform_device, dev)\n\nextern int platform_device_register(struct platform_device *);\nextern void platform_device_unregister(struct platform_device *);\n\nextern struct bus_type platform_bus_type;\nextern struct device platform_bus;\n\nextern struct resource *platform_get_resource(struct platform_device *,\n\t\t\t\t\t      unsigned int, unsigned int);\nextern struct resource *platform_get_mem_or_io(struct platform_device *,\n\t\t\t\t\t       unsigned int);\n\nextern struct device *\nplatform_find_device_by_driver(struct device *start,\n\t\t\t       const struct device_driver *drv);\n\n#ifdef CONFIG_HAS_IOMEM\nextern void __iomem *\ndevm_platform_get_and_ioremap_resource(struct platform_device *pdev,\n\t\t\t\tunsigned int index, struct resource **res);\nextern void __iomem *\ndevm_platform_ioremap_resource(struct platform_device *pdev,\n\t\t\t       unsigned int index);\nextern void __iomem *\ndevm_platform_ioremap_resource_byname(struct platform_device *pdev,\n\t\t\t\t      const char *name);\n#else\n\nstatic inline void __iomem *\ndevm_platform_get_and_ioremap_resource(struct platform_device *pdev,\n\t\t\t\tunsigned int index, struct resource **res)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n\n\nstatic inline void __iomem *\ndevm_platform_ioremap_resource(struct platform_device *pdev,\n\t\t\t       unsigned int index)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic inline void __iomem *\ndevm_platform_ioremap_resource_byname(struct platform_device *pdev,\n\t\t\t\t      const char *name)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n\n#endif\n\nextern int platform_get_irq(struct platform_device *, unsigned int);\nextern int platform_get_irq_optional(struct platform_device *, unsigned int);\nextern int platform_irq_count(struct platform_device *);\nextern int devm_platform_get_irqs_affinity(struct platform_device *dev,\n\t\t\t\t\t   struct irq_affinity *affd,\n\t\t\t\t\t   unsigned int minvec,\n\t\t\t\t\t   unsigned int maxvec,\n\t\t\t\t\t   int **irqs);\nextern struct resource *platform_get_resource_byname(struct platform_device *,\n\t\t\t\t\t\t     unsigned int,\n\t\t\t\t\t\t     const char *);\nextern int platform_get_irq_byname(struct platform_device *, const char *);\nextern int platform_get_irq_byname_optional(struct platform_device *dev,\n\t\t\t\t\t    const char *name);\nextern int platform_add_devices(struct platform_device **, int);\n\nstruct platform_device_info {\n\t\tstruct device *parent;\n\t\tstruct fwnode_handle *fwnode;\n\t\tbool of_node_reused;\n\n\t\tconst char *name;\n\t\tint id;\n\n\t\tconst struct resource *res;\n\t\tunsigned int num_res;\n\n\t\tconst void *data;\n\t\tsize_t size_data;\n\t\tu64 dma_mask;\n\n\t\tconst struct property_entry *properties;\n};\nextern struct platform_device *platform_device_register_full(\n\t\tconst struct platform_device_info *pdevinfo);\n\n \nstatic inline struct platform_device *platform_device_register_resndata(\n\t\tstruct device *parent, const char *name, int id,\n\t\tconst struct resource *res, unsigned int num,\n\t\tconst void *data, size_t size) {\n\n\tstruct platform_device_info pdevinfo = {\n\t\t.parent = parent,\n\t\t.name = name,\n\t\t.id = id,\n\t\t.res = res,\n\t\t.num_res = num,\n\t\t.data = data,\n\t\t.size_data = size,\n\t\t.dma_mask = 0,\n\t};\n\n\treturn platform_device_register_full(&pdevinfo);\n}\n\n \nstatic inline struct platform_device *platform_device_register_simple(\n\t\tconst char *name, int id,\n\t\tconst struct resource *res, unsigned int num)\n{\n\treturn platform_device_register_resndata(NULL, name, id,\n\t\t\tres, num, NULL, 0);\n}\n\n \nstatic inline struct platform_device *platform_device_register_data(\n\t\tstruct device *parent, const char *name, int id,\n\t\tconst void *data, size_t size)\n{\n\treturn platform_device_register_resndata(parent, name, id,\n\t\t\tNULL, 0, data, size);\n}\n\nextern struct platform_device *platform_device_alloc(const char *name, int id);\nextern int platform_device_add_resources(struct platform_device *pdev,\n\t\t\t\t\t const struct resource *res,\n\t\t\t\t\t unsigned int num);\nextern int platform_device_add_data(struct platform_device *pdev,\n\t\t\t\t    const void *data, size_t size);\nextern int platform_device_add(struct platform_device *pdev);\nextern void platform_device_del(struct platform_device *pdev);\nextern void platform_device_put(struct platform_device *pdev);\n\nstruct platform_driver {\n\tint (*probe)(struct platform_device *);\n\n\t \n\tint (*remove)(struct platform_device *);\n\tvoid (*remove_new)(struct platform_device *);\n\n\tvoid (*shutdown)(struct platform_device *);\n\tint (*suspend)(struct platform_device *, pm_message_t state);\n\tint (*resume)(struct platform_device *);\n\tstruct device_driver driver;\n\tconst struct platform_device_id *id_table;\n\tbool prevent_deferred_probe;\n\t \n\tbool driver_managed_dma;\n};\n\n#define to_platform_driver(drv)\t(container_of((drv), struct platform_driver, \\\n\t\t\t\t driver))\n\n \n#define platform_driver_register(drv) \\\n\t__platform_driver_register(drv, THIS_MODULE)\nextern int __platform_driver_register(struct platform_driver *,\n\t\t\t\t\tstruct module *);\nextern void platform_driver_unregister(struct platform_driver *);\n\n \n#define platform_driver_probe(drv, probe) \\\n\t__platform_driver_probe(drv, probe, THIS_MODULE)\nextern int __platform_driver_probe(struct platform_driver *driver,\n\t\tint (*probe)(struct platform_device *), struct module *module);\n\nstatic inline void *platform_get_drvdata(const struct platform_device *pdev)\n{\n\treturn dev_get_drvdata(&pdev->dev);\n}\n\nstatic inline void platform_set_drvdata(struct platform_device *pdev,\n\t\t\t\t\tvoid *data)\n{\n\tdev_set_drvdata(&pdev->dev, data);\n}\n\n \n#define module_platform_driver(__platform_driver) \\\n\tmodule_driver(__platform_driver, platform_driver_register, \\\n\t\t\tplatform_driver_unregister)\n\n \n#define builtin_platform_driver(__platform_driver) \\\n\tbuiltin_driver(__platform_driver, platform_driver_register)\n\n \n#define module_platform_driver_probe(__platform_driver, __platform_probe) \\\nstatic int __init __platform_driver##_init(void) \\\n{ \\\n\treturn platform_driver_probe(&(__platform_driver), \\\n\t\t\t\t     __platform_probe);    \\\n} \\\nmodule_init(__platform_driver##_init); \\\nstatic void __exit __platform_driver##_exit(void) \\\n{ \\\n\tplatform_driver_unregister(&(__platform_driver)); \\\n} \\\nmodule_exit(__platform_driver##_exit);\n\n \n#define builtin_platform_driver_probe(__platform_driver, __platform_probe) \\\nstatic int __init __platform_driver##_init(void) \\\n{ \\\n\treturn platform_driver_probe(&(__platform_driver), \\\n\t\t\t\t     __platform_probe);    \\\n} \\\ndevice_initcall(__platform_driver##_init); \\\n\n#define platform_create_bundle(driver, probe, res, n_res, data, size) \\\n\t__platform_create_bundle(driver, probe, res, n_res, data, size, THIS_MODULE)\nextern struct platform_device *__platform_create_bundle(\n\tstruct platform_driver *driver, int (*probe)(struct platform_device *),\n\tstruct resource *res, unsigned int n_res,\n\tconst void *data, size_t size, struct module *module);\n\nint __platform_register_drivers(struct platform_driver * const *drivers,\n\t\t\t\tunsigned int count, struct module *owner);\nvoid platform_unregister_drivers(struct platform_driver * const *drivers,\n\t\t\t\t unsigned int count);\n\n#define platform_register_drivers(drivers, count) \\\n\t__platform_register_drivers(drivers, count, THIS_MODULE)\n\n#ifdef CONFIG_SUSPEND\nextern int platform_pm_suspend(struct device *dev);\nextern int platform_pm_resume(struct device *dev);\n#else\n#define platform_pm_suspend\t\tNULL\n#define platform_pm_resume\t\tNULL\n#endif\n\n#ifdef CONFIG_HIBERNATE_CALLBACKS\nextern int platform_pm_freeze(struct device *dev);\nextern int platform_pm_thaw(struct device *dev);\nextern int platform_pm_poweroff(struct device *dev);\nextern int platform_pm_restore(struct device *dev);\n#else\n#define platform_pm_freeze\t\tNULL\n#define platform_pm_thaw\t\tNULL\n#define platform_pm_poweroff\t\tNULL\n#define platform_pm_restore\t\tNULL\n#endif\n\n#ifdef CONFIG_PM_SLEEP\n#define USE_PLATFORM_PM_SLEEP_OPS \\\n\t.suspend = platform_pm_suspend, \\\n\t.resume = platform_pm_resume, \\\n\t.freeze = platform_pm_freeze, \\\n\t.thaw = platform_pm_thaw, \\\n\t.poweroff = platform_pm_poweroff, \\\n\t.restore = platform_pm_restore,\n#else\n#define USE_PLATFORM_PM_SLEEP_OPS\n#endif\n\n#ifndef CONFIG_SUPERH\n \nstatic inline int is_sh_early_platform_device(struct platform_device *pdev)\n{\n\treturn 0;\n}\n#endif  \n\n \nvoid early_platform_cleanup(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}