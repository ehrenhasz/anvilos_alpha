{
  "module_name": "nodemask.h",
  "hash_id": "8cb6c1a1ff394170bd5a9f4889df07aebaf6681cc54f9eed8e4fdd525cbb5b12",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/nodemask.h",
  "human_readable_source": " \n#ifndef __LINUX_NODEMASK_H\n#define __LINUX_NODEMASK_H\n\n \n\n#include <linux/threads.h>\n#include <linux/bitmap.h>\n#include <linux/minmax.h>\n#include <linux/numa.h>\n#include <linux/random.h>\n\ntypedef struct { DECLARE_BITMAP(bits, MAX_NUMNODES); } nodemask_t;\nextern nodemask_t _unused_nodemask_arg_;\n\n \n#define nodemask_pr_args(maskp)\t__nodemask_pr_numnodes(maskp), \\\n\t\t\t\t__nodemask_pr_bits(maskp)\nstatic inline unsigned int __nodemask_pr_numnodes(const nodemask_t *m)\n{\n\treturn m ? MAX_NUMNODES : 0;\n}\nstatic inline const unsigned long *__nodemask_pr_bits(const nodemask_t *m)\n{\n\treturn m ? m->bits : NULL;\n}\n\n \n#define node_set(node, dst) __node_set((node), &(dst))\nstatic __always_inline void __node_set(int node, volatile nodemask_t *dstp)\n{\n\tset_bit(node, dstp->bits);\n}\n\n#define node_clear(node, dst) __node_clear((node), &(dst))\nstatic inline void __node_clear(int node, volatile nodemask_t *dstp)\n{\n\tclear_bit(node, dstp->bits);\n}\n\n#define nodes_setall(dst) __nodes_setall(&(dst), MAX_NUMNODES)\nstatic inline void __nodes_setall(nodemask_t *dstp, unsigned int nbits)\n{\n\tbitmap_fill(dstp->bits, nbits);\n}\n\n#define nodes_clear(dst) __nodes_clear(&(dst), MAX_NUMNODES)\nstatic inline void __nodes_clear(nodemask_t *dstp, unsigned int nbits)\n{\n\tbitmap_zero(dstp->bits, nbits);\n}\n\n \n#define node_isset(node, nodemask) test_bit((node), (nodemask).bits)\n\n#define node_test_and_set(node, nodemask) \\\n\t\t\t__node_test_and_set((node), &(nodemask))\nstatic inline bool __node_test_and_set(int node, nodemask_t *addr)\n{\n\treturn test_and_set_bit(node, addr->bits);\n}\n\n#define nodes_and(dst, src1, src2) \\\n\t\t\t__nodes_and(&(dst), &(src1), &(src2), MAX_NUMNODES)\nstatic inline void __nodes_and(nodemask_t *dstp, const nodemask_t *src1p,\n\t\t\t\t\tconst nodemask_t *src2p, unsigned int nbits)\n{\n\tbitmap_and(dstp->bits, src1p->bits, src2p->bits, nbits);\n}\n\n#define nodes_or(dst, src1, src2) \\\n\t\t\t__nodes_or(&(dst), &(src1), &(src2), MAX_NUMNODES)\nstatic inline void __nodes_or(nodemask_t *dstp, const nodemask_t *src1p,\n\t\t\t\t\tconst nodemask_t *src2p, unsigned int nbits)\n{\n\tbitmap_or(dstp->bits, src1p->bits, src2p->bits, nbits);\n}\n\n#define nodes_xor(dst, src1, src2) \\\n\t\t\t__nodes_xor(&(dst), &(src1), &(src2), MAX_NUMNODES)\nstatic inline void __nodes_xor(nodemask_t *dstp, const nodemask_t *src1p,\n\t\t\t\t\tconst nodemask_t *src2p, unsigned int nbits)\n{\n\tbitmap_xor(dstp->bits, src1p->bits, src2p->bits, nbits);\n}\n\n#define nodes_andnot(dst, src1, src2) \\\n\t\t\t__nodes_andnot(&(dst), &(src1), &(src2), MAX_NUMNODES)\nstatic inline void __nodes_andnot(nodemask_t *dstp, const nodemask_t *src1p,\n\t\t\t\t\tconst nodemask_t *src2p, unsigned int nbits)\n{\n\tbitmap_andnot(dstp->bits, src1p->bits, src2p->bits, nbits);\n}\n\n#define nodes_complement(dst, src) \\\n\t\t\t__nodes_complement(&(dst), &(src), MAX_NUMNODES)\nstatic inline void __nodes_complement(nodemask_t *dstp,\n\t\t\t\t\tconst nodemask_t *srcp, unsigned int nbits)\n{\n\tbitmap_complement(dstp->bits, srcp->bits, nbits);\n}\n\n#define nodes_equal(src1, src2) \\\n\t\t\t__nodes_equal(&(src1), &(src2), MAX_NUMNODES)\nstatic inline bool __nodes_equal(const nodemask_t *src1p,\n\t\t\t\t\tconst nodemask_t *src2p, unsigned int nbits)\n{\n\treturn bitmap_equal(src1p->bits, src2p->bits, nbits);\n}\n\n#define nodes_intersects(src1, src2) \\\n\t\t\t__nodes_intersects(&(src1), &(src2), MAX_NUMNODES)\nstatic inline bool __nodes_intersects(const nodemask_t *src1p,\n\t\t\t\t\tconst nodemask_t *src2p, unsigned int nbits)\n{\n\treturn bitmap_intersects(src1p->bits, src2p->bits, nbits);\n}\n\n#define nodes_subset(src1, src2) \\\n\t\t\t__nodes_subset(&(src1), &(src2), MAX_NUMNODES)\nstatic inline bool __nodes_subset(const nodemask_t *src1p,\n\t\t\t\t\tconst nodemask_t *src2p, unsigned int nbits)\n{\n\treturn bitmap_subset(src1p->bits, src2p->bits, nbits);\n}\n\n#define nodes_empty(src) __nodes_empty(&(src), MAX_NUMNODES)\nstatic inline bool __nodes_empty(const nodemask_t *srcp, unsigned int nbits)\n{\n\treturn bitmap_empty(srcp->bits, nbits);\n}\n\n#define nodes_full(nodemask) __nodes_full(&(nodemask), MAX_NUMNODES)\nstatic inline bool __nodes_full(const nodemask_t *srcp, unsigned int nbits)\n{\n\treturn bitmap_full(srcp->bits, nbits);\n}\n\n#define nodes_weight(nodemask) __nodes_weight(&(nodemask), MAX_NUMNODES)\nstatic inline int __nodes_weight(const nodemask_t *srcp, unsigned int nbits)\n{\n\treturn bitmap_weight(srcp->bits, nbits);\n}\n\n#define nodes_shift_right(dst, src, n) \\\n\t\t\t__nodes_shift_right(&(dst), &(src), (n), MAX_NUMNODES)\nstatic inline void __nodes_shift_right(nodemask_t *dstp,\n\t\t\t\t\tconst nodemask_t *srcp, int n, int nbits)\n{\n\tbitmap_shift_right(dstp->bits, srcp->bits, n, nbits);\n}\n\n#define nodes_shift_left(dst, src, n) \\\n\t\t\t__nodes_shift_left(&(dst), &(src), (n), MAX_NUMNODES)\nstatic inline void __nodes_shift_left(nodemask_t *dstp,\n\t\t\t\t\tconst nodemask_t *srcp, int n, int nbits)\n{\n\tbitmap_shift_left(dstp->bits, srcp->bits, n, nbits);\n}\n\n \n\n#define first_node(src) __first_node(&(src))\nstatic inline unsigned int __first_node(const nodemask_t *srcp)\n{\n\treturn min_t(unsigned int, MAX_NUMNODES, find_first_bit(srcp->bits, MAX_NUMNODES));\n}\n\n#define next_node(n, src) __next_node((n), &(src))\nstatic inline unsigned int __next_node(int n, const nodemask_t *srcp)\n{\n\treturn min_t(unsigned int, MAX_NUMNODES, find_next_bit(srcp->bits, MAX_NUMNODES, n+1));\n}\n\n \n#define next_node_in(n, src) __next_node_in((n), &(src))\nstatic inline unsigned int __next_node_in(int node, const nodemask_t *srcp)\n{\n\tunsigned int ret = __next_node(node, srcp);\n\n\tif (ret == MAX_NUMNODES)\n\t\tret = __first_node(srcp);\n\treturn ret;\n}\n\nstatic inline void init_nodemask_of_node(nodemask_t *mask, int node)\n{\n\tnodes_clear(*mask);\n\tnode_set(node, *mask);\n}\n\n#define nodemask_of_node(node)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(_unused_nodemask_arg_) m;\t\t\t\t\\\n\tif (sizeof(m) == sizeof(unsigned long)) {\t\t\t\\\n\t\tm.bits[0] = 1UL << (node);\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tinit_nodemask_of_node(&m, (node));\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tm;\t\t\t\t\t\t\t\t\\\n})\n\n#define first_unset_node(mask) __first_unset_node(&(mask))\nstatic inline unsigned int __first_unset_node(const nodemask_t *maskp)\n{\n\treturn min_t(unsigned int, MAX_NUMNODES,\n\t\t\tfind_first_zero_bit(maskp->bits, MAX_NUMNODES));\n}\n\n#define NODE_MASK_LAST_WORD BITMAP_LAST_WORD_MASK(MAX_NUMNODES)\n\n#if MAX_NUMNODES <= BITS_PER_LONG\n\n#define NODE_MASK_ALL\t\t\t\t\t\t\t\\\n((nodemask_t) { {\t\t\t\t\t\t\t\\\n\t[BITS_TO_LONGS(MAX_NUMNODES)-1] = NODE_MASK_LAST_WORD\t\t\\\n} })\n\n#else\n\n#define NODE_MASK_ALL\t\t\t\t\t\t\t\\\n((nodemask_t) { {\t\t\t\t\t\t\t\\\n\t[0 ... BITS_TO_LONGS(MAX_NUMNODES)-2] = ~0UL,\t\t\t\\\n\t[BITS_TO_LONGS(MAX_NUMNODES)-1] = NODE_MASK_LAST_WORD\t\t\\\n} })\n\n#endif\n\n#define NODE_MASK_NONE\t\t\t\t\t\t\t\\\n((nodemask_t) { {\t\t\t\t\t\t\t\\\n\t[0 ... BITS_TO_LONGS(MAX_NUMNODES)-1] =  0UL\t\t\t\\\n} })\n\n#define nodes_addr(src) ((src).bits)\n\n#define nodemask_parse_user(ubuf, ulen, dst) \\\n\t\t__nodemask_parse_user((ubuf), (ulen), &(dst), MAX_NUMNODES)\nstatic inline int __nodemask_parse_user(const char __user *buf, int len,\n\t\t\t\t\tnodemask_t *dstp, int nbits)\n{\n\treturn bitmap_parse_user(buf, len, dstp->bits, nbits);\n}\n\n#define nodelist_parse(buf, dst) __nodelist_parse((buf), &(dst), MAX_NUMNODES)\nstatic inline int __nodelist_parse(const char *buf, nodemask_t *dstp, int nbits)\n{\n\treturn bitmap_parselist(buf, dstp->bits, nbits);\n}\n\n#define node_remap(oldbit, old, new) \\\n\t\t__node_remap((oldbit), &(old), &(new), MAX_NUMNODES)\nstatic inline int __node_remap(int oldbit,\n\t\tconst nodemask_t *oldp, const nodemask_t *newp, int nbits)\n{\n\treturn bitmap_bitremap(oldbit, oldp->bits, newp->bits, nbits);\n}\n\n#define nodes_remap(dst, src, old, new) \\\n\t\t__nodes_remap(&(dst), &(src), &(old), &(new), MAX_NUMNODES)\nstatic inline void __nodes_remap(nodemask_t *dstp, const nodemask_t *srcp,\n\t\tconst nodemask_t *oldp, const nodemask_t *newp, int nbits)\n{\n\tbitmap_remap(dstp->bits, srcp->bits, oldp->bits, newp->bits, nbits);\n}\n\n#define nodes_onto(dst, orig, relmap) \\\n\t\t__nodes_onto(&(dst), &(orig), &(relmap), MAX_NUMNODES)\nstatic inline void __nodes_onto(nodemask_t *dstp, const nodemask_t *origp,\n\t\tconst nodemask_t *relmapp, int nbits)\n{\n\tbitmap_onto(dstp->bits, origp->bits, relmapp->bits, nbits);\n}\n\n#define nodes_fold(dst, orig, sz) \\\n\t\t__nodes_fold(&(dst), &(orig), sz, MAX_NUMNODES)\nstatic inline void __nodes_fold(nodemask_t *dstp, const nodemask_t *origp,\n\t\tint sz, int nbits)\n{\n\tbitmap_fold(dstp->bits, origp->bits, sz, nbits);\n}\n\n#if MAX_NUMNODES > 1\n#define for_each_node_mask(node, mask)\t\t\t\t    \\\n\tfor ((node) = first_node(mask);\t\t\t\t    \\\n\t     (node) < MAX_NUMNODES;\t\t\t\t    \\\n\t     (node) = next_node((node), (mask)))\n#else  \n#define for_each_node_mask(node, mask)                                  \\\n\tfor ((node) = 0; (node) < 1 && !nodes_empty(mask); (node)++)\n#endif  \n\n \nenum node_states {\n\tN_POSSIBLE,\t\t \n\tN_ONLINE,\t\t \n\tN_NORMAL_MEMORY,\t \n#ifdef CONFIG_HIGHMEM\n\tN_HIGH_MEMORY,\t\t \n#else\n\tN_HIGH_MEMORY = N_NORMAL_MEMORY,\n#endif\n\tN_MEMORY,\t\t \n\tN_CPU,\t\t \n\tN_GENERIC_INITIATOR,\t \n\tNR_NODE_STATES\n};\n\n \n\nextern nodemask_t node_states[NR_NODE_STATES];\n\n#if MAX_NUMNODES > 1\nstatic inline int node_state(int node, enum node_states state)\n{\n\treturn node_isset(node, node_states[state]);\n}\n\nstatic inline void node_set_state(int node, enum node_states state)\n{\n\t__node_set(node, &node_states[state]);\n}\n\nstatic inline void node_clear_state(int node, enum node_states state)\n{\n\t__node_clear(node, &node_states[state]);\n}\n\nstatic inline int num_node_state(enum node_states state)\n{\n\treturn nodes_weight(node_states[state]);\n}\n\n#define for_each_node_state(__node, __state) \\\n\tfor_each_node_mask((__node), node_states[__state])\n\n#define first_online_node\tfirst_node(node_states[N_ONLINE])\n#define first_memory_node\tfirst_node(node_states[N_MEMORY])\nstatic inline unsigned int next_online_node(int nid)\n{\n\treturn next_node(nid, node_states[N_ONLINE]);\n}\nstatic inline unsigned int next_memory_node(int nid)\n{\n\treturn next_node(nid, node_states[N_MEMORY]);\n}\n\nextern unsigned int nr_node_ids;\nextern unsigned int nr_online_nodes;\n\nstatic inline void node_set_online(int nid)\n{\n\tnode_set_state(nid, N_ONLINE);\n\tnr_online_nodes = num_node_state(N_ONLINE);\n}\n\nstatic inline void node_set_offline(int nid)\n{\n\tnode_clear_state(nid, N_ONLINE);\n\tnr_online_nodes = num_node_state(N_ONLINE);\n}\n\n#else\n\nstatic inline int node_state(int node, enum node_states state)\n{\n\treturn node == 0;\n}\n\nstatic inline void node_set_state(int node, enum node_states state)\n{\n}\n\nstatic inline void node_clear_state(int node, enum node_states state)\n{\n}\n\nstatic inline int num_node_state(enum node_states state)\n{\n\treturn 1;\n}\n\n#define for_each_node_state(node, __state) \\\n\tfor ( (node) = 0; (node) == 0; (node) = 1)\n\n#define first_online_node\t0\n#define first_memory_node\t0\n#define next_online_node(nid)\t(MAX_NUMNODES)\n#define next_memory_node(nid)\t(MAX_NUMNODES)\n#define nr_node_ids\t\t1U\n#define nr_online_nodes\t\t1U\n\n#define node_set_online(node)\t   node_set_state((node), N_ONLINE)\n#define node_set_offline(node)\t   node_clear_state((node), N_ONLINE)\n\n#endif\n\nstatic inline int node_random(const nodemask_t *maskp)\n{\n#if defined(CONFIG_NUMA) && (MAX_NUMNODES > 1)\n\tint w, bit;\n\n\tw = nodes_weight(*maskp);\n\tswitch (w) {\n\tcase 0:\n\t\tbit = NUMA_NO_NODE;\n\t\tbreak;\n\tcase 1:\n\t\tbit = first_node(*maskp);\n\t\tbreak;\n\tdefault:\n\t\tbit = find_nth_bit(maskp->bits, MAX_NUMNODES, get_random_u32_below(w));\n\t\tbreak;\n\t}\n\treturn bit;\n#else\n\treturn 0;\n#endif\n}\n\n#define node_online_map \tnode_states[N_ONLINE]\n#define node_possible_map \tnode_states[N_POSSIBLE]\n\n#define num_online_nodes()\tnum_node_state(N_ONLINE)\n#define num_possible_nodes()\tnum_node_state(N_POSSIBLE)\n#define node_online(node)\tnode_state((node), N_ONLINE)\n#define node_possible(node)\tnode_state((node), N_POSSIBLE)\n\n#define for_each_node(node)\t   for_each_node_state(node, N_POSSIBLE)\n#define for_each_online_node(node) for_each_node_state(node, N_ONLINE)\n\n \n#if NODES_SHIFT > 8  \n#define NODEMASK_ALLOC(type, name, gfp_flags)\t\\\n\t\t\ttype *name = kmalloc(sizeof(*name), gfp_flags)\n#define NODEMASK_FREE(m)\t\t\tkfree(m)\n#else\n#define NODEMASK_ALLOC(type, name, gfp_flags)\ttype _##name, *name = &_##name\n#define NODEMASK_FREE(m)\t\t\tdo {} while (0)\n#endif\n\n \nstruct nodemask_scratch {\n\tnodemask_t\tmask1;\n\tnodemask_t\tmask2;\n};\n\n#define NODEMASK_SCRATCH(x)\t\t\t\t\t\t\\\n\t\t\tNODEMASK_ALLOC(struct nodemask_scratch, x,\t\\\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY)\n#define NODEMASK_SCRATCH_FREE(x)\tNODEMASK_FREE(x)\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}