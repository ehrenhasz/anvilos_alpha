{
  "module_name": "nvram.h",
  "hash_id": "331f04a749a2dad57139a476e118d61e518f470e31ae66cc766d1c9b02055a27",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/nvram.h",
  "human_readable_source": " \n#ifndef _LINUX_NVRAM_H\n#define _LINUX_NVRAM_H\n\n#include <linux/errno.h>\n#include <uapi/linux/nvram.h>\n\n#ifdef CONFIG_PPC\n#include <asm/machdep.h>\n#endif\n\n \n\nstruct nvram_ops {\n\tssize_t         (*get_size)(void);\n\tunsigned char   (*read_byte)(int);\n\tvoid            (*write_byte)(unsigned char, int);\n\tssize_t         (*read)(char *, size_t, loff_t *);\n\tssize_t         (*write)(char *, size_t, loff_t *);\n#if defined(CONFIG_X86) || defined(CONFIG_M68K)\n\tlong            (*initialize)(void);\n\tlong            (*set_checksum)(void);\n#endif\n};\n\nextern const struct nvram_ops arch_nvram_ops;\n\nstatic inline ssize_t nvram_get_size(void)\n{\n#ifdef CONFIG_PPC\n\tif (ppc_md.nvram_size)\n\t\treturn ppc_md.nvram_size();\n#else\n\tif (arch_nvram_ops.get_size)\n\t\treturn arch_nvram_ops.get_size();\n#endif\n\treturn -ENODEV;\n}\n\nstatic inline unsigned char nvram_read_byte(int addr)\n{\n#ifdef CONFIG_PPC\n\tif (ppc_md.nvram_read_val)\n\t\treturn ppc_md.nvram_read_val(addr);\n#else\n\tif (arch_nvram_ops.read_byte)\n\t\treturn arch_nvram_ops.read_byte(addr);\n#endif\n\treturn 0xFF;\n}\n\nstatic inline void nvram_write_byte(unsigned char val, int addr)\n{\n#ifdef CONFIG_PPC\n\tif (ppc_md.nvram_write_val)\n\t\tppc_md.nvram_write_val(addr, val);\n#else\n\tif (arch_nvram_ops.write_byte)\n\t\tarch_nvram_ops.write_byte(val, addr);\n#endif\n}\n\nstatic inline ssize_t nvram_read_bytes(char *buf, size_t count, loff_t *ppos)\n{\n\tssize_t nvram_size = nvram_get_size();\n\tloff_t i;\n\tchar *p = buf;\n\n\tif (nvram_size < 0)\n\t\treturn nvram_size;\n\tfor (i = *ppos; count > 0 && i < nvram_size; ++i, ++p, --count)\n\t\t*p = nvram_read_byte(i);\n\t*ppos = i;\n\treturn p - buf;\n}\n\nstatic inline ssize_t nvram_write_bytes(char *buf, size_t count, loff_t *ppos)\n{\n\tssize_t nvram_size = nvram_get_size();\n\tloff_t i;\n\tchar *p = buf;\n\n\tif (nvram_size < 0)\n\t\treturn nvram_size;\n\tfor (i = *ppos; count > 0 && i < nvram_size; ++i, ++p, --count)\n\t\tnvram_write_byte(*p, i);\n\t*ppos = i;\n\treturn p - buf;\n}\n\nstatic inline ssize_t nvram_read(char *buf, size_t count, loff_t *ppos)\n{\n#ifdef CONFIG_PPC\n\tif (ppc_md.nvram_read)\n\t\treturn ppc_md.nvram_read(buf, count, ppos);\n#else\n\tif (arch_nvram_ops.read)\n\t\treturn arch_nvram_ops.read(buf, count, ppos);\n#endif\n\treturn nvram_read_bytes(buf, count, ppos);\n}\n\nstatic inline ssize_t nvram_write(char *buf, size_t count, loff_t *ppos)\n{\n#ifdef CONFIG_PPC\n\tif (ppc_md.nvram_write)\n\t\treturn ppc_md.nvram_write(buf, count, ppos);\n#else\n\tif (arch_nvram_ops.write)\n\t\treturn arch_nvram_ops.write(buf, count, ppos);\n#endif\n\treturn nvram_write_bytes(buf, count, ppos);\n}\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}