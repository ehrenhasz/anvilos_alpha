{
  "module_name": "of.h",
  "hash_id": "9d6756858a68c1080e4fad64bad2be535d7bc2eafe45f32a839c0eebba09ec8b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/of.h",
  "human_readable_source": " \n#ifndef _LINUX_OF_H\n#define _LINUX_OF_H\n \n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/kobject.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/list.h>\n\n#include <asm/byteorder.h>\n\ntypedef u32 phandle;\ntypedef u32 ihandle;\n\nstruct property {\n\tchar\t*name;\n\tint\tlength;\n\tvoid\t*value;\n\tstruct property *next;\n#if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)\n\tunsigned long _flags;\n#endif\n#if defined(CONFIG_OF_PROMTREE)\n\tunsigned int unique_id;\n#endif\n#if defined(CONFIG_OF_KOBJ)\n\tstruct bin_attribute attr;\n#endif\n};\n\n#if defined(CONFIG_SPARC)\nstruct of_irq_controller;\n#endif\n\nstruct device_node {\n\tconst char *name;\n\tphandle phandle;\n\tconst char *full_name;\n\tstruct fwnode_handle fwnode;\n\n\tstruct\tproperty *properties;\n\tstruct\tproperty *deadprops;\t \n\tstruct\tdevice_node *parent;\n\tstruct\tdevice_node *child;\n\tstruct\tdevice_node *sibling;\n#if defined(CONFIG_OF_KOBJ)\n\tstruct\tkobject kobj;\n#endif\n\tunsigned long _flags;\n\tvoid\t*data;\n#if defined(CONFIG_SPARC)\n\tunsigned int unique_id;\n\tstruct of_irq_controller *irq_trans;\n#endif\n};\n\n#define MAX_PHANDLE_ARGS 16\nstruct of_phandle_args {\n\tstruct device_node *np;\n\tint args_count;\n\tuint32_t args[MAX_PHANDLE_ARGS];\n};\n\nstruct of_phandle_iterator {\n\t \n\tconst char *cells_name;\n\tint cell_count;\n\tconst struct device_node *parent;\n\n\t \n\tconst __be32 *list_end;\n\tconst __be32 *phandle_end;\n\n\t \n\tconst __be32 *cur;\n\tuint32_t cur_count;\n\tphandle phandle;\n\tstruct device_node *node;\n};\n\nstruct of_reconfig_data {\n\tstruct device_node\t*dn;\n\tstruct property\t\t*prop;\n\tstruct property\t\t*old_prop;\n};\n\nextern const struct kobj_type of_node_ktype;\nextern const struct fwnode_operations of_fwnode_ops;\n\n \nstatic inline void of_node_init(struct device_node *node)\n{\n#if defined(CONFIG_OF_KOBJ)\n\tkobject_init(&node->kobj, &of_node_ktype);\n#endif\n\tfwnode_init(&node->fwnode, &of_fwnode_ops);\n}\n\n#if defined(CONFIG_OF_KOBJ)\n#define of_node_kobj(n) (&(n)->kobj)\n#else\n#define of_node_kobj(n) NULL\n#endif\n\n#ifdef CONFIG_OF_DYNAMIC\nextern struct device_node *of_node_get(struct device_node *node);\nextern void of_node_put(struct device_node *node);\n#else  \n \nstatic inline struct device_node *of_node_get(struct device_node *node)\n{\n\treturn node;\n}\nstatic inline void of_node_put(struct device_node *node) { }\n#endif  \n\n \nextern struct device_node *of_root;\nextern struct device_node *of_chosen;\nextern struct device_node *of_aliases;\nextern struct device_node *of_stdout;\n\n \n#define OF_DYNAMIC\t\t1  \n#define OF_DETACHED\t\t2  \n#define OF_POPULATED\t\t3  \n#define OF_POPULATED_BUS\t4  \n#define OF_OVERLAY\t\t5  \n#define OF_OVERLAY_FREE_CSET\t6  \n\n#define OF_BAD_ADDR\t((u64)-1)\n\n#ifdef CONFIG_OF\nvoid of_core_init(void);\n\nstatic inline bool is_of_node(const struct fwnode_handle *fwnode)\n{\n\treturn !IS_ERR_OR_NULL(fwnode) && fwnode->ops == &of_fwnode_ops;\n}\n\n#define to_of_node(__fwnode)\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\ttypeof(__fwnode) __to_of_node_fwnode = (__fwnode);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tis_of_node(__to_of_node_fwnode) ?\t\t\t\\\n\t\t\tcontainer_of(__to_of_node_fwnode,\t\t\\\n\t\t\t\t     struct device_node, fwnode) :\t\\\n\t\t\tNULL;\t\t\t\t\t\t\\\n\t})\n\n#define of_fwnode_handle(node)\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\ttypeof(node) __of_fwnode_handle_node = (node);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__of_fwnode_handle_node ?\t\t\t\t\\\n\t\t\t&__of_fwnode_handle_node->fwnode : NULL;\t\\\n\t})\n\nstatic inline bool of_have_populated_dt(void)\n{\n\treturn of_root != NULL;\n}\n\nstatic inline bool of_node_is_root(const struct device_node *node)\n{\n\treturn node && (node->parent == NULL);\n}\n\nstatic inline int of_node_check_flag(const struct device_node *n, unsigned long flag)\n{\n\treturn test_bit(flag, &n->_flags);\n}\n\nstatic inline int of_node_test_and_set_flag(struct device_node *n,\n\t\t\t\t\t    unsigned long flag)\n{\n\treturn test_and_set_bit(flag, &n->_flags);\n}\n\nstatic inline void of_node_set_flag(struct device_node *n, unsigned long flag)\n{\n\tset_bit(flag, &n->_flags);\n}\n\nstatic inline void of_node_clear_flag(struct device_node *n, unsigned long flag)\n{\n\tclear_bit(flag, &n->_flags);\n}\n\n#if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)\nstatic inline int of_property_check_flag(const struct property *p, unsigned long flag)\n{\n\treturn test_bit(flag, &p->_flags);\n}\n\nstatic inline void of_property_set_flag(struct property *p, unsigned long flag)\n{\n\tset_bit(flag, &p->_flags);\n}\n\nstatic inline void of_property_clear_flag(struct property *p, unsigned long flag)\n{\n\tclear_bit(flag, &p->_flags);\n}\n#endif\n\nextern struct device_node *__of_find_all_nodes(struct device_node *prev);\nextern struct device_node *of_find_all_nodes(struct device_node *prev);\n\n \n\n \nstatic inline u64 of_read_number(const __be32 *cell, int size)\n{\n\tu64 r = 0;\n\tfor (; size--; cell++)\n\t\tr = (r << 32) | be32_to_cpu(*cell);\n\treturn r;\n}\n\n \nstatic inline unsigned long of_read_ulong(const __be32 *cell, int size)\n{\n\t \n\treturn of_read_number(cell, size);\n}\n\n#if defined(CONFIG_SPARC)\n#include <asm/prom.h>\n#endif\n\n#define OF_IS_DYNAMIC(x) test_bit(OF_DYNAMIC, &x->_flags)\n#define OF_MARK_DYNAMIC(x) set_bit(OF_DYNAMIC, &x->_flags)\n\nextern bool of_node_name_eq(const struct device_node *np, const char *name);\nextern bool of_node_name_prefix(const struct device_node *np, const char *prefix);\n\nstatic inline const char *of_node_full_name(const struct device_node *np)\n{\n\treturn np ? np->full_name : \"<no-node>\";\n}\n\n#define for_each_of_allnodes_from(from, dn) \\\n\tfor (dn = __of_find_all_nodes(from); dn; dn = __of_find_all_nodes(dn))\n#define for_each_of_allnodes(dn) for_each_of_allnodes_from(NULL, dn)\nextern struct device_node *of_find_node_by_name(struct device_node *from,\n\tconst char *name);\nextern struct device_node *of_find_node_by_type(struct device_node *from,\n\tconst char *type);\nextern struct device_node *of_find_compatible_node(struct device_node *from,\n\tconst char *type, const char *compat);\nextern struct device_node *of_find_matching_node_and_match(\n\tstruct device_node *from,\n\tconst struct of_device_id *matches,\n\tconst struct of_device_id **match);\n\nextern struct device_node *of_find_node_opts_by_path(const char *path,\n\tconst char **opts);\nstatic inline struct device_node *of_find_node_by_path(const char *path)\n{\n\treturn of_find_node_opts_by_path(path, NULL);\n}\n\nextern struct device_node *of_find_node_by_phandle(phandle handle);\nextern struct device_node *of_get_parent(const struct device_node *node);\nextern struct device_node *of_get_next_parent(struct device_node *node);\nextern struct device_node *of_get_next_child(const struct device_node *node,\n\t\t\t\t\t     struct device_node *prev);\nextern struct device_node *of_get_next_available_child(\n\tconst struct device_node *node, struct device_node *prev);\n\nextern struct device_node *of_get_compatible_child(const struct device_node *parent,\n\t\t\t\t\tconst char *compatible);\nextern struct device_node *of_get_child_by_name(const struct device_node *node,\n\t\t\t\t\tconst char *name);\n\n \nextern struct device_node *of_find_next_cache_node(const struct device_node *);\nextern int of_find_last_cache_level(unsigned int cpu);\nextern struct device_node *of_find_node_with_property(\n\tstruct device_node *from, const char *prop_name);\n\nextern struct property *of_find_property(const struct device_node *np,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t int *lenp);\nextern int of_property_count_elems_of_size(const struct device_node *np,\n\t\t\t\tconst char *propname, int elem_size);\nextern int of_property_read_u32_index(const struct device_node *np,\n\t\t\t\t       const char *propname,\n\t\t\t\t       u32 index, u32 *out_value);\nextern int of_property_read_u64_index(const struct device_node *np,\n\t\t\t\t       const char *propname,\n\t\t\t\t       u32 index, u64 *out_value);\nextern int of_property_read_variable_u8_array(const struct device_node *np,\n\t\t\t\t\tconst char *propname, u8 *out_values,\n\t\t\t\t\tsize_t sz_min, size_t sz_max);\nextern int of_property_read_variable_u16_array(const struct device_node *np,\n\t\t\t\t\tconst char *propname, u16 *out_values,\n\t\t\t\t\tsize_t sz_min, size_t sz_max);\nextern int of_property_read_variable_u32_array(const struct device_node *np,\n\t\t\t\t\tconst char *propname,\n\t\t\t\t\tu32 *out_values,\n\t\t\t\t\tsize_t sz_min,\n\t\t\t\t\tsize_t sz_max);\nextern int of_property_read_u64(const struct device_node *np,\n\t\t\t\tconst char *propname, u64 *out_value);\nextern int of_property_read_variable_u64_array(const struct device_node *np,\n\t\t\t\t\tconst char *propname,\n\t\t\t\t\tu64 *out_values,\n\t\t\t\t\tsize_t sz_min,\n\t\t\t\t\tsize_t sz_max);\n\nextern int of_property_read_string(const struct device_node *np,\n\t\t\t\t   const char *propname,\n\t\t\t\t   const char **out_string);\nextern int of_property_match_string(const struct device_node *np,\n\t\t\t\t    const char *propname,\n\t\t\t\t    const char *string);\nextern int of_property_read_string_helper(const struct device_node *np,\n\t\t\t\t\t      const char *propname,\n\t\t\t\t\t      const char **out_strs, size_t sz, int index);\nextern int of_device_is_compatible(const struct device_node *device,\n\t\t\t\t   const char *);\nextern int of_device_compatible_match(const struct device_node *device,\n\t\t\t\t      const char *const *compat);\nextern bool of_device_is_available(const struct device_node *device);\nextern bool of_device_is_big_endian(const struct device_node *device);\nextern const void *of_get_property(const struct device_node *node,\n\t\t\t\tconst char *name,\n\t\t\t\tint *lenp);\nextern struct device_node *of_get_cpu_node(int cpu, unsigned int *thread);\nextern struct device_node *of_cpu_device_node_get(int cpu);\nextern int of_cpu_node_to_id(struct device_node *np);\nextern struct device_node *of_get_next_cpu_node(struct device_node *prev);\nextern struct device_node *of_get_cpu_state_node(struct device_node *cpu_node,\n\t\t\t\t\t\t int index);\nextern u64 of_get_cpu_hwid(struct device_node *cpun, unsigned int thread);\n\n#define for_each_property_of_node(dn, pp) \\\n\tfor (pp = dn->properties; pp != NULL; pp = pp->next)\n\nextern int of_n_addr_cells(struct device_node *np);\nextern int of_n_size_cells(struct device_node *np);\nextern const struct of_device_id *of_match_node(\n\tconst struct of_device_id *matches, const struct device_node *node);\nextern const void *of_device_get_match_data(const struct device *dev);\nextern int of_alias_from_compatible(const struct device_node *node, char *alias,\n\t\t\t\t    int len);\nextern void of_print_phandle_args(const char *msg, const struct of_phandle_args *args);\nextern int __of_parse_phandle_with_args(const struct device_node *np,\n\tconst char *list_name, const char *cells_name, int cell_count,\n\tint index, struct of_phandle_args *out_args);\nextern int of_parse_phandle_with_args_map(const struct device_node *np,\n\tconst char *list_name, const char *stem_name, int index,\n\tstruct of_phandle_args *out_args);\nextern int of_count_phandle_with_args(const struct device_node *np,\n\tconst char *list_name, const char *cells_name);\n\n \nextern ssize_t of_modalias(const struct device_node *np, char *str, ssize_t len);\nextern int of_request_module(const struct device_node *np);\n\n \nextern int of_phandle_iterator_init(struct of_phandle_iterator *it,\n\t\t\t\t    const struct device_node *np,\n\t\t\t\t    const char *list_name,\n\t\t\t\t    const char *cells_name,\n\t\t\t\t    int cell_count);\n\nextern int of_phandle_iterator_next(struct of_phandle_iterator *it);\nextern int of_phandle_iterator_args(struct of_phandle_iterator *it,\n\t\t\t\t    uint32_t *args,\n\t\t\t\t    int size);\n\nextern void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align));\nextern int of_alias_get_id(struct device_node *np, const char *stem);\nextern int of_alias_get_highest_id(const char *stem);\n\nextern int of_machine_is_compatible(const char *compat);\n\nextern int of_add_property(struct device_node *np, struct property *prop);\nextern int of_remove_property(struct device_node *np, struct property *prop);\nextern int of_update_property(struct device_node *np, struct property *newprop);\n\n \n#define OF_RECONFIG_ATTACH_NODE\t\t0x0001\n#define OF_RECONFIG_DETACH_NODE\t\t0x0002\n#define OF_RECONFIG_ADD_PROPERTY\t0x0003\n#define OF_RECONFIG_REMOVE_PROPERTY\t0x0004\n#define OF_RECONFIG_UPDATE_PROPERTY\t0x0005\n\nextern int of_attach_node(struct device_node *);\nextern int of_detach_node(struct device_node *);\n\n#define of_match_ptr(_ptr)\t(_ptr)\n\n \nconst __be32 *of_prop_next_u32(struct property *prop, const __be32 *cur,\n\t\t\t       u32 *pu);\n \nconst char *of_prop_next_string(struct property *prop, const char *cur);\n\nbool of_console_check(struct device_node *dn, char *name, int index);\n\nint of_map_id(struct device_node *np, u32 id,\n\t       const char *map_name, const char *map_mask_name,\n\t       struct device_node **target, u32 *id_out);\n\nphys_addr_t of_dma_get_max_cpu_address(struct device_node *np);\n\nstruct kimage;\nvoid *of_kexec_alloc_and_setup_fdt(const struct kimage *image,\n\t\t\t\t   unsigned long initrd_load_addr,\n\t\t\t\t   unsigned long initrd_len,\n\t\t\t\t   const char *cmdline, size_t extra_fdt_size);\n#else  \n\nstatic inline void of_core_init(void)\n{\n}\n\nstatic inline bool is_of_node(const struct fwnode_handle *fwnode)\n{\n\treturn false;\n}\n\nstatic inline struct device_node *to_of_node(const struct fwnode_handle *fwnode)\n{\n\treturn NULL;\n}\n\nstatic inline bool of_node_name_eq(const struct device_node *np, const char *name)\n{\n\treturn false;\n}\n\nstatic inline bool of_node_name_prefix(const struct device_node *np, const char *prefix)\n{\n\treturn false;\n}\n\nstatic inline const char* of_node_full_name(const struct device_node *np)\n{\n\treturn \"<no-node>\";\n}\n\nstatic inline struct device_node *of_find_node_by_name(struct device_node *from,\n\tconst char *name)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_find_node_by_type(struct device_node *from,\n\tconst char *type)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_find_matching_node_and_match(\n\tstruct device_node *from,\n\tconst struct of_device_id *matches,\n\tconst struct of_device_id **match)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_find_node_by_path(const char *path)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_find_node_opts_by_path(const char *path,\n\tconst char **opts)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_find_node_by_phandle(phandle handle)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_get_parent(const struct device_node *node)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_get_next_parent(struct device_node *node)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_get_next_child(\n\tconst struct device_node *node, struct device_node *prev)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_get_next_available_child(\n\tconst struct device_node *node, struct device_node *prev)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_find_node_with_property(\n\tstruct device_node *from, const char *prop_name)\n{\n\treturn NULL;\n}\n\n#define of_fwnode_handle(node) NULL\n\nstatic inline bool of_have_populated_dt(void)\n{\n\treturn false;\n}\n\nstatic inline struct device_node *of_get_compatible_child(const struct device_node *parent,\n\t\t\t\t\tconst char *compatible)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_get_child_by_name(\n\t\t\t\t\tconst struct device_node *node,\n\t\t\t\t\tconst char *name)\n{\n\treturn NULL;\n}\n\nstatic inline int of_device_is_compatible(const struct device_node *device,\n\t\t\t\t\t  const char *name)\n{\n\treturn 0;\n}\n\nstatic inline  int of_device_compatible_match(const struct device_node *device,\n\t\t\t\t\t      const char *const *compat)\n{\n\treturn 0;\n}\n\nstatic inline bool of_device_is_available(const struct device_node *device)\n{\n\treturn false;\n}\n\nstatic inline bool of_device_is_big_endian(const struct device_node *device)\n{\n\treturn false;\n}\n\nstatic inline struct property *of_find_property(const struct device_node *np,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tint *lenp)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_find_compatible_node(\n\t\t\t\t\t\tstruct device_node *from,\n\t\t\t\t\t\tconst char *type,\n\t\t\t\t\t\tconst char *compat)\n{\n\treturn NULL;\n}\n\nstatic inline int of_property_count_elems_of_size(const struct device_node *np,\n\t\t\tconst char *propname, int elem_size)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_property_read_u32_index(const struct device_node *np,\n\t\t\tconst char *propname, u32 index, u32 *out_value)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_property_read_u64_index(const struct device_node *np,\n\t\t\tconst char *propname, u32 index, u64 *out_value)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline const void *of_get_property(const struct device_node *node,\n\t\t\t\tconst char *name,\n\t\t\t\tint *lenp)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_get_cpu_node(int cpu,\n\t\t\t\t\tunsigned int *thread)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_cpu_device_node_get(int cpu)\n{\n\treturn NULL;\n}\n\nstatic inline int of_cpu_node_to_id(struct device_node *np)\n{\n\treturn -ENODEV;\n}\n\nstatic inline struct device_node *of_get_next_cpu_node(struct device_node *prev)\n{\n\treturn NULL;\n}\n\nstatic inline struct device_node *of_get_cpu_state_node(struct device_node *cpu_node,\n\t\t\t\t\tint index)\n{\n\treturn NULL;\n}\n\nstatic inline int of_n_addr_cells(struct device_node *np)\n{\n\treturn 0;\n\n}\nstatic inline int of_n_size_cells(struct device_node *np)\n{\n\treturn 0;\n}\n\nstatic inline int of_property_read_variable_u8_array(const struct device_node *np,\n\t\t\t\t\tconst char *propname, u8 *out_values,\n\t\t\t\t\tsize_t sz_min, size_t sz_max)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_property_read_variable_u16_array(const struct device_node *np,\n\t\t\t\t\tconst char *propname, u16 *out_values,\n\t\t\t\t\tsize_t sz_min, size_t sz_max)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_property_read_variable_u32_array(const struct device_node *np,\n\t\t\t\t\tconst char *propname,\n\t\t\t\t\tu32 *out_values,\n\t\t\t\t\tsize_t sz_min,\n\t\t\t\t\tsize_t sz_max)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_property_read_u64(const struct device_node *np,\n\t\t\t\t       const char *propname, u64 *out_value)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_property_read_variable_u64_array(const struct device_node *np,\n\t\t\t\t\tconst char *propname,\n\t\t\t\t\tu64 *out_values,\n\t\t\t\t\tsize_t sz_min,\n\t\t\t\t\tsize_t sz_max)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_property_read_string(const struct device_node *np,\n\t\t\t\t\t  const char *propname,\n\t\t\t\t\t  const char **out_string)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_property_match_string(const struct device_node *np,\n\t\t\t\t\t   const char *propname,\n\t\t\t\t\t   const char *string)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_property_read_string_helper(const struct device_node *np,\n\t\t\t\t\t\t const char *propname,\n\t\t\t\t\t\t const char **out_strs, size_t sz, int index)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int __of_parse_phandle_with_args(const struct device_node *np,\n\t\t\t\t\t       const char *list_name,\n\t\t\t\t\t       const char *cells_name,\n\t\t\t\t\t       int cell_count,\n\t\t\t\t\t       int index,\n\t\t\t\t\t       struct of_phandle_args *out_args)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_parse_phandle_with_args_map(const struct device_node *np,\n\t\t\t\t\t\t const char *list_name,\n\t\t\t\t\t\t const char *stem_name,\n\t\t\t\t\t\t int index,\n\t\t\t\t\t\t struct of_phandle_args *out_args)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_count_phandle_with_args(const struct device_node *np,\n\t\t\t\t\t     const char *list_name,\n\t\t\t\t\t     const char *cells_name)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline ssize_t of_modalias(const struct device_node *np, char *str,\n\t\t\t\t  ssize_t len)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int of_request_module(const struct device_node *np)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int of_phandle_iterator_init(struct of_phandle_iterator *it,\n\t\t\t\t\t   const struct device_node *np,\n\t\t\t\t\t   const char *list_name,\n\t\t\t\t\t   const char *cells_name,\n\t\t\t\t\t   int cell_count)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_phandle_iterator_next(struct of_phandle_iterator *it)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_phandle_iterator_args(struct of_phandle_iterator *it,\n\t\t\t\t\t   uint32_t *args,\n\t\t\t\t\t   int size)\n{\n\treturn 0;\n}\n\nstatic inline int of_alias_get_id(struct device_node *np, const char *stem)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_alias_get_highest_id(const char *stem)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int of_machine_is_compatible(const char *compat)\n{\n\treturn 0;\n}\n\nstatic inline int of_add_property(struct device_node *np, struct property *prop)\n{\n\treturn 0;\n}\n\nstatic inline int of_remove_property(struct device_node *np, struct property *prop)\n{\n\treturn 0;\n}\n\nstatic inline bool of_console_check(const struct device_node *dn, const char *name, int index)\n{\n\treturn false;\n}\n\nstatic inline const __be32 *of_prop_next_u32(struct property *prop,\n\t\tconst __be32 *cur, u32 *pu)\n{\n\treturn NULL;\n}\n\nstatic inline const char *of_prop_next_string(struct property *prop,\n\t\tconst char *cur)\n{\n\treturn NULL;\n}\n\nstatic inline int of_node_check_flag(struct device_node *n, unsigned long flag)\n{\n\treturn 0;\n}\n\nstatic inline int of_node_test_and_set_flag(struct device_node *n,\n\t\t\t\t\t    unsigned long flag)\n{\n\treturn 0;\n}\n\nstatic inline void of_node_set_flag(struct device_node *n, unsigned long flag)\n{\n}\n\nstatic inline void of_node_clear_flag(struct device_node *n, unsigned long flag)\n{\n}\n\nstatic inline int of_property_check_flag(const struct property *p,\n\t\t\t\t\t unsigned long flag)\n{\n\treturn 0;\n}\n\nstatic inline void of_property_set_flag(struct property *p, unsigned long flag)\n{\n}\n\nstatic inline void of_property_clear_flag(struct property *p, unsigned long flag)\n{\n}\n\nstatic inline int of_map_id(struct device_node *np, u32 id,\n\t\t\t     const char *map_name, const char *map_mask_name,\n\t\t\t     struct device_node **target, u32 *id_out)\n{\n\treturn -EINVAL;\n}\n\nstatic inline phys_addr_t of_dma_get_max_cpu_address(struct device_node *np)\n{\n\treturn PHYS_ADDR_MAX;\n}\n\nstatic inline const void *of_device_get_match_data(const struct device *dev)\n{\n\treturn NULL;\n}\n\n#define of_match_ptr(_ptr)\tNULL\n#define of_match_node(_matches, _node)\tNULL\n#endif  \n\n \n#if !defined(of_compat_cmp)\n#define of_compat_cmp(s1, s2, l)\tstrcasecmp((s1), (s2))\n#define of_prop_cmp(s1, s2)\t\tstrcmp((s1), (s2))\n#define of_node_cmp(s1, s2)\t\tstrcasecmp((s1), (s2))\n#endif\n\nstatic inline int of_prop_val_eq(struct property *p1, struct property *p2)\n{\n\treturn p1->length == p2->length &&\n\t       !memcmp(p1->value, p2->value, (size_t)p1->length);\n}\n\n#if defined(CONFIG_OF) && defined(CONFIG_NUMA)\nextern int of_node_to_nid(struct device_node *np);\n#else\nstatic inline int of_node_to_nid(struct device_node *device)\n{\n\treturn NUMA_NO_NODE;\n}\n#endif\n\n#ifdef CONFIG_OF_NUMA\nextern int of_numa_init(void);\n#else\nstatic inline int of_numa_init(void)\n{\n\treturn -ENOSYS;\n}\n#endif\n\nstatic inline struct device_node *of_find_matching_node(\n\tstruct device_node *from,\n\tconst struct of_device_id *matches)\n{\n\treturn of_find_matching_node_and_match(from, matches, NULL);\n}\n\nstatic inline const char *of_node_get_device_type(const struct device_node *np)\n{\n\treturn of_get_property(np, \"device_type\", NULL);\n}\n\nstatic inline bool of_node_is_type(const struct device_node *np, const char *type)\n{\n\tconst char *match = of_node_get_device_type(np);\n\n\treturn np && match && type && !strcmp(match, type);\n}\n\n \nstatic inline struct device_node *of_parse_phandle(const struct device_node *np,\n\t\t\t\t\t\t   const char *phandle_name,\n\t\t\t\t\t\t   int index)\n{\n\tstruct of_phandle_args args;\n\n\tif (__of_parse_phandle_with_args(np, phandle_name, NULL, 0,\n\t\t\t\t\t index, &args))\n\t\treturn NULL;\n\n\treturn args.np;\n}\n\n \nstatic inline int of_parse_phandle_with_args(const struct device_node *np,\n\t\t\t\t\t     const char *list_name,\n\t\t\t\t\t     const char *cells_name,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     struct of_phandle_args *out_args)\n{\n\tint cell_count = -1;\n\n\t \n\tif (!cells_name)\n\t\tcell_count = 0;\n\n\treturn __of_parse_phandle_with_args(np, list_name, cells_name,\n\t\t\t\t\t    cell_count, index, out_args);\n}\n\n \nstatic inline int of_parse_phandle_with_fixed_args(const struct device_node *np,\n\t\t\t\t\t\t   const char *list_name,\n\t\t\t\t\t\t   int cell_count,\n\t\t\t\t\t\t   int index,\n\t\t\t\t\t\t   struct of_phandle_args *out_args)\n{\n\treturn __of_parse_phandle_with_args(np, list_name, NULL, cell_count,\n\t\t\t\t\t    index, out_args);\n}\n\n \nstatic inline int of_parse_phandle_with_optional_args(const struct device_node *np,\n\t\t\t\t\t\t      const char *list_name,\n\t\t\t\t\t\t      const char *cells_name,\n\t\t\t\t\t\t      int index,\n\t\t\t\t\t\t      struct of_phandle_args *out_args)\n{\n\treturn __of_parse_phandle_with_args(np, list_name, cells_name,\n\t\t\t\t\t    0, index, out_args);\n}\n\n \nstatic inline int of_property_count_u8_elems(const struct device_node *np,\n\t\t\t\tconst char *propname)\n{\n\treturn of_property_count_elems_of_size(np, propname, sizeof(u8));\n}\n\n \nstatic inline int of_property_count_u16_elems(const struct device_node *np,\n\t\t\t\tconst char *propname)\n{\n\treturn of_property_count_elems_of_size(np, propname, sizeof(u16));\n}\n\n \nstatic inline int of_property_count_u32_elems(const struct device_node *np,\n\t\t\t\tconst char *propname)\n{\n\treturn of_property_count_elems_of_size(np, propname, sizeof(u32));\n}\n\n \nstatic inline int of_property_count_u64_elems(const struct device_node *np,\n\t\t\t\tconst char *propname)\n{\n\treturn of_property_count_elems_of_size(np, propname, sizeof(u64));\n}\n\n \nstatic inline int of_property_read_string_array(const struct device_node *np,\n\t\t\t\t\t\tconst char *propname, const char **out_strs,\n\t\t\t\t\t\tsize_t sz)\n{\n\treturn of_property_read_string_helper(np, propname, out_strs, sz, 0);\n}\n\n \nstatic inline int of_property_count_strings(const struct device_node *np,\n\t\t\t\t\t    const char *propname)\n{\n\treturn of_property_read_string_helper(np, propname, NULL, 0, 0);\n}\n\n \nstatic inline int of_property_read_string_index(const struct device_node *np,\n\t\t\t\t\t\tconst char *propname,\n\t\t\t\t\t\tint index, const char **output)\n{\n\tint rc = of_property_read_string_helper(np, propname, output, 1, index);\n\treturn rc < 0 ? rc : 0;\n}\n\n \nstatic inline bool of_property_read_bool(const struct device_node *np,\n\t\t\t\t\t const char *propname)\n{\n\tstruct property *prop = of_find_property(np, propname, NULL);\n\n\treturn prop ? true : false;\n}\n\n \nstatic inline bool of_property_present(const struct device_node *np, const char *propname)\n{\n\treturn of_property_read_bool(np, propname);\n}\n\n \nstatic inline int of_property_read_u8_array(const struct device_node *np,\n\t\t\t\t\t    const char *propname,\n\t\t\t\t\t    u8 *out_values, size_t sz)\n{\n\tint ret = of_property_read_variable_u8_array(np, propname, out_values,\n\t\t\t\t\t\t     sz, 0);\n\tif (ret >= 0)\n\t\treturn 0;\n\telse\n\t\treturn ret;\n}\n\n \nstatic inline int of_property_read_u16_array(const struct device_node *np,\n\t\t\t\t\t     const char *propname,\n\t\t\t\t\t     u16 *out_values, size_t sz)\n{\n\tint ret = of_property_read_variable_u16_array(np, propname, out_values,\n\t\t\t\t\t\t      sz, 0);\n\tif (ret >= 0)\n\t\treturn 0;\n\telse\n\t\treturn ret;\n}\n\n \nstatic inline int of_property_read_u32_array(const struct device_node *np,\n\t\t\t\t\t     const char *propname,\n\t\t\t\t\t     u32 *out_values, size_t sz)\n{\n\tint ret = of_property_read_variable_u32_array(np, propname, out_values,\n\t\t\t\t\t\t      sz, 0);\n\tif (ret >= 0)\n\t\treturn 0;\n\telse\n\t\treturn ret;\n}\n\n \nstatic inline int of_property_read_u64_array(const struct device_node *np,\n\t\t\t\t\t     const char *propname,\n\t\t\t\t\t     u64 *out_values, size_t sz)\n{\n\tint ret = of_property_read_variable_u64_array(np, propname, out_values,\n\t\t\t\t\t\t      sz, 0);\n\tif (ret >= 0)\n\t\treturn 0;\n\telse\n\t\treturn ret;\n}\n\nstatic inline int of_property_read_u8(const struct device_node *np,\n\t\t\t\t       const char *propname,\n\t\t\t\t       u8 *out_value)\n{\n\treturn of_property_read_u8_array(np, propname, out_value, 1);\n}\n\nstatic inline int of_property_read_u16(const struct device_node *np,\n\t\t\t\t       const char *propname,\n\t\t\t\t       u16 *out_value)\n{\n\treturn of_property_read_u16_array(np, propname, out_value, 1);\n}\n\nstatic inline int of_property_read_u32(const struct device_node *np,\n\t\t\t\t       const char *propname,\n\t\t\t\t       u32 *out_value)\n{\n\treturn of_property_read_u32_array(np, propname, out_value, 1);\n}\n\nstatic inline int of_property_read_s32(const struct device_node *np,\n\t\t\t\t       const char *propname,\n\t\t\t\t       s32 *out_value)\n{\n\treturn of_property_read_u32(np, propname, (u32*) out_value);\n}\n\n#define of_for_each_phandle(it, err, np, ln, cn, cc)\t\t\t\\\n\tfor (of_phandle_iterator_init((it), (np), (ln), (cn), (cc)),\t\\\n\t     err = of_phandle_iterator_next(it);\t\t\t\\\n\t     err == 0;\t\t\t\t\t\t\t\\\n\t     err = of_phandle_iterator_next(it))\n\n#define of_property_for_each_u32(np, propname, prop, p, u)\t\\\n\tfor (prop = of_find_property(np, propname, NULL),\t\\\n\t\tp = of_prop_next_u32(prop, NULL, &u);\t\t\\\n\t\tp;\t\t\t\t\t\t\\\n\t\tp = of_prop_next_u32(prop, p, &u))\n\n#define of_property_for_each_string(np, propname, prop, s)\t\\\n\tfor (prop = of_find_property(np, propname, NULL),\t\\\n\t\ts = of_prop_next_string(prop, NULL);\t\t\\\n\t\ts;\t\t\t\t\t\t\\\n\t\ts = of_prop_next_string(prop, s))\n\n#define for_each_node_by_name(dn, name) \\\n\tfor (dn = of_find_node_by_name(NULL, name); dn; \\\n\t     dn = of_find_node_by_name(dn, name))\n#define for_each_node_by_type(dn, type) \\\n\tfor (dn = of_find_node_by_type(NULL, type); dn; \\\n\t     dn = of_find_node_by_type(dn, type))\n#define for_each_compatible_node(dn, type, compatible) \\\n\tfor (dn = of_find_compatible_node(NULL, type, compatible); dn; \\\n\t     dn = of_find_compatible_node(dn, type, compatible))\n#define for_each_matching_node(dn, matches) \\\n\tfor (dn = of_find_matching_node(NULL, matches); dn; \\\n\t     dn = of_find_matching_node(dn, matches))\n#define for_each_matching_node_and_match(dn, matches, match) \\\n\tfor (dn = of_find_matching_node_and_match(NULL, matches, match); \\\n\t     dn; dn = of_find_matching_node_and_match(dn, matches, match))\n\n#define for_each_child_of_node(parent, child) \\\n\tfor (child = of_get_next_child(parent, NULL); child != NULL; \\\n\t     child = of_get_next_child(parent, child))\n#define for_each_available_child_of_node(parent, child) \\\n\tfor (child = of_get_next_available_child(parent, NULL); child != NULL; \\\n\t     child = of_get_next_available_child(parent, child))\n\n#define for_each_of_cpu_node(cpu) \\\n\tfor (cpu = of_get_next_cpu_node(NULL); cpu != NULL; \\\n\t     cpu = of_get_next_cpu_node(cpu))\n\n#define for_each_node_with_property(dn, prop_name) \\\n\tfor (dn = of_find_node_with_property(NULL, prop_name); dn; \\\n\t     dn = of_find_node_with_property(dn, prop_name))\n\nstatic inline int of_get_child_count(const struct device_node *np)\n{\n\tstruct device_node *child;\n\tint num = 0;\n\n\tfor_each_child_of_node(np, child)\n\t\tnum++;\n\n\treturn num;\n}\n\nstatic inline int of_get_available_child_count(const struct device_node *np)\n{\n\tstruct device_node *child;\n\tint num = 0;\n\n\tfor_each_available_child_of_node(np, child)\n\t\tnum++;\n\n\treturn num;\n}\n\n#define _OF_DECLARE_STUB(table, name, compat, fn, fn_type)\t\t\\\n\tstatic const struct of_device_id __of_table_##name\t\t\\\n\t\t__attribute__((unused))\t\t\t\t\t\\\n\t\t = { .compatible = compat,\t\t\t\t\\\n\t\t     .data = (fn == (fn_type)NULL) ? fn : fn }\n\n#if defined(CONFIG_OF) && !defined(MODULE)\n#define _OF_DECLARE(table, name, compat, fn, fn_type)\t\t\t\\\n\tstatic const struct of_device_id __of_table_##name\t\t\\\n\t\t__used __section(\"__\" #table \"_of_table\")\t\t\\\n\t\t__aligned(__alignof__(struct of_device_id))\t\t\\\n\t\t = { .compatible = compat,\t\t\t\t\\\n\t\t     .data = (fn == (fn_type)NULL) ? fn : fn  }\n#else\n#define _OF_DECLARE(table, name, compat, fn, fn_type)\t\t\t\\\n\t_OF_DECLARE_STUB(table, name, compat, fn, fn_type)\n#endif\n\ntypedef int (*of_init_fn_2)(struct device_node *, struct device_node *);\ntypedef int (*of_init_fn_1_ret)(struct device_node *);\ntypedef void (*of_init_fn_1)(struct device_node *);\n\n#define OF_DECLARE_1(table, name, compat, fn) \\\n\t\t_OF_DECLARE(table, name, compat, fn, of_init_fn_1)\n#define OF_DECLARE_1_RET(table, name, compat, fn) \\\n\t\t_OF_DECLARE(table, name, compat, fn, of_init_fn_1_ret)\n#define OF_DECLARE_2(table, name, compat, fn) \\\n\t\t_OF_DECLARE(table, name, compat, fn, of_init_fn_2)\n\n \nstruct of_changeset_entry {\n\tstruct list_head node;\n\tunsigned long action;\n\tstruct device_node *np;\n\tstruct property *prop;\n\tstruct property *old_prop;\n};\n\n \nstruct of_changeset {\n\tstruct list_head entries;\n};\n\nenum of_reconfig_change {\n\tOF_RECONFIG_NO_CHANGE = 0,\n\tOF_RECONFIG_CHANGE_ADD,\n\tOF_RECONFIG_CHANGE_REMOVE,\n};\n\nstruct notifier_block;\n\n#ifdef CONFIG_OF_DYNAMIC\nextern int of_reconfig_notifier_register(struct notifier_block *);\nextern int of_reconfig_notifier_unregister(struct notifier_block *);\nextern int of_reconfig_notify(unsigned long, struct of_reconfig_data *rd);\nextern int of_reconfig_get_state_change(unsigned long action,\n\t\t\t\t\tstruct of_reconfig_data *arg);\n\nextern void of_changeset_init(struct of_changeset *ocs);\nextern void of_changeset_destroy(struct of_changeset *ocs);\nextern int of_changeset_apply(struct of_changeset *ocs);\nextern int of_changeset_revert(struct of_changeset *ocs);\nextern int of_changeset_action(struct of_changeset *ocs,\n\t\tunsigned long action, struct device_node *np,\n\t\tstruct property *prop);\n\nstatic inline int of_changeset_attach_node(struct of_changeset *ocs,\n\t\tstruct device_node *np)\n{\n\treturn of_changeset_action(ocs, OF_RECONFIG_ATTACH_NODE, np, NULL);\n}\n\nstatic inline int of_changeset_detach_node(struct of_changeset *ocs,\n\t\tstruct device_node *np)\n{\n\treturn of_changeset_action(ocs, OF_RECONFIG_DETACH_NODE, np, NULL);\n}\n\nstatic inline int of_changeset_add_property(struct of_changeset *ocs,\n\t\tstruct device_node *np, struct property *prop)\n{\n\treturn of_changeset_action(ocs, OF_RECONFIG_ADD_PROPERTY, np, prop);\n}\n\nstatic inline int of_changeset_remove_property(struct of_changeset *ocs,\n\t\tstruct device_node *np, struct property *prop)\n{\n\treturn of_changeset_action(ocs, OF_RECONFIG_REMOVE_PROPERTY, np, prop);\n}\n\nstatic inline int of_changeset_update_property(struct of_changeset *ocs,\n\t\tstruct device_node *np, struct property *prop)\n{\n\treturn of_changeset_action(ocs, OF_RECONFIG_UPDATE_PROPERTY, np, prop);\n}\n\nstruct device_node *of_changeset_create_node(struct of_changeset *ocs,\n\t\t\t\t\t     struct device_node *parent,\n\t\t\t\t\t     const char *full_name);\nint of_changeset_add_prop_string(struct of_changeset *ocs,\n\t\t\t\t struct device_node *np,\n\t\t\t\t const char *prop_name, const char *str);\nint of_changeset_add_prop_string_array(struct of_changeset *ocs,\n\t\t\t\t       struct device_node *np,\n\t\t\t\t       const char *prop_name,\n\t\t\t\t       const char **str_array, size_t sz);\nint of_changeset_add_prop_u32_array(struct of_changeset *ocs,\n\t\t\t\t    struct device_node *np,\n\t\t\t\t    const char *prop_name,\n\t\t\t\t    const u32 *array, size_t sz);\nstatic inline int of_changeset_add_prop_u32(struct of_changeset *ocs,\n\t\t\t\t\t    struct device_node *np,\n\t\t\t\t\t    const char *prop_name,\n\t\t\t\t\t    const u32 val)\n{\n\treturn of_changeset_add_prop_u32_array(ocs, np, prop_name, &val, 1);\n}\n\n#else  \nstatic inline int of_reconfig_notifier_register(struct notifier_block *nb)\n{\n\treturn -EINVAL;\n}\nstatic inline int of_reconfig_notifier_unregister(struct notifier_block *nb)\n{\n\treturn -EINVAL;\n}\nstatic inline int of_reconfig_notify(unsigned long action,\n\t\t\t\t     struct of_reconfig_data *arg)\n{\n\treturn -EINVAL;\n}\nstatic inline int of_reconfig_get_state_change(unsigned long action,\n\t\t\t\t\t\tstruct of_reconfig_data *arg)\n{\n\treturn -EINVAL;\n}\n#endif  \n\n \nstatic inline bool of_device_is_system_power_controller(const struct device_node *np)\n{\n\treturn of_property_read_bool(np, \"system-power-controller\");\n}\n\n \n\nenum of_overlay_notify_action {\n\tOF_OVERLAY_INIT = 0,\t \n\tOF_OVERLAY_PRE_APPLY,\n\tOF_OVERLAY_POST_APPLY,\n\tOF_OVERLAY_PRE_REMOVE,\n\tOF_OVERLAY_POST_REMOVE,\n};\n\nstatic inline const char *of_overlay_action_name(enum of_overlay_notify_action action)\n{\n\tstatic const char *const of_overlay_action_name[] = {\n\t\t\"init\",\n\t\t\"pre-apply\",\n\t\t\"post-apply\",\n\t\t\"pre-remove\",\n\t\t\"post-remove\",\n\t};\n\n\treturn of_overlay_action_name[action];\n}\n\nstruct of_overlay_notify_data {\n\tstruct device_node *overlay;\n\tstruct device_node *target;\n};\n\n#ifdef CONFIG_OF_OVERLAY\n\nint of_overlay_fdt_apply(const void *overlay_fdt, u32 overlay_fdt_size,\n\t\t\t int *ovcs_id, struct device_node *target_base);\nint of_overlay_remove(int *ovcs_id);\nint of_overlay_remove_all(void);\n\nint of_overlay_notifier_register(struct notifier_block *nb);\nint of_overlay_notifier_unregister(struct notifier_block *nb);\n\n#else\n\nstatic inline int of_overlay_fdt_apply(const void *overlay_fdt, u32 overlay_fdt_size,\n\t\t\t\t       int *ovcs_id, struct device_node *target_base)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic inline int of_overlay_remove(int *ovcs_id)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic inline int of_overlay_remove_all(void)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic inline int of_overlay_notifier_register(struct notifier_block *nb)\n{\n\treturn 0;\n}\n\nstatic inline int of_overlay_notifier_unregister(struct notifier_block *nb)\n{\n\treturn 0;\n}\n\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}