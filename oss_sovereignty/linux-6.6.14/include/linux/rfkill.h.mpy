{
  "module_name": "rfkill.h",
  "hash_id": "293ba9805fc34bcaaa76f3a428fee9aa507652771d7c43a6a13c4e9d171ed042",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/rfkill.h",
  "human_readable_source": " \n#ifndef __RFKILL_H\n#define __RFKILL_H\n\n#include <uapi/linux/rfkill.h>\n\n \nenum rfkill_user_states {\n\tRFKILL_USER_STATE_SOFT_BLOCKED\t= RFKILL_STATE_SOFT_BLOCKED,\n\tRFKILL_USER_STATE_UNBLOCKED\t= RFKILL_STATE_UNBLOCKED,\n\tRFKILL_USER_STATE_HARD_BLOCKED\t= RFKILL_STATE_HARD_BLOCKED,\n};\n#undef RFKILL_STATE_SOFT_BLOCKED\n#undef RFKILL_STATE_UNBLOCKED\n#undef RFKILL_STATE_HARD_BLOCKED\n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/leds.h>\n#include <linux/err.h>\n\nstruct device;\n \nstruct rfkill;\n\n \nstruct rfkill_ops {\n\tvoid\t(*poll)(struct rfkill *rfkill, void *data);\n\tvoid\t(*query)(struct rfkill *rfkill, void *data);\n\tint\t(*set_block)(void *data, bool blocked);\n};\n\n#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)\n \nstruct rfkill * __must_check rfkill_alloc(const char *name,\n\t\t\t\t\t  struct device *parent,\n\t\t\t\t\t  const enum rfkill_type type,\n\t\t\t\t\t  const struct rfkill_ops *ops,\n\t\t\t\t\t  void *ops_data);\n\n \nint __must_check rfkill_register(struct rfkill *rfkill);\n\n \nvoid rfkill_pause_polling(struct rfkill *rfkill);\n\n \nvoid rfkill_resume_polling(struct rfkill *rfkill);\n\n\n \nvoid rfkill_unregister(struct rfkill *rfkill);\n\n \nvoid rfkill_destroy(struct rfkill *rfkill);\n\n \nbool rfkill_set_hw_state_reason(struct rfkill *rfkill,\n\t\t\t\tbool blocked, unsigned long reason);\n \nstatic inline bool rfkill_set_hw_state(struct rfkill *rfkill, bool blocked)\n{\n\treturn rfkill_set_hw_state_reason(rfkill, blocked,\n\t\t\t\t\t  RFKILL_HARD_BLOCK_SIGNAL);\n}\n\n \nbool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked);\n\n \nvoid rfkill_init_sw_state(struct rfkill *rfkill, bool blocked);\n\n \nvoid rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw);\n\n \nbool rfkill_blocked(struct rfkill *rfkill);\n\n \nbool rfkill_soft_blocked(struct rfkill *rfkill);\n\n \nenum rfkill_type rfkill_find_type(const char *name);\n\n#else  \nstatic inline struct rfkill * __must_check\nrfkill_alloc(const char *name,\n\t     struct device *parent,\n\t     const enum rfkill_type type,\n\t     const struct rfkill_ops *ops,\n\t     void *ops_data)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic inline int __must_check rfkill_register(struct rfkill *rfkill)\n{\n\tif (rfkill == ERR_PTR(-ENODEV))\n\t\treturn 0;\n\treturn -EINVAL;\n}\n\nstatic inline void rfkill_pause_polling(struct rfkill *rfkill)\n{\n}\n\nstatic inline void rfkill_resume_polling(struct rfkill *rfkill)\n{\n}\n\nstatic inline void rfkill_unregister(struct rfkill *rfkill)\n{\n}\n\nstatic inline void rfkill_destroy(struct rfkill *rfkill)\n{\n}\n\nstatic inline bool rfkill_set_hw_state_reason(struct rfkill *rfkill,\n\t\t\t\t\t      bool blocked,\n\t\t\t\t\t      unsigned long reason)\n{\n\treturn blocked;\n}\n\nstatic inline bool rfkill_set_hw_state(struct rfkill *rfkill, bool blocked)\n{\n\treturn blocked;\n}\n\nstatic inline bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked)\n{\n\treturn blocked;\n}\n\nstatic inline void rfkill_init_sw_state(struct rfkill *rfkill, bool blocked)\n{\n}\n\nstatic inline void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw)\n{\n}\n\nstatic inline bool rfkill_blocked(struct rfkill *rfkill)\n{\n\treturn false;\n}\n\nstatic inline bool rfkill_soft_blocked(struct rfkill *rfkill)\n{\n\treturn false;\n}\n\nstatic inline enum rfkill_type rfkill_find_type(const char *name)\n{\n\treturn RFKILL_TYPE_ALL;\n}\n\n#endif  \n\n\n#ifdef CONFIG_RFKILL_LEDS\n \nconst char *rfkill_get_led_trigger_name(struct rfkill *rfkill);\n\n \nvoid rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name);\n#else\nstatic inline const char *rfkill_get_led_trigger_name(struct rfkill *rfkill)\n{\n\treturn NULL;\n}\n\nstatic inline void\nrfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name)\n{\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}