{
  "module_name": "virtio_config.h",
  "hash_id": "d1efaeb42c7efc90774178ef3be434623d110e9c10f53fd508c455add5bdde25",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/virtio_config.h",
  "human_readable_source": " \n#ifndef _LINUX_VIRTIO_CONFIG_H\n#define _LINUX_VIRTIO_CONFIG_H\n\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/virtio.h>\n#include <linux/virtio_byteorder.h>\n#include <linux/compiler_types.h>\n#include <uapi/linux/virtio_config.h>\n\nstruct irq_affinity;\n\nstruct virtio_shm_region {\n\tu64 addr;\n\tu64 len;\n};\n\ntypedef void vq_callback_t(struct virtqueue *);\n\n \nstruct virtio_config_ops {\n\tvoid (*get)(struct virtio_device *vdev, unsigned offset,\n\t\t    void *buf, unsigned len);\n\tvoid (*set)(struct virtio_device *vdev, unsigned offset,\n\t\t    const void *buf, unsigned len);\n\tu32 (*generation)(struct virtio_device *vdev);\n\tu8 (*get_status)(struct virtio_device *vdev);\n\tvoid (*set_status)(struct virtio_device *vdev, u8 status);\n\tvoid (*reset)(struct virtio_device *vdev);\n\tint (*find_vqs)(struct virtio_device *, unsigned nvqs,\n\t\t\tstruct virtqueue *vqs[], vq_callback_t *callbacks[],\n\t\t\tconst char * const names[], const bool *ctx,\n\t\t\tstruct irq_affinity *desc);\n\tvoid (*del_vqs)(struct virtio_device *);\n\tvoid (*synchronize_cbs)(struct virtio_device *);\n\tu64 (*get_features)(struct virtio_device *vdev);\n\tint (*finalize_features)(struct virtio_device *vdev);\n\tconst char *(*bus_name)(struct virtio_device *vdev);\n\tint (*set_vq_affinity)(struct virtqueue *vq,\n\t\t\t       const struct cpumask *cpu_mask);\n\tconst struct cpumask *(*get_vq_affinity)(struct virtio_device *vdev,\n\t\t\tint index);\n\tbool (*get_shm_region)(struct virtio_device *vdev,\n\t\t\t       struct virtio_shm_region *region, u8 id);\n\tint (*disable_vq_and_reset)(struct virtqueue *vq);\n\tint (*enable_vq_after_reset)(struct virtqueue *vq);\n};\n\n \nvoid virtio_check_driver_offered_feature(const struct virtio_device *vdev,\n\t\t\t\t\t unsigned int fbit);\n\n \nstatic inline bool __virtio_test_bit(const struct virtio_device *vdev,\n\t\t\t\t     unsigned int fbit)\n{\n\t \n\tif (__builtin_constant_p(fbit))\n\t\tBUILD_BUG_ON(fbit >= 64);\n\telse\n\t\tBUG_ON(fbit >= 64);\n\n\treturn vdev->features & BIT_ULL(fbit);\n}\n\n \nstatic inline void __virtio_set_bit(struct virtio_device *vdev,\n\t\t\t\t    unsigned int fbit)\n{\n\t \n\tif (__builtin_constant_p(fbit))\n\t\tBUILD_BUG_ON(fbit >= 64);\n\telse\n\t\tBUG_ON(fbit >= 64);\n\n\tvdev->features |= BIT_ULL(fbit);\n}\n\n \nstatic inline void __virtio_clear_bit(struct virtio_device *vdev,\n\t\t\t\t      unsigned int fbit)\n{\n\t \n\tif (__builtin_constant_p(fbit))\n\t\tBUILD_BUG_ON(fbit >= 64);\n\telse\n\t\tBUG_ON(fbit >= 64);\n\n\tvdev->features &= ~BIT_ULL(fbit);\n}\n\n \nstatic inline bool virtio_has_feature(const struct virtio_device *vdev,\n\t\t\t\t      unsigned int fbit)\n{\n\tif (fbit < VIRTIO_TRANSPORT_F_START)\n\t\tvirtio_check_driver_offered_feature(vdev, fbit);\n\n\treturn __virtio_test_bit(vdev, fbit);\n}\n\n \nstatic inline bool virtio_has_dma_quirk(const struct virtio_device *vdev)\n{\n\t \n\treturn !virtio_has_feature(vdev, VIRTIO_F_ACCESS_PLATFORM);\n}\n\nstatic inline\nstruct virtqueue *virtio_find_single_vq(struct virtio_device *vdev,\n\t\t\t\t\tvq_callback_t *c, const char *n)\n{\n\tvq_callback_t *callbacks[] = { c };\n\tconst char *names[] = { n };\n\tstruct virtqueue *vq;\n\tint err = vdev->config->find_vqs(vdev, 1, &vq, callbacks, names, NULL,\n\t\t\t\t\t NULL);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn vq;\n}\n\nstatic inline\nint virtio_find_vqs(struct virtio_device *vdev, unsigned nvqs,\n\t\t\tstruct virtqueue *vqs[], vq_callback_t *callbacks[],\n\t\t\tconst char * const names[],\n\t\t\tstruct irq_affinity *desc)\n{\n\treturn vdev->config->find_vqs(vdev, nvqs, vqs, callbacks, names, NULL, desc);\n}\n\nstatic inline\nint virtio_find_vqs_ctx(struct virtio_device *vdev, unsigned nvqs,\n\t\t\tstruct virtqueue *vqs[], vq_callback_t *callbacks[],\n\t\t\tconst char * const names[], const bool *ctx,\n\t\t\tstruct irq_affinity *desc)\n{\n\treturn vdev->config->find_vqs(vdev, nvqs, vqs, callbacks, names, ctx,\n\t\t\t\t      desc);\n}\n\n \nstatic inline\nvoid virtio_synchronize_cbs(struct virtio_device *dev)\n{\n\tif (dev->config->synchronize_cbs) {\n\t\tdev->config->synchronize_cbs(dev);\n\t} else {\n\t\t \n\t\tsynchronize_rcu();\n\t}\n}\n\n \nstatic inline\nvoid virtio_device_ready(struct virtio_device *dev)\n{\n\tunsigned status = dev->config->get_status(dev);\n\n\tWARN_ON(status & VIRTIO_CONFIG_S_DRIVER_OK);\n\n#ifdef CONFIG_VIRTIO_HARDEN_NOTIFICATION\n\t \n\tvirtio_synchronize_cbs(dev);\n\t__virtio_unbreak_device(dev);\n#endif\n\t \n\tdev->config->set_status(dev, status | VIRTIO_CONFIG_S_DRIVER_OK);\n}\n\nstatic inline\nconst char *virtio_bus_name(struct virtio_device *vdev)\n{\n\tif (!vdev->config->bus_name)\n\t\treturn \"virtio\";\n\treturn vdev->config->bus_name(vdev);\n}\n\n \nstatic inline\nint virtqueue_set_affinity(struct virtqueue *vq, const struct cpumask *cpu_mask)\n{\n\tstruct virtio_device *vdev = vq->vdev;\n\tif (vdev->config->set_vq_affinity)\n\t\treturn vdev->config->set_vq_affinity(vq, cpu_mask);\n\treturn 0;\n}\n\nstatic inline\nbool virtio_get_shm_region(struct virtio_device *vdev,\n\t\t\t   struct virtio_shm_region *region, u8 id)\n{\n\tif (!vdev->config->get_shm_region)\n\t\treturn false;\n\treturn vdev->config->get_shm_region(vdev, region, id);\n}\n\nstatic inline bool virtio_is_little_endian(struct virtio_device *vdev)\n{\n\treturn virtio_has_feature(vdev, VIRTIO_F_VERSION_1) ||\n\t\tvirtio_legacy_is_little_endian();\n}\n\n \nstatic inline u16 virtio16_to_cpu(struct virtio_device *vdev, __virtio16 val)\n{\n\treturn __virtio16_to_cpu(virtio_is_little_endian(vdev), val);\n}\n\nstatic inline __virtio16 cpu_to_virtio16(struct virtio_device *vdev, u16 val)\n{\n\treturn __cpu_to_virtio16(virtio_is_little_endian(vdev), val);\n}\n\nstatic inline u32 virtio32_to_cpu(struct virtio_device *vdev, __virtio32 val)\n{\n\treturn __virtio32_to_cpu(virtio_is_little_endian(vdev), val);\n}\n\nstatic inline __virtio32 cpu_to_virtio32(struct virtio_device *vdev, u32 val)\n{\n\treturn __cpu_to_virtio32(virtio_is_little_endian(vdev), val);\n}\n\nstatic inline u64 virtio64_to_cpu(struct virtio_device *vdev, __virtio64 val)\n{\n\treturn __virtio64_to_cpu(virtio_is_little_endian(vdev), val);\n}\n\nstatic inline __virtio64 cpu_to_virtio64(struct virtio_device *vdev, u64 val)\n{\n\treturn __cpu_to_virtio64(virtio_is_little_endian(vdev), val);\n}\n\n#define virtio_to_cpu(vdev, x) \\\n\t_Generic((x), \\\n\t\t__u8: (x), \\\n\t\t__virtio16: virtio16_to_cpu((vdev), (x)), \\\n\t\t__virtio32: virtio32_to_cpu((vdev), (x)), \\\n\t\t__virtio64: virtio64_to_cpu((vdev), (x)) \\\n\t\t)\n\n#define cpu_to_virtio(vdev, x, m) \\\n\t_Generic((m), \\\n\t\t__u8: (x), \\\n\t\t__virtio16: cpu_to_virtio16((vdev), (x)), \\\n\t\t__virtio32: cpu_to_virtio32((vdev), (x)), \\\n\t\t__virtio64: cpu_to_virtio64((vdev), (x)) \\\n\t\t)\n\n#define __virtio_native_type(structname, member) \\\n\ttypeof(virtio_to_cpu(NULL, ((structname*)0)->member))\n\n \n#define virtio_cread(vdev, structname, member, ptr)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttypeof(((structname*)0)->member) virtio_cread_v;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tmight_sleep();\t\t\t\t\t\t\\\n\t\t \t\\\n\t\ttypecheck(typeof(virtio_to_cpu((vdev), virtio_cread_v)), *(ptr)); \\\n\t\t\t\t\t\t\t\t\t\\\n\t\tswitch (sizeof(virtio_cread_v)) {\t\t\t\\\n\t\tcase 1:\t\t\t\t\t\t\t\\\n\t\tcase 2:\t\t\t\t\t\t\t\\\n\t\tcase 4:\t\t\t\t\t\t\t\\\n\t\t\tvdev->config->get((vdev), \t\t\t\\\n\t\t\t\t\t  offsetof(structname, member), \\\n\t\t\t\t\t  &virtio_cread_v,\t\t\\\n\t\t\t\t\t  sizeof(virtio_cread_v));\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tdefault:\t\t\t\t\t\t\\\n\t\t\t__virtio_cread_many((vdev), \t\t\t\\\n\t\t\t\t\t  offsetof(structname, member), \\\n\t\t\t\t\t  &virtio_cread_v,\t\t\\\n\t\t\t\t\t  1,\t\t\t\t\\\n\t\t\t\t\t  sizeof(virtio_cread_v));\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t*(ptr) = virtio_to_cpu(vdev, virtio_cread_v);\t\t\\\n\t} while(0)\n\n \n#define virtio_cwrite(vdev, structname, member, ptr)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttypeof(((structname*)0)->member) virtio_cwrite_v =\t\\\n\t\t\tcpu_to_virtio(vdev, *(ptr), ((structname*)0)->member); \\\n\t\t\t\t\t\t\t\t\t\\\n\t\tmight_sleep();\t\t\t\t\t\t\\\n\t\t \t\\\n\t\ttypecheck(typeof(virtio_to_cpu((vdev), virtio_cwrite_v)), *(ptr)); \\\n\t\t\t\t\t\t\t\t\t\\\n\t\tvdev->config->set((vdev), offsetof(structname, member),\t\\\n\t\t\t\t  &virtio_cwrite_v,\t\t\t\\\n\t\t\t\t  sizeof(virtio_cwrite_v));\t\t\\\n\t} while(0)\n\n \n#define virtio_le_to_cpu(x) \\\n\t_Generic((x), \\\n\t\t__u8: (u8)(x), \\\n\t\t __le16: (u16)le16_to_cpu(x), \\\n\t\t __le32: (u32)le32_to_cpu(x), \\\n\t\t __le64: (u64)le64_to_cpu(x) \\\n\t\t)\n\n#define virtio_cpu_to_le(x, m) \\\n\t_Generic((m), \\\n\t\t __u8: (x), \\\n\t\t __le16: cpu_to_le16(x), \\\n\t\t __le32: cpu_to_le32(x), \\\n\t\t __le64: cpu_to_le64(x) \\\n\t\t)\n\n \n#define virtio_cread_le(vdev, structname, member, ptr)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttypeof(((structname*)0)->member) virtio_cread_v;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tmight_sleep();\t\t\t\t\t\t\\\n\t\t \t\\\n\t\ttypecheck(typeof(virtio_le_to_cpu(virtio_cread_v)), *(ptr)); \\\n\t\t\t\t\t\t\t\t\t\\\n\t\tswitch (sizeof(virtio_cread_v)) {\t\t\t\\\n\t\tcase 1:\t\t\t\t\t\t\t\\\n\t\tcase 2:\t\t\t\t\t\t\t\\\n\t\tcase 4:\t\t\t\t\t\t\t\\\n\t\t\tvdev->config->get((vdev), \t\t\t\\\n\t\t\t\t\t  offsetof(structname, member), \\\n\t\t\t\t\t  &virtio_cread_v,\t\t\\\n\t\t\t\t\t  sizeof(virtio_cread_v));\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tdefault:\t\t\t\t\t\t\\\n\t\t\t__virtio_cread_many((vdev), \t\t\t\\\n\t\t\t\t\t  offsetof(structname, member), \\\n\t\t\t\t\t  &virtio_cread_v,\t\t\\\n\t\t\t\t\t  1,\t\t\t\t\\\n\t\t\t\t\t  sizeof(virtio_cread_v));\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t*(ptr) = virtio_le_to_cpu(virtio_cread_v);\t\t\\\n\t} while(0)\n\n#define virtio_cwrite_le(vdev, structname, member, ptr)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttypeof(((structname*)0)->member) virtio_cwrite_v =\t\\\n\t\t\tvirtio_cpu_to_le(*(ptr), ((structname*)0)->member); \\\n\t\t\t\t\t\t\t\t\t\\\n\t\tmight_sleep();\t\t\t\t\t\t\\\n\t\t \t\\\n\t\ttypecheck(typeof(virtio_le_to_cpu(virtio_cwrite_v)), *(ptr)); \\\n\t\t\t\t\t\t\t\t\t\\\n\t\tvdev->config->set((vdev), offsetof(structname, member),\t\\\n\t\t\t\t  &virtio_cwrite_v,\t\t\t\\\n\t\t\t\t  sizeof(virtio_cwrite_v));\t\t\\\n\t} while(0)\n\n\n \nstatic inline void __virtio_cread_many(struct virtio_device *vdev,\n\t\t\t\t       unsigned int offset,\n\t\t\t\t       void *buf, size_t count, size_t bytes)\n{\n\tu32 old, gen = vdev->config->generation ?\n\t\tvdev->config->generation(vdev) : 0;\n\tint i;\n\n\tmight_sleep();\n\tdo {\n\t\told = gen;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\tvdev->config->get(vdev, offset + bytes * i,\n\t\t\t\t\t  buf + i * bytes, bytes);\n\n\t\tgen = vdev->config->generation ?\n\t\t\tvdev->config->generation(vdev) : 0;\n\t} while (gen != old);\n}\n\nstatic inline void virtio_cread_bytes(struct virtio_device *vdev,\n\t\t\t\t      unsigned int offset,\n\t\t\t\t      void *buf, size_t len)\n{\n\t__virtio_cread_many(vdev, offset, buf, len, 1);\n}\n\nstatic inline u8 virtio_cread8(struct virtio_device *vdev, unsigned int offset)\n{\n\tu8 ret;\n\n\tmight_sleep();\n\tvdev->config->get(vdev, offset, &ret, sizeof(ret));\n\treturn ret;\n}\n\nstatic inline void virtio_cwrite8(struct virtio_device *vdev,\n\t\t\t\t  unsigned int offset, u8 val)\n{\n\tmight_sleep();\n\tvdev->config->set(vdev, offset, &val, sizeof(val));\n}\n\nstatic inline u16 virtio_cread16(struct virtio_device *vdev,\n\t\t\t\t unsigned int offset)\n{\n\t__virtio16 ret;\n\n\tmight_sleep();\n\tvdev->config->get(vdev, offset, &ret, sizeof(ret));\n\treturn virtio16_to_cpu(vdev, ret);\n}\n\nstatic inline void virtio_cwrite16(struct virtio_device *vdev,\n\t\t\t\t   unsigned int offset, u16 val)\n{\n\t__virtio16 v;\n\n\tmight_sleep();\n\tv = cpu_to_virtio16(vdev, val);\n\tvdev->config->set(vdev, offset, &v, sizeof(v));\n}\n\nstatic inline u32 virtio_cread32(struct virtio_device *vdev,\n\t\t\t\t unsigned int offset)\n{\n\t__virtio32 ret;\n\n\tmight_sleep();\n\tvdev->config->get(vdev, offset, &ret, sizeof(ret));\n\treturn virtio32_to_cpu(vdev, ret);\n}\n\nstatic inline void virtio_cwrite32(struct virtio_device *vdev,\n\t\t\t\t   unsigned int offset, u32 val)\n{\n\t__virtio32 v;\n\n\tmight_sleep();\n\tv = cpu_to_virtio32(vdev, val);\n\tvdev->config->set(vdev, offset, &v, sizeof(v));\n}\n\nstatic inline u64 virtio_cread64(struct virtio_device *vdev,\n\t\t\t\t unsigned int offset)\n{\n\t__virtio64 ret;\n\n\t__virtio_cread_many(vdev, offset, &ret, 1, sizeof(ret));\n\treturn virtio64_to_cpu(vdev, ret);\n}\n\nstatic inline void virtio_cwrite64(struct virtio_device *vdev,\n\t\t\t\t   unsigned int offset, u64 val)\n{\n\t__virtio64 v;\n\n\tmight_sleep();\n\tv = cpu_to_virtio64(vdev, val);\n\tvdev->config->set(vdev, offset, &v, sizeof(v));\n}\n\n \n#define virtio_cread_feature(vdev, fbit, structname, member, ptr)\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint _r = 0;\t\t\t\t\t\t\\\n\t\tif (!virtio_has_feature(vdev, fbit))\t\t\t\\\n\t\t\t_r = -ENOENT;\t\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tvirtio_cread((vdev), structname, member, ptr);\t\\\n\t\t_r;\t\t\t\t\t\t\t\\\n\t})\n\n \n#define virtio_cread_le_feature(vdev, fbit, structname, member, ptr)\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint _r = 0;\t\t\t\t\t\t\\\n\t\tif (!virtio_has_feature(vdev, fbit))\t\t\t\\\n\t\t\t_r = -ENOENT;\t\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tvirtio_cread_le((vdev), structname, member, ptr); \\\n\t\t_r;\t\t\t\t\t\t\t\\\n\t})\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}