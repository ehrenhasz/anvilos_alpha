{
  "module_name": "apple-gmux.h",
  "hash_id": "b978a4c71a8a69797d3f9ddeb1cee09b5bc22b9f51bd06cbc631b421eb8a60c2",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/apple-gmux.h",
  "human_readable_source": " \n \n\n#ifndef LINUX_APPLE_GMUX_H\n#define LINUX_APPLE_GMUX_H\n\n#include <linux/acpi.h>\n#include <linux/io.h>\n#include <linux/pnp.h>\n\n#define GMUX_ACPI_HID \"APP000B\"\n\n \n#define GMUX_PORT_VERSION_MAJOR\t\t0x04\n#define GMUX_PORT_VERSION_MINOR\t\t0x05\n#define GMUX_PORT_VERSION_RELEASE\t0x06\n#define GMUX_PORT_SWITCH_DISPLAY\t0x10\n#define GMUX_PORT_SWITCH_GET_DISPLAY\t0x11\n#define GMUX_PORT_INTERRUPT_ENABLE\t0x14\n#define GMUX_PORT_INTERRUPT_STATUS\t0x16\n#define GMUX_PORT_SWITCH_DDC\t\t0x28\n#define GMUX_PORT_SWITCH_EXTERNAL\t0x40\n#define GMUX_PORT_SWITCH_GET_EXTERNAL\t0x41\n#define GMUX_PORT_DISCRETE_POWER\t0x50\n#define GMUX_PORT_MAX_BRIGHTNESS\t0x70\n#define GMUX_PORT_BRIGHTNESS\t\t0x74\n#define GMUX_PORT_VALUE\t\t\t0xc2\n#define GMUX_PORT_READ\t\t\t0xd0\n#define GMUX_PORT_WRITE\t\t\t0xd4\n\n#define GMUX_MMIO_PORT_SELECT\t\t0x0e\n#define GMUX_MMIO_COMMAND_SEND\t\t0x0f\n\n#define GMUX_MMIO_READ\t\t\t0x00\n#define GMUX_MMIO_WRITE\t\t\t0x40\n\n#define GMUX_MIN_IO_LEN\t\t\t(GMUX_PORT_BRIGHTNESS + 4)\n\nenum apple_gmux_type {\n\tAPPLE_GMUX_TYPE_PIO,\n\tAPPLE_GMUX_TYPE_INDEXED,\n\tAPPLE_GMUX_TYPE_MMIO,\n};\n\n#if IS_ENABLED(CONFIG_APPLE_GMUX)\nstatic inline bool apple_gmux_is_indexed(unsigned long iostart)\n{\n\tu16 val;\n\n\toutb(0xaa, iostart + 0xcc);\n\toutb(0x55, iostart + 0xcd);\n\toutb(0x00, iostart + 0xce);\n\n\tval = inb(iostart + 0xcc) | (inb(iostart + 0xcd) << 8);\n\tif (val == 0x55aa)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool apple_gmux_is_mmio(unsigned long iostart)\n{\n\tu8 __iomem *iomem_base = ioremap(iostart, 16);\n\tu8 val;\n\n\tif (!iomem_base)\n\t\treturn false;\n\n\t \n\tval = ioread8(iomem_base + GMUX_MMIO_COMMAND_SEND);\n\tiounmap(iomem_base);\n\treturn (val != 0xff);\n}\n\n \nstatic inline bool apple_gmux_detect(struct pnp_dev *pnp_dev, enum apple_gmux_type *type_ret)\n{\n\tu8 ver_major, ver_minor, ver_release;\n\tstruct device *dev = NULL;\n\tstruct acpi_device *adev;\n\tstruct resource *res;\n\tenum apple_gmux_type type = APPLE_GMUX_TYPE_PIO;\n\tbool ret = false;\n\n\tif (!pnp_dev) {\n\t\tadev = acpi_dev_get_first_match_dev(GMUX_ACPI_HID, NULL, -1);\n\t\tif (!adev)\n\t\t\treturn false;\n\n\t\tdev = get_device(acpi_get_first_physical_node(adev));\n\t\tacpi_dev_put(adev);\n\t\tif (!dev)\n\t\t\treturn false;\n\n\t\tpnp_dev = to_pnp_dev(dev);\n\t}\n\n\tres = pnp_get_resource(pnp_dev, IORESOURCE_IO, 0);\n\tif (res && resource_size(res) >= GMUX_MIN_IO_LEN) {\n\t\t \n\t\tver_major = inb(res->start + GMUX_PORT_VERSION_MAJOR);\n\t\tver_minor = inb(res->start + GMUX_PORT_VERSION_MINOR);\n\t\tver_release = inb(res->start + GMUX_PORT_VERSION_RELEASE);\n\t\tif (ver_major == 0xff && ver_minor == 0xff && ver_release == 0xff) {\n\t\t\tif (apple_gmux_is_indexed(res->start))\n\t\t\t\ttype = APPLE_GMUX_TYPE_INDEXED;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tres = pnp_get_resource(pnp_dev, IORESOURCE_MEM, 0);\n\t\tif (res && apple_gmux_is_mmio(res->start))\n\t\t\ttype = APPLE_GMUX_TYPE_MMIO;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tif (type_ret)\n\t\t*type_ret = type;\n\n\tret = true;\nout:\n\tput_device(dev);\n\treturn ret;\n}\n\n \nstatic inline bool apple_gmux_present(void)\n{\n\treturn acpi_dev_found(GMUX_ACPI_HID);\n}\n\n#else   \n\nstatic inline bool apple_gmux_present(void)\n{\n\treturn false;\n}\n\nstatic inline bool apple_gmux_detect(struct pnp_dev *pnp_dev, bool *indexed_ret)\n{\n\treturn false;\n}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}