{
  "module_name": "compiler_types.h",
  "hash_id": "6fbaee06fc1a5b2c717bbd15d6e12f8ab3cc783794a6fb0b52c493453632aa42",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/compiler_types.h",
  "human_readable_source": " \n#ifndef __LINUX_COMPILER_TYPES_H\n#define __LINUX_COMPILER_TYPES_H\n\n#ifndef __ASSEMBLY__\n\n \n#if defined(CONFIG_DEBUG_INFO_BTF) && defined(CONFIG_PAHOLE_HAS_BTF_TAG) && \\\n\t__has_attribute(btf_type_tag) && !defined(__BINDGEN__)\n# define BTF_TYPE_TAG(value) __attribute__((btf_type_tag(#value)))\n#else\n# define BTF_TYPE_TAG(value)  \n#endif\n\n \n#ifdef __CHECKER__\n \n# define __kernel\t__attribute__((address_space(0)))\n# define __user\t\t__attribute__((noderef, address_space(__user)))\n# define __iomem\t__attribute__((noderef, address_space(__iomem)))\n# define __percpu\t__attribute__((noderef, address_space(__percpu)))\n# define __rcu\t\t__attribute__((noderef, address_space(__rcu)))\nstatic inline void __chk_user_ptr(const volatile void __user *ptr) { }\nstatic inline void __chk_io_ptr(const volatile void __iomem *ptr) { }\n \n# define __must_hold(x)\t__attribute__((context(x,1,1)))\n# define __acquires(x)\t__attribute__((context(x,0,1)))\n# define __cond_acquires(x) __attribute__((context(x,0,-1)))\n# define __releases(x)\t__attribute__((context(x,1,0)))\n# define __acquire(x)\t__context__(x,1)\n# define __release(x)\t__context__(x,-1)\n# define __cond_lock(x,c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n \n# define __force\t__attribute__((force))\n# define __nocast\t__attribute__((nocast))\n# define __safe\t\t__attribute__((safe))\n# define __private\t__attribute__((noderef))\n# define ACCESS_PRIVATE(p, member) (*((typeof((p)->member) __force *) &(p)->member))\n#else  \n \n# define __kernel\n# ifdef STRUCTLEAK_PLUGIN\n#  define __user\t__attribute__((user))\n# else\n#  define __user\tBTF_TYPE_TAG(user)\n# endif\n# define __iomem\n# define __percpu\tBTF_TYPE_TAG(percpu)\n# define __rcu\t\tBTF_TYPE_TAG(rcu)\n\n# define __chk_user_ptr(x)\t(void)0\n# define __chk_io_ptr(x)\t(void)0\n \n# define __must_hold(x)\n# define __acquires(x)\n# define __cond_acquires(x)\n# define __releases(x)\n# define __acquire(x)\t(void)0\n# define __release(x)\t(void)0\n# define __cond_lock(x,c) (c)\n \n# define __force\n# define __nocast\n# define __safe\n# define __private\n# define ACCESS_PRIVATE(p, member) ((p)->member)\n# define __builtin_warning(x, y...) (1)\n#endif  \n\n \n#define ___PASTE(a,b) a##b\n#define __PASTE(a,b) ___PASTE(a,b)\n\n#ifdef __KERNEL__\n\n \n#include <linux/compiler_attributes.h>\n\n#if CONFIG_FUNCTION_ALIGNMENT > 0\n#define __function_aligned\t\t__aligned(CONFIG_FUNCTION_ALIGNMENT)\n#else\n#define __function_aligned\n#endif\n\n \n#if !defined(CONFIG_CC_IS_GCC) || (CONFIG_FUNCTION_ALIGNMENT == 0)\n#define __cold\t\t\t\t__attribute__((__cold__))\n#else\n#define __cold\n#endif\n\n \n#if __has_attribute(__preserve_most__) && (defined(CONFIG_X86_64) || defined(CONFIG_ARM64))\n# define __preserve_most notrace __attribute__((__preserve_most__))\n#else\n# define __preserve_most\n#endif\n\n \n\n \n#ifndef __has_builtin\n#define __has_builtin(x) (0)\n#endif\n\n \n#ifdef __clang__\n#include <linux/compiler-clang.h>\n#elif defined(__GNUC__)\n \n#include <linux/compiler-gcc.h>\n#else\n#error \"Unknown compiler\"\n#endif\n\n \n#ifdef CONFIG_HAVE_ARCH_COMPILER_H\n#include <asm/compiler.h>\n#endif\n\nstruct ftrace_branch_data {\n\tconst char *func;\n\tconst char *file;\n\tunsigned line;\n\tunion {\n\t\tstruct {\n\t\t\tunsigned long correct;\n\t\t\tunsigned long incorrect;\n\t\t};\n\t\tstruct {\n\t\t\tunsigned long miss;\n\t\t\tunsigned long hit;\n\t\t};\n\t\tunsigned long miss_hit[2];\n\t};\n};\n\nstruct ftrace_likely_data {\n\tstruct ftrace_branch_data\tdata;\n\tunsigned long\t\t\tconstant;\n};\n\n#if defined(CC_USING_HOTPATCH)\n#define notrace\t\t\t__attribute__((hotpatch(0, 0)))\n#elif defined(CC_USING_PATCHABLE_FUNCTION_ENTRY)\n#define notrace\t\t\t__attribute__((patchable_function_entry(0, 0)))\n#else\n#define notrace\t\t\t__attribute__((__no_instrument_function__))\n#endif\n\n \n#define __naked\t\t\t__attribute__((__naked__)) notrace\n\n \n#define inline inline __gnu_inline __inline_maybe_unused notrace\n\n \n#define __inline__ inline\n\n \n#ifdef KBUILD_EXTRA_WARN1\n#define __inline_maybe_unused\n#else\n#define __inline_maybe_unused __maybe_unused\n#endif\n\n \n#define noinline_for_stack noinline\n\n \n#ifdef __SANITIZE_ADDRESS__\n \n# define __no_kasan_or_inline __no_sanitize_address notrace __maybe_unused\n# define __no_sanitize_or_inline __no_kasan_or_inline\n#else\n# define __no_kasan_or_inline __always_inline\n#endif\n\n#ifdef __SANITIZE_THREAD__\n \n# define __no_kcsan __no_sanitize_thread __disable_sanitizer_instrumentation\n# define __no_sanitize_or_inline __no_kcsan notrace __maybe_unused\n#else\n# define __no_kcsan\n#endif\n\n#ifndef __no_sanitize_or_inline\n#define __no_sanitize_or_inline __always_inline\n#endif\n\n \n#define __noinstr_section(section)\t\t\t\t\t\\\n\tnoinline notrace __attribute((__section__(section)))\t\t\\\n\t__no_kcsan __no_sanitize_address __no_profile __no_sanitize_coverage \\\n\t__no_sanitize_memory\n\n#define noinstr __noinstr_section(\".noinstr.text\")\n\n \n#define __cpuidle __noinstr_section(\".cpuidle.text\")\n\n#endif  \n\n#endif  \n\n \n#ifndef __latent_entropy\n# define __latent_entropy\n#endif\n\n#if defined(RANDSTRUCT) && !defined(__CHECKER__)\n# define __randomize_layout __designated_init __attribute__((randomize_layout))\n# define __no_randomize_layout __attribute__((no_randomize_layout))\n \n# define randomized_struct_fields_start\tstruct {\n# define randomized_struct_fields_end\t} __randomize_layout;\n#else\n# define __randomize_layout __designated_init\n# define __no_randomize_layout\n# define randomized_struct_fields_start\n# define randomized_struct_fields_end\n#endif\n\n#ifndef __noscs\n# define __noscs\n#endif\n\n#ifndef __nocfi\n# define __nocfi\n#endif\n\n \n#ifdef __alloc_size__\n# define __alloc_size(x, ...)\t__alloc_size__(x, ## __VA_ARGS__) __malloc\n# define __realloc_size(x, ...)\t__alloc_size__(x, ## __VA_ARGS__)\n#else\n# define __alloc_size(x, ...)\t__malloc\n# define __realloc_size(x, ...)\n#endif\n\n#ifndef asm_volatile_goto\n#define asm_volatile_goto(x...) asm goto(x)\n#endif\n\n#ifdef CONFIG_CC_HAS_ASM_INLINE\n#define asm_inline asm __inline\n#else\n#define asm_inline asm\n#endif\n\n \n#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n\n \n \n#define __scalar_type_to_expr_cases(type)\t\t\t\t\\\n\t\tunsigned type:\t(unsigned type)0,\t\t\t\\\n\t\tsigned type:\t(signed type)0\n\n#define __unqual_scalar_typeof(x) typeof(\t\t\t\t\\\n\t\t_Generic((x),\t\t\t\t\t\t\\\n\t\t\t char:\t(char)0,\t\t\t\t\\\n\t\t\t __scalar_type_to_expr_cases(char),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(short),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(int),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long long),\t\\\n\t\t\t default: (x)))\n\n \n#define __native_word(t) \\\n\t(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \\\n\t sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))\n\n#ifdef __OPTIMIZE__\n# define __compiletime_assert(condition, msg, prefix, suffix)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t \t\t\t\t\t\t\t\\\n\t\t__noreturn extern void prefix ## suffix(void)\t\t\\\n\t\t\t__compiletime_error(msg);\t\t\t\\\n\t\tif (!(condition))\t\t\t\t\t\\\n\t\t\tprefix ## suffix();\t\t\t\t\\\n\t} while (0)\n#else\n# define __compiletime_assert(condition, msg, prefix, suffix) do { } while (0)\n#endif\n\n#define _compiletime_assert(condition, msg, prefix, suffix) \\\n\t__compiletime_assert(condition, msg, prefix, suffix)\n\n \n#define compiletime_assert(condition, msg) \\\n\t_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n\n#define compiletime_assert_atomic_type(t)\t\t\t\t\\\n\tcompiletime_assert(__native_word(t),\t\t\t\t\\\n\t\t\"Need native word sized stores/loads for atomicity.\")\n\n \n#ifndef __diag\n#define __diag(string)\n#endif\n\n#ifndef __diag_GCC\n#define __diag_GCC(version, severity, string)\n#endif\n\n#define __diag_push()\t__diag(push)\n#define __diag_pop()\t__diag(pop)\n\n#define __diag_ignore(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, ignore, option)\n#define __diag_warn(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, warn, option)\n#define __diag_error(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, error, option)\n\n#ifndef __diag_ignore_all\n#define __diag_ignore_all(option, comment)\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}