{
  "module_name": "list_lru.h",
  "hash_id": "459cced4d109f690dbc779058363979826bd0f39a324f0d65d490ddc7642172b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/list_lru.h",
  "human_readable_source": " \n \n#ifndef _LRU_LIST_H\n#define _LRU_LIST_H\n\n#include <linux/list.h>\n#include <linux/nodemask.h>\n#include <linux/shrinker.h>\n#include <linux/xarray.h>\n\nstruct mem_cgroup;\n\n \nenum lru_status {\n\tLRU_REMOVED,\t\t \n\tLRU_REMOVED_RETRY,\t \n\tLRU_ROTATE,\t\t \n\tLRU_SKIP,\t\t \n\tLRU_RETRY,\t\t \n};\n\nstruct list_lru_one {\n\tstruct list_head\tlist;\n\t \n\tlong\t\t\tnr_items;\n};\n\nstruct list_lru_memcg {\n\tstruct rcu_head\t\trcu;\n\t \n\tstruct list_lru_one\tnode[];\n};\n\nstruct list_lru_node {\n\t \n\tspinlock_t\t\tlock;\n\t \n\tstruct list_lru_one\tlru;\n\tlong\t\t\tnr_items;\n} ____cacheline_aligned_in_smp;\n\nstruct list_lru {\n\tstruct list_lru_node\t*node;\n#ifdef CONFIG_MEMCG_KMEM\n\tstruct list_head\tlist;\n\tint\t\t\tshrinker_id;\n\tbool\t\t\tmemcg_aware;\n\tstruct xarray\t\txa;\n#endif\n};\n\nvoid list_lru_destroy(struct list_lru *lru);\nint __list_lru_init(struct list_lru *lru, bool memcg_aware,\n\t\t    struct lock_class_key *key, struct shrinker *shrinker);\n\n#define list_lru_init(lru)\t\t\t\t\\\n\t__list_lru_init((lru), false, NULL, NULL)\n#define list_lru_init_key(lru, key)\t\t\t\\\n\t__list_lru_init((lru), false, (key), NULL)\n#define list_lru_init_memcg(lru, shrinker)\t\t\\\n\t__list_lru_init((lru), true, NULL, shrinker)\n\nint memcg_list_lru_alloc(struct mem_cgroup *memcg, struct list_lru *lru,\n\t\t\t gfp_t gfp);\nvoid memcg_reparent_list_lrus(struct mem_cgroup *memcg, struct mem_cgroup *parent);\n\n \nbool list_lru_add(struct list_lru *lru, struct list_head *item);\n\n \nbool list_lru_del(struct list_lru *lru, struct list_head *item);\n\n \nunsigned long list_lru_count_one(struct list_lru *lru,\n\t\t\t\t int nid, struct mem_cgroup *memcg);\nunsigned long list_lru_count_node(struct list_lru *lru, int nid);\n\nstatic inline unsigned long list_lru_shrink_count(struct list_lru *lru,\n\t\t\t\t\t\t  struct shrink_control *sc)\n{\n\treturn list_lru_count_one(lru, sc->nid, sc->memcg);\n}\n\nstatic inline unsigned long list_lru_count(struct list_lru *lru)\n{\n\tlong count = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_NORMAL_MEMORY)\n\t\tcount += list_lru_count_node(lru, nid);\n\n\treturn count;\n}\n\nvoid list_lru_isolate(struct list_lru_one *list, struct list_head *item);\nvoid list_lru_isolate_move(struct list_lru_one *list, struct list_head *item,\n\t\t\t   struct list_head *head);\n\ntypedef enum lru_status (*list_lru_walk_cb)(struct list_head *item,\n\t\tstruct list_lru_one *list, spinlock_t *lock, void *cb_arg);\n\n \nunsigned long list_lru_walk_one(struct list_lru *lru,\n\t\t\t\tint nid, struct mem_cgroup *memcg,\n\t\t\t\tlist_lru_walk_cb isolate, void *cb_arg,\n\t\t\t\tunsigned long *nr_to_walk);\n \nunsigned long list_lru_walk_one_irq(struct list_lru *lru,\n\t\t\t\t    int nid, struct mem_cgroup *memcg,\n\t\t\t\t    list_lru_walk_cb isolate, void *cb_arg,\n\t\t\t\t    unsigned long *nr_to_walk);\nunsigned long list_lru_walk_node(struct list_lru *lru, int nid,\n\t\t\t\t list_lru_walk_cb isolate, void *cb_arg,\n\t\t\t\t unsigned long *nr_to_walk);\n\nstatic inline unsigned long\nlist_lru_shrink_walk(struct list_lru *lru, struct shrink_control *sc,\n\t\t     list_lru_walk_cb isolate, void *cb_arg)\n{\n\treturn list_lru_walk_one(lru, sc->nid, sc->memcg, isolate, cb_arg,\n\t\t\t\t &sc->nr_to_scan);\n}\n\nstatic inline unsigned long\nlist_lru_shrink_walk_irq(struct list_lru *lru, struct shrink_control *sc,\n\t\t\t list_lru_walk_cb isolate, void *cb_arg)\n{\n\treturn list_lru_walk_one_irq(lru, sc->nid, sc->memcg, isolate, cb_arg,\n\t\t\t\t     &sc->nr_to_scan);\n}\n\nstatic inline unsigned long\nlist_lru_walk(struct list_lru *lru, list_lru_walk_cb isolate,\n\t      void *cb_arg, unsigned long nr_to_walk)\n{\n\tlong isolated = 0;\n\tint nid;\n\n\tfor_each_node_state(nid, N_NORMAL_MEMORY) {\n\t\tisolated += list_lru_walk_node(lru, nid, isolate,\n\t\t\t\t\t       cb_arg, &nr_to_walk);\n\t\tif (nr_to_walk <= 0)\n\t\t\tbreak;\n\t}\n\treturn isolated;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}