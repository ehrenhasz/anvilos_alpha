{
  "module_name": "time_namespace.h",
  "hash_id": "a65013a3e4cabecb0f89ec65670e5df51290510aecaa16d1256abd9f4978fa99",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/time_namespace.h",
  "human_readable_source": " \n#ifndef _LINUX_TIMENS_H\n#define _LINUX_TIMENS_H\n\n\n#include <linux/sched.h>\n#include <linux/nsproxy.h>\n#include <linux/ns_common.h>\n#include <linux/err.h>\n\nstruct user_namespace;\nextern struct user_namespace init_user_ns;\n\nstruct timens_offsets {\n\tstruct timespec64 monotonic;\n\tstruct timespec64 boottime;\n};\n\nstruct time_namespace {\n\tstruct user_namespace\t*user_ns;\n\tstruct ucounts\t\t*ucounts;\n\tstruct ns_common\tns;\n\tstruct timens_offsets\toffsets;\n\tstruct page\t\t*vvar_page;\n\t \n\tbool\t\t\tfrozen_offsets;\n} __randomize_layout;\n\nextern struct time_namespace init_time_ns;\n\n#ifdef CONFIG_TIME_NS\nextern int vdso_join_timens(struct task_struct *task,\n\t\t\t    struct time_namespace *ns);\nextern void timens_commit(struct task_struct *tsk, struct time_namespace *ns);\n\nstatic inline struct time_namespace *get_time_ns(struct time_namespace *ns)\n{\n\trefcount_inc(&ns->ns.count);\n\treturn ns;\n}\n\nstruct time_namespace *copy_time_ns(unsigned long flags,\n\t\t\t\t    struct user_namespace *user_ns,\n\t\t\t\t    struct time_namespace *old_ns);\nvoid free_time_ns(struct time_namespace *ns);\nvoid timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk);\nstruct page *find_timens_vvar_page(struct vm_area_struct *vma);\n\nstatic inline void put_time_ns(struct time_namespace *ns)\n{\n\tif (refcount_dec_and_test(&ns->ns.count))\n\t\tfree_time_ns(ns);\n}\n\nvoid proc_timens_show_offsets(struct task_struct *p, struct seq_file *m);\n\nstruct proc_timens_offset {\n\tint\t\t\tclockid;\n\tstruct timespec64\tval;\n};\n\nint proc_timens_set_offset(struct file *file, struct task_struct *p,\n\t\t\t   struct proc_timens_offset *offsets, int n);\n\nstatic inline void timens_add_monotonic(struct timespec64 *ts)\n{\n\tstruct timens_offsets *ns_offsets = &current->nsproxy->time_ns->offsets;\n\n\t*ts = timespec64_add(*ts, ns_offsets->monotonic);\n}\n\nstatic inline void timens_add_boottime(struct timespec64 *ts)\n{\n\tstruct timens_offsets *ns_offsets = &current->nsproxy->time_ns->offsets;\n\n\t*ts = timespec64_add(*ts, ns_offsets->boottime);\n}\n\nstatic inline u64 timens_add_boottime_ns(u64 nsec)\n{\n\tstruct timens_offsets *ns_offsets = &current->nsproxy->time_ns->offsets;\n\n\treturn nsec + timespec64_to_ns(&ns_offsets->boottime);\n}\n\nstatic inline void timens_sub_boottime(struct timespec64 *ts)\n{\n\tstruct timens_offsets *ns_offsets = &current->nsproxy->time_ns->offsets;\n\n\t*ts = timespec64_sub(*ts, ns_offsets->boottime);\n}\n\nktime_t do_timens_ktime_to_host(clockid_t clockid, ktime_t tim,\n\t\t\t\tstruct timens_offsets *offsets);\n\nstatic inline ktime_t timens_ktime_to_host(clockid_t clockid, ktime_t tim)\n{\n\tstruct time_namespace *ns = current->nsproxy->time_ns;\n\n\tif (likely(ns == &init_time_ns))\n\t\treturn tim;\n\n\treturn do_timens_ktime_to_host(clockid, tim, &ns->offsets);\n}\n\n#else\nstatic inline int vdso_join_timens(struct task_struct *task,\n\t\t\t\t   struct time_namespace *ns)\n{\n\treturn 0;\n}\n\nstatic inline void timens_commit(struct task_struct *tsk,\n\t\t\t\t struct time_namespace *ns)\n{\n}\n\nstatic inline struct time_namespace *get_time_ns(struct time_namespace *ns)\n{\n\treturn NULL;\n}\n\nstatic inline void put_time_ns(struct time_namespace *ns)\n{\n}\n\nstatic inline\nstruct time_namespace *copy_time_ns(unsigned long flags,\n\t\t\t\t    struct user_namespace *user_ns,\n\t\t\t\t    struct time_namespace *old_ns)\n{\n\tif (flags & CLONE_NEWTIME)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn old_ns;\n}\n\nstatic inline void timens_on_fork(struct nsproxy *nsproxy,\n\t\t\t\t struct task_struct *tsk)\n{\n\treturn;\n}\n\nstatic inline struct page *find_timens_vvar_page(struct vm_area_struct *vma)\n{\n\treturn NULL;\n}\n\nstatic inline void timens_add_monotonic(struct timespec64 *ts) { }\nstatic inline void timens_add_boottime(struct timespec64 *ts) { }\n\nstatic inline u64 timens_add_boottime_ns(u64 nsec)\n{\n\treturn nsec;\n}\n\nstatic inline void timens_sub_boottime(struct timespec64 *ts) { }\n\nstatic inline ktime_t timens_ktime_to_host(clockid_t clockid, ktime_t tim)\n{\n\treturn tim;\n}\n#endif\n\nstruct vdso_data *arch_get_vdso_data(void *vvar_page);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}