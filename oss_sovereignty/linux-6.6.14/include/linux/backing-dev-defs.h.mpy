{
  "module_name": "backing-dev-defs.h",
  "hash_id": "2349627ba557284ab1b9558042649c2898909bf0f09f88f9053a7b49a70eec87",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/backing-dev-defs.h",
  "human_readable_source": " \n#ifndef __LINUX_BACKING_DEV_DEFS_H\n#define __LINUX_BACKING_DEV_DEFS_H\n\n#include <linux/list.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/percpu_counter.h>\n#include <linux/percpu-refcount.h>\n#include <linux/flex_proportions.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/kref.h>\n#include <linux/refcount.h>\n\nstruct page;\nstruct device;\nstruct dentry;\n\n \nenum wb_state {\n\tWB_registered,\t\t \n\tWB_writeback_running,\t \n\tWB_has_dirty_io,\t \n\tWB_start_all,\t\t \n};\n\nenum wb_stat_item {\n\tWB_RECLAIMABLE,\n\tWB_WRITEBACK,\n\tWB_DIRTIED,\n\tWB_WRITTEN,\n\tNR_WB_STAT_ITEMS\n};\n\n#define WB_STAT_BATCH (8*(1+ilog2(nr_cpu_ids)))\n\n \nenum wb_reason {\n\tWB_REASON_BACKGROUND,\n\tWB_REASON_VMSCAN,\n\tWB_REASON_SYNC,\n\tWB_REASON_PERIODIC,\n\tWB_REASON_LAPTOP_TIMER,\n\tWB_REASON_FS_FREE_SPACE,\n\t \n\tWB_REASON_FORKER_THREAD,\n\tWB_REASON_FOREIGN_FLUSH,\n\n\tWB_REASON_MAX,\n};\n\nstruct wb_completion {\n\tatomic_t\t\tcnt;\n\twait_queue_head_t\t*waitq;\n};\n\n#define __WB_COMPLETION_INIT(_waitq)\t\\\n\t(struct wb_completion){ .cnt = ATOMIC_INIT(1), .waitq = (_waitq) }\n\n \n#define WB_COMPLETION_INIT(bdi)\t\t__WB_COMPLETION_INIT(&(bdi)->wb_waitq)\n\n#define DEFINE_WB_COMPLETION(cmpl, bdi)\t\\\n\tstruct wb_completion cmpl = WB_COMPLETION_INIT(bdi)\n\n \nstruct bdi_writeback {\n\tstruct backing_dev_info *bdi;\t \n\n\tunsigned long state;\t\t \n\tunsigned long last_old_flush;\t \n\n\tstruct list_head b_dirty;\t \n\tstruct list_head b_io;\t\t \n\tstruct list_head b_more_io;\t \n\tstruct list_head b_dirty_time;\t \n\tspinlock_t list_lock;\t\t \n\n\tatomic_t writeback_inodes;\t \n\tstruct percpu_counter stat[NR_WB_STAT_ITEMS];\n\n\tunsigned long bw_time_stamp;\t \n\tunsigned long dirtied_stamp;\n\tunsigned long written_stamp;\t \n\tunsigned long write_bandwidth;\t \n\tunsigned long avg_write_bandwidth;  \n\n\t \n\tunsigned long dirty_ratelimit;\n\tunsigned long balanced_dirty_ratelimit;\n\n\tstruct fprop_local_percpu completions;\n\tint dirty_exceeded;\n\tenum wb_reason start_all_reason;\n\n\tspinlock_t work_lock;\t\t \n\tstruct list_head work_list;\n\tstruct delayed_work dwork;\t \n\tstruct delayed_work bw_dwork;\t \n\n\tunsigned long dirty_sleep;\t \n\n\tstruct list_head bdi_node;\t \n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tstruct percpu_ref refcnt;\t \n\tstruct fprop_local_percpu memcg_completions;\n\tstruct cgroup_subsys_state *memcg_css;  \n\tstruct cgroup_subsys_state *blkcg_css;  \n\tstruct list_head memcg_node;\t \n\tstruct list_head blkcg_node;\t \n\tstruct list_head b_attached;\t \n\tstruct list_head offline_node;\t \n\n\tunion {\n\t\tstruct work_struct release_work;\n\t\tstruct rcu_head rcu;\n\t};\n#endif\n};\n\nstruct backing_dev_info {\n\tu64 id;\n\tstruct rb_node rb_node;  \n\tstruct list_head bdi_list;\n\tunsigned long ra_pages;\t \n\tunsigned long io_pages;\t \n\n\tstruct kref refcnt;\t \n\tunsigned int capabilities;  \n\tunsigned int min_ratio;\n\tunsigned int max_ratio, max_prop_frac;\n\n\t \n\tatomic_long_t tot_write_bandwidth;\n\n\tstruct bdi_writeback wb;   \n\tstruct list_head wb_list;  \n#ifdef CONFIG_CGROUP_WRITEBACK\n\tstruct radix_tree_root cgwb_tree;  \n\tstruct mutex cgwb_release_mutex;   \n\tstruct rw_semaphore wb_switch_rwsem;  \n#endif\n\twait_queue_head_t wb_waitq;\n\n\tstruct device *dev;\n\tchar dev_name[64];\n\tstruct device *owner;\n\n\tstruct timer_list laptop_mode_wb_timer;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *debug_dir;\n#endif\n};\n\nstruct wb_lock_cookie {\n\tbool locked;\n\tunsigned long flags;\n};\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\n \nstatic inline bool wb_tryget(struct bdi_writeback *wb)\n{\n\tif (wb != &wb->bdi->wb)\n\t\treturn percpu_ref_tryget(&wb->refcnt);\n\treturn true;\n}\n\n \nstatic inline void wb_get(struct bdi_writeback *wb)\n{\n\tif (wb != &wb->bdi->wb)\n\t\tpercpu_ref_get(&wb->refcnt);\n}\n\n \nstatic inline void wb_put_many(struct bdi_writeback *wb, unsigned long nr)\n{\n\tif (WARN_ON_ONCE(!wb->bdi)) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (wb != &wb->bdi->wb)\n\t\tpercpu_ref_put_many(&wb->refcnt, nr);\n}\n\n \nstatic inline void wb_put(struct bdi_writeback *wb)\n{\n\twb_put_many(wb, 1);\n}\n\n \nstatic inline bool wb_dying(struct bdi_writeback *wb)\n{\n\treturn percpu_ref_is_dying(&wb->refcnt);\n}\n\n#else\t \n\nstatic inline bool wb_tryget(struct bdi_writeback *wb)\n{\n\treturn true;\n}\n\nstatic inline void wb_get(struct bdi_writeback *wb)\n{\n}\n\nstatic inline void wb_put(struct bdi_writeback *wb)\n{\n}\n\nstatic inline void wb_put_many(struct bdi_writeback *wb, unsigned long nr)\n{\n}\n\nstatic inline bool wb_dying(struct bdi_writeback *wb)\n{\n\treturn false;\n}\n\n#endif\t \n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}