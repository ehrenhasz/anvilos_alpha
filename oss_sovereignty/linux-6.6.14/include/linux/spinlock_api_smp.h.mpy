{
  "module_name": "spinlock_api_smp.h",
  "hash_id": "f8f2e22b082e1d2bcfc1a3920c695b38c0a0f551b74724a4d8a965a45d11b378",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/spinlock_api_smp.h",
  "human_readable_source": "#ifndef __LINUX_SPINLOCK_API_SMP_H\n#define __LINUX_SPINLOCK_API_SMP_H\n\n#ifndef __LINUX_INSIDE_SPINLOCK_H\n# error \"please don't include this file directly\"\n#endif\n\n \n\nint in_lock_functions(unsigned long addr);\n\n#define assert_raw_spin_locked(x)\tBUG_ON(!raw_spin_is_locked(x))\n\nvoid __lockfunc _raw_spin_lock(raw_spinlock_t *lock)\t\t__acquires(lock);\nvoid __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)\n\t\t\t\t\t\t\t\t__acquires(lock);\nvoid __lockfunc\n_raw_spin_lock_nest_lock(raw_spinlock_t *lock, struct lockdep_map *map)\n\t\t\t\t\t\t\t\t__acquires(lock);\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\t\t__acquires(lock);\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n\t\t\t\t\t\t\t\t__acquires(lock);\n\nunsigned long __lockfunc _raw_spin_lock_irqsave(raw_spinlock_t *lock)\n\t\t\t\t\t\t\t\t__acquires(lock);\nunsigned long __lockfunc\n_raw_spin_lock_irqsave_nested(raw_spinlock_t *lock, int subclass)\n\t\t\t\t\t\t\t\t__acquires(lock);\nint __lockfunc _raw_spin_trylock(raw_spinlock_t *lock);\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock);\nvoid __lockfunc _raw_spin_unlock(raw_spinlock_t *lock)\t\t__releases(lock);\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\t__releases(lock);\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\t__releases(lock);\nvoid __lockfunc\n_raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n\t\t\t\t\t\t\t\t__releases(lock);\n\n#ifdef CONFIG_INLINE_SPIN_LOCK\n#define _raw_spin_lock(lock) __raw_spin_lock(lock)\n#endif\n\n#ifdef CONFIG_INLINE_SPIN_LOCK_BH\n#define _raw_spin_lock_bh(lock) __raw_spin_lock_bh(lock)\n#endif\n\n#ifdef CONFIG_INLINE_SPIN_LOCK_IRQ\n#define _raw_spin_lock_irq(lock) __raw_spin_lock_irq(lock)\n#endif\n\n#ifdef CONFIG_INLINE_SPIN_LOCK_IRQSAVE\n#define _raw_spin_lock_irqsave(lock) __raw_spin_lock_irqsave(lock)\n#endif\n\n#ifdef CONFIG_INLINE_SPIN_TRYLOCK\n#define _raw_spin_trylock(lock) __raw_spin_trylock(lock)\n#endif\n\n#ifdef CONFIG_INLINE_SPIN_TRYLOCK_BH\n#define _raw_spin_trylock_bh(lock) __raw_spin_trylock_bh(lock)\n#endif\n\n#ifndef CONFIG_UNINLINE_SPIN_UNLOCK\n#define _raw_spin_unlock(lock) __raw_spin_unlock(lock)\n#endif\n\n#ifdef CONFIG_INLINE_SPIN_UNLOCK_BH\n#define _raw_spin_unlock_bh(lock) __raw_spin_unlock_bh(lock)\n#endif\n\n#ifdef CONFIG_INLINE_SPIN_UNLOCK_IRQ\n#define _raw_spin_unlock_irq(lock) __raw_spin_unlock_irq(lock)\n#endif\n\n#ifdef CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE\n#define _raw_spin_unlock_irqrestore(lock, flags) __raw_spin_unlock_irqrestore(lock, flags)\n#endif\n\nstatic inline int __raw_spin_trylock(raw_spinlock_t *lock)\n{\n\tpreempt_disable();\n\tif (do_raw_spin_trylock(lock)) {\n\t\tspin_acquire(&lock->dep_map, 0, 1, _RET_IP_);\n\t\treturn 1;\n\t}\n\tpreempt_enable();\n\treturn 0;\n}\n\n \n#if !defined(CONFIG_GENERIC_LOCKBREAK) || defined(CONFIG_DEBUG_LOCK_ALLOC)\n\nstatic inline unsigned long __raw_spin_lock_irqsave(raw_spinlock_t *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}\n\nstatic inline void __raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\tlocal_irq_disable();\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}\n\nstatic inline void __raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__local_bh_disable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);\n\tspin_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}\n\nstatic inline void __raw_spin_lock(raw_spinlock_t *lock)\n{\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}\n\n#endif  \n\nstatic inline void __raw_spin_unlock(raw_spinlock_t *lock)\n{\n\tspin_release(&lock->dep_map, _RET_IP_);\n\tdo_raw_spin_unlock(lock);\n\tpreempt_enable();\n}\n\nstatic inline void __raw_spin_unlock_irqrestore(raw_spinlock_t *lock,\n\t\t\t\t\t    unsigned long flags)\n{\n\tspin_release(&lock->dep_map, _RET_IP_);\n\tdo_raw_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}\n\nstatic inline void __raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\tspin_release(&lock->dep_map, _RET_IP_);\n\tdo_raw_spin_unlock(lock);\n\tlocal_irq_enable();\n\tpreempt_enable();\n}\n\nstatic inline void __raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\tspin_release(&lock->dep_map, _RET_IP_);\n\tdo_raw_spin_unlock(lock);\n\t__local_bh_enable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);\n}\n\nstatic inline int __raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\t__local_bh_disable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);\n\tif (do_raw_spin_trylock(lock)) {\n\t\tspin_acquire(&lock->dep_map, 0, 1, _RET_IP_);\n\t\treturn 1;\n\t}\n\t__local_bh_enable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);\n\treturn 0;\n}\n\n \n#ifndef CONFIG_PREEMPT_RT\n#include <linux/rwlock_api_smp.h>\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}