{
  "module_name": "icmpv6.h",
  "hash_id": "ba771abc9ad976f57caac711e1044ce77562e877afa5dc4bf29d9b3968c38eb8",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/icmpv6.h",
  "human_readable_source": " \n#ifndef _LINUX_ICMPV6_H\n#define _LINUX_ICMPV6_H\n\n#include <linux/skbuff.h>\n#include <linux/ipv6.h>\n#include <uapi/linux/icmpv6.h>\n\nstatic inline struct icmp6hdr *icmp6_hdr(const struct sk_buff *skb)\n{\n\treturn (struct icmp6hdr *)skb_transport_header(skb);\n}\n\n#include <linux/netdevice.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n\ntypedef void ip6_icmp_send_t(struct sk_buff *skb, u8 type, u8 code, __u32 info,\n\t\t\t     const struct in6_addr *force_saddr,\n\t\t\t     const struct inet6_skb_parm *parm);\nvoid icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info,\n\t\tconst struct in6_addr *force_saddr,\n\t\tconst struct inet6_skb_parm *parm);\n#if IS_BUILTIN(CONFIG_IPV6)\nstatic inline void __icmpv6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info,\n\t\t\t\t const struct inet6_skb_parm *parm)\n{\n\ticmp6_send(skb, type, code, info, NULL, parm);\n}\nstatic inline int inet6_register_icmp_sender(ip6_icmp_send_t *fn)\n{\n\tBUILD_BUG_ON(fn != icmp6_send);\n\treturn 0;\n}\nstatic inline int inet6_unregister_icmp_sender(ip6_icmp_send_t *fn)\n{\n\tBUILD_BUG_ON(fn != icmp6_send);\n\treturn 0;\n}\n#else\nextern void __icmpv6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info,\n\t\t\t  const struct inet6_skb_parm *parm);\nextern int inet6_register_icmp_sender(ip6_icmp_send_t *fn);\nextern int inet6_unregister_icmp_sender(ip6_icmp_send_t *fn);\n#endif\n\nstatic inline void icmpv6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info)\n{\n\t__icmpv6_send(skb, type, code, info, IP6CB(skb));\n}\n\nint ip6_err_gen_icmpv6_unreach(struct sk_buff *skb, int nhs, int type,\n\t\t\t       unsigned int data_len);\n\n#if IS_ENABLED(CONFIG_NF_NAT)\nvoid icmpv6_ndo_send(struct sk_buff *skb_in, u8 type, u8 code, __u32 info);\n#else\nstatic inline void icmpv6_ndo_send(struct sk_buff *skb_in, u8 type, u8 code, __u32 info)\n{\n\tstruct inet6_skb_parm parm = { 0 };\n\t__icmpv6_send(skb_in, type, code, info, &parm);\n}\n#endif\n\n#else\n\nstatic inline void icmpv6_send(struct sk_buff *skb,\n\t\t\t       u8 type, u8 code, __u32 info)\n{\n}\n\nstatic inline void icmpv6_ndo_send(struct sk_buff *skb,\n\t\t\t\t   u8 type, u8 code, __u32 info)\n{\n}\n#endif\n\nextern int\t\t\t\ticmpv6_init(void);\nextern int\t\t\t\ticmpv6_err_convert(u8 type, u8 code,\n\t\t\t\t\t\t\t   int *err);\nextern void\t\t\t\ticmpv6_cleanup(void);\nextern void\t\t\t\ticmpv6_param_prob_reason(struct sk_buff *skb,\n\t\t\t\t\t\t\t\t u8 code, int pos,\n\t\t\t\t\t\t\t\t enum skb_drop_reason reason);\n\nstruct flowi6;\nstruct in6_addr;\n\nvoid icmpv6_flow_init(const struct sock *sk, struct flowi6 *fl6, u8 type,\n\t\t      const struct in6_addr *saddr,\n\t\t      const struct in6_addr *daddr, int oif);\n\nstatic inline void icmpv6_param_prob(struct sk_buff *skb, u8 code, int pos)\n{\n\ticmpv6_param_prob_reason(skb, code, pos,\n\t\t\t\t SKB_DROP_REASON_NOT_SPECIFIED);\n}\n\nstatic inline bool icmpv6_is_err(int type)\n{\n\tswitch (type) {\n\tcase ICMPV6_DEST_UNREACH:\n\tcase ICMPV6_PKT_TOOBIG:\n\tcase ICMPV6_TIME_EXCEED:\n\tcase ICMPV6_PARAMPROB:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}