{
  "module_name": "exportfs.h",
  "hash_id": "34820568c8cbe17d5b52cf75cfa58ccfb781822163a8c4153bfd6b0f8e1e03f7",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/exportfs.h",
  "human_readable_source": " \n#ifndef LINUX_EXPORTFS_H\n#define LINUX_EXPORTFS_H 1\n\n#include <linux/types.h>\n\nstruct dentry;\nstruct iattr;\nstruct inode;\nstruct iomap;\nstruct super_block;\nstruct vfsmount;\n\n \n#define MAX_HANDLE_SZ 128\n\n \nenum fid_type {\n\t \n\tFILEID_ROOT = 0,\n\n\t \n\tFILEID_INO32_GEN = 1,\n\n\t \n\tFILEID_INO32_GEN_PARENT = 2,\n\n\t \n\tFILEID_BTRFS_WITHOUT_PARENT = 0x4d,\n\n\t \n\tFILEID_BTRFS_WITH_PARENT = 0x4e,\n\n\t \n\tFILEID_BTRFS_WITH_PARENT_ROOT = 0x4f,\n\n\t \n\tFILEID_UDF_WITHOUT_PARENT = 0x51,\n\n\t \n\tFILEID_UDF_WITH_PARENT = 0x52,\n\n\t \n\tFILEID_NILFS_WITHOUT_PARENT = 0x61,\n\n\t \n\tFILEID_NILFS_WITH_PARENT = 0x62,\n\n\t \n\tFILEID_FAT_WITHOUT_PARENT = 0x71,\n\n\t \n\tFILEID_FAT_WITH_PARENT = 0x72,\n\n\t \n\tFILEID_LUSTRE = 0x97,\n\n\t \n\tFILEID_KERNFS = 0xfe,\n\n\t \n\tFILEID_INVALID = 0xff,\n};\n\nstruct fid {\n\tunion {\n\t\tstruct {\n\t\t\tu32 ino;\n\t\t\tu32 gen;\n\t\t\tu32 parent_ino;\n\t\t\tu32 parent_gen;\n\t\t} i32;\n \t\tstruct {\n \t\t\tu32 block;\n \t\t\tu16 partref;\n \t\t\tu16 parent_partref;\n \t\t\tu32 generation;\n \t\t\tu32 parent_block;\n \t\t\tu32 parent_generation;\n \t\t} udf;\n\t\tDECLARE_FLEX_ARRAY(__u32, raw);\n\t};\n};\n\n#define EXPORT_FH_CONNECTABLE\t0x1  \n#define EXPORT_FH_FID\t\t0x2  \n\n \n\nstruct export_operations {\n\tint (*encode_fh)(struct inode *inode, __u32 *fh, int *max_len,\n\t\t\tstruct inode *parent);\n\tstruct dentry * (*fh_to_dentry)(struct super_block *sb, struct fid *fid,\n\t\t\tint fh_len, int fh_type);\n\tstruct dentry * (*fh_to_parent)(struct super_block *sb, struct fid *fid,\n\t\t\tint fh_len, int fh_type);\n\tint (*get_name)(struct dentry *parent, char *name,\n\t\t\tstruct dentry *child);\n\tstruct dentry * (*get_parent)(struct dentry *child);\n\tint (*commit_metadata)(struct inode *inode);\n\n\tint (*get_uuid)(struct super_block *sb, u8 *buf, u32 *len, u64 *offset);\n\tint (*map_blocks)(struct inode *inode, loff_t offset,\n\t\t\t  u64 len, struct iomap *iomap,\n\t\t\t  bool write, u32 *device_generation);\n\tint (*commit_blocks)(struct inode *inode, struct iomap *iomaps,\n\t\t\t     int nr_iomaps, struct iattr *iattr);\n#define\tEXPORT_OP_NOWCC\t\t\t(0x1)  \n#define\tEXPORT_OP_NOSUBTREECHK\t\t(0x2)  \n#define\tEXPORT_OP_CLOSE_BEFORE_UNLINK\t(0x4)  \n#define EXPORT_OP_REMOTE_FS\t\t(0x8)  \n#define EXPORT_OP_NOATOMIC_ATTR\t\t(0x10)  \n#define EXPORT_OP_FLUSH_ON_CLOSE\t(0x20)  \n\tunsigned long\tflags;\n};\n\nextern int exportfs_encode_inode_fh(struct inode *inode, struct fid *fid,\n\t\t\t\t    int *max_len, struct inode *parent,\n\t\t\t\t    int flags);\nextern int exportfs_encode_fh(struct dentry *dentry, struct fid *fid,\n\t\t\t      int *max_len, int flags);\n\nstatic inline int exportfs_encode_fid(struct inode *inode, struct fid *fid,\n\t\t\t\t      int *max_len)\n{\n\treturn exportfs_encode_inode_fh(inode, fid, max_len, NULL,\n\t\t\t\t\tEXPORT_FH_FID);\n}\n\nextern struct dentry *exportfs_decode_fh_raw(struct vfsmount *mnt,\n\t\t\t\t\t     struct fid *fid, int fh_len,\n\t\t\t\t\t     int fileid_type,\n\t\t\t\t\t     int (*acceptable)(void *, struct dentry *),\n\t\t\t\t\t     void *context);\nextern struct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\n\tint fh_len, int fileid_type, int (*acceptable)(void *, struct dentry *),\n\tvoid *context);\n\n \nextern struct dentry *generic_fh_to_dentry(struct super_block *sb,\n\tstruct fid *fid, int fh_len, int fh_type,\n\tstruct inode *(*get_inode) (struct super_block *sb, u64 ino, u32 gen));\nextern struct dentry *generic_fh_to_parent(struct super_block *sb,\n\tstruct fid *fid, int fh_len, int fh_type,\n\tstruct inode *(*get_inode) (struct super_block *sb, u64 ino, u32 gen));\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}