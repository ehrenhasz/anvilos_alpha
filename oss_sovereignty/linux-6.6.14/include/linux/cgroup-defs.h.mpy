{
  "module_name": "cgroup-defs.h",
  "hash_id": "bb415423189431097ef10a8d9c5b17fbd18385c06e3d85a06b4e284ede3ec90c",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/cgroup-defs.h",
  "human_readable_source": " \n \n#ifndef _LINUX_CGROUP_DEFS_H\n#define _LINUX_CGROUP_DEFS_H\n\n#include <linux/limits.h>\n#include <linux/list.h>\n#include <linux/idr.h>\n#include <linux/wait.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/refcount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/u64_stats_sync.h>\n#include <linux/workqueue.h>\n#include <linux/bpf-cgroup-defs.h>\n#include <linux/psi_types.h>\n\n#ifdef CONFIG_CGROUPS\n\nstruct cgroup;\nstruct cgroup_root;\nstruct cgroup_subsys;\nstruct cgroup_taskset;\nstruct kernfs_node;\nstruct kernfs_ops;\nstruct kernfs_open_file;\nstruct seq_file;\nstruct poll_table_struct;\n\n#define MAX_CGROUP_TYPE_NAMELEN 32\n#define MAX_CGROUP_ROOT_NAMELEN 64\n#define MAX_CFTYPE_NAME\t\t64\n\n \n#define SUBSYS(_x) _x ## _cgrp_id,\nenum cgroup_subsys_id {\n#include <linux/cgroup_subsys.h>\n\tCGROUP_SUBSYS_COUNT,\n};\n#undef SUBSYS\n\n \nenum {\n\tCSS_NO_REF\t= (1 << 0),  \n\tCSS_ONLINE\t= (1 << 1),  \n\tCSS_RELEASED\t= (1 << 2),  \n\tCSS_VISIBLE\t= (1 << 3),  \n\tCSS_DYING\t= (1 << 4),  \n};\n\n \nenum {\n\t \n\tCGRP_NOTIFY_ON_RELEASE,\n\t \n\tCGRP_CPUSET_CLONE_CHILDREN,\n\n\t \n\tCGRP_FREEZE,\n\n\t \n\tCGRP_FROZEN,\n\n\t \n\tCGRP_KILL,\n};\n\n \nenum {\n\tCGRP_ROOT_NOPREFIX\t= (1 << 1),  \n\tCGRP_ROOT_XATTR\t\t= (1 << 2),  \n\n\t \n\tCGRP_ROOT_NS_DELEGATE\t= (1 << 3),\n\n\t \n\tCGRP_ROOT_FAVOR_DYNMODS = (1 << 4),\n\n\t \n\tCGRP_ROOT_CPUSET_V2_MODE = (1 << 16),\n\n\t \n\tCGRP_ROOT_MEMORY_LOCAL_EVENTS = (1 << 17),\n\n\t \n\tCGRP_ROOT_MEMORY_RECURSIVE_PROT = (1 << 18),\n};\n\n \nenum {\n\tCFTYPE_ONLY_ON_ROOT\t= (1 << 0),\t \n\tCFTYPE_NOT_ON_ROOT\t= (1 << 1),\t \n\tCFTYPE_NS_DELEGATABLE\t= (1 << 2),\t \n\n\tCFTYPE_NO_PREFIX\t= (1 << 3),\t \n\tCFTYPE_WORLD_WRITABLE\t= (1 << 4),\t \n\tCFTYPE_DEBUG\t\t= (1 << 5),\t \n\n\t \n\t__CFTYPE_ONLY_ON_DFL\t= (1 << 16),\t \n\t__CFTYPE_NOT_ON_DFL\t= (1 << 17),\t \n\t__CFTYPE_ADDED\t\t= (1 << 18),\n};\n\n \nstruct cgroup_file {\n\t \n\tstruct kernfs_node *kn;\n\tunsigned long notified_at;\n\tstruct timer_list notify_timer;\n};\n\n \nstruct cgroup_subsys_state {\n\t \n\tstruct cgroup *cgroup;\n\n\t \n\tstruct cgroup_subsys *ss;\n\n\t \n\tstruct percpu_ref refcnt;\n\n\t \n\tstruct list_head sibling;\n\tstruct list_head children;\n\n\t \n\tstruct list_head rstat_css_node;\n\n\t \n\tint id;\n\n\tunsigned int flags;\n\n\t \n\tu64 serial_nr;\n\n\t \n\tatomic_t online_cnt;\n\n\t \n\tstruct work_struct destroy_work;\n\tstruct rcu_work destroy_rwork;\n\n\t \n\tstruct cgroup_subsys_state *parent;\n};\n\n \nstruct css_set {\n\t \n\tstruct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT];\n\n\t \n\trefcount_t refcount;\n\n\t \n\tstruct css_set *dom_cset;\n\n\t \n\tstruct cgroup *dfl_cgrp;\n\n\t \n\tint nr_tasks;\n\n\t \n\tstruct list_head tasks;\n\tstruct list_head mg_tasks;\n\tstruct list_head dying_tasks;\n\n\t \n\tstruct list_head task_iters;\n\n\t \n\tstruct list_head e_cset_node[CGROUP_SUBSYS_COUNT];\n\n\t \n\tstruct list_head threaded_csets;\n\tstruct list_head threaded_csets_node;\n\n\t \n\tstruct hlist_node hlist;\n\n\t \n\tstruct list_head cgrp_links;\n\n\t \n\tstruct list_head mg_src_preload_node;\n\tstruct list_head mg_dst_preload_node;\n\tstruct list_head mg_node;\n\n\t \n\tstruct cgroup *mg_src_cgrp;\n\tstruct cgroup *mg_dst_cgrp;\n\tstruct css_set *mg_dst_cset;\n\n\t \n\tbool dead;\n\n\t \n\tstruct rcu_head rcu_head;\n};\n\nstruct cgroup_base_stat {\n\tstruct task_cputime cputime;\n\n#ifdef CONFIG_SCHED_CORE\n\tu64 forceidle_sum;\n#endif\n};\n\n \nstruct cgroup_rstat_cpu {\n\t \n\tstruct u64_stats_sync bsync;\n\tstruct cgroup_base_stat bstat;\n\n\t \n\tstruct cgroup_base_stat last_bstat;\n\n\t \n\tstruct cgroup_base_stat subtree_bstat;\n\n\t \n\tstruct cgroup_base_stat last_subtree_bstat;\n\n\t \n\tstruct cgroup *updated_children;\t \n\tstruct cgroup *updated_next;\t\t \n};\n\nstruct cgroup_freezer_state {\n\t \n\tbool freeze;\n\n\t \n\tint e_freeze;\n\n\t \n\n\t \n\tint nr_frozen_descendants;\n\n\t \n\tint nr_frozen_tasks;\n};\n\nstruct cgroup {\n\t \n\tstruct cgroup_subsys_state self;\n\n\tunsigned long flags;\t\t \n\n\t \n\tint level;\n\n\t \n\tint max_depth;\n\n\t \n\tint nr_descendants;\n\tint nr_dying_descendants;\n\tint max_descendants;\n\n\t \n\tint nr_populated_csets;\n\tint nr_populated_domain_children;\n\tint nr_populated_threaded_children;\n\n\tint nr_threaded_children;\t \n\n\tstruct kernfs_node *kn;\t\t \n\tstruct cgroup_file procs_file;\t \n\tstruct cgroup_file events_file;\t \n\n\t \n\tstruct cgroup_file psi_files[NR_PSI_RESOURCES];\n\n\t \n\tu16 subtree_control;\n\tu16 subtree_ss_mask;\n\tu16 old_subtree_control;\n\tu16 old_subtree_ss_mask;\n\n\t \n\tstruct cgroup_subsys_state __rcu *subsys[CGROUP_SUBSYS_COUNT];\n\n\tstruct cgroup_root *root;\n\n\t \n\tstruct list_head cset_links;\n\n\t \n\tstruct list_head e_csets[CGROUP_SUBSYS_COUNT];\n\n\t \n\tstruct cgroup *dom_cgrp;\n\tstruct cgroup *old_dom_cgrp;\t\t \n\n\t \n\tstruct cgroup_rstat_cpu __percpu *rstat_cpu;\n\tstruct list_head rstat_css_list;\n\n\t \n\tstruct cgroup_base_stat last_bstat;\n\tstruct cgroup_base_stat bstat;\n\tstruct prev_cputime prev_cputime;\t \n\n\t \n\tstruct list_head pidlists;\n\tstruct mutex pidlist_mutex;\n\n\t \n\twait_queue_head_t offline_waitq;\n\n\t \n\tstruct work_struct release_agent_work;\n\n\t \n\tstruct psi_group *psi;\n\n\t \n\tstruct cgroup_bpf bpf;\n\n\t \n\tatomic_t congestion_count;\n\n\t \n\tstruct cgroup_freezer_state freezer;\n\n#ifdef CONFIG_BPF_SYSCALL\n\tstruct bpf_local_storage __rcu  *bpf_cgrp_storage;\n#endif\n\n\t \n\tstruct cgroup *ancestors[];\n};\n\n \nstruct cgroup_root {\n\tstruct kernfs_root *kf_root;\n\n\t \n\tunsigned int subsys_mask;\n\n\t \n\tint hierarchy_id;\n\n\t \n\tstruct cgroup cgrp;\n\n\t \n\tstruct cgroup *cgrp_ancestor_storage;\n\n\t \n\tatomic_t nr_cgrps;\n\n\t \n\tstruct list_head root_list;\n\n\t \n\tunsigned int flags;\n\n\t \n\tchar release_agent_path[PATH_MAX];\n\n\t \n\tchar name[MAX_CGROUP_ROOT_NAMELEN];\n};\n\n \nstruct cftype {\n\t \n\tchar name[MAX_CFTYPE_NAME];\n\tunsigned long private;\n\n\t \n\tsize_t max_write_len;\n\n\t \n\tunsigned int flags;\n\n\t \n\tunsigned int file_offset;\n\n\t \n\tstruct cgroup_subsys *ss;\t \n\tstruct list_head node;\t\t \n\tstruct kernfs_ops *kf_ops;\n\n\tint (*open)(struct kernfs_open_file *of);\n\tvoid (*release)(struct kernfs_open_file *of);\n\n\t \n\tu64 (*read_u64)(struct cgroup_subsys_state *css, struct cftype *cft);\n\t \n\ts64 (*read_s64)(struct cgroup_subsys_state *css, struct cftype *cft);\n\n\t \n\tint (*seq_show)(struct seq_file *sf, void *v);\n\n\t \n\tvoid *(*seq_start)(struct seq_file *sf, loff_t *ppos);\n\tvoid *(*seq_next)(struct seq_file *sf, void *v, loff_t *ppos);\n\tvoid (*seq_stop)(struct seq_file *sf, void *v);\n\n\t \n\tint (*write_u64)(struct cgroup_subsys_state *css, struct cftype *cft,\n\t\t\t u64 val);\n\t \n\tint (*write_s64)(struct cgroup_subsys_state *css, struct cftype *cft,\n\t\t\t s64 val);\n\n\t \n\tssize_t (*write)(struct kernfs_open_file *of,\n\t\t\t char *buf, size_t nbytes, loff_t off);\n\n\t__poll_t (*poll)(struct kernfs_open_file *of,\n\t\t\t struct poll_table_struct *pt);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tstruct lock_class_key\tlockdep_key;\n#endif\n};\n\n \nstruct cgroup_subsys {\n\tstruct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *parent_css);\n\tint (*css_online)(struct cgroup_subsys_state *css);\n\tvoid (*css_offline)(struct cgroup_subsys_state *css);\n\tvoid (*css_released)(struct cgroup_subsys_state *css);\n\tvoid (*css_free)(struct cgroup_subsys_state *css);\n\tvoid (*css_reset)(struct cgroup_subsys_state *css);\n\tvoid (*css_rstat_flush)(struct cgroup_subsys_state *css, int cpu);\n\tint (*css_extra_stat_show)(struct seq_file *seq,\n\t\t\t\t   struct cgroup_subsys_state *css);\n\tint (*css_local_stat_show)(struct seq_file *seq,\n\t\t\t\t   struct cgroup_subsys_state *css);\n\n\tint (*can_attach)(struct cgroup_taskset *tset);\n\tvoid (*cancel_attach)(struct cgroup_taskset *tset);\n\tvoid (*attach)(struct cgroup_taskset *tset);\n\tvoid (*post_attach)(void);\n\tint (*can_fork)(struct task_struct *task,\n\t\t\tstruct css_set *cset);\n\tvoid (*cancel_fork)(struct task_struct *task, struct css_set *cset);\n\tvoid (*fork)(struct task_struct *task);\n\tvoid (*exit)(struct task_struct *task);\n\tvoid (*release)(struct task_struct *task);\n\tvoid (*bind)(struct cgroup_subsys_state *root_css);\n\n\tbool early_init:1;\n\n\t \n\tbool implicit_on_dfl:1;\n\n\t \n\tbool threaded:1;\n\n\t \n\tint id;\n\tconst char *name;\n\n\t \n\tconst char *legacy_name;\n\n\t \n\tstruct cgroup_root *root;\n\n\t \n\tstruct idr css_idr;\n\n\t \n\tstruct list_head cfts;\n\n\t \n\tstruct cftype *dfl_cftypes;\t \n\tstruct cftype *legacy_cftypes;\t \n\n\t \n\tunsigned int depends_on;\n};\n\nextern struct percpu_rw_semaphore cgroup_threadgroup_rwsem;\n\n \nstatic inline void cgroup_threadgroup_change_begin(struct task_struct *tsk)\n{\n\tpercpu_down_read(&cgroup_threadgroup_rwsem);\n}\n\n \nstatic inline void cgroup_threadgroup_change_end(struct task_struct *tsk)\n{\n\tpercpu_up_read(&cgroup_threadgroup_rwsem);\n}\n\n#else\t \n\n#define CGROUP_SUBSYS_COUNT 0\n\nstatic inline void cgroup_threadgroup_change_begin(struct task_struct *tsk)\n{\n\tmight_sleep();\n}\n\nstatic inline void cgroup_threadgroup_change_end(struct task_struct *tsk) {}\n\n#endif\t \n\n#ifdef CONFIG_SOCK_CGROUP_DATA\n\n \nstruct sock_cgroup_data {\n\tstruct cgroup\t*cgroup;  \n#ifdef CONFIG_CGROUP_NET_CLASSID\n\tu32\t\tclassid;  \n#endif\n#ifdef CONFIG_CGROUP_NET_PRIO\n\tu16\t\tprioidx;  \n#endif\n};\n\nstatic inline u16 sock_cgroup_prioidx(const struct sock_cgroup_data *skcd)\n{\n#ifdef CONFIG_CGROUP_NET_PRIO\n\treturn READ_ONCE(skcd->prioidx);\n#else\n\treturn 1;\n#endif\n}\n\nstatic inline u32 sock_cgroup_classid(const struct sock_cgroup_data *skcd)\n{\n#ifdef CONFIG_CGROUP_NET_CLASSID\n\treturn READ_ONCE(skcd->classid);\n#else\n\treturn 0;\n#endif\n}\n\nstatic inline void sock_cgroup_set_prioidx(struct sock_cgroup_data *skcd,\n\t\t\t\t\t   u16 prioidx)\n{\n#ifdef CONFIG_CGROUP_NET_PRIO\n\tWRITE_ONCE(skcd->prioidx, prioidx);\n#endif\n}\n\nstatic inline void sock_cgroup_set_classid(struct sock_cgroup_data *skcd,\n\t\t\t\t\t   u32 classid)\n{\n#ifdef CONFIG_CGROUP_NET_CLASSID\n\tWRITE_ONCE(skcd->classid, classid);\n#endif\n}\n\n#else\t \n\nstruct sock_cgroup_data {\n};\n\n#endif\t \n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}