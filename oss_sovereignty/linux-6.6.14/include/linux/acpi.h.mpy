{
  "module_name": "acpi.h",
  "hash_id": "115591680c865bdb2b8aa854a8f3870eb11d780c0f3f554ecc971bfcdb83a33e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/acpi.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_ACPI_H\n#define _LINUX_ACPI_H\n\n#include <linux/errno.h>\n#include <linux/ioport.h>\t \n#include <linux/resource_ext.h>\n#include <linux/device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/uuid.h>\n\nstruct irq_domain;\nstruct irq_domain_ops;\n\n#ifndef _LINUX\n#define _LINUX\n#endif\n#include <acpi/acpi.h>\n\n#ifdef\tCONFIG_ACPI\n\n#include <linux/list.h>\n#include <linux/dynamic_debug.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include <acpi/acpi_bus.h>\n#include <acpi/acpi_drivers.h>\n#include <acpi/acpi_numa.h>\n#include <acpi/acpi_io.h>\n#include <asm/acpi.h>\n\nstatic inline acpi_handle acpi_device_handle(struct acpi_device *adev)\n{\n\treturn adev ? adev->handle : NULL;\n}\n\n#define ACPI_COMPANION(dev)\t\tto_acpi_device_node((dev)->fwnode)\n#define ACPI_COMPANION_SET(dev, adev)\tset_primary_fwnode(dev, (adev) ? \\\n\tacpi_fwnode_handle(adev) : NULL)\n#define ACPI_HANDLE(dev)\t\tacpi_device_handle(ACPI_COMPANION(dev))\n#define ACPI_HANDLE_FWNODE(fwnode)\t\\\n\t\t\t\tacpi_device_handle(to_acpi_device_node(fwnode))\n\nstatic inline struct fwnode_handle *acpi_alloc_fwnode_static(void)\n{\n\tstruct fwnode_handle *fwnode;\n\n\tfwnode = kzalloc(sizeof(struct fwnode_handle), GFP_KERNEL);\n\tif (!fwnode)\n\t\treturn NULL;\n\n\tfwnode_init(fwnode, &acpi_static_fwnode_ops);\n\n\treturn fwnode;\n}\n\nstatic inline void acpi_free_fwnode_static(struct fwnode_handle *fwnode)\n{\n\tif (WARN_ON(!is_acpi_static_node(fwnode)))\n\t\treturn;\n\n\tkfree(fwnode);\n}\n\nstatic inline bool has_acpi_companion(struct device *dev)\n{\n\treturn is_acpi_device_node(dev->fwnode);\n}\n\nstatic inline void acpi_preset_companion(struct device *dev,\n\t\t\t\t\t struct acpi_device *parent, u64 addr)\n{\n\tACPI_COMPANION_SET(dev, acpi_find_child_device(parent, addr, false));\n}\n\nstatic inline const char *acpi_dev_name(struct acpi_device *adev)\n{\n\treturn dev_name(&adev->dev);\n}\n\nstruct device *acpi_get_first_physical_node(struct acpi_device *adev);\n\nenum acpi_irq_model_id {\n\tACPI_IRQ_MODEL_PIC = 0,\n\tACPI_IRQ_MODEL_IOAPIC,\n\tACPI_IRQ_MODEL_IOSAPIC,\n\tACPI_IRQ_MODEL_PLATFORM,\n\tACPI_IRQ_MODEL_GIC,\n\tACPI_IRQ_MODEL_LPIC,\n\tACPI_IRQ_MODEL_COUNT\n};\n\nextern enum acpi_irq_model_id\tacpi_irq_model;\n\nenum acpi_interrupt_id {\n\tACPI_INTERRUPT_PMI\t= 1,\n\tACPI_INTERRUPT_INIT,\n\tACPI_INTERRUPT_CPEI,\n\tACPI_INTERRUPT_COUNT\n};\n\n#define\tACPI_SPACE_MEM\t\t0\n\nenum acpi_address_range_id {\n\tACPI_ADDRESS_RANGE_MEMORY = 1,\n\tACPI_ADDRESS_RANGE_RESERVED = 2,\n\tACPI_ADDRESS_RANGE_ACPI = 3,\n\tACPI_ADDRESS_RANGE_NVS\t= 4,\n\tACPI_ADDRESS_RANGE_COUNT\n};\n\n\n \nunion acpi_subtable_headers {\n\tstruct acpi_subtable_header common;\n\tstruct acpi_hmat_structure hmat;\n\tstruct acpi_prmt_module_header prmt;\n\tstruct acpi_cedt_header cedt;\n};\n\ntypedef int (*acpi_tbl_table_handler)(struct acpi_table_header *table);\n\ntypedef int (*acpi_tbl_entry_handler)(union acpi_subtable_headers *header,\n\t\t\t\t      const unsigned long end);\n\ntypedef int (*acpi_tbl_entry_handler_arg)(union acpi_subtable_headers *header,\n\t\t\t\t\t  void *arg, const unsigned long end);\n\n \n\nstruct acpi_debugger_ops {\n\tint (*create_thread)(acpi_osd_exec_callback function, void *context);\n\tssize_t (*write_log)(const char *msg);\n\tssize_t (*read_cmd)(char *buffer, size_t length);\n\tint (*wait_command_ready)(bool single_step, char *buffer, size_t length);\n\tint (*notify_command_complete)(void);\n};\n\nstruct acpi_debugger {\n\tconst struct acpi_debugger_ops *ops;\n\tstruct module *owner;\n\tstruct mutex lock;\n};\n\n#ifdef CONFIG_ACPI_DEBUGGER\nint __init acpi_debugger_init(void);\nint acpi_register_debugger(struct module *owner,\n\t\t\t   const struct acpi_debugger_ops *ops);\nvoid acpi_unregister_debugger(const struct acpi_debugger_ops *ops);\nint acpi_debugger_create_thread(acpi_osd_exec_callback function, void *context);\nssize_t acpi_debugger_write_log(const char *msg);\nssize_t acpi_debugger_read_cmd(char *buffer, size_t buffer_length);\nint acpi_debugger_wait_command_ready(void);\nint acpi_debugger_notify_command_complete(void);\n#else\nstatic inline int acpi_debugger_init(void)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_register_debugger(struct module *owner,\n\t\t\t\t\t const struct acpi_debugger_ops *ops)\n{\n\treturn -ENODEV;\n}\n\nstatic inline void acpi_unregister_debugger(const struct acpi_debugger_ops *ops)\n{\n}\n\nstatic inline int acpi_debugger_create_thread(acpi_osd_exec_callback function,\n\t\t\t\t\t      void *context)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_debugger_write_log(const char *msg)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_debugger_read_cmd(char *buffer, u32 buffer_length)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_debugger_wait_command_ready(void)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_debugger_notify_command_complete(void)\n{\n\treturn -ENODEV;\n}\n#endif\n\n#define BAD_MADT_ENTRY(entry, end) (\t\t\t\t\t    \\\n\t\t(!entry) || (unsigned long)entry + sizeof(*entry) > end ||  \\\n\t\t((struct acpi_subtable_header *)entry)->length < sizeof(*entry))\n\nstruct acpi_subtable_proc {\n\tint id;\n\tacpi_tbl_entry_handler handler;\n\tacpi_tbl_entry_handler_arg handler_arg;\n\tvoid *arg;\n\tint count;\n};\n\nvoid __iomem *__acpi_map_table(unsigned long phys, unsigned long size);\nvoid __acpi_unmap_table(void __iomem *map, unsigned long size);\nint early_acpi_boot_init(void);\nint acpi_boot_init (void);\nvoid acpi_boot_table_prepare (void);\nvoid acpi_boot_table_init (void);\nint acpi_mps_check (void);\nint acpi_numa_init (void);\n\nint acpi_locate_initial_tables (void);\nvoid acpi_reserve_initial_tables (void);\nvoid acpi_table_init_complete (void);\nint acpi_table_init (void);\n\n#ifdef CONFIG_ACPI_TABLE_LIB\n#define EXPORT_SYMBOL_ACPI_LIB(x) EXPORT_SYMBOL_NS_GPL(x, ACPI)\n#define __init_or_acpilib\n#define __initdata_or_acpilib\n#else\n#define EXPORT_SYMBOL_ACPI_LIB(x)\n#define __init_or_acpilib __init\n#define __initdata_or_acpilib __initdata\n#endif\n\nint acpi_table_parse(char *id, acpi_tbl_table_handler handler);\nint __init_or_acpilib acpi_table_parse_entries(char *id,\n\t\tunsigned long table_size, int entry_id,\n\t\tacpi_tbl_entry_handler handler, unsigned int max_entries);\nint __init_or_acpilib acpi_table_parse_entries_array(char *id,\n\t\tunsigned long table_size, struct acpi_subtable_proc *proc,\n\t\tint proc_num, unsigned int max_entries);\nint acpi_table_parse_madt(enum acpi_madt_type id,\n\t\t\t  acpi_tbl_entry_handler handler,\n\t\t\t  unsigned int max_entries);\nint __init_or_acpilib\nacpi_table_parse_cedt(enum acpi_cedt_type id,\n\t\t      acpi_tbl_entry_handler_arg handler_arg, void *arg);\n\nint acpi_parse_mcfg (struct acpi_table_header *header);\nvoid acpi_table_print_madt_entry (struct acpi_subtable_header *madt);\n\n \nvoid acpi_numa_slit_init (struct acpi_table_slit *slit);\n\n#if defined(CONFIG_X86) || defined(CONFIG_IA64) || defined(CONFIG_LOONGARCH)\nvoid acpi_numa_processor_affinity_init (struct acpi_srat_cpu_affinity *pa);\n#else\nstatic inline void\nacpi_numa_processor_affinity_init(struct acpi_srat_cpu_affinity *pa) { }\n#endif\n\nvoid acpi_numa_x2apic_affinity_init(struct acpi_srat_x2apic_cpu_affinity *pa);\n\n#if defined(CONFIG_ARM64) || defined(CONFIG_LOONGARCH)\nvoid acpi_arch_dma_setup(struct device *dev);\n#else\nstatic inline void acpi_arch_dma_setup(struct device *dev) { }\n#endif\n\n#ifdef CONFIG_ARM64\nvoid acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa);\n#else\nstatic inline void\nacpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa) { }\n#endif\n\nint acpi_numa_memory_affinity_init (struct acpi_srat_mem_affinity *ma);\n\n#ifndef PHYS_CPUID_INVALID\ntypedef u32 phys_cpuid_t;\n#define PHYS_CPUID_INVALID (phys_cpuid_t)(-1)\n#endif\n\nstatic inline bool invalid_logical_cpuid(u32 cpuid)\n{\n\treturn (int)cpuid < 0;\n}\n\nstatic inline bool invalid_phys_cpuid(phys_cpuid_t phys_id)\n{\n\treturn phys_id == PHYS_CPUID_INVALID;\n}\n\n \nbool acpi_duplicate_processor_id(int proc_id);\n \nstruct acpi_processor_power;\n\n#ifdef CONFIG_ACPI_PROCESSOR_CSTATE\nbool acpi_processor_claim_cst_control(void);\nint acpi_processor_evaluate_cst(acpi_handle handle, u32 cpu,\n\t\t\t\tstruct acpi_processor_power *info);\n#else\nstatic inline bool acpi_processor_claim_cst_control(void) { return false; }\nstatic inline int acpi_processor_evaluate_cst(acpi_handle handle, u32 cpu,\n\t\t\t\t\t      struct acpi_processor_power *info)\n{\n\treturn -ENODEV;\n}\n#endif\n\n#ifdef CONFIG_ACPI_HOTPLUG_CPU\n \nint acpi_map_cpu(acpi_handle handle, phys_cpuid_t physid, u32 acpi_id,\n\t\t int *pcpu);\nint acpi_unmap_cpu(int cpu);\n#endif  \n\n#ifdef CONFIG_ACPI_HOTPLUG_IOAPIC\nint acpi_get_ioapic_id(acpi_handle handle, u32 gsi_base, u64 *phys_addr);\n#endif\n\nint acpi_register_ioapic(acpi_handle handle, u64 phys_addr, u32 gsi_base);\nint acpi_unregister_ioapic(acpi_handle handle, u32 gsi_base);\nint acpi_ioapic_registered(acpi_handle handle, u32 gsi_base);\nvoid acpi_irq_stats_init(void);\nextern u32 acpi_irq_handled;\nextern u32 acpi_irq_not_handled;\nextern unsigned int acpi_sci_irq;\nextern bool acpi_no_s5;\n#define INVALID_ACPI_IRQ\t((unsigned)-1)\nstatic inline bool acpi_sci_irq_valid(void)\n{\n\treturn acpi_sci_irq != INVALID_ACPI_IRQ;\n}\n\nextern int sbf_port;\nextern unsigned long acpi_realmode_flags;\n\nint acpi_register_gsi (struct device *dev, u32 gsi, int triggering, int polarity);\nint acpi_gsi_to_irq (u32 gsi, unsigned int *irq);\nint acpi_isa_irq_to_gsi (unsigned isa_irq, u32 *gsi);\n\nvoid acpi_set_irq_model(enum acpi_irq_model_id model,\n\t\t\tstruct fwnode_handle *(*)(u32));\nvoid acpi_set_gsi_to_irq_fallback(u32 (*)(u32));\n\nstruct irq_domain *acpi_irq_create_hierarchy(unsigned int flags,\n\t\t\t\t\t     unsigned int size,\n\t\t\t\t\t     struct fwnode_handle *fwnode,\n\t\t\t\t\t     const struct irq_domain_ops *ops,\n\t\t\t\t\t     void *host_data);\n\n#ifdef CONFIG_X86_IO_APIC\nextern int acpi_get_override_irq(u32 gsi, int *trigger, int *polarity);\n#else\nstatic inline int acpi_get_override_irq(u32 gsi, int *trigger, int *polarity)\n{\n\treturn -1;\n}\n#endif\n \nvoid acpi_unregister_gsi (u32 gsi);\n\nstruct pci_dev;\n\nint acpi_pci_irq_enable (struct pci_dev *dev);\nvoid acpi_penalize_isa_irq(int irq, int active);\nbool acpi_isa_irq_available(int irq);\n#ifdef CONFIG_PCI\nvoid acpi_penalize_sci_irq(int irq, int trigger, int polarity);\n#else\nstatic inline void acpi_penalize_sci_irq(int irq, int trigger,\n\t\t\t\t\tint polarity)\n{\n}\n#endif\nvoid acpi_pci_irq_disable (struct pci_dev *dev);\n\nextern int ec_read(u8 addr, u8 *val);\nextern int ec_write(u8 addr, u8 val);\nextern int ec_transaction(u8 command,\n                          const u8 *wdata, unsigned wdata_len,\n                          u8 *rdata, unsigned rdata_len);\nextern acpi_handle ec_get_handle(void);\n\nextern bool acpi_is_pnp_device(struct acpi_device *);\n\n#if defined(CONFIG_ACPI_WMI) || defined(CONFIG_ACPI_WMI_MODULE)\n\ntypedef void (*wmi_notify_handler) (u32 value, void *context);\n\nint wmi_instance_count(const char *guid);\n\nextern acpi_status wmi_evaluate_method(const char *guid, u8 instance,\n\t\t\t\t\tu32 method_id,\n\t\t\t\t\tconst struct acpi_buffer *in,\n\t\t\t\t\tstruct acpi_buffer *out);\nextern acpi_status wmi_query_block(const char *guid, u8 instance,\n\t\t\t\t\tstruct acpi_buffer *out);\nextern acpi_status wmi_set_block(const char *guid, u8 instance,\n\t\t\t\t\tconst struct acpi_buffer *in);\nextern acpi_status wmi_install_notify_handler(const char *guid,\n\t\t\t\t\twmi_notify_handler handler, void *data);\nextern acpi_status wmi_remove_notify_handler(const char *guid);\nextern acpi_status wmi_get_event_data(u32 event, struct acpi_buffer *out);\nextern bool wmi_has_guid(const char *guid);\nextern char *wmi_get_acpi_device_uid(const char *guid);\n\n#endif\t \n\n#define ACPI_VIDEO_OUTPUT_SWITCHING\t\t\t0x0001\n#define ACPI_VIDEO_DEVICE_POSTING\t\t\t0x0002\n#define ACPI_VIDEO_ROM_AVAILABLE\t\t\t0x0004\n#define ACPI_VIDEO_BACKLIGHT\t\t\t\t0x0008\n#define ACPI_VIDEO_BACKLIGHT_FORCE_VENDOR\t\t0x0010\n#define ACPI_VIDEO_BACKLIGHT_FORCE_VIDEO\t\t0x0020\n#define ACPI_VIDEO_OUTPUT_SWITCHING_FORCE_VENDOR\t0x0040\n#define ACPI_VIDEO_OUTPUT_SWITCHING_FORCE_VIDEO\t\t0x0080\n#define ACPI_VIDEO_BACKLIGHT_DMI_VENDOR\t\t\t0x0100\n#define ACPI_VIDEO_BACKLIGHT_DMI_VIDEO\t\t\t0x0200\n#define ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VENDOR\t\t0x0400\n#define ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VIDEO\t\t0x0800\n\nextern char acpi_video_backlight_string[];\nextern long acpi_is_video_device(acpi_handle handle);\nextern int acpi_blacklisted(void);\nextern void acpi_osi_setup(char *str);\nextern bool acpi_osi_is_win8(void);\n\n#ifdef CONFIG_ACPI_NUMA\nint acpi_map_pxm_to_node(int pxm);\nint acpi_get_node(acpi_handle handle);\n\n \nstatic inline int pxm_to_online_node(int pxm)\n{\n\tint node = pxm_to_node(pxm);\n\n\treturn numa_map_to_online_node(node);\n}\n#else\nstatic inline int pxm_to_online_node(int pxm)\n{\n\treturn 0;\n}\nstatic inline int acpi_map_pxm_to_node(int pxm)\n{\n\treturn 0;\n}\nstatic inline int acpi_get_node(acpi_handle handle)\n{\n\treturn 0;\n}\n#endif\nextern int pnpacpi_disabled;\n\n#define PXM_INVAL\t(-1)\n\nbool acpi_dev_resource_memory(struct acpi_resource *ares, struct resource *res);\nbool acpi_dev_resource_io(struct acpi_resource *ares, struct resource *res);\nbool acpi_dev_resource_address_space(struct acpi_resource *ares,\n\t\t\t\t     struct resource_win *win);\nbool acpi_dev_resource_ext_address_space(struct acpi_resource *ares,\n\t\t\t\t\t struct resource_win *win);\nunsigned long acpi_dev_irq_flags(u8 triggering, u8 polarity, u8 shareable, u8 wake_capable);\nunsigned int acpi_dev_get_irq_type(int triggering, int polarity);\nbool acpi_dev_resource_interrupt(struct acpi_resource *ares, int index,\n\t\t\t\t struct resource *res);\n\nvoid acpi_dev_free_resource_list(struct list_head *list);\nint acpi_dev_get_resources(struct acpi_device *adev, struct list_head *list,\n\t\t\t   int (*preproc)(struct acpi_resource *, void *),\n\t\t\t   void *preproc_data);\nint acpi_dev_get_dma_resources(struct acpi_device *adev,\n\t\t\t       struct list_head *list);\nint acpi_dev_get_memory_resources(struct acpi_device *adev, struct list_head *list);\nint acpi_dev_filter_resource_type(struct acpi_resource *ares,\n\t\t\t\t  unsigned long types);\n\nstatic inline int acpi_dev_filter_resource_type_cb(struct acpi_resource *ares,\n\t\t\t\t\t\t   void *arg)\n{\n\treturn acpi_dev_filter_resource_type(ares, (unsigned long)arg);\n}\n\nstruct acpi_device *acpi_resource_consumer(struct resource *res);\n\nint acpi_check_resource_conflict(const struct resource *res);\n\nint acpi_check_region(resource_size_t start, resource_size_t n,\n\t\t      const char *name);\n\nint acpi_resources_are_enforced(void);\n\n#ifdef CONFIG_HIBERNATION\nextern int acpi_check_s4_hw_signature;\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nvoid __init acpi_old_suspend_ordering(void);\nvoid __init acpi_nvs_nosave(void);\nvoid __init acpi_nvs_nosave_s3(void);\nvoid __init acpi_sleep_no_blacklist(void);\n#endif  \n\nint acpi_register_wakeup_handler(\n\tint wake_irq, bool (*wakeup)(void *context), void *context);\nvoid acpi_unregister_wakeup_handler(\n\tbool (*wakeup)(void *context), void *context);\n\nstruct acpi_osc_context {\n\tchar *uuid_str;\t\t\t \n\tint rev;\n\tstruct acpi_buffer cap;\t\t \n\tstruct acpi_buffer ret;\t\t \n};\n\nacpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context);\n\n \n#define OSC_PCI_CAPABILITY_DWORDS\t\t3\n#define OSC_CXL_CAPABILITY_DWORDS\t\t5\n\n \n#define OSC_QUERY_DWORD\t\t\t\t0\t \n#define OSC_SUPPORT_DWORD\t\t\t1\t \n#define OSC_CONTROL_DWORD\t\t\t2\t \n#define OSC_EXT_SUPPORT_DWORD\t\t\t3\t \n#define OSC_EXT_CONTROL_DWORD\t\t\t4\t \n\n \n#define OSC_QUERY_ENABLE\t\t\t0x00000001   \n#define OSC_REQUEST_ERROR\t\t\t0x00000002   \n#define OSC_INVALID_UUID_ERROR\t\t\t0x00000004   \n#define OSC_INVALID_REVISION_ERROR\t\t0x00000008   \n#define OSC_CAPABILITIES_MASK_ERROR\t\t0x00000010   \n\n \n#define OSC_SB_PAD_SUPPORT\t\t\t0x00000001\n#define OSC_SB_PPC_OST_SUPPORT\t\t\t0x00000002\n#define OSC_SB_PR3_SUPPORT\t\t\t0x00000004\n#define OSC_SB_HOTPLUG_OST_SUPPORT\t\t0x00000008\n#define OSC_SB_APEI_SUPPORT\t\t\t0x00000010\n#define OSC_SB_CPC_SUPPORT\t\t\t0x00000020\n#define OSC_SB_CPCV2_SUPPORT\t\t\t0x00000040\n#define OSC_SB_PCLPI_SUPPORT\t\t\t0x00000080\n#define OSC_SB_OSLPI_SUPPORT\t\t\t0x00000100\n#define OSC_SB_CPC_DIVERSE_HIGH_SUPPORT\t\t0x00001000\n#define OSC_SB_GENERIC_INITIATOR_SUPPORT\t0x00002000\n#define OSC_SB_CPC_FLEXIBLE_ADR_SPACE\t\t0x00004000\n#define OSC_SB_NATIVE_USB4_SUPPORT\t\t0x00040000\n#define OSC_SB_PRM_SUPPORT\t\t\t0x00200000\n#define OSC_SB_FFH_OPR_SUPPORT\t\t\t0x00400000\n\nextern bool osc_sb_apei_support_acked;\nextern bool osc_pc_lpi_support_confirmed;\nextern bool osc_sb_native_usb4_support_confirmed;\nextern bool osc_sb_cppc2_support_acked;\nextern bool osc_cpc_flexible_adr_space_confirmed;\n\n \n#define OSC_USB_USB3_TUNNELING\t\t\t0x00000001\n#define OSC_USB_DP_TUNNELING\t\t\t0x00000002\n#define OSC_USB_PCIE_TUNNELING\t\t\t0x00000004\n#define OSC_USB_XDOMAIN\t\t\t\t0x00000008\n\nextern u32 osc_sb_native_usb4_control;\n\n \n#define OSC_PCI_EXT_CONFIG_SUPPORT\t\t0x00000001\n#define OSC_PCI_ASPM_SUPPORT\t\t\t0x00000002\n#define OSC_PCI_CLOCK_PM_SUPPORT\t\t0x00000004\n#define OSC_PCI_SEGMENT_GROUPS_SUPPORT\t\t0x00000008\n#define OSC_PCI_MSI_SUPPORT\t\t\t0x00000010\n#define OSC_PCI_EDR_SUPPORT\t\t\t0x00000080\n#define OSC_PCI_HPX_TYPE_3_SUPPORT\t\t0x00000100\n\n \n#define OSC_PCI_EXPRESS_NATIVE_HP_CONTROL\t0x00000001\n#define OSC_PCI_SHPC_NATIVE_HP_CONTROL\t\t0x00000002\n#define OSC_PCI_EXPRESS_PME_CONTROL\t\t0x00000004\n#define OSC_PCI_EXPRESS_AER_CONTROL\t\t0x00000008\n#define OSC_PCI_EXPRESS_CAPABILITY_CONTROL\t0x00000010\n#define OSC_PCI_EXPRESS_LTR_CONTROL\t\t0x00000020\n#define OSC_PCI_EXPRESS_DPC_CONTROL\t\t0x00000080\n\n \n#define OSC_CXL_1_1_PORT_REG_ACCESS_SUPPORT\t0x00000001\n#define OSC_CXL_2_0_PORT_DEV_REG_ACCESS_SUPPORT\t0x00000002\n#define OSC_CXL_PROTOCOL_ERR_REPORTING_SUPPORT\t0x00000004\n#define OSC_CXL_NATIVE_HP_SUPPORT\t\t0x00000008\n\n \n#define OSC_CXL_ERROR_REPORTING_CONTROL\t\t0x00000001\n\nstatic inline u32 acpi_osc_ctx_get_pci_control(struct acpi_osc_context *context)\n{\n\tu32 *ret = context->ret.pointer;\n\n\treturn ret[OSC_CONTROL_DWORD];\n}\n\nstatic inline u32 acpi_osc_ctx_get_cxl_control(struct acpi_osc_context *context)\n{\n\tu32 *ret = context->ret.pointer;\n\n\treturn ret[OSC_EXT_CONTROL_DWORD];\n}\n\n#define ACPI_GSB_ACCESS_ATTRIB_QUICK\t\t0x00000002\n#define ACPI_GSB_ACCESS_ATTRIB_SEND_RCV         0x00000004\n#define ACPI_GSB_ACCESS_ATTRIB_BYTE\t\t0x00000006\n#define ACPI_GSB_ACCESS_ATTRIB_WORD\t\t0x00000008\n#define ACPI_GSB_ACCESS_ATTRIB_BLOCK\t\t0x0000000A\n#define ACPI_GSB_ACCESS_ATTRIB_MULTIBYTE\t0x0000000B\n#define ACPI_GSB_ACCESS_ATTRIB_WORD_CALL\t0x0000000C\n#define ACPI_GSB_ACCESS_ATTRIB_BLOCK_CALL\t0x0000000D\n#define ACPI_GSB_ACCESS_ATTRIB_RAW_BYTES\t0x0000000E\n#define ACPI_GSB_ACCESS_ATTRIB_RAW_PROCESS\t0x0000000F\n\n \n#if defined(CONFIG_ACPI_HOTPLUG_CPU) &&\t\t\t\\\n\tdefined(CONFIG_ACPI_HOTPLUG_MEMORY) &&\t\t\\\n\tdefined(CONFIG_ACPI_CONTAINER)\n#define ACPI_HOTPLUG_OST\n#endif\n\n \n#define ACPI_OST_EC_OSPM_SHUTDOWN\t\t0x100\n#define ACPI_OST_EC_OSPM_EJECT\t\t\t0x103\n#define ACPI_OST_EC_OSPM_INSERTION\t\t0x200\n\n \n#define ACPI_OST_SC_SUCCESS\t\t\t0x0\n#define ACPI_OST_SC_NON_SPECIFIC_FAILURE\t0x1\n#define ACPI_OST_SC_UNRECOGNIZED_NOTIFY\t\t0x2\n\n \n#define ACPI_OST_SC_OS_SHUTDOWN_DENIED\t\t0x80\n#define ACPI_OST_SC_OS_SHUTDOWN_IN_PROGRESS\t0x81\n#define ACPI_OST_SC_OS_SHUTDOWN_COMPLETED\t0x82\n#define ACPI_OST_SC_OS_SHUTDOWN_NOT_SUPPORTED\t0x83\n\n \n#define ACPI_OST_SC_EJECT_NOT_SUPPORTED\t\t0x80\n#define ACPI_OST_SC_DEVICE_IN_USE\t\t0x81\n#define ACPI_OST_SC_DEVICE_BUSY\t\t\t0x82\n#define ACPI_OST_SC_EJECT_DEPENDENCY_BUSY\t0x83\n#define ACPI_OST_SC_EJECT_IN_PROGRESS\t\t0x84\n\n \n#define ACPI_OST_SC_INSERT_IN_PROGRESS\t\t0x80\n#define ACPI_OST_SC_DRIVER_LOAD_FAILURE\t\t0x81\n#define ACPI_OST_SC_INSERT_NOT_SUPPORTED\t0x82\n\nenum acpi_predicate {\n\tall_versions,\n\tless_than_or_equal,\n\tequal,\n\tgreater_than_or_equal,\n};\n\n \nstruct acpi_platform_list {\n\tchar\toem_id[ACPI_OEM_ID_SIZE+1];\n\tchar\toem_table_id[ACPI_OEM_TABLE_ID_SIZE+1];\n\tu32\toem_revision;\n\tchar\t*table;\n\tenum acpi_predicate pred;\n\tchar\t*reason;\n\tu32\tdata;\n};\nint acpi_match_platform_list(const struct acpi_platform_list *plat);\n\nextern void acpi_early_init(void);\nextern void acpi_subsystem_init(void);\n\nextern int acpi_nvs_register(__u64 start, __u64 size);\n\nextern int acpi_nvs_for_each_region(int (*func)(__u64, __u64, void *),\n\t\t\t\t    void *data);\n\nconst struct acpi_device_id *acpi_match_acpi_device(const struct acpi_device_id *ids,\n\t\t\t\t\t\t    const struct acpi_device *adev);\n\nconst struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,\n\t\t\t\t\t       const struct device *dev);\n\nconst void *acpi_device_get_match_data(const struct device *dev);\nextern bool acpi_driver_match_device(struct device *dev,\n\t\t\t\t     const struct device_driver *drv);\nint acpi_device_uevent_modalias(const struct device *, struct kobj_uevent_env *);\nint acpi_device_modalias(struct device *, char *, int);\n\nstruct platform_device *acpi_create_platform_device(struct acpi_device *,\n\t\t\t\t\t\t    const struct property_entry *);\n#define ACPI_PTR(_ptr)\t(_ptr)\n\nstatic inline void acpi_device_set_enumerated(struct acpi_device *adev)\n{\n\tadev->flags.visited = true;\n}\n\nstatic inline void acpi_device_clear_enumerated(struct acpi_device *adev)\n{\n\tadev->flags.visited = false;\n}\n\nenum acpi_reconfig_event  {\n\tACPI_RECONFIG_DEVICE_ADD = 0,\n\tACPI_RECONFIG_DEVICE_REMOVE,\n};\n\nint acpi_reconfig_notifier_register(struct notifier_block *nb);\nint acpi_reconfig_notifier_unregister(struct notifier_block *nb);\n\n#ifdef CONFIG_ACPI_GTDT\nint acpi_gtdt_init(struct acpi_table_header *table, int *platform_timer_count);\nint acpi_gtdt_map_ppi(int type);\nbool acpi_gtdt_c3stop(int type);\nint acpi_arch_timer_mem_init(struct arch_timer_mem *timer_mem, int *timer_count);\n#endif\n\n#ifndef ACPI_HAVE_ARCH_SET_ROOT_POINTER\nstatic inline void acpi_arch_set_root_pointer(u64 addr)\n{\n}\n#endif\n\n#ifndef ACPI_HAVE_ARCH_GET_ROOT_POINTER\nstatic inline u64 acpi_arch_get_root_pointer(void)\n{\n\treturn 0;\n}\n#endif\n\nint acpi_get_local_address(acpi_handle handle, u32 *addr);\nconst char *acpi_get_subsystem_id(acpi_handle handle);\n\n#else\t \n\n#define acpi_disabled 1\n\n#define ACPI_COMPANION(dev)\t\t(NULL)\n#define ACPI_COMPANION_SET(dev, adev)\tdo { } while (0)\n#define ACPI_HANDLE(dev)\t\t(NULL)\n#define ACPI_HANDLE_FWNODE(fwnode)\t(NULL)\n\n#include <acpi/acpi_numa.h>\n\nstruct fwnode_handle;\n\nstatic inline bool acpi_dev_found(const char *hid)\n{\n\treturn false;\n}\n\nstatic inline bool acpi_dev_present(const char *hid, const char *uid, s64 hrv)\n{\n\treturn false;\n}\n\nstruct acpi_device;\n\nstatic inline bool\nacpi_dev_hid_uid_match(struct acpi_device *adev, const char *hid2, const char *uid2)\n{\n\treturn false;\n}\n\nstatic inline int acpi_dev_uid_to_integer(struct acpi_device *adev, u64 *integer)\n{\n\treturn -ENODEV;\n}\n\nstatic inline struct acpi_device *\nacpi_dev_get_first_match_dev(const char *hid, const char *uid, s64 hrv)\n{\n\treturn NULL;\n}\n\nstatic inline bool acpi_reduced_hardware(void)\n{\n\treturn false;\n}\n\nstatic inline void acpi_dev_put(struct acpi_device *adev) {}\n\nstatic inline bool is_acpi_node(const struct fwnode_handle *fwnode)\n{\n\treturn false;\n}\n\nstatic inline bool is_acpi_device_node(const struct fwnode_handle *fwnode)\n{\n\treturn false;\n}\n\nstatic inline struct acpi_device *to_acpi_device_node(const struct fwnode_handle *fwnode)\n{\n\treturn NULL;\n}\n\nstatic inline bool is_acpi_data_node(const struct fwnode_handle *fwnode)\n{\n\treturn false;\n}\n\nstatic inline struct acpi_data_node *to_acpi_data_node(const struct fwnode_handle *fwnode)\n{\n\treturn NULL;\n}\n\nstatic inline bool acpi_data_node_match(const struct fwnode_handle *fwnode,\n\t\t\t\t\tconst char *name)\n{\n\treturn false;\n}\n\nstatic inline struct fwnode_handle *acpi_fwnode_handle(struct acpi_device *adev)\n{\n\treturn NULL;\n}\n\nstatic inline bool has_acpi_companion(struct device *dev)\n{\n\treturn false;\n}\n\nstatic inline void acpi_preset_companion(struct device *dev,\n\t\t\t\t\t struct acpi_device *parent, u64 addr)\n{\n}\n\nstatic inline const char *acpi_dev_name(struct acpi_device *adev)\n{\n\treturn NULL;\n}\n\nstatic inline struct device *acpi_get_first_physical_node(struct acpi_device *adev)\n{\n\treturn NULL;\n}\n\nstatic inline void acpi_early_init(void) { }\nstatic inline void acpi_subsystem_init(void) { }\n\nstatic inline int early_acpi_boot_init(void)\n{\n\treturn 0;\n}\nstatic inline int acpi_boot_init(void)\n{\n\treturn 0;\n}\n\nstatic inline void acpi_boot_table_prepare(void)\n{\n}\n\nstatic inline void acpi_boot_table_init(void)\n{\n}\n\nstatic inline int acpi_mps_check(void)\n{\n\treturn 0;\n}\n\nstatic inline int acpi_check_resource_conflict(struct resource *res)\n{\n\treturn 0;\n}\n\nstatic inline int acpi_check_region(resource_size_t start, resource_size_t n,\n\t\t\t\t    const char *name)\n{\n\treturn 0;\n}\n\nstruct acpi_table_header;\nstatic inline int acpi_table_parse(char *id,\n\t\t\t\tint (*handler)(struct acpi_table_header *))\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_nvs_register(__u64 start, __u64 size)\n{\n\treturn 0;\n}\n\nstatic inline int acpi_nvs_for_each_region(int (*func)(__u64, __u64, void *),\n\t\t\t\t\t   void *data)\n{\n\treturn 0;\n}\n\nstruct acpi_device_id;\n\nstatic inline const struct acpi_device_id *acpi_match_acpi_device(\n\tconst struct acpi_device_id *ids, const struct acpi_device *adev)\n{\n\treturn NULL;\n}\n\nstatic inline const struct acpi_device_id *acpi_match_device(\n\tconst struct acpi_device_id *ids, const struct device *dev)\n{\n\treturn NULL;\n}\n\nstatic inline const void *acpi_device_get_match_data(const struct device *dev)\n{\n\treturn NULL;\n}\n\nstatic inline bool acpi_driver_match_device(struct device *dev,\n\t\t\t\t\t    const struct device_driver *drv)\n{\n\treturn false;\n}\n\nstatic inline bool acpi_check_dsm(acpi_handle handle, const guid_t *guid,\n\t\t\t\t  u64 rev, u64 funcs)\n{\n\treturn false;\n}\n\nstatic inline union acpi_object *acpi_evaluate_dsm(acpi_handle handle,\n\t\t\t\t\t\t   const guid_t *guid,\n\t\t\t\t\t\t   u64 rev, u64 func,\n\t\t\t\t\t\t   union acpi_object *argv4)\n{\n\treturn NULL;\n}\n\nstatic inline union acpi_object *acpi_evaluate_dsm_typed(acpi_handle handle,\n\t\t\t\t\t\t\t const guid_t *guid,\n\t\t\t\t\t\t\t u64 rev, u64 func,\n\t\t\t\t\t\t\t union acpi_object *argv4,\n\t\t\t\t\t\t\t acpi_object_type type)\n{\n\treturn NULL;\n}\n\nstatic inline int acpi_device_uevent_modalias(const struct device *dev,\n\t\t\t\tstruct kobj_uevent_env *env)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_device_modalias(struct device *dev,\n\t\t\t\tchar *buf, int size)\n{\n\treturn -ENODEV;\n}\n\nstatic inline struct platform_device *\nacpi_create_platform_device(struct acpi_device *adev,\n\t\t\t    const struct property_entry *properties)\n{\n\treturn NULL;\n}\n\nstatic inline bool acpi_dma_supported(const struct acpi_device *adev)\n{\n\treturn false;\n}\n\nstatic inline enum dev_dma_attr acpi_get_dma_attr(struct acpi_device *adev)\n{\n\treturn DEV_DMA_NOT_SUPPORTED;\n}\n\nstatic inline int acpi_dma_get_range(struct device *dev, const struct bus_dma_region **map)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_dma_configure(struct device *dev,\n\t\t\t\t     enum dev_dma_attr attr)\n{\n\treturn 0;\n}\n\nstatic inline int acpi_dma_configure_id(struct device *dev,\n\t\t\t\t\tenum dev_dma_attr attr,\n\t\t\t\t\tconst u32 *input_id)\n{\n\treturn 0;\n}\n\n#define ACPI_PTR(_ptr)\t(NULL)\n\nstatic inline void acpi_device_set_enumerated(struct acpi_device *adev)\n{\n}\n\nstatic inline void acpi_device_clear_enumerated(struct acpi_device *adev)\n{\n}\n\nstatic inline int acpi_reconfig_notifier_register(struct notifier_block *nb)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int acpi_reconfig_notifier_unregister(struct notifier_block *nb)\n{\n\treturn -EINVAL;\n}\n\nstatic inline struct acpi_device *acpi_resource_consumer(struct resource *res)\n{\n\treturn NULL;\n}\n\nstatic inline int acpi_get_local_address(acpi_handle handle, u32 *addr)\n{\n\treturn -ENODEV;\n}\n\nstatic inline const char *acpi_get_subsystem_id(acpi_handle handle)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic inline int acpi_register_wakeup_handler(int wake_irq,\n\tbool (*wakeup)(void *context), void *context)\n{\n\treturn -ENXIO;\n}\n\nstatic inline void acpi_unregister_wakeup_handler(\n\tbool (*wakeup)(void *context), void *context) { }\n\nstruct acpi_osc_context;\nstatic inline u32 acpi_osc_ctx_get_pci_control(struct acpi_osc_context *context)\n{\n\treturn 0;\n}\n\nstatic inline u32 acpi_osc_ctx_get_cxl_control(struct acpi_osc_context *context)\n{\n\treturn 0;\n}\n\nstatic inline bool acpi_sleep_state_supported(u8 sleep_state)\n{\n\treturn false;\n}\n\n#endif\t \n\nextern void arch_post_acpi_subsys_init(void);\n\n#ifdef CONFIG_ACPI_HOTPLUG_IOAPIC\nint acpi_ioapic_add(acpi_handle root);\n#else\nstatic inline int acpi_ioapic_add(acpi_handle root) { return 0; }\n#endif\n\n#ifdef CONFIG_ACPI\nvoid acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,\n\t\t\t       u32 pm1a_ctrl,  u32 pm1b_ctrl));\n\nacpi_status acpi_os_prepare_sleep(u8 sleep_state,\n\t\t\t\t  u32 pm1a_control, u32 pm1b_control);\n\nvoid acpi_os_set_prepare_extended_sleep(int (*func)(u8 sleep_state,\n\t\t\t\t        u32 val_a,  u32 val_b));\n\nacpi_status acpi_os_prepare_extended_sleep(u8 sleep_state,\n\t\t\t\t\t   u32 val_a, u32 val_b);\n#if defined(CONFIG_SUSPEND) && defined(CONFIG_X86)\nstruct acpi_s2idle_dev_ops {\n\tstruct list_head list_node;\n\tvoid (*prepare)(void);\n\tvoid (*check)(void);\n\tvoid (*restore)(void);\n};\nint acpi_register_lps0_dev(struct acpi_s2idle_dev_ops *arg);\nvoid acpi_unregister_lps0_dev(struct acpi_s2idle_dev_ops *arg);\nint acpi_get_lps0_constraint(struct acpi_device *adev);\n#else  \nstatic inline int acpi_get_lps0_constraint(struct device *dev)\n{\n\treturn ACPI_STATE_UNKNOWN;\n}\n#endif  \n#ifndef CONFIG_IA64\nvoid arch_reserve_mem_area(acpi_physical_address addr, size_t size);\n#else\nstatic inline void arch_reserve_mem_area(acpi_physical_address addr,\n\t\t\t\t\t  size_t size)\n{\n}\n#endif  \n#else\n#define acpi_os_set_prepare_sleep(func, pm1a_ctrl, pm1b_ctrl) do { } while (0)\n#endif\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_PM)\nint acpi_dev_suspend(struct device *dev, bool wakeup);\nint acpi_dev_resume(struct device *dev);\nint acpi_subsys_runtime_suspend(struct device *dev);\nint acpi_subsys_runtime_resume(struct device *dev);\nint acpi_dev_pm_attach(struct device *dev, bool power_on);\nbool acpi_storage_d3(struct device *dev);\nbool acpi_dev_state_d0(struct device *dev);\n#else\nstatic inline int acpi_subsys_runtime_suspend(struct device *dev) { return 0; }\nstatic inline int acpi_subsys_runtime_resume(struct device *dev) { return 0; }\nstatic inline int acpi_dev_pm_attach(struct device *dev, bool power_on)\n{\n\treturn 0;\n}\nstatic inline bool acpi_storage_d3(struct device *dev)\n{\n\treturn false;\n}\nstatic inline bool acpi_dev_state_d0(struct device *dev)\n{\n\treturn true;\n}\n#endif\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_PM_SLEEP)\nint acpi_subsys_prepare(struct device *dev);\nvoid acpi_subsys_complete(struct device *dev);\nint acpi_subsys_suspend_late(struct device *dev);\nint acpi_subsys_suspend_noirq(struct device *dev);\nint acpi_subsys_suspend(struct device *dev);\nint acpi_subsys_freeze(struct device *dev);\nint acpi_subsys_poweroff(struct device *dev);\nvoid acpi_ec_mark_gpe_for_wake(void);\nvoid acpi_ec_set_gpe_wake_mask(u8 action);\nint acpi_subsys_restore_early(struct device *dev);\n#else\nstatic inline int acpi_subsys_prepare(struct device *dev) { return 0; }\nstatic inline void acpi_subsys_complete(struct device *dev) {}\nstatic inline int acpi_subsys_suspend_late(struct device *dev) { return 0; }\nstatic inline int acpi_subsys_suspend_noirq(struct device *dev) { return 0; }\nstatic inline int acpi_subsys_suspend(struct device *dev) { return 0; }\nstatic inline int acpi_subsys_freeze(struct device *dev) { return 0; }\nstatic inline int acpi_subsys_poweroff(struct device *dev) { return 0; }\nstatic inline int acpi_subsys_restore_early(struct device *dev) { return 0; }\nstatic inline void acpi_ec_mark_gpe_for_wake(void) {}\nstatic inline void acpi_ec_set_gpe_wake_mask(u8 action) {}\n#endif\n\n#ifdef CONFIG_ACPI\n__printf(3, 4)\nvoid acpi_handle_printk(const char *level, acpi_handle handle,\n\t\t\tconst char *fmt, ...);\nvoid acpi_evaluation_failure_warn(acpi_handle handle, const char *name,\n\t\t\t\t  acpi_status status);\n#else\t \nstatic inline __printf(3, 4) void\nacpi_handle_printk(const char *level, void *handle, const char *fmt, ...) {}\nstatic inline void acpi_evaluation_failure_warn(acpi_handle handle,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tacpi_status status) {}\n#endif\t \n\n#if defined(CONFIG_ACPI) && defined(CONFIG_DYNAMIC_DEBUG)\n__printf(3, 4)\nvoid __acpi_handle_debug(struct _ddebug *descriptor, acpi_handle handle, const char *fmt, ...);\n#endif\n\n \n#define acpi_handle_emerg(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_EMERG, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_alert(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_ALERT, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_crit(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_CRIT, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_err(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_ERR, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_warn(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_WARNING, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_notice(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_NOTICE, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_info(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_INFO, handle, fmt, ##__VA_ARGS__)\n\n#if defined(DEBUG)\n#define acpi_handle_debug(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_DEBUG, handle, fmt, ##__VA_ARGS__)\n#else\n#if defined(CONFIG_DYNAMIC_DEBUG)\n#define acpi_handle_debug(handle, fmt, ...)\t\t\t\t\\\n\t_dynamic_func_call(fmt, __acpi_handle_debug,\t\t\t\\\n\t\t\t   handle, pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define acpi_handle_debug(handle, fmt, ...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\tacpi_handle_printk(KERN_DEBUG, handle, fmt, ##__VA_ARGS__); \\\n\t0;\t\t\t\t\t\t\t\t\\\n})\n#endif\n#endif\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_GPIOLIB)\nbool acpi_gpio_get_irq_resource(struct acpi_resource *ares,\n\t\t\t\tstruct acpi_resource_gpio **agpio);\nbool acpi_gpio_get_io_resource(struct acpi_resource *ares,\n\t\t\t       struct acpi_resource_gpio **agpio);\nint acpi_dev_gpio_irq_wake_get_by(struct acpi_device *adev, const char *name, int index,\n\t\t\t\t  bool *wake_capable);\n#else\nstatic inline bool acpi_gpio_get_irq_resource(struct acpi_resource *ares,\n\t\t\t\t\t      struct acpi_resource_gpio **agpio)\n{\n\treturn false;\n}\nstatic inline bool acpi_gpio_get_io_resource(struct acpi_resource *ares,\n\t\t\t\t\t     struct acpi_resource_gpio **agpio)\n{\n\treturn false;\n}\nstatic inline int acpi_dev_gpio_irq_wake_get_by(struct acpi_device *adev, const char *name,\n\t\t\t\t\t\tint index, bool *wake_capable)\n{\n\treturn -ENXIO;\n}\n#endif\n\nstatic inline int acpi_dev_gpio_irq_wake_get(struct acpi_device *adev, int index,\n\t\t\t\t\t     bool *wake_capable)\n{\n\treturn acpi_dev_gpio_irq_wake_get_by(adev, NULL, index, wake_capable);\n}\n\nstatic inline int acpi_dev_gpio_irq_get_by(struct acpi_device *adev, const char *name,\n\t\t\t\t\t   int index)\n{\n\treturn acpi_dev_gpio_irq_wake_get_by(adev, name, index, NULL);\n}\n\nstatic inline int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)\n{\n\treturn acpi_dev_gpio_irq_wake_get_by(adev, NULL, index, NULL);\n}\n\n \n\n#ifdef CONFIG_ACPI\nint acpi_dev_get_property(const struct acpi_device *adev, const char *name,\n\t\t\t  acpi_object_type type, const union acpi_object **obj);\nint __acpi_node_get_property_reference(const struct fwnode_handle *fwnode,\n\t\t\t\tconst char *name, size_t index, size_t num_args,\n\t\t\t\tstruct fwnode_reference_args *args);\n\nstatic inline int acpi_node_get_property_reference(\n\t\t\t\tconst struct fwnode_handle *fwnode,\n\t\t\t\tconst char *name, size_t index,\n\t\t\t\tstruct fwnode_reference_args *args)\n{\n\treturn __acpi_node_get_property_reference(fwnode, name, index,\n\t\tNR_FWNODE_REFERENCE_ARGS, args);\n}\n\nstatic inline bool acpi_dev_has_props(const struct acpi_device *adev)\n{\n\treturn !list_empty(&adev->data.properties);\n}\n\nstruct acpi_device_properties *\nacpi_data_add_props(struct acpi_device_data *data, const guid_t *guid,\n\t\t    union acpi_object *properties);\n\nint acpi_node_prop_get(const struct fwnode_handle *fwnode, const char *propname,\n\t\t       void **valptr);\n\nstruct fwnode_handle *acpi_get_next_subnode(const struct fwnode_handle *fwnode,\n\t\t\t\t\t    struct fwnode_handle *child);\n\nstruct acpi_probe_entry;\ntypedef bool (*acpi_probe_entry_validate_subtbl)(struct acpi_subtable_header *,\n\t\t\t\t\t\t struct acpi_probe_entry *);\n\n#define ACPI_TABLE_ID_LEN\t5\n\n \nstruct acpi_probe_entry {\n\t__u8 id[ACPI_TABLE_ID_LEN];\n\t__u8 type;\n\tacpi_probe_entry_validate_subtbl subtable_valid;\n\tunion {\n\t\tacpi_tbl_table_handler probe_table;\n\t\tacpi_tbl_entry_handler probe_subtbl;\n\t};\n\tkernel_ulong_t driver_data;\n};\n\n#define ACPI_DECLARE_PROBE_ENTRY(table, name, table_id, subtable,\t\\\n\t\t\t\t valid, data, fn)\t\t\t\\\n\tstatic const struct acpi_probe_entry __acpi_probe_##name\t\\\n\t\t__used __section(\"__\" #table \"_acpi_probe_table\") = {\t\\\n\t\t\t.id = table_id,\t\t\t\t\t\\\n\t\t\t.type = subtable,\t\t\t\t\\\n\t\t\t.subtable_valid = valid,\t\t\t\\\n\t\t\t.probe_table = fn,\t\t\t\t\\\n\t\t\t.driver_data = data,\t\t\t\t\\\n\t\t}\n\n#define ACPI_DECLARE_SUBTABLE_PROBE_ENTRY(table, name, table_id,\t\\\n\t\t\t\t\t  subtable, valid, data, fn)\t\\\n\tstatic const struct acpi_probe_entry __acpi_probe_##name\t\\\n\t\t__used __section(\"__\" #table \"_acpi_probe_table\") = {\t\\\n\t\t\t.id = table_id,\t\t\t\t\t\\\n\t\t\t.type = subtable,\t\t\t\t\\\n\t\t\t.subtable_valid = valid,\t\t\t\\\n\t\t\t.probe_subtbl = fn,\t\t\t\t\\\n\t\t\t.driver_data = data,\t\t\t\t\\\n\t\t}\n\n#define ACPI_PROBE_TABLE(name)\t\t__##name##_acpi_probe_table\n#define ACPI_PROBE_TABLE_END(name)\t__##name##_acpi_probe_table_end\n\nint __acpi_probe_device_table(struct acpi_probe_entry *start, int nr);\n\n#define acpi_probe_device_table(t)\t\t\t\t\t\\\n\t({ \t\t\t\t\t\t\t\t\\\n\t\textern struct acpi_probe_entry ACPI_PROBE_TABLE(t),\t\\\n\t\t\t                       ACPI_PROBE_TABLE_END(t);\t\\\n\t\t__acpi_probe_device_table(&ACPI_PROBE_TABLE(t),\t\t\\\n\t\t\t\t\t  (&ACPI_PROBE_TABLE_END(t) -\t\\\n\t\t\t\t\t   &ACPI_PROBE_TABLE(t)));\t\\\n\t})\n#else\nstatic inline int acpi_dev_get_property(struct acpi_device *adev,\n\t\t\t\t\tconst char *name, acpi_object_type type,\n\t\t\t\t\tconst union acpi_object **obj)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int\n__acpi_node_get_property_reference(const struct fwnode_handle *fwnode,\n\t\t\t\tconst char *name, size_t index, size_t num_args,\n\t\t\t\tstruct fwnode_reference_args *args)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int\nacpi_node_get_property_reference(const struct fwnode_handle *fwnode,\n\t\t\t\t const char *name, size_t index,\n\t\t\t\t struct fwnode_reference_args *args)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int acpi_node_prop_get(const struct fwnode_handle *fwnode,\n\t\t\t\t     const char *propname,\n\t\t\t\t     void **valptr)\n{\n\treturn -ENXIO;\n}\n\nstatic inline struct fwnode_handle *\nacpi_get_next_subnode(const struct fwnode_handle *fwnode,\n\t\t      struct fwnode_handle *child)\n{\n\treturn NULL;\n}\n\nstatic inline struct fwnode_handle *\nacpi_graph_get_next_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t     struct fwnode_handle *prev)\n{\n\treturn ERR_PTR(-ENXIO);\n}\n\nstatic inline int\nacpi_graph_get_remote_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t       struct fwnode_handle **remote,\n\t\t\t       struct fwnode_handle **port,\n\t\t\t       struct fwnode_handle **endpoint)\n{\n\treturn -ENXIO;\n}\n\n#define ACPI_DECLARE_PROBE_ENTRY(table, name, table_id, subtable, valid, data, fn) \\\n\tstatic const void * __acpi_table_##name[]\t\t\t\\\n\t\t__attribute__((unused))\t\t\t\t\t\\\n\t\t = { (void *) table_id,\t\t\t\t\t\\\n\t\t     (void *) subtable,\t\t\t\t\t\\\n\t\t     (void *) valid,\t\t\t\t\t\\\n\t\t     (void *) fn,\t\t\t\t\t\\\n\t\t     (void *) data }\n\n#define acpi_probe_device_table(t)\t({ int __r = 0; __r;})\n#endif\n\n#ifdef CONFIG_ACPI_TABLE_UPGRADE\nvoid acpi_table_upgrade(void);\n#else\nstatic inline void acpi_table_upgrade(void) { }\n#endif\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_ACPI_WATCHDOG)\nextern bool acpi_has_watchdog(void);\n#else\nstatic inline bool acpi_has_watchdog(void) { return false; }\n#endif\n\n#ifdef CONFIG_ACPI_SPCR_TABLE\nextern bool qdf2400_e44_present;\nint acpi_parse_spcr(bool enable_earlycon, bool enable_console);\n#else\nstatic inline int acpi_parse_spcr(bool enable_earlycon, bool enable_console)\n{\n\treturn 0;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_ACPI_GENERIC_GSI)\nint acpi_irq_get(acpi_handle handle, unsigned int index, struct resource *res);\n#else\nstatic inline\nint acpi_irq_get(acpi_handle handle, unsigned int index, struct resource *res)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#ifdef CONFIG_ACPI_LPIT\nint lpit_read_residency_count_address(u64 *address);\n#else\nstatic inline int lpit_read_residency_count_address(u64 *address)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#ifdef CONFIG_ACPI_PROCESSOR_IDLE\n#ifndef arch_get_idle_state_flags\nstatic inline unsigned int arch_get_idle_state_flags(u32 arch_flags)\n{\n\treturn 0;\n}\n#endif\n#endif  \n\n#ifdef CONFIG_ACPI_PPTT\nint acpi_pptt_cpu_is_thread(unsigned int cpu);\nint find_acpi_cpu_topology(unsigned int cpu, int level);\nint find_acpi_cpu_topology_cluster(unsigned int cpu);\nint find_acpi_cpu_topology_package(unsigned int cpu);\nint find_acpi_cpu_topology_hetero_id(unsigned int cpu);\n#else\nstatic inline int acpi_pptt_cpu_is_thread(unsigned int cpu)\n{\n\treturn -EINVAL;\n}\nstatic inline int find_acpi_cpu_topology(unsigned int cpu, int level)\n{\n\treturn -EINVAL;\n}\nstatic inline int find_acpi_cpu_topology_cluster(unsigned int cpu)\n{\n\treturn -EINVAL;\n}\nstatic inline int find_acpi_cpu_topology_package(unsigned int cpu)\n{\n\treturn -EINVAL;\n}\nstatic inline int find_acpi_cpu_topology_hetero_id(unsigned int cpu)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#ifdef CONFIG_ARM64\nvoid acpi_arm_init(void);\n#else\nstatic inline void acpi_arm_init(void) { }\n#endif\n\n#ifdef CONFIG_ACPI_PCC\nvoid acpi_init_pcc(void);\n#else\nstatic inline void acpi_init_pcc(void) { }\n#endif\n\n#ifdef CONFIG_ACPI_FFH\nvoid acpi_init_ffh(void);\nextern int acpi_ffh_address_space_arch_setup(void *handler_ctxt,\n\t\t\t\t\t     void **region_ctxt);\nextern int acpi_ffh_address_space_arch_handler(acpi_integer *value,\n\t\t\t\t\t       void *region_context);\n#else\nstatic inline void acpi_init_ffh(void) { }\n#endif\n\n#ifdef CONFIG_ACPI\nextern void acpi_device_notify(struct device *dev);\nextern void acpi_device_notify_remove(struct device *dev);\n#else\nstatic inline void acpi_device_notify(struct device *dev) { }\nstatic inline void acpi_device_notify_remove(struct device *dev) { }\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}