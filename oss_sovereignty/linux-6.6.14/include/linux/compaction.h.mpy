{
  "module_name": "compaction.h",
  "hash_id": "4b1879ebfc8730d56acb76a904ccd3a821347281db448e74e420c57a434f8aaf",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/compaction.h",
  "human_readable_source": " \n#ifndef _LINUX_COMPACTION_H\n#define _LINUX_COMPACTION_H\n\n \nenum compact_priority {\n\tCOMPACT_PRIO_SYNC_FULL,\n\tMIN_COMPACT_PRIORITY = COMPACT_PRIO_SYNC_FULL,\n\tCOMPACT_PRIO_SYNC_LIGHT,\n\tMIN_COMPACT_COSTLY_PRIORITY = COMPACT_PRIO_SYNC_LIGHT,\n\tDEF_COMPACT_PRIORITY = COMPACT_PRIO_SYNC_LIGHT,\n\tCOMPACT_PRIO_ASYNC,\n\tINIT_COMPACT_PRIORITY = COMPACT_PRIO_ASYNC\n};\n\n \n \nenum compact_result {\n\t \n\tCOMPACT_NOT_SUITABLE_ZONE,\n\t \n\tCOMPACT_SKIPPED,\n\t \n\tCOMPACT_DEFERRED,\n\n\t \n\tCOMPACT_NO_SUITABLE_PAGE,\n\t \n\tCOMPACT_CONTINUE,\n\n\t \n\tCOMPACT_COMPLETE,\n\t \n\tCOMPACT_PARTIAL_SKIPPED,\n\n\t \n\tCOMPACT_CONTENDED,\n\n\t \n\tCOMPACT_SUCCESS,\n};\n\nstruct alloc_context;  \n\n \nstatic inline unsigned long compact_gap(unsigned int order)\n{\n\t \n\treturn 2UL << order;\n}\n\n#ifdef CONFIG_COMPACTION\n\nextern unsigned int extfrag_for_order(struct zone *zone, unsigned int order);\nextern int fragmentation_index(struct zone *zone, unsigned int order);\nextern enum compact_result try_to_compact_pages(gfp_t gfp_mask,\n\t\tunsigned int order, unsigned int alloc_flags,\n\t\tconst struct alloc_context *ac, enum compact_priority prio,\n\t\tstruct page **page);\nextern void reset_isolation_suitable(pg_data_t *pgdat);\nextern bool compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\t       int highest_zoneidx);\n\nextern void compaction_defer_reset(struct zone *zone, int order,\n\t\t\t\tbool alloc_success);\n\nbool compaction_zonelist_suitable(struct alloc_context *ac, int order,\n\t\t\t\t\tint alloc_flags);\n\nextern void __meminit kcompactd_run(int nid);\nextern void __meminit kcompactd_stop(int nid);\nextern void wakeup_kcompactd(pg_data_t *pgdat, int order, int highest_zoneidx);\n\n#else\nstatic inline void reset_isolation_suitable(pg_data_t *pgdat)\n{\n}\n\nstatic inline bool compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\t\t      int highest_zoneidx)\n{\n\treturn false;\n}\n\nstatic inline void kcompactd_run(int nid)\n{\n}\nstatic inline void kcompactd_stop(int nid)\n{\n}\n\nstatic inline void wakeup_kcompactd(pg_data_t *pgdat,\n\t\t\t\tint order, int highest_zoneidx)\n{\n}\n\n#endif  \n\nstruct node;\n#if defined(CONFIG_COMPACTION) && defined(CONFIG_SYSFS) && defined(CONFIG_NUMA)\nextern int compaction_register_node(struct node *node);\nextern void compaction_unregister_node(struct node *node);\n\n#else\n\nstatic inline int compaction_register_node(struct node *node)\n{\n\treturn 0;\n}\n\nstatic inline void compaction_unregister_node(struct node *node)\n{\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}