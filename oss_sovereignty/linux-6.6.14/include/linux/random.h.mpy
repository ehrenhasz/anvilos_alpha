{
  "module_name": "random.h",
  "hash_id": "68dd5568b0d80d74d9ee4e7209141148eec74374d370fa31bdac6ea0fe506a28",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/random.h",
  "human_readable_source": " \n\n#ifndef _LINUX_RANDOM_H\n#define _LINUX_RANDOM_H\n\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n\n#include <uapi/linux/random.h>\n\nstruct notifier_block;\n\nvoid add_device_randomness(const void *buf, size_t len);\nvoid __init add_bootloader_randomness(const void *buf, size_t len);\nvoid add_input_randomness(unsigned int type, unsigned int code,\n\t\t\t  unsigned int value) __latent_entropy;\nvoid add_interrupt_randomness(int irq) __latent_entropy;\nvoid add_hwgenerator_randomness(const void *buf, size_t len, size_t entropy, bool sleep_after);\n\nstatic inline void add_latent_entropy(void)\n{\n#if defined(LATENT_ENTROPY_PLUGIN) && !defined(__CHECKER__)\n\tadd_device_randomness((const void *)&latent_entropy, sizeof(latent_entropy));\n#else\n\tadd_device_randomness(NULL, 0);\n#endif\n}\n\n#if IS_ENABLED(CONFIG_VMGENID)\nvoid add_vmfork_randomness(const void *unique_vm_id, size_t len);\nint register_random_vmfork_notifier(struct notifier_block *nb);\nint unregister_random_vmfork_notifier(struct notifier_block *nb);\n#else\nstatic inline int register_random_vmfork_notifier(struct notifier_block *nb) { return 0; }\nstatic inline int unregister_random_vmfork_notifier(struct notifier_block *nb) { return 0; }\n#endif\n\nvoid get_random_bytes(void *buf, size_t len);\nu8 get_random_u8(void);\nu16 get_random_u16(void);\nu32 get_random_u32(void);\nu64 get_random_u64(void);\nstatic inline unsigned long get_random_long(void)\n{\n#if BITS_PER_LONG == 64\n\treturn get_random_u64();\n#else\n\treturn get_random_u32();\n#endif\n}\n\nu32 __get_random_u32_below(u32 ceil);\n\n \nstatic inline u32 get_random_u32_below(u32 ceil)\n{\n\tif (!__builtin_constant_p(ceil))\n\t\treturn __get_random_u32_below(ceil);\n\n\t \n\tBUILD_BUG_ON_MSG(!ceil, \"get_random_u32_below() must take ceil > 0\");\n\tif (ceil <= 1)\n\t\treturn 0;\n\tfor (;;) {\n\t\tif (ceil <= 1U << 8) {\n\t\t\tu32 mult = ceil * get_random_u8();\n\t\t\tif (likely(is_power_of_2(ceil) || (u8)mult >= (1U << 8) % ceil))\n\t\t\t\treturn mult >> 8;\n\t\t} else if (ceil <= 1U << 16) {\n\t\t\tu32 mult = ceil * get_random_u16();\n\t\t\tif (likely(is_power_of_2(ceil) || (u16)mult >= (1U << 16) % ceil))\n\t\t\t\treturn mult >> 16;\n\t\t} else {\n\t\t\tu64 mult = (u64)ceil * get_random_u32();\n\t\t\tif (likely(is_power_of_2(ceil) || (u32)mult >= -ceil % ceil))\n\t\t\t\treturn mult >> 32;\n\t\t}\n\t}\n}\n\n \nstatic inline u32 get_random_u32_above(u32 floor)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(floor) && floor == U32_MAX,\n\t\t\t \"get_random_u32_above() must take floor < U32_MAX\");\n\treturn floor + 1 + get_random_u32_below(U32_MAX - floor);\n}\n\n \nstatic inline u32 get_random_u32_inclusive(u32 floor, u32 ceil)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(floor) && __builtin_constant_p(ceil) &&\n\t\t\t (floor > ceil || ceil - floor == U32_MAX),\n\t\t\t \"get_random_u32_inclusive() must take floor <= ceil\");\n\treturn floor + get_random_u32_below(ceil - floor + 1);\n}\n\nvoid __init random_init_early(const char *command_line);\nvoid __init random_init(void);\nbool rng_is_initialized(void);\nint wait_for_random_bytes(void);\nint execute_with_initialized_rng(struct notifier_block *nb);\n\n \nstatic inline int get_random_bytes_wait(void *buf, size_t nbytes)\n{\n\tint ret = wait_for_random_bytes();\n\tget_random_bytes(buf, nbytes);\n\treturn ret;\n}\n\n#define declare_get_random_var_wait(name, ret_type) \\\n\tstatic inline int get_random_ ## name ## _wait(ret_type *out) { \\\n\t\tint ret = wait_for_random_bytes(); \\\n\t\tif (unlikely(ret)) \\\n\t\t\treturn ret; \\\n\t\t*out = get_random_ ## name(); \\\n\t\treturn 0; \\\n\t}\ndeclare_get_random_var_wait(u8, u8)\ndeclare_get_random_var_wait(u16, u16)\ndeclare_get_random_var_wait(u32, u32)\ndeclare_get_random_var_wait(u64, u32)\ndeclare_get_random_var_wait(long, unsigned long)\n#undef declare_get_random_var\n\n \n#include <linux/prandom.h>\n\n#ifdef CONFIG_SMP\nint random_prepare_cpu(unsigned int cpu);\nint random_online_cpu(unsigned int cpu);\n#endif\n\n#ifndef MODULE\nextern const struct file_operations random_fops, urandom_fops;\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}