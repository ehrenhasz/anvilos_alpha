{
  "module_name": "mbcache.h",
  "hash_id": "fcaa6c6637db8b0dfa78babd5344d58ff9a1829c91b93c04aedcf72921e1cd45",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mbcache.h",
  "human_readable_source": " \n#ifndef _LINUX_MBCACHE_H\n#define _LINUX_MBCACHE_H\n\n#include <linux/hash.h>\n#include <linux/list_bl.h>\n#include <linux/list.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstruct mb_cache;\n\n \nenum {\n\tMBE_REFERENCED_B = 0,\n\tMBE_REUSABLE_B\n};\n\nstruct mb_cache_entry {\n\t \n\tstruct list_head\te_list;\n\t \n\tstruct hlist_bl_node\te_hash_list;\n\t \n\tatomic_t\t\te_refcnt;\n\t \n\tu32\t\t\te_key;\n\tunsigned long\t\te_flags;\n\t \n\tu64\t\t\te_value;\n};\n\nstruct mb_cache *mb_cache_create(int bucket_bits);\nvoid mb_cache_destroy(struct mb_cache *cache);\n\nint mb_cache_entry_create(struct mb_cache *cache, gfp_t mask, u32 key,\n\t\t\t  u64 value, bool reusable);\nvoid __mb_cache_entry_free(struct mb_cache *cache,\n\t\t\t   struct mb_cache_entry *entry);\nvoid mb_cache_entry_wait_unused(struct mb_cache_entry *entry);\nstatic inline void mb_cache_entry_put(struct mb_cache *cache,\n\t\t\t\t      struct mb_cache_entry *entry)\n{\n\tunsigned int cnt = atomic_dec_return(&entry->e_refcnt);\n\n\tif (cnt > 0) {\n\t\tif (cnt <= 2)\n\t\t\twake_up_var(&entry->e_refcnt);\n\t\treturn;\n\t}\n\t__mb_cache_entry_free(cache, entry);\n}\n\nstruct mb_cache_entry *mb_cache_entry_delete_or_get(struct mb_cache *cache,\n\t\t\t\t\t\t    u32 key, u64 value);\nstruct mb_cache_entry *mb_cache_entry_get(struct mb_cache *cache, u32 key,\n\t\t\t\t\t  u64 value);\nstruct mb_cache_entry *mb_cache_entry_find_first(struct mb_cache *cache,\n\t\t\t\t\t\t u32 key);\nstruct mb_cache_entry *mb_cache_entry_find_next(struct mb_cache *cache,\n\t\t\t\t\t\tstruct mb_cache_entry *entry);\nvoid mb_cache_entry_touch(struct mb_cache *cache,\n\t\t\t  struct mb_cache_entry *entry);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}