{
  "module_name": "capability.h",
  "hash_id": "5fee890504128dae572bc5da96290b3e4ca7d87c0aa268558ab1cfdb6f2e1bec",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/capability.h",
  "human_readable_source": " \n \n#ifndef _LINUX_CAPABILITY_H\n#define _LINUX_CAPABILITY_H\n\n#include <uapi/linux/capability.h>\n#include <linux/uidgid.h>\n#include <linux/bits.h>\n\n#define _KERNEL_CAPABILITY_VERSION _LINUX_CAPABILITY_VERSION_3\n\nextern int file_caps_enabled;\n\ntypedef struct { u64 val; } kernel_cap_t;\n\n \nstruct cpu_vfs_cap_data {\n\t__u32 magic_etc;\n\tkuid_t rootid;\n\tkernel_cap_t permitted;\n\tkernel_cap_t inheritable;\n};\n\n#define _USER_CAP_HEADER_SIZE  (sizeof(struct __user_cap_header_struct))\n#define _KERNEL_CAP_T_SIZE     (sizeof(kernel_cap_t))\n\nstruct file;\nstruct inode;\nstruct dentry;\nstruct task_struct;\nstruct user_namespace;\nstruct mnt_idmap;\n\n \n\n# define CAP_FS_MASK     (BIT_ULL(CAP_CHOWN)\t\t\\\n\t\t\t| BIT_ULL(CAP_MKNOD)\t\t\\\n\t\t\t| BIT_ULL(CAP_DAC_OVERRIDE)\t\\\n\t\t\t| BIT_ULL(CAP_DAC_READ_SEARCH)\t\\\n\t\t\t| BIT_ULL(CAP_FOWNER)\t\t\\\n\t\t\t| BIT_ULL(CAP_FSETID)\t\t\\\n\t\t\t| BIT_ULL(CAP_MAC_OVERRIDE))\n#define CAP_VALID_MASK\t (BIT_ULL(CAP_LAST_CAP+1)-1)\n\n# define CAP_EMPTY_SET    ((kernel_cap_t) { 0 })\n# define CAP_FULL_SET     ((kernel_cap_t) { CAP_VALID_MASK })\n# define CAP_FS_SET       ((kernel_cap_t) { CAP_FS_MASK | BIT_ULL(CAP_LINUX_IMMUTABLE) })\n# define CAP_NFSD_SET     ((kernel_cap_t) { CAP_FS_MASK | BIT_ULL(CAP_SYS_RESOURCE) })\n\n# define cap_clear(c)         do { (c).val = 0; } while (0)\n\n#define cap_raise(c, flag)  ((c).val |= BIT_ULL(flag))\n#define cap_lower(c, flag)  ((c).val &= ~BIT_ULL(flag))\n#define cap_raised(c, flag) (((c).val & BIT_ULL(flag)) != 0)\n\nstatic inline kernel_cap_t cap_combine(const kernel_cap_t a,\n\t\t\t\t       const kernel_cap_t b)\n{\n\treturn (kernel_cap_t) { a.val | b.val };\n}\n\nstatic inline kernel_cap_t cap_intersect(const kernel_cap_t a,\n\t\t\t\t\t const kernel_cap_t b)\n{\n\treturn (kernel_cap_t) { a.val & b.val };\n}\n\nstatic inline kernel_cap_t cap_drop(const kernel_cap_t a,\n\t\t\t\t    const kernel_cap_t drop)\n{\n\treturn (kernel_cap_t) { a.val &~ drop.val };\n}\n\nstatic inline bool cap_isclear(const kernel_cap_t a)\n{\n\treturn !a.val;\n}\n\nstatic inline bool cap_isidentical(const kernel_cap_t a, const kernel_cap_t b)\n{\n\treturn a.val == b.val;\n}\n\n \nstatic inline bool cap_issubset(const kernel_cap_t a, const kernel_cap_t set)\n{\n\treturn !(a.val & ~set.val);\n}\n\n \n\nstatic inline kernel_cap_t cap_drop_fs_set(const kernel_cap_t a)\n{\n\treturn cap_drop(a, CAP_FS_SET);\n}\n\nstatic inline kernel_cap_t cap_raise_fs_set(const kernel_cap_t a,\n\t\t\t\t\t    const kernel_cap_t permitted)\n{\n\treturn cap_combine(a, cap_intersect(permitted, CAP_FS_SET));\n}\n\nstatic inline kernel_cap_t cap_drop_nfsd_set(const kernel_cap_t a)\n{\n\treturn cap_drop(a, CAP_NFSD_SET);\n}\n\nstatic inline kernel_cap_t cap_raise_nfsd_set(const kernel_cap_t a,\n\t\t\t\t\t      const kernel_cap_t permitted)\n{\n\treturn cap_combine(a, cap_intersect(permitted, CAP_NFSD_SET));\n}\n\n#ifdef CONFIG_MULTIUSER\nextern bool has_capability(struct task_struct *t, int cap);\nextern bool has_ns_capability(struct task_struct *t,\n\t\t\t      struct user_namespace *ns, int cap);\nextern bool has_capability_noaudit(struct task_struct *t, int cap);\nextern bool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t\t      struct user_namespace *ns, int cap);\nextern bool capable(int cap);\nextern bool ns_capable(struct user_namespace *ns, int cap);\nextern bool ns_capable_noaudit(struct user_namespace *ns, int cap);\nextern bool ns_capable_setid(struct user_namespace *ns, int cap);\n#else\nstatic inline bool has_capability(struct task_struct *t, int cap)\n{\n\treturn true;\n}\nstatic inline bool has_ns_capability(struct task_struct *t,\n\t\t\t      struct user_namespace *ns, int cap)\n{\n\treturn true;\n}\nstatic inline bool has_capability_noaudit(struct task_struct *t, int cap)\n{\n\treturn true;\n}\nstatic inline bool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t\t      struct user_namespace *ns, int cap)\n{\n\treturn true;\n}\nstatic inline bool capable(int cap)\n{\n\treturn true;\n}\nstatic inline bool ns_capable(struct user_namespace *ns, int cap)\n{\n\treturn true;\n}\nstatic inline bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn true;\n}\nstatic inline bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn true;\n}\n#endif  \nbool privileged_wrt_inode_uidgid(struct user_namespace *ns,\n\t\t\t\t struct mnt_idmap *idmap,\n\t\t\t\t const struct inode *inode);\nbool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,\n\t\t\t      const struct inode *inode, int cap);\nextern bool file_ns_capable(const struct file *file, struct user_namespace *ns, int cap);\nextern bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns);\nstatic inline bool perfmon_capable(void)\n{\n\treturn capable(CAP_PERFMON) || capable(CAP_SYS_ADMIN);\n}\n\nstatic inline bool bpf_capable(void)\n{\n\treturn capable(CAP_BPF) || capable(CAP_SYS_ADMIN);\n}\n\nstatic inline bool checkpoint_restore_ns_capable(struct user_namespace *ns)\n{\n\treturn ns_capable(ns, CAP_CHECKPOINT_RESTORE) ||\n\t\tns_capable(ns, CAP_SYS_ADMIN);\n}\n\n \nint get_vfs_caps_from_disk(struct mnt_idmap *idmap,\n\t\t\t   const struct dentry *dentry,\n\t\t\t   struct cpu_vfs_cap_data *cpu_caps);\n\nint cap_convert_nscap(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t      const void **ivalue, size_t size);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}