{
  "module_name": "dcache.h",
  "hash_id": "a84fd1e69806c5b403aed852fa3bc8626502ec1c124848d96eab08efb73ca64d",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/dcache.h",
  "human_readable_source": " \n#ifndef __LINUX_DCACHE_H\n#define __LINUX_DCACHE_H\n\n#include <linux/atomic.h>\n#include <linux/list.h>\n#include <linux/math.h>\n#include <linux/rculist.h>\n#include <linux/rculist_bl.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/cache.h>\n#include <linux/rcupdate.h>\n#include <linux/lockref.h>\n#include <linux/stringhash.h>\n#include <linux/wait.h>\n\nstruct path;\nstruct file;\nstruct vfsmount;\n\n \n\n#define IS_ROOT(x) ((x) == (x)->d_parent)\n\n \n#ifdef __LITTLE_ENDIAN\n #define HASH_LEN_DECLARE u32 hash; u32 len\n #define bytemask_from_count(cnt)\t(~(~0ul << (cnt)*8))\n#else\n #define HASH_LEN_DECLARE u32 len; u32 hash\n #define bytemask_from_count(cnt)\t(~(~0ul >> (cnt)*8))\n#endif\n\n \nstruct qstr {\n\tunion {\n\t\tstruct {\n\t\t\tHASH_LEN_DECLARE;\n\t\t};\n\t\tu64 hash_len;\n\t};\n\tconst unsigned char *name;\n};\n\n#define QSTR_INIT(n,l) { { { .len = l } }, .name = n }\n\nextern const struct qstr empty_name;\nextern const struct qstr slash_name;\nextern const struct qstr dotdot_name;\n\n \n#ifdef CONFIG_64BIT\n# define DNAME_INLINE_LEN 32  \n#else\n# ifdef CONFIG_SMP\n#  define DNAME_INLINE_LEN 36  \n# else\n#  define DNAME_INLINE_LEN 40  \n# endif\n#endif\n\n#define d_lock\td_lockref.lock\n\nstruct dentry {\n\t \n\tunsigned int d_flags;\t\t \n\tseqcount_spinlock_t d_seq;\t \n\tstruct hlist_bl_node d_hash;\t \n\tstruct dentry *d_parent;\t \n\tstruct qstr d_name;\n\tstruct inode *d_inode;\t\t \n\tunsigned char d_iname[DNAME_INLINE_LEN];\t \n\n\t \n\tstruct lockref d_lockref;\t \n\tconst struct dentry_operations *d_op;\n\tstruct super_block *d_sb;\t \n\tunsigned long d_time;\t\t \n\tvoid *d_fsdata;\t\t\t \n\n\tunion {\n\t\tstruct list_head d_lru;\t\t \n\t\twait_queue_head_t *d_wait;\t \n\t};\n\tstruct list_head d_child;\t \n\tstruct list_head d_subdirs;\t \n\t \n\tunion {\n\t\tstruct hlist_node d_alias;\t \n\t\tstruct hlist_bl_node d_in_lookup_hash;\t \n\t \tstruct rcu_head d_rcu;\n\t} d_u;\n} __randomize_layout;\n\n \nenum dentry_d_lock_class\n{\n\tDENTRY_D_LOCK_NORMAL,  \n\tDENTRY_D_LOCK_NESTED\n};\n\nstruct dentry_operations {\n\tint (*d_revalidate)(struct dentry *, unsigned int);\n\tint (*d_weak_revalidate)(struct dentry *, unsigned int);\n\tint (*d_hash)(const struct dentry *, struct qstr *);\n\tint (*d_compare)(const struct dentry *,\n\t\t\tunsigned int, const char *, const struct qstr *);\n\tint (*d_delete)(const struct dentry *);\n\tint (*d_init)(struct dentry *);\n\tvoid (*d_release)(struct dentry *);\n\tvoid (*d_prune)(struct dentry *);\n\tvoid (*d_iput)(struct dentry *, struct inode *);\n\tchar *(*d_dname)(struct dentry *, char *, int);\n\tstruct vfsmount *(*d_automount)(struct path *);\n\tint (*d_manage)(const struct path *, bool);\n\tstruct dentry *(*d_real)(struct dentry *, const struct inode *);\n} ____cacheline_aligned;\n\n \n\n \n#define DCACHE_OP_HASH\t\t\t0x00000001\n#define DCACHE_OP_COMPARE\t\t0x00000002\n#define DCACHE_OP_REVALIDATE\t\t0x00000004\n#define DCACHE_OP_DELETE\t\t0x00000008\n#define DCACHE_OP_PRUNE\t\t\t0x00000010\n\n#define\tDCACHE_DISCONNECTED\t\t0x00000020\n      \n\n#define DCACHE_REFERENCED\t\t0x00000040  \n\n#define DCACHE_DONTCACHE\t\t0x00000080  \n\n#define DCACHE_CANT_MOUNT\t\t0x00000100\n#define DCACHE_GENOCIDE\t\t\t0x00000200\n#define DCACHE_SHRINK_LIST\t\t0x00000400\n\n#define DCACHE_OP_WEAK_REVALIDATE\t0x00000800\n\n#define DCACHE_NFSFS_RENAMED\t\t0x00001000\n      \n#define DCACHE_COOKIE\t\t\t0x00002000  \n#define DCACHE_FSNOTIFY_PARENT_WATCHED\t0x00004000\n      \n\n#define DCACHE_DENTRY_KILLED\t\t0x00008000\n\n#define DCACHE_MOUNTED\t\t\t0x00010000  \n#define DCACHE_NEED_AUTOMOUNT\t\t0x00020000  \n#define DCACHE_MANAGE_TRANSIT\t\t0x00040000  \n#define DCACHE_MANAGED_DENTRY \\\n\t(DCACHE_MOUNTED|DCACHE_NEED_AUTOMOUNT|DCACHE_MANAGE_TRANSIT)\n\n#define DCACHE_LRU_LIST\t\t\t0x00080000\n\n#define DCACHE_ENTRY_TYPE\t\t0x00700000\n#define DCACHE_MISS_TYPE\t\t0x00000000  \n#define DCACHE_WHITEOUT_TYPE\t\t0x00100000  \n#define DCACHE_DIRECTORY_TYPE\t\t0x00200000  \n#define DCACHE_AUTODIR_TYPE\t\t0x00300000  \n#define DCACHE_REGULAR_TYPE\t\t0x00400000  \n#define DCACHE_SPECIAL_TYPE\t\t0x00500000  \n#define DCACHE_SYMLINK_TYPE\t\t0x00600000  \n\n#define DCACHE_MAY_FREE\t\t\t0x00800000\n#define DCACHE_FALLTHRU\t\t\t0x01000000  \n#define DCACHE_NOKEY_NAME\t\t0x02000000  \n#define DCACHE_OP_REAL\t\t\t0x04000000\n\n#define DCACHE_PAR_LOOKUP\t\t0x10000000  \n#define DCACHE_DENTRY_CURSOR\t\t0x20000000\n#define DCACHE_NORCU\t\t\t0x40000000  \n\nextern seqlock_t rename_lock;\n\n \nextern void d_instantiate(struct dentry *, struct inode *);\nextern void d_instantiate_new(struct dentry *, struct inode *);\nextern struct dentry * d_instantiate_unique(struct dentry *, struct inode *);\nextern struct dentry * d_instantiate_anon(struct dentry *, struct inode *);\nextern void __d_drop(struct dentry *dentry);\nextern void d_drop(struct dentry *dentry);\nextern void d_delete(struct dentry *);\nextern void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op);\n\n \nextern struct dentry * d_alloc(struct dentry *, const struct qstr *);\nextern struct dentry * d_alloc_anon(struct super_block *);\nextern struct dentry * d_alloc_parallel(struct dentry *, const struct qstr *,\n\t\t\t\t\twait_queue_head_t *);\nextern struct dentry * d_splice_alias(struct inode *, struct dentry *);\nextern struct dentry * d_add_ci(struct dentry *, struct inode *, struct qstr *);\nextern bool d_same_name(const struct dentry *dentry, const struct dentry *parent,\n\t\t\tconst struct qstr *name);\nextern struct dentry * d_exact_alias(struct dentry *, struct inode *);\nextern struct dentry *d_find_any_alias(struct inode *inode);\nextern struct dentry * d_obtain_alias(struct inode *);\nextern struct dentry * d_obtain_root(struct inode *);\nextern void shrink_dcache_sb(struct super_block *);\nextern void shrink_dcache_parent(struct dentry *);\nextern void shrink_dcache_for_umount(struct super_block *);\nextern void d_invalidate(struct dentry *);\n\n \nextern struct dentry * d_make_root(struct inode *);\n\n \nextern void d_genocide(struct dentry *);\n\nextern void d_tmpfile(struct file *, struct inode *);\n\nextern struct dentry *d_find_alias(struct inode *);\nextern void d_prune_aliases(struct inode *);\n\nextern struct dentry *d_find_alias_rcu(struct inode *);\n\n \nextern int path_has_submounts(const struct path *);\n\n \nextern void d_rehash(struct dentry *);\n \nextern void d_add(struct dentry *, struct inode *);\n\n \nextern void d_move(struct dentry *, struct dentry *);\nextern void d_exchange(struct dentry *, struct dentry *);\nextern struct dentry *d_ancestor(struct dentry *, struct dentry *);\n\n \nextern struct dentry *d_lookup(const struct dentry *, const struct qstr *);\nextern struct dentry *d_hash_and_lookup(struct dentry *, struct qstr *);\nextern struct dentry *__d_lookup(const struct dentry *, const struct qstr *);\nextern struct dentry *__d_lookup_rcu(const struct dentry *parent,\n\t\t\t\tconst struct qstr *name, unsigned *seq);\n\nstatic inline unsigned d_count(const struct dentry *dentry)\n{\n\treturn dentry->d_lockref.count;\n}\n\n \nextern __printf(3, 4)\nchar *dynamic_dname(char *, int, const char *, ...);\n\nextern char *__d_path(const struct path *, const struct path *, char *, int);\nextern char *d_absolute_path(const struct path *, char *, int);\nextern char *d_path(const struct path *, char *, int);\nextern char *dentry_path_raw(const struct dentry *, char *, int);\nextern char *dentry_path(const struct dentry *, char *, int);\n\n \n\n \nstatic inline struct dentry *dget_dlock(struct dentry *dentry)\n{\n\tif (dentry)\n\t\tdentry->d_lockref.count++;\n\treturn dentry;\n}\n\nstatic inline struct dentry *dget(struct dentry *dentry)\n{\n\tif (dentry)\n\t\tlockref_get(&dentry->d_lockref);\n\treturn dentry;\n}\n\nextern struct dentry *dget_parent(struct dentry *dentry);\n\n \n \nstatic inline int d_unhashed(const struct dentry *dentry)\n{\n\treturn hlist_bl_unhashed(&dentry->d_hash);\n}\n\nstatic inline int d_unlinked(const struct dentry *dentry)\n{\n\treturn d_unhashed(dentry) && !IS_ROOT(dentry);\n}\n\nstatic inline int cant_mount(const struct dentry *dentry)\n{\n\treturn (dentry->d_flags & DCACHE_CANT_MOUNT);\n}\n\nstatic inline void dont_mount(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags |= DCACHE_CANT_MOUNT;\n\tspin_unlock(&dentry->d_lock);\n}\n\nextern void __d_lookup_unhash_wake(struct dentry *dentry);\n\nstatic inline int d_in_lookup(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_PAR_LOOKUP;\n}\n\nstatic inline void d_lookup_done(struct dentry *dentry)\n{\n\tif (unlikely(d_in_lookup(dentry)))\n\t\t__d_lookup_unhash_wake(dentry);\n}\n\nextern void dput(struct dentry *);\n\nstatic inline bool d_managed(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_MANAGED_DENTRY;\n}\n\nstatic inline bool d_mountpoint(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_MOUNTED;\n}\n\n \nstatic inline unsigned __d_entry_type(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_ENTRY_TYPE;\n}\n\nstatic inline bool d_is_miss(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_MISS_TYPE;\n}\n\nstatic inline bool d_is_whiteout(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_WHITEOUT_TYPE;\n}\n\nstatic inline bool d_can_lookup(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_DIRECTORY_TYPE;\n}\n\nstatic inline bool d_is_autodir(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_AUTODIR_TYPE;\n}\n\nstatic inline bool d_is_dir(const struct dentry *dentry)\n{\n\treturn d_can_lookup(dentry) || d_is_autodir(dentry);\n}\n\nstatic inline bool d_is_symlink(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_SYMLINK_TYPE;\n}\n\nstatic inline bool d_is_reg(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_REGULAR_TYPE;\n}\n\nstatic inline bool d_is_special(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_SPECIAL_TYPE;\n}\n\nstatic inline bool d_is_file(const struct dentry *dentry)\n{\n\treturn d_is_reg(dentry) || d_is_special(dentry);\n}\n\nstatic inline bool d_is_negative(const struct dentry *dentry)\n{\n\t\n\treturn d_is_miss(dentry);\n}\n\nstatic inline bool d_flags_negative(unsigned flags)\n{\n\treturn (flags & DCACHE_ENTRY_TYPE) == DCACHE_MISS_TYPE;\n}\n\nstatic inline bool d_is_positive(const struct dentry *dentry)\n{\n\treturn !d_is_negative(dentry);\n}\n\n \nstatic inline bool d_really_is_negative(const struct dentry *dentry)\n{\n\treturn dentry->d_inode == NULL;\n}\n\n \nstatic inline bool d_really_is_positive(const struct dentry *dentry)\n{\n\treturn dentry->d_inode != NULL;\n}\n\nstatic inline int simple_positive(const struct dentry *dentry)\n{\n\treturn d_really_is_positive(dentry) && !d_unhashed(dentry);\n}\n\nextern void d_set_fallthru(struct dentry *dentry);\n\nstatic inline bool d_is_fallthru(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_FALLTHRU;\n}\n\n\nextern int sysctl_vfs_cache_pressure;\n\nstatic inline unsigned long vfs_pressure_ratio(unsigned long val)\n{\n\treturn mult_frac(val, sysctl_vfs_cache_pressure, 100);\n}\n\n \nstatic inline struct inode *d_inode(const struct dentry *dentry)\n{\n\treturn dentry->d_inode;\n}\n\n \nstatic inline struct inode *d_inode_rcu(const struct dentry *dentry)\n{\n\treturn READ_ONCE(dentry->d_inode);\n}\n\n \nstatic inline struct inode *d_backing_inode(const struct dentry *upper)\n{\n\tstruct inode *inode = upper->d_inode;\n\n\treturn inode;\n}\n\n \nstatic inline struct dentry *d_backing_dentry(struct dentry *upper)\n{\n\treturn upper;\n}\n\n \nstatic inline struct dentry *d_real(struct dentry *dentry,\n\t\t\t\t    const struct inode *inode)\n{\n\tif (unlikely(dentry->d_flags & DCACHE_OP_REAL))\n\t\treturn dentry->d_op->d_real(dentry, inode);\n\telse\n\t\treturn dentry;\n}\n\n \nstatic inline struct inode *d_real_inode(const struct dentry *dentry)\n{\n\t \n\treturn d_backing_inode(d_real((struct dentry *) dentry, NULL));\n}\n\nstruct name_snapshot {\n\tstruct qstr name;\n\tunsigned char inline_name[DNAME_INLINE_LEN];\n};\nvoid take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);\nvoid release_dentry_name_snapshot(struct name_snapshot *);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}