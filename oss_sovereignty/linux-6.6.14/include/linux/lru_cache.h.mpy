{
  "module_name": "lru_cache.h",
  "hash_id": "28b77929a1660dc5f24da03eb5d4a96f8459f6f389779db3db32b3426319bca1",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/lru_cache.h",
  "human_readable_source": " \n \n\n#ifndef LRU_CACHE_H\n#define LRU_CACHE_H\n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/string.h>  \n#include <linux/seq_file.h>\n\n \n\n \nstruct lc_element {\n\tstruct hlist_node colision;\n\tstruct list_head list;\t\t  \n\tunsigned refcnt;\n\t \n\tunsigned lc_index;\n\t \n\tunsigned lc_number;\n\t \n#define LC_FREE (~0U)\n\n\t \n\tunsigned lc_new_number;\n};\n\nstruct lru_cache {\n\t \n\tstruct list_head lru;\n\tstruct list_head free;\n\tstruct list_head in_use;\n\tstruct list_head to_be_changed;\n\n\t \n\tstruct kmem_cache *lc_cache;\n\n\t \n\tsize_t element_size;\n\t \n\tsize_t element_off;\n\n\t \n\tunsigned int nr_elements;\n\t \n#define LC_MAX_ACTIVE\t(1<<24)\n\n\t \n\tunsigned int max_pending_changes;\n\t \n\tunsigned int pending_changes;\n\n\t \n\tunsigned used;  \n\tunsigned long hits, misses, starving, locked, changed;\n\n\t \n\tunsigned long flags;\n\n\n\tconst char *name;\n\n\t \n\tstruct hlist_head *lc_slot;\n\tstruct lc_element **lc_element;\n};\n\n\n \nenum {\n\t \n\t__LC_PARANOIA,\n\n\t \n\t__LC_DIRTY,\n\n\t \n\t__LC_LOCKED,\n\n\t \n\t__LC_STARVING,\n};\n#define LC_PARANOIA (1<<__LC_PARANOIA)\n#define LC_DIRTY    (1<<__LC_DIRTY)\n#define LC_LOCKED   (1<<__LC_LOCKED)\n#define LC_STARVING (1<<__LC_STARVING)\n\nextern struct lru_cache *lc_create(const char *name, struct kmem_cache *cache,\n\t\tunsigned max_pending_changes,\n\t\tunsigned e_count, size_t e_size, size_t e_off);\nextern void lc_reset(struct lru_cache *lc);\nextern void lc_destroy(struct lru_cache *lc);\nextern void lc_del(struct lru_cache *lc, struct lc_element *element);\n\nextern struct lc_element *lc_get_cumulative(struct lru_cache *lc, unsigned int enr);\nextern struct lc_element *lc_try_get(struct lru_cache *lc, unsigned int enr);\nextern struct lc_element *lc_find(struct lru_cache *lc, unsigned int enr);\nextern struct lc_element *lc_get(struct lru_cache *lc, unsigned int enr);\nextern unsigned int lc_put(struct lru_cache *lc, struct lc_element *e);\nextern void lc_committed(struct lru_cache *lc);\n\nstruct seq_file;\nextern void lc_seq_printf_stats(struct seq_file *seq, struct lru_cache *lc);\n\nextern void lc_seq_dump_details(struct seq_file *seq, struct lru_cache *lc, char *utext,\n\t\t\t\tvoid (*detail) (struct seq_file *, struct lc_element *));\n\n \nstatic inline int lc_try_lock_for_transaction(struct lru_cache *lc)\n{\n\treturn !test_and_set_bit(__LC_LOCKED, &lc->flags);\n}\n\n \nextern int lc_try_lock(struct lru_cache *lc);\n\n \nstatic inline void lc_unlock(struct lru_cache *lc)\n{\n\tclear_bit(__LC_DIRTY, &lc->flags);\n\tclear_bit_unlock(__LC_LOCKED, &lc->flags);\n}\n\nextern bool lc_is_used(struct lru_cache *lc, unsigned int enr);\n\n#define lc_entry(ptr, type, member) \\\n\tcontainer_of(ptr, type, member)\n\nextern struct lc_element *lc_element_by_index(struct lru_cache *lc, unsigned i);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}