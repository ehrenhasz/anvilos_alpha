{
  "module_name": "net.h",
  "hash_id": "8c16f3f8f95e2d5f8e3dbe4f980e1b78356585a52f8272ec94f15f7f407cf54a",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/net.h",
  "human_readable_source": " \n \n#ifndef _LINUX_NET_H\n#define _LINUX_NET_H\n\n#include <linux/stringify.h>\n#include <linux/random.h>\n#include <linux/wait.h>\n#include <linux/fcntl.h>\t \n#include <linux/rcupdate.h>\n#include <linux/once.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/sockptr.h>\n\n#include <uapi/linux/net.h>\n\nstruct poll_table_struct;\nstruct pipe_inode_info;\nstruct inode;\nstruct file;\nstruct net;\n\n \n#define SOCKWQ_ASYNC_NOSPACE\t0\n#define SOCKWQ_ASYNC_WAITDATA\t1\n#define SOCK_NOSPACE\t\t2\n#define SOCK_PASSCRED\t\t3\n#define SOCK_PASSSEC\t\t4\n#define SOCK_SUPPORT_ZC\t\t5\n#define SOCK_CUSTOM_SOCKOPT\t6\n#define SOCK_PASSPIDFD\t\t7\n\n#ifndef ARCH_HAS_SOCKET_TYPES\n \nenum sock_type {\n\tSOCK_STREAM\t= 1,\n\tSOCK_DGRAM\t= 2,\n\tSOCK_RAW\t= 3,\n\tSOCK_RDM\t= 4,\n\tSOCK_SEQPACKET\t= 5,\n\tSOCK_DCCP\t= 6,\n\tSOCK_PACKET\t= 10,\n};\n\n#define SOCK_MAX (SOCK_PACKET + 1)\n \n#define SOCK_TYPE_MASK 0xf\n\n \n#define SOCK_CLOEXEC\tO_CLOEXEC\n#ifndef SOCK_NONBLOCK\n#define SOCK_NONBLOCK\tO_NONBLOCK\n#endif\n\n#endif  \n\n \nenum sock_shutdown_cmd {\n\tSHUT_RD,\n\tSHUT_WR,\n\tSHUT_RDWR,\n};\n\nstruct socket_wq {\n\t \n\twait_queue_head_t\twait;\n\tstruct fasync_struct\t*fasync_list;\n\tunsigned long\t\tflags;  \n\tstruct rcu_head\t\trcu;\n} ____cacheline_aligned_in_smp;\n\n \nstruct socket {\n\tsocket_state\t\tstate;\n\n\tshort\t\t\ttype;\n\n\tunsigned long\t\tflags;\n\n\tstruct file\t\t*file;\n\tstruct sock\t\t*sk;\n\tconst struct proto_ops\t*ops;  \n\n\tstruct socket_wq\twq;\n};\n\n \ntypedef struct {\n\tsize_t written;\n\tsize_t count;\n\tunion {\n\t\tchar __user *buf;\n\t\tvoid *data;\n\t} arg;\n\tint error;\n} read_descriptor_t;\n\nstruct vm_area_struct;\nstruct page;\nstruct sockaddr;\nstruct msghdr;\nstruct module;\nstruct sk_buff;\ntypedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *,\n\t\t\t       unsigned int, size_t);\ntypedef int (*skb_read_actor_t)(struct sock *, struct sk_buff *);\n\n\nstruct proto_ops {\n\tint\t\tfamily;\n\tstruct module\t*owner;\n\tint\t\t(*release)   (struct socket *sock);\n\tint\t\t(*bind)\t     (struct socket *sock,\n\t\t\t\t      struct sockaddr *myaddr,\n\t\t\t\t      int sockaddr_len);\n\tint\t\t(*connect)   (struct socket *sock,\n\t\t\t\t      struct sockaddr *vaddr,\n\t\t\t\t      int sockaddr_len, int flags);\n\tint\t\t(*socketpair)(struct socket *sock1,\n\t\t\t\t      struct socket *sock2);\n\tint\t\t(*accept)    (struct socket *sock,\n\t\t\t\t      struct socket *newsock, int flags, bool kern);\n\tint\t\t(*getname)   (struct socket *sock,\n\t\t\t\t      struct sockaddr *addr,\n\t\t\t\t      int peer);\n\t__poll_t\t(*poll)\t     (struct file *file, struct socket *sock,\n\t\t\t\t      struct poll_table_struct *wait);\n\tint\t\t(*ioctl)     (struct socket *sock, unsigned int cmd,\n\t\t\t\t      unsigned long arg);\n#ifdef CONFIG_COMPAT\n\tint\t \t(*compat_ioctl) (struct socket *sock, unsigned int cmd,\n\t\t\t\t      unsigned long arg);\n#endif\n\tint\t\t(*gettstamp) (struct socket *sock, void __user *userstamp,\n\t\t\t\t      bool timeval, bool time32);\n\tint\t\t(*listen)    (struct socket *sock, int len);\n\tint\t\t(*shutdown)  (struct socket *sock, int flags);\n\tint\t\t(*setsockopt)(struct socket *sock, int level,\n\t\t\t\t      int optname, sockptr_t optval,\n\t\t\t\t      unsigned int optlen);\n\tint\t\t(*getsockopt)(struct socket *sock, int level,\n\t\t\t\t      int optname, char __user *optval, int __user *optlen);\n\tvoid\t\t(*show_fdinfo)(struct seq_file *m, struct socket *sock);\n\tint\t\t(*sendmsg)   (struct socket *sock, struct msghdr *m,\n\t\t\t\t      size_t total_len);\n\t \n\tint\t\t(*recvmsg)   (struct socket *sock, struct msghdr *m,\n\t\t\t\t      size_t total_len, int flags);\n\tint\t\t(*mmap)\t     (struct file *file, struct socket *sock,\n\t\t\t\t      struct vm_area_struct * vma);\n\tssize_t \t(*splice_read)(struct socket *sock,  loff_t *ppos,\n\t\t\t\t       struct pipe_inode_info *pipe, size_t len, unsigned int flags);\n\tvoid\t\t(*splice_eof)(struct socket *sock);\n\tint\t\t(*set_peek_off)(struct sock *sk, int val);\n\tint\t\t(*peek_len)(struct socket *sock);\n\n\t \n\tint\t\t(*read_sock)(struct sock *sk, read_descriptor_t *desc,\n\t\t\t\t     sk_read_actor_t recv_actor);\n\t \n\tint\t\t(*read_skb)(struct sock *sk, skb_read_actor_t recv_actor);\n\tint\t\t(*sendmsg_locked)(struct sock *sk, struct msghdr *msg,\n\t\t\t\t\t  size_t size);\n\tint\t\t(*set_rcvlowat)(struct sock *sk, int val);\n};\n\n#define DECLARE_SOCKADDR(type, dst, src)\t\\\n\ttype dst = ({ __sockaddr_check_size(sizeof(*dst)); (type) src; })\n\nstruct net_proto_family {\n\tint\t\tfamily;\n\tint\t\t(*create)(struct net *net, struct socket *sock,\n\t\t\t\t  int protocol, int kern);\n\tstruct module\t*owner;\n};\n\nstruct iovec;\nstruct kvec;\n\nenum {\n\tSOCK_WAKE_IO,\n\tSOCK_WAKE_WAITD,\n\tSOCK_WAKE_SPACE,\n\tSOCK_WAKE_URG,\n};\n\nint sock_wake_async(struct socket_wq *sk_wq, int how, int band);\nint sock_register(const struct net_proto_family *fam);\nvoid sock_unregister(int family);\nbool sock_is_registered(int family);\nint __sock_create(struct net *net, int family, int type, int proto,\n\t\t  struct socket **res, int kern);\nint sock_create(int family, int type, int proto, struct socket **res);\nint sock_create_kern(struct net *net, int family, int type, int proto, struct socket **res);\nint sock_create_lite(int family, int type, int proto, struct socket **res);\nstruct socket *sock_alloc(void);\nvoid sock_release(struct socket *sock);\nint sock_sendmsg(struct socket *sock, struct msghdr *msg);\nint sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags);\nstruct file *sock_alloc_file(struct socket *sock, int flags, const char *dname);\nstruct socket *sockfd_lookup(int fd, int *err);\nstruct socket *sock_from_file(struct file *file);\n#define\t\t     sockfd_put(sock) fput(sock->file)\nint net_ratelimit(void);\n\n#define net_ratelimited_function(function, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (net_ratelimit())\t\t\t\t\t\\\n\t\tfunction(__VA_ARGS__);\t\t\t\t\\\n} while (0)\n\n#define net_emerg_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_emerg, fmt, ##__VA_ARGS__)\n#define net_alert_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_alert, fmt, ##__VA_ARGS__)\n#define net_crit_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_crit, fmt, ##__VA_ARGS__)\n#define net_err_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_err, fmt, ##__VA_ARGS__)\n#define net_notice_ratelimited(fmt, ...)\t\t\t\\\n\tnet_ratelimited_function(pr_notice, fmt, ##__VA_ARGS__)\n#define net_warn_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_warn, fmt, ##__VA_ARGS__)\n#define net_info_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_info, fmt, ##__VA_ARGS__)\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n#define net_dbg_ratelimited(fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tDEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);\t\t\t\\\n\tif (DYNAMIC_DEBUG_BRANCH(descriptor) &&\t\t\t\t\\\n\t    net_ratelimit())\t\t\t\t\t\t\\\n\t\t__dynamic_pr_debug(&descriptor, pr_fmt(fmt),\t\t\\\n\t\t                   ##__VA_ARGS__);\t\t\t\\\n} while (0)\n#elif defined(DEBUG)\n#define net_dbg_ratelimited(fmt, ...)\t\t\t\t\\\n\tnet_ratelimited_function(pr_debug, fmt, ##__VA_ARGS__)\n#else\n#define net_dbg_ratelimited(fmt, ...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (0)\t\t\t\t\t\t\\\n\t\t\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__); \\\n\t} while (0)\n#endif\n\n#define net_get_random_once(buf, nbytes)\t\t\t\\\n\tget_random_once((buf), (nbytes))\n\n \nstatic inline bool sendpage_ok(struct page *page)\n{\n\treturn !PageSlab(page) && page_count(page) >= 1;\n}\n\nint kernel_sendmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,\n\t\t   size_t num, size_t len);\nint kernel_sendmsg_locked(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct kvec *vec, size_t num, size_t len);\nint kernel_recvmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,\n\t\t   size_t num, size_t len, int flags);\n\nint kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen);\nint kernel_listen(struct socket *sock, int backlog);\nint kernel_accept(struct socket *sock, struct socket **newsock, int flags);\nint kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,\n\t\t   int flags);\nint kernel_getsockname(struct socket *sock, struct sockaddr *addr);\nint kernel_getpeername(struct socket *sock, struct sockaddr *addr);\nint kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how);\n\n \nu32 kernel_sock_ip_overhead(struct sock *sk);\n\n#define MODULE_ALIAS_NETPROTO(proto) \\\n\tMODULE_ALIAS(\"net-pf-\" __stringify(proto))\n\n#define MODULE_ALIAS_NET_PF_PROTO(pf, proto) \\\n\tMODULE_ALIAS(\"net-pf-\" __stringify(pf) \"-proto-\" __stringify(proto))\n\n#define MODULE_ALIAS_NET_PF_PROTO_TYPE(pf, proto, type) \\\n\tMODULE_ALIAS(\"net-pf-\" __stringify(pf) \"-proto-\" __stringify(proto) \\\n\t\t     \"-type-\" __stringify(type))\n\n#define MODULE_ALIAS_NET_PF_PROTO_NAME(pf, proto, name) \\\n\tMODULE_ALIAS(\"net-pf-\" __stringify(pf) \"-proto-\" __stringify(proto) \\\n\t\t     name)\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}