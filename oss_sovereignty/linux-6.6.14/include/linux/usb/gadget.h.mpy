{
  "module_name": "gadget.h",
  "hash_id": "36c14ef3d00c8c41035fd4a9a704e4fe704f8bae67b9867050a276b5951717d2",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/usb/gadget.h",
  "human_readable_source": "\n \n\n#ifndef __LINUX_USB_GADGET_H\n#define __LINUX_USB_GADGET_H\n\n#include <linux/configfs.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <linux/usb/ch9.h>\n\n#define UDC_TRACE_STR_MAX\t512\n\nstruct usb_ep;\n\n \n\nstruct usb_request {\n\tvoid\t\t\t*buf;\n\tunsigned\t\tlength;\n\tdma_addr_t\t\tdma;\n\n\tstruct scatterlist\t*sg;\n\tunsigned\t\tnum_sgs;\n\tunsigned\t\tnum_mapped_sgs;\n\n\tunsigned\t\tstream_id:16;\n\tunsigned\t\tis_last:1;\n\tunsigned\t\tno_interrupt:1;\n\tunsigned\t\tzero:1;\n\tunsigned\t\tshort_not_ok:1;\n\tunsigned\t\tdma_mapped:1;\n\n\tvoid\t\t\t(*complete)(struct usb_ep *ep,\n\t\t\t\t\tstruct usb_request *req);\n\tvoid\t\t\t*context;\n\tstruct list_head\tlist;\n\n\tunsigned\t\tframe_number;\t\t \n\n\tint\t\t\tstatus;\n\tunsigned\t\tactual;\n};\n\n \n\n \nstruct usb_ep_ops {\n\tint (*enable) (struct usb_ep *ep,\n\t\tconst struct usb_endpoint_descriptor *desc);\n\tint (*disable) (struct usb_ep *ep);\n\tvoid (*dispose) (struct usb_ep *ep);\n\n\tstruct usb_request *(*alloc_request) (struct usb_ep *ep,\n\t\tgfp_t gfp_flags);\n\tvoid (*free_request) (struct usb_ep *ep, struct usb_request *req);\n\n\tint (*queue) (struct usb_ep *ep, struct usb_request *req,\n\t\tgfp_t gfp_flags);\n\tint (*dequeue) (struct usb_ep *ep, struct usb_request *req);\n\n\tint (*set_halt) (struct usb_ep *ep, int value);\n\tint (*set_wedge) (struct usb_ep *ep);\n\n\tint (*fifo_status) (struct usb_ep *ep);\n\tvoid (*fifo_flush) (struct usb_ep *ep);\n};\n\n \nstruct usb_ep_caps {\n\tunsigned type_control:1;\n\tunsigned type_iso:1;\n\tunsigned type_bulk:1;\n\tunsigned type_int:1;\n\tunsigned dir_in:1;\n\tunsigned dir_out:1;\n};\n\n#define USB_EP_CAPS_TYPE_CONTROL     0x01\n#define USB_EP_CAPS_TYPE_ISO         0x02\n#define USB_EP_CAPS_TYPE_BULK        0x04\n#define USB_EP_CAPS_TYPE_INT         0x08\n#define USB_EP_CAPS_TYPE_ALL \\\n\t(USB_EP_CAPS_TYPE_ISO | USB_EP_CAPS_TYPE_BULK | USB_EP_CAPS_TYPE_INT)\n#define USB_EP_CAPS_DIR_IN           0x01\n#define USB_EP_CAPS_DIR_OUT          0x02\n#define USB_EP_CAPS_DIR_ALL  (USB_EP_CAPS_DIR_IN | USB_EP_CAPS_DIR_OUT)\n\n#define USB_EP_CAPS(_type, _dir) \\\n\t{ \\\n\t\t.type_control = !!(_type & USB_EP_CAPS_TYPE_CONTROL), \\\n\t\t.type_iso = !!(_type & USB_EP_CAPS_TYPE_ISO), \\\n\t\t.type_bulk = !!(_type & USB_EP_CAPS_TYPE_BULK), \\\n\t\t.type_int = !!(_type & USB_EP_CAPS_TYPE_INT), \\\n\t\t.dir_in = !!(_dir & USB_EP_CAPS_DIR_IN), \\\n\t\t.dir_out = !!(_dir & USB_EP_CAPS_DIR_OUT), \\\n\t}\n\n \n\nstruct usb_ep {\n\tvoid\t\t\t*driver_data;\n\n\tconst char\t\t*name;\n\tconst struct usb_ep_ops\t*ops;\n\tstruct list_head\tep_list;\n\tstruct usb_ep_caps\tcaps;\n\tbool\t\t\tclaimed;\n\tbool\t\t\tenabled;\n\tunsigned\t\tmaxpacket:16;\n\tunsigned\t\tmaxpacket_limit:16;\n\tunsigned\t\tmax_streams:16;\n\tunsigned\t\tmult:2;\n\tunsigned\t\tmaxburst:5;\n\tu8\t\t\taddress;\n\tconst struct usb_endpoint_descriptor\t*desc;\n\tconst struct usb_ss_ep_comp_descriptor\t*comp_desc;\n};\n\n \n\n#if IS_ENABLED(CONFIG_USB_GADGET)\nvoid usb_ep_set_maxpacket_limit(struct usb_ep *ep, unsigned maxpacket_limit);\nint usb_ep_enable(struct usb_ep *ep);\nint usb_ep_disable(struct usb_ep *ep);\nstruct usb_request *usb_ep_alloc_request(struct usb_ep *ep, gfp_t gfp_flags);\nvoid usb_ep_free_request(struct usb_ep *ep, struct usb_request *req);\nint usb_ep_queue(struct usb_ep *ep, struct usb_request *req, gfp_t gfp_flags);\nint usb_ep_dequeue(struct usb_ep *ep, struct usb_request *req);\nint usb_ep_set_halt(struct usb_ep *ep);\nint usb_ep_clear_halt(struct usb_ep *ep);\nint usb_ep_set_wedge(struct usb_ep *ep);\nint usb_ep_fifo_status(struct usb_ep *ep);\nvoid usb_ep_fifo_flush(struct usb_ep *ep);\n#else\nstatic inline void usb_ep_set_maxpacket_limit(struct usb_ep *ep,\n\t\tunsigned maxpacket_limit)\n{ }\nstatic inline int usb_ep_enable(struct usb_ep *ep)\n{ return 0; }\nstatic inline int usb_ep_disable(struct usb_ep *ep)\n{ return 0; }\nstatic inline struct usb_request *usb_ep_alloc_request(struct usb_ep *ep,\n\t\tgfp_t gfp_flags)\n{ return NULL; }\nstatic inline void usb_ep_free_request(struct usb_ep *ep,\n\t\tstruct usb_request *req)\n{ }\nstatic inline int usb_ep_queue(struct usb_ep *ep, struct usb_request *req,\n\t\tgfp_t gfp_flags)\n{ return 0; }\nstatic inline int usb_ep_dequeue(struct usb_ep *ep, struct usb_request *req)\n{ return 0; }\nstatic inline int usb_ep_set_halt(struct usb_ep *ep)\n{ return 0; }\nstatic inline int usb_ep_clear_halt(struct usb_ep *ep)\n{ return 0; }\nstatic inline int usb_ep_set_wedge(struct usb_ep *ep)\n{ return 0; }\nstatic inline int usb_ep_fifo_status(struct usb_ep *ep)\n{ return 0; }\nstatic inline void usb_ep_fifo_flush(struct usb_ep *ep)\n{ }\n#endif  \n\n \n\nstruct usb_dcd_config_params {\n\t__u8  bU1devExitLat;\t \n#define USB_DEFAULT_U1_DEV_EXIT_LAT\t0x01\t \n\t__le16 bU2DevExitLat;\t \n#define USB_DEFAULT_U2_DEV_EXIT_LAT\t0x1F4\t \n\t__u8 besl_baseline;\t \n\t__u8 besl_deep;\t\t \n#define USB_DEFAULT_BESL_UNSPECIFIED\t0xFF\t \n};\n\n\nstruct usb_gadget;\nstruct usb_gadget_driver;\nstruct usb_udc;\n\n \nstruct usb_gadget_ops {\n\tint\t(*get_frame)(struct usb_gadget *);\n\tint\t(*wakeup)(struct usb_gadget *);\n\tint\t(*func_wakeup)(struct usb_gadget *gadget, int intf_id);\n\tint\t(*set_remote_wakeup)(struct usb_gadget *, int set);\n\tint\t(*set_selfpowered) (struct usb_gadget *, int is_selfpowered);\n\tint\t(*vbus_session) (struct usb_gadget *, int is_active);\n\tint\t(*vbus_draw) (struct usb_gadget *, unsigned mA);\n\tint\t(*pullup) (struct usb_gadget *, int is_on);\n\tint\t(*ioctl)(struct usb_gadget *,\n\t\t\t\tunsigned code, unsigned long param);\n\tvoid\t(*get_config_params)(struct usb_gadget *,\n\t\t\t\t     struct usb_dcd_config_params *);\n\tint\t(*udc_start)(struct usb_gadget *,\n\t\t\tstruct usb_gadget_driver *);\n\tint\t(*udc_stop)(struct usb_gadget *);\n\tvoid\t(*udc_set_speed)(struct usb_gadget *, enum usb_device_speed);\n\tvoid\t(*udc_set_ssp_rate)(struct usb_gadget *gadget,\n\t\t\tenum usb_ssp_rate rate);\n\tvoid\t(*udc_async_callbacks)(struct usb_gadget *gadget, bool enable);\n\tstruct usb_ep *(*match_ep)(struct usb_gadget *,\n\t\t\tstruct usb_endpoint_descriptor *,\n\t\t\tstruct usb_ss_ep_comp_descriptor *);\n\tint\t(*check_config)(struct usb_gadget *gadget);\n};\n\n \nstruct usb_gadget {\n\tstruct work_struct\t\twork;\n\tstruct usb_udc\t\t\t*udc;\n\t \n\tconst struct usb_gadget_ops\t*ops;\n\tstruct usb_ep\t\t\t*ep0;\n\tstruct list_head\t\tep_list;\t \n\tenum usb_device_speed\t\tspeed;\n\tenum usb_device_speed\t\tmax_speed;\n\n\t \n\tenum usb_ssp_rate\t\tssp_rate;\n\tenum usb_ssp_rate\t\tmax_ssp_rate;\n\n\tenum usb_device_state\t\tstate;\n\tconst char\t\t\t*name;\n\tstruct device\t\t\tdev;\n\tunsigned\t\t\tisoch_delay;\n\tunsigned\t\t\tout_epnum;\n\tunsigned\t\t\tin_epnum;\n\tunsigned\t\t\tmA;\n\tstruct usb_otg_caps\t\t*otg_caps;\n\n\tunsigned\t\t\tsg_supported:1;\n\tunsigned\t\t\tis_otg:1;\n\tunsigned\t\t\tis_a_peripheral:1;\n\tunsigned\t\t\tb_hnp_enable:1;\n\tunsigned\t\t\ta_hnp_support:1;\n\tunsigned\t\t\ta_alt_hnp_support:1;\n\tunsigned\t\t\thnp_polling_support:1;\n\tunsigned\t\t\thost_request_flag:1;\n\tunsigned\t\t\tquirk_ep_out_aligned_size:1;\n\tunsigned\t\t\tquirk_altset_not_supp:1;\n\tunsigned\t\t\tquirk_stall_not_supp:1;\n\tunsigned\t\t\tquirk_zlp_not_supp:1;\n\tunsigned\t\t\tquirk_avoids_skb_reserve:1;\n\tunsigned\t\t\tis_selfpowered:1;\n\tunsigned\t\t\tdeactivated:1;\n\tunsigned\t\t\tconnected:1;\n\tunsigned\t\t\tlpm_capable:1;\n\tunsigned\t\t\twakeup_capable:1;\n\tunsigned\t\t\twakeup_armed:1;\n\tint\t\t\t\tirq;\n\tint\t\t\t\tid_number;\n};\n#define work_to_gadget(w)\t(container_of((w), struct usb_gadget, work))\n\n \nstatic inline void set_gadget_data(struct usb_gadget *gadget, void *data)\n\t{ dev_set_drvdata(&gadget->dev, data); }\nstatic inline void *get_gadget_data(struct usb_gadget *gadget)\n\t{ return dev_get_drvdata(&gadget->dev); }\nstatic inline struct usb_gadget *dev_to_usb_gadget(struct device *dev)\n{\n\treturn container_of(dev, struct usb_gadget, dev);\n}\nstatic inline struct usb_gadget *usb_get_gadget(struct usb_gadget *gadget)\n{\n\tget_device(&gadget->dev);\n\treturn gadget;\n}\nstatic inline void usb_put_gadget(struct usb_gadget *gadget)\n{\n\tput_device(&gadget->dev);\n}\nextern void usb_initialize_gadget(struct device *parent,\n\t\tstruct usb_gadget *gadget, void (*release)(struct device *dev));\nextern int usb_add_gadget(struct usb_gadget *gadget);\nextern void usb_del_gadget(struct usb_gadget *gadget);\n\n \nextern int usb_add_gadget_udc_release(struct device *parent,\n\t\tstruct usb_gadget *gadget, void (*release)(struct device *dev));\nextern int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget);\nextern void usb_del_gadget_udc(struct usb_gadget *gadget);\nextern char *usb_get_gadget_udc_name(void);\n\n \n#define gadget_for_each_ep(tmp, gadget) \\\n\tlist_for_each_entry(tmp, &(gadget)->ep_list, ep_list)\n\n \nstatic inline size_t usb_ep_align(struct usb_ep *ep, size_t len)\n{\n\tint max_packet_size = (size_t)usb_endpoint_maxp(ep->desc);\n\n\treturn round_up(len, max_packet_size);\n}\n\n \nstatic inline size_t\nusb_ep_align_maybe(struct usb_gadget *g, struct usb_ep *ep, size_t len)\n{\n\treturn g->quirk_ep_out_aligned_size ? usb_ep_align(ep, len) : len;\n}\n\n \nstatic inline int gadget_is_altset_supported(struct usb_gadget *g)\n{\n\treturn !g->quirk_altset_not_supp;\n}\n\n \nstatic inline int gadget_is_stall_supported(struct usb_gadget *g)\n{\n\treturn !g->quirk_stall_not_supp;\n}\n\n \nstatic inline int gadget_is_zlp_supported(struct usb_gadget *g)\n{\n\treturn !g->quirk_zlp_not_supp;\n}\n\n \nstatic inline int gadget_avoids_skb_reserve(struct usb_gadget *g)\n{\n\treturn g->quirk_avoids_skb_reserve;\n}\n\n \nstatic inline int gadget_is_dualspeed(struct usb_gadget *g)\n{\n\treturn g->max_speed >= USB_SPEED_HIGH;\n}\n\n \nstatic inline int gadget_is_superspeed(struct usb_gadget *g)\n{\n\treturn g->max_speed >= USB_SPEED_SUPER;\n}\n\n \nstatic inline int gadget_is_superspeed_plus(struct usb_gadget *g)\n{\n\treturn g->max_speed >= USB_SPEED_SUPER_PLUS;\n}\n\n \nstatic inline int gadget_is_otg(struct usb_gadget *g)\n{\n#ifdef CONFIG_USB_OTG\n\treturn g->is_otg;\n#else\n\treturn 0;\n#endif\n}\n\n \n\n#if IS_ENABLED(CONFIG_USB_GADGET)\nint usb_gadget_frame_number(struct usb_gadget *gadget);\nint usb_gadget_wakeup(struct usb_gadget *gadget);\nint usb_gadget_set_remote_wakeup(struct usb_gadget *gadget, int set);\nint usb_gadget_set_selfpowered(struct usb_gadget *gadget);\nint usb_gadget_clear_selfpowered(struct usb_gadget *gadget);\nint usb_gadget_vbus_connect(struct usb_gadget *gadget);\nint usb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA);\nint usb_gadget_vbus_disconnect(struct usb_gadget *gadget);\nint usb_gadget_connect(struct usb_gadget *gadget);\nint usb_gadget_disconnect(struct usb_gadget *gadget);\nint usb_gadget_deactivate(struct usb_gadget *gadget);\nint usb_gadget_activate(struct usb_gadget *gadget);\nint usb_gadget_check_config(struct usb_gadget *gadget);\n#else\nstatic inline int usb_gadget_frame_number(struct usb_gadget *gadget)\n{ return 0; }\nstatic inline int usb_gadget_wakeup(struct usb_gadget *gadget)\n{ return 0; }\nstatic inline int usb_gadget_set_remote_wakeup(struct usb_gadget *gadget, int set)\n{ return 0; }\nstatic inline int usb_gadget_set_selfpowered(struct usb_gadget *gadget)\n{ return 0; }\nstatic inline int usb_gadget_clear_selfpowered(struct usb_gadget *gadget)\n{ return 0; }\nstatic inline int usb_gadget_vbus_connect(struct usb_gadget *gadget)\n{ return 0; }\nstatic inline int usb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA)\n{ return 0; }\nstatic inline int usb_gadget_vbus_disconnect(struct usb_gadget *gadget)\n{ return 0; }\nstatic inline int usb_gadget_connect(struct usb_gadget *gadget)\n{ return 0; }\nstatic inline int usb_gadget_disconnect(struct usb_gadget *gadget)\n{ return 0; }\nstatic inline int usb_gadget_deactivate(struct usb_gadget *gadget)\n{ return 0; }\nstatic inline int usb_gadget_activate(struct usb_gadget *gadget)\n{ return 0; }\nstatic inline int usb_gadget_check_config(struct usb_gadget *gadget)\n{ return 0; }\n#endif  \n\n \n\n \nstruct usb_gadget_driver {\n\tchar\t\t\t*function;\n\tenum usb_device_speed\tmax_speed;\n\tint\t\t\t(*bind)(struct usb_gadget *gadget,\n\t\t\t\t\tstruct usb_gadget_driver *driver);\n\tvoid\t\t\t(*unbind)(struct usb_gadget *);\n\tint\t\t\t(*setup)(struct usb_gadget *,\n\t\t\t\t\tconst struct usb_ctrlrequest *);\n\tvoid\t\t\t(*disconnect)(struct usb_gadget *);\n\tvoid\t\t\t(*suspend)(struct usb_gadget *);\n\tvoid\t\t\t(*resume)(struct usb_gadget *);\n\tvoid\t\t\t(*reset)(struct usb_gadget *);\n\n\t \n\tstruct device_driver\tdriver;\n\n\tchar\t\t\t*udc_name;\n\tunsigned                match_existing_only:1;\n\tbool\t\t\tis_bound:1;\n};\n\n\n\n \n\n \n\n \nint usb_gadget_register_driver_owner(struct usb_gadget_driver *driver,\n\t\tstruct module *owner, const char *mod_name);\n\n \n#define usb_gadget_register_driver(driver) \\\n\tusb_gadget_register_driver_owner(driver, THIS_MODULE, KBUILD_MODNAME)\n\n \nint usb_gadget_unregister_driver(struct usb_gadget_driver *driver);\n\n \n\n \n\n \nstruct usb_string {\n\tu8\t\t\tid;\n\tconst char\t\t*s;\n};\n\n \nstruct usb_gadget_strings {\n\tu16\t\t\tlanguage;\t \n\tstruct usb_string\t*strings;\n};\n\nstruct usb_gadget_string_container {\n\tstruct list_head        list;\n\tu8                      *stash[];\n};\n\n \nint usb_gadget_get_string(const struct usb_gadget_strings *table, int id, u8 *buf);\n\n \nbool usb_validate_langid(u16 langid);\n\nstruct gadget_string {\n\tstruct config_item item;\n\tstruct list_head list;\n\tchar string[USB_MAX_STRING_LEN];\n\tstruct usb_string usb_string;\n};\n\n#define to_gadget_string(str_item)\\\ncontainer_of(str_item, struct gadget_string, item)\n\n \n\n \n\n \nint usb_descriptor_fillbuf(void *, unsigned,\n\t\tconst struct usb_descriptor_header **);\n\n \nint usb_gadget_config_buf(const struct usb_config_descriptor *config,\n\tvoid *buf, unsigned buflen, const struct usb_descriptor_header **desc);\n\n \nstruct usb_descriptor_header **usb_copy_descriptors(\n\t\tstruct usb_descriptor_header **);\n\n \nstatic inline void usb_free_descriptors(struct usb_descriptor_header **v)\n{\n\tkfree(v);\n}\n\nstruct usb_function;\nint usb_assign_descriptors(struct usb_function *f,\n\t\tstruct usb_descriptor_header **fs,\n\t\tstruct usb_descriptor_header **hs,\n\t\tstruct usb_descriptor_header **ss,\n\t\tstruct usb_descriptor_header **ssp);\nvoid usb_free_all_descriptors(struct usb_function *f);\n\nstruct usb_descriptor_header *usb_otg_descriptor_alloc(\n\t\t\t\tstruct usb_gadget *gadget);\nint usb_otg_descriptor_init(struct usb_gadget *gadget,\n\t\tstruct usb_descriptor_header *otg_desc);\n \n\n \n\n#ifdef\tCONFIG_HAS_DMA\nextern int usb_gadget_map_request_by_dev(struct device *dev,\n\t\tstruct usb_request *req, int is_in);\nextern int usb_gadget_map_request(struct usb_gadget *gadget,\n\t\tstruct usb_request *req, int is_in);\n\nextern void usb_gadget_unmap_request_by_dev(struct device *dev,\n\t\tstruct usb_request *req, int is_in);\nextern void usb_gadget_unmap_request(struct usb_gadget *gadget,\n\t\tstruct usb_request *req, int is_in);\n#else  \nstatic inline int usb_gadget_map_request_by_dev(struct device *dev,\n\t\tstruct usb_request *req, int is_in) { return -ENOSYS; }\nstatic inline int usb_gadget_map_request(struct usb_gadget *gadget,\n\t\tstruct usb_request *req, int is_in) { return -ENOSYS; }\n\nstatic inline void usb_gadget_unmap_request_by_dev(struct device *dev,\n\t\tstruct usb_request *req, int is_in) { }\nstatic inline void usb_gadget_unmap_request(struct usb_gadget *gadget,\n\t\tstruct usb_request *req, int is_in) { }\n#endif  \n\n \n\n \n\nextern void usb_gadget_set_state(struct usb_gadget *gadget,\n\t\tenum usb_device_state state);\n\n \n\n \nextern void usb_gadget_udc_reset(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver);\n\n \n\n \n\nextern void usb_gadget_giveback_request(struct usb_ep *ep,\n\t\tstruct usb_request *req);\n\n \n\n \n\nextern struct usb_ep *gadget_find_ep_by_name(struct usb_gadget *g,\n\t\tconst char *name);\n\n \n\n \n\nextern int usb_gadget_ep_match_desc(struct usb_gadget *gadget,\n\t\tstruct usb_ep *ep, struct usb_endpoint_descriptor *desc,\n\t\tstruct usb_ss_ep_comp_descriptor *ep_comp);\n\n \n\n \nextern void usb_udc_vbus_handler(struct usb_gadget *gadget, bool status);\n\n \n\n \n\nextern struct usb_ep *usb_ep_autoconfig(struct usb_gadget *,\n\t\t\tstruct usb_endpoint_descriptor *);\n\n\nextern struct usb_ep *usb_ep_autoconfig_ss(struct usb_gadget *,\n\t\t\tstruct usb_endpoint_descriptor *,\n\t\t\tstruct usb_ss_ep_comp_descriptor *);\n\nextern void usb_ep_autoconfig_release(struct usb_ep *);\n\nextern void usb_ep_autoconfig_reset(struct usb_gadget *);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}