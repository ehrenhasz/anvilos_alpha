{
  "module_name": "composite.h",
  "hash_id": "b6f5fb5f150e4601de5970d7e0259fbbc0085b69309870b57f65d26ab8b5d586",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/usb/composite.h",
  "human_readable_source": "\n \n\n#ifndef\t__LINUX_USB_COMPOSITE_H\n#define\t__LINUX_USB_COMPOSITE_H\n\n \n\n#include <linux/bcd.h>\n#include <linux/version.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/webusb.h>\n#include <linux/log2.h>\n#include <linux/configfs.h>\n\n \n#define USB_GADGET_DELAYED_STATUS       0x7fff\t \n\n \n#define USB_COMP_EP0_BUFSIZ\t4096\n\n \n#define USB_COMP_EP0_OS_DESC_BUFSIZ\t4096\n\n#define USB_MS_TO_HS_INTERVAL(x)\t(ilog2((x * 1000 / 125)) + 1)\nstruct usb_configuration;\n\n \nstruct usb_os_desc_ext_prop {\n\tstruct list_head\tentry;\n\tu8\t\t\ttype;\n\tint\t\t\tname_len;\n\tchar\t\t\t*name;\n\tint\t\t\tdata_len;\n\tchar\t\t\t*data;\n\tstruct config_item\titem;\n};\n\n \nstruct usb_os_desc {\n\tchar\t\t\t*ext_compat_id;\n\tstruct list_head\text_prop;\n\tint\t\t\text_prop_len;\n\tint\t\t\text_prop_count;\n\tstruct mutex\t\t*opts_mutex;\n\tstruct config_group\tgroup;\n\tstruct module\t\t*owner;\n};\n\n \nstruct usb_os_desc_table {\n\tint\t\t\tif_id;\n\tstruct usb_os_desc\t*os_desc;\n};\n\n \n\nstruct usb_function {\n\tconst char\t\t\t*name;\n\tstruct usb_gadget_strings\t**strings;\n\tstruct usb_descriptor_header\t**fs_descriptors;\n\tstruct usb_descriptor_header\t**hs_descriptors;\n\tstruct usb_descriptor_header\t**ss_descriptors;\n\tstruct usb_descriptor_header\t**ssp_descriptors;\n\n\tstruct usb_configuration\t*config;\n\n\tstruct usb_os_desc_table\t*os_desc_table;\n\tunsigned\t\t\tos_desc_n;\n\n\t \n\n\t \n\tint\t\t\t(*bind)(struct usb_configuration *,\n\t\t\t\t\tstruct usb_function *);\n\tvoid\t\t\t(*unbind)(struct usb_configuration *,\n\t\t\t\t\tstruct usb_function *);\n\tvoid\t\t\t(*free_func)(struct usb_function *f);\n\tstruct module\t\t*mod;\n\n\t \n\tint\t\t\t(*set_alt)(struct usb_function *,\n\t\t\t\t\tunsigned interface, unsigned alt);\n\tint\t\t\t(*get_alt)(struct usb_function *,\n\t\t\t\t\tunsigned interface);\n\tvoid\t\t\t(*disable)(struct usb_function *);\n\tint\t\t\t(*setup)(struct usb_function *,\n\t\t\t\t\tconst struct usb_ctrlrequest *);\n\tbool\t\t\t(*req_match)(struct usb_function *,\n\t\t\t\t\tconst struct usb_ctrlrequest *,\n\t\t\t\t\tbool config0);\n\tvoid\t\t\t(*suspend)(struct usb_function *);\n\tvoid\t\t\t(*resume)(struct usb_function *);\n\n\t \n\tint\t\t\t(*get_status)(struct usb_function *);\n\tint\t\t\t(*func_suspend)(struct usb_function *,\n\t\t\t\t\t\tu8 suspend_opt);\n\tbool\t\t\tfunc_suspended;\n\tbool\t\t\tfunc_wakeup_armed;\n\t \n\t \n\tstruct list_head\t\tlist;\n\tDECLARE_BITMAP(endpoints, 32);\n\tconst struct usb_function_instance *fi;\n\n\tunsigned int\t\tbind_deactivated:1;\n};\n\nint usb_add_function(struct usb_configuration *, struct usb_function *);\n\nint usb_function_deactivate(struct usb_function *);\nint usb_function_activate(struct usb_function *);\n\nint usb_interface_id(struct usb_configuration *, struct usb_function *);\n\nint config_ep_by_speed_and_alt(struct usb_gadget *g, struct usb_function *f,\n\t\t\t\tstruct usb_ep *_ep, u8 alt);\n\nint config_ep_by_speed(struct usb_gadget *g, struct usb_function *f,\n\t\t\tstruct usb_ep *_ep);\nint usb_func_wakeup(struct usb_function *func);\n\n#define\tMAX_CONFIG_INTERFACES\t\t16\t \n\n \nstruct usb_configuration {\n\tconst char\t\t\t*label;\n\tstruct usb_gadget_strings\t**strings;\n\tconst struct usb_descriptor_header **descriptors;\n\n\t \n\n\t \n\tvoid\t\t\t(*unbind)(struct usb_configuration *);\n\tint\t\t\t(*setup)(struct usb_configuration *,\n\t\t\t\t\tconst struct usb_ctrlrequest *);\n\n\t \n\tu8\t\t\tbConfigurationValue;\n\tu8\t\t\tiConfiguration;\n\tu8\t\t\tbmAttributes;\n\tu16\t\t\tMaxPower;\n\n\tstruct usb_composite_dev\t*cdev;\n\n\t \n\t \n\tstruct list_head\tlist;\n\tstruct list_head\tfunctions;\n\tu8\t\t\tnext_interface_id;\n\tunsigned\t\tsuperspeed:1;\n\tunsigned\t\thighspeed:1;\n\tunsigned\t\tfullspeed:1;\n\tunsigned\t\tsuperspeed_plus:1;\n\tstruct usb_function\t*interface[MAX_CONFIG_INTERFACES];\n};\n\nint usb_add_config(struct usb_composite_dev *,\n\t\tstruct usb_configuration *,\n\t\tint (*)(struct usb_configuration *));\n\nvoid usb_remove_config(struct usb_composite_dev *,\n\t\tstruct usb_configuration *);\n\n \nenum {\n\tUSB_GADGET_MANUFACTURER_IDX\t= 0,\n\tUSB_GADGET_PRODUCT_IDX,\n\tUSB_GADGET_SERIAL_IDX,\n\tUSB_GADGET_FIRST_AVAIL_IDX,\n};\n\n \nstruct usb_composite_driver {\n\tconst char\t\t\t\t*name;\n\tconst struct usb_device_descriptor\t*dev;\n\tstruct usb_gadget_strings\t\t**strings;\n\tenum usb_device_speed\t\t\tmax_speed;\n\tunsigned\t\tneeds_serial:1;\n\n\tint\t\t\t(*bind)(struct usb_composite_dev *cdev);\n\tint\t\t\t(*unbind)(struct usb_composite_dev *);\n\n\tvoid\t\t\t(*disconnect)(struct usb_composite_dev *);\n\n\t \n\tvoid\t\t\t(*suspend)(struct usb_composite_dev *);\n\tvoid\t\t\t(*resume)(struct usb_composite_dev *);\n\tstruct usb_gadget_driver\t\tgadget_driver;\n};\n\nextern int usb_composite_probe(struct usb_composite_driver *driver);\nextern void usb_composite_unregister(struct usb_composite_driver *driver);\n\n \n#define module_usb_composite_driver(__usb_composite_driver) \\\n\tmodule_driver(__usb_composite_driver, usb_composite_probe, \\\n\t\t       usb_composite_unregister)\n\nextern void usb_composite_setup_continue(struct usb_composite_dev *cdev);\nextern int composite_dev_prepare(struct usb_composite_driver *composite,\n\t\tstruct usb_composite_dev *cdev);\nextern int composite_os_desc_req_prepare(struct usb_composite_dev *cdev,\n\t\t\t\t\t struct usb_ep *ep0);\nvoid composite_dev_cleanup(struct usb_composite_dev *cdev);\nvoid check_remote_wakeup_config(struct usb_gadget *g,\n\t\t\t\tstruct usb_configuration *c);\n\nstatic inline struct usb_composite_driver *to_cdriver(\n\t\tstruct usb_gadget_driver *gdrv)\n{\n\treturn container_of(gdrv, struct usb_composite_driver, gadget_driver);\n}\n\n#define OS_STRING_QW_SIGN_LEN\t\t14\n#define OS_STRING_IDX\t\t\t0xEE\n\n \nstruct usb_composite_dev {\n\tstruct usb_gadget\t\t*gadget;\n\tstruct usb_request\t\t*req;\n\tstruct usb_request\t\t*os_desc_req;\n\n\tstruct usb_configuration\t*config;\n\n\t \n\tu8\t\t\t\tqw_sign[OS_STRING_QW_SIGN_LEN];\n\tu8\t\t\t\tb_vendor_code;\n\tstruct usb_configuration\t*os_desc_config;\n\tunsigned int\t\t\tuse_os_string:1;\n\n\t \n\tu16\t\t\t\tbcd_webusb_version;\n\tu8\t\t\t\tb_webusb_vendor_code;\n\tchar\t\t\t\tlanding_page[WEBUSB_URL_RAW_MAX_LENGTH];\n\tunsigned int\t\t\tuse_webusb:1;\n\n\t \n\t \n\tunsigned int\t\t\tsuspended:1;\n\tstruct usb_device_descriptor\tdesc;\n\tstruct list_head\t\tconfigs;\n\tstruct list_head\t\tgstrings;\n\tstruct usb_composite_driver\t*driver;\n\tu8\t\t\t\tnext_string_id;\n\tchar\t\t\t\t*def_manufacturer;\n\tstruct usb_string\t\t*usb_strings;\n\n\t \n\tunsigned\t\t\tdeactivations;\n\n\t \n\tint\t\t\t\tdelayed_status;\n\n\t \n\tspinlock_t\t\t\tlock;\n\n\t \n\tunsigned int\t\t\tsetup_pending:1;\n\tunsigned int\t\t\tos_desc_pending:1;\n};\n\nextern int usb_string_id(struct usb_composite_dev *c);\nextern int usb_string_ids_tab(struct usb_composite_dev *c,\n\t\t\t      struct usb_string *str);\nextern struct usb_string *usb_gstrings_attach(struct usb_composite_dev *cdev,\n\t\tstruct usb_gadget_strings **sp, unsigned n_strings);\n\nextern int usb_string_ids_n(struct usb_composite_dev *c, unsigned n);\n\nextern void composite_disconnect(struct usb_gadget *gadget);\nextern void composite_reset(struct usb_gadget *gadget);\n\nextern int composite_setup(struct usb_gadget *gadget,\n\t\tconst struct usb_ctrlrequest *ctrl);\nextern void composite_suspend(struct usb_gadget *gadget);\nextern void composite_resume(struct usb_gadget *gadget);\n\n \nstruct usb_composite_overwrite {\n\tu16\tidVendor;\n\tu16\tidProduct;\n\tu16\tbcdDevice;\n\tchar\t*serial_number;\n\tchar\t*manufacturer;\n\tchar\t*product;\n};\n#define USB_GADGET_COMPOSITE_OPTIONS()\t\t\t\t\t\\\n\tstatic struct usb_composite_overwrite coverwrite;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmodule_param_named(idVendor, coverwrite.idVendor, ushort, S_IRUGO); \\\n\tMODULE_PARM_DESC(idVendor, \"USB Vendor ID\");\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmodule_param_named(idProduct, coverwrite.idProduct, ushort, S_IRUGO); \\\n\tMODULE_PARM_DESC(idProduct, \"USB Product ID\");\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmodule_param_named(bcdDevice, coverwrite.bcdDevice, ushort, S_IRUGO); \\\n\tMODULE_PARM_DESC(bcdDevice, \"USB Device version (BCD)\");\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmodule_param_named(iSerialNumber, coverwrite.serial_number, charp, \\\n\t\t\tS_IRUGO); \\\n\tMODULE_PARM_DESC(iSerialNumber, \"SerialNumber string\");\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmodule_param_named(iManufacturer, coverwrite.manufacturer, charp, \\\n\t\t\tS_IRUGO); \\\n\tMODULE_PARM_DESC(iManufacturer, \"USB Manufacturer string\");\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmodule_param_named(iProduct, coverwrite.product, charp, S_IRUGO); \\\n\tMODULE_PARM_DESC(iProduct, \"USB Product string\")\n\nvoid usb_composite_overwrite_options(struct usb_composite_dev *cdev,\n\t\tstruct usb_composite_overwrite *covr);\n\nstatic inline u16 get_default_bcdDevice(void)\n{\n\tu16 bcdDevice;\n\n\tbcdDevice = bin2bcd(LINUX_VERSION_MAJOR) << 8;\n\tbcdDevice |= bin2bcd(LINUX_VERSION_PATCHLEVEL);\n\treturn bcdDevice;\n}\n\nstruct usb_function_driver {\n\tconst char *name;\n\tstruct module *mod;\n\tstruct list_head list;\n\tstruct usb_function_instance *(*alloc_inst)(void);\n\tstruct usb_function *(*alloc_func)(struct usb_function_instance *inst);\n};\n\nstruct usb_function_instance {\n\tstruct config_group group;\n\tstruct list_head cfs_list;\n\tstruct usb_function_driver *fd;\n\tint (*set_inst_name)(struct usb_function_instance *inst,\n\t\t\t      const char *name);\n\tvoid (*free_func_inst)(struct usb_function_instance *inst);\n};\n\nvoid usb_function_unregister(struct usb_function_driver *f);\nint usb_function_register(struct usb_function_driver *newf);\nvoid usb_put_function_instance(struct usb_function_instance *fi);\nvoid usb_put_function(struct usb_function *f);\nstruct usb_function_instance *usb_get_function_instance(const char *name);\nstruct usb_function *usb_get_function(struct usb_function_instance *fi);\n\nstruct usb_configuration *usb_get_config(struct usb_composite_dev *cdev,\n\t\tint val);\nint usb_add_config_only(struct usb_composite_dev *cdev,\n\t\tstruct usb_configuration *config);\nvoid usb_remove_function(struct usb_configuration *c, struct usb_function *f);\n\n#define DECLARE_USB_FUNCTION(_name, _inst_alloc, _func_alloc)\t\t\\\n\tstatic struct usb_function_driver _name ## usb_func = {\t\t\\\n\t\t.name = __stringify(_name),\t\t\t\t\\\n\t\t.mod  = THIS_MODULE,\t\t\t\t\t\\\n\t\t.alloc_inst = _inst_alloc,\t\t\t\t\\\n\t\t.alloc_func = _func_alloc,\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\tMODULE_ALIAS(\"usbfunc:\"__stringify(_name));\n\n#define DECLARE_USB_FUNCTION_INIT(_name, _inst_alloc, _func_alloc)\t\\\n\tDECLARE_USB_FUNCTION(_name, _inst_alloc, _func_alloc)\t\t\\\n\tstatic int __init _name ## mod_init(void)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn usb_function_register(&_name ## usb_func);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic void __exit _name ## mod_exit(void)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tusb_function_unregister(&_name ## usb_func);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tmodule_init(_name ## mod_init);\t\t\t\t\t\\\n\tmodule_exit(_name ## mod_exit)\n\n \n#define DBG(d, fmt, args...) \\\n\tdev_dbg(&(d)->gadget->dev , fmt , ## args)\n#define VDBG(d, fmt, args...) \\\n\tdev_vdbg(&(d)->gadget->dev , fmt , ## args)\n#define ERROR(d, fmt, args...) \\\n\tdev_err(&(d)->gadget->dev , fmt , ## args)\n#define WARNING(d, fmt, args...) \\\n\tdev_warn(&(d)->gadget->dev , fmt , ## args)\n#define INFO(d, fmt, args...) \\\n\tdev_info(&(d)->gadget->dev , fmt , ## args)\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}