{
  "module_name": "pd.h",
  "hash_id": "470781e5c9d1422ac7f00dd0c37ceb868b750c2dd2a969be3fd357eebdda29dd",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/usb/pd.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_USB_PD_H\n#define __LINUX_USB_PD_H\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/usb/typec.h>\n\n \nenum pd_ctrl_msg_type {\n\t \n\tPD_CTRL_GOOD_CRC = 1,\n\tPD_CTRL_GOTO_MIN = 2,\n\tPD_CTRL_ACCEPT = 3,\n\tPD_CTRL_REJECT = 4,\n\tPD_CTRL_PING = 5,\n\tPD_CTRL_PS_RDY = 6,\n\tPD_CTRL_GET_SOURCE_CAP = 7,\n\tPD_CTRL_GET_SINK_CAP = 8,\n\tPD_CTRL_DR_SWAP = 9,\n\tPD_CTRL_PR_SWAP = 10,\n\tPD_CTRL_VCONN_SWAP = 11,\n\tPD_CTRL_WAIT = 12,\n\tPD_CTRL_SOFT_RESET = 13,\n\t \n\tPD_CTRL_NOT_SUPP = 16,\n\tPD_CTRL_GET_SOURCE_CAP_EXT = 17,\n\tPD_CTRL_GET_STATUS = 18,\n\tPD_CTRL_FR_SWAP = 19,\n\tPD_CTRL_GET_PPS_STATUS = 20,\n\tPD_CTRL_GET_COUNTRY_CODES = 21,\n\t \n};\n\nenum pd_data_msg_type {\n\t \n\tPD_DATA_SOURCE_CAP = 1,\n\tPD_DATA_REQUEST = 2,\n\tPD_DATA_BIST = 3,\n\tPD_DATA_SINK_CAP = 4,\n\tPD_DATA_BATT_STATUS = 5,\n\tPD_DATA_ALERT = 6,\n\tPD_DATA_GET_COUNTRY_INFO = 7,\n\tPD_DATA_ENTER_USB = 8,\n\t \n\tPD_DATA_VENDOR_DEF = 15,\n\t \n};\n\nenum pd_ext_msg_type {\n\t \n\tPD_EXT_SOURCE_CAP_EXT = 1,\n\tPD_EXT_STATUS = 2,\n\tPD_EXT_GET_BATT_CAP = 3,\n\tPD_EXT_GET_BATT_STATUS = 4,\n\tPD_EXT_BATT_CAP = 5,\n\tPD_EXT_GET_MANUFACTURER_INFO = 6,\n\tPD_EXT_MANUFACTURER_INFO = 7,\n\tPD_EXT_SECURITY_REQUEST = 8,\n\tPD_EXT_SECURITY_RESPONSE = 9,\n\tPD_EXT_FW_UPDATE_REQUEST = 10,\n\tPD_EXT_FW_UPDATE_RESPONSE = 11,\n\tPD_EXT_PPS_STATUS = 12,\n\tPD_EXT_COUNTRY_INFO = 13,\n\tPD_EXT_COUNTRY_CODES = 14,\n\t \n};\n\n#define PD_REV10\t0x0\n#define PD_REV20\t0x1\n#define PD_REV30\t0x2\n#define PD_MAX_REV\tPD_REV30\n\n#define PD_HEADER_EXT_HDR\tBIT(15)\n#define PD_HEADER_CNT_SHIFT\t12\n#define PD_HEADER_CNT_MASK\t0x7\n#define PD_HEADER_ID_SHIFT\t9\n#define PD_HEADER_ID_MASK\t0x7\n#define PD_HEADER_PWR_ROLE\tBIT(8)\n#define PD_HEADER_REV_SHIFT\t6\n#define PD_HEADER_REV_MASK\t0x3\n#define PD_HEADER_DATA_ROLE\tBIT(5)\n#define PD_HEADER_TYPE_SHIFT\t0\n#define PD_HEADER_TYPE_MASK\t0x1f\n\n#define PD_HEADER(type, pwr, data, rev, id, cnt, ext_hdr)\t\t\\\n\t((((type) & PD_HEADER_TYPE_MASK) << PD_HEADER_TYPE_SHIFT) |\t\\\n\t ((pwr) == TYPEC_SOURCE ? PD_HEADER_PWR_ROLE : 0) |\t\t\\\n\t ((data) == TYPEC_HOST ? PD_HEADER_DATA_ROLE : 0) |\t\t\\\n\t (rev << PD_HEADER_REV_SHIFT) |\t\t\t\t\t\\\n\t (((id) & PD_HEADER_ID_MASK) << PD_HEADER_ID_SHIFT) |\t\t\\\n\t (((cnt) & PD_HEADER_CNT_MASK) << PD_HEADER_CNT_SHIFT) |\t\\\n\t ((ext_hdr) ? PD_HEADER_EXT_HDR : 0))\n\n#define PD_HEADER_LE(type, pwr, data, rev, id, cnt) \\\n\tcpu_to_le16(PD_HEADER((type), (pwr), (data), (rev), (id), (cnt), (0)))\n\nstatic inline unsigned int pd_header_cnt(u16 header)\n{\n\treturn (header >> PD_HEADER_CNT_SHIFT) & PD_HEADER_CNT_MASK;\n}\n\nstatic inline unsigned int pd_header_cnt_le(__le16 header)\n{\n\treturn pd_header_cnt(le16_to_cpu(header));\n}\n\nstatic inline unsigned int pd_header_type(u16 header)\n{\n\treturn (header >> PD_HEADER_TYPE_SHIFT) & PD_HEADER_TYPE_MASK;\n}\n\nstatic inline unsigned int pd_header_type_le(__le16 header)\n{\n\treturn pd_header_type(le16_to_cpu(header));\n}\n\nstatic inline unsigned int pd_header_msgid(u16 header)\n{\n\treturn (header >> PD_HEADER_ID_SHIFT) & PD_HEADER_ID_MASK;\n}\n\nstatic inline unsigned int pd_header_msgid_le(__le16 header)\n{\n\treturn pd_header_msgid(le16_to_cpu(header));\n}\n\nstatic inline unsigned int pd_header_rev(u16 header)\n{\n\treturn (header >> PD_HEADER_REV_SHIFT) & PD_HEADER_REV_MASK;\n}\n\nstatic inline unsigned int pd_header_rev_le(__le16 header)\n{\n\treturn pd_header_rev(le16_to_cpu(header));\n}\n\n#define PD_EXT_HDR_CHUNKED\t\tBIT(15)\n#define PD_EXT_HDR_CHUNK_NUM_SHIFT\t11\n#define PD_EXT_HDR_CHUNK_NUM_MASK\t0xf\n#define PD_EXT_HDR_REQ_CHUNK\t\tBIT(10)\n#define PD_EXT_HDR_DATA_SIZE_SHIFT\t0\n#define PD_EXT_HDR_DATA_SIZE_MASK\t0x1ff\n\n#define PD_EXT_HDR(data_size, req_chunk, chunk_num, chunked)\t\t\t\t\\\n\t((((data_size) & PD_EXT_HDR_DATA_SIZE_MASK) << PD_EXT_HDR_DATA_SIZE_SHIFT) |\t\\\n\t ((req_chunk) ? PD_EXT_HDR_REQ_CHUNK : 0) |\t\t\t\t\t\\\n\t (((chunk_num) & PD_EXT_HDR_CHUNK_NUM_MASK) << PD_EXT_HDR_CHUNK_NUM_SHIFT) |\t\\\n\t ((chunked) ? PD_EXT_HDR_CHUNKED : 0))\n\n#define PD_EXT_HDR_LE(data_size, req_chunk, chunk_num, chunked) \\\n\tcpu_to_le16(PD_EXT_HDR((data_size), (req_chunk), (chunk_num), (chunked)))\n\nstatic inline unsigned int pd_ext_header_chunk_num(u16 ext_header)\n{\n\treturn (ext_header >> PD_EXT_HDR_CHUNK_NUM_SHIFT) &\n\t\tPD_EXT_HDR_CHUNK_NUM_MASK;\n}\n\nstatic inline unsigned int pd_ext_header_data_size(u16 ext_header)\n{\n\treturn (ext_header >> PD_EXT_HDR_DATA_SIZE_SHIFT) &\n\t\tPD_EXT_HDR_DATA_SIZE_MASK;\n}\n\nstatic inline unsigned int pd_ext_header_data_size_le(__le16 ext_header)\n{\n\treturn pd_ext_header_data_size(le16_to_cpu(ext_header));\n}\n\n#define PD_MAX_PAYLOAD\t\t7\n#define PD_EXT_MAX_CHUNK_DATA\t26\n\n \nstruct pd_chunked_ext_message_data {\n\t__le16 header;\n\tu8 data[PD_EXT_MAX_CHUNK_DATA];\n} __packed;\n\n \nstruct pd_message {\n\t__le16 header;\n\tunion {\n\t\t__le32 payload[PD_MAX_PAYLOAD];\n\t\tstruct pd_chunked_ext_message_data ext_msg;\n\t};\n} __packed;\n\n \n#define PDO_MAX_OBJECTS\t\t7\n\nenum pd_pdo_type {\n\tPDO_TYPE_FIXED = 0,\n\tPDO_TYPE_BATT = 1,\n\tPDO_TYPE_VAR = 2,\n\tPDO_TYPE_APDO = 3,\n};\n\n#define PDO_TYPE_SHIFT\t\t30\n#define PDO_TYPE_MASK\t\t0x3\n\n#define PDO_TYPE(t)\t((t) << PDO_TYPE_SHIFT)\n\n#define PDO_VOLT_MASK\t\t0x3ff\n#define PDO_CURR_MASK\t\t0x3ff\n#define PDO_PWR_MASK\t\t0x3ff\n\n#define PDO_FIXED_DUAL_ROLE\t\tBIT(29)\t \n#define PDO_FIXED_SUSPEND\t\tBIT(28)  \n#define PDO_FIXED_HIGHER_CAP\t\tBIT(28)  \n#define PDO_FIXED_EXTPOWER\t\tBIT(27)  \n#define PDO_FIXED_USB_COMM\t\tBIT(26)  \n#define PDO_FIXED_DATA_SWAP\t\tBIT(25)  \n#define PDO_FIXED_UNCHUNK_EXT\t\tBIT(24)  \n#define PDO_FIXED_FRS_CURR_MASK\t\t(BIT(24) | BIT(23))  \n#define PDO_FIXED_FRS_CURR_SHIFT\t23\n#define PDO_FIXED_VOLT_SHIFT\t\t10\t \n#define PDO_FIXED_CURR_SHIFT\t\t0\t \n\n#define PDO_FIXED_VOLT(mv)\t((((mv) / 50) & PDO_VOLT_MASK) << PDO_FIXED_VOLT_SHIFT)\n#define PDO_FIXED_CURR(ma)\t((((ma) / 10) & PDO_CURR_MASK) << PDO_FIXED_CURR_SHIFT)\n\n#define PDO_FIXED(mv, ma, flags)\t\t\t\\\n\t(PDO_TYPE(PDO_TYPE_FIXED) | (flags) |\t\t\\\n\t PDO_FIXED_VOLT(mv) | PDO_FIXED_CURR(ma))\n\n#define VSAFE5V 5000  \n\n#define PDO_BATT_MAX_VOLT_SHIFT\t20\t \n#define PDO_BATT_MIN_VOLT_SHIFT\t10\t \n#define PDO_BATT_MAX_PWR_SHIFT\t0\t \n\n#define PDO_BATT_MIN_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_BATT_MIN_VOLT_SHIFT)\n#define PDO_BATT_MAX_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_BATT_MAX_VOLT_SHIFT)\n#define PDO_BATT_MAX_POWER(mw) ((((mw) / 250) & PDO_PWR_MASK) << PDO_BATT_MAX_PWR_SHIFT)\n\n#define PDO_BATT(min_mv, max_mv, max_mw)\t\t\t\\\n\t(PDO_TYPE(PDO_TYPE_BATT) | PDO_BATT_MIN_VOLT(min_mv) |\t\\\n\t PDO_BATT_MAX_VOLT(max_mv) | PDO_BATT_MAX_POWER(max_mw))\n\n#define PDO_VAR_MAX_VOLT_SHIFT\t20\t \n#define PDO_VAR_MIN_VOLT_SHIFT\t10\t \n#define PDO_VAR_MAX_CURR_SHIFT\t0\t \n\n#define PDO_VAR_MIN_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_VAR_MIN_VOLT_SHIFT)\n#define PDO_VAR_MAX_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_VAR_MAX_VOLT_SHIFT)\n#define PDO_VAR_MAX_CURR(ma) ((((ma) / 10) & PDO_CURR_MASK) << PDO_VAR_MAX_CURR_SHIFT)\n\n#define PDO_VAR(min_mv, max_mv, max_ma)\t\t\t\t\\\n\t(PDO_TYPE(PDO_TYPE_VAR) | PDO_VAR_MIN_VOLT(min_mv) |\t\\\n\t PDO_VAR_MAX_VOLT(max_mv) | PDO_VAR_MAX_CURR(max_ma))\n\nenum pd_apdo_type {\n\tAPDO_TYPE_PPS = 0,\n};\n\n#define PDO_APDO_TYPE_SHIFT\t28\t \n#define PDO_APDO_TYPE_MASK\t0x3\n\n#define PDO_APDO_TYPE(t)\t((t) << PDO_APDO_TYPE_SHIFT)\n\n#define PDO_PPS_APDO_MAX_VOLT_SHIFT\t17\t \n#define PDO_PPS_APDO_MIN_VOLT_SHIFT\t8\t \n#define PDO_PPS_APDO_MAX_CURR_SHIFT\t0\t \n\n#define PDO_PPS_APDO_VOLT_MASK\t0xff\n#define PDO_PPS_APDO_CURR_MASK\t0x7f\n\n#define PDO_PPS_APDO_MIN_VOLT(mv)\t\\\n\t((((mv) / 100) & PDO_PPS_APDO_VOLT_MASK) << PDO_PPS_APDO_MIN_VOLT_SHIFT)\n#define PDO_PPS_APDO_MAX_VOLT(mv)\t\\\n\t((((mv) / 100) & PDO_PPS_APDO_VOLT_MASK) << PDO_PPS_APDO_MAX_VOLT_SHIFT)\n#define PDO_PPS_APDO_MAX_CURR(ma)\t\\\n\t((((ma) / 50) & PDO_PPS_APDO_CURR_MASK) << PDO_PPS_APDO_MAX_CURR_SHIFT)\n\n#define PDO_PPS_APDO(min_mv, max_mv, max_ma)\t\t\t\t\\\n\t(PDO_TYPE(PDO_TYPE_APDO) | PDO_APDO_TYPE(APDO_TYPE_PPS) |\t\\\n\tPDO_PPS_APDO_MIN_VOLT(min_mv) | PDO_PPS_APDO_MAX_VOLT(max_mv) |\t\\\n\tPDO_PPS_APDO_MAX_CURR(max_ma))\n\nstatic inline enum pd_pdo_type pdo_type(u32 pdo)\n{\n\treturn (pdo >> PDO_TYPE_SHIFT) & PDO_TYPE_MASK;\n}\n\nstatic inline unsigned int pdo_fixed_voltage(u32 pdo)\n{\n\treturn ((pdo >> PDO_FIXED_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;\n}\n\nstatic inline unsigned int pdo_min_voltage(u32 pdo)\n{\n\treturn ((pdo >> PDO_VAR_MIN_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;\n}\n\nstatic inline unsigned int pdo_max_voltage(u32 pdo)\n{\n\treturn ((pdo >> PDO_VAR_MAX_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;\n}\n\nstatic inline unsigned int pdo_max_current(u32 pdo)\n{\n\treturn ((pdo >> PDO_VAR_MAX_CURR_SHIFT) & PDO_CURR_MASK) * 10;\n}\n\nstatic inline unsigned int pdo_max_power(u32 pdo)\n{\n\treturn ((pdo >> PDO_BATT_MAX_PWR_SHIFT) & PDO_PWR_MASK) * 250;\n}\n\nstatic inline enum pd_apdo_type pdo_apdo_type(u32 pdo)\n{\n\treturn (pdo >> PDO_APDO_TYPE_SHIFT) & PDO_APDO_TYPE_MASK;\n}\n\nstatic inline unsigned int pdo_pps_apdo_min_voltage(u32 pdo)\n{\n\treturn ((pdo >> PDO_PPS_APDO_MIN_VOLT_SHIFT) &\n\t\tPDO_PPS_APDO_VOLT_MASK) * 100;\n}\n\nstatic inline unsigned int pdo_pps_apdo_max_voltage(u32 pdo)\n{\n\treturn ((pdo >> PDO_PPS_APDO_MAX_VOLT_SHIFT) &\n\t\tPDO_PPS_APDO_VOLT_MASK) * 100;\n}\n\nstatic inline unsigned int pdo_pps_apdo_max_current(u32 pdo)\n{\n\treturn ((pdo >> PDO_PPS_APDO_MAX_CURR_SHIFT) &\n\t\tPDO_PPS_APDO_CURR_MASK) * 50;\n}\n\n \n#define RDO_OBJ_POS_SHIFT\t28\n#define RDO_OBJ_POS_MASK\t0x7\n#define RDO_GIVE_BACK\t\tBIT(27)\t \n#define RDO_CAP_MISMATCH\tBIT(26)  \n#define RDO_USB_COMM\t\tBIT(25)  \n#define RDO_NO_SUSPEND\t\tBIT(24)  \n\n#define RDO_PWR_MASK\t\t\t0x3ff\n#define RDO_CURR_MASK\t\t\t0x3ff\n\n#define RDO_FIXED_OP_CURR_SHIFT\t\t10\n#define RDO_FIXED_MAX_CURR_SHIFT\t0\n\n#define RDO_OBJ(idx) (((idx) & RDO_OBJ_POS_MASK) << RDO_OBJ_POS_SHIFT)\n\n#define PDO_FIXED_OP_CURR(ma) ((((ma) / 10) & RDO_CURR_MASK) << RDO_FIXED_OP_CURR_SHIFT)\n#define PDO_FIXED_MAX_CURR(ma) ((((ma) / 10) & RDO_CURR_MASK) << RDO_FIXED_MAX_CURR_SHIFT)\n\n#define RDO_FIXED(idx, op_ma, max_ma, flags)\t\t\t\\\n\t(RDO_OBJ(idx) | (flags) |\t\t\t\t\\\n\t PDO_FIXED_OP_CURR(op_ma) | PDO_FIXED_MAX_CURR(max_ma))\n\n#define RDO_BATT_OP_PWR_SHIFT\t\t10\t \n#define RDO_BATT_MAX_PWR_SHIFT\t\t0\t \n\n#define RDO_BATT_OP_PWR(mw) ((((mw) / 250) & RDO_PWR_MASK) << RDO_BATT_OP_PWR_SHIFT)\n#define RDO_BATT_MAX_PWR(mw) ((((mw) / 250) & RDO_PWR_MASK) << RDO_BATT_MAX_PWR_SHIFT)\n\n#define RDO_BATT(idx, op_mw, max_mw, flags)\t\t\t\\\n\t(RDO_OBJ(idx) | (flags) |\t\t\t\t\\\n\t RDO_BATT_OP_PWR(op_mw) | RDO_BATT_MAX_PWR(max_mw))\n\n#define RDO_PROG_VOLT_MASK\t0x7ff\n#define RDO_PROG_CURR_MASK\t0x7f\n\n#define RDO_PROG_VOLT_SHIFT\t9\n#define RDO_PROG_CURR_SHIFT\t0\n\n#define RDO_PROG_VOLT_MV_STEP\t20\n#define RDO_PROG_CURR_MA_STEP\t50\n\n#define PDO_PROG_OUT_VOLT(mv)\t\\\n\t((((mv) / RDO_PROG_VOLT_MV_STEP) & RDO_PROG_VOLT_MASK) << RDO_PROG_VOLT_SHIFT)\n#define PDO_PROG_OP_CURR(ma)\t\\\n\t((((ma) / RDO_PROG_CURR_MA_STEP) & RDO_PROG_CURR_MASK) << RDO_PROG_CURR_SHIFT)\n\n#define RDO_PROG(idx, out_mv, op_ma, flags)\t\t\t\\\n\t(RDO_OBJ(idx) | (flags) |\t\t\t\t\\\n\t PDO_PROG_OUT_VOLT(out_mv) | PDO_PROG_OP_CURR(op_ma))\n\nstatic inline unsigned int rdo_index(u32 rdo)\n{\n\treturn (rdo >> RDO_OBJ_POS_SHIFT) & RDO_OBJ_POS_MASK;\n}\n\nstatic inline unsigned int rdo_op_current(u32 rdo)\n{\n\treturn ((rdo >> RDO_FIXED_OP_CURR_SHIFT) & RDO_CURR_MASK) * 10;\n}\n\nstatic inline unsigned int rdo_max_current(u32 rdo)\n{\n\treturn ((rdo >> RDO_FIXED_MAX_CURR_SHIFT) &\n\t\tRDO_CURR_MASK) * 10;\n}\n\nstatic inline unsigned int rdo_op_power(u32 rdo)\n{\n\treturn ((rdo >> RDO_BATT_OP_PWR_SHIFT) & RDO_PWR_MASK) * 250;\n}\n\nstatic inline unsigned int rdo_max_power(u32 rdo)\n{\n\treturn ((rdo >> RDO_BATT_MAX_PWR_SHIFT) & RDO_PWR_MASK) * 250;\n}\n\n \n#define EUDO_USB_MODE_MASK\t\tGENMASK(30, 28)\n#define EUDO_USB_MODE_SHIFT\t\t28\n#define   EUDO_USB_MODE_USB2\t\t0\n#define   EUDO_USB_MODE_USB3\t\t1\n#define   EUDO_USB_MODE_USB4\t\t2\n#define EUDO_USB4_DRD\t\t\tBIT(26)\n#define EUDO_USB3_DRD\t\t\tBIT(25)\n#define EUDO_CABLE_SPEED_MASK\t\tGENMASK(23, 21)\n#define EUDO_CABLE_SPEED_SHIFT\t\t21\n#define   EUDO_CABLE_SPEED_USB2\t\t0\n#define   EUDO_CABLE_SPEED_USB3_GEN1\t1\n#define   EUDO_CABLE_SPEED_USB4_GEN2\t2\n#define   EUDO_CABLE_SPEED_USB4_GEN3\t3\n#define EUDO_CABLE_TYPE_MASK\t\tGENMASK(20, 19)\n#define EUDO_CABLE_TYPE_SHIFT\t\t19\n#define   EUDO_CABLE_TYPE_PASSIVE\t0\n#define   EUDO_CABLE_TYPE_RE_TIMER\t1\n#define   EUDO_CABLE_TYPE_RE_DRIVER\t2\n#define   EUDO_CABLE_TYPE_OPTICAL\t3\n#define EUDO_CABLE_CURRENT_MASK\t\tGENMASK(18, 17)\n#define EUDO_CABLE_CURRENT_SHIFT\t17\n#define   EUDO_CABLE_CURRENT_NOTSUPP\t0\n#define   EUDO_CABLE_CURRENT_3A\t\t2\n#define   EUDO_CABLE_CURRENT_5A\t\t3\n#define EUDO_PCIE_SUPPORT\t\tBIT(16)\n#define EUDO_DP_SUPPORT\t\t\tBIT(15)\n#define EUDO_TBT_SUPPORT\t\tBIT(14)\n#define EUDO_HOST_PRESENT\t\tBIT(13)\n\n \n#define PD_T_NO_RESPONSE\t5000\t \n#define PD_T_DB_DETECT\t\t10000\t \n#define PD_T_SEND_SOURCE_CAP\t150\t \n#define PD_T_SENDER_RESPONSE\t60\t \n#define PD_T_RECEIVER_RESPONSE\t15\t \n#define PD_T_SOURCE_ACTIVITY\t45\n#define PD_T_SINK_ACTIVITY\t135\n#define PD_T_SINK_WAIT_CAP\t310\t \n#define PD_T_PS_TRANSITION\t500\n#define PD_T_SRC_TRANSITION\t35\n#define PD_T_DRP_SNK\t\t40\n#define PD_T_DRP_SRC\t\t30\n#define PD_T_PS_SOURCE_OFF\t920\n#define PD_T_PS_SOURCE_ON\t480\n#define PD_T_PS_SOURCE_ON_PRS\t450\t \n#define PD_T_PS_HARD_RESET\t30\n#define PD_T_SRC_RECOVER\t760\n#define PD_T_SRC_RECOVER_MAX\t1000\n#define PD_T_SRC_TURN_ON\t275\n#define PD_T_SAFE_0V\t\t650\n#define PD_T_VCONN_SOURCE_ON\t100\n#define PD_T_SINK_REQUEST\t100\t \n#define PD_T_ERROR_RECOVERY\t100\t \n#define PD_T_SRCSWAPSTDBY\t625\t \n#define PD_T_NEWSRC\t\t250\t \n#define PD_T_SWAP_SRC_START\t20\t \n#define PD_T_BIST_CONT_MODE\t50\t \n#define PD_T_SINK_TX\t\t16\t \n#define PD_T_CHUNK_NOT_SUPP\t42\t \n\n#define PD_T_DRP_TRY\t\t100\t \n#define PD_T_DRP_TRYWAIT\t600\t \n\n#define PD_T_CC_DEBOUNCE\t200\t \n#define PD_T_PD_DEBOUNCE\t20\t \n#define PD_T_TRY_CC_DEBOUNCE\t15\t \n\n#define PD_N_CAPS_COUNT\t\t(PD_T_NO_RESPONSE / PD_T_SEND_SOURCE_CAP)\n#define PD_N_HARD_RESET_COUNT\t2\n\n#define PD_P_SNK_STDBY_MW\t2500\t \n\n#if IS_ENABLED(CONFIG_TYPEC)\n\nstruct usb_power_delivery;\n\n \nstruct usb_power_delivery_desc {\n\tu16 revision;\n\tu16 version;\n};\n\n \nstruct usb_power_delivery_capabilities_desc {\n\tu32 pdo[PDO_MAX_OBJECTS];\n\tenum typec_role role;\n};\n\nstruct usb_power_delivery_capabilities *\nusb_power_delivery_register_capabilities(struct usb_power_delivery *pd,\n\t\t\t\t\t struct usb_power_delivery_capabilities_desc *desc);\nvoid usb_power_delivery_unregister_capabilities(struct usb_power_delivery_capabilities *cap);\n\nstruct usb_power_delivery *usb_power_delivery_register(struct device *parent,\n\t\t\t\t\t\t       struct usb_power_delivery_desc *desc);\nvoid usb_power_delivery_unregister(struct usb_power_delivery *pd);\n\nint usb_power_delivery_link_device(struct usb_power_delivery *pd, struct device *dev);\nvoid usb_power_delivery_unlink_device(struct usb_power_delivery *pd, struct device *dev);\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}