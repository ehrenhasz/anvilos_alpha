{
  "module_name": "gadget_configfs.h",
  "hash_id": "78c41394a71e0775c884ec417852c61fb0fab8d87c424ae2f213353ce4da2f3f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/usb/gadget_configfs.h",
  "human_readable_source": " \n#ifndef __GADGET_CONFIGFS__\n#define __GADGET_CONFIGFS__\n\n#include <linux/configfs.h>\n\nint check_user_usb_string(const char *name,\n\t\tstruct usb_gadget_strings *stringtab_dev);\n\n#define GS_STRINGS_W(__struct, __name)\t\\\nstatic ssize_t __struct##_##__name##_store(struct config_item *item, \\\n\t\tconst char *page, size_t len)\t\t\\\n{\t\t\t\t\t\t\t\\\n\tstruct __struct *gs = to_##__struct(item);\t\\\n\tint ret;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\n\tret = usb_string_copy(page, &gs->__name);\t\\\n\tif (ret)\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\\\n\treturn len;\t\t\t\t\t\\\n}\n\n#define GS_STRINGS_R(__struct, __name)\t\\\nstatic ssize_t __struct##_##__name##_show(struct config_item *item, char *page) \\\n{\t\\\n\tstruct __struct *gs = to_##__struct(item);\t\\\n\treturn sprintf(page, \"%s\\n\", gs->__name ?: \"\");\t\\\n}\n\n#define GS_STRINGS_RW(struct_name, _name)\t\\\n\tGS_STRINGS_R(struct_name, _name)\t\\\n\tGS_STRINGS_W(struct_name, _name)\t\\\n\tCONFIGFS_ATTR(struct_name##_, _name)\n\n#define USB_CONFIG_STRING_RW_OPS(struct_in)\t\t\t\t\\\nstatic struct configfs_item_operations struct_in##_langid_item_ops = {\t\\\n\t.release                = struct_in##_attr_release,\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic struct config_item_type struct_in##_langid_type = {\t\t\\\n\t.ct_item_ops\t= &struct_in##_langid_item_ops,\t\t\t\\\n\t.ct_attrs\t= struct_in##_langid_attrs,\t\t\t\\\n\t.ct_owner\t= THIS_MODULE,\t\t\t\t\t\\\n}\n\n#define USB_CONFIG_STRINGS_LANG(struct_in, struct_member)\t\\\n\tstatic struct config_group *struct_in##_strings_make(\t\t\\\n\t\t\tstruct config_group *group,\t\t\t\\\n\t\t\tconst char *name)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\tstruct struct_member *gi;\t\t\t\t\t\\\n\tstruct struct_in *gs;\t\t\t\t\t\t\\\n\tstruct struct_in *new;\t\t\t\t\t\t\\\n\tint langs = 0;\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\t\t\t\\\n\tif (!new)\t\t\t\t\t\t\t\\\n\t\treturn ERR_PTR(-ENOMEM);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = check_user_usb_string(name, &new->stringtab_dev);\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto err;\t\t\t\t\t\t\\\n\tconfig_group_init_type_name(&new->group, name,\t\t\t\\\n\t\t\t&struct_in##_langid_type);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgi = container_of(group, struct struct_member, strings_group);\t\\\n\tret = -EEXIST;\t\t\t\t\t\t\t\\\n\tlist_for_each_entry(gs, &gi->string_list, list) {\t\t\\\n\t\tif (gs->stringtab_dev.language == new->stringtab_dev.language) \\\n\t\t\tgoto err;\t\t\t\t\t\\\n\t\tlangs++;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret = -EOVERFLOW;\t\t\t\t\t\t\\\n\tif (langs >= MAX_USB_STRING_LANGS)\t\t\t\t\\\n\t\tgoto err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tlist_add_tail(&new->list, &gi->string_list);\t\t\t\\\n\treturn &new->group;\t\t\t\t\t\t\\\nerr:\t\t\t\t\t\t\t\t\t\\\n\tkfree(new);\t\t\t\t\t\t\t\\\n\treturn ERR_PTR(ret);\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic void struct_in##_strings_drop(\t\t\t\t\t\\\n\t\tstruct config_group *group,\t\t\t\t\\\n\t\tstruct config_item *item)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tconfig_item_put(item);\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic struct configfs_group_operations struct_in##_strings_ops = {\t\\\n\t.make_group     = &struct_in##_strings_make,\t\t\t\\\n\t.drop_item      = &struct_in##_strings_drop,\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic struct config_item_type struct_in##_strings_type = {\t\t\\\n\t.ct_group_ops   = &struct_in##_strings_ops,\t\t\t\\\n\t.ct_owner       = THIS_MODULE,\t\t\t\t\t\\\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}