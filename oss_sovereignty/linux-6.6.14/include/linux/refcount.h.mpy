{
  "module_name": "refcount.h",
  "hash_id": "9dae007d1c1ddb14539d921e99b45c4c1834085eade23fc5c40d90f3acecb86a",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/refcount.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_REFCOUNT_H\n#define _LINUX_REFCOUNT_H\n\n#include <linux/atomic.h>\n#include <linux/bug.h>\n#include <linux/compiler.h>\n#include <linux/limits.h>\n#include <linux/spinlock_types.h>\n\nstruct mutex;\n\n \ntypedef struct refcount_struct {\n\tatomic_t refs;\n} refcount_t;\n\n#define REFCOUNT_INIT(n)\t{ .refs = ATOMIC_INIT(n), }\n#define REFCOUNT_MAX\t\tINT_MAX\n#define REFCOUNT_SATURATED\t(INT_MIN / 2)\n\nenum refcount_saturation_type {\n\tREFCOUNT_ADD_NOT_ZERO_OVF,\n\tREFCOUNT_ADD_OVF,\n\tREFCOUNT_ADD_UAF,\n\tREFCOUNT_SUB_UAF,\n\tREFCOUNT_DEC_LEAK,\n};\n\nvoid refcount_warn_saturate(refcount_t *r, enum refcount_saturation_type t);\n\n \nstatic inline void refcount_set(refcount_t *r, int n)\n{\n\tatomic_set(&r->refs, n);\n}\n\n \nstatic inline unsigned int refcount_read(const refcount_t *r)\n{\n\treturn atomic_read(&r->refs);\n}\n\nstatic inline __must_check bool __refcount_add_not_zero(int i, refcount_t *r, int *oldp)\n{\n\tint old = refcount_read(r);\n\n\tdo {\n\t\tif (!old)\n\t\t\tbreak;\n\t} while (!atomic_try_cmpxchg_relaxed(&r->refs, &old, old + i));\n\n\tif (oldp)\n\t\t*oldp = old;\n\n\tif (unlikely(old < 0 || old + i < 0))\n\t\trefcount_warn_saturate(r, REFCOUNT_ADD_NOT_ZERO_OVF);\n\n\treturn old;\n}\n\n \nstatic inline __must_check bool refcount_add_not_zero(int i, refcount_t *r)\n{\n\treturn __refcount_add_not_zero(i, r, NULL);\n}\n\nstatic inline void __refcount_add(int i, refcount_t *r, int *oldp)\n{\n\tint old = atomic_fetch_add_relaxed(i, &r->refs);\n\n\tif (oldp)\n\t\t*oldp = old;\n\n\tif (unlikely(!old))\n\t\trefcount_warn_saturate(r, REFCOUNT_ADD_UAF);\n\telse if (unlikely(old < 0 || old + i < 0))\n\t\trefcount_warn_saturate(r, REFCOUNT_ADD_OVF);\n}\n\n \nstatic inline void refcount_add(int i, refcount_t *r)\n{\n\t__refcount_add(i, r, NULL);\n}\n\nstatic inline __must_check bool __refcount_inc_not_zero(refcount_t *r, int *oldp)\n{\n\treturn __refcount_add_not_zero(1, r, oldp);\n}\n\n \nstatic inline __must_check bool refcount_inc_not_zero(refcount_t *r)\n{\n\treturn __refcount_inc_not_zero(r, NULL);\n}\n\nstatic inline void __refcount_inc(refcount_t *r, int *oldp)\n{\n\t__refcount_add(1, r, oldp);\n}\n\n \nstatic inline void refcount_inc(refcount_t *r)\n{\n\t__refcount_inc(r, NULL);\n}\n\nstatic inline __must_check bool __refcount_sub_and_test(int i, refcount_t *r, int *oldp)\n{\n\tint old = atomic_fetch_sub_release(i, &r->refs);\n\n\tif (oldp)\n\t\t*oldp = old;\n\n\tif (old == i) {\n\t\tsmp_acquire__after_ctrl_dep();\n\t\treturn true;\n\t}\n\n\tif (unlikely(old < 0 || old - i < 0))\n\t\trefcount_warn_saturate(r, REFCOUNT_SUB_UAF);\n\n\treturn false;\n}\n\n \nstatic inline __must_check bool refcount_sub_and_test(int i, refcount_t *r)\n{\n\treturn __refcount_sub_and_test(i, r, NULL);\n}\n\nstatic inline __must_check bool __refcount_dec_and_test(refcount_t *r, int *oldp)\n{\n\treturn __refcount_sub_and_test(1, r, oldp);\n}\n\n \nstatic inline __must_check bool refcount_dec_and_test(refcount_t *r)\n{\n\treturn __refcount_dec_and_test(r, NULL);\n}\n\nstatic inline void __refcount_dec(refcount_t *r, int *oldp)\n{\n\tint old = atomic_fetch_sub_release(1, &r->refs);\n\n\tif (oldp)\n\t\t*oldp = old;\n\n\tif (unlikely(old <= 1))\n\t\trefcount_warn_saturate(r, REFCOUNT_DEC_LEAK);\n}\n\n \nstatic inline void refcount_dec(refcount_t *r)\n{\n\t__refcount_dec(r, NULL);\n}\n\nextern __must_check bool refcount_dec_if_one(refcount_t *r);\nextern __must_check bool refcount_dec_not_one(refcount_t *r);\nextern __must_check bool refcount_dec_and_mutex_lock(refcount_t *r, struct mutex *lock) __cond_acquires(lock);\nextern __must_check bool refcount_dec_and_lock(refcount_t *r, spinlock_t *lock) __cond_acquires(lock);\nextern __must_check bool refcount_dec_and_lock_irqsave(refcount_t *r,\n\t\t\t\t\t\t       spinlock_t *lock,\n\t\t\t\t\t\t       unsigned long *flags) __cond_acquires(lock);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}