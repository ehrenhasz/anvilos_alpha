{
  "module_name": "gameport.h",
  "hash_id": "8087e192674194e58d169fabbcbe9f1911081d2e4a011866c151c2906a35754e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/gameport.h",
  "human_readable_source": " \n \n#ifndef _GAMEPORT_H\n#define _GAMEPORT_H\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <uapi/linux/gameport.h>\n\nstruct gameport {\n\n\tvoid *port_data;\t \n\tchar name[32];\n\tchar phys[32];\n\n\tint io;\n\tint speed;\n\tint fuzz;\n\n\tvoid (*trigger)(struct gameport *);\n\tunsigned char (*read)(struct gameport *);\n\tint (*cooked_read)(struct gameport *, int *, int *);\n\tint (*calibrate)(struct gameport *, int *, int *);\n\tint (*open)(struct gameport *, int);\n\tvoid (*close)(struct gameport *);\n\n\tstruct timer_list poll_timer;\n\tunsigned int poll_interval;\t \n\tspinlock_t timer_lock;\n\tunsigned int poll_cnt;\n\tvoid (*poll_handler)(struct gameport *);\n\n\tstruct gameport *parent, *child;\n\n\tstruct gameport_driver *drv;\n\tstruct mutex drv_mutex;\t\t \n\n\tstruct device dev;\n\n\tstruct list_head node;\n};\n#define to_gameport_port(d)\tcontainer_of(d, struct gameport, dev)\n\nstruct gameport_driver {\n\tconst char *description;\n\n\tint (*connect)(struct gameport *, struct gameport_driver *drv);\n\tint (*reconnect)(struct gameport *);\n\tvoid (*disconnect)(struct gameport *);\n\n\tstruct device_driver driver;\n\n\tbool ignore;\n};\n#define to_gameport_driver(d)\tcontainer_of(d, struct gameport_driver, driver)\n\nint gameport_open(struct gameport *gameport, struct gameport_driver *drv, int mode);\nvoid gameport_close(struct gameport *gameport);\n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n\nvoid __gameport_register_port(struct gameport *gameport, struct module *owner);\n \n#define gameport_register_port(gameport) \\\n\t__gameport_register_port(gameport, THIS_MODULE)\n\nvoid gameport_unregister_port(struct gameport *gameport);\n\n__printf(2, 3)\nvoid gameport_set_phys(struct gameport *gameport, const char *fmt, ...);\n\n#else\n\nstatic inline void gameport_register_port(struct gameport *gameport)\n{\n\treturn;\n}\n\nstatic inline void gameport_unregister_port(struct gameport *gameport)\n{\n\treturn;\n}\n\nstatic inline __printf(2, 3)\nvoid gameport_set_phys(struct gameport *gameport, const char *fmt, ...)\n{\n\treturn;\n}\n\n#endif\n\nstatic inline struct gameport *gameport_allocate_port(void)\n{\n\tstruct gameport *gameport = kzalloc(sizeof(struct gameport), GFP_KERNEL);\n\n\treturn gameport;\n}\n\nstatic inline void gameport_free_port(struct gameport *gameport)\n{\n\tkfree(gameport);\n}\n\nstatic inline void gameport_set_name(struct gameport *gameport, const char *name)\n{\n\tstrscpy(gameport->name, name, sizeof(gameport->name));\n}\n\n \nstatic inline void *gameport_get_drvdata(struct gameport *gameport)\n{\n\treturn dev_get_drvdata(&gameport->dev);\n}\n\nstatic inline void gameport_set_drvdata(struct gameport *gameport, void *data)\n{\n\tdev_set_drvdata(&gameport->dev, data);\n}\n\n \nstatic inline int gameport_pin_driver(struct gameport *gameport)\n{\n\treturn mutex_lock_interruptible(&gameport->drv_mutex);\n}\n\nstatic inline void gameport_unpin_driver(struct gameport *gameport)\n{\n\tmutex_unlock(&gameport->drv_mutex);\n}\n\nint __must_check __gameport_register_driver(struct gameport_driver *drv,\n\t\t\t\tstruct module *owner, const char *mod_name);\n\n \n#define gameport_register_driver(drv) \\\n\t__gameport_register_driver(drv, THIS_MODULE, KBUILD_MODNAME)\n\nvoid gameport_unregister_driver(struct gameport_driver *drv);\n\n \n#define module_gameport_driver(__gameport_driver) \\\n\tmodule_driver(__gameport_driver, gameport_register_driver, \\\n\t\t       gameport_unregister_driver)\n\n\nstatic inline void gameport_trigger(struct gameport *gameport)\n{\n\tgameport->trigger(gameport);\n}\n\nstatic inline unsigned char gameport_read(struct gameport *gameport)\n{\n\treturn gameport->read(gameport);\n}\n\nstatic inline int gameport_cooked_read(struct gameport *gameport, int *axes, int *buttons)\n{\n\tif (gameport->cooked_read)\n\t\treturn gameport->cooked_read(gameport, axes, buttons);\n\telse\n\t\treturn -1;\n}\n\nstatic inline int gameport_calibrate(struct gameport *gameport, int *axes, int *max)\n{\n\tif (gameport->calibrate)\n\t\treturn gameport->calibrate(gameport, axes, max);\n\telse\n\t\treturn -1;\n}\n\nstatic inline int gameport_time(struct gameport *gameport, int time)\n{\n\treturn (time * gameport->speed) / 1000;\n}\n\nstatic inline void gameport_set_poll_handler(struct gameport *gameport, void (*handler)(struct gameport *))\n{\n\tgameport->poll_handler = handler;\n}\n\nstatic inline void gameport_set_poll_interval(struct gameport *gameport, unsigned int msecs)\n{\n\tgameport->poll_interval = msecs;\n}\n\nvoid gameport_start_polling(struct gameport *gameport);\nvoid gameport_stop_polling(struct gameport *gameport);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}