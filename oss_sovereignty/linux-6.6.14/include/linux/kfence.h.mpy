{
  "module_name": "kfence.h",
  "hash_id": "9215dd7fb9122cb4a8b89a9f3264eb2b47781e66b095264d752a0df5ed530bc4",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/kfence.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_KFENCE_H\n#define _LINUX_KFENCE_H\n\n#include <linux/mm.h>\n#include <linux/types.h>\n\n#ifdef CONFIG_KFENCE\n\n#include <linux/atomic.h>\n#include <linux/static_key.h>\n\nextern unsigned long kfence_sample_interval;\n\n \n#define KFENCE_POOL_SIZE ((CONFIG_KFENCE_NUM_OBJECTS + 1) * 2 * PAGE_SIZE)\nextern char *__kfence_pool;\n\nDECLARE_STATIC_KEY_FALSE(kfence_allocation_key);\nextern atomic_t kfence_allocation_gate;\n\n \nstatic __always_inline bool is_kfence_address(const void *addr)\n{\n\t \n\treturn unlikely((unsigned long)((char *)addr - __kfence_pool) < KFENCE_POOL_SIZE && __kfence_pool);\n}\n\n \nvoid __init kfence_alloc_pool_and_metadata(void);\n\n \nvoid __init kfence_init(void);\n\n \nvoid kfence_shutdown_cache(struct kmem_cache *s);\n\n \nvoid *__kfence_alloc(struct kmem_cache *s, size_t size, gfp_t flags);\n\n \nstatic __always_inline void *kfence_alloc(struct kmem_cache *s, size_t size, gfp_t flags)\n{\n#if defined(CONFIG_KFENCE_STATIC_KEYS) || CONFIG_KFENCE_SAMPLE_INTERVAL == 0\n\tif (!static_branch_unlikely(&kfence_allocation_key))\n\t\treturn NULL;\n#else\n\tif (!static_branch_likely(&kfence_allocation_key))\n\t\treturn NULL;\n#endif\n\tif (likely(atomic_read(&kfence_allocation_gate)))\n\t\treturn NULL;\n\treturn __kfence_alloc(s, size, flags);\n}\n\n \nsize_t kfence_ksize(const void *addr);\n\n \nvoid *kfence_object_start(const void *addr);\n\n \nvoid __kfence_free(void *addr);\n\n \nstatic __always_inline __must_check bool kfence_free(void *addr)\n{\n\tif (!is_kfence_address(addr))\n\t\treturn false;\n\t__kfence_free(addr);\n\treturn true;\n}\n\n \nbool __must_check kfence_handle_page_fault(unsigned long addr, bool is_write, struct pt_regs *regs);\n\n#ifdef CONFIG_PRINTK\nstruct kmem_obj_info;\n \nbool __kfence_obj_info(struct kmem_obj_info *kpp, void *object, struct slab *slab);\n#endif\n\n#else  \n\nstatic inline bool is_kfence_address(const void *addr) { return false; }\nstatic inline void kfence_alloc_pool_and_metadata(void) { }\nstatic inline void kfence_init(void) { }\nstatic inline void kfence_shutdown_cache(struct kmem_cache *s) { }\nstatic inline void *kfence_alloc(struct kmem_cache *s, size_t size, gfp_t flags) { return NULL; }\nstatic inline size_t kfence_ksize(const void *addr) { return 0; }\nstatic inline void *kfence_object_start(const void *addr) { return NULL; }\nstatic inline void __kfence_free(void *addr) { }\nstatic inline bool __must_check kfence_free(void *addr) { return false; }\nstatic inline bool __must_check kfence_handle_page_fault(unsigned long addr, bool is_write,\n\t\t\t\t\t\t\t struct pt_regs *regs)\n{\n\treturn false;\n}\n\n#ifdef CONFIG_PRINTK\nstruct kmem_obj_info;\nstatic inline bool __kfence_obj_info(struct kmem_obj_info *kpp, void *object, struct slab *slab)\n{\n\treturn false;\n}\n#endif\n\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}