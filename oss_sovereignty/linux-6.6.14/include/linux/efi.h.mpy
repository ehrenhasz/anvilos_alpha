{
  "module_name": "efi.h",
  "hash_id": "67019dcf321da7e10f4d6939e9affb32b873abdd5f143bb43bff5ed84b723f5a",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/efi.h",
  "human_readable_source": " \n#ifndef _LINUX_EFI_H\n#define _LINUX_EFI_H\n\n \n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/types.h>\n#include <linux/proc_fs.h>\n#include <linux/rtc.h>\n#include <linux/ioport.h>\n#include <linux/pfn.h>\n#include <linux/pstore.h>\n#include <linux/range.h>\n#include <linux/reboot.h>\n#include <linux/uuid.h>\n\n#include <asm/page.h>\n\nstruct screen_info;\n\n#define EFI_SUCCESS\t\t0\n#define EFI_LOAD_ERROR\t\t( 1 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_INVALID_PARAMETER\t( 2 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_UNSUPPORTED\t\t( 3 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_BAD_BUFFER_SIZE\t( 4 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_BUFFER_TOO_SMALL\t( 5 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_NOT_READY\t\t( 6 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_DEVICE_ERROR\t( 7 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_WRITE_PROTECTED\t( 8 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_OUT_OF_RESOURCES\t( 9 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_NOT_FOUND\t\t(14 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_TIMEOUT\t\t(18 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_ABORTED\t\t(21 | (1UL << (BITS_PER_LONG-1)))\n#define EFI_SECURITY_VIOLATION\t(26 | (1UL << (BITS_PER_LONG-1)))\n\ntypedef unsigned long efi_status_t;\ntypedef u8 efi_bool_t;\ntypedef u16 efi_char16_t;\t\t \ntypedef u64 efi_physical_addr_t;\ntypedef void *efi_handle_t;\n\n#if defined(CONFIG_X86_64)\n#define __efiapi __attribute__((ms_abi))\n#elif defined(CONFIG_X86_32)\n#define __efiapi __attribute__((regparm(0)))\n#else\n#define __efiapi\n#endif\n\n \ntypedef guid_t efi_guid_t __aligned(__alignof__(u32));\n\n#define EFI_GUID(a, b, c, d...) (efi_guid_t){ {\t\t\t\t\t\\\n\t(a) & 0xff, ((a) >> 8) & 0xff, ((a) >> 16) & 0xff, ((a) >> 24) & 0xff,\t\\\n\t(b) & 0xff, ((b) >> 8) & 0xff,\t\t\t\t\t\t\\\n\t(c) & 0xff, ((c) >> 8) & 0xff, d } }\n\n \ntypedef\tstruct {\n\tu64 signature;\n\tu32 revision;\n\tu32 headersize;\n\tu32 crc32;\n\tu32 reserved;\n} efi_table_hdr_t;\n\n \n\n \n#define EFI_RESERVED_TYPE\t\t 0\n#define EFI_LOADER_CODE\t\t\t 1\n#define EFI_LOADER_DATA\t\t\t 2\n#define EFI_BOOT_SERVICES_CODE\t\t 3\n#define EFI_BOOT_SERVICES_DATA\t\t 4\n#define EFI_RUNTIME_SERVICES_CODE\t 5\n#define EFI_RUNTIME_SERVICES_DATA\t 6\n#define EFI_CONVENTIONAL_MEMORY\t\t 7\n#define EFI_UNUSABLE_MEMORY\t\t 8\n#define EFI_ACPI_RECLAIM_MEMORY\t\t 9\n#define EFI_ACPI_MEMORY_NVS\t\t10\n#define EFI_MEMORY_MAPPED_IO\t\t11\n#define EFI_MEMORY_MAPPED_IO_PORT_SPACE\t12\n#define EFI_PAL_CODE\t\t\t13\n#define EFI_PERSISTENT_MEMORY\t\t14\n#define EFI_UNACCEPTED_MEMORY\t\t15\n#define EFI_MAX_MEMORY_TYPE\t\t16\n\n \n#define EFI_MEMORY_UC\t\t((u64)0x0000000000000001ULL)\t \n#define EFI_MEMORY_WC\t\t((u64)0x0000000000000002ULL)\t \n#define EFI_MEMORY_WT\t\t((u64)0x0000000000000004ULL)\t \n#define EFI_MEMORY_WB\t\t((u64)0x0000000000000008ULL)\t \n#define EFI_MEMORY_UCE\t\t((u64)0x0000000000000010ULL)\t \n#define EFI_MEMORY_WP\t\t((u64)0x0000000000001000ULL)\t \n#define EFI_MEMORY_RP\t\t((u64)0x0000000000002000ULL)\t \n#define EFI_MEMORY_XP\t\t((u64)0x0000000000004000ULL)\t \n#define EFI_MEMORY_NV\t\t((u64)0x0000000000008000ULL)\t \n#define EFI_MEMORY_MORE_RELIABLE \\\n\t\t\t\t((u64)0x0000000000010000ULL)\t \n#define EFI_MEMORY_RO\t\t((u64)0x0000000000020000ULL)\t \n#define EFI_MEMORY_SP\t\t((u64)0x0000000000040000ULL)\t \n#define EFI_MEMORY_CPU_CRYPTO\t((u64)0x0000000000080000ULL)\t \n#define EFI_MEMORY_RUNTIME\t((u64)0x8000000000000000ULL)\t \n#define EFI_MEMORY_DESCRIPTOR_VERSION\t1\n\n#define EFI_PAGE_SHIFT\t\t12\n#define EFI_PAGE_SIZE\t\t(1UL << EFI_PAGE_SHIFT)\n#define EFI_PAGES_MAX\t\t(U64_MAX >> EFI_PAGE_SHIFT)\n\ntypedef struct {\n\tu32 type;\n\tu32 pad;\n\tu64 phys_addr;\n\tu64 virt_addr;\n\tu64 num_pages;\n\tu64 attribute;\n} efi_memory_desc_t;\n\ntypedef struct {\n\tefi_guid_t guid;\n\tu32 headersize;\n\tu32 flags;\n\tu32 imagesize;\n} efi_capsule_header_t;\n\n \nstruct efi_manage_capsule_header {\n\tu32 ver;\n\tu16 emb_drv_cnt;\n\tu16 payload_cnt;\n\t \n\tu64 offset_list[];\n} __packed;\n\n \nstruct efi_manage_capsule_image_header {\n\tu32 ver;\n\tefi_guid_t image_type_id;\n\tu8 image_index;\n\tu8 reserved_bytes[3];\n\tu32 image_size;\n\tu32 vendor_code_size;\n\t \n\tu64 hw_ins;\n\t \n\tu64 capsule_support;\n} __packed;\n\n \nstruct win_cert {\n\tu32 len;\n\tu16 rev;\n\tu16 cert_type;\n};\n\n \nstruct win_cert_uefi_guid {\n\tstruct win_cert\thdr;\n\tefi_guid_t cert_type;\n\tu8 cert_data[];\n};\n\n \nstruct efi_image_auth {\n\tu64 mon_count;\n\tstruct win_cert_uefi_guid auth_info;\n};\n\n \n#define EFI_CAPSULE_PERSIST_ACROSS_RESET\t0x00010000\n#define EFI_CAPSULE_POPULATE_SYSTEM_TABLE\t0x00020000\n#define EFI_CAPSULE_INITIATE_RESET\t\t0x00040000\n\nstruct capsule_info {\n\tefi_capsule_header_t\theader;\n\tefi_capsule_header_t\t*capsule;\n\tint\t\t\treset_type;\n\tlong\t\t\tindex;\n\tsize_t\t\t\tcount;\n\tsize_t\t\t\ttotal_size;\n\tstruct page\t\t**pages;\n\tphys_addr_t\t\t*phys;\n\tsize_t\t\t\tpage_bytes_remain;\n};\n\nint efi_capsule_setup_info(struct capsule_info *cap_info, void *kbuff,\n                           size_t hdr_bytes);\nint __efi_capsule_setup_info(struct capsule_info *cap_info);\n\n \n#define EFI_TIME_ADJUST_DAYLIGHT 0x1\n#define EFI_TIME_IN_DAYLIGHT     0x2\n#define EFI_UNSPECIFIED_TIMEZONE 0x07ff\n\ntypedef struct {\n\tu16 year;\n\tu8 month;\n\tu8 day;\n\tu8 hour;\n\tu8 minute;\n\tu8 second;\n\tu8 pad1;\n\tu32 nanosecond;\n\ts16 timezone;\n\tu8 daylight;\n\tu8 pad2;\n} efi_time_t;\n\ntypedef struct {\n\tu32 resolution;\n\tu32 accuracy;\n\tu8 sets_to_zero;\n} efi_time_cap_t;\n\ntypedef union efi_boot_services efi_boot_services_t;\n\n \n#define EFI_RESET_COLD 0\n#define EFI_RESET_WARM 1\n#define EFI_RESET_SHUTDOWN 2\n\n \n#define EFI_RUNTIME_SERVICES_SIGNATURE ((u64)0x5652453544e5552ULL)\n#define EFI_RUNTIME_SERVICES_REVISION  0x00010000\n\ntypedef struct {\n\tefi_table_hdr_t hdr;\n\tu32 get_time;\n\tu32 set_time;\n\tu32 get_wakeup_time;\n\tu32 set_wakeup_time;\n\tu32 set_virtual_address_map;\n\tu32 convert_pointer;\n\tu32 get_variable;\n\tu32 get_next_variable;\n\tu32 set_variable;\n\tu32 get_next_high_mono_count;\n\tu32 reset_system;\n\tu32 update_capsule;\n\tu32 query_capsule_caps;\n\tu32 query_variable_info;\n} efi_runtime_services_32_t;\n\ntypedef efi_status_t efi_get_time_t (efi_time_t *tm, efi_time_cap_t *tc);\ntypedef efi_status_t efi_set_time_t (efi_time_t *tm);\ntypedef efi_status_t efi_get_wakeup_time_t (efi_bool_t *enabled, efi_bool_t *pending,\n\t\t\t\t\t    efi_time_t *tm);\ntypedef efi_status_t efi_set_wakeup_time_t (efi_bool_t enabled, efi_time_t *tm);\ntypedef efi_status_t efi_get_variable_t (efi_char16_t *name, efi_guid_t *vendor, u32 *attr,\n\t\t\t\t\t unsigned long *data_size, void *data);\ntypedef efi_status_t efi_get_next_variable_t (unsigned long *name_size, efi_char16_t *name,\n\t\t\t\t\t      efi_guid_t *vendor);\ntypedef efi_status_t efi_set_variable_t (efi_char16_t *name, efi_guid_t *vendor, \n\t\t\t\t\t u32 attr, unsigned long data_size,\n\t\t\t\t\t void *data);\ntypedef efi_status_t efi_get_next_high_mono_count_t (u32 *count);\ntypedef void efi_reset_system_t (int reset_type, efi_status_t status,\n\t\t\t\t unsigned long data_size, efi_char16_t *data);\ntypedef efi_status_t efi_set_virtual_address_map_t (unsigned long memory_map_size,\n\t\t\t\t\t\tunsigned long descriptor_size,\n\t\t\t\t\t\tu32 descriptor_version,\n\t\t\t\t\t\tefi_memory_desc_t *virtual_map);\ntypedef efi_status_t efi_query_variable_info_t(u32 attr,\n\t\t\t\t\t       u64 *storage_space,\n\t\t\t\t\t       u64 *remaining_space,\n\t\t\t\t\t       u64 *max_variable_size);\ntypedef efi_status_t efi_update_capsule_t(efi_capsule_header_t **capsules,\n\t\t\t\t\t  unsigned long count,\n\t\t\t\t\t  unsigned long sg_list);\ntypedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **capsules,\n\t\t\t\t\t      unsigned long count,\n\t\t\t\t\t      u64 *max_size,\n\t\t\t\t\t      int *reset_type);\ntypedef efi_status_t efi_query_variable_store_t(u32 attributes,\n\t\t\t\t\t\tunsigned long size,\n\t\t\t\t\t\tbool nonblocking);\n\ntypedef union {\n\tstruct {\n\t\tefi_table_hdr_t\t\t\t\thdr;\n\t\tefi_get_time_t __efiapi\t\t\t*get_time;\n\t\tefi_set_time_t __efiapi\t\t\t*set_time;\n\t\tefi_get_wakeup_time_t __efiapi\t\t*get_wakeup_time;\n\t\tefi_set_wakeup_time_t __efiapi\t\t*set_wakeup_time;\n\t\tefi_set_virtual_address_map_t __efiapi\t*set_virtual_address_map;\n\t\tvoid\t\t\t\t\t*convert_pointer;\n\t\tefi_get_variable_t __efiapi\t\t*get_variable;\n\t\tefi_get_next_variable_t __efiapi\t*get_next_variable;\n\t\tefi_set_variable_t __efiapi\t\t*set_variable;\n\t\tefi_get_next_high_mono_count_t __efiapi\t*get_next_high_mono_count;\n\t\tefi_reset_system_t __efiapi\t\t*reset_system;\n\t\tefi_update_capsule_t __efiapi\t\t*update_capsule;\n\t\tefi_query_capsule_caps_t __efiapi\t*query_capsule_caps;\n\t\tefi_query_variable_info_t __efiapi\t*query_variable_info;\n\t};\n\tefi_runtime_services_32_t mixed_mode;\n} efi_runtime_services_t;\n\nvoid efi_native_runtime_setup(void);\n\n \n#define NULL_GUID\t\t\t\tEFI_GUID(0x00000000, 0x0000, 0x0000,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)\n#define MPS_TABLE_GUID\t\t\t\tEFI_GUID(0xeb9d2d2f, 0x2d88, 0x11d3,  0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)\n#define ACPI_TABLE_GUID\t\t\t\tEFI_GUID(0xeb9d2d30, 0x2d88, 0x11d3,  0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)\n#define ACPI_20_TABLE_GUID\t\t\tEFI_GUID(0x8868e871, 0xe4f1, 0x11d3,  0xbc, 0x22, 0x00, 0x80, 0xc7, 0x3c, 0x88, 0x81)\n#define SMBIOS_TABLE_GUID\t\t\tEFI_GUID(0xeb9d2d31, 0x2d88, 0x11d3,  0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)\n#define SMBIOS3_TABLE_GUID\t\t\tEFI_GUID(0xf2fd1544, 0x9794, 0x4a2c,  0x99, 0x2e, 0xe5, 0xbb, 0xcf, 0x20, 0xe3, 0x94)\n#define SAL_SYSTEM_TABLE_GUID\t\t\tEFI_GUID(0xeb9d2d32, 0x2d88, 0x11d3,  0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)\n#define HCDP_TABLE_GUID\t\t\t\tEFI_GUID(0xf951938d, 0x620b, 0x42ef,  0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98)\n#define UGA_IO_PROTOCOL_GUID\t\t\tEFI_GUID(0x61a4d49e, 0x6f68, 0x4f1b,  0xb9, 0x22, 0xa8, 0x6e, 0xed, 0x0b, 0x07, 0xa2)\n#define EFI_GLOBAL_VARIABLE_GUID\t\tEFI_GUID(0x8be4df61, 0x93ca, 0x11d2,  0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c)\n#define UV_SYSTEM_TABLE_GUID\t\t\tEFI_GUID(0x3b13a7d4, 0x633e, 0x11dd,  0x93, 0xec, 0xda, 0x25, 0x56, 0xd8, 0x95, 0x93)\n#define LINUX_EFI_CRASH_GUID\t\t\tEFI_GUID(0xcfc8fc79, 0xbe2e, 0x4ddc,  0x97, 0xf0, 0x9f, 0x98, 0xbf, 0xe2, 0x98, 0xa0)\n#define LOADED_IMAGE_PROTOCOL_GUID\t\tEFI_GUID(0x5b1b31a1, 0x9562, 0x11d2,  0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)\n#define LOADED_IMAGE_DEVICE_PATH_PROTOCOL_GUID\tEFI_GUID(0xbc62157e, 0x3e33, 0x4fec,  0x99, 0x20, 0x2d, 0x3b, 0x36, 0xd7, 0x50, 0xdf)\n#define EFI_DEVICE_PATH_PROTOCOL_GUID\t\tEFI_GUID(0x09576e91, 0x6d3f, 0x11d2,  0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)\n#define EFI_DEVICE_PATH_TO_TEXT_PROTOCOL_GUID\tEFI_GUID(0x8b843e20, 0x8132, 0x4852,  0x90, 0xcc, 0x55, 0x1a, 0x4e, 0x4a, 0x7f, 0x1c)\n#define EFI_DEVICE_PATH_FROM_TEXT_PROTOCOL_GUID\tEFI_GUID(0x05c99a21, 0xc70f, 0x4ad2,  0x8a, 0x5f, 0x35, 0xdf, 0x33, 0x43, 0xf5, 0x1e)\n#define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID\tEFI_GUID(0x9042a9de, 0x23dc, 0x4a38,  0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a)\n#define EFI_UGA_PROTOCOL_GUID\t\t\tEFI_GUID(0x982c298b, 0xf4fa, 0x41cb,  0xb8, 0x38, 0x77, 0xaa, 0x68, 0x8f, 0xb8, 0x39)\n#define EFI_PCI_IO_PROTOCOL_GUID\t\tEFI_GUID(0x4cf5b200, 0x68b8, 0x4ca5,  0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x02, 0x9a)\n#define EFI_FILE_INFO_ID\t\t\tEFI_GUID(0x09576e92, 0x6d3f, 0x11d2,  0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)\n#define EFI_SYSTEM_RESOURCE_TABLE_GUID\t\tEFI_GUID(0xb122a263, 0x3661, 0x4f68,  0x99, 0x29, 0x78, 0xf8, 0xb0, 0xd6, 0x21, 0x80)\n#define EFI_FILE_SYSTEM_GUID\t\t\tEFI_GUID(0x964e5b22, 0x6459, 0x11d2,  0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)\n#define DEVICE_TREE_GUID\t\t\tEFI_GUID(0xb1b621d5, 0xf19c, 0x41a5,  0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0)\n#define EFI_PROPERTIES_TABLE_GUID\t\tEFI_GUID(0x880aaca3, 0x4adc, 0x4a04,  0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5)\n#define EFI_RNG_PROTOCOL_GUID\t\t\tEFI_GUID(0x3152bca5, 0xeade, 0x433d,  0x86, 0x2e, 0xc0, 0x1c, 0xdc, 0x29, 0x1f, 0x44)\n#define EFI_RNG_ALGORITHM_RAW\t\t\tEFI_GUID(0xe43176d7, 0xb6e8, 0x4827,  0xb7, 0x84, 0x7f, 0xfd, 0xc4, 0xb6, 0x85, 0x61)\n#define EFI_MEMORY_ATTRIBUTES_TABLE_GUID\tEFI_GUID(0xdcfa911d, 0x26eb, 0x469f,  0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20)\n#define EFI_CONSOLE_OUT_DEVICE_GUID\t\tEFI_GUID(0xd3b36f2c, 0xd551, 0x11d4,  0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)\n#define APPLE_PROPERTIES_PROTOCOL_GUID\t\tEFI_GUID(0x91bd12fe, 0xf6c3, 0x44fb,  0xa5, 0xb7, 0x51, 0x22, 0xab, 0x30, 0x3a, 0xe0)\n#define EFI_TCG2_PROTOCOL_GUID\t\t\tEFI_GUID(0x607f766c, 0x7455, 0x42be,  0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f)\n#define EFI_LOAD_FILE_PROTOCOL_GUID\t\tEFI_GUID(0x56ec3091, 0x954c, 0x11d2,  0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)\n#define EFI_LOAD_FILE2_PROTOCOL_GUID\t\tEFI_GUID(0x4006c0c1, 0xfcb3, 0x403e,  0x99, 0x6d, 0x4a, 0x6c, 0x87, 0x24, 0xe0, 0x6d)\n#define EFI_RT_PROPERTIES_TABLE_GUID\t\tEFI_GUID(0xeb66918a, 0x7eef, 0x402a,  0x84, 0x2e, 0x93, 0x1d, 0x21, 0xc3, 0x8a, 0xe9)\n#define EFI_DXE_SERVICES_TABLE_GUID\t\tEFI_GUID(0x05ad34ba, 0x6f02, 0x4214,  0x95, 0x2e, 0x4d, 0xa0, 0x39, 0x8e, 0x2b, 0xb9)\n#define EFI_SMBIOS_PROTOCOL_GUID\t\tEFI_GUID(0x03583ff6, 0xcb36, 0x4940,  0x94, 0x7e, 0xb9, 0xb3, 0x9f, 0x4a, 0xfa, 0xf7)\n#define EFI_MEMORY_ATTRIBUTE_PROTOCOL_GUID\tEFI_GUID(0xf4560cf6, 0x40ec, 0x4b4a,  0xa1, 0x92, 0xbf, 0x1d, 0x57, 0xd0, 0xb1, 0x89)\n\n#define EFI_IMAGE_SECURITY_DATABASE_GUID\tEFI_GUID(0xd719b2cb, 0x3d3a, 0x4596,  0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f)\n#define EFI_SHIM_LOCK_GUID\t\t\tEFI_GUID(0x605dab50, 0xe046, 0x4300,  0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23)\n\n#define EFI_CERT_SHA256_GUID\t\t\tEFI_GUID(0xc1c41626, 0x504c, 0x4092, 0xac, 0xa9, 0x41, 0xf9, 0x36, 0x93, 0x43, 0x28)\n#define EFI_CERT_X509_GUID\t\t\tEFI_GUID(0xa5c059a1, 0x94e4, 0x4aa7, 0x87, 0xb5, 0xab, 0x15, 0x5c, 0x2b, 0xf0, 0x72)\n#define EFI_CERT_X509_SHA256_GUID\t\tEFI_GUID(0x3bd2a492, 0x96c0, 0x4079, 0xb4, 0x20, 0xfc, 0xf9, 0x8e, 0xf1, 0x03, 0xed)\n#define EFI_CC_BLOB_GUID\t\t\tEFI_GUID(0x067b1f5f, 0xcf26, 0x44c5, 0x85, 0x54, 0x93, 0xd7, 0x77, 0x91, 0x2d, 0x42)\n\n \n#define LINUX_EFI_SCREEN_INFO_TABLE_GUID\tEFI_GUID(0xe03fc20a, 0x85dc, 0x406e,  0xb9, 0x0e, 0x4a, 0xb5, 0x02, 0x37, 0x1d, 0x95)\n#define LINUX_EFI_ARM_CPU_STATE_TABLE_GUID\tEFI_GUID(0xef79e4aa, 0x3c3d, 0x4989,  0xb9, 0x02, 0x07, 0xa9, 0x43, 0xe5, 0x50, 0xd2)\n#define LINUX_EFI_LOADER_ENTRY_GUID\t\tEFI_GUID(0x4a67b082, 0x0a4c, 0x41cf,  0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)\n#define LINUX_EFI_RANDOM_SEED_TABLE_GUID\tEFI_GUID(0x1ce1e5bc, 0x7ceb, 0x42f2,  0x81, 0xe5, 0x8a, 0xad, 0xf1, 0x80, 0xf5, 0x7b)\n#define LINUX_EFI_TPM_EVENT_LOG_GUID\t\tEFI_GUID(0xb7799cb0, 0xeca2, 0x4943,  0x96, 0x67, 0x1f, 0xae, 0x07, 0xb7, 0x47, 0xfa)\n#define LINUX_EFI_TPM_FINAL_LOG_GUID\t\tEFI_GUID(0x1e2ed096, 0x30e2, 0x4254,  0xbd, 0x89, 0x86, 0x3b, 0xbe, 0xf8, 0x23, 0x25)\n#define LINUX_EFI_MEMRESERVE_TABLE_GUID\t\tEFI_GUID(0x888eb0c6, 0x8ede, 0x4ff5,  0xa8, 0xf0, 0x9a, 0xee, 0x5c, 0xb9, 0x77, 0xc2)\n#define LINUX_EFI_INITRD_MEDIA_GUID\t\tEFI_GUID(0x5568e427, 0x68fc, 0x4f3d,  0xac, 0x74, 0xca, 0x55, 0x52, 0x31, 0xcc, 0x68)\n#define LINUX_EFI_MOK_VARIABLE_TABLE_GUID\tEFI_GUID(0xc451ed2b, 0x9694, 0x45d3,  0xba, 0xba, 0xed, 0x9f, 0x89, 0x88, 0xa3, 0x89)\n#define LINUX_EFI_COCO_SECRET_AREA_GUID\t\tEFI_GUID(0xadf956ad, 0xe98c, 0x484c,  0xae, 0x11, 0xb5, 0x1c, 0x7d, 0x33, 0x64, 0x47)\n#define LINUX_EFI_BOOT_MEMMAP_GUID\t\tEFI_GUID(0x800f683f, 0xd08b, 0x423a,  0xa2, 0x93, 0x96, 0x5c, 0x3c, 0x6f, 0xe2, 0xb4)\n#define LINUX_EFI_UNACCEPTED_MEM_TABLE_GUID\tEFI_GUID(0xd5d1de3c, 0x105c, 0x44f9,  0x9e, 0xa9, 0xbc, 0xef, 0x98, 0x12, 0x00, 0x31)\n\n#define RISCV_EFI_BOOT_PROTOCOL_GUID\t\tEFI_GUID(0xccd15fec, 0x6f73, 0x4eec,  0x83, 0x95, 0x3e, 0x69, 0xe4, 0xb9, 0x40, 0xbf)\n\n \n#define LINUX_EFI_LOADED_IMAGE_FIXED_GUID\tEFI_GUID(0xf5a37b6d, 0x3344, 0x42a5,  0xb6, 0xbb, 0x97, 0x86, 0x48, 0xc1, 0x89, 0x0a)\n\n \n#define DELLEMC_EFI_RCI2_TABLE_GUID\t\tEFI_GUID(0x2d9f28a2, 0xa886, 0x456a,  0x97, 0xa8, 0xf1, 0x1e, 0xf2, 0x4f, 0xf4, 0x55)\n#define AMD_SEV_MEM_ENCRYPT_GUID\t\tEFI_GUID(0x0cf29b71, 0x9e51, 0x433a,  0xa3, 0xb7, 0x81, 0xf3, 0xab, 0x16, 0xb8, 0x75)\n\n \n#define OVMF_SEV_MEMORY_ACCEPTANCE_PROTOCOL_GUID\tEFI_GUID(0xc5a010fe, 0x38a7, 0x4531,  0x8a, 0x4a, 0x05, 0x00, 0xd2, 0xfd, 0x16, 0x49)\n\ntypedef struct {\n\tefi_guid_t guid;\n\tu64 table;\n} efi_config_table_64_t;\n\ntypedef struct {\n\tefi_guid_t guid;\n\tu32 table;\n} efi_config_table_32_t;\n\ntypedef union {\n\tstruct {\n\t\tefi_guid_t guid;\n\t\tvoid *table;\n\t};\n\tefi_config_table_32_t mixed_mode;\n} efi_config_table_t;\n\ntypedef struct {\n\tefi_guid_t guid;\n\tunsigned long *ptr;\n\tconst char name[16];\n} efi_config_table_type_t;\n\n#define EFI_SYSTEM_TABLE_SIGNATURE ((u64)0x5453595320494249ULL)\n#define EFI_DXE_SERVICES_TABLE_SIGNATURE ((u64)0x565245535f455844ULL)\n\n#define EFI_2_30_SYSTEM_TABLE_REVISION  ((2 << 16) | (30))\n#define EFI_2_20_SYSTEM_TABLE_REVISION  ((2 << 16) | (20))\n#define EFI_2_10_SYSTEM_TABLE_REVISION  ((2 << 16) | (10))\n#define EFI_2_00_SYSTEM_TABLE_REVISION  ((2 << 16) | (00))\n#define EFI_1_10_SYSTEM_TABLE_REVISION  ((1 << 16) | (10))\n#define EFI_1_02_SYSTEM_TABLE_REVISION  ((1 << 16) | (02))\n\ntypedef struct {\n\tefi_table_hdr_t hdr;\n\tu64 fw_vendor;\t \n\tu32 fw_revision;\n\tu32 __pad1;\n\tu64 con_in_handle;\n\tu64 con_in;\n\tu64 con_out_handle;\n\tu64 con_out;\n\tu64 stderr_handle;\n\tu64 stderr;\n\tu64 runtime;\n\tu64 boottime;\n\tu32 nr_tables;\n\tu32 __pad2;\n\tu64 tables;\n} efi_system_table_64_t;\n\ntypedef struct {\n\tefi_table_hdr_t hdr;\n\tu32 fw_vendor;\t \n\tu32 fw_revision;\n\tu32 con_in_handle;\n\tu32 con_in;\n\tu32 con_out_handle;\n\tu32 con_out;\n\tu32 stderr_handle;\n\tu32 stderr;\n\tu32 runtime;\n\tu32 boottime;\n\tu32 nr_tables;\n\tu32 tables;\n} efi_system_table_32_t;\n\ntypedef union efi_simple_text_input_protocol efi_simple_text_input_protocol_t;\ntypedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;\n\ntypedef union {\n\tstruct {\n\t\tefi_table_hdr_t hdr;\n\t\tunsigned long fw_vendor;\t \n\t\tu32 fw_revision;\n\t\tunsigned long con_in_handle;\n\t\tefi_simple_text_input_protocol_t *con_in;\n\t\tunsigned long con_out_handle;\n\t\tefi_simple_text_output_protocol_t *con_out;\n\t\tunsigned long stderr_handle;\n\t\tunsigned long stderr;\n\t\tefi_runtime_services_t *runtime;\n\t\tefi_boot_services_t *boottime;\n\t\tunsigned long nr_tables;\n\t\tunsigned long tables;\n\t};\n\tefi_system_table_32_t mixed_mode;\n} efi_system_table_t;\n\nstruct efi_boot_memmap {\n\tunsigned long\t\tmap_size;\n\tunsigned long\t\tdesc_size;\n\tu32\t\t\tdesc_ver;\n\tunsigned long\t\tmap_key;\n\tunsigned long\t\tbuff_size;\n\tefi_memory_desc_t\tmap[];\n};\n\nstruct efi_unaccepted_memory {\n\tu32 version;\n\tu32 unit_size;\n\tu64 phys_base;\n\tu64 size;\n\tunsigned long bitmap[];\n};\n\n \nstruct efi_memory_map_data {\n\tphys_addr_t phys_map;\n\tunsigned long size;\n\tunsigned long desc_version;\n\tunsigned long desc_size;\n\tunsigned long flags;\n};\n\nstruct efi_memory_map {\n\tphys_addr_t phys_map;\n\tvoid *map;\n\tvoid *map_end;\n\tint nr_map;\n\tunsigned long desc_version;\n\tunsigned long desc_size;\n#define EFI_MEMMAP_LATE (1UL << 0)\n#define EFI_MEMMAP_MEMBLOCK (1UL << 1)\n#define EFI_MEMMAP_SLAB (1UL << 2)\n\tunsigned long flags;\n};\n\nstruct efi_mem_range {\n\tstruct range range;\n\tu64 attribute;\n};\n\ntypedef struct {\n\tu32 version;\n\tu32 length;\n\tu64 memory_protection_attribute;\n} efi_properties_table_t;\n\n#define EFI_PROPERTIES_TABLE_VERSION\t0x00010000\n#define EFI_PROPERTIES_RUNTIME_MEMORY_PROTECTION_NON_EXECUTABLE_PE_DATA\t0x1\n\ntypedef struct {\n\tu16 version;\n\tu16 length;\n\tu32 runtime_services_supported;\n} efi_rt_properties_table_t;\n\n#define EFI_RT_PROPERTIES_TABLE_VERSION\t0x1\n\n#define EFI_INVALID_TABLE_ADDR\t\t(~0UL)\n\n\n\n#define EFI_MEMORY_ATTRIBUTES_FLAGS_RT_FORWARD_CONTROL_FLOW_GUARD\t0x1\n\ntypedef struct {\n\tu32 version;\n\tu32 num_entries;\n\tu32 desc_size;\n\tu32 flags;\n\tefi_memory_desc_t entry[0];\n} efi_memory_attributes_table_t;\n\ntypedef struct {\n\tefi_guid_t signature_owner;\n\tu8 signature_data[];\n} efi_signature_data_t;\n\ntypedef struct {\n\tefi_guid_t signature_type;\n\tu32 signature_list_size;\n\tu32 signature_header_size;\n\tu32 signature_size;\n\tu8 signature_header[];\n\t \n} efi_signature_list_t;\n\ntypedef u8 efi_sha256_hash_t[32];\n\ntypedef struct {\n\tefi_sha256_hash_t to_be_signed_hash;\n\tefi_time_t time_of_revocation;\n} efi_cert_x509_sha256_t;\n\nextern unsigned long __ro_after_init efi_rng_seed;\t\t \n\n \nextern struct efi {\n\tconst efi_runtime_services_t\t*runtime;\t\t \n\tunsigned int\t\t\truntime_version;\t \n\tunsigned int\t\t\truntime_supported_mask;\n\n\tunsigned long\t\t\tacpi;\t\t\t \n\tunsigned long\t\t\tacpi20;\t\t\t \n\tunsigned long\t\t\tsmbios;\t\t\t \n\tunsigned long\t\t\tsmbios3;\t\t \n\tunsigned long\t\t\tesrt;\t\t\t \n\tunsigned long\t\t\ttpm_log;\t\t \n\tunsigned long\t\t\ttpm_final_log;\t\t \n\tunsigned long\t\t\tmokvar_table;\t\t \n\tunsigned long\t\t\tcoco_secret;\t\t \n\tunsigned long\t\t\tunaccepted;\t\t \n\n\tefi_get_time_t\t\t\t*get_time;\n\tefi_set_time_t\t\t\t*set_time;\n\tefi_get_wakeup_time_t\t\t*get_wakeup_time;\n\tefi_set_wakeup_time_t\t\t*set_wakeup_time;\n\tefi_get_variable_t\t\t*get_variable;\n\tefi_get_next_variable_t\t\t*get_next_variable;\n\tefi_set_variable_t\t\t*set_variable;\n\tefi_set_variable_t\t\t*set_variable_nonblocking;\n\tefi_query_variable_info_t\t*query_variable_info;\n\tefi_query_variable_info_t\t*query_variable_info_nonblocking;\n\tefi_update_capsule_t\t\t*update_capsule;\n\tefi_query_capsule_caps_t\t*query_capsule_caps;\n\tefi_get_next_high_mono_count_t\t*get_next_high_mono_count;\n\tefi_reset_system_t\t\t*reset_system;\n\n\tstruct efi_memory_map\t\tmemmap;\n\tunsigned long\t\t\tflags;\n} efi;\n\n#define EFI_RT_SUPPORTED_GET_TIME\t\t\t\t0x0001\n#define EFI_RT_SUPPORTED_SET_TIME\t\t\t\t0x0002\n#define EFI_RT_SUPPORTED_GET_WAKEUP_TIME\t\t\t0x0004\n#define EFI_RT_SUPPORTED_SET_WAKEUP_TIME\t\t\t0x0008\n#define EFI_RT_SUPPORTED_GET_VARIABLE\t\t\t\t0x0010\n#define EFI_RT_SUPPORTED_GET_NEXT_VARIABLE_NAME\t\t\t0x0020\n#define EFI_RT_SUPPORTED_SET_VARIABLE\t\t\t\t0x0040\n#define EFI_RT_SUPPORTED_SET_VIRTUAL_ADDRESS_MAP\t\t0x0080\n#define EFI_RT_SUPPORTED_CONVERT_POINTER\t\t\t0x0100\n#define EFI_RT_SUPPORTED_GET_NEXT_HIGH_MONOTONIC_COUNT\t\t0x0200\n#define EFI_RT_SUPPORTED_RESET_SYSTEM\t\t\t\t0x0400\n#define EFI_RT_SUPPORTED_UPDATE_CAPSULE\t\t\t\t0x0800\n#define EFI_RT_SUPPORTED_QUERY_CAPSULE_CAPABILITIES\t\t0x1000\n#define EFI_RT_SUPPORTED_QUERY_VARIABLE_INFO\t\t\t0x2000\n\n#define EFI_RT_SUPPORTED_ALL\t\t\t\t\t0x3fff\n\n#define EFI_RT_SUPPORTED_TIME_SERVICES\t\t\t\t0x0003\n#define EFI_RT_SUPPORTED_WAKEUP_SERVICES\t\t\t0x000c\n#define EFI_RT_SUPPORTED_VARIABLE_SERVICES\t\t\t0x0070\n\nextern struct mm_struct efi_mm;\n\nstatic inline int\nefi_guidcmp (efi_guid_t left, efi_guid_t right)\n{\n\treturn memcmp(&left, &right, sizeof (efi_guid_t));\n}\n\nstatic inline char *\nefi_guid_to_str(efi_guid_t *guid, char *out)\n{\n\tsprintf(out, \"%pUl\", guid->b);\n        return out;\n}\n\nextern void efi_init (void);\nextern void efi_earlycon_reprobe(void);\n#ifdef CONFIG_EFI\nextern void efi_enter_virtual_mode (void);\t \n#else\nstatic inline void efi_enter_virtual_mode (void) {}\n#endif\n#ifdef CONFIG_X86\nextern efi_status_t efi_query_variable_store(u32 attributes,\n\t\t\t\t\t     unsigned long size,\n\t\t\t\t\t     bool nonblocking);\n#else\n\nstatic inline efi_status_t efi_query_variable_store(u32 attributes,\n\t\t\t\t\t\t    unsigned long size,\n\t\t\t\t\t\t    bool nonblocking)\n{\n\treturn EFI_SUCCESS;\n}\n#endif\n\nextern int __init __efi_memmap_init(struct efi_memory_map_data *data);\nextern int __init efi_memmap_init_early(struct efi_memory_map_data *data);\nextern int __init efi_memmap_init_late(phys_addr_t addr, unsigned long size);\nextern void __init efi_memmap_unmap(void);\n\n#ifdef CONFIG_EFI_ESRT\nextern void __init efi_esrt_init(void);\n#else\nstatic inline void efi_esrt_init(void) { }\n#endif\nextern int efi_config_parse_tables(const efi_config_table_t *config_tables,\n\t\t\t\t   int count,\n\t\t\t\t   const efi_config_table_type_t *arch_tables);\nextern int efi_systab_check_header(const efi_table_hdr_t *systab_hdr);\nextern void efi_systab_report_header(const efi_table_hdr_t *systab_hdr,\n\t\t\t\t     unsigned long fw_vendor);\nextern u64 efi_get_iobase (void);\nextern int efi_mem_type(unsigned long phys_addr);\nextern u64 efi_mem_attributes (unsigned long phys_addr);\nextern u64 efi_mem_attribute (unsigned long phys_addr, unsigned long size);\nextern int __init efi_uart_console_only (void);\nextern u64 efi_mem_desc_end(efi_memory_desc_t *md);\nextern int efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md);\nextern int __efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md);\nextern void efi_mem_reserve(phys_addr_t addr, u64 size);\nextern int efi_mem_reserve_persistent(phys_addr_t addr, u64 size);\nextern void efi_initialize_iomem_resources(struct resource *code_resource,\n\t\tstruct resource *data_resource, struct resource *bss_resource);\nextern u64 efi_get_fdt_params(struct efi_memory_map_data *data);\nextern struct kobject *efi_kobj;\n\nextern int efi_reboot_quirk_mode;\nextern bool efi_poweroff_required(void);\n\nextern unsigned long efi_mem_attr_table;\n\n \ntypedef int (*efi_memattr_perm_setter)(struct mm_struct *, efi_memory_desc_t *, bool);\n\nextern int efi_memattr_init(void);\nextern int efi_memattr_apply_permissions(struct mm_struct *mm,\n\t\t\t\t\t efi_memattr_perm_setter fn);\n\n \n#define efi_early_memdesc_ptr(map, desc_size, n)\t\t\t\\\n\t(efi_memory_desc_t *)((void *)(map) + ((n) * (desc_size)))\n\n \n#define for_each_efi_memory_desc_in_map(m, md)\t\t\t\t   \\\n\tfor ((md) = (m)->map;\t\t\t\t\t\t   \\\n\t     (md) && ((void *)(md) + (m)->desc_size) <= (m)->map_end;\t   \\\n\t     (md) = (void *)(md) + (m)->desc_size)\n\n \n#define for_each_efi_memory_desc(md) \\\n\tfor_each_efi_memory_desc_in_map(&efi.memmap, md)\n\n \nchar * __init efi_md_typeattr_format(char *buf, size_t size,\n\t\t\t\t     const efi_memory_desc_t *md);\n\n\ntypedef void (*efi_element_handler_t)(const char *source,\n\t\t\t\t      const void *element_data,\n\t\t\t\t      size_t element_size);\nextern int __init parse_efi_signature_list(\n\tconst char *source,\n\tconst void *data, size_t size,\n\tefi_element_handler_t (*get_handler_for_guid)(const efi_guid_t *));\n\n \nstatic inline int efi_range_is_wc(unsigned long start, unsigned long len)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < len; i += (1UL << EFI_PAGE_SHIFT)) {\n\t\tunsigned long paddr = __pa(start + i);\n\t\tif (!(efi_mem_attributes(paddr) & EFI_MEMORY_WC))\n\t\t\treturn 0;\n\t}\n\t \n\treturn 1;\n}\n\n#ifdef CONFIG_EFI_PCDP\nextern int __init efi_setup_pcdp_console(char *);\n#endif\n\n \n#define EFI_BOOT\t\t0\t \n#define EFI_CONFIG_TABLES\t2\t \n#define EFI_RUNTIME_SERVICES\t3\t \n#define EFI_MEMMAP\t\t4\t \n#define EFI_64BIT\t\t5\t \n#define EFI_PARAVIRT\t\t6\t \n#define EFI_ARCH_1\t\t7\t \n#define EFI_DBG\t\t\t8\t \n#define EFI_NX_PE_DATA\t\t9\t \n#define EFI_MEM_ATTR\t\t10\t \n#define EFI_MEM_NO_SOFT_RESERVE\t11\t \n#define EFI_PRESERVE_BS_REGIONS\t12\t \n\n#ifdef CONFIG_EFI\n \nstatic inline bool efi_enabled(int feature)\n{\n\treturn test_bit(feature, &efi.flags) != 0;\n}\nextern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);\n\nbool __pure __efi_soft_reserve_enabled(void);\n\nstatic inline bool __pure efi_soft_reserve_enabled(void)\n{\n\treturn IS_ENABLED(CONFIG_EFI_SOFT_RESERVE)\n\t\t&& __efi_soft_reserve_enabled();\n}\n\nstatic inline bool efi_rt_services_supported(unsigned int mask)\n{\n\treturn (efi.runtime_supported_mask & mask) == mask;\n}\nextern void efi_find_mirror(void);\n#else\nstatic inline bool efi_enabled(int feature)\n{\n\treturn false;\n}\nstatic inline void\nefi_reboot(enum reboot_mode reboot_mode, const char *__unused) {}\n\nstatic inline bool efi_soft_reserve_enabled(void)\n{\n\treturn false;\n}\n\nstatic inline bool efi_rt_services_supported(unsigned int mask)\n{\n\treturn false;\n}\n\nstatic inline void efi_find_mirror(void) {}\n#endif\n\nextern int efi_status_to_err(efi_status_t status);\n\n \n#define EFI_VARIABLE_NON_VOLATILE       0x0000000000000001\n#define EFI_VARIABLE_BOOTSERVICE_ACCESS 0x0000000000000002\n#define EFI_VARIABLE_RUNTIME_ACCESS     0x0000000000000004\n#define EFI_VARIABLE_HARDWARE_ERROR_RECORD 0x0000000000000008\n#define EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS 0x0000000000000010\n#define EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS 0x0000000000000020\n#define EFI_VARIABLE_APPEND_WRITE\t0x0000000000000040\n\n#define EFI_VARIABLE_MASK\t(EFI_VARIABLE_NON_VOLATILE | \\\n\t\t\t\tEFI_VARIABLE_BOOTSERVICE_ACCESS | \\\n\t\t\t\tEFI_VARIABLE_RUNTIME_ACCESS | \\\n\t\t\t\tEFI_VARIABLE_HARDWARE_ERROR_RECORD | \\\n\t\t\t\tEFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS | \\\n\t\t\t\tEFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS | \\\n\t\t\t\tEFI_VARIABLE_APPEND_WRITE)\n \n#define EFI_VARIABLE_GUID_LEN\tUUID_STRING_LEN\n\n \n#define EFI_DEV_HW\t\t\t0x01\n#define  EFI_DEV_PCI\t\t\t\t 1\n#define  EFI_DEV_PCCARD\t\t\t\t 2\n#define  EFI_DEV_MEM_MAPPED\t\t\t 3\n#define  EFI_DEV_VENDOR\t\t\t\t 4\n#define  EFI_DEV_CONTROLLER\t\t\t 5\n#define EFI_DEV_ACPI\t\t\t0x02\n#define   EFI_DEV_BASIC_ACPI\t\t\t 1\n#define   EFI_DEV_EXPANDED_ACPI\t\t\t 2\n#define EFI_DEV_MSG\t\t\t0x03\n#define   EFI_DEV_MSG_ATAPI\t\t\t 1\n#define   EFI_DEV_MSG_SCSI\t\t\t 2\n#define   EFI_DEV_MSG_FC\t\t\t 3\n#define   EFI_DEV_MSG_1394\t\t\t 4\n#define   EFI_DEV_MSG_USB\t\t\t 5\n#define   EFI_DEV_MSG_USB_CLASS\t\t\t15\n#define   EFI_DEV_MSG_I20\t\t\t 6\n#define   EFI_DEV_MSG_MAC\t\t\t11\n#define   EFI_DEV_MSG_IPV4\t\t\t12\n#define   EFI_DEV_MSG_IPV6\t\t\t13\n#define   EFI_DEV_MSG_INFINIBAND\t\t 9\n#define   EFI_DEV_MSG_UART\t\t\t14\n#define   EFI_DEV_MSG_VENDOR\t\t\t10\n#define EFI_DEV_MEDIA\t\t\t0x04\n#define   EFI_DEV_MEDIA_HARD_DRIVE\t\t 1\n#define   EFI_DEV_MEDIA_CDROM\t\t\t 2\n#define   EFI_DEV_MEDIA_VENDOR\t\t\t 3\n#define   EFI_DEV_MEDIA_FILE\t\t\t 4\n#define   EFI_DEV_MEDIA_PROTOCOL\t\t 5\n#define   EFI_DEV_MEDIA_REL_OFFSET\t\t 8\n#define EFI_DEV_BIOS_BOOT\t\t0x05\n#define EFI_DEV_END_PATH\t\t0x7F\n#define EFI_DEV_END_PATH2\t\t0xFF\n#define   EFI_DEV_END_INSTANCE\t\t\t0x01\n#define   EFI_DEV_END_ENTIRE\t\t\t0xFF\n\nstruct efi_generic_dev_path {\n\tu8\t\t\t\ttype;\n\tu8\t\t\t\tsub_type;\n\tu16\t\t\t\tlength;\n} __packed;\n\nstruct efi_acpi_dev_path {\n\tstruct efi_generic_dev_path\theader;\n\tu32\t\t\t\thid;\n\tu32\t\t\t\tuid;\n} __packed;\n\nstruct efi_pci_dev_path {\n\tstruct efi_generic_dev_path\theader;\n\tu8\t\t\t\tfn;\n\tu8\t\t\t\tdev;\n} __packed;\n\nstruct efi_vendor_dev_path {\n\tstruct efi_generic_dev_path\theader;\n\tefi_guid_t\t\t\tvendorguid;\n\tu8\t\t\t\tvendordata[];\n} __packed;\n\nstruct efi_rel_offset_dev_path {\n\tstruct efi_generic_dev_path\theader;\n\tu32\t\t\t\treserved;\n\tu64\t\t\t\tstarting_offset;\n\tu64\t\t\t\tending_offset;\n} __packed;\n\nstruct efi_mem_mapped_dev_path {\n\tstruct efi_generic_dev_path\theader;\n\tu32\t\t\t\tmemory_type;\n\tu64\t\t\t\tstarting_addr;\n\tu64\t\t\t\tending_addr;\n} __packed;\n\nstruct efi_file_path_dev_path {\n\tstruct efi_generic_dev_path\theader;\n\tefi_char16_t\t\t\tfilename[];\n} __packed;\n\nstruct efi_dev_path {\n\tunion {\n\t\tstruct efi_generic_dev_path\theader;\n\t\tstruct efi_acpi_dev_path\tacpi;\n\t\tstruct efi_pci_dev_path\t\tpci;\n\t\tstruct efi_vendor_dev_path\tvendor;\n\t\tstruct efi_rel_offset_dev_path\trel_offset;\n\t};\n} __packed;\n\nstruct device *efi_get_device_by_path(const struct efi_dev_path **node,\n\t\t\t\t      size_t *len);\n\nstatic inline void memrange_efi_to_native(u64 *addr, u64 *npages)\n{\n\t*npages = PFN_UP(*addr + (*npages<<EFI_PAGE_SHIFT)) - PFN_DOWN(*addr);\n\t*addr &= PAGE_MASK;\n}\n\n \n\nstruct efivar_operations {\n\tefi_get_variable_t *get_variable;\n\tefi_get_next_variable_t *get_next_variable;\n\tefi_set_variable_t *set_variable;\n\tefi_set_variable_t *set_variable_nonblocking;\n\tefi_query_variable_store_t *query_variable_store;\n\tefi_query_variable_info_t *query_variable_info;\n};\n\nstruct efivars {\n\tstruct kset *kset;\n\tconst struct efivar_operations *ops;\n};\n\n#ifdef CONFIG_X86\nu64 __attribute_const__ efivar_reserved_space(void);\n#else\nstatic inline u64 efivar_reserved_space(void) { return 0; }\n#endif\n\n \n\n#define EFI_VAR_NAME_LEN\t1024\n\nint efivars_register(struct efivars *efivars,\n\t\t     const struct efivar_operations *ops);\nint efivars_unregister(struct efivars *efivars);\n\n#ifdef CONFIG_EFI\nbool efivar_is_available(void);\n#else\nstatic inline bool efivar_is_available(void) { return false; }\n#endif\n\nbool efivar_supports_writes(void);\n\nint efivar_lock(void);\nint efivar_trylock(void);\nvoid efivar_unlock(void);\n\nefi_status_t efivar_get_variable(efi_char16_t *name, efi_guid_t *vendor,\n\t\t\t\t u32 *attr, unsigned long *size, void *data);\n\nefi_status_t efivar_get_next_variable(unsigned long *name_size,\n\t\t\t\t      efi_char16_t *name, efi_guid_t *vendor);\n\nefi_status_t efivar_set_variable_locked(efi_char16_t *name, efi_guid_t *vendor,\n\t\t\t\t\tu32 attr, unsigned long data_size,\n\t\t\t\t\tvoid *data, bool nonblocking);\n\nefi_status_t efivar_set_variable(efi_char16_t *name, efi_guid_t *vendor,\n\t\t\t\t u32 attr, unsigned long data_size, void *data);\n\nefi_status_t efivar_query_variable_info(u32 attr, u64 *storage_space,\n\t\t\t\t\tu64 *remaining_space,\n\t\t\t\t\tu64 *max_variable_size);\n\n#if IS_ENABLED(CONFIG_EFI_CAPSULE_LOADER)\nextern bool efi_capsule_pending(int *reset_type);\n\nextern int efi_capsule_supported(efi_guid_t guid, u32 flags,\n\t\t\t\t size_t size, int *reset);\n\nextern int efi_capsule_update(efi_capsule_header_t *capsule,\n\t\t\t      phys_addr_t *pages);\n#else\nstatic inline bool efi_capsule_pending(int *reset_type) { return false; }\n#endif\n\n#ifdef CONFIG_EFI\nextern bool efi_runtime_disabled(void);\n#else\nstatic inline bool efi_runtime_disabled(void) { return true; }\n#endif\n\nextern void efi_call_virt_check_flags(unsigned long flags, const void *caller);\nextern unsigned long efi_call_virt_save_flags(void);\n\nenum efi_secureboot_mode {\n\tefi_secureboot_mode_unset,\n\tefi_secureboot_mode_unknown,\n\tefi_secureboot_mode_disabled,\n\tefi_secureboot_mode_enabled,\n};\n\nstatic inline\nenum efi_secureboot_mode efi_get_secureboot_mode(efi_get_variable_t *get_var)\n{\n\tu8 secboot, setupmode = 0;\n\tefi_status_t status;\n\tunsigned long size;\n\n\tsize = sizeof(secboot);\n\tstatus = get_var(L\"SecureBoot\", &EFI_GLOBAL_VARIABLE_GUID, NULL, &size,\n\t\t\t &secboot);\n\tif (status == EFI_NOT_FOUND)\n\t\treturn efi_secureboot_mode_disabled;\n\tif (status != EFI_SUCCESS)\n\t\treturn efi_secureboot_mode_unknown;\n\n\tsize = sizeof(setupmode);\n\tget_var(L\"SetupMode\", &EFI_GLOBAL_VARIABLE_GUID, NULL, &size, &setupmode);\n\tif (secboot == 0 || setupmode == 1)\n\t\treturn efi_secureboot_mode_disabled;\n\treturn efi_secureboot_mode_enabled;\n}\n\n#ifdef CONFIG_EFI_EMBEDDED_FIRMWARE\nvoid efi_check_for_embedded_firmwares(void);\n#else\nstatic inline void efi_check_for_embedded_firmwares(void) { }\n#endif\n\n#define arch_efi_call_virt(p, f, args...)\t((p)->f(args))\n\n \n\n#define efi_call_virt_pointer(p, f, args...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof((p)->f(args)) __s;\t\t\t\t\t\\\n\tunsigned long __flags;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tarch_efi_call_virt_setup();\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__flags = efi_call_virt_save_flags();\t\t\t\t\\\n\t__s = arch_efi_call_virt(p, f, args);\t\t\t\t\\\n\tefi_call_virt_check_flags(__flags, NULL);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tarch_efi_call_virt_teardown();\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__s;\t\t\t\t\t\t\t\t\\\n})\n\n#define EFI_RANDOM_SEED_SIZE\t\t32U \n\nstruct linux_efi_random_seed {\n\tu32\tsize;\n\tu8\tbits[];\n};\n\nstruct linux_efi_tpm_eventlog {\n\tu32\tsize;\n\tu32\tfinal_events_preboot_size;\n\tu8\tversion;\n\tu8\tlog[];\n};\n\nextern int efi_tpm_eventlog_init(void);\n\nstruct efi_tcg2_final_events_table {\n\tu64 version;\n\tu64 nr_events;\n\tu8 events[];\n};\nextern int efi_tpm_final_log_size;\n\nextern unsigned long rci2_table_phys;\n\nefi_status_t\nefi_call_acpi_prm_handler(efi_status_t (__efiapi *handler_addr)(u64, void *),\n\t\t\t  u64 param_buffer_addr, void *context);\n\n \nenum efi_rts_ids {\n\tEFI_NONE,\n\tEFI_GET_TIME,\n\tEFI_SET_TIME,\n\tEFI_GET_WAKEUP_TIME,\n\tEFI_SET_WAKEUP_TIME,\n\tEFI_GET_VARIABLE,\n\tEFI_GET_NEXT_VARIABLE,\n\tEFI_SET_VARIABLE,\n\tEFI_QUERY_VARIABLE_INFO,\n\tEFI_GET_NEXT_HIGH_MONO_COUNT,\n\tEFI_RESET_SYSTEM,\n\tEFI_UPDATE_CAPSULE,\n\tEFI_QUERY_CAPSULE_CAPS,\n\tEFI_ACPI_PRM_HANDLER,\n};\n\nunion efi_rts_args;\n\n \nstruct efi_runtime_work {\n\tunion efi_rts_args\t*args;\n\tefi_status_t\t\tstatus;\n\tstruct work_struct\twork;\n\tenum efi_rts_ids\tefi_rts_id;\n\tstruct completion\tefi_rts_comp;\n\tconst void\t\t*caller;\n};\n\nextern struct efi_runtime_work efi_rts_work;\n\n \nextern struct workqueue_struct *efi_rts_wq;\n\nstruct linux_efi_memreserve {\n\tint\t\tsize;\t\t\t\n\tatomic_t\tcount;\t\t\t\n\tphys_addr_t\tnext;\t\t\t\n\tstruct {\n\t\tphys_addr_t\tbase;\n\t\tphys_addr_t\tsize;\n\t} entry[];\n};\n\n#define EFI_MEMRESERVE_COUNT(size) (((size) - sizeof(struct linux_efi_memreserve)) \\\n\t/ sizeof_field(struct linux_efi_memreserve, entry[0]))\n\nvoid __init efi_arch_mem_reserve(phys_addr_t addr, u64 size);\n\nchar *efi_systab_show_arch(char *str);\n\n \nstruct efi_mokvar_table_entry {\n\tchar name[256];\n\tu64 data_size;\n\tu8 data[];\n} __attribute((packed));\n\n#ifdef CONFIG_LOAD_UEFI_KEYS\nextern void __init efi_mokvar_table_init(void);\nextern struct efi_mokvar_table_entry *efi_mokvar_entry_next(\n\t\t\tstruct efi_mokvar_table_entry **mokvar_entry);\nextern struct efi_mokvar_table_entry *efi_mokvar_entry_find(const char *name);\n#else\nstatic inline void efi_mokvar_table_init(void) { }\nstatic inline struct efi_mokvar_table_entry *efi_mokvar_entry_next(\n\t\t\tstruct efi_mokvar_table_entry **mokvar_entry)\n{\n\treturn NULL;\n}\nstatic inline struct efi_mokvar_table_entry *efi_mokvar_entry_find(\n\t\t\tconst char *name)\n{\n\treturn NULL;\n}\n#endif\n\nextern void efifb_setup_from_dmi(struct screen_info *si, const char *opt);\n\nstruct linux_efi_coco_secret_area {\n\tu64\tbase_pa;\n\tu64\tsize;\n};\n\nstruct linux_efi_initrd {\n\tunsigned long\tbase;\n\tunsigned long\tsize;\n};\n\n \n#define EFI_SECRET_TABLE_HEADER_GUID\tEFI_GUID(0x1e74f542, 0x71dd, 0x4d66,  0x96, 0x3e, 0xef, 0x42, 0x87, 0xff, 0x17, 0x3b)\n\nbool xen_efi_config_table_is_usable(const efi_guid_t *guid, unsigned long table);\n\nstatic inline\nbool efi_config_table_is_usable(const efi_guid_t *guid, unsigned long table)\n{\n\tif (!IS_ENABLED(CONFIG_XEN_EFI))\n\t\treturn true;\n\treturn xen_efi_config_table_is_usable(guid, table);\n}\n\numode_t efi_attr_is_visible(struct kobject *kobj, struct attribute *attr, int n);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}