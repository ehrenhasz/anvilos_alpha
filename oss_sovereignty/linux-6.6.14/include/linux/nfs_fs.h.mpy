{
  "module_name": "nfs_fs.h",
  "hash_id": "55a3b3a3538c48693e6d95436fb3c86776ba83dd81612b358ac14191c924b738",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/nfs_fs.h",
  "human_readable_source": " \n \n#ifndef _LINUX_NFS_FS_H\n#define _LINUX_NFS_FS_H\n\n#include <uapi/linux/nfs_fs.h>\n\n\n \n#ifdef CONFIG_NFS_DEBUG\n# define NFS_DEBUG\n#endif\n\n#include <linux/in.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/rbtree.h>\n#include <linux/refcount.h>\n#include <linux/rwsem.h>\n#include <linux/wait.h>\n\n#include <linux/sunrpc/debug.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/clnt.h>\n\n#ifdef CONFIG_NFS_FSCACHE\n#include <linux/netfs.h>\n#endif\n\n#include <linux/nfs.h>\n#include <linux/nfs2.h>\n#include <linux/nfs3.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs_sb.h>\n\n#include <linux/mempool.h>\n\n \n#define NFS_MAX_TRANSPORTS 16\n\n \n#define NFS_DIR_VERIFIER_SIZE\t\t2\n\n \nstruct nfs_access_entry {\n\tstruct rb_node\t\trb_node;\n\tstruct list_head\tlru;\n\tkuid_t\t\t\tfsuid;\n\tkgid_t\t\t\tfsgid;\n\tstruct group_info\t*group_info;\n\tu64\t\t\ttimestamp;\n\t__u32\t\t\tmask;\n\tstruct rcu_head\t\trcu_head;\n};\n\nstruct nfs_lock_context {\n\trefcount_t count;\n\tstruct list_head list;\n\tstruct nfs_open_context *open_context;\n\tfl_owner_t lockowner;\n\tatomic_t io_count;\n\tstruct rcu_head\trcu_head;\n};\n\nstruct nfs4_state;\nstruct nfs_open_context {\n\tstruct nfs_lock_context lock_context;\n\tfl_owner_t flock_owner;\n\tstruct dentry *dentry;\n\tconst struct cred *cred;\n\tstruct rpc_cred __rcu *ll_cred;\t \n\tstruct nfs4_state *state;\n\tfmode_t mode;\n\n\tunsigned long flags;\n#define NFS_CONTEXT_BAD\t\t\t(2)\n#define NFS_CONTEXT_UNLOCK\t(3)\n#define NFS_CONTEXT_FILE_OPEN\t\t(4)\n\tint error;\n\n\tstruct list_head list;\n\tstruct nfs4_threshold\t*mdsthreshold;\n\tstruct rcu_head\trcu_head;\n};\n\nstruct nfs_open_dir_context {\n\tstruct list_head list;\n\tatomic_t cache_hits;\n\tatomic_t cache_misses;\n\tunsigned long attr_gencount;\n\t__be32\tverf[NFS_DIR_VERIFIER_SIZE];\n\t__u64 dir_cookie;\n\t__u64 last_cookie;\n\tpgoff_t page_index;\n\tunsigned int dtsize;\n\tbool force_clear;\n\tbool eof;\n\tstruct rcu_head rcu_head;\n};\n\n \nstruct nfs_delegation;\n\nstruct posix_acl;\n\nstruct nfs4_xattr_cache;\n\n \nstruct nfs_inode {\n\t \n\t__u64 fileid;\n\n\t \n\tstruct nfs_fh\t\tfh;\n\n\t \n\tunsigned long\t\tflags;\t\t\t \n\tunsigned long\t\tcache_validity;\t\t \n\n\t \n\tunsigned long\t\tread_cache_jiffies;\n\tunsigned long\t\tattrtimeo;\n\tunsigned long\t\tattrtimeo_timestamp;\n\n\tunsigned long\t\tattr_gencount;\n\n\tstruct rb_root\t\taccess_cache;\n\tstruct list_head\taccess_cache_entry_lru;\n\tstruct list_head\taccess_cache_inode_lru;\n\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tunsigned long\tcache_change_attribute;\n\t\t\t \n\t\t\t__be32\t\tcookieverf[NFS_DIR_VERIFIER_SIZE];\n\t\t\t \n\t\t\t \n\t\t\tstruct rw_semaphore\trmdir_sem;\n\t\t};\n\t\t \n\t\tstruct {\n\t\t\tatomic_long_t\tnrequests;\n\t\t\tatomic_long_t\tredirtied_pages;\n\t\t\tstruct nfs_mds_commit_info commit_info;\n\t\t\tstruct mutex\tcommit_mutex;\n\t\t};\n\t};\n\n\t \n\tstruct list_head\topen_files;\n\n\t \n\tstruct {\n\t\tint cnt;\n\t\tstruct {\n\t\t\tu64 start, end;\n\t\t} gap[16];\n\t} *ooo;\n\n#if IS_ENABLED(CONFIG_NFS_V4)\n\tstruct nfs4_cached_acl\t*nfs4_acl;\n         \n\tstruct list_head\topen_states;\n\tstruct nfs_delegation __rcu *delegation;\n\tstruct rw_semaphore\trwsem;\n\n\t \n\tstruct pnfs_layout_hdr *layout;\n#endif  \n\t \n\t__u64 write_io;\n\t__u64 read_io;\n#ifdef CONFIG_NFS_V4_2\n\tstruct nfs4_xattr_cache *xattr_cache;\n#endif\n\tunion {\n\t\tstruct inode\t\tvfs_inode;\n#ifdef CONFIG_NFS_FSCACHE\n\t\tstruct netfs_inode\tnetfs;  \n#endif\n\t};\n};\n\nstruct nfs4_copy_state {\n\tstruct list_head\tcopies;\n\tstruct list_head\tsrc_copies;\n\tnfs4_stateid\t\tstateid;\n\tstruct completion\tcompletion;\n\tuint64_t\t\tcount;\n\tstruct nfs_writeverf\tverf;\n\tint\t\t\terror;\n\tint\t\t\tflags;\n\tstruct nfs4_state\t*parent_src_state;\n\tstruct nfs4_state\t*parent_dst_state;\n};\n\n \n#define NFS_ACCESS_READ        0x0001\n#define NFS_ACCESS_LOOKUP      0x0002\n#define NFS_ACCESS_MODIFY      0x0004\n#define NFS_ACCESS_EXTEND      0x0008\n#define NFS_ACCESS_DELETE      0x0010\n#define NFS_ACCESS_EXECUTE     0x0020\n#define NFS_ACCESS_XAREAD      0x0040\n#define NFS_ACCESS_XAWRITE     0x0080\n#define NFS_ACCESS_XALIST      0x0100\n\n \n#define NFS_INO_INVALID_DATA\tBIT(1)\t\t \n#define NFS_INO_INVALID_ATIME\tBIT(2)\t\t \n#define NFS_INO_INVALID_ACCESS\tBIT(3)\t\t \n#define NFS_INO_INVALID_ACL\tBIT(4)\t\t \n#define NFS_INO_REVAL_FORCED\tBIT(6)\t\t \n#define NFS_INO_INVALID_LABEL\tBIT(7)\t\t \n#define NFS_INO_INVALID_CHANGE\tBIT(8)\t\t \n#define NFS_INO_INVALID_CTIME\tBIT(9)\t\t \n#define NFS_INO_INVALID_MTIME\tBIT(10)\t\t \n#define NFS_INO_INVALID_SIZE\tBIT(11)\t\t \n#define NFS_INO_INVALID_OTHER\tBIT(12)\t\t \n#define NFS_INO_DATA_INVAL_DEFER\t\\\n\t\t\t\tBIT(13)\t\t \n#define NFS_INO_INVALID_BLOCKS\tBIT(14)          \n#define NFS_INO_INVALID_XATTR\tBIT(15)\t\t \n#define NFS_INO_INVALID_NLINK\tBIT(16)\t\t \n#define NFS_INO_INVALID_MODE\tBIT(17)\t\t \n\n#define NFS_INO_INVALID_ATTR\t(NFS_INO_INVALID_CHANGE \\\n\t\t| NFS_INO_INVALID_CTIME \\\n\t\t| NFS_INO_INVALID_MTIME \\\n\t\t| NFS_INO_INVALID_SIZE \\\n\t\t| NFS_INO_INVALID_NLINK \\\n\t\t| NFS_INO_INVALID_MODE \\\n\t\t| NFS_INO_INVALID_OTHER)\t \n\n \n#define NFS_INO_STALE\t\t(1)\t\t \n#define NFS_INO_ACL_LRU_SET\t(2)\t\t \n#define NFS_INO_INVALIDATING\t(3)\t\t \n#define NFS_INO_PRESERVE_UNLINKED (4)\t\t \n#define NFS_INO_LAYOUTCOMMIT\t(9)\t\t \n#define NFS_INO_LAYOUTCOMMITTING (10)\t\t \n#define NFS_INO_LAYOUTSTATS\t(11)\t\t \n#define NFS_INO_ODIRECT\t\t(12)\t\t \n\nstatic inline struct nfs_inode *NFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nfs_inode, vfs_inode);\n}\n\nstatic inline struct nfs_server *NFS_SB(const struct super_block *s)\n{\n\treturn (struct nfs_server *)(s->s_fs_info);\n}\n\nstatic inline struct nfs_fh *NFS_FH(const struct inode *inode)\n{\n\treturn &NFS_I(inode)->fh;\n}\n\nstatic inline struct nfs_server *NFS_SERVER(const struct inode *inode)\n{\n\treturn NFS_SB(inode->i_sb);\n}\n\nstatic inline struct rpc_clnt *NFS_CLIENT(const struct inode *inode)\n{\n\treturn NFS_SERVER(inode)->client;\n}\n\nstatic inline const struct nfs_rpc_ops *NFS_PROTO(const struct inode *inode)\n{\n\treturn NFS_SERVER(inode)->nfs_client->rpc_ops;\n}\n\nstatic inline unsigned NFS_MINATTRTIMEO(const struct inode *inode)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\treturn S_ISDIR(inode->i_mode) ? nfss->acdirmin : nfss->acregmin;\n}\n\nstatic inline unsigned NFS_MAXATTRTIMEO(const struct inode *inode)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\treturn S_ISDIR(inode->i_mode) ? nfss->acdirmax : nfss->acregmax;\n}\n\nstatic inline int NFS_STALE(const struct inode *inode)\n{\n\treturn test_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n}\n\nstatic inline __u64 NFS_FILEID(const struct inode *inode)\n{\n\treturn NFS_I(inode)->fileid;\n}\n\nstatic inline void set_nfs_fileid(struct inode *inode, __u64 fileid)\n{\n\tNFS_I(inode)->fileid = fileid;\n}\n\nstatic inline void nfs_mark_for_revalidate(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tnfsi->cache_validity |= NFS_INO_INVALID_ACCESS | NFS_INO_INVALID_ACL |\n\t\t\t\tNFS_INO_INVALID_CHANGE | NFS_INO_INVALID_CTIME |\n\t\t\t\tNFS_INO_INVALID_SIZE;\n\tif (S_ISDIR(inode->i_mode))\n\t\tnfsi->cache_validity |= NFS_INO_INVALID_DATA;\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic inline int nfs_server_capable(const struct inode *inode, int cap)\n{\n\treturn NFS_SERVER(inode)->caps & cap;\n}\n\n \nstatic inline unsigned long nfs_save_change_attribute(struct inode *dir)\n{\n\treturn NFS_I(dir)->cache_change_attribute;\n}\n\n \nextern int nfs_sync_mapping(struct address_space *mapping);\nextern void nfs_zap_mapping(struct inode *inode, struct address_space *mapping);\nextern void nfs_zap_caches(struct inode *);\nextern void nfs_set_inode_stale(struct inode *inode);\nextern void nfs_invalidate_atime(struct inode *);\nextern struct inode *nfs_fhget(struct super_block *, struct nfs_fh *,\n\t\t\t\tstruct nfs_fattr *);\nstruct inode *nfs_ilookup(struct super_block *sb, struct nfs_fattr *, struct nfs_fh *);\nextern int nfs_refresh_inode(struct inode *, struct nfs_fattr *);\nextern int nfs_post_op_update_inode(struct inode *inode, struct nfs_fattr *fattr);\nextern int nfs_post_op_update_inode_force_wcc(struct inode *inode, struct nfs_fattr *fattr);\nextern int nfs_post_op_update_inode_force_wcc_locked(struct inode *inode, struct nfs_fattr *fattr);\nextern int nfs_getattr(struct mnt_idmap *, const struct path *,\n\t\t       struct kstat *, u32, unsigned int);\nextern void nfs_access_add_cache(struct inode *, struct nfs_access_entry *, const struct cred *);\nextern void nfs_access_set_mask(struct nfs_access_entry *, u32);\nextern int nfs_permission(struct mnt_idmap *, struct inode *, int);\nextern int nfs_open(struct inode *, struct file *);\nextern int nfs_attribute_cache_expired(struct inode *inode);\nextern int nfs_revalidate_inode(struct inode *inode, unsigned long flags);\nextern int __nfs_revalidate_inode(struct nfs_server *, struct inode *);\nextern int nfs_clear_invalid_mapping(struct address_space *mapping);\nextern bool nfs_mapping_need_revalidate_inode(struct inode *inode);\nextern int nfs_revalidate_mapping(struct inode *inode, struct address_space *mapping);\nextern int nfs_revalidate_mapping_rcu(struct inode *inode);\nextern int nfs_setattr(struct mnt_idmap *, struct dentry *, struct iattr *);\nextern void nfs_setattr_update_inode(struct inode *inode, struct iattr *attr, struct nfs_fattr *);\nextern void nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr);\nextern struct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx);\nextern void put_nfs_open_context(struct nfs_open_context *ctx);\nextern struct nfs_open_context *nfs_find_open_context(struct inode *inode, const struct cred *cred, fmode_t mode);\nextern struct nfs_open_context *alloc_nfs_open_context(struct dentry *dentry, fmode_t f_mode, struct file *filp);\nextern void nfs_inode_attach_open_context(struct nfs_open_context *ctx);\nextern void nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx);\nextern void nfs_file_clear_open_context(struct file *flip);\nextern struct nfs_lock_context *nfs_get_lock_context(struct nfs_open_context *ctx);\nextern void nfs_put_lock_context(struct nfs_lock_context *l_ctx);\nextern u64 nfs_compat_user_ino64(u64 fileid);\nextern void nfs_fattr_init(struct nfs_fattr *fattr);\nextern void nfs_fattr_set_barrier(struct nfs_fattr *fattr);\nextern unsigned long nfs_inc_attr_generation_counter(void);\n\nextern struct nfs_fattr *nfs_alloc_fattr(void);\nextern struct nfs_fattr *nfs_alloc_fattr_with_label(struct nfs_server *server);\n\nstatic inline void nfs4_label_free(struct nfs4_label *label)\n{\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\tif (label) {\n\t\tkfree(label->label);\n\t\tkfree(label);\n\t}\n#endif\n}\n\nstatic inline void nfs_free_fattr(const struct nfs_fattr *fattr)\n{\n\tif (fattr)\n\t\tnfs4_label_free(fattr->label);\n\tkfree(fattr);\n}\n\nextern struct nfs_fh *nfs_alloc_fhandle(void);\n\nstatic inline void nfs_free_fhandle(const struct nfs_fh *fh)\n{\n\tkfree(fh);\n}\n\n#ifdef NFS_DEBUG\nextern u32 _nfs_display_fhandle_hash(const struct nfs_fh *fh);\nstatic inline u32 nfs_display_fhandle_hash(const struct nfs_fh *fh)\n{\n\treturn _nfs_display_fhandle_hash(fh);\n}\nextern void _nfs_display_fhandle(const struct nfs_fh *fh, const char *caption);\n#define nfs_display_fhandle(fh, caption)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (unlikely(nfs_debug & NFSDBG_FACILITY))\t\\\n\t\t\t_nfs_display_fhandle(fh, caption);\t\\\n\t} while (0)\n#else\nstatic inline u32 nfs_display_fhandle_hash(const struct nfs_fh *fh)\n{\n\treturn 0;\n}\nstatic inline void nfs_display_fhandle(const struct nfs_fh *fh,\n\t\t\t\t       const char *caption)\n{\n}\n#endif\n\n \nextern int  nfs_root_data(char **root_device, char **root_data);  \n \nextern __be32 root_nfs_parse_addr(char *name);  \n\n \nextern const struct file_operations nfs_file_operations;\n#if IS_ENABLED(CONFIG_NFS_V4)\nextern const struct file_operations nfs4_file_operations;\n#endif  \nextern const struct address_space_operations nfs_file_aops;\nextern const struct address_space_operations nfs_dir_aops;\n\nstatic inline struct nfs_open_context *nfs_file_open_context(struct file *filp)\n{\n\treturn filp->private_data;\n}\n\nstatic inline const struct cred *nfs_file_cred(struct file *file)\n{\n\tif (file != NULL) {\n\t\tstruct nfs_open_context *ctx =\n\t\t\tnfs_file_open_context(file);\n\t\tif (ctx)\n\t\t\treturn ctx->cred;\n\t}\n\treturn NULL;\n}\n\n \nint nfs_swap_rw(struct kiocb *iocb, struct iov_iter *iter);\nssize_t nfs_file_direct_read(struct kiocb *iocb,\n\t\t\t     struct iov_iter *iter, bool swap);\nssize_t nfs_file_direct_write(struct kiocb *iocb,\n\t\t\t      struct iov_iter *iter, bool swap);\n\n \nextern const struct file_operations nfs_dir_operations;\nextern const struct dentry_operations nfs_dentry_operations;\n\nextern void nfs_force_lookup_revalidate(struct inode *dir);\nextern void nfs_set_verifier(struct dentry * dentry, unsigned long verf);\n#if IS_ENABLED(CONFIG_NFS_V4)\nextern void nfs_clear_verifier_delegated(struct inode *inode);\n#endif  \nextern struct dentry *nfs_add_or_obtain(struct dentry *dentry,\n\t\t\tstruct nfs_fh *fh, struct nfs_fattr *fattr);\nextern int nfs_instantiate(struct dentry *dentry, struct nfs_fh *fh,\n\t\t\tstruct nfs_fattr *fattr);\nextern int nfs_may_open(struct inode *inode, const struct cred *cred, int openflags);\nextern void nfs_access_zap_cache(struct inode *inode);\nextern int nfs_access_get_cached(struct inode *inode, const struct cred *cred,\n\t\t\t\t u32 *mask, bool may_block);\n\n \nextern const struct inode_operations nfs_symlink_inode_operations;\n\n \n#ifdef CONFIG_SYSCTL\nextern int nfs_register_sysctl(void);\nextern void nfs_unregister_sysctl(void);\n#else\n#define nfs_register_sysctl() 0\n#define nfs_unregister_sysctl() do { } while(0)\n#endif\n\n \nextern const struct inode_operations nfs_mountpoint_inode_operations;\nextern const struct inode_operations nfs_referral_inode_operations;\nextern int nfs_mountpoint_expiry_timeout;\nextern void nfs_release_automount_timer(void);\n\n \nextern void nfs_complete_unlink(struct dentry *dentry, struct inode *);\n\n \nextern int  nfs_congestion_kb;\nextern int  nfs_writepage(struct page *page, struct writeback_control *wbc);\nextern int  nfs_writepages(struct address_space *, struct writeback_control *);\nextern int  nfs_flush_incompatible(struct file *file, struct folio *folio);\nextern int  nfs_update_folio(struct file *file, struct folio *folio,\n\t\t\t     unsigned int offset, unsigned int count);\n\n \nextern int nfs_sync_inode(struct inode *inode);\nextern int nfs_wb_all(struct inode *inode);\nextern int nfs_wb_folio(struct inode *inode, struct folio *folio);\nint nfs_wb_folio_cancel(struct inode *inode, struct folio *folio);\nextern int  nfs_commit_inode(struct inode *, int);\nextern struct nfs_commit_data *nfs_commitdata_alloc(void);\nextern void nfs_commit_free(struct nfs_commit_data *data);\nbool nfs_commit_end(struct nfs_mds_commit_info *cinfo);\n\nstatic inline bool nfs_have_writebacks(const struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn atomic_long_read(&NFS_I(inode)->nrequests) != 0;\n\treturn false;\n}\n\n \nint  nfs_read_folio(struct file *, struct folio *);\nvoid nfs_readahead(struct readahead_control *);\n\n \n\nstatic inline loff_t nfs_size_to_loff_t(__u64 size)\n{\n\treturn min_t(u64, size, OFFSET_MAX);\n}\n\nstatic inline ino_t\nnfs_fileid_to_ino_t(u64 fileid)\n{\n\tino_t ino = (ino_t) fileid;\n\tif (sizeof(ino_t) < sizeof(u64))\n\t\tino ^= fileid >> (sizeof(u64)-sizeof(ino_t)) * 8;\n\treturn ino;\n}\n\nstatic inline void nfs_ooo_clear(struct nfs_inode *nfsi)\n{\n\tnfsi->cache_validity &= ~NFS_INO_DATA_INVAL_DEFER;\n\tkfree(nfsi->ooo);\n\tnfsi->ooo = NULL;\n}\n\nstatic inline bool nfs_ooo_test(struct nfs_inode *nfsi)\n{\n\treturn (nfsi->cache_validity & NFS_INO_DATA_INVAL_DEFER) ||\n\t\t(nfsi->ooo && nfsi->ooo->cnt > 0);\n\n}\n\n#define NFS_JUKEBOX_RETRY_TIME (5 * HZ)\n\n \n#define NFS_FSDATA_BLOCKED ((void*)1)\n\n# undef ifdebug\n# ifdef NFS_DEBUG\n#  define ifdebug(fac)\t\tif (unlikely(nfs_debug & NFSDBG_##fac))\n#  define NFS_IFDEBUG(x)\tx\n# else\n#  define ifdebug(fac)\t\tif (0)\n#  define NFS_IFDEBUG(x)\n# endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}