{
  "module_name": "audit.h",
  "hash_id": "45aac83a6eee94e02c9504ce6d25028a8b28122187d233ecf967107044b5a6a9",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/audit.h",
  "human_readable_source": " \n \n#ifndef _LINUX_AUDIT_H_\n#define _LINUX_AUDIT_H_\n\n#include <linux/sched.h>\n#include <linux/ptrace.h>\n#include <linux/audit_arch.h>\n#include <uapi/linux/audit.h>\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/fanotify.h>\n\n#define AUDIT_INO_UNSET ((unsigned long)-1)\n#define AUDIT_DEV_UNSET ((dev_t)-1)\n\nstruct audit_sig_info {\n\tuid_t\t\tuid;\n\tpid_t\t\tpid;\n\tchar\t\tctx[];\n};\n\nstruct audit_buffer;\nstruct audit_context;\nstruct inode;\nstruct netlink_skb_parms;\nstruct path;\nstruct linux_binprm;\nstruct mq_attr;\nstruct mqstat;\nstruct audit_watch;\nstruct audit_tree;\nstruct sk_buff;\n\nstruct audit_krule {\n\tu32\t\t\tpflags;\n\tu32\t\t\tflags;\n\tu32\t\t\tlistnr;\n\tu32\t\t\taction;\n\tu32\t\t\tmask[AUDIT_BITMASK_SIZE];\n\tu32\t\t\tbuflen;  \n\tu32\t\t\tfield_count;\n\tchar\t\t\t*filterkey;  \n\tstruct audit_field\t*fields;\n\tstruct audit_field\t*arch_f;  \n\tstruct audit_field\t*inode_f;  \n\tstruct audit_watch\t*watch;\t \n\tstruct audit_tree\t*tree;\t \n\tstruct audit_fsnotify_mark\t*exe;\n\tstruct list_head\trlist;\t \n\tstruct list_head\tlist;\t \n\tu64\t\t\tprio;\n};\n\n \n#define AUDIT_LOGINUID_LEGACY\t\t0x1\n\nstruct audit_field {\n\tu32\t\t\t\ttype;\n\tunion {\n\t\tu32\t\t\tval;\n\t\tkuid_t\t\t\tuid;\n\t\tkgid_t\t\t\tgid;\n\t\tstruct {\n\t\t\tchar\t\t*lsm_str;\n\t\t\tvoid\t\t*lsm_rule;\n\t\t};\n\t};\n\tu32\t\t\t\top;\n};\n\nenum audit_ntp_type {\n\tAUDIT_NTP_OFFSET,\n\tAUDIT_NTP_FREQ,\n\tAUDIT_NTP_STATUS,\n\tAUDIT_NTP_TAI,\n\tAUDIT_NTP_TICK,\n\tAUDIT_NTP_ADJUST,\n\n\tAUDIT_NTP_NVALS  \n};\n\n#ifdef CONFIG_AUDITSYSCALL\nstruct audit_ntp_val {\n\tlong long oldval, newval;\n};\n\nstruct audit_ntp_data {\n\tstruct audit_ntp_val vals[AUDIT_NTP_NVALS];\n};\n#else\nstruct audit_ntp_data {};\n#endif\n\nenum audit_nfcfgop {\n\tAUDIT_XT_OP_REGISTER,\n\tAUDIT_XT_OP_REPLACE,\n\tAUDIT_XT_OP_UNREGISTER,\n\tAUDIT_NFT_OP_TABLE_REGISTER,\n\tAUDIT_NFT_OP_TABLE_UNREGISTER,\n\tAUDIT_NFT_OP_CHAIN_REGISTER,\n\tAUDIT_NFT_OP_CHAIN_UNREGISTER,\n\tAUDIT_NFT_OP_RULE_REGISTER,\n\tAUDIT_NFT_OP_RULE_UNREGISTER,\n\tAUDIT_NFT_OP_SET_REGISTER,\n\tAUDIT_NFT_OP_SET_UNREGISTER,\n\tAUDIT_NFT_OP_SETELEM_REGISTER,\n\tAUDIT_NFT_OP_SETELEM_UNREGISTER,\n\tAUDIT_NFT_OP_GEN_REGISTER,\n\tAUDIT_NFT_OP_OBJ_REGISTER,\n\tAUDIT_NFT_OP_OBJ_UNREGISTER,\n\tAUDIT_NFT_OP_OBJ_RESET,\n\tAUDIT_NFT_OP_FLOWTABLE_REGISTER,\n\tAUDIT_NFT_OP_FLOWTABLE_UNREGISTER,\n\tAUDIT_NFT_OP_SETELEM_RESET,\n\tAUDIT_NFT_OP_RULE_RESET,\n\tAUDIT_NFT_OP_INVALID,\n};\n\nextern int __init audit_register_class(int class, unsigned *list);\nextern int audit_classify_syscall(int abi, unsigned syscall);\nextern int audit_classify_arch(int arch);\n \nextern unsigned compat_write_class[];\nextern unsigned compat_read_class[];\nextern unsigned compat_dir_class[];\nextern unsigned compat_chattr_class[];\nextern unsigned compat_signal_class[];\n\n \n#define\tAUDIT_TYPE_UNKNOWN\t0\t \n#define\tAUDIT_TYPE_NORMAL\t1\t \n#define\tAUDIT_TYPE_PARENT\t2\t \n#define\tAUDIT_TYPE_CHILD_DELETE 3\t \n#define\tAUDIT_TYPE_CHILD_CREATE 4\t \n\n \n#define AUDITSC_ARGS\t\t6\n\n \n#define AUDIT_TTY_ENABLE\tBIT(0)\n#define AUDIT_TTY_LOG_PASSWD\tBIT(1)\n\nstruct filename;\n\n#define AUDIT_OFF\t0\n#define AUDIT_ON\t1\n#define AUDIT_LOCKED\t2\n#ifdef CONFIG_AUDIT\n \n\t\t\t\t \nextern __printf(4, 5)\nvoid audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,\n\t       const char *fmt, ...);\n\nextern struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask, int type);\nextern __printf(2, 3)\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...);\nextern void\t\t    audit_log_end(struct audit_buffer *ab);\nextern bool\t\t    audit_string_contains_control(const char *string,\n\t\t\t\t\t\t\t  size_t len);\nextern void\t\t    audit_log_n_hex(struct audit_buffer *ab,\n\t\t\t\t\t  const unsigned char *buf,\n\t\t\t\t\t  size_t len);\nextern void\t\t    audit_log_n_string(struct audit_buffer *ab,\n\t\t\t\t\t       const char *buf,\n\t\t\t\t\t       size_t n);\nextern void\t\t    audit_log_n_untrustedstring(struct audit_buffer *ab,\n\t\t\t\t\t\t\tconst char *string,\n\t\t\t\t\t\t\tsize_t n);\nextern void\t\t    audit_log_untrustedstring(struct audit_buffer *ab,\n\t\t\t\t\t\t      const char *string);\nextern void\t\t    audit_log_d_path(struct audit_buffer *ab,\n\t\t\t\t\t     const char *prefix,\n\t\t\t\t\t     const struct path *path);\nextern void\t\t    audit_log_key(struct audit_buffer *ab,\n\t\t\t\t\t  char *key);\nextern void\t\t    audit_log_path_denied(int type,\n\t\t\t\t\t\t  const char *operation);\nextern void\t\t    audit_log_lost(const char *message);\n\nextern int audit_log_task_context(struct audit_buffer *ab);\nextern void audit_log_task_info(struct audit_buffer *ab);\n\nextern int\t\t    audit_update_lsm_rules(void);\n\n\t\t\t\t \nextern int audit_rule_change(int type, int seq, void *data, size_t datasz);\nextern int audit_list_rules_send(struct sk_buff *request_skb, int seq);\n\nextern int audit_set_loginuid(kuid_t loginuid);\n\nstatic inline kuid_t audit_get_loginuid(struct task_struct *tsk)\n{\n\treturn tsk->loginuid;\n}\n\nstatic inline unsigned int audit_get_sessionid(struct task_struct *tsk)\n{\n\treturn tsk->sessionid;\n}\n\nextern u32 audit_enabled;\n\nextern int audit_signal_info(int sig, struct task_struct *t);\n\n#else  \nstatic inline __printf(4, 5)\nvoid audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,\n\t       const char *fmt, ...)\n{ }\nstatic inline struct audit_buffer *audit_log_start(struct audit_context *ctx,\n\t\t\t\t\t\t   gfp_t gfp_mask, int type)\n{\n\treturn NULL;\n}\nstatic inline __printf(2, 3)\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{ }\nstatic inline void audit_log_end(struct audit_buffer *ab)\n{ }\nstatic inline void audit_log_n_hex(struct audit_buffer *ab,\n\t\t\t\t   const unsigned char *buf, size_t len)\n{ }\nstatic inline void audit_log_n_string(struct audit_buffer *ab,\n\t\t\t\t      const char *buf, size_t n)\n{ }\nstatic inline void  audit_log_n_untrustedstring(struct audit_buffer *ab,\n\t\t\t\t\t\tconst char *string, size_t n)\n{ }\nstatic inline void audit_log_untrustedstring(struct audit_buffer *ab,\n\t\t\t\t\t     const char *string)\n{ }\nstatic inline void audit_log_d_path(struct audit_buffer *ab,\n\t\t\t\t    const char *prefix,\n\t\t\t\t    const struct path *path)\n{ }\nstatic inline void audit_log_key(struct audit_buffer *ab, char *key)\n{ }\nstatic inline void audit_log_path_denied(int type, const char *operation)\n{ }\nstatic inline int audit_log_task_context(struct audit_buffer *ab)\n{\n\treturn 0;\n}\nstatic inline void audit_log_task_info(struct audit_buffer *ab)\n{ }\n\nstatic inline kuid_t audit_get_loginuid(struct task_struct *tsk)\n{\n\treturn INVALID_UID;\n}\n\nstatic inline unsigned int audit_get_sessionid(struct task_struct *tsk)\n{\n\treturn AUDIT_SID_UNSET;\n}\n\n#define audit_enabled AUDIT_OFF\n\nstatic inline int audit_signal_info(int sig, struct task_struct *t)\n{\n\treturn 0;\n}\n\n#endif  \n\n#ifdef CONFIG_AUDIT_COMPAT_GENERIC\n#define audit_is_compat(arch)  (!((arch) & __AUDIT_ARCH_64BIT))\n#else\n#define audit_is_compat(arch)  false\n#endif\n\n#define AUDIT_INODE_PARENT\t1\t \n#define AUDIT_INODE_HIDDEN\t2\t \n#define AUDIT_INODE_NOEVAL\t4\t \n\n#ifdef CONFIG_AUDITSYSCALL\n#include <asm/syscall.h>  \n\n \n\t\t\t\t \nextern int  audit_alloc(struct task_struct *task);\nextern void __audit_free(struct task_struct *task);\nextern void __audit_uring_entry(u8 op);\nextern void __audit_uring_exit(int success, long code);\nextern void __audit_syscall_entry(int major, unsigned long a0, unsigned long a1,\n\t\t\t\t  unsigned long a2, unsigned long a3);\nextern void __audit_syscall_exit(int ret_success, long ret_value);\nextern struct filename *__audit_reusename(const __user char *uptr);\nextern void __audit_getname(struct filename *name);\nextern void __audit_inode(struct filename *name, const struct dentry *dentry,\n\t\t\t\tunsigned int flags);\nextern void __audit_file(const struct file *);\nextern void __audit_inode_child(struct inode *parent,\n\t\t\t\tconst struct dentry *dentry,\n\t\t\t\tconst unsigned char type);\nextern void audit_seccomp(unsigned long syscall, long signr, int code);\nextern void audit_seccomp_actions_logged(const char *names,\n\t\t\t\t\t const char *old_names, int res);\nextern void __audit_ptrace(struct task_struct *t);\n\nstatic inline void audit_set_context(struct task_struct *task, struct audit_context *ctx)\n{\n\ttask->audit_context = ctx;\n}\n\nstatic inline struct audit_context *audit_context(void)\n{\n\treturn current->audit_context;\n}\n\nstatic inline bool audit_dummy_context(void)\n{\n\tvoid *p = audit_context();\n\treturn !p || *(int *)p;\n}\nstatic inline void audit_free(struct task_struct *task)\n{\n\tif (unlikely(task->audit_context))\n\t\t__audit_free(task);\n}\nstatic inline void audit_uring_entry(u8 op)\n{\n\t \n\tif (unlikely(audit_context() && audit_enabled))\n\t\t__audit_uring_entry(op);\n}\nstatic inline void audit_uring_exit(int success, long code)\n{\n\tif (unlikely(audit_context()))\n\t\t__audit_uring_exit(success, code);\n}\nstatic inline void audit_syscall_entry(int major, unsigned long a0,\n\t\t\t\t       unsigned long a1, unsigned long a2,\n\t\t\t\t       unsigned long a3)\n{\n\tif (unlikely(audit_context()))\n\t\t__audit_syscall_entry(major, a0, a1, a2, a3);\n}\nstatic inline void audit_syscall_exit(void *pt_regs)\n{\n\tif (unlikely(audit_context())) {\n\t\tint success = is_syscall_success(pt_regs);\n\t\tlong return_code = regs_return_value(pt_regs);\n\n\t\t__audit_syscall_exit(success, return_code);\n\t}\n}\nstatic inline struct filename *audit_reusename(const __user char *name)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\treturn __audit_reusename(name);\n\treturn NULL;\n}\nstatic inline void audit_getname(struct filename *name)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_getname(name);\n}\nstatic inline void audit_inode(struct filename *name,\n\t\t\t\tconst struct dentry *dentry,\n\t\t\t\tunsigned int aflags) {\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_inode(name, dentry, aflags);\n}\nstatic inline void audit_file(struct file *file)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_file(file);\n}\nstatic inline void audit_inode_parent_hidden(struct filename *name,\n\t\t\t\t\t\tconst struct dentry *dentry)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_inode(name, dentry,\n\t\t\t\tAUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);\n}\nstatic inline void audit_inode_child(struct inode *parent,\n\t\t\t\t     const struct dentry *dentry,\n\t\t\t\t     const unsigned char type) {\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_inode_child(parent, dentry, type);\n}\nvoid audit_core_dumps(long signr);\n\nstatic inline void audit_ptrace(struct task_struct *t)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_ptrace(t);\n}\n\n\t\t\t\t \nextern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);\nextern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode);\nextern void __audit_bprm(struct linux_binprm *bprm);\nextern int __audit_socketcall(int nargs, unsigned long *args);\nextern int __audit_sockaddr(int len, void *addr);\nextern void __audit_fd_pair(int fd1, int fd2);\nextern void __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr);\nextern void __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec64 *abs_timeout);\nextern void __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification);\nextern void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);\nextern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t\t  const struct cred *new,\n\t\t\t\t  const struct cred *old);\nextern void __audit_log_capset(const struct cred *new, const struct cred *old);\nextern void __audit_mmap_fd(int fd, int flags);\nextern void __audit_openat2_how(struct open_how *how);\nextern void __audit_log_kern_module(char *name);\nextern void __audit_fanotify(u32 response, struct fanotify_response_info_audit_rule *friar);\nextern void __audit_tk_injoffset(struct timespec64 offset);\nextern void __audit_ntp_log(const struct audit_ntp_data *ad);\nextern void __audit_log_nfcfg(const char *name, u8 af, unsigned int nentries,\n\t\t\t      enum audit_nfcfgop op, gfp_t gfp);\n\nstatic inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_ipc_obj(ipcp);\n}\nstatic inline void audit_fd_pair(int fd1, int fd2)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_fd_pair(fd1, fd2);\n}\nstatic inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_ipc_set_perm(qbytes, uid, gid, mode);\n}\nstatic inline void audit_bprm(struct linux_binprm *bprm)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_bprm(bprm);\n}\nstatic inline int audit_socketcall(int nargs, unsigned long *args)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\treturn __audit_socketcall(nargs, args);\n\treturn 0;\n}\n\nstatic inline int audit_socketcall_compat(int nargs, u32 *args)\n{\n\tunsigned long a[AUDITSC_ARGS];\n\tint i;\n\n\tif (audit_dummy_context())\n\t\treturn 0;\n\n\tfor (i = 0; i < nargs; i++)\n\t\ta[i] = (unsigned long)args[i];\n\treturn __audit_socketcall(nargs, a);\n}\n\nstatic inline int audit_sockaddr(int len, void *addr)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\treturn __audit_sockaddr(len, addr);\n\treturn 0;\n}\nstatic inline void audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_mq_open(oflag, mode, attr);\n}\nstatic inline void audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec64 *abs_timeout)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_mq_sendrecv(mqdes, msg_len, msg_prio, abs_timeout);\n}\nstatic inline void audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_mq_notify(mqdes, notification);\n}\nstatic inline void audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_mq_getsetattr(mqdes, mqstat);\n}\n\nstatic inline int audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t\t       const struct cred *new,\n\t\t\t\t       const struct cred *old)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\treturn __audit_log_bprm_fcaps(bprm, new, old);\n\treturn 0;\n}\n\nstatic inline void audit_log_capset(const struct cred *new,\n\t\t\t\t   const struct cred *old)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_log_capset(new, old);\n}\n\nstatic inline void audit_mmap_fd(int fd, int flags)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_mmap_fd(fd, flags);\n}\n\nstatic inline void audit_openat2_how(struct open_how *how)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\t__audit_openat2_how(how);\n}\n\nstatic inline void audit_log_kern_module(char *name)\n{\n\tif (!audit_dummy_context())\n\t\t__audit_log_kern_module(name);\n}\n\nstatic inline void audit_fanotify(u32 response, struct fanotify_response_info_audit_rule *friar)\n{\n\tif (!audit_dummy_context())\n\t\t__audit_fanotify(response, friar);\n}\n\nstatic inline void audit_tk_injoffset(struct timespec64 offset)\n{\n\t \n\tif (offset.tv_sec == 0 && offset.tv_nsec == 0)\n\t\treturn;\n\n\tif (!audit_dummy_context())\n\t\t__audit_tk_injoffset(offset);\n}\n\nstatic inline void audit_ntp_init(struct audit_ntp_data *ad)\n{\n\tmemset(ad, 0, sizeof(*ad));\n}\n\nstatic inline void audit_ntp_set_old(struct audit_ntp_data *ad,\n\t\t\t\t     enum audit_ntp_type type, long long val)\n{\n\tad->vals[type].oldval = val;\n}\n\nstatic inline void audit_ntp_set_new(struct audit_ntp_data *ad,\n\t\t\t\t     enum audit_ntp_type type, long long val)\n{\n\tad->vals[type].newval = val;\n}\n\nstatic inline void audit_ntp_log(const struct audit_ntp_data *ad)\n{\n\tif (!audit_dummy_context())\n\t\t__audit_ntp_log(ad);\n}\n\nstatic inline void audit_log_nfcfg(const char *name, u8 af,\n\t\t\t\t   unsigned int nentries,\n\t\t\t\t   enum audit_nfcfgop op, gfp_t gfp)\n{\n\tif (audit_enabled)\n\t\t__audit_log_nfcfg(name, af, nentries, op, gfp);\n}\n\nextern int audit_n_rules;\nextern int audit_signals;\n#else  \nstatic inline int audit_alloc(struct task_struct *task)\n{\n\treturn 0;\n}\nstatic inline void audit_free(struct task_struct *task)\n{ }\nstatic inline void audit_uring_entry(u8 op)\n{ }\nstatic inline void audit_uring_exit(int success, long code)\n{ }\nstatic inline void audit_syscall_entry(int major, unsigned long a0,\n\t\t\t\t       unsigned long a1, unsigned long a2,\n\t\t\t\t       unsigned long a3)\n{ }\nstatic inline void audit_syscall_exit(void *pt_regs)\n{ }\nstatic inline bool audit_dummy_context(void)\n{\n\treturn true;\n}\nstatic inline void audit_set_context(struct task_struct *task, struct audit_context *ctx)\n{ }\nstatic inline struct audit_context *audit_context(void)\n{\n\treturn NULL;\n}\nstatic inline struct filename *audit_reusename(const __user char *name)\n{\n\treturn NULL;\n}\nstatic inline void audit_getname(struct filename *name)\n{ }\nstatic inline void audit_inode(struct filename *name,\n\t\t\t\tconst struct dentry *dentry,\n\t\t\t\tunsigned int aflags)\n{ }\nstatic inline void audit_file(struct file *file)\n{\n}\nstatic inline void audit_inode_parent_hidden(struct filename *name,\n\t\t\t\tconst struct dentry *dentry)\n{ }\nstatic inline void audit_inode_child(struct inode *parent,\n\t\t\t\t     const struct dentry *dentry,\n\t\t\t\t     const unsigned char type)\n{ }\nstatic inline void audit_core_dumps(long signr)\n{ }\nstatic inline void audit_seccomp(unsigned long syscall, long signr, int code)\n{ }\nstatic inline void audit_seccomp_actions_logged(const char *names,\n\t\t\t\t\t\tconst char *old_names, int res)\n{ }\nstatic inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)\n{ }\nstatic inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid,\n\t\t\t\t\tgid_t gid, umode_t mode)\n{ }\nstatic inline void audit_bprm(struct linux_binprm *bprm)\n{ }\nstatic inline int audit_socketcall(int nargs, unsigned long *args)\n{\n\treturn 0;\n}\n\nstatic inline int audit_socketcall_compat(int nargs, u32 *args)\n{\n\treturn 0;\n}\n\nstatic inline void audit_fd_pair(int fd1, int fd2)\n{ }\nstatic inline int audit_sockaddr(int len, void *addr)\n{\n\treturn 0;\n}\nstatic inline void audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)\n{ }\nstatic inline void audit_mq_sendrecv(mqd_t mqdes, size_t msg_len,\n\t\t\t\t     unsigned int msg_prio,\n\t\t\t\t     const struct timespec64 *abs_timeout)\n{ }\nstatic inline void audit_mq_notify(mqd_t mqdes,\n\t\t\t\t   const struct sigevent *notification)\n{ }\nstatic inline void audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\n{ }\nstatic inline int audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t\t       const struct cred *new,\n\t\t\t\t       const struct cred *old)\n{\n\treturn 0;\n}\nstatic inline void audit_log_capset(const struct cred *new,\n\t\t\t\t    const struct cred *old)\n{ }\nstatic inline void audit_mmap_fd(int fd, int flags)\n{ }\n\nstatic inline void audit_openat2_how(struct open_how *how)\n{ }\n\nstatic inline void audit_log_kern_module(char *name)\n{\n}\n\nstatic inline void audit_fanotify(u32 response, struct fanotify_response_info_audit_rule *friar)\n{ }\n\nstatic inline void audit_tk_injoffset(struct timespec64 offset)\n{ }\n\nstatic inline void audit_ntp_init(struct audit_ntp_data *ad)\n{ }\n\nstatic inline void audit_ntp_set_old(struct audit_ntp_data *ad,\n\t\t\t\t     enum audit_ntp_type type, long long val)\n{ }\n\nstatic inline void audit_ntp_set_new(struct audit_ntp_data *ad,\n\t\t\t\t     enum audit_ntp_type type, long long val)\n{ }\n\nstatic inline void audit_ntp_log(const struct audit_ntp_data *ad)\n{ }\n\nstatic inline void audit_ptrace(struct task_struct *t)\n{ }\n\nstatic inline void audit_log_nfcfg(const char *name, u8 af,\n\t\t\t\t   unsigned int nentries,\n\t\t\t\t   enum audit_nfcfgop op, gfp_t gfp)\n{ }\n\n#define audit_n_rules 0\n#define audit_signals 0\n#endif  \n\nstatic inline bool audit_loginuid_set(struct task_struct *tsk)\n{\n\treturn uid_valid(audit_get_loginuid(tsk));\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}