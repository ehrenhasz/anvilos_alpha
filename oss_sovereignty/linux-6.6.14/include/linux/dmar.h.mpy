{
  "module_name": "dmar.h",
  "hash_id": "ab1d607fa0febf16b944b3b0cf02b4a864a99b8921c1661389889f45aeb718b7",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/dmar.h",
  "human_readable_source": " \n \n\n#ifndef __DMAR_H__\n#define __DMAR_H__\n\n#include <linux/acpi.h>\n#include <linux/types.h>\n#include <linux/msi.h>\n#include <linux/irqreturn.h>\n#include <linux/rwsem.h>\n#include <linux/rculist.h>\n\nstruct acpi_dmar_header;\n\n#define DMAR_UNITS_SUPPORTED\t1024\n\n \n#define DMAR_INTR_REMAP\t\t0x1\n#define DMAR_X2APIC_OPT_OUT\t0x2\n#define DMAR_PLATFORM_OPT_IN\t0x4\n\nstruct intel_iommu;\n\nstruct dmar_dev_scope {\n\tstruct device __rcu *dev;\n\tu8 bus;\n\tu8 devfn;\n};\n\n#ifdef CONFIG_DMAR_TABLE\nextern struct acpi_table_header *dmar_tbl;\nstruct dmar_drhd_unit {\n\tstruct list_head list;\t\t \n\tstruct  acpi_dmar_header *hdr;\t \n\tu64\treg_base_addr;\t\t \n\tunsigned long reg_size;\t\t \n\tstruct\tdmar_dev_scope *devices; \n\tint\tdevices_cnt;\t\t \n\tu16\tsegment;\t\t \n\tu8\tignored:1; \t\t \n\tu8\tinclude_all:1;\n\tu8\tgfx_dedicated:1;\t \n\tstruct intel_iommu *iommu;\n};\n\nstruct dmar_pci_path {\n\tu8 bus;\n\tu8 device;\n\tu8 function;\n};\n\nstruct dmar_pci_notify_info {\n\tstruct pci_dev\t\t\t*dev;\n\tunsigned long\t\t\tevent;\n\tint\t\t\t\tbus;\n\tu16\t\t\t\tseg;\n\tu16\t\t\t\tlevel;\n\tstruct dmar_pci_path\t\tpath[];\n}  __attribute__((packed));\n\nextern struct rw_semaphore dmar_global_lock;\nextern struct list_head dmar_drhd_units;\n\n#define for_each_drhd_unit(drhd)\t\t\t\t\t\\\n\tlist_for_each_entry_rcu(drhd, &dmar_drhd_units, list,\t\t\\\n\t\t\t\tdmar_rcu_check())\n\n#define for_each_active_drhd_unit(drhd)\t\t\t\t\t\\\n\tlist_for_each_entry_rcu(drhd, &dmar_drhd_units, list,\t\t\\\n\t\t\t\tdmar_rcu_check())\t\t\t\\\n\t\tif (drhd->ignored) {} else\n\n#define for_each_active_iommu(i, drhd)\t\t\t\t\t\\\n\tlist_for_each_entry_rcu(drhd, &dmar_drhd_units, list,\t\t\\\n\t\t\t\tdmar_rcu_check())\t\t\t\\\n\t\tif (i=drhd->iommu, drhd->ignored) {} else\n\n#define for_each_iommu(i, drhd)\t\t\t\t\t\t\\\n\tlist_for_each_entry_rcu(drhd, &dmar_drhd_units, list,\t\t\\\n\t\t\t\tdmar_rcu_check())\t\t\t\\\n\t\tif (i=drhd->iommu, 0) {} else \n\nstatic inline bool dmar_rcu_check(void)\n{\n\treturn rwsem_is_locked(&dmar_global_lock) ||\n\t       system_state == SYSTEM_BOOTING;\n}\n\n#define\tdmar_rcu_dereference(p)\trcu_dereference_check((p), dmar_rcu_check())\n\n#define for_each_dev_scope(devs, cnt, i, tmp)\t\t\t\t\\\n\tfor ((i) = 0; ((tmp) = (i) < (cnt) ?\t\t\t\t\\\n\t    dmar_rcu_dereference((devs)[(i)].dev) : NULL, (i) < (cnt)); \\\n\t    (i)++)\n\n#define for_each_active_dev_scope(devs, cnt, i, tmp)\t\t\t\\\n\tfor_each_dev_scope((devs), (cnt), (i), (tmp))\t\t\t\\\n\t\tif (!(tmp)) { continue; } else\n\nextern int dmar_table_init(void);\nextern int dmar_dev_scope_init(void);\nextern void dmar_register_bus_notifier(void);\nextern void *dmar_alloc_dev_scope(void *start, void *end, int *cnt);\nextern void dmar_free_dev_scope(struct dmar_dev_scope **devices, int *cnt);\nextern int dmar_insert_dev_scope(struct dmar_pci_notify_info *info,\n\t\t\t\t void *start, void*end, u16 segment,\n\t\t\t\t struct dmar_dev_scope *devices,\n\t\t\t\t int devices_cnt);\nextern int dmar_remove_dev_scope(struct dmar_pci_notify_info *info,\n\t\t\t\t u16 segment, struct dmar_dev_scope *devices,\n\t\t\t\t int count);\n \nvoid detect_intel_iommu(void);\nextern int enable_drhd_fault_handling(void);\nextern int dmar_device_add(acpi_handle handle);\nextern int dmar_device_remove(acpi_handle handle);\n\nstatic inline int dmar_res_noop(struct acpi_dmar_header *hdr, void *arg)\n{\n\treturn 0;\n}\n\n#ifdef CONFIG_DMAR_DEBUG\nvoid dmar_fault_dump_ptes(struct intel_iommu *iommu, u16 source_id,\n\t\t\t  unsigned long long addr, u32 pasid);\n#else\nstatic inline void dmar_fault_dump_ptes(struct intel_iommu *iommu, u16 source_id,\n\t\t\t\t\tunsigned long long addr, u32 pasid) {}\n#endif\n\n#ifdef CONFIG_INTEL_IOMMU\nextern int iommu_detected, no_iommu;\nextern int intel_iommu_init(void);\nextern void intel_iommu_shutdown(void);\nextern int dmar_parse_one_rmrr(struct acpi_dmar_header *header, void *arg);\nextern int dmar_parse_one_atsr(struct acpi_dmar_header *header, void *arg);\nextern int dmar_check_one_atsr(struct acpi_dmar_header *hdr, void *arg);\nextern int dmar_parse_one_satc(struct acpi_dmar_header *hdr, void *arg);\nextern int dmar_release_one_atsr(struct acpi_dmar_header *hdr, void *arg);\nextern int dmar_iommu_hotplug(struct dmar_drhd_unit *dmaru, bool insert);\nextern int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info);\n#else  \nstatic inline int intel_iommu_init(void) { return -ENODEV; }\nstatic inline void intel_iommu_shutdown(void) { }\n\n#define\tdmar_parse_one_rmrr\t\tdmar_res_noop\n#define\tdmar_parse_one_atsr\t\tdmar_res_noop\n#define\tdmar_check_one_atsr\t\tdmar_res_noop\n#define\tdmar_release_one_atsr\t\tdmar_res_noop\n#define\tdmar_parse_one_satc\t\tdmar_res_noop\n\nstatic inline int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info)\n{\n\treturn 0;\n}\n\nstatic inline int dmar_iommu_hotplug(struct dmar_drhd_unit *dmaru, bool insert)\n{\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_IRQ_REMAP\nextern int dmar_ir_hotplug(struct dmar_drhd_unit *dmaru, bool insert);\n#else   \nstatic inline int dmar_ir_hotplug(struct dmar_drhd_unit *dmaru, bool insert)\n{ return 0; }\n#endif  \n\nextern bool dmar_platform_optin(void);\n\n#else  \n\nstatic inline int dmar_device_add(void *handle)\n{\n\treturn 0;\n}\n\nstatic inline int dmar_device_remove(void *handle)\n{\n\treturn 0;\n}\n\nstatic inline bool dmar_platform_optin(void)\n{\n\treturn false;\n}\n\nstatic inline void detect_intel_iommu(void)\n{\n}\n\n#endif  \n\nstruct irte {\n\tunion {\n\t\tstruct {\n\t\t\tunion {\n\t\t\t\t \n\t\t\t\tstruct {\n\t\t\t\t\t__u64\tpresent\t\t: 1,   \n\t\t\t\t\t\tfpd\t\t: 1,   \n\t\t\t\t\t\t__res0\t\t: 6,   \n\t\t\t\t\t\tavail\t\t: 4,   \n\t\t\t\t\t\t__res1\t\t: 3,   \n\t\t\t\t\t\tpst\t\t: 1,   \n\t\t\t\t\t\tvector\t\t: 8,   \n\t\t\t\t\t\t__res2\t\t: 40;  \n\t\t\t\t};\n\n\t\t\t\t \n\t\t\t\tstruct {\n\t\t\t\t\t__u64\tr_present\t: 1,   \n\t\t\t\t\t\tr_fpd\t\t: 1,   \n\t\t\t\t\t\tdst_mode\t: 1,   \n\t\t\t\t\t\tredir_hint\t: 1,   \n\t\t\t\t\t\ttrigger_mode\t: 1,   \n\t\t\t\t\t\tdlvry_mode\t: 3,   \n\t\t\t\t\t\tr_avail\t\t: 4,   \n\t\t\t\t\t\tr_res0\t\t: 4,   \n\t\t\t\t\t\tr_vector\t: 8,   \n\t\t\t\t\t\tr_res1\t\t: 8,   \n\t\t\t\t\t\tdest_id\t\t: 32;  \n\t\t\t\t};\n\n\t\t\t\t \n\t\t\t\tstruct {\n\t\t\t\t\t__u64\tp_present\t: 1,   \n\t\t\t\t\t\tp_fpd\t\t: 1,   \n\t\t\t\t\t\tp_res0\t\t: 6,   \n\t\t\t\t\t\tp_avail\t\t: 4,   \n\t\t\t\t\t\tp_res1\t\t: 2,   \n\t\t\t\t\t\tp_urgent\t: 1,   \n\t\t\t\t\t\tp_pst\t\t: 1,   \n\t\t\t\t\t\tp_vector\t: 8,   \n\t\t\t\t\t\tp_res2\t\t: 14,  \n\t\t\t\t\t\tpda_l\t\t: 26;  \n\t\t\t\t};\n\t\t\t\t__u64 low;\n\t\t\t};\n\n\t\t\tunion {\n\t\t\t\t \n\t\t\t\tstruct {\n\t\t\t\t\t__u64\tsid\t\t: 16,   \n\t\t\t\t\t\tsq\t\t: 2,    \n\t\t\t\t\t\tsvt\t\t: 2,    \n\t\t\t\t\t\t__res3\t\t: 44;   \n\t\t\t\t};\n\n\t\t\t\t \n\t\t\t\tstruct {\n\t\t\t\t\t__u64\tp_sid\t\t: 16,   \n\t\t\t\t\t\tp_sq\t\t: 2,    \n\t\t\t\t\t\tp_svt\t\t: 2,    \n\t\t\t\t\t\tp_res3\t\t: 12,   \n\t\t\t\t\t\tpda_h\t\t: 32;   \n\t\t\t\t};\n\t\t\t\t__u64 high;\n\t\t\t};\n\t\t};\n#ifdef CONFIG_IRQ_REMAP\n\t\t__u128 irte;\n#endif\n\t};\n};\n\nstatic inline void dmar_copy_shared_irte(struct irte *dst, struct irte *src)\n{\n\tdst->present\t= src->present;\n\tdst->fpd\t= src->fpd;\n\tdst->avail\t= src->avail;\n\tdst->pst\t= src->pst;\n\tdst->vector\t= src->vector;\n\tdst->sid\t= src->sid;\n\tdst->sq\t\t= src->sq;\n\tdst->svt\t= src->svt;\n}\n\n#define PDA_LOW_BIT    26\n#define PDA_HIGH_BIT   32\n\n \nstruct irq_data;\nextern void dmar_msi_unmask(struct irq_data *data);\nextern void dmar_msi_mask(struct irq_data *data);\nextern void dmar_msi_read(int irq, struct msi_msg *msg);\nextern void dmar_msi_write(int irq, struct msi_msg *msg);\nextern int dmar_set_interrupt(struct intel_iommu *iommu);\nextern irqreturn_t dmar_fault(int irq, void *dev_id);\nextern int dmar_alloc_hwirq(int id, int node, void *arg);\nextern void dmar_free_hwirq(int irq);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}