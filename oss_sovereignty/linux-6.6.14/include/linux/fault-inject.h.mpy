{
  "module_name": "fault-inject.h",
  "hash_id": "9135aa51340b1fe499a59f9d6f32792ec70e325d66ba1830dcd895416d17111a",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fault-inject.h",
  "human_readable_source": " \n#ifndef _LINUX_FAULT_INJECT_H\n#define _LINUX_FAULT_INJECT_H\n\n#ifdef CONFIG_FAULT_INJECTION\n\n#include <linux/types.h>\n#include <linux/debugfs.h>\n#include <linux/configfs.h>\n#include <linux/ratelimit.h>\n#include <linux/atomic.h>\n\n \nstruct fault_attr {\n\tunsigned long probability;\n\tunsigned long interval;\n\tatomic_t times;\n\tatomic_t space;\n\tunsigned long verbose;\n\tbool task_filter;\n\tunsigned long stacktrace_depth;\n\tunsigned long require_start;\n\tunsigned long require_end;\n\tunsigned long reject_start;\n\tunsigned long reject_end;\n\n\tunsigned long count;\n\tstruct ratelimit_state ratelimit_state;\n\tstruct dentry *dname;\n};\n\nenum fault_flags {\n\tFAULT_NOWARN =\t1 << 0,\n};\n\n#define FAULT_ATTR_INITIALIZER {\t\t\t\t\t\\\n\t\t.interval = 1,\t\t\t\t\t\t\\\n\t\t.times = ATOMIC_INIT(1),\t\t\t\t\\\n\t\t.require_end = ULONG_MAX,\t\t\t\t\\\n\t\t.stacktrace_depth = 32,\t\t\t\t\t\\\n\t\t.ratelimit_state = RATELIMIT_STATE_INIT_DISABLED,\t\\\n\t\t.verbose = 2,\t\t\t\t\t\t\\\n\t\t.dname = NULL,\t\t\t\t\t\t\\\n\t}\n\n#define DECLARE_FAULT_ATTR(name) struct fault_attr name = FAULT_ATTR_INITIALIZER\nint setup_fault_attr(struct fault_attr *attr, char *str);\nbool should_fail_ex(struct fault_attr *attr, ssize_t size, int flags);\nbool should_fail(struct fault_attr *attr, ssize_t size);\n\n#ifdef CONFIG_FAULT_INJECTION_DEBUG_FS\n\nstruct dentry *fault_create_debugfs_attr(const char *name,\n\t\t\tstruct dentry *parent, struct fault_attr *attr);\n\n#else  \n\nstatic inline struct dentry *fault_create_debugfs_attr(const char *name,\n\t\t\tstruct dentry *parent, struct fault_attr *attr)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n\n#endif  \n\n#ifdef CONFIG_FAULT_INJECTION_CONFIGFS\n\nstruct fault_config {\n\tstruct fault_attr attr;\n\tstruct config_group group;\n};\n\nvoid fault_config_init(struct fault_config *config, const char *name);\n\n#else  \n\nstruct fault_config {\n};\n\nstatic inline void fault_config_init(struct fault_config *config,\n\t\t\tconst char *name)\n{\n}\n\n#endif  \n\n#endif  \n\nstruct kmem_cache;\n\nbool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order);\n\n#ifdef CONFIG_FAIL_PAGE_ALLOC\nbool __should_fail_alloc_page(gfp_t gfp_mask, unsigned int order);\n#else\nstatic inline bool __should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)\n{\n\treturn false;\n}\n#endif  \n\nint should_failslab(struct kmem_cache *s, gfp_t gfpflags);\n#ifdef CONFIG_FAILSLAB\nextern bool __should_failslab(struct kmem_cache *s, gfp_t gfpflags);\n#else\nstatic inline bool __should_failslab(struct kmem_cache *s, gfp_t gfpflags)\n{\n\treturn false;\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}