{
  "module_name": "sched.h",
  "hash_id": "50d86c29b8af91a0a9dcc8e0973cd599071f5fbec73df93f25722423e9cd1444",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/sunrpc/sched.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_SUNRPC_SCHED_H_\n#define _LINUX_SUNRPC_SCHED_H_\n\n#include <linux/timer.h>\n#include <linux/ktime.h>\n#include <linux/sunrpc/types.h>\n#include <linux/spinlock.h>\n#include <linux/wait_bit.h>\n#include <linux/workqueue.h>\n#include <linux/sunrpc/xdr.h>\n\n \nstruct rpc_procinfo;\nstruct rpc_message {\n\tconst struct rpc_procinfo *rpc_proc;\t \n\tvoid *\t\t\trpc_argp;\t \n\tvoid *\t\t\trpc_resp;\t \n\tconst struct cred *\trpc_cred;\t \n};\n\nstruct rpc_call_ops;\nstruct rpc_wait_queue;\nstruct rpc_wait {\n\tstruct list_head\tlist;\t\t \n\tstruct list_head\tlinks;\t\t \n\tstruct list_head\ttimer_list;\t \n};\n\n \nstruct rpc_task {\n\tatomic_t\t\ttk_count;\t \n\tint\t\t\ttk_status;\t \n\tstruct list_head\ttk_task;\t \n\n\t \n\tvoid\t\t\t(*tk_callback)(struct rpc_task *);\n\tvoid\t\t\t(*tk_action)(struct rpc_task *);\n\n\tunsigned long\t\ttk_timeout;\t \n\tunsigned long\t\ttk_runstate;\t \n\n\tstruct rpc_wait_queue \t*tk_waitqueue;\t \n\tunion {\n\t\tstruct work_struct\ttk_work;\t \n\t\tstruct rpc_wait\t\ttk_wait;\t \n\t} u;\n\n\t \n\tstruct rpc_message\ttk_msg;\t\t \n\tvoid *\t\t\ttk_calldata;\t \n\tconst struct rpc_call_ops *tk_ops;\t \n\n\tstruct rpc_clnt *\ttk_client;\t \n\tstruct rpc_xprt *\ttk_xprt;\t \n\tstruct rpc_cred *\ttk_op_cred;\t \n\n\tstruct rpc_rqst *\ttk_rqstp;\t \n\n\tstruct workqueue_struct\t*tk_workqueue;\t \n\tktime_t\t\t\ttk_start;\t \n\n\tpid_t\t\t\ttk_owner;\t \n\n\tint\t\t\ttk_rpc_status;\t \n\tunsigned short\t\ttk_flags;\t \n\tunsigned short\t\ttk_timeouts;\t \n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG) || IS_ENABLED(CONFIG_TRACEPOINTS)\n\tunsigned short\t\ttk_pid;\t\t \n#endif\n\tunsigned char\t\ttk_priority : 2, \n\t\t\t\ttk_garb_retry : 2,\n\t\t\t\ttk_cred_retry : 2;\n};\n\ntypedef void\t\t\t(*rpc_action)(struct rpc_task *);\n\nstruct rpc_call_ops {\n\tvoid (*rpc_call_prepare)(struct rpc_task *, void *);\n\tvoid (*rpc_call_done)(struct rpc_task *, void *);\n\tvoid (*rpc_count_stats)(struct rpc_task *, void *);\n\tvoid (*rpc_release)(void *);\n};\n\nstruct rpc_task_setup {\n\tstruct rpc_task *task;\n\tstruct rpc_clnt *rpc_client;\n\tstruct rpc_xprt *rpc_xprt;\n\tstruct rpc_cred *rpc_op_cred;\t \n\tconst struct rpc_message *rpc_message;\n\tconst struct rpc_call_ops *callback_ops;\n\tvoid *callback_data;\n\tstruct workqueue_struct *workqueue;\n\tunsigned short flags;\n\tsigned char priority;\n};\n\n \n#define RPC_TASK_ASYNC\t\t0x0001\t\t \n#define RPC_TASK_SWAPPER\t0x0002\t\t \n#define RPC_TASK_MOVEABLE\t0x0004\t\t \n#define RPC_TASK_NULLCREDS\t0x0010\t\t \n#define RPC_CALL_MAJORSEEN\t0x0020\t\t \n#define RPC_TASK_DYNAMIC\t0x0080\t\t \n#define\tRPC_TASK_NO_ROUND_ROBIN\t0x0100\t\t \n#define RPC_TASK_SOFT\t\t0x0200\t\t \n#define RPC_TASK_SOFTCONN\t0x0400\t\t \n#define RPC_TASK_SENT\t\t0x0800\t\t \n#define RPC_TASK_TIMEOUT\t0x1000\t\t \n#define RPC_TASK_NOCONNECT\t0x2000\t\t \n#define RPC_TASK_NO_RETRANS_TIMEOUT\t0x4000\t\t \n#define RPC_TASK_CRED_NOREF\t0x8000\t\t \n\n#define RPC_IS_ASYNC(t)\t\t((t)->tk_flags & RPC_TASK_ASYNC)\n#define RPC_IS_SWAPPER(t)\t((t)->tk_flags & RPC_TASK_SWAPPER)\n#define RPC_IS_SOFT(t)\t\t((t)->tk_flags & (RPC_TASK_SOFT|RPC_TASK_TIMEOUT))\n#define RPC_IS_SOFTCONN(t)\t((t)->tk_flags & RPC_TASK_SOFTCONN)\n#define RPC_WAS_SENT(t)\t\t((t)->tk_flags & RPC_TASK_SENT)\n#define RPC_IS_MOVEABLE(t)\t((t)->tk_flags & RPC_TASK_MOVEABLE)\n\n#define RPC_TASK_RUNNING\t0\n#define RPC_TASK_QUEUED\t\t1\n#define RPC_TASK_ACTIVE\t\t2\n#define RPC_TASK_NEED_XMIT\t3\n#define RPC_TASK_NEED_RECV\t4\n#define RPC_TASK_MSG_PIN_WAIT\t5\n#define RPC_TASK_SIGNALLED\t6\n\n#define rpc_test_and_set_running(t) \\\n\t\t\t\ttest_and_set_bit(RPC_TASK_RUNNING, &(t)->tk_runstate)\n#define rpc_clear_running(t)\tclear_bit(RPC_TASK_RUNNING, &(t)->tk_runstate)\n\n#define RPC_IS_QUEUED(t)\ttest_bit(RPC_TASK_QUEUED, &(t)->tk_runstate)\n#define rpc_set_queued(t)\tset_bit(RPC_TASK_QUEUED, &(t)->tk_runstate)\n#define rpc_clear_queued(t)\tclear_bit(RPC_TASK_QUEUED, &(t)->tk_runstate)\n\n#define RPC_IS_ACTIVATED(t)\ttest_bit(RPC_TASK_ACTIVE, &(t)->tk_runstate)\n\n#define RPC_SIGNALLED(t)\ttest_bit(RPC_TASK_SIGNALLED, &(t)->tk_runstate)\n\n \n#define RPC_PRIORITY_LOW\t(-1)\n#define RPC_PRIORITY_NORMAL\t(0)\n#define RPC_PRIORITY_HIGH\t(1)\n#define RPC_PRIORITY_PRIVILEGED\t(2)\n#define RPC_NR_PRIORITY\t\t(1 + RPC_PRIORITY_PRIVILEGED - RPC_PRIORITY_LOW)\n\nstruct rpc_timer {\n\tstruct list_head list;\n\tunsigned long expires;\n\tstruct delayed_work dwork;\n};\n\n \nstruct rpc_wait_queue {\n\tspinlock_t\t\tlock;\n\tstruct list_head\ttasks[RPC_NR_PRIORITY];\t \n\tunsigned char\t\tmaxpriority;\t\t \n\tunsigned char\t\tpriority;\t\t \n\tunsigned char\t\tnr;\t\t\t \n\tunsigned short\t\tqlen;\t\t\t \n\tstruct rpc_timer\ttimer_list;\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG) || IS_ENABLED(CONFIG_TRACEPOINTS)\n\tconst char *\t\tname;\n#endif\n};\n\n \n#define RPC_IS_PRIORITY(q)\t\t((q)->maxpriority > 0)\n\n \nstruct rpc_task *rpc_new_task(const struct rpc_task_setup *);\nstruct rpc_task *rpc_run_task(const struct rpc_task_setup *);\nstruct rpc_task *rpc_run_bc_task(struct rpc_rqst *req);\nvoid\t\trpc_put_task(struct rpc_task *);\nvoid\t\trpc_put_task_async(struct rpc_task *);\nbool\t\trpc_task_set_rpc_status(struct rpc_task *task, int rpc_status);\nvoid\t\trpc_task_try_cancel(struct rpc_task *task, int error);\nvoid\t\trpc_signal_task(struct rpc_task *);\nvoid\t\trpc_exit_task(struct rpc_task *);\nvoid\t\trpc_exit(struct rpc_task *, int);\nvoid\t\trpc_release_calldata(const struct rpc_call_ops *, void *);\nvoid\t\trpc_killall_tasks(struct rpc_clnt *);\nunsigned long\trpc_cancel_tasks(struct rpc_clnt *clnt, int error,\n\t\t\t\t bool (*fnmatch)(const struct rpc_task *,\n\t\t\t\t\t\t const void *),\n\t\t\t\t const void *data);\nvoid\t\trpc_execute(struct rpc_task *);\nvoid\t\trpc_init_priority_wait_queue(struct rpc_wait_queue *, const char *);\nvoid\t\trpc_init_wait_queue(struct rpc_wait_queue *, const char *);\nvoid\t\trpc_destroy_wait_queue(struct rpc_wait_queue *);\nunsigned long\trpc_task_timeout(const struct rpc_task *task);\nvoid\t\trpc_sleep_on_timeout(struct rpc_wait_queue *queue,\n\t\t\t\t\tstruct rpc_task *task,\n\t\t\t\t\trpc_action action,\n\t\t\t\t\tunsigned long timeout);\nvoid\t\trpc_sleep_on(struct rpc_wait_queue *, struct rpc_task *,\n\t\t\t\t\trpc_action action);\nvoid\t\trpc_sleep_on_priority_timeout(struct rpc_wait_queue *queue,\n\t\t\t\t\tstruct rpc_task *task,\n\t\t\t\t\tunsigned long timeout,\n\t\t\t\t\tint priority);\nvoid\t\trpc_sleep_on_priority(struct rpc_wait_queue *,\n\t\t\t\t\tstruct rpc_task *,\n\t\t\t\t\tint priority);\nvoid\t\trpc_wake_up_queued_task(struct rpc_wait_queue *,\n\t\t\t\t\tstruct rpc_task *);\nvoid\t\trpc_wake_up_queued_task_set_status(struct rpc_wait_queue *,\n\t\t\t\t\t\t   struct rpc_task *,\n\t\t\t\t\t\t   int);\nvoid\t\trpc_wake_up(struct rpc_wait_queue *);\nstruct rpc_task *rpc_wake_up_next(struct rpc_wait_queue *);\nstruct rpc_task *rpc_wake_up_first_on_wq(struct workqueue_struct *wq,\n\t\t\t\t\tstruct rpc_wait_queue *,\n\t\t\t\t\tbool (*)(struct rpc_task *, void *),\n\t\t\t\t\tvoid *);\nstruct rpc_task *rpc_wake_up_first(struct rpc_wait_queue *,\n\t\t\t\t\tbool (*)(struct rpc_task *, void *),\n\t\t\t\t\tvoid *);\nvoid\t\trpc_wake_up_status(struct rpc_wait_queue *, int);\nvoid\t\trpc_delay(struct rpc_task *, unsigned long);\nint\t\trpc_malloc(struct rpc_task *);\nvoid\t\trpc_free(struct rpc_task *);\nint\t\trpciod_up(void);\nvoid\t\trpciod_down(void);\nint\t\trpc_wait_for_completion_task(struct rpc_task *task);\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\nstruct net;\nvoid\t\trpc_show_tasks(struct net *);\n#endif\nint\t\trpc_init_mempool(void);\nvoid\t\trpc_destroy_mempool(void);\nextern struct workqueue_struct *rpciod_workqueue;\nextern struct workqueue_struct *xprtiod_workqueue;\nvoid\t\trpc_prepare_task(struct rpc_task *task);\ngfp_t\t\trpc_task_gfp_mask(void);\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG) || IS_ENABLED(CONFIG_TRACEPOINTS)\nstatic inline const char * rpc_qname(const struct rpc_wait_queue *q)\n{\n\treturn ((q && q->name) ? q->name : \"unknown\");\n}\n\nstatic inline void rpc_assign_waitqueue_name(struct rpc_wait_queue *q,\n\t\tconst char *name)\n{\n\tq->name = name;\n}\n#else\nstatic inline void rpc_assign_waitqueue_name(struct rpc_wait_queue *q,\n\t\tconst char *name)\n{\n}\n#endif\n\n#if IS_ENABLED(CONFIG_SUNRPC_SWAP)\nint rpc_clnt_swap_activate(struct rpc_clnt *clnt);\nvoid rpc_clnt_swap_deactivate(struct rpc_clnt *clnt);\n#else\nstatic inline int\nrpc_clnt_swap_activate(struct rpc_clnt *clnt)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void\nrpc_clnt_swap_deactivate(struct rpc_clnt *clnt)\n{\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}