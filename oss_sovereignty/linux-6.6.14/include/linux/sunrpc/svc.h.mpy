{
  "module_name": "svc.h",
  "hash_id": "6984361b46011e1950618d46d0d43ddf0856b9d5c1529a210208241f34cbbafa",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/sunrpc/svc.h",
  "human_readable_source": " \n \n\n\n#ifndef SUNRPC_SVC_H\n#define SUNRPC_SVC_H\n\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/sunrpc/types.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/svcauth.h>\n#include <linux/wait.h>\n#include <linux/mm.h>\n#include <linux/pagevec.h>\n\n \nstruct svc_pool {\n\tunsigned int\t\tsp_id;\t    \t \n\tspinlock_t\t\tsp_lock;\t \n\tstruct list_head\tsp_sockets;\t \n\tunsigned int\t\tsp_nrthreads;\t \n\tstruct list_head\tsp_all_threads;\t \n\n\t \n\tstruct percpu_counter\tsp_messages_arrived;\n\tstruct percpu_counter\tsp_sockets_queued;\n\tstruct percpu_counter\tsp_threads_woken;\n\n\tunsigned long\t\tsp_flags;\n} ____cacheline_aligned_in_smp;\n\n \nenum {\n\tSP_TASK_PENDING,\t \n\tSP_CONGESTED,\t\t \n};\n\n\n \nstruct svc_serv {\n\tstruct svc_program *\tsv_program;\t \n\tstruct svc_stat *\tsv_stats;\t \n\tspinlock_t\t\tsv_lock;\n\tstruct kref\t\tsv_refcnt;\n\tunsigned int\t\tsv_nrthreads;\t \n\tunsigned int\t\tsv_maxconn;\t \n\n\tunsigned int\t\tsv_max_payload;\t \n\tunsigned int\t\tsv_max_mesg;\t \n\tunsigned int\t\tsv_xdrsize;\t \n\tstruct list_head\tsv_permsocks;\t \n\tstruct list_head\tsv_tempsocks;\t \n\tint\t\t\tsv_tmpcnt;\t \n\tstruct timer_list\tsv_temptimer;\t \n\n\tchar *\t\t\tsv_name;\t \n\n\tunsigned int\t\tsv_nrpools;\t \n\tstruct svc_pool *\tsv_pools;\t \n\tint\t\t\t(*sv_threadfn)(void *data);\n\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\n\tstruct list_head\tsv_cb_list;\t \n\tspinlock_t\t\tsv_cb_lock;\t \n\twait_queue_head_t\tsv_cb_waitq;\t \n\tbool\t\t\tsv_bc_enabled;\t \n#endif  \n};\n\n \nstatic inline struct svc_serv *svc_get(struct svc_serv *serv)\n{\n\tkref_get(&serv->sv_refcnt);\n\treturn serv;\n}\n\nvoid svc_destroy(struct kref *);\n\n \nstatic inline void svc_put(struct svc_serv *serv)\n{\n\tkref_put(&serv->sv_refcnt, svc_destroy);\n}\n\n \n#define RPCSVC_MAXPAYLOAD\t(1*1024*1024u)\n#define RPCSVC_MAXPAYLOAD_TCP\tRPCSVC_MAXPAYLOAD\n#define RPCSVC_MAXPAYLOAD_UDP\t(32*1024u)\n\nextern u32 svc_max_payload(const struct svc_rqst *rqstp);\n\n \n#define RPCSVC_MAXPAGES\t\t((RPCSVC_MAXPAYLOAD+PAGE_SIZE-1)/PAGE_SIZE \\\n\t\t\t\t+ 2 + 1)\n\n \nstruct svc_rqst {\n\tstruct list_head\trq_all;\t\t \n\tstruct rcu_head\t\trq_rcu_head;\t \n\tstruct svc_xprt *\trq_xprt;\t \n\n\tstruct sockaddr_storage\trq_addr;\t \n\tsize_t\t\t\trq_addrlen;\n\tstruct sockaddr_storage\trq_daddr;\t \n\tsize_t\t\t\trq_daddrlen;\n\n\tstruct svc_serv *\trq_server;\t \n\tstruct svc_pool *\trq_pool;\t \n\tconst struct svc_procedure *rq_procinfo; \n\tstruct auth_ops *\trq_authop;\t \n\tstruct svc_cred\t\trq_cred;\t \n\tvoid *\t\t\trq_xprt_ctxt;\t \n\tstruct svc_deferred_req*rq_deferred;\t \n\n\tstruct xdr_buf\t\trq_arg;\n\tstruct xdr_stream\trq_arg_stream;\n\tstruct xdr_stream\trq_res_stream;\n\tstruct page\t\t*rq_scratch_page;\n\tstruct xdr_buf\t\trq_res;\n\tstruct page\t\t*rq_pages[RPCSVC_MAXPAGES + 1];\n\tstruct page *\t\t*rq_respages;\t \n\tstruct page *\t\t*rq_next_page;  \n\tstruct page *\t\t*rq_page_end;   \n\n\tstruct folio_batch\trq_fbatch;\n\tstruct kvec\t\trq_vec[RPCSVC_MAXPAGES];  \n\tstruct bio_vec\t\trq_bvec[RPCSVC_MAXPAGES];\n\n\t__be32\t\t\trq_xid;\t\t \n\tu32\t\t\trq_prog;\t \n\tu32\t\t\trq_vers;\t \n\tu32\t\t\trq_proc;\t \n\tu32\t\t\trq_prot;\t \n\tint\t\t\trq_cachetype;\t \n\tunsigned long\t\trq_flags;\t \n\tktime_t\t\t\trq_qtime;\t \n\n\tvoid *\t\t\trq_argp;\t \n\tvoid *\t\t\trq_resp;\t \n\t__be32\t\t\t*rq_accept_statp;\n\tvoid *\t\t\trq_auth_data;\t \n\t__be32\t\t\trq_auth_stat;\t \n\tint\t\t\trq_auth_slack;\t \n\tint\t\t\trq_reserved;\t \n\tktime_t\t\t\trq_stime;\t \n\n\tstruct cache_req\trq_chandle;\t \n\t \n\tstruct auth_domain *\trq_client;\t \n\tstruct auth_domain *\trq_gssclient;\t \n\tstruct task_struct\t*rq_task;\t \n\tstruct net\t\t*rq_bc_net;\t \n\tvoid **\t\t\trq_lease_breaker;  \n};\n\n \nenum {\n\tRQ_SECURE,\t\t \n\tRQ_LOCAL,\t\t \n\tRQ_USEDEFERRAL,\t\t \n\tRQ_DROPME,\t\t \n\tRQ_SPLICE_OK,\t\t \n\tRQ_VICTIM,\t\t \n\tRQ_BUSY,\t\t \n\tRQ_DATA,\t\t \n};\n\n#define SVC_NET(rqst) (rqst->rq_xprt ? rqst->rq_xprt->xpt_net : rqst->rq_bc_net)\n\n \nstatic inline struct sockaddr_in *svc_addr_in(const struct svc_rqst *rqst)\n{\n\treturn (struct sockaddr_in *) &rqst->rq_addr;\n}\n\nstatic inline struct sockaddr_in6 *svc_addr_in6(const struct svc_rqst *rqst)\n{\n\treturn (struct sockaddr_in6 *) &rqst->rq_addr;\n}\n\nstatic inline struct sockaddr *svc_addr(const struct svc_rqst *rqst)\n{\n\treturn (struct sockaddr *) &rqst->rq_addr;\n}\n\nstatic inline struct sockaddr_in *svc_daddr_in(const struct svc_rqst *rqst)\n{\n\treturn (struct sockaddr_in *) &rqst->rq_daddr;\n}\n\nstatic inline struct sockaddr_in6 *svc_daddr_in6(const struct svc_rqst *rqst)\n{\n\treturn (struct sockaddr_in6 *) &rqst->rq_daddr;\n}\n\nstatic inline struct sockaddr *svc_daddr(const struct svc_rqst *rqst)\n{\n\treturn (struct sockaddr *) &rqst->rq_daddr;\n}\n\nstruct svc_deferred_req {\n\tu32\t\t\tprot;\t \n\tstruct svc_xprt\t\t*xprt;\n\tstruct sockaddr_storage\taddr;\t \n\tsize_t\t\t\taddrlen;\n\tstruct sockaddr_storage\tdaddr;\t \n\tsize_t\t\t\tdaddrlen;\n\tvoid\t\t\t*xprt_ctxt;\n\tstruct cache_deferred_req handle;\n\tint\t\t\targslen;\n\t__be32\t\t\targs[];\n};\n\nstruct svc_process_info {\n\tunion {\n\t\tint  (*dispatch)(struct svc_rqst *rqstp);\n\t\tstruct {\n\t\t\tunsigned int lovers;\n\t\t\tunsigned int hivers;\n\t\t} mismatch;\n\t};\n};\n\n \nstruct svc_program {\n\tstruct svc_program *\tpg_next;\t \n\tu32\t\t\tpg_prog;\t \n\tunsigned int\t\tpg_lovers;\t \n\tunsigned int\t\tpg_hivers;\t \n\tunsigned int\t\tpg_nvers;\t \n\tconst struct svc_version **pg_vers;\t \n\tchar *\t\t\tpg_name;\t \n\tchar *\t\t\tpg_class;\t \n\tstruct svc_stat *\tpg_stats;\t \n\tenum svc_auth_status\t(*pg_authenticate)(struct svc_rqst *rqstp);\n\t__be32\t\t\t(*pg_init_request)(struct svc_rqst *,\n\t\t\t\t\t\t   const struct svc_program *,\n\t\t\t\t\t\t   struct svc_process_info *);\n\tint\t\t\t(*pg_rpcbind_set)(struct net *net,\n\t\t\t\t\t\t  const struct svc_program *,\n\t\t\t\t\t\t  u32 version, int family,\n\t\t\t\t\t\t  unsigned short proto,\n\t\t\t\t\t\t  unsigned short port);\n};\n\n \nstruct svc_version {\n\tu32\t\t\tvs_vers;\t \n\tu32\t\t\tvs_nproc;\t \n\tconst struct svc_procedure *vs_proc;\t \n\tunsigned long __percpu\t*vs_count;\t \n\tu32\t\t\tvs_xdrsize;\t \n\n\t \n\tbool\t\t\tvs_hidden;\n\n\t \n\tbool\t\t\tvs_rpcb_optnl;\n\n\t \n\tbool\t\t\tvs_need_cong_ctrl;\n\n\t \n\tint\t\t\t(*vs_dispatch)(struct svc_rqst *rqstp);\n};\n\n \nstruct svc_procedure {\n\t \n\t__be32\t\t\t(*pc_func)(struct svc_rqst *);\n\t \n\tbool\t\t\t(*pc_decode)(struct svc_rqst *rqstp,\n\t\t\t\t\t     struct xdr_stream *xdr);\n\t \n\tbool\t\t\t(*pc_encode)(struct svc_rqst *rqstp,\n\t\t\t\t\t     struct xdr_stream *xdr);\n\t \n\tvoid\t\t\t(*pc_release)(struct svc_rqst *);\n\tunsigned int\t\tpc_argsize;\t \n\tunsigned int\t\tpc_argzero;\t \n\tunsigned int\t\tpc_ressize;\t \n\tunsigned int\t\tpc_cachetype;\t \n\tunsigned int\t\tpc_xdrressize;\t \n\tconst char *\t\tpc_name;\t \n};\n\n \nint svc_rpcb_setup(struct svc_serv *serv, struct net *net);\nvoid svc_rpcb_cleanup(struct svc_serv *serv, struct net *net);\nint svc_bind(struct svc_serv *serv, struct net *net);\nstruct svc_serv *svc_create(struct svc_program *, unsigned int,\n\t\t\t    int (*threadfn)(void *data));\nstruct svc_rqst *svc_rqst_alloc(struct svc_serv *serv,\n\t\t\t\t\tstruct svc_pool *pool, int node);\nbool\t\t   svc_rqst_replace_page(struct svc_rqst *rqstp,\n\t\t\t\t\t struct page *page);\nvoid\t\t   svc_rqst_release_pages(struct svc_rqst *rqstp);\nvoid\t\t   svc_rqst_free(struct svc_rqst *);\nvoid\t\t   svc_exit_thread(struct svc_rqst *);\nstruct svc_serv *  svc_create_pooled(struct svc_program *, unsigned int,\n\t\t\t\t     int (*threadfn)(void *data));\nint\t\t   svc_set_num_threads(struct svc_serv *, struct svc_pool *, int);\nint\t\t   svc_pool_stats_open(struct svc_serv *serv, struct file *file);\nvoid\t\t   svc_process(struct svc_rqst *rqstp);\nint\t\t   bc_svc_process(struct svc_serv *, struct rpc_rqst *,\n\t\t\tstruct svc_rqst *);\nint\t\t   svc_register(const struct svc_serv *, struct net *, const int,\n\t\t\t\tconst unsigned short, const unsigned short);\n\nvoid\t\t   svc_wake_up(struct svc_serv *);\nvoid\t\t   svc_reserve(struct svc_rqst *rqstp, int space);\nvoid\t\t   svc_pool_wake_idle_thread(struct svc_pool *pool);\nstruct svc_pool   *svc_pool_for_cpu(struct svc_serv *serv);\nchar *\t\t   svc_print_addr(struct svc_rqst *, char *, size_t);\nconst char *\t   svc_proc_name(const struct svc_rqst *rqstp);\nint\t\t   svc_encode_result_payload(struct svc_rqst *rqstp,\n\t\t\t\t\t     unsigned int offset,\n\t\t\t\t\t     unsigned int length);\nunsigned int\t   svc_fill_write_vector(struct svc_rqst *rqstp,\n\t\t\t\t\t struct xdr_buf *payload);\nchar\t\t  *svc_fill_symlink_pathname(struct svc_rqst *rqstp,\n\t\t\t\t\t     struct kvec *first, void *p,\n\t\t\t\t\t     size_t total);\n__be32\t\t   svc_generic_init_request(struct svc_rqst *rqstp,\n\t\t\t\t\t    const struct svc_program *progp,\n\t\t\t\t\t    struct svc_process_info *procinfo);\nint\t\t   svc_generic_rpcbind_set(struct net *net,\n\t\t\t\t\t   const struct svc_program *progp,\n\t\t\t\t\t   u32 version, int family,\n\t\t\t\t\t   unsigned short proto,\n\t\t\t\t\t   unsigned short port);\nint\t\t   svc_rpcbind_set_version(struct net *net,\n\t\t\t\t\t   const struct svc_program *progp,\n\t\t\t\t\t   u32 version, int family,\n\t\t\t\t\t   unsigned short proto,\n\t\t\t\t\t   unsigned short port);\n\n#define\tRPC_MAX_ADDRBUFLEN\t(63U)\n\n \nstatic inline void svc_reserve_auth(struct svc_rqst *rqstp, int space)\n{\n\tsvc_reserve(rqstp, space + rqstp->rq_auth_slack);\n}\n\n \nstatic inline void svcxdr_init_decode(struct svc_rqst *rqstp)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_arg_stream;\n\tstruct xdr_buf *buf = &rqstp->rq_arg;\n\tstruct kvec *argv = buf->head;\n\n\tWARN_ON(buf->len != buf->head->iov_len + buf->page_len + buf->tail->iov_len);\n\tbuf->len = buf->head->iov_len + buf->page_len + buf->tail->iov_len;\n\n\txdr_init_decode(xdr, buf, argv->iov_base, NULL);\n\txdr_set_scratch_page(xdr, rqstp->rq_scratch_page);\n}\n\n \nstatic inline void svcxdr_init_encode(struct svc_rqst *rqstp)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_res_stream;\n\tstruct xdr_buf *buf = &rqstp->rq_res;\n\tstruct kvec *resv = buf->head;\n\n\txdr_reset_scratch_buffer(xdr);\n\n\txdr->buf = buf;\n\txdr->iov = resv;\n\txdr->p   = resv->iov_base + resv->iov_len;\n\txdr->end = resv->iov_base + PAGE_SIZE;\n\tbuf->len = resv->iov_len;\n\txdr->page_ptr = buf->pages - 1;\n\tbuf->buflen = PAGE_SIZE * (rqstp->rq_page_end - buf->pages);\n\txdr->rqst = NULL;\n}\n\n \nstatic inline void svcxdr_encode_opaque_pages(struct svc_rqst *rqstp,\n\t\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t\t      struct page **pages,\n\t\t\t\t\t      unsigned int base,\n\t\t\t\t\t      unsigned int len)\n{\n\txdr_write_pages(xdr, pages, base, len);\n\txdr->page_ptr = rqstp->rq_next_page - 1;\n}\n\n \nstatic inline void svcxdr_set_auth_slack(struct svc_rqst *rqstp, int slack)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_res_stream;\n\tstruct xdr_buf *buf = &rqstp->rq_res;\n\tstruct kvec *resv = buf->head;\n\n\trqstp->rq_auth_slack = slack;\n\n\txdr->end -= XDR_QUADLEN(slack);\n\tbuf->buflen -= rqstp->rq_auth_slack;\n\n\tWARN_ON(xdr->iov != resv);\n\tWARN_ON(xdr->p > xdr->end);\n}\n\n \nstatic inline bool svcxdr_set_accept_stat(struct svc_rqst *rqstp)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_res_stream;\n\n\trqstp->rq_accept_statp = xdr_reserve_space(xdr, XDR_UNIT);\n\tif (unlikely(!rqstp->rq_accept_statp))\n\t\treturn false;\n\t*rqstp->rq_accept_statp = rpc_success;\n\treturn true;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}