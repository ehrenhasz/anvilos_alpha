{
  "module_name": "xdr.h",
  "hash_id": "13454b1b4997b6229ce0a6354592888ec3ab6c37f0962486bea6955f60fcdecc",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/sunrpc/xdr.h",
  "human_readable_source": " \n \n\n#ifndef _SUNRPC_XDR_H_\n#define _SUNRPC_XDR_H_\n\n#include <linux/uio.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <linux/scatterlist.h>\n\nstruct bio_vec;\nstruct rpc_rqst;\n\n \n#define XDR_UNIT\t\tsizeof(__be32)\n\n \n#define XDR_QUADLEN(l)\t\t(((l) + 3) >> 2)\n\n \n#define XDR_MAX_NETOBJ\t\t1024\nstruct xdr_netobj {\n\tunsigned int\t\tlen;\n\tu8 *\t\t\tdata;\n};\n\n \nstruct xdr_buf {\n\tstruct kvec\thead[1],\t \n\t\t\ttail[1];\t \n\n\tstruct bio_vec\t*bvec;\n\tstruct page **\tpages;\t\t \n\tunsigned int\tpage_base,\t \n\t\t\tpage_len,\t \n\t\t\tflags;\t\t \n#define XDRBUF_READ\t\t0x01\t\t \n#define XDRBUF_WRITE\t\t0x02\t\t \n#define XDRBUF_SPARSE_PAGES\t0x04\t\t \n\n\tunsigned int\tbuflen,\t\t \n\t\t\tlen;\t\t \n};\n\nstatic inline void\nxdr_buf_init(struct xdr_buf *buf, void *start, size_t len)\n{\n\tbuf->head[0].iov_base = start;\n\tbuf->head[0].iov_len = len;\n\tbuf->tail[0].iov_len = 0;\n\tbuf->pages = NULL;\n\tbuf->page_len = 0;\n\tbuf->flags = 0;\n\tbuf->len = 0;\n\tbuf->buflen = len;\n}\n\n \n\n#define\txdr_zero\tcpu_to_be32(0)\n#define\txdr_one\t\tcpu_to_be32(1)\n#define\txdr_two\t\tcpu_to_be32(2)\n\n#define\trpc_auth_null\tcpu_to_be32(RPC_AUTH_NULL)\n#define\trpc_auth_unix\tcpu_to_be32(RPC_AUTH_UNIX)\n#define\trpc_auth_short\tcpu_to_be32(RPC_AUTH_SHORT)\n#define\trpc_auth_gss\tcpu_to_be32(RPC_AUTH_GSS)\n#define\trpc_auth_tls\tcpu_to_be32(RPC_AUTH_TLS)\n\n#define\trpc_call\tcpu_to_be32(RPC_CALL)\n#define\trpc_reply\tcpu_to_be32(RPC_REPLY)\n\n#define\trpc_msg_accepted\tcpu_to_be32(RPC_MSG_ACCEPTED)\n\n#define\trpc_success\t\tcpu_to_be32(RPC_SUCCESS)\n#define\trpc_prog_unavail\tcpu_to_be32(RPC_PROG_UNAVAIL)\n#define\trpc_prog_mismatch\tcpu_to_be32(RPC_PROG_MISMATCH)\n#define\trpc_proc_unavail\tcpu_to_be32(RPC_PROC_UNAVAIL)\n#define\trpc_garbage_args\tcpu_to_be32(RPC_GARBAGE_ARGS)\n#define\trpc_system_err\t\tcpu_to_be32(RPC_SYSTEM_ERR)\n#define\trpc_drop_reply\t\tcpu_to_be32(RPC_DROP_REPLY)\n\n#define\trpc_mismatch\t\tcpu_to_be32(RPC_MISMATCH)\n#define\trpc_auth_error\t\tcpu_to_be32(RPC_AUTH_ERROR)\n\n#define\trpc_auth_ok\t\tcpu_to_be32(RPC_AUTH_OK)\n#define\trpc_autherr_badcred\tcpu_to_be32(RPC_AUTH_BADCRED)\n#define\trpc_autherr_rejectedcred cpu_to_be32(RPC_AUTH_REJECTEDCRED)\n#define\trpc_autherr_badverf\tcpu_to_be32(RPC_AUTH_BADVERF)\n#define\trpc_autherr_rejectedverf cpu_to_be32(RPC_AUTH_REJECTEDVERF)\n#define\trpc_autherr_tooweak\tcpu_to_be32(RPC_AUTH_TOOWEAK)\n#define\trpcsec_gsserr_credproblem\tcpu_to_be32(RPCSEC_GSS_CREDPROBLEM)\n#define\trpcsec_gsserr_ctxproblem\tcpu_to_be32(RPCSEC_GSS_CTXPROBLEM)\n\n \n__be32 *xdr_encode_opaque_fixed(__be32 *p, const void *ptr, unsigned int len);\n__be32 *xdr_encode_opaque(__be32 *p, const void *ptr, unsigned int len);\n__be32 *xdr_encode_string(__be32 *p, const char *s);\n__be32 *xdr_decode_string_inplace(__be32 *p, char **sp, unsigned int *lenp,\n\t\t\tunsigned int maxlen);\n__be32 *xdr_encode_netobj(__be32 *p, const struct xdr_netobj *);\n__be32 *xdr_decode_netobj(__be32 *p, struct xdr_netobj *);\n\nvoid\txdr_inline_pages(struct xdr_buf *, unsigned int,\n\t\t\t struct page **, unsigned int, unsigned int);\nvoid\txdr_terminate_string(const struct xdr_buf *, const u32);\nsize_t\txdr_buf_pagecount(const struct xdr_buf *buf);\nint\txdr_alloc_bvec(struct xdr_buf *buf, gfp_t gfp);\nvoid\txdr_free_bvec(struct xdr_buf *buf);\nunsigned int xdr_buf_to_bvec(struct bio_vec *bvec, unsigned int bvec_size,\n\t\t\t     const struct xdr_buf *xdr);\n\nstatic inline __be32 *xdr_encode_array(__be32 *p, const void *s, unsigned int len)\n{\n\treturn xdr_encode_opaque(p, s, len);\n}\n\n \nstatic inline __be32 *\nxdr_encode_hyper(__be32 *p, __u64 val)\n{\n\tput_unaligned_be64(val, p);\n\treturn p + 2;\n}\n\nstatic inline __be32 *\nxdr_decode_hyper(__be32 *p, __u64 *valp)\n{\n\t*valp = get_unaligned_be64(p);\n\treturn p + 2;\n}\n\nstatic inline __be32 *\nxdr_decode_opaque_fixed(__be32 *p, void *ptr, unsigned int len)\n{\n\tmemcpy(ptr, p, len);\n\treturn p + XDR_QUADLEN(len);\n}\n\nstatic inline void xdr_netobj_dup(struct xdr_netobj *dst,\n\t\t\t\t  struct xdr_netobj *src, gfp_t gfp_mask)\n{\n\tdst->data = kmemdup(src->data, src->len, gfp_mask);\n\tdst->len = src->len;\n}\n\n \nstatic inline int\nxdr_adjust_iovec(struct kvec *iov, __be32 *p)\n{\n\treturn iov->iov_len = ((u8 *) p - (u8 *) iov->iov_base);\n}\n\n \nextern void xdr_buf_from_iov(const struct kvec *, struct xdr_buf *);\nextern int xdr_buf_subsegment(const struct xdr_buf *, struct xdr_buf *, unsigned int, unsigned int);\nextern void xdr_buf_trim(struct xdr_buf *, unsigned int);\nextern int read_bytes_from_xdr_buf(const struct xdr_buf *, unsigned int, void *, unsigned int);\nextern int write_bytes_to_xdr_buf(const struct xdr_buf *, unsigned int, void *, unsigned int);\n\nextern int xdr_encode_word(const struct xdr_buf *, unsigned int, u32);\nextern int xdr_decode_word(const struct xdr_buf *, unsigned int, u32 *);\n\nstruct xdr_array2_desc;\ntypedef int (*xdr_xcode_elem_t)(struct xdr_array2_desc *desc, void *elem);\nstruct xdr_array2_desc {\n\tunsigned int elem_size;\n\tunsigned int array_len;\n\tunsigned int array_maxlen;\n\txdr_xcode_elem_t xcode;\n};\n\nextern int xdr_decode_array2(const struct xdr_buf *buf, unsigned int base,\n\t\t\t     struct xdr_array2_desc *desc);\nextern int xdr_encode_array2(const struct xdr_buf *buf, unsigned int base,\n\t\t\t     struct xdr_array2_desc *desc);\nextern void _copy_from_pages(char *p, struct page **pages, size_t pgbase,\n\t\t\t     size_t len);\n\n \nstruct xdr_stream {\n\t__be32 *p;\t\t \n\tstruct xdr_buf *buf;\t \n\n\t__be32 *end;\t\t \n\tstruct kvec *iov;\t \n\tstruct kvec scratch;\t \n\tstruct page **page_ptr;\t \n\tvoid *page_kaddr;\t \n\tunsigned int nwords;\t \n\n\tstruct rpc_rqst *rqst;\t \n};\n\n \ntypedef void\t(*kxdreproc_t)(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\tconst void *obj);\ntypedef int\t(*kxdrdproc_t)(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\tvoid *obj);\n\nextern void xdr_init_encode(struct xdr_stream *xdr, struct xdr_buf *buf,\n\t\t\t    __be32 *p, struct rpc_rqst *rqst);\nextern void xdr_init_encode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,\n\t\t\t   struct page **pages, struct rpc_rqst *rqst);\nextern __be32 *xdr_reserve_space(struct xdr_stream *xdr, size_t nbytes);\nextern int xdr_reserve_space_vec(struct xdr_stream *xdr, size_t nbytes);\nextern void __xdr_commit_encode(struct xdr_stream *xdr);\nextern void xdr_truncate_encode(struct xdr_stream *xdr, size_t len);\nextern void xdr_truncate_decode(struct xdr_stream *xdr, size_t len);\nextern int xdr_restrict_buflen(struct xdr_stream *xdr, int newbuflen);\nextern void xdr_write_pages(struct xdr_stream *xdr, struct page **pages,\n\t\tunsigned int base, unsigned int len);\nextern unsigned int xdr_stream_pos(const struct xdr_stream *xdr);\nextern unsigned int xdr_page_pos(const struct xdr_stream *xdr);\nextern void xdr_init_decode(struct xdr_stream *xdr, struct xdr_buf *buf,\n\t\t\t    __be32 *p, struct rpc_rqst *rqst);\nextern void xdr_init_decode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,\n\t\tstruct page **pages, unsigned int len);\nextern void xdr_finish_decode(struct xdr_stream *xdr);\nextern __be32 *xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes);\nextern unsigned int xdr_read_pages(struct xdr_stream *xdr, unsigned int len);\nextern void xdr_enter_page(struct xdr_stream *xdr, unsigned int len);\nextern int xdr_process_buf(const struct xdr_buf *buf, unsigned int offset, unsigned int len, int (*actor)(struct scatterlist *, void *), void *data);\nextern void xdr_set_pagelen(struct xdr_stream *, unsigned int len);\nextern bool xdr_stream_subsegment(struct xdr_stream *xdr, struct xdr_buf *subbuf,\n\t\t\t\t  unsigned int len);\nextern unsigned int xdr_stream_move_subsegment(struct xdr_stream *xdr, unsigned int offset,\n\t\t\t\t\t       unsigned int target, unsigned int length);\nextern unsigned int xdr_stream_zero(struct xdr_stream *xdr, unsigned int offset,\n\t\t\t\t    unsigned int length);\n\n \nstatic inline void\nxdr_set_scratch_buffer(struct xdr_stream *xdr, void *buf, size_t buflen)\n{\n\txdr->scratch.iov_base = buf;\n\txdr->scratch.iov_len = buflen;\n}\n\n \nstatic inline void\nxdr_set_scratch_page(struct xdr_stream *xdr, struct page *page)\n{\n\txdr_set_scratch_buffer(xdr, page_address(page), PAGE_SIZE);\n}\n\n \nstatic inline void\nxdr_reset_scratch_buffer(struct xdr_stream *xdr)\n{\n\txdr_set_scratch_buffer(xdr, NULL, 0);\n}\n\n \nstatic inline void xdr_commit_encode(struct xdr_stream *xdr)\n{\n\tif (unlikely(xdr->scratch.iov_len))\n\t\t__xdr_commit_encode(xdr);\n}\n\n \nstatic inline size_t\nxdr_stream_remaining(const struct xdr_stream *xdr)\n{\n\treturn xdr->nwords << 2;\n}\n\nssize_t xdr_stream_decode_opaque(struct xdr_stream *xdr, void *ptr,\n\t\tsize_t size);\nssize_t xdr_stream_decode_opaque_dup(struct xdr_stream *xdr, void **ptr,\n\t\tsize_t maxlen, gfp_t gfp_flags);\nssize_t xdr_stream_decode_string(struct xdr_stream *xdr, char *str,\n\t\tsize_t size);\nssize_t xdr_stream_decode_string_dup(struct xdr_stream *xdr, char **str,\n\t\tsize_t maxlen, gfp_t gfp_flags);\nssize_t xdr_stream_decode_opaque_auth(struct xdr_stream *xdr, u32 *flavor,\n\t\tvoid **body, unsigned int *body_len);\nssize_t xdr_stream_encode_opaque_auth(struct xdr_stream *xdr, u32 flavor,\n\t\tvoid *body, unsigned int body_len);\n\n \nstatic inline size_t\nxdr_align_size(size_t n)\n{\n\tconst size_t mask = XDR_UNIT - 1;\n\n\treturn (n + mask) & ~mask;\n}\n\n \nstatic inline size_t xdr_pad_size(size_t n)\n{\n\treturn xdr_align_size(n) - n;\n}\n\n \nstatic inline ssize_t xdr_stream_encode_item_present(struct xdr_stream *xdr)\n{\n\tconst size_t len = XDR_UNIT;\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\t*p = xdr_one;\n\treturn len;\n}\n\n \nstatic inline int xdr_stream_encode_item_absent(struct xdr_stream *xdr)\n{\n\tconst size_t len = XDR_UNIT;\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\t*p = xdr_zero;\n\treturn len;\n}\n\n \nstatic inline __be32 *xdr_encode_bool(__be32 *p, u32 n)\n{\n\t*p++ = n ? xdr_one : xdr_zero;\n\treturn p;\n}\n\n \nstatic inline int xdr_stream_encode_bool(struct xdr_stream *xdr, __u32 n)\n{\n\tconst size_t len = XDR_UNIT;\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\txdr_encode_bool(p, n);\n\treturn len;\n}\n\n \nstatic inline ssize_t\nxdr_stream_encode_u32(struct xdr_stream *xdr, __u32 n)\n{\n\tconst size_t len = sizeof(n);\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\t*p = cpu_to_be32(n);\n\treturn len;\n}\n\n \nstatic inline ssize_t\nxdr_stream_encode_be32(struct xdr_stream *xdr, __be32 n)\n{\n\tconst size_t len = sizeof(n);\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\t*p = n;\n\treturn len;\n}\n\n \nstatic inline ssize_t\nxdr_stream_encode_u64(struct xdr_stream *xdr, __u64 n)\n{\n\tconst size_t len = sizeof(n);\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\txdr_encode_hyper(p, n);\n\treturn len;\n}\n\n \nstatic inline ssize_t\nxdr_stream_encode_opaque_inline(struct xdr_stream *xdr, void **ptr, size_t len)\n{\n\tsize_t count = sizeof(__u32) + xdr_align_size(len);\n\t__be32 *p = xdr_reserve_space(xdr, count);\n\n\tif (unlikely(!p)) {\n\t\t*ptr = NULL;\n\t\treturn -EMSGSIZE;\n\t}\n\txdr_encode_opaque(p, NULL, len);\n\t*ptr = ++p;\n\treturn count;\n}\n\n \nstatic inline ssize_t\nxdr_stream_encode_opaque_fixed(struct xdr_stream *xdr, const void *ptr, size_t len)\n{\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\txdr_encode_opaque_fixed(p, ptr, len);\n\treturn xdr_align_size(len);\n}\n\n \nstatic inline ssize_t\nxdr_stream_encode_opaque(struct xdr_stream *xdr, const void *ptr, size_t len)\n{\n\tsize_t count = sizeof(__u32) + xdr_align_size(len);\n\t__be32 *p = xdr_reserve_space(xdr, count);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\txdr_encode_opaque(p, ptr, len);\n\treturn count;\n}\n\n \nstatic inline ssize_t\nxdr_stream_encode_uint32_array(struct xdr_stream *xdr,\n\t\tconst __u32 *array, size_t array_size)\n{\n\tssize_t ret = (array_size+1) * sizeof(__u32);\n\t__be32 *p = xdr_reserve_space(xdr, ret);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\t*p++ = cpu_to_be32(array_size);\n\tfor (; array_size > 0; p++, array++, array_size--)\n\t\t*p = cpu_to_be32p(array);\n\treturn ret;\n}\n\n \nstatic inline bool xdr_item_is_absent(const __be32 *p)\n{\n\treturn *p == xdr_zero;\n}\n\n \nstatic inline bool xdr_item_is_present(const __be32 *p)\n{\n\treturn *p != xdr_zero;\n}\n\n \nstatic inline ssize_t\nxdr_stream_decode_bool(struct xdr_stream *xdr, __u32 *ptr)\n{\n\tconst size_t count = sizeof(*ptr);\n\t__be32 *p = xdr_inline_decode(xdr, count);\n\n\tif (unlikely(!p))\n\t\treturn -EBADMSG;\n\t*ptr = (*p != xdr_zero);\n\treturn 0;\n}\n\n \nstatic inline ssize_t\nxdr_stream_decode_u32(struct xdr_stream *xdr, __u32 *ptr)\n{\n\tconst size_t count = sizeof(*ptr);\n\t__be32 *p = xdr_inline_decode(xdr, count);\n\n\tif (unlikely(!p))\n\t\treturn -EBADMSG;\n\t*ptr = be32_to_cpup(p);\n\treturn 0;\n}\n\n \nstatic inline ssize_t\nxdr_stream_decode_u64(struct xdr_stream *xdr, __u64 *ptr)\n{\n\tconst size_t count = sizeof(*ptr);\n\t__be32 *p = xdr_inline_decode(xdr, count);\n\n\tif (unlikely(!p))\n\t\treturn -EBADMSG;\n\txdr_decode_hyper(p, ptr);\n\treturn 0;\n}\n\n \nstatic inline ssize_t\nxdr_stream_decode_opaque_fixed(struct xdr_stream *xdr, void *ptr, size_t len)\n{\n\t__be32 *p = xdr_inline_decode(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EBADMSG;\n\txdr_decode_opaque_fixed(p, ptr, len);\n\treturn len;\n}\n\n \nstatic inline ssize_t\nxdr_stream_decode_opaque_inline(struct xdr_stream *xdr, void **ptr, size_t maxlen)\n{\n\t__be32 *p;\n\t__u32 len;\n\n\t*ptr = NULL;\n\tif (unlikely(xdr_stream_decode_u32(xdr, &len) < 0))\n\t\treturn -EBADMSG;\n\tif (len != 0) {\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EBADMSG;\n\t\tif (unlikely(len > maxlen))\n\t\t\treturn -EMSGSIZE;\n\t\t*ptr = p;\n\t}\n\treturn len;\n}\n\n \nstatic inline ssize_t\nxdr_stream_decode_uint32_array(struct xdr_stream *xdr,\n\t\t__u32 *array, size_t array_size)\n{\n\t__be32 *p;\n\t__u32 len;\n\tssize_t retval;\n\n\tif (unlikely(xdr_stream_decode_u32(xdr, &len) < 0))\n\t\treturn -EBADMSG;\n\tif (U32_MAX >= SIZE_MAX / sizeof(*p) && len > SIZE_MAX / sizeof(*p))\n\t\treturn -EBADMSG;\n\tp = xdr_inline_decode(xdr, len * sizeof(*p));\n\tif (unlikely(!p))\n\t\treturn -EBADMSG;\n\tif (array == NULL)\n\t\treturn len;\n\tif (len <= array_size) {\n\t\tif (len < array_size)\n\t\t\tmemset(array+len, 0, (array_size-len)*sizeof(*array));\n\t\tarray_size = len;\n\t\tretval = len;\n\t} else\n\t\tretval = -EMSGSIZE;\n\tfor (; array_size > 0; p++, array++, array_size--)\n\t\t*array = be32_to_cpup(p);\n\treturn retval;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}