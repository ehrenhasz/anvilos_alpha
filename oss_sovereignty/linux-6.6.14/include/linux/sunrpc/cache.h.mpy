{
  "module_name": "cache.h",
  "hash_id": "9ab4a80f7c8c63d54e5c417ebae740ff6ed64e4c1128df8f20be0a83492a0a0e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/sunrpc/cache.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_SUNRPC_CACHE_H_\n#define _LINUX_SUNRPC_CACHE_H_\n\n#include <linux/kref.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/kstrtox.h>\n#include <linux/proc_fs.h>\n\n \n\n \nstruct cache_head {\n\tstruct hlist_node\tcache_list;\n\ttime64_t\texpiry_time;\t \n\ttime64_t\tlast_refresh;    \n\tstruct kref\tref;\n\tunsigned long\tflags;\n};\n\n \nenum {\n\tCACHE_VALID,\t\t \n\tCACHE_NEGATIVE,\t\t \n\tCACHE_PENDING,\t\t \n\tCACHE_CLEANED,\t\t \n};\n\n#define\tCACHE_NEW_EXPIRY 120\t \n\nstruct cache_detail {\n\tstruct module *\t\towner;\n\tint\t\t\thash_size;\n\tstruct hlist_head *\thash_table;\n\tspinlock_t\t\thash_lock;\n\n\tchar\t\t\t*name;\n\tvoid\t\t\t(*cache_put)(struct kref *);\n\n\tint\t\t\t(*cache_upcall)(struct cache_detail *,\n\t\t\t\t\t\tstruct cache_head *);\n\n\tvoid\t\t\t(*cache_request)(struct cache_detail *cd,\n\t\t\t\t\t\t struct cache_head *ch,\n\t\t\t\t\t\t char **bpp, int *blen);\n\n\tint\t\t\t(*cache_parse)(struct cache_detail *,\n\t\t\t\t\t       char *buf, int len);\n\n\tint\t\t\t(*cache_show)(struct seq_file *m,\n\t\t\t\t\t      struct cache_detail *cd,\n\t\t\t\t\t      struct cache_head *h);\n\tvoid\t\t\t(*warn_no_listener)(struct cache_detail *cd,\n\t\t\t\t\t      int has_died);\n\n\tstruct cache_head *\t(*alloc)(void);\n\tvoid\t\t\t(*flush)(void);\n\tint\t\t\t(*match)(struct cache_head *orig, struct cache_head *new);\n\tvoid\t\t\t(*init)(struct cache_head *orig, struct cache_head *new);\n\tvoid\t\t\t(*update)(struct cache_head *orig, struct cache_head *new);\n\n\t \n\ttime64_t\t\tflush_time;\t\t \n\tstruct list_head\tothers;\n\ttime64_t\t\tnextcheck;\n\tint\t\t\tentries;\n\n\t \n\tstruct list_head\tqueue;\n\n\tatomic_t\t\twriters;\t\t \n\ttime64_t\t\tlast_close;\t\t \n\ttime64_t\t\tlast_warn;\t\t \n\n\tunion {\n\t\tstruct proc_dir_entry\t*procfs;\n\t\tstruct dentry\t\t*pipefs;\n\t};\n\tstruct net\t\t*net;\n};\n\n \nstruct cache_req {\n\tstruct cache_deferred_req *(*defer)(struct cache_req *req);\n\tunsigned long\tthread_wait;\t \n};\n\n \nstruct cache_deferred_req {\n\tstruct hlist_node\thash;\t \n\tstruct list_head\trecent;  \n\tstruct cache_head\t*item;   \n\tvoid\t\t\t*owner;  \n\tvoid\t\t\t(*revisit)(struct cache_deferred_req *req,\n\t\t\t\t\t   int too_many);\n};\n\n \nstatic inline time64_t seconds_since_boot(void)\n{\n\tstruct timespec64 boot;\n\tgetboottime64(&boot);\n\treturn ktime_get_real_seconds() - boot.tv_sec;\n}\n\nstatic inline time64_t convert_to_wallclock(time64_t sinceboot)\n{\n\tstruct timespec64 boot;\n\tgetboottime64(&boot);\n\treturn boot.tv_sec + sinceboot;\n}\n\nextern const struct file_operations cache_file_operations_pipefs;\nextern const struct file_operations content_file_operations_pipefs;\nextern const struct file_operations cache_flush_operations_pipefs;\n\nextern struct cache_head *\nsunrpc_cache_lookup_rcu(struct cache_detail *detail,\n\t\t\tstruct cache_head *key, int hash);\nextern struct cache_head *\nsunrpc_cache_update(struct cache_detail *detail,\n\t\t    struct cache_head *new, struct cache_head *old, int hash);\n\nextern int\nsunrpc_cache_pipe_upcall(struct cache_detail *detail, struct cache_head *h);\nextern int\nsunrpc_cache_pipe_upcall_timeout(struct cache_detail *detail,\n\t\t\t\t struct cache_head *h);\n\n\nextern void cache_clean_deferred(void *owner);\n\nstatic inline struct cache_head  *cache_get(struct cache_head *h)\n{\n\tkref_get(&h->ref);\n\treturn h;\n}\n\nstatic inline struct cache_head  *cache_get_rcu(struct cache_head *h)\n{\n\tif (kref_get_unless_zero(&h->ref))\n\t\treturn h;\n\treturn NULL;\n}\n\nstatic inline void cache_put(struct cache_head *h, struct cache_detail *cd)\n{\n\tif (kref_read(&h->ref) <= 2 &&\n\t    h->expiry_time < cd->nextcheck)\n\t\tcd->nextcheck = h->expiry_time;\n\tkref_put(&h->ref, cd->cache_put);\n}\n\nstatic inline bool cache_is_expired(struct cache_detail *detail, struct cache_head *h)\n{\n\tif (h->expiry_time < seconds_since_boot())\n\t\treturn true;\n\tif (!test_bit(CACHE_VALID, &h->flags))\n\t\treturn false;\n\treturn detail->flush_time >= h->last_refresh;\n}\n\nextern int cache_check(struct cache_detail *detail,\n\t\t       struct cache_head *h, struct cache_req *rqstp);\nextern void cache_flush(void);\nextern void cache_purge(struct cache_detail *detail);\n#define NEVER (0x7FFFFFFF)\nextern void __init cache_initialize(void);\nextern int cache_register_net(struct cache_detail *cd, struct net *net);\nextern void cache_unregister_net(struct cache_detail *cd, struct net *net);\n\nextern struct cache_detail *cache_create_net(const struct cache_detail *tmpl, struct net *net);\nextern void cache_destroy_net(struct cache_detail *cd, struct net *net);\n\nextern void sunrpc_init_cache_detail(struct cache_detail *cd);\nextern void sunrpc_destroy_cache_detail(struct cache_detail *cd);\nextern int sunrpc_cache_register_pipefs(struct dentry *parent, const char *,\n\t\t\t\t\tumode_t, struct cache_detail *);\nextern void sunrpc_cache_unregister_pipefs(struct cache_detail *);\nextern void sunrpc_cache_unhash(struct cache_detail *, struct cache_head *);\n\n \nextern void *cache_seq_start_rcu(struct seq_file *file, loff_t *pos);\nextern void *cache_seq_next_rcu(struct seq_file *file, void *p, loff_t *pos);\nextern void cache_seq_stop_rcu(struct seq_file *file, void *p);\n\nextern void qword_add(char **bpp, int *lp, char *str);\nextern void qword_addhex(char **bpp, int *lp, char *buf, int blen);\nextern int qword_get(char **bpp, char *dest, int bufsize);\n\nstatic inline int get_int(char **bpp, int *anint)\n{\n\tchar buf[50];\n\tchar *ep;\n\tint rv;\n\tint len = qword_get(bpp, buf, sizeof(buf));\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\trv = simple_strtol(buf, &ep, 0);\n\tif (*ep)\n\t\treturn -EINVAL;\n\n\t*anint = rv;\n\treturn 0;\n}\n\nstatic inline int get_uint(char **bpp, unsigned int *anint)\n{\n\tchar buf[50];\n\tint len = qword_get(bpp, buf, sizeof(buf));\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tif (kstrtouint(buf, 0, anint))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline int get_time(char **bpp, time64_t *time)\n{\n\tchar buf[50];\n\tlong long ll;\n\tint len = qword_get(bpp, buf, sizeof(buf));\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tif (kstrtoll(buf, 0, &ll))\n\t\treturn -EINVAL;\n\n\t*time = ll;\n\treturn 0;\n}\n\nstatic inline int get_expiry(char **bpp, time64_t *rvp)\n{\n\tint error;\n\tstruct timespec64 boot;\n\n\terror = get_time(bpp, rvp);\n\tif (error)\n\t\treturn error;\n\n\tgetboottime64(&boot);\n\t(*rvp) -= boot.tv_sec;\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}