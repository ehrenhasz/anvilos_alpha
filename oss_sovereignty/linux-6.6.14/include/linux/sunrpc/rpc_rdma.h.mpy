{
  "module_name": "rpc_rdma.h",
  "hash_id": "839cd01569dee4400b93808ef330f7f9ce84185b70641e6e50619dcae8ac6512",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/sunrpc/rpc_rdma.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_SUNRPC_RPC_RDMA_H\n#define _LINUX_SUNRPC_RPC_RDMA_H\n\n#include <linux/types.h>\n#include <linux/bitops.h>\n\n#define RPCRDMA_VERSION\t\t1\n#define rpcrdma_version\t\tcpu_to_be32(RPCRDMA_VERSION)\n\nenum {\n\tRPCRDMA_V1_DEF_INLINE_SIZE\t= 1024,\n};\n\n \nenum {\n\trpcrdma_fixed_maxsz\t= 4,\n\trpcrdma_segment_maxsz\t= 4,\n\trpcrdma_readseg_maxsz\t= 1 + rpcrdma_segment_maxsz,\n\trpcrdma_readchunk_maxsz\t= 1 + rpcrdma_readseg_maxsz,\n};\n\n \n#define RPCRDMA_HDRLEN_MIN\t(sizeof(__be32) * 7)\n#define RPCRDMA_HDRLEN_ERR\t(sizeof(__be32) * 5)\n\nenum rpcrdma_errcode {\n\tERR_VERS = 1,\n\tERR_CHUNK = 2\n};\n\nenum rpcrdma_proc {\n\tRDMA_MSG = 0,\t\t \n\tRDMA_NOMSG = 1,\t\t \n\tRDMA_MSGP = 2,\t\t \n\tRDMA_DONE = 3,\t\t \n\tRDMA_ERROR = 4\t\t \n};\n\n#define rdma_msg\tcpu_to_be32(RDMA_MSG)\n#define rdma_nomsg\tcpu_to_be32(RDMA_NOMSG)\n#define rdma_msgp\tcpu_to_be32(RDMA_MSGP)\n#define rdma_done\tcpu_to_be32(RDMA_DONE)\n#define rdma_error\tcpu_to_be32(RDMA_ERROR)\n\n#define err_vers\tcpu_to_be32(ERR_VERS)\n#define err_chunk\tcpu_to_be32(ERR_CHUNK)\n\n \nstruct rpcrdma_connect_private {\n\t__be32\t\t\tcp_magic;\n\tu8\t\t\tcp_version;\n\tu8\t\t\tcp_flags;\n\tu8\t\t\tcp_send_size;\n\tu8\t\t\tcp_recv_size;\n} __packed;\n\n#define rpcrdma_cmp_magic\t__cpu_to_be32(0xf6ab0e18)\n\nenum {\n\tRPCRDMA_CMP_VERSION\t\t= 1,\n\tRPCRDMA_CMP_F_SND_W_INV_OK\t= BIT(0),\n};\n\nstatic inline u8\nrpcrdma_encode_buffer_size(unsigned int size)\n{\n\treturn (size >> 10) - 1;\n}\n\nstatic inline unsigned int\nrpcrdma_decode_buffer_size(u8 val)\n{\n\treturn ((unsigned int)val + 1) << 10;\n}\n\n \nstatic inline __be32 *xdr_encode_rdma_segment(__be32 *p, u32 handle,\n\t\t\t\t\t      u32 length, u64 offset)\n{\n\t*p++ = cpu_to_be32(handle);\n\t*p++ = cpu_to_be32(length);\n\treturn xdr_encode_hyper(p, offset);\n}\n\n \nstatic inline __be32 *xdr_encode_read_segment(__be32 *p, u32 position,\n\t\t\t\t\t      u32 handle, u32 length,\n\t\t\t\t\t      u64 offset)\n{\n\t*p++ = cpu_to_be32(position);\n\treturn xdr_encode_rdma_segment(p, handle, length, offset);\n}\n\n \nstatic inline __be32 *xdr_decode_rdma_segment(__be32 *p, u32 *handle,\n\t\t\t\t\t      u32 *length, u64 *offset)\n{\n\t*handle = be32_to_cpup(p++);\n\t*length = be32_to_cpup(p++);\n\treturn xdr_decode_hyper(p, offset);\n}\n\n \nstatic inline __be32 *xdr_decode_read_segment(__be32 *p, u32 *position,\n\t\t\t\t\t      u32 *handle, u32 *length,\n\t\t\t\t\t      u64 *offset)\n{\n\t*position = be32_to_cpup(p++);\n\treturn xdr_decode_rdma_segment(p, handle, length, offset);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}