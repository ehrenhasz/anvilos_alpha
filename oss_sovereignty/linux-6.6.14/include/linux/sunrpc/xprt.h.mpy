{
  "module_name": "xprt.h",
  "hash_id": "ad803850b1de8abeb7729f036687fdfbe94ec815f49e90307043f127964ddad8",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/sunrpc/xprt.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_SUNRPC_XPRT_H\n#define _LINUX_SUNRPC_XPRT_H\n\n#include <linux/uio.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/ktime.h>\n#include <linux/kref.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/msg_prot.h>\n\n#define RPC_MIN_SLOT_TABLE\t(2U)\n#define RPC_DEF_SLOT_TABLE\t(16U)\n#define RPC_MAX_SLOT_TABLE_LIMIT\t(65536U)\n#define RPC_MAX_SLOT_TABLE\tRPC_MAX_SLOT_TABLE_LIMIT\n\n#define RPC_CWNDSHIFT\t\t(8U)\n#define RPC_CWNDSCALE\t\t(1U << RPC_CWNDSHIFT)\n#define RPC_INITCWND\t\tRPC_CWNDSCALE\n#define RPC_MAXCWND(xprt)\t((xprt)->max_reqs << RPC_CWNDSHIFT)\n#define RPCXPRT_CONGESTED(xprt) ((xprt)->cong >= (xprt)->cwnd)\n\n \nstruct rpc_timeout {\n\tunsigned long\t\tto_initval,\t\t \n\t\t\t\tto_maxval,\t\t \n\t\t\t\tto_increment;\t\t \n\tunsigned int\t\tto_retries;\t\t \n\tunsigned char\t\tto_exponential;\n};\n\nenum rpc_display_format_t {\n\tRPC_DISPLAY_ADDR = 0,\n\tRPC_DISPLAY_PORT,\n\tRPC_DISPLAY_PROTO,\n\tRPC_DISPLAY_HEX_ADDR,\n\tRPC_DISPLAY_HEX_PORT,\n\tRPC_DISPLAY_NETID,\n\tRPC_DISPLAY_MAX,\n};\n\nstruct rpc_task;\nstruct rpc_xprt;\nstruct xprt_class;\nstruct seq_file;\nstruct svc_serv;\nstruct net;\n\n \nstruct rpc_rqst {\n\t \n\tstruct rpc_xprt *\trq_xprt;\t\t \n\tstruct xdr_buf\t\trq_snd_buf;\t\t \n\tstruct xdr_buf\t\trq_rcv_buf;\t\t \n\n\t \n\tstruct rpc_task *\trq_task;\t \n\tstruct rpc_cred *\trq_cred;\t \n\t__be32\t\t\trq_xid;\t\t \n\tint\t\t\trq_cong;\t \n\tu32\t\t\trq_seqno;\t \n\tint\t\t\trq_enc_pages_num;\n\tstruct page\t\t**rq_enc_pages;\t \n\tvoid (*rq_release_snd_buf)(struct rpc_rqst *);  \n\n\tunion {\n\t\tstruct list_head\trq_list;\t \n\t\tstruct rb_node\t\trq_recv;\t \n\t};\n\n\tstruct list_head\trq_xmit;\t \n\tstruct list_head\trq_xmit2;\t \n\n\tvoid\t\t\t*rq_buffer;\t \n\tsize_t\t\t\trq_callsize;\n\tvoid\t\t\t*rq_rbuffer;\t \n\tsize_t\t\t\trq_rcvsize;\n\tsize_t\t\t\trq_xmit_bytes_sent;\t \n\tsize_t\t\t\trq_reply_bytes_recvd;\t \n\t\t\t\t\t\t\t \n\n\tstruct xdr_buf\t\trq_private_buf;\t\t \n\tunsigned long\t\trq_majortimeo;\t \n\tunsigned long\t\trq_minortimeo;\t \n\tunsigned long\t\trq_timeout;\t \n\tktime_t\t\t\trq_rtt;\t\t \n\tunsigned int\t\trq_retries;\t \n\tunsigned int\t\trq_connect_cookie;\n\t\t\t\t\t\t \n\tatomic_t\t\trq_pin;\n\t\n\t \n\tu32\t\t\trq_bytes_sent;\t \n\n\tktime_t\t\t\trq_xtime;\t \n\tint\t\t\trq_ntrans;\n\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\n\tstruct list_head\trq_bc_list;\t \n\tunsigned long\t\trq_bc_pa_state;\t \n\tstruct list_head\trq_bc_pa_list;\t \n#endif  \n};\n#define rq_svec\t\t\trq_snd_buf.head\n#define rq_slen\t\t\trq_snd_buf.len\n\n \nenum xprtsec_policies {\n\tRPC_XPRTSEC_NONE = 0,\n\tRPC_XPRTSEC_TLS_ANON,\n\tRPC_XPRTSEC_TLS_X509,\n};\n\nstruct xprtsec_parms {\n\tenum xprtsec_policies\tpolicy;\n\n\t \n\tkey_serial_t\t\tcert_serial;\n\tkey_serial_t\t\tprivkey_serial;\n};\n\nstruct rpc_xprt_ops {\n\tvoid\t\t(*set_buffer_size)(struct rpc_xprt *xprt, size_t sndsize, size_t rcvsize);\n\tint\t\t(*reserve_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);\n\tvoid\t\t(*release_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);\n\tvoid\t\t(*alloc_slot)(struct rpc_xprt *xprt, struct rpc_task *task);\n\tvoid\t\t(*free_slot)(struct rpc_xprt *xprt,\n\t\t\t\t     struct rpc_rqst *req);\n\tvoid\t\t(*rpcbind)(struct rpc_task *task);\n\tvoid\t\t(*set_port)(struct rpc_xprt *xprt, unsigned short port);\n\tvoid\t\t(*connect)(struct rpc_xprt *xprt, struct rpc_task *task);\n\tint\t\t(*get_srcaddr)(struct rpc_xprt *xprt, char *buf,\n\t\t\t\t       size_t buflen);\n\tunsigned short\t(*get_srcport)(struct rpc_xprt *xprt);\n\tint\t\t(*buf_alloc)(struct rpc_task *task);\n\tvoid\t\t(*buf_free)(struct rpc_task *task);\n\tint\t\t(*prepare_request)(struct rpc_rqst *req,\n\t\t\t\t\t   struct xdr_buf *buf);\n\tint\t\t(*send_request)(struct rpc_rqst *req);\n\tvoid\t\t(*wait_for_reply_request)(struct rpc_task *task);\n\tvoid\t\t(*timer)(struct rpc_xprt *xprt, struct rpc_task *task);\n\tvoid\t\t(*release_request)(struct rpc_task *task);\n\tvoid\t\t(*close)(struct rpc_xprt *xprt);\n\tvoid\t\t(*destroy)(struct rpc_xprt *xprt);\n\tvoid\t\t(*set_connect_timeout)(struct rpc_xprt *xprt,\n\t\t\t\t\tunsigned long connect_timeout,\n\t\t\t\t\tunsigned long reconnect_timeout);\n\tvoid\t\t(*print_stats)(struct rpc_xprt *xprt, struct seq_file *seq);\n\tint\t\t(*enable_swap)(struct rpc_xprt *xprt);\n\tvoid\t\t(*disable_swap)(struct rpc_xprt *xprt);\n\tvoid\t\t(*inject_disconnect)(struct rpc_xprt *xprt);\n\tint\t\t(*bc_setup)(struct rpc_xprt *xprt,\n\t\t\t\t    unsigned int min_reqs);\n\tsize_t\t\t(*bc_maxpayload)(struct rpc_xprt *xprt);\n\tunsigned int\t(*bc_num_slots)(struct rpc_xprt *xprt);\n\tvoid\t\t(*bc_free_rqst)(struct rpc_rqst *rqst);\n\tvoid\t\t(*bc_destroy)(struct rpc_xprt *xprt,\n\t\t\t\t      unsigned int max_reqs);\n};\n\n \n#define XPRT_TRANSPORT_BC       (1 << 31)\nenum xprt_transports {\n\tXPRT_TRANSPORT_UDP\t= IPPROTO_UDP,\n\tXPRT_TRANSPORT_TCP\t= IPPROTO_TCP,\n\tXPRT_TRANSPORT_BC_TCP\t= IPPROTO_TCP | XPRT_TRANSPORT_BC,\n\tXPRT_TRANSPORT_RDMA\t= 256,\n\tXPRT_TRANSPORT_BC_RDMA\t= XPRT_TRANSPORT_RDMA | XPRT_TRANSPORT_BC,\n\tXPRT_TRANSPORT_LOCAL\t= 257,\n\tXPRT_TRANSPORT_TCP_TLS\t= 258,\n};\n\nstruct rpc_sysfs_xprt;\nstruct rpc_xprt {\n\tstruct kref\t\tkref;\t\t \n\tconst struct rpc_xprt_ops *ops;\t\t \n\tunsigned int\t\tid;\t\t \n\n\tconst struct rpc_timeout *timeout;\t \n\tstruct sockaddr_storage\taddr;\t\t \n\tsize_t\t\t\taddrlen;\t \n\tint\t\t\tprot;\t\t \n\n\tunsigned long\t\tcong;\t\t \n\tunsigned long\t\tcwnd;\t\t \n\n\tsize_t\t\t\tmax_payload;\t \n\n\tstruct rpc_wait_queue\tbinding;\t \n\tstruct rpc_wait_queue\tsending;\t \n\tstruct rpc_wait_queue\tpending;\t \n\tstruct rpc_wait_queue\tbacklog;\t \n\tstruct list_head\tfree;\t\t \n\tunsigned int\t\tmax_reqs;\t \n\tunsigned int\t\tmin_reqs;\t \n\tunsigned int\t\tnum_reqs;\t \n\tunsigned long\t\tstate;\t\t \n\tunsigned char\t\tresvport   : 1,\t \n\t\t\t\treuseport  : 1;  \n\tatomic_t\t\tswapper;\t \n\tunsigned int\t\tbind_index;\t \n\n\t \n\tstruct list_head\txprt_switch;\n\n\t \n\tunsigned long\t\tbind_timeout,\n\t\t\t\treestablish_timeout;\n\tstruct xprtsec_parms\txprtsec;\n\tunsigned int\t\tconnect_cookie;\t \n\n\t \n\tstruct work_struct\ttask_cleanup;\n\tstruct timer_list\ttimer;\n\tunsigned long\t\tlast_used,\n\t\t\t\tidle_timeout,\n\t\t\t\tconnect_timeout,\n\t\t\t\tmax_reconnect_timeout;\n\n\t \n\tatomic_long_t\t\tqueuelen;\n\tspinlock_t\t\ttransport_lock;\t \n\tspinlock_t\t\treserve_lock;\t \n\tspinlock_t\t\tqueue_lock;\t \n\tu32\t\t\txid;\t\t \n\tstruct rpc_task *\tsnd_task;\t \n\n\tstruct list_head\txmit_queue;\t \n\tatomic_long_t\t\txmit_queuelen;\n\n\tstruct svc_xprt\t\t*bc_xprt;\t \n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\n\tstruct svc_serv\t\t*bc_serv;        \n\t\t\t\t\t\t \n\tunsigned int\t\tbc_alloc_max;\n\tunsigned int\t\tbc_alloc_count;\t \n\tatomic_t\t\tbc_slot_count;\t \n\tspinlock_t\t\tbc_pa_lock;\t \n\tstruct list_head\tbc_pa_list;\t \n#endif  \n\n\tstruct rb_root\t\trecv_queue;\t \n\n\tstruct {\n\t\tunsigned long\t\tbind_count,\t \n\t\t\t\t\tconnect_count,\t \n\t\t\t\t\tconnect_start,\t \n\t\t\t\t\tconnect_time,\t \n\t\t\t\t\tsends,\t\t \n\t\t\t\t\trecvs,\t\t \n\t\t\t\t\tbad_xids,\t \n\t\t\t\t\tmax_slots;\t \n\n\t\tunsigned long long\treq_u,\t\t \n\t\t\t\t\tbklog_u,\t \n\t\t\t\t\tsending_u,\t \n\t\t\t\t\tpending_u;\t \n\t} stat;\n\n\tstruct net\t\t*xprt_net;\n\tnetns_tracker\t\tns_tracker;\n\tconst char\t\t*servername;\n\tconst char\t\t*address_strings[RPC_DISPLAY_MAX];\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n\tstruct dentry\t\t*debugfs;\t\t \n#endif\n\tstruct rcu_head\t\trcu;\n\tconst struct xprt_class\t*xprt_class;\n\tstruct rpc_sysfs_xprt\t*xprt_sysfs;\n\tbool\t\t\tmain;  \n};\n\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\n \n#define\tRPC_BC_PA_IN_USE\t0x0001\t\t \n\t\t\t\t\t\t \n#endif  \n\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\nstatic inline int bc_prealloc(struct rpc_rqst *req)\n{\n\treturn test_bit(RPC_BC_PA_IN_USE, &req->rq_bc_pa_state);\n}\n#else\nstatic inline int bc_prealloc(struct rpc_rqst *req)\n{\n\treturn 0;\n}\n#endif  \n\n#define XPRT_CREATE_INFINITE_SLOTS\t(1U)\n#define XPRT_CREATE_NO_IDLE_TIMEOUT\t(1U << 1)\n\nstruct xprt_create {\n\tint\t\t\tident;\t\t \n\tstruct net *\t\tnet;\n\tstruct sockaddr *\tsrcaddr;\t \n\tstruct sockaddr *\tdstaddr;\t \n\tsize_t\t\t\taddrlen;\n\tconst char\t\t*servername;\n\tstruct svc_xprt\t\t*bc_xprt;\t \n\tstruct rpc_xprt_switch\t*bc_xps;\n\tunsigned int\t\tflags;\n\tstruct xprtsec_parms\txprtsec;\n\tunsigned long\t\tconnect_timeout;\n\tunsigned long\t\treconnect_timeout;\n};\n\nstruct xprt_class {\n\tstruct list_head\tlist;\n\tint\t\t\tident;\t\t \n\tstruct rpc_xprt *\t(*setup)(struct xprt_create *);\n\tstruct module\t\t*owner;\n\tchar\t\t\tname[32];\n\tconst char *\t\tnetid[];\n};\n\n \nstruct rpc_xprt\t\t*xprt_create_transport(struct xprt_create *args);\nvoid\t\t\txprt_connect(struct rpc_task *task);\nunsigned long\t\txprt_reconnect_delay(const struct rpc_xprt *xprt);\nvoid\t\t\txprt_reconnect_backoff(struct rpc_xprt *xprt,\n\t\t\t\t\t       unsigned long init_to);\nvoid\t\t\txprt_reserve(struct rpc_task *task);\nvoid\t\t\txprt_retry_reserve(struct rpc_task *task);\nint\t\t\txprt_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task);\nint\t\t\txprt_reserve_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);\nvoid\t\t\txprt_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);\nvoid\t\t\txprt_free_slot(struct rpc_xprt *xprt,\n\t\t\t\t       struct rpc_rqst *req);\nbool\t\t\txprt_prepare_transmit(struct rpc_task *task);\nvoid\t\t\txprt_request_enqueue_transmit(struct rpc_task *task);\nint\t\t\txprt_request_enqueue_receive(struct rpc_task *task);\nvoid\t\t\txprt_request_wait_receive(struct rpc_task *task);\nvoid\t\t\txprt_request_dequeue_xprt(struct rpc_task *task);\nbool\t\t\txprt_request_need_retransmit(struct rpc_task *task);\nvoid\t\t\txprt_transmit(struct rpc_task *task);\nvoid\t\t\txprt_end_transmit(struct rpc_task *task);\nint\t\t\txprt_adjust_timeout(struct rpc_rqst *req);\nvoid\t\t\txprt_release_xprt(struct rpc_xprt *xprt, struct rpc_task *task);\nvoid\t\t\txprt_release_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);\nvoid\t\t\txprt_release(struct rpc_task *task);\nstruct rpc_xprt *\txprt_get(struct rpc_xprt *xprt);\nvoid\t\t\txprt_put(struct rpc_xprt *xprt);\nstruct rpc_xprt *\txprt_alloc(struct net *net, size_t size,\n\t\t\t\tunsigned int num_prealloc,\n\t\t\t\tunsigned int max_req);\nvoid\t\t\txprt_free(struct rpc_xprt *);\nvoid\t\t\txprt_add_backlog(struct rpc_xprt *xprt, struct rpc_task *task);\nbool\t\t\txprt_wake_up_backlog(struct rpc_xprt *xprt, struct rpc_rqst *req);\nvoid\t\t\txprt_cleanup_ids(void);\n\nstatic inline int\nxprt_enable_swap(struct rpc_xprt *xprt)\n{\n\treturn xprt->ops->enable_swap(xprt);\n}\n\nstatic inline void\nxprt_disable_swap(struct rpc_xprt *xprt)\n{\n\txprt->ops->disable_swap(xprt);\n}\n\n \nint\t\t\txprt_register_transport(struct xprt_class *type);\nint\t\t\txprt_unregister_transport(struct xprt_class *type);\nint\t\t\txprt_find_transport_ident(const char *);\nvoid\t\t\txprt_wait_for_reply_request_def(struct rpc_task *task);\nvoid\t\t\txprt_wait_for_reply_request_rtt(struct rpc_task *task);\nvoid\t\t\txprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);\nvoid\t\t\txprt_wait_for_buffer_space(struct rpc_xprt *xprt);\nbool\t\t\txprt_write_space(struct rpc_xprt *xprt);\nvoid\t\t\txprt_adjust_cwnd(struct rpc_xprt *xprt, struct rpc_task *task, int result);\nstruct rpc_rqst *\txprt_lookup_rqst(struct rpc_xprt *xprt, __be32 xid);\nvoid\t\t\txprt_update_rtt(struct rpc_task *task);\nvoid\t\t\txprt_complete_rqst(struct rpc_task *task, int copied);\nvoid\t\t\txprt_pin_rqst(struct rpc_rqst *req);\nvoid\t\t\txprt_unpin_rqst(struct rpc_rqst *req);\nvoid\t\t\txprt_release_rqst_cong(struct rpc_task *task);\nbool\t\t\txprt_request_get_cong(struct rpc_xprt *xprt, struct rpc_rqst *req);\nvoid\t\t\txprt_disconnect_done(struct rpc_xprt *xprt);\nvoid\t\t\txprt_force_disconnect(struct rpc_xprt *xprt);\nvoid\t\t\txprt_conditional_disconnect(struct rpc_xprt *xprt, unsigned int cookie);\n\nbool\t\t\txprt_lock_connect(struct rpc_xprt *, struct rpc_task *, void *);\nvoid\t\t\txprt_unlock_connect(struct rpc_xprt *, void *);\nvoid\t\t\txprt_release_write(struct rpc_xprt *, struct rpc_task *);\n\n \n#define XPRT_LOCKED\t\t(0)\n#define XPRT_CONNECTED\t\t(1)\n#define XPRT_CONNECTING\t\t(2)\n#define XPRT_CLOSE_WAIT\t\t(3)\n#define XPRT_BOUND\t\t(4)\n#define XPRT_BINDING\t\t(5)\n#define XPRT_CLOSING\t\t(6)\n#define XPRT_OFFLINE\t\t(7)\n#define XPRT_REMOVE\t\t(8)\n#define XPRT_CONGESTED\t\t(9)\n#define XPRT_CWND_WAIT\t\t(10)\n#define XPRT_WRITE_SPACE\t(11)\n#define XPRT_SND_IS_COOKIE\t(12)\n\nstatic inline void xprt_set_connected(struct rpc_xprt *xprt)\n{\n\tset_bit(XPRT_CONNECTED, &xprt->state);\n}\n\nstatic inline void xprt_clear_connected(struct rpc_xprt *xprt)\n{\n\tclear_bit(XPRT_CONNECTED, &xprt->state);\n}\n\nstatic inline int xprt_connected(struct rpc_xprt *xprt)\n{\n\treturn test_bit(XPRT_CONNECTED, &xprt->state);\n}\n\nstatic inline int xprt_test_and_set_connected(struct rpc_xprt *xprt)\n{\n\treturn test_and_set_bit(XPRT_CONNECTED, &xprt->state);\n}\n\nstatic inline int xprt_test_and_clear_connected(struct rpc_xprt *xprt)\n{\n\treturn test_and_clear_bit(XPRT_CONNECTED, &xprt->state);\n}\n\nstatic inline void xprt_clear_connecting(struct rpc_xprt *xprt)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(XPRT_CONNECTING, &xprt->state);\n\tsmp_mb__after_atomic();\n}\n\nstatic inline int xprt_connecting(struct rpc_xprt *xprt)\n{\n\treturn test_bit(XPRT_CONNECTING, &xprt->state);\n}\n\nstatic inline int xprt_test_and_set_connecting(struct rpc_xprt *xprt)\n{\n\treturn test_and_set_bit(XPRT_CONNECTING, &xprt->state);\n}\n\nstatic inline void xprt_set_bound(struct rpc_xprt *xprt)\n{\n\ttest_and_set_bit(XPRT_BOUND, &xprt->state);\n}\n\nstatic inline int xprt_bound(struct rpc_xprt *xprt)\n{\n\treturn test_bit(XPRT_BOUND, &xprt->state);\n}\n\nstatic inline void xprt_clear_bound(struct rpc_xprt *xprt)\n{\n\tclear_bit(XPRT_BOUND, &xprt->state);\n}\n\nstatic inline void xprt_clear_binding(struct rpc_xprt *xprt)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(XPRT_BINDING, &xprt->state);\n\tsmp_mb__after_atomic();\n}\n\nstatic inline int xprt_test_and_set_binding(struct rpc_xprt *xprt)\n{\n\treturn test_and_set_bit(XPRT_BINDING, &xprt->state);\n}\n\nvoid xprt_set_offline_locked(struct rpc_xprt *xprt, struct rpc_xprt_switch *xps);\nvoid xprt_set_online_locked(struct rpc_xprt *xprt, struct rpc_xprt_switch *xps);\nvoid xprt_delete_locked(struct rpc_xprt *xprt, struct rpc_xprt_switch *xps);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}