{
  "module_name": "virtio_net.h",
  "hash_id": "8f65993eec79b194cfca1539c621d3caf0f6f936cd637dbbb2bc6d4820585ca3",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/virtio_net.h",
  "human_readable_source": " \n#ifndef _LINUX_VIRTIO_NET_H\n#define _LINUX_VIRTIO_NET_H\n\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/udp.h>\n#include <uapi/linux/tcp.h>\n#include <uapi/linux/virtio_net.h>\n\nstatic inline bool virtio_net_hdr_match_proto(__be16 protocol, __u8 gso_type)\n{\n\tswitch (gso_type & ~VIRTIO_NET_HDR_GSO_ECN) {\n\tcase VIRTIO_NET_HDR_GSO_TCPV4:\n\t\treturn protocol == cpu_to_be16(ETH_P_IP);\n\tcase VIRTIO_NET_HDR_GSO_TCPV6:\n\t\treturn protocol == cpu_to_be16(ETH_P_IPV6);\n\tcase VIRTIO_NET_HDR_GSO_UDP:\n\tcase VIRTIO_NET_HDR_GSO_UDP_L4:\n\t\treturn protocol == cpu_to_be16(ETH_P_IP) ||\n\t\t       protocol == cpu_to_be16(ETH_P_IPV6);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline int virtio_net_hdr_set_proto(struct sk_buff *skb,\n\t\t\t\t\t   const struct virtio_net_hdr *hdr)\n{\n\tif (skb->protocol)\n\t\treturn 0;\n\n\tswitch (hdr->gso_type & ~VIRTIO_NET_HDR_GSO_ECN) {\n\tcase VIRTIO_NET_HDR_GSO_TCPV4:\n\tcase VIRTIO_NET_HDR_GSO_UDP:\n\tcase VIRTIO_NET_HDR_GSO_UDP_L4:\n\t\tskb->protocol = cpu_to_be16(ETH_P_IP);\n\t\tbreak;\n\tcase VIRTIO_NET_HDR_GSO_TCPV6:\n\t\tskb->protocol = cpu_to_be16(ETH_P_IPV6);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int virtio_net_hdr_to_skb(struct sk_buff *skb,\n\t\t\t\t\tconst struct virtio_net_hdr *hdr,\n\t\t\t\t\tbool little_endian)\n{\n\tunsigned int nh_min_len = sizeof(struct iphdr);\n\tunsigned int gso_type = 0;\n\tunsigned int thlen = 0;\n\tunsigned int p_off = 0;\n\tunsigned int ip_proto;\n\n\tif (hdr->gso_type != VIRTIO_NET_HDR_GSO_NONE) {\n\t\tswitch (hdr->gso_type & ~VIRTIO_NET_HDR_GSO_ECN) {\n\t\tcase VIRTIO_NET_HDR_GSO_TCPV4:\n\t\t\tgso_type = SKB_GSO_TCPV4;\n\t\t\tip_proto = IPPROTO_TCP;\n\t\t\tthlen = sizeof(struct tcphdr);\n\t\t\tbreak;\n\t\tcase VIRTIO_NET_HDR_GSO_TCPV6:\n\t\t\tgso_type = SKB_GSO_TCPV6;\n\t\t\tip_proto = IPPROTO_TCP;\n\t\t\tthlen = sizeof(struct tcphdr);\n\t\t\tnh_min_len = sizeof(struct ipv6hdr);\n\t\t\tbreak;\n\t\tcase VIRTIO_NET_HDR_GSO_UDP:\n\t\t\tgso_type = SKB_GSO_UDP;\n\t\t\tip_proto = IPPROTO_UDP;\n\t\t\tthlen = sizeof(struct udphdr);\n\t\t\tbreak;\n\t\tcase VIRTIO_NET_HDR_GSO_UDP_L4:\n\t\t\tgso_type = SKB_GSO_UDP_L4;\n\t\t\tip_proto = IPPROTO_UDP;\n\t\t\tthlen = sizeof(struct udphdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (hdr->gso_type & VIRTIO_NET_HDR_GSO_ECN)\n\t\t\tgso_type |= SKB_GSO_TCP_ECN;\n\n\t\tif (hdr->gso_size == 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tskb_reset_mac_header(skb);\n\n\tif (hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {\n\t\tu32 start = __virtio16_to_cpu(little_endian, hdr->csum_start);\n\t\tu32 off = __virtio16_to_cpu(little_endian, hdr->csum_offset);\n\t\tu32 needed = start + max_t(u32, thlen, off + sizeof(__sum16));\n\n\t\tif (!pskb_may_pull(skb, needed))\n\t\t\treturn -EINVAL;\n\n\t\tif (!skb_partial_csum_set(skb, start, off))\n\t\t\treturn -EINVAL;\n\n\t\tnh_min_len = max_t(u32, nh_min_len, skb_transport_offset(skb));\n\t\tp_off = nh_min_len + thlen;\n\t\tif (!pskb_may_pull(skb, p_off))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tif (gso_type && skb->network_header) {\n\t\t\tstruct flow_keys_basic keys;\n\n\t\t\tif (!skb->protocol) {\n\t\t\t\t__be16 protocol = dev_parse_header_protocol(skb);\n\n\t\t\t\tif (!protocol)\n\t\t\t\t\tvirtio_net_hdr_set_proto(skb, hdr);\n\t\t\t\telse if (!virtio_net_hdr_match_proto(protocol, hdr->gso_type))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tskb->protocol = protocol;\n\t\t\t}\nretry:\n\t\t\tif (!skb_flow_dissect_flow_keys_basic(NULL, skb, &keys,\n\t\t\t\t\t\t\t      NULL, 0, 0, 0,\n\t\t\t\t\t\t\t      0)) {\n\t\t\t\t \n\t\t\t\tif (gso_type & SKB_GSO_UDP &&\n\t\t\t\t    skb->protocol == htons(ETH_P_IP)) {\n\t\t\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tp_off = keys.control.thoff + thlen;\n\t\t\tif (!pskb_may_pull(skb, p_off) ||\n\t\t\t    keys.basic.ip_proto != ip_proto)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tskb_set_transport_header(skb, keys.control.thoff);\n\t\t} else if (gso_type) {\n\t\t\tp_off = nh_min_len + thlen;\n\t\t\tif (!pskb_may_pull(skb, p_off))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (hdr->gso_type != VIRTIO_NET_HDR_GSO_NONE) {\n\t\tu16 gso_size = __virtio16_to_cpu(little_endian, hdr->gso_size);\n\t\tunsigned int nh_off = p_off;\n\t\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\n\t\tswitch (gso_type & ~SKB_GSO_TCP_ECN) {\n\t\tcase SKB_GSO_UDP:\n\t\t\t \n\t\t\tnh_off -= thlen;\n\t\t\tbreak;\n\t\tcase SKB_GSO_UDP_L4:\n\t\t\tif (!(hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (skb->csum_offset != offsetof(struct udphdr, check))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (skb->len - p_off > gso_size * UDP_MAX_SEGMENTS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (gso_type != SKB_GSO_UDP_L4)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (gso_size == GSO_BY_FRAGS)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (skb->len - nh_off > gso_size) {\n\t\t\tshinfo->gso_size = gso_size;\n\t\t\tshinfo->gso_type = gso_type;\n\n\t\t\t \n\t\t\tshinfo->gso_type |= SKB_GSO_DODGY;\n\t\t\tshinfo->gso_segs = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int virtio_net_hdr_from_skb(const struct sk_buff *skb,\n\t\t\t\t\t  struct virtio_net_hdr *hdr,\n\t\t\t\t\t  bool little_endian,\n\t\t\t\t\t  bool has_data_valid,\n\t\t\t\t\t  int vlan_hlen)\n{\n\tmemset(hdr, 0, sizeof(*hdr));    \n\n\tif (skb_is_gso(skb)) {\n\t\tstruct skb_shared_info *sinfo = skb_shinfo(skb);\n\n\t\t \n\t\thdr->hdr_len = __cpu_to_virtio16(little_endian,\n\t\t\t\t\t\t skb_headlen(skb));\n\t\thdr->gso_size = __cpu_to_virtio16(little_endian,\n\t\t\t\t\t\t  sinfo->gso_size);\n\t\tif (sinfo->gso_type & SKB_GSO_TCPV4)\n\t\t\thdr->gso_type = VIRTIO_NET_HDR_GSO_TCPV4;\n\t\telse if (sinfo->gso_type & SKB_GSO_TCPV6)\n\t\t\thdr->gso_type = VIRTIO_NET_HDR_GSO_TCPV6;\n\t\telse if (sinfo->gso_type & SKB_GSO_UDP_L4)\n\t\t\thdr->gso_type = VIRTIO_NET_HDR_GSO_UDP_L4;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tif (sinfo->gso_type & SKB_GSO_TCP_ECN)\n\t\t\thdr->gso_type |= VIRTIO_NET_HDR_GSO_ECN;\n\t} else\n\t\thdr->gso_type = VIRTIO_NET_HDR_GSO_NONE;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\thdr->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\t\thdr->csum_start = __cpu_to_virtio16(little_endian,\n\t\t\tskb_checksum_start_offset(skb) + vlan_hlen);\n\t\thdr->csum_offset = __cpu_to_virtio16(little_endian,\n\t\t\t\tskb->csum_offset);\n\t} else if (has_data_valid &&\n\t\t   skb->ip_summed == CHECKSUM_UNNECESSARY) {\n\t\thdr->flags = VIRTIO_NET_HDR_F_DATA_VALID;\n\t}  \n\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}