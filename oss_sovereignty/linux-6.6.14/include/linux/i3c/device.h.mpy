{
  "module_name": "device.h",
  "hash_id": "da6a3c18b672269f9d1bbd63f7ba8c6163f577ff0a12bb558b5a1904eec78e9b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/i3c/device.h",
  "human_readable_source": " \n \n\n#ifndef I3C_DEV_H\n#define I3C_DEV_H\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/kconfig.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n\n \nenum i3c_error_code {\n\tI3C_ERROR_UNKNOWN = 0,\n\tI3C_ERROR_M0 = 1,\n\tI3C_ERROR_M1,\n\tI3C_ERROR_M2,\n};\n\n \nenum i3c_hdr_mode {\n\tI3C_HDR_DDR,\n\tI3C_HDR_TSP,\n\tI3C_HDR_TSL,\n};\n\n \nstruct i3c_priv_xfer {\n\tu8 rnw;\n\tu16 len;\n\tunion {\n\t\tvoid *in;\n\t\tconst void *out;\n\t} data;\n\tenum i3c_error_code err;\n};\n\n \nenum i3c_dcr {\n\tI3C_DCR_GENERIC_DEVICE = 0,\n};\n\n#define I3C_PID_MANUF_ID(pid)\t\t(((pid) & GENMASK_ULL(47, 33)) >> 33)\n#define I3C_PID_RND_LOWER_32BITS(pid)\t(!!((pid) & BIT_ULL(32)))\n#define I3C_PID_RND_VAL(pid)\t\t((pid) & GENMASK_ULL(31, 0))\n#define I3C_PID_PART_ID(pid)\t\t(((pid) & GENMASK_ULL(31, 16)) >> 16)\n#define I3C_PID_INSTANCE_ID(pid)\t(((pid) & GENMASK_ULL(15, 12)) >> 12)\n#define I3C_PID_EXTRA_INFO(pid)\t\t((pid) & GENMASK_ULL(11, 0))\n\n#define I3C_BCR_DEVICE_ROLE(bcr)\t((bcr) & GENMASK(7, 6))\n#define I3C_BCR_I3C_SLAVE\t\t(0 << 6)\n#define I3C_BCR_I3C_MASTER\t\t(1 << 6)\n#define I3C_BCR_HDR_CAP\t\t\tBIT(5)\n#define I3C_BCR_BRIDGE\t\t\tBIT(4)\n#define I3C_BCR_OFFLINE_CAP\t\tBIT(3)\n#define I3C_BCR_IBI_PAYLOAD\t\tBIT(2)\n#define I3C_BCR_IBI_REQ_CAP\t\tBIT(1)\n#define I3C_BCR_MAX_DATA_SPEED_LIM\tBIT(0)\n\n \nstruct i3c_device_info {\n\tu64 pid;\n\tu8 bcr;\n\tu8 dcr;\n\tu8 static_addr;\n\tu8 dyn_addr;\n\tu8 hdr_cap;\n\tu8 max_read_ds;\n\tu8 max_write_ds;\n\tu8 max_ibi_len;\n\tu32 max_read_turnaround;\n\tu16 max_read_len;\n\tu16 max_write_len;\n};\n\n \nstruct i3c_device;\n\n \n#define I3C_MATCH_MANUF_AND_PART (I3C_MATCH_MANUF | I3C_MATCH_PART)\n\n#define I3C_DEVICE(_manufid, _partid, _drvdata)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.match_flags = I3C_MATCH_MANUF_AND_PART,\t\t\\\n\t\t.manuf_id = _manufid,\t\t\t\t\t\\\n\t\t.part_id = _partid,\t\t\t\t\t\\\n\t\t.data = _drvdata,\t\t\t\t\t\\\n\t}\n\n#define I3C_DEVICE_EXTRA_INFO(_manufid, _partid, _info, _drvdata)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.match_flags = I3C_MATCH_MANUF_AND_PART |\t\t\\\n\t\t\t       I3C_MATCH_EXTRA_INFO,\t\t\t\\\n\t\t.manuf_id = _manufid,\t\t\t\t\t\\\n\t\t.part_id = _partid,\t\t\t\t\t\\\n\t\t.extra_info = _info,\t\t\t\t\t\\\n\t\t.data = _drvdata,\t\t\t\t\t\\\n\t}\n\n#define I3C_CLASS(_dcr, _drvdata)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.match_flags = I3C_MATCH_DCR,\t\t\t\t\\\n\t\t.dcr = _dcr,\t\t\t\t\t\t\\\n\t}\n\n \nstruct i3c_driver {\n\tstruct device_driver driver;\n\tint (*probe)(struct i3c_device *dev);\n\tvoid (*remove)(struct i3c_device *dev);\n\tconst struct i3c_device_id *id_table;\n};\n\nstatic inline struct i3c_driver *drv_to_i3cdrv(struct device_driver *drv)\n{\n\treturn container_of(drv, struct i3c_driver, driver);\n}\n\nstruct device *i3cdev_to_dev(struct i3c_device *i3cdev);\n\n \n#define dev_to_i3cdev(__dev)\tcontainer_of_const(__dev, struct i3c_device, dev)\n\nconst struct i3c_device_id *\ni3c_device_match_id(struct i3c_device *i3cdev,\n\t\t    const struct i3c_device_id *id_table);\n\nstatic inline void i3cdev_set_drvdata(struct i3c_device *i3cdev,\n\t\t\t\t      void *data)\n{\n\tstruct device *dev = i3cdev_to_dev(i3cdev);\n\n\tdev_set_drvdata(dev, data);\n}\n\nstatic inline void *i3cdev_get_drvdata(struct i3c_device *i3cdev)\n{\n\tstruct device *dev = i3cdev_to_dev(i3cdev);\n\n\treturn dev_get_drvdata(dev);\n}\n\nint i3c_driver_register_with_owner(struct i3c_driver *drv,\n\t\t\t\t   struct module *owner);\nvoid i3c_driver_unregister(struct i3c_driver *drv);\n\n#define i3c_driver_register(__drv)\t\t\\\n\ti3c_driver_register_with_owner(__drv, THIS_MODULE)\n\n \n#define module_i3c_driver(__drv)\t\t\\\n\tmodule_driver(__drv, i3c_driver_register, i3c_driver_unregister)\n\n \nstatic inline int i3c_i2c_driver_register(struct i3c_driver *i3cdrv,\n\t\t\t\t\t  struct i2c_driver *i2cdrv)\n{\n\tint ret;\n\n\tret = i2c_add_driver(i2cdrv);\n\tif (ret || !IS_ENABLED(CONFIG_I3C))\n\t\treturn ret;\n\n\tret = i3c_driver_register(i3cdrv);\n\tif (ret)\n\t\ti2c_del_driver(i2cdrv);\n\n\treturn ret;\n}\n\n \nstatic inline void i3c_i2c_driver_unregister(struct i3c_driver *i3cdrv,\n\t\t\t\t\t     struct i2c_driver *i2cdrv)\n{\n\tif (IS_ENABLED(CONFIG_I3C))\n\t\ti3c_driver_unregister(i3cdrv);\n\n\ti2c_del_driver(i2cdrv);\n}\n\n \n#define module_i3c_i2c_driver(__i3cdrv, __i2cdrv)\t\\\n\tmodule_driver(__i3cdrv,\t\t\t\t\\\n\t\t      i3c_i2c_driver_register,\t\t\\\n\t\t      i3c_i2c_driver_unregister,\t\\\n\t\t      __i2cdrv)\n\nint i3c_device_do_priv_xfers(struct i3c_device *dev,\n\t\t\t     struct i3c_priv_xfer *xfers,\n\t\t\t     int nxfers);\n\nint i3c_device_do_setdasa(struct i3c_device *dev);\n\nvoid i3c_device_get_info(const struct i3c_device *dev, struct i3c_device_info *info);\n\nstruct i3c_ibi_payload {\n\tunsigned int len;\n\tconst void *data;\n};\n\n \nstruct i3c_ibi_setup {\n\tunsigned int max_payload_len;\n\tunsigned int num_slots;\n\tvoid (*handler)(struct i3c_device *dev,\n\t\t\tconst struct i3c_ibi_payload *payload);\n};\n\nint i3c_device_request_ibi(struct i3c_device *dev,\n\t\t\t   const struct i3c_ibi_setup *setup);\nvoid i3c_device_free_ibi(struct i3c_device *dev);\nint i3c_device_enable_ibi(struct i3c_device *dev);\nint i3c_device_disable_ibi(struct i3c_device *dev);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}