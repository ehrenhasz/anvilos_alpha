{
  "module_name": "math.h",
  "hash_id": "4885219518e3dc4b3d3dff35d18c3d1afd8a0a183b72eba736bf0e811b2ed427",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/math.h",
  "human_readable_source": " \n#ifndef _LINUX_MATH_H\n#define _LINUX_MATH_H\n\n#include <linux/types.h>\n#include <asm/div64.h>\n#include <uapi/linux/kernel.h>\n\n \n#define __round_mask(x, y) ((__typeof__(x))((y)-1))\n\n \n#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)\n\n \n#define round_down(x, y) ((x) & ~__round_mask(x, y))\n\n#define DIV_ROUND_UP __KERNEL_DIV_ROUND_UP\n\n#define DIV_ROUND_DOWN_ULL(ll, d) \\\n\t({ unsigned long long _tmp = (ll); do_div(_tmp, d); _tmp; })\n\n#define DIV_ROUND_UP_ULL(ll, d) \\\n\tDIV_ROUND_DOWN_ULL((unsigned long long)(ll) + (d) - 1, (d))\n\n#if BITS_PER_LONG == 32\n# define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP_ULL(ll, d)\n#else\n# define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP(ll,d)\n#endif\n\n \n#define roundup(x, y) (\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(y) __y = y;\t\t\t\t\\\n\t(((x) + (__y - 1)) / __y) * __y;\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n \n#define rounddown(x, y) (\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(x) __x = (x);\t\t\t\t\\\n\t__x - (__x % (y));\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n\n \n#define DIV_ROUND_CLOSEST(x, divisor)(\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(x) __x = x;\t\t\t\t\\\n\ttypeof(divisor) __d = divisor;\t\t\t\\\n\t(((typeof(x))-1) > 0 ||\t\t\t\t\\\n\t ((typeof(divisor))-1) > 0 ||\t\t\t\\\n\t (((__x) > 0) == ((__d) > 0))) ?\t\t\\\n\t\t(((__x) + ((__d) / 2)) / (__d)) :\t\\\n\t\t(((__x) - ((__d) / 2)) / (__d));\t\\\n}\t\t\t\t\t\t\t\\\n)\n \n#define DIV_ROUND_CLOSEST_ULL(x, divisor)(\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(divisor) __d = divisor;\t\t\t\\\n\tunsigned long long _tmp = (x) + (__d) / 2;\t\\\n\tdo_div(_tmp, __d);\t\t\t\t\\\n\t_tmp;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n\n#define __STRUCT_FRACT(type)\t\t\t\t\\\nstruct type##_fract {\t\t\t\t\t\\\n\t__##type numerator;\t\t\t\t\\\n\t__##type denominator;\t\t\t\t\\\n};\n__STRUCT_FRACT(s16)\n__STRUCT_FRACT(u16)\n__STRUCT_FRACT(s32)\n__STRUCT_FRACT(u32)\n#undef __STRUCT_FRACT\n\n \n#define mult_frac(x, n, d)\t\\\n({\t\t\t\t\\\n\ttypeof(x) x_ = (x);\t\\\n\ttypeof(n) n_ = (n);\t\\\n\ttypeof(d) d_ = (d);\t\\\n\t\t\t\t\\\n\ttypeof(x_) q = x_ / d_;\t\\\n\ttypeof(x_) r = x_ % d_;\t\\\n\tq * n_ + r * n_ / d_;\t\\\n})\n\n#define sector_div(a, b) do_div(a, b)\n\n \n#define abs(x)\t__abs_choose_expr(x, long long,\t\t\t\t\\\n\t\t__abs_choose_expr(x, long,\t\t\t\t\\\n\t\t__abs_choose_expr(x, int,\t\t\t\t\\\n\t\t__abs_choose_expr(x, short,\t\t\t\t\\\n\t\t__abs_choose_expr(x, char,\t\t\t\t\\\n\t\t__builtin_choose_expr(\t\t\t\t\t\\\n\t\t\t__builtin_types_compatible_p(typeof(x), char),\t\\\n\t\t\t(char)({ signed char __x = (x); __x<0?-__x:__x; }), \\\n\t\t\t((void)0)))))))\n\n#define __abs_choose_expr(x, type, other) __builtin_choose_expr(\t\\\n\t__builtin_types_compatible_p(typeof(x),   signed type) ||\t\\\n\t__builtin_types_compatible_p(typeof(x), unsigned type),\t\t\\\n\t({ signed type __x = (x); __x < 0 ? -__x : __x; }), other)\n\n \n#define abs_diff(a, b) ({\t\t\t\\\n\ttypeof(a) __a = (a);\t\t\t\\\n\ttypeof(b) __b = (b);\t\t\t\\\n\t(void)(&__a == &__b);\t\t\t\\\n\t__a > __b ? (__a - __b) : (__b - __a);\t\\\n})\n\n \nstatic inline u32 reciprocal_scale(u32 val, u32 ep_ro)\n{\n\treturn (u32)(((u64) val * ep_ro) >> 32);\n}\n\nu64 int_pow(u64 base, unsigned int exp);\nunsigned long int_sqrt(unsigned long);\n\n#if BITS_PER_LONG < 64\nu32 int_sqrt64(u64 x);\n#else\nstatic inline u32 int_sqrt64(u64 x)\n{\n\treturn (u32)int_sqrt(x);\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}