{
  "module_name": "fsverity.h",
  "hash_id": "6f61cf97ac4180d3ba185458b3a601b6ae69579388a86625c4e6aa5389390255",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fsverity.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_FSVERITY_H\n#define _LINUX_FSVERITY_H\n\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <crypto/hash_info.h>\n#include <crypto/sha2.h>\n#include <uapi/linux/fsverity.h>\n\n \n#define FS_VERITY_MAX_DIGEST_SIZE\tSHA512_DIGEST_SIZE\n\n \n#define FS_VERITY_MAX_DESCRIPTOR_SIZE\t16384\n\n \nstruct fsverity_operations {\n\n\t \n\tint (*begin_enable_verity)(struct file *filp);\n\n\t \n\tint (*end_enable_verity)(struct file *filp, const void *desc,\n\t\t\t\t size_t desc_size, u64 merkle_tree_size);\n\n\t \n\tint (*get_verity_descriptor)(struct inode *inode, void *buf,\n\t\t\t\t     size_t bufsize);\n\n\t \n\tstruct page *(*read_merkle_tree_page)(struct inode *inode,\n\t\t\t\t\t      pgoff_t index,\n\t\t\t\t\t      unsigned long num_ra_pages);\n\n\t \n\tint (*write_merkle_tree_block)(struct inode *inode, const void *buf,\n\t\t\t\t       u64 pos, unsigned int size);\n};\n\n#ifdef CONFIG_FS_VERITY\n\nstatic inline struct fsverity_info *fsverity_get_info(const struct inode *inode)\n{\n\t \n\treturn smp_load_acquire(&inode->i_verity_info);\n}\n\n \n\nint fsverity_ioctl_enable(struct file *filp, const void __user *arg);\n\n \n\nint fsverity_ioctl_measure(struct file *filp, void __user *arg);\nint fsverity_get_digest(struct inode *inode,\n\t\t\tu8 raw_digest[FS_VERITY_MAX_DIGEST_SIZE],\n\t\t\tu8 *alg, enum hash_algo *halg);\n\n \n\nint __fsverity_file_open(struct inode *inode, struct file *filp);\nint __fsverity_prepare_setattr(struct dentry *dentry, struct iattr *attr);\nvoid __fsverity_cleanup_inode(struct inode *inode);\n\n \nstatic inline void fsverity_cleanup_inode(struct inode *inode)\n{\n\tif (inode->i_verity_info)\n\t\t__fsverity_cleanup_inode(inode);\n}\n\n \n\nint fsverity_ioctl_read_metadata(struct file *filp, const void __user *uarg);\n\n \n\nbool fsverity_verify_blocks(struct folio *folio, size_t len, size_t offset);\nvoid fsverity_verify_bio(struct bio *bio);\nvoid fsverity_enqueue_verify_work(struct work_struct *work);\n\n#else  \n\nstatic inline struct fsverity_info *fsverity_get_info(const struct inode *inode)\n{\n\treturn NULL;\n}\n\n \n\nstatic inline int fsverity_ioctl_enable(struct file *filp,\n\t\t\t\t\tconst void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \n\nstatic inline int fsverity_ioctl_measure(struct file *filp, void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int fsverity_get_digest(struct inode *inode,\n\t\t\t\t      u8 raw_digest[FS_VERITY_MAX_DIGEST_SIZE],\n\t\t\t\t      u8 *alg, enum hash_algo *halg)\n{\n\t \n\treturn 0;\n}\n\n \n\nstatic inline int __fsverity_file_open(struct inode *inode, struct file *filp)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int __fsverity_prepare_setattr(struct dentry *dentry,\n\t\t\t\t\t     struct iattr *attr)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void fsverity_cleanup_inode(struct inode *inode)\n{\n}\n\n \n\nstatic inline int fsverity_ioctl_read_metadata(struct file *filp,\n\t\t\t\t\t       const void __user *uarg)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \n\nstatic inline bool fsverity_verify_blocks(struct folio *folio, size_t len,\n\t\t\t\t\t  size_t offset)\n{\n\tWARN_ON_ONCE(1);\n\treturn false;\n}\n\nstatic inline void fsverity_verify_bio(struct bio *bio)\n{\n\tWARN_ON_ONCE(1);\n}\n\nstatic inline void fsverity_enqueue_verify_work(struct work_struct *work)\n{\n\tWARN_ON_ONCE(1);\n}\n\n#endif\t \n\nstatic inline bool fsverity_verify_folio(struct folio *folio)\n{\n\treturn fsverity_verify_blocks(folio, folio_size(folio), 0);\n}\n\nstatic inline bool fsverity_verify_page(struct page *page)\n{\n\treturn fsverity_verify_blocks(page_folio(page), PAGE_SIZE, 0);\n}\n\n \nstatic inline bool fsverity_active(const struct inode *inode)\n{\n\treturn fsverity_get_info(inode) != NULL;\n}\n\n \nstatic inline int fsverity_file_open(struct inode *inode, struct file *filp)\n{\n\tif (IS_VERITY(inode))\n\t\treturn __fsverity_file_open(inode, filp);\n\treturn 0;\n}\n\n \nstatic inline int fsverity_prepare_setattr(struct dentry *dentry,\n\t\t\t\t\t   struct iattr *attr)\n{\n\tif (IS_VERITY(d_inode(dentry)))\n\t\treturn __fsverity_prepare_setattr(dentry, attr);\n\treturn 0;\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}