{
  "module_name": "pid.h",
  "hash_id": "f0f84e263dc5f2102c28f1eb5b62a9fd4ec7f771a752c7c6e963c45f53d277c7",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/pid.h",
  "human_readable_source": " \n#ifndef _LINUX_PID_H\n#define _LINUX_PID_H\n\n#include <linux/rculist.h>\n#include <linux/wait.h>\n#include <linux/refcount.h>\n\nenum pid_type\n{\n\tPIDTYPE_PID,\n\tPIDTYPE_TGID,\n\tPIDTYPE_PGID,\n\tPIDTYPE_SID,\n\tPIDTYPE_MAX,\n};\n\n \n\n\n \n\nstruct upid {\n\tint nr;\n\tstruct pid_namespace *ns;\n};\n\nstruct pid\n{\n\trefcount_t count;\n\tunsigned int level;\n\tspinlock_t lock;\n\t \n\tstruct hlist_head tasks[PIDTYPE_MAX];\n\tstruct hlist_head inodes;\n\t \n\twait_queue_head_t wait_pidfd;\n\tstruct rcu_head rcu;\n\tstruct upid numbers[];\n};\n\nextern struct pid init_struct_pid;\n\nextern const struct file_operations pidfd_fops;\n\nstruct file;\n\nextern struct pid *pidfd_pid(const struct file *file);\nstruct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags);\nstruct task_struct *pidfd_get_task(int pidfd, unsigned int *flags);\nint pidfd_create(struct pid *pid, unsigned int flags);\nint pidfd_prepare(struct pid *pid, unsigned int flags, struct file **ret);\n\nstatic inline struct pid *get_pid(struct pid *pid)\n{\n\tif (pid)\n\t\trefcount_inc(&pid->count);\n\treturn pid;\n}\n\nextern void put_pid(struct pid *pid);\nextern struct task_struct *pid_task(struct pid *pid, enum pid_type);\nstatic inline bool pid_has_task(struct pid *pid, enum pid_type type)\n{\n\treturn !hlist_empty(&pid->tasks[type]);\n}\nextern struct task_struct *get_pid_task(struct pid *pid, enum pid_type);\n\nextern struct pid *get_task_pid(struct task_struct *task, enum pid_type type);\n\n \nextern void attach_pid(struct task_struct *task, enum pid_type);\nextern void detach_pid(struct task_struct *task, enum pid_type);\nextern void change_pid(struct task_struct *task, enum pid_type,\n\t\t\tstruct pid *pid);\nextern void exchange_tids(struct task_struct *task, struct task_struct *old);\nextern void transfer_pid(struct task_struct *old, struct task_struct *new,\n\t\t\t enum pid_type);\n\nstruct pid_namespace;\nextern struct pid_namespace init_pid_ns;\n\nextern int pid_max;\nextern int pid_max_min, pid_max_max;\n\n \nextern struct pid *find_pid_ns(int nr, struct pid_namespace *ns);\nextern struct pid *find_vpid(int nr);\n\n \nextern struct pid *find_get_pid(int nr);\nextern struct pid *find_ge_pid(int nr, struct pid_namespace *);\n\nextern struct pid *alloc_pid(struct pid_namespace *ns, pid_t *set_tid,\n\t\t\t     size_t set_tid_size);\nextern void free_pid(struct pid *pid);\nextern void disable_pid_allocation(struct pid_namespace *ns);\n\n \nstatic inline struct pid_namespace *ns_of_pid(struct pid *pid)\n{\n\tstruct pid_namespace *ns = NULL;\n\tif (pid)\n\t\tns = pid->numbers[pid->level].ns;\n\treturn ns;\n}\n\n \nstatic inline bool is_child_reaper(struct pid *pid)\n{\n\treturn pid->numbers[pid->level].nr == 1;\n}\n\n \n\nstatic inline pid_t pid_nr(struct pid *pid)\n{\n\tpid_t nr = 0;\n\tif (pid)\n\t\tnr = pid->numbers[0].nr;\n\treturn nr;\n}\n\npid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns);\npid_t pid_vnr(struct pid *pid);\n\n#define do_each_pid_task(pid, type, task)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((pid) != NULL)\t\t\t\t\t\\\n\t\t\thlist_for_each_entry_rcu((task),\t\t\\\n\t\t\t\t&(pid)->tasks[type], pid_links[type]) {\n\n\t\t\t \n#define while_each_pid_task(pid, type, task)\t\t\t\t\\\n\t\t\t\tif (type == PIDTYPE_PID)\t\t\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t} while (0)\n\n#define do_each_pid_thread(pid, type, task)\t\t\t\t\\\n\tdo_each_pid_task(pid, type, task) {\t\t\t\t\\\n\t\tstruct task_struct *tg___ = task;\t\t\t\\\n\t\tfor_each_thread(tg___, task) {\n\n#define while_each_pid_thread(pid, type, task)\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\ttask = tg___;\t\t\t\t\t\t\\\n\t} while_each_pid_task(pid, type, task)\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}