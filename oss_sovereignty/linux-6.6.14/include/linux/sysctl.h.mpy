{
  "module_name": "sysctl.h",
  "hash_id": "f5eb2ced5cb6a6dfd2ce7e653a661c758da4f5a1d60c3371cf71e40cb8af687e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/sysctl.h",
  "human_readable_source": " \n \n#ifndef _LINUX_SYSCTL_H\n#define _LINUX_SYSCTL_H\n\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/uidgid.h>\n#include <uapi/linux/sysctl.h>\n\n \nstruct completion;\nstruct ctl_table;\nstruct nsproxy;\nstruct ctl_table_root;\nstruct ctl_table_header;\nstruct ctl_dir;\n\n \n#define SYSCTL_ZERO\t\t\t((void *)&sysctl_vals[0])\n#define SYSCTL_ONE\t\t\t((void *)&sysctl_vals[1])\n#define SYSCTL_TWO\t\t\t((void *)&sysctl_vals[2])\n#define SYSCTL_THREE\t\t\t((void *)&sysctl_vals[3])\n#define SYSCTL_FOUR\t\t\t((void *)&sysctl_vals[4])\n#define SYSCTL_ONE_HUNDRED\t\t((void *)&sysctl_vals[5])\n#define SYSCTL_TWO_HUNDRED\t\t((void *)&sysctl_vals[6])\n#define SYSCTL_ONE_THOUSAND\t\t((void *)&sysctl_vals[7])\n#define SYSCTL_THREE_THOUSAND\t\t((void *)&sysctl_vals[8])\n#define SYSCTL_INT_MAX\t\t\t((void *)&sysctl_vals[9])\n\n \n#define SYSCTL_MAXOLDUID\t\t((void *)&sysctl_vals[10])\n#define SYSCTL_NEG_ONE\t\t\t((void *)&sysctl_vals[11])\n\nextern const int sysctl_vals[];\n\n#define SYSCTL_LONG_ZERO\t((void *)&sysctl_long_vals[0])\n#define SYSCTL_LONG_ONE\t\t((void *)&sysctl_long_vals[1])\n#define SYSCTL_LONG_MAX\t\t((void *)&sysctl_long_vals[2])\n\nextern const unsigned long sysctl_long_vals[];\n\ntypedef int proc_handler(struct ctl_table *ctl, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos);\n\nint proc_dostring(struct ctl_table *, int, void *, size_t *, loff_t *);\nint proc_dobool(struct ctl_table *table, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos);\nint proc_dointvec(struct ctl_table *, int, void *, size_t *, loff_t *);\nint proc_douintvec(struct ctl_table *, int, void *, size_t *, loff_t *);\nint proc_dointvec_minmax(struct ctl_table *, int, void *, size_t *, loff_t *);\nint proc_douintvec_minmax(struct ctl_table *table, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos);\nint proc_dou8vec_minmax(struct ctl_table *table, int write, void *buffer,\n\t\t\tsize_t *lenp, loff_t *ppos);\nint proc_dointvec_jiffies(struct ctl_table *, int, void *, size_t *, loff_t *);\nint proc_dointvec_ms_jiffies_minmax(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos);\nint proc_dointvec_userhz_jiffies(struct ctl_table *, int, void *, size_t *,\n\t\tloff_t *);\nint proc_dointvec_ms_jiffies(struct ctl_table *, int, void *, size_t *,\n\t\tloff_t *);\nint proc_doulongvec_minmax(struct ctl_table *, int, void *, size_t *, loff_t *);\nint proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int, void *,\n\t\tsize_t *, loff_t *);\nint proc_do_large_bitmap(struct ctl_table *, int, void *, size_t *, loff_t *);\nint proc_do_static_key(struct ctl_table *table, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos);\n\n \n\n \nstruct ctl_table_poll {\n\tatomic_t event;\n\twait_queue_head_t wait;\n};\n\nstatic inline void *proc_sys_poll_event(struct ctl_table_poll *poll)\n{\n\treturn (void *)(unsigned long)atomic_read(&poll->event);\n}\n\n#define __CTL_TABLE_POLL_INITIALIZER(name) {\t\t\t\t\\\n\t.event = ATOMIC_INIT(0),\t\t\t\t\t\\\n\t.wait = __WAIT_QUEUE_HEAD_INITIALIZER(name.wait) }\n\n#define DEFINE_CTL_TABLE_POLL(name)\t\t\t\t\t\\\n\tstruct ctl_table_poll name = __CTL_TABLE_POLL_INITIALIZER(name)\n\n \nstruct ctl_table {\n\tconst char *procname;\t\t \n\tvoid *data;\n\tint maxlen;\n\tumode_t mode;\n\t \n\tenum {\n\t\tSYSCTL_TABLE_TYPE_DEFAULT,\n\t\tSYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY\n\t} type;\n\tproc_handler *proc_handler;\t \n\tstruct ctl_table_poll *poll;\n\tvoid *extra1;\n\tvoid *extra2;\n} __randomize_layout;\n\nstruct ctl_node {\n\tstruct rb_node node;\n\tstruct ctl_table_header *header;\n};\n\n \nstruct ctl_table_header {\n\tunion {\n\t\tstruct {\n\t\t\tstruct ctl_table *ctl_table;\n\t\t\tint ctl_table_size;\n\t\t\tint used;\n\t\t\tint count;\n\t\t\tint nreg;\n\t\t};\n\t\tstruct rcu_head rcu;\n\t};\n\tstruct completion *unregistering;\n\tstruct ctl_table *ctl_table_arg;\n\tstruct ctl_table_root *root;\n\tstruct ctl_table_set *set;\n\tstruct ctl_dir *parent;\n\tstruct ctl_node *node;\n\tstruct hlist_head inodes;  \n};\n\nstruct ctl_dir {\n\t \n\tstruct ctl_table_header header;\n\tstruct rb_root root;\n};\n\nstruct ctl_table_set {\n\tint (*is_seen)(struct ctl_table_set *);\n\tstruct ctl_dir dir;\n};\n\nstruct ctl_table_root {\n\tstruct ctl_table_set default_set;\n\tstruct ctl_table_set *(*lookup)(struct ctl_table_root *root);\n\tvoid (*set_ownership)(struct ctl_table_header *head,\n\t\t\t      struct ctl_table *table,\n\t\t\t      kuid_t *uid, kgid_t *gid);\n\tint (*permissions)(struct ctl_table_header *head, struct ctl_table *table);\n};\n\n \nstruct ctl_path {\n\tconst char *procname;\n};\n\n#define register_sysctl(path, table)\t\\\n\tregister_sysctl_sz(path, table, ARRAY_SIZE(table))\n\n#ifdef CONFIG_SYSCTL\n\nvoid proc_sys_poll_notify(struct ctl_table_poll *poll);\n\nextern void setup_sysctl_set(struct ctl_table_set *p,\n\tstruct ctl_table_root *root,\n\tint (*is_seen)(struct ctl_table_set *));\nextern void retire_sysctl_set(struct ctl_table_set *set);\n\nstruct ctl_table_header *__register_sysctl_table(\n\tstruct ctl_table_set *set,\n\tconst char *path, struct ctl_table *table, size_t table_size);\nstruct ctl_table_header *register_sysctl_sz(const char *path, struct ctl_table *table,\n\t\t\t\t\t    size_t table_size);\nvoid unregister_sysctl_table(struct ctl_table_header * table);\n\nextern int sysctl_init_bases(void);\nextern void __register_sysctl_init(const char *path, struct ctl_table *table,\n\t\t\t\t const char *table_name, size_t table_size);\n#define register_sysctl_init(path, table)\t\\\n\t__register_sysctl_init(path, table, #table, ARRAY_SIZE(table))\nextern struct ctl_table_header *register_sysctl_mount_point(const char *path);\n\nvoid do_sysctl_args(void);\nbool sysctl_is_alias(char *param);\nint do_proc_douintvec(struct ctl_table *table, int write,\n\t\t      void *buffer, size_t *lenp, loff_t *ppos,\n\t\t      int (*conv)(unsigned long *lvalp,\n\t\t\t\t  unsigned int *valp,\n\t\t\t\t  int write, void *data),\n\t\t      void *data);\n\nextern int pwrsw_enabled;\nextern int unaligned_enabled;\nextern int unaligned_dump_stack;\nextern int no_unaligned_warning;\n\n#define SYSCTL_PERM_EMPTY_DIR\t(1 << 0)\n\n#else  \n\nstatic inline void register_sysctl_init(const char *path, struct ctl_table *table)\n{\n}\n\nstatic inline struct ctl_table_header *register_sysctl_mount_point(const char *path)\n{\n\treturn NULL;\n}\n\nstatic inline struct ctl_table_header *register_sysctl_sz(const char *path,\n\t\t\t\t\t\t\t  struct ctl_table *table,\n\t\t\t\t\t\t\t  size_t table_size)\n{\n\treturn NULL;\n}\n\nstatic inline void unregister_sysctl_table(struct ctl_table_header * table)\n{\n}\n\nstatic inline void setup_sysctl_set(struct ctl_table_set *p,\n\tstruct ctl_table_root *root,\n\tint (*is_seen)(struct ctl_table_set *))\n{\n}\n\nstatic inline void do_sysctl_args(void)\n{\n}\n\nstatic inline bool sysctl_is_alias(char *param)\n{\n\treturn false;\n}\n#endif  \n\nint sysctl_max_threads(struct ctl_table *table, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}