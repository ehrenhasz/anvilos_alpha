{
  "module_name": "f2fs_fs.h",
  "hash_id": "c75dea9fbf5ce2f20c690abfbd8981fe4a465c816a752bbd563060dc6bac0a9f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/f2fs_fs.h",
  "human_readable_source": "\n \n#ifndef _LINUX_F2FS_FS_H\n#define _LINUX_F2FS_FS_H\n\n#include <linux/pagemap.h>\n#include <linux/types.h>\n\n#define F2FS_SUPER_OFFSET\t\t1024\t \n#define F2FS_MIN_LOG_SECTOR_SIZE\t9\t \n#define F2FS_MAX_LOG_SECTOR_SIZE\t12\t \n#define F2FS_LOG_SECTORS_PER_BLOCK\t3\t \n#define F2FS_BLKSIZE\t\t\t4096\t \n#define F2FS_BLKSIZE_BITS\t\t12\t \n#define F2FS_MAX_EXTENSION\t\t64\t \n#define F2FS_EXTENSION_LEN\t\t8\t \n#define F2FS_BLK_ALIGN(x)\t(((x) + F2FS_BLKSIZE - 1) >> F2FS_BLKSIZE_BITS)\n\n#define NULL_ADDR\t\t((block_t)0)\t \n#define NEW_ADDR\t\t((block_t)-1)\t \n#define COMPRESS_ADDR\t\t((block_t)-2)\t \n\n#define F2FS_BYTES_TO_BLK(bytes)\t((bytes) >> F2FS_BLKSIZE_BITS)\n#define F2FS_BLK_TO_BYTES(blk)\t\t((blk) << F2FS_BLKSIZE_BITS)\n\n \n#define F2FS_RESERVED_NODE_NUM\t\t3\n\n#define F2FS_ROOT_INO(sbi)\t((sbi)->root_ino_num)\n#define F2FS_NODE_INO(sbi)\t((sbi)->node_ino_num)\n#define F2FS_META_INO(sbi)\t((sbi)->meta_ino_num)\n#define F2FS_COMPRESS_INO(sbi)\t(NM_I(sbi)->max_nid)\n\n#define F2FS_MAX_QUOTAS\t\t3\n\n#define F2FS_ENC_UTF8_12_1\t1\n\n#define F2FS_IO_SIZE(sbi)\tBIT(F2FS_OPTION(sbi).write_io_size_bits)  \n#define F2FS_IO_SIZE_KB(sbi)\tBIT(F2FS_OPTION(sbi).write_io_size_bits + 2)  \n#define F2FS_IO_SIZE_BITS(sbi)\t(F2FS_OPTION(sbi).write_io_size_bits)  \n#define F2FS_IO_SIZE_MASK(sbi)\t(F2FS_IO_SIZE(sbi) - 1)\n#define F2FS_IO_ALIGNED(sbi)\t(F2FS_IO_SIZE(sbi) > 1)\n\n \n#define GFP_F2FS_ZERO\t\t(GFP_NOFS | __GFP_ZERO)\n\n \n#define MAX_ACTIVE_LOGS\t16\n#define MAX_ACTIVE_NODE_LOGS\t8\n#define MAX_ACTIVE_DATA_LOGS\t8\n\n#define VERSION_LEN\t256\n#define MAX_VOLUME_NAME\t\t512\n#define MAX_PATH_LEN\t\t64\n#define MAX_DEVICES\t\t8\n\n \nstruct f2fs_device {\n\t__u8 path[MAX_PATH_LEN];\n\t__le32 total_segments;\n} __packed;\n\n \nenum stop_cp_reason {\n\tSTOP_CP_REASON_SHUTDOWN,\n\tSTOP_CP_REASON_FAULT_INJECT,\n\tSTOP_CP_REASON_META_PAGE,\n\tSTOP_CP_REASON_WRITE_FAIL,\n\tSTOP_CP_REASON_CORRUPTED_SUMMARY,\n\tSTOP_CP_REASON_UPDATE_INODE,\n\tSTOP_CP_REASON_FLUSH_FAIL,\n\tSTOP_CP_REASON_MAX,\n};\n\n#define\tMAX_STOP_REASON\t\t\t32\n\n \nenum f2fs_error {\n\tERROR_CORRUPTED_CLUSTER,\n\tERROR_FAIL_DECOMPRESSION,\n\tERROR_INVALID_BLKADDR,\n\tERROR_CORRUPTED_DIRENT,\n\tERROR_CORRUPTED_INODE,\n\tERROR_INCONSISTENT_SUMMARY,\n\tERROR_INCONSISTENT_FOOTER,\n\tERROR_INCONSISTENT_SUM_TYPE,\n\tERROR_CORRUPTED_JOURNAL,\n\tERROR_INCONSISTENT_NODE_COUNT,\n\tERROR_INCONSISTENT_BLOCK_COUNT,\n\tERROR_INVALID_CURSEG,\n\tERROR_INCONSISTENT_SIT,\n\tERROR_CORRUPTED_VERITY_XATTR,\n\tERROR_CORRUPTED_XATTR,\n\tERROR_INVALID_NODE_REFERENCE,\n\tERROR_INCONSISTENT_NAT,\n\tERROR_MAX,\n};\n\n#define MAX_F2FS_ERRORS\t\t\t16\n\nstruct f2fs_super_block {\n\t__le32 magic;\t\t\t \n\t__le16 major_ver;\t\t \n\t__le16 minor_ver;\t\t \n\t__le32 log_sectorsize;\t\t \n\t__le32 log_sectors_per_block;\t \n\t__le32 log_blocksize;\t\t \n\t__le32 log_blocks_per_seg;\t \n\t__le32 segs_per_sec;\t\t \n\t__le32 secs_per_zone;\t\t \n\t__le32 checksum_offset;\t\t \n\t__le64 block_count;\t\t \n\t__le32 section_count;\t\t \n\t__le32 segment_count;\t\t \n\t__le32 segment_count_ckpt;\t \n\t__le32 segment_count_sit;\t \n\t__le32 segment_count_nat;\t \n\t__le32 segment_count_ssa;\t \n\t__le32 segment_count_main;\t \n\t__le32 segment0_blkaddr;\t \n\t__le32 cp_blkaddr;\t\t \n\t__le32 sit_blkaddr;\t\t \n\t__le32 nat_blkaddr;\t\t \n\t__le32 ssa_blkaddr;\t\t \n\t__le32 main_blkaddr;\t\t \n\t__le32 root_ino;\t\t \n\t__le32 node_ino;\t\t \n\t__le32 meta_ino;\t\t \n\t__u8 uuid[16];\t\t\t \n\t__le16 volume_name[MAX_VOLUME_NAME];\t \n\t__le32 extension_count;\t\t \n\t__u8 extension_list[F2FS_MAX_EXTENSION][F2FS_EXTENSION_LEN]; \n\t__le32 cp_payload;\n\t__u8 version[VERSION_LEN];\t \n\t__u8 init_version[VERSION_LEN];\t \n\t__le32 feature;\t\t\t \n\t__u8 encryption_level;\t\t \n\t__u8 encrypt_pw_salt[16];\t \n\tstruct f2fs_device devs[MAX_DEVICES];\t \n\t__le32 qf_ino[F2FS_MAX_QUOTAS];\t \n\t__u8 hot_ext_count;\t\t \n\t__le16  s_encoding;\t\t \n\t__le16  s_encoding_flags;\t \n\t__u8 s_stop_reason[MAX_STOP_REASON];\t \n\t__u8 s_errors[MAX_F2FS_ERRORS];\t\t \n\t__u8 reserved[258];\t\t \n\t__le32 crc;\t\t\t \n} __packed;\n\n \n#define CP_RESIZEFS_FLAG\t\t0x00004000\n#define CP_DISABLED_QUICK_FLAG\t\t0x00002000\n#define CP_DISABLED_FLAG\t\t0x00001000\n#define CP_QUOTA_NEED_FSCK_FLAG\t\t0x00000800\n#define CP_LARGE_NAT_BITMAP_FLAG\t0x00000400\n#define CP_NOCRC_RECOVERY_FLAG\t0x00000200\n#define CP_TRIMMED_FLAG\t\t0x00000100\n#define CP_NAT_BITS_FLAG\t0x00000080\n#define CP_CRC_RECOVERY_FLAG\t0x00000040\n#define CP_FASTBOOT_FLAG\t0x00000020\n#define CP_FSCK_FLAG\t\t0x00000010\n#define CP_ERROR_FLAG\t\t0x00000008\n#define CP_COMPACT_SUM_FLAG\t0x00000004\n#define CP_ORPHAN_PRESENT_FLAG\t0x00000002\n#define CP_UMOUNT_FLAG\t\t0x00000001\n\n#define F2FS_CP_PACKS\t\t2\t \n\nstruct f2fs_checkpoint {\n\t__le64 checkpoint_ver;\t\t \n\t__le64 user_block_count;\t \n\t__le64 valid_block_count;\t \n\t__le32 rsvd_segment_count;\t \n\t__le32 overprov_segment_count;\t \n\t__le32 free_segment_count;\t \n\n\t \n\t__le32 cur_node_segno[MAX_ACTIVE_NODE_LOGS];\n\t__le16 cur_node_blkoff[MAX_ACTIVE_NODE_LOGS];\n\t \n\t__le32 cur_data_segno[MAX_ACTIVE_DATA_LOGS];\n\t__le16 cur_data_blkoff[MAX_ACTIVE_DATA_LOGS];\n\t__le32 ckpt_flags;\t\t \n\t__le32 cp_pack_total_block_count;\t \n\t__le32 cp_pack_start_sum;\t \n\t__le32 valid_node_count;\t \n\t__le32 valid_inode_count;\t \n\t__le32 next_free_nid;\t\t \n\t__le32 sit_ver_bitmap_bytesize;\t \n\t__le32 nat_ver_bitmap_bytesize;  \n\t__le32 checksum_offset;\t\t \n\t__le64 elapsed_time;\t\t \n\t \n\tunsigned char alloc_type[MAX_ACTIVE_LOGS];\n\n\t \n\tunsigned char sit_nat_version_bitmap[];\n} __packed;\n\n#define CP_CHKSUM_OFFSET\t4092\t \n#define CP_MIN_CHKSUM_OFFSET\t\t\t\t\t\t\\\n\t(offsetof(struct f2fs_checkpoint, sit_nat_version_bitmap))\n\n \n#define F2FS_ORPHANS_PER_BLOCK\t1020\n\n#define GET_ORPHAN_BLOCKS(n)\t(((n) + F2FS_ORPHANS_PER_BLOCK - 1) / \\\n\t\t\t\t\tF2FS_ORPHANS_PER_BLOCK)\n\nstruct f2fs_orphan_block {\n\t__le32 ino[F2FS_ORPHANS_PER_BLOCK];\t \n\t__le32 reserved;\t \n\t__le16 blk_addr;\t \n\t__le16 blk_count;\t \n\t__le32 entry_count;\t \n\t__le32 check_sum;\t \n} __packed;\n\n \nstruct f2fs_extent {\n\t__le32 fofs;\t\t \n\t__le32 blk;\t\t \n\t__le32 len;\t\t \n} __packed;\n\n#define F2FS_NAME_LEN\t\t255\n \n#define DEFAULT_INLINE_XATTR_ADDRS\t50\n#define DEF_ADDRS_PER_INODE\t923\t \n#define CUR_ADDRS_PER_INODE(inode)\t(DEF_ADDRS_PER_INODE - \\\n\t\t\t\t\tget_extra_isize(inode))\n#define DEF_NIDS_PER_INODE\t5\t \n#define ADDRS_PER_INODE(inode)\taddrs_per_inode(inode)\n#define DEF_ADDRS_PER_BLOCK\t1018\t \n#define ADDRS_PER_BLOCK(inode)\taddrs_per_block(inode)\n#define NIDS_PER_BLOCK\t\t1018\t \n\n#define ADDRS_PER_PAGE(page, inode)\t\\\n\t(IS_INODE(page) ? ADDRS_PER_INODE(inode) : ADDRS_PER_BLOCK(inode))\n\n#define\tNODE_DIR1_BLOCK\t\t(DEF_ADDRS_PER_INODE + 1)\n#define\tNODE_DIR2_BLOCK\t\t(DEF_ADDRS_PER_INODE + 2)\n#define\tNODE_IND1_BLOCK\t\t(DEF_ADDRS_PER_INODE + 3)\n#define\tNODE_IND2_BLOCK\t\t(DEF_ADDRS_PER_INODE + 4)\n#define\tNODE_DIND_BLOCK\t\t(DEF_ADDRS_PER_INODE + 5)\n\n#define F2FS_INLINE_XATTR\t0x01\t \n#define F2FS_INLINE_DATA\t0x02\t \n#define F2FS_INLINE_DENTRY\t0x04\t \n#define F2FS_DATA_EXIST\t\t0x08\t \n#define F2FS_INLINE_DOTS\t0x10\t \n#define F2FS_EXTRA_ATTR\t\t0x20\t \n#define F2FS_PIN_FILE\t\t0x40\t \n#define F2FS_COMPRESS_RELEASED\t0x80\t \n\nstruct f2fs_inode {\n\t__le16 i_mode;\t\t\t \n\t__u8 i_advise;\t\t\t \n\t__u8 i_inline;\t\t\t \n\t__le32 i_uid;\t\t\t \n\t__le32 i_gid;\t\t\t \n\t__le32 i_links;\t\t\t \n\t__le64 i_size;\t\t\t \n\t__le64 i_blocks;\t\t \n\t__le64 i_atime;\t\t\t \n\t__le64 i_ctime;\t\t\t \n\t__le64 i_mtime;\t\t\t \n\t__le32 i_atime_nsec;\t\t \n\t__le32 i_ctime_nsec;\t\t \n\t__le32 i_mtime_nsec;\t\t \n\t__le32 i_generation;\t\t \n\tunion {\n\t\t__le32 i_current_depth;\t \n\t\t__le16 i_gc_failures;\t \n\t};\n\t__le32 i_xattr_nid;\t\t \n\t__le32 i_flags;\t\t\t \n\t__le32 i_pino;\t\t\t \n\t__le32 i_namelen;\t\t \n\t__u8 i_name[F2FS_NAME_LEN];\t \n\t__u8 i_dir_level;\t\t \n\n\tstruct f2fs_extent i_ext;\t \n\n\tunion {\n\t\tstruct {\n\t\t\t__le16 i_extra_isize;\t \n\t\t\t__le16 i_inline_xattr_size;\t \n\t\t\t__le32 i_projid;\t \n\t\t\t__le32 i_inode_checksum; \n\t\t\t__le64 i_crtime;\t \n\t\t\t__le32 i_crtime_nsec;\t \n\t\t\t__le64 i_compr_blocks;\t \n\t\t\t__u8 i_compress_algorithm;\t \n\t\t\t__u8 i_log_cluster_size;\t \n\t\t\t__le16 i_compress_flag;\t\t \n\t\t\t\t\t\t \n\t\t\t__le32 i_extra_end[0];\t \n\t\t} __packed;\n\t\t__le32 i_addr[DEF_ADDRS_PER_INODE];\t \n\t};\n\t__le32 i_nid[DEF_NIDS_PER_INODE];\t \n} __packed;\n\nstruct direct_node {\n\t__le32 addr[DEF_ADDRS_PER_BLOCK];\t \n} __packed;\n\nstruct indirect_node {\n\t__le32 nid[NIDS_PER_BLOCK];\t \n} __packed;\n\nenum {\n\tCOLD_BIT_SHIFT = 0,\n\tFSYNC_BIT_SHIFT,\n\tDENT_BIT_SHIFT,\n\tOFFSET_BIT_SHIFT\n};\n\n#define OFFSET_BIT_MASK\t\tGENMASK(OFFSET_BIT_SHIFT - 1, 0)\n\nstruct node_footer {\n\t__le32 nid;\t\t \n\t__le32 ino;\t\t \n\t__le32 flag;\t\t \n\t__le64 cp_ver;\t\t \n\t__le32 next_blkaddr;\t \n} __packed;\n\nstruct f2fs_node {\n\t \n\tunion {\n\t\tstruct f2fs_inode i;\n\t\tstruct direct_node dn;\n\t\tstruct indirect_node in;\n\t};\n\tstruct node_footer footer;\n} __packed;\n\n \n#define NAT_ENTRY_PER_BLOCK (PAGE_SIZE / sizeof(struct f2fs_nat_entry))\n\nstruct f2fs_nat_entry {\n\t__u8 version;\t\t \n\t__le32 ino;\t\t \n\t__le32 block_addr;\t \n} __packed;\n\nstruct f2fs_nat_block {\n\tstruct f2fs_nat_entry entries[NAT_ENTRY_PER_BLOCK];\n} __packed;\n\n \n#define SIT_VBLOCK_MAP_SIZE 64\n#define SIT_ENTRY_PER_BLOCK (PAGE_SIZE / sizeof(struct f2fs_sit_entry))\n\n \n#define F2FS_MAX_SEGMENT       ((16 * 1024 * 1024) / 2)\n\n \n#define SIT_VBLOCKS_SHIFT\t10\n#define SIT_VBLOCKS_MASK\t((1 << SIT_VBLOCKS_SHIFT) - 1)\n#define GET_SIT_VBLOCKS(raw_sit)\t\t\t\t\\\n\t(le16_to_cpu((raw_sit)->vblocks) & SIT_VBLOCKS_MASK)\n#define GET_SIT_TYPE(raw_sit)\t\t\t\t\t\\\n\t((le16_to_cpu((raw_sit)->vblocks) & ~SIT_VBLOCKS_MASK)\t\\\n\t >> SIT_VBLOCKS_SHIFT)\n\nstruct f2fs_sit_entry {\n\t__le16 vblocks;\t\t\t\t \n\t__u8 valid_map[SIT_VBLOCK_MAP_SIZE];\t \n\t__le64 mtime;\t\t\t\t \n} __packed;\n\nstruct f2fs_sit_block {\n\tstruct f2fs_sit_entry entries[SIT_ENTRY_PER_BLOCK];\n} __packed;\n\n \n#define ENTRIES_IN_SUM\t\t512\n#define\tSUMMARY_SIZE\t\t(7)\t \n#define\tSUM_FOOTER_SIZE\t\t(5)\t \n#define SUM_ENTRY_SIZE\t\t(SUMMARY_SIZE * ENTRIES_IN_SUM)\n\n \nstruct f2fs_summary {\n\t__le32 nid;\t\t \n\tunion {\n\t\t__u8 reserved[3];\n\t\tstruct {\n\t\t\t__u8 version;\t\t \n\t\t\t__le16 ofs_in_node;\t \n\t\t} __packed;\n\t};\n} __packed;\n\n \n#define SUM_TYPE_NODE\t\t(1)\n#define SUM_TYPE_DATA\t\t(0)\n\nstruct summary_footer {\n\tunsigned char entry_type;\t \n\t__le32 check_sum;\t\t \n} __packed;\n\n#define SUM_JOURNAL_SIZE\t(F2FS_BLKSIZE - SUM_FOOTER_SIZE -\\\n\t\t\t\tSUM_ENTRY_SIZE)\n#define NAT_JOURNAL_ENTRIES\t((SUM_JOURNAL_SIZE - 2) /\\\n\t\t\t\tsizeof(struct nat_journal_entry))\n#define NAT_JOURNAL_RESERVED\t((SUM_JOURNAL_SIZE - 2) %\\\n\t\t\t\tsizeof(struct nat_journal_entry))\n#define SIT_JOURNAL_ENTRIES\t((SUM_JOURNAL_SIZE - 2) /\\\n\t\t\t\tsizeof(struct sit_journal_entry))\n#define SIT_JOURNAL_RESERVED\t((SUM_JOURNAL_SIZE - 2) %\\\n\t\t\t\tsizeof(struct sit_journal_entry))\n\n \n#define EXTRA_INFO_RESERVED\t(SUM_JOURNAL_SIZE - 2 - 8)\n\n \nenum {\n\tNAT_JOURNAL = 0,\n\tSIT_JOURNAL\n};\n\nstruct nat_journal_entry {\n\t__le32 nid;\n\tstruct f2fs_nat_entry ne;\n} __packed;\n\nstruct nat_journal {\n\tstruct nat_journal_entry entries[NAT_JOURNAL_ENTRIES];\n\t__u8 reserved[NAT_JOURNAL_RESERVED];\n} __packed;\n\nstruct sit_journal_entry {\n\t__le32 segno;\n\tstruct f2fs_sit_entry se;\n} __packed;\n\nstruct sit_journal {\n\tstruct sit_journal_entry entries[SIT_JOURNAL_ENTRIES];\n\t__u8 reserved[SIT_JOURNAL_RESERVED];\n} __packed;\n\nstruct f2fs_extra_info {\n\t__le64 kbytes_written;\n\t__u8 reserved[EXTRA_INFO_RESERVED];\n} __packed;\n\nstruct f2fs_journal {\n\tunion {\n\t\t__le16 n_nats;\n\t\t__le16 n_sits;\n\t};\n\t \n\tunion {\n\t\tstruct nat_journal nat_j;\n\t\tstruct sit_journal sit_j;\n\t\tstruct f2fs_extra_info info;\n\t};\n} __packed;\n\n \nstruct f2fs_summary_block {\n\tstruct f2fs_summary entries[ENTRIES_IN_SUM];\n\tstruct f2fs_journal journal;\n\tstruct summary_footer footer;\n} __packed;\n\n \n#define F2FS_DOT_HASH\t\t0\n#define F2FS_DDOT_HASH\t\tF2FS_DOT_HASH\n#define F2FS_MAX_HASH\t\t(~((0x3ULL) << 62))\n#define F2FS_HASH_COL_BIT\t((0x1ULL) << 63)\n\ntypedef __le32\tf2fs_hash_t;\n\n \n#define F2FS_SLOT_LEN\t\t8\n#define F2FS_SLOT_LEN_BITS\t3\n\n#define GET_DENTRY_SLOTS(x) (((x) + F2FS_SLOT_LEN - 1) >> F2FS_SLOT_LEN_BITS)\n\n \n#define MAX_DIR_HASH_DEPTH\t63\n\n \n#define MAX_DIR_BUCKETS\t\tBIT((MAX_DIR_HASH_DEPTH / 2) - 1)\n\n \n#define NR_DENTRY_IN_BLOCK\t214\t \n#define SIZE_OF_DIR_ENTRY\t11\t \n#define SIZE_OF_DENTRY_BITMAP\t((NR_DENTRY_IN_BLOCK + BITS_PER_BYTE - 1) / \\\n\t\t\t\t\tBITS_PER_BYTE)\n#define SIZE_OF_RESERVED\t(PAGE_SIZE - ((SIZE_OF_DIR_ENTRY + \\\n\t\t\t\tF2FS_SLOT_LEN) * \\\n\t\t\t\tNR_DENTRY_IN_BLOCK + SIZE_OF_DENTRY_BITMAP))\n#define MIN_INLINE_DENTRY_SIZE\t\t40\t \n\n \nstruct f2fs_dir_entry {\n\t__le32 hash_code;\t \n\t__le32 ino;\t\t \n\t__le16 name_len;\t \n\t__u8 file_type;\t\t \n} __packed;\n\n \nstruct f2fs_dentry_block {\n\t \n\t__u8 dentry_bitmap[SIZE_OF_DENTRY_BITMAP];\n\t__u8 reserved[SIZE_OF_RESERVED];\n\tstruct f2fs_dir_entry dentry[NR_DENTRY_IN_BLOCK];\n\t__u8 filename[NR_DENTRY_IN_BLOCK][F2FS_SLOT_LEN];\n} __packed;\n\n#define\tF2FS_DEF_PROJID\t\t0\t \n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}