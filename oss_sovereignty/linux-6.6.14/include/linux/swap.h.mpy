{
  "module_name": "swap.h",
  "hash_id": "d42944cd2f1b4d12aaf7e3701d675df14cead541c7796b8adb546c84243ff433",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/swap.h",
  "human_readable_source": " \n#ifndef _LINUX_SWAP_H\n#define _LINUX_SWAP_H\n\n#include <linux/spinlock.h>\n#include <linux/linkage.h>\n#include <linux/mmzone.h>\n#include <linux/list.h>\n#include <linux/memcontrol.h>\n#include <linux/sched.h>\n#include <linux/node.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/atomic.h>\n#include <linux/page-flags.h>\n#include <uapi/linux/mempolicy.h>\n#include <asm/page.h>\n\nstruct notifier_block;\n\nstruct bio;\n\nstruct pagevec;\n\n#define SWAP_FLAG_PREFER\t0x8000\t \n#define SWAP_FLAG_PRIO_MASK\t0x7fff\n#define SWAP_FLAG_PRIO_SHIFT\t0\n#define SWAP_FLAG_DISCARD\t0x10000  \n#define SWAP_FLAG_DISCARD_ONCE\t0x20000  \n#define SWAP_FLAG_DISCARD_PAGES 0x40000  \n\n#define SWAP_FLAGS_VALID\t(SWAP_FLAG_PRIO_MASK | SWAP_FLAG_PREFER | \\\n\t\t\t\t SWAP_FLAG_DISCARD | SWAP_FLAG_DISCARD_ONCE | \\\n\t\t\t\t SWAP_FLAG_DISCARD_PAGES)\n#define SWAP_BATCH 64\n\nstatic inline int current_is_kswapd(void)\n{\n\treturn current->flags & PF_KSWAPD;\n}\n\n \n#define MAX_SWAPFILES_SHIFT\t5\n\n \n\n \n#define SWP_PTE_MARKER_NUM 1\n#define SWP_PTE_MARKER     (MAX_SWAPFILES + SWP_HWPOISON_NUM + \\\n\t\t\t    SWP_MIGRATION_NUM + SWP_DEVICE_NUM)\n\n \n#ifdef CONFIG_DEVICE_PRIVATE\n#define SWP_DEVICE_NUM 4\n#define SWP_DEVICE_WRITE (MAX_SWAPFILES+SWP_HWPOISON_NUM+SWP_MIGRATION_NUM)\n#define SWP_DEVICE_READ (MAX_SWAPFILES+SWP_HWPOISON_NUM+SWP_MIGRATION_NUM+1)\n#define SWP_DEVICE_EXCLUSIVE_WRITE (MAX_SWAPFILES+SWP_HWPOISON_NUM+SWP_MIGRATION_NUM+2)\n#define SWP_DEVICE_EXCLUSIVE_READ (MAX_SWAPFILES+SWP_HWPOISON_NUM+SWP_MIGRATION_NUM+3)\n#else\n#define SWP_DEVICE_NUM 0\n#endif\n\n \n#ifdef CONFIG_MIGRATION\n#define SWP_MIGRATION_NUM 3\n#define SWP_MIGRATION_READ (MAX_SWAPFILES + SWP_HWPOISON_NUM)\n#define SWP_MIGRATION_READ_EXCLUSIVE (MAX_SWAPFILES + SWP_HWPOISON_NUM + 1)\n#define SWP_MIGRATION_WRITE (MAX_SWAPFILES + SWP_HWPOISON_NUM + 2)\n#else\n#define SWP_MIGRATION_NUM 0\n#endif\n\n \n#ifdef CONFIG_MEMORY_FAILURE\n#define SWP_HWPOISON_NUM 1\n#define SWP_HWPOISON\t\tMAX_SWAPFILES\n#else\n#define SWP_HWPOISON_NUM 0\n#endif\n\n#define MAX_SWAPFILES \\\n\t((1 << MAX_SWAPFILES_SHIFT) - SWP_DEVICE_NUM - \\\n\tSWP_MIGRATION_NUM - SWP_HWPOISON_NUM - \\\n\tSWP_PTE_MARKER_NUM)\n\n \nunion swap_header {\n\tstruct {\n\t\tchar reserved[PAGE_SIZE - 10];\n\t\tchar magic[10];\t\t\t \n\t} magic;\n\tstruct {\n\t\tchar\t\tbootbits[1024];\t \n\t\t__u32\t\tversion;\n\t\t__u32\t\tlast_page;\n\t\t__u32\t\tnr_badpages;\n\t\tunsigned char\tsws_uuid[16];\n\t\tunsigned char\tsws_volume[16];\n\t\t__u32\t\tpadding[117];\n\t\t__u32\t\tbadpages[1];\n\t} info;\n};\n\n \nstruct reclaim_state {\n\t \n\tunsigned long reclaimed;\n#ifdef CONFIG_LRU_GEN\n\t \n\tstruct lru_gen_mm_walk *mm_walk;\n#endif\n};\n\n \nstatic inline void mm_account_reclaimed_pages(unsigned long pages)\n{\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed += pages;\n}\n\n#ifdef __KERNEL__\n\nstruct address_space;\nstruct sysinfo;\nstruct writeback_control;\nstruct zone;\n\n \nstruct swap_extent {\n\tstruct rb_node rb_node;\n\tpgoff_t start_page;\n\tpgoff_t nr_pages;\n\tsector_t start_block;\n};\n\n \n#define MAX_SWAP_BADPAGES \\\n\t((offsetof(union swap_header, magic.magic) - \\\n\t  offsetof(union swap_header, info.badpages)) / sizeof(int))\n\nenum {\n\tSWP_USED\t= (1 << 0),\t \n\tSWP_WRITEOK\t= (1 << 1),\t \n\tSWP_DISCARDABLE = (1 << 2),\t \n\tSWP_DISCARDING\t= (1 << 3),\t \n\tSWP_SOLIDSTATE\t= (1 << 4),\t \n\tSWP_CONTINUED\t= (1 << 5),\t \n\tSWP_BLKDEV\t= (1 << 6),\t \n\tSWP_ACTIVATED\t= (1 << 7),\t \n\tSWP_FS_OPS\t= (1 << 8),\t \n\tSWP_AREA_DISCARD = (1 << 9),\t \n\tSWP_PAGE_DISCARD = (1 << 10),\t \n\tSWP_STABLE_WRITES = (1 << 11),\t \n\tSWP_SYNCHRONOUS_IO = (1 << 12),\t \n\t\t\t\t\t \n\tSWP_SCANNING\t= (1 << 14),\t \n};\n\n#define SWAP_CLUSTER_MAX 32UL\n#define COMPACT_CLUSTER_MAX SWAP_CLUSTER_MAX\n\n \n#define SWAP_HAS_CACHE\t0x40\t \n#define COUNT_CONTINUED\t0x80\t \n\n \n#define SWAP_MAP_MAX\t0x3e\t \n#define SWAP_MAP_BAD\t0x3f\t \n#define SWAP_MAP_SHMEM\t0xbf\t \n\n \n#define SWAP_CONT_MAX\t0x7f\t \n\n \nstruct swap_cluster_info {\n\tspinlock_t lock;\t \n\tunsigned int data:24;\n\tunsigned int flags:8;\n};\n#define CLUSTER_FLAG_FREE 1  \n#define CLUSTER_FLAG_NEXT_NULL 2  \n#define CLUSTER_FLAG_HUGE 4  \n\n \nstruct percpu_cluster {\n\tstruct swap_cluster_info index;  \n\tunsigned int next;  \n};\n\nstruct swap_cluster_list {\n\tstruct swap_cluster_info head;\n\tstruct swap_cluster_info tail;\n};\n\n \nstruct swap_info_struct {\n\tstruct percpu_ref users;\t \n\tunsigned long\tflags;\t\t \n\tsigned short\tprio;\t\t \n\tstruct plist_node list;\t\t \n\tsigned char\ttype;\t\t \n\tunsigned int\tmax;\t\t \n\tunsigned char *swap_map;\t \n\tstruct swap_cluster_info *cluster_info;  \n\tstruct swap_cluster_list free_clusters;  \n\tunsigned int lowest_bit;\t \n\tunsigned int highest_bit;\t \n\tunsigned int pages;\t\t \n\tunsigned int inuse_pages;\t \n\tunsigned int cluster_next;\t \n\tunsigned int cluster_nr;\t \n\tunsigned int __percpu *cluster_next_cpu;  \n\tstruct percpu_cluster __percpu *percpu_cluster;  \n\tstruct rb_root swap_extent_root; \n\tstruct block_device *bdev;\t \n\tstruct file *swap_file;\t\t \n\tunsigned int old_block_size;\t \n\tstruct completion comp;\t\t \n\tspinlock_t lock;\t\t \n\tspinlock_t cont_lock;\t\t \n\tstruct work_struct discard_work;  \n\tstruct swap_cluster_list discard_clusters;  \n\tstruct plist_node avail_lists[];  \n};\n\nstatic inline swp_entry_t page_swap_entry(struct page *page)\n{\n\tstruct folio *folio = page_folio(page);\n\tswp_entry_t entry = folio->swap;\n\n\tentry.val += folio_page_idx(folio, page);\n\treturn entry;\n}\n\n \nbool workingset_test_recent(void *shadow, bool file, bool *workingset);\nvoid workingset_age_nonresident(struct lruvec *lruvec, unsigned long nr_pages);\nvoid *workingset_eviction(struct folio *folio, struct mem_cgroup *target_memcg);\nvoid workingset_refault(struct folio *folio, void *shadow);\nvoid workingset_activation(struct folio *folio);\n\n \nvoid workingset_update_node(struct xa_node *node);\nextern struct list_lru shadow_nodes;\n#define mapping_set_update(xas, mapping) do {\t\t\t\t\\\n\tif (!dax_mapping(mapping) && !shmem_mapping(mapping)) {\t\t\\\n\t\txas_set_update(xas, workingset_update_node);\t\t\\\n\t\txas_set_lru(xas, &shadow_nodes);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \nextern unsigned long totalreserve_pages;\n\n \n#define nr_free_pages() global_zone_page_state(NR_FREE_PAGES)\n\n\n \nvoid lru_note_cost(struct lruvec *lruvec, bool file,\n\t\t   unsigned int nr_io, unsigned int nr_rotated);\nvoid lru_note_cost_refault(struct folio *);\nvoid folio_add_lru(struct folio *);\nvoid folio_add_lru_vma(struct folio *, struct vm_area_struct *);\nvoid mark_page_accessed(struct page *);\nvoid folio_mark_accessed(struct folio *);\n\nextern atomic_t lru_disable_count;\n\nstatic inline bool lru_cache_disabled(void)\n{\n\treturn atomic_read(&lru_disable_count);\n}\n\nstatic inline void lru_cache_enable(void)\n{\n\tatomic_dec(&lru_disable_count);\n}\n\nextern void lru_cache_disable(void);\nextern void lru_add_drain(void);\nextern void lru_add_drain_cpu(int cpu);\nextern void lru_add_drain_cpu_zone(struct zone *zone);\nextern void lru_add_drain_all(void);\nvoid folio_deactivate(struct folio *folio);\nvoid folio_mark_lazyfree(struct folio *folio);\nextern void swap_setup(void);\n\nextern void lru_cache_add_inactive_or_unevictable(struct page *page,\n\t\t\t\t\t\tstruct vm_area_struct *vma);\n\n \nextern unsigned long zone_reclaimable_pages(struct zone *zone);\nextern unsigned long try_to_free_pages(struct zonelist *zonelist, int order,\n\t\t\t\t\tgfp_t gfp_mask, nodemask_t *mask);\n\n#define MEMCG_RECLAIM_MAY_SWAP (1 << 1)\n#define MEMCG_RECLAIM_PROACTIVE (1 << 2)\nextern unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t\t  unsigned long nr_pages,\n\t\t\t\t\t\t  gfp_t gfp_mask,\n\t\t\t\t\t\t  unsigned int reclaim_options);\nextern unsigned long mem_cgroup_shrink_node(struct mem_cgroup *mem,\n\t\t\t\t\t\tgfp_t gfp_mask, bool noswap,\n\t\t\t\t\t\tpg_data_t *pgdat,\n\t\t\t\t\t\tunsigned long *nr_scanned);\nextern unsigned long shrink_all_memory(unsigned long nr_pages);\nextern int vm_swappiness;\nlong remove_mapping(struct address_space *mapping, struct folio *folio);\n\n#ifdef CONFIG_NUMA\nextern int node_reclaim_mode;\nextern int sysctl_min_unmapped_ratio;\nextern int sysctl_min_slab_ratio;\n#else\n#define node_reclaim_mode 0\n#endif\n\nstatic inline bool node_reclaim_enabled(void)\n{\n\t \n\treturn node_reclaim_mode & (RECLAIM_ZONE|RECLAIM_WRITE|RECLAIM_UNMAP);\n}\n\nvoid check_move_unevictable_folios(struct folio_batch *fbatch);\n\nextern void __meminit kswapd_run(int nid);\nextern void __meminit kswapd_stop(int nid);\n\n#ifdef CONFIG_SWAP\n\nint add_swap_extent(struct swap_info_struct *sis, unsigned long start_page,\n\t\tunsigned long nr_pages, sector_t start_block);\nint generic_swapfile_activate(struct swap_info_struct *, struct file *,\n\t\tsector_t *);\n\nstatic inline unsigned long total_swapcache_pages(void)\n{\n\treturn global_node_page_state(NR_SWAPCACHE);\n}\n\nextern void free_swap_cache(struct page *page);\nextern void free_page_and_swap_cache(struct page *);\nextern void free_pages_and_swap_cache(struct encoded_page **, int);\n \nextern atomic_long_t nr_swap_pages;\nextern long total_swap_pages;\nextern atomic_t nr_rotate_swap;\nextern bool has_usable_swap(void);\n\n \nstatic inline bool vm_swap_full(void)\n{\n\treturn atomic_long_read(&nr_swap_pages) * 2 < total_swap_pages;\n}\n\nstatic inline long get_nr_swap_pages(void)\n{\n\treturn atomic_long_read(&nr_swap_pages);\n}\n\nextern void si_swapinfo(struct sysinfo *);\nswp_entry_t folio_alloc_swap(struct folio *folio);\nbool folio_free_swap(struct folio *folio);\nvoid put_swap_folio(struct folio *folio, swp_entry_t entry);\nextern swp_entry_t get_swap_page_of_type(int);\nextern int get_swap_pages(int n, swp_entry_t swp_entries[], int entry_size);\nextern int add_swap_count_continuation(swp_entry_t, gfp_t);\nextern void swap_shmem_alloc(swp_entry_t);\nextern int swap_duplicate(swp_entry_t);\nextern int swapcache_prepare(swp_entry_t);\nextern void swap_free(swp_entry_t);\nextern void swapcache_free_entries(swp_entry_t *entries, int n);\nextern int free_swap_and_cache(swp_entry_t);\nint swap_type_of(dev_t device, sector_t offset);\nint find_first_swap(dev_t *device);\nextern unsigned int count_swap_pages(int, int);\nextern sector_t swapdev_block(int, pgoff_t);\nextern int __swap_count(swp_entry_t entry);\nextern int swap_swapcount(struct swap_info_struct *si, swp_entry_t entry);\nextern int swp_swapcount(swp_entry_t entry);\nextern struct swap_info_struct *page_swap_info(struct page *);\nextern struct swap_info_struct *swp_swap_info(swp_entry_t entry);\nstruct backing_dev_info;\nextern int init_swap_address_space(unsigned int type, unsigned long nr_pages);\nextern void exit_swap_address_space(unsigned int type);\nextern struct swap_info_struct *get_swap_device(swp_entry_t entry);\nsector_t swap_page_sector(struct page *page);\n\nstatic inline void put_swap_device(struct swap_info_struct *si)\n{\n\tpercpu_ref_put(&si->users);\n}\n\n#else  \nstatic inline struct swap_info_struct *swp_swap_info(swp_entry_t entry)\n{\n\treturn NULL;\n}\n\nstatic inline struct swap_info_struct *get_swap_device(swp_entry_t entry)\n{\n\treturn NULL;\n}\n\nstatic inline void put_swap_device(struct swap_info_struct *si)\n{\n}\n\n#define get_nr_swap_pages()\t\t\t0L\n#define total_swap_pages\t\t\t0L\n#define total_swapcache_pages()\t\t\t0UL\n#define vm_swap_full()\t\t\t\t0\n\n#define si_swapinfo(val) \\\n\tdo { (val)->freeswap = (val)->totalswap = 0; } while (0)\n \n#define free_page_and_swap_cache(page) \\\n\tput_page(page)\n#define free_pages_and_swap_cache(pages, nr) \\\n\trelease_pages((pages), (nr));\n\n \n#define free_swap_and_cache(e) is_pfn_swap_entry(e)\n\nstatic inline void free_swap_cache(struct page *page)\n{\n}\n\nstatic inline int add_swap_count_continuation(swp_entry_t swp, gfp_t gfp_mask)\n{\n\treturn 0;\n}\n\nstatic inline void swap_shmem_alloc(swp_entry_t swp)\n{\n}\n\nstatic inline int swap_duplicate(swp_entry_t swp)\n{\n\treturn 0;\n}\n\nstatic inline void swap_free(swp_entry_t swp)\n{\n}\n\nstatic inline void put_swap_folio(struct folio *folio, swp_entry_t swp)\n{\n}\n\nstatic inline int __swap_count(swp_entry_t entry)\n{\n\treturn 0;\n}\n\nstatic inline int swap_swapcount(struct swap_info_struct *si, swp_entry_t entry)\n{\n\treturn 0;\n}\n\nstatic inline int swp_swapcount(swp_entry_t entry)\n{\n\treturn 0;\n}\n\nstatic inline swp_entry_t folio_alloc_swap(struct folio *folio)\n{\n\tswp_entry_t entry;\n\tentry.val = 0;\n\treturn entry;\n}\n\nstatic inline bool folio_free_swap(struct folio *folio)\n{\n\treturn false;\n}\n\nstatic inline int add_swap_extent(struct swap_info_struct *sis,\n\t\t\t\t  unsigned long start_page,\n\t\t\t\t  unsigned long nr_pages, sector_t start_block)\n{\n\treturn -EINVAL;\n}\n#endif  \n\n#ifdef CONFIG_THP_SWAP\nextern int split_swap_cluster(swp_entry_t entry);\n#else\nstatic inline int split_swap_cluster(swp_entry_t entry)\n{\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_MEMCG\nstatic inline int mem_cgroup_swappiness(struct mem_cgroup *memcg)\n{\n\t \n\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn READ_ONCE(vm_swappiness);\n\n\t \n\tif (mem_cgroup_disabled() || mem_cgroup_is_root(memcg))\n\t\treturn READ_ONCE(vm_swappiness);\n\n\treturn READ_ONCE(memcg->swappiness);\n}\n#else\nstatic inline int mem_cgroup_swappiness(struct mem_cgroup *mem)\n{\n\treturn READ_ONCE(vm_swappiness);\n}\n#endif\n\n#if defined(CONFIG_SWAP) && defined(CONFIG_MEMCG) && defined(CONFIG_BLK_CGROUP)\nvoid __folio_throttle_swaprate(struct folio *folio, gfp_t gfp);\nstatic inline void folio_throttle_swaprate(struct folio *folio, gfp_t gfp)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t__folio_throttle_swaprate(folio, gfp);\n}\n#else\nstatic inline void folio_throttle_swaprate(struct folio *folio, gfp_t gfp)\n{\n}\n#endif\n\n#if defined(CONFIG_MEMCG) && defined(CONFIG_SWAP)\nvoid mem_cgroup_swapout(struct folio *folio, swp_entry_t entry);\nint __mem_cgroup_try_charge_swap(struct folio *folio, swp_entry_t entry);\nstatic inline int mem_cgroup_try_charge_swap(struct folio *folio,\n\t\tswp_entry_t entry)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn 0;\n\treturn __mem_cgroup_try_charge_swap(folio, entry);\n}\n\nextern void __mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages);\nstatic inline void mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t__mem_cgroup_uncharge_swap(entry, nr_pages);\n}\n\nextern long mem_cgroup_get_nr_swap_pages(struct mem_cgroup *memcg);\nextern bool mem_cgroup_swap_full(struct folio *folio);\n#else\nstatic inline void mem_cgroup_swapout(struct folio *folio, swp_entry_t entry)\n{\n}\n\nstatic inline int mem_cgroup_try_charge_swap(struct folio *folio,\n\t\t\t\t\t     swp_entry_t entry)\n{\n\treturn 0;\n}\n\nstatic inline void mem_cgroup_uncharge_swap(swp_entry_t entry,\n\t\t\t\t\t    unsigned int nr_pages)\n{\n}\n\nstatic inline long mem_cgroup_get_nr_swap_pages(struct mem_cgroup *memcg)\n{\n\treturn get_nr_swap_pages();\n}\n\nstatic inline bool mem_cgroup_swap_full(struct folio *folio)\n{\n\treturn vm_swap_full();\n}\n#endif\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}