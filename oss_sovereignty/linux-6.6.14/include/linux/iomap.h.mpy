{
  "module_name": "iomap.h",
  "hash_id": "d1e08a6381c1369e5aaa24f9ad1d3ec768e21da17ff84d7b404bbe345630845b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/iomap.h",
  "human_readable_source": " \n#ifndef LINUX_IOMAP_H\n#define LINUX_IOMAP_H 1\n\n#include <linux/atomic.h>\n#include <linux/bitmap.h>\n#include <linux/blk_types.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/mm_types.h>\n#include <linux/blkdev.h>\n\nstruct address_space;\nstruct fiemap_extent_info;\nstruct inode;\nstruct iomap_iter;\nstruct iomap_dio;\nstruct iomap_writepage_ctx;\nstruct iov_iter;\nstruct kiocb;\nstruct page;\nstruct vm_area_struct;\nstruct vm_fault;\n\n \n#define IOMAP_HOLE\t0\t \n#define IOMAP_DELALLOC\t1\t \n#define IOMAP_MAPPED\t2\t \n#define IOMAP_UNWRITTEN\t3\t \n#define IOMAP_INLINE\t4\t \n\n \n#define IOMAP_F_NEW\t\t(1U << 0)\n#define IOMAP_F_DIRTY\t\t(1U << 1)\n#define IOMAP_F_SHARED\t\t(1U << 2)\n#define IOMAP_F_MERGED\t\t(1U << 3)\n#ifdef CONFIG_BUFFER_HEAD\n#define IOMAP_F_BUFFER_HEAD\t(1U << 4)\n#else\n#define IOMAP_F_BUFFER_HEAD\t0\n#endif  \n#define IOMAP_F_XATTR\t\t(1U << 5)\n\n \n#define IOMAP_F_SIZE_CHANGED\t(1U << 8)\n#define IOMAP_F_STALE\t\t(1U << 9)\n\n \n#define IOMAP_F_PRIVATE\t\t(1U << 12)\n\n\n \n#define IOMAP_NULL_ADDR -1ULL\t \n\nstruct iomap_folio_ops;\n\nstruct iomap {\n\tu64\t\t\taddr;  \n\tloff_t\t\t\toffset;\t \n\tu64\t\t\tlength;\t \n\tu16\t\t\ttype;\t \n\tu16\t\t\tflags;\t \n\tstruct block_device\t*bdev;\t \n\tstruct dax_device\t*dax_dev;  \n\tvoid\t\t\t*inline_data;\n\tvoid\t\t\t*private;  \n\tconst struct iomap_folio_ops *folio_ops;\n\tu64\t\t\tvalidity_cookie;  \n};\n\nstatic inline sector_t iomap_sector(const struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}\n\n \nstatic inline void *iomap_inline_data(const struct iomap *iomap, loff_t pos)\n{\n\treturn iomap->inline_data + pos - iomap->offset;\n}\n\n \nstatic inline bool iomap_inline_data_valid(const struct iomap *iomap)\n{\n\treturn iomap->length <= PAGE_SIZE - offset_in_page(iomap->inline_data);\n}\n\n \nstruct iomap_folio_ops {\n\tstruct folio *(*get_folio)(struct iomap_iter *iter, loff_t pos,\n\t\t\tunsigned len);\n\tvoid (*put_folio)(struct inode *inode, loff_t pos, unsigned copied,\n\t\t\tstruct folio *folio);\n\n\t \n\tbool (*iomap_valid)(struct inode *inode, const struct iomap *iomap);\n};\n\n \n#define IOMAP_WRITE\t\t(1 << 0)  \n#define IOMAP_ZERO\t\t(1 << 1)  \n#define IOMAP_REPORT\t\t(1 << 2)  \n#define IOMAP_FAULT\t\t(1 << 3)  \n#define IOMAP_DIRECT\t\t(1 << 4)  \n#define IOMAP_NOWAIT\t\t(1 << 5)  \n#define IOMAP_OVERWRITE_ONLY\t(1 << 6)  \n#define IOMAP_UNSHARE\t\t(1 << 7)  \n#ifdef CONFIG_FS_DAX\n#define IOMAP_DAX\t\t(1 << 8)  \n#else\n#define IOMAP_DAX\t\t0\n#endif  \n\nstruct iomap_ops {\n\t \n\tint (*iomap_begin)(struct inode *inode, loff_t pos, loff_t length,\n\t\t\tunsigned flags, struct iomap *iomap,\n\t\t\tstruct iomap *srcmap);\n\n\t \n\tint (*iomap_end)(struct inode *inode, loff_t pos, loff_t length,\n\t\t\tssize_t written, unsigned flags, struct iomap *iomap);\n};\n\n \nstruct iomap_iter {\n\tstruct inode *inode;\n\tloff_t pos;\n\tu64 len;\n\ts64 processed;\n\tunsigned flags;\n\tstruct iomap iomap;\n\tstruct iomap srcmap;\n\tvoid *private;\n};\n\nint iomap_iter(struct iomap_iter *iter, const struct iomap_ops *ops);\n\n \nstatic inline u64 iomap_length(const struct iomap_iter *iter)\n{\n\tu64 end = iter->iomap.offset + iter->iomap.length;\n\n\tif (iter->srcmap.type != IOMAP_HOLE)\n\t\tend = min(end, iter->srcmap.offset + iter->srcmap.length);\n\treturn min(iter->len, end - iter->pos);\n}\n\n \nstatic inline const struct iomap *iomap_iter_srcmap(const struct iomap_iter *i)\n{\n\tif (i->srcmap.type != IOMAP_HOLE)\n\t\treturn &i->srcmap;\n\treturn &i->iomap;\n}\n\nssize_t iomap_file_buffered_write(struct kiocb *iocb, struct iov_iter *from,\n\t\tconst struct iomap_ops *ops);\nint iomap_file_buffered_write_punch_delalloc(struct inode *inode,\n\t\tstruct iomap *iomap, loff_t pos, loff_t length, ssize_t written,\n\t\tint (*punch)(struct inode *inode, loff_t pos, loff_t length));\n\nint iomap_read_folio(struct folio *folio, const struct iomap_ops *ops);\nvoid iomap_readahead(struct readahead_control *, const struct iomap_ops *ops);\nbool iomap_is_partially_uptodate(struct folio *, size_t from, size_t count);\nstruct folio *iomap_get_folio(struct iomap_iter *iter, loff_t pos, size_t len);\nbool iomap_release_folio(struct folio *folio, gfp_t gfp_flags);\nvoid iomap_invalidate_folio(struct folio *folio, size_t offset, size_t len);\nbool iomap_dirty_folio(struct address_space *mapping, struct folio *folio);\nint iomap_file_unshare(struct inode *inode, loff_t pos, loff_t len,\n\t\tconst struct iomap_ops *ops);\nint iomap_zero_range(struct inode *inode, loff_t pos, loff_t len,\n\t\tbool *did_zero, const struct iomap_ops *ops);\nint iomap_truncate_page(struct inode *inode, loff_t pos, bool *did_zero,\n\t\tconst struct iomap_ops *ops);\nvm_fault_t iomap_page_mkwrite(struct vm_fault *vmf,\n\t\t\tconst struct iomap_ops *ops);\nint iomap_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\tu64 start, u64 len, const struct iomap_ops *ops);\nloff_t iomap_seek_hole(struct inode *inode, loff_t offset,\n\t\tconst struct iomap_ops *ops);\nloff_t iomap_seek_data(struct inode *inode, loff_t offset,\n\t\tconst struct iomap_ops *ops);\nsector_t iomap_bmap(struct address_space *mapping, sector_t bno,\n\t\tconst struct iomap_ops *ops);\n\n \nstruct iomap_ioend {\n\tstruct list_head\tio_list;\t \n\tu16\t\t\tio_type;\n\tu16\t\t\tio_flags;\t \n\tu32\t\t\tio_folios;\t \n\tstruct inode\t\t*io_inode;\t \n\tsize_t\t\t\tio_size;\t \n\tloff_t\t\t\tio_offset;\t \n\tsector_t\t\tio_sector;\t \n\tstruct bio\t\t*io_bio;\t \n\tstruct bio\t\tio_inline_bio;\t \n};\n\nstruct iomap_writeback_ops {\n\t \n\tint (*map_blocks)(struct iomap_writepage_ctx *wpc, struct inode *inode,\n\t\t\t\tloff_t offset);\n\n\t \n\tint (*prepare_ioend)(struct iomap_ioend *ioend, int status);\n\n\t \n\tvoid (*discard_folio)(struct folio *folio, loff_t pos);\n};\n\nstruct iomap_writepage_ctx {\n\tstruct iomap\t\tiomap;\n\tstruct iomap_ioend\t*ioend;\n\tconst struct iomap_writeback_ops *ops;\n};\n\nvoid iomap_finish_ioends(struct iomap_ioend *ioend, int error);\nvoid iomap_ioend_try_merge(struct iomap_ioend *ioend,\n\t\tstruct list_head *more_ioends);\nvoid iomap_sort_ioends(struct list_head *ioend_list);\nint iomap_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, struct iomap_writepage_ctx *wpc,\n\t\tconst struct iomap_writeback_ops *ops);\n\n \n#define IOMAP_DIO_UNWRITTEN\t(1 << 0)\t \n#define IOMAP_DIO_COW\t\t(1 << 1)\t \n\nstruct iomap_dio_ops {\n\tint (*end_io)(struct kiocb *iocb, ssize_t size, int error,\n\t\t      unsigned flags);\n\tvoid (*submit_io)(const struct iomap_iter *iter, struct bio *bio,\n\t\t          loff_t file_offset);\n\n\t \n\tstruct bio_set *bio_set;\n};\n\n \n#define IOMAP_DIO_FORCE_WAIT\t(1 << 0)\n\n \n#define IOMAP_DIO_OVERWRITE_ONLY\t(1 << 1)\n\n \n#define IOMAP_DIO_PARTIAL\t\t(1 << 2)\n\nssize_t iomap_dio_rw(struct kiocb *iocb, struct iov_iter *iter,\n\t\tconst struct iomap_ops *ops, const struct iomap_dio_ops *dops,\n\t\tunsigned int dio_flags, void *private, size_t done_before);\nstruct iomap_dio *__iomap_dio_rw(struct kiocb *iocb, struct iov_iter *iter,\n\t\tconst struct iomap_ops *ops, const struct iomap_dio_ops *dops,\n\t\tunsigned int dio_flags, void *private, size_t done_before);\nssize_t iomap_dio_complete(struct iomap_dio *dio);\nvoid iomap_dio_bio_end_io(struct bio *bio);\n\n#ifdef CONFIG_SWAP\nstruct file;\nstruct swap_info_struct;\n\nint iomap_swapfile_activate(struct swap_info_struct *sis,\n\t\tstruct file *swap_file, sector_t *pagespan,\n\t\tconst struct iomap_ops *ops);\n#else\n# define iomap_swapfile_activate(sis, swapfile, pagespan, ops)\t(-EIO)\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}