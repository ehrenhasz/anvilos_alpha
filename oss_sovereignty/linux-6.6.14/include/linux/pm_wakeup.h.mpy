{
  "module_name": "pm_wakeup.h",
  "hash_id": "917692827a116d178a5b5be53cefe184a67e53bd70a237589deb147d2c755555",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/pm_wakeup.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_PM_WAKEUP_H\n#define _LINUX_PM_WAKEUP_H\n\n#ifndef _DEVICE_H_\n# error \"please don't include this file directly\"\n#endif\n\n#include <linux/types.h>\n\nstruct wake_irq;\n\n \nstruct wakeup_source {\n\tconst char \t\t*name;\n\tint\t\t\tid;\n\tstruct list_head\tentry;\n\tspinlock_t\t\tlock;\n\tstruct wake_irq\t\t*wakeirq;\n\tstruct timer_list\ttimer;\n\tunsigned long\t\ttimer_expires;\n\tktime_t total_time;\n\tktime_t max_time;\n\tktime_t last_time;\n\tktime_t start_prevent_time;\n\tktime_t prevent_sleep_time;\n\tunsigned long\t\tevent_count;\n\tunsigned long\t\tactive_count;\n\tunsigned long\t\trelax_count;\n\tunsigned long\t\texpire_count;\n\tunsigned long\t\twakeup_count;\n\tstruct device\t\t*dev;\n\tbool\t\t\tactive:1;\n\tbool\t\t\tautosleep_enabled:1;\n};\n\n#define for_each_wakeup_source(ws) \\\n\tfor ((ws) = wakeup_sources_walk_start();\t\\\n\t     (ws);\t\t\t\t\t\\\n\t     (ws) = wakeup_sources_walk_next((ws)))\n\n#ifdef CONFIG_PM_SLEEP\n\n \n\nstatic inline bool device_can_wakeup(struct device *dev)\n{\n\treturn dev->power.can_wakeup;\n}\n\nstatic inline bool device_may_wakeup(struct device *dev)\n{\n\treturn dev->power.can_wakeup && !!dev->power.wakeup;\n}\n\nstatic inline bool device_wakeup_path(struct device *dev)\n{\n\treturn dev->power.wakeup_path;\n}\n\nstatic inline void device_set_wakeup_path(struct device *dev)\n{\n\tdev->power.wakeup_path = true;\n}\n\n \nextern struct wakeup_source *wakeup_source_create(const char *name);\nextern void wakeup_source_destroy(struct wakeup_source *ws);\nextern void wakeup_source_add(struct wakeup_source *ws);\nextern void wakeup_source_remove(struct wakeup_source *ws);\nextern struct wakeup_source *wakeup_source_register(struct device *dev,\n\t\t\t\t\t\t    const char *name);\nextern void wakeup_source_unregister(struct wakeup_source *ws);\nextern int wakeup_sources_read_lock(void);\nextern void wakeup_sources_read_unlock(int idx);\nextern struct wakeup_source *wakeup_sources_walk_start(void);\nextern struct wakeup_source *wakeup_sources_walk_next(struct wakeup_source *ws);\nextern int device_wakeup_enable(struct device *dev);\nextern int device_wakeup_disable(struct device *dev);\nextern void device_set_wakeup_capable(struct device *dev, bool capable);\nextern int device_set_wakeup_enable(struct device *dev, bool enable);\nextern void __pm_stay_awake(struct wakeup_source *ws);\nextern void pm_stay_awake(struct device *dev);\nextern void __pm_relax(struct wakeup_source *ws);\nextern void pm_relax(struct device *dev);\nextern void pm_wakeup_ws_event(struct wakeup_source *ws, unsigned int msec, bool hard);\nextern void pm_wakeup_dev_event(struct device *dev, unsigned int msec, bool hard);\n\n#else  \n\nstatic inline void device_set_wakeup_capable(struct device *dev, bool capable)\n{\n\tdev->power.can_wakeup = capable;\n}\n\nstatic inline bool device_can_wakeup(struct device *dev)\n{\n\treturn dev->power.can_wakeup;\n}\n\nstatic inline struct wakeup_source *wakeup_source_create(const char *name)\n{\n\treturn NULL;\n}\n\nstatic inline void wakeup_source_destroy(struct wakeup_source *ws) {}\n\nstatic inline void wakeup_source_add(struct wakeup_source *ws) {}\n\nstatic inline void wakeup_source_remove(struct wakeup_source *ws) {}\n\nstatic inline struct wakeup_source *wakeup_source_register(struct device *dev,\n\t\t\t\t\t\t\t   const char *name)\n{\n\treturn NULL;\n}\n\nstatic inline void wakeup_source_unregister(struct wakeup_source *ws) {}\n\nstatic inline int device_wakeup_enable(struct device *dev)\n{\n\tdev->power.should_wakeup = true;\n\treturn 0;\n}\n\nstatic inline int device_wakeup_disable(struct device *dev)\n{\n\tdev->power.should_wakeup = false;\n\treturn 0;\n}\n\nstatic inline int device_set_wakeup_enable(struct device *dev, bool enable)\n{\n\tdev->power.should_wakeup = enable;\n\treturn 0;\n}\n\nstatic inline bool device_may_wakeup(struct device *dev)\n{\n\treturn dev->power.can_wakeup && dev->power.should_wakeup;\n}\n\nstatic inline bool device_wakeup_path(struct device *dev)\n{\n\treturn false;\n}\n\nstatic inline void device_set_wakeup_path(struct device *dev) {}\n\nstatic inline void __pm_stay_awake(struct wakeup_source *ws) {}\n\nstatic inline void pm_stay_awake(struct device *dev) {}\n\nstatic inline void __pm_relax(struct wakeup_source *ws) {}\n\nstatic inline void pm_relax(struct device *dev) {}\n\nstatic inline void pm_wakeup_ws_event(struct wakeup_source *ws,\n\t\t\t\t      unsigned int msec, bool hard) {}\n\nstatic inline void pm_wakeup_dev_event(struct device *dev, unsigned int msec,\n\t\t\t\t       bool hard) {}\n\n#endif  \n\nstatic inline bool device_awake_path(struct device *dev)\n{\n\treturn device_wakeup_path(dev);\n}\n\nstatic inline void device_set_awake_path(struct device *dev)\n{\n\tdevice_set_wakeup_path(dev);\n}\n\nstatic inline void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)\n{\n\treturn pm_wakeup_ws_event(ws, msec, false);\n}\n\nstatic inline void pm_wakeup_event(struct device *dev, unsigned int msec)\n{\n\treturn pm_wakeup_dev_event(dev, msec, false);\n}\n\nstatic inline void pm_wakeup_hard_event(struct device *dev)\n{\n\treturn pm_wakeup_dev_event(dev, 0, true);\n}\n\n \nstatic inline int device_init_wakeup(struct device *dev, bool enable)\n{\n\tif (enable) {\n\t\tdevice_set_wakeup_capable(dev, true);\n\t\treturn device_wakeup_enable(dev);\n\t} else {\n\t\tdevice_wakeup_disable(dev);\n\t\tdevice_set_wakeup_capable(dev, false);\n\t\treturn 0;\n\t}\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}