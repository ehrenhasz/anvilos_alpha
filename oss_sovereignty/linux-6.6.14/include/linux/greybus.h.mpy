{
  "module_name": "greybus.h",
  "hash_id": "25aa94c3abad747c49a18e9aa8fdc48992bdfe1b10cda273f7ada128efd6fd67",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/greybus.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_GREYBUS_H\n#define __LINUX_GREYBUS_H\n\n#ifdef __KERNEL__\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/idr.h>\n\n#include <linux/greybus/greybus_id.h>\n#include <linux/greybus/greybus_manifest.h>\n#include <linux/greybus/greybus_protocols.h>\n#include <linux/greybus/manifest.h>\n#include <linux/greybus/hd.h>\n#include <linux/greybus/svc.h>\n#include <linux/greybus/control.h>\n#include <linux/greybus/module.h>\n#include <linux/greybus/interface.h>\n#include <linux/greybus/bundle.h>\n#include <linux/greybus/connection.h>\n#include <linux/greybus/operation.h>\n\n \n#define GREYBUS_VERSION_MAJOR\t0x00\n#define GREYBUS_VERSION_MINOR\t0x01\n\n#define GREYBUS_ID_MATCH_DEVICE \\\n\t(GREYBUS_ID_MATCH_VENDOR | GREYBUS_ID_MATCH_PRODUCT)\n\n#define GREYBUS_DEVICE(v, p)\t\t\t\t\t\\\n\t.match_flags\t= GREYBUS_ID_MATCH_DEVICE,\t\t\\\n\t.vendor\t\t= (v),\t\t\t\t\t\\\n\t.product\t= (p),\n\n#define GREYBUS_DEVICE_CLASS(c)\t\t\t\t\t\\\n\t.match_flags\t= GREYBUS_ID_MATCH_CLASS,\t\t\\\n\t.class\t\t= (c),\n\n \n#define CPORT_ID_MAX\t4095\t\t \n#define CPORT_ID_BAD\tU16_MAX\n\nstruct greybus_driver {\n\tconst char *name;\n\n\tint (*probe)(struct gb_bundle *bundle,\n\t\t     const struct greybus_bundle_id *id);\n\tvoid (*disconnect)(struct gb_bundle *bundle);\n\n\tconst struct greybus_bundle_id *id_table;\n\n\tstruct device_driver driver;\n};\n#define to_greybus_driver(d) container_of(d, struct greybus_driver, driver)\n\nstatic inline void greybus_set_drvdata(struct gb_bundle *bundle, void *data)\n{\n\tdev_set_drvdata(&bundle->dev, data);\n}\n\nstatic inline void *greybus_get_drvdata(struct gb_bundle *bundle)\n{\n\treturn dev_get_drvdata(&bundle->dev);\n}\n\n \nint greybus_register_driver(struct greybus_driver *driver,\n\t\t\t    struct module *module, const char *mod_name);\nvoid greybus_deregister_driver(struct greybus_driver *driver);\n\n \n#define greybus_register(driver) \\\n\tgreybus_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)\n#define greybus_deregister(driver) \\\n\tgreybus_deregister_driver(driver)\n\n \n#define module_greybus_driver(__greybus_driver)\t\\\n\tmodule_driver(__greybus_driver, greybus_register, greybus_deregister)\n\nint greybus_disabled(void);\n\nvoid gb_debugfs_init(void);\nvoid gb_debugfs_cleanup(void);\nstruct dentry *gb_debugfs_get(void);\n\nextern struct bus_type greybus_bus_type;\n\nextern struct device_type greybus_hd_type;\nextern struct device_type greybus_module_type;\nextern struct device_type greybus_interface_type;\nextern struct device_type greybus_control_type;\nextern struct device_type greybus_bundle_type;\nextern struct device_type greybus_svc_type;\n\nstatic inline int is_gb_host_device(const struct device *dev)\n{\n\treturn dev->type == &greybus_hd_type;\n}\n\nstatic inline int is_gb_module(const struct device *dev)\n{\n\treturn dev->type == &greybus_module_type;\n}\n\nstatic inline int is_gb_interface(const struct device *dev)\n{\n\treturn dev->type == &greybus_interface_type;\n}\n\nstatic inline int is_gb_control(const struct device *dev)\n{\n\treturn dev->type == &greybus_control_type;\n}\n\nstatic inline int is_gb_bundle(const struct device *dev)\n{\n\treturn dev->type == &greybus_bundle_type;\n}\n\nstatic inline int is_gb_svc(const struct device *dev)\n{\n\treturn dev->type == &greybus_svc_type;\n}\n\nstatic inline bool cport_id_valid(struct gb_host_device *hd, u16 cport_id)\n{\n\treturn cport_id != CPORT_ID_BAD && cport_id < hd->num_cports;\n}\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}