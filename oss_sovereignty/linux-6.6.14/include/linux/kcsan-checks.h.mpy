{
  "module_name": "kcsan-checks.h",
  "hash_id": "32df0be679618904d16e3a2bc4acec6a97ab71b496160b08cd48899f7476f327",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/kcsan-checks.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_KCSAN_CHECKS_H\n#define _LINUX_KCSAN_CHECKS_H\n\n \n#include <linux/compiler_attributes.h>\n#include <linux/types.h>\n\n \n#define KCSAN_ACCESS_WRITE\t(1 << 0)  \n#define KCSAN_ACCESS_COMPOUND\t(1 << 1)  \n#define KCSAN_ACCESS_ATOMIC\t(1 << 2)  \n \n#define KCSAN_ACCESS_ASSERT\t(1 << 3)  \n#define KCSAN_ACCESS_SCOPED\t(1 << 4)  \n\n \n#ifdef CONFIG_KCSAN\n \nvoid __kcsan_check_access(const volatile void *ptr, size_t size, int type);\n\n \n#define __KCSAN_BARRIER_TO_SIGNAL_FENCE_mb\t__ATOMIC_SEQ_CST\n#define __KCSAN_BARRIER_TO_SIGNAL_FENCE_wmb\t__ATOMIC_ACQ_REL\n#define __KCSAN_BARRIER_TO_SIGNAL_FENCE_rmb\t__ATOMIC_ACQUIRE\n#define __KCSAN_BARRIER_TO_SIGNAL_FENCE_release\t__ATOMIC_RELEASE\n\n \nvoid __kcsan_mb(void);\n\n \nvoid __kcsan_wmb(void);\n\n \nvoid __kcsan_rmb(void);\n\n \nvoid __kcsan_release(void);\n\n \nvoid kcsan_disable_current(void);\n\n \nvoid kcsan_enable_current(void);\nvoid kcsan_enable_current_nowarn(void);  \n\n \nvoid kcsan_nestable_atomic_begin(void);\n\n \nvoid kcsan_nestable_atomic_end(void);\n\n \nvoid kcsan_flat_atomic_begin(void);\n\n \nvoid kcsan_flat_atomic_end(void);\n\n \nvoid kcsan_atomic_next(int n);\n\n \nvoid kcsan_set_access_mask(unsigned long mask);\n\n \nstruct kcsan_scoped_access {\n\tunion {\n\t\tstruct list_head list;  \n\t\t \n\t\tint stack_depth;\n\t};\n\n\t \n\tconst volatile void *ptr;\n\tsize_t size;\n\tint type;\n\t \n\tunsigned long ip;\n};\n \n#define __kcsan_cleanup_scoped                                                 \\\n\t__maybe_unused __attribute__((__cleanup__(kcsan_end_scoped_access)))\n\n \nstruct kcsan_scoped_access *\nkcsan_begin_scoped_access(const volatile void *ptr, size_t size, int type,\n\t\t\t  struct kcsan_scoped_access *sa);\n\n \nvoid kcsan_end_scoped_access(struct kcsan_scoped_access *sa);\n\n\n#else  \n\nstatic inline void __kcsan_check_access(const volatile void *ptr, size_t size,\n\t\t\t\t\tint type) { }\n\nstatic inline void __kcsan_mb(void)\t\t\t{ }\nstatic inline void __kcsan_wmb(void)\t\t\t{ }\nstatic inline void __kcsan_rmb(void)\t\t\t{ }\nstatic inline void __kcsan_release(void)\t\t{ }\nstatic inline void kcsan_disable_current(void)\t\t{ }\nstatic inline void kcsan_enable_current(void)\t\t{ }\nstatic inline void kcsan_enable_current_nowarn(void)\t{ }\nstatic inline void kcsan_nestable_atomic_begin(void)\t{ }\nstatic inline void kcsan_nestable_atomic_end(void)\t{ }\nstatic inline void kcsan_flat_atomic_begin(void)\t{ }\nstatic inline void kcsan_flat_atomic_end(void)\t\t{ }\nstatic inline void kcsan_atomic_next(int n)\t\t{ }\nstatic inline void kcsan_set_access_mask(unsigned long mask) { }\n\nstruct kcsan_scoped_access { };\n#define __kcsan_cleanup_scoped __maybe_unused\nstatic inline struct kcsan_scoped_access *\nkcsan_begin_scoped_access(const volatile void *ptr, size_t size, int type,\n\t\t\t  struct kcsan_scoped_access *sa) { return sa; }\nstatic inline void kcsan_end_scoped_access(struct kcsan_scoped_access *sa) { }\n\n#endif  \n\n#ifdef __SANITIZE_THREAD__\n \n#define kcsan_check_access __kcsan_check_access\n\n \n#define __kcsan_disable_current kcsan_disable_current\n#define __kcsan_enable_current kcsan_enable_current_nowarn\n#else  \nstatic inline void kcsan_check_access(const volatile void *ptr, size_t size,\n\t\t\t\t      int type) { }\nstatic inline void __kcsan_enable_current(void)  { }\nstatic inline void __kcsan_disable_current(void) { }\n#endif  \n\n#if defined(CONFIG_KCSAN_WEAK_MEMORY) && defined(__SANITIZE_THREAD__)\n \n#define __KCSAN_BARRIER_TO_SIGNAL_FENCE(name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\tbarrier();\t\t\t\t\t\t\t\\\n\t\t__atomic_signal_fence(__KCSAN_BARRIER_TO_SIGNAL_FENCE_##name);\t\\\n\t\tbarrier();\t\t\t\t\t\t\t\\\n\t} while (0)\n#define kcsan_mb()\t__KCSAN_BARRIER_TO_SIGNAL_FENCE(mb)\n#define kcsan_wmb()\t__KCSAN_BARRIER_TO_SIGNAL_FENCE(wmb)\n#define kcsan_rmb()\t__KCSAN_BARRIER_TO_SIGNAL_FENCE(rmb)\n#define kcsan_release()\t__KCSAN_BARRIER_TO_SIGNAL_FENCE(release)\n#elif defined(CONFIG_KCSAN_WEAK_MEMORY) && defined(__KCSAN_INSTRUMENT_BARRIERS__)\n#define kcsan_mb\t__kcsan_mb\n#define kcsan_wmb\t__kcsan_wmb\n#define kcsan_rmb\t__kcsan_rmb\n#define kcsan_release\t__kcsan_release\n#else  \n#define kcsan_mb()\tdo { } while (0)\n#define kcsan_wmb()\tdo { } while (0)\n#define kcsan_rmb()\tdo { } while (0)\n#define kcsan_release()\tdo { } while (0)\n#endif  \n\n \n#define __kcsan_check_read(ptr, size) __kcsan_check_access(ptr, size, 0)\n\n \n#define __kcsan_check_write(ptr, size)                                         \\\n\t__kcsan_check_access(ptr, size, KCSAN_ACCESS_WRITE)\n\n \n#define __kcsan_check_read_write(ptr, size)                                    \\\n\t__kcsan_check_access(ptr, size, KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE)\n\n \n#define kcsan_check_read(ptr, size) kcsan_check_access(ptr, size, 0)\n\n \n#define kcsan_check_write(ptr, size)                                           \\\n\tkcsan_check_access(ptr, size, KCSAN_ACCESS_WRITE)\n\n \n#define kcsan_check_read_write(ptr, size)                                      \\\n\tkcsan_check_access(ptr, size, KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE)\n\n \n#ifdef CONFIG_KCSAN_IGNORE_ATOMICS\n#define kcsan_check_atomic_read(...)\t\tdo { } while (0)\n#define kcsan_check_atomic_write(...)\t\tdo { } while (0)\n#define kcsan_check_atomic_read_write(...)\tdo { } while (0)\n#else\n#define kcsan_check_atomic_read(ptr, size)                                     \\\n\tkcsan_check_access(ptr, size, KCSAN_ACCESS_ATOMIC)\n#define kcsan_check_atomic_write(ptr, size)                                    \\\n\tkcsan_check_access(ptr, size, KCSAN_ACCESS_ATOMIC | KCSAN_ACCESS_WRITE)\n#define kcsan_check_atomic_read_write(ptr, size)                               \\\n\tkcsan_check_access(ptr, size, KCSAN_ACCESS_ATOMIC | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_COMPOUND)\n#endif\n\n \n#define ASSERT_EXCLUSIVE_WRITER(var)                                           \\\n\t__kcsan_check_access(&(var), sizeof(var), KCSAN_ACCESS_ASSERT)\n\n \n#define __kcsan_scoped_name(c, suffix) __kcsan_scoped_##c##suffix\n#define __ASSERT_EXCLUSIVE_SCOPED(var, type, id)                               \\\n\tstruct kcsan_scoped_access __kcsan_scoped_name(id, _)                  \\\n\t\t__kcsan_cleanup_scoped;                                        \\\n\tstruct kcsan_scoped_access *__kcsan_scoped_name(id, _dummy_p)          \\\n\t\t__maybe_unused = kcsan_begin_scoped_access(                    \\\n\t\t\t&(var), sizeof(var), KCSAN_ACCESS_SCOPED | (type),     \\\n\t\t\t&__kcsan_scoped_name(id, _))\n\n \n#define ASSERT_EXCLUSIVE_WRITER_SCOPED(var)                                    \\\n\t__ASSERT_EXCLUSIVE_SCOPED(var, KCSAN_ACCESS_ASSERT, __COUNTER__)\n\n \n#define ASSERT_EXCLUSIVE_ACCESS(var)                                           \\\n\t__kcsan_check_access(&(var), sizeof(var), KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ASSERT)\n\n \n#define ASSERT_EXCLUSIVE_ACCESS_SCOPED(var)                                    \\\n\t__ASSERT_EXCLUSIVE_SCOPED(var, KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ASSERT, __COUNTER__)\n\n \n#define ASSERT_EXCLUSIVE_BITS(var, mask)                                       \\\n\tdo {                                                                   \\\n\t\tkcsan_set_access_mask(mask);                                   \\\n\t\t__kcsan_check_access(&(var), sizeof(var), KCSAN_ACCESS_ASSERT);\\\n\t\tkcsan_set_access_mask(0);                                      \\\n\t\tkcsan_atomic_next(1);                                          \\\n\t} while (0)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}