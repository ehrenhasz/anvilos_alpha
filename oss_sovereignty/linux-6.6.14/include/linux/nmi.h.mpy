{
  "module_name": "nmi.h",
  "hash_id": "a04db11af56f9309d6e716f658e7c47361c490360ab01b956fade83bd0d0932e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/nmi.h",
  "human_readable_source": " \n \n#ifndef LINUX_NMI_H\n#define LINUX_NMI_H\n\n#include <linux/sched.h>\n#include <asm/irq.h>\n\n \n#if defined(CONFIG_HARDLOCKUP_DETECTOR_ARCH) || defined(CONFIG_HARDLOCKUP_DETECTOR_SPARC64)\n#include <asm/nmi.h>\n#endif\n\n#ifdef CONFIG_LOCKUP_DETECTOR\nvoid lockup_detector_init(void);\nvoid lockup_detector_retry_init(void);\nvoid lockup_detector_soft_poweroff(void);\nvoid lockup_detector_cleanup(void);\n\nextern int watchdog_user_enabled;\nextern int watchdog_thresh;\nextern unsigned long watchdog_enabled;\n\nextern struct cpumask watchdog_cpumask;\nextern unsigned long *watchdog_cpumask_bits;\n#ifdef CONFIG_SMP\nextern int sysctl_softlockup_all_cpu_backtrace;\nextern int sysctl_hardlockup_all_cpu_backtrace;\n#else\n#define sysctl_softlockup_all_cpu_backtrace 0\n#define sysctl_hardlockup_all_cpu_backtrace 0\n#endif  \n\n#else  \nstatic inline void lockup_detector_init(void) { }\nstatic inline void lockup_detector_retry_init(void) { }\nstatic inline void lockup_detector_soft_poweroff(void) { }\nstatic inline void lockup_detector_cleanup(void) { }\n#endif  \n\n#ifdef CONFIG_SOFTLOCKUP_DETECTOR\nextern void touch_softlockup_watchdog_sched(void);\nextern void touch_softlockup_watchdog(void);\nextern void touch_softlockup_watchdog_sync(void);\nextern void touch_all_softlockup_watchdogs(void);\nextern unsigned int  softlockup_panic;\n\nextern int lockup_detector_online_cpu(unsigned int cpu);\nextern int lockup_detector_offline_cpu(unsigned int cpu);\n#else  \nstatic inline void touch_softlockup_watchdog_sched(void) { }\nstatic inline void touch_softlockup_watchdog(void) { }\nstatic inline void touch_softlockup_watchdog_sync(void) { }\nstatic inline void touch_all_softlockup_watchdogs(void) { }\n\n#define lockup_detector_online_cpu\tNULL\n#define lockup_detector_offline_cpu\tNULL\n#endif  \n\n#ifdef CONFIG_DETECT_HUNG_TASK\nvoid reset_hung_task_detector(void);\n#else\nstatic inline void reset_hung_task_detector(void) { }\n#endif\n\n \n#define WATCHDOG_HARDLOCKUP_ENABLED_BIT  0\n#define WATCHDOG_SOFTOCKUP_ENABLED_BIT   1\n#define WATCHDOG_HARDLOCKUP_ENABLED     (1 << WATCHDOG_HARDLOCKUP_ENABLED_BIT)\n#define WATCHDOG_SOFTOCKUP_ENABLED      (1 << WATCHDOG_SOFTOCKUP_ENABLED_BIT)\n\n#if defined(CONFIG_HARDLOCKUP_DETECTOR)\nextern void hardlockup_detector_disable(void);\nextern unsigned int hardlockup_panic;\n#else\nstatic inline void hardlockup_detector_disable(void) {}\n#endif\n\n \n#if defined(CONFIG_HARDLOCKUP_DETECTOR) || defined(CONFIG_HARDLOCKUP_DETECTOR_SPARC64)\nvoid arch_touch_nmi_watchdog(void);\n#else\nstatic inline void arch_touch_nmi_watchdog(void) { }\n#endif\n\n#if defined(CONFIG_HARDLOCKUP_DETECTOR_COUNTS_HRTIMER)\nvoid watchdog_hardlockup_touch_cpu(unsigned int cpu);\nvoid watchdog_hardlockup_check(unsigned int cpu, struct pt_regs *regs);\n#endif\n\n#if defined(CONFIG_HARDLOCKUP_DETECTOR_PERF)\nextern void hardlockup_detector_perf_stop(void);\nextern void hardlockup_detector_perf_restart(void);\nextern void hardlockup_detector_perf_cleanup(void);\n#else\nstatic inline void hardlockup_detector_perf_stop(void) { }\nstatic inline void hardlockup_detector_perf_restart(void) { }\nstatic inline void hardlockup_detector_perf_cleanup(void) { }\n#endif\n\nvoid watchdog_hardlockup_stop(void);\nvoid watchdog_hardlockup_start(void);\nint watchdog_hardlockup_probe(void);\nvoid watchdog_hardlockup_enable(unsigned int cpu);\nvoid watchdog_hardlockup_disable(unsigned int cpu);\n\nvoid lockup_detector_reconfigure(void);\n\n#ifdef CONFIG_HARDLOCKUP_DETECTOR_BUDDY\nvoid watchdog_buddy_check_hardlockup(int hrtimer_interrupts);\n#else\nstatic inline void watchdog_buddy_check_hardlockup(int hrtimer_interrupts) {}\n#endif\n\n \nstatic inline void touch_nmi_watchdog(void)\n{\n\t \n\tarch_touch_nmi_watchdog();\n\n\ttouch_softlockup_watchdog();\n}\n\n \n#ifdef arch_trigger_cpumask_backtrace\nstatic inline bool trigger_all_cpu_backtrace(void)\n{\n\tarch_trigger_cpumask_backtrace(cpu_online_mask, -1);\n\treturn true;\n}\n\nstatic inline bool trigger_allbutcpu_cpu_backtrace(int exclude_cpu)\n{\n\tarch_trigger_cpumask_backtrace(cpu_online_mask, exclude_cpu);\n\treturn true;\n}\n\nstatic inline bool trigger_cpumask_backtrace(struct cpumask *mask)\n{\n\tarch_trigger_cpumask_backtrace(mask, -1);\n\treturn true;\n}\n\nstatic inline bool trigger_single_cpu_backtrace(int cpu)\n{\n\tarch_trigger_cpumask_backtrace(cpumask_of(cpu), -1);\n\treturn true;\n}\n\n \nvoid nmi_trigger_cpumask_backtrace(const cpumask_t *mask,\n\t\t\t\t   int exclude_cpu,\n\t\t\t\t   void (*raise)(cpumask_t *mask));\nbool nmi_cpu_backtrace(struct pt_regs *regs);\n\n#else\nstatic inline bool trigger_all_cpu_backtrace(void)\n{\n\treturn false;\n}\nstatic inline bool trigger_allbutcpu_cpu_backtrace(int exclude_cpu)\n{\n\treturn false;\n}\nstatic inline bool trigger_cpumask_backtrace(struct cpumask *mask)\n{\n\treturn false;\n}\nstatic inline bool trigger_single_cpu_backtrace(int cpu)\n{\n\treturn false;\n}\n#endif\n\n#ifdef CONFIG_HARDLOCKUP_DETECTOR_PERF\nu64 hw_nmi_get_sample_period(int watchdog_thresh);\nbool arch_perf_nmi_is_available(void);\n#endif\n\n#if defined(CONFIG_HARDLOCKUP_CHECK_TIMESTAMP) && \\\n    defined(CONFIG_HARDLOCKUP_DETECTOR_PERF)\nvoid watchdog_update_hrtimer_threshold(u64 period);\n#else\nstatic inline void watchdog_update_hrtimer_threshold(u64 period) { }\n#endif\n\nstruct ctl_table;\nint proc_watchdog(struct ctl_table *, int, void *, size_t *, loff_t *);\nint proc_nmi_watchdog(struct ctl_table *, int , void *, size_t *, loff_t *);\nint proc_soft_watchdog(struct ctl_table *, int , void *, size_t *, loff_t *);\nint proc_watchdog_thresh(struct ctl_table *, int , void *, size_t *, loff_t *);\nint proc_watchdog_cpumask(struct ctl_table *, int, void *, size_t *, loff_t *);\n\n#ifdef CONFIG_HAVE_ACPI_APEI_NMI\n#include <asm/nmi.h>\n#endif\n\n#ifdef CONFIG_NMI_CHECK_CPU\nvoid nmi_backtrace_stall_snap(const struct cpumask *btp);\nvoid nmi_backtrace_stall_check(const struct cpumask *btp);\n#else\nstatic inline void nmi_backtrace_stall_snap(const struct cpumask *btp) {}\nstatic inline void nmi_backtrace_stall_check(const struct cpumask *btp) {}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}