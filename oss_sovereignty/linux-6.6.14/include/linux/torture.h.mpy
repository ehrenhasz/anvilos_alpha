{
  "module_name": "torture.h",
  "hash_id": "eb8719b9aa2d5a7004834f0580ccdd56986cd1a075ad1928addfcf13a4f79c2e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/torture.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_TORTURE_H\n#define __LINUX_TORTURE_H\n\n#include <linux/types.h>\n#include <linux/cache.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/cpumask.h>\n#include <linux/seqlock.h>\n#include <linux/lockdep.h>\n#include <linux/completion.h>\n#include <linux/debugobjects.h>\n#include <linux/bug.h>\n#include <linux/compiler.h>\n\n \n#define torture_param(type, name, init, msg) \\\n\tstatic type name = init; \\\n\tmodule_param(name, type, 0444); \\\n\tMODULE_PARM_DESC(name, msg);\n\n#define TORTURE_FLAG \"-torture:\"\n#define TOROUT_STRING(s) \\\n\tpr_alert(\"%s\" TORTURE_FLAG \" %s\\n\", torture_type, s)\n#define VERBOSE_TOROUT_STRING(s) \\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (verbose) {\t\t\t\t\t\t\t\t\\\n\t\tverbose_torout_sleep();\t\t\t\t\t\t\\\n\t\tpr_alert(\"%s\" TORTURE_FLAG \" %s\\n\", torture_type, s);\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n} while (0)\n#define TOROUT_ERRSTRING(s) \\\n\tpr_alert(\"%s\" TORTURE_FLAG \"!!! %s\\n\", torture_type, s)\nvoid verbose_torout_sleep(void);\n\n#define torture_init_error(firsterr)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tint ___firsterr = (firsterr);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tWARN_ONCE(!IS_MODULE(CONFIG_RCU_TORTURE_TEST) && ___firsterr < 0, \"Torture-test initialization failed with error code %d\\n\", ___firsterr); \\\n\t___firsterr < 0;\t\t\t\t\t\t\t\t\\\n})\n\n \n#ifdef CONFIG_HOTPLUG_CPU\nint torture_num_online_cpus(void);\n#else  \nstatic inline int torture_num_online_cpus(void) { return 1; }\n#endif  \ntypedef void torture_ofl_func(void);\nbool torture_offline(int cpu, long *n_onl_attempts, long *n_onl_successes,\n\t\t     unsigned long *sum_offl, int *min_onl, int *max_onl);\nbool torture_online(int cpu, long *n_onl_attempts, long *n_onl_successes,\n\t\t    unsigned long *sum_onl, int *min_onl, int *max_onl);\nint torture_onoff_init(long ooholdoff, long oointerval, torture_ofl_func *f);\nvoid torture_onoff_stats(void);\nbool torture_onoff_failures(void);\n\n \nstruct torture_random_state {\n\tunsigned long trs_state;\n\tlong trs_count;\n};\n#define DEFINE_TORTURE_RANDOM(name) struct torture_random_state name = { 0, 0 }\n#define DEFINE_TORTURE_RANDOM_PERCPU(name) \\\n\tDEFINE_PER_CPU(struct torture_random_state, name)\nunsigned long torture_random(struct torture_random_state *trsp);\nstatic inline void torture_random_init(struct torture_random_state *trsp)\n{\n\ttrsp->trs_state = 0;\n\ttrsp->trs_count = 0;\n}\n\n \nint torture_hrtimeout_ns(ktime_t baset_ns, u32 fuzzt_ns, const enum hrtimer_mode mode,\n\t\t\t struct torture_random_state *trsp);\nint torture_hrtimeout_us(u32 baset_us, u32 fuzzt_ns, struct torture_random_state *trsp);\nint torture_hrtimeout_ms(u32 baset_ms, u32 fuzzt_us, struct torture_random_state *trsp);\nint torture_hrtimeout_jiffies(u32 baset_j, struct torture_random_state *trsp);\nint torture_hrtimeout_s(u32 baset_s, u32 fuzzt_ms, struct torture_random_state *trsp);\n\n \nvoid torture_shuffle_task_register(struct task_struct *tp);\nint torture_shuffle_init(long shuffint);\n\n \nvoid torture_shutdown_absorb(const char *title);\nint torture_shutdown_init(int ssecs, void (*cleanup)(void));\n\n \nbool stutter_wait(const char *title);\nint torture_stutter_init(int s, int sgap);\n\n \nbool torture_init_begin(char *ttype, int v);\nvoid torture_init_end(void);\nbool torture_cleanup_begin(void);\nvoid torture_cleanup_end(void);\nbool torture_must_stop(void);\nbool torture_must_stop_irq(void);\nvoid torture_kthread_stopping(char *title);\nint _torture_create_kthread(int (*fn)(void *arg), void *arg, char *s, char *m,\n\t\t\t     char *f, struct task_struct **tp, void (*cbf)(struct task_struct *tp));\nvoid _torture_stop_kthread(char *m, struct task_struct **tp);\n\n#define torture_create_kthread(n, arg, tp) \\\n\t_torture_create_kthread(n, (arg), #n, \"Creating \" #n \" task\", \\\n\t\t\t\t\"Failed to create \" #n, &(tp), NULL)\n#define torture_create_kthread_cb(n, arg, tp, cbf) \\\n\t_torture_create_kthread(n, (arg), #n, \"Creating \" #n \" task\", \\\n\t\t\t\t\"Failed to create \" #n, &(tp), cbf)\n#define torture_stop_kthread(n, tp) \\\n\t_torture_stop_kthread(\"Stopping \" #n \" task\", &(tp))\n\n#ifdef CONFIG_PREEMPTION\n#define torture_preempt_schedule() __preempt_schedule()\n#else\n#define torture_preempt_schedule()\tdo { } while (0)\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}