{
  "module_name": "writeback.h",
  "hash_id": "c4fa6c3fde4920c3a33498a24c47b8dc1e1c0a85117591eb5a07d1446207a734",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/writeback.h",
  "human_readable_source": " \n \n#ifndef WRITEBACK_H\n#define WRITEBACK_H\n\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/fs.h>\n#include <linux/flex_proportions.h>\n#include <linux/backing-dev-defs.h>\n#include <linux/blk_types.h>\n\nstruct bio;\n\nDECLARE_PER_CPU(int, dirty_throttle_leaks);\n\n \n#define DIRTY_SCOPE\t\t8\n\nstruct backing_dev_info;\n\n \nenum writeback_sync_modes {\n\tWB_SYNC_NONE,\t \n\tWB_SYNC_ALL,\t \n};\n\n \nstruct writeback_control {\n\tlong nr_to_write;\t\t \n\tlong pages_skipped;\t\t \n\n\t \n\tloff_t range_start;\n\tloff_t range_end;\n\n\tenum writeback_sync_modes sync_mode;\n\n\tunsigned for_kupdate:1;\t\t \n\tunsigned for_background:1;\t \n\tunsigned tagged_writepages:1;\t \n\tunsigned for_reclaim:1;\t\t \n\tunsigned range_cyclic:1;\t \n\tunsigned for_sync:1;\t\t \n\tunsigned unpinned_fscache_wb:1;\t \n\n\t \n\tunsigned no_cgroup_owner:1;\n\n\t \n\tstruct swap_iocb **swap_plug;\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tstruct bdi_writeback *wb;\t \n\tstruct inode *inode;\t\t \n\n\t \n\tint wb_id;\t\t\t \n\tint wb_lcand_id;\t\t \n\tint wb_tcand_id;\t\t \n\tsize_t wb_bytes;\t\t \n\tsize_t wb_lcand_bytes;\t\t \n\tsize_t wb_tcand_bytes;\t\t \n#endif\n};\n\nstatic inline blk_opf_t wbc_to_write_flags(struct writeback_control *wbc)\n{\n\tblk_opf_t flags = 0;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\tflags |= REQ_SYNC;\n\telse if (wbc->for_kupdate || wbc->for_background)\n\t\tflags |= REQ_BACKGROUND;\n\n\treturn flags;\n}\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n#define wbc_blkcg_css(wbc) \\\n\t((wbc)->wb ? (wbc)->wb->blkcg_css : blkcg_root_css)\n#else\n#define wbc_blkcg_css(wbc)\t\t(blkcg_root_css)\n#endif  \n\n \nstruct wb_domain {\n\tspinlock_t lock;\n\n\t \n\tstruct fprop_global completions;\n\tstruct timer_list period_timer;\t \n\tunsigned long period_time;\n\n\t \n\tunsigned long dirty_limit_tstamp;\n\tunsigned long dirty_limit;\n};\n\n \nstatic inline void wb_domain_size_changed(struct wb_domain *dom)\n{\n\tspin_lock(&dom->lock);\n\tdom->dirty_limit_tstamp = jiffies;\n\tdom->dirty_limit = 0;\n\tspin_unlock(&dom->lock);\n}\n\n \t\nstruct bdi_writeback;\nvoid writeback_inodes_sb(struct super_block *, enum wb_reason reason);\nvoid writeback_inodes_sb_nr(struct super_block *, unsigned long nr,\n\t\t\t\t\t\t\tenum wb_reason reason);\nvoid try_to_writeback_inodes_sb(struct super_block *sb, enum wb_reason reason);\nvoid sync_inodes_sb(struct super_block *);\nvoid wakeup_flusher_threads(enum wb_reason reason);\nvoid wakeup_flusher_threads_bdi(struct backing_dev_info *bdi,\n\t\t\t\tenum wb_reason reason);\nvoid inode_wait_for_writeback(struct inode *inode);\nvoid inode_io_list_del(struct inode *inode);\n\n \nstatic inline void wait_on_inode(struct inode *inode)\n{\n\tmight_sleep();\n\twait_on_bit(&inode->i_state, __I_NEW, TASK_UNINTERRUPTIBLE);\n}\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\n#include <linux/cgroup.h>\n#include <linux/bio.h>\n\nvoid __inode_attach_wb(struct inode *inode, struct folio *folio);\nvoid wbc_attach_and_unlock_inode(struct writeback_control *wbc,\n\t\t\t\t struct inode *inode)\n\t__releases(&inode->i_lock);\nvoid wbc_detach_inode(struct writeback_control *wbc);\nvoid wbc_account_cgroup_owner(struct writeback_control *wbc, struct page *page,\n\t\t\t      size_t bytes);\nint cgroup_writeback_by_id(u64 bdi_id, int memcg_id,\n\t\t\t   enum wb_reason reason, struct wb_completion *done);\nvoid cgroup_writeback_umount(void);\nbool cleanup_offline_cgwb(struct bdi_writeback *wb);\n\n \nstatic inline void inode_attach_wb(struct inode *inode, struct folio *folio)\n{\n\tif (!inode->i_wb)\n\t\t__inode_attach_wb(inode, folio);\n}\n\n \nstatic inline void inode_detach_wb(struct inode *inode)\n{\n\tif (inode->i_wb) {\n\t\tWARN_ON_ONCE(!(inode->i_state & I_CLEAR));\n\t\twb_put(inode->i_wb);\n\t\tinode->i_wb = NULL;\n\t}\n}\n\n \nstatic inline void wbc_attach_fdatawrite_inode(struct writeback_control *wbc,\n\t\t\t\t\t       struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tinode_attach_wb(inode, NULL);\n\twbc_attach_and_unlock_inode(wbc, inode);\n}\n\n \nstatic inline void wbc_init_bio(struct writeback_control *wbc, struct bio *bio)\n{\n\t \n\tif (wbc->wb)\n\t\tbio_associate_blkg_from_css(bio, wbc->wb->blkcg_css);\n}\n\n#else\t \n\nstatic inline void inode_attach_wb(struct inode *inode, struct folio *folio)\n{\n}\n\nstatic inline void inode_detach_wb(struct inode *inode)\n{\n}\n\nstatic inline void wbc_attach_and_unlock_inode(struct writeback_control *wbc,\n\t\t\t\t\t       struct inode *inode)\n\t__releases(&inode->i_lock)\n{\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic inline void wbc_attach_fdatawrite_inode(struct writeback_control *wbc,\n\t\t\t\t\t       struct inode *inode)\n{\n}\n\nstatic inline void wbc_detach_inode(struct writeback_control *wbc)\n{\n}\n\nstatic inline void wbc_init_bio(struct writeback_control *wbc, struct bio *bio)\n{\n}\n\nstatic inline void wbc_account_cgroup_owner(struct writeback_control *wbc,\n\t\t\t\t\t    struct page *page, size_t bytes)\n{\n}\n\nstatic inline void cgroup_writeback_umount(void)\n{\n}\n\n#endif\t \n\n \nvoid laptop_io_completion(struct backing_dev_info *info);\nvoid laptop_sync_completion(void);\nvoid laptop_mode_timer_fn(struct timer_list *t);\nbool node_dirty_ok(struct pglist_data *pgdat);\nint wb_domain_init(struct wb_domain *dom, gfp_t gfp);\n#ifdef CONFIG_CGROUP_WRITEBACK\nvoid wb_domain_exit(struct wb_domain *dom);\n#endif\n\nextern struct wb_domain global_wb_domain;\n\n \nextern unsigned int dirty_writeback_interval;\nextern unsigned int dirty_expire_interval;\nextern unsigned int dirtytime_expire_interval;\nextern int laptop_mode;\n\nint dirtytime_interval_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos);\n\nvoid global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty);\nunsigned long wb_calc_thresh(struct bdi_writeback *wb, unsigned long thresh);\n\nvoid wb_update_bandwidth(struct bdi_writeback *wb);\n\n \n#define BDP_ASYNC 0x0001\n\nvoid balance_dirty_pages_ratelimited(struct address_space *mapping);\nint balance_dirty_pages_ratelimited_flags(struct address_space *mapping,\n\t\tunsigned int flags);\n\nbool wb_over_bg_thresh(struct bdi_writeback *wb);\n\ntypedef int (*writepage_t)(struct folio *folio, struct writeback_control *wbc,\n\t\t\t\tvoid *data);\n\nvoid tag_pages_for_writeback(struct address_space *mapping,\n\t\t\t     pgoff_t start, pgoff_t end);\nint write_cache_pages(struct address_space *mapping,\n\t\t      struct writeback_control *wbc, writepage_t writepage,\n\t\t      void *data);\nint do_writepages(struct address_space *mapping, struct writeback_control *wbc);\nvoid writeback_set_ratelimit(void);\nvoid tag_pages_for_writeback(struct address_space *mapping,\n\t\t\t     pgoff_t start, pgoff_t end);\n\nbool filemap_dirty_folio(struct address_space *mapping, struct folio *folio);\nbool folio_redirty_for_writepage(struct writeback_control *, struct folio *);\nbool redirty_page_for_writepage(struct writeback_control *, struct page *);\n\nvoid sb_mark_inode_writeback(struct inode *inode);\nvoid sb_clear_inode_writeback(struct inode *inode);\n\n#endif\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}