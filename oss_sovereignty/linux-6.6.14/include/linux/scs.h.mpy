{
  "module_name": "scs.h",
  "hash_id": "f020dcc6256d20a5e11b2a61801e840d02493f6b758ab046e19d206fe5ae66ae",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/scs.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_SCS_H\n#define _LINUX_SCS_H\n\n#include <linux/gfp.h>\n#include <linux/poison.h>\n#include <linux/sched.h>\n#include <linux/sizes.h>\n\n#ifdef CONFIG_SHADOW_CALL_STACK\n\n#define SCS_ORDER\t\t0\n#define SCS_SIZE\t\t(PAGE_SIZE << SCS_ORDER)\n#define GFP_SCS\t\t\t(GFP_KERNEL | __GFP_ZERO)\n\n \n#define SCS_END_MAGIC\t\t(0x5f6UL + POISON_POINTER_DELTA)\n\n#define task_scs(tsk)\t\t(task_thread_info(tsk)->scs_base)\n#define task_scs_sp(tsk)\t(task_thread_info(tsk)->scs_sp)\n\nvoid *scs_alloc(int node);\nvoid scs_free(void *s);\nvoid scs_init(void);\nint scs_prepare(struct task_struct *tsk, int node);\nvoid scs_release(struct task_struct *tsk);\n\nstatic inline void scs_task_reset(struct task_struct *tsk)\n{\n\t \n\ttask_scs_sp(tsk) = task_scs(tsk);\n}\n\nstatic inline unsigned long *__scs_magic(void *s)\n{\n\treturn (unsigned long *)(s + SCS_SIZE) - 1;\n}\n\nstatic inline bool task_scs_end_corrupted(struct task_struct *tsk)\n{\n\tunsigned long *magic = __scs_magic(task_scs(tsk));\n\tunsigned long sz = task_scs_sp(tsk) - task_scs(tsk);\n\n\treturn sz >= SCS_SIZE - 1 || READ_ONCE_NOCHECK(*magic) != SCS_END_MAGIC;\n}\n\nDECLARE_STATIC_KEY_FALSE(dynamic_scs_enabled);\n\nstatic inline bool scs_is_dynamic(void)\n{\n\tif (!IS_ENABLED(CONFIG_DYNAMIC_SCS))\n\t\treturn false;\n\treturn static_branch_likely(&dynamic_scs_enabled);\n}\n\nstatic inline bool scs_is_enabled(void)\n{\n\tif (!IS_ENABLED(CONFIG_DYNAMIC_SCS))\n\t\treturn true;\n\treturn scs_is_dynamic();\n}\n\n#else  \n\nstatic inline void *scs_alloc(int node) { return NULL; }\nstatic inline void scs_free(void *s) {}\nstatic inline void scs_init(void) {}\nstatic inline void scs_task_reset(struct task_struct *tsk) {}\nstatic inline int scs_prepare(struct task_struct *tsk, int node) { return 0; }\nstatic inline void scs_release(struct task_struct *tsk) {}\nstatic inline bool task_scs_end_corrupted(struct task_struct *tsk) { return false; }\nstatic inline bool scs_is_enabled(void) { return false; }\nstatic inline bool scs_is_dynamic(void) { return false; }\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}