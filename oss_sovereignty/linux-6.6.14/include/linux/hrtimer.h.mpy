{
  "module_name": "hrtimer.h",
  "hash_id": "521f0e8332b59778c01f01266749dc8cf991a46dff95c5f4480dde376cba03dc",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/hrtimer.h",
  "human_readable_source": "\n \n#ifndef _LINUX_HRTIMER_H\n#define _LINUX_HRTIMER_H\n\n#include <linux/hrtimer_defs.h>\n#include <linux/rbtree.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/seqlock.h>\n#include <linux/timer.h>\n#include <linux/timerqueue.h>\n\nstruct hrtimer_clock_base;\nstruct hrtimer_cpu_base;\n\n \nenum hrtimer_mode {\n\tHRTIMER_MODE_ABS\t= 0x00,\n\tHRTIMER_MODE_REL\t= 0x01,\n\tHRTIMER_MODE_PINNED\t= 0x02,\n\tHRTIMER_MODE_SOFT\t= 0x04,\n\tHRTIMER_MODE_HARD\t= 0x08,\n\n\tHRTIMER_MODE_ABS_PINNED = HRTIMER_MODE_ABS | HRTIMER_MODE_PINNED,\n\tHRTIMER_MODE_REL_PINNED = HRTIMER_MODE_REL | HRTIMER_MODE_PINNED,\n\n\tHRTIMER_MODE_ABS_SOFT\t= HRTIMER_MODE_ABS | HRTIMER_MODE_SOFT,\n\tHRTIMER_MODE_REL_SOFT\t= HRTIMER_MODE_REL | HRTIMER_MODE_SOFT,\n\n\tHRTIMER_MODE_ABS_PINNED_SOFT = HRTIMER_MODE_ABS_PINNED | HRTIMER_MODE_SOFT,\n\tHRTIMER_MODE_REL_PINNED_SOFT = HRTIMER_MODE_REL_PINNED | HRTIMER_MODE_SOFT,\n\n\tHRTIMER_MODE_ABS_HARD\t= HRTIMER_MODE_ABS | HRTIMER_MODE_HARD,\n\tHRTIMER_MODE_REL_HARD\t= HRTIMER_MODE_REL | HRTIMER_MODE_HARD,\n\n\tHRTIMER_MODE_ABS_PINNED_HARD = HRTIMER_MODE_ABS_PINNED | HRTIMER_MODE_HARD,\n\tHRTIMER_MODE_REL_PINNED_HARD = HRTIMER_MODE_REL_PINNED | HRTIMER_MODE_HARD,\n};\n\n \nenum hrtimer_restart {\n\tHRTIMER_NORESTART,\t \n\tHRTIMER_RESTART,\t \n};\n\n \n#define HRTIMER_STATE_INACTIVE\t0x00\n#define HRTIMER_STATE_ENQUEUED\t0x01\n\n \nstruct hrtimer {\n\tstruct timerqueue_node\t\tnode;\n\tktime_t\t\t\t\t_softexpires;\n\tenum hrtimer_restart\t\t(*function)(struct hrtimer *);\n\tstruct hrtimer_clock_base\t*base;\n\tu8\t\t\t\tstate;\n\tu8\t\t\t\tis_rel;\n\tu8\t\t\t\tis_soft;\n\tu8\t\t\t\tis_hard;\n};\n\n \nstruct hrtimer_sleeper {\n\tstruct hrtimer timer;\n\tstruct task_struct *task;\n};\n\n#ifdef CONFIG_64BIT\n# define __hrtimer_clock_base_align\t____cacheline_aligned\n#else\n# define __hrtimer_clock_base_align\n#endif\n\n \nstruct hrtimer_clock_base {\n\tstruct hrtimer_cpu_base\t*cpu_base;\n\tunsigned int\t\tindex;\n\tclockid_t\t\tclockid;\n\tseqcount_raw_spinlock_t\tseq;\n\tstruct hrtimer\t\t*running;\n\tstruct timerqueue_head\tactive;\n\tktime_t\t\t\t(*get_time)(void);\n\tktime_t\t\t\toffset;\n} __hrtimer_clock_base_align;\n\nenum  hrtimer_base_type {\n\tHRTIMER_BASE_MONOTONIC,\n\tHRTIMER_BASE_REALTIME,\n\tHRTIMER_BASE_BOOTTIME,\n\tHRTIMER_BASE_TAI,\n\tHRTIMER_BASE_MONOTONIC_SOFT,\n\tHRTIMER_BASE_REALTIME_SOFT,\n\tHRTIMER_BASE_BOOTTIME_SOFT,\n\tHRTIMER_BASE_TAI_SOFT,\n\tHRTIMER_MAX_CLOCK_BASES,\n};\n\n \nstruct hrtimer_cpu_base {\n\traw_spinlock_t\t\t\tlock;\n\tunsigned int\t\t\tcpu;\n\tunsigned int\t\t\tactive_bases;\n\tunsigned int\t\t\tclock_was_set_seq;\n\tunsigned int\t\t\thres_active\t\t: 1,\n\t\t\t\t\tin_hrtirq\t\t: 1,\n\t\t\t\t\thang_detected\t\t: 1,\n\t\t\t\t\tsoftirq_activated       : 1;\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tunsigned int\t\t\tnr_events;\n\tunsigned short\t\t\tnr_retries;\n\tunsigned short\t\t\tnr_hangs;\n\tunsigned int\t\t\tmax_hang_time;\n#endif\n#ifdef CONFIG_PREEMPT_RT\n\tspinlock_t\t\t\tsoftirq_expiry_lock;\n\tatomic_t\t\t\ttimer_waiters;\n#endif\n\tktime_t\t\t\t\texpires_next;\n\tstruct hrtimer\t\t\t*next_timer;\n\tktime_t\t\t\t\tsoftirq_expires_next;\n\tstruct hrtimer\t\t\t*softirq_next_timer;\n\tstruct hrtimer_clock_base\tclock_base[HRTIMER_MAX_CLOCK_BASES];\n} ____cacheline_aligned;\n\nstatic inline void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)\n{\n\ttimer->node.expires = time;\n\ttimer->_softexpires = time;\n}\n\nstatic inline void hrtimer_set_expires_range(struct hrtimer *timer, ktime_t time, ktime_t delta)\n{\n\ttimer->_softexpires = time;\n\ttimer->node.expires = ktime_add_safe(time, delta);\n}\n\nstatic inline void hrtimer_set_expires_range_ns(struct hrtimer *timer, ktime_t time, u64 delta)\n{\n\ttimer->_softexpires = time;\n\ttimer->node.expires = ktime_add_safe(time, ns_to_ktime(delta));\n}\n\nstatic inline void hrtimer_set_expires_tv64(struct hrtimer *timer, s64 tv64)\n{\n\ttimer->node.expires = tv64;\n\ttimer->_softexpires = tv64;\n}\n\nstatic inline void hrtimer_add_expires(struct hrtimer *timer, ktime_t time)\n{\n\ttimer->node.expires = ktime_add_safe(timer->node.expires, time);\n\ttimer->_softexpires = ktime_add_safe(timer->_softexpires, time);\n}\n\nstatic inline void hrtimer_add_expires_ns(struct hrtimer *timer, u64 ns)\n{\n\ttimer->node.expires = ktime_add_ns(timer->node.expires, ns);\n\ttimer->_softexpires = ktime_add_ns(timer->_softexpires, ns);\n}\n\nstatic inline ktime_t hrtimer_get_expires(const struct hrtimer *timer)\n{\n\treturn timer->node.expires;\n}\n\nstatic inline ktime_t hrtimer_get_softexpires(const struct hrtimer *timer)\n{\n\treturn timer->_softexpires;\n}\n\nstatic inline s64 hrtimer_get_expires_tv64(const struct hrtimer *timer)\n{\n\treturn timer->node.expires;\n}\nstatic inline s64 hrtimer_get_softexpires_tv64(const struct hrtimer *timer)\n{\n\treturn timer->_softexpires;\n}\n\nstatic inline s64 hrtimer_get_expires_ns(const struct hrtimer *timer)\n{\n\treturn ktime_to_ns(timer->node.expires);\n}\n\nstatic inline ktime_t hrtimer_expires_remaining(const struct hrtimer *timer)\n{\n\treturn ktime_sub(timer->node.expires, timer->base->get_time());\n}\n\nstatic inline ktime_t hrtimer_cb_get_time(struct hrtimer *timer)\n{\n\treturn timer->base->get_time();\n}\n\nstatic inline int hrtimer_is_hres_active(struct hrtimer *timer)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\ttimer->base->cpu_base->hres_active : 0;\n}\n\n#ifdef CONFIG_HIGH_RES_TIMERS\nstruct clock_event_device;\n\nextern void hrtimer_interrupt(struct clock_event_device *dev);\n\nextern unsigned int hrtimer_resolution;\n\n#else\n\n#define hrtimer_resolution\t(unsigned int)LOW_RES_NSEC\n\n#endif\n\nstatic inline ktime_t\n__hrtimer_expires_remaining_adjusted(const struct hrtimer *timer, ktime_t now)\n{\n\tktime_t rem = ktime_sub(timer->node.expires, now);\n\n\t \n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES) && timer->is_rel)\n\t\trem -= hrtimer_resolution;\n\treturn rem;\n}\n\nstatic inline ktime_t\nhrtimer_expires_remaining_adjusted(const struct hrtimer *timer)\n{\n\treturn __hrtimer_expires_remaining_adjusted(timer,\n\t\t\t\t\t\t    timer->base->get_time());\n}\n\n#ifdef CONFIG_TIMERFD\nextern void timerfd_clock_was_set(void);\nextern void timerfd_resume(void);\n#else\nstatic inline void timerfd_clock_was_set(void) { }\nstatic inline void timerfd_resume(void) { }\n#endif\n\nDECLARE_PER_CPU(struct tick_device, tick_cpu_device);\n\n#ifdef CONFIG_PREEMPT_RT\nvoid hrtimer_cancel_wait_running(const struct hrtimer *timer);\n#else\nstatic inline void hrtimer_cancel_wait_running(struct hrtimer *timer)\n{\n\tcpu_relax();\n}\n#endif\n\n \n\n \nextern void hrtimer_init(struct hrtimer *timer, clockid_t which_clock,\n\t\t\t enum hrtimer_mode mode);\nextern void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t\t enum hrtimer_mode mode);\n\n#ifdef CONFIG_DEBUG_OBJECTS_TIMERS\nextern void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t which_clock,\n\t\t\t\t  enum hrtimer_mode mode);\nextern void hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,\n\t\t\t\t\t  clockid_t clock_id,\n\t\t\t\t\t  enum hrtimer_mode mode);\n\nextern void destroy_hrtimer_on_stack(struct hrtimer *timer);\n#else\nstatic inline void hrtimer_init_on_stack(struct hrtimer *timer,\n\t\t\t\t\t clockid_t which_clock,\n\t\t\t\t\t enum hrtimer_mode mode)\n{\n\thrtimer_init(timer, which_clock, mode);\n}\n\nstatic inline void hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,\n\t\t\t\t\t\t clockid_t clock_id,\n\t\t\t\t\t\t enum hrtimer_mode mode)\n{\n\thrtimer_init_sleeper(sl, clock_id, mode);\n}\n\nstatic inline void destroy_hrtimer_on_stack(struct hrtimer *timer) { }\n#endif\n\n \nextern void hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t   u64 range_ns, const enum hrtimer_mode mode);\n\n \nstatic inline void hrtimer_start(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t const enum hrtimer_mode mode)\n{\n\thrtimer_start_range_ns(timer, tim, 0, mode);\n}\n\nextern int hrtimer_cancel(struct hrtimer *timer);\nextern int hrtimer_try_to_cancel(struct hrtimer *timer);\n\nstatic inline void hrtimer_start_expires(struct hrtimer *timer,\n\t\t\t\t\t enum hrtimer_mode mode)\n{\n\tu64 delta;\n\tktime_t soft, hard;\n\tsoft = hrtimer_get_softexpires(timer);\n\thard = hrtimer_get_expires(timer);\n\tdelta = ktime_to_ns(ktime_sub(hard, soft));\n\thrtimer_start_range_ns(timer, soft, delta, mode);\n}\n\nvoid hrtimer_sleeper_start_expires(struct hrtimer_sleeper *sl,\n\t\t\t\t   enum hrtimer_mode mode);\n\nstatic inline void hrtimer_restart(struct hrtimer *timer)\n{\n\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}\n\n \nextern ktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust);\n\n \nstatic inline ktime_t hrtimer_get_remaining(const struct hrtimer *timer)\n{\n\treturn __hrtimer_get_remaining(timer, false);\n}\n\nextern u64 hrtimer_get_next_event(void);\nextern u64 hrtimer_next_event_without(const struct hrtimer *exclude);\n\nextern bool hrtimer_active(const struct hrtimer *timer);\n\n \nstatic inline bool hrtimer_is_queued(struct hrtimer *timer)\n{\n\t \n\treturn !!(READ_ONCE(timer->state) & HRTIMER_STATE_ENQUEUED);\n}\n\n \nstatic inline int hrtimer_callback_running(struct hrtimer *timer)\n{\n\treturn timer->base->running == timer;\n}\n\n \nextern u64\nhrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval);\n\n \nstatic inline u64 hrtimer_forward_now(struct hrtimer *timer,\n\t\t\t\t      ktime_t interval)\n{\n\treturn hrtimer_forward(timer, timer->base->get_time(), interval);\n}\n\n \n\nextern int nanosleep_copyout(struct restart_block *, struct timespec64 *);\nextern long hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,\n\t\t\t      const clockid_t clockid);\n\nextern int schedule_hrtimeout_range(ktime_t *expires, u64 delta,\n\t\t\t\t    const enum hrtimer_mode mode);\nextern int schedule_hrtimeout_range_clock(ktime_t *expires,\n\t\t\t\t\t  u64 delta,\n\t\t\t\t\t  const enum hrtimer_mode mode,\n\t\t\t\t\t  clockid_t clock_id);\nextern int schedule_hrtimeout(ktime_t *expires, const enum hrtimer_mode mode);\n\n \nextern void hrtimer_run_queues(void);\n\n \nextern void __init hrtimers_init(void);\n\n \nextern void sysrq_timer_list_show(void);\n\nint hrtimers_prepare_cpu(unsigned int cpu);\n#ifdef CONFIG_HOTPLUG_CPU\nint hrtimers_cpu_dying(unsigned int cpu);\n#else\n#define hrtimers_cpu_dying\tNULL\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}