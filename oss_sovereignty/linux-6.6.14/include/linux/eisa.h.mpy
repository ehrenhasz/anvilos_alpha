{
  "module_name": "eisa.h",
  "hash_id": "c074ffbfe3ddeac3b8c3be9c4264e84ead063a430e863c0a2f382126945bdb63",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/eisa.h",
  "human_readable_source": " \n#ifndef _LINUX_EISA_H\n#define _LINUX_EISA_H\n\n#include <linux/ioport.h>\n#include <linux/device.h>\n#include <linux/mod_devicetable.h>\n\n#define EISA_MAX_SLOTS 8\n\n#define EISA_MAX_RESOURCES 4\n\n \n\n#define EISA_DMA1_STATUS            8\n#define EISA_INT1_CTRL           0x20\n#define EISA_INT1_MASK           0x21\n#define EISA_INT2_CTRL           0xA0\n#define EISA_INT2_MASK           0xA1\n#define EISA_DMA2_STATUS         0xD0\n#define EISA_DMA2_WRITE_SINGLE   0xD4\n#define EISA_EXT_NMI_RESET_CTRL 0x461\n#define EISA_INT1_EDGE_LEVEL    0x4D0\n#define EISA_INT2_EDGE_LEVEL    0x4D1\n#define EISA_VENDOR_ID_OFFSET   0xC80\n#define EISA_CONFIG_OFFSET      0xC84\n\n#define EISA_CONFIG_ENABLED         1\n#define EISA_CONFIG_FORCED          2\n\n \n\nstruct eisa_device {\n\tstruct eisa_device_id id;\n\tint                   slot;\n\tint                   state;\n\tunsigned long         base_addr;\n\tstruct resource       res[EISA_MAX_RESOURCES];\n\tu64                   dma_mask;\n\tstruct device         dev;  \n#ifdef CONFIG_EISA_NAMES\n\tchar\t\t      pretty_name[50];\n#endif\n};\n\n#define to_eisa_device(n) container_of(n, struct eisa_device, dev)\n\nstatic inline int eisa_get_region_index (void *addr)\n{\n\tunsigned long x = (unsigned long) addr;\n\n\tx &= 0xc00;\n\treturn (x >> 12);\n}\n\nstruct eisa_driver {\n\tconst struct eisa_device_id *id_table;\n\tstruct device_driver         driver;\n};\n\n#define to_eisa_driver(drv) container_of(drv,struct eisa_driver, driver)\n\n \n#ifdef CONFIG_EISA\n\nextern struct bus_type eisa_bus_type;\nint eisa_driver_register (struct eisa_driver *edrv);\nvoid eisa_driver_unregister (struct eisa_driver *edrv);\n\n#else  \n\nstatic inline int eisa_driver_register (struct eisa_driver *edrv) { return 0; }\nstatic inline void eisa_driver_unregister (struct eisa_driver *edrv) { }\n\n#endif  \n\n \nstatic inline void *eisa_get_drvdata (struct eisa_device *edev)\n{\n        return dev_get_drvdata(&edev->dev);\n}\n\nstatic inline void eisa_set_drvdata (struct eisa_device *edev, void *data)\n{\n        dev_set_drvdata(&edev->dev, data);\n}\n\n \n\nstruct eisa_root_device {\n\tstruct device   *dev;\t  \n\tstruct resource *res;\n\tunsigned long    bus_base_addr;\n\tint\t\t slots;   \n\tint\t\t force_probe;  \n\tu64\t\t dma_mask;  \n\tint              bus_nr;  \n\tstruct resource  eisa_root_res;\t \n};\n\nint eisa_root_register (struct eisa_root_device *root);\n\n#ifdef CONFIG_EISA\nextern int EISA_bus;\n#else\n# define EISA_bus 0\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}