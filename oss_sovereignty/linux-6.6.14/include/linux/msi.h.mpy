{
  "module_name": "msi.h",
  "hash_id": "a5153940e0605b63502e6ac3ab7598ac5e9cf8f2eb44aedddb1a50b3152e37cf",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/msi.h",
  "human_readable_source": " \n#ifndef LINUX_MSI_H\n#define LINUX_MSI_H\n\n \n\n#include <linux/irqdomain_defs.h>\n#include <linux/cpumask.h>\n#include <linux/msi_api.h>\n#include <linux/xarray.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bits.h>\n\n#include <asm/msi.h>\n\n \n#ifndef arch_msi_msg_addr_lo\ntypedef struct arch_msi_msg_addr_lo {\n\tu32\taddress_lo;\n} __attribute__ ((packed)) arch_msi_msg_addr_lo_t;\n#endif\n\n#ifndef arch_msi_msg_addr_hi\ntypedef struct arch_msi_msg_addr_hi {\n\tu32\taddress_hi;\n} __attribute__ ((packed)) arch_msi_msg_addr_hi_t;\n#endif\n\n#ifndef arch_msi_msg_data\ntypedef struct arch_msi_msg_data {\n\tu32\tdata;\n} __attribute__ ((packed)) arch_msi_msg_data_t;\n#endif\n\n#ifndef arch_is_isolated_msi\n#define arch_is_isolated_msi() false\n#endif\n\n \nstruct msi_msg {\n\tunion {\n\t\tu32\t\t\taddress_lo;\n\t\tarch_msi_msg_addr_lo_t\tarch_addr_lo;\n\t};\n\tunion {\n\t\tu32\t\t\taddress_hi;\n\t\tarch_msi_msg_addr_hi_t\tarch_addr_hi;\n\t};\n\tunion {\n\t\tu32\t\t\tdata;\n\t\tarch_msi_msg_data_t\tarch_data;\n\t};\n};\n\nextern int pci_msi_ignore_mask;\n \nstruct msi_desc;\nstruct pci_dev;\nstruct platform_msi_priv_data;\nstruct device_attribute;\nstruct irq_domain;\nstruct irq_affinity_desc;\n\nvoid __get_cached_msi_msg(struct msi_desc *entry, struct msi_msg *msg);\n#ifdef CONFIG_GENERIC_MSI_IRQ\nvoid get_cached_msi_msg(unsigned int irq, struct msi_msg *msg);\n#else\nstatic inline void get_cached_msi_msg(unsigned int irq, struct msi_msg *msg) { }\n#endif\n\ntypedef void (*irq_write_msi_msg_t)(struct msi_desc *desc,\n\t\t\t\t    struct msi_msg *msg);\n\n \nstruct pci_msi_desc {\n\tunion {\n\t\tu32 msi_mask;\n\t\tu32 msix_ctrl;\n\t};\n\tstruct {\n\t\tu8\tis_msix\t\t: 1;\n\t\tu8\tmultiple\t: 3;\n\t\tu8\tmulti_cap\t: 3;\n\t\tu8\tcan_mask\t: 1;\n\t\tu8\tis_64\t\t: 1;\n\t\tu8\tis_virtual\t: 1;\n\t\tunsigned default_irq;\n\t} msi_attrib;\n\tunion {\n\t\tu8\tmask_pos;\n\t\tvoid __iomem *mask_base;\n\t};\n};\n\n \nunion msi_domain_cookie {\n\tu64\tvalue;\n\tvoid\t*ptr;\n\tvoid\t__iomem *iobase;\n};\n\n \nstruct msi_desc_data {\n\tunion msi_domain_cookie\t\tdcookie;\n\tunion msi_instance_cookie\ticookie;\n};\n\n#define MSI_MAX_INDEX\t\t((unsigned int)USHRT_MAX)\n\n \nstruct msi_desc {\n\t \n\tunsigned int\t\t\tirq;\n\tunsigned int\t\t\tnvec_used;\n\tstruct device\t\t\t*dev;\n\tstruct msi_msg\t\t\tmsg;\n\tstruct irq_affinity_desc\t*affinity;\n#ifdef CONFIG_IRQ_MSI_IOMMU\n\tconst void\t\t\t*iommu_cookie;\n#endif\n#ifdef CONFIG_SYSFS\n\tstruct device_attribute\t\t*sysfs_attrs;\n#endif\n\n\tvoid (*write_msi_msg)(struct msi_desc *entry, void *data);\n\tvoid *write_msi_msg_data;\n\n\tu16\t\t\t\tmsi_index;\n\tunion {\n\t\tstruct pci_msi_desc\tpci;\n\t\tstruct msi_desc_data\tdata;\n\t};\n};\n\n \nenum msi_desc_filter {\n\t \n\tMSI_DESC_ALL,\n\t \n\tMSI_DESC_NOTASSOCIATED,\n\t \n\tMSI_DESC_ASSOCIATED,\n};\n\n\n \nstruct msi_dev_domain {\n\tstruct xarray\t\tstore;\n\tstruct irq_domain\t*domain;\n};\n\n \nstruct msi_device_data {\n\tunsigned long\t\t\tproperties;\n\tstruct platform_msi_priv_data\t*platform_data;\n\tstruct mutex\t\t\tmutex;\n\tstruct msi_dev_domain\t\t__domains[MSI_MAX_DEVICE_IRQDOMAINS];\n\tunsigned long\t\t\t__iter_idx;\n};\n\nint msi_setup_device_data(struct device *dev);\n\nvoid msi_lock_descs(struct device *dev);\nvoid msi_unlock_descs(struct device *dev);\n\nstruct msi_desc *msi_domain_first_desc(struct device *dev, unsigned int domid,\n\t\t\t\t       enum msi_desc_filter filter);\n\n \nstatic inline struct msi_desc *msi_first_desc(struct device *dev,\n\t\t\t\t\t      enum msi_desc_filter filter)\n{\n\treturn msi_domain_first_desc(dev, MSI_DEFAULT_DOMAIN, filter);\n}\n\nstruct msi_desc *msi_next_desc(struct device *dev, unsigned int domid,\n\t\t\t       enum msi_desc_filter filter);\n\n \n#define msi_domain_for_each_desc(desc, dev, domid, filter)\t\t\t\\\n\tfor ((desc) = msi_domain_first_desc((dev), (domid), (filter)); (desc);\t\\\n\t     (desc) = msi_next_desc((dev), (domid), (filter)))\n\n \n#define msi_for_each_desc(desc, dev, filter)\t\t\t\t\t\\\n\tmsi_domain_for_each_desc((desc), (dev), MSI_DEFAULT_DOMAIN, (filter))\n\n#define msi_desc_to_dev(desc)\t\t((desc)->dev)\n\n#ifdef CONFIG_IRQ_MSI_IOMMU\nstatic inline const void *msi_desc_get_iommu_cookie(struct msi_desc *desc)\n{\n\treturn desc->iommu_cookie;\n}\n\nstatic inline void msi_desc_set_iommu_cookie(struct msi_desc *desc,\n\t\t\t\t\t     const void *iommu_cookie)\n{\n\tdesc->iommu_cookie = iommu_cookie;\n}\n#else\nstatic inline const void *msi_desc_get_iommu_cookie(struct msi_desc *desc)\n{\n\treturn NULL;\n}\n\nstatic inline void msi_desc_set_iommu_cookie(struct msi_desc *desc,\n\t\t\t\t\t     const void *iommu_cookie)\n{\n}\n#endif\n\nint msi_domain_insert_msi_desc(struct device *dev, unsigned int domid,\n\t\t\t       struct msi_desc *init_desc);\n \nstatic inline int msi_insert_msi_desc(struct device *dev, struct msi_desc *init_desc)\n{\n\treturn msi_domain_insert_msi_desc(dev, MSI_DEFAULT_DOMAIN, init_desc);\n}\n\nvoid msi_domain_free_msi_descs_range(struct device *dev, unsigned int domid,\n\t\t\t\t     unsigned int first, unsigned int last);\n\n \nstatic inline void msi_free_msi_descs_range(struct device *dev, unsigned int first,\n\t\t\t\t\t    unsigned int last)\n{\n\tmsi_domain_free_msi_descs_range(dev, MSI_DEFAULT_DOMAIN, first, last);\n}\n\n \nstatic inline void msi_free_msi_descs(struct device *dev)\n{\n\tmsi_free_msi_descs_range(dev, 0, MSI_MAX_INDEX);\n}\n\n \n#ifdef CONFIG_PCI_MSI_ARCH_FALLBACKS\nint arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc);\nvoid arch_teardown_msi_irq(unsigned int irq);\nint arch_setup_msi_irqs(struct pci_dev *dev, int nvec, int type);\nvoid arch_teardown_msi_irqs(struct pci_dev *dev);\n#endif  \n\n \n#if defined(CONFIG_PCI_XEN) || defined(CONFIG_PCI_MSI_ARCH_FALLBACKS)\n#ifdef CONFIG_SYSFS\nint msi_device_populate_sysfs(struct device *dev);\nvoid msi_device_destroy_sysfs(struct device *dev);\n#else  \nstatic inline int msi_device_populate_sysfs(struct device *dev) { return 0; }\nstatic inline void msi_device_destroy_sysfs(struct device *dev) { }\n#endif  \n#endif  \n\n \nbool arch_restore_msi_irqs(struct pci_dev *dev);\n\n#ifdef CONFIG_GENERIC_MSI_IRQ\n\n#include <linux/irqhandler.h>\n\nstruct irq_domain;\nstruct irq_domain_ops;\nstruct irq_chip;\nstruct device_node;\nstruct fwnode_handle;\nstruct msi_domain_info;\n\n \nstruct msi_domain_ops {\n\tirq_hw_number_t\t(*get_hwirq)(struct msi_domain_info *info,\n\t\t\t\t     msi_alloc_info_t *arg);\n\tint\t\t(*msi_init)(struct irq_domain *domain,\n\t\t\t\t    struct msi_domain_info *info,\n\t\t\t\t    unsigned int virq, irq_hw_number_t hwirq,\n\t\t\t\t    msi_alloc_info_t *arg);\n\tvoid\t\t(*msi_free)(struct irq_domain *domain,\n\t\t\t\t    struct msi_domain_info *info,\n\t\t\t\t    unsigned int virq);\n\tint\t\t(*msi_prepare)(struct irq_domain *domain,\n\t\t\t\t       struct device *dev, int nvec,\n\t\t\t\t       msi_alloc_info_t *arg);\n\tvoid\t\t(*prepare_desc)(struct irq_domain *domain, msi_alloc_info_t *arg,\n\t\t\t\t\tstruct msi_desc *desc);\n\tvoid\t\t(*set_desc)(msi_alloc_info_t *arg,\n\t\t\t\t    struct msi_desc *desc);\n\tint\t\t(*domain_alloc_irqs)(struct irq_domain *domain,\n\t\t\t\t\t     struct device *dev, int nvec);\n\tvoid\t\t(*domain_free_irqs)(struct irq_domain *domain,\n\t\t\t\t\t    struct device *dev);\n\tvoid\t\t(*msi_post_free)(struct irq_domain *domain,\n\t\t\t\t\t struct device *dev);\n};\n\n \nstruct msi_domain_info {\n\tu32\t\t\t\tflags;\n\tenum irq_domain_bus_token\tbus_token;\n\tunsigned int\t\t\thwsize;\n\tstruct msi_domain_ops\t\t*ops;\n\tstruct irq_chip\t\t\t*chip;\n\tvoid\t\t\t\t*chip_data;\n\tirq_flow_handler_t\t\thandler;\n\tvoid\t\t\t\t*handler_data;\n\tconst char\t\t\t*handler_name;\n\tvoid\t\t\t\t*data;\n};\n\n \nstruct msi_domain_template {\n\tchar\t\t\tname[48];\n\tstruct irq_chip\t\tchip;\n\tstruct msi_domain_ops\tops;\n\tstruct msi_domain_info\tinfo;\n};\n\n \nenum {\n\t \n\tMSI_FLAG_USE_DEF_DOM_OPS\t= (1 << 0),\n\t \n\tMSI_FLAG_USE_DEF_CHIP_OPS\t= (1 << 1),\n\t \n\tMSI_FLAG_ACTIVATE_EARLY\t\t= (1 << 2),\n\t \n\tMSI_FLAG_MUST_REACTIVATE\t= (1 << 3),\n\t \n\tMSI_FLAG_DEV_SYSFS\t\t= (1 << 4),\n\t \n\tMSI_FLAG_ALLOC_SIMPLE_MSI_DESCS\t= (1 << 5),\n\t \n\tMSI_FLAG_FREE_MSI_DESCS\t\t= (1 << 6),\n\n\t \n\tMSI_GENERIC_FLAGS_MASK\t\t= GENMASK(15, 0),\n\n\t \n\tMSI_DOMAIN_FLAGS_MASK\t\t= GENMASK(31, 16),\n\n\t \n\tMSI_FLAG_MULTI_PCI_MSI\t\t= (1 << 16),\n\t \n\tMSI_FLAG_PCI_MSIX\t\t= (1 << 17),\n\t \n\tMSI_FLAG_LEVEL_CAPABLE\t\t= (1 << 18),\n\t \n\tMSI_FLAG_MSIX_CONTIGUOUS\t= (1 << 19),\n\t \n\tMSI_FLAG_PCI_MSIX_ALLOC_DYN\t= (1 << 20),\n\t \n\tMSI_FLAG_PCI_IMS\t\t= (1 << 21),\n};\n\n \nstruct msi_parent_ops {\n\tu32\t\tsupported_flags;\n\tconst char\t*prefix;\n\tbool\t\t(*init_dev_msi_info)(struct device *dev, struct irq_domain *domain,\n\t\t\t\t\t     struct irq_domain *msi_parent_domain,\n\t\t\t\t\t     struct msi_domain_info *msi_child_info);\n};\n\nbool msi_parent_init_dev_msi_info(struct device *dev, struct irq_domain *domain,\n\t\t\t\t  struct irq_domain *msi_parent_domain,\n\t\t\t\t  struct msi_domain_info *msi_child_info);\n\nint msi_domain_set_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t\t    bool force);\n\nstruct irq_domain *msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t struct msi_domain_info *info,\n\t\t\t\t\t struct irq_domain *parent);\n\nbool msi_create_device_irq_domain(struct device *dev, unsigned int domid,\n\t\t\t\t  const struct msi_domain_template *template,\n\t\t\t\t  unsigned int hwsize, void *domain_data,\n\t\t\t\t  void *chip_data);\nvoid msi_remove_device_irq_domain(struct device *dev, unsigned int domid);\n\nbool msi_match_device_irq_domain(struct device *dev, unsigned int domid,\n\t\t\t\t enum irq_domain_bus_token bus_token);\n\nint msi_domain_alloc_irqs_range_locked(struct device *dev, unsigned int domid,\n\t\t\t\t       unsigned int first, unsigned int last);\nint msi_domain_alloc_irqs_range(struct device *dev, unsigned int domid,\n\t\t\t\tunsigned int first, unsigned int last);\nint msi_domain_alloc_irqs_all_locked(struct device *dev, unsigned int domid, int nirqs);\n\nstruct msi_map msi_domain_alloc_irq_at(struct device *dev, unsigned int domid, unsigned int index,\n\t\t\t\t       const struct irq_affinity_desc *affdesc,\n\t\t\t\t       union msi_instance_cookie *cookie);\n\nvoid msi_domain_free_irqs_range_locked(struct device *dev, unsigned int domid,\n\t\t\t\t       unsigned int first, unsigned int last);\nvoid msi_domain_free_irqs_range(struct device *dev, unsigned int domid,\n\t\t\t\tunsigned int first, unsigned int last);\nvoid msi_domain_free_irqs_all_locked(struct device *dev, unsigned int domid);\nvoid msi_domain_free_irqs_all(struct device *dev, unsigned int domid);\n\nstruct msi_domain_info *msi_get_domain_info(struct irq_domain *domain);\n\nstruct irq_domain *platform_msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t\t  struct msi_domain_info *info,\n\t\t\t\t\t\t  struct irq_domain *parent);\nint platform_msi_domain_alloc_irqs(struct device *dev, unsigned int nvec,\n\t\t\t\t   irq_write_msi_msg_t write_msi_msg);\nvoid platform_msi_domain_free_irqs(struct device *dev);\n\n \nint msi_domain_prepare_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t    int nvec, msi_alloc_info_t *args);\nint msi_domain_populate_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t     int virq, int nvec, msi_alloc_info_t *args);\nvoid msi_domain_depopulate_descs(struct device *dev, int virq, int nvec);\n\nstruct irq_domain *\n__platform_msi_create_device_domain(struct device *dev,\n\t\t\t\t    unsigned int nvec,\n\t\t\t\t    bool is_tree,\n\t\t\t\t    irq_write_msi_msg_t write_msi_msg,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data);\n\n#define platform_msi_create_device_domain(dev, nvec, write, ops, data)\t\\\n\t__platform_msi_create_device_domain(dev, nvec, false, write, ops, data)\n#define platform_msi_create_device_tree_domain(dev, nvec, write, ops, data) \\\n\t__platform_msi_create_device_domain(dev, nvec, true, write, ops, data)\n\nint platform_msi_device_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t     unsigned int nr_irqs);\nvoid platform_msi_device_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t     unsigned int nvec);\nvoid *platform_msi_get_host_data(struct irq_domain *domain);\n\nbool msi_device_has_isolated_msi(struct device *dev);\n#else  \nstatic inline bool msi_device_has_isolated_msi(struct device *dev)\n{\n\t \n\treturn arch_is_isolated_msi();\n}\n#endif  \n\n \n#ifdef CONFIG_PCI_MSI\nstruct pci_dev *msi_desc_to_pci_dev(struct msi_desc *desc);\nvoid pci_write_msi_msg(unsigned int irq, struct msi_msg *msg);\nvoid __pci_read_msi_msg(struct msi_desc *entry, struct msi_msg *msg);\nvoid __pci_write_msi_msg(struct msi_desc *entry, struct msi_msg *msg);\nvoid pci_msi_mask_irq(struct irq_data *data);\nvoid pci_msi_unmask_irq(struct irq_data *data);\nstruct irq_domain *pci_msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t     struct msi_domain_info *info,\n\t\t\t\t\t     struct irq_domain *parent);\nu32 pci_msi_domain_get_msi_rid(struct irq_domain *domain, struct pci_dev *pdev);\nstruct irq_domain *pci_msi_get_device_domain(struct pci_dev *pdev);\n#else  \nstatic inline struct irq_domain *pci_msi_get_device_domain(struct pci_dev *pdev)\n{\n\treturn NULL;\n}\nstatic inline void pci_write_msi_msg(unsigned int irq, struct msi_msg *msg) { }\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}