{
  "module_name": "tcp.h",
  "hash_id": "344e49abf4685c77cabf9e25c55bccf0c0ac1e09ba6304ab015ceebb4c56fdae",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/tcp.h",
  "human_readable_source": " \n \n#ifndef _LINUX_TCP_H\n#define _LINUX_TCP_H\n\n\n#include <linux/skbuff.h>\n#include <linux/win_minmax.h>\n#include <net/sock.h>\n#include <net/inet_connection_sock.h>\n#include <net/inet_timewait_sock.h>\n#include <uapi/linux/tcp.h>\n\nstatic inline struct tcphdr *tcp_hdr(const struct sk_buff *skb)\n{\n\treturn (struct tcphdr *)skb_transport_header(skb);\n}\n\nstatic inline unsigned int __tcp_hdrlen(const struct tcphdr *th)\n{\n\treturn th->doff * 4;\n}\n\nstatic inline unsigned int tcp_hdrlen(const struct sk_buff *skb)\n{\n\treturn __tcp_hdrlen(tcp_hdr(skb));\n}\n\nstatic inline struct tcphdr *inner_tcp_hdr(const struct sk_buff *skb)\n{\n\treturn (struct tcphdr *)skb_inner_transport_header(skb);\n}\n\nstatic inline unsigned int inner_tcp_hdrlen(const struct sk_buff *skb)\n{\n\treturn inner_tcp_hdr(skb)->doff * 4;\n}\n\n \nstatic inline int skb_tcp_all_headers(const struct sk_buff *skb)\n{\n\treturn skb_transport_offset(skb) + tcp_hdrlen(skb);\n}\n\n \nstatic inline int skb_inner_tcp_all_headers(const struct sk_buff *skb)\n{\n\treturn skb_inner_transport_offset(skb) + inner_tcp_hdrlen(skb);\n}\n\nstatic inline unsigned int tcp_optlen(const struct sk_buff *skb)\n{\n\treturn (tcp_hdr(skb)->doff - 5) * 4;\n}\n\n \n#define TCP_FASTOPEN_COOKIE_MIN\t4\t \n#define TCP_FASTOPEN_COOKIE_MAX\t16\t \n#define TCP_FASTOPEN_COOKIE_SIZE 8\t \n\n \nstruct tcp_fastopen_cookie {\n\t__le64\tval[DIV_ROUND_UP(TCP_FASTOPEN_COOKIE_MAX, sizeof(u64))];\n\ts8\tlen;\n\tbool\texp;\t \n};\n\n \nstruct tcp_sack_block_wire {\n\t__be32\tstart_seq;\n\t__be32\tend_seq;\n};\n\nstruct tcp_sack_block {\n\tu32\tstart_seq;\n\tu32\tend_seq;\n};\n\n \n#define TCP_SACK_SEEN     (1 << 0)    \n#define TCP_DSACK_SEEN    (1 << 2)    \n\nstruct tcp_options_received {\n \n\tint\tts_recent_stamp; \n\tu32\tts_recent;\t \n\tu32\trcv_tsval;\t \n\tu32\trcv_tsecr;\t \n\tu16 \tsaw_tstamp : 1,\t \n\t\ttstamp_ok : 1,\t \n\t\tdsack : 1,\t \n\t\twscale_ok : 1,\t \n\t\tsack_ok : 3,\t \n\t\tsmc_ok : 1,\t \n\t\tsnd_wscale : 4,\t \n\t\trcv_wscale : 4;\t \n\tu8\tsaw_unknown:1,\t \n\t\tunused:7;\n\tu8\tnum_sacks;\t \n\tu16\tuser_mss;\t \n\tu16\tmss_clamp;\t \n};\n\nstatic inline void tcp_clear_options(struct tcp_options_received *rx_opt)\n{\n\trx_opt->tstamp_ok = rx_opt->sack_ok = 0;\n\trx_opt->wscale_ok = rx_opt->snd_wscale = 0;\n#if IS_ENABLED(CONFIG_SMC)\n\trx_opt->smc_ok = 0;\n#endif\n}\n\n \n#define TCP_NUM_SACKS 4\n\nstruct tcp_request_sock_ops;\n\nstruct tcp_request_sock {\n\tstruct inet_request_sock \treq;\n\tconst struct tcp_request_sock_ops *af_specific;\n\tu64\t\t\t\tsnt_synack;  \n\tbool\t\t\t\ttfo_listener;\n\tbool\t\t\t\tis_mptcp;\n#if IS_ENABLED(CONFIG_MPTCP)\n\tbool\t\t\t\tdrop_req;\n#endif\n\tu32\t\t\t\ttxhash;\n\tu32\t\t\t\trcv_isn;\n\tu32\t\t\t\tsnt_isn;\n\tu32\t\t\t\tts_off;\n\tu32\t\t\t\tlast_oow_ack_time;  \n\tu32\t\t\t\trcv_nxt;  \n\tu8\t\t\t\tsyn_tos;\n};\n\nstatic inline struct tcp_request_sock *tcp_rsk(const struct request_sock *req)\n{\n\treturn (struct tcp_request_sock *)req;\n}\n\n#define TCP_RMEM_TO_WIN_SCALE 8\n\nstruct tcp_sock {\n\t \n\tstruct inet_connection_sock\tinet_conn;\n\tu16\ttcp_header_len;\t \n\tu16\tgso_segs;\t \n\n \n\t__be32\tpred_flags;\n\n \n\tu64\tbytes_received;\t \n\tu32\tsegs_in;\t \n\tu32\tdata_segs_in;\t \n \tu32\trcv_nxt;\t \n\tu32\tcopied_seq;\t \n\tu32\trcv_wup;\t \n \tu32\tsnd_nxt;\t \n\tu32\tsegs_out;\t \n\tu32\tdata_segs_out;\t \n\tu64\tbytes_sent;\t \n\tu64\tbytes_acked;\t \n\tu32\tdsack_dups;\t \n \tu32\tsnd_una;\t \n \tu32\tsnd_sml;\t \n\tu32\trcv_tstamp;\t \n\tu32\tlsndtime;\t \n\tu32\tlast_oow_ack_time;   \n\tu32\tcompressed_ack_rcv_nxt;\n\n\tu32\ttsoffset;\t \n\n\tstruct list_head tsq_node;  \n\tstruct list_head tsorted_sent_queue;  \n\n\tu32\tsnd_wl1;\t \n\tu32\tsnd_wnd;\t \n\tu32\tmax_window;\t \n\tu32\tmss_cache;\t \n\n\tu32\twindow_clamp;\t \n\tu32\trcv_ssthresh;\t \n\tu8\tscaling_ratio;\t \n\t \n\tstruct tcp_rack {\n\t\tu64 mstamp;  \n\t\tu32 rtt_us;   \n\t\tu32 end_seq;  \n\t\tu32 last_delivered;  \n\t\tu8 reo_wnd_steps;    \n#define TCP_RACK_RECOVERY_THRESH 16\n\t\tu8 reo_wnd_persist:5,  \n\t\t   dsack_seen:1,  \n\t\t   advanced:1;\t  \n\t} rack;\n\tu16\tadvmss;\t\t \n\tu8\tcompressed_ack;\n\tu8\tdup_ack_counter:2,\n\t\ttlp_retrans:1,\t \n\t\tunused:5;\n\tu32\tchrono_start;\t \n\tu32\tchrono_stat[3];\t \n\tu8\tchrono_type:2,\t \n\t\trate_app_limited:1,   \n\t\tfastopen_connect:1,  \n\t\tfastopen_no_cookie:1,  \n\t\tis_sack_reneg:1,     \n\t\tfastopen_client_fail:2;  \n\tu8\tnonagle     : 4, \n\t\tthin_lto    : 1, \n\t\trecvmsg_inq : 1, \n\t\trepair      : 1,\n\t\tfrto        : 1; \n\tu8\trepair_queue;\n\tu8\tsave_syn:2,\t \n\t\tsyn_data:1,\t \n\t\tsyn_fastopen:1,\t \n\t\tsyn_fastopen_exp:1, \n\t\tsyn_fastopen_ch:1,  \n\t\tsyn_data_acked:1, \n\t\tis_cwnd_limited:1; \n\tu32\ttlp_high_seq;\t \n\n\tu32\ttcp_tx_delay;\t \n\tu64\ttcp_wstamp_ns;\t \n\tu64\ttcp_clock_cache;  \n\n \n\tu64\ttcp_mstamp;\t \n\tu32\tsrtt_us;\t \n\tu32\tmdev_us;\t \n\tu32\tmdev_max_us;\t \n\tu32\trttvar_us;\t \n\tu32\trtt_seq;\t \n\tstruct  minmax rtt_min;\n\n\tu32\tpackets_out;\t \n\tu32\tretrans_out;\t \n\tu32\tmax_packets_out;   \n\tu32\tcwnd_usage_seq;   \n\n\tu16\turg_data;\t \n\tu8\tecn_flags;\t \n\tu8\tkeepalive_probes;  \n\tu32\treordering;\t \n\tu32\treord_seen;\t \n\tu32\tsnd_up;\t\t \n\n \n\tstruct tcp_options_received rx_opt;\n\n \n \tu32\tsnd_ssthresh;\t \n \tu32\tsnd_cwnd;\t \n\tu32\tsnd_cwnd_cnt;\t \n\tu32\tsnd_cwnd_clamp;  \n\tu32\tsnd_cwnd_used;\n\tu32\tsnd_cwnd_stamp;\n\tu32\tprior_cwnd;\t \n\tu32\tprr_delivered;\t \n\tu32\tprr_out;\t \n\tu32\tdelivered;\t \n\tu32\tdelivered_ce;\t \n\tu32\tlost;\t\t \n\tu32\tapp_limited;\t \n\tu64\tfirst_tx_mstamp;   \n\tu64\tdelivered_mstamp;  \n\tu32\trate_delivered;     \n\tu32\trate_interval_us;   \n\n \tu32\trcv_wnd;\t \n\tu32\twrite_seq;\t \n\tu32\tnotsent_lowat;\t \n\tu32\tpushed_seq;\t \n\tu32\tlost_out;\t \n\tu32\tsacked_out;\t \n\n\tstruct hrtimer\tpacing_timer;\n\tstruct hrtimer\tcompressed_ack_timer;\n\n\t \n\tstruct sk_buff* lost_skb_hint;\n\tstruct sk_buff *retransmit_skb_hint;\n\n\t \n\tstruct rb_root\tout_of_order_queue;\n\tstruct sk_buff\t*ooo_last_skb;  \n\n\t \n\tstruct tcp_sack_block duplicate_sack[1];  \n\tstruct tcp_sack_block selective_acks[4];  \n\n\tstruct tcp_sack_block recv_sack_cache[4];\n\n\tstruct sk_buff *highest_sack;    \n\n\tint     lost_cnt_hint;\n\n\tu32\tprior_ssthresh;  \n\tu32\thigh_seq;\t \n\n\tu32\tretrans_stamp;\t \n\tu32\tundo_marker;\t \n\tint\tundo_retrans;\t \n\tu64\tbytes_retrans;\t \n\tu32\ttotal_retrans;\t \n\n\tu32\turg_seq;\t \n\tunsigned int\t\tkeepalive_time;\t   \n\tunsigned int\t\tkeepalive_intvl;   \n\n\tint\t\t\tlinger2;\n\n\n \n#ifdef CONFIG_BPF\n\tu8\tbpf_sock_ops_cb_flags;   \n\tu8\tbpf_chg_cc_inprogress:1;  \n#define BPF_SOCK_OPS_TEST_FLAG(TP, ARG) (TP->bpf_sock_ops_cb_flags & ARG)\n#else\n#define BPF_SOCK_OPS_TEST_FLAG(TP, ARG) 0\n#endif\n\n\tu16 timeout_rehash;\t \n\n\tu32 rcv_ooopack;  \n\n \n\tu32 rcv_rtt_last_tsecr;\n\tstruct {\n\t\tu32\trtt_us;\n\t\tu32\tseq;\n\t\tu64\ttime;\n\t} rcv_rtt_est;\n\n \n\tstruct {\n\t\tu32\tspace;\n\t\tu32\tseq;\n\t\tu64\ttime;\n\t} rcvq_space;\n\n \n\tstruct {\n\t\tu32\t\t  probe_seq_start;\n\t\tu32\t\t  probe_seq_end;\n\t} mtu_probe;\n\tu32     plb_rehash;      \n\tu32\tmtu_info;  \n#if IS_ENABLED(CONFIG_MPTCP)\n\tbool\tis_mptcp;\n#endif\n#if IS_ENABLED(CONFIG_SMC)\n\tbool\t(*smc_hs_congested)(const struct sock *sk);\n\tbool\tsyn_smc;\t \n#endif\n\n#ifdef CONFIG_TCP_MD5SIG\n \n\tconst struct tcp_sock_af_ops\t*af_specific;\n\n \n\tstruct tcp_md5sig_info\t__rcu *md5sig_info;\n#endif\n\n \n\tstruct tcp_fastopen_request *fastopen_req;\n\t \n\tstruct request_sock __rcu *fastopen_rsk;\n\tstruct saved_syn *saved_syn;\n};\n\nenum tsq_enum {\n\tTSQ_THROTTLED,\n\tTSQ_QUEUED,\n\tTCP_TSQ_DEFERRED,\t    \n\tTCP_WRITE_TIMER_DEFERRED,   \n\tTCP_DELACK_TIMER_DEFERRED,  \n\tTCP_MTU_REDUCED_DEFERRED,   \n};\n\nenum tsq_flags {\n\tTSQF_THROTTLED\t\t\t= (1UL << TSQ_THROTTLED),\n\tTSQF_QUEUED\t\t\t= (1UL << TSQ_QUEUED),\n\tTCPF_TSQ_DEFERRED\t\t= (1UL << TCP_TSQ_DEFERRED),\n\tTCPF_WRITE_TIMER_DEFERRED\t= (1UL << TCP_WRITE_TIMER_DEFERRED),\n\tTCPF_DELACK_TIMER_DEFERRED\t= (1UL << TCP_DELACK_TIMER_DEFERRED),\n\tTCPF_MTU_REDUCED_DEFERRED\t= (1UL << TCP_MTU_REDUCED_DEFERRED),\n};\n\n#define tcp_sk(ptr) container_of_const(ptr, struct tcp_sock, inet_conn.icsk_inet.sk)\n\n \n#define tcp_sk_rw(ptr) container_of(ptr, struct tcp_sock, inet_conn.icsk_inet.sk)\n\nstruct tcp_timewait_sock {\n\tstruct inet_timewait_sock tw_sk;\n#define tw_rcv_nxt tw_sk.__tw_common.skc_tw_rcv_nxt\n#define tw_snd_nxt tw_sk.__tw_common.skc_tw_snd_nxt\n\tu32\t\t\t  tw_rcv_wnd;\n\tu32\t\t\t  tw_ts_offset;\n\tu32\t\t\t  tw_ts_recent;\n\n\t \n\tu32\t\t\t  tw_last_oow_ack_time;\n\n\tint\t\t\t  tw_ts_recent_stamp;\n\tu32\t\t\t  tw_tx_delay;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key\t  *tw_md5_key;\n#endif\n};\n\nstatic inline struct tcp_timewait_sock *tcp_twsk(const struct sock *sk)\n{\n\treturn (struct tcp_timewait_sock *)sk;\n}\n\nstatic inline bool tcp_passive_fastopen(const struct sock *sk)\n{\n\treturn sk->sk_state == TCP_SYN_RECV &&\n\t       rcu_access_pointer(tcp_sk(sk)->fastopen_rsk) != NULL;\n}\n\nstatic inline void fastopen_queue_tune(struct sock *sk, int backlog)\n{\n\tstruct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue;\n\tint somaxconn = READ_ONCE(sock_net(sk)->core.sysctl_somaxconn);\n\n\tWRITE_ONCE(queue->fastopenq.max_qlen, min_t(unsigned int, backlog, somaxconn));\n}\n\nstatic inline void tcp_move_syn(struct tcp_sock *tp,\n\t\t\t\tstruct request_sock *req)\n{\n\ttp->saved_syn = req->saved_syn;\n\treq->saved_syn = NULL;\n}\n\nstatic inline void tcp_saved_syn_free(struct tcp_sock *tp)\n{\n\tkfree(tp->saved_syn);\n\ttp->saved_syn = NULL;\n}\n\nstatic inline u32 tcp_saved_syn_len(const struct saved_syn *saved_syn)\n{\n\treturn saved_syn->mac_hdrlen + saved_syn->network_hdrlen +\n\t\tsaved_syn->tcp_hdrlen;\n}\n\nstruct sk_buff *tcp_get_timestamping_opt_stats(const struct sock *sk,\n\t\t\t\t\t       const struct sk_buff *orig_skb,\n\t\t\t\t\t       const struct sk_buff *ack_skb);\n\nstatic inline u16 tcp_mss_clamp(const struct tcp_sock *tp, u16 mss)\n{\n\t \n\tu16 user_mss = READ_ONCE(tp->rx_opt.user_mss);\n\n\treturn (user_mss && user_mss < mss) ? user_mss : mss;\n}\n\nint tcp_skb_shift(struct sk_buff *to, struct sk_buff *from, int pcount,\n\t\t  int shiftlen);\n\nvoid __tcp_sock_set_cork(struct sock *sk, bool on);\nvoid tcp_sock_set_cork(struct sock *sk, bool on);\nint tcp_sock_set_keepcnt(struct sock *sk, int val);\nint tcp_sock_set_keepidle_locked(struct sock *sk, int val);\nint tcp_sock_set_keepidle(struct sock *sk, int val);\nint tcp_sock_set_keepintvl(struct sock *sk, int val);\nvoid __tcp_sock_set_nodelay(struct sock *sk, bool on);\nvoid tcp_sock_set_nodelay(struct sock *sk);\nvoid tcp_sock_set_quickack(struct sock *sk, int val);\nint tcp_sock_set_syncnt(struct sock *sk, int val);\nint tcp_sock_set_user_timeout(struct sock *sk, int val);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}