{
  "module_name": "damon.h",
  "hash_id": "504dc988459d56664cb119846e44adb4a9a1e785293eb4733f143879651bd214",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/damon.h",
  "human_readable_source": " \n \n\n#ifndef _DAMON_H_\n#define _DAMON_H_\n\n#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/time64.h>\n#include <linux/types.h>\n#include <linux/random.h>\n\n \n#define DAMON_MIN_REGION\tPAGE_SIZE\n \n#define DAMOS_MAX_SCORE\t\t(99)\n\n \nstatic inline unsigned long damon_rand(unsigned long l, unsigned long r)\n{\n\treturn l + get_random_u32_below(r - l);\n}\n\n \nstruct damon_addr_range {\n\tunsigned long start;\n\tunsigned long end;\n};\n\n \nstruct damon_region {\n\tstruct damon_addr_range ar;\n\tunsigned long sampling_addr;\n\tunsigned int nr_accesses;\n\tstruct list_head list;\n\n\tunsigned int age;\n \n\tunsigned int last_nr_accesses;\n};\n\n \nstruct damon_target {\n\tstruct pid *pid;\n\tunsigned int nr_regions;\n\tstruct list_head regions_list;\n\tstruct list_head list;\n};\n\n \nenum damos_action {\n\tDAMOS_WILLNEED,\n\tDAMOS_COLD,\n\tDAMOS_PAGEOUT,\n\tDAMOS_HUGEPAGE,\n\tDAMOS_NOHUGEPAGE,\n\tDAMOS_LRU_PRIO,\n\tDAMOS_LRU_DEPRIO,\n\tDAMOS_STAT,\t\t \n\tNR_DAMOS_ACTIONS,\n};\n\n \nstruct damos_quota {\n\tunsigned long ms;\n\tunsigned long sz;\n\tunsigned long reset_interval;\n\n\tunsigned int weight_sz;\n\tunsigned int weight_nr_accesses;\n\tunsigned int weight_age;\n\n \n\t \n\tunsigned long total_charged_sz;\n\tunsigned long total_charged_ns;\n\n\tunsigned long esz;\t \n\n\t \n\tunsigned long charged_sz;\n\tunsigned long charged_from;\n\tstruct damon_target *charge_target_from;\n\tunsigned long charge_addr_from;\n\n\t \n\tunsigned long histogram[DAMOS_MAX_SCORE + 1];\n\tunsigned int min_score;\n};\n\n \nenum damos_wmark_metric {\n\tDAMOS_WMARK_NONE,\n\tDAMOS_WMARK_FREE_MEM_RATE,\n\tNR_DAMOS_WMARK_METRICS,\n};\n\n \nstruct damos_watermarks {\n\tenum damos_wmark_metric metric;\n\tunsigned long interval;\n\tunsigned long high;\n\tunsigned long mid;\n\tunsigned long low;\n\n \n\tbool activated;\n};\n\n \nstruct damos_stat {\n\tunsigned long nr_tried;\n\tunsigned long sz_tried;\n\tunsigned long nr_applied;\n\tunsigned long sz_applied;\n\tunsigned long qt_exceeds;\n};\n\n \nenum damos_filter_type {\n\tDAMOS_FILTER_TYPE_ANON,\n\tDAMOS_FILTER_TYPE_MEMCG,\n\tDAMOS_FILTER_TYPE_ADDR,\n\tDAMOS_FILTER_TYPE_TARGET,\n\tNR_DAMOS_FILTER_TYPES,\n};\n\n \nstruct damos_filter {\n\tenum damos_filter_type type;\n\tbool matching;\n\tunion {\n\t\tunsigned short memcg_id;\n\t\tstruct damon_addr_range addr_range;\n\t\tint target_idx;\n\t};\n\tstruct list_head list;\n};\n\n \nstruct damos_access_pattern {\n\tunsigned long min_sz_region;\n\tunsigned long max_sz_region;\n\tunsigned int min_nr_accesses;\n\tunsigned int max_nr_accesses;\n\tunsigned int min_age_region;\n\tunsigned int max_age_region;\n};\n\n \nstruct damos {\n\tstruct damos_access_pattern pattern;\n\tenum damos_action action;\n\tstruct damos_quota quota;\n\tstruct damos_watermarks wmarks;\n\tstruct list_head filters;\n\tstruct damos_stat stat;\n\tstruct list_head list;\n};\n\n \nenum damon_ops_id {\n\tDAMON_OPS_VADDR,\n\tDAMON_OPS_FVADDR,\n\tDAMON_OPS_PADDR,\n\tNR_DAMON_OPS,\n};\n\nstruct damon_ctx;\n\n \nstruct damon_operations {\n\tenum damon_ops_id id;\n\tvoid (*init)(struct damon_ctx *context);\n\tvoid (*update)(struct damon_ctx *context);\n\tvoid (*prepare_access_checks)(struct damon_ctx *context);\n\tunsigned int (*check_accesses)(struct damon_ctx *context);\n\tvoid (*reset_aggregated)(struct damon_ctx *context);\n\tint (*get_scheme_score)(struct damon_ctx *context,\n\t\t\tstruct damon_target *t, struct damon_region *r,\n\t\t\tstruct damos *scheme);\n\tunsigned long (*apply_scheme)(struct damon_ctx *context,\n\t\t\tstruct damon_target *t, struct damon_region *r,\n\t\t\tstruct damos *scheme);\n\tbool (*target_valid)(struct damon_target *t);\n\tvoid (*cleanup)(struct damon_ctx *context);\n};\n\n \nstruct damon_callback {\n\tvoid *private;\n\n\tint (*before_start)(struct damon_ctx *context);\n\tint (*after_wmarks_check)(struct damon_ctx *context);\n\tint (*after_sampling)(struct damon_ctx *context);\n\tint (*after_aggregation)(struct damon_ctx *context);\n\tint (*before_damos_apply)(struct damon_ctx *context,\n\t\t\tstruct damon_target *target,\n\t\t\tstruct damon_region *region,\n\t\t\tstruct damos *scheme);\n\tvoid (*before_terminate)(struct damon_ctx *context);\n};\n\n \nstruct damon_attrs {\n\tunsigned long sample_interval;\n\tunsigned long aggr_interval;\n\tunsigned long ops_update_interval;\n\tunsigned long min_nr_regions;\n\tunsigned long max_nr_regions;\n};\n\n \nstruct damon_ctx {\n\tstruct damon_attrs attrs;\n\n \n\t \n\tunsigned long passed_sample_intervals;\n\t \n\tunsigned long next_aggregation_sis;\n\t \n\tunsigned long next_ops_update_sis;\n\t \n\tstruct completion kdamond_started;\n\n \n\tstruct task_struct *kdamond;\n\tstruct mutex kdamond_lock;\n\n\tstruct damon_operations ops;\n\tstruct damon_callback callback;\n\n\tstruct list_head adaptive_targets;\n\tstruct list_head schemes;\n};\n\nstatic inline struct damon_region *damon_next_region(struct damon_region *r)\n{\n\treturn container_of(r->list.next, struct damon_region, list);\n}\n\nstatic inline struct damon_region *damon_prev_region(struct damon_region *r)\n{\n\treturn container_of(r->list.prev, struct damon_region, list);\n}\n\nstatic inline struct damon_region *damon_last_region(struct damon_target *t)\n{\n\treturn list_last_entry(&t->regions_list, struct damon_region, list);\n}\n\nstatic inline struct damon_region *damon_first_region(struct damon_target *t)\n{\n\treturn list_first_entry(&t->regions_list, struct damon_region, list);\n}\n\nstatic inline unsigned long damon_sz_region(struct damon_region *r)\n{\n\treturn r->ar.end - r->ar.start;\n}\n\n\n#define damon_for_each_region(r, t) \\\n\tlist_for_each_entry(r, &t->regions_list, list)\n\n#define damon_for_each_region_from(r, t) \\\n\tlist_for_each_entry_from(r, &t->regions_list, list)\n\n#define damon_for_each_region_safe(r, next, t) \\\n\tlist_for_each_entry_safe(r, next, &t->regions_list, list)\n\n#define damon_for_each_target(t, ctx) \\\n\tlist_for_each_entry(t, &(ctx)->adaptive_targets, list)\n\n#define damon_for_each_target_safe(t, next, ctx)\t\\\n\tlist_for_each_entry_safe(t, next, &(ctx)->adaptive_targets, list)\n\n#define damon_for_each_scheme(s, ctx) \\\n\tlist_for_each_entry(s, &(ctx)->schemes, list)\n\n#define damon_for_each_scheme_safe(s, next, ctx) \\\n\tlist_for_each_entry_safe(s, next, &(ctx)->schemes, list)\n\n#define damos_for_each_filter(f, scheme) \\\n\tlist_for_each_entry(f, &(scheme)->filters, list)\n\n#define damos_for_each_filter_safe(f, next, scheme) \\\n\tlist_for_each_entry_safe(f, next, &(scheme)->filters, list)\n\n#ifdef CONFIG_DAMON\n\nstruct damon_region *damon_new_region(unsigned long start, unsigned long end);\n\n \nstatic inline void damon_insert_region(struct damon_region *r,\n\t\tstruct damon_region *prev, struct damon_region *next,\n\t\tstruct damon_target *t)\n{\n\t__list_add(&r->list, &prev->list, &next->list);\n\tt->nr_regions++;\n}\n\nvoid damon_add_region(struct damon_region *r, struct damon_target *t);\nvoid damon_destroy_region(struct damon_region *r, struct damon_target *t);\nint damon_set_regions(struct damon_target *t, struct damon_addr_range *ranges,\n\t\tunsigned int nr_ranges);\n\nstruct damos_filter *damos_new_filter(enum damos_filter_type type,\n\t\tbool matching);\nvoid damos_add_filter(struct damos *s, struct damos_filter *f);\nvoid damos_destroy_filter(struct damos_filter *f);\n\nstruct damos *damon_new_scheme(struct damos_access_pattern *pattern,\n\t\t\tenum damos_action action, struct damos_quota *quota,\n\t\t\tstruct damos_watermarks *wmarks);\nvoid damon_add_scheme(struct damon_ctx *ctx, struct damos *s);\nvoid damon_destroy_scheme(struct damos *s);\n\nstruct damon_target *damon_new_target(void);\nvoid damon_add_target(struct damon_ctx *ctx, struct damon_target *t);\nbool damon_targets_empty(struct damon_ctx *ctx);\nvoid damon_free_target(struct damon_target *t);\nvoid damon_destroy_target(struct damon_target *t);\nunsigned int damon_nr_regions(struct damon_target *t);\n\nstruct damon_ctx *damon_new_ctx(void);\nvoid damon_destroy_ctx(struct damon_ctx *ctx);\nint damon_set_attrs(struct damon_ctx *ctx, struct damon_attrs *attrs);\nvoid damon_set_schemes(struct damon_ctx *ctx,\n\t\t\tstruct damos **schemes, ssize_t nr_schemes);\nint damon_nr_running_ctxs(void);\nbool damon_is_registered_ops(enum damon_ops_id id);\nint damon_register_ops(struct damon_operations *ops);\nint damon_select_ops(struct damon_ctx *ctx, enum damon_ops_id id);\n\nstatic inline bool damon_target_has_pid(const struct damon_ctx *ctx)\n{\n\treturn ctx->ops.id == DAMON_OPS_VADDR || ctx->ops.id == DAMON_OPS_FVADDR;\n}\n\nstatic inline unsigned int damon_max_nr_accesses(const struct damon_attrs *attrs)\n{\n\t \n\treturn min(attrs->aggr_interval / attrs->sample_interval,\n\t\t\t(unsigned long)UINT_MAX);\n}\n\n\nint damon_start(struct damon_ctx **ctxs, int nr_ctxs, bool exclusive);\nint damon_stop(struct damon_ctx **ctxs, int nr_ctxs);\n\nint damon_set_region_biggest_system_ram_default(struct damon_target *t,\n\t\t\t\tunsigned long *start, unsigned long *end);\n\n#endif\t \n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}