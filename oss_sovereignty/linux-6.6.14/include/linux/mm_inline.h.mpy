{
  "module_name": "mm_inline.h",
  "hash_id": "a1a634bc9983e69b6b3d0bbce43826153ea49f3d6f83593d4bbba80c9e43564f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mm_inline.h",
  "human_readable_source": " \n#ifndef LINUX_MM_INLINE_H\n#define LINUX_MM_INLINE_H\n\n#include <linux/atomic.h>\n#include <linux/huge_mm.h>\n#include <linux/swap.h>\n#include <linux/string.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/swapops.h>\n\n \nstatic inline int folio_is_file_lru(struct folio *folio)\n{\n\treturn !folio_test_swapbacked(folio);\n}\n\nstatic inline int page_is_file_lru(struct page *page)\n{\n\treturn folio_is_file_lru(page_folio(page));\n}\n\nstatic __always_inline void __update_lru_size(struct lruvec *lruvec,\n\t\t\t\tenum lru_list lru, enum zone_type zid,\n\t\t\t\tlong nr_pages)\n{\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\n\tlockdep_assert_held(&lruvec->lru_lock);\n\tWARN_ON_ONCE(nr_pages != (int)nr_pages);\n\n\t__mod_lruvec_state(lruvec, NR_LRU_BASE + lru, nr_pages);\n\t__mod_zone_page_state(&pgdat->node_zones[zid],\n\t\t\t\tNR_ZONE_LRU_BASE + lru, nr_pages);\n}\n\nstatic __always_inline void update_lru_size(struct lruvec *lruvec,\n\t\t\t\tenum lru_list lru, enum zone_type zid,\n\t\t\t\tlong nr_pages)\n{\n\t__update_lru_size(lruvec, lru, zid, nr_pages);\n#ifdef CONFIG_MEMCG\n\tmem_cgroup_update_lru_size(lruvec, lru, zid, nr_pages);\n#endif\n}\n\n \nstatic __always_inline void __folio_clear_lru_flags(struct folio *folio)\n{\n\tVM_BUG_ON_FOLIO(!folio_test_lru(folio), folio);\n\n\t__folio_clear_lru(folio);\n\n\t \n\tif (folio_test_active(folio) && folio_test_unevictable(folio))\n\t\treturn;\n\n\t__folio_clear_active(folio);\n\t__folio_clear_unevictable(folio);\n}\n\n \nstatic __always_inline enum lru_list folio_lru_list(struct folio *folio)\n{\n\tenum lru_list lru;\n\n\tVM_BUG_ON_FOLIO(folio_test_active(folio) && folio_test_unevictable(folio), folio);\n\n\tif (folio_test_unevictable(folio))\n\t\treturn LRU_UNEVICTABLE;\n\n\tlru = folio_is_file_lru(folio) ? LRU_INACTIVE_FILE : LRU_INACTIVE_ANON;\n\tif (folio_test_active(folio))\n\t\tlru += LRU_ACTIVE;\n\n\treturn lru;\n}\n\n#ifdef CONFIG_LRU_GEN\n\n#ifdef CONFIG_LRU_GEN_ENABLED\nstatic inline bool lru_gen_enabled(void)\n{\n\tDECLARE_STATIC_KEY_TRUE(lru_gen_caps[NR_LRU_GEN_CAPS]);\n\n\treturn static_branch_likely(&lru_gen_caps[LRU_GEN_CORE]);\n}\n#else\nstatic inline bool lru_gen_enabled(void)\n{\n\tDECLARE_STATIC_KEY_FALSE(lru_gen_caps[NR_LRU_GEN_CAPS]);\n\n\treturn static_branch_unlikely(&lru_gen_caps[LRU_GEN_CORE]);\n}\n#endif\n\nstatic inline bool lru_gen_in_fault(void)\n{\n\treturn current->in_lru_fault;\n}\n\nstatic inline int lru_gen_from_seq(unsigned long seq)\n{\n\treturn seq % MAX_NR_GENS;\n}\n\nstatic inline int lru_hist_from_seq(unsigned long seq)\n{\n\treturn seq % NR_HIST_GENS;\n}\n\nstatic inline int lru_tier_from_refs(int refs)\n{\n\tVM_WARN_ON_ONCE(refs > BIT(LRU_REFS_WIDTH));\n\n\t \n\treturn order_base_2(refs + 1);\n}\n\nstatic inline int folio_lru_refs(struct folio *folio)\n{\n\tunsigned long flags = READ_ONCE(folio->flags);\n\tbool workingset = flags & BIT(PG_workingset);\n\n\t \n\treturn ((flags & LRU_REFS_MASK) >> LRU_REFS_PGOFF) + workingset;\n}\n\nstatic inline int folio_lru_gen(struct folio *folio)\n{\n\tunsigned long flags = READ_ONCE(folio->flags);\n\n\treturn ((flags & LRU_GEN_MASK) >> LRU_GEN_PGOFF) - 1;\n}\n\nstatic inline bool lru_gen_is_active(struct lruvec *lruvec, int gen)\n{\n\tunsigned long max_seq = lruvec->lrugen.max_seq;\n\n\tVM_WARN_ON_ONCE(gen >= MAX_NR_GENS);\n\n\t \n\treturn gen == lru_gen_from_seq(max_seq) || gen == lru_gen_from_seq(max_seq - 1);\n}\n\nstatic inline void lru_gen_update_size(struct lruvec *lruvec, struct folio *folio,\n\t\t\t\t       int old_gen, int new_gen)\n{\n\tint type = folio_is_file_lru(folio);\n\tint zone = folio_zonenum(folio);\n\tint delta = folio_nr_pages(folio);\n\tenum lru_list lru = type * LRU_INACTIVE_FILE;\n\tstruct lru_gen_folio *lrugen = &lruvec->lrugen;\n\n\tVM_WARN_ON_ONCE(old_gen != -1 && old_gen >= MAX_NR_GENS);\n\tVM_WARN_ON_ONCE(new_gen != -1 && new_gen >= MAX_NR_GENS);\n\tVM_WARN_ON_ONCE(old_gen == -1 && new_gen == -1);\n\n\tif (old_gen >= 0)\n\t\tWRITE_ONCE(lrugen->nr_pages[old_gen][type][zone],\n\t\t\t   lrugen->nr_pages[old_gen][type][zone] - delta);\n\tif (new_gen >= 0)\n\t\tWRITE_ONCE(lrugen->nr_pages[new_gen][type][zone],\n\t\t\t   lrugen->nr_pages[new_gen][type][zone] + delta);\n\n\t \n\tif (old_gen < 0) {\n\t\tif (lru_gen_is_active(lruvec, new_gen))\n\t\t\tlru += LRU_ACTIVE;\n\t\t__update_lru_size(lruvec, lru, zone, delta);\n\t\treturn;\n\t}\n\n\t \n\tif (new_gen < 0) {\n\t\tif (lru_gen_is_active(lruvec, old_gen))\n\t\t\tlru += LRU_ACTIVE;\n\t\t__update_lru_size(lruvec, lru, zone, -delta);\n\t\treturn;\n\t}\n\n\t \n\tif (!lru_gen_is_active(lruvec, old_gen) && lru_gen_is_active(lruvec, new_gen)) {\n\t\t__update_lru_size(lruvec, lru, zone, -delta);\n\t\t__update_lru_size(lruvec, lru + LRU_ACTIVE, zone, delta);\n\t}\n\n\t \n\tVM_WARN_ON_ONCE(lru_gen_is_active(lruvec, old_gen) && !lru_gen_is_active(lruvec, new_gen));\n}\n\nstatic inline bool lru_gen_add_folio(struct lruvec *lruvec, struct folio *folio, bool reclaiming)\n{\n\tunsigned long seq;\n\tunsigned long flags;\n\tint gen = folio_lru_gen(folio);\n\tint type = folio_is_file_lru(folio);\n\tint zone = folio_zonenum(folio);\n\tstruct lru_gen_folio *lrugen = &lruvec->lrugen;\n\n\tVM_WARN_ON_ONCE_FOLIO(gen != -1, folio);\n\n\tif (folio_test_unevictable(folio) || !lrugen->enabled)\n\t\treturn false;\n\t \n\tif (folio_test_active(folio))\n\t\tseq = lrugen->max_seq;\n\telse if ((type == LRU_GEN_ANON && !folio_test_swapcache(folio)) ||\n\t\t (folio_test_reclaim(folio) &&\n\t\t  (folio_test_dirty(folio) || folio_test_writeback(folio))))\n\t\tseq = lrugen->max_seq - 1;\n\telse if (reclaiming || lrugen->min_seq[type] + MIN_NR_GENS >= lrugen->max_seq)\n\t\tseq = lrugen->min_seq[type];\n\telse\n\t\tseq = lrugen->min_seq[type] + 1;\n\n\tgen = lru_gen_from_seq(seq);\n\tflags = (gen + 1UL) << LRU_GEN_PGOFF;\n\t \n\tset_mask_bits(&folio->flags, LRU_GEN_MASK | BIT(PG_active), flags);\n\n\tlru_gen_update_size(lruvec, folio, -1, gen);\n\t \n\tif (reclaiming)\n\t\tlist_add_tail(&folio->lru, &lrugen->folios[gen][type][zone]);\n\telse\n\t\tlist_add(&folio->lru, &lrugen->folios[gen][type][zone]);\n\n\treturn true;\n}\n\nstatic inline bool lru_gen_del_folio(struct lruvec *lruvec, struct folio *folio, bool reclaiming)\n{\n\tunsigned long flags;\n\tint gen = folio_lru_gen(folio);\n\n\tif (gen < 0)\n\t\treturn false;\n\n\tVM_WARN_ON_ONCE_FOLIO(folio_test_active(folio), folio);\n\tVM_WARN_ON_ONCE_FOLIO(folio_test_unevictable(folio), folio);\n\n\t \n\tflags = !reclaiming && lru_gen_is_active(lruvec, gen) ? BIT(PG_active) : 0;\n\tflags = set_mask_bits(&folio->flags, LRU_GEN_MASK, flags);\n\tgen = ((flags & LRU_GEN_MASK) >> LRU_GEN_PGOFF) - 1;\n\n\tlru_gen_update_size(lruvec, folio, gen, -1);\n\tlist_del(&folio->lru);\n\n\treturn true;\n}\n\n#else  \n\nstatic inline bool lru_gen_enabled(void)\n{\n\treturn false;\n}\n\nstatic inline bool lru_gen_in_fault(void)\n{\n\treturn false;\n}\n\nstatic inline bool lru_gen_add_folio(struct lruvec *lruvec, struct folio *folio, bool reclaiming)\n{\n\treturn false;\n}\n\nstatic inline bool lru_gen_del_folio(struct lruvec *lruvec, struct folio *folio, bool reclaiming)\n{\n\treturn false;\n}\n\n#endif  \n\nstatic __always_inline\nvoid lruvec_add_folio(struct lruvec *lruvec, struct folio *folio)\n{\n\tenum lru_list lru = folio_lru_list(folio);\n\n\tif (lru_gen_add_folio(lruvec, folio, false))\n\t\treturn;\n\n\tupdate_lru_size(lruvec, lru, folio_zonenum(folio),\n\t\t\tfolio_nr_pages(folio));\n\tif (lru != LRU_UNEVICTABLE)\n\t\tlist_add(&folio->lru, &lruvec->lists[lru]);\n}\n\nstatic __always_inline\nvoid lruvec_add_folio_tail(struct lruvec *lruvec, struct folio *folio)\n{\n\tenum lru_list lru = folio_lru_list(folio);\n\n\tif (lru_gen_add_folio(lruvec, folio, true))\n\t\treturn;\n\n\tupdate_lru_size(lruvec, lru, folio_zonenum(folio),\n\t\t\tfolio_nr_pages(folio));\n\t \n\tlist_add_tail(&folio->lru, &lruvec->lists[lru]);\n}\n\nstatic __always_inline\nvoid lruvec_del_folio(struct lruvec *lruvec, struct folio *folio)\n{\n\tenum lru_list lru = folio_lru_list(folio);\n\n\tif (lru_gen_del_folio(lruvec, folio, false))\n\t\treturn;\n\n\tif (lru != LRU_UNEVICTABLE)\n\t\tlist_del(&folio->lru);\n\tupdate_lru_size(lruvec, lru, folio_zonenum(folio),\n\t\t\t-folio_nr_pages(folio));\n}\n\n#ifdef CONFIG_ANON_VMA_NAME\n \nextern struct anon_vma_name *anon_vma_name(struct vm_area_struct *vma);\nextern struct anon_vma_name *anon_vma_name_alloc(const char *name);\nextern void anon_vma_name_free(struct kref *kref);\n\n \nstatic inline void anon_vma_name_get(struct anon_vma_name *anon_name)\n{\n\tif (anon_name)\n\t\tkref_get(&anon_name->kref);\n}\n\nstatic inline void anon_vma_name_put(struct anon_vma_name *anon_name)\n{\n\tif (anon_name)\n\t\tkref_put(&anon_name->kref, anon_vma_name_free);\n}\n\nstatic inline\nstruct anon_vma_name *anon_vma_name_reuse(struct anon_vma_name *anon_name)\n{\n\t \n\tif (kref_read(&anon_name->kref) < REFCOUNT_MAX) {\n\t\tanon_vma_name_get(anon_name);\n\t\treturn anon_name;\n\n\t}\n\treturn anon_vma_name_alloc(anon_name->name);\n}\n\nstatic inline void dup_anon_vma_name(struct vm_area_struct *orig_vma,\n\t\t\t\t     struct vm_area_struct *new_vma)\n{\n\tstruct anon_vma_name *anon_name = anon_vma_name(orig_vma);\n\n\tif (anon_name)\n\t\tnew_vma->anon_name = anon_vma_name_reuse(anon_name);\n}\n\nstatic inline void free_anon_vma_name(struct vm_area_struct *vma)\n{\n\t \n\tanon_vma_name_put(vma->anon_name);\n}\n\nstatic inline bool anon_vma_name_eq(struct anon_vma_name *anon_name1,\n\t\t\t\t    struct anon_vma_name *anon_name2)\n{\n\tif (anon_name1 == anon_name2)\n\t\treturn true;\n\n\treturn anon_name1 && anon_name2 &&\n\t\t!strcmp(anon_name1->name, anon_name2->name);\n}\n\n#else  \nstatic inline struct anon_vma_name *anon_vma_name(struct vm_area_struct *vma)\n{\n\treturn NULL;\n}\n\nstatic inline struct anon_vma_name *anon_vma_name_alloc(const char *name)\n{\n\treturn NULL;\n}\n\nstatic inline void anon_vma_name_get(struct anon_vma_name *anon_name) {}\nstatic inline void anon_vma_name_put(struct anon_vma_name *anon_name) {}\nstatic inline void dup_anon_vma_name(struct vm_area_struct *orig_vma,\n\t\t\t\t     struct vm_area_struct *new_vma) {}\nstatic inline void free_anon_vma_name(struct vm_area_struct *vma) {}\n\nstatic inline bool anon_vma_name_eq(struct anon_vma_name *anon_name1,\n\t\t\t\t    struct anon_vma_name *anon_name2)\n{\n\treturn true;\n}\n\n#endif   \n\nstatic inline void init_tlb_flush_pending(struct mm_struct *mm)\n{\n\tatomic_set(&mm->tlb_flush_pending, 0);\n}\n\nstatic inline void inc_tlb_flush_pending(struct mm_struct *mm)\n{\n\tatomic_inc(&mm->tlb_flush_pending);\n\t \n}\n\nstatic inline void dec_tlb_flush_pending(struct mm_struct *mm)\n{\n\t \n\tatomic_dec(&mm->tlb_flush_pending);\n}\n\nstatic inline bool mm_tlb_flush_pending(struct mm_struct *mm)\n{\n\t \n\treturn atomic_read(&mm->tlb_flush_pending);\n}\n\nstatic inline bool mm_tlb_flush_nested(struct mm_struct *mm)\n{\n\t \n\treturn atomic_read(&mm->tlb_flush_pending) > 1;\n}\n\n#ifdef CONFIG_MMU\n \nstatic inline pte_marker copy_pte_marker(\n\t\tswp_entry_t entry, struct vm_area_struct *dst_vma)\n{\n\tpte_marker srcm = pte_marker_get(entry);\n\t \n\tpte_marker dstm = srcm & PTE_MARKER_POISONED;\n\n\t \n\tif ((srcm & PTE_MARKER_UFFD_WP) && userfaultfd_wp(dst_vma))\n\t\tdstm |= PTE_MARKER_UFFD_WP;\n\n\treturn dstm;\n}\n#endif\n\n \nstatic inline void\npte_install_uffd_wp_if_needed(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t      pte_t *pte, pte_t pteval)\n{\n#ifdef CONFIG_PTE_MARKER_UFFD_WP\n\tbool arm_uffd_pte = false;\n\n\t \n\tWARN_ON_ONCE(!pte_none(ptep_get(pte)));\n\n\t \n\tif (vma_is_anonymous(vma) || !userfaultfd_wp(vma))\n\t\treturn;\n\n\t \n\tif (unlikely(pte_present(pteval) && pte_uffd_wp(pteval)))\n\t\tarm_uffd_pte = true;\n\n\t \n\tif (unlikely(pte_swp_uffd_wp_any(pteval)))\n\t\tarm_uffd_pte = true;\n\n\tif (unlikely(arm_uffd_pte))\n\t\tset_pte_at(vma->vm_mm, addr, pte,\n\t\t\t   make_pte_marker(PTE_MARKER_UFFD_WP));\n#endif\n}\n\nstatic inline bool vma_has_recency(struct vm_area_struct *vma)\n{\n\tif (vma->vm_flags & (VM_SEQ_READ | VM_RAND_READ))\n\t\treturn false;\n\n\tif (vma->vm_file && (vma->vm_file->f_mode & FMODE_NOREUSE))\n\t\treturn false;\n\n\treturn true;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}