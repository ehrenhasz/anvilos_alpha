{
  "module_name": "serial_core.h",
  "hash_id": "57a79decfa3fcb0e30234f7179dad00dd70fd81c5f99e9bc23655865ae9bf83b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/serial_core.h",
  "human_readable_source": " \n \n#ifndef LINUX_SERIAL_CORE_H\n#define LINUX_SERIAL_CORE_H\n\n#include <linux/bitops.h>\n#include <linux/compiler.h>\n#include <linux/console.h>\n#include <linux/interrupt.h>\n#include <linux/circ_buf.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/tty.h>\n#include <linux/mutex.h>\n#include <linux/sysrq.h>\n#include <uapi/linux/serial_core.h>\n\n#ifdef CONFIG_SERIAL_CORE_CONSOLE\n#define uart_console(port) \\\n\t((port)->cons && (port)->cons->index == (port)->line)\n#else\n#define uart_console(port)      ({ (void)port; 0; })\n#endif\n\nstruct uart_port;\nstruct serial_struct;\nstruct serial_port_device;\nstruct device;\nstruct gpio_desc;\n\n \nstruct uart_ops {\n\tunsigned int\t(*tx_empty)(struct uart_port *);\n\tvoid\t\t(*set_mctrl)(struct uart_port *, unsigned int mctrl);\n\tunsigned int\t(*get_mctrl)(struct uart_port *);\n\tvoid\t\t(*stop_tx)(struct uart_port *);\n\tvoid\t\t(*start_tx)(struct uart_port *);\n\tvoid\t\t(*throttle)(struct uart_port *);\n\tvoid\t\t(*unthrottle)(struct uart_port *);\n\tvoid\t\t(*send_xchar)(struct uart_port *, char ch);\n\tvoid\t\t(*stop_rx)(struct uart_port *);\n\tvoid\t\t(*start_rx)(struct uart_port *);\n\tvoid\t\t(*enable_ms)(struct uart_port *);\n\tvoid\t\t(*break_ctl)(struct uart_port *, int ctl);\n\tint\t\t(*startup)(struct uart_port *);\n\tvoid\t\t(*shutdown)(struct uart_port *);\n\tvoid\t\t(*flush_buffer)(struct uart_port *);\n\tvoid\t\t(*set_termios)(struct uart_port *, struct ktermios *new,\n\t\t\t\t       const struct ktermios *old);\n\tvoid\t\t(*set_ldisc)(struct uart_port *, struct ktermios *);\n\tvoid\t\t(*pm)(struct uart_port *, unsigned int state,\n\t\t\t      unsigned int oldstate);\n\tconst char\t*(*type)(struct uart_port *);\n\tvoid\t\t(*release_port)(struct uart_port *);\n\tint\t\t(*request_port)(struct uart_port *);\n\tvoid\t\t(*config_port)(struct uart_port *, int);\n\tint\t\t(*verify_port)(struct uart_port *, struct serial_struct *);\n\tint\t\t(*ioctl)(struct uart_port *, unsigned int, unsigned long);\n#ifdef CONFIG_CONSOLE_POLL\n\tint\t\t(*poll_init)(struct uart_port *);\n\tvoid\t\t(*poll_put_char)(struct uart_port *, unsigned char);\n\tint\t\t(*poll_get_char)(struct uart_port *);\n#endif\n};\n\n#define NO_POLL_CHAR\t\t0x00ff0000\n#define UART_CONFIG_TYPE\t(1 << 0)\n#define UART_CONFIG_IRQ\t\t(1 << 1)\n\nstruct uart_icount {\n\t__u32\tcts;\n\t__u32\tdsr;\n\t__u32\trng;\n\t__u32\tdcd;\n\t__u32\trx;\n\t__u32\ttx;\n\t__u32\tframe;\n\t__u32\toverrun;\n\t__u32\tparity;\n\t__u32\tbrk;\n\t__u32\tbuf_overrun;\n};\n\ntypedef u64 __bitwise upf_t;\ntypedef unsigned int __bitwise upstat_t;\n\nstruct uart_port {\n\tspinlock_t\t\tlock;\t\t\t \n\tunsigned long\t\tiobase;\t\t\t \n\tunsigned char __iomem\t*membase;\t\t \n\tunsigned int\t\t(*serial_in)(struct uart_port *, int);\n\tvoid\t\t\t(*serial_out)(struct uart_port *, int, int);\n\tvoid\t\t\t(*set_termios)(struct uart_port *,\n\t\t\t\t               struct ktermios *new,\n\t\t\t\t               const struct ktermios *old);\n\tvoid\t\t\t(*set_ldisc)(struct uart_port *,\n\t\t\t\t\t     struct ktermios *);\n\tunsigned int\t\t(*get_mctrl)(struct uart_port *);\n\tvoid\t\t\t(*set_mctrl)(struct uart_port *, unsigned int);\n\tunsigned int\t\t(*get_divisor)(struct uart_port *,\n\t\t\t\t\t       unsigned int baud,\n\t\t\t\t\t       unsigned int *frac);\n\tvoid\t\t\t(*set_divisor)(struct uart_port *,\n\t\t\t\t\t       unsigned int baud,\n\t\t\t\t\t       unsigned int quot,\n\t\t\t\t\t       unsigned int quot_frac);\n\tint\t\t\t(*startup)(struct uart_port *port);\n\tvoid\t\t\t(*shutdown)(struct uart_port *port);\n\tvoid\t\t\t(*throttle)(struct uart_port *port);\n\tvoid\t\t\t(*unthrottle)(struct uart_port *port);\n\tint\t\t\t(*handle_irq)(struct uart_port *);\n\tvoid\t\t\t(*pm)(struct uart_port *, unsigned int state,\n\t\t\t\t      unsigned int old);\n\tvoid\t\t\t(*handle_break)(struct uart_port *);\n\tint\t\t\t(*rs485_config)(struct uart_port *,\n\t\t\t\t\t\tstruct ktermios *termios,\n\t\t\t\t\t\tstruct serial_rs485 *rs485);\n\tint\t\t\t(*iso7816_config)(struct uart_port *,\n\t\t\t\t\t\t  struct serial_iso7816 *iso7816);\n\tunsigned int\t\tctrl_id;\t\t \n\tunsigned int\t\tport_id;\t\t \n\tunsigned int\t\tirq;\t\t\t \n\tunsigned long\t\tirqflags;\t\t \n\tunsigned int\t\tuartclk;\t\t \n\tunsigned int\t\tfifosize;\t\t \n\tunsigned char\t\tx_char;\t\t\t \n\tunsigned char\t\tregshift;\t\t \n\tunsigned char\t\tiotype;\t\t\t \n\tunsigned char\t\tquirks;\t\t\t \n\n#define UPIO_PORT\t\t(SERIAL_IO_PORT)\t \n#define UPIO_HUB6\t\t(SERIAL_IO_HUB6)\t \n#define UPIO_MEM\t\t(SERIAL_IO_MEM)\t\t \n#define UPIO_MEM32\t\t(SERIAL_IO_MEM32)\t \n#define UPIO_AU\t\t\t(SERIAL_IO_AU)\t\t \n#define UPIO_TSI\t\t(SERIAL_IO_TSI)\t\t \n#define UPIO_MEM32BE\t\t(SERIAL_IO_MEM32BE)\t \n#define UPIO_MEM16\t\t(SERIAL_IO_MEM16)\t \n\n\t \n#define UPQ_NO_TXEN_TEST\tBIT(0)\n\n\tunsigned int\t\tread_status_mask;\t \n\tunsigned int\t\tignore_status_mask;\t \n\tstruct uart_state\t*state;\t\t\t \n\tstruct uart_icount\ticount;\t\t\t \n\n\tstruct console\t\t*cons;\t\t\t \n\t \n\tupf_t\t\t\tflags;\n\n\t \n#define UPF_FOURPORT\t\t((__force upf_t) ASYNC_FOURPORT         )\n#define UPF_SAK\t\t\t((__force upf_t) ASYNC_SAK              )\n#define UPF_SPD_HI\t\t((__force upf_t) ASYNC_SPD_HI           )\n#define UPF_SPD_VHI\t\t((__force upf_t) ASYNC_SPD_VHI          )\n#define UPF_SPD_CUST\t\t((__force upf_t) ASYNC_SPD_CUST     )\n#define UPF_SPD_WARP\t\t((__force upf_t) ASYNC_SPD_WARP     )\n#define UPF_SPD_MASK\t\t((__force upf_t) ASYNC_SPD_MASK     )\n#define UPF_SKIP_TEST\t\t((__force upf_t) ASYNC_SKIP_TEST        )\n#define UPF_AUTO_IRQ\t\t((__force upf_t) ASYNC_AUTO_IRQ         )\n#define UPF_HARDPPS_CD\t\t((__force upf_t) ASYNC_HARDPPS_CD       )\n#define UPF_SPD_SHI\t\t((__force upf_t) ASYNC_SPD_SHI          )\n#define UPF_LOW_LATENCY\t\t((__force upf_t) ASYNC_LOW_LATENCY      )\n#define UPF_BUGGY_UART\t\t((__force upf_t) ASYNC_BUGGY_UART       )\n#define UPF_MAGIC_MULTIPLIER\t((__force upf_t) ASYNC_MAGIC_MULTIPLIER   )\n\n#define UPF_NO_THRE_TEST\t((__force upf_t) BIT_ULL(19))\n \n#define UPF_AUTO_CTS\t\t((__force upf_t) BIT_ULL(20))\n#define UPF_AUTO_RTS\t\t((__force upf_t) BIT_ULL(21))\n#define UPF_HARD_FLOW\t\t((__force upf_t) (UPF_AUTO_CTS | UPF_AUTO_RTS))\n \n#define UPF_SOFT_FLOW\t\t((__force upf_t) BIT_ULL(22))\n#define UPF_CONS_FLOW\t\t((__force upf_t) BIT_ULL(23))\n#define UPF_SHARE_IRQ\t\t((__force upf_t) BIT_ULL(24))\n#define UPF_EXAR_EFR\t\t((__force upf_t) BIT_ULL(25))\n#define UPF_BUG_THRE\t\t((__force upf_t) BIT_ULL(26))\n \n#define UPF_FIXED_TYPE\t\t((__force upf_t) BIT_ULL(27))\n#define UPF_BOOT_AUTOCONF\t((__force upf_t) BIT_ULL(28))\n#define UPF_FIXED_PORT\t\t((__force upf_t) BIT_ULL(29))\n#define UPF_DEAD\t\t((__force upf_t) BIT_ULL(30))\n#define UPF_IOREMAP\t\t((__force upf_t) BIT_ULL(31))\n#define UPF_FULL_PROBE\t\t((__force upf_t) BIT_ULL(32))\n\n#define __UPF_CHANGE_MASK\t0x17fff\n#define UPF_CHANGE_MASK\t\t((__force upf_t) __UPF_CHANGE_MASK)\n#define UPF_USR_MASK\t\t((__force upf_t) (UPF_SPD_MASK|UPF_LOW_LATENCY))\n\n#if __UPF_CHANGE_MASK > ASYNC_FLAGS\n#error Change mask not equivalent to userspace-visible bit defines\n#endif\n\n\t \n\tupstat_t\t\tstatus;\n\n#define UPSTAT_CTS_ENABLE\t((__force upstat_t) (1 << 0))\n#define UPSTAT_DCD_ENABLE\t((__force upstat_t) (1 << 1))\n#define UPSTAT_AUTORTS\t\t((__force upstat_t) (1 << 2))\n#define UPSTAT_AUTOCTS\t\t((__force upstat_t) (1 << 3))\n#define UPSTAT_AUTOXOFF\t\t((__force upstat_t) (1 << 4))\n#define UPSTAT_SYNC_FIFO\t((__force upstat_t) (1 << 5))\n\n\tbool\t\t\thw_stopped;\t\t \n\tunsigned int\t\tmctrl;\t\t\t \n\tunsigned int\t\tframe_time;\t\t \n\tunsigned int\t\ttype;\t\t\t \n\tconst struct uart_ops\t*ops;\n\tunsigned int\t\tcustom_divisor;\n\tunsigned int\t\tline;\t\t\t \n\tunsigned int\t\tminor;\n\tresource_size_t\t\tmapbase;\t\t \n\tresource_size_t\t\tmapsize;\n\tstruct device\t\t*dev;\t\t\t \n\tstruct serial_port_device *port_dev;\t\t \n\n\tunsigned long\t\tsysrq;\t\t\t \n\tu8\t\t\tsysrq_ch;\t\t \n\tunsigned char\t\thas_sysrq;\n\tunsigned char\t\tsysrq_seq;\t\t \n\n\tunsigned char\t\thub6;\t\t\t \n\tunsigned char\t\tsuspended;\n\tunsigned char\t\tconsole_reinit;\n\tconst char\t\t*name;\t\t\t \n\tstruct attribute_group\t*attr_group;\t\t \n\tconst struct attribute_group **tty_groups;\t \n\tstruct serial_rs485     rs485;\n\tstruct serial_rs485\trs485_supported;\t \n\tstruct gpio_desc\t*rs485_term_gpio;\t \n\tstruct gpio_desc\t*rs485_rx_during_tx_gpio;  \n\tstruct serial_iso7816   iso7816;\n\tvoid\t\t\t*private_data;\t\t \n};\n\nstatic inline int serial_port_in(struct uart_port *up, int offset)\n{\n\treturn up->serial_in(up, offset);\n}\n\nstatic inline void serial_port_out(struct uart_port *up, int offset, int value)\n{\n\tup->serial_out(up, offset, value);\n}\n\n \nenum uart_pm_state {\n\tUART_PM_STATE_ON = 0,\n\tUART_PM_STATE_OFF = 3,  \n\tUART_PM_STATE_UNDEFINED,\n};\n\n \nstruct uart_state {\n\tstruct tty_port\t\tport;\n\n\tenum uart_pm_state\tpm_state;\n\tstruct circ_buf\t\txmit;\n\n\tatomic_t\t\trefcount;\n\twait_queue_head_t\tremove_wait;\n\tstruct uart_port\t*uart_port;\n};\n\n#define UART_XMIT_SIZE\tPAGE_SIZE\n\n\n \n#define WAKEUP_CHARS\t\t256\n\n \nstatic inline void uart_xmit_advance(struct uart_port *up, unsigned int chars)\n{\n\tstruct circ_buf *xmit = &up->state->xmit;\n\n\txmit->tail = (xmit->tail + chars) & (UART_XMIT_SIZE - 1);\n\tup->icount.tx += chars;\n}\n\nstruct module;\nstruct tty_driver;\n\nstruct uart_driver {\n\tstruct module\t\t*owner;\n\tconst char\t\t*driver_name;\n\tconst char\t\t*dev_name;\n\tint\t\t\t major;\n\tint\t\t\t minor;\n\tint\t\t\t nr;\n\tstruct console\t\t*cons;\n\n\t \n\tstruct uart_state\t*state;\n\tstruct tty_driver\t*tty_driver;\n};\n\nvoid uart_write_wakeup(struct uart_port *port);\n\n#define __uart_port_tx(uport, ch, tx_ready, put_char, tx_done, for_test,      \\\n\t\tfor_post)\t\t\t\t\t\t      \\\n({\t\t\t\t\t\t\t\t\t      \\\n\tstruct uart_port *__port = (uport);\t\t\t\t      \\\n\tstruct circ_buf *xmit = &__port->state->xmit;\t\t\t      \\\n\tunsigned int pending;\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tfor (; (for_test) && (tx_ready); (for_post), __port->icount.tx++) {   \\\n\t\tif (__port->x_char) {\t\t\t\t\t      \\\n\t\t\t(ch) = __port->x_char;\t\t\t\t      \\\n\t\t\t(put_char);\t\t\t\t\t      \\\n\t\t\t__port->x_char = 0;\t\t\t\t      \\\n\t\t\tcontinue;\t\t\t\t\t      \\\n\t\t}\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\t\tif (uart_circ_empty(xmit) || uart_tx_stopped(__port))\t      \\\n\t\t\tbreak;\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\t\t(ch) = xmit->buf[xmit->tail];\t\t\t\t      \\\n\t\t(put_char);\t\t\t\t\t\t      \\\n\t\txmit->tail = (xmit->tail + 1) % UART_XMIT_SIZE;\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\t(tx_done);\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tpending = uart_circ_chars_pending(xmit);\t\t\t      \\\n\tif (pending < WAKEUP_CHARS) {\t\t\t\t\t      \\\n\t\tuart_write_wakeup(__port);\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\t\tif (pending == 0)\t\t\t\t\t      \\\n\t\t\t__port->ops->stop_tx(__port);\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tpending;\t\t\t\t\t\t\t      \\\n})\n\n \n#define uart_port_tx_limited(port, ch, count, tx_ready, put_char, tx_done) ({ \\\n\tunsigned int __count = (count);\t\t\t\t\t      \\\n\t__uart_port_tx(port, ch, tx_ready, put_char, tx_done, __count,\t      \\\n\t\t\t__count--);\t\t\t\t\t      \\\n})\n\n \n#define uart_port_tx(port, ch, tx_ready, put_char)\t\t\t\\\n\t__uart_port_tx(port, ch, tx_ready, put_char, ({}), true, ({}))\n\n \nvoid uart_update_timeout(struct uart_port *port, unsigned int cflag,\n\t\t\t unsigned int baud);\nunsigned int uart_get_baud_rate(struct uart_port *port, struct ktermios *termios,\n\t\t\t\tconst struct ktermios *old, unsigned int min,\n\t\t\t\tunsigned int max);\nunsigned int uart_get_divisor(struct uart_port *port, unsigned int baud);\n\n \nstatic inline unsigned long uart_fifo_timeout(struct uart_port *port)\n{\n\tu64 fifo_timeout = (u64)READ_ONCE(port->frame_time) * port->fifosize;\n\n\t \n\tfifo_timeout += 20 * NSEC_PER_MSEC;\n\n\treturn max(nsecs_to_jiffies(fifo_timeout), 1UL);\n}\n\n \nstatic inline int uart_poll_timeout(struct uart_port *port)\n{\n\tint timeout = uart_fifo_timeout(port);\n\n\treturn timeout > 6 ? (timeout / 2 - 2) : 1;\n}\n\n \nstruct earlycon_device {\n\tstruct console *con;\n\tstruct uart_port port;\n\tchar options[32];\t\t \n\tunsigned int baud;\n};\n\nstruct earlycon_id {\n\tchar\tname[15];\n\tchar\tname_term;\t \n\tchar\tcompatible[128];\n\tint\t(*setup)(struct earlycon_device *, const char *options);\n};\n\nextern const struct earlycon_id __earlycon_table[];\nextern const struct earlycon_id __earlycon_table_end[];\n\n#if defined(CONFIG_SERIAL_EARLYCON) && !defined(MODULE)\n#define EARLYCON_USED_OR_UNUSED\t__used\n#else\n#define EARLYCON_USED_OR_UNUSED\t__maybe_unused\n#endif\n\n#define OF_EARLYCON_DECLARE(_name, compat, fn)\t\t\t\t\\\n\tstatic const struct earlycon_id __UNIQUE_ID(__earlycon_##_name) \\\n\t\tEARLYCON_USED_OR_UNUSED  __section(\"__earlycon_table\")  \\\n\t\t__aligned(__alignof__(struct earlycon_id))\t\t\\\n\t\t= { .name = __stringify(_name),\t\t\t\t\\\n\t\t    .compatible = compat,\t\t\t\t\\\n\t\t    .setup = fn }\n\n#define EARLYCON_DECLARE(_name, fn)\tOF_EARLYCON_DECLARE(_name, \"\", fn)\n\nint of_setup_earlycon(const struct earlycon_id *match, unsigned long node,\n\t\t      const char *options);\n\n#ifdef CONFIG_SERIAL_EARLYCON\nextern bool earlycon_acpi_spcr_enable __initdata;\nint setup_earlycon(char *buf);\n#else\nstatic const bool earlycon_acpi_spcr_enable EARLYCON_USED_OR_UNUSED;\nstatic inline int setup_earlycon(char *buf) { return 0; }\n#endif\n\n \nstatic inline bool uart_console_registered_locked(struct uart_port *port)\n{\n\treturn uart_console(port) && console_is_registered_locked(port->cons);\n}\n\nstatic inline bool uart_console_registered(struct uart_port *port)\n{\n\treturn uart_console(port) && console_is_registered(port->cons);\n}\n\nstruct uart_port *uart_get_console(struct uart_port *ports, int nr,\n\t\t\t\t   struct console *c);\nint uart_parse_earlycon(char *p, unsigned char *iotype, resource_size_t *addr,\n\t\t\tchar **options);\nvoid uart_parse_options(const char *options, int *baud, int *parity, int *bits,\n\t\t\tint *flow);\nint uart_set_options(struct uart_port *port, struct console *co, int baud,\n\t\t     int parity, int bits, int flow);\nstruct tty_driver *uart_console_device(struct console *co, int *index);\nvoid uart_console_write(struct uart_port *port, const char *s,\n\t\t\tunsigned int count,\n\t\t\tvoid (*putchar)(struct uart_port *, unsigned char));\n\n \nint uart_register_driver(struct uart_driver *uart);\nvoid uart_unregister_driver(struct uart_driver *uart);\nint uart_add_one_port(struct uart_driver *reg, struct uart_port *port);\nvoid uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);\nbool uart_match_port(const struct uart_port *port1,\n\t\tconst struct uart_port *port2);\n\n \nint uart_suspend_port(struct uart_driver *reg, struct uart_port *port);\nint uart_resume_port(struct uart_driver *reg, struct uart_port *port);\n\n#define uart_circ_empty(circ)\t\t((circ)->head == (circ)->tail)\n#define uart_circ_clear(circ)\t\t((circ)->head = (circ)->tail = 0)\n\n#define uart_circ_chars_pending(circ)\t\\\n\t(CIRC_CNT((circ)->head, (circ)->tail, UART_XMIT_SIZE))\n\n#define uart_circ_chars_free(circ)\t\\\n\t(CIRC_SPACE((circ)->head, (circ)->tail, UART_XMIT_SIZE))\n\nstatic inline int uart_tx_stopped(struct uart_port *port)\n{\n\tstruct tty_struct *tty = port->state->port.tty;\n\tif ((tty && tty->flow.stopped) || port->hw_stopped)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline bool uart_cts_enabled(struct uart_port *uport)\n{\n\treturn !!(uport->status & UPSTAT_CTS_ENABLE);\n}\n\nstatic inline bool uart_softcts_mode(struct uart_port *uport)\n{\n\tupstat_t mask = UPSTAT_CTS_ENABLE | UPSTAT_AUTOCTS;\n\n\treturn ((uport->status & mask) == UPSTAT_CTS_ENABLE);\n}\n\n \n\nvoid uart_handle_dcd_change(struct uart_port *uport, bool active);\nvoid uart_handle_cts_change(struct uart_port *uport, bool active);\n\nvoid uart_insert_char(struct uart_port *port, unsigned int status,\n\t\t      unsigned int overrun, u8 ch, u8 flag);\n\nvoid uart_xchar_out(struct uart_port *uport, int offset);\n\n#ifdef CONFIG_MAGIC_SYSRQ_SERIAL\n#define SYSRQ_TIMEOUT\t(HZ * 5)\n\nbool uart_try_toggle_sysrq(struct uart_port *port, u8 ch);\n\nstatic inline int uart_handle_sysrq_char(struct uart_port *port, u8 ch)\n{\n\tif (!port->sysrq)\n\t\treturn 0;\n\n\tif (ch && time_before(jiffies, port->sysrq)) {\n\t\tif (sysrq_mask()) {\n\t\t\thandle_sysrq(ch);\n\t\t\tport->sysrq = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif (uart_try_toggle_sysrq(port, ch))\n\t\t\treturn 1;\n\t}\n\tport->sysrq = 0;\n\n\treturn 0;\n}\n\nstatic inline int uart_prepare_sysrq_char(struct uart_port *port, u8 ch)\n{\n\tif (!port->sysrq)\n\t\treturn 0;\n\n\tif (ch && time_before(jiffies, port->sysrq)) {\n\t\tif (sysrq_mask()) {\n\t\t\tport->sysrq_ch = ch;\n\t\t\tport->sysrq = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif (uart_try_toggle_sysrq(port, ch))\n\t\t\treturn 1;\n\t}\n\tport->sysrq = 0;\n\n\treturn 0;\n}\n\nstatic inline void uart_unlock_and_check_sysrq(struct uart_port *port)\n{\n\tu8 sysrq_ch;\n\n\tif (!port->has_sysrq) {\n\t\tspin_unlock(&port->lock);\n\t\treturn;\n\t}\n\n\tsysrq_ch = port->sysrq_ch;\n\tport->sysrq_ch = 0;\n\n\tspin_unlock(&port->lock);\n\n\tif (sysrq_ch)\n\t\thandle_sysrq(sysrq_ch);\n}\n\nstatic inline void uart_unlock_and_check_sysrq_irqrestore(struct uart_port *port,\n\t\tunsigned long flags)\n{\n\tu8 sysrq_ch;\n\n\tif (!port->has_sysrq) {\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\treturn;\n\t}\n\n\tsysrq_ch = port->sysrq_ch;\n\tport->sysrq_ch = 0;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (sysrq_ch)\n\t\thandle_sysrq(sysrq_ch);\n}\n#else\t \nstatic inline int uart_handle_sysrq_char(struct uart_port *port, u8 ch)\n{\n\treturn 0;\n}\nstatic inline int uart_prepare_sysrq_char(struct uart_port *port, u8 ch)\n{\n\treturn 0;\n}\nstatic inline void uart_unlock_and_check_sysrq(struct uart_port *port)\n{\n\tspin_unlock(&port->lock);\n}\nstatic inline void uart_unlock_and_check_sysrq_irqrestore(struct uart_port *port,\n\t\tunsigned long flags)\n{\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n#endif\t \n\n \nstatic inline int uart_handle_break(struct uart_port *port)\n{\n\tstruct uart_state *state = port->state;\n\n\tif (port->handle_break)\n\t\tport->handle_break(port);\n\n#ifdef CONFIG_MAGIC_SYSRQ_SERIAL\n\tif (port->has_sysrq && uart_console(port)) {\n\t\tif (!port->sysrq) {\n\t\t\tport->sysrq = jiffies + SYSRQ_TIMEOUT;\n\t\t\treturn 1;\n\t\t}\n\t\tport->sysrq = 0;\n\t}\n#endif\n\tif (port->flags & UPF_SAK)\n\t\tdo_SAK(state->port.tty);\n\treturn 0;\n}\n\n \n#define UART_ENABLE_MS(port,cflag)\t((port)->flags & UPF_HARDPPS_CD || \\\n\t\t\t\t\t (cflag) & CRTSCTS || \\\n\t\t\t\t\t !((cflag) & CLOCAL))\n\nint uart_get_rs485_mode(struct uart_port *port);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}