{
  "module_name": "percpu-rwsem.h",
  "hash_id": "9468b573a7659d5680d850e5b38cb91467e8dd21a5eaa58547452d8790aa34d9",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/percpu-rwsem.h",
  "human_readable_source": " \n#ifndef _LINUX_PERCPU_RWSEM_H\n#define _LINUX_PERCPU_RWSEM_H\n\n#include <linux/atomic.h>\n#include <linux/percpu.h>\n#include <linux/rcuwait.h>\n#include <linux/wait.h>\n#include <linux/rcu_sync.h>\n#include <linux/lockdep.h>\n\nstruct percpu_rw_semaphore {\n\tstruct rcu_sync\t\trss;\n\tunsigned int __percpu\t*read_count;\n\tstruct rcuwait\t\twriter;\n\twait_queue_head_t\twaiters;\n\tatomic_t\t\tblock;\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tstruct lockdep_map\tdep_map;\n#endif\n};\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n#define __PERCPU_RWSEM_DEP_MAP_INIT(lockname)\t.dep_map = { .name = #lockname },\n#else\n#define __PERCPU_RWSEM_DEP_MAP_INIT(lockname)\n#endif\n\n#define __DEFINE_PERCPU_RWSEM(name, is_static)\t\t\t\t\\\nstatic DEFINE_PER_CPU(unsigned int, __percpu_rwsem_rc_##name);\t\t\\\nis_static struct percpu_rw_semaphore name = {\t\t\t\t\\\n\t.rss = __RCU_SYNC_INITIALIZER(name.rss),\t\t\t\\\n\t.read_count = &__percpu_rwsem_rc_##name,\t\t\t\\\n\t.writer = __RCUWAIT_INITIALIZER(name.writer),\t\t\t\\\n\t.waiters = __WAIT_QUEUE_HEAD_INITIALIZER(name.waiters),\t\t\\\n\t.block = ATOMIC_INIT(0),\t\t\t\t\t\\\n\t__PERCPU_RWSEM_DEP_MAP_INIT(name)\t\t\t\t\\\n}\n\n#define DEFINE_PERCPU_RWSEM(name)\t\t\\\n\t__DEFINE_PERCPU_RWSEM(name,  )\n#define DEFINE_STATIC_PERCPU_RWSEM(name)\t\\\n\t__DEFINE_PERCPU_RWSEM(name, static)\n\nextern bool __percpu_down_read(struct percpu_rw_semaphore *, bool);\n\nstatic inline void percpu_down_read(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\trwsem_acquire_read(&sem->dep_map, 0, 0, _RET_IP_);\n\n\tpreempt_disable();\n\t \n\tif (likely(rcu_sync_is_idle(&sem->rss)))\n\t\tthis_cpu_inc(*sem->read_count);\n\telse\n\t\t__percpu_down_read(sem, false);  \n\t \n\tpreempt_enable();\n}\n\nstatic inline bool percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tbool ret = true;\n\n\tpreempt_disable();\n\t \n\tif (likely(rcu_sync_is_idle(&sem->rss)))\n\t\tthis_cpu_inc(*sem->read_count);\n\telse\n\t\tret = __percpu_down_read(sem, true);  \n\tpreempt_enable();\n\t \n\n\tif (ret)\n\t\trwsem_acquire_read(&sem->dep_map, 0, 1, _RET_IP_);\n\n\treturn ret;\n}\n\nstatic inline void percpu_up_read(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\tpreempt_disable();\n\t \n\tif (likely(rcu_sync_is_idle(&sem->rss))) {\n\t\tthis_cpu_dec(*sem->read_count);\n\t} else {\n\t\t \n\t\tsmp_mb();  \n\t\t \n\t\tthis_cpu_dec(*sem->read_count);\n\t\trcuwait_wake_up(&sem->writer);\n\t}\n\tpreempt_enable();\n}\n\nextern bool percpu_is_read_locked(struct percpu_rw_semaphore *);\nextern void percpu_down_write(struct percpu_rw_semaphore *);\nextern void percpu_up_write(struct percpu_rw_semaphore *);\n\nstatic inline bool percpu_is_write_locked(struct percpu_rw_semaphore *sem)\n{\n\treturn atomic_read(&sem->block);\n}\n\nextern int __percpu_init_rwsem(struct percpu_rw_semaphore *,\n\t\t\t\tconst char *, struct lock_class_key *);\n\nextern void percpu_free_rwsem(struct percpu_rw_semaphore *);\n\n#define percpu_init_rwsem(sem)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key rwsem_key;\t\t\t\\\n\t__percpu_init_rwsem(sem, #sem, &rwsem_key);\t\t\\\n})\n\n#define percpu_rwsem_is_held(sem)\tlockdep_is_held(sem)\n#define percpu_rwsem_assert_held(sem)\tlockdep_assert_held(sem)\n\nstatic inline void percpu_rwsem_release(struct percpu_rw_semaphore *sem,\n\t\t\t\t\tbool read, unsigned long ip)\n{\n\tlock_release(&sem->dep_map, ip);\n}\n\nstatic inline void percpu_rwsem_acquire(struct percpu_rw_semaphore *sem,\n\t\t\t\t\tbool read, unsigned long ip)\n{\n\tlock_acquire(&sem->dep_map, 0, 1, read, 1, NULL, ip);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}