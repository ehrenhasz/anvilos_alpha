{
  "module_name": "topology.h",
  "hash_id": "bc5e40704c84158eec81609f5562af8f89a62378cc42c12498643ff39c82a2ae",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/topology.h",
  "human_readable_source": " \n#ifndef _LINUX_TOPOLOGY_H\n#define _LINUX_TOPOLOGY_H\n\n#include <linux/arch_topology.h>\n#include <linux/cpumask.h>\n#include <linux/bitops.h>\n#include <linux/mmzone.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <asm/topology.h>\n\n#ifndef nr_cpus_node\n#define nr_cpus_node(node) cpumask_weight(cpumask_of_node(node))\n#endif\n\n#define for_each_node_with_cpus(node)\t\t\t\\\n\tfor_each_online_node(node)\t\t\t\\\n\t\tif (nr_cpus_node(node))\n\nint arch_update_cpu_topology(void);\n\n \n#define LOCAL_DISTANCE\t\t10\n#define REMOTE_DISTANCE\t\t20\n#define DISTANCE_BITS           8\n#ifndef node_distance\n#define node_distance(from,to)\t((from) == (to) ? LOCAL_DISTANCE : REMOTE_DISTANCE)\n#endif\n#ifndef RECLAIM_DISTANCE\n \n#define RECLAIM_DISTANCE 30\n#endif\n\n \nextern int __read_mostly node_reclaim_distance;\n\n#ifndef PENALTY_FOR_NODE_WITH_CPUS\n#define PENALTY_FOR_NODE_WITH_CPUS\t(1)\n#endif\n\n#ifdef CONFIG_USE_PERCPU_NUMA_NODE_ID\nDECLARE_PER_CPU(int, numa_node);\n\n#ifndef numa_node_id\n \nstatic inline int numa_node_id(void)\n{\n\treturn raw_cpu_read(numa_node);\n}\n#endif\n\n#ifndef cpu_to_node\nstatic inline int cpu_to_node(int cpu)\n{\n\treturn per_cpu(numa_node, cpu);\n}\n#endif\n\n#ifndef set_numa_node\nstatic inline void set_numa_node(int node)\n{\n\tthis_cpu_write(numa_node, node);\n}\n#endif\n\n#ifndef set_cpu_numa_node\nstatic inline void set_cpu_numa_node(int cpu, int node)\n{\n\tper_cpu(numa_node, cpu) = node;\n}\n#endif\n\n#else\t \n\n \n#ifndef numa_node_id\nstatic inline int numa_node_id(void)\n{\n\treturn cpu_to_node(raw_smp_processor_id());\n}\n#endif\n\n#endif\t \n\n#ifdef CONFIG_HAVE_MEMORYLESS_NODES\n\n \nDECLARE_PER_CPU(int, _numa_mem_);\n\n#ifndef set_numa_mem\nstatic inline void set_numa_mem(int node)\n{\n\tthis_cpu_write(_numa_mem_, node);\n}\n#endif\n\n#ifndef numa_mem_id\n \nstatic inline int numa_mem_id(void)\n{\n\treturn raw_cpu_read(_numa_mem_);\n}\n#endif\n\n#ifndef cpu_to_mem\nstatic inline int cpu_to_mem(int cpu)\n{\n\treturn per_cpu(_numa_mem_, cpu);\n}\n#endif\n\n#ifndef set_cpu_numa_mem\nstatic inline void set_cpu_numa_mem(int cpu, int node)\n{\n\tper_cpu(_numa_mem_, cpu) = node;\n}\n#endif\n\n#else\t \n\n#ifndef numa_mem_id\n \nstatic inline int numa_mem_id(void)\n{\n\treturn numa_node_id();\n}\n#endif\n\n#ifndef cpu_to_mem\nstatic inline int cpu_to_mem(int cpu)\n{\n\treturn cpu_to_node(cpu);\n}\n#endif\n\n#endif\t \n\n#if defined(topology_die_id) && defined(topology_die_cpumask)\n#define TOPOLOGY_DIE_SYSFS\n#endif\n#if defined(topology_cluster_id) && defined(topology_cluster_cpumask)\n#define TOPOLOGY_CLUSTER_SYSFS\n#endif\n#if defined(topology_book_id) && defined(topology_book_cpumask)\n#define TOPOLOGY_BOOK_SYSFS\n#endif\n#if defined(topology_drawer_id) && defined(topology_drawer_cpumask)\n#define TOPOLOGY_DRAWER_SYSFS\n#endif\n\n#ifndef topology_physical_package_id\n#define topology_physical_package_id(cpu)\t((void)(cpu), -1)\n#endif\n#ifndef topology_die_id\n#define topology_die_id(cpu)\t\t\t((void)(cpu), -1)\n#endif\n#ifndef topology_cluster_id\n#define topology_cluster_id(cpu)\t\t((void)(cpu), -1)\n#endif\n#ifndef topology_core_id\n#define topology_core_id(cpu)\t\t\t((void)(cpu), 0)\n#endif\n#ifndef topology_book_id\n#define topology_book_id(cpu)\t\t\t((void)(cpu), -1)\n#endif\n#ifndef topology_drawer_id\n#define topology_drawer_id(cpu)\t\t\t((void)(cpu), -1)\n#endif\n#ifndef topology_ppin\n#define topology_ppin(cpu)\t\t\t((void)(cpu), 0ull)\n#endif\n#ifndef topology_sibling_cpumask\n#define topology_sibling_cpumask(cpu)\t\tcpumask_of(cpu)\n#endif\n#ifndef topology_core_cpumask\n#define topology_core_cpumask(cpu)\t\tcpumask_of(cpu)\n#endif\n#ifndef topology_cluster_cpumask\n#define topology_cluster_cpumask(cpu)\t\tcpumask_of(cpu)\n#endif\n#ifndef topology_die_cpumask\n#define topology_die_cpumask(cpu)\t\tcpumask_of(cpu)\n#endif\n#ifndef topology_book_cpumask\n#define topology_book_cpumask(cpu)\t\tcpumask_of(cpu)\n#endif\n#ifndef topology_drawer_cpumask\n#define topology_drawer_cpumask(cpu)\t\tcpumask_of(cpu)\n#endif\n\n#if defined(CONFIG_SCHED_SMT) && !defined(cpu_smt_mask)\nstatic inline const struct cpumask *cpu_smt_mask(int cpu)\n{\n\treturn topology_sibling_cpumask(cpu);\n}\n#endif\n\nstatic inline const struct cpumask *cpu_cpu_mask(int cpu)\n{\n\treturn cpumask_of_node(cpu_to_node(cpu));\n}\n\n#ifdef CONFIG_NUMA\nint sched_numa_find_nth_cpu(const struct cpumask *cpus, int cpu, int node);\nextern const struct cpumask *sched_numa_hop_mask(unsigned int node, unsigned int hops);\n#else\nstatic __always_inline int sched_numa_find_nth_cpu(const struct cpumask *cpus, int cpu, int node)\n{\n\treturn cpumask_nth_and(cpu, cpus, cpu_online_mask);\n}\n\nstatic inline const struct cpumask *\nsched_numa_hop_mask(unsigned int node, unsigned int hops)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n#endif\t \n\n \n#define for_each_numa_hop_mask(mask, node)\t\t\t\t       \\\n\tfor (unsigned int __hops = 0;\t\t\t\t\t       \\\n\t     mask = (node != NUMA_NO_NODE || __hops) ?\t\t\t       \\\n\t\t     sched_numa_hop_mask(node, __hops) :\t\t       \\\n\t\t     cpu_online_mask,\t\t\t\t\t       \\\n\t     !IS_ERR_OR_NULL(mask);\t\t\t\t\t       \\\n\t     __hops++)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}