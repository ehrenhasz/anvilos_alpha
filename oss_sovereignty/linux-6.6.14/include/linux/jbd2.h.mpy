{
  "module_name": "jbd2.h",
  "hash_id": "ed86a7cc0852cfa9e89e877f7a24f00767339927f98be82ae04fa2029b14df50",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/jbd2.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_JBD2_H\n#define _LINUX_JBD2_H\n\n \n#ifndef __KERNEL__\n#include \"jfs_compat.h\"\n#define JBD2_DEBUG\n#else\n\n#include <linux/types.h>\n#include <linux/buffer_head.h>\n#include <linux/journal-head.h>\n#include <linux/stddef.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/blkdev.h>\n#include <crypto/hash.h>\n#endif\n\n#define journal_oom_retry 1\n\n \n#undef JBD2_PARANOID_IOFAIL\n\n \n#define JBD2_DEFAULT_MAX_COMMIT_AGE 5\n\n#ifdef CONFIG_JBD2_DEBUG\n \n#define JBD2_EXPENSIVE_CHECKING\nvoid __jbd2_debug(int level, const char *file, const char *func,\n\t\t  unsigned int line, const char *fmt, ...);\n\n#define jbd2_debug(n, fmt, a...) \\\n\t__jbd2_debug((n), __FILE__, __func__, __LINE__, (fmt), ##a)\n#else\n#define jbd2_debug(n, fmt, a...)  no_printk(fmt, ##a)\n#endif\n\nextern void *jbd2_alloc(size_t size, gfp_t flags);\nextern void jbd2_free(void *ptr, size_t size);\n\n#define JBD2_MIN_JOURNAL_BLOCKS 1024\n#define JBD2_DEFAULT_FAST_COMMIT_BLOCKS 256\n\n#ifdef __KERNEL__\n\n \ntypedef struct jbd2_journal_handle handle_t;\t \n\n\n \ntypedef struct journal_s\tjournal_t;\t \n#endif\n\n \n\n#define JBD2_MAGIC_NUMBER 0xc03b3998U  \n\n \n\n \n\n#define JBD2_DESCRIPTOR_BLOCK\t1\n#define JBD2_COMMIT_BLOCK\t2\n#define JBD2_SUPERBLOCK_V1\t3\n#define JBD2_SUPERBLOCK_V2\t4\n#define JBD2_REVOKE_BLOCK\t5\n\n \ntypedef struct journal_header_s\n{\n\t__be32\t\th_magic;\n\t__be32\t\th_blocktype;\n\t__be32\t\th_sequence;\n} journal_header_t;\n\n \n#define JBD2_CRC32_CHKSUM   1\n#define JBD2_MD5_CHKSUM     2\n#define JBD2_SHA1_CHKSUM    3\n#define JBD2_CRC32C_CHKSUM  4\n\n#define JBD2_CRC32_CHKSUM_SIZE 4\n\n#define JBD2_CHECKSUM_BYTES (32 / sizeof(u32))\n \nstruct commit_header {\n\t__be32\t\th_magic;\n\t__be32          h_blocktype;\n\t__be32          h_sequence;\n\tunsigned char   h_chksum_type;\n\tunsigned char   h_chksum_size;\n\tunsigned char \th_padding[2];\n\t__be32 \t\th_chksum[JBD2_CHECKSUM_BYTES];\n\t__be64\t\th_commit_sec;\n\t__be32\t\th_commit_nsec;\n};\n\n \ntypedef struct journal_block_tag3_s\n{\n\t__be32\t\tt_blocknr;\t \n\t__be32\t\tt_flags;\t \n\t__be32\t\tt_blocknr_high;  \n\t__be32\t\tt_checksum;\t \n} journal_block_tag3_t;\n\ntypedef struct journal_block_tag_s\n{\n\t__be32\t\tt_blocknr;\t \n\t__be16\t\tt_checksum;\t \n\t__be16\t\tt_flags;\t \n\t__be32\t\tt_blocknr_high;  \n} journal_block_tag_t;\n\n \nstruct jbd2_journal_block_tail {\n\t__be32\t\tt_checksum;\t \n};\n\n \ntypedef struct jbd2_journal_revoke_header_s\n{\n\tjournal_header_t r_header;\n\t__be32\t\t r_count;\t \n} jbd2_journal_revoke_header_t;\n\n \n#define JBD2_FLAG_ESCAPE\t\t1\t \n#define JBD2_FLAG_SAME_UUID\t2\t \n#define JBD2_FLAG_DELETED\t4\t \n#define JBD2_FLAG_LAST_TAG\t8\t \n\n\n \ntypedef struct journal_superblock_s\n{\n \n\tjournal_header_t s_header;\n\n \n\t \n\t__be32\ts_blocksize;\t\t \n\t__be32\ts_maxlen;\t\t \n\t__be32\ts_first;\t\t \n\n \n\t \n\t__be32\ts_sequence;\t\t \n\t__be32\ts_start;\t\t \n\n \n\t \n\t__be32\ts_errno;\n\n \n\t \n\t__be32\ts_feature_compat;\t \n\t__be32\ts_feature_incompat;\t \n\t__be32\ts_feature_ro_compat;\t \n \n\t__u8\ts_uuid[16];\t\t \n\n \n\t__be32\ts_nr_users;\t\t \n\n\t__be32\ts_dynsuper;\t\t \n\n \n\t__be32\ts_max_transaction;\t \n\t__be32\ts_max_trans_data;\t \n\n \n\t__u8\ts_checksum_type;\t \n\t__u8\ts_padding2[3];\n \n\t__be32\ts_num_fc_blks;\t\t \n\t__be32\ts_head;\t\t\t \n \n\t__u32\ts_padding[40];\n\t__be32\ts_checksum;\t\t \n\n \n\t__u8\ts_users[16*48];\t\t \n \n} journal_superblock_t;\n\n#define JBD2_FEATURE_COMPAT_CHECKSUM\t\t0x00000001\n\n#define JBD2_FEATURE_INCOMPAT_REVOKE\t\t0x00000001\n#define JBD2_FEATURE_INCOMPAT_64BIT\t\t0x00000002\n#define JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT\t0x00000004\n#define JBD2_FEATURE_INCOMPAT_CSUM_V2\t\t0x00000008\n#define JBD2_FEATURE_INCOMPAT_CSUM_V3\t\t0x00000010\n#define JBD2_FEATURE_INCOMPAT_FAST_COMMIT\t0x00000020\n\n \n\n \n#define JBD2_KNOWN_COMPAT_FEATURES\tJBD2_FEATURE_COMPAT_CHECKSUM\n#define JBD2_KNOWN_ROCOMPAT_FEATURES\t0\n#define JBD2_KNOWN_INCOMPAT_FEATURES\t(JBD2_FEATURE_INCOMPAT_REVOKE | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_64BIT | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V2 | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V3 | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_FAST_COMMIT)\n\n#ifdef __KERNEL__\n\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nenum jbd_state_bits {\n\tBH_JBD\t\t\t \n\t  = BH_PrivateStart,\n\tBH_JWrite,\t\t \n\tBH_Freed,\t\t \n\tBH_Revoked,\t\t \n\tBH_RevokeValid,\t\t \n\tBH_JBDDirty,\t\t \n\tBH_JournalHead,\t\t \n\tBH_Shadow,\t\t \n\tBH_Verified,\t\t \n\tBH_JBDPrivateStart,\t \n};\n\nBUFFER_FNS(JBD, jbd)\nBUFFER_FNS(JWrite, jwrite)\nBUFFER_FNS(JBDDirty, jbddirty)\nTAS_BUFFER_FNS(JBDDirty, jbddirty)\nBUFFER_FNS(Revoked, revoked)\nTAS_BUFFER_FNS(Revoked, revoked)\nBUFFER_FNS(RevokeValid, revokevalid)\nTAS_BUFFER_FNS(RevokeValid, revokevalid)\nBUFFER_FNS(Freed, freed)\nBUFFER_FNS(Shadow, shadow)\nBUFFER_FNS(Verified, verified)\n\nstatic inline struct buffer_head *jh2bh(struct journal_head *jh)\n{\n\treturn jh->b_bh;\n}\n\nstatic inline struct journal_head *bh2jh(struct buffer_head *bh)\n{\n\treturn bh->b_private;\n}\n\nstatic inline void jbd_lock_bh_journal_head(struct buffer_head *bh)\n{\n\tbit_spin_lock(BH_JournalHead, &bh->b_state);\n}\n\nstatic inline void jbd_unlock_bh_journal_head(struct buffer_head *bh)\n{\n\tbit_spin_unlock(BH_JournalHead, &bh->b_state);\n}\n\n#define J_ASSERT(assert)\tBUG_ON(!(assert))\n\n#define J_ASSERT_BH(bh, expr)\tJ_ASSERT(expr)\n#define J_ASSERT_JH(jh, expr)\tJ_ASSERT(expr)\n\n#if defined(JBD2_PARANOID_IOFAIL)\n#define J_EXPECT(expr, why...)\t\tJ_ASSERT(expr)\n#define J_EXPECT_BH(bh, expr, why...)\tJ_ASSERT_BH(bh, expr)\n#define J_EXPECT_JH(jh, expr, why...)\tJ_ASSERT_JH(jh, expr)\n#else\n#define __journal_expect(expr, why...)\t\t\t\t\t     \\\n\t({\t\t\t\t\t\t\t\t     \\\n\t\tint val = (expr);\t\t\t\t\t     \\\n\t\tif (!val) {\t\t\t\t\t\t     \\\n\t\t\tprintk(KERN_ERR\t\t\t\t\t     \\\n\t\t\t       \"JBD2 unexpected failure: %s: %s;\\n\",\t     \\\n\t\t\t       __func__, #expr);\t\t\t     \\\n\t\t\tprintk(KERN_ERR why \"\\n\");\t\t\t     \\\n\t\t}\t\t\t\t\t\t\t     \\\n\t\tval;\t\t\t\t\t\t\t     \\\n\t})\n#define J_EXPECT(expr, why...)\t\t__journal_expect(expr, ## why)\n#define J_EXPECT_BH(bh, expr, why...)\t__journal_expect(expr, ## why)\n#define J_EXPECT_JH(jh, expr, why...)\t__journal_expect(expr, ## why)\n#endif\n\n \n#define __JI_COMMIT_RUNNING 0\n#define __JI_WRITE_DATA 1\n#define __JI_WAIT_DATA 2\n\n \n#define JI_COMMIT_RUNNING (1 << __JI_COMMIT_RUNNING)\n \n#define JI_WRITE_DATA (1 << __JI_WRITE_DATA)\n \n#define JI_WAIT_DATA (1 << __JI_WAIT_DATA)\n\n \nstruct jbd2_inode {\n\t \n\ttransaction_t *i_transaction;\n\n\t \n\ttransaction_t *i_next_transaction;\n\n\t \n\tstruct list_head i_list;\n\n\t \n\tstruct inode *i_vfs_inode;\n\n\t \n\tunsigned long i_flags;\n\n\t \n\tloff_t i_dirty_start;\n\n\t \n\tloff_t i_dirty_end;\n};\n\nstruct jbd2_revoke_table_s;\n\n \n\n \n\nstruct jbd2_journal_handle\n{\n\tunion {\n\t\ttransaction_t\t*h_transaction;\n\t\t \n\t\tjournal_t\t*h_journal;\n\t};\n\n\thandle_t\t\t*h_rsv_handle;\n\tint\t\t\th_total_credits;\n\tint\t\t\th_revoke_credits;\n\tint\t\t\th_revoke_credits_requested;\n\tint\t\t\th_ref;\n\tint\t\t\th_err;\n\n\t \n\tunsigned int\th_sync:\t\t1;\n\tunsigned int\th_jdata:\t1;\n\tunsigned int\th_reserved:\t1;\n\tunsigned int\th_aborted:\t1;\n\tunsigned int\th_type:\t\t8;\n\tunsigned int\th_line_no:\t16;\n\n\tunsigned long\t\th_start_jiffies;\n\tunsigned int\t\th_requested_credits;\n\n\tunsigned int\t\tsaved_alloc_context;\n};\n\n\n \nstruct transaction_chp_stats_s {\n\tunsigned long\t\tcs_chp_time;\n\t__u32\t\t\tcs_forced_to_close;\n\t__u32\t\t\tcs_written;\n\t__u32\t\t\tcs_dropped;\n};\n\n \n\n \n\nstruct transaction_s\n{\n\t \n\tjournal_t\t\t*t_journal;\n\n\t \n\ttid_t\t\t\tt_tid;\n\n\t \n\tenum {\n\t\tT_RUNNING,\n\t\tT_LOCKED,\n\t\tT_SWITCH,\n\t\tT_FLUSH,\n\t\tT_COMMIT,\n\t\tT_COMMIT_DFLUSH,\n\t\tT_COMMIT_JFLUSH,\n\t\tT_COMMIT_CALLBACK,\n\t\tT_FINISHED\n\t}\t\t\tt_state;\n\n\t \n\tunsigned long\t\tt_log_start;\n\n\t \n\tint\t\t\tt_nr_buffers;\n\n\t \n\tstruct journal_head\t*t_reserved_list;\n\n\t \n\tstruct journal_head\t*t_buffers;\n\n\t \n\tstruct journal_head\t*t_forget;\n\n\t \n\tstruct journal_head\t*t_checkpoint_list;\n\n\t \n\tstruct journal_head\t*t_shadow_list;\n\n\t \n\tstruct list_head\tt_inode_list;\n\n\t \n\tunsigned long\t\tt_max_wait;\n\n\t \n\tunsigned long\t\tt_start;\n\n\t \n\tunsigned long\t\tt_requested;\n\n\t \n\tstruct transaction_chp_stats_s t_chp_stats;\n\n\t \n\tatomic_t\t\tt_updates;\n\n\t \n\tatomic_t\t\tt_outstanding_credits;\n\n\t \n\tatomic_t\t\tt_outstanding_revokes;\n\n\t \n\tatomic_t\t\tt_handle_count;\n\n\t \n\ttransaction_t\t\t*t_cpnext, *t_cpprev;\n\n\t \n\tunsigned long\t\tt_expires;\n\n\t \n\tktime_t\t\t\tt_start_time;\n\n\t \n\tunsigned int t_synchronous_commit:1;\n\n\t \n\tint\t\t\tt_need_data_flush;\n\n\t \n\tstruct list_head\tt_private_list;\n};\n\nstruct transaction_run_stats_s {\n\tunsigned long\t\trs_wait;\n\tunsigned long\t\trs_request_delay;\n\tunsigned long\t\trs_running;\n\tunsigned long\t\trs_locked;\n\tunsigned long\t\trs_flushing;\n\tunsigned long\t\trs_logging;\n\n\t__u32\t\t\trs_handle_count;\n\t__u32\t\t\trs_blocks;\n\t__u32\t\t\trs_blocks_logged;\n};\n\nstruct transaction_stats_s {\n\tunsigned long\t\tts_tid;\n\tunsigned long\t\tts_requested;\n\tstruct transaction_run_stats_s run;\n};\n\nstatic inline unsigned long\njbd2_time_diff(unsigned long start, unsigned long end)\n{\n\tif (end >= start)\n\t\treturn end - start;\n\n\treturn end + (MAX_JIFFY_OFFSET - start);\n}\n\n#define JBD2_NR_BATCH\t64\n\nenum passtype {PASS_SCAN, PASS_REVOKE, PASS_REPLAY};\n\n#define JBD2_FC_REPLAY_STOP\t0\n#define JBD2_FC_REPLAY_CONTINUE\t1\n\n \nstruct journal_s\n{\n\t \n\tunsigned long\t\tj_flags;\n\n\t \n\tunsigned long\t\tj_atomic_flags;\n\n\t \n\tint\t\t\tj_errno;\n\n\t \n\tstruct mutex\t\tj_abort_mutex;\n\n\t \n\tstruct buffer_head\t*j_sb_buffer;\n\n\t \n\tjournal_superblock_t\t*j_superblock;\n\n\t \n\trwlock_t\t\tj_state_lock;\n\n\t \n\tint\t\t\tj_barrier_count;\n\n\t \n\tstruct mutex\t\tj_barrier;\n\n\t \n\ttransaction_t\t\t*j_running_transaction;\n\n\t \n\ttransaction_t\t\t*j_committing_transaction;\n\n\t \n\ttransaction_t\t\t*j_checkpoint_transactions;\n\n\t \n\twait_queue_head_t\tj_wait_transaction_locked;\n\n\t \n\twait_queue_head_t\tj_wait_done_commit;\n\n\t \n\twait_queue_head_t\tj_wait_commit;\n\n\t \n\twait_queue_head_t\tj_wait_updates;\n\n\t \n\twait_queue_head_t\tj_wait_reserved;\n\n\t \n\twait_queue_head_t\tj_fc_wait;\n\n\t \n\tstruct mutex\t\tj_checkpoint_mutex;\n\n\t \n\tstruct buffer_head\t*j_chkpt_bhs[JBD2_NR_BATCH];\n\n\t \n\tstruct shrinker\t\tj_shrinker;\n\n\t \n\tstruct percpu_counter\tj_checkpoint_jh_count;\n\n\t \n\ttransaction_t\t\t*j_shrink_transaction;\n\n\t \n\tunsigned long\t\tj_head;\n\n\t \n\tunsigned long\t\tj_tail;\n\n\t \n\tunsigned long\t\tj_free;\n\n\t \n\tunsigned long\t\tj_first;\n\n\t \n\tunsigned long\t\tj_last;\n\n\t \n\tunsigned long\t\tj_fc_first;\n\n\t \n\tunsigned long\t\tj_fc_off;\n\n\t \n\tunsigned long\t\tj_fc_last;\n\n\t \n\tstruct block_device\t*j_dev;\n\n\t \n\tint\t\t\tj_blocksize;\n\n\t \n\tunsigned long long\tj_blk_offset;\n\n\t \n\tchar\t\t\tj_devname[BDEVNAME_SIZE+24];\n\n\t \n\tstruct block_device\t*j_fs_dev;\n\n\t \n\tunsigned int\t\tj_total_len;\n\n\t \n\tatomic_t\t\tj_reserved_credits;\n\n\t \n\tspinlock_t\t\tj_list_lock;\n\n\t \n\tstruct inode\t\t*j_inode;\n\n\t \n\ttid_t\t\t\tj_tail_sequence;\n\n\t \n\ttid_t\t\t\tj_transaction_sequence;\n\n\t \n\ttid_t\t\t\tj_commit_sequence;\n\n\t \n\ttid_t\t\t\tj_commit_request;\n\n\t \n\t__u8\t\t\tj_uuid[16];\n\n\t \n\tstruct task_struct\t*j_task;\n\n\t \n\tint\t\t\tj_max_transaction_buffers;\n\n\t \n\tint\t\t\tj_revoke_records_per_block;\n\n\t \n\tunsigned long\t\tj_commit_interval;\n\n\t \n\tstruct timer_list\tj_commit_timer;\n\n\t \n\tspinlock_t\t\tj_revoke_lock;\n\n\t \n\tstruct jbd2_revoke_table_s *j_revoke;\n\n\t \n\tstruct jbd2_revoke_table_s *j_revoke_table[2];\n\n\t \n\tstruct buffer_head\t**j_wbuf;\n\n\t \n\tstruct buffer_head\t**j_fc_wbuf;\n\n\t \n\tint\t\t\tj_wbufsize;\n\n\t \n\tint\t\t\tj_fc_wbufsize;\n\n\t \n\tpid_t\t\t\tj_last_sync_writer;\n\n\t \n\tu64\t\t\tj_average_commit_time;\n\n\t \n\tu32\t\t\tj_min_batch_time;\n\n\t \n\tu32\t\t\tj_max_batch_time;\n\n\t \n\tvoid\t\t\t(*j_commit_callback)(journal_t *,\n\t\t\t\t\t\t     transaction_t *);\n\n\t \n\tint\t\t\t(*j_submit_inode_data_buffers)\n\t\t\t\t\t(struct jbd2_inode *);\n\n\t \n\tint\t\t\t(*j_finish_inode_data_buffers)\n\t\t\t\t\t(struct jbd2_inode *);\n\n\t \n\n\t \n\tspinlock_t\t\tj_history_lock;\n\n\t \n\tstruct proc_dir_entry\t*j_proc_entry;\n\n\t \n\tstruct transaction_stats_s j_stats;\n\n\t \n\tunsigned int\t\tj_failed_commit;\n\n\t \n\tvoid *j_private;\n\n\t \n\tstruct crypto_shash *j_chksum_driver;\n\n\t \n\t__u32 j_csum_seed;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t \n\tstruct lockdep_map\tj_trans_commit_map;\n#endif\n\n\t \n\tvoid (*j_fc_cleanup_callback)(struct journal_s *journal, int full, tid_t tid);\n\n\t \n\tint (*j_fc_replay_callback)(struct journal_s *journal,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    enum passtype pass, int off,\n\t\t\t\t    tid_t expected_commit_id);\n\n\t \n\tint (*j_bmap)(struct journal_s *journal, sector_t *block);\n};\n\n#define jbd2_might_wait_for_commit(j) \\\n\tdo { \\\n\t\trwsem_acquire(&j->j_trans_commit_map, 0, 0, _THIS_IP_); \\\n\t\trwsem_release(&j->j_trans_commit_map, _THIS_IP_); \\\n\t} while (0)\n\n \nstatic inline bool jbd2_format_support_feature(journal_t *j)\n{\n\treturn j->j_superblock->s_header.h_blocktype !=\n\t\t\t\t\tcpu_to_be32(JBD2_SUPERBLOCK_V1);\n}\n\n \n#define JBD2_FEATURE_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool jbd2_has_feature_##name(journal_t *j) \\\n{ \\\n\treturn (jbd2_format_support_feature(j) && \\\n\t\t((j)->j_superblock->s_feature_compat & \\\n\t\t cpu_to_be32(JBD2_FEATURE_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void jbd2_set_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_compat |= \\\n\t\tcpu_to_be32(JBD2_FEATURE_COMPAT_##flagname); \\\n} \\\nstatic inline void jbd2_clear_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_compat &= \\\n\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_##flagname); \\\n}\n\n#define JBD2_FEATURE_RO_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool jbd2_has_feature_##name(journal_t *j) \\\n{ \\\n\treturn (jbd2_format_support_feature(j) && \\\n\t\t((j)->j_superblock->s_feature_ro_compat & \\\n\t\t cpu_to_be32(JBD2_FEATURE_RO_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void jbd2_set_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_ro_compat |= \\\n\t\tcpu_to_be32(JBD2_FEATURE_RO_COMPAT_##flagname); \\\n} \\\nstatic inline void jbd2_clear_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_ro_compat &= \\\n\t\t~cpu_to_be32(JBD2_FEATURE_RO_COMPAT_##flagname); \\\n}\n\n#define JBD2_FEATURE_INCOMPAT_FUNCS(name, flagname) \\\nstatic inline bool jbd2_has_feature_##name(journal_t *j) \\\n{ \\\n\treturn (jbd2_format_support_feature(j) && \\\n\t\t((j)->j_superblock->s_feature_incompat & \\\n\t\t cpu_to_be32(JBD2_FEATURE_INCOMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void jbd2_set_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_incompat |= \\\n\t\tcpu_to_be32(JBD2_FEATURE_INCOMPAT_##flagname); \\\n} \\\nstatic inline void jbd2_clear_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_incompat &= \\\n\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_##flagname); \\\n}\n\nJBD2_FEATURE_COMPAT_FUNCS(checksum,\t\tCHECKSUM)\n\nJBD2_FEATURE_INCOMPAT_FUNCS(revoke,\t\tREVOKE)\nJBD2_FEATURE_INCOMPAT_FUNCS(64bit,\t\t64BIT)\nJBD2_FEATURE_INCOMPAT_FUNCS(async_commit,\tASYNC_COMMIT)\nJBD2_FEATURE_INCOMPAT_FUNCS(csum2,\t\tCSUM_V2)\nJBD2_FEATURE_INCOMPAT_FUNCS(csum3,\t\tCSUM_V3)\nJBD2_FEATURE_INCOMPAT_FUNCS(fast_commit,\tFAST_COMMIT)\n\n \n#define JBD2_JOURNAL_REQ_FLAGS\t\t(REQ_META | REQ_SYNC | REQ_IDLE)\n\n \n#define JBD2_UNMOUNT\t0x001\t \n#define JBD2_ABORT\t0x002\t \n#define JBD2_ACK_ERR\t0x004\t \n#define JBD2_FLUSHED\t0x008\t \n#define JBD2_LOADED\t0x010\t \n#define JBD2_BARRIER\t0x020\t \n#define JBD2_ABORT_ON_SYNCDATA_ERR\t0x040\t \n#define JBD2_CYCLE_RECORD\t\t0x080\t \n#define JBD2_FAST_COMMIT_ONGOING\t0x100\t \n#define JBD2_FULL_COMMIT_ONGOING\t0x200\t \n#define JBD2_JOURNAL_FLUSH_DISCARD\t0x0001\n#define JBD2_JOURNAL_FLUSH_ZEROOUT\t0x0002\n#define JBD2_JOURNAL_FLUSH_VALID\t(JBD2_JOURNAL_FLUSH_DISCARD | \\\n\t\t\t\t\tJBD2_JOURNAL_FLUSH_ZEROOUT)\n\n \n#define JBD2_CHECKPOINT_IO_ERROR\t0x001\t \n\n \n\n \nextern void jbd2_journal_unfile_buffer(journal_t *, struct journal_head *);\nextern bool __jbd2_journal_refile_buffer(struct journal_head *);\nextern void jbd2_journal_refile_buffer(journal_t *, struct journal_head *);\nextern void __jbd2_journal_file_buffer(struct journal_head *, transaction_t *, int);\nextern void jbd2_journal_file_buffer(struct journal_head *, transaction_t *, int);\nstatic inline void jbd2_file_log_bh(struct list_head *head, struct buffer_head *bh)\n{\n\tlist_add_tail(&bh->b_assoc_buffers, head);\n}\nstatic inline void jbd2_unfile_log_bh(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n}\n\n \nstruct buffer_head *jbd2_journal_get_descriptor_buffer(transaction_t *, int);\nvoid jbd2_descriptor_block_csum_set(journal_t *, struct buffer_head *);\nint jbd2_journal_next_log_block(journal_t *, unsigned long long *);\nint jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,\n\t\t\t      unsigned long *block);\nint __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);\nvoid jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);\n\n \nextern void jbd2_journal_commit_transaction(journal_t *);\n\n \nvoid __jbd2_journal_clean_checkpoint_list(journal_t *journal, bool destroy);\nunsigned long jbd2_journal_shrink_checkpoint_list(journal_t *journal, unsigned long *nr_to_scan);\nint __jbd2_journal_remove_checkpoint(struct journal_head *);\nint jbd2_journal_try_remove_checkpoint(struct journal_head *jh);\nvoid jbd2_journal_destroy_checkpoint(journal_t *journal);\nvoid __jbd2_journal_insert_checkpoint(struct journal_head *, transaction_t *);\n\n\n \n\nstruct jbd2_buffer_trigger_type {\n\t \n\tvoid (*t_frozen)(struct jbd2_buffer_trigger_type *type,\n\t\t\t struct buffer_head *bh, void *mapped_data,\n\t\t\t size_t size);\n\n\t \n\tvoid (*t_abort)(struct jbd2_buffer_trigger_type *type,\n\t\t\tstruct buffer_head *bh);\n};\n\nextern void jbd2_buffer_frozen_trigger(struct journal_head *jh,\n\t\t\t\t       void *mapped_data,\n\t\t\t\t       struct jbd2_buffer_trigger_type *triggers);\nextern void jbd2_buffer_abort_trigger(struct journal_head *jh,\n\t\t\t\t      struct jbd2_buffer_trigger_type *triggers);\n\n \nextern int jbd2_journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t\t      struct journal_head *jh_in,\n\t\t\t\t\t      struct buffer_head **bh_out,\n\t\t\t\t\t      sector_t blocknr);\n\n \nextern void jbd2_journal_destroy_transaction_cache(void);\nextern int __init jbd2_journal_init_transaction_cache(void);\nextern void jbd2_journal_free_transaction(transaction_t *);\n\n \n\nstatic inline handle_t *journal_current_handle(void)\n{\n\treturn current->journal_info;\n}\n\n \n\nextern handle_t *jbd2_journal_start(journal_t *, int nblocks);\nextern handle_t *jbd2__journal_start(journal_t *, int blocks, int rsv_blocks,\n\t\t\t\t     int revoke_records, gfp_t gfp_mask,\n\t\t\t\t     unsigned int type, unsigned int line_no);\nextern int\t jbd2_journal_restart(handle_t *, int nblocks);\nextern int\t jbd2__journal_restart(handle_t *, int nblocks,\n\t\t\t\t       int revoke_records, gfp_t gfp_mask);\nextern int\t jbd2_journal_start_reserved(handle_t *handle,\n\t\t\t\tunsigned int type, unsigned int line_no);\nextern void\t jbd2_journal_free_reserved(handle_t *handle);\nextern int\t jbd2_journal_extend(handle_t *handle, int nblocks,\n\t\t\t\t     int revoke_records);\nextern int\t jbd2_journal_get_write_access(handle_t *, struct buffer_head *);\nextern int\t jbd2_journal_get_create_access (handle_t *, struct buffer_head *);\nextern int\t jbd2_journal_get_undo_access(handle_t *, struct buffer_head *);\nvoid\t\t jbd2_journal_set_triggers(struct buffer_head *,\n\t\t\t\t\t   struct jbd2_buffer_trigger_type *type);\nextern int\t jbd2_journal_dirty_metadata (handle_t *, struct buffer_head *);\nextern int\t jbd2_journal_forget (handle_t *, struct buffer_head *);\nint jbd2_journal_invalidate_folio(journal_t *, struct folio *,\n\t\t\t\t\tsize_t offset, size_t length);\nbool jbd2_journal_try_to_free_buffers(journal_t *journal, struct folio *folio);\nextern int\t jbd2_journal_stop(handle_t *);\nextern int\t jbd2_journal_flush(journal_t *journal, unsigned int flags);\nextern void\t jbd2_journal_lock_updates (journal_t *);\nextern void\t jbd2_journal_unlock_updates (journal_t *);\n\nvoid jbd2_journal_wait_updates(journal_t *);\n\nextern journal_t * jbd2_journal_init_dev(struct block_device *bdev,\n\t\t\t\tstruct block_device *fs_dev,\n\t\t\t\tunsigned long long start, int len, int bsize);\nextern journal_t * jbd2_journal_init_inode (struct inode *);\nextern int\t   jbd2_journal_update_format (journal_t *);\nextern int\t   jbd2_journal_check_used_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern int\t   jbd2_journal_check_available_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern int\t   jbd2_journal_set_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern void\t   jbd2_journal_clear_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern int\t   jbd2_journal_load       (journal_t *journal);\nextern int\t   jbd2_journal_destroy    (journal_t *);\nextern int\t   jbd2_journal_recover    (journal_t *journal);\nextern int\t   jbd2_journal_wipe       (journal_t *, int);\nextern int\t   jbd2_journal_skip_recovery\t(journal_t *);\nextern void\t   jbd2_journal_update_sb_errno(journal_t *);\nextern int\t   jbd2_journal_update_sb_log_tail\t(journal_t *, tid_t,\n\t\t\t\tunsigned long, blk_opf_t);\nextern void\t   jbd2_journal_abort      (journal_t *, int);\nextern int\t   jbd2_journal_errno      (journal_t *);\nextern void\t   jbd2_journal_ack_err    (journal_t *);\nextern int\t   jbd2_journal_clear_err  (journal_t *);\nextern int\t   jbd2_journal_bmap(journal_t *, unsigned long, unsigned long long *);\nextern int\t   jbd2_journal_force_commit(journal_t *);\nextern int\t   jbd2_journal_force_commit_nested(journal_t *);\nextern int\t   jbd2_journal_inode_ranged_write(handle_t *handle,\n\t\t\tstruct jbd2_inode *inode, loff_t start_byte,\n\t\t\tloff_t length);\nextern int\t   jbd2_journal_inode_ranged_wait(handle_t *handle,\n\t\t\tstruct jbd2_inode *inode, loff_t start_byte,\n\t\t\tloff_t length);\nextern int\t   jbd2_journal_finish_inode_data_buffers(\n\t\t\tstruct jbd2_inode *jinode);\nextern int\t   jbd2_journal_begin_ordered_truncate(journal_t *journal,\n\t\t\t\tstruct jbd2_inode *inode, loff_t new_size);\nextern void\t   jbd2_journal_init_jbd_inode(struct jbd2_inode *jinode, struct inode *inode);\nextern void\t   jbd2_journal_release_jbd_inode(journal_t *journal, struct jbd2_inode *jinode);\n\n \nstruct journal_head *jbd2_journal_add_journal_head(struct buffer_head *bh);\nstruct journal_head *jbd2_journal_grab_journal_head(struct buffer_head *bh);\nvoid jbd2_journal_put_journal_head(struct journal_head *jh);\n\n \nextern struct kmem_cache *jbd2_handle_cache;\n\nstatic inline handle_t *jbd2_alloc_handle(gfp_t gfp_flags)\n{\n\treturn kmem_cache_zalloc(jbd2_handle_cache, gfp_flags);\n}\n\nstatic inline void jbd2_free_handle(handle_t *handle)\n{\n\tkmem_cache_free(jbd2_handle_cache, handle);\n}\n\n \nextern struct kmem_cache *jbd2_inode_cache;\n\nstatic inline struct jbd2_inode *jbd2_alloc_inode(gfp_t gfp_flags)\n{\n\treturn kmem_cache_alloc(jbd2_inode_cache, gfp_flags);\n}\n\nstatic inline void jbd2_free_inode(struct jbd2_inode *jinode)\n{\n\tkmem_cache_free(jbd2_inode_cache, jinode);\n}\n\n \n#define JOURNAL_REVOKE_DEFAULT_HASH 256\nextern int\t   jbd2_journal_init_revoke(journal_t *, int);\nextern void\t   jbd2_journal_destroy_revoke_record_cache(void);\nextern void\t   jbd2_journal_destroy_revoke_table_cache(void);\nextern int __init jbd2_journal_init_revoke_record_cache(void);\nextern int __init jbd2_journal_init_revoke_table_cache(void);\n\nextern void\t   jbd2_journal_destroy_revoke(journal_t *);\nextern int\t   jbd2_journal_revoke (handle_t *, unsigned long long, struct buffer_head *);\nextern int\t   jbd2_journal_cancel_revoke(handle_t *, struct journal_head *);\nextern void\t   jbd2_journal_write_revoke_records(transaction_t *transaction,\n\t\t\t\t\t\t     struct list_head *log_bufs);\n\n \nextern int\tjbd2_journal_set_revoke(journal_t *, unsigned long long, tid_t);\nextern int\tjbd2_journal_test_revoke(journal_t *, unsigned long long, tid_t);\nextern void\tjbd2_journal_clear_revoke(journal_t *);\nextern void\tjbd2_journal_switch_revoke_table(journal_t *journal);\nextern void\tjbd2_clear_buffer_revoked_flags(journal_t *journal);\n\n \n\nint jbd2_log_start_commit(journal_t *journal, tid_t tid);\nint jbd2_journal_start_commit(journal_t *journal, tid_t *tid);\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid);\nint jbd2_transaction_committed(journal_t *journal, tid_t tid);\nint jbd2_complete_transaction(journal_t *journal, tid_t tid);\nint jbd2_log_do_checkpoint(journal_t *journal);\nint jbd2_trans_will_send_data_barrier(journal_t *journal, tid_t tid);\n\nvoid __jbd2_log_wait_for_space(journal_t *journal);\nextern void __jbd2_journal_drop_transaction(journal_t *, transaction_t *);\nextern int jbd2_cleanup_journal_tail(journal_t *);\n\n \nint jbd2_fc_begin_commit(journal_t *journal, tid_t tid);\nint jbd2_fc_end_commit(journal_t *journal);\nint jbd2_fc_end_commit_fallback(journal_t *journal);\nint jbd2_fc_get_buf(journal_t *journal, struct buffer_head **bh_out);\nint jbd2_submit_inode_data(journal_t *journal, struct jbd2_inode *jinode);\nint jbd2_wait_inode_data(journal_t *journal, struct jbd2_inode *jinode);\nint jbd2_fc_wait_bufs(journal_t *journal, int num_blks);\nint jbd2_fc_release_bufs(journal_t *journal);\n\nstatic inline int jbd2_journal_get_max_txn_bufs(journal_t *journal)\n{\n\treturn (journal->j_total_len - journal->j_fc_wbufsize) / 4;\n}\n\n \n\nstatic inline int is_journal_aborted(journal_t *journal)\n{\n\treturn journal->j_flags & JBD2_ABORT;\n}\n\nstatic inline int is_handle_aborted(handle_t *handle)\n{\n\tif (handle->h_aborted || !handle->h_transaction)\n\t\treturn 1;\n\treturn is_journal_aborted(handle->h_transaction->t_journal);\n}\n\nstatic inline void jbd2_journal_abort_handle(handle_t *handle)\n{\n\thandle->h_aborted = 1;\n}\n\n#endif  \n\n \n\nstatic inline int tid_gt(tid_t x, tid_t y)\n{\n\tint difference = (x - y);\n\treturn (difference > 0);\n}\n\nstatic inline int tid_geq(tid_t x, tid_t y)\n{\n\tint difference = (x - y);\n\treturn (difference >= 0);\n}\n\nextern int jbd2_journal_blocks_per_page(struct inode *inode);\nextern size_t journal_tag_bytes(journal_t *journal);\n\nstatic inline bool jbd2_journal_has_csum_v2or3_feature(journal_t *j)\n{\n\treturn jbd2_has_feature_csum2(j) || jbd2_has_feature_csum3(j);\n}\n\nstatic inline int jbd2_journal_has_csum_v2or3(journal_t *journal)\n{\n\tWARN_ON_ONCE(jbd2_journal_has_csum_v2or3_feature(journal) &&\n\t\t     journal->j_chksum_driver == NULL);\n\n\treturn journal->j_chksum_driver != NULL;\n}\n\nstatic inline int jbd2_journal_get_num_fc_blks(journal_superblock_t *jsb)\n{\n\tint num_fc_blocks = be32_to_cpu(jsb->s_num_fc_blks);\n\n\treturn num_fc_blocks ? num_fc_blocks : JBD2_DEFAULT_FAST_COMMIT_BLOCKS;\n}\n\n \nstatic inline unsigned long jbd2_log_space_left(journal_t *journal)\n{\n\t \n\tlong free = journal->j_free - 32;\n\n\tif (journal->j_committing_transaction) {\n\t\tfree -= atomic_read(&journal->\n                        j_committing_transaction->t_outstanding_credits);\n\t}\n\treturn max_t(long, free, 0);\n}\n\n \n\n \n#define BJ_None\t\t0\t \n#define BJ_Metadata\t1\t \n#define BJ_Forget\t2\t \n#define BJ_Shadow\t3\t \n#define BJ_Reserved\t4\t \n#define BJ_Types\t5\n\n \n#define JBD_MAX_CHECKSUM_SIZE 4\n\nstatic inline u32 jbd2_chksum(journal_t *journal, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[JBD_MAX_CHECKSUM_SIZE];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(journal->j_chksum_driver) >\n\t\tJBD_MAX_CHECKSUM_SIZE);\n\n\tdesc.shash.tfm = journal->j_chksum_driver;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}\n\n \nstatic inline tid_t  jbd2_get_latest_transaction(journal_t *journal)\n{\n\ttid_t tid;\n\n\tread_lock(&journal->j_state_lock);\n\ttid = journal->j_commit_request;\n\tif (journal->j_running_transaction)\n\t\ttid = journal->j_running_transaction->t_tid;\n\tread_unlock(&journal->j_state_lock);\n\treturn tid;\n}\n\nstatic inline int jbd2_handle_buffer_credits(handle_t *handle)\n{\n\tjournal_t *journal;\n\n\tif (!handle->h_reserved)\n\t\tjournal = handle->h_transaction->t_journal;\n\telse\n\t\tjournal = handle->h_journal;\n\n\treturn handle->h_total_credits -\n\t\tDIV_ROUND_UP(handle->h_revoke_credits_requested,\n\t\t\t     journal->j_revoke_records_per_block);\n}\n\n#ifdef __KERNEL__\n\n#define buffer_trace_init(bh)\tdo {} while (0)\n#define print_buffer_fields(bh)\tdo {} while (0)\n#define print_buffer_trace(bh)\tdo {} while (0)\n#define BUFFER_TRACE(bh, info)\tdo {} while (0)\n#define BUFFER_TRACE2(bh, bh2, info)\tdo {} while (0)\n#define JBUFFER_TRACE(jh, info)\tdo {} while (0)\n\n#endif\t \n\n#define EFSBADCRC\tEBADMSG\t\t \n#define EFSCORRUPTED\tEUCLEAN\t\t \n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}