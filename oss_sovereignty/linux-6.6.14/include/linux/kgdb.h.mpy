{
  "module_name": "kgdb.h",
  "hash_id": "c7aa7dec0b48dde701a3b5c5429b9a05b72135b9f80476f2197a0a612b86877a",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/kgdb.h",
  "human_readable_source": " \n#ifndef _KGDB_H_\n#define _KGDB_H_\n\n#include <linux/linkage.h>\n#include <linux/init.h>\n#include <linux/atomic.h>\n#include <linux/kprobes.h>\n#ifdef CONFIG_HAVE_ARCH_KGDB\n#include <asm/kgdb.h>\n#endif\n\n#ifdef CONFIG_KGDB\nstruct pt_regs;\n\n \nextern int kgdb_skipexception(int exception, struct pt_regs *regs);\n\nstruct tasklet_struct;\nstruct task_struct;\nstruct uart_port;\n\n \nvoid kgdb_breakpoint(void);\n\nextern int kgdb_connected;\nextern int kgdb_io_module_registered;\n\nextern atomic_t\t\t\tkgdb_setting_breakpoint;\nextern atomic_t\t\t\tkgdb_cpu_doing_single_step;\n\nextern struct task_struct\t*kgdb_usethread;\nextern struct task_struct\t*kgdb_contthread;\n\nenum kgdb_bptype {\n\tBP_BREAKPOINT = 0,\n\tBP_HARDWARE_BREAKPOINT,\n\tBP_WRITE_WATCHPOINT,\n\tBP_READ_WATCHPOINT,\n\tBP_ACCESS_WATCHPOINT,\n\tBP_POKE_BREAKPOINT,\n};\n\nenum kgdb_bpstate {\n\tBP_UNDEFINED = 0,\n\tBP_REMOVED,\n\tBP_SET,\n\tBP_ACTIVE\n};\n\nstruct kgdb_bkpt {\n\tunsigned long\t\tbpt_addr;\n\tunsigned char\t\tsaved_instr[BREAK_INSTR_SIZE];\n\tenum kgdb_bptype\ttype;\n\tenum kgdb_bpstate\tstate;\n};\n\nstruct dbg_reg_def_t {\n\tchar *name;\n\tint size;\n\tint offset;\n};\n\n#ifndef DBG_MAX_REG_NUM\n#define DBG_MAX_REG_NUM 0\n#else\nextern struct dbg_reg_def_t dbg_reg_def[];\nextern char *dbg_get_reg(int regno, void *mem, struct pt_regs *regs);\nextern int dbg_set_reg(int regno, void *mem, struct pt_regs *regs);\n#endif\n#ifndef KGDB_MAX_BREAKPOINTS\n# define KGDB_MAX_BREAKPOINTS\t1000\n#endif\n\n#define KGDB_HW_BREAKPOINT\t1\n\n \n\n \nextern int kgdb_arch_init(void);\n\n \nextern void kgdb_arch_exit(void);\n\n \nextern void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs);\n\n \nextern void\nsleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p);\n\n \nextern void gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs);\n\n \nextern int\nkgdb_arch_handle_exception(int vector, int signo, int err_code,\n\t\t\t   char *remcom_in_buffer,\n\t\t\t   char *remcom_out_buffer,\n\t\t\t   struct pt_regs *regs);\n\n \n\nextern void\nkgdb_arch_handle_qxfer_pkt(char *remcom_in_buffer,\n\t\t\t   char *remcom_out_buffer);\n\n \n\nextern void kgdb_call_nmi_hook(void *ignored);\n\n \nextern void kgdb_roundup_cpus(void);\n\n \nextern void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc);\n\n\n \nextern int kgdb_validate_break_address(unsigned long addr);\nextern int kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt);\nextern int kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt);\n\n \nextern void kgdb_arch_late(void);\n\n\n \nstruct kgdb_arch {\n\tunsigned char\t\tgdb_bpt_instr[BREAK_INSTR_SIZE];\n\tunsigned long\t\tflags;\n\n\tint\t(*set_breakpoint)(unsigned long, char *);\n\tint\t(*remove_breakpoint)(unsigned long, char *);\n\tint\t(*set_hw_breakpoint)(unsigned long, int, enum kgdb_bptype);\n\tint\t(*remove_hw_breakpoint)(unsigned long, int, enum kgdb_bptype);\n\tvoid\t(*disable_hw_break)(struct pt_regs *regs);\n\tvoid\t(*remove_all_hw_break)(void);\n\tvoid\t(*correct_hw_break)(void);\n\n\tvoid\t(*enable_nmi)(bool on);\n};\n\n \nstruct kgdb_io {\n\tconst char\t\t*name;\n\tint\t\t\t(*read_char) (void);\n\tvoid\t\t\t(*write_char) (u8);\n\tvoid\t\t\t(*flush) (void);\n\tint\t\t\t(*init) (void);\n\tvoid\t\t\t(*deinit) (void);\n\tvoid\t\t\t(*pre_exception) (void);\n\tvoid\t\t\t(*post_exception) (void);\n\tstruct console\t\t*cons;\n};\n\nextern const struct kgdb_arch\t\tarch_kgdb_ops;\n\nextern unsigned long kgdb_arch_pc(int exception, struct pt_regs *regs);\n\n#ifdef CONFIG_SERIAL_KGDB_NMI\nextern int kgdb_register_nmi_console(void);\nextern int kgdb_unregister_nmi_console(void);\nextern bool kgdb_nmi_poll_knock(void);\n#else\nstatic inline int kgdb_register_nmi_console(void) { return 0; }\nstatic inline int kgdb_unregister_nmi_console(void) { return 0; }\nstatic inline bool kgdb_nmi_poll_knock(void) { return true; }\n#endif\n\nextern int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops);\nextern void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops);\nextern struct kgdb_io *dbg_io_ops;\n\nextern int kgdb_hex2long(char **ptr, unsigned long *long_val);\nextern char *kgdb_mem2hex(char *mem, char *buf, int count);\nextern int kgdb_hex2mem(char *buf, char *mem, int count);\n\nextern int kgdb_isremovedbreak(unsigned long addr);\nextern int kgdb_has_hit_break(unsigned long addr);\n\nextern int\nkgdb_handle_exception(int ex_vector, int signo, int err_code,\n\t\t      struct pt_regs *regs);\nextern int kgdb_nmicallback(int cpu, void *regs);\nextern int kgdb_nmicallin(int cpu, int trapnr, void *regs, int err_code,\n\t\t\t  atomic_t *snd_rdy);\nextern void gdbstub_exit(int status);\n\n \nstatic inline bool kgdb_within_blocklist(unsigned long addr)\n{\n#ifdef CONFIG_KGDB_HONOUR_BLOCKLIST\n\treturn within_kprobe_blacklist(addr);\n#else\n\treturn false;\n#endif\n}\n\nextern int\t\t\tkgdb_single_step;\nextern atomic_t\t\t\tkgdb_active;\n#define in_dbg_master() \\\n\t(irqs_disabled() && (smp_processor_id() == atomic_read(&kgdb_active)))\nextern bool dbg_is_early;\nextern void __init dbg_late_init(void);\nextern void kgdb_panic(const char *msg);\nextern void kgdb_free_init_mem(void);\n#else  \n#define in_dbg_master() (0)\n#define dbg_late_init()\nstatic inline void kgdb_panic(const char *msg) {}\nstatic inline void kgdb_free_init_mem(void) { }\nstatic inline int kgdb_nmicallback(int cpu, void *regs) { return 1; }\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}