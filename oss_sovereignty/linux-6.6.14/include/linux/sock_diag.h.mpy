{
  "module_name": "sock_diag.h",
  "hash_id": "3124332657cbebd0763d61f45d11bea7d0b8ab0e94f74df4f2ba1672f238fdff",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/sock_diag.h",
  "human_readable_source": " \n#ifndef __SOCK_DIAG_H__\n#define __SOCK_DIAG_H__\n\n#include <linux/netlink.h>\n#include <linux/user_namespace.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <uapi/linux/sock_diag.h>\n\nstruct sk_buff;\nstruct nlmsghdr;\nstruct sock;\n\nstruct sock_diag_handler {\n\t__u8 family;\n\tint (*dump)(struct sk_buff *skb, struct nlmsghdr *nlh);\n\tint (*get_info)(struct sk_buff *skb, struct sock *sk);\n\tint (*destroy)(struct sk_buff *skb, struct nlmsghdr *nlh);\n};\n\nint sock_diag_register(const struct sock_diag_handler *h);\nvoid sock_diag_unregister(const struct sock_diag_handler *h);\n\nvoid sock_diag_register_inet_compat(int (*fn)(struct sk_buff *skb, struct nlmsghdr *nlh));\nvoid sock_diag_unregister_inet_compat(int (*fn)(struct sk_buff *skb, struct nlmsghdr *nlh));\n\nu64 __sock_gen_cookie(struct sock *sk);\n\nstatic inline u64 sock_gen_cookie(struct sock *sk)\n{\n\tu64 cookie;\n\n\tpreempt_disable();\n\tcookie = __sock_gen_cookie(sk);\n\tpreempt_enable();\n\n\treturn cookie;\n}\n\nint sock_diag_check_cookie(struct sock *sk, const __u32 *cookie);\nvoid sock_diag_save_cookie(struct sock *sk, __u32 *cookie);\n\nint sock_diag_put_meminfo(struct sock *sk, struct sk_buff *skb, int attr);\nint sock_diag_put_filterinfo(bool may_report_filterinfo, struct sock *sk,\n\t\t\t     struct sk_buff *skb, int attrtype);\n\nstatic inline\nenum sknetlink_groups sock_diag_destroy_group(const struct sock *sk)\n{\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tif (sk->sk_type == SOCK_RAW)\n\t\t\treturn SKNLGRP_NONE;\n\n\t\tswitch (sk->sk_protocol) {\n\t\tcase IPPROTO_TCP:\n\t\t\treturn SKNLGRP_INET_TCP_DESTROY;\n\t\tcase IPPROTO_UDP:\n\t\t\treturn SKNLGRP_INET_UDP_DESTROY;\n\t\tdefault:\n\t\t\treturn SKNLGRP_NONE;\n\t\t}\n\tcase AF_INET6:\n\t\tif (sk->sk_type == SOCK_RAW)\n\t\t\treturn SKNLGRP_NONE;\n\n\t\tswitch (sk->sk_protocol) {\n\t\tcase IPPROTO_TCP:\n\t\t\treturn SKNLGRP_INET6_TCP_DESTROY;\n\t\tcase IPPROTO_UDP:\n\t\t\treturn SKNLGRP_INET6_UDP_DESTROY;\n\t\tdefault:\n\t\t\treturn SKNLGRP_NONE;\n\t\t}\n\tdefault:\n\t\treturn SKNLGRP_NONE;\n\t}\n}\n\nstatic inline\nbool sock_diag_has_destroy_listeners(const struct sock *sk)\n{\n\tconst struct net *n = sock_net(sk);\n\tconst enum sknetlink_groups group = sock_diag_destroy_group(sk);\n\n\treturn group != SKNLGRP_NONE && n->diag_nlsk &&\n\t\tnetlink_has_listeners(n->diag_nlsk, group);\n}\nvoid sock_diag_broadcast_destroy(struct sock *sk);\n\nint sock_diag_destroy(struct sock *sk, int err);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}