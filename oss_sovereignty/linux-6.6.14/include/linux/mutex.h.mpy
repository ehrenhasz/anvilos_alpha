{
  "module_name": "mutex.h",
  "hash_id": "1b374a10a3f9486649398cdc60eb7260c7846ee5932df812a02537865209e8dc",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mutex.h",
  "human_readable_source": " \n \n#ifndef __LINUX_MUTEX_H\n#define __LINUX_MUTEX_H\n\n#include <asm/current.h>\n#include <linux/list.h>\n#include <linux/spinlock_types.h>\n#include <linux/lockdep.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/cleanup.h>\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n# define __DEP_MAP_MUTEX_INITIALIZER(lockname)\t\t\t\\\n\t\t, .dep_map = {\t\t\t\t\t\\\n\t\t\t.name = #lockname,\t\t\t\\\n\t\t\t.wait_type_inner = LD_WAIT_SLEEP,\t\\\n\t\t}\n#else\n# define __DEP_MAP_MUTEX_INITIALIZER(lockname)\n#endif\n\n#ifndef CONFIG_PREEMPT_RT\n\n \nstruct mutex {\n\tatomic_long_t\t\towner;\n\traw_spinlock_t\t\twait_lock;\n#ifdef CONFIG_MUTEX_SPIN_ON_OWNER\n\tstruct optimistic_spin_queue osq;  \n#endif\n\tstruct list_head\twait_list;\n#ifdef CONFIG_DEBUG_MUTEXES\n\tvoid\t\t\t*magic;\n#endif\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tstruct lockdep_map\tdep_map;\n#endif\n};\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\n#define __DEBUG_MUTEX_INITIALIZER(lockname)\t\t\t\t\\\n\t, .magic = &lockname\n\nextern void mutex_destroy(struct mutex *lock);\n\n#else\n\n# define __DEBUG_MUTEX_INITIALIZER(lockname)\n\nstatic inline void mutex_destroy(struct mutex *lock) {}\n\n#endif\n\n \n#define mutex_init(mutex)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__mutex_init((mutex), #mutex, &__key);\t\t\t\t\\\n} while (0)\n\n#define __MUTEX_INITIALIZER(lockname) \\\n\t\t{ .owner = ATOMIC_LONG_INIT(0) \\\n\t\t, .wait_lock = __RAW_SPIN_LOCK_UNLOCKED(lockname.wait_lock) \\\n\t\t, .wait_list = LIST_HEAD_INIT(lockname.wait_list) \\\n\t\t__DEBUG_MUTEX_INITIALIZER(lockname) \\\n\t\t__DEP_MAP_MUTEX_INITIALIZER(lockname) }\n\n#define DEFINE_MUTEX(mutexname) \\\n\tstruct mutex mutexname = __MUTEX_INITIALIZER(mutexname)\n\nextern void __mutex_init(struct mutex *lock, const char *name,\n\t\t\t struct lock_class_key *key);\n\n \nextern bool mutex_is_locked(struct mutex *lock);\n\n#else  \n \n#include <linux/rtmutex.h>\n\nstruct mutex {\n\tstruct rt_mutex_base\trtmutex;\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tstruct lockdep_map\tdep_map;\n#endif\n};\n\n#define __MUTEX_INITIALIZER(mutexname)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.rtmutex = __RT_MUTEX_BASE_INITIALIZER(mutexname.rtmutex)\t\\\n\t__DEP_MAP_MUTEX_INITIALIZER(mutexname)\t\t\t\t\\\n}\n\n#define DEFINE_MUTEX(mutexname)\t\t\t\t\t\t\\\n\tstruct mutex mutexname = __MUTEX_INITIALIZER(mutexname)\n\nextern void __mutex_rt_init(struct mutex *lock, const char *name,\n\t\t\t    struct lock_class_key *key);\nextern int mutex_trylock(struct mutex *lock);\n\nstatic inline void mutex_destroy(struct mutex *lock) { }\n\n#define mutex_is_locked(l)\trt_mutex_base_is_locked(&(l)->rtmutex)\n\n#define __mutex_init(mutex, name, key)\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\trt_mutex_base_init(&(mutex)->rtmutex);\t\t\\\n\t__mutex_rt_init((mutex), name, key);\t\t\\\n} while (0)\n\n#define mutex_init(mutex)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\\\n\t\t\t\t\t\t\t\\\n\t__mutex_init((mutex), #mutex, &__key);\t\t\\\n} while (0)\n#endif  \n\n \n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nextern void mutex_lock_nested(struct mutex *lock, unsigned int subclass);\nextern void _mutex_lock_nest_lock(struct mutex *lock, struct lockdep_map *nest_lock);\n\nextern int __must_check mutex_lock_interruptible_nested(struct mutex *lock,\n\t\t\t\t\tunsigned int subclass);\nextern int __must_check mutex_lock_killable_nested(struct mutex *lock,\n\t\t\t\t\tunsigned int subclass);\nextern void mutex_lock_io_nested(struct mutex *lock, unsigned int subclass);\n\n#define mutex_lock(lock) mutex_lock_nested(lock, 0)\n#define mutex_lock_interruptible(lock) mutex_lock_interruptible_nested(lock, 0)\n#define mutex_lock_killable(lock) mutex_lock_killable_nested(lock, 0)\n#define mutex_lock_io(lock) mutex_lock_io_nested(lock, 0)\n\n#define mutex_lock_nest_lock(lock, nest_lock)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypecheck(struct lockdep_map *, &(nest_lock)->dep_map);\t\\\n\t_mutex_lock_nest_lock(lock, &(nest_lock)->dep_map);\t\t\\\n} while (0)\n\n#else\nextern void mutex_lock(struct mutex *lock);\nextern int __must_check mutex_lock_interruptible(struct mutex *lock);\nextern int __must_check mutex_lock_killable(struct mutex *lock);\nextern void mutex_lock_io(struct mutex *lock);\n\n# define mutex_lock_nested(lock, subclass) mutex_lock(lock)\n# define mutex_lock_interruptible_nested(lock, subclass) mutex_lock_interruptible(lock)\n# define mutex_lock_killable_nested(lock, subclass) mutex_lock_killable(lock)\n# define mutex_lock_nest_lock(lock, nest_lock) mutex_lock(lock)\n# define mutex_lock_io_nested(lock, subclass) mutex_lock_io(lock)\n#endif\n\n \nextern int mutex_trylock(struct mutex *lock);\nextern void mutex_unlock(struct mutex *lock);\n\nextern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);\n\nDEFINE_GUARD(mutex, struct mutex *, mutex_lock(_T), mutex_unlock(_T))\nDEFINE_FREE(mutex, struct mutex *, if (_T) mutex_unlock(_T))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}