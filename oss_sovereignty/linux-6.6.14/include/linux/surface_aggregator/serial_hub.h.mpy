{
  "module_name": "serial_hub.h",
  "hash_id": "089969975a10459a8b73a819e40b2e237408939396a1cf4c4a5f79d1142f1e1f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/surface_aggregator/serial_hub.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_SURFACE_AGGREGATOR_SERIAL_HUB_H\n#define _LINUX_SURFACE_AGGREGATOR_SERIAL_HUB_H\n\n#include <linux/crc-ccitt.h>\n#include <linux/kref.h>\n#include <linux/ktime.h>\n#include <linux/list.h>\n#include <linux/types.h>\n\n\n \n\n \nenum ssh_frame_type {\n\tSSH_FRAME_TYPE_DATA_SEQ = 0x80,\n\tSSH_FRAME_TYPE_DATA_NSQ = 0x00,\n\tSSH_FRAME_TYPE_ACK      = 0x40,\n\tSSH_FRAME_TYPE_NAK      = 0x04,\n};\n\n \nstruct ssh_frame {\n\tu8 type;\n\t__le16 len;\n\tu8 seq;\n} __packed;\n\nstatic_assert(sizeof(struct ssh_frame) == 4);\n\n \n#define SSH_FRAME_MAX_PAYLOAD_SIZE\tU16_MAX\n\n \nenum ssh_payload_type {\n\tSSH_PLD_TYPE_CMD = 0x80,\n};\n\n \nstruct ssh_command {\n\tu8 type;\n\tu8 tc;\n\tu8 tid;\n\tu8 sid;\n\tu8 iid;\n\t__le16 rqid;\n\tu8 cid;\n} __packed;\n\nstatic_assert(sizeof(struct ssh_command) == 8);\n\n \n#define SSH_COMMAND_MAX_PAYLOAD_SIZE \\\n\t(SSH_FRAME_MAX_PAYLOAD_SIZE - sizeof(struct ssh_command))\n\n \n#define SSH_MSG_LEN_BASE\t(sizeof(struct ssh_frame) + 3ull * sizeof(u16))\n\n \n#define SSH_MSG_LEN_CTRL\tSSH_MSG_LEN_BASE\n\n \n#define SSH_MESSAGE_LENGTH(payload_size) (SSH_MSG_LEN_BASE + (payload_size))\n\n \n#define SSH_COMMAND_MESSAGE_LENGTH(payload_size) \\\n\tSSH_MESSAGE_LENGTH(sizeof(struct ssh_command) + (payload_size))\n\n \n#define SSH_MSGOFFSET_FRAME(field) \\\n\t(sizeof(u16) + offsetof(struct ssh_frame, field))\n\n \n#define SSH_MSGOFFSET_COMMAND(field) \\\n\t(2ull * sizeof(u16) + sizeof(struct ssh_frame) \\\n\t\t+ offsetof(struct ssh_command, field))\n\n \n#define SSH_MSG_SYN\t\t((u16)0x55aa)\n\n \nstatic inline u16 ssh_crc(const u8 *buf, size_t len)\n{\n\treturn crc_ccitt_false(0xffff, buf, len);\n}\n\n \n#define SSH_NUM_EVENTS\t\t38\n\n \n#define SSH_NUM_TARGETS\t\t2\n\n \nstatic inline u16 ssh_rqid_next_valid(u16 rqid)\n{\n\treturn rqid > 0 ? rqid + 1u : rqid + SSH_NUM_EVENTS + 1u;\n}\n\n \nstatic inline u16 ssh_rqid_to_event(u16 rqid)\n{\n\treturn rqid - 1u;\n}\n\n \nstatic inline bool ssh_rqid_is_event(u16 rqid)\n{\n\treturn ssh_rqid_to_event(rqid) < SSH_NUM_EVENTS;\n}\n\n \nstatic inline u16 ssh_tc_to_rqid(u8 tc)\n{\n\treturn tc;\n}\n\n \nstatic inline u8 ssh_tid_to_index(u8 tid)\n{\n\treturn tid - 1u;\n}\n\n \nstatic inline bool ssh_tid_is_valid(u8 tid)\n{\n\treturn ssh_tid_to_index(tid) < SSH_NUM_TARGETS;\n}\n\n \nstruct ssam_span {\n\tu8    *ptr;\n\tsize_t len;\n};\n\n \nenum ssam_ssh_tid {\n\tSSAM_SSH_TID_HOST     = 0x00,\n\tSSAM_SSH_TID_SAM      = 0x01,\n\tSSAM_SSH_TID_KIP      = 0x02,\n\tSSAM_SSH_TID_DEBUG    = 0x03,\n\tSSAM_SSH_TID_SURFLINK = 0x04,\n};\n\n \nenum ssam_ssh_tc {\n\t\t\t\t   \n\tSSAM_SSH_TC_SAM  = 0x01,   \n\tSSAM_SSH_TC_BAT  = 0x02,   \n\tSSAM_SSH_TC_TMP  = 0x03,   \n\tSSAM_SSH_TC_PMC  = 0x04,\n\tSSAM_SSH_TC_FAN  = 0x05,\n\tSSAM_SSH_TC_PoM  = 0x06,\n\tSSAM_SSH_TC_DBG  = 0x07,\n\tSSAM_SSH_TC_KBD  = 0x08,   \n\tSSAM_SSH_TC_FWU  = 0x09,\n\tSSAM_SSH_TC_UNI  = 0x0a,\n\tSSAM_SSH_TC_LPC  = 0x0b,\n\tSSAM_SSH_TC_TCL  = 0x0c,\n\tSSAM_SSH_TC_SFL  = 0x0d,\n\tSSAM_SSH_TC_KIP  = 0x0e,   \n\tSSAM_SSH_TC_EXT  = 0x0f,\n\tSSAM_SSH_TC_BLD  = 0x10,\n\tSSAM_SSH_TC_BAS  = 0x11,   \n\tSSAM_SSH_TC_SEN  = 0x12,\n\tSSAM_SSH_TC_SRQ  = 0x13,\n\tSSAM_SSH_TC_MCU  = 0x14,\n\tSSAM_SSH_TC_HID  = 0x15,   \n\tSSAM_SSH_TC_TCH  = 0x16,\n\tSSAM_SSH_TC_BKL  = 0x17,\n\tSSAM_SSH_TC_TAM  = 0x18,\n\tSSAM_SSH_TC_ACC0 = 0x19,\n\tSSAM_SSH_TC_UFI  = 0x1a,\n\tSSAM_SSH_TC_USC  = 0x1b,\n\tSSAM_SSH_TC_PEN  = 0x1c,\n\tSSAM_SSH_TC_VID  = 0x1d,\n\tSSAM_SSH_TC_AUD  = 0x1e,\n\tSSAM_SSH_TC_SMC  = 0x1f,\n\tSSAM_SSH_TC_KPD  = 0x20,\n\tSSAM_SSH_TC_REG  = 0x21,   \n\tSSAM_SSH_TC_SPT  = 0x22,\n\tSSAM_SSH_TC_SYS  = 0x23,\n\tSSAM_SSH_TC_ACC1 = 0x24,\n\tSSAM_SSH_TC_SHB  = 0x25,\n\tSSAM_SSH_TC_POS  = 0x26,   \n};\n\n\n \n\n \nenum ssh_packet_base_priority {\n\tSSH_PACKET_PRIORITY_FLUSH = 0,\t \n\tSSH_PACKET_PRIORITY_DATA  = 0,\n\tSSH_PACKET_PRIORITY_NAK   = 1,\n\tSSH_PACKET_PRIORITY_ACK   = 2,\n};\n\n \n#define __SSH_PACKET_PRIORITY(base, try) \\\n\t(((base) << 4) | ((try) & 0x0f))\n\n \n#define SSH_PACKET_PRIORITY(base, try) \\\n\t__SSH_PACKET_PRIORITY(SSH_PACKET_PRIORITY_##base, (try))\n\n \nstatic inline u8 ssh_packet_priority_get_try(u8 priority)\n{\n\treturn priority & 0x0f;\n}\n\n \nstatic inline u8 ssh_packet_priority_get_base(u8 priority)\n{\n\treturn (priority & 0xf0) >> 4;\n}\n\nenum ssh_packet_flags {\n\t \n\tSSH_PACKET_SF_LOCKED_BIT,\n\tSSH_PACKET_SF_QUEUED_BIT,\n\tSSH_PACKET_SF_PENDING_BIT,\n\tSSH_PACKET_SF_TRANSMITTING_BIT,\n\tSSH_PACKET_SF_TRANSMITTED_BIT,\n\tSSH_PACKET_SF_ACKED_BIT,\n\tSSH_PACKET_SF_CANCELED_BIT,\n\tSSH_PACKET_SF_COMPLETED_BIT,\n\n\t \n\tSSH_PACKET_TY_FLUSH_BIT,\n\tSSH_PACKET_TY_SEQUENCED_BIT,\n\tSSH_PACKET_TY_BLOCKING_BIT,\n\n\t \n\tSSH_PACKET_FLAGS_SF_MASK =\n\t\t  BIT(SSH_PACKET_SF_LOCKED_BIT)\n\t\t| BIT(SSH_PACKET_SF_QUEUED_BIT)\n\t\t| BIT(SSH_PACKET_SF_PENDING_BIT)\n\t\t| BIT(SSH_PACKET_SF_TRANSMITTING_BIT)\n\t\t| BIT(SSH_PACKET_SF_TRANSMITTED_BIT)\n\t\t| BIT(SSH_PACKET_SF_ACKED_BIT)\n\t\t| BIT(SSH_PACKET_SF_CANCELED_BIT)\n\t\t| BIT(SSH_PACKET_SF_COMPLETED_BIT),\n\n\t \n\tSSH_PACKET_FLAGS_TY_MASK =\n\t\t  BIT(SSH_PACKET_TY_FLUSH_BIT)\n\t\t| BIT(SSH_PACKET_TY_SEQUENCED_BIT)\n\t\t| BIT(SSH_PACKET_TY_BLOCKING_BIT),\n};\n\nstruct ssh_ptl;\nstruct ssh_packet;\n\n \nstruct ssh_packet_ops {\n\tvoid (*release)(struct ssh_packet *p);\n\tvoid (*complete)(struct ssh_packet *p, int status);\n};\n\n \nstruct ssh_packet {\n\tstruct ssh_ptl *ptl;\n\tstruct kref refcnt;\n\n\tu8 priority;\n\n\tstruct {\n\t\tsize_t len;\n\t\tu8 *ptr;\n\t} data;\n\n\tunsigned long state;\n\tktime_t timestamp;\n\n\tstruct list_head queue_node;\n\tstruct list_head pending_node;\n\n\tconst struct ssh_packet_ops *ops;\n};\n\nstruct ssh_packet *ssh_packet_get(struct ssh_packet *p);\nvoid ssh_packet_put(struct ssh_packet *p);\n\n \nstatic inline void ssh_packet_set_data(struct ssh_packet *p, u8 *ptr, size_t len)\n{\n\tp->data.ptr = ptr;\n\tp->data.len = len;\n}\n\n\n \n\nenum ssh_request_flags {\n\t \n\tSSH_REQUEST_SF_LOCKED_BIT,\n\tSSH_REQUEST_SF_QUEUED_BIT,\n\tSSH_REQUEST_SF_PENDING_BIT,\n\tSSH_REQUEST_SF_TRANSMITTING_BIT,\n\tSSH_REQUEST_SF_TRANSMITTED_BIT,\n\tSSH_REQUEST_SF_RSPRCVD_BIT,\n\tSSH_REQUEST_SF_CANCELED_BIT,\n\tSSH_REQUEST_SF_COMPLETED_BIT,\n\n\t \n\tSSH_REQUEST_TY_FLUSH_BIT,\n\tSSH_REQUEST_TY_HAS_RESPONSE_BIT,\n\n\t \n\tSSH_REQUEST_FLAGS_SF_MASK =\n\t\t  BIT(SSH_REQUEST_SF_LOCKED_BIT)\n\t\t| BIT(SSH_REQUEST_SF_QUEUED_BIT)\n\t\t| BIT(SSH_REQUEST_SF_PENDING_BIT)\n\t\t| BIT(SSH_REQUEST_SF_TRANSMITTING_BIT)\n\t\t| BIT(SSH_REQUEST_SF_TRANSMITTED_BIT)\n\t\t| BIT(SSH_REQUEST_SF_RSPRCVD_BIT)\n\t\t| BIT(SSH_REQUEST_SF_CANCELED_BIT)\n\t\t| BIT(SSH_REQUEST_SF_COMPLETED_BIT),\n\n\t \n\tSSH_REQUEST_FLAGS_TY_MASK =\n\t\t  BIT(SSH_REQUEST_TY_FLUSH_BIT)\n\t\t| BIT(SSH_REQUEST_TY_HAS_RESPONSE_BIT),\n};\n\nstruct ssh_rtl;\nstruct ssh_request;\n\n \nstruct ssh_request_ops {\n\tvoid (*release)(struct ssh_request *rqst);\n\tvoid (*complete)(struct ssh_request *rqst,\n\t\t\t const struct ssh_command *cmd,\n\t\t\t const struct ssam_span *data, int status);\n};\n\n \nstruct ssh_request {\n\tstruct ssh_packet packet;\n\tstruct list_head node;\n\n\tunsigned long state;\n\tktime_t timestamp;\n\n\tconst struct ssh_request_ops *ops;\n};\n\n \nstatic inline struct ssh_request *to_ssh_request(struct ssh_packet *p)\n{\n\treturn container_of(p, struct ssh_request, packet);\n}\n\n \nstatic inline struct ssh_request *ssh_request_get(struct ssh_request *r)\n{\n\treturn r ? to_ssh_request(ssh_packet_get(&r->packet)) : NULL;\n}\n\n \nstatic inline void ssh_request_put(struct ssh_request *r)\n{\n\tif (r)\n\t\tssh_packet_put(&r->packet);\n}\n\n \nstatic inline void ssh_request_set_data(struct ssh_request *r, u8 *ptr, size_t len)\n{\n\tssh_packet_set_data(&r->packet, ptr, len);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}