{
  "module_name": "if_vlan.h",
  "hash_id": "da6d06862c3e6f16eb8b51df68e423394fd3b9023ce9203cda7c965096e3025c",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/if_vlan.h",
  "human_readable_source": " \n \n#ifndef _LINUX_IF_VLAN_H_\n#define _LINUX_IF_VLAN_H_\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/bug.h>\n#include <uapi/linux/if_vlan.h>\n\n#define VLAN_HLEN\t4\t\t \n#define VLAN_ETH_HLEN\t18\t\t \n#define VLAN_ETH_ZLEN\t64\t\t \n\n \n#define VLAN_ETH_DATA_LEN\t1500\t \n#define VLAN_ETH_FRAME_LEN\t1518\t \n\n#define VLAN_MAX_DEPTH\t8\t\t \n\n \nstruct vlan_hdr {\n\t__be16\th_vlan_TCI;\n\t__be16\th_vlan_encapsulated_proto;\n};\n\n \nstruct vlan_ethhdr {\n\tstruct_group(addrs,\n\t\tunsigned char\th_dest[ETH_ALEN];\n\t\tunsigned char\th_source[ETH_ALEN];\n\t);\n\t__be16\t\th_vlan_proto;\n\t__be16\t\th_vlan_TCI;\n\t__be16\t\th_vlan_encapsulated_proto;\n};\n\n#include <linux/skbuff.h>\n\nstatic inline struct vlan_ethhdr *vlan_eth_hdr(const struct sk_buff *skb)\n{\n\treturn (struct vlan_ethhdr *)skb_mac_header(skb);\n}\n\n \nstatic inline struct vlan_ethhdr *skb_vlan_eth_hdr(const struct sk_buff *skb)\n{\n\treturn (struct vlan_ethhdr *)skb->data;\n}\n\n#define VLAN_PRIO_MASK\t\t0xe000  \n#define VLAN_PRIO_SHIFT\t\t13\n#define VLAN_CFI_MASK\t\t0x1000  \n#define VLAN_VID_MASK\t\t0x0fff  \n#define VLAN_N_VID\t\t4096\n\n \nextern void vlan_ioctl_set(int (*hook)(struct net *, void __user *));\n\nstatic inline bool is_vlan_dev(const struct net_device *dev)\n{\n        return dev->priv_flags & IFF_802_1Q_VLAN;\n}\n\n#define skb_vlan_tag_present(__skb)\t(!!(__skb)->vlan_all)\n#define skb_vlan_tag_get(__skb)\t\t((__skb)->vlan_tci)\n#define skb_vlan_tag_get_id(__skb)\t((__skb)->vlan_tci & VLAN_VID_MASK)\n#define skb_vlan_tag_get_cfi(__skb)\t(!!((__skb)->vlan_tci & VLAN_CFI_MASK))\n#define skb_vlan_tag_get_prio(__skb)\t(((__skb)->vlan_tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT)\n\nstatic inline int vlan_get_rx_ctag_filter_info(struct net_device *dev)\n{\n\tASSERT_RTNL();\n\treturn notifier_to_errno(call_netdevice_notifiers(NETDEV_CVLAN_FILTER_PUSH_INFO, dev));\n}\n\nstatic inline void vlan_drop_rx_ctag_filter_info(struct net_device *dev)\n{\n\tASSERT_RTNL();\n\tcall_netdevice_notifiers(NETDEV_CVLAN_FILTER_DROP_INFO, dev);\n}\n\nstatic inline int vlan_get_rx_stag_filter_info(struct net_device *dev)\n{\n\tASSERT_RTNL();\n\treturn notifier_to_errno(call_netdevice_notifiers(NETDEV_SVLAN_FILTER_PUSH_INFO, dev));\n}\n\nstatic inline void vlan_drop_rx_stag_filter_info(struct net_device *dev)\n{\n\tASSERT_RTNL();\n\tcall_netdevice_notifiers(NETDEV_SVLAN_FILTER_DROP_INFO, dev);\n}\n\n \nstruct vlan_pcpu_stats {\n\tu64_stats_t\t\trx_packets;\n\tu64_stats_t\t\trx_bytes;\n\tu64_stats_t\t\trx_multicast;\n\tu64_stats_t\t\ttx_packets;\n\tu64_stats_t\t\ttx_bytes;\n\tstruct u64_stats_sync\tsyncp;\n\tu32\t\t\trx_errors;\n\tu32\t\t\ttx_dropped;\n};\n\n#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)\n\nextern struct net_device *__vlan_find_dev_deep_rcu(struct net_device *real_dev,\n\t\t\t\t\t       __be16 vlan_proto, u16 vlan_id);\nextern int vlan_for_each(struct net_device *dev,\n\t\t\t int (*action)(struct net_device *dev, int vid,\n\t\t\t\t       void *arg), void *arg);\nextern struct net_device *vlan_dev_real_dev(const struct net_device *dev);\nextern u16 vlan_dev_vlan_id(const struct net_device *dev);\nextern __be16 vlan_dev_vlan_proto(const struct net_device *dev);\n\n \nstruct vlan_priority_tci_mapping {\n\tu32\t\t\t\t\tpriority;\n\tu16\t\t\t\t\tvlan_qos;\n\tstruct vlan_priority_tci_mapping\t*next;\n};\n\nstruct proc_dir_entry;\nstruct netpoll;\n\n \nstruct vlan_dev_priv {\n\tunsigned int\t\t\t\tnr_ingress_mappings;\n\tu32\t\t\t\t\tingress_priority_map[8];\n\tunsigned int\t\t\t\tnr_egress_mappings;\n\tstruct vlan_priority_tci_mapping\t*egress_priority_map[16];\n\n\t__be16\t\t\t\t\tvlan_proto;\n\tu16\t\t\t\t\tvlan_id;\n\tu16\t\t\t\t\tflags;\n\n\tstruct net_device\t\t\t*real_dev;\n\tnetdevice_tracker\t\t\tdev_tracker;\n\n\tunsigned char\t\t\t\treal_dev_addr[ETH_ALEN];\n\n\tstruct proc_dir_entry\t\t\t*dent;\n\tstruct vlan_pcpu_stats __percpu\t\t*vlan_pcpu_stats;\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\tstruct netpoll\t\t\t\t*netpoll;\n#endif\n};\n\nstatic inline struct vlan_dev_priv *vlan_dev_priv(const struct net_device *dev)\n{\n\treturn netdev_priv(dev);\n}\n\nstatic inline u16\nvlan_dev_get_egress_qos_mask(struct net_device *dev, u32 skprio)\n{\n\tstruct vlan_priority_tci_mapping *mp;\n\n\tsmp_rmb();  \n\n\tmp = vlan_dev_priv(dev)->egress_priority_map[(skprio & 0xF)];\n\twhile (mp) {\n\t\tif (mp->priority == skprio) {\n\t\t\treturn mp->vlan_qos;  \n\t\t}\n\t\tmp = mp->next;\n\t}\n\treturn 0;\n}\n\nextern bool vlan_do_receive(struct sk_buff **skb);\n\nextern int vlan_vid_add(struct net_device *dev, __be16 proto, u16 vid);\nextern void vlan_vid_del(struct net_device *dev, __be16 proto, u16 vid);\n\nextern int vlan_vids_add_by_dev(struct net_device *dev,\n\t\t\t\tconst struct net_device *by_dev);\nextern void vlan_vids_del_by_dev(struct net_device *dev,\n\t\t\t\t const struct net_device *by_dev);\n\nextern bool vlan_uses_dev(const struct net_device *dev);\n\n#else\nstatic inline struct net_device *\n__vlan_find_dev_deep_rcu(struct net_device *real_dev,\n\t\t     __be16 vlan_proto, u16 vlan_id)\n{\n\treturn NULL;\n}\n\nstatic inline int\nvlan_for_each(struct net_device *dev,\n\t      int (*action)(struct net_device *dev, int vid, void *arg),\n\t      void *arg)\n{\n\treturn 0;\n}\n\nstatic inline struct net_device *vlan_dev_real_dev(const struct net_device *dev)\n{\n\tBUG();\n\treturn NULL;\n}\n\nstatic inline u16 vlan_dev_vlan_id(const struct net_device *dev)\n{\n\tBUG();\n\treturn 0;\n}\n\nstatic inline __be16 vlan_dev_vlan_proto(const struct net_device *dev)\n{\n\tBUG();\n\treturn 0;\n}\n\nstatic inline u16 vlan_dev_get_egress_qos_mask(struct net_device *dev,\n\t\t\t\t\t       u32 skprio)\n{\n\treturn 0;\n}\n\nstatic inline bool vlan_do_receive(struct sk_buff **skb)\n{\n\treturn false;\n}\n\nstatic inline int vlan_vid_add(struct net_device *dev, __be16 proto, u16 vid)\n{\n\treturn 0;\n}\n\nstatic inline void vlan_vid_del(struct net_device *dev, __be16 proto, u16 vid)\n{\n}\n\nstatic inline int vlan_vids_add_by_dev(struct net_device *dev,\n\t\t\t\t       const struct net_device *by_dev)\n{\n\treturn 0;\n}\n\nstatic inline void vlan_vids_del_by_dev(struct net_device *dev,\n\t\t\t\t\tconst struct net_device *by_dev)\n{\n}\n\nstatic inline bool vlan_uses_dev(const struct net_device *dev)\n{\n\treturn false;\n}\n#endif\n\n \nstatic inline bool eth_type_vlan(__be16 ethertype)\n{\n\tswitch (ethertype) {\n\tcase htons(ETH_P_8021Q):\n\tcase htons(ETH_P_8021AD):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline bool vlan_hw_offload_capable(netdev_features_t features,\n\t\t\t\t\t   __be16 proto)\n{\n\tif (proto == htons(ETH_P_8021Q) && features & NETIF_F_HW_VLAN_CTAG_TX)\n\t\treturn true;\n\tif (proto == htons(ETH_P_8021AD) && features & NETIF_F_HW_VLAN_STAG_TX)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic inline int __vlan_insert_inner_tag(struct sk_buff *skb,\n\t\t\t\t\t  __be16 vlan_proto, u16 vlan_tci,\n\t\t\t\t\t  unsigned int mac_len)\n{\n\tstruct vlan_ethhdr *veth;\n\n\tif (skb_cow_head(skb, VLAN_HLEN) < 0)\n\t\treturn -ENOMEM;\n\n\tskb_push(skb, VLAN_HLEN);\n\n\t \n\tif (likely(mac_len > ETH_TLEN))\n\t\tmemmove(skb->data, skb->data + VLAN_HLEN, mac_len - ETH_TLEN);\n\tif (skb_mac_header_was_set(skb))\n\t\tskb->mac_header -= VLAN_HLEN;\n\n\tveth = (struct vlan_ethhdr *)(skb->data + mac_len - ETH_HLEN);\n\n\t \n\tif (likely(mac_len >= ETH_TLEN)) {\n\t\t \n\t\tveth->h_vlan_proto = vlan_proto;\n\t} else {\n\t\t \n\t\tveth->h_vlan_encapsulated_proto = skb->protocol;\n\t}\n\n\t \n\tveth->h_vlan_TCI = htons(vlan_tci);\n\n\treturn 0;\n}\n\n \nstatic inline int __vlan_insert_tag(struct sk_buff *skb,\n\t\t\t\t    __be16 vlan_proto, u16 vlan_tci)\n{\n\treturn __vlan_insert_inner_tag(skb, vlan_proto, vlan_tci, ETH_HLEN);\n}\n\n \nstatic inline struct sk_buff *vlan_insert_inner_tag(struct sk_buff *skb,\n\t\t\t\t\t\t    __be16 vlan_proto,\n\t\t\t\t\t\t    u16 vlan_tci,\n\t\t\t\t\t\t    unsigned int mac_len)\n{\n\tint err;\n\n\terr = __vlan_insert_inner_tag(skb, vlan_proto, vlan_tci, mac_len);\n\tif (err) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NULL;\n\t}\n\treturn skb;\n}\n\n \nstatic inline struct sk_buff *vlan_insert_tag(struct sk_buff *skb,\n\t\t\t\t\t      __be16 vlan_proto, u16 vlan_tci)\n{\n\treturn vlan_insert_inner_tag(skb, vlan_proto, vlan_tci, ETH_HLEN);\n}\n\n \nstatic inline struct sk_buff *vlan_insert_tag_set_proto(struct sk_buff *skb,\n\t\t\t\t\t\t\t__be16 vlan_proto,\n\t\t\t\t\t\t\tu16 vlan_tci)\n{\n\tskb = vlan_insert_tag(skb, vlan_proto, vlan_tci);\n\tif (skb)\n\t\tskb->protocol = vlan_proto;\n\treturn skb;\n}\n\n \nstatic inline void __vlan_hwaccel_clear_tag(struct sk_buff *skb)\n{\n\tskb->vlan_all = 0;\n}\n\n \nstatic inline void __vlan_hwaccel_copy_tag(struct sk_buff *dst, const struct sk_buff *src)\n{\n\tdst->vlan_all = src->vlan_all;\n}\n\n \nstatic inline struct sk_buff *__vlan_hwaccel_push_inside(struct sk_buff *skb)\n{\n\tskb = vlan_insert_tag_set_proto(skb, skb->vlan_proto,\n\t\t\t\t\tskb_vlan_tag_get(skb));\n\tif (likely(skb))\n\t\t__vlan_hwaccel_clear_tag(skb);\n\treturn skb;\n}\n\n \nstatic inline void __vlan_hwaccel_put_tag(struct sk_buff *skb,\n\t\t\t\t\t  __be16 vlan_proto, u16 vlan_tci)\n{\n\tskb->vlan_proto = vlan_proto;\n\tskb->vlan_tci = vlan_tci;\n}\n\n \nstatic inline int __vlan_get_tag(const struct sk_buff *skb, u16 *vlan_tci)\n{\n\tstruct vlan_ethhdr *veth = skb_vlan_eth_hdr(skb);\n\n\tif (!eth_type_vlan(veth->h_vlan_proto))\n\t\treturn -EINVAL;\n\n\t*vlan_tci = ntohs(veth->h_vlan_TCI);\n\treturn 0;\n}\n\n \nstatic inline int __vlan_hwaccel_get_tag(const struct sk_buff *skb,\n\t\t\t\t\t u16 *vlan_tci)\n{\n\tif (skb_vlan_tag_present(skb)) {\n\t\t*vlan_tci = skb_vlan_tag_get(skb);\n\t\treturn 0;\n\t} else {\n\t\t*vlan_tci = 0;\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic inline int vlan_get_tag(const struct sk_buff *skb, u16 *vlan_tci)\n{\n\tif (skb->dev->features & NETIF_F_HW_VLAN_CTAG_TX) {\n\t\treturn __vlan_hwaccel_get_tag(skb, vlan_tci);\n\t} else {\n\t\treturn __vlan_get_tag(skb, vlan_tci);\n\t}\n}\n\n \nstatic inline __be16 __vlan_get_protocol(const struct sk_buff *skb, __be16 type,\n\t\t\t\t\t int *depth)\n{\n\tunsigned int vlan_depth = skb->mac_len, parse_depth = VLAN_MAX_DEPTH;\n\n\t \n\tif (eth_type_vlan(type)) {\n\t\tif (vlan_depth) {\n\t\t\tif (WARN_ON(vlan_depth < VLAN_HLEN))\n\t\t\t\treturn 0;\n\t\t\tvlan_depth -= VLAN_HLEN;\n\t\t} else {\n\t\t\tvlan_depth = ETH_HLEN;\n\t\t}\n\t\tdo {\n\t\t\tstruct vlan_hdr vhdr, *vh;\n\n\t\t\tvh = skb_header_pointer(skb, vlan_depth, sizeof(vhdr), &vhdr);\n\t\t\tif (unlikely(!vh || !--parse_depth))\n\t\t\t\treturn 0;\n\n\t\t\ttype = vh->h_vlan_encapsulated_proto;\n\t\t\tvlan_depth += VLAN_HLEN;\n\t\t} while (eth_type_vlan(type));\n\t}\n\n\tif (depth)\n\t\t*depth = vlan_depth;\n\n\treturn type;\n}\n\n \nstatic inline __be16 vlan_get_protocol(const struct sk_buff *skb)\n{\n\treturn __vlan_get_protocol(skb, skb->protocol, NULL);\n}\n\n \nstatic inline __be16 vlan_get_protocol_and_depth(struct sk_buff *skb,\n\t\t\t\t\t\t __be16 type, int *depth)\n{\n\tint maclen;\n\n\ttype = __vlan_get_protocol(skb, type, &maclen);\n\n\tif (type) {\n\t\tif (!pskb_may_pull(skb, maclen))\n\t\t\ttype = 0;\n\t\telse if (depth)\n\t\t\t*depth = maclen;\n\t}\n\treturn type;\n}\n\n \nstatic inline __be16 skb_protocol(const struct sk_buff *skb, bool skip_vlan)\n{\n\tif (!skip_vlan)\n\t\t \n\t\treturn skb_vlan_tag_present(skb) ? skb->vlan_proto : skb->protocol;\n\n\treturn vlan_get_protocol(skb);\n}\n\nstatic inline void vlan_set_encap_proto(struct sk_buff *skb,\n\t\t\t\t\tstruct vlan_hdr *vhdr)\n{\n\t__be16 proto;\n\tunsigned short *rawp;\n\n\t \n\n\tproto = vhdr->h_vlan_encapsulated_proto;\n\tif (eth_proto_is_802_3(proto)) {\n\t\tskb->protocol = proto;\n\t\treturn;\n\t}\n\n\trawp = (unsigned short *)(vhdr + 1);\n\tif (*rawp == 0xFFFF)\n\t\t \n\t\tskb->protocol = htons(ETH_P_802_3);\n\telse\n\t\t \n\t\tskb->protocol = htons(ETH_P_802_2);\n}\n\n \nstatic inline void *vlan_remove_tag(struct sk_buff *skb, u16 *vlan_tci)\n{\n\tstruct vlan_hdr *vhdr = (struct vlan_hdr *)(skb->data + ETH_HLEN);\n\n\t*vlan_tci = ntohs(vhdr->h_vlan_TCI);\n\n\tmemmove(skb->data + VLAN_HLEN, skb->data, 2 * ETH_ALEN);\n\tvlan_set_encap_proto(skb, vhdr);\n\treturn __skb_pull(skb, VLAN_HLEN);\n}\n\n \nstatic inline bool skb_vlan_tagged(const struct sk_buff *skb)\n{\n\tif (!skb_vlan_tag_present(skb) &&\n\t    likely(!eth_type_vlan(skb->protocol)))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic inline bool skb_vlan_tagged_multi(struct sk_buff *skb)\n{\n\t__be16 protocol = skb->protocol;\n\n\tif (!skb_vlan_tag_present(skb)) {\n\t\tstruct vlan_ethhdr *veh;\n\n\t\tif (likely(!eth_type_vlan(protocol)))\n\t\t\treturn false;\n\n\t\tif (unlikely(!pskb_may_pull(skb, VLAN_ETH_HLEN)))\n\t\t\treturn false;\n\n\t\tveh = skb_vlan_eth_hdr(skb);\n\t\tprotocol = veh->h_vlan_encapsulated_proto;\n\t}\n\n\tif (!eth_type_vlan(protocol))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic inline netdev_features_t vlan_features_check(struct sk_buff *skb,\n\t\t\t\t\t\t    netdev_features_t features)\n{\n\tif (skb_vlan_tagged_multi(skb)) {\n\t\t \n\t\tfeatures &= NETIF_F_SG | NETIF_F_HIGHDMA | NETIF_F_HW_CSUM |\n\t\t\t    NETIF_F_FRAGLIST | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t    NETIF_F_HW_VLAN_STAG_TX;\n\t}\n\n\treturn features;\n}\n\n \nstatic inline unsigned long compare_vlan_header(const struct vlan_hdr *h1,\n\t\t\t\t\t\tconst struct vlan_hdr *h2)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\treturn *(u32 *)h1 ^ *(u32 *)h2;\n#else\n\treturn ((__force u32)h1->h_vlan_TCI ^ (__force u32)h2->h_vlan_TCI) |\n\t       ((__force u32)h1->h_vlan_encapsulated_proto ^\n\t\t(__force u32)h2->h_vlan_encapsulated_proto);\n#endif\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}