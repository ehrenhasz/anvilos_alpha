{
  "module_name": "mhi.h",
  "hash_id": "82e0bd0df6b432f173bb94bf5e11d3aa877ebde2d21bacc12f1cbff4c38449a3",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mhi.h",
  "human_readable_source": " \n \n#ifndef _MHI_H_\n#define _MHI_H_\n\n#include <linux/device.h>\n#include <linux/dma-direction.h>\n#include <linux/mutex.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n\n#define MHI_MAX_OEM_PK_HASH_SEGMENTS 16\n\nstruct mhi_chan;\nstruct mhi_event;\nstruct mhi_ctxt;\nstruct mhi_cmd;\nstruct mhi_buf_info;\n\n \nenum mhi_callback {\n\tMHI_CB_IDLE,\n\tMHI_CB_PENDING_DATA,\n\tMHI_CB_LPM_ENTER,\n\tMHI_CB_LPM_EXIT,\n\tMHI_CB_EE_RDDM,\n\tMHI_CB_EE_MISSION_MODE,\n\tMHI_CB_SYS_ERROR,\n\tMHI_CB_FATAL_ERROR,\n\tMHI_CB_BW_REQ,\n};\n\n \nenum mhi_flags {\n\tMHI_EOB = BIT(0),\n\tMHI_EOT = BIT(1),\n\tMHI_CHAIN = BIT(2),\n};\n\n \nenum mhi_device_type {\n\tMHI_DEVICE_XFER,\n\tMHI_DEVICE_CONTROLLER,\n};\n\n \nenum mhi_ch_type {\n\tMHI_CH_TYPE_INVALID = 0,\n\tMHI_CH_TYPE_OUTBOUND = DMA_TO_DEVICE,\n\tMHI_CH_TYPE_INBOUND = DMA_FROM_DEVICE,\n\tMHI_CH_TYPE_INBOUND_COALESCED = 3,\n};\n\n \nstruct image_info {\n\tstruct mhi_buf *mhi_buf;\n\t \n\tstruct bhi_vec_entry *bhi_vec;\n\t \n\tu32 entries;\n};\n\n \nstruct mhi_link_info {\n\tunsigned int target_link_speed;\n\tunsigned int target_link_width;\n};\n\n \nenum mhi_ee_type {\n\tMHI_EE_PBL,\n\tMHI_EE_SBL,\n\tMHI_EE_AMSS,\n\tMHI_EE_RDDM,\n\tMHI_EE_WFW,\n\tMHI_EE_PTHRU,\n\tMHI_EE_EDL,\n\tMHI_EE_FP,\n\tMHI_EE_MAX_SUPPORTED = MHI_EE_FP,\n\tMHI_EE_DISABLE_TRANSITION,  \n\tMHI_EE_NOT_SUPPORTED,\n\tMHI_EE_MAX,\n};\n\n \nenum mhi_state {\n\tMHI_STATE_RESET = 0x0,\n\tMHI_STATE_READY = 0x1,\n\tMHI_STATE_M0 = 0x2,\n\tMHI_STATE_M1 = 0x3,\n\tMHI_STATE_M2 = 0x4,\n\tMHI_STATE_M3 = 0x5,\n\tMHI_STATE_M3_FAST = 0x6,\n\tMHI_STATE_BHI = 0x7,\n\tMHI_STATE_SYS_ERR = 0xFF,\n\tMHI_STATE_MAX,\n};\n\n \nenum mhi_ch_ee_mask {\n\tMHI_CH_EE_PBL = BIT(MHI_EE_PBL),\n\tMHI_CH_EE_SBL = BIT(MHI_EE_SBL),\n\tMHI_CH_EE_AMSS = BIT(MHI_EE_AMSS),\n\tMHI_CH_EE_RDDM = BIT(MHI_EE_RDDM),\n\tMHI_CH_EE_PTHRU = BIT(MHI_EE_PTHRU),\n\tMHI_CH_EE_WFW = BIT(MHI_EE_WFW),\n\tMHI_CH_EE_EDL = BIT(MHI_EE_EDL),\n};\n\n \nenum mhi_er_data_type {\n\tMHI_ER_DATA,\n\tMHI_ER_CTRL,\n};\n\n \nenum mhi_db_brst_mode {\n\tMHI_DB_BRST_DISABLE = 0x2,\n\tMHI_DB_BRST_ENABLE = 0x3,\n};\n\n \nstruct mhi_channel_config {\n\tchar *name;\n\tu32 num;\n\tu32 num_elements;\n\tu32 local_elements;\n\tu32 event_ring;\n\tenum dma_data_direction dir;\n\tenum mhi_ch_type type;\n\tu32 ee_mask;\n\tu32 pollcfg;\n\tenum mhi_db_brst_mode doorbell;\n\tbool lpm_notify;\n\tbool offload_channel;\n\tbool doorbell_mode_switch;\n\tbool auto_queue;\n\tbool wake_capable;\n};\n\n \nstruct mhi_event_config {\n\tu32 num_elements;\n\tu32 irq_moderation_ms;\n\tu32 irq;\n\tu32 channel;\n\tu32 priority;\n\tenum mhi_db_brst_mode mode;\n\tenum mhi_er_data_type data_type;\n\tbool hardware_event;\n\tbool client_managed;\n\tbool offload_channel;\n};\n\n \nstruct mhi_controller_config {\n\tu32 max_channels;\n\tu32 timeout_ms;\n\tu32 buf_len;\n\tu32 num_channels;\n\tconst struct mhi_channel_config *ch_cfg;\n\tu32 num_events;\n\tstruct mhi_event_config *event_cfg;\n\tbool use_bounce_buf;\n\tbool m2_no_db;\n};\n\n \nstruct mhi_controller {\n\tstruct device *cntrl_dev;\n\tstruct mhi_device *mhi_dev;\n\tstruct dentry *debugfs_dentry;\n\tvoid __iomem *regs;\n\tvoid __iomem *bhi;\n\tvoid __iomem *bhie;\n\tvoid __iomem *wake_db;\n\n\tdma_addr_t iova_start;\n\tdma_addr_t iova_stop;\n\tconst char *fw_image;\n\tconst u8 *fw_data;\n\tsize_t fw_sz;\n\tconst char *edl_image;\n\tsize_t rddm_size;\n\tsize_t sbl_size;\n\tsize_t seg_len;\n\tsize_t reg_len;\n\tstruct image_info *fbc_image;\n\tstruct image_info *rddm_image;\n\tstruct mhi_chan *mhi_chan;\n\tstruct list_head lpm_chans;\n\tint *irq;\n\tu32 max_chan;\n\tu32 total_ev_rings;\n\tu32 hw_ev_rings;\n\tu32 sw_ev_rings;\n\tu32 nr_irqs;\n\tu32 family_number;\n\tu32 device_number;\n\tu32 major_version;\n\tu32 minor_version;\n\tu32 serial_number;\n\tu32 oem_pk_hash[MHI_MAX_OEM_PK_HASH_SEGMENTS];\n\n\tstruct mhi_event *mhi_event;\n\tstruct mhi_cmd *mhi_cmd;\n\tstruct mhi_ctxt *mhi_ctxt;\n\n\tstruct mutex pm_mutex;\n\trwlock_t pm_lock;\n\tu32 timeout_ms;\n\tu32 pm_state;\n\tu32 db_access;\n\tenum mhi_ee_type ee;\n\tenum mhi_state dev_state;\n\tatomic_t dev_wake;\n\tatomic_t pending_pkts;\n\tu32 M0, M2, M3;\n\tstruct list_head transition_list;\n\tspinlock_t transition_lock;\n\tspinlock_t wlock;\n\tstruct mhi_link_info mhi_link_info;\n\tstruct work_struct st_worker;\n\tstruct workqueue_struct *hiprio_wq;\n\twait_queue_head_t state_event;\n\n\tvoid (*status_cb)(struct mhi_controller *mhi_cntrl,\n\t\t\t  enum mhi_callback cb);\n\tvoid (*wake_get)(struct mhi_controller *mhi_cntrl, bool override);\n\tvoid (*wake_put)(struct mhi_controller *mhi_cntrl, bool override);\n\tvoid (*wake_toggle)(struct mhi_controller *mhi_cntrl);\n\tint (*runtime_get)(struct mhi_controller *mhi_cntrl);\n\tvoid (*runtime_put)(struct mhi_controller *mhi_cntrl);\n\tint (*map_single)(struct mhi_controller *mhi_cntrl,\n\t\t\t  struct mhi_buf_info *buf);\n\tvoid (*unmap_single)(struct mhi_controller *mhi_cntrl,\n\t\t\t     struct mhi_buf_info *buf);\n\tint (*read_reg)(struct mhi_controller *mhi_cntrl, void __iomem *addr,\n\t\t\tu32 *out);\n\tvoid (*write_reg)(struct mhi_controller *mhi_cntrl, void __iomem *addr,\n\t\t\t  u32 val);\n\tvoid (*reset)(struct mhi_controller *mhi_cntrl);\n\n\tsize_t buffer_len;\n\tint index;\n\tbool bounce_buf;\n\tbool fbc_download;\n\tbool wake_set;\n\tunsigned long irq_flags;\n\tu32 mru;\n};\n\n \nstruct mhi_device {\n\tconst struct mhi_device_id *id;\n\tconst char *name;\n\tstruct mhi_controller *mhi_cntrl;\n\tstruct mhi_chan *ul_chan;\n\tstruct mhi_chan *dl_chan;\n\tstruct device dev;\n\tenum mhi_device_type dev_type;\n\tint ul_chan_id;\n\tint dl_chan_id;\n\tu32 dev_wake;\n};\n\n \nstruct mhi_result {\n\tvoid *buf_addr;\n\tsize_t bytes_xferd;\n\tenum dma_data_direction dir;\n\tint transaction_status;\n};\n\n \nstruct mhi_buf {\n\tvoid *buf;\n\tconst char *name;\n\tdma_addr_t dma_addr;\n\tsize_t len;\n};\n\n \nstruct mhi_driver {\n\tconst struct mhi_device_id *id_table;\n\tint (*probe)(struct mhi_device *mhi_dev,\n\t\t     const struct mhi_device_id *id);\n\tvoid (*remove)(struct mhi_device *mhi_dev);\n\tvoid (*ul_xfer_cb)(struct mhi_device *mhi_dev,\n\t\t\t   struct mhi_result *result);\n\tvoid (*dl_xfer_cb)(struct mhi_device *mhi_dev,\n\t\t\t   struct mhi_result *result);\n\tvoid (*status_cb)(struct mhi_device *mhi_dev, enum mhi_callback mhi_cb);\n\tstruct device_driver driver;\n};\n\n#define to_mhi_driver(drv) container_of(drv, struct mhi_driver, driver)\n#define to_mhi_device(dev) container_of(dev, struct mhi_device, dev)\n\n \nstruct mhi_controller *mhi_alloc_controller(void);\n\n \nvoid mhi_free_controller(struct mhi_controller *mhi_cntrl);\n\n \nint mhi_register_controller(struct mhi_controller *mhi_cntrl,\n\t\t\tconst struct mhi_controller_config *config);\n\n \nvoid mhi_unregister_controller(struct mhi_controller *mhi_cntrl);\n\n \n#define module_mhi_driver(mhi_drv) \\\n\tmodule_driver(mhi_drv, mhi_driver_register, \\\n\t\t      mhi_driver_unregister)\n\n \n#define mhi_driver_register(mhi_drv) \\\n\t__mhi_driver_register(mhi_drv, THIS_MODULE)\n\n \nint __mhi_driver_register(struct mhi_driver *mhi_drv, struct module *owner);\n\n \nvoid mhi_driver_unregister(struct mhi_driver *mhi_drv);\n\n \nvoid mhi_set_mhi_state(struct mhi_controller *mhi_cntrl,\n\t\t       enum mhi_state state);\n\n \nvoid mhi_notify(struct mhi_device *mhi_dev, enum mhi_callback cb_reason);\n\n \nint mhi_get_free_desc_count(struct mhi_device *mhi_dev,\n\t\t\t\tenum dma_data_direction dir);\n\n \nint mhi_prepare_for_power_up(struct mhi_controller *mhi_cntrl);\n\n \nint mhi_async_power_up(struct mhi_controller *mhi_cntrl);\n\n \nint mhi_sync_power_up(struct mhi_controller *mhi_cntrl);\n\n \nvoid mhi_power_down(struct mhi_controller *mhi_cntrl, bool graceful);\n\n \nvoid mhi_unprepare_after_power_down(struct mhi_controller *mhi_cntrl);\n\n \nint mhi_pm_suspend(struct mhi_controller *mhi_cntrl);\n\n \nint mhi_pm_resume(struct mhi_controller *mhi_cntrl);\n\n \nint mhi_pm_resume_force(struct mhi_controller *mhi_cntrl);\n\n \nint mhi_download_rddm_image(struct mhi_controller *mhi_cntrl, bool in_panic);\n\n \nint mhi_force_rddm_mode(struct mhi_controller *mhi_cntrl);\n\n \nenum mhi_ee_type mhi_get_exec_env(struct mhi_controller *mhi_cntrl);\n\n \nenum mhi_state mhi_get_mhi_state(struct mhi_controller *mhi_cntrl);\n\n \nvoid mhi_soc_reset(struct mhi_controller *mhi_cntrl);\n\n \nvoid mhi_device_get(struct mhi_device *mhi_dev);\n\n \nint mhi_device_get_sync(struct mhi_device *mhi_dev);\n\n \nvoid mhi_device_put(struct mhi_device *mhi_dev);\n\n \nint mhi_prepare_for_transfer(struct mhi_device *mhi_dev);\n\n \nint mhi_prepare_for_transfer_autoqueue(struct mhi_device *mhi_dev);\n\n \nvoid mhi_unprepare_from_transfer(struct mhi_device *mhi_dev);\n\n \nint mhi_queue_dma(struct mhi_device *mhi_dev, enum dma_data_direction dir,\n\t\t  struct mhi_buf *mhi_buf, size_t len, enum mhi_flags mflags);\n\n \nint mhi_queue_buf(struct mhi_device *mhi_dev, enum dma_data_direction dir,\n\t\t  void *buf, size_t len, enum mhi_flags mflags);\n\n \nint mhi_queue_skb(struct mhi_device *mhi_dev, enum dma_data_direction dir,\n\t\t  struct sk_buff *skb, size_t len, enum mhi_flags mflags);\n\n \nbool mhi_queue_is_full(struct mhi_device *mhi_dev, enum dma_data_direction dir);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}