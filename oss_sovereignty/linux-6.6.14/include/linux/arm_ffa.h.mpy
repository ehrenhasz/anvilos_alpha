{
  "module_name": "arm_ffa.h",
  "hash_id": "917081e811bbd69f1ab0317852420ba89cdcf6b36b08b173e54dc52da1f826f5",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/arm_ffa.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_ARM_FFA_H\n#define _LINUX_ARM_FFA_H\n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/uuid.h>\n\n#define FFA_SMC(calling_convention, func_num)\t\t\t\t\\\n\tARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, (calling_convention),\t\\\n\t\t\t   ARM_SMCCC_OWNER_STANDARD, (func_num))\n\n#define FFA_SMC_32(func_num)\tFFA_SMC(ARM_SMCCC_SMC_32, (func_num))\n#define FFA_SMC_64(func_num)\tFFA_SMC(ARM_SMCCC_SMC_64, (func_num))\n\n#define FFA_ERROR\t\t\tFFA_SMC_32(0x60)\n#define FFA_SUCCESS\t\t\tFFA_SMC_32(0x61)\n#define FFA_INTERRUPT\t\t\tFFA_SMC_32(0x62)\n#define FFA_VERSION\t\t\tFFA_SMC_32(0x63)\n#define FFA_FEATURES\t\t\tFFA_SMC_32(0x64)\n#define FFA_RX_RELEASE\t\t\tFFA_SMC_32(0x65)\n#define FFA_RXTX_MAP\t\t\tFFA_SMC_32(0x66)\n#define FFA_FN64_RXTX_MAP\t\tFFA_SMC_64(0x66)\n#define FFA_RXTX_UNMAP\t\t\tFFA_SMC_32(0x67)\n#define FFA_PARTITION_INFO_GET\t\tFFA_SMC_32(0x68)\n#define FFA_ID_GET\t\t\tFFA_SMC_32(0x69)\n#define FFA_MSG_POLL\t\t\tFFA_SMC_32(0x6A)\n#define FFA_MSG_WAIT\t\t\tFFA_SMC_32(0x6B)\n#define FFA_YIELD\t\t\tFFA_SMC_32(0x6C)\n#define FFA_RUN\t\t\t\tFFA_SMC_32(0x6D)\n#define FFA_MSG_SEND\t\t\tFFA_SMC_32(0x6E)\n#define FFA_MSG_SEND_DIRECT_REQ\t\tFFA_SMC_32(0x6F)\n#define FFA_FN64_MSG_SEND_DIRECT_REQ\tFFA_SMC_64(0x6F)\n#define FFA_MSG_SEND_DIRECT_RESP\tFFA_SMC_32(0x70)\n#define FFA_FN64_MSG_SEND_DIRECT_RESP\tFFA_SMC_64(0x70)\n#define FFA_MEM_DONATE\t\t\tFFA_SMC_32(0x71)\n#define FFA_FN64_MEM_DONATE\t\tFFA_SMC_64(0x71)\n#define FFA_MEM_LEND\t\t\tFFA_SMC_32(0x72)\n#define FFA_FN64_MEM_LEND\t\tFFA_SMC_64(0x72)\n#define FFA_MEM_SHARE\t\t\tFFA_SMC_32(0x73)\n#define FFA_FN64_MEM_SHARE\t\tFFA_SMC_64(0x73)\n#define FFA_MEM_RETRIEVE_REQ\t\tFFA_SMC_32(0x74)\n#define FFA_FN64_MEM_RETRIEVE_REQ\tFFA_SMC_64(0x74)\n#define FFA_MEM_RETRIEVE_RESP\t\tFFA_SMC_32(0x75)\n#define FFA_MEM_RELINQUISH\t\tFFA_SMC_32(0x76)\n#define FFA_MEM_RECLAIM\t\t\tFFA_SMC_32(0x77)\n#define FFA_MEM_OP_PAUSE\t\tFFA_SMC_32(0x78)\n#define FFA_MEM_OP_RESUME\t\tFFA_SMC_32(0x79)\n#define FFA_MEM_FRAG_RX\t\t\tFFA_SMC_32(0x7A)\n#define FFA_MEM_FRAG_TX\t\t\tFFA_SMC_32(0x7B)\n#define FFA_NORMAL_WORLD_RESUME\t\tFFA_SMC_32(0x7C)\n\n \n#ifdef CONFIG_64BIT\n#define FFA_FN_NATIVE(name)\tFFA_FN64_##name\n#else\n#define FFA_FN_NATIVE(name)\tFFA_##name\n#endif\n\n \n#define FFA_RET_SUCCESS            (0)\n#define FFA_RET_NOT_SUPPORTED      (-1)\n#define FFA_RET_INVALID_PARAMETERS (-2)\n#define FFA_RET_NO_MEMORY          (-3)\n#define FFA_RET_BUSY               (-4)\n#define FFA_RET_INTERRUPTED        (-5)\n#define FFA_RET_DENIED             (-6)\n#define FFA_RET_RETRY              (-7)\n#define FFA_RET_ABORTED            (-8)\n\n \n#define FFA_MAJOR_VERSION_MASK\tGENMASK(30, 16)\n#define FFA_MINOR_VERSION_MASK\tGENMASK(15, 0)\n#define FFA_MAJOR_VERSION(x)\t((u16)(FIELD_GET(FFA_MAJOR_VERSION_MASK, (x))))\n#define FFA_MINOR_VERSION(x)\t((u16)(FIELD_GET(FFA_MINOR_VERSION_MASK, (x))))\n#define FFA_PACK_VERSION_INFO(major, minor)\t\t\t\\\n\t(FIELD_PREP(FFA_MAJOR_VERSION_MASK, (major)) |\t\t\\\n\t FIELD_PREP(FFA_MINOR_VERSION_MASK, (minor)))\n#define FFA_VERSION_1_0\t\tFFA_PACK_VERSION_INFO(1, 0)\n\n \n#define FFA_PAGE_SIZE\t\tSZ_4K\n\n \n#define FFA_FEAT_RXTX_MIN_SZ_4K\t\t0\n#define FFA_FEAT_RXTX_MIN_SZ_64K\t1\n#define FFA_FEAT_RXTX_MIN_SZ_16K\t2\n\n \nstruct ffa_device {\n\tu32 id;\n\tint vm_id;\n\tbool mode_32bit;\n\tuuid_t uuid;\n\tstruct device dev;\n\tconst struct ffa_ops *ops;\n};\n\n#define to_ffa_dev(d) container_of(d, struct ffa_device, dev)\n\nstruct ffa_device_id {\n\tuuid_t uuid;\n};\n\nstruct ffa_driver {\n\tconst char *name;\n\tint (*probe)(struct ffa_device *sdev);\n\tvoid (*remove)(struct ffa_device *sdev);\n\tconst struct ffa_device_id *id_table;\n\n\tstruct device_driver driver;\n};\n\n#define to_ffa_driver(d) container_of(d, struct ffa_driver, driver)\n\nstatic inline void ffa_dev_set_drvdata(struct ffa_device *fdev, void *data)\n{\n\tdev_set_drvdata(&fdev->dev, data);\n}\n\nstatic inline void *ffa_dev_get_drvdata(struct ffa_device *fdev)\n{\n\treturn dev_get_drvdata(&fdev->dev);\n}\n\n#if IS_REACHABLE(CONFIG_ARM_FFA_TRANSPORT)\nstruct ffa_device *ffa_device_register(const uuid_t *uuid, int vm_id,\n\t\t\t\t       const struct ffa_ops *ops);\nvoid ffa_device_unregister(struct ffa_device *ffa_dev);\nint ffa_driver_register(struct ffa_driver *driver, struct module *owner,\n\t\t\tconst char *mod_name);\nvoid ffa_driver_unregister(struct ffa_driver *driver);\nbool ffa_device_is_valid(struct ffa_device *ffa_dev);\n\n#else\nstatic inline\nstruct ffa_device *ffa_device_register(const uuid_t *uuid, int vm_id,\n\t\t\t\t       const struct ffa_ops *ops)\n{\n\treturn NULL;\n}\n\nstatic inline void ffa_device_unregister(struct ffa_device *dev) {}\n\nstatic inline int\nffa_driver_register(struct ffa_driver *driver, struct module *owner,\n\t\t    const char *mod_name)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void ffa_driver_unregister(struct ffa_driver *driver) {}\n\nstatic inline\nbool ffa_device_is_valid(struct ffa_device *ffa_dev) { return false; }\n\n#endif  \n\n#define ffa_register(driver) \\\n\tffa_driver_register(driver, THIS_MODULE, KBUILD_MODNAME)\n#define ffa_unregister(driver) \\\n\tffa_driver_unregister(driver)\n\n \n#define module_ffa_driver(__ffa_driver)\t\\\n\tmodule_driver(__ffa_driver, ffa_register, ffa_unregister)\n\n \nstruct ffa_partition_info {\n\tu16 id;\n\tu16 exec_ctxt;\n \n#define FFA_PARTITION_DIRECT_RECV\tBIT(0)\n \n#define FFA_PARTITION_DIRECT_SEND\tBIT(1)\n \n#define FFA_PARTITION_INDIRECT_MSG\tBIT(2)\n \n#define FFA_PARTITION_AARCH64_EXEC\tBIT(8)\n\tu32 properties;\n\tu32 uuid[4];\n};\n\n \nstruct ffa_send_direct_data {\n\tunsigned long data0;  \n\tunsigned long data1;  \n\tunsigned long data2;  \n\tunsigned long data3;  \n\tunsigned long data4;  \n};\n\nstruct ffa_mem_region_addr_range {\n\t \n\tu64 address;\n\t \n\tu32 pg_cnt;\n\tu32 reserved;\n};\n\nstruct ffa_composite_mem_region {\n\t \n\tu32 total_pg_cnt;\n\t \n\tu32 addr_range_cnt;\n\tu64 reserved;\n\t \n\tstruct ffa_mem_region_addr_range constituents[];\n};\n\nstruct ffa_mem_region_attributes {\n\t \n\tu16 receiver;\n\t \n#define FFA_MEM_EXEC\t\tBIT(3)\n#define FFA_MEM_NO_EXEC\t\tBIT(2)\n#define FFA_MEM_RW\t\tBIT(1)\n#define FFA_MEM_RO\t\tBIT(0)\n\tu8 attrs;\n\t \n#define FFA_MEM_RETRIEVE_SELF_BORROWER\tBIT(0)\n\tu8 flag;\n\t \n\tu32 composite_off;\n\tu64 reserved;\n};\n\nstruct ffa_mem_region {\n\t \n\tu16 sender_id;\n#define FFA_MEM_NORMAL\t\tBIT(5)\n#define FFA_MEM_DEVICE\t\tBIT(4)\n\n#define FFA_MEM_WRITE_BACK\t(3 << 2)\n#define FFA_MEM_NON_CACHEABLE\t(1 << 2)\n\n#define FFA_DEV_nGnRnE\t\t(0 << 2)\n#define FFA_DEV_nGnRE\t\t(1 << 2)\n#define FFA_DEV_nGRE\t\t(2 << 2)\n#define FFA_DEV_GRE\t\t(3 << 2)\n\n#define FFA_MEM_NON_SHAREABLE\t(0)\n#define FFA_MEM_OUTER_SHAREABLE\t(2)\n#define FFA_MEM_INNER_SHAREABLE\t(3)\n\tu8 attributes;\n\tu8 reserved_0;\n \n#define FFA_MEM_CLEAR\t\t\tBIT(0)\n \n#define FFA_TIME_SLICE_ENABLE\t\tBIT(1)\n\n#define FFA_MEM_RETRIEVE_TYPE_IN_RESP\t(0 << 3)\n#define FFA_MEM_RETRIEVE_TYPE_SHARE\t(1 << 3)\n#define FFA_MEM_RETRIEVE_TYPE_LEND\t(2 << 3)\n#define FFA_MEM_RETRIEVE_TYPE_DONATE\t(3 << 3)\n\n#define FFA_MEM_RETRIEVE_ADDR_ALIGN_HINT\tBIT(9)\n#define FFA_MEM_RETRIEVE_ADDR_ALIGN(x)\t\t((x) << 5)\n\t \n\tu32 flags;\n#define HANDLE_LOW_MASK\t\tGENMASK_ULL(31, 0)\n#define HANDLE_HIGH_MASK\tGENMASK_ULL(63, 32)\n#define HANDLE_LOW(x)\t\t((u32)(FIELD_GET(HANDLE_LOW_MASK, (x))))\n#define\tHANDLE_HIGH(x)\t\t((u32)(FIELD_GET(HANDLE_HIGH_MASK, (x))))\n\n#define PACK_HANDLE(l, h)\t\t\\\n\t(FIELD_PREP(HANDLE_LOW_MASK, (l)) | FIELD_PREP(HANDLE_HIGH_MASK, (h)))\n\t \n\tu64 handle;\n\t \n\tu64 tag;\n\tu32 reserved_1;\n\t \n\tu32 ep_count;\n\t \n\tstruct ffa_mem_region_attributes ep_mem_access[];\n};\n\n#define\tCOMPOSITE_OFFSET(x)\t\\\n\t(offsetof(struct ffa_mem_region, ep_mem_access[x]))\n#define CONSTITUENTS_OFFSET(x)\t\\\n\t(offsetof(struct ffa_composite_mem_region, constituents[x]))\n#define COMPOSITE_CONSTITUENTS_OFFSET(x, y)\t\\\n\t(COMPOSITE_OFFSET(x) + CONSTITUENTS_OFFSET(y))\n\nstruct ffa_mem_ops_args {\n\tbool use_txbuf;\n\tu32 nattrs;\n\tu32 flags;\n\tu64 tag;\n\tu64 g_handle;\n\tstruct scatterlist *sg;\n\tstruct ffa_mem_region_attributes *attrs;\n};\n\nstruct ffa_info_ops {\n\tu32 (*api_version_get)(void);\n\tint (*partition_info_get)(const char *uuid_str,\n\t\t\t\t  struct ffa_partition_info *buffer);\n};\n\nstruct ffa_msg_ops {\n\tvoid (*mode_32bit_set)(struct ffa_device *dev);\n\tint (*sync_send_receive)(struct ffa_device *dev,\n\t\t\t\t struct ffa_send_direct_data *data);\n};\n\nstruct ffa_mem_ops {\n\tint (*memory_reclaim)(u64 g_handle, u32 flags);\n\tint (*memory_share)(struct ffa_mem_ops_args *args);\n\tint (*memory_lend)(struct ffa_mem_ops_args *args);\n};\n\nstruct ffa_ops {\n\tconst struct ffa_info_ops *info_ops;\n\tconst struct ffa_msg_ops *msg_ops;\n\tconst struct ffa_mem_ops *mem_ops;\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}