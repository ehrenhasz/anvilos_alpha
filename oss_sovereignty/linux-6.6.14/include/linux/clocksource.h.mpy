{
  "module_name": "clocksource.h",
  "hash_id": "a73ab8f1680d442c929b8fb1b154f35d830a5c81d7f1d83a9b6ec6cb2c76288b",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/clocksource.h",
  "human_readable_source": " \n \n#ifndef _LINUX_CLOCKSOURCE_H\n#define _LINUX_CLOCKSOURCE_H\n\n#include <linux/types.h>\n#include <linux/timex.h>\n#include <linux/time.h>\n#include <linux/list.h>\n#include <linux/cache.h>\n#include <linux/timer.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/clocksource_ids.h>\n#include <asm/div64.h>\n#include <asm/io.h>\n\nstruct clocksource;\nstruct module;\n\n#if defined(CONFIG_ARCH_CLOCKSOURCE_DATA) || \\\n    defined(CONFIG_GENERIC_GETTIMEOFDAY)\n#include <asm/clocksource.h>\n#endif\n\n#include <vdso/clocksource.h>\n\n \nstruct clocksource {\n\tu64\t\t\t(*read)(struct clocksource *cs);\n\tu64\t\t\tmask;\n\tu32\t\t\tmult;\n\tu32\t\t\tshift;\n\tu64\t\t\tmax_idle_ns;\n\tu32\t\t\tmaxadj;\n\tu32\t\t\tuncertainty_margin;\n#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA\n\tstruct arch_clocksource_data archdata;\n#endif\n\tu64\t\t\tmax_cycles;\n\tconst char\t\t*name;\n\tstruct list_head\tlist;\n\tint\t\t\trating;\n\tenum clocksource_ids\tid;\n\tenum vdso_clock_mode\tvdso_clock_mode;\n\tunsigned long\t\tflags;\n\n\tint\t\t\t(*enable)(struct clocksource *cs);\n\tvoid\t\t\t(*disable)(struct clocksource *cs);\n\tvoid\t\t\t(*suspend)(struct clocksource *cs);\n\tvoid\t\t\t(*resume)(struct clocksource *cs);\n\tvoid\t\t\t(*mark_unstable)(struct clocksource *cs);\n\tvoid\t\t\t(*tick_stable)(struct clocksource *cs);\n\n\t \n#ifdef CONFIG_CLOCKSOURCE_WATCHDOG\n\t \n\tstruct list_head\twd_list;\n\tu64\t\t\tcs_last;\n\tu64\t\t\twd_last;\n#endif\n\tstruct module\t\t*owner;\n};\n\n \n#define CLOCK_SOURCE_IS_CONTINUOUS\t\t0x01\n#define CLOCK_SOURCE_MUST_VERIFY\t\t0x02\n\n#define CLOCK_SOURCE_WATCHDOG\t\t\t0x10\n#define CLOCK_SOURCE_VALID_FOR_HRES\t\t0x20\n#define CLOCK_SOURCE_UNSTABLE\t\t\t0x40\n#define CLOCK_SOURCE_SUSPEND_NONSTOP\t\t0x80\n#define CLOCK_SOURCE_RESELECT\t\t\t0x100\n#define CLOCK_SOURCE_VERIFY_PERCPU\t\t0x200\n \n#define CLOCKSOURCE_MASK(bits) GENMASK_ULL((bits) - 1, 0)\n\nstatic inline u32 clocksource_freq2mult(u32 freq, u32 shift_constant, u64 from)\n{\n\t \n\tu64 tmp = ((u64)from) << shift_constant;\n\n\ttmp += freq/2;  \n\tdo_div(tmp, freq);\n\n\treturn (u32)tmp;\n}\n\n \nstatic inline u32 clocksource_khz2mult(u32 khz, u32 shift_constant)\n{\n\treturn clocksource_freq2mult(khz, shift_constant, NSEC_PER_MSEC);\n}\n\n \nstatic inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)\n{\n\treturn clocksource_freq2mult(hz, shift_constant, NSEC_PER_SEC);\n}\n\n \nstatic inline s64 clocksource_cyc2ns(u64 cycles, u32 mult, u32 shift)\n{\n\treturn ((u64) cycles * mult) >> shift;\n}\n\n\nextern int clocksource_unregister(struct clocksource*);\nextern void clocksource_touch_watchdog(void);\nextern void clocksource_change_rating(struct clocksource *cs, int rating);\nextern void clocksource_suspend(void);\nextern void clocksource_resume(void);\nextern struct clocksource * __init clocksource_default_clock(void);\nextern void clocksource_mark_unstable(struct clocksource *cs);\nextern void\nclocksource_start_suspend_timing(struct clocksource *cs, u64 start_cycles);\nextern u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 now);\n\nextern u64\nclocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cycles);\nextern void\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 minsec);\n\n \nextern int\n__clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq);\nextern void\n__clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq);\n\n \nstatic inline int __clocksource_register(struct clocksource *cs)\n{\n\treturn __clocksource_register_scale(cs, 1, 0);\n}\n\nstatic inline int clocksource_register_hz(struct clocksource *cs, u32 hz)\n{\n\treturn __clocksource_register_scale(cs, 1, hz);\n}\n\nstatic inline int clocksource_register_khz(struct clocksource *cs, u32 khz)\n{\n\treturn __clocksource_register_scale(cs, 1000, khz);\n}\n\nstatic inline void __clocksource_update_freq_hz(struct clocksource *cs, u32 hz)\n{\n\t__clocksource_update_freq_scale(cs, 1, hz);\n}\n\nstatic inline void __clocksource_update_freq_khz(struct clocksource *cs, u32 khz)\n{\n\t__clocksource_update_freq_scale(cs, 1000, khz);\n}\n\n#ifdef CONFIG_ARCH_CLOCKSOURCE_INIT\nextern void clocksource_arch_init(struct clocksource *cs);\n#else\nstatic inline void clocksource_arch_init(struct clocksource *cs) { }\n#endif\n\nextern int timekeeping_notify(struct clocksource *clock);\n\nextern u64 clocksource_mmio_readl_up(struct clocksource *);\nextern u64 clocksource_mmio_readl_down(struct clocksource *);\nextern u64 clocksource_mmio_readw_up(struct clocksource *);\nextern u64 clocksource_mmio_readw_down(struct clocksource *);\n\nextern int clocksource_mmio_init(void __iomem *, const char *,\n\tunsigned long, int, unsigned, u64 (*)(struct clocksource *));\n\nextern int clocksource_i8253_init(void);\n\n#define TIMER_OF_DECLARE(name, compat, fn) \\\n\tOF_DECLARE_1_RET(timer, name, compat, fn)\n\n#ifdef CONFIG_TIMER_PROBE\nextern void timer_probe(void);\n#else\nstatic inline void timer_probe(void) {}\n#endif\n\n#define TIMER_ACPI_DECLARE(name, table_id, fn)\t\t\\\n\tACPI_DECLARE_PROBE_ENTRY(timer, name, table_id, 0, NULL, 0, fn)\n\nextern ulong max_cswd_read_retries;\nvoid clocksource_verify_percpu(struct clocksource *cs);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}