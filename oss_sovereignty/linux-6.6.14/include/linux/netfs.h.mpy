{
  "module_name": "netfs.h",
  "hash_id": "32c1d584c870dcf1fa7011275ca4b882fa2c6f0adabc20d274f9be6455662086",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/netfs.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_NETFS_H\n#define _LINUX_NETFS_H\n\n#include <linux/workqueue.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/uio.h>\n\nenum netfs_sreq_ref_trace;\n\n \n#define folio_test_fscache(folio)\tfolio_test_private_2(folio)\n#define PageFsCache(page)\t\tPagePrivate2((page))\n#define SetPageFsCache(page)\t\tSetPagePrivate2((page))\n#define ClearPageFsCache(page)\t\tClearPagePrivate2((page))\n#define TestSetPageFsCache(page)\tTestSetPagePrivate2((page))\n#define TestClearPageFsCache(page)\tTestClearPagePrivate2((page))\n\n \nstatic inline void folio_start_fscache(struct folio *folio)\n{\n\tVM_BUG_ON_FOLIO(folio_test_private_2(folio), folio);\n\tfolio_get(folio);\n\tfolio_set_private_2(folio);\n}\n\n \nstatic inline void folio_end_fscache(struct folio *folio)\n{\n\tfolio_end_private_2(folio);\n}\n\n \nstatic inline void folio_wait_fscache(struct folio *folio)\n{\n\tfolio_wait_private_2(folio);\n}\n\n \nstatic inline int folio_wait_fscache_killable(struct folio *folio)\n{\n\treturn folio_wait_private_2_killable(folio);\n}\n\nstatic inline void set_page_fscache(struct page *page)\n{\n\tfolio_start_fscache(page_folio(page));\n}\n\nstatic inline void end_page_fscache(struct page *page)\n{\n\tfolio_end_private_2(page_folio(page));\n}\n\nstatic inline void wait_on_page_fscache(struct page *page)\n{\n\tfolio_wait_private_2(page_folio(page));\n}\n\nstatic inline int wait_on_page_fscache_killable(struct page *page)\n{\n\treturn folio_wait_private_2_killable(page_folio(page));\n}\n\nenum netfs_io_source {\n\tNETFS_FILL_WITH_ZEROES,\n\tNETFS_DOWNLOAD_FROM_SERVER,\n\tNETFS_READ_FROM_CACHE,\n\tNETFS_INVALID_READ,\n} __mode(byte);\n\ntypedef void (*netfs_io_terminated_t)(void *priv, ssize_t transferred_or_error,\n\t\t\t\t      bool was_async);\n\n \nstruct netfs_inode {\n\tstruct inode\t\tinode;\t\t \n\tconst struct netfs_request_ops *ops;\n#if IS_ENABLED(CONFIG_FSCACHE)\n\tstruct fscache_cookie\t*cache;\n#endif\n\tloff_t\t\t\tremote_i_size;\t \n};\n\n \nstruct netfs_cache_resources {\n\tconst struct netfs_cache_ops\t*ops;\n\tvoid\t\t\t\t*cache_priv;\n\tvoid\t\t\t\t*cache_priv2;\n\tunsigned int\t\t\tdebug_id;\t \n\tunsigned int\t\t\tinval_counter;\t \n};\n\n \nstruct netfs_io_subrequest {\n\tstruct netfs_io_request *rreq;\t\t \n\tstruct list_head\trreq_link;\t \n\tloff_t\t\t\tstart;\t\t \n\tsize_t\t\t\tlen;\t\t \n\tsize_t\t\t\ttransferred;\t \n\trefcount_t\t\tref;\n\tshort\t\t\terror;\t\t \n\tunsigned short\t\tdebug_index;\t \n\tenum netfs_io_source\tsource;\t\t \n\tunsigned long\t\tflags;\n#define NETFS_SREQ_COPY_TO_CACHE\t0\t \n#define NETFS_SREQ_CLEAR_TAIL\t\t1\t \n#define NETFS_SREQ_SHORT_IO\t\t2\t \n#define NETFS_SREQ_SEEK_DATA_READ\t3\t \n#define NETFS_SREQ_NO_PROGRESS\t\t4\t \n#define NETFS_SREQ_ONDEMAND\t\t5\t \n};\n\nenum netfs_io_origin {\n\tNETFS_READAHEAD,\t\t \n\tNETFS_READPAGE,\t\t\t \n\tNETFS_READ_FOR_WRITE,\t\t \n} __mode(byte);\n\n \nstruct netfs_io_request {\n\tstruct work_struct\twork;\n\tstruct inode\t\t*inode;\t\t \n\tstruct address_space\t*mapping;\t \n\tstruct netfs_cache_resources cache_resources;\n\tstruct list_head\tsubrequests;\t \n\tvoid\t\t\t*netfs_priv;\t \n\tunsigned int\t\tdebug_id;\n\tatomic_t\t\tnr_outstanding;\t \n\tatomic_t\t\tnr_copy_ops;\t \n\tsize_t\t\t\tsubmitted;\t \n\tsize_t\t\t\tlen;\t\t \n\tshort\t\t\terror;\t\t \n\tenum netfs_io_origin\torigin;\t\t \n\tloff_t\t\t\ti_size;\t\t \n\tloff_t\t\t\tstart;\t\t \n\tpgoff_t\t\t\tno_unlock_folio;  \n\trefcount_t\t\tref;\n\tunsigned long\t\tflags;\n#define NETFS_RREQ_INCOMPLETE_IO\t0\t \n#define NETFS_RREQ_COPY_TO_CACHE\t1\t \n#define NETFS_RREQ_NO_UNLOCK_FOLIO\t2\t \n#define NETFS_RREQ_DONT_UNLOCK_FOLIOS\t3\t \n#define NETFS_RREQ_FAILED\t\t4\t \n#define NETFS_RREQ_IN_PROGRESS\t\t5\t \n\tconst struct netfs_request_ops *netfs_ops;\n};\n\n \nstruct netfs_request_ops {\n\tint (*init_request)(struct netfs_io_request *rreq, struct file *file);\n\tvoid (*free_request)(struct netfs_io_request *rreq);\n\tint (*begin_cache_operation)(struct netfs_io_request *rreq);\n\n\tvoid (*expand_readahead)(struct netfs_io_request *rreq);\n\tbool (*clamp_length)(struct netfs_io_subrequest *subreq);\n\tvoid (*issue_read)(struct netfs_io_subrequest *subreq);\n\tbool (*is_still_valid)(struct netfs_io_request *rreq);\n\tint (*check_write_begin)(struct file *file, loff_t pos, unsigned len,\n\t\t\t\t struct folio **foliop, void **_fsdata);\n\tvoid (*done)(struct netfs_io_request *rreq);\n};\n\n \nenum netfs_read_from_hole {\n\tNETFS_READ_HOLE_IGNORE,\n\tNETFS_READ_HOLE_CLEAR,\n\tNETFS_READ_HOLE_FAIL,\n};\n\n \nstruct netfs_cache_ops {\n\t \n\tvoid (*end_operation)(struct netfs_cache_resources *cres);\n\n\t \n\tint (*read)(struct netfs_cache_resources *cres,\n\t\t    loff_t start_pos,\n\t\t    struct iov_iter *iter,\n\t\t    enum netfs_read_from_hole read_hole,\n\t\t    netfs_io_terminated_t term_func,\n\t\t    void *term_func_priv);\n\n\t \n\tint (*write)(struct netfs_cache_resources *cres,\n\t\t     loff_t start_pos,\n\t\t     struct iov_iter *iter,\n\t\t     netfs_io_terminated_t term_func,\n\t\t     void *term_func_priv);\n\n\t \n\tvoid (*expand_readahead)(struct netfs_cache_resources *cres,\n\t\t\t\t loff_t *_start, size_t *_len, loff_t i_size);\n\n\t \n\tenum netfs_io_source (*prepare_read)(struct netfs_io_subrequest *subreq,\n\t\t\t\t\t     loff_t i_size);\n\n\t \n\tint (*prepare_write)(struct netfs_cache_resources *cres,\n\t\t\t     loff_t *_start, size_t *_len, loff_t i_size,\n\t\t\t     bool no_space_allocated_yet);\n\n\t \n\tenum netfs_io_source (*prepare_ondemand_read)(struct netfs_cache_resources *cres,\n\t\t\t\t\t\t      loff_t start, size_t *_len,\n\t\t\t\t\t\t      loff_t i_size,\n\t\t\t\t\t\t      unsigned long *_flags, ino_t ino);\n\n\t \n\tint (*query_occupancy)(struct netfs_cache_resources *cres,\n\t\t\t       loff_t start, size_t len, size_t granularity,\n\t\t\t       loff_t *_data_start, size_t *_data_len);\n};\n\nstruct readahead_control;\nvoid netfs_readahead(struct readahead_control *);\nint netfs_read_folio(struct file *, struct folio *);\nint netfs_write_begin(struct netfs_inode *, struct file *,\n\t\tstruct address_space *, loff_t pos, unsigned int len,\n\t\tstruct folio **, void **fsdata);\n\nvoid netfs_subreq_terminated(struct netfs_io_subrequest *, ssize_t, bool);\nvoid netfs_get_subrequest(struct netfs_io_subrequest *subreq,\n\t\t\t  enum netfs_sreq_ref_trace what);\nvoid netfs_put_subrequest(struct netfs_io_subrequest *subreq,\n\t\t\t  bool was_async, enum netfs_sreq_ref_trace what);\nvoid netfs_stats_show(struct seq_file *);\nssize_t netfs_extract_user_iter(struct iov_iter *orig, size_t orig_len,\n\t\t\t\tstruct iov_iter *new,\n\t\t\t\tiov_iter_extraction_t extraction_flags);\n\n \nstatic inline struct netfs_inode *netfs_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct netfs_inode, inode);\n}\n\n \nstatic inline void netfs_inode_init(struct netfs_inode *ctx,\n\t\t\t\t    const struct netfs_request_ops *ops)\n{\n\tctx->ops = ops;\n\tctx->remote_i_size = i_size_read(&ctx->inode);\n#if IS_ENABLED(CONFIG_FSCACHE)\n\tctx->cache = NULL;\n#endif\n}\n\n \nstatic inline void netfs_resize_file(struct netfs_inode *ctx, loff_t new_i_size)\n{\n\tctx->remote_i_size = new_i_size;\n}\n\n \nstatic inline struct fscache_cookie *netfs_i_cookie(struct netfs_inode *ctx)\n{\n#if IS_ENABLED(CONFIG_FSCACHE)\n\treturn ctx->cache;\n#else\n\treturn NULL;\n#endif\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}