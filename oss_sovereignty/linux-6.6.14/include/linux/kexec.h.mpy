{
  "module_name": "kexec.h",
  "hash_id": "a136f58b278824eaf7e88eb62fe56bf99415ce0b28d95efc3203d291437286ab",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/kexec.h",
  "human_readable_source": " \n#ifndef LINUX_KEXEC_H\n#define LINUX_KEXEC_H\n\n#define IND_DESTINATION_BIT 0\n#define IND_INDIRECTION_BIT 1\n#define IND_DONE_BIT        2\n#define IND_SOURCE_BIT      3\n\n#define IND_DESTINATION  (1 << IND_DESTINATION_BIT)\n#define IND_INDIRECTION  (1 << IND_INDIRECTION_BIT)\n#define IND_DONE         (1 << IND_DONE_BIT)\n#define IND_SOURCE       (1 << IND_SOURCE_BIT)\n#define IND_FLAGS (IND_DESTINATION | IND_INDIRECTION | IND_DONE | IND_SOURCE)\n\n#if !defined(__ASSEMBLY__)\n\n#include <linux/crash_core.h>\n#include <asm/io.h>\n#include <linux/range.h>\n\n#include <uapi/linux/kexec.h>\n#include <linux/verification.h>\n\n \nextern struct resource crashk_res;\nextern struct resource crashk_low_res;\nextern note_buf_t __percpu *crash_notes;\n\n#ifdef CONFIG_KEXEC_CORE\n#include <linux/list.h>\n#include <linux/compat.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <asm/kexec.h>\n\n \n\n#ifndef KEXEC_SOURCE_MEMORY_LIMIT\n#error KEXEC_SOURCE_MEMORY_LIMIT not defined\n#endif\n\n#ifndef KEXEC_DESTINATION_MEMORY_LIMIT\n#error KEXEC_DESTINATION_MEMORY_LIMIT not defined\n#endif\n\n#ifndef KEXEC_CONTROL_MEMORY_LIMIT\n#error KEXEC_CONTROL_MEMORY_LIMIT not defined\n#endif\n\n#ifndef KEXEC_CONTROL_MEMORY_GFP\n#define KEXEC_CONTROL_MEMORY_GFP (GFP_KERNEL | __GFP_NORETRY)\n#endif\n\n#ifndef KEXEC_CONTROL_PAGE_SIZE\n#error KEXEC_CONTROL_PAGE_SIZE not defined\n#endif\n\n#ifndef KEXEC_ARCH\n#error KEXEC_ARCH not defined\n#endif\n\n#ifndef KEXEC_CRASH_CONTROL_MEMORY_LIMIT\n#define KEXEC_CRASH_CONTROL_MEMORY_LIMIT KEXEC_CONTROL_MEMORY_LIMIT\n#endif\n\n#ifndef KEXEC_CRASH_MEM_ALIGN\n#define KEXEC_CRASH_MEM_ALIGN PAGE_SIZE\n#endif\n\n#define KEXEC_CORE_NOTE_NAME\tCRASH_CORE_NOTE_NAME\n\n \n\ntypedef unsigned long kimage_entry_t;\n\nstruct kexec_segment {\n\t \n\tunion {\n\t\tvoid __user *buf;\n\t\tvoid *kbuf;\n\t};\n\tsize_t bufsz;\n\tunsigned long mem;\n\tsize_t memsz;\n};\n\n#ifdef CONFIG_COMPAT\nstruct compat_kexec_segment {\n\tcompat_uptr_t buf;\n\tcompat_size_t bufsz;\n\tcompat_ulong_t mem;\t \n\tcompat_size_t memsz;\n};\n#endif\n\n#ifdef CONFIG_KEXEC_FILE\nstruct purgatory_info {\n\t \n\tconst Elf_Ehdr *ehdr;\n\t \n\tElf_Shdr *sechdrs;\n\t \n\tvoid *purgatory_buf;\n};\n\nstruct kimage;\n\ntypedef int (kexec_probe_t)(const char *kernel_buf, unsigned long kernel_size);\ntypedef void *(kexec_load_t)(struct kimage *image, char *kernel_buf,\n\t\t\t     unsigned long kernel_len, char *initrd,\n\t\t\t     unsigned long initrd_len, char *cmdline,\n\t\t\t     unsigned long cmdline_len);\ntypedef int (kexec_cleanup_t)(void *loader_data);\n\n#ifdef CONFIG_KEXEC_SIG\ntypedef int (kexec_verify_sig_t)(const char *kernel_buf,\n\t\t\t\t unsigned long kernel_len);\n#endif\n\nstruct kexec_file_ops {\n\tkexec_probe_t *probe;\n\tkexec_load_t *load;\n\tkexec_cleanup_t *cleanup;\n#ifdef CONFIG_KEXEC_SIG\n\tkexec_verify_sig_t *verify_sig;\n#endif\n};\n\nextern const struct kexec_file_ops * const kexec_file_loaders[];\n\nint kexec_image_probe_default(struct kimage *image, void *buf,\n\t\t\t      unsigned long buf_len);\nint kexec_image_post_load_cleanup_default(struct kimage *image);\n\n \n#ifndef KEXEC_BUF_MEM_UNKNOWN\n#define KEXEC_BUF_MEM_UNKNOWN 0\n#endif\n\n \nstruct kexec_buf {\n\tstruct kimage *image;\n\tvoid *buffer;\n\tunsigned long bufsz;\n\tunsigned long mem;\n\tunsigned long memsz;\n\tunsigned long buf_align;\n\tunsigned long buf_min;\n\tunsigned long buf_max;\n\tbool top_down;\n};\n\nint kexec_load_purgatory(struct kimage *image, struct kexec_buf *kbuf);\nint kexec_purgatory_get_set_symbol(struct kimage *image, const char *name,\n\t\t\t\t   void *buf, unsigned int size,\n\t\t\t\t   bool get_value);\nvoid *kexec_purgatory_get_symbol_addr(struct kimage *image, const char *name);\n\n#ifndef arch_kexec_kernel_image_probe\nstatic inline int\narch_kexec_kernel_image_probe(struct kimage *image, void *buf, unsigned long buf_len)\n{\n\treturn kexec_image_probe_default(image, buf, buf_len);\n}\n#endif\n\n#ifndef arch_kimage_file_post_load_cleanup\nstatic inline int arch_kimage_file_post_load_cleanup(struct kimage *image)\n{\n\treturn kexec_image_post_load_cleanup_default(image);\n}\n#endif\n\n#ifdef CONFIG_KEXEC_SIG\n#ifdef CONFIG_SIGNED_PE_FILE_VERIFICATION\nint kexec_kernel_verify_pe_sig(const char *kernel, unsigned long kernel_len);\n#endif\n#endif\n\nextern int kexec_add_buffer(struct kexec_buf *kbuf);\nint kexec_locate_mem_hole(struct kexec_buf *kbuf);\n\n#ifndef arch_kexec_locate_mem_hole\n \nstatic inline int arch_kexec_locate_mem_hole(struct kexec_buf *kbuf)\n{\n\treturn kexec_locate_mem_hole(kbuf);\n}\n#endif\n\n#ifndef arch_kexec_apply_relocations_add\n \nstatic inline int\narch_kexec_apply_relocations_add(struct purgatory_info *pi, Elf_Shdr *section,\n\t\t\t\t const Elf_Shdr *relsec, const Elf_Shdr *symtab)\n{\n\tpr_err(\"RELA relocation unsupported.\\n\");\n\treturn -ENOEXEC;\n}\n#endif\n\n#ifndef arch_kexec_apply_relocations\n \nstatic inline int\narch_kexec_apply_relocations(struct purgatory_info *pi, Elf_Shdr *section,\n\t\t\t     const Elf_Shdr *relsec, const Elf_Shdr *symtab)\n{\n\tpr_err(\"REL relocation unsupported.\\n\");\n\treturn -ENOEXEC;\n}\n#endif\n#endif  \n\n#ifdef CONFIG_KEXEC_ELF\nstruct kexec_elf_info {\n\t \n\tconst char *buffer;\n\n\tconst struct elfhdr *ehdr;\n\tconst struct elf_phdr *proghdrs;\n};\n\nint kexec_build_elf_info(const char *buf, size_t len, struct elfhdr *ehdr,\n\t\t\t       struct kexec_elf_info *elf_info);\n\nint kexec_elf_load(struct kimage *image, struct elfhdr *ehdr,\n\t\t\t struct kexec_elf_info *elf_info,\n\t\t\t struct kexec_buf *kbuf,\n\t\t\t unsigned long *lowest_load_addr);\n\nvoid kexec_free_elf_info(struct kexec_elf_info *elf_info);\nint kexec_elf_probe(const char *buf, unsigned long len);\n#endif\nstruct kimage {\n\tkimage_entry_t head;\n\tkimage_entry_t *entry;\n\tkimage_entry_t *last_entry;\n\n\tunsigned long start;\n\tstruct page *control_code_page;\n\tstruct page *swap_page;\n\tvoid *vmcoreinfo_data_copy;  \n\n\tunsigned long nr_segments;\n\tstruct kexec_segment segment[KEXEC_SEGMENT_MAX];\n\n\tstruct list_head control_pages;\n\tstruct list_head dest_pages;\n\tstruct list_head unusable_pages;\n\n\t \n\tunsigned long control_page;\n\n\t \n\tunsigned int type : 1;\n#define KEXEC_TYPE_DEFAULT 0\n#define KEXEC_TYPE_CRASH   1\n\tunsigned int preserve_context : 1;\n\t \n\tunsigned int file_mode:1;\n#ifdef CONFIG_CRASH_HOTPLUG\n\t \n\tunsigned int update_elfcorehdr:1;\n#endif\n\n#ifdef ARCH_HAS_KIMAGE_ARCH\n\tstruct kimage_arch arch;\n#endif\n\n#ifdef CONFIG_KEXEC_FILE\n\t \n\tvoid *kernel_buf;\n\tunsigned long kernel_buf_len;\n\n\tvoid *initrd_buf;\n\tunsigned long initrd_buf_len;\n\n\tchar *cmdline_buf;\n\tunsigned long cmdline_buf_len;\n\n\t \n\tconst struct kexec_file_ops *fops;\n\n\t \n\tvoid *image_loader_data;\n\n\t \n\tstruct purgatory_info purgatory_info;\n#endif\n\n#ifdef CONFIG_CRASH_HOTPLUG\n\tint hp_action;\n\tint elfcorehdr_index;\n\tbool elfcorehdr_updated;\n#endif\n\n#ifdef CONFIG_IMA_KEXEC\n\t \n\tvoid *ima_buffer;\n\n\tphys_addr_t ima_buffer_addr;\n\tsize_t ima_buffer_size;\n#endif\n\n\t \n\tvoid *elf_headers;\n\tunsigned long elf_headers_sz;\n\tunsigned long elf_load_addr;\n};\n\n \nextern void machine_kexec(struct kimage *image);\nextern int machine_kexec_prepare(struct kimage *image);\nextern void machine_kexec_cleanup(struct kimage *image);\nextern int kernel_kexec(void);\nextern struct page *kimage_alloc_control_pages(struct kimage *image,\n\t\t\t\t\t\tunsigned int order);\n\n#ifndef machine_kexec_post_load\nstatic inline int machine_kexec_post_load(struct kimage *image) { return 0; }\n#endif\n\nextern void __crash_kexec(struct pt_regs *);\nextern void crash_kexec(struct pt_regs *);\nint kexec_should_crash(struct task_struct *);\nint kexec_crash_loaded(void);\nvoid crash_save_cpu(struct pt_regs *regs, int cpu);\nextern int kimage_crash_copy_vmcoreinfo(struct kimage *image);\n\nextern struct kimage *kexec_image;\nextern struct kimage *kexec_crash_image;\n\nbool kexec_load_permitted(int kexec_image_type);\n\n#ifndef kexec_flush_icache_page\n#define kexec_flush_icache_page(page)\n#endif\n\n \n#ifndef CONFIG_KEXEC_JUMP\n#define KEXEC_FLAGS    (KEXEC_ON_CRASH | KEXEC_UPDATE_ELFCOREHDR)\n#else\n#define KEXEC_FLAGS    (KEXEC_ON_CRASH | KEXEC_PRESERVE_CONTEXT | KEXEC_UPDATE_ELFCOREHDR)\n#endif\n\n \n#define KEXEC_FILE_FLAGS\t(KEXEC_FILE_UNLOAD | KEXEC_FILE_ON_CRASH | \\\n\t\t\t\t KEXEC_FILE_NO_INITRAMFS)\n\n \nextern bool kexec_in_progress;\n\nint crash_shrink_memory(unsigned long new_size);\nssize_t crash_get_memory_size(void);\n\n#ifndef arch_kexec_protect_crashkres\n \nstatic inline void arch_kexec_protect_crashkres(void) { }\n#endif\n\n#ifndef arch_kexec_unprotect_crashkres\nstatic inline void arch_kexec_unprotect_crashkres(void) { }\n#endif\n\n#ifndef page_to_boot_pfn\nstatic inline unsigned long page_to_boot_pfn(struct page *page)\n{\n\treturn page_to_pfn(page);\n}\n#endif\n\n#ifndef boot_pfn_to_page\nstatic inline struct page *boot_pfn_to_page(unsigned long boot_pfn)\n{\n\treturn pfn_to_page(boot_pfn);\n}\n#endif\n\n#ifndef phys_to_boot_phys\nstatic inline unsigned long phys_to_boot_phys(phys_addr_t phys)\n{\n\treturn phys;\n}\n#endif\n\n#ifndef boot_phys_to_phys\nstatic inline phys_addr_t boot_phys_to_phys(unsigned long boot_phys)\n{\n\treturn boot_phys;\n}\n#endif\n\n#ifndef crash_free_reserved_phys_range\nstatic inline void crash_free_reserved_phys_range(unsigned long begin, unsigned long end)\n{\n\tunsigned long addr;\n\n\tfor (addr = begin; addr < end; addr += PAGE_SIZE)\n\t\tfree_reserved_page(boot_pfn_to_page(addr >> PAGE_SHIFT));\n}\n#endif\n\nstatic inline unsigned long virt_to_boot_phys(void *addr)\n{\n\treturn phys_to_boot_phys(__pa((unsigned long)addr));\n}\n\nstatic inline void *boot_phys_to_virt(unsigned long entry)\n{\n\treturn phys_to_virt(boot_phys_to_phys(entry));\n}\n\n#ifndef arch_kexec_post_alloc_pages\nstatic inline int arch_kexec_post_alloc_pages(void *vaddr, unsigned int pages, gfp_t gfp) { return 0; }\n#endif\n\n#ifndef arch_kexec_pre_free_pages\nstatic inline void arch_kexec_pre_free_pages(void *vaddr, unsigned int pages) { }\n#endif\n\n#ifndef arch_crash_handle_hotplug_event\nstatic inline void arch_crash_handle_hotplug_event(struct kimage *image) { }\n#endif\n\nint crash_check_update_elfcorehdr(void);\n\n#ifndef crash_hotplug_cpu_support\nstatic inline int crash_hotplug_cpu_support(void) { return 0; }\n#endif\n\n#ifndef crash_hotplug_memory_support\nstatic inline int crash_hotplug_memory_support(void) { return 0; }\n#endif\n\n#ifndef crash_get_elfcorehdr_size\nstatic inline unsigned int crash_get_elfcorehdr_size(void) { return 0; }\n#endif\n\n#else  \nstruct pt_regs;\nstruct task_struct;\nstatic inline void __crash_kexec(struct pt_regs *regs) { }\nstatic inline void crash_kexec(struct pt_regs *regs) { }\nstatic inline int kexec_should_crash(struct task_struct *p) { return 0; }\nstatic inline int kexec_crash_loaded(void) { return 0; }\n#define kexec_in_progress false\n#endif  \n\n#ifdef CONFIG_KEXEC_SIG\nvoid set_kexec_sig_enforced(void);\n#else\nstatic inline void set_kexec_sig_enforced(void) {}\n#endif\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}