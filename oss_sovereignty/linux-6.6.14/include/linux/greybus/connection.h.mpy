{
  "module_name": "connection.h",
  "hash_id": "06c734c8bbdbb95268e8929915e4574afcc2e22e6c121fd91f612322f4224d61",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/greybus/connection.h",
  "human_readable_source": " \n \n\n#ifndef __CONNECTION_H\n#define __CONNECTION_H\n\n#include <linux/bits.h>\n#include <linux/list.h>\n#include <linux/kfifo.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n\n#define GB_CONNECTION_FLAG_CSD\t\tBIT(0)\n#define GB_CONNECTION_FLAG_NO_FLOWCTRL\tBIT(1)\n#define GB_CONNECTION_FLAG_OFFLOADED\tBIT(2)\n#define GB_CONNECTION_FLAG_CDSI1\tBIT(3)\n#define GB_CONNECTION_FLAG_CONTROL\tBIT(4)\n#define GB_CONNECTION_FLAG_HIGH_PRIO\tBIT(5)\n\n#define GB_CONNECTION_FLAG_CORE_MASK\tGB_CONNECTION_FLAG_CONTROL\n\nenum gb_connection_state {\n\tGB_CONNECTION_STATE_DISABLED\t\t= 0,\n\tGB_CONNECTION_STATE_ENABLED_TX\t\t= 1,\n\tGB_CONNECTION_STATE_ENABLED\t\t= 2,\n\tGB_CONNECTION_STATE_DISCONNECTING\t= 3,\n};\n\nstruct gb_operation;\n\ntypedef int (*gb_request_handler_t)(struct gb_operation *);\n\nstruct gb_connection {\n\tstruct gb_host_device\t\t*hd;\n\tstruct gb_interface\t\t*intf;\n\tstruct gb_bundle\t\t*bundle;\n\tstruct kref\t\t\tkref;\n\tu16\t\t\t\thd_cport_id;\n\tu16\t\t\t\tintf_cport_id;\n\n\tstruct list_head\t\thd_links;\n\tstruct list_head\t\tbundle_links;\n\n\tgb_request_handler_t\t\thandler;\n\tunsigned long\t\t\tflags;\n\n\tstruct mutex\t\t\tmutex;\n\tspinlock_t\t\t\tlock;\n\tenum gb_connection_state\tstate;\n\tstruct list_head\t\toperations;\n\n\tchar\t\t\t\tname[16];\n\tstruct workqueue_struct\t\t*wq;\n\n\tatomic_t\t\t\top_cycle;\n\n\tvoid\t\t\t\t*private;\n\n\tbool\t\t\t\tmode_switch;\n};\n\nstruct gb_connection *gb_connection_create_static(struct gb_host_device *hd,\n\t\t\t\tu16 hd_cport_id, gb_request_handler_t handler);\nstruct gb_connection *gb_connection_create_control(struct gb_interface *intf);\nstruct gb_connection *gb_connection_create(struct gb_bundle *bundle,\n\t\t\t\tu16 cport_id, gb_request_handler_t handler);\nstruct gb_connection *gb_connection_create_flags(struct gb_bundle *bundle,\n\t\t\t\tu16 cport_id, gb_request_handler_t handler,\n\t\t\t\tunsigned long flags);\nstruct gb_connection *gb_connection_create_offloaded(struct gb_bundle *bundle,\n\t\t\t\tu16 cport_id, unsigned long flags);\nvoid gb_connection_destroy(struct gb_connection *connection);\n\nstatic inline bool gb_connection_is_static(struct gb_connection *connection)\n{\n\treturn !connection->intf;\n}\n\nint gb_connection_enable(struct gb_connection *connection);\nint gb_connection_enable_tx(struct gb_connection *connection);\nvoid gb_connection_disable_rx(struct gb_connection *connection);\nvoid gb_connection_disable(struct gb_connection *connection);\nvoid gb_connection_disable_forced(struct gb_connection *connection);\n\nvoid gb_connection_mode_switch_prepare(struct gb_connection *connection);\nvoid gb_connection_mode_switch_complete(struct gb_connection *connection);\n\nvoid greybus_data_rcvd(struct gb_host_device *hd, u16 cport_id,\n\t\t       u8 *data, size_t length);\n\nvoid gb_connection_latency_tag_enable(struct gb_connection *connection);\nvoid gb_connection_latency_tag_disable(struct gb_connection *connection);\n\nstatic inline bool gb_connection_e2efc_enabled(struct gb_connection *connection)\n{\n\treturn !(connection->flags & GB_CONNECTION_FLAG_CSD);\n}\n\nstatic inline bool\ngb_connection_flow_control_disabled(struct gb_connection *connection)\n{\n\treturn connection->flags & GB_CONNECTION_FLAG_NO_FLOWCTRL;\n}\n\nstatic inline bool gb_connection_is_offloaded(struct gb_connection *connection)\n{\n\treturn connection->flags & GB_CONNECTION_FLAG_OFFLOADED;\n}\n\nstatic inline bool gb_connection_is_control(struct gb_connection *connection)\n{\n\treturn connection->flags & GB_CONNECTION_FLAG_CONTROL;\n}\n\nstatic inline void *gb_connection_get_data(struct gb_connection *connection)\n{\n\treturn connection->private;\n}\n\nstatic inline void gb_connection_set_data(struct gb_connection *connection,\n\t\t\t\t\t  void *data)\n{\n\tconnection->private = data;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}