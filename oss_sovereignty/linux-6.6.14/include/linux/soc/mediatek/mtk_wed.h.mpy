{
  "module_name": "mtk_wed.h",
  "hash_id": "71959ab6d954b9a8eca6b8a9e736535c2e809829a50711bb25aa1ce13dfd300e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/soc/mediatek/mtk_wed.h",
  "human_readable_source": "#ifndef __MTK_WED_H\n#define __MTK_WED_H\n\n#include <linux/kernel.h>\n#include <linux/rcupdate.h>\n#include <linux/regmap.h>\n#include <linux/pci.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n\n#define MTK_WED_TX_QUEUES\t\t2\n#define MTK_WED_RX_QUEUES\t\t2\n\n#define WED_WO_STA_REC\t\t\t0x6\n\nstruct mtk_wed_hw;\nstruct mtk_wdma_desc;\n\nenum mtk_wed_wo_cmd {\n\tMTK_WED_WO_CMD_WED_CFG,\n\tMTK_WED_WO_CMD_WED_RX_STAT,\n\tMTK_WED_WO_CMD_RRO_SER,\n\tMTK_WED_WO_CMD_DBG_INFO,\n\tMTK_WED_WO_CMD_DEV_INFO,\n\tMTK_WED_WO_CMD_BSS_INFO,\n\tMTK_WED_WO_CMD_STA_REC,\n\tMTK_WED_WO_CMD_DEV_INFO_DUMP,\n\tMTK_WED_WO_CMD_BSS_INFO_DUMP,\n\tMTK_WED_WO_CMD_STA_REC_DUMP,\n\tMTK_WED_WO_CMD_BA_INFO_DUMP,\n\tMTK_WED_WO_CMD_FBCMD_Q_DUMP,\n\tMTK_WED_WO_CMD_FW_LOG_CTRL,\n\tMTK_WED_WO_CMD_LOG_FLUSH,\n\tMTK_WED_WO_CMD_CHANGE_STATE,\n\tMTK_WED_WO_CMD_CPU_STATS_ENABLE,\n\tMTK_WED_WO_CMD_CPU_STATS_DUMP,\n\tMTK_WED_WO_CMD_EXCEPTION_INIT,\n\tMTK_WED_WO_CMD_PROF_CTRL,\n\tMTK_WED_WO_CMD_STA_BA_DUMP,\n\tMTK_WED_WO_CMD_BA_CTRL_DUMP,\n\tMTK_WED_WO_CMD_RXCNT_CTRL,\n\tMTK_WED_WO_CMD_RXCNT_INFO,\n\tMTK_WED_WO_CMD_SET_CAP,\n\tMTK_WED_WO_CMD_CCIF_RING_DUMP,\n\tMTK_WED_WO_CMD_WED_END\n};\n\nstruct mtk_rxbm_desc {\n\t__le32 buf0;\n\t__le32 token;\n} __packed __aligned(4);\n\nenum mtk_wed_bus_tye {\n\tMTK_WED_BUS_PCIE,\n\tMTK_WED_BUS_AXI,\n};\n\n#define MTK_WED_RING_CONFIGURED\t\tBIT(0)\nstruct mtk_wed_ring {\n\tstruct mtk_wdma_desc *desc;\n\tdma_addr_t desc_phys;\n\tu32 desc_size;\n\tint size;\n\tu32 flags;\n\n\tu32 reg_base;\n\tvoid __iomem *wpdma;\n};\n\nstruct mtk_wed_wo_rx_stats {\n\t__le16 wlan_idx;\n\t__le16 tid;\n\t__le32 rx_pkt_cnt;\n\t__le32 rx_byte_cnt;\n\t__le32 rx_err_cnt;\n\t__le32 rx_drop_cnt;\n};\n\nstruct mtk_wed_device {\n#ifdef CONFIG_NET_MEDIATEK_SOC_WED\n\tconst struct mtk_wed_ops *ops;\n\tstruct device *dev;\n\tstruct mtk_wed_hw *hw;\n\tbool init_done, running;\n\tint wdma_idx;\n\tint irq;\n\tu8 version;\n\n\t \n\tu32 rev_id;\n\n\tstruct mtk_wed_ring tx_ring[MTK_WED_TX_QUEUES];\n\tstruct mtk_wed_ring rx_ring[MTK_WED_RX_QUEUES];\n\tstruct mtk_wed_ring txfree_ring;\n\tstruct mtk_wed_ring tx_wdma[MTK_WED_TX_QUEUES];\n\tstruct mtk_wed_ring rx_wdma[MTK_WED_RX_QUEUES];\n\n\tstruct {\n\t\tint size;\n\t\tvoid **pages;\n\t\tstruct mtk_wdma_desc *desc;\n\t\tdma_addr_t desc_phys;\n\t} tx_buf_ring;\n\n\tstruct {\n\t\tint size;\n\t\tstruct mtk_rxbm_desc *desc;\n\t\tdma_addr_t desc_phys;\n\t} rx_buf_ring;\n\n\tstruct {\n\t\tstruct mtk_wed_ring ring;\n\t\tdma_addr_t miod_phys;\n\t\tdma_addr_t fdbk_phys;\n\t} rro;\n\n\t \n\tstruct {\n\t\tunion {\n\t\t\tstruct platform_device *platform_dev;\n\t\t\tstruct pci_dev *pci_dev;\n\t\t};\n\t\tenum mtk_wed_bus_tye bus_type;\n\t\tvoid __iomem *base;\n\t\tu32 phy_base;\n\n\t\tu32 wpdma_phys;\n\t\tu32 wpdma_int;\n\t\tu32 wpdma_mask;\n\t\tu32 wpdma_tx;\n\t\tu32 wpdma_txfree;\n\t\tu32 wpdma_rx_glo;\n\t\tu32 wpdma_rx;\n\n\t\tbool wcid_512;\n\n\t\tu16 token_start;\n\t\tunsigned int nbuf;\n\t\tunsigned int rx_nbuf;\n\t\tunsigned int rx_npkt;\n\t\tunsigned int rx_size;\n\n\t\tu8 tx_tbit[MTK_WED_TX_QUEUES];\n\t\tu8 rx_tbit[MTK_WED_RX_QUEUES];\n\t\tu8 txfree_tbit;\n\n\t\tu32 (*init_buf)(void *ptr, dma_addr_t phys, int token_id);\n\t\tint (*offload_enable)(struct mtk_wed_device *wed);\n\t\tvoid (*offload_disable)(struct mtk_wed_device *wed);\n\t\tu32 (*init_rx_buf)(struct mtk_wed_device *wed, int size);\n\t\tvoid (*release_rx_buf)(struct mtk_wed_device *wed);\n\t\tvoid (*update_wo_rx_stats)(struct mtk_wed_device *wed,\n\t\t\t\t\t   struct mtk_wed_wo_rx_stats *stats);\n\t\tint (*reset)(struct mtk_wed_device *wed);\n\t\tvoid (*reset_complete)(struct mtk_wed_device *wed);\n\t} wlan;\n#endif\n};\n\nstruct mtk_wed_ops {\n\tint (*attach)(struct mtk_wed_device *dev);\n\tint (*tx_ring_setup)(struct mtk_wed_device *dev, int ring,\n\t\t\t     void __iomem *regs, bool reset);\n\tint (*rx_ring_setup)(struct mtk_wed_device *dev, int ring,\n\t\t\t     void __iomem *regs, bool reset);\n\tint (*txfree_ring_setup)(struct mtk_wed_device *dev,\n\t\t\t\t void __iomem *regs);\n\tint (*msg_update)(struct mtk_wed_device *dev, int cmd_id,\n\t\t\t  void *data, int len);\n\tvoid (*detach)(struct mtk_wed_device *dev);\n\tvoid (*ppe_check)(struct mtk_wed_device *dev, struct sk_buff *skb,\n\t\t\t  u32 reason, u32 hash);\n\n\tvoid (*stop)(struct mtk_wed_device *dev);\n\tvoid (*start)(struct mtk_wed_device *dev, u32 irq_mask);\n\tvoid (*reset_dma)(struct mtk_wed_device *dev);\n\n\tu32 (*reg_read)(struct mtk_wed_device *dev, u32 reg);\n\tvoid (*reg_write)(struct mtk_wed_device *dev, u32 reg, u32 val);\n\n\tu32 (*irq_get)(struct mtk_wed_device *dev, u32 mask);\n\tvoid (*irq_set_mask)(struct mtk_wed_device *dev, u32 mask);\n\tint (*setup_tc)(struct mtk_wed_device *wed, struct net_device *dev,\n\t\t\tenum tc_setup_type type, void *type_data);\n};\n\nextern const struct mtk_wed_ops __rcu *mtk_soc_wed_ops;\n\nstatic inline int\nmtk_wed_device_attach(struct mtk_wed_device *dev)\n{\n\tint ret = -ENODEV;\n\n#ifdef CONFIG_NET_MEDIATEK_SOC_WED\n\trcu_read_lock();\n\tdev->ops = rcu_dereference(mtk_soc_wed_ops);\n\tif (dev->ops)\n\t\tret = dev->ops->attach(dev);\n\telse\n\t\trcu_read_unlock();\n\n\tif (ret)\n\t\tdev->ops = NULL;\n#endif\n\n\treturn ret;\n}\n\nstatic inline bool\nmtk_wed_get_rx_capa(struct mtk_wed_device *dev)\n{\n#ifdef CONFIG_NET_MEDIATEK_SOC_WED\n\treturn dev->version != 1;\n#else\n\treturn false;\n#endif\n}\n\n#ifdef CONFIG_NET_MEDIATEK_SOC_WED\n#define mtk_wed_device_active(_dev) !!(_dev)->ops\n#define mtk_wed_device_detach(_dev) (_dev)->ops->detach(_dev)\n#define mtk_wed_device_start(_dev, _mask) (_dev)->ops->start(_dev, _mask)\n#define mtk_wed_device_tx_ring_setup(_dev, _ring, _regs, _reset) \\\n\t(_dev)->ops->tx_ring_setup(_dev, _ring, _regs, _reset)\n#define mtk_wed_device_txfree_ring_setup(_dev, _regs) \\\n\t(_dev)->ops->txfree_ring_setup(_dev, _regs)\n#define mtk_wed_device_reg_read(_dev, _reg) \\\n\t(_dev)->ops->reg_read(_dev, _reg)\n#define mtk_wed_device_reg_write(_dev, _reg, _val) \\\n\t(_dev)->ops->reg_write(_dev, _reg, _val)\n#define mtk_wed_device_irq_get(_dev, _mask) \\\n\t(_dev)->ops->irq_get(_dev, _mask)\n#define mtk_wed_device_irq_set_mask(_dev, _mask) \\\n\t(_dev)->ops->irq_set_mask(_dev, _mask)\n#define mtk_wed_device_rx_ring_setup(_dev, _ring, _regs, _reset) \\\n\t(_dev)->ops->rx_ring_setup(_dev, _ring, _regs, _reset)\n#define mtk_wed_device_ppe_check(_dev, _skb, _reason, _hash) \\\n\t(_dev)->ops->ppe_check(_dev, _skb, _reason, _hash)\n#define mtk_wed_device_update_msg(_dev, _id, _msg, _len) \\\n\t(_dev)->ops->msg_update(_dev, _id, _msg, _len)\n#define mtk_wed_device_stop(_dev) (_dev)->ops->stop(_dev)\n#define mtk_wed_device_dma_reset(_dev) (_dev)->ops->reset_dma(_dev)\n#define mtk_wed_device_setup_tc(_dev, _netdev, _type, _type_data) \\\n\t(_dev)->ops->setup_tc(_dev, _netdev, _type, _type_data)\n#else\nstatic inline bool mtk_wed_device_active(struct mtk_wed_device *dev)\n{\n\treturn false;\n}\n#define mtk_wed_device_detach(_dev) do {} while (0)\n#define mtk_wed_device_start(_dev, _mask) do {} while (0)\n#define mtk_wed_device_tx_ring_setup(_dev, _ring, _regs, _reset) -ENODEV\n#define mtk_wed_device_txfree_ring_setup(_dev, _ring, _regs) -ENODEV\n#define mtk_wed_device_reg_read(_dev, _reg) 0\n#define mtk_wed_device_reg_write(_dev, _reg, _val) do {} while (0)\n#define mtk_wed_device_irq_get(_dev, _mask) 0\n#define mtk_wed_device_irq_set_mask(_dev, _mask) do {} while (0)\n#define mtk_wed_device_rx_ring_setup(_dev, _ring, _regs, _reset) -ENODEV\n#define mtk_wed_device_ppe_check(_dev, _skb, _reason, _hash)  do {} while (0)\n#define mtk_wed_device_update_msg(_dev, _id, _msg, _len) -ENODEV\n#define mtk_wed_device_stop(_dev) do {} while (0)\n#define mtk_wed_device_dma_reset(_dev) do {} while (0)\n#define mtk_wed_device_setup_tc(_dev, _netdev, _type, _type_data) -EOPNOTSUPP\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}