{
  "module_name": "bpf_mprog.h",
  "hash_id": "8c802618ac5004c48a2e733965aed57c0453fbacbdda2d41a930bf5473c2de92",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/bpf_mprog.h",
  "human_readable_source": " \n \n#ifndef __BPF_MPROG_H\n#define __BPF_MPROG_H\n\n#include <linux/bpf.h>\n\n \n\n#define bpf_mprog_foreach_tuple(entry, fp, cp, t)\t\t\t\\\n\tfor (fp = &entry->fp_items[0], cp = &entry->parent->cp_items[0];\\\n\t     ({\t\t\t\t\t\t\t\t\\\n\t\tt.prog = READ_ONCE(fp->prog);\t\t\t\t\\\n\t\tt.link = cp->link;\t\t\t\t\t\\\n\t\tt.prog;\t\t\t\t\t\t\t\\\n\t      });\t\t\t\t\t\t\t\\\n\t     fp++, cp++)\n\n#define bpf_mprog_foreach_prog(entry, fp, p)\t\t\t\t\\\n\tfor (fp = &entry->fp_items[0];\t\t\t\t\t\\\n\t     (p = READ_ONCE(fp->prog));\t\t\t\t\t\\\n\t     fp++)\n\n#define BPF_MPROG_MAX 64\n\nstruct bpf_mprog_fp {\n\tstruct bpf_prog *prog;\n};\n\nstruct bpf_mprog_cp {\n\tstruct bpf_link *link;\n};\n\nstruct bpf_mprog_entry {\n\tstruct bpf_mprog_fp fp_items[BPF_MPROG_MAX];\n\tstruct bpf_mprog_bundle *parent;\n};\n\nstruct bpf_mprog_bundle {\n\tstruct bpf_mprog_entry a;\n\tstruct bpf_mprog_entry b;\n\tstruct bpf_mprog_cp cp_items[BPF_MPROG_MAX];\n\tstruct bpf_prog *ref;\n\tatomic64_t revision;\n\tu32 count;\n};\n\nstruct bpf_tuple {\n\tstruct bpf_prog *prog;\n\tstruct bpf_link *link;\n};\n\nstatic inline struct bpf_mprog_entry *\nbpf_mprog_peer(const struct bpf_mprog_entry *entry)\n{\n\tif (entry == &entry->parent->a)\n\t\treturn &entry->parent->b;\n\telse\n\t\treturn &entry->parent->a;\n}\n\nstatic inline void bpf_mprog_bundle_init(struct bpf_mprog_bundle *bundle)\n{\n\tBUILD_BUG_ON(sizeof(bundle->a.fp_items[0]) > sizeof(u64));\n\tBUILD_BUG_ON(ARRAY_SIZE(bundle->a.fp_items) !=\n\t\t     ARRAY_SIZE(bundle->cp_items));\n\n\tmemset(bundle, 0, sizeof(*bundle));\n\tatomic64_set(&bundle->revision, 1);\n\tbundle->a.parent = bundle;\n\tbundle->b.parent = bundle;\n}\n\nstatic inline void bpf_mprog_inc(struct bpf_mprog_entry *entry)\n{\n\tentry->parent->count++;\n}\n\nstatic inline void bpf_mprog_dec(struct bpf_mprog_entry *entry)\n{\n\tentry->parent->count--;\n}\n\nstatic inline int bpf_mprog_max(void)\n{\n\treturn ARRAY_SIZE(((struct bpf_mprog_entry *)NULL)->fp_items) - 1;\n}\n\nstatic inline int bpf_mprog_total(struct bpf_mprog_entry *entry)\n{\n\tint total = entry->parent->count;\n\n\tWARN_ON_ONCE(total > bpf_mprog_max());\n\treturn total;\n}\n\nstatic inline bool bpf_mprog_exists(struct bpf_mprog_entry *entry,\n\t\t\t\t    struct bpf_prog *prog)\n{\n\tconst struct bpf_mprog_fp *fp;\n\tconst struct bpf_prog *tmp;\n\n\tbpf_mprog_foreach_prog(entry, fp, tmp) {\n\t\tif (tmp == prog)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline void bpf_mprog_mark_for_release(struct bpf_mprog_entry *entry,\n\t\t\t\t\t      struct bpf_tuple *tuple)\n{\n\tWARN_ON_ONCE(entry->parent->ref);\n\tif (!tuple->link)\n\t\tentry->parent->ref = tuple->prog;\n}\n\nstatic inline void bpf_mprog_complete_release(struct bpf_mprog_entry *entry)\n{\n\t \n\tif (entry->parent->ref) {\n\t\tbpf_prog_put(entry->parent->ref);\n\t\tentry->parent->ref = NULL;\n\t}\n}\n\nstatic inline void bpf_mprog_revision_new(struct bpf_mprog_entry *entry)\n{\n\tatomic64_inc(&entry->parent->revision);\n}\n\nstatic inline void bpf_mprog_commit(struct bpf_mprog_entry *entry)\n{\n\tbpf_mprog_complete_release(entry);\n\tbpf_mprog_revision_new(entry);\n}\n\nstatic inline u64 bpf_mprog_revision(struct bpf_mprog_entry *entry)\n{\n\treturn atomic64_read(&entry->parent->revision);\n}\n\nstatic inline void bpf_mprog_entry_copy(struct bpf_mprog_entry *dst,\n\t\t\t\t\tstruct bpf_mprog_entry *src)\n{\n\tmemcpy(dst->fp_items, src->fp_items, sizeof(src->fp_items));\n}\n\nstatic inline void bpf_mprog_entry_clear(struct bpf_mprog_entry *dst)\n{\n\tmemset(dst->fp_items, 0, sizeof(dst->fp_items));\n}\n\nstatic inline void bpf_mprog_clear_all(struct bpf_mprog_entry *entry,\n\t\t\t\t       struct bpf_mprog_entry **entry_new)\n{\n\tstruct bpf_mprog_entry *peer;\n\n\tpeer = bpf_mprog_peer(entry);\n\tbpf_mprog_entry_clear(peer);\n\tpeer->parent->count = 0;\n\t*entry_new = peer;\n}\n\nstatic inline void bpf_mprog_entry_grow(struct bpf_mprog_entry *entry, int idx)\n{\n\tint total = bpf_mprog_total(entry);\n\n\tmemmove(entry->fp_items + idx + 1,\n\t\tentry->fp_items + idx,\n\t\t(total - idx) * sizeof(struct bpf_mprog_fp));\n\n\tmemmove(entry->parent->cp_items + idx + 1,\n\t\tentry->parent->cp_items + idx,\n\t\t(total - idx) * sizeof(struct bpf_mprog_cp));\n}\n\nstatic inline void bpf_mprog_entry_shrink(struct bpf_mprog_entry *entry, int idx)\n{\n\t \n\tint total = ARRAY_SIZE(entry->fp_items);\n\n\tmemmove(entry->fp_items + idx,\n\t\tentry->fp_items + idx + 1,\n\t\t(total - idx - 1) * sizeof(struct bpf_mprog_fp));\n\n\tmemmove(entry->parent->cp_items + idx,\n\t\tentry->parent->cp_items + idx + 1,\n\t\t(total - idx - 1) * sizeof(struct bpf_mprog_cp));\n}\n\nstatic inline void bpf_mprog_read(struct bpf_mprog_entry *entry, u32 idx,\n\t\t\t\t  struct bpf_mprog_fp **fp,\n\t\t\t\t  struct bpf_mprog_cp **cp)\n{\n\t*fp = &entry->fp_items[idx];\n\t*cp = &entry->parent->cp_items[idx];\n}\n\nstatic inline void bpf_mprog_write(struct bpf_mprog_fp *fp,\n\t\t\t\t   struct bpf_mprog_cp *cp,\n\t\t\t\t   struct bpf_tuple *tuple)\n{\n\tWRITE_ONCE(fp->prog, tuple->prog);\n\tcp->link = tuple->link;\n}\n\nint bpf_mprog_attach(struct bpf_mprog_entry *entry,\n\t\t     struct bpf_mprog_entry **entry_new,\n\t\t     struct bpf_prog *prog_new, struct bpf_link *link,\n\t\t     struct bpf_prog *prog_old,\n\t\t     u32 flags, u32 id_or_fd, u64 revision);\n\nint bpf_mprog_detach(struct bpf_mprog_entry *entry,\n\t\t     struct bpf_mprog_entry **entry_new,\n\t\t     struct bpf_prog *prog, struct bpf_link *link,\n\t\t     u32 flags, u32 id_or_fd, u64 revision);\n\nint bpf_mprog_query(const union bpf_attr *attr, union bpf_attr __user *uattr,\n\t\t    struct bpf_mprog_entry *entry);\n\nstatic inline bool bpf_mprog_supported(enum bpf_prog_type type)\n{\n\tswitch (type) {\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}