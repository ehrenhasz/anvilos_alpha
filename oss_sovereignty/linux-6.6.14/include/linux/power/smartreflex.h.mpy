{
  "module_name": "smartreflex.h",
  "hash_id": "54b3fe1e1215901603166565a3b72b37c90bae111bf7c4cf5b59a72e0bc87d64",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/power/smartreflex.h",
  "human_readable_source": " \n \n\n#ifndef __POWER_SMARTREFLEX_H\n#define __POWER_SMARTREFLEX_H\n\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/platform_data/voltage-omap.h>\n\n \n#define SR_TYPE_V1\t1\n#define SR_TYPE_V2\t2\n\n \n#define SRCONFIG\t\t0x00\n#define SRSTATUS\t\t0x04\n#define SENVAL\t\t\t0x08\n#define SENMIN\t\t\t0x0C\n#define SENMAX\t\t\t0x10\n#define SENAVG\t\t\t0x14\n#define AVGWEIGHT\t\t0x18\n#define NVALUERECIPROCAL\t0x1c\n#define SENERROR_V1\t\t0x20\n#define ERRCONFIG_V1\t\t0x24\n#define IRQ_EOI\t\t\t0x20\n#define IRQSTATUS_RAW\t\t0x24\n#define IRQSTATUS\t\t0x28\n#define IRQENABLE_SET\t\t0x2C\n#define IRQENABLE_CLR\t\t0x30\n#define SENERROR_V2\t\t0x34\n#define ERRCONFIG_V2\t\t0x38\n\n \n\n \n#define SRCONFIG_ACCUMDATA_SHIFT\t22\n#define SRCONFIG_SRCLKLENGTH_SHIFT\t12\n#define SRCONFIG_SENNENABLE_V1_SHIFT\t5\n#define SRCONFIG_SENPENABLE_V1_SHIFT\t3\n#define SRCONFIG_SENNENABLE_V2_SHIFT\t1\n#define SRCONFIG_SENPENABLE_V2_SHIFT\t0\n#define SRCONFIG_CLKCTRL_SHIFT\t\t0\n\n#define SRCONFIG_ACCUMDATA_MASK\t\t(0x3ff << 22)\n\n#define SRCONFIG_SRENABLE\t\tBIT(11)\n#define SRCONFIG_SENENABLE\t\tBIT(10)\n#define SRCONFIG_ERRGEN_EN\t\tBIT(9)\n#define SRCONFIG_MINMAXAVG_EN\t\tBIT(8)\n#define SRCONFIG_DELAYCTRL\t\tBIT(2)\n\n \n#define AVGWEIGHT_SENPAVGWEIGHT_SHIFT\t2\n#define AVGWEIGHT_SENNAVGWEIGHT_SHIFT\t0\n\n \n#define NVALUERECIPROCAL_SENPGAIN_SHIFT\t20\n#define NVALUERECIPROCAL_SENNGAIN_SHIFT\t16\n#define NVALUERECIPROCAL_RNSENP_SHIFT\t8\n#define NVALUERECIPROCAL_RNSENN_SHIFT\t0\n\n \n#define ERRCONFIG_ERRWEIGHT_SHIFT\t16\n#define ERRCONFIG_ERRMAXLIMIT_SHIFT\t8\n#define ERRCONFIG_ERRMINLIMIT_SHIFT\t0\n\n#define SR_ERRWEIGHT_MASK\t\t(0x07 << 16)\n#define SR_ERRMAXLIMIT_MASK\t\t(0xff << 8)\n#define SR_ERRMINLIMIT_MASK\t\t(0xff << 0)\n\n#define ERRCONFIG_VPBOUNDINTEN_V1\tBIT(31)\n#define ERRCONFIG_VPBOUNDINTST_V1\tBIT(30)\n#define\tERRCONFIG_MCUACCUMINTEN\t\tBIT(29)\n#define ERRCONFIG_MCUACCUMINTST\t\tBIT(28)\n#define\tERRCONFIG_MCUVALIDINTEN\t\tBIT(27)\n#define ERRCONFIG_MCUVALIDINTST\t\tBIT(26)\n#define ERRCONFIG_MCUBOUNDINTEN\t\tBIT(25)\n#define\tERRCONFIG_MCUBOUNDINTST\t\tBIT(24)\n#define\tERRCONFIG_MCUDISACKINTEN\tBIT(23)\n#define ERRCONFIG_VPBOUNDINTST_V2\tBIT(23)\n#define ERRCONFIG_MCUDISACKINTST\tBIT(22)\n#define ERRCONFIG_VPBOUNDINTEN_V2\tBIT(22)\n\n#define ERRCONFIG_STATUS_V1_MASK\t(ERRCONFIG_VPBOUNDINTST_V1 | \\\n\t\t\t\t\tERRCONFIG_MCUACCUMINTST | \\\n\t\t\t\t\tERRCONFIG_MCUVALIDINTST | \\\n\t\t\t\t\tERRCONFIG_MCUBOUNDINTST | \\\n\t\t\t\t\tERRCONFIG_MCUDISACKINTST)\n \n#define IRQSTATUS_MCUACCUMINT\t\tBIT(3)\n#define IRQSTATUS_MCVALIDINT\t\tBIT(2)\n#define IRQSTATUS_MCBOUNDSINT\t\tBIT(1)\n#define IRQSTATUS_MCUDISABLEACKINT\tBIT(0)\n\n \n#define IRQENABLE_MCUACCUMINT\t\tBIT(3)\n#define IRQENABLE_MCUVALIDINT\t\tBIT(2)\n#define IRQENABLE_MCUBOUNDSINT\t\tBIT(1)\n#define IRQENABLE_MCUDISABLEACKINT\tBIT(0)\n\n \n\n#define SRCLKLENGTH_12MHZ_SYSCLK\t0x3c\n#define SRCLKLENGTH_13MHZ_SYSCLK\t0x41\n#define SRCLKLENGTH_19MHZ_SYSCLK\t0x60\n#define SRCLKLENGTH_26MHZ_SYSCLK\t0x82\n#define SRCLKLENGTH_38MHZ_SYSCLK\t0xC0\n\n \n#define OMAP3430_SR_ACCUMDATA\t\t0x1f4\n\n#define OMAP3430_SR1_SENPAVGWEIGHT\t0x03\n#define OMAP3430_SR1_SENNAVGWEIGHT\t0x03\n\n#define OMAP3430_SR2_SENPAVGWEIGHT\t0x01\n#define OMAP3430_SR2_SENNAVGWEIGHT\t0x01\n\n#define OMAP3430_SR_ERRWEIGHT\t\t0x04\n#define OMAP3430_SR_ERRMAXLIMIT\t\t0x02\n\nenum sr_instance {\n\tOMAP_SR_MPU,\t\t\t \n\tOMAP_SR_CORE,\n\tOMAP_SR_IVA,\n\tOMAP_SR_NR,\n};\n\nstruct omap_sr {\n\tchar\t\t\t\t*name;\n\tstruct list_head\t\tnode;\n\tstruct platform_device\t\t*pdev;\n\tstruct omap_sr_nvalue_table\t*nvalue_table;\n\tstruct voltagedomain\t\t*voltdm;\n\tstruct dentry\t\t\t*dbg_dir;\n\tunsigned int\t\t\tirq;\n\tstruct clk\t\t\t*fck;\n\tint\t\t\t\tsrid;\n\tint\t\t\t\tip_type;\n\tint\t\t\t\tnvalue_count;\n\tbool\t\t\t\tautocomp_active;\n\tu32\t\t\t\tclk_length;\n\tu32\t\t\t\terr_weight;\n\tu32\t\t\t\terr_minlimit;\n\tu32\t\t\t\terr_maxlimit;\n\tu32\t\t\t\taccum_data;\n\tu32\t\t\t\tsenn_avgweight;\n\tu32\t\t\t\tsenp_avgweight;\n\tu32\t\t\t\tsenp_mod;\n\tu32\t\t\t\tsenn_mod;\n\tvoid __iomem\t\t\t*base;\n\tunsigned long\t\t\tenabled:1;\n};\n\n \n#define sr_test_cond_timeout(cond, timeout, index)\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tfor (index = 0; index < timeout; index++) {\t\t\\\n\t\tif (cond)\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\\\n\t\tudelay(1);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n})\n\n \nstruct omap_sr_pmic_data {\n\tvoid (*sr_pmic_init) (void);\n};\n\n \nstruct omap_smartreflex_dev_attr {\n\tconst char      *sensor_voltdm_name;\n};\n\n \n#define SR_CLASS1\t0x1\n#define SR_CLASS2\t0x2\n#define SR_CLASS3\t0x3\n\n \nstruct omap_sr_class_data {\n\tint (*enable)(struct omap_sr *sr);\n\tint (*disable)(struct omap_sr *sr, int is_volt_reset);\n\tint (*configure)(struct omap_sr *sr);\n\tint (*notify)(struct omap_sr *sr, u32 status);\n\tu8 notify_flags;\n\tu8 class_type;\n};\n\n \nstruct omap_sr_nvalue_table {\n\tu32 efuse_offs;\n\tu32 nvalue;\n\tu32 errminlimit;\n\tunsigned long volt_nominal;\n};\n\n \nstruct omap_sr_data {\n\tconst char\t\t\t*name;\n\tint\t\t\t\tip_type;\n\tu32\t\t\t\tsenp_mod;\n\tu32\t\t\t\tsenn_mod;\n\tu32\t\t\t\terr_weight;\n\tu32\t\t\t\terr_maxlimit;\n\tu32\t\t\t\taccum_data;\n\tu32\t\t\t\tsenn_avgweight;\n\tu32\t\t\t\tsenp_avgweight;\n\tint\t\t\t\tnvalue_count;\n\tstruct omap_sr_nvalue_table\t*nvalue_table;\n\tstruct voltagedomain\t\t*voltdm;\n};\n\n\nextern struct omap_sr_data omap_sr_pdata[OMAP_SR_NR];\n\n#ifdef CONFIG_POWER_AVS_OMAP\n\n \nvoid omap_sr_enable(struct voltagedomain *voltdm);\nvoid omap_sr_disable(struct voltagedomain *voltdm);\nvoid omap_sr_disable_reset_volt(struct voltagedomain *voltdm);\n\n \nint sr_enable(struct omap_sr *sr, unsigned long volt);\nvoid sr_disable(struct omap_sr *sr);\nint sr_configure_errgen(struct omap_sr *sr);\nint sr_disable_errgen(struct omap_sr *sr);\nint sr_configure_minmax(struct omap_sr *sr);\n\n \nint sr_register_class(struct omap_sr_class_data *class_data);\n#else\nstatic inline void omap_sr_enable(struct voltagedomain *voltdm) {}\nstatic inline void omap_sr_disable(struct voltagedomain *voltdm) {}\nstatic inline void omap_sr_disable_reset_volt(\n\t\tstruct voltagedomain *voltdm) {}\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}