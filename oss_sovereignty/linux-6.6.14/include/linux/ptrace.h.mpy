{
  "module_name": "ptrace.h",
  "hash_id": "1ed84b4aacda4bfbc94ee66bd87663e4721b7c3064b24e01b2342bdde1e5d098",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/ptrace.h",
  "human_readable_source": " \n#ifndef _LINUX_PTRACE_H\n#define _LINUX_PTRACE_H\n\n#include <linux/compiler.h>\t\t \n#include <linux/sched.h>\t\t \n#include <linux/sched/signal.h>\t\t \n#include <linux/err.h>\t\t\t \n#include <linux/bug.h>\t\t\t \n#include <linux/pid_namespace.h>\t \n#include <uapi/linux/ptrace.h>\n#include <linux/seccomp.h>\n\n \nstruct syscall_info {\n\t__u64\t\t\tsp;\n\tstruct seccomp_data\tdata;\n};\n\nextern int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t\t    void *buf, int len, unsigned int gup_flags);\n\n \n\n#define PT_SEIZED\t0x00010000\t \n#define PT_PTRACED\t0x00000001\n\n#define PT_OPT_FLAG_SHIFT\t3\n \n#define PT_EVENT_FLAG(event)\t(1 << (PT_OPT_FLAG_SHIFT + (event)))\n#define PT_TRACESYSGOOD\t\tPT_EVENT_FLAG(0)\n#define PT_TRACE_FORK\t\tPT_EVENT_FLAG(PTRACE_EVENT_FORK)\n#define PT_TRACE_VFORK\t\tPT_EVENT_FLAG(PTRACE_EVENT_VFORK)\n#define PT_TRACE_CLONE\t\tPT_EVENT_FLAG(PTRACE_EVENT_CLONE)\n#define PT_TRACE_EXEC\t\tPT_EVENT_FLAG(PTRACE_EVENT_EXEC)\n#define PT_TRACE_VFORK_DONE\tPT_EVENT_FLAG(PTRACE_EVENT_VFORK_DONE)\n#define PT_TRACE_EXIT\t\tPT_EVENT_FLAG(PTRACE_EVENT_EXIT)\n#define PT_TRACE_SECCOMP\tPT_EVENT_FLAG(PTRACE_EVENT_SECCOMP)\n\n#define PT_EXITKILL\t\t(PTRACE_O_EXITKILL << PT_OPT_FLAG_SHIFT)\n#define PT_SUSPEND_SECCOMP\t(PTRACE_O_SUSPEND_SECCOMP << PT_OPT_FLAG_SHIFT)\n\nextern long arch_ptrace(struct task_struct *child, long request,\n\t\t\tunsigned long addr, unsigned long data);\nextern int ptrace_readdata(struct task_struct *tsk, unsigned long src, char __user *dst, int len);\nextern int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len);\nextern void ptrace_disable(struct task_struct *);\nextern int ptrace_request(struct task_struct *child, long request,\n\t\t\t  unsigned long addr, unsigned long data);\nextern int ptrace_notify(int exit_code, unsigned long message);\nextern void __ptrace_link(struct task_struct *child,\n\t\t\t  struct task_struct *new_parent,\n\t\t\t  const struct cred *ptracer_cred);\nextern void __ptrace_unlink(struct task_struct *child);\nextern void exit_ptrace(struct task_struct *tracer, struct list_head *dead);\n#define PTRACE_MODE_READ\t0x01\n#define PTRACE_MODE_ATTACH\t0x02\n#define PTRACE_MODE_NOAUDIT\t0x04\n#define PTRACE_MODE_FSCREDS\t0x08\n#define PTRACE_MODE_REALCREDS\t0x10\n\n \n#define PTRACE_MODE_READ_FSCREDS (PTRACE_MODE_READ | PTRACE_MODE_FSCREDS)\n#define PTRACE_MODE_READ_REALCREDS (PTRACE_MODE_READ | PTRACE_MODE_REALCREDS)\n#define PTRACE_MODE_ATTACH_FSCREDS (PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS)\n#define PTRACE_MODE_ATTACH_REALCREDS (PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS)\n\n \nextern bool ptrace_may_access(struct task_struct *task, unsigned int mode);\n\nstatic inline int ptrace_reparented(struct task_struct *child)\n{\n\treturn !same_thread_group(child->real_parent, child->parent);\n}\n\nstatic inline void ptrace_unlink(struct task_struct *child)\n{\n\tif (unlikely(child->ptrace))\n\t\t__ptrace_unlink(child);\n}\n\nint generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data);\nint generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data);\n\n \nstatic inline struct task_struct *ptrace_parent(struct task_struct *task)\n{\n\tif (unlikely(task->ptrace))\n\t\treturn rcu_dereference(task->parent);\n\treturn NULL;\n}\n\n \nstatic inline bool ptrace_event_enabled(struct task_struct *task, int event)\n{\n\treturn task->ptrace & PT_EVENT_FLAG(event);\n}\n\n \nstatic inline void ptrace_event(int event, unsigned long message)\n{\n\tif (unlikely(ptrace_event_enabled(current, event))) {\n\t\tptrace_notify((event << 8) | SIGTRAP, message);\n\t} else if (event == PTRACE_EVENT_EXEC) {\n\t\t \n\t\tif ((current->ptrace & (PT_PTRACED|PT_SEIZED)) == PT_PTRACED)\n\t\t\tsend_sig(SIGTRAP, current, 0);\n\t}\n}\n\n \nstatic inline void ptrace_event_pid(int event, struct pid *pid)\n{\n\t \n\tunsigned long message = 0;\n\tstruct pid_namespace *ns;\n\n\trcu_read_lock();\n\tns = task_active_pid_ns(rcu_dereference(current->parent));\n\tif (ns)\n\t\tmessage = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\n\tptrace_event(event, message);\n}\n\n \nstatic inline void ptrace_init_task(struct task_struct *child, bool ptrace)\n{\n\tINIT_LIST_HEAD(&child->ptrace_entry);\n\tINIT_LIST_HEAD(&child->ptraced);\n\tchild->jobctl = 0;\n\tchild->ptrace = 0;\n\tchild->parent = child->real_parent;\n\n\tif (unlikely(ptrace) && current->ptrace) {\n\t\tchild->ptrace = current->ptrace;\n\t\t__ptrace_link(child, current->parent, current->ptracer_cred);\n\n\t\tif (child->ptrace & PT_SEIZED)\n\t\t\ttask_set_jobctl_pending(child, JOBCTL_TRAP_STOP);\n\t\telse\n\t\t\tsigaddset(&child->pending.signal, SIGSTOP);\n\t}\n\telse\n\t\tchild->ptracer_cred = NULL;\n}\n\n \nstatic inline void ptrace_release_task(struct task_struct *task)\n{\n\tBUG_ON(!list_empty(&task->ptraced));\n\tptrace_unlink(task);\n\tBUG_ON(!list_empty(&task->ptrace_entry));\n}\n\n#ifndef force_successful_syscall_return\n \n#define force_successful_syscall_return() do { } while (0)\n#endif\n\n#ifndef is_syscall_success\n \n#define is_syscall_success(regs) (!IS_ERR_VALUE((unsigned long)(regs_return_value(regs))))\n#endif\n\n \n\n#ifndef arch_has_single_step\n \n#define arch_has_single_step()\t\t(0)\n\n \nstatic inline void user_enable_single_step(struct task_struct *task)\n{\n\tBUG();\t\t\t \n}\n\n \nstatic inline void user_disable_single_step(struct task_struct *task)\n{\n}\n#else\nextern void user_enable_single_step(struct task_struct *);\nextern void user_disable_single_step(struct task_struct *);\n#endif\t \n\n#ifndef arch_has_block_step\n \n#define arch_has_block_step()\t\t(0)\n\n \nstatic inline void user_enable_block_step(struct task_struct *task)\n{\n\tBUG();\t\t\t \n}\n#else\nextern void user_enable_block_step(struct task_struct *);\n#endif\t \n\n#ifdef ARCH_HAS_USER_SINGLE_STEP_REPORT\nextern void user_single_step_report(struct pt_regs *regs);\n#else\nstatic inline void user_single_step_report(struct pt_regs *regs)\n{\n\tkernel_siginfo_t info;\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_USER;\n\tinfo.si_pid = 0;\n\tinfo.si_uid = 0;\n\tforce_sig_info(&info);\n}\n#endif\n\n#ifndef arch_ptrace_stop_needed\n \n#define arch_ptrace_stop_needed()\t(0)\n#endif\n\n#ifndef arch_ptrace_stop\n \n#define arch_ptrace_stop()\t\tdo { } while (0)\n#endif\n\n#ifndef current_pt_regs\n#define current_pt_regs() task_pt_regs(current)\n#endif\n\n#ifndef current_user_stack_pointer\n#define current_user_stack_pointer() user_stack_pointer(current_pt_regs())\n#endif\n\nextern int task_current_syscall(struct task_struct *target, struct syscall_info *info);\n\nextern void sigaction_compat_abi(struct k_sigaction *act, struct k_sigaction *oact);\n\n \nstatic inline int ptrace_report_syscall(unsigned long message)\n{\n\tint ptrace = current->ptrace;\n\tint signr;\n\n\tif (!(ptrace & PT_PTRACED))\n\t\treturn 0;\n\n\tsignr = ptrace_notify(SIGTRAP | ((ptrace & PT_TRACESYSGOOD) ? 0x80 : 0),\n\t\t\t      message);\n\n\t \n\tif (signr)\n\t\tsend_sig(signr, current, 1);\n\n\treturn fatal_signal_pending(current);\n}\n\n \nstatic inline __must_check int ptrace_report_syscall_entry(\n\tstruct pt_regs *regs)\n{\n\treturn ptrace_report_syscall(PTRACE_EVENTMSG_SYSCALL_ENTRY);\n}\n\n \nstatic inline void ptrace_report_syscall_exit(struct pt_regs *regs, int step)\n{\n\tif (step)\n\t\tuser_single_step_report(regs);\n\telse\n\t\tptrace_report_syscall(PTRACE_EVENTMSG_SYSCALL_EXIT);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}