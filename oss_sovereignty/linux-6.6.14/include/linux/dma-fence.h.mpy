{
  "module_name": "dma-fence.h",
  "hash_id": "bd9800d44bb484a52e9dbd473210ed5996bb162311bee19e06648d61f0b9b32e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/dma-fence.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_DMA_FENCE_H\n#define __LINUX_DMA_FENCE_H\n\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/kref.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/rcupdate.h>\n\nstruct dma_fence;\nstruct dma_fence_ops;\nstruct dma_fence_cb;\n\n \nstruct dma_fence {\n\tspinlock_t *lock;\n\tconst struct dma_fence_ops *ops;\n\t \n\tunion {\n\t\tstruct list_head cb_list;\n\t\t \n\t\tktime_t timestamp;\n\t\t \n\t\tstruct rcu_head rcu;\n\t};\n\tu64 context;\n\tu64 seqno;\n\tunsigned long flags;\n\tstruct kref refcount;\n\tint error;\n};\n\nenum dma_fence_flag_bits {\n\tDMA_FENCE_FLAG_SIGNALED_BIT,\n\tDMA_FENCE_FLAG_TIMESTAMP_BIT,\n\tDMA_FENCE_FLAG_ENABLE_SIGNAL_BIT,\n\tDMA_FENCE_FLAG_USER_BITS,  \n};\n\ntypedef void (*dma_fence_func_t)(struct dma_fence *fence,\n\t\t\t\t struct dma_fence_cb *cb);\n\n \nstruct dma_fence_cb {\n\tstruct list_head node;\n\tdma_fence_func_t func;\n};\n\n \nstruct dma_fence_ops {\n\t \n\tbool use_64bit_seqno;\n\n\t \n\tconst char * (*get_driver_name)(struct dma_fence *fence);\n\n\t \n\tconst char * (*get_timeline_name)(struct dma_fence *fence);\n\n\t \n\tbool (*enable_signaling)(struct dma_fence *fence);\n\n\t \n\tbool (*signaled)(struct dma_fence *fence);\n\n\t \n\tsigned long (*wait)(struct dma_fence *fence,\n\t\t\t    bool intr, signed long timeout);\n\n\t \n\tvoid (*release)(struct dma_fence *fence);\n\n\t \n\tvoid (*fence_value_str)(struct dma_fence *fence, char *str, int size);\n\n\t \n\tvoid (*timeline_value_str)(struct dma_fence *fence,\n\t\t\t\t   char *str, int size);\n\n\t \n\tvoid (*set_deadline)(struct dma_fence *fence, ktime_t deadline);\n};\n\nvoid dma_fence_init(struct dma_fence *fence, const struct dma_fence_ops *ops,\n\t\t    spinlock_t *lock, u64 context, u64 seqno);\n\nvoid dma_fence_release(struct kref *kref);\nvoid dma_fence_free(struct dma_fence *fence);\nvoid dma_fence_describe(struct dma_fence *fence, struct seq_file *seq);\n\n \nstatic inline void dma_fence_put(struct dma_fence *fence)\n{\n\tif (fence)\n\t\tkref_put(&fence->refcount, dma_fence_release);\n}\n\n \nstatic inline struct dma_fence *dma_fence_get(struct dma_fence *fence)\n{\n\tif (fence)\n\t\tkref_get(&fence->refcount);\n\treturn fence;\n}\n\n \nstatic inline struct dma_fence *dma_fence_get_rcu(struct dma_fence *fence)\n{\n\tif (kref_get_unless_zero(&fence->refcount))\n\t\treturn fence;\n\telse\n\t\treturn NULL;\n}\n\n \nstatic inline struct dma_fence *\ndma_fence_get_rcu_safe(struct dma_fence __rcu **fencep)\n{\n\tdo {\n\t\tstruct dma_fence *fence;\n\n\t\tfence = rcu_dereference(*fencep);\n\t\tif (!fence)\n\t\t\treturn NULL;\n\n\t\tif (!dma_fence_get_rcu(fence))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (fence == rcu_access_pointer(*fencep))\n\t\t\treturn rcu_pointer_handoff(fence);\n\n\t\tdma_fence_put(fence);\n\t} while (1);\n}\n\n#ifdef CONFIG_LOCKDEP\nbool dma_fence_begin_signalling(void);\nvoid dma_fence_end_signalling(bool cookie);\nvoid __dma_fence_might_wait(void);\n#else\nstatic inline bool dma_fence_begin_signalling(void)\n{\n\treturn true;\n}\nstatic inline void dma_fence_end_signalling(bool cookie) {}\nstatic inline void __dma_fence_might_wait(void) {}\n#endif\n\nint dma_fence_signal(struct dma_fence *fence);\nint dma_fence_signal_locked(struct dma_fence *fence);\nint dma_fence_signal_timestamp(struct dma_fence *fence, ktime_t timestamp);\nint dma_fence_signal_timestamp_locked(struct dma_fence *fence,\n\t\t\t\t      ktime_t timestamp);\nsigned long dma_fence_default_wait(struct dma_fence *fence,\n\t\t\t\t   bool intr, signed long timeout);\nint dma_fence_add_callback(struct dma_fence *fence,\n\t\t\t   struct dma_fence_cb *cb,\n\t\t\t   dma_fence_func_t func);\nbool dma_fence_remove_callback(struct dma_fence *fence,\n\t\t\t       struct dma_fence_cb *cb);\nvoid dma_fence_enable_sw_signaling(struct dma_fence *fence);\n\n \nstatic inline bool\ndma_fence_is_signaled_locked(struct dma_fence *fence)\n{\n\tif (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags))\n\t\treturn true;\n\n\tif (fence->ops->signaled && fence->ops->signaled(fence)) {\n\t\tdma_fence_signal_locked(fence);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic inline bool\ndma_fence_is_signaled(struct dma_fence *fence)\n{\n\tif (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags))\n\t\treturn true;\n\n\tif (fence->ops->signaled && fence->ops->signaled(fence)) {\n\t\tdma_fence_signal(fence);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic inline bool __dma_fence_is_later(u64 f1, u64 f2,\n\t\t\t\t\tconst struct dma_fence_ops *ops)\n{\n\t \n\tif (ops->use_64bit_seqno)\n\t\treturn f1 > f2;\n\n\treturn (int)(lower_32_bits(f1) - lower_32_bits(f2)) > 0;\n}\n\n \nstatic inline bool dma_fence_is_later(struct dma_fence *f1,\n\t\t\t\t      struct dma_fence *f2)\n{\n\tif (WARN_ON(f1->context != f2->context))\n\t\treturn false;\n\n\treturn __dma_fence_is_later(f1->seqno, f2->seqno, f1->ops);\n}\n\n \nstatic inline bool dma_fence_is_later_or_same(struct dma_fence *f1,\n\t\t\t\t\t      struct dma_fence *f2)\n{\n\treturn f1 == f2 || dma_fence_is_later(f1, f2);\n}\n\n \nstatic inline struct dma_fence *dma_fence_later(struct dma_fence *f1,\n\t\t\t\t\t\tstruct dma_fence *f2)\n{\n\tif (WARN_ON(f1->context != f2->context))\n\t\treturn NULL;\n\n\t \n\tif (dma_fence_is_later(f1, f2))\n\t\treturn dma_fence_is_signaled(f1) ? NULL : f1;\n\telse\n\t\treturn dma_fence_is_signaled(f2) ? NULL : f2;\n}\n\n \nstatic inline int dma_fence_get_status_locked(struct dma_fence *fence)\n{\n\tif (dma_fence_is_signaled_locked(fence))\n\t\treturn fence->error ?: 1;\n\telse\n\t\treturn 0;\n}\n\nint dma_fence_get_status(struct dma_fence *fence);\n\n \nstatic inline void dma_fence_set_error(struct dma_fence *fence,\n\t\t\t\t       int error)\n{\n\tWARN_ON(test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags));\n\tWARN_ON(error >= 0 || error < -MAX_ERRNO);\n\n\tfence->error = error;\n}\n\n \nstatic inline ktime_t dma_fence_timestamp(struct dma_fence *fence)\n{\n\tif (WARN_ON(!test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags)))\n\t\treturn ktime_get();\n\n\twhile (!test_bit(DMA_FENCE_FLAG_TIMESTAMP_BIT, &fence->flags))\n\t\tcpu_relax();\n\n\treturn fence->timestamp;\n}\n\nsigned long dma_fence_wait_timeout(struct dma_fence *,\n\t\t\t\t   bool intr, signed long timeout);\nsigned long dma_fence_wait_any_timeout(struct dma_fence **fences,\n\t\t\t\t       uint32_t count,\n\t\t\t\t       bool intr, signed long timeout,\n\t\t\t\t       uint32_t *idx);\n\n \nstatic inline signed long dma_fence_wait(struct dma_fence *fence, bool intr)\n{\n\tsigned long ret;\n\n\t \n\tret = dma_fence_wait_timeout(fence, intr, MAX_SCHEDULE_TIMEOUT);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nvoid dma_fence_set_deadline(struct dma_fence *fence, ktime_t deadline);\n\nstruct dma_fence *dma_fence_get_stub(void);\nstruct dma_fence *dma_fence_allocate_private_stub(ktime_t timestamp);\nu64 dma_fence_context_alloc(unsigned num);\n\nextern const struct dma_fence_ops dma_fence_array_ops;\nextern const struct dma_fence_ops dma_fence_chain_ops;\n\n \nstatic inline bool dma_fence_is_array(struct dma_fence *fence)\n{\n\treturn fence->ops == &dma_fence_array_ops;\n}\n\n \nstatic inline bool dma_fence_is_chain(struct dma_fence *fence)\n{\n\treturn fence->ops == &dma_fence_chain_ops;\n}\n\n \nstatic inline bool dma_fence_is_container(struct dma_fence *fence)\n{\n\treturn dma_fence_is_array(fence) || dma_fence_is_chain(fence);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}