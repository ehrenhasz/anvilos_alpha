{
  "module_name": "trace_recursion.h",
  "hash_id": "47a0eb58ab8afc98242812d54a4d2e892fc8311fb76f234b3b7ab3ab550d35d2",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/trace_recursion.h",
  "human_readable_source": " \n#ifndef _LINUX_TRACE_RECURSION_H\n#define _LINUX_TRACE_RECURSION_H\n\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n\n#ifdef CONFIG_TRACING\n\n \n\n \nenum {\n\t \n\tTRACE_FTRACE_BIT,\n\tTRACE_FTRACE_NMI_BIT,\n\tTRACE_FTRACE_IRQ_BIT,\n\tTRACE_FTRACE_SIRQ_BIT,\n\tTRACE_FTRACE_TRANSITION_BIT,\n\n\t \n\tTRACE_INTERNAL_BIT,\n\tTRACE_INTERNAL_NMI_BIT,\n\tTRACE_INTERNAL_IRQ_BIT,\n\tTRACE_INTERNAL_SIRQ_BIT,\n\tTRACE_INTERNAL_TRANSITION_BIT,\n\n\tTRACE_BRANCH_BIT,\n \n\tTRACE_IRQ_BIT,\n\n\t \n\tTRACE_GRAPH_BIT,\n\n\t \n\n\tTRACE_GRAPH_DEPTH_START_BIT,\n\tTRACE_GRAPH_DEPTH_END_BIT,\n\n\t \n\tTRACE_GRAPH_NOTRACE_BIT,\n\n\t \n\tTRACE_RECORD_RECURSION_BIT,\n};\n\n#define trace_recursion_set(bit)\tdo { (current)->trace_recursion |= (1<<(bit)); } while (0)\n#define trace_recursion_clear(bit)\tdo { (current)->trace_recursion &= ~(1<<(bit)); } while (0)\n#define trace_recursion_test(bit)\t((current)->trace_recursion & (1<<(bit)))\n\n#define trace_recursion_depth() \\\n\t(((current)->trace_recursion >> TRACE_GRAPH_DEPTH_START_BIT) & 3)\n#define trace_recursion_set_depth(depth) \\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tcurrent->trace_recursion &=\t\t\t\t\\\n\t\t\t~(3 << TRACE_GRAPH_DEPTH_START_BIT);\t\t\\\n\t\tcurrent->trace_recursion |=\t\t\t\t\\\n\t\t\t((depth) & 3) << TRACE_GRAPH_DEPTH_START_BIT;\t\\\n\t} while (0)\n\n#define TRACE_CONTEXT_BITS\t4\n\n#define TRACE_FTRACE_START\tTRACE_FTRACE_BIT\n\n#define TRACE_LIST_START\tTRACE_INTERNAL_BIT\n\n#define TRACE_CONTEXT_MASK\t((1 << (TRACE_LIST_START + TRACE_CONTEXT_BITS)) - 1)\n\n \nenum {\n\tTRACE_CTX_NMI,\n\tTRACE_CTX_IRQ,\n\tTRACE_CTX_SOFTIRQ,\n\tTRACE_CTX_NORMAL,\n\tTRACE_CTX_TRANSITION,\n};\n\nstatic __always_inline int trace_get_context_bit(void)\n{\n\tunsigned char bit = interrupt_context_level();\n\n\treturn TRACE_CTX_NORMAL - bit;\n}\n\n#ifdef CONFIG_FTRACE_RECORD_RECURSION\nextern void ftrace_record_recursion(unsigned long ip, unsigned long parent_ip);\n# define do_ftrace_record_recursion(ip, pip)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!trace_recursion_test(TRACE_RECORD_RECURSION_BIT)) { \\\n\t\t\ttrace_recursion_set(TRACE_RECORD_RECURSION_BIT); \\\n\t\t\tftrace_record_recursion(ip, pip);\t\t\\\n\t\t\ttrace_recursion_clear(TRACE_RECORD_RECURSION_BIT); \\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n#else\n# define do_ftrace_record_recursion(ip, pip)\tdo { } while (0)\n#endif\n\n#ifdef CONFIG_ARCH_WANTS_NO_INSTR\n# define trace_warn_on_no_rcu(ip)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tbool __ret = !rcu_is_watching();\t\t\t\\\n\t\tif (__ret && !trace_recursion_test(TRACE_RECORD_RECURSION_BIT)) { \\\n\t\t\ttrace_recursion_set(TRACE_RECORD_RECURSION_BIT); \\\n\t\t\tWARN_ONCE(true, \"RCU not on for: %pS\\n\", (void *)ip); \\\n\t\t\ttrace_recursion_clear(TRACE_RECORD_RECURSION_BIT); \\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t__ret;\t\t\t\t\t\t\t\\\n\t})\n#else\n# define trace_warn_on_no_rcu(ip)\tfalse\n#endif\n\n \nstatic __always_inline int trace_test_and_set_recursion(unsigned long ip, unsigned long pip,\n\t\t\t\t\t\t\tint start)\n{\n\tunsigned int val = READ_ONCE(current->trace_recursion);\n\tint bit;\n\n\tif (trace_warn_on_no_rcu(ip))\n\t\treturn -1;\n\n\tbit = trace_get_context_bit() + start;\n\tif (unlikely(val & (1 << bit))) {\n\t\t \n\t\tbit = TRACE_CTX_TRANSITION + start;\n\t\tif (val & (1 << bit)) {\n\t\t\tdo_ftrace_record_recursion(ip, pip);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tval |= 1 << bit;\n\tcurrent->trace_recursion = val;\n\tbarrier();\n\n\tpreempt_disable_notrace();\n\n\treturn bit;\n}\n\n \nstatic __always_inline void trace_clear_recursion(int bit)\n{\n\tpreempt_enable_notrace();\n\tbarrier();\n\ttrace_recursion_clear(bit);\n}\n\n \nstatic __always_inline int ftrace_test_recursion_trylock(unsigned long ip,\n\t\t\t\t\t\t\t unsigned long parent_ip)\n{\n\treturn trace_test_and_set_recursion(ip, parent_ip, TRACE_FTRACE_START);\n}\n\n \nstatic __always_inline void ftrace_test_recursion_unlock(int bit)\n{\n\ttrace_clear_recursion(bit);\n}\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}