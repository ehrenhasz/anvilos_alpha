{
  "module_name": "if_team.h",
  "hash_id": "8675c417630783bc38860704f4e8b855eb3d80188a42be4ae7138411f1e50b92",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/if_team.h",
  "human_readable_source": " \n \n#ifndef _LINUX_IF_TEAM_H_\n#define _LINUX_IF_TEAM_H_\n\n#include <linux/netpoll.h>\n#include <net/sch_generic.h>\n#include <linux/types.h>\n#include <uapi/linux/if_team.h>\n\nstruct team_pcpu_stats {\n\tu64_stats_t\t\trx_packets;\n\tu64_stats_t\t\trx_bytes;\n\tu64_stats_t\t\trx_multicast;\n\tu64_stats_t\t\ttx_packets;\n\tu64_stats_t\t\ttx_bytes;\n\tstruct u64_stats_sync\tsyncp;\n\tu32\t\t\trx_dropped;\n\tu32\t\t\ttx_dropped;\n\tu32\t\t\trx_nohandler;\n};\n\nstruct team;\n\nstruct team_port {\n\tstruct net_device *dev;\n\tstruct hlist_node hlist;  \n\tstruct list_head list;  \n\tstruct team *team;\n\tint index;  \n\n\tbool linkup;  \n\n\tstruct {\n\t\tbool linkup;\n\t\tu32 speed;\n\t\tu8 duplex;\n\t} state;\n\n\t \n\tstruct {\n\t\tbool linkup;\n\t\tbool linkup_enabled;\n\t} user;\n\n\t \n\tbool changed;\n\tbool removed;\n\n\t \n\tstruct {\n\t\tunsigned char dev_addr[MAX_ADDR_LEN];\n\t\tunsigned int mtu;\n\t} orig;\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\tstruct netpoll *np;\n#endif\n\n\ts32 priority;  \n\tu16 queue_id;\n\tstruct list_head qom_list;  \n\tstruct rcu_head\trcu;\n\tlong mode_priv[];\n};\n\nstatic inline struct team_port *team_port_get_rcu(const struct net_device *dev)\n{\n\treturn rcu_dereference(dev->rx_handler_data);\n}\n\nstatic inline bool team_port_enabled(struct team_port *port)\n{\n\treturn port->index != -1;\n}\n\nstatic inline bool team_port_txable(struct team_port *port)\n{\n\treturn port->linkup && team_port_enabled(port);\n}\n\nstatic inline bool team_port_dev_txable(const struct net_device *port_dev)\n{\n\tstruct team_port *port;\n\tbool txable;\n\n\trcu_read_lock();\n\tport = team_port_get_rcu(port_dev);\n\ttxable = port ? team_port_txable(port) : false;\n\trcu_read_unlock();\n\n\treturn txable;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic inline void team_netpoll_send_skb(struct team_port *port,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tnetpoll_send_skb(port->np, skb);\n}\n#else\nstatic inline void team_netpoll_send_skb(struct team_port *port,\n\t\t\t\t\t struct sk_buff *skb)\n{\n}\n#endif\n\nstruct team_mode_ops {\n\tint (*init)(struct team *team);\n\tvoid (*exit)(struct team *team);\n\trx_handler_result_t (*receive)(struct team *team,\n\t\t\t\t       struct team_port *port,\n\t\t\t\t       struct sk_buff *skb);\n\tbool (*transmit)(struct team *team, struct sk_buff *skb);\n\tint (*port_enter)(struct team *team, struct team_port *port);\n\tvoid (*port_leave)(struct team *team, struct team_port *port);\n\tvoid (*port_change_dev_addr)(struct team *team, struct team_port *port);\n\tvoid (*port_enabled)(struct team *team, struct team_port *port);\n\tvoid (*port_disabled)(struct team *team, struct team_port *port);\n};\n\nextern int team_modeop_port_enter(struct team *team, struct team_port *port);\nextern void team_modeop_port_change_dev_addr(struct team *team,\n\t\t\t\t\t     struct team_port *port);\n\nenum team_option_type {\n\tTEAM_OPTION_TYPE_U32,\n\tTEAM_OPTION_TYPE_STRING,\n\tTEAM_OPTION_TYPE_BINARY,\n\tTEAM_OPTION_TYPE_BOOL,\n\tTEAM_OPTION_TYPE_S32,\n};\n\nstruct team_option_inst_info {\n\tu32 array_index;\n\tstruct team_port *port;  \n};\n\nstruct team_gsetter_ctx {\n\tunion {\n\t\tu32 u32_val;\n\t\tconst char *str_val;\n\t\tstruct {\n\t\t\tconst void *ptr;\n\t\t\tu32 len;\n\t\t} bin_val;\n\t\tbool bool_val;\n\t\ts32 s32_val;\n\t} data;\n\tstruct team_option_inst_info *info;\n};\n\nstruct team_option {\n\tstruct list_head list;\n\tconst char *name;\n\tbool per_port;\n\tunsigned int array_size;  \n\tenum team_option_type type;\n\tvoid (*init)(struct team *team, struct team_option_inst_info *info);\n\tvoid (*getter)(struct team *team, struct team_gsetter_ctx *ctx);\n\tint (*setter)(struct team *team, struct team_gsetter_ctx *ctx);\n};\n\nextern void team_option_inst_set_change(struct team_option_inst_info *opt_inst_info);\nextern void team_options_change_check(struct team *team);\n\nstruct team_mode {\n\tconst char *kind;\n\tstruct module *owner;\n\tsize_t priv_size;\n\tsize_t port_priv_size;\n\tconst struct team_mode_ops *ops;\n\tenum netdev_lag_tx_type lag_tx_type;\n};\n\n#define TEAM_PORT_HASHBITS 4\n#define TEAM_PORT_HASHENTRIES (1 << TEAM_PORT_HASHBITS)\n\n#define TEAM_MODE_PRIV_LONGS 4\n#define TEAM_MODE_PRIV_SIZE (sizeof(long) * TEAM_MODE_PRIV_LONGS)\n\nstruct team {\n\tstruct net_device *dev;  \n\tstruct team_pcpu_stats __percpu *pcpu_stats;\n\n\tconst struct header_ops *header_ops_cache;\n\n\tstruct mutex lock;  \n\n\t \n\tint en_port_count;\n\tstruct hlist_head en_port_hlist[TEAM_PORT_HASHENTRIES];\n\n\tstruct list_head port_list;  \n\n\tstruct list_head option_list;\n\tstruct list_head option_inst_list;  \n\n\tconst struct team_mode *mode;\n\tstruct team_mode_ops ops;\n\tbool user_carrier_enabled;\n\tbool queue_override_enabled;\n\tstruct list_head *qom_lists;  \n\tbool port_mtu_change_allowed;\n\tbool notifier_ctx;\n\tstruct {\n\t\tunsigned int count;\n\t\tunsigned int interval;  \n\t\tatomic_t count_pending;\n\t\tstruct delayed_work dw;\n\t} notify_peers;\n\tstruct {\n\t\tunsigned int count;\n\t\tunsigned int interval;  \n\t\tatomic_t count_pending;\n\t\tstruct delayed_work dw;\n\t} mcast_rejoin;\n\tstruct lock_class_key team_lock_key;\n\tlong mode_priv[TEAM_MODE_PRIV_LONGS];\n};\n\nstatic inline int team_dev_queue_xmit(struct team *team, struct team_port *port,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tBUILD_BUG_ON(sizeof(skb->queue_mapping) !=\n\t\t     sizeof(qdisc_skb_cb(skb)->slave_dev_queue_mapping));\n\tskb_set_queue_mapping(skb, qdisc_skb_cb(skb)->slave_dev_queue_mapping);\n\n\tskb->dev = port->dev;\n\tif (unlikely(netpoll_tx_running(team->dev))) {\n\t\tteam_netpoll_send_skb(port, skb);\n\t\treturn 0;\n\t}\n\treturn dev_queue_xmit(skb);\n}\n\nstatic inline struct hlist_head *team_port_index_hash(struct team *team,\n\t\t\t\t\t\t      int port_index)\n{\n\treturn &team->en_port_hlist[port_index & (TEAM_PORT_HASHENTRIES - 1)];\n}\n\nstatic inline struct team_port *team_get_port_by_index(struct team *team,\n\t\t\t\t\t\t       int port_index)\n{\n\tstruct team_port *port;\n\tstruct hlist_head *head = team_port_index_hash(team, port_index);\n\n\thlist_for_each_entry(port, head, hlist)\n\t\tif (port->index == port_index)\n\t\t\treturn port;\n\treturn NULL;\n}\n\nstatic inline int team_num_to_port_index(struct team *team, unsigned int num)\n{\n\tint en_port_count = READ_ONCE(team->en_port_count);\n\n\tif (unlikely(!en_port_count))\n\t\treturn 0;\n\treturn num % en_port_count;\n}\n\nstatic inline struct team_port *team_get_port_by_index_rcu(struct team *team,\n\t\t\t\t\t\t\t   int port_index)\n{\n\tstruct team_port *port;\n\tstruct hlist_head *head = team_port_index_hash(team, port_index);\n\n\thlist_for_each_entry_rcu(port, head, hlist)\n\t\tif (port->index == port_index)\n\t\t\treturn port;\n\treturn NULL;\n}\n\nstatic inline struct team_port *\nteam_get_first_port_txable_rcu(struct team *team, struct team_port *port)\n{\n\tstruct team_port *cur;\n\n\tif (likely(team_port_txable(port)))\n\t\treturn port;\n\tcur = port;\n\tlist_for_each_entry_continue_rcu(cur, &team->port_list, list)\n\t\tif (team_port_txable(cur))\n\t\t\treturn cur;\n\tlist_for_each_entry_rcu(cur, &team->port_list, list) {\n\t\tif (cur == port)\n\t\t\tbreak;\n\t\tif (team_port_txable(cur))\n\t\t\treturn cur;\n\t}\n\treturn NULL;\n}\n\nextern int team_options_register(struct team *team,\n\t\t\t\t const struct team_option *option,\n\t\t\t\t size_t option_count);\nextern void team_options_unregister(struct team *team,\n\t\t\t\t    const struct team_option *option,\n\t\t\t\t    size_t option_count);\nextern int team_mode_register(const struct team_mode *mode);\nextern void team_mode_unregister(const struct team_mode *mode);\n\n#define TEAM_DEFAULT_NUM_TX_QUEUES 16\n#define TEAM_DEFAULT_NUM_RX_QUEUES 16\n\n#define MODULE_ALIAS_TEAM_MODE(kind) MODULE_ALIAS(\"team-mode-\" kind)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}