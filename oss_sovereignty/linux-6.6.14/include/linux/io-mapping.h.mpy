{
  "module_name": "io-mapping.h",
  "hash_id": "d22a3552dd5832e2eff38188cc5e4842b348e220e24339bd43554718949f652c",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/io-mapping.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_IO_MAPPING_H\n#define _LINUX_IO_MAPPING_H\n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/bug.h>\n#include <linux/io.h>\n#include <linux/pgtable.h>\n#include <asm/page.h>\n\n \n\nstruct io_mapping {\n\tresource_size_t base;\n\tunsigned long size;\n\tpgprot_t prot;\n\tvoid __iomem *iomem;\n};\n\n#ifdef CONFIG_HAVE_ATOMIC_IOMAP\n\n#include <linux/pfn.h>\n#include <asm/iomap.h>\n \n\nstatic inline struct io_mapping *\nio_mapping_init_wc(struct io_mapping *iomap,\n\t\t   resource_size_t base,\n\t\t   unsigned long size)\n{\n\tpgprot_t prot;\n\n\tif (iomap_create_wc(base, size, &prot))\n\t\treturn NULL;\n\n\tiomap->base = base;\n\tiomap->size = size;\n\tiomap->prot = prot;\n\treturn iomap;\n}\n\nstatic inline void\nio_mapping_fini(struct io_mapping *mapping)\n{\n\tiomap_free(mapping->base, mapping->size);\n}\n\n \nstatic inline void __iomem *\nio_mapping_map_atomic_wc(struct io_mapping *mapping,\n\t\t\t unsigned long offset)\n{\n\tresource_size_t phys_addr;\n\n\tBUG_ON(offset >= mapping->size);\n\tphys_addr = mapping->base + offset;\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tpreempt_disable();\n\telse\n\t\tmigrate_disable();\n\tpagefault_disable();\n\treturn __iomap_local_pfn_prot(PHYS_PFN(phys_addr), mapping->prot);\n}\n\nstatic inline void\nio_mapping_unmap_atomic(void __iomem *vaddr)\n{\n\tkunmap_local_indexed((void __force *)vaddr);\n\tpagefault_enable();\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tpreempt_enable();\n\telse\n\t\tmigrate_enable();\n}\n\nstatic inline void __iomem *\nio_mapping_map_local_wc(struct io_mapping *mapping, unsigned long offset)\n{\n\tresource_size_t phys_addr;\n\n\tBUG_ON(offset >= mapping->size);\n\tphys_addr = mapping->base + offset;\n\treturn __iomap_local_pfn_prot(PHYS_PFN(phys_addr), mapping->prot);\n}\n\nstatic inline void io_mapping_unmap_local(void __iomem *vaddr)\n{\n\tkunmap_local_indexed((void __force *)vaddr);\n}\n\nstatic inline void __iomem *\nio_mapping_map_wc(struct io_mapping *mapping,\n\t\t  unsigned long offset,\n\t\t  unsigned long size)\n{\n\tresource_size_t phys_addr;\n\n\tBUG_ON(offset >= mapping->size);\n\tphys_addr = mapping->base + offset;\n\n\treturn ioremap_wc(phys_addr, size);\n}\n\nstatic inline void\nio_mapping_unmap(void __iomem *vaddr)\n{\n\tiounmap(vaddr);\n}\n\n#else   \n\n#include <linux/uaccess.h>\n\n \nstatic inline struct io_mapping *\nio_mapping_init_wc(struct io_mapping *iomap,\n\t\t   resource_size_t base,\n\t\t   unsigned long size)\n{\n\tiomap->iomem = ioremap_wc(base, size);\n\tif (!iomap->iomem)\n\t\treturn NULL;\n\n\tiomap->base = base;\n\tiomap->size = size;\n\tiomap->prot = pgprot_writecombine(PAGE_KERNEL);\n\n\treturn iomap;\n}\n\nstatic inline void\nio_mapping_fini(struct io_mapping *mapping)\n{\n\tiounmap(mapping->iomem);\n}\n\n \nstatic inline void __iomem *\nio_mapping_map_wc(struct io_mapping *mapping,\n\t\t  unsigned long offset,\n\t\t  unsigned long size)\n{\n\treturn mapping->iomem + offset;\n}\n\nstatic inline void\nio_mapping_unmap(void __iomem *vaddr)\n{\n}\n\n \nstatic inline void __iomem *\nio_mapping_map_atomic_wc(struct io_mapping *mapping,\n\t\t\t unsigned long offset)\n{\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tpreempt_disable();\n\telse\n\t\tmigrate_disable();\n\tpagefault_disable();\n\treturn io_mapping_map_wc(mapping, offset, PAGE_SIZE);\n}\n\nstatic inline void\nio_mapping_unmap_atomic(void __iomem *vaddr)\n{\n\tio_mapping_unmap(vaddr);\n\tpagefault_enable();\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tpreempt_enable();\n\telse\n\t\tmigrate_enable();\n}\n\nstatic inline void __iomem *\nio_mapping_map_local_wc(struct io_mapping *mapping, unsigned long offset)\n{\n\treturn io_mapping_map_wc(mapping, offset, PAGE_SIZE);\n}\n\nstatic inline void io_mapping_unmap_local(void __iomem *vaddr)\n{\n\tio_mapping_unmap(vaddr);\n}\n\n#endif  \n\nstatic inline struct io_mapping *\nio_mapping_create_wc(resource_size_t base,\n\t\t     unsigned long size)\n{\n\tstruct io_mapping *iomap;\n\n\tiomap = kmalloc(sizeof(*iomap), GFP_KERNEL);\n\tif (!iomap)\n\t\treturn NULL;\n\n\tif (!io_mapping_init_wc(iomap, base, size)) {\n\t\tkfree(iomap);\n\t\treturn NULL;\n\t}\n\n\treturn iomap;\n}\n\nstatic inline void\nio_mapping_free(struct io_mapping *iomap)\n{\n\tio_mapping_fini(iomap);\n\tkfree(iomap);\n}\n\nint io_mapping_map_user(struct io_mapping *iomap, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long pfn, unsigned long size);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}