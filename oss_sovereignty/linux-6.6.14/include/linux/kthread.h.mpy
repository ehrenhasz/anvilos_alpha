{
  "module_name": "kthread.h",
  "hash_id": "d2d5ae9e440312d14fd6fe13abae8c7044a5daacb7a488ae60e16db2cd599a82",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/kthread.h",
  "human_readable_source": " \n#ifndef _LINUX_KTHREAD_H\n#define _LINUX_KTHREAD_H\n \n#include <linux/err.h>\n#include <linux/sched.h>\n\nstruct mm_struct;\n\n__printf(4, 5)\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data,\n\t\t\t\t\t   int node,\n\t\t\t\t\t   const char namefmt[], ...);\n\n \n#define kthread_create(threadfn, data, namefmt, arg...) \\\n\tkthread_create_on_node(threadfn, data, NUMA_NO_NODE, namefmt, ##arg)\n\n\nstruct task_struct *kthread_create_on_cpu(int (*threadfn)(void *data),\n\t\t\t\t\t  void *data,\n\t\t\t\t\t  unsigned int cpu,\n\t\t\t\t\t  const char *namefmt);\n\nvoid get_kthread_comm(char *buf, size_t buf_size, struct task_struct *tsk);\nbool set_kthread_struct(struct task_struct *p);\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu);\nbool kthread_is_per_cpu(struct task_struct *k);\n\n \n#define kthread_run(threadfn, data, namefmt, ...)\t\t\t   \\\n({\t\t\t\t\t\t\t\t\t   \\\n\tstruct task_struct *__k\t\t\t\t\t\t   \\\n\t\t= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \\\n\tif (!IS_ERR(__k))\t\t\t\t\t\t   \\\n\t\twake_up_process(__k);\t\t\t\t\t   \\\n\t__k;\t\t\t\t\t\t\t\t   \\\n})\n\n \nstatic inline struct task_struct *\nkthread_run_on_cpu(int (*threadfn)(void *data), void *data,\n\t\t\tunsigned int cpu, const char *namefmt)\n{\n\tstruct task_struct *p;\n\n\tp = kthread_create_on_cpu(threadfn, data, cpu, namefmt);\n\tif (!IS_ERR(p))\n\t\twake_up_process(p);\n\n\treturn p;\n}\n\nvoid free_kthread_struct(struct task_struct *k);\nvoid kthread_bind(struct task_struct *k, unsigned int cpu);\nvoid kthread_bind_mask(struct task_struct *k, const struct cpumask *mask);\nint kthread_stop(struct task_struct *k);\nbool kthread_should_stop(void);\nbool kthread_should_park(void);\nbool kthread_should_stop_or_park(void);\nbool kthread_freezable_should_stop(bool *was_frozen);\nvoid *kthread_func(struct task_struct *k);\nvoid *kthread_data(struct task_struct *k);\nvoid *kthread_probe_data(struct task_struct *k);\nint kthread_park(struct task_struct *k);\nvoid kthread_unpark(struct task_struct *k);\nvoid kthread_parkme(void);\nvoid kthread_exit(long result) __noreturn;\nvoid kthread_complete_and_exit(struct completion *, long) __noreturn;\n\nint kthreadd(void *unused);\nextern struct task_struct *kthreadd_task;\nextern int tsk_fork_get_node(struct task_struct *tsk);\n\n \nstruct kthread_work;\ntypedef void (*kthread_work_func_t)(struct kthread_work *work);\nvoid kthread_delayed_work_timer_fn(struct timer_list *t);\n\nenum {\n\tKTW_FREEZABLE\t\t= 1 << 0,\t \n};\n\nstruct kthread_worker {\n\tunsigned int\t\tflags;\n\traw_spinlock_t\t\tlock;\n\tstruct list_head\twork_list;\n\tstruct list_head\tdelayed_work_list;\n\tstruct task_struct\t*task;\n\tstruct kthread_work\t*current_work;\n};\n\nstruct kthread_work {\n\tstruct list_head\tnode;\n\tkthread_work_func_t\tfunc;\n\tstruct kthread_worker\t*worker;\n\t \n\tint\t\t\tcanceling;\n};\n\nstruct kthread_delayed_work {\n\tstruct kthread_work work;\n\tstruct timer_list timer;\n};\n\n#define KTHREAD_WORK_INIT(work, fn)\t{\t\t\t\t\\\n\t.node = LIST_HEAD_INIT((work).node),\t\t\t\t\\\n\t.func = (fn),\t\t\t\t\t\t\t\\\n\t}\n\n#define KTHREAD_DELAYED_WORK_INIT(dwork, fn) {\t\t\t\t\\\n\t.work = KTHREAD_WORK_INIT((dwork).work, (fn)),\t\t\t\\\n\t.timer = __TIMER_INITIALIZER(kthread_delayed_work_timer_fn,\\\n\t\t\t\t     TIMER_IRQSAFE),\t\t\t\\\n\t}\n\n#define DEFINE_KTHREAD_WORK(work, fn)\t\t\t\t\t\\\n\tstruct kthread_work work = KTHREAD_WORK_INIT(work, fn)\n\n#define DEFINE_KTHREAD_DELAYED_WORK(dwork, fn)\t\t\t\t\\\n\tstruct kthread_delayed_work dwork =\t\t\t\t\\\n\t\tKTHREAD_DELAYED_WORK_INIT(dwork, fn)\n\nextern void __kthread_init_worker(struct kthread_worker *worker,\n\t\t\tconst char *name, struct lock_class_key *key);\n\n#define kthread_init_worker(worker)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic struct lock_class_key __key;\t\t\t\\\n\t\t__kthread_init_worker((worker), \"(\"#worker\")->lock\", &__key); \\\n\t} while (0)\n\n#define kthread_init_work(work, fn)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tmemset((work), 0, sizeof(struct kthread_work));\t\t\\\n\t\tINIT_LIST_HEAD(&(work)->node);\t\t\t\t\\\n\t\t(work)->func = (fn);\t\t\t\t\t\\\n\t} while (0)\n\n#define kthread_init_delayed_work(dwork, fn)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tkthread_init_work(&(dwork)->work, (fn));\t\t\\\n\t\ttimer_setup(&(dwork)->timer,\t\t\t\t\\\n\t\t\t     kthread_delayed_work_timer_fn,\t\t\\\n\t\t\t     TIMER_IRQSAFE);\t\t\t\t\\\n\t} while (0)\n\nint kthread_worker_fn(void *worker_ptr);\n\n__printf(2, 3)\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...);\n\n__printf(3, 4) struct kthread_worker *\nkthread_create_worker_on_cpu(int cpu, unsigned int flags,\n\t\t\t     const char namefmt[], ...);\n\nbool kthread_queue_work(struct kthread_worker *worker,\n\t\t\tstruct kthread_work *work);\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay);\n\nbool kthread_mod_delayed_work(struct kthread_worker *worker,\n\t\t\t      struct kthread_delayed_work *dwork,\n\t\t\t      unsigned long delay);\n\nvoid kthread_flush_work(struct kthread_work *work);\nvoid kthread_flush_worker(struct kthread_worker *worker);\n\nbool kthread_cancel_work_sync(struct kthread_work *work);\nbool kthread_cancel_delayed_work_sync(struct kthread_delayed_work *work);\n\nvoid kthread_destroy_worker(struct kthread_worker *worker);\n\nvoid kthread_use_mm(struct mm_struct *mm);\nvoid kthread_unuse_mm(struct mm_struct *mm);\n\nstruct cgroup_subsys_state;\n\n#ifdef CONFIG_BLK_CGROUP\nvoid kthread_associate_blkcg(struct cgroup_subsys_state *css);\nstruct cgroup_subsys_state *kthread_blkcg(void);\n#else\nstatic inline void kthread_associate_blkcg(struct cgroup_subsys_state *css) { }\n#endif\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}