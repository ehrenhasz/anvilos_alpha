{
  "module_name": "fscache.h",
  "hash_id": "04dbd689a60de392536b2854449aacfd32a4599ee04394f3ac55d9988e5de1e9",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/fscache.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_FSCACHE_H\n#define _LINUX_FSCACHE_H\n\n#include <linux/fs.h>\n#include <linux/netfs.h>\n#include <linux/writeback.h>\n\n#if defined(CONFIG_FSCACHE) || defined(CONFIG_FSCACHE_MODULE)\n#define __fscache_available (1)\n#define fscache_available() (1)\n#define fscache_volume_valid(volume) (volume)\n#define fscache_cookie_valid(cookie) (cookie)\n#define fscache_resources_valid(cres) ((cres)->cache_priv)\n#define fscache_cookie_enabled(cookie) (cookie && !test_bit(FSCACHE_COOKIE_DISABLED, &cookie->flags))\n#else\n#define __fscache_available (0)\n#define fscache_available() (0)\n#define fscache_volume_valid(volume) (0)\n#define fscache_cookie_valid(cookie) (0)\n#define fscache_resources_valid(cres) (false)\n#define fscache_cookie_enabled(cookie) (0)\n#endif\n\nstruct fscache_cookie;\n\n#define FSCACHE_ADV_SINGLE_CHUNK\t0x01  \n#define FSCACHE_ADV_WRITE_CACHE\t\t0x00  \n#define FSCACHE_ADV_WRITE_NOCACHE\t0x02  \n#define FSCACHE_ADV_WANT_CACHE_SIZE\t0x04  \n\n#define FSCACHE_INVAL_DIO_WRITE\t\t0x01  \n\nenum fscache_want_state {\n\tFSCACHE_WANT_PARAMS,\n\tFSCACHE_WANT_WRITE,\n\tFSCACHE_WANT_READ,\n};\n\n \nenum fscache_cookie_state {\n\tFSCACHE_COOKIE_STATE_QUIESCENT,\t\t \n\tFSCACHE_COOKIE_STATE_LOOKING_UP,\t \n\tFSCACHE_COOKIE_STATE_CREATING,\t\t \n\tFSCACHE_COOKIE_STATE_ACTIVE,\t\t \n\tFSCACHE_COOKIE_STATE_INVALIDATING,\t \n\tFSCACHE_COOKIE_STATE_FAILED,\t\t \n\tFSCACHE_COOKIE_STATE_LRU_DISCARDING,\t \n\tFSCACHE_COOKIE_STATE_WITHDRAWING,\t \n\tFSCACHE_COOKIE_STATE_RELINQUISHING,\t \n\tFSCACHE_COOKIE_STATE_DROPPED,\t\t \n#define FSCACHE_COOKIE_STATE__NR (FSCACHE_COOKIE_STATE_DROPPED + 1)\n} __attribute__((mode(byte)));\n\n \nstruct fscache_volume {\n\trefcount_t\t\t\tref;\n\tatomic_t\t\t\tn_cookies;\t \n\tatomic_t\t\t\tn_accesses;\t \n\tunsigned int\t\t\tdebug_id;\n\tunsigned int\t\t\tkey_hash;\t \n\tu8\t\t\t\t*key;\t\t \n\tstruct list_head\t\tproc_link;\t \n\tstruct hlist_bl_node\t\thash_link;\t \n\tstruct work_struct\t\twork;\n\tstruct fscache_cache\t\t*cache;\t\t \n\tvoid\t\t\t\t*cache_priv;\t \n\tspinlock_t\t\t\tlock;\n\tunsigned long\t\t\tflags;\n#define FSCACHE_VOLUME_RELINQUISHED\t0\t \n#define FSCACHE_VOLUME_INVALIDATE\t1\t \n#define FSCACHE_VOLUME_COLLIDED_WITH\t2\t \n#define FSCACHE_VOLUME_ACQUIRE_PENDING\t3\t \n#define FSCACHE_VOLUME_CREATING\t\t4\t \n\tu8\t\t\t\tcoherency_len;\t \n\tu8\t\t\t\tcoherency[];\t \n};\n\n \nstruct fscache_cookie {\n\trefcount_t\t\t\tref;\n\tatomic_t\t\t\tn_active;\t \n\tatomic_t\t\t\tn_accesses;\t \n\tunsigned int\t\t\tdebug_id;\n\tunsigned int\t\t\tinval_counter;\t \n\tspinlock_t\t\t\tlock;\n\tstruct fscache_volume\t\t*volume;\t \n\tvoid\t\t\t\t*cache_priv;\t \n\tstruct hlist_bl_node\t\thash_link;\t \n\tstruct list_head\t\tproc_link;\t \n\tstruct list_head\t\tcommit_link;\t \n\tstruct work_struct\t\twork;\t\t \n\tloff_t\t\t\t\tobject_size;\t \n\tunsigned long\t\t\tunused_at;\t \n\tunsigned long\t\t\tflags;\n#define FSCACHE_COOKIE_RELINQUISHED\t0\t\t \n#define FSCACHE_COOKIE_RETIRED\t\t1\t\t \n#define FSCACHE_COOKIE_IS_CACHING\t2\t\t \n#define FSCACHE_COOKIE_NO_DATA_TO_READ\t3\t\t \n#define FSCACHE_COOKIE_NEEDS_UPDATE\t4\t\t \n#define FSCACHE_COOKIE_HAS_BEEN_CACHED\t5\t\t \n#define FSCACHE_COOKIE_DISABLED\t\t6\t\t \n#define FSCACHE_COOKIE_LOCAL_WRITE\t7\t\t \n#define FSCACHE_COOKIE_NO_ACCESS_WAKE\t8\t\t \n#define FSCACHE_COOKIE_DO_RELINQUISH\t9\t\t \n#define FSCACHE_COOKIE_DO_WITHDRAW\t10\t\t \n#define FSCACHE_COOKIE_DO_LRU_DISCARD\t11\t\t \n#define FSCACHE_COOKIE_DO_PREP_TO_WRITE\t12\t\t \n#define FSCACHE_COOKIE_HAVE_DATA\t13\t\t \n#define FSCACHE_COOKIE_IS_HASHED\t14\t\t \n#define FSCACHE_COOKIE_DO_INVALIDATE\t15\t\t \n\n\tenum fscache_cookie_state\tstate;\n\tu8\t\t\t\tadvice;\t\t \n\tu8\t\t\t\tkey_len;\t \n\tu8\t\t\t\taux_len;\t \n\tu32\t\t\t\tkey_hash;\t \n\tunion {\n\t\tvoid\t\t\t*key;\t\t \n\t\tu8\t\t\tinline_key[16];\t \n\t};\n\tunion {\n\t\tvoid\t\t\t*aux;\t\t \n\t\tu8\t\t\tinline_aux[8];\t \n\t};\n};\n\n \nextern struct fscache_volume *__fscache_acquire_volume(const char *, const char *,\n\t\t\t\t\t\t       const void *, size_t);\nextern void __fscache_relinquish_volume(struct fscache_volume *, const void *, bool);\n\nextern struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_volume *,\n\tu8,\n\tconst void *, size_t,\n\tconst void *, size_t,\n\tloff_t);\nextern void __fscache_use_cookie(struct fscache_cookie *, bool);\nextern void __fscache_unuse_cookie(struct fscache_cookie *, const void *, const loff_t *);\nextern void __fscache_relinquish_cookie(struct fscache_cookie *, bool);\nextern void __fscache_resize_cookie(struct fscache_cookie *, loff_t);\nextern void __fscache_invalidate(struct fscache_cookie *, const void *, loff_t, unsigned int);\nextern int __fscache_begin_read_operation(struct netfs_cache_resources *, struct fscache_cookie *);\nextern int __fscache_begin_write_operation(struct netfs_cache_resources *, struct fscache_cookie *);\n\nextern void __fscache_write_to_cache(struct fscache_cookie *, struct address_space *,\n\t\t\t\t     loff_t, size_t, loff_t, netfs_io_terminated_t, void *,\n\t\t\t\t     bool);\nextern void __fscache_clear_page_bits(struct address_space *, loff_t, size_t);\n\n \nstatic inline\nstruct fscache_volume *fscache_acquire_volume(const char *volume_key,\n\t\t\t\t\t      const char *cache_name,\n\t\t\t\t\t      const void *coherency_data,\n\t\t\t\t\t      size_t coherency_len)\n{\n\tif (!fscache_available())\n\t\treturn NULL;\n\treturn __fscache_acquire_volume(volume_key, cache_name,\n\t\t\t\t\tcoherency_data, coherency_len);\n}\n\n \nstatic inline\nvoid fscache_relinquish_volume(struct fscache_volume *volume,\n\t\t\t       const void *coherency_data,\n\t\t\t       bool invalidate)\n{\n\tif (fscache_volume_valid(volume))\n\t\t__fscache_relinquish_volume(volume, coherency_data, invalidate);\n}\n\n \nstatic inline\nstruct fscache_cookie *fscache_acquire_cookie(struct fscache_volume *volume,\n\t\t\t\t\t      u8 advice,\n\t\t\t\t\t      const void *index_key,\n\t\t\t\t\t      size_t index_key_len,\n\t\t\t\t\t      const void *aux_data,\n\t\t\t\t\t      size_t aux_data_len,\n\t\t\t\t\t      loff_t object_size)\n{\n\tif (!fscache_volume_valid(volume))\n\t\treturn NULL;\n\treturn __fscache_acquire_cookie(volume, advice,\n\t\t\t\t\tindex_key, index_key_len,\n\t\t\t\t\taux_data, aux_data_len,\n\t\t\t\t\tobject_size);\n}\n\n \nstatic inline void fscache_use_cookie(struct fscache_cookie *cookie,\n\t\t\t\t      bool will_modify)\n{\n\tif (fscache_cookie_valid(cookie))\n\t\t__fscache_use_cookie(cookie, will_modify);\n}\n\n \nstatic inline void fscache_unuse_cookie(struct fscache_cookie *cookie,\n\t\t\t\t\tconst void *aux_data,\n\t\t\t\t\tconst loff_t *object_size)\n{\n\tif (fscache_cookie_valid(cookie))\n\t\t__fscache_unuse_cookie(cookie, aux_data, object_size);\n}\n\n \nstatic inline\nvoid fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tif (fscache_cookie_valid(cookie))\n\t\t__fscache_relinquish_cookie(cookie, retire);\n}\n\n \nstatic inline void *fscache_get_aux(struct fscache_cookie *cookie)\n{\n\tif (cookie->aux_len <= sizeof(cookie->inline_aux))\n\t\treturn cookie->inline_aux;\n\telse\n\t\treturn cookie->aux;\n}\n\n \nstatic inline\nvoid fscache_update_aux(struct fscache_cookie *cookie,\n\t\t\tconst void *aux_data, const loff_t *object_size)\n{\n\tvoid *p = fscache_get_aux(cookie);\n\n\tif (aux_data && p)\n\t\tmemcpy(p, aux_data, cookie->aux_len);\n\tif (object_size)\n\t\tcookie->object_size = *object_size;\n}\n\n#ifdef CONFIG_FSCACHE_STATS\nextern atomic_t fscache_n_updates;\n#endif\n\nstatic inline\nvoid __fscache_update_cookie(struct fscache_cookie *cookie, const void *aux_data,\n\t\t\t     const loff_t *object_size)\n{\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_updates);\n#endif\n\tfscache_update_aux(cookie, aux_data, object_size);\n\tsmp_wmb();\n\tset_bit(FSCACHE_COOKIE_NEEDS_UPDATE, &cookie->flags);\n}\n\n \nstatic inline\nvoid fscache_update_cookie(struct fscache_cookie *cookie, const void *aux_data,\n\t\t\t   const loff_t *object_size)\n{\n\tif (fscache_cookie_enabled(cookie))\n\t\t__fscache_update_cookie(cookie, aux_data, object_size);\n}\n\n \nstatic inline\nvoid fscache_resize_cookie(struct fscache_cookie *cookie, loff_t new_size)\n{\n\tif (fscache_cookie_enabled(cookie))\n\t\t__fscache_resize_cookie(cookie, new_size);\n}\n\n \nstatic inline\nvoid fscache_invalidate(struct fscache_cookie *cookie,\n\t\t\tconst void *aux_data, loff_t size, unsigned int flags)\n{\n\tif (fscache_cookie_enabled(cookie))\n\t\t__fscache_invalidate(cookie, aux_data, size, flags);\n}\n\n \nstatic inline\nconst struct netfs_cache_ops *fscache_operation_valid(const struct netfs_cache_resources *cres)\n{\n\treturn fscache_resources_valid(cres) ? cres->ops : NULL;\n}\n\n \nstatic inline\nint fscache_begin_read_operation(struct netfs_cache_resources *cres,\n\t\t\t\t struct fscache_cookie *cookie)\n{\n\tif (fscache_cookie_enabled(cookie))\n\t\treturn __fscache_begin_read_operation(cres, cookie);\n\treturn -ENOBUFS;\n}\n\n \nstatic inline void fscache_end_operation(struct netfs_cache_resources *cres)\n{\n\tconst struct netfs_cache_ops *ops = fscache_operation_valid(cres);\n\n\tif (ops)\n\t\tops->end_operation(cres);\n}\n\n \nstatic inline\nint fscache_read(struct netfs_cache_resources *cres,\n\t\t loff_t start_pos,\n\t\t struct iov_iter *iter,\n\t\t enum netfs_read_from_hole read_hole,\n\t\t netfs_io_terminated_t term_func,\n\t\t void *term_func_priv)\n{\n\tconst struct netfs_cache_ops *ops = fscache_operation_valid(cres);\n\treturn ops->read(cres, start_pos, iter, read_hole,\n\t\t\t term_func, term_func_priv);\n}\n\n \nstatic inline\nint fscache_begin_write_operation(struct netfs_cache_resources *cres,\n\t\t\t\t  struct fscache_cookie *cookie)\n{\n\tif (fscache_cookie_enabled(cookie))\n\t\treturn __fscache_begin_write_operation(cres, cookie);\n\treturn -ENOBUFS;\n}\n\n \nstatic inline\nint fscache_write(struct netfs_cache_resources *cres,\n\t\t  loff_t start_pos,\n\t\t  struct iov_iter *iter,\n\t\t  netfs_io_terminated_t term_func,\n\t\t  void *term_func_priv)\n{\n\tconst struct netfs_cache_ops *ops = fscache_operation_valid(cres);\n\treturn ops->write(cres, start_pos, iter, term_func, term_func_priv);\n}\n\n \nstatic inline void fscache_clear_page_bits(struct address_space *mapping,\n\t\t\t\t\t   loff_t start, size_t len,\n\t\t\t\t\t   bool caching)\n{\n\tif (caching)\n\t\t__fscache_clear_page_bits(mapping, start, len);\n}\n\n \nstatic inline void fscache_write_to_cache(struct fscache_cookie *cookie,\n\t\t\t\t\t  struct address_space *mapping,\n\t\t\t\t\t  loff_t start, size_t len, loff_t i_size,\n\t\t\t\t\t  netfs_io_terminated_t term_func,\n\t\t\t\t\t  void *term_func_priv,\n\t\t\t\t\t  bool caching)\n{\n\tif (caching)\n\t\t__fscache_write_to_cache(cookie, mapping, start, len, i_size,\n\t\t\t\t\t term_func, term_func_priv, caching);\n\telse if (term_func)\n\t\tterm_func(term_func_priv, -ENOBUFS, false);\n\n}\n\n#if __fscache_available\nbool fscache_dirty_folio(struct address_space *mapping, struct folio *folio,\n\t\tstruct fscache_cookie *cookie);\n#else\n#define fscache_dirty_folio(MAPPING, FOLIO, COOKIE) \\\n\t\tfilemap_dirty_folio(MAPPING, FOLIO)\n#endif\n\n \nstatic inline void fscache_unpin_writeback(struct writeback_control *wbc,\n\t\t\t\t\t   struct fscache_cookie *cookie)\n{\n\tif (wbc->unpinned_fscache_wb)\n\t\tfscache_unuse_cookie(cookie, NULL, NULL);\n}\n\n \nstatic inline void fscache_clear_inode_writeback(struct fscache_cookie *cookie,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t const void *aux)\n{\n\tif (inode->i_state & I_PINNING_FSCACHE_WB) {\n\t\tloff_t i_size = i_size_read(inode);\n\t\tfscache_unuse_cookie(cookie, aux, &i_size);\n\t}\n}\n\n \nstatic inline\nvoid fscache_note_page_release(struct fscache_cookie *cookie)\n{\n\t \n\tif (cookie &&\n\t    test_bit(FSCACHE_COOKIE_HAVE_DATA, &cookie->flags) &&\n\t    test_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags))\n\t\tclear_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}