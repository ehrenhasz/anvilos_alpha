{
  "module_name": "scmi_protocol.h",
  "hash_id": "81defe0075b79c293c9a7aaeef3744c72477151c647836241f062706387fc88e",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/scmi_protocol.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_SCMI_PROTOCOL_H\n#define _LINUX_SCMI_PROTOCOL_H\n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/notifier.h>\n#include <linux/types.h>\n\n#define SCMI_MAX_STR_SIZE\t\t64\n#define SCMI_SHORT_NAME_MAX_SIZE\t16\n#define SCMI_MAX_NUM_RATES\t\t16\n\n \nstruct scmi_revision_info {\n\tu16 major_ver;\n\tu16 minor_ver;\n\tu8 num_protocols;\n\tu8 num_agents;\n\tu32 impl_ver;\n\tchar vendor_id[SCMI_SHORT_NAME_MAX_SIZE];\n\tchar sub_vendor_id[SCMI_SHORT_NAME_MAX_SIZE];\n};\n\nstruct scmi_clock_info {\n\tchar name[SCMI_MAX_STR_SIZE];\n\tunsigned int enable_latency;\n\tbool rate_discrete;\n\tbool rate_changed_notifications;\n\tbool rate_change_requested_notifications;\n\tunion {\n\t\tstruct {\n\t\t\tint num_rates;\n\t\t\tu64 rates[SCMI_MAX_NUM_RATES];\n\t\t} list;\n\t\tstruct {\n\t\t\tu64 min_rate;\n\t\t\tu64 max_rate;\n\t\t\tu64 step_size;\n\t\t} range;\n\t};\n};\n\nenum scmi_power_scale {\n\tSCMI_POWER_BOGOWATTS,\n\tSCMI_POWER_MILLIWATTS,\n\tSCMI_POWER_MICROWATTS\n};\n\nstruct scmi_handle;\nstruct scmi_device;\nstruct scmi_protocol_handle;\n\n \nstruct scmi_clk_proto_ops {\n\tint (*count_get)(const struct scmi_protocol_handle *ph);\n\n\tconst struct scmi_clock_info __must_check *(*info_get)\n\t\t(const struct scmi_protocol_handle *ph, u32 clk_id);\n\tint (*rate_get)(const struct scmi_protocol_handle *ph, u32 clk_id,\n\t\t\tu64 *rate);\n\tint (*rate_set)(const struct scmi_protocol_handle *ph, u32 clk_id,\n\t\t\tu64 rate);\n\tint (*enable)(const struct scmi_protocol_handle *ph, u32 clk_id);\n\tint (*disable)(const struct scmi_protocol_handle *ph, u32 clk_id);\n\tint (*enable_atomic)(const struct scmi_protocol_handle *ph, u32 clk_id);\n\tint (*disable_atomic)(const struct scmi_protocol_handle *ph,\n\t\t\t      u32 clk_id);\n};\n\nstruct scmi_perf_domain_info {\n\tchar name[SCMI_MAX_STR_SIZE];\n\tbool set_perf;\n};\n\n \nstruct scmi_perf_proto_ops {\n\tint (*num_domains_get)(const struct scmi_protocol_handle *ph);\n\tconst struct scmi_perf_domain_info __must_check *(*info_get)\n\t\t(const struct scmi_protocol_handle *ph, u32 domain);\n\tint (*limits_set)(const struct scmi_protocol_handle *ph, u32 domain,\n\t\t\t  u32 max_perf, u32 min_perf);\n\tint (*limits_get)(const struct scmi_protocol_handle *ph, u32 domain,\n\t\t\t  u32 *max_perf, u32 *min_perf);\n\tint (*level_set)(const struct scmi_protocol_handle *ph, u32 domain,\n\t\t\t u32 level, bool poll);\n\tint (*level_get)(const struct scmi_protocol_handle *ph, u32 domain,\n\t\t\t u32 *level, bool poll);\n\tint (*device_domain_id)(struct device *dev);\n\tint (*transition_latency_get)(const struct scmi_protocol_handle *ph,\n\t\t\t\t      struct device *dev);\n\tint (*device_opps_add)(const struct scmi_protocol_handle *ph,\n\t\t\t       struct device *dev);\n\tint (*freq_set)(const struct scmi_protocol_handle *ph, u32 domain,\n\t\t\tunsigned long rate, bool poll);\n\tint (*freq_get)(const struct scmi_protocol_handle *ph, u32 domain,\n\t\t\tunsigned long *rate, bool poll);\n\tint (*est_power_get)(const struct scmi_protocol_handle *ph, u32 domain,\n\t\t\t     unsigned long *rate, unsigned long *power);\n\tbool (*fast_switch_possible)(const struct scmi_protocol_handle *ph,\n\t\t\t\t     struct device *dev);\n\tenum scmi_power_scale (*power_scale_get)(const struct scmi_protocol_handle *ph);\n};\n\n \nstruct scmi_power_proto_ops {\n\tint (*num_domains_get)(const struct scmi_protocol_handle *ph);\n\tconst char *(*name_get)(const struct scmi_protocol_handle *ph,\n\t\t\t\tu32 domain);\n#define SCMI_POWER_STATE_TYPE_SHIFT\t30\n#define SCMI_POWER_STATE_ID_MASK\t(BIT(28) - 1)\n#define SCMI_POWER_STATE_PARAM(type, id) \\\n\t((((type) & BIT(0)) << SCMI_POWER_STATE_TYPE_SHIFT) | \\\n\t\t((id) & SCMI_POWER_STATE_ID_MASK))\n#define SCMI_POWER_STATE_GENERIC_ON\tSCMI_POWER_STATE_PARAM(0, 0)\n#define SCMI_POWER_STATE_GENERIC_OFF\tSCMI_POWER_STATE_PARAM(1, 0)\n\tint (*state_set)(const struct scmi_protocol_handle *ph, u32 domain,\n\t\t\t u32 state);\n\tint (*state_get)(const struct scmi_protocol_handle *ph, u32 domain,\n\t\t\t u32 *state);\n};\n\n \nstruct scmi_sensor_reading {\n\tlong long value;\n\tunsigned long long timestamp;\n};\n\n \nstruct scmi_range_attrs {\n\tlong long min_range;\n\tlong long max_range;\n};\n\n \nstruct scmi_sensor_axis_info {\n\tunsigned int id;\n\tunsigned int type;\n\tint scale;\n\tchar name[SCMI_MAX_STR_SIZE];\n\tbool extended_attrs;\n\tunsigned int resolution;\n\tint exponent;\n\tstruct scmi_range_attrs attrs;\n};\n\n \nstruct scmi_sensor_intervals_info {\n\tbool segmented;\n\tunsigned int count;\n#define SCMI_SENS_INTVL_SEGMENT_LOW\t0\n#define SCMI_SENS_INTVL_SEGMENT_HIGH\t1\n#define SCMI_SENS_INTVL_SEGMENT_STEP\t2\n\tunsigned int *desc;\n#define SCMI_SENS_INTVL_GET_SECS(x)\t\tFIELD_GET(GENMASK(20, 5), (x))\n#define SCMI_SENS_INTVL_GET_EXP(x)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint __signed_exp = FIELD_GET(GENMASK(4, 0), (x));\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (__signed_exp & BIT(4))\t\t\t\t\\\n\t\t\t__signed_exp |= GENMASK(31, 5);\t\t\t\\\n\t\t__signed_exp;\t\t\t\t\t\t\\\n\t})\n#define SCMI_MAX_PREALLOC_POOL\t\t\t16\n\tunsigned int prealloc_pool[SCMI_MAX_PREALLOC_POOL];\n};\n\n \nstruct scmi_sensor_info {\n\tunsigned int id;\n\tunsigned int type;\n\tint scale;\n\tunsigned int num_trip_points;\n\tbool async;\n\tbool update;\n\tbool timestamped;\n\tint tstamp_scale;\n\tunsigned int num_axis;\n\tstruct scmi_sensor_axis_info *axis;\n\tstruct scmi_sensor_intervals_info intervals;\n\tunsigned int sensor_config;\n#define SCMI_SENS_CFG_UPDATE_SECS_MASK\t\tGENMASK(31, 16)\n#define SCMI_SENS_CFG_GET_UPDATE_SECS(x)\t\t\t\t\\\n\tFIELD_GET(SCMI_SENS_CFG_UPDATE_SECS_MASK, (x))\n\n#define SCMI_SENS_CFG_UPDATE_EXP_MASK\t\tGENMASK(15, 11)\n#define SCMI_SENS_CFG_GET_UPDATE_EXP(x)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint __signed_exp =\t\t\t\t\t\\\n\t\t\tFIELD_GET(SCMI_SENS_CFG_UPDATE_EXP_MASK, (x));\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (__signed_exp & BIT(4))\t\t\t\t\\\n\t\t\t__signed_exp |= GENMASK(31, 5);\t\t\t\\\n\t\t__signed_exp;\t\t\t\t\t\t\\\n\t})\n\n#define SCMI_SENS_CFG_ROUND_MASK\t\tGENMASK(10, 9)\n#define SCMI_SENS_CFG_ROUND_AUTO\t\t2\n#define SCMI_SENS_CFG_ROUND_UP\t\t\t1\n#define SCMI_SENS_CFG_ROUND_DOWN\t\t0\n\n#define SCMI_SENS_CFG_TSTAMP_ENABLED_MASK\tBIT(1)\n#define SCMI_SENS_CFG_TSTAMP_ENABLE\t\t1\n#define SCMI_SENS_CFG_TSTAMP_DISABLE\t\t0\n#define SCMI_SENS_CFG_IS_TSTAMP_ENABLED(x)\t\t\t\t\\\n\tFIELD_GET(SCMI_SENS_CFG_TSTAMP_ENABLED_MASK, (x))\n\n#define SCMI_SENS_CFG_SENSOR_ENABLED_MASK\tBIT(0)\n#define SCMI_SENS_CFG_SENSOR_ENABLE\t\t1\n#define SCMI_SENS_CFG_SENSOR_DISABLE\t\t0\n\tchar name[SCMI_MAX_STR_SIZE];\n#define SCMI_SENS_CFG_IS_ENABLED(x)\t\tFIELD_GET(BIT(0), (x))\n\tbool extended_scalar_attrs;\n\tunsigned int sensor_power;\n\tunsigned int resolution;\n\tint exponent;\n\tstruct scmi_range_attrs scalar_attrs;\n};\n\n \nenum scmi_sensor_class {\n\tNONE = 0x0,\n\tUNSPEC = 0x1,\n\tTEMPERATURE_C = 0x2,\n\tTEMPERATURE_F = 0x3,\n\tTEMPERATURE_K = 0x4,\n\tVOLTAGE = 0x5,\n\tCURRENT = 0x6,\n\tPOWER = 0x7,\n\tENERGY = 0x8,\n\tCHARGE = 0x9,\n\tVOLTAMPERE = 0xA,\n\tNITS = 0xB,\n\tLUMENS = 0xC,\n\tLUX = 0xD,\n\tCANDELAS = 0xE,\n\tKPA = 0xF,\n\tPSI = 0x10,\n\tNEWTON = 0x11,\n\tCFM = 0x12,\n\tRPM = 0x13,\n\tHERTZ = 0x14,\n\tSECS = 0x15,\n\tMINS = 0x16,\n\tHOURS = 0x17,\n\tDAYS = 0x18,\n\tWEEKS = 0x19,\n\tMILS = 0x1A,\n\tINCHES = 0x1B,\n\tFEET = 0x1C,\n\tCUBIC_INCHES = 0x1D,\n\tCUBIC_FEET = 0x1E,\n\tMETERS = 0x1F,\n\tCUBIC_CM = 0x20,\n\tCUBIC_METERS = 0x21,\n\tLITERS = 0x22,\n\tFLUID_OUNCES = 0x23,\n\tRADIANS = 0x24,\n\tSTERADIANS = 0x25,\n\tREVOLUTIONS = 0x26,\n\tCYCLES = 0x27,\n\tGRAVITIES = 0x28,\n\tOUNCES = 0x29,\n\tPOUNDS = 0x2A,\n\tFOOT_POUNDS = 0x2B,\n\tOUNCE_INCHES = 0x2C,\n\tGAUSS = 0x2D,\n\tGILBERTS = 0x2E,\n\tHENRIES = 0x2F,\n\tFARADS = 0x30,\n\tOHMS = 0x31,\n\tSIEMENS = 0x32,\n\tMOLES = 0x33,\n\tBECQUERELS = 0x34,\n\tPPM = 0x35,\n\tDECIBELS = 0x36,\n\tDBA = 0x37,\n\tDBC = 0x38,\n\tGRAYS = 0x39,\n\tSIEVERTS = 0x3A,\n\tCOLOR_TEMP_K = 0x3B,\n\tBITS = 0x3C,\n\tBYTES = 0x3D,\n\tWORDS = 0x3E,\n\tDWORDS = 0x3F,\n\tQWORDS = 0x40,\n\tPERCENTAGE = 0x41,\n\tPASCALS = 0x42,\n\tCOUNTS = 0x43,\n\tGRAMS = 0x44,\n\tNEWTON_METERS = 0x45,\n\tHITS = 0x46,\n\tMISSES = 0x47,\n\tRETRIES = 0x48,\n\tOVERRUNS = 0x49,\n\tUNDERRUNS = 0x4A,\n\tCOLLISIONS = 0x4B,\n\tPACKETS = 0x4C,\n\tMESSAGES = 0x4D,\n\tCHARS = 0x4E,\n\tERRORS = 0x4F,\n\tCORRECTED_ERRS = 0x50,\n\tUNCORRECTABLE_ERRS = 0x51,\n\tSQ_MILS = 0x52,\n\tSQ_INCHES = 0x53,\n\tSQ_FEET = 0x54,\n\tSQ_CM = 0x55,\n\tSQ_METERS = 0x56,\n\tRADIANS_SEC = 0x57,\n\tBPM = 0x58,\n\tMETERS_SEC_SQUARED = 0x59,\n\tMETERS_SEC = 0x5A,\n\tCUBIC_METERS_SEC = 0x5B,\n\tMM_MERCURY = 0x5C,\n\tRADIANS_SEC_SQUARED = 0x5D,\n\tOEM_UNIT = 0xFF\n};\n\n \nstruct scmi_sensor_proto_ops {\n\tint (*count_get)(const struct scmi_protocol_handle *ph);\n\tconst struct scmi_sensor_info __must_check *(*info_get)\n\t\t(const struct scmi_protocol_handle *ph, u32 sensor_id);\n\tint (*trip_point_config)(const struct scmi_protocol_handle *ph,\n\t\t\t\t u32 sensor_id, u8 trip_id, u64 trip_value);\n\tint (*reading_get)(const struct scmi_protocol_handle *ph, u32 sensor_id,\n\t\t\t   u64 *value);\n\tint (*reading_get_timestamped)(const struct scmi_protocol_handle *ph,\n\t\t\t\t       u32 sensor_id, u8 count,\n\t\t\t\t       struct scmi_sensor_reading *readings);\n\tint (*config_get)(const struct scmi_protocol_handle *ph,\n\t\t\t  u32 sensor_id, u32 *sensor_config);\n\tint (*config_set)(const struct scmi_protocol_handle *ph,\n\t\t\t  u32 sensor_id, u32 sensor_config);\n};\n\n \nstruct scmi_reset_proto_ops {\n\tint (*num_domains_get)(const struct scmi_protocol_handle *ph);\n\tconst char *(*name_get)(const struct scmi_protocol_handle *ph,\n\t\t\t\tu32 domain);\n\tint (*latency_get)(const struct scmi_protocol_handle *ph, u32 domain);\n\tint (*reset)(const struct scmi_protocol_handle *ph, u32 domain);\n\tint (*assert)(const struct scmi_protocol_handle *ph, u32 domain);\n\tint (*deassert)(const struct scmi_protocol_handle *ph, u32 domain);\n};\n\nenum scmi_voltage_level_mode {\n\tSCMI_VOLTAGE_LEVEL_SET_AUTO,\n\tSCMI_VOLTAGE_LEVEL_SET_SYNC,\n};\n\n \nstruct scmi_voltage_info {\n\tunsigned int id;\n\tbool segmented;\n\tbool negative_volts_allowed;\n\tbool async_level_set;\n\tchar name[SCMI_MAX_STR_SIZE];\n\tunsigned int num_levels;\n#define SCMI_VOLTAGE_SEGMENT_LOW\t0\n#define SCMI_VOLTAGE_SEGMENT_HIGH\t1\n#define SCMI_VOLTAGE_SEGMENT_STEP\t2\n\tint *levels_uv;\n};\n\n \nstruct scmi_voltage_proto_ops {\n\tint (*num_domains_get)(const struct scmi_protocol_handle *ph);\n\tconst struct scmi_voltage_info __must_check *(*info_get)\n\t\t(const struct scmi_protocol_handle *ph, u32 domain_id);\n\tint (*config_set)(const struct scmi_protocol_handle *ph, u32 domain_id,\n\t\t\t  u32 config);\n#define\tSCMI_VOLTAGE_ARCH_STATE_OFF\t\t0x0\n#define\tSCMI_VOLTAGE_ARCH_STATE_ON\t\t0x7\n\tint (*config_get)(const struct scmi_protocol_handle *ph, u32 domain_id,\n\t\t\t  u32 *config);\n\tint (*level_set)(const struct scmi_protocol_handle *ph, u32 domain_id,\n\t\t\t enum scmi_voltage_level_mode mode, s32 volt_uV);\n\tint (*level_get)(const struct scmi_protocol_handle *ph, u32 domain_id,\n\t\t\t s32 *volt_uV);\n};\n\n \nstruct scmi_powercap_info {\n\tunsigned int id;\n\tbool notify_powercap_cap_change;\n\tbool notify_powercap_measurement_change;\n\tbool async_powercap_cap_set;\n\tbool powercap_cap_config;\n\tbool powercap_monitoring;\n\tbool powercap_pai_config;\n\tbool powercap_scale_mw;\n\tbool powercap_scale_uw;\n\tbool fastchannels;\n\tchar name[SCMI_MAX_STR_SIZE];\n\tunsigned int min_pai;\n\tunsigned int max_pai;\n\tunsigned int pai_step;\n\tunsigned int min_power_cap;\n\tunsigned int max_power_cap;\n\tunsigned int power_cap_step;\n\tunsigned int sustainable_power;\n\tunsigned int accuracy;\n#define SCMI_POWERCAP_ROOT_ZONE_ID     0xFFFFFFFFUL\n\tunsigned int parent_id;\n\tstruct scmi_fc_info *fc_info;\n};\n\n \nstruct scmi_powercap_proto_ops {\n\tint (*num_domains_get)(const struct scmi_protocol_handle *ph);\n\tconst struct scmi_powercap_info __must_check *(*info_get)\n\t\t(const struct scmi_protocol_handle *ph, u32 domain_id);\n\tint (*cap_get)(const struct scmi_protocol_handle *ph, u32 domain_id,\n\t\t       u32 *power_cap);\n\tint (*cap_set)(const struct scmi_protocol_handle *ph, u32 domain_id,\n\t\t       u32 power_cap, bool ignore_dresp);\n\tint (*cap_enable_set)(const struct scmi_protocol_handle *ph,\n\t\t\t      u32 domain_id, bool enable);\n\tint (*cap_enable_get)(const struct scmi_protocol_handle *ph,\n\t\t\t      u32 domain_id, bool *enable);\n\tint (*pai_get)(const struct scmi_protocol_handle *ph, u32 domain_id,\n\t\t       u32 *pai);\n\tint (*pai_set)(const struct scmi_protocol_handle *ph, u32 domain_id,\n\t\t       u32 pai);\n\tint (*measurements_get)(const struct scmi_protocol_handle *ph,\n\t\t\t\tu32 domain_id, u32 *average_power, u32 *pai);\n\tint (*measurements_threshold_set)(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t  u32 domain_id, u32 power_thresh_low,\n\t\t\t\t\t  u32 power_thresh_high);\n\tint (*measurements_threshold_get)(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t  u32 domain_id, u32 *power_thresh_low,\n\t\t\t\t\t  u32 *power_thresh_high);\n};\n\n \nstruct scmi_notify_ops {\n\tint (*devm_event_notifier_register)(struct scmi_device *sdev,\n\t\t\t\t\t    u8 proto_id, u8 evt_id,\n\t\t\t\t\t    const u32 *src_id,\n\t\t\t\t\t    struct notifier_block *nb);\n\tint (*devm_event_notifier_unregister)(struct scmi_device *sdev,\n\t\t\t\t\t      u8 proto_id, u8 evt_id,\n\t\t\t\t\t      const u32 *src_id,\n\t\t\t\t\t      struct notifier_block *nb);\n\tint (*event_notifier_register)(const struct scmi_handle *handle,\n\t\t\t\t       u8 proto_id, u8 evt_id,\n\t\t\t\t       const u32 *src_id,\n\t\t\t\t       struct notifier_block *nb);\n\tint (*event_notifier_unregister)(const struct scmi_handle *handle,\n\t\t\t\t\t u8 proto_id, u8 evt_id,\n\t\t\t\t\t const u32 *src_id,\n\t\t\t\t\t struct notifier_block *nb);\n};\n\n \nstruct scmi_handle {\n\tstruct device *dev;\n\tstruct scmi_revision_info *version;\n\n\tint __must_check (*devm_protocol_acquire)(struct scmi_device *sdev,\n\t\t\t\t\t\t  u8 proto);\n\tconst void __must_check *\n\t\t(*devm_protocol_get)(struct scmi_device *sdev, u8 proto,\n\t\t\t\t     struct scmi_protocol_handle **ph);\n\tvoid (*devm_protocol_put)(struct scmi_device *sdev, u8 proto);\n\tbool (*is_transport_atomic)(const struct scmi_handle *handle,\n\t\t\t\t    unsigned int *atomic_threshold);\n\n\tconst struct scmi_notify_ops *notify_ops;\n};\n\nenum scmi_std_protocol {\n\tSCMI_PROTOCOL_BASE = 0x10,\n\tSCMI_PROTOCOL_POWER = 0x11,\n\tSCMI_PROTOCOL_SYSTEM = 0x12,\n\tSCMI_PROTOCOL_PERF = 0x13,\n\tSCMI_PROTOCOL_CLOCK = 0x14,\n\tSCMI_PROTOCOL_SENSOR = 0x15,\n\tSCMI_PROTOCOL_RESET = 0x16,\n\tSCMI_PROTOCOL_VOLTAGE = 0x17,\n\tSCMI_PROTOCOL_POWERCAP = 0x18,\n};\n\nenum scmi_system_events {\n\tSCMI_SYSTEM_SHUTDOWN,\n\tSCMI_SYSTEM_COLDRESET,\n\tSCMI_SYSTEM_WARMRESET,\n\tSCMI_SYSTEM_POWERUP,\n\tSCMI_SYSTEM_SUSPEND,\n\tSCMI_SYSTEM_MAX\n};\n\nstruct scmi_device {\n\tu32 id;\n\tu8 protocol_id;\n\tconst char *name;\n\tstruct device dev;\n\tstruct scmi_handle *handle;\n};\n\n#define to_scmi_dev(d) container_of(d, struct scmi_device, dev)\n\nstruct scmi_device_id {\n\tu8 protocol_id;\n\tconst char *name;\n};\n\nstruct scmi_driver {\n\tconst char *name;\n\tint (*probe)(struct scmi_device *sdev);\n\tvoid (*remove)(struct scmi_device *sdev);\n\tconst struct scmi_device_id *id_table;\n\n\tstruct device_driver driver;\n};\n\n#define to_scmi_driver(d) container_of(d, struct scmi_driver, driver)\n\n#if IS_REACHABLE(CONFIG_ARM_SCMI_PROTOCOL)\nint scmi_driver_register(struct scmi_driver *driver,\n\t\t\t struct module *owner, const char *mod_name);\nvoid scmi_driver_unregister(struct scmi_driver *driver);\n#else\nstatic inline int\nscmi_driver_register(struct scmi_driver *driver, struct module *owner,\n\t\t     const char *mod_name)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void scmi_driver_unregister(struct scmi_driver *driver) {}\n#endif  \n\n#define scmi_register(driver) \\\n\tscmi_driver_register(driver, THIS_MODULE, KBUILD_MODNAME)\n#define scmi_unregister(driver) \\\n\tscmi_driver_unregister(driver)\n\n \n#define module_scmi_driver(__scmi_driver)\t\\\n\tmodule_driver(__scmi_driver, scmi_register, scmi_unregister)\n\n \n#define module_scmi_protocol(__scmi_protocol)\t\\\n\tmodule_driver(__scmi_protocol,\t\t\\\n\t\t      scmi_protocol_register, scmi_protocol_unregister)\n\nstruct scmi_protocol;\nint scmi_protocol_register(const struct scmi_protocol *proto);\nvoid scmi_protocol_unregister(const struct scmi_protocol *proto);\n\n \nenum scmi_notification_events {\n\tSCMI_EVENT_POWER_STATE_CHANGED = 0x0,\n\tSCMI_EVENT_CLOCK_RATE_CHANGED = 0x0,\n\tSCMI_EVENT_CLOCK_RATE_CHANGE_REQUESTED = 0x1,\n\tSCMI_EVENT_PERFORMANCE_LIMITS_CHANGED = 0x0,\n\tSCMI_EVENT_PERFORMANCE_LEVEL_CHANGED = 0x1,\n\tSCMI_EVENT_SENSOR_TRIP_POINT_EVENT = 0x0,\n\tSCMI_EVENT_SENSOR_UPDATE = 0x1,\n\tSCMI_EVENT_RESET_ISSUED = 0x0,\n\tSCMI_EVENT_BASE_ERROR_EVENT = 0x0,\n\tSCMI_EVENT_SYSTEM_POWER_STATE_NOTIFIER = 0x0,\n\tSCMI_EVENT_POWERCAP_CAP_CHANGED = 0x0,\n\tSCMI_EVENT_POWERCAP_MEASUREMENTS_CHANGED = 0x1,\n};\n\nstruct scmi_power_state_changed_report {\n\tktime_t\t\ttimestamp;\n\tunsigned int\tagent_id;\n\tunsigned int\tdomain_id;\n\tunsigned int\tpower_state;\n};\n\nstruct scmi_clock_rate_notif_report {\n\tktime_t\t\t\ttimestamp;\n\tunsigned int\t\tagent_id;\n\tunsigned int\t\tclock_id;\n\tunsigned long long\trate;\n};\n\nstruct scmi_system_power_state_notifier_report {\n\tktime_t\t\ttimestamp;\n\tunsigned int\tagent_id;\n#define SCMI_SYSPOWER_IS_REQUEST_GRACEFUL(flags)\t((flags) & BIT(0))\n\tunsigned int\tflags;\n\tunsigned int\tsystem_state;\n\tunsigned int\ttimeout;\n};\n\nstruct scmi_perf_limits_report {\n\tktime_t\t\ttimestamp;\n\tunsigned int\tagent_id;\n\tunsigned int\tdomain_id;\n\tunsigned int\trange_max;\n\tunsigned int\trange_min;\n};\n\nstruct scmi_perf_level_report {\n\tktime_t\t\ttimestamp;\n\tunsigned int\tagent_id;\n\tunsigned int\tdomain_id;\n\tunsigned int\tperformance_level;\n};\n\nstruct scmi_sensor_trip_point_report {\n\tktime_t\t\ttimestamp;\n\tunsigned int\tagent_id;\n\tunsigned int\tsensor_id;\n\tunsigned int\ttrip_point_desc;\n};\n\nstruct scmi_sensor_update_report {\n\tktime_t\t\t\t\ttimestamp;\n\tunsigned int\t\t\tagent_id;\n\tunsigned int\t\t\tsensor_id;\n\tunsigned int\t\t\treadings_count;\n\tstruct scmi_sensor_reading\treadings[];\n};\n\nstruct scmi_reset_issued_report {\n\tktime_t\t\ttimestamp;\n\tunsigned int\tagent_id;\n\tunsigned int\tdomain_id;\n\tunsigned int\treset_state;\n};\n\nstruct scmi_base_error_report {\n\tktime_t\t\t\ttimestamp;\n\tunsigned int\t\tagent_id;\n\tbool\t\t\tfatal;\n\tunsigned int\t\tcmd_count;\n\tunsigned long long\treports[];\n};\n\nstruct scmi_powercap_cap_changed_report {\n\tktime_t\t\ttimestamp;\n\tunsigned int\tagent_id;\n\tunsigned int\tdomain_id;\n\tunsigned int\tpower_cap;\n\tunsigned int\tpai;\n};\n\nstruct scmi_powercap_meas_changed_report {\n\tktime_t\t\ttimestamp;\n\tunsigned int\tagent_id;\n\tunsigned int\tdomain_id;\n\tunsigned int\tpower;\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}