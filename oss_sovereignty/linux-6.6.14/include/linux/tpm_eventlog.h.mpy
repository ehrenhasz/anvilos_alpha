{
  "module_name": "tpm_eventlog.h",
  "hash_id": "fb3c569821f78c448dd253ffe2a15bb3b21779484e7221cdba0c03387aa49c36",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/tpm_eventlog.h",
  "human_readable_source": " \n\n#ifndef __LINUX_TPM_EVENTLOG_H__\n#define __LINUX_TPM_EVENTLOG_H__\n\n#include <linux/tpm.h>\n\n#define TCG_EVENT_NAME_LEN_MAX\t255\n#define MAX_TEXT_EVENT\t\t1000\t \n#define ACPI_TCPA_SIG\t\t\"TCPA\"\t \n\n#define EFI_TCG2_EVENT_LOG_FORMAT_TCG_1_2 0x1\n#define EFI_TCG2_EVENT_LOG_FORMAT_TCG_2   0x2\n\n#ifdef CONFIG_PPC64\n#define do_endian_conversion(x) be32_to_cpu(x)\n#else\n#define do_endian_conversion(x) x\n#endif\n\nenum bios_platform_class {\n\tBIOS_CLIENT = 0x00,\n\tBIOS_SERVER = 0x01,\n};\n\nstruct tcpa_event {\n\tu32 pcr_index;\n\tu32 event_type;\n\tu8 pcr_value[20];\t \n\tu32 event_size;\n\tu8 event_data[];\n};\n\nenum tcpa_event_types {\n\tPREBOOT = 0,\n\tPOST_CODE,\n\tUNUSED,\n\tNO_ACTION,\n\tSEPARATOR,\n\tACTION,\n\tEVENT_TAG,\n\tSCRTM_CONTENTS,\n\tSCRTM_VERSION,\n\tCPU_MICROCODE,\n\tPLATFORM_CONFIG_FLAGS,\n\tTABLE_OF_DEVICES,\n\tCOMPACT_HASH,\n\tIPL,\n\tIPL_PARTITION_DATA,\n\tNONHOST_CODE,\n\tNONHOST_CONFIG,\n\tNONHOST_INFO,\n};\n\nstruct tcpa_pc_event {\n\tu32 event_id;\n\tu32 event_size;\n\tu8 event_data[];\n};\n\nenum tcpa_pc_event_ids {\n\tSMBIOS = 1,\n\tBIS_CERT,\n\tPOST_BIOS_ROM,\n\tESCD,\n\tCMOS,\n\tNVRAM,\n\tOPTION_ROM_EXEC,\n\tOPTION_ROM_CONFIG,\n\tOPTION_ROM_MICROCODE = 10,\n\tS_CRTM_VERSION,\n\tS_CRTM_CONTENTS,\n\tPOST_CONTENTS,\n\tHOST_TABLE_OF_DEVICES,\n};\n\n \n\nstatic __always_inline int __calc_tpm2_event_size(struct tcg_pcr_event2_head *event,\n\t\t\t\t\t struct tcg_pcr_event *event_header,\n\t\t\t\t\t bool do_mapping)\n{\n\tstruct tcg_efi_specid_event_head *efispecid;\n\tstruct tcg_event_field *event_field;\n\tvoid *mapping = NULL;\n\tint mapping_size;\n\tvoid *marker;\n\tvoid *marker_start;\n\tu32 halg_size;\n\tsize_t size;\n\tu16 halg;\n\tint i;\n\tint j;\n\tu32 count, event_type;\n\tconst u8 zero_digest[sizeof(event_header->digest)] = {0};\n\n\tmarker = event;\n\tmarker_start = marker;\n\tmarker = marker + sizeof(event->pcr_idx) + sizeof(event->event_type)\n\t\t+ sizeof(event->count);\n\n\t \n\tif (do_mapping) {\n\t\tmapping_size = marker - marker_start;\n\t\tmapping = TPM_MEMREMAP((unsigned long)marker_start,\n\t\t\t\t       mapping_size);\n\t\tif (!mapping) {\n\t\t\tsize = 0;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tmapping = marker_start;\n\t}\n\n\tevent = (struct tcg_pcr_event2_head *)mapping;\n\t \n\tcount = event->count;\n\tevent_type = event->event_type;\n\n\t \n\tif (event_header->pcr_idx != 0 ||\n\t    event_header->event_type != NO_ACTION ||\n\t    memcmp(event_header->digest, zero_digest, sizeof(zero_digest))) {\n\t\tsize = 0;\n\t\tgoto out;\n\t}\n\n\tefispecid = (struct tcg_efi_specid_event_head *)event_header->event;\n\n\t \n\tif (memcmp(efispecid->signature, TCG_SPECID_SIG,\n\t\t   sizeof(TCG_SPECID_SIG)) ||\n\t    !efispecid->num_algs || count != efispecid->num_algs) {\n\t\tsize = 0;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\thalg_size = sizeof(event->digests[i].alg_id);\n\n\t\t \n\t\tif (do_mapping) {\n\t\t\tTPM_MEMUNMAP(mapping, mapping_size);\n\t\t\tmapping_size = halg_size;\n\t\t\tmapping = TPM_MEMREMAP((unsigned long)marker,\n\t\t\t\t\t     mapping_size);\n\t\t\tif (!mapping) {\n\t\t\t\tsize = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tmapping = marker;\n\t\t}\n\n\t\tmemcpy(&halg, mapping, halg_size);\n\t\tmarker = marker + halg_size;\n\n\t\tfor (j = 0; j < efispecid->num_algs; j++) {\n\t\t\tif (halg == efispecid->digest_sizes[j].alg_id) {\n\t\t\t\tmarker +=\n\t\t\t\t\tefispecid->digest_sizes[j].digest_size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (j == efispecid->num_algs) {\n\t\t\tsize = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (do_mapping) {\n\t\tTPM_MEMUNMAP(mapping, mapping_size);\n\t\tmapping_size += sizeof(event_field->event_size);\n\t\tmapping = TPM_MEMREMAP((unsigned long)marker,\n\t\t\t\t       mapping_size);\n\t\tif (!mapping) {\n\t\t\tsize = 0;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tmapping = marker;\n\t}\n\n\tevent_field = (struct tcg_event_field *)mapping;\n\n\tmarker = marker + sizeof(event_field->event_size)\n\t\t+ event_field->event_size;\n\tsize = marker - marker_start;\n\n\tif (event_type == 0 && event_field->event_size == 0)\n\t\tsize = 0;\n\nout:\n\tif (do_mapping)\n\t\tTPM_MEMUNMAP(mapping, mapping_size);\n\treturn size;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}