{
  "module_name": "overflow.h",
  "hash_id": "8afacdca3d8079d775d4db91658b042a219d08148552758c01cb305850db278f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/overflow.h",
  "human_readable_source": " \n#ifndef __LINUX_OVERFLOW_H\n#define __LINUX_OVERFLOW_H\n\n#include <linux/compiler.h>\n#include <linux/limits.h>\n#include <linux/const.h>\n\n \n#define __type_half_max(type) ((type)1 << (8*sizeof(type) - 1 - is_signed_type(type)))\n#define type_max(T) ((T)((__type_half_max(T) - 1) + __type_half_max(T)))\n#define type_min(T) ((T)((T)-type_max(T)-(T)1))\n\n \n#define is_non_negative(a) ((a) > 0 || (a) == 0)\n#define is_negative(a) (!(is_non_negative(a)))\n\n \nstatic inline bool __must_check __must_check_overflow(bool overflow)\n{\n\treturn unlikely(overflow);\n}\n\n \n#define check_add_overflow(a, b, d)\t\\\n\t__must_check_overflow(__builtin_add_overflow(a, b, d))\n\n \n#define check_sub_overflow(a, b, d)\t\\\n\t__must_check_overflow(__builtin_sub_overflow(a, b, d))\n\n \n#define check_mul_overflow(a, b, d)\t\\\n\t__must_check_overflow(__builtin_mul_overflow(a, b, d))\n\n \n#define check_shl_overflow(a, s, d) __must_check_overflow(({\t\t\\\n\ttypeof(a) _a = a;\t\t\t\t\t\t\\\n\ttypeof(s) _s = s;\t\t\t\t\t\t\\\n\ttypeof(d) _d = d;\t\t\t\t\t\t\\\n\tu64 _a_full = _a;\t\t\t\t\t\t\\\n\tunsigned int _to_shift =\t\t\t\t\t\\\n\t\tis_non_negative(_s) && _s < 8 * sizeof(*d) ? _s : 0;\t\\\n\t*_d = (_a_full << _to_shift);\t\t\t\t\t\\\n\t(_to_shift != _s || is_negative(*_d) || is_negative(_a) ||\t\\\n\t(*_d >> _to_shift) != _a);\t\t\t\t\t\\\n}))\n\n#define __overflows_type_constexpr(x, T) (\t\t\t\\\n\tis_unsigned_type(typeof(x)) ?\t\t\t\t\\\n\t\t(x) > type_max(typeof(T)) :\t\t\t\\\n\tis_unsigned_type(typeof(T)) ?\t\t\t\t\\\n\t\t(x) < 0 || (x) > type_max(typeof(T)) :\t\t\\\n\t(x) < type_min(typeof(T)) || (x) > type_max(typeof(T)))\n\n#define __overflows_type(x, T)\t\t({\t\\\n\ttypeof(T) v = 0;\t\t\t\\\n\tcheck_add_overflow((x), v, &v);\t\t\\\n})\n\n \n#define overflows_type(n, T)\t\t\t\t\t\\\n\t__builtin_choose_expr(__is_constexpr(n),\t\t\\\n\t\t\t      __overflows_type_constexpr(n, T),\t\\\n\t\t\t      __overflows_type(n, T))\n\n \n#define castable_to_type(n, T)\t\t\t\t\t\t\\\n\t__builtin_choose_expr(__is_constexpr(n),\t\t\t\\\n\t\t\t      !__overflows_type_constexpr(n, T),\t\\\n\t\t\t      __same_type(n, T))\n\n \nstatic inline size_t __must_check size_mul(size_t factor1, size_t factor2)\n{\n\tsize_t bytes;\n\n\tif (check_mul_overflow(factor1, factor2, &bytes))\n\t\treturn SIZE_MAX;\n\n\treturn bytes;\n}\n\n \nstatic inline size_t __must_check size_add(size_t addend1, size_t addend2)\n{\n\tsize_t bytes;\n\n\tif (check_add_overflow(addend1, addend2, &bytes))\n\t\treturn SIZE_MAX;\n\n\treturn bytes;\n}\n\n \nstatic inline size_t __must_check size_sub(size_t minuend, size_t subtrahend)\n{\n\tsize_t bytes;\n\n\tif (minuend == SIZE_MAX || subtrahend == SIZE_MAX ||\n\t    check_sub_overflow(minuend, subtrahend, &bytes))\n\t\treturn SIZE_MAX;\n\n\treturn bytes;\n}\n\n \n#define array_size(a, b)\tsize_mul(a, b)\n\n \n#define array3_size(a, b, c)\tsize_mul(size_mul(a, b), c)\n\n \n#define flex_array_size(p, member, count)\t\t\t\t\\\n\t__builtin_choose_expr(__is_constexpr(count),\t\t\t\\\n\t\t(count) * sizeof(*(p)->member) + __must_be_array((p)->member),\t\\\n\t\tsize_mul(count, sizeof(*(p)->member) + __must_be_array((p)->member)))\n\n \n#define struct_size(p, member, count)\t\t\t\t\t\\\n\t__builtin_choose_expr(__is_constexpr(count),\t\t\t\\\n\t\tsizeof(*(p)) + flex_array_size(p, member, count),\t\\\n\t\tsize_add(sizeof(*(p)), flex_array_size(p, member, count)))\n\n \n#define struct_size_t(type, member, count)\t\t\t\t\t\\\n\tstruct_size((type *)NULL, member, count)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}