{
  "module_name": "generic.h",
  "hash_id": "69b638bd2677a34cbbef07cbebb92dce97373200ec9b844f59c9856672223530",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/byteorder/generic.h",
  "human_readable_source": " \n#ifndef _LINUX_BYTEORDER_GENERIC_H\n#define _LINUX_BYTEORDER_GENERIC_H\n\n \n\n \n\n#define cpu_to_le64 __cpu_to_le64\n#define le64_to_cpu __le64_to_cpu\n#define cpu_to_le32 __cpu_to_le32\n#define le32_to_cpu __le32_to_cpu\n#define cpu_to_le16 __cpu_to_le16\n#define le16_to_cpu __le16_to_cpu\n#define cpu_to_be64 __cpu_to_be64\n#define be64_to_cpu __be64_to_cpu\n#define cpu_to_be32 __cpu_to_be32\n#define be32_to_cpu __be32_to_cpu\n#define cpu_to_be16 __cpu_to_be16\n#define be16_to_cpu __be16_to_cpu\n#define cpu_to_le64p __cpu_to_le64p\n#define le64_to_cpup __le64_to_cpup\n#define cpu_to_le32p __cpu_to_le32p\n#define le32_to_cpup __le32_to_cpup\n#define cpu_to_le16p __cpu_to_le16p\n#define le16_to_cpup __le16_to_cpup\n#define cpu_to_be64p __cpu_to_be64p\n#define be64_to_cpup __be64_to_cpup\n#define cpu_to_be32p __cpu_to_be32p\n#define be32_to_cpup __be32_to_cpup\n#define cpu_to_be16p __cpu_to_be16p\n#define be16_to_cpup __be16_to_cpup\n#define cpu_to_le64s __cpu_to_le64s\n#define le64_to_cpus __le64_to_cpus\n#define cpu_to_le32s __cpu_to_le32s\n#define le32_to_cpus __le32_to_cpus\n#define cpu_to_le16s __cpu_to_le16s\n#define le16_to_cpus __le16_to_cpus\n#define cpu_to_be64s __cpu_to_be64s\n#define be64_to_cpus __be64_to_cpus\n#define cpu_to_be32s __cpu_to_be32s\n#define be32_to_cpus __be32_to_cpus\n#define cpu_to_be16s __cpu_to_be16s\n#define be16_to_cpus __be16_to_cpus\n\n \n\n#undef ntohl\n#undef ntohs\n#undef htonl\n#undef htons\n\n#define ___htonl(x) __cpu_to_be32(x)\n#define ___htons(x) __cpu_to_be16(x)\n#define ___ntohl(x) __be32_to_cpu(x)\n#define ___ntohs(x) __be16_to_cpu(x)\n\n#define htonl(x) ___htonl(x)\n#define ntohl(x) ___ntohl(x)\n#define htons(x) ___htons(x)\n#define ntohs(x) ___ntohs(x)\n\nstatic inline void le16_add_cpu(__le16 *var, u16 val)\n{\n\t*var = cpu_to_le16(le16_to_cpu(*var) + val);\n}\n\nstatic inline void le32_add_cpu(__le32 *var, u32 val)\n{\n\t*var = cpu_to_le32(le32_to_cpu(*var) + val);\n}\n\nstatic inline void le64_add_cpu(__le64 *var, u64 val)\n{\n\t*var = cpu_to_le64(le64_to_cpu(*var) + val);\n}\n\n \nstatic inline void le32_to_cpu_array(u32 *buf, unsigned int words)\n{\n\twhile (words--) {\n\t\t__le32_to_cpus(buf);\n\t\tbuf++;\n\t}\n}\n\nstatic inline void cpu_to_le32_array(u32 *buf, unsigned int words)\n{\n\twhile (words--) {\n\t\t__cpu_to_le32s(buf);\n\t\tbuf++;\n\t}\n}\n\nstatic inline void be16_add_cpu(__be16 *var, u16 val)\n{\n\t*var = cpu_to_be16(be16_to_cpu(*var) + val);\n}\n\nstatic inline void be32_add_cpu(__be32 *var, u32 val)\n{\n\t*var = cpu_to_be32(be32_to_cpu(*var) + val);\n}\n\nstatic inline void be64_add_cpu(__be64 *var, u64 val)\n{\n\t*var = cpu_to_be64(be64_to_cpu(*var) + val);\n}\n\nstatic inline void cpu_to_be32_array(__be32 *dst, const u32 *src, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[i] = cpu_to_be32(src[i]);\n}\n\nstatic inline void be32_to_cpu_array(u32 *dst, const __be32 *src, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[i] = be32_to_cpu(src[i]);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}