{
  "module_name": "netfilter_bridge.h",
  "hash_id": "e11c755d8abd92176315b9c24bdec7ecc77a0451d6798bd5d801edf8e2f8c870",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/netfilter_bridge.h",
  "human_readable_source": " \n#ifndef __LINUX_BRIDGE_NETFILTER_H\n#define __LINUX_BRIDGE_NETFILTER_H\n\n#include <uapi/linux/netfilter_bridge.h>\n#include <linux/skbuff.h>\n\nstruct nf_bridge_frag_data {\n\tchar    mac[ETH_HLEN];\n\tbool    vlan_present;\n\tu16     vlan_tci;\n\t__be16  vlan_proto;\n};\n\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\nint br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb);\n\nstatic inline void br_drop_fake_rtable(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst && (dst->flags & DST_FAKE_RTABLE))\n\t\tskb_dst_drop(skb);\n}\n\nstatic inline struct nf_bridge_info *\nnf_bridge_info_get(const struct sk_buff *skb)\n{\n\treturn skb_ext_find(skb, SKB_EXT_BRIDGE_NF);\n}\n\nstatic inline bool nf_bridge_info_exists(const struct sk_buff *skb)\n{\n\treturn skb_ext_exist(skb, SKB_EXT_BRIDGE_NF);\n}\n\nstatic inline int nf_bridge_get_physinif(const struct sk_buff *skb)\n{\n\tconst struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\n\tif (!nf_bridge)\n\t\treturn 0;\n\n\treturn nf_bridge->physinif;\n}\n\nstatic inline int nf_bridge_get_physoutif(const struct sk_buff *skb)\n{\n\tconst struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\n\tif (!nf_bridge)\n\t\treturn 0;\n\n\treturn nf_bridge->physoutdev ? nf_bridge->physoutdev->ifindex : 0;\n}\n\nstatic inline struct net_device *\nnf_bridge_get_physindev(const struct sk_buff *skb, struct net *net)\n{\n\tconst struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\n\treturn nf_bridge ? dev_get_by_index_rcu(net, nf_bridge->physinif) : NULL;\n}\n\nstatic inline struct net_device *\nnf_bridge_get_physoutdev(const struct sk_buff *skb)\n{\n\tconst struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\n\treturn nf_bridge ? nf_bridge->physoutdev : NULL;\n}\n\nstatic inline bool nf_bridge_in_prerouting(const struct sk_buff *skb)\n{\n\tconst struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\n\n\treturn nf_bridge && nf_bridge->in_prerouting;\n}\n#else\n#define br_drop_fake_rtable(skb)\t        do { } while (0)\nstatic inline bool nf_bridge_in_prerouting(const struct sk_buff *skb)\n{\n\treturn false;\n}\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}