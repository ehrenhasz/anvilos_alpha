{
  "module_name": "device.h",
  "hash_id": "4f0d7da462862633b36eb6e59653a1314ba3bf6232ad1a8f9eeb43b5530dfbac",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mlx5/device.h",
  "human_readable_source": " \n\n#ifndef MLX5_DEVICE_H\n#define MLX5_DEVICE_H\n\n#include <linux/types.h>\n#include <rdma/ib_verbs.h>\n#include <linux/mlx5/mlx5_ifc.h>\n#include <linux/bitfield.h>\n\n#if defined(__LITTLE_ENDIAN)\n#define MLX5_SET_HOST_ENDIANNESS\t0\n#elif defined(__BIG_ENDIAN)\n#define MLX5_SET_HOST_ENDIANNESS\t0x80\n#else\n#error Host endianness not defined\n#endif\n\n \n#define __mlx5_nullp(typ) ((struct mlx5_ifc_##typ##_bits *)0)\n#define __mlx5_bit_sz(typ, fld) sizeof(__mlx5_nullp(typ)->fld)\n#define __mlx5_bit_off(typ, fld) (offsetof(struct mlx5_ifc_##typ##_bits, fld))\n#define __mlx5_16_off(typ, fld) (__mlx5_bit_off(typ, fld) / 16)\n#define __mlx5_dw_off(typ, fld) (__mlx5_bit_off(typ, fld) / 32)\n#define __mlx5_64_off(typ, fld) (__mlx5_bit_off(typ, fld) / 64)\n#define __mlx5_16_bit_off(typ, fld) (16 - __mlx5_bit_sz(typ, fld) - (__mlx5_bit_off(typ, fld) & 0xf))\n#define __mlx5_dw_bit_off(typ, fld) (32 - __mlx5_bit_sz(typ, fld) - (__mlx5_bit_off(typ, fld) & 0x1f))\n#define __mlx5_mask(typ, fld) ((u32)((1ull << __mlx5_bit_sz(typ, fld)) - 1))\n#define __mlx5_dw_mask(typ, fld) (__mlx5_mask(typ, fld) << __mlx5_dw_bit_off(typ, fld))\n#define __mlx5_mask16(typ, fld) ((u16)((1ull << __mlx5_bit_sz(typ, fld)) - 1))\n#define __mlx5_16_mask(typ, fld) (__mlx5_mask16(typ, fld) << __mlx5_16_bit_off(typ, fld))\n#define __mlx5_st_sz_bits(typ) sizeof(struct mlx5_ifc_##typ##_bits)\n\n#define MLX5_FLD_SZ_BYTES(typ, fld) (__mlx5_bit_sz(typ, fld) / 8)\n#define MLX5_ST_SZ_BYTES(typ) (sizeof(struct mlx5_ifc_##typ##_bits) / 8)\n#define MLX5_ST_SZ_DW(typ) (sizeof(struct mlx5_ifc_##typ##_bits) / 32)\n#define MLX5_ST_SZ_QW(typ) (sizeof(struct mlx5_ifc_##typ##_bits) / 64)\n#define MLX5_UN_SZ_BYTES(typ) (sizeof(union mlx5_ifc_##typ##_bits) / 8)\n#define MLX5_UN_SZ_DW(typ) (sizeof(union mlx5_ifc_##typ##_bits) / 32)\n#define MLX5_BYTE_OFF(typ, fld) (__mlx5_bit_off(typ, fld) / 8)\n#define MLX5_ADDR_OF(typ, p, fld) ((void *)((uint8_t *)(p) + MLX5_BYTE_OFF(typ, fld)))\n\n \n#define MLX5_SET(typ, p, fld, v) do { \\\n\tu32 _v = v; \\\n\tBUILD_BUG_ON(__mlx5_st_sz_bits(typ) % 32);             \\\n\t*((__be32 *)(p) + __mlx5_dw_off(typ, fld)) = \\\n\tcpu_to_be32((be32_to_cpu(*((__be32 *)(p) + __mlx5_dw_off(typ, fld))) & \\\n\t\t     (~__mlx5_dw_mask(typ, fld))) | (((_v) & __mlx5_mask(typ, fld)) \\\n\t\t     << __mlx5_dw_bit_off(typ, fld))); \\\n} while (0)\n\n#define MLX5_ARRAY_SET(typ, p, fld, idx, v) do { \\\n\tBUILD_BUG_ON(__mlx5_bit_off(typ, fld) % 32); \\\n\tMLX5_SET(typ, p, fld[idx], v); \\\n} while (0)\n\n#define MLX5_SET_TO_ONES(typ, p, fld) do { \\\n\tBUILD_BUG_ON(__mlx5_st_sz_bits(typ) % 32);             \\\n\t*((__be32 *)(p) + __mlx5_dw_off(typ, fld)) = \\\n\tcpu_to_be32((be32_to_cpu(*((__be32 *)(p) + __mlx5_dw_off(typ, fld))) & \\\n\t\t     (~__mlx5_dw_mask(typ, fld))) | ((__mlx5_mask(typ, fld)) \\\n\t\t     << __mlx5_dw_bit_off(typ, fld))); \\\n} while (0)\n\n#define MLX5_GET(typ, p, fld) ((be32_to_cpu(*((__be32 *)(p) +\\\n__mlx5_dw_off(typ, fld))) >> __mlx5_dw_bit_off(typ, fld)) & \\\n__mlx5_mask(typ, fld))\n\n#define MLX5_GET_PR(typ, p, fld) ({ \\\n\tu32 ___t = MLX5_GET(typ, p, fld); \\\n\tpr_debug(#fld \" = 0x%x\\n\", ___t); \\\n\t___t; \\\n})\n\n#define __MLX5_SET64(typ, p, fld, v) do { \\\n\tBUILD_BUG_ON(__mlx5_bit_sz(typ, fld) != 64); \\\n\t*((__be64 *)(p) + __mlx5_64_off(typ, fld)) = cpu_to_be64(v); \\\n} while (0)\n\n#define MLX5_SET64(typ, p, fld, v) do { \\\n\tBUILD_BUG_ON(__mlx5_bit_off(typ, fld) % 64); \\\n\t__MLX5_SET64(typ, p, fld, v); \\\n} while (0)\n\n#define MLX5_ARRAY_SET64(typ, p, fld, idx, v) do { \\\n\tBUILD_BUG_ON(__mlx5_bit_off(typ, fld) % 64); \\\n\t__MLX5_SET64(typ, p, fld[idx], v); \\\n} while (0)\n\n#define MLX5_GET64(typ, p, fld) be64_to_cpu(*((__be64 *)(p) + __mlx5_64_off(typ, fld)))\n\n#define MLX5_GET64_PR(typ, p, fld) ({ \\\n\tu64 ___t = MLX5_GET64(typ, p, fld); \\\n\tpr_debug(#fld \" = 0x%llx\\n\", ___t); \\\n\t___t; \\\n})\n\n#define MLX5_GET16(typ, p, fld) ((be16_to_cpu(*((__be16 *)(p) +\\\n__mlx5_16_off(typ, fld))) >> __mlx5_16_bit_off(typ, fld)) & \\\n__mlx5_mask16(typ, fld))\n\n#define MLX5_SET16(typ, p, fld, v) do { \\\n\tu16 _v = v; \\\n\tBUILD_BUG_ON(__mlx5_st_sz_bits(typ) % 16);             \\\n\t*((__be16 *)(p) + __mlx5_16_off(typ, fld)) = \\\n\tcpu_to_be16((be16_to_cpu(*((__be16 *)(p) + __mlx5_16_off(typ, fld))) & \\\n\t\t     (~__mlx5_16_mask(typ, fld))) | (((_v) & __mlx5_mask16(typ, fld)) \\\n\t\t     << __mlx5_16_bit_off(typ, fld))); \\\n} while (0)\n\n \n#define MLX5_GET64_BE(typ, p, fld) (*((__be64 *)(p) +\\\n\t__mlx5_64_off(typ, fld)))\n\n#define MLX5_GET_BE(type_t, typ, p, fld) ({\t\t\t\t  \\\n\t\ttype_t tmp;\t\t\t\t\t\t  \\\n\t\tswitch (sizeof(tmp)) {\t\t\t\t\t  \\\n\t\tcase sizeof(u8):\t\t\t\t\t  \\\n\t\t\ttmp = (__force type_t)MLX5_GET(typ, p, fld);\t  \\\n\t\t\tbreak;\t\t\t\t\t\t  \\\n\t\tcase sizeof(u16):\t\t\t\t\t  \\\n\t\t\ttmp = (__force type_t)cpu_to_be16(MLX5_GET(typ, p, fld)); \\\n\t\t\tbreak;\t\t\t\t\t\t  \\\n\t\tcase sizeof(u32):\t\t\t\t\t  \\\n\t\t\ttmp = (__force type_t)cpu_to_be32(MLX5_GET(typ, p, fld)); \\\n\t\t\tbreak;\t\t\t\t\t\t  \\\n\t\tcase sizeof(u64):\t\t\t\t\t  \\\n\t\t\ttmp = (__force type_t)MLX5_GET64_BE(typ, p, fld); \\\n\t\t\tbreak;\t\t\t\t\t\t  \\\n\t\t\t}\t\t\t\t\t\t  \\\n\t\ttmp;\t\t\t\t\t\t\t  \\\n\t\t})\n\nenum mlx5_inline_modes {\n\tMLX5_INLINE_MODE_NONE,\n\tMLX5_INLINE_MODE_L2,\n\tMLX5_INLINE_MODE_IP,\n\tMLX5_INLINE_MODE_TCP_UDP,\n};\n\nenum {\n\tMLX5_MAX_COMMANDS\t\t= 32,\n\tMLX5_CMD_DATA_BLOCK_SIZE\t= 512,\n\tMLX5_PCI_CMD_XPORT\t\t= 7,\n\tMLX5_MKEY_BSF_OCTO_SIZE\t\t= 4,\n\tMLX5_MAX_PSVS\t\t\t= 4,\n};\n\nenum {\n\tMLX5_EXTENDED_UD_AV\t\t= 0x80000000,\n};\n\nenum {\n\tMLX5_CQ_STATE_ARMED\t\t= 9,\n\tMLX5_CQ_STATE_ALWAYS_ARMED\t= 0xb,\n\tMLX5_CQ_STATE_FIRED\t\t= 0xa,\n};\n\nenum {\n\tMLX5_STAT_RATE_OFFSET\t= 5,\n};\n\nenum {\n\tMLX5_INLINE_SEG = 0x80000000,\n};\n\nenum {\n\tMLX5_HW_START_PADDING = MLX5_INLINE_SEG,\n};\n\nenum {\n\tMLX5_MIN_PKEY_TABLE_SIZE = 128,\n\tMLX5_MAX_LOG_PKEY_TABLE  = 5,\n};\n\nenum {\n\tMLX5_MKEY_INBOX_PG_ACCESS = 1 << 31\n};\n\nenum {\n\tMLX5_PFAULT_SUBTYPE_WQE = 0,\n\tMLX5_PFAULT_SUBTYPE_RDMA = 1,\n};\n\nenum wqe_page_fault_type {\n\tMLX5_WQE_PF_TYPE_RMP = 0,\n\tMLX5_WQE_PF_TYPE_REQ_SEND_OR_WRITE = 1,\n\tMLX5_WQE_PF_TYPE_RESP = 2,\n\tMLX5_WQE_PF_TYPE_REQ_READ_OR_ATOMIC = 3,\n};\n\nenum {\n\tMLX5_PERM_LOCAL_READ\t= 1 << 2,\n\tMLX5_PERM_LOCAL_WRITE\t= 1 << 3,\n\tMLX5_PERM_REMOTE_READ\t= 1 << 4,\n\tMLX5_PERM_REMOTE_WRITE\t= 1 << 5,\n\tMLX5_PERM_ATOMIC\t= 1 << 6,\n\tMLX5_PERM_UMR_EN\t= 1 << 7,\n};\n\nenum {\n\tMLX5_PCIE_CTRL_SMALL_FENCE\t= 1 << 0,\n\tMLX5_PCIE_CTRL_RELAXED_ORDERING\t= 1 << 2,\n\tMLX5_PCIE_CTRL_NO_SNOOP\t\t= 1 << 3,\n\tMLX5_PCIE_CTRL_TLP_PROCE_EN\t= 1 << 6,\n\tMLX5_PCIE_CTRL_TPH_MASK\t\t= 3 << 4,\n};\n\nenum {\n\tMLX5_EN_RD\t= (u64)1,\n\tMLX5_EN_WR\t= (u64)2\n};\n\nenum {\n\tMLX5_ADAPTER_PAGE_SHIFT\t\t= 12,\n\tMLX5_ADAPTER_PAGE_SIZE\t\t= 1 << MLX5_ADAPTER_PAGE_SHIFT,\n};\n\nenum {\n\tMLX5_BFREGS_PER_UAR\t\t= 4,\n\tMLX5_MAX_UARS\t\t\t= 1 << 8,\n\tMLX5_NON_FP_BFREGS_PER_UAR\t= 2,\n\tMLX5_FP_BFREGS_PER_UAR\t\t= MLX5_BFREGS_PER_UAR -\n\t\t\t\t\t  MLX5_NON_FP_BFREGS_PER_UAR,\n\tMLX5_MAX_BFREGS\t\t\t= MLX5_MAX_UARS *\n\t\t\t\t\t  MLX5_NON_FP_BFREGS_PER_UAR,\n\tMLX5_UARS_IN_PAGE\t\t= PAGE_SIZE / MLX5_ADAPTER_PAGE_SIZE,\n\tMLX5_NON_FP_BFREGS_IN_PAGE\t= MLX5_NON_FP_BFREGS_PER_UAR * MLX5_UARS_IN_PAGE,\n\tMLX5_MIN_DYN_BFREGS\t\t= 512,\n\tMLX5_MAX_DYN_BFREGS\t\t= 1024,\n};\n\nenum {\n\tMLX5_MKEY_MASK_LEN\t\t= 1ull << 0,\n\tMLX5_MKEY_MASK_PAGE_SIZE\t= 1ull << 1,\n\tMLX5_MKEY_MASK_START_ADDR\t= 1ull << 6,\n\tMLX5_MKEY_MASK_PD\t\t= 1ull << 7,\n\tMLX5_MKEY_MASK_EN_RINVAL\t= 1ull << 8,\n\tMLX5_MKEY_MASK_EN_SIGERR\t= 1ull << 9,\n\tMLX5_MKEY_MASK_BSF_EN\t\t= 1ull << 12,\n\tMLX5_MKEY_MASK_KEY\t\t= 1ull << 13,\n\tMLX5_MKEY_MASK_QPN\t\t= 1ull << 14,\n\tMLX5_MKEY_MASK_LR\t\t= 1ull << 17,\n\tMLX5_MKEY_MASK_LW\t\t= 1ull << 18,\n\tMLX5_MKEY_MASK_RR\t\t= 1ull << 19,\n\tMLX5_MKEY_MASK_RW\t\t= 1ull << 20,\n\tMLX5_MKEY_MASK_A\t\t= 1ull << 21,\n\tMLX5_MKEY_MASK_SMALL_FENCE\t= 1ull << 23,\n\tMLX5_MKEY_MASK_RELAXED_ORDERING_WRITE\t= 1ull << 25,\n\tMLX5_MKEY_MASK_FREE\t\t\t= 1ull << 29,\n\tMLX5_MKEY_MASK_RELAXED_ORDERING_READ\t= 1ull << 47,\n};\n\nenum {\n\tMLX5_UMR_TRANSLATION_OFFSET_EN\t= (1 << 4),\n\n\tMLX5_UMR_CHECK_NOT_FREE\t\t= (1 << 5),\n\tMLX5_UMR_CHECK_FREE\t\t= (2 << 5),\n\n\tMLX5_UMR_INLINE\t\t\t= (1 << 7),\n};\n\n#define MLX5_UMR_FLEX_ALIGNMENT 0x40\n#define MLX5_UMR_MTT_NUM_ENTRIES_ALIGNMENT (MLX5_UMR_FLEX_ALIGNMENT / sizeof(struct mlx5_mtt))\n#define MLX5_UMR_KLM_NUM_ENTRIES_ALIGNMENT (MLX5_UMR_FLEX_ALIGNMENT / sizeof(struct mlx5_klm))\n\n#define MLX5_USER_INDEX_LEN (MLX5_FLD_SZ_BYTES(qpc, user_index) * 8)\n\nenum {\n\tMLX5_EVENT_QUEUE_TYPE_QP = 0,\n\tMLX5_EVENT_QUEUE_TYPE_RQ = 1,\n\tMLX5_EVENT_QUEUE_TYPE_SQ = 2,\n\tMLX5_EVENT_QUEUE_TYPE_DCT = 6,\n};\n\n \nenum mlx5_event {\n\t \n\tMLX5_EVENT_TYPE_NOTIFY_ANY\t   = 0x0,\n\t \n\tMLX5_EVENT_TYPE_COMP\t\t   = 0x0,\n\t \n\tMLX5_EVENT_TYPE_PATH_MIG\t   = 0x01,\n\tMLX5_EVENT_TYPE_COMM_EST\t   = 0x02,\n\tMLX5_EVENT_TYPE_SQ_DRAINED\t   = 0x03,\n\tMLX5_EVENT_TYPE_SRQ_LAST_WQE\t   = 0x13,\n\tMLX5_EVENT_TYPE_SRQ_RQ_LIMIT\t   = 0x14,\n\n\tMLX5_EVENT_TYPE_CQ_ERROR\t   = 0x04,\n\tMLX5_EVENT_TYPE_WQ_CATAS_ERROR\t   = 0x05,\n\tMLX5_EVENT_TYPE_PATH_MIG_FAILED\t   = 0x07,\n\tMLX5_EVENT_TYPE_WQ_INVAL_REQ_ERROR = 0x10,\n\tMLX5_EVENT_TYPE_WQ_ACCESS_ERROR\t   = 0x11,\n\tMLX5_EVENT_TYPE_SRQ_CATAS_ERROR\t   = 0x12,\n\tMLX5_EVENT_TYPE_OBJECT_CHANGE\t   = 0x27,\n\n\tMLX5_EVENT_TYPE_INTERNAL_ERROR\t   = 0x08,\n\tMLX5_EVENT_TYPE_PORT_CHANGE\t   = 0x09,\n\tMLX5_EVENT_TYPE_GPIO_EVENT\t   = 0x15,\n\tMLX5_EVENT_TYPE_PORT_MODULE_EVENT  = 0x16,\n\tMLX5_EVENT_TYPE_TEMP_WARN_EVENT    = 0x17,\n\tMLX5_EVENT_TYPE_XRQ_ERROR\t   = 0x18,\n\tMLX5_EVENT_TYPE_REMOTE_CONFIG\t   = 0x19,\n\tMLX5_EVENT_TYPE_GENERAL_EVENT\t   = 0x22,\n\tMLX5_EVENT_TYPE_MONITOR_COUNTER    = 0x24,\n\tMLX5_EVENT_TYPE_PPS_EVENT          = 0x25,\n\n\tMLX5_EVENT_TYPE_DB_BF_CONGESTION   = 0x1a,\n\tMLX5_EVENT_TYPE_STALL_EVENT\t   = 0x1b,\n\n\tMLX5_EVENT_TYPE_CMD\t\t   = 0x0a,\n\tMLX5_EVENT_TYPE_PAGE_REQUEST\t   = 0xb,\n\n\tMLX5_EVENT_TYPE_PAGE_FAULT\t   = 0xc,\n\tMLX5_EVENT_TYPE_NIC_VPORT_CHANGE   = 0xd,\n\n\tMLX5_EVENT_TYPE_ESW_FUNCTIONS_CHANGED = 0xe,\n\tMLX5_EVENT_TYPE_VHCA_STATE_CHANGE = 0xf,\n\n\tMLX5_EVENT_TYPE_DCT_DRAINED        = 0x1c,\n\tMLX5_EVENT_TYPE_DCT_KEY_VIOLATION  = 0x1d,\n\n\tMLX5_EVENT_TYPE_FPGA_ERROR         = 0x20,\n\tMLX5_EVENT_TYPE_FPGA_QP_ERROR      = 0x21,\n\n\tMLX5_EVENT_TYPE_DEVICE_TRACER      = 0x26,\n\n\tMLX5_EVENT_TYPE_MAX                = 0x100,\n};\n\nenum mlx5_driver_event {\n\tMLX5_DRIVER_EVENT_TYPE_TRAP = 0,\n\tMLX5_DRIVER_EVENT_UPLINK_NETDEV,\n\tMLX5_DRIVER_EVENT_MACSEC_SA_ADDED,\n\tMLX5_DRIVER_EVENT_MACSEC_SA_DELETED,\n\tMLX5_DRIVER_EVENT_AFFILIATION_DONE,\n\tMLX5_DRIVER_EVENT_AFFILIATION_REMOVED,\n};\n\nenum {\n\tMLX5_TRACER_SUBTYPE_OWNERSHIP_CHANGE = 0x0,\n\tMLX5_TRACER_SUBTYPE_TRACES_AVAILABLE = 0x1,\n\tMLX5_TRACER_SUBTYPE_STRINGS_DB_UPDATE = 0x2,\n};\n\nenum {\n\tMLX5_GENERAL_SUBTYPE_DELAY_DROP_TIMEOUT = 0x1,\n\tMLX5_GENERAL_SUBTYPE_PCI_POWER_CHANGE_EVENT = 0x5,\n\tMLX5_GENERAL_SUBTYPE_FW_LIVE_PATCH_EVENT = 0x7,\n\tMLX5_GENERAL_SUBTYPE_PCI_SYNC_FOR_FW_UPDATE_EVENT = 0x8,\n};\n\nenum {\n\tMLX5_PORT_CHANGE_SUBTYPE_DOWN\t\t= 1,\n\tMLX5_PORT_CHANGE_SUBTYPE_ACTIVE\t\t= 4,\n\tMLX5_PORT_CHANGE_SUBTYPE_INITIALIZED\t= 5,\n\tMLX5_PORT_CHANGE_SUBTYPE_LID\t\t= 6,\n\tMLX5_PORT_CHANGE_SUBTYPE_PKEY\t\t= 7,\n\tMLX5_PORT_CHANGE_SUBTYPE_GUID\t\t= 8,\n\tMLX5_PORT_CHANGE_SUBTYPE_CLIENT_REREG\t= 9,\n};\n\nenum {\n\tMLX5_ROCE_VERSION_1\t\t= 0,\n\tMLX5_ROCE_VERSION_2\t\t= 2,\n};\n\nenum {\n\tMLX5_ROCE_VERSION_1_CAP\t\t= 1 << MLX5_ROCE_VERSION_1,\n\tMLX5_ROCE_VERSION_2_CAP\t\t= 1 << MLX5_ROCE_VERSION_2,\n};\n\nenum {\n\tMLX5_ROCE_L3_TYPE_IPV4\t\t= 0,\n\tMLX5_ROCE_L3_TYPE_IPV6\t\t= 1,\n};\n\nenum {\n\tMLX5_ROCE_L3_TYPE_IPV4_CAP\t= 1 << 1,\n\tMLX5_ROCE_L3_TYPE_IPV6_CAP\t= 1 << 2,\n};\n\nenum {\n\tMLX5_OPCODE_NOP\t\t\t= 0x00,\n\tMLX5_OPCODE_SEND_INVAL\t\t= 0x01,\n\tMLX5_OPCODE_RDMA_WRITE\t\t= 0x08,\n\tMLX5_OPCODE_RDMA_WRITE_IMM\t= 0x09,\n\tMLX5_OPCODE_SEND\t\t= 0x0a,\n\tMLX5_OPCODE_SEND_IMM\t\t= 0x0b,\n\tMLX5_OPCODE_LSO\t\t\t= 0x0e,\n\tMLX5_OPCODE_RDMA_READ\t\t= 0x10,\n\tMLX5_OPCODE_ATOMIC_CS\t\t= 0x11,\n\tMLX5_OPCODE_ATOMIC_FA\t\t= 0x12,\n\tMLX5_OPCODE_ATOMIC_MASKED_CS\t= 0x14,\n\tMLX5_OPCODE_ATOMIC_MASKED_FA\t= 0x15,\n\tMLX5_OPCODE_BIND_MW\t\t= 0x18,\n\tMLX5_OPCODE_CONFIG_CMD\t\t= 0x1f,\n\tMLX5_OPCODE_ENHANCED_MPSW\t= 0x29,\n\n\tMLX5_RECV_OPCODE_RDMA_WRITE_IMM\t= 0x00,\n\tMLX5_RECV_OPCODE_SEND\t\t= 0x01,\n\tMLX5_RECV_OPCODE_SEND_IMM\t= 0x02,\n\tMLX5_RECV_OPCODE_SEND_INVAL\t= 0x03,\n\n\tMLX5_CQE_OPCODE_ERROR\t\t= 0x1e,\n\tMLX5_CQE_OPCODE_RESIZE\t\t= 0x16,\n\n\tMLX5_OPCODE_SET_PSV\t\t= 0x20,\n\tMLX5_OPCODE_GET_PSV\t\t= 0x21,\n\tMLX5_OPCODE_CHECK_PSV\t\t= 0x22,\n\tMLX5_OPCODE_DUMP\t\t= 0x23,\n\tMLX5_OPCODE_RGET_PSV\t\t= 0x26,\n\tMLX5_OPCODE_RCHECK_PSV\t\t= 0x27,\n\n\tMLX5_OPCODE_UMR\t\t\t= 0x25,\n\n\tMLX5_OPCODE_FLOW_TBL_ACCESS\t= 0x2c,\n\n\tMLX5_OPCODE_ACCESS_ASO\t\t= 0x2d,\n};\n\nenum {\n\tMLX5_OPC_MOD_TLS_TIS_STATIC_PARAMS = 0x1,\n\tMLX5_OPC_MOD_TLS_TIR_STATIC_PARAMS = 0x2,\n};\n\nenum {\n\tMLX5_OPC_MOD_TLS_TIS_PROGRESS_PARAMS = 0x1,\n\tMLX5_OPC_MOD_TLS_TIR_PROGRESS_PARAMS = 0x2,\n};\n\nstruct mlx5_wqe_tls_static_params_seg {\n\tu8     ctx[MLX5_ST_SZ_BYTES(tls_static_params)];\n};\n\nstruct mlx5_wqe_tls_progress_params_seg {\n\t__be32 tis_tir_num;\n\tu8     ctx[MLX5_ST_SZ_BYTES(tls_progress_params)];\n};\n\nenum {\n\tMLX5_SET_PORT_RESET_QKEY\t= 0,\n\tMLX5_SET_PORT_GUID0\t\t= 16,\n\tMLX5_SET_PORT_NODE_GUID\t\t= 17,\n\tMLX5_SET_PORT_SYS_GUID\t\t= 18,\n\tMLX5_SET_PORT_GID_TABLE\t\t= 19,\n\tMLX5_SET_PORT_PKEY_TABLE\t= 20,\n};\n\nenum {\n\tMLX5_BW_NO_LIMIT   = 0,\n\tMLX5_100_MBPS_UNIT = 3,\n\tMLX5_GBPS_UNIT\t   = 4,\n};\n\nenum {\n\tMLX5_MAX_PAGE_SHIFT\t\t= 31\n};\n\nenum {\n\t \n\tMLX5_MAX_SGE_RD\t= (512 - 16 - 16) / 16\n};\n\nenum mlx5_odp_transport_cap_bits {\n\tMLX5_ODP_SUPPORT_SEND\t = 1 << 31,\n\tMLX5_ODP_SUPPORT_RECV\t = 1 << 30,\n\tMLX5_ODP_SUPPORT_WRITE\t = 1 << 29,\n\tMLX5_ODP_SUPPORT_READ\t = 1 << 28,\n};\n\nstruct mlx5_odp_caps {\n\tchar reserved[0x10];\n\tstruct {\n\t\t__be32\t\t\trc_odp_caps;\n\t\t__be32\t\t\tuc_odp_caps;\n\t\t__be32\t\t\tud_odp_caps;\n\t} per_transport_caps;\n\tchar reserved2[0xe4];\n};\n\nstruct mlx5_cmd_layout {\n\tu8\t\ttype;\n\tu8\t\trsvd0[3];\n\t__be32\t\tinlen;\n\t__be64\t\tin_ptr;\n\t__be32\t\tin[4];\n\t__be32\t\tout[4];\n\t__be64\t\tout_ptr;\n\t__be32\t\toutlen;\n\tu8\t\ttoken;\n\tu8\t\tsig;\n\tu8\t\trsvd1;\n\tu8\t\tstatus_own;\n};\n\nenum mlx5_rfr_severity_bit_offsets {\n\tMLX5_RFR_BIT_OFFSET = 0x7,\n};\n\nstruct health_buffer {\n\t__be32\t\tassert_var[6];\n\t__be32\t\trsvd0[2];\n\t__be32\t\tassert_exit_ptr;\n\t__be32\t\tassert_callra;\n\t__be32\t\trsvd1[1];\n\t__be32\t\ttime;\n\t__be32\t\tfw_ver;\n\t__be32\t\thw_id;\n\tu8\t\trfr_severity;\n\tu8\t\trsvd2[3];\n\tu8\t\tirisc_index;\n\tu8\t\tsynd;\n\t__be16\t\text_synd;\n};\n\nenum mlx5_initializing_bit_offsets {\n\tMLX5_FW_RESET_SUPPORTED_OFFSET = 30,\n};\n\nenum mlx5_cmd_addr_l_sz_offset {\n\tMLX5_NIC_IFC_OFFSET = 8,\n};\n\nstruct mlx5_init_seg {\n\t__be32\t\t\tfw_rev;\n\t__be32\t\t\tcmdif_rev_fw_sub;\n\t__be32\t\t\trsvd0[2];\n\t__be32\t\t\tcmdq_addr_h;\n\t__be32\t\t\tcmdq_addr_l_sz;\n\t__be32\t\t\tcmd_dbell;\n\t__be32\t\t\trsvd1[120];\n\t__be32\t\t\tinitializing;\n\tstruct health_buffer\thealth;\n\t__be32\t\t\trsvd2[878];\n\t__be32\t\t\tcmd_exec_to;\n\t__be32\t\t\tcmd_q_init_to;\n\t__be32\t\t\tinternal_timer_h;\n\t__be32\t\t\tinternal_timer_l;\n\t__be32\t\t\trsvd3[2];\n\t__be32\t\t\thealth_counter;\n\t__be32\t\t\trsvd4[11];\n\t__be32\t\t\treal_time_h;\n\t__be32\t\t\treal_time_l;\n\t__be32\t\t\trsvd5[1006];\n\t__be64\t\t\tieee1588_clk;\n\t__be32\t\t\tieee1588_clk_type;\n\t__be32\t\t\tclr_intx;\n};\n\nstruct mlx5_eqe_comp {\n\t__be32\treserved[6];\n\t__be32\tcqn;\n};\n\nstruct mlx5_eqe_qp_srq {\n\t__be32\treserved1[5];\n\tu8\ttype;\n\tu8\treserved2[3];\n\t__be32\tqp_srq_n;\n};\n\nstruct mlx5_eqe_cq_err {\n\t__be32\tcqn;\n\tu8\treserved1[7];\n\tu8\tsyndrome;\n};\n\nstruct mlx5_eqe_xrq_err {\n\t__be32\treserved1[5];\n\t__be32\ttype_xrqn;\n\t__be32\treserved2;\n};\n\nstruct mlx5_eqe_port_state {\n\tu8\treserved0[8];\n\tu8\tport;\n};\n\nstruct mlx5_eqe_gpio {\n\t__be32\treserved0[2];\n\t__be64\tgpio_event;\n};\n\nstruct mlx5_eqe_congestion {\n\tu8\ttype;\n\tu8\trsvd0;\n\tu8\tcongestion_level;\n};\n\nstruct mlx5_eqe_stall_vl {\n\tu8\trsvd0[3];\n\tu8\tport_vl;\n};\n\nstruct mlx5_eqe_cmd {\n\t__be32\tvector;\n\t__be32\trsvd[6];\n};\n\nstruct mlx5_eqe_page_req {\n\t__be16\t\tec_function;\n\t__be16\t\tfunc_id;\n\t__be32\t\tnum_pages;\n\t__be32\t\trsvd1[5];\n};\n\nstruct mlx5_eqe_page_fault {\n\t__be32 bytes_committed;\n\tunion {\n\t\tstruct {\n\t\t\tu16     reserved1;\n\t\t\t__be16  wqe_index;\n\t\t\tu16\treserved2;\n\t\t\t__be16  packet_length;\n\t\t\t__be32  token;\n\t\t\tu8\treserved4[8];\n\t\t\t__be32  pftype_wq;\n\t\t} __packed wqe;\n\t\tstruct {\n\t\t\t__be32  r_key;\n\t\t\tu16\treserved1;\n\t\t\t__be16  packet_length;\n\t\t\t__be32  rdma_op_len;\n\t\t\t__be64  rdma_va;\n\t\t\t__be32  pftype_token;\n\t\t} __packed rdma;\n\t} __packed;\n} __packed;\n\nstruct mlx5_eqe_vport_change {\n\tu8\t\trsvd0[2];\n\t__be16\t\tvport_num;\n\t__be32\t\trsvd1[6];\n} __packed;\n\nstruct mlx5_eqe_port_module {\n\tu8        reserved_at_0[1];\n\tu8        module;\n\tu8        reserved_at_2[1];\n\tu8        module_status;\n\tu8        reserved_at_4[2];\n\tu8        error_type;\n} __packed;\n\nstruct mlx5_eqe_pps {\n\tu8\t\trsvd0[3];\n\tu8\t\tpin;\n\tu8\t\trsvd1[4];\n\tunion {\n\t\tstruct {\n\t\t\t__be32\t\ttime_sec;\n\t\t\t__be32\t\ttime_nsec;\n\t\t};\n\t\tstruct {\n\t\t\t__be64\t\ttime_stamp;\n\t\t};\n\t};\n\tu8\t\trsvd2[12];\n} __packed;\n\nstruct mlx5_eqe_dct {\n\t__be32  reserved[6];\n\t__be32  dctn;\n};\n\nstruct mlx5_eqe_temp_warning {\n\t__be64 sensor_warning_msb;\n\t__be64 sensor_warning_lsb;\n} __packed;\n\nstruct mlx5_eqe_obj_change {\n\tu8      rsvd0[2];\n\t__be16  obj_type;\n\t__be32  obj_id;\n} __packed;\n\n#define SYNC_RST_STATE_MASK    0xf\n\nenum sync_rst_state_type {\n\tMLX5_SYNC_RST_STATE_RESET_REQUEST\t= 0x0,\n\tMLX5_SYNC_RST_STATE_RESET_NOW\t\t= 0x1,\n\tMLX5_SYNC_RST_STATE_RESET_ABORT\t\t= 0x2,\n\tMLX5_SYNC_RST_STATE_RESET_UNLOAD\t= 0x3,\n};\n\nstruct mlx5_eqe_sync_fw_update {\n\tu8 reserved_at_0[3];\n\tu8 sync_rst_state;\n};\n\nstruct mlx5_eqe_vhca_state {\n\t__be16 ec_function;\n\t__be16 function_id;\n} __packed;\n\nunion ev_data {\n\t__be32\t\t\t\traw[7];\n\tstruct mlx5_eqe_cmd\t\tcmd;\n\tstruct mlx5_eqe_comp\t\tcomp;\n\tstruct mlx5_eqe_qp_srq\t\tqp_srq;\n\tstruct mlx5_eqe_cq_err\t\tcq_err;\n\tstruct mlx5_eqe_port_state\tport;\n\tstruct mlx5_eqe_gpio\t\tgpio;\n\tstruct mlx5_eqe_congestion\tcong;\n\tstruct mlx5_eqe_stall_vl\tstall_vl;\n\tstruct mlx5_eqe_page_req\treq_pages;\n\tstruct mlx5_eqe_page_fault\tpage_fault;\n\tstruct mlx5_eqe_vport_change\tvport_change;\n\tstruct mlx5_eqe_port_module\tport_module;\n\tstruct mlx5_eqe_pps\t\tpps;\n\tstruct mlx5_eqe_dct             dct;\n\tstruct mlx5_eqe_temp_warning\ttemp_warning;\n\tstruct mlx5_eqe_xrq_err\t\txrq_err;\n\tstruct mlx5_eqe_sync_fw_update\tsync_fw_update;\n\tstruct mlx5_eqe_vhca_state\tvhca_state;\n\tstruct mlx5_eqe_obj_change\tobj_change;\n} __packed;\n\nstruct mlx5_eqe {\n\tu8\t\trsvd0;\n\tu8\t\ttype;\n\tu8\t\trsvd1;\n\tu8\t\tsub_type;\n\t__be32\t\trsvd2[7];\n\tunion ev_data\tdata;\n\t__be16\t\trsvd3;\n\tu8\t\tsignature;\n\tu8\t\towner;\n} __packed;\n\nstruct mlx5_cmd_prot_block {\n\tu8\t\tdata[MLX5_CMD_DATA_BLOCK_SIZE];\n\tu8\t\trsvd0[48];\n\t__be64\t\tnext;\n\t__be32\t\tblock_num;\n\tu8\t\trsvd1;\n\tu8\t\ttoken;\n\tu8\t\tctrl_sig;\n\tu8\t\tsig;\n};\n\nenum {\n\tMLX5_CQE_SYND_FLUSHED_IN_ERROR = 5,\n};\n\nstruct mlx5_err_cqe {\n\tu8\trsvd0[32];\n\t__be32\tsrqn;\n\tu8\trsvd1[18];\n\tu8\tvendor_err_synd;\n\tu8\tsyndrome;\n\t__be32\ts_wqe_opcode_qpn;\n\t__be16\twqe_counter;\n\tu8\tsignature;\n\tu8\top_own;\n};\n\nstruct mlx5_cqe64 {\n\tu8\t\ttls_outer_l3_tunneled;\n\tu8\t\trsvd0;\n\t__be16\t\twqe_id;\n\tunion {\n\t\tstruct {\n\t\t\tu8\ttcppsh_abort_dupack;\n\t\t\tu8\tmin_ttl;\n\t\t\t__be16\ttcp_win;\n\t\t\t__be32\tack_seq_num;\n\t\t} lro;\n\t\tstruct {\n\t\t\tu8\treserved0:1;\n\t\t\tu8\tmatch:1;\n\t\t\tu8\tflush:1;\n\t\t\tu8\treserved3:5;\n\t\t\tu8\theader_size;\n\t\t\t__be16\theader_entry_index;\n\t\t\t__be32\tdata_offset;\n\t\t} shampo;\n\t};\n\t__be32\t\trss_hash_result;\n\tu8\t\trss_hash_type;\n\tu8\t\tml_path;\n\tu8\t\trsvd20[2];\n\t__be16\t\tcheck_sum;\n\t__be16\t\tslid;\n\t__be32\t\tflags_rqpn;\n\tu8\t\thds_ip_ext;\n\tu8\t\tl4_l3_hdr_type;\n\t__be16\t\tvlan_info;\n\t__be32\t\tsrqn;  \n\tunion {\n\t\t__be32 immediate;\n\t\t__be32 inval_rkey;\n\t\t__be32 pkey;\n\t\t__be32 ft_metadata;\n\t};\n\tu8\t\trsvd40[4];\n\t__be32\t\tbyte_cnt;\n\t__be32\t\ttimestamp_h;\n\t__be32\t\ttimestamp_l;\n\t__be32\t\tsop_drop_qpn;\n\t__be16\t\twqe_counter;\n\tunion {\n\t\tu8\tsignature;\n\t\tu8\tvalidity_iteration_count;\n\t};\n\tu8\t\top_own;\n};\n\nstruct mlx5_mini_cqe8 {\n\tunion {\n\t\t__be32 rx_hash_result;\n\t\tstruct {\n\t\t\t__be16 checksum;\n\t\t\t__be16 stridx;\n\t\t};\n\t\tstruct {\n\t\t\t__be16 wqe_counter;\n\t\t\tu8  s_wqe_opcode;\n\t\t\tu8  reserved;\n\t\t} s_wqe_info;\n\t};\n\t__be32 byte_cnt;\n};\n\nenum {\n\tMLX5_NO_INLINE_DATA,\n\tMLX5_INLINE_DATA32_SEG,\n\tMLX5_INLINE_DATA64_SEG,\n\tMLX5_COMPRESSED,\n};\n\nenum {\n\tMLX5_CQE_FORMAT_CSUM = 0x1,\n\tMLX5_CQE_FORMAT_CSUM_STRIDX = 0x3,\n};\n\nenum {\n\tMLX5_CQE_COMPRESS_LAYOUT_BASIC = 0,\n\tMLX5_CQE_COMPRESS_LAYOUT_ENHANCED = 1,\n};\n\n#define MLX5_MINI_CQE_ARRAY_SIZE 8\n\nstatic inline u8 mlx5_get_cqe_format(struct mlx5_cqe64 *cqe)\n{\n\treturn (cqe->op_own >> 2) & 0x3;\n}\n\nstatic inline u8 get_cqe_opcode(struct mlx5_cqe64 *cqe)\n{\n\treturn cqe->op_own >> 4;\n}\n\nstatic inline u8 get_cqe_enhanced_num_mini_cqes(struct mlx5_cqe64 *cqe)\n{\n\t \n\treturn get_cqe_opcode(cqe) + 1;\n}\n\nstatic inline u8 get_cqe_lro_tcppsh(struct mlx5_cqe64 *cqe)\n{\n\treturn (cqe->lro.tcppsh_abort_dupack >> 6) & 1;\n}\n\nstatic inline u8 get_cqe_l4_hdr_type(struct mlx5_cqe64 *cqe)\n{\n\treturn (cqe->l4_l3_hdr_type >> 4) & 0x7;\n}\n\nstatic inline bool cqe_is_tunneled(struct mlx5_cqe64 *cqe)\n{\n\treturn cqe->tls_outer_l3_tunneled & 0x1;\n}\n\nstatic inline u8 get_cqe_tls_offload(struct mlx5_cqe64 *cqe)\n{\n\treturn (cqe->tls_outer_l3_tunneled >> 3) & 0x3;\n}\n\nstatic inline bool cqe_has_vlan(struct mlx5_cqe64 *cqe)\n{\n\treturn cqe->l4_l3_hdr_type & 0x1;\n}\n\nstatic inline u64 get_cqe_ts(struct mlx5_cqe64 *cqe)\n{\n\tu32 hi, lo;\n\n\thi = be32_to_cpu(cqe->timestamp_h);\n\tlo = be32_to_cpu(cqe->timestamp_l);\n\n\treturn (u64)lo | ((u64)hi << 32);\n}\n\nstatic inline u16 get_cqe_flow_tag(struct mlx5_cqe64 *cqe)\n{\n\treturn be32_to_cpu(cqe->sop_drop_qpn) & 0xFFF;\n}\n\n#define MLX5_MPWQE_LOG_NUM_STRIDES_EXT_BASE\t3\n#define MLX5_MPWQE_LOG_NUM_STRIDES_BASE\t\t9\n#define MLX5_MPWQE_LOG_NUM_STRIDES_MAX\t\t16\n#define MLX5_MPWQE_LOG_STRIDE_SZ_BASE\t\t6\n#define MLX5_MPWQE_LOG_STRIDE_SZ_MAX\t\t13\n\nstruct mpwrq_cqe_bc {\n\t__be16\tfiller_consumed_strides;\n\t__be16\tbyte_cnt;\n};\n\nstatic inline u16 mpwrq_get_cqe_byte_cnt(struct mlx5_cqe64 *cqe)\n{\n\tstruct mpwrq_cqe_bc *bc = (struct mpwrq_cqe_bc *)&cqe->byte_cnt;\n\n\treturn be16_to_cpu(bc->byte_cnt);\n}\n\nstatic inline u16 mpwrq_get_cqe_bc_consumed_strides(struct mpwrq_cqe_bc *bc)\n{\n\treturn 0x7fff & be16_to_cpu(bc->filler_consumed_strides);\n}\n\nstatic inline u16 mpwrq_get_cqe_consumed_strides(struct mlx5_cqe64 *cqe)\n{\n\tstruct mpwrq_cqe_bc *bc = (struct mpwrq_cqe_bc *)&cqe->byte_cnt;\n\n\treturn mpwrq_get_cqe_bc_consumed_strides(bc);\n}\n\nstatic inline bool mpwrq_is_filler_cqe(struct mlx5_cqe64 *cqe)\n{\n\tstruct mpwrq_cqe_bc *bc = (struct mpwrq_cqe_bc *)&cqe->byte_cnt;\n\n\treturn 0x8000 & be16_to_cpu(bc->filler_consumed_strides);\n}\n\nstatic inline u16 mpwrq_get_cqe_stride_index(struct mlx5_cqe64 *cqe)\n{\n\treturn be16_to_cpu(cqe->wqe_counter);\n}\n\nenum {\n\tCQE_L4_HDR_TYPE_NONE\t\t\t= 0x0,\n\tCQE_L4_HDR_TYPE_TCP_NO_ACK\t\t= 0x1,\n\tCQE_L4_HDR_TYPE_UDP\t\t\t= 0x2,\n\tCQE_L4_HDR_TYPE_TCP_ACK_NO_DATA\t\t= 0x3,\n\tCQE_L4_HDR_TYPE_TCP_ACK_AND_DATA\t= 0x4,\n};\n\nenum {\n\tCQE_RSS_HTYPE_IP\t= GENMASK(3, 2),\n\t \n\tCQE_RSS_IP_NONE\t\t= 0x0,\n\tCQE_RSS_IPV4\t\t= 0x1,\n\tCQE_RSS_IPV6\t\t= 0x2,\n\tCQE_RSS_RESERVED\t= 0x3,\n\n\tCQE_RSS_HTYPE_L4\t= GENMASK(7, 6),\n\t \n\tCQE_RSS_L4_NONE\t\t= 0x0,\n\tCQE_RSS_L4_TCP\t\t= 0x1,\n\tCQE_RSS_L4_UDP\t\t= 0x2,\n\tCQE_RSS_L4_IPSEC\t= 0x3,\n};\n\nenum {\n\tMLX5_CQE_ROCE_L3_HEADER_TYPE_GRH\t= 0x0,\n\tMLX5_CQE_ROCE_L3_HEADER_TYPE_IPV6\t= 0x1,\n\tMLX5_CQE_ROCE_L3_HEADER_TYPE_IPV4\t= 0x2,\n};\n\nenum {\n\tCQE_L2_OK\t= 1 << 0,\n\tCQE_L3_OK\t= 1 << 1,\n\tCQE_L4_OK\t= 1 << 2,\n};\n\nenum {\n\tCQE_TLS_OFFLOAD_NOT_DECRYPTED\t\t= 0x0,\n\tCQE_TLS_OFFLOAD_DECRYPTED\t\t= 0x1,\n\tCQE_TLS_OFFLOAD_RESYNC\t\t\t= 0x2,\n\tCQE_TLS_OFFLOAD_ERROR\t\t\t= 0x3,\n};\n\nstruct mlx5_sig_err_cqe {\n\tu8\t\trsvd0[16];\n\t__be32\t\texpected_trans_sig;\n\t__be32\t\tactual_trans_sig;\n\t__be32\t\texpected_reftag;\n\t__be32\t\tactual_reftag;\n\t__be16\t\tsyndrome;\n\tu8\t\trsvd22[2];\n\t__be32\t\tmkey;\n\t__be64\t\terr_offset;\n\tu8\t\trsvd30[8];\n\t__be32\t\tqpn;\n\tu8\t\trsvd38[2];\n\tu8\t\tsignature;\n\tu8\t\top_own;\n};\n\nstruct mlx5_wqe_srq_next_seg {\n\tu8\t\t\trsvd0[2];\n\t__be16\t\t\tnext_wqe_index;\n\tu8\t\t\tsignature;\n\tu8\t\t\trsvd1[11];\n};\n\nunion mlx5_ext_cqe {\n\tstruct ib_grh\tgrh;\n\tu8\t\tinl[64];\n};\n\nstruct mlx5_cqe128 {\n\tunion mlx5_ext_cqe\tinl_grh;\n\tstruct mlx5_cqe64\tcqe64;\n};\n\nenum {\n\tMLX5_MKEY_STATUS_FREE = 1 << 6,\n};\n\nenum {\n\tMLX5_MKEY_REMOTE_INVAL\t= 1 << 24,\n\tMLX5_MKEY_FLAG_SYNC_UMR = 1 << 29,\n\tMLX5_MKEY_BSF_EN\t= 1 << 30,\n};\n\nstruct mlx5_mkey_seg {\n\t \n\tu8\t\tstatus;\n\tu8\t\tpcie_control;\n\tu8\t\tflags;\n\tu8\t\tversion;\n\t__be32\t\tqpn_mkey7_0;\n\tu8\t\trsvd1[4];\n\t__be32\t\tflags_pd;\n\t__be64\t\tstart_addr;\n\t__be64\t\tlen;\n\t__be32\t\tbsfs_octo_size;\n\tu8\t\trsvd2[16];\n\t__be32\t\txlt_oct_size;\n\tu8\t\trsvd3[3];\n\tu8\t\tlog2_page_size;\n\tu8\t\trsvd4[4];\n};\n\n#define MLX5_ATTR_EXTENDED_PORT_INFO\tcpu_to_be16(0xff90)\n\nenum {\n\tMLX_EXT_PORT_CAP_FLAG_EXTENDED_PORT_INFO\t= 1 <<  0\n};\n\nenum {\n\tVPORT_STATE_DOWN\t\t= 0x0,\n\tVPORT_STATE_UP\t\t\t= 0x1,\n};\n\nenum {\n\tMLX5_VPORT_ADMIN_STATE_DOWN  = 0x0,\n\tMLX5_VPORT_ADMIN_STATE_UP    = 0x1,\n\tMLX5_VPORT_ADMIN_STATE_AUTO  = 0x2,\n};\n\nenum {\n\tMLX5_VPORT_CVLAN_INSERT_WHEN_NO_CVLAN  = 0x1,\n\tMLX5_VPORT_CVLAN_INSERT_ALWAYS         = 0x3,\n};\n\nenum {\n\tMLX5_L3_PROT_TYPE_IPV4\t\t= 0,\n\tMLX5_L3_PROT_TYPE_IPV6\t\t= 1,\n};\n\nenum {\n\tMLX5_L4_PROT_TYPE_TCP\t\t= 0,\n\tMLX5_L4_PROT_TYPE_UDP\t\t= 1,\n};\n\nenum {\n\tMLX5_HASH_FIELD_SEL_SRC_IP\t= 1 << 0,\n\tMLX5_HASH_FIELD_SEL_DST_IP\t= 1 << 1,\n\tMLX5_HASH_FIELD_SEL_L4_SPORT\t= 1 << 2,\n\tMLX5_HASH_FIELD_SEL_L4_DPORT\t= 1 << 3,\n\tMLX5_HASH_FIELD_SEL_IPSEC_SPI\t= 1 << 4,\n};\n\nenum {\n\tMLX5_MATCH_OUTER_HEADERS\t= 1 << 0,\n\tMLX5_MATCH_MISC_PARAMETERS\t= 1 << 1,\n\tMLX5_MATCH_INNER_HEADERS\t= 1 << 2,\n\tMLX5_MATCH_MISC_PARAMETERS_2\t= 1 << 3,\n\tMLX5_MATCH_MISC_PARAMETERS_3\t= 1 << 4,\n\tMLX5_MATCH_MISC_PARAMETERS_4\t= 1 << 5,\n\tMLX5_MATCH_MISC_PARAMETERS_5\t= 1 << 6,\n};\n\nenum {\n\tMLX5_FLOW_TABLE_TYPE_NIC_RCV\t= 0,\n\tMLX5_FLOW_TABLE_TYPE_ESWITCH\t= 4,\n};\n\nenum {\n\tMLX5_FLOW_CONTEXT_DEST_TYPE_VPORT\t= 0,\n\tMLX5_FLOW_CONTEXT_DEST_TYPE_FLOW_TABLE\t= 1,\n\tMLX5_FLOW_CONTEXT_DEST_TYPE_TIR\t\t= 2,\n};\n\nenum mlx5_list_type {\n\tMLX5_NVPRT_LIST_TYPE_UC   = 0x0,\n\tMLX5_NVPRT_LIST_TYPE_MC   = 0x1,\n\tMLX5_NVPRT_LIST_TYPE_VLAN = 0x2,\n};\n\nenum {\n\tMLX5_RQC_RQ_TYPE_MEMORY_RQ_INLINE = 0x0,\n\tMLX5_RQC_RQ_TYPE_MEMORY_RQ_RPM    = 0x1,\n};\n\nenum mlx5_wol_mode {\n\tMLX5_WOL_DISABLE        = 0,\n\tMLX5_WOL_SECURED_MAGIC  = 1 << 1,\n\tMLX5_WOL_MAGIC          = 1 << 2,\n\tMLX5_WOL_ARP            = 1 << 3,\n\tMLX5_WOL_BROADCAST      = 1 << 4,\n\tMLX5_WOL_MULTICAST      = 1 << 5,\n\tMLX5_WOL_UNICAST        = 1 << 6,\n\tMLX5_WOL_PHY_ACTIVITY   = 1 << 7,\n};\n\nenum mlx5_mpls_supported_fields {\n\tMLX5_FIELD_SUPPORT_MPLS_LABEL = 1 << 0,\n\tMLX5_FIELD_SUPPORT_MPLS_EXP   = 1 << 1,\n\tMLX5_FIELD_SUPPORT_MPLS_S_BOS = 1 << 2,\n\tMLX5_FIELD_SUPPORT_MPLS_TTL   = 1 << 3\n};\n\nenum mlx5_flex_parser_protos {\n\tMLX5_FLEX_PROTO_GENEVE\t      = 1 << 3,\n\tMLX5_FLEX_PROTO_CW_MPLS_GRE   = 1 << 4,\n\tMLX5_FLEX_PROTO_CW_MPLS_UDP   = 1 << 5,\n\tMLX5_FLEX_PROTO_ICMP\t      = 1 << 8,\n\tMLX5_FLEX_PROTO_ICMPV6\t      = 1 << 9,\n};\n\n \n\n \nenum mlx5_cap_mode {\n\tHCA_CAP_OPMOD_GET_MAX\t= 0,\n\tHCA_CAP_OPMOD_GET_CUR\t= 1,\n};\n\n \nenum mlx5_cap_type {\n\tMLX5_CAP_GENERAL = 0,\n\tMLX5_CAP_ETHERNET_OFFLOADS,\n\tMLX5_CAP_ODP,\n\tMLX5_CAP_ATOMIC,\n\tMLX5_CAP_ROCE,\n\tMLX5_CAP_IPOIB_OFFLOADS,\n\tMLX5_CAP_IPOIB_ENHANCED_OFFLOADS,\n\tMLX5_CAP_FLOW_TABLE,\n\tMLX5_CAP_ESWITCH_FLOW_TABLE,\n\tMLX5_CAP_ESWITCH,\n\tMLX5_CAP_QOS = 0xc,\n\tMLX5_CAP_DEBUG,\n\tMLX5_CAP_RESERVED_14,\n\tMLX5_CAP_DEV_MEM,\n\tMLX5_CAP_RESERVED_16,\n\tMLX5_CAP_TLS,\n\tMLX5_CAP_VDPA_EMULATION = 0x13,\n\tMLX5_CAP_DEV_EVENT = 0x14,\n\tMLX5_CAP_IPSEC,\n\tMLX5_CAP_CRYPTO = 0x1a,\n\tMLX5_CAP_MACSEC = 0x1f,\n\tMLX5_CAP_GENERAL_2 = 0x20,\n\tMLX5_CAP_PORT_SELECTION = 0x25,\n\tMLX5_CAP_ADV_VIRTUALIZATION = 0x26,\n\t \n\tMLX5_CAP_NUM\n};\n\nenum mlx5_pcam_reg_groups {\n\tMLX5_PCAM_REGS_5000_TO_507F                 = 0x0,\n};\n\nenum mlx5_pcam_feature_groups {\n\tMLX5_PCAM_FEATURE_ENHANCED_FEATURES         = 0x0,\n};\n\nenum mlx5_mcam_reg_groups {\n\tMLX5_MCAM_REGS_FIRST_128                    = 0x0,\n\tMLX5_MCAM_REGS_0x9100_0x917F                = 0x2,\n\tMLX5_MCAM_REGS_NUM                          = 0x3,\n};\n\nenum mlx5_mcam_feature_groups {\n\tMLX5_MCAM_FEATURE_ENHANCED_FEATURES         = 0x0,\n};\n\nenum mlx5_qcam_reg_groups {\n\tMLX5_QCAM_REGS_FIRST_128                    = 0x0,\n};\n\nenum mlx5_qcam_feature_groups {\n\tMLX5_QCAM_FEATURE_ENHANCED_FEATURES         = 0x0,\n};\n\n \n#define MLX5_CAP_GEN(mdev, cap) \\\n\tMLX5_GET(cmd_hca_cap, mdev->caps.hca[MLX5_CAP_GENERAL]->cur, cap)\n\n#define MLX5_CAP_GEN_64(mdev, cap) \\\n\tMLX5_GET64(cmd_hca_cap, mdev->caps.hca[MLX5_CAP_GENERAL]->cur, cap)\n\n#define MLX5_CAP_GEN_MAX(mdev, cap) \\\n\tMLX5_GET(cmd_hca_cap, mdev->caps.hca[MLX5_CAP_GENERAL]->max, cap)\n\n#define MLX5_CAP_GEN_2(mdev, cap) \\\n\tMLX5_GET(cmd_hca_cap_2, mdev->caps.hca[MLX5_CAP_GENERAL_2]->cur, cap)\n\n#define MLX5_CAP_GEN_2_64(mdev, cap) \\\n\tMLX5_GET64(cmd_hca_cap_2, mdev->caps.hca[MLX5_CAP_GENERAL_2]->cur, cap)\n\n#define MLX5_CAP_GEN_2_MAX(mdev, cap) \\\n\tMLX5_GET(cmd_hca_cap_2, mdev->caps.hca[MLX5_CAP_GENERAL_2]->max, cap)\n\n#define MLX5_CAP_ETH(mdev, cap) \\\n\tMLX5_GET(per_protocol_networking_offload_caps,\\\n\t\t mdev->caps.hca[MLX5_CAP_ETHERNET_OFFLOADS]->cur, cap)\n\n#define MLX5_CAP_IPOIB_ENHANCED(mdev, cap) \\\n\tMLX5_GET(per_protocol_networking_offload_caps,\\\n\t\t mdev->caps.hca[MLX5_CAP_IPOIB_ENHANCED_OFFLOADS]->cur, cap)\n\n#define MLX5_CAP_ROCE(mdev, cap) \\\n\tMLX5_GET(roce_cap, mdev->caps.hca[MLX5_CAP_ROCE]->cur, cap)\n\n#define MLX5_CAP_ROCE_MAX(mdev, cap) \\\n\tMLX5_GET(roce_cap, mdev->caps.hca[MLX5_CAP_ROCE]->max, cap)\n\n#define MLX5_CAP_ATOMIC(mdev, cap) \\\n\tMLX5_GET(atomic_caps, mdev->caps.hca[MLX5_CAP_ATOMIC]->cur, cap)\n\n#define MLX5_CAP_ATOMIC_MAX(mdev, cap) \\\n\tMLX5_GET(atomic_caps, mdev->caps.hca[MLX5_CAP_ATOMIC]->max, cap)\n\n#define MLX5_CAP_FLOWTABLE(mdev, cap) \\\n\tMLX5_GET(flow_table_nic_cap, mdev->caps.hca[MLX5_CAP_FLOW_TABLE]->cur, cap)\n\n#define MLX5_CAP64_FLOWTABLE(mdev, cap) \\\n\tMLX5_GET64(flow_table_nic_cap, (mdev)->caps.hca[MLX5_CAP_FLOW_TABLE]->cur, cap)\n\n#define MLX5_CAP_FLOWTABLE_NIC_RX(mdev, cap) \\\n\tMLX5_CAP_FLOWTABLE(mdev, flow_table_properties_nic_receive.cap)\n\n#define MLX5_CAP_FLOWTABLE_NIC_TX(mdev, cap) \\\n\t\tMLX5_CAP_FLOWTABLE(mdev, flow_table_properties_nic_transmit.cap)\n\n#define MLX5_CAP_FLOWTABLE_SNIFFER_RX(mdev, cap) \\\n\tMLX5_CAP_FLOWTABLE(mdev, flow_table_properties_nic_receive_sniffer.cap)\n\n#define MLX5_CAP_FLOWTABLE_SNIFFER_TX(mdev, cap) \\\n\tMLX5_CAP_FLOWTABLE(mdev, flow_table_properties_nic_transmit_sniffer.cap)\n\n#define MLX5_CAP_FLOWTABLE_RDMA_RX(mdev, cap) \\\n\tMLX5_CAP_FLOWTABLE(mdev, flow_table_properties_nic_receive_rdma.cap)\n\n#define MLX5_CAP_FLOWTABLE_RDMA_TX(mdev, cap) \\\n\tMLX5_CAP_FLOWTABLE(mdev, flow_table_properties_nic_transmit_rdma.cap)\n\n#define MLX5_CAP_ESW_FLOWTABLE(mdev, cap) \\\n\tMLX5_GET(flow_table_eswitch_cap, \\\n\t\t mdev->caps.hca[MLX5_CAP_ESWITCH_FLOW_TABLE]->cur, cap)\n\n#define MLX5_CAP_ESW_FLOWTABLE_FDB(mdev, cap) \\\n\tMLX5_CAP_ESW_FLOWTABLE(mdev, flow_table_properties_nic_esw_fdb.cap)\n\n#define MLX5_CAP_ESW_EGRESS_ACL(mdev, cap) \\\n\tMLX5_CAP_ESW_FLOWTABLE(mdev, flow_table_properties_esw_acl_egress.cap)\n\n#define MLX5_CAP_ESW_INGRESS_ACL(mdev, cap) \\\n\tMLX5_CAP_ESW_FLOWTABLE(mdev, flow_table_properties_esw_acl_ingress.cap)\n\n#define MLX5_CAP_ESW_FT_FIELD_SUPPORT_2(mdev, cap) \\\n\tMLX5_CAP_ESW_FLOWTABLE(mdev, ft_field_support_2_esw_fdb.cap)\n\n#define MLX5_CAP_ESW(mdev, cap) \\\n\tMLX5_GET(e_switch_cap, \\\n\t\t mdev->caps.hca[MLX5_CAP_ESWITCH]->cur, cap)\n\n#define MLX5_CAP64_ESW_FLOWTABLE(mdev, cap) \\\n\tMLX5_GET64(flow_table_eswitch_cap, \\\n\t\t(mdev)->caps.hca[MLX5_CAP_ESWITCH_FLOW_TABLE]->cur, cap)\n\n#define MLX5_CAP_PORT_SELECTION(mdev, cap) \\\n\tMLX5_GET(port_selection_cap, \\\n\t\t mdev->caps.hca[MLX5_CAP_PORT_SELECTION]->cur, cap)\n\n#define MLX5_CAP_PORT_SELECTION_MAX(mdev, cap) \\\n\tMLX5_GET(port_selection_cap, \\\n\t\t mdev->caps.hca[MLX5_CAP_PORT_SELECTION]->max, cap)\n\n#define MLX5_CAP_ADV_VIRTUALIZATION(mdev, cap) \\\n\tMLX5_GET(adv_virtualization_cap, \\\n\t\t mdev->caps.hca[MLX5_CAP_ADV_VIRTUALIZATION]->cur, cap)\n\n#define MLX5_CAP_FLOWTABLE_PORT_SELECTION(mdev, cap) \\\n\tMLX5_CAP_PORT_SELECTION(mdev, flow_table_properties_port_selection.cap)\n\n#define MLX5_CAP_ODP(mdev, cap)\\\n\tMLX5_GET(odp_cap, mdev->caps.hca[MLX5_CAP_ODP]->cur, cap)\n\n#define MLX5_CAP_ODP_MAX(mdev, cap)\\\n\tMLX5_GET(odp_cap, mdev->caps.hca[MLX5_CAP_ODP]->max, cap)\n\n#define MLX5_CAP_QOS(mdev, cap)\\\n\tMLX5_GET(qos_cap, mdev->caps.hca[MLX5_CAP_QOS]->cur, cap)\n\n#define MLX5_CAP_DEBUG(mdev, cap)\\\n\tMLX5_GET(debug_cap, mdev->caps.hca[MLX5_CAP_DEBUG]->cur, cap)\n\n#define MLX5_CAP_PCAM_FEATURE(mdev, fld) \\\n\tMLX5_GET(pcam_reg, (mdev)->caps.pcam, feature_cap_mask.enhanced_features.fld)\n\n#define MLX5_CAP_PCAM_REG(mdev, reg) \\\n\tMLX5_GET(pcam_reg, (mdev)->caps.pcam, port_access_reg_cap_mask.regs_5000_to_507f.reg)\n\n#define MLX5_CAP_MCAM_REG(mdev, reg) \\\n\tMLX5_GET(mcam_reg, (mdev)->caps.mcam[MLX5_MCAM_REGS_FIRST_128], \\\n\t\t mng_access_reg_cap_mask.access_regs.reg)\n\n#define MLX5_CAP_MCAM_REG2(mdev, reg) \\\n\tMLX5_GET(mcam_reg, (mdev)->caps.mcam[MLX5_MCAM_REGS_0x9100_0x917F], \\\n\t\t mng_access_reg_cap_mask.access_regs2.reg)\n\n#define MLX5_CAP_MCAM_FEATURE(mdev, fld) \\\n\tMLX5_GET(mcam_reg, (mdev)->caps.mcam, mng_feature_cap_mask.enhanced_features.fld)\n\n#define MLX5_CAP_QCAM_REG(mdev, fld) \\\n\tMLX5_GET(qcam_reg, (mdev)->caps.qcam, qos_access_reg_cap_mask.reg_cap.fld)\n\n#define MLX5_CAP_QCAM_FEATURE(mdev, fld) \\\n\tMLX5_GET(qcam_reg, (mdev)->caps.qcam, qos_feature_cap_mask.feature_cap.fld)\n\n#define MLX5_CAP_FPGA(mdev, cap) \\\n\tMLX5_GET(fpga_cap, (mdev)->caps.fpga, cap)\n\n#define MLX5_CAP64_FPGA(mdev, cap) \\\n\tMLX5_GET64(fpga_cap, (mdev)->caps.fpga, cap)\n\n#define MLX5_CAP_DEV_MEM(mdev, cap)\\\n\tMLX5_GET(device_mem_cap, mdev->caps.hca[MLX5_CAP_DEV_MEM]->cur, cap)\n\n#define MLX5_CAP64_DEV_MEM(mdev, cap)\\\n\tMLX5_GET64(device_mem_cap, mdev->caps.hca[MLX5_CAP_DEV_MEM]->cur, cap)\n\n#define MLX5_CAP_TLS(mdev, cap) \\\n\tMLX5_GET(tls_cap, (mdev)->caps.hca[MLX5_CAP_TLS]->cur, cap)\n\n#define MLX5_CAP_DEV_EVENT(mdev, cap)\\\n\tMLX5_ADDR_OF(device_event_cap, (mdev)->caps.hca[MLX5_CAP_DEV_EVENT]->cur, cap)\n\n#define MLX5_CAP_DEV_VDPA_EMULATION(mdev, cap)\\\n\tMLX5_GET(virtio_emulation_cap, \\\n\t\t(mdev)->caps.hca[MLX5_CAP_VDPA_EMULATION]->cur, cap)\n\n#define MLX5_CAP64_DEV_VDPA_EMULATION(mdev, cap)\\\n\tMLX5_GET64(virtio_emulation_cap, \\\n\t\t(mdev)->caps.hca[MLX5_CAP_VDPA_EMULATION]->cur, cap)\n\n#define MLX5_CAP_IPSEC(mdev, cap)\\\n\tMLX5_GET(ipsec_cap, (mdev)->caps.hca[MLX5_CAP_IPSEC]->cur, cap)\n\n#define MLX5_CAP_CRYPTO(mdev, cap)\\\n\tMLX5_GET(crypto_cap, (mdev)->caps.hca[MLX5_CAP_CRYPTO]->cur, cap)\n\n#define MLX5_CAP_MACSEC(mdev, cap)\\\n\tMLX5_GET(macsec_cap, (mdev)->caps.hca[MLX5_CAP_MACSEC]->cur, cap)\n\nenum {\n\tMLX5_CMD_STAT_OK\t\t\t= 0x0,\n\tMLX5_CMD_STAT_INT_ERR\t\t\t= 0x1,\n\tMLX5_CMD_STAT_BAD_OP_ERR\t\t= 0x2,\n\tMLX5_CMD_STAT_BAD_PARAM_ERR\t\t= 0x3,\n\tMLX5_CMD_STAT_BAD_SYS_STATE_ERR\t\t= 0x4,\n\tMLX5_CMD_STAT_BAD_RES_ERR\t\t= 0x5,\n\tMLX5_CMD_STAT_RES_BUSY\t\t\t= 0x6,\n\tMLX5_CMD_STAT_LIM_ERR\t\t\t= 0x8,\n\tMLX5_CMD_STAT_BAD_RES_STATE_ERR\t\t= 0x9,\n\tMLX5_CMD_STAT_IX_ERR\t\t\t= 0xa,\n\tMLX5_CMD_STAT_NO_RES_ERR\t\t= 0xf,\n\tMLX5_CMD_STAT_BAD_INP_LEN_ERR\t\t= 0x50,\n\tMLX5_CMD_STAT_BAD_OUTP_LEN_ERR\t\t= 0x51,\n\tMLX5_CMD_STAT_BAD_QP_STATE_ERR\t\t= 0x10,\n\tMLX5_CMD_STAT_BAD_PKT_ERR\t\t= 0x30,\n\tMLX5_CMD_STAT_BAD_SIZE_OUTS_CQES_ERR\t= 0x40,\n};\n\nenum {\n\tMLX5_IEEE_802_3_COUNTERS_GROUP\t      = 0x0,\n\tMLX5_RFC_2863_COUNTERS_GROUP\t      = 0x1,\n\tMLX5_RFC_2819_COUNTERS_GROUP\t      = 0x2,\n\tMLX5_RFC_3635_COUNTERS_GROUP\t      = 0x3,\n\tMLX5_ETHERNET_EXTENDED_COUNTERS_GROUP = 0x5,\n\tMLX5_PER_PRIORITY_COUNTERS_GROUP      = 0x10,\n\tMLX5_PER_TRAFFIC_CLASS_COUNTERS_GROUP = 0x11,\n\tMLX5_PHYSICAL_LAYER_COUNTERS_GROUP    = 0x12,\n\tMLX5_PER_TRAFFIC_CLASS_CONGESTION_GROUP = 0x13,\n\tMLX5_PHYSICAL_LAYER_STATISTICAL_GROUP = 0x16,\n\tMLX5_INFINIBAND_PORT_COUNTERS_GROUP   = 0x20,\n};\n\nenum {\n\tMLX5_PCIE_PERFORMANCE_COUNTERS_GROUP       = 0x0,\n};\n\nstatic inline u16 mlx5_to_sw_pkey_sz(int pkey_sz)\n{\n\tif (pkey_sz > MLX5_MAX_LOG_PKEY_TABLE)\n\t\treturn 0;\n\treturn MLX5_MIN_PKEY_TABLE_SIZE << pkey_sz;\n}\n\n#define MLX5_RDMA_RX_NUM_COUNTERS_PRIOS 2\n#define MLX5_RDMA_TX_NUM_COUNTERS_PRIOS 1\n#define MLX5_BY_PASS_NUM_REGULAR_PRIOS 16\n#define MLX5_BY_PASS_NUM_DONT_TRAP_PRIOS 16\n#define MLX5_BY_PASS_NUM_MULTICAST_PRIOS 1\n#define MLX5_BY_PASS_NUM_PRIOS (MLX5_BY_PASS_NUM_REGULAR_PRIOS +\\\n\t\t\t\tMLX5_BY_PASS_NUM_DONT_TRAP_PRIOS +\\\n\t\t\t\tMLX5_BY_PASS_NUM_MULTICAST_PRIOS)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}