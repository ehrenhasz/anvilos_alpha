{
  "module_name": "eswitch.h",
  "hash_id": "5894ca1503cacbc4e85738bd2b381e0df0e4de4c24278044afa9bc7540abd17f",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/mlx5/eswitch.h",
  "human_readable_source": " \n \n\n#ifndef _MLX5_ESWITCH_\n#define _MLX5_ESWITCH_\n\n#include <linux/mlx5/driver.h>\n#include <net/devlink.h>\n\n#define MLX5_ESWITCH_MANAGER(mdev) MLX5_CAP_GEN(mdev, eswitch_manager)\n\nenum {\n\tMLX5_ESWITCH_LEGACY,\n\tMLX5_ESWITCH_OFFLOADS\n};\n\nenum {\n\tREP_ETH,\n\tREP_IB,\n\tNUM_REP_TYPES,\n};\n\nenum {\n\tREP_UNREGISTERED,\n\tREP_REGISTERED,\n\tREP_LOADED,\n};\n\nenum mlx5_switchdev_event {\n\tMLX5_SWITCHDEV_EVENT_PAIR,\n\tMLX5_SWITCHDEV_EVENT_UNPAIR,\n};\n\nstruct mlx5_eswitch_rep;\nstruct mlx5_eswitch_rep_ops {\n\tint (*load)(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep);\n\tvoid (*unload)(struct mlx5_eswitch_rep *rep);\n\tvoid *(*get_proto_dev)(struct mlx5_eswitch_rep *rep);\n\tint (*event)(struct mlx5_eswitch *esw,\n\t\t     struct mlx5_eswitch_rep *rep,\n\t\t     enum mlx5_switchdev_event event,\n\t\t     void *data);\n};\n\nstruct mlx5_eswitch_rep_data {\n\tvoid *priv;\n\tatomic_t state;\n};\n\nstruct mlx5_eswitch_rep {\n\tstruct mlx5_eswitch_rep_data rep_data[NUM_REP_TYPES];\n\tu16\t\t       vport;\n\tu16\t\t       vlan;\n\t \n\tu16\t\t       vport_index;\n\tu32\t\t       vlan_refcount;\n\tstruct                 mlx5_eswitch *esw;\n};\n\nvoid mlx5_eswitch_register_vport_reps(struct mlx5_eswitch *esw,\n\t\t\t\t      const struct mlx5_eswitch_rep_ops *ops,\n\t\t\t\t      u8 rep_type);\nvoid mlx5_eswitch_unregister_vport_reps(struct mlx5_eswitch *esw, u8 rep_type);\nvoid *mlx5_eswitch_get_proto_dev(struct mlx5_eswitch *esw,\n\t\t\t\t u16 vport_num,\n\t\t\t\t u8 rep_type);\nstruct mlx5_eswitch_rep *mlx5_eswitch_vport_rep(struct mlx5_eswitch *esw,\n\t\t\t\t\t\tu16 vport_num);\nvoid *mlx5_eswitch_uplink_get_proto_dev(struct mlx5_eswitch *esw, u8 rep_type);\nstruct mlx5_flow_handle *\nmlx5_eswitch_add_send_to_vport_rule(struct mlx5_eswitch *on_esw,\n\t\t\t\t    struct mlx5_eswitch *from_esw,\n\t\t\t\t    struct mlx5_eswitch_rep *rep, u32 sqn);\n\n#ifdef CONFIG_MLX5_ESWITCH\nenum devlink_eswitch_encap_mode\nmlx5_eswitch_get_encap_mode(const struct mlx5_core_dev *dev);\n\nbool mlx5_eswitch_reg_c1_loopback_enabled(const struct mlx5_eswitch *esw);\nbool mlx5_eswitch_vport_match_metadata_enabled(const struct mlx5_eswitch *esw);\n\n \n#define ESW_VPORT_BITS 12\n#define ESW_PFNUM_BITS 4\n#define ESW_SOURCE_PORT_METADATA_BITS (ESW_PFNUM_BITS + ESW_VPORT_BITS)\n#define ESW_SOURCE_PORT_METADATA_OFFSET (32 - ESW_SOURCE_PORT_METADATA_BITS)\n#define ESW_REG_C0_USER_DATA_METADATA_BITS (32 - ESW_SOURCE_PORT_METADATA_BITS)\n#define ESW_REG_C0_USER_DATA_METADATA_MASK GENMASK(ESW_REG_C0_USER_DATA_METADATA_BITS - 1, 0)\n\nstatic inline u32 mlx5_eswitch_get_vport_metadata_mask(void)\n{\n\treturn GENMASK(31, 32 - ESW_SOURCE_PORT_METADATA_BITS);\n}\n\nu32 mlx5_eswitch_get_vport_metadata_for_match(struct mlx5_eswitch *esw,\n\t\t\t\t\t      u16 vport_num);\nu32 mlx5_eswitch_get_vport_metadata_for_set(struct mlx5_eswitch *esw,\n\t\t\t\t\t    u16 vport_num);\n\n \n#define ESW_RESERVED_BITS 1\n#define ESW_ZONE_ID_BITS 8\n#define ESW_TUN_OPTS_BITS 11\n#define ESW_TUN_ID_BITS 12\n#define ESW_TUN_OPTS_OFFSET ESW_ZONE_ID_BITS\n#define ESW_TUN_OFFSET ESW_TUN_OPTS_OFFSET\n#define ESW_ZONE_ID_MASK GENMASK(ESW_ZONE_ID_BITS - 1, 0)\n#define ESW_TUN_OPTS_MASK GENMASK(31 - ESW_TUN_ID_BITS - ESW_RESERVED_BITS, ESW_TUN_OPTS_OFFSET)\n#define ESW_TUN_MASK GENMASK(31 - ESW_RESERVED_BITS, ESW_TUN_OFFSET)\n#define ESW_TUN_ID_SLOW_TABLE_GOTO_VPORT 0  \n#define ESW_TUN_ID_BRIDGE_INGRESS_PUSH_VLAN ESW_TUN_ID_SLOW_TABLE_GOTO_VPORT\n \n#define ESW_TUN_OPTS_SLOW_TABLE_GOTO_VPORT GENMASK(ESW_TUN_OPTS_BITS - 1, 0)\n#define ESW_TUN_SLOW_TABLE_GOTO_VPORT ((ESW_TUN_ID_SLOW_TABLE_GOTO_VPORT << ESW_TUN_OPTS_BITS) | \\\n\t\t\t\t       ESW_TUN_OPTS_SLOW_TABLE_GOTO_VPORT)\n#define ESW_TUN_SLOW_TABLE_GOTO_VPORT_MARK ESW_TUN_OPTS_MASK\n \n#define ESW_TUN_OPTS_BRIDGE_INGRESS_PUSH_VLAN (ESW_TUN_OPTS_SLOW_TABLE_GOTO_VPORT - 1)\n#define ESW_TUN_BRIDGE_INGRESS_PUSH_VLAN ((ESW_TUN_ID_BRIDGE_INGRESS_PUSH_VLAN << \\\n\t\t\t\t\t   ESW_TUN_OPTS_BITS) | \\\n\t\t\t\t\t  ESW_TUN_OPTS_BRIDGE_INGRESS_PUSH_VLAN)\n#define ESW_TUN_BRIDGE_INGRESS_PUSH_VLAN_MARK \\\n\tGENMASK(31 - ESW_TUN_ID_BITS - ESW_RESERVED_BITS, \\\n\t\tESW_TUN_OPTS_OFFSET + 1)\n\n \n#define ESW_IPSEC_RX_MAPPED_ID_MASK GENMASK(ESW_TUN_OPTS_BITS - 1, 0)\n\nu8 mlx5_eswitch_mode(const struct mlx5_core_dev *dev);\nu16 mlx5_eswitch_get_total_vports(const struct mlx5_core_dev *dev);\nstruct mlx5_core_dev *mlx5_eswitch_get_core_dev(struct mlx5_eswitch *esw);\n\n#else   \n\nstatic inline u8 mlx5_eswitch_mode(const struct mlx5_core_dev *dev)\n{\n\treturn MLX5_ESWITCH_LEGACY;\n}\n\nstatic inline enum devlink_eswitch_encap_mode\nmlx5_eswitch_get_encap_mode(const struct mlx5_core_dev *dev)\n{\n\treturn DEVLINK_ESWITCH_ENCAP_MODE_NONE;\n}\n\nstatic inline bool\nmlx5_eswitch_reg_c1_loopback_enabled(const struct mlx5_eswitch *esw)\n{\n\treturn false;\n};\n\nstatic inline bool\nmlx5_eswitch_vport_match_metadata_enabled(const struct mlx5_eswitch *esw)\n{\n\treturn false;\n};\n\nstatic inline u32\nmlx5_eswitch_get_vport_metadata_for_match(struct mlx5_eswitch *esw, u16 vport_num)\n{\n\treturn 0;\n};\n\nstatic inline u32\nmlx5_eswitch_get_vport_metadata_mask(void)\n{\n\treturn 0;\n}\n\nstatic inline u16 mlx5_eswitch_get_total_vports(const struct mlx5_core_dev *dev)\n{\n\treturn 0;\n}\n\nstatic inline struct mlx5_core_dev *mlx5_eswitch_get_core_dev(struct mlx5_eswitch *esw)\n{\n\treturn NULL;\n}\n\n#endif  \n\nstatic inline bool is_mdev_legacy_mode(struct mlx5_core_dev *dev)\n{\n\treturn mlx5_eswitch_mode(dev) == MLX5_ESWITCH_LEGACY;\n}\n\nstatic inline bool is_mdev_switchdev_mode(struct mlx5_core_dev *dev)\n{\n\treturn mlx5_eswitch_mode(dev) == MLX5_ESWITCH_OFFLOADS;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}