{
  "module_name": "vmw_vmci_defs.h",
  "hash_id": "b218aef1ddcc0dba2031b5f69450648be775f8e9978f69faf252e5aa6f59bad0",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/vmw_vmci_defs.h",
  "human_readable_source": " \n \n\n#ifndef _VMW_VMCI_DEF_H_\n#define _VMW_VMCI_DEF_H_\n\n#include <linux/atomic.h>\n#include <linux/bits.h>\n\n \n#define VMCI_STATUS_ADDR        0x00\n#define VMCI_CONTROL_ADDR       0x04\n#define VMCI_ICR_ADDR           0x08\n#define VMCI_IMR_ADDR           0x0c\n#define VMCI_DATA_OUT_ADDR      0x10\n#define VMCI_DATA_IN_ADDR       0x14\n#define VMCI_CAPS_ADDR          0x18\n#define VMCI_RESULT_LOW_ADDR    0x1c\n#define VMCI_RESULT_HIGH_ADDR   0x20\n#define VMCI_DATA_OUT_LOW_ADDR  0x24\n#define VMCI_DATA_OUT_HIGH_ADDR 0x28\n#define VMCI_DATA_IN_LOW_ADDR   0x2c\n#define VMCI_DATA_IN_HIGH_ADDR  0x30\n#define VMCI_GUEST_PAGE_SHIFT   0x34\n\n \n#define VMCI_MAX_DEVICES 1\n\n \n#define VMCI_STATUS_INT_ON     BIT(0)\n\n \n#define VMCI_CONTROL_RESET        BIT(0)\n#define VMCI_CONTROL_INT_ENABLE   BIT(1)\n#define VMCI_CONTROL_INT_DISABLE  BIT(2)\n\n \n#define VMCI_CAPS_HYPERCALL     BIT(0)\n#define VMCI_CAPS_GUESTCALL     BIT(1)\n#define VMCI_CAPS_DATAGRAM      BIT(2)\n#define VMCI_CAPS_NOTIFICATIONS BIT(3)\n#define VMCI_CAPS_PPN64         BIT(4)\n#define VMCI_CAPS_DMA_DATAGRAM  BIT(5)\n\n \n#define VMCI_ICR_DATAGRAM      BIT(0)\n#define VMCI_ICR_NOTIFICATION  BIT(1)\n#define VMCI_ICR_DMA_DATAGRAM  BIT(2)\n\n \n#define VMCI_IMR_DATAGRAM      BIT(0)\n#define VMCI_IMR_NOTIFICATION  BIT(1)\n#define VMCI_IMR_DMA_DATAGRAM  BIT(2)\n\n \n#define VMCI_MAX_INTRS_NOTIFICATION 2\n#define VMCI_MAX_INTRS_DMA_DATAGRAM 3\n#define VMCI_MAX_INTRS              VMCI_MAX_INTRS_DMA_DATAGRAM\n\n \nenum {\n\tVMCI_INTR_DATAGRAM = 0,\n\tVMCI_INTR_NOTIFICATION = 1,\n\tVMCI_INTR_DMA_DATAGRAM = 2,\n};\n\n \n#define VMCI_MAX_GUEST_QP_MEMORY ((size_t)(128 * 1024 * 1024))\n#define VMCI_MAX_GUEST_QP_COUNT  (VMCI_MAX_GUEST_QP_MEMORY / PAGE_SIZE / 2)\n\n \n#define VMCI_MAX_GUEST_DOORBELL_COUNT PAGE_SIZE\n\n \n#define VMCI_MAX_PINNED_QP_MEMORY ((size_t)(32 * 1024))\n\n \n#define VMCI_WITH_MMIO_ACCESS_BAR_SIZE ((size_t)(256 * 1024))\n#define VMCI_MMIO_ACCESS_OFFSET        ((size_t)(128 * 1024))\n#define VMCI_MMIO_ACCESS_SIZE          ((size_t)(64 * 1024))\n\n \nstruct vmci_data_in_out_header {\n\tuint32_t busy;\n\tuint32_t opcode;\n\tuint32_t size;\n\tuint32_t rsvd;\n\tuint64_t result;\n};\n\nstruct vmci_sg_elem {\n\tuint64_t addr;\n\tuint64_t size;\n};\n\n \nenum {\n\tVMCI_RESOURCES_QUERY = 0,\n\tVMCI_GET_CONTEXT_ID = 1,\n\tVMCI_SET_NOTIFY_BITMAP = 2,\n\tVMCI_DOORBELL_LINK = 3,\n\tVMCI_DOORBELL_UNLINK = 4,\n\tVMCI_DOORBELL_NOTIFY = 5,\n\t \n\tVMCI_DATAGRAM_REQUEST_MAP = 6,\n\tVMCI_DATAGRAM_REMOVE_MAP = 7,\n\tVMCI_EVENT_SUBSCRIBE = 8,\n\tVMCI_EVENT_UNSUBSCRIBE = 9,\n\tVMCI_QUEUEPAIR_ALLOC = 10,\n\tVMCI_QUEUEPAIR_DETACH = 11,\n\n\t \n\tVMCI_HGFS_TRANSPORT = 13,\n\tVMCI_UNITY_PBRPC_REGISTER = 14,\n\tVMCI_RPC_PRIVILEGED = 15,\n\tVMCI_RPC_UNPRIVILEGED = 16,\n\tVMCI_RESOURCE_MAX = 17,\n};\n\n \nstruct vmci_handle {\n\tu32 context;\n\tu32 resource;\n};\n\n#define vmci_make_handle(_cid, _rid) \\\n\t(struct vmci_handle){ .context = _cid, .resource = _rid }\n\nstatic inline bool vmci_handle_is_equal(struct vmci_handle h1,\n\t\t\t\t\tstruct vmci_handle h2)\n{\n\treturn h1.context == h2.context && h1.resource == h2.resource;\n}\n\n#define VMCI_INVALID_ID ~0\nstatic const struct vmci_handle VMCI_INVALID_HANDLE = {\n\t.context = VMCI_INVALID_ID,\n\t.resource = VMCI_INVALID_ID\n};\n\nstatic inline bool vmci_handle_is_invalid(struct vmci_handle h)\n{\n\treturn vmci_handle_is_equal(h, VMCI_INVALID_HANDLE);\n}\n\n \n#define VMCI_ANON_SRC_CONTEXT_ID   VMCI_INVALID_ID\n#define VMCI_ANON_SRC_RESOURCE_ID  VMCI_INVALID_ID\nstatic const struct vmci_handle __maybe_unused VMCI_ANON_SRC_HANDLE = {\n\t.context = VMCI_ANON_SRC_CONTEXT_ID,\n\t.resource = VMCI_ANON_SRC_RESOURCE_ID\n};\n\n \n#define VMCI_RESERVED_CID_LIMIT ((u32) 16)\n\n \n#define VMCI_HYPERVISOR_CONTEXT_ID 0\n\n \n#define VMCI_WELL_KNOWN_CONTEXT_ID 1\n\n \n#define VMCI_HOST_CONTEXT_ID  2\n\n#define VMCI_CONTEXT_IS_VM(_cid) (VMCI_INVALID_ID != (_cid) &&\t\t\\\n\t\t\t\t  (_cid) > VMCI_HOST_CONTEXT_ID)\n\n \n#define VMCI_CONTEXT_RESOURCE_ID 0\n\n \nenum {\n\tVMCI_SUCCESS_QUEUEPAIR_ATTACH\t= 5,\n\tVMCI_SUCCESS_QUEUEPAIR_CREATE\t= 4,\n\tVMCI_SUCCESS_LAST_DETACH\t= 3,\n\tVMCI_SUCCESS_ACCESS_GRANTED\t= 2,\n\tVMCI_SUCCESS_ENTRY_DEAD\t\t= 1,\n\tVMCI_SUCCESS\t\t\t = 0,\n\tVMCI_ERROR_INVALID_RESOURCE\t = (-1),\n\tVMCI_ERROR_INVALID_ARGS\t\t = (-2),\n\tVMCI_ERROR_NO_MEM\t\t = (-3),\n\tVMCI_ERROR_DATAGRAM_FAILED\t = (-4),\n\tVMCI_ERROR_MORE_DATA\t\t = (-5),\n\tVMCI_ERROR_NO_MORE_DATAGRAMS\t = (-6),\n\tVMCI_ERROR_NO_ACCESS\t\t = (-7),\n\tVMCI_ERROR_NO_HANDLE\t\t = (-8),\n\tVMCI_ERROR_DUPLICATE_ENTRY\t = (-9),\n\tVMCI_ERROR_DST_UNREACHABLE\t = (-10),\n\tVMCI_ERROR_PAYLOAD_TOO_LARGE\t = (-11),\n\tVMCI_ERROR_INVALID_PRIV\t\t = (-12),\n\tVMCI_ERROR_GENERIC\t\t = (-13),\n\tVMCI_ERROR_PAGE_ALREADY_SHARED\t = (-14),\n\tVMCI_ERROR_CANNOT_SHARE_PAGE\t = (-15),\n\tVMCI_ERROR_CANNOT_UNSHARE_PAGE\t = (-16),\n\tVMCI_ERROR_NO_PROCESS\t\t = (-17),\n\tVMCI_ERROR_NO_DATAGRAM\t\t = (-18),\n\tVMCI_ERROR_NO_RESOURCES\t\t = (-19),\n\tVMCI_ERROR_UNAVAILABLE\t\t = (-20),\n\tVMCI_ERROR_NOT_FOUND\t\t = (-21),\n\tVMCI_ERROR_ALREADY_EXISTS\t = (-22),\n\tVMCI_ERROR_NOT_PAGE_ALIGNED\t = (-23),\n\tVMCI_ERROR_INVALID_SIZE\t\t = (-24),\n\tVMCI_ERROR_REGION_ALREADY_SHARED = (-25),\n\tVMCI_ERROR_TIMEOUT\t\t = (-26),\n\tVMCI_ERROR_DATAGRAM_INCOMPLETE\t = (-27),\n\tVMCI_ERROR_INCORRECT_IRQL\t = (-28),\n\tVMCI_ERROR_EVENT_UNKNOWN\t = (-29),\n\tVMCI_ERROR_OBSOLETE\t\t = (-30),\n\tVMCI_ERROR_QUEUEPAIR_MISMATCH\t = (-31),\n\tVMCI_ERROR_QUEUEPAIR_NOTSET\t = (-32),\n\tVMCI_ERROR_QUEUEPAIR_NOTOWNER\t = (-33),\n\tVMCI_ERROR_QUEUEPAIR_NOTATTACHED = (-34),\n\tVMCI_ERROR_QUEUEPAIR_NOSPACE\t = (-35),\n\tVMCI_ERROR_QUEUEPAIR_NODATA\t = (-36),\n\tVMCI_ERROR_BUSMEM_INVALIDATION\t = (-37),\n\tVMCI_ERROR_MODULE_NOT_LOADED\t = (-38),\n\tVMCI_ERROR_DEVICE_NOT_FOUND\t = (-39),\n\tVMCI_ERROR_QUEUEPAIR_NOT_READY\t = (-40),\n\tVMCI_ERROR_WOULD_BLOCK\t\t = (-41),\n\n\t \n\tVMCI_ERROR_CLIENT_MIN\t\t = (-500),\n\tVMCI_ERROR_CLIENT_MAX\t\t = (-550),\n\n\t \n\tVMCI_SHAREDMEM_ERROR_BAD_CONTEXT = (-1000),\n};\n\n \nenum {\n\t \n\tVMCI_EVENT_CTX_ID_UPDATE  = 0,\n\n\t \n\tVMCI_EVENT_CTX_REMOVED\t  = 1,\n\n\t \n\tVMCI_EVENT_QP_RESUMED\t  = 2,\n\n\t \n\tVMCI_EVENT_QP_PEER_ATTACH = 3,\n\n\t \n\tVMCI_EVENT_QP_PEER_DETACH = 4,\n\n\t \n\tVMCI_EVENT_MEM_ACCESS_ON  = 5,\n\n\t \n\tVMCI_EVENT_MEM_ACCESS_OFF = 6,\n\tVMCI_EVENT_MAX\t\t  = 7,\n};\n\n \n#define VMCI_EVENT_VALID_VMX(_event) ((_event) == VMCI_EVENT_MEM_ACCESS_ON || \\\n\t\t\t\t      (_event) == VMCI_EVENT_MEM_ACCESS_OFF)\n\n#define VMCI_EVENT_VALID(_event) ((_event) < VMCI_EVENT_MAX &&\t\t\\\n\t\t\t\t  !VMCI_EVENT_VALID_VMX(_event))\n\n \n#define VMCI_EVENT_HANDLER 0\n\n \nenum {\n\tVMCI_NO_PRIVILEGE_FLAGS = 0,\n\tVMCI_PRIVILEGE_FLAG_RESTRICTED = 1,\n\tVMCI_PRIVILEGE_FLAG_TRUSTED = 2,\n\tVMCI_PRIVILEGE_ALL_FLAGS = (VMCI_PRIVILEGE_FLAG_RESTRICTED |\n\t\t\t\t    VMCI_PRIVILEGE_FLAG_TRUSTED),\n\tVMCI_DEFAULT_PROC_PRIVILEGE_FLAGS = VMCI_NO_PRIVILEGE_FLAGS,\n\tVMCI_LEAST_PRIVILEGE_FLAGS = VMCI_PRIVILEGE_FLAG_RESTRICTED,\n\tVMCI_MAX_PRIVILEGE_FLAGS = VMCI_PRIVILEGE_FLAG_TRUSTED,\n};\n\n \n#define VMCI_RESERVED_RESOURCE_ID_MAX 1023\n\n \n\n \n#define VMCI_VERSION_SHIFT_WIDTH 16\n#define VMCI_MAKE_VERSION(_major, _minor)\t\t\t\\\n\t((_major) << VMCI_VERSION_SHIFT_WIDTH | (u16) (_minor))\n\n#define VMCI_VERSION_MAJOR(v)  ((u32) (v) >> VMCI_VERSION_SHIFT_WIDTH)\n#define VMCI_VERSION_MINOR(v)  ((u16) (v))\n\n \n\n#define VMCI_VERSION                VMCI_VERSION_NOVMVM\n#define VMCI_VERSION_NOVMVM         VMCI_MAKE_VERSION(11, 0)\n#define VMCI_VERSION_NOTIFY         VMCI_MAKE_VERSION(10, 0)\n#define VMCI_VERSION_HOSTQP         VMCI_MAKE_VERSION(9, 0)\n#define VMCI_VERSION_PREHOSTQP      VMCI_MAKE_VERSION(8, 0)\n#define VMCI_VERSION_PREVERS2       VMCI_MAKE_VERSION(1, 0)\n\n#define VMCI_SOCKETS_MAKE_VERSION(_p)\t\t\t\t\t\\\n\t((((_p)[0] & 0xFF) << 24) | (((_p)[1] & 0xFF) << 16) | ((_p)[2]))\n\n \n#define IOCTL_VMCI_VERSION\t\t\t_IO(7, 0x9f)\t \n#define IOCTL_VMCI_INIT_CONTEXT\t\t\t_IO(7, 0xa0)\n#define IOCTL_VMCI_QUEUEPAIR_SETVA\t\t_IO(7, 0xa4)\n#define IOCTL_VMCI_NOTIFY_RESOURCE\t\t_IO(7, 0xa5)\n#define IOCTL_VMCI_NOTIFICATIONS_RECEIVE\t_IO(7, 0xa6)\n#define IOCTL_VMCI_VERSION2\t\t\t_IO(7, 0xa7)\n#define IOCTL_VMCI_QUEUEPAIR_ALLOC\t\t_IO(7, 0xa8)\n#define IOCTL_VMCI_QUEUEPAIR_SETPAGEFILE\t_IO(7, 0xa9)\n#define IOCTL_VMCI_QUEUEPAIR_DETACH\t\t_IO(7, 0xaa)\n#define IOCTL_VMCI_DATAGRAM_SEND\t\t_IO(7, 0xab)\n#define IOCTL_VMCI_DATAGRAM_RECEIVE\t\t_IO(7, 0xac)\n#define IOCTL_VMCI_CTX_ADD_NOTIFICATION\t\t_IO(7, 0xaf)\n#define IOCTL_VMCI_CTX_REMOVE_NOTIFICATION\t_IO(7, 0xb0)\n#define IOCTL_VMCI_CTX_GET_CPT_STATE\t\t_IO(7, 0xb1)\n#define IOCTL_VMCI_CTX_SET_CPT_STATE\t\t_IO(7, 0xb2)\n#define IOCTL_VMCI_GET_CONTEXT_ID\t\t_IO(7, 0xb3)\n#define IOCTL_VMCI_SOCKETS_VERSION\t\t_IO(7, 0xb4)\n#define IOCTL_VMCI_SOCKETS_GET_AF_VALUE\t\t_IO(7, 0xb8)\n#define IOCTL_VMCI_SOCKETS_GET_LOCAL_CID\t_IO(7, 0xb9)\n#define IOCTL_VMCI_SET_NOTIFY\t\t\t_IO(7, 0xcb)\t \n \t \n\n \nstruct vmci_queue_header {\n\t \n\tstruct vmci_handle handle;\t \n\tu64 producer_tail;\t \n\tu64 consumer_head;\t \n};\n\n \nstruct vmci_datagram {\n\tstruct vmci_handle dst;\n\tstruct vmci_handle src;\n\tu64 payload_size;\n};\n\n \n#define VMCI_FLAG_DG_NONE          0\n#define VMCI_FLAG_WELLKNOWN_DG_HND BIT(0)\n#define VMCI_FLAG_ANYCID_DG_HND    BIT(1)\n#define VMCI_FLAG_DG_DELAYED_CB    BIT(2)\n\n \n#define VMCI_MAX_DG_SIZE (17 * 4096)\n#define VMCI_MAX_DG_PAYLOAD_SIZE (VMCI_MAX_DG_SIZE - \\\n\t\t\t\t  sizeof(struct vmci_datagram))\n#define VMCI_DG_PAYLOAD(_dg) (void *)((char *)(_dg) +\t\t\t\\\n\t\t\t\t      sizeof(struct vmci_datagram))\n#define VMCI_DG_HEADERSIZE sizeof(struct vmci_datagram)\n#define VMCI_DG_SIZE(_dg) (VMCI_DG_HEADERSIZE + (size_t)(_dg)->payload_size)\n#define VMCI_DG_SIZE_ALIGNED(_dg) ((VMCI_DG_SIZE(_dg) + 7) & (~((size_t) 0x7)))\n#define VMCI_MAX_DATAGRAM_QUEUE_SIZE (VMCI_MAX_DG_SIZE * 2)\n\nstruct vmci_event_payload_qp {\n\tstruct vmci_handle handle;   \n\tu32 peer_id;\t\t     \n\tu32 _pad;\n};\n\n \nenum {\n\t \n\tVMCI_QPFLAG_ATTACH_ONLY = 1 << 0,\n\n\t \n\tVMCI_QPFLAG_LOCAL = 1 << 1,\n\n\t \n\tVMCI_QPFLAG_NONBLOCK = 1 << 2,\n\n\t \n\tVMCI_QPFLAG_PINNED = 1 << 3,\n\n\t \n\tVMCI_QP_ALL_FLAGS = (VMCI_QPFLAG_ATTACH_ONLY | VMCI_QPFLAG_LOCAL |\n\t\t\t     VMCI_QPFLAG_NONBLOCK | VMCI_QPFLAG_PINNED),\n\n\t \n\tVMCI_QP_ASYMM = (VMCI_QPFLAG_NONBLOCK | VMCI_QPFLAG_PINNED),\n\tVMCI_QP_ASYMM_PEER = (VMCI_QPFLAG_ATTACH_ONLY | VMCI_QP_ASYMM),\n};\n\n \n#define VMCI_MAX_DATAGRAM_AND_EVENT_QUEUE_SIZE\t\t\t\t\\\n\t(VMCI_MAX_DATAGRAM_QUEUE_SIZE +\t\t\t\t\t\\\n\t 1024 * (sizeof(struct vmci_datagram) +\t\t\t\t\\\n\t\t sizeof(struct vmci_event_data_max)))\n\n \nstruct vmci_resource_query_hdr {\n\tstruct vmci_datagram hdr;\n\tu32 num_resources;\n\tu32 _padding;\n};\n\n \nstruct vmci_resource_query_msg {\n\tu32 num_resources;\n\tu32 _padding;\n\tu32 resources[1];\n};\n\n \n#define VMCI_RESOURCE_QUERY_MAX_NUM 31\n\n \n#define VMCI_RESOURCE_QUERY_MAX_SIZE\t\t\t\t\\\n\t(sizeof(struct vmci_resource_query_hdr) +\t\t\\\n\t sizeof(u32) * VMCI_RESOURCE_QUERY_MAX_NUM)\n\n \nstruct vmci_notify_bm_set_msg {\n\tstruct vmci_datagram hdr;\n\tunion {\n\t\tu32 bitmap_ppn32;\n\t\tu64 bitmap_ppn64;\n\t};\n};\n\n \nstruct vmci_doorbell_link_msg {\n\tstruct vmci_datagram hdr;\n\tstruct vmci_handle handle;\n\tu64 notify_idx;\n};\n\n \nstruct vmci_doorbell_unlink_msg {\n\tstruct vmci_datagram hdr;\n\tstruct vmci_handle handle;\n};\n\n \nstruct vmci_doorbell_notify_msg {\n\tstruct vmci_datagram hdr;\n\tstruct vmci_handle handle;\n};\n\n \nstruct vmci_event_data {\n\tu32 event;\t\t \n\tu32 _pad;\n\t \n};\n\n \nstruct vmci_event_payld_ctx {\n\tu32 context_id;\t \n\tu32 _pad;\n};\n\nstruct vmci_event_payld_qp {\n\tstruct vmci_handle handle;   \n\tu32 peer_id;\t     \n\tu32 _pad;\n};\n\n \nstruct vmci_event_data_max {\n\tstruct vmci_event_data event_data;\n\tunion {\n\t\tstruct vmci_event_payld_ctx context_payload;\n\t\tstruct vmci_event_payld_qp qp_payload;\n\t} ev_data_payload;\n};\n\n \nstruct vmci_event_msg {\n\tstruct vmci_datagram hdr;\n\n\t \n\tstruct vmci_event_data event_data;\n\n\t \n};\n\n \nstruct vmci_event_ctx {\n\tstruct vmci_event_msg msg;\n\tstruct vmci_event_payld_ctx payload;\n};\n\n \nstruct vmci_event_qp {\n\tstruct vmci_event_msg msg;\n\tstruct vmci_event_payld_qp payload;\n};\n\n \nstruct vmci_qp_alloc_msg {\n\tstruct vmci_datagram hdr;\n\tstruct vmci_handle handle;\n\tu32 peer;\n\tu32 flags;\n\tu64 produce_size;\n\tu64 consume_size;\n\tu64 num_ppns;\n\n\t \n};\n\nstruct vmci_qp_detach_msg {\n\tstruct vmci_datagram hdr;\n\tstruct vmci_handle handle;\n};\n\n \n#define VMCI_FLAG_DELAYED_CB BIT(0)\n\ntypedef void (*vmci_callback) (void *client_data);\n\n \nstruct vmci_qp;\n\n \ntypedef int (*vmci_datagram_recv_cb) (void *client_data,\n\t\t\t\t      struct vmci_datagram *msg);\n\n \ntypedef void (*vmci_event_cb) (u32 sub_id, const struct vmci_event_data *ed,\n\t\t\t       void *client_data);\n\n \nstatic inline const void *\nvmci_event_data_const_payload(const struct vmci_event_data *ev_data)\n{\n\treturn (const char *)ev_data + sizeof(*ev_data);\n}\n\nstatic inline void *vmci_event_data_payload(struct vmci_event_data *ev_data)\n{\n\treturn (void *)vmci_event_data_const_payload(ev_data);\n}\n\n \nstatic inline u64 vmci_q_read_pointer(u64 *var)\n{\n\treturn READ_ONCE(*(unsigned long *)var);\n}\n\n \nstatic inline void vmci_q_set_pointer(u64 *var, u64 new_val)\n{\n\t \n\tWRITE_ONCE(*(unsigned long *)var, (unsigned long)new_val);\n}\n\n \nstatic inline void vmci_qp_add_pointer(u64 *var, size_t add, u64 size)\n{\n\tu64 new_val = vmci_q_read_pointer(var);\n\n\tif (new_val >= size - add)\n\t\tnew_val -= size;\n\n\tnew_val += add;\n\n\tvmci_q_set_pointer(var, new_val);\n}\n\n \nstatic inline u64\nvmci_q_header_producer_tail(const struct vmci_queue_header *q_header)\n{\n\tstruct vmci_queue_header *qh = (struct vmci_queue_header *)q_header;\n\treturn vmci_q_read_pointer(&qh->producer_tail);\n}\n\n \nstatic inline u64\nvmci_q_header_consumer_head(const struct vmci_queue_header *q_header)\n{\n\tstruct vmci_queue_header *qh = (struct vmci_queue_header *)q_header;\n\treturn vmci_q_read_pointer(&qh->consumer_head);\n}\n\n \nstatic inline void\nvmci_q_header_add_producer_tail(struct vmci_queue_header *q_header,\n\t\t\t\tsize_t add,\n\t\t\t\tu64 queue_size)\n{\n\tvmci_qp_add_pointer(&q_header->producer_tail, add, queue_size);\n}\n\n \nstatic inline void\nvmci_q_header_add_consumer_head(struct vmci_queue_header *q_header,\n\t\t\t\tsize_t add,\n\t\t\t\tu64 queue_size)\n{\n\tvmci_qp_add_pointer(&q_header->consumer_head, add, queue_size);\n}\n\n \nstatic inline void\nvmci_q_header_get_pointers(const struct vmci_queue_header *produce_q_header,\n\t\t\t   const struct vmci_queue_header *consume_q_header,\n\t\t\t   u64 *producer_tail,\n\t\t\t   u64 *consumer_head)\n{\n\tif (producer_tail)\n\t\t*producer_tail = vmci_q_header_producer_tail(produce_q_header);\n\n\tif (consumer_head)\n\t\t*consumer_head = vmci_q_header_consumer_head(consume_q_header);\n}\n\nstatic inline void vmci_q_header_init(struct vmci_queue_header *q_header,\n\t\t\t\t      const struct vmci_handle handle)\n{\n\tq_header->handle = handle;\n\tq_header->producer_tail = 0;\n\tq_header->consumer_head = 0;\n}\n\n \nstatic s64\nvmci_q_header_free_space(const struct vmci_queue_header *produce_q_header,\n\t\t\t const struct vmci_queue_header *consume_q_header,\n\t\t\t const u64 produce_q_size)\n{\n\tu64 tail;\n\tu64 head;\n\tu64 free_space;\n\n\ttail = vmci_q_header_producer_tail(produce_q_header);\n\thead = vmci_q_header_consumer_head(consume_q_header);\n\n\tif (tail >= produce_q_size || head >= produce_q_size)\n\t\treturn VMCI_ERROR_INVALID_SIZE;\n\n\t \n\tif (tail >= head)\n\t\tfree_space = produce_q_size - (tail - head) - 1;\n\telse\n\t\tfree_space = head - tail - 1;\n\n\treturn free_space;\n}\n\n \nstatic inline s64\nvmci_q_header_buf_ready(const struct vmci_queue_header *consume_q_header,\n\t\t\tconst struct vmci_queue_header *produce_q_header,\n\t\t\tconst u64 consume_q_size)\n{\n\ts64 free_space;\n\n\tfree_space = vmci_q_header_free_space(consume_q_header,\n\t\t\t\t\t      produce_q_header, consume_q_size);\n\tif (free_space < VMCI_SUCCESS)\n\t\treturn free_space;\n\n\treturn consume_q_size - free_space - 1;\n}\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}