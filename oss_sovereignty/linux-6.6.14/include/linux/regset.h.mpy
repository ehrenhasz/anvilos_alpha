{
  "module_name": "regset.h",
  "hash_id": "45c68d1d3efc7d18eb073437fe5421c21f37a4b839a561aef3549b2f593f04f0",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/regset.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_REGSET_H\n#define _LINUX_REGSET_H\t1\n\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/bug.h>\n#include <linux/uaccess.h>\nstruct task_struct;\nstruct user_regset;\n\nstruct membuf {\n\tvoid *p;\n\tsize_t left;\n};\n\nstatic inline int membuf_zero(struct membuf *s, size_t size)\n{\n\tif (s->left) {\n\t\tif (size > s->left)\n\t\t\tsize = s->left;\n\t\tmemset(s->p, 0, size);\n\t\ts->p += size;\n\t\ts->left -= size;\n\t}\n\treturn s->left;\n}\n\nstatic inline int membuf_write(struct membuf *s, const void *v, size_t size)\n{\n\tif (s->left) {\n\t\tif (size > s->left)\n\t\t\tsize = s->left;\n\t\tmemcpy(s->p, v, size);\n\t\ts->p += size;\n\t\ts->left -= size;\n\t}\n\treturn s->left;\n}\n\nstatic inline struct membuf membuf_at(const struct membuf *s, size_t offs)\n{\n\tstruct membuf n = *s;\n\n\tif (offs > n.left)\n\t\toffs = n.left;\n\tn.p += offs;\n\tn.left -= offs;\n\n\treturn n;\n}\n\n \n#define membuf_store(s, v)\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tstruct membuf *__s = (s);\t\t\t\\\n        if (__s->left) {\t\t\t\t\\\n\t\ttypeof(v) __v = (v);\t\t\t\\\n\t\tsize_t __size = sizeof(__v);\t\t\\\n\t\tif (unlikely(__size > __s->left)) {\t\\\n\t\t\t__size = __s->left;\t\t\\\n\t\t\tmemcpy(__s->p, &__v, __size);\t\\\n\t\t} else {\t\t\t\t\\\n\t\t\t*(typeof(__v + 0) *)__s->p = __v;\t\\\n\t\t}\t\t\t\t\t\\\n\t\t__s->p += __size;\t\t\t\\\n\t\t__s->left -= __size;\t\t\t\\\n\t}\t\t\t\t\t\t\\\n\t__s->left;})\n\n \ntypedef int user_regset_active_fn(struct task_struct *target,\n\t\t\t\t  const struct user_regset *regset);\n\ntypedef int user_regset_get2_fn(struct task_struct *target,\n\t\t\t       const struct user_regset *regset,\n\t\t\t       struct membuf to);\n\n \ntypedef int user_regset_set_fn(struct task_struct *target,\n\t\t\t       const struct user_regset *regset,\n\t\t\t       unsigned int pos, unsigned int count,\n\t\t\t       const void *kbuf, const void __user *ubuf);\n\n \ntypedef int user_regset_writeback_fn(struct task_struct *target,\n\t\t\t\t     const struct user_regset *regset,\n\t\t\t\t     int immediate);\n\n \nstruct user_regset {\n\tuser_regset_get2_fn\t\t*regset_get;\n\tuser_regset_set_fn\t\t*set;\n\tuser_regset_active_fn\t\t*active;\n\tuser_regset_writeback_fn\t*writeback;\n\tunsigned int\t\t\tn;\n\tunsigned int \t\t\tsize;\n\tunsigned int \t\t\talign;\n\tunsigned int \t\t\tbias;\n\tunsigned int \t\t\tcore_note_type;\n};\n\n \nstruct user_regset_view {\n\tconst char *name;\n\tconst struct user_regset *regsets;\n\tunsigned int n;\n\tu32 e_flags;\n\tu16 e_machine;\n\tu8 ei_osabi;\n};\n\n \n \nconst struct user_regset_view *task_user_regset_view(struct task_struct *tsk);\n\nstatic inline int user_regset_copyin(unsigned int *pos, unsigned int *count,\n\t\t\t\t     const void **kbuf,\n\t\t\t\t     const void __user **ubuf, void *data,\n\t\t\t\t     const int start_pos, const int end_pos)\n{\n\tif (*count == 0)\n\t\treturn 0;\n\tBUG_ON(*pos < start_pos);\n\tif (end_pos < 0 || *pos < end_pos) {\n\t\tunsigned int copy = (end_pos < 0 ? *count\n\t\t\t\t     : min(*count, end_pos - *pos));\n\t\tdata += *pos - start_pos;\n\t\tif (*kbuf) {\n\t\t\tmemcpy(data, *kbuf, copy);\n\t\t\t*kbuf += copy;\n\t\t} else if (__copy_from_user(data, *ubuf, copy))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\t*ubuf += copy;\n\t\t*pos += copy;\n\t\t*count -= copy;\n\t}\n\treturn 0;\n}\n\nstatic inline void user_regset_copyin_ignore(unsigned int *pos,\n\t\t\t\t\t     unsigned int *count,\n\t\t\t\t\t     const void **kbuf,\n\t\t\t\t\t     const void __user **ubuf,\n\t\t\t\t\t     const int start_pos,\n\t\t\t\t\t     const int end_pos)\n{\n\tif (*count == 0)\n\t\treturn;\n\tBUG_ON(*pos < start_pos);\n\tif (end_pos < 0 || *pos < end_pos) {\n\t\tunsigned int copy = (end_pos < 0 ? *count\n\t\t\t\t     : min(*count, end_pos - *pos));\n\t\tif (*kbuf)\n\t\t\t*kbuf += copy;\n\t\telse\n\t\t\t*ubuf += copy;\n\t\t*pos += copy;\n\t\t*count -= copy;\n\t}\n}\n\nextern int regset_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int size, void *data);\n\nextern int regset_get_alloc(struct task_struct *target,\n\t\t\t    const struct user_regset *regset,\n\t\t\t    unsigned int size,\n\t\t\t    void **data);\n\nextern int copy_regset_to_user(struct task_struct *target,\n\t\t\t       const struct user_regset_view *view,\n\t\t\t       unsigned int setno, unsigned int offset,\n\t\t\t       unsigned int size, void __user *data);\n\n \nstatic inline int copy_regset_from_user(struct task_struct *target,\n\t\t\t\t\tconst struct user_regset_view *view,\n\t\t\t\t\tunsigned int setno,\n\t\t\t\t\tunsigned int offset, unsigned int size,\n\t\t\t\t\tconst void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\n\tif (!regset->set)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!access_ok(data, size))\n\t\treturn -EFAULT;\n\n\treturn regset->set(target, regset, offset, size, NULL, data);\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}