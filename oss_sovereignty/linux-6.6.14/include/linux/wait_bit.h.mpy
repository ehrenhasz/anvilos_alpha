{
  "module_name": "wait_bit.h",
  "hash_id": "3dfbb4fcc64d5fe3e19c1a9d3fcf9b91e617a469be9aa2d99a42f047a3259865",
  "original_prompt": "Ingested from linux-6.6.14/include/linux/wait_bit.h",
  "human_readable_source": " \n#ifndef _LINUX_WAIT_BIT_H\n#define _LINUX_WAIT_BIT_H\n\n \n#include <linux/wait.h>\n\nstruct wait_bit_key {\n\tvoid\t\t\t*flags;\n\tint\t\t\tbit_nr;\n\tunsigned long\t\ttimeout;\n};\n\nstruct wait_bit_queue_entry {\n\tstruct wait_bit_key\tkey;\n\tstruct wait_queue_entry\twq_entry;\n};\n\n#define __WAIT_BIT_KEY_INITIALIZER(word, bit)\t\t\t\t\t\\\n\t{ .flags = word, .bit_nr = bit, }\n\ntypedef int wait_bit_action_f(struct wait_bit_key *key, int mode);\n\nvoid __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit);\nint __wait_on_bit(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry, wait_bit_action_f *action, unsigned int mode);\nint __wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry, wait_bit_action_f *action, unsigned int mode);\nvoid wake_up_bit(void *word, int bit);\nint out_of_line_wait_on_bit(void *word, int, wait_bit_action_f *action, unsigned int mode);\nint out_of_line_wait_on_bit_timeout(void *word, int, wait_bit_action_f *action, unsigned int mode, unsigned long timeout);\nint out_of_line_wait_on_bit_lock(void *word, int, wait_bit_action_f *action, unsigned int mode);\nstruct wait_queue_head *bit_waitqueue(void *word, int bit);\nextern void __init wait_bit_init(void);\n\nint wake_bit_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);\n\n#define DEFINE_WAIT_BIT(name, word, bit)\t\t\t\t\t\\\n\tstruct wait_bit_queue_entry name = {\t\t\t\t\t\\\n\t\t.key = __WAIT_BIT_KEY_INITIALIZER(word, bit),\t\t\t\\\n\t\t.wq_entry = {\t\t\t\t\t\t\t\\\n\t\t\t.private\t= current,\t\t\t\t\\\n\t\t\t.func\t\t= wake_bit_function,\t\t\t\\\n\t\t\t.entry\t\t=\t\t\t\t\t\\\n\t\t\t\tLIST_HEAD_INIT((name).wq_entry.entry),\t\t\\\n\t\t},\t\t\t\t\t\t\t\t\\\n\t}\n\nextern int bit_wait(struct wait_bit_key *key, int mode);\nextern int bit_wait_io(struct wait_bit_key *key, int mode);\nextern int bit_wait_timeout(struct wait_bit_key *key, int mode);\nextern int bit_wait_io_timeout(struct wait_bit_key *key, int mode);\n\n \nstatic inline int\nwait_on_bit(unsigned long *word, int bit, unsigned mode)\n{\n\tmight_sleep();\n\tif (!test_bit_acquire(bit, word))\n\t\treturn 0;\n\treturn out_of_line_wait_on_bit(word, bit,\n\t\t\t\t       bit_wait,\n\t\t\t\t       mode);\n}\n\n \nstatic inline int\nwait_on_bit_io(unsigned long *word, int bit, unsigned mode)\n{\n\tmight_sleep();\n\tif (!test_bit_acquire(bit, word))\n\t\treturn 0;\n\treturn out_of_line_wait_on_bit(word, bit,\n\t\t\t\t       bit_wait_io,\n\t\t\t\t       mode);\n}\n\n \nstatic inline int\nwait_on_bit_timeout(unsigned long *word, int bit, unsigned mode,\n\t\t    unsigned long timeout)\n{\n\tmight_sleep();\n\tif (!test_bit_acquire(bit, word))\n\t\treturn 0;\n\treturn out_of_line_wait_on_bit_timeout(word, bit,\n\t\t\t\t\t       bit_wait_timeout,\n\t\t\t\t\t       mode, timeout);\n}\n\n \nstatic inline int\nwait_on_bit_action(unsigned long *word, int bit, wait_bit_action_f *action,\n\t\t   unsigned mode)\n{\n\tmight_sleep();\n\tif (!test_bit_acquire(bit, word))\n\t\treturn 0;\n\treturn out_of_line_wait_on_bit(word, bit, action, mode);\n}\n\n \nstatic inline int\nwait_on_bit_lock(unsigned long *word, int bit, unsigned mode)\n{\n\tmight_sleep();\n\tif (!test_and_set_bit(bit, word))\n\t\treturn 0;\n\treturn out_of_line_wait_on_bit_lock(word, bit, bit_wait, mode);\n}\n\n \nstatic inline int\nwait_on_bit_lock_io(unsigned long *word, int bit, unsigned mode)\n{\n\tmight_sleep();\n\tif (!test_and_set_bit(bit, word))\n\t\treturn 0;\n\treturn out_of_line_wait_on_bit_lock(word, bit, bit_wait_io, mode);\n}\n\n \nstatic inline int\nwait_on_bit_lock_action(unsigned long *word, int bit, wait_bit_action_f *action,\n\t\t\tunsigned mode)\n{\n\tmight_sleep();\n\tif (!test_and_set_bit(bit, word))\n\t\treturn 0;\n\treturn out_of_line_wait_on_bit_lock(word, bit, action, mode);\n}\n\nextern void init_wait_var_entry(struct wait_bit_queue_entry *wbq_entry, void *var, int flags);\nextern void wake_up_var(void *var);\nextern wait_queue_head_t *__var_waitqueue(void *p);\n\n#define ___wait_var_event(var, condition, state, exclusive, ret, cmd)\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__label__ __out;\t\t\t\t\t\t\\\n\tstruct wait_queue_head *__wq_head = __var_waitqueue(var);\t\\\n\tstruct wait_bit_queue_entry __wbq_entry;\t\t\t\\\n\tlong __ret = ret;  \t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tinit_wait_var_entry(&__wbq_entry, var,\t\t\t\t\\\n\t\t\t    exclusive ? WQ_FLAG_EXCLUSIVE : 0);\t\t\\\n\tfor (;;) {\t\t\t\t\t\t\t\\\n\t\tlong __int = prepare_to_wait_event(__wq_head,\t\t\\\n\t\t\t\t\t\t   &__wbq_entry.wq_entry, \\\n\t\t\t\t\t\t   state);\t\t\\\n\t\tif (condition)\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (___wait_is_interruptible(state) && __int) {\t\t\\\n\t\t\t__ret = __int;\t\t\t\t\t\\\n\t\t\tgoto __out;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tcmd;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tfinish_wait(__wq_head, &__wbq_entry.wq_entry);\t\t\t\\\n__out:\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_var_event(var, condition)\t\t\t\t\\\n\t___wait_var_event(var, condition, TASK_UNINTERRUPTIBLE, 0, 0,\t\\\n\t\t\t  schedule())\n\n#define wait_var_event(var, condition)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\\\n\tif (condition)\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\t__wait_var_event(var, condition);\t\t\t\t\\\n} while (0)\n\n#define __wait_var_event_killable(var, condition)\t\t\t\\\n\t___wait_var_event(var, condition, TASK_KILLABLE, 0, 0,\t\t\\\n\t\t\t  schedule())\n\n#define wait_var_event_killable(var, condition)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\\\n\t\t__ret = __wait_var_event_killable(var, condition);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_var_event_timeout(var, condition, timeout)\t\t\\\n\t___wait_var_event(var, ___wait_cond_timeout(condition),\t\t\\\n\t\t\t  TASK_UNINTERRUPTIBLE, 0, timeout,\t\t\\\n\t\t\t  __ret = schedule_timeout(__ret))\n\n#define wait_var_event_timeout(var, condition, timeout)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tlong __ret = timeout;\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\\\n\tif (!___wait_cond_timeout(condition))\t\t\t\t\\\n\t\t__ret = __wait_var_event_timeout(var, condition, timeout); \\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define __wait_var_event_interruptible(var, condition)\t\t\t\\\n\t___wait_var_event(var, condition, TASK_INTERRUPTIBLE, 0, 0,\t\\\n\t\t\t  schedule())\n\n#define wait_var_event_interruptible(var, condition)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\\\n\tif (!(condition))\t\t\t\t\t\t\\\n\t\t__ret = __wait_var_event_interruptible(var, condition);\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n \nstatic inline void clear_and_wake_up_bit(int bit, void *word)\n{\n\tclear_bit_unlock(bit, word);\n\t \n\tsmp_mb__after_atomic();\n\twake_up_bit(word, bit);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}