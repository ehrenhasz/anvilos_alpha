{
  "module_name": "double.h",
  "hash_id": "d17a452029de3ed3131e5ebdc33d3d4a80e304948bf918b004600c7f3303c64b",
  "original_prompt": "Ingested from linux-6.6.14/include/math-emu/double.h",
  "human_readable_source": " \n\n#ifndef    __MATH_EMU_DOUBLE_H__\n#define    __MATH_EMU_DOUBLE_H__\n\n#if _FP_W_TYPE_SIZE < 32\n#error \"Here's a nickel kid.  Go buy yourself a real computer.\"\n#endif\n\n#if _FP_W_TYPE_SIZE < 64\n#define _FP_FRACTBITS_D\t\t(2 * _FP_W_TYPE_SIZE)\n#else\n#define _FP_FRACTBITS_D\t\t_FP_W_TYPE_SIZE\n#endif\n\n#define _FP_FRACBITS_D\t\t53\n#define _FP_FRACXBITS_D\t\t(_FP_FRACTBITS_D - _FP_FRACBITS_D)\n#define _FP_WFRACBITS_D\t\t(_FP_WORKBITS + _FP_FRACBITS_D)\n#define _FP_WFRACXBITS_D\t(_FP_FRACTBITS_D - _FP_WFRACBITS_D)\n#define _FP_EXPBITS_D\t\t11\n#define _FP_EXPBIAS_D\t\t1023\n#define _FP_EXPMAX_D\t\t2047\n\n#define _FP_QNANBIT_D\t\t\\\n\t((_FP_W_TYPE)1 << (_FP_FRACBITS_D-2) % _FP_W_TYPE_SIZE)\n#define _FP_IMPLBIT_D\t\t\\\n\t((_FP_W_TYPE)1 << (_FP_FRACBITS_D-1) % _FP_W_TYPE_SIZE)\n#define _FP_OVERFLOW_D\t\t\\\n\t((_FP_W_TYPE)1 << _FP_WFRACBITS_D % _FP_W_TYPE_SIZE)\n\n#if _FP_W_TYPE_SIZE < 64\n\nunion _FP_UNION_D\n{\n  double flt;\n  struct {\n#if __BYTE_ORDER == __BIG_ENDIAN\n    unsigned sign  : 1;\n    unsigned exp   : _FP_EXPBITS_D;\n    unsigned frac1 : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0) - _FP_W_TYPE_SIZE;\n    unsigned frac0 : _FP_W_TYPE_SIZE;\n#else\n    unsigned frac0 : _FP_W_TYPE_SIZE;\n    unsigned frac1 : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0) - _FP_W_TYPE_SIZE;\n    unsigned exp   : _FP_EXPBITS_D;\n    unsigned sign  : 1;\n#endif\n  } bits __attribute__((packed));\n};\n\n#define FP_DECL_D(X)\t\t_FP_DECL(2,X)\n#define FP_UNPACK_RAW_D(X,val)\t_FP_UNPACK_RAW_2(D,X,val)\n#define FP_UNPACK_RAW_DP(X,val)\t_FP_UNPACK_RAW_2_P(D,X,val)\n#define FP_PACK_RAW_D(val,X)\t_FP_PACK_RAW_2(D,val,X)\n#define FP_PACK_RAW_DP(val,X)\t\t\\\n  do {\t\t\t\t\t\\\n    if (!FP_INHIBIT_RESULTS)\t\t\\\n      _FP_PACK_RAW_2_P(D,val,X);\t\\\n  } while (0)\n\n#define FP_UNPACK_D(X,val)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_UNPACK_RAW_2(D,X,val);\t\t\\\n    _FP_UNPACK_CANONICAL(D,2,X);\t\\\n  } while (0)\n\n#define FP_UNPACK_DP(X,val)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_UNPACK_RAW_2_P(D,X,val);\t\\\n    _FP_UNPACK_CANONICAL(D,2,X);\t\\\n  } while (0)\n\n#define FP_PACK_D(val,X)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_PACK_CANONICAL(D,2,X);\t\t\\\n    _FP_PACK_RAW_2(D,val,X);\t\t\\\n  } while (0)\n\n#define FP_PACK_DP(val,X)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_PACK_CANONICAL(D,2,X);\t\t\\\n    if (!FP_INHIBIT_RESULTS)\t\t\\\n      _FP_PACK_RAW_2_P(D,val,X);\t\\\n  } while (0)\n\n#define FP_ISSIGNAN_D(X)\t\t_FP_ISSIGNAN(D,2,X)\n#define FP_NEG_D(R,X)\t\t\t_FP_NEG(D,2,R,X)\n#define FP_ADD_D(R,X,Y)\t\t\t_FP_ADD(D,2,R,X,Y)\n#define FP_SUB_D(R,X,Y)\t\t\t_FP_SUB(D,2,R,X,Y)\n#define FP_MUL_D(R,X,Y)\t\t\t_FP_MUL(D,2,R,X,Y)\n#define FP_DIV_D(R,X,Y)\t\t\t_FP_DIV(D,2,R,X,Y)\n#define FP_SQRT_D(R,X)\t\t\t_FP_SQRT(D,2,R,X)\n#define _FP_SQRT_MEAT_D(R,S,T,X,Q)\t_FP_SQRT_MEAT_2(R,S,T,X,Q)\n\n#define FP_CMP_D(r,X,Y,un)\t_FP_CMP(D,2,r,X,Y,un)\n#define FP_CMP_EQ_D(r,X,Y)\t_FP_CMP_EQ(D,2,r,X,Y)\n\n#define FP_TO_INT_D(r,X,rsz,rsg)\t_FP_TO_INT(D,2,r,X,rsz,rsg)\n#define FP_TO_INT_ROUND_D(r,X,rsz,rsg)\t_FP_TO_INT_ROUND(D,2,r,X,rsz,rsg)\n#define FP_FROM_INT_D(X,r,rs,rt)\t_FP_FROM_INT(D,2,X,r,rs,rt)\n\n#define _FP_FRAC_HIGH_D(X)\t_FP_FRAC_HIGH_2(X)\n#define _FP_FRAC_HIGH_RAW_D(X)\t_FP_FRAC_HIGH_2(X)\n\n#else\n\nunion _FP_UNION_D\n{\n  double flt;\n  struct {\n#if __BYTE_ORDER == __BIG_ENDIAN\n    unsigned sign : 1;\n    unsigned exp  : _FP_EXPBITS_D;\n    unsigned long frac : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0);\n#else\n    unsigned long frac : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0);\n    unsigned exp  : _FP_EXPBITS_D;\n    unsigned sign : 1;\n#endif\n  } bits __attribute__((packed));\n};\n\n#define FP_DECL_D(X)\t\t_FP_DECL(1,X)\n#define FP_UNPACK_RAW_D(X,val)\t_FP_UNPACK_RAW_1(D,X,val)\n#define FP_UNPACK_RAW_DP(X,val)\t_FP_UNPACK_RAW_1_P(D,X,val)\n#define FP_PACK_RAW_D(val,X)\t_FP_PACK_RAW_1(D,val,X)\n#define FP_PACK_RAW_DP(val,X)\t\t\\\n  do {\t\t\t\t\t\\\n    if (!FP_INHIBIT_RESULTS)\t\t\\\n      _FP_PACK_RAW_1_P(D,val,X);\t\\\n  } while (0)\n\n#define FP_UNPACK_D(X,val)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_UNPACK_RAW_1(D,X,val);\t\t\\\n    _FP_UNPACK_CANONICAL(D,1,X);\t\\\n  } while (0)\n\n#define FP_UNPACK_DP(X,val)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_UNPACK_RAW_1_P(D,X,val);\t\\\n    _FP_UNPACK_CANONICAL(D,1,X);\t\\\n  } while (0)\n\n#define FP_PACK_D(val,X)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_PACK_CANONICAL(D,1,X);\t\t\\\n    _FP_PACK_RAW_1(D,val,X);\t\t\\\n  } while (0)\n\n#define FP_PACK_DP(val,X)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_PACK_CANONICAL(D,1,X);\t\t\\\n    if (!FP_INHIBIT_RESULTS)\t\t\\\n      _FP_PACK_RAW_1_P(D,val,X);\t\\\n  } while (0)\n\n#define FP_ISSIGNAN_D(X)\t\t_FP_ISSIGNAN(D,1,X)\n#define FP_NEG_D(R,X)\t\t\t_FP_NEG(D,1,R,X)\n#define FP_ADD_D(R,X,Y)\t\t\t_FP_ADD(D,1,R,X,Y)\n#define FP_SUB_D(R,X,Y)\t\t\t_FP_SUB(D,1,R,X,Y)\n#define FP_MUL_D(R,X,Y)\t\t\t_FP_MUL(D,1,R,X,Y)\n#define FP_DIV_D(R,X,Y)\t\t\t_FP_DIV(D,1,R,X,Y)\n#define FP_SQRT_D(R,X)\t\t\t_FP_SQRT(D,1,R,X)\n#define _FP_SQRT_MEAT_D(R,S,T,X,Q)\t_FP_SQRT_MEAT_1(R,S,T,X,Q)\n\n \n\n#define FP_CMP_D(r,X,Y,un)\t_FP_CMP(D,1,r,X,Y,un)\n#define FP_CMP_EQ_D(r,X,Y)\t_FP_CMP_EQ(D,1,r,X,Y)\n\n#define FP_TO_INT_D(r,X,rsz,rsg)\t_FP_TO_INT(D,1,r,X,rsz,rsg)\n#define FP_TO_INT_ROUND_D(r,X,rsz,rsg)\t_FP_TO_INT_ROUND(D,1,r,X,rsz,rsg)\n#define FP_FROM_INT_D(X,r,rs,rt)\t_FP_FROM_INT(D,1,X,r,rs,rt)\n\n#define _FP_FRAC_HIGH_D(X)\t_FP_FRAC_HIGH_1(X)\n#define _FP_FRAC_HIGH_RAW_D(X)\t_FP_FRAC_HIGH_1(X)\n\n#endif  \n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}