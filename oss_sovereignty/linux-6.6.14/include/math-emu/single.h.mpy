{
  "module_name": "single.h",
  "hash_id": "77a78ff3b5af02972021bfa26599baa5d181fa34bf8d3d214f1b9b18d9aae232",
  "original_prompt": "Ingested from linux-6.6.14/include/math-emu/single.h",
  "human_readable_source": " \n\n#ifndef    __MATH_EMU_SINGLE_H__\n#define    __MATH_EMU_SINGLE_H__\n\n#if _FP_W_TYPE_SIZE < 32\n#error \"Here's a nickel kid.  Go buy yourself a real computer.\"\n#endif\n\n#define _FP_FRACBITS_S\t\t24\n#define _FP_FRACXBITS_S\t\t(_FP_W_TYPE_SIZE - _FP_FRACBITS_S)\n#define _FP_WFRACBITS_S\t\t(_FP_WORKBITS + _FP_FRACBITS_S)\n#define _FP_WFRACXBITS_S\t(_FP_W_TYPE_SIZE - _FP_WFRACBITS_S)\n#define _FP_EXPBITS_S\t\t8\n#define _FP_EXPBIAS_S\t\t127\n#define _FP_EXPMAX_S\t\t255\n#define _FP_QNANBIT_S\t\t((_FP_W_TYPE)1 << (_FP_FRACBITS_S-2))\n#define _FP_IMPLBIT_S\t\t((_FP_W_TYPE)1 << (_FP_FRACBITS_S-1))\n#define _FP_OVERFLOW_S\t\t((_FP_W_TYPE)1 << (_FP_WFRACBITS_S))\n\n \n\nunion _FP_UNION_S\n{\n  float flt;\n  struct {\n#if __BYTE_ORDER == __BIG_ENDIAN\n    unsigned sign : 1;\n    unsigned exp  : _FP_EXPBITS_S;\n    unsigned frac : _FP_FRACBITS_S - (_FP_IMPLBIT_S != 0);\n#else\n    unsigned frac : _FP_FRACBITS_S - (_FP_IMPLBIT_S != 0);\n    unsigned exp  : _FP_EXPBITS_S;\n    unsigned sign : 1;\n#endif\n  } bits __attribute__((packed));\n};\n\n#define FP_DECL_S(X)\t\t_FP_DECL(1,X)\n#define FP_UNPACK_RAW_S(X,val)\t_FP_UNPACK_RAW_1(S,X,val)\n#define FP_UNPACK_RAW_SP(X,val)\t_FP_UNPACK_RAW_1_P(S,X,val)\n#define FP_PACK_RAW_S(val,X)\t_FP_PACK_RAW_1(S,val,X)\n#define FP_PACK_RAW_SP(val,X)\t\t\\\n  do {\t\t\t\t\t\\\n    if (!FP_INHIBIT_RESULTS)\t\t\\\n      _FP_PACK_RAW_1_P(S,val,X);\t\\\n  } while (0)\n\n#define FP_UNPACK_S(X,val)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_UNPACK_RAW_1(S,X,val);\t\t\\\n    _FP_UNPACK_CANONICAL(S,1,X);\t\\\n  } while (0)\n\n#define FP_UNPACK_SP(X,val)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_UNPACK_RAW_1_P(S,X,val);\t\\\n    _FP_UNPACK_CANONICAL(S,1,X);\t\\\n  } while (0)\n\n#define FP_PACK_S(val,X)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_PACK_CANONICAL(S,1,X);\t\t\\\n    _FP_PACK_RAW_1(S,val,X);\t\t\\\n  } while (0)\n\n#define FP_PACK_SP(val,X)\t\t\\\n  do {\t\t\t\t\t\\\n    _FP_PACK_CANONICAL(S,1,X);\t\t\\\n    if (!FP_INHIBIT_RESULTS)\t\t\\\n      _FP_PACK_RAW_1_P(S,val,X);\t\\\n  } while (0)\n\n#define FP_ISSIGNAN_S(X)\t\t_FP_ISSIGNAN(S,1,X)\n#define FP_NEG_S(R,X)\t\t\t_FP_NEG(S,1,R,X)\n#define FP_ADD_S(R,X,Y)\t\t\t_FP_ADD(S,1,R,X,Y)\n#define FP_SUB_S(R,X,Y)\t\t\t_FP_SUB(S,1,R,X,Y)\n#define FP_MUL_S(R,X,Y)\t\t\t_FP_MUL(S,1,R,X,Y)\n#define FP_DIV_S(R,X,Y)\t\t\t_FP_DIV(S,1,R,X,Y)\n#define FP_SQRT_S(R,X)\t\t\t_FP_SQRT(S,1,R,X)\n#define _FP_SQRT_MEAT_S(R,S,T,X,Q)\t_FP_SQRT_MEAT_1(R,S,T,X,Q)\n\n#define FP_CMP_S(r,X,Y,un)\t_FP_CMP(S,1,r,X,Y,un)\n#define FP_CMP_EQ_S(r,X,Y)\t_FP_CMP_EQ(S,1,r,X,Y)\n\n#define FP_TO_INT_S(r,X,rsz,rsg)\t_FP_TO_INT(S,1,r,X,rsz,rsg)\n#define FP_TO_INT_ROUND_S(r,X,rsz,rsg)\t_FP_TO_INT_ROUND(S,1,r,X,rsz,rsg)\n#define FP_FROM_INT_S(X,r,rs,rt)\t_FP_FROM_INT(S,1,X,r,rs,rt)\n\n#define _FP_FRAC_HIGH_S(X)\t_FP_FRAC_HIGH_1(X)\n#define _FP_FRAC_HIGH_RAW_S(X)\t_FP_FRAC_HIGH_1(X)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}