{
  "module_name": "arm_pmu.h",
  "hash_id": "9a8e6bb0358a148d1f30ac5f3564923d0c24fe8ed20fabc11adb4e5febbcbabb",
  "original_prompt": "Ingested from linux-6.6.14/include/kvm/arm_pmu.h",
  "human_readable_source": " \n \n\n#ifndef __ASM_ARM_KVM_PMU_H\n#define __ASM_ARM_KVM_PMU_H\n\n#include <linux/perf_event.h>\n#include <linux/perf/arm_pmuv3.h>\n\n#define ARMV8_PMU_CYCLE_IDX\t\t(ARMV8_PMU_MAX_COUNTERS - 1)\n\n#if IS_ENABLED(CONFIG_HW_PERF_EVENTS) && IS_ENABLED(CONFIG_KVM)\n\nstruct kvm_pmc {\n\tu8 idx;\t \n\tstruct perf_event *perf_event;\n};\n\nstruct kvm_pmu_events {\n\tu32 events_host;\n\tu32 events_guest;\n};\n\nstruct kvm_pmu {\n\tstruct irq_work overflow_work;\n\tstruct kvm_pmu_events events;\n\tstruct kvm_pmc pmc[ARMV8_PMU_MAX_COUNTERS];\n\tint irq_num;\n\tbool created;\n\tbool irq_level;\n};\n\nstruct arm_pmu_entry {\n\tstruct list_head entry;\n\tstruct arm_pmu *arm_pmu;\n};\n\nDECLARE_STATIC_KEY_FALSE(kvm_arm_pmu_available);\n\nstatic __always_inline bool kvm_arm_support_pmu_v3(void)\n{\n\treturn static_branch_likely(&kvm_arm_pmu_available);\n}\n\n#define kvm_arm_pmu_irq_initialized(v)\t((v)->arch.pmu.irq_num >= VGIC_NR_SGIS)\nu64 kvm_pmu_get_counter_value(struct kvm_vcpu *vcpu, u64 select_idx);\nvoid kvm_pmu_set_counter_value(struct kvm_vcpu *vcpu, u64 select_idx, u64 val);\nu64 kvm_pmu_valid_counter_mask(struct kvm_vcpu *vcpu);\nu64 kvm_pmu_get_pmceid(struct kvm_vcpu *vcpu, bool pmceid1);\nvoid kvm_pmu_vcpu_init(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_vcpu_reset(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_vcpu_destroy(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_disable_counter_mask(struct kvm_vcpu *vcpu, u64 val);\nvoid kvm_pmu_enable_counter_mask(struct kvm_vcpu *vcpu, u64 val);\nvoid kvm_pmu_flush_hwstate(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_sync_hwstate(struct kvm_vcpu *vcpu);\nbool kvm_pmu_should_notify_user(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_update_run(struct kvm_vcpu *vcpu);\nvoid kvm_pmu_software_increment(struct kvm_vcpu *vcpu, u64 val);\nvoid kvm_pmu_handle_pmcr(struct kvm_vcpu *vcpu, u64 val);\nvoid kvm_pmu_set_counter_event_type(struct kvm_vcpu *vcpu, u64 data,\n\t\t\t\t    u64 select_idx);\nint kvm_arm_pmu_v3_set_attr(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_device_attr *attr);\nint kvm_arm_pmu_v3_get_attr(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_device_attr *attr);\nint kvm_arm_pmu_v3_has_attr(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_device_attr *attr);\nint kvm_arm_pmu_v3_enable(struct kvm_vcpu *vcpu);\n\nstruct kvm_pmu_events *kvm_get_pmu_events(void);\nvoid kvm_vcpu_pmu_restore_guest(struct kvm_vcpu *vcpu);\nvoid kvm_vcpu_pmu_restore_host(struct kvm_vcpu *vcpu);\nvoid kvm_vcpu_pmu_resync_el0(void);\n\n#define kvm_vcpu_has_pmu(vcpu)\t\t\t\t\t\\\n\t(test_bit(KVM_ARM_VCPU_PMU_V3, (vcpu)->arch.features))\n\n \n#define kvm_pmu_update_vcpu_events(vcpu)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!has_vhe() && kvm_vcpu_has_pmu(vcpu))\t\t\\\n\t\t\tvcpu->arch.pmu.events = *kvm_get_pmu_events();\t\\\n\t} while (0)\n\n \n#define kvm_pmu_is_3p5(vcpu) ({\t\t\t\t\t\t\\\n\tu64 val = IDREG(vcpu->kvm, SYS_ID_AA64DFR0_EL1);\t\t\\\n\tu8 pmuver = SYS_FIELD_GET(ID_AA64DFR0_EL1, PMUVer, val);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tpmuver >= ID_AA64DFR0_EL1_PMUVer_V3P5;\t\t\t\t\\\n})\n\nu8 kvm_arm_pmu_get_pmuver_limit(void);\n\n#else\nstruct kvm_pmu {\n};\n\nstatic inline bool kvm_arm_support_pmu_v3(void)\n{\n\treturn false;\n}\n\n#define kvm_arm_pmu_irq_initialized(v)\t(false)\nstatic inline u64 kvm_pmu_get_counter_value(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    u64 select_idx)\n{\n\treturn 0;\n}\nstatic inline void kvm_pmu_set_counter_value(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     u64 select_idx, u64 val) {}\nstatic inline u64 kvm_pmu_valid_counter_mask(struct kvm_vcpu *vcpu)\n{\n\treturn 0;\n}\nstatic inline void kvm_pmu_vcpu_init(struct kvm_vcpu *vcpu) {}\nstatic inline void kvm_pmu_vcpu_reset(struct kvm_vcpu *vcpu) {}\nstatic inline void kvm_pmu_vcpu_destroy(struct kvm_vcpu *vcpu) {}\nstatic inline void kvm_pmu_disable_counter_mask(struct kvm_vcpu *vcpu, u64 val) {}\nstatic inline void kvm_pmu_enable_counter_mask(struct kvm_vcpu *vcpu, u64 val) {}\nstatic inline void kvm_pmu_flush_hwstate(struct kvm_vcpu *vcpu) {}\nstatic inline void kvm_pmu_sync_hwstate(struct kvm_vcpu *vcpu) {}\nstatic inline bool kvm_pmu_should_notify_user(struct kvm_vcpu *vcpu)\n{\n\treturn false;\n}\nstatic inline void kvm_pmu_update_run(struct kvm_vcpu *vcpu) {}\nstatic inline void kvm_pmu_software_increment(struct kvm_vcpu *vcpu, u64 val) {}\nstatic inline void kvm_pmu_handle_pmcr(struct kvm_vcpu *vcpu, u64 val) {}\nstatic inline void kvm_pmu_set_counter_event_type(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t  u64 data, u64 select_idx) {}\nstatic inline int kvm_arm_pmu_v3_set_attr(struct kvm_vcpu *vcpu,\n\t\t\t\t\t  struct kvm_device_attr *attr)\n{\n\treturn -ENXIO;\n}\nstatic inline int kvm_arm_pmu_v3_get_attr(struct kvm_vcpu *vcpu,\n\t\t\t\t\t  struct kvm_device_attr *attr)\n{\n\treturn -ENXIO;\n}\nstatic inline int kvm_arm_pmu_v3_has_attr(struct kvm_vcpu *vcpu,\n\t\t\t\t\t  struct kvm_device_attr *attr)\n{\n\treturn -ENXIO;\n}\nstatic inline int kvm_arm_pmu_v3_enable(struct kvm_vcpu *vcpu)\n{\n\treturn 0;\n}\nstatic inline u64 kvm_pmu_get_pmceid(struct kvm_vcpu *vcpu, bool pmceid1)\n{\n\treturn 0;\n}\n\n#define kvm_vcpu_has_pmu(vcpu)\t\t({ false; })\n#define kvm_pmu_is_3p5(vcpu)\t\t({ false; })\nstatic inline void kvm_pmu_update_vcpu_events(struct kvm_vcpu *vcpu) {}\nstatic inline void kvm_vcpu_pmu_restore_guest(struct kvm_vcpu *vcpu) {}\nstatic inline void kvm_vcpu_pmu_restore_host(struct kvm_vcpu *vcpu) {}\nstatic inline u8 kvm_arm_pmu_get_pmuver_limit(void)\n{\n\treturn 0;\n}\nstatic inline void kvm_vcpu_pmu_resync_el0(void) {}\n\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}