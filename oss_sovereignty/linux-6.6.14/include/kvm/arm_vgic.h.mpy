{
  "module_name": "arm_vgic.h",
  "hash_id": "287ad7cafb285316830351e79a61709871102d6cca7316af217ba73b7ca7e8b8",
  "original_prompt": "Ingested from linux-6.6.14/include/kvm/arm_vgic.h",
  "human_readable_source": " \n \n#ifndef __KVM_ARM_VGIC_H\n#define __KVM_ARM_VGIC_H\n\n#include <linux/bits.h>\n#include <linux/kvm.h>\n#include <linux/irqreturn.h>\n#include <linux/kref.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/static_key.h>\n#include <linux/types.h>\n#include <kvm/iodev.h>\n#include <linux/list.h>\n#include <linux/jump_label.h>\n\n#include <linux/irqchip/arm-gic-v4.h>\n\n#define VGIC_V3_MAX_CPUS\t512\n#define VGIC_V2_MAX_CPUS\t8\n#define VGIC_NR_IRQS_LEGACY     256\n#define VGIC_NR_SGIS\t\t16\n#define VGIC_NR_PPIS\t\t16\n#define VGIC_NR_PRIVATE_IRQS\t(VGIC_NR_SGIS + VGIC_NR_PPIS)\n#define VGIC_MAX_PRIVATE\t(VGIC_NR_PRIVATE_IRQS - 1)\n#define VGIC_MAX_SPI\t\t1019\n#define VGIC_MAX_RESERVED\t1023\n#define VGIC_MIN_LPI\t\t8192\n#define KVM_IRQCHIP_NUM_PINS\t(1020 - 32)\n\n#define irq_is_ppi(irq) ((irq) >= VGIC_NR_SGIS && (irq) < VGIC_NR_PRIVATE_IRQS)\n#define irq_is_spi(irq) ((irq) >= VGIC_NR_PRIVATE_IRQS && \\\n\t\t\t (irq) <= VGIC_MAX_SPI)\n\nenum vgic_type {\n\tVGIC_V2,\t\t \n\tVGIC_V3,\t\t \n};\n\n \nstruct vgic_global {\n\t \n\tenum vgic_type\t\ttype;\n\n\t \n\tphys_addr_t\t\tvcpu_base;\n\n\t \n\tvoid __iomem\t\t*vcpu_base_va;\n\t \n\tvoid __iomem\t\t*vcpu_hyp_va;\n\n\t \n\tvoid __iomem\t\t*vctrl_base;\n\t \n\tvoid __iomem\t\t*vctrl_hyp;\n\n\t \n\tint\t\t\tnr_lr;\n\n\t \n\tunsigned int\t\tmaint_irq;\n\n\t \n\tint\t\t\tmax_gic_vcpus;\n\n\t \n\tbool\t\t\tcan_emulate_gicv2;\n\n\t \n\tbool\t\t\thas_gicv4;\n\tbool\t\t\thas_gicv4_1;\n\n\t \n\tbool\t\t\tno_hw_deactivation;\n\n\t \n\tstruct static_key_false gicv3_cpuif;\n\n\tu32\t\t\tich_vtr_el2;\n};\n\nextern struct vgic_global kvm_vgic_global_state;\n\n#define VGIC_V2_MAX_LRS\t\t(1 << 6)\n#define VGIC_V3_MAX_LRS\t\t16\n#define VGIC_V3_LR_INDEX(lr)\t(VGIC_V3_MAX_LRS - 1 - lr)\n\nenum vgic_irq_config {\n\tVGIC_CONFIG_EDGE = 0,\n\tVGIC_CONFIG_LEVEL\n};\n\n \nstruct irq_ops {\n\t \n\tunsigned long flags;\n\n#define VGIC_IRQ_SW_RESAMPLE\tBIT(0)\t \n\n\t \n\tbool (*get_input_level)(int vintid);\n};\n\nstruct vgic_irq {\n\traw_spinlock_t irq_lock;\t \n\tstruct list_head lpi_list;\t \n\tstruct list_head ap_list;\n\n\tstruct kvm_vcpu *vcpu;\t\t \n\n\tstruct kvm_vcpu *target_vcpu;\t \n\n\tu32 intid;\t\t\t \n\tbool line_level;\t\t \n\tbool pending_latch;\t\t \n\tbool active;\t\t\t \n\tbool enabled;\n\tbool hw;\t\t\t \n\tstruct kref refcount;\t\t \n\tu32 hwintid;\t\t\t \n\tunsigned int host_irq;\t\t \n\tunion {\n\t\tu8 targets;\t\t\t \n\t\tu32 mpidr;\t\t\t \n\t};\n\tu8 source;\t\t\t \n\tu8 active_source;\t\t \n\tu8 priority;\n\tu8 group;\t\t\t \n\tenum vgic_irq_config config;\t \n\n\tstruct irq_ops *ops;\n\n\tvoid *owner;\t\t\t \n};\n\nstatic inline bool vgic_irq_needs_resampling(struct vgic_irq *irq)\n{\n\treturn irq->ops && (irq->ops->flags & VGIC_IRQ_SW_RESAMPLE);\n}\n\nstruct vgic_register_region;\nstruct vgic_its;\n\nenum iodev_type {\n\tIODEV_CPUIF,\n\tIODEV_DIST,\n\tIODEV_REDIST,\n\tIODEV_ITS\n};\n\nstruct vgic_io_device {\n\tgpa_t base_addr;\n\tunion {\n\t\tstruct kvm_vcpu *redist_vcpu;\n\t\tstruct vgic_its *its;\n\t};\n\tconst struct vgic_register_region *regions;\n\tenum iodev_type iodev_type;\n\tint nr_regions;\n\tstruct kvm_io_device dev;\n};\n\nstruct vgic_its {\n\t \n\tgpa_t\t\t\tvgic_its_base;\n\n\tbool\t\t\tenabled;\n\tstruct vgic_io_device\tiodev;\n\tstruct kvm_device\t*dev;\n\n\t \n\tu64\t\t\tbaser_device_table;\n\tu64\t\t\tbaser_coll_table;\n\n\t \n\tstruct mutex\t\tcmd_lock;\n\tu64\t\t\tcbaser;\n\tu32\t\t\tcreadr;\n\tu32\t\t\tcwriter;\n\n\t \n\tu32\t\t\tabi_rev;\n\n\t \n\tstruct mutex\t\tits_lock;\n\tstruct list_head\tdevice_list;\n\tstruct list_head\tcollection_list;\n};\n\nstruct vgic_state_iter;\n\nstruct vgic_redist_region {\n\tu32 index;\n\tgpa_t base;\n\tu32 count;  \n\tu32 free_index;  \n\tstruct list_head list;\n};\n\nstruct vgic_dist {\n\tbool\t\t\tin_kernel;\n\tbool\t\t\tready;\n\tbool\t\t\tinitialized;\n\n\t \n\tu32\t\t\tvgic_model;\n\n\t \n\tu32\t\t\timplementation_rev;\n#define KVM_VGIC_IMP_REV_2\t2  \n#define KVM_VGIC_IMP_REV_3\t3  \n#define KVM_VGIC_IMP_REV_LATEST\tKVM_VGIC_IMP_REV_3\n\n\t \n\tbool\t\t\tv2_groups_user_writable;\n\n\t \n\tbool\t\t\tmsis_require_devid;\n\n\tint\t\t\tnr_spis;\n\n\t \n\tgpa_t\t\t\tvgic_dist_base;\t\t \n\tunion {\n\t\t \n\t\tgpa_t\t\t\tvgic_cpu_base;\n\t\t \n\t\tstruct list_head rd_regions;\n\t};\n\n\t \n\tbool\t\t\tenabled;\n\n\t \n\tbool\t\t\tnassgireq;\n\n\tstruct vgic_irq\t\t*spis;\n\n\tstruct vgic_io_device\tdist_iodev;\n\n\tbool\t\t\thas_its;\n\tbool\t\t\ttable_write_in_progress;\n\n\t \n\tu64\t\t\tpropbaser;\n\n\t \n\traw_spinlock_t\t\tlpi_list_lock;\n\tstruct list_head\tlpi_list_head;\n\tint\t\t\tlpi_list_count;\n\n\t \n\tstruct list_head\tlpi_translation_cache;\n\n\t \n\tstruct vgic_state_iter *iter;\n\n\t \n\tstruct its_vm\t\tits_vm;\n};\n\nstruct vgic_v2_cpu_if {\n\tu32\t\tvgic_hcr;\n\tu32\t\tvgic_vmcr;\n\tu32\t\tvgic_apr;\n\tu32\t\tvgic_lr[VGIC_V2_MAX_LRS];\n\n\tunsigned int used_lrs;\n};\n\nstruct vgic_v3_cpu_if {\n\tu32\t\tvgic_hcr;\n\tu32\t\tvgic_vmcr;\n\tu32\t\tvgic_sre;\t \n\tu32\t\tvgic_ap0r[4];\n\tu32\t\tvgic_ap1r[4];\n\tu64\t\tvgic_lr[VGIC_V3_MAX_LRS];\n\n\t \n\tstruct its_vpe\tits_vpe;\n\n\tunsigned int used_lrs;\n};\n\nstruct vgic_cpu {\n\t \n\tunion {\n\t\tstruct vgic_v2_cpu_if\tvgic_v2;\n\t\tstruct vgic_v3_cpu_if\tvgic_v3;\n\t};\n\n\tstruct vgic_irq private_irqs[VGIC_NR_PRIVATE_IRQS];\n\n\traw_spinlock_t ap_list_lock;\t \n\n\t \n\tstruct list_head ap_list_head;\n\n\t \n\tstruct vgic_io_device\trd_iodev;\n\tstruct vgic_redist_region *rdreg;\n\tu32 rdreg_index;\n\tatomic_t syncr_busy;\n\n\t \n\tu64 pendbaser;\n\t \n\tatomic_t ctlr;\n\n\t \n\tu32 num_pri_bits;\n\n\t \n\tu32 num_id_bits;\n};\n\nextern struct static_key_false vgic_v2_cpuif_trap;\nextern struct static_key_false vgic_v3_cpuif_trap;\n\nint kvm_set_legacy_vgic_v2_addr(struct kvm *kvm, struct kvm_arm_device_addr *dev_addr);\nvoid kvm_vgic_early_init(struct kvm *kvm);\nint kvm_vgic_vcpu_init(struct kvm_vcpu *vcpu);\nint kvm_vgic_create(struct kvm *kvm, u32 type);\nvoid kvm_vgic_destroy(struct kvm *kvm);\nvoid kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu);\nint kvm_vgic_map_resources(struct kvm *kvm);\nint kvm_vgic_hyp_init(void);\nvoid kvm_vgic_init_cpu_hardware(void);\n\nint kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int intid,\n\t\t\tbool level, void *owner);\nint kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu, unsigned int host_irq,\n\t\t\t  u32 vintid, struct irq_ops *ops);\nint kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, unsigned int vintid);\nint kvm_vgic_get_map(struct kvm_vcpu *vcpu, unsigned int vintid);\nbool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int vintid);\n\nint kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);\n\nvoid kvm_vgic_load(struct kvm_vcpu *vcpu);\nvoid kvm_vgic_put(struct kvm_vcpu *vcpu);\nvoid kvm_vgic_vmcr_sync(struct kvm_vcpu *vcpu);\n\n#define irqchip_in_kernel(k)\t(!!((k)->arch.vgic.in_kernel))\n#define vgic_initialized(k)\t((k)->arch.vgic.initialized)\n#define vgic_ready(k)\t\t((k)->arch.vgic.ready)\n#define vgic_valid_spi(k, i)\t(((i) >= VGIC_NR_PRIVATE_IRQS) && \\\n\t\t\t((i) < (k)->arch.vgic.nr_spis + VGIC_NR_PRIVATE_IRQS))\n\nbool kvm_vcpu_has_pending_irqs(struct kvm_vcpu *vcpu);\nvoid kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);\nvoid kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);\nvoid kvm_vgic_reset_mapped_irq(struct kvm_vcpu *vcpu, u32 vintid);\n\nvoid vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg, bool allow_group1);\n\n \nstatic inline int kvm_vgic_get_max_vcpus(void)\n{\n\treturn kvm_vgic_global_state.max_gic_vcpus;\n}\n\n \nint kvm_vgic_setup_default_irq_routing(struct kvm *kvm);\n\nint kvm_vgic_set_owner(struct kvm_vcpu *vcpu, unsigned int intid, void *owner);\n\nstruct kvm_kernel_irq_routing_entry;\n\nint kvm_vgic_v4_set_forwarding(struct kvm *kvm, int irq,\n\t\t\t       struct kvm_kernel_irq_routing_entry *irq_entry);\n\nint kvm_vgic_v4_unset_forwarding(struct kvm *kvm, int irq,\n\t\t\t\t struct kvm_kernel_irq_routing_entry *irq_entry);\n\nint vgic_v4_load(struct kvm_vcpu *vcpu);\nvoid vgic_v4_commit(struct kvm_vcpu *vcpu);\nint vgic_v4_put(struct kvm_vcpu *vcpu);\n\n \nvoid kvm_vgic_cpu_up(void);\nvoid kvm_vgic_cpu_down(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}