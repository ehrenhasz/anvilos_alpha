{
  "module_name": "arm_arch_timer.h",
  "hash_id": "cbabf44e188e14863da22b3d8811171eb41b60ed5edbc21a43449414028d01eb",
  "original_prompt": "Ingested from linux-6.6.14/include/kvm/arm_arch_timer.h",
  "human_readable_source": " \n \n\n#ifndef __ASM_ARM_KVM_ARCH_TIMER_H\n#define __ASM_ARM_KVM_ARCH_TIMER_H\n\n#include <linux/clocksource.h>\n#include <linux/hrtimer.h>\n\nenum kvm_arch_timers {\n\tTIMER_PTIMER,\n\tTIMER_VTIMER,\n\tNR_KVM_EL0_TIMERS,\n\tTIMER_HVTIMER = NR_KVM_EL0_TIMERS,\n\tTIMER_HPTIMER,\n\tNR_KVM_TIMERS\n};\n\nenum kvm_arch_timer_regs {\n\tTIMER_REG_CNT,\n\tTIMER_REG_CVAL,\n\tTIMER_REG_TVAL,\n\tTIMER_REG_CTL,\n\tTIMER_REG_VOFF,\n};\n\nstruct arch_timer_offset {\n\t \n\tu64\t*vm_offset;\n\t \n\tu64\t*vcpu_offset;\n};\n\nstruct arch_timer_vm_data {\n\t \n\tu64\tvoffset;\n\t \n\tu64\tpoffset;\n\n\t \n\tu8\tppi[NR_KVM_TIMERS];\n};\n\nstruct arch_timer_context {\n\tstruct kvm_vcpu\t\t\t*vcpu;\n\n\t \n\tstruct hrtimer\t\t\thrtimer;\n\tu64\t\t\t\tns_frac;\n\n\t \n\tstruct arch_timer_offset\toffset;\n\t \n\tbool\t\t\t\tloaded;\n\n\t \n\tstruct {\n\t\tbool\t\t\tlevel;\n\t} irq;\n\n\t \n\tu32\t\t\t\thost_timer_irq;\n};\n\nstruct timer_map {\n\tstruct arch_timer_context *direct_vtimer;\n\tstruct arch_timer_context *direct_ptimer;\n\tstruct arch_timer_context *emul_vtimer;\n\tstruct arch_timer_context *emul_ptimer;\n};\n\nvoid get_timer_map(struct kvm_vcpu *vcpu, struct timer_map *map);\n\nstruct arch_timer_cpu {\n\tstruct arch_timer_context timers[NR_KVM_TIMERS];\n\n\t \n\tstruct hrtimer\t\t\tbg_timer;\n\n\t \n\tbool\t\t\tenabled;\n};\n\nint __init kvm_timer_hyp_init(bool has_gic);\nint kvm_timer_enable(struct kvm_vcpu *vcpu);\nint kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu);\nvoid kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);\nvoid kvm_timer_sync_user(struct kvm_vcpu *vcpu);\nbool kvm_timer_should_notify_user(struct kvm_vcpu *vcpu);\nvoid kvm_timer_update_run(struct kvm_vcpu *vcpu);\nvoid kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu);\n\nvoid kvm_timer_init_vm(struct kvm *kvm);\n\nu64 kvm_arm_timer_get_reg(struct kvm_vcpu *, u64 regid);\nint kvm_arm_timer_set_reg(struct kvm_vcpu *, u64 regid, u64 value);\n\nint kvm_arm_timer_set_attr(struct kvm_vcpu *vcpu, struct kvm_device_attr *attr);\nint kvm_arm_timer_get_attr(struct kvm_vcpu *vcpu, struct kvm_device_attr *attr);\nint kvm_arm_timer_has_attr(struct kvm_vcpu *vcpu, struct kvm_device_attr *attr);\n\nu64 kvm_phys_timer_read(void);\n\nvoid kvm_timer_vcpu_load(struct kvm_vcpu *vcpu);\nvoid kvm_timer_vcpu_put(struct kvm_vcpu *vcpu);\n\nvoid kvm_timer_init_vhe(void);\n\n#define vcpu_timer(v)\t(&(v)->arch.timer_cpu)\n#define vcpu_get_timer(v,t)\t(&vcpu_timer(v)->timers[(t)])\n#define vcpu_vtimer(v)\t(&(v)->arch.timer_cpu.timers[TIMER_VTIMER])\n#define vcpu_ptimer(v)\t(&(v)->arch.timer_cpu.timers[TIMER_PTIMER])\n#define vcpu_hvtimer(v)\t(&(v)->arch.timer_cpu.timers[TIMER_HVTIMER])\n#define vcpu_hptimer(v)\t(&(v)->arch.timer_cpu.timers[TIMER_HPTIMER])\n\n#define arch_timer_ctx_index(ctx)\t((ctx) - vcpu_timer((ctx)->vcpu)->timers)\n\n#define timer_vm_data(ctx)\t\t(&(ctx)->vcpu->kvm->arch.timer_data)\n#define timer_irq(ctx)\t\t\t(timer_vm_data(ctx)->ppi[arch_timer_ctx_index(ctx)])\n\nu64 kvm_arm_timer_read_sysreg(struct kvm_vcpu *vcpu,\n\t\t\t      enum kvm_arch_timers tmr,\n\t\t\t      enum kvm_arch_timer_regs treg);\nvoid kvm_arm_timer_write_sysreg(struct kvm_vcpu *vcpu,\n\t\t\t\tenum kvm_arch_timers tmr,\n\t\t\t\tenum kvm_arch_timer_regs treg,\n\t\t\t\tu64 val);\n\n \nu32 timer_get_ctl(struct arch_timer_context *ctxt);\nu64 timer_get_cval(struct arch_timer_context *ctxt);\n\n \nvoid kvm_timer_cpu_up(void);\nvoid kvm_timer_cpu_down(void);\n\nstatic inline bool has_cntpoff(void)\n{\n\treturn (has_vhe() && cpus_have_final_cap(ARM64_HAS_ECV_CNTPOFF));\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}