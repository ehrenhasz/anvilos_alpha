{
  "module_name": "target_core_base.h",
  "hash_id": "5115faedfbb9f2dd2dd7419a60c991991cd0616e6030919d34d42cde46f04c11",
  "original_prompt": "Ingested from linux-6.6.14/include/target/target_core_base.h",
  "human_readable_source": " \n#ifndef TARGET_CORE_BASE_H\n#define TARGET_CORE_BASE_H\n\n#include <linux/configfs.h>       \n#include <linux/dma-direction.h>  \n#include <linux/sbitmap.h>\n#include <linux/percpu-refcount.h>\n#include <linux/semaphore.h>      \n#include <linux/completion.h>\n\n#define TARGET_CORE_VERSION\t\t\"v5.0\"\n\n \n#define TCM_MAX_COMMAND_SIZE\t\t\t32\n \n#define TRANSPORT_SENSE_BUFFER\t\t\t96\n \n#define SPC_SENSE_KEY_OFFSET\t\t\t2\n#define SPC_ADD_SENSE_LEN_OFFSET\t\t7\n#define SPC_DESC_TYPE_OFFSET\t\t\t8\n#define SPC_ADDITIONAL_DESC_LEN_OFFSET\t\t9\n#define SPC_VALIDITY_OFFSET\t\t\t10\n#define SPC_ASC_KEY_OFFSET\t\t\t12\n#define SPC_ASCQ_KEY_OFFSET\t\t\t13\n#define TRANSPORT_IQN_LEN\t\t\t224\n \n#define LU_GROUP_NAME_BUF\t\t\t256\n \n#define TG_PT_GROUP_NAME_BUF\t\t\t256\n \n#define VPD_TMP_BUF_SIZE\t\t\t254\n \n#define READ_BLOCK_LEN          \t\t6\n#define READ_CAP_LEN            \t\t8\n#define READ_POSITION_LEN       \t\t20\n#define INQUIRY_LEN\t\t\t\t36\n \n#define INQUIRY_VPD_SERIAL_LEN\t\t\t254\n \n#define INQUIRY_VPD_DEVICE_IDENTIFIER_LEN\t254\n\n#define INQUIRY_VENDOR_LEN\t\t\t8\n#define INQUIRY_MODEL_LEN\t\t\t16\n#define INQUIRY_REVISION_LEN\t\t\t4\n\n \n#define PYX_TRANSPORT_WINDOW_CLOSED_THRESHOLD\t3\n#define PYX_TRANSPORT_WINDOW_CLOSED_WAIT_SHORT\t3   \n#define PYX_TRANSPORT_WINDOW_CLOSED_WAIT_LONG\t10  \n\n#define PYX_TRANSPORT_STATUS_INTERVAL\t\t5  \n\n \n \n#define DA_MAX_UNMAP_LBA_COUNT\t\t\t0\n \n#define DA_MAX_UNMAP_BLOCK_DESC_COUNT\t\t0\n \n#define DA_UNMAP_GRANULARITY_DEFAULT\t\t0\n \n#define DA_UNMAP_GRANULARITY_ALIGNMENT_DEFAULT\t0\n \n#define DA_UNMAP_ZEROES_DATA_DEFAULT\t\t0\n \n#define DA_MAX_WRITE_SAME_LEN\t\t\t0\n \n#define DA_EMULATE_MODEL_ALIAS\t\t\t0\n \n#define DA_EMULATE_WRITE_CACHE\t\t\t0\n \n#define DA_EMULATE_TAS\t\t\t\t1\n \n#define DA_EMULATE_TPU\t\t\t\t0\n \n#define DA_EMULATE_TPWS\t\t\t\t0\n \n#define DA_EMULATE_CAW\t\t\t\t1\n \n#define DA_EMULATE_3PC\t\t\t\t1\n \n#define DA_EMULATE_ALUA\t\t\t\t0\n \n#define DA_EMULATE_PR\t\t\t\t1\n \n#define DA_EMULATE_RSOC\t\t\t\t1\n \n#define DA_ENFORCE_PR_ISIDS\t\t\t1\n \n#define DA_FORCE_PR_APTPL\t\t\t0\n#define DA_STATUS_MAX_SECTORS_MIN\t\t16\n#define DA_STATUS_MAX_SECTORS_MAX\t\t8192\n \n#define DA_IS_NONROT\t\t\t\t0\n \n#define DA_EMULATE_REST_REORD\t\t\t0\n\n#define SE_INQUIRY_BUF\t\t\t\t1024\n#define SE_MODE_PAGE_BUF\t\t\t512\n#define SE_SENSE_BUF\t\t\t\t96\n\n \nenum hba_flags_table {\n\tHBA_FLAGS_INTERNAL_USE\t= 0x01,\n\tHBA_FLAGS_PSCSI_MODE\t= 0x02,\n};\n\n \nenum transport_state_table {\n\tTRANSPORT_NO_STATE\t= 0,\n\tTRANSPORT_NEW_CMD\t= 1,\n\tTRANSPORT_WRITE_PENDING\t= 3,\n\tTRANSPORT_PROCESSING\t= 5,\n\tTRANSPORT_COMPLETE\t= 6,\n\tTRANSPORT_ISTATE_PROCESSING = 11,\n\tTRANSPORT_COMPLETE_QF_WP = 18,\n\tTRANSPORT_COMPLETE_QF_OK = 19,\n\tTRANSPORT_COMPLETE_QF_ERR = 20,\n};\n\n \nenum se_cmd_flags_table {\n\tSCF_SUPPORTED_SAM_OPCODE\t\t= (1 << 0),\n\tSCF_TRANSPORT_TASK_SENSE\t\t= (1 << 1),\n\tSCF_EMULATED_TASK_SENSE\t\t\t= (1 << 2),\n\tSCF_SCSI_DATA_CDB\t\t\t= (1 << 3),\n\tSCF_SCSI_TMR_CDB\t\t\t= (1 << 4),\n\tSCF_FUA\t\t\t\t\t= (1 << 5),\n\tSCF_SE_LUN_CMD\t\t\t\t= (1 << 6),\n\tSCF_BIDI\t\t\t\t= (1 << 7),\n\tSCF_SENT_CHECK_CONDITION\t\t= (1 << 8),\n\tSCF_OVERFLOW_BIT\t\t\t= (1 << 9),\n\tSCF_UNDERFLOW_BIT\t\t\t= (1 << 10),\n\tSCF_ALUA_NON_OPTIMIZED\t\t\t= (1 << 11),\n\tSCF_PASSTHROUGH_SG_TO_MEM_NOALLOC\t= (1 << 12),\n\tSCF_COMPARE_AND_WRITE\t\t\t= (1 << 13),\n\tSCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC\t= (1 << 14),\n\tSCF_ACK_KREF\t\t\t\t= (1 << 15),\n\tSCF_USE_CPUID\t\t\t\t= (1 << 16),\n\tSCF_TASK_ATTR_SET\t\t\t= (1 << 17),\n\tSCF_TREAT_READ_AS_NORMAL\t\t= (1 << 18),\n};\n\n \ntypedef unsigned __bitwise sense_reason_t;\n\nenum tcm_sense_reason_table {\n#define R(x)\t(__force sense_reason_t )(x)\n\tTCM_NO_SENSE\t\t\t\t= R(0x00),\n\tTCM_NON_EXISTENT_LUN\t\t\t= R(0x01),\n\tTCM_UNSUPPORTED_SCSI_OPCODE\t\t= R(0x02),\n\tTCM_INCORRECT_AMOUNT_OF_DATA\t\t= R(0x03),\n\tTCM_UNEXPECTED_UNSOLICITED_DATA\t\t= R(0x04),\n\tTCM_SERVICE_CRC_ERROR\t\t\t= R(0x05),\n\tTCM_SNACK_REJECTED\t\t\t= R(0x06),\n\tTCM_SECTOR_COUNT_TOO_MANY\t\t= R(0x07),\n\tTCM_INVALID_CDB_FIELD\t\t\t= R(0x08),\n\tTCM_INVALID_PARAMETER_LIST\t\t= R(0x09),\n\tTCM_LOGICAL_UNIT_COMMUNICATION_FAILURE\t= R(0x0a),\n\tTCM_UNKNOWN_MODE_PAGE\t\t\t= R(0x0b),\n\tTCM_WRITE_PROTECTED\t\t\t= R(0x0c),\n\tTCM_CHECK_CONDITION_ABORT_CMD\t\t= R(0x0d),\n\tTCM_CHECK_CONDITION_UNIT_ATTENTION\t= R(0x0e),\n\n\tTCM_RESERVATION_CONFLICT\t\t= R(0x10),\n\tTCM_ADDRESS_OUT_OF_RANGE\t\t= R(0x11),\n\tTCM_OUT_OF_RESOURCES\t\t\t= R(0x12),\n\tTCM_PARAMETER_LIST_LENGTH_ERROR\t\t= R(0x13),\n\tTCM_MISCOMPARE_VERIFY\t\t\t= R(0x14),\n\tTCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED\t= R(0x15),\n\tTCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED\t= R(0x16),\n\tTCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED\t= R(0x17),\n\tTCM_COPY_TARGET_DEVICE_NOT_REACHABLE\t= R(0x18),\n\tTCM_TOO_MANY_TARGET_DESCS\t\t= R(0x19),\n\tTCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE\t= R(0x1a),\n\tTCM_TOO_MANY_SEGMENT_DESCS\t\t= R(0x1b),\n\tTCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE\t= R(0x1c),\n\tTCM_INSUFFICIENT_REGISTRATION_RESOURCES\t= R(0x1d),\n\tTCM_LUN_BUSY\t\t\t\t= R(0x1e),\n\tTCM_INVALID_FIELD_IN_COMMAND_IU         = R(0x1f),\n\tTCM_ALUA_TG_PT_STANDBY\t\t\t= R(0x20),\n\tTCM_ALUA_TG_PT_UNAVAILABLE\t\t= R(0x21),\n\tTCM_ALUA_STATE_TRANSITION\t\t= R(0x22),\n\tTCM_ALUA_OFFLINE\t\t\t= R(0x23),\n#undef R\n};\n\nenum target_sc_flags_table {\n\tTARGET_SCF_BIDI_OP\t\t= 0x01,\n\tTARGET_SCF_ACK_KREF\t\t= 0x02,\n\tTARGET_SCF_UNKNOWN_SIZE\t\t= 0x04,\n\tTARGET_SCF_USE_CPUID\t\t= 0x08,\n};\n\n \nenum tcm_tmreq_table {\n\tTMR_ABORT_TASK\t\t= 1,\n\tTMR_ABORT_TASK_SET\t= 2,\n\tTMR_CLEAR_ACA\t\t= 3,\n\tTMR_CLEAR_TASK_SET\t= 4,\n\tTMR_LUN_RESET\t\t= 5,\n\tTMR_TARGET_WARM_RESET\t= 6,\n\tTMR_TARGET_COLD_RESET\t= 7,\n\tTMR_LUN_RESET_PRO\t= 0x80,\n\tTMR_UNKNOWN\t\t= 0xff,\n};\n\n \nenum tcm_tmrsp_table {\n\tTMR_FUNCTION_FAILED\t\t= 0,\n\tTMR_FUNCTION_COMPLETE\t\t= 1,\n\tTMR_TASK_DOES_NOT_EXIST\t\t= 2,\n\tTMR_LUN_DOES_NOT_EXIST\t\t= 3,\n\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED\t= 4,\n\tTMR_FUNCTION_REJECTED\t\t= 5,\n};\n\n \ntypedef enum {\n\tSCSI_INST_INDEX,\n\tSCSI_AUTH_INTR_INDEX,\n\tSCSI_INDEX_TYPE_MAX\n} scsi_index_t;\n\nstruct se_cmd;\n\nstruct t10_alua_lba_map_member {\n\tstruct list_head lba_map_mem_list;\n\tint lba_map_mem_alua_state;\n\tint lba_map_mem_alua_pg_id;\n};\n\nstruct t10_alua_lba_map {\n\tu64 lba_map_first_lba;\n\tu64 lba_map_last_lba;\n\tstruct list_head lba_map_list;\n\tstruct list_head lba_map_mem_list;\n};\n\nstruct t10_alua {\n\t \n\tu16\talua_tg_pt_gps_counter;\n\tu32\talua_tg_pt_gps_count;\n\t \n\tspinlock_t lba_map_lock;\n\tu32     lba_map_segment_size;\n\tu32     lba_map_segment_multiplier;\n\tstruct list_head lba_map_list;\n\tspinlock_t tg_pt_gps_lock;\n\tstruct se_device *t10_dev;\n\t \n\tstruct t10_alua_tg_pt_gp *default_tg_pt_gp;\n\t \n\tstruct config_group alua_tg_pt_gps_group;\n\tstruct list_head tg_pt_gps_list;\n};\n\nstruct t10_alua_lu_gp {\n\tu16\tlu_gp_id;\n\tint\tlu_gp_valid_id;\n\tu32\tlu_gp_members;\n\tatomic_t lu_gp_ref_cnt;\n\tspinlock_t lu_gp_lock;\n\tstruct config_group lu_gp_group;\n\tstruct list_head lu_gp_node;\n\tstruct list_head lu_gp_mem_list;\n};\n\nstruct t10_alua_lu_gp_member {\n\tbool lu_gp_assoc;\n\tatomic_t lu_gp_mem_ref_cnt;\n\tspinlock_t lu_gp_mem_lock;\n\tstruct t10_alua_lu_gp *lu_gp;\n\tstruct se_device *lu_gp_mem_dev;\n\tstruct list_head lu_gp_mem_list;\n};\n\nstruct t10_alua_tg_pt_gp {\n\tu16\ttg_pt_gp_id;\n\tint\ttg_pt_gp_valid_id;\n\tint\ttg_pt_gp_alua_supported_states;\n\tint\ttg_pt_gp_alua_access_status;\n\tint\ttg_pt_gp_alua_access_type;\n\tint\ttg_pt_gp_nonop_delay_msecs;\n\tint\ttg_pt_gp_trans_delay_msecs;\n\tint\ttg_pt_gp_implicit_trans_secs;\n\tint\ttg_pt_gp_pref;\n\tint\ttg_pt_gp_write_metadata;\n\tu32\ttg_pt_gp_members;\n\tint\ttg_pt_gp_alua_access_state;\n\tatomic_t tg_pt_gp_ref_cnt;\n\tspinlock_t tg_pt_gp_lock;\n\tstruct mutex tg_pt_gp_transition_mutex;\n\tstruct se_device *tg_pt_gp_dev;\n\tstruct config_group tg_pt_gp_group;\n\tstruct list_head tg_pt_gp_list;\n\tstruct list_head tg_pt_gp_lun_list;\n\tstruct se_lun *tg_pt_gp_alua_lun;\n\tstruct se_node_acl *tg_pt_gp_alua_nacl;\n};\n\nstruct t10_vpd {\n\tunsigned char device_identifier[INQUIRY_VPD_DEVICE_IDENTIFIER_LEN];\n\tint protocol_identifier_set;\n\tu32 protocol_identifier;\n\tu32 device_identifier_code_set;\n\tu32 association;\n\tu32 device_identifier_type;\n\tstruct list_head vpd_list;\n};\n\nstruct t10_wwn {\n\t \n\tchar vendor[INQUIRY_VENDOR_LEN + 1];\n\tchar model[INQUIRY_MODEL_LEN + 1];\n\tchar revision[INQUIRY_REVISION_LEN + 1];\n\tchar unit_serial[INQUIRY_VPD_SERIAL_LEN];\n\tu32 company_id;\n\tspinlock_t t10_vpd_lock;\n\tstruct se_device *t10_dev;\n\tstruct config_group t10_wwn_group;\n\tstruct list_head t10_vpd_list;\n};\n\nstruct t10_pr_registration {\n\t \n#define PR_REG_ISID_LEN\t\t\t\t16\n\t \n#define PR_REG_ISID_ID_LEN\t\t\t(PR_REG_ISID_LEN + 5)\n\tchar pr_reg_isid[PR_REG_ISID_LEN];\n\t \n#define PR_APTPL_MAX_IPORT_LEN\t\t\t256\n\tunsigned char pr_iport[PR_APTPL_MAX_IPORT_LEN];\n\t \n#define PR_APTPL_MAX_TPORT_LEN\t\t\t256\n\tunsigned char pr_tport[PR_APTPL_MAX_TPORT_LEN];\n\tu16 pr_aptpl_rpti;\n\tu16 pr_reg_tpgt;\n\t \n\tint pr_reg_all_tg_pt;\n\t \n\tint pr_reg_aptpl;\n\tint pr_res_holder;\n\tint pr_res_type;\n\tint pr_res_scope;\n\t \n\tbool isid_present_at_reg;\n\tu64 pr_res_mapped_lun;\n\tu64 pr_aptpl_target_lun;\n\tu16 tg_pt_sep_rtpi;\n\tu32 pr_res_generation;\n\tu64 pr_reg_bin_isid;\n\tu64 pr_res_key;\n\tatomic_t pr_res_holders;\n\tstruct se_node_acl *pr_reg_nacl;\n\t \n\tstruct se_dev_entry *pr_reg_deve;\n\tstruct list_head pr_reg_list;\n\tstruct list_head pr_reg_abort_list;\n\tstruct list_head pr_reg_aptpl_list;\n\tstruct list_head pr_reg_atp_list;\n\tstruct list_head pr_reg_atp_mem_list;\n};\n\nstruct t10_reservation {\n\t \n\tint pr_all_tg_pt;\n\t \n\tint pr_aptpl_active;\n#define PR_APTPL_BUF_LEN\t\t\t262144\n\tu32 pr_generation;\n\tspinlock_t registration_lock;\n\tspinlock_t aptpl_reg_lock;\n\t \n\tstruct se_node_acl *pr_res_holder;\n\tstruct list_head registration_list;\n\tstruct list_head aptpl_reg_list;\n};\n\nstruct se_tmr_req {\n\t \n\tu8\t\t\tfunction;\n\t \n\tu8\t\t\tresponse;\n\tint\t\t\tcall_transport;\n\t \n\tu64\t\t\tref_task_tag;\n\tvoid \t\t\t*fabric_tmr_ptr;\n\tstruct se_cmd\t\t*task_cmd;\n\tstruct se_device\t*tmr_dev;\n\tstruct list_head\ttmr_list;\n};\n\nenum target_prot_op {\n\tTARGET_PROT_NORMAL\t= 0,\n\tTARGET_PROT_DIN_INSERT\t= (1 << 0),\n\tTARGET_PROT_DOUT_INSERT\t= (1 << 1),\n\tTARGET_PROT_DIN_STRIP\t= (1 << 2),\n\tTARGET_PROT_DOUT_STRIP\t= (1 << 3),\n\tTARGET_PROT_DIN_PASS\t= (1 << 4),\n\tTARGET_PROT_DOUT_PASS\t= (1 << 5),\n};\n\n#define TARGET_PROT_ALL\tTARGET_PROT_DIN_INSERT | TARGET_PROT_DOUT_INSERT | \\\n\t\t\tTARGET_PROT_DIN_STRIP | TARGET_PROT_DOUT_STRIP | \\\n\t\t\tTARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS\n\nenum target_prot_type {\n\tTARGET_DIF_TYPE0_PROT,\n\tTARGET_DIF_TYPE1_PROT,\n\tTARGET_DIF_TYPE2_PROT,\n\tTARGET_DIF_TYPE3_PROT,\n};\n\n \nenum target_ua_intlck_ctrl {\n\tTARGET_UA_INTLCK_CTRL_CLEAR = 0,\n\tTARGET_UA_INTLCK_CTRL_NO_CLEAR = 1,\n\tTARGET_UA_INTLCK_CTRL_ESTABLISH_UA = 2,\n};\n\nenum target_core_dif_check {\n\tTARGET_DIF_CHECK_GUARD  = 0x1 << 0,\n\tTARGET_DIF_CHECK_APPTAG = 0x1 << 1,\n\tTARGET_DIF_CHECK_REFTAG = 0x1 << 2,\n};\n\n \n#define TCM_SIMPLE_TAG\t0x20\n#define TCM_HEAD_TAG\t0x21\n#define TCM_ORDERED_TAG\t0x22\n#define TCM_ACA_TAG\t0x24\n\nstruct se_cmd {\n\t \n\tsense_reason_t\t\tsense_reason;\n\t \n\tu8\t\t\tscsi_status;\n\tu16\t\t\tscsi_sense_length;\n\tunsigned\t\tunknown_data_length:1;\n\tbool\t\t\tstate_active:1;\n\tu64\t\t\ttag;  \n\t \n\tint\t\t\talua_nonop_delay;\n\t \n\tenum dma_data_direction\tdata_direction;\n\t \n\tint\t\t\tsam_task_attr;\n\t \n\tunsigned int\t\tmap_tag;\n\tint\t\t\tmap_cpu;\n\t \n\tenum transport_state_table t_state;\n\t \n\tu32\t\t\tse_cmd_flags;\n\t \n\tu32\t\t\tdata_length;\n\tu32\t\t\tresidual_count;\n\tu64\t\t\torig_fe_lun;\n\t \n\tu64\t\t\tpr_res_key;\n\t \n\tvoid\t\t\t*sense_buffer;\n\tstruct list_head\tse_delayed_node;\n\tstruct list_head\tse_qf_node;\n\tstruct se_device      *se_dev;\n\tstruct se_lun\t\t*se_lun;\n\t \n\tstruct se_session\t*se_sess;\n\tstruct target_cmd_counter *cmd_cnt;\n\tstruct se_tmr_req\t*se_tmr_req;\n\tstruct llist_node\tse_cmd_list;\n\tstruct completion\t*free_compl;\n\tstruct completion\t*abrt_compl;\n\tconst struct target_core_fabric_ops *se_tfo;\n\tsense_reason_t\t\t(*execute_cmd)(struct se_cmd *);\n\tsense_reason_t (*transport_complete_callback)(struct se_cmd *, bool, int *);\n\tvoid\t\t\t*protocol_data;\n\n\tunsigned char\t\t*t_task_cdb;\n\tunsigned char\t\t__t_task_cdb[TCM_MAX_COMMAND_SIZE];\n\tunsigned long long\tt_task_lba;\n\tunsigned int\t\tt_task_nolb;\n\tunsigned int\t\ttransport_state;\n#define CMD_T_ABORTED\t\t(1 << 0)\n#define CMD_T_ACTIVE\t\t(1 << 1)\n#define CMD_T_COMPLETE\t\t(1 << 2)\n#define CMD_T_SENT\t\t(1 << 4)\n#define CMD_T_STOP\t\t(1 << 5)\n#define CMD_T_TAS\t\t(1 << 10)\n#define CMD_T_FABRIC_STOP\t(1 << 11)\n\tspinlock_t\t\tt_state_lock;\n\tstruct kref\t\tcmd_kref;\n\tstruct completion\tt_transport_stop_comp;\n\n\tstruct work_struct\twork;\n\n\tstruct scatterlist\t*t_data_sg;\n\tstruct scatterlist\t*t_data_sg_orig;\n\tunsigned int\t\tt_data_nents;\n\tunsigned int\t\tt_data_nents_orig;\n\tvoid\t\t\t*t_data_vmap;\n\tstruct scatterlist\t*t_bidi_data_sg;\n\tunsigned int\t\tt_bidi_data_nents;\n\n\t \n\tint\t\t\tlun_ref_active;\n\n\tstruct list_head\tstate_list;\n\n\t \n\tvoid\t\t\t*priv;\n\n\t \n\tenum target_prot_op\tprot_op;\n\tenum target_prot_type\tprot_type;\n\tu8\t\t\tprot_checks;\n\tbool\t\t\tprot_pto;\n\tu32\t\t\tprot_length;\n\tu32\t\t\treftag_seed;\n\tstruct scatterlist\t*t_prot_sg;\n\tunsigned int\t\tt_prot_nents;\n\tsense_reason_t\t\tpi_err;\n\tu64\t\t\tsense_info;\n\t \n\tint\t\t\tcpuid;\n};\n\nstruct se_ua {\n\tu8\t\t\tua_asc;\n\tu8\t\t\tua_ascq;\n\tstruct list_head\tua_nacl_list;\n};\n\nstruct se_node_acl {\n\tchar\t\t\tinitiatorname[TRANSPORT_IQN_LEN];\n\t \n\tbool\t\t\tdynamic_node_acl;\n\tbool\t\t\tdynamic_stop;\n\tu32\t\t\tqueue_depth;\n\tu32\t\t\tacl_index;\n\tenum target_prot_type\tsaved_prot_type;\n#define MAX_ACL_TAG_SIZE 64\n\tchar\t\t\tacl_tag[MAX_ACL_TAG_SIZE];\n\t \n\tatomic_t\t\tacl_pr_ref_count;\n\tstruct hlist_head\tlun_entry_hlist;\n\tstruct se_session\t*nacl_sess;\n\tstruct se_portal_group *se_tpg;\n\tstruct mutex\t\tlun_entry_mutex;\n\tspinlock_t\t\tnacl_sess_lock;\n\tstruct config_group\tacl_group;\n\tstruct config_group\tacl_attrib_group;\n\tstruct config_group\tacl_auth_group;\n\tstruct config_group\tacl_param_group;\n\tstruct config_group\tacl_fabric_stat_group;\n\tstruct list_head\tacl_list;\n\tstruct list_head\tacl_sess_list;\n\tstruct completion\tacl_free_comp;\n\tstruct kref\t\tacl_kref;\n};\n\nstatic inline struct se_node_acl *acl_to_nacl(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_node_acl,\n\t\t\tacl_group);\n}\n\nstatic inline struct se_node_acl *attrib_to_nacl(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_node_acl,\n\t\t\tacl_attrib_group);\n}\n\nstatic inline struct se_node_acl *auth_to_nacl(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_node_acl,\n\t\t\tacl_auth_group);\n}\n\nstatic inline struct se_node_acl *param_to_nacl(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_node_acl,\n\t\t\tacl_param_group);\n}\n\nstatic inline struct se_node_acl *fabric_stat_to_nacl(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_node_acl,\n\t\t\tacl_fabric_stat_group);\n}\n\nstruct target_cmd_counter {\n\tstruct percpu_ref\trefcnt;\n\twait_queue_head_t\trefcnt_wq;\n\tstruct completion\tstop_done;\n\tatomic_t\t\tstopped;\n};\n\nstruct se_session {\n\tu64\t\t\tsess_bin_isid;\n\tenum target_prot_op\tsup_prot_ops;\n\tenum target_prot_type\tsess_prot_type;\n\tstruct se_node_acl\t*se_node_acl;\n\tstruct se_portal_group *se_tpg;\n\tvoid\t\t\t*fabric_sess_ptr;\n\tstruct list_head\tsess_list;\n\tstruct list_head\tsess_acl_list;\n\tspinlock_t\t\tsess_cmd_lock;\n\tvoid\t\t\t*sess_cmd_map;\n\tstruct sbitmap_queue\tsess_tag_pool;\n\tstruct target_cmd_counter *cmd_cnt;\n};\n\nstruct se_device;\nstruct se_transform_info;\nstruct scatterlist;\n\nstruct se_ml_stat_grps {\n\tstruct config_group\tstat_group;\n\tstruct config_group\tscsi_auth_intr_group;\n\tstruct config_group\tscsi_att_intr_port_group;\n};\n\nstruct se_lun_acl {\n\tu64\t\t\tmapped_lun;\n\tstruct se_node_acl\t*se_lun_nacl;\n\tstruct se_lun\t\t*se_lun;\n\tstruct config_group\tse_lun_group;\n\tstruct se_ml_stat_grps\tml_stat_grps;\n};\n\nstruct se_dev_entry {\n\tu64\t\t\tmapped_lun;\n\tu64\t\t\tpr_res_key;\n\tu64\t\t\tcreation_time;\n\tbool\t\t\tlun_access_ro;\n\tu32\t\t\tattach_count;\n\tatomic_long_t\t\ttotal_cmds;\n\tatomic_long_t\t\tread_bytes;\n\tatomic_long_t\t\twrite_bytes;\n\t \n\tstruct kref\t\tpr_kref;\n\tstruct completion\tpr_comp;\n\tstruct se_lun_acl\t*se_lun_acl;\n\tspinlock_t\t\tua_lock;\n\tstruct se_lun\t\t*se_lun;\n#define DEF_PR_REG_ACTIVE\t\t1\n\tunsigned long\t\tdeve_flags;\n\tstruct list_head\talua_port_list;\n\tstruct list_head\tlun_link;\n\tstruct list_head\tua_list;\n\tstruct hlist_node\tlink;\n\tstruct rcu_head\t\trcu_head;\n};\n\nstruct se_dev_attrib {\n\tbool\t\temulate_model_alias;\n\tbool\t\temulate_dpo;\t\t \n\tbool\t\temulate_fua_write;\n\tbool\t\temulate_fua_read;\t \n\tbool\t\temulate_write_cache;\n\tenum target_ua_intlck_ctrl emulate_ua_intlck_ctrl;\n\tbool\t\temulate_tas;\n\tbool\t\temulate_tpu;\n\tbool\t\temulate_tpws;\n\tbool\t\temulate_caw;\n\tbool\t\temulate_3pc;\n\tbool\t\temulate_pr;\n\tbool\t\temulate_rsoc;\n\tenum target_prot_type pi_prot_type;\n\tenum target_prot_type hw_pi_prot_type;\n\tbool\t\tpi_prot_verify;\n\tbool\t\tenforce_pr_isids;\n\tbool\t\tforce_pr_aptpl;\n\tbool\t\tis_nonrot;\n\tbool\t\temulate_rest_reord;\n\tbool\t\tunmap_zeroes_data;\n\tu32\t\thw_block_size;\n\tu32\t\tblock_size;\n\tu32\t\thw_max_sectors;\n\tu32\t\toptimal_sectors;\n\tu32\t\thw_queue_depth;\n\tu32\t\tqueue_depth;\n\tu32\t\tmax_unmap_lba_count;\n\tu32\t\tmax_unmap_block_desc_count;\n\tu32\t\tunmap_granularity;\n\tu32\t\tunmap_granularity_alignment;\n\tu32\t\tmax_write_same_len;\n\tstruct se_device *da_dev;\n\tstruct config_group da_group;\n};\n\nstruct se_port_stat_grps {\n\tstruct config_group stat_group;\n\tstruct config_group scsi_port_group;\n\tstruct config_group scsi_tgt_port_group;\n\tstruct config_group scsi_transport_group;\n};\n\nstruct scsi_port_stats {\n\tatomic_long_t\tcmd_pdus;\n\tatomic_long_t\ttx_data_octets;\n\tatomic_long_t\trx_data_octets;\n};\n\nstruct se_lun {\n\tu64\t\t\tunpacked_lun;\n\tbool\t\t\tlun_shutdown;\n\tbool\t\t\tlun_access_ro;\n\tu32\t\t\tlun_index;\n\n\tatomic_t\t\tlun_acl_count;\n\tstruct se_device __rcu\t*lun_se_dev;\n\n\tstruct list_head\tlun_deve_list;\n\tspinlock_t\t\tlun_deve_lock;\n\n\t \n\tint\t\t\tlun_tg_pt_secondary_stat;\n\tint\t\t\tlun_tg_pt_secondary_write_md;\n\tatomic_t\t\tlun_tg_pt_secondary_offline;\n\tstruct mutex\t\tlun_tg_pt_md_mutex;\n\n\t \n\tstruct list_head\tlun_tg_pt_gp_link;\n\tstruct t10_alua_tg_pt_gp __rcu *lun_tg_pt_gp;\n\tspinlock_t\t\tlun_tg_pt_gp_lock;\n\n\tstruct se_portal_group\t*lun_tpg;\n\tstruct scsi_port_stats\tlun_stats;\n\tstruct config_group\tlun_group;\n\tstruct se_port_stat_grps port_stat_grps;\n\tstruct completion\tlun_shutdown_comp;\n\tstruct percpu_ref\tlun_ref;\n\tstruct list_head\tlun_dev_link;\n\tstruct hlist_node\tlink;\n\tstruct rcu_head\t\trcu_head;\n};\n\nstruct se_dev_stat_grps {\n\tstruct config_group stat_group;\n\tstruct config_group scsi_dev_group;\n\tstruct config_group scsi_tgt_dev_group;\n\tstruct config_group scsi_lu_group;\n};\n\nstruct se_cmd_queue {\n\tstruct llist_head\tcmd_list;\n\tstruct work_struct\twork;\n};\n\nstruct se_dev_plug {\n\tstruct se_device\t*se_dev;\n};\n\nstruct se_device_queue {\n\tstruct list_head\tstate_list;\n\tspinlock_t\t\tlock;\n\tstruct se_cmd_queue\tsq;\n};\n\nstruct se_device {\n\t \n\tu32\t\t\tdev_cur_ordered_id;\n\tu32\t\t\tdev_flags;\n#define DF_CONFIGURED\t\t\t\t0x00000001\n#define DF_FIRMWARE_VPD_UNIT_SERIAL\t\t0x00000002\n#define DF_EMULATED_VPD_UNIT_SERIAL\t\t0x00000004\n#define DF_USING_UDEV_PATH\t\t\t0x00000008\n#define DF_USING_ALIAS\t\t\t\t0x00000010\n#define DF_READ_ONLY\t\t\t\t0x00000020\n\tu8\t\t\ttransport_flags;\n\t \n\tu32\t\t\tqueue_depth;\n\t \n\tu64\t\t\tdev_res_bin_isid;\n\t \n\tu32\t\t\tdev_index;\n\tu64\t\t\tcreation_time;\n\tatomic_long_t\t\tnum_resets;\n\tatomic_long_t\t\taborts_complete;\n\tatomic_long_t\t\taborts_no_task;\n\tatomic_long_t\t\tnum_cmds;\n\tatomic_long_t\t\tread_bytes;\n\tatomic_long_t\t\twrite_bytes;\n\t \n\tatomic_t\t\tnon_ordered;\n\tbool\t\t\tordered_sync_in_progress;\n\tatomic_t\t\tdelayed_cmd_count;\n\tatomic_t\t\tdev_qf_count;\n\tu32\t\t\texport_count;\n\tspinlock_t\t\tdelayed_cmd_lock;\n\tspinlock_t\t\tdev_reservation_lock;\n\tunsigned int\t\tdev_reservation_flags;\n#define DRF_SPC2_RESERVATIONS\t\t\t0x00000001\n#define DRF_SPC2_RESERVATIONS_WITH_ISID\t\t0x00000002\n\tspinlock_t\t\tse_port_lock;\n\tspinlock_t\t\tse_tmr_lock;\n\tspinlock_t\t\tqf_cmd_lock;\n\tstruct semaphore\tcaw_sem;\n\t \n\tstruct se_session\t*reservation_holder;\n\t \n\tstruct t10_alua_lu_gp_member *dev_alua_lu_gp_mem;\n\t \n\tstruct t10_pr_registration *dev_pr_res_holder;\n\tstruct list_head\tdev_sep_list;\n\tstruct list_head\tdev_tmr_list;\n\tstruct work_struct\tqf_work_queue;\n\tstruct work_struct\tdelayed_cmd_work;\n\tstruct list_head\tdelayed_cmd_list;\n\tstruct list_head\tqf_cmd_list;\n\t \n\tstruct se_hba\t\t*se_hba;\n\t \n\tstruct t10_wwn\t\tt10_wwn;\n\t \n\tstruct t10_alua\t\tt10_alua;\n\t \n\tstruct t10_reservation\tt10_pr;\n\tstruct se_dev_attrib\tdev_attrib;\n\tstruct config_group\tdev_action_group;\n\tstruct config_group\tdev_group;\n\tstruct config_group\tdev_pr_group;\n\tstruct se_dev_stat_grps dev_stat_grps;\n#define SE_DEV_ALIAS_LEN 512\t\t \n\tunsigned char\t\tdev_alias[SE_DEV_ALIAS_LEN];\n#define SE_UDEV_PATH_LEN 512\t\t \n\tunsigned char\t\tudev_path[SE_UDEV_PATH_LEN];\n\t \n\tconst struct target_backend_ops *transport;\n\tstruct se_lun\t\txcopy_lun;\n\t \n\tint\t\t\tprot_length;\n\t \n\tu32\t\t\thba_index;\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tqueue_cnt;\n\tstruct se_device_queue\t*queues;\n\tstruct mutex\t\tlun_reset_mutex;\n};\n\nstruct target_opcode_descriptor {\n\tu8\t\t\tsupport:3;\n\tu8\t\t\tserv_action_valid:1;\n\tu8\t\t\topcode;\n\tu16\t\t\tservice_action;\n\tu32\t\t\tcdb_size;\n\tu8\t\t\tspecific_timeout;\n\tu16\t\t\tnominal_timeout;\n\tu16\t\t\trecommended_timeout;\n\tbool\t\t\t(*enabled)(struct target_opcode_descriptor *descr,\n\t\t\t\t\t   struct se_cmd *cmd);\n\tvoid\t\t\t(*update_usage_bits)(u8 *usage_bits,\n\t\t\t\t\t\t     struct se_device *dev);\n\tu8\t\t\tusage_bits[];\n};\n\nstruct se_hba {\n\tu16\t\t\thba_tpgt;\n\tu32\t\t\thba_id;\n\t \n\tu32\t\t\thba_flags;\n\t \n\tu32\t\t\tdev_count;\n\tu32\t\t\thba_index;\n\t \n\tvoid\t\t\t*hba_ptr;\n\tstruct list_head\thba_node;\n\tspinlock_t\t\tdevice_lock;\n\tstruct config_group\thba_group;\n\tstruct mutex\t\thba_access_mutex;\n\tstruct target_backend\t*backend;\n};\n\nstruct se_tpg_np {\n\tstruct se_portal_group *tpg_np_parent;\n\tstruct config_group\ttpg_np_group;\n};\n\nstatic inline struct se_tpg_np *to_tpg_np(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_tpg_np,\n\t\t\ttpg_np_group);\n}\n\nstruct se_portal_group {\n\t \n\tint\t\t\tproto_id;\n\tbool\t\t\tenabled;\n\t \n\tu16\t\t\ttpg_rtpi;\n\tbool\t\t\trtpi_manual;\n\t \n\tatomic_t\t\ttpg_pr_ref_count;\n\t \n\tstruct mutex\t\tacl_node_mutex;\n\t \n\tspinlock_t\t\tsession_lock;\n\tstruct mutex\t\ttpg_lun_mutex;\n\t \n\tstruct list_head\tacl_node_list;\n\tstruct hlist_head\ttpg_lun_hlist;\n\tstruct se_lun\t\t*tpg_virt_lun0;\n\t \n\tstruct list_head\ttpg_sess_list;\n\t \n\tconst struct target_core_fabric_ops *se_tpg_tfo;\n\tstruct se_wwn\t\t*se_tpg_wwn;\n\tstruct config_group\ttpg_group;\n\tstruct config_group\ttpg_lun_group;\n\tstruct config_group\ttpg_np_group;\n\tstruct config_group\ttpg_acl_group;\n\tstruct config_group\ttpg_attrib_group;\n\tstruct config_group\ttpg_auth_group;\n\tstruct config_group\ttpg_param_group;\n};\n\nstatic inline struct se_portal_group *to_tpg(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_portal_group,\n\t\t\ttpg_group);\n}\n\nstatic inline struct se_portal_group *attrib_to_tpg(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_portal_group,\n\t\t\ttpg_attrib_group);\n}\n\nstatic inline struct se_portal_group *auth_to_tpg(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_portal_group,\n\t\t\ttpg_auth_group);\n}\n\nstatic inline struct se_portal_group *param_to_tpg(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_portal_group,\n\t\t\ttpg_param_group);\n}\n\nenum {\n\t \n\tSE_COMPL_AFFINITY_CPUID\t\t= -1,\n\t \n\tSE_COMPL_AFFINITY_CURR_CPU\t= -2,\n};\n\nstruct se_wwn {\n\tstruct target_fabric_configfs *wwn_tf;\n\tvoid\t\t\t*priv;\n\tstruct config_group\twwn_group;\n\tstruct config_group\tfabric_stat_group;\n\tstruct config_group\tparam_group;\n\tint\t\t\tcmd_compl_affinity;\n};\n\nstatic inline void atomic_inc_mb(atomic_t *v)\n{\n\tsmp_mb__before_atomic();\n\tatomic_inc(v);\n\tsmp_mb__after_atomic();\n}\n\nstatic inline void atomic_dec_mb(atomic_t *v)\n{\n\tsmp_mb__before_atomic();\n\tatomic_dec(v);\n\tsmp_mb__after_atomic();\n}\n\nstatic inline void target_free_tag(struct se_session *sess, struct se_cmd *cmd)\n{\n\tsbitmap_queue_clear(&sess->sess_tag_pool, cmd->map_tag, cmd->map_cpu);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}