{
  "module_name": "xen-ops.h",
  "hash_id": "4c6e9ceb7a37d997d1221cb2c1d9f79fa586e89e84d0486b572be5bad2c49928",
  "original_prompt": "Ingested from linux-6.6.14/include/xen/xen-ops.h",
  "human_readable_source": " \n#ifndef INCLUDE_XEN_OPS_H\n#define INCLUDE_XEN_OPS_H\n\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/efi.h>\n#include <linux/virtio_anchor.h>\n#include <xen/features.h>\n#include <asm/xen/interface.h>\n#include <xen/interface/vcpu.h>\n\nDECLARE_PER_CPU(struct vcpu_info *, xen_vcpu);\n\nDECLARE_PER_CPU(uint32_t, xen_vcpu_id);\nstatic inline uint32_t xen_vcpu_nr(int cpu)\n{\n\treturn per_cpu(xen_vcpu_id, cpu);\n}\n\n#define XEN_VCPU_ID_INVALID U32_MAX\n\nvoid xen_arch_pre_suspend(void);\nvoid xen_arch_post_suspend(int suspend_cancelled);\n\nvoid xen_timer_resume(void);\nvoid xen_arch_resume(void);\nvoid xen_arch_suspend(void);\n\nvoid xen_reboot(int reason);\n\nvoid xen_resume_notifier_register(struct notifier_block *nb);\nvoid xen_resume_notifier_unregister(struct notifier_block *nb);\n\nbool xen_vcpu_stolen(int vcpu);\nvoid xen_setup_runstate_info(int cpu);\nvoid xen_time_setup_guest(void);\nvoid xen_manage_runstate_time(int action);\nvoid xen_get_runstate_snapshot(struct vcpu_runstate_info *res);\nu64 xen_steal_clock(int cpu);\n\nint xen_setup_shutdown_event(void);\n\nextern unsigned long *xen_contiguous_bitmap;\n\n#if defined(CONFIG_XEN_PV)\nint xen_remap_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t  xen_pfn_t *pfn, int nr, int *err_ptr, pgprot_t prot,\n\t\t  unsigned int domid, bool no_translate);\n#else\nstatic inline int xen_remap_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\txen_pfn_t *pfn, int nr, int *err_ptr,\n\t\t\t\tpgprot_t prot,  unsigned int domid,\n\t\t\t\tbool no_translate)\n{\n\tBUG();\n\treturn 0;\n}\n#endif\n\nstruct vm_area_struct;\n\n#ifdef CONFIG_XEN_AUTO_XLATE\nint xen_xlate_remap_gfn_array(struct vm_area_struct *vma,\n\t\t\t      unsigned long addr,\n\t\t\t      xen_pfn_t *gfn, int nr,\n\t\t\t      int *err_ptr, pgprot_t prot,\n\t\t\t      unsigned int domid,\n\t\t\t      struct page **pages);\nint xen_xlate_unmap_gfn_range(struct vm_area_struct *vma,\n\t\t\t      int nr, struct page **pages);\n#else\n \nstatic inline int xen_xlate_remap_gfn_array(struct vm_area_struct *vma,\n\t\t\t\t\t    unsigned long addr,\n\t\t\t\t\t    xen_pfn_t *gfn, int nr,\n\t\t\t\t\t    int *err_ptr, pgprot_t prot,\n\t\t\t\t\t    unsigned int domid,\n\t\t\t\t\t    struct page **pages)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int xen_xlate_unmap_gfn_range(struct vm_area_struct *vma,\n\t\t\t\t\t    int nr, struct page **pages)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nint xen_remap_vma_range(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long len);\n\n \nstatic inline int xen_remap_domain_gfn_array(struct vm_area_struct *vma,\n\t\t\t\t\t     unsigned long addr,\n\t\t\t\t\t     xen_pfn_t *gfn, int nr,\n\t\t\t\t\t     int *err_ptr, pgprot_t prot,\n\t\t\t\t\t     unsigned int domid,\n\t\t\t\t\t     struct page **pages)\n{\n\tif (xen_feature(XENFEAT_auto_translated_physmap))\n\t\treturn xen_xlate_remap_gfn_array(vma, addr, gfn, nr, err_ptr,\n\t\t\t\t\t\t prot, domid, pages);\n\n\t \n\tBUG_ON(err_ptr == NULL);\n\treturn xen_remap_pfn(vma, addr, gfn, nr, err_ptr, prot, domid,\n\t\t\t     false);\n}\n\n \nstatic inline int xen_remap_domain_mfn_array(struct vm_area_struct *vma,\n\t\t\t\t\t     unsigned long addr, xen_pfn_t *mfn,\n\t\t\t\t\t     int nr, int *err_ptr,\n\t\t\t\t\t     pgprot_t prot, unsigned int domid)\n{\n\tif (xen_feature(XENFEAT_auto_translated_physmap))\n\t\treturn -EOPNOTSUPP;\n\n\treturn xen_remap_pfn(vma, addr, mfn, nr, err_ptr, prot, domid,\n\t\t\t     true);\n}\n\n \nstatic inline int xen_remap_domain_gfn_range(struct vm_area_struct *vma,\n\t\t\t\t\t     unsigned long addr,\n\t\t\t\t\t     xen_pfn_t gfn, int nr,\n\t\t\t\t\t     pgprot_t prot, unsigned int domid,\n\t\t\t\t\t     struct page **pages)\n{\n\tif (xen_feature(XENFEAT_auto_translated_physmap))\n\t\treturn -EOPNOTSUPP;\n\n\treturn xen_remap_pfn(vma, addr, &gfn, nr, NULL, prot, domid, false);\n}\n\nint xen_unmap_domain_gfn_range(struct vm_area_struct *vma,\n\t\t\t       int numpgs, struct page **pages);\n\nint xen_xlate_map_ballooned_pages(xen_pfn_t **pfns, void **vaddr,\n\t\t\t\t  unsigned long nr_grant_frames);\n\nbool xen_running_on_version_or_later(unsigned int major, unsigned int minor);\n\nvoid xen_efi_runtime_setup(void);\n\n\n#if defined(CONFIG_XEN_PV) && !defined(CONFIG_PREEMPTION)\n\nDECLARE_PER_CPU(bool, xen_in_preemptible_hcall);\n\nstatic inline void xen_preemptible_hcall_begin(void)\n{\n\t__this_cpu_write(xen_in_preemptible_hcall, true);\n}\n\nstatic inline void xen_preemptible_hcall_end(void)\n{\n\t__this_cpu_write(xen_in_preemptible_hcall, false);\n}\n\n#else\n\nstatic inline void xen_preemptible_hcall_begin(void) { }\nstatic inline void xen_preemptible_hcall_end(void) { }\n\n#endif  \n\n#ifdef CONFIG_XEN_GRANT_DMA_OPS\nbool xen_virtio_restricted_mem_acc(struct virtio_device *dev);\n#else\nstruct virtio_device;\n\nstatic inline bool xen_virtio_restricted_mem_acc(struct virtio_device *dev)\n{\n\treturn false;\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}