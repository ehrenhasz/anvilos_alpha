{
  "module_name": "grant_table.h",
  "hash_id": "9b81017c8044005bf3d43cdacc1a12df8b8341a7f127dee1fe76d18f0fda7e7c",
  "original_prompt": "Ingested from linux-6.6.14/include/xen/grant_table.h",
  "human_readable_source": " \n\n#ifndef __ASM_GNTTAB_H__\n#define __ASM_GNTTAB_H__\n\n#include <asm/page.h>\n\n#include <xen/interface/xen.h>\n#include <xen/interface/grant_table.h>\n\n#include <asm/xen/hypervisor.h>\n\n#include <xen/features.h>\n#include <xen/page.h>\n#include <linux/mm_types.h>\n#include <linux/page-flags.h>\n#include <linux/kernel.h>\n\n \n#define INVALID_GRANT_REF          ((grant_ref_t)-1)\n#define INVALID_GRANT_HANDLE       ((grant_handle_t)-1)\n\n \n#define NR_GRANT_FRAMES 4\n\nstruct gnttab_free_callback {\n\tstruct gnttab_free_callback *next;\n\tvoid (*fn)(void *);\n\tvoid *arg;\n\tu16 count;\n};\n\nstruct gntab_unmap_queue_data;\n\ntypedef void (*gnttab_unmap_refs_done)(int result, struct gntab_unmap_queue_data *data);\n\nstruct gntab_unmap_queue_data\n{\n\tstruct delayed_work\tgnttab_work;\n\tvoid *data;\n\tgnttab_unmap_refs_done\tdone;\n\tstruct gnttab_unmap_grant_ref *unmap_ops;\n\tstruct gnttab_unmap_grant_ref *kunmap_ops;\n\tstruct page **pages;\n\tunsigned int count;\n\tunsigned int age;\n};\n\nint gnttab_init(void);\nint gnttab_suspend(void);\nint gnttab_resume(void);\n\nint gnttab_grant_foreign_access(domid_t domid, unsigned long frame,\n\t\t\t\tint readonly);\n\n \nint gnttab_end_foreign_access_ref(grant_ref_t ref);\n\n \nvoid gnttab_end_foreign_access(grant_ref_t ref, struct page *page);\n\n \nint gnttab_try_end_foreign_access(grant_ref_t ref);\n\n \nint gnttab_alloc_grant_references(u16 count, grant_ref_t *pprivate_head);\n\nint gnttab_alloc_grant_reference_seq(unsigned int count, grant_ref_t *first);\n\nvoid gnttab_free_grant_reference(grant_ref_t ref);\n\nvoid gnttab_free_grant_references(grant_ref_t head);\n\nvoid gnttab_free_grant_reference_seq(grant_ref_t head, unsigned int count);\n\nint gnttab_empty_grant_references(const grant_ref_t *pprivate_head);\n\nint gnttab_claim_grant_reference(grant_ref_t *pprivate_head);\n\nvoid gnttab_release_grant_reference(grant_ref_t *private_head,\n\t\t\t\t    grant_ref_t release);\n\nvoid gnttab_request_free_callback(struct gnttab_free_callback *callback,\n\t\t\t\t  void (*fn)(void *), void *arg, u16 count);\nvoid gnttab_cancel_free_callback(struct gnttab_free_callback *callback);\n\nvoid gnttab_grant_foreign_access_ref(grant_ref_t ref, domid_t domid,\n\t\t\t\t     unsigned long frame, int readonly);\n\n \nstatic inline void gnttab_page_grant_foreign_access_ref_one(\n\tgrant_ref_t ref, domid_t domid,\n\tstruct page *page, int readonly)\n{\n\tgnttab_grant_foreign_access_ref(ref, domid, xen_page_to_gfn(page),\n\t\t\t\t\treadonly);\n}\n\nstatic inline void\ngnttab_set_map_op(struct gnttab_map_grant_ref *map, phys_addr_t addr,\n\t\t  uint32_t flags, grant_ref_t ref, domid_t domid)\n{\n\tif (flags & GNTMAP_contains_pte)\n\t\tmap->host_addr = addr;\n\telse if (xen_feature(XENFEAT_auto_translated_physmap))\n\t\tmap->host_addr = __pa(addr);\n\telse\n\t\tmap->host_addr = addr;\n\n\tmap->flags = flags;\n\tmap->ref = ref;\n\tmap->dom = domid;\n\tmap->status = 1;  \n}\n\nstatic inline void\ngnttab_set_unmap_op(struct gnttab_unmap_grant_ref *unmap, phys_addr_t addr,\n\t\t    uint32_t flags, grant_handle_t handle)\n{\n\tif (flags & GNTMAP_contains_pte)\n\t\tunmap->host_addr = addr;\n\telse if (xen_feature(XENFEAT_auto_translated_physmap))\n\t\tunmap->host_addr = __pa(addr);\n\telse\n\t\tunmap->host_addr = addr;\n\n\tunmap->handle = handle;\n\tunmap->dev_bus_addr = 0;\n}\n\nint arch_gnttab_init(unsigned long nr_shared, unsigned long nr_status);\nint arch_gnttab_map_shared(xen_pfn_t *frames, unsigned long nr_gframes,\n\t\t\t   unsigned long max_nr_gframes,\n\t\t\t   void **__shared);\nint arch_gnttab_map_status(uint64_t *frames, unsigned long nr_gframes,\n\t\t\t   unsigned long max_nr_gframes,\n\t\t\t   grant_status_t **__shared);\nvoid arch_gnttab_unmap(void *shared, unsigned long nr_gframes);\n\nstruct grant_frames {\n\txen_pfn_t *pfn;\n\tunsigned int count;\n\tvoid *vaddr;\n};\nextern struct grant_frames xen_auto_xlat_grant_frames;\nunsigned int gnttab_max_grant_frames(void);\nint gnttab_setup_auto_xlat_frames(phys_addr_t addr);\nvoid gnttab_free_auto_xlat_frames(void);\n\n#define gnttab_map_vaddr(map) ((void *)(map.host_virt_addr))\n\nint gnttab_alloc_pages(int nr_pages, struct page **pages);\nvoid gnttab_free_pages(int nr_pages, struct page **pages);\n\nstruct gnttab_page_cache {\n\tspinlock_t\t\tlock;\n#ifdef CONFIG_XEN_UNPOPULATED_ALLOC\n\tstruct page\t\t*pages;\n#else\n\tstruct list_head\tpages;\n#endif\n\tunsigned int\t\tnum_pages;\n};\n\nvoid gnttab_page_cache_init(struct gnttab_page_cache *cache);\nint gnttab_page_cache_get(struct gnttab_page_cache *cache, struct page **page);\nvoid gnttab_page_cache_put(struct gnttab_page_cache *cache, struct page **page,\n\t\t\t   unsigned int num);\nvoid gnttab_page_cache_shrink(struct gnttab_page_cache *cache,\n\t\t\t      unsigned int num);\n\n#ifdef CONFIG_XEN_GRANT_DMA_ALLOC\nstruct gnttab_dma_alloc_args {\n\t \n\tstruct device *dev;\n\t \n\tbool coherent;\n\n\tint nr_pages;\n\tstruct page **pages;\n\txen_pfn_t *frames;\n\tvoid *vaddr;\n\tdma_addr_t dev_bus_addr;\n};\n\nint gnttab_dma_alloc_pages(struct gnttab_dma_alloc_args *args);\nint gnttab_dma_free_pages(struct gnttab_dma_alloc_args *args);\n#endif\n\nint gnttab_pages_set_private(int nr_pages, struct page **pages);\nvoid gnttab_pages_clear_private(int nr_pages, struct page **pages);\n\nint gnttab_map_refs(struct gnttab_map_grant_ref *map_ops,\n\t\t    struct gnttab_map_grant_ref *kmap_ops,\n\t\t    struct page **pages, unsigned int count);\nint gnttab_unmap_refs(struct gnttab_unmap_grant_ref *unmap_ops,\n\t\t      struct gnttab_unmap_grant_ref *kunmap_ops,\n\t\t      struct page **pages, unsigned int count);\nvoid gnttab_unmap_refs_async(struct gntab_unmap_queue_data* item);\nint gnttab_unmap_refs_sync(struct gntab_unmap_queue_data *item);\n\n\n \nvoid gnttab_batch_map(struct gnttab_map_grant_ref *batch, unsigned count);\nvoid gnttab_batch_copy(struct gnttab_copy *batch, unsigned count);\n\n\nstruct xen_page_foreign {\n\tdomid_t domid;\n\tgrant_ref_t gref;\n};\n\nstatic inline struct xen_page_foreign *xen_page_foreign(struct page *page)\n{\n\tif (!PageForeign(page))\n\t\treturn NULL;\n#if BITS_PER_LONG < 64\n\treturn (struct xen_page_foreign *)page->private;\n#else\n\tBUILD_BUG_ON(sizeof(struct xen_page_foreign) > BITS_PER_LONG);\n\treturn (struct xen_page_foreign *)&page->private;\n#endif\n}\n\n \ntypedef void (*xen_grant_fn_t)(unsigned long gfn, unsigned int offset,\n\t\t\t       unsigned int len, void *data);\n\nvoid gnttab_foreach_grant_in_range(struct page *page,\n\t\t\t\t   unsigned int offset,\n\t\t\t\t   unsigned int len,\n\t\t\t\t   xen_grant_fn_t fn,\n\t\t\t\t   void *data);\n\n \nstatic inline void gnttab_for_one_grant(struct page *page, unsigned int offset,\n\t\t\t\t\tunsigned len, xen_grant_fn_t fn,\n\t\t\t\t\tvoid *data)\n{\n\t \n\tlen = min_t(unsigned int, XEN_PAGE_SIZE - (offset & ~XEN_PAGE_MASK),\n\t\t    len);\n\n\tgnttab_foreach_grant_in_range(page, offset, len, fn, data);\n}\n\n \nvoid gnttab_foreach_grant(struct page **pages,\n\t\t\t  unsigned int nr_grefs,\n\t\t\t  xen_grant_fn_t fn,\n\t\t\t  void *data);\n\n \nstatic inline unsigned int gnttab_count_grant(unsigned int start,\n\t\t\t\t\t      unsigned int len)\n{\n\treturn XEN_PFN_UP(xen_offset_in_page(start) + len);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}