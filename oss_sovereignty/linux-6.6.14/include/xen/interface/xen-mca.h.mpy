{
  "module_name": "xen-mca.h",
  "hash_id": "fb73a11081ab1acb0f053c098c4b69a3c2a750025a89c0ab1d2504ed32082347",
  "original_prompt": "Ingested from linux-6.6.14/include/xen/interface/xen-mca.h",
  "human_readable_source": " \n \n\n#ifndef __XEN_PUBLIC_ARCH_X86_MCA_H__\n#define __XEN_PUBLIC_ARCH_X86_MCA_H__\n\n \n#define __HYPERVISOR_mca __HYPERVISOR_arch_0\n\n#define XEN_MCA_INTERFACE_VERSION\t0x01ecc003\n\n \n#define XEN_MC_NONURGENT\t0x1\n \n#define XEN_MC_URGENT\t\t0x2\n \n#define XEN_MC_ACK\t\t0x4\n\n \n#define XEN_MC_OK\t\t0x0\n \n#define XEN_MC_FETCHFAILED\t0x1\n \n#define XEN_MC_NODATA\t\t0x2\n\n#ifndef __ASSEMBLY__\n \n#define VIRQ_MCA VIRQ_ARCH_0\n\n \n#define MC_TYPE_GLOBAL\t\t0\n#define MC_TYPE_BANK\t\t1\n#define MC_TYPE_EXTENDED\t2\n#define MC_TYPE_RECOVERY\t3\n\nstruct mcinfo_common {\n\tuint16_t type;  \n\tuint16_t size;  \n};\n\n#define MC_FLAG_CORRECTABLE\t(1 << 0)\n#define MC_FLAG_UNCORRECTABLE\t(1 << 1)\n#define MC_FLAG_RECOVERABLE\t(1 << 2)\n#define MC_FLAG_POLLED\t\t(1 << 3)\n#define MC_FLAG_RESET\t\t(1 << 4)\n#define MC_FLAG_CMCI\t\t(1 << 5)\n#define MC_FLAG_MCE\t\t(1 << 6)\n\n \nstruct mcinfo_global {\n\tstruct mcinfo_common common;\n\n\tuint16_t mc_domid;  \n\tuint16_t mc_vcpuid;  \n\tuint32_t mc_socketid;  \n\tuint16_t mc_coreid;  \n\tuint16_t mc_core_threadid;  \n\tuint32_t mc_apicid;\n\tuint32_t mc_flags;\n\tuint64_t mc_gstatus;  \n};\n\n \nstruct mcinfo_bank {\n\tstruct mcinfo_common common;\n\n\tuint16_t mc_bank;  \n\tuint16_t mc_domid;  \n\tuint64_t mc_status;  \n\tuint64_t mc_addr;  \n\tuint64_t mc_misc;\n\tuint64_t mc_ctrl2;\n\tuint64_t mc_tsc;\n};\n\nstruct mcinfo_msr {\n\tuint64_t reg;  \n\tuint64_t value;  \n};\n\n \nstruct mcinfo_extended {\n\tstruct mcinfo_common common;\n\tuint32_t mc_msrs;  \n\t \n\tstruct mcinfo_msr mc_msr[sizeof(void *) * 4];\n};\n\n \n\n \n#define REC_ACTION_RECOVERED (0x1 << 0)\n \n#define REC_ACTION_NONE (0x1 << 1)\n \n#define REC_ACTION_NEED_RESET (0x1 << 2)\n\n \n\n \n#define MC_ACTION_PAGE_OFFLINE (0x1 << 0)\n \n#define MC_ACTION_CPU_OFFLINE (0x1 << 1)\n \n#define MC_ACTION_CACHE_SHRINK (0x1 << 2)\n\n \nstruct page_offline_action {\n\t \n\tuint64_t mfn;\n\tuint64_t status;\n};\n\nstruct cpu_offline_action {\n\t \n\tuint32_t mc_socketid;\n\tuint16_t mc_coreid;\n\tuint16_t mc_core_threadid;\n};\n\n#define MAX_UNION_SIZE 16\nstruct mcinfo_recovery {\n\tstruct mcinfo_common common;\n\tuint16_t mc_bank;  \n\tuint8_t action_flags;\n\tuint8_t action_types;\n\tunion {\n\t\tstruct page_offline_action page_retire;\n\t\tstruct cpu_offline_action cpu_offline;\n\t\tuint8_t pad[MAX_UNION_SIZE];\n\t} action_info;\n};\n\n\n#define MCINFO_MAXSIZE 768\nstruct mc_info {\n\t \n\tuint32_t mi_nentries;\n\tuint32_t flags;\n\tuint64_t mi_data[(MCINFO_MAXSIZE - 1) / 8];\n};\nDEFINE_GUEST_HANDLE_STRUCT(mc_info);\n\n#define __MC_MSR_ARRAYSIZE 8\n#define __MC_NMSRS 1\n#define MC_NCAPS 7\nstruct mcinfo_logical_cpu {\n\tuint32_t mc_cpunr;\n\tuint32_t mc_chipid;\n\tuint16_t mc_coreid;\n\tuint16_t mc_threadid;\n\tuint32_t mc_apicid;\n\tuint32_t mc_clusterid;\n\tuint32_t mc_ncores;\n\tuint32_t mc_ncores_active;\n\tuint32_t mc_nthreads;\n\tuint32_t mc_cpuid_level;\n\tuint32_t mc_family;\n\tuint32_t mc_vendor;\n\tuint32_t mc_model;\n\tuint32_t mc_step;\n\tchar mc_vendorid[16];\n\tchar mc_brandid[64];\n\tuint32_t mc_cpu_caps[MC_NCAPS];\n\tuint32_t mc_cache_size;\n\tuint32_t mc_cache_alignment;\n\tuint32_t mc_nmsrvals;\n\tstruct mcinfo_msr mc_msrvalues[__MC_MSR_ARRAYSIZE];\n};\nDEFINE_GUEST_HANDLE_STRUCT(mcinfo_logical_cpu);\n\n \n#define x86_mcinfo_nentries(_mi)    \\\n\t((_mi)->mi_nentries)\n \n#define x86_mcinfo_first(_mi)       \\\n\t((struct mcinfo_common *)(_mi)->mi_data)\n \n#define x86_mcinfo_next(_mic)       \\\n\t((struct mcinfo_common *)((uint8_t *)(_mic) + (_mic)->size))\n\n \nstatic inline void x86_mcinfo_lookup(struct mcinfo_common **ret,\n\t\t\t\t     struct mc_info *mi, uint16_t type)\n{\n\tuint32_t i;\n\tstruct mcinfo_common *mic;\n\tbool found = 0;\n\n\tif (!ret || !mi)\n\t\treturn;\n\n\tmic = x86_mcinfo_first(mi);\n\tfor (i = 0; i < x86_mcinfo_nentries(mi); i++) {\n\t\tif (mic->type == type) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tmic = x86_mcinfo_next(mic);\n\t}\n\n\t*ret = found ? mic : NULL;\n}\n\n \n#define XEN_MC_fetch\t\t1\nstruct xen_mc_fetch {\n\t \n\tuint32_t flags;\n\tuint32_t _pad0;\n\t \n\tuint64_t fetch_id;\n\n\t \n\tGUEST_HANDLE(mc_info) data;\n};\nDEFINE_GUEST_HANDLE_STRUCT(xen_mc_fetch);\n\n\n \n#define XEN_MC_notifydomain\t2\nstruct xen_mc_notifydomain {\n\t \n\tuint16_t mc_domid;  \n\tuint16_t mc_vcpuid;  \n\n\t \n\tuint32_t flags;\n};\nDEFINE_GUEST_HANDLE_STRUCT(xen_mc_notifydomain);\n\n#define XEN_MC_physcpuinfo\t3\nstruct xen_mc_physcpuinfo {\n\t \n\tuint32_t ncpus;\n\tuint32_t _pad0;\n\t \n\tGUEST_HANDLE(mcinfo_logical_cpu) info;\n};\n\n#define XEN_MC_msrinject\t4\n#define MC_MSRINJ_MAXMSRS\t8\nstruct xen_mc_msrinject {\n\t \n\tuint32_t mcinj_cpunr;  \n\tuint32_t mcinj_flags;  \n\tuint32_t mcinj_count;  \n\tuint32_t _pad0;\n\tstruct mcinfo_msr mcinj_msr[MC_MSRINJ_MAXMSRS];\n};\n\n \n#define MC_MSRINJ_F_INTERPOSE\t0x1\n\n#define XEN_MC_mceinject\t5\nstruct xen_mc_mceinject {\n\tunsigned int mceinj_cpunr;  \n};\n\nstruct xen_mc {\n\tuint32_t cmd;\n\tuint32_t interface_version;  \n\tunion {\n\t\tstruct xen_mc_fetch        mc_fetch;\n\t\tstruct xen_mc_notifydomain mc_notifydomain;\n\t\tstruct xen_mc_physcpuinfo  mc_physcpuinfo;\n\t\tstruct xen_mc_msrinject    mc_msrinject;\n\t\tstruct xen_mc_mceinject    mc_mceinject;\n\t} u;\n};\nDEFINE_GUEST_HANDLE_STRUCT(xen_mc);\n\n \nstruct xen_mce {\n\t__u64 status;\n\t__u64 misc;\n\t__u64 addr;\n\t__u64 mcgstatus;\n\t__u64 ip;\n\t__u64 tsc;\t \n\t__u64 time;\t \n\t__u8  cpuvendor;\t \n\t__u8  inject_flags;\t \n\t__u16  pad;\n\t__u32 cpuid;\t \n\t__u8  cs;\t\t \n\t__u8  bank;\t \n\t__u8  cpu;\t \n\t__u8  finished;    \n\t__u32 extcpu;\t \n\t__u32 socketid;\t \n\t__u32 apicid;\t \n\t__u64 mcgcap;\t \n\t__u64 synd;\t \n\t__u64 ipid;\t \n\t__u64 ppin;\t \n};\n\n \n\n#define XEN_MCE_LOG_LEN 32\n\nstruct xen_mce_log {\n\tchar signature[12];  \n\tunsigned len;\t     \n\tunsigned next;\n\tunsigned flags;\n\tunsigned recordlen;\t \n\tstruct xen_mce entry[XEN_MCE_LOG_LEN];\n};\n\n#define XEN_MCE_OVERFLOW 0\t\t \n\n#define XEN_MCE_LOG_SIGNATURE\t\"MACHINECHECK\"\n\n#define MCE_GET_RECORD_LEN   _IOR('M', 1, int)\n#define MCE_GET_LOG_LEN      _IOR('M', 2, int)\n#define MCE_GETCLEAR_FLAGS   _IOR('M', 3, int)\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}