{
  "module_name": "ib_umem.h",
  "hash_id": "97c8f437e4a2cb2e238dd9c0da49fd9ffffe5b306b5fc9dcd3fbe9c475892a32",
  "original_prompt": "Ingested from linux-6.6.14/include/rdma/ib_umem.h",
  "human_readable_source": " \n \n\n#ifndef IB_UMEM_H\n#define IB_UMEM_H\n\n#include <linux/list.h>\n#include <linux/scatterlist.h>\n#include <linux/workqueue.h>\n#include <rdma/ib_verbs.h>\n\nstruct ib_ucontext;\nstruct ib_umem_odp;\nstruct dma_buf_attach_ops;\n\nstruct ib_umem {\n\tstruct ib_device       *ibdev;\n\tstruct mm_struct       *owning_mm;\n\tu64 iova;\n\tsize_t\t\t\tlength;\n\tunsigned long\t\taddress;\n\tu32 writable : 1;\n\tu32 is_odp : 1;\n\tu32 is_dmabuf : 1;\n\tstruct sg_append_table sgt_append;\n};\n\nstruct ib_umem_dmabuf {\n\tstruct ib_umem umem;\n\tstruct dma_buf_attachment *attach;\n\tstruct sg_table *sgt;\n\tstruct scatterlist *first_sg;\n\tstruct scatterlist *last_sg;\n\tunsigned long first_sg_offset;\n\tunsigned long last_sg_trim;\n\tvoid *private;\n\tu8 pinned : 1;\n};\n\nstatic inline struct ib_umem_dmabuf *to_ib_umem_dmabuf(struct ib_umem *umem)\n{\n\treturn container_of(umem, struct ib_umem_dmabuf, umem);\n}\n\n \nstatic inline int ib_umem_offset(struct ib_umem *umem)\n{\n\treturn umem->address & ~PAGE_MASK;\n}\n\nstatic inline unsigned long ib_umem_dma_offset(struct ib_umem *umem,\n\t\t\t\t\t       unsigned long pgsz)\n{\n\treturn (sg_dma_address(umem->sgt_append.sgt.sgl) + ib_umem_offset(umem)) &\n\t       (pgsz - 1);\n}\n\nstatic inline size_t ib_umem_num_dma_blocks(struct ib_umem *umem,\n\t\t\t\t\t    unsigned long pgsz)\n{\n\treturn (size_t)((ALIGN(umem->iova + umem->length, pgsz) -\n\t\t\t ALIGN_DOWN(umem->iova, pgsz))) /\n\t       pgsz;\n}\n\nstatic inline size_t ib_umem_num_pages(struct ib_umem *umem)\n{\n\treturn ib_umem_num_dma_blocks(umem, PAGE_SIZE);\n}\n\nstatic inline void __rdma_umem_block_iter_start(struct ib_block_iter *biter,\n\t\t\t\t\t\tstruct ib_umem *umem,\n\t\t\t\t\t\tunsigned long pgsz)\n{\n\t__rdma_block_iter_start(biter, umem->sgt_append.sgt.sgl,\n\t\t\t\tumem->sgt_append.sgt.nents, pgsz);\n\tbiter->__sg_advance = ib_umem_offset(umem) & ~(pgsz - 1);\n\tbiter->__sg_numblocks = ib_umem_num_dma_blocks(umem, pgsz);\n}\n\nstatic inline bool __rdma_umem_block_iter_next(struct ib_block_iter *biter)\n{\n\treturn __rdma_block_iter_next(biter) && biter->__sg_numblocks--;\n}\n\n \n#define rdma_umem_for_each_dma_block(umem, biter, pgsz)                        \\\n\tfor (__rdma_umem_block_iter_start(biter, umem, pgsz);                  \\\n\t     __rdma_umem_block_iter_next(biter);)\n\n#ifdef CONFIG_INFINIBAND_USER_MEM\n\nstruct ib_umem *ib_umem_get(struct ib_device *device, unsigned long addr,\n\t\t\t    size_t size, int access);\nvoid ib_umem_release(struct ib_umem *umem);\nint ib_umem_copy_from(void *dst, struct ib_umem *umem, size_t offset,\n\t\t      size_t length);\nunsigned long ib_umem_find_best_pgsz(struct ib_umem *umem,\n\t\t\t\t     unsigned long pgsz_bitmap,\n\t\t\t\t     unsigned long virt);\n\n \nstatic inline unsigned long ib_umem_find_best_pgoff(struct ib_umem *umem,\n\t\t\t\t\t\t    unsigned long pgsz_bitmap,\n\t\t\t\t\t\t    u64 pgoff_bitmask)\n{\n\tstruct scatterlist *sg = umem->sgt_append.sgt.sgl;\n\tdma_addr_t dma_addr;\n\n\tdma_addr = sg_dma_address(sg) + (umem->address & ~PAGE_MASK);\n\treturn ib_umem_find_best_pgsz(umem, pgsz_bitmap,\n\t\t\t\t      dma_addr & pgoff_bitmask);\n}\n\nstruct ib_umem_dmabuf *ib_umem_dmabuf_get(struct ib_device *device,\n\t\t\t\t\t  unsigned long offset, size_t size,\n\t\t\t\t\t  int fd, int access,\n\t\t\t\t\t  const struct dma_buf_attach_ops *ops);\nstruct ib_umem_dmabuf *ib_umem_dmabuf_get_pinned(struct ib_device *device,\n\t\t\t\t\t\t unsigned long offset,\n\t\t\t\t\t\t size_t size, int fd,\n\t\t\t\t\t\t int access);\nint ib_umem_dmabuf_map_pages(struct ib_umem_dmabuf *umem_dmabuf);\nvoid ib_umem_dmabuf_unmap_pages(struct ib_umem_dmabuf *umem_dmabuf);\nvoid ib_umem_dmabuf_release(struct ib_umem_dmabuf *umem_dmabuf);\n\n#else  \n\n#include <linux/err.h>\n\nstatic inline struct ib_umem *ib_umem_get(struct ib_device *device,\n\t\t\t\t\t  unsigned long addr, size_t size,\n\t\t\t\t\t  int access)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\nstatic inline void ib_umem_release(struct ib_umem *umem) { }\nstatic inline int ib_umem_copy_from(void *dst, struct ib_umem *umem, size_t offset,\n\t\t      \t\t    size_t length) {\n\treturn -EOPNOTSUPP;\n}\nstatic inline unsigned long ib_umem_find_best_pgsz(struct ib_umem *umem,\n\t\t\t\t\t\t   unsigned long pgsz_bitmap,\n\t\t\t\t\t\t   unsigned long virt)\n{\n\treturn 0;\n}\nstatic inline unsigned long ib_umem_find_best_pgoff(struct ib_umem *umem,\n\t\t\t\t\t\t    unsigned long pgsz_bitmap,\n\t\t\t\t\t\t    u64 pgoff_bitmask)\n{\n\treturn 0;\n}\nstatic inline\nstruct ib_umem_dmabuf *ib_umem_dmabuf_get(struct ib_device *device,\n\t\t\t\t\t  unsigned long offset,\n\t\t\t\t\t  size_t size, int fd,\n\t\t\t\t\t  int access,\n\t\t\t\t\t  struct dma_buf_attach_ops *ops)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\nstatic inline struct ib_umem_dmabuf *\nib_umem_dmabuf_get_pinned(struct ib_device *device, unsigned long offset,\n\t\t\t  size_t size, int fd, int access)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\nstatic inline int ib_umem_dmabuf_map_pages(struct ib_umem_dmabuf *umem_dmabuf)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline void ib_umem_dmabuf_unmap_pages(struct ib_umem_dmabuf *umem_dmabuf) { }\nstatic inline void ib_umem_dmabuf_release(struct ib_umem_dmabuf *umem_dmabuf) { }\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}