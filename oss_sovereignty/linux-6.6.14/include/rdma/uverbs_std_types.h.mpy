{
  "module_name": "uverbs_std_types.h",
  "hash_id": "fd0dc921d869d425be139097a9dd002a21219c218e80803e95dd5baf4bb175ab",
  "original_prompt": "Ingested from linux-6.6.14/include/rdma/uverbs_std_types.h",
  "human_readable_source": " \n \n\n#ifndef _UVERBS_STD_TYPES__\n#define _UVERBS_STD_TYPES__\n\n#include <rdma/uverbs_types.h>\n#include <rdma/uverbs_ioctl.h>\n#include <rdma/ib_user_ioctl_verbs.h>\n\n \n#define _uobj_check_id(_id) ((_id) * typecheck(u32, _id))\n\n#define uobj_get_type(_attrs, _object)                                         \\\n\tuapi_get_object((_attrs)->ufile->device->uapi, _object)\n\n#define uobj_get_read(_type, _id, _attrs)                                      \\\n\trdma_lookup_get_uobject(uobj_get_type(_attrs, _type), (_attrs)->ufile, \\\n\t\t\t\t_uobj_check_id(_id), UVERBS_LOOKUP_READ,       \\\n\t\t\t\t_attrs)\n\n#define ufd_get_read(_type, _fdnum, _attrs)                                    \\\n\trdma_lookup_get_uobject(uobj_get_type(_attrs, _type), (_attrs)->ufile, \\\n\t\t\t\t(_fdnum)*typecheck(s32, _fdnum),               \\\n\t\t\t\tUVERBS_LOOKUP_READ, _attrs)\n\nstatic inline void *_uobj_get_obj_read(struct ib_uobject *uobj)\n{\n\tif (IS_ERR(uobj))\n\t\treturn NULL;\n\treturn uobj->object;\n}\n#define uobj_get_obj_read(_object, _type, _id, _attrs)                         \\\n\t((struct ib_##_object *)_uobj_get_obj_read(                            \\\n\t\tuobj_get_read(_type, _id, _attrs)))\n\n#define uobj_get_write(_type, _id, _attrs)                                     \\\n\trdma_lookup_get_uobject(uobj_get_type(_attrs, _type), (_attrs)->ufile, \\\n\t\t\t\t_uobj_check_id(_id), UVERBS_LOOKUP_WRITE,      \\\n\t\t\t\t_attrs)\n\nint __uobj_perform_destroy(const struct uverbs_api_object *obj, u32 id,\n\t\t\t   struct uverbs_attr_bundle *attrs);\n#define uobj_perform_destroy(_type, _id, _attrs)                               \\\n\t__uobj_perform_destroy(uobj_get_type(_attrs, _type),                   \\\n\t\t\t       _uobj_check_id(_id), _attrs)\n\nstruct ib_uobject *__uobj_get_destroy(const struct uverbs_api_object *obj,\n\t\t\t\t      u32 id, struct uverbs_attr_bundle *attrs);\n\n#define uobj_get_destroy(_type, _id, _attrs)                                   \\\n\t__uobj_get_destroy(uobj_get_type(_attrs, _type), _uobj_check_id(_id),  \\\n\t\t\t   _attrs)\n\nstatic inline void uobj_put_destroy(struct ib_uobject *uobj)\n{\n\trdma_lookup_put_uobject(uobj, UVERBS_LOOKUP_DESTROY);\n}\n\nstatic inline void uobj_put_read(struct ib_uobject *uobj)\n{\n\trdma_lookup_put_uobject(uobj, UVERBS_LOOKUP_READ);\n}\n\n#define uobj_put_obj_read(_obj)\t\t\t\t\t\\\n\tuobj_put_read((_obj)->uobject)\n\nstatic inline void uobj_put_write(struct ib_uobject *uobj)\n{\n\trdma_lookup_put_uobject(uobj, UVERBS_LOOKUP_WRITE);\n}\n\nstatic inline void uobj_alloc_abort(struct ib_uobject *uobj,\n\t\t\t\t    struct uverbs_attr_bundle *attrs)\n{\n\trdma_alloc_abort_uobject(uobj, attrs, false);\n}\n\nstatic inline void uobj_finalize_uobj_create(struct ib_uobject *uobj,\n\t\t\t\t\t     struct uverbs_attr_bundle *attrs)\n{\n\t \n\tWARN_ON(attrs->uobject);\n\tattrs->uobject = uobj;\n}\n\nstatic inline struct ib_uobject *\n__uobj_alloc(const struct uverbs_api_object *obj,\n\t     struct uverbs_attr_bundle *attrs, struct ib_device **ib_dev)\n{\n\tstruct ib_uobject *uobj = rdma_alloc_begin_uobject(obj, attrs);\n\n\tif (!IS_ERR(uobj))\n\t\t*ib_dev = attrs->context->device;\n\treturn uobj;\n}\n\n#define uobj_alloc(_type, _attrs, _ib_dev)                                     \\\n\t__uobj_alloc(uobj_get_type(_attrs, _type), _attrs, _ib_dev)\n\nstatic inline void uverbs_flow_action_fill_action(struct ib_flow_action *action,\n\t\t\t\t\t\t  struct ib_uobject *uobj,\n\t\t\t\t\t\t  struct ib_device *ib_dev,\n\t\t\t\t\t\t  enum ib_flow_action_type type)\n{\n\tatomic_set(&action->usecnt, 0);\n\taction->device = ib_dev;\n\taction->type = type;\n\taction->uobject = uobj;\n\tuobj->object = action;\n}\n\nstruct ib_uflow_resources {\n\tsize_t\t\t\tmax;\n\tsize_t\t\t\tnum;\n\tsize_t\t\t\tcollection_num;\n\tsize_t\t\t\tcounters_num;\n\tstruct ib_counters\t**counters;\n\tstruct ib_flow_action\t**collection;\n};\n\nstruct ib_uflow_object {\n\tstruct ib_uobject\t\tuobject;\n\tstruct ib_uflow_resources\t*resources;\n};\n\nstruct ib_uflow_resources *flow_resources_alloc(size_t num_specs);\nvoid flow_resources_add(struct ib_uflow_resources *uflow_res,\n\t\t\tenum ib_flow_spec_type type,\n\t\t\tvoid *ibobj);\nvoid ib_uverbs_flow_resources_free(struct ib_uflow_resources *uflow_res);\n\nstatic inline void ib_set_flow(struct ib_uobject *uobj, struct ib_flow *ibflow,\n\t\t\t       struct ib_qp *qp, struct ib_device *device,\n\t\t\t       struct ib_uflow_resources *uflow_res)\n{\n\tstruct ib_uflow_object *uflow;\n\n\tuobj->object = ibflow;\n\tibflow->uobject = uobj;\n\n\tif (qp) {\n\t\tatomic_inc(&qp->usecnt);\n\t\tibflow->qp = qp;\n\t}\n\n\tibflow->device = device;\n\tuflow = container_of(uobj, typeof(*uflow), uobject);\n\tuflow->resources = uflow_res;\n}\n\nstruct uverbs_api_object {\n\tconst struct uverbs_obj_type *type_attrs;\n\tconst struct uverbs_obj_type_class *type_class;\n\tu8 disabled:1;\n\tu32 id;\n};\n\nstatic inline u32 uobj_get_object_id(struct ib_uobject *uobj)\n{\n\treturn uobj->uapi_object->id;\n}\n\n#endif\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}