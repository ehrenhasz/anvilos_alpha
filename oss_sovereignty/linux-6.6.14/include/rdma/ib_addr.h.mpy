{
  "module_name": "ib_addr.h",
  "hash_id": "23a0864516f7554c54496369032cf66bc1398e81c41c6fc9b039d6d610ad1256",
  "original_prompt": "Ingested from linux-6.6.14/include/rdma/ib_addr.h",
  "human_readable_source": " \n \n\n#ifndef IB_ADDR_H\n#define IB_ADDR_H\n\n#include <linux/ethtool.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/socket.h>\n#include <linux/if_vlan.h>\n#include <net/ipv6.h>\n#include <net/if_inet6.h>\n#include <net/ip.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_pack.h>\n#include <net/net_namespace.h>\n\n \nstruct rdma_dev_addr {\n\tunsigned char src_dev_addr[MAX_ADDR_LEN];\n\tunsigned char dst_dev_addr[MAX_ADDR_LEN];\n\tunsigned char broadcast[MAX_ADDR_LEN];\n\tunsigned short dev_type;\n\tint bound_dev_if;\n\tenum rdma_transport_type transport;\n\tstruct net *net;\n\tconst struct ib_gid_attr *sgid_attr;\n\tenum rdma_network_type network;\n\tint hoplimit;\n};\n\n \nint rdma_translate_ip(const struct sockaddr *addr,\n\t\t      struct rdma_dev_addr *dev_addr);\n\n \nint rdma_resolve_ip(struct sockaddr *src_addr, const struct sockaddr *dst_addr,\n\t\t    struct rdma_dev_addr *addr, unsigned long timeout_ms,\n\t\t    void (*callback)(int status, struct sockaddr *src_addr,\n\t\t\t\t     struct rdma_dev_addr *addr, void *context),\n\t\t    bool resolve_by_gid_attr, void *context);\n\nvoid rdma_addr_cancel(struct rdma_dev_addr *addr);\n\nint rdma_addr_size(const struct sockaddr *addr);\nint rdma_addr_size_in6(struct sockaddr_in6 *addr);\nint rdma_addr_size_kss(struct __kernel_sockaddr_storage *addr);\n\nstatic inline u16 ib_addr_get_pkey(struct rdma_dev_addr *dev_addr)\n{\n\treturn ((u16)dev_addr->broadcast[8] << 8) | (u16)dev_addr->broadcast[9];\n}\n\nstatic inline void ib_addr_set_pkey(struct rdma_dev_addr *dev_addr, u16 pkey)\n{\n\tdev_addr->broadcast[8] = pkey >> 8;\n\tdev_addr->broadcast[9] = (unsigned char) pkey;\n}\n\nstatic inline void ib_addr_get_mgid(struct rdma_dev_addr *dev_addr,\n\t\t\t\t    union ib_gid *gid)\n{\n\tmemcpy(gid, dev_addr->broadcast + 4, sizeof *gid);\n}\n\nstatic inline int rdma_addr_gid_offset(struct rdma_dev_addr *dev_addr)\n{\n\treturn dev_addr->dev_type == ARPHRD_INFINIBAND ? 4 : 0;\n}\n\nstatic inline u16 rdma_vlan_dev_vlan_id(const struct net_device *dev)\n{\n\treturn is_vlan_dev(dev) ? vlan_dev_vlan_id(dev) : 0xffff;\n}\n\nstatic inline int rdma_ip2gid(struct sockaddr *addr, union ib_gid *gid)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tipv6_addr_set_v4mapped(((struct sockaddr_in *)\n\t\t\t\t\taddr)->sin_addr.s_addr,\n\t\t\t\t       (struct in6_addr *)gid);\n\t\tbreak;\n\tcase AF_INET6:\n\t\t*(struct in6_addr *)&gid->raw =\n\t\t\t((struct sockaddr_in6 *)addr)->sin6_addr;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic inline void rdma_gid2ip(struct sockaddr *out, const union ib_gid *gid)\n{\n\tif (ipv6_addr_v4mapped((struct in6_addr *)gid)) {\n\t\tstruct sockaddr_in *out_in = (struct sockaddr_in *)out;\n\t\tmemset(out_in, 0, sizeof(*out_in));\n\t\tout_in->sin_family = AF_INET;\n\t\tmemcpy(&out_in->sin_addr.s_addr, gid->raw + 12, 4);\n\t} else {\n\t\tstruct sockaddr_in6 *out_in = (struct sockaddr_in6 *)out;\n\t\tmemset(out_in, 0, sizeof(*out_in));\n\t\tout_in->sin6_family = AF_INET6;\n\t\tmemcpy(&out_in->sin6_addr.s6_addr, gid->raw, 16);\n\t}\n}\n\n \nstatic inline void rdma_addr_get_sgid(struct rdma_dev_addr *dev_addr, union ib_gid *gid)\n{\n\tmemcpy(gid, dev_addr->src_dev_addr + rdma_addr_gid_offset(dev_addr),\n\t       sizeof(*gid));\n}\n\nstatic inline void rdma_addr_set_sgid(struct rdma_dev_addr *dev_addr, union ib_gid *gid)\n{\n\tmemcpy(dev_addr->src_dev_addr + rdma_addr_gid_offset(dev_addr), gid, sizeof *gid);\n}\n\nstatic inline void rdma_addr_get_dgid(struct rdma_dev_addr *dev_addr, union ib_gid *gid)\n{\n\tmemcpy(gid, dev_addr->dst_dev_addr + rdma_addr_gid_offset(dev_addr), sizeof *gid);\n}\n\nstatic inline void rdma_addr_set_dgid(struct rdma_dev_addr *dev_addr, union ib_gid *gid)\n{\n\tmemcpy(dev_addr->dst_dev_addr + rdma_addr_gid_offset(dev_addr), gid, sizeof *gid);\n}\n\nstatic inline enum ib_mtu iboe_get_mtu(int mtu)\n{\n\t \n\tmtu = mtu - (IB_GRH_BYTES + IB_UDP_BYTES + IB_BTH_BYTES +\n\t\t     IB_EXT_XRC_BYTES + IB_EXT_ATOMICETH_BYTES +\n\t\t     IB_ICRC_BYTES);\n\n\tif (mtu >= ib_mtu_enum_to_int(IB_MTU_4096))\n\t\treturn IB_MTU_4096;\n\telse if (mtu >= ib_mtu_enum_to_int(IB_MTU_2048))\n\t\treturn IB_MTU_2048;\n\telse if (mtu >= ib_mtu_enum_to_int(IB_MTU_1024))\n\t\treturn IB_MTU_1024;\n\telse if (mtu >= ib_mtu_enum_to_int(IB_MTU_512))\n\t\treturn IB_MTU_512;\n\telse if (mtu >= ib_mtu_enum_to_int(IB_MTU_256))\n\t\treturn IB_MTU_256;\n\telse\n\t\treturn 0;\n}\n\nstatic inline int rdma_link_local_addr(struct in6_addr *addr)\n{\n\tif (addr->s6_addr32[0] == htonl(0xfe800000) &&\n\t    addr->s6_addr32[1] == 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline void rdma_get_ll_mac(struct in6_addr *addr, u8 *mac)\n{\n\tmemcpy(mac, &addr->s6_addr[8], 3);\n\tmemcpy(mac + 3, &addr->s6_addr[13], 3);\n\tmac[0] ^= 2;\n}\n\nstatic inline int rdma_is_multicast_addr(struct in6_addr *addr)\n{\n\t__be32 ipv4_addr;\n\n\tif (addr->s6_addr[0] == 0xff)\n\t\treturn 1;\n\n\tipv4_addr = addr->s6_addr32[3];\n\treturn (ipv6_addr_v4mapped(addr) && ipv4_is_multicast(ipv4_addr));\n}\n\nstatic inline void rdma_get_mcast_mac(struct in6_addr *addr, u8 *mac)\n{\n\tint i;\n\n\tmac[0] = 0x33;\n\tmac[1] = 0x33;\n\tfor (i = 2; i < 6; ++i)\n\t\tmac[i] = addr->s6_addr[i + 10];\n}\n\nstatic inline u16 rdma_get_vlan_id(union ib_gid *dgid)\n{\n\tu16 vid;\n\n\tvid = dgid->raw[11] << 8 | dgid->raw[12];\n\treturn vid < 0x1000 ? vid : 0xffff;\n}\n\nstatic inline struct net_device *rdma_vlan_dev_real_dev(const struct net_device *dev)\n{\n\treturn is_vlan_dev(dev) ? vlan_dev_real_dev(dev) : NULL;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}