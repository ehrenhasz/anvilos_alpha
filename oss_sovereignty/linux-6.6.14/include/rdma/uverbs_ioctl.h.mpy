{
  "module_name": "uverbs_ioctl.h",
  "hash_id": "fa2781ddcb32d101e14a765dcca84a3a31d23795f882ff83585afb7bcded727f",
  "original_prompt": "Ingested from linux-6.6.14/include/rdma/uverbs_ioctl.h",
  "human_readable_source": " \n \n\n#ifndef _UVERBS_IOCTL_\n#define _UVERBS_IOCTL_\n\n#include <rdma/uverbs_types.h>\n#include <linux/uaccess.h>\n#include <rdma/rdma_user_ioctl.h>\n#include <rdma/ib_user_ioctl_verbs.h>\n#include <rdma/ib_user_ioctl_cmds.h>\n\n \n\nenum uverbs_attr_type {\n\tUVERBS_ATTR_TYPE_NA,\n\tUVERBS_ATTR_TYPE_PTR_IN,\n\tUVERBS_ATTR_TYPE_PTR_OUT,\n\tUVERBS_ATTR_TYPE_IDR,\n\tUVERBS_ATTR_TYPE_FD,\n\tUVERBS_ATTR_TYPE_RAW_FD,\n\tUVERBS_ATTR_TYPE_ENUM_IN,\n\tUVERBS_ATTR_TYPE_IDRS_ARRAY,\n};\n\nenum uverbs_obj_access {\n\tUVERBS_ACCESS_READ,\n\tUVERBS_ACCESS_WRITE,\n\tUVERBS_ACCESS_NEW,\n\tUVERBS_ACCESS_DESTROY\n};\n\n \n \nstruct uverbs_attr_spec {\n\tu8 type;\n\n\t \n\tu8 zero_trailing:1;\n\t \n\tu8 alloc_and_copy:1;\n\tu8 mandatory:1;\n\t \n\tu8 is_udata:1;\n\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\tu16 len;\n\t\t\t \n\t\t\tu16 min_len;\n\t\t} ptr;\n\n\t\tstruct {\n\t\t\t \n\t\t\tu16 obj_type;\n\t\t\tu8 access;\n\t\t} obj;\n\n\t\tstruct {\n\t\t\tu8 num_elems;\n\t\t} enum_def;\n\t} u;\n\n\t \n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\tconst struct uverbs_attr_spec *ids;\n\t\t} enum_def;\n\n\t\tstruct {\n\t\t\t \n\t\t\tu16\t\t\t\tobj_type;\n\t\t\tu16\t\t\t\tmin_len;\n\t\t\tu16\t\t\t\tmax_len;\n\t\t\tu8\t\t\t\taccess;\n\t\t} objs_arr;\n\t} u2;\n};\n\n \nenum uapi_radix_data {\n\tUVERBS_API_NS_FLAG = 1U << UVERBS_ID_NS_SHIFT,\n\n\tUVERBS_API_ATTR_KEY_BITS = 6,\n\tUVERBS_API_ATTR_KEY_MASK = GENMASK(UVERBS_API_ATTR_KEY_BITS - 1, 0),\n\tUVERBS_API_ATTR_BKEY_LEN = (1 << UVERBS_API_ATTR_KEY_BITS) - 1,\n\tUVERBS_API_WRITE_KEY_NUM = 1 << UVERBS_API_ATTR_KEY_BITS,\n\n\tUVERBS_API_METHOD_KEY_BITS = 5,\n\tUVERBS_API_METHOD_KEY_SHIFT = UVERBS_API_ATTR_KEY_BITS,\n\tUVERBS_API_METHOD_KEY_NUM_CORE = 22,\n\tUVERBS_API_METHOD_IS_WRITE = 30 << UVERBS_API_METHOD_KEY_SHIFT,\n\tUVERBS_API_METHOD_IS_WRITE_EX = 31 << UVERBS_API_METHOD_KEY_SHIFT,\n\tUVERBS_API_METHOD_KEY_NUM_DRIVER =\n\t\t(UVERBS_API_METHOD_IS_WRITE >> UVERBS_API_METHOD_KEY_SHIFT) -\n\t\tUVERBS_API_METHOD_KEY_NUM_CORE,\n\tUVERBS_API_METHOD_KEY_MASK = GENMASK(\n\t\tUVERBS_API_METHOD_KEY_BITS + UVERBS_API_METHOD_KEY_SHIFT - 1,\n\t\tUVERBS_API_METHOD_KEY_SHIFT),\n\n\tUVERBS_API_OBJ_KEY_BITS = 5,\n\tUVERBS_API_OBJ_KEY_SHIFT =\n\t\tUVERBS_API_METHOD_KEY_BITS + UVERBS_API_METHOD_KEY_SHIFT,\n\tUVERBS_API_OBJ_KEY_NUM_CORE = 20,\n\tUVERBS_API_OBJ_KEY_NUM_DRIVER =\n\t\t(1 << UVERBS_API_OBJ_KEY_BITS) - UVERBS_API_OBJ_KEY_NUM_CORE,\n\tUVERBS_API_OBJ_KEY_MASK = GENMASK(31, UVERBS_API_OBJ_KEY_SHIFT),\n\n\t \n\tUVERBS_API_KEY_ERR = 0xFFFFFFFF,\n};\n\nstatic inline __attribute_const__ u32 uapi_key_obj(u32 id)\n{\n\tif (id & UVERBS_API_NS_FLAG) {\n\t\tid &= ~UVERBS_API_NS_FLAG;\n\t\tif (id >= UVERBS_API_OBJ_KEY_NUM_DRIVER)\n\t\t\treturn UVERBS_API_KEY_ERR;\n\t\tid = id + UVERBS_API_OBJ_KEY_NUM_CORE;\n\t} else {\n\t\tif (id >= UVERBS_API_OBJ_KEY_NUM_CORE)\n\t\t\treturn UVERBS_API_KEY_ERR;\n\t}\n\n\treturn id << UVERBS_API_OBJ_KEY_SHIFT;\n}\n\nstatic inline __attribute_const__ bool uapi_key_is_object(u32 key)\n{\n\treturn (key & ~UVERBS_API_OBJ_KEY_MASK) == 0;\n}\n\nstatic inline __attribute_const__ u32 uapi_key_ioctl_method(u32 id)\n{\n\tif (id & UVERBS_API_NS_FLAG) {\n\t\tid &= ~UVERBS_API_NS_FLAG;\n\t\tif (id >= UVERBS_API_METHOD_KEY_NUM_DRIVER)\n\t\t\treturn UVERBS_API_KEY_ERR;\n\t\tid = id + UVERBS_API_METHOD_KEY_NUM_CORE;\n\t} else {\n\t\tid++;\n\t\tif (id >= UVERBS_API_METHOD_KEY_NUM_CORE)\n\t\t\treturn UVERBS_API_KEY_ERR;\n\t}\n\n\treturn id << UVERBS_API_METHOD_KEY_SHIFT;\n}\n\nstatic inline __attribute_const__ u32 uapi_key_write_method(u32 id)\n{\n\tif (id >= UVERBS_API_WRITE_KEY_NUM)\n\t\treturn UVERBS_API_KEY_ERR;\n\treturn UVERBS_API_METHOD_IS_WRITE | id;\n}\n\nstatic inline __attribute_const__ u32 uapi_key_write_ex_method(u32 id)\n{\n\tif (id >= UVERBS_API_WRITE_KEY_NUM)\n\t\treturn UVERBS_API_KEY_ERR;\n\treturn UVERBS_API_METHOD_IS_WRITE_EX | id;\n}\n\nstatic inline __attribute_const__ u32\nuapi_key_attr_to_ioctl_method(u32 attr_key)\n{\n\treturn attr_key &\n\t       (UVERBS_API_OBJ_KEY_MASK | UVERBS_API_METHOD_KEY_MASK);\n}\n\nstatic inline __attribute_const__ bool uapi_key_is_ioctl_method(u32 key)\n{\n\tunsigned int method = key & UVERBS_API_METHOD_KEY_MASK;\n\n\treturn method != 0 && method < UVERBS_API_METHOD_IS_WRITE &&\n\t       (key & UVERBS_API_ATTR_KEY_MASK) == 0;\n}\n\nstatic inline __attribute_const__ bool uapi_key_is_write_method(u32 key)\n{\n\treturn (key & UVERBS_API_METHOD_KEY_MASK) == UVERBS_API_METHOD_IS_WRITE;\n}\n\nstatic inline __attribute_const__ bool uapi_key_is_write_ex_method(u32 key)\n{\n\treturn (key & UVERBS_API_METHOD_KEY_MASK) ==\n\t       UVERBS_API_METHOD_IS_WRITE_EX;\n}\n\nstatic inline __attribute_const__ u32 uapi_key_attrs_start(u32 ioctl_method_key)\n{\n\t \n\treturn ioctl_method_key + 1;\n}\n\nstatic inline __attribute_const__ u32 uapi_key_attr(u32 id)\n{\n\t \n\tif (id & UVERBS_API_NS_FLAG) {\n\t\tid &= ~UVERBS_API_NS_FLAG;\n\t\tid++;\n\t\tif (id >= 1 << (UVERBS_API_ATTR_KEY_BITS - 1))\n\t\t\treturn UVERBS_API_KEY_ERR;\n\t\tid = (id << 1) | 0;\n\t} else {\n\t\tif (id >= 1 << (UVERBS_API_ATTR_KEY_BITS - 1))\n\t\t\treturn UVERBS_API_KEY_ERR;\n\t\tid = (id << 1) | 1;\n\t}\n\n\treturn id;\n}\n\n \nstatic inline __attribute_const__ bool uapi_key_is_attr(u32 key)\n{\n\tunsigned int method = key & UVERBS_API_METHOD_KEY_MASK;\n\n\treturn method != 0 && method < UVERBS_API_METHOD_IS_WRITE &&\n\t       (key & UVERBS_API_ATTR_KEY_MASK) != 0;\n}\n\n \nstatic inline __attribute_const__ u32 uapi_bkey_attr(u32 attr_key)\n{\n\treturn attr_key - 1;\n}\n\nstatic inline __attribute_const__ u32 uapi_bkey_to_key_attr(u32 attr_bkey)\n{\n\treturn attr_bkey + 1;\n}\n\n \n\nstruct uverbs_attr_def {\n\tu16                           id;\n\tstruct uverbs_attr_spec       attr;\n};\n\nstruct uverbs_method_def {\n\tu16                                  id;\n\t \n\tu32\t\t\t\t     flags;\n\tsize_t\t\t\t\t     num_attrs;\n\tconst struct uverbs_attr_def * const (*attrs)[];\n\tint (*handler)(struct uverbs_attr_bundle *attrs);\n};\n\nstruct uverbs_object_def {\n\tu16\t\t\t\t\t id;\n\tconst struct uverbs_obj_type\t        *type_attrs;\n\tsize_t\t\t\t\t         num_methods;\n\tconst struct uverbs_method_def * const (*methods)[];\n};\n\nenum uapi_definition_kind {\n\tUAPI_DEF_END = 0,\n\tUAPI_DEF_OBJECT_START,\n\tUAPI_DEF_WRITE,\n\tUAPI_DEF_CHAIN_OBJ_TREE,\n\tUAPI_DEF_CHAIN,\n\tUAPI_DEF_IS_SUPPORTED_FUNC,\n\tUAPI_DEF_IS_SUPPORTED_DEV_FN,\n};\n\nenum uapi_definition_scope {\n\tUAPI_SCOPE_OBJECT = 1,\n\tUAPI_SCOPE_METHOD = 2,\n};\n\nstruct uapi_definition {\n\tu8 kind;\n\tu8 scope;\n\tunion {\n\t\tstruct {\n\t\t\tu16 object_id;\n\t\t} object_start;\n\t\tstruct {\n\t\t\tu16 command_num;\n\t\t\tu8 is_ex:1;\n\t\t\tu8 has_udata:1;\n\t\t\tu8 has_resp:1;\n\t\t\tu8 req_size;\n\t\t\tu8 resp_size;\n\t\t} write;\n\t};\n\n\tunion {\n\t\tbool (*func_is_supported)(struct ib_device *device);\n\t\tint (*func_write)(struct uverbs_attr_bundle *attrs);\n\t\tconst struct uapi_definition *chain;\n\t\tconst struct uverbs_object_def *chain_obj_tree;\n\t\tsize_t needs_fn_offset;\n\t};\n};\n\n \n#define DECLARE_UVERBS_OBJECT(_object_id, ...)                                 \\\n\t{                                                                      \\\n\t\t.kind = UAPI_DEF_OBJECT_START,                                 \\\n\t\t.object_start = { .object_id = _object_id },                   \\\n\t},                                                                     \\\n\t\t##__VA_ARGS__\n\n \n#define DECLARE_UVERBS_WRITE(_command_num, _func, _cmd_desc, ...)              \\\n\t{                                                                      \\\n\t\t.kind = UAPI_DEF_WRITE,                                        \\\n\t\t.scope = UAPI_SCOPE_OBJECT,                                    \\\n\t\t.write = { .is_ex = 0, .command_num = _command_num },          \\\n\t\t.func_write = _func,                                           \\\n\t\t_cmd_desc,                                                     \\\n\t},                                                                     \\\n\t\t##__VA_ARGS__\n\n \n#define DECLARE_UVERBS_WRITE_EX(_command_num, _func, _cmd_desc, ...)           \\\n\t{                                                                      \\\n\t\t.kind = UAPI_DEF_WRITE,                                        \\\n\t\t.scope = UAPI_SCOPE_OBJECT,                                    \\\n\t\t.write = { .is_ex = 1, .command_num = _command_num },          \\\n\t\t.func_write = _func,                                           \\\n\t\t_cmd_desc,                                                     \\\n\t},                                                                     \\\n\t\t##__VA_ARGS__\n\n \n#define UAPI_DEF_OBJ_NEEDS_FN(ibdev_fn)                                        \\\n\t{                                                                      \\\n\t\t.kind = UAPI_DEF_IS_SUPPORTED_DEV_FN,                          \\\n\t\t.scope = UAPI_SCOPE_OBJECT,                                    \\\n\t\t.needs_fn_offset =                                             \\\n\t\t\toffsetof(struct ib_device_ops, ibdev_fn) +             \\\n\t\t\tBUILD_BUG_ON_ZERO(sizeof_field(struct ib_device_ops,   \\\n\t\t\t\t\t\t       ibdev_fn) !=            \\\n\t\t\t\t\t  sizeof(void *)),                     \\\n\t}\n\n \n#define UAPI_DEF_METHOD_NEEDS_FN(ibdev_fn)                                     \\\n\t{                                                                      \\\n\t\t.kind = UAPI_DEF_IS_SUPPORTED_DEV_FN,                          \\\n\t\t.scope = UAPI_SCOPE_METHOD,                                    \\\n\t\t.needs_fn_offset =                                             \\\n\t\t\toffsetof(struct ib_device_ops, ibdev_fn) +             \\\n\t\t\tBUILD_BUG_ON_ZERO(sizeof_field(struct ib_device_ops,   \\\n\t\t\t\t\t\t       ibdev_fn) !=            \\\n\t\t\t\t\t  sizeof(void *)),                     \\\n\t}\n\n \n#define UAPI_DEF_IS_OBJ_SUPPORTED(_func)                                       \\\n\t{                                                                      \\\n\t\t.kind = UAPI_DEF_IS_SUPPORTED_FUNC,                            \\\n\t\t.scope = UAPI_SCOPE_OBJECT, .func_is_supported = _func,        \\\n\t}\n\n \n#define UAPI_DEF_CHAIN(_def_var)                                               \\\n\t{                                                                      \\\n\t\t.kind = UAPI_DEF_CHAIN, .chain = _def_var,                     \\\n\t}\n\n \n#define UAPI_DEF_CHAIN_OBJ_TREE(_object_enum, _object_ptr, ...)                \\\n\t{                                                                      \\\n\t\t.kind = UAPI_DEF_CHAIN_OBJ_TREE,                               \\\n\t\t.object_start = { .object_id = _object_enum },                 \\\n\t\t.chain_obj_tree = _object_ptr,                                 \\\n\t},\t\t\t\t\t\t\t\t       \\\n\t\t##__VA_ARGS__\n#define UAPI_DEF_CHAIN_OBJ_TREE_NAMED(_object_enum, ...)                       \\\n\tUAPI_DEF_CHAIN_OBJ_TREE(_object_enum,\t\t\t\t       \\\n\t\tPTR_IF(IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS),\t       \\\n\t\t       &UVERBS_OBJECT(_object_enum)),\t\t\t       \\\n\t\t##__VA_ARGS__)\n\n \n\n#define UVERBS_ATTR_SIZE(_min_len, _len)\t\t\t\\\n\t.u.ptr.min_len = _min_len, .u.ptr.len = _len\n\n#define UVERBS_ATTR_NO_DATA() UVERBS_ATTR_SIZE(0, 0)\n\n \n#define UVERBS_ATTR_TYPE(_type)\t\t\t\t\t\\\n\t.u.ptr.min_len = sizeof(_type), .u.ptr.len = sizeof(_type)\n \n#define UVERBS_ATTR_STRUCT(_type, _last)                                       \\\n\t.zero_trailing = 1,                                                    \\\n\tUVERBS_ATTR_SIZE(offsetofend(_type, _last), sizeof(_type))\n \n#define UVERBS_ATTR_MIN_SIZE(_min_len) UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)\n\n \n#define UA_ALLOC_AND_COPY .alloc_and_copy = 1\n#define UA_MANDATORY .mandatory = 1\n#define UA_OPTIONAL .mandatory = 0\n\n \n#define UVERBS_ATTR_IDRS_ARR(_attr_id, _idr_type, _access, _min_len, _max_len, \\\n\t\t\t     ...)                                              \\\n\t(&(const struct uverbs_attr_def){                                      \\\n\t\t.id = (_attr_id) +                                             \\\n\t\t      BUILD_BUG_ON_ZERO((_min_len) == 0 ||                     \\\n\t\t\t\t\t(_max_len) >                           \\\n\t\t\t\t\t\tPAGE_SIZE / sizeof(void *) ||  \\\n\t\t\t\t\t(_min_len) > (_max_len) ||             \\\n\t\t\t\t\t(_access) == UVERBS_ACCESS_NEW ||      \\\n\t\t\t\t\t(_access) == UVERBS_ACCESS_DESTROY),   \\\n\t\t.attr = { .type = UVERBS_ATTR_TYPE_IDRS_ARRAY,                 \\\n\t\t\t  .u2.objs_arr.obj_type = _idr_type,                   \\\n\t\t\t  .u2.objs_arr.access = _access,                       \\\n\t\t\t  .u2.objs_arr.min_len = _min_len,                     \\\n\t\t\t  .u2.objs_arr.max_len = _max_len,                     \\\n\t\t\t  __VA_ARGS__ } })\n\n \n#define UVERBS_IDR_ANY_OBJECT 0xFFFF\n\n#define UVERBS_ATTR_IDR(_attr_id, _idr_type, _access, ...)                     \\\n\t(&(const struct uverbs_attr_def){                                      \\\n\t\t.id = _attr_id,                                                \\\n\t\t.attr = { .type = UVERBS_ATTR_TYPE_IDR,                        \\\n\t\t\t  .u.obj.obj_type = _idr_type,                         \\\n\t\t\t  .u.obj.access = _access,                             \\\n\t\t\t  __VA_ARGS__ } })\n\n#define UVERBS_ATTR_FD(_attr_id, _fd_type, _access, ...)                       \\\n\t(&(const struct uverbs_attr_def){                                      \\\n\t\t.id = (_attr_id) +                                             \\\n\t\t      BUILD_BUG_ON_ZERO((_access) != UVERBS_ACCESS_NEW &&      \\\n\t\t\t\t\t(_access) != UVERBS_ACCESS_READ),      \\\n\t\t.attr = { .type = UVERBS_ATTR_TYPE_FD,                         \\\n\t\t\t  .u.obj.obj_type = _fd_type,                          \\\n\t\t\t  .u.obj.access = _access,                             \\\n\t\t\t  __VA_ARGS__ } })\n\n#define UVERBS_ATTR_RAW_FD(_attr_id, ...)                                      \\\n\t(&(const struct uverbs_attr_def){                                      \\\n\t\t.id = (_attr_id),                                              \\\n\t\t.attr = { .type = UVERBS_ATTR_TYPE_RAW_FD, __VA_ARGS__ } })\n\n#define UVERBS_ATTR_PTR_IN(_attr_id, _type, ...)                               \\\n\t(&(const struct uverbs_attr_def){                                      \\\n\t\t.id = _attr_id,                                                \\\n\t\t.attr = { .type = UVERBS_ATTR_TYPE_PTR_IN,                     \\\n\t\t\t  _type,                                               \\\n\t\t\t  __VA_ARGS__ } })\n\n#define UVERBS_ATTR_PTR_OUT(_attr_id, _type, ...)                              \\\n\t(&(const struct uverbs_attr_def){                                      \\\n\t\t.id = _attr_id,                                                \\\n\t\t.attr = { .type = UVERBS_ATTR_TYPE_PTR_OUT,                    \\\n\t\t\t  _type,                                               \\\n\t\t\t  __VA_ARGS__ } })\n\n \n#define UVERBS_ATTR_ENUM_IN(_attr_id, _enum_arr, ...)                          \\\n\t(&(const struct uverbs_attr_def){                                      \\\n\t\t.id = _attr_id,                                                \\\n\t\t.attr = { .type = UVERBS_ATTR_TYPE_ENUM_IN,                    \\\n\t\t\t  .u2.enum_def.ids = _enum_arr,                        \\\n\t\t\t  .u.enum_def.num_elems = ARRAY_SIZE(_enum_arr),       \\\n\t\t\t  __VA_ARGS__ },                                       \\\n\t})\n\n \n#define UVERBS_ATTR_CONST_IN(_attr_id, _enum_type, ...)                        \\\n\tUVERBS_ATTR_PTR_IN(                                                    \\\n\t\t_attr_id,                                                      \\\n\t\tUVERBS_ATTR_SIZE(                                              \\\n\t\t\tsizeof(u64) + BUILD_BUG_ON_ZERO(!sizeof(_enum_type)),  \\\n\t\t\tsizeof(u64)),                                          \\\n\t\t__VA_ARGS__)\n\n \n#define UVERBS_ATTR_FLAGS_IN(_attr_id, _enum_type, ...)                        \\\n\tUVERBS_ATTR_PTR_IN(                                                    \\\n\t\t_attr_id,                                                      \\\n\t\tUVERBS_ATTR_SIZE(sizeof(u32) + BUILD_BUG_ON_ZERO(              \\\n\t\t\t\t\t\t       !sizeof(_enum_type *)), \\\n\t\t\t\t sizeof(u64)),                                 \\\n\t\t__VA_ARGS__)\n\n \n#define UVERBS_ATTR_UHW()                                                      \\\n\tUVERBS_ATTR_PTR_IN(UVERBS_ATTR_UHW_IN,                                 \\\n\t\t\t   UVERBS_ATTR_MIN_SIZE(0),\t\t\t       \\\n\t\t\t   UA_OPTIONAL,                                        \\\n\t\t\t   .is_udata = 1),\t\t\t\t       \\\n\tUVERBS_ATTR_PTR_OUT(UVERBS_ATTR_UHW_OUT,                               \\\n\t\t\t    UVERBS_ATTR_MIN_SIZE(0),\t\t\t       \\\n\t\t\t    UA_OPTIONAL,                                       \\\n\t\t\t    .is_udata = 1)\n\n \n\n\nstruct uverbs_ptr_attr {\n\t \n\tunion {\n\t\tvoid *ptr;\n\t\tu64 data;\n\t};\n\tu16\t\tlen;\n\tu16\t\tuattr_idx;\n\tu8\t\tenum_id;\n};\n\nstruct uverbs_obj_attr {\n\tstruct ib_uobject\t\t*uobject;\n\tconst struct uverbs_api_attr\t*attr_elm;\n};\n\nstruct uverbs_objs_arr_attr {\n\tstruct ib_uobject **uobjects;\n\tu16 len;\n};\n\nstruct uverbs_attr {\n\tunion {\n\t\tstruct uverbs_ptr_attr\tptr_attr;\n\t\tstruct uverbs_obj_attr\tobj_attr;\n\t\tstruct uverbs_objs_arr_attr objs_arr_attr;\n\t};\n};\n\nstruct uverbs_attr_bundle {\n\tstruct ib_udata driver_udata;\n\tstruct ib_udata ucore;\n\tstruct ib_uverbs_file *ufile;\n\tstruct ib_ucontext *context;\n\tstruct ib_uobject *uobject;\n\tDECLARE_BITMAP(attr_present, UVERBS_API_ATTR_BKEY_LEN);\n\tstruct uverbs_attr attrs[];\n};\n\nstatic inline bool uverbs_attr_is_valid(const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t\t\tunsigned int idx)\n{\n\treturn test_bit(uapi_bkey_attr(uapi_key_attr(idx)),\n\t\t\tattrs_bundle->attr_present);\n}\n\n \nstatic inline struct uverbs_attr_bundle *\nrdma_udata_to_uverbs_attr_bundle(struct ib_udata *udata)\n{\n\treturn container_of(udata, struct uverbs_attr_bundle, driver_udata);\n}\n\n#define rdma_udata_to_drv_context(udata, drv_dev_struct, member)                \\\n\t(udata ? container_of(rdma_udata_to_uverbs_attr_bundle(udata)->context, \\\n\t\t\t      drv_dev_struct, member) : (drv_dev_struct *)NULL)\n\n#define IS_UVERBS_COPY_ERR(_ret)\t\t((_ret) && (_ret) != -ENOENT)\n\nstatic inline const struct uverbs_attr *uverbs_attr_get(const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t\t\t\t\tu16 idx)\n{\n\tif (!uverbs_attr_is_valid(attrs_bundle, idx))\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn &attrs_bundle->attrs[uapi_bkey_attr(uapi_key_attr(idx))];\n}\n\nstatic inline int uverbs_attr_get_enum_id(const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t\t\t  u16 idx)\n{\n\tconst struct uverbs_attr *attr = uverbs_attr_get(attrs_bundle, idx);\n\n\tif (IS_ERR(attr))\n\t\treturn PTR_ERR(attr);\n\n\treturn attr->ptr_attr.enum_id;\n}\n\nstatic inline void *uverbs_attr_get_obj(const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t\t\tu16 idx)\n{\n\tconst struct uverbs_attr *attr;\n\n\tattr = uverbs_attr_get(attrs_bundle, idx);\n\tif (IS_ERR(attr))\n\t\treturn ERR_CAST(attr);\n\n\treturn attr->obj_attr.uobject->object;\n}\n\nstatic inline struct ib_uobject *uverbs_attr_get_uobject(const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t\t\t\t\t u16 idx)\n{\n\tconst struct uverbs_attr *attr = uverbs_attr_get(attrs_bundle, idx);\n\n\tif (IS_ERR(attr))\n\t\treturn ERR_CAST(attr);\n\n\treturn attr->obj_attr.uobject;\n}\n\nstatic inline int\nuverbs_attr_get_len(const struct uverbs_attr_bundle *attrs_bundle, u16 idx)\n{\n\tconst struct uverbs_attr *attr = uverbs_attr_get(attrs_bundle, idx);\n\n\tif (IS_ERR(attr))\n\t\treturn PTR_ERR(attr);\n\n\treturn attr->ptr_attr.len;\n}\n\nvoid uverbs_finalize_uobj_create(const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t\t u16 idx);\n\n \nstatic inline int\nuverbs_attr_ptr_get_array_size(struct uverbs_attr_bundle *attrs, u16 idx,\n\t\t\t       size_t elem_size)\n{\n\tint size = uverbs_attr_get_len(attrs, idx);\n\n\tif (size < 0)\n\t\treturn size;\n\n\tif (size % elem_size)\n\t\treturn -EINVAL;\n\n\treturn size / elem_size;\n}\n\n \nstatic inline int uverbs_attr_get_uobjs_arr(\n\tconst struct uverbs_attr_bundle *attrs_bundle, u16 attr_idx,\n\tstruct ib_uobject ***arr)\n{\n\tconst struct uverbs_attr *attr =\n\t\t\tuverbs_attr_get(attrs_bundle, attr_idx);\n\n\tif (IS_ERR(attr)) {\n\t\t*arr = NULL;\n\t\treturn 0;\n\t}\n\n\t*arr = attr->objs_arr_attr.uobjects;\n\n\treturn attr->objs_arr_attr.len;\n}\n\nstatic inline bool uverbs_attr_ptr_is_inline(const struct uverbs_attr *attr)\n{\n\treturn attr->ptr_attr.len <= sizeof(attr->ptr_attr.data);\n}\n\nstatic inline void *uverbs_attr_get_alloced_ptr(\n\tconst struct uverbs_attr_bundle *attrs_bundle, u16 idx)\n{\n\tconst struct uverbs_attr *attr = uverbs_attr_get(attrs_bundle, idx);\n\n\tif (IS_ERR(attr))\n\t\treturn (void *)attr;\n\n\treturn uverbs_attr_ptr_is_inline(attr) ? (void *)&attr->ptr_attr.data :\n\t\t\t\t\t\t attr->ptr_attr.ptr;\n}\n\nstatic inline int _uverbs_copy_from(void *to,\n\t\t\t\t    const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t\t    size_t idx,\n\t\t\t\t    size_t size)\n{\n\tconst struct uverbs_attr *attr = uverbs_attr_get(attrs_bundle, idx);\n\n\tif (IS_ERR(attr))\n\t\treturn PTR_ERR(attr);\n\n\t \n\tif (unlikely(size < attr->ptr_attr.len))\n\t\treturn -EINVAL;\n\n\tif (uverbs_attr_ptr_is_inline(attr))\n\t\tmemcpy(to, &attr->ptr_attr.data, attr->ptr_attr.len);\n\telse if (copy_from_user(to, u64_to_user_ptr(attr->ptr_attr.data),\n\t\t\t\tattr->ptr_attr.len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic inline int _uverbs_copy_from_or_zero(void *to,\n\t\t\t\t\t    const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t\t\t    size_t idx,\n\t\t\t\t\t    size_t size)\n{\n\tconst struct uverbs_attr *attr = uverbs_attr_get(attrs_bundle, idx);\n\tsize_t min_size;\n\n\tif (IS_ERR(attr))\n\t\treturn PTR_ERR(attr);\n\n\tmin_size = min_t(size_t, size, attr->ptr_attr.len);\n\n\tif (uverbs_attr_ptr_is_inline(attr))\n\t\tmemcpy(to, &attr->ptr_attr.data, min_size);\n\telse if (copy_from_user(to, u64_to_user_ptr(attr->ptr_attr.data),\n\t\t\t\tmin_size))\n\t\treturn -EFAULT;\n\n\tif (size > min_size)\n\t\tmemset(to + min_size, 0, size - min_size);\n\n\treturn 0;\n}\n\n#define uverbs_copy_from(to, attrs_bundle, idx)\t\t\t\t      \\\n\t_uverbs_copy_from(to, attrs_bundle, idx, sizeof(*to))\n\n#define uverbs_copy_from_or_zero(to, attrs_bundle, idx)\t\t\t      \\\n\t_uverbs_copy_from_or_zero(to, attrs_bundle, idx, sizeof(*to))\n\nstatic inline struct ib_ucontext *\nib_uverbs_get_ucontext(const struct uverbs_attr_bundle *attrs)\n{\n\treturn ib_uverbs_get_ucontext_file(attrs->ufile);\n}\n\n#if IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS)\nint uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,\n\t\t       size_t idx, u64 allowed_bits);\nint uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,\n\t\t       size_t idx, u64 allowed_bits);\nint uverbs_copy_to(const struct uverbs_attr_bundle *attrs_bundle, size_t idx,\n\t\t   const void *from, size_t size);\n__malloc void *_uverbs_alloc(struct uverbs_attr_bundle *bundle, size_t size,\n\t\t\t     gfp_t flags);\n\nstatic inline __malloc void *uverbs_alloc(struct uverbs_attr_bundle *bundle,\n\t\t\t\t\t  size_t size)\n{\n\treturn _uverbs_alloc(bundle, size, GFP_KERNEL);\n}\n\nstatic inline __malloc void *uverbs_zalloc(struct uverbs_attr_bundle *bundle,\n\t\t\t\t\t   size_t size)\n{\n\treturn _uverbs_alloc(bundle, size, GFP_KERNEL | __GFP_ZERO);\n}\n\nstatic inline __malloc void *uverbs_kcalloc(struct uverbs_attr_bundle *bundle,\n\t\t\t\t\t    size_t n, size_t size)\n{\n\tsize_t bytes;\n\n\tif (unlikely(check_mul_overflow(n, size, &bytes)))\n\t\treturn ERR_PTR(-EOVERFLOW);\n\treturn uverbs_zalloc(bundle, bytes);\n}\n\nint _uverbs_get_const_signed(s64 *to,\n\t\t\t     const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t     size_t idx, s64 lower_bound, u64 upper_bound,\n\t\t\t     s64 *def_val);\nint _uverbs_get_const_unsigned(u64 *to,\n\t\t\t       const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t       size_t idx, u64 upper_bound, u64 *def_val);\nint uverbs_copy_to_struct_or_zero(const struct uverbs_attr_bundle *bundle,\n\t\t\t\t  size_t idx, const void *from, size_t size);\n#else\nstatic inline int\nuverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,\n\t\t   size_t idx, u64 allowed_bits)\n{\n\treturn -EINVAL;\n}\nstatic inline int\nuverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,\n\t\t   size_t idx, u64 allowed_bits)\n{\n\treturn -EINVAL;\n}\nstatic inline int uverbs_copy_to(const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t\t size_t idx, const void *from, size_t size)\n{\n\treturn -EINVAL;\n}\nstatic inline __malloc void *uverbs_alloc(struct uverbs_attr_bundle *bundle,\n\t\t\t\t\t  size_t size)\n{\n\treturn ERR_PTR(-EINVAL);\n}\nstatic inline __malloc void *uverbs_zalloc(struct uverbs_attr_bundle *bundle,\n\t\t\t\t\t   size_t size)\n{\n\treturn ERR_PTR(-EINVAL);\n}\nstatic inline int\n_uverbs_get_const(s64 *to, const struct uverbs_attr_bundle *attrs_bundle,\n\t\t  size_t idx, s64 lower_bound, u64 upper_bound,\n\t\t  s64 *def_val)\n{\n\treturn -EINVAL;\n}\nstatic inline int\nuverbs_copy_to_struct_or_zero(const struct uverbs_attr_bundle *bundle,\n\t\t\t      size_t idx, const void *from, size_t size)\n{\n\treturn -EINVAL;\n}\nstatic inline int\n_uverbs_get_const_signed(s64 *to,\n\t\t\t const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t size_t idx, s64 lower_bound, u64 upper_bound,\n\t\t\t s64 *def_val)\n{\n\treturn -EINVAL;\n}\nstatic inline int\n_uverbs_get_const_unsigned(u64 *to,\n\t\t\t   const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t   size_t idx, u64 upper_bound, u64 *def_val)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#define uverbs_get_const_signed(_to, _attrs_bundle, _idx)                      \\\n\t({                                                                     \\\n\t\ts64 _val;                                                      \\\n\t\tint _ret =                                                     \\\n\t\t\t_uverbs_get_const_signed(&_val, _attrs_bundle, _idx,   \\\n\t\t\t\t\t  type_min(typeof(*(_to))),            \\\n\t\t\t\t\t  type_max(typeof(*(_to))), NULL);     \\\n\t\t(*(_to)) = _val;                                               \\\n\t\t_ret;                                                          \\\n\t})\n\n#define uverbs_get_const_unsigned(_to, _attrs_bundle, _idx)                    \\\n\t({                                                                     \\\n\t\tu64 _val;                                                      \\\n\t\tint _ret =                                                     \\\n\t\t\t_uverbs_get_const_unsigned(&_val, _attrs_bundle, _idx, \\\n\t\t\t\t\t  type_max(typeof(*(_to))), NULL);     \\\n\t\t(*(_to)) = _val;                                               \\\n\t\t_ret;                                                          \\\n\t})\n\n#define uverbs_get_const_default_signed(_to, _attrs_bundle, _idx, _default)    \\\n\t({                                                                     \\\n\t\ts64 _val;                                                      \\\n\t\ts64 _def_val = _default;                                       \\\n\t\tint _ret =                                                     \\\n\t\t\t_uverbs_get_const_signed(&_val, _attrs_bundle, _idx,   \\\n\t\t\t\ttype_min(typeof(*(_to))),                      \\\n\t\t\t\ttype_max(typeof(*(_to))), &_def_val);          \\\n\t\t(*(_to)) = _val;                                               \\\n\t\t_ret;                                                          \\\n\t})\n\n#define uverbs_get_const_default_unsigned(_to, _attrs_bundle, _idx, _default)  \\\n\t({                                                                     \\\n\t\tu64 _val;                                                      \\\n\t\tu64 _def_val = _default;                                       \\\n\t\tint _ret =                                                     \\\n\t\t\t_uverbs_get_const_unsigned(&_val, _attrs_bundle, _idx, \\\n\t\t\t\ttype_max(typeof(*(_to))), &_def_val);          \\\n\t\t(*(_to)) = _val;                                               \\\n\t\t_ret;                                                          \\\n\t})\n\n#define uverbs_get_const(_to, _attrs_bundle, _idx)                             \\\n\t(is_signed_type(typeof(*(_to))) ?                                      \\\n\t\t uverbs_get_const_signed(_to, _attrs_bundle, _idx) :           \\\n\t\t uverbs_get_const_unsigned(_to, _attrs_bundle, _idx))          \\\n\n#define uverbs_get_const_default(_to, _attrs_bundle, _idx, _default)           \\\n\t(is_signed_type(typeof(*(_to))) ?                                      \\\n\t\t uverbs_get_const_default_signed(_to, _attrs_bundle, _idx,     \\\n\t\t\t\t\t\t  _default) :                  \\\n\t\t uverbs_get_const_default_unsigned(_to, _attrs_bundle, _idx,   \\\n\t\t\t\t\t\t    _default))\n\nstatic inline int\nuverbs_get_raw_fd(int *to, const struct uverbs_attr_bundle *attrs_bundle,\n\t\t  size_t idx)\n{\n\treturn uverbs_get_const_signed(to, attrs_bundle, idx);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}