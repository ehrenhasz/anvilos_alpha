{
  "module_name": "rdma_vt.h",
  "hash_id": "ae6b243549d2523b6a52e3ec5f094d4f2c10416b9550521ca3b2caaf108e093a",
  "original_prompt": "Ingested from linux-6.6.14/include/rdma/rdma_vt.h",
  "human_readable_source": " \n \n\n#ifndef DEF_RDMA_VT_H\n#define DEF_RDMA_VT_H\n\n \n\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_mad.h>\n#include <rdma/rdmavt_mr.h>\n\n#define RVT_MAX_PKEY_VALUES 16\n\n#define RVT_MAX_TRAP_LEN 100  \n#define RVT_MAX_TRAP_LISTS 5  \n#define RVT_TRAP_TIMEOUT 4096  \n\nstruct trap_list {\n\tu32 list_len;\n\tstruct list_head list;\n};\n\nstruct rvt_qp;\nstruct rvt_qpn_table;\nstruct rvt_ibport {\n\tstruct rvt_qp __rcu *qp[2];\n\tstruct ib_mad_agent *send_agent;\t \n\tstruct rb_root mcast_tree;\n\tspinlock_t lock;\t\t \n\n\t \n\tunsigned long mkey_lease_timeout;\n\tunsigned long trap_timeout;\n\t__be64 gid_prefix;       \n\t__be64 mkey;\n\tu64 tid;\n\tu32 port_cap_flags;\n\tu16 port_cap3_flags;\n\tu32 pma_sample_start;\n\tu32 pma_sample_interval;\n\t__be16 pma_counter_select[5];\n\tu16 pma_tag;\n\tu16 mkey_lease_period;\n\tu32 sm_lid;\n\tu8 sm_sl;\n\tu8 mkeyprot;\n\tu8 subnet_timeout;\n\tu8 vl_high_limit;\n\n\t \n\tu64 n_rc_resends;\n\tu64 n_seq_naks;\n\tu64 n_rdma_seq;\n\tu64 n_rnr_naks;\n\tu64 n_other_naks;\n\tu64 n_loop_pkts;\n\tu64 n_pkt_drops;\n\tu64 n_vl15_dropped;\n\tu64 n_rc_timeouts;\n\tu64 n_dmawait;\n\tu64 n_unaligned;\n\tu64 n_rc_dupreq;\n\tu64 n_rc_seqnak;\n\tu64 n_rc_crwaits;\n\tu16 pkey_violations;\n\tu16 qkey_violations;\n\tu16 mkey_violations;\n\n\t \n\tu64 z_rc_acks;\n\tu64 z_rc_qacks;\n\tu64 z_rc_delayed_comp;\n\tu64 __percpu *rc_acks;\n\tu64 __percpu *rc_qacks;\n\tu64 __percpu *rc_delayed_comp;\n\n\tvoid *priv;  \n\n\t \n\tu16 *pkey_table;\n\n\tstruct rvt_ah *sm_ah;\n\n\t \n\tstruct trap_list trap_lists[RVT_MAX_TRAP_LISTS];\n\tstruct timer_list trap_timer;\n};\n\n#define RVT_CQN_MAX 16  \n\n#define RVT_SGE_COPY_MEMCPY\t0\n#define RVT_SGE_COPY_CACHELESS\t1\n#define RVT_SGE_COPY_ADAPTIVE\t2\n\n \nstruct rvt_driver_params {\n\tstruct ib_device_attr props;\n\n\t \n\tunsigned int lkey_table_size;\n\tunsigned int qp_table_size;\n\tunsigned int sge_copy_mode;\n\tunsigned int wss_threshold;\n\tunsigned int wss_clean_period;\n\tint qpn_start;\n\tint qpn_inc;\n\tint qpn_res_start;\n\tint qpn_res_end;\n\tint nports;\n\tint npkeys;\n\tint node;\n\tint psn_mask;\n\tint psn_shift;\n\tint psn_modify_mask;\n\tu32 core_cap_flags;\n\tu32 max_mad_size;\n\tu8 qos_shift;\n\tu8 max_rdma_atomic;\n\tu8 extra_rdma_atomic;\n\tu8 reserved_operations;\n};\n\n \nstruct rvt_ucontext {\n\tstruct ib_ucontext ibucontext;\n};\n\n \nstruct rvt_pd {\n\tstruct ib_pd ibpd;\n\tbool user;\n};\n\n \nstruct rvt_ah {\n\tstruct ib_ah ibah;\n\tstruct rdma_ah_attr attr;\n\tu8 vl;\n\tu8 log_pmtu;\n};\n\n \nstruct rvt_mmap_info {\n\tstruct list_head pending_mmaps;\n\tstruct ib_ucontext *context;\n\tvoid *obj;\n\t__u64 offset;\n\tstruct kref ref;\n\tu32 size;\n};\n\n \nstruct rvt_wss {\n\tunsigned long *entries;\n\tatomic_t total_count;\n\tatomic_t clean_counter;\n\tatomic_t clean_entry;\n\n\tint threshold;\n\tint num_entries;\n\tlong pages_mask;\n\tunsigned int clean_period;\n};\n\nstruct rvt_dev_info;\nstruct rvt_swqe;\nstruct rvt_driver_provided {\n\t \n\n\t \n\n\t \n\tbool (*schedule_send)(struct rvt_qp *qp);\n\tbool (*schedule_send_no_lock)(struct rvt_qp *qp);\n\n\t \n\tint (*setup_wqe)(struct rvt_qp *qp, struct rvt_swqe *wqe,\n\t\t\t bool *call_send);\n\n\t \n\tvoid (*do_send)(struct rvt_qp *qp);\n\n\t \n\tstruct pci_dev * (*get_pci_dev)(struct rvt_dev_info *rdi);\n\n\t \n\tvoid * (*qp_priv_alloc)(struct rvt_dev_info *rdi, struct rvt_qp *qp);\n\n\t \n\tint (*qp_priv_init)(struct rvt_dev_info *rdi, struct rvt_qp *qp,\n\t\t\t    struct ib_qp_init_attr *init_attr);\n\n\t \n\tvoid (*qp_priv_free)(struct rvt_dev_info *rdi, struct rvt_qp *qp);\n\n\t \n\tvoid (*notify_qp_reset)(struct rvt_qp *qp);\n\n\t \n\tint (*get_pmtu_from_attr)(struct rvt_dev_info *rdi, struct rvt_qp *qp,\n\t\t\t\t  struct ib_qp_attr *attr);\n\n\t \n\tvoid (*flush_qp_waiters)(struct rvt_qp *qp);\n\n\t \n\tvoid (*stop_send_queue)(struct rvt_qp *qp);\n\n\t \n\tvoid (*quiesce_qp)(struct rvt_qp *qp);\n\n\t \n\tvoid (*notify_error_qp)(struct rvt_qp *qp);\n\n\t \n\tu32 (*mtu_from_qp)(struct rvt_dev_info *rdi, struct rvt_qp *qp,\n\t\t\t   u32 pmtu);\n\t \n\tint (*mtu_to_path_mtu)(u32 mtu);\n\n\t \n\tint (*get_guid_be)(struct rvt_dev_info *rdi, struct rvt_ibport *rvp,\n\t\t\t   int guid_index, __be64 *guid);\n\n\t \n\tint (*query_port_state)(struct rvt_dev_info *rdi, u32 port_num,\n\t\t\t\tstruct ib_port_attr *props);\n\n\t \n\tint (*shut_down_port)(struct rvt_dev_info *rdi, u32 port_num);\n\n\t \n\tvoid (*cap_mask_chg)(struct rvt_dev_info *rdi, u32 port_num);\n\n\t \n\n\t \n\tunsigned (*free_all_qps)(struct rvt_dev_info *rdi);\n\n\t \n\tint (*check_ah)(struct ib_device *, struct rdma_ah_attr *);\n\n\t \n\tvoid (*notify_new_ah)(struct ib_device *, struct rdma_ah_attr *,\n\t\t\t      struct rvt_ah *);\n\n\t \n\tint (*alloc_qpn)(struct rvt_dev_info *rdi, struct rvt_qpn_table *qpt,\n\t\t\t enum ib_qp_type type, u32 port_num);\n\n\t \n\tint (*check_modify_qp)(struct rvt_qp *qp, struct ib_qp_attr *attr,\n\t\t\t       int attr_mask, struct ib_udata *udata);\n\n\t \n\tvoid (*modify_qp)(struct rvt_qp *qp, struct ib_qp_attr *attr,\n\t\t\t  int attr_mask, struct ib_udata *udata);\n\n\t \n\tvoid (*notify_create_mad_agent)(struct rvt_dev_info *rdi, int port_idx);\n\n\t \n\tvoid (*notify_free_mad_agent)(struct rvt_dev_info *rdi, int port_idx);\n\n\t \n\tvoid (*notify_restart_rc)(struct rvt_qp *qp, u32 psn, int wait);\n\n\t \n\tint (*comp_vect_cpu_lookup)(struct rvt_dev_info *rdi, int comp_vect);\n};\n\nstruct rvt_dev_info {\n\tstruct ib_device ibdev;  \n\n\t \n\n\t \n\tstruct rvt_driver_params dparms;\n\n\t \n\tconst struct rvt_operation_params *post_parms;\n\n\t \n\tconst enum ib_wc_opcode *wc_opcode;\n\n\t \n\tstruct rvt_driver_provided driver_f;\n\n\tstruct rvt_mregion __rcu *dma_mr;\n\tstruct rvt_lkey_table lkey_table;\n\n\t \n\tint n_pds_allocated;\n\tspinlock_t n_pds_lock;  \n\n\tint n_ahs_allocated;\n\tspinlock_t n_ahs_lock;  \n\n\tu32 n_srqs_allocated;\n\tspinlock_t n_srqs_lock;  \n\n\tint flags;\n\tstruct rvt_ibport **ports;\n\n\t \n\tstruct rvt_qp_ibdev *qp_dev;\n\tu32 n_qps_allocated;     \n\tu32 n_rc_qps;\t\t \n\tu32 busy_jiffies;\t \n\tspinlock_t n_qps_lock;\t \n\n\t \n\tstruct list_head pending_mmaps;\n\tspinlock_t mmap_offset_lock;  \n\tu32 mmap_offset;\n\tspinlock_t pending_lock;  \n\n\t \n\tu32 n_cqs_allocated;     \n\tspinlock_t n_cqs_lock;  \n\n\t \n\tu32 n_mcast_grps_allocated;  \n\tspinlock_t n_mcast_grps_lock;\n\n\t \n\tstruct rvt_wss *wss;\n};\n\n \nstatic inline void rvt_set_ibdev_name(struct rvt_dev_info *rdi,\n\t\t\t\t      const char *fmt, const char *name,\n\t\t\t\t      const int unit)\n{\n\t \n\tdev_set_name(&rdi->ibdev.dev, fmt, name, unit);\n\tstrscpy(rdi->ibdev.name, dev_name(&rdi->ibdev.dev), IB_DEVICE_NAME_MAX);\n}\n\n \nstatic inline const char *rvt_get_ibdev_name(const struct rvt_dev_info *rdi)\n{\n\treturn dev_name(&rdi->ibdev.dev);\n}\n\nstatic inline struct rvt_pd *ibpd_to_rvtpd(struct ib_pd *ibpd)\n{\n\treturn container_of(ibpd, struct rvt_pd, ibpd);\n}\n\nstatic inline struct rvt_ah *ibah_to_rvtah(struct ib_ah *ibah)\n{\n\treturn container_of(ibah, struct rvt_ah, ibah);\n}\n\nstatic inline struct rvt_dev_info *ib_to_rvt(struct ib_device *ibdev)\n{\n\treturn  container_of(ibdev, struct rvt_dev_info, ibdev);\n}\n\nstatic inline unsigned rvt_get_npkeys(struct rvt_dev_info *rdi)\n{\n\t \n\treturn rdi->dparms.npkeys;\n}\n\n \nstatic inline unsigned int rvt_max_atomic(struct rvt_dev_info *rdi)\n{\n\treturn rdi->dparms.max_rdma_atomic +\n\t\trdi->dparms.extra_rdma_atomic + 1;\n}\n\nstatic inline unsigned int rvt_size_atomic(struct rvt_dev_info *rdi)\n{\n\treturn rdi->dparms.max_rdma_atomic +\n\t\trdi->dparms.extra_rdma_atomic;\n}\n\n \nstatic inline u16 rvt_get_pkey(struct rvt_dev_info *rdi,\n\t\t\t       int port_index,\n\t\t\t       unsigned index)\n{\n\tif (index >= rvt_get_npkeys(rdi))\n\t\treturn 0;\n\telse\n\t\treturn rdi->ports[port_index]->pkey_table[index];\n}\n\nstruct rvt_dev_info *rvt_alloc_device(size_t size, int nports);\nvoid rvt_dealloc_device(struct rvt_dev_info *rdi);\nint rvt_register_device(struct rvt_dev_info *rvd);\nvoid rvt_unregister_device(struct rvt_dev_info *rvd);\nint rvt_check_ah(struct ib_device *ibdev, struct rdma_ah_attr *ah_attr);\nint rvt_init_port(struct rvt_dev_info *rdi, struct rvt_ibport *port,\n\t\t  int port_index, u16 *pkey_table);\nint rvt_fast_reg_mr(struct rvt_qp *qp, struct ib_mr *ibmr, u32 key,\n\t\t    int access);\nint rvt_invalidate_rkey(struct rvt_qp *qp, u32 rkey);\nint rvt_rkey_ok(struct rvt_qp *qp, struct rvt_sge *sge,\n\t\tu32 len, u64 vaddr, u32 rkey, int acc);\nint rvt_lkey_ok(struct rvt_lkey_table *rkt, struct rvt_pd *pd,\n\t\tstruct rvt_sge *isge, struct rvt_sge *last_sge,\n\t\tstruct ib_sge *sge, int acc);\nstruct rvt_mcast *rvt_mcast_find(struct rvt_ibport *ibp, union ib_gid *mgid,\n\t\t\t\t u16 lid);\n\n#endif           \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}