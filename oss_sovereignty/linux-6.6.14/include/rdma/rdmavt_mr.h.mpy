{
  "module_name": "rdmavt_mr.h",
  "hash_id": "bbce9f26b6fa5a9df01dab4393f571d9fdaf943a38079f7eb7179e2349badbb1",
  "original_prompt": "Ingested from linux-6.6.14/include/rdma/rdmavt_mr.h",
  "human_readable_source": " \n \n\n#ifndef DEF_RDMAVT_INCMR_H\n#define DEF_RDMAVT_INCMR_H\n\n \n#include <linux/percpu-refcount.h>\n\n \nstruct rvt_seg {\n\tvoid *vaddr;\n\tsize_t length;\n};\n\n \n#define RVT_SEGSZ     (PAGE_SIZE / sizeof(struct rvt_seg))\n\nstruct rvt_segarray {\n\tstruct rvt_seg segs[RVT_SEGSZ];\n};\n\nstruct rvt_mregion {\n\tstruct ib_pd *pd;        \n\tu64 user_base;           \n\tu64 iova;                \n\tsize_t length;\n\tu32 lkey;\n\tu32 offset;              \n\tint access_flags;\n\tu32 max_segs;            \n\tu32 mapsz;               \n\tatomic_t lkey_invalid;\t \n\tu8  page_shift;          \n\tu8  lkey_published;      \n\tstruct percpu_ref refcount;\n\tstruct completion comp;  \n\tstruct rvt_segarray *map[];     \n};\n\n#define RVT_MAX_LKEY_TABLE_BITS 23\n\nstruct rvt_lkey_table {\n\t \n\tu32 max;                 \n\tu32 shift;               \n\tstruct rvt_mregion __rcu **table;\n\t \n\t \n\tspinlock_t lock ____cacheline_aligned_in_smp;\n\tu32 next;                \n\tu32 gen;                 \n};\n\n \nstruct rvt_sge {\n\tstruct rvt_mregion *mr;\n\tvoid *vaddr;             \n\tu32 sge_length;          \n\tu32 length;              \n\tu16 m;                   \n\tu16 n;                   \n};\n\nstruct rvt_sge_state {\n\tstruct rvt_sge *sg_list;       \n\tstruct rvt_sge sge;    \n\tu32 total_len;\n\tu8 num_sge;\n};\n\nstatic inline void rvt_put_mr(struct rvt_mregion *mr)\n{\n\tpercpu_ref_put(&mr->refcount);\n}\n\nstatic inline void rvt_get_mr(struct rvt_mregion *mr)\n{\n\tpercpu_ref_get(&mr->refcount);\n}\n\nstatic inline void rvt_put_ss(struct rvt_sge_state *ss)\n{\n\twhile (ss->num_sge) {\n\t\trvt_put_mr(ss->sge.mr);\n\t\tif (--ss->num_sge)\n\t\t\tss->sge = *ss->sg_list++;\n\t}\n}\n\nstatic inline u32 rvt_get_sge_length(struct rvt_sge *sge, u32 length)\n{\n\tu32 len = sge->length;\n\n\tif (len > length)\n\t\tlen = length;\n\tif (len > sge->sge_length)\n\t\tlen = sge->sge_length;\n\n\treturn len;\n}\n\nstatic inline void rvt_update_sge(struct rvt_sge_state *ss, u32 length,\n\t\t\t\t  bool release)\n{\n\tstruct rvt_sge *sge = &ss->sge;\n\n\tsge->vaddr += length;\n\tsge->length -= length;\n\tsge->sge_length -= length;\n\tif (sge->sge_length == 0) {\n\t\tif (release)\n\t\t\trvt_put_mr(sge->mr);\n\t\tif (--ss->num_sge)\n\t\t\t*sge = *ss->sg_list++;\n\t} else if (sge->length == 0 && sge->mr->lkey) {\n\t\tif (++sge->n >= RVT_SEGSZ) {\n\t\t\tif (++sge->m >= sge->mr->mapsz)\n\t\t\t\treturn;\n\t\t\tsge->n = 0;\n\t\t}\n\t\tsge->vaddr = sge->mr->map[sge->m]->segs[sge->n].vaddr;\n\t\tsge->length = sge->mr->map[sge->m]->segs[sge->n].length;\n\t}\n}\n\nstatic inline void rvt_skip_sge(struct rvt_sge_state *ss, u32 length,\n\t\t\t\tbool release)\n{\n\tstruct rvt_sge *sge = &ss->sge;\n\n\twhile (length) {\n\t\tu32 len = rvt_get_sge_length(sge, length);\n\n\t\tWARN_ON_ONCE(len == 0);\n\t\trvt_update_sge(ss, len, release);\n\t\tlength -= len;\n\t}\n}\n\nbool rvt_ss_has_lkey(struct rvt_sge_state *ss, u32 lkey);\nbool rvt_mr_has_lkey(struct rvt_mregion *mr, u32 lkey);\n\n#endif           \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}