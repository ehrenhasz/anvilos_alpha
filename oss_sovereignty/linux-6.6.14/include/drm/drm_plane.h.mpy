{
  "module_name": "drm_plane.h",
  "hash_id": "16953c3bf3e2ea8cc3ced0dbe71a8d75057429e162052f664779f2f271e69a11",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_plane.h",
  "human_readable_source": " \n\n#ifndef __DRM_PLANE_H__\n#define __DRM_PLANE_H__\n\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <drm/drm_mode_object.h>\n#include <drm/drm_color_mgmt.h>\n#include <drm/drm_rect.h>\n#include <drm/drm_modeset_lock.h>\n#include <drm/drm_util.h>\n\nstruct drm_crtc;\nstruct drm_printer;\nstruct drm_modeset_acquire_ctx;\n\nenum drm_scaling_filter {\n\tDRM_SCALING_FILTER_DEFAULT,\n\tDRM_SCALING_FILTER_NEAREST_NEIGHBOR,\n};\n\n \nstruct drm_plane_state {\n\t \n\tstruct drm_plane *plane;\n\n\t \n\tstruct drm_crtc *crtc;\n\n\t \n\tstruct drm_framebuffer *fb;\n\n\t \n\tstruct dma_fence *fence;\n\n\t \n\n\tint32_t crtc_x;\n\t \n\tint32_t crtc_y;\n\n\t \n\t \n\tuint32_t crtc_w, crtc_h;\n\n\t \n\tuint32_t src_x;\n\t \n\tuint32_t src_y;\n\t \n\t \n\tuint32_t src_h, src_w;\n\n\t \n\tu16 alpha;\n\n\t \n\tuint16_t pixel_blend_mode;\n\n\t \n\tunsigned int rotation;\n\n\t \n\tunsigned int zpos;\n\n\t \n\tunsigned int normalized_zpos;\n\n\t \n\tenum drm_color_encoding color_encoding;\n\n\t \n\tenum drm_color_range color_range;\n\n\t \n\tstruct drm_property_blob *fb_damage_clips;\n\n\t \n\t \n\tstruct drm_rect src, dst;\n\n\t \n\tbool visible;\n\n\t \n\tenum drm_scaling_filter scaling_filter;\n\n\t \n\tstruct drm_crtc_commit *commit;\n\n\t \n\tstruct drm_atomic_state *state;\n};\n\nstatic inline struct drm_rect\ndrm_plane_state_src(const struct drm_plane_state *state)\n{\n\tstruct drm_rect src = {\n\t\t.x1 = state->src_x,\n\t\t.y1 = state->src_y,\n\t\t.x2 = state->src_x + state->src_w,\n\t\t.y2 = state->src_y + state->src_h,\n\t};\n\treturn src;\n}\n\nstatic inline struct drm_rect\ndrm_plane_state_dest(const struct drm_plane_state *state)\n{\n\tstruct drm_rect dest = {\n\t\t.x1 = state->crtc_x,\n\t\t.y1 = state->crtc_y,\n\t\t.x2 = state->crtc_x + state->crtc_w,\n\t\t.y2 = state->crtc_y + state->crtc_h,\n\t};\n\treturn dest;\n}\n\n \nstruct drm_plane_funcs {\n\t \n\tint (*update_plane)(struct drm_plane *plane,\n\t\t\t    struct drm_crtc *crtc, struct drm_framebuffer *fb,\n\t\t\t    int crtc_x, int crtc_y,\n\t\t\t    unsigned int crtc_w, unsigned int crtc_h,\n\t\t\t    uint32_t src_x, uint32_t src_y,\n\t\t\t    uint32_t src_w, uint32_t src_h,\n\t\t\t    struct drm_modeset_acquire_ctx *ctx);\n\n\t \n\tint (*disable_plane)(struct drm_plane *plane,\n\t\t\t     struct drm_modeset_acquire_ctx *ctx);\n\n\t \n\tvoid (*destroy)(struct drm_plane *plane);\n\n\t \n\tvoid (*reset)(struct drm_plane *plane);\n\n\t \n\tint (*set_property)(struct drm_plane *plane,\n\t\t\t    struct drm_property *property, uint64_t val);\n\n\t \n\tstruct drm_plane_state *(*atomic_duplicate_state)(struct drm_plane *plane);\n\n\t \n\tvoid (*atomic_destroy_state)(struct drm_plane *plane,\n\t\t\t\t     struct drm_plane_state *state);\n\n\t \n\tint (*atomic_set_property)(struct drm_plane *plane,\n\t\t\t\t   struct drm_plane_state *state,\n\t\t\t\t   struct drm_property *property,\n\t\t\t\t   uint64_t val);\n\n\t \n\tint (*atomic_get_property)(struct drm_plane *plane,\n\t\t\t\t   const struct drm_plane_state *state,\n\t\t\t\t   struct drm_property *property,\n\t\t\t\t   uint64_t *val);\n\t \n\tint (*late_register)(struct drm_plane *plane);\n\n\t \n\tvoid (*early_unregister)(struct drm_plane *plane);\n\n\t \n\tvoid (*atomic_print_state)(struct drm_printer *p,\n\t\t\t\t   const struct drm_plane_state *state);\n\n\t \n\tbool (*format_mod_supported)(struct drm_plane *plane, uint32_t format,\n\t\t\t\t     uint64_t modifier);\n};\n\n \nenum drm_plane_type {\n\t \n\tDRM_PLANE_TYPE_OVERLAY,\n\n\t \n\tDRM_PLANE_TYPE_PRIMARY,\n\n\t \n\tDRM_PLANE_TYPE_CURSOR,\n};\n\n\n \nstruct drm_plane {\n\t \n\tstruct drm_device *dev;\n\n\t \n\tstruct list_head head;\n\n\t \n\tchar *name;\n\n\t \n\tstruct drm_modeset_lock mutex;\n\n\t \n\tstruct drm_mode_object base;\n\n\t \n\tuint32_t possible_crtcs;\n\t \n\tuint32_t *format_types;\n\t \n\tunsigned int format_count;\n\t \n\tbool format_default;\n\n\t \n\tuint64_t *modifiers;\n\t \n\tunsigned int modifier_count;\n\n\t \n\tstruct drm_crtc *crtc;\n\n\t \n\tstruct drm_framebuffer *fb;\n\n\t \n\tstruct drm_framebuffer *old_fb;\n\n\t \n\tconst struct drm_plane_funcs *funcs;\n\n\t \n\tstruct drm_object_properties properties;\n\n\t \n\tenum drm_plane_type type;\n\n\t \n\tunsigned index;\n\n\t \n\tconst struct drm_plane_helper_funcs *helper_private;\n\n\t \n\tstruct drm_plane_state *state;\n\n\t \n\tstruct drm_property *alpha_property;\n\t \n\tstruct drm_property *zpos_property;\n\t \n\tstruct drm_property *rotation_property;\n\t \n\tstruct drm_property *blend_mode_property;\n\n\t \n\tstruct drm_property *color_encoding_property;\n\t \n\tstruct drm_property *color_range_property;\n\n\t \n\tstruct drm_property *scaling_filter_property;\n};\n\n#define obj_to_plane(x) container_of(x, struct drm_plane, base)\n\n__printf(9, 10)\nint drm_universal_plane_init(struct drm_device *dev,\n\t\t\t     struct drm_plane *plane,\n\t\t\t     uint32_t possible_crtcs,\n\t\t\t     const struct drm_plane_funcs *funcs,\n\t\t\t     const uint32_t *formats,\n\t\t\t     unsigned int format_count,\n\t\t\t     const uint64_t *format_modifiers,\n\t\t\t     enum drm_plane_type type,\n\t\t\t     const char *name, ...);\nvoid drm_plane_cleanup(struct drm_plane *plane);\n\n__printf(10, 11)\nvoid *__drmm_universal_plane_alloc(struct drm_device *dev,\n\t\t\t\t   size_t size, size_t offset,\n\t\t\t\t   uint32_t possible_crtcs,\n\t\t\t\t   const struct drm_plane_funcs *funcs,\n\t\t\t\t   const uint32_t *formats,\n\t\t\t\t   unsigned int format_count,\n\t\t\t\t   const uint64_t *format_modifiers,\n\t\t\t\t   enum drm_plane_type plane_type,\n\t\t\t\t   const char *name, ...);\n\n \n#define drmm_universal_plane_alloc(dev, type, member, possible_crtcs, funcs, formats, \\\n\t\t\t\t   format_count, format_modifiers, plane_type, name, ...) \\\n\t((type *)__drmm_universal_plane_alloc(dev, sizeof(type), \\\n\t\t\t\t\t      offsetof(type, member), \\\n\t\t\t\t\t      possible_crtcs, funcs, formats, \\\n\t\t\t\t\t      format_count, format_modifiers, \\\n\t\t\t\t\t      plane_type, name, ##__VA_ARGS__))\n\n__printf(10, 11)\nvoid *__drm_universal_plane_alloc(struct drm_device *dev,\n\t\t\t\t  size_t size, size_t offset,\n\t\t\t\t  uint32_t possible_crtcs,\n\t\t\t\t  const struct drm_plane_funcs *funcs,\n\t\t\t\t  const uint32_t *formats,\n\t\t\t\t  unsigned int format_count,\n\t\t\t\t  const uint64_t *format_modifiers,\n\t\t\t\t  enum drm_plane_type plane_type,\n\t\t\t\t  const char *name, ...);\n\n \n#define drm_universal_plane_alloc(dev, type, member, possible_crtcs, funcs, formats, \\\n\t\t\t\t   format_count, format_modifiers, plane_type, name, ...) \\\n\t((type *)__drm_universal_plane_alloc(dev, sizeof(type), \\\n\t\t\t\t\t     offsetof(type, member), \\\n\t\t\t\t\t     possible_crtcs, funcs, formats, \\\n\t\t\t\t\t     format_count, format_modifiers, \\\n\t\t\t\t\t     plane_type, name, ##__VA_ARGS__))\n\n \nstatic inline unsigned int drm_plane_index(const struct drm_plane *plane)\n{\n\treturn plane->index;\n}\n\n \nstatic inline u32 drm_plane_mask(const struct drm_plane *plane)\n{\n\treturn 1 << drm_plane_index(plane);\n}\n\nstruct drm_plane * drm_plane_from_index(struct drm_device *dev, int idx);\nvoid drm_plane_force_disable(struct drm_plane *plane);\n\nint drm_mode_plane_set_obj_prop(struct drm_plane *plane,\n\t\t\t\t       struct drm_property *property,\n\t\t\t\t       uint64_t value);\n\n \nstatic inline struct drm_plane *drm_plane_find(struct drm_device *dev,\n\t\tstruct drm_file *file_priv,\n\t\tuint32_t id)\n{\n\tstruct drm_mode_object *mo;\n\tmo = drm_mode_object_find(dev, file_priv, id, DRM_MODE_OBJECT_PLANE);\n\treturn mo ? obj_to_plane(mo) : NULL;\n}\n\n \n#define drm_for_each_plane_mask(plane, dev, plane_mask) \\\n\tlist_for_each_entry((plane), &(dev)->mode_config.plane_list, head) \\\n\t\tfor_each_if ((plane_mask) & drm_plane_mask(plane))\n\n \n#define drm_for_each_legacy_plane(plane, dev) \\\n\tlist_for_each_entry(plane, &(dev)->mode_config.plane_list, head) \\\n\t\tfor_each_if (plane->type == DRM_PLANE_TYPE_OVERLAY)\n\n \n#define drm_for_each_plane(plane, dev) \\\n\tlist_for_each_entry(plane, &(dev)->mode_config.plane_list, head)\n\nbool drm_any_plane_has_format(struct drm_device *dev,\n\t\t\t      u32 format, u64 modifier);\n\nvoid drm_plane_enable_fb_damage_clips(struct drm_plane *plane);\nunsigned int\ndrm_plane_get_damage_clips_count(const struct drm_plane_state *state);\nstruct drm_mode_rect *\ndrm_plane_get_damage_clips(const struct drm_plane_state *state);\n\nint drm_plane_create_scaling_filter_property(struct drm_plane *plane,\n\t\t\t\t\t     unsigned int supported_filters);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}