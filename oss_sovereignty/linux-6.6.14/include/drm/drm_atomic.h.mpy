{
  "module_name": "drm_atomic.h",
  "hash_id": "71bc522413028b56997c6a4d8080433a38b3f5ace9ecf5feea7486489004b1ad",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_atomic.h",
  "human_readable_source": " \n\n#ifndef DRM_ATOMIC_H_\n#define DRM_ATOMIC_H_\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_util.h>\n\n \nstruct drm_crtc_commit {\n\t \n\tstruct drm_crtc *crtc;\n\n\t \n\tstruct kref ref;\n\n\t \n\tstruct completion flip_done;\n\n\t \n\tstruct completion hw_done;\n\n\t \n\tstruct completion cleanup_done;\n\n\t \n\tstruct list_head commit_entry;\n\n\t \n\tstruct drm_pending_vblank_event *event;\n\n\t \n\tbool abort_completion;\n};\n\nstruct __drm_planes_state {\n\tstruct drm_plane *ptr;\n\tstruct drm_plane_state *state, *old_state, *new_state;\n};\n\nstruct __drm_crtcs_state {\n\tstruct drm_crtc *ptr;\n\tstruct drm_crtc_state *state, *old_state, *new_state;\n\n\t \n\tstruct drm_crtc_commit *commit;\n\n\ts32 __user *out_fence_ptr;\n\tu64 last_vblank_count;\n};\n\nstruct __drm_connnectors_state {\n\tstruct drm_connector *ptr;\n\tstruct drm_connector_state *state, *old_state, *new_state;\n\t \n\ts32 __user *out_fence_ptr;\n};\n\nstruct drm_private_obj;\nstruct drm_private_state;\n\n \nstruct drm_private_state_funcs {\n\t \n\tstruct drm_private_state *(*atomic_duplicate_state)(struct drm_private_obj *obj);\n\n\t \n\tvoid (*atomic_destroy_state)(struct drm_private_obj *obj,\n\t\t\t\t     struct drm_private_state *state);\n\n\t \n\tvoid (*atomic_print_state)(struct drm_printer *p,\n\t\t\t\t   const struct drm_private_state *state);\n};\n\n \nstruct drm_private_obj {\n\t \n\tstruct list_head head;\n\n\t \n\tstruct drm_modeset_lock lock;\n\n\t \n\tstruct drm_private_state *state;\n\n\t \n\tconst struct drm_private_state_funcs *funcs;\n};\n\n \n#define drm_for_each_privobj(privobj, dev) \\\n\tlist_for_each_entry(privobj, &(dev)->mode_config.privobj_list, head)\n\n \nstruct drm_private_state {\n\t \n\tstruct drm_atomic_state *state;\n\n\t \n\tstruct drm_private_obj *obj;\n};\n\nstruct __drm_private_objs_state {\n\tstruct drm_private_obj *ptr;\n\tstruct drm_private_state *state, *old_state, *new_state;\n};\n\n \nstruct drm_atomic_state {\n\tstruct kref ref;\n\n\tstruct drm_device *dev;\n\n\t \n\tbool allow_modeset : 1;\n\t \n\tbool legacy_cursor_update : 1;\n\tbool async_update : 1;\n\t \n\tbool duplicated : 1;\n\tstruct __drm_planes_state *planes;\n\tstruct __drm_crtcs_state *crtcs;\n\tint num_connector;\n\tstruct __drm_connnectors_state *connectors;\n\tint num_private_objs;\n\tstruct __drm_private_objs_state *private_objs;\n\n\tstruct drm_modeset_acquire_ctx *acquire_ctx;\n\n\t \n\tstruct drm_crtc_commit *fake_commit;\n\n\t \n\tstruct work_struct commit_work;\n};\n\nvoid __drm_crtc_commit_free(struct kref *kref);\n\n \nstatic inline struct drm_crtc_commit *drm_crtc_commit_get(struct drm_crtc_commit *commit)\n{\n\tkref_get(&commit->ref);\n\treturn commit;\n}\n\n \nstatic inline void drm_crtc_commit_put(struct drm_crtc_commit *commit)\n{\n\tkref_put(&commit->ref, __drm_crtc_commit_free);\n}\n\nint drm_crtc_commit_wait(struct drm_crtc_commit *commit);\n\nstruct drm_atomic_state * __must_check\ndrm_atomic_state_alloc(struct drm_device *dev);\nvoid drm_atomic_state_clear(struct drm_atomic_state *state);\n\n \nstatic inline struct drm_atomic_state *\ndrm_atomic_state_get(struct drm_atomic_state *state)\n{\n\tkref_get(&state->ref);\n\treturn state;\n}\n\nvoid __drm_atomic_state_free(struct kref *ref);\n\n \nstatic inline void drm_atomic_state_put(struct drm_atomic_state *state)\n{\n\tkref_put(&state->ref, __drm_atomic_state_free);\n}\n\nint  __must_check\ndrm_atomic_state_init(struct drm_device *dev, struct drm_atomic_state *state);\nvoid drm_atomic_state_default_clear(struct drm_atomic_state *state);\nvoid drm_atomic_state_default_release(struct drm_atomic_state *state);\n\nstruct drm_crtc_state * __must_check\ndrm_atomic_get_crtc_state(struct drm_atomic_state *state,\n\t\t\t  struct drm_crtc *crtc);\nstruct drm_plane_state * __must_check\ndrm_atomic_get_plane_state(struct drm_atomic_state *state,\n\t\t\t   struct drm_plane *plane);\nstruct drm_connector_state * __must_check\ndrm_atomic_get_connector_state(struct drm_atomic_state *state,\n\t\t\t       struct drm_connector *connector);\n\nvoid drm_atomic_private_obj_init(struct drm_device *dev,\n\t\t\t\t struct drm_private_obj *obj,\n\t\t\t\t struct drm_private_state *state,\n\t\t\t\t const struct drm_private_state_funcs *funcs);\nvoid drm_atomic_private_obj_fini(struct drm_private_obj *obj);\n\nstruct drm_private_state * __must_check\ndrm_atomic_get_private_obj_state(struct drm_atomic_state *state,\n\t\t\t\t struct drm_private_obj *obj);\nstruct drm_private_state *\ndrm_atomic_get_old_private_obj_state(const struct drm_atomic_state *state,\n\t\t\t\t     struct drm_private_obj *obj);\nstruct drm_private_state *\ndrm_atomic_get_new_private_obj_state(const struct drm_atomic_state *state,\n\t\t\t\t     struct drm_private_obj *obj);\n\nstruct drm_connector *\ndrm_atomic_get_old_connector_for_encoder(const struct drm_atomic_state *state,\n\t\t\t\t\t struct drm_encoder *encoder);\nstruct drm_connector *\ndrm_atomic_get_new_connector_for_encoder(const struct drm_atomic_state *state,\n\t\t\t\t\t struct drm_encoder *encoder);\n\nstruct drm_crtc *\ndrm_atomic_get_old_crtc_for_encoder(struct drm_atomic_state *state,\n\t\t\t\t\t struct drm_encoder *encoder);\nstruct drm_crtc *\ndrm_atomic_get_new_crtc_for_encoder(struct drm_atomic_state *state,\n\t\t\t\t\t struct drm_encoder *encoder);\n\n \nstatic inline struct drm_crtc_state *\ndrm_atomic_get_existing_crtc_state(const struct drm_atomic_state *state,\n\t\t\t\t   struct drm_crtc *crtc)\n{\n\treturn state->crtcs[drm_crtc_index(crtc)].state;\n}\n\n \nstatic inline struct drm_crtc_state *\ndrm_atomic_get_old_crtc_state(const struct drm_atomic_state *state,\n\t\t\t      struct drm_crtc *crtc)\n{\n\treturn state->crtcs[drm_crtc_index(crtc)].old_state;\n}\n \nstatic inline struct drm_crtc_state *\ndrm_atomic_get_new_crtc_state(const struct drm_atomic_state *state,\n\t\t\t      struct drm_crtc *crtc)\n{\n\treturn state->crtcs[drm_crtc_index(crtc)].new_state;\n}\n\n \nstatic inline struct drm_plane_state *\ndrm_atomic_get_existing_plane_state(const struct drm_atomic_state *state,\n\t\t\t\t    struct drm_plane *plane)\n{\n\treturn state->planes[drm_plane_index(plane)].state;\n}\n\n \nstatic inline struct drm_plane_state *\ndrm_atomic_get_old_plane_state(const struct drm_atomic_state *state,\n\t\t\t       struct drm_plane *plane)\n{\n\treturn state->planes[drm_plane_index(plane)].old_state;\n}\n\n \nstatic inline struct drm_plane_state *\ndrm_atomic_get_new_plane_state(const struct drm_atomic_state *state,\n\t\t\t       struct drm_plane *plane)\n{\n\treturn state->planes[drm_plane_index(plane)].new_state;\n}\n\n \nstatic inline struct drm_connector_state *\ndrm_atomic_get_existing_connector_state(const struct drm_atomic_state *state,\n\t\t\t\t\tstruct drm_connector *connector)\n{\n\tint index = drm_connector_index(connector);\n\n\tif (index >= state->num_connector)\n\t\treturn NULL;\n\n\treturn state->connectors[index].state;\n}\n\n \nstatic inline struct drm_connector_state *\ndrm_atomic_get_old_connector_state(const struct drm_atomic_state *state,\n\t\t\t\t   struct drm_connector *connector)\n{\n\tint index = drm_connector_index(connector);\n\n\tif (index >= state->num_connector)\n\t\treturn NULL;\n\n\treturn state->connectors[index].old_state;\n}\n\n \nstatic inline struct drm_connector_state *\ndrm_atomic_get_new_connector_state(const struct drm_atomic_state *state,\n\t\t\t\t   struct drm_connector *connector)\n{\n\tint index = drm_connector_index(connector);\n\n\tif (index >= state->num_connector)\n\t\treturn NULL;\n\n\treturn state->connectors[index].new_state;\n}\n\n \nstatic inline const struct drm_plane_state *\n__drm_atomic_get_current_plane_state(const struct drm_atomic_state *state,\n\t\t\t\t     struct drm_plane *plane)\n{\n\tif (state->planes[drm_plane_index(plane)].state)\n\t\treturn state->planes[drm_plane_index(plane)].state;\n\n\treturn plane->state;\n}\n\nint __must_check\ndrm_atomic_add_encoder_bridges(struct drm_atomic_state *state,\n\t\t\t       struct drm_encoder *encoder);\nint __must_check\ndrm_atomic_add_affected_connectors(struct drm_atomic_state *state,\n\t\t\t\t   struct drm_crtc *crtc);\nint __must_check\ndrm_atomic_add_affected_planes(struct drm_atomic_state *state,\n\t\t\t       struct drm_crtc *crtc);\n\nint __must_check drm_atomic_check_only(struct drm_atomic_state *state);\nint __must_check drm_atomic_commit(struct drm_atomic_state *state);\nint __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);\n\nvoid drm_state_dump(struct drm_device *dev, struct drm_printer *p);\n\n \n#define for_each_oldnew_connector_in_state(__state, connector, old_connector_state, new_connector_state, __i) \\\n\tfor ((__i) = 0;\t\t\t\t\t\t\t\t\\\n\t     (__i) < (__state)->num_connector;\t\t\t\t\t\\\n\t     (__i)++)\t\t\t\t\t\t\t\t\\\n\t\tfor_each_if ((__state)->connectors[__i].ptr &&\t\t\t\\\n\t\t\t     ((connector) = (__state)->connectors[__i].ptr,\t\\\n\t\t\t     (void)(connector)  , \\\n\t\t\t     (old_connector_state) = (__state)->connectors[__i].old_state,\t\\\n\t\t\t     (new_connector_state) = (__state)->connectors[__i].new_state, 1))\n\n \n#define for_each_old_connector_in_state(__state, connector, old_connector_state, __i) \\\n\tfor ((__i) = 0;\t\t\t\t\t\t\t\t\\\n\t     (__i) < (__state)->num_connector;\t\t\t\t\t\\\n\t     (__i)++)\t\t\t\t\t\t\t\t\\\n\t\tfor_each_if ((__state)->connectors[__i].ptr &&\t\t\t\\\n\t\t\t     ((connector) = (__state)->connectors[__i].ptr,\t\\\n\t\t\t     (void)(connector)  , \\\n\t\t\t     (old_connector_state) = (__state)->connectors[__i].old_state, 1))\n\n \n#define for_each_new_connector_in_state(__state, connector, new_connector_state, __i) \\\n\tfor ((__i) = 0;\t\t\t\t\t\t\t\t\\\n\t     (__i) < (__state)->num_connector;\t\t\t\t\t\\\n\t     (__i)++)\t\t\t\t\t\t\t\t\\\n\t\tfor_each_if ((__state)->connectors[__i].ptr &&\t\t\t\\\n\t\t\t     ((connector) = (__state)->connectors[__i].ptr,\t\\\n\t\t\t     (void)(connector)  , \\\n\t\t\t     (new_connector_state) = (__state)->connectors[__i].new_state, \\\n\t\t\t     (void)(new_connector_state)  , 1))\n\n \n#define for_each_oldnew_crtc_in_state(__state, crtc, old_crtc_state, new_crtc_state, __i) \\\n\tfor ((__i) = 0;\t\t\t\t\t\t\t\\\n\t     (__i) < (__state)->dev->mode_config.num_crtc;\t\t\\\n\t     (__i)++)\t\t\t\t\t\t\t\\\n\t\tfor_each_if ((__state)->crtcs[__i].ptr &&\t\t\\\n\t\t\t     ((crtc) = (__state)->crtcs[__i].ptr,\t\\\n\t\t\t      (void)(crtc)  , \\\n\t\t\t     (old_crtc_state) = (__state)->crtcs[__i].old_state, \\\n\t\t\t     (void)(old_crtc_state)  , \\\n\t\t\t     (new_crtc_state) = (__state)->crtcs[__i].new_state, \\\n\t\t\t     (void)(new_crtc_state)  , 1))\n\n \n#define for_each_old_crtc_in_state(__state, crtc, old_crtc_state, __i)\t\\\n\tfor ((__i) = 0;\t\t\t\t\t\t\t\\\n\t     (__i) < (__state)->dev->mode_config.num_crtc;\t\t\\\n\t     (__i)++)\t\t\t\t\t\t\t\\\n\t\tfor_each_if ((__state)->crtcs[__i].ptr &&\t\t\\\n\t\t\t     ((crtc) = (__state)->crtcs[__i].ptr,\t\\\n\t\t\t     (void)(crtc)  , \\\n\t\t\t     (old_crtc_state) = (__state)->crtcs[__i].old_state, 1))\n\n \n#define for_each_new_crtc_in_state(__state, crtc, new_crtc_state, __i)\t\\\n\tfor ((__i) = 0;\t\t\t\t\t\t\t\\\n\t     (__i) < (__state)->dev->mode_config.num_crtc;\t\t\\\n\t     (__i)++)\t\t\t\t\t\t\t\\\n\t\tfor_each_if ((__state)->crtcs[__i].ptr &&\t\t\\\n\t\t\t     ((crtc) = (__state)->crtcs[__i].ptr,\t\\\n\t\t\t     (void)(crtc)  , \\\n\t\t\t     (new_crtc_state) = (__state)->crtcs[__i].new_state, \\\n\t\t\t     (void)(new_crtc_state)  , 1))\n\n \n#define for_each_oldnew_plane_in_state(__state, plane, old_plane_state, new_plane_state, __i) \\\n\tfor ((__i) = 0;\t\t\t\t\t\t\t\\\n\t     (__i) < (__state)->dev->mode_config.num_total_plane;\t\\\n\t     (__i)++)\t\t\t\t\t\t\t\\\n\t\tfor_each_if ((__state)->planes[__i].ptr &&\t\t\\\n\t\t\t     ((plane) = (__state)->planes[__i].ptr,\t\\\n\t\t\t      (void)(plane)  , \\\n\t\t\t      (old_plane_state) = (__state)->planes[__i].old_state,\\\n\t\t\t      (new_plane_state) = (__state)->planes[__i].new_state, 1))\n\n \n#define for_each_oldnew_plane_in_state_reverse(__state, plane, old_plane_state, new_plane_state, __i) \\\n\tfor ((__i) = ((__state)->dev->mode_config.num_total_plane - 1);\t\\\n\t     (__i) >= 0;\t\t\t\t\t\t\\\n\t     (__i)--)\t\t\t\t\t\t\t\\\n\t\tfor_each_if ((__state)->planes[__i].ptr &&\t\t\\\n\t\t\t     ((plane) = (__state)->planes[__i].ptr,\t\\\n\t\t\t      (old_plane_state) = (__state)->planes[__i].old_state,\\\n\t\t\t      (new_plane_state) = (__state)->planes[__i].new_state, 1))\n\n \n#define for_each_new_plane_in_state_reverse(__state, plane, new_plane_state, __i) \\\n\tfor ((__i) = ((__state)->dev->mode_config.num_total_plane - 1);\t\\\n\t     (__i) >= 0;\t\t\t\t\t\t\\\n\t     (__i)--)\t\t\t\t\t\t\t\\\n\t\tfor_each_if ((__state)->planes[__i].ptr &&\t\t\\\n\t\t\t     ((plane) = (__state)->planes[__i].ptr,\t\\\n\t\t\t      (new_plane_state) = (__state)->planes[__i].new_state, 1))\n\n \n#define for_each_old_plane_in_state(__state, plane, old_plane_state, __i) \\\n\tfor ((__i) = 0;\t\t\t\t\t\t\t\\\n\t     (__i) < (__state)->dev->mode_config.num_total_plane;\t\\\n\t     (__i)++)\t\t\t\t\t\t\t\\\n\t\tfor_each_if ((__state)->planes[__i].ptr &&\t\t\\\n\t\t\t     ((plane) = (__state)->planes[__i].ptr,\t\\\n\t\t\t      (old_plane_state) = (__state)->planes[__i].old_state, 1))\n \n#define for_each_new_plane_in_state(__state, plane, new_plane_state, __i) \\\n\tfor ((__i) = 0;\t\t\t\t\t\t\t\\\n\t     (__i) < (__state)->dev->mode_config.num_total_plane;\t\\\n\t     (__i)++)\t\t\t\t\t\t\t\\\n\t\tfor_each_if ((__state)->planes[__i].ptr &&\t\t\\\n\t\t\t     ((plane) = (__state)->planes[__i].ptr,\t\\\n\t\t\t      (void)(plane)  , \\\n\t\t\t      (new_plane_state) = (__state)->planes[__i].new_state, \\\n\t\t\t      (void)(new_plane_state)  , 1))\n\n \n#define for_each_oldnew_private_obj_in_state(__state, obj, old_obj_state, new_obj_state, __i) \\\n\tfor ((__i) = 0; \\\n\t     (__i) < (__state)->num_private_objs && \\\n\t\t     ((obj) = (__state)->private_objs[__i].ptr, \\\n\t\t      (old_obj_state) = (__state)->private_objs[__i].old_state,\t\\\n\t\t      (new_obj_state) = (__state)->private_objs[__i].new_state, 1); \\\n\t     (__i)++)\n\n \n#define for_each_old_private_obj_in_state(__state, obj, old_obj_state, __i) \\\n\tfor ((__i) = 0; \\\n\t     (__i) < (__state)->num_private_objs && \\\n\t\t     ((obj) = (__state)->private_objs[__i].ptr, \\\n\t\t      (old_obj_state) = (__state)->private_objs[__i].old_state, 1); \\\n\t     (__i)++)\n\n \n#define for_each_new_private_obj_in_state(__state, obj, new_obj_state, __i) \\\n\tfor ((__i) = 0; \\\n\t     (__i) < (__state)->num_private_objs && \\\n\t\t     ((obj) = (__state)->private_objs[__i].ptr, \\\n\t\t      (void)(obj)  , \\\n\t\t      (new_obj_state) = (__state)->private_objs[__i].new_state, 1); \\\n\t     (__i)++)\n\n \nstatic inline bool\ndrm_atomic_crtc_needs_modeset(const struct drm_crtc_state *state)\n{\n\treturn state->mode_changed || state->active_changed ||\n\t       state->connectors_changed;\n}\n\n \nstatic inline bool\ndrm_atomic_crtc_effectively_active(const struct drm_crtc_state *state)\n{\n\treturn state->active || state->self_refresh_active;\n}\n\n \nstruct drm_bus_cfg {\n\t \n\tu32 format;\n\n\t \n\tu32 flags;\n};\n\n \nstruct drm_bridge_state {\n\t \n\tstruct drm_private_state base;\n\n\t \n\tstruct drm_bridge *bridge;\n\n\t \n\tstruct drm_bus_cfg input_bus_cfg;\n\n\t \n\tstruct drm_bus_cfg output_bus_cfg;\n};\n\nstatic inline struct drm_bridge_state *\ndrm_priv_to_bridge_state(struct drm_private_state *priv)\n{\n\treturn container_of(priv, struct drm_bridge_state, base);\n}\n\nstruct drm_bridge_state *\ndrm_atomic_get_bridge_state(struct drm_atomic_state *state,\n\t\t\t    struct drm_bridge *bridge);\nstruct drm_bridge_state *\ndrm_atomic_get_old_bridge_state(const struct drm_atomic_state *state,\n\t\t\t\tstruct drm_bridge *bridge);\nstruct drm_bridge_state *\ndrm_atomic_get_new_bridge_state(const struct drm_atomic_state *state,\n\t\t\t\tstruct drm_bridge *bridge);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}