{
  "module_name": "drm_of.h",
  "hash_id": "8dee4195b4c96d4a9ffe5d5e479d68f5a7744f401f165a1057e6190d3c291179",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_of.h",
  "human_readable_source": " \n#ifndef __DRM_OF_H__\n#define __DRM_OF_H__\n\n#include <linux/of_graph.h>\n#if IS_ENABLED(CONFIG_OF) && IS_ENABLED(CONFIG_DRM_PANEL_BRIDGE)\n#include <drm/drm_bridge.h>\n#endif\n\nstruct component_master_ops;\nstruct component_match;\nstruct device;\nstruct drm_device;\nstruct drm_encoder;\nstruct drm_panel;\nstruct drm_bridge;\nstruct device_node;\nstruct mipi_dsi_device_info;\nstruct mipi_dsi_host;\n\n \nenum drm_lvds_dual_link_pixels {\n\tDRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS = 0,\n\tDRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS = 1,\n};\n\n#ifdef CONFIG_OF\nuint32_t drm_of_crtc_port_mask(struct drm_device *dev,\n\t\t\t    struct device_node *port);\nuint32_t drm_of_find_possible_crtcs(struct drm_device *dev,\n\t\t\t\t    struct device_node *port);\nvoid drm_of_component_match_add(struct device *master,\n\t\t\t\tstruct component_match **matchptr,\n\t\t\t\tint (*compare)(struct device *, void *),\n\t\t\t\tstruct device_node *node);\nint drm_of_component_probe(struct device *dev,\n\t\t\t   int (*compare_of)(struct device *, void *),\n\t\t\t   const struct component_master_ops *m_ops);\nint drm_of_encoder_active_endpoint(struct device_node *node,\n\t\t\t\t   struct drm_encoder *encoder,\n\t\t\t\t   struct of_endpoint *endpoint);\nint drm_of_find_panel_or_bridge(const struct device_node *np,\n\t\t\t\tint port, int endpoint,\n\t\t\t\tstruct drm_panel **panel,\n\t\t\t\tstruct drm_bridge **bridge);\nint drm_of_lvds_get_dual_link_pixel_order(const struct device_node *port1,\n\t\t\t\t\t  const struct device_node *port2);\nint drm_of_lvds_get_data_mapping(const struct device_node *port);\nint drm_of_get_data_lanes_count(const struct device_node *endpoint,\n\t\t\t\tconst unsigned int min, const unsigned int max);\nint drm_of_get_data_lanes_count_ep(const struct device_node *port,\n\t\t\t\t   int port_reg, int reg,\n\t\t\t\t   const unsigned int min,\n\t\t\t\t   const unsigned int max);\n#else\nstatic inline uint32_t drm_of_crtc_port_mask(struct drm_device *dev,\n\t\t\t\t\t  struct device_node *port)\n{\n\treturn 0;\n}\n\nstatic inline uint32_t drm_of_find_possible_crtcs(struct drm_device *dev,\n\t\t\t\t\t\t  struct device_node *port)\n{\n\treturn 0;\n}\n\nstatic inline void\ndrm_of_component_match_add(struct device *master,\n\t\t\t   struct component_match **matchptr,\n\t\t\t   int (*compare)(struct device *, void *),\n\t\t\t   struct device_node *node)\n{\n}\n\nstatic inline int\ndrm_of_component_probe(struct device *dev,\n\t\t       int (*compare_of)(struct device *, void *),\n\t\t       const struct component_master_ops *m_ops)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int drm_of_encoder_active_endpoint(struct device_node *node,\n\t\t\t\t\t\t struct drm_encoder *encoder,\n\t\t\t\t\t\t struct of_endpoint *endpoint)\n{\n\treturn -EINVAL;\n}\nstatic inline int drm_of_find_panel_or_bridge(const struct device_node *np,\n\t\t\t\t\t      int port, int endpoint,\n\t\t\t\t\t      struct drm_panel **panel,\n\t\t\t\t\t      struct drm_bridge **bridge)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int\ndrm_of_lvds_get_dual_link_pixel_order(const struct device_node *port1,\n\t\t\t\t      const struct device_node *port2)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int\ndrm_of_lvds_get_data_mapping(const struct device_node *port)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int\ndrm_of_get_data_lanes_count(const struct device_node *endpoint,\n\t\t\t    const unsigned int min, const unsigned int max)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int\ndrm_of_get_data_lanes_count_ep(const struct device_node *port,\n\t\t\t       int port_reg, int reg,\n\t\t\t       const unsigned int min,\n\t\t\t       const unsigned int max)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_OF) && IS_ENABLED(CONFIG_DRM_MIPI_DSI)\nstruct mipi_dsi_host *drm_of_get_dsi_bus(struct device *dev);\n#else\nstatic inline struct\nmipi_dsi_host *drm_of_get_dsi_bus(struct device *dev)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n#endif  \n\n \nstatic inline int drm_of_panel_bridge_remove(const struct device_node *np,\n\t\t\t\t\t     int port, int endpoint)\n{\n#if IS_ENABLED(CONFIG_OF) && IS_ENABLED(CONFIG_DRM_PANEL_BRIDGE)\n\tstruct drm_bridge *bridge;\n\tstruct device_node *remote;\n\n\tremote = of_graph_get_remote_node(np, port, endpoint);\n\tif (!remote)\n\t\treturn -ENODEV;\n\n\tbridge = of_drm_find_bridge(remote);\n\tdrm_panel_bridge_remove(bridge);\n\n\treturn 0;\n#else\n\treturn -EINVAL;\n#endif\n}\n\nstatic inline int drm_of_encoder_active_endpoint_id(struct device_node *node,\n\t\t\t\t\t\t    struct drm_encoder *encoder)\n{\n\tstruct of_endpoint endpoint;\n\tint ret = drm_of_encoder_active_endpoint(node, encoder,\n\t\t\t\t\t\t &endpoint);\n\n\treturn ret ?: endpoint.id;\n}\n\nstatic inline int drm_of_encoder_active_port_id(struct device_node *node,\n\t\t\t\t\t\tstruct drm_encoder *encoder)\n{\n\tstruct of_endpoint endpoint;\n\tint ret = drm_of_encoder_active_endpoint(node, encoder,\n\t\t\t\t\t\t &endpoint);\n\n\treturn ret ?: endpoint.port;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}