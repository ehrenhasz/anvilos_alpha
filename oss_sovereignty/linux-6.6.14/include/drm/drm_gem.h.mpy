{
  "module_name": "drm_gem.h",
  "hash_id": "fcf217f7257b29adf362850026e411df7fac5cb2073b2676947a37730e7fbb33",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_gem.h",
  "human_readable_source": "#ifndef __DRM_GEM_H__\n#define __DRM_GEM_H__\n\n \n\n#include <linux/kref.h>\n#include <linux/dma-resv.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n\n#include <drm/drm_vma_manager.h>\n\nstruct iosys_map;\nstruct drm_gem_object;\n\n \nenum drm_gem_object_status {\n\tDRM_GEM_OBJECT_RESIDENT  = BIT(0),\n\tDRM_GEM_OBJECT_PURGEABLE = BIT(1),\n};\n\n \nstruct drm_gem_object_funcs {\n\t \n\tvoid (*free)(struct drm_gem_object *obj);\n\n\t \n\tint (*open)(struct drm_gem_object *obj, struct drm_file *file);\n\n\t \n\tvoid (*close)(struct drm_gem_object *obj, struct drm_file *file);\n\n\t \n\tvoid (*print_info)(struct drm_printer *p, unsigned int indent,\n\t\t\t   const struct drm_gem_object *obj);\n\n\t \n\tstruct dma_buf *(*export)(struct drm_gem_object *obj, int flags);\n\n\t \n\tint (*pin)(struct drm_gem_object *obj);\n\n\t \n\tvoid (*unpin)(struct drm_gem_object *obj);\n\n\t \n\tstruct sg_table *(*get_sg_table)(struct drm_gem_object *obj);\n\n\t \n\tint (*vmap)(struct drm_gem_object *obj, struct iosys_map *map);\n\n\t \n\tvoid (*vunmap)(struct drm_gem_object *obj, struct iosys_map *map);\n\n\t \n\tint (*mmap)(struct drm_gem_object *obj, struct vm_area_struct *vma);\n\n\t \n\tint (*evict)(struct drm_gem_object *obj);\n\n\t \n\tenum drm_gem_object_status (*status)(struct drm_gem_object *obj);\n\n\t \n\tconst struct vm_operations_struct *vm_ops;\n};\n\n \nstruct drm_gem_lru {\n\t \n\tstruct mutex *lock;\n\n\t \n\tlong count;\n\n\t \n\tstruct list_head list;\n};\n\n \nstruct drm_gem_object {\n\t \n\tstruct kref refcount;\n\n\t \n\tunsigned handle_count;\n\n\t \n\tstruct drm_device *dev;\n\n\t \n\tstruct file *filp;\n\n\t \n\tstruct drm_vma_offset_node vma_node;\n\n\t \n\tsize_t size;\n\n\t \n\tint name;\n\n\t \n\tstruct dma_buf *dma_buf;\n\n\t \n\tstruct dma_buf_attachment *import_attach;\n\n\t \n\tstruct dma_resv *resv;\n\n\t \n\tstruct dma_resv _resv;\n\n\t \n\tstruct {\n\t\tstruct list_head list;\n\n#ifdef CONFIG_LOCKDEP\n\t\tstruct lockdep_map *lock_dep_map;\n#endif\n\t} gpuva;\n\n\t \n\tconst struct drm_gem_object_funcs *funcs;\n\n\t \n\tstruct list_head lru_node;\n\n\t \n\tstruct drm_gem_lru *lru;\n};\n\n \n#define DRM_GEM_FOPS \\\n\t.open\t\t= drm_open,\\\n\t.release\t= drm_release,\\\n\t.unlocked_ioctl\t= drm_ioctl,\\\n\t.compat_ioctl\t= drm_compat_ioctl,\\\n\t.poll\t\t= drm_poll,\\\n\t.read\t\t= drm_read,\\\n\t.llseek\t\t= noop_llseek,\\\n\t.mmap\t\t= drm_gem_mmap\n\n \n#define DEFINE_DRM_GEM_FOPS(name) \\\n\tstatic const struct file_operations name = {\\\n\t\t.owner\t\t= THIS_MODULE,\\\n\t\tDRM_GEM_FOPS,\\\n\t}\n\nvoid drm_gem_object_release(struct drm_gem_object *obj);\nvoid drm_gem_object_free(struct kref *kref);\nint drm_gem_object_init(struct drm_device *dev,\n\t\t\tstruct drm_gem_object *obj, size_t size);\nvoid drm_gem_private_object_init(struct drm_device *dev,\n\t\t\t\t struct drm_gem_object *obj, size_t size);\nvoid drm_gem_private_object_fini(struct drm_gem_object *obj);\nvoid drm_gem_vm_open(struct vm_area_struct *vma);\nvoid drm_gem_vm_close(struct vm_area_struct *vma);\nint drm_gem_mmap_obj(struct drm_gem_object *obj, unsigned long obj_size,\n\t\t     struct vm_area_struct *vma);\nint drm_gem_mmap(struct file *filp, struct vm_area_struct *vma);\n\n \nstatic inline void drm_gem_object_get(struct drm_gem_object *obj)\n{\n\tkref_get(&obj->refcount);\n}\n\n__attribute__((nonnull))\nstatic inline void\n__drm_gem_object_put(struct drm_gem_object *obj)\n{\n\tkref_put(&obj->refcount, drm_gem_object_free);\n}\n\n \nstatic inline void\ndrm_gem_object_put(struct drm_gem_object *obj)\n{\n\tif (obj)\n\t\t__drm_gem_object_put(obj);\n}\n\nint drm_gem_handle_create(struct drm_file *file_priv,\n\t\t\t  struct drm_gem_object *obj,\n\t\t\t  u32 *handlep);\nint drm_gem_handle_delete(struct drm_file *filp, u32 handle);\n\n\nvoid drm_gem_free_mmap_offset(struct drm_gem_object *obj);\nint drm_gem_create_mmap_offset(struct drm_gem_object *obj);\nint drm_gem_create_mmap_offset_size(struct drm_gem_object *obj, size_t size);\n\nstruct page **drm_gem_get_pages(struct drm_gem_object *obj);\nvoid drm_gem_put_pages(struct drm_gem_object *obj, struct page **pages,\n\t\tbool dirty, bool accessed);\n\nint drm_gem_vmap_unlocked(struct drm_gem_object *obj, struct iosys_map *map);\nvoid drm_gem_vunmap_unlocked(struct drm_gem_object *obj, struct iosys_map *map);\n\nint drm_gem_objects_lookup(struct drm_file *filp, void __user *bo_handles,\n\t\t\t   int count, struct drm_gem_object ***objs_out);\nstruct drm_gem_object *drm_gem_object_lookup(struct drm_file *filp, u32 handle);\nlong drm_gem_dma_resv_wait(struct drm_file *filep, u32 handle,\n\t\t\t\t    bool wait_all, unsigned long timeout);\nint drm_gem_lock_reservations(struct drm_gem_object **objs, int count,\n\t\t\t      struct ww_acquire_ctx *acquire_ctx);\nvoid drm_gem_unlock_reservations(struct drm_gem_object **objs, int count,\n\t\t\t\t struct ww_acquire_ctx *acquire_ctx);\nint drm_gem_dumb_map_offset(struct drm_file *file, struct drm_device *dev,\n\t\t\t    u32 handle, u64 *offset);\n\nvoid drm_gem_lru_init(struct drm_gem_lru *lru, struct mutex *lock);\nvoid drm_gem_lru_remove(struct drm_gem_object *obj);\nvoid drm_gem_lru_move_tail_locked(struct drm_gem_lru *lru, struct drm_gem_object *obj);\nvoid drm_gem_lru_move_tail(struct drm_gem_lru *lru, struct drm_gem_object *obj);\nunsigned long drm_gem_lru_scan(struct drm_gem_lru *lru,\n\t\t\t       unsigned int nr_to_scan,\n\t\t\t       unsigned long *remaining,\n\t\t\t       bool (*shrink)(struct drm_gem_object *obj));\n\nint drm_gem_evict(struct drm_gem_object *obj);\n\n#ifdef CONFIG_LOCKDEP\n \n#define drm_gem_gpuva_set_lock(obj, lock) \\\n\tif (!WARN((obj)->gpuva.lock_dep_map, \\\n\t\t  \"GEM GPUVA lock should be set only once.\")) \\\n\t\t(obj)->gpuva.lock_dep_map = &(lock)->dep_map\n#define drm_gem_gpuva_assert_lock_held(obj) \\\n\tlockdep_assert((obj)->gpuva.lock_dep_map ? \\\n\t\t       lock_is_held((obj)->gpuva.lock_dep_map) : \\\n\t\t       dma_resv_held((obj)->resv))\n#else\n#define drm_gem_gpuva_set_lock(obj, lock) do {} while (0)\n#define drm_gem_gpuva_assert_lock_held(obj) do {} while (0)\n#endif\n\n \nstatic inline void drm_gem_gpuva_init(struct drm_gem_object *obj)\n{\n\tINIT_LIST_HEAD(&obj->gpuva.list);\n}\n\n \n#define drm_gem_for_each_gpuva(entry__, obj__) \\\n\tlist_for_each_entry(entry__, &(obj__)->gpuva.list, gem.entry)\n\n \n#define drm_gem_for_each_gpuva_safe(entry__, next__, obj__) \\\n\tlist_for_each_entry_safe(entry__, next__, &(obj__)->gpuva.list, gem.entry)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}