{
  "module_name": "drm_connector.h",
  "hash_id": "142f02af48599de51e3d3ad8b48c988de2a0b674372659f11243a56514d00519",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_connector.h",
  "human_readable_source": " \n\n#ifndef __DRM_CONNECTOR_H__\n#define __DRM_CONNECTOR_H__\n\n#include <linux/list.h>\n#include <linux/llist.h>\n#include <linux/ctype.h>\n#include <linux/hdmi.h>\n#include <linux/notifier.h>\n#include <drm/drm_mode_object.h>\n#include <drm/drm_util.h>\n#include <drm/drm_property.h>\n\n#include <uapi/drm/drm_mode.h>\n\nstruct drm_connector_helper_funcs;\nstruct drm_modeset_acquire_ctx;\nstruct drm_device;\nstruct drm_crtc;\nstruct drm_encoder;\nstruct drm_panel;\nstruct drm_property;\nstruct drm_property_blob;\nstruct drm_printer;\nstruct drm_privacy_screen;\nstruct edid;\nstruct i2c_adapter;\n\nenum drm_connector_force {\n\tDRM_FORCE_UNSPECIFIED,\n\tDRM_FORCE_OFF,\n\tDRM_FORCE_ON,          \n\tDRM_FORCE_ON_DIGITAL,  \n};\n\n \nenum drm_connector_status {\n\t \n\tconnector_status_connected = 1,\n\t \n\tconnector_status_disconnected = 2,\n\t \n\tconnector_status_unknown = 3,\n};\n\n \nenum drm_connector_registration_state {\n\t \n\tDRM_CONNECTOR_INITIALIZING = 0,\n\n\t \n\tDRM_CONNECTOR_REGISTERED = 1,\n\n\t \n\tDRM_CONNECTOR_UNREGISTERED = 2,\n};\n\nenum subpixel_order {\n\tSubPixelUnknown = 0,\n\tSubPixelHorizontalRGB,\n\tSubPixelHorizontalBGR,\n\tSubPixelVerticalRGB,\n\tSubPixelVerticalBGR,\n\tSubPixelNone,\n\n};\n\n \nenum drm_connector_tv_mode {\n\t \n\tDRM_MODE_TV_MODE_NTSC,\n\n\t \n\tDRM_MODE_TV_MODE_NTSC_443,\n\n\t \n\tDRM_MODE_TV_MODE_NTSC_J,\n\n\t \n\tDRM_MODE_TV_MODE_PAL,\n\n\t \n\tDRM_MODE_TV_MODE_PAL_M,\n\n\t \n\tDRM_MODE_TV_MODE_PAL_N,\n\n\t \n\tDRM_MODE_TV_MODE_SECAM,\n\n\t \n\tDRM_MODE_TV_MODE_MAX,\n};\n\n \nstruct drm_scrambling {\n\t \n\tbool supported;\n\t \n\tbool low_rates;\n};\n\n \nstruct drm_scdc {\n\t \n\tbool supported;\n\t \n\tbool read_request;\n\t \n\tstruct drm_scrambling scrambling;\n};\n\n \nstruct drm_hdmi_dsc_cap {\n\t \n\tbool v_1p2;\n\n\t \n\tbool native_420;\n\n\t \n\tbool all_bpp;\n\n\t \n\tu8 bpc_supported;\n\n\t \n\tu8 max_slices;\n\n\t \n\tint clk_per_slice;\n\n\t \n\tu8 max_lanes;\n\n\t \n\tu8 max_frl_rate_per_lane;\n\n\t \n\tu8 total_chunk_kbytes;\n};\n\n \nstruct drm_hdmi_info {\n\t \n\tstruct drm_scdc scdc;\n\n\t \n\tunsigned long y420_vdb_modes[BITS_TO_LONGS(256)];\n\n\t \n\tunsigned long y420_cmdb_modes[BITS_TO_LONGS(256)];\n\n\t \n\tu8 y420_dc_modes;\n\n\t \n\tu8 max_frl_rate_per_lane;\n\n\t \n\tu8 max_lanes;\n\n\t \n\tstruct drm_hdmi_dsc_cap dsc_cap;\n};\n\n \nenum drm_link_status {\n\tDRM_LINK_STATUS_GOOD = DRM_MODE_LINK_STATUS_GOOD,\n\tDRM_LINK_STATUS_BAD = DRM_MODE_LINK_STATUS_BAD,\n};\n\n \nenum drm_panel_orientation {\n\tDRM_MODE_PANEL_ORIENTATION_UNKNOWN = -1,\n\tDRM_MODE_PANEL_ORIENTATION_NORMAL = 0,\n\tDRM_MODE_PANEL_ORIENTATION_BOTTOM_UP,\n\tDRM_MODE_PANEL_ORIENTATION_LEFT_UP,\n\tDRM_MODE_PANEL_ORIENTATION_RIGHT_UP,\n};\n\n \nstruct drm_monitor_range_info {\n\tu16 min_vfreq;\n\tu16 max_vfreq;\n};\n\n \nstruct drm_luminance_range_info {\n\tu32 min_luminance;\n\tu32 max_luminance;\n};\n\n \nenum drm_privacy_screen_status {\n\tPRIVACY_SCREEN_DISABLED = 0,\n\tPRIVACY_SCREEN_ENABLED,\n\tPRIVACY_SCREEN_DISABLED_LOCKED,\n\tPRIVACY_SCREEN_ENABLED_LOCKED,\n};\n\n \nenum drm_colorspace {\n\t \n\tDRM_MODE_COLORIMETRY_DEFAULT \t\t= 0,\n\t \n\tDRM_MODE_COLORIMETRY_NO_DATA\t\t= 0,\n\tDRM_MODE_COLORIMETRY_SMPTE_170M_YCC\t= 1,\n\tDRM_MODE_COLORIMETRY_BT709_YCC\t\t= 2,\n\t \n\tDRM_MODE_COLORIMETRY_XVYCC_601\t\t= 3,\n\tDRM_MODE_COLORIMETRY_XVYCC_709\t\t= 4,\n\tDRM_MODE_COLORIMETRY_SYCC_601\t\t= 5,\n\tDRM_MODE_COLORIMETRY_OPYCC_601\t\t= 6,\n\tDRM_MODE_COLORIMETRY_OPRGB\t\t= 7,\n\tDRM_MODE_COLORIMETRY_BT2020_CYCC\t= 8,\n\tDRM_MODE_COLORIMETRY_BT2020_RGB\t\t= 9,\n\tDRM_MODE_COLORIMETRY_BT2020_YCC\t\t= 10,\n\t \n\tDRM_MODE_COLORIMETRY_DCI_P3_RGB_D65\t= 11,\n\tDRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER\t= 12,\n\t \n\tDRM_MODE_COLORIMETRY_RGB_WIDE_FIXED\t= 13,\n\tDRM_MODE_COLORIMETRY_RGB_WIDE_FLOAT\t= 14,\n\tDRM_MODE_COLORIMETRY_BT601_YCC\t\t= 15,\n\t \n\tDRM_MODE_COLORIMETRY_COUNT\n};\n\n \nenum drm_bus_flags {\n\t \n\tDRM_BUS_FLAG_DE_LOW = BIT(0),\n\n\t \n\tDRM_BUS_FLAG_DE_HIGH = BIT(1),\n\n\t \n\tDRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE = BIT(2),\n\n\t \n\tDRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE = BIT(3),\n\n\t \n\tDRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE = DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE,\n\n\t \n\tDRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE = DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE,\n\n\t \n\tDRM_BUS_FLAG_DATA_MSB_TO_LSB = BIT(4),\n\n\t \n\tDRM_BUS_FLAG_DATA_LSB_TO_MSB = BIT(5),\n\n\t \n\tDRM_BUS_FLAG_SYNC_DRIVE_POSEDGE = BIT(6),\n\n\t \n\tDRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE = BIT(7),\n\n\t \n\tDRM_BUS_FLAG_SYNC_SAMPLE_POSEDGE = DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE,\n\n\t \n\tDRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE = DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE,\n\n\t \n\tDRM_BUS_FLAG_SHARP_SIGNALS = BIT(8),\n};\n\n \nstruct drm_display_info {\n\t \n\tunsigned int width_mm;\n\n\t \n\tunsigned int height_mm;\n\n\t \n\tunsigned int bpc;\n\n\t \n\tenum subpixel_order subpixel_order;\n\n#define DRM_COLOR_FORMAT_RGB444\t\t(1<<0)\n#define DRM_COLOR_FORMAT_YCBCR444\t(1<<1)\n#define DRM_COLOR_FORMAT_YCBCR422\t(1<<2)\n#define DRM_COLOR_FORMAT_YCBCR420\t(1<<3)\n\n\t \n\tint panel_orientation;\n\n\t \n\tu32 color_formats;\n\n\t \n\tconst u32 *bus_formats;\n\t \n\tunsigned int num_bus_formats;\n\n\t \n\tu32 bus_flags;\n\n\t \n\tint max_tmds_clock;\n\n\t \n\tbool dvi_dual;\n\n\t \n\tbool is_hdmi;\n\n\t \n\tbool has_audio;\n\n\t \n\tbool has_hdmi_infoframe;\n\n\t \n\tbool rgb_quant_range_selectable;\n\n\t \n\tu8 edid_hdmi_rgb444_dc_modes;\n\n\t \n\tu8 edid_hdmi_ycbcr444_dc_modes;\n\n\t \n\tu8 cea_rev;\n\n\t \n\tstruct drm_hdmi_info hdmi;\n\n\t \n\tbool non_desktop;\n\n\t \n\tstruct drm_monitor_range_info monitor_range;\n\n\t \n\tstruct drm_luminance_range_info luminance_range;\n\n\t \n\tu8 mso_stream_count;\n\n\t \n\tu8 mso_pixel_overlap;\n\n\t \n\tu32 max_dsc_bpp;\n\n\t \n\tu8 *vics;\n\n\t \n\tint vics_len;\n\n\t \n\tu32 quirks;\n};\n\nint drm_display_info_set_bus_formats(struct drm_display_info *info,\n\t\t\t\t     const u32 *formats,\n\t\t\t\t     unsigned int num_formats);\n\n \nstruct drm_connector_tv_margins {\n\t \n\tunsigned int bottom;\n\n\t \n\tunsigned int left;\n\n\t \n\tunsigned int right;\n\n\t \n\tunsigned int top;\n};\n\n \nstruct drm_tv_connector_state {\n\tenum drm_mode_subconnector select_subconnector;\n\tenum drm_mode_subconnector subconnector;\n\tstruct drm_connector_tv_margins margins;\n\tunsigned int legacy_mode;\n\tunsigned int mode;\n\tunsigned int brightness;\n\tunsigned int contrast;\n\tunsigned int flicker_reduction;\n\tunsigned int overscan;\n\tunsigned int saturation;\n\tunsigned int hue;\n};\n\n \nstruct drm_connector_state {\n\t \n\tstruct drm_connector *connector;\n\n\t \n\tstruct drm_crtc *crtc;\n\n\t \n\tstruct drm_encoder *best_encoder;\n\n\t \n\tenum drm_link_status link_status;\n\n\t \n\tstruct drm_atomic_state *state;\n\n\t \n\tstruct drm_crtc_commit *commit;\n\n\t \n\tstruct drm_tv_connector_state tv;\n\n\t \n\tbool self_refresh_aware;\n\n\t \n\tenum hdmi_picture_aspect picture_aspect_ratio;\n\n\t \n\tunsigned int content_type;\n\n\t \n\tunsigned int hdcp_content_type;\n\n\t \n\tunsigned int scaling_mode;\n\n\t \n\tunsigned int content_protection;\n\n\t \n\tenum drm_colorspace colorspace;\n\n\t \n\tstruct drm_writeback_job *writeback_job;\n\n\t \n\tu8 max_requested_bpc;\n\n\t \n\tu8 max_bpc;\n\n\t \n\tenum drm_privacy_screen_status privacy_screen_sw_state;\n\n\t \n\tstruct drm_property_blob *hdr_output_metadata;\n};\n\n \nstruct drm_connector_funcs {\n\t \n\tint (*dpms)(struct drm_connector *connector, int mode);\n\n\t \n\tvoid (*reset)(struct drm_connector *connector);\n\n\t \n\tenum drm_connector_status (*detect)(struct drm_connector *connector,\n\t\t\t\t\t    bool force);\n\n\t \n\tvoid (*force)(struct drm_connector *connector);\n\n\t \n\tint (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);\n\n\t \n\tint (*set_property)(struct drm_connector *connector, struct drm_property *property,\n\t\t\t     uint64_t val);\n\n\t \n\tint (*late_register)(struct drm_connector *connector);\n\n\t \n\tvoid (*early_unregister)(struct drm_connector *connector);\n\n\t \n\tvoid (*destroy)(struct drm_connector *connector);\n\n\t \n\tstruct drm_connector_state *(*atomic_duplicate_state)(struct drm_connector *connector);\n\n\t \n\tvoid (*atomic_destroy_state)(struct drm_connector *connector,\n\t\t\t\t     struct drm_connector_state *state);\n\n\t \n\tint (*atomic_set_property)(struct drm_connector *connector,\n\t\t\t\t   struct drm_connector_state *state,\n\t\t\t\t   struct drm_property *property,\n\t\t\t\t   uint64_t val);\n\n\t \n\tint (*atomic_get_property)(struct drm_connector *connector,\n\t\t\t\t   const struct drm_connector_state *state,\n\t\t\t\t   struct drm_property *property,\n\t\t\t\t   uint64_t *val);\n\n\t \n\tvoid (*atomic_print_state)(struct drm_printer *p,\n\t\t\t\t   const struct drm_connector_state *state);\n\n\t \n\tvoid (*oob_hotplug_event)(struct drm_connector *connector);\n\n\t \n\tvoid (*debugfs_init)(struct drm_connector *connector, struct dentry *root);\n};\n\n \nstruct drm_cmdline_mode {\n\t \n\tchar name[DRM_DISPLAY_MODE_LEN];\n\n\t \n\tbool specified;\n\n\t \n\tbool refresh_specified;\n\n\t \n\tbool bpp_specified;\n\n\t \n\tunsigned int pixel_clock;\n\n\t \n\tint xres;\n\n\t \n\tint yres;\n\n\t \n\tint bpp;\n\n\t \n\tint refresh;\n\n\t \n\tbool rb;\n\n\t \n\tbool interlace;\n\n\t \n\tbool cvt;\n\n\t \n\tbool margins;\n\n\t \n\tenum drm_connector_force force;\n\n\t \n\tunsigned int rotation_reflection;\n\n\t \n\tenum drm_panel_orientation panel_orientation;\n\n\t \n\tstruct drm_connector_tv_margins tv_margins;\n\n\t \n\tenum drm_connector_tv_mode tv_mode;\n\n\t \n\tbool tv_mode_specified;\n};\n\n \nstruct drm_connector {\n\t \n\tstruct drm_device *dev;\n\t \n\tstruct device *kdev;\n\t \n\tstruct device_attribute *attr;\n\t \n\tstruct fwnode_handle *fwnode;\n\n\t \n\tstruct list_head head;\n\n\t \n\tstruct list_head global_connector_list_entry;\n\n\t \n\tstruct drm_mode_object base;\n\n\t \n\tchar *name;\n\n\t \n\tstruct mutex mutex;\n\n\t \n\tunsigned index;\n\n\t \n\tint connector_type;\n\t \n\tint connector_type_id;\n\t \n\tbool interlace_allowed;\n\t \n\tbool doublescan_allowed;\n\t \n\tbool stereo_allowed;\n\n\t \n\tbool ycbcr_420_allowed;\n\n\t \n\tenum drm_connector_registration_state registration_state;\n\n\t \n\tstruct list_head modes;\n\n\t \n\tenum drm_connector_status status;\n\n\t \n\tstruct list_head probed_modes;\n\n\t \n\tstruct drm_display_info display_info;\n\n\t \n\tconst struct drm_connector_funcs *funcs;\n\n\t \n\tstruct drm_property_blob *edid_blob_ptr;\n\n\t \n\tstruct drm_object_properties properties;\n\n\t \n\tstruct drm_property *scaling_mode_property;\n\n\t \n\tstruct drm_property *vrr_capable_property;\n\n\t \n\tstruct drm_property *colorspace_property;\n\n\t \n\tstruct drm_property_blob *path_blob_ptr;\n\n\t \n\tstruct drm_property *max_bpc_property;\n\n\t \n\tstruct drm_privacy_screen *privacy_screen;\n\n\t \n\tstruct notifier_block privacy_screen_notifier;\n\n\t \n\tstruct drm_property *privacy_screen_sw_state_property;\n\n\t \n\tstruct drm_property *privacy_screen_hw_state_property;\n\n#define DRM_CONNECTOR_POLL_HPD (1 << 0)\n#define DRM_CONNECTOR_POLL_CONNECT (1 << 1)\n#define DRM_CONNECTOR_POLL_DISCONNECT (1 << 2)\n\n\t \n\tuint8_t polled;\n\n\t \n\tint dpms;\n\n\t \n\tconst struct drm_connector_helper_funcs *helper_private;\n\n\t \n\tstruct drm_cmdline_mode cmdline_mode;\n\t \n\tenum drm_connector_force force;\n\n\t \n\tconst struct drm_edid *edid_override;\n\n\t \n\tstruct mutex edid_override_mutex;\n\n\t \n\tu64 epoch_counter;\n\n\t \n\tu32 possible_encoders;\n\n\t \n\tstruct drm_encoder *encoder;\n\n#define MAX_ELD_BYTES\t128\n\t \n\tuint8_t eld[MAX_ELD_BYTES];\n\t \n\tbool latency_present[2];\n\t \n\tint video_latency[2];\n\t \n\tint audio_latency[2];\n\n\t \n\tstruct i2c_adapter *ddc;\n\n\t \n\tint null_edid_counter;\n\n\t \n\tunsigned bad_edid_counter;\n\n\t \n\tbool edid_corrupt;\n\t \n\tu8 real_edid_checksum;\n\n\t \n\tstruct dentry *debugfs_entry;\n\n\t \n\tstruct drm_connector_state *state;\n\n\t \n\n\t \n\tstruct drm_property_blob *tile_blob_ptr;\n\n\t \n\tbool has_tile;\n\t \n\tstruct drm_tile_group *tile_group;\n\t \n\tbool tile_is_single_monitor;\n\n\t \n\t \n\tuint8_t num_h_tile, num_v_tile;\n\t \n\t \n\tuint8_t tile_h_loc, tile_v_loc;\n\t \n\t \n\tuint16_t tile_h_size, tile_v_size;\n\n\t \n\tstruct llist_node free_node;\n\n\t \n\tstruct hdr_sink_metadata hdr_sink_metadata;\n};\n\n#define obj_to_connector(x) container_of(x, struct drm_connector, base)\n\nint drm_connector_init(struct drm_device *dev,\n\t\t       struct drm_connector *connector,\n\t\t       const struct drm_connector_funcs *funcs,\n\t\t       int connector_type);\nint drm_connector_init_with_ddc(struct drm_device *dev,\n\t\t\t\tstruct drm_connector *connector,\n\t\t\t\tconst struct drm_connector_funcs *funcs,\n\t\t\t\tint connector_type,\n\t\t\t\tstruct i2c_adapter *ddc);\nint drmm_connector_init(struct drm_device *dev,\n\t\t\tstruct drm_connector *connector,\n\t\t\tconst struct drm_connector_funcs *funcs,\n\t\t\tint connector_type,\n\t\t\tstruct i2c_adapter *ddc);\nvoid drm_connector_attach_edid_property(struct drm_connector *connector);\nint drm_connector_register(struct drm_connector *connector);\nvoid drm_connector_unregister(struct drm_connector *connector);\nint drm_connector_attach_encoder(struct drm_connector *connector,\n\t\t\t\t      struct drm_encoder *encoder);\n\nvoid drm_connector_cleanup(struct drm_connector *connector);\n\nstatic inline unsigned int drm_connector_index(const struct drm_connector *connector)\n{\n\treturn connector->index;\n}\n\nstatic inline u32 drm_connector_mask(const struct drm_connector *connector)\n{\n\treturn 1 << connector->index;\n}\n\n \nstatic inline struct drm_connector *drm_connector_lookup(struct drm_device *dev,\n\t\tstruct drm_file *file_priv,\n\t\tuint32_t id)\n{\n\tstruct drm_mode_object *mo;\n\tmo = drm_mode_object_find(dev, file_priv, id, DRM_MODE_OBJECT_CONNECTOR);\n\treturn mo ? obj_to_connector(mo) : NULL;\n}\n\n \nstatic inline void drm_connector_get(struct drm_connector *connector)\n{\n\tdrm_mode_object_get(&connector->base);\n}\n\n \nstatic inline void drm_connector_put(struct drm_connector *connector)\n{\n\tdrm_mode_object_put(&connector->base);\n}\n\n \nstatic inline bool\ndrm_connector_is_unregistered(struct drm_connector *connector)\n{\n\treturn READ_ONCE(connector->registration_state) ==\n\t\tDRM_CONNECTOR_UNREGISTERED;\n}\n\nvoid drm_connector_oob_hotplug_event(struct fwnode_handle *connector_fwnode);\nconst char *drm_get_connector_type_name(unsigned int connector_type);\nconst char *drm_get_connector_status_name(enum drm_connector_status status);\nconst char *drm_get_subpixel_order_name(enum subpixel_order order);\nconst char *drm_get_dpms_name(int val);\nconst char *drm_get_dvi_i_subconnector_name(int val);\nconst char *drm_get_dvi_i_select_name(int val);\nconst char *drm_get_tv_mode_name(int val);\nconst char *drm_get_tv_subconnector_name(int val);\nconst char *drm_get_tv_select_name(int val);\nconst char *drm_get_dp_subconnector_name(int val);\nconst char *drm_get_content_protection_name(int val);\nconst char *drm_get_hdcp_content_type_name(int val);\n\nint drm_get_tv_mode_from_name(const char *name, size_t len);\n\nint drm_mode_create_dvi_i_properties(struct drm_device *dev);\nvoid drm_connector_attach_dp_subconnector_property(struct drm_connector *connector);\n\nint drm_mode_create_tv_margin_properties(struct drm_device *dev);\nint drm_mode_create_tv_properties_legacy(struct drm_device *dev,\n\t\t\t\t\t unsigned int num_modes,\n\t\t\t\t\t const char * const modes[]);\nint drm_mode_create_tv_properties(struct drm_device *dev,\n\t\t\t\t  unsigned int supported_tv_modes);\nvoid drm_connector_attach_tv_margin_properties(struct drm_connector *conn);\nint drm_mode_create_scaling_mode_property(struct drm_device *dev);\nint drm_connector_attach_content_type_property(struct drm_connector *dev);\nint drm_connector_attach_scaling_mode_property(struct drm_connector *connector,\n\t\t\t\t\t       u32 scaling_mode_mask);\nint drm_connector_attach_vrr_capable_property(\n\t\tstruct drm_connector *connector);\nint drm_connector_attach_colorspace_property(struct drm_connector *connector);\nint drm_connector_attach_hdr_output_metadata_property(struct drm_connector *connector);\nbool drm_connector_atomic_hdr_metadata_equal(struct drm_connector_state *old_state,\n\t\t\t\t\t     struct drm_connector_state *new_state);\nint drm_mode_create_aspect_ratio_property(struct drm_device *dev);\nint drm_mode_create_hdmi_colorspace_property(struct drm_connector *connector,\n\t\t\t\t\t     u32 supported_colorspaces);\nint drm_mode_create_dp_colorspace_property(struct drm_connector *connector,\n\t\t\t\t\t   u32 supported_colorspaces);\nint drm_mode_create_content_type_property(struct drm_device *dev);\nint drm_mode_create_suggested_offset_properties(struct drm_device *dev);\n\nint drm_connector_set_path_property(struct drm_connector *connector,\n\t\t\t\t    const char *path);\nint drm_connector_set_tile_property(struct drm_connector *connector);\nint drm_connector_update_edid_property(struct drm_connector *connector,\n\t\t\t\t       const struct edid *edid);\nvoid drm_connector_set_link_status_property(struct drm_connector *connector,\n\t\t\t\t\t    uint64_t link_status);\nvoid drm_connector_set_vrr_capable_property(\n\t\tstruct drm_connector *connector, bool capable);\nint drm_connector_set_panel_orientation(\n\tstruct drm_connector *connector,\n\tenum drm_panel_orientation panel_orientation);\nint drm_connector_set_panel_orientation_with_quirk(\n\tstruct drm_connector *connector,\n\tenum drm_panel_orientation panel_orientation,\n\tint width, int height);\nint drm_connector_set_orientation_from_panel(\n\tstruct drm_connector *connector,\n\tstruct drm_panel *panel);\nint drm_connector_attach_max_bpc_property(struct drm_connector *connector,\n\t\t\t\t\t  int min, int max);\nvoid drm_connector_create_privacy_screen_properties(struct drm_connector *conn);\nvoid drm_connector_attach_privacy_screen_properties(struct drm_connector *conn);\nvoid drm_connector_attach_privacy_screen_provider(\n\tstruct drm_connector *connector, struct drm_privacy_screen *priv);\nvoid drm_connector_update_privacy_screen(const struct drm_connector_state *connector_state);\n\n \nstruct drm_tile_group {\n\tstruct kref refcount;\n\tstruct drm_device *dev;\n\tint id;\n\tu8 group_data[8];\n};\n\nstruct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,\n\t\t\t\t\t\t  const char topology[8]);\nstruct drm_tile_group *drm_mode_get_tile_group(struct drm_device *dev,\n\t\t\t\t\t       const char topology[8]);\nvoid drm_mode_put_tile_group(struct drm_device *dev,\n\t\t\t     struct drm_tile_group *tg);\n\n \nstruct drm_connector_list_iter {\n \n\tstruct drm_device *dev;\n\tstruct drm_connector *conn;\n};\n\nvoid drm_connector_list_iter_begin(struct drm_device *dev,\n\t\t\t\t   struct drm_connector_list_iter *iter);\nstruct drm_connector *\ndrm_connector_list_iter_next(struct drm_connector_list_iter *iter);\nvoid drm_connector_list_iter_end(struct drm_connector_list_iter *iter);\n\nbool drm_connector_has_possible_encoder(struct drm_connector *connector,\n\t\t\t\t\tstruct drm_encoder *encoder);\nconst char *drm_get_colorspace_name(enum drm_colorspace colorspace);\n\n \n#define drm_for_each_connector_iter(connector, iter) \\\n\twhile ((connector = drm_connector_list_iter_next(iter)))\n\n \n#define drm_connector_for_each_possible_encoder(connector, encoder) \\\n\tdrm_for_each_encoder_mask(encoder, (connector)->dev, \\\n\t\t\t\t  (connector)->possible_encoders)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}