{
  "module_name": "drm_edid.h",
  "hash_id": "5b4ac492e8035e0eb59d1d804785ca80b0ec214ace8349abad5efc78422a1a49",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_edid.h",
  "human_readable_source": " \n#ifndef __DRM_EDID_H__\n#define __DRM_EDID_H__\n\n#include <linux/types.h>\n#include <linux/hdmi.h>\n#include <drm/drm_mode.h>\n\nstruct drm_device;\nstruct drm_edid;\nstruct i2c_adapter;\n\n#define EDID_LENGTH 128\n#define DDC_ADDR 0x50\n#define DDC_ADDR2 0x52  \n\n#define CEA_EXT\t    0x02\n#define VTB_EXT\t    0x10\n#define DI_EXT\t    0x40\n#define LS_EXT\t    0x50\n#define MI_EXT\t    0x60\n#define DISPLAYID_EXT 0x70\n\nstruct est_timings {\n\tu8 t1;\n\tu8 t2;\n\tu8 mfg_rsvd;\n} __attribute__((packed));\n\n \n#define EDID_TIMING_ASPECT_SHIFT 6\n#define EDID_TIMING_ASPECT_MASK  (0x3 << EDID_TIMING_ASPECT_SHIFT)\n\n \n#define EDID_TIMING_VFREQ_SHIFT  0\n#define EDID_TIMING_VFREQ_MASK   (0x3f << EDID_TIMING_VFREQ_SHIFT)\n\nstruct std_timing {\n\tu8 hsize;  \n\tu8 vfreq_aspect;\n} __attribute__((packed));\n\n#define DRM_EDID_PT_HSYNC_POSITIVE (1 << 1)\n#define DRM_EDID_PT_VSYNC_POSITIVE (1 << 2)\n#define DRM_EDID_PT_SEPARATE_SYNC  (3 << 3)\n#define DRM_EDID_PT_STEREO         (1 << 5)\n#define DRM_EDID_PT_INTERLACED     (1 << 7)\n\n \nstruct detailed_pixel_timing {\n\tu8 hactive_lo;\n\tu8 hblank_lo;\n\tu8 hactive_hblank_hi;\n\tu8 vactive_lo;\n\tu8 vblank_lo;\n\tu8 vactive_vblank_hi;\n\tu8 hsync_offset_lo;\n\tu8 hsync_pulse_width_lo;\n\tu8 vsync_offset_pulse_width_lo;\n\tu8 hsync_vsync_offset_pulse_width_hi;\n\tu8 width_mm_lo;\n\tu8 height_mm_lo;\n\tu8 width_height_mm_hi;\n\tu8 hborder;\n\tu8 vborder;\n\tu8 misc;\n} __attribute__((packed));\n\n \nstruct detailed_data_string {\n\tu8 str[13];\n} __attribute__((packed));\n\n#define DRM_EDID_RANGE_OFFSET_MIN_VFREQ (1 << 0)  \n#define DRM_EDID_RANGE_OFFSET_MAX_VFREQ (1 << 1)  \n#define DRM_EDID_RANGE_OFFSET_MIN_HFREQ (1 << 2)  \n#define DRM_EDID_RANGE_OFFSET_MAX_HFREQ (1 << 3)  \n\n#define DRM_EDID_DEFAULT_GTF_SUPPORT_FLAG   0x00  \n#define DRM_EDID_RANGE_LIMITS_ONLY_FLAG     0x01  \n#define DRM_EDID_SECONDARY_GTF_SUPPORT_FLAG 0x02  \n#define DRM_EDID_CVT_SUPPORT_FLAG           0x04  \n\n#define DRM_EDID_CVT_FLAGS_STANDARD_BLANKING (1 << 3)\n#define DRM_EDID_CVT_FLAGS_REDUCED_BLANKING  (1 << 4)\n\nstruct detailed_data_monitor_range {\n\tu8 min_vfreq;\n\tu8 max_vfreq;\n\tu8 min_hfreq_khz;\n\tu8 max_hfreq_khz;\n\tu8 pixel_clock_mhz;  \n\tu8 flags;\n\tunion {\n\t\tstruct {\n\t\t\tu8 reserved;\n\t\t\tu8 hfreq_start_khz;  \n\t\t\tu8 c;  \n\t\t\t__le16 m;\n\t\t\tu8 k;\n\t\t\tu8 j;  \n\t\t} __attribute__((packed)) gtf2;\n\t\tstruct {\n\t\t\tu8 version;\n\t\t\tu8 data1;  \n\t\t\tu8 data2;  \n\t\t\tu8 supported_aspects;\n\t\t\tu8 flags;  \n\t\t\tu8 supported_scalings;\n\t\t\tu8 preferred_refresh;\n\t\t} __attribute__((packed)) cvt;\n\t} __attribute__((packed)) formula;\n} __attribute__((packed));\n\nstruct detailed_data_wpindex {\n\tu8 white_yx_lo;  \n\tu8 white_x_hi;\n\tu8 white_y_hi;\n\tu8 gamma;  \n} __attribute__((packed));\n\nstruct detailed_data_color_point {\n\tu8 windex1;\n\tu8 wpindex1[3];\n\tu8 windex2;\n\tu8 wpindex2[3];\n} __attribute__((packed));\n\nstruct cvt_timing {\n\tu8 code[3];\n} __attribute__((packed));\n\nstruct detailed_non_pixel {\n\tu8 pad1;\n\tu8 type;  \n\tu8 pad2;\n\tunion {\n\t\tstruct detailed_data_string str;\n\t\tstruct detailed_data_monitor_range range;\n\t\tstruct detailed_data_wpindex color;\n\t\tstruct std_timing timings[6];\n\t\tstruct cvt_timing cvt[4];\n\t} __attribute__((packed)) data;\n} __attribute__((packed));\n\n#define EDID_DETAIL_EST_TIMINGS 0xf7\n#define EDID_DETAIL_CVT_3BYTE 0xf8\n#define EDID_DETAIL_COLOR_MGMT_DATA 0xf9\n#define EDID_DETAIL_STD_MODES 0xfa\n#define EDID_DETAIL_MONITOR_CPDATA 0xfb\n#define EDID_DETAIL_MONITOR_NAME 0xfc\n#define EDID_DETAIL_MONITOR_RANGE 0xfd\n#define EDID_DETAIL_MONITOR_STRING 0xfe\n#define EDID_DETAIL_MONITOR_SERIAL 0xff\n\nstruct detailed_timing {\n\t__le16 pixel_clock;  \n\tunion {\n\t\tstruct detailed_pixel_timing pixel_data;\n\t\tstruct detailed_non_pixel other_data;\n\t} __attribute__((packed)) data;\n} __attribute__((packed));\n\n#define DRM_EDID_INPUT_SERRATION_VSYNC (1 << 0)\n#define DRM_EDID_INPUT_SYNC_ON_GREEN   (1 << 1)\n#define DRM_EDID_INPUT_COMPOSITE_SYNC  (1 << 2)\n#define DRM_EDID_INPUT_SEPARATE_SYNCS  (1 << 3)\n#define DRM_EDID_INPUT_BLANK_TO_BLACK  (1 << 4)\n#define DRM_EDID_INPUT_VIDEO_LEVEL     (3 << 5)\n#define DRM_EDID_INPUT_DIGITAL         (1 << 7)\n#define DRM_EDID_DIGITAL_DEPTH_MASK    (7 << 4)  \n#define DRM_EDID_DIGITAL_DEPTH_UNDEF   (0 << 4)  \n#define DRM_EDID_DIGITAL_DEPTH_6       (1 << 4)  \n#define DRM_EDID_DIGITAL_DEPTH_8       (2 << 4)  \n#define DRM_EDID_DIGITAL_DEPTH_10      (3 << 4)  \n#define DRM_EDID_DIGITAL_DEPTH_12      (4 << 4)  \n#define DRM_EDID_DIGITAL_DEPTH_14      (5 << 4)  \n#define DRM_EDID_DIGITAL_DEPTH_16      (6 << 4)  \n#define DRM_EDID_DIGITAL_DEPTH_RSVD    (7 << 4)  \n#define DRM_EDID_DIGITAL_TYPE_MASK     (7 << 0)  \n#define DRM_EDID_DIGITAL_TYPE_UNDEF    (0 << 0)  \n#define DRM_EDID_DIGITAL_TYPE_DVI      (1 << 0)  \n#define DRM_EDID_DIGITAL_TYPE_HDMI_A   (2 << 0)  \n#define DRM_EDID_DIGITAL_TYPE_HDMI_B   (3 << 0)  \n#define DRM_EDID_DIGITAL_TYPE_MDDI     (4 << 0)  \n#define DRM_EDID_DIGITAL_TYPE_DP       (5 << 0)  \n#define DRM_EDID_DIGITAL_DFP_1_X       (1 << 0)  \n\n#define DRM_EDID_FEATURE_DEFAULT_GTF      (1 << 0)  \n#define DRM_EDID_FEATURE_CONTINUOUS_FREQ  (1 << 0)  \n#define DRM_EDID_FEATURE_PREFERRED_TIMING (1 << 1)\n#define DRM_EDID_FEATURE_STANDARD_COLOR   (1 << 2)\n \n#define DRM_EDID_FEATURE_DISPLAY_TYPE     (3 << 3)  \n \n#define DRM_EDID_FEATURE_COLOR_MASK\t  (3 << 3)\n#define DRM_EDID_FEATURE_RGB\t\t  (0 << 3)\n#define DRM_EDID_FEATURE_RGB_YCRCB444\t  (1 << 3)\n#define DRM_EDID_FEATURE_RGB_YCRCB422\t  (2 << 3)\n#define DRM_EDID_FEATURE_RGB_YCRCB\t  (3 << 3)  \n\n#define DRM_EDID_FEATURE_PM_ACTIVE_OFF    (1 << 5)\n#define DRM_EDID_FEATURE_PM_SUSPEND       (1 << 6)\n#define DRM_EDID_FEATURE_PM_STANDBY       (1 << 7)\n\n#define DRM_EDID_HDMI_DC_48               (1 << 6)\n#define DRM_EDID_HDMI_DC_36               (1 << 5)\n#define DRM_EDID_HDMI_DC_30               (1 << 4)\n#define DRM_EDID_HDMI_DC_Y444             (1 << 3)\n\n \n#define DRM_EDID_YCBCR420_DC_48\t\t  (1 << 2)\n#define DRM_EDID_YCBCR420_DC_36\t\t  (1 << 1)\n#define DRM_EDID_YCBCR420_DC_30\t\t  (1 << 0)\n#define DRM_EDID_YCBCR420_DC_MASK (DRM_EDID_YCBCR420_DC_48 | \\\n\t\t\t\t    DRM_EDID_YCBCR420_DC_36 | \\\n\t\t\t\t    DRM_EDID_YCBCR420_DC_30)\n\n \n#define DRM_EDID_MAX_FRL_RATE_MASK\t\t0xf0\n#define DRM_EDID_FAPA_START_LOCATION\t\t(1 << 0)\n#define DRM_EDID_ALLM\t\t\t\t(1 << 1)\n#define DRM_EDID_FVA\t\t\t\t(1 << 2)\n\n \n#define DRM_EDID_DC_30BIT_420\t\t\t(1 << 0)\n#define DRM_EDID_DC_36BIT_420\t\t\t(1 << 1)\n#define DRM_EDID_DC_48BIT_420\t\t\t(1 << 2)\n\n \n#define DRM_EDID_CNMVRR\t\t\t\t(1 << 3)\n#define DRM_EDID_CINEMA_VRR\t\t\t(1 << 4)\n#define DRM_EDID_MDELTA\t\t\t\t(1 << 5)\n#define DRM_EDID_VRR_MAX_UPPER_MASK\t\t0xc0\n#define DRM_EDID_VRR_MAX_LOWER_MASK\t\t0xff\n#define DRM_EDID_VRR_MIN_MASK\t\t\t0x3f\n\n \n#define DRM_EDID_DSC_10BPC\t\t\t(1 << 0)\n#define DRM_EDID_DSC_12BPC\t\t\t(1 << 1)\n#define DRM_EDID_DSC_16BPC\t\t\t(1 << 2)\n#define DRM_EDID_DSC_ALL_BPP\t\t\t(1 << 3)\n#define DRM_EDID_DSC_NATIVE_420\t\t\t(1 << 6)\n#define DRM_EDID_DSC_1P2\t\t\t(1 << 7)\n#define DRM_EDID_DSC_MAX_FRL_RATE_MASK\t\t0xf0\n#define DRM_EDID_DSC_MAX_SLICES\t\t\t0xf\n#define DRM_EDID_DSC_TOTAL_CHUNK_KBYTES\t\t0x3f\n\n \n#define DRM_ELD_HEADER_BLOCK_SIZE\t4\n\n#define DRM_ELD_VER\t\t\t0\n# define DRM_ELD_VER_SHIFT\t\t3\n# define DRM_ELD_VER_MASK\t\t(0x1f << 3)\n# define DRM_ELD_VER_CEA861D\t\t(2 << 3)  \n# define DRM_ELD_VER_CANNED\t\t(0x1f << 3)\n\n#define DRM_ELD_BASELINE_ELD_LEN\t2\t \n\n \n#define DRM_ELD_CEA_EDID_VER_MNL\t4\n# define DRM_ELD_CEA_EDID_VER_SHIFT\t5\n# define DRM_ELD_CEA_EDID_VER_MASK\t(7 << 5)\n# define DRM_ELD_CEA_EDID_VER_NONE\t(0 << 5)\n# define DRM_ELD_CEA_EDID_VER_CEA861\t(1 << 5)\n# define DRM_ELD_CEA_EDID_VER_CEA861A\t(2 << 5)\n# define DRM_ELD_CEA_EDID_VER_CEA861BCD\t(3 << 5)\n# define DRM_ELD_MNL_SHIFT\t\t0\n# define DRM_ELD_MNL_MASK\t\t(0x1f << 0)\n\n#define DRM_ELD_SAD_COUNT_CONN_TYPE\t5\n# define DRM_ELD_SAD_COUNT_SHIFT\t4\n# define DRM_ELD_SAD_COUNT_MASK\t\t(0xf << 4)\n# define DRM_ELD_CONN_TYPE_SHIFT\t2\n# define DRM_ELD_CONN_TYPE_MASK\t\t(3 << 2)\n# define DRM_ELD_CONN_TYPE_HDMI\t\t(0 << 2)\n# define DRM_ELD_CONN_TYPE_DP\t\t(1 << 2)\n# define DRM_ELD_SUPPORTS_AI\t\t(1 << 1)\n# define DRM_ELD_SUPPORTS_HDCP\t\t(1 << 0)\n\n#define DRM_ELD_AUD_SYNCH_DELAY\t\t6\t \n# define DRM_ELD_AUD_SYNCH_DELAY_MAX\t0xfa\t \n\n#define DRM_ELD_SPEAKER\t\t\t7\n# define DRM_ELD_SPEAKER_MASK\t\t0x7f\n# define DRM_ELD_SPEAKER_RLRC\t\t(1 << 6)\n# define DRM_ELD_SPEAKER_FLRC\t\t(1 << 5)\n# define DRM_ELD_SPEAKER_RC\t\t(1 << 4)\n# define DRM_ELD_SPEAKER_RLR\t\t(1 << 3)\n# define DRM_ELD_SPEAKER_FC\t\t(1 << 2)\n# define DRM_ELD_SPEAKER_LFE\t\t(1 << 1)\n# define DRM_ELD_SPEAKER_FLR\t\t(1 << 0)\n\n#define DRM_ELD_PORT_ID\t\t\t8\t \n# define DRM_ELD_PORT_ID_LEN\t\t8\n\n#define DRM_ELD_MANUFACTURER_NAME0\t16\n#define DRM_ELD_MANUFACTURER_NAME1\t17\n\n#define DRM_ELD_PRODUCT_CODE0\t\t18\n#define DRM_ELD_PRODUCT_CODE1\t\t19\n\n#define DRM_ELD_MONITOR_NAME_STRING\t20\t \n\n#define DRM_ELD_CEA_SAD(mnl, sad)\t(20 + (mnl) + 3 * (sad))\n\nstruct edid {\n\tu8 header[8];\n\t \n\tu8 mfg_id[2];\n\tu8 prod_code[2];\n\tu32 serial;  \n\tu8 mfg_week;\n\tu8 mfg_year;\n\t \n\tu8 version;\n\tu8 revision;\n\t \n\tu8 input;\n\tu8 width_cm;\n\tu8 height_cm;\n\tu8 gamma;\n\tu8 features;\n\t \n\tu8 red_green_lo;\n\tu8 blue_white_lo;\n\tu8 red_x;\n\tu8 red_y;\n\tu8 green_x;\n\tu8 green_y;\n\tu8 blue_x;\n\tu8 blue_y;\n\tu8 white_x;\n\tu8 white_y;\n\t \n\tstruct est_timings established_timings;\n\t \n\tstruct std_timing standard_timings[8];\n\t \n\tstruct detailed_timing detailed_timings[4];\n\t \n\tu8 extensions;\n\t \n\tu8 checksum;\n} __attribute__((packed));\n\n#define EDID_PRODUCT_ID(e) ((e)->prod_code[0] | ((e)->prod_code[1] << 8))\n\n \nstruct cea_sad {\n\tu8 format;\n\tu8 channels;  \n\tu8 freq;\n\tu8 byte2;  \n};\n\nstruct drm_encoder;\nstruct drm_connector;\nstruct drm_connector_state;\nstruct drm_display_mode;\n\nint drm_edid_to_sad(const struct edid *edid, struct cea_sad **sads);\nint drm_edid_to_speaker_allocation(const struct edid *edid, u8 **sadb);\nint drm_av_sync_delay(struct drm_connector *connector,\n\t\t      const struct drm_display_mode *mode);\n\n#ifdef CONFIG_DRM_LOAD_EDID_FIRMWARE\nint __drm_set_edid_firmware_path(const char *path);\nint __drm_get_edid_firmware_path(char *buf, size_t bufsize);\n#endif\n\nbool drm_edid_are_equal(const struct edid *edid1, const struct edid *edid2);\n\nint\ndrm_hdmi_avi_infoframe_from_display_mode(struct hdmi_avi_infoframe *frame,\n\t\t\t\t\t const struct drm_connector *connector,\n\t\t\t\t\t const struct drm_display_mode *mode);\nint\ndrm_hdmi_vendor_infoframe_from_display_mode(struct hdmi_vendor_infoframe *frame,\n\t\t\t\t\t    const struct drm_connector *connector,\n\t\t\t\t\t    const struct drm_display_mode *mode);\n\nvoid\ndrm_hdmi_avi_infoframe_quant_range(struct hdmi_avi_infoframe *frame,\n\t\t\t\t   const struct drm_connector *connector,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   enum hdmi_quantization_range rgb_quant_range);\n\n \nstatic inline int drm_eld_mnl(const uint8_t *eld)\n{\n\treturn (eld[DRM_ELD_CEA_EDID_VER_MNL] & DRM_ELD_MNL_MASK) >> DRM_ELD_MNL_SHIFT;\n}\n\n \nstatic inline const uint8_t *drm_eld_sad(const uint8_t *eld)\n{\n\tunsigned int ver, mnl;\n\n\tver = (eld[DRM_ELD_VER] & DRM_ELD_VER_MASK) >> DRM_ELD_VER_SHIFT;\n\tif (ver != 2 && ver != 31)\n\t\treturn NULL;\n\n\tmnl = drm_eld_mnl(eld);\n\tif (mnl > 16)\n\t\treturn NULL;\n\n\treturn eld + DRM_ELD_CEA_SAD(mnl, 0);\n}\n\n \nstatic inline int drm_eld_sad_count(const uint8_t *eld)\n{\n\treturn (eld[DRM_ELD_SAD_COUNT_CONN_TYPE] & DRM_ELD_SAD_COUNT_MASK) >>\n\t\tDRM_ELD_SAD_COUNT_SHIFT;\n}\n\n \nstatic inline int drm_eld_calc_baseline_block_size(const uint8_t *eld)\n{\n\treturn DRM_ELD_MONITOR_NAME_STRING - DRM_ELD_HEADER_BLOCK_SIZE +\n\t\tdrm_eld_mnl(eld) + drm_eld_sad_count(eld) * 3;\n}\n\n \nstatic inline int drm_eld_size(const uint8_t *eld)\n{\n\treturn DRM_ELD_HEADER_BLOCK_SIZE + eld[DRM_ELD_BASELINE_ELD_LEN] * 4;\n}\n\n \nstatic inline u8 drm_eld_get_spk_alloc(const uint8_t *eld)\n{\n\treturn eld[DRM_ELD_SPEAKER] & DRM_ELD_SPEAKER_MASK;\n}\n\n \nstatic inline u8 drm_eld_get_conn_type(const uint8_t *eld)\n{\n\treturn eld[DRM_ELD_SAD_COUNT_CONN_TYPE] & DRM_ELD_CONN_TYPE_MASK;\n}\n\n \nstatic inline const char *drm_edid_decode_mfg_id(u16 mfg_id, char vend[4])\n{\n\tvend[0] = '@' + ((mfg_id >> 10) & 0x1f);\n\tvend[1] = '@' + ((mfg_id >> 5) & 0x1f);\n\tvend[2] = '@' + ((mfg_id >> 0) & 0x1f);\n\tvend[3] = '\\0';\n\n\treturn vend;\n}\n\n \n#define drm_edid_encode_panel_id(vend_chr_0, vend_chr_1, vend_chr_2, product_id) \\\n\t((((u32)(vend_chr_0) - '@') & 0x1f) << 26 | \\\n\t (((u32)(vend_chr_1) - '@') & 0x1f) << 21 | \\\n\t (((u32)(vend_chr_2) - '@') & 0x1f) << 16 | \\\n\t ((product_id) & 0xffff))\n\n \nstatic inline void drm_edid_decode_panel_id(u32 panel_id, char vend[4], u16 *product_id)\n{\n\t*product_id = (u16)(panel_id & 0xffff);\n\tdrm_edid_decode_mfg_id(panel_id >> 16, vend);\n}\n\nbool drm_probe_ddc(struct i2c_adapter *adapter);\nstruct edid *drm_do_get_edid(struct drm_connector *connector,\n\tint (*get_edid_block)(void *data, u8 *buf, unsigned int block,\n\t\t\t      size_t len),\n\tvoid *data);\nstruct edid *drm_get_edid(struct drm_connector *connector,\n\t\t\t  struct i2c_adapter *adapter);\nu32 drm_edid_get_panel_id(struct i2c_adapter *adapter);\nstruct edid *drm_get_edid_switcheroo(struct drm_connector *connector,\n\t\t\t\t     struct i2c_adapter *adapter);\nstruct edid *drm_edid_duplicate(const struct edid *edid);\nint drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);\nint drm_edid_override_connector_update(struct drm_connector *connector);\n\nu8 drm_match_cea_mode(const struct drm_display_mode *to_match);\nbool drm_detect_hdmi_monitor(const struct edid *edid);\nbool drm_detect_monitor_audio(const struct edid *edid);\nenum hdmi_quantization_range\ndrm_default_rgb_quant_range(const struct drm_display_mode *mode);\nint drm_add_modes_noedid(struct drm_connector *connector,\n\t\t\t int hdisplay, int vdisplay);\nvoid drm_set_preferred_mode(struct drm_connector *connector,\n\t\t\t    int hpref, int vpref);\n\nint drm_edid_header_is_valid(const void *edid);\nbool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,\n\t\t\t  bool *edid_corrupt);\nbool drm_edid_is_valid(struct edid *edid);\nvoid drm_edid_get_monitor_name(const struct edid *edid, char *name,\n\t\t\t       int buflen);\nstruct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,\n\t\t\t\t\t   int hsize, int vsize, int fresh,\n\t\t\t\t\t   bool rb);\nstruct drm_display_mode *\ndrm_display_mode_from_cea_vic(struct drm_device *dev,\n\t\t\t      u8 video_code);\n\n \nconst struct drm_edid *drm_edid_alloc(const void *edid, size_t size);\nconst struct drm_edid *drm_edid_dup(const struct drm_edid *drm_edid);\nvoid drm_edid_free(const struct drm_edid *drm_edid);\nbool drm_edid_valid(const struct drm_edid *drm_edid);\nconst struct edid *drm_edid_raw(const struct drm_edid *drm_edid);\nconst struct drm_edid *drm_edid_read(struct drm_connector *connector);\nconst struct drm_edid *drm_edid_read_ddc(struct drm_connector *connector,\n\t\t\t\t\t struct i2c_adapter *adapter);\nconst struct drm_edid *drm_edid_read_custom(struct drm_connector *connector,\n\t\t\t\t\t    int (*read_block)(void *context, u8 *buf, unsigned int block, size_t len),\n\t\t\t\t\t    void *context);\nconst struct drm_edid *drm_edid_read_switcheroo(struct drm_connector *connector,\n\t\t\t\t\t\tstruct i2c_adapter *adapter);\nint drm_edid_connector_update(struct drm_connector *connector,\n\t\t\t      const struct drm_edid *edid);\nint drm_edid_connector_add_modes(struct drm_connector *connector);\n\nconst u8 *drm_find_edid_extension(const struct drm_edid *drm_edid,\n\t\t\t\t  int ext_id, int *ext_index);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}