{
  "module_name": "drm_modes.h",
  "hash_id": "ae3c5e332df9d0f548bbd783851ba314411208ad24211061bec80008cf8a1559",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_modes.h",
  "human_readable_source": " \n#ifndef __DRM_MODES_H__\n#define __DRM_MODES_H__\n\n#include <linux/hdmi.h>\n\n#include <drm/drm_mode_object.h>\n#include <drm/drm_connector.h>\n\nstruct videomode;\n\n \n\n \nenum drm_mode_status {\n\tMODE_OK = 0,\n\tMODE_HSYNC,\n\tMODE_VSYNC,\n\tMODE_H_ILLEGAL,\n\tMODE_V_ILLEGAL,\n\tMODE_BAD_WIDTH,\n\tMODE_NOMODE,\n\tMODE_NO_INTERLACE,\n\tMODE_NO_DBLESCAN,\n\tMODE_NO_VSCAN,\n\tMODE_MEM,\n\tMODE_VIRTUAL_X,\n\tMODE_VIRTUAL_Y,\n\tMODE_MEM_VIRT,\n\tMODE_NOCLOCK,\n\tMODE_CLOCK_HIGH,\n\tMODE_CLOCK_LOW,\n\tMODE_CLOCK_RANGE,\n\tMODE_BAD_HVALUE,\n\tMODE_BAD_VVALUE,\n\tMODE_BAD_VSCAN,\n\tMODE_HSYNC_NARROW,\n\tMODE_HSYNC_WIDE,\n\tMODE_HBLANK_NARROW,\n\tMODE_HBLANK_WIDE,\n\tMODE_VSYNC_NARROW,\n\tMODE_VSYNC_WIDE,\n\tMODE_VBLANK_NARROW,\n\tMODE_VBLANK_WIDE,\n\tMODE_PANEL,\n\tMODE_INTERLACE_WIDTH,\n\tMODE_ONE_WIDTH,\n\tMODE_ONE_HEIGHT,\n\tMODE_ONE_SIZE,\n\tMODE_NO_REDUCED,\n\tMODE_NO_STEREO,\n\tMODE_NO_420,\n\tMODE_STALE = -3,\n\tMODE_BAD = -2,\n\tMODE_ERROR = -1\n};\n\n#define DRM_MODE(nm, t, c, hd, hss, hse, ht, hsk, vd, vss, vse, vt, vs, f) \\\n\t.name = nm, .status = 0, .type = (t), .clock = (c), \\\n\t.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \\\n\t.htotal = (ht), .hskew = (hsk), .vdisplay = (vd), \\\n\t.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \\\n\t.vscan = (vs), .flags = (f)\n\n \n#define DRM_MODE_RES_MM(res, dpi)\t\\\n\t(((res) * 254ul) / ((dpi) * 10ul))\n\n#define __DRM_MODE_INIT(pix, hd, vd, hd_mm, vd_mm) \\\n\t.type = DRM_MODE_TYPE_DRIVER, .clock = (pix), \\\n\t.hdisplay = (hd), .hsync_start = (hd), .hsync_end = (hd), \\\n\t.htotal = (hd), .vdisplay = (vd), .vsync_start = (vd), \\\n\t.vsync_end = (vd), .vtotal = (vd), .width_mm = (hd_mm), \\\n\t.height_mm = (vd_mm)\n\n \n#define DRM_MODE_INIT(hz, hd, vd, hd_mm, vd_mm) \\\n\t__DRM_MODE_INIT((hd) * (vd) * (hz) / 1000  , hd, vd, hd_mm, vd_mm)\n\n \n#define DRM_SIMPLE_MODE(hd, vd, hd_mm, vd_mm) \\\n\t__DRM_MODE_INIT(1  , hd, vd, hd_mm, vd_mm)\n\n#define CRTC_INTERLACE_HALVE_V\t(1 << 0)  \n#define CRTC_STEREO_DOUBLE\t(1 << 1)  \n#define CRTC_NO_DBLSCAN\t\t(1 << 2)  \n#define CRTC_NO_VSCAN\t\t(1 << 3)  \n#define CRTC_STEREO_DOUBLE_ONLY\t(CRTC_STEREO_DOUBLE | CRTC_NO_DBLSCAN | CRTC_NO_VSCAN)\n\n#define DRM_MODE_FLAG_3D_MAX\tDRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF\n\n#define DRM_MODE_MATCH_TIMINGS (1 << 0)\n#define DRM_MODE_MATCH_CLOCK (1 << 1)\n#define DRM_MODE_MATCH_FLAGS (1 << 2)\n#define DRM_MODE_MATCH_3D_FLAGS (1 << 3)\n#define DRM_MODE_MATCH_ASPECT_RATIO (1 << 4)\n\n \nstruct drm_display_mode {\n\t \n\tint clock;\t\t \n\tu16 hdisplay;\n\tu16 hsync_start;\n\tu16 hsync_end;\n\tu16 htotal;\n\tu16 hskew;\n\tu16 vdisplay;\n\tu16 vsync_start;\n\tu16 vsync_end;\n\tu16 vtotal;\n\tu16 vscan;\n\t \n\tu32 flags;\n\n\t \n\tint crtc_clock;\n\tu16 crtc_hdisplay;\n\tu16 crtc_hblank_start;\n\tu16 crtc_hblank_end;\n\tu16 crtc_hsync_start;\n\tu16 crtc_hsync_end;\n\tu16 crtc_htotal;\n\tu16 crtc_hskew;\n\tu16 crtc_vdisplay;\n\tu16 crtc_vblank_start;\n\tu16 crtc_vblank_end;\n\tu16 crtc_vsync_start;\n\tu16 crtc_vsync_end;\n\tu16 crtc_vtotal;\n\n\t \n\tu16 width_mm;\n\n\t \n\tu16 height_mm;\n\n\t \n\tu8 type;\n\n\t \n\tbool expose_to_userspace;\n\n\t \n\tstruct list_head head;\n\n\t \n\tchar name[DRM_DISPLAY_MODE_LEN];\n\n\t \n\tenum drm_mode_status status;\n\n\t \n\tenum hdmi_picture_aspect picture_aspect_ratio;\n\n};\n\n \n#define DRM_MODE_FMT    \"\\\"%s\\\": %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x\"\n\n \n#define DRM_MODE_ARG(m) \\\n\t(m)->name, drm_mode_vrefresh(m), (m)->clock, \\\n\t(m)->hdisplay, (m)->hsync_start, (m)->hsync_end, (m)->htotal, \\\n\t(m)->vdisplay, (m)->vsync_start, (m)->vsync_end, (m)->vtotal, \\\n\t(m)->type, (m)->flags\n\n#define obj_to_mode(x) container_of(x, struct drm_display_mode, base)\n\n \nstatic inline bool drm_mode_is_stereo(const struct drm_display_mode *mode)\n{\n\treturn mode->flags & DRM_MODE_FLAG_3D_MASK;\n}\n\nstruct drm_connector;\nstruct drm_cmdline_mode;\n\nstruct drm_display_mode *drm_mode_create(struct drm_device *dev);\nvoid drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);\nvoid drm_mode_convert_to_umode(struct drm_mode_modeinfo *out,\n\t\t\t       const struct drm_display_mode *in);\nint drm_mode_convert_umode(struct drm_device *dev,\n\t\t\t   struct drm_display_mode *out,\n\t\t\t   const struct drm_mode_modeinfo *in);\nvoid drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);\nvoid drm_mode_debug_printmodeline(const struct drm_display_mode *mode);\nbool drm_mode_is_420_only(const struct drm_display_info *display,\n\t\t\t  const struct drm_display_mode *mode);\nbool drm_mode_is_420_also(const struct drm_display_info *display,\n\t\t\t  const struct drm_display_mode *mode);\nbool drm_mode_is_420(const struct drm_display_info *display,\n\t\t     const struct drm_display_mode *mode);\n\nstruct drm_display_mode *drm_analog_tv_mode(struct drm_device *dev,\n\t\t\t\t\t    enum drm_connector_tv_mode mode,\n\t\t\t\t\t    unsigned long pixel_clock_hz,\n\t\t\t\t\t    unsigned int hdisplay,\n\t\t\t\t\t    unsigned int vdisplay,\n\t\t\t\t\t    bool interlace);\n\nstatic inline struct drm_display_mode *drm_mode_analog_ntsc_480i(struct drm_device *dev)\n{\n\treturn drm_analog_tv_mode(dev, DRM_MODE_TV_MODE_NTSC, 13500000, 720, 480, true);\n}\n\nstatic inline struct drm_display_mode *drm_mode_analog_pal_576i(struct drm_device *dev)\n{\n\treturn drm_analog_tv_mode(dev, DRM_MODE_TV_MODE_PAL, 13500000, 720, 576, true);\n}\n\nstruct drm_display_mode *drm_cvt_mode(struct drm_device *dev,\n\t\t\t\t      int hdisplay, int vdisplay, int vrefresh,\n\t\t\t\t      bool reduced, bool interlaced,\n\t\t\t\t      bool margins);\nstruct drm_display_mode *drm_gtf_mode(struct drm_device *dev,\n\t\t\t\t      int hdisplay, int vdisplay, int vrefresh,\n\t\t\t\t      bool interlaced, int margins);\nstruct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,\n\t\t\t\t\t      int hdisplay, int vdisplay,\n\t\t\t\t\t      int vrefresh, bool interlaced,\n\t\t\t\t\t      int margins,\n\t\t\t\t\t      int GTF_M, int GTF_2C,\n\t\t\t\t\t      int GTF_K, int GTF_2J);\nvoid drm_display_mode_from_videomode(const struct videomode *vm,\n\t\t\t\t     struct drm_display_mode *dmode);\nvoid drm_display_mode_to_videomode(const struct drm_display_mode *dmode,\n\t\t\t\t   struct videomode *vm);\nvoid drm_bus_flags_from_videomode(const struct videomode *vm, u32 *bus_flags);\n\n#if defined(CONFIG_OF)\nint of_get_drm_display_mode(struct device_node *np,\n\t\t\t    struct drm_display_mode *dmode, u32 *bus_flags,\n\t\t\t    int index);\nint of_get_drm_panel_display_mode(struct device_node *np,\n\t\t\t\t  struct drm_display_mode *dmode, u32 *bus_flags);\n#else\nstatic inline int of_get_drm_display_mode(struct device_node *np,\n\t\t\t\t\t  struct drm_display_mode *dmode,\n\t\t\t\t\t  u32 *bus_flags, int index)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int of_get_drm_panel_display_mode(struct device_node *np,\n\t\t\t\t\t\tstruct drm_display_mode *dmode, u32 *bus_flags)\n{\n\treturn -EINVAL;\n}\n#endif\n\nvoid drm_mode_set_name(struct drm_display_mode *mode);\nint drm_mode_vrefresh(const struct drm_display_mode *mode);\nvoid drm_mode_get_hv_timing(const struct drm_display_mode *mode,\n\t\t\t    int *hdisplay, int *vdisplay);\n\nvoid drm_mode_set_crtcinfo(struct drm_display_mode *p,\n\t\t\t   int adjust_flags);\nvoid drm_mode_copy(struct drm_display_mode *dst,\n\t\t   const struct drm_display_mode *src);\nvoid drm_mode_init(struct drm_display_mode *dst,\n\t\t   const struct drm_display_mode *src);\nstruct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,\n\t\t\t\t\t    const struct drm_display_mode *mode);\nbool drm_mode_match(const struct drm_display_mode *mode1,\n\t\t    const struct drm_display_mode *mode2,\n\t\t    unsigned int match_flags);\nbool drm_mode_equal(const struct drm_display_mode *mode1,\n\t\t    const struct drm_display_mode *mode2);\nbool drm_mode_equal_no_clocks(const struct drm_display_mode *mode1,\n\t\t\t      const struct drm_display_mode *mode2);\nbool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,\n\t\t\t\t\tconst struct drm_display_mode *mode2);\n\n \nenum drm_mode_status drm_mode_validate_driver(struct drm_device *dev,\n\t\t\t\t\t      const struct drm_display_mode *mode);\nenum drm_mode_status drm_mode_validate_size(const struct drm_display_mode *mode,\n\t\t\t\t\t    int maxX, int maxY);\nenum drm_mode_status\ndrm_mode_validate_ycbcr420(const struct drm_display_mode *mode,\n\t\t\t   struct drm_connector *connector);\nvoid drm_mode_prune_invalid(struct drm_device *dev,\n\t\t\t    struct list_head *mode_list, bool verbose);\nvoid drm_mode_sort(struct list_head *mode_list);\nvoid drm_connector_list_update(struct drm_connector *connector);\n\n \nbool\ndrm_mode_parse_command_line_for_connector(const char *mode_option,\n\t\t\t\t\t  const struct drm_connector *connector,\n\t\t\t\t\t  struct drm_cmdline_mode *mode);\nstruct drm_display_mode *\ndrm_mode_create_from_cmdline_mode(struct drm_device *dev,\n\t\t\t\t  struct drm_cmdline_mode *cmd);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}