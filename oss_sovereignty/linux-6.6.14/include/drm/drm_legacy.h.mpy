{
  "module_name": "drm_legacy.h",
  "hash_id": "0afece03fb3f5b6de84aa6c8835334ad50359a74e1be61422681a66a14649491",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_legacy.h",
  "human_readable_source": "#ifndef __DRM_DRM_LEGACY_H__\n#define __DRM_DRM_LEGACY_H__\n \n\n#include <linux/agp_backend.h>\n\n#include <drm/drm.h>\n#include <drm/drm_auth.h>\n\nstruct drm_device;\nstruct drm_driver;\nstruct file;\nstruct pci_driver;\n\n \n\n \n\nstruct drm_hash_item {\n\tstruct hlist_node head;\n\tunsigned long key;\n};\n\nstruct drm_open_hash {\n\tstruct hlist_head *table;\n\tu8 order;\n};\n\n \nstruct drm_buf {\n\tint idx;\t\t        \n\tint total;\t\t        \n\tint order;\t\t        \n\tint used;\t\t        \n\tunsigned long offset;\t        \n\tvoid *address;\t\t        \n\tunsigned long bus_address;      \n\tstruct drm_buf *next;\t        \n\t__volatile__ int waiting;       \n\t__volatile__ int pending;       \n\tstruct drm_file *file_priv;     \n\tint context;\t\t        \n\tint while_locked;\t        \n\tenum {\n\t\tDRM_LIST_NONE = 0,\n\t\tDRM_LIST_FREE = 1,\n\t\tDRM_LIST_WAIT = 2,\n\t\tDRM_LIST_PEND = 3,\n\t\tDRM_LIST_PRIO = 4,\n\t\tDRM_LIST_RECLAIM = 5\n\t} list;\t\t\t        \n\n\tint dev_priv_size;\t\t  \n\tvoid *dev_private;\t\t  \n};\n\ntypedef struct drm_dma_handle {\n\tdma_addr_t busaddr;\n\tvoid *vaddr;\n\tsize_t size;\n} drm_dma_handle_t;\n\n \nstruct drm_buf_entry {\n\tint buf_size;\t\t\t \n\tint buf_count;\t\t\t \n\tstruct drm_buf *buflist;\t\t \n\tint seg_count;\n\tint page_order;\n\tstruct drm_dma_handle **seglist;\n\n\tint low_mark;\t\t\t \n\tint high_mark;\t\t\t \n};\n\n \nstruct drm_device_dma {\n\n\tstruct drm_buf_entry bufs[DRM_MAX_ORDER + 1];\t \n\tint buf_count;\t\t\t \n\tstruct drm_buf **buflist;\t\t \n\tint seg_count;\n\tint page_count;\t\t\t \n\tunsigned long *pagelist;\t \n\tunsigned long byte_count;\n\tenum {\n\t\t_DRM_DMA_USE_AGP = 0x01,\n\t\t_DRM_DMA_USE_SG = 0x02,\n\t\t_DRM_DMA_USE_FB = 0x04,\n\t\t_DRM_DMA_USE_PCI_RO = 0x08\n\t} flags;\n\n};\n\n \nstruct drm_sg_mem {\n\tunsigned long handle;\n\tvoid *virtual;\n\tint pages;\n\tstruct page **pagelist;\n\tdma_addr_t *busaddr;\n};\n\n \nstruct drm_local_map {\n\tdma_addr_t offset;\t  \n\tunsigned long size;\t  \n\tenum drm_map_type type;\t  \n\tenum drm_map_flags flags;\t  \n\tvoid *handle;\t\t  \n\t\t\t\t  \n\tint mtrr;\t\t  \n};\n\ntypedef struct drm_local_map drm_local_map_t;\n\n \nstruct drm_map_list {\n\tstruct list_head head;\t\t \n\tstruct drm_hash_item hash;\n\tstruct drm_local_map *map;\t \n\tuint64_t user_token;\n\tstruct drm_master *master;\n};\n\nint drm_legacy_addmap(struct drm_device *d, resource_size_t offset,\n\t\t      unsigned int size, enum drm_map_type type,\n\t\t      enum drm_map_flags flags, struct drm_local_map **map_p);\nstruct drm_local_map *drm_legacy_findmap(struct drm_device *dev, unsigned int token);\nvoid drm_legacy_rmmap(struct drm_device *d, struct drm_local_map *map);\nint drm_legacy_rmmap_locked(struct drm_device *d, struct drm_local_map *map);\nstruct drm_local_map *drm_legacy_getsarea(struct drm_device *dev);\nint drm_legacy_mmap(struct file *filp, struct vm_area_struct *vma);\n\nint drm_legacy_addbufs_agp(struct drm_device *d, struct drm_buf_desc *req);\nint drm_legacy_addbufs_pci(struct drm_device *d, struct drm_buf_desc *req);\n\n \n#define LOCK_TEST_WITH_RETURN( dev, _file_priv )\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (!_DRM_LOCK_IS_HELD(_file_priv->master->lock.hw_lock->lock) ||\t\\\n\t    _file_priv->master->lock.file_priv != _file_priv)\t{\t\t\\\n\t\tDRM_ERROR( \"%s called without lock held, held  %d owner %p %p\\n\",\\\n\t\t\t   __func__, _DRM_LOCK_IS_HELD(_file_priv->master->lock.hw_lock->lock),\\\n\t\t\t   _file_priv->master->lock.file_priv, _file_priv);\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\nvoid drm_legacy_idlelock_take(struct drm_lock_data *lock);\nvoid drm_legacy_idlelock_release(struct drm_lock_data *lock);\n\n \nint drm_legacy_irq_uninstall(struct drm_device *dev);\n\n \n\n#ifdef CONFIG_PCI\n\nint drm_legacy_pci_init(const struct drm_driver *driver,\n\t\t\tstruct pci_driver *pdriver);\nvoid drm_legacy_pci_exit(const struct drm_driver *driver,\n\t\t\t struct pci_driver *pdriver);\n\n#else\n\nstatic inline struct drm_dma_handle *drm_pci_alloc(struct drm_device *dev,\n\t\t\t\t\t\t   size_t size, size_t align)\n{\n\treturn NULL;\n}\n\nstatic inline void drm_pci_free(struct drm_device *dev,\n\t\t\t\tstruct drm_dma_handle *dmah)\n{\n}\n\nstatic inline int drm_legacy_pci_init(const struct drm_driver *driver,\n\t\t\t\t      struct pci_driver *pdriver)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void drm_legacy_pci_exit(const struct drm_driver *driver,\n\t\t\t\t       struct pci_driver *pdriver)\n{\n}\n\n#endif\n\n \n\nstruct drm_agp_head {\n\tstruct agp_kern_info agp_info;\n\tstruct list_head memory;\n\tunsigned long mode;\n\tstruct agp_bridge_data *bridge;\n\tint enabled;\n\tint acquired;\n\tunsigned long base;\n\tint agp_mtrr;\n\tint cant_use_aperture;\n\tunsigned long page_mask;\n};\n\n#if IS_ENABLED(CONFIG_DRM_LEGACY) && IS_ENABLED(CONFIG_AGP)\nstruct drm_agp_head *drm_legacy_agp_init(struct drm_device *dev);\nint drm_legacy_agp_acquire(struct drm_device *dev);\nint drm_legacy_agp_release(struct drm_device *dev);\nint drm_legacy_agp_enable(struct drm_device *dev, struct drm_agp_mode mode);\nint drm_legacy_agp_info(struct drm_device *dev, struct drm_agp_info *info);\nint drm_legacy_agp_alloc(struct drm_device *dev, struct drm_agp_buffer *request);\nint drm_legacy_agp_free(struct drm_device *dev, struct drm_agp_buffer *request);\nint drm_legacy_agp_unbind(struct drm_device *dev, struct drm_agp_binding *request);\nint drm_legacy_agp_bind(struct drm_device *dev, struct drm_agp_binding *request);\n#else\nstatic inline struct drm_agp_head *drm_legacy_agp_init(struct drm_device *dev)\n{\n\treturn NULL;\n}\n\nstatic inline int drm_legacy_agp_acquire(struct drm_device *dev)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int drm_legacy_agp_release(struct drm_device *dev)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int drm_legacy_agp_enable(struct drm_device *dev,\n\t\t\t\t\tstruct drm_agp_mode mode)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int drm_legacy_agp_info(struct drm_device *dev,\n\t\t\t\t      struct drm_agp_info *info)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int drm_legacy_agp_alloc(struct drm_device *dev,\n\t\t\t\t       struct drm_agp_buffer *request)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int drm_legacy_agp_free(struct drm_device *dev,\n\t\t\t\t      struct drm_agp_buffer *request)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int drm_legacy_agp_unbind(struct drm_device *dev,\n\t\t\t\t\tstruct drm_agp_binding *request)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int drm_legacy_agp_bind(struct drm_device *dev,\n\t\t\t\t      struct drm_agp_binding *request)\n{\n\treturn -ENODEV;\n}\n#endif\n\n \nvoid drm_legacy_ioremap(struct drm_local_map *map, struct drm_device *dev);\nvoid drm_legacy_ioremap_wc(struct drm_local_map *map, struct drm_device *dev);\nvoid drm_legacy_ioremapfree(struct drm_local_map *map, struct drm_device *dev);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}