{
  "module_name": "drm_dp_helper.h",
  "hash_id": "5d167c64952b5b98bacfbffe61333c7703cea524a7d4421d182d18a76cc03e24",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/display/drm_dp_helper.h",
  "human_readable_source": " \n\n#ifndef _DRM_DP_HELPER_H_\n#define _DRM_DP_HELPER_H_\n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n\n#include <drm/display/drm_dp.h>\n#include <drm/drm_connector.h>\n\nstruct drm_device;\nstruct drm_dp_aux;\nstruct drm_panel;\n\nbool drm_dp_channel_eq_ok(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t  int lane_count);\nbool drm_dp_clock_recovery_ok(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t      int lane_count);\nu8 drm_dp_get_adjust_request_voltage(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t     int lane);\nu8 drm_dp_get_adjust_request_pre_emphasis(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t  int lane);\nu8 drm_dp_get_adjust_tx_ffe_preset(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t   int lane);\n\nint drm_dp_read_clock_recovery_delay(struct drm_dp_aux *aux, const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t     enum drm_dp_phy dp_phy, bool uhbr);\nint drm_dp_read_channel_eq_delay(struct drm_dp_aux *aux, const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t enum drm_dp_phy dp_phy, bool uhbr);\n\nvoid drm_dp_link_train_clock_recovery_delay(const struct drm_dp_aux *aux,\n\t\t\t\t\t    const u8 dpcd[DP_RECEIVER_CAP_SIZE]);\nvoid drm_dp_lttpr_link_train_clock_recovery_delay(void);\nvoid drm_dp_link_train_channel_eq_delay(const struct drm_dp_aux *aux,\n\t\t\t\t\tconst u8 dpcd[DP_RECEIVER_CAP_SIZE]);\nvoid drm_dp_lttpr_link_train_channel_eq_delay(const struct drm_dp_aux *aux,\n\t\t\t\t\t      const u8 caps[DP_LTTPR_PHY_CAP_SIZE]);\n\nint drm_dp_128b132b_read_aux_rd_interval(struct drm_dp_aux *aux);\nbool drm_dp_128b132b_lane_channel_eq_done(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t  int lane_count);\nbool drm_dp_128b132b_lane_symbol_locked(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\tint lane_count);\nbool drm_dp_128b132b_eq_interlane_align_done(const u8 link_status[DP_LINK_STATUS_SIZE]);\nbool drm_dp_128b132b_cds_interlane_align_done(const u8 link_status[DP_LINK_STATUS_SIZE]);\nbool drm_dp_128b132b_link_training_failed(const u8 link_status[DP_LINK_STATUS_SIZE]);\n\nu8 drm_dp_link_rate_to_bw_code(int link_rate);\nint drm_dp_bw_code_to_link_rate(u8 link_bw);\n\nconst char *drm_dp_phy_name(enum drm_dp_phy dp_phy);\n\n \nstruct drm_dp_vsc_sdp {\n\tunsigned char sdp_type;\n\tunsigned char revision;\n\tunsigned char length;\n\tenum dp_pixelformat pixelformat;\n\tenum dp_colorimetry colorimetry;\n\tint bpc;\n\tenum dp_dynamic_range dynamic_range;\n\tenum dp_content_type content_type;\n};\n\nvoid drm_dp_vsc_sdp_log(const char *level, struct device *dev,\n\t\t\tconst struct drm_dp_vsc_sdp *vsc);\n\nint drm_dp_psr_setup_time(const u8 psr_cap[EDP_PSR_RECEIVER_CAP_SIZE]);\n\nstatic inline int\ndrm_dp_max_link_rate(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn drm_dp_bw_code_to_link_rate(dpcd[DP_MAX_LINK_RATE]);\n}\n\nstatic inline u8\ndrm_dp_max_lane_count(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn dpcd[DP_MAX_LANE_COUNT] & DP_MAX_LANE_COUNT_MASK;\n}\n\nstatic inline bool\ndrm_dp_enhanced_frame_cap(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn dpcd[DP_DPCD_REV] >= 0x11 &&\n\t\t(dpcd[DP_MAX_LANE_COUNT] & DP_ENHANCED_FRAME_CAP);\n}\n\nstatic inline bool\ndrm_dp_fast_training_cap(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn dpcd[DP_DPCD_REV] >= 0x11 &&\n\t\t(dpcd[DP_MAX_DOWNSPREAD] & DP_NO_AUX_HANDSHAKE_LINK_TRAINING);\n}\n\nstatic inline bool\ndrm_dp_tps3_supported(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn dpcd[DP_DPCD_REV] >= 0x12 &&\n\t\tdpcd[DP_MAX_LANE_COUNT] & DP_TPS3_SUPPORTED;\n}\n\nstatic inline bool\ndrm_dp_max_downspread(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn dpcd[DP_DPCD_REV] >= 0x11 ||\n\t\tdpcd[DP_MAX_DOWNSPREAD] & DP_MAX_DOWNSPREAD_0_5;\n}\n\nstatic inline bool\ndrm_dp_tps4_supported(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn dpcd[DP_DPCD_REV] >= 0x14 &&\n\t\tdpcd[DP_MAX_DOWNSPREAD] & DP_TPS4_SUPPORTED;\n}\n\nstatic inline u8\ndrm_dp_training_pattern_mask(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn (dpcd[DP_DPCD_REV] >= 0x14) ? DP_TRAINING_PATTERN_MASK_1_4 :\n\t\tDP_TRAINING_PATTERN_MASK;\n}\n\nstatic inline bool\ndrm_dp_is_branch(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DWN_STRM_PORT_PRESENT;\n}\n\n \nu8 drm_dp_dsc_sink_max_slice_count(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE],\n\t\t\t\t   bool is_edp);\nu8 drm_dp_dsc_sink_line_buf_depth(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE]);\nint drm_dp_dsc_sink_supported_input_bpcs(const u8 dsc_dpc[DP_DSC_RECEIVER_CAP_SIZE],\n\t\t\t\t\t u8 dsc_bpc[3]);\n\nstatic inline bool\ndrm_dp_sink_supports_dsc(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE])\n{\n\treturn dsc_dpcd[DP_DSC_SUPPORT - DP_DSC_SUPPORT] &\n\t\tDP_DSC_DECOMPRESSION_IS_SUPPORTED;\n}\n\nstatic inline u16\ndrm_edp_dsc_sink_output_bpp(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE])\n{\n\treturn dsc_dpcd[DP_DSC_MAX_BITS_PER_PIXEL_LOW - DP_DSC_SUPPORT] |\n\t\t((dsc_dpcd[DP_DSC_MAX_BITS_PER_PIXEL_HI - DP_DSC_SUPPORT] &\n\t\t  DP_DSC_MAX_BITS_PER_PIXEL_HI_MASK) << 8);\n}\n\nstatic inline u32\ndrm_dp_dsc_sink_max_slice_width(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE])\n{\n\t \n\treturn dsc_dpcd[DP_DSC_MAX_SLICE_WIDTH - DP_DSC_SUPPORT] *\n\t\tDP_DSC_SLICE_WIDTH_MULTIPLIER;\n}\n\n \nstatic inline bool\ndrm_dp_dsc_sink_supports_format(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE], u8 output_format)\n{\n\treturn dsc_dpcd[DP_DSC_DEC_COLOR_FORMAT_CAP - DP_DSC_SUPPORT] & output_format;\n}\n\n \nstatic inline bool\ndrm_dp_sink_supports_fec(const u8 fec_capable)\n{\n\treturn fec_capable & DP_FEC_CAPABLE;\n}\n\nstatic inline bool\ndrm_dp_channel_coding_supported(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn dpcd[DP_MAIN_LINK_CHANNEL_CODING] & DP_CAP_ANSI_8B10B;\n}\n\nstatic inline bool\ndrm_dp_alternate_scrambler_reset_cap(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn dpcd[DP_EDP_CONFIGURATION_CAP] &\n\t\t\tDP_ALTERNATE_SCRAMBLER_RESET_CAP;\n}\n\n \nstatic inline bool\ndrm_dp_sink_can_do_video_without_timing_msa(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\treturn dpcd[DP_DOWN_STREAM_PORT_COUNT] &\n\t\tDP_MSA_TIMING_PAR_IGNORED;\n}\n\n \nstatic inline bool\ndrm_edp_backlight_supported(const u8 edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE])\n{\n\treturn !!(edp_dpcd[1] & DP_EDP_TCON_BACKLIGHT_ADJUSTMENT_CAP);\n}\n\n \n\n \nstruct drm_dp_aux_msg {\n\tunsigned int address;\n\tu8 request;\n\tu8 reply;\n\tvoid *buffer;\n\tsize_t size;\n};\n\nstruct cec_adapter;\nstruct edid;\nstruct drm_connector;\n\n \nstruct drm_dp_aux_cec {\n\tstruct mutex lock;\n\tstruct cec_adapter *adap;\n\tstruct drm_connector *connector;\n\tstruct delayed_work unregister_work;\n};\n\n \nstruct drm_dp_aux {\n\t \n\tconst char *name;\n\n\t \n\tstruct i2c_adapter ddc;\n\n\t \n\tstruct device *dev;\n\n\t \n\tstruct drm_device *drm_dev;\n\n\t \n\tstruct drm_crtc *crtc;\n\n\t \n\tstruct mutex hw_mutex;\n\n\t \n\tstruct work_struct crc_work;\n\n\t \n\tu8 crc_count;\n\n\t \n\tssize_t (*transfer)(struct drm_dp_aux *aux,\n\t\t\t    struct drm_dp_aux_msg *msg);\n\n\t \n\tint (*wait_hpd_asserted)(struct drm_dp_aux *aux, unsigned long wait_us);\n\n\t \n\tunsigned i2c_nack_count;\n\t \n\tunsigned i2c_defer_count;\n\t \n\tstruct drm_dp_aux_cec cec;\n\t \n\tbool is_remote;\n};\n\nint drm_dp_dpcd_probe(struct drm_dp_aux *aux, unsigned int offset);\nssize_t drm_dp_dpcd_read(struct drm_dp_aux *aux, unsigned int offset,\n\t\t\t void *buffer, size_t size);\nssize_t drm_dp_dpcd_write(struct drm_dp_aux *aux, unsigned int offset,\n\t\t\t  void *buffer, size_t size);\n\n \nstatic inline ssize_t drm_dp_dpcd_readb(struct drm_dp_aux *aux,\n\t\t\t\t\tunsigned int offset, u8 *valuep)\n{\n\treturn drm_dp_dpcd_read(aux, offset, valuep, 1);\n}\n\n \nstatic inline ssize_t drm_dp_dpcd_writeb(struct drm_dp_aux *aux,\n\t\t\t\t\t unsigned int offset, u8 value)\n{\n\treturn drm_dp_dpcd_write(aux, offset, &value, 1);\n}\n\nint drm_dp_read_dpcd_caps(struct drm_dp_aux *aux,\n\t\t\t  u8 dpcd[DP_RECEIVER_CAP_SIZE]);\n\nint drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,\n\t\t\t\t u8 status[DP_LINK_STATUS_SIZE]);\n\nint drm_dp_dpcd_read_phy_link_status(struct drm_dp_aux *aux,\n\t\t\t\t     enum drm_dp_phy dp_phy,\n\t\t\t\t     u8 link_status[DP_LINK_STATUS_SIZE]);\n\nbool drm_dp_send_real_edid_checksum(struct drm_dp_aux *aux,\n\t\t\t\t    u8 real_edid_checksum);\n\nint drm_dp_read_downstream_info(struct drm_dp_aux *aux,\n\t\t\t\tconst u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\tu8 downstream_ports[DP_MAX_DOWNSTREAM_PORTS]);\nbool drm_dp_downstream_is_type(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t       const u8 port_cap[4], u8 type);\nbool drm_dp_downstream_is_tmds(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t       const u8 port_cap[4],\n\t\t\t       const struct edid *edid);\nint drm_dp_downstream_max_dotclock(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t   const u8 port_cap[4]);\nint drm_dp_downstream_max_tmds_clock(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t     const u8 port_cap[4],\n\t\t\t\t     const struct edid *edid);\nint drm_dp_downstream_min_tmds_clock(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t     const u8 port_cap[4],\n\t\t\t\t     const struct edid *edid);\nint drm_dp_downstream_max_bpc(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t      const u8 port_cap[4],\n\t\t\t      const struct edid *edid);\nbool drm_dp_downstream_420_passthrough(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t       const u8 port_cap[4]);\nbool drm_dp_downstream_444_to_420_conversion(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t\t     const u8 port_cap[4]);\nstruct drm_display_mode *drm_dp_downstream_mode(struct drm_device *dev,\n\t\t\t\t\t\tconst u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t\t\tconst u8 port_cap[4]);\nint drm_dp_downstream_id(struct drm_dp_aux *aux, char id[6]);\nvoid drm_dp_downstream_debug(struct seq_file *m,\n\t\t\t     const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t     const u8 port_cap[4],\n\t\t\t     const struct edid *edid,\n\t\t\t     struct drm_dp_aux *aux);\nenum drm_mode_subconnector\ndrm_dp_subconnector_type(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t const u8 port_cap[4]);\nvoid drm_dp_set_subconnector_property(struct drm_connector *connector,\n\t\t\t\t      enum drm_connector_status status,\n\t\t\t\t      const u8 *dpcd,\n\t\t\t\t      const u8 port_cap[4]);\n\nstruct drm_dp_desc;\nbool drm_dp_read_sink_count_cap(struct drm_connector *connector,\n\t\t\t\tconst u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\tconst struct drm_dp_desc *desc);\nint drm_dp_read_sink_count(struct drm_dp_aux *aux);\n\nint drm_dp_read_lttpr_common_caps(struct drm_dp_aux *aux,\n\t\t\t\t  const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t  u8 caps[DP_LTTPR_COMMON_CAP_SIZE]);\nint drm_dp_read_lttpr_phy_caps(struct drm_dp_aux *aux,\n\t\t\t       const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t       enum drm_dp_phy dp_phy,\n\t\t\t       u8 caps[DP_LTTPR_PHY_CAP_SIZE]);\nint drm_dp_lttpr_count(const u8 cap[DP_LTTPR_COMMON_CAP_SIZE]);\nint drm_dp_lttpr_max_link_rate(const u8 caps[DP_LTTPR_COMMON_CAP_SIZE]);\nint drm_dp_lttpr_max_lane_count(const u8 caps[DP_LTTPR_COMMON_CAP_SIZE]);\nbool drm_dp_lttpr_voltage_swing_level_3_supported(const u8 caps[DP_LTTPR_PHY_CAP_SIZE]);\nbool drm_dp_lttpr_pre_emphasis_level_3_supported(const u8 caps[DP_LTTPR_PHY_CAP_SIZE]);\n\nvoid drm_dp_remote_aux_init(struct drm_dp_aux *aux);\nvoid drm_dp_aux_init(struct drm_dp_aux *aux);\nint drm_dp_aux_register(struct drm_dp_aux *aux);\nvoid drm_dp_aux_unregister(struct drm_dp_aux *aux);\n\nint drm_dp_start_crc(struct drm_dp_aux *aux, struct drm_crtc *crtc);\nint drm_dp_stop_crc(struct drm_dp_aux *aux);\n\nstruct drm_dp_dpcd_ident {\n\tu8 oui[3];\n\tu8 device_id[6];\n\tu8 hw_rev;\n\tu8 sw_major_rev;\n\tu8 sw_minor_rev;\n} __packed;\n\n \nstruct drm_dp_desc {\n\tstruct drm_dp_dpcd_ident ident;\n\tu32 quirks;\n};\n\nint drm_dp_read_desc(struct drm_dp_aux *aux, struct drm_dp_desc *desc,\n\t\t     bool is_branch);\n\n \nenum drm_dp_quirk {\n\t \n\tDP_DPCD_QUIRK_CONSTANT_N,\n\t \n\tDP_DPCD_QUIRK_NO_PSR,\n\t \n\tDP_DPCD_QUIRK_NO_SINK_COUNT,\n\t \n\tDP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD,\n\t \n\tDP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS,\n};\n\n \nstatic inline bool\ndrm_dp_has_quirk(const struct drm_dp_desc *desc, enum drm_dp_quirk quirk)\n{\n\treturn desc->quirks & BIT(quirk);\n}\n\n \nstruct drm_edp_backlight_info {\n\tu8 pwmgen_bit_count;\n\tu8 pwm_freq_pre_divider;\n\tu16 max;\n\n\tbool lsb_reg_used : 1;\n\tbool aux_enable : 1;\n\tbool aux_set : 1;\n};\n\nint\ndrm_edp_backlight_init(struct drm_dp_aux *aux, struct drm_edp_backlight_info *bl,\n\t\t       u16 driver_pwm_freq_hz, const u8 edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE],\n\t\t       u16 *current_level, u8 *current_mode);\nint drm_edp_backlight_set_level(struct drm_dp_aux *aux, const struct drm_edp_backlight_info *bl,\n\t\t\t\tu16 level);\nint drm_edp_backlight_enable(struct drm_dp_aux *aux, const struct drm_edp_backlight_info *bl,\n\t\t\t     u16 level);\nint drm_edp_backlight_disable(struct drm_dp_aux *aux, const struct drm_edp_backlight_info *bl);\n\n#if IS_ENABLED(CONFIG_DRM_KMS_HELPER) && (IS_BUILTIN(CONFIG_BACKLIGHT_CLASS_DEVICE) || \\\n\t(IS_MODULE(CONFIG_DRM_KMS_HELPER) && IS_MODULE(CONFIG_BACKLIGHT_CLASS_DEVICE)))\n\nint drm_panel_dp_aux_backlight(struct drm_panel *panel, struct drm_dp_aux *aux);\n\n#else\n\nstatic inline int drm_panel_dp_aux_backlight(struct drm_panel *panel,\n\t\t\t\t\t     struct drm_dp_aux *aux)\n{\n\treturn 0;\n}\n\n#endif\n\n#ifdef CONFIG_DRM_DP_CEC\nvoid drm_dp_cec_irq(struct drm_dp_aux *aux);\nvoid drm_dp_cec_register_connector(struct drm_dp_aux *aux,\n\t\t\t\t   struct drm_connector *connector);\nvoid drm_dp_cec_unregister_connector(struct drm_dp_aux *aux);\nvoid drm_dp_cec_set_edid(struct drm_dp_aux *aux, const struct edid *edid);\nvoid drm_dp_cec_unset_edid(struct drm_dp_aux *aux);\n#else\nstatic inline void drm_dp_cec_irq(struct drm_dp_aux *aux)\n{\n}\n\nstatic inline void\ndrm_dp_cec_register_connector(struct drm_dp_aux *aux,\n\t\t\t      struct drm_connector *connector)\n{\n}\n\nstatic inline void drm_dp_cec_unregister_connector(struct drm_dp_aux *aux)\n{\n}\n\nstatic inline void drm_dp_cec_set_edid(struct drm_dp_aux *aux,\n\t\t\t\t       const struct edid *edid)\n{\n}\n\nstatic inline void drm_dp_cec_unset_edid(struct drm_dp_aux *aux)\n{\n}\n\n#endif\n\n \nstruct drm_dp_phy_test_params {\n\tint link_rate;\n\tu8 num_lanes;\n\tu8 phy_pattern;\n\tu8 hbr2_reset[2];\n\tu8 custom80[10];\n\tbool enhanced_frame_cap;\n};\n\nint drm_dp_get_phy_test_pattern(struct drm_dp_aux *aux,\n\t\t\t\tstruct drm_dp_phy_test_params *data);\nint drm_dp_set_phy_test_pattern(struct drm_dp_aux *aux,\n\t\t\t\tstruct drm_dp_phy_test_params *data, u8 dp_rev);\nint drm_dp_get_pcon_max_frl_bw(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t       const u8 port_cap[4]);\nint drm_dp_pcon_frl_prepare(struct drm_dp_aux *aux, bool enable_frl_ready_hpd);\nbool drm_dp_pcon_is_frl_ready(struct drm_dp_aux *aux);\nint drm_dp_pcon_frl_configure_1(struct drm_dp_aux *aux, int max_frl_gbps,\n\t\t\t\tu8 frl_mode);\nint drm_dp_pcon_frl_configure_2(struct drm_dp_aux *aux, int max_frl_mask,\n\t\t\t\tu8 frl_type);\nint drm_dp_pcon_reset_frl_config(struct drm_dp_aux *aux);\nint drm_dp_pcon_frl_enable(struct drm_dp_aux *aux);\n\nbool drm_dp_pcon_hdmi_link_active(struct drm_dp_aux *aux);\nint drm_dp_pcon_hdmi_link_mode(struct drm_dp_aux *aux, u8 *frl_trained_mask);\nvoid drm_dp_pcon_hdmi_frl_link_error_count(struct drm_dp_aux *aux,\n\t\t\t\t\t   struct drm_connector *connector);\nbool drm_dp_pcon_enc_is_dsc_1_2(const u8 pcon_dsc_dpcd[DP_PCON_DSC_ENCODER_CAP_SIZE]);\nint drm_dp_pcon_dsc_max_slices(const u8 pcon_dsc_dpcd[DP_PCON_DSC_ENCODER_CAP_SIZE]);\nint drm_dp_pcon_dsc_max_slice_width(const u8 pcon_dsc_dpcd[DP_PCON_DSC_ENCODER_CAP_SIZE]);\nint drm_dp_pcon_dsc_bpp_incr(const u8 pcon_dsc_dpcd[DP_PCON_DSC_ENCODER_CAP_SIZE]);\nint drm_dp_pcon_pps_default(struct drm_dp_aux *aux);\nint drm_dp_pcon_pps_override_buf(struct drm_dp_aux *aux, u8 pps_buf[128]);\nint drm_dp_pcon_pps_override_param(struct drm_dp_aux *aux, u8 pps_param[6]);\nbool drm_dp_downstream_rgb_to_ycbcr_conversion(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t\t       const u8 port_cap[4], u8 color_spc);\nint drm_dp_pcon_convert_rgb_to_ycbcr(struct drm_dp_aux *aux, u8 color_spc);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}