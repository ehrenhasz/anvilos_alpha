{
  "module_name": "drm_file.h",
  "hash_id": "1907c7cf2b67c2c2f99d89e7c16387585d2a4639d8c864281b2e20186ec5d528",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_file.h",
  "human_readable_source": " \n\n#ifndef _DRM_FILE_H_\n#define _DRM_FILE_H_\n\n#include <linux/types.h>\n#include <linux/completion.h>\n#include <linux/idr.h>\n\n#include <uapi/drm/drm.h>\n\n#include <drm/drm_prime.h>\n\nstruct dma_fence;\nstruct drm_file;\nstruct drm_device;\nstruct drm_printer;\nstruct device;\nstruct file;\n\n \n\n \nenum drm_minor_type {\n\tDRM_MINOR_PRIMARY = 0,\n\tDRM_MINOR_CONTROL = 1,\n\tDRM_MINOR_RENDER = 2,\n\tDRM_MINOR_ACCEL = 32,\n};\n\n \nstruct drm_minor {\n\t \n\tint index;\t\t\t \n\tint type;                        \n\tstruct device *kdev;\t\t \n\tstruct drm_device *dev;\n\n\tstruct dentry *debugfs_root;\n\n\tstruct list_head debugfs_list;\n\tstruct mutex debugfs_lock;  \n};\n\n \nstruct drm_pending_event {\n\t \n\tstruct completion *completion;\n\n\t \n\tvoid (*completion_release)(struct completion *completion);\n\n\t \n\tstruct drm_event *event;\n\n\t \n\tstruct dma_fence *fence;\n\n\t \n\tstruct drm_file *file_priv;\n\n\t \n\tstruct list_head link;\n\n\t \n\tstruct list_head pending_link;\n};\n\n \nstruct drm_file {\n\t \n\tbool authenticated;\n\n\t \n\tbool stereo_allowed;\n\n\t \n\tbool universal_planes;\n\n\t \n\tbool atomic;\n\n\t \n\tbool aspect_ratio_allowed;\n\n\t \n\tbool writeback_connectors;\n\n\t \n\tbool was_master;\n\n\t \n\tbool is_master;\n\n\t \n\tstruct drm_master *master;\n\n\t \n\tspinlock_t master_lookup_lock;\n\n\t \n\tstruct pid __rcu *pid;\n\n\t \n\tu64 client_id;\n\n\t \n\tdrm_magic_t magic;\n\n\t \n\tstruct list_head lhead;\n\n\t \n\tstruct drm_minor *minor;\n\n\t \n\tstruct idr object_idr;\n\n\t \n\tspinlock_t table_lock;\n\n\t \n\tstruct idr syncobj_idr;\n\t \n\tspinlock_t syncobj_table_lock;\n\n\t \n\tstruct file *filp;\n\n\t \n\tvoid *driver_priv;\n\n\t \n\tstruct list_head fbs;\n\n\t \n\tstruct mutex fbs_lock;\n\n\t \n\tstruct list_head blobs;\n\n\t \n\twait_queue_head_t event_wait;\n\n\t \n\tstruct list_head pending_event_list;\n\n\t \n\tstruct list_head event_list;\n\n\t \n\tint event_space;\n\n\t \n\tstruct mutex event_read_lock;\n\n\t \n\tstruct drm_prime_file_private prime;\n\n\t \n#if IS_ENABLED(CONFIG_DRM_LEGACY)\n\tunsigned long lock_count;  \n#endif\n};\n\n \nstatic inline bool drm_is_primary_client(const struct drm_file *file_priv)\n{\n\treturn file_priv->minor->type == DRM_MINOR_PRIMARY;\n}\n\n \nstatic inline bool drm_is_render_client(const struct drm_file *file_priv)\n{\n\treturn file_priv->minor->type == DRM_MINOR_RENDER;\n}\n\n \nstatic inline bool drm_is_accel_client(const struct drm_file *file_priv)\n{\n\treturn file_priv->minor->type == DRM_MINOR_ACCEL;\n}\n\nvoid drm_file_update_pid(struct drm_file *);\n\nint drm_open(struct inode *inode, struct file *filp);\nint drm_open_helper(struct file *filp, struct drm_minor *minor);\nssize_t drm_read(struct file *filp, char __user *buffer,\n\t\t size_t count, loff_t *offset);\nint drm_release(struct inode *inode, struct file *filp);\nint drm_release_noglobal(struct inode *inode, struct file *filp);\n__poll_t drm_poll(struct file *filp, struct poll_table_struct *wait);\nint drm_event_reserve_init_locked(struct drm_device *dev,\n\t\t\t\t  struct drm_file *file_priv,\n\t\t\t\t  struct drm_pending_event *p,\n\t\t\t\t  struct drm_event *e);\nint drm_event_reserve_init(struct drm_device *dev,\n\t\t\t   struct drm_file *file_priv,\n\t\t\t   struct drm_pending_event *p,\n\t\t\t   struct drm_event *e);\nvoid drm_event_cancel_free(struct drm_device *dev,\n\t\t\t   struct drm_pending_event *p);\nvoid drm_send_event_locked(struct drm_device *dev, struct drm_pending_event *e);\nvoid drm_send_event(struct drm_device *dev, struct drm_pending_event *e);\nvoid drm_send_event_timestamp_locked(struct drm_device *dev,\n\t\t\t\t     struct drm_pending_event *e,\n\t\t\t\t     ktime_t timestamp);\n\n \nstruct drm_memory_stats {\n\tu64 shared;\n\tu64 private;\n\tu64 resident;\n\tu64 purgeable;\n\tu64 active;\n};\n\nenum drm_gem_object_status;\n\nvoid drm_print_memory_stats(struct drm_printer *p,\n\t\t\t    const struct drm_memory_stats *stats,\n\t\t\t    enum drm_gem_object_status supported_status,\n\t\t\t    const char *region);\n\nvoid drm_show_memory_stats(struct drm_printer *p, struct drm_file *file);\nvoid drm_show_fdinfo(struct seq_file *m, struct file *f);\n\nstruct file *mock_drm_getfile(struct drm_minor *minor, unsigned int flags);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}