{
  "module_name": "ttm_tt.h",
  "hash_id": "a1d68e45699462db6a6c61ff1e7488477de8b3c335ce9b6cd21e756aa5b46bb2",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/ttm/ttm_tt.h",
  "human_readable_source": " \n#ifndef _TTM_TT_H_\n#define _TTM_TT_H_\n\n#include <linux/pagemap.h>\n#include <linux/types.h>\n#include <drm/ttm/ttm_caching.h>\n#include <drm/ttm/ttm_kmap_iter.h>\n\nstruct ttm_device;\nstruct ttm_tt;\nstruct ttm_resource;\nstruct ttm_buffer_object;\nstruct ttm_operation_ctx;\n\n \nstruct ttm_tt {\n\t \n\tstruct page **pages;\n\t \n#define TTM_TT_FLAG_SWAPPED\t\tBIT(0)\n#define TTM_TT_FLAG_ZERO_ALLOC\t\tBIT(1)\n#define TTM_TT_FLAG_EXTERNAL\t\tBIT(2)\n#define TTM_TT_FLAG_EXTERNAL_MAPPABLE\tBIT(3)\n\n#define TTM_TT_FLAG_PRIV_POPULATED\tBIT(4)\n\tuint32_t page_flags;\n\t \n\tuint32_t num_pages;\n\t \n\tstruct sg_table *sg;\n\t \n\tdma_addr_t *dma_address;\n\t \n\tstruct file *swap_storage;\n\t \n\tenum ttm_caching caching;\n};\n\n \nstruct ttm_kmap_iter_tt {\n\tstruct ttm_kmap_iter base;\n\tstruct ttm_tt *tt;\n\tpgprot_t prot;\n};\n\nstatic inline bool ttm_tt_is_populated(struct ttm_tt *tt)\n{\n\treturn tt->page_flags & TTM_TT_FLAG_PRIV_POPULATED;\n}\n\n \nint ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc);\n\n \nint ttm_tt_init(struct ttm_tt *ttm, struct ttm_buffer_object *bo,\n\t\tuint32_t page_flags, enum ttm_caching caching,\n\t\tunsigned long extra_pages);\nint ttm_sg_tt_init(struct ttm_tt *ttm_dma, struct ttm_buffer_object *bo,\n\t\t   uint32_t page_flags, enum ttm_caching caching);\n\n \nvoid ttm_tt_fini(struct ttm_tt *ttm);\n\n \nvoid ttm_tt_destroy(struct ttm_device *bdev, struct ttm_tt *ttm);\n\n \nint ttm_tt_swapin(struct ttm_tt *ttm);\nint ttm_tt_swapout(struct ttm_device *bdev, struct ttm_tt *ttm,\n\t\t   gfp_t gfp_flags);\n\n \nint ttm_tt_populate(struct ttm_device *bdev, struct ttm_tt *ttm,\n\t\t    struct ttm_operation_ctx *ctx);\n\n \nvoid ttm_tt_unpopulate(struct ttm_device *bdev, struct ttm_tt *ttm);\n\n \nstatic inline void ttm_tt_mark_for_clear(struct ttm_tt *ttm)\n{\n\tttm->page_flags |= TTM_TT_FLAG_ZERO_ALLOC;\n}\n\nvoid ttm_tt_mgr_init(unsigned long num_pages, unsigned long num_dma32_pages);\n\nstruct ttm_kmap_iter *ttm_kmap_iter_tt_init(struct ttm_kmap_iter_tt *iter_tt,\n\t\t\t\t\t    struct ttm_tt *tt);\nunsigned long ttm_tt_pages_limit(void);\n#if IS_ENABLED(CONFIG_AGP)\n#include <linux/agp_backend.h>\n\n \nstruct ttm_tt *ttm_agp_tt_create(struct ttm_buffer_object *bo,\n\t\t\t\t struct agp_bridge_data *bridge,\n\t\t\t\t uint32_t page_flags);\nint ttm_agp_bind(struct ttm_tt *ttm, struct ttm_resource *bo_mem);\nvoid ttm_agp_unbind(struct ttm_tt *ttm);\nvoid ttm_agp_destroy(struct ttm_tt *ttm);\nbool ttm_agp_is_bound(struct ttm_tt *ttm);\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}