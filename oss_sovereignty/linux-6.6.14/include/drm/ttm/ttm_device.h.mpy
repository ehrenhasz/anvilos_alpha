{
  "module_name": "ttm_device.h",
  "hash_id": "69f974153d05341430ebd1041a700563e7bf9124753806fcf10e1b891ab917a1",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/ttm/ttm_device.h",
  "human_readable_source": " \n\n#ifndef _TTM_DEVICE_H_\n#define _TTM_DEVICE_H_\n\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <drm/ttm/ttm_resource.h>\n#include <drm/ttm/ttm_pool.h>\n\nstruct ttm_device;\nstruct ttm_placement;\nstruct ttm_buffer_object;\nstruct ttm_operation_ctx;\n\n \nextern struct ttm_global {\n\n\t \n\tstruct page *dummy_read_page;\n\n\t \n\tstruct list_head device_list;\n\n\t \n\tatomic_t bo_count;\n} ttm_glob;\n\nstruct ttm_device_funcs {\n\t \n\tstruct ttm_tt *(*ttm_tt_create)(struct ttm_buffer_object *bo,\n\t\t\t\t\tuint32_t page_flags);\n\n\t \n\tint (*ttm_tt_populate)(struct ttm_device *bdev,\n\t\t\t       struct ttm_tt *ttm,\n\t\t\t       struct ttm_operation_ctx *ctx);\n\n\t \n\tvoid (*ttm_tt_unpopulate)(struct ttm_device *bdev,\n\t\t\t\t  struct ttm_tt *ttm);\n\n\t \n\tvoid (*ttm_tt_destroy)(struct ttm_device *bdev, struct ttm_tt *ttm);\n\n\t \n\tbool (*eviction_valuable)(struct ttm_buffer_object *bo,\n\t\t\t\t  const struct ttm_place *place);\n\t \n\n\tvoid (*evict_flags)(struct ttm_buffer_object *bo,\n\t\t\t    struct ttm_placement *placement);\n\n\t \n\tint (*move)(struct ttm_buffer_object *bo, bool evict,\n\t\t    struct ttm_operation_ctx *ctx,\n\t\t    struct ttm_resource *new_mem,\n\t\t    struct ttm_place *hop);\n\n\t \n\tvoid (*delete_mem_notify)(struct ttm_buffer_object *bo);\n\n\t \n\tvoid (*swap_notify)(struct ttm_buffer_object *bo);\n\n\t \n\tint (*io_mem_reserve)(struct ttm_device *bdev,\n\t\t\t      struct ttm_resource *mem);\n\tvoid (*io_mem_free)(struct ttm_device *bdev,\n\t\t\t    struct ttm_resource *mem);\n\n\t \n\tunsigned long (*io_mem_pfn)(struct ttm_buffer_object *bo,\n\t\t\t\t    unsigned long page_offset);\n\n\t \n\tint (*access_memory)(struct ttm_buffer_object *bo, unsigned long offset,\n\t\t\t     void *buf, int len, int write);\n\n\t \n\tvoid (*release_notify)(struct ttm_buffer_object *bo);\n};\n\n \nstruct ttm_device {\n\t \n\tstruct list_head device_list;\n\n\t \n\tconst struct ttm_device_funcs *funcs;\n\n\t \n\tstruct ttm_resource_manager sysman;\n\n\t \n\tstruct ttm_resource_manager *man_drv[TTM_NUM_MEM_TYPES];\n\n\t \n\tstruct drm_vma_offset_manager *vma_manager;\n\n\t \n\tstruct ttm_pool pool;\n\n\t \n\tspinlock_t lru_lock;\n\n\t \n\tstruct list_head pinned;\n\n\t \n\tstruct address_space *dev_mapping;\n\n\t \n\tstruct workqueue_struct *wq;\n};\n\nint ttm_global_swapout(struct ttm_operation_ctx *ctx, gfp_t gfp_flags);\nint ttm_device_swapout(struct ttm_device *bdev, struct ttm_operation_ctx *ctx,\n\t\t       gfp_t gfp_flags);\n\nstatic inline struct ttm_resource_manager *\nttm_manager_type(struct ttm_device *bdev, int mem_type)\n{\n\tBUILD_BUG_ON(__builtin_constant_p(mem_type)\n\t\t     && mem_type >= TTM_NUM_MEM_TYPES);\n\treturn bdev->man_drv[mem_type];\n}\n\nstatic inline void ttm_set_driver_manager(struct ttm_device *bdev, int type,\n\t\t\t\t\t  struct ttm_resource_manager *manager)\n{\n\tBUILD_BUG_ON(__builtin_constant_p(type) && type >= TTM_NUM_MEM_TYPES);\n\tbdev->man_drv[type] = manager;\n}\n\nint ttm_device_init(struct ttm_device *bdev, const struct ttm_device_funcs *funcs,\n\t\t    struct device *dev, struct address_space *mapping,\n\t\t    struct drm_vma_offset_manager *vma_manager,\n\t\t    bool use_dma_alloc, bool use_dma32);\nvoid ttm_device_fini(struct ttm_device *bdev);\nvoid ttm_device_clear_dma_mappings(struct ttm_device *bdev);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}