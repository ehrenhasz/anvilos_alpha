{
  "module_name": "ttm_resource.h",
  "hash_id": "df15ab17d1a55e9c0ae6800767fe06892484670eb978991dd612802ddb3db5d0",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/ttm/ttm_resource.h",
  "human_readable_source": " \n\n#ifndef _TTM_RESOURCE_H_\n#define _TTM_RESOURCE_H_\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/iosys-map.h>\n#include <linux/dma-fence.h>\n\n#include <drm/drm_print.h>\n#include <drm/ttm/ttm_caching.h>\n#include <drm/ttm/ttm_kmap_iter.h>\n\n#define TTM_MAX_BO_PRIORITY\t4U\n#define TTM_NUM_MEM_TYPES 8\n\nstruct ttm_device;\nstruct ttm_resource_manager;\nstruct ttm_resource;\nstruct ttm_place;\nstruct ttm_buffer_object;\nstruct ttm_placement;\nstruct iosys_map;\nstruct io_mapping;\nstruct sg_table;\nstruct scatterlist;\n\nstruct ttm_resource_manager_func {\n\t \n\tint  (*alloc)(struct ttm_resource_manager *man,\n\t\t      struct ttm_buffer_object *bo,\n\t\t      const struct ttm_place *place,\n\t\t      struct ttm_resource **res);\n\n\t \n\tvoid (*free)(struct ttm_resource_manager *man,\n\t\t     struct ttm_resource *res);\n\n\t \n\tbool (*intersects)(struct ttm_resource_manager *man,\n\t\t\t   struct ttm_resource *res,\n\t\t\t   const struct ttm_place *place,\n\t\t\t   size_t size);\n\n\t \n\tbool (*compatible)(struct ttm_resource_manager *man,\n\t\t\t   struct ttm_resource *res,\n\t\t\t   const struct ttm_place *place,\n\t\t\t   size_t size);\n\n\t \n\tvoid (*debug)(struct ttm_resource_manager *man,\n\t\t      struct drm_printer *printer);\n};\n\n \nstruct ttm_resource_manager {\n\t \n\tbool use_type;\n\tbool use_tt;\n\tstruct ttm_device *bdev;\n\tuint64_t size;\n\tconst struct ttm_resource_manager_func *func;\n\tspinlock_t move_lock;\n\n\t \n\tstruct dma_fence *move;\n\n\t \n\tstruct list_head lru[TTM_MAX_BO_PRIORITY];\n\n\t \n\tuint64_t usage;\n};\n\n \nstruct ttm_bus_placement {\n\tvoid\t\t\t*addr;\n\tphys_addr_t\t\toffset;\n\tbool\t\t\tis_iomem;\n\tenum ttm_caching\tcaching;\n};\n\n \nstruct ttm_resource {\n\tunsigned long start;\n\tsize_t size;\n\tuint32_t mem_type;\n\tuint32_t placement;\n\tstruct ttm_bus_placement bus;\n\tstruct ttm_buffer_object *bo;\n\n\t \n\tstruct list_head lru;\n};\n\n \nstruct ttm_resource_cursor {\n\tunsigned int priority;\n};\n\n \nstruct ttm_lru_bulk_move_pos {\n\tstruct ttm_resource *first;\n\tstruct ttm_resource *last;\n};\n\n \nstruct ttm_lru_bulk_move {\n\tstruct ttm_lru_bulk_move_pos pos[TTM_NUM_MEM_TYPES][TTM_MAX_BO_PRIORITY];\n};\n\n \nstruct ttm_kmap_iter_iomap {\n\tstruct ttm_kmap_iter base;\n\tstruct io_mapping *iomap;\n\tstruct sg_table *st;\n\tresource_size_t start;\n\tstruct {\n\t\tstruct scatterlist *sg;\n\t\tpgoff_t i;\n\t\tpgoff_t end;\n\t\tpgoff_t offs;\n\t} cache;\n};\n\n \nstruct ttm_kmap_iter_linear_io {\n\tstruct ttm_kmap_iter base;\n\tstruct iosys_map dmap;\n\tbool needs_unmap;\n};\n\n \nstatic inline void\nttm_resource_manager_set_used(struct ttm_resource_manager *man, bool used)\n{\n\tint i;\n\n\tfor (i = 0; i < TTM_MAX_BO_PRIORITY; i++)\n\t\tWARN_ON(!list_empty(&man->lru[i]));\n\tman->use_type = used;\n}\n\n \nstatic inline bool ttm_resource_manager_used(struct ttm_resource_manager *man)\n{\n\treturn man->use_type;\n}\n\n \nstatic inline void\nttm_resource_manager_cleanup(struct ttm_resource_manager *man)\n{\n\tdma_fence_put(man->move);\n\tman->move = NULL;\n}\n\nvoid ttm_lru_bulk_move_init(struct ttm_lru_bulk_move *bulk);\nvoid ttm_lru_bulk_move_tail(struct ttm_lru_bulk_move *bulk);\n\nvoid ttm_resource_add_bulk_move(struct ttm_resource *res,\n\t\t\t\tstruct ttm_buffer_object *bo);\nvoid ttm_resource_del_bulk_move(struct ttm_resource *res,\n\t\t\t\tstruct ttm_buffer_object *bo);\nvoid ttm_resource_move_to_lru_tail(struct ttm_resource *res);\n\nvoid ttm_resource_init(struct ttm_buffer_object *bo,\n                       const struct ttm_place *place,\n                       struct ttm_resource *res);\nvoid ttm_resource_fini(struct ttm_resource_manager *man,\n\t\t       struct ttm_resource *res);\n\nint ttm_resource_alloc(struct ttm_buffer_object *bo,\n\t\t       const struct ttm_place *place,\n\t\t       struct ttm_resource **res);\nvoid ttm_resource_free(struct ttm_buffer_object *bo, struct ttm_resource **res);\nbool ttm_resource_intersects(struct ttm_device *bdev,\n\t\t\t     struct ttm_resource *res,\n\t\t\t     const struct ttm_place *place,\n\t\t\t     size_t size);\nbool ttm_resource_compatible(struct ttm_device *bdev,\n\t\t\t     struct ttm_resource *res,\n\t\t\t     const struct ttm_place *place,\n\t\t\t     size_t size);\nbool ttm_resource_compat(struct ttm_resource *res,\n\t\t\t struct ttm_placement *placement);\nvoid ttm_resource_set_bo(struct ttm_resource *res,\n\t\t\t struct ttm_buffer_object *bo);\n\nvoid ttm_resource_manager_init(struct ttm_resource_manager *man,\n\t\t\t       struct ttm_device *bdev,\n\t\t\t       uint64_t size);\n\nint ttm_resource_manager_evict_all(struct ttm_device *bdev,\n\t\t\t\t   struct ttm_resource_manager *man);\n\nuint64_t ttm_resource_manager_usage(struct ttm_resource_manager *man);\nvoid ttm_resource_manager_debug(struct ttm_resource_manager *man,\n\t\t\t\tstruct drm_printer *p);\n\nstruct ttm_resource *\nttm_resource_manager_first(struct ttm_resource_manager *man,\n\t\t\t   struct ttm_resource_cursor *cursor);\nstruct ttm_resource *\nttm_resource_manager_next(struct ttm_resource_manager *man,\n\t\t\t  struct ttm_resource_cursor *cursor,\n\t\t\t  struct ttm_resource *res);\n\n \n#define ttm_resource_manager_for_each_res(man, cursor, res)\t\t\\\n\tfor (res = ttm_resource_manager_first(man, cursor); res;\t\\\n\t     res = ttm_resource_manager_next(man, cursor, res))\n\nstruct ttm_kmap_iter *\nttm_kmap_iter_iomap_init(struct ttm_kmap_iter_iomap *iter_io,\n\t\t\t struct io_mapping *iomap,\n\t\t\t struct sg_table *st,\n\t\t\t resource_size_t start);\n\nstruct ttm_kmap_iter_linear_io;\n\nstruct ttm_kmap_iter *\nttm_kmap_iter_linear_io_init(struct ttm_kmap_iter_linear_io *iter_io,\n\t\t\t     struct ttm_device *bdev,\n\t\t\t     struct ttm_resource *mem);\n\nvoid ttm_kmap_iter_linear_io_fini(struct ttm_kmap_iter_linear_io *iter_io,\n\t\t\t\t  struct ttm_device *bdev,\n\t\t\t\t  struct ttm_resource *mem);\n\nvoid ttm_resource_manager_create_debugfs(struct ttm_resource_manager *man,\n\t\t\t\t\t struct dentry * parent,\n\t\t\t\t\t const char *name);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}