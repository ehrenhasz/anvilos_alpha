{
  "module_name": "drm_bridge.h",
  "hash_id": "b62fff430065094eac5654f5e6150f3ee3daf4facff63813604c531b3868a61a",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_bridge.h",
  "human_readable_source": " \n\n#ifndef __DRM_BRIDGE_H__\n#define __DRM_BRIDGE_H__\n\n#include <linux/ctype.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_mode_object.h>\n#include <drm/drm_modes.h>\n\nstruct drm_bridge;\nstruct drm_bridge_timings;\nstruct drm_connector;\nstruct drm_display_info;\nstruct drm_minor;\nstruct drm_panel;\nstruct edid;\nstruct i2c_adapter;\n\n \nenum drm_bridge_attach_flags {\n\t \n\tDRM_BRIDGE_ATTACH_NO_CONNECTOR = BIT(0),\n};\n\n \nstruct drm_bridge_funcs {\n\t \n\tint (*attach)(struct drm_bridge *bridge,\n\t\t      enum drm_bridge_attach_flags flags);\n\n\t \n\tvoid (*detach)(struct drm_bridge *bridge);\n\n\t \n\tenum drm_mode_status (*mode_valid)(struct drm_bridge *bridge,\n\t\t\t\t\t   const struct drm_display_info *info,\n\t\t\t\t\t   const struct drm_display_mode *mode);\n\n\t \n\tbool (*mode_fixup)(struct drm_bridge *bridge,\n\t\t\t   const struct drm_display_mode *mode,\n\t\t\t   struct drm_display_mode *adjusted_mode);\n\t \n\tvoid (*disable)(struct drm_bridge *bridge);\n\n\t \n\tvoid (*post_disable)(struct drm_bridge *bridge);\n\n\t \n\tvoid (*mode_set)(struct drm_bridge *bridge,\n\t\t\t const struct drm_display_mode *mode,\n\t\t\t const struct drm_display_mode *adjusted_mode);\n\t \n\tvoid (*pre_enable)(struct drm_bridge *bridge);\n\n\t \n\tvoid (*enable)(struct drm_bridge *bridge);\n\n\t \n\tvoid (*atomic_pre_enable)(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *old_bridge_state);\n\n\t \n\tvoid (*atomic_enable)(struct drm_bridge *bridge,\n\t\t\t      struct drm_bridge_state *old_bridge_state);\n\t \n\tvoid (*atomic_disable)(struct drm_bridge *bridge,\n\t\t\t       struct drm_bridge_state *old_bridge_state);\n\n\t \n\tvoid (*atomic_post_disable)(struct drm_bridge *bridge,\n\t\t\t\t    struct drm_bridge_state *old_bridge_state);\n\n\t \n\tstruct drm_bridge_state *(*atomic_duplicate_state)(struct drm_bridge *bridge);\n\n\t \n\tvoid (*atomic_destroy_state)(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_bridge_state *state);\n\n\t \n\tu32 *(*atomic_get_output_bus_fmts)(struct drm_bridge *bridge,\n\t\t\t\t\t   struct drm_bridge_state *bridge_state,\n\t\t\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t\t\t   struct drm_connector_state *conn_state,\n\t\t\t\t\t   unsigned int *num_output_fmts);\n\n\t \n\tu32 *(*atomic_get_input_bus_fmts)(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_bridge_state *bridge_state,\n\t\t\t\t\t  struct drm_crtc_state *crtc_state,\n\t\t\t\t\t  struct drm_connector_state *conn_state,\n\t\t\t\t\t  u32 output_fmt,\n\t\t\t\t\t  unsigned int *num_input_fmts);\n\n\t \n\tint (*atomic_check)(struct drm_bridge *bridge,\n\t\t\t    struct drm_bridge_state *bridge_state,\n\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t    struct drm_connector_state *conn_state);\n\n\t \n\tstruct drm_bridge_state *(*atomic_reset)(struct drm_bridge *bridge);\n\n\t \n\tenum drm_connector_status (*detect)(struct drm_bridge *bridge);\n\n\t \n\tint (*get_modes)(struct drm_bridge *bridge,\n\t\t\t struct drm_connector *connector);\n\n\t \n\tstruct edid *(*get_edid)(struct drm_bridge *bridge,\n\t\t\t\t struct drm_connector *connector);\n\n\t \n\tvoid (*hpd_notify)(struct drm_bridge *bridge,\n\t\t\t   enum drm_connector_status status);\n\n\t \n\tvoid (*hpd_enable)(struct drm_bridge *bridge);\n\n\t \n\tvoid (*hpd_disable)(struct drm_bridge *bridge);\n\n\t \n\tvoid (*debugfs_init)(struct drm_bridge *bridge, struct dentry *root);\n};\n\n \nstruct drm_bridge_timings {\n\t \n\tu32 input_bus_flags;\n\t \n\tu32 setup_time_ps;\n\t \n\tu32 hold_time_ps;\n\t \n\tbool dual_link;\n};\n\n \nenum drm_bridge_ops {\n\t \n\tDRM_BRIDGE_OP_DETECT = BIT(0),\n\t \n\tDRM_BRIDGE_OP_EDID = BIT(1),\n\t \n\tDRM_BRIDGE_OP_HPD = BIT(2),\n\t \n\tDRM_BRIDGE_OP_MODES = BIT(3),\n};\n\n \nstruct drm_bridge {\n\t \n\tstruct drm_private_obj base;\n\t \n\tstruct drm_device *dev;\n\t \n\tstruct drm_encoder *encoder;\n\t \n\tstruct list_head chain_node;\n#ifdef CONFIG_OF\n\t \n\tstruct device_node *of_node;\n#endif\n\t \n\tstruct list_head list;\n\t \n\tconst struct drm_bridge_timings *timings;\n\t \n\tconst struct drm_bridge_funcs *funcs;\n\t \n\tvoid *driver_private;\n\t \n\tenum drm_bridge_ops ops;\n\t \n\tint type;\n\t \n\tbool interlace_allowed;\n\t \n\tbool pre_enable_prev_first;\n\t \n\tstruct i2c_adapter *ddc;\n\t \n\t \n\tstruct mutex hpd_mutex;\n\t \n\tvoid (*hpd_cb)(void *data, enum drm_connector_status status);\n\t \n\tvoid *hpd_data;\n};\n\nstatic inline struct drm_bridge *\ndrm_priv_to_bridge(struct drm_private_obj *priv)\n{\n\treturn container_of(priv, struct drm_bridge, base);\n}\n\nvoid drm_bridge_add(struct drm_bridge *bridge);\nint devm_drm_bridge_add(struct device *dev, struct drm_bridge *bridge);\nvoid drm_bridge_remove(struct drm_bridge *bridge);\nint drm_bridge_attach(struct drm_encoder *encoder, struct drm_bridge *bridge,\n\t\t      struct drm_bridge *previous,\n\t\t      enum drm_bridge_attach_flags flags);\n\n#ifdef CONFIG_OF\nstruct drm_bridge *of_drm_find_bridge(struct device_node *np);\n#else\nstatic inline struct drm_bridge *of_drm_find_bridge(struct device_node *np)\n{\n\treturn NULL;\n}\n#endif\n\n \nstatic inline struct drm_bridge *\ndrm_bridge_get_next_bridge(struct drm_bridge *bridge)\n{\n\tif (list_is_last(&bridge->chain_node, &bridge->encoder->bridge_chain))\n\t\treturn NULL;\n\n\treturn list_next_entry(bridge, chain_node);\n}\n\n \nstatic inline struct drm_bridge *\ndrm_bridge_get_prev_bridge(struct drm_bridge *bridge)\n{\n\tif (list_is_first(&bridge->chain_node, &bridge->encoder->bridge_chain))\n\t\treturn NULL;\n\n\treturn list_prev_entry(bridge, chain_node);\n}\n\n \nstatic inline struct drm_bridge *\ndrm_bridge_chain_get_first_bridge(struct drm_encoder *encoder)\n{\n\treturn list_first_entry_or_null(&encoder->bridge_chain,\n\t\t\t\t\tstruct drm_bridge, chain_node);\n}\n\n \n#define drm_for_each_bridge_in_chain(encoder, bridge)\t\t\t\\\n\tlist_for_each_entry(bridge, &(encoder)->bridge_chain, chain_node)\n\nbool drm_bridge_chain_mode_fixup(struct drm_bridge *bridge,\n\t\t\t\t const struct drm_display_mode *mode,\n\t\t\t\t struct drm_display_mode *adjusted_mode);\nenum drm_mode_status\ndrm_bridge_chain_mode_valid(struct drm_bridge *bridge,\n\t\t\t    const struct drm_display_info *info,\n\t\t\t    const struct drm_display_mode *mode);\nvoid drm_bridge_chain_mode_set(struct drm_bridge *bridge,\n\t\t\t       const struct drm_display_mode *mode,\n\t\t\t       const struct drm_display_mode *adjusted_mode);\n\nint drm_atomic_bridge_chain_check(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_crtc_state *crtc_state,\n\t\t\t\t  struct drm_connector_state *conn_state);\nvoid drm_atomic_bridge_chain_disable(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_atomic_state *state);\nvoid drm_atomic_bridge_chain_post_disable(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_atomic_state *state);\nvoid drm_atomic_bridge_chain_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_atomic_state *state);\nvoid drm_atomic_bridge_chain_enable(struct drm_bridge *bridge,\n\t\t\t\t    struct drm_atomic_state *state);\n\nu32 *\ndrm_atomic_helper_bridge_propagate_bus_fmt(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state,\n\t\t\t\t\tu32 output_fmt,\n\t\t\t\t\tunsigned int *num_input_fmts);\n\nenum drm_connector_status drm_bridge_detect(struct drm_bridge *bridge);\nint drm_bridge_get_modes(struct drm_bridge *bridge,\n\t\t\t struct drm_connector *connector);\nstruct edid *drm_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t struct drm_connector *connector);\nvoid drm_bridge_hpd_enable(struct drm_bridge *bridge,\n\t\t\t   void (*cb)(void *data,\n\t\t\t\t      enum drm_connector_status status),\n\t\t\t   void *data);\nvoid drm_bridge_hpd_disable(struct drm_bridge *bridge);\nvoid drm_bridge_hpd_notify(struct drm_bridge *bridge,\n\t\t\t   enum drm_connector_status status);\n\n#ifdef CONFIG_DRM_PANEL_BRIDGE\nbool drm_bridge_is_panel(const struct drm_bridge *bridge);\nstruct drm_bridge *drm_panel_bridge_add(struct drm_panel *panel);\nstruct drm_bridge *drm_panel_bridge_add_typed(struct drm_panel *panel,\n\t\t\t\t\t      u32 connector_type);\nvoid drm_panel_bridge_remove(struct drm_bridge *bridge);\nint drm_panel_bridge_set_orientation(struct drm_connector *connector,\n\t\t\t\t     struct drm_bridge *bridge);\nstruct drm_bridge *devm_drm_panel_bridge_add(struct device *dev,\n\t\t\t\t\t     struct drm_panel *panel);\nstruct drm_bridge *devm_drm_panel_bridge_add_typed(struct device *dev,\n\t\t\t\t\t\t   struct drm_panel *panel,\n\t\t\t\t\t\t   u32 connector_type);\nstruct drm_bridge *drmm_panel_bridge_add(struct drm_device *drm,\n\t\t\t\t\t     struct drm_panel *panel);\nstruct drm_connector *drm_panel_bridge_connector(struct drm_bridge *bridge);\n#else\nstatic inline bool drm_bridge_is_panel(const struct drm_bridge *bridge)\n{\n\treturn false;\n}\n\nstatic inline int drm_panel_bridge_set_orientation(struct drm_connector *connector,\n\t\t\t\t\t\t   struct drm_bridge *bridge)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#if defined(CONFIG_OF) && defined(CONFIG_DRM_PANEL_BRIDGE)\nstruct drm_bridge *devm_drm_of_get_bridge(struct device *dev, struct device_node *node,\n\t\t\t\t\t  u32 port, u32 endpoint);\nstruct drm_bridge *drmm_of_get_bridge(struct drm_device *drm, struct device_node *node,\n\t\t\t\t\t  u32 port, u32 endpoint);\n#else\nstatic inline struct drm_bridge *devm_drm_of_get_bridge(struct device *dev,\n\t\t\t\t\t\t\tstruct device_node *node,\n\t\t\t\t\t\t\tu32 port,\n\t\t\t\t\t\t\tu32 endpoint)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic inline struct drm_bridge *drmm_of_get_bridge(struct drm_device *drm,\n\t\t\t\t\t\t     struct device_node *node,\n\t\t\t\t\t\t     u32 port,\n\t\t\t\t\t\t     u32 endpoint)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n#endif\n\nvoid drm_bridge_debugfs_init(struct drm_minor *minor);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}