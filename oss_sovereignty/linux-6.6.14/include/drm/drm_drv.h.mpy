{
  "module_name": "drm_drv.h",
  "hash_id": "38a54d769a5175e5e1211f4ee1ac09e6721ba717aebb5b8d55bd2f65c2beb153",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_drv.h",
  "human_readable_source": " \n\n#ifndef _DRM_DRV_H_\n#define _DRM_DRV_H_\n\n#include <linux/list.h>\n#include <linux/irqreturn.h>\n\n#include <video/nomodeset.h>\n\n#include <drm/drm_device.h>\n\nstruct drm_file;\nstruct drm_gem_object;\nstruct drm_master;\nstruct drm_minor;\nstruct dma_buf;\nstruct dma_buf_attachment;\nstruct drm_display_mode;\nstruct drm_mode_create_dumb;\nstruct drm_printer;\nstruct sg_table;\n\n \nenum drm_driver_feature {\n\t \n\tDRIVER_GEM\t\t\t= BIT(0),\n\t \n\tDRIVER_MODESET\t\t\t= BIT(1),\n\t \n\tDRIVER_RENDER\t\t\t= BIT(3),\n\t \n\tDRIVER_ATOMIC\t\t\t= BIT(4),\n\t \n\tDRIVER_SYNCOBJ                  = BIT(5),\n\t \n\tDRIVER_SYNCOBJ_TIMELINE         = BIT(6),\n\t \n\tDRIVER_COMPUTE_ACCEL            = BIT(7),\n\t \n\tDRIVER_GEM_GPUVA\t\t= BIT(8),\n\n\t \n\n\t \n\tDRIVER_USE_AGP\t\t\t= BIT(25),\n\t \n\tDRIVER_LEGACY\t\t\t= BIT(26),\n\t \n\tDRIVER_PCI_DMA\t\t\t= BIT(27),\n\t \n\tDRIVER_SG\t\t\t= BIT(28),\n\n\t \n\tDRIVER_HAVE_DMA\t\t\t= BIT(29),\n\t \n\tDRIVER_HAVE_IRQ\t\t\t= BIT(30),\n};\n\n \nstruct drm_driver {\n\t \n\tint (*load) (struct drm_device *, unsigned long flags);\n\n\t \n\tint (*open) (struct drm_device *, struct drm_file *);\n\n\t \n\tvoid (*postclose) (struct drm_device *, struct drm_file *);\n\n\t \n\tvoid (*lastclose) (struct drm_device *);\n\n\t \n\tvoid (*unload) (struct drm_device *);\n\n\t \n\tvoid (*release) (struct drm_device *);\n\n\t \n\tvoid (*master_set)(struct drm_device *dev, struct drm_file *file_priv,\n\t\t\t   bool from_open);\n\t \n\tvoid (*master_drop)(struct drm_device *dev, struct drm_file *file_priv);\n\n\t \n\tvoid (*debugfs_init)(struct drm_minor *minor);\n\n\t \n\tstruct drm_gem_object *(*gem_create_object)(struct drm_device *dev,\n\t\t\t\t\t\t    size_t size);\n\n\t \n\tint (*prime_handle_to_fd)(struct drm_device *dev, struct drm_file *file_priv,\n\t\t\t\tuint32_t handle, uint32_t flags, int *prime_fd);\n\t \n\tint (*prime_fd_to_handle)(struct drm_device *dev, struct drm_file *file_priv,\n\t\t\t\tint prime_fd, uint32_t *handle);\n\n\t \n\tstruct drm_gem_object * (*gem_prime_import)(struct drm_device *dev,\n\t\t\t\tstruct dma_buf *dma_buf);\n\t \n\tstruct drm_gem_object *(*gem_prime_import_sg_table)(\n\t\t\t\tstruct drm_device *dev,\n\t\t\t\tstruct dma_buf_attachment *attach,\n\t\t\t\tstruct sg_table *sgt);\n\n\t \n\tint (*dumb_create)(struct drm_file *file_priv,\n\t\t\t   struct drm_device *dev,\n\t\t\t   struct drm_mode_create_dumb *args);\n\t \n\tint (*dumb_map_offset)(struct drm_file *file_priv,\n\t\t\t       struct drm_device *dev, uint32_t handle,\n\t\t\t       uint64_t *offset);\n\n\t \n\tvoid (*show_fdinfo)(struct drm_printer *p, struct drm_file *f);\n\n\t \n\tint major;\n\t \n\tint minor;\n\t \n\tint patchlevel;\n\t \n\tchar *name;\n\t \n\tchar *desc;\n\t \n\tchar *date;\n\n\t \n\tu32 driver_features;\n\n\t \n\n\tconst struct drm_ioctl_desc *ioctls;\n\t \n\tint num_ioctls;\n\n\t \n\tconst struct file_operations *fops;\n\n#ifdef CONFIG_DRM_LEGACY\n\t \n\t \n\n\tint (*firstopen) (struct drm_device *);\n\tvoid (*preclose) (struct drm_device *, struct drm_file *file_priv);\n\tint (*dma_ioctl) (struct drm_device *dev, void *data, struct drm_file *file_priv);\n\tint (*dma_quiescent) (struct drm_device *);\n\tint (*context_dtor) (struct drm_device *dev, int context);\n\tirqreturn_t (*irq_handler)(int irq, void *arg);\n\tvoid (*irq_preinstall)(struct drm_device *dev);\n\tint (*irq_postinstall)(struct drm_device *dev);\n\tvoid (*irq_uninstall)(struct drm_device *dev);\n\tu32 (*get_vblank_counter)(struct drm_device *dev, unsigned int pipe);\n\tint (*enable_vblank)(struct drm_device *dev, unsigned int pipe);\n\tvoid (*disable_vblank)(struct drm_device *dev, unsigned int pipe);\n\tint dev_priv_size;\n#endif\n};\n\nvoid *__devm_drm_dev_alloc(struct device *parent,\n\t\t\t   const struct drm_driver *driver,\n\t\t\t   size_t size, size_t offset);\n\n \n#define devm_drm_dev_alloc(parent, driver, type, member) \\\n\t((type *) __devm_drm_dev_alloc(parent, driver, sizeof(type), \\\n\t\t\t\t       offsetof(type, member)))\n\nstruct drm_device *drm_dev_alloc(const struct drm_driver *driver,\n\t\t\t\t struct device *parent);\nint drm_dev_register(struct drm_device *dev, unsigned long flags);\nvoid drm_dev_unregister(struct drm_device *dev);\n\nvoid drm_dev_get(struct drm_device *dev);\nvoid drm_dev_put(struct drm_device *dev);\nvoid drm_put_dev(struct drm_device *dev);\nbool drm_dev_enter(struct drm_device *dev, int *idx);\nvoid drm_dev_exit(int idx);\nvoid drm_dev_unplug(struct drm_device *dev);\n\n \nstatic inline bool drm_dev_is_unplugged(struct drm_device *dev)\n{\n\tint idx;\n\n\tif (drm_dev_enter(dev, &idx)) {\n\t\tdrm_dev_exit(idx);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic inline bool drm_core_check_all_features(const struct drm_device *dev,\n\t\t\t\t\t       u32 features)\n{\n\tu32 supported = dev->driver->driver_features & dev->driver_features;\n\n\treturn features && (supported & features) == features;\n}\n\n \nstatic inline bool drm_core_check_feature(const struct drm_device *dev,\n\t\t\t\t\t  enum drm_driver_feature feature)\n{\n\treturn drm_core_check_all_features(dev, feature);\n}\n\n \nstatic inline bool drm_drv_uses_atomic_modeset(struct drm_device *dev)\n{\n\treturn drm_core_check_feature(dev, DRIVER_ATOMIC) ||\n\t\t(dev->mode_config.funcs && dev->mode_config.funcs->atomic_commit != NULL);\n}\n\n\n \nstatic inline bool drm_firmware_drivers_only(void)\n{\n\treturn video_firmware_drivers_only();\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}