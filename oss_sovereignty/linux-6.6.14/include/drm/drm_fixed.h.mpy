{
  "module_name": "drm_fixed.h",
  "hash_id": "bcea8d1a4a9f932f5569a002c35a8038a91b3a097b3f912813d12be182953fea",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_fixed.h",
  "human_readable_source": " \n#ifndef DRM_FIXED_H\n#define DRM_FIXED_H\n\n#include <linux/kernel.h>\n#include <linux/math64.h>\n\ntypedef union dfixed {\n\tu32 full;\n} fixed20_12;\n\n\n#define dfixed_const(A) (u32)(((A) << 12)) \n#define dfixed_const_half(A) (u32)(((A) << 12) + 2048)\n#define dfixed_const_666(A) (u32)(((A) << 12) + 2731)\n#define dfixed_const_8(A) (u32)(((A) << 12) + 3277)\n#define dfixed_mul(A, B) ((u64)((u64)(A).full * (B).full + 2048) >> 12)\n#define dfixed_init(A) { .full = dfixed_const((A)) }\n#define dfixed_init_half(A) { .full = dfixed_const_half((A)) }\n#define dfixed_trunc(A) ((A).full >> 12)\n#define dfixed_frac(A) ((A).full & ((1 << 12) - 1))\n\nstatic inline u32 dfixed_floor(fixed20_12 A)\n{\n\tu32 non_frac = dfixed_trunc(A);\n\n\treturn dfixed_const(non_frac);\n}\n\nstatic inline u32 dfixed_ceil(fixed20_12 A)\n{\n\tu32 non_frac = dfixed_trunc(A);\n\n\tif (A.full > dfixed_const(non_frac))\n\t\treturn dfixed_const(non_frac + 1);\n\telse\n\t\treturn dfixed_const(non_frac);\n}\n\nstatic inline u32 dfixed_div(fixed20_12 A, fixed20_12 B)\n{\n\tu64 tmp = ((u64)A.full << 13);\n\n\tdo_div(tmp, B.full);\n\ttmp += 1;\n\ttmp /= 2;\n\treturn lower_32_bits(tmp);\n}\n\n#define DRM_FIXED_POINT\t\t32\n#define DRM_FIXED_POINT_HALF\t16\n#define DRM_FIXED_ONE\t\t(1ULL << DRM_FIXED_POINT)\n#define DRM_FIXED_DECIMAL_MASK\t(DRM_FIXED_ONE - 1)\n#define DRM_FIXED_DIGITS_MASK\t(~DRM_FIXED_DECIMAL_MASK)\n#define DRM_FIXED_EPSILON\t1LL\n#define DRM_FIXED_ALMOST_ONE\t(DRM_FIXED_ONE - DRM_FIXED_EPSILON)\n\nstatic inline s64 drm_int2fixp(int a)\n{\n\treturn ((s64)a) << DRM_FIXED_POINT;\n}\n\nstatic inline int drm_fixp2int(s64 a)\n{\n\treturn ((s64)a) >> DRM_FIXED_POINT;\n}\n\nstatic inline int drm_fixp2int_round(s64 a)\n{\n\treturn drm_fixp2int(a + (1 << (DRM_FIXED_POINT_HALF - 1)));\n}\n\nstatic inline int drm_fixp2int_ceil(s64 a)\n{\n\tif (a > 0)\n\t\treturn drm_fixp2int(a + DRM_FIXED_ALMOST_ONE);\n\telse\n\t\treturn drm_fixp2int(a - DRM_FIXED_ALMOST_ONE);\n}\n\nstatic inline unsigned drm_fixp_msbset(s64 a)\n{\n\tunsigned shift, sign = (a >> 63) & 1;\n\n\tfor (shift = 62; shift > 0; --shift)\n\t\tif (((a >> shift) & 1) != sign)\n\t\t\treturn shift;\n\n\treturn 0;\n}\n\nstatic inline s64 drm_fixp_mul(s64 a, s64 b)\n{\n\tunsigned shift = drm_fixp_msbset(a) + drm_fixp_msbset(b);\n\ts64 result;\n\n\tif (shift > 61) {\n\t\tshift = shift - 61;\n\t\ta >>= (shift >> 1) + (shift & 1);\n\t\tb >>= shift >> 1;\n\t} else\n\t\tshift = 0;\n\n\tresult = a * b;\n\n\tif (shift > DRM_FIXED_POINT)\n\t\treturn result << (shift - DRM_FIXED_POINT);\n\n\tif (shift < DRM_FIXED_POINT)\n\t\treturn result >> (DRM_FIXED_POINT - shift);\n\n\treturn result;\n}\n\nstatic inline s64 drm_fixp_div(s64 a, s64 b)\n{\n\tunsigned shift = 62 - drm_fixp_msbset(a);\n\ts64 result;\n\n\ta <<= shift;\n\n\tif (shift < DRM_FIXED_POINT)\n\t\tb >>= (DRM_FIXED_POINT - shift);\n\n\tresult = div64_s64(a, b);\n\n\tif (shift > DRM_FIXED_POINT)\n\t\treturn result >> (shift - DRM_FIXED_POINT);\n\n\treturn result;\n}\n\nstatic inline s64 drm_fixp_from_fraction(s64 a, s64 b)\n{\n\ts64 res;\n\tbool a_neg = a < 0;\n\tbool b_neg = b < 0;\n\tu64 a_abs = a_neg ? -a : a;\n\tu64 b_abs = b_neg ? -b : b;\n\tu64 rem;\n\n\t \n\tu64 res_abs  = div64_u64_rem(a_abs, b_abs, &rem);\n\n\t \n\t{\n\t\tu32 i = DRM_FIXED_POINT;\n\n\t\tdo {\n\t\t\trem <<= 1;\n\t\t\tres_abs <<= 1;\n\t\t\tif (rem >= b_abs) {\n\t\t\t\tres_abs |= 1;\n\t\t\t\trem -= b_abs;\n\t\t\t}\n\t\t} while (--i != 0);\n\t}\n\n\t \n\t{\n\t\tu64 summand = (rem << 1) >= b_abs;\n\n\t\tres_abs += summand;\n\t}\n\n\tres = (s64) res_abs;\n\tif (a_neg ^ b_neg)\n\t\tres = -res;\n\treturn res;\n}\n\nstatic inline s64 drm_fixp_exp(s64 x)\n{\n\ts64 tolerance = div64_s64(DRM_FIXED_ONE, 1000000);\n\ts64 sum = DRM_FIXED_ONE, term, y = x;\n\tu64 count = 1;\n\n\tif (x < 0)\n\t\ty = -1 * x;\n\n\tterm = y;\n\n\twhile (term >= tolerance) {\n\t\tsum = sum + term;\n\t\tcount = count + 1;\n\t\tterm = drm_fixp_mul(term, div64_s64(y, count));\n\t}\n\n\tif (x < 0)\n\t\tsum = drm_fixp_div(DRM_FIXED_ONE, sum);\n\n\treturn sum;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}