{
  "module_name": "drm_modeset_lock.h",
  "hash_id": "d1e6030d09ac9e0158eac576c360e138f7fa31e90d3105cfbd59993b74e0225f",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_modeset_lock.h",
  "human_readable_source": " \n\n#ifndef DRM_MODESET_LOCK_H_\n#define DRM_MODESET_LOCK_H_\n\n#include <linux/types.h>  \n#include <linux/stackdepot.h>\n#include <linux/ww_mutex.h>\n\nstruct drm_modeset_lock;\n\n \nstruct drm_modeset_acquire_ctx {\n\n\tstruct ww_acquire_ctx ww_ctx;\n\n\t \n\tstruct drm_modeset_lock *contended;\n\n\t \n\tdepot_stack_handle_t stack_depot;\n\n\t \n\tstruct list_head locked;\n\n\t \n\tbool trylock_only;\n\n\t \n\tbool interruptible;\n};\n\n \nstruct drm_modeset_lock {\n\t \n\tstruct ww_mutex mutex;\n\n\t \n\tstruct list_head head;\n};\n\n#define DRM_MODESET_ACQUIRE_INTERRUPTIBLE BIT(0)\n\nvoid drm_modeset_acquire_init(struct drm_modeset_acquire_ctx *ctx,\n\t\tuint32_t flags);\nvoid drm_modeset_acquire_fini(struct drm_modeset_acquire_ctx *ctx);\nvoid drm_modeset_drop_locks(struct drm_modeset_acquire_ctx *ctx);\nint drm_modeset_backoff(struct drm_modeset_acquire_ctx *ctx);\n\nvoid drm_modeset_lock_init(struct drm_modeset_lock *lock);\n\n \nstatic inline void drm_modeset_lock_fini(struct drm_modeset_lock *lock)\n{\n\tWARN_ON(!list_empty(&lock->head));\n}\n\n \nstatic inline bool drm_modeset_is_locked(struct drm_modeset_lock *lock)\n{\n\treturn ww_mutex_is_locked(&lock->mutex);\n}\n\n \nstatic inline void drm_modeset_lock_assert_held(struct drm_modeset_lock *lock)\n{\n\tlockdep_assert_held(&lock->mutex.base);\n}\n\nint drm_modeset_lock(struct drm_modeset_lock *lock,\n\t\tstruct drm_modeset_acquire_ctx *ctx);\nint __must_check drm_modeset_lock_single_interruptible(struct drm_modeset_lock *lock);\nvoid drm_modeset_unlock(struct drm_modeset_lock *lock);\n\nstruct drm_device;\nstruct drm_crtc;\nstruct drm_plane;\n\nvoid drm_modeset_lock_all(struct drm_device *dev);\nvoid drm_modeset_unlock_all(struct drm_device *dev);\nvoid drm_warn_on_modeset_not_all_locked(struct drm_device *dev);\n\nint drm_modeset_lock_all_ctx(struct drm_device *dev,\n\t\t\t     struct drm_modeset_acquire_ctx *ctx);\n\n \n#define DRM_MODESET_LOCK_ALL_BEGIN(dev, ctx, flags, ret)\t\t\\\n\tif (!drm_drv_uses_atomic_modeset(dev))\t\t\t\t\\\n\t\tmutex_lock(&dev->mode_config.mutex);\t\t\t\\\n\tdrm_modeset_acquire_init(&ctx, flags);\t\t\t\t\\\nmodeset_lock_retry:\t\t\t\t\t\t\t\\\n\tret = drm_modeset_lock_all_ctx(dev, &ctx);\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto modeset_lock_fail;\n\n \n#define DRM_MODESET_LOCK_ALL_END(dev, ctx, ret)\t\t\t\t\\\nmodeset_lock_fail:\t\t\t\t\t\t\t\\\n\tif (ret == -EDEADLK) {\t\t\t\t\t\t\\\n\t\tret = drm_modeset_backoff(&ctx);\t\t\t\\\n\t\tif (!ret)\t\t\t\t\t\t\\\n\t\t\tgoto modeset_lock_retry;\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tdrm_modeset_drop_locks(&ctx);\t\t\t\t\t\\\n\tdrm_modeset_acquire_fini(&ctx);\t\t\t\t\t\\\n\tif (!drm_drv_uses_atomic_modeset(dev))\t\t\t\t\\\n\t\tmutex_unlock(&dev->mode_config.mutex);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}