{
  "module_name": "drm_crtc.h",
  "hash_id": "77a19fe29d06bc2ed4b69dac55e66f38eb0dd5931c38cdab466570bc7813e146",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_crtc.h",
  "human_readable_source": " \n#ifndef __DRM_CRTC_H__\n#define __DRM_CRTC_H__\n\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <drm/drm_modeset_lock.h>\n#include <drm/drm_mode_object.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_device.h>\n#include <drm/drm_plane.h>\n#include <drm/drm_debugfs_crc.h>\n#include <drm/drm_mode_config.h>\n\nstruct drm_connector;\nstruct drm_device;\nstruct drm_framebuffer;\nstruct drm_mode_set;\nstruct drm_file;\nstruct drm_printer;\nstruct drm_self_refresh_data;\nstruct device_node;\nstruct edid;\n\nstatic inline int64_t U642I64(uint64_t val)\n{\n\treturn (int64_t)*((int64_t *)&val);\n}\nstatic inline uint64_t I642U64(int64_t val)\n{\n\treturn (uint64_t)*((uint64_t *)&val);\n}\n\nstruct drm_crtc;\nstruct drm_pending_vblank_event;\nstruct drm_plane;\nstruct drm_bridge;\nstruct drm_atomic_state;\n\nstruct drm_crtc_helper_funcs;\nstruct drm_plane_helper_funcs;\n\n \nstruct drm_crtc_state {\n\t \n\tstruct drm_crtc *crtc;\n\n\t \n\tbool enable;\n\n\t \n\tbool active;\n\n\t \n\tbool planes_changed : 1;\n\n\t \n\tbool mode_changed : 1;\n\n\t \n\tbool active_changed : 1;\n\n\t \n\tbool connectors_changed : 1;\n\t \n\tbool zpos_changed : 1;\n\t \n\tbool color_mgmt_changed : 1;\n\n\t \n\tbool no_vblank : 1;\n\n\t \n\tu32 plane_mask;\n\n\t \n\tu32 connector_mask;\n\n\t \n\tu32 encoder_mask;\n\n\t \n\tstruct drm_display_mode adjusted_mode;\n\n\t \n\tstruct drm_display_mode mode;\n\n\t \n\tstruct drm_property_blob *mode_blob;\n\n\t \n\tstruct drm_property_blob *degamma_lut;\n\n\t \n\tstruct drm_property_blob *ctm;\n\n\t \n\tstruct drm_property_blob *gamma_lut;\n\n\t \n\tu32 target_vblank;\n\n\t \n\tbool async_flip;\n\n\t \n\tbool vrr_enabled;\n\n\t \n\tbool self_refresh_active;\n\n\t \n\tenum drm_scaling_filter scaling_filter;\n\n\t \n\tstruct drm_pending_vblank_event *event;\n\n\t \n\tstruct drm_crtc_commit *commit;\n\n\t \n\tstruct drm_atomic_state *state;\n};\n\n \nstruct drm_crtc_funcs {\n\t \n\tvoid (*reset)(struct drm_crtc *crtc);\n\n\t \n\tint (*cursor_set)(struct drm_crtc *crtc, struct drm_file *file_priv,\n\t\t\t  uint32_t handle, uint32_t width, uint32_t height);\n\n\t \n\tint (*cursor_set2)(struct drm_crtc *crtc, struct drm_file *file_priv,\n\t\t\t   uint32_t handle, uint32_t width, uint32_t height,\n\t\t\t   int32_t hot_x, int32_t hot_y);\n\n\t \n\tint (*cursor_move)(struct drm_crtc *crtc, int x, int y);\n\n\t \n\tint (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,\n\t\t\t uint32_t size,\n\t\t\t struct drm_modeset_acquire_ctx *ctx);\n\n\t \n\tvoid (*destroy)(struct drm_crtc *crtc);\n\n\t \n\tint (*set_config)(struct drm_mode_set *set,\n\t\t\t  struct drm_modeset_acquire_ctx *ctx);\n\n\t \n\tint (*page_flip)(struct drm_crtc *crtc,\n\t\t\t struct drm_framebuffer *fb,\n\t\t\t struct drm_pending_vblank_event *event,\n\t\t\t uint32_t flags,\n\t\t\t struct drm_modeset_acquire_ctx *ctx);\n\n\t \n\tint (*page_flip_target)(struct drm_crtc *crtc,\n\t\t\t\tstruct drm_framebuffer *fb,\n\t\t\t\tstruct drm_pending_vblank_event *event,\n\t\t\t\tuint32_t flags, uint32_t target,\n\t\t\t\tstruct drm_modeset_acquire_ctx *ctx);\n\n\t \n\tint (*set_property)(struct drm_crtc *crtc,\n\t\t\t    struct drm_property *property, uint64_t val);\n\n\t \n\tstruct drm_crtc_state *(*atomic_duplicate_state)(struct drm_crtc *crtc);\n\n\t \n\tvoid (*atomic_destroy_state)(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_crtc_state *state);\n\n\t \n\tint (*atomic_set_property)(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_crtc_state *state,\n\t\t\t\t   struct drm_property *property,\n\t\t\t\t   uint64_t val);\n\t \n\tint (*atomic_get_property)(struct drm_crtc *crtc,\n\t\t\t\t   const struct drm_crtc_state *state,\n\t\t\t\t   struct drm_property *property,\n\t\t\t\t   uint64_t *val);\n\n\t \n\tint (*late_register)(struct drm_crtc *crtc);\n\n\t \n\tvoid (*early_unregister)(struct drm_crtc *crtc);\n\n\t \n\tint (*set_crc_source)(struct drm_crtc *crtc, const char *source);\n\n\t \n\tint (*verify_crc_source)(struct drm_crtc *crtc, const char *source,\n\t\t\t\t size_t *values_cnt);\n\t \n\tconst char *const *(*get_crc_sources)(struct drm_crtc *crtc,\n\t\t\t\t\t      size_t *count);\n\n\t \n\tvoid (*atomic_print_state)(struct drm_printer *p,\n\t\t\t\t   const struct drm_crtc_state *state);\n\n\t \n\tu32 (*get_vblank_counter)(struct drm_crtc *crtc);\n\n\t \n\tint (*enable_vblank)(struct drm_crtc *crtc);\n\n\t \n\tvoid (*disable_vblank)(struct drm_crtc *crtc);\n\n\t \n\tbool (*get_vblank_timestamp)(struct drm_crtc *crtc,\n\t\t\t\t     int *max_error,\n\t\t\t\t     ktime_t *vblank_time,\n\t\t\t\t     bool in_vblank_irq);\n};\n\n \nstruct drm_crtc {\n\t \n\tstruct drm_device *dev;\n\t \n\tstruct device_node *port;\n\t \n\tstruct list_head head;\n\n\t \n\tchar *name;\n\n\t \n\tstruct drm_modeset_lock mutex;\n\n\t \n\tstruct drm_mode_object base;\n\n\t \n\tstruct drm_plane *primary;\n\n\t \n\tstruct drm_plane *cursor;\n\n\t \n\tunsigned index;\n\n\t \n\tint cursor_x;\n\t \n\tint cursor_y;\n\n\t \n\tbool enabled;\n\n\t \n\tstruct drm_display_mode mode;\n\n\t \n\tstruct drm_display_mode hwmode;\n\n\t \n\tint x;\n\t \n\tint y;\n\n\t \n\tconst struct drm_crtc_funcs *funcs;\n\n\t \n\tuint32_t gamma_size;\n\n\t \n\tuint16_t *gamma_store;\n\n\t \n\tconst struct drm_crtc_helper_funcs *helper_private;\n\n\t \n\tstruct drm_object_properties properties;\n\n\t \n\tstruct drm_property *scaling_filter_property;\n\n\t \n\tstruct drm_crtc_state *state;\n\n\t \n\tstruct list_head commit_list;\n\n\t \n\tspinlock_t commit_lock;\n\n\t \n\tstruct dentry *debugfs_entry;\n\n\t \n\tstruct drm_crtc_crc crc;\n\n\t \n\tunsigned int fence_context;\n\n\t \n\tspinlock_t fence_lock;\n\t \n\tunsigned long fence_seqno;\n\n\t \n\tchar timeline_name[32];\n\n\t \n\tstruct drm_self_refresh_data *self_refresh_data;\n};\n\n \nstruct drm_mode_set {\n\tstruct drm_framebuffer *fb;\n\tstruct drm_crtc *crtc;\n\tstruct drm_display_mode *mode;\n\n\tuint32_t x;\n\tuint32_t y;\n\n\tstruct drm_connector **connectors;\n\tsize_t num_connectors;\n};\n\n#define obj_to_crtc(x) container_of(x, struct drm_crtc, base)\n\n__printf(6, 7)\nint drm_crtc_init_with_planes(struct drm_device *dev,\n\t\t\t      struct drm_crtc *crtc,\n\t\t\t      struct drm_plane *primary,\n\t\t\t      struct drm_plane *cursor,\n\t\t\t      const struct drm_crtc_funcs *funcs,\n\t\t\t      const char *name, ...);\n\n__printf(6, 7)\nint drmm_crtc_init_with_planes(struct drm_device *dev,\n\t\t\t       struct drm_crtc *crtc,\n\t\t\t       struct drm_plane *primary,\n\t\t\t       struct drm_plane *cursor,\n\t\t\t       const struct drm_crtc_funcs *funcs,\n\t\t\t       const char *name, ...);\n\nvoid drm_crtc_cleanup(struct drm_crtc *crtc);\n\n__printf(7, 8)\nvoid *__drmm_crtc_alloc_with_planes(struct drm_device *dev,\n\t\t\t\t    size_t size, size_t offset,\n\t\t\t\t    struct drm_plane *primary,\n\t\t\t\t    struct drm_plane *cursor,\n\t\t\t\t    const struct drm_crtc_funcs *funcs,\n\t\t\t\t    const char *name, ...);\n\n \n#define drmm_crtc_alloc_with_planes(dev, type, member, primary, cursor, funcs, name, ...) \\\n\t((type *)__drmm_crtc_alloc_with_planes(dev, sizeof(type), \\\n\t\t\t\t\t       offsetof(type, member), \\\n\t\t\t\t\t       primary, cursor, funcs, \\\n\t\t\t\t\t       name, ##__VA_ARGS__))\n\n \nstatic inline unsigned int drm_crtc_index(const struct drm_crtc *crtc)\n{\n\treturn crtc->index;\n}\n\n \nstatic inline uint32_t drm_crtc_mask(const struct drm_crtc *crtc)\n{\n\treturn 1 << drm_crtc_index(crtc);\n}\n\nint drm_mode_set_config_internal(struct drm_mode_set *set);\nstruct drm_crtc *drm_crtc_from_index(struct drm_device *dev, int idx);\n\n \nstatic inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,\n\t\tstruct drm_file *file_priv,\n\t\tuint32_t id)\n{\n\tstruct drm_mode_object *mo;\n\tmo = drm_mode_object_find(dev, file_priv, id, DRM_MODE_OBJECT_CRTC);\n\treturn mo ? obj_to_crtc(mo) : NULL;\n}\n\n \n#define drm_for_each_crtc(crtc, dev) \\\n\tlist_for_each_entry(crtc, &(dev)->mode_config.crtc_list, head)\n\n \n#define drm_for_each_crtc_reverse(crtc, dev) \\\n\tlist_for_each_entry_reverse(crtc, &(dev)->mode_config.crtc_list, head)\n\nint drm_crtc_create_scaling_filter_property(struct drm_crtc *crtc,\n\t\t\t\t\t    unsigned int supported_filters);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}