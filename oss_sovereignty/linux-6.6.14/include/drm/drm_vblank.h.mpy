{
  "module_name": "drm_vblank.h",
  "hash_id": "726eeea5fed4795f4745af747832995dc427c9663dca6a3e849d8a09131f45b8",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_vblank.h",
  "human_readable_source": " \n\n#ifndef _DRM_VBLANK_H_\n#define _DRM_VBLANK_H_\n\n#include <linux/seqlock.h>\n#include <linux/idr.h>\n#include <linux/poll.h>\n#include <linux/kthread.h>\n\n#include <drm/drm_file.h>\n#include <drm/drm_modes.h>\n\nstruct drm_device;\nstruct drm_crtc;\nstruct drm_vblank_work;\n\n \nstruct drm_pending_vblank_event {\n\t \n\tstruct drm_pending_event base;\n\t \n\tunsigned int pipe;\n\t \n\tu64 sequence;\n\t \n\tunion {\n\t\t \n\t\tstruct drm_event base;\n\n\t\t \n\t\tstruct drm_event_vblank vbl;\n\n\t\t \n\t\tstruct drm_event_crtc_sequence seq;\n\t} event;\n};\n\n \nstruct drm_vblank_crtc {\n\t \n\tstruct drm_device *dev;\n\t \n\twait_queue_head_t queue;\n\t \n\tstruct timer_list disable_timer;\n\n\t \n\tseqlock_t seqlock;\n\n\t \n\tatomic64_t count;\n\t \n\tktime_t time;\n\n\t \n\tatomic_t refcount;\n\t \n\tu32 last;\n\t \n\tu32 max_vblank_count;\n\t \n\tunsigned int inmodeset;\n\t \n\tunsigned int pipe;\n\t \n\tint framedur_ns;\n\t \n\tint linedur_ns;\n\n\t \n\tstruct drm_display_mode hwmode;\n\n\t \n\tbool enabled;\n\n\t \n\tstruct kthread_worker *worker;\n\n\t \n\tstruct list_head pending_work;\n\n\t \n\twait_queue_head_t work_wait_queue;\n};\n\nint drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);\nbool drm_dev_has_vblank(const struct drm_device *dev);\nu64 drm_crtc_vblank_count(struct drm_crtc *crtc);\nu64 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,\n\t\t\t\t   ktime_t *vblanktime);\nint drm_crtc_next_vblank_start(struct drm_crtc *crtc, ktime_t *vblanktime);\nvoid drm_crtc_send_vblank_event(struct drm_crtc *crtc,\n\t\t\t       struct drm_pending_vblank_event *e);\nvoid drm_crtc_arm_vblank_event(struct drm_crtc *crtc,\n\t\t\t      struct drm_pending_vblank_event *e);\nvoid drm_vblank_set_event(struct drm_pending_vblank_event *e,\n\t\t\t  u64 *seq,\n\t\t\t  ktime_t *now);\nbool drm_handle_vblank(struct drm_device *dev, unsigned int pipe);\nbool drm_crtc_handle_vblank(struct drm_crtc *crtc);\nint drm_crtc_vblank_get(struct drm_crtc *crtc);\nvoid drm_crtc_vblank_put(struct drm_crtc *crtc);\nvoid drm_wait_one_vblank(struct drm_device *dev, unsigned int pipe);\nvoid drm_crtc_wait_one_vblank(struct drm_crtc *crtc);\nvoid drm_crtc_vblank_off(struct drm_crtc *crtc);\nvoid drm_crtc_vblank_reset(struct drm_crtc *crtc);\nvoid drm_crtc_vblank_on(struct drm_crtc *crtc);\nu64 drm_crtc_accurate_vblank_count(struct drm_crtc *crtc);\nvoid drm_crtc_vblank_restore(struct drm_crtc *crtc);\n\nvoid drm_calc_timestamping_constants(struct drm_crtc *crtc,\n\t\t\t\t     const struct drm_display_mode *mode);\nwait_queue_head_t *drm_crtc_vblank_waitqueue(struct drm_crtc *crtc);\nvoid drm_crtc_set_max_vblank_count(struct drm_crtc *crtc,\n\t\t\t\t   u32 max_vblank_count);\n\n \n\ntypedef bool (*drm_vblank_get_scanout_position_func)(struct drm_crtc *crtc,\n\t\t\t\t\t\t     bool in_vblank_irq,\n\t\t\t\t\t\t     int *vpos, int *hpos,\n\t\t\t\t\t\t     ktime_t *stime,\n\t\t\t\t\t\t     ktime_t *etime,\n\t\t\t\t\t\t     const struct drm_display_mode *mode);\n\nbool\ndrm_crtc_vblank_helper_get_vblank_timestamp_internal(struct drm_crtc *crtc,\n\t\t\t\t\t\t     int *max_error,\n\t\t\t\t\t\t     ktime_t *vblank_time,\n\t\t\t\t\t\t     bool in_vblank_irq,\n\t\t\t\t\t\t     drm_vblank_get_scanout_position_func get_scanout_position);\nbool drm_crtc_vblank_helper_get_vblank_timestamp(struct drm_crtc *crtc,\n\t\t\t\t\t\t int *max_error,\n\t\t\t\t\t\t ktime_t *vblank_time,\n\t\t\t\t\t\t bool in_vblank_irq);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}