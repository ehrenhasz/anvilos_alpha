{
  "module_name": "spsc_queue.h",
  "hash_id": "b21e2a892dfa328a4cf9a3e926c575a33d4abaada695e5c791ec4de52fba8132",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/spsc_queue.h",
  "human_readable_source": " \n\n#ifndef DRM_SCHEDULER_SPSC_QUEUE_H_\n#define DRM_SCHEDULER_SPSC_QUEUE_H_\n\n#include <linux/atomic.h>\n#include <linux/preempt.h>\n\n \n\nstruct spsc_node {\n\n\t \n\tstruct spsc_node *next;\n};\n\nstruct spsc_queue {\n\n\t struct spsc_node *head;\n\n\t \n\tatomic_long_t tail;\n\n\tatomic_t job_count;\n};\n\nstatic inline void spsc_queue_init(struct spsc_queue *queue)\n{\n\tqueue->head = NULL;\n\tatomic_long_set(&queue->tail, (long)&queue->head);\n\tatomic_set(&queue->job_count, 0);\n}\n\nstatic inline struct spsc_node *spsc_queue_peek(struct spsc_queue *queue)\n{\n\treturn queue->head;\n}\n\nstatic inline int spsc_queue_count(struct spsc_queue *queue)\n{\n\treturn atomic_read(&queue->job_count);\n}\n\nstatic inline bool spsc_queue_push(struct spsc_queue *queue, struct spsc_node *node)\n{\n\tstruct spsc_node **tail;\n\n\tnode->next = NULL;\n\n\tpreempt_disable();\n\n\ttail = (struct spsc_node **)atomic_long_xchg(&queue->tail, (long)&node->next);\n\tWRITE_ONCE(*tail, node);\n\tatomic_inc(&queue->job_count);\n\n\t \n\tsmp_wmb();\n\n\tpreempt_enable();\n\n\treturn tail == &queue->head;\n}\n\n\nstatic inline struct spsc_node *spsc_queue_pop(struct spsc_queue *queue)\n{\n\tstruct spsc_node *next, *node;\n\n\t \n\tsmp_rmb();\n\n\tnode = READ_ONCE(queue->head);\n\n\tif (!node)\n\t\treturn NULL;\n\n\tnext = READ_ONCE(node->next);\n\tWRITE_ONCE(queue->head, next);\n\n\tif (unlikely(!next)) {\n\t\t \n\n\t\tif (atomic_long_cmpxchg(&queue->tail,\n\t\t\t\t(long)&node->next, (long) &queue->head) != (long)&node->next) {\n\t\t\t \n\t\t\tdo {\n\t\t\t\tsmp_rmb();\n\t\t\t} while (unlikely(!(queue->head = READ_ONCE(node->next))));\n\t\t}\n\t}\n\n\tatomic_dec(&queue->job_count);\n\treturn node;\n}\n\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}