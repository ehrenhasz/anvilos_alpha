{
  "module_name": "drm_vma_manager.h",
  "hash_id": "9aa3a2f76bad3ffdb615de23dac2f4d8bcf0faa7c018ef2454be151e980f35dd",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_vma_manager.h",
  "human_readable_source": "#ifndef __DRM_VMA_MANAGER_H__\n#define __DRM_VMA_MANAGER_H__\n\n \n\n#include <drm/drm_mm.h>\n#include <linux/mm.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n \n#if BITS_PER_LONG == 64\n#define DRM_FILE_PAGE_OFFSET_START ((0xFFFFFFFFUL >> PAGE_SHIFT) + 1)\n#define DRM_FILE_PAGE_OFFSET_SIZE ((0xFFFFFFFFUL >> PAGE_SHIFT) * 256)\n#else\n#define DRM_FILE_PAGE_OFFSET_START ((0xFFFFFFFUL >> PAGE_SHIFT) + 1)\n#define DRM_FILE_PAGE_OFFSET_SIZE ((0xFFFFFFFUL >> PAGE_SHIFT) * 16)\n#endif\n\nstruct drm_file;\n\nstruct drm_vma_offset_file {\n\tstruct rb_node vm_rb;\n\tstruct drm_file *vm_tag;\n\tunsigned long vm_count;\n};\n\nstruct drm_vma_offset_node {\n\trwlock_t vm_lock;\n\tstruct drm_mm_node vm_node;\n\tstruct rb_root vm_files;\n\tvoid *driver_private;\n};\n\nstruct drm_vma_offset_manager {\n\trwlock_t vm_lock;\n\tstruct drm_mm vm_addr_space_mm;\n};\n\nvoid drm_vma_offset_manager_init(struct drm_vma_offset_manager *mgr,\n\t\t\t\t unsigned long page_offset, unsigned long size);\nvoid drm_vma_offset_manager_destroy(struct drm_vma_offset_manager *mgr);\n\nstruct drm_vma_offset_node *drm_vma_offset_lookup_locked(struct drm_vma_offset_manager *mgr,\n\t\t\t\t\t\t\t   unsigned long start,\n\t\t\t\t\t\t\t   unsigned long pages);\nint drm_vma_offset_add(struct drm_vma_offset_manager *mgr,\n\t\t       struct drm_vma_offset_node *node, unsigned long pages);\nvoid drm_vma_offset_remove(struct drm_vma_offset_manager *mgr,\n\t\t\t   struct drm_vma_offset_node *node);\n\nint drm_vma_node_allow(struct drm_vma_offset_node *node, struct drm_file *tag);\nint drm_vma_node_allow_once(struct drm_vma_offset_node *node, struct drm_file *tag);\nvoid drm_vma_node_revoke(struct drm_vma_offset_node *node,\n\t\t\t struct drm_file *tag);\nbool drm_vma_node_is_allowed(struct drm_vma_offset_node *node,\n\t\t\t     struct drm_file *tag);\n\n \nstatic inline struct drm_vma_offset_node *\ndrm_vma_offset_exact_lookup_locked(struct drm_vma_offset_manager *mgr,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long pages)\n{\n\tstruct drm_vma_offset_node *node;\n\n\tnode = drm_vma_offset_lookup_locked(mgr, start, pages);\n\treturn (node && node->vm_node.start == start) ? node : NULL;\n}\n\n \nstatic inline void drm_vma_offset_lock_lookup(struct drm_vma_offset_manager *mgr)\n{\n\tread_lock(&mgr->vm_lock);\n}\n\n \nstatic inline void drm_vma_offset_unlock_lookup(struct drm_vma_offset_manager *mgr)\n{\n\tread_unlock(&mgr->vm_lock);\n}\n\n \nstatic inline void drm_vma_node_reset(struct drm_vma_offset_node *node)\n{\n\tmemset(node, 0, sizeof(*node));\n\tnode->vm_files = RB_ROOT;\n\trwlock_init(&node->vm_lock);\n}\n\n \nstatic inline unsigned long drm_vma_node_start(const struct drm_vma_offset_node *node)\n{\n\treturn node->vm_node.start;\n}\n\n \nstatic inline unsigned long drm_vma_node_size(struct drm_vma_offset_node *node)\n{\n\treturn node->vm_node.size;\n}\n\n \nstatic inline __u64 drm_vma_node_offset_addr(struct drm_vma_offset_node *node)\n{\n\treturn ((__u64)node->vm_node.start) << PAGE_SHIFT;\n}\n\n \nstatic inline void drm_vma_node_unmap(struct drm_vma_offset_node *node,\n\t\t\t\t      struct address_space *file_mapping)\n{\n\tif (drm_mm_node_allocated(&node->vm_node))\n\t\tunmap_mapping_range(file_mapping,\n\t\t\t\t    drm_vma_node_offset_addr(node),\n\t\t\t\t    drm_vma_node_size(node) << PAGE_SHIFT, 1);\n}\n\n \nstatic inline int drm_vma_node_verify_access(struct drm_vma_offset_node *node,\n\t\t\t\t\t     struct drm_file *tag)\n{\n\treturn drm_vma_node_is_allowed(node, tag) ? 0 : -EACCES;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}