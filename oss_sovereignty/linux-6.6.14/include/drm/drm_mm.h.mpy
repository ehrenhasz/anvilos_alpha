{
  "module_name": "drm_mm.h",
  "hash_id": "85bec53d7f1d0b5018395948d92160d602ef2679c97633facf9b051043695c8e",
  "original_prompt": "Ingested from linux-6.6.14/include/drm/drm_mm.h",
  "human_readable_source": " \n \n\n#ifndef _DRM_MM_H_\n#define _DRM_MM_H_\n\n \n#include <linux/bug.h>\n#include <linux/rbtree.h>\n#include <linux/limits.h>\n#include <linux/mm_types.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#ifdef CONFIG_DRM_DEBUG_MM\n#include <linux/stackdepot.h>\n#endif\n#include <linux/types.h>\n\n#include <drm/drm_print.h>\n\n#ifdef CONFIG_DRM_DEBUG_MM\n#define DRM_MM_BUG_ON(expr) BUG_ON(expr)\n#else\n#define DRM_MM_BUG_ON(expr) BUILD_BUG_ON_INVALID(expr)\n#endif\n\n \nenum drm_mm_insert_mode {\n\t \n\tDRM_MM_INSERT_BEST = 0,\n\n\t \n\tDRM_MM_INSERT_LOW,\n\n\t \n\tDRM_MM_INSERT_HIGH,\n\n\t \n\tDRM_MM_INSERT_EVICT,\n\n\t \n\tDRM_MM_INSERT_ONCE = BIT(31),\n\n\t \n\tDRM_MM_INSERT_HIGHEST = DRM_MM_INSERT_HIGH | DRM_MM_INSERT_ONCE,\n\n\t \n\tDRM_MM_INSERT_LOWEST  = DRM_MM_INSERT_LOW | DRM_MM_INSERT_ONCE,\n};\n\n \nstruct drm_mm_node {\n\t \n\tunsigned long color;\n\t \n\tu64 start;\n\t \n\tu64 size;\n\t \n\tstruct drm_mm *mm;\n\tstruct list_head node_list;\n\tstruct list_head hole_stack;\n\tstruct rb_node rb;\n\tstruct rb_node rb_hole_size;\n\tstruct rb_node rb_hole_addr;\n\tu64 __subtree_last;\n\tu64 hole_size;\n\tu64 subtree_max_hole;\n\tunsigned long flags;\n#define DRM_MM_NODE_ALLOCATED_BIT\t0\n#define DRM_MM_NODE_SCANNED_BIT\t\t1\n#ifdef CONFIG_DRM_DEBUG_MM\n\tdepot_stack_handle_t stack;\n#endif\n};\n\n \nstruct drm_mm {\n\t \n\tvoid (*color_adjust)(const struct drm_mm_node *node,\n\t\t\t     unsigned long color,\n\t\t\t     u64 *start, u64 *end);\n\n\t \n\t \n\tstruct list_head hole_stack;\n\t \n\tstruct drm_mm_node head_node;\n\t \n\tstruct rb_root_cached interval_tree;\n\tstruct rb_root_cached holes_size;\n\tstruct rb_root holes_addr;\n\n\tunsigned long scan_active;\n};\n\n \nstruct drm_mm_scan {\n\t \n\tstruct drm_mm *mm;\n\n\tu64 size;\n\tu64 alignment;\n\tu64 remainder_mask;\n\n\tu64 range_start;\n\tu64 range_end;\n\n\tu64 hit_start;\n\tu64 hit_end;\n\n\tunsigned long color;\n\tenum drm_mm_insert_mode mode;\n};\n\n \nstatic inline bool drm_mm_node_allocated(const struct drm_mm_node *node)\n{\n\treturn test_bit(DRM_MM_NODE_ALLOCATED_BIT, &node->flags);\n}\n\n \nstatic inline bool drm_mm_initialized(const struct drm_mm *mm)\n{\n\treturn READ_ONCE(mm->hole_stack.next);\n}\n\n \nstatic inline bool drm_mm_hole_follows(const struct drm_mm_node *node)\n{\n\treturn node->hole_size;\n}\n\nstatic inline u64 __drm_mm_hole_node_start(const struct drm_mm_node *hole_node)\n{\n\treturn hole_node->start + hole_node->size;\n}\n\n \nstatic inline u64 drm_mm_hole_node_start(const struct drm_mm_node *hole_node)\n{\n\tDRM_MM_BUG_ON(!drm_mm_hole_follows(hole_node));\n\treturn __drm_mm_hole_node_start(hole_node);\n}\n\nstatic inline u64 __drm_mm_hole_node_end(const struct drm_mm_node *hole_node)\n{\n\treturn list_next_entry(hole_node, node_list)->start;\n}\n\n \nstatic inline u64 drm_mm_hole_node_end(const struct drm_mm_node *hole_node)\n{\n\treturn __drm_mm_hole_node_end(hole_node);\n}\n\n \n#define drm_mm_nodes(mm) (&(mm)->head_node.node_list)\n\n \n#define drm_mm_for_each_node(entry, mm) \\\n\tlist_for_each_entry(entry, drm_mm_nodes(mm), node_list)\n\n \n#define drm_mm_for_each_node_safe(entry, next, mm) \\\n\tlist_for_each_entry_safe(entry, next, drm_mm_nodes(mm), node_list)\n\n \n#define drm_mm_for_each_hole(pos, mm, hole_start, hole_end) \\\n\tfor (pos = list_first_entry(&(mm)->hole_stack, \\\n\t\t\t\t    typeof(*pos), hole_stack); \\\n\t     &pos->hole_stack != &(mm)->hole_stack ? \\\n\t     hole_start = drm_mm_hole_node_start(pos), \\\n\t     hole_end = hole_start + pos->hole_size, \\\n\t     1 : 0; \\\n\t     pos = list_next_entry(pos, hole_stack))\n\n \nint drm_mm_reserve_node(struct drm_mm *mm, struct drm_mm_node *node);\nint drm_mm_insert_node_in_range(struct drm_mm *mm,\n\t\t\t\tstruct drm_mm_node *node,\n\t\t\t\tu64 size,\n\t\t\t\tu64 alignment,\n\t\t\t\tunsigned long color,\n\t\t\t\tu64 start,\n\t\t\t\tu64 end,\n\t\t\t\tenum drm_mm_insert_mode mode);\n\n \nstatic inline int\ndrm_mm_insert_node_generic(struct drm_mm *mm, struct drm_mm_node *node,\n\t\t\t   u64 size, u64 alignment,\n\t\t\t   unsigned long color,\n\t\t\t   enum drm_mm_insert_mode mode)\n{\n\treturn drm_mm_insert_node_in_range(mm, node,\n\t\t\t\t\t   size, alignment, color,\n\t\t\t\t\t   0, U64_MAX, mode);\n}\n\n \nstatic inline int drm_mm_insert_node(struct drm_mm *mm,\n\t\t\t\t     struct drm_mm_node *node,\n\t\t\t\t     u64 size)\n{\n\treturn drm_mm_insert_node_generic(mm, node, size, 0, 0, 0);\n}\n\nvoid drm_mm_remove_node(struct drm_mm_node *node);\nvoid drm_mm_replace_node(struct drm_mm_node *old, struct drm_mm_node *new);\nvoid drm_mm_init(struct drm_mm *mm, u64 start, u64 size);\nvoid drm_mm_takedown(struct drm_mm *mm);\n\n \nstatic inline bool drm_mm_clean(const struct drm_mm *mm)\n{\n\treturn list_empty(drm_mm_nodes(mm));\n}\n\nstruct drm_mm_node *\n__drm_mm_interval_first(const struct drm_mm *mm, u64 start, u64 last);\n\n \n#define drm_mm_for_each_node_in_range(node__, mm__, start__, end__)\t\\\n\tfor (node__ = __drm_mm_interval_first((mm__), (start__), (end__)-1); \\\n\t     node__->start < (end__);\t\t\t\t\t\\\n\t     node__ = list_next_entry(node__, node_list))\n\nvoid drm_mm_scan_init_with_range(struct drm_mm_scan *scan,\n\t\t\t\t struct drm_mm *mm,\n\t\t\t\t u64 size, u64 alignment, unsigned long color,\n\t\t\t\t u64 start, u64 end,\n\t\t\t\t enum drm_mm_insert_mode mode);\n\n \nstatic inline void drm_mm_scan_init(struct drm_mm_scan *scan,\n\t\t\t\t    struct drm_mm *mm,\n\t\t\t\t    u64 size,\n\t\t\t\t    u64 alignment,\n\t\t\t\t    unsigned long color,\n\t\t\t\t    enum drm_mm_insert_mode mode)\n{\n\tdrm_mm_scan_init_with_range(scan, mm,\n\t\t\t\t    size, alignment, color,\n\t\t\t\t    0, U64_MAX, mode);\n}\n\nbool drm_mm_scan_add_block(struct drm_mm_scan *scan,\n\t\t\t   struct drm_mm_node *node);\nbool drm_mm_scan_remove_block(struct drm_mm_scan *scan,\n\t\t\t      struct drm_mm_node *node);\nstruct drm_mm_node *drm_mm_scan_color_evict(struct drm_mm_scan *scan);\n\nvoid drm_mm_print(const struct drm_mm *mm, struct drm_printer *p);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}