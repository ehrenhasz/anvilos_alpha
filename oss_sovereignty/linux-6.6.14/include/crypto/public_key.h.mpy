{
  "module_name": "public_key.h",
  "hash_id": "c97ce02d616f40e14835322f5ffb11da85547599c725350a79b82bc11086511d",
  "original_prompt": "Ingested from linux-6.6.14/include/crypto/public_key.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_PUBLIC_KEY_H\n#define _LINUX_PUBLIC_KEY_H\n\n#include <linux/keyctl.h>\n#include <linux/oid_registry.h>\n\n \nstruct public_key {\n\tvoid *key;\n\tu32 keylen;\n\tenum OID algo;\n\tvoid *params;\n\tu32 paramlen;\n\tbool key_is_private;\n\tconst char *id_type;\n\tconst char *pkey_algo;\n\tunsigned long key_eflags;\t \n#define KEY_EFLAG_CA\t\t0\t \n#define KEY_EFLAG_DIGITALSIG\t1\t \n#define KEY_EFLAG_KEYCERTSIGN\t2\t \n};\n\nextern void public_key_free(struct public_key *key);\n\n \nstruct public_key_signature {\n\tstruct asymmetric_key_id *auth_ids[3];\n\tu8 *s;\t\t\t \n\tu8 *digest;\n\tu32 s_size;\t\t \n\tu32 digest_size;\t \n\tconst char *pkey_algo;\n\tconst char *hash_algo;\n\tconst char *encoding;\n};\n\nextern void public_key_signature_free(struct public_key_signature *sig);\n\nextern struct asymmetric_key_subtype public_key_subtype;\n\nstruct key;\nstruct key_type;\nunion key_payload;\n\nextern int restrict_link_by_signature(struct key *dest_keyring,\n\t\t\t\t      const struct key_type *type,\n\t\t\t\t      const union key_payload *payload,\n\t\t\t\t      struct key *trust_keyring);\n\nextern int restrict_link_by_key_or_keyring(struct key *dest_keyring,\n\t\t\t\t\t   const struct key_type *type,\n\t\t\t\t\t   const union key_payload *payload,\n\t\t\t\t\t   struct key *trusted);\n\nextern int restrict_link_by_key_or_keyring_chain(struct key *trust_keyring,\n\t\t\t\t\t\t const struct key_type *type,\n\t\t\t\t\t\t const union key_payload *payload,\n\t\t\t\t\t\t struct key *trusted);\n\n#if IS_REACHABLE(CONFIG_ASYMMETRIC_KEY_TYPE)\nextern int restrict_link_by_ca(struct key *dest_keyring,\n\t\t\t       const struct key_type *type,\n\t\t\t       const union key_payload *payload,\n\t\t\t       struct key *trust_keyring);\nint restrict_link_by_digsig(struct key *dest_keyring,\n\t\t\t    const struct key_type *type,\n\t\t\t    const union key_payload *payload,\n\t\t\t    struct key *trust_keyring);\n#else\nstatic inline int restrict_link_by_ca(struct key *dest_keyring,\n\t\t\t\t      const struct key_type *type,\n\t\t\t\t      const union key_payload *payload,\n\t\t\t\t      struct key *trust_keyring)\n{\n\treturn 0;\n}\n\nstatic inline int restrict_link_by_digsig(struct key *dest_keyring,\n\t\t\t\t\t  const struct key_type *type,\n\t\t\t\t\t  const union key_payload *payload,\n\t\t\t\t\t  struct key *trust_keyring)\n{\n\treturn 0;\n}\n#endif\n\nextern int query_asymmetric_key(const struct kernel_pkey_params *,\n\t\t\t\tstruct kernel_pkey_query *);\n\nextern int encrypt_blob(struct kernel_pkey_params *, const void *, void *);\nextern int decrypt_blob(struct kernel_pkey_params *, const void *, void *);\nextern int create_signature(struct kernel_pkey_params *, const void *, void *);\nextern int verify_signature(const struct key *,\n\t\t\t    const struct public_key_signature *);\n\n#if IS_REACHABLE(CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE)\nint public_key_verify_signature(const struct public_key *pkey,\n\t\t\t\tconst struct public_key_signature *sig);\n#else\nstatic inline\nint public_key_verify_signature(const struct public_key *pkey,\n\t\t\t\tconst struct public_key_signature *sig)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}