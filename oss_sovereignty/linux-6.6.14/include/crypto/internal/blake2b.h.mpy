{
  "module_name": "blake2b.h",
  "hash_id": "d4250986010b8269114d2a557d57c1f10d7d3e56386e491f489b806ca7374ef0",
  "original_prompt": "Ingested from linux-6.6.14/include/crypto/internal/blake2b.h",
  "human_readable_source": " \n \n\n#ifndef _CRYPTO_INTERNAL_BLAKE2B_H\n#define _CRYPTO_INTERNAL_BLAKE2B_H\n\n#include <crypto/blake2b.h>\n#include <crypto/internal/hash.h>\n#include <linux/string.h>\n\nvoid blake2b_compress_generic(struct blake2b_state *state,\n\t\t\t      const u8 *block, size_t nblocks, u32 inc);\n\nstatic inline void blake2b_set_lastblock(struct blake2b_state *state)\n{\n\tstate->f[0] = -1;\n}\n\ntypedef void (*blake2b_compress_t)(struct blake2b_state *state,\n\t\t\t\t   const u8 *block, size_t nblocks, u32 inc);\n\nstatic inline void __blake2b_update(struct blake2b_state *state,\n\t\t\t\t    const u8 *in, size_t inlen,\n\t\t\t\t    blake2b_compress_t compress)\n{\n\tconst size_t fill = BLAKE2B_BLOCK_SIZE - state->buflen;\n\n\tif (unlikely(!inlen))\n\t\treturn;\n\tif (inlen > fill) {\n\t\tmemcpy(state->buf + state->buflen, in, fill);\n\t\t(*compress)(state, state->buf, 1, BLAKE2B_BLOCK_SIZE);\n\t\tstate->buflen = 0;\n\t\tin += fill;\n\t\tinlen -= fill;\n\t}\n\tif (inlen > BLAKE2B_BLOCK_SIZE) {\n\t\tconst size_t nblocks = DIV_ROUND_UP(inlen, BLAKE2B_BLOCK_SIZE);\n\t\t \n\t\t(*compress)(state, in, nblocks - 1, BLAKE2B_BLOCK_SIZE);\n\t\tin += BLAKE2B_BLOCK_SIZE * (nblocks - 1);\n\t\tinlen -= BLAKE2B_BLOCK_SIZE * (nblocks - 1);\n\t}\n\tmemcpy(state->buf + state->buflen, in, inlen);\n\tstate->buflen += inlen;\n}\n\nstatic inline void __blake2b_final(struct blake2b_state *state, u8 *out,\n\t\t\t\t   blake2b_compress_t compress)\n{\n\tint i;\n\n\tblake2b_set_lastblock(state);\n\tmemset(state->buf + state->buflen, 0,\n\t       BLAKE2B_BLOCK_SIZE - state->buflen);  \n\t(*compress)(state, state->buf, 1, state->buflen);\n\tfor (i = 0; i < ARRAY_SIZE(state->h); i++)\n\t\t__cpu_to_le64s(&state->h[i]);\n\tmemcpy(out, state->h, state->outlen);\n}\n\n \n\nstruct blake2b_tfm_ctx {\n\tu8 key[BLAKE2B_KEY_SIZE];\n\tunsigned int keylen;\n};\n\nstatic inline int crypto_blake2b_setkey(struct crypto_shash *tfm,\n\t\t\t\t\tconst u8 *key, unsigned int keylen)\n{\n\tstruct blake2b_tfm_ctx *tctx = crypto_shash_ctx(tfm);\n\n\tif (keylen == 0 || keylen > BLAKE2B_KEY_SIZE)\n\t\treturn -EINVAL;\n\n\tmemcpy(tctx->key, key, keylen);\n\ttctx->keylen = keylen;\n\n\treturn 0;\n}\n\nstatic inline int crypto_blake2b_init(struct shash_desc *desc)\n{\n\tconst struct blake2b_tfm_ctx *tctx = crypto_shash_ctx(desc->tfm);\n\tstruct blake2b_state *state = shash_desc_ctx(desc);\n\tunsigned int outlen = crypto_shash_digestsize(desc->tfm);\n\n\t__blake2b_init(state, outlen, tctx->key, tctx->keylen);\n\treturn 0;\n}\n\nstatic inline int crypto_blake2b_update(struct shash_desc *desc,\n\t\t\t\t\tconst u8 *in, unsigned int inlen,\n\t\t\t\t\tblake2b_compress_t compress)\n{\n\tstruct blake2b_state *state = shash_desc_ctx(desc);\n\n\t__blake2b_update(state, in, inlen, compress);\n\treturn 0;\n}\n\nstatic inline int crypto_blake2b_final(struct shash_desc *desc, u8 *out,\n\t\t\t\t       blake2b_compress_t compress)\n{\n\tstruct blake2b_state *state = shash_desc_ctx(desc);\n\n\t__blake2b_final(state, out, compress);\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}