{
  "module_name": "sha1_base.h",
  "hash_id": "6c3ab0d1b52c654ef525cda4d3dd61d05d95f721e422fe75cca33d8ec9bc7209",
  "original_prompt": "Ingested from linux-6.6.14/include/crypto/sha1_base.h",
  "human_readable_source": " \n \n\n#ifndef _CRYPTO_SHA1_BASE_H\n#define _CRYPTO_SHA1_BASE_H\n\n#include <crypto/internal/hash.h>\n#include <crypto/sha1.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\n#include <asm/unaligned.h>\n\ntypedef void (sha1_block_fn)(struct sha1_state *sst, u8 const *src, int blocks);\n\nstatic inline int sha1_base_init(struct shash_desc *desc)\n{\n\tstruct sha1_state *sctx = shash_desc_ctx(desc);\n\n\tsctx->state[0] = SHA1_H0;\n\tsctx->state[1] = SHA1_H1;\n\tsctx->state[2] = SHA1_H2;\n\tsctx->state[3] = SHA1_H3;\n\tsctx->state[4] = SHA1_H4;\n\tsctx->count = 0;\n\n\treturn 0;\n}\n\nstatic inline int sha1_base_do_update(struct shash_desc *desc,\n\t\t\t\t      const u8 *data,\n\t\t\t\t      unsigned int len,\n\t\t\t\t      sha1_block_fn *block_fn)\n{\n\tstruct sha1_state *sctx = shash_desc_ctx(desc);\n\tunsigned int partial = sctx->count % SHA1_BLOCK_SIZE;\n\n\tsctx->count += len;\n\n\tif (unlikely((partial + len) >= SHA1_BLOCK_SIZE)) {\n\t\tint blocks;\n\n\t\tif (partial) {\n\t\t\tint p = SHA1_BLOCK_SIZE - partial;\n\n\t\t\tmemcpy(sctx->buffer + partial, data, p);\n\t\t\tdata += p;\n\t\t\tlen -= p;\n\n\t\t\tblock_fn(sctx, sctx->buffer, 1);\n\t\t}\n\n\t\tblocks = len / SHA1_BLOCK_SIZE;\n\t\tlen %= SHA1_BLOCK_SIZE;\n\n\t\tif (blocks) {\n\t\t\tblock_fn(sctx, data, blocks);\n\t\t\tdata += blocks * SHA1_BLOCK_SIZE;\n\t\t}\n\t\tpartial = 0;\n\t}\n\tif (len)\n\t\tmemcpy(sctx->buffer + partial, data, len);\n\n\treturn 0;\n}\n\nstatic inline int sha1_base_do_finalize(struct shash_desc *desc,\n\t\t\t\t\tsha1_block_fn *block_fn)\n{\n\tconst int bit_offset = SHA1_BLOCK_SIZE - sizeof(__be64);\n\tstruct sha1_state *sctx = shash_desc_ctx(desc);\n\t__be64 *bits = (__be64 *)(sctx->buffer + bit_offset);\n\tunsigned int partial = sctx->count % SHA1_BLOCK_SIZE;\n\n\tsctx->buffer[partial++] = 0x80;\n\tif (partial > bit_offset) {\n\t\tmemset(sctx->buffer + partial, 0x0, SHA1_BLOCK_SIZE - partial);\n\t\tpartial = 0;\n\n\t\tblock_fn(sctx, sctx->buffer, 1);\n\t}\n\n\tmemset(sctx->buffer + partial, 0x0, bit_offset - partial);\n\t*bits = cpu_to_be64(sctx->count << 3);\n\tblock_fn(sctx, sctx->buffer, 1);\n\n\treturn 0;\n}\n\nstatic inline int sha1_base_finish(struct shash_desc *desc, u8 *out)\n{\n\tstruct sha1_state *sctx = shash_desc_ctx(desc);\n\t__be32 *digest = (__be32 *)out;\n\tint i;\n\n\tfor (i = 0; i < SHA1_DIGEST_SIZE / sizeof(__be32); i++)\n\t\tput_unaligned_be32(sctx->state[i], digest++);\n\n\tmemzero_explicit(sctx, sizeof(*sctx));\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}