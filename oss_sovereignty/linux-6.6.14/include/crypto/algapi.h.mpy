{
  "module_name": "algapi.h",
  "hash_id": "8491d8c817d1173fc4f1b35aefb8f2fd47478b981cf7fb97bc1079dcc2a5ed88",
  "original_prompt": "Ingested from linux-6.6.14/include/crypto/algapi.h",
  "human_readable_source": " \n \n#ifndef _CRYPTO_ALGAPI_H\n#define _CRYPTO_ALGAPI_H\n\n#include <crypto/utils.h>\n#include <linux/align.h>\n#include <linux/cache.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n \n#define MAX_ALGAPI_BLOCKSIZE\t\t160\n#define MAX_ALGAPI_ALIGNMASK\t\t127\n#define MAX_CIPHER_BLOCKSIZE\t\t16\n#define MAX_CIPHER_ALIGNMASK\t\t15\n\n#ifdef ARCH_DMA_MINALIGN\n#define CRYPTO_DMA_ALIGN ARCH_DMA_MINALIGN\n#else\n#define CRYPTO_DMA_ALIGN CRYPTO_MINALIGN\n#endif\n\n#define CRYPTO_DMA_PADDING ((CRYPTO_DMA_ALIGN - 1) & ~(CRYPTO_MINALIGN - 1))\n\n \n#define MODULE_ALIAS_CRYPTO(name)\t\\\n\t\t__MODULE_INFO(alias, alias_userspace, name);\t\\\n\t\t__MODULE_INFO(alias, alias_crypto, \"crypto-\" name)\n\nstruct crypto_aead;\nstruct crypto_instance;\nstruct module;\nstruct notifier_block;\nstruct rtattr;\nstruct scatterlist;\nstruct seq_file;\nstruct sk_buff;\n\nstruct crypto_type {\n\tunsigned int (*ctxsize)(struct crypto_alg *alg, u32 type, u32 mask);\n\tunsigned int (*extsize)(struct crypto_alg *alg);\n\tint (*init_tfm)(struct crypto_tfm *tfm);\n\tvoid (*show)(struct seq_file *m, struct crypto_alg *alg);\n\tint (*report)(struct sk_buff *skb, struct crypto_alg *alg);\n\tvoid (*free)(struct crypto_instance *inst);\n#ifdef CONFIG_CRYPTO_STATS\n\tint (*report_stat)(struct sk_buff *skb, struct crypto_alg *alg);\n#endif\n\n\tunsigned int type;\n\tunsigned int maskclear;\n\tunsigned int maskset;\n\tunsigned int tfmsize;\n};\n\nstruct crypto_instance {\n\tstruct crypto_alg alg;\n\n\tstruct crypto_template *tmpl;\n\n\tunion {\n\t\t \n\t\tstruct hlist_node list;\n\t\t \n\t\tstruct crypto_spawn *spawns;\n\t};\n\n\tstruct work_struct free_work;\n\n\tvoid *__ctx[] CRYPTO_MINALIGN_ATTR;\n};\n\nstruct crypto_template {\n\tstruct list_head list;\n\tstruct hlist_head instances;\n\tstruct module *module;\n\n\tint (*create)(struct crypto_template *tmpl, struct rtattr **tb);\n\n\tchar name[CRYPTO_MAX_ALG_NAME];\n};\n\nstruct crypto_spawn {\n\tstruct list_head list;\n\tstruct crypto_alg *alg;\n\tunion {\n\t\t \n\t\tstruct crypto_instance *inst;\n\t\t \n\t\tstruct crypto_spawn *next;\n\t};\n\tconst struct crypto_type *frontend;\n\tu32 mask;\n\tbool dead;\n\tbool registered;\n};\n\nstruct crypto_queue {\n\tstruct list_head list;\n\tstruct list_head *backlog;\n\n\tunsigned int qlen;\n\tunsigned int max_qlen;\n};\n\nstruct scatter_walk {\n\tstruct scatterlist *sg;\n\tunsigned int offset;\n};\n\nstruct crypto_attr_alg {\n\tchar name[CRYPTO_MAX_ALG_NAME];\n};\n\nstruct crypto_attr_type {\n\tu32 type;\n\tu32 mask;\n};\n\n \nint crypto_register_alg(struct crypto_alg *alg);\nvoid crypto_unregister_alg(struct crypto_alg *alg);\nint crypto_register_algs(struct crypto_alg *algs, int count);\nvoid crypto_unregister_algs(struct crypto_alg *algs, int count);\n\nvoid crypto_mod_put(struct crypto_alg *alg);\n\nint crypto_register_template(struct crypto_template *tmpl);\nint crypto_register_templates(struct crypto_template *tmpls, int count);\nvoid crypto_unregister_template(struct crypto_template *tmpl);\nvoid crypto_unregister_templates(struct crypto_template *tmpls, int count);\nstruct crypto_template *crypto_lookup_template(const char *name);\n\nint crypto_register_instance(struct crypto_template *tmpl,\n\t\t\t     struct crypto_instance *inst);\nvoid crypto_unregister_instance(struct crypto_instance *inst);\n\nint crypto_grab_spawn(struct crypto_spawn *spawn, struct crypto_instance *inst,\n\t\t      const char *name, u32 type, u32 mask);\nvoid crypto_drop_spawn(struct crypto_spawn *spawn);\nstruct crypto_tfm *crypto_spawn_tfm(struct crypto_spawn *spawn, u32 type,\n\t\t\t\t    u32 mask);\nvoid *crypto_spawn_tfm2(struct crypto_spawn *spawn);\n\nstruct crypto_attr_type *crypto_get_attr_type(struct rtattr **tb);\nint crypto_check_attr_type(struct rtattr **tb, u32 type, u32 *mask_ret);\nconst char *crypto_attr_alg_name(struct rtattr *rta);\nint crypto_inst_setname(struct crypto_instance *inst, const char *name,\n\t\t\tstruct crypto_alg *alg);\n\nvoid crypto_init_queue(struct crypto_queue *queue, unsigned int max_qlen);\nint crypto_enqueue_request(struct crypto_queue *queue,\n\t\t\t   struct crypto_async_request *request);\nvoid crypto_enqueue_request_head(struct crypto_queue *queue,\n\t\t\t\t struct crypto_async_request *request);\nstruct crypto_async_request *crypto_dequeue_request(struct crypto_queue *queue);\nstatic inline unsigned int crypto_queue_len(struct crypto_queue *queue)\n{\n\treturn queue->qlen;\n}\n\nvoid crypto_inc(u8 *a, unsigned int size);\n\nstatic inline void *crypto_tfm_ctx(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_ctx;\n}\n\nstatic inline void *crypto_tfm_ctx_align(struct crypto_tfm *tfm,\n\t\t\t\t\t unsigned int align)\n{\n\tif (align <= crypto_tfm_ctx_alignment())\n\t\talign = 1;\n\n\treturn PTR_ALIGN(crypto_tfm_ctx(tfm), align);\n}\n\nstatic inline void *crypto_tfm_ctx_aligned(struct crypto_tfm *tfm)\n{\n\treturn crypto_tfm_ctx_align(tfm, crypto_tfm_alg_alignmask(tfm) + 1);\n}\n\nstatic inline unsigned int crypto_dma_align(void)\n{\n\treturn CRYPTO_DMA_ALIGN;\n}\n\nstatic inline unsigned int crypto_dma_padding(void)\n{\n\treturn (crypto_dma_align() - 1) & ~(crypto_tfm_ctx_alignment() - 1);\n}\n\nstatic inline void *crypto_tfm_ctx_dma(struct crypto_tfm *tfm)\n{\n\treturn crypto_tfm_ctx_align(tfm, crypto_dma_align());\n}\n\nstatic inline struct crypto_instance *crypto_tfm_alg_instance(\n\tstruct crypto_tfm *tfm)\n{\n\treturn container_of(tfm->__crt_alg, struct crypto_instance, alg);\n}\n\nstatic inline void *crypto_instance_ctx(struct crypto_instance *inst)\n{\n\treturn inst->__ctx;\n}\n\nstatic inline struct crypto_async_request *crypto_get_backlog(\n\tstruct crypto_queue *queue)\n{\n\treturn queue->backlog == &queue->list ? NULL :\n\t       container_of(queue->backlog, struct crypto_async_request, list);\n}\n\nstatic inline u32 crypto_requires_off(struct crypto_attr_type *algt, u32 off)\n{\n\treturn (algt->type ^ off) & algt->mask & off;\n}\n\n \n#define CRYPTO_ALG_INHERITED_FLAGS\t\\\n\t(CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK |\t\\\n\t CRYPTO_ALG_ALLOCATES_MEMORY)\n\n \nstatic inline u32 crypto_algt_inherited_mask(struct crypto_attr_type *algt)\n{\n\treturn crypto_requires_off(algt, CRYPTO_ALG_INHERITED_FLAGS);\n}\n\nint crypto_register_notifier(struct notifier_block *nb);\nint crypto_unregister_notifier(struct notifier_block *nb);\n\n \nenum {\n\tCRYPTO_MSG_ALG_REQUEST,\n\tCRYPTO_MSG_ALG_REGISTER,\n\tCRYPTO_MSG_ALG_LOADED,\n};\n\nstatic inline void crypto_request_complete(struct crypto_async_request *req,\n\t\t\t\t\t   int err)\n{\n\treq->complete(req->data, err);\n}\n\nstatic inline u32 crypto_tfm_alg_type(struct crypto_tfm *tfm)\n{\n\treturn tfm->__crt_alg->cra_flags & CRYPTO_ALG_TYPE_MASK;\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}