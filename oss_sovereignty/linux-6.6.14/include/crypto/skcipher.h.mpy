{
  "module_name": "skcipher.h",
  "hash_id": "4700af90debfbfb84e6321f8d6408052dbedb7cf0ec2eae6da393d75a7206d6a",
  "original_prompt": "Ingested from linux-6.6.14/include/crypto/skcipher.h",
  "human_readable_source": " \n \n\n#ifndef _CRYPTO_SKCIPHER_H\n#define _CRYPTO_SKCIPHER_H\n\n#include <linux/atomic.h>\n#include <linux/container_of.h>\n#include <linux/crypto.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct scatterlist;\n\n \nstruct skcipher_request {\n\tunsigned int cryptlen;\n\n\tu8 *iv;\n\n\tstruct scatterlist *src;\n\tstruct scatterlist *dst;\n\n\tstruct crypto_async_request base;\n\n\tvoid *__ctx[] CRYPTO_MINALIGN_ATTR;\n};\n\nstruct crypto_skcipher {\n\tunsigned int reqsize;\n\n\tstruct crypto_tfm base;\n};\n\nstruct crypto_sync_skcipher {\n\tstruct crypto_skcipher base;\n};\n\n \nstruct crypto_istat_cipher {\n\tatomic64_t encrypt_cnt;\n\tatomic64_t encrypt_tlen;\n\tatomic64_t decrypt_cnt;\n\tatomic64_t decrypt_tlen;\n\tatomic64_t err_cnt;\n};\n\n \nstruct skcipher_alg {\n\tint (*setkey)(struct crypto_skcipher *tfm, const u8 *key,\n\t              unsigned int keylen);\n\tint (*encrypt)(struct skcipher_request *req);\n\tint (*decrypt)(struct skcipher_request *req);\n\tint (*init)(struct crypto_skcipher *tfm);\n\tvoid (*exit)(struct crypto_skcipher *tfm);\n\n\tunsigned int min_keysize;\n\tunsigned int max_keysize;\n\tunsigned int ivsize;\n\tunsigned int chunksize;\n\tunsigned int walksize;\n\n#ifdef CONFIG_CRYPTO_STATS\n\tstruct crypto_istat_cipher stat;\n#endif\n\n\tstruct crypto_alg base;\n};\n\n#define MAX_SYNC_SKCIPHER_REQSIZE      384\n \n#define SYNC_SKCIPHER_REQUEST_ON_STACK(name, tfm) \\\n\tchar __##name##_desc[sizeof(struct skcipher_request) + \\\n\t\t\t     MAX_SYNC_SKCIPHER_REQSIZE + \\\n\t\t\t     (!(sizeof((struct crypto_sync_skcipher *)1 == \\\n\t\t\t\t       (typeof(tfm))1))) \\\n\t\t\t    ] CRYPTO_MINALIGN_ATTR; \\\n\tstruct skcipher_request *name = (void *)__##name##_desc\n\n \n\nstatic inline struct crypto_skcipher *__crypto_skcipher_cast(\n\tstruct crypto_tfm *tfm)\n{\n\treturn container_of(tfm, struct crypto_skcipher, base);\n}\n\n \nstruct crypto_skcipher *crypto_alloc_skcipher(const char *alg_name,\n\t\t\t\t\t      u32 type, u32 mask);\n\nstruct crypto_sync_skcipher *crypto_alloc_sync_skcipher(const char *alg_name,\n\t\t\t\t\t      u32 type, u32 mask);\n\nstatic inline struct crypto_tfm *crypto_skcipher_tfm(\n\tstruct crypto_skcipher *tfm)\n{\n\treturn &tfm->base;\n}\n\n \nstatic inline void crypto_free_skcipher(struct crypto_skcipher *tfm)\n{\n\tcrypto_destroy_tfm(tfm, crypto_skcipher_tfm(tfm));\n}\n\nstatic inline void crypto_free_sync_skcipher(struct crypto_sync_skcipher *tfm)\n{\n\tcrypto_free_skcipher(&tfm->base);\n}\n\n \nint crypto_has_skcipher(const char *alg_name, u32 type, u32 mask);\n\nstatic inline const char *crypto_skcipher_driver_name(\n\tstruct crypto_skcipher *tfm)\n{\n\treturn crypto_tfm_alg_driver_name(crypto_skcipher_tfm(tfm));\n}\n\nstatic inline struct skcipher_alg *crypto_skcipher_alg(\n\tstruct crypto_skcipher *tfm)\n{\n\treturn container_of(crypto_skcipher_tfm(tfm)->__crt_alg,\n\t\t\t    struct skcipher_alg, base);\n}\n\nstatic inline unsigned int crypto_skcipher_alg_ivsize(struct skcipher_alg *alg)\n{\n\treturn alg->ivsize;\n}\n\n \nstatic inline unsigned int crypto_skcipher_ivsize(struct crypto_skcipher *tfm)\n{\n\treturn crypto_skcipher_alg(tfm)->ivsize;\n}\n\nstatic inline unsigned int crypto_sync_skcipher_ivsize(\n\tstruct crypto_sync_skcipher *tfm)\n{\n\treturn crypto_skcipher_ivsize(&tfm->base);\n}\n\n \nstatic inline unsigned int crypto_skcipher_blocksize(\n\tstruct crypto_skcipher *tfm)\n{\n\treturn crypto_tfm_alg_blocksize(crypto_skcipher_tfm(tfm));\n}\n\nstatic inline unsigned int crypto_skcipher_alg_chunksize(\n\tstruct skcipher_alg *alg)\n{\n\treturn alg->chunksize;\n}\n\n \nstatic inline unsigned int crypto_skcipher_chunksize(\n\tstruct crypto_skcipher *tfm)\n{\n\treturn crypto_skcipher_alg_chunksize(crypto_skcipher_alg(tfm));\n}\n\nstatic inline unsigned int crypto_sync_skcipher_blocksize(\n\tstruct crypto_sync_skcipher *tfm)\n{\n\treturn crypto_skcipher_blocksize(&tfm->base);\n}\n\nstatic inline unsigned int crypto_skcipher_alignmask(\n\tstruct crypto_skcipher *tfm)\n{\n\treturn crypto_tfm_alg_alignmask(crypto_skcipher_tfm(tfm));\n}\n\nstatic inline u32 crypto_skcipher_get_flags(struct crypto_skcipher *tfm)\n{\n\treturn crypto_tfm_get_flags(crypto_skcipher_tfm(tfm));\n}\n\nstatic inline void crypto_skcipher_set_flags(struct crypto_skcipher *tfm,\n\t\t\t\t\t       u32 flags)\n{\n\tcrypto_tfm_set_flags(crypto_skcipher_tfm(tfm), flags);\n}\n\nstatic inline void crypto_skcipher_clear_flags(struct crypto_skcipher *tfm,\n\t\t\t\t\t\t u32 flags)\n{\n\tcrypto_tfm_clear_flags(crypto_skcipher_tfm(tfm), flags);\n}\n\nstatic inline u32 crypto_sync_skcipher_get_flags(\n\tstruct crypto_sync_skcipher *tfm)\n{\n\treturn crypto_skcipher_get_flags(&tfm->base);\n}\n\nstatic inline void crypto_sync_skcipher_set_flags(\n\tstruct crypto_sync_skcipher *tfm, u32 flags)\n{\n\tcrypto_skcipher_set_flags(&tfm->base, flags);\n}\n\nstatic inline void crypto_sync_skcipher_clear_flags(\n\tstruct crypto_sync_skcipher *tfm, u32 flags)\n{\n\tcrypto_skcipher_clear_flags(&tfm->base, flags);\n}\n\n \nint crypto_skcipher_setkey(struct crypto_skcipher *tfm,\n\t\t\t   const u8 *key, unsigned int keylen);\n\nstatic inline int crypto_sync_skcipher_setkey(struct crypto_sync_skcipher *tfm,\n\t\t\t\t\t const u8 *key, unsigned int keylen)\n{\n\treturn crypto_skcipher_setkey(&tfm->base, key, keylen);\n}\n\nstatic inline unsigned int crypto_skcipher_min_keysize(\n\tstruct crypto_skcipher *tfm)\n{\n\treturn crypto_skcipher_alg(tfm)->min_keysize;\n}\n\nstatic inline unsigned int crypto_skcipher_max_keysize(\n\tstruct crypto_skcipher *tfm)\n{\n\treturn crypto_skcipher_alg(tfm)->max_keysize;\n}\n\n \nstatic inline struct crypto_skcipher *crypto_skcipher_reqtfm(\n\tstruct skcipher_request *req)\n{\n\treturn __crypto_skcipher_cast(req->base.tfm);\n}\n\nstatic inline struct crypto_sync_skcipher *crypto_sync_skcipher_reqtfm(\n\tstruct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\n\treturn container_of(tfm, struct crypto_sync_skcipher, base);\n}\n\n \nint crypto_skcipher_encrypt(struct skcipher_request *req);\n\n \nint crypto_skcipher_decrypt(struct skcipher_request *req);\n\n \n\n \nstatic inline unsigned int crypto_skcipher_reqsize(struct crypto_skcipher *tfm)\n{\n\treturn tfm->reqsize;\n}\n\n \nstatic inline void skcipher_request_set_tfm(struct skcipher_request *req,\n\t\t\t\t\t    struct crypto_skcipher *tfm)\n{\n\treq->base.tfm = crypto_skcipher_tfm(tfm);\n}\n\nstatic inline void skcipher_request_set_sync_tfm(struct skcipher_request *req,\n\t\t\t\t\t    struct crypto_sync_skcipher *tfm)\n{\n\tskcipher_request_set_tfm(req, &tfm->base);\n}\n\nstatic inline struct skcipher_request *skcipher_request_cast(\n\tstruct crypto_async_request *req)\n{\n\treturn container_of(req, struct skcipher_request, base);\n}\n\n \nstatic inline struct skcipher_request *skcipher_request_alloc(\n\tstruct crypto_skcipher *tfm, gfp_t gfp)\n{\n\tstruct skcipher_request *req;\n\n\treq = kmalloc(sizeof(struct skcipher_request) +\n\t\t      crypto_skcipher_reqsize(tfm), gfp);\n\n\tif (likely(req))\n\t\tskcipher_request_set_tfm(req, tfm);\n\n\treturn req;\n}\n\n \nstatic inline void skcipher_request_free(struct skcipher_request *req)\n{\n\tkfree_sensitive(req);\n}\n\nstatic inline void skcipher_request_zero(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\n\tmemzero_explicit(req, sizeof(*req) + crypto_skcipher_reqsize(tfm));\n}\n\n \nstatic inline void skcipher_request_set_callback(struct skcipher_request *req,\n\t\t\t\t\t\t u32 flags,\n\t\t\t\t\t\t crypto_completion_t compl,\n\t\t\t\t\t\t void *data)\n{\n\treq->base.complete = compl;\n\treq->base.data = data;\n\treq->base.flags = flags;\n}\n\n \nstatic inline void skcipher_request_set_crypt(\n\tstruct skcipher_request *req,\n\tstruct scatterlist *src, struct scatterlist *dst,\n\tunsigned int cryptlen, void *iv)\n{\n\treq->src = src;\n\treq->dst = dst;\n\treq->cryptlen = cryptlen;\n\treq->iv = iv;\n}\n\n#endif\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}