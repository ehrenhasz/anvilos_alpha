{
  "module_name": "scatterwalk.h",
  "hash_id": "eeef46a6d9646a4993c0c42186b9eaeebfd5830ab04c208f6f25151ad61dc042",
  "original_prompt": "Ingested from linux-6.6.14/include/crypto/scatterwalk.h",
  "human_readable_source": " \n \n\n#ifndef _CRYPTO_SCATTERWALK_H\n#define _CRYPTO_SCATTERWALK_H\n\n#include <crypto/algapi.h>\n\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/scatterlist.h>\n\nstatic inline void scatterwalk_crypto_chain(struct scatterlist *head,\n\t\t\t\t\t    struct scatterlist *sg, int num)\n{\n\tif (sg)\n\t\tsg_chain(head, num, sg);\n\telse\n\t\tsg_mark_end(head);\n}\n\nstatic inline unsigned int scatterwalk_pagelen(struct scatter_walk *walk)\n{\n\tunsigned int len = walk->sg->offset + walk->sg->length - walk->offset;\n\tunsigned int len_this_page = offset_in_page(~walk->offset) + 1;\n\treturn len_this_page > len ? len : len_this_page;\n}\n\nstatic inline unsigned int scatterwalk_clamp(struct scatter_walk *walk,\n\t\t\t\t\t     unsigned int nbytes)\n{\n\tunsigned int len_this_page = scatterwalk_pagelen(walk);\n\treturn nbytes > len_this_page ? len_this_page : nbytes;\n}\n\nstatic inline void scatterwalk_advance(struct scatter_walk *walk,\n\t\t\t\t       unsigned int nbytes)\n{\n\twalk->offset += nbytes;\n}\n\nstatic inline struct page *scatterwalk_page(struct scatter_walk *walk)\n{\n\treturn sg_page(walk->sg) + (walk->offset >> PAGE_SHIFT);\n}\n\nstatic inline void scatterwalk_unmap(void *vaddr)\n{\n\tkunmap_local(vaddr);\n}\n\nstatic inline void scatterwalk_start(struct scatter_walk *walk,\n\t\t\t\t     struct scatterlist *sg)\n{\n\twalk->sg = sg;\n\twalk->offset = sg->offset;\n}\n\nstatic inline void *scatterwalk_map(struct scatter_walk *walk)\n{\n\treturn kmap_local_page(scatterwalk_page(walk)) +\n\t       offset_in_page(walk->offset);\n}\n\nstatic inline void scatterwalk_pagedone(struct scatter_walk *walk, int out,\n\t\t\t\t\tunsigned int more)\n{\n\tif (out) {\n\t\tstruct page *page;\n\n\t\tpage = sg_page(walk->sg) + ((walk->offset - 1) >> PAGE_SHIFT);\n\t\tflush_dcache_page(page);\n\t}\n\n\tif (more && walk->offset >= walk->sg->offset + walk->sg->length)\n\t\tscatterwalk_start(walk, sg_next(walk->sg));\n}\n\nstatic inline void scatterwalk_done(struct scatter_walk *walk, int out,\n\t\t\t\t    int more)\n{\n\tif (!more || walk->offset >= walk->sg->offset + walk->sg->length ||\n\t    !(walk->offset & (PAGE_SIZE - 1)))\n\t\tscatterwalk_pagedone(walk, out, more);\n}\n\nvoid scatterwalk_copychunks(void *buf, struct scatter_walk *walk,\n\t\t\t    size_t nbytes, int out);\n\nvoid scatterwalk_map_and_copy(void *buf, struct scatterlist *sg,\n\t\t\t      unsigned int start, unsigned int nbytes, int out);\n\nstruct scatterlist *scatterwalk_ffwd(struct scatterlist dst[2],\n\t\t\t\t     struct scatterlist *src,\n\t\t\t\t     unsigned int len);\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}