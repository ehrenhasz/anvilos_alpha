{
  "module_name": "sha256_base.h",
  "hash_id": "9c52fcb1529b1a55f16b7ca54440e0a5c6339e2ce34c1ec915dc1f5d495c7fff",
  "original_prompt": "Ingested from linux-6.6.14/include/crypto/sha256_base.h",
  "human_readable_source": " \n \n\n#ifndef _CRYPTO_SHA256_BASE_H\n#define _CRYPTO_SHA256_BASE_H\n\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <crypto/internal/hash.h>\n#include <crypto/sha2.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\ntypedef void (sha256_block_fn)(struct sha256_state *sst, u8 const *src,\n\t\t\t       int blocks);\n\nstatic inline int sha224_base_init(struct shash_desc *desc)\n{\n\tstruct sha256_state *sctx = shash_desc_ctx(desc);\n\n\tsha224_init(sctx);\n\treturn 0;\n}\n\nstatic inline int sha256_base_init(struct shash_desc *desc)\n{\n\tstruct sha256_state *sctx = shash_desc_ctx(desc);\n\n\tsha256_init(sctx);\n\treturn 0;\n}\n\nstatic inline int lib_sha256_base_do_update(struct sha256_state *sctx,\n\t\t\t\t\t    const u8 *data,\n\t\t\t\t\t    unsigned int len,\n\t\t\t\t\t    sha256_block_fn *block_fn)\n{\n\tunsigned int partial = sctx->count % SHA256_BLOCK_SIZE;\n\n\tsctx->count += len;\n\n\tif (unlikely((partial + len) >= SHA256_BLOCK_SIZE)) {\n\t\tint blocks;\n\n\t\tif (partial) {\n\t\t\tint p = SHA256_BLOCK_SIZE - partial;\n\n\t\t\tmemcpy(sctx->buf + partial, data, p);\n\t\t\tdata += p;\n\t\t\tlen -= p;\n\n\t\t\tblock_fn(sctx, sctx->buf, 1);\n\t\t}\n\n\t\tblocks = len / SHA256_BLOCK_SIZE;\n\t\tlen %= SHA256_BLOCK_SIZE;\n\n\t\tif (blocks) {\n\t\t\tblock_fn(sctx, data, blocks);\n\t\t\tdata += blocks * SHA256_BLOCK_SIZE;\n\t\t}\n\t\tpartial = 0;\n\t}\n\tif (len)\n\t\tmemcpy(sctx->buf + partial, data, len);\n\n\treturn 0;\n}\n\nstatic inline int sha256_base_do_update(struct shash_desc *desc,\n\t\t\t\t\tconst u8 *data,\n\t\t\t\t\tunsigned int len,\n\t\t\t\t\tsha256_block_fn *block_fn)\n{\n\tstruct sha256_state *sctx = shash_desc_ctx(desc);\n\n\treturn lib_sha256_base_do_update(sctx, data, len, block_fn);\n}\n\nstatic inline int lib_sha256_base_do_finalize(struct sha256_state *sctx,\n\t\t\t\t\t      sha256_block_fn *block_fn)\n{\n\tconst int bit_offset = SHA256_BLOCK_SIZE - sizeof(__be64);\n\t__be64 *bits = (__be64 *)(sctx->buf + bit_offset);\n\tunsigned int partial = sctx->count % SHA256_BLOCK_SIZE;\n\n\tsctx->buf[partial++] = 0x80;\n\tif (partial > bit_offset) {\n\t\tmemset(sctx->buf + partial, 0x0, SHA256_BLOCK_SIZE - partial);\n\t\tpartial = 0;\n\n\t\tblock_fn(sctx, sctx->buf, 1);\n\t}\n\n\tmemset(sctx->buf + partial, 0x0, bit_offset - partial);\n\t*bits = cpu_to_be64(sctx->count << 3);\n\tblock_fn(sctx, sctx->buf, 1);\n\n\treturn 0;\n}\n\nstatic inline int sha256_base_do_finalize(struct shash_desc *desc,\n\t\t\t\t\t  sha256_block_fn *block_fn)\n{\n\tstruct sha256_state *sctx = shash_desc_ctx(desc);\n\n\treturn lib_sha256_base_do_finalize(sctx, block_fn);\n}\n\nstatic inline int lib_sha256_base_finish(struct sha256_state *sctx, u8 *out,\n\t\t\t\t\t unsigned int digest_size)\n{\n\t__be32 *digest = (__be32 *)out;\n\tint i;\n\n\tfor (i = 0; digest_size > 0; i++, digest_size -= sizeof(__be32))\n\t\tput_unaligned_be32(sctx->state[i], digest++);\n\n\tmemzero_explicit(sctx, sizeof(*sctx));\n\treturn 0;\n}\n\nstatic inline int sha256_base_finish(struct shash_desc *desc, u8 *out)\n{\n\tunsigned int digest_size = crypto_shash_digestsize(desc->tfm);\n\tstruct sha256_state *sctx = shash_desc_ctx(desc);\n\n\treturn lib_sha256_base_finish(sctx, out, digest_size);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}