{
  "module_name": "ctr.h",
  "hash_id": "ef7354b2691dc87e6655e0c70805a6e9ebde06efc0131d6ac50c67cfeead7f6b",
  "original_prompt": "Ingested from linux-6.6.14/include/crypto/ctr.h",
  "human_readable_source": " \n \n\n#ifndef _CRYPTO_CTR_H\n#define _CRYPTO_CTR_H\n\n#include <crypto/algapi.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#define CTR_RFC3686_NONCE_SIZE 4\n#define CTR_RFC3686_IV_SIZE 8\n#define CTR_RFC3686_BLOCK_SIZE 16\n\nstatic inline int crypto_ctr_encrypt_walk(struct skcipher_request *req,\n\t\t\t\t\t  void (*fn)(struct crypto_skcipher *,\n\t\t\t\t\t\t     const u8 *, u8 *))\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tint blocksize = crypto_skcipher_chunksize(tfm);\n\tu8 buf[MAX_CIPHER_BLOCKSIZE];\n\tstruct skcipher_walk walk;\n\tint err;\n\n\t \n\tif (WARN_ON_ONCE(!is_power_of_2(blocksize)))\n\t\treturn -EINVAL;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile (walk.nbytes > 0) {\n\t\tu8 *dst = walk.dst.virt.addr;\n\t\tu8 *src = walk.src.virt.addr;\n\t\tint nbytes = walk.nbytes;\n\t\tint tail = 0;\n\n\t\tif (nbytes < walk.total) {\n\t\t\ttail = walk.nbytes & (blocksize - 1);\n\t\t\tnbytes -= tail;\n\t\t}\n\n\t\tdo {\n\t\t\tint bsize = min(nbytes, blocksize);\n\n\t\t\tfn(tfm, walk.iv, buf);\n\n\t\t\tcrypto_xor_cpy(dst, src, buf, bsize);\n\t\t\tcrypto_inc(walk.iv, blocksize);\n\n\t\t\tdst += bsize;\n\t\t\tsrc += bsize;\n\t\t\tnbytes -= bsize;\n\t\t} while (nbytes > 0);\n\n\t\terr = skcipher_walk_done(&walk, tail);\n\t}\n\treturn err;\n}\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}