{
  "module_name": "if_alg.h",
  "hash_id": "1d790c540002228e59cd2620212cc958f1a1bd7f8e99d7a4e6df44768acc694a",
  "original_prompt": "Ingested from linux-6.6.14/include/crypto/if_alg.h",
  "human_readable_source": " \n \n\n#ifndef _CRYPTO_IF_ALG_H\n#define _CRYPTO_IF_ALG_H\n\n#include <linux/compiler.h>\n#include <linux/completion.h>\n#include <linux/if_alg.h>\n#include <linux/scatterlist.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <net/sock.h>\n\n#include <crypto/aead.h>\n#include <crypto/skcipher.h>\n\n#define ALG_MAX_PAGES\t\t\t16\n\nstruct alg_sock {\n\t \n\tstruct sock sk;\n\n\tstruct sock *parent;\n\n\tatomic_t refcnt;\n\tatomic_t nokey_refcnt;\n\n\tconst struct af_alg_type *type;\n\tvoid *private;\n};\n\nstruct af_alg_control {\n\tstruct af_alg_iv *iv;\n\tint op;\n\tunsigned int aead_assoclen;\n};\n\nstruct af_alg_type {\n\tvoid *(*bind)(const char *name, u32 type, u32 mask);\n\tvoid (*release)(void *private);\n\tint (*setkey)(void *private, const u8 *key, unsigned int keylen);\n\tint (*setentropy)(void *private, sockptr_t entropy, unsigned int len);\n\tint (*accept)(void *private, struct sock *sk);\n\tint (*accept_nokey)(void *private, struct sock *sk);\n\tint (*setauthsize)(void *private, unsigned int authsize);\n\n\tstruct proto_ops *ops;\n\tstruct proto_ops *ops_nokey;\n\tstruct module *owner;\n\tchar name[14];\n};\n\nstruct af_alg_sgl {\n\tstruct sg_table sgt;\n\tstruct scatterlist sgl[ALG_MAX_PAGES + 1];\n\tbool need_unpin;\n};\n\n \nstruct af_alg_tsgl {\n\tstruct list_head list;\n\tunsigned int cur;\t\t \n\tstruct scatterlist sg[];\t \n};\n\n#define MAX_SGL_ENTS ((4096 - sizeof(struct af_alg_tsgl)) / \\\n\t\t      sizeof(struct scatterlist) - 1)\n\n \nstruct af_alg_rsgl {\n\tstruct af_alg_sgl sgl;\n\tstruct list_head list;\n\tsize_t sg_num_bytes;\t\t \n};\n\n \nstruct af_alg_async_req {\n\tstruct kiocb *iocb;\n\tstruct sock *sk;\n\n\tstruct af_alg_rsgl first_rsgl;\n\tstruct af_alg_rsgl *last_rsgl;\n\tstruct list_head rsgl_list;\n\n\tstruct scatterlist *tsgl;\n\tunsigned int tsgl_entries;\n\n\tunsigned int outlen;\n\tunsigned int areqlen;\n\n\tunion {\n\t\tstruct aead_request aead_req;\n\t\tstruct skcipher_request skcipher_req;\n\t} cra_u;\n\n\t \n};\n\n \nstruct af_alg_ctx {\n\tstruct list_head tsgl_list;\n\n\tvoid *iv;\n\tsize_t aead_assoclen;\n\n\tstruct crypto_wait wait;\n\n\tsize_t used;\n\tatomic_t rcvused;\n\n\tbool more;\n\tbool merge;\n\tbool enc;\n\tbool init;\n\n\tunsigned int len;\n\n\tunsigned int inflight;\n};\n\nint af_alg_register_type(const struct af_alg_type *type);\nint af_alg_unregister_type(const struct af_alg_type *type);\n\nint af_alg_release(struct socket *sock);\nvoid af_alg_release_parent(struct sock *sk);\nint af_alg_accept(struct sock *sk, struct socket *newsock, bool kern);\n\nvoid af_alg_free_sg(struct af_alg_sgl *sgl);\n\nstatic inline struct alg_sock *alg_sk(struct sock *sk)\n{\n\treturn (struct alg_sock *)sk;\n}\n\n \nstatic inline int af_alg_sndbuf(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\n\treturn max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -\n\t\t\t  ctx->used, 0);\n}\n\n \nstatic inline bool af_alg_writable(struct sock *sk)\n{\n\treturn PAGE_SIZE <= af_alg_sndbuf(sk);\n}\n\n \nstatic inline int af_alg_rcvbuf(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\n\treturn max_t(int, max_t(int, sk->sk_rcvbuf & PAGE_MASK, PAGE_SIZE) -\n\t\t     atomic_read(&ctx->rcvused), 0);\n}\n\n \nstatic inline bool af_alg_readable(struct sock *sk)\n{\n\treturn PAGE_SIZE <= af_alg_rcvbuf(sk);\n}\n\nunsigned int af_alg_count_tsgl(struct sock *sk, size_t bytes, size_t offset);\nvoid af_alg_pull_tsgl(struct sock *sk, size_t used, struct scatterlist *dst,\n\t\t      size_t dst_offset);\nvoid af_alg_wmem_wakeup(struct sock *sk);\nint af_alg_wait_for_data(struct sock *sk, unsigned flags, unsigned min);\nint af_alg_sendmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t   unsigned int ivsize);\nvoid af_alg_free_resources(struct af_alg_async_req *areq);\nvoid af_alg_async_cb(void *data, int err);\n__poll_t af_alg_poll(struct file *file, struct socket *sock,\n\t\t\t poll_table *wait);\nstruct af_alg_async_req *af_alg_alloc_areq(struct sock *sk,\n\t\t\t\t\t   unsigned int areqlen);\nint af_alg_get_rsgl(struct sock *sk, struct msghdr *msg, int flags,\n\t\t    struct af_alg_async_req *areq, size_t maxsize,\n\t\t    size_t *outlen);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}