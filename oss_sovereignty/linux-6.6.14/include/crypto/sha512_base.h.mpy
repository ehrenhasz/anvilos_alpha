{
  "module_name": "sha512_base.h",
  "hash_id": "f479ef860d3cf6671ecccf66520b10c8a32869ba1440f1423ef41226d3a9efd1",
  "original_prompt": "Ingested from linux-6.6.14/include/crypto/sha512_base.h",
  "human_readable_source": " \n \n\n#ifndef _CRYPTO_SHA512_BASE_H\n#define _CRYPTO_SHA512_BASE_H\n\n#include <crypto/internal/hash.h>\n#include <crypto/sha2.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\n#include <asm/unaligned.h>\n\ntypedef void (sha512_block_fn)(struct sha512_state *sst, u8 const *src,\n\t\t\t       int blocks);\n\nstatic inline int sha384_base_init(struct shash_desc *desc)\n{\n\tstruct sha512_state *sctx = shash_desc_ctx(desc);\n\n\tsctx->state[0] = SHA384_H0;\n\tsctx->state[1] = SHA384_H1;\n\tsctx->state[2] = SHA384_H2;\n\tsctx->state[3] = SHA384_H3;\n\tsctx->state[4] = SHA384_H4;\n\tsctx->state[5] = SHA384_H5;\n\tsctx->state[6] = SHA384_H6;\n\tsctx->state[7] = SHA384_H7;\n\tsctx->count[0] = sctx->count[1] = 0;\n\n\treturn 0;\n}\n\nstatic inline int sha512_base_init(struct shash_desc *desc)\n{\n\tstruct sha512_state *sctx = shash_desc_ctx(desc);\n\n\tsctx->state[0] = SHA512_H0;\n\tsctx->state[1] = SHA512_H1;\n\tsctx->state[2] = SHA512_H2;\n\tsctx->state[3] = SHA512_H3;\n\tsctx->state[4] = SHA512_H4;\n\tsctx->state[5] = SHA512_H5;\n\tsctx->state[6] = SHA512_H6;\n\tsctx->state[7] = SHA512_H7;\n\tsctx->count[0] = sctx->count[1] = 0;\n\n\treturn 0;\n}\n\nstatic inline int sha512_base_do_update(struct shash_desc *desc,\n\t\t\t\t\tconst u8 *data,\n\t\t\t\t\tunsigned int len,\n\t\t\t\t\tsha512_block_fn *block_fn)\n{\n\tstruct sha512_state *sctx = shash_desc_ctx(desc);\n\tunsigned int partial = sctx->count[0] % SHA512_BLOCK_SIZE;\n\n\tsctx->count[0] += len;\n\tif (sctx->count[0] < len)\n\t\tsctx->count[1]++;\n\n\tif (unlikely((partial + len) >= SHA512_BLOCK_SIZE)) {\n\t\tint blocks;\n\n\t\tif (partial) {\n\t\t\tint p = SHA512_BLOCK_SIZE - partial;\n\n\t\t\tmemcpy(sctx->buf + partial, data, p);\n\t\t\tdata += p;\n\t\t\tlen -= p;\n\n\t\t\tblock_fn(sctx, sctx->buf, 1);\n\t\t}\n\n\t\tblocks = len / SHA512_BLOCK_SIZE;\n\t\tlen %= SHA512_BLOCK_SIZE;\n\n\t\tif (blocks) {\n\t\t\tblock_fn(sctx, data, blocks);\n\t\t\tdata += blocks * SHA512_BLOCK_SIZE;\n\t\t}\n\t\tpartial = 0;\n\t}\n\tif (len)\n\t\tmemcpy(sctx->buf + partial, data, len);\n\n\treturn 0;\n}\n\nstatic inline int sha512_base_do_finalize(struct shash_desc *desc,\n\t\t\t\t\t  sha512_block_fn *block_fn)\n{\n\tconst int bit_offset = SHA512_BLOCK_SIZE - sizeof(__be64[2]);\n\tstruct sha512_state *sctx = shash_desc_ctx(desc);\n\t__be64 *bits = (__be64 *)(sctx->buf + bit_offset);\n\tunsigned int partial = sctx->count[0] % SHA512_BLOCK_SIZE;\n\n\tsctx->buf[partial++] = 0x80;\n\tif (partial > bit_offset) {\n\t\tmemset(sctx->buf + partial, 0x0, SHA512_BLOCK_SIZE - partial);\n\t\tpartial = 0;\n\n\t\tblock_fn(sctx, sctx->buf, 1);\n\t}\n\n\tmemset(sctx->buf + partial, 0x0, bit_offset - partial);\n\tbits[0] = cpu_to_be64(sctx->count[1] << 3 | sctx->count[0] >> 61);\n\tbits[1] = cpu_to_be64(sctx->count[0] << 3);\n\tblock_fn(sctx, sctx->buf, 1);\n\n\treturn 0;\n}\n\nstatic inline int sha512_base_finish(struct shash_desc *desc, u8 *out)\n{\n\tunsigned int digest_size = crypto_shash_digestsize(desc->tfm);\n\tstruct sha512_state *sctx = shash_desc_ctx(desc);\n\t__be64 *digest = (__be64 *)out;\n\tint i;\n\n\tfor (i = 0; digest_size > 0; i++, digest_size -= sizeof(__be64))\n\t\tput_unaligned_be64(sctx->state[i], digest++);\n\n\tmemzero_explicit(sctx, sizeof(*sctx));\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}