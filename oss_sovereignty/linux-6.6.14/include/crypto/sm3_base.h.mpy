{
  "module_name": "sm3_base.h",
  "hash_id": "a6f24cb0f0bf6455dbe375bc40e5a650ce85894b01a06429664e6ededab28c69",
  "original_prompt": "Ingested from linux-6.6.14/include/crypto/sm3_base.h",
  "human_readable_source": " \n \n\n#ifndef _CRYPTO_SM3_BASE_H\n#define _CRYPTO_SM3_BASE_H\n\n#include <crypto/internal/hash.h>\n#include <crypto/sm3.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <asm/unaligned.h>\n\ntypedef void (sm3_block_fn)(struct sm3_state *sst, u8 const *src, int blocks);\n\nstatic inline int sm3_base_init(struct shash_desc *desc)\n{\n\tstruct sm3_state *sctx = shash_desc_ctx(desc);\n\n\tsctx->state[0] = SM3_IVA;\n\tsctx->state[1] = SM3_IVB;\n\tsctx->state[2] = SM3_IVC;\n\tsctx->state[3] = SM3_IVD;\n\tsctx->state[4] = SM3_IVE;\n\tsctx->state[5] = SM3_IVF;\n\tsctx->state[6] = SM3_IVG;\n\tsctx->state[7] = SM3_IVH;\n\tsctx->count = 0;\n\n\treturn 0;\n}\n\nstatic inline int sm3_base_do_update(struct shash_desc *desc,\n\t\t\t\t      const u8 *data,\n\t\t\t\t      unsigned int len,\n\t\t\t\t      sm3_block_fn *block_fn)\n{\n\tstruct sm3_state *sctx = shash_desc_ctx(desc);\n\tunsigned int partial = sctx->count % SM3_BLOCK_SIZE;\n\n\tsctx->count += len;\n\n\tif (unlikely((partial + len) >= SM3_BLOCK_SIZE)) {\n\t\tint blocks;\n\n\t\tif (partial) {\n\t\t\tint p = SM3_BLOCK_SIZE - partial;\n\n\t\t\tmemcpy(sctx->buffer + partial, data, p);\n\t\t\tdata += p;\n\t\t\tlen -= p;\n\n\t\t\tblock_fn(sctx, sctx->buffer, 1);\n\t\t}\n\n\t\tblocks = len / SM3_BLOCK_SIZE;\n\t\tlen %= SM3_BLOCK_SIZE;\n\n\t\tif (blocks) {\n\t\t\tblock_fn(sctx, data, blocks);\n\t\t\tdata += blocks * SM3_BLOCK_SIZE;\n\t\t}\n\t\tpartial = 0;\n\t}\n\tif (len)\n\t\tmemcpy(sctx->buffer + partial, data, len);\n\n\treturn 0;\n}\n\nstatic inline int sm3_base_do_finalize(struct shash_desc *desc,\n\t\t\t\t\tsm3_block_fn *block_fn)\n{\n\tconst int bit_offset = SM3_BLOCK_SIZE - sizeof(__be64);\n\tstruct sm3_state *sctx = shash_desc_ctx(desc);\n\t__be64 *bits = (__be64 *)(sctx->buffer + bit_offset);\n\tunsigned int partial = sctx->count % SM3_BLOCK_SIZE;\n\n\tsctx->buffer[partial++] = 0x80;\n\tif (partial > bit_offset) {\n\t\tmemset(sctx->buffer + partial, 0x0, SM3_BLOCK_SIZE - partial);\n\t\tpartial = 0;\n\n\t\tblock_fn(sctx, sctx->buffer, 1);\n\t}\n\n\tmemset(sctx->buffer + partial, 0x0, bit_offset - partial);\n\t*bits = cpu_to_be64(sctx->count << 3);\n\tblock_fn(sctx, sctx->buffer, 1);\n\n\treturn 0;\n}\n\nstatic inline int sm3_base_finish(struct shash_desc *desc, u8 *out)\n{\n\tstruct sm3_state *sctx = shash_desc_ctx(desc);\n\t__be32 *digest = (__be32 *)out;\n\tint i;\n\n\tfor (i = 0; i < SM3_DIGEST_SIZE / sizeof(__be32); i++)\n\t\tput_unaligned_be32(sctx->state[i], digest++);\n\n\tmemzero_explicit(sctx, sizeof(*sctx));\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}