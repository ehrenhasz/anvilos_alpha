{
  "module_name": "libfcoe.h",
  "hash_id": "403ee80a5eac8013ecd8e688bbc84ecf333a0a95e9d470f7dd74ac07580059dc",
  "original_prompt": "Ingested from linux-6.6.14/include/scsi/libfcoe.h",
  "human_readable_source": " \n \n\n#ifndef _LIBFCOE_H\n#define _LIBFCOE_H\n\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/workqueue.h>\n#include <linux/local_lock.h>\n#include <linux/random.h>\n#include <scsi/fc/fc_fcoe.h>\n#include <scsi/libfc.h>\n#include <scsi/fcoe_sysfs.h>\n\n#define FCOE_MAX_CMD_LEN\t16\t \n\n \n#define FCOE_MTU\t2158\n\n \n#define FCOE_CTLR_START_DELAY\t2000\t \n#define FCOE_CTLR_SOL_TOV\t2000\t \n#define FCOE_CTLR_FCF_LIMIT\t20\t \n#define FCOE_CTLR_VN2VN_LOGIN_LIMIT 3\t \n\n \nenum fip_state {\n\tFIP_ST_DISABLED,\n\tFIP_ST_LINK_WAIT,\n\tFIP_ST_AUTO,\n\tFIP_ST_NON_FIP,\n\tFIP_ST_ENABLED,\n\tFIP_ST_VNMP_START,\n\tFIP_ST_VNMP_PROBE1,\n\tFIP_ST_VNMP_PROBE2,\n\tFIP_ST_VNMP_CLAIM,\n\tFIP_ST_VNMP_UP,\n};\n\n \nenum fip_mode {\n\tFIP_MODE_AUTO,\n\tFIP_MODE_NON_FIP,\n\tFIP_MODE_FABRIC,\n\tFIP_MODE_VN2VN,\n};\n\n \nstruct fcoe_ctlr {\n\tenum fip_state state;\n\tenum fip_mode mode;\n\tstruct fc_lport *lp;\n\tstruct fcoe_fcf *sel_fcf;\n\tstruct list_head fcfs;\n\tstruct fcoe_ctlr_device *cdev;\n\tu16 fcf_count;\n\tunsigned long sol_time;\n\tunsigned long sel_time;\n\tunsigned long port_ka_time;\n\tunsigned long ctlr_ka_time;\n\tstruct timer_list timer;\n\tstruct work_struct timer_work;\n\tstruct work_struct recv_work;\n\tstruct sk_buff_head fip_recv_list;\n\tstruct sk_buff *flogi_req;\n\n\tstruct rnd_state rnd_state;\n\tu32 port_id;\n\n\tu16 user_mfs;\n\tu16 flogi_oxid;\n\tu8 flogi_req_send;\n\tu8 flogi_count;\n\tbool map_dest;\n\tbool fip_resp;\n\tu8 spma;\n\tu8 probe_tries;\n\tu8 priority;\n\tu8 dest_addr[ETH_ALEN];\n\tu8 ctl_src_addr[ETH_ALEN];\n\n\tvoid (*send)(struct fcoe_ctlr *, struct sk_buff *);\n\tvoid (*update_mac)(struct fc_lport *, u8 *addr);\n\tu8 * (*get_src_addr)(struct fc_lport *);\n\tstruct mutex ctlr_mutex;\n\tspinlock_t ctlr_lock;\n};\n\n \nstatic inline void *fcoe_ctlr_priv(const struct fcoe_ctlr *ctlr)\n{\n\treturn (void *)(ctlr + 1);\n}\n\n \n#define fcoe_ctlr_to_ctlr_dev(x)\t\t\t\t\t\\\n\t(x)->cdev\n\n \nstruct fcoe_fcf {\n\tstruct list_head list;\n\tstruct work_struct event_work;\n\tstruct fcoe_ctlr *fip;\n\tstruct fcoe_fcf_device *fcf_dev;\n\tunsigned long time;\n\n\tu64 switch_name;\n\tu64 fabric_name;\n\tu32 fc_map;\n\tu16 vfid;\n\tu8 fcf_mac[ETH_ALEN];\n\tu8 fcoe_mac[ETH_ALEN];\n\n\tu8 pri;\n\tu8 flogi_sent;\n\tu16 flags;\n\tu32 fka_period;\n\tu8 fd_flags:1;\n};\n\n#define fcoe_fcf_to_fcf_dev(x)\t\t\t\\\n\t((x)->fcf_dev)\n\n \nstruct fcoe_rport {\n\tstruct fc_rport_priv rdata;\n\tunsigned long time;\n\tu16 fcoe_len;\n\tu16 flags;\n\tu8 login_count;\n\tu8 enode_mac[ETH_ALEN];\n\tu8 vn_mac[ETH_ALEN];\n};\n\n \nvoid fcoe_ctlr_init(struct fcoe_ctlr *, enum fip_mode);\nvoid fcoe_ctlr_destroy(struct fcoe_ctlr *);\nvoid fcoe_ctlr_link_up(struct fcoe_ctlr *);\nint fcoe_ctlr_link_down(struct fcoe_ctlr *);\nint fcoe_ctlr_els_send(struct fcoe_ctlr *, struct fc_lport *, struct sk_buff *);\nvoid fcoe_ctlr_recv(struct fcoe_ctlr *, struct sk_buff *);\nint fcoe_ctlr_recv_flogi(struct fcoe_ctlr *, struct fc_lport *,\n\t\t\t struct fc_frame *);\n\n \nu64 fcoe_wwn_from_mac(unsigned char mac[ETH_ALEN], unsigned int scheme,\n\t\t      unsigned int port);\nint fcoe_libfc_config(struct fc_lport *, struct fcoe_ctlr *,\n\t\t      const struct libfc_function_template *, int init_fcp);\nu32 fcoe_fc_crc(struct fc_frame *fp);\nint fcoe_start_io(struct sk_buff *skb);\nint fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type);\nvoid __fcoe_get_lesb(struct fc_lport *lport, struct fc_els_lesb *fc_lesb,\n\t\t     struct net_device *netdev);\nvoid fcoe_wwn_to_str(u64 wwn, char *buf, int len);\nint fcoe_validate_vport_create(struct fc_vport *vport);\nint fcoe_link_speed_update(struct fc_lport *);\nvoid fcoe_get_lesb(struct fc_lport *, struct fc_els_lesb *);\nvoid fcoe_ctlr_get_lesb(struct fcoe_ctlr_device *ctlr_dev);\n\n \nstatic inline bool is_fip_mode(struct fcoe_ctlr *fip)\n{\n\treturn fip->state == FIP_ST_ENABLED;\n}\n\n \n#define MODULE_ALIAS_FCOE_PCI(ven, dev) \\\n\tMODULE_ALIAS(\"fcoe-pci:\"\t\\\n\t\t\"v\" __stringify(ven)\t\\\n\t\t\"d\" __stringify(dev) \"sv*sd*bc*sc*i*\")\n\n \n#define FCOE_TRANSPORT_DEFAULT\t\"fcoe\"\n\n \nstruct fcoe_transport {\n\tchar name[IFNAMSIZ];\n\tbool attached;\n\tstruct list_head list;\n\tbool (*match) (struct net_device *device);\n\tint (*alloc) (struct net_device *device);\n\tint (*create) (struct net_device *device, enum fip_mode fip_mode);\n\tint (*destroy) (struct net_device *device);\n\tint (*enable) (struct net_device *device);\n\tint (*disable) (struct net_device *device);\n};\n\n \nstruct fcoe_percpu_s {\n\tstruct task_struct *kthread;\n\tstruct work_struct work;\n\tstruct sk_buff_head fcoe_rx_list;\n\tstruct page *crc_eof_page;\n\tint crc_eof_offset;\n\tlocal_lock_t lock;\n};\n\n \nstruct fcoe_port {\n\tvoid\t\t      *priv;\n\tstruct fc_lport\t      *lport;\n\tstruct sk_buff_head   fcoe_pending_queue;\n\tu8\t\t      fcoe_pending_queue_active;\n\tu32\t\t      max_queue_depth;\n\tu32\t\t      min_queue_depth;\n\tstruct timer_list     timer;\n\tstruct work_struct    destroy_work;\n\tu8\t\t      data_src_addr[ETH_ALEN];\n\tstruct net_device * (*get_netdev)(const struct fc_lport *lport);\n};\n\n \nstatic inline struct net_device *fcoe_get_netdev(const struct fc_lport *lport)\n{\n\tstruct fcoe_port *port = ((struct fcoe_port *)lport_priv(lport));\n\n\treturn (port->get_netdev) ? port->get_netdev(lport) : NULL;\n}\n\nvoid fcoe_clean_pending_queue(struct fc_lport *);\nvoid fcoe_check_wait_queue(struct fc_lport *lport, struct sk_buff *skb);\nvoid fcoe_queue_timer(struct timer_list *t);\nint fcoe_get_paged_crc_eof(struct sk_buff *skb, int tlen,\n\t\t\t   struct fcoe_percpu_s *fps);\n\n \nvoid fcoe_fcf_get_selected(struct fcoe_fcf_device *);\nvoid fcoe_ctlr_set_fip_mode(struct fcoe_ctlr_device *);\n\n \nstruct fcoe_netdev_mapping {\n\tstruct list_head list;\n\tstruct net_device *netdev;\n\tstruct fcoe_transport *ft;\n};\n\n \nint fcoe_transport_attach(struct fcoe_transport *ft);\nint fcoe_transport_detach(struct fcoe_transport *ft);\n\n \nssize_t fcoe_ctlr_create_store(const char *buf, size_t count);\nssize_t fcoe_ctlr_destroy_store(const char *buf, size_t count);\n\n#endif  \n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}