{
  "module_name": "scsi_transport_sas.h",
  "hash_id": "3134fe4e004aa2d981b2b2f22b6aba2fb78cc0c3d80cff053ed2e8dc3542a582",
  "original_prompt": "Ingested from linux-6.6.14/include/scsi/scsi_transport_sas.h",
  "human_readable_source": " \n#ifndef SCSI_TRANSPORT_SAS_H\n#define SCSI_TRANSPORT_SAS_H\n\n#include <linux/transport_class.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <scsi/sas.h>\n#include <linux/bsg-lib.h>\n\nstruct scsi_transport_template;\nstruct sas_rphy;\nstruct request;\n\n#if !IS_ENABLED(CONFIG_SCSI_SAS_ATTRS)\nstatic inline int scsi_is_sas_rphy(const struct device *sdev)\n{\n\treturn 0;\n}\n#else\nextern int scsi_is_sas_rphy(const struct device *);\n#endif\n\nstatic inline int sas_protocol_ata(enum sas_protocol proto)\n{\n\treturn ((proto & SAS_PROTOCOL_SATA) ||\n\t\t(proto & SAS_PROTOCOL_STP))? 1 : 0;\n}\n\nenum sas_linkrate {\n\t \n\tSAS_LINK_RATE_UNKNOWN = 0,\n\tSAS_PHY_DISABLED = 1,\n\tSAS_PHY_RESET_PROBLEM = 2,\n\tSAS_SATA_SPINUP_HOLD = 3,\n\tSAS_SATA_PORT_SELECTOR = 4,\n\tSAS_PHY_RESET_IN_PROGRESS = 5,\n\tSAS_LINK_RATE_1_5_GBPS = 8,\n\tSAS_LINK_RATE_G1 = SAS_LINK_RATE_1_5_GBPS,\n\tSAS_LINK_RATE_3_0_GBPS = 9,\n\tSAS_LINK_RATE_G2 = SAS_LINK_RATE_3_0_GBPS,\n\tSAS_LINK_RATE_6_0_GBPS = 10,\n\tSAS_LINK_RATE_12_0_GBPS = 11,\n\tSAS_LINK_RATE_22_5_GBPS = 12,\n\t \n\tSAS_LINK_RATE_FAILED = 0x10,\n\tSAS_PHY_VIRTUAL = 0x11,\n};\n\nstruct sas_identify {\n\tenum sas_device_type\tdevice_type;\n\tenum sas_protocol\tinitiator_port_protocols;\n\tenum sas_protocol\ttarget_port_protocols;\n\tu64\t\t\tsas_address;\n\tu8\t\t\tphy_identifier;\n};\n\nstruct sas_phy {\n\tstruct device\t\tdev;\n\tint\t\t\tnumber;\n\tint\t\t\tenabled;\n\n\t \n\tstruct sas_identify\tidentify;\n\n\t \n\tenum sas_linkrate\tnegotiated_linkrate;\n\tenum sas_linkrate\tminimum_linkrate_hw;\n\tenum sas_linkrate\tminimum_linkrate;\n\tenum sas_linkrate\tmaximum_linkrate_hw;\n\tenum sas_linkrate\tmaximum_linkrate;\n\n\t \n\tu32\t\t\tinvalid_dword_count;\n\tu32\t\t\trunning_disparity_error_count;\n\tu32\t\t\tloss_of_dword_sync_count;\n\tu32\t\t\tphy_reset_problem_count;\n\n\t \n\tstruct list_head\tport_siblings;\n\n\t \n\tvoid\t\t\t*hostdata;\n};\n\n#define dev_to_phy(d) \\\n\tcontainer_of((d), struct sas_phy, dev)\n#define transport_class_to_phy(dev) \\\n\tdev_to_phy((dev)->parent)\n#define phy_to_shost(phy) \\\n\tdev_to_shost((phy)->dev.parent)\n\nstruct request_queue;\nstruct sas_rphy {\n\tstruct device\t\tdev;\n\tstruct sas_identify\tidentify;\n\tstruct list_head\tlist;\n\tstruct request_queue\t*q;\n\tu32\t\t\tscsi_target_id;\n};\n\n#define dev_to_rphy(d) \\\n\tcontainer_of((d), struct sas_rphy, dev)\n#define transport_class_to_rphy(dev) \\\n\tdev_to_rphy((dev)->parent)\n#define rphy_to_shost(rphy) \\\n\tdev_to_shost((rphy)->dev.parent)\n#define target_to_rphy(targ) \\\n\tdev_to_rphy((targ)->dev.parent)\n\nstruct sas_end_device {\n\tstruct sas_rphy\t\trphy;\n\t \n\tunsigned\t\tready_led_meaning:1;\n\tunsigned\t\ttlr_supported:1;\n\tunsigned\t\ttlr_enabled:1;\n\t \n\tu16\t\t\tI_T_nexus_loss_timeout;\n\tu16\t\t\tinitiator_response_timeout;\n};\n#define rphy_to_end_device(r) \\\n\tcontainer_of((r), struct sas_end_device, rphy)\n\nstruct sas_expander_device {\n\tint    level;\n\tint    next_port_id;\n\n\t#define SAS_EXPANDER_VENDOR_ID_LEN\t8\n\tchar   vendor_id[SAS_EXPANDER_VENDOR_ID_LEN+1];\n\t#define SAS_EXPANDER_PRODUCT_ID_LEN\t16\n\tchar   product_id[SAS_EXPANDER_PRODUCT_ID_LEN+1];\n\t#define SAS_EXPANDER_PRODUCT_REV_LEN\t4\n\tchar   product_rev[SAS_EXPANDER_PRODUCT_REV_LEN+1];\n\t#define SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN\t8\n\tchar   component_vendor_id[SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN+1];\n\tu16    component_id;\n\tu8     component_revision_id;\n\n\tstruct sas_rphy\t\trphy;\n\n};\n#define rphy_to_expander_device(r) \\\n\tcontainer_of((r), struct sas_expander_device, rphy)\n\nstruct sas_port {\n\tstruct device\t\tdev;\n\n\tint\t\t\tport_identifier;\n\tint\t\t\tnum_phys;\n\t \n\tunsigned int\t\tis_backlink:1;\n\n\t \n\tstruct sas_rphy\t\t*rphy;\n\n\tstruct mutex\t\tphy_list_mutex;\n\tstruct list_head\tphy_list;\n\tstruct list_head\tdel_list;  \n};\n\n#define dev_to_sas_port(d) \\\n\tcontainer_of((d), struct sas_port, dev)\n#define transport_class_to_sas_port(dev) \\\n\tdev_to_sas_port((dev)->parent)\n\nstruct sas_phy_linkrates {\n\tenum sas_linkrate maximum_linkrate;\n\tenum sas_linkrate minimum_linkrate;\n};\n\n \nstruct sas_function_template {\n\tint (*get_linkerrors)(struct sas_phy *);\n\tint (*get_enclosure_identifier)(struct sas_rphy *, u64 *);\n\tint (*get_bay_identifier)(struct sas_rphy *);\n\tint (*phy_reset)(struct sas_phy *, int);\n\tint (*phy_enable)(struct sas_phy *, int);\n\tint (*phy_setup)(struct sas_phy *);\n\tvoid (*phy_release)(struct sas_phy *);\n\tint (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);\n\tvoid (*smp_handler)(struct bsg_job *, struct Scsi_Host *,\n\t\t\tstruct sas_rphy *);\n};\n\n\nvoid sas_remove_children(struct device *);\nextern void sas_remove_host(struct Scsi_Host *);\n\nextern struct sas_phy *sas_phy_alloc(struct device *, int);\nextern void sas_phy_free(struct sas_phy *);\nextern int sas_phy_add(struct sas_phy *);\nextern void sas_phy_delete(struct sas_phy *);\nextern int scsi_is_sas_phy(const struct device *);\n\nu64 sas_get_address(struct scsi_device *);\nunsigned int sas_tlr_supported(struct scsi_device *);\nunsigned int sas_is_tlr_enabled(struct scsi_device *);\nvoid sas_disable_tlr(struct scsi_device *);\nvoid sas_enable_tlr(struct scsi_device *);\n\nextern struct sas_rphy *sas_end_device_alloc(struct sas_port *);\nextern struct sas_rphy *sas_expander_alloc(struct sas_port *, enum sas_device_type);\nvoid sas_rphy_free(struct sas_rphy *);\nextern int sas_rphy_add(struct sas_rphy *);\nextern void sas_rphy_remove(struct sas_rphy *);\nextern void sas_rphy_delete(struct sas_rphy *);\nextern void sas_rphy_unlink(struct sas_rphy *);\n\nstruct sas_port *sas_port_alloc(struct device *, int);\nstruct sas_port *sas_port_alloc_num(struct device *);\nint sas_port_add(struct sas_port *);\nvoid sas_port_free(struct sas_port *);\nvoid sas_port_delete(struct sas_port *);\nvoid sas_port_add_phy(struct sas_port *, struct sas_phy *);\nvoid sas_port_delete_phy(struct sas_port *, struct sas_phy *);\nvoid sas_port_mark_backlink(struct sas_port *);\nint scsi_is_sas_port(const struct device *);\nstruct sas_phy *sas_port_get_phy(struct sas_port *port);\nstatic inline void sas_port_put_phy(struct sas_phy *phy)\n{\n\tif (phy)\n\t\tput_device(&phy->dev);\n}\n\nextern struct scsi_transport_template *\nsas_attach_transport(struct sas_function_template *);\nextern void sas_release_transport(struct scsi_transport_template *);\nint sas_read_port_mode_page(struct scsi_device *);\n\nstatic inline int\nscsi_is_sas_expander_device(struct device *dev)\n{\n\tstruct sas_rphy *rphy;\n\tif (!scsi_is_sas_rphy(dev))\n\t\treturn 0;\n\trphy = dev_to_rphy(dev);\n\treturn rphy->identify.device_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\trphy->identify.device_type == SAS_EDGE_EXPANDER_DEVICE;\n}\n\n#define scsi_is_sas_phy_local(phy)\tscsi_is_host_device((phy)->dev.parent)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}