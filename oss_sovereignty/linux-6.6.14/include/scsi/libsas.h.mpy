{
  "module_name": "libsas.h",
  "hash_id": "d67685be3871c02a7d0b0fb9a5ffef95b063ec62e91f0883ad4e92f2789b7e7b",
  "original_prompt": "Ingested from linux-6.6.14/include/scsi/libsas.h",
  "human_readable_source": " \n \n\n#ifndef _LIBSAS_H_\n#define _LIBSAS_H_\n\n\n#include <linux/timer.h>\n#include <linux/pci.h>\n#include <scsi/sas.h>\n#include <linux/libata.h>\n#include <linux/list.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_transport_sas.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n\nstruct block_device;\n\nenum sas_phy_role {\n\tPHY_ROLE_NONE = 0,\n\tPHY_ROLE_TARGET = 0x40,\n\tPHY_ROLE_INITIATOR = 0x80,\n};\n\n \nenum port_event {\n\tPORTE_BYTES_DMAED     = 0U,\n\tPORTE_BROADCAST_RCVD,\n\tPORTE_LINK_RESET_ERR,\n\tPORTE_TIMER_EVENT,\n\tPORTE_HARD_RESET,\n\tPORT_NUM_EVENTS,\n};\n\nenum phy_event {\n\tPHYE_LOSS_OF_SIGNAL   = 0U,\n\tPHYE_OOB_DONE,\n\tPHYE_OOB_ERROR,\n\tPHYE_SPINUP_HOLD,              \n\tPHYE_RESUME_TIMEOUT,\n\tPHYE_SHUTDOWN,\n\tPHY_NUM_EVENTS,\n};\n\nenum discover_event {\n\tDISCE_DISCOVER_DOMAIN   = 0U,\n\tDISCE_REVALIDATE_DOMAIN,\n\tDISCE_SUSPEND,\n\tDISCE_RESUME,\n\tDISC_NUM_EVENTS,\n};\n\n \n\n#define to_dom_device(_obj) container_of(_obj, struct domain_device, dev_obj)\n#define to_dev_attr(_attr)  container_of(_attr, struct domain_dev_attribute,\\\n\t\t\t\t\t attr)\n\nenum routing_attribute {\n\tDIRECT_ROUTING,\n\tSUBTRACTIVE_ROUTING,\n\tTABLE_ROUTING,\n};\n\nenum ex_phy_state {\n\tPHY_EMPTY,\n\tPHY_VACANT,\n\tPHY_NOT_PRESENT,\n\tPHY_DEVICE_DISCOVERED\n};\n\nstruct ex_phy {\n\tint    phy_id;\n\n\tenum ex_phy_state phy_state;\n\n\tenum sas_device_type attached_dev_type;\n\tenum sas_linkrate linkrate;\n\n\tu8   attached_sata_host:1;\n\tu8   attached_sata_dev:1;\n\tu8   attached_sata_ps:1;\n\n\tenum sas_protocol attached_tproto;\n\tenum sas_protocol attached_iproto;\n\n\tu8   attached_sas_addr[SAS_ADDR_SIZE];\n\tu8   attached_phy_id;\n\n\tint phy_change_count;\n\tenum routing_attribute routing_attr;\n\tu8   virtual:1;\n\n\tint  last_da_index;\n\n\tstruct sas_phy *phy;\n\tstruct sas_port *port;\n};\n\nstruct expander_device {\n\tstruct list_head children;\n\n\tint    ex_change_count;\n\tu16    max_route_indexes;\n\tu8     num_phys;\n\n\tu8     t2t_supp:1;\n\tu8     configuring:1;\n\tu8     conf_route_table:1;\n\n\tu8     enclosure_logical_id[8];\n\n\tstruct ex_phy *ex_phy;\n\tstruct sas_port *parent_port;\n\n\tstruct mutex cmd_mutex;\n};\n\n \n#define ATA_RESP_FIS_SIZE 24\n\nstruct sata_device {\n\tunsigned int class;\n\tu8     port_no;         \n\n\tstruct ata_port *ap;\n\tstruct ata_host *ata_host;\n\tstruct smp_rps_resp rps_resp ____cacheline_aligned;  \n\tu8     fis[ATA_RESP_FIS_SIZE];\n};\n\nstruct ssp_device {\n\tstruct list_head eh_list_node;  \n\tstruct scsi_lun reset_lun;\n};\n\nenum {\n\tSAS_DEV_GONE,\n\tSAS_DEV_FOUND,  \n\tSAS_DEV_DESTROY,\n\tSAS_DEV_EH_PENDING,\n\tSAS_DEV_LU_RESET,\n\tSAS_DEV_RESET,\n};\n\nstruct domain_device {\n\tspinlock_t done_lock;\n\tenum sas_device_type dev_type;\n\n\tenum sas_linkrate linkrate;\n\tenum sas_linkrate min_linkrate;\n\tenum sas_linkrate max_linkrate;\n\n\tint  pathways;\n\n\tstruct domain_device *parent;\n\tstruct list_head siblings;  \n\tstruct asd_sas_port *port;         \n\tstruct sas_phy *phy;\n\n\tstruct list_head dev_list_node;\n\tstruct list_head disco_list_node;  \n\n\tenum sas_protocol    iproto;\n\tenum sas_protocol    tproto;\n\n\tstruct sas_rphy *rphy;\n\n\tu8  sas_addr[SAS_ADDR_SIZE];\n\tu8  hashed_sas_addr[HASHED_SAS_ADDR_SIZE];\n\n\tu8  frame_rcvd[32];\n\n\tunion {\n\t\tstruct expander_device ex_dev;\n\t\tstruct sata_device     sata_dev;  \n\t\tstruct ssp_device      ssp_dev;\n\t};\n\n\tvoid *lldd_dev;\n\tunsigned long state;\n\tstruct kref kref;\n};\n\nstruct sas_work {\n\tstruct list_head drain_node;\n\tstruct work_struct work;\n};\n\nstatic inline bool dev_is_expander(enum sas_device_type type)\n{\n\treturn type == SAS_EDGE_EXPANDER_DEVICE ||\n\t       type == SAS_FANOUT_EXPANDER_DEVICE;\n}\n\nstatic inline void INIT_SAS_WORK(struct sas_work *sw, void (*fn)(struct work_struct *))\n{\n\tINIT_WORK(&sw->work, fn);\n\tINIT_LIST_HEAD(&sw->drain_node);\n}\n\nstruct sas_discovery_event {\n\tstruct sas_work work;\n\tstruct asd_sas_port *port;\n};\n\nstatic inline struct sas_discovery_event *to_sas_discovery_event(struct work_struct *work)\n{\n\tstruct sas_discovery_event *ev = container_of(work, typeof(*ev), work.work);\n\n\treturn ev;\n}\n\nstruct sas_discovery {\n\tstruct sas_discovery_event disc_work[DISC_NUM_EVENTS];\n\tunsigned long    pending;\n\tu8     fanout_sas_addr[SAS_ADDR_SIZE];\n\tu8     eeds_a[SAS_ADDR_SIZE];\n\tu8     eeds_b[SAS_ADDR_SIZE];\n\tint    max_level;\n};\n\n \nstruct asd_sas_port {\n \n\tstruct sas_discovery disc;\n\tstruct domain_device *port_dev;\n\tspinlock_t dev_list_lock;\n\tstruct list_head dev_list;\n\tstruct list_head disco_list;\n\tstruct list_head destroy_list;\n\tstruct list_head sas_port_del_list;\n\tenum   sas_linkrate linkrate;\n\n\tstruct sas_work work;\n\tint suspended;\n\n \n\tint id;\n\n\tu8               sas_addr[SAS_ADDR_SIZE];\n\tu8               attached_sas_addr[SAS_ADDR_SIZE];\n\tenum sas_protocol   iproto;\n\tenum sas_protocol   tproto;\n\n\tenum sas_oob_mode oob_mode;\n\n\tspinlock_t       phy_list_lock;\n\tstruct list_head phy_list;\n\tint              num_phys;\n\tu32              phy_mask;\n\n\tstruct sas_ha_struct *ha;\n\n\tstruct sas_port\t*port;\n\n\tvoid *lldd_port;\t   \n};\n\nstruct asd_sas_event {\n\tstruct sas_work work;\n\tstruct asd_sas_phy *phy;\n\tint event;\n};\n\nstatic inline struct asd_sas_event *to_asd_sas_event(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = container_of(work, typeof(*ev), work.work);\n\n\treturn ev;\n}\n\nstatic inline void INIT_SAS_EVENT(struct asd_sas_event *ev,\n\t\tvoid (*fn)(struct work_struct *),\n\t\tstruct asd_sas_phy *phy, int event)\n{\n\tINIT_SAS_WORK(&ev->work, fn);\n\tev->phy = phy;\n\tev->event = event;\n}\n\n#define SAS_PHY_SHUTDOWN_THRES   1024\n\n \nstruct asd_sas_phy {\n \n\tatomic_t event_nr;\n\tint in_shutdown;\n\tint error;\n\tint suspended;\n\n\tstruct sas_phy *phy;\n\n \n\t \n\tint            enabled;\t   \n\n\tint            id;\t   \n\tenum sas_protocol iproto;\n\tenum sas_protocol tproto;\n\n\tenum sas_phy_role  role;\n\tenum sas_oob_mode  oob_mode;\n\tenum sas_linkrate linkrate;\n\n\tu8   *sas_addr;\t\t   \n\tu8   attached_sas_addr[SAS_ADDR_SIZE];  \n\n\tspinlock_t     frame_rcvd_lock;\n\tu8             *frame_rcvd;  \n\tint            frame_rcvd_size;\n\n\tspinlock_t     sas_prim_lock;\n\tu32            sas_prim;\n\n\tstruct list_head port_phy_el;  \n\tstruct asd_sas_port      *port;  \n\n\tstruct sas_ha_struct *ha;  \n\n\tvoid *lldd_phy;\t\t   \n};\n\nenum sas_ha_state {\n\tSAS_HA_REGISTERED,\n\tSAS_HA_DRAINING,\n\tSAS_HA_ATA_EH_ACTIVE,\n\tSAS_HA_FROZEN,\n\tSAS_HA_RESUMING,\n};\n\nstruct sas_ha_struct {\n \n\tstruct list_head  defer_q;  \n\tstruct mutex\t  drain_mutex;\n\tunsigned long\t  state;\n\tspinlock_t\t  lock;\n\tint\t\t  eh_active;\n\twait_queue_head_t eh_wait_q;\n\tstruct list_head  eh_dev_q;\n\n\tstruct mutex disco_mutex;\n\n\tstruct Scsi_Host *shost;\n\n \n\tchar *sas_ha_name;\n\tstruct device *dev;\t   \n\n\tstruct workqueue_struct *event_q;\n\tstruct workqueue_struct *disco_q;\n\n\tu8 *sas_addr;\t\t   \n\tu8 hashed_sas_addr[HASHED_SAS_ADDR_SIZE];\n\n\tspinlock_t      phy_port_lock;\n\tstruct asd_sas_phy  **sas_phy;  \n\tstruct asd_sas_port **sas_port;  \n\tint             num_phys;  \n\n\tint strict_wide_ports;  \n\n\tvoid *lldd_ha;\t\t   \n\n\tstruct list_head eh_done_q;   \n\tstruct list_head eh_ata_q;  \n\n\tint event_thres;\n};\n\n#define SHOST_TO_SAS_HA(_shost) (*(struct sas_ha_struct **)(_shost)->hostdata)\n\nstatic inline struct domain_device *\nstarget_to_domain_dev(struct scsi_target *starget) {\n\treturn starget->hostdata;\n}\n\nstatic inline struct domain_device *\nsdev_to_domain_dev(struct scsi_device *sdev) {\n\treturn starget_to_domain_dev(sdev->sdev_target);\n}\n\nstatic inline struct ata_device *sas_to_ata_dev(struct domain_device *dev)\n{\n\treturn &dev->sata_dev.ap->link.device[0];\n}\n\nstatic inline struct domain_device *\ncmd_to_domain_dev(struct scsi_cmnd *cmd)\n{\n\treturn sdev_to_domain_dev(cmd->device);\n}\n\nvoid sas_hash_addr(u8 *hashed, const u8 *sas_addr);\n\n \nstatic inline void sas_phy_disconnected(struct asd_sas_phy *phy)\n{\n\tphy->oob_mode = OOB_NOT_CONNECTED;\n\tphy->linkrate = SAS_LINK_RATE_UNKNOWN;\n}\n\nstatic inline unsigned int to_sas_gpio_od(int device, int bit)\n{\n\treturn 3 * device + bit;\n}\n\nstatic inline void sas_put_local_phy(struct sas_phy *phy)\n{\n\tput_device(&phy->dev);\n}\n\n#ifdef CONFIG_SCSI_SAS_HOST_SMP\nint try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count);\n#else\nstatic inline int try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count)\n{\n\treturn -1;\n}\n#endif\n\n \n \n\nenum service_response {\n\tSAS_TASK_COMPLETE,\n\tSAS_TASK_UNDELIVERED = -1,\n};\n\nenum exec_status {\n\t \n\tSAS_SAM_STAT_GOOD = SAM_STAT_GOOD,\n\tSAS_SAM_STAT_BUSY = SAM_STAT_BUSY,\n\tSAS_SAM_STAT_TASK_ABORTED = SAM_STAT_TASK_ABORTED,\n\tSAS_SAM_STAT_CHECK_CONDITION = SAM_STAT_CHECK_CONDITION,\n\n\tSAS_DEV_NO_RESPONSE = 0x80,\n\tSAS_DATA_UNDERRUN,\n\tSAS_DATA_OVERRUN,\n\tSAS_INTERRUPTED,\n\tSAS_QUEUE_FULL,\n\tSAS_DEVICE_UNKNOWN,\n\tSAS_OPEN_REJECT,\n\tSAS_OPEN_TO,\n\tSAS_PROTO_RESPONSE,\n\tSAS_PHY_DOWN,\n\tSAS_NAK_R_ERR,\n\tSAS_PENDING,\n\tSAS_ABORTED_TASK,\n};\n\n \nstruct ata_task_resp {\n\tu16  frame_len;\n\tu8   ending_fis[ATA_RESP_FIS_SIZE];\t   \n};\n\n#define SAS_STATUS_BUF_SIZE 96\n\nstruct task_status_struct {\n\tenum service_response resp;\n\tenum exec_status      stat;\n\tint  buf_valid_size;\n\n\tu8   buf[SAS_STATUS_BUF_SIZE];\n\n\tu32  residual;\n\tenum sas_open_rej_reason open_rej_reason;\n};\n\n \nstruct sas_ata_task {\n\tstruct host_to_dev_fis fis;\n\tu8     atapi_packet[16];   \n\n\tu8     dma_xfer:1;\t   \n\tu8     use_ncq:1;\n\tu8     return_fis_on_success:1;\n\n\tu8     device_control_reg_update:1;\n\n\tbool   force_phy;\n\tint    force_phy_id;\n};\n\n \nenum sas_internal_abort {\n\tSAS_INTERNAL_ABORT_SINGLE\t= 0,\n\tSAS_INTERNAL_ABORT_DEV\t\t= 1,\n};\n\nstruct sas_internal_abort_task {\n\tenum sas_internal_abort type;\n\tunsigned int qid;\n\tu16 tag;\n};\n\nstruct sas_smp_task {\n\tstruct scatterlist smp_req;\n\tstruct scatterlist smp_resp;\n};\n\nenum task_attribute {\n\tTASK_ATTR_SIMPLE = 0,\n\tTASK_ATTR_HOQ    = 1,\n\tTASK_ATTR_ORDERED= 2,\n\tTASK_ATTR_ACA    = 4,\n};\n\nstruct sas_ssp_task {\n\tu8     LUN[8];\n\tenum   task_attribute task_attr;\n\tstruct scsi_cmnd *cmd;\n};\n\nstruct sas_tmf_task {\n\tu8 tmf;\n\tu16 tag_of_task_to_be_managed;\n};\n\nstruct sas_task {\n\tstruct domain_device *dev;\n\n\tspinlock_t   task_state_lock;\n\tunsigned     task_state_flags;\n\n\tenum   sas_protocol      task_proto;\n\n\tunion {\n\t\tstruct sas_ata_task ata_task;\n\t\tstruct sas_smp_task smp_task;\n\t\tstruct sas_ssp_task ssp_task;\n\t\tstruct sas_internal_abort_task abort_task;\n\t};\n\n\tstruct scatterlist *scatter;\n\tint    num_scatter;\n\tu32    total_xfer_len;\n\tu8     data_dir:2;\t   \n\n\tstruct task_status_struct task_status;\n\tvoid   (*task_done)(struct sas_task *);\n\n\tvoid   *lldd_task;\t   \n\tvoid   *uldd_task;\n\tstruct sas_task_slow *slow_task;\n\tstruct sas_tmf_task *tmf;\n};\n\nstruct sas_task_slow {\n\t \n\tstruct timer_list     timer;\n\tstruct completion     completion;\n\tstruct sas_task       *task;\n};\n\n#define SAS_TASK_STATE_PENDING      1\n#define SAS_TASK_STATE_DONE         2\n#define SAS_TASK_STATE_ABORTED      4\n#define SAS_TASK_NEED_DEV_RESET     8\n\nstatic inline bool sas_is_internal_abort(struct sas_task *task)\n{\n\treturn task->task_proto == SAS_PROTOCOL_INTERNAL_ABORT;\n}\n\nstatic inline struct request *sas_task_find_rq(struct sas_task *task)\n{\n\tstruct scsi_cmnd *scmd;\n\n\tif (task->task_proto & SAS_PROTOCOL_STP_ALL) {\n\t\tstruct ata_queued_cmd *qc = task->uldd_task;\n\n\t\tscmd = qc ? qc->scsicmd : NULL;\n\t} else {\n\t\tscmd = task->uldd_task;\n\t}\n\n\tif (!scmd)\n\t\treturn NULL;\n\n\treturn scsi_cmd_to_rq(scmd);\n}\n\nstruct sas_domain_function_template {\n\t \n\tvoid (*lldd_port_formed)(struct asd_sas_phy *);\n\tvoid (*lldd_port_deformed)(struct asd_sas_phy *);\n\n\t \n\tint  (*lldd_dev_found)(struct domain_device *);\n\tvoid (*lldd_dev_gone)(struct domain_device *);\n\n\tint (*lldd_execute_task)(struct sas_task *, gfp_t gfp_flags);\n\n\t \n\tint (*lldd_abort_task)(struct sas_task *);\n\tint (*lldd_abort_task_set)(struct domain_device *, u8 *lun);\n\tint (*lldd_clear_task_set)(struct domain_device *, u8 *lun);\n\tint (*lldd_I_T_nexus_reset)(struct domain_device *);\n\tint (*lldd_ata_check_ready)(struct domain_device *);\n\tvoid (*lldd_ata_set_dmamode)(struct domain_device *);\n\tint (*lldd_lu_reset)(struct domain_device *, u8 *lun);\n\tint (*lldd_query_task)(struct sas_task *);\n\n\t \n\tvoid (*lldd_tmf_exec_complete)(struct domain_device *dev);\n\tvoid (*lldd_tmf_aborted)(struct sas_task *task);\n\tbool (*lldd_abort_timeout)(struct sas_task *task, void *data);\n\n\t \n\tint (*lldd_clear_nexus_port)(struct asd_sas_port *);\n\tint (*lldd_clear_nexus_ha)(struct sas_ha_struct *);\n\n\t \n\tint (*lldd_control_phy)(struct asd_sas_phy *, enum phy_func, void *);\n\n\t \n\tint (*lldd_write_gpio)(struct sas_ha_struct *, u8 reg_type,\n\t\t\t       u8 reg_index, u8 reg_count, u8 *write_data);\n};\n\nextern int sas_register_ha(struct sas_ha_struct *);\nextern int sas_unregister_ha(struct sas_ha_struct *);\nextern void sas_prep_resume_ha(struct sas_ha_struct *sas_ha);\nextern void sas_resume_ha(struct sas_ha_struct *sas_ha);\nextern void sas_resume_ha_no_sync(struct sas_ha_struct *sas_ha);\nextern void sas_suspend_ha(struct sas_ha_struct *sas_ha);\n\nint sas_set_phy_speed(struct sas_phy *phy, struct sas_phy_linkrates *rates);\nint sas_phy_reset(struct sas_phy *phy, int hard_reset);\nint sas_phy_enable(struct sas_phy *phy, int enable);\nextern int sas_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);\nextern int sas_target_alloc(struct scsi_target *);\nextern int sas_slave_configure(struct scsi_device *);\nextern int sas_change_queue_depth(struct scsi_device *, int new_depth);\nextern int sas_bios_param(struct scsi_device *, struct block_device *,\n\t\t\t  sector_t capacity, int *hsc);\nint sas_execute_internal_abort_single(struct domain_device *device,\n\t\t\t\t      u16 tag, unsigned int qid,\n\t\t\t\t      void *data);\nint sas_execute_internal_abort_dev(struct domain_device *device,\n\t\t\t\t   unsigned int qid, void *data);\nextern struct scsi_transport_template *\nsas_domain_attach_transport(struct sas_domain_function_template *);\nextern struct device_attribute dev_attr_phy_event_threshold;\n\nint  sas_discover_root_expander(struct domain_device *);\n\nint  sas_ex_revalidate_domain(struct domain_device *);\n\nvoid sas_unregister_domain_devices(struct asd_sas_port *port, int gone);\nvoid sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *);\nvoid sas_discover_event(struct asd_sas_port *, enum discover_event ev);\n\nint  sas_discover_end_dev(struct domain_device *);\n\nvoid sas_unregister_dev(struct asd_sas_port *port, struct domain_device *);\n\nvoid sas_init_dev(struct domain_device *);\n\nvoid sas_task_abort(struct sas_task *);\nint sas_eh_abort_handler(struct scsi_cmnd *cmd);\nint sas_eh_device_reset_handler(struct scsi_cmnd *cmd);\nint sas_eh_target_reset_handler(struct scsi_cmnd *cmd);\n\nextern void sas_target_destroy(struct scsi_target *);\nextern int sas_slave_alloc(struct scsi_device *);\nextern int sas_ioctl(struct scsi_device *sdev, unsigned int cmd,\n\t\t     void __user *arg);\nextern int sas_drain_work(struct sas_ha_struct *ha);\n\nextern void sas_ssp_task_response(struct device *dev, struct sas_task *task,\n\t\t\t\t  struct ssp_response_iu *iu);\nstruct sas_phy *sas_get_local_phy(struct domain_device *dev);\n\nint sas_request_addr(struct Scsi_Host *shost, u8 *addr);\n\nint sas_abort_task_set(struct domain_device *dev, u8 *lun);\nint sas_clear_task_set(struct domain_device *dev, u8 *lun);\nint sas_lu_reset(struct domain_device *dev, u8 *lun);\nint sas_query_task(struct sas_task *task, u16 tag);\nint sas_abort_task(struct sas_task *task, u16 tag);\nint sas_find_attached_phy_id(struct expander_device *ex_dev,\n\t\t\t     struct domain_device *dev);\n\nvoid sas_notify_port_event(struct asd_sas_phy *phy, enum port_event event,\n\t\t\t   gfp_t gfp_flags);\nvoid sas_notify_phy_event(struct asd_sas_phy *phy, enum phy_event event,\n\t\t\t   gfp_t gfp_flags);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}