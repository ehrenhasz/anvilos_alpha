{
  "module_name": "scsi_host.h",
  "hash_id": "9710ed5c3186d3a3f3cca96b3e2091a907d2a6aefba95b96740a9f1f82e825dc",
  "original_prompt": "Ingested from linux-6.6.14/include/scsi/scsi_host.h",
  "human_readable_source": " \n#ifndef _SCSI_SCSI_HOST_H\n#define _SCSI_SCSI_HOST_H\n\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/blk-mq.h>\n#include <scsi/scsi.h>\n\nstruct block_device;\nstruct completion;\nstruct module;\nstruct scsi_cmnd;\nstruct scsi_device;\nstruct scsi_target;\nstruct Scsi_Host;\nstruct scsi_transport_template;\n\n\n#define SG_ALL\tSG_CHUNK_SIZE\n\n#define MODE_UNKNOWN 0x00\n#define MODE_INITIATOR 0x01\n#define MODE_TARGET 0x02\n\n \nenum scsi_timeout_action {\n\tSCSI_EH_DONE,\n\tSCSI_EH_RESET_TIMER,\n\tSCSI_EH_NOT_HANDLED,\n};\n\nstruct scsi_host_template {\n\t \n\n\t \n\tunsigned int cmd_size;\n\n\t \n\tint (* queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);\n\n\t \n\tvoid (*commit_rqs)(struct Scsi_Host *, u16);\n\n\tstruct module *module;\n\tconst char *name;\n\n\t \n\tconst char *(*info)(struct Scsi_Host *);\n\n\t \n\tint (*ioctl)(struct scsi_device *dev, unsigned int cmd,\n\t\t     void __user *arg);\n\n\n#ifdef CONFIG_COMPAT\n\t \n\tint (*compat_ioctl)(struct scsi_device *dev, unsigned int cmd,\n\t\t\t    void __user *arg);\n#endif\n\n\tint (*init_cmd_priv)(struct Scsi_Host *shost, struct scsi_cmnd *cmd);\n\tint (*exit_cmd_priv)(struct Scsi_Host *shost, struct scsi_cmnd *cmd);\n\n\t \n\tint (* eh_abort_handler)(struct scsi_cmnd *);\n\tint (* eh_device_reset_handler)(struct scsi_cmnd *);\n\tint (* eh_target_reset_handler)(struct scsi_cmnd *);\n\tint (* eh_bus_reset_handler)(struct scsi_cmnd *);\n\tint (* eh_host_reset_handler)(struct scsi_cmnd *);\n\n\t \n\tint (* slave_alloc)(struct scsi_device *);\n\n\t \n\tint (* slave_configure)(struct scsi_device *);\n\n\t \n\tvoid (* slave_destroy)(struct scsi_device *);\n\n\t \n\tint (* target_alloc)(struct scsi_target *);\n\n\t \n\tvoid (* target_destroy)(struct scsi_target *);\n\n\t \n\tint (* scan_finished)(struct Scsi_Host *, unsigned long);\n\n\t \n\tvoid (* scan_start)(struct Scsi_Host *);\n\n\t \n\tint (* change_queue_depth)(struct scsi_device *, int);\n\n\t \n\tvoid (* map_queues)(struct Scsi_Host *shost);\n\n\t \n\tint (* mq_poll)(struct Scsi_Host *shost, unsigned int queue_num);\n\n\t \n\tbool (* dma_need_drain)(struct request *rq);\n\n\t \n\tint (* bios_param)(struct scsi_device *, struct block_device *,\n\t\t\tsector_t, int []);\n\n\t \n\tvoid (*unlock_native_capacity)(struct scsi_device *);\n\n\t \n\tint (*show_info)(struct seq_file *, struct Scsi_Host *);\n\tint (*write_info)(struct Scsi_Host *, char *, int);\n\n\t \n\tenum scsi_timeout_action (*eh_timed_out)(struct scsi_cmnd *);\n\t \n\tbool (*eh_should_retry_cmd)(struct scsi_cmnd *scmd);\n\n\t \n\n\tint (*host_reset)(struct Scsi_Host *shost, int reset_type);\n#define SCSI_ADAPTER_RESET\t1\n#define SCSI_FIRMWARE_RESET\t2\n\n\n\t \n\tconst char *proc_name;\n\n\t \n\tint can_queue;\n\n\t \n\tint this_id;\n\n\t \n\tunsigned short sg_tablesize;\n\tunsigned short sg_prot_tablesize;\n\n\t \n\tunsigned int max_sectors;\n\n\t \n\tunsigned int max_segment_size;\n\n\t \n\tunsigned long dma_boundary;\n\n\tunsigned long virt_boundary_mask;\n\n\t \n#define SCSI_DEFAULT_MAX_SECTORS\t1024\n\n\t \n\tshort cmd_per_lun;\n\n\t \n\tint tag_alloc_policy;\n\n\t \n\tunsigned track_queue_depth:1;\n\n\t \n\tunsigned supported_mode:2;\n\n\t \n\tunsigned emulated:1;\n\n\t \n\tunsigned skip_settle_delay:1;\n\n\t \n\tunsigned no_write_same:1;\n\n\t \n\tunsigned host_tagset:1;\n\n\t \n\tunsigned queuecommand_may_block:1;\n\n\t \n\tunsigned int max_host_blocked;\n\n\t \n#define SCSI_DEFAULT_HOST_BLOCKED\t7\n\n\t \n\tconst struct attribute_group **shost_groups;\n\n\t \n\tconst struct attribute_group **sdev_groups;\n\n\t \n\tu64 vendor_id;\n\n\t \n\tint rpm_autosuspend_delay;\n};\n\n \n#define DEF_SCSI_QCMD(func_name) \\\n\tint func_name(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tunsigned long irq_flags;\t\t\t\t\\\n\t\tint rc;\t\t\t\t\t\t\t\\\n\t\tspin_lock_irqsave(shost->host_lock, irq_flags);\t\t\\\n\t\trc = func_name##_lck(cmd);\t\t\t\t\\\n\t\tspin_unlock_irqrestore(shost->host_lock, irq_flags);\t\\\n\t\treturn rc;\t\t\t\t\t\t\\\n\t}\n\n\n \nenum scsi_host_state {\n\tSHOST_CREATED = 1,\n\tSHOST_RUNNING,\n\tSHOST_CANCEL,\n\tSHOST_DEL,\n\tSHOST_RECOVERY,\n\tSHOST_CANCEL_RECOVERY,\n\tSHOST_DEL_RECOVERY,\n};\n\nstruct Scsi_Host {\n\t \n\tstruct list_head\t__devices;\n\tstruct list_head\t__targets;\n\t\n\tstruct list_head\tstarved_list;\n\n\tspinlock_t\t\tdefault_lock;\n\tspinlock_t\t\t*host_lock;\n\n\tstruct mutex\t\tscan_mutex; \n\n\tstruct list_head\teh_abort_list;\n\tstruct list_head\teh_cmd_q;\n\tstruct task_struct    * ehandler;   \n\tstruct completion     * eh_action;  \n\twait_queue_head_t       host_wait;\n\tconst struct scsi_host_template *hostt;\n\tstruct scsi_transport_template *transportt;\n\n\tstruct kref\t\ttagset_refcnt;\n\tstruct completion\ttagset_freed;\n\t \n\tstruct blk_mq_tag_set\ttag_set;\n\n\tatomic_t host_blocked;\n\n\tunsigned int host_failed;\t    \n\tunsigned int host_eh_scheduled;     \n    \n\tunsigned int host_no;   \n\n\t \n\tint eh_deadline;\n\tunsigned long last_reset;\n\n\n\t \n\tunsigned int max_channel;\n\tunsigned int max_id;\n\tu64 max_lun;\n\n\t \n\tunsigned int unique_id;\n\n\t \n\tunsigned short max_cmd_len;\n\n\tint this_id;\n\tint can_queue;\n\tshort cmd_per_lun;\n\tshort unsigned int sg_tablesize;\n\tshort unsigned int sg_prot_tablesize;\n\tunsigned int max_sectors;\n\tunsigned int opt_sectors;\n\tunsigned int max_segment_size;\n\tunsigned long dma_boundary;\n\tunsigned long virt_boundary_mask;\n\t \n\tunsigned nr_hw_queues;\n\tunsigned nr_maps;\n\tunsigned active_mode:2;\n\n\t \n\tunsigned host_self_blocked:1;\n    \n\t \n\tunsigned reverse_ordering:1;\n\n\t \n\tunsigned tmf_in_progress:1;\n\n\t \n\tunsigned async_scan:1;\n\n\t \n\tunsigned eh_noresume:1;\n\n\t \n\tunsigned no_write_same:1;\n\n\t \n\tunsigned host_tagset:1;\n\n\t \n\tunsigned queuecommand_may_block:1;\n\n\t \n\tunsigned short_inquiry:1;\n\n\t \n\tunsigned no_scsi2_lun_in_cdb:1;\n\n\t \n\tchar work_q_name[20];\n\tstruct workqueue_struct *work_q;\n\n\t \n\tstruct workqueue_struct *tmf_work_q;\n\n\t \n\tunsigned int max_host_blocked;\n\n\t \n\tunsigned int prot_capabilities;\n\tunsigned char prot_guard_type;\n\n\t \n\tunsigned long base;\n\tunsigned long io_port;\n\tunsigned char n_io_port;\n\tunsigned char dma_channel;\n\tunsigned int  irq;\n\t\n\n\tenum scsi_host_state shost_state;\n\n\t \n\tstruct device\t\tshost_gendev, shost_dev;\n\n\t \n\tvoid *shost_data;\n\n\t \n\tstruct device *dma_dev;\n\n\t \n\tunsigned long hostdata[]   \n\t\t__attribute__ ((aligned (sizeof(unsigned long))));\n};\n\n#define\t\tclass_to_shost(d)\t\\\n\tcontainer_of(d, struct Scsi_Host, shost_dev)\n\n#define shost_printk(prefix, shost, fmt, a...)\t\\\n\tdev_printk(prefix, &(shost)->shost_gendev, fmt, ##a)\n\nstatic inline void *shost_priv(struct Scsi_Host *shost)\n{\n\treturn (void *)shost->hostdata;\n}\n\nint scsi_is_host_device(const struct device *);\n\nstatic inline struct Scsi_Host *dev_to_shost(struct device *dev)\n{\n\twhile (!scsi_is_host_device(dev)) {\n\t\tif (!dev->parent)\n\t\t\treturn NULL;\n\t\tdev = dev->parent;\n\t}\n\treturn container_of(dev, struct Scsi_Host, shost_gendev);\n}\n\nstatic inline int scsi_host_in_recovery(struct Scsi_Host *shost)\n{\n\treturn shost->shost_state == SHOST_RECOVERY ||\n\t\tshost->shost_state == SHOST_CANCEL_RECOVERY ||\n\t\tshost->shost_state == SHOST_DEL_RECOVERY ||\n\t\tshost->tmf_in_progress;\n}\n\nextern int scsi_queue_work(struct Scsi_Host *, struct work_struct *);\nextern void scsi_flush_work(struct Scsi_Host *);\n\nextern struct Scsi_Host *scsi_host_alloc(const struct scsi_host_template *, int);\nextern int __must_check scsi_add_host_with_dma(struct Scsi_Host *,\n\t\t\t\t\t       struct device *,\n\t\t\t\t\t       struct device *);\n#if defined(CONFIG_SCSI_PROC_FS)\nstruct proc_dir_entry *\nscsi_template_proc_dir(const struct scsi_host_template *sht);\n#else\n#define scsi_template_proc_dir(sht) NULL\n#endif\nextern void scsi_scan_host(struct Scsi_Host *);\nextern int scsi_rescan_device(struct scsi_device *sdev);\nextern void scsi_remove_host(struct Scsi_Host *);\nextern struct Scsi_Host *scsi_host_get(struct Scsi_Host *);\nextern int scsi_host_busy(struct Scsi_Host *shost);\nextern void scsi_host_put(struct Scsi_Host *t);\nextern struct Scsi_Host *scsi_host_lookup(unsigned int hostnum);\nextern const char *scsi_host_state_name(enum scsi_host_state);\nextern void scsi_host_complete_all_commands(struct Scsi_Host *shost,\n\t\t\t\t\t    enum scsi_host_status status);\n\nstatic inline int __must_check scsi_add_host(struct Scsi_Host *host,\n\t\t\t\t\t     struct device *dev)\n{\n\treturn scsi_add_host_with_dma(host, dev, dev);\n}\n\nstatic inline struct device *scsi_get_device(struct Scsi_Host *shost)\n{\n        return shost->shost_gendev.parent;\n}\n\n \nstatic inline int scsi_host_scan_allowed(struct Scsi_Host *shost)\n{\n\treturn shost->shost_state == SHOST_RUNNING ||\n\t       shost->shost_state == SHOST_RECOVERY;\n}\n\nextern void scsi_unblock_requests(struct Scsi_Host *);\nextern void scsi_block_requests(struct Scsi_Host *);\nextern int scsi_host_block(struct Scsi_Host *shost);\nextern int scsi_host_unblock(struct Scsi_Host *shost, int new_state);\n\nvoid scsi_host_busy_iter(struct Scsi_Host *,\n\t\t\t bool (*fn)(struct scsi_cmnd *, void *), void *priv);\n\nstruct class_container;\n\n \nenum scsi_host_prot_capabilities {\n\tSHOST_DIF_TYPE1_PROTECTION = 1 << 0,  \n\tSHOST_DIF_TYPE2_PROTECTION = 1 << 1,  \n\tSHOST_DIF_TYPE3_PROTECTION = 1 << 2,  \n\n\tSHOST_DIX_TYPE0_PROTECTION = 1 << 3,  \n\tSHOST_DIX_TYPE1_PROTECTION = 1 << 4,  \n\tSHOST_DIX_TYPE2_PROTECTION = 1 << 5,  \n\tSHOST_DIX_TYPE3_PROTECTION = 1 << 6,  \n};\n\n \nstatic inline void scsi_host_set_prot(struct Scsi_Host *shost, unsigned int mask)\n{\n\tshost->prot_capabilities = mask;\n}\n\nstatic inline unsigned int scsi_host_get_prot(struct Scsi_Host *shost)\n{\n\treturn shost->prot_capabilities;\n}\n\nstatic inline int scsi_host_prot_dma(struct Scsi_Host *shost)\n{\n\treturn shost->prot_capabilities >= SHOST_DIX_TYPE0_PROTECTION;\n}\n\nstatic inline unsigned int scsi_host_dif_capable(struct Scsi_Host *shost, unsigned int target_type)\n{\n\tstatic unsigned char cap[] = { 0,\n\t\t\t\t       SHOST_DIF_TYPE1_PROTECTION,\n\t\t\t\t       SHOST_DIF_TYPE2_PROTECTION,\n\t\t\t\t       SHOST_DIF_TYPE3_PROTECTION };\n\n\tif (target_type >= ARRAY_SIZE(cap))\n\t\treturn 0;\n\n\treturn shost->prot_capabilities & cap[target_type] ? target_type : 0;\n}\n\nstatic inline unsigned int scsi_host_dix_capable(struct Scsi_Host *shost, unsigned int target_type)\n{\n#if defined(CONFIG_BLK_DEV_INTEGRITY)\n\tstatic unsigned char cap[] = { SHOST_DIX_TYPE0_PROTECTION,\n\t\t\t\t       SHOST_DIX_TYPE1_PROTECTION,\n\t\t\t\t       SHOST_DIX_TYPE2_PROTECTION,\n\t\t\t\t       SHOST_DIX_TYPE3_PROTECTION };\n\n\tif (target_type >= ARRAY_SIZE(cap))\n\t\treturn 0;\n\n\treturn shost->prot_capabilities & cap[target_type];\n#endif\n\treturn 0;\n}\n\n \n\nenum scsi_host_guard_type {\n\tSHOST_DIX_GUARD_CRC = 1 << 0,\n\tSHOST_DIX_GUARD_IP  = 1 << 1,\n};\n\nstatic inline void scsi_host_set_guard(struct Scsi_Host *shost, unsigned char type)\n{\n\tshost->prot_guard_type = type;\n}\n\nstatic inline unsigned char scsi_host_get_guard(struct Scsi_Host *shost)\n{\n\treturn shost->prot_guard_type;\n}\n\nextern int scsi_host_set_state(struct Scsi_Host *, enum scsi_host_state);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}