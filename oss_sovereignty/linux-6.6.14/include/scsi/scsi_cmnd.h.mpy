{
  "module_name": "scsi_cmnd.h",
  "hash_id": "e7ccccabf40619ed64672f1332d5aa3c8cceb68ec317fd07d73578f99af2eeb5",
  "original_prompt": "Ingested from linux-6.6.14/include/scsi/scsi_cmnd.h",
  "human_readable_source": " \n#ifndef _SCSI_SCSI_CMND_H\n#define _SCSI_SCSI_CMND_H\n\n#include <linux/dma-mapping.h>\n#include <linux/blkdev.h>\n#include <linux/t10-pi.h>\n#include <linux/list.h>\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/scatterlist.h>\n#include <scsi/scsi_device.h>\n\nstruct Scsi_Host;\n\n \n#define MAX_COMMAND_SIZE 16\n\nstruct scsi_data_buffer {\n\tstruct sg_table table;\n\tunsigned length;\n};\n\n \nstruct scsi_pointer {\n\tchar *ptr;\t\t \n\tint this_residual;\t \n\tstruct scatterlist *buffer;\t \n\tint buffers_residual;\t \n\n        dma_addr_t dma_handle;\n\n\tvolatile int Status;\n\tvolatile int Message;\n\tvolatile int have_data_in;\n\tvolatile int sent_command;\n\tvolatile int phase;\n};\n\n \n#define SCMD_TAGGED\t\t(1 << 0)\n#define SCMD_INITIALIZED\t(1 << 1)\n#define SCMD_LAST\t\t(1 << 2)\n \n#define SCMD_FORCE_EH_SUCCESS\t(1 << 3)\n#define SCMD_FAIL_IF_RECOVERING\t(1 << 4)\n \n#define SCMD_PRESERVED_FLAGS\t(SCMD_INITIALIZED | SCMD_FAIL_IF_RECOVERING)\n\n \n#define SCMD_STATE_COMPLETE\t0\n#define SCMD_STATE_INFLIGHT\t1\n\nenum scsi_cmnd_submitter {\n\tSUBMITTED_BY_BLOCK_LAYER = 0,\n\tSUBMITTED_BY_SCSI_ERROR_HANDLER = 1,\n\tSUBMITTED_BY_SCSI_RESET_IOCTL = 2,\n} __packed;\n\nstruct scsi_cmnd {\n\tstruct scsi_device *device;\n\tstruct list_head eh_entry;  \n\tstruct delayed_work abort_work;\n\n\tstruct rcu_head rcu;\n\n\tint eh_eflags;\t\t \n\n\tint budget_token;\n\n\t \n\tunsigned long jiffies_at_alloc;\n\n\tint retries;\n\tint allowed;\n\n\tunsigned char prot_op;\n\tunsigned char prot_type;\n\tunsigned char prot_flags;\n\tenum scsi_cmnd_submitter submitter;\n\n\tunsigned short cmd_len;\n\tenum dma_data_direction sc_data_direction;\n\n\tunsigned char cmnd[32];  \n\n\t \n\tstruct scsi_data_buffer sdb;\n\tstruct scsi_data_buffer *prot_sdb;\n\n\tunsigned underflow;\t \n\n\tunsigned transfersize;\t \n\tunsigned resid_len;\t \n\tunsigned sense_len;\n\tunsigned char *sense_buffer;\n\t\t\t\t \n\n\tint flags;\t\t \n\tunsigned long state;\t \n\n\tunsigned int extra_len;\t \n\n\t \n\n\tunsigned char *host_scribble;\t \n\n\tint result;\t\t \n};\n\n \nstatic inline struct request *scsi_cmd_to_rq(struct scsi_cmnd *scmd)\n{\n\treturn blk_mq_rq_from_pdu(scmd);\n}\n\n \nstatic inline void *scsi_cmd_priv(struct scsi_cmnd *cmd)\n{\n\treturn cmd + 1;\n}\n\nvoid scsi_done(struct scsi_cmnd *cmd);\nvoid scsi_done_direct(struct scsi_cmnd *cmd);\n\nextern void scsi_finish_command(struct scsi_cmnd *cmd);\n\nextern void *scsi_kmap_atomic_sg(struct scatterlist *sg, int sg_count,\n\t\t\t\t size_t *offset, size_t *len);\nextern void scsi_kunmap_atomic_sg(void *virt);\n\nblk_status_t scsi_alloc_sgtables(struct scsi_cmnd *cmd);\nvoid scsi_free_sgtables(struct scsi_cmnd *cmd);\n\n#ifdef CONFIG_SCSI_DMA\nextern int scsi_dma_map(struct scsi_cmnd *cmd);\nextern void scsi_dma_unmap(struct scsi_cmnd *cmd);\n#else  \nstatic inline int scsi_dma_map(struct scsi_cmnd *cmd) { return -ENOSYS; }\nstatic inline void scsi_dma_unmap(struct scsi_cmnd *cmd) { }\n#endif  \n\nstatic inline unsigned scsi_sg_count(struct scsi_cmnd *cmd)\n{\n\treturn cmd->sdb.table.nents;\n}\n\nstatic inline struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd)\n{\n\treturn cmd->sdb.table.sgl;\n}\n\nstatic inline unsigned scsi_bufflen(struct scsi_cmnd *cmd)\n{\n\treturn cmd->sdb.length;\n}\n\nstatic inline void scsi_set_resid(struct scsi_cmnd *cmd, unsigned int resid)\n{\n\tcmd->resid_len = resid;\n}\n\nstatic inline unsigned int scsi_get_resid(struct scsi_cmnd *cmd)\n{\n\treturn cmd->resid_len;\n}\n\n#define scsi_for_each_sg(cmd, sg, nseg, __i)\t\t\t\\\n\tfor_each_sg(scsi_sglist(cmd), sg, nseg, __i)\n\nstatic inline int scsi_sg_copy_from_buffer(struct scsi_cmnd *cmd,\n\t\t\t\t\t   const void *buf, int buflen)\n{\n\treturn sg_copy_from_buffer(scsi_sglist(cmd), scsi_sg_count(cmd),\n\t\t\t\t   buf, buflen);\n}\n\nstatic inline int scsi_sg_copy_to_buffer(struct scsi_cmnd *cmd,\n\t\t\t\t\t void *buf, int buflen)\n{\n\treturn sg_copy_to_buffer(scsi_sglist(cmd), scsi_sg_count(cmd),\n\t\t\t\t buf, buflen);\n}\n\nstatic inline sector_t scsi_get_sector(struct scsi_cmnd *scmd)\n{\n\treturn blk_rq_pos(scsi_cmd_to_rq(scmd));\n}\n\nstatic inline sector_t scsi_get_lba(struct scsi_cmnd *scmd)\n{\n\tunsigned int shift = ilog2(scmd->device->sector_size) - SECTOR_SHIFT;\n\n\treturn blk_rq_pos(scsi_cmd_to_rq(scmd)) >> shift;\n}\n\nstatic inline unsigned int scsi_logical_block_count(struct scsi_cmnd *scmd)\n{\n\tunsigned int shift = ilog2(scmd->device->sector_size) - SECTOR_SHIFT;\n\n\treturn blk_rq_bytes(scsi_cmd_to_rq(scmd)) >> shift;\n}\n\n \nenum scsi_prot_operations {\n\t \n\tSCSI_PROT_NORMAL = 0,\n\n\t \n\tSCSI_PROT_READ_INSERT,\n\tSCSI_PROT_WRITE_STRIP,\n\n\t \n\tSCSI_PROT_READ_STRIP,\n\tSCSI_PROT_WRITE_INSERT,\n\n\t \n\tSCSI_PROT_READ_PASS,\n\tSCSI_PROT_WRITE_PASS,\n};\n\nstatic inline void scsi_set_prot_op(struct scsi_cmnd *scmd, unsigned char op)\n{\n\tscmd->prot_op = op;\n}\n\nstatic inline unsigned char scsi_get_prot_op(struct scsi_cmnd *scmd)\n{\n\treturn scmd->prot_op;\n}\n\nenum scsi_prot_flags {\n\tSCSI_PROT_TRANSFER_PI\t\t= 1 << 0,\n\tSCSI_PROT_GUARD_CHECK\t\t= 1 << 1,\n\tSCSI_PROT_REF_CHECK\t\t= 1 << 2,\n\tSCSI_PROT_REF_INCREMENT\t\t= 1 << 3,\n\tSCSI_PROT_IP_CHECKSUM\t\t= 1 << 4,\n};\n\n \nenum scsi_prot_target_type {\n\tSCSI_PROT_DIF_TYPE0 = 0,\n\tSCSI_PROT_DIF_TYPE1,\n\tSCSI_PROT_DIF_TYPE2,\n\tSCSI_PROT_DIF_TYPE3,\n};\n\nstatic inline void scsi_set_prot_type(struct scsi_cmnd *scmd, unsigned char type)\n{\n\tscmd->prot_type = type;\n}\n\nstatic inline unsigned char scsi_get_prot_type(struct scsi_cmnd *scmd)\n{\n\treturn scmd->prot_type;\n}\n\nstatic inline u32 scsi_prot_ref_tag(struct scsi_cmnd *scmd)\n{\n\tstruct request *rq = blk_mq_rq_from_pdu(scmd);\n\n\treturn t10_pi_ref_tag(rq);\n}\n\nstatic inline unsigned int scsi_prot_interval(struct scsi_cmnd *scmd)\n{\n\treturn scmd->device->sector_size;\n}\n\nstatic inline unsigned scsi_prot_sg_count(struct scsi_cmnd *cmd)\n{\n\treturn cmd->prot_sdb ? cmd->prot_sdb->table.nents : 0;\n}\n\nstatic inline struct scatterlist *scsi_prot_sglist(struct scsi_cmnd *cmd)\n{\n\treturn cmd->prot_sdb ? cmd->prot_sdb->table.sgl : NULL;\n}\n\nstatic inline struct scsi_data_buffer *scsi_prot(struct scsi_cmnd *cmd)\n{\n\treturn cmd->prot_sdb;\n}\n\n#define scsi_for_each_prot_sg(cmd, sg, nseg, __i)\t\t\\\n\tfor_each_sg(scsi_prot_sglist(cmd), sg, nseg, __i)\n\nstatic inline void set_status_byte(struct scsi_cmnd *cmd, char status)\n{\n\tcmd->result = (cmd->result & 0xffffff00) | status;\n}\n\nstatic inline u8 get_status_byte(struct scsi_cmnd *cmd)\n{\n\treturn cmd->result & 0xff;\n}\n\nstatic inline void set_host_byte(struct scsi_cmnd *cmd, char status)\n{\n\tcmd->result = (cmd->result & 0xff00ffff) | (status << 16);\n}\n\nstatic inline u8 get_host_byte(struct scsi_cmnd *cmd)\n{\n\treturn (cmd->result >> 16) & 0xff;\n}\n\n \nstatic inline void scsi_msg_to_host_byte(struct scsi_cmnd *cmd, u8 msg)\n{\n\tswitch (msg) {\n\tcase COMMAND_COMPLETE:\n\t\tbreak;\n\tcase ABORT_TASK_SET:\n\t\tset_host_byte(cmd, DID_ABORT);\n\t\tbreak;\n\tcase TARGET_RESET:\n\t\tset_host_byte(cmd, DID_RESET);\n\t\tbreak;\n\tdefault:\n\t\tset_host_byte(cmd, DID_ERROR);\n\t\tbreak;\n\t}\n}\n\nstatic inline unsigned scsi_transfer_length(struct scsi_cmnd *scmd)\n{\n\tunsigned int xfer_len = scmd->sdb.length;\n\tunsigned int prot_interval = scsi_prot_interval(scmd);\n\n\tif (scmd->prot_flags & SCSI_PROT_TRANSFER_PI)\n\t\txfer_len += (xfer_len >> ilog2(prot_interval)) * 8;\n\n\treturn xfer_len;\n}\n\nextern void scsi_build_sense(struct scsi_cmnd *scmd, int desc,\n\t\t\t     u8 key, u8 asc, u8 ascq);\n\nstruct request *scsi_alloc_request(struct request_queue *q, blk_opf_t opf,\n\t\t\t\t   blk_mq_req_flags_t flags);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}