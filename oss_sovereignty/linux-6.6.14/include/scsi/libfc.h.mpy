{
  "module_name": "libfc.h",
  "hash_id": "a99cf9b0dd8e2a812c2fe16eb82ca65c53f0c0bc165286cf4f7c8f1024c56421",
  "original_prompt": "Ingested from linux-6.6.14/include/scsi/libfc.h",
  "human_readable_source": " \n \n\n#ifndef _LIBFC_H_\n#define _LIBFC_H_\n\n#include <linux/timer.h>\n#include <linux/if.h>\n#include <linux/percpu.h>\n#include <linux/refcount.h>\n\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/scsi_bsg_fc.h>\n\n#include <scsi/fc/fc_fcp.h>\n#include <scsi/fc/fc_ns.h>\n#include <scsi/fc/fc_ms.h>\n#include <scsi/fc/fc_els.h>\n#include <scsi/fc/fc_gs.h>\n\n#include <scsi/fc_frame.h>\n\n#define\tFC_FC4_PROV_SIZE\t(FC_TYPE_FCP + 1)\t \n\n \n#define\tFC_NO_ERR\t0\t \n#define\tFC_EX_TIMEOUT\t1\t \n#define\tFC_EX_CLOSED\t2\t \n#define FC_EX_ALLOC_ERR\t3\t \n#define FC_EX_XMIT_ERR\t4\t \n#define FC_EX_ELS_RJT\t5\t \n#define FC_EX_INV_LOGIN\t6\t \n#define FC_EX_SEQ_ERR\t6\t \n\n \nenum fc_lport_state {\n\tLPORT_ST_DISABLED = 0,\n\tLPORT_ST_FLOGI,\n\tLPORT_ST_DNS,\n\tLPORT_ST_RNN_ID,\n\tLPORT_ST_RSNN_NN,\n\tLPORT_ST_RSPN_ID,\n\tLPORT_ST_RFT_ID,\n\tLPORT_ST_RFF_ID,\n\tLPORT_ST_FDMI,\n\tLPORT_ST_RHBA,\n\tLPORT_ST_RPA,\n\tLPORT_ST_DHBA,\n\tLPORT_ST_DPRT,\n\tLPORT_ST_SCR,\n\tLPORT_ST_READY,\n\tLPORT_ST_LOGO,\n\tLPORT_ST_RESET\n};\n\nenum fc_disc_event {\n\tDISC_EV_NONE = 0,\n\tDISC_EV_SUCCESS,\n\tDISC_EV_FAILED\n};\n\n \nenum fc_rport_state {\n\tRPORT_ST_INIT,\n\tRPORT_ST_FLOGI,\n\tRPORT_ST_PLOGI_WAIT,\n\tRPORT_ST_PLOGI,\n\tRPORT_ST_PRLI,\n\tRPORT_ST_RTV,\n\tRPORT_ST_READY,\n\tRPORT_ST_ADISC,\n\tRPORT_ST_DELETE,\n};\n\n \nstruct fc_disc_port {\n\tstruct fc_lport    *lp;\n\tstruct list_head   peers;\n\tstruct work_struct rport_work;\n\tu32\t\t   port_id;\n};\n\n \nenum fc_rport_event {\n\tRPORT_EV_NONE = 0,\n\tRPORT_EV_READY,\n\tRPORT_EV_FAILED,\n\tRPORT_EV_STOP,\n\tRPORT_EV_LOGO\n};\n\nstruct fc_rport_priv;\n\n \nstruct fc_rport_operations {\n\tvoid (*event_callback)(struct fc_lport *, struct fc_rport_priv *,\n\t\t\t       enum fc_rport_event);\n};\n\n \nstruct fc_rport_libfc_priv {\n\tstruct fc_lport\t\t   *local_port;\n\tenum fc_rport_state\t   rp_state;\n\tu16\t\t\t   flags;\n\t#define FC_RP_FLAGS_REC_SUPPORTED\t(1 << 0)\n\t#define FC_RP_FLAGS_RETRY\t\t(1 << 1)\n\t#define FC_RP_STARTED\t\t\t(1 << 2)\n\t#define FC_RP_FLAGS_CONF_REQ\t\t(1 << 3)\n\tunsigned int\t\t   e_d_tov;\n\tunsigned int\t\t   r_a_tov;\n};\n\n \nstruct fc_rport_priv {\n\tstruct fc_lport\t\t    *local_port;\n\tstruct fc_rport\t\t    *rport;\n\tstruct kref\t\t    kref;\n\tenum fc_rport_state\t    rp_state;\n\tstruct fc_rport_identifiers ids;\n\tu16\t\t\t    flags;\n\tu16\t\t\t    max_seq;\n\tu16\t\t\t    disc_id;\n\tu16\t\t\t    maxframe_size;\n\tunsigned int\t\t    retries;\n\tunsigned int\t\t    major_retries;\n\tunsigned int\t\t    e_d_tov;\n\tunsigned int\t\t    r_a_tov;\n\tstruct mutex\t\t    rp_mutex;\n\tstruct delayed_work\t    retry_work;\n\tenum fc_rport_event\t    event;\n\tstruct fc_rport_operations  *ops;\n\tstruct list_head\t    peers;\n\tstruct work_struct\t    event_work;\n\tu32\t\t\t    supported_classes;\n\tu16\t\t\t    prli_count;\n\tstruct rcu_head\t\t    rcu;\n\tu16\t\t\t    sp_features;\n\tu8\t\t\t    spp_type;\n\tvoid\t\t\t    (*lld_event_callback)(struct fc_lport *,\n\t\t\t\t\t\t      struct fc_rport_priv *,\n\t\t\t\t\t\t      enum fc_rport_event);\n};\n\n \nstruct fc_stats {\n\tu64\t\tSecondsSinceLastReset;\n\tu64\t\tTxFrames;\n\tu64\t\tTxWords;\n\tu64\t\tRxFrames;\n\tu64\t\tRxWords;\n\tu64\t\tErrorFrames;\n\tu64\t\tDumpedFrames;\n\tu64\t\tFcpPktAllocFails;\n\tu64\t\tFcpPktAborts;\n\tu64\t\tFcpFrameAllocFails;\n\tu64\t\tLinkFailureCount;\n\tu64\t\tLossOfSignalCount;\n\tu64\t\tInvalidTxWordCount;\n\tu64\t\tInvalidCRCCount;\n\tu64\t\tInputRequests;\n\tu64\t\tOutputRequests;\n\tu64\t\tControlRequests;\n\tu64\t\tInputBytes;\n\tu64\t\tOutputBytes;\n\tu64\t\tVLinkFailureCount;\n\tu64\t\tMissDiscAdvCount;\n};\n\n \nstruct fc_seq_els_data {\n\tenum fc_els_rjt_reason reason;\n\tenum fc_els_rjt_explan explan;\n};\n\n \nstruct fc_fcp_pkt {\n\tspinlock_t\t  scsi_pkt_lock;\n\trefcount_t\t  ref_cnt;\n\n\t \n\tu32\t\t  data_len;\n\n\t \n\tstruct scsi_cmnd  *cmd;\n\tstruct list_head  list;\n\n\t \n\tstruct fc_lport   *lp;\n\tu8\t\t  state;\n\n\t \n\tu8\t\t  cdb_status;\n\tu8\t\t  status_code;\n\tu8\t\t  scsi_comp_flags;\n\tu32\t\t  io_status;\n\tu32\t\t  req_flags;\n\tu32\t\t  scsi_resid;\n\n\t \n\tsize_t\t\t  xfer_len;\n\tstruct fcp_cmnd   cdb_cmd;\n\tu32\t\t  xfer_contig_end;\n\tu16\t\t  max_payload;\n\tu16\t\t  xfer_ddp;\n\n\t \n\tstruct fc_rport\t  *rport;\n\tstruct fc_seq\t  *seq_ptr;\n\n\t \n\tstruct timer_list timer;\n\tint\t\t  wait_for_comp;\n\tint\t\t  timer_delay;\n\tu32\t\t  recov_retry;\n\tstruct fc_seq\t  *recov_seq;\n\tstruct completion tm_done;\n} ____cacheline_aligned_in_smp;\n\n \nstruct libfc_cmd_priv {\n\tstruct fc_fcp_pkt *fsp;\n\tu32 resid_len;\n\tu8 status;\n};\n\n \n\nstruct fc_exch_mgr;\nstruct fc_exch_mgr_anchor;\nextern u16 fc_cpu_mask;\t \n\n \nstruct fc_seq {\n\tu8  id;\n\tu16 ssb_stat;\n\tu16 cnt;\n\tu32 rec_data;\n};\n\n#define FC_EX_DONE\t\t(1 << 0)  \n#define FC_EX_RST_CLEANUP\t(1 << 1)  \n#define FC_EX_QUARANTINE\t(1 << 2)  \n\n \nstruct fc_exch {\n\tspinlock_t\t    ex_lock;\n\tatomic_t\t    ex_refcnt;\n\tenum fc_class\t    class;\n\tstruct fc_exch_mgr  *em;\n\tstruct fc_exch_pool *pool;\n\tstruct list_head    ex_list;\n\tstruct fc_lport\t    *lp;\n\tu32\t\t    esb_stat;\n\tu8\t\t    state;\n\tu8\t\t    fh_type;\n\tu8\t\t    seq_id;\n\tu8\t\t    encaps;\n\tu16\t\t    xid;\n\tu16\t\t    oxid;\n\tu16\t\t    rxid;\n\tu32\t\t    oid;\n\tu32\t\t    sid;\n\tu32\t\t    did;\n\tu32\t\t    r_a_tov;\n\tu32\t\t    f_ctl;\n\tstruct fc_seq       seq;\n\tint\t\t    resp_active;\n\tstruct task_struct  *resp_task;\n\twait_queue_head_t   resp_wq;\n\tvoid\t\t    (*resp)(struct fc_seq *, struct fc_frame *, void *);\n\tvoid\t\t    *arg;\n\tvoid\t\t    (*destructor)(struct fc_seq *, void *);\n\tstruct delayed_work timeout_work;\n} ____cacheline_aligned_in_smp;\n#define\tfc_seq_exch(sp) container_of(sp, struct fc_exch, seq)\n\n\nstruct libfc_function_template {\n\t \n\tint (*frame_send)(struct fc_lport *, struct fc_frame *);\n\n\t \n\tstruct fc_seq *(*elsct_send)(struct fc_lport *, u32 did,\n\t\t\t\t     struct fc_frame *, unsigned int op,\n\t\t\t\t     void (*resp)(struct fc_seq *,\n\t\t\t\t\t     struct fc_frame *, void *arg),\n\t\t\t\t     void *arg, u32 timer_msec);\n\n\t \n\tint (*ddp_setup)(struct fc_lport *, u16, struct scatterlist *,\n\t\t\t unsigned int);\n\t \n\tint (*ddp_done)(struct fc_lport *, u16);\n\t \n\tint (*ddp_target)(struct fc_lport *, u16, struct scatterlist *,\n\t\t\t  unsigned int);\n\t \n\tvoid (*get_lesb)(struct fc_lport *, struct fc_els_lesb *lesb);\n\n\t \n\tvoid (*exch_mgr_reset)(struct fc_lport *, u32 s_id, u32 d_id);\n\n\t \n\tvoid (*lport_set_port_id)(struct fc_lport *, u32 port_id,\n\t\t\t\t  struct fc_frame *);\n\n\t \n\tvoid (*rport_event_callback)(struct fc_lport *,\n\t\t\t\t     struct fc_rport_priv *,\n\t\t\t\t     enum fc_rport_event);\n\n\t \n\tint (*fcp_cmd_send)(struct fc_lport *, struct fc_fcp_pkt *,\n\t\t\t    void (*resp)(struct fc_seq *, struct fc_frame *,\n\t\t\t\t\t void *));\n\n\t \n\tvoid (*fcp_cleanup)(struct fc_lport *);\n\n\t \n\tvoid (*fcp_abort_io)(struct fc_lport *);\n\n\t \n\tvoid (*disc_recv_req)(struct fc_lport *, struct fc_frame *);\n\n\t \n\tvoid (*disc_start)(void (*disc_callback)(struct fc_lport *,\n\t\t\t\t\t\t enum fc_disc_event),\n\t\t\t   struct fc_lport *);\n\n\t \n\tvoid (*disc_stop) (struct fc_lport *);\n\n\t \n\tvoid (*disc_stop_final) (struct fc_lport *);\n};\n\n \nstruct fc_disc {\n\tunsigned char\t      retry_count;\n\tunsigned char\t      pending;\n\tunsigned char\t      requested;\n\tunsigned short\t      seq_count;\n\tunsigned char\t      buf_len;\n\tu16\t\t      disc_id;\n\n\tstruct list_head      rports;\n\tvoid\t\t      *priv;\n\tstruct mutex\t      disc_mutex;\n\tstruct fc_gpn_ft_resp partial_buf;\n\tstruct delayed_work   disc_work;\n\n\tvoid (*disc_callback)(struct fc_lport *,\n\t\t\t      enum fc_disc_event);\n};\n\n \nextern struct blocking_notifier_head fc_lport_notifier_head;\nenum fc_lport_event {\n\tFC_LPORT_EV_ADD,\n\tFC_LPORT_EV_DEL,\n};\n\n \nstruct fc_lport {\n\t \n\tstruct Scsi_Host\t       *host;\n\tstruct list_head\t       ema_list;\n\tstruct fc_rport_priv\t       *dns_rdata;\n\tstruct fc_rport_priv\t       *ms_rdata;\n\tstruct fc_rport_priv\t       *ptp_rdata;\n\tvoid\t\t\t       *scsi_priv;\n\tstruct fc_disc\t\t       disc;\n\n\t \n\tstruct list_head\t       vports;\n\tstruct fc_vport\t\t       *vport;\n\n\t \n\tstruct libfc_function_template tt;\n\tu8\t\t\t       link_up;\n\tu8\t\t\t       qfull;\n\tu16\t\t\t       vlan;\n\tenum fc_lport_state\t       state;\n\tunsigned long\t\t       boot_time;\n\tstruct fc_host_statistics      host_stats;\n\tstruct fc_stats\t__percpu       *stats;\n\tu8\t\t\t       retry_count;\n\n\t \n\tu32\t\t\t       port_id;\n\tu64\t\t\t       wwpn;\n\tu64\t\t\t       wwnn;\n\tunsigned int\t\t       service_params;\n\tunsigned int\t\t       e_d_tov;\n\tunsigned int\t\t       r_a_tov;\n\tstruct fc_els_rnid_gen\t       rnid_gen;\n\n\t \n\tu32\t\t\t       sg_supp:1;\n\tu32\t\t\t       seq_offload:1;\n\tu32\t\t\t       crc_offload:1;\n\tu32\t\t\t       lro_enabled:1;\n\tu32\t\t\t       does_npiv:1;\n\tu32\t\t\t       npiv_enabled:1;\n\tu32\t\t\t       point_to_multipoint:1;\n\tu32\t\t\t       fdmi_enabled:1;\n\tu32\t\t\t       mfs;\n\tu8\t\t\t       max_retry_count;\n\tu8\t\t\t       max_rport_retry_count;\n\tu16\t\t\t       rport_priv_size;\n\tu16\t\t\t       link_speed;\n\tu16\t\t\t       link_supported_speeds;\n\tu16\t\t\t       lro_xid;\n\tunsigned int\t\t       lso_max;\n\tstruct fc_ns_fts\t       fcts;\n\n\t \n\tstruct mutex\t\t       lp_mutex;\n\tstruct list_head\t       list;\n\tstruct delayed_work\t       retry_work;\n\tvoid\t\t\t       *prov[FC_FC4_PROV_SIZE];\n\tstruct list_head\t       lport_list;\n};\n\n \nstruct fc4_prov {\n\tint (*prli)(struct fc_rport_priv *, u32 spp_len,\n\t\t    const struct fc_els_spp *spp_in,\n\t\t    struct fc_els_spp *spp_out);\n\tvoid (*prlo)(struct fc_rport_priv *);\n\tvoid (*recv)(struct fc_lport *, struct fc_frame *);\n\tstruct module *module;\n};\n\n \nint fc_fc4_register_provider(enum fc_fh_type type, struct fc4_prov *);\nvoid fc_fc4_deregister_provider(enum fc_fh_type type, struct fc4_prov *);\n\n \n\n \nstatic inline int fc_lport_test_ready(struct fc_lport *lport)\n{\n\treturn lport->state == LPORT_ST_READY;\n}\n\n \nstatic inline void fc_set_wwnn(struct fc_lport *lport, u64 wwnn)\n{\n\tlport->wwnn = wwnn;\n}\n\n \nstatic inline void fc_set_wwpn(struct fc_lport *lport, u64 wwpn)\n{\n\tlport->wwpn = wwpn;\n}\n\n \nstatic inline void fc_lport_state_enter(struct fc_lport *lport,\n\t\t\t\t\tenum fc_lport_state state)\n{\n\tif (state != lport->state)\n\t\tlport->retry_count = 0;\n\tlport->state = state;\n}\n\n \nstatic inline int fc_lport_init_stats(struct fc_lport *lport)\n{\n\tlport->stats = alloc_percpu(struct fc_stats);\n\tif (!lport->stats)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nstatic inline void fc_lport_free_stats(struct fc_lport *lport)\n{\n\tfree_percpu(lport->stats);\n}\n\n \nstatic inline void *lport_priv(const struct fc_lport *lport)\n{\n\treturn (void *)(lport + 1);\n}\n\n \nstatic inline struct fc_lport *\nlibfc_host_alloc(const struct scsi_host_template *sht, int priv_size)\n{\n\tstruct fc_lport *lport;\n\tstruct Scsi_Host *shost;\n\n\tshost = scsi_host_alloc(sht, sizeof(*lport) + priv_size);\n\tif (!shost)\n\t\treturn NULL;\n\tlport = shost_priv(shost);\n\tlport->host = shost;\n\tINIT_LIST_HEAD(&lport->ema_list);\n\tINIT_LIST_HEAD(&lport->vports);\n\treturn lport;\n}\n\n \nstatic inline bool fc_fcp_is_read(const struct fc_fcp_pkt *fsp)\n{\n\tif (fsp && fsp->cmd)\n\t\treturn fsp->cmd->sc_data_direction == DMA_FROM_DEVICE;\n\treturn false;\n}\n\n \nint fc_lport_init(struct fc_lport *);\nint fc_lport_destroy(struct fc_lport *);\nint fc_fabric_logoff(struct fc_lport *);\nint fc_fabric_login(struct fc_lport *);\nvoid __fc_linkup(struct fc_lport *);\nvoid fc_linkup(struct fc_lport *);\nvoid __fc_linkdown(struct fc_lport *);\nvoid fc_linkdown(struct fc_lport *);\nvoid fc_vport_setlink(struct fc_lport *);\nvoid fc_vports_linkchange(struct fc_lport *);\nint fc_lport_config(struct fc_lport *);\nint fc_lport_reset(struct fc_lport *);\nvoid fc_lport_recv(struct fc_lport *lport, struct fc_frame *fp);\nint fc_set_mfs(struct fc_lport *, u32 mfs);\nstruct fc_lport *libfc_vport_create(struct fc_vport *, int privsize);\nstruct fc_lport *fc_vport_id_lookup(struct fc_lport *, u32 port_id);\nint fc_lport_bsg_request(struct bsg_job *);\nvoid fc_lport_set_local_id(struct fc_lport *, u32 port_id);\nvoid fc_lport_iterate(void (*func)(struct fc_lport *, void *), void *);\n\n \nvoid fc_rport_terminate_io(struct fc_rport *);\nstruct fc_rport_priv *fc_rport_lookup(const struct fc_lport *lport,\n\t\t\t\t      u32 port_id);\nstruct fc_rport_priv *fc_rport_create(struct fc_lport *, u32);\nvoid fc_rport_destroy(struct kref *kref);\nint fc_rport_login(struct fc_rport_priv *rdata);\nint fc_rport_logoff(struct fc_rport_priv *rdata);\nvoid fc_rport_recv_req(struct fc_lport *lport, struct fc_frame *fp);\nvoid fc_rport_flush_queue(void);\n\n \nvoid fc_disc_init(struct fc_lport *);\nvoid fc_disc_config(struct fc_lport *, void *);\n\nstatic inline struct fc_lport *fc_disc_lport(struct fc_disc *disc)\n{\n\treturn container_of(disc, struct fc_lport, disc);\n}\n\n \nint fc_fcp_init(struct fc_lport *);\nvoid fc_fcp_destroy(struct fc_lport *);\n\n \nint fc_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);\nint fc_eh_abort(struct scsi_cmnd *);\nint fc_eh_device_reset(struct scsi_cmnd *);\nint fc_eh_host_reset(struct scsi_cmnd *);\nint fc_slave_alloc(struct scsi_device *);\n\n \nint fc_elsct_init(struct fc_lport *);\nstruct fc_seq *fc_elsct_send(struct fc_lport *, u32 did,\n\t\t\t\t    struct fc_frame *,\n\t\t\t\t    unsigned int op,\n\t\t\t\t    void (*resp)(struct fc_seq *,\n\t\t\t\t\t\t struct fc_frame *,\n\t\t\t\t\t\t void *arg),\n\t\t\t\t    void *arg, u32 timer_msec);\nvoid fc_lport_flogi_resp(struct fc_seq *, struct fc_frame *, void *);\nvoid fc_lport_logo_resp(struct fc_seq *, struct fc_frame *, void *);\nvoid fc_fill_reply_hdr(struct fc_frame *, const struct fc_frame *,\n\t\t       enum fc_rctl, u32 parm_offset);\nvoid fc_fill_hdr(struct fc_frame *, const struct fc_frame *,\n\t\t enum fc_rctl, u32 f_ctl, u16 seq_cnt, u32 parm_offset);\n\n\n \nint fc_exch_init(struct fc_lport *);\nvoid fc_exch_update_stats(struct fc_lport *lport);\nstruct fc_seq *fc_exch_seq_send(struct fc_lport *lport,\n\t\t\t\tstruct fc_frame *fp,\n\t\t\t\tvoid (*resp)(struct fc_seq *,\n\t\t\t\t\t     struct fc_frame *fp,\n\t\t\t\t\t     void *arg),\n\t\t\t\tvoid (*destructor)(struct fc_seq *, void *),\n\t\t\t\tvoid *arg, u32 timer_msec);\nvoid fc_seq_els_rsp_send(struct fc_frame *, enum fc_els_cmd,\n\t\t\t struct fc_seq_els_data *);\nstruct fc_seq *fc_seq_start_next(struct fc_seq *sp);\nvoid fc_seq_set_resp(struct fc_seq *sp,\n\t\t     void (*resp)(struct fc_seq *, struct fc_frame *, void *),\n\t\t     void *arg);\nstruct fc_seq *fc_seq_assign(struct fc_lport *lport, struct fc_frame *fp);\nvoid fc_seq_release(struct fc_seq *sp);\nstruct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *,\n\t\t\t\t\t   struct fc_exch_mgr *,\n\t\t\t\t\t   bool (*match)(struct fc_frame *));\nvoid fc_exch_mgr_del(struct fc_exch_mgr_anchor *);\nint fc_exch_mgr_list_clone(struct fc_lport *src, struct fc_lport *dst);\nstruct fc_exch_mgr *fc_exch_mgr_alloc(struct fc_lport *, enum fc_class class,\n\t\t\t\t      u16 min_xid, u16 max_xid,\n\t\t\t\t      bool (*match)(struct fc_frame *));\nvoid fc_exch_mgr_free(struct fc_lport *);\nvoid fc_exch_recv(struct fc_lport *, struct fc_frame *);\nvoid fc_exch_mgr_reset(struct fc_lport *, u32 s_id, u32 d_id);\nint fc_seq_send(struct fc_lport *lport, struct fc_seq *sp, struct fc_frame *fp);\nint fc_seq_exch_abort(const struct fc_seq *, unsigned int timer_msec);\nvoid fc_exch_done(struct fc_seq *sp);\n\n \nvoid fc_get_host_speed(struct Scsi_Host *);\nvoid fc_get_host_port_state(struct Scsi_Host *);\nvoid fc_set_rport_loss_tmo(struct fc_rport *, u32 timeout);\nstruct fc_host_statistics *fc_get_host_stats(struct Scsi_Host *);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}