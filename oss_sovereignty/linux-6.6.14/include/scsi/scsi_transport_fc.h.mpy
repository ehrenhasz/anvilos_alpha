{
  "module_name": "scsi_transport_fc.h",
  "hash_id": "37d384bdfdf65246b93cc936471c939a9f8bda4a8f2557f57b71cf3ed51e3cf7",
  "original_prompt": "Ingested from linux-6.6.14/include/scsi/scsi_transport_fc.h",
  "human_readable_source": " \n \n#ifndef SCSI_TRANSPORT_FC_H\n#define SCSI_TRANSPORT_FC_H\n\n#include <linux/sched.h>\n#include <linux/bsg-lib.h>\n#include <asm/unaligned.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_netlink.h>\n#include <scsi/scsi_host.h>\n\nstruct scsi_transport_template;\n\n \n\n \nenum fc_port_type {\n\tFC_PORTTYPE_UNKNOWN,\n\tFC_PORTTYPE_OTHER,\n\tFC_PORTTYPE_NOTPRESENT,\n\tFC_PORTTYPE_NPORT,\t\t \n\tFC_PORTTYPE_NLPORT,\t\t \n\tFC_PORTTYPE_LPORT,\t\t \n\tFC_PORTTYPE_PTP,\t\t \n\tFC_PORTTYPE_NPIV,\t\t \n};\n\n\n \nenum fc_port_state {\n\tFC_PORTSTATE_UNKNOWN,\n\tFC_PORTSTATE_NOTPRESENT,\n\tFC_PORTSTATE_ONLINE,\n\tFC_PORTSTATE_OFFLINE,\t\t \n\tFC_PORTSTATE_BLOCKED,\n\tFC_PORTSTATE_BYPASSED,\n\tFC_PORTSTATE_DIAGNOSTICS,\n\tFC_PORTSTATE_LINKDOWN,\n\tFC_PORTSTATE_ERROR,\n\tFC_PORTSTATE_LOOPBACK,\n\tFC_PORTSTATE_DELETED,\n\tFC_PORTSTATE_MARGINAL,\n};\n\n\n \nenum fc_vport_state {\n\tFC_VPORT_UNKNOWN,\n\tFC_VPORT_ACTIVE,\n\tFC_VPORT_DISABLED,\n\tFC_VPORT_LINKDOWN,\n\tFC_VPORT_INITIALIZING,\n\tFC_VPORT_NO_FABRIC_SUPP,\n\tFC_VPORT_NO_FABRIC_RSCS,\n\tFC_VPORT_FABRIC_LOGOUT,\n\tFC_VPORT_FABRIC_REJ_WWN,\n\tFC_VPORT_FAILED,\n};\n\n\n\n \n#define FC_COS_UNSPECIFIED\t\t0\n#define FC_COS_CLASS1\t\t\t2\n#define FC_COS_CLASS2\t\t\t4\n#define FC_COS_CLASS3\t\t\t8\n#define FC_COS_CLASS4\t\t\t0x10\n#define FC_COS_CLASS6\t\t\t0x40\n\n \n#define FC_PORTSPEED_UNKNOWN\t\t0  \n#define FC_PORTSPEED_1GBIT\t\t1\n#define FC_PORTSPEED_2GBIT\t\t2\n#define FC_PORTSPEED_10GBIT\t\t4\n#define FC_PORTSPEED_4GBIT\t\t8\n#define FC_PORTSPEED_8GBIT\t\t0x10\n#define FC_PORTSPEED_16GBIT\t\t0x20\n#define FC_PORTSPEED_32GBIT\t\t0x40\n#define FC_PORTSPEED_20GBIT\t\t0x80\n#define FC_PORTSPEED_40GBIT\t\t0x100\n#define FC_PORTSPEED_50GBIT\t\t0x200\n#define FC_PORTSPEED_100GBIT\t\t0x400\n#define FC_PORTSPEED_25GBIT\t\t0x800\n#define FC_PORTSPEED_64GBIT\t\t0x1000\n#define FC_PORTSPEED_128GBIT\t\t0x2000\n#define FC_PORTSPEED_256GBIT\t\t0x4000\n#define FC_PORTSPEED_NOT_NEGOTIATED\t(1 << 15)  \n\n \nenum fc_tgtid_binding_type  {\n\tFC_TGTID_BIND_NONE,\n\tFC_TGTID_BIND_BY_WWPN,\n\tFC_TGTID_BIND_BY_WWNN,\n\tFC_TGTID_BIND_BY_ID,\n};\n\n \n#define FC_PORT_ROLE_UNKNOWN\t\t\t0x00\n#define FC_PORT_ROLE_FCP_TARGET\t\t\t0x01\n#define FC_PORT_ROLE_FCP_INITIATOR\t\t0x02\n#define FC_PORT_ROLE_IP_PORT\t\t\t0x04\n#define FC_PORT_ROLE_FCP_DUMMY_INITIATOR\t0x08\n#define FC_PORT_ROLE_NVME_INITIATOR\t\t0x10\n#define FC_PORT_ROLE_NVME_TARGET\t\t0x20\n#define FC_PORT_ROLE_NVME_DISCOVERY\t\t0x40\n\n \n#define FC_RPORT_ROLE_UNKNOWN\t\t\tFC_PORT_ROLE_UNKNOWN\n#define FC_RPORT_ROLE_FCP_TARGET\t\tFC_PORT_ROLE_FCP_TARGET\n#define FC_RPORT_ROLE_FCP_INITIATOR\t\tFC_PORT_ROLE_FCP_INITIATOR\n#define FC_RPORT_ROLE_IP_PORT\t\t\tFC_PORT_ROLE_IP_PORT\n\n\n \n#define FC_VPORT_ATTR(_name,_mode,_show,_store)\t\t\\\nstruct device_attribute dev_attr_vport_##_name = \t\\\n\t__ATTR(_name,_mode,_show,_store)\n\n \n#define FC_VPORT_SYMBOLIC_NAMELEN\t\t64\nstruct fc_vport_identifiers {\n\tu64 node_name;\n\tu64 port_name;\n\tu32 roles;\n\tbool disable;\n\tenum fc_port_type vport_type;\t \n\tchar symbolic_name[FC_VPORT_SYMBOLIC_NAMELEN];\n};\n\n \n\nstruct fc_vport {\n\t \n\n\t \n\n\t \n\tenum fc_vport_state vport_state;\n\tenum fc_vport_state vport_last_state;\n\tu64 node_name;\n\tu64 port_name;\n\tu32 roles;\n\tu32 vport_id;\t\t \n\tenum fc_port_type vport_type;\n\tchar symbolic_name[FC_VPORT_SYMBOLIC_NAMELEN];\n\n\t \n\tvoid *dd_data;\t\t\t \n\n\t \n\tstruct Scsi_Host *shost;\t \n\tunsigned int channel;\n\tu32 number;\n\tu8 flags;\n\tstruct list_head peers;\n\tstruct device dev;\n\tstruct work_struct vport_delete_work;\n} __attribute__((aligned(sizeof(unsigned long))));\n\n \n#define FC_VPORT_CREATING\t\t0x01\n#define FC_VPORT_DELETING\t\t0x02\n#define FC_VPORT_DELETED\t\t0x04\n#define FC_VPORT_DEL\t\t\t0x06\t \n\n#define\tdev_to_vport(d)\t\t\t\t\\\n\tcontainer_of(d, struct fc_vport, dev)\n#define transport_class_to_vport(dev)\t\t\\\n\tdev_to_vport(dev->parent)\n#define vport_to_shost(v)\t\t\t\\\n\t(v->shost)\n#define vport_to_shost_channel(v)\t\t\\\n\t(v->channel)\n#define vport_to_parent(v)\t\t\t\\\n\t(v->dev.parent)\n\n\n \n#define VPCERR_UNSUPPORTED\t\t-ENOSYS\t\t \n#define VPCERR_BAD_WWN\t\t\t-ENOTUNIQ\t \n#define VPCERR_NO_FABRIC_SUPP\t\t-EOPNOTSUPP\t \n\n \nstruct fc_rport_identifiers {\n\tu64 node_name;\n\tu64 port_name;\n\tu32 port_id;\n\tu32 roles;\n};\n\n \nstruct fc_fpin_stats {\n\t \n\tu64 dn;\n\tu64 dn_unknown;\n\tu64 dn_timeout;\n\tu64 dn_unable_to_route;\n\tu64 dn_device_specific;\n\n\t \n\tu64 li;\n\tu64 li_failure_unknown;\n\tu64 li_link_failure_count;\n\tu64 li_loss_of_sync_count;\n\tu64 li_loss_of_signals_count;\n\tu64 li_prim_seq_err_count;\n\tu64 li_invalid_tx_word_count;\n\tu64 li_invalid_crc_count;\n\tu64 li_device_specific;\n\n\t \n\tu64 cn;\n\tu64 cn_clear;\n\tu64 cn_lost_credit;\n\tu64 cn_credit_stall;\n\tu64 cn_oversubscription;\n\tu64 cn_device_specific;\n};\n\n \n#define FC_RPORT_ATTR(_name,_mode,_show,_store)\t\t\t\t\\\nstruct device_attribute dev_attr_rport_##_name = \t\\\n\t__ATTR(_name,_mode,_show,_store)\n\n\n \n\nstruct fc_rport {\t \n\t \n\tu32 maxframe_size;\n\tu32 supported_classes;\n\n\t \n\tu32 dev_loss_tmo;\t \n\tstruct fc_fpin_stats fpin_stats;\n\n\t \n\tu64 node_name;\n\tu64 port_name;\n\tu32 port_id;\n\tu32 roles;\n\tenum fc_port_state port_state;\t \n\tu32 scsi_target_id;\n\tu32 fast_io_fail_tmo;\n\n\t \n\tvoid *dd_data;\t\t\t \n\n\t \n\tunsigned int channel;\n\tu32 number;\n\tu8 flags;\n\tstruct list_head peers;\n\tstruct device dev;\n \tstruct delayed_work dev_loss_work;\n \tstruct work_struct scan_work;\n \tstruct delayed_work fail_io_work;\n \tstruct work_struct stgt_delete_work;\n\tstruct work_struct rport_delete_work;\n\tstruct request_queue *rqst_q;\t \n} __attribute__((aligned(sizeof(unsigned long))));\n\n \n#define FC_RPORT_DEVLOSS_PENDING\t0x01\n#define FC_RPORT_SCAN_PENDING\t\t0x02\n#define FC_RPORT_FAST_FAIL_TIMEDOUT\t0x04\n#define FC_RPORT_DEVLOSS_CALLBK_DONE\t0x08\n\n#define\tdev_to_rport(d)\t\t\t\t\\\n\tcontainer_of(d, struct fc_rport, dev)\n#define transport_class_to_rport(dev)\t\\\n\tdev_to_rport(dev->parent)\n#define rport_to_shost(r)\t\t\t\\\n\tdev_to_shost(r->dev.parent)\n\n \n\nstruct fc_starget_attrs {\t \n\t \n\tu64 node_name;\n\tu64 port_name;\n\tu32 port_id;\n};\n\n#define fc_starget_node_name(x) \\\n\t(((struct fc_starget_attrs *)&(x)->starget_data)->node_name)\n#define fc_starget_port_name(x)\t\\\n\t(((struct fc_starget_attrs *)&(x)->starget_data)->port_name)\n#define fc_starget_port_id(x) \\\n\t(((struct fc_starget_attrs *)&(x)->starget_data)->port_id)\n\n#define starget_to_rport(s)\t\t\t\\\n\tscsi_is_fc_rport(s->dev.parent) ? dev_to_rport(s->dev.parent) : NULL\n\n\n \n\n \nstruct fc_host_statistics {\n\t \n\tu64 seconds_since_last_reset;\n\tu64 tx_frames;\n\tu64 tx_words;\n\tu64 rx_frames;\n\tu64 rx_words;\n\tu64 lip_count;\n\tu64 nos_count;\n\tu64 error_frames;\n\tu64 dumped_frames;\n\tu64 link_failure_count;\n\tu64 loss_of_sync_count;\n\tu64 loss_of_signal_count;\n\tu64 prim_seq_protocol_err_count;\n\tu64 invalid_tx_word_count;\n\tu64 invalid_crc_count;\n\n\t \n\tu64 fcp_input_requests;\n\tu64 fcp_output_requests;\n\tu64 fcp_control_requests;\n\tu64 fcp_input_megabytes;\n\tu64 fcp_output_megabytes;\n\tu64 fcp_packet_alloc_failures;\t \n\tu64 fcp_packet_aborts;\t\t \n\tu64 fcp_frame_alloc_failures;\t \n\n\t \n\tu64 fc_no_free_exch;\t\t \n\tu64 fc_no_free_exch_xid;\t \n\tu64 fc_xid_not_found;\t\t \n\tu64 fc_xid_busy;\t\t \n\tu64 fc_seq_not_found;\t\t \n\tu64 fc_non_bls_resp;\t\t \n\t \n\tu64 cn_sig_warn;\n\tu64 cn_sig_alarm;\n};\n\n\n \n\n \nenum fc_host_event_code  {\n\tFCH_EVT_LIP\t\t\t= 0x1,\n\tFCH_EVT_LINKUP\t\t\t= 0x2,\n\tFCH_EVT_LINKDOWN\t\t= 0x3,\n\tFCH_EVT_LIPRESET\t\t= 0x4,\n\tFCH_EVT_RSCN\t\t\t= 0x5,\n\tFCH_EVT_ADAPTER_CHANGE\t\t= 0x103,\n\tFCH_EVT_PORT_UNKNOWN\t\t= 0x200,\n\tFCH_EVT_PORT_OFFLINE\t\t= 0x201,\n\tFCH_EVT_PORT_ONLINE\t\t= 0x202,\n\tFCH_EVT_PORT_FABRIC\t\t= 0x204,\n\tFCH_EVT_LINK_UNKNOWN\t\t= 0x500,\n\tFCH_EVT_LINK_FPIN\t\t= 0x501,\n\tFCH_EVT_LINK_FPIN_ACK\t\t= 0x502,\n\tFCH_EVT_VENDOR_UNIQUE\t\t= 0xffff,\n};\n\n\n \n\n#define FC_VENDOR_IDENTIFIER\t\t8\n#define FC_FC4_LIST_SIZE\t\t32\n#define FC_SYMBOLIC_NAME_SIZE\t\t256\n#define FC_VERSION_STRING_SIZE\t\t64\n#define FC_SERIAL_NUMBER_SIZE\t\t64\n\nstruct fc_host_attrs {\n\t \n\tu64 node_name;\n\tu64 port_name;\n\tu64 permanent_port_name;\n\tu32 supported_classes;\n\tu8  supported_fc4s[FC_FC4_LIST_SIZE];\n\tu32 supported_speeds;\n\tu32 maxframe_size;\n\tu16 max_npiv_vports;\n\tu32 max_ct_payload;\n\tu32 num_ports;\n\tu32 num_discovered_ports;\n\tu32 bootbios_state;\n\tchar serial_number[FC_SERIAL_NUMBER_SIZE];\n\tchar manufacturer[FC_SERIAL_NUMBER_SIZE];\n\tchar model[FC_SYMBOLIC_NAME_SIZE];\n\tchar model_description[FC_SYMBOLIC_NAME_SIZE];\n\tchar hardware_version[FC_VERSION_STRING_SIZE];\n\tchar driver_version[FC_VERSION_STRING_SIZE];\n\tchar firmware_version[FC_VERSION_STRING_SIZE];\n\tchar optionrom_version[FC_VERSION_STRING_SIZE];\n\tchar vendor_identifier[FC_VENDOR_IDENTIFIER];\n\tchar bootbios_version[FC_SYMBOLIC_NAME_SIZE];\n\n\n\t \n\tu32 port_id;\n\tenum fc_port_type port_type;\n\tenum fc_port_state port_state;\n\tu8  active_fc4s[FC_FC4_LIST_SIZE];\n\tu32 speed;\n\tu64 fabric_name;\n\tchar symbolic_name[FC_SYMBOLIC_NAME_SIZE];\n\tchar system_hostname[FC_SYMBOLIC_NAME_SIZE];\n\tu32 dev_loss_tmo;\n\tstruct fc_fpin_stats fpin_stats;\n\n\t \n\tenum fc_tgtid_binding_type  tgtid_bind_type;\n\n\t \n\tstruct list_head rports;\n\tstruct list_head rport_bindings;\n\tstruct list_head vports;\n\tu32 next_rport_number;\n\tu32 next_target_id;\n\tu32 next_vport_number;\n\tu16 npiv_vports_inuse;\n\n\t \n\tchar work_q_name[20];\n\tstruct workqueue_struct *work_q;\n\tchar devloss_work_q_name[20];\n\tstruct workqueue_struct *devloss_work_q;\n\n\t \n\tstruct request_queue *rqst_q;\n\n\t \n\tu8 fdmi_version;\n};\n\n#define shost_to_fc_host(x) \\\n\t((struct fc_host_attrs *)(x)->shost_data)\n\n#define fc_host_node_name(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->node_name)\n#define fc_host_port_name(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->port_name)\n#define fc_host_permanent_port_name(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->permanent_port_name)\n#define fc_host_supported_classes(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->supported_classes)\n#define fc_host_supported_fc4s(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->supported_fc4s)\n#define fc_host_supported_speeds(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->supported_speeds)\n#define fc_host_maxframe_size(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->maxframe_size)\n#define fc_host_max_npiv_vports(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->max_npiv_vports)\n#define fc_host_serial_number(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->serial_number)\n#define fc_host_manufacturer(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->manufacturer)\n#define fc_host_model(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->model)\n#define fc_host_model_description(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->model_description)\n#define fc_host_hardware_version(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->hardware_version)\n#define fc_host_driver_version(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->driver_version)\n#define fc_host_firmware_version(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->firmware_version)\n#define fc_host_optionrom_version(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->optionrom_version)\n#define fc_host_port_id(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->port_id)\n#define fc_host_port_type(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->port_type)\n#define fc_host_port_state(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->port_state)\n#define fc_host_active_fc4s(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->active_fc4s)\n#define fc_host_speed(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->speed)\n#define fc_host_fabric_name(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->fabric_name)\n#define fc_host_symbolic_name(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->symbolic_name)\n#define fc_host_system_hostname(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->system_hostname)\n#define fc_host_tgtid_bind_type(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->tgtid_bind_type)\n#define fc_host_rports(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->rports)\n#define fc_host_rport_bindings(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->rport_bindings)\n#define fc_host_vports(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->vports)\n#define fc_host_next_rport_number(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->next_rport_number)\n#define fc_host_next_target_id(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->next_target_id)\n#define fc_host_next_vport_number(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->next_vport_number)\n#define fc_host_npiv_vports_inuse(x)\t\\\n\t(((struct fc_host_attrs *)(x)->shost_data)->npiv_vports_inuse)\n#define fc_host_work_q_name(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->work_q_name)\n#define fc_host_work_q(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->work_q)\n#define fc_host_devloss_work_q_name(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->devloss_work_q_name)\n#define fc_host_devloss_work_q(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->devloss_work_q)\n#define fc_host_dev_loss_tmo(x) \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->dev_loss_tmo)\n#define fc_host_max_ct_payload(x)  \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->max_ct_payload)\n#define fc_host_vendor_identifier(x)  \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->vendor_identifier)\n#define fc_host_num_discovered_ports(x)  \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->num_discovered_ports)\n#define fc_host_num_ports(x)  \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->num_ports)\n#define fc_host_bootbios_version(x)  \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->bootbios_version)\n#define fc_host_bootbios_state(x)  \\\n\t(((struct fc_host_attrs *)(x)->shost_data)->bootbios_state)\n\n \nstruct fc_function_template {\n\tvoid    (*get_rport_dev_loss_tmo)(struct fc_rport *);\n\tvoid\t(*set_rport_dev_loss_tmo)(struct fc_rport *, u32);\n\n\tvoid\t(*get_starget_node_name)(struct scsi_target *);\n\tvoid\t(*get_starget_port_name)(struct scsi_target *);\n\tvoid \t(*get_starget_port_id)(struct scsi_target *);\n\n\tvoid \t(*get_host_port_id)(struct Scsi_Host *);\n\tvoid\t(*get_host_port_type)(struct Scsi_Host *);\n\tvoid\t(*get_host_port_state)(struct Scsi_Host *);\n\tvoid\t(*get_host_active_fc4s)(struct Scsi_Host *);\n\tvoid\t(*get_host_speed)(struct Scsi_Host *);\n\tvoid\t(*get_host_fabric_name)(struct Scsi_Host *);\n\tvoid\t(*get_host_symbolic_name)(struct Scsi_Host *);\n\tvoid\t(*set_host_system_hostname)(struct Scsi_Host *);\n\n\tstruct fc_host_statistics * (*get_fc_host_stats)(struct Scsi_Host *);\n\tvoid\t(*reset_fc_host_stats)(struct Scsi_Host *);\n\n\tint\t(*issue_fc_host_lip)(struct Scsi_Host *);\n\n\tvoid    (*dev_loss_tmo_callbk)(struct fc_rport *);\n\tvoid\t(*terminate_rport_io)(struct fc_rport *);\n\n\tvoid\t(*set_vport_symbolic_name)(struct fc_vport *);\n\tint  \t(*vport_create)(struct fc_vport *, bool);\n\tint\t(*vport_disable)(struct fc_vport *, bool);\n\tint  \t(*vport_delete)(struct fc_vport *);\n\n\t \n\tint\t(*bsg_request)(struct bsg_job *);\n\tint\t(*bsg_timeout)(struct bsg_job *);\n\n\t \n\tu32\t \t\t\tdd_fcrport_size;\n\tu32\t \t\t\tdd_fcvport_size;\n\tu32\t\t\t\tdd_bsg_size;\n\n\t \n\n\t \n\tunsigned long\tshow_rport_maxframe_size:1;\n\tunsigned long\tshow_rport_supported_classes:1;\n\tunsigned long   show_rport_dev_loss_tmo:1;\n\n\t \n\tunsigned long\tshow_starget_node_name:1;\n\tunsigned long\tshow_starget_port_name:1;\n\tunsigned long\tshow_starget_port_id:1;\n\n\t \n\tunsigned long\tshow_host_node_name:1;\n\tunsigned long\tshow_host_port_name:1;\n\tunsigned long\tshow_host_permanent_port_name:1;\n\tunsigned long\tshow_host_supported_classes:1;\n\tunsigned long\tshow_host_supported_fc4s:1;\n\tunsigned long\tshow_host_supported_speeds:1;\n\tunsigned long\tshow_host_maxframe_size:1;\n\tunsigned long\tshow_host_serial_number:1;\n\tunsigned long\tshow_host_manufacturer:1;\n\tunsigned long\tshow_host_model:1;\n\tunsigned long\tshow_host_model_description:1;\n\tunsigned long\tshow_host_hardware_version:1;\n\tunsigned long\tshow_host_driver_version:1;\n\tunsigned long\tshow_host_firmware_version:1;\n\tunsigned long\tshow_host_optionrom_version:1;\n\t \n\tunsigned long\tshow_host_port_id:1;\n\tunsigned long\tshow_host_port_type:1;\n\tunsigned long\tshow_host_port_state:1;\n\tunsigned long\tshow_host_active_fc4s:1;\n\tunsigned long\tshow_host_speed:1;\n\tunsigned long\tshow_host_fabric_name:1;\n\tunsigned long\tshow_host_symbolic_name:1;\n\tunsigned long\tshow_host_system_hostname:1;\n\n\tunsigned long\tdisable_target_scan:1;\n};\n\n \nstatic inline int\nfc_remote_port_chkready(struct fc_rport *rport)\n{\n\tint result;\n\n\tswitch (rport->port_state) {\n\tcase FC_PORTSTATE_ONLINE:\n\tcase FC_PORTSTATE_MARGINAL:\n\t\tif (rport->roles & FC_PORT_ROLE_FCP_TARGET)\n\t\t\tresult = 0;\n\t\telse if (rport->flags & FC_RPORT_DEVLOSS_PENDING)\n\t\t\tresult = DID_IMM_RETRY << 16;\n\t\telse\n\t\t\tresult = DID_NO_CONNECT << 16;\n\t\tbreak;\n\tcase FC_PORTSTATE_BLOCKED:\n\t\tif (rport->flags & FC_RPORT_FAST_FAIL_TIMEDOUT)\n\t\t\tresult = DID_TRANSPORT_FAILFAST << 16;\n\t\telse\n\t\t\tresult = DID_IMM_RETRY << 16;\n\t\tbreak;\n\tdefault:\n\t\tresult = DID_NO_CONNECT << 16;\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic inline u64 wwn_to_u64(const u8 *wwn)\n{\n\treturn get_unaligned_be64(wwn);\n}\n\nstatic inline void u64_to_wwn(u64 inm, u8 *wwn)\n{\n\tput_unaligned_be64(inm, wwn);\n}\n\n \nstatic inline void\nfc_vport_set_state(struct fc_vport *vport, enum fc_vport_state new_state)\n{\n\tif ((new_state != FC_VPORT_UNKNOWN) &&\n\t    (new_state != FC_VPORT_INITIALIZING))\n\t\tvport->vport_last_state = vport->vport_state;\n\tvport->vport_state = new_state;\n}\n\nstruct scsi_transport_template *fc_attach_transport(\n\t\t\tstruct fc_function_template *);\nvoid fc_release_transport(struct scsi_transport_template *);\nvoid fc_remove_host(struct Scsi_Host *);\nstruct fc_rport *fc_remote_port_add(struct Scsi_Host *shost,\n\t\t\tint channel, struct fc_rport_identifiers  *ids);\nvoid fc_remote_port_delete(struct fc_rport  *rport);\nvoid fc_remote_port_rolechg(struct fc_rport  *rport, u32 roles);\nint scsi_is_fc_rport(const struct device *);\nu32 fc_get_event_number(void);\nvoid fc_host_post_event(struct Scsi_Host *shost, u32 event_number,\n\t\tenum fc_host_event_code event_code, u32 event_data);\nvoid fc_host_post_vendor_event(struct Scsi_Host *shost, u32 event_number,\n\t\tu32 data_len, char *data_buf, u64 vendor_id);\nstruct fc_rport *fc_find_rport_by_wwpn(struct Scsi_Host *shost, u64 wwpn);\nvoid fc_host_post_fc_event(struct Scsi_Host *shost, u32 event_number,\n\t\tenum fc_host_event_code event_code,\n\t\tu32 data_len, char *data_buf, u64 vendor_id);\n\t \nvoid fc_host_fpin_rcv(struct Scsi_Host *shost, u32 fpin_len, char *fpin_buf,\n\t\tu8 event_acknowledge);\nstruct fc_vport *fc_vport_create(struct Scsi_Host *shost, int channel,\n\t\tstruct fc_vport_identifiers *);\nint fc_vport_terminate(struct fc_vport *vport);\nint fc_block_rport(struct fc_rport *rport);\nint fc_block_scsi_eh(struct scsi_cmnd *cmnd);\nenum scsi_timeout_action fc_eh_timed_out(struct scsi_cmnd *scmd);\nbool fc_eh_should_retry_cmd(struct scsi_cmnd *scmd);\n\nstatic inline struct Scsi_Host *fc_bsg_to_shost(struct bsg_job *job)\n{\n\tif (scsi_is_host_device(job->dev))\n\t\treturn dev_to_shost(job->dev);\n\treturn rport_to_shost(dev_to_rport(job->dev));\n}\n\nstatic inline struct fc_rport *fc_bsg_to_rport(struct bsg_job *job)\n{\n\tif (scsi_is_fc_rport(job->dev))\n\t\treturn dev_to_rport(job->dev);\n\treturn NULL;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}