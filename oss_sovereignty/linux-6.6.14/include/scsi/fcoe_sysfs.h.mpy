{
  "module_name": "fcoe_sysfs.h",
  "hash_id": "bd31e4a4ca4da5985472cc23ed02245777145b30e7209b85bcfa0c1e62ee96e5",
  "original_prompt": "Ingested from linux-6.6.14/include/scsi/fcoe_sysfs.h",
  "human_readable_source": " \n \n\n#ifndef FCOE_SYSFS\n#define FCOE_SYSFS\n\n#include <linux/if_ether.h>\n#include <linux/device.h>\n#include <scsi/fc/fc_fcoe.h>\n\nstruct fcoe_ctlr_device;\nstruct fcoe_fcf_device;\n\nstruct fcoe_sysfs_function_template {\n\tvoid (*get_fcoe_ctlr_link_fail)(struct fcoe_ctlr_device *);\n\tvoid (*get_fcoe_ctlr_vlink_fail)(struct fcoe_ctlr_device *);\n\tvoid (*get_fcoe_ctlr_miss_fka)(struct fcoe_ctlr_device *);\n\tvoid (*get_fcoe_ctlr_symb_err)(struct fcoe_ctlr_device *);\n\tvoid (*get_fcoe_ctlr_err_block)(struct fcoe_ctlr_device *);\n\tvoid (*get_fcoe_ctlr_fcs_error)(struct fcoe_ctlr_device *);\n\tvoid (*set_fcoe_ctlr_mode)(struct fcoe_ctlr_device *);\n\tint  (*set_fcoe_ctlr_enabled)(struct fcoe_ctlr_device *);\n\tvoid (*get_fcoe_fcf_selected)(struct fcoe_fcf_device *);\n\tvoid (*get_fcoe_fcf_vlan_id)(struct fcoe_fcf_device *);\n};\n\n#define dev_to_ctlr(d)\t\t\t\t\t\\\n\tcontainer_of((d), struct fcoe_ctlr_device, dev)\n\nenum fip_conn_type {\n\tFIP_CONN_TYPE_UNKNOWN,\n\tFIP_CONN_TYPE_FABRIC,\n\tFIP_CONN_TYPE_VN2VN,\n};\n\nenum ctlr_enabled_state {\n\tFCOE_CTLR_ENABLED,\n\tFCOE_CTLR_DISABLED,\n\tFCOE_CTLR_UNUSED,\n};\n\nstruct fcoe_ctlr_device {\n\tu32\t\t\t\tid;\n\n\tstruct device\t\t\tdev;\n\tstruct fcoe_sysfs_function_template *f;\n\n\tstruct list_head\t\tfcfs;\n\tchar\t\t\t\twork_q_name[20];\n\tstruct workqueue_struct\t\t*work_q;\n\tchar\t\t\t\tdevloss_work_q_name[20];\n\tstruct workqueue_struct\t\t*devloss_work_q;\n\tstruct mutex\t\t\tlock;\n\n\tint                             fcf_dev_loss_tmo;\n\tenum fip_conn_type              mode;\n\n\tenum ctlr_enabled_state         enabled;\n\n\t \n\tstruct fcoe_fc_els_lesb         lesb;\n};\n\nstatic inline void *fcoe_ctlr_device_priv(const struct fcoe_ctlr_device *ctlr)\n{\n\treturn (void *)(ctlr + 1);\n}\n\n \nenum fcf_state {\n\tFCOE_FCF_STATE_UNKNOWN,\n\tFCOE_FCF_STATE_DISCONNECTED,\n\tFCOE_FCF_STATE_CONNECTED,\n\tFCOE_FCF_STATE_DELETED,\n};\n\nstruct fcoe_fcf_device {\n\tu32\t\t    id;\n\tstruct device\t    dev;\n\tstruct list_head    peers;\n\tstruct work_struct  delete_work;\n\tstruct delayed_work dev_loss_work;\n\tu32\t\t    dev_loss_tmo;\n\tvoid                *priv;\n\tenum fcf_state      state;\n\n\tu64                 fabric_name;\n\tu64                 switch_name;\n\tu32                 fc_map;\n\tu16                 vfid;\n\tu8                  mac[ETH_ALEN];\n\tu8                  priority;\n\tu32                 fka_period;\n\tu8                  selected;\n\tu16                 vlan_id;\n};\n\n#define dev_to_fcf(d)\t\t\t\t\t\\\n\tcontainer_of((d), struct fcoe_fcf_device, dev)\n \n#define fcoe_fcf_dev_to_ctlr_dev(x)\t\t\\\n\tdev_to_ctlr((x)->dev.parent)\n#define fcoe_fcf_device_priv(x)\t\t\t\\\n\t((x)->priv)\n\nstruct fcoe_ctlr_device *fcoe_ctlr_device_add(struct device *parent,\n\t\t\t    struct fcoe_sysfs_function_template *f,\n\t\t\t    int priv_size);\nvoid fcoe_ctlr_device_delete(struct fcoe_ctlr_device *);\nstruct fcoe_fcf_device *fcoe_fcf_device_add(struct fcoe_ctlr_device *,\n\t\t\t\t\t    struct fcoe_fcf_device *);\nvoid fcoe_fcf_device_delete(struct fcoe_fcf_device *);\n\nint __init fcoe_sysfs_setup(void);\nvoid __exit fcoe_sysfs_teardown(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}