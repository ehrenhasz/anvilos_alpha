{
  "module_name": "libiscsi.h",
  "hash_id": "659591f18e2046f8ad25b1a5d487b0a061804dc34d6eba3f818936f2685747ef",
  "original_prompt": "Ingested from linux-6.6.14/include/scsi/libiscsi.h",
  "human_readable_source": " \n \n#ifndef LIBISCSI_H\n#define LIBISCSI_H\n\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/kfifo.h>\n#include <linux/refcount.h>\n#include <scsi/iscsi_proto.h>\n#include <scsi/iscsi_if.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_transport_iscsi.h>\n\nstruct scsi_transport_template;\nstruct scsi_host_template;\nstruct scsi_device;\nstruct Scsi_Host;\nstruct scsi_target;\nstruct scsi_cmnd;\nstruct socket;\nstruct iscsi_transport;\nstruct iscsi_cls_session;\nstruct iscsi_cls_conn;\nstruct iscsi_session;\nstruct iscsi_nopin;\nstruct device;\n\n#define ISCSI_DEF_XMIT_CMDS_MAX\t128\t \n#define ISCSI_MGMT_CMDS_MAX\t15\n\n#define ISCSI_DEF_CMD_PER_LUN\t32\n\n \nenum {\n\tTMF_INITIAL,\n\tTMF_QUEUED,\n\tTMF_SUCCESS,\n\tTMF_FAILED,\n\tTMF_TIMEDOUT,\n\tTMF_NOT_FOUND,\n};\n\n#define ISID_SIZE\t\t\t6\n\n \n#define ISCSI_CONN_FLAG_SUSPEND_TX\t0\n#define ISCSI_CONN_FLAG_SUSPEND_RX\t1\n#define ISCSI_CONN_FLAG_BOUND\t\t2\n\n#define ISCSI_ITT_MASK\t\t\t0x1fff\n#define ISCSI_TOTAL_CMDS_MAX\t\t4096\n \n#define ISCSI_TOTAL_CMDS_MIN\t\t16\n#define ISCSI_AGE_SHIFT\t\t\t28\n#define ISCSI_AGE_MASK\t\t\t0xf\n\n#define ISCSI_ADDRESS_BUF_LEN\t\t64\n\nenum {\n\t \n\tISCSI_MAX_AHS_SIZE = sizeof(struct iscsi_ecdb_ahdr) +\n\t\t\t\tsizeof(struct iscsi_rlength_ahdr),\n\tISCSI_DIGEST_SIZE = sizeof(__u32),\n};\n\n\nenum {\n\tISCSI_TASK_FREE,\n\tISCSI_TASK_COMPLETED,\n\tISCSI_TASK_PENDING,\n\tISCSI_TASK_RUNNING,\n\tISCSI_TASK_ABRT_TMF,\t\t \n\tISCSI_TASK_ABRT_SESS_RECOV,\t \n\tISCSI_TASK_REQUEUE_SCSIQ,\t \n};\n\nstruct iscsi_r2t_info {\n\t__be32\t\t\tttt;\t\t \n\t__be32\t\t\texp_statsn;\t \n\tuint32_t\t\tdata_length;\t \n\tuint32_t\t\tdata_offset;\t \n\tint\t\t\tdata_count;\t \n\tint\t\t\tdatasn;\n\t \n\tint\t\t\tsent;\t\t \n};\n\nstruct iscsi_task {\n\t \n\tstruct iscsi_hdr\t*hdr;\n\tunsigned short\t\thdr_max;\n\tunsigned short\t\thdr_len;\t \n\t \n\titt_t\t\t\thdr_itt;\n\t__be32\t\t\tcmdsn;\n\tstruct scsi_lun\t\tlun;\n\n\tint\t\t\titt;\t\t \n\n\tunsigned\t\timm_count;\t \n\t \n\tstruct iscsi_r2t_info\tunsol_r2t;\n\tchar\t\t\t*data;\t\t \n\tunsigned\t\tdata_count;\n\tstruct scsi_cmnd\t*sc;\t\t \n\tstruct iscsi_conn\t*conn;\t\t \n\n\t \n\tunsigned long\t\tlast_xfer;\n\tunsigned long\t\tlast_timeout;\n\tbool\t\t\thave_checked_conn;\n\n\t \n\tbool\t\t\tprotected;\n\n\t \n\tint\t\t\tstate;\n\trefcount_t\t\trefcount;\n\tstruct list_head\trunning;\t \n\tvoid\t\t\t*dd_data;\t \n};\n\nstatic inline int iscsi_task_has_unsol_data(struct iscsi_task *task)\n{\n\treturn task->unsol_r2t.data_length > task->unsol_r2t.sent;\n}\n\nstatic inline void* iscsi_next_hdr(struct iscsi_task *task)\n{\n\treturn (void*)task->hdr + task->hdr_len;\n}\n\nstatic inline bool iscsi_task_is_completed(struct iscsi_task *task)\n{\n\treturn task->state == ISCSI_TASK_COMPLETED ||\n\t       task->state == ISCSI_TASK_ABRT_TMF ||\n\t       task->state == ISCSI_TASK_ABRT_SESS_RECOV;\n}\n\n \nstruct iscsi_cmd {\n\tstruct iscsi_task\t*task;\n\tint\t\t\tage;\n};\n\nstatic inline struct iscsi_cmd *iscsi_cmd(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\n \nenum {\n\tISCSI_CONN_INITIAL_STAGE,\n\tISCSI_CONN_STARTED,\n\tISCSI_CONN_STOPPED,\n\tISCSI_CONN_CLEANUP_WAIT,\n};\n\nstruct iscsi_conn {\n\tstruct iscsi_cls_conn\t*cls_conn;\t \n\tvoid\t\t\t*dd_data;\t \n\tstruct iscsi_session\t*session;\t \n\t \n        int\t\t\tstop_stage;\n\tstruct timer_list\ttransport_timer;\n\tunsigned long\t\tlast_recv;\n\tunsigned long\t\tlast_ping;\n\tint\t\t\tping_timeout;\n\tint\t\t\trecv_timeout;\n\tstruct iscsi_task \t*ping_task;\n\n\t \n\tuint32_t\t\texp_statsn;\n\tuint32_t\t\tstatsn;\n\n\t \n\tint\t\t\tid;\t\t \n\tint\t\t\tc_stage;\t \n\t \n\tchar\t\t\t*data;\n\tstruct iscsi_task \t*login_task;\t \n\tstruct iscsi_task\t*task;\t\t \n\n\t \n\t \n\tstruct list_head\tmgmtqueue;\t \n\tstruct list_head\tcmdqueue;\t \n\tstruct list_head\trequeue;\t \n\tstruct work_struct\txmitwork;\t \n\t \n\tstruct work_struct\trecvwork;\n\tunsigned long\t\tflags;\t\t \n\n\t \n\tunsigned\t\tmax_recv_dlength;  \n\tunsigned\t\tmax_xmit_dlength;  \n\tint\t\t\thdrdgst_en;\n\tint\t\t\tdatadgst_en;\n\tint\t\t\tifmarker_en;\n\tint\t\t\tofmarker_en;\n\t \n\tint\t\t\tpersistent_port;\n\tchar\t\t\t*persistent_address;\n\n\tunsigned\t\tmax_segment_size;\n\tunsigned\t\ttcp_xmit_wsf;\n\tunsigned\t\ttcp_recv_wsf;\n\tuint16_t\t\tkeepalive_tmo;\n\tuint16_t\t\tlocal_port;\n\tuint8_t\t\t\ttcp_timestamp_stat;\n\tuint8_t\t\t\ttcp_nagle_disable;\n\tuint8_t\t\t\ttcp_wsf_disable;\n\tuint8_t\t\t\ttcp_timer_scale;\n\tuint8_t\t\t\ttcp_timestamp_en;\n\tuint8_t\t\t\tfragment_disable;\n\tuint8_t\t\t\tipv4_tos;\n\tuint8_t\t\t\tipv6_traffic_class;\n\tuint8_t\t\t\tipv6_flow_label;\n\tuint8_t\t\t\tis_fw_assigned_ipv6;\n\tchar\t\t\t*local_ipaddr;\n\n\t \n\tuint64_t\t\ttxdata_octets;\n\tuint64_t\t\trxdata_octets;\n\tuint32_t\t\tscsicmd_pdus_cnt;\n\tuint32_t\t\tdataout_pdus_cnt;\n\tuint32_t\t\tscsirsp_pdus_cnt;\n\tuint32_t\t\tdatain_pdus_cnt;\n\tuint32_t\t\tr2t_pdus_cnt;\n\tuint32_t\t\ttmfcmd_pdus_cnt;\n\tint32_t\t\t\ttmfrsp_pdus_cnt;\n\n\t \n\tuint32_t\t\teh_abort_cnt;\n\tuint32_t\t\tfmr_unalign_cnt;\n};\n\nstruct iscsi_pool {\n\tstruct kfifo\t\tqueue;\t\t \n\tvoid\t\t\t**pool;\t\t \n\tint\t\t\tmax;\t\t \n};\n\n \nenum {\n\tISCSI_STATE_FREE = 1,\n\tISCSI_STATE_LOGGED_IN,\n\tISCSI_STATE_FAILED,\n\tISCSI_STATE_TERMINATE,\n\tISCSI_STATE_IN_RECOVERY,\n\tISCSI_STATE_RECOVERY_FAILED,\n\tISCSI_STATE_LOGGING_OUT,\n};\n\nstruct iscsi_session {\n\tstruct iscsi_cls_session *cls_session;\n\t \n\tstruct mutex\t\teh_mutex;\n\t \n\twait_queue_head_t\tehwait;\t\t \n\tstruct iscsi_tm\t\ttmhdr;\n\tstruct timer_list\ttmf_timer;\n\tint\t\t\ttmf_state;\t \n\tstruct iscsi_task\t*running_aborted_task;\n\n\t \n\tuint32_t\t\tcmdsn;\n\tuint32_t\t\texp_cmdsn;\n\tuint32_t\t\tmax_cmdsn;\n\n\t \n\tuint32_t\t\tqueued_cmdsn;\n\n\t \n\tint\t\t\tabort_timeout;\n\tint\t\t\tlu_reset_timeout;\n\tint\t\t\ttgt_reset_timeout;\n\tint\t\t\tinitial_r2t_en;\n\tunsigned short\t\tmax_r2t;\n\tint\t\t\timm_data_en;\n\tunsigned\t\tfirst_burst;\n\tunsigned\t\tmax_burst;\n\tint\t\t\ttime2wait;\n\tint\t\t\ttime2retain;\n\tint\t\t\tpdu_inorder_en;\n\tint\t\t\tdataseq_inorder_en;\n\tint\t\t\terl;\n\tint\t\t\tfast_abort;\n\tint\t\t\ttpgt;\n\tchar\t\t\t*username;\n\tchar\t\t\t*username_in;\n\tchar\t\t\t*password;\n\tchar\t\t\t*password_in;\n\tchar\t\t\t*targetname;\n\tchar\t\t\t*targetalias;\n\tchar\t\t\t*ifacename;\n\tchar\t\t\t*initiatorname;\n\tchar\t\t\t*boot_root;\n\tchar\t\t\t*boot_nic;\n\tchar\t\t\t*boot_target;\n\tchar\t\t\t*portal_type;\n\tchar\t\t\t*discovery_parent_type;\n\tuint16_t\t\tdiscovery_parent_idx;\n\tuint16_t\t\tdef_taskmgmt_tmo;\n\tuint16_t\t\ttsid;\n\tuint8_t\t\t\tauto_snd_tgt_disable;\n\tuint8_t\t\t\tdiscovery_sess;\n\tuint8_t\t\t\tchap_auth_en;\n\tuint8_t\t\t\tdiscovery_logout_en;\n\tuint8_t\t\t\tbidi_chap_en;\n\tuint8_t\t\t\tdiscovery_auth_optional;\n\tuint8_t\t\t\tisid[ISID_SIZE];\n\n\t \n\tstruct iscsi_transport\t*tt;\n\tstruct Scsi_Host\t*host;\n\tstruct iscsi_conn\t*leadconn;\t \n\t \n\tspinlock_t\t\tfrwd_lock;\t \n\tspinlock_t\t\tback_lock;\t \n\tint\t\t\tstate;\t\t \n\tint\t\t\tage;\t\t \n\n\tint\t\t\tscsi_cmds_max; \t \n\tint\t\t\tcmds_max;\t \n\tstruct iscsi_task\t**cmds;\t\t \n\tstruct iscsi_pool\tcmdpool;\t \n\tvoid\t\t\t*dd_data;\t \n};\n\nenum {\n\tISCSI_HOST_SETUP,\n\tISCSI_HOST_REMOVED,\n};\n\nstruct iscsi_host {\n\tchar\t\t\t*initiatorname;\n\t \n\tchar\t\t\t*hwaddress;\n\tchar\t\t\t*netdev;\n\n\twait_queue_head_t\tsession_removal_wq;\n\t \n\tspinlock_t\t\tlock;\n\tint\t\t\tnum_sessions;\n\tint\t\t\tstate;\n\n\tstruct workqueue_struct\t*workq;\n};\n\n \nextern int iscsi_eh_abort(struct scsi_cmnd *sc);\nextern int iscsi_eh_recover_target(struct scsi_cmnd *sc);\nextern int iscsi_eh_session_reset(struct scsi_cmnd *sc);\nextern int iscsi_eh_device_reset(struct scsi_cmnd *sc);\nextern int iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc);\nextern enum scsi_timeout_action iscsi_eh_cmd_timed_out(struct scsi_cmnd *sc);\n\n \n#define iscsi_host_priv(_shost) \\\n\t(shost_priv(_shost) + sizeof(struct iscsi_host))\n\nextern int iscsi_host_set_param(struct Scsi_Host *shost,\n\t\t\t\tenum iscsi_host_param param, char *buf,\n\t\t\t\tint buflen);\nextern int iscsi_host_get_param(struct Scsi_Host *shost,\n\t\t\t\tenum iscsi_host_param param, char *buf);\nextern int iscsi_host_add(struct Scsi_Host *shost, struct device *pdev);\nextern struct Scsi_Host *iscsi_host_alloc(const struct scsi_host_template *sht,\n\t\t\t\t\t  int dd_data_size,\n\t\t\t\t\t  bool xmit_can_sleep);\nextern void iscsi_host_remove(struct Scsi_Host *shost, bool is_shutdown);\nextern void iscsi_host_free(struct Scsi_Host *shost);\nextern int iscsi_target_alloc(struct scsi_target *starget);\nextern int iscsi_host_get_max_scsi_cmds(struct Scsi_Host *shost,\n\t\t\t\t\tuint16_t requested_cmds_max);\n\n \nextern struct iscsi_cls_session *\niscsi_session_setup(struct iscsi_transport *, struct Scsi_Host *shost,\n\t\t    uint16_t, int, int, uint32_t, unsigned int);\nvoid iscsi_session_remove(struct iscsi_cls_session *cls_session);\nvoid iscsi_session_free(struct iscsi_cls_session *cls_session);\nextern void iscsi_session_teardown(struct iscsi_cls_session *);\nextern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);\nextern int iscsi_set_param(struct iscsi_cls_conn *cls_conn,\n\t\t\t   enum iscsi_param param, char *buf, int buflen);\nextern int iscsi_session_get_param(struct iscsi_cls_session *cls_session,\n\t\t\t\t   enum iscsi_param param, char *buf);\n\n#define iscsi_session_printk(prefix, _sess, fmt, a...)\t\\\n\tiscsi_cls_session_printk(prefix, _sess->cls_session, fmt, ##a)\n\n \nextern struct iscsi_cls_conn *iscsi_conn_setup(struct iscsi_cls_session *,\n\t\t\t\t\t       int, uint32_t);\nextern void iscsi_conn_teardown(struct iscsi_cls_conn *);\nextern int iscsi_conn_start(struct iscsi_cls_conn *);\nextern void iscsi_conn_stop(struct iscsi_cls_conn *, int);\nextern int iscsi_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,\n\t\t\t   int);\nextern void iscsi_conn_unbind(struct iscsi_cls_conn *cls_conn, bool is_active);\nextern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);\nextern void iscsi_session_failure(struct iscsi_session *session,\n\t\t\t\t  enum iscsi_err err);\nextern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,\n\t\t\t\tenum iscsi_param param, char *buf);\nextern int iscsi_conn_get_addr_param(struct sockaddr_storage *addr,\n\t\t\t\t     enum iscsi_param param, char *buf);\nextern void iscsi_suspend_tx(struct iscsi_conn *conn);\nextern void iscsi_suspend_rx(struct iscsi_conn *conn);\nextern void iscsi_suspend_queue(struct iscsi_conn *conn);\nextern void iscsi_conn_queue_xmit(struct iscsi_conn *conn);\nextern void iscsi_conn_queue_recv(struct iscsi_conn *conn);\n\n#define iscsi_conn_printk(prefix, _c, fmt, a...) \\\n\tiscsi_cls_conn_printk(prefix, ((struct iscsi_conn *)_c)->cls_conn, \\\n\t\t\t      fmt, ##a)\n\n \nextern void iscsi_update_cmdsn(struct iscsi_session *, struct iscsi_nopin *);\nextern void iscsi_prep_data_out_pdu(struct iscsi_task *task,\n\t\t\t\t    struct iscsi_r2t_info *r2t,\n\t\t\t\t    struct iscsi_data *hdr);\nextern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,\n\t\t\t\tchar *, uint32_t);\nextern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,\n\t\t\t      char *, int);\nextern int __iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,\n\t\t\t\tchar *, int);\nextern int iscsi_verify_itt(struct iscsi_conn *, itt_t);\nextern struct iscsi_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);\nextern struct iscsi_task *iscsi_itt_to_task(struct iscsi_conn *, itt_t);\nextern void iscsi_requeue_task(struct iscsi_task *task);\nextern void iscsi_put_task(struct iscsi_task *task);\nextern void __iscsi_put_task(struct iscsi_task *task);\nextern bool iscsi_get_task(struct iscsi_task *task);\nextern void iscsi_complete_scsi_task(struct iscsi_task *task,\n\t\t\t\t     uint32_t exp_cmdsn, uint32_t max_cmdsn);\n\n \nextern void iscsi_pool_free(struct iscsi_pool *);\nextern int iscsi_pool_init(struct iscsi_pool *, int, void ***, int);\nextern int iscsi_switch_str_param(char **, char *);\n\n \nstatic inline unsigned int\niscsi_padded(unsigned int len)\n{\n\treturn (len + ISCSI_PAD_LEN - 1) & ~(ISCSI_PAD_LEN - 1);\n}\n\nstatic inline unsigned int\niscsi_padding(unsigned int len)\n{\n\tlen &= (ISCSI_PAD_LEN - 1);\n\tif (len)\n\t\tlen = ISCSI_PAD_LEN - len;\n\treturn len;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}