{
  "module_name": "fc_frame.h",
  "hash_id": "694ee3a9e7d619f37c82e9d66cac66dc26e2e458e79c380daa149162766a7510",
  "original_prompt": "Ingested from linux-6.6.14/include/scsi/fc_frame.h",
  "human_readable_source": " \n \n\n#ifndef _FC_FRAME_H_\n#define _FC_FRAME_H_\n\n#include <linux/scatterlist.h>\n#include <linux/skbuff.h>\n#include <scsi/scsi_cmnd.h>\n\n#include <scsi/fc/fc_fs.h>\n#include <scsi/fc/fc_fcp.h>\n#include <scsi/fc/fc_encaps.h>\n\n#include <linux/if_ether.h>\n\n \n\n#define ntohll(x) be64_to_cpu(x)\n#define htonll(x) cpu_to_be64(x)\n\nstatic inline u32 ntoh24(const u8 *p)\n{\n\treturn (p[0] << 16) | (p[1] << 8) | p[2];\n}\n\nstatic inline void hton24(u8 *p, u32 v)\n{\n\tp[0] = (v >> 16) & 0xff;\n\tp[1] = (v >> 8) & 0xff;\n\tp[2] = v & 0xff;\n}\n\n \n\n#define\tFC_FRAME_HEADROOM\t32\t \n#define\tFC_FRAME_TAILROOM\t8\t \n\n \n#define FC_FRAME_SG_LEN\t\t(MAX_SKB_FRAGS - 1)\n\n#define fp_skb(fp)\t(&((fp)->skb))\n#define fr_hdr(fp)\t((fp)->skb.data)\n#define fr_len(fp)\t((fp)->skb.len)\n#define fr_cb(fp)\t((struct fcoe_rcv_info *)&((fp)->skb.cb[0]))\n#define fr_dev(fp)\t(fr_cb(fp)->fr_dev)\n#define fr_seq(fp)\t(fr_cb(fp)->fr_seq)\n#define fr_sof(fp)\t(fr_cb(fp)->fr_sof)\n#define fr_eof(fp)\t(fr_cb(fp)->fr_eof)\n#define fr_flags(fp)\t(fr_cb(fp)->fr_flags)\n#define fr_encaps(fp)\t(fr_cb(fp)->fr_encaps)\n#define fr_max_payload(fp)\t(fr_cb(fp)->fr_max_payload)\n#define fr_fsp(fp)\t(fr_cb(fp)->fr_fsp)\n#define fr_crc(fp)\t(fr_cb(fp)->fr_crc)\n\nstruct fc_frame {\n\tstruct sk_buff skb;\n};\n\nstruct fcoe_rcv_info {\n\tstruct fc_lport\t*fr_dev;\t \n\tstruct fc_seq\t*fr_seq;\t \n\tstruct fc_fcp_pkt *fr_fsp;\t \n\tu32\t\tfr_crc;\n\tu16\t\tfr_max_payload;\t \n\tu8\t\tfr_sof;\t\t \n\tu8\t\tfr_eof;\t\t \n\tu8\t\tfr_flags;\t \n\tu8\t\tfr_encaps;\t \n\tu8\t\tgranted_mac[ETH_ALEN];  \n};\n\n\n \nstatic inline struct fcoe_rcv_info *fcoe_dev_from_skb(const struct sk_buff *skb)\n{\n\tBUILD_BUG_ON(sizeof(struct fcoe_rcv_info) > sizeof(skb->cb));\n\treturn (struct fcoe_rcv_info *) skb->cb;\n}\n\n \n#define\tFCPHF_CRC_UNCHECKED\t0x01\t \n\n \nstatic inline void fc_frame_init(struct fc_frame *fp)\n{\n\tfr_dev(fp) = NULL;\n\tfr_seq(fp) = NULL;\n\tfr_flags(fp) = 0;\n\tfr_encaps(fp) = 0;\n}\n\nstruct fc_frame *fc_frame_alloc_fill(struct fc_lport *, size_t payload_len);\nstruct fc_frame *_fc_frame_alloc(size_t payload_len);\n\n \nstatic inline struct fc_frame *fc_frame_alloc(struct fc_lport *dev, size_t len)\n{\n\tstruct fc_frame *fp;\n\n\t \n\tif (len && len % 4)\n\t\tfp = fc_frame_alloc_fill(dev, len);\n\telse\n\t\tfp = _fc_frame_alloc(len);\n\treturn fp;\n}\n\n \nstatic inline void fc_frame_free(struct fc_frame *fp)\n{\n\tkfree_skb(fp_skb(fp));\n}\n\nstatic inline int fc_frame_is_linear(struct fc_frame *fp)\n{\n\treturn !skb_is_nonlinear(fp_skb(fp));\n}\n\n \nstatic inline\nstruct fc_frame_header *__fc_frame_header_get(const struct fc_frame *fp)\n{\n\treturn (struct fc_frame_header *)fr_hdr(fp);\n}\n\n \nstatic inline\nstruct fc_frame_header *fc_frame_header_get(const struct fc_frame *fp)\n{\n\tWARN_ON(fr_len(fp) < sizeof(struct fc_frame_header));\n\treturn __fc_frame_header_get(fp);\n}\n\n \nstatic inline u32 fc_frame_sid(const struct fc_frame *fp)\n{\n\treturn ntoh24(__fc_frame_header_get(fp)->fh_s_id);\n}\n\n \nstatic inline u32 fc_frame_did(const struct fc_frame *fp)\n{\n\treturn ntoh24(__fc_frame_header_get(fp)->fh_d_id);\n}\n\n \nstatic inline void *fc_frame_payload_get(const struct fc_frame *fp,\n\t\t\t\t\t size_t len)\n{\n\tvoid *pp = NULL;\n\n\tif (fr_len(fp) >= sizeof(struct fc_frame_header) + len)\n\t\tpp = fc_frame_header_get(fp) + 1;\n\treturn pp;\n}\n\n \nstatic inline u8 fc_frame_payload_op(const struct fc_frame *fp)\n{\n\tu8 *cp;\n\n\tcp = fc_frame_payload_get(fp, sizeof(u8));\n\tif (!cp)\n\t\treturn 0;\n\treturn *cp;\n\n}\n\n \nstatic inline enum fc_class fc_frame_class(const struct fc_frame *fp)\n{\n\treturn fc_sof_class(fr_sof(fp));\n}\n\n \nu32 fc_frame_crc_check(struct fc_frame *);\n\nstatic inline u8 fc_frame_rctl(const struct fc_frame *fp)\n{\n\treturn fc_frame_header_get(fp)->fh_r_ctl;\n}\n\nstatic inline bool fc_frame_is_cmd(const struct fc_frame *fp)\n{\n\treturn fc_frame_rctl(fp) == FC_RCTL_DD_UNSOL_CMD;\n}\n\n \nvoid fc_frame_leak_check(void);\n\nstatic inline void __fc_fill_fc_hdr(struct fc_frame_header *fh,\n\t\t\t\t    enum fc_rctl r_ctl,\n\t\t\t\t    u32 did, u32 sid, enum fc_fh_type type,\n\t\t\t\t    u32 f_ctl, u32 parm_offset)\n{\n\tWARN_ON(r_ctl == 0);\n\tfh->fh_r_ctl = r_ctl;\n\thton24(fh->fh_d_id, did);\n\thton24(fh->fh_s_id, sid);\n\tfh->fh_type = type;\n\thton24(fh->fh_f_ctl, f_ctl);\n\tfh->fh_cs_ctl = 0;\n\tfh->fh_df_ctl = 0;\n\tfh->fh_parm_offset = htonl(parm_offset);\n}\n\n \nstatic inline void fc_fill_fc_hdr(struct fc_frame *fp, enum fc_rctl r_ctl,\n\t\t\t\t  u32 did, u32 sid, enum fc_fh_type type,\n\t\t\t\t  u32 f_ctl, u32 parm_offset)\n{\n\tstruct fc_frame_header *fh;\n\n\tfh = fc_frame_header_get(fp);\n\t__fc_fill_fc_hdr(fh, r_ctl, did, sid, type, f_ctl, parm_offset);\n}\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}