{
  "module_name": "videobuf2-v4l2.h",
  "hash_id": "ba96d5edb16f6ae4fc7461bf271e11a0e59853616a02b939e52e876f6f2f35b9",
  "original_prompt": "Ingested from linux-6.6.14/include/media/videobuf2-v4l2.h",
  "human_readable_source": " \n#ifndef _MEDIA_VIDEOBUF2_V4L2_H\n#define _MEDIA_VIDEOBUF2_V4L2_H\n\n#include <linux/videodev2.h>\n#include <media/videobuf2-core.h>\n\n#if VB2_MAX_FRAME != VIDEO_MAX_FRAME\n#error VB2_MAX_FRAME != VIDEO_MAX_FRAME\n#endif\n\n#if VB2_MAX_PLANES != VIDEO_MAX_PLANES\n#error VB2_MAX_PLANES != VIDEO_MAX_PLANES\n#endif\n\nstruct video_device;\n\n \nstruct vb2_v4l2_buffer {\n\tstruct vb2_buffer\tvb2_buf;\n\n\t__u32\t\t\tflags;\n\t__u32\t\t\tfield;\n\tstruct v4l2_timecode\ttimecode;\n\t__u32\t\t\tsequence;\n\t__s32\t\t\trequest_fd;\n\tbool\t\t\tis_held;\n\tstruct vb2_plane\tplanes[VB2_MAX_PLANES];\n};\n\n \n#define VB2_V4L2_FL_SUPPORTS_M2M_HOLD_CAPTURE_BUF (1 << 0)\n\n \n#define to_vb2_v4l2_buffer(vb) \\\n\tcontainer_of(vb, struct vb2_v4l2_buffer, vb2_buf)\n\n \nstruct vb2_buffer *vb2_find_buffer(struct vb2_queue *q, u64 timestamp);\n\nint vb2_querybuf(struct vb2_queue *q, struct v4l2_buffer *b);\n\n \nint vb2_reqbufs(struct vb2_queue *q, struct v4l2_requestbuffers *req);\n\n \nint vb2_create_bufs(struct vb2_queue *q, struct v4l2_create_buffers *create);\n\n \nint vb2_prepare_buf(struct vb2_queue *q, struct media_device *mdev,\n\t\t    struct v4l2_buffer *b);\n\n \nint vb2_qbuf(struct vb2_queue *q, struct media_device *mdev,\n\t     struct v4l2_buffer *b);\n\n \nint vb2_expbuf(struct vb2_queue *q, struct v4l2_exportbuffer *eb);\n\n \nint vb2_dqbuf(struct vb2_queue *q, struct v4l2_buffer *b, bool nonblocking);\n\n \nint vb2_streamon(struct vb2_queue *q, enum v4l2_buf_type type);\n\n \nint vb2_streamoff(struct vb2_queue *q, enum v4l2_buf_type type);\n\n \nint __must_check vb2_queue_init(struct vb2_queue *q);\n\n \nint __must_check vb2_queue_init_name(struct vb2_queue *q, const char *name);\n\n \nvoid vb2_queue_release(struct vb2_queue *q);\n\n \nint vb2_queue_change_type(struct vb2_queue *q, unsigned int type);\n\n \n__poll_t vb2_poll(struct vb2_queue *q, struct file *file, poll_table *wait);\n\n \n\n \nstatic inline bool vb2_queue_is_busy(struct vb2_queue *q, struct file *file)\n{\n\treturn q->owner && q->owner != file->private_data;\n}\n\n \n\nint vb2_ioctl_reqbufs(struct file *file, void *priv,\n\t\t\t  struct v4l2_requestbuffers *p);\nint vb2_ioctl_create_bufs(struct file *file, void *priv,\n\t\t\t  struct v4l2_create_buffers *p);\nint vb2_ioctl_prepare_buf(struct file *file, void *priv,\n\t\t\t  struct v4l2_buffer *p);\nint vb2_ioctl_querybuf(struct file *file, void *priv, struct v4l2_buffer *p);\nint vb2_ioctl_qbuf(struct file *file, void *priv, struct v4l2_buffer *p);\nint vb2_ioctl_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p);\nint vb2_ioctl_streamon(struct file *file, void *priv, enum v4l2_buf_type i);\nint vb2_ioctl_streamoff(struct file *file, void *priv, enum v4l2_buf_type i);\nint vb2_ioctl_expbuf(struct file *file, void *priv,\n\tstruct v4l2_exportbuffer *p);\n\n \n\nint vb2_fop_mmap(struct file *file, struct vm_area_struct *vma);\nint vb2_fop_release(struct file *file);\nint _vb2_fop_release(struct file *file, struct mutex *lock);\nssize_t vb2_fop_write(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *ppos);\nssize_t vb2_fop_read(struct file *file, char __user *buf,\n\t\tsize_t count, loff_t *ppos);\n__poll_t vb2_fop_poll(struct file *file, poll_table *wait);\n#ifndef CONFIG_MMU\nunsigned long vb2_fop_get_unmapped_area(struct file *file, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags);\n#endif\n\n \nvoid vb2_video_unregister_device(struct video_device *vdev);\n\n \nvoid vb2_ops_wait_prepare(struct vb2_queue *vq);\n\n \nvoid vb2_ops_wait_finish(struct vb2_queue *vq);\n\nstruct media_request;\nint vb2_request_validate(struct media_request *req);\nvoid vb2_request_queue(struct media_request *req);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}