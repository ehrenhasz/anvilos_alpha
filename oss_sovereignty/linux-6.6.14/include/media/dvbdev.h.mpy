{
  "module_name": "dvbdev.h",
  "hash_id": "3db86635760a9cb97a7cb820895932404ab0c1cf92d32e93b8455fdd3c9693c2",
  "original_prompt": "Ingested from linux-6.6.14/include/media/dvbdev.h",
  "human_readable_source": " \n\n#ifndef _DVBDEV_H_\n#define _DVBDEV_H_\n\n#include <linux/types.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <media/media-device.h>\n\n#define DVB_MAJOR 212\n\n#if defined(CONFIG_DVB_MAX_ADAPTERS) && CONFIG_DVB_MAX_ADAPTERS > 0\n  #define DVB_MAX_ADAPTERS CONFIG_DVB_MAX_ADAPTERS\n#else\n  #define DVB_MAX_ADAPTERS 16\n#endif\n\n#define DVB_UNSET (-1)\n\n \n\n \nenum dvb_device_type {\n\tDVB_DEVICE_SEC,\n\tDVB_DEVICE_FRONTEND,\n\tDVB_DEVICE_DEMUX,\n\tDVB_DEVICE_DVR,\n\tDVB_DEVICE_CA,\n\tDVB_DEVICE_NET,\n\n\tDVB_DEVICE_VIDEO,\n\tDVB_DEVICE_AUDIO,\n\tDVB_DEVICE_OSD,\n};\n\n#define DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr) \\\n\tstatic short adapter_nr[] = \\\n\t\t{[0 ... (DVB_MAX_ADAPTERS - 1)] = DVB_UNSET }; \\\n\tmodule_param_array(adapter_nr, short, NULL, 0444); \\\n\tMODULE_PARM_DESC(adapter_nr, \"DVB adapter numbers\")\n\nstruct dvb_frontend;\n\n \nstruct dvb_adapter {\n\tint num;\n\tstruct list_head list_head;\n\tstruct list_head device_list;\n\tconst char *name;\n\tu8 proposed_mac [6];\n\tvoid* priv;\n\n\tstruct device *device;\n\n\tstruct module *module;\n\n\tint mfe_shared;\t\t\t \n\tstruct dvb_device *mfe_dvbdev;\t \n\tstruct mutex mfe_lock;\t\t \n\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\n\tstruct mutex mdev_lock;\n\tstruct media_device *mdev;\n\tstruct media_entity *conn;\n\tstruct media_pad *conn_pads;\n#endif\n};\n\n \nstruct dvb_device {\n\tstruct list_head list_head;\n\tstruct kref ref;\n\tconst struct file_operations *fops;\n\tstruct dvb_adapter *adapter;\n\tenum dvb_device_type type;\n\tint minor;\n\tu32 id;\n\n\t \n\tint readers;\n\tint writers;\n\tint users;\n\n\twait_queue_head_t\t  wait_queue;\n\t \n\tint (*kernel_ioctl)(struct file *file, unsigned int cmd, void *arg);\n\n\t \n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\n\tconst char *name;\n\n\t \n\tstruct media_intf_devnode *intf_devnode;\n\n\tunsigned tsout_num_entities;\n\tstruct media_entity *entity, *tsout_entity;\n\tstruct media_pad *pads, *tsout_pads;\n#endif\n\n\tvoid *priv;\n};\n\n \nstruct dvbdevfops_node {\n\tstruct file_operations *fops;\n\tenum dvb_device_type type;\n\tconst struct dvb_device *template;\n\tstruct list_head list_head;\n};\n\n \nstruct dvb_device *dvb_device_get(struct dvb_device *dvbdev);\n\n \nvoid dvb_device_put(struct dvb_device *dvbdev);\n\n \nint dvb_register_adapter(struct dvb_adapter *adap, const char *name,\n\t\t\t struct module *module, struct device *device,\n\t\t\t short *adapter_nums);\n\n \nint dvb_unregister_adapter(struct dvb_adapter *adap);\n\n \nint dvb_register_device(struct dvb_adapter *adap,\n\t\t\tstruct dvb_device **pdvbdev,\n\t\t\tconst struct dvb_device *template,\n\t\t\tvoid *priv,\n\t\t\tenum dvb_device_type type,\n\t\t\tint demux_sink_pads);\n\n \nvoid dvb_remove_device(struct dvb_device *dvbdev);\n\n\n \nvoid dvb_unregister_device(struct dvb_device *dvbdev);\n\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n \n__must_check int dvb_create_media_graph(struct dvb_adapter *adap,\n\t\t\t\t\tbool create_rf_connector);\n\n \nstatic inline void dvb_register_media_controller(struct dvb_adapter *adap,\n\t\t\t\t\t\t struct media_device *mdev)\n{\n\tadap->mdev = mdev;\n}\n\n \nstatic inline struct media_device *\ndvb_get_media_controller(struct dvb_adapter *adap)\n{\n\treturn adap->mdev;\n}\n#else\nstatic inline\nint dvb_create_media_graph(struct dvb_adapter *adap,\n\t\t\t   bool create_rf_connector)\n{\n\treturn 0;\n};\n#define dvb_register_media_controller(a, b) {}\n#define dvb_get_media_controller(a) NULL\n#endif\n\n \nint dvb_generic_open(struct inode *inode, struct file *file);\n\n \nint dvb_generic_release(struct inode *inode, struct file *file);\n\n \nlong dvb_generic_ioctl(struct file *file,\n\t\t       unsigned int cmd, unsigned long arg);\n\n \nint dvb_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t int (*func)(struct file *file, unsigned int cmd, void *arg));\n\n#if IS_ENABLED(CONFIG_I2C)\n\nstruct i2c_adapter;\nstruct i2c_client;\n \nstruct i2c_client *dvb_module_probe(const char *module_name,\n\t\t\t\t    const char *name,\n\t\t\t\t    struct i2c_adapter *adap,\n\t\t\t\t    unsigned char addr,\n\t\t\t\t    void *platform_data);\n\n \nvoid dvb_module_release(struct i2c_client *client);\n\n#endif  \n\n \n#ifdef CONFIG_MEDIA_ATTACH\n\n \n#define dvb_attach(FUNCTION, ARGS...) ({ \\\n\tvoid *__r = NULL; \\\n\ttypeof(&FUNCTION) __a = symbol_request(FUNCTION); \\\n\tif (__a) { \\\n\t\t__r = (void *) __a(ARGS); \\\n\t\tif (__r == NULL) \\\n\t\t\tsymbol_put(FUNCTION); \\\n\t} else { \\\n\t\tprintk(KERN_ERR \"DVB: Unable to find symbol \"#FUNCTION\"()\\n\"); \\\n\t} \\\n\t__r; \\\n})\n\n \n\n#define dvb_detach(FUNC)\tsymbol_put_addr(FUNC)\n\n#else\n#define dvb_attach(FUNCTION, ARGS...) ({ \\\n\tFUNCTION(ARGS); \\\n})\n\n#define dvb_detach(FUNC)\t{}\n\n#endif\t \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}