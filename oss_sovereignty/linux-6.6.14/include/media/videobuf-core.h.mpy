{
  "module_name": "videobuf-core.h",
  "hash_id": "8bdf111ab04c32d95872934b0705a100364d67713032f5e6edb5193e6d99c6d0",
  "original_prompt": "Ingested from linux-6.6.14/include/media/videobuf-core.h",
  "human_readable_source": " \n \n\n#ifndef _VIDEOBUF_CORE_H\n#define _VIDEOBUF_CORE_H\n\n#include <linux/poll.h>\n#include <linux/videodev2.h>\n\n#define UNSET (-1U)\n\n\nstruct videobuf_buffer;\nstruct videobuf_queue;\n\n \n\n \n\nstruct videobuf_mapping {\n\tunsigned int count;\n\tstruct videobuf_queue *q;\n};\n\nenum videobuf_state {\n\tVIDEOBUF_NEEDS_INIT = 0,\n\tVIDEOBUF_PREPARED   = 1,\n\tVIDEOBUF_QUEUED     = 2,\n\tVIDEOBUF_ACTIVE     = 3,\n\tVIDEOBUF_DONE       = 4,\n\tVIDEOBUF_ERROR      = 5,\n\tVIDEOBUF_IDLE       = 6,\n};\n\nstruct videobuf_buffer {\n\tunsigned int            i;\n\tu32                     magic;\n\n\t \n\tunsigned int            width;\n\tunsigned int            height;\n\tunsigned int            bytesperline;  \n\tunsigned long           size;\n\tenum v4l2_field         field;\n\tenum videobuf_state     state;\n\tstruct list_head        stream;   \n\n\t \n\tstruct list_head        queue;\n\twait_queue_head_t       done;\n\tunsigned int            field_count;\n\tu64\t\t\tts;\n\n\t \n\tenum v4l2_memory        memory;\n\n\t \n\tsize_t                  bsize;\n\n\t \n\tsize_t                  boff;\n\n\t \n\tunsigned long           baddr;\n\n\t \n\tstruct videobuf_mapping *map;\n\n\t \n\tint\t\t\tprivsize;\n\tvoid                    *priv;\n};\n\nstruct videobuf_queue_ops {\n\tint (*buf_setup)(struct videobuf_queue *q,\n\t\t\t unsigned int *count, unsigned int *size);\n\tint (*buf_prepare)(struct videobuf_queue *q,\n\t\t\t   struct videobuf_buffer *vb,\n\t\t\t   enum v4l2_field field);\n\tvoid (*buf_queue)(struct videobuf_queue *q,\n\t\t\t  struct videobuf_buffer *vb);\n\tvoid (*buf_release)(struct videobuf_queue *q,\n\t\t\t    struct videobuf_buffer *vb);\n};\n\n#define MAGIC_QTYPE_OPS\t0x12261003\n\n \nstruct videobuf_qtype_ops {\n\tu32                     magic;\n\n\tstruct videobuf_buffer *(*alloc_vb)(size_t size);\n\tvoid *(*vaddr)\t\t(struct videobuf_buffer *buf);\n\tint (*iolock)\t\t(struct videobuf_queue *q,\n\t\t\t\t struct videobuf_buffer *vb,\n\t\t\t\t struct v4l2_framebuffer *fbuf);\n\tint (*sync)\t\t(struct videobuf_queue *q,\n\t\t\t\t struct videobuf_buffer *buf);\n\tint (*mmap_mapper)\t(struct videobuf_queue *q,\n\t\t\t\t struct videobuf_buffer *buf,\n\t\t\t\t struct vm_area_struct *vma);\n};\n\nstruct videobuf_queue {\n\tstruct mutex               vb_lock;\n\tstruct mutex               *ext_lock;\n\tspinlock_t                 *irqlock;\n\tstruct device\t\t   *dev;\n\n\twait_queue_head_t\t   wait;  \n\n\tenum v4l2_buf_type         type;\n\tunsigned int               msize;\n\tenum v4l2_field            field;\n\tenum v4l2_field            last;    \n\tstruct videobuf_buffer     *bufs[VIDEO_MAX_FRAME];\n\tconst struct videobuf_queue_ops  *ops;\n\tstruct videobuf_qtype_ops  *int_ops;\n\n\tunsigned int               streaming:1;\n\tunsigned int               reading:1;\n\n\t \n\tstruct list_head           stream;\n\n\t \n\tunsigned int               read_off;\n\tstruct videobuf_buffer     *read_buf;\n\n\t \n\tvoid                       *priv_data;\n};\n\nstatic inline void videobuf_queue_lock(struct videobuf_queue *q)\n{\n\tif (!q->ext_lock)\n\t\tmutex_lock(&q->vb_lock);\n}\n\nstatic inline void videobuf_queue_unlock(struct videobuf_queue *q)\n{\n\tif (!q->ext_lock)\n\t\tmutex_unlock(&q->vb_lock);\n}\n\nint videobuf_waiton(struct videobuf_queue *q, struct videobuf_buffer *vb,\n\t\tint non_blocking, int intr);\nint videobuf_iolock(struct videobuf_queue *q, struct videobuf_buffer *vb,\n\t\tstruct v4l2_framebuffer *fbuf);\n\nstruct videobuf_buffer *videobuf_alloc_vb(struct videobuf_queue *q);\n\n \nvoid *videobuf_queue_to_vaddr(struct videobuf_queue *q,\n\t\t\t      struct videobuf_buffer *buf);\n\nvoid videobuf_queue_core_init(struct videobuf_queue *q,\n\t\t\t const struct videobuf_queue_ops *ops,\n\t\t\t struct device *dev,\n\t\t\t spinlock_t *irqlock,\n\t\t\t enum v4l2_buf_type type,\n\t\t\t enum v4l2_field field,\n\t\t\t unsigned int msize,\n\t\t\t void *priv,\n\t\t\t struct videobuf_qtype_ops *int_ops,\n\t\t\t struct mutex *ext_lock);\nint  videobuf_queue_is_busy(struct videobuf_queue *q);\nvoid videobuf_queue_cancel(struct videobuf_queue *q);\n\nenum v4l2_field videobuf_next_field(struct videobuf_queue *q);\nint videobuf_reqbufs(struct videobuf_queue *q,\n\t\t     struct v4l2_requestbuffers *req);\nint videobuf_querybuf(struct videobuf_queue *q, struct v4l2_buffer *b);\nint videobuf_qbuf(struct videobuf_queue *q,\n\t\t  struct v4l2_buffer *b);\nint videobuf_dqbuf(struct videobuf_queue *q,\n\t\t   struct v4l2_buffer *b, int nonblocking);\nint videobuf_streamon(struct videobuf_queue *q);\nint videobuf_streamoff(struct videobuf_queue *q);\n\nvoid videobuf_stop(struct videobuf_queue *q);\n\nint videobuf_read_start(struct videobuf_queue *q);\nvoid videobuf_read_stop(struct videobuf_queue *q);\nssize_t videobuf_read_stream(struct videobuf_queue *q,\n\t\t\t     char __user *data, size_t count, loff_t *ppos,\n\t\t\t     int vbihack, int nonblocking);\nssize_t videobuf_read_one(struct videobuf_queue *q,\n\t\t\t  char __user *data, size_t count, loff_t *ppos,\n\t\t\t  int nonblocking);\n__poll_t videobuf_poll_stream(struct file *file,\n\t\t\t\t  struct videobuf_queue *q,\n\t\t\t\t  poll_table *wait);\n\nint videobuf_mmap_setup(struct videobuf_queue *q,\n\t\t\tunsigned int bcount, unsigned int bsize,\n\t\t\tenum v4l2_memory memory);\nint __videobuf_mmap_setup(struct videobuf_queue *q,\n\t\t\tunsigned int bcount, unsigned int bsize,\n\t\t\tenum v4l2_memory memory);\nint videobuf_mmap_free(struct videobuf_queue *q);\nint videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}