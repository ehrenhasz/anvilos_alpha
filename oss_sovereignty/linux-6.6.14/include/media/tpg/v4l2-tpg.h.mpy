{
  "module_name": "v4l2-tpg.h",
  "hash_id": "35f4a523c3f910f840787ec0c7b28e4b0e1854d0807aca81be1104c1333322ed",
  "original_prompt": "Ingested from linux-6.6.14/include/media/tpg/v4l2-tpg.h",
  "human_readable_source": " \n \n\n#ifndef _V4L2_TPG_H_\n#define _V4L2_TPG_H_\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/videodev2.h>\n\nstruct tpg_rbg_color8 {\n\tunsigned char r, g, b;\n};\n\nstruct tpg_rbg_color16 {\n\t__u16 r, g, b;\n};\n\nenum tpg_color {\n\tTPG_COLOR_CSC_WHITE,\n\tTPG_COLOR_CSC_YELLOW,\n\tTPG_COLOR_CSC_CYAN,\n\tTPG_COLOR_CSC_GREEN,\n\tTPG_COLOR_CSC_MAGENTA,\n\tTPG_COLOR_CSC_RED,\n\tTPG_COLOR_CSC_BLUE,\n\tTPG_COLOR_CSC_BLACK,\n\tTPG_COLOR_75_YELLOW,\n\tTPG_COLOR_75_CYAN,\n\tTPG_COLOR_75_GREEN,\n\tTPG_COLOR_75_MAGENTA,\n\tTPG_COLOR_75_RED,\n\tTPG_COLOR_75_BLUE,\n\tTPG_COLOR_100_WHITE,\n\tTPG_COLOR_100_YELLOW,\n\tTPG_COLOR_100_CYAN,\n\tTPG_COLOR_100_GREEN,\n\tTPG_COLOR_100_MAGENTA,\n\tTPG_COLOR_100_RED,\n\tTPG_COLOR_100_BLUE,\n\tTPG_COLOR_100_BLACK,\n\tTPG_COLOR_TEXTFG,\n\tTPG_COLOR_TEXTBG,\n\tTPG_COLOR_RANDOM,\n\tTPG_COLOR_RAMP,\n\tTPG_COLOR_MAX = TPG_COLOR_RAMP + 256\n};\n\nextern const struct tpg_rbg_color8 tpg_colors[TPG_COLOR_MAX];\nextern const unsigned short tpg_rec709_to_linear[255 * 16 + 1];\nextern const unsigned short tpg_linear_to_rec709[255 * 16 + 1];\nextern const struct tpg_rbg_color16 tpg_csc_colors[V4L2_COLORSPACE_DCI_P3 + 1]\n\t\t\t\t\t  [V4L2_XFER_FUNC_SMPTE2084 + 1]\n\t\t\t\t\t  [TPG_COLOR_CSC_BLACK + 1];\nenum tpg_pattern {\n\tTPG_PAT_75_COLORBAR,\n\tTPG_PAT_100_COLORBAR,\n\tTPG_PAT_CSC_COLORBAR,\n\tTPG_PAT_100_HCOLORBAR,\n\tTPG_PAT_100_COLORSQUARES,\n\tTPG_PAT_BLACK,\n\tTPG_PAT_WHITE,\n\tTPG_PAT_RED,\n\tTPG_PAT_GREEN,\n\tTPG_PAT_BLUE,\n\tTPG_PAT_CHECKERS_16X16,\n\tTPG_PAT_CHECKERS_2X2,\n\tTPG_PAT_CHECKERS_1X1,\n\tTPG_PAT_COLOR_CHECKERS_2X2,\n\tTPG_PAT_COLOR_CHECKERS_1X1,\n\tTPG_PAT_ALTERNATING_HLINES,\n\tTPG_PAT_ALTERNATING_VLINES,\n\tTPG_PAT_CROSS_1_PIXEL,\n\tTPG_PAT_CROSS_2_PIXELS,\n\tTPG_PAT_CROSS_10_PIXELS,\n\tTPG_PAT_GRAY_RAMP,\n\n\t \n\tTPG_PAT_NOISE,\n};\n\nextern const char * const tpg_pattern_strings[];\n\nenum tpg_quality {\n\tTPG_QUAL_COLOR,\n\tTPG_QUAL_GRAY,\n\tTPG_QUAL_NOISE\n};\n\nenum tpg_video_aspect {\n\tTPG_VIDEO_ASPECT_IMAGE,\n\tTPG_VIDEO_ASPECT_4X3,\n\tTPG_VIDEO_ASPECT_14X9_CENTRE,\n\tTPG_VIDEO_ASPECT_16X9_CENTRE,\n\tTPG_VIDEO_ASPECT_16X9_ANAMORPHIC,\n};\n\nenum tpg_pixel_aspect {\n\tTPG_PIXEL_ASPECT_SQUARE,\n\tTPG_PIXEL_ASPECT_NTSC,\n\tTPG_PIXEL_ASPECT_PAL,\n};\n\nenum tpg_move_mode {\n\tTPG_MOVE_NEG_FAST,\n\tTPG_MOVE_NEG,\n\tTPG_MOVE_NEG_SLOW,\n\tTPG_MOVE_NONE,\n\tTPG_MOVE_POS_SLOW,\n\tTPG_MOVE_POS,\n\tTPG_MOVE_POS_FAST,\n};\n\nenum tgp_color_enc {\n\tTGP_COLOR_ENC_RGB,\n\tTGP_COLOR_ENC_YCBCR,\n\tTGP_COLOR_ENC_HSV,\n\tTGP_COLOR_ENC_LUMA,\n};\n\nextern const char * const tpg_aspect_strings[];\n\n#define TPG_MAX_PLANES 3\n#define TPG_MAX_PAT_LINES 8\n\nstruct tpg_data {\n\t \n\tunsigned\t\t\tsrc_width, src_height;\n\t \n\tunsigned\t\t\tbuf_height;\n\t \n\tunsigned\t\t\tscaled_width;\n\tu32\t\t\t\tfield;\n\tbool\t\t\t\tfield_alternate;\n\t \n\tstruct v4l2_rect\t\tcrop;\n\t \n\tstruct v4l2_rect\t\tcompose;\n\t \n\tstruct v4l2_rect\t\tborder;\n\tstruct v4l2_rect\t\tsquare;\n\n\t \n\tenum tpg_quality\t\tqual;\n\tunsigned\t\t\tqual_offset;\n\tu8\t\t\t\talpha_component;\n\tbool\t\t\t\talpha_red_only;\n\tu8\t\t\t\tbrightness;\n\tu8\t\t\t\tcontrast;\n\tu8\t\t\t\tsaturation;\n\ts16\t\t\t\thue;\n\tu32\t\t\t\tfourcc;\n\tenum tgp_color_enc\t\tcolor_enc;\n\tu32\t\t\t\tcolorspace;\n\tu32\t\t\t\txfer_func;\n\tu32\t\t\t\tycbcr_enc;\n\tu32\t\t\t\thsv_enc;\n\t \n\tu32\t\t\t\treal_xfer_func;\n\t \n\tu32\t\t\t\treal_hsv_enc;\n\tu32\t\t\t\treal_ycbcr_enc;\n\tu32\t\t\t\tquantization;\n\t \n\tu32\t\t\t\treal_quantization;\n\tenum tpg_video_aspect\t\tvid_aspect;\n\tenum tpg_pixel_aspect\t\tpix_aspect;\n\tunsigned\t\t\trgb_range;\n\tunsigned\t\t\treal_rgb_range;\n\tunsigned\t\t\tbuffers;\n\tunsigned\t\t\tplanes;\n\tbool\t\t\t\tinterleaved;\n\tu8\t\t\t\tvdownsampling[TPG_MAX_PLANES];\n\tu8\t\t\t\thdownsampling[TPG_MAX_PLANES];\n\t \n\tunsigned\t\t\thmask[TPG_MAX_PLANES];\n\t \n\tu8\t\t\t\tcolors[TPG_COLOR_MAX][3];\n\tu8\t\t\t\ttextfg[TPG_MAX_PLANES][8], textbg[TPG_MAX_PLANES][8];\n\t \n\tunsigned\t\t\ttwopixelsize[TPG_MAX_PLANES];\n\tunsigned\t\t\tbytesperline[TPG_MAX_PLANES];\n\n\t \n\tenum tpg_pattern\t\tpattern;\n\tbool\t\t\t\thflip;\n\tbool\t\t\t\tvflip;\n\tunsigned\t\t\tperc_fill;\n\tbool\t\t\t\tperc_fill_blank;\n\tbool\t\t\t\tshow_border;\n\tbool\t\t\t\tshow_square;\n\tbool\t\t\t\tinsert_sav;\n\tbool\t\t\t\tinsert_eav;\n\tbool\t\t\t\tinsert_hdmi_video_guard_band;\n\n\t \n\tenum tpg_move_mode\t\tmv_hor_mode;\n\tint\t\t\t\tmv_hor_count;\n\tint\t\t\t\tmv_hor_step;\n\tenum tpg_move_mode\t\tmv_vert_mode;\n\tint\t\t\t\tmv_vert_count;\n\tint\t\t\t\tmv_vert_step;\n\n\tbool\t\t\t\trecalc_colors;\n\tbool\t\t\t\trecalc_lines;\n\tbool\t\t\t\trecalc_square_border;\n\n\t \n\tunsigned\t\t\tmax_line_width;\n\tu8\t\t\t\t*lines[TPG_MAX_PAT_LINES][TPG_MAX_PLANES];\n\tu8\t\t\t\t*downsampled_lines[TPG_MAX_PAT_LINES][TPG_MAX_PLANES];\n\tu8\t\t\t\t*random_line[TPG_MAX_PLANES];\n\tu8\t\t\t\t*contrast_line[TPG_MAX_PLANES];\n\tu8\t\t\t\t*black_line[TPG_MAX_PLANES];\n};\n\nvoid tpg_init(struct tpg_data *tpg, unsigned w, unsigned h);\nint tpg_alloc(struct tpg_data *tpg, unsigned max_w);\nvoid tpg_free(struct tpg_data *tpg);\nvoid tpg_reset_source(struct tpg_data *tpg, unsigned width, unsigned height,\n\t\t       u32 field);\nvoid tpg_log_status(struct tpg_data *tpg);\n\nvoid tpg_set_font(const u8 *f);\nvoid tpg_gen_text(const struct tpg_data *tpg,\n\t\tu8 *basep[TPG_MAX_PLANES][2], int y, int x, const char *text);\nvoid tpg_calc_text_basep(struct tpg_data *tpg,\n\t\tu8 *basep[TPG_MAX_PLANES][2], unsigned p, u8 *vbuf);\nunsigned tpg_g_interleaved_plane(const struct tpg_data *tpg, unsigned buf_line);\nvoid tpg_fill_plane_buffer(struct tpg_data *tpg, v4l2_std_id std,\n\t\t\t   unsigned p, u8 *vbuf);\nvoid tpg_fillbuffer(struct tpg_data *tpg, v4l2_std_id std,\n\t\t    unsigned p, u8 *vbuf);\nbool tpg_s_fourcc(struct tpg_data *tpg, u32 fourcc);\nvoid tpg_s_crop_compose(struct tpg_data *tpg, const struct v4l2_rect *crop,\n\t\tconst struct v4l2_rect *compose);\nconst char *tpg_g_color_order(const struct tpg_data *tpg);\n\nstatic inline void tpg_s_pattern(struct tpg_data *tpg, enum tpg_pattern pattern)\n{\n\tif (tpg->pattern == pattern)\n\t\treturn;\n\ttpg->pattern = pattern;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline void tpg_s_quality(struct tpg_data *tpg,\n\t\t\t\t    enum tpg_quality qual, unsigned qual_offset)\n{\n\tif (tpg->qual == qual && tpg->qual_offset == qual_offset)\n\t\treturn;\n\ttpg->qual = qual;\n\ttpg->qual_offset = qual_offset;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline enum tpg_quality tpg_g_quality(const struct tpg_data *tpg)\n{\n\treturn tpg->qual;\n}\n\nstatic inline void tpg_s_alpha_component(struct tpg_data *tpg,\n\t\t\t\t\t    u8 alpha_component)\n{\n\tif (tpg->alpha_component == alpha_component)\n\t\treturn;\n\ttpg->alpha_component = alpha_component;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline void tpg_s_alpha_mode(struct tpg_data *tpg,\n\t\t\t\t\t    bool red_only)\n{\n\tif (tpg->alpha_red_only == red_only)\n\t\treturn;\n\ttpg->alpha_red_only = red_only;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline void tpg_s_brightness(struct tpg_data *tpg,\n\t\t\t\t\tu8 brightness)\n{\n\tif (tpg->brightness == brightness)\n\t\treturn;\n\ttpg->brightness = brightness;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline void tpg_s_contrast(struct tpg_data *tpg,\n\t\t\t\t\tu8 contrast)\n{\n\tif (tpg->contrast == contrast)\n\t\treturn;\n\ttpg->contrast = contrast;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline void tpg_s_saturation(struct tpg_data *tpg,\n\t\t\t\t\tu8 saturation)\n{\n\tif (tpg->saturation == saturation)\n\t\treturn;\n\ttpg->saturation = saturation;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline void tpg_s_hue(struct tpg_data *tpg,\n\t\t\t\t\ts16 hue)\n{\n\thue = clamp_t(s16, hue, -128, 128);\n\tif (tpg->hue == hue)\n\t\treturn;\n\ttpg->hue = hue;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline void tpg_s_rgb_range(struct tpg_data *tpg,\n\t\t\t\t\tunsigned rgb_range)\n{\n\tif (tpg->rgb_range == rgb_range)\n\t\treturn;\n\ttpg->rgb_range = rgb_range;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline void tpg_s_real_rgb_range(struct tpg_data *tpg,\n\t\t\t\t\tunsigned rgb_range)\n{\n\tif (tpg->real_rgb_range == rgb_range)\n\t\treturn;\n\ttpg->real_rgb_range = rgb_range;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline void tpg_s_colorspace(struct tpg_data *tpg, u32 colorspace)\n{\n\tif (tpg->colorspace == colorspace)\n\t\treturn;\n\ttpg->colorspace = colorspace;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline u32 tpg_g_colorspace(const struct tpg_data *tpg)\n{\n\treturn tpg->colorspace;\n}\n\nstatic inline void tpg_s_ycbcr_enc(struct tpg_data *tpg, u32 ycbcr_enc)\n{\n\tif (tpg->ycbcr_enc == ycbcr_enc)\n\t\treturn;\n\ttpg->ycbcr_enc = ycbcr_enc;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline u32 tpg_g_ycbcr_enc(const struct tpg_data *tpg)\n{\n\treturn tpg->ycbcr_enc;\n}\n\nstatic inline void tpg_s_hsv_enc(struct tpg_data *tpg, u32 hsv_enc)\n{\n\tif (tpg->hsv_enc == hsv_enc)\n\t\treturn;\n\ttpg->hsv_enc = hsv_enc;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline u32 tpg_g_hsv_enc(const struct tpg_data *tpg)\n{\n\treturn tpg->hsv_enc;\n}\n\nstatic inline void tpg_s_xfer_func(struct tpg_data *tpg, u32 xfer_func)\n{\n\tif (tpg->xfer_func == xfer_func)\n\t\treturn;\n\ttpg->xfer_func = xfer_func;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline u32 tpg_g_xfer_func(const struct tpg_data *tpg)\n{\n\treturn tpg->xfer_func;\n}\n\nstatic inline void tpg_s_quantization(struct tpg_data *tpg, u32 quantization)\n{\n\tif (tpg->quantization == quantization)\n\t\treturn;\n\ttpg->quantization = quantization;\n\ttpg->recalc_colors = true;\n}\n\nstatic inline u32 tpg_g_quantization(const struct tpg_data *tpg)\n{\n\treturn tpg->quantization;\n}\n\nstatic inline unsigned tpg_g_buffers(const struct tpg_data *tpg)\n{\n\treturn tpg->buffers;\n}\n\nstatic inline unsigned tpg_g_planes(const struct tpg_data *tpg)\n{\n\treturn tpg->interleaved ? 1 : tpg->planes;\n}\n\nstatic inline bool tpg_g_interleaved(const struct tpg_data *tpg)\n{\n\treturn tpg->interleaved;\n}\n\nstatic inline unsigned tpg_g_twopixelsize(const struct tpg_data *tpg, unsigned plane)\n{\n\treturn tpg->twopixelsize[plane];\n}\n\nstatic inline unsigned tpg_hdiv(const struct tpg_data *tpg,\n\t\t\t\t  unsigned plane, unsigned x)\n{\n\treturn ((x / tpg->hdownsampling[plane]) & tpg->hmask[plane]) *\n\t\ttpg->twopixelsize[plane] / 2;\n}\n\nstatic inline unsigned tpg_hscale(const struct tpg_data *tpg, unsigned x)\n{\n\treturn (x * tpg->scaled_width) / tpg->src_width;\n}\n\nstatic inline unsigned tpg_hscale_div(const struct tpg_data *tpg,\n\t\t\t\t      unsigned plane, unsigned x)\n{\n\treturn tpg_hdiv(tpg, plane, tpg_hscale(tpg, x));\n}\n\nstatic inline unsigned tpg_g_bytesperline(const struct tpg_data *tpg, unsigned plane)\n{\n\treturn tpg->bytesperline[plane];\n}\n\nstatic inline void tpg_s_bytesperline(struct tpg_data *tpg, unsigned plane, unsigned bpl)\n{\n\tunsigned p;\n\n\tif (tpg->buffers > 1) {\n\t\ttpg->bytesperline[plane] = bpl;\n\t\treturn;\n\t}\n\n\tfor (p = 0; p < tpg_g_planes(tpg); p++) {\n\t\tunsigned plane_w = bpl * tpg->twopixelsize[p] / tpg->twopixelsize[0];\n\n\t\ttpg->bytesperline[p] = plane_w / tpg->hdownsampling[p];\n\t}\n\tif (tpg_g_interleaved(tpg))\n\t\ttpg->bytesperline[1] = tpg->bytesperline[0];\n}\n\n\nstatic inline unsigned tpg_g_line_width(const struct tpg_data *tpg, unsigned plane)\n{\n\tunsigned w = 0;\n\tunsigned p;\n\n\tif (tpg->buffers > 1)\n\t\treturn tpg_g_bytesperline(tpg, plane);\n\tfor (p = 0; p < tpg_g_planes(tpg); p++) {\n\t\tunsigned plane_w = tpg_g_bytesperline(tpg, p);\n\n\t\tw += plane_w / tpg->vdownsampling[p];\n\t}\n\treturn w;\n}\n\nstatic inline unsigned tpg_calc_line_width(const struct tpg_data *tpg,\n\t\t\t\t\t   unsigned plane, unsigned bpl)\n{\n\tunsigned w = 0;\n\tunsigned p;\n\n\tif (tpg->buffers > 1)\n\t\treturn bpl;\n\tfor (p = 0; p < tpg_g_planes(tpg); p++) {\n\t\tunsigned plane_w = bpl * tpg->twopixelsize[p] / tpg->twopixelsize[0];\n\n\t\tplane_w /= tpg->hdownsampling[p];\n\t\tw += plane_w / tpg->vdownsampling[p];\n\t}\n\treturn w;\n}\n\nstatic inline unsigned tpg_calc_plane_size(const struct tpg_data *tpg, unsigned plane)\n{\n\tif (plane >= tpg_g_planes(tpg))\n\t\treturn 0;\n\n\treturn tpg_g_bytesperline(tpg, plane) * tpg->buf_height /\n\t       tpg->vdownsampling[plane];\n}\n\nstatic inline void tpg_s_buf_height(struct tpg_data *tpg, unsigned h)\n{\n\ttpg->buf_height = h;\n}\n\nstatic inline void tpg_s_field(struct tpg_data *tpg, unsigned field, bool alternate)\n{\n\ttpg->field = field;\n\ttpg->field_alternate = alternate;\n}\n\nstatic inline void tpg_s_perc_fill(struct tpg_data *tpg,\n\t\t\t\t      unsigned perc_fill)\n{\n\ttpg->perc_fill = perc_fill;\n}\n\nstatic inline unsigned tpg_g_perc_fill(const struct tpg_data *tpg)\n{\n\treturn tpg->perc_fill;\n}\n\nstatic inline void tpg_s_perc_fill_blank(struct tpg_data *tpg,\n\t\t\t\t\t bool perc_fill_blank)\n{\n\ttpg->perc_fill_blank = perc_fill_blank;\n}\n\nstatic inline void tpg_s_video_aspect(struct tpg_data *tpg,\n\t\t\t\t\tenum tpg_video_aspect vid_aspect)\n{\n\tif (tpg->vid_aspect == vid_aspect)\n\t\treturn;\n\ttpg->vid_aspect = vid_aspect;\n\ttpg->recalc_square_border = true;\n}\n\nstatic inline enum tpg_video_aspect tpg_g_video_aspect(const struct tpg_data *tpg)\n{\n\treturn tpg->vid_aspect;\n}\n\nstatic inline void tpg_s_pixel_aspect(struct tpg_data *tpg,\n\t\t\t\t\tenum tpg_pixel_aspect pix_aspect)\n{\n\tif (tpg->pix_aspect == pix_aspect)\n\t\treturn;\n\ttpg->pix_aspect = pix_aspect;\n\ttpg->recalc_square_border = true;\n}\n\nstatic inline void tpg_s_show_border(struct tpg_data *tpg,\n\t\t\t\t\tbool show_border)\n{\n\ttpg->show_border = show_border;\n}\n\nstatic inline void tpg_s_show_square(struct tpg_data *tpg,\n\t\t\t\t\tbool show_square)\n{\n\ttpg->show_square = show_square;\n}\n\nstatic inline void tpg_s_insert_sav(struct tpg_data *tpg, bool insert_sav)\n{\n\ttpg->insert_sav = insert_sav;\n}\n\nstatic inline void tpg_s_insert_eav(struct tpg_data *tpg, bool insert_eav)\n{\n\ttpg->insert_eav = insert_eav;\n}\n\n \nstatic inline void tpg_s_insert_hdmi_video_guard_band(struct tpg_data *tpg,\n\t\t\t\t\t\t      bool insert_hdmi_video_guard_band)\n{\n\ttpg->insert_hdmi_video_guard_band = insert_hdmi_video_guard_band;\n}\n\nvoid tpg_update_mv_step(struct tpg_data *tpg);\n\nstatic inline void tpg_s_mv_hor_mode(struct tpg_data *tpg,\n\t\t\t\tenum tpg_move_mode mv_hor_mode)\n{\n\ttpg->mv_hor_mode = mv_hor_mode;\n\ttpg_update_mv_step(tpg);\n}\n\nstatic inline void tpg_s_mv_vert_mode(struct tpg_data *tpg,\n\t\t\t\tenum tpg_move_mode mv_vert_mode)\n{\n\ttpg->mv_vert_mode = mv_vert_mode;\n\ttpg_update_mv_step(tpg);\n}\n\nstatic inline void tpg_init_mv_count(struct tpg_data *tpg)\n{\n\ttpg->mv_hor_count = tpg->mv_vert_count = 0;\n}\n\nstatic inline void tpg_update_mv_count(struct tpg_data *tpg, bool frame_is_field)\n{\n\ttpg->mv_hor_count += tpg->mv_hor_step * (frame_is_field ? 1 : 2);\n\ttpg->mv_vert_count += tpg->mv_vert_step * (frame_is_field ? 1 : 2);\n}\n\nstatic inline void tpg_s_hflip(struct tpg_data *tpg, bool hflip)\n{\n\tif (tpg->hflip == hflip)\n\t\treturn;\n\ttpg->hflip = hflip;\n\ttpg_update_mv_step(tpg);\n\ttpg->recalc_lines = true;\n}\n\nstatic inline bool tpg_g_hflip(const struct tpg_data *tpg)\n{\n\treturn tpg->hflip;\n}\n\nstatic inline void tpg_s_vflip(struct tpg_data *tpg, bool vflip)\n{\n\ttpg->vflip = vflip;\n}\n\nstatic inline bool tpg_g_vflip(const struct tpg_data *tpg)\n{\n\treturn tpg->vflip;\n}\n\nstatic inline bool tpg_pattern_is_static(const struct tpg_data *tpg)\n{\n\treturn tpg->pattern != TPG_PAT_NOISE &&\n\t       tpg->mv_hor_mode == TPG_MOVE_NONE &&\n\t       tpg->mv_vert_mode == TPG_MOVE_NONE;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}