{
  "module_name": "exynos-fimc.h",
  "hash_id": "fe2aa9b0d02d369a21cc6228a34ae9dd752cc7448dacf02c83f0f84bff1cfff1",
  "original_prompt": "Ingested from linux-6.6.14/include/media/drv-intf/exynos-fimc.h",
  "human_readable_source": " \n \n\n#ifndef S5P_FIMC_H_\n#define S5P_FIMC_H_\n\n#include <media/media-entity.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-mediabus.h>\n\n \nenum fimc_input {\n\tFIMC_INPUT_PARALLEL_0\t= 1,\n\tFIMC_INPUT_PARALLEL_1,\n\tFIMC_INPUT_MIPI_CSI2_0\t= 3,\n\tFIMC_INPUT_MIPI_CSI2_1,\n\tFIMC_INPUT_WRITEBACK_A\t= 5,\n\tFIMC_INPUT_WRITEBACK_B,\n\tFIMC_INPUT_WRITEBACK_ISP = 5,\n};\n\n \nenum fimc_bus_type {\n\t \n\tFIMC_BUS_TYPE_ITU_601 = 1,\n\t \n\tFIMC_BUS_TYPE_ITU_656,\n\t \n\tFIMC_BUS_TYPE_MIPI_CSI2,\n\t \n\tFIMC_BUS_TYPE_LCD_WRITEBACK_A,\n\t \n\tFIMC_BUS_TYPE_LCD_WRITEBACK_B,\n\t \n\tFIMC_BUS_TYPE_ISP_WRITEBACK = FIMC_BUS_TYPE_LCD_WRITEBACK_B,\n};\n\n#define fimc_input_is_parallel(x) ((x) == 1 || (x) == 2)\n#define fimc_input_is_mipi_csi(x) ((x) == 3 || (x) == 4)\n\n \n#define GRP_ID_SENSOR\t\t(1 << 8)\n#define GRP_ID_FIMC_IS_SENSOR\t(1 << 9)\n#define GRP_ID_WRITEBACK\t(1 << 10)\n#define GRP_ID_CSIS\t\t(1 << 11)\n#define GRP_ID_FIMC\t\t(1 << 12)\n#define GRP_ID_FLITE\t\t(1 << 13)\n#define GRP_ID_FIMC_IS\t\t(1 << 14)\n\n \nstruct fimc_source_info {\n\tenum fimc_bus_type fimc_bus_type;\n\tenum fimc_bus_type sensor_bus_type;\n\tu16 flags;\n\tu16 mux_id;\n};\n\n \n#define S5P_FIMC_TX_END_NOTIFY _IO('e', 0)\n\n#define FIMC_MAX_PLANES\t3\n\n \nstruct fimc_fmt {\n\tu32 mbus_code;\n\tu32\tfourcc;\n\tu32\tcolor;\n\tu16\tmemplanes;\n\tu16\tcolplanes;\n\tu8\tcolorspace;\n\tu8\tdepth[FIMC_MAX_PLANES];\n\tu16\tmdataplanes;\n\tu16\tflags;\n#define FMT_FLAGS_CAM\t\t(1 << 0)\n#define FMT_FLAGS_M2M_IN\t(1 << 1)\n#define FMT_FLAGS_M2M_OUT\t(1 << 2)\n#define FMT_FLAGS_M2M\t\t(1 << 1 | 1 << 2)\n#define FMT_HAS_ALPHA\t\t(1 << 3)\n#define FMT_FLAGS_COMPRESSED\t(1 << 4)\n#define FMT_FLAGS_WRITEBACK\t(1 << 5)\n#define FMT_FLAGS_RAW_BAYER\t(1 << 6)\n#define FMT_FLAGS_YUV\t\t(1 << 7)\n};\n\nstruct exynos_media_pipeline;\n\n \nstruct exynos_media_pipeline_ops {\n\tint (*prepare)(struct exynos_media_pipeline *p,\n\t\t\t\t\t\tstruct media_entity *me);\n\tint (*unprepare)(struct exynos_media_pipeline *p);\n\tint (*open)(struct exynos_media_pipeline *p, struct media_entity *me,\n\t\t\t\t\t\t\tbool resume);\n\tint (*close)(struct exynos_media_pipeline *p);\n\tint (*set_stream)(struct exynos_media_pipeline *p, bool state);\n};\n\nstruct exynos_video_entity {\n\tstruct video_device vdev;\n\tstruct exynos_media_pipeline *pipe;\n};\n\nstruct exynos_media_pipeline {\n\tstruct media_pipeline mp;\n\tconst struct exynos_media_pipeline_ops *ops;\n};\n\nstatic inline struct exynos_video_entity *vdev_to_exynos_video_entity(\n\t\t\t\t\tstruct video_device *vdev)\n{\n\treturn container_of(vdev, struct exynos_video_entity, vdev);\n}\n\n#define fimc_pipeline_call(ent, op, args...)\t\t\t\t  \\\n\t((!(ent) || !(ent)->pipe) ? -ENOENT : \\\n\t(((ent)->pipe->ops && (ent)->pipe->ops->op) ? \\\n\t(ent)->pipe->ops->op(((ent)->pipe), ##args) : -ENOIOCTLCMD))\t  \\\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}