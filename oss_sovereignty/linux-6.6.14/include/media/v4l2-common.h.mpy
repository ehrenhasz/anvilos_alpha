{
  "module_name": "v4l2-common.h",
  "hash_id": "d252c173eb5c741ca19b393df1866bf167cc5c42452fd78fbb1cf949c9bb0a85",
  "original_prompt": "Ingested from linux-6.6.14/include/media/v4l2-common.h",
  "human_readable_source": " \n \n\n#ifndef V4L2_COMMON_H_\n#define V4L2_COMMON_H_\n\n#include <linux/time.h>\n#include <media/v4l2-dev.h>\n\n \n#define v4l_printk(level, name, adapter, addr, fmt, arg...) \\\n\tprintk(level \"%s %d-%04x: \" fmt, name, i2c_adapter_id(adapter), addr , ## arg)\n\n#define v4l_client_printk(level, client, fmt, arg...)\t\t\t    \\\n\tv4l_printk(level, (client)->dev.driver->name, (client)->adapter, \\\n\t\t   (client)->addr, fmt , ## arg)\n\n#define v4l_err(client, fmt, arg...) \\\n\tv4l_client_printk(KERN_ERR, client, fmt , ## arg)\n\n#define v4l_warn(client, fmt, arg...) \\\n\tv4l_client_printk(KERN_WARNING, client, fmt , ## arg)\n\n#define v4l_info(client, fmt, arg...) \\\n\tv4l_client_printk(KERN_INFO, client, fmt , ## arg)\n\n \n#define v4l_dbg(level, debug, client, fmt, arg...)\t\t\t     \\\n\tdo {\t\t\t\t\t\t\t\t     \\\n\t\tif (debug >= (level))\t\t\t\t\t     \\\n\t\t\tv4l_client_printk(KERN_DEBUG, client, fmt , ## arg); \\\n\t} while (0)\n\n \n#define dev_dbg_lvl(__dev, __level, __debug, __fmt, __arg...)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (__debug >= (__level))\t\t\t\t\\\n\t\t\tdev_printk(KERN_DEBUG, __dev, __fmt, ##__arg);\t\\\n\t} while (0)\n\n \n\n \n#define v4l2_printk(level, dev, fmt, arg...) \\\n\tprintk(level \"%s: \" fmt, (dev)->name , ## arg)\n\n#define v4l2_err(dev, fmt, arg...) \\\n\tv4l2_printk(KERN_ERR, dev, fmt , ## arg)\n\n#define v4l2_warn(dev, fmt, arg...) \\\n\tv4l2_printk(KERN_WARNING, dev, fmt , ## arg)\n\n#define v4l2_info(dev, fmt, arg...) \\\n\tv4l2_printk(KERN_INFO, dev, fmt , ## arg)\n\n \n#define v4l2_dbg(level, debug, dev, fmt, arg...)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (debug >= (level))\t\t\t\t\t\\\n\t\t\tv4l2_printk(KERN_DEBUG, dev, fmt , ## arg);\t\\\n\t} while (0)\n\n \n\nint v4l2_ctrl_query_fill(struct v4l2_queryctrl *qctrl,\n\t\t\t s32 min, s32 max, s32 step, s32 def);\n\n \n\nstruct v4l2_device;\nstruct v4l2_subdev;\nstruct v4l2_subdev_ops;\n\n \n#include <linux/i2c.h>\n\n \nenum v4l2_i2c_tuner_type {\n\tADDRS_RADIO,\n\tADDRS_DEMOD,\n\tADDRS_TV,\n\tADDRS_TV_WITH_DEMOD,\n};\n\n#if defined(CONFIG_VIDEO_V4L2_I2C)\n\n \nstruct v4l2_subdev *v4l2_i2c_new_subdev(struct v4l2_device *v4l2_dev,\n\t\tstruct i2c_adapter *adapter, const char *client_type,\n\t\tu8 addr, const unsigned short *probe_addrs);\n\n \nstruct v4l2_subdev *v4l2_i2c_new_subdev_board(struct v4l2_device *v4l2_dev,\n\t\tstruct i2c_adapter *adapter, struct i2c_board_info *info,\n\t\tconst unsigned short *probe_addrs);\n\n \nvoid v4l2_i2c_subdev_set_name(struct v4l2_subdev *sd, struct i2c_client *client,\n\t\t\t      const char *devname, const char *postfix);\n\n \nvoid v4l2_i2c_subdev_init(struct v4l2_subdev *sd, struct i2c_client *client,\n\t\tconst struct v4l2_subdev_ops *ops);\n\n \nunsigned short v4l2_i2c_subdev_addr(struct v4l2_subdev *sd);\n\n \nconst unsigned short *v4l2_i2c_tuner_addrs(enum v4l2_i2c_tuner_type type);\n\n \nvoid v4l2_i2c_subdev_unregister(struct v4l2_subdev *sd);\n\n#else\n\nstatic inline struct v4l2_subdev *\nv4l2_i2c_new_subdev(struct v4l2_device *v4l2_dev,\n\t\t    struct i2c_adapter *adapter, const char *client_type,\n\t\t    u8 addr, const unsigned short *probe_addrs)\n{\n\treturn NULL;\n}\n\nstatic inline struct v4l2_subdev *\nv4l2_i2c_new_subdev_board(struct v4l2_device *v4l2_dev,\n\t\t\t  struct i2c_adapter *adapter, struct i2c_board_info *info,\n\t\t\t  const unsigned short *probe_addrs)\n{\n\treturn NULL;\n}\n\nstatic inline void\nv4l2_i2c_subdev_set_name(struct v4l2_subdev *sd, struct i2c_client *client,\n\t\t\t const char *devname, const char *postfix)\n{}\n\nstatic inline void\nv4l2_i2c_subdev_init(struct v4l2_subdev *sd, struct i2c_client *client,\n\t\t     const struct v4l2_subdev_ops *ops)\n{}\n\nstatic inline unsigned short v4l2_i2c_subdev_addr(struct v4l2_subdev *sd)\n{\n\treturn I2C_CLIENT_END;\n}\n\nstatic inline const unsigned short *\nv4l2_i2c_tuner_addrs(enum v4l2_i2c_tuner_type type)\n{\n\treturn NULL;\n}\n\nstatic inline void v4l2_i2c_subdev_unregister(struct v4l2_subdev *sd)\n{}\n\n#endif\n\n \n\n \n\n#include <linux/spi/spi.h>\n\n#if defined(CONFIG_SPI)\n\n \nstruct v4l2_subdev *v4l2_spi_new_subdev(struct v4l2_device *v4l2_dev,\n\t\tstruct spi_master *master, struct spi_board_info *info);\n\n \nvoid v4l2_spi_subdev_init(struct v4l2_subdev *sd, struct spi_device *spi,\n\t\tconst struct v4l2_subdev_ops *ops);\n\n \nvoid v4l2_spi_subdev_unregister(struct v4l2_subdev *sd);\n\n#else\n\nstatic inline struct v4l2_subdev *\nv4l2_spi_new_subdev(struct v4l2_device *v4l2_dev,\n\t\t    struct spi_master *master, struct spi_board_info *info)\n{\n\treturn NULL;\n}\n\nstatic inline void\nv4l2_spi_subdev_init(struct v4l2_subdev *sd, struct spi_device *spi,\n\t\t     const struct v4l2_subdev_ops *ops)\n{}\n\nstatic inline void v4l2_spi_subdev_unregister(struct v4l2_subdev *sd)\n{}\n#endif\n\n \n\n \n\n \nstruct v4l2_priv_tun_config {\n\tint tuner;\n\tvoid *priv;\n};\n#define TUNER_SET_CONFIG           _IOW('d', 92, struct v4l2_priv_tun_config)\n\n#define VIDIOC_INT_RESET\t\t_IOW ('d', 102, u32)\n\n \n\n \n\n \nvoid v4l_bound_align_image(unsigned int *width, unsigned int wmin,\n\t\t\t   unsigned int wmax, unsigned int walign,\n\t\t\t   unsigned int *height, unsigned int hmin,\n\t\t\t   unsigned int hmax, unsigned int halign,\n\t\t\t   unsigned int salign);\n\n \n#define v4l2_find_nearest_size(array, array_size, width_field, height_field, \\\n\t\t\t       width, height)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tBUILD_BUG_ON(sizeof((array)->width_field) != sizeof(u32) || \\\n\t\t\t     sizeof((array)->height_field) != sizeof(u32)); \\\n\t\t(typeof(&(array)[0]))__v4l2_find_nearest_size(\t\t\\\n\t\t\t(array), array_size, sizeof(*(array)),\t\t\\\n\t\t\toffsetof(typeof(*(array)), width_field),\t\\\n\t\t\toffsetof(typeof(*(array)), height_field),\t\\\n\t\t\twidth, height);\t\t\t\t\t\\\n\t})\nconst void *\n__v4l2_find_nearest_size(const void *array, size_t array_size,\n\t\t\t size_t entry_size, size_t width_offset,\n\t\t\t size_t height_offset, s32 width, s32 height);\n\n \nint v4l2_g_parm_cap(struct video_device *vdev,\n\t\t    struct v4l2_subdev *sd, struct v4l2_streamparm *a);\n\n \nint v4l2_s_parm_cap(struct video_device *vdev,\n\t\t    struct v4l2_subdev *sd, struct v4l2_streamparm *a);\n\n \n#define V4L2_FRACT_COMPARE(a, OP, b)\t\t\t\\\n\t((u64)(a).numerator * (b).denominator OP\t\\\n\t(u64)(b).numerator * (a).denominator)\n\n \n\n \n\n \nenum v4l2_pixel_encoding {\n\tV4L2_PIXEL_ENC_UNKNOWN = 0,\n\tV4L2_PIXEL_ENC_YUV = 1,\n\tV4L2_PIXEL_ENC_RGB = 2,\n\tV4L2_PIXEL_ENC_BAYER = 3,\n};\n\n \nstruct v4l2_format_info {\n\tu32 format;\n\tu8 pixel_enc;\n\tu8 mem_planes;\n\tu8 comp_planes;\n\tu8 bpp[4];\n\tu8 bpp_div[4];\n\tu8 hdiv;\n\tu8 vdiv;\n\tu8 block_w[4];\n\tu8 block_h[4];\n};\n\nstatic inline bool v4l2_is_format_rgb(const struct v4l2_format_info *f)\n{\n\treturn f && f->pixel_enc == V4L2_PIXEL_ENC_RGB;\n}\n\nstatic inline bool v4l2_is_format_yuv(const struct v4l2_format_info *f)\n{\n\treturn f && f->pixel_enc == V4L2_PIXEL_ENC_YUV;\n}\n\nstatic inline bool v4l2_is_format_bayer(const struct v4l2_format_info *f)\n{\n\treturn f && f->pixel_enc == V4L2_PIXEL_ENC_BAYER;\n}\n\nconst struct v4l2_format_info *v4l2_format_info(u32 format);\nvoid v4l2_apply_frmsize_constraints(u32 *width, u32 *height,\n\t\t\t\t    const struct v4l2_frmsize_stepwise *frmsize);\nint v4l2_fill_pixfmt(struct v4l2_pix_format *pixfmt, u32 pixelformat,\n\t\t     u32 width, u32 height);\nint v4l2_fill_pixfmt_mp(struct v4l2_pix_format_mplane *pixfmt, u32 pixelformat,\n\t\t\tu32 width, u32 height);\n\n \ns64 v4l2_get_link_freq(struct v4l2_ctrl_handler *handler, unsigned int mul,\n\t\t       unsigned int div);\n\nvoid v4l2_simplify_fraction(u32 *numerator, u32 *denominator,\n\t\tunsigned int n_terms, unsigned int threshold);\nu32 v4l2_fraction_to_interval(u32 numerator, u32 denominator);\n\nstatic inline u64 v4l2_buffer_get_timestamp(const struct v4l2_buffer *buf)\n{\n\t \n\treturn buf->timestamp.tv_sec * NSEC_PER_SEC +\n\t\t(u32)buf->timestamp.tv_usec * NSEC_PER_USEC;\n}\n\nstatic inline void v4l2_buffer_set_timestamp(struct v4l2_buffer *buf,\n\t\t\t\t\t     u64 timestamp)\n{\n\tstruct timespec64 ts = ns_to_timespec64(timestamp);\n\n\tbuf->timestamp.tv_sec  = ts.tv_sec;\n\tbuf->timestamp.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n}\n\nstatic inline bool v4l2_is_colorspace_valid(__u32 colorspace)\n{\n\treturn colorspace > V4L2_COLORSPACE_DEFAULT &&\n\t       colorspace < V4L2_COLORSPACE_LAST;\n}\n\nstatic inline bool v4l2_is_xfer_func_valid(__u32 xfer_func)\n{\n\treturn xfer_func > V4L2_XFER_FUNC_DEFAULT &&\n\t       xfer_func < V4L2_XFER_FUNC_LAST;\n}\n\nstatic inline bool v4l2_is_ycbcr_enc_valid(__u8 ycbcr_enc)\n{\n\treturn ycbcr_enc > V4L2_YCBCR_ENC_DEFAULT &&\n\t       ycbcr_enc < V4L2_YCBCR_ENC_LAST;\n}\n\nstatic inline bool v4l2_is_hsv_enc_valid(__u8 hsv_enc)\n{\n\treturn hsv_enc == V4L2_HSV_ENC_180 || hsv_enc == V4L2_HSV_ENC_256;\n}\n\nstatic inline bool v4l2_is_quant_valid(__u8 quantization)\n{\n\treturn quantization == V4L2_QUANTIZATION_FULL_RANGE ||\n\t       quantization == V4L2_QUANTIZATION_LIM_RANGE;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}