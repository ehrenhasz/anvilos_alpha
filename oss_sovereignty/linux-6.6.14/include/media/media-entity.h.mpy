{
  "module_name": "media-entity.h",
  "hash_id": "fb5ac1afe7a544fb93654305edfcb5f48d79c14c985e7a6082d5fc5649cf3838",
  "original_prompt": "Ingested from linux-6.6.14/include/media/media-entity.h",
  "human_readable_source": " \n \n\n#ifndef _MEDIA_ENTITY_H\n#define _MEDIA_ENTITY_H\n\n#include <linux/bitmap.h>\n#include <linux/bug.h>\n#include <linux/container_of.h>\n#include <linux/fwnode.h>\n#include <linux/list.h>\n#include <linux/media.h>\n#include <linux/minmax.h>\n#include <linux/types.h>\n\n \n\n \nenum media_gobj_type {\n\tMEDIA_GRAPH_ENTITY,\n\tMEDIA_GRAPH_PAD,\n\tMEDIA_GRAPH_LINK,\n\tMEDIA_GRAPH_INTF_DEVNODE,\n};\n\n#define MEDIA_BITS_PER_TYPE\t\t8\n#define MEDIA_BITS_PER_ID\t\t(32 - MEDIA_BITS_PER_TYPE)\n#define MEDIA_ID_MASK\t\t\t GENMASK_ULL(MEDIA_BITS_PER_ID - 1, 0)\n\n \n\n \nstruct media_gobj {\n\tstruct media_device\t*mdev;\n\tu32\t\t\tid;\n\tstruct list_head\tlist;\n};\n\n#define MEDIA_ENTITY_ENUM_MAX_DEPTH\t16\n\n \nstruct media_entity_enum {\n\tunsigned long *bmap;\n\tint idx_max;\n};\n\n \nstruct media_graph {\n\tstruct {\n\t\tstruct media_entity *entity;\n\t\tstruct list_head *link;\n\t} stack[MEDIA_ENTITY_ENUM_MAX_DEPTH];\n\n\tstruct media_entity_enum ent_enum;\n\tint top;\n};\n\n \nstruct media_pipeline {\n\tbool allocated;\n\tstruct media_device *mdev;\n\tstruct list_head pads;\n\tint start_count;\n};\n\n \nstruct media_pipeline_pad {\n\tstruct list_head list;\n\tstruct media_pipeline *pipe;\n\tstruct media_pad *pad;\n};\n\n \nstruct media_pipeline_pad_iter {\n\tstruct list_head *cursor;\n};\n\n \nstruct media_pipeline_entity_iter {\n\tstruct media_entity_enum ent_enum;\n\tstruct list_head *cursor;\n};\n\n \nstruct media_link {\n\tstruct media_gobj graph_obj;\n\tstruct list_head list;\n\tunion {\n\t\tstruct media_gobj *gobj0;\n\t\tstruct media_pad *source;\n\t\tstruct media_interface *intf;\n\t};\n\tunion {\n\t\tstruct media_gobj *gobj1;\n\t\tstruct media_pad *sink;\n\t\tstruct media_entity *entity;\n\t};\n\tstruct media_link *reverse;\n\tunsigned long flags;\n\tbool is_backlink;\n};\n\n \nenum media_pad_signal_type {\n\tPAD_SIGNAL_DEFAULT = 0,\n\tPAD_SIGNAL_ANALOG,\n\tPAD_SIGNAL_DV,\n\tPAD_SIGNAL_AUDIO,\n};\n\n \nstruct media_pad {\n\tstruct media_gobj graph_obj;\t \n\tstruct media_entity *entity;\n\tu16 index;\n\tenum media_pad_signal_type sig_type;\n\tunsigned long flags;\n\n\t \n\tstruct media_pipeline *pipe;\n};\n\n \nstruct media_entity_operations {\n\tint (*get_fwnode_pad)(struct media_entity *entity,\n\t\t\t      struct fwnode_endpoint *endpoint);\n\tint (*link_setup)(struct media_entity *entity,\n\t\t\t  const struct media_pad *local,\n\t\t\t  const struct media_pad *remote, u32 flags);\n\tint (*link_validate)(struct media_link *link);\n\tbool (*has_pad_interdep)(struct media_entity *entity, unsigned int pad0,\n\t\t\t\t unsigned int pad1);\n};\n\n \nenum media_entity_type {\n\tMEDIA_ENTITY_TYPE_BASE,\n\tMEDIA_ENTITY_TYPE_VIDEO_DEVICE,\n\tMEDIA_ENTITY_TYPE_V4L2_SUBDEV,\n};\n\n \nstruct media_entity {\n\tstruct media_gobj graph_obj;\t \n\tconst char *name;\n\tenum media_entity_type obj_type;\n\tu32 function;\n\tunsigned long flags;\n\n\tu16 num_pads;\n\tu16 num_links;\n\tu16 num_backlinks;\n\tint internal_idx;\n\n\tstruct media_pad *pads;\n\tstruct list_head links;\n\n\tconst struct media_entity_operations *ops;\n\n\tint use_count;\n\n\tunion {\n\t\tstruct {\n\t\t\tu32 major;\n\t\t\tu32 minor;\n\t\t} dev;\n\t} info;\n};\n\n \n#define media_entity_for_each_pad(entity, iter)\t\t\t\\\n\tfor (iter = (entity)->pads;\t\t\t\t\\\n\t     iter < &(entity)->pads[(entity)->num_pads];\t\\\n\t     ++iter)\n\n \nstruct media_interface {\n\tstruct media_gobj\t\tgraph_obj;\n\tstruct list_head\t\tlinks;\n\tu32\t\t\t\ttype;\n\tu32\t\t\t\tflags;\n};\n\n \nstruct media_intf_devnode {\n\tstruct media_interface\t\tintf;\n\n\t \n\tu32\t\t\t\tmajor;\n\tu32\t\t\t\tminor;\n};\n\n \nstatic inline u32 media_entity_id(struct media_entity *entity)\n{\n\treturn entity->graph_obj.id;\n}\n\n \nstatic inline enum media_gobj_type media_type(struct media_gobj *gobj)\n{\n\treturn gobj->id >> MEDIA_BITS_PER_ID;\n}\n\n \nstatic inline u32 media_id(struct media_gobj *gobj)\n{\n\treturn gobj->id & MEDIA_ID_MASK;\n}\n\n \nstatic inline u32 media_gobj_gen_id(enum media_gobj_type type, u64 local_id)\n{\n\tu32 id;\n\n\tid = type << MEDIA_BITS_PER_ID;\n\tid |= local_id & MEDIA_ID_MASK;\n\n\treturn id;\n}\n\n \nstatic inline bool is_media_entity_v4l2_video_device(struct media_entity *entity)\n{\n\treturn entity && entity->obj_type == MEDIA_ENTITY_TYPE_VIDEO_DEVICE;\n}\n\n \nstatic inline bool is_media_entity_v4l2_subdev(struct media_entity *entity)\n{\n\treturn entity && entity->obj_type == MEDIA_ENTITY_TYPE_V4L2_SUBDEV;\n}\n\n \n__must_check int media_entity_enum_init(struct media_entity_enum *ent_enum,\n\t\t\t\t\tstruct media_device *mdev);\n\n \nvoid media_entity_enum_cleanup(struct media_entity_enum *ent_enum);\n\n \nstatic inline void media_entity_enum_zero(struct media_entity_enum *ent_enum)\n{\n\tbitmap_zero(ent_enum->bmap, ent_enum->idx_max);\n}\n\n \nstatic inline void media_entity_enum_set(struct media_entity_enum *ent_enum,\n\t\t\t\t\t struct media_entity *entity)\n{\n\tif (WARN_ON(entity->internal_idx >= ent_enum->idx_max))\n\t\treturn;\n\n\t__set_bit(entity->internal_idx, ent_enum->bmap);\n}\n\n \nstatic inline void media_entity_enum_clear(struct media_entity_enum *ent_enum,\n\t\t\t\t\t   struct media_entity *entity)\n{\n\tif (WARN_ON(entity->internal_idx >= ent_enum->idx_max))\n\t\treturn;\n\n\t__clear_bit(entity->internal_idx, ent_enum->bmap);\n}\n\n \nstatic inline bool media_entity_enum_test(struct media_entity_enum *ent_enum,\n\t\t\t\t\t  struct media_entity *entity)\n{\n\tif (WARN_ON(entity->internal_idx >= ent_enum->idx_max))\n\t\treturn true;\n\n\treturn test_bit(entity->internal_idx, ent_enum->bmap);\n}\n\n \nstatic inline bool\nmedia_entity_enum_test_and_set(struct media_entity_enum *ent_enum,\n\t\t\t       struct media_entity *entity)\n{\n\tif (WARN_ON(entity->internal_idx >= ent_enum->idx_max))\n\t\treturn true;\n\n\treturn __test_and_set_bit(entity->internal_idx, ent_enum->bmap);\n}\n\n \nstatic inline bool media_entity_enum_empty(struct media_entity_enum *ent_enum)\n{\n\treturn bitmap_empty(ent_enum->bmap, ent_enum->idx_max);\n}\n\n \nstatic inline bool media_entity_enum_intersects(\n\tstruct media_entity_enum *ent_enum1,\n\tstruct media_entity_enum *ent_enum2)\n{\n\tWARN_ON(ent_enum1->idx_max != ent_enum2->idx_max);\n\n\treturn bitmap_intersects(ent_enum1->bmap, ent_enum2->bmap,\n\t\t\t\t min(ent_enum1->idx_max, ent_enum2->idx_max));\n}\n\n \n#define gobj_to_entity(gobj) \\\n\t\tcontainer_of(gobj, struct media_entity, graph_obj)\n\n \n#define gobj_to_pad(gobj) \\\n\t\tcontainer_of(gobj, struct media_pad, graph_obj)\n\n \n#define gobj_to_link(gobj) \\\n\t\tcontainer_of(gobj, struct media_link, graph_obj)\n\n \n#define gobj_to_intf(gobj) \\\n\t\tcontainer_of(gobj, struct media_interface, graph_obj)\n\n \n#define intf_to_devnode(intf) \\\n\t\tcontainer_of(intf, struct media_intf_devnode, intf)\n\n \nvoid media_gobj_create(struct media_device *mdev,\n\t\t    enum media_gobj_type type,\n\t\t    struct media_gobj *gobj);\n\n \nvoid media_gobj_destroy(struct media_gobj *gobj);\n\n \nint media_entity_pads_init(struct media_entity *entity, u16 num_pads,\n\t\t      struct media_pad *pads);\n\n \n#if IS_ENABLED(CONFIG_MEDIA_CONTROLLER)\nstatic inline void media_entity_cleanup(struct media_entity *entity) {}\n#else\n#define media_entity_cleanup(entity) do { } while (false)\n#endif\n\n \nint media_get_pad_index(struct media_entity *entity, u32 pad_type,\n\t\t\tenum media_pad_signal_type sig_type);\n\n \n__must_check int media_create_pad_link(struct media_entity *source,\n\t\t\tu16 source_pad, struct media_entity *sink,\n\t\t\tu16 sink_pad, u32 flags);\n\n \nint media_create_pad_links(const struct media_device *mdev,\n\t\t\t   const u32 source_function,\n\t\t\t   struct media_entity *source,\n\t\t\t   const u16 source_pad,\n\t\t\t   const u32 sink_function,\n\t\t\t   struct media_entity *sink,\n\t\t\t   const u16 sink_pad,\n\t\t\t   u32 flags,\n\t\t\t   const bool allow_both_undefined);\n\nvoid __media_entity_remove_links(struct media_entity *entity);\n\n \nvoid media_entity_remove_links(struct media_entity *entity);\n\n \nint __media_entity_setup_link(struct media_link *link, u32 flags);\n\n \nint media_entity_setup_link(struct media_link *link, u32 flags);\n\n \nstruct media_link *media_entity_find_link(struct media_pad *source,\n\t\tstruct media_pad *sink);\n\n \nstruct media_pad *media_pad_remote_pad_first(const struct media_pad *pad);\n\n \nstruct media_pad *media_pad_remote_pad_unique(const struct media_pad *pad);\n\n \nstruct media_pad *\nmedia_entity_remote_pad_unique(const struct media_entity *entity,\n\t\t\t       unsigned int type);\n\n \nstatic inline struct media_pad *\nmedia_entity_remote_source_pad_unique(const struct media_entity *entity)\n{\n\treturn media_entity_remote_pad_unique(entity, MEDIA_PAD_FL_SOURCE);\n}\n\n \nstatic inline bool media_pad_is_streaming(const struct media_pad *pad)\n{\n\treturn pad->pipe;\n}\n\n \nstatic inline bool media_entity_is_streaming(const struct media_entity *entity)\n{\n\tstruct media_pad *pad;\n\n\tmedia_entity_for_each_pad(entity, pad) {\n\t\tif (media_pad_is_streaming(pad))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstruct media_pipeline *media_entity_pipeline(struct media_entity *entity);\n\n \nstruct media_pipeline *media_pad_pipeline(struct media_pad *pad);\n\n \nint media_entity_get_fwnode_pad(struct media_entity *entity,\n\t\t\t\tconst struct fwnode_handle *fwnode,\n\t\t\t\tunsigned long direction_flags);\n\n \n__must_check int media_graph_walk_init(\n\tstruct media_graph *graph, struct media_device *mdev);\n\n \nvoid media_graph_walk_cleanup(struct media_graph *graph);\n\n \nvoid media_graph_walk_start(struct media_graph *graph,\n\t\t\t    struct media_entity *entity);\n\n \nstruct media_entity *media_graph_walk_next(struct media_graph *graph);\n\n \n__must_check int media_pipeline_start(struct media_pad *pad,\n\t\t\t\t      struct media_pipeline *pipe);\n \n__must_check int __media_pipeline_start(struct media_pad *pad,\n\t\t\t\t\tstruct media_pipeline *pipe);\n\n \nvoid media_pipeline_stop(struct media_pad *pad);\n\n \nvoid __media_pipeline_stop(struct media_pad *pad);\n\nstruct media_pad *\n__media_pipeline_pad_iter_next(struct media_pipeline *pipe,\n\t\t\t       struct media_pipeline_pad_iter *iter,\n\t\t\t       struct media_pad *pad);\n\n \n#define media_pipeline_for_each_pad(pipe, iter, pad)\t\t\t\\\n\tfor (pad = __media_pipeline_pad_iter_next((pipe), iter, NULL);\t\\\n\t     pad != NULL;\t\t\t\t\t\t\\\n\t     pad = __media_pipeline_pad_iter_next((pipe), iter, pad))\n\n \nint media_pipeline_entity_iter_init(struct media_pipeline *pipe,\n\t\t\t\t    struct media_pipeline_entity_iter *iter);\n\n \nvoid media_pipeline_entity_iter_cleanup(struct media_pipeline_entity_iter *iter);\n\nstruct media_entity *\n__media_pipeline_entity_iter_next(struct media_pipeline *pipe,\n\t\t\t\t  struct media_pipeline_entity_iter *iter,\n\t\t\t\t  struct media_entity *entity);\n\n \n#define media_pipeline_for_each_entity(pipe, iter, entity)\t\t\t\\\n\tfor (entity = __media_pipeline_entity_iter_next((pipe), iter, NULL);\t\\\n\t     entity != NULL;\t\t\t\t\t\t\t\\\n\t     entity = __media_pipeline_entity_iter_next((pipe), iter, entity))\n\n \n__must_check int media_pipeline_alloc_start(struct media_pad *pad);\n\n \nstruct media_intf_devnode *\n__must_check media_devnode_create(struct media_device *mdev,\n\t\t\t\t  u32 type, u32 flags,\n\t\t\t\t  u32 major, u32 minor);\n \nvoid media_devnode_remove(struct media_intf_devnode *devnode);\n\n \nstruct media_link *\n__must_check media_create_intf_link(struct media_entity *entity,\n\t\t\t\t    struct media_interface *intf,\n\t\t\t\t    u32 flags);\n \nvoid __media_remove_intf_link(struct media_link *link);\n\n \nvoid media_remove_intf_link(struct media_link *link);\n\n \nvoid __media_remove_intf_links(struct media_interface *intf);\n\n \nvoid media_remove_intf_links(struct media_interface *intf);\n\n \n\n#define media_entity_call(entity, operation, args...)\t\t\t\\\n\t(((entity)->ops && (entity)->ops->operation) ?\t\t\t\\\n\t (entity)->ops->operation((entity) , ##args) : -ENOIOCTLCMD)\n\n \nstruct media_link *\nmedia_create_ancillary_link(struct media_entity *primary,\n\t\t\t    struct media_entity *ancillary);\n\n \nstruct media_link *__media_entity_next_link(struct media_entity *entity,\n\t\t\t\t\t    struct media_link *link,\n\t\t\t\t\t    unsigned long link_type);\n\n \n#define for_each_media_entity_data_link(entity, link)\t\t\t\\\n\tfor (link = __media_entity_next_link(entity, NULL,\t\t\\\n\t\t\t\t\t     MEDIA_LNK_FL_DATA_LINK);\t\\\n\t     link;\t\t\t\t\t\t\t\\\n\t     link = __media_entity_next_link(entity, link,\t\t\\\n\t\t\t\t\t     MEDIA_LNK_FL_DATA_LINK))\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}