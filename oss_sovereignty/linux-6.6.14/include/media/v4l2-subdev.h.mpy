{
  "module_name": "v4l2-subdev.h",
  "hash_id": "277340f5230a5241248d4cf2b4e943a03a379bf3a0dd2df2527b310083722874",
  "original_prompt": "Ingested from linux-6.6.14/include/media/v4l2-subdev.h",
  "human_readable_source": " \n \n\n#ifndef _V4L2_SUBDEV_H\n#define _V4L2_SUBDEV_H\n\n#include <linux/types.h>\n#include <linux/v4l2-subdev.h>\n#include <media/media-entity.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-mediabus.h>\n\n \n#define V4L2_SUBDEV_IR_RX_NOTIFY\t\t_IOW('v', 0, u32)\n#define V4L2_SUBDEV_IR_RX_FIFO_SERVICE_REQ\t0x00000001\n#define V4L2_SUBDEV_IR_RX_END_OF_RX_DETECTED\t0x00000002\n#define V4L2_SUBDEV_IR_RX_HW_FIFO_OVERRUN\t0x00000004\n#define V4L2_SUBDEV_IR_RX_SW_FIFO_OVERRUN\t0x00000008\n\n#define V4L2_SUBDEV_IR_TX_NOTIFY\t\t_IOW('v', 1, u32)\n#define V4L2_SUBDEV_IR_TX_FIFO_SERVICE_REQ\t0x00000001\n\n#define\tV4L2_DEVICE_NOTIFY_EVENT\t\t_IOW('v', 2, struct v4l2_event)\n\nstruct v4l2_device;\nstruct v4l2_ctrl_handler;\nstruct v4l2_event;\nstruct v4l2_event_subscription;\nstruct v4l2_fh;\nstruct v4l2_subdev;\nstruct v4l2_subdev_fh;\nstruct tuner_setup;\nstruct v4l2_mbus_frame_desc;\nstruct led_classdev;\n\n \nstruct v4l2_decode_vbi_line {\n\tu32 is_second_field;\n\tu8 *p;\n\tu32 line;\n\tu32 type;\n};\n\n \n\n \n\n \nenum v4l2_subdev_io_pin_bits {\n\tV4L2_SUBDEV_IO_PIN_DISABLE\t= 0,\n\tV4L2_SUBDEV_IO_PIN_OUTPUT\t= 1,\n\tV4L2_SUBDEV_IO_PIN_INPUT\t= 2,\n\tV4L2_SUBDEV_IO_PIN_SET_VALUE\t= 3,\n\tV4L2_SUBDEV_IO_PIN_ACTIVE_LOW\t= 4,\n};\n\n \nstruct v4l2_subdev_io_pin_config {\n\tu32 flags;\n\tu8 pin;\n\tu8 function;\n\tu8 value;\n\tu8 strength;\n};\n\n \nstruct v4l2_subdev_core_ops {\n\tint (*log_status)(struct v4l2_subdev *sd);\n\tint (*s_io_pin_config)(struct v4l2_subdev *sd, size_t n,\n\t\t\t\t      struct v4l2_subdev_io_pin_config *pincfg);\n\tint (*init)(struct v4l2_subdev *sd, u32 val);\n\tint (*load_fw)(struct v4l2_subdev *sd);\n\tint (*reset)(struct v4l2_subdev *sd, u32 val);\n\tint (*s_gpio)(struct v4l2_subdev *sd, u32 val);\n\tlong (*command)(struct v4l2_subdev *sd, unsigned int cmd, void *arg);\n\tlong (*ioctl)(struct v4l2_subdev *sd, unsigned int cmd, void *arg);\n#ifdef CONFIG_COMPAT\n\tlong (*compat_ioctl32)(struct v4l2_subdev *sd, unsigned int cmd,\n\t\t\t       unsigned long arg);\n#endif\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\tint (*g_register)(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg);\n\tint (*s_register)(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg);\n#endif\n\tint (*s_power)(struct v4l2_subdev *sd, int on);\n\tint (*interrupt_service_routine)(struct v4l2_subdev *sd,\n\t\t\t\t\t\tu32 status, bool *handled);\n\tint (*subscribe_event)(struct v4l2_subdev *sd, struct v4l2_fh *fh,\n\t\t\t       struct v4l2_event_subscription *sub);\n\tint (*unsubscribe_event)(struct v4l2_subdev *sd, struct v4l2_fh *fh,\n\t\t\t\t struct v4l2_event_subscription *sub);\n};\n\n \nstruct v4l2_subdev_tuner_ops {\n\tint (*standby)(struct v4l2_subdev *sd);\n\tint (*s_radio)(struct v4l2_subdev *sd);\n\tint (*s_frequency)(struct v4l2_subdev *sd, const struct v4l2_frequency *freq);\n\tint (*g_frequency)(struct v4l2_subdev *sd, struct v4l2_frequency *freq);\n\tint (*enum_freq_bands)(struct v4l2_subdev *sd, struct v4l2_frequency_band *band);\n\tint (*g_tuner)(struct v4l2_subdev *sd, struct v4l2_tuner *vt);\n\tint (*s_tuner)(struct v4l2_subdev *sd, const struct v4l2_tuner *vt);\n\tint (*g_modulator)(struct v4l2_subdev *sd, struct v4l2_modulator *vm);\n\tint (*s_modulator)(struct v4l2_subdev *sd, const struct v4l2_modulator *vm);\n\tint (*s_type_addr)(struct v4l2_subdev *sd, struct tuner_setup *type);\n\tint (*s_config)(struct v4l2_subdev *sd, const struct v4l2_priv_tun_config *config);\n};\n\n \nstruct v4l2_subdev_audio_ops {\n\tint (*s_clock_freq)(struct v4l2_subdev *sd, u32 freq);\n\tint (*s_i2s_clock_freq)(struct v4l2_subdev *sd, u32 freq);\n\tint (*s_routing)(struct v4l2_subdev *sd, u32 input, u32 output, u32 config);\n\tint (*s_stream)(struct v4l2_subdev *sd, int enable);\n};\n\n \nstruct v4l2_mbus_frame_desc_entry_csi2 {\n\tu8 vc;\n\tu8 dt;\n};\n\n \nenum v4l2_mbus_frame_desc_flags {\n\tV4L2_MBUS_FRAME_DESC_FL_LEN_MAX\t= BIT(0),\n\tV4L2_MBUS_FRAME_DESC_FL_BLOB\t= BIT(1),\n};\n\n \nstruct v4l2_mbus_frame_desc_entry {\n\tenum v4l2_mbus_frame_desc_flags flags;\n\tu32 stream;\n\tu32 pixelcode;\n\tu32 length;\n\tunion {\n\t\tstruct v4l2_mbus_frame_desc_entry_csi2 csi2;\n\t} bus;\n};\n\n  \n#define V4L2_FRAME_DESC_ENTRY_MAX\t8\n\n \nenum v4l2_mbus_frame_desc_type {\n\tV4L2_MBUS_FRAME_DESC_TYPE_UNDEFINED = 0,\n\tV4L2_MBUS_FRAME_DESC_TYPE_PARALLEL,\n\tV4L2_MBUS_FRAME_DESC_TYPE_CSI2,\n};\n\n \nstruct v4l2_mbus_frame_desc {\n\tenum v4l2_mbus_frame_desc_type type;\n\tstruct v4l2_mbus_frame_desc_entry entry[V4L2_FRAME_DESC_ENTRY_MAX];\n\tunsigned short num_entries;\n};\n\n \nenum v4l2_subdev_pre_streamon_flags {\n\tV4L2_SUBDEV_PRE_STREAMON_FL_MANUAL_LP = BIT(0),\n};\n\n \nstruct v4l2_subdev_video_ops {\n\tint (*s_routing)(struct v4l2_subdev *sd, u32 input, u32 output, u32 config);\n\tint (*s_crystal_freq)(struct v4l2_subdev *sd, u32 freq, u32 flags);\n\tint (*g_std)(struct v4l2_subdev *sd, v4l2_std_id *norm);\n\tint (*s_std)(struct v4l2_subdev *sd, v4l2_std_id norm);\n\tint (*s_std_output)(struct v4l2_subdev *sd, v4l2_std_id std);\n\tint (*g_std_output)(struct v4l2_subdev *sd, v4l2_std_id *std);\n\tint (*querystd)(struct v4l2_subdev *sd, v4l2_std_id *std);\n\tint (*g_tvnorms)(struct v4l2_subdev *sd, v4l2_std_id *std);\n\tint (*g_tvnorms_output)(struct v4l2_subdev *sd, v4l2_std_id *std);\n\tint (*g_input_status)(struct v4l2_subdev *sd, u32 *status);\n\tint (*s_stream)(struct v4l2_subdev *sd, int enable);\n\tint (*g_pixelaspect)(struct v4l2_subdev *sd, struct v4l2_fract *aspect);\n\tint (*g_frame_interval)(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_frame_interval *interval);\n\tint (*s_frame_interval)(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_frame_interval *interval);\n\tint (*s_dv_timings)(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_dv_timings *timings);\n\tint (*g_dv_timings)(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_dv_timings *timings);\n\tint (*query_dv_timings)(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_dv_timings *timings);\n\tint (*s_rx_buffer)(struct v4l2_subdev *sd, void *buf,\n\t\t\t   unsigned int *size);\n\tint (*pre_streamon)(struct v4l2_subdev *sd, u32 flags);\n\tint (*post_streamoff)(struct v4l2_subdev *sd);\n};\n\n \nstruct v4l2_subdev_vbi_ops {\n\tint (*decode_vbi_line)(struct v4l2_subdev *sd, struct v4l2_decode_vbi_line *vbi_line);\n\tint (*s_vbi_data)(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *vbi_data);\n\tint (*g_vbi_data)(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_data *vbi_data);\n\tint (*g_sliced_vbi_cap)(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_cap *cap);\n\tint (*s_raw_fmt)(struct v4l2_subdev *sd, struct v4l2_vbi_format *fmt);\n\tint (*g_sliced_fmt)(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *fmt);\n\tint (*s_sliced_fmt)(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *fmt);\n};\n\n \nstruct v4l2_subdev_sensor_ops {\n\tint (*g_skip_top_lines)(struct v4l2_subdev *sd, u32 *lines);\n\tint (*g_skip_frames)(struct v4l2_subdev *sd, u32 *frames);\n};\n\n \nenum v4l2_subdev_ir_mode {\n\tV4L2_SUBDEV_IR_MODE_PULSE_WIDTH,\n};\n\n \nstruct v4l2_subdev_ir_parameters {\n\tunsigned int bytes_per_data_element;\n\tenum v4l2_subdev_ir_mode mode;\n\n\tbool enable;\n\tbool interrupt_enable;\n\tbool shutdown;\n\n\tbool modulation;\n\tu32 max_pulse_width;\n\tunsigned int carrier_freq;\n\tunsigned int duty_cycle;\n\tbool invert_level;\n\n\t \n\tbool invert_carrier_sense;\n\n\t \n\tu32 noise_filter_min_width;\n\tunsigned int carrier_range_lower;\n\tunsigned int carrier_range_upper;\n\tu32 resolution;\n};\n\n \nstruct v4l2_subdev_ir_ops {\n\t \n\tint (*rx_read)(struct v4l2_subdev *sd, u8 *buf, size_t count,\n\t\t\t\tssize_t *num);\n\n\tint (*rx_g_parameters)(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_ir_parameters *params);\n\tint (*rx_s_parameters)(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_ir_parameters *params);\n\n\t \n\tint (*tx_write)(struct v4l2_subdev *sd, u8 *buf, size_t count,\n\t\t\t\tssize_t *num);\n\n\tint (*tx_g_parameters)(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_ir_parameters *params);\n\tint (*tx_s_parameters)(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_ir_parameters *params);\n};\n\n \nstruct v4l2_subdev_pad_config {\n\tstruct v4l2_mbus_framefmt try_fmt;\n\tstruct v4l2_rect try_crop;\n\tstruct v4l2_rect try_compose;\n};\n\n \nstruct v4l2_subdev_stream_config {\n\tu32 pad;\n\tu32 stream;\n\tbool enabled;\n\n\tstruct v4l2_mbus_framefmt fmt;\n\tstruct v4l2_rect crop;\n\tstruct v4l2_rect compose;\n};\n\n \nstruct v4l2_subdev_stream_configs {\n\tu32 num_configs;\n\tstruct v4l2_subdev_stream_config *configs;\n};\n\n \nstruct v4l2_subdev_krouting {\n\tunsigned int num_routes;\n\tstruct v4l2_subdev_route *routes;\n};\n\n \nstruct v4l2_subdev_state {\n\t \n\tstruct mutex _lock;\n\tstruct mutex *lock;\n\tstruct v4l2_subdev_pad_config *pads;\n\tstruct v4l2_subdev_krouting routing;\n\tstruct v4l2_subdev_stream_configs stream_configs;\n};\n\n \nstruct v4l2_subdev_pad_ops {\n\tint (*init_cfg)(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_subdev_state *state);\n\tint (*enum_mbus_code)(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code);\n\tint (*enum_frame_size)(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse);\n\tint (*enum_frame_interval)(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *state,\n\t\t\t\t   struct v4l2_subdev_frame_interval_enum *fie);\n\tint (*get_fmt)(struct v4l2_subdev *sd,\n\t\t       struct v4l2_subdev_state *state,\n\t\t       struct v4l2_subdev_format *format);\n\tint (*set_fmt)(struct v4l2_subdev *sd,\n\t\t       struct v4l2_subdev_state *state,\n\t\t       struct v4l2_subdev_format *format);\n\tint (*get_selection)(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *state,\n\t\t\t     struct v4l2_subdev_selection *sel);\n\tint (*set_selection)(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *state,\n\t\t\t     struct v4l2_subdev_selection *sel);\n\tint (*get_edid)(struct v4l2_subdev *sd, struct v4l2_edid *edid);\n\tint (*set_edid)(struct v4l2_subdev *sd, struct v4l2_edid *edid);\n\tint (*dv_timings_cap)(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_dv_timings_cap *cap);\n\tint (*enum_dv_timings)(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_enum_dv_timings *timings);\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tint (*link_validate)(struct v4l2_subdev *sd, struct media_link *link,\n\t\t\t     struct v4l2_subdev_format *source_fmt,\n\t\t\t     struct v4l2_subdev_format *sink_fmt);\n#endif  \n\tint (*get_frame_desc)(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t      struct v4l2_mbus_frame_desc *fd);\n\tint (*set_frame_desc)(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t      struct v4l2_mbus_frame_desc *fd);\n\tint (*get_mbus_config)(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t       struct v4l2_mbus_config *config);\n\tint (*set_routing)(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *state,\n\t\t\t   enum v4l2_subdev_format_whence which,\n\t\t\t   struct v4l2_subdev_krouting *route);\n\tint (*enable_streams)(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *state, u32 pad,\n\t\t\t      u64 streams_mask);\n\tint (*disable_streams)(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *state, u32 pad,\n\t\t\t       u64 streams_mask);\n};\n\n \nstruct v4l2_subdev_ops {\n\tconst struct v4l2_subdev_core_ops\t*core;\n\tconst struct v4l2_subdev_tuner_ops\t*tuner;\n\tconst struct v4l2_subdev_audio_ops\t*audio;\n\tconst struct v4l2_subdev_video_ops\t*video;\n\tconst struct v4l2_subdev_vbi_ops\t*vbi;\n\tconst struct v4l2_subdev_ir_ops\t\t*ir;\n\tconst struct v4l2_subdev_sensor_ops\t*sensor;\n\tconst struct v4l2_subdev_pad_ops\t*pad;\n};\n\n \nstruct v4l2_subdev_internal_ops {\n\tint (*registered)(struct v4l2_subdev *sd);\n\tvoid (*unregistered)(struct v4l2_subdev *sd);\n\tint (*open)(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);\n\tint (*close)(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);\n\tvoid (*release)(struct v4l2_subdev *sd);\n};\n\n#define V4L2_SUBDEV_NAME_SIZE 32\n\n \n#define V4L2_SUBDEV_FL_IS_I2C\t\t\t(1U << 0)\n \n#define V4L2_SUBDEV_FL_IS_SPI\t\t\t(1U << 1)\n \n#define V4L2_SUBDEV_FL_HAS_DEVNODE\t\t(1U << 2)\n \n#define V4L2_SUBDEV_FL_HAS_EVENTS\t\t(1U << 3)\n \n#define V4L2_SUBDEV_FL_STREAMS\t\t\t(1U << 4)\n\nstruct regulator_bulk_data;\n\n \nstruct v4l2_subdev_platform_data {\n\tstruct regulator_bulk_data *regulators;\n\tint num_regulators;\n\n\tvoid *host_priv;\n};\n\n \nstruct v4l2_subdev {\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tstruct media_entity entity;\n#endif\n\tstruct list_head list;\n\tstruct module *owner;\n\tbool owner_v4l2_dev;\n\tu32 flags;\n\tstruct v4l2_device *v4l2_dev;\n\tconst struct v4l2_subdev_ops *ops;\n\tconst struct v4l2_subdev_internal_ops *internal_ops;\n\tstruct v4l2_ctrl_handler *ctrl_handler;\n\tchar name[V4L2_SUBDEV_NAME_SIZE];\n\tu32 grp_id;\n\tvoid *dev_priv;\n\tvoid *host_priv;\n\tstruct video_device *devnode;\n\tstruct device *dev;\n\tstruct fwnode_handle *fwnode;\n\tstruct list_head async_list;\n\tstruct list_head async_subdev_endpoint_list;\n\tstruct v4l2_async_notifier *subdev_notifier;\n\tstruct list_head asc_list;\n\tstruct v4l2_subdev_platform_data *pdata;\n\tstruct mutex *state_lock;\n\n\t \n\n\tstruct led_classdev *privacy_led;\n\n\t \n\tstruct v4l2_subdev_state *active_state;\n\tu64 enabled_streams;\n};\n\n\n \n#define media_entity_to_v4l2_subdev(ent)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(ent) __me_sd_ent = (ent);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__me_sd_ent ?\t\t\t\t\t\t\t\\\n\t\tcontainer_of(__me_sd_ent, struct v4l2_subdev, entity) :\t\\\n\t\tNULL;\t\t\t\t\t\t\t\\\n})\n\n \n#define vdev_to_v4l2_subdev(vdev) \\\n\t((struct v4l2_subdev *)video_get_drvdata(vdev))\n\n \nstruct v4l2_subdev_fh {\n\tstruct v4l2_fh vfh;\n\tstruct module *owner;\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\n\tstruct v4l2_subdev_state *state;\n\tu64 client_caps;\n#endif\n};\n\n \n#define to_v4l2_subdev_fh(fh)\t\\\n\tcontainer_of(fh, struct v4l2_subdev_fh, vfh)\n\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\n\n \nstatic inline struct v4l2_mbus_framefmt *\nv4l2_subdev_get_pad_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *state,\n\t\t\t   unsigned int pad)\n{\n\tif (WARN_ON(!state))\n\t\treturn NULL;\n\tif (WARN_ON(pad >= sd->entity.num_pads))\n\t\tpad = 0;\n\treturn &state->pads[pad].try_fmt;\n}\n\n \nstatic inline struct v4l2_rect *\nv4l2_subdev_get_pad_crop(struct v4l2_subdev *sd,\n\t\t\t struct v4l2_subdev_state *state,\n\t\t\t unsigned int pad)\n{\n\tif (WARN_ON(!state))\n\t\treturn NULL;\n\tif (WARN_ON(pad >= sd->entity.num_pads))\n\t\tpad = 0;\n\treturn &state->pads[pad].try_crop;\n}\n\n \nstatic inline struct v4l2_rect *\nv4l2_subdev_get_pad_compose(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *state,\n\t\t\t    unsigned int pad)\n{\n\tif (WARN_ON(!state))\n\t\treturn NULL;\n\tif (WARN_ON(pad >= sd->entity.num_pads))\n\t\tpad = 0;\n\treturn &state->pads[pad].try_compose;\n}\n\n \n#define v4l2_subdev_get_try_format(sd, state, pad) \\\n\tv4l2_subdev_get_pad_format(sd, state, pad)\n\n#define v4l2_subdev_get_try_crop(sd, state, pad) \\\n\tv4l2_subdev_get_pad_crop(sd, state, pad)\n\n#define v4l2_subdev_get_try_compose(sd, state, pad) \\\n\tv4l2_subdev_get_pad_compose(sd, state, pad)\n\n#endif  \n\nextern const struct v4l2_file_operations v4l2_subdev_fops;\n\n \nstatic inline void v4l2_set_subdevdata(struct v4l2_subdev *sd, void *p)\n{\n\tsd->dev_priv = p;\n}\n\n \nstatic inline void *v4l2_get_subdevdata(const struct v4l2_subdev *sd)\n{\n\treturn sd->dev_priv;\n}\n\n \nstatic inline void v4l2_set_subdev_hostdata(struct v4l2_subdev *sd, void *p)\n{\n\tsd->host_priv = p;\n}\n\n \nstatic inline void *v4l2_get_subdev_hostdata(const struct v4l2_subdev *sd)\n{\n\treturn sd->host_priv;\n}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\n \nint v4l2_subdev_get_fwnode_pad_1_to_1(struct media_entity *entity,\n\t\t\t\t      struct fwnode_endpoint *endpoint);\n\n \nint v4l2_subdev_link_validate_default(struct v4l2_subdev *sd,\n\t\t\t\t      struct media_link *link,\n\t\t\t\t      struct v4l2_subdev_format *source_fmt,\n\t\t\t\t      struct v4l2_subdev_format *sink_fmt);\n\n \nint v4l2_subdev_link_validate(struct media_link *link);\n\n \nbool v4l2_subdev_has_pad_interdep(struct media_entity *entity,\n\t\t\t\t  unsigned int pad0, unsigned int pad1);\n\n \nstruct v4l2_subdev_state *__v4l2_subdev_state_alloc(struct v4l2_subdev *sd,\n\t\t\t\t\t\t    const char *lock_name,\n\t\t\t\t\t\t    struct lock_class_key *key);\n\n \nvoid __v4l2_subdev_state_free(struct v4l2_subdev_state *state);\n\n \n#define v4l2_subdev_init_finalize(sd)                                          \\\n\t({                                                                     \\\n\t\tstatic struct lock_class_key __key;                            \\\n\t\tconst char *name = KBUILD_BASENAME                             \\\n\t\t\t\":\" __stringify(__LINE__) \":sd->active_state->lock\";   \\\n\t\t__v4l2_subdev_init_finalize(sd, name, &__key);                 \\\n\t})\n\nint __v4l2_subdev_init_finalize(struct v4l2_subdev *sd, const char *name,\n\t\t\t\tstruct lock_class_key *key);\n\n \nvoid v4l2_subdev_cleanup(struct v4l2_subdev *sd);\n\n \nstatic inline void v4l2_subdev_lock_state(struct v4l2_subdev_state *state)\n{\n\tmutex_lock(state->lock);\n}\n\n \nstatic inline void v4l2_subdev_unlock_state(struct v4l2_subdev_state *state)\n{\n\tmutex_unlock(state->lock);\n}\n\n \nstatic inline struct v4l2_subdev_state *\nv4l2_subdev_get_unlocked_active_state(struct v4l2_subdev *sd)\n{\n\tif (sd->active_state)\n\t\tlockdep_assert_not_held(sd->active_state->lock);\n\treturn sd->active_state;\n}\n\n \nstatic inline struct v4l2_subdev_state *\nv4l2_subdev_get_locked_active_state(struct v4l2_subdev *sd)\n{\n\tif (sd->active_state)\n\t\tlockdep_assert_held(sd->active_state->lock);\n\treturn sd->active_state;\n}\n\n \nstatic inline struct v4l2_subdev_state *\nv4l2_subdev_lock_and_get_active_state(struct v4l2_subdev *sd)\n{\n\tif (sd->active_state)\n\t\tv4l2_subdev_lock_state(sd->active_state);\n\treturn sd->active_state;\n}\n\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\n\n \nint v4l2_subdev_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_state *state,\n\t\t\tstruct v4l2_subdev_format *format);\n\n \nint v4l2_subdev_set_routing(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *state,\n\t\t\t    const struct v4l2_subdev_krouting *routing);\n\nstruct v4l2_subdev_route *\n__v4l2_subdev_next_active_route(const struct v4l2_subdev_krouting *routing,\n\t\t\t\tstruct v4l2_subdev_route *route);\n\n \n#define for_each_active_route(routing, route) \\\n\tfor ((route) = NULL;                  \\\n\t     ((route) = __v4l2_subdev_next_active_route((routing), (route)));)\n\n \nint v4l2_subdev_set_routing_with_fmt(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *state,\n\t\t\t\t     const struct v4l2_subdev_krouting *routing,\n\t\t\t\t     const struct v4l2_mbus_framefmt *fmt);\n\n \nstruct v4l2_mbus_framefmt *\nv4l2_subdev_state_get_stream_format(struct v4l2_subdev_state *state,\n\t\t\t\t    unsigned int pad, u32 stream);\n\n \nstruct v4l2_rect *\nv4l2_subdev_state_get_stream_crop(struct v4l2_subdev_state *state,\n\t\t\t\t  unsigned int pad, u32 stream);\n\n \nstruct v4l2_rect *\nv4l2_subdev_state_get_stream_compose(struct v4l2_subdev_state *state,\n\t\t\t\t     unsigned int pad, u32 stream);\n\n \nint v4l2_subdev_routing_find_opposite_end(const struct v4l2_subdev_krouting *routing,\n\t\t\t\t\t  u32 pad, u32 stream, u32 *other_pad,\n\t\t\t\t\t  u32 *other_stream);\n\n \nstruct v4l2_mbus_framefmt *\nv4l2_subdev_state_get_opposite_stream_format(struct v4l2_subdev_state *state,\n\t\t\t\t\t     u32 pad, u32 stream);\n\n \nu64 v4l2_subdev_state_xlate_streams(const struct v4l2_subdev_state *state,\n\t\t\t\t    u32 pad0, u32 pad1, u64 *streams);\n\n \nenum v4l2_subdev_routing_restriction {\n\tV4L2_SUBDEV_ROUTING_NO_1_TO_N = BIT(0),\n\tV4L2_SUBDEV_ROUTING_NO_N_TO_1 = BIT(1),\n\tV4L2_SUBDEV_ROUTING_NO_SINK_STREAM_MIX = BIT(2),\n\tV4L2_SUBDEV_ROUTING_NO_SOURCE_STREAM_MIX = BIT(3),\n\tV4L2_SUBDEV_ROUTING_NO_SINK_MULTIPLEXING = BIT(4),\n\tV4L2_SUBDEV_ROUTING_NO_SOURCE_MULTIPLEXING = BIT(5),\n\tV4L2_SUBDEV_ROUTING_ONLY_1_TO_1 =\n\t\tV4L2_SUBDEV_ROUTING_NO_1_TO_N |\n\t\tV4L2_SUBDEV_ROUTING_NO_N_TO_1,\n\tV4L2_SUBDEV_ROUTING_NO_STREAM_MIX =\n\t\tV4L2_SUBDEV_ROUTING_NO_SINK_STREAM_MIX |\n\t\tV4L2_SUBDEV_ROUTING_NO_SOURCE_STREAM_MIX,\n\tV4L2_SUBDEV_ROUTING_NO_MULTIPLEXING =\n\t\tV4L2_SUBDEV_ROUTING_NO_SINK_MULTIPLEXING |\n\t\tV4L2_SUBDEV_ROUTING_NO_SOURCE_MULTIPLEXING,\n};\n\n \nint v4l2_subdev_routing_validate(struct v4l2_subdev *sd,\n\t\t\t\t const struct v4l2_subdev_krouting *routing,\n\t\t\t\t enum v4l2_subdev_routing_restriction disallow);\n\n \nint v4l2_subdev_enable_streams(struct v4l2_subdev *sd, u32 pad,\n\t\t\t       u64 streams_mask);\n\n \nint v4l2_subdev_disable_streams(struct v4l2_subdev *sd, u32 pad,\n\t\t\t\tu64 streams_mask);\n\n \nint v4l2_subdev_s_stream_helper(struct v4l2_subdev *sd, int enable);\n\n#endif  \n\n#endif  \n\n \nvoid v4l2_subdev_init(struct v4l2_subdev *sd,\n\t\t      const struct v4l2_subdev_ops *ops);\n\nextern const struct v4l2_subdev_ops v4l2_subdev_call_wrappers;\n\n \n#define v4l2_subdev_call(sd, o, f, args...)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tstruct v4l2_subdev *__sd = (sd);\t\t\t\\\n\t\tint __result;\t\t\t\t\t\t\\\n\t\tif (!__sd)\t\t\t\t\t\t\\\n\t\t\t__result = -ENODEV;\t\t\t\t\\\n\t\telse if (!(__sd->ops->o && __sd->ops->o->f))\t\t\\\n\t\t\t__result = -ENOIOCTLCMD;\t\t\t\\\n\t\telse if (v4l2_subdev_call_wrappers.o &&\t\t\t\\\n\t\t\t v4l2_subdev_call_wrappers.o->f)\t\t\\\n\t\t\t__result = v4l2_subdev_call_wrappers.o->f(\t\\\n\t\t\t\t\t\t\t__sd, ##args);\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\t__result = __sd->ops->o->f(__sd, ##args);\t\\\n\t\t__result;\t\t\t\t\t\t\\\n\t})\n\n \n#define v4l2_subdev_call_state_active(sd, o, f, args...)\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint __result;\t\t\t\t\t\t\\\n\t\tstruct v4l2_subdev_state *state;\t\t\t\\\n\t\tstate = v4l2_subdev_get_unlocked_active_state(sd);\t\\\n\t\tif (state)\t\t\t\t\t\t\\\n\t\t\tv4l2_subdev_lock_state(state);\t\t\t\\\n\t\t__result = v4l2_subdev_call(sd, o, f, state, ##args);\t\\\n\t\tif (state)\t\t\t\t\t\t\\\n\t\t\tv4l2_subdev_unlock_state(state);\t\t\\\n\t\t__result;\t\t\t\t\t\t\\\n\t})\n\n \n#define v4l2_subdev_call_state_try(sd, o, f, args...)                 \\\n\t({                                                            \\\n\t\tint __result;                                         \\\n\t\tstatic struct lock_class_key __key;                   \\\n\t\tconst char *name = KBUILD_BASENAME                    \\\n\t\t\t\":\" __stringify(__LINE__) \":state->lock\";     \\\n\t\tstruct v4l2_subdev_state *state =                     \\\n\t\t\t__v4l2_subdev_state_alloc(sd, name, &__key);  \\\n\t\tv4l2_subdev_lock_state(state);                        \\\n\t\t__result = v4l2_subdev_call(sd, o, f, state, ##args); \\\n\t\tv4l2_subdev_unlock_state(state);                      \\\n\t\t__v4l2_subdev_state_free(state);                      \\\n\t\t__result;                                             \\\n\t})\n\n \n#define v4l2_subdev_has_op(sd, o, f) \\\n\t((sd)->ops->o && (sd)->ops->o->f)\n\n \nvoid v4l2_subdev_notify_event(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_event *ev);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}