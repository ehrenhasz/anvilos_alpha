{
  "module_name": "v4l2-ctrls.h",
  "hash_id": "b874e531018254be6024cb2ed2c4a53cc39da9d6389d3d8e41c4f644de8e3532",
  "original_prompt": "Ingested from linux-6.6.14/include/media/v4l2-ctrls.h",
  "human_readable_source": " \n \n\n#ifndef _V4L2_CTRLS_H\n#define _V4L2_CTRLS_H\n\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/videodev2.h>\n#include <media/media-request.h>\n\n \nstruct file;\nstruct poll_table_struct;\nstruct v4l2_ctrl;\nstruct v4l2_ctrl_handler;\nstruct v4l2_ctrl_helper;\nstruct v4l2_fh;\nstruct v4l2_fwnode_device_properties;\nstruct v4l2_subdev;\nstruct v4l2_subscribed_event;\nstruct video_device;\n\n \nunion v4l2_ctrl_ptr {\n\ts32 *p_s32;\n\ts64 *p_s64;\n\tu8 *p_u8;\n\tu16 *p_u16;\n\tu32 *p_u32;\n\tchar *p_char;\n\tstruct v4l2_ctrl_mpeg2_sequence *p_mpeg2_sequence;\n\tstruct v4l2_ctrl_mpeg2_picture *p_mpeg2_picture;\n\tstruct v4l2_ctrl_mpeg2_quantisation *p_mpeg2_quantisation;\n\tstruct v4l2_ctrl_fwht_params *p_fwht_params;\n\tstruct v4l2_ctrl_h264_sps *p_h264_sps;\n\tstruct v4l2_ctrl_h264_pps *p_h264_pps;\n\tstruct v4l2_ctrl_h264_scaling_matrix *p_h264_scaling_matrix;\n\tstruct v4l2_ctrl_h264_slice_params *p_h264_slice_params;\n\tstruct v4l2_ctrl_h264_decode_params *p_h264_decode_params;\n\tstruct v4l2_ctrl_h264_pred_weights *p_h264_pred_weights;\n\tstruct v4l2_ctrl_vp8_frame *p_vp8_frame;\n\tstruct v4l2_ctrl_hevc_sps *p_hevc_sps;\n\tstruct v4l2_ctrl_hevc_pps *p_hevc_pps;\n\tstruct v4l2_ctrl_hevc_slice_params *p_hevc_slice_params;\n\tstruct v4l2_ctrl_vp9_compressed_hdr *p_vp9_compressed_hdr_probs;\n\tstruct v4l2_ctrl_vp9_frame *p_vp9_frame;\n\tstruct v4l2_ctrl_hdr10_cll_info *p_hdr10_cll;\n\tstruct v4l2_ctrl_hdr10_mastering_display *p_hdr10_mastering;\n\tstruct v4l2_area *p_area;\n\tstruct v4l2_ctrl_av1_sequence *p_av1_sequence;\n\tstruct v4l2_ctrl_av1_tile_group_entry *p_av1_tile_group_entry;\n\tstruct v4l2_ctrl_av1_frame *p_av1_frame;\n\tstruct v4l2_ctrl_av1_film_grain *p_av1_film_grain;\n\tvoid *p;\n\tconst void *p_const;\n};\n\n \nstatic inline union v4l2_ctrl_ptr v4l2_ctrl_ptr_create(void *ptr)\n{\n\tunion v4l2_ctrl_ptr p = { .p = ptr };\n\n\treturn p;\n}\n\n \nstruct v4l2_ctrl_ops {\n\tint (*g_volatile_ctrl)(struct v4l2_ctrl *ctrl);\n\tint (*try_ctrl)(struct v4l2_ctrl *ctrl);\n\tint (*s_ctrl)(struct v4l2_ctrl *ctrl);\n};\n\n \nstruct v4l2_ctrl_type_ops {\n\tbool (*equal)(const struct v4l2_ctrl *ctrl,\n\t\t      union v4l2_ctrl_ptr ptr1, union v4l2_ctrl_ptr ptr2);\n\tvoid (*init)(const struct v4l2_ctrl *ctrl, u32 from_idx,\n\t\t     union v4l2_ctrl_ptr ptr);\n\tvoid (*log)(const struct v4l2_ctrl *ctrl);\n\tint (*validate)(const struct v4l2_ctrl *ctrl, union v4l2_ctrl_ptr ptr);\n};\n\n \ntypedef void (*v4l2_ctrl_notify_fnc)(struct v4l2_ctrl *ctrl, void *priv);\n\n \nstruct v4l2_ctrl {\n\t \n\tstruct list_head node;\n\tstruct list_head ev_subs;\n\tstruct v4l2_ctrl_handler *handler;\n\tstruct v4l2_ctrl **cluster;\n\tunsigned int ncontrols;\n\n\tunsigned int done:1;\n\n\tunsigned int is_new:1;\n\tunsigned int has_changed:1;\n\tunsigned int is_private:1;\n\tunsigned int is_auto:1;\n\tunsigned int is_int:1;\n\tunsigned int is_string:1;\n\tunsigned int is_ptr:1;\n\tunsigned int is_array:1;\n\tunsigned int is_dyn_array:1;\n\tunsigned int has_volatiles:1;\n\tunsigned int call_notify:1;\n\tunsigned int manual_mode_value:8;\n\n\tconst struct v4l2_ctrl_ops *ops;\n\tconst struct v4l2_ctrl_type_ops *type_ops;\n\tu32 id;\n\tconst char *name;\n\tenum v4l2_ctrl_type type;\n\ts64 minimum, maximum, default_value;\n\tu32 elems;\n\tu32 elem_size;\n\tu32 new_elems;\n\tu32 dims[V4L2_CTRL_MAX_DIMS];\n\tu32 nr_of_dims;\n\tunion {\n\t\tu64 step;\n\t\tu64 menu_skip_mask;\n\t};\n\tunion {\n\t\tconst char * const *qmenu;\n\t\tconst s64 *qmenu_int;\n\t};\n\tunsigned long flags;\n\tvoid *priv;\n\tvoid *p_array;\n\tu32 p_array_alloc_elems;\n\ts32 val;\n\tstruct {\n\t\ts32 val;\n\t} cur;\n\n\tunion v4l2_ctrl_ptr p_def;\n\tunion v4l2_ctrl_ptr p_new;\n\tunion v4l2_ctrl_ptr p_cur;\n};\n\n \nstruct v4l2_ctrl_ref {\n\tstruct list_head node;\n\tstruct v4l2_ctrl_ref *next;\n\tstruct v4l2_ctrl *ctrl;\n\tstruct v4l2_ctrl_helper *helper;\n\tbool from_other_dev;\n\tbool req_done;\n\tbool p_req_valid;\n\tbool p_req_array_enomem;\n\tu32 p_req_array_alloc_elems;\n\tu32 p_req_elems;\n\tunion v4l2_ctrl_ptr p_req;\n};\n\n \nstruct v4l2_ctrl_handler {\n\tstruct mutex _lock;\n\tstruct mutex *lock;\n\tstruct list_head ctrls;\n\tstruct list_head ctrl_refs;\n\tstruct v4l2_ctrl_ref *cached;\n\tstruct v4l2_ctrl_ref **buckets;\n\tv4l2_ctrl_notify_fnc notify;\n\tvoid *notify_priv;\n\tu16 nr_of_buckets;\n\tint error;\n\tbool request_is_queued;\n\tstruct list_head requests;\n\tstruct list_head requests_queued;\n\tstruct media_request_object req_obj;\n};\n\n \nstruct v4l2_ctrl_config {\n\tconst struct v4l2_ctrl_ops *ops;\n\tconst struct v4l2_ctrl_type_ops *type_ops;\n\tu32 id;\n\tconst char *name;\n\tenum v4l2_ctrl_type type;\n\ts64 min;\n\ts64 max;\n\tu64 step;\n\ts64 def;\n\tunion v4l2_ctrl_ptr p_def;\n\tu32 dims[V4L2_CTRL_MAX_DIMS];\n\tu32 elem_size;\n\tu32 flags;\n\tu64 menu_skip_mask;\n\tconst char * const *qmenu;\n\tconst s64 *qmenu_int;\n\tunsigned int is_private:1;\n};\n\n \nvoid v4l2_ctrl_fill(u32 id, const char **name, enum v4l2_ctrl_type *type,\n\t\t    s64 *min, s64 *max, u64 *step, s64 *def, u32 *flags);\n\n\n \nint v4l2_ctrl_handler_init_class(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t unsigned int nr_of_controls_hint,\n\t\t\t\t struct lock_class_key *key, const char *name);\n\n#ifdef CONFIG_LOCKDEP\n\n \n#define v4l2_ctrl_handler_init(hdl, nr_of_controls_hint)\t\t\\\n(\t\t\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tstatic struct lock_class_key _key;\t\t\t\\\n\t\tv4l2_ctrl_handler_init_class(hdl, nr_of_controls_hint,\t\\\n\t\t\t\t\t&_key,\t\t\t\t\\\n\t\t\t\t\tKBUILD_BASENAME \":\"\t\t\\\n\t\t\t\t\t__stringify(__LINE__) \":\"\t\\\n\t\t\t\t\t\"(\" #hdl \")->_lock\");\t\t\\\n\t})\t\t\t\t\t\t\t\t\\\n)\n#else\n#define v4l2_ctrl_handler_init(hdl, nr_of_controls_hint)\t\t\\\n\tv4l2_ctrl_handler_init_class(hdl, nr_of_controls_hint, NULL, NULL)\n#endif\n\n \nvoid v4l2_ctrl_handler_free(struct v4l2_ctrl_handler *hdl);\n\n \nstatic inline void v4l2_ctrl_lock(struct v4l2_ctrl *ctrl)\n{\n\tmutex_lock(ctrl->handler->lock);\n}\n\n \nstatic inline void v4l2_ctrl_unlock(struct v4l2_ctrl *ctrl)\n{\n\tmutex_unlock(ctrl->handler->lock);\n}\n\n \nint __v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler *hdl);\n\n \nint v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler *hdl);\n\n \nvoid v4l2_ctrl_handler_log_status(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t  const char *prefix);\n\n \nstruct v4l2_ctrl *v4l2_ctrl_new_custom(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t       const struct v4l2_ctrl_config *cfg,\n\t\t\t\t       void *priv);\n\n \nstruct v4l2_ctrl *v4l2_ctrl_new_std(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t    const struct v4l2_ctrl_ops *ops,\n\t\t\t\t    u32 id, s64 min, s64 max, u64 step,\n\t\t\t\t    s64 def);\n\n \nstruct v4l2_ctrl *v4l2_ctrl_new_std_menu(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t\t const struct v4l2_ctrl_ops *ops,\n\t\t\t\t\t u32 id, u8 max, u64 mask, u8 def);\n\n \nstruct v4l2_ctrl *v4l2_ctrl_new_std_menu_items(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t\t       const struct v4l2_ctrl_ops *ops,\n\t\t\t\t\t       u32 id, u8 max,\n\t\t\t\t\t       u64 mask, u8 def,\n\t\t\t\t\t       const char * const *qmenu);\n\n \nstruct v4l2_ctrl *v4l2_ctrl_new_std_compound(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t\t     const struct v4l2_ctrl_ops *ops,\n\t\t\t\t\t     u32 id,\n\t\t\t\t\t     const union v4l2_ctrl_ptr p_def);\n\n \nstruct v4l2_ctrl *v4l2_ctrl_new_int_menu(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t\t const struct v4l2_ctrl_ops *ops,\n\t\t\t\t\t u32 id, u8 max, u8 def,\n\t\t\t\t\t const s64 *qmenu_int);\n\n \n\ntypedef bool (*v4l2_ctrl_filter)(const struct v4l2_ctrl *ctrl);\n\n \nint v4l2_ctrl_add_handler(struct v4l2_ctrl_handler *hdl,\n\t\t\t  struct v4l2_ctrl_handler *add,\n\t\t\t  v4l2_ctrl_filter filter,\n\t\t\t  bool from_other_dev);\n\n \nbool v4l2_ctrl_radio_filter(const struct v4l2_ctrl *ctrl);\n\n \nvoid v4l2_ctrl_cluster(unsigned int ncontrols, struct v4l2_ctrl **controls);\n\n\n \nvoid v4l2_ctrl_auto_cluster(unsigned int ncontrols,\n\t\t\t    struct v4l2_ctrl **controls,\n\t\t\t    u8 manual_val, bool set_volatile);\n\n\n \nstruct v4l2_ctrl *v4l2_ctrl_find(struct v4l2_ctrl_handler *hdl, u32 id);\n\n \nvoid v4l2_ctrl_activate(struct v4l2_ctrl *ctrl, bool active);\n\n \nvoid __v4l2_ctrl_grab(struct v4l2_ctrl *ctrl, bool grabbed);\n\n \nstatic inline void v4l2_ctrl_grab(struct v4l2_ctrl *ctrl, bool grabbed)\n{\n\tif (!ctrl)\n\t\treturn;\n\n\tv4l2_ctrl_lock(ctrl);\n\t__v4l2_ctrl_grab(ctrl, grabbed);\n\tv4l2_ctrl_unlock(ctrl);\n}\n\n \nint __v4l2_ctrl_modify_range(struct v4l2_ctrl *ctrl,\n\t\t\t     s64 min, s64 max, u64 step, s64 def);\n\n \nstatic inline int v4l2_ctrl_modify_range(struct v4l2_ctrl *ctrl,\n\t\t\t\t\t s64 min, s64 max, u64 step, s64 def)\n{\n\tint rval;\n\n\tv4l2_ctrl_lock(ctrl);\n\trval = __v4l2_ctrl_modify_range(ctrl, min, max, step, def);\n\tv4l2_ctrl_unlock(ctrl);\n\n\treturn rval;\n}\n\n \nint __v4l2_ctrl_modify_dimensions(struct v4l2_ctrl *ctrl,\n\t\t\t\t  u32 dims[V4L2_CTRL_MAX_DIMS]);\n\n \nstatic inline int v4l2_ctrl_modify_dimensions(struct v4l2_ctrl *ctrl,\n\t\t\t\t\t      u32 dims[V4L2_CTRL_MAX_DIMS])\n{\n\tint rval;\n\n\tv4l2_ctrl_lock(ctrl);\n\trval = __v4l2_ctrl_modify_dimensions(ctrl, dims);\n\tv4l2_ctrl_unlock(ctrl);\n\n\treturn rval;\n}\n\n \nvoid v4l2_ctrl_notify(struct v4l2_ctrl *ctrl, v4l2_ctrl_notify_fnc notify,\n\t\t      void *priv);\n\n \nconst char *v4l2_ctrl_get_name(u32 id);\n\n \nconst char * const *v4l2_ctrl_get_menu(u32 id);\n\n \nconst s64 *v4l2_ctrl_get_int_menu(u32 id, u32 *len);\n\n \ns32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl *ctrl);\n\n \nint __v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl, s32 val);\n\n \nstatic inline int v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl, s32 val)\n{\n\tint rval;\n\n\tv4l2_ctrl_lock(ctrl);\n\trval = __v4l2_ctrl_s_ctrl(ctrl, val);\n\tv4l2_ctrl_unlock(ctrl);\n\n\treturn rval;\n}\n\n \ns64 v4l2_ctrl_g_ctrl_int64(struct v4l2_ctrl *ctrl);\n\n \nint __v4l2_ctrl_s_ctrl_int64(struct v4l2_ctrl *ctrl, s64 val);\n\n \nstatic inline int v4l2_ctrl_s_ctrl_int64(struct v4l2_ctrl *ctrl, s64 val)\n{\n\tint rval;\n\n\tv4l2_ctrl_lock(ctrl);\n\trval = __v4l2_ctrl_s_ctrl_int64(ctrl, val);\n\tv4l2_ctrl_unlock(ctrl);\n\n\treturn rval;\n}\n\n \nint __v4l2_ctrl_s_ctrl_string(struct v4l2_ctrl *ctrl, const char *s);\n\n \nstatic inline int v4l2_ctrl_s_ctrl_string(struct v4l2_ctrl *ctrl, const char *s)\n{\n\tint rval;\n\n\tv4l2_ctrl_lock(ctrl);\n\trval = __v4l2_ctrl_s_ctrl_string(ctrl, s);\n\tv4l2_ctrl_unlock(ctrl);\n\n\treturn rval;\n}\n\n \nint __v4l2_ctrl_s_ctrl_compound(struct v4l2_ctrl *ctrl,\n\t\t\t\tenum v4l2_ctrl_type type, const void *p);\n\n \nstatic inline int v4l2_ctrl_s_ctrl_compound(struct v4l2_ctrl *ctrl,\n\t\t\t\t\t    enum v4l2_ctrl_type type,\n\t\t\t\t\t    const void *p)\n{\n\tint rval;\n\n\tv4l2_ctrl_lock(ctrl);\n\trval = __v4l2_ctrl_s_ctrl_compound(ctrl, type, p);\n\tv4l2_ctrl_unlock(ctrl);\n\n\treturn rval;\n}\n\n \n#define __v4l2_ctrl_s_ctrl_area(ctrl, area) \\\n\t__v4l2_ctrl_s_ctrl_compound((ctrl), V4L2_CTRL_TYPE_AREA, (area))\n#define v4l2_ctrl_s_ctrl_area(ctrl, area) \\\n\tv4l2_ctrl_s_ctrl_compound((ctrl), V4L2_CTRL_TYPE_AREA, (area))\n\n \nextern const struct v4l2_subscribed_event_ops v4l2_ctrl_sub_ev_ops;\n\n \nvoid v4l2_ctrl_replace(struct v4l2_event *old, const struct v4l2_event *new);\n\n \nvoid v4l2_ctrl_merge(const struct v4l2_event *old, struct v4l2_event *new);\n\n \nint v4l2_ctrl_log_status(struct file *file, void *fh);\n\n \nint v4l2_ctrl_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\tconst struct v4l2_event_subscription *sub);\n\n \n__poll_t v4l2_ctrl_poll(struct file *file, struct poll_table_struct *wait);\n\n \nint v4l2_ctrl_request_setup(struct media_request *req,\n\t\t\t     struct v4l2_ctrl_handler *parent);\n\n \nvoid v4l2_ctrl_request_complete(struct media_request *req,\n\t\t\t\tstruct v4l2_ctrl_handler *parent);\n\n \nstruct v4l2_ctrl_handler *v4l2_ctrl_request_hdl_find(struct media_request *req,\n\t\t\t\t\tstruct v4l2_ctrl_handler *parent);\n\n \nstatic inline void v4l2_ctrl_request_hdl_put(struct v4l2_ctrl_handler *hdl)\n{\n\tif (hdl)\n\t\tmedia_request_object_put(&hdl->req_obj);\n}\n\n \nstruct v4l2_ctrl *\nv4l2_ctrl_request_hdl_ctrl_find(struct v4l2_ctrl_handler *hdl, u32 id);\n\n \n\n \nint v4l2_queryctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_queryctrl *qc);\n\n \nint v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl,\n\t\t\tstruct v4l2_query_ext_ctrl *qc);\n\n \nint v4l2_querymenu(struct v4l2_ctrl_handler *hdl, struct v4l2_querymenu *qm);\n\n \nint v4l2_g_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_control *ctrl);\n\n \nint v4l2_s_ctrl(struct v4l2_fh *fh, struct v4l2_ctrl_handler *hdl,\n\t\tstruct v4l2_control *ctrl);\n\n \nint v4l2_g_ext_ctrls(struct v4l2_ctrl_handler *hdl, struct video_device *vdev,\n\t\t     struct media_device *mdev, struct v4l2_ext_controls *c);\n\n \nint v4l2_try_ext_ctrls(struct v4l2_ctrl_handler *hdl,\n\t\t       struct video_device *vdev,\n\t\t       struct media_device *mdev,\n\t\t       struct v4l2_ext_controls *c);\n\n \nint v4l2_s_ext_ctrls(struct v4l2_fh *fh, struct v4l2_ctrl_handler *hdl,\n\t\t     struct video_device *vdev,\n\t\t     struct media_device *mdev,\n\t\t     struct v4l2_ext_controls *c);\n\n \nint v4l2_ctrl_subdev_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\n\t\t\t\t     struct v4l2_event_subscription *sub);\n\n \nint v4l2_ctrl_subdev_log_status(struct v4l2_subdev *sd);\n\n \nint v4l2_ctrl_new_fwnode_properties(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t    const struct v4l2_ctrl_ops *ctrl_ops,\n\t\t\t\t    const struct v4l2_fwnode_device_properties *p);\n\n \nbool v4l2_ctrl_type_op_equal(const struct v4l2_ctrl *ctrl,\n\t\t\t     union v4l2_ctrl_ptr ptr1, union v4l2_ctrl_ptr ptr2);\n\n \nvoid v4l2_ctrl_type_op_init(const struct v4l2_ctrl *ctrl, u32 from_idx,\n\t\t\t    union v4l2_ctrl_ptr ptr);\n\n \nvoid v4l2_ctrl_type_op_log(const struct v4l2_ctrl *ctrl);\n\n \nint v4l2_ctrl_type_op_validate(const struct v4l2_ctrl *ctrl, union v4l2_ctrl_ptr ptr);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}