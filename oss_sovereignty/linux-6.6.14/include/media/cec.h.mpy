{
  "module_name": "cec.h",
  "hash_id": "ef5d945eb5968b0d7cd8badb18af5be97f17fa14368d6898d11229a421556b0f",
  "original_prompt": "Ingested from linux-6.6.14/include/media/cec.h",
  "human_readable_source": " \n \n\n#ifndef _MEDIA_CEC_H\n#define _MEDIA_CEC_H\n\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/cec-funcs.h>\n#include <media/rc-core.h>\n\n#define CEC_CAP_DEFAULTS (CEC_CAP_LOG_ADDRS | CEC_CAP_TRANSMIT | \\\n\t\t\t  CEC_CAP_PASSTHROUGH | CEC_CAP_RC)\n\n \nstruct cec_devnode {\n\t \n\tstruct device dev;\n\tstruct cdev cdev;\n\n\t \n\tint minor;\n\t \n\tstruct mutex lock;\n\tbool registered;\n\tbool unregistered;\n\t \n\tstruct mutex lock_fhs;\n\tstruct list_head fhs;\n};\n\nstruct cec_adapter;\nstruct cec_data;\nstruct cec_pin;\nstruct cec_notifier;\n\nstruct cec_data {\n\tstruct list_head list;\n\tstruct list_head xfer_list;\n\tstruct cec_adapter *adap;\n\tstruct cec_msg msg;\n\tstruct cec_fh *fh;\n\tstruct delayed_work work;\n\tstruct completion c;\n\tu8 attempts;\n\tbool blocking;\n\tbool completed;\n};\n\nstruct cec_msg_entry {\n\tstruct list_head\tlist;\n\tstruct cec_msg\t\tmsg;\n};\n\nstruct cec_event_entry {\n\tstruct list_head\tlist;\n\tstruct cec_event\tev;\n};\n\n#define CEC_NUM_CORE_EVENTS 2\n#define CEC_NUM_EVENTS CEC_EVENT_PIN_5V_HIGH\n\nstruct cec_fh {\n\tstruct list_head\tlist;\n\tstruct list_head\txfer_list;\n\tstruct cec_adapter\t*adap;\n\tu8\t\t\tmode_initiator;\n\tu8\t\t\tmode_follower;\n\n\t \n\twait_queue_head_t\twait;\n\tstruct mutex\t\tlock;\n\tstruct list_head\tevents[CEC_NUM_EVENTS];  \n\tu16\t\t\tqueued_events[CEC_NUM_EVENTS];\n\tunsigned int\t\ttotal_queued_events;\n\tstruct cec_event_entry\tcore_events[CEC_NUM_CORE_EVENTS];\n\tstruct list_head\tmsgs;  \n\tunsigned int\t\tqueued_msgs;\n};\n\n#define CEC_SIGNAL_FREE_TIME_RETRY\t\t3\n#define CEC_SIGNAL_FREE_TIME_NEW_INITIATOR\t5\n#define CEC_SIGNAL_FREE_TIME_NEXT_XFER\t\t7\n\n \n#define CEC_FREE_TIME_TO_USEC(ft)\t\t((ft) * 2400)\n\nstruct cec_adap_ops {\n\t \n\tint (*adap_enable)(struct cec_adapter *adap, bool enable);\n\tint (*adap_monitor_all_enable)(struct cec_adapter *adap, bool enable);\n\tint (*adap_monitor_pin_enable)(struct cec_adapter *adap, bool enable);\n\tint (*adap_log_addr)(struct cec_adapter *adap, u8 logical_addr);\n\tvoid (*adap_unconfigured)(struct cec_adapter *adap);\n\tint (*adap_transmit)(struct cec_adapter *adap, u8 attempts,\n\t\t\t     u32 signal_free_time, struct cec_msg *msg);\n\tvoid (*adap_nb_transmit_canceled)(struct cec_adapter *adap,\n\t\t\t\t\t  const struct cec_msg *msg);\n\tvoid (*adap_status)(struct cec_adapter *adap, struct seq_file *file);\n\tvoid (*adap_free)(struct cec_adapter *adap);\n\n\t \n\tint (*error_inj_show)(struct cec_adapter *adap, struct seq_file *sf);\n\tbool (*error_inj_parse_line)(struct cec_adapter *adap, char *line);\n\n\t \n\tvoid (*configured)(struct cec_adapter *adap);\n\tint (*received)(struct cec_adapter *adap, struct cec_msg *msg);\n};\n\n \n#define CEC_MAX_MSG_RX_QUEUE_SZ\t\t(18 * 3)\n\n \n#define CEC_MAX_MSG_TX_QUEUE_SZ\t\t(18 * 1)\n\n \nstruct cec_adapter {\n\tstruct module *owner;\n\tchar name[32];\n\tstruct cec_devnode devnode;\n\tstruct mutex lock;\n\tstruct rc_dev *rc;\n\n\tstruct list_head transmit_queue;\n\tunsigned int transmit_queue_sz;\n\tstruct list_head wait_queue;\n\tstruct cec_data *transmitting;\n\tbool transmit_in_progress;\n\tbool transmit_in_progress_aborted;\n\tunsigned int xfer_timeout_ms;\n\n\tstruct task_struct *kthread_config;\n\tstruct completion config_completion;\n\n\tstruct task_struct *kthread;\n\twait_queue_head_t kthread_waitq;\n\n\tconst struct cec_adap_ops *ops;\n\tvoid *priv;\n\tu32 capabilities;\n\tu8 available_log_addrs;\n\n\tu16 phys_addr;\n\tbool needs_hpd;\n\tbool is_enabled;\n\tbool is_configuring;\n\tbool must_reconfigure;\n\tbool is_configured;\n\tbool cec_pin_is_high;\n\tbool adap_controls_phys_addr;\n\tu8 last_initiator;\n\tu32 monitor_all_cnt;\n\tu32 monitor_pin_cnt;\n\tu32 follower_cnt;\n\tstruct cec_fh *cec_follower;\n\tstruct cec_fh *cec_initiator;\n\tbool passthrough;\n\tstruct cec_log_addrs log_addrs;\n\tstruct cec_connector_info conn_info;\n\n\tu32 tx_timeouts;\n\n#ifdef CONFIG_CEC_NOTIFIER\n\tstruct cec_notifier *notifier;\n#endif\n#ifdef CONFIG_CEC_PIN\n\tstruct cec_pin *pin;\n#endif\n\n\tstruct dentry *cec_dir;\n\n\tu32 sequence;\n\n\tchar input_phys[32];\n};\n\nstatic inline void *cec_get_drvdata(const struct cec_adapter *adap)\n{\n\treturn adap->priv;\n}\n\nstatic inline bool cec_has_log_addr(const struct cec_adapter *adap, u8 log_addr)\n{\n\treturn adap->log_addrs.log_addr_mask & (1 << log_addr);\n}\n\nstatic inline bool cec_is_sink(const struct cec_adapter *adap)\n{\n\treturn adap->phys_addr == 0;\n}\n\n \nstatic inline bool cec_is_registered(const struct cec_adapter *adap)\n{\n\treturn adap && adap->devnode.registered;\n}\n\n#define cec_phys_addr_exp(pa) \\\n\t((pa) >> 12), ((pa) >> 8) & 0xf, ((pa) >> 4) & 0xf, (pa) & 0xf\n\nstruct edid;\nstruct drm_connector;\n\n#if IS_REACHABLE(CONFIG_CEC_CORE)\nstruct cec_adapter *cec_allocate_adapter(const struct cec_adap_ops *ops,\n\t\tvoid *priv, const char *name, u32 caps, u8 available_las);\nint cec_register_adapter(struct cec_adapter *adap, struct device *parent);\nvoid cec_unregister_adapter(struct cec_adapter *adap);\nvoid cec_delete_adapter(struct cec_adapter *adap);\n\nint cec_s_log_addrs(struct cec_adapter *adap, struct cec_log_addrs *log_addrs,\n\t\t    bool block);\nvoid cec_s_phys_addr(struct cec_adapter *adap, u16 phys_addr,\n\t\t     bool block);\nvoid cec_s_phys_addr_from_edid(struct cec_adapter *adap,\n\t\t\t       const struct edid *edid);\nvoid cec_s_conn_info(struct cec_adapter *adap,\n\t\t     const struct cec_connector_info *conn_info);\nint cec_transmit_msg(struct cec_adapter *adap, struct cec_msg *msg,\n\t\t     bool block);\n\n \nvoid cec_transmit_done_ts(struct cec_adapter *adap, u8 status,\n\t\t\t  u8 arb_lost_cnt, u8 nack_cnt, u8 low_drive_cnt,\n\t\t\t  u8 error_cnt, ktime_t ts);\n\nstatic inline void cec_transmit_done(struct cec_adapter *adap, u8 status,\n\t\t\t\t     u8 arb_lost_cnt, u8 nack_cnt,\n\t\t\t\t     u8 low_drive_cnt, u8 error_cnt)\n{\n\tcec_transmit_done_ts(adap, status, arb_lost_cnt, nack_cnt,\n\t\t\t     low_drive_cnt, error_cnt, ktime_get());\n}\n \nvoid cec_transmit_attempt_done_ts(struct cec_adapter *adap,\n\t\t\t\t  u8 status, ktime_t ts);\n\nstatic inline void cec_transmit_attempt_done(struct cec_adapter *adap,\n\t\t\t\t\t     u8 status)\n{\n\tcec_transmit_attempt_done_ts(adap, status, ktime_get());\n}\n\nvoid cec_received_msg_ts(struct cec_adapter *adap,\n\t\t\t struct cec_msg *msg, ktime_t ts);\n\nstatic inline void cec_received_msg(struct cec_adapter *adap,\n\t\t\t\t    struct cec_msg *msg)\n{\n\tcec_received_msg_ts(adap, msg, ktime_get());\n}\n\n \nvoid cec_queue_pin_cec_event(struct cec_adapter *adap, bool is_high,\n\t\t\t     bool dropped_events, ktime_t ts);\n\n \nvoid cec_queue_pin_hpd_event(struct cec_adapter *adap, bool is_high, ktime_t ts);\n\n \nvoid cec_queue_pin_5v_event(struct cec_adapter *adap, bool is_high, ktime_t ts);\n\n \nu16 cec_get_edid_phys_addr(const u8 *edid, unsigned int size,\n\t\t\t   unsigned int *offset);\n\nvoid cec_fill_conn_info_from_drm(struct cec_connector_info *conn_info,\n\t\t\t\t const struct drm_connector *connector);\n\n#else\n\nstatic inline int cec_register_adapter(struct cec_adapter *adap,\n\t\t\t\t       struct device *parent)\n{\n\treturn 0;\n}\n\nstatic inline void cec_unregister_adapter(struct cec_adapter *adap)\n{\n}\n\nstatic inline void cec_delete_adapter(struct cec_adapter *adap)\n{\n}\n\nstatic inline void cec_s_phys_addr(struct cec_adapter *adap, u16 phys_addr,\n\t\t\t\t   bool block)\n{\n}\n\nstatic inline void cec_s_phys_addr_from_edid(struct cec_adapter *adap,\n\t\t\t\t\t     const struct edid *edid)\n{\n}\n\nstatic inline u16 cec_get_edid_phys_addr(const u8 *edid, unsigned int size,\n\t\t\t\t\t unsigned int *offset)\n{\n\tif (offset)\n\t\t*offset = 0;\n\treturn CEC_PHYS_ADDR_INVALID;\n}\n\nstatic inline void cec_s_conn_info(struct cec_adapter *adap,\n\t\t\t\t   const struct cec_connector_info *conn_info)\n{\n}\n\nstatic inline void\ncec_fill_conn_info_from_drm(struct cec_connector_info *conn_info,\n\t\t\t    const struct drm_connector *connector)\n{\n\tmemset(conn_info, 0, sizeof(*conn_info));\n}\n\n#endif\n\n \nstatic inline void cec_phys_addr_invalidate(struct cec_adapter *adap)\n{\n\tcec_s_phys_addr(adap, CEC_PHYS_ADDR_INVALID, false);\n}\n\n \nstatic inline unsigned int cec_get_edid_spa_location(const u8 *edid,\n\t\t\t\t\t\t     unsigned int size)\n{\n\tunsigned int blocks = size / 128;\n\tunsigned int block;\n\tu8 d;\n\n\t \n\tif (blocks < 2 || size % 128)\n\t\treturn 0;\n\n\t \n\tif (edid[0x7e] + 1 < blocks)\n\t\tblocks = edid[0x7e] + 1;\n\n\tfor (block = 1; block < blocks; block++) {\n\t\tunsigned int offset = block * 128;\n\n\t\t \n\t\tif (edid[offset] != 0x02 || edid[offset + 1] != 0x03)\n\t\t\tcontinue;\n\n\t\t \n\t\td = edid[offset + 2] & 0x7f;\n\t\t \n\t\tif (d <= 4)\n\t\t\tcontinue;\n\t\tif (d > 4) {\n\t\t\tunsigned int i = offset + 4;\n\t\t\tunsigned int end = offset + d;\n\n\t\t\t \n\t\t\tdo {\n\t\t\t\tu8 tag = edid[i] >> 5;\n\t\t\t\tu8 len = edid[i] & 0x1f;\n\n\t\t\t\tif (tag == 3 && len >= 5 && i + len <= end &&\n\t\t\t\t    edid[i + 1] == 0x03 &&\n\t\t\t\t    edid[i + 2] == 0x0c &&\n\t\t\t\t    edid[i + 3] == 0x00)\n\t\t\t\t\treturn i + 4;\n\t\t\t\ti += len + 1;\n\t\t\t} while (i < end);\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}