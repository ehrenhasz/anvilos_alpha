{
  "module_name": "rc-core.h",
  "hash_id": "f2354e1e01ace10f08c3fa4de8a53a7779b4155872a3dd1db37d0c5e365ca5e7",
  "original_prompt": "Ingested from linux-6.6.14/include/media/rc-core.h",
  "human_readable_source": " \n \n\n#ifndef _RC_CORE\n#define _RC_CORE\n\n#include <linux/spinlock.h>\n#include <linux/cdev.h>\n#include <linux/kfifo.h>\n#include <linux/time.h>\n#include <linux/timer.h>\n#include <media/rc-map.h>\n\n \nenum rc_driver_type {\n\tRC_DRIVER_SCANCODE = 0,\n\tRC_DRIVER_IR_RAW,\n\tRC_DRIVER_IR_RAW_TX,\n};\n\n \nstruct rc_scancode_filter {\n\tu32 data;\n\tu32 mask;\n};\n\n \nenum rc_filter_type {\n\tRC_FILTER_NORMAL = 0,\n\tRC_FILTER_WAKEUP,\n\n\tRC_FILTER_MAX\n};\n\n \nstruct lirc_fh {\n\tstruct list_head list;\n\tstruct rc_dev *rc;\n\tint\t\t\t\tcarrier_low;\n\tDECLARE_KFIFO_PTR(rawir, unsigned int);\n\tDECLARE_KFIFO_PTR(scancodes, struct lirc_scancode);\n\twait_queue_head_t\t\twait_poll;\n\tu8\t\t\t\tsend_mode;\n\tu8\t\t\t\trec_mode;\n};\n\n \nstruct rc_dev {\n\tstruct device\t\t\tdev;\n\tbool\t\t\t\tmanaged_alloc;\n\tconst struct attribute_group\t*sysfs_groups[5];\n\tconst char\t\t\t*device_name;\n\tconst char\t\t\t*input_phys;\n\tstruct input_id\t\t\tinput_id;\n\tconst char\t\t\t*driver_name;\n\tconst char\t\t\t*map_name;\n\tstruct rc_map\t\t\trc_map;\n\tstruct mutex\t\t\tlock;\n\tunsigned int\t\t\tminor;\n\tstruct ir_raw_event_ctrl\t*raw;\n\tstruct input_dev\t\t*input_dev;\n\tenum rc_driver_type\t\tdriver_type;\n\tbool\t\t\t\tidle;\n\tbool\t\t\t\tencode_wakeup;\n\tu64\t\t\t\tallowed_protocols;\n\tu64\t\t\t\tenabled_protocols;\n\tu64\t\t\t\tallowed_wakeup_protocols;\n\tenum rc_proto\t\t\twakeup_protocol;\n\tstruct rc_scancode_filter\tscancode_filter;\n\tstruct rc_scancode_filter\tscancode_wakeup_filter;\n\tu32\t\t\t\tscancode_mask;\n\tu32\t\t\t\tusers;\n\tvoid\t\t\t\t*priv;\n\tspinlock_t\t\t\tkeylock;\n\tbool\t\t\t\tkeypressed;\n\tunsigned long\t\t\tkeyup_jiffies;\n\tstruct timer_list\t\ttimer_keyup;\n\tstruct timer_list\t\ttimer_repeat;\n\tu32\t\t\t\tlast_keycode;\n\tenum rc_proto\t\t\tlast_protocol;\n\tu64\t\t\t\tlast_scancode;\n\tu8\t\t\t\tlast_toggle;\n\tu32\t\t\t\ttimeout;\n\tu32\t\t\t\tmin_timeout;\n\tu32\t\t\t\tmax_timeout;\n\tu32\t\t\t\trx_resolution;\n\tu32\t\t\t\ttx_resolution;\n#ifdef CONFIG_LIRC\n\tstruct device\t\t\tlirc_dev;\n\tstruct cdev\t\t\tlirc_cdev;\n\tktime_t\t\t\t\tgap_start;\n\tspinlock_t\t\t\tlirc_fh_lock;\n\tstruct list_head\t\tlirc_fh;\n#endif\n\tbool\t\t\t\tregistered;\n\tint\t\t\t\t(*change_protocol)(struct rc_dev *dev, u64 *rc_proto);\n\tint\t\t\t\t(*open)(struct rc_dev *dev);\n\tvoid\t\t\t\t(*close)(struct rc_dev *dev);\n\tint\t\t\t\t(*s_tx_mask)(struct rc_dev *dev, u32 mask);\n\tint\t\t\t\t(*s_tx_carrier)(struct rc_dev *dev, u32 carrier);\n\tint\t\t\t\t(*s_tx_duty_cycle)(struct rc_dev *dev, u32 duty_cycle);\n\tint\t\t\t\t(*s_rx_carrier_range)(struct rc_dev *dev, u32 min, u32 max);\n\tint\t\t\t\t(*tx_ir)(struct rc_dev *dev, unsigned *txbuf, unsigned n);\n\tvoid\t\t\t\t(*s_idle)(struct rc_dev *dev, bool enable);\n\tint\t\t\t\t(*s_wideband_receiver)(struct rc_dev *dev, int enable);\n\tint\t\t\t\t(*s_carrier_report) (struct rc_dev *dev, int enable);\n\tint\t\t\t\t(*s_filter)(struct rc_dev *dev,\n\t\t\t\t\t\t    struct rc_scancode_filter *filter);\n\tint\t\t\t\t(*s_wakeup_filter)(struct rc_dev *dev,\n\t\t\t\t\t\t\t   struct rc_scancode_filter *filter);\n\tint\t\t\t\t(*s_timeout)(struct rc_dev *dev,\n\t\t\t\t\t\t     unsigned int timeout);\n};\n\n#define to_rc_dev(d) container_of(d, struct rc_dev, dev)\n\n \n\n \nstruct rc_dev *rc_allocate_device(enum rc_driver_type);\n\n \nstruct rc_dev *devm_rc_allocate_device(struct device *dev, enum rc_driver_type);\n\n \nvoid rc_free_device(struct rc_dev *dev);\n\n \nint rc_register_device(struct rc_dev *dev);\n\n \nint devm_rc_register_device(struct device *parent, struct rc_dev *dev);\n\n \nvoid rc_unregister_device(struct rc_dev *dev);\n\nvoid rc_repeat(struct rc_dev *dev);\nvoid rc_keydown(struct rc_dev *dev, enum rc_proto protocol, u64 scancode,\n\t\tu8 toggle);\nvoid rc_keydown_notimeout(struct rc_dev *dev, enum rc_proto protocol,\n\t\t\t  u64 scancode, u8 toggle);\nvoid rc_keyup(struct rc_dev *dev);\nu32 rc_g_keycode_from_table(struct rc_dev *dev, u64 scancode);\n\n \nstruct ir_raw_event {\n\tunion {\n\t\tu32             duration;\n\t\tu32             carrier;\n\t};\n\tu8                      duty_cycle;\n\n\tunsigned                pulse:1;\n\tunsigned                overflow:1;\n\tunsigned                timeout:1;\n\tunsigned                carrier_report:1;\n};\n\n#define US_TO_NS(usec)\t\t((usec) * 1000)\n#define MS_TO_US(msec)\t\t((msec) * 1000)\n#define IR_MAX_DURATION\t\tMS_TO_US(500)\n#define IR_DEFAULT_TIMEOUT\tMS_TO_US(125)\n#define IR_MAX_TIMEOUT\t\tLIRC_VALUE_MASK\n\nvoid ir_raw_event_handle(struct rc_dev *dev);\nint ir_raw_event_store(struct rc_dev *dev, struct ir_raw_event *ev);\nint ir_raw_event_store_edge(struct rc_dev *dev, bool pulse);\nint ir_raw_event_store_with_filter(struct rc_dev *dev,\n\t\t\t\t   struct ir_raw_event *ev);\nint ir_raw_event_store_with_timeout(struct rc_dev *dev,\n\t\t\t\t    struct ir_raw_event *ev);\nvoid ir_raw_event_set_idle(struct rc_dev *dev, bool idle);\nint ir_raw_encode_scancode(enum rc_proto protocol, u32 scancode,\n\t\t\t   struct ir_raw_event *events, unsigned int max);\nint ir_raw_encode_carrier(enum rc_proto protocol);\n\nstatic inline void ir_raw_event_overflow(struct rc_dev *dev)\n{\n\tir_raw_event_store(dev, &((struct ir_raw_event) { .overflow = true }));\n\tdev->idle = true;\n\tir_raw_event_handle(dev);\n}\n\n \nstatic inline u32 ir_extract_bits(u32 data, u32 mask)\n{\n\tu32 vbit = 1, value = 0;\n\n\tdo {\n\t\tif (mask & 1) {\n\t\t\tif (data & 1)\n\t\t\t\tvalue |= vbit;\n\t\t\tvbit <<= 1;\n\t\t}\n\t\tdata >>= 1;\n\t} while (mask >>= 1);\n\n\treturn value;\n}\n\n \nstatic inline u32 ir_nec_bytes_to_scancode(u8 address, u8 not_address,\n\t\t\t\t\t   u8 command, u8 not_command,\n\t\t\t\t\t   enum rc_proto *protocol)\n{\n\tu32 scancode;\n\n\tif ((command ^ not_command) != 0xff) {\n\t\t \n\t\tscancode = not_address << 24 |\n\t\t\taddress     << 16 |\n\t\t\tnot_command <<  8 |\n\t\t\tcommand;\n\t\t*protocol = RC_PROTO_NEC32;\n\t} else if ((address ^ not_address) != 0xff) {\n\t\t \n\t\tscancode = address     << 16 |\n\t\t\t   not_address <<  8 |\n\t\t\t   command;\n\t\t*protocol = RC_PROTO_NECX;\n\t} else {\n\t\t \n\t\tscancode = address << 8 | command;\n\t\t*protocol = RC_PROTO_NEC;\n\t}\n\n\treturn scancode;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}