{
  "module_name": "net_namespace.h",
  "hash_id": "758612f5c43bc5f94b757ec67ca021370eb73787e8de5a4c7479b6cfe7695cc0",
  "original_prompt": "Ingested from linux-6.6.14/include/net/net_namespace.h",
  "human_readable_source": " \n \n#ifndef __NET_NET_NAMESPACE_H\n#define __NET_NET_NAMESPACE_H\n\n#include <linux/atomic.h>\n#include <linux/refcount.h>\n#include <linux/workqueue.h>\n#include <linux/list.h>\n#include <linux/sysctl.h>\n#include <linux/uidgid.h>\n\n#include <net/flow.h>\n#include <net/netns/core.h>\n#include <net/netns/mib.h>\n#include <net/netns/unix.h>\n#include <net/netns/packet.h>\n#include <net/netns/ipv4.h>\n#include <net/netns/ipv6.h>\n#include <net/netns/nexthop.h>\n#include <net/netns/ieee802154_6lowpan.h>\n#include <net/netns/sctp.h>\n#include <net/netns/netfilter.h>\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\n#include <net/netns/conntrack.h>\n#endif\n#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)\n#include <net/netns/flow_table.h>\n#endif\n#include <net/netns/nftables.h>\n#include <net/netns/xfrm.h>\n#include <net/netns/mpls.h>\n#include <net/netns/can.h>\n#include <net/netns/xdp.h>\n#include <net/netns/smc.h>\n#include <net/netns/bpf.h>\n#include <net/netns/mctp.h>\n#include <net/net_trackers.h>\n#include <linux/ns_common.h>\n#include <linux/idr.h>\n#include <linux/skbuff.h>\n#include <linux/notifier.h>\n#include <linux/xarray.h>\n\nstruct user_namespace;\nstruct proc_dir_entry;\nstruct net_device;\nstruct sock;\nstruct ctl_table_header;\nstruct net_generic;\nstruct uevent_sock;\nstruct netns_ipvs;\nstruct bpf_prog;\n\n\n#define NETDEV_HASHBITS    8\n#define NETDEV_HASHENTRIES (1 << NETDEV_HASHBITS)\n\nstruct net {\n\t \n\trefcount_t\t\tpassive;\t \n\tspinlock_t\t\trules_mod_lock;\n\n\tatomic_t\t\tdev_unreg_count;\n\n\tunsigned int\t\tdev_base_seq;\t \n\tu32\t\t\tifindex;\n\n\tspinlock_t\t\tnsid_lock;\n\tatomic_t\t\tfnhe_genid;\n\n\tstruct list_head\tlist;\t\t \n\tstruct list_head\texit_list;\t \n\tstruct llist_node\tcleanup_list;\t \n\n#ifdef CONFIG_KEYS\n\tstruct key_tag\t\t*key_domain;\t \n#endif\n\tstruct user_namespace   *user_ns;\t \n\tstruct ucounts\t\t*ucounts;\n\tstruct idr\t\tnetns_ids;\n\n\tstruct ns_common\tns;\n\tstruct ref_tracker_dir  refcnt_tracker;\n\tstruct ref_tracker_dir  notrefcnt_tracker;  \n\tstruct list_head \tdev_base_head;\n\tstruct proc_dir_entry \t*proc_net;\n\tstruct proc_dir_entry \t*proc_net_stat;\n\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table_set\tsysctls;\n#endif\n\n\tstruct sock \t\t*rtnl;\t\t\t \n\tstruct sock\t\t*genl_sock;\n\n\tstruct uevent_sock\t*uevent_sock;\t\t \n\n\tstruct hlist_head \t*dev_name_head;\n\tstruct hlist_head\t*dev_index_head;\n\tstruct xarray\t\tdev_by_index;\n\tstruct raw_notifier_head\tnetdev_chain;\n\n\t \n\tu32\t\t\thash_mix;\n\n\tstruct net_device       *loopback_dev;           \n\n\t \n\tstruct list_head\trules_ops;\n\n\tstruct netns_core\tcore;\n\tstruct netns_mib\tmib;\n\tstruct netns_packet\tpacket;\n#if IS_ENABLED(CONFIG_UNIX)\n\tstruct netns_unix\tunx;\n#endif\n\tstruct netns_nexthop\tnexthop;\n\tstruct netns_ipv4\tipv4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct netns_ipv6\tipv6;\n#endif\n#if IS_ENABLED(CONFIG_IEEE802154_6LOWPAN)\n\tstruct netns_ieee802154_lowpan\tieee802154_lowpan;\n#endif\n#if defined(CONFIG_IP_SCTP) || defined(CONFIG_IP_SCTP_MODULE)\n\tstruct netns_sctp\tsctp;\n#endif\n#ifdef CONFIG_NETFILTER\n\tstruct netns_nf\t\tnf;\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\n\tstruct netns_ct\t\tct;\n#endif\n#if defined(CONFIG_NF_TABLES) || defined(CONFIG_NF_TABLES_MODULE)\n\tstruct netns_nftables\tnft;\n#endif\n#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)\n\tstruct netns_ft ft;\n#endif\n#endif\n#ifdef CONFIG_WEXT_CORE\n\tstruct sk_buff_head\twext_nlevents;\n#endif\n\tstruct net_generic __rcu\t*gen;\n\n\t \n\tstruct netns_bpf\tbpf;\n\n\t \n#ifdef CONFIG_XFRM\n\tstruct netns_xfrm\txfrm;\n#endif\n\n\tu64\t\t\tnet_cookie;  \n\n#if IS_ENABLED(CONFIG_IP_VS)\n\tstruct netns_ipvs\t*ipvs;\n#endif\n#if IS_ENABLED(CONFIG_MPLS)\n\tstruct netns_mpls\tmpls;\n#endif\n#if IS_ENABLED(CONFIG_CAN)\n\tstruct netns_can\tcan;\n#endif\n#ifdef CONFIG_XDP_SOCKETS\n\tstruct netns_xdp\txdp;\n#endif\n#if IS_ENABLED(CONFIG_MCTP)\n\tstruct netns_mctp\tmctp;\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_USER)\n\tstruct sock\t\t*crypto_nlsk;\n#endif\n\tstruct sock\t\t*diag_nlsk;\n#if IS_ENABLED(CONFIG_SMC)\n\tstruct netns_smc\tsmc;\n#endif\n} __randomize_layout;\n\n#include <linux/seq_file_net.h>\n\n \nextern struct net init_net;\n\n#ifdef CONFIG_NET_NS\nstruct net *copy_net_ns(unsigned long flags, struct user_namespace *user_ns,\n\t\t\tstruct net *old_net);\n\nvoid net_ns_get_ownership(const struct net *net, kuid_t *uid, kgid_t *gid);\n\nvoid net_ns_barrier(void);\n\nstruct ns_common *get_net_ns(struct ns_common *ns);\nstruct net *get_net_ns_by_fd(int fd);\n#else  \n#include <linux/sched.h>\n#include <linux/nsproxy.h>\nstatic inline struct net *copy_net_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct net *old_net)\n{\n\tif (flags & CLONE_NEWNET)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn old_net;\n}\n\nstatic inline void net_ns_get_ownership(const struct net *net,\n\t\t\t\t\tkuid_t *uid, kgid_t *gid)\n{\n\t*uid = GLOBAL_ROOT_UID;\n\t*gid = GLOBAL_ROOT_GID;\n}\n\nstatic inline void net_ns_barrier(void) {}\n\nstatic inline struct ns_common *get_net_ns(struct ns_common *ns)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic inline struct net *get_net_ns_by_fd(int fd)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n#endif  \n\n\nextern struct list_head net_namespace_list;\n\nstruct net *get_net_ns_by_pid(pid_t pid);\n\n#ifdef CONFIG_SYSCTL\nvoid ipx_register_sysctl(void);\nvoid ipx_unregister_sysctl(void);\n#else\n#define ipx_register_sysctl()\n#define ipx_unregister_sysctl()\n#endif\n\n#ifdef CONFIG_NET_NS\nvoid __put_net(struct net *net);\n\n \nstatic inline struct net *get_net(struct net *net)\n{\n\trefcount_inc(&net->ns.count);\n\treturn net;\n}\n\nstatic inline struct net *maybe_get_net(struct net *net)\n{\n\t \n\tif (!refcount_inc_not_zero(&net->ns.count))\n\t\tnet = NULL;\n\treturn net;\n}\n\n \nstatic inline void put_net(struct net *net)\n{\n\tif (refcount_dec_and_test(&net->ns.count))\n\t\t__put_net(net);\n}\n\nstatic inline\nint net_eq(const struct net *net1, const struct net *net2)\n{\n\treturn net1 == net2;\n}\n\nstatic inline int check_net(const struct net *net)\n{\n\treturn refcount_read(&net->ns.count) != 0;\n}\n\nvoid net_drop_ns(void *);\n\n#else\n\nstatic inline struct net *get_net(struct net *net)\n{\n\treturn net;\n}\n\nstatic inline void put_net(struct net *net)\n{\n}\n\nstatic inline struct net *maybe_get_net(struct net *net)\n{\n\treturn net;\n}\n\nstatic inline\nint net_eq(const struct net *net1, const struct net *net2)\n{\n\treturn 1;\n}\n\nstatic inline int check_net(const struct net *net)\n{\n\treturn 1;\n}\n\n#define net_drop_ns NULL\n#endif\n\n\nstatic inline void __netns_tracker_alloc(struct net *net,\n\t\t\t\t\t netns_tracker *tracker,\n\t\t\t\t\t bool refcounted,\n\t\t\t\t\t gfp_t gfp)\n{\n#ifdef CONFIG_NET_NS_REFCNT_TRACKER\n\tref_tracker_alloc(refcounted ? &net->refcnt_tracker :\n\t\t\t\t       &net->notrefcnt_tracker,\n\t\t\t  tracker, gfp);\n#endif\n}\n\nstatic inline void netns_tracker_alloc(struct net *net, netns_tracker *tracker,\n\t\t\t\t       gfp_t gfp)\n{\n\t__netns_tracker_alloc(net, tracker, true, gfp);\n}\n\nstatic inline void __netns_tracker_free(struct net *net,\n\t\t\t\t\tnetns_tracker *tracker,\n\t\t\t\t\tbool refcounted)\n{\n#ifdef CONFIG_NET_NS_REFCNT_TRACKER\n       ref_tracker_free(refcounted ? &net->refcnt_tracker :\n\t\t\t\t     &net->notrefcnt_tracker, tracker);\n#endif\n}\n\nstatic inline struct net *get_net_track(struct net *net,\n\t\t\t\t\tnetns_tracker *tracker, gfp_t gfp)\n{\n\tget_net(net);\n\tnetns_tracker_alloc(net, tracker, gfp);\n\treturn net;\n}\n\nstatic inline void put_net_track(struct net *net, netns_tracker *tracker)\n{\n\t__netns_tracker_free(net, tracker, true);\n\tput_net(net);\n}\n\ntypedef struct {\n#ifdef CONFIG_NET_NS\n\tstruct net *net;\n#endif\n} possible_net_t;\n\nstatic inline void write_pnet(possible_net_t *pnet, struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\tpnet->net = net;\n#endif\n}\n\nstatic inline struct net *read_pnet(const possible_net_t *pnet)\n{\n#ifdef CONFIG_NET_NS\n\treturn pnet->net;\n#else\n\treturn &init_net;\n#endif\n}\n\n \n#define for_each_net(VAR)\t\t\t\t\\\n\tlist_for_each_entry(VAR, &net_namespace_list, list)\n#define for_each_net_continue_reverse(VAR)\t\t\\\n\tlist_for_each_entry_continue_reverse(VAR, &net_namespace_list, list)\n#define for_each_net_rcu(VAR)\t\t\t\t\\\n\tlist_for_each_entry_rcu(VAR, &net_namespace_list, list)\n\n#ifdef CONFIG_NET_NS\n#define __net_init\n#define __net_exit\n#define __net_initdata\n#define __net_initconst\n#else\n#define __net_init\t__init\n#define __net_exit\t__ref\n#define __net_initdata\t__initdata\n#define __net_initconst\t__initconst\n#endif\n\nint peernet2id_alloc(struct net *net, struct net *peer, gfp_t gfp);\nint peernet2id(const struct net *net, struct net *peer);\nbool peernet_has_id(const struct net *net, struct net *peer);\nstruct net *get_net_ns_by_id(const struct net *net, int id);\n\nstruct pernet_operations {\n\tstruct list_head list;\n\t \n\tint (*init)(struct net *net);\n\tvoid (*pre_exit)(struct net *net);\n\tvoid (*exit)(struct net *net);\n\tvoid (*exit_batch)(struct list_head *net_exit_list);\n\tunsigned int *id;\n\tsize_t size;\n};\n\n \nint register_pernet_subsys(struct pernet_operations *);\nvoid unregister_pernet_subsys(struct pernet_operations *);\nint register_pernet_device(struct pernet_operations *);\nvoid unregister_pernet_device(struct pernet_operations *);\n\nstruct ctl_table;\n\n#define register_net_sysctl(net, path, table)\t\\\n\tregister_net_sysctl_sz(net, path, table, ARRAY_SIZE(table))\n#ifdef CONFIG_SYSCTL\nint net_sysctl_init(void);\nstruct ctl_table_header *register_net_sysctl_sz(struct net *net, const char *path,\n\t\t\t\t\t     struct ctl_table *table, size_t table_size);\nvoid unregister_net_sysctl_table(struct ctl_table_header *header);\n#else\nstatic inline int net_sysctl_init(void) { return 0; }\nstatic inline struct ctl_table_header *register_net_sysctl_sz(struct net *net,\n\tconst char *path, struct ctl_table *table, size_t table_size)\n{\n\treturn NULL;\n}\nstatic inline void unregister_net_sysctl_table(struct ctl_table_header *header)\n{\n}\n#endif\n\nstatic inline int rt_genid_ipv4(const struct net *net)\n{\n\treturn atomic_read(&net->ipv4.rt_genid);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline int rt_genid_ipv6(const struct net *net)\n{\n\treturn atomic_read(&net->ipv6.fib6_sernum);\n}\n#endif\n\nstatic inline void rt_genid_bump_ipv4(struct net *net)\n{\n\tatomic_inc(&net->ipv4.rt_genid);\n}\n\nextern void (*__fib6_flush_trees)(struct net *net);\nstatic inline void rt_genid_bump_ipv6(struct net *net)\n{\n\tif (__fib6_flush_trees)\n\t\t__fib6_flush_trees(net);\n}\n\n#if IS_ENABLED(CONFIG_IEEE802154_6LOWPAN)\nstatic inline struct netns_ieee802154_lowpan *\nnet_ieee802154_lowpan(struct net *net)\n{\n\treturn &net->ieee802154_lowpan;\n}\n#endif\n\n \nstatic inline void rt_genid_bump_all(struct net *net)\n{\n\trt_genid_bump_ipv4(net);\n\trt_genid_bump_ipv6(net);\n}\n\nstatic inline int fnhe_genid(const struct net *net)\n{\n\treturn atomic_read(&net->fnhe_genid);\n}\n\nstatic inline void fnhe_genid_bump(struct net *net)\n{\n\tatomic_inc(&net->fnhe_genid);\n}\n\n#ifdef CONFIG_NET\nvoid net_ns_init(void);\n#else\nstatic inline void net_ns_init(void) {}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}