{
  "module_name": "netlink.h",
  "hash_id": "b112b9e4045680a60df2edd03a2490215c4747c758d71147b757a5a54bb69e06",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netlink.h",
  "human_readable_source": " \n#ifndef __NET_NETLINK_H\n#define __NET_NETLINK_H\n\n#include <linux/types.h>\n#include <linux/netlink.h>\n#include <linux/jiffies.h>\n#include <linux/in6.h>\n\n \n\n  \nenum {\n\tNLA_UNSPEC,\n\tNLA_U8,\n\tNLA_U16,\n\tNLA_U32,\n\tNLA_U64,\n\tNLA_STRING,\n\tNLA_FLAG,\n\tNLA_MSECS,\n\tNLA_NESTED,\n\tNLA_NESTED_ARRAY,\n\tNLA_NUL_STRING,\n\tNLA_BINARY,\n\tNLA_S8,\n\tNLA_S16,\n\tNLA_S32,\n\tNLA_S64,\n\tNLA_BITFIELD32,\n\tNLA_REJECT,\n\tNLA_BE16,\n\tNLA_BE32,\n\t__NLA_TYPE_MAX,\n};\n\n#define NLA_TYPE_MAX (__NLA_TYPE_MAX - 1)\n\nstruct netlink_range_validation {\n\tu64 min, max;\n};\n\nstruct netlink_range_validation_signed {\n\ts64 min, max;\n};\n\nenum nla_policy_validation {\n\tNLA_VALIDATE_NONE,\n\tNLA_VALIDATE_RANGE,\n\tNLA_VALIDATE_RANGE_WARN_TOO_LONG,\n\tNLA_VALIDATE_MIN,\n\tNLA_VALIDATE_MAX,\n\tNLA_VALIDATE_MASK,\n\tNLA_VALIDATE_RANGE_PTR,\n\tNLA_VALIDATE_FUNCTION,\n};\n\n \nstruct nla_policy {\n\tu8\t\ttype;\n\tu8\t\tvalidation_type;\n\tu16\t\tlen;\n\tunion {\n\t\t \n\t\tu16 strict_start_type;\n\n\t\t \n\t\tconst u32 bitfield32_valid;\n\t\tconst u32 mask;\n\t\tconst char *reject_message;\n\t\tconst struct nla_policy *nested_policy;\n\t\tstruct netlink_range_validation *range;\n\t\tstruct netlink_range_validation_signed *range_signed;\n\t\tstruct {\n\t\t\ts16 min, max;\n\t\t};\n\t\tint (*validate)(const struct nlattr *attr,\n\t\t\t\tstruct netlink_ext_ack *extack);\n\t};\n};\n\n#define NLA_POLICY_ETH_ADDR\t\tNLA_POLICY_EXACT_LEN(ETH_ALEN)\n#define NLA_POLICY_ETH_ADDR_COMPAT\tNLA_POLICY_EXACT_LEN_WARN(ETH_ALEN)\n\n#define _NLA_POLICY_NESTED(maxattr, policy) \\\n\t{ .type = NLA_NESTED, .nested_policy = policy, .len = maxattr }\n#define _NLA_POLICY_NESTED_ARRAY(maxattr, policy) \\\n\t{ .type = NLA_NESTED_ARRAY, .nested_policy = policy, .len = maxattr }\n#define NLA_POLICY_NESTED(policy) \\\n\t_NLA_POLICY_NESTED(ARRAY_SIZE(policy) - 1, policy)\n#define NLA_POLICY_NESTED_ARRAY(policy) \\\n\t_NLA_POLICY_NESTED_ARRAY(ARRAY_SIZE(policy) - 1, policy)\n#define NLA_POLICY_BITFIELD32(valid) \\\n\t{ .type = NLA_BITFIELD32, .bitfield32_valid = valid }\n\n#define __NLA_IS_UINT_TYPE(tp)\t\t\t\t\t\\\n\t(tp == NLA_U8 || tp == NLA_U16 || tp == NLA_U32 ||\t\\\n\t tp == NLA_U64 || tp == NLA_BE16 || tp == NLA_BE32)\n#define __NLA_IS_SINT_TYPE(tp)\t\t\t\t\t\t\\\n\t(tp == NLA_S8 || tp == NLA_S16 || tp == NLA_S32 || tp == NLA_S64)\n\n#define __NLA_ENSURE(condition) BUILD_BUG_ON_ZERO(!(condition))\n#define NLA_ENSURE_UINT_TYPE(tp)\t\t\t\\\n\t(__NLA_ENSURE(__NLA_IS_UINT_TYPE(tp)) + tp)\n#define NLA_ENSURE_UINT_OR_BINARY_TYPE(tp)\t\t\\\n\t(__NLA_ENSURE(__NLA_IS_UINT_TYPE(tp) ||\t\\\n\t\t      tp == NLA_MSECS ||\t\t\\\n\t\t      tp == NLA_BINARY) + tp)\n#define NLA_ENSURE_SINT_TYPE(tp)\t\t\t\\\n\t(__NLA_ENSURE(__NLA_IS_SINT_TYPE(tp)) + tp)\n#define NLA_ENSURE_INT_OR_BINARY_TYPE(tp)\t\t\\\n\t(__NLA_ENSURE(__NLA_IS_UINT_TYPE(tp) ||\t\t\\\n\t\t      __NLA_IS_SINT_TYPE(tp) ||\t\t\\\n\t\t      tp == NLA_MSECS ||\t\t\\\n\t\t      tp == NLA_BINARY) + tp)\n#define NLA_ENSURE_NO_VALIDATION_PTR(tp)\t\t\\\n\t(__NLA_ENSURE(tp != NLA_BITFIELD32 &&\t\t\\\n\t\t      tp != NLA_REJECT &&\t\t\\\n\t\t      tp != NLA_NESTED &&\t\t\\\n\t\t      tp != NLA_NESTED_ARRAY) + tp)\n\n#define NLA_POLICY_RANGE(tp, _min, _max) {\t\t\\\n\t.type = NLA_ENSURE_INT_OR_BINARY_TYPE(tp),\t\\\n\t.validation_type = NLA_VALIDATE_RANGE,\t\t\\\n\t.min = _min,\t\t\t\t\t\\\n\t.max = _max\t\t\t\t\t\\\n}\n\n#define NLA_POLICY_FULL_RANGE(tp, _range) {\t\t\\\n\t.type = NLA_ENSURE_UINT_OR_BINARY_TYPE(tp),\t\\\n\t.validation_type = NLA_VALIDATE_RANGE_PTR,\t\\\n\t.range = _range,\t\t\t\t\\\n}\n\n#define NLA_POLICY_FULL_RANGE_SIGNED(tp, _range) {\t\\\n\t.type = NLA_ENSURE_SINT_TYPE(tp),\t\t\\\n\t.validation_type = NLA_VALIDATE_RANGE_PTR,\t\\\n\t.range_signed = _range,\t\t\t\t\\\n}\n\n#define NLA_POLICY_MIN(tp, _min) {\t\t\t\\\n\t.type = NLA_ENSURE_INT_OR_BINARY_TYPE(tp),\t\\\n\t.validation_type = NLA_VALIDATE_MIN,\t\t\\\n\t.min = _min,\t\t\t\t\t\\\n}\n\n#define NLA_POLICY_MAX(tp, _max) {\t\t\t\\\n\t.type = NLA_ENSURE_INT_OR_BINARY_TYPE(tp),\t\\\n\t.validation_type = NLA_VALIDATE_MAX,\t\t\\\n\t.max = _max,\t\t\t\t\t\\\n}\n\n#define NLA_POLICY_MASK(tp, _mask) {\t\t\t\\\n\t.type = NLA_ENSURE_UINT_TYPE(tp),\t\t\\\n\t.validation_type = NLA_VALIDATE_MASK,\t\t\\\n\t.mask = _mask,\t\t\t\t\t\\\n}\n\n#define NLA_POLICY_VALIDATE_FN(tp, fn, ...) {\t\t\\\n\t.type = NLA_ENSURE_NO_VALIDATION_PTR(tp),\t\\\n\t.validation_type = NLA_VALIDATE_FUNCTION,\t\\\n\t.validate = fn,\t\t\t\t\t\\\n\t.len = __VA_ARGS__ + 0,\t\t\t\t\\\n}\n\n#define NLA_POLICY_EXACT_LEN(_len)\tNLA_POLICY_RANGE(NLA_BINARY, _len, _len)\n#define NLA_POLICY_EXACT_LEN_WARN(_len) {\t\t\t\\\n\t.type = NLA_BINARY,\t\t\t\t\t\\\n\t.validation_type = NLA_VALIDATE_RANGE_WARN_TOO_LONG,\t\\\n\t.min = _len,\t\t\t\t\t\t\\\n\t.max = _len\t\t\t\t\t\t\\\n}\n#define NLA_POLICY_MIN_LEN(_len)\tNLA_POLICY_MIN(NLA_BINARY, _len)\n\n \nstruct nl_info {\n\tstruct nlmsghdr\t\t*nlh;\n\tstruct net\t\t*nl_net;\n\tu32\t\t\tportid;\n\tu8\t\t\tskip_notify:1,\n\t\t\t\tskip_notify_kernel:1;\n};\n\n \nenum netlink_validation {\n\tNL_VALIDATE_LIBERAL = 0,\n\tNL_VALIDATE_TRAILING = BIT(0),\n\tNL_VALIDATE_MAXTYPE = BIT(1),\n\tNL_VALIDATE_UNSPEC = BIT(2),\n\tNL_VALIDATE_STRICT_ATTRS = BIT(3),\n\tNL_VALIDATE_NESTED = BIT(4),\n};\n\n#define NL_VALIDATE_DEPRECATED_STRICT (NL_VALIDATE_TRAILING |\\\n\t\t\t\t       NL_VALIDATE_MAXTYPE)\n#define NL_VALIDATE_STRICT (NL_VALIDATE_TRAILING |\\\n\t\t\t    NL_VALIDATE_MAXTYPE |\\\n\t\t\t    NL_VALIDATE_UNSPEC |\\\n\t\t\t    NL_VALIDATE_STRICT_ATTRS |\\\n\t\t\t    NL_VALIDATE_NESTED)\n\nint netlink_rcv_skb(struct sk_buff *skb,\n\t\t    int (*cb)(struct sk_buff *, struct nlmsghdr *,\n\t\t\t      struct netlink_ext_ack *));\nint nlmsg_notify(struct sock *sk, struct sk_buff *skb, u32 portid,\n\t\t unsigned int group, int report, gfp_t flags);\n\nint __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack);\nint __nla_parse(struct nlattr **tb, int maxtype, const struct nlattr *head,\n\t\tint len, const struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack);\nint nla_policy_len(const struct nla_policy *, int);\nstruct nlattr *nla_find(const struct nlattr *head, int len, int attrtype);\nssize_t nla_strscpy(char *dst, const struct nlattr *nla, size_t dstsize);\nchar *nla_strdup(const struct nlattr *nla, gfp_t flags);\nint nla_memcpy(void *dest, const struct nlattr *src, int count);\nint nla_memcmp(const struct nlattr *nla, const void *data, size_t size);\nint nla_strcmp(const struct nlattr *nla, const char *str);\nstruct nlattr *__nla_reserve(struct sk_buff *skb, int attrtype, int attrlen);\nstruct nlattr *__nla_reserve_64bit(struct sk_buff *skb, int attrtype,\n\t\t\t\t   int attrlen, int padattr);\nvoid *__nla_reserve_nohdr(struct sk_buff *skb, int attrlen);\nstruct nlattr *nla_reserve(struct sk_buff *skb, int attrtype, int attrlen);\nstruct nlattr *nla_reserve_64bit(struct sk_buff *skb, int attrtype,\n\t\t\t\t int attrlen, int padattr);\nvoid *nla_reserve_nohdr(struct sk_buff *skb, int attrlen);\nvoid __nla_put(struct sk_buff *skb, int attrtype, int attrlen,\n\t       const void *data);\nvoid __nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t     const void *data, int padattr);\nvoid __nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data);\nint nla_put(struct sk_buff *skb, int attrtype, int attrlen, const void *data);\nint nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t  const void *data, int padattr);\nint nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data);\nint nla_append(struct sk_buff *skb, int attrlen, const void *data);\n\n \n\n \nstatic inline int nlmsg_msg_size(int payload)\n{\n\treturn NLMSG_HDRLEN + payload;\n}\n\n \nstatic inline int nlmsg_total_size(int payload)\n{\n\treturn NLMSG_ALIGN(nlmsg_msg_size(payload));\n}\n\n \nstatic inline int nlmsg_padlen(int payload)\n{\n\treturn nlmsg_total_size(payload) - nlmsg_msg_size(payload);\n}\n\n \nstatic inline void *nlmsg_data(const struct nlmsghdr *nlh)\n{\n\treturn (unsigned char *) nlh + NLMSG_HDRLEN;\n}\n\n \nstatic inline int nlmsg_len(const struct nlmsghdr *nlh)\n{\n\treturn nlh->nlmsg_len - NLMSG_HDRLEN;\n}\n\n \nstatic inline struct nlattr *nlmsg_attrdata(const struct nlmsghdr *nlh,\n\t\t\t\t\t    int hdrlen)\n{\n\tunsigned char *data = nlmsg_data(nlh);\n\treturn (struct nlattr *) (data + NLMSG_ALIGN(hdrlen));\n}\n\n \nstatic inline int nlmsg_attrlen(const struct nlmsghdr *nlh, int hdrlen)\n{\n\treturn nlmsg_len(nlh) - NLMSG_ALIGN(hdrlen);\n}\n\n \nstatic inline int nlmsg_ok(const struct nlmsghdr *nlh, int remaining)\n{\n\treturn (remaining >= (int) sizeof(struct nlmsghdr) &&\n\t\tnlh->nlmsg_len >= sizeof(struct nlmsghdr) &&\n\t\tnlh->nlmsg_len <= remaining);\n}\n\n \nstatic inline struct nlmsghdr *\nnlmsg_next(const struct nlmsghdr *nlh, int *remaining)\n{\n\tint totlen = NLMSG_ALIGN(nlh->nlmsg_len);\n\n\t*remaining -= totlen;\n\n\treturn (struct nlmsghdr *) ((unsigned char *) nlh + totlen);\n}\n\n \nstatic inline int nla_parse(struct nlattr **tb, int maxtype,\n\t\t\t    const struct nlattr *head, int len,\n\t\t\t    const struct nla_policy *policy,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn __nla_parse(tb, maxtype, head, len, policy,\n\t\t\t   NL_VALIDATE_STRICT, extack);\n}\n\n \nstatic inline int nla_parse_deprecated(struct nlattr **tb, int maxtype,\n\t\t\t\t       const struct nlattr *head, int len,\n\t\t\t\t       const struct nla_policy *policy,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn __nla_parse(tb, maxtype, head, len, policy,\n\t\t\t   NL_VALIDATE_LIBERAL, extack);\n}\n\n \nstatic inline int nla_parse_deprecated_strict(struct nlattr **tb, int maxtype,\n\t\t\t\t\t      const struct nlattr *head,\n\t\t\t\t\t      int len,\n\t\t\t\t\t      const struct nla_policy *policy,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn __nla_parse(tb, maxtype, head, len, policy,\n\t\t\t   NL_VALIDATE_DEPRECATED_STRICT, extack);\n}\n\n \nstatic inline int __nlmsg_parse(const struct nlmsghdr *nlh, int hdrlen,\n\t\t\t\tstruct nlattr *tb[], int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header length\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __nla_parse(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),\n\t\t\t   nlmsg_attrlen(nlh, hdrlen), policy, validate,\n\t\t\t   extack);\n}\n\n \nstatic inline int nlmsg_parse(const struct nlmsghdr *nlh, int hdrlen,\n\t\t\t      struct nlattr *tb[], int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn __nlmsg_parse(nlh, hdrlen, tb, maxtype, policy,\n\t\t\t     NL_VALIDATE_STRICT, extack);\n}\n\n \nstatic inline int nlmsg_parse_deprecated(const struct nlmsghdr *nlh, int hdrlen,\n\t\t\t\t\t struct nlattr *tb[], int maxtype,\n\t\t\t\t\t const struct nla_policy *policy,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn __nlmsg_parse(nlh, hdrlen, tb, maxtype, policy,\n\t\t\t     NL_VALIDATE_LIBERAL, extack);\n}\n\n \nstatic inline int\nnlmsg_parse_deprecated_strict(const struct nlmsghdr *nlh, int hdrlen,\n\t\t\t      struct nlattr *tb[], int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn __nlmsg_parse(nlh, hdrlen, tb, maxtype, policy,\n\t\t\t     NL_VALIDATE_DEPRECATED_STRICT, extack);\n}\n\n \nstatic inline struct nlattr *nlmsg_find_attr(const struct nlmsghdr *nlh,\n\t\t\t\t\t     int hdrlen, int attrtype)\n{\n\treturn nla_find(nlmsg_attrdata(nlh, hdrlen),\n\t\t\tnlmsg_attrlen(nlh, hdrlen), attrtype);\n}\n\n \nstatic inline int nla_validate_deprecated(const struct nlattr *head, int len,\n\t\t\t\t\t  int maxtype,\n\t\t\t\t\t  const struct nla_policy *policy,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate(head, len, maxtype, policy, NL_VALIDATE_LIBERAL,\n\t\t\t      extack);\n}\n\n \nstatic inline int nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t\t       const struct nla_policy *policy,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate(head, len, maxtype, policy, NL_VALIDATE_STRICT,\n\t\t\t      extack);\n}\n\n \nstatic inline int nlmsg_validate_deprecated(const struct nlmsghdr *nlh,\n\t\t\t\t\t    int hdrlen, int maxtype,\n\t\t\t\t\t    const struct nla_policy *policy,\n\t\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\n\t\treturn -EINVAL;\n\n\treturn __nla_validate(nlmsg_attrdata(nlh, hdrlen),\n\t\t\t      nlmsg_attrlen(nlh, hdrlen), maxtype,\n\t\t\t      policy, NL_VALIDATE_LIBERAL, extack);\n}\n\n\n\n \nstatic inline int nlmsg_report(const struct nlmsghdr *nlh)\n{\n\treturn nlh ? !!(nlh->nlmsg_flags & NLM_F_ECHO) : 0;\n}\n\n \nstatic inline u32 nlmsg_seq(const struct nlmsghdr *nlh)\n{\n\treturn nlh ? nlh->nlmsg_seq : 0;\n}\n\n \n#define nlmsg_for_each_attr(pos, nlh, hdrlen, rem) \\\n\tnla_for_each_attr(pos, nlmsg_attrdata(nlh, hdrlen), \\\n\t\t\t  nlmsg_attrlen(nlh, hdrlen), rem)\n\n \nstatic inline struct nlmsghdr *nlmsg_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t\t\t int type, int payload, int flags)\n{\n\tif (unlikely(skb_tailroom(skb) < nlmsg_total_size(payload)))\n\t\treturn NULL;\n\n\treturn __nlmsg_put(skb, portid, seq, type, payload, flags);\n}\n\n \nstatic inline void *nlmsg_append(struct sk_buff *skb, u32 size)\n{\n\tif (unlikely(skb_tailroom(skb) < NLMSG_ALIGN(size)))\n\t\treturn NULL;\n\n\tif (NLMSG_ALIGN(size) - size)\n\t\tmemset(skb_tail_pointer(skb) + size, 0,\n\t\t       NLMSG_ALIGN(size) - size);\n\treturn __skb_put(skb, NLMSG_ALIGN(size));\n}\n\n \nstatic inline struct nlmsghdr *nlmsg_put_answer(struct sk_buff *skb,\n\t\t\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\t\t\tint type, int payload,\n\t\t\t\t\t\tint flags)\n{\n\treturn nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t type, payload, flags);\n}\n\n \nstatic inline struct sk_buff *nlmsg_new(size_t payload, gfp_t flags)\n{\n\treturn alloc_skb(nlmsg_total_size(payload), flags);\n}\n\n \nstatic inline void nlmsg_end(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - (unsigned char *)nlh;\n}\n\n \nstatic inline void *nlmsg_get_pos(struct sk_buff *skb)\n{\n\treturn skb_tail_pointer(skb);\n}\n\n \nstatic inline void nlmsg_trim(struct sk_buff *skb, const void *mark)\n{\n\tif (mark) {\n\t\tWARN_ON((unsigned char *) mark < skb->data);\n\t\tskb_trim(skb, (unsigned char *) mark - skb->data);\n\t}\n}\n\n \nstatic inline void nlmsg_cancel(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tnlmsg_trim(skb, nlh);\n}\n\n \nstatic inline void nlmsg_free(struct sk_buff *skb)\n{\n\tkfree_skb(skb);\n}\n\n \nstatic inline int nlmsg_multicast(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  u32 portid, unsigned int group, gfp_t flags)\n{\n\tint err;\n\n\tNETLINK_CB(skb).dst_group = group;\n\n\terr = netlink_broadcast(sk, skb, portid, group, flags);\n\tif (err > 0)\n\t\terr = 0;\n\n\treturn err;\n}\n\n \nstatic inline int nlmsg_unicast(struct sock *sk, struct sk_buff *skb, u32 portid)\n{\n\tint err;\n\n\terr = netlink_unicast(sk, skb, portid, MSG_DONTWAIT);\n\tif (err > 0)\n\t\terr = 0;\n\n\treturn err;\n}\n\n \n#define nlmsg_for_each_msg(pos, head, len, rem) \\\n\tfor (pos = head, rem = len; \\\n\t     nlmsg_ok(pos, rem); \\\n\t     pos = nlmsg_next(pos, &(rem)))\n\n \nstatic inline void\nnl_dump_check_consistent(struct netlink_callback *cb,\n\t\t\t struct nlmsghdr *nlh)\n{\n\tif (cb->prev_seq && cb->seq != cb->prev_seq)\n\t\tnlh->nlmsg_flags |= NLM_F_DUMP_INTR;\n\tcb->prev_seq = cb->seq;\n}\n\n \n\n \nstatic inline int nla_attr_size(int payload)\n{\n\treturn NLA_HDRLEN + payload;\n}\n\n \nstatic inline int nla_total_size(int payload)\n{\n\treturn NLA_ALIGN(nla_attr_size(payload));\n}\n\n \nstatic inline int nla_padlen(int payload)\n{\n\treturn nla_total_size(payload) - nla_attr_size(payload);\n}\n\n \nstatic inline int nla_type(const struct nlattr *nla)\n{\n\treturn nla->nla_type & NLA_TYPE_MASK;\n}\n\n \nstatic inline void *nla_data(const struct nlattr *nla)\n{\n\treturn (char *) nla + NLA_HDRLEN;\n}\n\n \nstatic inline int nla_len(const struct nlattr *nla)\n{\n\treturn nla->nla_len - NLA_HDRLEN;\n}\n\n \nstatic inline int nla_ok(const struct nlattr *nla, int remaining)\n{\n\treturn remaining >= (int) sizeof(*nla) &&\n\t       nla->nla_len >= sizeof(*nla) &&\n\t       nla->nla_len <= remaining;\n}\n\n \nstatic inline struct nlattr *nla_next(const struct nlattr *nla, int *remaining)\n{\n\tunsigned int totlen = NLA_ALIGN(nla->nla_len);\n\n\t*remaining -= totlen;\n\treturn (struct nlattr *) ((char *) nla + totlen);\n}\n\n \nstatic inline struct nlattr *\nnla_find_nested(const struct nlattr *nla, int attrtype)\n{\n\treturn nla_find(nla_data(nla), nla_len(nla), attrtype);\n}\n\n \nstatic inline int nla_parse_nested(struct nlattr *tb[], int maxtype,\n\t\t\t\t   const struct nlattr *nla,\n\t\t\t\t   const struct nla_policy *policy,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tif (!(nla->nla_type & NLA_F_NESTED)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla, \"NLA_F_NESTED is missing\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,\n\t\t\t   NL_VALIDATE_STRICT, extack);\n}\n\n \nstatic inline int nla_parse_nested_deprecated(struct nlattr *tb[], int maxtype,\n\t\t\t\t\t      const struct nlattr *nla,\n\t\t\t\t\t      const struct nla_policy *policy,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,\n\t\t\t   NL_VALIDATE_LIBERAL, extack);\n}\n\n \nstatic inline int nla_put_u8(struct sk_buff *skb, int attrtype, u8 value)\n{\n\t \n\tu8 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(u8), &tmp);\n}\n\n \nstatic inline int nla_put_u16(struct sk_buff *skb, int attrtype, u16 value)\n{\n\tu16 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(u16), &tmp);\n}\n\n \nstatic inline int nla_put_be16(struct sk_buff *skb, int attrtype, __be16 value)\n{\n\t__be16 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(__be16), &tmp);\n}\n\n \nstatic inline int nla_put_net16(struct sk_buff *skb, int attrtype, __be16 value)\n{\n\t__be16 tmp = value;\n\n\treturn nla_put_be16(skb, attrtype | NLA_F_NET_BYTEORDER, tmp);\n}\n\n \nstatic inline int nla_put_le16(struct sk_buff *skb, int attrtype, __le16 value)\n{\n\t__le16 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(__le16), &tmp);\n}\n\n \nstatic inline int nla_put_u32(struct sk_buff *skb, int attrtype, u32 value)\n{\n\tu32 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(u32), &tmp);\n}\n\n \nstatic inline int nla_put_be32(struct sk_buff *skb, int attrtype, __be32 value)\n{\n\t__be32 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(__be32), &tmp);\n}\n\n \nstatic inline int nla_put_net32(struct sk_buff *skb, int attrtype, __be32 value)\n{\n\t__be32 tmp = value;\n\n\treturn nla_put_be32(skb, attrtype | NLA_F_NET_BYTEORDER, tmp);\n}\n\n \nstatic inline int nla_put_le32(struct sk_buff *skb, int attrtype, __le32 value)\n{\n\t__le32 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(__le32), &tmp);\n}\n\n \nstatic inline int nla_put_u64_64bit(struct sk_buff *skb, int attrtype,\n\t\t\t\t    u64 value, int padattr)\n{\n\tu64 tmp = value;\n\n\treturn nla_put_64bit(skb, attrtype, sizeof(u64), &tmp, padattr);\n}\n\n \nstatic inline int nla_put_be64(struct sk_buff *skb, int attrtype, __be64 value,\n\t\t\t       int padattr)\n{\n\t__be64 tmp = value;\n\n\treturn nla_put_64bit(skb, attrtype, sizeof(__be64), &tmp, padattr);\n}\n\n \nstatic inline int nla_put_net64(struct sk_buff *skb, int attrtype, __be64 value,\n\t\t\t\tint padattr)\n{\n\t__be64 tmp = value;\n\n\treturn nla_put_be64(skb, attrtype | NLA_F_NET_BYTEORDER, tmp,\n\t\t\t    padattr);\n}\n\n \nstatic inline int nla_put_le64(struct sk_buff *skb, int attrtype, __le64 value,\n\t\t\t       int padattr)\n{\n\t__le64 tmp = value;\n\n\treturn nla_put_64bit(skb, attrtype, sizeof(__le64), &tmp, padattr);\n}\n\n \nstatic inline int nla_put_s8(struct sk_buff *skb, int attrtype, s8 value)\n{\n\ts8 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(s8), &tmp);\n}\n\n \nstatic inline int nla_put_s16(struct sk_buff *skb, int attrtype, s16 value)\n{\n\ts16 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(s16), &tmp);\n}\n\n \nstatic inline int nla_put_s32(struct sk_buff *skb, int attrtype, s32 value)\n{\n\ts32 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(s32), &tmp);\n}\n\n \nstatic inline int nla_put_s64(struct sk_buff *skb, int attrtype, s64 value,\n\t\t\t      int padattr)\n{\n\ts64 tmp = value;\n\n\treturn nla_put_64bit(skb, attrtype, sizeof(s64), &tmp, padattr);\n}\n\n \nstatic inline int nla_put_string(struct sk_buff *skb, int attrtype,\n\t\t\t\t const char *str)\n{\n\treturn nla_put(skb, attrtype, strlen(str) + 1, str);\n}\n\n \nstatic inline int nla_put_flag(struct sk_buff *skb, int attrtype)\n{\n\treturn nla_put(skb, attrtype, 0, NULL);\n}\n\n \nstatic inline int nla_put_msecs(struct sk_buff *skb, int attrtype,\n\t\t\t\tunsigned long njiffies, int padattr)\n{\n\tu64 tmp = jiffies_to_msecs(njiffies);\n\n\treturn nla_put_64bit(skb, attrtype, sizeof(u64), &tmp, padattr);\n}\n\n \nstatic inline int nla_put_in_addr(struct sk_buff *skb, int attrtype,\n\t\t\t\t  __be32 addr)\n{\n\t__be32 tmp = addr;\n\n\treturn nla_put_be32(skb, attrtype, tmp);\n}\n\n \nstatic inline int nla_put_in6_addr(struct sk_buff *skb, int attrtype,\n\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn nla_put(skb, attrtype, sizeof(*addr), addr);\n}\n\n \nstatic inline int nla_put_bitfield32(struct sk_buff *skb, int attrtype,\n\t\t\t\t     __u32 value, __u32 selector)\n{\n\tstruct nla_bitfield32 tmp = { value, selector, };\n\n\treturn nla_put(skb, attrtype, sizeof(tmp), &tmp);\n}\n\n \nstatic inline u32 nla_get_u32(const struct nlattr *nla)\n{\n\treturn *(u32 *) nla_data(nla);\n}\n\n \nstatic inline __be32 nla_get_be32(const struct nlattr *nla)\n{\n\treturn *(__be32 *) nla_data(nla);\n}\n\n \nstatic inline __le32 nla_get_le32(const struct nlattr *nla)\n{\n\treturn *(__le32 *) nla_data(nla);\n}\n\n \nstatic inline u16 nla_get_u16(const struct nlattr *nla)\n{\n\treturn *(u16 *) nla_data(nla);\n}\n\n \nstatic inline __be16 nla_get_be16(const struct nlattr *nla)\n{\n\treturn *(__be16 *) nla_data(nla);\n}\n\n \nstatic inline __le16 nla_get_le16(const struct nlattr *nla)\n{\n\treturn *(__le16 *) nla_data(nla);\n}\n\n \nstatic inline u8 nla_get_u8(const struct nlattr *nla)\n{\n\treturn *(u8 *) nla_data(nla);\n}\n\n \nstatic inline u64 nla_get_u64(const struct nlattr *nla)\n{\n\tu64 tmp;\n\n\tnla_memcpy(&tmp, nla, sizeof(tmp));\n\n\treturn tmp;\n}\n\n \nstatic inline __be64 nla_get_be64(const struct nlattr *nla)\n{\n\t__be64 tmp;\n\n\tnla_memcpy(&tmp, nla, sizeof(tmp));\n\n\treturn tmp;\n}\n\n \nstatic inline __le64 nla_get_le64(const struct nlattr *nla)\n{\n\treturn *(__le64 *) nla_data(nla);\n}\n\n \nstatic inline s32 nla_get_s32(const struct nlattr *nla)\n{\n\treturn *(s32 *) nla_data(nla);\n}\n\n \nstatic inline s16 nla_get_s16(const struct nlattr *nla)\n{\n\treturn *(s16 *) nla_data(nla);\n}\n\n \nstatic inline s8 nla_get_s8(const struct nlattr *nla)\n{\n\treturn *(s8 *) nla_data(nla);\n}\n\n \nstatic inline s64 nla_get_s64(const struct nlattr *nla)\n{\n\ts64 tmp;\n\n\tnla_memcpy(&tmp, nla, sizeof(tmp));\n\n\treturn tmp;\n}\n\n \nstatic inline int nla_get_flag(const struct nlattr *nla)\n{\n\treturn !!nla;\n}\n\n \nstatic inline unsigned long nla_get_msecs(const struct nlattr *nla)\n{\n\tu64 msecs = nla_get_u64(nla);\n\n\treturn msecs_to_jiffies((unsigned long) msecs);\n}\n\n \nstatic inline __be32 nla_get_in_addr(const struct nlattr *nla)\n{\n\treturn *(__be32 *) nla_data(nla);\n}\n\n \nstatic inline struct in6_addr nla_get_in6_addr(const struct nlattr *nla)\n{\n\tstruct in6_addr tmp;\n\n\tnla_memcpy(&tmp, nla, sizeof(tmp));\n\treturn tmp;\n}\n\n \nstatic inline struct nla_bitfield32 nla_get_bitfield32(const struct nlattr *nla)\n{\n\tstruct nla_bitfield32 tmp;\n\n\tnla_memcpy(&tmp, nla, sizeof(tmp));\n\treturn tmp;\n}\n\n \nstatic inline void *nla_memdup(const struct nlattr *src, gfp_t gfp)\n{\n\treturn kmemdup(nla_data(src), nla_len(src), gfp);\n}\n\n \nstatic inline struct nlattr *nla_nest_start_noflag(struct sk_buff *skb,\n\t\t\t\t\t\t   int attrtype)\n{\n\tstruct nlattr *start = (struct nlattr *)skb_tail_pointer(skb);\n\n\tif (nla_put(skb, attrtype, 0, NULL) < 0)\n\t\treturn NULL;\n\n\treturn start;\n}\n\n \nstatic inline struct nlattr *nla_nest_start(struct sk_buff *skb, int attrtype)\n{\n\treturn nla_nest_start_noflag(skb, attrtype | NLA_F_NESTED);\n}\n\n \nstatic inline int nla_nest_end(struct sk_buff *skb, struct nlattr *start)\n{\n\tstart->nla_len = skb_tail_pointer(skb) - (unsigned char *)start;\n\treturn skb->len;\n}\n\n \nstatic inline void nla_nest_cancel(struct sk_buff *skb, struct nlattr *start)\n{\n\tnlmsg_trim(skb, start);\n}\n\n \nstatic inline int __nla_validate_nested(const struct nlattr *start, int maxtype,\n\t\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\t\tunsigned int validate,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate(nla_data(start), nla_len(start), maxtype, policy,\n\t\t\t      validate, extack);\n}\n\nstatic inline int\nnla_validate_nested(const struct nlattr *start, int maxtype,\n\t\t    const struct nla_policy *policy,\n\t\t    struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_nested(start, maxtype, policy,\n\t\t\t\t     NL_VALIDATE_STRICT, extack);\n}\n\nstatic inline int\nnla_validate_nested_deprecated(const struct nlattr *start, int maxtype,\n\t\t\t       const struct nla_policy *policy,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_nested(start, maxtype, policy,\n\t\t\t\t     NL_VALIDATE_LIBERAL, extack);\n}\n\n \nstatic inline bool nla_need_padding_for_64bit(struct sk_buff *skb)\n{\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\t \n\tif (IS_ALIGNED((unsigned long)skb_tail_pointer(skb), 8))\n\t\treturn true;\n#endif\n\treturn false;\n}\n\n \nstatic inline int nla_align_64bit(struct sk_buff *skb, int padattr)\n{\n\tif (nla_need_padding_for_64bit(skb) &&\n\t    !nla_reserve(skb, padattr, 0))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\n \nstatic inline int nla_total_size_64bit(int payload)\n{\n\treturn NLA_ALIGN(nla_attr_size(payload))\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\t\t+ NLA_ALIGN(nla_attr_size(0))\n#endif\n\t\t;\n}\n\n \n#define nla_for_each_attr(pos, head, len, rem) \\\n\tfor (pos = head, rem = len; \\\n\t     nla_ok(pos, rem); \\\n\t     pos = nla_next(pos, &(rem)))\n\n \n#define nla_for_each_nested(pos, nla, rem) \\\n\tnla_for_each_attr(pos, nla_data(nla), nla_len(nla), rem)\n\n \nstatic inline bool nla_is_last(const struct nlattr *nla, int rem)\n{\n\treturn nla->nla_len == rem;\n}\n\nvoid nla_get_range_unsigned(const struct nla_policy *pt,\n\t\t\t    struct netlink_range_validation *range);\nvoid nla_get_range_signed(const struct nla_policy *pt,\n\t\t\t  struct netlink_range_validation_signed *range);\n\nstruct netlink_policy_dump_state;\n\nint netlink_policy_dump_add_policy(struct netlink_policy_dump_state **pstate,\n\t\t\t\t   const struct nla_policy *policy,\n\t\t\t\t   unsigned int maxtype);\nint netlink_policy_dump_get_policy_idx(struct netlink_policy_dump_state *state,\n\t\t\t\t       const struct nla_policy *policy,\n\t\t\t\t       unsigned int maxtype);\nbool netlink_policy_dump_loop(struct netlink_policy_dump_state *state);\nint netlink_policy_dump_write(struct sk_buff *skb,\n\t\t\t      struct netlink_policy_dump_state *state);\nint netlink_policy_dump_attr_size_estimate(const struct nla_policy *pt);\nint netlink_policy_dump_write_attr(struct sk_buff *skb,\n\t\t\t\t   const struct nla_policy *pt,\n\t\t\t\t   int nestattr);\nvoid netlink_policy_dump_free(struct netlink_policy_dump_state *state);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}