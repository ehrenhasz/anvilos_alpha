{
  "module_name": "ipv6.h",
  "hash_id": "4962faa0d40fe6263218da1af171f79cc89ee5ae899185a0763d56f1f004cdf1",
  "original_prompt": "Ingested from linux-6.6.14/include/net/ipv6.h",
  "human_readable_source": " \n \n\n#ifndef _NET_IPV6_H\n#define _NET_IPV6_H\n\n#include <linux/ipv6.h>\n#include <linux/hardirq.h>\n#include <linux/jhash.h>\n#include <linux/refcount.h>\n#include <linux/jump_label_ratelimit.h>\n#include <net/if_inet6.h>\n#include <net/flow.h>\n#include <net/flow_dissector.h>\n#include <net/inet_dscp.h>\n#include <net/snmp.h>\n#include <net/netns/hash.h>\n\nstruct ip_tunnel_info;\n\n#define SIN6_LEN_RFC2133\t24\n\n#define IPV6_MAXPLEN\t\t65535\n\n \n\n#define NEXTHDR_HOP\t\t0\t \n#define NEXTHDR_IPV4\t\t4\t \n#define NEXTHDR_TCP\t\t6\t \n#define NEXTHDR_UDP\t\t17\t \n#define NEXTHDR_IPV6\t\t41\t \n#define NEXTHDR_ROUTING\t\t43\t \n#define NEXTHDR_FRAGMENT\t44\t \n#define NEXTHDR_GRE\t\t47\t \n#define NEXTHDR_ESP\t\t50\t \n#define NEXTHDR_AUTH\t\t51\t \n#define NEXTHDR_ICMP\t\t58\t \n#define NEXTHDR_NONE\t\t59\t \n#define NEXTHDR_DEST\t\t60\t \n#define NEXTHDR_SCTP\t\t132\t \n#define NEXTHDR_MOBILITY\t135\t \n\n#define NEXTHDR_MAX\t\t255\n\n#define IPV6_DEFAULT_HOPLIMIT   64\n#define IPV6_DEFAULT_MCASTHOPS\t1\n\n \n\n \n#define IP6_DEFAULT_MAX_DST_OPTS_CNT\t 8\n#define IP6_DEFAULT_MAX_HBH_OPTS_CNT\t 8\n#define IP6_DEFAULT_MAX_DST_OPTS_LEN\t INT_MAX  \n#define IP6_DEFAULT_MAX_HBH_OPTS_LEN\t INT_MAX  \n\n \n\n#define IPV6_ADDR_ANY\t\t0x0000U\n\n#define IPV6_ADDR_UNICAST\t0x0001U\n#define IPV6_ADDR_MULTICAST\t0x0002U\n\n#define IPV6_ADDR_LOOPBACK\t0x0010U\n#define IPV6_ADDR_LINKLOCAL\t0x0020U\n#define IPV6_ADDR_SITELOCAL\t0x0040U\n\n#define IPV6_ADDR_COMPATv4\t0x0080U\n\n#define IPV6_ADDR_SCOPE_MASK\t0x00f0U\n\n#define IPV6_ADDR_MAPPED\t0x1000U\n\n \n#define IPV6_ADDR_MC_SCOPE(a)\t\\\n\t((a)->s6_addr[1] & 0x0f)\t \n#define __IPV6_ADDR_SCOPE_INVALID\t-1\n#define IPV6_ADDR_SCOPE_NODELOCAL\t0x01\n#define IPV6_ADDR_SCOPE_LINKLOCAL\t0x02\n#define IPV6_ADDR_SCOPE_SITELOCAL\t0x05\n#define IPV6_ADDR_SCOPE_ORGLOCAL\t0x08\n#define IPV6_ADDR_SCOPE_GLOBAL\t\t0x0e\n\n \n#define IPV6_ADDR_MC_FLAG_TRANSIENT(a)\t\\\n\t((a)->s6_addr[1] & 0x10)\n#define IPV6_ADDR_MC_FLAG_PREFIX(a)\t\\\n\t((a)->s6_addr[1] & 0x20)\n#define IPV6_ADDR_MC_FLAG_RENDEZVOUS(a)\t\\\n\t((a)->s6_addr[1] & 0x40)\n\n \n\nstruct frag_hdr {\n\t__u8\tnexthdr;\n\t__u8\treserved;\n\t__be16\tfrag_off;\n\t__be32\tidentification;\n};\n\n \nstruct hop_jumbo_hdr {\n\tu8\tnexthdr;\n\tu8\thdrlen;\n\tu8\ttlv_type;\t \n\tu8\ttlv_len;\t \n\t__be32\tjumbo_payload_len;\n};\n\n#define\tIP6_MF\t\t0x0001\n#define\tIP6_OFFSET\t0xFFF8\n\nstruct ip6_fraglist_iter {\n\tstruct ipv6hdr\t*tmp_hdr;\n\tstruct sk_buff\t*frag;\n\tint\t\toffset;\n\tunsigned int\thlen;\n\t__be32\t\tfrag_id;\n\tu8\t\tnexthdr;\n};\n\nint ip6_fraglist_init(struct sk_buff *skb, unsigned int hlen, u8 *prevhdr,\n\t\t      u8 nexthdr, __be32 frag_id,\n\t\t      struct ip6_fraglist_iter *iter);\nvoid ip6_fraglist_prepare(struct sk_buff *skb, struct ip6_fraglist_iter *iter);\n\nstatic inline struct sk_buff *ip6_fraglist_next(struct ip6_fraglist_iter *iter)\n{\n\tstruct sk_buff *skb = iter->frag;\n\n\titer->frag = skb->next;\n\tskb_mark_not_on_list(skb);\n\n\treturn skb;\n}\n\nstruct ip6_frag_state {\n\tu8\t\t*prevhdr;\n\tunsigned int\thlen;\n\tunsigned int\tmtu;\n\tunsigned int\tleft;\n\tint\t\toffset;\n\tint\t\tptr;\n\tint\t\throom;\n\tint\t\ttroom;\n\t__be32\t\tfrag_id;\n\tu8\t\tnexthdr;\n};\n\nvoid ip6_frag_init(struct sk_buff *skb, unsigned int hlen, unsigned int mtu,\n\t\t   unsigned short needed_tailroom, int hdr_room, u8 *prevhdr,\n\t\t   u8 nexthdr, __be32 frag_id, struct ip6_frag_state *state);\nstruct sk_buff *ip6_frag_next(struct sk_buff *skb,\n\t\t\t      struct ip6_frag_state *state);\n\n#define IP6_REPLY_MARK(net, mark) \\\n\t((net)->ipv6.sysctl.fwmark_reflect ? (mark) : 0)\n\n#include <net/sock.h>\n\n \nextern int sysctl_mld_max_msf;\nextern int sysctl_mld_qrv;\n\n#define _DEVINC(net, statname, mod, idev, field)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tmod##SNMP_INC_STATS64((_idev)->stats.statname, (field));\\\n\tmod##SNMP_INC_STATS64((net)->mib.statname##_statistics, (field));\\\n})\n\n \n#define _DEVINCATOMIC(net, statname, mod, idev, field)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_INC_STATS_ATOMIC_LONG((_idev)->stats.statname##dev, (field)); \\\n\tmod##SNMP_INC_STATS((net)->mib.statname##_statistics, (field));\\\n})\n\n \n#define _DEVINC_ATOMIC_ATOMIC(net, statname, idev, field)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_INC_STATS_ATOMIC_LONG((_idev)->stats.statname##dev, (field)); \\\n\tSNMP_INC_STATS_ATOMIC_LONG((net)->mib.statname##_statistics, (field));\\\n})\n\n#define _DEVADD(net, statname, mod, idev, field, val)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tmod##SNMP_ADD_STATS((_idev)->stats.statname, (field), (val)); \\\n\tmod##SNMP_ADD_STATS((net)->mib.statname##_statistics, (field), (val));\\\n})\n\n#define _DEVUPD(net, statname, mod, idev, field, val)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tmod##SNMP_UPD_PO_STATS((_idev)->stats.statname, field, (val)); \\\n\tmod##SNMP_UPD_PO_STATS((net)->mib.statname##_statistics, field, (val));\\\n})\n\n \n\n#define IP6_INC_STATS(net, idev,field)\t\t\\\n\t\t_DEVINC(net, ipv6, , idev, field)\n#define __IP6_INC_STATS(net, idev,field)\t\\\n\t\t_DEVINC(net, ipv6, __, idev, field)\n#define IP6_ADD_STATS(net, idev,field,val)\t\\\n\t\t_DEVADD(net, ipv6, , idev, field, val)\n#define __IP6_ADD_STATS(net, idev,field,val)\t\\\n\t\t_DEVADD(net, ipv6, __, idev, field, val)\n#define IP6_UPD_PO_STATS(net, idev,field,val)   \\\n\t\t_DEVUPD(net, ipv6, , idev, field, val)\n#define __IP6_UPD_PO_STATS(net, idev,field,val)   \\\n\t\t_DEVUPD(net, ipv6, __, idev, field, val)\n#define ICMP6_INC_STATS(net, idev, field)\t\\\n\t\t_DEVINCATOMIC(net, icmpv6, , idev, field)\n#define __ICMP6_INC_STATS(net, idev, field)\t\\\n\t\t_DEVINCATOMIC(net, icmpv6, __, idev, field)\n\n#define ICMP6MSGOUT_INC_STATS(net, idev, field)\t\t\\\n\t_DEVINC_ATOMIC_ATOMIC(net, icmpv6msg, idev, field +256)\n#define ICMP6MSGIN_INC_STATS(net, idev, field)\t\\\n\t_DEVINC_ATOMIC_ATOMIC(net, icmpv6msg, idev, field)\n\nstruct ip6_ra_chain {\n\tstruct ip6_ra_chain\t*next;\n\tstruct sock\t\t*sk;\n\tint\t\t\tsel;\n\tvoid\t\t\t(*destructor)(struct sock *);\n};\n\nextern struct ip6_ra_chain\t*ip6_ra_chain;\nextern rwlock_t ip6_ra_lock;\n\n \n\nstruct ipv6_txoptions {\n\trefcount_t\t\trefcnt;\n\t \n\tint\t\t\ttot_len;\n\n\t \n\n\t__u16\t\t\topt_flen;\t \n\t__u16\t\t\topt_nflen;\t \n\n\tstruct ipv6_opt_hdr\t*hopopt;\n\tstruct ipv6_opt_hdr\t*dst0opt;\n\tstruct ipv6_rt_hdr\t*srcrt;\t \n\tstruct ipv6_opt_hdr\t*dst1opt;\n\tstruct rcu_head\t\trcu;\n\t \n};\n\n \nenum flowlabel_reflect {\n\tFLOWLABEL_REFLECT_ESTABLISHED\t\t= 1,\n\tFLOWLABEL_REFLECT_TCP_RESET\t\t= 2,\n\tFLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES\t= 4,\n};\n\nstruct ip6_flowlabel {\n\tstruct ip6_flowlabel __rcu *next;\n\t__be32\t\t\tlabel;\n\tatomic_t\t\tusers;\n\tstruct in6_addr\t\tdst;\n\tstruct ipv6_txoptions\t*opt;\n\tunsigned long\t\tlinger;\n\tstruct rcu_head\t\trcu;\n\tu8\t\t\tshare;\n\tunion {\n\t\tstruct pid *pid;\n\t\tkuid_t uid;\n\t} owner;\n\tunsigned long\t\tlastuse;\n\tunsigned long\t\texpires;\n\tstruct net\t\t*fl_net;\n};\n\n#define IPV6_FLOWINFO_MASK\t\tcpu_to_be32(0x0FFFFFFF)\n#define IPV6_FLOWLABEL_MASK\t\tcpu_to_be32(0x000FFFFF)\n#define IPV6_FLOWLABEL_STATELESS_FLAG\tcpu_to_be32(0x00080000)\n\n#define IPV6_TCLASS_MASK (IPV6_FLOWINFO_MASK & ~IPV6_FLOWLABEL_MASK)\n#define IPV6_TCLASS_SHIFT\t20\n\nstruct ipv6_fl_socklist {\n\tstruct ipv6_fl_socklist\t__rcu\t*next;\n\tstruct ip6_flowlabel\t\t*fl;\n\tstruct rcu_head\t\t\trcu;\n};\n\nstruct ipcm6_cookie {\n\tstruct sockcm_cookie sockc;\n\t__s16 hlimit;\n\t__s16 tclass;\n\t__u16 gso_size;\n\t__s8  dontfrag;\n\tstruct ipv6_txoptions *opt;\n};\n\nstatic inline void ipcm6_init(struct ipcm6_cookie *ipc6)\n{\n\t*ipc6 = (struct ipcm6_cookie) {\n\t\t.hlimit = -1,\n\t\t.tclass = -1,\n\t\t.dontfrag = -1,\n\t};\n}\n\nstatic inline void ipcm6_init_sk(struct ipcm6_cookie *ipc6,\n\t\t\t\t const struct ipv6_pinfo *np)\n{\n\t*ipc6 = (struct ipcm6_cookie) {\n\t\t.hlimit = -1,\n\t\t.tclass = np->tclass,\n\t\t.dontfrag = np->dontfrag,\n\t};\n}\n\nstatic inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)\n{\n\tstruct ipv6_txoptions *opt;\n\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\tif (!refcount_inc_not_zero(&opt->refcnt))\n\t\t\topt = NULL;\n\t\telse\n\t\t\topt = rcu_pointer_handoff(opt);\n\t}\n\trcu_read_unlock();\n\treturn opt;\n}\n\nstatic inline void txopt_put(struct ipv6_txoptions *opt)\n{\n\tif (opt && refcount_dec_and_test(&opt->refcnt))\n\t\tkfree_rcu(opt, rcu);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstruct ip6_flowlabel *__fl6_sock_lookup(struct sock *sk, __be32 label);\n\nextern struct static_key_false_deferred ipv6_flowlabel_exclusive;\nstatic inline struct ip6_flowlabel *fl6_sock_lookup(struct sock *sk,\n\t\t\t\t\t\t    __be32 label)\n{\n\tif (static_branch_unlikely(&ipv6_flowlabel_exclusive.key) &&\n\t    READ_ONCE(sock_net(sk)->ipv6.flowlabel_has_excl))\n\t\treturn __fl6_sock_lookup(sk, label) ? : ERR_PTR(-ENOENT);\n\n\treturn NULL;\n}\n#endif\n\nstruct ipv6_txoptions *fl6_merge_options(struct ipv6_txoptions *opt_space,\n\t\t\t\t\t struct ip6_flowlabel *fl,\n\t\t\t\t\t struct ipv6_txoptions *fopt);\nvoid fl6_free_socklist(struct sock *sk);\nint ipv6_flowlabel_opt(struct sock *sk, sockptr_t optval, int optlen);\nint ipv6_flowlabel_opt_get(struct sock *sk, struct in6_flowlabel_req *freq,\n\t\t\t   int flags);\nint ip6_flowlabel_init(void);\nvoid ip6_flowlabel_cleanup(void);\nbool ip6_autoflowlabel(struct net *net, const struct ipv6_pinfo *np);\n\nstatic inline void fl6_sock_release(struct ip6_flowlabel *fl)\n{\n\tif (fl)\n\t\tatomic_dec(&fl->users);\n}\n\nenum skb_drop_reason icmpv6_notify(struct sk_buff *skb, u8 type,\n\t\t\t\t   u8 code, __be32 info);\n\nvoid icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\tstruct icmp6hdr *thdr, int len);\n\nint ip6_ra_control(struct sock *sk, int sel);\n\nint ipv6_parse_hopopts(struct sk_buff *skb);\n\nstruct ipv6_txoptions *ipv6_dup_options(struct sock *sk,\n\t\t\t\t\tstruct ipv6_txoptions *opt);\nstruct ipv6_txoptions *ipv6_renew_options(struct sock *sk,\n\t\t\t\t\t  struct ipv6_txoptions *opt,\n\t\t\t\t\t  int newtype,\n\t\t\t\t\t  struct ipv6_opt_hdr *newopt);\nstruct ipv6_txoptions *__ipv6_fixup_options(struct ipv6_txoptions *opt_space,\n\t\t\t\t\t    struct ipv6_txoptions *opt);\n\nstatic inline struct ipv6_txoptions *\nipv6_fixup_options(struct ipv6_txoptions *opt_space, struct ipv6_txoptions *opt)\n{\n\tif (!opt)\n\t\treturn NULL;\n\treturn __ipv6_fixup_options(opt_space, opt);\n}\n\nbool ipv6_opt_accepted(const struct sock *sk, const struct sk_buff *skb,\n\t\t       const struct inet6_skb_parm *opt);\nstruct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt);\n\n \nstatic inline int ipv6_has_hopopt_jumbo(const struct sk_buff *skb)\n{\n\tconst struct hop_jumbo_hdr *jhdr;\n\tconst struct ipv6hdr *nhdr;\n\n\tif (likely(skb->len <= GRO_LEGACY_MAX_SIZE))\n\t\treturn 0;\n\n\tif (skb->protocol != htons(ETH_P_IPV6))\n\t\treturn 0;\n\n\tif (skb_network_offset(skb) +\n\t    sizeof(struct ipv6hdr) +\n\t    sizeof(struct hop_jumbo_hdr) > skb_headlen(skb))\n\t\treturn 0;\n\n\tnhdr = ipv6_hdr(skb);\n\n\tif (nhdr->nexthdr != NEXTHDR_HOP)\n\t\treturn 0;\n\n\tjhdr = (const struct hop_jumbo_hdr *) (nhdr + 1);\n\tif (jhdr->tlv_type != IPV6_TLV_JUMBO || jhdr->hdrlen != 0 ||\n\t    jhdr->nexthdr != IPPROTO_TCP)\n\t\treturn 0;\n\treturn jhdr->nexthdr;\n}\n\n \nstatic inline int ipv6_hopopt_jumbo_remove(struct sk_buff *skb)\n{\n\tconst int hophdr_len = sizeof(struct hop_jumbo_hdr);\n\tint nexthdr = ipv6_has_hopopt_jumbo(skb);\n\tstruct ipv6hdr *h6;\n\n\tif (!nexthdr)\n\t\treturn 0;\n\n\tif (skb_cow_head(skb, 0))\n\t\treturn -1;\n\n\t \n\tmemmove(skb_mac_header(skb) + hophdr_len, skb_mac_header(skb),\n\t\tskb_network_header(skb) - skb_mac_header(skb) +\n\t\tsizeof(struct ipv6hdr));\n\n\t__skb_pull(skb, hophdr_len);\n\tskb->network_header += hophdr_len;\n\tskb->mac_header += hophdr_len;\n\n\th6 = ipv6_hdr(skb);\n\th6->nexthdr = nexthdr;\n\n\treturn 0;\n}\n\nstatic inline bool ipv6_accept_ra(struct inet6_dev *idev)\n{\n\t \n\treturn idev->cnf.forwarding ? idev->cnf.accept_ra == 2 :\n\t    idev->cnf.accept_ra;\n}\n\n#define IPV6_FRAG_HIGH_THRESH\t(4 * 1024*1024)\t \n#define IPV6_FRAG_LOW_THRESH\t(3 * 1024*1024)\t \n#define IPV6_FRAG_TIMEOUT\t(60 * HZ)\t \n\nint __ipv6_addr_type(const struct in6_addr *addr);\nstatic inline int ipv6_addr_type(const struct in6_addr *addr)\n{\n\treturn __ipv6_addr_type(addr) & 0xffff;\n}\n\nstatic inline int ipv6_addr_scope(const struct in6_addr *addr)\n{\n\treturn __ipv6_addr_type(addr) & IPV6_ADDR_SCOPE_MASK;\n}\n\nstatic inline int __ipv6_addr_src_scope(int type)\n{\n\treturn (type == IPV6_ADDR_ANY) ? __IPV6_ADDR_SCOPE_INVALID : (type >> 16);\n}\n\nstatic inline int ipv6_addr_src_scope(const struct in6_addr *addr)\n{\n\treturn __ipv6_addr_src_scope(__ipv6_addr_type(addr));\n}\n\nstatic inline bool __ipv6_addr_needs_scope_id(int type)\n{\n\treturn type & IPV6_ADDR_LINKLOCAL ||\n\t       (type & IPV6_ADDR_MULTICAST &&\n\t\t(type & (IPV6_ADDR_LOOPBACK|IPV6_ADDR_LINKLOCAL)));\n}\n\nstatic inline __u32 ipv6_iface_scope_id(const struct in6_addr *addr, int iface)\n{\n\treturn __ipv6_addr_needs_scope_id(__ipv6_addr_type(addr)) ? iface : 0;\n}\n\nstatic inline int ipv6_addr_cmp(const struct in6_addr *a1, const struct in6_addr *a2)\n{\n\treturn memcmp(a1, a2, sizeof(struct in6_addr));\n}\n\nstatic inline bool\nipv6_masked_addr_cmp(const struct in6_addr *a1, const struct in6_addr *m,\n\t\t     const struct in6_addr *a2)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul1 = (const unsigned long *)a1;\n\tconst unsigned long *ulm = (const unsigned long *)m;\n\tconst unsigned long *ul2 = (const unsigned long *)a2;\n\n\treturn !!(((ul1[0] ^ ul2[0]) & ulm[0]) |\n\t\t  ((ul1[1] ^ ul2[1]) & ulm[1]));\n#else\n\treturn !!(((a1->s6_addr32[0] ^ a2->s6_addr32[0]) & m->s6_addr32[0]) |\n\t\t  ((a1->s6_addr32[1] ^ a2->s6_addr32[1]) & m->s6_addr32[1]) |\n\t\t  ((a1->s6_addr32[2] ^ a2->s6_addr32[2]) & m->s6_addr32[2]) |\n\t\t  ((a1->s6_addr32[3] ^ a2->s6_addr32[3]) & m->s6_addr32[3]));\n#endif\n}\n\nstatic inline void ipv6_addr_prefix(struct in6_addr *pfx,\n\t\t\t\t    const struct in6_addr *addr,\n\t\t\t\t    int plen)\n{\n\t \n\tint o = plen >> 3,\n\t    b = plen & 0x7;\n\n\tmemset(pfx->s6_addr, 0, sizeof(pfx->s6_addr));\n\tmemcpy(pfx->s6_addr, addr, o);\n\tif (b != 0)\n\t\tpfx->s6_addr[o] = addr->s6_addr[o] & (0xff00 >> b);\n}\n\nstatic inline void ipv6_addr_prefix_copy(struct in6_addr *addr,\n\t\t\t\t\t const struct in6_addr *pfx,\n\t\t\t\t\t int plen)\n{\n\t \n\tint o = plen >> 3,\n\t    b = plen & 0x7;\n\n\tmemcpy(addr->s6_addr, pfx, o);\n\tif (b != 0) {\n\t\taddr->s6_addr[o] &= ~(0xff00 >> b);\n\t\taddr->s6_addr[o] |= (pfx->s6_addr[o] & (0xff00 >> b));\n\t}\n}\n\nstatic inline void __ipv6_addr_set_half(__be32 *addr,\n\t\t\t\t\t__be32 wh, __be32 wl)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n#if defined(__BIG_ENDIAN)\n\tif (__builtin_constant_p(wh) && __builtin_constant_p(wl)) {\n\t\t*(__force u64 *)addr = ((__force u64)(wh) << 32 | (__force u64)(wl));\n\t\treturn;\n\t}\n#elif defined(__LITTLE_ENDIAN)\n\tif (__builtin_constant_p(wl) && __builtin_constant_p(wh)) {\n\t\t*(__force u64 *)addr = ((__force u64)(wl) << 32 | (__force u64)(wh));\n\t\treturn;\n\t}\n#endif\n#endif\n\taddr[0] = wh;\n\taddr[1] = wl;\n}\n\nstatic inline void ipv6_addr_set(struct in6_addr *addr,\n\t\t\t\t     __be32 w1, __be32 w2,\n\t\t\t\t     __be32 w3, __be32 w4)\n{\n\t__ipv6_addr_set_half(&addr->s6_addr32[0], w1, w2);\n\t__ipv6_addr_set_half(&addr->s6_addr32[2], w3, w4);\n}\n\nstatic inline bool ipv6_addr_equal(const struct in6_addr *a1,\n\t\t\t\t   const struct in6_addr *a2)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul1 = (const unsigned long *)a1;\n\tconst unsigned long *ul2 = (const unsigned long *)a2;\n\n\treturn ((ul1[0] ^ ul2[0]) | (ul1[1] ^ ul2[1])) == 0UL;\n#else\n\treturn ((a1->s6_addr32[0] ^ a2->s6_addr32[0]) |\n\t\t(a1->s6_addr32[1] ^ a2->s6_addr32[1]) |\n\t\t(a1->s6_addr32[2] ^ a2->s6_addr32[2]) |\n\t\t(a1->s6_addr32[3] ^ a2->s6_addr32[3])) == 0;\n#endif\n}\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\nstatic inline bool __ipv6_prefix_equal64_half(const __be64 *a1,\n\t\t\t\t\t      const __be64 *a2,\n\t\t\t\t\t      unsigned int len)\n{\n\tif (len && ((*a1 ^ *a2) & cpu_to_be64((~0UL) << (64 - len))))\n\t\treturn false;\n\treturn true;\n}\n\nstatic inline bool ipv6_prefix_equal(const struct in6_addr *addr1,\n\t\t\t\t     const struct in6_addr *addr2,\n\t\t\t\t     unsigned int prefixlen)\n{\n\tconst __be64 *a1 = (const __be64 *)addr1;\n\tconst __be64 *a2 = (const __be64 *)addr2;\n\n\tif (prefixlen >= 64) {\n\t\tif (a1[0] ^ a2[0])\n\t\t\treturn false;\n\t\treturn __ipv6_prefix_equal64_half(a1 + 1, a2 + 1, prefixlen - 64);\n\t}\n\treturn __ipv6_prefix_equal64_half(a1, a2, prefixlen);\n}\n#else\nstatic inline bool ipv6_prefix_equal(const struct in6_addr *addr1,\n\t\t\t\t     const struct in6_addr *addr2,\n\t\t\t\t     unsigned int prefixlen)\n{\n\tconst __be32 *a1 = addr1->s6_addr32;\n\tconst __be32 *a2 = addr2->s6_addr32;\n\tunsigned int pdw, pbi;\n\n\t \n\tpdw = prefixlen >> 5;\n\tif (pdw && memcmp(a1, a2, pdw << 2))\n\t\treturn false;\n\n\t \n\tpbi = prefixlen & 0x1f;\n\tif (pbi && ((a1[pdw] ^ a2[pdw]) & htonl((0xffffffff) << (32 - pbi))))\n\t\treturn false;\n\n\treturn true;\n}\n#endif\n\nstatic inline bool ipv6_addr_any(const struct in6_addr *a)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul = (const unsigned long *)a;\n\n\treturn (ul[0] | ul[1]) == 0UL;\n#else\n\treturn (a->s6_addr32[0] | a->s6_addr32[1] |\n\t\ta->s6_addr32[2] | a->s6_addr32[3]) == 0;\n#endif\n}\n\nstatic inline u32 ipv6_addr_hash(const struct in6_addr *a)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul = (const unsigned long *)a;\n\tunsigned long x = ul[0] ^ ul[1];\n\n\treturn (u32)(x ^ (x >> 32));\n#else\n\treturn (__force u32)(a->s6_addr32[0] ^ a->s6_addr32[1] ^\n\t\t\t     a->s6_addr32[2] ^ a->s6_addr32[3]);\n#endif\n}\n\n \nstatic inline u32 __ipv6_addr_jhash(const struct in6_addr *a, const u32 initval)\n{\n\treturn jhash2((__force const u32 *)a->s6_addr32,\n\t\t      ARRAY_SIZE(a->s6_addr32), initval);\n}\n\nstatic inline bool ipv6_addr_loopback(const struct in6_addr *a)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst __be64 *be = (const __be64 *)a;\n\n\treturn (be[0] | (be[1] ^ cpu_to_be64(1))) == 0UL;\n#else\n\treturn (a->s6_addr32[0] | a->s6_addr32[1] |\n\t\ta->s6_addr32[2] | (a->s6_addr32[3] ^ cpu_to_be32(1))) == 0;\n#endif\n}\n\n \nstatic inline bool ipv6_addr_v4mapped(const struct in6_addr *a)\n{\n\treturn (\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\t\t*(unsigned long *)a |\n#else\n\t\t(__force unsigned long)(a->s6_addr32[0] | a->s6_addr32[1]) |\n#endif\n\t\t(__force unsigned long)(a->s6_addr32[2] ^\n\t\t\t\t\tcpu_to_be32(0x0000ffff))) == 0UL;\n}\n\nstatic inline bool ipv6_addr_v4mapped_any(const struct in6_addr *a)\n{\n\treturn ipv6_addr_v4mapped(a) && ipv4_is_zeronet(a->s6_addr32[3]);\n}\n\nstatic inline bool ipv6_addr_v4mapped_loopback(const struct in6_addr *a)\n{\n\treturn ipv6_addr_v4mapped(a) && ipv4_is_loopback(a->s6_addr32[3]);\n}\n\nstatic inline u32 ipv6_portaddr_hash(const struct net *net,\n\t\t\t\t     const struct in6_addr *addr6,\n\t\t\t\t     unsigned int port)\n{\n\tunsigned int hash, mix = net_hash_mix(net);\n\n\tif (ipv6_addr_any(addr6))\n\t\thash = jhash_1word(0, mix);\n\telse if (ipv6_addr_v4mapped(addr6))\n\t\thash = jhash_1word((__force u32)addr6->s6_addr32[3], mix);\n\telse\n\t\thash = jhash2((__force u32 *)addr6->s6_addr32, 4, mix);\n\n\treturn hash ^ port;\n}\n\n \nstatic inline bool ipv6_addr_orchid(const struct in6_addr *a)\n{\n\treturn (a->s6_addr32[0] & htonl(0xfffffff0)) == htonl(0x20010010);\n}\n\nstatic inline bool ipv6_addr_is_multicast(const struct in6_addr *addr)\n{\n\treturn (addr->s6_addr32[0] & htonl(0xFF000000)) == htonl(0xFF000000);\n}\n\nstatic inline void ipv6_addr_set_v4mapped(const __be32 addr,\n\t\t\t\t\t  struct in6_addr *v4mapped)\n{\n\tipv6_addr_set(v4mapped,\n\t\t\t0, 0,\n\t\t\thtonl(0x0000FFFF),\n\t\t\taddr);\n}\n\n \nstatic inline int __ipv6_addr_diff32(const void *token1, const void *token2, int addrlen)\n{\n\tconst __be32 *a1 = token1, *a2 = token2;\n\tint i;\n\n\taddrlen >>= 2;\n\n\tfor (i = 0; i < addrlen; i++) {\n\t\t__be32 xb = a1[i] ^ a2[i];\n\t\tif (xb)\n\t\t\treturn i * 32 + 31 - __fls(ntohl(xb));\n\t}\n\n\t \n\treturn addrlen << 5;\n}\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\nstatic inline int __ipv6_addr_diff64(const void *token1, const void *token2, int addrlen)\n{\n\tconst __be64 *a1 = token1, *a2 = token2;\n\tint i;\n\n\taddrlen >>= 3;\n\n\tfor (i = 0; i < addrlen; i++) {\n\t\t__be64 xb = a1[i] ^ a2[i];\n\t\tif (xb)\n\t\t\treturn i * 64 + 63 - __fls(be64_to_cpu(xb));\n\t}\n\n\treturn addrlen << 6;\n}\n#endif\n\nstatic inline int __ipv6_addr_diff(const void *token1, const void *token2, int addrlen)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tif (__builtin_constant_p(addrlen) && !(addrlen & 7))\n\t\treturn __ipv6_addr_diff64(token1, token2, addrlen);\n#endif\n\treturn __ipv6_addr_diff32(token1, token2, addrlen);\n}\n\nstatic inline int ipv6_addr_diff(const struct in6_addr *a1, const struct in6_addr *a2)\n{\n\treturn __ipv6_addr_diff(a1, a2, sizeof(struct in6_addr));\n}\n\n__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr);\n__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb);\n\nint ip6_dst_hoplimit(struct dst_entry *dst);\n\nstatic inline int ip6_sk_dst_hoplimit(struct ipv6_pinfo *np, struct flowi6 *fl6,\n\t\t\t\t      struct dst_entry *dst)\n{\n\tint hlimit;\n\n\tif (ipv6_addr_is_multicast(&fl6->daddr))\n\t\thlimit = np->mcast_hops;\n\telse\n\t\thlimit = np->hop_limit;\n\tif (hlimit < 0)\n\t\thlimit = ip6_dst_hoplimit(dst);\n\treturn hlimit;\n}\n\n \nstatic inline void iph_to_flow_copy_v6addrs(struct flow_keys *flow,\n\t\t\t\t\t    const struct ipv6hdr *iph)\n{\n\tBUILD_BUG_ON(offsetof(typeof(flow->addrs), v6addrs.dst) !=\n\t\t     offsetof(typeof(flow->addrs), v6addrs.src) +\n\t\t     sizeof(flow->addrs.v6addrs.src));\n\tmemcpy(&flow->addrs.v6addrs, &iph->addrs, sizeof(flow->addrs.v6addrs));\n\tflow->control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\nstatic inline bool ipv6_can_nonlocal_bind(struct net *net,\n\t\t\t\t\t  struct inet_sock *inet)\n{\n\treturn net->ipv6.sysctl.ip_nonlocal_bind ||\n\t\ttest_bit(INET_FLAGS_FREEBIND, &inet->inet_flags) ||\n\t\ttest_bit(INET_FLAGS_TRANSPARENT, &inet->inet_flags);\n}\n\n \n#define IP6_AUTO_FLOW_LABEL_OFF\t\t0\n#define IP6_AUTO_FLOW_LABEL_OPTOUT\t1\n#define IP6_AUTO_FLOW_LABEL_OPTIN\t2\n#define IP6_AUTO_FLOW_LABEL_FORCED\t3\n\n#define IP6_AUTO_FLOW_LABEL_MAX\t\tIP6_AUTO_FLOW_LABEL_FORCED\n\n#define IP6_DEFAULT_AUTO_FLOW_LABELS\tIP6_AUTO_FLOW_LABEL_OPTOUT\n\nstatic inline __be32 ip6_make_flowlabel(struct net *net, struct sk_buff *skb,\n\t\t\t\t\t__be32 flowlabel, bool autolabel,\n\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tu32 hash;\n\n\t \n\tflowlabel &= IPV6_FLOWLABEL_MASK;\n\n\tif (flowlabel ||\n\t    net->ipv6.sysctl.auto_flowlabels == IP6_AUTO_FLOW_LABEL_OFF ||\n\t    (!autolabel &&\n\t     net->ipv6.sysctl.auto_flowlabels != IP6_AUTO_FLOW_LABEL_FORCED))\n\t\treturn flowlabel;\n\n\thash = skb_get_hash_flowi6(skb, fl6);\n\n\t \n\thash = rol32(hash, 16);\n\n\tflowlabel = (__force __be32)hash & IPV6_FLOWLABEL_MASK;\n\n\tif (net->ipv6.sysctl.flowlabel_state_ranges)\n\t\tflowlabel |= IPV6_FLOWLABEL_STATELESS_FLAG;\n\n\treturn flowlabel;\n}\n\nstatic inline int ip6_default_np_autolabel(struct net *net)\n{\n\tswitch (net->ipv6.sysctl.auto_flowlabels) {\n\tcase IP6_AUTO_FLOW_LABEL_OFF:\n\tcase IP6_AUTO_FLOW_LABEL_OPTIN:\n\tdefault:\n\t\treturn 0;\n\tcase IP6_AUTO_FLOW_LABEL_OPTOUT:\n\tcase IP6_AUTO_FLOW_LABEL_FORCED:\n\t\treturn 1;\n\t}\n}\n#else\nstatic inline __be32 ip6_make_flowlabel(struct net *net, struct sk_buff *skb,\n\t\t\t\t\t__be32 flowlabel, bool autolabel,\n\t\t\t\t\tstruct flowi6 *fl6)\n{\n\treturn flowlabel;\n}\nstatic inline int ip6_default_np_autolabel(struct net *net)\n{\n\treturn 0;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline int ip6_multipath_hash_policy(const struct net *net)\n{\n\treturn net->ipv6.sysctl.multipath_hash_policy;\n}\nstatic inline u32 ip6_multipath_hash_fields(const struct net *net)\n{\n\treturn net->ipv6.sysctl.multipath_hash_fields;\n}\n#else\nstatic inline int ip6_multipath_hash_policy(const struct net *net)\n{\n\treturn 0;\n}\nstatic inline u32 ip6_multipath_hash_fields(const struct net *net)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic inline void ip6_flow_hdr(struct ipv6hdr *hdr, unsigned int tclass,\n\t\t\t\t__be32 flowlabel)\n{\n\t*(__be32 *)hdr = htonl(0x60000000 | (tclass << 20)) | flowlabel;\n}\n\nstatic inline __be32 ip6_flowinfo(const struct ipv6hdr *hdr)\n{\n\treturn *(__be32 *)hdr & IPV6_FLOWINFO_MASK;\n}\n\nstatic inline __be32 ip6_flowlabel(const struct ipv6hdr *hdr)\n{\n\treturn *(__be32 *)hdr & IPV6_FLOWLABEL_MASK;\n}\n\nstatic inline u8 ip6_tclass(__be32 flowinfo)\n{\n\treturn ntohl(flowinfo & IPV6_TCLASS_MASK) >> IPV6_TCLASS_SHIFT;\n}\n\nstatic inline dscp_t ip6_dscp(__be32 flowinfo)\n{\n\treturn inet_dsfield_to_dscp(ip6_tclass(flowinfo));\n}\n\nstatic inline __be32 ip6_make_flowinfo(unsigned int tclass, __be32 flowlabel)\n{\n\treturn htonl(tclass << IPV6_TCLASS_SHIFT) | flowlabel;\n}\n\nstatic inline __be32 flowi6_get_flowlabel(const struct flowi6 *fl6)\n{\n\treturn fl6->flowlabel & IPV6_FLOWLABEL_MASK;\n}\n\n \n\n \n\nint ipv6_rcv(struct sk_buff *skb, struct net_device *dev,\n\t     struct packet_type *pt, struct net_device *orig_dev);\nvoid ipv6_list_rcv(struct list_head *head, struct packet_type *pt,\n\t\t   struct net_device *orig_dev);\n\nint ip6_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb);\n\n \nint ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,\n\t     __u32 mark, struct ipv6_txoptions *opt, int tclass, u32 priority);\n\nint ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr);\n\nint ip6_append_data(struct sock *sk,\n\t\t    int getfrag(void *from, char *to, int offset, int len,\n\t\t\t\tint odd, struct sk_buff *skb),\n\t\t    void *from, size_t length, int transhdrlen,\n\t\t    struct ipcm6_cookie *ipc6, struct flowi6 *fl6,\n\t\t    struct rt6_info *rt, unsigned int flags);\n\nint ip6_push_pending_frames(struct sock *sk);\n\nvoid ip6_flush_pending_frames(struct sock *sk);\n\nint ip6_send_skb(struct sk_buff *skb);\n\nstruct sk_buff *__ip6_make_skb(struct sock *sk, struct sk_buff_head *queue,\n\t\t\t       struct inet_cork_full *cork,\n\t\t\t       struct inet6_cork *v6_cork);\nstruct sk_buff *ip6_make_skb(struct sock *sk,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, size_t length, int transhdrlen,\n\t\t\t     struct ipcm6_cookie *ipc6,\n\t\t\t     struct rt6_info *rt, unsigned int flags,\n\t\t\t     struct inet_cork_full *cork);\n\nstatic inline struct sk_buff *ip6_finish_skb(struct sock *sk)\n{\n\treturn __ip6_make_skb(sk, &sk->sk_write_queue, &inet_sk(sk)->cork,\n\t\t\t      &inet6_sk(sk)->cork);\n}\n\nint ip6_dst_lookup(struct net *net, struct sock *sk, struct dst_entry **dst,\n\t\t   struct flowi6 *fl6);\nstruct dst_entry *ip6_dst_lookup_flow(struct net *net, const struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t      const struct in6_addr *final_dst);\nstruct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t\t const struct in6_addr *final_dst,\n\t\t\t\t\t bool connected);\nstruct dst_entry *ip6_dst_lookup_tunnel(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\tstruct net *net, struct socket *sock,\n\t\t\t\t\tstruct in6_addr *saddr,\n\t\t\t\t\tconst struct ip_tunnel_info *info,\n\t\t\t\t\tu8 protocol, bool use_cache);\nstruct dst_entry *ip6_blackhole_route(struct net *net,\n\t\t\t\t      struct dst_entry *orig_dst);\n\n \n\nint ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb);\nint ip6_forward(struct sk_buff *skb);\nint ip6_input(struct sk_buff *skb);\nint ip6_mc_input(struct sk_buff *skb);\nvoid ip6_protocol_deliver_rcu(struct net *net, struct sk_buff *skb, int nexthdr,\n\t\t\t      bool have_final);\n\nint __ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb);\nint ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb);\n\n \n\nvoid ipv6_push_nfrag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,\n\t\t\t  u8 *proto, struct in6_addr **daddr_p,\n\t\t\t  struct in6_addr *saddr);\nvoid ipv6_push_frag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,\n\t\t\t u8 *proto);\n\nint ipv6_skip_exthdr(const struct sk_buff *, int start, u8 *nexthdrp,\n\t\t     __be16 *frag_offp);\n\nbool ipv6_ext_hdr(u8 nexthdr);\n\nenum {\n\tIP6_FH_F_FRAG\t\t= (1 << 0),\n\tIP6_FH_F_AUTH\t\t= (1 << 1),\n\tIP6_FH_F_SKIP_RH\t= (1 << 2),\n};\n\n \nint ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset, int target,\n\t\t  unsigned short *fragoff, int *fragflg);\n\nint ipv6_find_tlv(const struct sk_buff *skb, int offset, int type);\n\nstruct in6_addr *fl6_update_dst(struct flowi6 *fl6,\n\t\t\t\tconst struct ipv6_txoptions *opt,\n\t\t\t\tstruct in6_addr *orig);\n\n \nDECLARE_STATIC_KEY_FALSE(ip6_min_hopcount);\n\nint do_ipv6_setsockopt(struct sock *sk, int level, int optname, sockptr_t optval,\n\t\t       unsigned int optlen);\nint ipv6_setsockopt(struct sock *sk, int level, int optname, sockptr_t optval,\n\t\t    unsigned int optlen);\nint do_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t       sockptr_t optval, sockptr_t optlen);\nint ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen);\n\nint __ip6_datagram_connect(struct sock *sk, struct sockaddr *addr,\n\t\t\t   int addr_len);\nint ip6_datagram_connect(struct sock *sk, struct sockaddr *addr, int addr_len);\nint ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *addr,\n\t\t\t\t int addr_len);\nint ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr);\nvoid ip6_datagram_release_cb(struct sock *sk);\n\nint ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len,\n\t\t    int *addr_len);\nint ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len,\n\t\t     int *addr_len);\nvoid ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err, __be16 port,\n\t\t     u32 info, u8 *payload);\nvoid ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info);\nvoid ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu);\n\nvoid inet6_cleanup_sock(struct sock *sk);\nvoid inet6_sock_destruct(struct sock *sk);\nint inet6_release(struct socket *sock);\nint inet6_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len);\nint inet6_bind_sk(struct sock *sk, struct sockaddr *uaddr, int addr_len);\nint inet6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t  int peer);\nint inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);\nint inet6_compat_ioctl(struct socket *sock, unsigned int cmd,\n\t\tunsigned long arg);\n\nint inet6_hash_connect(struct inet_timewait_death_row *death_row,\n\t\t\t      struct sock *sk);\nint inet6_sendmsg(struct socket *sock, struct msghdr *msg, size_t size);\nint inet6_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t  int flags);\n\n \nextern const struct proto_ops inet6_stream_ops;\nextern const struct proto_ops inet6_dgram_ops;\nextern const struct proto_ops inet6_sockraw_ops;\n\nstruct group_source_req;\nstruct group_filter;\n\nint ip6_mc_source(int add, int omode, struct sock *sk,\n\t\t  struct group_source_req *pgsr);\nint ip6_mc_msfilter(struct sock *sk, struct group_filter *gsf,\n\t\t  struct sockaddr_storage *list);\nint ip6_mc_msfget(struct sock *sk, struct group_filter *gsf,\n\t\t  sockptr_t optval, size_t ss_offset);\n\n#ifdef CONFIG_PROC_FS\nint ac6_proc_init(struct net *net);\nvoid ac6_proc_exit(struct net *net);\nint raw6_proc_init(void);\nvoid raw6_proc_exit(void);\nint tcp6_proc_init(struct net *net);\nvoid tcp6_proc_exit(struct net *net);\nint udp6_proc_init(struct net *net);\nvoid udp6_proc_exit(struct net *net);\nint udplite6_proc_init(void);\nvoid udplite6_proc_exit(void);\nint ipv6_misc_proc_init(void);\nvoid ipv6_misc_proc_exit(void);\nint snmp6_register_dev(struct inet6_dev *idev);\nint snmp6_unregister_dev(struct inet6_dev *idev);\n\n#else\nstatic inline int ac6_proc_init(struct net *net) { return 0; }\nstatic inline void ac6_proc_exit(struct net *net) { }\nstatic inline int snmp6_register_dev(struct inet6_dev *idev) { return 0; }\nstatic inline int snmp6_unregister_dev(struct inet6_dev *idev) { return 0; }\n#endif\n\n#ifdef CONFIG_SYSCTL\nstruct ctl_table *ipv6_icmp_sysctl_init(struct net *net);\nsize_t ipv6_icmp_sysctl_table_size(void);\nstruct ctl_table *ipv6_route_sysctl_init(struct net *net);\nsize_t ipv6_route_sysctl_table_size(struct net *net);\nint ipv6_sysctl_register(void);\nvoid ipv6_sysctl_unregister(void);\n#endif\n\nint ipv6_sock_mc_join(struct sock *sk, int ifindex,\n\t\t      const struct in6_addr *addr);\nint ipv6_sock_mc_join_ssm(struct sock *sk, int ifindex,\n\t\t\t  const struct in6_addr *addr, unsigned int mode);\nint ipv6_sock_mc_drop(struct sock *sk, int ifindex,\n\t\t      const struct in6_addr *addr);\n\nstatic inline int ip6_sock_set_v6only(struct sock *sk)\n{\n\tif (inet_sk(sk)->inet_num)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tsk->sk_ipv6only = true;\n\trelease_sock(sk);\n\treturn 0;\n}\n\nstatic inline void ip6_sock_set_recverr(struct sock *sk)\n{\n\tlock_sock(sk);\n\tinet6_sk(sk)->recverr = true;\n\trelease_sock(sk);\n}\n\nstatic inline int __ip6_sock_set_addr_preferences(struct sock *sk, int val)\n{\n\tunsigned int pref = 0;\n\tunsigned int prefmask = ~0;\n\n\t \n\tswitch (val & (IPV6_PREFER_SRC_PUBLIC |\n\t\t       IPV6_PREFER_SRC_TMP |\n\t\t       IPV6_PREFER_SRC_PUBTMP_DEFAULT)) {\n\tcase IPV6_PREFER_SRC_PUBLIC:\n\t\tpref |= IPV6_PREFER_SRC_PUBLIC;\n\t\tprefmask &= ~(IPV6_PREFER_SRC_PUBLIC |\n\t\t\t      IPV6_PREFER_SRC_TMP);\n\t\tbreak;\n\tcase IPV6_PREFER_SRC_TMP:\n\t\tpref |= IPV6_PREFER_SRC_TMP;\n\t\tprefmask &= ~(IPV6_PREFER_SRC_PUBLIC |\n\t\t\t      IPV6_PREFER_SRC_TMP);\n\t\tbreak;\n\tcase IPV6_PREFER_SRC_PUBTMP_DEFAULT:\n\t\tprefmask &= ~(IPV6_PREFER_SRC_PUBLIC |\n\t\t\t      IPV6_PREFER_SRC_TMP);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (val & (IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_COA)) {\n\tcase IPV6_PREFER_SRC_HOME:\n\t\tprefmask &= ~IPV6_PREFER_SRC_COA;\n\t\tbreak;\n\tcase IPV6_PREFER_SRC_COA:\n\t\tpref |= IPV6_PREFER_SRC_COA;\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (val & (IPV6_PREFER_SRC_CGA|IPV6_PREFER_SRC_NONCGA)) {\n\tcase IPV6_PREFER_SRC_CGA:\n\tcase IPV6_PREFER_SRC_NONCGA:\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tinet6_sk(sk)->srcprefs = (inet6_sk(sk)->srcprefs & prefmask) | pref;\n\treturn 0;\n}\n\nstatic inline int ip6_sock_set_addr_preferences(struct sock *sk, int val)\n{\n\tint ret;\n\n\tlock_sock(sk);\n\tret = __ip6_sock_set_addr_preferences(sk, val);\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic inline void ip6_sock_set_recvpktinfo(struct sock *sk)\n{\n\tlock_sock(sk);\n\tinet6_sk(sk)->rxopt.bits.rxinfo = true;\n\trelease_sock(sk);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}