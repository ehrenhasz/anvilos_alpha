{
  "module_name": "ndisc.h",
  "hash_id": "53e944512f2d7066396f8960a73ebf974ebb513f8f9b3a7a6099d44b2afaf899",
  "original_prompt": "Ingested from linux-6.6.14/include/net/ndisc.h",
  "human_readable_source": " \n#ifndef _NDISC_H\n#define _NDISC_H\n\n#include <net/ipv6_stubs.h>\n\n \n\n#define NDISC_ROUTER_SOLICITATION\t133\n#define NDISC_ROUTER_ADVERTISEMENT\t134\n#define NDISC_NEIGHBOUR_SOLICITATION\t135\n#define NDISC_NEIGHBOUR_ADVERTISEMENT\t136\n#define NDISC_REDIRECT\t\t\t137\n\n \n#define NDISC_NODETYPE_UNSPEC\t\t0\t \n#define NDISC_NODETYPE_HOST\t\t1\t \n#define NDISC_NODETYPE_NODEFAULT\t2\t \n#define NDISC_NODETYPE_DEFAULT\t\t3\t \n\n \n\nenum {\n\t__ND_OPT_PREFIX_INFO_END = 0,\n\tND_OPT_SOURCE_LL_ADDR = 1,\t \n\tND_OPT_TARGET_LL_ADDR = 2,\t \n\tND_OPT_PREFIX_INFO = 3,\t\t \n\tND_OPT_REDIRECT_HDR = 4,\t \n\tND_OPT_MTU = 5,\t\t\t \n\tND_OPT_NONCE = 14,               \n\t__ND_OPT_ARRAY_MAX,\n\tND_OPT_ROUTE_INFO = 24,\t\t \n\tND_OPT_RDNSS = 25,\t\t \n\tND_OPT_DNSSL = 31,\t\t \n\tND_OPT_6CO = 34,\t\t \n\tND_OPT_CAPTIVE_PORTAL = 37,\t \n\tND_OPT_PREF64 = 38,\t\t \n\t__ND_OPT_MAX\n};\n\n#define MAX_RTR_SOLICITATION_DELAY\tHZ\n\n#define ND_REACHABLE_TIME\t\t(30*HZ)\n#define ND_RETRANS_TIMER\t\tHZ\n\n#include <linux/compiler.h>\n#include <linux/icmpv6.h>\n#include <linux/in6.h>\n#include <linux/types.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/hash.h>\n\n#include <net/neighbour.h>\n\n \n#define ND_DEBUG 1\n\n#define ND_PRINTK(val, level, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (val <= ND_DEBUG)\t\t\t\t\t\\\n\t\tnet_##level##_ratelimited(fmt, ##__VA_ARGS__);\t\\\n} while (0)\n\nstruct ctl_table;\nstruct inet6_dev;\nstruct net_device;\nstruct net_proto_family;\nstruct sk_buff;\nstruct prefix_info;\n\nextern struct neigh_table nd_tbl;\n\nstruct nd_msg {\n        struct icmp6hdr\ticmph;\n        struct in6_addr\ttarget;\n\t__u8\t\topt[];\n};\n\nstruct rs_msg {\n\tstruct icmp6hdr\ticmph;\n\t__u8\t\topt[];\n};\n\nstruct ra_msg {\n        struct icmp6hdr\t\ticmph;\n\t__be32\t\t\treachable_time;\n\t__be32\t\t\tretrans_timer;\n};\n\nstruct rd_msg {\n\tstruct icmp6hdr icmph;\n\tstruct in6_addr\ttarget;\n\tstruct in6_addr\tdest;\n\t__u8\t\topt[];\n};\n\nstruct nd_opt_hdr {\n\t__u8\t\tnd_opt_type;\n\t__u8\t\tnd_opt_len;\n} __packed;\n\n \nstruct ndisc_options {\n\tstruct nd_opt_hdr *nd_opt_array[__ND_OPT_ARRAY_MAX];\n#ifdef CONFIG_IPV6_ROUTE_INFO\n\tstruct nd_opt_hdr *nd_opts_ri;\n\tstruct nd_opt_hdr *nd_opts_ri_end;\n#endif\n\tstruct nd_opt_hdr *nd_useropts;\n\tstruct nd_opt_hdr *nd_useropts_end;\n#if IS_ENABLED(CONFIG_IEEE802154_6LOWPAN)\n\tstruct nd_opt_hdr *nd_802154_opt_array[ND_OPT_TARGET_LL_ADDR + 1];\n#endif\n};\n\n#define nd_opts_src_lladdr\t\tnd_opt_array[ND_OPT_SOURCE_LL_ADDR]\n#define nd_opts_tgt_lladdr\t\tnd_opt_array[ND_OPT_TARGET_LL_ADDR]\n#define nd_opts_pi\t\t\tnd_opt_array[ND_OPT_PREFIX_INFO]\n#define nd_opts_pi_end\t\t\tnd_opt_array[__ND_OPT_PREFIX_INFO_END]\n#define nd_opts_rh\t\t\tnd_opt_array[ND_OPT_REDIRECT_HDR]\n#define nd_opts_mtu\t\t\tnd_opt_array[ND_OPT_MTU]\n#define nd_opts_nonce\t\t\tnd_opt_array[ND_OPT_NONCE]\n#define nd_802154_opts_src_lladdr\tnd_802154_opt_array[ND_OPT_SOURCE_LL_ADDR]\n#define nd_802154_opts_tgt_lladdr\tnd_802154_opt_array[ND_OPT_TARGET_LL_ADDR]\n\n#define NDISC_OPT_SPACE(len) (((len)+2+7)&~7)\n\nstruct ndisc_options *ndisc_parse_options(const struct net_device *dev,\n\t\t\t\t\t  u8 *opt, int opt_len,\n\t\t\t\t\t  struct ndisc_options *ndopts);\n\nvoid __ndisc_fill_addr_option(struct sk_buff *skb, int type, const void *data,\n\t\t\t      int data_len, int pad);\n\n#define NDISC_OPS_REDIRECT_DATA_SPACE\t2\n\n \nstruct ndisc_ops {\n\tint\t(*is_useropt)(u8 nd_opt_type);\n\tint\t(*parse_options)(const struct net_device *dev,\n\t\t\t\t struct nd_opt_hdr *nd_opt,\n\t\t\t\t struct ndisc_options *ndopts);\n\tvoid\t(*update)(const struct net_device *dev, struct neighbour *n,\n\t\t\t  u32 flags, u8 icmp6_type,\n\t\t\t  const struct ndisc_options *ndopts);\n\tint\t(*opt_addr_space)(const struct net_device *dev, u8 icmp6_type,\n\t\t\t\t  struct neighbour *neigh, u8 *ha_buf,\n\t\t\t\t  u8 **ha);\n\tvoid\t(*fill_addr_option)(const struct net_device *dev,\n\t\t\t\t    struct sk_buff *skb, u8 icmp6_type,\n\t\t\t\t    const u8 *ha);\n\tvoid\t(*prefix_rcv_add_addr)(struct net *net, struct net_device *dev,\n\t\t\t\t       const struct prefix_info *pinfo,\n\t\t\t\t       struct inet6_dev *in6_dev,\n\t\t\t\t       struct in6_addr *addr,\n\t\t\t\t       int addr_type, u32 addr_flags,\n\t\t\t\t       bool sllao, bool tokenized,\n\t\t\t\t       __u32 valid_lft, u32 prefered_lft,\n\t\t\t\t       bool dev_addr_generated);\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline int ndisc_ops_is_useropt(const struct net_device *dev,\n\t\t\t\t       u8 nd_opt_type)\n{\n\tif (dev->ndisc_ops && dev->ndisc_ops->is_useropt)\n\t\treturn dev->ndisc_ops->is_useropt(nd_opt_type);\n\telse\n\t\treturn 0;\n}\n\nstatic inline int ndisc_ops_parse_options(const struct net_device *dev,\n\t\t\t\t\t  struct nd_opt_hdr *nd_opt,\n\t\t\t\t\t  struct ndisc_options *ndopts)\n{\n\tif (dev->ndisc_ops && dev->ndisc_ops->parse_options)\n\t\treturn dev->ndisc_ops->parse_options(dev, nd_opt, ndopts);\n\telse\n\t\treturn 0;\n}\n\nstatic inline void ndisc_ops_update(const struct net_device *dev,\n\t\t\t\t\t  struct neighbour *n, u32 flags,\n\t\t\t\t\t  u8 icmp6_type,\n\t\t\t\t\t  const struct ndisc_options *ndopts)\n{\n\tif (dev->ndisc_ops && dev->ndisc_ops->update)\n\t\tdev->ndisc_ops->update(dev, n, flags, icmp6_type, ndopts);\n}\n\nstatic inline int ndisc_ops_opt_addr_space(const struct net_device *dev,\n\t\t\t\t\t   u8 icmp6_type)\n{\n\tif (dev->ndisc_ops && dev->ndisc_ops->opt_addr_space &&\n\t    icmp6_type != NDISC_REDIRECT)\n\t\treturn dev->ndisc_ops->opt_addr_space(dev, icmp6_type, NULL,\n\t\t\t\t\t\t      NULL, NULL);\n\telse\n\t\treturn 0;\n}\n\nstatic inline int ndisc_ops_redirect_opt_addr_space(const struct net_device *dev,\n\t\t\t\t\t\t    struct neighbour *neigh,\n\t\t\t\t\t\t    u8 *ha_buf, u8 **ha)\n{\n\tif (dev->ndisc_ops && dev->ndisc_ops->opt_addr_space)\n\t\treturn dev->ndisc_ops->opt_addr_space(dev, NDISC_REDIRECT,\n\t\t\t\t\t\t      neigh, ha_buf, ha);\n\telse\n\t\treturn 0;\n}\n\nstatic inline void ndisc_ops_fill_addr_option(const struct net_device *dev,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      u8 icmp6_type)\n{\n\tif (dev->ndisc_ops && dev->ndisc_ops->fill_addr_option &&\n\t    icmp6_type != NDISC_REDIRECT)\n\t\tdev->ndisc_ops->fill_addr_option(dev, skb, icmp6_type, NULL);\n}\n\nstatic inline void ndisc_ops_fill_redirect_addr_option(const struct net_device *dev,\n\t\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t\t       const u8 *ha)\n{\n\tif (dev->ndisc_ops && dev->ndisc_ops->fill_addr_option)\n\t\tdev->ndisc_ops->fill_addr_option(dev, skb, NDISC_REDIRECT, ha);\n}\n\nstatic inline void ndisc_ops_prefix_rcv_add_addr(struct net *net,\n\t\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t\t const struct prefix_info *pinfo,\n\t\t\t\t\t\t struct inet6_dev *in6_dev,\n\t\t\t\t\t\t struct in6_addr *addr,\n\t\t\t\t\t\t int addr_type, u32 addr_flags,\n\t\t\t\t\t\t bool sllao, bool tokenized,\n\t\t\t\t\t\t __u32 valid_lft,\n\t\t\t\t\t\t u32 prefered_lft,\n\t\t\t\t\t\t bool dev_addr_generated)\n{\n\tif (dev->ndisc_ops && dev->ndisc_ops->prefix_rcv_add_addr)\n\t\tdev->ndisc_ops->prefix_rcv_add_addr(net, dev, pinfo, in6_dev,\n\t\t\t\t\t\t    addr, addr_type,\n\t\t\t\t\t\t    addr_flags, sllao,\n\t\t\t\t\t\t    tokenized, valid_lft,\n\t\t\t\t\t\t    prefered_lft,\n\t\t\t\t\t\t    dev_addr_generated);\n}\n#endif\n\n \nstatic inline int ndisc_addr_option_pad(unsigned short type)\n{\n\tswitch (type) {\n\tcase ARPHRD_INFINIBAND: return 2;\n\tdefault:                return 0;\n\t}\n}\n\nstatic inline int __ndisc_opt_addr_space(unsigned char addr_len, int pad)\n{\n\treturn NDISC_OPT_SPACE(addr_len + pad);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline int ndisc_opt_addr_space(struct net_device *dev, u8 icmp6_type)\n{\n\treturn __ndisc_opt_addr_space(dev->addr_len,\n\t\t\t\t      ndisc_addr_option_pad(dev->type)) +\n\t\tndisc_ops_opt_addr_space(dev, icmp6_type);\n}\n\nstatic inline int ndisc_redirect_opt_addr_space(struct net_device *dev,\n\t\t\t\t\t\tstruct neighbour *neigh,\n\t\t\t\t\t\tu8 *ops_data_buf,\n\t\t\t\t\t\tu8 **ops_data)\n{\n\treturn __ndisc_opt_addr_space(dev->addr_len,\n\t\t\t\t      ndisc_addr_option_pad(dev->type)) +\n\t\tndisc_ops_redirect_opt_addr_space(dev, neigh, ops_data_buf,\n\t\t\t\t\t\t  ops_data);\n}\n#endif\n\nstatic inline u8 *__ndisc_opt_addr_data(struct nd_opt_hdr *p,\n\t\t\t\t\tunsigned char addr_len, int prepad)\n{\n\tu8 *lladdr = (u8 *)(p + 1);\n\tint lladdrlen = p->nd_opt_len << 3;\n\tif (lladdrlen != __ndisc_opt_addr_space(addr_len, prepad))\n\t\treturn NULL;\n\treturn lladdr + prepad;\n}\n\nstatic inline u8 *ndisc_opt_addr_data(struct nd_opt_hdr *p,\n\t\t\t\t      struct net_device *dev)\n{\n\treturn __ndisc_opt_addr_data(p, dev->addr_len,\n\t\t\t\t     ndisc_addr_option_pad(dev->type));\n}\n\nstatic inline u32 ndisc_hashfn(const void *pkey, const struct net_device *dev, __u32 *hash_rnd)\n{\n\tconst u32 *p32 = pkey;\n\n\treturn (((p32[0] ^ hash32_ptr(dev)) * hash_rnd[0]) +\n\t\t(p32[1] * hash_rnd[1]) +\n\t\t(p32[2] * hash_rnd[2]) +\n\t\t(p32[3] * hash_rnd[3]));\n}\n\nstatic inline struct neighbour *__ipv6_neigh_lookup_noref(struct net_device *dev, const void *pkey)\n{\n\treturn ___neigh_lookup_noref(&nd_tbl, neigh_key_eq128, ndisc_hashfn, pkey, dev);\n}\n\nstatic inline\nstruct neighbour *__ipv6_neigh_lookup_noref_stub(struct net_device *dev,\n\t\t\t\t\t\t const void *pkey)\n{\n\treturn ___neigh_lookup_noref(ipv6_stub->nd_tbl, neigh_key_eq128,\n\t\t\t\t     ndisc_hashfn, pkey, dev);\n}\n\nstatic inline struct neighbour *__ipv6_neigh_lookup(struct net_device *dev, const void *pkey)\n{\n\tstruct neighbour *n;\n\n\trcu_read_lock();\n\tn = __ipv6_neigh_lookup_noref(dev, pkey);\n\tif (n && !refcount_inc_not_zero(&n->refcnt))\n\t\tn = NULL;\n\trcu_read_unlock();\n\n\treturn n;\n}\n\nstatic inline void __ipv6_confirm_neigh(struct net_device *dev,\n\t\t\t\t\tconst void *pkey)\n{\n\tstruct neighbour *n;\n\n\trcu_read_lock();\n\tn = __ipv6_neigh_lookup_noref(dev, pkey);\n\tneigh_confirm(n);\n\trcu_read_unlock();\n}\n\nstatic inline void __ipv6_confirm_neigh_stub(struct net_device *dev,\n\t\t\t\t\t     const void *pkey)\n{\n\tstruct neighbour *n;\n\n\trcu_read_lock();\n\tn = __ipv6_neigh_lookup_noref_stub(dev, pkey);\n\tneigh_confirm(n);\n\trcu_read_unlock();\n}\n\n \nstatic inline struct neighbour *ip_neigh_gw6(struct net_device *dev,\n\t\t\t\t\t     const void *addr)\n{\n\tstruct neighbour *neigh;\n\n\tneigh = __ipv6_neigh_lookup_noref_stub(dev, addr);\n\tif (unlikely(!neigh))\n\t\tneigh = __neigh_create(ipv6_stub->nd_tbl, addr, dev, false);\n\n\treturn neigh;\n}\n\nint ndisc_init(void);\nint ndisc_late_init(void);\n\nvoid ndisc_late_cleanup(void);\nvoid ndisc_cleanup(void);\n\nenum skb_drop_reason ndisc_rcv(struct sk_buff *skb);\n\nstruct sk_buff *ndisc_ns_create(struct net_device *dev, const struct in6_addr *solicit,\n\t\t\t\tconst struct in6_addr *saddr, u64 nonce);\nvoid ndisc_send_ns(struct net_device *dev, const struct in6_addr *solicit,\n\t\t   const struct in6_addr *daddr, const struct in6_addr *saddr,\n\t\t   u64 nonce);\n\nvoid ndisc_send_skb(struct sk_buff *skb, const struct in6_addr *daddr,\n\t\t    const struct in6_addr *saddr);\n\nvoid ndisc_send_rs(struct net_device *dev,\n\t\t   const struct in6_addr *saddr, const struct in6_addr *daddr);\nvoid ndisc_send_na(struct net_device *dev, const struct in6_addr *daddr,\n\t\t   const struct in6_addr *solicited_addr,\n\t\t   bool router, bool solicited, bool override, bool inc_opt);\n\nvoid ndisc_send_redirect(struct sk_buff *skb, const struct in6_addr *target);\n\nint ndisc_mc_map(const struct in6_addr *addr, char *buf, struct net_device *dev,\n\t\t int dir);\n\nvoid ndisc_update(const struct net_device *dev, struct neighbour *neigh,\n\t\t  const u8 *lladdr, u8 new, u32 flags, u8 icmp6_type,\n\t\t  struct ndisc_options *ndopts);\n\n \nint igmp6_init(void);\nint igmp6_late_init(void);\n\nvoid igmp6_cleanup(void);\nvoid igmp6_late_cleanup(void);\n\nvoid igmp6_event_query(struct sk_buff *skb);\n\nvoid igmp6_event_report(struct sk_buff *skb);\n\n\n#ifdef CONFIG_SYSCTL\nint ndisc_ifinfo_sysctl_change(struct ctl_table *ctl, int write,\n\t\t\t       void *buffer, size_t *lenp, loff_t *ppos);\n#endif\n\nvoid inet6_ifinfo_notify(int event, struct inet6_dev *idev);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}