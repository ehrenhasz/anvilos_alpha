{
  "module_name": "dst_metadata.h",
  "hash_id": "fc5bfa77f5b9652c62948e1396de06e3c180af36df863142533ffc42206f2df6",
  "original_prompt": "Ingested from linux-6.6.14/include/net/dst_metadata.h",
  "human_readable_source": " \n#ifndef __NET_DST_METADATA_H\n#define __NET_DST_METADATA_H 1\n\n#include <linux/skbuff.h>\n#include <net/ip_tunnels.h>\n#include <net/macsec.h>\n#include <net/dst.h>\n\nenum metadata_type {\n\tMETADATA_IP_TUNNEL,\n\tMETADATA_HW_PORT_MUX,\n\tMETADATA_MACSEC,\n\tMETADATA_XFRM,\n};\n\nstruct hw_port_info {\n\tstruct net_device *lower_dev;\n\tu32 port_id;\n};\n\nstruct macsec_info {\n\tsci_t sci;\n};\n\nstruct xfrm_md_info {\n\tu32 if_id;\n\tint link;\n\tstruct dst_entry *dst_orig;\n};\n\nstruct metadata_dst {\n\tstruct dst_entry\t\tdst;\n\tenum metadata_type\t\ttype;\n\tunion {\n\t\tstruct ip_tunnel_info\ttun_info;\n\t\tstruct hw_port_info\tport_info;\n\t\tstruct macsec_info\tmacsec_info;\n\t\tstruct xfrm_md_info\txfrm_info;\n\t} u;\n};\n\nstatic inline struct metadata_dst *skb_metadata_dst(const struct sk_buff *skb)\n{\n\tstruct metadata_dst *md_dst = (struct metadata_dst *) skb_dst(skb);\n\n\tif (md_dst && md_dst->dst.flags & DST_METADATA)\n\t\treturn md_dst;\n\n\treturn NULL;\n}\n\nstatic inline struct ip_tunnel_info *\nskb_tunnel_info(const struct sk_buff *skb)\n{\n\tstruct metadata_dst *md_dst = skb_metadata_dst(skb);\n\tstruct dst_entry *dst;\n\n\tif (md_dst && md_dst->type == METADATA_IP_TUNNEL)\n\t\treturn &md_dst->u.tun_info;\n\n\tdst = skb_dst(skb);\n\tif (dst && dst->lwtstate &&\n\t    (dst->lwtstate->type == LWTUNNEL_ENCAP_IP ||\n\t     dst->lwtstate->type == LWTUNNEL_ENCAP_IP6))\n\t\treturn lwt_tun_info(dst->lwtstate);\n\n\treturn NULL;\n}\n\nstatic inline struct xfrm_md_info *lwt_xfrm_info(struct lwtunnel_state *lwt)\n{\n\treturn (struct xfrm_md_info *)lwt->data;\n}\n\nstatic inline struct xfrm_md_info *skb_xfrm_md_info(const struct sk_buff *skb)\n{\n\tstruct metadata_dst *md_dst = skb_metadata_dst(skb);\n\tstruct dst_entry *dst;\n\n\tif (md_dst && md_dst->type == METADATA_XFRM)\n\t\treturn &md_dst->u.xfrm_info;\n\n\tdst = skb_dst(skb);\n\tif (dst && dst->lwtstate &&\n\t    dst->lwtstate->type == LWTUNNEL_ENCAP_XFRM)\n\t\treturn lwt_xfrm_info(dst->lwtstate);\n\n\treturn NULL;\n}\n\nstatic inline bool skb_valid_dst(const struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\treturn dst && !(dst->flags & DST_METADATA);\n}\n\nstatic inline int skb_metadata_dst_cmp(const struct sk_buff *skb_a,\n\t\t\t\t       const struct sk_buff *skb_b)\n{\n\tconst struct metadata_dst *a, *b;\n\n\tif (!(skb_a->_skb_refdst | skb_b->_skb_refdst))\n\t\treturn 0;\n\n\ta = (const struct metadata_dst *) skb_dst(skb_a);\n\tb = (const struct metadata_dst *) skb_dst(skb_b);\n\n\tif (!a != !b || a->type != b->type)\n\t\treturn 1;\n\n\tswitch (a->type) {\n\tcase METADATA_HW_PORT_MUX:\n\t\treturn memcmp(&a->u.port_info, &b->u.port_info,\n\t\t\t      sizeof(a->u.port_info));\n\tcase METADATA_IP_TUNNEL:\n\t\treturn memcmp(&a->u.tun_info, &b->u.tun_info,\n\t\t\t      sizeof(a->u.tun_info) +\n\t\t\t\t\t a->u.tun_info.options_len);\n\tcase METADATA_MACSEC:\n\t\treturn memcmp(&a->u.macsec_info, &b->u.macsec_info,\n\t\t\t      sizeof(a->u.macsec_info));\n\tcase METADATA_XFRM:\n\t\treturn memcmp(&a->u.xfrm_info, &b->u.xfrm_info,\n\t\t\t      sizeof(a->u.xfrm_info));\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nvoid metadata_dst_free(struct metadata_dst *);\nstruct metadata_dst *metadata_dst_alloc(u8 optslen, enum metadata_type type,\n\t\t\t\t\tgfp_t flags);\nvoid metadata_dst_free_percpu(struct metadata_dst __percpu *md_dst);\nstruct metadata_dst __percpu *\nmetadata_dst_alloc_percpu(u8 optslen, enum metadata_type type, gfp_t flags);\n\nstatic inline struct metadata_dst *tun_rx_dst(int md_size)\n{\n\tstruct metadata_dst *tun_dst;\n\n\ttun_dst = metadata_dst_alloc(md_size, METADATA_IP_TUNNEL, GFP_ATOMIC);\n\tif (!tun_dst)\n\t\treturn NULL;\n\n\ttun_dst->u.tun_info.options_len = 0;\n\ttun_dst->u.tun_info.mode = 0;\n\treturn tun_dst;\n}\n\nstatic inline struct metadata_dst *tun_dst_unclone(struct sk_buff *skb)\n{\n\tstruct metadata_dst *md_dst = skb_metadata_dst(skb);\n\tint md_size;\n\tstruct metadata_dst *new_md;\n\n\tif (!md_dst || md_dst->type != METADATA_IP_TUNNEL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmd_size = md_dst->u.tun_info.options_len;\n\tnew_md = metadata_dst_alloc(md_size, METADATA_IP_TUNNEL, GFP_ATOMIC);\n\tif (!new_md)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(&new_md->u.tun_info, &md_dst->u.tun_info,\n\t       sizeof(struct ip_tunnel_info) + md_size);\n#ifdef CONFIG_DST_CACHE\n\t \n\tif (new_md->u.tun_info.dst_cache.cache) {\n\t\tint ret;\n\n\t\tret = dst_cache_init(&new_md->u.tun_info.dst_cache, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tmetadata_dst_free(new_md);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n#endif\n\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, &new_md->dst);\n\treturn new_md;\n}\n\nstatic inline struct ip_tunnel_info *skb_tunnel_info_unclone(struct sk_buff *skb)\n{\n\tstruct metadata_dst *dst;\n\n\tdst = tun_dst_unclone(skb);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\n\treturn &dst->u.tun_info;\n}\n\nstatic inline struct metadata_dst *__ip_tun_set_dst(__be32 saddr,\n\t\t\t\t\t\t    __be32 daddr,\n\t\t\t\t\t\t    __u8 tos, __u8 ttl,\n\t\t\t\t\t\t    __be16 tp_dst,\n\t\t\t\t\t\t    __be16 flags,\n\t\t\t\t\t\t    __be64 tunnel_id,\n\t\t\t\t\t\t    int md_size)\n{\n\tstruct metadata_dst *tun_dst;\n\n\ttun_dst = tun_rx_dst(md_size);\n\tif (!tun_dst)\n\t\treturn NULL;\n\n\tip_tunnel_key_init(&tun_dst->u.tun_info.key,\n\t\t\t   saddr, daddr, tos, ttl,\n\t\t\t   0, 0, tp_dst, tunnel_id, flags);\n\treturn tun_dst;\n}\n\nstatic inline struct metadata_dst *ip_tun_rx_dst(struct sk_buff *skb,\n\t\t\t\t\t\t __be16 flags,\n\t\t\t\t\t\t __be64 tunnel_id,\n\t\t\t\t\t\t int md_size)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\n\treturn __ip_tun_set_dst(iph->saddr, iph->daddr, iph->tos, iph->ttl,\n\t\t\t\t0, flags, tunnel_id, md_size);\n}\n\nstatic inline struct metadata_dst *__ipv6_tun_set_dst(const struct in6_addr *saddr,\n\t\t\t\t\t\t      const struct in6_addr *daddr,\n\t\t\t\t\t\t      __u8 tos, __u8 ttl,\n\t\t\t\t\t\t      __be16 tp_dst,\n\t\t\t\t\t\t      __be32 label,\n\t\t\t\t\t\t      __be16 flags,\n\t\t\t\t\t\t      __be64 tunnel_id,\n\t\t\t\t\t\t      int md_size)\n{\n\tstruct metadata_dst *tun_dst;\n\tstruct ip_tunnel_info *info;\n\n\ttun_dst = tun_rx_dst(md_size);\n\tif (!tun_dst)\n\t\treturn NULL;\n\n\tinfo = &tun_dst->u.tun_info;\n\tinfo->mode = IP_TUNNEL_INFO_IPV6;\n\tinfo->key.tun_flags = flags;\n\tinfo->key.tun_id = tunnel_id;\n\tinfo->key.tp_src = 0;\n\tinfo->key.tp_dst = tp_dst;\n\n\tinfo->key.u.ipv6.src = *saddr;\n\tinfo->key.u.ipv6.dst = *daddr;\n\n\tinfo->key.tos = tos;\n\tinfo->key.ttl = ttl;\n\tinfo->key.label = label;\n\n\treturn tun_dst;\n}\n\nstatic inline struct metadata_dst *ipv6_tun_rx_dst(struct sk_buff *skb,\n\t\t\t\t\t\t   __be16 flags,\n\t\t\t\t\t\t   __be64 tunnel_id,\n\t\t\t\t\t\t   int md_size)\n{\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\n\treturn __ipv6_tun_set_dst(&ip6h->saddr, &ip6h->daddr,\n\t\t\t\t  ipv6_get_dsfield(ip6h), ip6h->hop_limit,\n\t\t\t\t  0, ip6_flowlabel(ip6h), flags, tunnel_id,\n\t\t\t\t  md_size);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}