{
  "module_name": "udp.h",
  "hash_id": "fab29b0b188a25a5ec03e71fa3c6ece56fce2d49f7e2fa0aad26d1528524a337",
  "original_prompt": "Ingested from linux-6.6.14/include/net/udp.h",
  "human_readable_source": " \n \n#ifndef _UDP_H\n#define _UDP_H\n\n#include <linux/list.h>\n#include <linux/bug.h>\n#include <net/inet_sock.h>\n#include <net/gso.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/seq_file.h>\n#include <linux/poll.h>\n#include <linux/indirect_call_wrapper.h>\n\n \nstruct udp_skb_cb {\n\tunion {\n\t\tstruct inet_skb_parm\th4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct inet6_skb_parm\th6;\n#endif\n\t} header;\n\t__u16\t\tcscov;\n\t__u8\t\tpartial_cov;\n};\n#define UDP_SKB_CB(__skb)\t((struct udp_skb_cb *)((__skb)->cb))\n\n \nstruct udp_hslot {\n\tstruct hlist_head\thead;\n\tint\t\t\tcount;\n\tspinlock_t\t\tlock;\n} __attribute__((aligned(2 * sizeof(long))));\n\n \nstruct udp_table {\n\tstruct udp_hslot\t*hash;\n\tstruct udp_hslot\t*hash2;\n\tunsigned int\t\tmask;\n\tunsigned int\t\tlog;\n};\nextern struct udp_table udp_table;\nvoid udp_table_init(struct udp_table *, const char *);\nstatic inline struct udp_hslot *udp_hashslot(struct udp_table *table,\n\t\t\t\t\t     struct net *net, unsigned int num)\n{\n\treturn &table->hash[udp_hashfn(net, num, table->mask)];\n}\n \nstatic inline struct udp_hslot *udp_hashslot2(struct udp_table *table,\n\t\t\t\t\t      unsigned int hash)\n{\n\treturn &table->hash2[hash & table->mask];\n}\n\nextern struct proto udp_prot;\n\nextern atomic_long_t udp_memory_allocated;\nDECLARE_PER_CPU(int, udp_memory_per_cpu_fw_alloc);\n\n \nextern long sysctl_udp_mem[3];\nextern int sysctl_udp_rmem_min;\nextern int sysctl_udp_wmem_min;\n\nstruct sk_buff;\n\n \nstatic inline __sum16 __udp_lib_checksum_complete(struct sk_buff *skb)\n{\n\treturn (UDP_SKB_CB(skb)->cscov == skb->len ?\n\t\t__skb_checksum_complete(skb) :\n\t\t__skb_checksum_complete_head(skb, UDP_SKB_CB(skb)->cscov));\n}\n\nstatic inline int udp_lib_checksum_complete(struct sk_buff *skb)\n{\n\treturn !skb_csum_unnecessary(skb) &&\n\t\t__udp_lib_checksum_complete(skb);\n}\n\n \nstatic inline __wsum udp_csum_outgoing(struct sock *sk, struct sk_buff *skb)\n{\n\t__wsum csum = csum_partial(skb_transport_header(skb),\n\t\t\t\t   sizeof(struct udphdr), 0);\n\tskb_queue_walk(&sk->sk_write_queue, skb) {\n\t\tcsum = csum_add(csum, skb->csum);\n\t}\n\treturn csum;\n}\n\nstatic inline __wsum udp_csum(struct sk_buff *skb)\n{\n\t__wsum csum = csum_partial(skb_transport_header(skb),\n\t\t\t\t   sizeof(struct udphdr), skb->csum);\n\n\tfor (skb = skb_shinfo(skb)->frag_list; skb; skb = skb->next) {\n\t\tcsum = csum_add(csum, skb->csum);\n\t}\n\treturn csum;\n}\n\nstatic inline __sum16 udp_v4_check(int len, __be32 saddr,\n\t\t\t\t   __be32 daddr, __wsum base)\n{\n\treturn csum_tcpudp_magic(saddr, daddr, len, IPPROTO_UDP, base);\n}\n\nvoid udp_set_csum(bool nocheck, struct sk_buff *skb,\n\t\t  __be32 saddr, __be32 daddr, int len);\n\nstatic inline void udp_csum_pull_header(struct sk_buff *skb)\n{\n\tif (!skb->csum_valid && skb->ip_summed == CHECKSUM_NONE)\n\t\tskb->csum = csum_partial(skb->data, sizeof(struct udphdr),\n\t\t\t\t\t skb->csum);\n\tskb_pull_rcsum(skb, sizeof(struct udphdr));\n\tUDP_SKB_CB(skb)->cscov -= sizeof(struct udphdr);\n}\n\ntypedef struct sock *(*udp_lookup_t)(const struct sk_buff *skb, __be16 sport,\n\t\t\t\t     __be16 dport);\n\nvoid udp_v6_early_demux(struct sk_buff *skb);\nINDIRECT_CALLABLE_DECLARE(int udpv6_rcv(struct sk_buff *));\n\nstruct sk_buff *__udp_gso_segment(struct sk_buff *gso_skb,\n\t\t\t\t  netdev_features_t features, bool is_ipv6);\n\nstatic inline void udp_lib_init_sock(struct sock *sk)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\n\tskb_queue_head_init(&up->reader_queue);\n\tup->forward_threshold = sk->sk_rcvbuf >> 2;\n\tset_bit(SOCK_CUSTOM_SOCKOPT, &sk->sk_socket->flags);\n}\n\n \nstatic inline int udp_lib_hash(struct sock *sk)\n{\n\tBUG();\n\treturn 0;\n}\n\nvoid udp_lib_unhash(struct sock *sk);\nvoid udp_lib_rehash(struct sock *sk, u16 new_hash);\n\nstatic inline void udp_lib_close(struct sock *sk, long timeout)\n{\n\tsk_common_release(sk);\n}\n\nint udp_lib_get_port(struct sock *sk, unsigned short snum,\n\t\t     unsigned int hash2_nulladdr);\n\nu32 udp_flow_hashrnd(void);\n\nstatic inline __be16 udp_flow_src_port(struct net *net, struct sk_buff *skb,\n\t\t\t\t       int min, int max, bool use_eth)\n{\n\tu32 hash;\n\n\tif (min >= max) {\n\t\t \n\t\tinet_get_local_port_range(net, &min, &max);\n\t}\n\n\thash = skb_get_hash(skb);\n\tif (unlikely(!hash)) {\n\t\tif (use_eth) {\n\t\t\t \n\t\t\thash = jhash(skb->data, 2 * ETH_ALEN,\n\t\t\t\t     (__force u32) skb->protocol);\n\t\t} else {\n\t\t\t \n\t\t\thash = udp_flow_hashrnd();\n\t\t}\n\t}\n\n\t \n\thash ^= hash << 16;\n\n\treturn htons((((u64) hash * (max - min)) >> 32) + min);\n}\n\nstatic inline int udp_rqueue_get(struct sock *sk)\n{\n\treturn sk_rmem_alloc_get(sk) - READ_ONCE(udp_sk(sk)->forward_deficit);\n}\n\nstatic inline bool udp_sk_bound_dev_eq(struct net *net, int bound_dev_if,\n\t\t\t\t       int dif, int sdif)\n{\n#if IS_ENABLED(CONFIG_NET_L3_MASTER_DEV)\n\treturn inet_bound_dev_eq(!!READ_ONCE(net->ipv4.sysctl_udp_l3mdev_accept),\n\t\t\t\t bound_dev_if, dif, sdif);\n#else\n\treturn inet_bound_dev_eq(true, bound_dev_if, dif, sdif);\n#endif\n}\n\n \nvoid udp_destruct_common(struct sock *sk);\nvoid skb_consume_udp(struct sock *sk, struct sk_buff *skb, int len);\nint __udp_enqueue_schedule_skb(struct sock *sk, struct sk_buff *skb);\nvoid udp_skb_destructor(struct sock *sk, struct sk_buff *skb);\nstruct sk_buff *__skb_recv_udp(struct sock *sk, unsigned int flags, int *off,\n\t\t\t       int *err);\nstatic inline struct sk_buff *skb_recv_udp(struct sock *sk, unsigned int flags,\n\t\t\t\t\t   int *err)\n{\n\tint off = 0;\n\n\treturn __skb_recv_udp(sk, flags, &off, err);\n}\n\nint udp_v4_early_demux(struct sk_buff *skb);\nbool udp_sk_rx_dst_set(struct sock *sk, struct dst_entry *dst);\nint udp_err(struct sk_buff *, u32);\nint udp_abort(struct sock *sk, int err);\nint udp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len);\nvoid udp_splice_eof(struct socket *sock);\nint udp_push_pending_frames(struct sock *sk);\nvoid udp_flush_pending_frames(struct sock *sk);\nint udp_cmsg_send(struct sock *sk, struct msghdr *msg, u16 *gso_size);\nvoid udp4_hwcsum(struct sk_buff *skb, __be32 src, __be32 dst);\nint udp_rcv(struct sk_buff *skb);\nint udp_ioctl(struct sock *sk, int cmd, int *karg);\nint udp_init_sock(struct sock *sk);\nint udp_pre_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);\nint __udp_disconnect(struct sock *sk, int flags);\nint udp_disconnect(struct sock *sk, int flags);\n__poll_t udp_poll(struct file *file, struct socket *sock, poll_table *wait);\nstruct sk_buff *skb_udp_tunnel_segment(struct sk_buff *skb,\n\t\t\t\t       netdev_features_t features,\n\t\t\t\t       bool is_ipv6);\nint udp_lib_getsockopt(struct sock *sk, int level, int optname,\n\t\t       char __user *optval, int __user *optlen);\nint udp_lib_setsockopt(struct sock *sk, int level, int optname,\n\t\t       sockptr_t optval, unsigned int optlen,\n\t\t       int (*push_pending_frames)(struct sock *));\nstruct sock *udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,\n\t\t\t     __be32 daddr, __be16 dport, int dif);\nstruct sock *__udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,\n\t\t\t       __be32 daddr, __be16 dport, int dif, int sdif,\n\t\t\t       struct udp_table *tbl, struct sk_buff *skb);\nstruct sock *udp4_lib_lookup_skb(const struct sk_buff *skb,\n\t\t\t\t __be16 sport, __be16 dport);\nstruct sock *udp6_lib_lookup(struct net *net,\n\t\t\t     const struct in6_addr *saddr, __be16 sport,\n\t\t\t     const struct in6_addr *daddr, __be16 dport,\n\t\t\t     int dif);\nstruct sock *__udp6_lib_lookup(struct net *net,\n\t\t\t       const struct in6_addr *saddr, __be16 sport,\n\t\t\t       const struct in6_addr *daddr, __be16 dport,\n\t\t\t       int dif, int sdif, struct udp_table *tbl,\n\t\t\t       struct sk_buff *skb);\nstruct sock *udp6_lib_lookup_skb(const struct sk_buff *skb,\n\t\t\t\t __be16 sport, __be16 dport);\nint udp_read_skb(struct sock *sk, skb_read_actor_t recv_actor);\n\n \nstruct udp_dev_scratch {\n\t \n\tu32 _tsize_state;\n\n#if BITS_PER_LONG == 64\n\t \n\tu16 len;\n\tbool is_linear;\n\tbool csum_unnecessary;\n#endif\n};\n\nstatic inline struct udp_dev_scratch *udp_skb_scratch(struct sk_buff *skb)\n{\n\treturn (struct udp_dev_scratch *)&skb->dev_scratch;\n}\n\n#if BITS_PER_LONG == 64\nstatic inline unsigned int udp_skb_len(struct sk_buff *skb)\n{\n\treturn udp_skb_scratch(skb)->len;\n}\n\nstatic inline bool udp_skb_csum_unnecessary(struct sk_buff *skb)\n{\n\treturn udp_skb_scratch(skb)->csum_unnecessary;\n}\n\nstatic inline bool udp_skb_is_linear(struct sk_buff *skb)\n{\n\treturn udp_skb_scratch(skb)->is_linear;\n}\n\n#else\nstatic inline unsigned int udp_skb_len(struct sk_buff *skb)\n{\n\treturn skb->len;\n}\n\nstatic inline bool udp_skb_csum_unnecessary(struct sk_buff *skb)\n{\n\treturn skb_csum_unnecessary(skb);\n}\n\nstatic inline bool udp_skb_is_linear(struct sk_buff *skb)\n{\n\treturn !skb_is_nonlinear(skb);\n}\n#endif\n\nstatic inline int copy_linear_skb(struct sk_buff *skb, int len, int off,\n\t\t\t\t  struct iov_iter *to)\n{\n\tint n;\n\n\tn = copy_to_iter(skb->data + off, len, to);\n\tif (n == len)\n\t\treturn 0;\n\n\tiov_iter_revert(to, n);\n\treturn -EFAULT;\n}\n\n \n#define UDP_INC_STATS(net, field, is_udplite)\t\t      do { \\\n\tif (is_udplite) SNMP_INC_STATS((net)->mib.udplite_statistics, field);       \\\n\telse\t\tSNMP_INC_STATS((net)->mib.udp_statistics, field);  }  while(0)\n#define __UDP_INC_STATS(net, field, is_udplite) \t      do { \\\n\tif (is_udplite) __SNMP_INC_STATS((net)->mib.udplite_statistics, field);         \\\n\telse\t\t__SNMP_INC_STATS((net)->mib.udp_statistics, field);    }  while(0)\n\n#define __UDP6_INC_STATS(net, field, is_udplite)\t    do { \\\n\tif (is_udplite) __SNMP_INC_STATS((net)->mib.udplite_stats_in6, field);\\\n\telse\t\t__SNMP_INC_STATS((net)->mib.udp_stats_in6, field);  \\\n} while(0)\n#define UDP6_INC_STATS(net, field, __lite)\t\t    do { \\\n\tif (__lite) SNMP_INC_STATS((net)->mib.udplite_stats_in6, field);  \\\n\telse\t    SNMP_INC_STATS((net)->mib.udp_stats_in6, field);      \\\n} while(0)\n\n#if IS_ENABLED(CONFIG_IPV6)\n#define __UDPX_MIB(sk, ipv4)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tipv4 ? (IS_UDPLITE(sk) ? sock_net(sk)->mib.udplite_statistics :\t\\\n\t\t\t\t sock_net(sk)->mib.udp_statistics) :\t\\\n\t\t(IS_UDPLITE(sk) ? sock_net(sk)->mib.udplite_stats_in6 :\t\\\n\t\t\t\t sock_net(sk)->mib.udp_stats_in6);\t\\\n})\n#else\n#define __UDPX_MIB(sk, ipv4)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tIS_UDPLITE(sk) ? sock_net(sk)->mib.udplite_statistics :\t\t\\\n\t\t\t sock_net(sk)->mib.udp_statistics;\t\t\\\n})\n#endif\n\n#define __UDPX_INC_STATS(sk, field) \\\n\t__SNMP_INC_STATS(__UDPX_MIB(sk, (sk)->sk_family == AF_INET), field)\n\n#ifdef CONFIG_PROC_FS\nstruct udp_seq_afinfo {\n\tsa_family_t\t\t\tfamily;\n\tstruct udp_table\t\t*udp_table;\n};\n\nstruct udp_iter_state {\n\tstruct seq_net_private  p;\n\tint\t\t\tbucket;\n};\n\nvoid *udp_seq_start(struct seq_file *seq, loff_t *pos);\nvoid *udp_seq_next(struct seq_file *seq, void *v, loff_t *pos);\nvoid udp_seq_stop(struct seq_file *seq, void *v);\n\nextern const struct seq_operations udp_seq_ops;\nextern const struct seq_operations udp6_seq_ops;\n\nint udp4_proc_init(void);\nvoid udp4_proc_exit(void);\n#endif  \n\nint udpv4_offload_init(void);\n\nvoid udp_init(void);\n\nDECLARE_STATIC_KEY_FALSE(udp_encap_needed_key);\nvoid udp_encap_enable(void);\nvoid udp_encap_disable(void);\n#if IS_ENABLED(CONFIG_IPV6)\nDECLARE_STATIC_KEY_FALSE(udpv6_encap_needed_key);\nvoid udpv6_encap_enable(void);\n#endif\n\nstatic inline struct sk_buff *udp_rcv_segment(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb, bool ipv4)\n{\n\tnetdev_features_t features = NETIF_F_SG;\n\tstruct sk_buff *segs;\n\n\t \n\tif (!inet_get_convert_csum(sk))\n\t\tfeatures |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\n\t \n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\n\t \n\tsegs = __skb_gso_segment(skb, features, false);\n\tif (IS_ERR_OR_NULL(segs)) {\n\t\tint segs_nr = skb_shinfo(skb)->gso_segs;\n\n\t\tatomic_add(segs_nr, &sk->sk_drops);\n\t\tSNMP_ADD_STATS(__UDPX_MIB(sk, ipv4), UDP_MIB_INERRORS, segs_nr);\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tconsume_skb(skb);\n\treturn segs;\n}\n\nstatic inline void udp_post_segment_fix_csum(struct sk_buff *skb)\n{\n\t \n\tWARN_ON_ONCE(UDP_SKB_CB(skb)->partial_cov);\n\n\t \n\tUDP_SKB_CB(skb)->cscov = skb->len;\n\tif (skb->ip_summed == CHECKSUM_NONE && !skb->csum_valid)\n\t\tskb->csum_valid = 1;\n}\n\n#ifdef CONFIG_BPF_SYSCALL\nstruct sk_psock;\nint udp_bpf_update_proto(struct sock *sk, struct sk_psock *psock, bool restore);\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}