{
  "module_name": "dst.h",
  "hash_id": "d6ca5f8971b1219be0a96d6d4ba82a1f1c239f8ef2092a6b0d7279c6c09bac7d",
  "original_prompt": "Ingested from linux-6.6.14/include/net/dst.h",
  "human_readable_source": " \n \n\n#ifndef _NET_DST_H\n#define _NET_DST_H\n\n#include <net/dst_ops.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/rcupdate.h>\n#include <linux/bug.h>\n#include <linux/jiffies.h>\n#include <linux/refcount.h>\n#include <linux/rcuref.h>\n#include <net/neighbour.h>\n#include <asm/processor.h>\n#include <linux/indirect_call_wrapper.h>\n\nstruct sk_buff;\n\nstruct dst_entry {\n\tstruct net_device       *dev;\n\tstruct  dst_ops\t        *ops;\n\tunsigned long\t\t_metrics;\n\tunsigned long           expires;\n#ifdef CONFIG_XFRM\n\tstruct xfrm_state\t*xfrm;\n#else\n\tvoid\t\t\t*__pad1;\n#endif\n\tint\t\t\t(*input)(struct sk_buff *);\n\tint\t\t\t(*output)(struct net *net, struct sock *sk, struct sk_buff *skb);\n\n\tunsigned short\t\tflags;\n#define DST_NOXFRM\t\t0x0002\n#define DST_NOPOLICY\t\t0x0004\n#define DST_NOCOUNT\t\t0x0008\n#define DST_FAKE_RTABLE\t\t0x0010\n#define DST_XFRM_TUNNEL\t\t0x0020\n#define DST_XFRM_QUEUE\t\t0x0040\n#define DST_METADATA\t\t0x0080\n\n\t \n\tshort\t\t\tobsolete;\n#define DST_OBSOLETE_NONE\t0\n#define DST_OBSOLETE_DEAD\t2\n#define DST_OBSOLETE_FORCE_CHK\t-1\n#define DST_OBSOLETE_KILL\t-2\n\tunsigned short\t\theader_len;\t \n\tunsigned short\t\ttrailer_len;\t \n\n\t \n#ifdef CONFIG_64BIT\n\trcuref_t\t\t__rcuref;\t \n#endif\n\tint\t\t\t__use;\n\tunsigned long\t\tlastuse;\n\tstruct rcu_head\t\trcu_head;\n\tshort\t\t\terror;\n\tshort\t\t\t__pad;\n\t__u32\t\t\ttclassid;\n#ifndef CONFIG_64BIT\n\tstruct lwtunnel_state   *lwtstate;\n\trcuref_t\t\t__rcuref;\t \n#endif\n\tnetdevice_tracker\tdev_tracker;\n\n\t \n\tstruct list_head\trt_uncached;\n\tstruct uncached_list\t*rt_uncached_list;\n#ifdef CONFIG_64BIT\n\tstruct lwtunnel_state   *lwtstate;\n#endif\n};\n\nstruct dst_metrics {\n\tu32\t\tmetrics[RTAX_MAX];\n\trefcount_t\trefcnt;\n} __aligned(4);\t\t \nextern const struct dst_metrics dst_default_metrics;\n\nu32 *dst_cow_metrics_generic(struct dst_entry *dst, unsigned long old);\n\n#define DST_METRICS_READ_ONLY\t\t0x1UL\n#define DST_METRICS_REFCOUNTED\t\t0x2UL\n#define DST_METRICS_FLAGS\t\t0x3UL\n#define __DST_METRICS_PTR(Y)\t\\\n\t((u32 *)((Y) & ~DST_METRICS_FLAGS))\n#define DST_METRICS_PTR(X)\t__DST_METRICS_PTR((X)->_metrics)\n\nstatic inline bool dst_metrics_read_only(const struct dst_entry *dst)\n{\n\treturn dst->_metrics & DST_METRICS_READ_ONLY;\n}\n\nvoid __dst_destroy_metrics_generic(struct dst_entry *dst, unsigned long old);\n\nstatic inline void dst_destroy_metrics_generic(struct dst_entry *dst)\n{\n\tunsigned long val = dst->_metrics;\n\tif (!(val & DST_METRICS_READ_ONLY))\n\t\t__dst_destroy_metrics_generic(dst, val);\n}\n\nstatic inline u32 *dst_metrics_write_ptr(struct dst_entry *dst)\n{\n\tunsigned long p = dst->_metrics;\n\n\tBUG_ON(!p);\n\n\tif (p & DST_METRICS_READ_ONLY)\n\t\treturn dst->ops->cow_metrics(dst, p);\n\treturn __DST_METRICS_PTR(p);\n}\n\n \nstatic inline void dst_init_metrics(struct dst_entry *dst,\n\t\t\t\t    const u32 *src_metrics,\n\t\t\t\t    bool read_only)\n{\n\tdst->_metrics = ((unsigned long) src_metrics) |\n\t\t(read_only ? DST_METRICS_READ_ONLY : 0);\n}\n\nstatic inline void dst_copy_metrics(struct dst_entry *dest, const struct dst_entry *src)\n{\n\tu32 *dst_metrics = dst_metrics_write_ptr(dest);\n\n\tif (dst_metrics) {\n\t\tu32 *src_metrics = DST_METRICS_PTR(src);\n\n\t\tmemcpy(dst_metrics, src_metrics, RTAX_MAX * sizeof(u32));\n\t}\n}\n\nstatic inline u32 *dst_metrics_ptr(struct dst_entry *dst)\n{\n\treturn DST_METRICS_PTR(dst);\n}\n\nstatic inline u32\ndst_metric_raw(const struct dst_entry *dst, const int metric)\n{\n\tu32 *p = DST_METRICS_PTR(dst);\n\n\treturn p[metric-1];\n}\n\nstatic inline u32\ndst_metric(const struct dst_entry *dst, const int metric)\n{\n\tWARN_ON_ONCE(metric == RTAX_HOPLIMIT ||\n\t\t     metric == RTAX_ADVMSS ||\n\t\t     metric == RTAX_MTU);\n\treturn dst_metric_raw(dst, metric);\n}\n\nstatic inline u32\ndst_metric_advmss(const struct dst_entry *dst)\n{\n\tu32 advmss = dst_metric_raw(dst, RTAX_ADVMSS);\n\n\tif (!advmss)\n\t\tadvmss = dst->ops->default_advmss(dst);\n\n\treturn advmss;\n}\n\nstatic inline void dst_metric_set(struct dst_entry *dst, int metric, u32 val)\n{\n\tu32 *p = dst_metrics_write_ptr(dst);\n\n\tif (p)\n\t\tp[metric-1] = val;\n}\n\n \n#define DST_FEATURE_ECN_CA\t(1U << 31)\n\n#define DST_FEATURE_MASK\t(DST_FEATURE_ECN_CA)\n#define DST_FEATURE_ECN_MASK\t(DST_FEATURE_ECN_CA | RTAX_FEATURE_ECN)\n\nstatic inline u32\ndst_feature(const struct dst_entry *dst, u32 feature)\n{\n\treturn dst_metric(dst, RTAX_FEATURES) & feature;\n}\n\nINDIRECT_CALLABLE_DECLARE(unsigned int ip6_mtu(const struct dst_entry *));\nINDIRECT_CALLABLE_DECLARE(unsigned int ipv4_mtu(const struct dst_entry *));\nstatic inline u32 dst_mtu(const struct dst_entry *dst)\n{\n\treturn INDIRECT_CALL_INET(dst->ops->mtu, ip6_mtu, ipv4_mtu, dst);\n}\n\n \nstatic inline unsigned long dst_metric_rtt(const struct dst_entry *dst, int metric)\n{\n\treturn msecs_to_jiffies(dst_metric(dst, metric));\n}\n\nstatic inline u32\ndst_allfrag(const struct dst_entry *dst)\n{\n\tint ret = dst_feature(dst,  RTAX_FEATURE_ALLFRAG);\n\treturn ret;\n}\n\nstatic inline int\ndst_metric_locked(const struct dst_entry *dst, int metric)\n{\n\treturn dst_metric(dst, RTAX_LOCK) & (1 << metric);\n}\n\nstatic inline void dst_hold(struct dst_entry *dst)\n{\n\t \n\tBUILD_BUG_ON(offsetof(struct dst_entry, __rcuref) & 63);\n\tWARN_ON(!rcuref_get(&dst->__rcuref));\n}\n\nstatic inline void dst_use_noref(struct dst_entry *dst, unsigned long time)\n{\n\tif (unlikely(time != dst->lastuse)) {\n\t\tdst->__use++;\n\t\tdst->lastuse = time;\n\t}\n}\n\nstatic inline struct dst_entry *dst_clone(struct dst_entry *dst)\n{\n\tif (dst)\n\t\tdst_hold(dst);\n\treturn dst;\n}\n\nvoid dst_release(struct dst_entry *dst);\n\nvoid dst_release_immediate(struct dst_entry *dst);\n\nstatic inline void refdst_drop(unsigned long refdst)\n{\n\tif (!(refdst & SKB_DST_NOREF))\n\t\tdst_release((struct dst_entry *)(refdst & SKB_DST_PTRMASK));\n}\n\n \nstatic inline void skb_dst_drop(struct sk_buff *skb)\n{\n\tif (skb->_skb_refdst) {\n\t\trefdst_drop(skb->_skb_refdst);\n\t\tskb->_skb_refdst = 0UL;\n\t}\n}\n\nstatic inline void __skb_dst_copy(struct sk_buff *nskb, unsigned long refdst)\n{\n\tnskb->slow_gro |= !!refdst;\n\tnskb->_skb_refdst = refdst;\n\tif (!(nskb->_skb_refdst & SKB_DST_NOREF))\n\t\tdst_clone(skb_dst(nskb));\n}\n\nstatic inline void skb_dst_copy(struct sk_buff *nskb, const struct sk_buff *oskb)\n{\n\t__skb_dst_copy(nskb, oskb->_skb_refdst);\n}\n\n \nstatic inline bool dst_hold_safe(struct dst_entry *dst)\n{\n\treturn rcuref_get(&dst->__rcuref);\n}\n\n \nstatic inline bool skb_dst_force(struct sk_buff *skb)\n{\n\tif (skb_dst_is_noref(skb)) {\n\t\tstruct dst_entry *dst = skb_dst(skb);\n\n\t\tWARN_ON(!rcu_read_lock_held());\n\t\tif (!dst_hold_safe(dst))\n\t\t\tdst = NULL;\n\n\t\tskb->_skb_refdst = (unsigned long)dst;\n\t\tskb->slow_gro |= !!dst;\n\t}\n\n\treturn skb->_skb_refdst != 0UL;\n}\n\n\n \nstatic inline void __skb_tunnel_rx(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t   struct net *net)\n{\n\tskb->dev = dev;\n\n\t \n\tskb_clear_hash_if_not_l4(skb);\n\tskb_set_queue_mapping(skb, 0);\n\tskb_scrub_packet(skb, !net_eq(net, dev_net(dev)));\n}\n\n \nstatic inline void skb_tunnel_rx(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t struct net *net)\n{\n\tDEV_STATS_INC(dev, rx_packets);\n\tDEV_STATS_ADD(dev, rx_bytes, skb->len);\n\t__skb_tunnel_rx(skb, dev, net);\n}\n\nstatic inline u32 dst_tclassid(const struct sk_buff *skb)\n{\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tconst struct dst_entry *dst;\n\n\tdst = skb_dst(skb);\n\tif (dst)\n\t\treturn dst->tclassid;\n#endif\n\treturn 0;\n}\n\nint dst_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb);\nstatic inline int dst_discard(struct sk_buff *skb)\n{\n\treturn dst_discard_out(&init_net, skb->sk, skb);\n}\nvoid *dst_alloc(struct dst_ops *ops, struct net_device *dev, int initial_ref,\n\t\tint initial_obsolete, unsigned short flags);\nvoid dst_init(struct dst_entry *dst, struct dst_ops *ops,\n\t      struct net_device *dev, int initial_ref, int initial_obsolete,\n\t      unsigned short flags);\nstruct dst_entry *dst_destroy(struct dst_entry *dst);\nvoid dst_dev_put(struct dst_entry *dst);\n\nstatic inline void dst_confirm(struct dst_entry *dst)\n{\n}\n\nstatic inline struct neighbour *dst_neigh_lookup(const struct dst_entry *dst, const void *daddr)\n{\n\tstruct neighbour *n = dst->ops->neigh_lookup(dst, NULL, daddr);\n\treturn IS_ERR(n) ? NULL : n;\n}\n\nstatic inline struct neighbour *dst_neigh_lookup_skb(const struct dst_entry *dst,\n\t\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct neighbour *n;\n\n\tif (WARN_ON_ONCE(!dst->ops->neigh_lookup))\n\t\treturn NULL;\n\n\tn = dst->ops->neigh_lookup(dst, skb, NULL);\n\n\treturn IS_ERR(n) ? NULL : n;\n}\n\nstatic inline void dst_confirm_neigh(const struct dst_entry *dst,\n\t\t\t\t     const void *daddr)\n{\n\tif (dst->ops->confirm_neigh)\n\t\tdst->ops->confirm_neigh(dst, daddr);\n}\n\nstatic inline void dst_link_failure(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tif (dst && dst->ops && dst->ops->link_failure)\n\t\tdst->ops->link_failure(skb);\n}\n\nstatic inline void dst_set_expires(struct dst_entry *dst, int timeout)\n{\n\tunsigned long expires = jiffies + timeout;\n\n\tif (expires == 0)\n\t\texpires = 1;\n\n\tif (dst->expires == 0 || time_before(expires, dst->expires))\n\t\tdst->expires = expires;\n}\n\nINDIRECT_CALLABLE_DECLARE(int ip6_output(struct net *, struct sock *,\n\t\t\t\t\t struct sk_buff *));\nINDIRECT_CALLABLE_DECLARE(int ip_output(struct net *, struct sock *,\n\t\t\t\t\t struct sk_buff *));\n \nstatic inline int dst_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\treturn INDIRECT_CALL_INET(skb_dst(skb)->output,\n\t\t\t\t  ip6_output, ip_output,\n\t\t\t\t  net, sk, skb);\n}\n\nINDIRECT_CALLABLE_DECLARE(int ip6_input(struct sk_buff *));\nINDIRECT_CALLABLE_DECLARE(int ip_local_deliver(struct sk_buff *));\n \nstatic inline int dst_input(struct sk_buff *skb)\n{\n\treturn INDIRECT_CALL_INET(skb_dst(skb)->input,\n\t\t\t\t  ip6_input, ip_local_deliver, skb);\n}\n\nINDIRECT_CALLABLE_DECLARE(struct dst_entry *ip6_dst_check(struct dst_entry *,\n\t\t\t\t\t\t\t  u32));\nINDIRECT_CALLABLE_DECLARE(struct dst_entry *ipv4_dst_check(struct dst_entry *,\n\t\t\t\t\t\t\t   u32));\nstatic inline struct dst_entry *dst_check(struct dst_entry *dst, u32 cookie)\n{\n\tif (dst->obsolete)\n\t\tdst = INDIRECT_CALL_INET(dst->ops->check, ip6_dst_check,\n\t\t\t\t\t ipv4_dst_check, dst, cookie);\n\treturn dst;\n}\n\n \nenum {\n\tXFRM_LOOKUP_ICMP = 1 << 0,\n\tXFRM_LOOKUP_QUEUE = 1 << 1,\n\tXFRM_LOOKUP_KEEP_DST_REF = 1 << 2,\n};\n\nstruct flowi;\n#ifndef CONFIG_XFRM\nstatic inline struct dst_entry *xfrm_lookup(struct net *net,\n\t\t\t\t\t    struct dst_entry *dst_orig,\n\t\t\t\t\t    const struct flowi *fl,\n\t\t\t\t\t    const struct sock *sk,\n\t\t\t\t\t    int flags)\n{\n\treturn dst_orig;\n}\n\nstatic inline struct dst_entry *\nxfrm_lookup_with_ifid(struct net *net, struct dst_entry *dst_orig,\n\t\t      const struct flowi *fl, const struct sock *sk,\n\t\t      int flags, u32 if_id)\n{\n\treturn dst_orig;\n}\n\nstatic inline struct dst_entry *xfrm_lookup_route(struct net *net,\n\t\t\t\t\t\t  struct dst_entry *dst_orig,\n\t\t\t\t\t\t  const struct flowi *fl,\n\t\t\t\t\t\t  const struct sock *sk,\n\t\t\t\t\t\t  int flags)\n{\n\treturn dst_orig;\n}\n\nstatic inline struct xfrm_state *dst_xfrm(const struct dst_entry *dst)\n{\n\treturn NULL;\n}\n\n#else\nstruct dst_entry *xfrm_lookup(struct net *net, struct dst_entry *dst_orig,\n\t\t\t      const struct flowi *fl, const struct sock *sk,\n\t\t\t      int flags);\n\nstruct dst_entry *xfrm_lookup_with_ifid(struct net *net,\n\t\t\t\t\tstruct dst_entry *dst_orig,\n\t\t\t\t\tconst struct flowi *fl,\n\t\t\t\t\tconst struct sock *sk, int flags,\n\t\t\t\t\tu32 if_id);\n\nstruct dst_entry *xfrm_lookup_route(struct net *net, struct dst_entry *dst_orig,\n\t\t\t\t    const struct flowi *fl, const struct sock *sk,\n\t\t\t\t    int flags);\n\n \nstatic inline struct xfrm_state *dst_xfrm(const struct dst_entry *dst)\n{\n\treturn dst->xfrm;\n}\n#endif\n\nstatic inline void skb_dst_update_pmtu(struct sk_buff *skb, u32 mtu)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst && dst->ops->update_pmtu)\n\t\tdst->ops->update_pmtu(dst, NULL, skb, mtu, true);\n}\n\n \nstatic inline void skb_dst_update_pmtu_no_confirm(struct sk_buff *skb, u32 mtu)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst && dst->ops->update_pmtu)\n\t\tdst->ops->update_pmtu(dst, NULL, skb, mtu, false);\n}\n\nstruct dst_entry *dst_blackhole_check(struct dst_entry *dst, u32 cookie);\nvoid dst_blackhole_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t       struct sk_buff *skb, u32 mtu, bool confirm_neigh);\nvoid dst_blackhole_redirect(struct dst_entry *dst, struct sock *sk,\n\t\t\t    struct sk_buff *skb);\nu32 *dst_blackhole_cow_metrics(struct dst_entry *dst, unsigned long old);\nstruct neighbour *dst_blackhole_neigh_lookup(const struct dst_entry *dst,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     const void *daddr);\nunsigned int dst_blackhole_mtu(const struct dst_entry *dst);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}