{
  "module_name": "flow_dissector.h",
  "hash_id": "394ce6ee5f0833b72870ef60dc0edf3f4289db46124d5d95ab3d48ca009c9efa",
  "original_prompt": "Ingested from linux-6.6.14/include/net/flow_dissector.h",
  "human_readable_source": " \n#ifndef _NET_FLOW_DISSECTOR_H\n#define _NET_FLOW_DISSECTOR_H\n\n#include <linux/types.h>\n#include <linux/in6.h>\n#include <linux/siphash.h>\n#include <linux/string.h>\n#include <uapi/linux/if_ether.h>\n\nstruct bpf_prog;\nstruct net;\nstruct sk_buff;\n\n \nstruct flow_dissector_key_control {\n\tu16\tthoff;\n\tu16\taddr_type;\n\tu32\tflags;\n};\n\n#define FLOW_DIS_IS_FRAGMENT\tBIT(0)\n#define FLOW_DIS_FIRST_FRAG\tBIT(1)\n#define FLOW_DIS_ENCAPSULATION\tBIT(2)\n\nenum flow_dissect_ret {\n\tFLOW_DISSECT_RET_OUT_GOOD,\n\tFLOW_DISSECT_RET_OUT_BAD,\n\tFLOW_DISSECT_RET_PROTO_AGAIN,\n\tFLOW_DISSECT_RET_IPPROTO_AGAIN,\n\tFLOW_DISSECT_RET_CONTINUE,\n};\n\n \nstruct flow_dissector_key_basic {\n\t__be16\tn_proto;\n\tu8\tip_proto;\n\tu8\tpadding;\n};\n\nstruct flow_dissector_key_tags {\n\tu32\tflow_label;\n};\n\nstruct flow_dissector_key_vlan {\n\tunion {\n\t\tstruct {\n\t\t\tu16\tvlan_id:12,\n\t\t\t\tvlan_dei:1,\n\t\t\t\tvlan_priority:3;\n\t\t};\n\t\t__be16\tvlan_tci;\n\t};\n\t__be16\tvlan_tpid;\n\t__be16\tvlan_eth_type;\n\tu16\tpadding;\n};\n\nstruct flow_dissector_mpls_lse {\n\tu32\tmpls_ttl:8,\n\t\tmpls_bos:1,\n\t\tmpls_tc:3,\n\t\tmpls_label:20;\n};\n\n#define FLOW_DIS_MPLS_MAX 7\nstruct flow_dissector_key_mpls {\n\tstruct flow_dissector_mpls_lse ls[FLOW_DIS_MPLS_MAX];  \n\tu8 used_lses;  \n};\n\nstatic inline void dissector_set_mpls_lse(struct flow_dissector_key_mpls *mpls,\n\t\t\t\t\t  int lse_index)\n{\n\tmpls->used_lses |= 1 << lse_index;\n}\n\n#define FLOW_DIS_TUN_OPTS_MAX 255\n \nstruct flow_dissector_key_enc_opts {\n\tu8 data[FLOW_DIS_TUN_OPTS_MAX];\t \n\tu8 len;\n\t__be16 dst_opt_type;\n};\n\nstruct flow_dissector_key_keyid {\n\t__be32\tkeyid;\n};\n\n \nstruct flow_dissector_key_ipv4_addrs {\n\t \n\t__be32 src;\n\t__be32 dst;\n};\n\n \nstruct flow_dissector_key_ipv6_addrs {\n\t \n\tstruct in6_addr src;\n\tstruct in6_addr dst;\n};\n\n \nstruct flow_dissector_key_tipc {\n\t__be32 key;\n};\n\n \nstruct flow_dissector_key_addrs {\n\tunion {\n\t\tstruct flow_dissector_key_ipv4_addrs v4addrs;\n\t\tstruct flow_dissector_key_ipv6_addrs v6addrs;\n\t\tstruct flow_dissector_key_tipc tipckey;\n\t};\n};\n\n \nstruct flow_dissector_key_arp {\n\t__u32 sip;\n\t__u32 tip;\n\t__u8 op;\n\tunsigned char sha[ETH_ALEN];\n\tunsigned char tha[ETH_ALEN];\n};\n\n \nstruct flow_dissector_key_ports {\n\tunion {\n\t\t__be32 ports;\n\t\tstruct {\n\t\t\t__be16 src;\n\t\t\t__be16 dst;\n\t\t};\n\t};\n};\n\n \nstruct flow_dissector_key_ports_range {\n\tunion {\n\t\tstruct flow_dissector_key_ports tp;\n\t\tstruct {\n\t\t\tstruct flow_dissector_key_ports tp_min;\n\t\t\tstruct flow_dissector_key_ports tp_max;\n\t\t};\n\t};\n};\n\n \nstruct flow_dissector_key_icmp {\n\tstruct {\n\t\tu8 type;\n\t\tu8 code;\n\t};\n\tu16 id;\n};\n\n \nstruct flow_dissector_key_eth_addrs {\n\t \n\tunsigned char dst[ETH_ALEN];\n\tunsigned char src[ETH_ALEN];\n};\n\n \nstruct flow_dissector_key_tcp {\n\t__be16 flags;\n};\n\n \nstruct flow_dissector_key_ip {\n\t__u8\ttos;\n\t__u8\tttl;\n};\n\n \nstruct flow_dissector_key_meta {\n\tint ingress_ifindex;\n\tu16 ingress_iftype;\n\tu8 l2_miss;\n};\n\n \nstruct flow_dissector_key_ct {\n\tu16\tct_state;\n\tu16\tct_zone;\n\tu32\tct_mark;\n\tu32\tct_labels[4];\n};\n\n \nstruct flow_dissector_key_hash {\n\tu32 hash;\n};\n\n \nstruct flow_dissector_key_num_of_vlans {\n\tu8 num_of_vlans;\n};\n\n \nstruct flow_dissector_key_pppoe {\n\t__be16 session_id;\n\t__be16 ppp_proto;\n\t__be16 type;\n};\n\n \nstruct flow_dissector_key_l2tpv3 {\n\t__be32 session_id;\n};\n\n \nstruct flow_dissector_key_ipsec {\n\t__be32 spi;\n};\n\n \nstruct flow_dissector_key_cfm {\n\tu8\tmdl_ver;\n\tu8\topcode;\n};\n\n#define FLOW_DIS_CFM_MDL_MASK GENMASK(7, 5)\n#define FLOW_DIS_CFM_MDL_MAX 7\n\nenum flow_dissector_key_id {\n\tFLOW_DISSECTOR_KEY_CONTROL,  \n\tFLOW_DISSECTOR_KEY_BASIC,  \n\tFLOW_DISSECTOR_KEY_IPV4_ADDRS,  \n\tFLOW_DISSECTOR_KEY_IPV6_ADDRS,  \n\tFLOW_DISSECTOR_KEY_PORTS,  \n\tFLOW_DISSECTOR_KEY_PORTS_RANGE,  \n\tFLOW_DISSECTOR_KEY_ICMP,  \n\tFLOW_DISSECTOR_KEY_ETH_ADDRS,  \n\tFLOW_DISSECTOR_KEY_TIPC,  \n\tFLOW_DISSECTOR_KEY_ARP,  \n\tFLOW_DISSECTOR_KEY_VLAN,  \n\tFLOW_DISSECTOR_KEY_FLOW_LABEL,  \n\tFLOW_DISSECTOR_KEY_GRE_KEYID,  \n\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY,  \n\tFLOW_DISSECTOR_KEY_ENC_KEYID,  \n\tFLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS,  \n\tFLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS,  \n\tFLOW_DISSECTOR_KEY_ENC_CONTROL,  \n\tFLOW_DISSECTOR_KEY_ENC_PORTS,  \n\tFLOW_DISSECTOR_KEY_MPLS,  \n\tFLOW_DISSECTOR_KEY_TCP,  \n\tFLOW_DISSECTOR_KEY_IP,  \n\tFLOW_DISSECTOR_KEY_CVLAN,  \n\tFLOW_DISSECTOR_KEY_ENC_IP,  \n\tFLOW_DISSECTOR_KEY_ENC_OPTS,  \n\tFLOW_DISSECTOR_KEY_META,  \n\tFLOW_DISSECTOR_KEY_CT,  \n\tFLOW_DISSECTOR_KEY_HASH,  \n\tFLOW_DISSECTOR_KEY_NUM_OF_VLANS,  \n\tFLOW_DISSECTOR_KEY_PPPOE,  \n\tFLOW_DISSECTOR_KEY_L2TPV3,  \n\tFLOW_DISSECTOR_KEY_CFM,  \n\tFLOW_DISSECTOR_KEY_IPSEC,  \n\n\tFLOW_DISSECTOR_KEY_MAX,\n};\n\n#define FLOW_DISSECTOR_F_PARSE_1ST_FRAG\t\tBIT(0)\n#define FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL\tBIT(1)\n#define FLOW_DISSECTOR_F_STOP_AT_ENCAP\t\tBIT(2)\n#define FLOW_DISSECTOR_F_STOP_BEFORE_ENCAP\tBIT(3)\n\nstruct flow_dissector_key {\n\tenum flow_dissector_key_id key_id;\n\tsize_t offset;  \n};\n\nstruct flow_dissector {\n\tunsigned long long  used_keys;\n\t\t \n\tunsigned short int offset[FLOW_DISSECTOR_KEY_MAX];\n};\n\nstruct flow_keys_basic {\n\tstruct flow_dissector_key_control control;\n\tstruct flow_dissector_key_basic basic;\n};\n\nstruct flow_keys {\n\tstruct flow_dissector_key_control control;\n#define FLOW_KEYS_HASH_START_FIELD basic\n\tstruct flow_dissector_key_basic basic __aligned(SIPHASH_ALIGNMENT);\n\tstruct flow_dissector_key_tags tags;\n\tstruct flow_dissector_key_vlan vlan;\n\tstruct flow_dissector_key_vlan cvlan;\n\tstruct flow_dissector_key_keyid keyid;\n\tstruct flow_dissector_key_ports ports;\n\tstruct flow_dissector_key_icmp icmp;\n\t \n\tstruct flow_dissector_key_addrs addrs;\n};\n\n#define FLOW_KEYS_HASH_OFFSET\t\t\\\n\toffsetof(struct flow_keys, FLOW_KEYS_HASH_START_FIELD)\n\n__be32 flow_get_u32_src(const struct flow_keys *flow);\n__be32 flow_get_u32_dst(const struct flow_keys *flow);\n\nextern struct flow_dissector flow_keys_dissector;\nextern struct flow_dissector flow_keys_basic_dissector;\n\n \n#define FLOW_KEYS_DIGEST_LEN\t16\nstruct flow_keys_digest {\n\tu8\tdata[FLOW_KEYS_DIGEST_LEN];\n};\n\nvoid make_flow_keys_digest(struct flow_keys_digest *digest,\n\t\t\t   const struct flow_keys *flow);\n\nstatic inline bool flow_keys_have_l4(const struct flow_keys *keys)\n{\n\treturn (keys->ports.ports || keys->tags.flow_label);\n}\n\nu32 flow_hash_from_keys(struct flow_keys *keys);\nvoid skb_flow_get_icmp_tci(const struct sk_buff *skb,\n\t\t\t   struct flow_dissector_key_icmp *key_icmp,\n\t\t\t   const void *data, int thoff, int hlen);\n\nstatic inline bool dissector_uses_key(const struct flow_dissector *flow_dissector,\n\t\t\t\t      enum flow_dissector_key_id key_id)\n{\n\treturn flow_dissector->used_keys & (1ULL << key_id);\n}\n\nstatic inline void *skb_flow_dissector_target(struct flow_dissector *flow_dissector,\n\t\t\t\t\t      enum flow_dissector_key_id key_id,\n\t\t\t\t\t      void *target_container)\n{\n\treturn ((char *)target_container) + flow_dissector->offset[key_id];\n}\n\nstruct bpf_flow_dissector {\n\tstruct bpf_flow_keys\t*flow_keys;\n\tconst struct sk_buff\t*skb;\n\tconst void\t\t*data;\n\tconst void\t\t*data_end;\n};\n\nstatic inline void\nflow_dissector_init_keys(struct flow_dissector_key_control *key_control,\n\t\t\t struct flow_dissector_key_basic *key_basic)\n{\n\tmemset(key_control, 0, sizeof(*key_control));\n\tmemset(key_basic, 0, sizeof(*key_basic));\n}\n\n#ifdef CONFIG_BPF_SYSCALL\nint flow_dissector_bpf_prog_attach_check(struct net *net,\n\t\t\t\t\t struct bpf_prog *prog);\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}