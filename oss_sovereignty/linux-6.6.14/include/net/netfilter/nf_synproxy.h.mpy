{
  "module_name": "nf_synproxy.h",
  "hash_id": "4324d826885a88378cdcf021536062a1a2486ca021190969c90ea361c7b5e072",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netfilter/nf_synproxy.h",
  "human_readable_source": " \n#ifndef _NF_SYNPROXY_SHARED_H\n#define _NF_SYNPROXY_SHARED_H\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <net/ip6_checksum.h>\n#include <net/ip6_route.h>\n#include <net/tcp.h>\n\n#include <net/netfilter/nf_conntrack_seqadj.h>\n#include <net/netfilter/nf_conntrack_synproxy.h>\n\nstruct synproxy_stats {\n\tunsigned int\t\t\tsyn_received;\n\tunsigned int\t\t\tcookie_invalid;\n\tunsigned int\t\t\tcookie_valid;\n\tunsigned int\t\t\tcookie_retrans;\n\tunsigned int\t\t\tconn_reopened;\n};\n\nstruct synproxy_net {\n\tstruct nf_conn\t\t\t*tmpl;\n\tstruct synproxy_stats __percpu\t*stats;\n\tunsigned int\t\t\thook_ref4;\n\tunsigned int\t\t\thook_ref6;\n};\n\nextern unsigned int synproxy_net_id;\nstatic inline struct synproxy_net *synproxy_pernet(struct net *net)\n{\n\treturn net_generic(net, synproxy_net_id);\n}\n\nstruct synproxy_options {\n\tu8\t\t\t\toptions;\n\tu8\t\t\t\twscale;\n\tu16\t\t\t\tmss_option;\n\tu16\t\t\t\tmss_encode;\n\tu32\t\t\t\ttsval;\n\tu32\t\t\t\ttsecr;\n};\n\nstruct nf_synproxy_info;\nbool synproxy_parse_options(const struct sk_buff *skb, unsigned int doff,\n\t\t\t    const struct tcphdr *th,\n\t\t\t    struct synproxy_options *opts);\n\nvoid synproxy_init_timestamp_cookie(const struct nf_synproxy_info *info,\n\t\t\t\t    struct synproxy_options *opts);\n\nvoid synproxy_send_client_synack(struct net *net, const struct sk_buff *skb,\n\t\t\t\t const struct tcphdr *th,\n\t\t\t\t const struct synproxy_options *opts);\n\nbool synproxy_recv_client_ack(struct net *net,\n\t\t\t      const struct sk_buff *skb,\n\t\t\t      const struct tcphdr *th,\n\t\t\t      struct synproxy_options *opts, u32 recv_seq);\n\nstruct nf_hook_state;\n\nunsigned int ipv4_synproxy_hook(void *priv, struct sk_buff *skb,\n\t\t\t\tconst struct nf_hook_state *nhs);\nint nf_synproxy_ipv4_init(struct synproxy_net *snet, struct net *net);\nvoid nf_synproxy_ipv4_fini(struct synproxy_net *snet, struct net *net);\n\n#if IS_ENABLED(CONFIG_IPV6)\nvoid synproxy_send_client_synack_ipv6(struct net *net,\n\t\t\t\t      const struct sk_buff *skb,\n\t\t\t\t      const struct tcphdr *th,\n\t\t\t\t      const struct synproxy_options *opts);\n\nbool synproxy_recv_client_ack_ipv6(struct net *net, const struct sk_buff *skb,\n\t\t\t\t   const struct tcphdr *th,\n\t\t\t\t   struct synproxy_options *opts, u32 recv_seq);\n\nunsigned int ipv6_synproxy_hook(void *priv, struct sk_buff *skb,\n\t\t\t\tconst struct nf_hook_state *nhs);\nint nf_synproxy_ipv6_init(struct synproxy_net *snet, struct net *net);\nvoid nf_synproxy_ipv6_fini(struct synproxy_net *snet, struct net *net);\n#else\nstatic inline int\nnf_synproxy_ipv6_init(struct synproxy_net *snet, struct net *net) { return 0; }\nstatic inline void\nnf_synproxy_ipv6_fini(struct synproxy_net *snet, struct net *net) {};\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}