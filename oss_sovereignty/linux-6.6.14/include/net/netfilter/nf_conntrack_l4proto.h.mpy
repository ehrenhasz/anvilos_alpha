{
  "module_name": "nf_conntrack_l4proto.h",
  "hash_id": "6ae2bc7fd6a5dd8af386f450f7b35e960670e1265428419afa212b930787c084",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netfilter/nf_conntrack_l4proto.h",
  "human_readable_source": " \n \n\n#ifndef _NF_CONNTRACK_L4PROTO_H\n#define _NF_CONNTRACK_L4PROTO_H\n#include <linux/netlink.h>\n#include <net/netlink.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netns/generic.h>\n\nstruct seq_file;\n\nstruct nf_conntrack_l4proto {\n\t \n\tu_int8_t l4proto;\n\n\t \n\tbool allow_clash;\n\n\t \n\tu16 nlattr_size;\n\n\t \n\tbool (*can_early_drop)(const struct nf_conn *ct);\n\n\t \n\tint (*to_nlattr)(struct sk_buff *skb, struct nlattr *nla,\n\t\t\t struct nf_conn *ct, bool destroy);\n\n\t \n\tint (*from_nlattr)(struct nlattr *tb[], struct nf_conn *ct);\n\n\tint (*tuple_to_nlattr)(struct sk_buff *skb,\n\t\t\t       const struct nf_conntrack_tuple *t);\n\t \n\tunsigned int (*nlattr_tuple_size)(void);\n\tint (*nlattr_to_tuple)(struct nlattr *tb[],\n\t\t\t       struct nf_conntrack_tuple *t,\n\t\t\t       u_int32_t flags);\n\tconst struct nla_policy *nla_policy;\n\n\tstruct {\n\t\tint (*nlattr_to_obj)(struct nlattr *tb[],\n\t\t\t\t     struct net *net, void *data);\n\t\tint (*obj_to_nlattr)(struct sk_buff *skb, const void *data);\n\n\t\tu16 obj_size;\n\t\tu16 nlattr_max;\n\t\tconst struct nla_policy *nla_policy;\n\t} ctnl_timeout;\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\n\t \n\tvoid (*print_conntrack)(struct seq_file *s, struct nf_conn *);\n#endif\n};\n\nbool icmp_pkt_to_tuple(const struct sk_buff *skb,\n\t\t       unsigned int dataoff,\n\t\t       struct net *net,\n\t\t       struct nf_conntrack_tuple *tuple);\n\nbool icmpv6_pkt_to_tuple(const struct sk_buff *skb,\n\t\t\t unsigned int dataoff,\n\t\t\t struct net *net,\n\t\t\t struct nf_conntrack_tuple *tuple);\n\nbool nf_conntrack_invert_icmp_tuple(struct nf_conntrack_tuple *tuple,\n\t\t\t\t    const struct nf_conntrack_tuple *orig);\nbool nf_conntrack_invert_icmpv6_tuple(struct nf_conntrack_tuple *tuple,\n\t\t\t\t      const struct nf_conntrack_tuple *orig);\n\nint nf_conntrack_inet_error(struct nf_conn *tmpl, struct sk_buff *skb,\n\t\t\t    unsigned int dataoff,\n\t\t\t    const struct nf_hook_state *state,\n\t\t\t    u8 l4proto,\n\t\t\t    union nf_inet_addr *outer_daddr);\n\nint nf_conntrack_icmpv4_error(struct nf_conn *tmpl,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      unsigned int dataoff,\n\t\t\t      const struct nf_hook_state *state);\n\nint nf_conntrack_icmpv6_error(struct nf_conn *tmpl,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      unsigned int dataoff,\n\t\t\t      const struct nf_hook_state *state);\n\nint nf_conntrack_icmp_packet(struct nf_conn *ct,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     enum ip_conntrack_info ctinfo,\n\t\t\t     const struct nf_hook_state *state);\n\nint nf_conntrack_icmpv6_packet(struct nf_conn *ct,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       enum ip_conntrack_info ctinfo,\n\t\t\t       const struct nf_hook_state *state);\n\nint nf_conntrack_udp_packet(struct nf_conn *ct,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    unsigned int dataoff,\n\t\t\t    enum ip_conntrack_info ctinfo,\n\t\t\t    const struct nf_hook_state *state);\nint nf_conntrack_udplite_packet(struct nf_conn *ct,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tunsigned int dataoff,\n\t\t\t\tenum ip_conntrack_info ctinfo,\n\t\t\t\tconst struct nf_hook_state *state);\nint nf_conntrack_tcp_packet(struct nf_conn *ct,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    unsigned int dataoff,\n\t\t\t    enum ip_conntrack_info ctinfo,\n\t\t\t    const struct nf_hook_state *state);\nint nf_conntrack_dccp_packet(struct nf_conn *ct,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     unsigned int dataoff,\n\t\t\t     enum ip_conntrack_info ctinfo,\n\t\t\t     const struct nf_hook_state *state);\nint nf_conntrack_sctp_packet(struct nf_conn *ct,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     unsigned int dataoff,\n\t\t\t     enum ip_conntrack_info ctinfo,\n\t\t\t     const struct nf_hook_state *state);\nint nf_conntrack_gre_packet(struct nf_conn *ct,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    unsigned int dataoff,\n\t\t\t    enum ip_conntrack_info ctinfo,\n\t\t\t    const struct nf_hook_state *state);\n\nvoid nf_conntrack_generic_init_net(struct net *net);\nvoid nf_conntrack_tcp_init_net(struct net *net);\nvoid nf_conntrack_udp_init_net(struct net *net);\nvoid nf_conntrack_gre_init_net(struct net *net);\nvoid nf_conntrack_dccp_init_net(struct net *net);\nvoid nf_conntrack_sctp_init_net(struct net *net);\nvoid nf_conntrack_icmp_init_net(struct net *net);\nvoid nf_conntrack_icmpv6_init_net(struct net *net);\n\n \nextern const struct nf_conntrack_l4proto nf_conntrack_l4proto_generic;\n\n#define MAX_NF_CT_PROTO IPPROTO_UDPLITE\n\nconst struct nf_conntrack_l4proto *nf_ct_l4proto_find(u8 l4proto);\n\n \nint nf_ct_port_tuple_to_nlattr(struct sk_buff *skb,\n\t\t\t       const struct nf_conntrack_tuple *tuple);\nint nf_ct_port_nlattr_to_tuple(struct nlattr *tb[],\n\t\t\t       struct nf_conntrack_tuple *t,\n\t\t\t       u_int32_t flags);\nunsigned int nf_ct_port_nlattr_tuple_size(void);\nextern const struct nla_policy nf_ct_port_nla_policy[];\n\n#ifdef CONFIG_SYSCTL\n__printf(4, 5) __cold\nvoid nf_ct_l4proto_log_invalid(const struct sk_buff *skb,\n\t\t\t       const struct nf_conn *ct,\n\t\t\t       const struct nf_hook_state *state,\n\t\t\t       const char *fmt, ...);\n__printf(4, 5) __cold\nvoid nf_l4proto_log_invalid(const struct sk_buff *skb,\n\t\t\t    const struct nf_hook_state *state,\n\t\t\t    u8 protonum,\n\t\t\t    const char *fmt, ...);\n#else\nstatic inline __printf(4, 5) __cold\nvoid nf_l4proto_log_invalid(const struct sk_buff *skb,\n\t\t\t    const struct nf_hook_state *state,\n\t\t\t    u8 protonum,\n\t\t\t    const char *fmt, ...) {}\nstatic inline __printf(4, 5) __cold\nvoid nf_ct_l4proto_log_invalid(const struct sk_buff *skb,\n\t\t\t       const struct nf_conn *ct,\n\t\t\t       const struct nf_hook_state *state,\n\t\t\t       const char *fmt, ...) { }\n#endif  \n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\nstatic inline struct nf_generic_net *nf_generic_pernet(struct net *net)\n{\n\treturn &net->ct.nf_ct_proto.generic;\n}\n\nstatic inline struct nf_tcp_net *nf_tcp_pernet(struct net *net)\n{\n\treturn &net->ct.nf_ct_proto.tcp;\n}\n\nstatic inline struct nf_udp_net *nf_udp_pernet(struct net *net)\n{\n\treturn &net->ct.nf_ct_proto.udp;\n}\n\nstatic inline struct nf_icmp_net *nf_icmp_pernet(struct net *net)\n{\n\treturn &net->ct.nf_ct_proto.icmp;\n}\n\nstatic inline struct nf_icmp_net *nf_icmpv6_pernet(struct net *net)\n{\n\treturn &net->ct.nf_ct_proto.icmpv6;\n}\n\n \nstatic inline void nf_ct_set_tcp_be_liberal(struct nf_conn *ct)\n{\n\tct->proto.tcp.seen[0].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;\n\tct->proto.tcp.seen[1].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;\n}\n\n \nstatic inline bool nf_conntrack_tcp_established(const struct nf_conn *ct)\n{\n\treturn ct->proto.tcp.state == TCP_CONNTRACK_ESTABLISHED &&\n\t       test_bit(IPS_ASSURED_BIT, &ct->status);\n}\n#endif\n\n#ifdef CONFIG_NF_CT_PROTO_DCCP\nstatic inline struct nf_dccp_net *nf_dccp_pernet(struct net *net)\n{\n\treturn &net->ct.nf_ct_proto.dccp;\n}\n#endif\n\n#ifdef CONFIG_NF_CT_PROTO_SCTP\nstatic inline struct nf_sctp_net *nf_sctp_pernet(struct net *net)\n{\n\treturn &net->ct.nf_ct_proto.sctp;\n}\n#endif\n\n#ifdef CONFIG_NF_CT_PROTO_GRE\nstatic inline struct nf_gre_net *nf_gre_pernet(struct net *net)\n{\n\treturn &net->ct.nf_ct_proto.gre;\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}