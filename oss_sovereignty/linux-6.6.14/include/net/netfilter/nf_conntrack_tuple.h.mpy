{
  "module_name": "nf_conntrack_tuple.h",
  "hash_id": "d8476a75e5c3b9d5610c39e5308c6f2da8e4d358859a41469f1f2882279bc7d1",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netfilter/nf_conntrack_tuple.h",
  "human_readable_source": " \n \n\n#ifndef _NF_CONNTRACK_TUPLE_H\n#define _NF_CONNTRACK_TUPLE_H\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/nf_conntrack_tuple_common.h>\n#include <linux/list_nulls.h>\n\n \n\n#define NF_CT_TUPLE_L3SIZE\tARRAY_SIZE(((union nf_inet_addr *)NULL)->all)\n\n \nstruct nf_conntrack_man {\n\tunion nf_inet_addr u3;\n\tunion nf_conntrack_man_proto u;\n\t \n\tu_int16_t l3num;\n};\n\n \nstruct nf_conntrack_tuple {\n\tstruct nf_conntrack_man src;\n\n\t \n\tstruct {\n\t\tunion nf_inet_addr u3;\n\t\tunion {\n\t\t\t \n\t\t\t__be16 all;\n\n\t\t\tstruct {\n\t\t\t\t__be16 port;\n\t\t\t} tcp;\n\t\t\tstruct {\n\t\t\t\t__be16 port;\n\t\t\t} udp;\n\t\t\tstruct {\n\t\t\t\tu_int8_t type, code;\n\t\t\t} icmp;\n\t\t\tstruct {\n\t\t\t\t__be16 port;\n\t\t\t} dccp;\n\t\t\tstruct {\n\t\t\t\t__be16 port;\n\t\t\t} sctp;\n\t\t\tstruct {\n\t\t\t\t__be16 key;\n\t\t\t} gre;\n\t\t} u;\n\n\t\t \n\t\tu_int8_t protonum;\n\n\t\t \n\t\tstruct { } __nfct_hash_offsetend;\n\n\t\t \n\t\tu_int8_t dir;\n\t} dst;\n};\n\nstruct nf_conntrack_tuple_mask {\n\tstruct {\n\t\tunion nf_inet_addr u3;\n\t\tunion nf_conntrack_man_proto u;\n\t} src;\n};\n\nstatic inline void nf_ct_dump_tuple_ip(const struct nf_conntrack_tuple *t)\n{\n#ifdef DEBUG\n\tprintk(\"tuple %p: %u %pI4:%hu -> %pI4:%hu\\n\",\n\t       t, t->dst.protonum,\n\t       &t->src.u3.ip, ntohs(t->src.u.all),\n\t       &t->dst.u3.ip, ntohs(t->dst.u.all));\n#endif\n}\n\nstatic inline void nf_ct_dump_tuple_ipv6(const struct nf_conntrack_tuple *t)\n{\n#ifdef DEBUG\n\tprintk(\"tuple %p: %u %pI6 %hu -> %pI6 %hu\\n\",\n\t       t, t->dst.protonum,\n\t       t->src.u3.all, ntohs(t->src.u.all),\n\t       t->dst.u3.all, ntohs(t->dst.u.all));\n#endif\n}\n\nstatic inline void nf_ct_dump_tuple(const struct nf_conntrack_tuple *t)\n{\n\tswitch (t->src.l3num) {\n\tcase AF_INET:\n\t\tnf_ct_dump_tuple_ip(t);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tnf_ct_dump_tuple_ipv6(t);\n\t\tbreak;\n\t}\n}\n\n \n#define NF_CT_DIRECTION(h)\t\t\t\t\t\t\\\n\t((enum ip_conntrack_dir)(h)->tuple.dst.dir)\n\n \nstruct nf_conntrack_tuple_hash {\n\tstruct hlist_nulls_node hnnode;\n\tstruct nf_conntrack_tuple tuple;\n};\n\nstatic inline bool __nf_ct_tuple_src_equal(const struct nf_conntrack_tuple *t1,\n\t\t\t\t\t   const struct nf_conntrack_tuple *t2)\n{\n\treturn (nf_inet_addr_cmp(&t1->src.u3, &t2->src.u3) &&\n\t\tt1->src.u.all == t2->src.u.all &&\n\t\tt1->src.l3num == t2->src.l3num);\n}\n\nstatic inline bool __nf_ct_tuple_dst_equal(const struct nf_conntrack_tuple *t1,\n\t\t\t\t\t   const struct nf_conntrack_tuple *t2)\n{\n\treturn (nf_inet_addr_cmp(&t1->dst.u3, &t2->dst.u3) &&\n\t\tt1->dst.u.all == t2->dst.u.all &&\n\t\tt1->dst.protonum == t2->dst.protonum);\n}\n\nstatic inline bool nf_ct_tuple_equal(const struct nf_conntrack_tuple *t1,\n\t\t\t\t     const struct nf_conntrack_tuple *t2)\n{\n\treturn __nf_ct_tuple_src_equal(t1, t2) &&\n\t       __nf_ct_tuple_dst_equal(t1, t2);\n}\n\nstatic inline bool\nnf_ct_tuple_mask_equal(const struct nf_conntrack_tuple_mask *m1,\n\t\t       const struct nf_conntrack_tuple_mask *m2)\n{\n\treturn (nf_inet_addr_cmp(&m1->src.u3, &m2->src.u3) &&\n\t\tm1->src.u.all == m2->src.u.all);\n}\n\nstatic inline bool\nnf_ct_tuple_src_mask_cmp(const struct nf_conntrack_tuple *t1,\n\t\t\t const struct nf_conntrack_tuple *t2,\n\t\t\t const struct nf_conntrack_tuple_mask *mask)\n{\n\tint count;\n\n\tfor (count = 0; count < NF_CT_TUPLE_L3SIZE; count++) {\n\t\tif ((t1->src.u3.all[count] ^ t2->src.u3.all[count]) &\n\t\t    mask->src.u3.all[count])\n\t\t\treturn false;\n\t}\n\n\tif ((t1->src.u.all ^ t2->src.u.all) & mask->src.u.all)\n\t\treturn false;\n\n\tif (t1->src.l3num != t2->src.l3num ||\n\t    t1->dst.protonum != t2->dst.protonum)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline bool\nnf_ct_tuple_mask_cmp(const struct nf_conntrack_tuple *t,\n\t\t     const struct nf_conntrack_tuple *tuple,\n\t\t     const struct nf_conntrack_tuple_mask *mask)\n{\n\treturn nf_ct_tuple_src_mask_cmp(t, tuple, mask) &&\n\t       __nf_ct_tuple_dst_equal(t, tuple);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}