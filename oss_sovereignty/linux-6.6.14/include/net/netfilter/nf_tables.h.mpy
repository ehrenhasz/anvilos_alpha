{
  "module_name": "nf_tables.h",
  "hash_id": "8a790d0f36290e3cb41e1810cc6a2f984729fc3f3ea59aea6929d4bfb8ee763c",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netfilter/nf_tables.h",
  "human_readable_source": " \n#ifndef _NET_NF_TABLES_H\n#define _NET_NF_TABLES_H\n\n#include <asm/unaligned.h>\n#include <linux/list.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/u64_stats_sync.h>\n#include <linux/rhashtable.h>\n#include <net/netfilter/nf_flow_table.h>\n#include <net/netlink.h>\n#include <net/flow_offload.h>\n#include <net/netns/generic.h>\n\n#define NFT_MAX_HOOKS\t(NF_INET_INGRESS + 1)\n\nstruct module;\n\n#define NFT_JUMP_STACK_SIZE\t16\n\nenum {\n\tNFT_PKTINFO_L4PROTO\t= (1 << 0),\n\tNFT_PKTINFO_INNER\t= (1 << 1),\n\tNFT_PKTINFO_INNER_FULL\t= (1 << 2),\n};\n\nstruct nft_pktinfo {\n\tstruct sk_buff\t\t\t*skb;\n\tconst struct nf_hook_state\t*state;\n\tu8\t\t\t\tflags;\n\tu8\t\t\t\ttprot;\n\tu16\t\t\t\tfragoff;\n\tu16\t\t\t\tthoff;\n\tu16\t\t\t\tinneroff;\n};\n\nstatic inline struct sock *nft_sk(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->sk;\n}\n\nstatic inline unsigned int nft_thoff(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->thoff;\n}\n\nstatic inline struct net *nft_net(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->net;\n}\n\nstatic inline unsigned int nft_hook(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->hook;\n}\n\nstatic inline u8 nft_pf(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->pf;\n}\n\nstatic inline const struct net_device *nft_in(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->in;\n}\n\nstatic inline const struct net_device *nft_out(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->out;\n}\n\nstatic inline void nft_set_pktinfo(struct nft_pktinfo *pkt,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   const struct nf_hook_state *state)\n{\n\tpkt->skb = skb;\n\tpkt->state = state;\n}\n\nstatic inline void nft_set_pktinfo_unspec(struct nft_pktinfo *pkt)\n{\n\tpkt->flags = 0;\n\tpkt->tprot = 0;\n\tpkt->thoff = 0;\n\tpkt->fragoff = 0;\n}\n\n \nstruct nft_verdict {\n\tu32\t\t\t\tcode;\n\tstruct nft_chain\t\t*chain;\n};\n\nstruct nft_data {\n\tunion {\n\t\tu32\t\t\tdata[4];\n\t\tstruct nft_verdict\tverdict;\n\t};\n} __attribute__((aligned(__alignof__(u64))));\n\n#define NFT_REG32_NUM\t\t20\n\n \nstruct nft_regs {\n\tunion {\n\t\tu32\t\t\tdata[NFT_REG32_NUM];\n\t\tstruct nft_verdict\tverdict;\n\t};\n};\n\nstruct nft_regs_track {\n\tstruct {\n\t\tconst struct nft_expr\t\t*selector;\n\t\tconst struct nft_expr\t\t*bitwise;\n\t\tu8\t\t\t\tnum_reg;\n\t} regs[NFT_REG32_NUM];\n\n\tconst struct nft_expr\t\t\t*cur;\n\tconst struct nft_expr\t\t\t*last;\n};\n\n \n\nstatic inline void nft_reg_store8(u32 *dreg, u8 val)\n{\n\t*dreg = 0;\n\t*(u8 *)dreg = val;\n}\n\nstatic inline u8 nft_reg_load8(const u32 *sreg)\n{\n\treturn *(u8 *)sreg;\n}\n\nstatic inline void nft_reg_store16(u32 *dreg, u16 val)\n{\n\t*dreg = 0;\n\t*(u16 *)dreg = val;\n}\n\nstatic inline void nft_reg_store_be16(u32 *dreg, __be16 val)\n{\n\tnft_reg_store16(dreg, (__force __u16)val);\n}\n\nstatic inline u16 nft_reg_load16(const u32 *sreg)\n{\n\treturn *(u16 *)sreg;\n}\n\nstatic inline __be16 nft_reg_load_be16(const u32 *sreg)\n{\n\treturn (__force __be16)nft_reg_load16(sreg);\n}\n\nstatic inline __be32 nft_reg_load_be32(const u32 *sreg)\n{\n\treturn *(__force __be32 *)sreg;\n}\n\nstatic inline void nft_reg_store64(u64 *dreg, u64 val)\n{\n\tput_unaligned(val, dreg);\n}\n\nstatic inline u64 nft_reg_load64(const u32 *sreg)\n{\n\treturn get_unaligned((u64 *)sreg);\n}\n\nstatic inline void nft_data_copy(u32 *dst, const struct nft_data *src,\n\t\t\t\t unsigned int len)\n{\n\tif (len % NFT_REG32_SIZE)\n\t\tdst[len / NFT_REG32_SIZE] = 0;\n\tmemcpy(dst, src, len);\n}\n\n \nstruct nft_ctx {\n\tstruct net\t\t\t*net;\n\tstruct nft_table\t\t*table;\n\tstruct nft_chain\t\t*chain;\n\tconst struct nlattr * const \t*nla;\n\tu32\t\t\t\tportid;\n\tu32\t\t\t\tseq;\n\tu16\t\t\t\tflags;\n\tu8\t\t\t\tfamily;\n\tu8\t\t\t\tlevel;\n\tbool\t\t\t\treport;\n};\n\nenum nft_data_desc_flags {\n\tNFT_DATA_DESC_SETELEM\t= (1 << 0),\n};\n\nstruct nft_data_desc {\n\tenum nft_data_types\t\ttype;\n\tunsigned int\t\t\tsize;\n\tunsigned int\t\t\tlen;\n\tunsigned int\t\t\tflags;\n};\n\nint nft_data_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t  struct nft_data_desc *desc, const struct nlattr *nla);\nvoid nft_data_hold(const struct nft_data *data, enum nft_data_types type);\nvoid nft_data_release(const struct nft_data *data, enum nft_data_types type);\nint nft_data_dump(struct sk_buff *skb, int attr, const struct nft_data *data,\n\t\t  enum nft_data_types type, unsigned int len);\n\nstatic inline enum nft_data_types nft_dreg_to_type(enum nft_registers reg)\n{\n\treturn reg == NFT_REG_VERDICT ? NFT_DATA_VERDICT : NFT_DATA_VALUE;\n}\n\nstatic inline enum nft_registers nft_type_to_reg(enum nft_data_types type)\n{\n\treturn type == NFT_DATA_VERDICT ? NFT_REG_VERDICT : NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE;\n}\n\nint nft_parse_u32_check(const struct nlattr *attr, int max, u32 *dest);\nint nft_dump_register(struct sk_buff *skb, unsigned int attr, unsigned int reg);\n\nint nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len);\nint nft_parse_register_store(const struct nft_ctx *ctx,\n\t\t\t     const struct nlattr *attr, u8 *dreg,\n\t\t\t     const struct nft_data *data,\n\t\t\t     enum nft_data_types type, unsigned int len);\n\n \nstruct nft_userdata {\n\tu8\t\t\tlen;\n\tunsigned char\t\tdata[];\n};\n\n \nstruct nft_set_elem {\n\tunion {\n\t\tu32\t\tbuf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];\n\t\tstruct nft_data\tval;\n\t} key;\n\tunion {\n\t\tu32\t\tbuf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];\n\t\tstruct nft_data\tval;\n\t} key_end;\n\tunion {\n\t\tu32\t\tbuf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];\n\t\tstruct nft_data val;\n\t} data;\n\tvoid\t\t\t*priv;\n};\n\nstruct nft_set;\nstruct nft_set_iter {\n\tu8\t\tgenmask;\n\tunsigned int\tcount;\n\tunsigned int\tskip;\n\tint\t\terr;\n\tint\t\t(*fn)(const struct nft_ctx *ctx,\n\t\t\t      struct nft_set *set,\n\t\t\t      const struct nft_set_iter *iter,\n\t\t\t      struct nft_set_elem *elem);\n};\n\n \nstruct nft_set_desc {\n\tu32\t\t\tktype;\n\tunsigned int\t\tklen;\n\tu32\t\t\tdtype;\n\tunsigned int\t\tdlen;\n\tu32\t\t\tobjtype;\n\tunsigned int\t\tsize;\n\tu32\t\t\tpolicy;\n\tu32\t\t\tgc_int;\n\tu64\t\t\ttimeout;\n\tu8\t\t\tfield_len[NFT_REG32_COUNT];\n\tu8\t\t\tfield_count;\n\tbool\t\t\texpr;\n};\n\n \nenum nft_set_class {\n\tNFT_SET_CLASS_O_1,\n\tNFT_SET_CLASS_O_LOG_N,\n\tNFT_SET_CLASS_O_N,\n};\n\n \nstruct nft_set_estimate {\n\tu64\t\t\tsize;\n\tenum nft_set_class\tlookup;\n\tenum nft_set_class\tspace;\n};\n\n#define NFT_EXPR_MAXATTR\t\t16\n#define NFT_EXPR_SIZE(size)\t\t(sizeof(struct nft_expr) + \\\n\t\t\t\t\t ALIGN(size, __alignof__(struct nft_expr)))\n\n \nstruct nft_expr {\n\tconst struct nft_expr_ops\t*ops;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(u64))));\n};\n\nstatic inline void *nft_expr_priv(const struct nft_expr *expr)\n{\n\treturn (void *)expr->data;\n}\n\nstruct nft_expr_info;\n\nint nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info);\nint nft_expr_clone(struct nft_expr *dst, struct nft_expr *src);\nvoid nft_expr_destroy(const struct nft_ctx *ctx, struct nft_expr *expr);\nint nft_expr_dump(struct sk_buff *skb, unsigned int attr,\n\t\t  const struct nft_expr *expr, bool reset);\nbool nft_expr_reduce_bitwise(struct nft_regs_track *track,\n\t\t\t     const struct nft_expr *expr);\n\nstruct nft_set_ext;\n\n \nstruct nft_set_ops {\n\tbool\t\t\t\t(*lookup)(const struct net *net,\n\t\t\t\t\t\t  const struct nft_set *set,\n\t\t\t\t\t\t  const u32 *key,\n\t\t\t\t\t\t  const struct nft_set_ext **ext);\n\tbool\t\t\t\t(*update)(struct nft_set *set,\n\t\t\t\t\t\t  const u32 *key,\n\t\t\t\t\t\t  void *(*new)(struct nft_set *,\n\t\t\t\t\t\t\t       const struct nft_expr *,\n\t\t\t\t\t\t\t       struct nft_regs *),\n\t\t\t\t\t\t  const struct nft_expr *expr,\n\t\t\t\t\t\t  struct nft_regs *regs,\n\t\t\t\t\t\t  const struct nft_set_ext **ext);\n\tbool\t\t\t\t(*delete)(const struct nft_set *set,\n\t\t\t\t\t\t  const u32 *key);\n\n\tint\t\t\t\t(*insert)(const struct net *net,\n\t\t\t\t\t\t  const struct nft_set *set,\n\t\t\t\t\t\t  const struct nft_set_elem *elem,\n\t\t\t\t\t\t  struct nft_set_ext **ext);\n\tvoid\t\t\t\t(*activate)(const struct net *net,\n\t\t\t\t\t\t    const struct nft_set *set,\n\t\t\t\t\t\t    const struct nft_set_elem *elem);\n\tvoid *\t\t\t\t(*deactivate)(const struct net *net,\n\t\t\t\t\t\t      const struct nft_set *set,\n\t\t\t\t\t\t      const struct nft_set_elem *elem);\n\tbool\t\t\t\t(*flush)(const struct net *net,\n\t\t\t\t\t\t const struct nft_set *set,\n\t\t\t\t\t\t void *priv);\n\tvoid\t\t\t\t(*remove)(const struct net *net,\n\t\t\t\t\t\t  const struct nft_set *set,\n\t\t\t\t\t\t  const struct nft_set_elem *elem);\n\tvoid\t\t\t\t(*walk)(const struct nft_ctx *ctx,\n\t\t\t\t\t\tstruct nft_set *set,\n\t\t\t\t\t\tstruct nft_set_iter *iter);\n\tvoid *\t\t\t\t(*get)(const struct net *net,\n\t\t\t\t\t       const struct nft_set *set,\n\t\t\t\t\t       const struct nft_set_elem *elem,\n\t\t\t\t\t       unsigned int flags);\n\tvoid\t\t\t\t(*commit)(const struct nft_set *set);\n\tvoid\t\t\t\t(*abort)(const struct nft_set *set);\n\tu64\t\t\t\t(*privsize)(const struct nlattr * const nla[],\n\t\t\t\t\t\t    const struct nft_set_desc *desc);\n\tbool\t\t\t\t(*estimate)(const struct nft_set_desc *desc,\n\t\t\t\t\t\t    u32 features,\n\t\t\t\t\t\t    struct nft_set_estimate *est);\n\tint\t\t\t\t(*init)(const struct nft_set *set,\n\t\t\t\t\t\tconst struct nft_set_desc *desc,\n\t\t\t\t\t\tconst struct nlattr * const nla[]);\n\tvoid\t\t\t\t(*destroy)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t   const struct nft_set *set);\n\tvoid\t\t\t\t(*gc_init)(const struct nft_set *set);\n\n\tunsigned int\t\t\telemsize;\n};\n\n \nstruct nft_set_type {\n\tconst struct nft_set_ops\tops;\n\tu32\t\t\t\tfeatures;\n};\n#define to_set_type(o) container_of(o, struct nft_set_type, ops)\n\nstruct nft_set_elem_expr {\n\tu8\t\t\t\tsize;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_expr))));\n};\n\n#define nft_setelem_expr_at(__elem_expr, __offset)\t\t\t\\\n\t((struct nft_expr *)&__elem_expr->data[__offset])\n\n#define nft_setelem_expr_foreach(__expr, __elem_expr, __size)\t\t\\\n\tfor (__expr = nft_setelem_expr_at(__elem_expr, 0), __size = 0;\t\\\n\t     __size < (__elem_expr)->size;\t\t\t\t\\\n\t     __size += (__expr)->ops->size, __expr = ((void *)(__expr)) + (__expr)->ops->size)\n\n#define NFT_SET_EXPR_MAX\t2\n\n \nstruct nft_set {\n\tstruct list_head\t\tlist;\n\tstruct list_head\t\tbindings;\n\trefcount_t\t\t\trefs;\n\tstruct nft_table\t\t*table;\n\tpossible_net_t\t\t\tnet;\n\tchar\t\t\t\t*name;\n\tu64\t\t\t\thandle;\n\tu32\t\t\t\tktype;\n\tu32\t\t\t\tdtype;\n\tu32\t\t\t\tobjtype;\n\tu32\t\t\t\tsize;\n\tu8\t\t\t\tfield_len[NFT_REG32_COUNT];\n\tu8\t\t\t\tfield_count;\n\tu32\t\t\t\tuse;\n\tatomic_t\t\t\tnelems;\n\tu32\t\t\t\tndeact;\n\tu64\t\t\t\ttimeout;\n\tu32\t\t\t\tgc_int;\n\tu16\t\t\t\tpolicy;\n\tu16\t\t\t\tudlen;\n\tunsigned char\t\t\t*udata;\n\tstruct list_head\t\tpending_update;\n\t \n\tconst struct nft_set_ops\t*ops ____cacheline_aligned;\n\tu16\t\t\t\tflags:13,\n\t\t\t\t\tdead:1,\n\t\t\t\t\tgenmask:2;\n\tu8\t\t\t\tklen;\n\tu8\t\t\t\tdlen;\n\tu8\t\t\t\tnum_exprs;\n\tstruct nft_expr\t\t\t*exprs[NFT_SET_EXPR_MAX];\n\tstruct list_head\t\tcatchall_list;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(u64))));\n};\n\nstatic inline bool nft_set_is_anonymous(const struct nft_set *set)\n{\n\treturn set->flags & NFT_SET_ANONYMOUS;\n}\n\nstatic inline void *nft_set_priv(const struct nft_set *set)\n{\n\treturn (void *)set->data;\n}\n\nstatic inline bool nft_set_gc_is_pending(const struct nft_set *s)\n{\n\treturn refcount_read(&s->refs) != 1;\n}\n\nstatic inline struct nft_set *nft_set_container_of(const void *priv)\n{\n\treturn (void *)priv - offsetof(struct nft_set, data);\n}\n\nstruct nft_set *nft_set_lookup_global(const struct net *net,\n\t\t\t\t      const struct nft_table *table,\n\t\t\t\t      const struct nlattr *nla_set_name,\n\t\t\t\t      const struct nlattr *nla_set_id,\n\t\t\t\t      u8 genmask);\n\nstruct nft_set_ext *nft_set_catchall_lookup(const struct net *net,\n\t\t\t\t\t    const struct nft_set *set);\n\nstatic inline unsigned long nft_set_gc_interval(const struct nft_set *set)\n{\n\tu32 gc_int = READ_ONCE(set->gc_int);\n\n\treturn gc_int ? msecs_to_jiffies(gc_int) : HZ;\n}\n\n \nstruct nft_set_binding {\n\tstruct list_head\t\tlist;\n\tconst struct nft_chain\t\t*chain;\n\tu32\t\t\t\tflags;\n};\n\nenum nft_trans_phase;\nvoid nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set);\nvoid nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t      struct nft_set_binding *binding,\n\t\t\t      enum nft_trans_phase phase);\nint nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t       struct nft_set_binding *binding);\nvoid nf_tables_destroy_set(const struct nft_ctx *ctx, struct nft_set *set);\n\n \nenum nft_set_extensions {\n\tNFT_SET_EXT_KEY,\n\tNFT_SET_EXT_KEY_END,\n\tNFT_SET_EXT_DATA,\n\tNFT_SET_EXT_FLAGS,\n\tNFT_SET_EXT_TIMEOUT,\n\tNFT_SET_EXT_EXPIRATION,\n\tNFT_SET_EXT_USERDATA,\n\tNFT_SET_EXT_EXPRESSIONS,\n\tNFT_SET_EXT_OBJREF,\n\tNFT_SET_EXT_NUM\n};\n\n \nstruct nft_set_ext_type {\n\tu8\tlen;\n\tu8\talign;\n};\n\nextern const struct nft_set_ext_type nft_set_ext_types[];\n\n \nstruct nft_set_ext_tmpl {\n\tu16\tlen;\n\tu8\toffset[NFT_SET_EXT_NUM];\n\tu8\text_len[NFT_SET_EXT_NUM];\n};\n\n \nstruct nft_set_ext {\n\tu8\tgenmask;\n\tu8\toffset[NFT_SET_EXT_NUM];\n\tchar\tdata[];\n};\n\nstatic inline void nft_set_ext_prepare(struct nft_set_ext_tmpl *tmpl)\n{\n\tmemset(tmpl, 0, sizeof(*tmpl));\n\ttmpl->len = sizeof(struct nft_set_ext);\n}\n\nstatic inline int nft_set_ext_add_length(struct nft_set_ext_tmpl *tmpl, u8 id,\n\t\t\t\t\t unsigned int len)\n{\n\ttmpl->len\t = ALIGN(tmpl->len, nft_set_ext_types[id].align);\n\tif (tmpl->len > U8_MAX)\n\t\treturn -EINVAL;\n\n\ttmpl->offset[id] = tmpl->len;\n\ttmpl->ext_len[id] = nft_set_ext_types[id].len + len;\n\ttmpl->len\t+= tmpl->ext_len[id];\n\n\treturn 0;\n}\n\nstatic inline int nft_set_ext_add(struct nft_set_ext_tmpl *tmpl, u8 id)\n{\n\treturn nft_set_ext_add_length(tmpl, id, 0);\n}\n\nstatic inline void nft_set_ext_init(struct nft_set_ext *ext,\n\t\t\t\t    const struct nft_set_ext_tmpl *tmpl)\n{\n\tmemcpy(ext->offset, tmpl->offset, sizeof(ext->offset));\n}\n\nstatic inline bool __nft_set_ext_exists(const struct nft_set_ext *ext, u8 id)\n{\n\treturn !!ext->offset[id];\n}\n\nstatic inline bool nft_set_ext_exists(const struct nft_set_ext *ext, u8 id)\n{\n\treturn ext && __nft_set_ext_exists(ext, id);\n}\n\nstatic inline void *nft_set_ext(const struct nft_set_ext *ext, u8 id)\n{\n\treturn (void *)ext + ext->offset[id];\n}\n\nstatic inline struct nft_data *nft_set_ext_key(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_KEY);\n}\n\nstatic inline struct nft_data *nft_set_ext_key_end(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_KEY_END);\n}\n\nstatic inline struct nft_data *nft_set_ext_data(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_DATA);\n}\n\nstatic inline u8 *nft_set_ext_flags(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_FLAGS);\n}\n\nstatic inline u64 *nft_set_ext_timeout(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_TIMEOUT);\n}\n\nstatic inline u64 *nft_set_ext_expiration(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_EXPIRATION);\n}\n\nstatic inline struct nft_userdata *nft_set_ext_userdata(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_USERDATA);\n}\n\nstatic inline struct nft_set_elem_expr *nft_set_ext_expr(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_EXPRESSIONS);\n}\n\nstatic inline bool nft_set_elem_expired(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION) &&\n\t       time_is_before_eq_jiffies64(*nft_set_ext_expiration(ext));\n}\n\nstatic inline struct nft_set_ext *nft_set_elem_ext(const struct nft_set *set,\n\t\t\t\t\t\t   void *elem)\n{\n\treturn elem + set->ops->elemsize;\n}\n\nstatic inline struct nft_object **nft_set_ext_obj(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_OBJREF);\n}\n\nstruct nft_expr *nft_set_elem_expr_alloc(const struct nft_ctx *ctx,\n\t\t\t\t\t const struct nft_set *set,\n\t\t\t\t\t const struct nlattr *attr);\n\nvoid *nft_set_elem_init(const struct nft_set *set,\n\t\t\tconst struct nft_set_ext_tmpl *tmpl,\n\t\t\tconst u32 *key, const u32 *key_end, const u32 *data,\n\t\t\tu64 timeout, u64 expiration, gfp_t gfp);\nint nft_set_elem_expr_clone(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t    struct nft_expr *expr_array[]);\nvoid nft_set_elem_destroy(const struct nft_set *set, void *elem,\n\t\t\t  bool destroy_expr);\nvoid nf_tables_set_elem_destroy(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_set *set, void *elem);\n\nstruct nft_expr_ops;\n \nstruct nft_expr_type {\n\tconst struct nft_expr_ops\t*(*select_ops)(const struct nft_ctx *,\n\t\t\t\t\t\t       const struct nlattr * const tb[]);\n\tvoid\t\t\t\t(*release_ops)(const struct nft_expr_ops *ops);\n\tconst struct nft_expr_ops\t*ops;\n\tconst struct nft_expr_ops\t*inner_ops;\n\tstruct list_head\t\tlist;\n\tconst char\t\t\t*name;\n\tstruct module\t\t\t*owner;\n\tconst struct nla_policy\t\t*policy;\n\tunsigned int\t\t\tmaxattr;\n\tu8\t\t\t\tfamily;\n\tu8\t\t\t\tflags;\n};\n\n#define NFT_EXPR_STATEFUL\t\t0x1\n#define NFT_EXPR_GC\t\t\t0x2\n\nenum nft_trans_phase {\n\tNFT_TRANS_PREPARE,\n\tNFT_TRANS_PREPARE_ERROR,\n\tNFT_TRANS_ABORT,\n\tNFT_TRANS_COMMIT,\n\tNFT_TRANS_RELEASE\n};\n\nstruct nft_flow_rule;\nstruct nft_offload_ctx;\n\n \nstruct nft_expr_ops {\n\tvoid\t\t\t\t(*eval)(const struct nft_expr *expr,\n\t\t\t\t\t\tstruct nft_regs *regs,\n\t\t\t\t\t\tconst struct nft_pktinfo *pkt);\n\tint\t\t\t\t(*clone)(struct nft_expr *dst,\n\t\t\t\t\t\t const struct nft_expr *src);\n\tunsigned int\t\t\tsize;\n\n\tint\t\t\t\t(*init)(const struct nft_ctx *ctx,\n\t\t\t\t\t\tconst struct nft_expr *expr,\n\t\t\t\t\t\tconst struct nlattr * const tb[]);\n\tvoid\t\t\t\t(*activate)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t    const struct nft_expr *expr);\n\tvoid\t\t\t\t(*deactivate)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t      const struct nft_expr *expr,\n\t\t\t\t\t\t      enum nft_trans_phase phase);\n\tvoid\t\t\t\t(*destroy)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t   const struct nft_expr *expr);\n\tvoid\t\t\t\t(*destroy_clone)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t\t const struct nft_expr *expr);\n\tint\t\t\t\t(*dump)(struct sk_buff *skb,\n\t\t\t\t\t\tconst struct nft_expr *expr,\n\t\t\t\t\t\tbool reset);\n\tint\t\t\t\t(*validate)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t    const struct nft_expr *expr,\n\t\t\t\t\t\t    const struct nft_data **data);\n\tbool\t\t\t\t(*reduce)(struct nft_regs_track *track,\n\t\t\t\t\t\t  const struct nft_expr *expr);\n\tbool\t\t\t\t(*gc)(struct net *net,\n\t\t\t\t\t      const struct nft_expr *expr);\n\tint\t\t\t\t(*offload)(struct nft_offload_ctx *ctx,\n\t\t\t\t\t\t   struct nft_flow_rule *flow,\n\t\t\t\t\t\t   const struct nft_expr *expr);\n\tbool\t\t\t\t(*offload_action)(const struct nft_expr *expr);\n\tvoid\t\t\t\t(*offload_stats)(struct nft_expr *expr,\n\t\t\t\t\t\t\t const struct flow_stats *stats);\n\tconst struct nft_expr_type\t*type;\n\tvoid\t\t\t\t*data;\n};\n\n \nstruct nft_rule {\n\tstruct list_head\t\tlist;\n\tu64\t\t\t\thandle:42,\n\t\t\t\t\tgenmask:2,\n\t\t\t\t\tdlen:12,\n\t\t\t\t\tudata:1;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_expr))));\n};\n\nstatic inline struct nft_expr *nft_expr_first(const struct nft_rule *rule)\n{\n\treturn (struct nft_expr *)&rule->data[0];\n}\n\nstatic inline struct nft_expr *nft_expr_next(const struct nft_expr *expr)\n{\n\treturn ((void *)expr) + expr->ops->size;\n}\n\nstatic inline struct nft_expr *nft_expr_last(const struct nft_rule *rule)\n{\n\treturn (struct nft_expr *)&rule->data[rule->dlen];\n}\n\nstatic inline bool nft_expr_more(const struct nft_rule *rule,\n\t\t\t\t const struct nft_expr *expr)\n{\n\treturn expr != nft_expr_last(rule) && expr->ops;\n}\n\nstatic inline struct nft_userdata *nft_userdata(const struct nft_rule *rule)\n{\n\treturn (void *)&rule->data[rule->dlen];\n}\n\nvoid nft_rule_expr_activate(const struct nft_ctx *ctx, struct nft_rule *rule);\nvoid nft_rule_expr_deactivate(const struct nft_ctx *ctx, struct nft_rule *rule,\n\t\t\t      enum nft_trans_phase phase);\nvoid nf_tables_rule_destroy(const struct nft_ctx *ctx, struct nft_rule *rule);\n\nstatic inline void nft_set_elem_update_expr(const struct nft_set_ext *ext,\n\t\t\t\t\t    struct nft_regs *regs,\n\t\t\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tstruct nft_set_elem_expr *elem_expr;\n\tstruct nft_expr *expr;\n\tu32 size;\n\n\tif (__nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS)) {\n\t\telem_expr = nft_set_ext_expr(ext);\n\t\tnft_setelem_expr_foreach(expr, elem_expr, size) {\n\t\t\texpr->ops->eval(expr, regs, pkt);\n\t\t\tif (regs->verdict.code == NFT_BREAK)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\n \n#define nft_rule_for_each_expr(expr, last, rule) \\\n\tfor ((expr) = nft_expr_first(rule), (last) = nft_expr_last(rule); \\\n\t     (expr) != (last); \\\n\t     (expr) = nft_expr_next(expr))\n\n#define NFT_CHAIN_POLICY_UNSET\t\tU8_MAX\n\nstruct nft_rule_dp {\n\tu64\t\t\t\tis_last:1,\n\t\t\t\t\tdlen:12,\n\t\t\t\t\thandle:42;\t \n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_expr))));\n};\n\nstruct nft_rule_dp_last {\n\tstruct nft_rule_dp end;\t\t \n\tstruct rcu_head h;\t\t \n\tstruct nft_rule_blob *blob;\t \n\tconst struct nft_chain *chain;\t \n};\n\nstatic inline const struct nft_rule_dp *nft_rule_next(const struct nft_rule_dp *rule)\n{\n\treturn (void *)rule + sizeof(*rule) + rule->dlen;\n}\n\nstruct nft_rule_blob {\n\tunsigned long\t\t\tsize;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_rule_dp))));\n};\n\n \nstruct nft_chain {\n\tstruct nft_rule_blob\t\t__rcu *blob_gen_0;\n\tstruct nft_rule_blob\t\t__rcu *blob_gen_1;\n\tstruct list_head\t\trules;\n\tstruct list_head\t\tlist;\n\tstruct rhlist_head\t\trhlhead;\n\tstruct nft_table\t\t*table;\n\tu64\t\t\t\thandle;\n\tu32\t\t\t\tuse;\n\tu8\t\t\t\tflags:5,\n\t\t\t\t\tbound:1,\n\t\t\t\t\tgenmask:2;\n\tchar\t\t\t\t*name;\n\tu16\t\t\t\tudlen;\n\tu8\t\t\t\t*udata;\n\n\t \n\tstruct nft_rule_blob\t\t*blob_next;\n};\n\nint nft_chain_validate(const struct nft_ctx *ctx, const struct nft_chain *chain);\nint nft_setelem_validate(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t const struct nft_set_iter *iter,\n\t\t\t struct nft_set_elem *elem);\nint nft_set_catchall_validate(const struct nft_ctx *ctx, struct nft_set *set);\nint nf_tables_bind_chain(const struct nft_ctx *ctx, struct nft_chain *chain);\nvoid nf_tables_unbind_chain(const struct nft_ctx *ctx, struct nft_chain *chain);\n\nenum nft_chain_types {\n\tNFT_CHAIN_T_DEFAULT = 0,\n\tNFT_CHAIN_T_ROUTE,\n\tNFT_CHAIN_T_NAT,\n\tNFT_CHAIN_T_MAX\n};\n\n \nstruct nft_chain_type {\n\tconst char\t\t\t*name;\n\tenum nft_chain_types\t\ttype;\n\tint\t\t\t\tfamily;\n\tstruct module\t\t\t*owner;\n\tunsigned int\t\t\thook_mask;\n\tnf_hookfn\t\t\t*hooks[NFT_MAX_HOOKS];\n\tint\t\t\t\t(*ops_register)(struct net *net, const struct nf_hook_ops *ops);\n\tvoid\t\t\t\t(*ops_unregister)(struct net *net, const struct nf_hook_ops *ops);\n};\n\nint nft_chain_validate_dependency(const struct nft_chain *chain,\n\t\t\t\t  enum nft_chain_types type);\nint nft_chain_validate_hooks(const struct nft_chain *chain,\n                             unsigned int hook_flags);\n\nstatic inline bool nft_chain_binding(const struct nft_chain *chain)\n{\n\treturn chain->flags & NFT_CHAIN_BINDING;\n}\n\nstatic inline bool nft_chain_is_bound(struct nft_chain *chain)\n{\n\treturn (chain->flags & NFT_CHAIN_BINDING) && chain->bound;\n}\n\nint nft_chain_add(struct nft_table *table, struct nft_chain *chain);\nvoid nft_chain_del(struct nft_chain *chain);\nvoid nf_tables_chain_destroy(struct nft_ctx *ctx);\n\nstruct nft_stats {\n\tu64\t\t\tbytes;\n\tu64\t\t\tpkts;\n\tstruct u64_stats_sync\tsyncp;\n};\n\nstruct nft_hook {\n\tstruct list_head\tlist;\n\tstruct nf_hook_ops\tops;\n\tstruct rcu_head\t\trcu;\n};\n\n \nstruct nft_base_chain {\n\tstruct nf_hook_ops\t\tops;\n\tstruct list_head\t\thook_list;\n\tconst struct nft_chain_type\t*type;\n\tu8\t\t\t\tpolicy;\n\tu8\t\t\t\tflags;\n\tstruct nft_stats __percpu\t*stats;\n\tstruct nft_chain\t\tchain;\n\tstruct flow_block\t\tflow_block;\n};\n\nstatic inline struct nft_base_chain *nft_base_chain(const struct nft_chain *chain)\n{\n\treturn container_of(chain, struct nft_base_chain, chain);\n}\n\nstatic inline bool nft_is_base_chain(const struct nft_chain *chain)\n{\n\treturn chain->flags & NFT_CHAIN_BASE;\n}\n\nint __nft_release_basechain(struct nft_ctx *ctx);\n\nunsigned int nft_do_chain(struct nft_pktinfo *pkt, void *priv);\n\nstatic inline bool nft_use_inc(u32 *use)\n{\n\tif (*use == UINT_MAX)\n\t\treturn false;\n\n\t(*use)++;\n\n\treturn true;\n}\n\nstatic inline void nft_use_dec(u32 *use)\n{\n\tWARN_ON_ONCE((*use)-- == 0);\n}\n\n \nstatic inline void nft_use_inc_restore(u32 *use)\n{\n\tWARN_ON_ONCE(!nft_use_inc(use));\n}\n\n#define nft_use_dec_restore\tnft_use_dec\n\n \nstruct nft_table {\n\tstruct list_head\t\tlist;\n\tstruct rhltable\t\t\tchains_ht;\n\tstruct list_head\t\tchains;\n\tstruct list_head\t\tsets;\n\tstruct list_head\t\tobjects;\n\tstruct list_head\t\tflowtables;\n\tu64\t\t\t\thgenerator;\n\tu64\t\t\t\thandle;\n\tu32\t\t\t\tuse;\n\tu16\t\t\t\tfamily:6,\n\t\t\t\t\tflags:8,\n\t\t\t\t\tgenmask:2;\n\tu32\t\t\t\tnlpid;\n\tchar\t\t\t\t*name;\n\tu16\t\t\t\tudlen;\n\tu8\t\t\t\t*udata;\n\tu8\t\t\t\tvalidate_state;\n};\n\nstatic inline bool nft_table_has_owner(const struct nft_table *table)\n{\n\treturn table->flags & NFT_TABLE_F_OWNER;\n}\n\nstatic inline bool nft_base_chain_netdev(int family, u32 hooknum)\n{\n\treturn family == NFPROTO_NETDEV ||\n\t       (family == NFPROTO_INET && hooknum == NF_INET_INGRESS);\n}\n\nvoid nft_register_chain_type(const struct nft_chain_type *);\nvoid nft_unregister_chain_type(const struct nft_chain_type *);\n\nint nft_register_expr(struct nft_expr_type *);\nvoid nft_unregister_expr(struct nft_expr_type *);\n\nint nft_verdict_dump(struct sk_buff *skb, int type,\n\t\t     const struct nft_verdict *v);\n\n \nstruct nft_object_hash_key {\n\tconst char                      *name;\n\tconst struct nft_table          *table;\n};\n\n \nstruct nft_object {\n\tstruct list_head\t\tlist;\n\tstruct rhlist_head\t\trhlhead;\n\tstruct nft_object_hash_key\tkey;\n\tu32\t\t\t\tgenmask:2;\n\tu32\t\t\t\tuse;\n\tu64\t\t\t\thandle;\n\tu16\t\t\t\tudlen;\n\tu8\t\t\t\t*udata;\n\t \n\tconst struct nft_object_ops\t*ops ____cacheline_aligned;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(u64))));\n};\n\nstatic inline void *nft_obj_data(const struct nft_object *obj)\n{\n\treturn (void *)obj->data;\n}\n\n#define nft_expr_obj(expr)\t*((struct nft_object **)nft_expr_priv(expr))\n\nstruct nft_object *nft_obj_lookup(const struct net *net,\n\t\t\t\t  const struct nft_table *table,\n\t\t\t\t  const struct nlattr *nla, u32 objtype,\n\t\t\t\t  u8 genmask);\n\nvoid nft_obj_notify(struct net *net, const struct nft_table *table,\n\t\t    struct nft_object *obj, u32 portid, u32 seq,\n\t\t    int event, u16 flags, int family, int report, gfp_t gfp);\n\n \nstruct nft_object_type {\n\tconst struct nft_object_ops\t*(*select_ops)(const struct nft_ctx *,\n\t\t\t\t\t\t       const struct nlattr * const tb[]);\n\tconst struct nft_object_ops\t*ops;\n\tstruct list_head\t\tlist;\n\tu32\t\t\t\ttype;\n\tunsigned int                    maxattr;\n\tstruct module\t\t\t*owner;\n\tconst struct nla_policy\t\t*policy;\n};\n\n \nstruct nft_object_ops {\n\tvoid\t\t\t\t(*eval)(struct nft_object *obj,\n\t\t\t\t\t\tstruct nft_regs *regs,\n\t\t\t\t\t\tconst struct nft_pktinfo *pkt);\n\tunsigned int\t\t\tsize;\n\tint\t\t\t\t(*init)(const struct nft_ctx *ctx,\n\t\t\t\t\t\tconst struct nlattr *const tb[],\n\t\t\t\t\t\tstruct nft_object *obj);\n\tvoid\t\t\t\t(*destroy)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t   struct nft_object *obj);\n\tint\t\t\t\t(*dump)(struct sk_buff *skb,\n\t\t\t\t\t\tstruct nft_object *obj,\n\t\t\t\t\t\tbool reset);\n\tvoid\t\t\t\t(*update)(struct nft_object *obj,\n\t\t\t\t\t\t  struct nft_object *newobj);\n\tconst struct nft_object_type\t*type;\n};\n\nint nft_register_obj(struct nft_object_type *obj_type);\nvoid nft_unregister_obj(struct nft_object_type *obj_type);\n\n#define NFT_NETDEVICE_MAX\t256\n\n \nstruct nft_flowtable {\n\tstruct list_head\t\tlist;\n\tstruct nft_table\t\t*table;\n\tchar\t\t\t\t*name;\n\tint\t\t\t\thooknum;\n\tint\t\t\t\tops_len;\n\tu32\t\t\t\tgenmask:2;\n\tu32\t\t\t\tuse;\n\tu64\t\t\t\thandle;\n\t \n\tstruct list_head\t\thook_list ____cacheline_aligned;\n\tstruct nf_flowtable\t\tdata;\n};\n\nstruct nft_flowtable *nft_flowtable_lookup(const struct nft_table *table,\n\t\t\t\t\t   const struct nlattr *nla,\n\t\t\t\t\t   u8 genmask);\n\nvoid nf_tables_deactivate_flowtable(const struct nft_ctx *ctx,\n\t\t\t\t    struct nft_flowtable *flowtable,\n\t\t\t\t    enum nft_trans_phase phase);\n\nvoid nft_register_flowtable_type(struct nf_flowtable_type *type);\nvoid nft_unregister_flowtable_type(struct nf_flowtable_type *type);\n\n \nstruct nft_traceinfo {\n\tbool\t\t\t\ttrace;\n\tbool\t\t\t\tnf_trace;\n\tbool\t\t\t\tpacket_dumped;\n\tenum nft_trace_types\t\ttype:8;\n\tu32\t\t\t\tskbid;\n\tconst struct nft_base_chain\t*basechain;\n};\n\nvoid nft_trace_init(struct nft_traceinfo *info, const struct nft_pktinfo *pkt,\n\t\t    const struct nft_chain *basechain);\n\nvoid nft_trace_notify(const struct nft_pktinfo *pkt,\n\t\t      const struct nft_verdict *verdict,\n\t\t      const struct nft_rule_dp *rule,\n\t\t      struct nft_traceinfo *info);\n\n#define MODULE_ALIAS_NFT_CHAIN(family, name) \\\n\tMODULE_ALIAS(\"nft-chain-\" __stringify(family) \"-\" name)\n\n#define MODULE_ALIAS_NFT_AF_EXPR(family, name) \\\n\tMODULE_ALIAS(\"nft-expr-\" __stringify(family) \"-\" name)\n\n#define MODULE_ALIAS_NFT_EXPR(name) \\\n\tMODULE_ALIAS(\"nft-expr-\" name)\n\n#define MODULE_ALIAS_NFT_OBJ(type) \\\n\tMODULE_ALIAS(\"nft-obj-\" __stringify(type))\n\n#if IS_ENABLED(CONFIG_NF_TABLES)\n\n \nstatic inline unsigned int nft_gencursor_next(const struct net *net)\n{\n\treturn net->nft.gencursor + 1 == 1 ? 1 : 0;\n}\n\nstatic inline u8 nft_genmask_next(const struct net *net)\n{\n\treturn 1 << nft_gencursor_next(net);\n}\n\nstatic inline u8 nft_genmask_cur(const struct net *net)\n{\n\t \n\treturn 1 << READ_ONCE(net->nft.gencursor);\n}\n\n#define NFT_GENMASK_ANY\t\t((1 << 0) | (1 << 1))\n\n \n\n \n#define nft_is_active(__net, __obj)\t\t\t\t\\\n\t(((__obj)->genmask & nft_genmask_cur(__net)) == 0)\n\n \n#define nft_is_active_next(__net, __obj)\t\t\t\\\n\t(((__obj)->genmask & nft_genmask_next(__net)) == 0)\n\n \n#define nft_activate_next(__net, __obj)\t\t\t\t\\\n\t(__obj)->genmask = nft_genmask_cur(__net)\n\n \n#define nft_deactivate_next(__net, __obj)\t\t\t\\\n        (__obj)->genmask = nft_genmask_next(__net)\n\n \n#define nft_clear(__net, __obj)\t\t\t\t\t\\\n\t(__obj)->genmask &= ~nft_genmask_next(__net)\n#define nft_active_genmask(__obj, __genmask)\t\t\t\\\n\t!((__obj)->genmask & __genmask)\n\n \n\nstatic inline bool nft_set_elem_active(const struct nft_set_ext *ext,\n\t\t\t\t       u8 genmask)\n{\n\treturn !(ext->genmask & genmask);\n}\n\nstatic inline void nft_set_elem_change_active(const struct net *net,\n\t\t\t\t\t      const struct nft_set *set,\n\t\t\t\t\t      struct nft_set_ext *ext)\n{\n\text->genmask ^= nft_genmask_next(net);\n}\n\n#endif  \n\n#define NFT_SET_ELEM_DEAD_MASK\t(1 << 2)\n\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n#define NFT_SET_ELEM_DEAD_BIT\t2\n#elif defined(__BIG_ENDIAN_BITFIELD)\n#define NFT_SET_ELEM_DEAD_BIT\t(BITS_PER_LONG - BITS_PER_BYTE + 2)\n#else\n#error\n#endif\n\nstatic inline void nft_set_elem_dead(struct nft_set_ext *ext)\n{\n\tunsigned long *word = (unsigned long *)ext;\n\n\tBUILD_BUG_ON(offsetof(struct nft_set_ext, genmask) != 0);\n\tset_bit(NFT_SET_ELEM_DEAD_BIT, word);\n}\n\nstatic inline int nft_set_elem_is_dead(const struct nft_set_ext *ext)\n{\n\tunsigned long *word = (unsigned long *)ext;\n\n\tBUILD_BUG_ON(offsetof(struct nft_set_ext, genmask) != 0);\n\treturn test_bit(NFT_SET_ELEM_DEAD_BIT, word);\n}\n\n \nstruct nft_trans {\n\tstruct list_head\t\tlist;\n\tstruct list_head\t\tbinding_list;\n\tint\t\t\t\tmsg_type;\n\tbool\t\t\t\tput_net;\n\tstruct nft_ctx\t\t\tctx;\n\tchar\t\t\t\tdata[];\n};\n\nstruct nft_trans_rule {\n\tstruct nft_rule\t\t\t*rule;\n\tstruct nft_flow_rule\t\t*flow;\n\tu32\t\t\t\trule_id;\n\tbool\t\t\t\tbound;\n};\n\n#define nft_trans_rule(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->rule)\n#define nft_trans_flow_rule(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->flow)\n#define nft_trans_rule_id(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->rule_id)\n#define nft_trans_rule_bound(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->bound)\n\nstruct nft_trans_set {\n\tstruct nft_set\t\t\t*set;\n\tu32\t\t\t\tset_id;\n\tu32\t\t\t\tgc_int;\n\tu64\t\t\t\ttimeout;\n\tbool\t\t\t\tupdate;\n\tbool\t\t\t\tbound;\n\tu32\t\t\t\tsize;\n};\n\n#define nft_trans_set(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->set)\n#define nft_trans_set_id(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->set_id)\n#define nft_trans_set_bound(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->bound)\n#define nft_trans_set_update(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->update)\n#define nft_trans_set_timeout(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->timeout)\n#define nft_trans_set_gc_int(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->gc_int)\n#define nft_trans_set_size(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->size)\n\nstruct nft_trans_chain {\n\tstruct nft_chain\t\t*chain;\n\tbool\t\t\t\tupdate;\n\tchar\t\t\t\t*name;\n\tstruct nft_stats __percpu\t*stats;\n\tu8\t\t\t\tpolicy;\n\tbool\t\t\t\tbound;\n\tu32\t\t\t\tchain_id;\n\tstruct nft_base_chain\t\t*basechain;\n\tstruct list_head\t\thook_list;\n};\n\n#define nft_trans_chain(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->chain)\n#define nft_trans_chain_update(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->update)\n#define nft_trans_chain_name(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->name)\n#define nft_trans_chain_stats(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->stats)\n#define nft_trans_chain_policy(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->policy)\n#define nft_trans_chain_bound(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->bound)\n#define nft_trans_chain_id(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->chain_id)\n#define nft_trans_basechain(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->basechain)\n#define nft_trans_chain_hooks(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->hook_list)\n\nstruct nft_trans_table {\n\tbool\t\t\t\tupdate;\n};\n\n#define nft_trans_table_update(trans)\t\\\n\t(((struct nft_trans_table *)trans->data)->update)\n\nstruct nft_trans_elem {\n\tstruct nft_set\t\t\t*set;\n\tstruct nft_set_elem\t\telem;\n\tbool\t\t\t\tbound;\n};\n\n#define nft_trans_elem_set(trans)\t\\\n\t(((struct nft_trans_elem *)trans->data)->set)\n#define nft_trans_elem(trans)\t\\\n\t(((struct nft_trans_elem *)trans->data)->elem)\n#define nft_trans_elem_set_bound(trans)\t\\\n\t(((struct nft_trans_elem *)trans->data)->bound)\n\nstruct nft_trans_obj {\n\tstruct nft_object\t\t*obj;\n\tstruct nft_object\t\t*newobj;\n\tbool\t\t\t\tupdate;\n};\n\n#define nft_trans_obj(trans)\t\\\n\t(((struct nft_trans_obj *)trans->data)->obj)\n#define nft_trans_obj_newobj(trans) \\\n\t(((struct nft_trans_obj *)trans->data)->newobj)\n#define nft_trans_obj_update(trans)\t\\\n\t(((struct nft_trans_obj *)trans->data)->update)\n\nstruct nft_trans_flowtable {\n\tstruct nft_flowtable\t\t*flowtable;\n\tbool\t\t\t\tupdate;\n\tstruct list_head\t\thook_list;\n\tu32\t\t\t\tflags;\n};\n\n#define nft_trans_flowtable(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->flowtable)\n#define nft_trans_flowtable_update(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->update)\n#define nft_trans_flowtable_hooks(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->hook_list)\n#define nft_trans_flowtable_flags(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->flags)\n\n#define NFT_TRANS_GC_BATCHCOUNT\t256\n\nstruct nft_trans_gc {\n\tstruct list_head\tlist;\n\tstruct net\t\t*net;\n\tstruct nft_set\t\t*set;\n\tu32\t\t\tseq;\n\tu16\t\t\tcount;\n\tvoid\t\t\t*priv[NFT_TRANS_GC_BATCHCOUNT];\n\tstruct rcu_head\t\trcu;\n};\n\nstruct nft_trans_gc *nft_trans_gc_alloc(struct nft_set *set,\n\t\t\t\t\tunsigned int gc_seq, gfp_t gfp);\nvoid nft_trans_gc_destroy(struct nft_trans_gc *trans);\n\nstruct nft_trans_gc *nft_trans_gc_queue_async(struct nft_trans_gc *gc,\n\t\t\t\t\t      unsigned int gc_seq, gfp_t gfp);\nvoid nft_trans_gc_queue_async_done(struct nft_trans_gc *gc);\n\nstruct nft_trans_gc *nft_trans_gc_queue_sync(struct nft_trans_gc *gc, gfp_t gfp);\nvoid nft_trans_gc_queue_sync_done(struct nft_trans_gc *trans);\n\nvoid nft_trans_gc_elem_add(struct nft_trans_gc *gc, void *priv);\n\nstruct nft_trans_gc *nft_trans_gc_catchall_async(struct nft_trans_gc *gc,\n\t\t\t\t\t\t unsigned int gc_seq);\nstruct nft_trans_gc *nft_trans_gc_catchall_sync(struct nft_trans_gc *gc);\n\nvoid nft_setelem_data_deactivate(const struct net *net,\n\t\t\t\t const struct nft_set *set,\n\t\t\t\t struct nft_set_elem *elem);\n\nint __init nft_chain_filter_init(void);\nvoid nft_chain_filter_fini(void);\n\nvoid __init nft_chain_route_init(void);\nvoid nft_chain_route_fini(void);\n\nvoid nf_tables_trans_destroy_flush_work(void);\n\nint nf_msecs_to_jiffies64(const struct nlattr *nla, u64 *result);\n__be64 nf_jiffies64_to_msecs(u64 input);\n\n#ifdef CONFIG_MODULES\n__printf(2, 3) int nft_request_module(struct net *net, const char *fmt, ...);\n#else\nstatic inline int nft_request_module(struct net *net, const char *fmt, ...) { return -ENOENT; }\n#endif\n\nstruct nftables_pernet {\n\tstruct list_head\ttables;\n\tstruct list_head\tcommit_list;\n\tstruct list_head\tbinding_list;\n\tstruct list_head\tmodule_list;\n\tstruct list_head\tnotify_list;\n\tstruct mutex\t\tcommit_mutex;\n\tu64\t\t\ttable_handle;\n\tunsigned int\t\tbase_seq;\n\tunsigned int\t\tgc_seq;\n\tu8\t\t\tvalidate_state;\n};\n\nextern unsigned int nf_tables_net_id;\n\nstatic inline struct nftables_pernet *nft_pernet(const struct net *net)\n{\n\treturn net_generic(net, nf_tables_net_id);\n}\n\n#define __NFT_REDUCE_READONLY\t1UL\n#define NFT_REDUCE_READONLY\t(void *)__NFT_REDUCE_READONLY\n\nstatic inline bool nft_reduce_is_readonly(const struct nft_expr *expr)\n{\n\treturn expr->ops->reduce == NFT_REDUCE_READONLY;\n}\n\nvoid nft_reg_track_update(struct nft_regs_track *track,\n\t\t\t  const struct nft_expr *expr, u8 dreg, u8 len);\nvoid nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg, u8 len);\nvoid __nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg);\n\nstatic inline bool nft_reg_track_cmp(struct nft_regs_track *track,\n\t\t\t\t     const struct nft_expr *expr, u8 dreg)\n{\n\treturn track->regs[dreg].selector &&\n\t       track->regs[dreg].selector->ops == expr->ops &&\n\t       track->regs[dreg].num_reg == 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}