{
  "module_name": "nf_tables_ipv6.h",
  "hash_id": "c67c82f75f820f87397efa6a208c5ea15612c22fbcf50dcd23be8a37cedb2c9c",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netfilter/nf_tables_ipv6.h",
  "human_readable_source": " \n#ifndef _NF_TABLES_IPV6_H_\n#define _NF_TABLES_IPV6_H_\n\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <net/ipv6.h>\n#include <net/netfilter/nf_tables.h>\n\nstatic inline void nft_set_pktinfo_ipv6(struct nft_pktinfo *pkt)\n{\n\tunsigned int flags = IP6_FH_F_AUTH;\n\tint protohdr, thoff = 0;\n\tunsigned short frag_off;\n\n\tprotohdr = ipv6_find_hdr(pkt->skb, &thoff, -1, &frag_off, &flags);\n\tif (protohdr < 0 || thoff > U16_MAX) {\n\t\tnft_set_pktinfo_unspec(pkt);\n\t\treturn;\n\t}\n\n\tpkt->flags = NFT_PKTINFO_L4PROTO;\n\tpkt->tprot = protohdr;\n\tpkt->thoff = thoff;\n\tpkt->fragoff = frag_off;\n}\n\nstatic inline int __nft_set_pktinfo_ipv6_validate(struct nft_pktinfo *pkt)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tunsigned int flags = IP6_FH_F_AUTH;\n\tstruct ipv6hdr *ip6h, _ip6h;\n\tunsigned int thoff = 0;\n\tunsigned short frag_off;\n\tint protohdr;\n\tu32 pkt_len;\n\n\tip6h = skb_header_pointer(pkt->skb, skb_network_offset(pkt->skb),\n\t\t\t\t  sizeof(*ip6h), &_ip6h);\n\tif (!ip6h)\n\t\treturn -1;\n\n\tif (ip6h->version != 6)\n\t\treturn -1;\n\n\tpkt_len = ntohs(ip6h->payload_len);\n\tif (pkt_len + sizeof(*ip6h) > pkt->skb->len)\n\t\treturn -1;\n\n\tprotohdr = ipv6_find_hdr(pkt->skb, &thoff, -1, &frag_off, &flags);\n\tif (protohdr < 0 || thoff > U16_MAX)\n\t\treturn -1;\n\n\tpkt->flags = NFT_PKTINFO_L4PROTO;\n\tpkt->tprot = protohdr;\n\tpkt->thoff = thoff;\n\tpkt->fragoff = frag_off;\n\n\treturn 0;\n#else\n\treturn -1;\n#endif\n}\n\nstatic inline void nft_set_pktinfo_ipv6_validate(struct nft_pktinfo *pkt)\n{\n\tif (__nft_set_pktinfo_ipv6_validate(pkt) < 0)\n\t\tnft_set_pktinfo_unspec(pkt);\n}\n\nstatic inline int nft_set_pktinfo_ipv6_ingress(struct nft_pktinfo *pkt)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tunsigned int flags = IP6_FH_F_AUTH;\n\tunsigned short frag_off;\n\tunsigned int thoff = 0;\n\tstruct inet6_dev *idev;\n\tstruct ipv6hdr *ip6h;\n\tint protohdr;\n\tu32 pkt_len;\n\n\tif (!pskb_may_pull(pkt->skb, sizeof(*ip6h)))\n\t\treturn -1;\n\n\tip6h = ipv6_hdr(pkt->skb);\n\tif (ip6h->version != 6)\n\t\tgoto inhdr_error;\n\n\tpkt_len = ntohs(ip6h->payload_len);\n\tif (pkt_len + sizeof(*ip6h) > pkt->skb->len) {\n\t\tidev = __in6_dev_get(nft_in(pkt));\n\t\t__IP6_INC_STATS(nft_net(pkt), idev, IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\treturn -1;\n\t}\n\n\tprotohdr = ipv6_find_hdr(pkt->skb, &thoff, -1, &frag_off, &flags);\n\tif (protohdr < 0 || thoff > U16_MAX)\n\t\tgoto inhdr_error;\n\n\tpkt->flags = NFT_PKTINFO_L4PROTO;\n\tpkt->tprot = protohdr;\n\tpkt->thoff = thoff;\n\tpkt->fragoff = frag_off;\n\n\treturn 0;\n\ninhdr_error:\n\tidev = __in6_dev_get(nft_in(pkt));\n\t__IP6_INC_STATS(nft_net(pkt), idev, IPSTATS_MIB_INHDRERRORS);\n\treturn -1;\n#else\n\treturn -1;\n#endif\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}