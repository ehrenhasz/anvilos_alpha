{
  "module_name": "br_netfilter.h",
  "hash_id": "14fcf970aef2596d51dfa5f8400e6c9a6b8ba55c4a67b63baac5afb6441d94d5",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netfilter/br_netfilter.h",
  "human_readable_source": " \n#ifndef _BR_NETFILTER_H_\n#define _BR_NETFILTER_H_\n\n#include <linux/netfilter.h>\n\n#include \"../../../net/bridge/br_private.h\"\n\nstatic inline struct nf_bridge_info *nf_bridge_alloc(struct sk_buff *skb)\n{\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\tstruct nf_bridge_info *b = skb_ext_add(skb, SKB_EXT_BRIDGE_NF);\n\n\tif (b)\n\t\tmemset(b, 0, sizeof(*b));\n\n\treturn b;\n#else\n\treturn NULL;\n#endif\n}\n\nvoid nf_bridge_update_protocol(struct sk_buff *skb);\n\nint br_nf_hook_thresh(unsigned int hook, struct net *net, struct sock *sk,\n\t\t      struct sk_buff *skb, struct net_device *indev,\n\t\t      struct net_device *outdev,\n\t\t      int (*okfn)(struct net *, struct sock *,\n\t\t\t\t  struct sk_buff *));\n\nunsigned int nf_bridge_encap_header_len(const struct sk_buff *skb);\n\nstatic inline void nf_bridge_push_encap_header(struct sk_buff *skb)\n{\n\tunsigned int len = nf_bridge_encap_header_len(skb);\n\n\tskb_push(skb, len);\n\tskb->network_header -= len;\n}\n\nint br_nf_pre_routing_finish_bridge(struct net *net, struct sock *sk, struct sk_buff *skb);\n\nstatic inline struct rtable *bridge_parent_rtable(const struct net_device *dev)\n{\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\tstruct net_bridge_port *port;\n\n\tport = br_port_get_rcu(dev);\n\treturn port ? &port->br->fake_rtable : NULL;\n#else\n\treturn NULL;\n#endif\n}\n\nstruct net_device *setup_pre_routing(struct sk_buff *skb,\n\t\t\t\t     const struct net *net);\n\n#if IS_ENABLED(CONFIG_IPV6)\nint br_validate_ipv6(struct net *net, struct sk_buff *skb);\nunsigned int br_nf_pre_routing_ipv6(void *priv,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    const struct nf_hook_state *state);\n#else\nstatic inline int br_validate_ipv6(struct net *net, struct sk_buff *skb)\n{\n\treturn -1;\n}\n\nstatic inline unsigned int\nbr_nf_pre_routing_ipv6(void *priv, struct sk_buff *skb,\n\t\t       const struct nf_hook_state *state)\n{\n\treturn NF_ACCEPT;\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}