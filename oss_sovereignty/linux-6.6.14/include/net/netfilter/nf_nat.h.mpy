{
  "module_name": "nf_nat.h",
  "hash_id": "1a83d5951c03bd06f513e9c51d10845f1ee67e6a283ee0d7a3dc317c94f9a703",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netfilter/nf_nat.h",
  "human_readable_source": " \n#ifndef _NF_NAT_H\n#define _NF_NAT_H\n\n#include <linux/list.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter/nf_conntrack_pptp.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_extend.h>\n#include <net/netfilter/nf_conntrack_tuple.h>\n#include <uapi/linux/netfilter/nf_nat.h>\n\nenum nf_nat_manip_type {\n\tNF_NAT_MANIP_SRC,\n\tNF_NAT_MANIP_DST\n};\n\n \n#define HOOK2MANIP(hooknum) ((hooknum) != NF_INET_POST_ROUTING && \\\n\t\t\t     (hooknum) != NF_INET_LOCAL_IN)\n\n \nunion nf_conntrack_nat_help {\n\t \n#if IS_ENABLED(CONFIG_NF_NAT_PPTP)\n\tstruct nf_nat_pptp nat_pptp_info;\n#endif\n};\n\n \nstruct nf_conn_nat {\n\tunion nf_conntrack_nat_help help;\n#if IS_ENABLED(CONFIG_NF_NAT_MASQUERADE)\n\tint masq_index;\n#endif\n};\n\n \nunsigned int nf_nat_setup_info(struct nf_conn *ct,\n\t\t\t       const struct nf_nat_range2 *range,\n\t\t\t       enum nf_nat_manip_type maniptype);\n\nextern unsigned int nf_nat_alloc_null_binding(struct nf_conn *ct,\n\t\t\t\t\t      unsigned int hooknum);\n\nstruct nf_conn_nat *nf_ct_nat_ext_add(struct nf_conn *ct);\n\nstatic inline struct nf_conn_nat *nfct_nat(const struct nf_conn *ct)\n{\n#if IS_ENABLED(CONFIG_NF_NAT)\n\treturn nf_ct_ext_find(ct, NF_CT_EXT_NAT);\n#else\n\treturn NULL;\n#endif\n}\n\nstatic inline bool nf_nat_oif_changed(unsigned int hooknum,\n\t\t\t\t      enum ip_conntrack_info ctinfo,\n\t\t\t\t      struct nf_conn_nat *nat,\n\t\t\t\t      const struct net_device *out)\n{\n#if IS_ENABLED(CONFIG_NF_NAT_MASQUERADE)\n\treturn nat && nat->masq_index && hooknum == NF_INET_POST_ROUTING &&\n\t       CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL &&\n\t       nat->masq_index != out->ifindex;\n#else\n\treturn false;\n#endif\n}\n\nint nf_nat_register_fn(struct net *net, u8 pf, const struct nf_hook_ops *ops,\n\t\t       const struct nf_hook_ops *nat_ops, unsigned int ops_count);\nvoid nf_nat_unregister_fn(struct net *net, u8 pf, const struct nf_hook_ops *ops,\n\t\t\t  unsigned int ops_count);\n\nunsigned int nf_nat_packet(struct nf_conn *ct, enum ip_conntrack_info ctinfo,\n\t\t\t   unsigned int hooknum, struct sk_buff *skb);\n\nunsigned int nf_nat_manip_pkt(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t      enum nf_nat_manip_type mtype,\n\t\t\t      enum ip_conntrack_dir dir);\nvoid nf_nat_csum_recalc(struct sk_buff *skb,\n\t\t\tu8 nfproto, u8 proto, void *data, __sum16 *check,\n\t\t\tint datalen, int oldlen);\n\nint nf_nat_icmp_reply_translation(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t\t  enum ip_conntrack_info ctinfo,\n\t\t\t\t  unsigned int hooknum);\n\nint nf_nat_icmpv6_reply_translation(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t\t    enum ip_conntrack_info ctinfo,\n\t\t\t\t    unsigned int hooknum, unsigned int hdrlen);\n\nint nf_nat_ipv4_register_fn(struct net *net, const struct nf_hook_ops *ops);\nvoid nf_nat_ipv4_unregister_fn(struct net *net, const struct nf_hook_ops *ops);\n\nint nf_nat_ipv6_register_fn(struct net *net, const struct nf_hook_ops *ops);\nvoid nf_nat_ipv6_unregister_fn(struct net *net, const struct nf_hook_ops *ops);\n\nint nf_nat_inet_register_fn(struct net *net, const struct nf_hook_ops *ops);\nvoid nf_nat_inet_unregister_fn(struct net *net, const struct nf_hook_ops *ops);\n\nunsigned int\nnf_nat_inet_fn(void *priv, struct sk_buff *skb,\n\t       const struct nf_hook_state *state);\n\nint nf_ct_nat(struct sk_buff *skb, struct nf_conn *ct,\n\t      enum ip_conntrack_info ctinfo, int *action,\n\t      const struct nf_nat_range2 *range, bool commit);\n\nstatic inline int nf_nat_initialized(const struct nf_conn *ct,\n\t\t\t\t     enum nf_nat_manip_type manip)\n{\n\tif (manip == NF_NAT_MANIP_SRC)\n\t\treturn ct->status & IPS_SRC_NAT_DONE;\n\telse\n\t\treturn ct->status & IPS_DST_NAT_DONE;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}