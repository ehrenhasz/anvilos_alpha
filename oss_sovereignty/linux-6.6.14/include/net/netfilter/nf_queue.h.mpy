{
  "module_name": "nf_queue.h",
  "hash_id": "6f7945595cf1094283d0db8e6470a999214242f5699ed87df07ffd969c5fe9cd",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netfilter/nf_queue.h",
  "human_readable_source": " \n#ifndef _NF_QUEUE_H\n#define _NF_QUEUE_H\n\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/jhash.h>\n#include <linux/netfilter.h>\n#include <linux/skbuff.h>\n\n \nstruct nf_queue_entry {\n\tstruct list_head\tlist;\n\tstruct sk_buff\t\t*skb;\n\tunsigned int\t\tid;\n\tunsigned int\t\thook_index;\t \n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\tstruct net_device\t*physin;\n\tstruct net_device\t*physout;\n#endif\n\tstruct nf_hook_state\tstate;\n\tu16\t\t\tsize;  \n\n\t \n};\n\n#define nf_queue_entry_reroute(x) ((void *)x + sizeof(struct nf_queue_entry))\n\n \nstruct nf_queue_handler {\n\tint\t\t(*outfn)(struct nf_queue_entry *entry,\n\t\t\t\t unsigned int queuenum);\n\tvoid\t\t(*nf_hook_drop)(struct net *net);\n};\n\nvoid nf_register_queue_handler(const struct nf_queue_handler *qh);\nvoid nf_unregister_queue_handler(void);\nvoid nf_reinject(struct nf_queue_entry *entry, unsigned int verdict);\n\nbool nf_queue_entry_get_refs(struct nf_queue_entry *entry);\nvoid nf_queue_entry_free(struct nf_queue_entry *entry);\n\nstatic inline void init_hashrandom(u32 *jhash_initval)\n{\n\twhile (*jhash_initval == 0)\n\t\t*jhash_initval = get_random_u32();\n}\n\nstatic inline u32 hash_v4(const struct iphdr *iph, u32 initval)\n{\n\t \n\tif ((__force u32)iph->saddr < (__force u32)iph->daddr)\n\t\treturn jhash_3words((__force u32)iph->saddr,\n\t\t\t(__force u32)iph->daddr, iph->protocol, initval);\n\n\treturn jhash_3words((__force u32)iph->daddr,\n\t\t\t(__force u32)iph->saddr, iph->protocol, initval);\n}\n\nstatic inline u32 hash_v6(const struct ipv6hdr *ip6h, u32 initval)\n{\n\tu32 a, b, c;\n\n\tif ((__force u32)ip6h->saddr.s6_addr32[3] <\n\t    (__force u32)ip6h->daddr.s6_addr32[3]) {\n\t\ta = (__force u32) ip6h->saddr.s6_addr32[3];\n\t\tb = (__force u32) ip6h->daddr.s6_addr32[3];\n\t} else {\n\t\tb = (__force u32) ip6h->saddr.s6_addr32[3];\n\t\ta = (__force u32) ip6h->daddr.s6_addr32[3];\n\t}\n\n\tif ((__force u32)ip6h->saddr.s6_addr32[1] <\n\t    (__force u32)ip6h->daddr.s6_addr32[1])\n\t\tc = (__force u32) ip6h->saddr.s6_addr32[1];\n\telse\n\t\tc = (__force u32) ip6h->daddr.s6_addr32[1];\n\n\treturn jhash_3words(a, b, c, initval);\n}\n\nstatic inline u32 hash_bridge(const struct sk_buff *skb, u32 initval)\n{\n\tstruct ipv6hdr *ip6h, _ip6h;\n\tstruct iphdr *iph, _iph;\n\n\tswitch (eth_hdr(skb)->h_proto) {\n\tcase htons(ETH_P_IP):\n\t\tiph = skb_header_pointer(skb, skb_network_offset(skb),\n\t\t\t\t\t sizeof(*iph), &_iph);\n\t\tif (iph)\n\t\t\treturn hash_v4(iph, initval);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tip6h = skb_header_pointer(skb, skb_network_offset(skb),\n\t\t\t\t\t  sizeof(*ip6h), &_ip6h);\n\t\tif (ip6h)\n\t\t\treturn hash_v6(ip6h, initval);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline u32\nnfqueue_hash(const struct sk_buff *skb, u16 queue, u16 queues_total, u8 family,\n\t     u32 initval)\n{\n\tswitch (family) {\n\tcase NFPROTO_IPV4:\n\t\tqueue += reciprocal_scale(hash_v4(ip_hdr(skb), initval),\n\t\t\t\t\t  queues_total);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tqueue += reciprocal_scale(hash_v6(ipv6_hdr(skb), initval),\n\t\t\t\t\t  queues_total);\n\t\tbreak;\n\tcase NFPROTO_BRIDGE:\n\t\tqueue += reciprocal_scale(hash_bridge(skb, initval),\n\t\t\t\t\t  queues_total);\n\t\tbreak;\n\t}\n\n\treturn queue;\n}\n\nint nf_queue(struct sk_buff *skb, struct nf_hook_state *state,\n\t     unsigned int index, unsigned int verdict);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}