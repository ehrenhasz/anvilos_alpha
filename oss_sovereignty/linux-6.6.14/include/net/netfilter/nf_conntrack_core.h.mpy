{
  "module_name": "nf_conntrack_core.h",
  "hash_id": "dd8532ce67fd18b129a64b9cf77448b2a0f66689dab0656cab922c6bcd34f9d2",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netfilter/nf_conntrack_core.h",
  "human_readable_source": " \n \n\n#ifndef _NF_CONNTRACK_CORE_H\n#define _NF_CONNTRACK_CORE_H\n\n#include <linux/netfilter.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n\n \n\nunsigned int nf_conntrack_in(struct sk_buff *skb,\n\t\t\t     const struct nf_hook_state *state);\n\nint nf_conntrack_init_net(struct net *net);\nvoid nf_conntrack_cleanup_net(struct net *net);\nvoid nf_conntrack_cleanup_net_list(struct list_head *net_exit_list);\n\nvoid nf_conntrack_proto_pernet_init(struct net *net);\n\nint nf_conntrack_proto_init(void);\nvoid nf_conntrack_proto_fini(void);\n\nint nf_conntrack_init_start(void);\nvoid nf_conntrack_cleanup_start(void);\n\nvoid nf_conntrack_init_end(void);\nvoid nf_conntrack_cleanup_end(void);\n\nbool nf_ct_invert_tuple(struct nf_conntrack_tuple *inverse,\n\t\t\tconst struct nf_conntrack_tuple *orig);\n\n \nstruct nf_conntrack_tuple_hash *\nnf_conntrack_find_get(struct net *net,\n\t\t      const struct nf_conntrack_zone *zone,\n\t\t      const struct nf_conntrack_tuple *tuple);\n\nint __nf_conntrack_confirm(struct sk_buff *skb);\n\n \nstatic inline int nf_conntrack_confirm(struct sk_buff *skb)\n{\n\tstruct nf_conn *ct = (struct nf_conn *)skb_nfct(skb);\n\tint ret = NF_ACCEPT;\n\n\tif (ct) {\n\t\tif (!nf_ct_is_confirmed(ct)) {\n\t\t\tret = __nf_conntrack_confirm(skb);\n\n\t\t\tif (ret == NF_ACCEPT)\n\t\t\t\tct = (struct nf_conn *)skb_nfct(skb);\n\t\t}\n\n\t\tif (ret == NF_ACCEPT && nf_ct_ecache_exist(ct))\n\t\t\tnf_ct_deliver_cached_events(ct);\n\t}\n\treturn ret;\n}\n\nunsigned int nf_confirm(void *priv, struct sk_buff *skb, const struct nf_hook_state *state);\n\nvoid print_tuple(struct seq_file *s, const struct nf_conntrack_tuple *tuple,\n\t\t const struct nf_conntrack_l4proto *proto);\n\n#define CONNTRACK_LOCKS 1024\n\nextern spinlock_t nf_conntrack_locks[CONNTRACK_LOCKS];\nvoid nf_conntrack_lock(spinlock_t *lock);\n\nextern spinlock_t nf_conntrack_expect_lock;\n\n \n\nstatic inline void __nf_ct_set_timeout(struct nf_conn *ct, u64 timeout)\n{\n\tif (timeout > INT_MAX)\n\t\ttimeout = INT_MAX;\n\n\tif (nf_ct_is_confirmed(ct))\n\t\tWRITE_ONCE(ct->timeout, nfct_time_stamp + (u32)timeout);\n\telse\n\t\tct->timeout = (u32)timeout;\n}\n\nint __nf_ct_change_timeout(struct nf_conn *ct, u64 cta_timeout);\nvoid __nf_ct_change_status(struct nf_conn *ct, unsigned long on, unsigned long off);\nint nf_ct_change_status_common(struct nf_conn *ct, unsigned int status);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}