{
  "module_name": "nf_conntrack.h",
  "hash_id": "5b4ea20b837f134faf64a5497e9ae6382cc9414b26002a535988bab6c5610e01",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netfilter/nf_conntrack.h",
  "human_readable_source": " \n \n\n#ifndef _NF_CONNTRACK_H\n#define _NF_CONNTRACK_H\n\n#include <linux/bitops.h>\n#include <linux/compiler.h>\n\n#include <linux/netfilter/nf_conntrack_common.h>\n#include <linux/netfilter/nf_conntrack_tcp.h>\n#include <linux/netfilter/nf_conntrack_dccp.h>\n#include <linux/netfilter/nf_conntrack_sctp.h>\n#include <linux/netfilter/nf_conntrack_proto_gre.h>\n\n#include <net/netfilter/nf_conntrack_tuple.h>\n\nstruct nf_ct_udp {\n\tunsigned long\tstream_ts;\n};\n\n \nunion nf_conntrack_proto {\n\t \n\tstruct nf_ct_dccp dccp;\n\tstruct ip_ct_sctp sctp;\n\tstruct ip_ct_tcp tcp;\n\tstruct nf_ct_udp udp;\n\tstruct nf_ct_gre gre;\n\tunsigned int tmpl_padto;\n};\n\nunion nf_conntrack_expect_proto {\n\t \n};\n\nstruct nf_conntrack_net_ecache {\n\tstruct delayed_work dwork;\n\tspinlock_t dying_lock;\n\tstruct hlist_nulls_head dying_list;\n};\n\nstruct nf_conntrack_net {\n\t \n\tatomic_t count;\n\tunsigned int expect_count;\n\n\t \n\tunsigned int users4;\n\tunsigned int users6;\n\tunsigned int users_bridge;\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table_header\t*sysctl_header;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\tstruct nf_conntrack_net_ecache ecache;\n#endif\n};\n\n#include <linux/types.h>\n#include <linux/skbuff.h>\n\n#include <net/netfilter/ipv4/nf_conntrack_ipv4.h>\n#include <net/netfilter/ipv6/nf_conntrack_ipv6.h>\n\nstruct nf_conn {\n\t \n\tstruct nf_conntrack ct_general;\n\n\tspinlock_t\tlock;\n\t \n\tu32 timeout;\n\n#ifdef CONFIG_NF_CONNTRACK_ZONES\n\tstruct nf_conntrack_zone zone;\n#endif\n\t \n\t \n\tstruct nf_conntrack_tuple_hash tuplehash[IP_CT_DIR_MAX];\n\n\t \n\tunsigned long status;\n\n\tpossible_net_t ct_net;\n\n#if IS_ENABLED(CONFIG_NF_NAT)\n\tstruct hlist_node\tnat_bysource;\n#endif\n\t \n\tstruct { } __nfct_init_offset;\n\n\t \n\tstruct nf_conn *master;\n\n#if defined(CONFIG_NF_CONNTRACK_MARK)\n\tu_int32_t mark;\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\n\tu_int32_t secmark;\n#endif\n\n\t \n\tstruct nf_ct_ext *ext;\n\n\t \n\tunion nf_conntrack_proto proto;\n};\n\nstatic inline struct nf_conn *\nnf_ct_to_nf_conn(const struct nf_conntrack *nfct)\n{\n\treturn container_of(nfct, struct nf_conn, ct_general);\n}\n\nstatic inline struct nf_conn *\nnf_ct_tuplehash_to_ctrack(const struct nf_conntrack_tuple_hash *hash)\n{\n\treturn container_of(hash, struct nf_conn,\n\t\t\t    tuplehash[hash->tuple.dst.dir]);\n}\n\nstatic inline u_int16_t nf_ct_l3num(const struct nf_conn *ct)\n{\n\treturn ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.l3num;\n}\n\nstatic inline u_int8_t nf_ct_protonum(const struct nf_conn *ct)\n{\n\treturn ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum;\n}\n\n#define nf_ct_tuple(ct, dir) (&(ct)->tuplehash[dir].tuple)\n\n \n#define master_ct(conntr) (conntr->master)\n\nextern struct net init_net;\n\nstatic inline struct net *nf_ct_net(const struct nf_conn *ct)\n{\n\treturn read_pnet(&ct->ct_net);\n}\n\n \nvoid nf_conntrack_alter_reply(struct nf_conn *ct,\n\t\t\t      const struct nf_conntrack_tuple *newreply);\n\n \nint nf_conntrack_tuple_taken(const struct nf_conntrack_tuple *tuple,\n\t\t\t     const struct nf_conn *ignored_conntrack);\n\n \nstatic inline struct nf_conn *\nnf_ct_get(const struct sk_buff *skb, enum ip_conntrack_info *ctinfo)\n{\n\tunsigned long nfct = skb_get_nfct(skb);\n\n\t*ctinfo = nfct & NFCT_INFOMASK;\n\treturn (struct nf_conn *)(nfct & NFCT_PTRMASK);\n}\n\nvoid nf_ct_destroy(struct nf_conntrack *nfct);\n\nvoid nf_conntrack_tcp_set_closing(struct nf_conn *ct);\n\n \nstatic inline void nf_ct_put(struct nf_conn *ct)\n{\n\tif (ct && refcount_dec_and_test(&ct->ct_general.use))\n\t\tnf_ct_destroy(&ct->ct_general);\n}\n\n \nint nf_ct_netns_get(struct net *net, u8 nfproto);\nvoid nf_ct_netns_put(struct net *net, u8 nfproto);\n\n \nvoid *nf_ct_alloc_hashtable(unsigned int *sizep, int nulls);\n\nint nf_conntrack_hash_check_insert(struct nf_conn *ct);\nbool nf_ct_delete(struct nf_conn *ct, u32 pid, int report);\n\nbool nf_ct_get_tuplepr(const struct sk_buff *skb, unsigned int nhoff,\n\t\t       u_int16_t l3num, struct net *net,\n\t\t       struct nf_conntrack_tuple *tuple);\n\nvoid __nf_ct_refresh_acct(struct nf_conn *ct, enum ip_conntrack_info ctinfo,\n\t\t\t  const struct sk_buff *skb,\n\t\t\t  u32 extra_jiffies, bool do_acct);\n\n \nstatic inline void nf_ct_refresh_acct(struct nf_conn *ct,\n\t\t\t\t      enum ip_conntrack_info ctinfo,\n\t\t\t\t      const struct sk_buff *skb,\n\t\t\t\t      u32 extra_jiffies)\n{\n\t__nf_ct_refresh_acct(ct, ctinfo, skb, extra_jiffies, true);\n}\n\n \nstatic inline void nf_ct_refresh(struct nf_conn *ct,\n\t\t\t\t const struct sk_buff *skb,\n\t\t\t\t u32 extra_jiffies)\n{\n\t__nf_ct_refresh_acct(ct, 0, skb, extra_jiffies, false);\n}\n\n \nbool nf_ct_kill_acct(struct nf_conn *ct, enum ip_conntrack_info ctinfo,\n\t\t     const struct sk_buff *skb);\n\n \nstatic inline bool nf_ct_kill(struct nf_conn *ct)\n{\n\treturn nf_ct_delete(ct, 0, 0);\n}\n\nstruct nf_ct_iter_data {\n\tstruct net *net;\n\tvoid *data;\n\tu32 portid;\n\tint report;\n};\n\n \nvoid nf_ct_iterate_cleanup_net(int (*iter)(struct nf_conn *i, void *data),\n\t\t\t       const struct nf_ct_iter_data *iter_data);\n\n \nvoid nf_ct_iterate_destroy(int (*iter)(struct nf_conn *i, void *data),\n\t\t\t   void *data);\n\nstruct nf_conntrack_zone;\n\nvoid nf_conntrack_free(struct nf_conn *ct);\nstruct nf_conn *nf_conntrack_alloc(struct net *net,\n\t\t\t\t   const struct nf_conntrack_zone *zone,\n\t\t\t\t   const struct nf_conntrack_tuple *orig,\n\t\t\t\t   const struct nf_conntrack_tuple *repl,\n\t\t\t\t   gfp_t gfp);\n\nstatic inline int nf_ct_is_template(const struct nf_conn *ct)\n{\n\treturn test_bit(IPS_TEMPLATE_BIT, &ct->status);\n}\n\n \nstatic inline int nf_ct_is_confirmed(const struct nf_conn *ct)\n{\n\treturn test_bit(IPS_CONFIRMED_BIT, &ct->status);\n}\n\nstatic inline int nf_ct_is_dying(const struct nf_conn *ct)\n{\n\treturn test_bit(IPS_DYING_BIT, &ct->status);\n}\n\n \nstatic inline bool nf_is_loopback_packet(const struct sk_buff *skb)\n{\n\treturn skb->dev && skb->skb_iif && skb->dev->flags & IFF_LOOPBACK;\n}\n\n#define nfct_time_stamp ((u32)(jiffies))\n\n \nstatic inline unsigned long nf_ct_expires(const struct nf_conn *ct)\n{\n\ts32 timeout = READ_ONCE(ct->timeout) - nfct_time_stamp;\n\n\treturn max(timeout, 0);\n}\n\nstatic inline bool nf_ct_is_expired(const struct nf_conn *ct)\n{\n\treturn (__s32)(READ_ONCE(ct->timeout) - nfct_time_stamp) <= 0;\n}\n\n \nstatic inline bool nf_ct_should_gc(const struct nf_conn *ct)\n{\n\treturn nf_ct_is_expired(ct) && nf_ct_is_confirmed(ct) &&\n\t       !nf_ct_is_dying(ct);\n}\n\n#define\tNF_CT_DAY\t(86400 * HZ)\n\n \nstatic inline void nf_ct_offload_timeout(struct nf_conn *ct)\n{\n\tif (nf_ct_expires(ct) < NF_CT_DAY / 2)\n\t\tWRITE_ONCE(ct->timeout, nfct_time_stamp + NF_CT_DAY);\n}\n\nstruct kernel_param;\n\nint nf_conntrack_set_hashsize(const char *val, const struct kernel_param *kp);\nint nf_conntrack_hash_resize(unsigned int hashsize);\n\nextern struct hlist_nulls_head *nf_conntrack_hash;\nextern unsigned int nf_conntrack_htable_size;\nextern seqcount_spinlock_t nf_conntrack_generation;\nextern unsigned int nf_conntrack_max;\n\n \nstatic inline void\nnf_conntrack_get_ht(struct hlist_nulls_head **hash, unsigned int *hsize)\n{\n\tstruct hlist_nulls_head *hptr;\n\tunsigned int sequence, hsz;\n\n\tdo {\n\t\tsequence = read_seqcount_begin(&nf_conntrack_generation);\n\t\thsz = nf_conntrack_htable_size;\n\t\thptr = nf_conntrack_hash;\n\t} while (read_seqcount_retry(&nf_conntrack_generation, sequence));\n\n\t*hash = hptr;\n\t*hsize = hsz;\n}\n\nstruct nf_conn *nf_ct_tmpl_alloc(struct net *net,\n\t\t\t\t const struct nf_conntrack_zone *zone,\n\t\t\t\t gfp_t flags);\nvoid nf_ct_tmpl_free(struct nf_conn *tmpl);\n\nu32 nf_ct_get_id(const struct nf_conn *ct);\nu32 nf_conntrack_count(const struct net *net);\n\nstatic inline void\nnf_ct_set(struct sk_buff *skb, struct nf_conn *ct, enum ip_conntrack_info info)\n{\n\tskb_set_nfct(skb, (unsigned long)ct | info);\n}\n\nextern unsigned int nf_conntrack_net_id;\n\nstatic inline struct nf_conntrack_net *nf_ct_pernet(const struct net *net)\n{\n\treturn net_generic(net, nf_conntrack_net_id);\n}\n\nint nf_ct_skb_network_trim(struct sk_buff *skb, int family);\nint nf_ct_handle_fragments(struct net *net, struct sk_buff *skb,\n\t\t\t   u16 zone, u8 family, u8 *proto, u16 *mru);\n\n#define NF_CT_STAT_INC(net, count)\t  __this_cpu_inc((net)->ct.stat->count)\n#define NF_CT_STAT_INC_ATOMIC(net, count) this_cpu_inc((net)->ct.stat->count)\n#define NF_CT_STAT_ADD_ATOMIC(net, count, v) this_cpu_add((net)->ct.stat->count, (v))\n\n#define MODULE_ALIAS_NFCT_HELPER(helper) \\\n        MODULE_ALIAS(\"nfct-helper-\" helper)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}