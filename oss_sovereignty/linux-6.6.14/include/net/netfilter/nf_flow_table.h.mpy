{
  "module_name": "nf_flow_table.h",
  "hash_id": "27b2b06812de6a454247a09f345ca3609a2131452bd1b5b268ba9c4078958713",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netfilter/nf_flow_table.h",
  "human_readable_source": "#ifndef _NF_FLOW_TABLE_H\n#define _NF_FLOW_TABLE_H\n\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/rhashtable-types.h>\n#include <linux/rcupdate.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_conntrack_tuple_common.h>\n#include <net/flow_offload.h>\n#include <net/dst.h>\n#include <linux/if_pppox.h>\n#include <linux/ppp_defs.h>\n\nstruct nf_flowtable;\nstruct nf_flow_rule;\nstruct flow_offload;\nenum flow_offload_tuple_dir;\n\nstruct nf_flow_key {\n\tstruct flow_dissector_key_meta\t\t\tmeta;\n\tstruct flow_dissector_key_control\t\tcontrol;\n\tstruct flow_dissector_key_control\t\tenc_control;\n\tstruct flow_dissector_key_basic\t\t\tbasic;\n\tstruct flow_dissector_key_vlan\t\t\tvlan;\n\tstruct flow_dissector_key_vlan\t\t\tcvlan;\n\tunion {\n\t\tstruct flow_dissector_key_ipv4_addrs\tipv4;\n\t\tstruct flow_dissector_key_ipv6_addrs\tipv6;\n\t};\n\tstruct flow_dissector_key_keyid\t\t\tenc_key_id;\n\tunion {\n\t\tstruct flow_dissector_key_ipv4_addrs\tenc_ipv4;\n\t\tstruct flow_dissector_key_ipv6_addrs\tenc_ipv6;\n\t};\n\tstruct flow_dissector_key_tcp\t\t\ttcp;\n\tstruct flow_dissector_key_ports\t\t\ttp;\n} __aligned(BITS_PER_LONG / 8);  \n\nstruct nf_flow_match {\n\tstruct flow_dissector\tdissector;\n\tstruct nf_flow_key\tkey;\n\tstruct nf_flow_key\tmask;\n};\n\nstruct nf_flow_rule {\n\tstruct nf_flow_match\tmatch;\n\tstruct flow_rule\t*rule;\n};\n\nstruct nf_flowtable_type {\n\tstruct list_head\t\tlist;\n\tint\t\t\t\tfamily;\n\tint\t\t\t\t(*init)(struct nf_flowtable *ft);\n\tbool\t\t\t\t(*gc)(const struct flow_offload *flow);\n\tint\t\t\t\t(*setup)(struct nf_flowtable *ft,\n\t\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t\t enum flow_block_command cmd);\n\tint\t\t\t\t(*action)(struct net *net,\n\t\t\t\t\t\t  struct flow_offload *flow,\n\t\t\t\t\t\t  enum flow_offload_tuple_dir dir,\n\t\t\t\t\t\t  struct nf_flow_rule *flow_rule);\n\tvoid\t\t\t\t(*free)(struct nf_flowtable *ft);\n\tvoid\t\t\t\t(*get)(struct nf_flowtable *ft);\n\tvoid\t\t\t\t(*put)(struct nf_flowtable *ft);\n\tnf_hookfn\t\t\t*hook;\n\tstruct module\t\t\t*owner;\n};\n\nenum nf_flowtable_flags {\n\tNF_FLOWTABLE_HW_OFFLOAD\t\t= 0x1,\t \n\tNF_FLOWTABLE_COUNTER\t\t= 0x2,\t \n};\n\nstruct nf_flowtable {\n\tstruct list_head\t\tlist;\n\tstruct rhashtable\t\trhashtable;\n\tint\t\t\t\tpriority;\n\tconst struct nf_flowtable_type\t*type;\n\tstruct delayed_work\t\tgc_work;\n\tunsigned int\t\t\tflags;\n\tstruct flow_block\t\tflow_block;\n\tstruct rw_semaphore\t\tflow_block_lock;  \n\tpossible_net_t\t\t\tnet;\n};\n\nstatic inline bool nf_flowtable_hw_offload(struct nf_flowtable *flowtable)\n{\n\treturn flowtable->flags & NF_FLOWTABLE_HW_OFFLOAD;\n}\n\nenum flow_offload_tuple_dir {\n\tFLOW_OFFLOAD_DIR_ORIGINAL = IP_CT_DIR_ORIGINAL,\n\tFLOW_OFFLOAD_DIR_REPLY = IP_CT_DIR_REPLY,\n};\n#define FLOW_OFFLOAD_DIR_MAX\tIP_CT_DIR_MAX\n\nenum flow_offload_xmit_type {\n\tFLOW_OFFLOAD_XMIT_UNSPEC\t= 0,\n\tFLOW_OFFLOAD_XMIT_NEIGH,\n\tFLOW_OFFLOAD_XMIT_XFRM,\n\tFLOW_OFFLOAD_XMIT_DIRECT,\n\tFLOW_OFFLOAD_XMIT_TC,\n};\n\n#define NF_FLOW_TABLE_ENCAP_MAX\t\t2\n\nstruct flow_offload_tuple {\n\tunion {\n\t\tstruct in_addr\t\tsrc_v4;\n\t\tstruct in6_addr\t\tsrc_v6;\n\t};\n\tunion {\n\t\tstruct in_addr\t\tdst_v4;\n\t\tstruct in6_addr\t\tdst_v6;\n\t};\n\tstruct {\n\t\t__be16\t\t\tsrc_port;\n\t\t__be16\t\t\tdst_port;\n\t};\n\n\tint\t\t\t\tiifidx;\n\n\tu8\t\t\t\tl3proto;\n\tu8\t\t\t\tl4proto;\n\tstruct {\n\t\tu16\t\t\tid;\n\t\t__be16\t\t\tproto;\n\t} encap[NF_FLOW_TABLE_ENCAP_MAX];\n\n\t \n\tstruct { }\t\t\t__hash;\n\n\tu8\t\t\t\tdir:2,\n\t\t\t\t\txmit_type:3,\n\t\t\t\t\tencap_num:2,\n\t\t\t\t\tin_vlan_ingress:2;\n\tu16\t\t\t\tmtu;\n\tunion {\n\t\tstruct {\n\t\t\tstruct dst_entry *dst_cache;\n\t\t\tu32\t\tdst_cookie;\n\t\t};\n\t\tstruct {\n\t\t\tu32\t\tifidx;\n\t\t\tu32\t\thw_ifidx;\n\t\t\tu8\t\th_source[ETH_ALEN];\n\t\t\tu8\t\th_dest[ETH_ALEN];\n\t\t} out;\n\t\tstruct {\n\t\t\tu32\t\tiifidx;\n\t\t} tc;\n\t};\n};\n\nstruct flow_offload_tuple_rhash {\n\tstruct rhash_head\t\tnode;\n\tstruct flow_offload_tuple\ttuple;\n};\n\nenum nf_flow_flags {\n\tNF_FLOW_SNAT,\n\tNF_FLOW_DNAT,\n\tNF_FLOW_TEARDOWN,\n\tNF_FLOW_HW,\n\tNF_FLOW_HW_DYING,\n\tNF_FLOW_HW_DEAD,\n\tNF_FLOW_HW_PENDING,\n\tNF_FLOW_HW_BIDIRECTIONAL,\n\tNF_FLOW_HW_ESTABLISHED,\n};\n\nenum flow_offload_type {\n\tNF_FLOW_OFFLOAD_UNSPEC\t= 0,\n\tNF_FLOW_OFFLOAD_ROUTE,\n};\n\nstruct flow_offload {\n\tstruct flow_offload_tuple_rhash\t\ttuplehash[FLOW_OFFLOAD_DIR_MAX];\n\tstruct nf_conn\t\t\t\t*ct;\n\tunsigned long\t\t\t\tflags;\n\tu16\t\t\t\t\ttype;\n\tu32\t\t\t\t\ttimeout;\n\tstruct rcu_head\t\t\t\trcu_head;\n};\n\n#define NF_FLOW_TIMEOUT (30 * HZ)\n#define nf_flowtable_time_stamp\t(u32)jiffies\n\nunsigned long flow_offload_get_timeout(struct flow_offload *flow);\n\nstatic inline __s32 nf_flow_timeout_delta(unsigned int timeout)\n{\n\treturn (__s32)(timeout - nf_flowtable_time_stamp);\n}\n\nstruct nf_flow_route {\n\tstruct {\n\t\tstruct dst_entry\t\t*dst;\n\t\tstruct {\n\t\t\tu32\t\t\tifindex;\n\t\t\tstruct {\n\t\t\t\tu16\t\tid;\n\t\t\t\t__be16\t\tproto;\n\t\t\t} encap[NF_FLOW_TABLE_ENCAP_MAX];\n\t\t\tu8\t\t\tnum_encaps:2,\n\t\t\t\t\t\tingress_vlans:2;\n\t\t} in;\n\t\tstruct {\n\t\t\tu32\t\t\tifindex;\n\t\t\tu32\t\t\thw_ifindex;\n\t\t\tu8\t\t\th_source[ETH_ALEN];\n\t\t\tu8\t\t\th_dest[ETH_ALEN];\n\t\t} out;\n\t\tenum flow_offload_xmit_type\txmit_type;\n\t} tuple[FLOW_OFFLOAD_DIR_MAX];\n};\n\nstruct flow_offload *flow_offload_alloc(struct nf_conn *ct);\nvoid flow_offload_free(struct flow_offload *flow);\n\nstatic inline int\nnf_flow_table_offload_add_cb(struct nf_flowtable *flow_table,\n\t\t\t     flow_setup_cb_t *cb, void *cb_priv)\n{\n\tstruct flow_block *block = &flow_table->flow_block;\n\tstruct flow_block_cb *block_cb;\n\tint err = 0;\n\n\tdown_write(&flow_table->flow_block_lock);\n\tblock_cb = flow_block_cb_lookup(block, cb, cb_priv);\n\tif (block_cb) {\n\t\terr = -EEXIST;\n\t\tgoto unlock;\n\t}\n\n\tblock_cb = flow_block_cb_alloc(cb, cb_priv, cb_priv, NULL);\n\tif (IS_ERR(block_cb)) {\n\t\terr = PTR_ERR(block_cb);\n\t\tgoto unlock;\n\t}\n\n\tlist_add_tail(&block_cb->list, &block->cb_list);\n\tup_write(&flow_table->flow_block_lock);\n\n\tif (flow_table->type->get)\n\t\tflow_table->type->get(flow_table);\n\treturn 0;\n\nunlock:\n\tup_write(&flow_table->flow_block_lock);\n\treturn err;\n}\n\nstatic inline void\nnf_flow_table_offload_del_cb(struct nf_flowtable *flow_table,\n\t\t\t     flow_setup_cb_t *cb, void *cb_priv)\n{\n\tstruct flow_block *block = &flow_table->flow_block;\n\tstruct flow_block_cb *block_cb;\n\n\tdown_write(&flow_table->flow_block_lock);\n\tblock_cb = flow_block_cb_lookup(block, cb, cb_priv);\n\tif (block_cb) {\n\t\tlist_del(&block_cb->list);\n\t\tflow_block_cb_free(block_cb);\n\t} else {\n\t\tWARN_ON(true);\n\t}\n\tup_write(&flow_table->flow_block_lock);\n\n\tif (flow_table->type->put)\n\t\tflow_table->type->put(flow_table);\n}\n\nvoid flow_offload_route_init(struct flow_offload *flow,\n\t\t\t     const struct nf_flow_route *route);\n\nint flow_offload_add(struct nf_flowtable *flow_table, struct flow_offload *flow);\nvoid flow_offload_refresh(struct nf_flowtable *flow_table,\n\t\t\t  struct flow_offload *flow, bool force);\n\nstruct flow_offload_tuple_rhash *flow_offload_lookup(struct nf_flowtable *flow_table,\n\t\t\t\t\t\t     struct flow_offload_tuple *tuple);\nvoid nf_flow_table_gc_run(struct nf_flowtable *flow_table);\nvoid nf_flow_table_gc_cleanup(struct nf_flowtable *flowtable,\n\t\t\t      struct net_device *dev);\nvoid nf_flow_table_cleanup(struct net_device *dev);\n\nint nf_flow_table_init(struct nf_flowtable *flow_table);\nvoid nf_flow_table_free(struct nf_flowtable *flow_table);\n\nvoid flow_offload_teardown(struct flow_offload *flow);\n\nvoid nf_flow_snat_port(const struct flow_offload *flow,\n\t\t       struct sk_buff *skb, unsigned int thoff,\n\t\t       u8 protocol, enum flow_offload_tuple_dir dir);\nvoid nf_flow_dnat_port(const struct flow_offload *flow,\n\t\t       struct sk_buff *skb, unsigned int thoff,\n\t\t       u8 protocol, enum flow_offload_tuple_dir dir);\n\nstruct flow_ports {\n\t__be16 source, dest;\n};\n\nunsigned int nf_flow_offload_ip_hook(void *priv, struct sk_buff *skb,\n\t\t\t\t     const struct nf_hook_state *state);\nunsigned int nf_flow_offload_ipv6_hook(void *priv, struct sk_buff *skb,\n\t\t\t\t       const struct nf_hook_state *state);\n\n#define MODULE_ALIAS_NF_FLOWTABLE(family)\t\\\n\tMODULE_ALIAS(\"nf-flowtable-\" __stringify(family))\n\nvoid nf_flow_offload_add(struct nf_flowtable *flowtable,\n\t\t\t struct flow_offload *flow);\nvoid nf_flow_offload_del(struct nf_flowtable *flowtable,\n\t\t\t struct flow_offload *flow);\nvoid nf_flow_offload_stats(struct nf_flowtable *flowtable,\n\t\t\t   struct flow_offload *flow);\n\nvoid nf_flow_table_offload_flush(struct nf_flowtable *flowtable);\nvoid nf_flow_table_offload_flush_cleanup(struct nf_flowtable *flowtable);\n\nint nf_flow_table_offload_setup(struct nf_flowtable *flowtable,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tenum flow_block_command cmd);\nint nf_flow_rule_route_ipv4(struct net *net, struct flow_offload *flow,\n\t\t\t    enum flow_offload_tuple_dir dir,\n\t\t\t    struct nf_flow_rule *flow_rule);\nint nf_flow_rule_route_ipv6(struct net *net, struct flow_offload *flow,\n\t\t\t    enum flow_offload_tuple_dir dir,\n\t\t\t    struct nf_flow_rule *flow_rule);\n\nint nf_flow_table_offload_init(void);\nvoid nf_flow_table_offload_exit(void);\n\nstatic inline __be16 nf_flow_pppoe_proto(const struct sk_buff *skb)\n{\n\t__be16 proto;\n\n\tproto = *((__be16 *)(skb_mac_header(skb) + ETH_HLEN +\n\t\t\t     sizeof(struct pppoe_hdr)));\n\tswitch (proto) {\n\tcase htons(PPP_IP):\n\t\treturn htons(ETH_P_IP);\n\tcase htons(PPP_IPV6):\n\t\treturn htons(ETH_P_IPV6);\n\t}\n\n\treturn 0;\n}\n\n#define NF_FLOW_TABLE_STAT_INC(net, count) __this_cpu_inc((net)->ft.stat->count)\n#define NF_FLOW_TABLE_STAT_DEC(net, count) __this_cpu_dec((net)->ft.stat->count)\n#define NF_FLOW_TABLE_STAT_INC_ATOMIC(net, count)\t\\\n\tthis_cpu_inc((net)->ft.stat->count)\n#define NF_FLOW_TABLE_STAT_DEC_ATOMIC(net, count)\t\\\n\tthis_cpu_dec((net)->ft.stat->count)\n\n#ifdef CONFIG_NF_FLOW_TABLE_PROCFS\nint nf_flow_table_init_proc(struct net *net);\nvoid nf_flow_table_fini_proc(struct net *net);\n#else\nstatic inline int nf_flow_table_init_proc(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline void nf_flow_table_fini_proc(struct net *net)\n{\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}