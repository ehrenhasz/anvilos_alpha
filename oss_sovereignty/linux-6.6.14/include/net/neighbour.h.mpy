{
  "module_name": "neighbour.h",
  "hash_id": "3c1ae74ec4de96ff3fc26b8f6089a8333fd5fb1d42d23231ee2160e0bd0fe23d",
  "original_prompt": "Ingested from linux-6.6.14/include/net/neighbour.h",
  "human_readable_source": " \n#ifndef _NET_NEIGHBOUR_H\n#define _NET_NEIGHBOUR_H\n\n#include <linux/neighbour.h>\n\n \n\n#include <linux/atomic.h>\n#include <linux/refcount.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/rcupdate.h>\n#include <linux/seq_file.h>\n#include <linux/bitmap.h>\n\n#include <linux/err.h>\n#include <linux/sysctl.h>\n#include <linux/workqueue.h>\n#include <net/rtnetlink.h>\n\n \n\n#define NUD_IN_TIMER\t(NUD_INCOMPLETE|NUD_REACHABLE|NUD_DELAY|NUD_PROBE)\n#define NUD_VALID\t(NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE|NUD_PROBE|NUD_STALE|NUD_DELAY)\n#define NUD_CONNECTED\t(NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE)\n\nstruct neighbour;\n\nenum {\n\tNEIGH_VAR_MCAST_PROBES,\n\tNEIGH_VAR_UCAST_PROBES,\n\tNEIGH_VAR_APP_PROBES,\n\tNEIGH_VAR_MCAST_REPROBES,\n\tNEIGH_VAR_RETRANS_TIME,\n\tNEIGH_VAR_BASE_REACHABLE_TIME,\n\tNEIGH_VAR_DELAY_PROBE_TIME,\n\tNEIGH_VAR_INTERVAL_PROBE_TIME_MS,\n\tNEIGH_VAR_GC_STALETIME,\n\tNEIGH_VAR_QUEUE_LEN_BYTES,\n\tNEIGH_VAR_PROXY_QLEN,\n\tNEIGH_VAR_ANYCAST_DELAY,\n\tNEIGH_VAR_PROXY_DELAY,\n\tNEIGH_VAR_LOCKTIME,\n#define NEIGH_VAR_DATA_MAX (NEIGH_VAR_LOCKTIME + 1)\n\t \n\tNEIGH_VAR_QUEUE_LEN,  \n\tNEIGH_VAR_RETRANS_TIME_MS,  \n\tNEIGH_VAR_BASE_REACHABLE_TIME_MS,  \n\t \n\tNEIGH_VAR_GC_INTERVAL,\n\tNEIGH_VAR_GC_THRESH1,\n\tNEIGH_VAR_GC_THRESH2,\n\tNEIGH_VAR_GC_THRESH3,\n\tNEIGH_VAR_MAX\n};\n\nstruct neigh_parms {\n\tpossible_net_t net;\n\tstruct net_device *dev;\n\tnetdevice_tracker dev_tracker;\n\tstruct list_head list;\n\tint\t(*neigh_setup)(struct neighbour *);\n\tstruct neigh_table *tbl;\n\n\tvoid\t*sysctl_table;\n\n\tint dead;\n\trefcount_t refcnt;\n\tstruct rcu_head rcu_head;\n\n\tint\treachable_time;\n\tu32\tqlen;\n\tint\tdata[NEIGH_VAR_DATA_MAX];\n\tDECLARE_BITMAP(data_state, NEIGH_VAR_DATA_MAX);\n};\n\nstatic inline void neigh_var_set(struct neigh_parms *p, int index, int val)\n{\n\tset_bit(index, p->data_state);\n\tp->data[index] = val;\n}\n\n#define NEIGH_VAR(p, attr) ((p)->data[NEIGH_VAR_ ## attr])\n\n \n#define NEIGH_VAR_INIT(p, attr, val) (NEIGH_VAR(p, attr) = val)\n#define NEIGH_VAR_SET(p, attr, val) neigh_var_set(p, NEIGH_VAR_ ## attr, val)\n\nstatic inline void neigh_parms_data_state_setall(struct neigh_parms *p)\n{\n\tbitmap_fill(p->data_state, NEIGH_VAR_DATA_MAX);\n}\n\nstatic inline void neigh_parms_data_state_cleanall(struct neigh_parms *p)\n{\n\tbitmap_zero(p->data_state, NEIGH_VAR_DATA_MAX);\n}\n\nstruct neigh_statistics {\n\tunsigned long allocs;\t\t \n\tunsigned long destroys;\t\t \n\tunsigned long hash_grows;\t \n\n\tunsigned long res_failed;\t \n\n\tunsigned long lookups;\t\t \n\tunsigned long hits;\t\t \n\n\tunsigned long rcv_probes_mcast;\t \n\tunsigned long rcv_probes_ucast;  \n\n\tunsigned long periodic_gc_runs;\t \n\tunsigned long forced_gc_runs;\t \n\n\tunsigned long unres_discards;\t \n\tunsigned long table_fulls;       \n};\n\n#define NEIGH_CACHE_STAT_INC(tbl, field) this_cpu_inc((tbl)->stats->field)\n\nstruct neighbour {\n\tstruct neighbour __rcu\t*next;\n\tstruct neigh_table\t*tbl;\n\tstruct neigh_parms\t*parms;\n\tunsigned long\t\tconfirmed;\n\tunsigned long\t\tupdated;\n\trwlock_t\t\tlock;\n\trefcount_t\t\trefcnt;\n\tunsigned int\t\tarp_queue_len_bytes;\n\tstruct sk_buff_head\tarp_queue;\n\tstruct timer_list\ttimer;\n\tunsigned long\t\tused;\n\tatomic_t\t\tprobes;\n\tu8\t\t\tnud_state;\n\tu8\t\t\ttype;\n\tu8\t\t\tdead;\n\tu8\t\t\tprotocol;\n\tu32\t\t\tflags;\n\tseqlock_t\t\tha_lock;\n\tunsigned char\t\tha[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))] __aligned(8);\n\tstruct hh_cache\t\thh;\n\tint\t\t\t(*output)(struct neighbour *, struct sk_buff *);\n\tconst struct neigh_ops\t*ops;\n\tstruct list_head\tgc_list;\n\tstruct list_head\tmanaged_list;\n\tstruct rcu_head\t\trcu;\n\tstruct net_device\t*dev;\n\tnetdevice_tracker\tdev_tracker;\n\tu8\t\t\tprimary_key[];\n} __randomize_layout;\n\nstruct neigh_ops {\n\tint\t\t\tfamily;\n\tvoid\t\t\t(*solicit)(struct neighbour *, struct sk_buff *);\n\tvoid\t\t\t(*error_report)(struct neighbour *, struct sk_buff *);\n\tint\t\t\t(*output)(struct neighbour *, struct sk_buff *);\n\tint\t\t\t(*connected_output)(struct neighbour *, struct sk_buff *);\n};\n\nstruct pneigh_entry {\n\tstruct pneigh_entry\t*next;\n\tpossible_net_t\t\tnet;\n\tstruct net_device\t*dev;\n\tnetdevice_tracker\tdev_tracker;\n\tu32\t\t\tflags;\n\tu8\t\t\tprotocol;\n\tu32\t\t\tkey[];\n};\n\n \n\n#define NEIGH_NUM_HASH_RND\t4\n\nstruct neigh_hash_table {\n\tstruct neighbour __rcu\t**hash_buckets;\n\tunsigned int\t\thash_shift;\n\t__u32\t\t\thash_rnd[NEIGH_NUM_HASH_RND];\n\tstruct rcu_head\t\trcu;\n};\n\n\nstruct neigh_table {\n\tint\t\t\tfamily;\n\tunsigned int\t\tentry_size;\n\tunsigned int\t\tkey_len;\n\t__be16\t\t\tprotocol;\n\t__u32\t\t\t(*hash)(const void *pkey,\n\t\t\t\t\tconst struct net_device *dev,\n\t\t\t\t\t__u32 *hash_rnd);\n\tbool\t\t\t(*key_eq)(const struct neighbour *, const void *pkey);\n\tint\t\t\t(*constructor)(struct neighbour *);\n\tint\t\t\t(*pconstructor)(struct pneigh_entry *);\n\tvoid\t\t\t(*pdestructor)(struct pneigh_entry *);\n\tvoid\t\t\t(*proxy_redo)(struct sk_buff *skb);\n\tint\t\t\t(*is_multicast)(const void *pkey);\n\tbool\t\t\t(*allow_add)(const struct net_device *dev,\n\t\t\t\t\t     struct netlink_ext_ack *extack);\n\tchar\t\t\t*id;\n\tstruct neigh_parms\tparms;\n\tstruct list_head\tparms_list;\n\tint\t\t\tgc_interval;\n\tint\t\t\tgc_thresh1;\n\tint\t\t\tgc_thresh2;\n\tint\t\t\tgc_thresh3;\n\tunsigned long\t\tlast_flush;\n\tstruct delayed_work\tgc_work;\n\tstruct delayed_work\tmanaged_work;\n\tstruct timer_list \tproxy_timer;\n\tstruct sk_buff_head\tproxy_queue;\n\tatomic_t\t\tentries;\n\tatomic_t\t\tgc_entries;\n\tstruct list_head\tgc_list;\n\tstruct list_head\tmanaged_list;\n\trwlock_t\t\tlock;\n\tunsigned long\t\tlast_rand;\n\tstruct neigh_statistics\t__percpu *stats;\n\tstruct neigh_hash_table __rcu *nht;\n\tstruct pneigh_entry\t**phash_buckets;\n};\n\nenum {\n\tNEIGH_ARP_TABLE = 0,\n\tNEIGH_ND_TABLE = 1,\n\tNEIGH_DN_TABLE = 2,\n\tNEIGH_NR_TABLES,\n\tNEIGH_LINK_TABLE = NEIGH_NR_TABLES  \n};\n\nstatic inline int neigh_parms_family(struct neigh_parms *p)\n{\n\treturn p->tbl->family;\n}\n\n#define NEIGH_PRIV_ALIGN\tsizeof(long long)\n#define NEIGH_ENTRY_SIZE(size)\tALIGN((size), NEIGH_PRIV_ALIGN)\n\nstatic inline void *neighbour_priv(const struct neighbour *n)\n{\n\treturn (char *)n + n->tbl->entry_size;\n}\n\n \n#define NEIGH_UPDATE_F_OVERRIDE\t\t\tBIT(0)\n#define NEIGH_UPDATE_F_WEAK_OVERRIDE\t\tBIT(1)\n#define NEIGH_UPDATE_F_OVERRIDE_ISROUTER\tBIT(2)\n#define NEIGH_UPDATE_F_USE\t\t\tBIT(3)\n#define NEIGH_UPDATE_F_MANAGED\t\t\tBIT(4)\n#define NEIGH_UPDATE_F_EXT_LEARNED\t\tBIT(5)\n#define NEIGH_UPDATE_F_ISROUTER\t\t\tBIT(6)\n#define NEIGH_UPDATE_F_ADMIN\t\t\tBIT(7)\n\n \n#define NTF_OLD_MASK\t\t0xff\n#define NTF_EXT_SHIFT\t\t8\n#define NTF_EXT_MASK\t\t(NTF_EXT_MANAGED)\n\n#define NTF_MANAGED\t\t(NTF_EXT_MANAGED << NTF_EXT_SHIFT)\n\nextern const struct nla_policy nda_policy[];\n\nstatic inline bool neigh_key_eq32(const struct neighbour *n, const void *pkey)\n{\n\treturn *(const u32 *)n->primary_key == *(const u32 *)pkey;\n}\n\nstatic inline bool neigh_key_eq128(const struct neighbour *n, const void *pkey)\n{\n\tconst u32 *n32 = (const u32 *)n->primary_key;\n\tconst u32 *p32 = pkey;\n\n\treturn ((n32[0] ^ p32[0]) | (n32[1] ^ p32[1]) |\n\t\t(n32[2] ^ p32[2]) | (n32[3] ^ p32[3])) == 0;\n}\n\nstatic inline struct neighbour *___neigh_lookup_noref(\n\tstruct neigh_table *tbl,\n\tbool (*key_eq)(const struct neighbour *n, const void *pkey),\n\t__u32 (*hash)(const void *pkey,\n\t\t      const struct net_device *dev,\n\t\t      __u32 *hash_rnd),\n\tconst void *pkey,\n\tstruct net_device *dev)\n{\n\tstruct neigh_hash_table *nht = rcu_dereference(tbl->nht);\n\tstruct neighbour *n;\n\tu32 hash_val;\n\n\thash_val = hash(pkey, dev, nht->hash_rnd) >> (32 - nht->hash_shift);\n\tfor (n = rcu_dereference(nht->hash_buckets[hash_val]);\n\t     n != NULL;\n\t     n = rcu_dereference(n->next)) {\n\t\tif (n->dev == dev && key_eq(n, pkey))\n\t\t\treturn n;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline struct neighbour *__neigh_lookup_noref(struct neigh_table *tbl,\n\t\t\t\t\t\t     const void *pkey,\n\t\t\t\t\t\t     struct net_device *dev)\n{\n\treturn ___neigh_lookup_noref(tbl, tbl->key_eq, tbl->hash, pkey, dev);\n}\n\nstatic inline void neigh_confirm(struct neighbour *n)\n{\n\tif (n) {\n\t\tunsigned long now = jiffies;\n\n\t\t \n\t\tif (READ_ONCE(n->confirmed) != now)\n\t\t\tWRITE_ONCE(n->confirmed, now);\n\t}\n}\n\nvoid neigh_table_init(int index, struct neigh_table *tbl);\nint neigh_table_clear(int index, struct neigh_table *tbl);\nstruct neighbour *neigh_lookup(struct neigh_table *tbl, const void *pkey,\n\t\t\t       struct net_device *dev);\nstruct neighbour *__neigh_create(struct neigh_table *tbl, const void *pkey,\n\t\t\t\t struct net_device *dev, bool want_ref);\nstatic inline struct neighbour *neigh_create(struct neigh_table *tbl,\n\t\t\t\t\t     const void *pkey,\n\t\t\t\t\t     struct net_device *dev)\n{\n\treturn __neigh_create(tbl, pkey, dev, true);\n}\nvoid neigh_destroy(struct neighbour *neigh);\nint __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb,\n\t\t       const bool immediate_ok);\nint neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new, u32 flags,\n\t\t u32 nlmsg_pid);\nvoid __neigh_set_probe_once(struct neighbour *neigh);\nbool neigh_remove_one(struct neighbour *ndel, struct neigh_table *tbl);\nvoid neigh_changeaddr(struct neigh_table *tbl, struct net_device *dev);\nint neigh_ifdown(struct neigh_table *tbl, struct net_device *dev);\nint neigh_carrier_down(struct neigh_table *tbl, struct net_device *dev);\nint neigh_resolve_output(struct neighbour *neigh, struct sk_buff *skb);\nint neigh_connected_output(struct neighbour *neigh, struct sk_buff *skb);\nint neigh_direct_output(struct neighbour *neigh, struct sk_buff *skb);\nstruct neighbour *neigh_event_ns(struct neigh_table *tbl,\n\t\t\t\t\t\tu8 *lladdr, void *saddr,\n\t\t\t\t\t\tstruct net_device *dev);\n\nstruct neigh_parms *neigh_parms_alloc(struct net_device *dev,\n\t\t\t\t      struct neigh_table *tbl);\nvoid neigh_parms_release(struct neigh_table *tbl, struct neigh_parms *parms);\n\nstatic inline\nstruct net *neigh_parms_net(const struct neigh_parms *parms)\n{\n\treturn read_pnet(&parms->net);\n}\n\nunsigned long neigh_rand_reach_time(unsigned long base);\n\nvoid pneigh_enqueue(struct neigh_table *tbl, struct neigh_parms *p,\n\t\t    struct sk_buff *skb);\nstruct pneigh_entry *pneigh_lookup(struct neigh_table *tbl, struct net *net,\n\t\t\t\t   const void *key, struct net_device *dev,\n\t\t\t\t   int creat);\nstruct pneigh_entry *__pneigh_lookup(struct neigh_table *tbl, struct net *net,\n\t\t\t\t     const void *key, struct net_device *dev);\nint pneigh_delete(struct neigh_table *tbl, struct net *net, const void *key,\n\t\t  struct net_device *dev);\n\nstatic inline struct net *pneigh_net(const struct pneigh_entry *pneigh)\n{\n\treturn read_pnet(&pneigh->net);\n}\n\nvoid neigh_app_ns(struct neighbour *n);\nvoid neigh_for_each(struct neigh_table *tbl,\n\t\t    void (*cb)(struct neighbour *, void *), void *cookie);\nvoid __neigh_for_each_release(struct neigh_table *tbl,\n\t\t\t      int (*cb)(struct neighbour *));\nint neigh_xmit(int fam, struct net_device *, const void *, struct sk_buff *);\n\nstruct neigh_seq_state {\n\tstruct seq_net_private p;\n\tstruct neigh_table *tbl;\n\tstruct neigh_hash_table *nht;\n\tvoid *(*neigh_sub_iter)(struct neigh_seq_state *state,\n\t\t\t\tstruct neighbour *n, loff_t *pos);\n\tunsigned int bucket;\n\tunsigned int flags;\n#define NEIGH_SEQ_NEIGH_ONLY\t0x00000001\n#define NEIGH_SEQ_IS_PNEIGH\t0x00000002\n#define NEIGH_SEQ_SKIP_NOARP\t0x00000004\n};\nvoid *neigh_seq_start(struct seq_file *, loff_t *, struct neigh_table *,\n\t\t      unsigned int);\nvoid *neigh_seq_next(struct seq_file *, void *, loff_t *);\nvoid neigh_seq_stop(struct seq_file *, void *);\n\nint neigh_proc_dointvec(struct ctl_table *ctl, int write,\n\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos);\nint neigh_proc_dointvec_jiffies(struct ctl_table *ctl, int write,\n\t\t\t\tvoid *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos);\nint neigh_proc_dointvec_ms_jiffies(struct ctl_table *ctl, int write,\n\t\t\t\t   void *buffer, size_t *lenp, loff_t *ppos);\n\nint neigh_sysctl_register(struct net_device *dev, struct neigh_parms *p,\n\t\t\t  proc_handler *proc_handler);\nvoid neigh_sysctl_unregister(struct neigh_parms *p);\n\nstatic inline void __neigh_parms_put(struct neigh_parms *parms)\n{\n\trefcount_dec(&parms->refcnt);\n}\n\nstatic inline struct neigh_parms *neigh_parms_clone(struct neigh_parms *parms)\n{\n\trefcount_inc(&parms->refcnt);\n\treturn parms;\n}\n\n \n\nstatic inline void neigh_release(struct neighbour *neigh)\n{\n\tif (refcount_dec_and_test(&neigh->refcnt))\n\t\tneigh_destroy(neigh);\n}\n\nstatic inline struct neighbour * neigh_clone(struct neighbour *neigh)\n{\n\tif (neigh)\n\t\trefcount_inc(&neigh->refcnt);\n\treturn neigh;\n}\n\n#define neigh_hold(n)\trefcount_inc(&(n)->refcnt)\n\nstatic __always_inline int neigh_event_send_probe(struct neighbour *neigh,\n\t\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t\t  const bool immediate_ok)\n{\n\tunsigned long now = jiffies;\n\n\tif (READ_ONCE(neigh->used) != now)\n\t\tWRITE_ONCE(neigh->used, now);\n\tif (!(READ_ONCE(neigh->nud_state) & (NUD_CONNECTED | NUD_DELAY | NUD_PROBE)))\n\t\treturn __neigh_event_send(neigh, skb, immediate_ok);\n\treturn 0;\n}\n\nstatic inline int neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)\n{\n\treturn neigh_event_send_probe(neigh, skb, true);\n}\n\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\nstatic inline int neigh_hh_bridge(struct hh_cache *hh, struct sk_buff *skb)\n{\n\tunsigned int seq, hh_alen;\n\n\tdo {\n\t\tseq = read_seqbegin(&hh->hh_lock);\n\t\thh_alen = HH_DATA_ALIGN(ETH_HLEN);\n\t\tmemcpy(skb->data - hh_alen, hh->hh_data, ETH_ALEN + hh_alen - ETH_HLEN);\n\t} while (read_seqretry(&hh->hh_lock, seq));\n\treturn 0;\n}\n#endif\n\nstatic inline int neigh_hh_output(const struct hh_cache *hh, struct sk_buff *skb)\n{\n\tunsigned int hh_alen = 0;\n\tunsigned int seq;\n\tunsigned int hh_len;\n\n\tdo {\n\t\tseq = read_seqbegin(&hh->hh_lock);\n\t\thh_len = READ_ONCE(hh->hh_len);\n\t\tif (likely(hh_len <= HH_DATA_MOD)) {\n\t\t\thh_alen = HH_DATA_MOD;\n\n\t\t\t \n\t\t\tif (likely(skb_headroom(skb) >= HH_DATA_MOD)) {\n\t\t\t\t \n\t\t\t\tmemcpy(skb->data - HH_DATA_MOD, hh->hh_data,\n\t\t\t\t       HH_DATA_MOD);\n\t\t\t}\n\t\t} else {\n\t\t\thh_alen = HH_DATA_ALIGN(hh_len);\n\n\t\t\tif (likely(skb_headroom(skb) >= hh_alen)) {\n\t\t\t\tmemcpy(skb->data - hh_alen, hh->hh_data,\n\t\t\t\t       hh_alen);\n\t\t\t}\n\t\t}\n\t} while (read_seqretry(&hh->hh_lock, seq));\n\n\tif (WARN_ON_ONCE(skb_headroom(skb) < hh_alen)) {\n\t\tkfree_skb(skb);\n\t\treturn NET_XMIT_DROP;\n\t}\n\n\t__skb_push(skb, hh_len);\n\treturn dev_queue_xmit(skb);\n}\n\nstatic inline int neigh_output(struct neighbour *n, struct sk_buff *skb,\n\t\t\t       bool skip_cache)\n{\n\tconst struct hh_cache *hh = &n->hh;\n\n\t \n\tif (!skip_cache &&\n\t    (READ_ONCE(n->nud_state) & NUD_CONNECTED) &&\n\t    READ_ONCE(hh->hh_len))\n\t\treturn neigh_hh_output(hh, skb);\n\n\treturn READ_ONCE(n->output)(n, skb);\n}\n\nstatic inline struct neighbour *\n__neigh_lookup(struct neigh_table *tbl, const void *pkey, struct net_device *dev, int creat)\n{\n\tstruct neighbour *n = neigh_lookup(tbl, pkey, dev);\n\n\tif (n || !creat)\n\t\treturn n;\n\n\tn = neigh_create(tbl, pkey, dev);\n\treturn IS_ERR(n) ? NULL : n;\n}\n\nstatic inline struct neighbour *\n__neigh_lookup_errno(struct neigh_table *tbl, const void *pkey,\n  struct net_device *dev)\n{\n\tstruct neighbour *n = neigh_lookup(tbl, pkey, dev);\n\n\tif (n)\n\t\treturn n;\n\n\treturn neigh_create(tbl, pkey, dev);\n}\n\nstruct neighbour_cb {\n\tunsigned long sched_next;\n\tunsigned int flags;\n};\n\n#define LOCALLY_ENQUEUED 0x1\n\n#define NEIGH_CB(skb)\t((struct neighbour_cb *)(skb)->cb)\n\nstatic inline void neigh_ha_snapshot(char *dst, const struct neighbour *n,\n\t\t\t\t     const struct net_device *dev)\n{\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqbegin(&n->ha_lock);\n\t\tmemcpy(dst, n->ha, dev->addr_len);\n\t} while (read_seqretry(&n->ha_lock, seq));\n}\n\nstatic inline void neigh_update_is_router(struct neighbour *neigh, u32 flags,\n\t\t\t\t\t  int *notify)\n{\n\tu8 ndm_flags = 0;\n\n\tndm_flags |= (flags & NEIGH_UPDATE_F_ISROUTER) ? NTF_ROUTER : 0;\n\tif ((neigh->flags ^ ndm_flags) & NTF_ROUTER) {\n\t\tif (ndm_flags & NTF_ROUTER)\n\t\t\tneigh->flags |= NTF_ROUTER;\n\t\telse\n\t\t\tneigh->flags &= ~NTF_ROUTER;\n\t\t*notify = 1;\n\t}\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}