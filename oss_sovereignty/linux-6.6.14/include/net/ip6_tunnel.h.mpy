{
  "module_name": "ip6_tunnel.h",
  "hash_id": "92176c754ecf7ebe3ed9286354d3c516bb7640541aaaf77c71987fac658d007d",
  "original_prompt": "Ingested from linux-6.6.14/include/net/ip6_tunnel.h",
  "human_readable_source": " \n#ifndef _NET_IP6_TUNNEL_H\n#define _NET_IP6_TUNNEL_H\n\n#include <linux/ipv6.h>\n#include <linux/netdevice.h>\n#include <linux/if_tunnel.h>\n#include <linux/ip6_tunnel.h>\n#include <net/ip_tunnels.h>\n#include <net/dst_cache.h>\n\n#define IP6TUNNEL_ERR_TIMEO (30*HZ)\n\n \n#define IP6_TNL_F_CAP_XMIT 0x10000\n \n#define IP6_TNL_F_CAP_RCV 0x20000\n \n#define IP6_TNL_F_CAP_PER_PACKET 0x40000\n\nstruct __ip6_tnl_parm {\n\tchar name[IFNAMSIZ];\t \n\tint link;\t\t \n\t__u8 proto;\t\t \n\t__u8 encap_limit;\t \n\t__u8 hop_limit;\t\t \n\tbool collect_md;\n\t__be32 flowinfo;\t \n\t__u32 flags;\t\t \n\tstruct in6_addr laddr;\t \n\tstruct in6_addr raddr;\t \n\n\t__be16\t\t\ti_flags;\n\t__be16\t\t\to_flags;\n\t__be32\t\t\ti_key;\n\t__be32\t\t\to_key;\n\n\t__u32\t\t\tfwmark;\n\t__u32\t\t\tindex;\t \n\t__u8\t\t\terspan_ver;\t \n\t__u8\t\t\tdir;\t \n\t__u16\t\t\thwid;\t \n};\n\n \nstruct ip6_tnl {\n\tstruct ip6_tnl __rcu *next;\t \n\tstruct net_device *dev;\t \n\tnetdevice_tracker dev_tracker;\n\tstruct net *net;\t \n\tstruct __ip6_tnl_parm parms;\t \n\tstruct flowi fl;\t \n\tstruct dst_cache dst_cache;\t \n\tstruct gro_cells gro_cells;\n\n\tint err_count;\n\tunsigned long err_time;\n\n\t \n\t__u32 i_seqno;\t \n\tatomic_t o_seqno;\t \n\tint hlen;        \n\tint tun_hlen;\t \n\tint encap_hlen;  \n\tstruct ip_tunnel_encap encap;\n\tint mlink;\n};\n\nstruct ip6_tnl_encap_ops {\n\tsize_t (*encap_hlen)(struct ip_tunnel_encap *e);\n\tint (*build_header)(struct sk_buff *skb, struct ip_tunnel_encap *e,\n\t\t\t    u8 *protocol, struct flowi6 *fl6);\n\tint (*err_handler)(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t   u8 type, u8 code, int offset, __be32 info);\n};\n\n#ifdef CONFIG_INET\n\nextern const struct ip6_tnl_encap_ops __rcu *\n\t\tip6tun_encaps[MAX_IPTUN_ENCAP_OPS];\n\nint ip6_tnl_encap_add_ops(const struct ip6_tnl_encap_ops *ops,\n\t\t\t  unsigned int num);\nint ip6_tnl_encap_del_ops(const struct ip6_tnl_encap_ops *ops,\n\t\t\t  unsigned int num);\nint ip6_tnl_encap_setup(struct ip6_tnl *t,\n\t\t\tstruct ip_tunnel_encap *ipencap);\n\nstatic inline int ip6_encap_hlen(struct ip_tunnel_encap *e)\n{\n\tconst struct ip6_tnl_encap_ops *ops;\n\tint hlen = -EINVAL;\n\n\tif (e->type == TUNNEL_ENCAP_NONE)\n\t\treturn 0;\n\n\tif (e->type >= MAX_IPTUN_ENCAP_OPS)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tops = rcu_dereference(ip6tun_encaps[e->type]);\n\tif (likely(ops && ops->encap_hlen))\n\t\thlen = ops->encap_hlen(e);\n\trcu_read_unlock();\n\n\treturn hlen;\n}\n\nstatic inline int ip6_tnl_encap(struct sk_buff *skb, struct ip6_tnl *t,\n\t\t\t\tu8 *protocol, struct flowi6 *fl6)\n{\n\tconst struct ip6_tnl_encap_ops *ops;\n\tint ret = -EINVAL;\n\n\tif (t->encap.type == TUNNEL_ENCAP_NONE)\n\t\treturn 0;\n\n\tif (t->encap.type >= MAX_IPTUN_ENCAP_OPS)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tops = rcu_dereference(ip6tun_encaps[t->encap.type]);\n\tif (likely(ops && ops->build_header))\n\t\tret = ops->build_header(skb, &t->encap, protocol, fl6);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n \n\nstruct ipv6_tlv_tnl_enc_lim {\n\t__u8 type;\t\t \n\t__u8 length;\t\t \n\t__u8 encap_limit;\t \n} __packed;\n\nint ip6_tnl_rcv_ctl(struct ip6_tnl *t, const struct in6_addr *laddr,\n\t\tconst struct in6_addr *raddr);\nint ip6_tnl_rcv(struct ip6_tnl *tunnel, struct sk_buff *skb,\n\t\tconst struct tnl_ptk_info *tpi, struct metadata_dst *tun_dst,\n\t\tbool log_ecn_error);\nint ip6_tnl_xmit_ctl(struct ip6_tnl *t, const struct in6_addr *laddr,\n\t\t     const struct in6_addr *raddr);\nint ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev, __u8 dsfield,\n\t\t struct flowi6 *fl6, int encap_limit, __u32 *pmtu, __u8 proto);\n__u16 ip6_tnl_parse_tlv_enc_lim(struct sk_buff *skb, __u8 *raw);\n__u32 ip6_tnl_get_cap(struct ip6_tnl *t, const struct in6_addr *laddr,\n\t\t\t     const struct in6_addr *raddr);\nstruct net *ip6_tnl_get_link_net(const struct net_device *dev);\nint ip6_tnl_get_iflink(const struct net_device *dev);\nint ip6_tnl_change_mtu(struct net_device *dev, int new_mtu);\n\nstatic inline void ip6tunnel_xmit(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct net_device *dev)\n{\n\tint pkt_len, err;\n\n\tmemset(skb->cb, 0, sizeof(struct inet6_skb_parm));\n\tpkt_len = skb->len - skb_inner_network_offset(skb);\n\terr = ip6_local_out(dev_net(skb_dst(skb)->dev), sk, skb);\n\n\tif (dev) {\n\t\tif (unlikely(net_xmit_eval(err)))\n\t\t\tpkt_len = -1;\n\t\tiptunnel_xmit_stats(dev, pkt_len);\n\t}\n}\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}