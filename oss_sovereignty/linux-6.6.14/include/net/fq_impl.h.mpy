{
  "module_name": "fq_impl.h",
  "hash_id": "f57fc04bd6f7983fe486985eab1175814ef7ae8948f44b847370d11576c9a1e0",
  "original_prompt": "Ingested from linux-6.6.14/include/net/fq_impl.h",
  "human_readable_source": " \n \n#ifndef __NET_SCHED_FQ_IMPL_H\n#define __NET_SCHED_FQ_IMPL_H\n\n#include <net/fq.h>\n\n \n\n\nstatic void\n__fq_adjust_removal(struct fq *fq, struct fq_flow *flow, unsigned int packets,\n\t\t    unsigned int bytes, unsigned int truesize)\n{\n\tstruct fq_tin *tin = flow->tin;\n\tint idx;\n\n\ttin->backlog_bytes -= bytes;\n\ttin->backlog_packets -= packets;\n\tflow->backlog -= bytes;\n\tfq->backlog -= packets;\n\tfq->memory_usage -= truesize;\n\n\tif (flow->backlog)\n\t\treturn;\n\n\tif (flow == &tin->default_flow) {\n\t\tlist_del_init(&tin->tin_list);\n\t\treturn;\n\t}\n\n\tidx = flow - fq->flows;\n\t__clear_bit(idx, fq->flows_bitmap);\n}\n\nstatic void fq_adjust_removal(struct fq *fq,\n\t\t\t      struct fq_flow *flow,\n\t\t\t      struct sk_buff *skb)\n{\n\t__fq_adjust_removal(fq, flow, 1, skb->len, skb->truesize);\n}\n\nstatic struct sk_buff *fq_flow_dequeue(struct fq *fq,\n\t\t\t\t       struct fq_flow *flow)\n{\n\tstruct sk_buff *skb;\n\n\tlockdep_assert_held(&fq->lock);\n\n\tskb = __skb_dequeue(&flow->queue);\n\tif (!skb)\n\t\treturn NULL;\n\n\tfq_adjust_removal(fq, flow, skb);\n\n\treturn skb;\n}\n\nstatic int fq_flow_drop(struct fq *fq, struct fq_flow *flow,\n\t\t\tfq_skb_free_t free_func)\n{\n\tunsigned int packets = 0, bytes = 0, truesize = 0;\n\tstruct fq_tin *tin = flow->tin;\n\tstruct sk_buff *skb;\n\tint pending;\n\n\tlockdep_assert_held(&fq->lock);\n\n\tpending = min_t(int, 32, skb_queue_len(&flow->queue) / 2);\n\tdo {\n\t\tskb = __skb_dequeue(&flow->queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tpackets++;\n\t\tbytes += skb->len;\n\t\ttruesize += skb->truesize;\n\t\tfree_func(fq, tin, flow, skb);\n\t} while (packets < pending);\n\n\t__fq_adjust_removal(fq, flow, packets, bytes, truesize);\n\n\treturn packets;\n}\n\nstatic struct sk_buff *fq_tin_dequeue(struct fq *fq,\n\t\t\t\t      struct fq_tin *tin,\n\t\t\t\t      fq_tin_dequeue_t dequeue_func)\n{\n\tstruct fq_flow *flow;\n\tstruct list_head *head;\n\tstruct sk_buff *skb;\n\n\tlockdep_assert_held(&fq->lock);\n\nbegin:\n\thead = &tin->new_flows;\n\tif (list_empty(head)) {\n\t\thead = &tin->old_flows;\n\t\tif (list_empty(head))\n\t\t\treturn NULL;\n\t}\n\n\tflow = list_first_entry(head, struct fq_flow, flowchain);\n\n\tif (flow->deficit <= 0) {\n\t\tflow->deficit += fq->quantum;\n\t\tlist_move_tail(&flow->flowchain,\n\t\t\t       &tin->old_flows);\n\t\tgoto begin;\n\t}\n\n\tskb = dequeue_func(fq, tin, flow);\n\tif (!skb) {\n\t\t \n\t\tif ((head == &tin->new_flows) &&\n\t\t    !list_empty(&tin->old_flows)) {\n\t\t\tlist_move_tail(&flow->flowchain, &tin->old_flows);\n\t\t} else {\n\t\t\tlist_del_init(&flow->flowchain);\n\t\t\tflow->tin = NULL;\n\t\t}\n\t\tgoto begin;\n\t}\n\n\tflow->deficit -= skb->len;\n\ttin->tx_bytes += skb->len;\n\ttin->tx_packets++;\n\n\treturn skb;\n}\n\nstatic u32 fq_flow_idx(struct fq *fq, struct sk_buff *skb)\n{\n\tu32 hash = skb_get_hash(skb);\n\n\treturn reciprocal_scale(hash, fq->flows_cnt);\n}\n\nstatic struct fq_flow *fq_flow_classify(struct fq *fq,\n\t\t\t\t\tstruct fq_tin *tin, u32 idx,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct fq_flow *flow;\n\n\tlockdep_assert_held(&fq->lock);\n\n\tflow = &fq->flows[idx];\n\tif (flow->tin && flow->tin != tin) {\n\t\tflow = &tin->default_flow;\n\t\ttin->collisions++;\n\t\tfq->collisions++;\n\t}\n\n\tif (!flow->tin)\n\t\ttin->flows++;\n\n\treturn flow;\n}\n\nstatic struct fq_flow *fq_find_fattest_flow(struct fq *fq)\n{\n\tstruct fq_tin *tin;\n\tstruct fq_flow *flow = NULL;\n\tu32 len = 0;\n\tint i;\n\n\tfor_each_set_bit(i, fq->flows_bitmap, fq->flows_cnt) {\n\t\tstruct fq_flow *cur = &fq->flows[i];\n\t\tunsigned int cur_len;\n\n\t\tcur_len = cur->backlog;\n\t\tif (cur_len <= len)\n\t\t\tcontinue;\n\n\t\tflow = cur;\n\t\tlen = cur_len;\n\t}\n\n\tlist_for_each_entry(tin, &fq->tin_backlog, tin_list) {\n\t\tunsigned int cur_len = tin->default_flow.backlog;\n\n\t\tif (cur_len <= len)\n\t\t\tcontinue;\n\n\t\tflow = &tin->default_flow;\n\t\tlen = cur_len;\n\t}\n\n\treturn flow;\n}\n\nstatic void fq_tin_enqueue(struct fq *fq,\n\t\t\t   struct fq_tin *tin, u32 idx,\n\t\t\t   struct sk_buff *skb,\n\t\t\t   fq_skb_free_t free_func)\n{\n\tstruct fq_flow *flow;\n\tstruct sk_buff *next;\n\tbool oom;\n\n\tlockdep_assert_held(&fq->lock);\n\n\tflow = fq_flow_classify(fq, tin, idx, skb);\n\n\tif (!flow->backlog) {\n\t\tif (flow != &tin->default_flow)\n\t\t\t__set_bit(idx, fq->flows_bitmap);\n\t\telse if (list_empty(&tin->tin_list))\n\t\t\tlist_add(&tin->tin_list, &fq->tin_backlog);\n\t}\n\n\tflow->tin = tin;\n\tskb_list_walk_safe(skb, skb, next) {\n\t\tskb_mark_not_on_list(skb);\n\t\tflow->backlog += skb->len;\n\t\ttin->backlog_bytes += skb->len;\n\t\ttin->backlog_packets++;\n\t\tfq->memory_usage += skb->truesize;\n\t\tfq->backlog++;\n\t\t__skb_queue_tail(&flow->queue, skb);\n\t}\n\n\tif (list_empty(&flow->flowchain)) {\n\t\tflow->deficit = fq->quantum;\n\t\tlist_add_tail(&flow->flowchain,\n\t\t\t      &tin->new_flows);\n\t}\n\n\toom = (fq->memory_usage > fq->memory_limit);\n\twhile (fq->backlog > fq->limit || oom) {\n\t\tflow = fq_find_fattest_flow(fq);\n\t\tif (!flow)\n\t\t\treturn;\n\n\t\tif (!fq_flow_drop(fq, flow, free_func))\n\t\t\treturn;\n\n\t\tflow->tin->overlimit++;\n\t\tfq->overlimit++;\n\t\tif (oom) {\n\t\t\tfq->overmemory++;\n\t\t\toom = (fq->memory_usage > fq->memory_limit);\n\t\t}\n\t}\n}\n\nstatic void fq_flow_filter(struct fq *fq,\n\t\t\t   struct fq_flow *flow,\n\t\t\t   fq_skb_filter_t filter_func,\n\t\t\t   void *filter_data,\n\t\t\t   fq_skb_free_t free_func)\n{\n\tstruct fq_tin *tin = flow->tin;\n\tstruct sk_buff *skb, *tmp;\n\n\tlockdep_assert_held(&fq->lock);\n\n\tskb_queue_walk_safe(&flow->queue, skb, tmp) {\n\t\tif (!filter_func(fq, tin, flow, skb, filter_data))\n\t\t\tcontinue;\n\n\t\t__skb_unlink(skb, &flow->queue);\n\t\tfq_adjust_removal(fq, flow, skb);\n\t\tfree_func(fq, tin, flow, skb);\n\t}\n}\n\nstatic void fq_tin_filter(struct fq *fq,\n\t\t\t  struct fq_tin *tin,\n\t\t\t  fq_skb_filter_t filter_func,\n\t\t\t  void *filter_data,\n\t\t\t  fq_skb_free_t free_func)\n{\n\tstruct fq_flow *flow;\n\n\tlockdep_assert_held(&fq->lock);\n\n\tlist_for_each_entry(flow, &tin->new_flows, flowchain)\n\t\tfq_flow_filter(fq, flow, filter_func, filter_data, free_func);\n\tlist_for_each_entry(flow, &tin->old_flows, flowchain)\n\t\tfq_flow_filter(fq, flow, filter_func, filter_data, free_func);\n}\n\nstatic void fq_flow_reset(struct fq *fq,\n\t\t\t  struct fq_flow *flow,\n\t\t\t  fq_skb_free_t free_func)\n{\n\tstruct fq_tin *tin = flow->tin;\n\tstruct sk_buff *skb;\n\n\twhile ((skb = fq_flow_dequeue(fq, flow)))\n\t\tfree_func(fq, tin, flow, skb);\n\n\tif (!list_empty(&flow->flowchain)) {\n\t\tlist_del_init(&flow->flowchain);\n\t\tif (list_empty(&tin->new_flows) &&\n\t\t    list_empty(&tin->old_flows))\n\t\t\tlist_del_init(&tin->tin_list);\n\t}\n\n\tflow->tin = NULL;\n\n\tWARN_ON_ONCE(flow->backlog);\n}\n\nstatic void fq_tin_reset(struct fq *fq,\n\t\t\t struct fq_tin *tin,\n\t\t\t fq_skb_free_t free_func)\n{\n\tstruct list_head *head;\n\tstruct fq_flow *flow;\n\n\tfor (;;) {\n\t\thead = &tin->new_flows;\n\t\tif (list_empty(head)) {\n\t\t\thead = &tin->old_flows;\n\t\t\tif (list_empty(head))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tflow = list_first_entry(head, struct fq_flow, flowchain);\n\t\tfq_flow_reset(fq, flow, free_func);\n\t}\n\n\tWARN_ON_ONCE(!list_empty(&tin->tin_list));\n\tWARN_ON_ONCE(tin->backlog_bytes);\n\tWARN_ON_ONCE(tin->backlog_packets);\n}\n\nstatic void fq_flow_init(struct fq_flow *flow)\n{\n\tINIT_LIST_HEAD(&flow->flowchain);\n\t__skb_queue_head_init(&flow->queue);\n}\n\nstatic void fq_tin_init(struct fq_tin *tin)\n{\n\tINIT_LIST_HEAD(&tin->new_flows);\n\tINIT_LIST_HEAD(&tin->old_flows);\n\tINIT_LIST_HEAD(&tin->tin_list);\n\tfq_flow_init(&tin->default_flow);\n}\n\nstatic int fq_init(struct fq *fq, int flows_cnt)\n{\n\tint i;\n\n\tmemset(fq, 0, sizeof(fq[0]));\n\tspin_lock_init(&fq->lock);\n\tINIT_LIST_HEAD(&fq->tin_backlog);\n\tfq->flows_cnt = max_t(u32, flows_cnt, 1);\n\tfq->quantum = 300;\n\tfq->limit = 8192;\n\tfq->memory_limit = 16 << 20;  \n\n\tfq->flows = kvcalloc(fq->flows_cnt, sizeof(fq->flows[0]), GFP_KERNEL);\n\tif (!fq->flows)\n\t\treturn -ENOMEM;\n\n\tfq->flows_bitmap = bitmap_zalloc(fq->flows_cnt, GFP_KERNEL);\n\tif (!fq->flows_bitmap) {\n\t\tkvfree(fq->flows);\n\t\tfq->flows = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < fq->flows_cnt; i++)\n\t\tfq_flow_init(&fq->flows[i]);\n\n\treturn 0;\n}\n\nstatic void fq_reset(struct fq *fq,\n\t\t     fq_skb_free_t free_func)\n{\n\tint i;\n\n\tfor (i = 0; i < fq->flows_cnt; i++)\n\t\tfq_flow_reset(fq, &fq->flows[i], free_func);\n\n\tkvfree(fq->flows);\n\tfq->flows = NULL;\n\n\tbitmap_free(fq->flows_bitmap);\n\tfq->flows_bitmap = NULL;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}