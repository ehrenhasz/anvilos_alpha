{
  "module_name": "mld.h",
  "hash_id": "1106cbcb89c06861b11fbbce9d3ab1bd9eded7824dc9c17247966938f2acce5e",
  "original_prompt": "Ingested from linux-6.6.14/include/net/mld.h",
  "human_readable_source": " \n#ifndef LINUX_MLD_H\n#define LINUX_MLD_H\n\n#include <linux/in6.h>\n#include <linux/icmpv6.h>\n\n \nstruct mld_msg {\n\tstruct icmp6hdr\t\tmld_hdr;\n\tstruct in6_addr\t\tmld_mca;\n};\n\n#define mld_type\t\tmld_hdr.icmp6_type\n#define mld_code\t\tmld_hdr.icmp6_code\n#define mld_cksum\t\tmld_hdr.icmp6_cksum\n#define mld_maxdelay\t\tmld_hdr.icmp6_maxdelay\n#define mld_reserved\t\tmld_hdr.icmp6_dataun.un_data16[1]\n\n \n \nstruct mld2_grec {\n\t__u8\t\tgrec_type;\n\t__u8\t\tgrec_auxwords;\n\t__be16\t\tgrec_nsrcs;\n\tstruct in6_addr\tgrec_mca;\n\tstruct in6_addr\tgrec_src[];\n};\n\nstruct mld2_report {\n\tstruct icmp6hdr\t\tmld2r_hdr;\n\tstruct mld2_grec\tmld2r_grec[];\n};\n\n#define mld2r_type\t\tmld2r_hdr.icmp6_type\n#define mld2r_resv1\t\tmld2r_hdr.icmp6_code\n#define mld2r_cksum\t\tmld2r_hdr.icmp6_cksum\n#define mld2r_resv2\t\tmld2r_hdr.icmp6_dataun.un_data16[0]\n#define mld2r_ngrec\t\tmld2r_hdr.icmp6_dataun.un_data16[1]\n\n \nstruct mld2_query {\n\tstruct icmp6hdr\t\tmld2q_hdr;\n\tstruct in6_addr\t\tmld2q_mca;\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\t__u8\t\t\tmld2q_qrv:3,\n\t\t\t\tmld2q_suppress:1,\n\t\t\t\tmld2q_resv2:4;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n\t__u8\t\t\tmld2q_resv2:4,\n\t\t\t\tmld2q_suppress:1,\n\t\t\t\tmld2q_qrv:3;\n#else\n#error \"Please fix <asm/byteorder.h>\"\n#endif\n\t__u8\t\t\tmld2q_qqic;\n\t__be16\t\t\tmld2q_nsrcs;\n\tstruct in6_addr\t\tmld2q_srcs[];\n};\n\n#define mld2q_type\t\tmld2q_hdr.icmp6_type\n#define mld2q_code\t\tmld2q_hdr.icmp6_code\n#define mld2q_cksum\t\tmld2q_hdr.icmp6_cksum\n#define mld2q_mrc\t\tmld2q_hdr.icmp6_maxdelay\n#define mld2q_resv1\t\tmld2q_hdr.icmp6_dataun.un_data16[1]\n\n \n#define MLDV2_MRC_EXP(value)\t(((value) >> 12) & 0x0007)\n#define MLDV2_MRC_MAN(value)\t((value) & 0x0fff)\n\n \n#define MLDV2_QQIC_EXP(value)\t(((value) >> 4) & 0x07)\n#define MLDV2_QQIC_MAN(value)\t((value) & 0x0f)\n\n#define MLD_EXP_MIN_LIMIT\t32768UL\n#define MLDV1_MRD_MAX_COMPAT\t(MLD_EXP_MIN_LIMIT - 1)\n\n#define MLD_MAX_QUEUE\t\t8\n#define MLD_MAX_SKBS\t\t32\n\nstatic inline unsigned long mldv2_mrc(const struct mld2_query *mlh2)\n{\n\t \n\tunsigned long ret, mc_mrc = ntohs(mlh2->mld2q_mrc);\n\n\tif (mc_mrc < MLD_EXP_MIN_LIMIT) {\n\t\tret = mc_mrc;\n\t} else {\n\t\tunsigned long mc_man, mc_exp;\n\n\t\tmc_exp = MLDV2_MRC_EXP(mc_mrc);\n\t\tmc_man = MLDV2_MRC_MAN(mc_mrc);\n\n\t\tret = (mc_man | 0x1000) << (mc_exp + 3);\n\t}\n\n\treturn ret;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}