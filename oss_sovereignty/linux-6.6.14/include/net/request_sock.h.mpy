{
  "module_name": "request_sock.h",
  "hash_id": "83f92ab5bc08b6295b3c160664e4c9d25c6a8b05139e92e289ca5f8701c35bbb",
  "original_prompt": "Ingested from linux-6.6.14/include/net/request_sock.h",
  "human_readable_source": " \n \n#ifndef _REQUEST_SOCK_H\n#define _REQUEST_SOCK_H\n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/bug.h>\n#include <linux/refcount.h>\n\n#include <net/sock.h>\n\nstruct request_sock;\nstruct sk_buff;\nstruct dst_entry;\nstruct proto;\n\nstruct request_sock_ops {\n\tint\t\tfamily;\n\tunsigned int\tobj_size;\n\tstruct kmem_cache\t*slab;\n\tchar\t\t*slab_name;\n\tint\t\t(*rtx_syn_ack)(const struct sock *sk,\n\t\t\t\t       struct request_sock *req);\n\tvoid\t\t(*send_ack)(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t    struct request_sock *req);\n\tvoid\t\t(*send_reset)(const struct sock *sk,\n\t\t\t\t      struct sk_buff *skb);\n\tvoid\t\t(*destructor)(struct request_sock *req);\n\tvoid\t\t(*syn_ack_timeout)(const struct request_sock *req);\n};\n\nint inet_rtx_syn_ack(const struct sock *parent, struct request_sock *req);\n\nstruct saved_syn {\n\tu32 mac_hdrlen;\n\tu32 network_hdrlen;\n\tu32 tcp_hdrlen;\n\tu8 data[];\n};\n\n \nstruct request_sock {\n\tstruct sock_common\t\t__req_common;\n#define rsk_refcnt\t\t\t__req_common.skc_refcnt\n#define rsk_hash\t\t\t__req_common.skc_hash\n#define rsk_listener\t\t\t__req_common.skc_listener\n#define rsk_window_clamp\t\t__req_common.skc_window_clamp\n#define rsk_rcv_wnd\t\t\t__req_common.skc_rcv_wnd\n\n\tstruct request_sock\t\t*dl_next;\n\tu16\t\t\t\tmss;\n\tu8\t\t\t\tnum_retrans;  \n\tu8\t\t\t\tsyncookie:1;  \n\tu8\t\t\t\tnum_timeout:7;  \n\tu32\t\t\t\tts_recent;\n\tstruct timer_list\t\trsk_timer;\n\tconst struct request_sock_ops\t*rsk_ops;\n\tstruct sock\t\t\t*sk;\n\tstruct saved_syn\t\t*saved_syn;\n\tu32\t\t\t\tsecid;\n\tu32\t\t\t\tpeer_secid;\n\tu32\t\t\t\ttimeout;\n};\n\nstatic inline struct request_sock *inet_reqsk(const struct sock *sk)\n{\n\treturn (struct request_sock *)sk;\n}\n\nstatic inline struct sock *req_to_sk(struct request_sock *req)\n{\n\treturn (struct sock *)req;\n}\n\nstatic inline struct request_sock *\nreqsk_alloc(const struct request_sock_ops *ops, struct sock *sk_listener,\n\t    bool attach_listener)\n{\n\tstruct request_sock *req;\n\n\treq = kmem_cache_alloc(ops->slab, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!req)\n\t\treturn NULL;\n\treq->rsk_listener = NULL;\n\tif (attach_listener) {\n\t\tif (unlikely(!refcount_inc_not_zero(&sk_listener->sk_refcnt))) {\n\t\t\tkmem_cache_free(ops->slab, req);\n\t\t\treturn NULL;\n\t\t}\n\t\treq->rsk_listener = sk_listener;\n\t}\n\treq->rsk_ops = ops;\n\treq_to_sk(req)->sk_prot = sk_listener->sk_prot;\n\tsk_node_init(&req_to_sk(req)->sk_node);\n\tsk_tx_queue_clear(req_to_sk(req));\n\treq->saved_syn = NULL;\n\treq->timeout = 0;\n\treq->num_timeout = 0;\n\treq->num_retrans = 0;\n\treq->sk = NULL;\n\trefcount_set(&req->rsk_refcnt, 0);\n\n\treturn req;\n}\n\nstatic inline void __reqsk_free(struct request_sock *req)\n{\n\treq->rsk_ops->destructor(req);\n\tif (req->rsk_listener)\n\t\tsock_put(req->rsk_listener);\n\tkfree(req->saved_syn);\n\tkmem_cache_free(req->rsk_ops->slab, req);\n}\n\nstatic inline void reqsk_free(struct request_sock *req)\n{\n\tWARN_ON_ONCE(refcount_read(&req->rsk_refcnt) != 0);\n\t__reqsk_free(req);\n}\n\nstatic inline void reqsk_put(struct request_sock *req)\n{\n\tif (refcount_dec_and_test(&req->rsk_refcnt))\n\t\treqsk_free(req);\n}\n\n \nstruct fastopen_queue {\n\tstruct request_sock\t*rskq_rst_head;  \n\tstruct request_sock\t*rskq_rst_tail;  \n\tspinlock_t\tlock;\n\tint\t\tqlen;\t\t \n\tint\t\tmax_qlen;\t \n\n\tstruct tcp_fastopen_context __rcu *ctx;  \n};\n\n \nstruct request_sock_queue {\n\tspinlock_t\t\trskq_lock;\n\tu8\t\t\trskq_defer_accept;\n\n\tu32\t\t\tsynflood_warned;\n\tatomic_t\t\tqlen;\n\tatomic_t\t\tyoung;\n\n\tstruct request_sock\t*rskq_accept_head;\n\tstruct request_sock\t*rskq_accept_tail;\n\tstruct fastopen_queue\tfastopenq;   \n};\n\nvoid reqsk_queue_alloc(struct request_sock_queue *queue);\n\nvoid reqsk_fastopen_remove(struct sock *sk, struct request_sock *req,\n\t\t\t   bool reset);\n\nstatic inline bool reqsk_queue_empty(const struct request_sock_queue *queue)\n{\n\treturn READ_ONCE(queue->rskq_accept_head) == NULL;\n}\n\nstatic inline struct request_sock *reqsk_queue_remove(struct request_sock_queue *queue,\n\t\t\t\t\t\t      struct sock *parent)\n{\n\tstruct request_sock *req;\n\n\tspin_lock_bh(&queue->rskq_lock);\n\treq = queue->rskq_accept_head;\n\tif (req) {\n\t\tsk_acceptq_removed(parent);\n\t\tWRITE_ONCE(queue->rskq_accept_head, req->dl_next);\n\t\tif (queue->rskq_accept_head == NULL)\n\t\t\tqueue->rskq_accept_tail = NULL;\n\t}\n\tspin_unlock_bh(&queue->rskq_lock);\n\treturn req;\n}\n\nstatic inline void reqsk_queue_removed(struct request_sock_queue *queue,\n\t\t\t\t       const struct request_sock *req)\n{\n\tif (req->num_timeout == 0)\n\t\tatomic_dec(&queue->young);\n\tatomic_dec(&queue->qlen);\n}\n\nstatic inline void reqsk_queue_added(struct request_sock_queue *queue)\n{\n\tatomic_inc(&queue->young);\n\tatomic_inc(&queue->qlen);\n}\n\nstatic inline int reqsk_queue_len(const struct request_sock_queue *queue)\n{\n\treturn atomic_read(&queue->qlen);\n}\n\nstatic inline int reqsk_queue_len_young(const struct request_sock_queue *queue)\n{\n\treturn atomic_read(&queue->young);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}