{
  "module_name": "garp.h",
  "hash_id": "de8956885bbb4ed2e37d810492e05f38dcf2b77fe3f4170498869d10ffb7d729",
  "original_prompt": "Ingested from linux-6.6.14/include/net/garp.h",
  "human_readable_source": " \n#ifndef _NET_GARP_H\n#define _NET_GARP_H\n\n#include <linux/if_ether.h>\n#include <linux/types.h>\n#include <net/stp.h>\n\n#define GARP_PROTOCOL_ID\t0x1\n#define GARP_END_MARK\t\t0x0\n\nstruct garp_pdu_hdr {\n\t__be16\tprotocol;\n};\n\nstruct garp_msg_hdr {\n\tu8\tattrtype;\n};\n\nenum garp_attr_event {\n\tGARP_LEAVE_ALL,\n\tGARP_JOIN_EMPTY,\n\tGARP_JOIN_IN,\n\tGARP_LEAVE_EMPTY,\n\tGARP_LEAVE_IN,\n\tGARP_EMPTY,\n};\n\nstruct garp_attr_hdr {\n\tu8\tlen;\n\tu8\tevent;\n\tu8\tdata[];\n};\n\nstruct garp_skb_cb {\n\tu8\tcur_type;\n};\n\nstatic inline struct garp_skb_cb *garp_cb(struct sk_buff *skb)\n{\n\tBUILD_BUG_ON(sizeof(struct garp_skb_cb) >\n\t\t     sizeof_field(struct sk_buff, cb));\n\treturn (struct garp_skb_cb *)skb->cb;\n}\n\nenum garp_applicant_state {\n\tGARP_APPLICANT_INVALID,\n\tGARP_APPLICANT_VA,\n\tGARP_APPLICANT_AA,\n\tGARP_APPLICANT_QA,\n\tGARP_APPLICANT_LA,\n\tGARP_APPLICANT_VP,\n\tGARP_APPLICANT_AP,\n\tGARP_APPLICANT_QP,\n\tGARP_APPLICANT_VO,\n\tGARP_APPLICANT_AO,\n\tGARP_APPLICANT_QO,\n\t__GARP_APPLICANT_MAX\n};\n#define GARP_APPLICANT_MAX\t(__GARP_APPLICANT_MAX - 1)\n\nenum garp_event {\n\tGARP_EVENT_REQ_JOIN,\n\tGARP_EVENT_REQ_LEAVE,\n\tGARP_EVENT_R_JOIN_IN,\n\tGARP_EVENT_R_JOIN_EMPTY,\n\tGARP_EVENT_R_EMPTY,\n\tGARP_EVENT_R_LEAVE_IN,\n\tGARP_EVENT_R_LEAVE_EMPTY,\n\tGARP_EVENT_TRANSMIT_PDU,\n\t__GARP_EVENT_MAX\n};\n#define GARP_EVENT_MAX\t\t(__GARP_EVENT_MAX - 1)\n\nenum garp_action {\n\tGARP_ACTION_NONE,\n\tGARP_ACTION_S_JOIN_IN,\n\tGARP_ACTION_S_LEAVE_EMPTY,\n};\n\nstruct garp_attr {\n\tstruct rb_node\t\t\tnode;\n\tenum garp_applicant_state\tstate;\n\tu8\t\t\t\ttype;\n\tu8\t\t\t\tdlen;\n\tunsigned char\t\t\tdata[];\n};\n\nenum garp_applications {\n\tGARP_APPLICATION_GVRP,\n\t__GARP_APPLICATION_MAX\n};\n#define GARP_APPLICATION_MAX\t(__GARP_APPLICATION_MAX - 1)\n\nstruct garp_application {\n\tenum garp_applications\ttype;\n\tunsigned int\t\tmaxattr;\n\tstruct stp_proto\tproto;\n};\n\nstruct garp_applicant {\n\tstruct garp_application\t*app;\n\tstruct net_device\t*dev;\n\tstruct timer_list\tjoin_timer;\n\n\tspinlock_t\t\tlock;\n\tstruct sk_buff_head\tqueue;\n\tstruct sk_buff\t\t*pdu;\n\tstruct rb_root\t\tgid;\n\tstruct rcu_head\t\trcu;\n};\n\nstruct garp_port {\n\tstruct garp_applicant __rcu\t*applicants[GARP_APPLICATION_MAX + 1];\n\tstruct rcu_head\t\t\trcu;\n};\n\nint garp_register_application(struct garp_application *app);\nvoid garp_unregister_application(struct garp_application *app);\n\nint garp_init_applicant(struct net_device *dev, struct garp_application *app);\nvoid garp_uninit_applicant(struct net_device *dev,\n\t\t\t   struct garp_application *app);\n\nint garp_request_join(const struct net_device *dev,\n\t\t      const struct garp_application *app, const void *data,\n\t\t      u8 len, u8 type);\nvoid garp_request_leave(const struct net_device *dev,\n\t\t\tconst struct garp_application *app,\n\t\t\tconst void *data, u8 len, u8 type);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}