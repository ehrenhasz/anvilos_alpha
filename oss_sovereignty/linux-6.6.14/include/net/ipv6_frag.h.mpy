{
  "module_name": "ipv6_frag.h",
  "hash_id": "d38f89bdedd97098992fda1f7f5069ce0f872945abe63eaebdbd1329b87cdcbd",
  "original_prompt": "Ingested from linux-6.6.14/include/net/ipv6_frag.h",
  "human_readable_source": " \n#ifndef _IPV6_FRAG_H\n#define _IPV6_FRAG_H\n#include <linux/icmpv6.h>\n#include <linux/kernel.h>\n#include <net/addrconf.h>\n#include <net/ipv6.h>\n#include <net/inet_frag.h>\n\nenum ip6_defrag_users {\n\tIP6_DEFRAG_LOCAL_DELIVER,\n\tIP6_DEFRAG_CONNTRACK_IN,\n\t__IP6_DEFRAG_CONNTRACK_IN\t= IP6_DEFRAG_CONNTRACK_IN + USHRT_MAX,\n\tIP6_DEFRAG_CONNTRACK_OUT,\n\t__IP6_DEFRAG_CONNTRACK_OUT\t= IP6_DEFRAG_CONNTRACK_OUT + USHRT_MAX,\n\tIP6_DEFRAG_CONNTRACK_BRIDGE_IN,\n\t__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = IP6_DEFRAG_CONNTRACK_BRIDGE_IN + USHRT_MAX,\n};\n\n \nstruct frag_queue {\n\tstruct inet_frag_queue\tq;\n\n\tint\t\t\tiif;\n\t__u16\t\t\tnhoffset;\n\tu8\t\t\tecn;\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline void ip6frag_init(struct inet_frag_queue *q, const void *a)\n{\n\tstruct frag_queue *fq = container_of(q, struct frag_queue, q);\n\tconst struct frag_v6_compare_key *key = a;\n\n\tq->key.v6 = *key;\n\tfq->ecn = 0;\n}\n\nstatic inline u32 ip6frag_key_hashfn(const void *data, u32 len, u32 seed)\n{\n\treturn jhash2(data,\n\t\t      sizeof(struct frag_v6_compare_key) / sizeof(u32), seed);\n}\n\nstatic inline u32 ip6frag_obj_hashfn(const void *data, u32 len, u32 seed)\n{\n\tconst struct inet_frag_queue *fq = data;\n\n\treturn jhash2((const u32 *)&fq->key.v6,\n\t\t      sizeof(struct frag_v6_compare_key) / sizeof(u32), seed);\n}\n\nstatic inline int\nip6frag_obj_cmpfn(struct rhashtable_compare_arg *arg, const void *ptr)\n{\n\tconst struct frag_v6_compare_key *key = arg->key;\n\tconst struct inet_frag_queue *fq = ptr;\n\n\treturn !!memcmp(&fq->key, key, sizeof(*key));\n}\n\nstatic inline void\nip6frag_expire_frag_queue(struct net *net, struct frag_queue *fq)\n{\n\tstruct net_device *dev = NULL;\n\tstruct sk_buff *head;\n\n\trcu_read_lock();\n\t \n\tif (READ_ONCE(fq->q.fqdir->dead))\n\t\tgoto out_rcu_unlock;\n\tspin_lock(&fq->q.lock);\n\n\tif (fq->q.flags & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tfq->q.flags |= INET_FRAG_DROP;\n\tinet_frag_kill(&fq->q);\n\n\tdev = dev_get_by_index_rcu(net, fq->iif);\n\tif (!dev)\n\t\tgoto out;\n\n\t__IP6_INC_STATS(net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);\n\t__IP6_INC_STATS(net, __in6_dev_get(dev), IPSTATS_MIB_REASMTIMEOUT);\n\n\t \n\tif (!(fq->q.flags & INET_FRAG_FIRST_IN))\n\t\tgoto out;\n\n\t \n\thead = inet_frag_pull_head(&fq->q);\n\tif (!head)\n\t\tgoto out;\n\n\thead->dev = dev;\n\tspin_unlock(&fq->q.lock);\n\n\ticmpv6_send(head, ICMPV6_TIME_EXCEED, ICMPV6_EXC_FRAGTIME, 0);\n\tkfree_skb_reason(head, SKB_DROP_REASON_FRAG_REASM_TIMEOUT);\n\tgoto out_rcu_unlock;\n\nout:\n\tspin_unlock(&fq->q.lock);\nout_rcu_unlock:\n\trcu_read_unlock();\n\tinet_frag_put(&fq->q);\n}\n\n \nstatic inline bool\nipv6frag_thdr_truncated(struct sk_buff *skb, int start, u8 *nexthdrp)\n{\n\tu8 nexthdr = *nexthdrp;\n\t__be16 frag_off;\n\tint offset;\n\n\toffset = ipv6_skip_exthdr(skb, start, &nexthdr, &frag_off);\n\tif (offset < 0 || (frag_off & htons(IP6_OFFSET)))\n\t\treturn false;\n\tswitch (nexthdr) {\n\tcase NEXTHDR_TCP:\n\t\toffset += sizeof(struct tcphdr);\n\t\tbreak;\n\tcase NEXTHDR_UDP:\n\t\toffset += sizeof(struct udphdr);\n\t\tbreak;\n\tcase NEXTHDR_ICMP:\n\t\toffset += sizeof(struct icmp6hdr);\n\t\tbreak;\n\tdefault:\n\t\toffset += 1;\n\t}\n\tif (offset > skb->len)\n\t\treturn true;\n\treturn false;\n}\n\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}