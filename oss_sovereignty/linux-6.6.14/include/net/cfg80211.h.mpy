{
  "module_name": "cfg80211.h",
  "hash_id": "8113ba06ef26e3534ffec649a489baab73822b0bab8232837771da3a31b98b69",
  "original_prompt": "Ingested from linux-6.6.14/include/net/cfg80211.h",
  "human_readable_source": " \n#ifndef __NET_CFG80211_H\n#define __NET_CFG80211_H\n \n\n#include <linux/ethtool.h>\n#include <uapi/linux/rfkill.h>\n#include <linux/netdevice.h>\n#include <linux/debugfs.h>\n#include <linux/list.h>\n#include <linux/bug.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/nl80211.h>\n#include <linux/if_ether.h>\n#include <linux/ieee80211.h>\n#include <linux/net.h>\n#include <linux/rfkill.h>\n#include <net/regulatory.h>\n\n \n\n\n \n\nstruct wiphy;\n\n \n\n \nenum ieee80211_channel_flags {\n\tIEEE80211_CHAN_DISABLED\t\t= 1<<0,\n\tIEEE80211_CHAN_NO_IR\t\t= 1<<1,\n\t \n\tIEEE80211_CHAN_RADAR\t\t= 1<<3,\n\tIEEE80211_CHAN_NO_HT40PLUS\t= 1<<4,\n\tIEEE80211_CHAN_NO_HT40MINUS\t= 1<<5,\n\tIEEE80211_CHAN_NO_OFDM\t\t= 1<<6,\n\tIEEE80211_CHAN_NO_80MHZ\t\t= 1<<7,\n\tIEEE80211_CHAN_NO_160MHZ\t= 1<<8,\n\tIEEE80211_CHAN_INDOOR_ONLY\t= 1<<9,\n\tIEEE80211_CHAN_IR_CONCURRENT\t= 1<<10,\n\tIEEE80211_CHAN_NO_20MHZ\t\t= 1<<11,\n\tIEEE80211_CHAN_NO_10MHZ\t\t= 1<<12,\n\tIEEE80211_CHAN_NO_HE\t\t= 1<<13,\n\tIEEE80211_CHAN_1MHZ\t\t= 1<<14,\n\tIEEE80211_CHAN_2MHZ\t\t= 1<<15,\n\tIEEE80211_CHAN_4MHZ\t\t= 1<<16,\n\tIEEE80211_CHAN_8MHZ\t\t= 1<<17,\n\tIEEE80211_CHAN_16MHZ\t\t= 1<<18,\n\tIEEE80211_CHAN_NO_320MHZ\t= 1<<19,\n\tIEEE80211_CHAN_NO_EHT\t\t= 1<<20,\n};\n\n#define IEEE80211_CHAN_NO_HT40 \\\n\t(IEEE80211_CHAN_NO_HT40PLUS | IEEE80211_CHAN_NO_HT40MINUS)\n\n#define IEEE80211_DFS_MIN_CAC_TIME_MS\t\t60000\n#define IEEE80211_DFS_MIN_NOP_TIME_MS\t\t(30 * 60 * 1000)\n\n \nstruct ieee80211_channel {\n\tenum nl80211_band band;\n\tu32 center_freq;\n\tu16 freq_offset;\n\tu16 hw_value;\n\tu32 flags;\n\tint max_antenna_gain;\n\tint max_power;\n\tint max_reg_power;\n\tbool beacon_found;\n\tu32 orig_flags;\n\tint orig_mag, orig_mpwr;\n\tenum nl80211_dfs_state dfs_state;\n\tunsigned long dfs_state_entered;\n\tunsigned int dfs_cac_ms;\n};\n\n \nenum ieee80211_rate_flags {\n\tIEEE80211_RATE_SHORT_PREAMBLE\t= 1<<0,\n\tIEEE80211_RATE_MANDATORY_A\t= 1<<1,\n\tIEEE80211_RATE_MANDATORY_B\t= 1<<2,\n\tIEEE80211_RATE_MANDATORY_G\t= 1<<3,\n\tIEEE80211_RATE_ERP_G\t\t= 1<<4,\n\tIEEE80211_RATE_SUPPORTS_5MHZ\t= 1<<5,\n\tIEEE80211_RATE_SUPPORTS_10MHZ\t= 1<<6,\n};\n\n \nenum ieee80211_bss_type {\n\tIEEE80211_BSS_TYPE_ESS,\n\tIEEE80211_BSS_TYPE_PBSS,\n\tIEEE80211_BSS_TYPE_IBSS,\n\tIEEE80211_BSS_TYPE_MBSS,\n\tIEEE80211_BSS_TYPE_ANY\n};\n\n \nenum ieee80211_privacy {\n\tIEEE80211_PRIVACY_ON,\n\tIEEE80211_PRIVACY_OFF,\n\tIEEE80211_PRIVACY_ANY\n};\n\n#define IEEE80211_PRIVACY(x)\t\\\n\t((x) ? IEEE80211_PRIVACY_ON : IEEE80211_PRIVACY_OFF)\n\n \nstruct ieee80211_rate {\n\tu32 flags;\n\tu16 bitrate;\n\tu16 hw_value, hw_value_short;\n};\n\n \nstruct ieee80211_he_obss_pd {\n\tbool enable;\n\tu8 sr_ctrl;\n\tu8 non_srg_max_offset;\n\tu8 min_offset;\n\tu8 max_offset;\n\tu8 bss_color_bitmap[8];\n\tu8 partial_bssid_bitmap[8];\n};\n\n \nstruct cfg80211_he_bss_color {\n\tu8 color;\n\tbool enabled;\n\tbool partial;\n};\n\n \nstruct ieee80211_sta_ht_cap {\n\tu16 cap;  \n\tbool ht_supported;\n\tu8 ampdu_factor;\n\tu8 ampdu_density;\n\tstruct ieee80211_mcs_info mcs;\n};\n\n \nstruct ieee80211_sta_vht_cap {\n\tbool vht_supported;\n\tu32 cap;  \n\tstruct ieee80211_vht_mcs_info vht_mcs;\n};\n\n#define IEEE80211_HE_PPE_THRES_MAX_LEN\t\t25\n\n \nstruct ieee80211_sta_he_cap {\n\tbool has_he;\n\tstruct ieee80211_he_cap_elem he_cap_elem;\n\tstruct ieee80211_he_mcs_nss_supp he_mcs_nss_supp;\n\tu8 ppe_thres[IEEE80211_HE_PPE_THRES_MAX_LEN];\n};\n\n \nstruct ieee80211_eht_mcs_nss_supp {\n\tunion {\n\t\tstruct ieee80211_eht_mcs_nss_supp_20mhz_only only_20mhz;\n\t\tstruct {\n\t\t\tstruct ieee80211_eht_mcs_nss_supp_bw _80;\n\t\t\tstruct ieee80211_eht_mcs_nss_supp_bw _160;\n\t\t\tstruct ieee80211_eht_mcs_nss_supp_bw _320;\n\t\t} __packed bw;\n\t} __packed;\n} __packed;\n\n#define IEEE80211_EHT_PPE_THRES_MAX_LEN\t\t32\n\n \nstruct ieee80211_sta_eht_cap {\n\tbool has_eht;\n\tstruct ieee80211_eht_cap_elem_fixed eht_cap_elem;\n\tstruct ieee80211_eht_mcs_nss_supp eht_mcs_nss_supp;\n\tu8 eht_ppe_thres[IEEE80211_EHT_PPE_THRES_MAX_LEN];\n};\n\n \nstruct ieee80211_sband_iftype_data {\n\tu16 types_mask;\n\tstruct ieee80211_sta_he_cap he_cap;\n\tstruct ieee80211_he_6ghz_capa he_6ghz_capa;\n\tstruct ieee80211_sta_eht_cap eht_cap;\n\tstruct {\n\t\tconst u8 *data;\n\t\tunsigned int len;\n\t} vendor_elems;\n};\n\n \nenum ieee80211_edmg_bw_config {\n\tIEEE80211_EDMG_BW_CONFIG_4\t= 4,\n\tIEEE80211_EDMG_BW_CONFIG_5\t= 5,\n\tIEEE80211_EDMG_BW_CONFIG_6\t= 6,\n\tIEEE80211_EDMG_BW_CONFIG_7\t= 7,\n\tIEEE80211_EDMG_BW_CONFIG_8\t= 8,\n\tIEEE80211_EDMG_BW_CONFIG_9\t= 9,\n\tIEEE80211_EDMG_BW_CONFIG_10\t= 10,\n\tIEEE80211_EDMG_BW_CONFIG_11\t= 11,\n\tIEEE80211_EDMG_BW_CONFIG_12\t= 12,\n\tIEEE80211_EDMG_BW_CONFIG_13\t= 13,\n\tIEEE80211_EDMG_BW_CONFIG_14\t= 14,\n\tIEEE80211_EDMG_BW_CONFIG_15\t= 15,\n};\n\n \nstruct ieee80211_edmg {\n\tu8 channels;\n\tenum ieee80211_edmg_bw_config bw_config;\n};\n\n \nstruct ieee80211_sta_s1g_cap {\n\tbool s1g;\n\tu8 cap[10];  \n\tu8 nss_mcs[5];\n};\n\n \nstruct ieee80211_supported_band {\n\tstruct ieee80211_channel *channels;\n\tstruct ieee80211_rate *bitrates;\n\tenum nl80211_band band;\n\tint n_channels;\n\tint n_bitrates;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tstruct ieee80211_sta_s1g_cap s1g_cap;\n\tstruct ieee80211_edmg edmg_cap;\n\tu16 n_iftype_data;\n\tconst struct ieee80211_sband_iftype_data *iftype_data;\n};\n\n \nstatic inline const struct ieee80211_sband_iftype_data *\nieee80211_get_sband_iftype_data(const struct ieee80211_supported_band *sband,\n\t\t\t\tu8 iftype)\n{\n\tint i;\n\n\tif (WARN_ON(iftype >= NL80211_IFTYPE_MAX))\n\t\treturn NULL;\n\n\tif (iftype == NL80211_IFTYPE_AP_VLAN)\n\t\tiftype = NL80211_IFTYPE_AP;\n\n\tfor (i = 0; i < sband->n_iftype_data; i++)  {\n\t\tconst struct ieee80211_sband_iftype_data *data =\n\t\t\t&sband->iftype_data[i];\n\n\t\tif (data->types_mask & BIT(iftype))\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic inline const struct ieee80211_sta_he_cap *\nieee80211_get_he_iftype_cap(const struct ieee80211_supported_band *sband,\n\t\t\t    u8 iftype)\n{\n\tconst struct ieee80211_sband_iftype_data *data =\n\t\tieee80211_get_sband_iftype_data(sband, iftype);\n\n\tif (data && data->he_cap.has_he)\n\t\treturn &data->he_cap;\n\n\treturn NULL;\n}\n\n \nstatic inline __le16\nieee80211_get_he_6ghz_capa(const struct ieee80211_supported_band *sband,\n\t\t\t   enum nl80211_iftype iftype)\n{\n\tconst struct ieee80211_sband_iftype_data *data =\n\t\tieee80211_get_sband_iftype_data(sband, iftype);\n\n\tif (WARN_ON(!data || !data->he_cap.has_he))\n\t\treturn 0;\n\n\treturn data->he_6ghz_capa.capa;\n}\n\n \nstatic inline const struct ieee80211_sta_eht_cap *\nieee80211_get_eht_iftype_cap(const struct ieee80211_supported_band *sband,\n\t\t\t     enum nl80211_iftype iftype)\n{\n\tconst struct ieee80211_sband_iftype_data *data =\n\t\tieee80211_get_sband_iftype_data(sband, iftype);\n\n\tif (data && data->eht_cap.has_eht)\n\t\treturn &data->eht_cap;\n\n\treturn NULL;\n}\n\n \n#ifdef CONFIG_OF\nvoid wiphy_read_of_freq_limits(struct wiphy *wiphy);\n#else  \nstatic inline void wiphy_read_of_freq_limits(struct wiphy *wiphy)\n{\n}\n#endif  \n\n\n \n\n \n\n#define VHT_MUMIMO_GROUPS_DATA_LEN (WLAN_MEMBERSHIP_LEN +\\\n\t\t\t\t    WLAN_USER_POSITION_LEN)\n\n \nstruct vif_params {\n\tu32 flags;\n\tint use_4addr;\n\tu8 macaddr[ETH_ALEN];\n\tconst u8 *vht_mumimo_groups;\n\tconst u8 *vht_mumimo_follow_addr;\n};\n\n \nstruct key_params {\n\tconst u8 *key;\n\tconst u8 *seq;\n\tint key_len;\n\tint seq_len;\n\tu16 vlan_id;\n\tu32 cipher;\n\tenum nl80211_key_mode mode;\n};\n\n \nstruct cfg80211_chan_def {\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_chan_width width;\n\tu32 center_freq1;\n\tu32 center_freq2;\n\tstruct ieee80211_edmg edmg;\n\tu16 freq1_offset;\n};\n\n \nstruct cfg80211_bitrate_mask {\n\tstruct {\n\t\tu32 legacy;\n\t\tu8 ht_mcs[IEEE80211_HT_MCS_MASK_LEN];\n\t\tu16 vht_mcs[NL80211_VHT_NSS_MAX];\n\t\tu16 he_mcs[NL80211_HE_NSS_MAX];\n\t\tenum nl80211_txrate_gi gi;\n\t\tenum nl80211_he_gi he_gi;\n\t\tenum nl80211_he_ltf he_ltf;\n\t} control[NUM_NL80211_BANDS];\n};\n\n\n \nstruct cfg80211_tid_cfg {\n\tbool config_override;\n\tu8 tids;\n\tu64 mask;\n\tenum nl80211_tid_config noack;\n\tu8 retry_long, retry_short;\n\tenum nl80211_tid_config ampdu;\n\tenum nl80211_tid_config rtscts;\n\tenum nl80211_tid_config amsdu;\n\tenum nl80211_tx_rate_setting txrate_type;\n\tstruct cfg80211_bitrate_mask txrate_mask;\n};\n\n \nstruct cfg80211_tid_config {\n\tconst u8 *peer;\n\tu32 n_tid_conf;\n\tstruct cfg80211_tid_cfg tid_conf[] __counted_by(n_tid_conf);\n};\n\n \nstruct cfg80211_fils_aad {\n\tconst u8 *macaddr;\n\tconst u8 *kek;\n\tu8 kek_len;\n\tconst u8 *snonce;\n\tconst u8 *anonce;\n};\n\n \nstruct cfg80211_set_hw_timestamp {\n\tconst u8 *macaddr;\n\tbool enable;\n};\n\n \nstatic inline enum nl80211_channel_type\ncfg80211_get_chandef_type(const struct cfg80211_chan_def *chandef)\n{\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\treturn NL80211_CHAN_NO_HT;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\treturn NL80211_CHAN_HT20;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (chandef->center_freq1 > chandef->chan->center_freq)\n\t\t\treturn NL80211_CHAN_HT40PLUS;\n\t\treturn NL80211_CHAN_HT40MINUS;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn NL80211_CHAN_NO_HT;\n\t}\n}\n\n \nvoid cfg80211_chandef_create(struct cfg80211_chan_def *chandef,\n\t\t\t     struct ieee80211_channel *channel,\n\t\t\t     enum nl80211_channel_type chantype);\n\n \nstatic inline bool\ncfg80211_chandef_identical(const struct cfg80211_chan_def *chandef1,\n\t\t\t   const struct cfg80211_chan_def *chandef2)\n{\n\treturn (chandef1->chan == chandef2->chan &&\n\t\tchandef1->width == chandef2->width &&\n\t\tchandef1->center_freq1 == chandef2->center_freq1 &&\n\t\tchandef1->freq1_offset == chandef2->freq1_offset &&\n\t\tchandef1->center_freq2 == chandef2->center_freq2);\n}\n\n \nstatic inline bool\ncfg80211_chandef_is_edmg(const struct cfg80211_chan_def *chandef)\n{\n\treturn chandef->edmg.channels || chandef->edmg.bw_config;\n}\n\n \nconst struct cfg80211_chan_def *\ncfg80211_chandef_compatible(const struct cfg80211_chan_def *chandef1,\n\t\t\t    const struct cfg80211_chan_def *chandef2);\n\n \nbool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef);\n\n \nbool cfg80211_chandef_usable(struct wiphy *wiphy,\n\t\t\t     const struct cfg80211_chan_def *chandef,\n\t\t\t     u32 prohibited_flags);\n\n \nint cfg80211_chandef_dfs_required(struct wiphy *wiphy,\n\t\t\t\t  const struct cfg80211_chan_def *chandef,\n\t\t\t\t  enum nl80211_iftype iftype);\n\n \nint nl80211_send_chandef(struct sk_buff *msg, const struct cfg80211_chan_def *chandef);\n\n \nstatic inline enum ieee80211_rate_flags\nieee80211_chanwidth_rate_flags(enum nl80211_chan_width width)\n{\n\tswitch (width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\t\treturn IEEE80211_RATE_SUPPORTS_5MHZ;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\treturn IEEE80211_RATE_SUPPORTS_10MHZ;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic inline enum ieee80211_rate_flags\nieee80211_chandef_rate_flags(struct cfg80211_chan_def *chandef)\n{\n\treturn ieee80211_chanwidth_rate_flags(chandef->width);\n}\n\n \nstatic inline int\nieee80211_chandef_max_power(struct cfg80211_chan_def *chandef)\n{\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\t\treturn min(chandef->chan->max_reg_power - 6,\n\t\t\t   chandef->chan->max_power);\n\tcase NL80211_CHAN_WIDTH_10:\n\t\treturn min(chandef->chan->max_reg_power - 3,\n\t\t\t   chandef->chan->max_power);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn chandef->chan->max_power;\n}\n\n \nbool cfg80211_any_usable_channels(struct wiphy *wiphy,\n\t\t\t\t  unsigned long band_mask,\n\t\t\t\t  u32 prohibited_flags);\n\n \nenum survey_info_flags {\n\tSURVEY_INFO_NOISE_DBM\t\t= BIT(0),\n\tSURVEY_INFO_IN_USE\t\t= BIT(1),\n\tSURVEY_INFO_TIME\t\t= BIT(2),\n\tSURVEY_INFO_TIME_BUSY\t\t= BIT(3),\n\tSURVEY_INFO_TIME_EXT_BUSY\t= BIT(4),\n\tSURVEY_INFO_TIME_RX\t\t= BIT(5),\n\tSURVEY_INFO_TIME_TX\t\t= BIT(6),\n\tSURVEY_INFO_TIME_SCAN\t\t= BIT(7),\n\tSURVEY_INFO_TIME_BSS_RX\t\t= BIT(8),\n};\n\n \nstruct survey_info {\n\tstruct ieee80211_channel *channel;\n\tu64 time;\n\tu64 time_busy;\n\tu64 time_ext_busy;\n\tu64 time_rx;\n\tu64 time_tx;\n\tu64 time_scan;\n\tu64 time_bss_rx;\n\tu32 filled;\n\ts8 noise;\n};\n\n#define CFG80211_MAX_NUM_AKM_SUITES\t10\n\n \nstruct cfg80211_crypto_settings {\n\tu32 wpa_versions;\n\tu32 cipher_group;\n\tint n_ciphers_pairwise;\n\tu32 ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES];\n\tint n_akm_suites;\n\tu32 akm_suites[CFG80211_MAX_NUM_AKM_SUITES];\n\tbool control_port;\n\t__be16 control_port_ethertype;\n\tbool control_port_no_encrypt;\n\tbool control_port_over_nl80211;\n\tbool control_port_no_preauth;\n\tconst u8 *psk;\n\tconst u8 *sae_pwd;\n\tu8 sae_pwd_len;\n\tenum nl80211_sae_pwe_mechanism sae_pwe;\n};\n\n \nstruct cfg80211_mbssid_config {\n\tstruct wireless_dev *tx_wdev;\n\tu8 index;\n\tbool ema;\n};\n\n \nstruct cfg80211_mbssid_elems {\n\tu8 cnt;\n\tstruct {\n\t\tconst u8 *data;\n\t\tsize_t len;\n\t} elem[] __counted_by(cnt);\n};\n\n \nstruct cfg80211_rnr_elems {\n\tu8 cnt;\n\tstruct {\n\t\tconst u8 *data;\n\t\tsize_t len;\n\t} elem[] __counted_by(cnt);\n};\n\n \nstruct cfg80211_beacon_data {\n\tunsigned int link_id;\n\n\tconst u8 *head, *tail;\n\tconst u8 *beacon_ies;\n\tconst u8 *proberesp_ies;\n\tconst u8 *assocresp_ies;\n\tconst u8 *probe_resp;\n\tconst u8 *lci;\n\tconst u8 *civicloc;\n\tstruct cfg80211_mbssid_elems *mbssid_ies;\n\tstruct cfg80211_rnr_elems *rnr_ies;\n\ts8 ftm_responder;\n\n\tsize_t head_len, tail_len;\n\tsize_t beacon_ies_len;\n\tsize_t proberesp_ies_len;\n\tsize_t assocresp_ies_len;\n\tsize_t probe_resp_len;\n\tsize_t lci_len;\n\tsize_t civicloc_len;\n\tstruct cfg80211_he_bss_color he_bss_color;\n\tbool he_bss_color_valid;\n};\n\nstruct mac_address {\n\tu8 addr[ETH_ALEN];\n};\n\n \nstruct cfg80211_acl_data {\n\tenum nl80211_acl_policy acl_policy;\n\tint n_acl_entries;\n\n\t \n\tstruct mac_address mac_addrs[] __counted_by(n_acl_entries);\n};\n\n \nstruct cfg80211_fils_discovery {\n\tu32 min_interval;\n\tu32 max_interval;\n\tsize_t tmpl_len;\n\tconst u8 *tmpl;\n};\n\n \nstruct cfg80211_unsol_bcast_probe_resp {\n\tu32 interval;\n\tsize_t tmpl_len;\n\tconst u8 *tmpl;\n};\n\n \nstruct cfg80211_ap_settings {\n\tstruct cfg80211_chan_def chandef;\n\n\tstruct cfg80211_beacon_data beacon;\n\n\tint beacon_interval, dtim_period;\n\tconst u8 *ssid;\n\tsize_t ssid_len;\n\tenum nl80211_hidden_ssid hidden_ssid;\n\tstruct cfg80211_crypto_settings crypto;\n\tbool privacy;\n\tenum nl80211_auth_type auth_type;\n\tenum nl80211_smps_mode smps_mode;\n\tint inactivity_timeout;\n\tu8 p2p_ctwindow;\n\tbool p2p_opp_ps;\n\tconst struct cfg80211_acl_data *acl;\n\tbool pbss;\n\tstruct cfg80211_bitrate_mask beacon_rate;\n\n\tconst struct ieee80211_ht_cap *ht_cap;\n\tconst struct ieee80211_vht_cap *vht_cap;\n\tconst struct ieee80211_he_cap_elem *he_cap;\n\tconst struct ieee80211_he_operation *he_oper;\n\tconst struct ieee80211_eht_cap_elem *eht_cap;\n\tconst struct ieee80211_eht_operation *eht_oper;\n\tbool ht_required, vht_required, he_required, sae_h2e_required;\n\tbool twt_responder;\n\tu32 flags;\n\tstruct ieee80211_he_obss_pd he_obss_pd;\n\tstruct cfg80211_fils_discovery fils_discovery;\n\tstruct cfg80211_unsol_bcast_probe_resp unsol_bcast_probe_resp;\n\tstruct cfg80211_mbssid_config mbssid_config;\n\tu16 punct_bitmap;\n};\n\n \nstruct cfg80211_csa_settings {\n\tstruct cfg80211_chan_def chandef;\n\tstruct cfg80211_beacon_data beacon_csa;\n\tconst u16 *counter_offsets_beacon;\n\tconst u16 *counter_offsets_presp;\n\tunsigned int n_counter_offsets_beacon;\n\tunsigned int n_counter_offsets_presp;\n\tstruct cfg80211_beacon_data beacon_after;\n\tbool radar_required;\n\tbool block_tx;\n\tu8 count;\n\tu16 punct_bitmap;\n};\n\n \nstruct cfg80211_color_change_settings {\n\tstruct cfg80211_beacon_data beacon_color_change;\n\tu16 counter_offset_beacon;\n\tu16 counter_offset_presp;\n\tstruct cfg80211_beacon_data beacon_next;\n\tu8 count;\n\tu8 color;\n};\n\n \nstruct iface_combination_params {\n\tint num_different_channels;\n\tu8 radar_detect;\n\tint iftype_num[NUM_NL80211_IFTYPES];\n\tu32 new_beacon_int;\n};\n\n \nenum station_parameters_apply_mask {\n\tSTATION_PARAM_APPLY_UAPSD = BIT(0),\n\tSTATION_PARAM_APPLY_CAPABILITY = BIT(1),\n\tSTATION_PARAM_APPLY_PLINK_STATE = BIT(2),\n};\n\n \nstruct sta_txpwr {\n\ts16 power;\n\tenum nl80211_tx_power_setting type;\n};\n\n \nstruct link_station_parameters {\n\tconst u8 *mld_mac;\n\tint link_id;\n\tconst u8 *link_mac;\n\tconst u8 *supported_rates;\n\tu8 supported_rates_len;\n\tconst struct ieee80211_ht_cap *ht_capa;\n\tconst struct ieee80211_vht_cap *vht_capa;\n\tu8 opmode_notif;\n\tbool opmode_notif_used;\n\tconst struct ieee80211_he_cap_elem *he_capa;\n\tu8 he_capa_len;\n\tstruct sta_txpwr txpwr;\n\tbool txpwr_set;\n\tconst struct ieee80211_he_6ghz_capa *he_6ghz_capa;\n\tconst struct ieee80211_eht_cap_elem *eht_capa;\n\tu8 eht_capa_len;\n};\n\n \nstruct link_station_del_parameters {\n\tconst u8 *mld_mac;\n\tu32 link_id;\n};\n\n \nstruct station_parameters {\n\tstruct net_device *vlan;\n\tu32 sta_flags_mask, sta_flags_set;\n\tu32 sta_modify_mask;\n\tint listen_interval;\n\tu16 aid;\n\tu16 vlan_id;\n\tu16 peer_aid;\n\tu8 plink_action;\n\tu8 plink_state;\n\tu8 uapsd_queues;\n\tu8 max_sp;\n\tenum nl80211_mesh_power_mode local_pm;\n\tu16 capability;\n\tconst u8 *ext_capab;\n\tu8 ext_capab_len;\n\tconst u8 *supported_channels;\n\tu8 supported_channels_len;\n\tconst u8 *supported_oper_classes;\n\tu8 supported_oper_classes_len;\n\tint support_p2p_ps;\n\tu16 airtime_weight;\n\tstruct link_station_parameters link_sta_params;\n};\n\n \nstruct station_del_parameters {\n\tconst u8 *mac;\n\tu8 subtype;\n\tu16 reason_code;\n};\n\n \nenum cfg80211_station_type {\n\tCFG80211_STA_AP_CLIENT,\n\tCFG80211_STA_AP_CLIENT_UNASSOC,\n\tCFG80211_STA_AP_MLME_CLIENT,\n\tCFG80211_STA_AP_STA,\n\tCFG80211_STA_IBSS,\n\tCFG80211_STA_TDLS_PEER_SETUP,\n\tCFG80211_STA_TDLS_PEER_ACTIVE,\n\tCFG80211_STA_MESH_PEER_KERNEL,\n\tCFG80211_STA_MESH_PEER_USER,\n};\n\n \nint cfg80211_check_station_change(struct wiphy *wiphy,\n\t\t\t\t  struct station_parameters *params,\n\t\t\t\t  enum cfg80211_station_type statype);\n\n \nenum rate_info_flags {\n\tRATE_INFO_FLAGS_MCS\t\t\t= BIT(0),\n\tRATE_INFO_FLAGS_VHT_MCS\t\t\t= BIT(1),\n\tRATE_INFO_FLAGS_SHORT_GI\t\t= BIT(2),\n\tRATE_INFO_FLAGS_DMG\t\t\t= BIT(3),\n\tRATE_INFO_FLAGS_HE_MCS\t\t\t= BIT(4),\n\tRATE_INFO_FLAGS_EDMG\t\t\t= BIT(5),\n\tRATE_INFO_FLAGS_EXTENDED_SC_DMG\t\t= BIT(6),\n\tRATE_INFO_FLAGS_EHT_MCS\t\t\t= BIT(7),\n\tRATE_INFO_FLAGS_S1G_MCS\t\t\t= BIT(8),\n};\n\n \nenum rate_info_bw {\n\tRATE_INFO_BW_20 = 0,\n\tRATE_INFO_BW_5,\n\tRATE_INFO_BW_10,\n\tRATE_INFO_BW_40,\n\tRATE_INFO_BW_80,\n\tRATE_INFO_BW_160,\n\tRATE_INFO_BW_HE_RU,\n\tRATE_INFO_BW_320,\n\tRATE_INFO_BW_EHT_RU,\n\tRATE_INFO_BW_1,\n\tRATE_INFO_BW_2,\n\tRATE_INFO_BW_4,\n\tRATE_INFO_BW_8,\n\tRATE_INFO_BW_16,\n};\n\n \nstruct rate_info {\n\tu16 flags;\n\tu16 legacy;\n\tu8 mcs;\n\tu8 nss;\n\tu8 bw;\n\tu8 he_gi;\n\tu8 he_dcm;\n\tu8 he_ru_alloc;\n\tu8 n_bonded_ch;\n\tu8 eht_gi;\n\tu8 eht_ru_alloc;\n};\n\n \nenum bss_param_flags {\n\tBSS_PARAM_FLAGS_CTS_PROT\t= 1<<0,\n\tBSS_PARAM_FLAGS_SHORT_PREAMBLE\t= 1<<1,\n\tBSS_PARAM_FLAGS_SHORT_SLOT_TIME\t= 1<<2,\n};\n\n \nstruct sta_bss_parameters {\n\tu8 flags;\n\tu8 dtim_period;\n\tu16 beacon_interval;\n};\n\n \nstruct cfg80211_txq_stats {\n\tu32 filled;\n\tu32 backlog_bytes;\n\tu32 backlog_packets;\n\tu32 flows;\n\tu32 drops;\n\tu32 ecn_marks;\n\tu32 overlimit;\n\tu32 overmemory;\n\tu32 collisions;\n\tu32 tx_bytes;\n\tu32 tx_packets;\n\tu32 max_flows;\n};\n\n \nstruct cfg80211_tid_stats {\n\tu32 filled;\n\tu64 rx_msdu;\n\tu64 tx_msdu;\n\tu64 tx_msdu_retries;\n\tu64 tx_msdu_failed;\n\tstruct cfg80211_txq_stats txq_stats;\n};\n\n#define IEEE80211_MAX_CHAINS\t4\n\n \nstruct station_info {\n\tu64 filled;\n\tu32 connected_time;\n\tu32 inactive_time;\n\tu64 assoc_at;\n\tu64 rx_bytes;\n\tu64 tx_bytes;\n\tu16 llid;\n\tu16 plid;\n\tu8 plink_state;\n\ts8 signal;\n\ts8 signal_avg;\n\n\tu8 chains;\n\ts8 chain_signal[IEEE80211_MAX_CHAINS];\n\ts8 chain_signal_avg[IEEE80211_MAX_CHAINS];\n\n\tstruct rate_info txrate;\n\tstruct rate_info rxrate;\n\tu32 rx_packets;\n\tu32 tx_packets;\n\tu32 tx_retries;\n\tu32 tx_failed;\n\tu32 rx_dropped_misc;\n\tstruct sta_bss_parameters bss_param;\n\tstruct nl80211_sta_flag_update sta_flags;\n\n\tint generation;\n\n\tconst u8 *assoc_req_ies;\n\tsize_t assoc_req_ies_len;\n\n\tu32 beacon_loss_count;\n\ts64 t_offset;\n\tenum nl80211_mesh_power_mode local_pm;\n\tenum nl80211_mesh_power_mode peer_pm;\n\tenum nl80211_mesh_power_mode nonpeer_pm;\n\n\tu32 expected_throughput;\n\n\tu64 tx_duration;\n\tu64 rx_duration;\n\tu64 rx_beacon;\n\tu8 rx_beacon_signal_avg;\n\tu8 connected_to_gate;\n\n\tstruct cfg80211_tid_stats *pertid;\n\ts8 ack_signal;\n\ts8 avg_ack_signal;\n\n\tu16 airtime_weight;\n\n\tu32 rx_mpdu_count;\n\tu32 fcs_err_count;\n\n\tu32 airtime_link_metric;\n\n\tu8 connected_to_as;\n\n\tbool mlo_params_valid;\n\tu8 assoc_link_id;\n\tu8 mld_addr[ETH_ALEN] __aligned(2);\n\tconst u8 *assoc_resp_ies;\n\tsize_t assoc_resp_ies_len;\n};\n\n \nstruct cfg80211_sar_sub_specs {\n\ts32 power;\n\tu32 freq_range_index;\n};\n\n \nstruct cfg80211_sar_specs {\n\tenum nl80211_sar_type type;\n\tu32 num_sub_specs;\n\tstruct cfg80211_sar_sub_specs sub_specs[];\n};\n\n\n \nstruct cfg80211_sar_freq_ranges {\n\tu32 start_freq;\n\tu32 end_freq;\n};\n\n \nstruct cfg80211_sar_capa {\n\tenum nl80211_sar_type type;\n\tu32 num_freq_ranges;\n\tconst struct cfg80211_sar_freq_ranges *freq_ranges;\n};\n\n#if IS_ENABLED(CONFIG_CFG80211)\n \nint cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,\n\t\t\t struct station_info *sinfo);\n#else\nstatic inline int cfg80211_get_station(struct net_device *dev,\n\t\t\t\t       const u8 *mac_addr,\n\t\t\t\t       struct station_info *sinfo)\n{\n\treturn -ENOENT;\n}\n#endif\n\n \nenum monitor_flags {\n\tMONITOR_FLAG_CHANGED\t\t= 1<<__NL80211_MNTR_FLAG_INVALID,\n\tMONITOR_FLAG_FCSFAIL\t\t= 1<<NL80211_MNTR_FLAG_FCSFAIL,\n\tMONITOR_FLAG_PLCPFAIL\t\t= 1<<NL80211_MNTR_FLAG_PLCPFAIL,\n\tMONITOR_FLAG_CONTROL\t\t= 1<<NL80211_MNTR_FLAG_CONTROL,\n\tMONITOR_FLAG_OTHER_BSS\t\t= 1<<NL80211_MNTR_FLAG_OTHER_BSS,\n\tMONITOR_FLAG_COOK_FRAMES\t= 1<<NL80211_MNTR_FLAG_COOK_FRAMES,\n\tMONITOR_FLAG_ACTIVE\t\t= 1<<NL80211_MNTR_FLAG_ACTIVE,\n};\n\n \nenum mpath_info_flags {\n\tMPATH_INFO_FRAME_QLEN\t\t= BIT(0),\n\tMPATH_INFO_SN\t\t\t= BIT(1),\n\tMPATH_INFO_METRIC\t\t= BIT(2),\n\tMPATH_INFO_EXPTIME\t\t= BIT(3),\n\tMPATH_INFO_DISCOVERY_TIMEOUT\t= BIT(4),\n\tMPATH_INFO_DISCOVERY_RETRIES\t= BIT(5),\n\tMPATH_INFO_FLAGS\t\t= BIT(6),\n\tMPATH_INFO_HOP_COUNT\t\t= BIT(7),\n\tMPATH_INFO_PATH_CHANGE\t\t= BIT(8),\n};\n\n \nstruct mpath_info {\n\tu32 filled;\n\tu32 frame_qlen;\n\tu32 sn;\n\tu32 metric;\n\tu32 exptime;\n\tu32 discovery_timeout;\n\tu8 discovery_retries;\n\tu8 flags;\n\tu8 hop_count;\n\tu32 path_change_count;\n\n\tint generation;\n};\n\n \nstruct bss_parameters {\n\tint link_id;\n\tint use_cts_prot;\n\tint use_short_preamble;\n\tint use_short_slot_time;\n\tconst u8 *basic_rates;\n\tu8 basic_rates_len;\n\tint ap_isolate;\n\tint ht_opmode;\n\ts8 p2p_ctwindow, p2p_opp_ps;\n};\n\n \nstruct mesh_config {\n\tu16 dot11MeshRetryTimeout;\n\tu16 dot11MeshConfirmTimeout;\n\tu16 dot11MeshHoldingTimeout;\n\tu16 dot11MeshMaxPeerLinks;\n\tu8 dot11MeshMaxRetries;\n\tu8 dot11MeshTTL;\n\tu8 element_ttl;\n\tbool auto_open_plinks;\n\tu32 dot11MeshNbrOffsetMaxNeighbor;\n\tu8 dot11MeshHWMPmaxPREQretries;\n\tu32 path_refresh_time;\n\tu16 min_discovery_timeout;\n\tu32 dot11MeshHWMPactivePathTimeout;\n\tu16 dot11MeshHWMPpreqMinInterval;\n\tu16 dot11MeshHWMPperrMinInterval;\n\tu16 dot11MeshHWMPnetDiameterTraversalTime;\n\tu8 dot11MeshHWMPRootMode;\n\tbool dot11MeshConnectedToMeshGate;\n\tbool dot11MeshConnectedToAuthServer;\n\tu16 dot11MeshHWMPRannInterval;\n\tbool dot11MeshGateAnnouncementProtocol;\n\tbool dot11MeshForwarding;\n\ts32 rssi_threshold;\n\tu16 ht_opmode;\n\tu32 dot11MeshHWMPactivePathToRootTimeout;\n\tu16 dot11MeshHWMProotInterval;\n\tu16 dot11MeshHWMPconfirmationInterval;\n\tenum nl80211_mesh_power_mode power_mode;\n\tu16 dot11MeshAwakeWindowDuration;\n\tu32 plink_timeout;\n\tbool dot11MeshNolearn;\n};\n\n \nstruct mesh_setup {\n\tstruct cfg80211_chan_def chandef;\n\tconst u8 *mesh_id;\n\tu8 mesh_id_len;\n\tu8 sync_method;\n\tu8 path_sel_proto;\n\tu8 path_metric;\n\tu8 auth_id;\n\tconst u8 *ie;\n\tu8 ie_len;\n\tbool is_authenticated;\n\tbool is_secure;\n\tbool user_mpm;\n\tu8 dtim_period;\n\tu16 beacon_interval;\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tu32 basic_rates;\n\tstruct cfg80211_bitrate_mask beacon_rate;\n\tbool userspace_handles_dfs;\n\tbool control_port_over_nl80211;\n};\n\n \nstruct ocb_setup {\n\tstruct cfg80211_chan_def chandef;\n};\n\n \nstruct ieee80211_txq_params {\n\tenum nl80211_ac ac;\n\tu16 txop;\n\tu16 cwmin;\n\tu16 cwmax;\n\tu8 aifs;\n\tint link_id;\n};\n\n \n\n \nstruct cfg80211_ssid {\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tu8 ssid_len;\n};\n\n \nstruct cfg80211_scan_info {\n\tu64 scan_start_tsf;\n\tu8 tsf_bssid[ETH_ALEN] __aligned(2);\n\tbool aborted;\n};\n\n \nstruct cfg80211_scan_6ghz_params {\n\tu32 short_ssid;\n\tu32 channel_idx;\n\tu8 bssid[ETH_ALEN];\n\tbool unsolicited_probe;\n\tbool short_ssid_valid;\n\tbool psc_no_listen;\n\ts8 psd_20;\n};\n\n \nstruct cfg80211_scan_request {\n\tstruct cfg80211_ssid *ssids;\n\tint n_ssids;\n\tu32 n_channels;\n\tenum nl80211_bss_scan_width scan_width;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tu16 duration;\n\tbool duration_mandatory;\n\tu32 flags;\n\n\tu32 rates[NUM_NL80211_BANDS];\n\n\tstruct wireless_dev *wdev;\n\n\tu8 mac_addr[ETH_ALEN] __aligned(2);\n\tu8 mac_addr_mask[ETH_ALEN] __aligned(2);\n\tu8 bssid[ETH_ALEN] __aligned(2);\n\n\t \n\tstruct wiphy *wiphy;\n\tunsigned long scan_start;\n\tstruct cfg80211_scan_info info;\n\tbool notified;\n\tbool no_cck;\n\tbool scan_6ghz;\n\tu32 n_6ghz_params;\n\tstruct cfg80211_scan_6ghz_params *scan_6ghz_params;\n\n\t \n\tstruct ieee80211_channel *channels[] __counted_by(n_channels);\n};\n\nstatic inline void get_random_mask_addr(u8 *buf, const u8 *addr, const u8 *mask)\n{\n\tint i;\n\n\tget_random_bytes(buf, ETH_ALEN);\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tbuf[i] &= ~mask[i];\n\t\tbuf[i] |= addr[i] & mask[i];\n\t}\n}\n\n \nstruct cfg80211_match_set {\n\tstruct cfg80211_ssid ssid;\n\tu8 bssid[ETH_ALEN];\n\ts32 rssi_thold;\n\ts32 per_band_rssi_thold[NUM_NL80211_BANDS];\n};\n\n \nstruct cfg80211_sched_scan_plan {\n\tu32 interval;\n\tu32 iterations;\n};\n\n \nstruct cfg80211_bss_select_adjust {\n\tenum nl80211_band band;\n\ts8 delta;\n};\n\n \nstruct cfg80211_sched_scan_request {\n\tu64 reqid;\n\tstruct cfg80211_ssid *ssids;\n\tint n_ssids;\n\tu32 n_channels;\n\tenum nl80211_bss_scan_width scan_width;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tu32 flags;\n\tstruct cfg80211_match_set *match_sets;\n\tint n_match_sets;\n\ts32 min_rssi_thold;\n\tu32 delay;\n\tstruct cfg80211_sched_scan_plan *scan_plans;\n\tint n_scan_plans;\n\n\tu8 mac_addr[ETH_ALEN] __aligned(2);\n\tu8 mac_addr_mask[ETH_ALEN] __aligned(2);\n\n\tbool relative_rssi_set;\n\ts8 relative_rssi;\n\tstruct cfg80211_bss_select_adjust rssi_adjust;\n\n\t \n\tstruct wiphy *wiphy;\n\tstruct net_device *dev;\n\tunsigned long scan_start;\n\tbool report_results;\n\tstruct rcu_head rcu_head;\n\tu32 owner_nlportid;\n\tbool nl_owner_dead;\n\tstruct list_head list;\n\n\t \n\tstruct ieee80211_channel *channels[];\n};\n\n \nenum cfg80211_signal_type {\n\tCFG80211_SIGNAL_TYPE_NONE,\n\tCFG80211_SIGNAL_TYPE_MBM,\n\tCFG80211_SIGNAL_TYPE_UNSPEC,\n};\n\n \nstruct cfg80211_inform_bss {\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_bss_scan_width scan_width;\n\ts32 signal;\n\tu64 boottime_ns;\n\tu64 parent_tsf;\n\tu8 parent_bssid[ETH_ALEN] __aligned(2);\n\tu8 chains;\n\ts8 chain_signal[IEEE80211_MAX_CHAINS];\n\n\tvoid *drv_data;\n};\n\n \nstruct cfg80211_bss_ies {\n\tu64 tsf;\n\tstruct rcu_head rcu_head;\n\tint len;\n\tbool from_beacon;\n\tu8 data[];\n};\n\n \nstruct cfg80211_bss {\n\tstruct ieee80211_channel *channel;\n\tenum nl80211_bss_scan_width scan_width;\n\n\tconst struct cfg80211_bss_ies __rcu *ies;\n\tconst struct cfg80211_bss_ies __rcu *beacon_ies;\n\tconst struct cfg80211_bss_ies __rcu *proberesp_ies;\n\n\tstruct cfg80211_bss *hidden_beacon_bss;\n\tstruct cfg80211_bss *transmitted_bss;\n\tstruct list_head nontrans_list;\n\n\ts32 signal;\n\n\tu16 beacon_interval;\n\tu16 capability;\n\n\tu8 bssid[ETH_ALEN];\n\tu8 chains;\n\ts8 chain_signal[IEEE80211_MAX_CHAINS];\n\n\tu8 bssid_index;\n\tu8 max_bssid_indicator;\n\n\tu8 priv[] __aligned(sizeof(void *));\n};\n\n \nconst struct element *ieee80211_bss_get_elem(struct cfg80211_bss *bss, u8 id);\n\n \nstatic inline const u8 *ieee80211_bss_get_ie(struct cfg80211_bss *bss, u8 id)\n{\n\treturn (const void *)ieee80211_bss_get_elem(bss, id);\n}\n\n\n \nstruct cfg80211_auth_request {\n\tstruct cfg80211_bss *bss;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tenum nl80211_auth_type auth_type;\n\tconst u8 *key;\n\tu8 key_len;\n\ts8 key_idx;\n\tconst u8 *auth_data;\n\tsize_t auth_data_len;\n\ts8 link_id;\n\tconst u8 *ap_mld_addr;\n};\n\n \nstruct cfg80211_assoc_link {\n\tstruct cfg80211_bss *bss;\n\tconst u8 *elems;\n\tsize_t elems_len;\n\tbool disabled;\n};\n\n \nenum cfg80211_assoc_req_flags {\n\tASSOC_REQ_DISABLE_HT\t\t\t= BIT(0),\n\tASSOC_REQ_DISABLE_VHT\t\t\t= BIT(1),\n\tASSOC_REQ_USE_RRM\t\t\t= BIT(2),\n\tCONNECT_REQ_EXTERNAL_AUTH_SUPPORT\t= BIT(3),\n\tASSOC_REQ_DISABLE_HE\t\t\t= BIT(4),\n\tASSOC_REQ_DISABLE_EHT\t\t\t= BIT(5),\n\tCONNECT_REQ_MLO_SUPPORT\t\t\t= BIT(6),\n};\n\n \nstruct cfg80211_assoc_request {\n\tstruct cfg80211_bss *bss;\n\tconst u8 *ie, *prev_bssid;\n\tsize_t ie_len;\n\tstruct cfg80211_crypto_settings crypto;\n\tbool use_mfp;\n\tu32 flags;\n\tstruct ieee80211_ht_cap ht_capa;\n\tstruct ieee80211_ht_cap ht_capa_mask;\n\tstruct ieee80211_vht_cap vht_capa, vht_capa_mask;\n\tconst u8 *fils_kek;\n\tsize_t fils_kek_len;\n\tconst u8 *fils_nonces;\n\tstruct ieee80211_s1g_cap s1g_capa, s1g_capa_mask;\n\tstruct cfg80211_assoc_link links[IEEE80211_MLD_MAX_NUM_LINKS];\n\tconst u8 *ap_mld_addr;\n\ts8 link_id;\n};\n\n \nstruct cfg80211_deauth_request {\n\tconst u8 *bssid;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tu16 reason_code;\n\tbool local_state_change;\n};\n\n \nstruct cfg80211_disassoc_request {\n\tconst u8 *ap_addr;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tu16 reason_code;\n\tbool local_state_change;\n};\n\n \nstruct cfg80211_ibss_params {\n\tconst u8 *ssid;\n\tconst u8 *bssid;\n\tstruct cfg80211_chan_def chandef;\n\tconst u8 *ie;\n\tu8 ssid_len, ie_len;\n\tu16 beacon_interval;\n\tu32 basic_rates;\n\tbool channel_fixed;\n\tbool privacy;\n\tbool control_port;\n\tbool control_port_over_nl80211;\n\tbool userspace_handles_dfs;\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tstruct ieee80211_ht_cap ht_capa;\n\tstruct ieee80211_ht_cap ht_capa_mask;\n\tstruct key_params *wep_keys;\n\tint wep_tx_key;\n};\n\n \nstruct cfg80211_bss_selection {\n\tenum nl80211_bss_select_attr behaviour;\n\tunion {\n\t\tenum nl80211_band band_pref;\n\t\tstruct cfg80211_bss_select_adjust adjust;\n\t} param;\n};\n\n \nstruct cfg80211_connect_params {\n\tstruct ieee80211_channel *channel;\n\tstruct ieee80211_channel *channel_hint;\n\tconst u8 *bssid;\n\tconst u8 *bssid_hint;\n\tconst u8 *ssid;\n\tsize_t ssid_len;\n\tenum nl80211_auth_type auth_type;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tbool privacy;\n\tenum nl80211_mfp mfp;\n\tstruct cfg80211_crypto_settings crypto;\n\tconst u8 *key;\n\tu8 key_len, key_idx;\n\tu32 flags;\n\tint bg_scan_period;\n\tstruct ieee80211_ht_cap ht_capa;\n\tstruct ieee80211_ht_cap ht_capa_mask;\n\tstruct ieee80211_vht_cap vht_capa;\n\tstruct ieee80211_vht_cap vht_capa_mask;\n\tbool pbss;\n\tstruct cfg80211_bss_selection bss_select;\n\tconst u8 *prev_bssid;\n\tconst u8 *fils_erp_username;\n\tsize_t fils_erp_username_len;\n\tconst u8 *fils_erp_realm;\n\tsize_t fils_erp_realm_len;\n\tu16 fils_erp_next_seq_num;\n\tconst u8 *fils_erp_rrk;\n\tsize_t fils_erp_rrk_len;\n\tbool want_1x;\n\tstruct ieee80211_edmg edmg;\n};\n\n \nenum cfg80211_connect_params_changed {\n\tUPDATE_ASSOC_IES\t\t= BIT(0),\n\tUPDATE_FILS_ERP_INFO\t\t= BIT(1),\n\tUPDATE_AUTH_TYPE\t\t= BIT(2),\n};\n\n \nenum wiphy_params_flags {\n\tWIPHY_PARAM_RETRY_SHORT\t\t= 1 << 0,\n\tWIPHY_PARAM_RETRY_LONG\t\t= 1 << 1,\n\tWIPHY_PARAM_FRAG_THRESHOLD\t= 1 << 2,\n\tWIPHY_PARAM_RTS_THRESHOLD\t= 1 << 3,\n\tWIPHY_PARAM_COVERAGE_CLASS\t= 1 << 4,\n\tWIPHY_PARAM_DYN_ACK\t\t= 1 << 5,\n\tWIPHY_PARAM_TXQ_LIMIT\t\t= 1 << 6,\n\tWIPHY_PARAM_TXQ_MEMORY_LIMIT\t= 1 << 7,\n\tWIPHY_PARAM_TXQ_QUANTUM\t\t= 1 << 8,\n};\n\n#define IEEE80211_DEFAULT_AIRTIME_WEIGHT\t256\n\n \n#define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L\t5000\n#define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H\t12000\n\n \n#define IEEE80211_AQL_THRESHOLD\t\t\t24000\n\n \nstruct cfg80211_pmksa {\n\tconst u8 *bssid;\n\tconst u8 *pmkid;\n\tconst u8 *pmk;\n\tsize_t pmk_len;\n\tconst u8 *ssid;\n\tsize_t ssid_len;\n\tconst u8 *cache_id;\n\tu32 pmk_lifetime;\n\tu8 pmk_reauth_threshold;\n};\n\n \nstruct cfg80211_pkt_pattern {\n\tconst u8 *mask, *pattern;\n\tint pattern_len;\n\tint pkt_offset;\n};\n\n \nstruct cfg80211_wowlan_tcp {\n\tstruct socket *sock;\n\t__be32 src, dst;\n\tu16 src_port, dst_port;\n\tu8 dst_mac[ETH_ALEN];\n\tint payload_len;\n\tconst u8 *payload;\n\tstruct nl80211_wowlan_tcp_data_seq payload_seq;\n\tu32 data_interval;\n\tu32 wake_len;\n\tconst u8 *wake_data, *wake_mask;\n\tu32 tokens_size;\n\t \n\tstruct nl80211_wowlan_tcp_data_token payload_tok;\n};\n\n \nstruct cfg80211_wowlan {\n\tbool any, disconnect, magic_pkt, gtk_rekey_failure,\n\t     eap_identity_req, four_way_handshake,\n\t     rfkill_release;\n\tstruct cfg80211_pkt_pattern *patterns;\n\tstruct cfg80211_wowlan_tcp *tcp;\n\tint n_patterns;\n\tstruct cfg80211_sched_scan_request *nd_config;\n};\n\n \nstruct cfg80211_coalesce_rules {\n\tint delay;\n\tenum nl80211_coalesce_condition condition;\n\tstruct cfg80211_pkt_pattern *patterns;\n\tint n_patterns;\n};\n\n \nstruct cfg80211_coalesce {\n\tstruct cfg80211_coalesce_rules *rules;\n\tint n_rules;\n};\n\n \nstruct cfg80211_wowlan_nd_match {\n\tstruct cfg80211_ssid ssid;\n\tint n_channels;\n\tu32 channels[];\n};\n\n \nstruct cfg80211_wowlan_nd_info {\n\tint n_matches;\n\tstruct cfg80211_wowlan_nd_match *matches[];\n};\n\n \nstruct cfg80211_wowlan_wakeup {\n\tbool disconnect, magic_pkt, gtk_rekey_failure,\n\t     eap_identity_req, four_way_handshake,\n\t     rfkill_release, packet_80211,\n\t     tcp_match, tcp_connlost, tcp_nomoretokens;\n\ts32 pattern_idx;\n\tu32 packet_present_len, packet_len;\n\tconst void *packet;\n\tstruct cfg80211_wowlan_nd_info *net_detect;\n};\n\n \nstruct cfg80211_gtk_rekey_data {\n\tconst u8 *kek, *kck, *replay_ctr;\n\tu32 akm;\n\tu8 kek_len, kck_len;\n};\n\n \nstruct cfg80211_update_ft_ies_params {\n\tu16 md;\n\tconst u8 *ie;\n\tsize_t ie_len;\n};\n\n \nstruct cfg80211_mgmt_tx_params {\n\tstruct ieee80211_channel *chan;\n\tbool offchan;\n\tunsigned int wait;\n\tconst u8 *buf;\n\tsize_t len;\n\tbool no_cck;\n\tbool dont_wait_for_ack;\n\tint n_csa_offsets;\n\tconst u16 *csa_offsets;\n\tint link_id;\n};\n\n \nstruct cfg80211_dscp_exception {\n\tu8 dscp;\n\tu8 up;\n};\n\n \nstruct cfg80211_dscp_range {\n\tu8 low;\n\tu8 high;\n};\n\n \n#define IEEE80211_QOS_MAP_MAX_EX\t21\n#define IEEE80211_QOS_MAP_LEN_MIN\t16\n#define IEEE80211_QOS_MAP_LEN_MAX \\\n\t(IEEE80211_QOS_MAP_LEN_MIN + 2 * IEEE80211_QOS_MAP_MAX_EX)\n\n \nstruct cfg80211_qos_map {\n\tu8 num_des;\n\tstruct cfg80211_dscp_exception dscp_exception[IEEE80211_QOS_MAP_MAX_EX];\n\tstruct cfg80211_dscp_range up[8];\n};\n\n \nstruct cfg80211_nan_conf {\n\tu8 master_pref;\n\tu8 bands;\n};\n\n \nenum cfg80211_nan_conf_changes {\n\tCFG80211_NAN_CONF_CHANGED_PREF = BIT(0),\n\tCFG80211_NAN_CONF_CHANGED_BANDS = BIT(1),\n};\n\n \nstruct cfg80211_nan_func_filter {\n\tconst u8 *filter;\n\tu8 len;\n};\n\n \nstruct cfg80211_nan_func {\n\tenum nl80211_nan_function_type type;\n\tu8 service_id[NL80211_NAN_FUNC_SERVICE_ID_LEN];\n\tu8 publish_type;\n\tbool close_range;\n\tbool publish_bcast;\n\tbool subscribe_active;\n\tu8 followup_id;\n\tu8 followup_reqid;\n\tstruct mac_address followup_dest;\n\tu32 ttl;\n\tconst u8 *serv_spec_info;\n\tu8 serv_spec_info_len;\n\tbool srf_include;\n\tconst u8 *srf_bf;\n\tu8 srf_bf_len;\n\tu8 srf_bf_idx;\n\tstruct mac_address *srf_macs;\n\tint srf_num_macs;\n\tstruct cfg80211_nan_func_filter *rx_filters;\n\tstruct cfg80211_nan_func_filter *tx_filters;\n\tu8 num_tx_filters;\n\tu8 num_rx_filters;\n\tu8 instance_id;\n\tu64 cookie;\n};\n\n \nstruct cfg80211_pmk_conf {\n\tconst u8 *aa;\n\tu8 pmk_len;\n\tconst u8 *pmk;\n\tconst u8 *pmk_r0_name;\n};\n\n \nstruct cfg80211_external_auth_params {\n\tenum nl80211_external_auth_action action;\n\tu8 bssid[ETH_ALEN] __aligned(2);\n\tstruct cfg80211_ssid ssid;\n\tunsigned int key_mgmt_suite;\n\tu16 status;\n\tconst u8 *pmkid;\n\tu8 mld_addr[ETH_ALEN] __aligned(2);\n};\n\n \nstruct cfg80211_ftm_responder_stats {\n\tu32 filled;\n\tu32 success_num;\n\tu32 partial_num;\n\tu32 failed_num;\n\tu32 asap_num;\n\tu32 non_asap_num;\n\tu64 total_duration_ms;\n\tu32 unknown_triggers_num;\n\tu32 reschedule_requests_num;\n\tu32 out_of_window_triggers_num;\n};\n\n \nstruct cfg80211_pmsr_ftm_result {\n\tconst u8 *lci;\n\tconst u8 *civicloc;\n\tunsigned int lci_len;\n\tunsigned int civicloc_len;\n\tenum nl80211_peer_measurement_ftm_failure_reasons failure_reason;\n\tu32 num_ftmr_attempts, num_ftmr_successes;\n\ts16 burst_index;\n\tu8 busy_retry_time;\n\tu8 num_bursts_exp;\n\tu8 burst_duration;\n\tu8 ftms_per_burst;\n\ts32 rssi_avg;\n\ts32 rssi_spread;\n\tstruct rate_info tx_rate, rx_rate;\n\ts64 rtt_avg;\n\ts64 rtt_variance;\n\ts64 rtt_spread;\n\ts64 dist_avg;\n\ts64 dist_variance;\n\ts64 dist_spread;\n\n\tu16 num_ftmr_attempts_valid:1,\n\t    num_ftmr_successes_valid:1,\n\t    rssi_avg_valid:1,\n\t    rssi_spread_valid:1,\n\t    tx_rate_valid:1,\n\t    rx_rate_valid:1,\n\t    rtt_avg_valid:1,\n\t    rtt_variance_valid:1,\n\t    rtt_spread_valid:1,\n\t    dist_avg_valid:1,\n\t    dist_variance_valid:1,\n\t    dist_spread_valid:1;\n};\n\n \nstruct cfg80211_pmsr_result {\n\tu64 host_time, ap_tsf;\n\tenum nl80211_peer_measurement_status status;\n\n\tu8 addr[ETH_ALEN];\n\n\tu8 final:1,\n\t   ap_tsf_valid:1;\n\n\tenum nl80211_peer_measurement_type type;\n\n\tunion {\n\t\tstruct cfg80211_pmsr_ftm_result ftm;\n\t};\n};\n\n \nstruct cfg80211_pmsr_ftm_request_peer {\n\tenum nl80211_preamble preamble;\n\tu16 burst_period;\n\tu8 requested:1,\n\t   asap:1,\n\t   request_lci:1,\n\t   request_civicloc:1,\n\t   trigger_based:1,\n\t   non_trigger_based:1,\n\t   lmr_feedback:1;\n\tu8 num_bursts_exp;\n\tu8 burst_duration;\n\tu8 ftms_per_burst;\n\tu8 ftmr_retries;\n\tu8 bss_color;\n};\n\n \nstruct cfg80211_pmsr_request_peer {\n\tu8 addr[ETH_ALEN];\n\tstruct cfg80211_chan_def chandef;\n\tu8 report_ap_tsf:1;\n\tstruct cfg80211_pmsr_ftm_request_peer ftm;\n};\n\n \nstruct cfg80211_pmsr_request {\n\tu64 cookie;\n\tvoid *drv_data;\n\tu32 n_peers;\n\tu32 nl_portid;\n\n\tu32 timeout;\n\n\tu8 mac_addr[ETH_ALEN] __aligned(2);\n\tu8 mac_addr_mask[ETH_ALEN] __aligned(2);\n\n\tstruct list_head list;\n\n\tstruct cfg80211_pmsr_request_peer peers[] __counted_by(n_peers);\n};\n\n \nstruct cfg80211_update_owe_info {\n\tu8 peer[ETH_ALEN] __aligned(2);\n\tu16 status;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tint assoc_link_id;\n\tu8 peer_mld_addr[ETH_ALEN] __aligned(2);\n};\n\n \nstruct mgmt_frame_regs {\n\tu32 global_stypes, interface_stypes;\n\tu32 global_mcast_stypes, interface_mcast_stypes;\n};\n\n \nstruct cfg80211_ops {\n\tint\t(*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);\n\tint\t(*resume)(struct wiphy *wiphy);\n\tvoid\t(*set_wakeup)(struct wiphy *wiphy, bool enabled);\n\n\tstruct wireless_dev * (*add_virtual_intf)(struct wiphy *wiphy,\n\t\t\t\t\t\t  const char *name,\n\t\t\t\t\t\t  unsigned char name_assign_type,\n\t\t\t\t\t\t  enum nl80211_iftype type,\n\t\t\t\t\t\t  struct vif_params *params);\n\tint\t(*del_virtual_intf)(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev);\n\tint\t(*change_virtual_intf)(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       enum nl80211_iftype type,\n\t\t\t\t       struct vif_params *params);\n\n\tint\t(*add_intf_link)(struct wiphy *wiphy,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t unsigned int link_id);\n\tvoid\t(*del_intf_link)(struct wiphy *wiphy,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t unsigned int link_id);\n\n\tint\t(*add_key)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   int link_id, u8 key_index, bool pairwise,\n\t\t\t   const u8 *mac_addr, struct key_params *params);\n\tint\t(*get_key)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   int link_id, u8 key_index, bool pairwise,\n\t\t\t   const u8 *mac_addr, void *cookie,\n\t\t\t   void (*callback)(void *cookie, struct key_params*));\n\tint\t(*del_key)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   int link_id, u8 key_index, bool pairwise,\n\t\t\t   const u8 *mac_addr);\n\tint\t(*set_default_key)(struct wiphy *wiphy,\n\t\t\t\t   struct net_device *netdev, int link_id,\n\t\t\t\t   u8 key_index, bool unicast, bool multicast);\n\tint\t(*set_default_mgmt_key)(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *netdev, int link_id,\n\t\t\t\t\tu8 key_index);\n\tint\t(*set_default_beacon_key)(struct wiphy *wiphy,\n\t\t\t\t\t  struct net_device *netdev,\n\t\t\t\t\t  int link_id,\n\t\t\t\t\t  u8 key_index);\n\n\tint\t(*start_ap)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t    struct cfg80211_ap_settings *settings);\n\tint\t(*change_beacon)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t struct cfg80211_beacon_data *info);\n\tint\t(*stop_ap)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   unsigned int link_id);\n\n\n\tint\t(*add_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const u8 *mac,\n\t\t\t       struct station_parameters *params);\n\tint\t(*del_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       struct station_del_parameters *params);\n\tint\t(*change_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *mac,\n\t\t\t\t  struct station_parameters *params);\n\tint\t(*get_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const u8 *mac, struct station_info *sinfo);\n\tint\t(*dump_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tint idx, u8 *mac, struct station_info *sinfo);\n\n\tint\t(*add_mpath)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const u8 *dst, const u8 *next_hop);\n\tint\t(*del_mpath)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const u8 *dst);\n\tint\t(*change_mpath)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *dst, const u8 *next_hop);\n\tint\t(*get_mpath)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     u8 *dst, u8 *next_hop, struct mpath_info *pinfo);\n\tint\t(*dump_mpath)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      int idx, u8 *dst, u8 *next_hop,\n\t\t\t      struct mpath_info *pinfo);\n\tint\t(*get_mpp)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   u8 *dst, u8 *mpp, struct mpath_info *pinfo);\n\tint\t(*dump_mpp)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t    int idx, u8 *dst, u8 *mpp,\n\t\t\t    struct mpath_info *pinfo);\n\tint\t(*get_mesh_config)(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tstruct mesh_config *conf);\n\tint\t(*update_mesh_config)(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev, u32 mask,\n\t\t\t\t      const struct mesh_config *nconf);\n\tint\t(*join_mesh)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     const struct mesh_config *conf,\n\t\t\t     const struct mesh_setup *setup);\n\tint\t(*leave_mesh)(struct wiphy *wiphy, struct net_device *dev);\n\n\tint\t(*join_ocb)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t    struct ocb_setup *setup);\n\tint\t(*leave_ocb)(struct wiphy *wiphy, struct net_device *dev);\n\n\tint\t(*change_bss)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      struct bss_parameters *params);\n\n\tvoid\t(*inform_bss)(struct wiphy *wiphy, struct cfg80211_bss *bss,\n\t\t\t      const struct cfg80211_bss_ies *ies, void *data);\n\n\tint\t(*set_txq_params)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  struct ieee80211_txq_params *params);\n\n\tint\t(*libertas_set_mesh_channel)(struct wiphy *wiphy,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     struct ieee80211_channel *chan);\n\n\tint\t(*set_monitor_channel)(struct wiphy *wiphy,\n\t\t\t\t       struct cfg80211_chan_def *chandef);\n\n\tint\t(*scan)(struct wiphy *wiphy,\n\t\t\tstruct cfg80211_scan_request *request);\n\tvoid\t(*abort_scan)(struct wiphy *wiphy, struct wireless_dev *wdev);\n\n\tint\t(*auth)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tstruct cfg80211_auth_request *req);\n\tint\t(*assoc)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t struct cfg80211_assoc_request *req);\n\tint\t(*deauth)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  struct cfg80211_deauth_request *req);\n\tint\t(*disassoc)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t    struct cfg80211_disassoc_request *req);\n\n\tint\t(*connect)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct cfg80211_connect_params *sme);\n\tint\t(*update_connect_params)(struct wiphy *wiphy,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t struct cfg80211_connect_params *sme,\n\t\t\t\t\t u32 changed);\n\tint\t(*disconnect)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      u16 reason_code);\n\n\tint\t(*join_ibss)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     struct cfg80211_ibss_params *params);\n\tint\t(*leave_ibss)(struct wiphy *wiphy, struct net_device *dev);\n\n\tint\t(*set_mcast_rate)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  int rate[NUM_NL80211_BANDS]);\n\n\tint\t(*set_wiphy_params)(struct wiphy *wiphy, u32 changed);\n\n\tint\t(*set_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tenum nl80211_tx_power_setting type, int mbm);\n\tint\t(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tint *dbm);\n\n\tvoid\t(*rfkill_poll)(struct wiphy *wiphy);\n\n#ifdef CONFIG_NL80211_TESTMODE\n\tint\t(*testmode_cmd)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tvoid *data, int len);\n\tint\t(*testmode_dump)(struct wiphy *wiphy, struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb,\n\t\t\t\t void *data, int len);\n#endif\n\n\tint\t(*set_bitrate_mask)(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    unsigned int link_id,\n\t\t\t\t    const u8 *peer,\n\t\t\t\t    const struct cfg80211_bitrate_mask *mask);\n\n\tint\t(*dump_survey)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\tint idx, struct survey_info *info);\n\n\tint\t(*set_pmksa)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t     struct cfg80211_pmksa *pmksa);\n\tint\t(*del_pmksa)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t     struct cfg80211_pmksa *pmksa);\n\tint\t(*flush_pmksa)(struct wiphy *wiphy, struct net_device *netdev);\n\n\tint\t(*remain_on_channel)(struct wiphy *wiphy,\n\t\t\t\t     struct wireless_dev *wdev,\n\t\t\t\t     struct ieee80211_channel *chan,\n\t\t\t\t     unsigned int duration,\n\t\t\t\t     u64 *cookie);\n\tint\t(*cancel_remain_on_channel)(struct wiphy *wiphy,\n\t\t\t\t\t    struct wireless_dev *wdev,\n\t\t\t\t\t    u64 cookie);\n\n\tint\t(*mgmt_tx)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t   struct cfg80211_mgmt_tx_params *params,\n\t\t\t   u64 *cookie);\n\tint\t(*mgmt_tx_cancel_wait)(struct wiphy *wiphy,\n\t\t\t\t       struct wireless_dev *wdev,\n\t\t\t\t       u64 cookie);\n\n\tint\t(*set_power_mgmt)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  bool enabled, int timeout);\n\n\tint\t(*set_cqm_rssi_config)(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       s32 rssi_thold, u32 rssi_hyst);\n\n\tint\t(*set_cqm_rssi_range_config)(struct wiphy *wiphy,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     s32 rssi_low, s32 rssi_high);\n\n\tint\t(*set_cqm_txe_config)(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      u32 rate, u32 pkts, u32 intvl);\n\n\tvoid\t(*update_mgmt_frame_registrations)(struct wiphy *wiphy,\n\t\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t\t   struct mgmt_frame_regs *upd);\n\n\tint\t(*set_antenna)(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant);\n\tint\t(*get_antenna)(struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant);\n\n\tint\t(*sched_scan_start)(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tstruct cfg80211_sched_scan_request *request);\n\tint\t(*sched_scan_stop)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t   u64 reqid);\n\n\tint\t(*set_rekey_data)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  struct cfg80211_gtk_rekey_data *data);\n\n\tint\t(*tdls_mgmt)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     const u8 *peer, int link_id,\n\t\t\t     u8 action_code, u8 dialog_token, u16 status_code,\n\t\t\t     u32 peer_capability, bool initiator,\n\t\t\t     const u8 *buf, size_t len);\n\tint\t(*tdls_oper)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     const u8 *peer, enum nl80211_tdls_operation oper);\n\n\tint\t(*probe_client)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tconst u8 *peer, u64 *cookie);\n\n\tint\t(*set_noack_map)(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  u16 noack_map);\n\n\tint\t(*get_channel)(struct wiphy *wiphy,\n\t\t\t       struct wireless_dev *wdev,\n\t\t\t       unsigned int link_id,\n\t\t\t       struct cfg80211_chan_def *chandef);\n\n\tint\t(*start_p2p_device)(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev);\n\tvoid\t(*stop_p2p_device)(struct wiphy *wiphy,\n\t\t\t\t   struct wireless_dev *wdev);\n\n\tint\t(*set_mac_acl)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const struct cfg80211_acl_data *params);\n\n\tint\t(*start_radar_detection)(struct wiphy *wiphy,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t struct cfg80211_chan_def *chandef,\n\t\t\t\t\t u32 cac_time_ms);\n\tvoid\t(*end_cac)(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev);\n\tint\t(*update_ft_ies)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t struct cfg80211_update_ft_ies_params *ftie);\n\tint\t(*crit_proto_start)(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev,\n\t\t\t\t    enum nl80211_crit_proto_id protocol,\n\t\t\t\t    u16 duration);\n\tvoid\t(*crit_proto_stop)(struct wiphy *wiphy,\n\t\t\t\t   struct wireless_dev *wdev);\n\tint\t(*set_coalesce)(struct wiphy *wiphy,\n\t\t\t\tstruct cfg80211_coalesce *coalesce);\n\n\tint\t(*channel_switch)(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  struct cfg80211_csa_settings *params);\n\n\tint     (*set_qos_map)(struct wiphy *wiphy,\n\t\t\t       struct net_device *dev,\n\t\t\t       struct cfg80211_qos_map *qos_map);\n\n\tint\t(*set_ap_chanwidth)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t    unsigned int link_id,\n\t\t\t\t    struct cfg80211_chan_def *chandef);\n\n\tint\t(*add_tx_ts)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     u8 tsid, const u8 *peer, u8 user_prio,\n\t\t\t     u16 admitted_time);\n\tint\t(*del_tx_ts)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     u8 tsid, const u8 *peer);\n\n\tint\t(*tdls_channel_switch)(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       const u8 *addr, u8 oper_class,\n\t\t\t\t       struct cfg80211_chan_def *chandef);\n\tvoid\t(*tdls_cancel_channel_switch)(struct wiphy *wiphy,\n\t\t\t\t\t      struct net_device *dev,\n\t\t\t\t\t      const u8 *addr);\n\tint\t(*start_nan)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t     struct cfg80211_nan_conf *conf);\n\tvoid\t(*stop_nan)(struct wiphy *wiphy, struct wireless_dev *wdev);\n\tint\t(*add_nan_func)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tstruct cfg80211_nan_func *nan_func);\n\tvoid\t(*del_nan_func)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t       u64 cookie);\n\tint\t(*nan_change_conf)(struct wiphy *wiphy,\n\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t   struct cfg80211_nan_conf *conf,\n\t\t\t\t   u32 changes);\n\n\tint\t(*set_multicast_to_unicast)(struct wiphy *wiphy,\n\t\t\t\t\t    struct net_device *dev,\n\t\t\t\t\t    const bool enabled);\n\n\tint\t(*get_txq_stats)(struct wiphy *wiphy,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t struct cfg80211_txq_stats *txqstats);\n\n\tint\t(*set_pmk)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   const struct cfg80211_pmk_conf *conf);\n\tint\t(*del_pmk)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   const u8 *aa);\n\tint     (*external_auth)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t struct cfg80211_external_auth_params *params);\n\n\tint\t(*tx_control_port)(struct wiphy *wiphy,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   const u8 *buf, size_t len,\n\t\t\t\t   const u8 *dest, const __be16 proto,\n\t\t\t\t   const bool noencrypt, int link_id,\n\t\t\t\t   u64 *cookie);\n\n\tint\t(*get_ftm_responder_stats)(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tstruct cfg80211_ftm_responder_stats *ftm_stats);\n\n\tint\t(*start_pmsr)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t      struct cfg80211_pmsr_request *request);\n\tvoid\t(*abort_pmsr)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t      struct cfg80211_pmsr_request *request);\n\tint\t(*update_owe_info)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t   struct cfg80211_update_owe_info *owe_info);\n\tint\t(*probe_mesh_link)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t   const u8 *buf, size_t len);\n\tint     (*set_tid_config)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  struct cfg80211_tid_config *tid_conf);\n\tint\t(*reset_tid_config)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t    const u8 *peer, u8 tids);\n\tint\t(*set_sar_specs)(struct wiphy *wiphy,\n\t\t\t\t struct cfg80211_sar_specs *sar);\n\tint\t(*color_change)(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tstruct cfg80211_color_change_settings *params);\n\tint     (*set_fils_aad)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tstruct cfg80211_fils_aad *fils_aad);\n\tint\t(*set_radar_background)(struct wiphy *wiphy,\n\t\t\t\t\tstruct cfg80211_chan_def *chandef);\n\tint\t(*add_link_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t    struct link_station_parameters *params);\n\tint\t(*mod_link_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t    struct link_station_parameters *params);\n\tint\t(*del_link_station)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t    struct link_station_del_parameters *params);\n\tint\t(*set_hw_timestamp)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t    struct cfg80211_set_hw_timestamp *hwts);\n};\n\n \n\n \nenum wiphy_flags {\n\tWIPHY_FLAG_SUPPORTS_EXT_KEK_KCK\t\t= BIT(0),\n\tWIPHY_FLAG_SUPPORTS_MLO\t\t\t= BIT(1),\n\tWIPHY_FLAG_SPLIT_SCAN_6GHZ\t\t= BIT(2),\n\tWIPHY_FLAG_NETNS_OK\t\t\t= BIT(3),\n\tWIPHY_FLAG_PS_ON_BY_DEFAULT\t\t= BIT(4),\n\tWIPHY_FLAG_4ADDR_AP\t\t\t= BIT(5),\n\tWIPHY_FLAG_4ADDR_STATION\t\t= BIT(6),\n\tWIPHY_FLAG_CONTROL_PORT_PROTOCOL\t= BIT(7),\n\tWIPHY_FLAG_IBSS_RSN\t\t\t= BIT(8),\n\tWIPHY_FLAG_MESH_AUTH\t\t\t= BIT(10),\n\tWIPHY_FLAG_SUPPORTS_EXT_KCK_32          = BIT(11),\n\t \n\tWIPHY_FLAG_SUPPORTS_FW_ROAM\t\t= BIT(13),\n\tWIPHY_FLAG_AP_UAPSD\t\t\t= BIT(14),\n\tWIPHY_FLAG_SUPPORTS_TDLS\t\t= BIT(15),\n\tWIPHY_FLAG_TDLS_EXTERNAL_SETUP\t\t= BIT(16),\n\tWIPHY_FLAG_HAVE_AP_SME\t\t\t= BIT(17),\n\tWIPHY_FLAG_REPORTS_OBSS\t\t\t= BIT(18),\n\tWIPHY_FLAG_AP_PROBE_RESP_OFFLOAD\t= BIT(19),\n\tWIPHY_FLAG_OFFCHAN_TX\t\t\t= BIT(20),\n\tWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL\t= BIT(21),\n\tWIPHY_FLAG_SUPPORTS_5_10_MHZ\t\t= BIT(22),\n\tWIPHY_FLAG_HAS_CHANNEL_SWITCH\t\t= BIT(23),\n\tWIPHY_FLAG_NOTIFY_REGDOM_BY_DRIVER\t= BIT(24),\n};\n\n \nstruct ieee80211_iface_limit {\n\tu16 max;\n\tu16 types;\n};\n\n \nstruct ieee80211_iface_combination {\n\t \n\tconst struct ieee80211_iface_limit *limits;\n\n\t \n\tu32 num_different_channels;\n\n\t \n\tu16 max_interfaces;\n\n\t \n\tu8 n_limits;\n\n\t \n\tbool beacon_int_infra_match;\n\n\t \n\tu8 radar_detect_widths;\n\n\t \n\tu8 radar_detect_regions;\n\n\t \n\tu32 beacon_int_min_gcd;\n};\n\nstruct ieee80211_txrx_stypes {\n\tu16 tx, rx;\n};\n\n \nenum wiphy_wowlan_support_flags {\n\tWIPHY_WOWLAN_ANY\t\t= BIT(0),\n\tWIPHY_WOWLAN_MAGIC_PKT\t\t= BIT(1),\n\tWIPHY_WOWLAN_DISCONNECT\t\t= BIT(2),\n\tWIPHY_WOWLAN_SUPPORTS_GTK_REKEY\t= BIT(3),\n\tWIPHY_WOWLAN_GTK_REKEY_FAILURE\t= BIT(4),\n\tWIPHY_WOWLAN_EAP_IDENTITY_REQ\t= BIT(5),\n\tWIPHY_WOWLAN_4WAY_HANDSHAKE\t= BIT(6),\n\tWIPHY_WOWLAN_RFKILL_RELEASE\t= BIT(7),\n\tWIPHY_WOWLAN_NET_DETECT\t\t= BIT(8),\n};\n\nstruct wiphy_wowlan_tcp_support {\n\tconst struct nl80211_wowlan_tcp_data_token_feature *tok;\n\tu32 data_payload_max;\n\tu32 data_interval_max;\n\tu32 wake_payload_max;\n\tbool seq;\n};\n\n \nstruct wiphy_wowlan_support {\n\tu32 flags;\n\tint n_patterns;\n\tint pattern_max_len;\n\tint pattern_min_len;\n\tint max_pkt_offset;\n\tint max_nd_match_sets;\n\tconst struct wiphy_wowlan_tcp_support *tcp;\n};\n\n \nstruct wiphy_coalesce_support {\n\tint n_rules;\n\tint max_delay;\n\tint n_patterns;\n\tint pattern_max_len;\n\tint pattern_min_len;\n\tint max_pkt_offset;\n};\n\n \nenum wiphy_vendor_command_flags {\n\tWIPHY_VENDOR_CMD_NEED_WDEV = BIT(0),\n\tWIPHY_VENDOR_CMD_NEED_NETDEV = BIT(1),\n\tWIPHY_VENDOR_CMD_NEED_RUNNING = BIT(2),\n};\n\n \nenum wiphy_opmode_flag {\n\tSTA_OPMODE_MAX_BW_CHANGED\t= BIT(0),\n\tSTA_OPMODE_SMPS_MODE_CHANGED\t= BIT(1),\n\tSTA_OPMODE_N_SS_CHANGED\t\t= BIT(2),\n};\n\n \n\nstruct sta_opmode_info {\n\tu32 changed;\n\tenum nl80211_smps_mode smps_mode;\n\tenum nl80211_chan_width bw;\n\tu8 rx_nss;\n};\n\n#define VENDOR_CMD_RAW_DATA ((const struct nla_policy *)(long)(-ENODATA))\n\n \nstruct wiphy_vendor_command {\n\tstruct nl80211_vendor_cmd_info info;\n\tu32 flags;\n\tint (*doit)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t    const void *data, int data_len);\n\tint (*dumpit)(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t      struct sk_buff *skb, const void *data, int data_len,\n\t\t      unsigned long *storage);\n\tconst struct nla_policy *policy;\n\tunsigned int maxattr;\n};\n\n \nstruct wiphy_iftype_ext_capab {\n\tenum nl80211_iftype iftype;\n\tconst u8 *extended_capabilities;\n\tconst u8 *extended_capabilities_mask;\n\tu8 extended_capabilities_len;\n\tu16 eml_capabilities;\n\tu16 mld_capa_and_ops;\n};\n\n \nconst struct wiphy_iftype_ext_capab *\ncfg80211_get_iftype_ext_capa(struct wiphy *wiphy, enum nl80211_iftype type);\n\n \nstruct cfg80211_pmsr_capabilities {\n\tunsigned int max_peers;\n\tu8 report_ap_tsf:1,\n\t   randomize_mac_addr:1;\n\n\tstruct {\n\t\tu32 preambles;\n\t\tu32 bandwidths;\n\t\ts8 max_bursts_exponent;\n\t\tu8 max_ftms_per_burst;\n\t\tu8 supported:1,\n\t\t   asap:1,\n\t\t   non_asap:1,\n\t\t   request_lci:1,\n\t\t   request_civicloc:1,\n\t\t   trigger_based:1,\n\t\t   non_trigger_based:1;\n\t} ftm;\n};\n\n \nstruct wiphy_iftype_akm_suites {\n\tu16 iftypes_mask;\n\tconst u32 *akm_suites;\n\tint n_akm_suites;\n};\n\n#define CFG80211_HW_TIMESTAMP_ALL_PEERS\t0xffff\n\n \nstruct wiphy {\n\tstruct mutex mtx;\n\n\t \n\n\tu8 perm_addr[ETH_ALEN];\n\tu8 addr_mask[ETH_ALEN];\n\n\tstruct mac_address *addresses;\n\n\tconst struct ieee80211_txrx_stypes *mgmt_stypes;\n\n\tconst struct ieee80211_iface_combination *iface_combinations;\n\tint n_iface_combinations;\n\tu16 software_iftypes;\n\n\tu16 n_addresses;\n\n\t \n\tu16 interface_modes;\n\n\tu16 max_acl_mac_addrs;\n\n\tu32 flags, regulatory_flags, features;\n\tu8 ext_features[DIV_ROUND_UP(NUM_NL80211_EXT_FEATURES, 8)];\n\n\tu32 ap_sme_capa;\n\n\tenum cfg80211_signal_type signal_type;\n\n\tint bss_priv_size;\n\tu8 max_scan_ssids;\n\tu8 max_sched_scan_reqs;\n\tu8 max_sched_scan_ssids;\n\tu8 max_match_sets;\n\tu16 max_scan_ie_len;\n\tu16 max_sched_scan_ie_len;\n\tu32 max_sched_scan_plans;\n\tu32 max_sched_scan_plan_interval;\n\tu32 max_sched_scan_plan_iterations;\n\n\tint n_cipher_suites;\n\tconst u32 *cipher_suites;\n\n\tint n_akm_suites;\n\tconst u32 *akm_suites;\n\n\tconst struct wiphy_iftype_akm_suites *iftype_akm_suites;\n\tunsigned int num_iftype_akm_suites;\n\n\tu8 retry_short;\n\tu8 retry_long;\n\tu32 frag_threshold;\n\tu32 rts_threshold;\n\tu8 coverage_class;\n\n\tchar fw_version[ETHTOOL_FWVERS_LEN];\n\tu32 hw_version;\n\n#ifdef CONFIG_PM\n\tconst struct wiphy_wowlan_support *wowlan;\n\tstruct cfg80211_wowlan *wowlan_config;\n#endif\n\n\tu16 max_remain_on_channel_duration;\n\n\tu8 max_num_pmkids;\n\n\tu32 available_antennas_tx;\n\tu32 available_antennas_rx;\n\n\tu32 probe_resp_offload;\n\n\tconst u8 *extended_capabilities, *extended_capabilities_mask;\n\tu8 extended_capabilities_len;\n\n\tconst struct wiphy_iftype_ext_capab *iftype_ext_capab;\n\tunsigned int num_iftype_ext_capab;\n\n\tconst void *privid;\n\n\tstruct ieee80211_supported_band *bands[NUM_NL80211_BANDS];\n\n\tvoid (*reg_notifier)(struct wiphy *wiphy,\n\t\t\t     struct regulatory_request *request);\n\n\t \n\n\tconst struct ieee80211_regdomain __rcu *regd;\n\n\tstruct device dev;\n\n\tbool registered;\n\n\tstruct dentry *debugfsdir;\n\n\tconst struct ieee80211_ht_cap *ht_capa_mod_mask;\n\tconst struct ieee80211_vht_cap *vht_capa_mod_mask;\n\n\tstruct list_head wdev_list;\n\n\tpossible_net_t _net;\n\n#ifdef CONFIG_CFG80211_WEXT\n\tconst struct iw_handler_def *wext;\n#endif\n\n\tconst struct wiphy_coalesce_support *coalesce;\n\n\tconst struct wiphy_vendor_command *vendor_commands;\n\tconst struct nl80211_vendor_cmd_info *vendor_events;\n\tint n_vendor_commands, n_vendor_events;\n\n\tu16 max_ap_assoc_sta;\n\n\tu8 max_num_csa_counters;\n\n\tu32 bss_select_support;\n\n\tu8 nan_supported_bands;\n\n\tu32 txq_limit;\n\tu32 txq_memory_limit;\n\tu32 txq_quantum;\n\n\tunsigned long tx_queue_len;\n\n\tu8 support_mbssid:1,\n\t   support_only_he_mbssid:1;\n\n\tconst struct cfg80211_pmsr_capabilities *pmsr_capa;\n\n\tstruct {\n\t\tu64 peer, vif;\n\t\tu8 max_retry;\n\t} tid_config_support;\n\n\tu8 max_data_retry_count;\n\n\tconst struct cfg80211_sar_capa *sar_capa;\n\n\tstruct rfkill *rfkill;\n\n\tu8 mbssid_max_interfaces;\n\tu8 ema_max_profile_periodicity;\n\tu16 max_num_akm_suites;\n\n\tu16 hw_timestamp_max_peers;\n\n\tchar priv[] __aligned(NETDEV_ALIGN);\n};\n\nstatic inline struct net *wiphy_net(struct wiphy *wiphy)\n{\n\treturn read_pnet(&wiphy->_net);\n}\n\nstatic inline void wiphy_net_set(struct wiphy *wiphy, struct net *net)\n{\n\twrite_pnet(&wiphy->_net, net);\n}\n\n \nstatic inline void *wiphy_priv(struct wiphy *wiphy)\n{\n\tBUG_ON(!wiphy);\n\treturn &wiphy->priv;\n}\n\n \nstatic inline struct wiphy *priv_to_wiphy(void *priv)\n{\n\tBUG_ON(!priv);\n\treturn container_of(priv, struct wiphy, priv);\n}\n\n \nstatic inline void set_wiphy_dev(struct wiphy *wiphy, struct device *dev)\n{\n\twiphy->dev.parent = dev;\n}\n\n \nstatic inline struct device *wiphy_dev(struct wiphy *wiphy)\n{\n\treturn wiphy->dev.parent;\n}\n\n \nstatic inline const char *wiphy_name(const struct wiphy *wiphy)\n{\n\treturn dev_name(&wiphy->dev);\n}\n\n \nstruct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,\n\t\t\t   const char *requested_name);\n\n \nstatic inline struct wiphy *wiphy_new(const struct cfg80211_ops *ops,\n\t\t\t\t      int sizeof_priv)\n{\n\treturn wiphy_new_nm(ops, sizeof_priv, NULL);\n}\n\n \nint wiphy_register(struct wiphy *wiphy);\n\n \n#define lockdep_assert_wiphy(wiphy) lockdep_assert_held(&(wiphy)->mtx)\n\n \n#define rcu_dereference_wiphy(wiphy, p)\t\t\t\t\\\n        rcu_dereference_check(p, lockdep_is_held(&wiphy->mtx))\n\n \n#define wiphy_dereference(wiphy, p)\t\t\t\t\\\n        rcu_dereference_protected(p, lockdep_is_held(&wiphy->mtx))\n\n \nconst struct ieee80211_regdomain *get_wiphy_regdom(struct wiphy *wiphy);\n\n \nvoid wiphy_unregister(struct wiphy *wiphy);\n\n \nvoid wiphy_free(struct wiphy *wiphy);\n\n \nstruct cfg80211_conn;\nstruct cfg80211_internal_bss;\nstruct cfg80211_cached_keys;\nstruct cfg80211_cqm_config;\n\n \nstatic inline void wiphy_lock(struct wiphy *wiphy)\n\t__acquires(&wiphy->mtx)\n{\n\tmutex_lock(&wiphy->mtx);\n\t__acquire(&wiphy->mtx);\n}\n\n \nstatic inline void wiphy_unlock(struct wiphy *wiphy)\n\t__releases(&wiphy->mtx)\n{\n\t__release(&wiphy->mtx);\n\tmutex_unlock(&wiphy->mtx);\n}\n\nstruct wiphy_work;\ntypedef void (*wiphy_work_func_t)(struct wiphy *, struct wiphy_work *);\n\nstruct wiphy_work {\n\tstruct list_head entry;\n\twiphy_work_func_t func;\n};\n\nstatic inline void wiphy_work_init(struct wiphy_work *work,\n\t\t\t\t   wiphy_work_func_t func)\n{\n\tINIT_LIST_HEAD(&work->entry);\n\twork->func = func;\n}\n\n \nvoid wiphy_work_queue(struct wiphy *wiphy, struct wiphy_work *work);\n\n \nvoid wiphy_work_cancel(struct wiphy *wiphy, struct wiphy_work *work);\n\n \nvoid wiphy_work_flush(struct wiphy *wiphy, struct wiphy_work *work);\n\nstruct wiphy_delayed_work {\n\tstruct wiphy_work work;\n\tstruct wiphy *wiphy;\n\tstruct timer_list timer;\n};\n\nvoid wiphy_delayed_work_timer(struct timer_list *t);\n\nstatic inline void wiphy_delayed_work_init(struct wiphy_delayed_work *dwork,\n\t\t\t\t\t   wiphy_work_func_t func)\n{\n\ttimer_setup(&dwork->timer, wiphy_delayed_work_timer, 0);\n\twiphy_work_init(&dwork->work, func);\n}\n\n \nvoid wiphy_delayed_work_queue(struct wiphy *wiphy,\n\t\t\t      struct wiphy_delayed_work *dwork,\n\t\t\t      unsigned long delay);\n\n \nvoid wiphy_delayed_work_cancel(struct wiphy *wiphy,\n\t\t\t       struct wiphy_delayed_work *dwork);\n\n \nvoid wiphy_delayed_work_flush(struct wiphy *wiphy,\n\t\t\t      struct wiphy_delayed_work *dwork);\n\n \nstruct wireless_dev {\n\tstruct wiphy *wiphy;\n\tenum nl80211_iftype iftype;\n\n\t \n\tstruct list_head list;\n\tstruct net_device *netdev;\n\n\tu32 identifier;\n\n\tstruct list_head mgmt_registrations;\n\tu8 mgmt_registrations_need_update:1;\n\n\tstruct mutex mtx;\n\n\tbool use_4addr, is_running, registered, registering;\n\n\tu8 address[ETH_ALEN] __aligned(sizeof(u16));\n\n\t \n\tstruct cfg80211_conn *conn;\n\tstruct cfg80211_cached_keys *connect_keys;\n\tenum ieee80211_bss_type conn_bss_type;\n\tu32 conn_owner_nlportid;\n\n\tstruct work_struct disconnect_wk;\n\tu8 disconnect_bssid[ETH_ALEN];\n\n\tstruct list_head event_list;\n\tspinlock_t event_lock;\n\n\tu8 connected:1;\n\n\tbool ps;\n\tint ps_timeout;\n\n\tu32 ap_unexpected_nlportid;\n\n\tu32 owner_nlportid;\n\tbool nl_owner_dead;\n\n\t \n\tbool cac_started;\n\tunsigned long cac_start_time;\n\tunsigned int cac_time_ms;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t \n\tstruct {\n\t\tstruct cfg80211_ibss_params ibss;\n\t\tstruct cfg80211_connect_params connect;\n\t\tstruct cfg80211_cached_keys *keys;\n\t\tconst u8 *ie;\n\t\tsize_t ie_len;\n\t\tu8 bssid[ETH_ALEN];\n\t\tu8 prev_bssid[ETH_ALEN];\n\t\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\t\ts8 default_key, default_mgmt_key;\n\t\tbool prev_bssid_valid;\n\t} wext;\n#endif\n\n\tstruct wiphy_work cqm_rssi_work;\n\tstruct cfg80211_cqm_config __rcu *cqm_config;\n\n\tstruct list_head pmsr_list;\n\tspinlock_t pmsr_lock;\n\tstruct work_struct pmsr_free_wk;\n\n\tunsigned long unprot_beacon_reported;\n\n\tunion {\n\t\tstruct {\n\t\t\tu8 connected_addr[ETH_ALEN] __aligned(2);\n\t\t\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\t\t\tu8 ssid_len;\n\t\t} client;\n\t\tstruct {\n\t\t\tint beacon_interval;\n\t\t\tstruct cfg80211_chan_def preset_chandef;\n\t\t\tstruct cfg80211_chan_def chandef;\n\t\t\tu8 id[IEEE80211_MAX_SSID_LEN];\n\t\t\tu8 id_len, id_up_len;\n\t\t} mesh;\n\t\tstruct {\n\t\t\tstruct cfg80211_chan_def preset_chandef;\n\t\t\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\t\t\tu8 ssid_len;\n\t\t} ap;\n\t\tstruct {\n\t\t\tstruct cfg80211_internal_bss *current_bss;\n\t\t\tstruct cfg80211_chan_def chandef;\n\t\t\tint beacon_interval;\n\t\t\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\t\t\tu8 ssid_len;\n\t\t} ibss;\n\t\tstruct {\n\t\t\tstruct cfg80211_chan_def chandef;\n\t\t} ocb;\n\t} u;\n\n\tstruct {\n\t\tu8 addr[ETH_ALEN] __aligned(2);\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tunsigned int beacon_interval;\n\t\t\t\tstruct cfg80211_chan_def chandef;\n\t\t\t} ap;\n\t\t\tstruct {\n\t\t\t\tstruct cfg80211_internal_bss *current_bss;\n\t\t\t} client;\n\t\t};\n\t} links[IEEE80211_MLD_MAX_NUM_LINKS];\n\tu16 valid_links;\n};\n\nstatic inline const u8 *wdev_address(struct wireless_dev *wdev)\n{\n\tif (wdev->netdev)\n\t\treturn wdev->netdev->dev_addr;\n\treturn wdev->address;\n}\n\nstatic inline bool wdev_running(struct wireless_dev *wdev)\n{\n\tif (wdev->netdev)\n\t\treturn netif_running(wdev->netdev);\n\treturn wdev->is_running;\n}\n\n \nstatic inline void *wdev_priv(struct wireless_dev *wdev)\n{\n\tBUG_ON(!wdev);\n\treturn wiphy_priv(wdev->wiphy);\n}\n\n \nstruct cfg80211_chan_def *wdev_chandef(struct wireless_dev *wdev,\n\t\t\t\t       unsigned int link_id);\n\nstatic inline void WARN_INVALID_LINK_ID(struct wireless_dev *wdev,\n\t\t\t\t\tunsigned int link_id)\n{\n\tWARN_ON(link_id && !wdev->valid_links);\n\tWARN_ON(wdev->valid_links &&\n\t\t!(wdev->valid_links & BIT(link_id)));\n}\n\n#define for_each_valid_link(link_info, link_id)\t\t\t\\\n\tfor (link_id = 0;\t\t\t\t\t\\\n\t     link_id < ((link_info)->valid_links ?\t\t\\\n\t\t\tARRAY_SIZE((link_info)->links) : 1);\t\\\n\t     link_id++)\t\t\t\t\t\t\\\n\t\tif (!(link_info)->valid_links ||\t\t\\\n\t\t    ((link_info)->valid_links & BIT(link_id)))\n\n \n\n \nstatic inline bool\nieee80211_channel_equal(struct ieee80211_channel *a,\n\t\t\tstruct ieee80211_channel *b)\n{\n\treturn (a->center_freq == b->center_freq &&\n\t\ta->freq_offset == b->freq_offset);\n}\n\n \nstatic inline u32\nieee80211_channel_to_khz(const struct ieee80211_channel *chan)\n{\n\treturn MHZ_TO_KHZ(chan->center_freq) + chan->freq_offset;\n}\n\n \nenum nl80211_chan_width\nieee80211_s1g_channel_width(const struct ieee80211_channel *chan);\n\n \nu32 ieee80211_channel_to_freq_khz(int chan, enum nl80211_band band);\n\n \nstatic inline int\nieee80211_channel_to_frequency(int chan, enum nl80211_band band)\n{\n\treturn KHZ_TO_MHZ(ieee80211_channel_to_freq_khz(chan, band));\n}\n\n \nint ieee80211_freq_khz_to_channel(u32 freq);\n\n \nstatic inline int\nieee80211_frequency_to_channel(int freq)\n{\n\treturn ieee80211_freq_khz_to_channel(MHZ_TO_KHZ(freq));\n}\n\n \nstruct ieee80211_channel *\nieee80211_get_channel_khz(struct wiphy *wiphy, u32 freq);\n\n \nstatic inline struct ieee80211_channel *\nieee80211_get_channel(struct wiphy *wiphy, int freq)\n{\n\treturn ieee80211_get_channel_khz(wiphy, MHZ_TO_KHZ(freq));\n}\n\n \nstatic inline bool cfg80211_channel_is_psc(struct ieee80211_channel *chan)\n{\n\tif (chan->band != NL80211_BAND_6GHZ)\n\t\treturn false;\n\n\treturn ieee80211_frequency_to_channel(chan->center_freq) % 16 == 5;\n}\n\n \nconst struct ieee80211_rate *\nieee80211_get_response_rate(struct ieee80211_supported_band *sband,\n\t\t\t    u32 basic_rates, int bitrate);\n\n \nu32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,\n\t\t\t      enum nl80211_bss_scan_width scan_width);\n\n \n\nstruct radiotap_align_size {\n\tuint8_t align:4, size:4;\n};\n\nstruct ieee80211_radiotap_namespace {\n\tconst struct radiotap_align_size *align_size;\n\tint n_bits;\n\tuint32_t oui;\n\tuint8_t subns;\n};\n\nstruct ieee80211_radiotap_vendor_namespaces {\n\tconst struct ieee80211_radiotap_namespace *ns;\n\tint n_ns;\n};\n\n \n\nstruct ieee80211_radiotap_iterator {\n\tstruct ieee80211_radiotap_header *_rtheader;\n\tconst struct ieee80211_radiotap_vendor_namespaces *_vns;\n\tconst struct ieee80211_radiotap_namespace *current_namespace;\n\n\tunsigned char *_arg, *_next_ns_data;\n\t__le32 *_next_bitmap;\n\n\tunsigned char *this_arg;\n\tint this_arg_index;\n\tint this_arg_size;\n\n\tint is_radiotap_ns;\n\n\tint _max_length;\n\tint _arg_index;\n\tuint32_t _bitmap_shifter;\n\tint _reset_on_ext;\n};\n\nint\nieee80211_radiotap_iterator_init(struct ieee80211_radiotap_iterator *iterator,\n\t\t\t\t struct ieee80211_radiotap_header *radiotap_header,\n\t\t\t\t int max_length,\n\t\t\t\t const struct ieee80211_radiotap_vendor_namespaces *vns);\n\nint\nieee80211_radiotap_iterator_next(struct ieee80211_radiotap_iterator *iterator);\n\n\nextern const unsigned char rfc1042_header[6];\nextern const unsigned char bridge_tunnel_header[6];\n\n \nunsigned int ieee80211_get_hdrlen_from_skb(const struct sk_buff *skb);\n\n \nunsigned int __attribute_const__ ieee80211_hdrlen(__le16 fc);\n\n \nunsigned int ieee80211_get_mesh_hdrlen(struct ieee80211s_hdr *meshhdr);\n\n \n\n \nint ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,\n\t\t\t\t  const u8 *addr, enum nl80211_iftype iftype,\n\t\t\t\t  u8 data_offset, bool is_amsdu);\n\n \nstatic inline int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,\n\t\t\t\t\t enum nl80211_iftype iftype)\n{\n\treturn ieee80211_data_to_8023_exthdr(skb, NULL, addr, iftype, 0, false);\n}\n\n \nbool ieee80211_is_valid_amsdu(struct sk_buff *skb, u8 mesh_hdr);\n\n \nvoid ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,\n\t\t\t      const u8 *addr, enum nl80211_iftype iftype,\n\t\t\t      const unsigned int extra_headroom,\n\t\t\t      const u8 *check_da, const u8 *check_sa,\n\t\t\t      u8 mesh_control);\n\n \nbool ieee80211_get_8023_tunnel_proto(const void *hdr, __be16 *proto);\n\n \nint ieee80211_strip_8023_mesh_hdr(struct sk_buff *skb);\n\n \nunsigned int cfg80211_classify8021d(struct sk_buff *skb,\n\t\t\t\t    struct cfg80211_qos_map *qos_map);\n\n \nconst struct element *\ncfg80211_find_elem_match(u8 eid, const u8 *ies, unsigned int len,\n\t\t\t const u8 *match, unsigned int match_len,\n\t\t\t unsigned int match_offset);\n\n \nstatic inline const u8 *\ncfg80211_find_ie_match(u8 eid, const u8 *ies, unsigned int len,\n\t\t       const u8 *match, unsigned int match_len,\n\t\t       unsigned int match_offset)\n{\n\t \n\tif (WARN_ON((match_len && match_offset < 2) ||\n\t\t    (!match_len && match_offset)))\n\t\treturn NULL;\n\n\treturn (const void *)cfg80211_find_elem_match(eid, ies, len,\n\t\t\t\t\t\t      match, match_len,\n\t\t\t\t\t\t      match_offset ?\n\t\t\t\t\t\t\tmatch_offset - 2 : 0);\n}\n\n \nstatic inline const struct element *\ncfg80211_find_elem(u8 eid, const u8 *ies, int len)\n{\n\treturn cfg80211_find_elem_match(eid, ies, len, NULL, 0, 0);\n}\n\n \nstatic inline const u8 *cfg80211_find_ie(u8 eid, const u8 *ies, int len)\n{\n\treturn cfg80211_find_ie_match(eid, ies, len, NULL, 0, 0);\n}\n\n \nstatic inline const struct element *\ncfg80211_find_ext_elem(u8 ext_eid, const u8 *ies, int len)\n{\n\treturn cfg80211_find_elem_match(WLAN_EID_EXTENSION, ies, len,\n\t\t\t\t\t&ext_eid, 1, 0);\n}\n\n \nstatic inline const u8 *cfg80211_find_ext_ie(u8 ext_eid, const u8 *ies, int len)\n{\n\treturn cfg80211_find_ie_match(WLAN_EID_EXTENSION, ies, len,\n\t\t\t\t      &ext_eid, 1, 2);\n}\n\n \nconst struct element *cfg80211_find_vendor_elem(unsigned int oui, int oui_type,\n\t\t\t\t\t\tconst u8 *ies,\n\t\t\t\t\t\tunsigned int len);\n\n \nstatic inline const u8 *\ncfg80211_find_vendor_ie(unsigned int oui, int oui_type,\n\t\t\tconst u8 *ies, unsigned int len)\n{\n\treturn (const void *)cfg80211_find_vendor_elem(oui, oui_type, ies, len);\n}\n\n \nssize_t cfg80211_defragment_element(const struct element *elem, const u8 *ies,\n\t\t\t\t    size_t ieslen, u8 *data, size_t data_len,\n\t\t\t\t    u8 frag_id);\n\n \nvoid cfg80211_send_layer2_update(struct net_device *dev, const u8 *addr);\n\n \n\n \nint regulatory_hint(struct wiphy *wiphy, const char *alpha2);\n\n \nint regulatory_set_wiphy_regd(struct wiphy *wiphy,\n\t\t\t      struct ieee80211_regdomain *rd);\n\n \nint regulatory_set_wiphy_regd_sync(struct wiphy *wiphy,\n\t\t\t\t   struct ieee80211_regdomain *rd);\n\n \nvoid wiphy_apply_custom_regulatory(struct wiphy *wiphy,\n\t\t\t\t   const struct ieee80211_regdomain *regd);\n\n \nconst struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,\n\t\t\t\t\t       u32 center_freq);\n\n \nconst char *reg_initiator_name(enum nl80211_reg_initiator initiator);\n\n \nbool regulatory_pre_cac_allowed(struct wiphy *wiphy);\n\n \n\n \nint reg_query_regdb_wmm(char *alpha2, int freq,\n\t\t\tstruct ieee80211_reg_rule *rule);\n\n \n\n \nvoid cfg80211_scan_done(struct cfg80211_scan_request *request,\n\t\t\tstruct cfg80211_scan_info *info);\n\n \nvoid cfg80211_sched_scan_results(struct wiphy *wiphy, u64 reqid);\n\n \nvoid cfg80211_sched_scan_stopped(struct wiphy *wiphy, u64 reqid);\n\n \nvoid cfg80211_sched_scan_stopped_locked(struct wiphy *wiphy, u64 reqid);\n\n \nstruct cfg80211_bss * __must_check\ncfg80211_inform_bss_frame_data(struct wiphy *wiphy,\n\t\t\t       struct cfg80211_inform_bss *data,\n\t\t\t       struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t       gfp_t gfp);\n\nstatic inline struct cfg80211_bss * __must_check\ncfg80211_inform_bss_width_frame(struct wiphy *wiphy,\n\t\t\t\tstruct ieee80211_channel *rx_channel,\n\t\t\t\tenum nl80211_bss_scan_width scan_width,\n\t\t\t\tstruct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t\ts32 signal, gfp_t gfp)\n{\n\tstruct cfg80211_inform_bss data = {\n\t\t.chan = rx_channel,\n\t\t.scan_width = scan_width,\n\t\t.signal = signal,\n\t};\n\n\treturn cfg80211_inform_bss_frame_data(wiphy, &data, mgmt, len, gfp);\n}\n\nstatic inline struct cfg80211_bss * __must_check\ncfg80211_inform_bss_frame(struct wiphy *wiphy,\n\t\t\t  struct ieee80211_channel *rx_channel,\n\t\t\t  struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t  s32 signal, gfp_t gfp)\n{\n\tstruct cfg80211_inform_bss data = {\n\t\t.chan = rx_channel,\n\t\t.scan_width = NL80211_BSS_CHAN_WIDTH_20,\n\t\t.signal = signal,\n\t};\n\n\treturn cfg80211_inform_bss_frame_data(wiphy, &data, mgmt, len, gfp);\n}\n\n \nstatic inline void cfg80211_gen_new_bssid(const u8 *bssid, u8 max_bssid,\n\t\t\t\t\t  u8 mbssid_index, u8 *new_bssid)\n{\n\tu64 bssid_u64 = ether_addr_to_u64(bssid);\n\tu64 mask = GENMASK_ULL(max_bssid - 1, 0);\n\tu64 new_bssid_u64;\n\n\tnew_bssid_u64 = bssid_u64 & ~mask;\n\n\tnew_bssid_u64 |= ((bssid_u64 & mask) + mbssid_index) & mask;\n\n\tu64_to_ether_addr(new_bssid_u64, new_bssid);\n}\n\n \nbool cfg80211_is_element_inherited(const struct element *element,\n\t\t\t\t   const struct element *non_inherit_element);\n\n \nsize_t cfg80211_merge_profile(const u8 *ie, size_t ielen,\n\t\t\t      const struct element *mbssid_elem,\n\t\t\t      const struct element *sub_elem,\n\t\t\t      u8 *merged_ie, size_t max_copy_len);\n\n \nenum cfg80211_bss_frame_type {\n\tCFG80211_BSS_FTYPE_UNKNOWN,\n\tCFG80211_BSS_FTYPE_BEACON,\n\tCFG80211_BSS_FTYPE_PRESP,\n};\n\n \nint cfg80211_get_ies_channel_number(const u8 *ie, size_t ielen,\n\t\t\t\t    enum nl80211_band band);\n\n \nstruct cfg80211_bss * __must_check\ncfg80211_inform_bss_data(struct wiphy *wiphy,\n\t\t\t struct cfg80211_inform_bss *data,\n\t\t\t enum cfg80211_bss_frame_type ftype,\n\t\t\t const u8 *bssid, u64 tsf, u16 capability,\n\t\t\t u16 beacon_interval, const u8 *ie, size_t ielen,\n\t\t\t gfp_t gfp);\n\nstatic inline struct cfg80211_bss * __must_check\ncfg80211_inform_bss_width(struct wiphy *wiphy,\n\t\t\t  struct ieee80211_channel *rx_channel,\n\t\t\t  enum nl80211_bss_scan_width scan_width,\n\t\t\t  enum cfg80211_bss_frame_type ftype,\n\t\t\t  const u8 *bssid, u64 tsf, u16 capability,\n\t\t\t  u16 beacon_interval, const u8 *ie, size_t ielen,\n\t\t\t  s32 signal, gfp_t gfp)\n{\n\tstruct cfg80211_inform_bss data = {\n\t\t.chan = rx_channel,\n\t\t.scan_width = scan_width,\n\t\t.signal = signal,\n\t};\n\n\treturn cfg80211_inform_bss_data(wiphy, &data, ftype, bssid, tsf,\n\t\t\t\t\tcapability, beacon_interval, ie, ielen,\n\t\t\t\t\tgfp);\n}\n\nstatic inline struct cfg80211_bss * __must_check\ncfg80211_inform_bss(struct wiphy *wiphy,\n\t\t    struct ieee80211_channel *rx_channel,\n\t\t    enum cfg80211_bss_frame_type ftype,\n\t\t    const u8 *bssid, u64 tsf, u16 capability,\n\t\t    u16 beacon_interval, const u8 *ie, size_t ielen,\n\t\t    s32 signal, gfp_t gfp)\n{\n\tstruct cfg80211_inform_bss data = {\n\t\t.chan = rx_channel,\n\t\t.scan_width = NL80211_BSS_CHAN_WIDTH_20,\n\t\t.signal = signal,\n\t};\n\n\treturn cfg80211_inform_bss_data(wiphy, &data, ftype, bssid, tsf,\n\t\t\t\t\tcapability, beacon_interval, ie, ielen,\n\t\t\t\t\tgfp);\n}\n\n \nstruct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,\n\t\t\t\t      struct ieee80211_channel *channel,\n\t\t\t\t      const u8 *bssid,\n\t\t\t\t      const u8 *ssid, size_t ssid_len,\n\t\t\t\t      enum ieee80211_bss_type bss_type,\n\t\t\t\t      enum ieee80211_privacy privacy);\nstatic inline struct cfg80211_bss *\ncfg80211_get_ibss(struct wiphy *wiphy,\n\t\t  struct ieee80211_channel *channel,\n\t\t  const u8 *ssid, size_t ssid_len)\n{\n\treturn cfg80211_get_bss(wiphy, channel, NULL, ssid, ssid_len,\n\t\t\t\tIEEE80211_BSS_TYPE_IBSS,\n\t\t\t\tIEEE80211_PRIVACY_ANY);\n}\n\n \nvoid cfg80211_ref_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);\n\n \nvoid cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);\n\n \nvoid cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);\n\n \nvoid cfg80211_bss_iter(struct wiphy *wiphy,\n\t\t       struct cfg80211_chan_def *chandef,\n\t\t       void (*iter)(struct wiphy *wiphy,\n\t\t\t\t    struct cfg80211_bss *bss,\n\t\t\t\t    void *data),\n\t\t       void *iter_data);\n\nstatic inline enum nl80211_bss_scan_width\ncfg80211_chandef_to_scan_width(const struct cfg80211_chan_def *chandef)\n{\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\t\treturn NL80211_BSS_CHAN_WIDTH_5;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\treturn NL80211_BSS_CHAN_WIDTH_10;\n\tdefault:\n\t\treturn NL80211_BSS_CHAN_WIDTH_20;\n\t}\n}\n\n \nvoid cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);\n\n \nvoid cfg80211_auth_timeout(struct net_device *dev, const u8 *addr);\n\n \nstruct cfg80211_rx_assoc_resp {\n\tconst u8 *buf;\n\tsize_t len;\n\tconst u8 *req_ies;\n\tsize_t req_ies_len;\n\tint uapsd_queues;\n\tconst u8 *ap_mld_addr;\n\tstruct {\n\t\tu8 addr[ETH_ALEN] __aligned(2);\n\t\tstruct cfg80211_bss *bss;\n\t\tu16 status;\n\t} links[IEEE80211_MLD_MAX_NUM_LINKS];\n};\n\n \nvoid cfg80211_rx_assoc_resp(struct net_device *dev,\n\t\t\t    struct cfg80211_rx_assoc_resp *data);\n\n \nstruct cfg80211_assoc_failure {\n\tconst u8 *ap_mld_addr;\n\tstruct cfg80211_bss *bss[IEEE80211_MLD_MAX_NUM_LINKS];\n\tbool timeout;\n};\n\n \nvoid cfg80211_assoc_failure(struct net_device *dev,\n\t\t\t    struct cfg80211_assoc_failure *data);\n\n \nvoid cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len,\n\t\t\t   bool reconnect);\n\n \nvoid cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev,\n\t\t\t\t  const u8 *buf, size_t len);\n\n \nvoid cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,\n\t\t\t\t  enum nl80211_key_type key_type, int key_id,\n\t\t\t\t  const u8 *tsc, gfp_t gfp);\n\n \nvoid cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,\n\t\t\t  struct ieee80211_channel *channel, gfp_t gfp);\n\n \nvoid cfg80211_notify_new_peer_candidate(struct net_device *dev,\n\t\tconst u8 *macaddr, const u8 *ie, u8 ie_len,\n\t\tint sig_dbm, gfp_t gfp);\n\n \n\n \nvoid wiphy_rfkill_set_hw_state_reason(struct wiphy *wiphy, bool blocked,\n\t\t\t\t      enum rfkill_hard_block_reasons reason);\n\nstatic inline void wiphy_rfkill_set_hw_state(struct wiphy *wiphy, bool blocked)\n{\n\twiphy_rfkill_set_hw_state_reason(wiphy, blocked,\n\t\t\t\t\t RFKILL_HARD_BLOCK_SIGNAL);\n}\n\n \nvoid wiphy_rfkill_start_polling(struct wiphy *wiphy);\n\n \nstatic inline void wiphy_rfkill_stop_polling(struct wiphy *wiphy)\n{\n\trfkill_pause_polling(wiphy->rfkill);\n}\n\n \n\nstruct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   int approxlen);\n\nstruct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   unsigned int portid,\n\t\t\t\t\t   int vendor_event_idx,\n\t\t\t\t\t   int approxlen, gfp_t gfp);\n\nvoid __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp);\n\n \nstatic inline struct sk_buff *\ncfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int approxlen)\n{\n\treturn __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_VENDOR,\n\t\t\t\t\t  NL80211_ATTR_VENDOR_DATA, approxlen);\n}\n\n \nint cfg80211_vendor_cmd_reply(struct sk_buff *skb);\n\n \nunsigned int cfg80211_vendor_cmd_get_sender(struct wiphy *wiphy);\n\n \nstatic inline struct sk_buff *\ncfg80211_vendor_event_alloc(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t     int approxlen, int event_idx, gfp_t gfp)\n{\n\treturn __cfg80211_alloc_event_skb(wiphy, wdev, NL80211_CMD_VENDOR,\n\t\t\t\t\t  NL80211_ATTR_VENDOR_DATA,\n\t\t\t\t\t  0, event_idx, approxlen, gfp);\n}\n\n \nstatic inline struct sk_buff *\ncfg80211_vendor_event_alloc_ucast(struct wiphy *wiphy,\n\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t  unsigned int portid, int approxlen,\n\t\t\t\t  int event_idx, gfp_t gfp)\n{\n\treturn __cfg80211_alloc_event_skb(wiphy, wdev, NL80211_CMD_VENDOR,\n\t\t\t\t\t  NL80211_ATTR_VENDOR_DATA,\n\t\t\t\t\t  portid, event_idx, approxlen, gfp);\n}\n\n \nstatic inline void cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp)\n{\n\t__cfg80211_send_event_skb(skb, gfp);\n}\n\n#ifdef CONFIG_NL80211_TESTMODE\n \n\n \nstatic inline struct sk_buff *\ncfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy, int approxlen)\n{\n\treturn __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_TESTMODE,\n\t\t\t\t\t  NL80211_ATTR_TESTDATA, approxlen);\n}\n\n \nstatic inline int cfg80211_testmode_reply(struct sk_buff *skb)\n{\n\treturn cfg80211_vendor_cmd_reply(skb);\n}\n\n \nstatic inline struct sk_buff *\ncfg80211_testmode_alloc_event_skb(struct wiphy *wiphy, int approxlen, gfp_t gfp)\n{\n\treturn __cfg80211_alloc_event_skb(wiphy, NULL, NL80211_CMD_TESTMODE,\n\t\t\t\t\t  NL80211_ATTR_TESTDATA, 0, -1,\n\t\t\t\t\t  approxlen, gfp);\n}\n\n \nstatic inline void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)\n{\n\t__cfg80211_send_event_skb(skb, gfp);\n}\n\n#define CFG80211_TESTMODE_CMD(cmd)\t.testmode_cmd = (cmd),\n#define CFG80211_TESTMODE_DUMP(cmd)\t.testmode_dump = (cmd),\n#else\n#define CFG80211_TESTMODE_CMD(cmd)\n#define CFG80211_TESTMODE_DUMP(cmd)\n#endif\n\n \nstruct cfg80211_fils_resp_params {\n\tconst u8 *kek;\n\tsize_t kek_len;\n\tbool update_erp_next_seq_num;\n\tu16 erp_next_seq_num;\n\tconst u8 *pmk;\n\tsize_t pmk_len;\n\tconst u8 *pmkid;\n};\n\n \nstruct cfg80211_connect_resp_params {\n\tint status;\n\tconst u8 *req_ie;\n\tsize_t req_ie_len;\n\tconst u8 *resp_ie;\n\tsize_t resp_ie_len;\n\tstruct cfg80211_fils_resp_params fils;\n\tenum nl80211_timeout_reason timeout_reason;\n\n\tconst u8 *ap_mld_addr;\n\tu16 valid_links;\n\tstruct {\n\t\tconst u8 *addr;\n\t\tconst u8 *bssid;\n\t\tstruct cfg80211_bss *bss;\n\t\tu16 status;\n\t} links[IEEE80211_MLD_MAX_NUM_LINKS];\n};\n\n \nvoid cfg80211_connect_done(struct net_device *dev,\n\t\t\t   struct cfg80211_connect_resp_params *params,\n\t\t\t   gfp_t gfp);\n\n \nstatic inline void\ncfg80211_connect_bss(struct net_device *dev, const u8 *bssid,\n\t\t     struct cfg80211_bss *bss, const u8 *req_ie,\n\t\t     size_t req_ie_len, const u8 *resp_ie,\n\t\t     size_t resp_ie_len, int status, gfp_t gfp,\n\t\t     enum nl80211_timeout_reason timeout_reason)\n{\n\tstruct cfg80211_connect_resp_params params;\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.status = status;\n\tparams.links[0].bssid = bssid;\n\tparams.links[0].bss = bss;\n\tparams.req_ie = req_ie;\n\tparams.req_ie_len = req_ie_len;\n\tparams.resp_ie = resp_ie;\n\tparams.resp_ie_len = resp_ie_len;\n\tparams.timeout_reason = timeout_reason;\n\n\tcfg80211_connect_done(dev, &params, gfp);\n}\n\n \nstatic inline void\ncfg80211_connect_result(struct net_device *dev, const u8 *bssid,\n\t\t\tconst u8 *req_ie, size_t req_ie_len,\n\t\t\tconst u8 *resp_ie, size_t resp_ie_len,\n\t\t\tu16 status, gfp_t gfp)\n{\n\tcfg80211_connect_bss(dev, bssid, NULL, req_ie, req_ie_len, resp_ie,\n\t\t\t     resp_ie_len, status, gfp,\n\t\t\t     NL80211_TIMEOUT_UNSPECIFIED);\n}\n\n \nstatic inline void\ncfg80211_connect_timeout(struct net_device *dev, const u8 *bssid,\n\t\t\t const u8 *req_ie, size_t req_ie_len, gfp_t gfp,\n\t\t\t enum nl80211_timeout_reason timeout_reason)\n{\n\tcfg80211_connect_bss(dev, bssid, NULL, req_ie, req_ie_len, NULL, 0, -1,\n\t\t\t     gfp, timeout_reason);\n}\n\n \nstruct cfg80211_roam_info {\n\tconst u8 *req_ie;\n\tsize_t req_ie_len;\n\tconst u8 *resp_ie;\n\tsize_t resp_ie_len;\n\tstruct cfg80211_fils_resp_params fils;\n\n\tconst u8 *ap_mld_addr;\n\tu16 valid_links;\n\tstruct {\n\t\tconst u8 *addr;\n\t\tconst u8 *bssid;\n\t\tstruct ieee80211_channel *channel;\n\t\tstruct cfg80211_bss *bss;\n\t} links[IEEE80211_MLD_MAX_NUM_LINKS];\n};\n\n \nvoid cfg80211_roamed(struct net_device *dev, struct cfg80211_roam_info *info,\n\t\t     gfp_t gfp);\n\n \nvoid cfg80211_port_authorized(struct net_device *dev, const u8 *bssid,\n\t\t\t      const u8* td_bitmap, u8 td_bitmap_len, gfp_t gfp);\n\n \nvoid cfg80211_disconnected(struct net_device *dev, u16 reason,\n\t\t\t   const u8 *ie, size_t ie_len,\n\t\t\t   bool locally_generated, gfp_t gfp);\n\n \nvoid cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,\n\t\t\t       struct ieee80211_channel *chan,\n\t\t\t       unsigned int duration, gfp_t gfp);\n\n \nvoid cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp);\n\n \nvoid cfg80211_tx_mgmt_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t      struct ieee80211_channel *chan, gfp_t gfp);\n\n \nint cfg80211_sinfo_alloc_tid_stats(struct station_info *sinfo, gfp_t gfp);\n\n \nstatic inline void cfg80211_sinfo_release_content(struct station_info *sinfo)\n{\n\tkfree(sinfo->pertid);\n}\n\n \nvoid cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,\n\t\t      struct station_info *sinfo, gfp_t gfp);\n\n \nvoid cfg80211_del_sta_sinfo(struct net_device *dev, const u8 *mac_addr,\n\t\t\t    struct station_info *sinfo, gfp_t gfp);\n\n \nstatic inline void cfg80211_del_sta(struct net_device *dev,\n\t\t\t\t    const u8 *mac_addr, gfp_t gfp)\n{\n\tcfg80211_del_sta_sinfo(dev, mac_addr, NULL, gfp);\n}\n\n \nvoid cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,\n\t\t\t  enum nl80211_connect_failed_reason reason,\n\t\t\t  gfp_t gfp);\n\n \nstruct cfg80211_rx_info {\n\tint freq;\n\tint sig_dbm;\n\tbool have_link_id;\n\tu8 link_id;\n\tconst u8 *buf;\n\tsize_t len;\n\tu32 flags;\n\tu64 rx_tstamp;\n\tu64 ack_tstamp;\n};\n\n \nbool cfg80211_rx_mgmt_ext(struct wireless_dev *wdev,\n\t\t\t  struct cfg80211_rx_info *info);\n\n \nstatic inline bool cfg80211_rx_mgmt_khz(struct wireless_dev *wdev, int freq,\n\t\t\t\t\tint sig_dbm, const u8 *buf, size_t len,\n\t\t\t\t\tu32 flags)\n{\n\tstruct cfg80211_rx_info info = {\n\t\t.freq = freq,\n\t\t.sig_dbm = sig_dbm,\n\t\t.buf = buf,\n\t\t.len = len,\n\t\t.flags = flags\n\t};\n\n\treturn cfg80211_rx_mgmt_ext(wdev, &info);\n}\n\n \nstatic inline bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq,\n\t\t\t\t    int sig_dbm, const u8 *buf, size_t len,\n\t\t\t\t    u32 flags)\n{\n\tstruct cfg80211_rx_info info = {\n\t\t.freq = MHZ_TO_KHZ(freq),\n\t\t.sig_dbm = sig_dbm,\n\t\t.buf = buf,\n\t\t.len = len,\n\t\t.flags = flags\n\t};\n\n\treturn cfg80211_rx_mgmt_ext(wdev, &info);\n}\n\n \nstruct cfg80211_tx_status {\n\tu64 cookie;\n\tu64 tx_tstamp;\n\tu64 ack_tstamp;\n\tconst u8 *buf;\n\tsize_t len;\n\tbool ack;\n};\n\n \nvoid cfg80211_mgmt_tx_status_ext(struct wireless_dev *wdev,\n\t\t\t\t struct cfg80211_tx_status *status, gfp_t gfp);\n\n \nstatic inline void cfg80211_mgmt_tx_status(struct wireless_dev *wdev,\n\t\t\t\t\t   u64 cookie, const u8 *buf,\n\t\t\t\t\t   size_t len, bool ack, gfp_t gfp)\n{\n\tstruct cfg80211_tx_status status = {\n\t\t.cookie = cookie,\n\t\t.buf = buf,\n\t\t.len = len,\n\t\t.ack = ack\n\t};\n\n\tcfg80211_mgmt_tx_status_ext(wdev, &status, gfp);\n}\n\n \nvoid cfg80211_control_port_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t     const u8 *buf, size_t len, bool ack,\n\t\t\t\t     gfp_t gfp);\n\n \nbool cfg80211_rx_control_port(struct net_device *dev, struct sk_buff *skb,\n\t\t\t      bool unencrypted, int link_id);\n\n \nvoid cfg80211_cqm_rssi_notify(struct net_device *dev,\n\t\t\t      enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t      s32 rssi_level, gfp_t gfp);\n\n \nvoid cfg80211_cqm_pktloss_notify(struct net_device *dev,\n\t\t\t\t const u8 *peer, u32 num_packets, gfp_t gfp);\n\n \nvoid cfg80211_cqm_txe_notify(struct net_device *dev, const u8 *peer,\n\t\t\t     u32 num_packets, u32 rate, u32 intvl, gfp_t gfp);\n\n \nvoid cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp);\n\n \nvoid __cfg80211_radar_event(struct wiphy *wiphy,\n\t\t\t    struct cfg80211_chan_def *chandef,\n\t\t\t    bool offchan, gfp_t gfp);\n\nstatic inline void\ncfg80211_radar_event(struct wiphy *wiphy,\n\t\t     struct cfg80211_chan_def *chandef,\n\t\t     gfp_t gfp)\n{\n\t__cfg80211_radar_event(wiphy, chandef, false, gfp);\n}\n\nstatic inline void\ncfg80211_background_radar_event(struct wiphy *wiphy,\n\t\t\t\tstruct cfg80211_chan_def *chandef,\n\t\t\t\tgfp_t gfp)\n{\n\t__cfg80211_radar_event(wiphy, chandef, true, gfp);\n}\n\n \nvoid cfg80211_sta_opmode_change_notify(struct net_device *dev, const u8 *mac,\n\t\t\t\t       struct sta_opmode_info *sta_opmode,\n\t\t\t\t       gfp_t gfp);\n\n \nvoid cfg80211_cac_event(struct net_device *netdev,\n\t\t\tconst struct cfg80211_chan_def *chandef,\n\t\t\tenum nl80211_radar_event event, gfp_t gfp);\n\n \nvoid cfg80211_background_cac_abort(struct wiphy *wiphy);\n\n \nvoid cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,\n\t\t\t       const u8 *replay_ctr, gfp_t gfp);\n\n \nvoid cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,\n\t\t\t\t     const u8 *bssid, bool preauth, gfp_t gfp);\n\n \nbool cfg80211_rx_spurious_frame(struct net_device *dev,\n\t\t\t\tconst u8 *addr, gfp_t gfp);\n\n \nbool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,\n\t\t\t\t\tconst u8 *addr, gfp_t gfp);\n\n \nvoid cfg80211_probe_status(struct net_device *dev, const u8 *addr,\n\t\t\t   u64 cookie, bool acked, s32 ack_signal,\n\t\t\t   bool is_valid_ack_signal, gfp_t gfp);\n\n \nvoid cfg80211_report_obss_beacon_khz(struct wiphy *wiphy, const u8 *frame,\n\t\t\t\t     size_t len, int freq, int sig_dbm);\n\n \nstatic inline void cfg80211_report_obss_beacon(struct wiphy *wiphy,\n\t\t\t\t\t       const u8 *frame, size_t len,\n\t\t\t\t\t       int freq, int sig_dbm)\n{\n\tcfg80211_report_obss_beacon_khz(wiphy, frame, len, MHZ_TO_KHZ(freq),\n\t\t\t\t\tsig_dbm);\n}\n\n \nbool cfg80211_reg_can_beacon(struct wiphy *wiphy,\n\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t     enum nl80211_iftype iftype);\n\n \nbool cfg80211_reg_can_beacon_relax(struct wiphy *wiphy,\n\t\t\t\t   struct cfg80211_chan_def *chandef,\n\t\t\t\t   enum nl80211_iftype iftype);\n\n \nvoid cfg80211_ch_switch_notify(struct net_device *dev,\n\t\t\t       struct cfg80211_chan_def *chandef,\n\t\t\t       unsigned int link_id, u16 punct_bitmap);\n\n \nvoid cfg80211_ch_switch_started_notify(struct net_device *dev,\n\t\t\t\t       struct cfg80211_chan_def *chandef,\n\t\t\t\t       unsigned int link_id, u8 count,\n\t\t\t\t       bool quiet, u16 punct_bitmap);\n\n \nbool ieee80211_operating_class_to_band(u8 operating_class,\n\t\t\t\t       enum nl80211_band *band);\n\n \nbool ieee80211_chandef_to_operating_class(struct cfg80211_chan_def *chandef,\n\t\t\t\t\t  u8 *op_class);\n\n \nstatic inline u32\nieee80211_chandef_to_khz(const struct cfg80211_chan_def *chandef)\n{\n\treturn MHZ_TO_KHZ(chandef->center_freq1) + chandef->freq1_offset;\n}\n\n \nvoid cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,\n\t\t\t\tenum nl80211_tdls_operation oper,\n\t\t\t\tu16 reason_code, gfp_t gfp);\n\n \nu32 cfg80211_calculate_bitrate(struct rate_info *rate);\n\n \nvoid cfg80211_unregister_wdev(struct wireless_dev *wdev);\n\n \nint cfg80211_register_netdevice(struct net_device *dev);\n\n \nstatic inline void cfg80211_unregister_netdevice(struct net_device *dev)\n{\n#if IS_ENABLED(CONFIG_CFG80211)\n\tcfg80211_unregister_wdev(dev->ieee80211_ptr);\n#endif\n}\n\n \nstruct cfg80211_ft_event_params {\n\tconst u8 *ies;\n\tsize_t ies_len;\n\tconst u8 *target_ap;\n\tconst u8 *ric_ies;\n\tsize_t ric_ies_len;\n};\n\n \nvoid cfg80211_ft_event(struct net_device *netdev,\n\t\t       struct cfg80211_ft_event_params *ft_event);\n\n \nint cfg80211_get_p2p_attr(const u8 *ies, unsigned int len,\n\t\t\t  enum ieee80211_p2p_attr_id attr,\n\t\t\t  u8 *buf, unsigned int bufsize);\n\n \nsize_t ieee80211_ie_split_ric(const u8 *ies, size_t ielen,\n\t\t\t      const u8 *ids, int n_ids,\n\t\t\t      const u8 *after_ric, int n_after_ric,\n\t\t\t      size_t offset);\n\n \nstatic inline size_t ieee80211_ie_split(const u8 *ies, size_t ielen,\n\t\t\t\t\tconst u8 *ids, int n_ids, size_t offset)\n{\n\treturn ieee80211_ie_split_ric(ies, ielen, ids, n_ids, NULL, 0, offset);\n}\n\n \nvoid cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,\n\t\t\t\t   struct cfg80211_wowlan_wakeup *wakeup,\n\t\t\t\t   gfp_t gfp);\n\n \nvoid cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp);\n\n \nunsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy);\n\n \nint cfg80211_check_combinations(struct wiphy *wiphy,\n\t\t\t\tstruct iface_combination_params *params);\n\n \nint cfg80211_iter_combinations(struct wiphy *wiphy,\n\t\t\t       struct iface_combination_params *params,\n\t\t\t       void (*iter)(const struct ieee80211_iface_combination *c,\n\t\t\t\t\t    void *data),\n\t\t\t       void *data);\n\n \nvoid cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t gfp_t gfp);\n\n \nvoid cfg80211_shutdown_all_interfaces(struct wiphy *wiphy);\n\n \nstatic inline void wiphy_ext_feature_set(struct wiphy *wiphy,\n\t\t\t\t\t enum nl80211_ext_feature_index ftidx)\n{\n\tu8 *ft_byte;\n\n\tft_byte = &wiphy->ext_features[ftidx / 8];\n\t*ft_byte |= BIT(ftidx % 8);\n}\n\n \nstatic inline bool\nwiphy_ext_feature_isset(struct wiphy *wiphy,\n\t\t\tenum nl80211_ext_feature_index ftidx)\n{\n\tu8 ft_byte;\n\n\tft_byte = wiphy->ext_features[ftidx / 8];\n\treturn (ft_byte & BIT(ftidx % 8)) != 0;\n}\n\n \nvoid cfg80211_free_nan_func(struct cfg80211_nan_func *f);\n\n \nstruct cfg80211_nan_match_params {\n\tenum nl80211_nan_function_type type;\n\tu8 inst_id;\n\tu8 peer_inst_id;\n\tconst u8 *addr;\n\tu8 info_len;\n\tconst u8 *info;\n\tu64 cookie;\n};\n\n \nvoid cfg80211_nan_match(struct wireless_dev *wdev,\n\t\t\tstruct cfg80211_nan_match_params *match, gfp_t gfp);\n\n \nvoid cfg80211_nan_func_terminated(struct wireless_dev *wdev,\n\t\t\t\t  u8 inst_id,\n\t\t\t\t  enum nl80211_nan_func_term_reason reason,\n\t\t\t\t  u64 cookie, gfp_t gfp);\n\n \nvoid cfg80211_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info);\n\n \nint cfg80211_external_auth_request(struct net_device *netdev,\n\t\t\t\t   struct cfg80211_external_auth_params *params,\n\t\t\t\t   gfp_t gfp);\n\n \nvoid cfg80211_pmsr_report(struct wireless_dev *wdev,\n\t\t\t  struct cfg80211_pmsr_request *req,\n\t\t\t  struct cfg80211_pmsr_result *result,\n\t\t\t  gfp_t gfp);\n\n \nvoid cfg80211_pmsr_complete(struct wireless_dev *wdev,\n\t\t\t    struct cfg80211_pmsr_request *req,\n\t\t\t    gfp_t gfp);\n\n \nbool cfg80211_iftype_allowed(struct wiphy *wiphy, enum nl80211_iftype iftype,\n\t\t\t     bool is_4addr, u8 check_swif);\n\n\n \nvoid cfg80211_assoc_comeback(struct net_device *netdev,\n\t\t\t     const u8 *ap_addr, u32 timeout);\n\n \n\n \n\n#define wiphy_printk(level, wiphy, format, args...)\t\t\\\n\tdev_printk(level, &(wiphy)->dev, format, ##args)\n#define wiphy_emerg(wiphy, format, args...)\t\t\t\\\n\tdev_emerg(&(wiphy)->dev, format, ##args)\n#define wiphy_alert(wiphy, format, args...)\t\t\t\\\n\tdev_alert(&(wiphy)->dev, format, ##args)\n#define wiphy_crit(wiphy, format, args...)\t\t\t\\\n\tdev_crit(&(wiphy)->dev, format, ##args)\n#define wiphy_err(wiphy, format, args...)\t\t\t\\\n\tdev_err(&(wiphy)->dev, format, ##args)\n#define wiphy_warn(wiphy, format, args...)\t\t\t\\\n\tdev_warn(&(wiphy)->dev, format, ##args)\n#define wiphy_notice(wiphy, format, args...)\t\t\t\\\n\tdev_notice(&(wiphy)->dev, format, ##args)\n#define wiphy_info(wiphy, format, args...)\t\t\t\\\n\tdev_info(&(wiphy)->dev, format, ##args)\n#define wiphy_info_once(wiphy, format, args...)\t\t\t\\\n\tdev_info_once(&(wiphy)->dev, format, ##args)\n\n#define wiphy_err_ratelimited(wiphy, format, args...)\t\t\\\n\tdev_err_ratelimited(&(wiphy)->dev, format, ##args)\n#define wiphy_warn_ratelimited(wiphy, format, args...)\t\t\\\n\tdev_warn_ratelimited(&(wiphy)->dev, format, ##args)\n\n#define wiphy_debug(wiphy, format, args...)\t\t\t\\\n\twiphy_printk(KERN_DEBUG, wiphy, format, ##args)\n\n#define wiphy_dbg(wiphy, format, args...)\t\t\t\\\n\tdev_dbg(&(wiphy)->dev, format, ##args)\n\n#if defined(VERBOSE_DEBUG)\n#define wiphy_vdbg\twiphy_dbg\n#else\n#define wiphy_vdbg(wiphy, format, args...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\twiphy_printk(KERN_DEBUG, wiphy, format, ##args);\t\\\n\t0;\t\t\t\t\t\t\t\t\\\n})\n#endif\n\n \n#define wiphy_WARN(wiphy, format, args...)\t\t\t\\\n\tWARN(1, \"wiphy: %s\\n\" format, wiphy_name(wiphy), ##args);\n\n \nvoid cfg80211_update_owe_info_event(struct net_device *netdev,\n\t\t\t\t    struct cfg80211_update_owe_info *owe_info,\n\t\t\t\t    gfp_t gfp);\n\n \nvoid cfg80211_bss_flush(struct wiphy *wiphy);\n\n \nint cfg80211_bss_color_notify(struct net_device *dev,\n\t\t\t      enum nl80211_commands cmd, u8 count,\n\t\t\t      u64 color_bitmap);\n\n \nstatic inline int cfg80211_obss_color_collision_notify(struct net_device *dev,\n\t\t\t\t\t\t       u64 color_bitmap)\n{\n\treturn cfg80211_bss_color_notify(dev, NL80211_CMD_OBSS_COLOR_COLLISION,\n\t\t\t\t\t 0, color_bitmap);\n}\n\n \nstatic inline int cfg80211_color_change_started_notify(struct net_device *dev,\n\t\t\t\t\t\t       u8 count)\n{\n\treturn cfg80211_bss_color_notify(dev, NL80211_CMD_COLOR_CHANGE_STARTED,\n\t\t\t\t\t count, 0);\n}\n\n \nstatic inline int cfg80211_color_change_aborted_notify(struct net_device *dev)\n{\n\treturn cfg80211_bss_color_notify(dev, NL80211_CMD_COLOR_CHANGE_ABORTED,\n\t\t\t\t\t 0, 0);\n}\n\n \nstatic inline int cfg80211_color_change_notify(struct net_device *dev)\n{\n\treturn cfg80211_bss_color_notify(dev,\n\t\t\t\t\t NL80211_CMD_COLOR_CHANGE_COMPLETED,\n\t\t\t\t\t 0, 0);\n}\n\n \nbool cfg80211_valid_disable_subchannel_bitmap(u16 *bitmap,\n\t\t\t\t\t      const struct cfg80211_chan_def *chandef);\n\n \nvoid cfg80211_links_removed(struct net_device *dev, u16 link_mask);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}