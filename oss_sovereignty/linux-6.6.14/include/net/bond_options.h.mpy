{
  "module_name": "bond_options.h",
  "hash_id": "50f8edc51cecd9d8b987111a5579a44a8cbd59713cecf138830d965a4e0073ef",
  "original_prompt": "Ingested from linux-6.6.14/include/net/bond_options.h",
  "human_readable_source": " \n \n\n#ifndef _NET_BOND_OPTIONS_H\n#define _NET_BOND_OPTIONS_H\n\n#include <linux/bits.h>\n#include <linux/limits.h>\n#include <linux/types.h>\n#include <linux/string.h>\n\nstruct netlink_ext_ack;\nstruct nlattr;\n\n#define BOND_OPT_MAX_NAMELEN 32\n#define BOND_OPT_VALID(opt) ((opt) < BOND_OPT_LAST)\n#define BOND_MODE_ALL_EX(x) (~(x))\n\n \nenum {\n\tBOND_OPTFLAG_NOSLAVES\t= BIT(0),\n\tBOND_OPTFLAG_IFDOWN\t= BIT(1),\n\tBOND_OPTFLAG_RAWVAL\t= BIT(2)\n};\n\n \nenum {\n\tBOND_VALFLAG_DEFAULT\t= BIT(0),\n\tBOND_VALFLAG_MIN\t= BIT(1),\n\tBOND_VALFLAG_MAX\t= BIT(2)\n};\n\n \nenum {\n\tBOND_OPT_MODE,\n\tBOND_OPT_PACKETS_PER_SLAVE,\n\tBOND_OPT_XMIT_HASH,\n\tBOND_OPT_ARP_VALIDATE,\n\tBOND_OPT_ARP_ALL_TARGETS,\n\tBOND_OPT_FAIL_OVER_MAC,\n\tBOND_OPT_ARP_INTERVAL,\n\tBOND_OPT_ARP_TARGETS,\n\tBOND_OPT_DOWNDELAY,\n\tBOND_OPT_UPDELAY,\n\tBOND_OPT_LACP_RATE,\n\tBOND_OPT_MINLINKS,\n\tBOND_OPT_AD_SELECT,\n\tBOND_OPT_NUM_PEER_NOTIF,\n\tBOND_OPT_MIIMON,\n\tBOND_OPT_PRIMARY,\n\tBOND_OPT_PRIMARY_RESELECT,\n\tBOND_OPT_USE_CARRIER,\n\tBOND_OPT_ACTIVE_SLAVE,\n\tBOND_OPT_QUEUE_ID,\n\tBOND_OPT_ALL_SLAVES_ACTIVE,\n\tBOND_OPT_RESEND_IGMP,\n\tBOND_OPT_LP_INTERVAL,\n\tBOND_OPT_SLAVES,\n\tBOND_OPT_TLB_DYNAMIC_LB,\n\tBOND_OPT_AD_ACTOR_SYS_PRIO,\n\tBOND_OPT_AD_ACTOR_SYSTEM,\n\tBOND_OPT_AD_USER_PORT_KEY,\n\tBOND_OPT_NUM_PEER_NOTIF_ALIAS,\n\tBOND_OPT_PEER_NOTIF_DELAY,\n\tBOND_OPT_LACP_ACTIVE,\n\tBOND_OPT_MISSED_MAX,\n\tBOND_OPT_NS_TARGETS,\n\tBOND_OPT_PRIO,\n\tBOND_OPT_LAST\n};\n\n \n\n#define BOND_OPT_EXTRA_MAXLEN 16\nstruct bond_opt_value {\n\tchar *string;\n\tu64 value;\n\tu32 flags;\n\tunion {\n\t\tchar extra[BOND_OPT_EXTRA_MAXLEN];\n\t\tstruct net_device *slave_dev;\n\t};\n};\n\nstruct bonding;\n\nstruct bond_option {\n\tint id;\n\tconst char *name;\n\tconst char *desc;\n\tu32 flags;\n\n\t \n\tunsigned long unsuppmodes;\n\t \n\tconst struct bond_opt_value *values;\n\n\tint (*set)(struct bonding *bond, const struct bond_opt_value *val);\n};\n\nint __bond_opt_set(struct bonding *bond, unsigned int option,\n\t\t   struct bond_opt_value *val,\n\t\t   struct nlattr *bad_attr, struct netlink_ext_ack *extack);\nint __bond_opt_set_notify(struct bonding *bond, unsigned int option,\n\t\t\t  struct bond_opt_value *val);\nint bond_opt_tryset_rtnl(struct bonding *bond, unsigned int option, char *buf);\n\nconst struct bond_opt_value *bond_opt_parse(const struct bond_option *opt,\n\t\t\t\t\t    struct bond_opt_value *val);\nconst struct bond_option *bond_opt_get(unsigned int option);\nconst struct bond_option *bond_opt_get_by_name(const char *name);\nconst struct bond_opt_value *bond_opt_get_val(unsigned int option, u64 val);\n\n \nstatic inline void __bond_opt_init(struct bond_opt_value *optval,\n\t\t\t\t   char *string, u64 value,\n\t\t\t\t   void *extra, size_t extra_len)\n{\n\tmemset(optval, 0, sizeof(*optval));\n\toptval->value = ULLONG_MAX;\n\tif (value != ULLONG_MAX)\n\t\toptval->value = value;\n\telse if (string)\n\t\toptval->string = string;\n\n\tif (extra && extra_len <= BOND_OPT_EXTRA_MAXLEN)\n\t\tmemcpy(optval->extra, extra, extra_len);\n}\n#define bond_opt_initval(optval, value) __bond_opt_init(optval, NULL, value, NULL, 0)\n#define bond_opt_initstr(optval, str) __bond_opt_init(optval, str, ULLONG_MAX, NULL, 0)\n#define bond_opt_initextra(optval, extra, extra_len) \\\n\t__bond_opt_init(optval, NULL, ULLONG_MAX, extra, extra_len)\n#define bond_opt_slave_initval(optval, slave_dev, value) \\\n\t__bond_opt_init(optval, NULL, value, slave_dev, sizeof(struct net_device *))\n\nvoid bond_option_arp_ip_targets_clear(struct bonding *bond);\n#if IS_ENABLED(CONFIG_IPV6)\nvoid bond_option_ns_ip6_targets_clear(struct bonding *bond);\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}