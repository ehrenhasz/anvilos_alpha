{
  "module_name": "tcx.h",
  "hash_id": "1b0104eebdb8275161ddf29bf8b080b854fb20d26dfee6ffd2101775a806ddb0",
  "original_prompt": "Ingested from linux-6.6.14/include/net/tcx.h",
  "human_readable_source": " \n \n#ifndef __NET_TCX_H\n#define __NET_TCX_H\n\n#include <linux/bpf.h>\n#include <linux/bpf_mprog.h>\n\n#include <net/sch_generic.h>\n\nstruct mini_Qdisc;\n\nstruct tcx_entry {\n\tstruct mini_Qdisc __rcu *miniq;\n\tstruct bpf_mprog_bundle bundle;\n\tbool miniq_active;\n\tstruct rcu_head rcu;\n};\n\nstruct tcx_link {\n\tstruct bpf_link link;\n\tstruct net_device *dev;\n\tu32 location;\n};\n\nstatic inline void tcx_set_ingress(struct sk_buff *skb, bool ingress)\n{\n#ifdef CONFIG_NET_XGRESS\n\tskb->tc_at_ingress = ingress;\n#endif\n}\n\n#ifdef CONFIG_NET_XGRESS\nstatic inline struct tcx_entry *tcx_entry(struct bpf_mprog_entry *entry)\n{\n\tstruct bpf_mprog_bundle *bundle = entry->parent;\n\n\treturn container_of(bundle, struct tcx_entry, bundle);\n}\n\nstatic inline struct tcx_link *tcx_link(struct bpf_link *link)\n{\n\treturn container_of(link, struct tcx_link, link);\n}\n\nstatic inline const struct tcx_link *tcx_link_const(const struct bpf_link *link)\n{\n\treturn tcx_link((struct bpf_link *)link);\n}\n\nvoid tcx_inc(void);\nvoid tcx_dec(void);\n\nstatic inline void tcx_entry_sync(void)\n{\n\t \n\tsynchronize_rcu();\n}\n\nstatic inline void\ntcx_entry_update(struct net_device *dev, struct bpf_mprog_entry *entry,\n\t\t bool ingress)\n{\n\tASSERT_RTNL();\n\tif (ingress)\n\t\trcu_assign_pointer(dev->tcx_ingress, entry);\n\telse\n\t\trcu_assign_pointer(dev->tcx_egress, entry);\n}\n\nstatic inline struct bpf_mprog_entry *\ntcx_entry_fetch(struct net_device *dev, bool ingress)\n{\n\tASSERT_RTNL();\n\tif (ingress)\n\t\treturn rcu_dereference_rtnl(dev->tcx_ingress);\n\telse\n\t\treturn rcu_dereference_rtnl(dev->tcx_egress);\n}\n\nstatic inline struct bpf_mprog_entry *tcx_entry_create(void)\n{\n\tstruct tcx_entry *tcx = kzalloc(sizeof(*tcx), GFP_KERNEL);\n\n\tif (tcx) {\n\t\tbpf_mprog_bundle_init(&tcx->bundle);\n\t\treturn &tcx->bundle.a;\n\t}\n\treturn NULL;\n}\n\nstatic inline void tcx_entry_free(struct bpf_mprog_entry *entry)\n{\n\tkfree_rcu(tcx_entry(entry), rcu);\n}\n\nstatic inline struct bpf_mprog_entry *\ntcx_entry_fetch_or_create(struct net_device *dev, bool ingress, bool *created)\n{\n\tstruct bpf_mprog_entry *entry = tcx_entry_fetch(dev, ingress);\n\n\t*created = false;\n\tif (!entry) {\n\t\tentry = tcx_entry_create();\n\t\tif (!entry)\n\t\t\treturn NULL;\n\t\t*created = true;\n\t}\n\treturn entry;\n}\n\nstatic inline void tcx_skeys_inc(bool ingress)\n{\n\ttcx_inc();\n\tif (ingress)\n\t\tnet_inc_ingress_queue();\n\telse\n\t\tnet_inc_egress_queue();\n}\n\nstatic inline void tcx_skeys_dec(bool ingress)\n{\n\tif (ingress)\n\t\tnet_dec_ingress_queue();\n\telse\n\t\tnet_dec_egress_queue();\n\ttcx_dec();\n}\n\nstatic inline void tcx_miniq_set_active(struct bpf_mprog_entry *entry,\n\t\t\t\t\tconst bool active)\n{\n\tASSERT_RTNL();\n\ttcx_entry(entry)->miniq_active = active;\n}\n\nstatic inline bool tcx_entry_is_active(struct bpf_mprog_entry *entry)\n{\n\tASSERT_RTNL();\n\treturn bpf_mprog_total(entry) || tcx_entry(entry)->miniq_active;\n}\n\nstatic inline enum tcx_action_base tcx_action_code(struct sk_buff *skb,\n\t\t\t\t\t\t   int code)\n{\n\tswitch (code) {\n\tcase TCX_PASS:\n\t\tskb->tc_index = qdisc_skb_cb(skb)->tc_classid;\n\t\tfallthrough;\n\tcase TCX_DROP:\n\tcase TCX_REDIRECT:\n\t\treturn code;\n\tcase TCX_NEXT:\n\tdefault:\n\t\treturn TCX_NEXT;\n\t}\n}\n#endif  \n\n#if defined(CONFIG_NET_XGRESS) && defined(CONFIG_BPF_SYSCALL)\nint tcx_prog_attach(const union bpf_attr *attr, struct bpf_prog *prog);\nint tcx_link_attach(const union bpf_attr *attr, struct bpf_prog *prog);\nint tcx_prog_detach(const union bpf_attr *attr, struct bpf_prog *prog);\nvoid tcx_uninstall(struct net_device *dev, bool ingress);\n\nint tcx_prog_query(const union bpf_attr *attr,\n\t\t   union bpf_attr __user *uattr);\n\nstatic inline void dev_tcx_uninstall(struct net_device *dev)\n{\n\tASSERT_RTNL();\n\ttcx_uninstall(dev, true);\n\ttcx_uninstall(dev, false);\n}\n#else\nstatic inline int tcx_prog_attach(const union bpf_attr *attr,\n\t\t\t\t  struct bpf_prog *prog)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int tcx_link_attach(const union bpf_attr *attr,\n\t\t\t\t  struct bpf_prog *prog)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int tcx_prog_detach(const union bpf_attr *attr,\n\t\t\t\t  struct bpf_prog *prog)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int tcx_prog_query(const union bpf_attr *attr,\n\t\t\t\t union bpf_attr __user *uattr)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void dev_tcx_uninstall(struct net_device *dev)\n{\n}\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}