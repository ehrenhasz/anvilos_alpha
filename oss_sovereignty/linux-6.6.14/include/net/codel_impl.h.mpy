{
  "module_name": "codel_impl.h",
  "hash_id": "65ccf11a70bf7beb9e567d860ac726e4f92ebb35b2b280fe3b4f6352c7f5cf43",
  "original_prompt": "Ingested from linux-6.6.14/include/net/codel_impl.h",
  "human_readable_source": "#ifndef __NET_SCHED_CODEL_IMPL_H\n#define __NET_SCHED_CODEL_IMPL_H\n\n \n\n \n\n#include <net/inet_ecn.h>\n\nstatic void codel_params_init(struct codel_params *params)\n{\n\tparams->interval = MS2TIME(100);\n\tparams->target = MS2TIME(5);\n\tparams->ce_threshold = CODEL_DISABLED_THRESHOLD;\n\tparams->ce_threshold_mask = 0;\n\tparams->ce_threshold_selector = 0;\n\tparams->ecn = false;\n}\n\nstatic void codel_vars_init(struct codel_vars *vars)\n{\n\tmemset(vars, 0, sizeof(*vars));\n}\n\nstatic void codel_stats_init(struct codel_stats *stats)\n{\n\tstats->maxpacket = 0;\n}\n\n \nstatic void codel_Newton_step(struct codel_vars *vars)\n{\n\tu32 invsqrt = ((u32)vars->rec_inv_sqrt) << REC_INV_SQRT_SHIFT;\n\tu32 invsqrt2 = ((u64)invsqrt * invsqrt) >> 32;\n\tu64 val = (3LL << 32) - ((u64)vars->count * invsqrt2);\n\n\tval >>= 2;  \n\tval = (val * invsqrt) >> (32 - 2 + 1);\n\n\tvars->rec_inv_sqrt = val >> REC_INV_SQRT_SHIFT;\n}\n\n \nstatic codel_time_t codel_control_law(codel_time_t t,\n\t\t\t\t      codel_time_t interval,\n\t\t\t\t      u32 rec_inv_sqrt)\n{\n\treturn t + reciprocal_scale(interval, rec_inv_sqrt << REC_INV_SQRT_SHIFT);\n}\n\nstatic bool codel_should_drop(const struct sk_buff *skb,\n\t\t\t      void *ctx,\n\t\t\t      struct codel_vars *vars,\n\t\t\t      struct codel_params *params,\n\t\t\t      struct codel_stats *stats,\n\t\t\t      codel_skb_len_t skb_len_func,\n\t\t\t      codel_skb_time_t skb_time_func,\n\t\t\t      u32 *backlog,\n\t\t\t      codel_time_t now)\n{\n\tbool ok_to_drop;\n\tu32 skb_len;\n\n\tif (!skb) {\n\t\tvars->first_above_time = 0;\n\t\treturn false;\n\t}\n\n\tskb_len = skb_len_func(skb);\n\tvars->ldelay = now - skb_time_func(skb);\n\n\tif (unlikely(skb_len > stats->maxpacket))\n\t\tstats->maxpacket = skb_len;\n\n\tif (codel_time_before(vars->ldelay, params->target) ||\n\t    *backlog <= params->mtu) {\n\t\t \n\t\tvars->first_above_time = 0;\n\t\treturn false;\n\t}\n\tok_to_drop = false;\n\tif (vars->first_above_time == 0) {\n\t\t \n\t\tvars->first_above_time = now + params->interval;\n\t} else if (codel_time_after(now, vars->first_above_time)) {\n\t\tok_to_drop = true;\n\t}\n\treturn ok_to_drop;\n}\n\nstatic struct sk_buff *codel_dequeue(void *ctx,\n\t\t\t\t     u32 *backlog,\n\t\t\t\t     struct codel_params *params,\n\t\t\t\t     struct codel_vars *vars,\n\t\t\t\t     struct codel_stats *stats,\n\t\t\t\t     codel_skb_len_t skb_len_func,\n\t\t\t\t     codel_skb_time_t skb_time_func,\n\t\t\t\t     codel_skb_drop_t drop_func,\n\t\t\t\t     codel_skb_dequeue_t dequeue_func)\n{\n\tstruct sk_buff *skb = dequeue_func(vars, ctx);\n\tcodel_time_t now;\n\tbool drop;\n\n\tif (!skb) {\n\t\tvars->dropping = false;\n\t\treturn skb;\n\t}\n\tnow = codel_get_time();\n\tdrop = codel_should_drop(skb, ctx, vars, params, stats,\n\t\t\t\t skb_len_func, skb_time_func, backlog, now);\n\tif (vars->dropping) {\n\t\tif (!drop) {\n\t\t\t \n\t\t\tvars->dropping = false;\n\t\t} else if (codel_time_after_eq(now, vars->drop_next)) {\n\t\t\t \n\t\t\twhile (vars->dropping &&\n\t\t\t       codel_time_after_eq(now, vars->drop_next)) {\n\t\t\t\tvars->count++;  \n\t\t\t\tcodel_Newton_step(vars);\n\t\t\t\tif (params->ecn && INET_ECN_set_ce(skb)) {\n\t\t\t\t\tstats->ecn_mark++;\n\t\t\t\t\tvars->drop_next =\n\t\t\t\t\t\tcodel_control_law(vars->drop_next,\n\t\t\t\t\t\t\t\t  params->interval,\n\t\t\t\t\t\t\t\t  vars->rec_inv_sqrt);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tstats->drop_len += skb_len_func(skb);\n\t\t\t\tdrop_func(skb, ctx);\n\t\t\t\tstats->drop_count++;\n\t\t\t\tskb = dequeue_func(vars, ctx);\n\t\t\t\tif (!codel_should_drop(skb, ctx,\n\t\t\t\t\t\t       vars, params, stats,\n\t\t\t\t\t\t       skb_len_func,\n\t\t\t\t\t\t       skb_time_func,\n\t\t\t\t\t\t       backlog, now)) {\n\t\t\t\t\t \n\t\t\t\t\tvars->dropping = false;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tvars->drop_next =\n\t\t\t\t\t\tcodel_control_law(vars->drop_next,\n\t\t\t\t\t\t\t\t  params->interval,\n\t\t\t\t\t\t\t\t  vars->rec_inv_sqrt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (drop) {\n\t\tu32 delta;\n\n\t\tif (params->ecn && INET_ECN_set_ce(skb)) {\n\t\t\tstats->ecn_mark++;\n\t\t} else {\n\t\t\tstats->drop_len += skb_len_func(skb);\n\t\t\tdrop_func(skb, ctx);\n\t\t\tstats->drop_count++;\n\n\t\t\tskb = dequeue_func(vars, ctx);\n\t\t\tdrop = codel_should_drop(skb, ctx, vars, params,\n\t\t\t\t\t\t stats, skb_len_func,\n\t\t\t\t\t\t skb_time_func, backlog, now);\n\t\t}\n\t\tvars->dropping = true;\n\t\t \n\t\tdelta = vars->count - vars->lastcount;\n\t\tif (delta > 1 &&\n\t\t    codel_time_before(now - vars->drop_next,\n\t\t\t\t      16 * params->interval)) {\n\t\t\tvars->count = delta;\n\t\t\t \n\t\t\tcodel_Newton_step(vars);\n\t\t} else {\n\t\t\tvars->count = 1;\n\t\t\tvars->rec_inv_sqrt = ~0U >> REC_INV_SQRT_SHIFT;\n\t\t}\n\t\tvars->lastcount = vars->count;\n\t\tvars->drop_next = codel_control_law(now, params->interval,\n\t\t\t\t\t\t    vars->rec_inv_sqrt);\n\t}\nend:\n\tif (skb && codel_time_after(vars->ldelay, params->ce_threshold)) {\n\t\tbool set_ce = true;\n\n\t\tif (params->ce_threshold_mask) {\n\t\t\tint dsfield = skb_get_dsfield(skb);\n\n\t\t\tset_ce = (dsfield >= 0 &&\n\t\t\t\t  (((u8)dsfield & params->ce_threshold_mask) ==\n\t\t\t\t   params->ce_threshold_selector));\n\t\t}\n\t\tif (set_ce && INET_ECN_set_ce(skb))\n\t\t\tstats->ce_mark++;\n\t}\n\treturn skb;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}