{
  "module_name": "af_iucv.h",
  "hash_id": "3d6289396acd1a5f090852e71f9a1994e104cef27e8cc6d6fa1db1d010e5f464",
  "original_prompt": "Ingested from linux-6.6.14/include/net/iucv/af_iucv.h",
  "human_readable_source": " \n \n\n#ifndef __AFIUCV_H\n#define __AFIUCV_H\n\n#include <asm/types.h>\n#include <asm/byteorder.h>\n#include <linux/list.h>\n#include <linux/poll.h>\n#include <linux/socket.h>\n#include <net/iucv/iucv.h>\n\n#ifndef AF_IUCV\n#define AF_IUCV\t\t32\n#define PF_IUCV\t\tAF_IUCV\n#endif\n\n \nenum {\n\tIUCV_CONNECTED = 1,\n\tIUCV_OPEN,\n\tIUCV_BOUND,\n\tIUCV_LISTEN,\n\tIUCV_DISCONN,\n\tIUCV_CLOSING,\n\tIUCV_CLOSED\n};\n\n#define IUCV_QUEUELEN_DEFAULT\t65535\n#define IUCV_HIPER_MSGLIM_DEFAULT\t128\n#define IUCV_CONN_TIMEOUT\t(HZ * 40)\n#define IUCV_DISCONN_TIMEOUT\t(HZ * 2)\n#define IUCV_CONN_IDLE_TIMEOUT\t(HZ * 60)\n#define IUCV_BUFSIZE_DEFAULT\t32768\n\n \nstruct sockaddr_iucv {\n\tsa_family_t\tsiucv_family;\n\tunsigned short\tsiucv_port;\t\t \n\tunsigned int\tsiucv_addr;\t\t \n\tchar\t\tsiucv_nodeid[8];\t \n\tchar\t\tsiucv_user_id[8];\t \n\tchar\t\tsiucv_name[8];\t\t \n};\n\n\n \nstruct sock_msg_q {\n\tstruct iucv_path\t*path;\n\tstruct iucv_message\tmsg;\n\tstruct list_head\tlist;\n\tspinlock_t\t\tlock;\n};\n\n#define AF_IUCV_FLAG_ACK 0x1\n#define AF_IUCV_FLAG_SYN 0x2\n#define AF_IUCV_FLAG_FIN 0x4\n#define AF_IUCV_FLAG_WIN 0x8\n#define AF_IUCV_FLAG_SHT 0x10\n\nstruct af_iucv_trans_hdr {\n\tu16 magic;\n\tu8 version;\n\tu8 flags;\n\tu16 window;\n\tchar destNodeID[8];\n\tchar destUserID[8];\n\tchar destAppName[16];\n\tchar srcNodeID[8];\n\tchar srcUserID[8];\n\tchar srcAppName[16];              \n\tstruct iucv_message iucv_hdr;     \n\tu8 pad;                           \n} __packed;\n\nstatic inline struct af_iucv_trans_hdr *iucv_trans_hdr(struct sk_buff *skb)\n{\n\treturn (struct af_iucv_trans_hdr *)skb_network_header(skb);\n}\n\nenum iucv_tx_notify {\n\t \n\tTX_NOTIFY_OK = 0,\n\t \n\tTX_NOTIFY_UNREACHABLE = 1,\n\t \n\tTX_NOTIFY_TPQFULL = 2,\n\t \n\tTX_NOTIFY_GENERALERROR = 3,\n\t \n\tTX_NOTIFY_PENDING = 4,\n\t \n\tTX_NOTIFY_DELAYED_OK = 5,\n\t \n\tTX_NOTIFY_DELAYED_UNREACHABLE = 6,\n\t \n\tTX_NOTIFY_DELAYED_GENERALERROR = 7,\n};\n\n#define iucv_sk(__sk) ((struct iucv_sock *) __sk)\n\n#define AF_IUCV_TRANS_IUCV 0\n#define AF_IUCV_TRANS_HIPER 1\n\nstruct iucv_sock {\n\tstruct sock\t\tsk;\n\tstruct_group(init,\n\t\tchar\t\tsrc_user_id[8];\n\t\tchar\t\tsrc_name[8];\n\t\tchar\t\tdst_user_id[8];\n\t\tchar\t\tdst_name[8];\n\t);\n\tstruct list_head\taccept_q;\n\tspinlock_t\t\taccept_q_lock;\n\tstruct sock\t\t*parent;\n\tstruct iucv_path\t*path;\n\tstruct net_device\t*hs_dev;\n\tstruct sk_buff_head\tsend_skb_q;\n\tstruct sk_buff_head\tbacklog_skb_q;\n\tstruct sock_msg_q\tmessage_q;\n\tunsigned int\t\tsend_tag;\n\tu8\t\t\tflags;\n\tu16\t\t\tmsglimit;\n\tu16\t\t\tmsglimit_peer;\n\tatomic_t\t\tskbs_in_xmit;\n\tatomic_t\t\tmsg_sent;\n\tatomic_t\t\tmsg_recv;\n\tatomic_t\t\tpendings;\n\tint\t\t\ttransport;\n\tvoid\t\t\t(*sk_txnotify)(struct sock *sk,\n\t\t\t\t\t       enum iucv_tx_notify n);\n};\n\nstruct iucv_skb_cb {\n\tu32\tclass;\t\t \n\tu32\ttag;\t\t \n\tu32\toffset;\t\t \n};\n\n#define IUCV_SKB_CB(__skb)\t((struct iucv_skb_cb *)&((__skb)->cb[0]))\n\n \n#define SO_IPRMDATA_MSG\t0x0080\t\t \n#define SO_MSGLIMIT\t0x1000\t\t \n#define SO_MSGSIZE\t0x0800\t\t \n\n \n#define SCM_IUCV_TRGCLS\t0x0001\t\t \n\nstruct iucv_sock_list {\n\tstruct hlist_head head;\n\trwlock_t\t  lock;\n\tatomic_t\t  autobind_name;\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}