{
  "module_name": "inet_hashtables.h",
  "hash_id": "9286ece818782bf944b8bbb8522d2bef5956844f2359a2eecca184d2877da471",
  "original_prompt": "Ingested from linux-6.6.14/include/net/inet_hashtables.h",
  "human_readable_source": " \n \n\n#ifndef _INET_HASHTABLES_H\n#define _INET_HASHTABLES_H\n\n\n#include <linux/interrupt.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n\n#include <net/inet_connection_sock.h>\n#include <net/inet_sock.h>\n#include <net/ip.h>\n#include <net/sock.h>\n#include <net/route.h>\n#include <net/tcp_states.h>\n#include <net/netns/hash.h>\n\n#include <linux/refcount.h>\n#include <asm/byteorder.h>\n\n \nstruct inet_ehash_bucket {\n\tstruct hlist_nulls_head chain;\n};\n\n \n#define FASTREUSEPORT_ANY\t1\n#define FASTREUSEPORT_STRICT\t2\n\nstruct inet_bind_bucket {\n\tpossible_net_t\t\tib_net;\n\tint\t\t\tl3mdev;\n\tunsigned short\t\tport;\n\tsigned char\t\tfastreuse;\n\tsigned char\t\tfastreuseport;\n\tkuid_t\t\t\tfastuid;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct in6_addr\t\tfast_v6_rcv_saddr;\n#endif\n\t__be32\t\t\tfast_rcv_saddr;\n\tunsigned short\t\tfast_sk_family;\n\tbool\t\t\tfast_ipv6_only;\n\tstruct hlist_node\tnode;\n\tstruct hlist_head\towners;\n};\n\nstruct inet_bind2_bucket {\n\tpossible_net_t\t\tib_net;\n\tint\t\t\tl3mdev;\n\tunsigned short\t\tport;\n#if IS_ENABLED(CONFIG_IPV6)\n\tunsigned short\t\tfamily;\n#endif\n\tunion {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct in6_addr\t\tv6_rcv_saddr;\n#endif\n\t\t__be32\t\t\trcv_saddr;\n\t};\n\t \n\tstruct hlist_node\tnode;\n\t \n\tstruct hlist_head\towners;\n\t \n\tstruct hlist_head\tdeathrow;\n};\n\nstatic inline struct net *ib_net(const struct inet_bind_bucket *ib)\n{\n\treturn read_pnet(&ib->ib_net);\n}\n\nstatic inline struct net *ib2_net(const struct inet_bind2_bucket *ib)\n{\n\treturn read_pnet(&ib->ib_net);\n}\n\n#define inet_bind_bucket_for_each(tb, head) \\\n\thlist_for_each_entry(tb, head, node)\n\nstruct inet_bind_hashbucket {\n\tspinlock_t\t\tlock;\n\tstruct hlist_head\tchain;\n};\n\n \n#define LISTENING_NULLS_BASE (1U << 29)\nstruct inet_listen_hashbucket {\n\tspinlock_t\t\tlock;\n\tstruct hlist_nulls_head\tnulls_head;\n};\n\n \n#define INET_LHTABLE_SIZE\t32\t \n\nstruct inet_hashinfo {\n\t \n\tstruct inet_ehash_bucket\t*ehash;\n\tspinlock_t\t\t\t*ehash_locks;\n\tunsigned int\t\t\tehash_mask;\n\tunsigned int\t\t\tehash_locks_mask;\n\n\t \n\tstruct kmem_cache\t\t*bind_bucket_cachep;\n\t \n\tstruct inet_bind_hashbucket\t*bhash;\n\tstruct kmem_cache\t\t*bind2_bucket_cachep;\n\t \n\tstruct inet_bind_hashbucket\t*bhash2;\n\tunsigned int\t\t\tbhash_size;\n\n\t \n\tunsigned int\t\t\tlhash2_mask;\n\tstruct inet_listen_hashbucket\t*lhash2;\n\n\tbool\t\t\t\tpernet;\n} ____cacheline_aligned_in_smp;\n\nstatic inline struct inet_hashinfo *tcp_or_dccp_get_hashinfo(const struct sock *sk)\n{\n#if IS_ENABLED(CONFIG_IP_DCCP)\n\treturn sk->sk_prot->h.hashinfo ? :\n\t\tsock_net(sk)->ipv4.tcp_death_row.hashinfo;\n#else\n\treturn sock_net(sk)->ipv4.tcp_death_row.hashinfo;\n#endif\n}\n\nstatic inline struct inet_listen_hashbucket *\ninet_lhash2_bucket(struct inet_hashinfo *h, u32 hash)\n{\n\treturn &h->lhash2[hash & h->lhash2_mask];\n}\n\nstatic inline struct inet_ehash_bucket *inet_ehash_bucket(\n\tstruct inet_hashinfo *hashinfo,\n\tunsigned int hash)\n{\n\treturn &hashinfo->ehash[hash & hashinfo->ehash_mask];\n}\n\nstatic inline spinlock_t *inet_ehash_lockp(\n\tstruct inet_hashinfo *hashinfo,\n\tunsigned int hash)\n{\n\treturn &hashinfo->ehash_locks[hash & hashinfo->ehash_locks_mask];\n}\n\nint inet_ehash_locks_alloc(struct inet_hashinfo *hashinfo);\n\nstatic inline void inet_hashinfo2_free_mod(struct inet_hashinfo *h)\n{\n\tkfree(h->lhash2);\n\th->lhash2 = NULL;\n}\n\nstatic inline void inet_ehash_locks_free(struct inet_hashinfo *hashinfo)\n{\n\tkvfree(hashinfo->ehash_locks);\n\thashinfo->ehash_locks = NULL;\n}\n\nstruct inet_hashinfo *inet_pernet_hashinfo_alloc(struct inet_hashinfo *hashinfo,\n\t\t\t\t\t\t unsigned int ehash_entries);\nvoid inet_pernet_hashinfo_free(struct inet_hashinfo *hashinfo);\n\nstruct inet_bind_bucket *\ninet_bind_bucket_create(struct kmem_cache *cachep, struct net *net,\n\t\t\tstruct inet_bind_hashbucket *head,\n\t\t\tconst unsigned short snum, int l3mdev);\nvoid inet_bind_bucket_destroy(struct kmem_cache *cachep,\n\t\t\t      struct inet_bind_bucket *tb);\n\nbool inet_bind_bucket_match(const struct inet_bind_bucket *tb,\n\t\t\t    const struct net *net, unsigned short port,\n\t\t\t    int l3mdev);\n\nstruct inet_bind2_bucket *\ninet_bind2_bucket_create(struct kmem_cache *cachep, struct net *net,\n\t\t\t struct inet_bind_hashbucket *head,\n\t\t\t unsigned short port, int l3mdev,\n\t\t\t const struct sock *sk);\n\nvoid inet_bind2_bucket_destroy(struct kmem_cache *cachep,\n\t\t\t       struct inet_bind2_bucket *tb);\n\nstruct inet_bind2_bucket *\ninet_bind2_bucket_find(const struct inet_bind_hashbucket *head,\n\t\t       const struct net *net,\n\t\t       unsigned short port, int l3mdev,\n\t\t       const struct sock *sk);\n\nbool inet_bind2_bucket_match_addr_any(const struct inet_bind2_bucket *tb,\n\t\t\t\t      const struct net *net, unsigned short port,\n\t\t\t\t      int l3mdev, const struct sock *sk);\n\nstatic inline u32 inet_bhashfn(const struct net *net, const __u16 lport,\n\t\t\t       const u32 bhash_size)\n{\n\treturn (lport + net_hash_mix(net)) & (bhash_size - 1);\n}\n\nstatic inline struct inet_bind_hashbucket *\ninet_bhashfn_portaddr(const struct inet_hashinfo *hinfo, const struct sock *sk,\n\t\t      const struct net *net, unsigned short port)\n{\n\tu32 hash;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\thash = ipv6_portaddr_hash(net, &sk->sk_v6_rcv_saddr, port);\n\telse\n#endif\n\t\thash = ipv4_portaddr_hash(net, sk->sk_rcv_saddr, port);\n\treturn &hinfo->bhash2[hash & (hinfo->bhash_size - 1)];\n}\n\nstruct inet_bind_hashbucket *\ninet_bhash2_addr_any_hashbucket(const struct sock *sk, const struct net *net, int port);\n\n \nint inet_bhash2_update_saddr(struct sock *sk, void *saddr, int family);\nvoid inet_bhash2_reset_saddr(struct sock *sk);\n\nvoid inet_bind_hash(struct sock *sk, struct inet_bind_bucket *tb,\n\t\t    struct inet_bind2_bucket *tb2, unsigned short port);\n\n \nint __inet_inherit_port(const struct sock *sk, struct sock *child);\n\nvoid inet_put_port(struct sock *sk);\n\nvoid inet_hashinfo2_init(struct inet_hashinfo *h, const char *name,\n\t\t\t unsigned long numentries, int scale,\n\t\t\t unsigned long low_limit,\n\t\t\t unsigned long high_limit);\nint inet_hashinfo2_init_mod(struct inet_hashinfo *h);\n\nbool inet_ehash_insert(struct sock *sk, struct sock *osk, bool *found_dup_sk);\nbool inet_ehash_nolisten(struct sock *sk, struct sock *osk,\n\t\t\t bool *found_dup_sk);\nint __inet_hash(struct sock *sk, struct sock *osk);\nint inet_hash(struct sock *sk);\nvoid inet_unhash(struct sock *sk);\n\nstruct sock *__inet_lookup_listener(struct net *net,\n\t\t\t\t    struct inet_hashinfo *hashinfo,\n\t\t\t\t    struct sk_buff *skb, int doff,\n\t\t\t\t    const __be32 saddr, const __be16 sport,\n\t\t\t\t    const __be32 daddr,\n\t\t\t\t    const unsigned short hnum,\n\t\t\t\t    const int dif, const int sdif);\n\nstatic inline struct sock *inet_lookup_listener(struct net *net,\n\t\tstruct inet_hashinfo *hashinfo,\n\t\tstruct sk_buff *skb, int doff,\n\t\t__be32 saddr, __be16 sport,\n\t\t__be32 daddr, __be16 dport, int dif, int sdif)\n{\n\treturn __inet_lookup_listener(net, hashinfo, skb, doff, saddr, sport,\n\t\t\t\t      daddr, ntohs(dport), dif, sdif);\n}\n\n \n \n#ifdef __BIG_ENDIAN\n#define INET_COMBINED_PORTS(__sport, __dport) \\\n\t((__force __portpair)(((__force __u32)(__be16)(__sport) << 16) | (__u32)(__dport)))\n#else  \n#define INET_COMBINED_PORTS(__sport, __dport) \\\n\t((__force __portpair)(((__u32)(__dport) << 16) | (__force __u32)(__be16)(__sport)))\n#endif\n\n#ifdef __BIG_ENDIAN\n#define INET_ADDR_COOKIE(__name, __saddr, __daddr) \\\n\tconst __addrpair __name = (__force __addrpair) ( \\\n\t\t\t\t   (((__force __u64)(__be32)(__saddr)) << 32) | \\\n\t\t\t\t   ((__force __u64)(__be32)(__daddr)))\n#else  \n#define INET_ADDR_COOKIE(__name, __saddr, __daddr) \\\n\tconst __addrpair __name = (__force __addrpair) ( \\\n\t\t\t\t   (((__force __u64)(__be32)(__daddr)) << 32) | \\\n\t\t\t\t   ((__force __u64)(__be32)(__saddr)))\n#endif  \n\nstatic inline bool inet_match(struct net *net, const struct sock *sk,\n\t\t\t      const __addrpair cookie, const __portpair ports,\n\t\t\t      int dif, int sdif)\n{\n\tif (!net_eq(sock_net(sk), net) ||\n\t    sk->sk_portpair != ports ||\n\t    sk->sk_addrpair != cookie)\n\t        return false;\n\n\t \n\treturn inet_sk_bound_dev_eq(net, READ_ONCE(sk->sk_bound_dev_if), dif,\n\t\t\t\t    sdif);\n}\n\n \nstruct sock *__inet_lookup_established(struct net *net,\n\t\t\t\t       struct inet_hashinfo *hashinfo,\n\t\t\t\t       const __be32 saddr, const __be16 sport,\n\t\t\t\t       const __be32 daddr, const u16 hnum,\n\t\t\t\t       const int dif, const int sdif);\n\ntypedef u32 (inet_ehashfn_t)(const struct net *net,\n\t\t\t      const __be32 laddr, const __u16 lport,\n\t\t\t      const __be32 faddr, const __be16 fport);\n\ninet_ehashfn_t inet_ehashfn;\n\nINDIRECT_CALLABLE_DECLARE(inet_ehashfn_t udp_ehashfn);\n\nstruct sock *inet_lookup_reuseport(struct net *net, struct sock *sk,\n\t\t\t\t   struct sk_buff *skb, int doff,\n\t\t\t\t   __be32 saddr, __be16 sport,\n\t\t\t\t   __be32 daddr, unsigned short hnum,\n\t\t\t\t   inet_ehashfn_t *ehashfn);\n\nstruct sock *inet_lookup_run_sk_lookup(struct net *net,\n\t\t\t\t       int protocol,\n\t\t\t\t       struct sk_buff *skb, int doff,\n\t\t\t\t       __be32 saddr, __be16 sport,\n\t\t\t\t       __be32 daddr, u16 hnum, const int dif,\n\t\t\t\t       inet_ehashfn_t *ehashfn);\n\nstatic inline struct sock *\n\tinet_lookup_established(struct net *net, struct inet_hashinfo *hashinfo,\n\t\t\t\tconst __be32 saddr, const __be16 sport,\n\t\t\t\tconst __be32 daddr, const __be16 dport,\n\t\t\t\tconst int dif)\n{\n\treturn __inet_lookup_established(net, hashinfo, saddr, sport, daddr,\n\t\t\t\t\t ntohs(dport), dif, 0);\n}\n\nstatic inline struct sock *__inet_lookup(struct net *net,\n\t\t\t\t\t struct inet_hashinfo *hashinfo,\n\t\t\t\t\t struct sk_buff *skb, int doff,\n\t\t\t\t\t const __be32 saddr, const __be16 sport,\n\t\t\t\t\t const __be32 daddr, const __be16 dport,\n\t\t\t\t\t const int dif, const int sdif,\n\t\t\t\t\t bool *refcounted)\n{\n\tu16 hnum = ntohs(dport);\n\tstruct sock *sk;\n\n\tsk = __inet_lookup_established(net, hashinfo, saddr, sport,\n\t\t\t\t       daddr, hnum, dif, sdif);\n\t*refcounted = true;\n\tif (sk)\n\t\treturn sk;\n\t*refcounted = false;\n\treturn __inet_lookup_listener(net, hashinfo, skb, doff, saddr,\n\t\t\t\t      sport, daddr, hnum, dif, sdif);\n}\n\nstatic inline struct sock *inet_lookup(struct net *net,\n\t\t\t\t       struct inet_hashinfo *hashinfo,\n\t\t\t\t       struct sk_buff *skb, int doff,\n\t\t\t\t       const __be32 saddr, const __be16 sport,\n\t\t\t\t       const __be32 daddr, const __be16 dport,\n\t\t\t\t       const int dif)\n{\n\tstruct sock *sk;\n\tbool refcounted;\n\n\tsk = __inet_lookup(net, hashinfo, skb, doff, saddr, sport, daddr,\n\t\t\t   dport, dif, 0, &refcounted);\n\n\tif (sk && !refcounted && !refcount_inc_not_zero(&sk->sk_refcnt))\n\t\tsk = NULL;\n\treturn sk;\n}\n\nstatic inline\nstruct sock *inet_steal_sock(struct net *net, struct sk_buff *skb, int doff,\n\t\t\t     const __be32 saddr, const __be16 sport,\n\t\t\t     const __be32 daddr, const __be16 dport,\n\t\t\t     bool *refcounted, inet_ehashfn_t *ehashfn)\n{\n\tstruct sock *sk, *reuse_sk;\n\tbool prefetched;\n\n\tsk = skb_steal_sock(skb, refcounted, &prefetched);\n\tif (!sk)\n\t\treturn NULL;\n\n\tif (!prefetched || !sk_fullsock(sk))\n\t\treturn sk;\n\n\tif (sk->sk_protocol == IPPROTO_TCP) {\n\t\tif (sk->sk_state != TCP_LISTEN)\n\t\t\treturn sk;\n\t} else if (sk->sk_protocol == IPPROTO_UDP) {\n\t\tif (sk->sk_state != TCP_CLOSE)\n\t\t\treturn sk;\n\t} else {\n\t\treturn sk;\n\t}\n\n\treuse_sk = inet_lookup_reuseport(net, sk, skb, doff,\n\t\t\t\t\t saddr, sport, daddr, ntohs(dport),\n\t\t\t\t\t ehashfn);\n\tif (!reuse_sk)\n\t\treturn sk;\n\n\t \n\tWARN_ON_ONCE(*refcounted);\n\n\treturn reuse_sk;\n}\n\nstatic inline struct sock *__inet_lookup_skb(struct inet_hashinfo *hashinfo,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     int doff,\n\t\t\t\t\t     const __be16 sport,\n\t\t\t\t\t     const __be16 dport,\n\t\t\t\t\t     const int sdif,\n\t\t\t\t\t     bool *refcounted)\n{\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct sock *sk;\n\n\tsk = inet_steal_sock(net, skb, doff, iph->saddr, sport, iph->daddr, dport,\n\t\t\t     refcounted, inet_ehashfn);\n\tif (IS_ERR(sk))\n\t\treturn NULL;\n\tif (sk)\n\t\treturn sk;\n\n\treturn __inet_lookup(net, hashinfo, skb,\n\t\t\t     doff, iph->saddr, sport,\n\t\t\t     iph->daddr, dport, inet_iif(skb), sdif,\n\t\t\t     refcounted);\n}\n\nstatic inline void sk_daddr_set(struct sock *sk, __be32 addr)\n{\n\tsk->sk_daddr = addr;  \n#if IS_ENABLED(CONFIG_IPV6)\n\tipv6_addr_set_v4mapped(addr, &sk->sk_v6_daddr);\n#endif\n}\n\nstatic inline void sk_rcv_saddr_set(struct sock *sk, __be32 addr)\n{\n\tsk->sk_rcv_saddr = addr;  \n#if IS_ENABLED(CONFIG_IPV6)\n\tipv6_addr_set_v4mapped(addr, &sk->sk_v6_rcv_saddr);\n#endif\n}\n\nint __inet_hash_connect(struct inet_timewait_death_row *death_row,\n\t\t\tstruct sock *sk, u64 port_offset,\n\t\t\tint (*check_established)(struct inet_timewait_death_row *,\n\t\t\t\t\t\t struct sock *, __u16,\n\t\t\t\t\t\t struct inet_timewait_sock **));\n\nint inet_hash_connect(struct inet_timewait_death_row *death_row,\n\t\t      struct sock *sk);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}