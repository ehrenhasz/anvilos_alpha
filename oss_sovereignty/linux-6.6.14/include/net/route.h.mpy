{
  "module_name": "route.h",
  "hash_id": "2d8276dfbf3c09a36a6dffd243217bb7378bd52fd6f3bf570307f4304961983a",
  "original_prompt": "Ingested from linux-6.6.14/include/net/route.h",
  "human_readable_source": " \n \n#ifndef _ROUTE_H\n#define _ROUTE_H\n\n#include <net/dst.h>\n#include <net/inetpeer.h>\n#include <net/flow.h>\n#include <net/inet_sock.h>\n#include <net/ip_fib.h>\n#include <net/arp.h>\n#include <net/ndisc.h>\n#include <linux/in_route.h>\n#include <linux/rtnetlink.h>\n#include <linux/rcupdate.h>\n#include <linux/route.h>\n#include <linux/ip.h>\n#include <linux/cache.h>\n#include <linux/security.h>\n\n#define RTO_ONLINK\t0x01\n\n#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sock_flag(sk, SOCK_LOCALROUTE))\n#define RT_CONN_FLAGS_TOS(sk,tos)   (RT_TOS(tos) | sock_flag(sk, SOCK_LOCALROUTE))\n\nstatic inline __u8 ip_sock_rt_scope(const struct sock *sk)\n{\n\tif (sock_flag(sk, SOCK_LOCALROUTE))\n\t\treturn RT_SCOPE_LINK;\n\n\treturn RT_SCOPE_UNIVERSE;\n}\n\nstatic inline __u8 ip_sock_rt_tos(const struct sock *sk)\n{\n\treturn RT_TOS(inet_sk(sk)->tos);\n}\n\nstruct ip_tunnel_info;\nstruct fib_nh;\nstruct fib_info;\nstruct uncached_list;\nstruct rtable {\n\tstruct dst_entry\tdst;\n\n\tint\t\t\trt_genid;\n\tunsigned int\t\trt_flags;\n\t__u16\t\t\trt_type;\n\t__u8\t\t\trt_is_input;\n\t__u8\t\t\trt_uses_gateway;\n\n\tint\t\t\trt_iif;\n\n\tu8\t\t\trt_gw_family;\n\t \n\tunion {\n\t\t__be32\t\trt_gw4;\n\t\tstruct in6_addr\trt_gw6;\n\t};\n\n\t \n\tu32\t\t\trt_mtu_locked:1,\n\t\t\t\trt_pmtu:31;\n};\n\nstatic inline bool rt_is_input_route(const struct rtable *rt)\n{\n\treturn rt->rt_is_input != 0;\n}\n\nstatic inline bool rt_is_output_route(const struct rtable *rt)\n{\n\treturn rt->rt_is_input == 0;\n}\n\nstatic inline __be32 rt_nexthop(const struct rtable *rt, __be32 daddr)\n{\n\tif (rt->rt_gw_family == AF_INET)\n\t\treturn rt->rt_gw4;\n\treturn daddr;\n}\n\nstruct ip_rt_acct {\n\t__u32 \to_bytes;\n\t__u32 \to_packets;\n\t__u32 \ti_bytes;\n\t__u32 \ti_packets;\n};\n\nstruct rt_cache_stat {\n        unsigned int in_slow_tot;\n        unsigned int in_slow_mc;\n        unsigned int in_no_route;\n        unsigned int in_brd;\n        unsigned int in_martian_dst;\n        unsigned int in_martian_src;\n        unsigned int out_slow_tot;\n        unsigned int out_slow_mc;\n};\n\nextern struct ip_rt_acct __percpu *ip_rt_acct;\n\nstruct in_device;\n\nint ip_rt_init(void);\nvoid rt_cache_flush(struct net *net);\nvoid rt_flush_dev(struct net_device *dev);\nstruct rtable *ip_route_output_key_hash(struct net *net, struct flowi4 *flp,\n\t\t\t\t\tconst struct sk_buff *skb);\nstruct rtable *ip_route_output_key_hash_rcu(struct net *net, struct flowi4 *flp,\n\t\t\t\t\t    struct fib_result *res,\n\t\t\t\t\t    const struct sk_buff *skb);\n\nstatic inline struct rtable *__ip_route_output_key(struct net *net,\n\t\t\t\t\t\t   struct flowi4 *flp)\n{\n\treturn ip_route_output_key_hash(net, flp, NULL);\n}\n\nstruct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,\n\t\t\t\t    const struct sock *sk);\nstruct rtable *ip_route_output_tunnel(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      struct net *net, __be32 *saddr,\n\t\t\t\t      const struct ip_tunnel_info *info,\n\t\t\t\t      u8 protocol, bool use_cache);\n\nstruct dst_entry *ipv4_blackhole_route(struct net *net,\n\t\t\t\t       struct dst_entry *dst_orig);\n\nstatic inline struct rtable *ip_route_output_key(struct net *net, struct flowi4 *flp)\n{\n\treturn ip_route_output_flow(net, flp, NULL);\n}\n\nstatic inline struct rtable *ip_route_output(struct net *net, __be32 daddr,\n\t\t\t\t\t     __be32 saddr, u8 tos, int oif)\n{\n\tstruct flowi4 fl4 = {\n\t\t.flowi4_oif = oif,\n\t\t.flowi4_tos = tos,\n\t\t.daddr = daddr,\n\t\t.saddr = saddr,\n\t};\n\treturn ip_route_output_key(net, &fl4);\n}\n\nstatic inline struct rtable *ip_route_output_ports(struct net *net, struct flowi4 *fl4,\n\t\t\t\t\t\t   const struct sock *sk,\n\t\t\t\t\t\t   __be32 daddr, __be32 saddr,\n\t\t\t\t\t\t   __be16 dport, __be16 sport,\n\t\t\t\t\t\t   __u8 proto, __u8 tos, int oif)\n{\n\tflowi4_init_output(fl4, oif, sk ? READ_ONCE(sk->sk_mark) : 0, tos,\n\t\t\t   RT_SCOPE_UNIVERSE, proto,\n\t\t\t   sk ? inet_sk_flowi_flags(sk) : 0,\n\t\t\t   daddr, saddr, dport, sport, sock_net_uid(net, sk));\n\tif (sk)\n\t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi_common(fl4));\n\treturn ip_route_output_flow(net, fl4, sk);\n}\n\nstatic inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4 *fl4,\n\t\t\t\t\t\t __be32 daddr, __be32 saddr,\n\t\t\t\t\t\t __be32 gre_key, __u8 tos, int oif)\n{\n\tmemset(fl4, 0, sizeof(*fl4));\n\tfl4->flowi4_oif = oif;\n\tfl4->daddr = daddr;\n\tfl4->saddr = saddr;\n\tfl4->flowi4_tos = tos;\n\tfl4->flowi4_proto = IPPROTO_GRE;\n\tfl4->fl4_gre_key = gre_key;\n\treturn ip_route_output_key(net, fl4);\n}\nint ip_mc_validate_source(struct sk_buff *skb, __be32 daddr, __be32 saddr,\n\t\t\t  u8 tos, struct net_device *dev,\n\t\t\t  struct in_device *in_dev, u32 *itag);\nint ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,\n\t\t\t u8 tos, struct net_device *devin);\nint ip_route_use_hint(struct sk_buff *skb, __be32 dst, __be32 src,\n\t\t      u8 tos, struct net_device *devin,\n\t\t      const struct sk_buff *hint);\n\nstatic inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,\n\t\t\t\t u8 tos, struct net_device *devin)\n{\n\tint err;\n\n\trcu_read_lock();\n\terr = ip_route_input_noref(skb, dst, src, tos, devin);\n\tif (!err) {\n\t\tskb_dst_force(skb);\n\t\tif (!skb_dst(skb))\n\t\t\terr = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nvoid ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu, int oif,\n\t\t      u8 protocol);\nvoid ipv4_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, u32 mtu);\nvoid ipv4_redirect(struct sk_buff *skb, struct net *net, int oif, u8 protocol);\nvoid ipv4_sk_redirect(struct sk_buff *skb, struct sock *sk);\nvoid ip_rt_send_redirect(struct sk_buff *skb);\n\nunsigned int inet_addr_type(struct net *net, __be32 addr);\nunsigned int inet_addr_type_table(struct net *net, __be32 addr, u32 tb_id);\nunsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,\n\t\t\t\t__be32 addr);\nunsigned int inet_addr_type_dev_table(struct net *net,\n\t\t\t\t      const struct net_device *dev,\n\t\t\t\t      __be32 addr);\nvoid ip_rt_multicast_event(struct in_device *);\nint ip_rt_ioctl(struct net *, unsigned int cmd, struct rtentry *rt);\nvoid ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);\nstruct rtable *rt_dst_alloc(struct net_device *dev,\n\t\t\t    unsigned int flags, u16 type, bool noxfrm);\nstruct rtable *rt_dst_clone(struct net_device *dev, struct rtable *rt);\n\nstruct in_ifaddr;\nvoid fib_add_ifaddr(struct in_ifaddr *);\nvoid fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);\nvoid fib_modify_prefix_metric(struct in_ifaddr *ifa, u32 new_metric);\n\nvoid rt_add_uncached_list(struct rtable *rt);\nvoid rt_del_uncached_list(struct rtable *rt);\n\nint fib_dump_info_fnhe(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t       u32 table_id, struct fib_info *fi,\n\t\t       int *fa_index, int fa_start, unsigned int flags);\n\nstatic inline void ip_rt_put(struct rtable *rt)\n{\n\t \n\tBUILD_BUG_ON(offsetof(struct rtable, dst) != 0);\n\tdst_release(&rt->dst);\n}\n\n#define IPTOS_RT_MASK\t(IPTOS_TOS_MASK & ~3)\n\nextern const __u8 ip_tos2prio[16];\n\nstatic inline char rt_tos2priority(u8 tos)\n{\n\treturn ip_tos2prio[IPTOS_TOS(tos)>>1];\n}\n\n \n\nstatic inline void ip_route_connect_init(struct flowi4 *fl4, __be32 dst,\n\t\t\t\t\t __be32 src, int oif, u8 protocol,\n\t\t\t\t\t __be16 sport, __be16 dport,\n\t\t\t\t\t const struct sock *sk)\n{\n\t__u8 flow_flags = 0;\n\n\tif (inet_test_bit(TRANSPARENT, sk))\n\t\tflow_flags |= FLOWI_FLAG_ANYSRC;\n\n\tflowi4_init_output(fl4, oif, READ_ONCE(sk->sk_mark), ip_sock_rt_tos(sk),\n\t\t\t   ip_sock_rt_scope(sk), protocol, flow_flags, dst,\n\t\t\t   src, dport, sport, sk->sk_uid);\n}\n\nstatic inline struct rtable *ip_route_connect(struct flowi4 *fl4, __be32 dst,\n\t\t\t\t\t      __be32 src, int oif, u8 protocol,\n\t\t\t\t\t      __be16 sport, __be16 dport,\n\t\t\t\t\t      const struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct rtable *rt;\n\n\tip_route_connect_init(fl4, dst, src, oif, protocol, sport, dport, sk);\n\n\tif (!dst || !src) {\n\t\trt = __ip_route_output_key(net, fl4);\n\t\tif (IS_ERR(rt))\n\t\t\treturn rt;\n\t\tip_rt_put(rt);\n\t\tflowi4_update_output(fl4, oif, fl4->daddr, fl4->saddr);\n\t}\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi_common(fl4));\n\treturn ip_route_output_flow(net, fl4, sk);\n}\n\nstatic inline struct rtable *ip_route_newports(struct flowi4 *fl4, struct rtable *rt,\n\t\t\t\t\t       __be16 orig_sport, __be16 orig_dport,\n\t\t\t\t\t       __be16 sport, __be16 dport,\n\t\t\t\t\t       const struct sock *sk)\n{\n\tif (sport != orig_sport || dport != orig_dport) {\n\t\tfl4->fl4_dport = dport;\n\t\tfl4->fl4_sport = sport;\n\t\tip_rt_put(rt);\n\t\tflowi4_update_output(fl4, sk->sk_bound_dev_if, fl4->daddr,\n\t\t\t\t     fl4->saddr);\n\t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi_common(fl4));\n\t\treturn ip_route_output_flow(sock_net(sk), fl4, sk);\n\t}\n\treturn rt;\n}\n\nstatic inline int inet_iif(const struct sk_buff *skb)\n{\n\tstruct rtable *rt = skb_rtable(skb);\n\n\tif (rt && rt->rt_iif)\n\t\treturn rt->rt_iif;\n\n\treturn skb->skb_iif;\n}\n\nstatic inline int ip4_dst_hoplimit(const struct dst_entry *dst)\n{\n\tint hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);\n\tstruct net *net = dev_net(dst->dev);\n\n\tif (hoplimit == 0)\n\t\thoplimit = READ_ONCE(net->ipv4.sysctl_ip_default_ttl);\n\treturn hoplimit;\n}\n\nstatic inline struct neighbour *ip_neigh_gw4(struct net_device *dev,\n\t\t\t\t\t     __be32 daddr)\n{\n\tstruct neighbour *neigh;\n\n\tneigh = __ipv4_neigh_lookup_noref(dev, (__force u32)daddr);\n\tif (unlikely(!neigh))\n\t\tneigh = __neigh_create(&arp_tbl, &daddr, dev, false);\n\n\treturn neigh;\n}\n\nstatic inline struct neighbour *ip_neigh_for_gw(struct rtable *rt,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tbool *is_v6gw)\n{\n\tstruct net_device *dev = rt->dst.dev;\n\tstruct neighbour *neigh;\n\n\tif (likely(rt->rt_gw_family == AF_INET)) {\n\t\tneigh = ip_neigh_gw4(dev, rt->rt_gw4);\n\t} else if (rt->rt_gw_family == AF_INET6) {\n\t\tneigh = ip_neigh_gw6(dev, &rt->rt_gw6);\n\t\t*is_v6gw = true;\n\t} else {\n\t\tneigh = ip_neigh_gw4(dev, ip_hdr(skb)->daddr);\n\t}\n\treturn neigh;\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}