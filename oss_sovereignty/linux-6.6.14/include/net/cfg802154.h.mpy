{
  "module_name": "cfg802154.h",
  "hash_id": "6ea1f843ce4d4a7f2ad2322c0237da1b56cae9c636950975119157758d71b46f",
  "original_prompt": "Ingested from linux-6.6.14/include/net/cfg802154.h",
  "human_readable_source": " \n \n\n#ifndef __NET_CFG802154_H\n#define __NET_CFG802154_H\n\n#include <linux/ieee802154.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n#include <linux/bug.h>\n\n#include <net/nl802154.h>\n\nstruct wpan_phy;\nstruct wpan_phy_cca;\nstruct cfg802154_scan_request;\nstruct cfg802154_beacon_request;\n\n#ifdef CONFIG_IEEE802154_NL802154_EXPERIMENTAL\nstruct ieee802154_llsec_device_key;\nstruct ieee802154_llsec_seclevel;\nstruct ieee802154_llsec_params;\nstruct ieee802154_llsec_device;\nstruct ieee802154_llsec_table;\nstruct ieee802154_llsec_key_id;\nstruct ieee802154_llsec_key;\n#endif  \n\nstruct cfg802154_ops {\n\tstruct net_device * (*add_virtual_intf_deprecated)(struct wpan_phy *wpan_phy,\n\t\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t\t   unsigned char name_assign_type,\n\t\t\t\t\t\t\t   int type);\n\tvoid\t(*del_virtual_intf_deprecated)(struct wpan_phy *wpan_phy,\n\t\t\t\t\t       struct net_device *dev);\n\tint\t(*suspend)(struct wpan_phy *wpan_phy);\n\tint\t(*resume)(struct wpan_phy *wpan_phy);\n\tint\t(*add_virtual_intf)(struct wpan_phy *wpan_phy,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned char name_assign_type,\n\t\t\t\t    enum nl802154_iftype type,\n\t\t\t\t    __le64 extended_addr);\n\tint\t(*del_virtual_intf)(struct wpan_phy *wpan_phy,\n\t\t\t\t    struct wpan_dev *wpan_dev);\n\tint\t(*set_channel)(struct wpan_phy *wpan_phy, u8 page, u8 channel);\n\tint\t(*set_cca_mode)(struct wpan_phy *wpan_phy,\n\t\t\t\tconst struct wpan_phy_cca *cca);\n\tint     (*set_cca_ed_level)(struct wpan_phy *wpan_phy, s32 ed_level);\n\tint     (*set_tx_power)(struct wpan_phy *wpan_phy, s32 power);\n\tint\t(*set_pan_id)(struct wpan_phy *wpan_phy,\n\t\t\t      struct wpan_dev *wpan_dev, __le16 pan_id);\n\tint\t(*set_short_addr)(struct wpan_phy *wpan_phy,\n\t\t\t\t  struct wpan_dev *wpan_dev, __le16 short_addr);\n\tint\t(*set_backoff_exponent)(struct wpan_phy *wpan_phy,\n\t\t\t\t\tstruct wpan_dev *wpan_dev, u8 min_be,\n\t\t\t\t\tu8 max_be);\n\tint\t(*set_max_csma_backoffs)(struct wpan_phy *wpan_phy,\n\t\t\t\t\t struct wpan_dev *wpan_dev,\n\t\t\t\t\t u8 max_csma_backoffs);\n\tint\t(*set_max_frame_retries)(struct wpan_phy *wpan_phy,\n\t\t\t\t\t struct wpan_dev *wpan_dev,\n\t\t\t\t\t s8 max_frame_retries);\n\tint\t(*set_lbt_mode)(struct wpan_phy *wpan_phy,\n\t\t\t\tstruct wpan_dev *wpan_dev, bool mode);\n\tint\t(*set_ackreq_default)(struct wpan_phy *wpan_phy,\n\t\t\t\t      struct wpan_dev *wpan_dev, bool ackreq);\n\tint\t(*trigger_scan)(struct wpan_phy *wpan_phy,\n\t\t\t\tstruct cfg802154_scan_request *request);\n\tint\t(*abort_scan)(struct wpan_phy *wpan_phy,\n\t\t\t      struct wpan_dev *wpan_dev);\n\tint\t(*send_beacons)(struct wpan_phy *wpan_phy,\n\t\t\t\tstruct cfg802154_beacon_request *request);\n\tint\t(*stop_beacons)(struct wpan_phy *wpan_phy,\n\t\t\t\tstruct wpan_dev *wpan_dev);\n#ifdef CONFIG_IEEE802154_NL802154_EXPERIMENTAL\n\tvoid\t(*get_llsec_table)(struct wpan_phy *wpan_phy,\n\t\t\t\t   struct wpan_dev *wpan_dev,\n\t\t\t\t   struct ieee802154_llsec_table **table);\n\tvoid\t(*lock_llsec_table)(struct wpan_phy *wpan_phy,\n\t\t\t\t    struct wpan_dev *wpan_dev);\n\tvoid\t(*unlock_llsec_table)(struct wpan_phy *wpan_phy,\n\t\t\t\t      struct wpan_dev *wpan_dev);\n\t \n\tint\t(*get_llsec_params)(struct wpan_phy *wpan_phy,\n\t\t\t\t    struct wpan_dev *wpan_dev,\n\t\t\t\t    struct ieee802154_llsec_params *params);\n\tint\t(*set_llsec_params)(struct wpan_phy *wpan_phy,\n\t\t\t\t    struct wpan_dev *wpan_dev,\n\t\t\t\t    const struct ieee802154_llsec_params *params,\n\t\t\t\t    int changed);\n\tint\t(*add_llsec_key)(struct wpan_phy *wpan_phy,\n\t\t\t\t struct wpan_dev *wpan_dev,\n\t\t\t\t const struct ieee802154_llsec_key_id *id,\n\t\t\t\t const struct ieee802154_llsec_key *key);\n\tint\t(*del_llsec_key)(struct wpan_phy *wpan_phy,\n\t\t\t\t struct wpan_dev *wpan_dev,\n\t\t\t\t const struct ieee802154_llsec_key_id *id);\n\tint\t(*add_seclevel)(struct wpan_phy *wpan_phy,\n\t\t\t\t struct wpan_dev *wpan_dev,\n\t\t\t\t const struct ieee802154_llsec_seclevel *sl);\n\tint\t(*del_seclevel)(struct wpan_phy *wpan_phy,\n\t\t\t\t struct wpan_dev *wpan_dev,\n\t\t\t\t const struct ieee802154_llsec_seclevel *sl);\n\tint\t(*add_device)(struct wpan_phy *wpan_phy,\n\t\t\t      struct wpan_dev *wpan_dev,\n\t\t\t      const struct ieee802154_llsec_device *dev);\n\tint\t(*del_device)(struct wpan_phy *wpan_phy,\n\t\t\t      struct wpan_dev *wpan_dev, __le64 extended_addr);\n\tint\t(*add_devkey)(struct wpan_phy *wpan_phy,\n\t\t\t      struct wpan_dev *wpan_dev,\n\t\t\t      __le64 extended_addr,\n\t\t\t      const struct ieee802154_llsec_device_key *key);\n\tint\t(*del_devkey)(struct wpan_phy *wpan_phy,\n\t\t\t      struct wpan_dev *wpan_dev,\n\t\t\t      __le64 extended_addr,\n\t\t\t      const struct ieee802154_llsec_device_key *key);\n#endif  \n};\n\nstatic inline bool\nwpan_phy_supported_bool(bool b, enum nl802154_supported_bool_states st)\n{\n\tswitch (st) {\n\tcase NL802154_SUPPORTED_BOOL_TRUE:\n\t\treturn b;\n\tcase NL802154_SUPPORTED_BOOL_FALSE:\n\t\treturn !b;\n\tcase NL802154_SUPPORTED_BOOL_BOTH:\n\t\treturn true;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\treturn false;\n}\n\nstruct wpan_phy_supported {\n\tu32 channels[IEEE802154_MAX_PAGE + 1],\n\t    cca_modes, cca_opts, iftypes;\n\tenum nl802154_supported_bool_states lbt;\n\tu8 min_minbe, max_minbe, min_maxbe, max_maxbe,\n\t   min_csma_backoffs, max_csma_backoffs;\n\ts8 min_frame_retries, max_frame_retries;\n\tsize_t tx_powers_size, cca_ed_levels_size;\n\tconst s32 *tx_powers, *cca_ed_levels;\n};\n\nstruct wpan_phy_cca {\n\tenum nl802154_cca_modes mode;\n\tenum nl802154_cca_opts opt;\n};\n\nstatic inline bool\nwpan_phy_cca_cmp(const struct wpan_phy_cca *a, const struct wpan_phy_cca *b)\n{\n\tif (a->mode != b->mode)\n\t\treturn false;\n\n\tif (a->mode == NL802154_CCA_ENERGY_CARRIER)\n\t\treturn a->opt == b->opt;\n\n\treturn true;\n}\n\n \nenum wpan_phy_flags {\n\tWPAN_PHY_FLAG_TXPOWER\t\t= BIT(1),\n\tWPAN_PHY_FLAG_CCA_ED_LEVEL\t= BIT(2),\n\tWPAN_PHY_FLAG_CCA_MODE\t\t= BIT(3),\n\tWPAN_PHY_FLAG_STATE_QUEUE_STOPPED = BIT(4),\n\tWPAN_PHY_FLAG_DATAGRAMS_ONLY\t= BIT(5),\n};\n\nstruct wpan_phy {\n\t \n\tconst void *privid;\n\n\tunsigned long flags;\n\n\t \n\tu8 current_channel;\n\tu8 current_page;\n\tstruct wpan_phy_supported supported;\n\t \n\ts32 transmit_power;\n\tstruct wpan_phy_cca cca;\n\n\t__le64 perm_extended_addr;\n\n\t \n\ts32 cca_ed_level;\n\n\t \n\n\t \n\tu32 symbol_duration;\n\t \n\tu16 lifs_period;\n\tu16 sifs_period;\n\n\tstruct device dev;\n\n\t \n\tpossible_net_t _net;\n\n\t \n\tspinlock_t queue_lock;\n\tatomic_t ongoing_txs;\n\tatomic_t hold_txs;\n\twait_queue_head_t sync_txq;\n\n\t \n\tenum ieee802154_filtering_level filtering;\n\n\tchar priv[] __aligned(NETDEV_ALIGN);\n};\n\nstatic inline struct net *wpan_phy_net(struct wpan_phy *wpan_phy)\n{\n\treturn read_pnet(&wpan_phy->_net);\n}\n\nstatic inline void wpan_phy_net_set(struct wpan_phy *wpan_phy, struct net *net)\n{\n\twrite_pnet(&wpan_phy->_net, net);\n}\n\nstatic inline bool ieee802154_chan_is_valid(struct wpan_phy *phy,\n\t\t\t\t\t    u8 page, u8 channel)\n{\n\tif (page > IEEE802154_MAX_PAGE ||\n\t    channel > IEEE802154_MAX_CHANNEL ||\n\t    !(phy->supported.channels[page] & BIT(channel)))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstruct ieee802154_addr {\n\tu8 mode;\n\t__le16 pan_id;\n\tunion {\n\t\t__le16 short_addr;\n\t\t__le64 extended_addr;\n\t};\n};\n\n \nstruct ieee802154_coord_desc {\n\tstruct ieee802154_addr addr;\n\tu8 page;\n\tu8 channel;\n\tu16 superframe_spec;\n\tu8 link_quality;\n\tbool gts_permit;\n};\n\n \nstruct cfg802154_scan_request {\n\tenum nl802154_scan_types type;\n\tu8 page;\n\tu32 channels;\n\tu8 duration;\n\tstruct wpan_dev *wpan_dev;\n\tstruct wpan_phy *wpan_phy;\n};\n\n \nstruct cfg802154_beacon_request {\n\tu8 interval;\n\tstruct wpan_dev *wpan_dev;\n\tstruct wpan_phy *wpan_phy;\n};\n\n \nstruct cfg802154_mac_pkt {\n\tstruct list_head node;\n\tstruct sk_buff *skb;\n\tstruct ieee802154_sub_if_data *sdata;\n\tu8 page;\n\tu8 channel;\n};\n\nstruct ieee802154_llsec_key_id {\n\tu8 mode;\n\tu8 id;\n\tunion {\n\t\tstruct ieee802154_addr device_addr;\n\t\t__le32 short_source;\n\t\t__le64 extended_source;\n\t};\n};\n\n#define IEEE802154_LLSEC_KEY_SIZE 16\n\nstruct ieee802154_llsec_key {\n\tu8 frame_types;\n\tu32 cmd_frame_ids;\n\t \n\tu8 key[IEEE802154_LLSEC_KEY_SIZE];\n};\n\nstruct ieee802154_llsec_key_entry {\n\tstruct list_head list;\n\n\tstruct ieee802154_llsec_key_id id;\n\tstruct ieee802154_llsec_key *key;\n};\n\nstruct ieee802154_llsec_params {\n\tbool enabled;\n\n\t__be32 frame_counter;\n\tu8 out_level;\n\tstruct ieee802154_llsec_key_id out_key;\n\n\t__le64 default_key_source;\n\n\t__le16 pan_id;\n\t__le64 hwaddr;\n\t__le64 coord_hwaddr;\n\t__le16 coord_shortaddr;\n};\n\nstruct ieee802154_llsec_table {\n\tstruct list_head keys;\n\tstruct list_head devices;\n\tstruct list_head security_levels;\n};\n\nstruct ieee802154_llsec_seclevel {\n\tstruct list_head list;\n\n\tu8 frame_type;\n\tu8 cmd_frame_id;\n\tbool device_override;\n\tu32 sec_levels;\n};\n\nstruct ieee802154_llsec_device {\n\tstruct list_head list;\n\n\t__le16 pan_id;\n\t__le16 short_addr;\n\t__le64 hwaddr;\n\tu32 frame_counter;\n\tbool seclevel_exempt;\n\n\tu8 key_mode;\n\tstruct list_head keys;\n};\n\nstruct ieee802154_llsec_device_key {\n\tstruct list_head list;\n\n\tstruct ieee802154_llsec_key_id key_id;\n\tu32 frame_counter;\n};\n\nstruct wpan_dev_header_ops {\n\t \n\tint\t(*create)(struct sk_buff *skb, struct net_device *dev,\n\t\t\t  const struct ieee802154_addr *daddr,\n\t\t\t  const struct ieee802154_addr *saddr,\n\t\t\t  unsigned int len);\n};\n\nstruct wpan_dev {\n\tstruct wpan_phy *wpan_phy;\n\tint iftype;\n\n\t \n\tstruct list_head list;\n\tstruct net_device *netdev;\n\n\tconst struct wpan_dev_header_ops *header_ops;\n\n\t \n\tstruct net_device *lowpan_dev;\n\n\tu32 identifier;\n\n\t \n\t__le16 pan_id;\n\t__le16 short_addr;\n\t__le64 extended_addr;\n\n\t \n\tatomic_t bsn;\n\t \n\tatomic_t dsn;\n\n\tu8 min_be;\n\tu8 max_be;\n\tu8 csma_retries;\n\ts8 frame_retries;\n\n\tbool lbt;\n\n\t \n\tbool ackreq;\n};\n\n#define to_phy(_dev)\tcontainer_of(_dev, struct wpan_phy, dev)\n\n#if IS_ENABLED(CONFIG_IEEE802154) || IS_ENABLED(CONFIG_6LOWPAN)\nstatic inline int\nwpan_dev_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t     const struct ieee802154_addr *daddr,\n\t\t     const struct ieee802154_addr *saddr,\n\t\t     unsigned int len)\n{\n\tstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\n\n\treturn wpan_dev->header_ops->create(skb, dev, daddr, saddr, len);\n}\n#endif\n\nstruct wpan_phy *\nwpan_phy_new(const struct cfg802154_ops *ops, size_t priv_size);\nstatic inline void wpan_phy_set_dev(struct wpan_phy *phy, struct device *dev)\n{\n\tphy->dev.parent = dev;\n}\n\nint wpan_phy_register(struct wpan_phy *phy);\nvoid wpan_phy_unregister(struct wpan_phy *phy);\nvoid wpan_phy_free(struct wpan_phy *phy);\n \nint wpan_phy_for_each(int (*fn)(struct wpan_phy *phy, void *data), void *data);\n\nstatic inline void *wpan_phy_priv(struct wpan_phy *phy)\n{\n\tBUG_ON(!phy);\n\treturn &phy->priv;\n}\n\nstruct wpan_phy *wpan_phy_find(const char *str);\n\nstatic inline void wpan_phy_put(struct wpan_phy *phy)\n{\n\tput_device(&phy->dev);\n}\n\nstatic inline const char *wpan_phy_name(struct wpan_phy *phy)\n{\n\treturn dev_name(&phy->dev);\n}\n\nvoid ieee802154_configure_durations(struct wpan_phy *phy,\n\t\t\t\t    unsigned int page, unsigned int channel);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}