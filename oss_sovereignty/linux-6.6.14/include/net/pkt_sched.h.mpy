{
  "module_name": "pkt_sched.h",
  "hash_id": "8609e743981bc281e1d7e8f2f12e9ba6f09a7bd4d3b3d2571613448098705c2a",
  "original_prompt": "Ingested from linux-6.6.14/include/net/pkt_sched.h",
  "human_readable_source": " \n#ifndef __NET_PKT_SCHED_H\n#define __NET_PKT_SCHED_H\n\n#include <linux/jiffies.h>\n#include <linux/ktime.h>\n#include <linux/if_vlan.h>\n#include <linux/netdevice.h>\n#include <net/sch_generic.h>\n#include <net/net_namespace.h>\n#include <uapi/linux/pkt_sched.h>\n\n#define DEFAULT_TX_QUEUE_LEN\t1000\n#define STAB_SIZE_LOG_MAX\t30\n\nstruct qdisc_walker {\n\tint\tstop;\n\tint\tskip;\n\tint\tcount;\n\tint\t(*fn)(struct Qdisc *, unsigned long cl, struct qdisc_walker *);\n};\n\nstatic inline void *qdisc_priv(struct Qdisc *q)\n{\n\treturn &q->privdata;\n}\n\nstatic inline struct Qdisc *qdisc_from_priv(void *priv)\n{\n\treturn container_of(priv, struct Qdisc, privdata);\n}\n\n \n\ntypedef u64\tpsched_time_t;\ntypedef long\tpsched_tdiff_t;\n\n \n#define PSCHED_SHIFT\t\t\t6\n#define PSCHED_TICKS2NS(x)\t\t((s64)(x) << PSCHED_SHIFT)\n#define PSCHED_NS2TICKS(x)\t\t((x) >> PSCHED_SHIFT)\n\n#define PSCHED_TICKS_PER_SEC\t\tPSCHED_NS2TICKS(NSEC_PER_SEC)\n#define PSCHED_PASTPERFECT\t\t0\n\nstatic inline psched_time_t psched_get_time(void)\n{\n\treturn PSCHED_NS2TICKS(ktime_get_ns());\n}\n\nstruct qdisc_watchdog {\n\tstruct hrtimer\ttimer;\n\tstruct Qdisc\t*qdisc;\n};\n\nvoid qdisc_watchdog_init_clockid(struct qdisc_watchdog *wd, struct Qdisc *qdisc,\n\t\t\t\t clockid_t clockid);\nvoid qdisc_watchdog_init(struct qdisc_watchdog *wd, struct Qdisc *qdisc);\n\nvoid qdisc_watchdog_schedule_range_ns(struct qdisc_watchdog *wd, u64 expires,\n\t\t\t\t      u64 delta_ns);\n\nstatic inline void qdisc_watchdog_schedule_ns(struct qdisc_watchdog *wd,\n\t\t\t\t\t      u64 expires)\n{\n\treturn qdisc_watchdog_schedule_range_ns(wd, expires, 0ULL);\n}\n\nstatic inline void qdisc_watchdog_schedule(struct qdisc_watchdog *wd,\n\t\t\t\t\t   psched_time_t expires)\n{\n\tqdisc_watchdog_schedule_ns(wd, PSCHED_TICKS2NS(expires));\n}\n\nvoid qdisc_watchdog_cancel(struct qdisc_watchdog *wd);\n\nextern struct Qdisc_ops pfifo_qdisc_ops;\nextern struct Qdisc_ops bfifo_qdisc_ops;\nextern struct Qdisc_ops pfifo_head_drop_qdisc_ops;\n\nint fifo_set_limit(struct Qdisc *q, unsigned int limit);\nstruct Qdisc *fifo_create_dflt(struct Qdisc *sch, struct Qdisc_ops *ops,\n\t\t\t       unsigned int limit,\n\t\t\t       struct netlink_ext_ack *extack);\n\nint register_qdisc(struct Qdisc_ops *qops);\nvoid unregister_qdisc(struct Qdisc_ops *qops);\nvoid qdisc_get_default(char *id, size_t len);\nint qdisc_set_default(const char *id);\n\nvoid qdisc_hash_add(struct Qdisc *q, bool invisible);\nvoid qdisc_hash_del(struct Qdisc *q);\nstruct Qdisc *qdisc_lookup(struct net_device *dev, u32 handle);\nstruct Qdisc *qdisc_lookup_rcu(struct net_device *dev, u32 handle);\nstruct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r,\n\t\t\t\t\tstruct nlattr *tab,\n\t\t\t\t\tstruct netlink_ext_ack *extack);\nvoid qdisc_put_rtab(struct qdisc_rate_table *tab);\nvoid qdisc_put_stab(struct qdisc_size_table *tab);\nvoid qdisc_warn_nonwc(const char *txt, struct Qdisc *qdisc);\nbool sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,\n\t\t     struct net_device *dev, struct netdev_queue *txq,\n\t\t     spinlock_t *root_lock, bool validate);\n\nvoid __qdisc_run(struct Qdisc *q);\n\nstatic inline void qdisc_run(struct Qdisc *q)\n{\n\tif (qdisc_run_begin(q)) {\n\t\t__qdisc_run(q);\n\t\tqdisc_run_end(q);\n\t}\n}\n\nextern const struct nla_policy rtm_tca_policy[TCA_MAX + 1];\n\n \nstatic inline unsigned int psched_mtu(const struct net_device *dev)\n{\n\treturn READ_ONCE(dev->mtu) + dev->hard_header_len;\n}\n\nstatic inline struct net *qdisc_net(struct Qdisc *q)\n{\n\treturn dev_net(q->dev_queue->dev);\n}\n\nstruct tc_query_caps_base {\n\tenum tc_setup_type type;\n\tvoid *caps;\n};\n\nstruct tc_cbs_qopt_offload {\n\tu8 enable;\n\ts32 queue;\n\ts32 hicredit;\n\ts32 locredit;\n\ts32 idleslope;\n\ts32 sendslope;\n};\n\nstruct tc_etf_qopt_offload {\n\tu8 enable;\n\ts32 queue;\n};\n\nstruct tc_mqprio_caps {\n\tbool validate_queue_counts:1;\n};\n\nstruct tc_mqprio_qopt_offload {\n\t \n\tstruct tc_mqprio_qopt qopt;\n\tstruct netlink_ext_ack *extack;\n\tu16 mode;\n\tu16 shaper;\n\tu32 flags;\n\tu64 min_rate[TC_QOPT_MAX_QUEUE];\n\tu64 max_rate[TC_QOPT_MAX_QUEUE];\n\tunsigned long preemptible_tcs;\n};\n\nstruct tc_taprio_caps {\n\tbool supports_queue_max_sdu:1;\n\tbool gate_mask_per_txq:1;\n\t \n\tbool broken_mqprio:1;\n};\n\nenum tc_taprio_qopt_cmd {\n\tTAPRIO_CMD_REPLACE,\n\tTAPRIO_CMD_DESTROY,\n\tTAPRIO_CMD_STATS,\n\tTAPRIO_CMD_QUEUE_STATS,\n};\n\n \nstruct tc_taprio_qopt_stats {\n\tu64 window_drops;\n\tu64 tx_overruns;\n};\n\nstruct tc_taprio_qopt_queue_stats {\n\tint queue;\n\tstruct tc_taprio_qopt_stats stats;\n};\n\nstruct tc_taprio_sched_entry {\n\tu8 command;  \n\n\t \n\tu32 gate_mask;\n\tu32 interval;\n};\n\nstruct tc_taprio_qopt_offload {\n\tenum tc_taprio_qopt_cmd cmd;\n\n\tunion {\n\t\t \n\t\tstruct tc_taprio_qopt_stats stats;\n\t\t \n\t\tstruct tc_taprio_qopt_queue_stats queue_stats;\n\t\t \n\t\tstruct {\n\t\t\tstruct tc_mqprio_qopt_offload mqprio;\n\t\t\tstruct netlink_ext_ack *extack;\n\t\t\tktime_t base_time;\n\t\t\tu64 cycle_time;\n\t\t\tu64 cycle_time_extension;\n\t\t\tu32 max_sdu[TC_MAX_QUEUE];\n\n\t\t\tsize_t num_entries;\n\t\t\tstruct tc_taprio_sched_entry entries[];\n\t\t};\n\t};\n};\n\n#if IS_ENABLED(CONFIG_NET_SCH_TAPRIO)\n\n \nstruct tc_taprio_qopt_offload *taprio_offload_get(struct tc_taprio_qopt_offload\n\t\t\t\t\t\t  *offload);\nvoid taprio_offload_free(struct tc_taprio_qopt_offload *offload);\n\n#else\n\n \nstatic inline struct tc_taprio_qopt_offload *\ntaprio_offload_get(struct tc_taprio_qopt_offload *offload)\n{\n\treturn NULL;\n}\n\nstatic inline void taprio_offload_free(struct tc_taprio_qopt_offload *offload)\n{\n}\n\n#endif\n\n \nstatic inline void skb_txtime_consumed(struct sk_buff *skb)\n{\n\tskb->tstamp = ktime_set(0, 0);\n}\n\nstruct tc_skb_cb {\n\tstruct qdisc_skb_cb qdisc_cb;\n\n\tu16 mru;\n\tu8 post_ct:1;\n\tu8 post_ct_snat:1;\n\tu8 post_ct_dnat:1;\n\tu16 zone;  \n};\n\nstatic inline struct tc_skb_cb *tc_skb_cb(const struct sk_buff *skb)\n{\n\tstruct tc_skb_cb *cb = (struct tc_skb_cb *)skb->cb;\n\n\tBUILD_BUG_ON(sizeof(*cb) > sizeof_field(struct sk_buff, cb));\n\treturn cb;\n}\n\nstatic inline bool tc_qdisc_stats_dump(struct Qdisc *sch,\n\t\t\t\t       unsigned long cl,\n\t\t\t\t       struct qdisc_walker *arg)\n{\n\tif (arg->count >= arg->skip && arg->fn(sch, cl, arg) < 0) {\n\t\targ->stop = 1;\n\t\treturn false;\n\t}\n\n\targ->count++;\n\treturn true;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}