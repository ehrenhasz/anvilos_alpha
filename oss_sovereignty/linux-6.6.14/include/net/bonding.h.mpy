{
  "module_name": "bonding.h",
  "hash_id": "148ac72fcaba17e781a8c49deae5913fe49475000bdc0c66c653e0ad1a96fd8f",
  "original_prompt": "Ingested from linux-6.6.14/include/net/bonding.h",
  "human_readable_source": " \n \n\n#ifndef _NET_BONDING_H\n#define _NET_BONDING_H\n\n#include <linux/timer.h>\n#include <linux/proc_fs.h>\n#include <linux/if_bonding.h>\n#include <linux/cpumask.h>\n#include <linux/in6.h>\n#include <linux/netpoll.h>\n#include <linux/inetdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/reciprocal_div.h>\n#include <linux/if_link.h>\n\n#include <net/bond_3ad.h>\n#include <net/bond_alb.h>\n#include <net/bond_options.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n\n#define BOND_MAX_ARP_TARGETS\t16\n#define BOND_MAX_NS_TARGETS\tBOND_MAX_ARP_TARGETS\n\n#define BOND_DEFAULT_MIIMON\t100\n\n#ifndef __long_aligned\n#define __long_aligned __attribute__((aligned((sizeof(long)))))\n#endif\n\n#define slave_info(bond_dev, slave_dev, fmt, ...) \\\n\tnetdev_info(bond_dev, \"(slave %s): \" fmt, (slave_dev)->name, ##__VA_ARGS__)\n#define slave_warn(bond_dev, slave_dev, fmt, ...) \\\n\tnetdev_warn(bond_dev, \"(slave %s): \" fmt, (slave_dev)->name, ##__VA_ARGS__)\n#define slave_dbg(bond_dev, slave_dev, fmt, ...) \\\n\tnetdev_dbg(bond_dev, \"(slave %s): \" fmt, (slave_dev)->name, ##__VA_ARGS__)\n#define slave_err(bond_dev, slave_dev, fmt, ...) \\\n\tnetdev_err(bond_dev, \"(slave %s): \" fmt, (slave_dev)->name, ##__VA_ARGS__)\n\n#define BOND_MODE(bond) ((bond)->params.mode)\n\n \n#define bond_slave_list(bond) (&(bond)->dev->adj_list.lower)\n\n#define bond_has_slaves(bond) !list_empty(bond_slave_list(bond))\n\n \n#define bond_first_slave(bond) \\\n\t(bond_has_slaves(bond) ? \\\n\t\tnetdev_adjacent_get_private(bond_slave_list(bond)->next) : \\\n\t\tNULL)\n#define bond_last_slave(bond) \\\n\t(bond_has_slaves(bond) ? \\\n\t\tnetdev_adjacent_get_private(bond_slave_list(bond)->prev) : \\\n\t\tNULL)\n\n \n#define bond_first_slave_rcu(bond) \\\n\tnetdev_lower_get_first_private_rcu(bond->dev)\n\n#define bond_is_first_slave(bond, pos) (pos == bond_first_slave(bond))\n#define bond_is_last_slave(bond, pos) (pos == bond_last_slave(bond))\n\n \n#define bond_for_each_slave(bond, pos, iter) \\\n\tnetdev_for_each_lower_private((bond)->dev, pos, iter)\n\n \n#define bond_for_each_slave_rcu(bond, pos, iter) \\\n\tnetdev_for_each_lower_private_rcu((bond)->dev, pos, iter)\n\n#define BOND_XFRM_FEATURES (NETIF_F_HW_ESP | NETIF_F_HW_ESP_TX_CSUM | \\\n\t\t\t    NETIF_F_GSO_ESP)\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nextern atomic_t netpoll_block_tx;\n\nstatic inline void block_netpoll_tx(void)\n{\n\tatomic_inc(&netpoll_block_tx);\n}\n\nstatic inline void unblock_netpoll_tx(void)\n{\n\tatomic_dec(&netpoll_block_tx);\n}\n\nstatic inline int is_netpoll_tx_blocked(struct net_device *dev)\n{\n\tif (unlikely(netpoll_tx_running(dev)))\n\t\treturn atomic_read(&netpoll_block_tx);\n\treturn 0;\n}\n#else\n#define block_netpoll_tx()\n#define unblock_netpoll_tx()\n#define is_netpoll_tx_blocked(dev) (0)\n#endif\n\nstruct bond_params {\n\tint mode;\n\tint xmit_policy;\n\tint miimon;\n\tu8 num_peer_notif;\n\tu8 missed_max;\n\tint arp_interval;\n\tint arp_validate;\n\tint arp_all_targets;\n\tint use_carrier;\n\tint fail_over_mac;\n\tint updelay;\n\tint downdelay;\n\tint peer_notif_delay;\n\tint lacp_active;\n\tint lacp_fast;\n\tunsigned int min_links;\n\tint ad_select;\n\tchar primary[IFNAMSIZ];\n\tint primary_reselect;\n\t__be32 arp_targets[BOND_MAX_ARP_TARGETS];\n\tint tx_queues;\n\tint all_slaves_active;\n\tint resend_igmp;\n\tint lp_interval;\n\tint packets_per_slave;\n\tint tlb_dynamic_lb;\n\tstruct reciprocal_value reciprocal_packets_per_slave;\n\tu16 ad_actor_sys_prio;\n\tu16 ad_user_port_key;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct in6_addr ns_targets[BOND_MAX_NS_TARGETS];\n#endif\n\n\t \n\tu8 ad_actor_system[ETH_ALEN + 2];\n};\n\nstruct slave {\n\tstruct net_device *dev;  \n\tstruct bonding *bond;  \n\tint    delay;\n\t \n\tunsigned long last_link_up;\n\tunsigned long last_tx;\n\tunsigned long last_rx;\n\tunsigned long target_last_arp_rx[BOND_MAX_ARP_TARGETS];\n\ts8     link;\t\t \n\ts8     link_new_state;\t \n\tu8     backup:1,    \n\t       inactive:1,  \n\t       should_notify:1,  \n\t       should_notify_link:1;  \n\tu8     duplex;\n\tu32    original_mtu;\n\tu32    link_failure_count;\n\tu32    speed;\n\tu16    queue_id;\n\tu8     perm_hwaddr[MAX_ADDR_LEN];\n\tint    prio;\n\tstruct ad_slave_info *ad_info;\n\tstruct tlb_slave_info tlb_info;\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\tstruct netpoll *np;\n#endif\n\tstruct delayed_work notify_work;\n\tstruct kobject kobj;\n\tstruct rtnl_link_stats64 slave_stats;\n};\n\nstatic inline struct slave *to_slave(struct kobject *kobj)\n{\n\treturn container_of(kobj, struct slave, kobj);\n}\n\nstruct bond_up_slave {\n\tunsigned int\tcount;\n\tstruct rcu_head rcu;\n\tstruct slave\t*arr[];\n};\n\n \n#define BOND_LINK_NOCHANGE -1\n\nstruct bond_ipsec {\n\tstruct list_head list;\n\tstruct xfrm_state *xs;\n};\n\n \nstruct bonding {\n\tstruct   net_device *dev;  \n\tstruct   slave __rcu *curr_active_slave;\n\tstruct   slave __rcu *current_arp_slave;\n\tstruct   slave __rcu *primary_slave;\n\tstruct   bond_up_slave __rcu *usable_slaves;\n\tstruct   bond_up_slave __rcu *all_slaves;\n\tbool     force_primary;\n\tbool     notifier_ctx;\n\ts32      slave_cnt;  \n\tint     (*recv_probe)(const struct sk_buff *, struct bonding *,\n\t\t\t      struct slave *);\n\t \n\tspinlock_t mode_lock;\n\tspinlock_t stats_lock;\n\tu32\t send_peer_notif;\n\tu8       igmp_retrans;\n#ifdef CONFIG_PROC_FS\n\tstruct   proc_dir_entry *proc_entry;\n\tchar     proc_file_name[IFNAMSIZ];\n#endif  \n\tstruct   list_head bond_list;\n\tu32 __percpu *rr_tx_counter;\n\tstruct   ad_bond_info ad_info;\n\tstruct   alb_bond_info alb_info;\n\tstruct   bond_params params;\n\tstruct   workqueue_struct *wq;\n\tstruct   delayed_work mii_work;\n\tstruct   delayed_work arp_work;\n\tstruct   delayed_work alb_work;\n\tstruct   delayed_work ad_work;\n\tstruct   delayed_work mcast_work;\n\tstruct   delayed_work slave_arr_work;\n#ifdef CONFIG_DEBUG_FS\n\t \n\tstruct\t dentry *debug_dir;\n#endif  \n\tstruct rtnl_link_stats64 bond_stats;\n#ifdef CONFIG_XFRM_OFFLOAD\n\tstruct list_head ipsec_list;\n\t \n\tspinlock_t ipsec_lock;\n#endif  \n\tstruct bpf_prog *xdp_prog;\n};\n\n#define bond_slave_get_rcu(dev) \\\n\t((struct slave *) rcu_dereference(dev->rx_handler_data))\n\n#define bond_slave_get_rtnl(dev) \\\n\t((struct slave *) rtnl_dereference(dev->rx_handler_data))\n\nvoid bond_queue_slave_event(struct slave *slave);\nvoid bond_lower_state_changed(struct slave *slave);\n\nstruct bond_vlan_tag {\n\t__be16\t\tvlan_proto;\n\tunsigned short\tvlan_id;\n};\n\n \nstatic inline struct slave *bond_get_slave_by_dev(struct bonding *bond,\n\t\t\t\t\t\t  struct net_device *slave_dev)\n{\n\treturn netdev_lower_dev_get_private(bond->dev, slave_dev);\n}\n\nstatic inline struct bonding *bond_get_bond_by_slave(struct slave *slave)\n{\n\treturn slave->bond;\n}\n\nstatic inline bool bond_should_override_tx_queue(struct bonding *bond)\n{\n\treturn BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP ||\n\t       BOND_MODE(bond) == BOND_MODE_ROUNDROBIN;\n}\n\nstatic inline bool bond_is_lb(const struct bonding *bond)\n{\n\treturn BOND_MODE(bond) == BOND_MODE_TLB ||\n\t       BOND_MODE(bond) == BOND_MODE_ALB;\n}\n\nstatic inline bool bond_needs_speed_duplex(const struct bonding *bond)\n{\n\treturn BOND_MODE(bond) == BOND_MODE_8023AD || bond_is_lb(bond);\n}\n\nstatic inline bool bond_is_nondyn_tlb(const struct bonding *bond)\n{\n\treturn (bond_is_lb(bond) && bond->params.tlb_dynamic_lb == 0);\n}\n\nstatic inline bool bond_mode_can_use_xmit_hash(const struct bonding *bond)\n{\n\treturn (BOND_MODE(bond) == BOND_MODE_8023AD ||\n\t\tBOND_MODE(bond) == BOND_MODE_XOR ||\n\t\tBOND_MODE(bond) == BOND_MODE_TLB ||\n\t\tBOND_MODE(bond) == BOND_MODE_ALB);\n}\n\nstatic inline bool bond_mode_uses_xmit_hash(const struct bonding *bond)\n{\n\treturn (BOND_MODE(bond) == BOND_MODE_8023AD ||\n\t\tBOND_MODE(bond) == BOND_MODE_XOR ||\n\t\tbond_is_nondyn_tlb(bond));\n}\n\nstatic inline bool bond_mode_uses_arp(int mode)\n{\n\treturn mode != BOND_MODE_8023AD && mode != BOND_MODE_TLB &&\n\t       mode != BOND_MODE_ALB;\n}\n\nstatic inline bool bond_mode_uses_primary(int mode)\n{\n\treturn mode == BOND_MODE_ACTIVEBACKUP || mode == BOND_MODE_TLB ||\n\t       mode == BOND_MODE_ALB;\n}\n\nstatic inline bool bond_uses_primary(struct bonding *bond)\n{\n\treturn bond_mode_uses_primary(BOND_MODE(bond));\n}\n\nstatic inline struct net_device *bond_option_active_slave_get_rcu(struct bonding *bond)\n{\n\tstruct slave *slave = rcu_dereference_rtnl(bond->curr_active_slave);\n\n\treturn bond_uses_primary(bond) && slave ? slave->dev : NULL;\n}\n\nstatic inline bool bond_slave_is_up(struct slave *slave)\n{\n\treturn netif_running(slave->dev) && netif_carrier_ok(slave->dev);\n}\n\nstatic inline void bond_set_active_slave(struct slave *slave)\n{\n\tif (slave->backup) {\n\t\tslave->backup = 0;\n\t\tbond_queue_slave_event(slave);\n\t\tbond_lower_state_changed(slave);\n\t}\n}\n\nstatic inline void bond_set_backup_slave(struct slave *slave)\n{\n\tif (!slave->backup) {\n\t\tslave->backup = 1;\n\t\tbond_queue_slave_event(slave);\n\t\tbond_lower_state_changed(slave);\n\t}\n}\n\nstatic inline void bond_set_slave_state(struct slave *slave,\n\t\t\t\t\tint slave_state, bool notify)\n{\n\tif (slave->backup == slave_state)\n\t\treturn;\n\n\tslave->backup = slave_state;\n\tif (notify) {\n\t\tbond_lower_state_changed(slave);\n\t\tbond_queue_slave_event(slave);\n\t\tslave->should_notify = 0;\n\t} else {\n\t\tif (slave->should_notify)\n\t\t\tslave->should_notify = 0;\n\t\telse\n\t\t\tslave->should_notify = 1;\n\t}\n}\n\nstatic inline void bond_slave_state_change(struct bonding *bond)\n{\n\tstruct list_head *iter;\n\tstruct slave *tmp;\n\n\tbond_for_each_slave(bond, tmp, iter) {\n\t\tif (tmp->link == BOND_LINK_UP)\n\t\t\tbond_set_active_slave(tmp);\n\t\telse if (tmp->link == BOND_LINK_DOWN)\n\t\t\tbond_set_backup_slave(tmp);\n\t}\n}\n\nstatic inline void bond_slave_state_notify(struct bonding *bond)\n{\n\tstruct list_head *iter;\n\tstruct slave *tmp;\n\n\tbond_for_each_slave(bond, tmp, iter) {\n\t\tif (tmp->should_notify) {\n\t\t\tbond_lower_state_changed(tmp);\n\t\t\ttmp->should_notify = 0;\n\t\t}\n\t}\n}\n\nstatic inline int bond_slave_state(struct slave *slave)\n{\n\treturn slave->backup;\n}\n\nstatic inline bool bond_is_active_slave(struct slave *slave)\n{\n\treturn !bond_slave_state(slave);\n}\n\nstatic inline bool bond_slave_can_tx(struct slave *slave)\n{\n\treturn bond_slave_is_up(slave) && slave->link == BOND_LINK_UP &&\n\t       bond_is_active_slave(slave);\n}\n\nstatic inline bool bond_is_active_slave_dev(const struct net_device *slave_dev)\n{\n\tstruct slave *slave;\n\tbool active;\n\n\trcu_read_lock();\n\tslave = bond_slave_get_rcu(slave_dev);\n\tactive = bond_is_active_slave(slave);\n\trcu_read_unlock();\n\n\treturn active;\n}\n\nstatic inline void bond_hw_addr_copy(u8 *dst, const u8 *src, unsigned int len)\n{\n\tif (len == ETH_ALEN) {\n\t\tether_addr_copy(dst, src);\n\t\treturn;\n\t}\n\n\tmemcpy(dst, src, len);\n}\n\n#define BOND_PRI_RESELECT_ALWAYS\t0\n#define BOND_PRI_RESELECT_BETTER\t1\n#define BOND_PRI_RESELECT_FAILURE\t2\n\n#define BOND_FOM_NONE\t\t\t0\n#define BOND_FOM_ACTIVE\t\t\t1\n#define BOND_FOM_FOLLOW\t\t\t2\n\n#define BOND_ARP_TARGETS_ANY\t\t0\n#define BOND_ARP_TARGETS_ALL\t\t1\n\n#define BOND_ARP_VALIDATE_NONE\t\t0\n#define BOND_ARP_VALIDATE_ACTIVE\t(1 << BOND_STATE_ACTIVE)\n#define BOND_ARP_VALIDATE_BACKUP\t(1 << BOND_STATE_BACKUP)\n#define BOND_ARP_VALIDATE_ALL\t\t(BOND_ARP_VALIDATE_ACTIVE | \\\n\t\t\t\t\t BOND_ARP_VALIDATE_BACKUP)\n#define BOND_ARP_FILTER\t\t\t(BOND_ARP_VALIDATE_ALL + 1)\n#define BOND_ARP_FILTER_ACTIVE\t\t(BOND_ARP_VALIDATE_ACTIVE | \\\n\t\t\t\t\t BOND_ARP_FILTER)\n#define BOND_ARP_FILTER_BACKUP\t\t(BOND_ARP_VALIDATE_BACKUP | \\\n\t\t\t\t\t BOND_ARP_FILTER)\n\n#define BOND_SLAVE_NOTIFY_NOW\t\ttrue\n#define BOND_SLAVE_NOTIFY_LATER\t\tfalse\n\nstatic inline int slave_do_arp_validate(struct bonding *bond,\n\t\t\t\t\tstruct slave *slave)\n{\n\treturn bond->params.arp_validate & (1 << bond_slave_state(slave));\n}\n\nstatic inline int slave_do_arp_validate_only(struct bonding *bond)\n{\n\treturn bond->params.arp_validate & BOND_ARP_FILTER;\n}\n\nstatic inline int bond_is_ip_target_ok(__be32 addr)\n{\n\treturn !ipv4_is_lbcast(addr) && !ipv4_is_zeronet(addr);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline int bond_is_ip6_target_ok(struct in6_addr *addr)\n{\n\treturn !ipv6_addr_any(addr) &&\n\t       !ipv6_addr_loopback(addr) &&\n\t       !ipv6_addr_is_multicast(addr);\n}\n#endif\n\n \nstatic inline unsigned long slave_oldest_target_arp_rx(struct bonding *bond,\n\t\t\t\t\t\t       struct slave *slave)\n{\n\tint i = 1;\n\tunsigned long ret = slave->target_last_arp_rx[0];\n\n\tfor (; (i < BOND_MAX_ARP_TARGETS) && bond->params.arp_targets[i]; i++)\n\t\tif (time_before(slave->target_last_arp_rx[i], ret))\n\t\t\tret = slave->target_last_arp_rx[i];\n\n\treturn ret;\n}\n\nstatic inline unsigned long slave_last_rx(struct bonding *bond,\n\t\t\t\t\tstruct slave *slave)\n{\n\tif (bond->params.arp_all_targets == BOND_ARP_TARGETS_ALL)\n\t\treturn slave_oldest_target_arp_rx(bond, slave);\n\n\treturn slave->last_rx;\n}\n\nstatic inline void slave_update_last_tx(struct slave *slave)\n{\n\tWRITE_ONCE(slave->last_tx, jiffies);\n}\n\nstatic inline unsigned long slave_last_tx(struct slave *slave)\n{\n\treturn READ_ONCE(slave->last_tx);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic inline netdev_tx_t bond_netpoll_send_skb(const struct slave *slave,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\treturn netpoll_send_skb(slave->np, skb);\n}\n#else\nstatic inline netdev_tx_t bond_netpoll_send_skb(const struct slave *slave,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tBUG();\n\treturn NETDEV_TX_OK;\n}\n#endif\n\nstatic inline void bond_set_slave_inactive_flags(struct slave *slave,\n\t\t\t\t\t\t bool notify)\n{\n\tif (!bond_is_lb(slave->bond))\n\t\tbond_set_slave_state(slave, BOND_STATE_BACKUP, notify);\n\tif (!slave->bond->params.all_slaves_active)\n\t\tslave->inactive = 1;\n}\n\nstatic inline void bond_set_slave_active_flags(struct slave *slave,\n\t\t\t\t\t       bool notify)\n{\n\tbond_set_slave_state(slave, BOND_STATE_ACTIVE, notify);\n\tslave->inactive = 0;\n}\n\nstatic inline bool bond_is_slave_inactive(struct slave *slave)\n{\n\treturn slave->inactive;\n}\n\nstatic inline void bond_propose_link_state(struct slave *slave, int state)\n{\n\tslave->link_new_state = state;\n}\n\nstatic inline void bond_commit_link_state(struct slave *slave, bool notify)\n{\n\tif (slave->link_new_state == BOND_LINK_NOCHANGE)\n\t\treturn;\n\n\tslave->link = slave->link_new_state;\n\tif (notify) {\n\t\tbond_queue_slave_event(slave);\n\t\tbond_lower_state_changed(slave);\n\t\tslave->should_notify_link = 0;\n\t} else {\n\t\tif (slave->should_notify_link)\n\t\t\tslave->should_notify_link = 0;\n\t\telse\n\t\t\tslave->should_notify_link = 1;\n\t}\n}\n\nstatic inline void bond_set_slave_link_state(struct slave *slave, int state,\n\t\t\t\t\t     bool notify)\n{\n\tbond_propose_link_state(slave, state);\n\tbond_commit_link_state(slave, notify);\n}\n\nstatic inline void bond_slave_link_notify(struct bonding *bond)\n{\n\tstruct list_head *iter;\n\tstruct slave *tmp;\n\n\tbond_for_each_slave(bond, tmp, iter) {\n\t\tif (tmp->should_notify_link) {\n\t\t\tbond_queue_slave_event(tmp);\n\t\t\tbond_lower_state_changed(tmp);\n\t\t\ttmp->should_notify_link = 0;\n\t\t}\n\t}\n}\n\nstatic inline __be32 bond_confirm_addr(struct net_device *dev, __be32 dst, __be32 local)\n{\n\tstruct in_device *in_dev;\n\t__be32 addr = 0;\n\n\trcu_read_lock();\n\tin_dev = __in_dev_get_rcu(dev);\n\n\tif (in_dev)\n\t\taddr = inet_confirm_addr(dev_net(dev), in_dev, dst, local,\n\t\t\t\t\t RT_SCOPE_HOST);\n\trcu_read_unlock();\n\treturn addr;\n}\n\nstruct bond_net {\n\tstruct net\t\t*net;\t \n\tstruct list_head\tdev_list;\n#ifdef CONFIG_PROC_FS\n\tstruct proc_dir_entry\t*proc_dir;\n#endif\n\tstruct class_attribute\tclass_attr_bonding_masters;\n};\n\nint bond_rcv_validate(const struct sk_buff *skb, struct bonding *bond, struct slave *slave);\nnetdev_tx_t bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb, struct net_device *slave_dev);\nint bond_create(struct net *net, const char *name);\nint bond_create_sysfs(struct bond_net *net);\nvoid bond_destroy_sysfs(struct bond_net *net);\nvoid bond_prepare_sysfs_group(struct bonding *bond);\nint bond_sysfs_slave_add(struct slave *slave);\nvoid bond_sysfs_slave_del(struct slave *slave);\nvoid bond_xdp_set_features(struct net_device *bond_dev);\nint bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev,\n\t\t struct netlink_ext_ack *extack);\nint bond_release(struct net_device *bond_dev, struct net_device *slave_dev);\nu32 bond_xmit_hash(struct bonding *bond, struct sk_buff *skb);\nint bond_set_carrier(struct bonding *bond);\nvoid bond_select_active_slave(struct bonding *bond);\nvoid bond_change_active_slave(struct bonding *bond, struct slave *new_active);\nvoid bond_create_debugfs(void);\nvoid bond_destroy_debugfs(void);\nvoid bond_debug_register(struct bonding *bond);\nvoid bond_debug_unregister(struct bonding *bond);\nvoid bond_debug_reregister(struct bonding *bond);\nconst char *bond_mode_name(int mode);\nvoid bond_setup(struct net_device *bond_dev);\nunsigned int bond_get_num_tx_queues(void);\nint bond_netlink_init(void);\nvoid bond_netlink_fini(void);\nstruct net_device *bond_option_active_slave_get_rcu(struct bonding *bond);\nconst char *bond_slave_link_status(s8 link);\nstruct bond_vlan_tag *bond_verify_device_path(struct net_device *start_dev,\n\t\t\t\t\t      struct net_device *end_dev,\n\t\t\t\t\t      int level);\nint bond_update_slave_arr(struct bonding *bond, struct slave *skipslave);\nvoid bond_slave_arr_work_rearm(struct bonding *bond, unsigned long delay);\nvoid bond_work_init_all(struct bonding *bond);\n\n#ifdef CONFIG_PROC_FS\nvoid bond_create_proc_entry(struct bonding *bond);\nvoid bond_remove_proc_entry(struct bonding *bond);\nvoid bond_create_proc_dir(struct bond_net *bn);\nvoid bond_destroy_proc_dir(struct bond_net *bn);\n#else\nstatic inline void bond_create_proc_entry(struct bonding *bond)\n{\n}\n\nstatic inline void bond_remove_proc_entry(struct bonding *bond)\n{\n}\n\nstatic inline void bond_create_proc_dir(struct bond_net *bn)\n{\n}\n\nstatic inline void bond_destroy_proc_dir(struct bond_net *bn)\n{\n}\n#endif\n\nstatic inline struct slave *bond_slave_has_mac(struct bonding *bond,\n\t\t\t\t\t       const u8 *mac)\n{\n\tstruct list_head *iter;\n\tstruct slave *tmp;\n\n\tbond_for_each_slave(bond, tmp, iter)\n\t\tif (ether_addr_equal_64bits(mac, tmp->dev->dev_addr))\n\t\t\treturn tmp;\n\n\treturn NULL;\n}\n\n \nstatic inline bool bond_slave_has_mac_rcu(struct bonding *bond, const u8 *mac)\n{\n\tstruct list_head *iter;\n\tstruct slave *tmp;\n\n\tbond_for_each_slave_rcu(bond, tmp, iter)\n\t\tif (ether_addr_equal_64bits(mac, tmp->dev->dev_addr))\n\t\t\treturn true;\n\treturn false;\n}\n\n \nstatic inline int bond_get_targets_ip(__be32 *targets, __be32 ip)\n{\n\tint i;\n\n\tfor (i = 0; i < BOND_MAX_ARP_TARGETS; i++)\n\t\tif (targets[i] == ip)\n\t\t\treturn i;\n\t\telse if (targets[i] == 0)\n\t\t\tbreak;\n\n\treturn -1;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline int bond_get_targets_ip6(struct in6_addr *targets, struct in6_addr *ip)\n{\n\tstruct in6_addr mcaddr;\n\tint i;\n\n\tfor (i = 0; i < BOND_MAX_NS_TARGETS; i++) {\n\t\taddrconf_addr_solict_mult(&targets[i], &mcaddr);\n\t\tif ((ipv6_addr_equal(&targets[i], ip)) ||\n\t\t    (ipv6_addr_equal(&mcaddr, ip)))\n\t\t\treturn i;\n\t\telse if (ipv6_addr_any(&targets[i]))\n\t\t\tbreak;\n\t}\n\n\treturn -1;\n}\n#endif\n\n \nextern unsigned int bond_net_id;\n\n \nextern struct rtnl_link_ops bond_link_ops;\n\n \nextern const struct sysfs_ops slave_sysfs_ops;\n\n \nextern const u8 lacpdu_mcast_addr[];\n\nstatic inline netdev_tx_t bond_tx_drop(struct net_device *dev, struct sk_buff *skb)\n{\n\tdev_core_stats_tx_dropped_inc(dev);\n\tdev_kfree_skb_any(skb);\n\treturn NET_XMIT_DROP;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}