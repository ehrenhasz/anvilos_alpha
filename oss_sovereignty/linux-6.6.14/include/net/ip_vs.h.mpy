{
  "module_name": "ip_vs.h",
  "hash_id": "36fe2ceb392784b180c2cd61573f318c8b1f2655171b9d41ff21a3284b364cba",
  "original_prompt": "Ingested from linux-6.6.14/include/net/ip_vs.h",
  "human_readable_source": " \n \n\n#ifndef _NET_IP_VS_H\n#define _NET_IP_VS_H\n\n#include <linux/ip_vs.h>                 \n\n#include <asm/types.h>                   \n\n#include <linux/list.h>                  \n#include <linux/spinlock.h>              \n#include <linux/atomic.h>                \n#include <linux/refcount.h>              \n#include <linux/workqueue.h>\n\n#include <linux/compiler.h>\n#include <linux/timer.h>\n#include <linux/bug.h>\n\n#include <net/checksum.h>\n#include <linux/netfilter.h>\t\t \n#include <linux/ip.h>\n#include <linux/ipv6.h>\t\t\t \n#include <net/ipv6.h>\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#include <net/netfilter/nf_conntrack.h>\n#endif\n#include <net/net_namespace.h>\t\t \n#include <linux/sched/isolation.h>\n\n#define IP_VS_HDR_INVERSE\t1\n#define IP_VS_HDR_ICMP\t\t2\n\n \nstatic inline struct netns_ipvs *net_ipvs(struct net* net)\n{\n\treturn net->ipvs;\n}\n\n \nextern int ip_vs_conn_tab_size;\n\nextern struct mutex __ip_vs_mutex;\n\nstruct ip_vs_iphdr {\n\tint hdr_flags;\t \n\t__u32 off;\t \n\t__u32 len;\t \n\t__u16 fragoffs;  \n\t__s16 protocol;\n\t__s32 flags;\n\tunion nf_inet_addr saddr;\n\tunion nf_inet_addr daddr;\n};\n\nstatic inline void *frag_safe_skb_hp(const struct sk_buff *skb, int offset,\n\t\t\t\t      int len, void *buffer)\n{\n\treturn skb_header_pointer(skb, offset, len, buffer);\n}\n\n \nstatic inline int\nip_vs_fill_iph_skb_off(int af, const struct sk_buff *skb, int offset,\n\t\t       int hdr_flags, struct ip_vs_iphdr *iphdr)\n{\n\tiphdr->hdr_flags = hdr_flags;\n\tiphdr->off = offset;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6) {\n\t\tstruct ipv6hdr _iph;\n\t\tconst struct ipv6hdr *iph = skb_header_pointer(\n\t\t\tskb, offset, sizeof(_iph), &_iph);\n\t\tif (!iph)\n\t\t\treturn 0;\n\n\t\tiphdr->saddr.in6 = iph->saddr;\n\t\tiphdr->daddr.in6 = iph->daddr;\n\t\t \n\t\tiphdr->len\t = offset;\n\t\tiphdr->flags\t = 0;\n\t\tiphdr->protocol  = ipv6_find_hdr(skb, &iphdr->len, -1,\n\t\t\t\t\t\t &iphdr->fragoffs,\n\t\t\t\t\t\t &iphdr->flags);\n\t\tif (iphdr->protocol < 0)\n\t\t\treturn 0;\n\t} else\n#endif\n\t{\n\t\tstruct iphdr _iph;\n\t\tconst struct iphdr *iph = skb_header_pointer(\n\t\t\tskb, offset, sizeof(_iph), &_iph);\n\t\tif (!iph)\n\t\t\treturn 0;\n\n\t\tiphdr->len\t= offset + iph->ihl * 4;\n\t\tiphdr->fragoffs\t= 0;\n\t\tiphdr->protocol\t= iph->protocol;\n\t\tiphdr->saddr.ip\t= iph->saddr;\n\t\tiphdr->daddr.ip\t= iph->daddr;\n\t}\n\n\treturn 1;\n}\n\nstatic inline int\nip_vs_fill_iph_skb_icmp(int af, const struct sk_buff *skb, int offset,\n\t\t\tbool inverse, struct ip_vs_iphdr *iphdr)\n{\n\tint hdr_flags = IP_VS_HDR_ICMP;\n\n\tif (inverse)\n\t\thdr_flags |= IP_VS_HDR_INVERSE;\n\n\treturn ip_vs_fill_iph_skb_off(af, skb, offset, hdr_flags, iphdr);\n}\n\nstatic inline int\nip_vs_fill_iph_skb(int af, const struct sk_buff *skb, bool inverse,\n\t\t   struct ip_vs_iphdr *iphdr)\n{\n\tint hdr_flags = 0;\n\n\tif (inverse)\n\t\thdr_flags |= IP_VS_HDR_INVERSE;\n\n\treturn ip_vs_fill_iph_skb_off(af, skb, skb_network_offset(skb),\n\t\t\t\t      hdr_flags, iphdr);\n}\n\nstatic inline bool\nip_vs_iph_inverse(const struct ip_vs_iphdr *iph)\n{\n\treturn !!(iph->hdr_flags & IP_VS_HDR_INVERSE);\n}\n\nstatic inline bool\nip_vs_iph_icmp(const struct ip_vs_iphdr *iph)\n{\n\treturn !!(iph->hdr_flags & IP_VS_HDR_ICMP);\n}\n\nstatic inline void ip_vs_addr_copy(int af, union nf_inet_addr *dst,\n\t\t\t\t   const union nf_inet_addr *src)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\tdst->in6 = src->in6;\n\telse\n#endif\n\tdst->ip = src->ip;\n}\n\nstatic inline void ip_vs_addr_set(int af, union nf_inet_addr *dst,\n\t\t\t\t  const union nf_inet_addr *src)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6) {\n\t\tdst->in6 = src->in6;\n\t\treturn;\n\t}\n#endif\n\tdst->ip = src->ip;\n\tdst->all[1] = 0;\n\tdst->all[2] = 0;\n\tdst->all[3] = 0;\n}\n\nstatic inline int ip_vs_addr_equal(int af, const union nf_inet_addr *a,\n\t\t\t\t   const union nf_inet_addr *b)\n{\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\treturn ipv6_addr_equal(&a->in6, &b->in6);\n#endif\n\treturn a->ip == b->ip;\n}\n\n#ifdef CONFIG_IP_VS_DEBUG\n#include <linux/net.h>\n\nint ip_vs_get_debug_level(void);\n\nstatic inline const char *ip_vs_dbg_addr(int af, char *buf, size_t buf_len,\n\t\t\t\t\t const union nf_inet_addr *addr,\n\t\t\t\t\t int *idx)\n{\n\tint len;\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\tlen = snprintf(&buf[*idx], buf_len - *idx, \"[%pI6c]\",\n\t\t\t       &addr->in6) + 1;\n\telse\n#endif\n\t\tlen = snprintf(&buf[*idx], buf_len - *idx, \"%pI4\",\n\t\t\t       &addr->ip) + 1;\n\n\t*idx += len;\n\tBUG_ON(*idx > buf_len + 1);\n\treturn &buf[*idx - len];\n}\n\n#define IP_VS_DBG_BUF(level, msg, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tchar ip_vs_dbg_buf[160];\t\t\t\t\\\n\t\tint ip_vs_dbg_idx = 0;\t\t\t\t\t\\\n\t\tif (level <= ip_vs_get_debug_level())\t\t\t\\\n\t\t\tprintk(KERN_DEBUG pr_fmt(msg), ##__VA_ARGS__);\t\\\n\t} while (0)\n#define IP_VS_ERR_BUF(msg...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tchar ip_vs_dbg_buf[160];\t\t\t\t\\\n\t\tint ip_vs_dbg_idx = 0;\t\t\t\t\t\\\n\t\tpr_err(msg);\t\t\t\t\t\t\\\n\t} while (0)\n\n \n#define IP_VS_DBG_ADDR(af, addr)\t\t\t\t\t\\\n\tip_vs_dbg_addr(af, ip_vs_dbg_buf,\t\t\t\t\\\n\t\t       sizeof(ip_vs_dbg_buf), addr,\t\t\t\\\n\t\t       &ip_vs_dbg_idx)\n\n#define IP_VS_DBG(level, msg, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (level <= ip_vs_get_debug_level())\t\t\t\\\n\t\t\tprintk(KERN_DEBUG pr_fmt(msg), ##__VA_ARGS__);\t\\\n\t} while (0)\n#define IP_VS_DBG_RL(msg, ...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (net_ratelimit())\t\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG pr_fmt(msg), ##__VA_ARGS__);\t\\\n\t} while (0)\n#define IP_VS_DBG_PKT(level, af, pp, skb, ofs, msg)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (level <= ip_vs_get_debug_level())\t\t\t\\\n\t\t\tpp->debug_packet(af, pp, skb, ofs, msg);\t\\\n\t} while (0)\n#define IP_VS_DBG_RL_PKT(level, af, pp, skb, ofs, msg)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (level <= ip_vs_get_debug_level() &&\t\t\t\\\n\t\t    net_ratelimit())\t\t\t\t\t\\\n\t\t\tpp->debug_packet(af, pp, skb, ofs, msg);\t\\\n\t} while (0)\n#else\t \n#define IP_VS_DBG_BUF(level, msg...)  do {} while (0)\n#define IP_VS_ERR_BUF(msg...)  do {} while (0)\n#define IP_VS_DBG(level, msg...)  do {} while (0)\n#define IP_VS_DBG_RL(msg...)  do {} while (0)\n#define IP_VS_DBG_PKT(level, af, pp, skb, ofs, msg)\tdo {} while (0)\n#define IP_VS_DBG_RL_PKT(level, af, pp, skb, ofs, msg)\tdo {} while (0)\n#endif\n\n#define IP_VS_BUG() BUG()\n#define IP_VS_ERR_RL(msg, ...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (net_ratelimit())\t\t\t\t\t\\\n\t\t\tpr_err(msg, ##__VA_ARGS__);\t\t\t\\\n\t} while (0)\n\n \n#define FTPPORT  cpu_to_be16(21)\n#define FTPDATA  cpu_to_be16(20)\n\n \nenum {\n\tIP_VS_TCP_S_NONE = 0,\n\tIP_VS_TCP_S_ESTABLISHED,\n\tIP_VS_TCP_S_SYN_SENT,\n\tIP_VS_TCP_S_SYN_RECV,\n\tIP_VS_TCP_S_FIN_WAIT,\n\tIP_VS_TCP_S_TIME_WAIT,\n\tIP_VS_TCP_S_CLOSE,\n\tIP_VS_TCP_S_CLOSE_WAIT,\n\tIP_VS_TCP_S_LAST_ACK,\n\tIP_VS_TCP_S_LISTEN,\n\tIP_VS_TCP_S_SYNACK,\n\tIP_VS_TCP_S_LAST\n};\n\n \nenum {\n\tIP_VS_UDP_S_NORMAL,\n\tIP_VS_UDP_S_LAST,\n};\n\n \nenum {\n\tIP_VS_ICMP_S_NORMAL,\n\tIP_VS_ICMP_S_LAST,\n};\n\n \nenum ip_vs_sctp_states {\n\tIP_VS_SCTP_S_NONE,\n\tIP_VS_SCTP_S_INIT1,\n\tIP_VS_SCTP_S_INIT,\n\tIP_VS_SCTP_S_COOKIE_SENT,\n\tIP_VS_SCTP_S_COOKIE_REPLIED,\n\tIP_VS_SCTP_S_COOKIE_WAIT,\n\tIP_VS_SCTP_S_COOKIE,\n\tIP_VS_SCTP_S_COOKIE_ECHOED,\n\tIP_VS_SCTP_S_ESTABLISHED,\n\tIP_VS_SCTP_S_SHUTDOWN_SENT,\n\tIP_VS_SCTP_S_SHUTDOWN_RECEIVED,\n\tIP_VS_SCTP_S_SHUTDOWN_ACK_SENT,\n\tIP_VS_SCTP_S_REJECTED,\n\tIP_VS_SCTP_S_CLOSED,\n\tIP_VS_SCTP_S_LAST\n};\n\n \n#define IP_VS_CTPL_S_NONE\t\t0x0000\n#define IP_VS_CTPL_S_ASSURED\t\t0x0001\n#define IP_VS_CTPL_S_LAST\t\t0x0002\n\n \nstruct ip_vs_seq {\n\t__u32\t\t\tinit_seq;\t \n\t__u32\t\t\tdelta;\t\t \n\t__u32\t\t\tprevious_delta;\t \n};\n\n \nstruct ip_vs_counters {\n\tu64_stats_t\tconns;\t\t \n\tu64_stats_t\tinpkts;\t\t \n\tu64_stats_t\toutpkts;\t \n\tu64_stats_t\tinbytes;\t \n\tu64_stats_t\toutbytes;\t \n};\n \nstruct ip_vs_cpu_stats {\n\tstruct ip_vs_counters   cnt;\n\tstruct u64_stats_sync   syncp;\n};\n\n \n#define IPVS_EST_NICE\t\t0\n\n \nstruct ip_vs_estimator {\n\tstruct hlist_node\tlist;\n\n\tu64\t\t\tlast_inbytes;\n\tu64\t\t\tlast_outbytes;\n\tu64\t\t\tlast_conns;\n\tu64\t\t\tlast_inpkts;\n\tu64\t\t\tlast_outpkts;\n\n\tu64\t\t\tcps;\n\tu64\t\t\tinpps;\n\tu64\t\t\toutpps;\n\tu64\t\t\tinbps;\n\tu64\t\t\toutbps;\n\n\ts32\t\t\tktid:16,\t \n\t\t\t\tktrow:8,\t \n\t\t\t\tktcid:8;\t \n};\n\n \nstruct ip_vs_kstats {\n\tu64\t\t\tconns;\t\t \n\tu64\t\t\tinpkts;\t\t \n\tu64\t\t\toutpkts;\t \n\tu64\t\t\tinbytes;\t \n\tu64\t\t\toutbytes;\t \n\n\tu64\t\t\tcps;\t\t \n\tu64\t\t\tinpps;\t\t \n\tu64\t\t\toutpps;\t\t \n\tu64\t\t\tinbps;\t\t \n\tu64\t\t\toutbps;\t\t \n};\n\nstruct ip_vs_stats {\n\tstruct ip_vs_kstats\tkstats;\t\t \n\tstruct ip_vs_estimator\test;\t\t \n\tstruct ip_vs_cpu_stats __percpu\t*cpustats;\t \n\tspinlock_t\t\tlock;\t\t \n\tstruct ip_vs_kstats\tkstats0;\t \n};\n\nstruct ip_vs_stats_rcu {\n\tstruct ip_vs_stats\ts;\n\tstruct rcu_head\t\trcu_head;\n};\n\nint ip_vs_stats_init_alloc(struct ip_vs_stats *s);\nstruct ip_vs_stats *ip_vs_stats_alloc(void);\nvoid ip_vs_stats_release(struct ip_vs_stats *stats);\nvoid ip_vs_stats_free(struct ip_vs_stats *stats);\n\n \n#define IPVS_EST_NTICKS\t\t50\n \n#define IPVS_EST_TICK\t\t((2 * HZ) / IPVS_EST_NTICKS)\n\n \n#define IPVS_EST_LOAD_DIVISOR\t8\n\n \n#define IPVS_EST_CPU_KTHREADS\t(IPVS_EST_LOAD_DIVISOR / 2)\n\n \n#define IPVS_EST_CHAIN_FACTOR\t\\\n\tALIGN_DOWN(2 * 1000 * 10 / IPVS_EST_LOAD_DIVISOR / IPVS_EST_NTICKS, 8)\n\n \n#if defined(CONFIG_DEBUG_ATOMIC_SLEEP) || !defined(CONFIG_PREEMPT_RCU)\n#define IPVS_EST_TICK_CHAINS\tIPVS_EST_CHAIN_FACTOR\n#else\n#define IPVS_EST_TICK_CHAINS\t1\n#endif\n\n#if IPVS_EST_NTICKS > 127\n#error Too many timer ticks for ktrow\n#endif\n\n \nstruct ip_vs_est_tick_data {\n\tstruct rcu_head\t\trcu_head;\n\tstruct hlist_head\tchains[IPVS_EST_TICK_CHAINS];\n\tDECLARE_BITMAP(present, IPVS_EST_TICK_CHAINS);\n\tDECLARE_BITMAP(full, IPVS_EST_TICK_CHAINS);\n\tint\t\t\tchain_len[IPVS_EST_TICK_CHAINS];\n};\n\n \nstruct ip_vs_est_kt_data {\n\tstruct netns_ipvs\t*ipvs;\n\tstruct task_struct\t*task;\t\t \n\tstruct ip_vs_est_tick_data __rcu *ticks[IPVS_EST_NTICKS];\n\tDECLARE_BITMAP(avail, IPVS_EST_NTICKS);\t \n\tunsigned long\t\test_timer;\t \n\tstruct ip_vs_stats\t*calc_stats;\t \n\tint\t\t\ttick_len[IPVS_EST_NTICKS];\t \n\tint\t\t\tid;\t\t \n\tint\t\t\tchain_max;\t \n\tint\t\t\ttick_max;\t \n\tint\t\t\test_count;\t \n\tint\t\t\test_max_count;\t \n\tint\t\t\tadd_row;\t \n\tint\t\t\test_row;\t \n};\n\nstruct dst_entry;\nstruct iphdr;\nstruct ip_vs_conn;\nstruct ip_vs_app;\nstruct sk_buff;\nstruct ip_vs_proto_data;\n\nstruct ip_vs_protocol {\n\tstruct ip_vs_protocol\t*next;\n\tchar\t\t\t*name;\n\tu16\t\t\tprotocol;\n\tu16\t\t\tnum_states;\n\tint\t\t\tdont_defrag;\n\n\tvoid (*init)(struct ip_vs_protocol *pp);\n\n\tvoid (*exit)(struct ip_vs_protocol *pp);\n\n\tint (*init_netns)(struct netns_ipvs *ipvs, struct ip_vs_proto_data *pd);\n\n\tvoid (*exit_netns)(struct netns_ipvs *ipvs, struct ip_vs_proto_data *pd);\n\n\tint (*conn_schedule)(struct netns_ipvs *ipvs,\n\t\t\t     int af, struct sk_buff *skb,\n\t\t\t     struct ip_vs_proto_data *pd,\n\t\t\t     int *verdict, struct ip_vs_conn **cpp,\n\t\t\t     struct ip_vs_iphdr *iph);\n\n\tstruct ip_vs_conn *\n\t(*conn_in_get)(struct netns_ipvs *ipvs,\n\t\t       int af,\n\t\t       const struct sk_buff *skb,\n\t\t       const struct ip_vs_iphdr *iph);\n\n\tstruct ip_vs_conn *\n\t(*conn_out_get)(struct netns_ipvs *ipvs,\n\t\t\tint af,\n\t\t\tconst struct sk_buff *skb,\n\t\t\tconst struct ip_vs_iphdr *iph);\n\n\tint (*snat_handler)(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t\t    struct ip_vs_conn *cp, struct ip_vs_iphdr *iph);\n\n\tint (*dnat_handler)(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t\t    struct ip_vs_conn *cp, struct ip_vs_iphdr *iph);\n\n\tconst char *(*state_name)(int state);\n\n\tvoid (*state_transition)(struct ip_vs_conn *cp, int direction,\n\t\t\t\t const struct sk_buff *skb,\n\t\t\t\t struct ip_vs_proto_data *pd);\n\n\tint (*register_app)(struct netns_ipvs *ipvs, struct ip_vs_app *inc);\n\n\tvoid (*unregister_app)(struct netns_ipvs *ipvs, struct ip_vs_app *inc);\n\n\tint (*app_conn_bind)(struct ip_vs_conn *cp);\n\n\tvoid (*debug_packet)(int af, struct ip_vs_protocol *pp,\n\t\t\t     const struct sk_buff *skb,\n\t\t\t     int offset,\n\t\t\t     const char *msg);\n\n\tvoid (*timeout_change)(struct ip_vs_proto_data *pd, int flags);\n};\n\n \nstruct ip_vs_proto_data {\n\tstruct ip_vs_proto_data\t*next;\n\tstruct ip_vs_protocol\t*pp;\n\tint\t\t\t*timeout_table;\t \n\tatomic_t\t\tappcnt;\t\t \n\tstruct tcp_states_t\t*tcp_state_table;\n};\n\nstruct ip_vs_protocol   *ip_vs_proto_get(unsigned short proto);\nstruct ip_vs_proto_data *ip_vs_proto_data_get(struct netns_ipvs *ipvs,\n\t\t\t\t\t      unsigned short proto);\n\nstruct ip_vs_conn_param {\n\tstruct netns_ipvs\t\t*ipvs;\n\tconst union nf_inet_addr\t*caddr;\n\tconst union nf_inet_addr\t*vaddr;\n\t__be16\t\t\t\tcport;\n\t__be16\t\t\t\tvport;\n\t__u16\t\t\t\tprotocol;\n\tu16\t\t\t\taf;\n\n\tconst struct ip_vs_pe\t\t*pe;\n\tchar\t\t\t\t*pe_data;\n\t__u8\t\t\t\tpe_data_len;\n};\n\n \nstruct ip_vs_conn {\n\tstruct hlist_node\tc_list;          \n\t \n\t__be16                  cport;\n\t__be16                  dport;\n\t__be16                  vport;\n\tu16\t\t\taf;\t\t \n\tunion nf_inet_addr      caddr;           \n\tunion nf_inet_addr      vaddr;           \n\tunion nf_inet_addr      daddr;           \n\tvolatile __u32          flags;           \n\t__u16                   protocol;        \n\t__u16\t\t\tdaf;\t\t \n\tstruct netns_ipvs\t*ipvs;\n\n\t \n\trefcount_t\t\trefcnt;\t\t \n\tstruct timer_list\ttimer;\t\t \n\tvolatile unsigned long\ttimeout;\t \n\n\t \n\tspinlock_t              lock;            \n\tvolatile __u16          state;           \n\tvolatile __u16          old_state;       \n\t__u32\t\t\tfwmark;\t\t \n\tunsigned long\t\tsync_endtime;\t \n\n\t \n\tstruct ip_vs_conn       *control;        \n\tatomic_t                n_control;       \n\tstruct ip_vs_dest       *dest;           \n\tatomic_t                in_pkts;         \n\n\t \n\tint (*packet_xmit)(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t\t   struct ip_vs_protocol *pp, struct ip_vs_iphdr *iph);\n\n\t \n\tstruct ip_vs_app        *app;            \n\tvoid                    *app_data;       \n\tstruct_group(sync_conn_opt,\n\t\tstruct ip_vs_seq  in_seq;        \n\t\tstruct ip_vs_seq  out_seq;       \n\t);\n\n\tconst struct ip_vs_pe\t*pe;\n\tchar\t\t\t*pe_data;\n\t__u8\t\t\tpe_data_len;\n\n\tstruct rcu_head\t\trcu_head;\n};\n\n \nstruct ip_vs_service_user_kern {\n\t \n\tu16\t\t\taf;\n\tu16\t\t\tprotocol;\n\tunion nf_inet_addr\taddr;\t\t \n\t__be16\t\t\tport;\n\tu32\t\t\tfwmark;\t\t \n\n\t \n\tchar\t\t\t*sched_name;\n\tchar\t\t\t*pe_name;\n\tunsigned int\t\tflags;\t\t \n\tunsigned int\t\ttimeout;\t \n\t__be32\t\t\tnetmask;\t \n};\n\n\nstruct ip_vs_dest_user_kern {\n\t \n\tunion nf_inet_addr\taddr;\n\t__be16\t\t\tport;\n\n\t \n\tunsigned int\t\tconn_flags;\t \n\tint\t\t\tweight;\t\t \n\n\t \n\tu32\t\t\tu_threshold;\t \n\tu32\t\t\tl_threshold;\t \n\n\t \n\tu16\t\t\taf;\n\n\tu16\t\t\ttun_type;\t \n\t__be16\t\t\ttun_port;\t \n\tu16\t\t\ttun_flags;\t \n};\n\n\n \nstruct ip_vs_service {\n\tstruct hlist_node\ts_list;    \n\tstruct hlist_node\tf_list;    \n\tatomic_t\t\trefcnt;    \n\n\tu16\t\t\taf;        \n\t__u16\t\t\tprotocol;  \n\tunion nf_inet_addr\taddr;\t   \n\t__be16\t\t\tport;\t   \n\t__u32                   fwmark;    \n\tunsigned int\t\tflags;\t   \n\tunsigned int\t\ttimeout;   \n\t__be32\t\t\tnetmask;   \n\tstruct netns_ipvs\t*ipvs;\n\n\tstruct list_head\tdestinations;   \n\t__u32\t\t\tnum_dests;      \n\tstruct ip_vs_stats      stats;          \n\n\t \n\tstruct ip_vs_scheduler __rcu *scheduler;  \n\tspinlock_t\t\tsched_lock;     \n\tvoid\t\t\t*sched_data;    \n\n\t \n\tstruct ip_vs_pe __rcu\t*pe;\n\tint\t\t\tconntrack_afmask;\n\n\tstruct rcu_head\t\trcu_head;\n};\n\n \nstruct ip_vs_dest_dst {\n\tstruct dst_entry\t*dst_cache;\t \n\tu32\t\t\tdst_cookie;\n\tunion nf_inet_addr\tdst_saddr;\n\tstruct rcu_head\t\trcu_head;\n};\n\n \nstruct ip_vs_dest {\n\tstruct list_head\tn_list;    \n\tstruct hlist_node\td_list;    \n\n\tu16\t\t\taf;\t\t \n\t__be16\t\t\tport;\t\t \n\tunion nf_inet_addr\taddr;\t\t \n\tvolatile unsigned int\tflags;\t\t \n\tatomic_t\t\tconn_flags;\t \n\tatomic_t\t\tweight;\t\t \n\tatomic_t\t\tlast_weight;\t \n\t__u16\t\t\ttun_type;\t \n\t__be16\t\t\ttun_port;\t \n\t__u16\t\t\ttun_flags;\t \n\n\trefcount_t\t\trefcnt;\t\t \n\tstruct ip_vs_stats      stats;           \n\tunsigned long\t\tidle_start;\t \n\n\t \n\tatomic_t\t\tactiveconns;\t \n\tatomic_t\t\tinactconns;\t \n\tatomic_t\t\tpersistconns;\t \n\t__u32\t\t\tu_threshold;\t \n\t__u32\t\t\tl_threshold;\t \n\n\t \n\tspinlock_t\t\tdst_lock;\t \n\tstruct ip_vs_dest_dst __rcu *dest_dst;\t \n\n\t \n\tstruct ip_vs_service __rcu *svc;\t \n\t__u16\t\t\tprotocol;\t \n\t__be16\t\t\tvport;\t\t \n\tunion nf_inet_addr\tvaddr;\t\t \n\t__u32\t\t\tvfwmark;\t \n\n\tstruct rcu_head\t\trcu_head;\n\tstruct list_head\tt_list;\t\t \n\tunsigned int\t\tin_rs_table:1;\t \n};\n\n \nstruct ip_vs_scheduler {\n\tstruct list_head\tn_list;\t\t \n\tchar\t\t\t*name;\t\t \n\tatomic_t\t\trefcnt;\t\t \n\tstruct module\t\t*module;\t \n\n\t \n\tint (*init_service)(struct ip_vs_service *svc);\n\t \n\tvoid (*done_service)(struct ip_vs_service *svc);\n\t \n\tint (*add_dest)(struct ip_vs_service *svc, struct ip_vs_dest *dest);\n\t \n\tint (*del_dest)(struct ip_vs_service *svc, struct ip_vs_dest *dest);\n\t \n\tint (*upd_dest)(struct ip_vs_service *svc, struct ip_vs_dest *dest);\n\n\t \n\tstruct ip_vs_dest* (*schedule)(struct ip_vs_service *svc,\n\t\t\t\t       const struct sk_buff *skb,\n\t\t\t\t       struct ip_vs_iphdr *iph);\n};\n\n \nstruct ip_vs_pe {\n\tstruct list_head\tn_list;\t\t \n\tchar\t\t\t*name;\t\t \n\tatomic_t\t\trefcnt;\t\t \n\tstruct module\t\t*module;\t \n\n\t \n\tint (*fill_param)(struct ip_vs_conn_param *p, struct sk_buff *skb);\n\tbool (*ct_match)(const struct ip_vs_conn_param *p,\n\t\t\t struct ip_vs_conn *ct);\n\tu32 (*hashkey_raw)(const struct ip_vs_conn_param *p, u32 initval,\n\t\t\t   bool inverse);\n\tint (*show_pe_data)(const struct ip_vs_conn *cp, char *buf);\n\t \n\tstruct ip_vs_conn* (*conn_out)(struct ip_vs_service *svc,\n\t\t\t\t       struct ip_vs_dest *dest,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       const struct ip_vs_iphdr *iph,\n\t\t\t\t       __be16 dport, __be16 cport);\n};\n\n \nstruct ip_vs_app {\n\tstruct list_head\ta_list;\t\t \n\tint\t\t\ttype;\t\t \n\tchar\t\t\t*name;\t\t \n\t__u16\t\t\tprotocol;\n\tstruct module\t\t*module;\t \n\tstruct list_head\tincs_list;\t \n\n\t \n\tstruct list_head\tp_list;\t\t \n\tstruct ip_vs_app\t*app;\t\t \n\t__be16\t\t\tport;\t\t \n\tatomic_t\t\tusecnt;\t\t \n\tstruct rcu_head\t\trcu_head;\n\n\t \n\tint (*pkt_out)(struct ip_vs_app *, struct ip_vs_conn *,\n\t\t       struct sk_buff *, int *diff, struct ip_vs_iphdr *ipvsh);\n\n\t \n\tint (*pkt_in)(struct ip_vs_app *, struct ip_vs_conn *,\n\t\t      struct sk_buff *, int *diff, struct ip_vs_iphdr *ipvsh);\n\n\t \n\tint (*init_conn)(struct ip_vs_app *, struct ip_vs_conn *);\n\n\t \n\tint (*done_conn)(struct ip_vs_app *, struct ip_vs_conn *);\n\n\n\t \n\tint (*bind_conn)(struct ip_vs_app *, struct ip_vs_conn *,\n\t\t\t struct ip_vs_protocol *);\n\n\tvoid (*unbind_conn)(struct ip_vs_app *, struct ip_vs_conn *);\n\n\tint *\t\t\ttimeout_table;\n\tint *\t\t\ttimeouts;\n\tint\t\t\ttimeouts_size;\n\n\tint (*conn_schedule)(struct sk_buff *skb, struct ip_vs_app *app,\n\t\t\t     int *verdict, struct ip_vs_conn **cpp);\n\n\tstruct ip_vs_conn *\n\t(*conn_in_get)(const struct sk_buff *skb, struct ip_vs_app *app,\n\t\t       const struct iphdr *iph, int inverse);\n\n\tstruct ip_vs_conn *\n\t(*conn_out_get)(const struct sk_buff *skb, struct ip_vs_app *app,\n\t\t\tconst struct iphdr *iph, int inverse);\n\n\tint (*state_transition)(struct ip_vs_conn *cp, int direction,\n\t\t\t\tconst struct sk_buff *skb,\n\t\t\t\tstruct ip_vs_app *app);\n\n\tvoid (*timeout_change)(struct ip_vs_app *app, int flags);\n};\n\nstruct ipvs_master_sync_state {\n\tstruct list_head\tsync_queue;\n\tstruct ip_vs_sync_buff\t*sync_buff;\n\tunsigned long\t\tsync_queue_len;\n\tunsigned int\t\tsync_queue_delay;\n\tstruct delayed_work\tmaster_wakeup_work;\n\tstruct netns_ipvs\t*ipvs;\n};\n\nstruct ip_vs_sync_thread_data;\n\n \n#define IP_VS_DEST_TRASH_PERIOD\t\t(120 * HZ)\n\nstruct ipvs_sync_daemon_cfg {\n\tunion nf_inet_addr\tmcast_group;\n\tint\t\t\tsyncid;\n\tu16\t\t\tsync_maxlen;\n\tu16\t\t\tmcast_port;\n\tu8\t\t\tmcast_af;\n\tu8\t\t\tmcast_ttl;\n\t \n\tchar\t\t\tmcast_ifn[IP_VS_IFNAME_MAXLEN];\n};\n\n \nstruct netns_ipvs {\n\tint\t\t\tgen;\t\t \n\tint\t\t\tenable;\t\t \n\t \n\t#define IP_VS_RTAB_BITS 4\n\t#define IP_VS_RTAB_SIZE (1 << IP_VS_RTAB_BITS)\n\t#define IP_VS_RTAB_MASK (IP_VS_RTAB_SIZE - 1)\n\n\tstruct hlist_head\trs_table[IP_VS_RTAB_SIZE];\n\t \n\tstruct list_head\tapp_list;\n\t \n\t#define IP_VS_PROTO_TAB_SIZE\t32\t \n\tstruct ip_vs_proto_data *proto_data_table[IP_VS_PROTO_TAB_SIZE];\n\t \n#ifdef CONFIG_IP_VS_PROTO_TCP\n\t#define\tTCP_APP_TAB_BITS\t4\n\t#define\tTCP_APP_TAB_SIZE\t(1 << TCP_APP_TAB_BITS)\n\t#define\tTCP_APP_TAB_MASK\t(TCP_APP_TAB_SIZE - 1)\n\tstruct list_head\ttcp_apps[TCP_APP_TAB_SIZE];\n#endif\n\t \n#ifdef CONFIG_IP_VS_PROTO_UDP\n\t#define\tUDP_APP_TAB_BITS\t4\n\t#define\tUDP_APP_TAB_SIZE\t(1 << UDP_APP_TAB_BITS)\n\t#define\tUDP_APP_TAB_MASK\t(UDP_APP_TAB_SIZE - 1)\n\tstruct list_head\tudp_apps[UDP_APP_TAB_SIZE];\n#endif\n\t \n#ifdef CONFIG_IP_VS_PROTO_SCTP\n\t#define SCTP_APP_TAB_BITS\t4\n\t#define SCTP_APP_TAB_SIZE\t(1 << SCTP_APP_TAB_BITS)\n\t#define SCTP_APP_TAB_MASK\t(SCTP_APP_TAB_SIZE - 1)\n\t \n\tstruct list_head\tsctp_apps[SCTP_APP_TAB_SIZE];\n#endif\n\t \n\tatomic_t\t\tconn_count;       \n\n\t \n\tstruct ip_vs_stats_rcu\t*tot_stats;       \n\n\tint\t\t\tnum_services;     \n\tint\t\t\tnum_services6;    \n\n\t \n\tstruct list_head\tdest_trash;\n\tspinlock_t\t\tdest_trash_lock;\n\tstruct timer_list\tdest_trash_timer;  \n\t \n\tatomic_t\t\tftpsvc_counter;\n\tatomic_t\t\tnullsvc_counter;\n\tatomic_t\t\tconn_out_counter;\n\n#ifdef CONFIG_SYSCTL\n\t \n\tstruct delayed_work\texpire_nodest_conn_work;\n\t \n\tstruct delayed_work\tdefense_work;    \n\tint\t\t\tdrop_rate;\n\tint\t\t\tdrop_counter;\n\tint\t\t\told_secure_tcp;\n\tatomic_t\t\tdropentry;\n\t \n\tspinlock_t\t\tdropentry_lock;   \n\tspinlock_t\t\tdroppacket_lock;  \n\tspinlock_t\t\tsecuretcp_lock;   \n\n\t \n\tstruct ctl_table_header\t*sysctl_hdr;\n\tstruct ctl_table\t*sysctl_tbl;\n#endif\n\n\t \n\tint\t\t\tsysctl_amemthresh;\n\tint\t\t\tsysctl_am_droprate;\n\tint\t\t\tsysctl_drop_entry;\n\tint\t\t\tsysctl_drop_packet;\n\tint\t\t\tsysctl_secure_tcp;\n#ifdef CONFIG_IP_VS_NFCT\n\tint\t\t\tsysctl_conntrack;\n#endif\n\tint\t\t\tsysctl_snat_reroute;\n\tint\t\t\tsysctl_sync_ver;\n\tint\t\t\tsysctl_sync_ports;\n\tint\t\t\tsysctl_sync_persist_mode;\n\tunsigned long\t\tsysctl_sync_qlen_max;\n\tint\t\t\tsysctl_sync_sock_size;\n\tint\t\t\tsysctl_cache_bypass;\n\tint\t\t\tsysctl_expire_nodest_conn;\n\tint\t\t\tsysctl_sloppy_tcp;\n\tint\t\t\tsysctl_sloppy_sctp;\n\tint\t\t\tsysctl_expire_quiescent_template;\n\tint\t\t\tsysctl_sync_threshold[2];\n\tunsigned int\t\tsysctl_sync_refresh_period;\n\tint\t\t\tsysctl_sync_retries;\n\tint\t\t\tsysctl_nat_icmp_send;\n\tint\t\t\tsysctl_pmtu_disc;\n\tint\t\t\tsysctl_backup_only;\n\tint\t\t\tsysctl_conn_reuse_mode;\n\tint\t\t\tsysctl_schedule_icmp;\n\tint\t\t\tsysctl_ignore_tunneled;\n\tint\t\t\tsysctl_run_estimation;\n#ifdef CONFIG_SYSCTL\n\tcpumask_var_t\t\tsysctl_est_cpulist;\t \n\tint\t\t\test_cpulist_valid;\t \n\tint\t\t\tsysctl_est_nice;\t \n\tint\t\t\test_stopped;\t\t \n#endif\n\n\t \n\tint\t\t\tsysctl_lblc_expiration;\n\tstruct ctl_table_header\t*lblc_ctl_header;\n\tstruct ctl_table\t*lblc_ctl_table;\n\t \n\tint\t\t\tsysctl_lblcr_expiration;\n\tstruct ctl_table_header\t*lblcr_ctl_header;\n\tstruct ctl_table\t*lblcr_ctl_table;\n\t \n\tstruct delayed_work\test_reload_work; \n\tstruct mutex\t\test_mutex;\t \n\tstruct hlist_head\test_temp_list;\t \n\tstruct ip_vs_est_kt_data **est_kt_arr;\t \n\tunsigned long\t\test_max_threads; \n\tint\t\t\test_calc_phase;\t \n\tint\t\t\test_chain_max;\t \n\tint\t\t\test_kt_count;\t \n\tint\t\t\test_add_ktid;\t \n\tatomic_t\t\test_genid;\t \n\tatomic_t\t\test_genid_done;\t \n\t \n\tspinlock_t\t\tsync_lock;\n\tstruct ipvs_master_sync_state *ms;\n\tspinlock_t\t\tsync_buff_lock;\n\tstruct ip_vs_sync_thread_data *master_tinfo;\n\tstruct ip_vs_sync_thread_data *backup_tinfo;\n\tint\t\t\tthreads_mask;\n\tvolatile int\t\tsync_state;\n\tstruct mutex\t\tsync_mutex;\n\tstruct ipvs_sync_daemon_cfg\tmcfg;\t \n\tstruct ipvs_sync_daemon_cfg\tbcfg;\t \n\t \n\tstruct net\t\t*net;             \n\t \n\tunsigned int\t\tmixed_address_family_dests;\n\tunsigned int\t\thooks_afmask;\t \n};\n\n#define DEFAULT_SYNC_THRESHOLD\t3\n#define DEFAULT_SYNC_PERIOD\t50\n#define DEFAULT_SYNC_VER\t1\n#define DEFAULT_SLOPPY_TCP\t0\n#define DEFAULT_SLOPPY_SCTP\t0\n#define DEFAULT_SYNC_REFRESH_PERIOD\t(0U * HZ)\n#define DEFAULT_SYNC_RETRIES\t\t0\n#define IPVS_SYNC_WAKEUP_RATE\t8\n#define IPVS_SYNC_QLEN_MAX\t(IPVS_SYNC_WAKEUP_RATE * 4)\n#define IPVS_SYNC_SEND_DELAY\t(HZ / 50)\n#define IPVS_SYNC_CHECK_PERIOD\tHZ\n#define IPVS_SYNC_FLUSH_TIME\t(HZ * 2)\n#define IPVS_SYNC_PORTS_MAX\t(1 << 6)\n\n#ifdef CONFIG_SYSCTL\n\nstatic inline int sysctl_sync_threshold(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_sync_threshold[0];\n}\n\nstatic inline int sysctl_sync_period(struct netns_ipvs *ipvs)\n{\n\treturn READ_ONCE(ipvs->sysctl_sync_threshold[1]);\n}\n\nstatic inline unsigned int sysctl_sync_refresh_period(struct netns_ipvs *ipvs)\n{\n\treturn READ_ONCE(ipvs->sysctl_sync_refresh_period);\n}\n\nstatic inline int sysctl_sync_retries(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_sync_retries;\n}\n\nstatic inline int sysctl_sync_ver(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_sync_ver;\n}\n\nstatic inline int sysctl_sloppy_tcp(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_sloppy_tcp;\n}\n\nstatic inline int sysctl_sloppy_sctp(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_sloppy_sctp;\n}\n\nstatic inline int sysctl_sync_ports(struct netns_ipvs *ipvs)\n{\n\treturn READ_ONCE(ipvs->sysctl_sync_ports);\n}\n\nstatic inline int sysctl_sync_persist_mode(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_sync_persist_mode;\n}\n\nstatic inline unsigned long sysctl_sync_qlen_max(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_sync_qlen_max;\n}\n\nstatic inline int sysctl_sync_sock_size(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_sync_sock_size;\n}\n\nstatic inline int sysctl_pmtu_disc(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_pmtu_disc;\n}\n\nstatic inline int sysctl_backup_only(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sync_state & IP_VS_STATE_BACKUP &&\n\t       ipvs->sysctl_backup_only;\n}\n\nstatic inline int sysctl_conn_reuse_mode(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_conn_reuse_mode;\n}\n\nstatic inline int sysctl_expire_nodest_conn(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_expire_nodest_conn;\n}\n\nstatic inline int sysctl_schedule_icmp(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_schedule_icmp;\n}\n\nstatic inline int sysctl_ignore_tunneled(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_ignore_tunneled;\n}\n\nstatic inline int sysctl_cache_bypass(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_cache_bypass;\n}\n\nstatic inline int sysctl_run_estimation(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_run_estimation;\n}\n\nstatic inline const struct cpumask *sysctl_est_cpulist(struct netns_ipvs *ipvs)\n{\n\tif (ipvs->est_cpulist_valid)\n\t\treturn ipvs->sysctl_est_cpulist;\n\telse\n\t\treturn housekeeping_cpumask(HK_TYPE_KTHREAD);\n}\n\nstatic inline int sysctl_est_nice(struct netns_ipvs *ipvs)\n{\n\treturn ipvs->sysctl_est_nice;\n}\n\n#else\n\nstatic inline int sysctl_sync_threshold(struct netns_ipvs *ipvs)\n{\n\treturn DEFAULT_SYNC_THRESHOLD;\n}\n\nstatic inline int sysctl_sync_period(struct netns_ipvs *ipvs)\n{\n\treturn DEFAULT_SYNC_PERIOD;\n}\n\nstatic inline unsigned int sysctl_sync_refresh_period(struct netns_ipvs *ipvs)\n{\n\treturn DEFAULT_SYNC_REFRESH_PERIOD;\n}\n\nstatic inline int sysctl_sync_retries(struct netns_ipvs *ipvs)\n{\n\treturn DEFAULT_SYNC_RETRIES & 3;\n}\n\nstatic inline int sysctl_sync_ver(struct netns_ipvs *ipvs)\n{\n\treturn DEFAULT_SYNC_VER;\n}\n\nstatic inline int sysctl_sloppy_tcp(struct netns_ipvs *ipvs)\n{\n\treturn DEFAULT_SLOPPY_TCP;\n}\n\nstatic inline int sysctl_sloppy_sctp(struct netns_ipvs *ipvs)\n{\n\treturn DEFAULT_SLOPPY_SCTP;\n}\n\nstatic inline int sysctl_sync_ports(struct netns_ipvs *ipvs)\n{\n\treturn 1;\n}\n\nstatic inline int sysctl_sync_persist_mode(struct netns_ipvs *ipvs)\n{\n\treturn 0;\n}\n\nstatic inline unsigned long sysctl_sync_qlen_max(struct netns_ipvs *ipvs)\n{\n\treturn IPVS_SYNC_QLEN_MAX;\n}\n\nstatic inline int sysctl_sync_sock_size(struct netns_ipvs *ipvs)\n{\n\treturn 0;\n}\n\nstatic inline int sysctl_pmtu_disc(struct netns_ipvs *ipvs)\n{\n\treturn 1;\n}\n\nstatic inline int sysctl_backup_only(struct netns_ipvs *ipvs)\n{\n\treturn 0;\n}\n\nstatic inline int sysctl_conn_reuse_mode(struct netns_ipvs *ipvs)\n{\n\treturn 1;\n}\n\nstatic inline int sysctl_expire_nodest_conn(struct netns_ipvs *ipvs)\n{\n\treturn 0;\n}\n\nstatic inline int sysctl_schedule_icmp(struct netns_ipvs *ipvs)\n{\n\treturn 0;\n}\n\nstatic inline int sysctl_ignore_tunneled(struct netns_ipvs *ipvs)\n{\n\treturn 0;\n}\n\nstatic inline int sysctl_cache_bypass(struct netns_ipvs *ipvs)\n{\n\treturn 0;\n}\n\nstatic inline int sysctl_run_estimation(struct netns_ipvs *ipvs)\n{\n\treturn 1;\n}\n\nstatic inline const struct cpumask *sysctl_est_cpulist(struct netns_ipvs *ipvs)\n{\n\treturn housekeeping_cpumask(HK_TYPE_KTHREAD);\n}\n\nstatic inline int sysctl_est_nice(struct netns_ipvs *ipvs)\n{\n\treturn IPVS_EST_NICE;\n}\n\n#endif\n\n \nconst char *ip_vs_proto_name(unsigned int proto);\nvoid ip_vs_init_hash_table(struct list_head *table, int rows);\nstruct ip_vs_conn *ip_vs_new_conn_out(struct ip_vs_service *svc,\n\t\t\t\t      struct ip_vs_dest *dest,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const struct ip_vs_iphdr *iph,\n\t\t\t\t      __be16 dport,\n\t\t\t\t      __be16 cport);\n#define IP_VS_INIT_HASH_TABLE(t) ip_vs_init_hash_table((t), ARRAY_SIZE((t)))\n\n#define IP_VS_APP_TYPE_FTP\t1\n\n \nenum {\n\tIP_VS_DIR_INPUT = 0,\n\tIP_VS_DIR_OUTPUT,\n\tIP_VS_DIR_INPUT_ONLY,\n\tIP_VS_DIR_LAST,\n};\n\nstatic inline void ip_vs_conn_fill_param(struct netns_ipvs *ipvs, int af, int protocol,\n\t\t\t\t\t const union nf_inet_addr *caddr,\n\t\t\t\t\t __be16 cport,\n\t\t\t\t\t const union nf_inet_addr *vaddr,\n\t\t\t\t\t __be16 vport,\n\t\t\t\t\t struct ip_vs_conn_param *p)\n{\n\tp->ipvs = ipvs;\n\tp->af = af;\n\tp->protocol = protocol;\n\tp->caddr = caddr;\n\tp->cport = cport;\n\tp->vaddr = vaddr;\n\tp->vport = vport;\n\tp->pe = NULL;\n\tp->pe_data = NULL;\n}\n\nstruct ip_vs_conn *ip_vs_conn_in_get(const struct ip_vs_conn_param *p);\nstruct ip_vs_conn *ip_vs_ct_in_get(const struct ip_vs_conn_param *p);\n\nstruct ip_vs_conn * ip_vs_conn_in_get_proto(struct netns_ipvs *ipvs, int af,\n\t\t\t\t\t    const struct sk_buff *skb,\n\t\t\t\t\t    const struct ip_vs_iphdr *iph);\n\nstruct ip_vs_conn *ip_vs_conn_out_get(const struct ip_vs_conn_param *p);\n\nstruct ip_vs_conn * ip_vs_conn_out_get_proto(struct netns_ipvs *ipvs, int af,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     const struct ip_vs_iphdr *iph);\n\n \nstatic inline bool __ip_vs_conn_get(struct ip_vs_conn *cp)\n{\n\treturn refcount_inc_not_zero(&cp->refcnt);\n}\n\n \nstatic inline void __ip_vs_conn_put(struct ip_vs_conn *cp)\n{\n\tsmp_mb__before_atomic();\n\trefcount_dec(&cp->refcnt);\n}\nvoid ip_vs_conn_put(struct ip_vs_conn *cp);\nvoid ip_vs_conn_fill_cport(struct ip_vs_conn *cp, __be16 cport);\n\nstruct ip_vs_conn *ip_vs_conn_new(const struct ip_vs_conn_param *p, int dest_af,\n\t\t\t\t  const union nf_inet_addr *daddr,\n\t\t\t\t  __be16 dport, unsigned int flags,\n\t\t\t\t  struct ip_vs_dest *dest, __u32 fwmark);\nvoid ip_vs_conn_expire_now(struct ip_vs_conn *cp);\n\nconst char *ip_vs_state_name(const struct ip_vs_conn *cp);\n\nvoid ip_vs_tcp_conn_listen(struct ip_vs_conn *cp);\nint ip_vs_check_template(struct ip_vs_conn *ct, struct ip_vs_dest *cdest);\nvoid ip_vs_random_dropentry(struct netns_ipvs *ipvs);\nint ip_vs_conn_init(void);\nvoid ip_vs_conn_cleanup(void);\n\nstatic inline void ip_vs_control_del(struct ip_vs_conn *cp)\n{\n\tstruct ip_vs_conn *ctl_cp = cp->control;\n\tif (!ctl_cp) {\n\t\tIP_VS_ERR_BUF(\"request control DEL for uncontrolled: \"\n\t\t\t      \"%s:%d to %s:%d\\n\",\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr),\n\t\t\t      ntohs(cp->cport),\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->vaddr),\n\t\t\t      ntohs(cp->vport));\n\n\t\treturn;\n\t}\n\n\tIP_VS_DBG_BUF(7, \"DELeting control for: \"\n\t\t      \"cp.dst=%s:%d ctl_cp.dst=%s:%d\\n\",\n\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr),\n\t\t      ntohs(cp->cport),\n\t\t      IP_VS_DBG_ADDR(cp->af, &ctl_cp->caddr),\n\t\t      ntohs(ctl_cp->cport));\n\n\tcp->control = NULL;\n\tif (atomic_read(&ctl_cp->n_control) == 0) {\n\t\tIP_VS_ERR_BUF(\"BUG control DEL with n=0 : \"\n\t\t\t      \"%s:%d to %s:%d\\n\",\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr),\n\t\t\t      ntohs(cp->cport),\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->vaddr),\n\t\t\t      ntohs(cp->vport));\n\n\t\treturn;\n\t}\n\tatomic_dec(&ctl_cp->n_control);\n}\n\nstatic inline void\nip_vs_control_add(struct ip_vs_conn *cp, struct ip_vs_conn *ctl_cp)\n{\n\tif (cp->control) {\n\t\tIP_VS_ERR_BUF(\"request control ADD for already controlled: \"\n\t\t\t      \"%s:%d to %s:%d\\n\",\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr),\n\t\t\t      ntohs(cp->cport),\n\t\t\t      IP_VS_DBG_ADDR(cp->af, &cp->vaddr),\n\t\t\t      ntohs(cp->vport));\n\n\t\tip_vs_control_del(cp);\n\t}\n\n\tIP_VS_DBG_BUF(7, \"ADDing control for: \"\n\t\t      \"cp.dst=%s:%d ctl_cp.dst=%s:%d\\n\",\n\t\t      IP_VS_DBG_ADDR(cp->af, &cp->caddr),\n\t\t      ntohs(cp->cport),\n\t\t      IP_VS_DBG_ADDR(cp->af, &ctl_cp->caddr),\n\t\t      ntohs(ctl_cp->cport));\n\n\tcp->control = ctl_cp;\n\tatomic_inc(&ctl_cp->n_control);\n}\n\n \nstatic inline void\nip_vs_control_assure_ct(struct ip_vs_conn *cp)\n{\n\tstruct ip_vs_conn *ct = cp->control;\n\n\tif (ct && !(ct->state & IP_VS_CTPL_S_ASSURED) &&\n\t    (ct->flags & IP_VS_CONN_F_TEMPLATE))\n\t\tct->state |= IP_VS_CTPL_S_ASSURED;\n}\n\n \nint ip_vs_estimator_net_init(struct netns_ipvs *ipvs);\nint ip_vs_control_net_init(struct netns_ipvs *ipvs);\nint ip_vs_protocol_net_init(struct netns_ipvs *ipvs);\nint ip_vs_app_net_init(struct netns_ipvs *ipvs);\nint ip_vs_conn_net_init(struct netns_ipvs *ipvs);\nint ip_vs_sync_net_init(struct netns_ipvs *ipvs);\nvoid ip_vs_conn_net_cleanup(struct netns_ipvs *ipvs);\nvoid ip_vs_app_net_cleanup(struct netns_ipvs *ipvs);\nvoid ip_vs_protocol_net_cleanup(struct netns_ipvs *ipvs);\nvoid ip_vs_control_net_cleanup(struct netns_ipvs *ipvs);\nvoid ip_vs_estimator_net_cleanup(struct netns_ipvs *ipvs);\nvoid ip_vs_sync_net_cleanup(struct netns_ipvs *ipvs);\nvoid ip_vs_service_nets_cleanup(struct list_head *net_list);\n\n \n#define IP_VS_APP_MAX_PORTS  8\nstruct ip_vs_app *register_ip_vs_app(struct netns_ipvs *ipvs, struct ip_vs_app *app);\nvoid unregister_ip_vs_app(struct netns_ipvs *ipvs, struct ip_vs_app *app);\nint ip_vs_bind_app(struct ip_vs_conn *cp, struct ip_vs_protocol *pp);\nvoid ip_vs_unbind_app(struct ip_vs_conn *cp);\nint register_ip_vs_app_inc(struct netns_ipvs *ipvs, struct ip_vs_app *app, __u16 proto,\n\t\t\t   __u16 port);\nint ip_vs_app_inc_get(struct ip_vs_app *inc);\nvoid ip_vs_app_inc_put(struct ip_vs_app *inc);\n\nint ip_vs_app_pkt_out(struct ip_vs_conn *, struct sk_buff *skb,\n\t\t      struct ip_vs_iphdr *ipvsh);\nint ip_vs_app_pkt_in(struct ip_vs_conn *, struct sk_buff *skb,\n\t\t     struct ip_vs_iphdr *ipvsh);\n\nint register_ip_vs_pe(struct ip_vs_pe *pe);\nint unregister_ip_vs_pe(struct ip_vs_pe *pe);\nstruct ip_vs_pe *ip_vs_pe_getbyname(const char *name);\nstruct ip_vs_pe *__ip_vs_pe_getbyname(const char *pe_name);\n\n \n#define ip_vs_pe_get(pe)\t\t\t\\\n\tif (pe && pe->module)\t\t\t\\\n\t\t__module_get(pe->module);\n\n#define ip_vs_pe_put(pe)\t\t\t\\\n\tif (pe && pe->module)\t\t\t\\\n\t\tmodule_put(pe->module);\n\n \nint ip_vs_protocol_init(void);\nvoid ip_vs_protocol_cleanup(void);\nvoid ip_vs_protocol_timeout_change(struct netns_ipvs *ipvs, int flags);\nint *ip_vs_create_timeout_table(int *table, int size);\nvoid ip_vs_tcpudp_debug_packet(int af, struct ip_vs_protocol *pp,\n\t\t\t       const struct sk_buff *skb, int offset,\n\t\t\t       const char *msg);\n\nextern struct ip_vs_protocol ip_vs_protocol_tcp;\nextern struct ip_vs_protocol ip_vs_protocol_udp;\nextern struct ip_vs_protocol ip_vs_protocol_icmp;\nextern struct ip_vs_protocol ip_vs_protocol_esp;\nextern struct ip_vs_protocol ip_vs_protocol_ah;\nextern struct ip_vs_protocol ip_vs_protocol_sctp;\n\n \nint register_ip_vs_scheduler(struct ip_vs_scheduler *scheduler);\nint unregister_ip_vs_scheduler(struct ip_vs_scheduler *scheduler);\nint ip_vs_bind_scheduler(struct ip_vs_service *svc,\n\t\t\t struct ip_vs_scheduler *scheduler);\nvoid ip_vs_unbind_scheduler(struct ip_vs_service *svc,\n\t\t\t    struct ip_vs_scheduler *sched);\nstruct ip_vs_scheduler *ip_vs_scheduler_get(const char *sched_name);\nvoid ip_vs_scheduler_put(struct ip_vs_scheduler *scheduler);\nstruct ip_vs_conn *\nip_vs_schedule(struct ip_vs_service *svc, struct sk_buff *skb,\n\t       struct ip_vs_proto_data *pd, int *ignored,\n\t       struct ip_vs_iphdr *iph);\nint ip_vs_leave(struct ip_vs_service *svc, struct sk_buff *skb,\n\t\tstruct ip_vs_proto_data *pd, struct ip_vs_iphdr *iph);\n\nvoid ip_vs_scheduler_err(struct ip_vs_service *svc, const char *msg);\n\n \nextern struct ip_vs_stats ip_vs_stats;\nextern int sysctl_ip_vs_sync_ver;\n\nstruct ip_vs_service *\nip_vs_service_find(struct netns_ipvs *ipvs, int af, __u32 fwmark, __u16 protocol,\n\t\t  const union nf_inet_addr *vaddr, __be16 vport);\n\nbool ip_vs_has_real_service(struct netns_ipvs *ipvs, int af, __u16 protocol,\n\t\t\t    const union nf_inet_addr *daddr, __be16 dport);\n\nstruct ip_vs_dest *\nip_vs_find_real_service(struct netns_ipvs *ipvs, int af, __u16 protocol,\n\t\t\tconst union nf_inet_addr *daddr, __be16 dport);\nstruct ip_vs_dest *ip_vs_find_tunnel(struct netns_ipvs *ipvs, int af,\n\t\t\t\t     const union nf_inet_addr *daddr,\n\t\t\t\t     __be16 tun_port);\n\nint ip_vs_use_count_inc(void);\nvoid ip_vs_use_count_dec(void);\nint ip_vs_register_nl_ioctl(void);\nvoid ip_vs_unregister_nl_ioctl(void);\nint ip_vs_control_init(void);\nvoid ip_vs_control_cleanup(void);\nstruct ip_vs_dest *\nip_vs_find_dest(struct netns_ipvs *ipvs, int svc_af, int dest_af,\n\t\tconst union nf_inet_addr *daddr, __be16 dport,\n\t\tconst union nf_inet_addr *vaddr, __be16 vport,\n\t\t__u16 protocol, __u32 fwmark, __u32 flags);\nvoid ip_vs_try_bind_dest(struct ip_vs_conn *cp);\n\nstatic inline void ip_vs_dest_hold(struct ip_vs_dest *dest)\n{\n\trefcount_inc(&dest->refcnt);\n}\n\nstatic inline void ip_vs_dest_put(struct ip_vs_dest *dest)\n{\n\tsmp_mb__before_atomic();\n\trefcount_dec(&dest->refcnt);\n}\n\nstatic inline void ip_vs_dest_put_and_free(struct ip_vs_dest *dest)\n{\n\tif (refcount_dec_and_test(&dest->refcnt))\n\t\tkfree(dest);\n}\n\n \nint start_sync_thread(struct netns_ipvs *ipvs, struct ipvs_sync_daemon_cfg *cfg,\n\t\t      int state);\nint stop_sync_thread(struct netns_ipvs *ipvs, int state);\nvoid ip_vs_sync_conn(struct netns_ipvs *ipvs, struct ip_vs_conn *cp, int pkts);\n\n \nint ip_vs_start_estimator(struct netns_ipvs *ipvs, struct ip_vs_stats *stats);\nvoid ip_vs_stop_estimator(struct netns_ipvs *ipvs, struct ip_vs_stats *stats);\nvoid ip_vs_zero_estimator(struct ip_vs_stats *stats);\nvoid ip_vs_read_estimator(struct ip_vs_kstats *dst, struct ip_vs_stats *stats);\nvoid ip_vs_est_reload_start(struct netns_ipvs *ipvs);\nint ip_vs_est_kthread_start(struct netns_ipvs *ipvs,\n\t\t\t    struct ip_vs_est_kt_data *kd);\nvoid ip_vs_est_kthread_stop(struct ip_vs_est_kt_data *kd);\n\nstatic inline void ip_vs_est_stopped_recalc(struct netns_ipvs *ipvs)\n{\n#ifdef CONFIG_SYSCTL\n\t \n\tipvs->est_stopped = !sysctl_run_estimation(ipvs) ||\n\t\t\t    (ipvs->est_cpulist_valid &&\n\t\t\t     cpumask_empty(sysctl_est_cpulist(ipvs)));\n#endif\n}\n\nstatic inline bool ip_vs_est_stopped(struct netns_ipvs *ipvs)\n{\n#ifdef CONFIG_SYSCTL\n\treturn ipvs->est_stopped;\n#else\n\treturn false;\n#endif\n}\n\nstatic inline int ip_vs_est_max_threads(struct netns_ipvs *ipvs)\n{\n\tunsigned int limit = IPVS_EST_CPU_KTHREADS *\n\t\t\t     cpumask_weight(sysctl_est_cpulist(ipvs));\n\n\treturn max(1U, limit);\n}\n\n \nint ip_vs_null_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t    struct ip_vs_protocol *pp, struct ip_vs_iphdr *iph);\nint ip_vs_bypass_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t      struct ip_vs_protocol *pp, struct ip_vs_iphdr *iph);\nint ip_vs_nat_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t   struct ip_vs_protocol *pp, struct ip_vs_iphdr *iph);\nint ip_vs_tunnel_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t      struct ip_vs_protocol *pp, struct ip_vs_iphdr *iph);\nint ip_vs_dr_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t  struct ip_vs_protocol *pp, struct ip_vs_iphdr *iph);\nint ip_vs_icmp_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t    struct ip_vs_protocol *pp, int offset,\n\t\t    unsigned int hooknum, struct ip_vs_iphdr *iph);\nvoid ip_vs_dest_dst_rcu_free(struct rcu_head *head);\n\n#ifdef CONFIG_IP_VS_IPV6\nint ip_vs_bypass_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t\t struct ip_vs_protocol *pp, struct ip_vs_iphdr *iph);\nint ip_vs_nat_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t      struct ip_vs_protocol *pp, struct ip_vs_iphdr *iph);\nint ip_vs_tunnel_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t\t struct ip_vs_protocol *pp, struct ip_vs_iphdr *iph);\nint ip_vs_dr_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t     struct ip_vs_protocol *pp, struct ip_vs_iphdr *iph);\nint ip_vs_icmp_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t       struct ip_vs_protocol *pp, int offset,\n\t\t       unsigned int hooknum, struct ip_vs_iphdr *iph);\n#endif\n\n#ifdef CONFIG_SYSCTL\n \nstatic inline int ip_vs_todrop(struct netns_ipvs *ipvs)\n{\n\tif (!ipvs->drop_rate)\n\t\treturn 0;\n\tif (--ipvs->drop_counter > 0)\n\t\treturn 0;\n\tipvs->drop_counter = ipvs->drop_rate;\n\treturn 1;\n}\n#else\nstatic inline int ip_vs_todrop(struct netns_ipvs *ipvs) { return 0; }\n#endif\n\n#ifdef CONFIG_SYSCTL\n \nstatic inline void ip_vs_enqueue_expire_nodest_conns(struct netns_ipvs *ipvs)\n{\n\tif (sysctl_expire_nodest_conn(ipvs))\n\t\tqueue_delayed_work(system_long_wq,\n\t\t\t\t   &ipvs->expire_nodest_conn_work, 1);\n}\n\nvoid ip_vs_expire_nodest_conn_flush(struct netns_ipvs *ipvs);\n#else\nstatic inline void ip_vs_enqueue_expire_nodest_conns(struct netns_ipvs *ipvs) {}\n#endif\n\n#define IP_VS_DFWD_METHOD(dest) (atomic_read(&(dest)->conn_flags) & \\\n\t\t\t\t IP_VS_CONN_F_FWD_MASK)\n\n \n#define IP_VS_FWD_METHOD(cp)  (cp->flags & IP_VS_CONN_F_FWD_MASK)\n\nstatic inline char ip_vs_fwd_tag(struct ip_vs_conn *cp)\n{\n\tchar fwd;\n\n\tswitch (IP_VS_FWD_METHOD(cp)) {\n\tcase IP_VS_CONN_F_MASQ:\n\t\tfwd = 'M'; break;\n\tcase IP_VS_CONN_F_LOCALNODE:\n\t\tfwd = 'L'; break;\n\tcase IP_VS_CONN_F_TUNNEL:\n\t\tfwd = 'T'; break;\n\tcase IP_VS_CONN_F_DROUTE:\n\t\tfwd = 'R'; break;\n\tcase IP_VS_CONN_F_BYPASS:\n\t\tfwd = 'B'; break;\n\tdefault:\n\t\tfwd = '?'; break;\n\t}\n\treturn fwd;\n}\n\nvoid ip_vs_nat_icmp(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t    struct ip_vs_conn *cp, int dir);\n\n#ifdef CONFIG_IP_VS_IPV6\nvoid ip_vs_nat_icmp_v6(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t       struct ip_vs_conn *cp, int dir);\n#endif\n\n__sum16 ip_vs_checksum_complete(struct sk_buff *skb, int offset);\n\nstatic inline __wsum ip_vs_check_diff4(__be32 old, __be32 new, __wsum oldsum)\n{\n\t__be32 diff[2] = { ~old, new };\n\n\treturn csum_partial(diff, sizeof(diff), oldsum);\n}\n\n#ifdef CONFIG_IP_VS_IPV6\nstatic inline __wsum ip_vs_check_diff16(const __be32 *old, const __be32 *new,\n\t\t\t\t\t__wsum oldsum)\n{\n\t__be32 diff[8] = { ~old[3], ~old[2], ~old[1], ~old[0],\n\t\t\t    new[3],  new[2],  new[1],  new[0] };\n\n\treturn csum_partial(diff, sizeof(diff), oldsum);\n}\n#endif\n\nstatic inline __wsum ip_vs_check_diff2(__be16 old, __be16 new, __wsum oldsum)\n{\n\t__be16 diff[2] = { ~old, new };\n\n\treturn csum_partial(diff, sizeof(diff), oldsum);\n}\n\n \nstatic inline void ip_vs_notrack(struct sk_buff *skb)\n{\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\n\tif (ct) {\n\t\tnf_conntrack_put(&ct->ct_general);\n\t\tnf_ct_set(skb, NULL, IP_CT_UNTRACKED);\n\t}\n#endif\n}\n\n#ifdef CONFIG_IP_VS_NFCT\n \nstatic inline int ip_vs_conntrack_enabled(struct netns_ipvs *ipvs)\n{\n#ifdef CONFIG_SYSCTL\n\treturn ipvs->sysctl_conntrack;\n#else\n\treturn 0;\n#endif\n}\n\nvoid ip_vs_update_conntrack(struct sk_buff *skb, struct ip_vs_conn *cp,\n\t\t\t    int outin);\nint ip_vs_confirm_conntrack(struct sk_buff *skb);\nvoid ip_vs_nfct_expect_related(struct sk_buff *skb, struct nf_conn *ct,\n\t\t\t       struct ip_vs_conn *cp, u_int8_t proto,\n\t\t\t       const __be16 port, int from_rs);\nvoid ip_vs_conn_drop_conntrack(struct ip_vs_conn *cp);\n\n#else\n\nstatic inline int ip_vs_conntrack_enabled(struct netns_ipvs *ipvs)\n{\n\treturn 0;\n}\n\nstatic inline void ip_vs_update_conntrack(struct sk_buff *skb,\n\t\t\t\t\t  struct ip_vs_conn *cp, int outin)\n{\n}\n\nstatic inline int ip_vs_confirm_conntrack(struct sk_buff *skb)\n{\n\treturn NF_ACCEPT;\n}\n\nstatic inline void ip_vs_conn_drop_conntrack(struct ip_vs_conn *cp)\n{\n}\n#endif  \n\n \nstatic inline bool ip_vs_conn_uses_old_conntrack(struct ip_vs_conn *cp,\n\t\t\t\t\t\t struct sk_buff *skb)\n{\n#ifdef CONFIG_IP_VS_NFCT\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct && nf_ct_is_confirmed(ct))\n\t\treturn true;\n#endif\n\treturn false;\n}\n\nstatic inline int ip_vs_register_conntrack(struct ip_vs_service *svc)\n{\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tint afmask = (svc->af == AF_INET6) ? 2 : 1;\n\tint ret = 0;\n\n\tif (!(svc->conntrack_afmask & afmask)) {\n\t\tret = nf_ct_netns_get(svc->ipvs->net, svc->af);\n\t\tif (ret >= 0)\n\t\t\tsvc->conntrack_afmask |= afmask;\n\t}\n\treturn ret;\n#else\n\treturn 0;\n#endif\n}\n\nstatic inline void ip_vs_unregister_conntrack(struct ip_vs_service *svc)\n{\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tint afmask = (svc->af == AF_INET6) ? 2 : 1;\n\n\tif (svc->conntrack_afmask & afmask) {\n\t\tnf_ct_netns_put(svc->ipvs->net, svc->af);\n\t\tsvc->conntrack_afmask &= ~afmask;\n\t}\n#endif\n}\n\nint ip_vs_register_hooks(struct netns_ipvs *ipvs, unsigned int af);\nvoid ip_vs_unregister_hooks(struct netns_ipvs *ipvs, unsigned int af);\n\nstatic inline int\nip_vs_dest_conn_overhead(struct ip_vs_dest *dest)\n{\n\t \n\treturn (atomic_read(&dest->activeconns) << 8) +\n\t\tatomic_read(&dest->inactconns);\n}\n\n#ifdef CONFIG_IP_VS_PROTO_TCP\nINDIRECT_CALLABLE_DECLARE(int\n\ttcp_snat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t\t struct ip_vs_conn *cp, struct ip_vs_iphdr *iph));\n#endif\n\n#ifdef CONFIG_IP_VS_PROTO_UDP\nINDIRECT_CALLABLE_DECLARE(int\n\tudp_snat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\n\t\t\t struct ip_vs_conn *cp, struct ip_vs_iphdr *iph));\n#endif\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}