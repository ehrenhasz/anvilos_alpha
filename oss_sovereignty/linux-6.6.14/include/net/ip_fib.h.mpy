{
  "module_name": "ip_fib.h",
  "hash_id": "79ebad399c2b20034d749361e36238caab9b7dab9314b271262cf95703b55aa6",
  "original_prompt": "Ingested from linux-6.6.14/include/net/ip_fib.h",
  "human_readable_source": " \n \n\n#ifndef _NET_IP_FIB_H\n#define _NET_IP_FIB_H\n\n#include <net/flow.h>\n#include <linux/seq_file.h>\n#include <linux/rcupdate.h>\n#include <net/fib_notifier.h>\n#include <net/fib_rules.h>\n#include <net/inet_dscp.h>\n#include <net/inetpeer.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/refcount.h>\n\nstruct fib_config {\n\tu8\t\t\tfc_dst_len;\n\tdscp_t\t\t\tfc_dscp;\n\tu8\t\t\tfc_protocol;\n\tu8\t\t\tfc_scope;\n\tu8\t\t\tfc_type;\n\tu8\t\t\tfc_gw_family;\n\t \n\tu32\t\t\tfc_table;\n\t__be32\t\t\tfc_dst;\n\tunion {\n\t\t__be32\t\tfc_gw4;\n\t\tstruct in6_addr\tfc_gw6;\n\t};\n\tint\t\t\tfc_oif;\n\tu32\t\t\tfc_flags;\n\tu32\t\t\tfc_priority;\n\t__be32\t\t\tfc_prefsrc;\n\tu32\t\t\tfc_nh_id;\n\tstruct nlattr\t\t*fc_mx;\n\tstruct rtnexthop\t*fc_mp;\n\tint\t\t\tfc_mx_len;\n\tint\t\t\tfc_mp_len;\n\tu32\t\t\tfc_flow;\n\tu32\t\t\tfc_nlflags;\n\tstruct nl_info\t\tfc_nlinfo;\n\tstruct nlattr\t\t*fc_encap;\n\tu16\t\t\tfc_encap_type;\n};\n\nstruct fib_info;\nstruct rtable;\n\nstruct fib_nh_exception {\n\tstruct fib_nh_exception __rcu\t*fnhe_next;\n\tint\t\t\t\tfnhe_genid;\n\t__be32\t\t\t\tfnhe_daddr;\n\tu32\t\t\t\tfnhe_pmtu;\n\tbool\t\t\t\tfnhe_mtu_locked;\n\t__be32\t\t\t\tfnhe_gw;\n\tunsigned long\t\t\tfnhe_expires;\n\tstruct rtable __rcu\t\t*fnhe_rth_input;\n\tstruct rtable __rcu\t\t*fnhe_rth_output;\n\tunsigned long\t\t\tfnhe_stamp;\n\tstruct rcu_head\t\t\trcu;\n};\n\nstruct fnhe_hash_bucket {\n\tstruct fib_nh_exception __rcu\t*chain;\n};\n\n#define FNHE_HASH_SHIFT\t\t11\n#define FNHE_HASH_SIZE\t\t(1 << FNHE_HASH_SHIFT)\n#define FNHE_RECLAIM_DEPTH\t5\n\nstruct fib_nh_common {\n\tstruct net_device\t*nhc_dev;\n\tnetdevice_tracker\tnhc_dev_tracker;\n\tint\t\t\tnhc_oif;\n\tunsigned char\t\tnhc_scope;\n\tu8\t\t\tnhc_family;\n\tu8\t\t\tnhc_gw_family;\n\tunsigned char\t\tnhc_flags;\n\tstruct lwtunnel_state\t*nhc_lwtstate;\n\n\tunion {\n\t\t__be32          ipv4;\n\t\tstruct in6_addr ipv6;\n\t} nhc_gw;\n\n\tint\t\t\tnhc_weight;\n\tatomic_t\t\tnhc_upper_bound;\n\n\t \n\tstruct rtable __rcu * __percpu *nhc_pcpu_rth_output;\n\tstruct rtable __rcu     *nhc_rth_input;\n\tstruct fnhe_hash_bucket\t__rcu *nhc_exceptions;\n};\n\nstruct fib_nh {\n\tstruct fib_nh_common\tnh_common;\n\tstruct hlist_node\tnh_hash;\n\tstruct fib_info\t\t*nh_parent;\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\t__u32\t\t\tnh_tclassid;\n#endif\n\t__be32\t\t\tnh_saddr;\n\tint\t\t\tnh_saddr_genid;\n#define fib_nh_family\t\tnh_common.nhc_family\n#define fib_nh_dev\t\tnh_common.nhc_dev\n#define fib_nh_dev_tracker\tnh_common.nhc_dev_tracker\n#define fib_nh_oif\t\tnh_common.nhc_oif\n#define fib_nh_flags\t\tnh_common.nhc_flags\n#define fib_nh_lws\t\tnh_common.nhc_lwtstate\n#define fib_nh_scope\t\tnh_common.nhc_scope\n#define fib_nh_gw_family\tnh_common.nhc_gw_family\n#define fib_nh_gw4\t\tnh_common.nhc_gw.ipv4\n#define fib_nh_gw6\t\tnh_common.nhc_gw.ipv6\n#define fib_nh_weight\t\tnh_common.nhc_weight\n#define fib_nh_upper_bound\tnh_common.nhc_upper_bound\n};\n\n \n\nstruct nexthop;\n\nstruct fib_info {\n\tstruct hlist_node\tfib_hash;\n\tstruct hlist_node\tfib_lhash;\n\tstruct list_head\tnh_list;\n\tstruct net\t\t*fib_net;\n\trefcount_t\t\tfib_treeref;\n\trefcount_t\t\tfib_clntref;\n\tunsigned int\t\tfib_flags;\n\tunsigned char\t\tfib_dead;\n\tunsigned char\t\tfib_protocol;\n\tunsigned char\t\tfib_scope;\n\tunsigned char\t\tfib_type;\n\t__be32\t\t\tfib_prefsrc;\n\tu32\t\t\tfib_tb_id;\n\tu32\t\t\tfib_priority;\n\tstruct dst_metrics\t*fib_metrics;\n#define fib_mtu fib_metrics->metrics[RTAX_MTU-1]\n#define fib_window fib_metrics->metrics[RTAX_WINDOW-1]\n#define fib_rtt fib_metrics->metrics[RTAX_RTT-1]\n#define fib_advmss fib_metrics->metrics[RTAX_ADVMSS-1]\n\tint\t\t\tfib_nhs;\n\tbool\t\t\tfib_nh_is_v6;\n\tbool\t\t\tnh_updated;\n\tbool\t\t\tpfsrc_removed;\n\tstruct nexthop\t\t*nh;\n\tstruct rcu_head\t\trcu;\n\tstruct fib_nh\t\tfib_nh[];\n};\n\n\n#ifdef CONFIG_IP_MULTIPLE_TABLES\nstruct fib_rule;\n#endif\n\nstruct fib_table;\nstruct fib_result {\n\t__be32\t\t\tprefix;\n\tunsigned char\t\tprefixlen;\n\tunsigned char\t\tnh_sel;\n\tunsigned char\t\ttype;\n\tunsigned char\t\tscope;\n\tu32\t\t\ttclassid;\n\tstruct fib_nh_common\t*nhc;\n\tstruct fib_info\t\t*fi;\n\tstruct fib_table\t*table;\n\tstruct hlist_head\t*fa_head;\n};\n\nstruct fib_result_nl {\n\t__be32\t\tfl_addr;    \n\tu32\t\tfl_mark;\n\tunsigned char\tfl_tos;\n\tunsigned char   fl_scope;\n\tunsigned char   tb_id_in;\n\n\tunsigned char   tb_id;       \n\tunsigned char\tprefixlen;\n\tunsigned char\tnh_sel;\n\tunsigned char\ttype;\n\tunsigned char\tscope;\n\tint             err;\n};\n\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n#define FIB_TABLE_HASHSZ 256\n#else\n#define FIB_TABLE_HASHSZ 2\n#endif\n\n__be32 fib_info_update_nhc_saddr(struct net *net, struct fib_nh_common *nhc,\n\t\t\t\t unsigned char scope);\n__be32 fib_result_prefsrc(struct net *net, struct fib_result *res);\n\n#define FIB_RES_NHC(res)\t\t((res).nhc)\n#define FIB_RES_DEV(res)\t(FIB_RES_NHC(res)->nhc_dev)\n#define FIB_RES_OIF(res)\t(FIB_RES_NHC(res)->nhc_oif)\n\nstruct fib_rt_info {\n\tstruct fib_info\t\t*fi;\n\tu32\t\t\ttb_id;\n\t__be32\t\t\tdst;\n\tint\t\t\tdst_len;\n\tdscp_t\t\t\tdscp;\n\tu8\t\t\ttype;\n\tu8\t\t\toffload:1,\n\t\t\t\ttrap:1,\n\t\t\t\toffload_failed:1,\n\t\t\t\tunused:5;\n};\n\nstruct fib_entry_notifier_info {\n\tstruct fib_notifier_info info;  \n\tu32 dst;\n\tint dst_len;\n\tstruct fib_info *fi;\n\tdscp_t dscp;\n\tu8 type;\n\tu32 tb_id;\n};\n\nstruct fib_nh_notifier_info {\n\tstruct fib_notifier_info info;  \n\tstruct fib_nh *fib_nh;\n};\n\nint call_fib4_notifier(struct notifier_block *nb,\n\t\t       enum fib_event_type event_type,\n\t\t       struct fib_notifier_info *info);\nint call_fib4_notifiers(struct net *net, enum fib_event_type event_type,\n\t\t\tstruct fib_notifier_info *info);\n\nint __net_init fib4_notifier_init(struct net *net);\nvoid __net_exit fib4_notifier_exit(struct net *net);\n\nvoid fib_info_notify_update(struct net *net, struct nl_info *info);\nint fib_notify(struct net *net, struct notifier_block *nb,\n\t       struct netlink_ext_ack *extack);\n\nstruct fib_table {\n\tstruct hlist_node\ttb_hlist;\n\tu32\t\t\ttb_id;\n\tint\t\t\ttb_num_default;\n\tstruct rcu_head\t\trcu;\n\tunsigned long \t\t*tb_data;\n\tunsigned long\t\t__data[];\n};\n\nstruct fib_dump_filter {\n\tu32\t\t\ttable_id;\n\t \n\tbool\t\t\tfilter_set;\n\tbool\t\t\tdump_routes;\n\tbool\t\t\tdump_exceptions;\n\tunsigned char\t\tprotocol;\n\tunsigned char\t\trt_type;\n\tunsigned int\t\tflags;\n\tstruct net_device\t*dev;\n};\n\nint fib_table_lookup(struct fib_table *tb, const struct flowi4 *flp,\n\t\t     struct fib_result *res, int fib_flags);\nint fib_table_insert(struct net *, struct fib_table *, struct fib_config *,\n\t\t     struct netlink_ext_ack *extack);\nint fib_table_delete(struct net *, struct fib_table *, struct fib_config *,\n\t\t     struct netlink_ext_ack *extack);\nint fib_table_dump(struct fib_table *table, struct sk_buff *skb,\n\t\t   struct netlink_callback *cb, struct fib_dump_filter *filter);\nint fib_table_flush(struct net *net, struct fib_table *table, bool flush_all);\nstruct fib_table *fib_trie_unmerge(struct fib_table *main_tb);\nvoid fib_table_flush_external(struct fib_table *table);\nvoid fib_free_table(struct fib_table *tb);\n\n#ifndef CONFIG_IP_MULTIPLE_TABLES\n\n#define TABLE_LOCAL_INDEX\t(RT_TABLE_LOCAL & (FIB_TABLE_HASHSZ - 1))\n#define TABLE_MAIN_INDEX\t(RT_TABLE_MAIN  & (FIB_TABLE_HASHSZ - 1))\n\nstatic inline struct fib_table *fib_get_table(struct net *net, u32 id)\n{\n\tstruct hlist_node *tb_hlist;\n\tstruct hlist_head *ptr;\n\n\tptr = id == RT_TABLE_LOCAL ?\n\t\t&net->ipv4.fib_table_hash[TABLE_LOCAL_INDEX] :\n\t\t&net->ipv4.fib_table_hash[TABLE_MAIN_INDEX];\n\n\ttb_hlist = rcu_dereference_rtnl(hlist_first_rcu(ptr));\n\n\treturn hlist_entry(tb_hlist, struct fib_table, tb_hlist);\n}\n\nstatic inline struct fib_table *fib_new_table(struct net *net, u32 id)\n{\n\treturn fib_get_table(net, id);\n}\n\nstatic inline int fib_lookup(struct net *net, const struct flowi4 *flp,\n\t\t\t     struct fib_result *res, unsigned int flags)\n{\n\tstruct fib_table *tb;\n\tint err = -ENETUNREACH;\n\n\trcu_read_lock();\n\n\ttb = fib_get_table(net, RT_TABLE_MAIN);\n\tif (tb)\n\t\terr = fib_table_lookup(tb, flp, res, flags | FIB_LOOKUP_NOREF);\n\n\tif (err == -EAGAIN)\n\t\terr = -ENETUNREACH;\n\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic inline bool fib4_has_custom_rules(const struct net *net)\n{\n\treturn false;\n}\n\nstatic inline bool fib4_rule_default(const struct fib_rule *rule)\n{\n\treturn true;\n}\n\nstatic inline int fib4_rules_dump(struct net *net, struct notifier_block *nb,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\n\nstatic inline unsigned int fib4_rules_seq_read(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline bool fib4_rules_early_flow_dissect(struct net *net,\n\t\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t\t struct flowi4 *fl4,\n\t\t\t\t\t\t struct flow_keys *flkeys)\n{\n\treturn false;\n}\n#else  \nint __net_init fib4_rules_init(struct net *net);\nvoid __net_exit fib4_rules_exit(struct net *net);\n\nstruct fib_table *fib_new_table(struct net *net, u32 id);\nstruct fib_table *fib_get_table(struct net *net, u32 id);\n\nint __fib_lookup(struct net *net, struct flowi4 *flp,\n\t\t struct fib_result *res, unsigned int flags);\n\nstatic inline int fib_lookup(struct net *net, struct flowi4 *flp,\n\t\t\t     struct fib_result *res, unsigned int flags)\n{\n\tstruct fib_table *tb;\n\tint err = -ENETUNREACH;\n\n\tflags |= FIB_LOOKUP_NOREF;\n\tif (net->ipv4.fib_has_custom_rules)\n\t\treturn __fib_lookup(net, flp, res, flags);\n\n\trcu_read_lock();\n\n\tres->tclassid = 0;\n\n\ttb = rcu_dereference_rtnl(net->ipv4.fib_main);\n\tif (tb)\n\t\terr = fib_table_lookup(tb, flp, res, flags);\n\n\tif (!err)\n\t\tgoto out;\n\n\ttb = rcu_dereference_rtnl(net->ipv4.fib_default);\n\tif (tb)\n\t\terr = fib_table_lookup(tb, flp, res, flags);\n\nout:\n\tif (err == -EAGAIN)\n\t\terr = -ENETUNREACH;\n\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic inline bool fib4_has_custom_rules(const struct net *net)\n{\n\treturn net->ipv4.fib_has_custom_rules;\n}\n\nbool fib4_rule_default(const struct fib_rule *rule);\nint fib4_rules_dump(struct net *net, struct notifier_block *nb,\n\t\t    struct netlink_ext_ack *extack);\nunsigned int fib4_rules_seq_read(struct net *net);\n\nstatic inline bool fib4_rules_early_flow_dissect(struct net *net,\n\t\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t\t struct flowi4 *fl4,\n\t\t\t\t\t\t struct flow_keys *flkeys)\n{\n\tunsigned int flag = FLOW_DISSECTOR_F_STOP_AT_ENCAP;\n\n\tif (!net->ipv4.fib_rules_require_fldissect)\n\t\treturn false;\n\n\tmemset(flkeys, 0, sizeof(*flkeys));\n\t__skb_flow_dissect(net, skb, &flow_keys_dissector,\n\t\t\t   flkeys, NULL, 0, 0, 0, flag);\n\n\tfl4->fl4_sport = flkeys->ports.src;\n\tfl4->fl4_dport = flkeys->ports.dst;\n\tfl4->flowi4_proto = flkeys->basic.ip_proto;\n\n\treturn true;\n}\n\n#endif  \n\n \nextern const struct nla_policy rtm_ipv4_policy[];\nvoid ip_fib_init(void);\nint fib_gw_from_via(struct fib_config *cfg, struct nlattr *nla,\n\t\t    struct netlink_ext_ack *extack);\n__be32 fib_compute_spec_dst(struct sk_buff *skb);\nbool fib_info_nh_uses_dev(struct fib_info *fi, const struct net_device *dev);\nint fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,\n\t\t\tu8 tos, int oif, struct net_device *dev,\n\t\t\tstruct in_device *idev, u32 *itag);\n#ifdef CONFIG_IP_ROUTE_CLASSID\nstatic inline int fib_num_tclassid_users(struct net *net)\n{\n\treturn atomic_read(&net->ipv4.fib_num_tclassid_users);\n}\n#else\nstatic inline int fib_num_tclassid_users(struct net *net)\n{\n\treturn 0;\n}\n#endif\nint fib_unmerge(struct net *net);\n\nstatic inline bool nhc_l3mdev_matches_dev(const struct fib_nh_common *nhc,\nconst struct net_device *dev)\n{\n\tif (nhc->nhc_dev == dev ||\n\t    l3mdev_master_ifindex_rcu(nhc->nhc_dev) == dev->ifindex)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint ip_fib_check_default(__be32 gw, struct net_device *dev);\nint fib_sync_down_dev(struct net_device *dev, unsigned long event, bool force);\nint fib_sync_down_addr(struct net_device *dev, __be32 local);\nint fib_sync_up(struct net_device *dev, unsigned char nh_flags);\nvoid fib_sync_mtu(struct net_device *dev, u32 orig_mtu);\nvoid fib_nhc_update_mtu(struct fib_nh_common *nhc, u32 new, u32 orig);\n\n \n#define FIB_MULTIPATH_HASH_FIELD_SRC_IP\t\t\tBIT(0)\n#define FIB_MULTIPATH_HASH_FIELD_DST_IP\t\t\tBIT(1)\n#define FIB_MULTIPATH_HASH_FIELD_IP_PROTO\t\tBIT(2)\n#define FIB_MULTIPATH_HASH_FIELD_FLOWLABEL\t\tBIT(3)\n#define FIB_MULTIPATH_HASH_FIELD_SRC_PORT\t\tBIT(4)\n#define FIB_MULTIPATH_HASH_FIELD_DST_PORT\t\tBIT(5)\n#define FIB_MULTIPATH_HASH_FIELD_INNER_SRC_IP\t\tBIT(6)\n#define FIB_MULTIPATH_HASH_FIELD_INNER_DST_IP\t\tBIT(7)\n#define FIB_MULTIPATH_HASH_FIELD_INNER_IP_PROTO\t\tBIT(8)\n#define FIB_MULTIPATH_HASH_FIELD_INNER_FLOWLABEL\tBIT(9)\n#define FIB_MULTIPATH_HASH_FIELD_INNER_SRC_PORT\t\tBIT(10)\n#define FIB_MULTIPATH_HASH_FIELD_INNER_DST_PORT\t\tBIT(11)\n\n#define FIB_MULTIPATH_HASH_FIELD_OUTER_MASK\t\t\\\n\t(FIB_MULTIPATH_HASH_FIELD_SRC_IP |\t\t\\\n\t FIB_MULTIPATH_HASH_FIELD_DST_IP |\t\t\\\n\t FIB_MULTIPATH_HASH_FIELD_IP_PROTO |\t\t\\\n\t FIB_MULTIPATH_HASH_FIELD_FLOWLABEL |\t\t\\\n\t FIB_MULTIPATH_HASH_FIELD_SRC_PORT |\t\t\\\n\t FIB_MULTIPATH_HASH_FIELD_DST_PORT)\n\n#define FIB_MULTIPATH_HASH_FIELD_INNER_MASK\t\t\\\n\t(FIB_MULTIPATH_HASH_FIELD_INNER_SRC_IP |\t\\\n\t FIB_MULTIPATH_HASH_FIELD_INNER_DST_IP |\t\\\n\t FIB_MULTIPATH_HASH_FIELD_INNER_IP_PROTO |\t\\\n\t FIB_MULTIPATH_HASH_FIELD_INNER_FLOWLABEL |\t\\\n\t FIB_MULTIPATH_HASH_FIELD_INNER_SRC_PORT |\t\\\n\t FIB_MULTIPATH_HASH_FIELD_INNER_DST_PORT)\n\n#define FIB_MULTIPATH_HASH_FIELD_ALL_MASK\t\t\\\n\t(FIB_MULTIPATH_HASH_FIELD_OUTER_MASK |\t\t\\\n\t FIB_MULTIPATH_HASH_FIELD_INNER_MASK)\n\n#define FIB_MULTIPATH_HASH_FIELD_DEFAULT_MASK\t\t\\\n\t(FIB_MULTIPATH_HASH_FIELD_SRC_IP |\t\t\\\n\t FIB_MULTIPATH_HASH_FIELD_DST_IP |\t\t\\\n\t FIB_MULTIPATH_HASH_FIELD_IP_PROTO)\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\nint fib_multipath_hash(const struct net *net, const struct flowi4 *fl4,\n\t\t       const struct sk_buff *skb, struct flow_keys *flkeys);\n#endif\nint fib_check_nh(struct net *net, struct fib_nh *nh, u32 table, u8 scope,\n\t\t struct netlink_ext_ack *extack);\nvoid fib_select_multipath(struct fib_result *res, int hash);\nvoid fib_select_path(struct net *net, struct fib_result *res,\n\t\t     struct flowi4 *fl4, const struct sk_buff *skb);\n\nint fib_nh_init(struct net *net, struct fib_nh *fib_nh,\n\t\tstruct fib_config *cfg, int nh_weight,\n\t\tstruct netlink_ext_ack *extack);\nvoid fib_nh_release(struct net *net, struct fib_nh *fib_nh);\nint fib_nh_common_init(struct net *net, struct fib_nh_common *nhc,\n\t\t       struct nlattr *fc_encap, u16 fc_encap_type,\n\t\t       void *cfg, gfp_t gfp_flags,\n\t\t       struct netlink_ext_ack *extack);\nvoid fib_nh_common_release(struct fib_nh_common *nhc);\n\n \nvoid fib_alias_hw_flags_set(struct net *net, const struct fib_rt_info *fri);\nvoid fib_trie_init(void);\nstruct fib_table *fib_trie_table(u32 id, struct fib_table *alias);\nbool fib_lookup_good_nhc(const struct fib_nh_common *nhc, int fib_flags,\n\t\t\t const struct flowi4 *flp);\n\nstatic inline void fib_combine_itag(u32 *itag, const struct fib_result *res)\n{\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tstruct fib_nh_common *nhc = res->nhc;\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\tu32 rtag;\n#endif\n\tif (nhc->nhc_family == AF_INET) {\n\t\tstruct fib_nh *nh;\n\n\t\tnh = container_of(nhc, struct fib_nh, nh_common);\n\t\t*itag = nh->nh_tclassid << 16;\n\t} else {\n\t\t*itag = 0;\n\t}\n\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\trtag = res->tclassid;\n\tif (*itag == 0)\n\t\t*itag = (rtag<<16);\n\t*itag |= (rtag>>16);\n#endif\n#endif\n}\n\nvoid fib_flush(struct net *net);\nvoid free_fib_info(struct fib_info *fi);\n\nstatic inline void fib_info_hold(struct fib_info *fi)\n{\n\trefcount_inc(&fi->fib_clntref);\n}\n\nstatic inline void fib_info_put(struct fib_info *fi)\n{\n\tif (refcount_dec_and_test(&fi->fib_clntref))\n\t\tfree_fib_info(fi);\n}\n\n#ifdef CONFIG_PROC_FS\nint __net_init fib_proc_init(struct net *net);\nvoid __net_exit fib_proc_exit(struct net *net);\n#else\nstatic inline int fib_proc_init(struct net *net)\n{\n\treturn 0;\n}\nstatic inline void fib_proc_exit(struct net *net)\n{\n}\n#endif\n\nu32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr);\n\nint ip_valid_fib_dump_req(struct net *net, const struct nlmsghdr *nlh,\n\t\t\t  struct fib_dump_filter *filter,\n\t\t\t  struct netlink_callback *cb);\n\nint fib_nexthop_info(struct sk_buff *skb, const struct fib_nh_common *nh,\n\t\t     u8 rt_family, unsigned char *flags, bool skip_oif);\nint fib_add_nexthop(struct sk_buff *skb, const struct fib_nh_common *nh,\n\t\t    int nh_weight, u8 rt_family, u32 nh_tclassid);\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}