{
  "module_name": "ip_tunnels.h",
  "hash_id": "3649e9ae217f892ff896840183923f770ce8c41b16d2da9c3dd912b9683caf87",
  "original_prompt": "Ingested from linux-6.6.14/include/net/ip_tunnels.h",
  "human_readable_source": " \n#ifndef __NET_IP_TUNNELS_H\n#define __NET_IP_TUNNELS_H 1\n\n#include <linux/if_tunnel.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n#include <linux/u64_stats_sync.h>\n#include <linux/bitops.h>\n\n#include <net/dsfield.h>\n#include <net/gro_cells.h>\n#include <net/inet_ecn.h>\n#include <net/netns/generic.h>\n#include <net/rtnetlink.h>\n#include <net/lwtunnel.h>\n#include <net/dst_cache.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n#endif\n\n \n#define IPTUNNEL_ERR_TIMEO\t(30*HZ)\n\n \n#define IP_TUNNEL_KEY_SIZE\toffsetofend(struct ip_tunnel_key, tp_dst)\n\n \n#define IP_TUNNEL_KEY_IPV4_PAD\toffsetofend(struct ip_tunnel_key, u.ipv4.dst)\n#define IP_TUNNEL_KEY_IPV4_PAD_LEN\t\t\t\t\\\n\t(sizeof_field(struct ip_tunnel_key, u) -\t\t\\\n\t sizeof_field(struct ip_tunnel_key, u.ipv4))\n\nstruct ip_tunnel_key {\n\t__be64\t\t\ttun_id;\n\tunion {\n\t\tstruct {\n\t\t\t__be32\tsrc;\n\t\t\t__be32\tdst;\n\t\t} ipv4;\n\t\tstruct {\n\t\t\tstruct in6_addr src;\n\t\t\tstruct in6_addr dst;\n\t\t} ipv6;\n\t} u;\n\t__be16\t\t\ttun_flags;\n\tu8\t\t\ttos;\t\t \n\tu8\t\t\tttl;\t\t \n\t__be32\t\t\tlabel;\t\t \n\tu32\t\t\tnhid;\n\t__be16\t\t\ttp_src;\n\t__be16\t\t\ttp_dst;\n\t__u8\t\t\tflow_flags;\n};\n\nstruct ip_tunnel_encap {\n\tu16\t\t\ttype;\n\tu16\t\t\tflags;\n\t__be16\t\t\tsport;\n\t__be16\t\t\tdport;\n};\n\n \n#define IP_TUNNEL_INFO_TX\t0x01\t \n#define IP_TUNNEL_INFO_IPV6\t0x02\t \n#define IP_TUNNEL_INFO_BRIDGE\t0x04\t \n\n \n#define IP_TUNNEL_OPTS_MAX\t\t\t\t\t\\\n\tGENMASK((sizeof_field(struct ip_tunnel_info,\t\t\\\n\t\t\t      options_len) * BITS_PER_BYTE) - 1, 0)\n\n#define ip_tunnel_info_opts(info)\t\t\t\t\\\n\t_Generic(info,\t\t\t\t\t\t\\\n\t\t const struct ip_tunnel_info * : ((const void *)((info) + 1)),\\\n\t\t struct ip_tunnel_info * : ((void *)((info) + 1))\\\n\t)\n\nstruct ip_tunnel_info {\n\tstruct ip_tunnel_key\tkey;\n\tstruct ip_tunnel_encap\tencap;\n#ifdef CONFIG_DST_CACHE\n\tstruct dst_cache\tdst_cache;\n#endif\n\tu8\t\t\toptions_len;\n\tu8\t\t\tmode;\n};\n\n \n#ifdef CONFIG_IPV6_SIT_6RD\nstruct ip_tunnel_6rd_parm {\n\tstruct in6_addr\t\tprefix;\n\t__be32\t\t\trelay_prefix;\n\tu16\t\t\tprefixlen;\n\tu16\t\t\trelay_prefixlen;\n};\n#endif\n\nstruct ip_tunnel_prl_entry {\n\tstruct ip_tunnel_prl_entry __rcu *next;\n\t__be32\t\t\t\taddr;\n\tu16\t\t\t\tflags;\n\tstruct rcu_head\t\t\trcu_head;\n};\n\nstruct metadata_dst;\n\nstruct ip_tunnel {\n\tstruct ip_tunnel __rcu\t*next;\n\tstruct hlist_node hash_node;\n\n\tstruct net_device\t*dev;\n\tnetdevice_tracker\tdev_tracker;\n\n\tstruct net\t\t*net;\t \n\n\tunsigned long\terr_time;\t \n\tint\t\terr_count;\t \n\n\t \n\tu32\t\ti_seqno;\t \n\tatomic_t\to_seqno;\t \n\tint\t\ttun_hlen;\t \n\n\t \n\tu32\t\tindex;\t\t \n\tu8\t\terspan_ver;\t \n\tu8\t\tdir;\t\t \n\tu16\t\thwid;\t\t \n\n\tstruct dst_cache dst_cache;\n\n\tstruct ip_tunnel_parm parms;\n\n\tint\t\tmlink;\n\tint\t\tencap_hlen;\t \n\tint\t\thlen;\t\t \n\tstruct ip_tunnel_encap encap;\n\n\t \n#ifdef CONFIG_IPV6_SIT_6RD\n\tstruct ip_tunnel_6rd_parm ip6rd;\n#endif\n\tstruct ip_tunnel_prl_entry __rcu *prl;\t \n\tunsigned int\t\tprl_count;\t \n\tunsigned int\t\tip_tnl_net_id;\n\tstruct gro_cells\tgro_cells;\n\t__u32\t\t\tfwmark;\n\tbool\t\t\tcollect_md;\n\tbool\t\t\tignore_df;\n};\n\nstruct tnl_ptk_info {\n\t__be16 flags;\n\t__be16 proto;\n\t__be32 key;\n\t__be32 seq;\n\tint hdr_len;\n};\n\n#define PACKET_RCVD\t0\n#define PACKET_REJECT\t1\n#define PACKET_NEXT\t2\n\n#define IP_TNL_HASH_BITS   7\n#define IP_TNL_HASH_SIZE   (1 << IP_TNL_HASH_BITS)\n\nstruct ip_tunnel_net {\n\tstruct net_device *fb_tunnel_dev;\n\tstruct rtnl_link_ops *rtnl_link_ops;\n\tstruct hlist_head tunnels[IP_TNL_HASH_SIZE];\n\tstruct ip_tunnel __rcu *collect_md_tun;\n\tint type;\n};\n\nstatic inline void ip_tunnel_key_init(struct ip_tunnel_key *key,\n\t\t\t\t      __be32 saddr, __be32 daddr,\n\t\t\t\t      u8 tos, u8 ttl, __be32 label,\n\t\t\t\t      __be16 tp_src, __be16 tp_dst,\n\t\t\t\t      __be64 tun_id, __be16 tun_flags)\n{\n\tkey->tun_id = tun_id;\n\tkey->u.ipv4.src = saddr;\n\tkey->u.ipv4.dst = daddr;\n\tmemset((unsigned char *)key + IP_TUNNEL_KEY_IPV4_PAD,\n\t       0, IP_TUNNEL_KEY_IPV4_PAD_LEN);\n\tkey->tos = tos;\n\tkey->ttl = ttl;\n\tkey->label = label;\n\tkey->tun_flags = tun_flags;\n\n\t \n\tkey->tp_src = tp_src;\n\tkey->tp_dst = tp_dst;\n\n\t \n\tif (sizeof(*key) != IP_TUNNEL_KEY_SIZE)\n\t\tmemset((unsigned char *)key + IP_TUNNEL_KEY_SIZE,\n\t\t       0, sizeof(*key) - IP_TUNNEL_KEY_SIZE);\n}\n\nstatic inline bool\nip_tunnel_dst_cache_usable(const struct sk_buff *skb,\n\t\t\t   const struct ip_tunnel_info *info)\n{\n\tif (skb->mark)\n\t\treturn false;\n\tif (!info)\n\t\treturn true;\n\tif (info->key.tun_flags & TUNNEL_NOCACHE)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline unsigned short ip_tunnel_info_af(const struct ip_tunnel_info\n\t\t\t\t\t       *tun_info)\n{\n\treturn tun_info->mode & IP_TUNNEL_INFO_IPV6 ? AF_INET6 : AF_INET;\n}\n\nstatic inline __be64 key32_to_tunnel_id(__be32 key)\n{\n#ifdef __BIG_ENDIAN\n\treturn (__force __be64)key;\n#else\n\treturn (__force __be64)((__force u64)key << 32);\n#endif\n}\n\n \nstatic inline __be32 tunnel_id_to_key32(__be64 tun_id)\n{\n#ifdef __BIG_ENDIAN\n\treturn (__force __be32)tun_id;\n#else\n\treturn (__force __be32)((__force u64)tun_id >> 32);\n#endif\n}\n\n#ifdef CONFIG_INET\n\nstatic inline void ip_tunnel_init_flow(struct flowi4 *fl4,\n\t\t\t\t       int proto,\n\t\t\t\t       __be32 daddr, __be32 saddr,\n\t\t\t\t       __be32 key, __u8 tos,\n\t\t\t\t       struct net *net, int oif,\n\t\t\t\t       __u32 mark, __u32 tun_inner_hash,\n\t\t\t\t       __u8 flow_flags)\n{\n\tmemset(fl4, 0, sizeof(*fl4));\n\n\tif (oif) {\n\t\tfl4->flowi4_l3mdev = l3mdev_master_upper_ifindex_by_index_rcu(net, oif);\n\t\t \n\t\tfl4->flowi4_oif = fl4->flowi4_l3mdev ? 0 : oif;\n\t}\n\n\tfl4->daddr = daddr;\n\tfl4->saddr = saddr;\n\tfl4->flowi4_tos = tos;\n\tfl4->flowi4_proto = proto;\n\tfl4->fl4_gre_key = key;\n\tfl4->flowi4_mark = mark;\n\tfl4->flowi4_multipath_hash = tun_inner_hash;\n\tfl4->flowi4_flags = flow_flags;\n}\n\nint ip_tunnel_init(struct net_device *dev);\nvoid ip_tunnel_uninit(struct net_device *dev);\nvoid  ip_tunnel_dellink(struct net_device *dev, struct list_head *head);\nstruct net *ip_tunnel_get_link_net(const struct net_device *dev);\nint ip_tunnel_get_iflink(const struct net_device *dev);\nint ip_tunnel_init_net(struct net *net, unsigned int ip_tnl_net_id,\n\t\t       struct rtnl_link_ops *ops, char *devname);\n\nvoid ip_tunnel_delete_nets(struct list_head *list_net, unsigned int id,\n\t\t\t   struct rtnl_link_ops *ops);\n\nvoid ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t    const struct iphdr *tnl_params, const u8 protocol);\nvoid ip_md_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t       const u8 proto, int tunnel_hlen);\nint ip_tunnel_ctl(struct net_device *dev, struct ip_tunnel_parm *p, int cmd);\nint ip_tunnel_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t     void __user *data, int cmd);\nint __ip_tunnel_change_mtu(struct net_device *dev, int new_mtu, bool strict);\nint ip_tunnel_change_mtu(struct net_device *dev, int new_mtu);\n\nstruct ip_tunnel *ip_tunnel_lookup(struct ip_tunnel_net *itn,\n\t\t\t\t   int link, __be16 flags,\n\t\t\t\t   __be32 remote, __be32 local,\n\t\t\t\t   __be32 key);\n\nvoid ip_tunnel_md_udp_encap(struct sk_buff *skb, struct ip_tunnel_info *info);\nint ip_tunnel_rcv(struct ip_tunnel *tunnel, struct sk_buff *skb,\n\t\t  const struct tnl_ptk_info *tpi, struct metadata_dst *tun_dst,\n\t\t  bool log_ecn_error);\nint ip_tunnel_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t struct ip_tunnel_parm *p, __u32 fwmark);\nint ip_tunnel_newlink(struct net_device *dev, struct nlattr *tb[],\n\t\t      struct ip_tunnel_parm *p, __u32 fwmark);\nvoid ip_tunnel_setup(struct net_device *dev, unsigned int net_id);\n\nbool ip_tunnel_netlink_encap_parms(struct nlattr *data[],\n\t\t\t\t   struct ip_tunnel_encap *encap);\n\nvoid ip_tunnel_netlink_parms(struct nlattr *data[],\n\t\t\t     struct ip_tunnel_parm *parms);\n\nextern const struct header_ops ip_tunnel_header_ops;\n__be16 ip_tunnel_parse_protocol(const struct sk_buff *skb);\n\nstruct ip_tunnel_encap_ops {\n\tsize_t (*encap_hlen)(struct ip_tunnel_encap *e);\n\tint (*build_header)(struct sk_buff *skb, struct ip_tunnel_encap *e,\n\t\t\t    u8 *protocol, struct flowi4 *fl4);\n\tint (*err_handler)(struct sk_buff *skb, u32 info);\n};\n\n#define MAX_IPTUN_ENCAP_OPS 8\n\nextern const struct ip_tunnel_encap_ops __rcu *\n\t\tiptun_encaps[MAX_IPTUN_ENCAP_OPS];\n\nint ip_tunnel_encap_add_ops(const struct ip_tunnel_encap_ops *op,\n\t\t\t    unsigned int num);\nint ip_tunnel_encap_del_ops(const struct ip_tunnel_encap_ops *op,\n\t\t\t    unsigned int num);\n\nint ip_tunnel_encap_setup(struct ip_tunnel *t,\n\t\t\t  struct ip_tunnel_encap *ipencap);\n\nstatic inline bool pskb_inet_may_pull(struct sk_buff *skb)\n{\n\tint nhlen;\n\n\tswitch (skb->protocol) {\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tnhlen = sizeof(struct ipv6hdr);\n\t\tbreak;\n#endif\n\tcase htons(ETH_P_IP):\n\t\tnhlen = sizeof(struct iphdr);\n\t\tbreak;\n\tdefault:\n\t\tnhlen = 0;\n\t}\n\n\treturn pskb_network_may_pull(skb, nhlen);\n}\n\nstatic inline int ip_encap_hlen(struct ip_tunnel_encap *e)\n{\n\tconst struct ip_tunnel_encap_ops *ops;\n\tint hlen = -EINVAL;\n\n\tif (e->type == TUNNEL_ENCAP_NONE)\n\t\treturn 0;\n\n\tif (e->type >= MAX_IPTUN_ENCAP_OPS)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tops = rcu_dereference(iptun_encaps[e->type]);\n\tif (likely(ops && ops->encap_hlen))\n\t\thlen = ops->encap_hlen(e);\n\trcu_read_unlock();\n\n\treturn hlen;\n}\n\nstatic inline int ip_tunnel_encap(struct sk_buff *skb,\n\t\t\t\t  struct ip_tunnel_encap *e,\n\t\t\t\t  u8 *protocol, struct flowi4 *fl4)\n{\n\tconst struct ip_tunnel_encap_ops *ops;\n\tint ret = -EINVAL;\n\n\tif (e->type == TUNNEL_ENCAP_NONE)\n\t\treturn 0;\n\n\tif (e->type >= MAX_IPTUN_ENCAP_OPS)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tops = rcu_dereference(iptun_encaps[e->type]);\n\tif (likely(ops && ops->build_header))\n\t\tret = ops->build_header(skb, e, protocol, fl4);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n \nstatic inline u8 ip_tunnel_get_dsfield(const struct iphdr *iph,\n\t\t\t\t       const struct sk_buff *skb)\n{\n\t__be16 payload_protocol = skb_protocol(skb, true);\n\n\tif (payload_protocol == htons(ETH_P_IP))\n\t\treturn iph->tos;\n\telse if (payload_protocol == htons(ETH_P_IPV6))\n\t\treturn ipv6_get_dsfield((const struct ipv6hdr *)iph);\n\telse\n\t\treturn 0;\n}\n\nstatic inline u8 ip_tunnel_get_ttl(const struct iphdr *iph,\n\t\t\t\t       const struct sk_buff *skb)\n{\n\t__be16 payload_protocol = skb_protocol(skb, true);\n\n\tif (payload_protocol == htons(ETH_P_IP))\n\t\treturn iph->ttl;\n\telse if (payload_protocol == htons(ETH_P_IPV6))\n\t\treturn ((const struct ipv6hdr *)iph)->hop_limit;\n\telse\n\t\treturn 0;\n}\n\n \nstatic inline u8 ip_tunnel_ecn_encap(u8 tos, const struct iphdr *iph,\n\t\t\t\t     const struct sk_buff *skb)\n{\n\tu8 inner = ip_tunnel_get_dsfield(iph, skb);\n\n\treturn INET_ECN_encapsulate(tos, inner);\n}\n\nint __iptunnel_pull_header(struct sk_buff *skb, int hdr_len,\n\t\t\t   __be16 inner_proto, bool raw_proto, bool xnet);\n\nstatic inline int iptunnel_pull_header(struct sk_buff *skb, int hdr_len,\n\t\t\t\t       __be16 inner_proto, bool xnet)\n{\n\treturn __iptunnel_pull_header(skb, hdr_len, inner_proto, false, xnet);\n}\n\nvoid iptunnel_xmit(struct sock *sk, struct rtable *rt, struct sk_buff *skb,\n\t\t   __be32 src, __be32 dst, u8 proto,\n\t\t   u8 tos, u8 ttl, __be16 df, bool xnet);\nstruct metadata_dst *iptunnel_metadata_reply(struct metadata_dst *md,\n\t\t\t\t\t     gfp_t flags);\nint skb_tunnel_check_pmtu(struct sk_buff *skb, struct dst_entry *encap_dst,\n\t\t\t  int headroom, bool reply);\n\nint iptunnel_handle_offloads(struct sk_buff *skb, int gso_type_mask);\n\nstatic inline int iptunnel_pull_offloads(struct sk_buff *skb)\n{\n\tif (skb_is_gso(skb)) {\n\t\tint err;\n\n\t\terr = skb_unclone(skb, GFP_ATOMIC);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tskb_shinfo(skb)->gso_type &= ~(NETIF_F_GSO_ENCAP_ALL >>\n\t\t\t\t\t       NETIF_F_GSO_SHIFT);\n\t}\n\n\tskb->encapsulation = 0;\n\treturn 0;\n}\n\nstatic inline void iptunnel_xmit_stats(struct net_device *dev, int pkt_len)\n{\n\tif (pkt_len > 0) {\n\t\tstruct pcpu_sw_netstats *tstats = get_cpu_ptr(dev->tstats);\n\n\t\tu64_stats_update_begin(&tstats->syncp);\n\t\tu64_stats_add(&tstats->tx_bytes, pkt_len);\n\t\tu64_stats_inc(&tstats->tx_packets);\n\t\tu64_stats_update_end(&tstats->syncp);\n\t\tput_cpu_ptr(tstats);\n\t\treturn;\n\t}\n\n\tif (pkt_len < 0) {\n\t\tDEV_STATS_INC(dev, tx_errors);\n\t\tDEV_STATS_INC(dev, tx_aborted_errors);\n\t} else {\n\t\tDEV_STATS_INC(dev, tx_dropped);\n\t}\n}\n\nstatic inline void ip_tunnel_info_opts_get(void *to,\n\t\t\t\t\t   const struct ip_tunnel_info *info)\n{\n\tmemcpy(to, info + 1, info->options_len);\n}\n\nstatic inline void ip_tunnel_info_opts_set(struct ip_tunnel_info *info,\n\t\t\t\t\t   const void *from, int len,\n\t\t\t\t\t   __be16 flags)\n{\n\tinfo->options_len = len;\n\tif (len > 0) {\n\t\tmemcpy(ip_tunnel_info_opts(info), from, len);\n\t\tinfo->key.tun_flags |= flags;\n\t}\n}\n\nstatic inline struct ip_tunnel_info *lwt_tun_info(struct lwtunnel_state *lwtstate)\n{\n\treturn (struct ip_tunnel_info *)lwtstate->data;\n}\n\nDECLARE_STATIC_KEY_FALSE(ip_tunnel_metadata_cnt);\n\n \nstatic inline int ip_tunnel_collect_metadata(void)\n{\n\treturn static_branch_unlikely(&ip_tunnel_metadata_cnt);\n}\n\nvoid __init ip_tunnel_core_init(void);\n\nvoid ip_tunnel_need_metadata(void);\nvoid ip_tunnel_unneed_metadata(void);\n\n#else  \n\nstatic inline struct ip_tunnel_info *lwt_tun_info(struct lwtunnel_state *lwtstate)\n{\n\treturn NULL;\n}\n\nstatic inline void ip_tunnel_need_metadata(void)\n{\n}\n\nstatic inline void ip_tunnel_unneed_metadata(void)\n{\n}\n\nstatic inline void ip_tunnel_info_opts_get(void *to,\n\t\t\t\t\t   const struct ip_tunnel_info *info)\n{\n}\n\nstatic inline void ip_tunnel_info_opts_set(struct ip_tunnel_info *info,\n\t\t\t\t\t   const void *from, int len,\n\t\t\t\t\t   __be16 flags)\n{\n\tinfo->options_len = 0;\n}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}