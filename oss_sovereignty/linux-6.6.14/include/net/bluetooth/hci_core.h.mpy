{
  "module_name": "hci_core.h",
  "hash_id": "8c00a91fccc87a55465f2f1c6c02205c816d38419170c8f0d5bbe4ed1eed5180",
  "original_prompt": "Ingested from linux-6.6.14/include/net/bluetooth/hci_core.h",
  "human_readable_source": " \n\n#ifndef __HCI_CORE_H\n#define __HCI_CORE_H\n\n#include <linux/idr.h>\n#include <linux/leds.h>\n#include <linux/rculist.h>\n\n#include <net/bluetooth/hci.h>\n#include <net/bluetooth/hci_sync.h>\n#include <net/bluetooth/hci_sock.h>\n#include <net/bluetooth/coredump.h>\n\n \n#define HCI_PRIO_MAX\t7\n\n \n#define HCI_MAX_ID 10000\n\n \nstruct inquiry_data {\n\tbdaddr_t\tbdaddr;\n\t__u8\t\tpscan_rep_mode;\n\t__u8\t\tpscan_period_mode;\n\t__u8\t\tpscan_mode;\n\t__u8\t\tdev_class[3];\n\t__le16\t\tclock_offset;\n\t__s8\t\trssi;\n\t__u8\t\tssp_mode;\n};\n\nstruct inquiry_entry {\n\tstruct list_head\tall;\t\t \n\tstruct list_head\tlist;\t\t \n\tenum {\n\t\tNAME_NOT_KNOWN,\n\t\tNAME_NEEDED,\n\t\tNAME_PENDING,\n\t\tNAME_KNOWN,\n\t} name_state;\n\t__u32\t\t\ttimestamp;\n\tstruct inquiry_data\tdata;\n};\n\nstruct discovery_state {\n\tint\t\t\ttype;\n\tenum {\n\t\tDISCOVERY_STOPPED,\n\t\tDISCOVERY_STARTING,\n\t\tDISCOVERY_FINDING,\n\t\tDISCOVERY_RESOLVING,\n\t\tDISCOVERY_STOPPING,\n\t} state;\n\tstruct list_head\tall;\t \n\tstruct list_head\tunknown;\t \n\tstruct list_head\tresolve;\t \n\t__u32\t\t\ttimestamp;\n\tbdaddr_t\t\tlast_adv_addr;\n\tu8\t\t\tlast_adv_addr_type;\n\ts8\t\t\tlast_adv_rssi;\n\tu32\t\t\tlast_adv_flags;\n\tu8\t\t\tlast_adv_data[HCI_MAX_EXT_AD_LENGTH];\n\tu8\t\t\tlast_adv_data_len;\n\tbool\t\t\treport_invalid_rssi;\n\tbool\t\t\tresult_filtering;\n\tbool\t\t\tlimited;\n\ts8\t\t\trssi;\n\tu16\t\t\tuuid_count;\n\tu8\t\t\t(*uuids)[16];\n\tunsigned long\t\tscan_start;\n\tunsigned long\t\tscan_duration;\n\tunsigned long\t\tname_resolve_timeout;\n};\n\n#define SUSPEND_NOTIFIER_TIMEOUT\tmsecs_to_jiffies(2000)  \n\nenum suspend_tasks {\n\tSUSPEND_PAUSE_DISCOVERY,\n\tSUSPEND_UNPAUSE_DISCOVERY,\n\n\tSUSPEND_PAUSE_ADVERTISING,\n\tSUSPEND_UNPAUSE_ADVERTISING,\n\n\tSUSPEND_SCAN_DISABLE,\n\tSUSPEND_SCAN_ENABLE,\n\tSUSPEND_DISCONNECTING,\n\n\tSUSPEND_POWERING_DOWN,\n\n\tSUSPEND_PREPARE_NOTIFIER,\n\n\tSUSPEND_SET_ADV_FILTER,\n\t__SUSPEND_NUM_TASKS\n};\n\nenum suspended_state {\n\tBT_RUNNING = 0,\n\tBT_SUSPEND_DISCONNECT,\n\tBT_SUSPEND_CONFIGURE_WAKE,\n};\n\nstruct hci_conn_hash {\n\tstruct list_head list;\n\tunsigned int     acl_num;\n\tunsigned int     amp_num;\n\tunsigned int     sco_num;\n\tunsigned int     iso_num;\n\tunsigned int     le_num;\n\tunsigned int     le_num_peripheral;\n};\n\nstruct bdaddr_list {\n\tstruct list_head list;\n\tbdaddr_t bdaddr;\n\tu8 bdaddr_type;\n};\n\nstruct codec_list {\n\tstruct list_head list;\n\tu8\tid;\n\t__u16\tcid;\n\t__u16\tvid;\n\tu8\ttransport;\n\tu8\tnum_caps;\n\tu32\tlen;\n\tstruct hci_codec_caps caps[];\n};\n\nstruct bdaddr_list_with_irk {\n\tstruct list_head list;\n\tbdaddr_t bdaddr;\n\tu8 bdaddr_type;\n\tu8 peer_irk[16];\n\tu8 local_irk[16];\n};\n\n \nenum hci_conn_flags {\n\tHCI_CONN_FLAG_REMOTE_WAKEUP = 1,\n\tHCI_CONN_FLAG_DEVICE_PRIVACY = 2,\n};\ntypedef u8 hci_conn_flags_t;\n\nstruct bdaddr_list_with_flags {\n\tstruct list_head list;\n\tbdaddr_t bdaddr;\n\tu8 bdaddr_type;\n\thci_conn_flags_t flags;\n};\n\nstruct bt_uuid {\n\tstruct list_head list;\n\tu8 uuid[16];\n\tu8 size;\n\tu8 svc_hint;\n};\n\nstruct blocked_key {\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n\tu8 type;\n\tu8 val[16];\n};\n\nstruct smp_csrk {\n\tbdaddr_t bdaddr;\n\tu8 bdaddr_type;\n\tu8 link_type;\n\tu8 type;\n\tu8 val[16];\n};\n\nstruct smp_ltk {\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n\tbdaddr_t bdaddr;\n\tu8 bdaddr_type;\n\tu8 link_type;\n\tu8 authenticated;\n\tu8 type;\n\tu8 enc_size;\n\t__le16 ediv;\n\t__le64 rand;\n\tu8 val[16];\n};\n\nstruct smp_irk {\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n\tbdaddr_t rpa;\n\tbdaddr_t bdaddr;\n\tu8 addr_type;\n\tu8 link_type;\n\tu8 val[16];\n};\n\nstruct link_key {\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n\tbdaddr_t bdaddr;\n\tu8 bdaddr_type;\n\tu8 link_type;\n\tu8 type;\n\tu8 val[HCI_LINK_KEY_SIZE];\n\tu8 pin_len;\n};\n\nstruct oob_data {\n\tstruct list_head list;\n\tbdaddr_t bdaddr;\n\tu8 bdaddr_type;\n\tu8 present;\n\tu8 hash192[16];\n\tu8 rand192[16];\n\tu8 hash256[16];\n\tu8 rand256[16];\n};\n\nstruct adv_info {\n\tstruct list_head list;\n\tbool\tenabled;\n\tbool\tpending;\n\tbool\tperiodic;\n\t__u8\tmesh;\n\t__u8\tinstance;\n\t__u32\tflags;\n\t__u16\ttimeout;\n\t__u16\tremaining_time;\n\t__u16\tduration;\n\t__u16\tadv_data_len;\n\t__u8\tadv_data[HCI_MAX_EXT_AD_LENGTH];\n\tbool\tadv_data_changed;\n\t__u16\tscan_rsp_len;\n\t__u8\tscan_rsp_data[HCI_MAX_EXT_AD_LENGTH];\n\tbool\tscan_rsp_changed;\n\t__u16\tper_adv_data_len;\n\t__u8\tper_adv_data[HCI_MAX_PER_AD_LENGTH];\n\t__s8\ttx_power;\n\t__u32   min_interval;\n\t__u32   max_interval;\n\tbdaddr_t\trandom_addr;\n\tbool \t\trpa_expired;\n\tstruct delayed_work\trpa_expired_cb;\n};\n\n#define HCI_MAX_ADV_INSTANCES\t\t5\n#define HCI_DEFAULT_ADV_DURATION\t2\n\n#define HCI_ADV_TX_POWER_NO_PREFERENCE 0x7F\n\n#define DATA_CMP(_d1, _l1, _d2, _l2) \\\n\t(_l1 == _l2 ? memcmp(_d1, _d2, _l1) : _l1 - _l2)\n\n#define ADV_DATA_CMP(_adv, _data, _len) \\\n\tDATA_CMP((_adv)->adv_data, (_adv)->adv_data_len, _data, _len)\n\n#define SCAN_RSP_CMP(_adv, _data, _len) \\\n\tDATA_CMP((_adv)->scan_rsp_data, (_adv)->scan_rsp_len, _data, _len)\n\nstruct monitored_device {\n\tstruct list_head list;\n\n\tbdaddr_t bdaddr;\n\t__u8     addr_type;\n\t__u16    handle;\n\tbool     notified;\n};\n\nstruct adv_pattern {\n\tstruct list_head list;\n\t__u8 ad_type;\n\t__u8 offset;\n\t__u8 length;\n\t__u8 value[HCI_MAX_EXT_AD_LENGTH];\n};\n\nstruct adv_rssi_thresholds {\n\t__s8 low_threshold;\n\t__s8 high_threshold;\n\t__u16 low_threshold_timeout;\n\t__u16 high_threshold_timeout;\n\t__u8 sampling_period;\n};\n\nstruct adv_monitor {\n\tstruct list_head patterns;\n\tstruct adv_rssi_thresholds rssi;\n\t__u16\t\thandle;\n\n\tenum {\n\t\tADV_MONITOR_STATE_NOT_REGISTERED,\n\t\tADV_MONITOR_STATE_REGISTERED,\n\t\tADV_MONITOR_STATE_OFFLOADED\n\t} state;\n};\n\n#define HCI_MIN_ADV_MONITOR_HANDLE\t\t1\n#define HCI_MAX_ADV_MONITOR_NUM_HANDLES\t\t32\n#define HCI_MAX_ADV_MONITOR_NUM_PATTERNS\t16\n#define HCI_ADV_MONITOR_EXT_NONE\t\t1\n#define HCI_ADV_MONITOR_EXT_MSFT\t\t2\n\n#define HCI_MAX_SHORT_NAME_LENGTH\t10\n\n#define HCI_CONN_HANDLE_MAX\t\t0x0eff\n#define HCI_CONN_HANDLE_UNSET(_handle)\t(_handle > HCI_CONN_HANDLE_MAX)\n\n \n#define HCI_MIN_ENC_KEY_SIZE\t\t7\n\n \n#define HCI_DEFAULT_RPA_TIMEOUT\t\t(15 * 60)\n\n \n#define DEFAULT_CONN_INFO_MIN_AGE\t1000\n#define DEFAULT_CONN_INFO_MAX_AGE\t3000\n \n#define DEFAULT_AUTH_PAYLOAD_TIMEOUT   0x0bb8\n\nstruct amp_assoc {\n\t__u16\tlen;\n\t__u16\toffset;\n\t__u16\trem_len;\n\t__u16\tlen_so_far;\n\t__u8\tdata[HCI_MAX_AMP_ASSOC_SIZE];\n};\n\n#define HCI_MAX_PAGES\t3\n\nstruct hci_dev {\n\tstruct list_head list;\n\tstruct mutex\tlock;\n\n\tstruct ida\tunset_handle_ida;\n\n\tconst char\t*name;\n\tunsigned long\tflags;\n\t__u16\t\tid;\n\t__u8\t\tbus;\n\t__u8\t\tdev_type;\n\tbdaddr_t\tbdaddr;\n\tbdaddr_t\tsetup_addr;\n\tbdaddr_t\tpublic_addr;\n\tbdaddr_t\trandom_addr;\n\tbdaddr_t\tstatic_addr;\n\t__u8\t\tadv_addr_type;\n\t__u8\t\tdev_name[HCI_MAX_NAME_LENGTH];\n\t__u8\t\tshort_name[HCI_MAX_SHORT_NAME_LENGTH];\n\t__u8\t\teir[HCI_MAX_EIR_LENGTH];\n\t__u16\t\tappearance;\n\t__u8\t\tdev_class[3];\n\t__u8\t\tmajor_class;\n\t__u8\t\tminor_class;\n\t__u8\t\tmax_page;\n\t__u8\t\tfeatures[HCI_MAX_PAGES][8];\n\t__u8\t\tle_features[8];\n\t__u8\t\tle_accept_list_size;\n\t__u8\t\tle_resolv_list_size;\n\t__u8\t\tle_num_of_adv_sets;\n\t__u8\t\tle_states[8];\n\t__u8\t\tmesh_ad_types[16];\n\t__u8\t\tmesh_send_ref;\n\t__u8\t\tcommands[64];\n\t__u8\t\thci_ver;\n\t__u16\t\thci_rev;\n\t__u8\t\tlmp_ver;\n\t__u16\t\tmanufacturer;\n\t__u16\t\tlmp_subver;\n\t__u16\t\tvoice_setting;\n\t__u8\t\tnum_iac;\n\t__u16\t\tstored_max_keys;\n\t__u16\t\tstored_num_keys;\n\t__u8\t\tio_capability;\n\t__s8\t\tinq_tx_power;\n\t__u8\t\terr_data_reporting;\n\t__u16\t\tpage_scan_interval;\n\t__u16\t\tpage_scan_window;\n\t__u8\t\tpage_scan_type;\n\t__u8\t\tle_adv_channel_map;\n\t__u16\t\tle_adv_min_interval;\n\t__u16\t\tle_adv_max_interval;\n\t__u8\t\tle_scan_type;\n\t__u16\t\tle_scan_interval;\n\t__u16\t\tle_scan_window;\n\t__u16\t\tle_scan_int_suspend;\n\t__u16\t\tle_scan_window_suspend;\n\t__u16\t\tle_scan_int_discovery;\n\t__u16\t\tle_scan_window_discovery;\n\t__u16\t\tle_scan_int_adv_monitor;\n\t__u16\t\tle_scan_window_adv_monitor;\n\t__u16\t\tle_scan_int_connect;\n\t__u16\t\tle_scan_window_connect;\n\t__u16\t\tle_conn_min_interval;\n\t__u16\t\tle_conn_max_interval;\n\t__u16\t\tle_conn_latency;\n\t__u16\t\tle_supv_timeout;\n\t__u16\t\tle_def_tx_len;\n\t__u16\t\tle_def_tx_time;\n\t__u16\t\tle_max_tx_len;\n\t__u16\t\tle_max_tx_time;\n\t__u16\t\tle_max_rx_len;\n\t__u16\t\tle_max_rx_time;\n\t__u8\t\tle_max_key_size;\n\t__u8\t\tle_min_key_size;\n\t__u16\t\tdiscov_interleaved_timeout;\n\t__u16\t\tconn_info_min_age;\n\t__u16\t\tconn_info_max_age;\n\t__u16\t\tauth_payload_timeout;\n\t__u8\t\tmin_enc_key_size;\n\t__u8\t\tmax_enc_key_size;\n\t__u8\t\tpairing_opts;\n\t__u8\t\tssp_debug_mode;\n\t__u8\t\thw_error_code;\n\t__u32\t\tclock;\n\t__u16\t\tadvmon_allowlist_duration;\n\t__u16\t\tadvmon_no_filter_duration;\n\t__u8\t\tenable_advmon_interleave_scan;\n\n\t__u16\t\tdevid_source;\n\t__u16\t\tdevid_vendor;\n\t__u16\t\tdevid_product;\n\t__u16\t\tdevid_version;\n\n\t__u8\t\tdef_page_scan_type;\n\t__u16\t\tdef_page_scan_int;\n\t__u16\t\tdef_page_scan_window;\n\t__u8\t\tdef_inq_scan_type;\n\t__u16\t\tdef_inq_scan_int;\n\t__u16\t\tdef_inq_scan_window;\n\t__u16\t\tdef_br_lsto;\n\t__u16\t\tdef_page_timeout;\n\t__u16\t\tdef_multi_adv_rotation_duration;\n\t__u16\t\tdef_le_autoconnect_timeout;\n\t__s8\t\tmin_le_tx_power;\n\t__s8\t\tmax_le_tx_power;\n\n\t__u16\t\tpkt_type;\n\t__u16\t\tesco_type;\n\t__u16\t\tlink_policy;\n\t__u16\t\tlink_mode;\n\n\t__u32\t\tidle_timeout;\n\t__u16\t\tsniff_min_interval;\n\t__u16\t\tsniff_max_interval;\n\n\t__u8\t\tamp_status;\n\t__u32\t\tamp_total_bw;\n\t__u32\t\tamp_max_bw;\n\t__u32\t\tamp_min_latency;\n\t__u32\t\tamp_max_pdu;\n\t__u8\t\tamp_type;\n\t__u16\t\tamp_pal_cap;\n\t__u16\t\tamp_assoc_size;\n\t__u32\t\tamp_max_flush_to;\n\t__u32\t\tamp_be_flush_to;\n\n\tstruct amp_assoc\tloc_assoc;\n\n\t__u8\t\tflow_ctl_mode;\n\n\tunsigned int\tauto_accept_delay;\n\n\tunsigned long\tquirks;\n\n\tatomic_t\tcmd_cnt;\n\tunsigned int\tacl_cnt;\n\tunsigned int\tsco_cnt;\n\tunsigned int\tle_cnt;\n\tunsigned int\tiso_cnt;\n\n\tunsigned int\tacl_mtu;\n\tunsigned int\tsco_mtu;\n\tunsigned int\tle_mtu;\n\tunsigned int\tiso_mtu;\n\tunsigned int\tacl_pkts;\n\tunsigned int\tsco_pkts;\n\tunsigned int\tle_pkts;\n\tunsigned int\tiso_pkts;\n\n\t__u16\t\tblock_len;\n\t__u16\t\tblock_mtu;\n\t__u16\t\tnum_blocks;\n\t__u16\t\tblock_cnt;\n\n\tunsigned long\tacl_last_tx;\n\tunsigned long\tsco_last_tx;\n\tunsigned long\tle_last_tx;\n\n\t__u8\t\tle_tx_def_phys;\n\t__u8\t\tle_rx_def_phys;\n\n\tstruct workqueue_struct\t*workqueue;\n\tstruct workqueue_struct\t*req_workqueue;\n\n\tstruct work_struct\tpower_on;\n\tstruct delayed_work\tpower_off;\n\tstruct work_struct\terror_reset;\n\tstruct work_struct\tcmd_sync_work;\n\tstruct list_head\tcmd_sync_work_list;\n\tstruct mutex\t\tcmd_sync_work_lock;\n\tstruct mutex\t\tunregister_lock;\n\tstruct work_struct\tcmd_sync_cancel_work;\n\tstruct work_struct\treenable_adv_work;\n\n\t__u16\t\t\tdiscov_timeout;\n\tstruct delayed_work\tdiscov_off;\n\n\tstruct delayed_work\tservice_cache;\n\n\tstruct delayed_work\tcmd_timer;\n\tstruct delayed_work\tncmd_timer;\n\n\tstruct work_struct\trx_work;\n\tstruct work_struct\tcmd_work;\n\tstruct work_struct\ttx_work;\n\n\tstruct delayed_work\tle_scan_disable;\n\tstruct delayed_work\tle_scan_restart;\n\n\tstruct sk_buff_head\trx_q;\n\tstruct sk_buff_head\traw_q;\n\tstruct sk_buff_head\tcmd_q;\n\n\tstruct sk_buff\t\t*sent_cmd;\n\tstruct sk_buff\t\t*recv_event;\n\n\tstruct mutex\t\treq_lock;\n\twait_queue_head_t\treq_wait_q;\n\t__u32\t\t\treq_status;\n\t__u32\t\t\treq_result;\n\tstruct sk_buff\t\t*req_skb;\n\n\tvoid\t\t\t*smp_data;\n\tvoid\t\t\t*smp_bredr_data;\n\n\tstruct discovery_state\tdiscovery;\n\n\tint\t\t\tdiscovery_old_state;\n\tbool\t\t\tdiscovery_paused;\n\tint\t\t\tadvertising_old_state;\n\tbool\t\t\tadvertising_paused;\n\n\tstruct notifier_block\tsuspend_notifier;\n\tenum suspended_state\tsuspend_state_next;\n\tenum suspended_state\tsuspend_state;\n\tbool\t\t\tscanning_paused;\n\tbool\t\t\tsuspended;\n\tu8\t\t\twake_reason;\n\tbdaddr_t\t\twake_addr;\n\tu8\t\t\twake_addr_type;\n\n\tstruct hci_conn_hash\tconn_hash;\n\n\tstruct list_head\tmesh_pending;\n\tstruct list_head\tmgmt_pending;\n\tstruct list_head\treject_list;\n\tstruct list_head\taccept_list;\n\tstruct list_head\tuuids;\n\tstruct list_head\tlink_keys;\n\tstruct list_head\tlong_term_keys;\n\tstruct list_head\tidentity_resolving_keys;\n\tstruct list_head\tremote_oob_data;\n\tstruct list_head\tle_accept_list;\n\tstruct list_head\tle_resolv_list;\n\tstruct list_head\tle_conn_params;\n\tstruct list_head\tpend_le_conns;\n\tstruct list_head\tpend_le_reports;\n\tstruct list_head\tblocked_keys;\n\tstruct list_head\tlocal_codecs;\n\n\tstruct hci_dev_stats\tstat;\n\n\tatomic_t\t\tpromisc;\n\n\tconst char\t\t*hw_info;\n\tconst char\t\t*fw_info;\n\tstruct dentry\t\t*debugfs;\n\n\tstruct hci_devcoredump\tdump;\n\n\tstruct device\t\tdev;\n\n\tstruct rfkill\t\t*rfkill;\n\n\tDECLARE_BITMAP(dev_flags, __HCI_NUM_FLAGS);\n\thci_conn_flags_t\tconn_flags;\n\n\t__s8\t\t\tadv_tx_power;\n\t__u8\t\t\tadv_data[HCI_MAX_EXT_AD_LENGTH];\n\t__u8\t\t\tadv_data_len;\n\t__u8\t\t\tscan_rsp_data[HCI_MAX_EXT_AD_LENGTH];\n\t__u8\t\t\tscan_rsp_data_len;\n\t__u8\t\t\tper_adv_data[HCI_MAX_PER_AD_LENGTH];\n\t__u8\t\t\tper_adv_data_len;\n\n\tstruct list_head\tadv_instances;\n\tunsigned int\t\tadv_instance_cnt;\n\t__u8\t\t\tcur_adv_instance;\n\t__u16\t\t\tadv_instance_timeout;\n\tstruct delayed_work\tadv_instance_expire;\n\n\tstruct idr\t\tadv_monitors_idr;\n\tunsigned int\t\tadv_monitors_cnt;\n\n\t__u8\t\t\tirk[16];\n\t__u32\t\t\trpa_timeout;\n\tstruct delayed_work\trpa_expired;\n\tbdaddr_t\t\trpa;\n\n\tstruct delayed_work\tmesh_send_done;\n\n\tenum {\n\t\tINTERLEAVE_SCAN_NONE,\n\t\tINTERLEAVE_SCAN_NO_FILTER,\n\t\tINTERLEAVE_SCAN_ALLOWLIST\n\t} interleave_scan_state;\n\n\tstruct delayed_work\tinterleave_scan;\n\n\tstruct list_head\tmonitored_devices;\n\tbool\t\t\tadvmon_pend_notify;\n\n#if IS_ENABLED(CONFIG_BT_LEDS)\n\tstruct led_trigger\t*power_led;\n#endif\n\n#if IS_ENABLED(CONFIG_BT_MSFTEXT)\n\t__u16\t\t\tmsft_opcode;\n\tvoid\t\t\t*msft_data;\n\tbool\t\t\tmsft_curve_validity;\n#endif\n\n#if IS_ENABLED(CONFIG_BT_AOSPEXT)\n\tbool\t\t\taosp_capable;\n\tbool\t\t\taosp_quality_report;\n#endif\n\n\tint (*open)(struct hci_dev *hdev);\n\tint (*close)(struct hci_dev *hdev);\n\tint (*flush)(struct hci_dev *hdev);\n\tint (*setup)(struct hci_dev *hdev);\n\tint (*shutdown)(struct hci_dev *hdev);\n\tint (*send)(struct hci_dev *hdev, struct sk_buff *skb);\n\tvoid (*notify)(struct hci_dev *hdev, unsigned int evt);\n\tvoid (*hw_error)(struct hci_dev *hdev, u8 code);\n\tint (*post_init)(struct hci_dev *hdev);\n\tint (*set_diag)(struct hci_dev *hdev, bool enable);\n\tint (*set_bdaddr)(struct hci_dev *hdev, const bdaddr_t *bdaddr);\n\tvoid (*cmd_timeout)(struct hci_dev *hdev);\n\tvoid (*reset)(struct hci_dev *hdev);\n\tbool (*wakeup)(struct hci_dev *hdev);\n\tint (*set_quality_report)(struct hci_dev *hdev, bool enable);\n\tint (*get_data_path_id)(struct hci_dev *hdev, __u8 *data_path);\n\tint (*get_codec_config_data)(struct hci_dev *hdev, __u8 type,\n\t\t\t\t     struct bt_codec *codec, __u8 *vnd_len,\n\t\t\t\t     __u8 **vnd_data);\n};\n\n#define HCI_PHY_HANDLE(handle)\t(handle & 0xff)\n\nenum conn_reasons {\n\tCONN_REASON_PAIR_DEVICE,\n\tCONN_REASON_L2CAP_CHAN,\n\tCONN_REASON_SCO_CONNECT,\n\tCONN_REASON_ISO_CONNECT,\n};\n\nstruct hci_conn {\n\tstruct list_head list;\n\n\tatomic_t\trefcnt;\n\n\tbdaddr_t\tdst;\n\t__u8\t\tdst_type;\n\tbdaddr_t\tsrc;\n\t__u8\t\tsrc_type;\n\tbdaddr_t\tinit_addr;\n\t__u8\t\tinit_addr_type;\n\tbdaddr_t\tresp_addr;\n\t__u8\t\tresp_addr_type;\n\t__u8\t\tadv_instance;\n\t__u16\t\thandle;\n\t__u16\t\tsync_handle;\n\t__u16\t\tstate;\n\t__u8\t\tmode;\n\t__u8\t\ttype;\n\t__u8\t\trole;\n\tbool\t\tout;\n\t__u8\t\tattempt;\n\t__u8\t\tdev_class[3];\n\t__u8\t\tfeatures[HCI_MAX_PAGES][8];\n\t__u16\t\tpkt_type;\n\t__u16\t\tlink_policy;\n\t__u8\t\tkey_type;\n\t__u8\t\tauth_type;\n\t__u8\t\tsec_level;\n\t__u8\t\tpending_sec_level;\n\t__u8\t\tpin_length;\n\t__u8\t\tenc_key_size;\n\t__u8\t\tio_capability;\n\t__u32\t\tpasskey_notify;\n\t__u8\t\tpasskey_entered;\n\t__u16\t\tdisc_timeout;\n\t__u16\t\tconn_timeout;\n\t__u16\t\tsetting;\n\t__u16\t\tauth_payload_timeout;\n\t__u16\t\tle_conn_min_interval;\n\t__u16\t\tle_conn_max_interval;\n\t__u16\t\tle_conn_interval;\n\t__u16\t\tle_conn_latency;\n\t__u16\t\tle_supv_timeout;\n\t__u8\t\tle_adv_data[HCI_MAX_EXT_AD_LENGTH];\n\t__u8\t\tle_adv_data_len;\n\t__u8\t\tle_per_adv_data[HCI_MAX_PER_AD_LENGTH];\n\t__u8\t\tle_per_adv_data_len;\n\t__u8\t\tle_tx_phy;\n\t__u8\t\tle_rx_phy;\n\t__s8\t\trssi;\n\t__s8\t\ttx_power;\n\t__s8\t\tmax_tx_power;\n\tstruct bt_iso_qos iso_qos;\n\tunsigned long\tflags;\n\n\tenum conn_reasons conn_reason;\n\t__u8\t\tabort_reason;\n\n\t__u32\t\tclock;\n\t__u16\t\tclock_accuracy;\n\n\tunsigned long\tconn_info_timestamp;\n\n\t__u8\t\tremote_cap;\n\t__u8\t\tremote_auth;\n\t__u8\t\tremote_id;\n\n\tunsigned int\tsent;\n\n\tstruct sk_buff_head data_q;\n\tstruct list_head chan_list;\n\n\tstruct delayed_work disc_work;\n\tstruct delayed_work auto_accept_work;\n\tstruct delayed_work idle_work;\n\tstruct delayed_work le_conn_timeout;\n\n\tstruct device\tdev;\n\tstruct dentry\t*debugfs;\n\n\tstruct hci_dev\t*hdev;\n\tvoid\t\t*l2cap_data;\n\tvoid\t\t*sco_data;\n\tvoid\t\t*iso_data;\n\tstruct amp_mgr\t*amp_mgr;\n\n\tstruct list_head link_list;\n\tstruct hci_conn\t*parent;\n\tstruct hci_link *link;\n\n\tstruct bt_codec codec;\n\n\tvoid (*connect_cfm_cb)\t(struct hci_conn *conn, u8 status);\n\tvoid (*security_cfm_cb)\t(struct hci_conn *conn, u8 status);\n\tvoid (*disconn_cfm_cb)\t(struct hci_conn *conn, u8 reason);\n\n\tvoid (*cleanup)(struct hci_conn *conn);\n};\n\nstruct hci_link {\n\tstruct list_head list;\n\tstruct hci_conn *conn;\n};\n\nstruct hci_chan {\n\tstruct list_head list;\n\t__u16 handle;\n\tstruct hci_conn *conn;\n\tstruct sk_buff_head data_q;\n\tunsigned int\tsent;\n\t__u8\t\tstate;\n\tbool\t\tamp;\n};\n\nstruct hci_conn_params {\n\tstruct list_head list;\n\tstruct list_head action;\n\n\tbdaddr_t addr;\n\tu8 addr_type;\n\n\tu16 conn_min_interval;\n\tu16 conn_max_interval;\n\tu16 conn_latency;\n\tu16 supervision_timeout;\n\n\tenum {\n\t\tHCI_AUTO_CONN_DISABLED,\n\t\tHCI_AUTO_CONN_REPORT,\n\t\tHCI_AUTO_CONN_DIRECT,\n\t\tHCI_AUTO_CONN_ALWAYS,\n\t\tHCI_AUTO_CONN_LINK_LOSS,\n\t\tHCI_AUTO_CONN_EXPLICIT,\n\t} auto_connect;\n\n\tstruct hci_conn *conn;\n\tbool explicit_connect;\n\t \n\thci_conn_flags_t flags;\n\tu8  privacy_mode;\n};\n\nextern struct list_head hci_dev_list;\nextern struct list_head hci_cb_list;\nextern rwlock_t hci_dev_list_lock;\nextern struct mutex hci_cb_list_lock;\n\n#define hci_dev_set_flag(hdev, nr)             set_bit((nr), (hdev)->dev_flags)\n#define hci_dev_clear_flag(hdev, nr)           clear_bit((nr), (hdev)->dev_flags)\n#define hci_dev_change_flag(hdev, nr)          change_bit((nr), (hdev)->dev_flags)\n#define hci_dev_test_flag(hdev, nr)            test_bit((nr), (hdev)->dev_flags)\n#define hci_dev_test_and_set_flag(hdev, nr)    test_and_set_bit((nr), (hdev)->dev_flags)\n#define hci_dev_test_and_clear_flag(hdev, nr)  test_and_clear_bit((nr), (hdev)->dev_flags)\n#define hci_dev_test_and_change_flag(hdev, nr) test_and_change_bit((nr), (hdev)->dev_flags)\n\n#define hci_dev_clear_volatile_flags(hdev)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\thci_dev_clear_flag(hdev, HCI_LE_SCAN);\t\t\\\n\t\thci_dev_clear_flag(hdev, HCI_LE_ADV);\t\t\\\n\t\thci_dev_clear_flag(hdev, HCI_LL_RPA_RESOLUTION);\\\n\t\thci_dev_clear_flag(hdev, HCI_PERIODIC_INQ);\t\\\n\t\thci_dev_clear_flag(hdev, HCI_QUALITY_REPORT);\t\\\n\t} while (0)\n\n#define hci_dev_le_state_simultaneous(hdev) \\\n\t(test_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks) && \\\n\t (hdev->le_states[4] & 0x08) &&\t  \\\n\t (hdev->le_states[4] & 0x40) &&\t  \\\n\t (hdev->le_states[3] & 0x10))\t \n\n \nint l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);\nint l2cap_disconn_ind(struct hci_conn *hcon);\nvoid l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);\n\n#if IS_ENABLED(CONFIG_BT_BREDR)\nint sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags);\nvoid sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);\n#else\nstatic inline int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t  __u8 *flags)\n{\n\treturn 0;\n}\n\nstatic inline void sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\n{\n}\n#endif\n\n#if IS_ENABLED(CONFIG_BT_LE)\nint iso_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags);\nvoid iso_recv(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);\n#else\nstatic inline int iso_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t  __u8 *flags)\n{\n\treturn 0;\n}\nstatic inline void iso_recv(struct hci_conn *hcon, struct sk_buff *skb,\n\t\t\t    u16 flags)\n{\n}\n#endif\n\n \n#define INQUIRY_CACHE_AGE_MAX   (HZ*30)    \n#define INQUIRY_ENTRY_AGE_MAX   (HZ*60)    \n\nstatic inline void discovery_init(struct hci_dev *hdev)\n{\n\thdev->discovery.state = DISCOVERY_STOPPED;\n\tINIT_LIST_HEAD(&hdev->discovery.all);\n\tINIT_LIST_HEAD(&hdev->discovery.unknown);\n\tINIT_LIST_HEAD(&hdev->discovery.resolve);\n\thdev->discovery.report_invalid_rssi = true;\n\thdev->discovery.rssi = HCI_RSSI_INVALID;\n}\n\nstatic inline void hci_discovery_filter_clear(struct hci_dev *hdev)\n{\n\thdev->discovery.result_filtering = false;\n\thdev->discovery.report_invalid_rssi = true;\n\thdev->discovery.rssi = HCI_RSSI_INVALID;\n\thdev->discovery.uuid_count = 0;\n\tkfree(hdev->discovery.uuids);\n\thdev->discovery.uuids = NULL;\n\thdev->discovery.scan_start = 0;\n\thdev->discovery.scan_duration = 0;\n}\n\nbool hci_discovery_active(struct hci_dev *hdev);\n\nvoid hci_discovery_set_state(struct hci_dev *hdev, int state);\n\nstatic inline int inquiry_cache_empty(struct hci_dev *hdev)\n{\n\treturn list_empty(&hdev->discovery.all);\n}\n\nstatic inline long inquiry_cache_age(struct hci_dev *hdev)\n{\n\tstruct discovery_state *c = &hdev->discovery;\n\treturn jiffies - c->timestamp;\n}\n\nstatic inline long inquiry_entry_age(struct inquiry_entry *e)\n{\n\treturn jiffies - e->timestamp;\n}\n\nstruct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,\n\t\t\t\t\t       bdaddr_t *bdaddr);\nstruct inquiry_entry *hci_inquiry_cache_lookup_unknown(struct hci_dev *hdev,\n\t\t\t\t\t\t       bdaddr_t *bdaddr);\nstruct inquiry_entry *hci_inquiry_cache_lookup_resolve(struct hci_dev *hdev,\n\t\t\t\t\t\t       bdaddr_t *bdaddr,\n\t\t\t\t\t\t       int state);\nvoid hci_inquiry_cache_update_resolve(struct hci_dev *hdev,\n\t\t\t\t      struct inquiry_entry *ie);\nu32 hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,\n\t\t\t     bool name_known);\nvoid hci_inquiry_cache_flush(struct hci_dev *hdev);\n\n \nenum {\n\tHCI_CONN_AUTH_PEND,\n\tHCI_CONN_ENCRYPT_PEND,\n\tHCI_CONN_RSWITCH_PEND,\n\tHCI_CONN_MODE_CHANGE_PEND,\n\tHCI_CONN_SCO_SETUP_PEND,\n\tHCI_CONN_MGMT_CONNECTED,\n\tHCI_CONN_SSP_ENABLED,\n\tHCI_CONN_SC_ENABLED,\n\tHCI_CONN_AES_CCM,\n\tHCI_CONN_POWER_SAVE,\n\tHCI_CONN_FLUSH_KEY,\n\tHCI_CONN_ENCRYPT,\n\tHCI_CONN_AUTH,\n\tHCI_CONN_SECURE,\n\tHCI_CONN_FIPS,\n\tHCI_CONN_STK_ENCRYPT,\n\tHCI_CONN_AUTH_INITIATOR,\n\tHCI_CONN_DROP,\n\tHCI_CONN_CANCEL,\n\tHCI_CONN_PARAM_REMOVAL_PEND,\n\tHCI_CONN_NEW_LINK_KEY,\n\tHCI_CONN_SCANNING,\n\tHCI_CONN_AUTH_FAILURE,\n\tHCI_CONN_PER_ADV,\n\tHCI_CONN_BIG_CREATED,\n\tHCI_CONN_CREATE_CIS,\n\tHCI_CONN_BIG_SYNC,\n\tHCI_CONN_BIG_SYNC_FAILED,\n\tHCI_CONN_PA_SYNC,\n\tHCI_CONN_PA_SYNC_FAILED,\n};\n\nstatic inline bool hci_conn_ssp_enabled(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\treturn hci_dev_test_flag(hdev, HCI_SSP_ENABLED) &&\n\t       test_bit(HCI_CONN_SSP_ENABLED, &conn->flags);\n}\n\nstatic inline bool hci_conn_sc_enabled(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\treturn hci_dev_test_flag(hdev, HCI_SC_ENABLED) &&\n\t       test_bit(HCI_CONN_SC_ENABLED, &conn->flags);\n}\n\nstatic inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tlist_add_tail_rcu(&c->list, &h->list);\n\tswitch (c->type) {\n\tcase ACL_LINK:\n\t\th->acl_num++;\n\t\tbreak;\n\tcase AMP_LINK:\n\t\th->amp_num++;\n\t\tbreak;\n\tcase LE_LINK:\n\t\th->le_num++;\n\t\tif (c->role == HCI_ROLE_SLAVE)\n\t\t\th->le_num_peripheral++;\n\t\tbreak;\n\tcase SCO_LINK:\n\tcase ESCO_LINK:\n\t\th->sco_num++;\n\t\tbreak;\n\tcase ISO_LINK:\n\t\th->iso_num++;\n\t\tbreak;\n\t}\n}\n\nstatic inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\n\tlist_del_rcu(&c->list);\n\tsynchronize_rcu();\n\n\tswitch (c->type) {\n\tcase ACL_LINK:\n\t\th->acl_num--;\n\t\tbreak;\n\tcase AMP_LINK:\n\t\th->amp_num--;\n\t\tbreak;\n\tcase LE_LINK:\n\t\th->le_num--;\n\t\tif (c->role == HCI_ROLE_SLAVE)\n\t\t\th->le_num_peripheral--;\n\t\tbreak;\n\tcase SCO_LINK:\n\tcase ESCO_LINK:\n\t\th->sco_num--;\n\t\tbreak;\n\tcase ISO_LINK:\n\t\th->iso_num--;\n\t\tbreak;\n\t}\n}\n\nstatic inline unsigned int hci_conn_num(struct hci_dev *hdev, __u8 type)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tswitch (type) {\n\tcase ACL_LINK:\n\t\treturn h->acl_num;\n\tcase AMP_LINK:\n\t\treturn h->amp_num;\n\tcase LE_LINK:\n\t\treturn h->le_num;\n\tcase SCO_LINK:\n\tcase ESCO_LINK:\n\t\treturn h->sco_num;\n\tcase ISO_LINK:\n\t\treturn h->iso_num;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline unsigned int hci_conn_count(struct hci_dev *hdev)\n{\n\tstruct hci_conn_hash *c = &hdev->conn_hash;\n\n\treturn c->acl_num + c->amp_num + c->sco_num + c->le_num + c->iso_num;\n}\n\nstatic inline __u8 hci_conn_lookup_type(struct hci_dev *hdev, __u16 handle)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn *c;\n\t__u8 type = INVALID_LINK;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->handle == handle) {\n\t\t\ttype = c->type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn type;\n}\n\nstatic inline struct hci_conn *hci_conn_hash_lookup_bis(struct hci_dev *hdev,\n\t\t\t\t\t\t\tbdaddr_t *ba, __u8 bis)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (bacmp(&c->dst, ba) || c->type != ISO_LINK)\n\t\t\tcontinue;\n\n\t\tif (c->iso_qos.bcast.bis == bis) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic inline struct hci_conn *\nhci_conn_hash_lookup_per_adv_bis(struct hci_dev *hdev,\n\t\t\t\t bdaddr_t *ba,\n\t\t\t\t __u8 big, __u8 bis)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (bacmp(&c->dst, ba) || c->type != ISO_LINK ||\n\t\t\t!test_bit(HCI_CONN_PER_ADV, &c->flags))\n\t\t\tcontinue;\n\n\t\tif (c->iso_qos.bcast.big == big &&\n\t\t    c->iso_qos.bcast.bis == bis) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,\n\t\t\t\t\t\t\t\t__u16 handle)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->handle == handle) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic inline struct hci_conn *hci_conn_hash_lookup_ba(struct hci_dev *hdev,\n\t\t\t\t\t\t\t__u8 type, bdaddr_t *ba)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->type == type && !bacmp(&c->dst, ba)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic inline struct hci_conn *hci_conn_hash_lookup_le(struct hci_dev *hdev,\n\t\t\t\t\t\t       bdaddr_t *ba,\n\t\t\t\t\t\t       __u8 ba_type)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->type != LE_LINK)\n\t\t       continue;\n\n\t\tif (ba_type == c->dst_type && !bacmp(&c->dst, ba)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic inline struct hci_conn *hci_conn_hash_lookup_cis(struct hci_dev *hdev,\n\t\t\t\t\t\t\tbdaddr_t *ba,\n\t\t\t\t\t\t\t__u8 ba_type,\n\t\t\t\t\t\t\t__u8 cig,\n\t\t\t\t\t\t\t__u8 id)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->type != ISO_LINK || !bacmp(&c->dst, BDADDR_ANY))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (cig != c->iso_qos.ucast.cig)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (id != c->iso_qos.ucast.cis)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!ba || (ba_type == c->dst_type && !bacmp(&c->dst, ba))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic inline struct hci_conn *hci_conn_hash_lookup_cig(struct hci_dev *hdev,\n\t\t\t\t\t\t\t__u8 handle)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->type != ISO_LINK || !bacmp(&c->dst, BDADDR_ANY))\n\t\t\tcontinue;\n\n\t\tif (handle == c->iso_qos.ucast.cig) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic inline struct hci_conn *hci_conn_hash_lookup_big(struct hci_dev *hdev,\n\t\t\t\t\t\t\t__u8 handle)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (bacmp(&c->dst, BDADDR_ANY) || c->type != ISO_LINK)\n\t\t\tcontinue;\n\n\t\tif (handle == c->iso_qos.bcast.big) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic inline struct hci_conn *hci_conn_hash_lookup_big_any_dst(struct hci_dev *hdev,\n\t\t\t\t\t\t\t__u8 handle)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->type != ISO_LINK)\n\t\t\tcontinue;\n\n\t\tif (handle != BT_ISO_QOS_BIG_UNSET && handle == c->iso_qos.bcast.big) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic inline struct hci_conn *\nhci_conn_hash_lookup_pa_sync_big_handle(struct hci_dev *hdev, __u8 big)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->type != ISO_LINK ||\n\t\t\t!test_bit(HCI_CONN_PA_SYNC, &c->flags))\n\t\t\tcontinue;\n\n\t\tif (c->iso_qos.bcast.big == big) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic inline struct hci_conn *\nhci_conn_hash_lookup_pa_sync_handle(struct hci_dev *hdev, __u16 sync_handle)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->type != ISO_LINK ||\n\t\t\t!test_bit(HCI_CONN_PA_SYNC, &c->flags))\n\t\t\tcontinue;\n\n\t\tif (c->sync_handle == sync_handle) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,\n\t\t\t\t\t\t\t__u8 type, __u16 state)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->type == type && c->state == state) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\ntypedef void (*hci_conn_func_t)(struct hci_conn *conn, void *data);\nstatic inline void hci_conn_hash_list_state(struct hci_dev *hdev,\n\t\t\t\t\t    hci_conn_func_t func, __u8 type,\n\t\t\t\t\t    __u16 state, void *data)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\tif (!func)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->type == type && c->state == state)\n\t\t\tfunc(c, data);\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic inline struct hci_conn *hci_lookup_le_connect(struct hci_dev *hdev)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->type == LE_LINK && c->state == BT_CONNECT &&\n\t\t    !test_bit(HCI_CONN_SCANNING, &c->flags)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn c;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\n \nstatic inline bool hci_is_le_conn_scanning(struct hci_dev *hdev)\n{\n\tstruct hci_conn_hash *h = &hdev->conn_hash;\n\tstruct hci_conn  *c;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(c, &h->list, list) {\n\t\tif (c->type == LE_LINK && c->state == BT_CONNECT &&\n\t\t    test_bit(HCI_CONN_SCANNING, &c->flags)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn false;\n}\n\nint hci_disconnect(struct hci_conn *conn, __u8 reason);\nbool hci_setup_sync(struct hci_conn *conn, __u16 handle);\nvoid hci_sco_setup(struct hci_conn *conn, __u8 status);\nbool hci_iso_setup_path(struct hci_conn *conn);\nint hci_le_create_cis_pending(struct hci_dev *hdev);\nint hci_conn_check_create_cis(struct hci_conn *conn);\n\nstruct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,\n\t\t\t      u8 role, u16 handle);\nstruct hci_conn *hci_conn_add_unset(struct hci_dev *hdev, int type,\n\t\t\t\t    bdaddr_t *dst, u8 role);\nvoid hci_conn_del(struct hci_conn *conn);\nvoid hci_conn_hash_flush(struct hci_dev *hdev);\nvoid hci_conn_check_pending(struct hci_dev *hdev);\n\nstruct hci_chan *hci_chan_create(struct hci_conn *conn);\nvoid hci_chan_del(struct hci_chan *chan);\nvoid hci_chan_list_flush(struct hci_conn *conn);\nstruct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);\n\nstruct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t\t     u8 dst_type, u8 sec_level,\n\t\t\t\t     u16 conn_timeout,\n\t\t\t\t     enum conn_reasons conn_reason);\nstruct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t\tu8 dst_type, bool dst_resolved, u8 sec_level,\n\t\t\t\tu16 conn_timeout, u8 role);\nstruct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t\t u8 sec_level, u8 auth_type,\n\t\t\t\t enum conn_reasons conn_reason);\nstruct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,\n\t\t\t\t __u16 setting, struct bt_codec *codec);\nstruct hci_conn *hci_bind_cis(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t      __u8 dst_type, struct bt_iso_qos *qos);\nstruct hci_conn *hci_bind_bis(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t      struct bt_iso_qos *qos,\n\t\t\t      __u8 base_len, __u8 *base);\nstruct hci_conn *hci_connect_cis(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t\t __u8 dst_type, struct bt_iso_qos *qos);\nstruct hci_conn *hci_connect_bis(struct hci_dev *hdev, bdaddr_t *dst,\n\t\t\t\t __u8 dst_type, struct bt_iso_qos *qos,\n\t\t\t\t __u8 data_len, __u8 *data);\nint hci_pa_create_sync(struct hci_dev *hdev, bdaddr_t *dst, __u8 dst_type,\n\t\t       __u8 sid, struct bt_iso_qos *qos);\nint hci_le_big_create_sync(struct hci_dev *hdev, struct hci_conn *hcon,\n\t\t\t   struct bt_iso_qos *qos,\n\t\t\t   __u16 sync_handle, __u8 num_bis, __u8 bis[]);\nint hci_conn_check_link_mode(struct hci_conn *conn);\nint hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);\nint hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type,\n\t\t      bool initiator);\nint hci_conn_switch_role(struct hci_conn *conn, __u8 role);\n\nvoid hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);\n\nvoid hci_conn_failed(struct hci_conn *conn, u8 status);\nu8 hci_conn_set_handle(struct hci_conn *conn, u16 handle);\n\n \n\nstatic inline struct hci_conn *hci_conn_get(struct hci_conn *conn)\n{\n\tget_device(&conn->dev);\n\treturn conn;\n}\n\nstatic inline void hci_conn_put(struct hci_conn *conn)\n{\n\tput_device(&conn->dev);\n}\n\nstatic inline struct hci_conn *hci_conn_hold(struct hci_conn *conn)\n{\n\tBT_DBG(\"hcon %p orig refcnt %d\", conn, atomic_read(&conn->refcnt));\n\n\tatomic_inc(&conn->refcnt);\n\tcancel_delayed_work(&conn->disc_work);\n\n\treturn conn;\n}\n\nstatic inline void hci_conn_drop(struct hci_conn *conn)\n{\n\tBT_DBG(\"hcon %p orig refcnt %d\", conn, atomic_read(&conn->refcnt));\n\n\tif (atomic_dec_and_test(&conn->refcnt)) {\n\t\tunsigned long timeo;\n\n\t\tswitch (conn->type) {\n\t\tcase ACL_LINK:\n\t\tcase LE_LINK:\n\t\t\tcancel_delayed_work(&conn->idle_work);\n\t\t\tif (conn->state == BT_CONNECTED) {\n\t\t\t\ttimeo = conn->disc_timeout;\n\t\t\t\tif (!conn->out)\n\t\t\t\t\ttimeo *= 2;\n\t\t\t} else {\n\t\t\t\ttimeo = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AMP_LINK:\n\t\t\ttimeo = conn->disc_timeout;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ttimeo = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcancel_delayed_work(&conn->disc_work);\n\t\tqueue_delayed_work(conn->hdev->workqueue,\n\t\t\t\t   &conn->disc_work, timeo);\n\t}\n}\n\n \nstatic inline void hci_dev_put(struct hci_dev *d)\n{\n\tBT_DBG(\"%s orig refcnt %d\", d->name,\n\t       kref_read(&d->dev.kobj.kref));\n\n\tput_device(&d->dev);\n}\n\nstatic inline struct hci_dev *hci_dev_hold(struct hci_dev *d)\n{\n\tBT_DBG(\"%s orig refcnt %d\", d->name,\n\t       kref_read(&d->dev.kobj.kref));\n\n\tget_device(&d->dev);\n\treturn d;\n}\n\n#define hci_dev_lock(d)\t\tmutex_lock(&d->lock)\n#define hci_dev_unlock(d)\tmutex_unlock(&d->lock)\n\n#define to_hci_dev(d) container_of(d, struct hci_dev, dev)\n#define to_hci_conn(c) container_of(c, struct hci_conn, dev)\n\nstatic inline void *hci_get_drvdata(struct hci_dev *hdev)\n{\n\treturn dev_get_drvdata(&hdev->dev);\n}\n\nstatic inline void hci_set_drvdata(struct hci_dev *hdev, void *data)\n{\n\tdev_set_drvdata(&hdev->dev, data);\n}\n\nstatic inline void *hci_get_priv(struct hci_dev *hdev)\n{\n\treturn (char *)hdev + sizeof(*hdev);\n}\n\nstruct hci_dev *hci_dev_get(int index);\nstruct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src, u8 src_type);\n\nstruct hci_dev *hci_alloc_dev_priv(int sizeof_priv);\n\nstatic inline struct hci_dev *hci_alloc_dev(void)\n{\n\treturn hci_alloc_dev_priv(0);\n}\n\nvoid hci_free_dev(struct hci_dev *hdev);\nint hci_register_dev(struct hci_dev *hdev);\nvoid hci_unregister_dev(struct hci_dev *hdev);\nvoid hci_release_dev(struct hci_dev *hdev);\nint hci_register_suspend_notifier(struct hci_dev *hdev);\nint hci_unregister_suspend_notifier(struct hci_dev *hdev);\nint hci_suspend_dev(struct hci_dev *hdev);\nint hci_resume_dev(struct hci_dev *hdev);\nint hci_reset_dev(struct hci_dev *hdev);\nint hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);\nint hci_recv_diag(struct hci_dev *hdev, struct sk_buff *skb);\n__printf(2, 3) void hci_set_hw_info(struct hci_dev *hdev, const char *fmt, ...);\n__printf(2, 3) void hci_set_fw_info(struct hci_dev *hdev, const char *fmt, ...);\n\nstatic inline void hci_set_msft_opcode(struct hci_dev *hdev, __u16 opcode)\n{\n#if IS_ENABLED(CONFIG_BT_MSFTEXT)\n\thdev->msft_opcode = opcode;\n#endif\n}\n\nstatic inline void hci_set_aosp_capable(struct hci_dev *hdev)\n{\n#if IS_ENABLED(CONFIG_BT_AOSPEXT)\n\thdev->aosp_capable = true;\n#endif\n}\n\nstatic inline void hci_devcd_setup(struct hci_dev *hdev)\n{\n#ifdef CONFIG_DEV_COREDUMP\n\tINIT_WORK(&hdev->dump.dump_rx, hci_devcd_rx);\n\tINIT_DELAYED_WORK(&hdev->dump.dump_timeout, hci_devcd_timeout);\n\tskb_queue_head_init(&hdev->dump.dump_q);\n#endif\n}\n\nint hci_dev_open(__u16 dev);\nint hci_dev_close(__u16 dev);\nint hci_dev_do_close(struct hci_dev *hdev);\nint hci_dev_reset(__u16 dev);\nint hci_dev_reset_stat(__u16 dev);\nint hci_dev_cmd(unsigned int cmd, void __user *arg);\nint hci_get_dev_list(void __user *arg);\nint hci_get_dev_info(void __user *arg);\nint hci_get_conn_list(void __user *arg);\nint hci_get_conn_info(struct hci_dev *hdev, void __user *arg);\nint hci_get_auth_info(struct hci_dev *hdev, void __user *arg);\nint hci_inquiry(void __user *arg);\n\nstruct bdaddr_list *hci_bdaddr_list_lookup(struct list_head *list,\n\t\t\t\t\t   bdaddr_t *bdaddr, u8 type);\nstruct bdaddr_list_with_irk *hci_bdaddr_list_lookup_with_irk(\n\t\t\t\t    struct list_head *list, bdaddr_t *bdaddr,\n\t\t\t\t    u8 type);\nstruct bdaddr_list_with_flags *\nhci_bdaddr_list_lookup_with_flags(struct list_head *list, bdaddr_t *bdaddr,\n\t\t\t\t  u8 type);\nint hci_bdaddr_list_add(struct list_head *list, bdaddr_t *bdaddr, u8 type);\nint hci_bdaddr_list_add_with_irk(struct list_head *list, bdaddr_t *bdaddr,\n\t\t\t\t u8 type, u8 *peer_irk, u8 *local_irk);\nint hci_bdaddr_list_add_with_flags(struct list_head *list, bdaddr_t *bdaddr,\n\t\t\t\t   u8 type, u32 flags);\nint hci_bdaddr_list_del(struct list_head *list, bdaddr_t *bdaddr, u8 type);\nint hci_bdaddr_list_del_with_irk(struct list_head *list, bdaddr_t *bdaddr,\n\t\t\t\t u8 type);\nint hci_bdaddr_list_del_with_flags(struct list_head *list, bdaddr_t *bdaddr,\n\t\t\t\t   u8 type);\nvoid hci_bdaddr_list_clear(struct list_head *list);\n\nstruct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,\n\t\t\t\t\t       bdaddr_t *addr, u8 addr_type);\nstruct hci_conn_params *hci_conn_params_add(struct hci_dev *hdev,\n\t\t\t\t\t    bdaddr_t *addr, u8 addr_type);\nvoid hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);\nvoid hci_conn_params_clear_disabled(struct hci_dev *hdev);\nvoid hci_conn_params_free(struct hci_conn_params *param);\n\nvoid hci_pend_le_list_del_init(struct hci_conn_params *param);\nvoid hci_pend_le_list_add(struct hci_conn_params *param,\n\t\t\t  struct list_head *list);\nstruct hci_conn_params *hci_pend_le_action_lookup(struct list_head *list,\n\t\t\t\t\t\t  bdaddr_t *addr,\n\t\t\t\t\t\t  u8 addr_type);\n\nvoid hci_uuids_clear(struct hci_dev *hdev);\n\nvoid hci_link_keys_clear(struct hci_dev *hdev);\nstruct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);\nstruct link_key *hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn,\n\t\t\t\t  bdaddr_t *bdaddr, u8 *val, u8 type,\n\t\t\t\t  u8 pin_len, bool *persistent);\nstruct smp_ltk *hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t    u8 addr_type, u8 type, u8 authenticated,\n\t\t\t    u8 tk[16], u8 enc_size, __le16 ediv, __le64 rand);\nstruct smp_ltk *hci_find_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t     u8 addr_type, u8 role);\nint hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 bdaddr_type);\nvoid hci_smp_ltks_clear(struct hci_dev *hdev);\nint hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);\n\nstruct smp_irk *hci_find_irk_by_rpa(struct hci_dev *hdev, bdaddr_t *rpa);\nstruct smp_irk *hci_find_irk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t     u8 addr_type);\nstruct smp_irk *hci_add_irk(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t    u8 addr_type, u8 val[16], bdaddr_t *rpa);\nvoid hci_remove_irk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type);\nbool hci_is_blocked_key(struct hci_dev *hdev, u8 type, u8 val[16]);\nvoid hci_blocked_keys_clear(struct hci_dev *hdev);\nvoid hci_smp_irks_clear(struct hci_dev *hdev);\n\nbool hci_bdaddr_is_paired(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);\n\nvoid hci_remote_oob_data_clear(struct hci_dev *hdev);\nstruct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,\n\t\t\t\t\t  bdaddr_t *bdaddr, u8 bdaddr_type);\nint hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t    u8 bdaddr_type, u8 *hash192, u8 *rand192,\n\t\t\t    u8 *hash256, u8 *rand256);\nint hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t       u8 bdaddr_type);\n\nvoid hci_adv_instances_clear(struct hci_dev *hdev);\nstruct adv_info *hci_find_adv_instance(struct hci_dev *hdev, u8 instance);\nstruct adv_info *hci_get_next_instance(struct hci_dev *hdev, u8 instance);\nstruct adv_info *hci_add_adv_instance(struct hci_dev *hdev, u8 instance,\n\t\t\t\t      u32 flags, u16 adv_data_len, u8 *adv_data,\n\t\t\t\t      u16 scan_rsp_len, u8 *scan_rsp_data,\n\t\t\t\t      u16 timeout, u16 duration, s8 tx_power,\n\t\t\t\t      u32 min_interval, u32 max_interval,\n\t\t\t\t      u8 mesh_handle);\nstruct adv_info *hci_add_per_instance(struct hci_dev *hdev, u8 instance,\n\t\t\t\t      u32 flags, u8 data_len, u8 *data,\n\t\t\t\t      u32 min_interval, u32 max_interval);\nint hci_set_adv_instance_data(struct hci_dev *hdev, u8 instance,\n\t\t\t u16 adv_data_len, u8 *adv_data,\n\t\t\t u16 scan_rsp_len, u8 *scan_rsp_data);\nint hci_remove_adv_instance(struct hci_dev *hdev, u8 instance);\nvoid hci_adv_instances_set_rpa_expired(struct hci_dev *hdev, bool rpa_expired);\nu32 hci_adv_instance_flags(struct hci_dev *hdev, u8 instance);\nbool hci_adv_instance_is_scannable(struct hci_dev *hdev, u8 instance);\n\nvoid hci_adv_monitors_clear(struct hci_dev *hdev);\nvoid hci_free_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor);\nint hci_add_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor);\nint hci_remove_single_adv_monitor(struct hci_dev *hdev, u16 handle);\nint hci_remove_all_adv_monitor(struct hci_dev *hdev);\nbool hci_is_adv_monitoring(struct hci_dev *hdev);\nint hci_get_adv_monitor_offload_ext(struct hci_dev *hdev);\n\nvoid hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);\n\nvoid hci_init_sysfs(struct hci_dev *hdev);\nvoid hci_conn_init_sysfs(struct hci_conn *conn);\nvoid hci_conn_add_sysfs(struct hci_conn *conn);\nvoid hci_conn_del_sysfs(struct hci_conn *conn);\n\n#define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->dev.parent = (pdev))\n#define GET_HCIDEV_DEV(hdev) ((hdev)->dev.parent)\n\n \n#define lmp_encrypt_capable(dev)   ((dev)->features[0][0] & LMP_ENCRYPT)\n#define lmp_rswitch_capable(dev)   ((dev)->features[0][0] & LMP_RSWITCH)\n#define lmp_hold_capable(dev)      ((dev)->features[0][0] & LMP_HOLD)\n#define lmp_sniff_capable(dev)     ((dev)->features[0][0] & LMP_SNIFF)\n#define lmp_park_capable(dev)      ((dev)->features[0][1] & LMP_PARK)\n#define lmp_inq_rssi_capable(dev)  ((dev)->features[0][3] & LMP_RSSI_INQ)\n#define lmp_esco_capable(dev)      ((dev)->features[0][3] & LMP_ESCO)\n#define lmp_bredr_capable(dev)     (!((dev)->features[0][4] & LMP_NO_BREDR))\n#define lmp_le_capable(dev)        ((dev)->features[0][4] & LMP_LE)\n#define lmp_sniffsubr_capable(dev) ((dev)->features[0][5] & LMP_SNIFF_SUBR)\n#define lmp_pause_enc_capable(dev) ((dev)->features[0][5] & LMP_PAUSE_ENC)\n#define lmp_esco_2m_capable(dev)   ((dev)->features[0][5] & LMP_EDR_ESCO_2M)\n#define lmp_ext_inq_capable(dev)   ((dev)->features[0][6] & LMP_EXT_INQ)\n#define lmp_le_br_capable(dev)     (!!((dev)->features[0][6] & LMP_SIMUL_LE_BR))\n#define lmp_ssp_capable(dev)       ((dev)->features[0][6] & LMP_SIMPLE_PAIR)\n#define lmp_no_flush_capable(dev)  ((dev)->features[0][6] & LMP_NO_FLUSH)\n#define lmp_lsto_capable(dev)      ((dev)->features[0][7] & LMP_LSTO)\n#define lmp_inq_tx_pwr_capable(dev) ((dev)->features[0][7] & LMP_INQ_TX_PWR)\n#define lmp_ext_feat_capable(dev)  ((dev)->features[0][7] & LMP_EXTFEATURES)\n#define lmp_transp_capable(dev)    ((dev)->features[0][2] & LMP_TRANSPARENT)\n#define lmp_edr_2m_capable(dev)    ((dev)->features[0][3] & LMP_EDR_2M)\n#define lmp_edr_3m_capable(dev)    ((dev)->features[0][3] & LMP_EDR_3M)\n#define lmp_edr_3slot_capable(dev) ((dev)->features[0][4] & LMP_EDR_3SLOT)\n#define lmp_edr_5slot_capable(dev) ((dev)->features[0][5] & LMP_EDR_5SLOT)\n\n \n#define lmp_cpb_central_capable(dev) ((dev)->features[2][0] & LMP_CPB_CENTRAL)\n#define lmp_cpb_peripheral_capable(dev) ((dev)->features[2][0] & LMP_CPB_PERIPHERAL)\n#define lmp_sync_train_capable(dev) ((dev)->features[2][0] & LMP_SYNC_TRAIN)\n#define lmp_sync_scan_capable(dev)  ((dev)->features[2][0] & LMP_SYNC_SCAN)\n#define lmp_sc_capable(dev)         ((dev)->features[2][1] & LMP_SC)\n#define lmp_ping_capable(dev)       ((dev)->features[2][1] & LMP_PING)\n\n \n#define lmp_host_ssp_capable(dev)  ((dev)->features[1][0] & LMP_HOST_SSP)\n#define lmp_host_sc_capable(dev)   ((dev)->features[1][0] & LMP_HOST_SC)\n#define lmp_host_le_capable(dev)   (!!((dev)->features[1][0] & LMP_HOST_LE))\n#define lmp_host_le_br_capable(dev) (!!((dev)->features[1][0] & LMP_HOST_LE_BREDR))\n\n#define hdev_is_powered(dev)   (test_bit(HCI_UP, &(dev)->flags) && \\\n\t\t\t\t!hci_dev_test_flag(dev, HCI_AUTO_OFF))\n#define bredr_sc_enabled(dev)  (lmp_sc_capable(dev) && \\\n\t\t\t\thci_dev_test_flag(dev, HCI_SC_ENABLED))\n#define rpa_valid(dev)         (bacmp(&dev->rpa, BDADDR_ANY) && \\\n\t\t\t\t!hci_dev_test_flag(dev, HCI_RPA_EXPIRED))\n#define adv_rpa_valid(adv)     (bacmp(&adv->random_addr, BDADDR_ANY) && \\\n\t\t\t\t!adv->rpa_expired)\n\n#define scan_1m(dev) (((dev)->le_tx_def_phys & HCI_LE_SET_PHY_1M) || \\\n\t\t      ((dev)->le_rx_def_phys & HCI_LE_SET_PHY_1M))\n\n#define le_2m_capable(dev) (((dev)->le_features[1] & HCI_LE_PHY_2M))\n\n#define scan_2m(dev) (((dev)->le_tx_def_phys & HCI_LE_SET_PHY_2M) || \\\n\t\t      ((dev)->le_rx_def_phys & HCI_LE_SET_PHY_2M))\n\n#define le_coded_capable(dev) (((dev)->le_features[1] & HCI_LE_PHY_CODED) && \\\n\t\t\t       !test_bit(HCI_QUIRK_BROKEN_LE_CODED, \\\n\t\t\t\t\t &(dev)->quirks))\n\n#define scan_coded(dev) (((dev)->le_tx_def_phys & HCI_LE_SET_PHY_CODED) || \\\n\t\t\t ((dev)->le_rx_def_phys & HCI_LE_SET_PHY_CODED))\n\n#define ll_privacy_capable(dev) ((dev)->le_features[0] & HCI_LE_LL_PRIVACY)\n\n \n#define use_ll_privacy(dev) (ll_privacy_capable(dev) && \\\n\t\t\t     hci_dev_test_flag(dev, HCI_ENABLE_LL_PRIVACY))\n\n#define privacy_mode_capable(dev) (use_ll_privacy(dev) && \\\n\t\t\t\t   (hdev->commands[39] & 0x04))\n\n \n#define enhanced_sync_conn_capable(dev) \\\n\t(((dev)->commands[29] & 0x08) && \\\n\t !test_bit(HCI_QUIRK_BROKEN_ENHANCED_SETUP_SYNC_CONN, &(dev)->quirks))\n\n \n#define use_ext_scan(dev) (((dev)->commands[37] & 0x20) && \\\n\t\t\t   ((dev)->commands[37] & 0x40) && \\\n\t\t\t   !test_bit(HCI_QUIRK_BROKEN_EXT_SCAN, &(dev)->quirks))\n\n \n#define use_ext_conn(dev) ((dev)->commands[37] & 0x80)\n\n \n#define ext_adv_capable(dev) (((dev)->le_features[1] & HCI_LE_EXT_ADV))\n\n \n#define max_adv_len(dev) \\\n\t(ext_adv_capable(dev) ? HCI_MAX_EXT_AD_LENGTH : HCI_MAX_AD_LENGTH)\n\n \n#define use_enhanced_conn_complete(dev) (ll_privacy_capable(dev) || \\\n\t\t\t\t\t ext_adv_capable(dev))\n\n \n#define per_adv_capable(dev) (((dev)->le_features[1] & HCI_LE_PERIODIC_ADV))\n\n \n#define iso_capable(dev) (cis_capable(dev) || bis_capable(dev))\n#define cis_capable(dev) \\\n\t(cis_central_capable(dev) || cis_peripheral_capable(dev))\n#define cis_central_capable(dev) \\\n\t((dev)->le_features[3] & HCI_LE_CIS_CENTRAL)\n#define cis_peripheral_capable(dev) \\\n\t((dev)->le_features[3] & HCI_LE_CIS_PERIPHERAL)\n#define bis_capable(dev) ((dev)->le_features[3] & HCI_LE_ISO_BROADCASTER)\n#define sync_recv_capable(dev) ((dev)->le_features[3] & HCI_LE_ISO_SYNC_RECEIVER)\n\n#define mws_transport_config_capable(dev) (((dev)->commands[30] & 0x08) && \\\n\t(!test_bit(HCI_QUIRK_BROKEN_MWS_TRANSPORT_CONFIG, &(dev)->quirks)))\n\n \n#define HCI_PROTO_DEFER             0x01\n\nstatic inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t\t__u8 type, __u8 *flags)\n{\n\tswitch (type) {\n\tcase ACL_LINK:\n\t\treturn l2cap_connect_ind(hdev, bdaddr);\n\n\tcase SCO_LINK:\n\tcase ESCO_LINK:\n\t\treturn sco_connect_ind(hdev, bdaddr, flags);\n\n\tcase ISO_LINK:\n\t\treturn iso_connect_ind(hdev, bdaddr, flags);\n\n\tdefault:\n\t\tBT_ERR(\"unknown link type %d\", type);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline int hci_proto_disconn_ind(struct hci_conn *conn)\n{\n\tif (conn->type != ACL_LINK && conn->type != LE_LINK)\n\t\treturn HCI_ERROR_REMOTE_USER_TERM;\n\n\treturn l2cap_disconn_ind(conn);\n}\n\n \nstruct hci_cb {\n\tstruct list_head list;\n\n\tchar *name;\n\n\tvoid (*connect_cfm)\t(struct hci_conn *conn, __u8 status);\n\tvoid (*disconn_cfm)\t(struct hci_conn *conn, __u8 status);\n\tvoid (*security_cfm)\t(struct hci_conn *conn, __u8 status,\n\t\t\t\t\t\t\t\t__u8 encrypt);\n\tvoid (*key_change_cfm)\t(struct hci_conn *conn, __u8 status);\n\tvoid (*role_switch_cfm)\t(struct hci_conn *conn, __u8 status, __u8 role);\n};\n\nstatic inline void hci_connect_cfm(struct hci_conn *conn, __u8 status)\n{\n\tstruct hci_cb *cb;\n\n\tmutex_lock(&hci_cb_list_lock);\n\tlist_for_each_entry(cb, &hci_cb_list, list) {\n\t\tif (cb->connect_cfm)\n\t\t\tcb->connect_cfm(conn, status);\n\t}\n\tmutex_unlock(&hci_cb_list_lock);\n\n\tif (conn->connect_cfm_cb)\n\t\tconn->connect_cfm_cb(conn, status);\n}\n\nstatic inline void hci_disconn_cfm(struct hci_conn *conn, __u8 reason)\n{\n\tstruct hci_cb *cb;\n\n\tmutex_lock(&hci_cb_list_lock);\n\tlist_for_each_entry(cb, &hci_cb_list, list) {\n\t\tif (cb->disconn_cfm)\n\t\t\tcb->disconn_cfm(conn, reason);\n\t}\n\tmutex_unlock(&hci_cb_list_lock);\n\n\tif (conn->disconn_cfm_cb)\n\t\tconn->disconn_cfm_cb(conn, reason);\n}\n\nstatic inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)\n{\n\tstruct hci_cb *cb;\n\t__u8 encrypt;\n\n\tif (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))\n\t\treturn;\n\n\tencrypt = test_bit(HCI_CONN_ENCRYPT, &conn->flags) ? 0x01 : 0x00;\n\n\tmutex_lock(&hci_cb_list_lock);\n\tlist_for_each_entry(cb, &hci_cb_list, list) {\n\t\tif (cb->security_cfm)\n\t\t\tcb->security_cfm(conn, status, encrypt);\n\t}\n\tmutex_unlock(&hci_cb_list_lock);\n\n\tif (conn->security_cfm_cb)\n\t\tconn->security_cfm_cb(conn, status);\n}\n\nstatic inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status)\n{\n\tstruct hci_cb *cb;\n\t__u8 encrypt;\n\n\tif (conn->state == BT_CONFIG) {\n\t\tif (!status)\n\t\t\tconn->state = BT_CONNECTED;\n\n\t\thci_connect_cfm(conn, status);\n\t\thci_conn_drop(conn);\n\t\treturn;\n\t}\n\n\tif (!test_bit(HCI_CONN_ENCRYPT, &conn->flags))\n\t\tencrypt = 0x00;\n\telse if (test_bit(HCI_CONN_AES_CCM, &conn->flags))\n\t\tencrypt = 0x02;\n\telse\n\t\tencrypt = 0x01;\n\n\tif (!status) {\n\t\tif (conn->sec_level == BT_SECURITY_SDP)\n\t\t\tconn->sec_level = BT_SECURITY_LOW;\n\n\t\tif (conn->pending_sec_level > conn->sec_level)\n\t\t\tconn->sec_level = conn->pending_sec_level;\n\t}\n\n\tmutex_lock(&hci_cb_list_lock);\n\tlist_for_each_entry(cb, &hci_cb_list, list) {\n\t\tif (cb->security_cfm)\n\t\t\tcb->security_cfm(conn, status, encrypt);\n\t}\n\tmutex_unlock(&hci_cb_list_lock);\n\n\tif (conn->security_cfm_cb)\n\t\tconn->security_cfm_cb(conn, status);\n}\n\nstatic inline void hci_key_change_cfm(struct hci_conn *conn, __u8 status)\n{\n\tstruct hci_cb *cb;\n\n\tmutex_lock(&hci_cb_list_lock);\n\tlist_for_each_entry(cb, &hci_cb_list, list) {\n\t\tif (cb->key_change_cfm)\n\t\t\tcb->key_change_cfm(conn, status);\n\t}\n\tmutex_unlock(&hci_cb_list_lock);\n}\n\nstatic inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,\n\t\t\t\t\t\t\t\t__u8 role)\n{\n\tstruct hci_cb *cb;\n\n\tmutex_lock(&hci_cb_list_lock);\n\tlist_for_each_entry(cb, &hci_cb_list, list) {\n\t\tif (cb->role_switch_cfm)\n\t\t\tcb->role_switch_cfm(conn, status, role);\n\t}\n\tmutex_unlock(&hci_cb_list_lock);\n}\n\nstatic inline bool hci_bdaddr_is_rpa(bdaddr_t *bdaddr, u8 addr_type)\n{\n\tif (addr_type != ADDR_LE_DEV_RANDOM)\n\t\treturn false;\n\n\tif ((bdaddr->b[5] & 0xc0) == 0x40)\n\t       return true;\n\n\treturn false;\n}\n\nstatic inline bool hci_is_identity_address(bdaddr_t *addr, u8 addr_type)\n{\n\tif (addr_type == ADDR_LE_DEV_PUBLIC)\n\t\treturn true;\n\n\t \n\tif ((addr->b[5] & 0xc0) == 0xc0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline struct smp_irk *hci_get_irk(struct hci_dev *hdev,\n\t\t\t\t\t  bdaddr_t *bdaddr, u8 addr_type)\n{\n\tif (!hci_bdaddr_is_rpa(bdaddr, addr_type))\n\t\treturn NULL;\n\n\treturn hci_find_irk_by_rpa(hdev, bdaddr);\n}\n\nstatic inline int hci_check_conn_params(u16 min, u16 max, u16 latency,\n\t\t\t\t\tu16 to_multiplier)\n{\n\tu16 max_latency;\n\n\tif (min > max || min < 6 || max > 3200)\n\t\treturn -EINVAL;\n\n\tif (to_multiplier < 10 || to_multiplier > 3200)\n\t\treturn -EINVAL;\n\n\tif (max >= to_multiplier * 8)\n\t\treturn -EINVAL;\n\n\tmax_latency = (to_multiplier * 4 / max) - 1;\n\tif (latency > 499 || latency > max_latency)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint hci_register_cb(struct hci_cb *hcb);\nint hci_unregister_cb(struct hci_cb *hcb);\n\nint __hci_cmd_send(struct hci_dev *hdev, u16 opcode, u32 plen,\n\t\t   const void *param);\n\nint hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen,\n\t\t const void *param);\nvoid hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);\nvoid hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);\nvoid hci_send_iso(struct hci_conn *conn, struct sk_buff *skb);\n\nvoid *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);\nvoid *hci_recv_event_data(struct hci_dev *hdev, __u8 event);\n\nu32 hci_conn_get_phy(struct hci_conn *conn);\n\n \nvoid hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);\nvoid hci_send_to_channel(unsigned short channel, struct sk_buff *skb,\n\t\t\t int flag, struct sock *skip_sk);\nvoid hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);\nvoid hci_send_monitor_ctrl_event(struct hci_dev *hdev, u16 event,\n\t\t\t\t void *data, u16 data_len, ktime_t tstamp,\n\t\t\t\t int flag, struct sock *skip_sk);\n\nvoid hci_sock_dev_event(struct hci_dev *hdev, int event);\n\n#define HCI_MGMT_VAR_LEN\tBIT(0)\n#define HCI_MGMT_NO_HDEV\tBIT(1)\n#define HCI_MGMT_UNTRUSTED\tBIT(2)\n#define HCI_MGMT_UNCONFIGURED\tBIT(3)\n#define HCI_MGMT_HDEV_OPTIONAL\tBIT(4)\n\nstruct hci_mgmt_handler {\n\tint (*func) (struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t     u16 data_len);\n\tsize_t data_len;\n\tunsigned long flags;\n};\n\nstruct hci_mgmt_chan {\n\tstruct list_head list;\n\tunsigned short channel;\n\tsize_t handler_count;\n\tconst struct hci_mgmt_handler *handlers;\n\tvoid (*hdev_init) (struct sock *sk, struct hci_dev *hdev);\n};\n\nint hci_mgmt_chan_register(struct hci_mgmt_chan *c);\nvoid hci_mgmt_chan_unregister(struct hci_mgmt_chan *c);\n\n \n#define DISCOV_TYPE_BREDR\t\t(BIT(BDADDR_BREDR))\n#define DISCOV_TYPE_LE\t\t\t(BIT(BDADDR_LE_PUBLIC) | \\\n\t\t\t\t\t BIT(BDADDR_LE_RANDOM))\n#define DISCOV_TYPE_INTERLEAVED\t\t(BIT(BDADDR_BREDR) | \\\n\t\t\t\t\t BIT(BDADDR_LE_PUBLIC) | \\\n\t\t\t\t\t BIT(BDADDR_LE_RANDOM))\n\n \n#define DISCOV_LE_SCAN_WIN\t\t0x12\n#define DISCOV_LE_SCAN_INT\t\t0x12\n#define DISCOV_LE_TIMEOUT\t\t10240\t \n#define DISCOV_INTERLEAVED_TIMEOUT\t5120\t \n#define DISCOV_INTERLEAVED_INQUIRY_LEN\t0x04\n#define DISCOV_BREDR_INQUIRY_LEN\t0x08\n#define DISCOV_LE_RESTART_DELAY\t\tmsecs_to_jiffies(200)\t \n#define DISCOV_LE_FAST_ADV_INT_MIN\t0x00A0\t \n#define DISCOV_LE_FAST_ADV_INT_MAX\t0x00F0\t \n#define DISCOV_LE_PER_ADV_INT_MIN\t0x00A0\t \n#define DISCOV_LE_PER_ADV_INT_MAX\t0x00A0\t \n#define DISCOV_LE_ADV_MESH_MIN\t\t0x00A0   \n#define DISCOV_LE_ADV_MESH_MAX\t\t0x00A0   \n#define INTERVAL_TO_MS(x)\t\t(((x) * 10) / 0x10)\n\n#define NAME_RESOLVE_DURATION\t\tmsecs_to_jiffies(10240)\t \n\nvoid mgmt_fill_version_info(void *ver);\nint mgmt_new_settings(struct hci_dev *hdev);\nvoid mgmt_index_added(struct hci_dev *hdev);\nvoid mgmt_index_removed(struct hci_dev *hdev);\nvoid mgmt_set_powered_failed(struct hci_dev *hdev, int err);\nvoid mgmt_power_on(struct hci_dev *hdev, int err);\nvoid __mgmt_power_off(struct hci_dev *hdev);\nvoid mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,\n\t\t       bool persistent);\nvoid mgmt_device_connected(struct hci_dev *hdev, struct hci_conn *conn,\n\t\t\t   u8 *name, u8 name_len);\nvoid mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t      u8 link_type, u8 addr_type, u8 reason,\n\t\t\t      bool mgmt_connected);\nvoid mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t    u8 link_type, u8 addr_type, u8 status);\nvoid mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\n\t\t\t u8 addr_type, u8 status);\nvoid mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);\nvoid mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t  u8 status);\nvoid mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t      u8 status);\nint mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t      u8 link_type, u8 addr_type, u32 value,\n\t\t\t      u8 confirm_hint);\nint mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t     u8 link_type, u8 addr_type, u8 status);\nint mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t\t u8 link_type, u8 addr_type, u8 status);\nint mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t      u8 link_type, u8 addr_type);\nint mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t     u8 link_type, u8 addr_type, u8 status);\nint mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t\t u8 link_type, u8 addr_type, u8 status);\nint mgmt_user_passkey_notify(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t     u8 link_type, u8 addr_type, u32 passkey,\n\t\t\t     u8 entered);\nvoid mgmt_auth_failed(struct hci_conn *conn, u8 status);\nvoid mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);\nvoid mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,\n\t\t\t\t    u8 status);\nvoid mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);\nvoid mgmt_start_discovery_complete(struct hci_dev *hdev, u8 status);\nvoid mgmt_stop_discovery_complete(struct hci_dev *hdev, u8 status);\nvoid mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\n\t\t       u8 addr_type, u8 *dev_class, s8 rssi, u32 flags,\n\t\t       u8 *eir, u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len,\n\t\t       u64 instant);\nvoid mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\n\t\t      u8 addr_type, s8 rssi, u8 *name, u8 name_len);\nvoid mgmt_discovering(struct hci_dev *hdev, u8 discovering);\nvoid mgmt_suspending(struct hci_dev *hdev, u8 state);\nvoid mgmt_resuming(struct hci_dev *hdev, u8 reason, bdaddr_t *bdaddr,\n\t\t   u8 addr_type);\nbool mgmt_powering_down(struct hci_dev *hdev);\nvoid mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, bool persistent);\nvoid mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk, bool persistent);\nvoid mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk,\n\t\t   bool persistent);\nvoid mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t u8 bdaddr_type, u8 store_hint, u16 min_interval,\n\t\t\t u16 max_interval, u16 latency, u16 timeout);\nvoid mgmt_smp_complete(struct hci_conn *conn, bool complete);\nbool mgmt_get_connectable(struct hci_dev *hdev);\nu8 mgmt_get_adv_discov_flags(struct hci_dev *hdev);\nvoid mgmt_advertising_added(struct sock *sk, struct hci_dev *hdev,\n\t\t\t    u8 instance);\nvoid mgmt_advertising_removed(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      u8 instance);\nvoid mgmt_adv_monitor_removed(struct hci_dev *hdev, u16 handle);\nint mgmt_phy_configuration_changed(struct hci_dev *hdev, struct sock *skip);\nvoid mgmt_adv_monitor_device_lost(struct hci_dev *hdev, u16 handle,\n\t\t\t\t  bdaddr_t *bdaddr, u8 addr_type);\n\nint hci_abort_conn(struct hci_conn *conn, u8 reason);\nu8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,\n\t\t      u16 to_multiplier);\nvoid hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,\n\t\t      __u8 ltk[16], __u8 key_size);\n\nvoid hci_copy_identity_address(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t       u8 *bdaddr_type);\n\n#define SCO_AIRMODE_MASK       0x0003\n#define SCO_AIRMODE_CVSD       0x0000\n#define SCO_AIRMODE_TRANSP     0x0003\n\n#define LOCAL_CODEC_ACL_MASK\tBIT(0)\n#define LOCAL_CODEC_SCO_MASK\tBIT(1)\n\n#define TRANSPORT_TYPE_MAX\t0x04\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}