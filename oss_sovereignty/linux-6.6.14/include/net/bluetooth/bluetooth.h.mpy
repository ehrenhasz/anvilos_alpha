{
  "module_name": "bluetooth.h",
  "hash_id": "00c538df599ed000d9e9c26c39218fa476ed9a648d88ae2dbd13fda90f447db1",
  "original_prompt": "Ingested from linux-6.6.14/include/net/bluetooth/bluetooth.h",
  "human_readable_source": " \n\n#ifndef __BLUETOOTH_H\n#define __BLUETOOTH_H\n\n#include <linux/poll.h>\n#include <net/sock.h>\n#include <linux/seq_file.h>\n\n#define BT_SUBSYS_VERSION\t2\n#define BT_SUBSYS_REVISION\t22\n\n#ifndef AF_BLUETOOTH\n#define AF_BLUETOOTH\t31\n#define PF_BLUETOOTH\tAF_BLUETOOTH\n#endif\n\n \n#define BLUETOOTH_VER_1_1\t1\n#define BLUETOOTH_VER_1_2\t2\n#define BLUETOOTH_VER_2_0\t3\n#define BLUETOOTH_VER_2_1\t4\n#define BLUETOOTH_VER_4_0\t6\n\n \n#define BT_SKB_RESERVE\t8\n\n#define BTPROTO_L2CAP\t0\n#define BTPROTO_HCI\t1\n#define BTPROTO_SCO\t2\n#define BTPROTO_RFCOMM\t3\n#define BTPROTO_BNEP\t4\n#define BTPROTO_CMTP\t5\n#define BTPROTO_HIDP\t6\n#define BTPROTO_AVDTP\t7\n#define BTPROTO_ISO\t8\n#define BTPROTO_LAST\tBTPROTO_ISO\n\n#define SOL_HCI\t\t0\n#define SOL_L2CAP\t6\n#define SOL_SCO\t\t17\n#define SOL_RFCOMM\t18\n\n#define BT_SECURITY\t4\nstruct bt_security {\n\t__u8 level;\n\t__u8 key_size;\n};\n#define BT_SECURITY_SDP\t\t0\n#define BT_SECURITY_LOW\t\t1\n#define BT_SECURITY_MEDIUM\t2\n#define BT_SECURITY_HIGH\t3\n#define BT_SECURITY_FIPS\t4\n\n#define BT_DEFER_SETUP\t7\n\n#define BT_FLUSHABLE\t8\n\n#define BT_FLUSHABLE_OFF\t0\n#define BT_FLUSHABLE_ON\t\t1\n\n#define BT_POWER\t9\nstruct bt_power {\n\t__u8 force_active;\n};\n#define BT_POWER_FORCE_ACTIVE_OFF 0\n#define BT_POWER_FORCE_ACTIVE_ON  1\n\n#define BT_CHANNEL_POLICY\t10\n\n \n#define BT_CHANNEL_POLICY_BREDR_ONLY\t\t0\n\n \n#define BT_CHANNEL_POLICY_BREDR_PREFERRED\t1\n\n \n#define BT_CHANNEL_POLICY_AMP_PREFERRED\t\t2\n\n#define BT_VOICE\t\t11\nstruct bt_voice {\n\t__u16 setting;\n};\n\n#define BT_VOICE_TRANSPARENT\t\t\t0x0003\n#define BT_VOICE_CVSD_16BIT\t\t\t0x0060\n\n#define BT_SNDMTU\t\t12\n#define BT_RCVMTU\t\t13\n#define BT_PHY\t\t\t14\n\n#define BT_PHY_BR_1M_1SLOT\t0x00000001\n#define BT_PHY_BR_1M_3SLOT\t0x00000002\n#define BT_PHY_BR_1M_5SLOT\t0x00000004\n#define BT_PHY_EDR_2M_1SLOT\t0x00000008\n#define BT_PHY_EDR_2M_3SLOT\t0x00000010\n#define BT_PHY_EDR_2M_5SLOT\t0x00000020\n#define BT_PHY_EDR_3M_1SLOT\t0x00000040\n#define BT_PHY_EDR_3M_3SLOT\t0x00000080\n#define BT_PHY_EDR_3M_5SLOT\t0x00000100\n#define BT_PHY_LE_1M_TX\t\t0x00000200\n#define BT_PHY_LE_1M_RX\t\t0x00000400\n#define BT_PHY_LE_2M_TX\t\t0x00000800\n#define BT_PHY_LE_2M_RX\t\t0x00001000\n#define BT_PHY_LE_CODED_TX\t0x00002000\n#define BT_PHY_LE_CODED_RX\t0x00004000\n\n#define BT_MODE\t\t\t15\n\n#define BT_MODE_BASIC\t\t0x00\n#define BT_MODE_ERTM\t\t0x01\n#define BT_MODE_STREAMING\t0x02\n#define BT_MODE_LE_FLOWCTL\t0x03\n#define BT_MODE_EXT_FLOWCTL\t0x04\n\n#define BT_PKT_STATUS           16\n\n#define BT_SCM_PKT_STATUS\t0x03\n\n#define BT_ISO_QOS\t\t17\n\n#define BT_ISO_QOS_CIG_UNSET\t0xff\n#define BT_ISO_QOS_CIS_UNSET\t0xff\n\n#define BT_ISO_QOS_BIG_UNSET\t0xff\n#define BT_ISO_QOS_BIS_UNSET\t0xff\n\nstruct bt_iso_io_qos {\n\t__u32 interval;\n\t__u16 latency;\n\t__u16 sdu;\n\t__u8  phy;\n\t__u8  rtn;\n};\n\nstruct bt_iso_ucast_qos {\n\t__u8  cig;\n\t__u8  cis;\n\t__u8  sca;\n\t__u8  packing;\n\t__u8  framing;\n\tstruct bt_iso_io_qos in;\n\tstruct bt_iso_io_qos out;\n};\n\nstruct bt_iso_bcast_qos {\n\t__u8  big;\n\t__u8  bis;\n\t__u8  sync_factor;\n\t__u8  packing;\n\t__u8  framing;\n\tstruct bt_iso_io_qos in;\n\tstruct bt_iso_io_qos out;\n\t__u8  encryption;\n\t__u8  bcode[16];\n\t__u8  options;\n\t__u16 skip;\n\t__u16 sync_timeout;\n\t__u8  sync_cte_type;\n\t__u8  mse;\n\t__u16 timeout;\n};\n\nstruct bt_iso_qos {\n\tunion {\n\t\tstruct bt_iso_ucast_qos ucast;\n\t\tstruct bt_iso_bcast_qos bcast;\n\t};\n};\n\n#define BT_ISO_PHY_1M\t\t0x01\n#define BT_ISO_PHY_2M\t\t0x02\n#define BT_ISO_PHY_CODED\t0x04\n#define BT_ISO_PHY_ANY\t\t(BT_ISO_PHY_1M | BT_ISO_PHY_2M | \\\n\t\t\t\t BT_ISO_PHY_CODED)\n\n#define BT_CODEC\t19\n\nstruct\tbt_codec_caps {\n\t__u8\tlen;\n\t__u8\tdata[];\n} __packed;\n\nstruct bt_codec {\n\t__u8\tid;\n\t__u16\tcid;\n\t__u16\tvid;\n\t__u8\tdata_path;\n\t__u8\tnum_caps;\n} __packed;\n\nstruct bt_codecs {\n\t__u8\t\tnum_codecs;\n\tstruct bt_codec\tcodecs[];\n} __packed;\n\n#define BT_CODEC_CVSD\t\t0x02\n#define BT_CODEC_TRANSPARENT\t0x03\n#define BT_CODEC_MSBC\t\t0x05\n\n#define BT_ISO_BASE\t\t20\n\n__printf(1, 2)\nvoid bt_info(const char *fmt, ...);\n__printf(1, 2)\nvoid bt_warn(const char *fmt, ...);\n__printf(1, 2)\nvoid bt_err(const char *fmt, ...);\n#if IS_ENABLED(CONFIG_BT_FEATURE_DEBUG)\nvoid bt_dbg_set(bool enable);\nbool bt_dbg_get(void);\n__printf(1, 2)\nvoid bt_dbg(const char *fmt, ...);\n#endif\n__printf(1, 2)\nvoid bt_warn_ratelimited(const char *fmt, ...);\n__printf(1, 2)\nvoid bt_err_ratelimited(const char *fmt, ...);\n\n#define BT_INFO(fmt, ...)\tbt_info(fmt \"\\n\", ##__VA_ARGS__)\n#define BT_WARN(fmt, ...)\tbt_warn(fmt \"\\n\", ##__VA_ARGS__)\n#define BT_ERR(fmt, ...)\tbt_err(fmt \"\\n\", ##__VA_ARGS__)\n\n#if IS_ENABLED(CONFIG_BT_FEATURE_DEBUG)\n#define BT_DBG(fmt, ...)\tbt_dbg(fmt \"\\n\", ##__VA_ARGS__)\n#else\n#define BT_DBG(fmt, ...)\tpr_debug(fmt \"\\n\", ##__VA_ARGS__)\n#endif\n\n#define bt_dev_name(hdev) ((hdev) ? (hdev)->name : \"null\")\n\n#define bt_dev_info(hdev, fmt, ...)\t\t\t\t\\\n\tBT_INFO(\"%s: \" fmt, bt_dev_name(hdev), ##__VA_ARGS__)\n#define bt_dev_warn(hdev, fmt, ...)\t\t\t\t\\\n\tBT_WARN(\"%s: \" fmt, bt_dev_name(hdev), ##__VA_ARGS__)\n#define bt_dev_err(hdev, fmt, ...)\t\t\t\t\\\n\tBT_ERR(\"%s: \" fmt, bt_dev_name(hdev), ##__VA_ARGS__)\n#define bt_dev_dbg(hdev, fmt, ...)\t\t\t\t\\\n\tBT_DBG(\"%s: \" fmt, bt_dev_name(hdev), ##__VA_ARGS__)\n\n#define bt_dev_warn_ratelimited(hdev, fmt, ...)\t\t\t\\\n\tbt_warn_ratelimited(\"%s: \" fmt, bt_dev_name(hdev), ##__VA_ARGS__)\n#define bt_dev_err_ratelimited(hdev, fmt, ...)\t\t\t\\\n\tbt_err_ratelimited(\"%s: \" fmt, bt_dev_name(hdev), ##__VA_ARGS__)\n\n \nenum {\n\tBT_CONNECTED = 1,  \n\tBT_OPEN,\n\tBT_BOUND,\n\tBT_LISTEN,\n\tBT_CONNECT,\n\tBT_CONNECT2,\n\tBT_CONFIG,\n\tBT_DISCONN,\n\tBT_CLOSED\n};\n\n \nstatic inline const char *state_to_string(int state)\n{\n\tswitch (state) {\n\tcase BT_CONNECTED:\n\t\treturn \"BT_CONNECTED\";\n\tcase BT_OPEN:\n\t\treturn \"BT_OPEN\";\n\tcase BT_BOUND:\n\t\treturn \"BT_BOUND\";\n\tcase BT_LISTEN:\n\t\treturn \"BT_LISTEN\";\n\tcase BT_CONNECT:\n\t\treturn \"BT_CONNECT\";\n\tcase BT_CONNECT2:\n\t\treturn \"BT_CONNECT2\";\n\tcase BT_CONFIG:\n\t\treturn \"BT_CONFIG\";\n\tcase BT_DISCONN:\n\t\treturn \"BT_DISCONN\";\n\tcase BT_CLOSED:\n\t\treturn \"BT_CLOSED\";\n\t}\n\n\treturn \"invalid state\";\n}\n\n \ntypedef struct {\n\t__u8 b[6];\n} __packed bdaddr_t;\n\n \n#define BDADDR_BREDR\t\t0x00\n#define BDADDR_LE_PUBLIC\t0x01\n#define BDADDR_LE_RANDOM\t0x02\n\nstatic inline bool bdaddr_type_is_valid(u8 type)\n{\n\tswitch (type) {\n\tcase BDADDR_BREDR:\n\tcase BDADDR_LE_PUBLIC:\n\tcase BDADDR_LE_RANDOM:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline bool bdaddr_type_is_le(u8 type)\n{\n\tswitch (type) {\n\tcase BDADDR_LE_PUBLIC:\n\tcase BDADDR_LE_RANDOM:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#define BDADDR_ANY  (&(bdaddr_t) {{0, 0, 0, 0, 0, 0}})\n#define BDADDR_NONE (&(bdaddr_t) {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}})\n\n \nstatic inline int bacmp(const bdaddr_t *ba1, const bdaddr_t *ba2)\n{\n\treturn memcmp(ba1, ba2, sizeof(bdaddr_t));\n}\nstatic inline void bacpy(bdaddr_t *dst, const bdaddr_t *src)\n{\n\tmemcpy(dst, src, sizeof(bdaddr_t));\n}\n\nvoid baswap(bdaddr_t *dst, const bdaddr_t *src);\n\n \n\n#define bt_sk(__sk) ((struct bt_sock *) __sk)\n\nstruct bt_sock {\n\tstruct sock sk;\n\tstruct list_head accept_q;\n\tstruct sock *parent;\n\tunsigned long flags;\n\tvoid (*skb_msg_name)(struct sk_buff *, void *, int *);\n\tvoid (*skb_put_cmsg)(struct sk_buff *, struct msghdr *, struct sock *);\n};\n\nenum {\n\tBT_SK_DEFER_SETUP,\n\tBT_SK_SUSPEND,\n\tBT_SK_PKT_STATUS\n};\n\nstruct bt_sock_list {\n\tstruct hlist_head head;\n\trwlock_t          lock;\n#ifdef CONFIG_PROC_FS\n        int (* custom_seq_show)(struct seq_file *, void *);\n#endif\n};\n\nint  bt_sock_register(int proto, const struct net_proto_family *ops);\nvoid bt_sock_unregister(int proto);\nvoid bt_sock_link(struct bt_sock_list *l, struct sock *s);\nvoid bt_sock_unlink(struct bt_sock_list *l, struct sock *s);\nstruct sock *bt_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t   struct proto *prot, int proto, gfp_t prio, int kern);\nint  bt_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t     int flags);\nint  bt_sock_stream_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len, int flags);\n__poll_t bt_sock_poll(struct file *file, struct socket *sock, poll_table *wait);\nint  bt_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);\nint  bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo);\nint  bt_sock_wait_ready(struct sock *sk, unsigned int msg_flags);\n\nvoid bt_accept_enqueue(struct sock *parent, struct sock *sk, bool bh);\nvoid bt_accept_unlink(struct sock *sk);\nstruct sock *bt_accept_dequeue(struct sock *parent, struct socket *newsock);\n\n \nstruct l2cap_ctrl {\n\tu8\tsframe:1,\n\t\tpoll:1,\n\t\tfinal:1,\n\t\tfcs:1,\n\t\tsar:2,\n\t\tsuper:2;\n\n\tu16\treqseq;\n\tu16\ttxseq;\n\tu8\tretries;\n\t__le16  psm;\n\tbdaddr_t bdaddr;\n\tstruct l2cap_chan *chan;\n};\n\nstruct hci_dev;\n\ntypedef void (*hci_req_complete_t)(struct hci_dev *hdev, u8 status, u16 opcode);\ntypedef void (*hci_req_complete_skb_t)(struct hci_dev *hdev, u8 status,\n\t\t\t\t       u16 opcode, struct sk_buff *skb);\n\n#define HCI_REQ_START\tBIT(0)\n#define HCI_REQ_SKB\tBIT(1)\n\nstruct hci_ctrl {\n\tstruct sock *sk;\n\tu16 opcode;\n\tu8 req_flags;\n\tu8 req_event;\n\tunion {\n\t\thci_req_complete_t req_complete;\n\t\thci_req_complete_skb_t req_complete_skb;\n\t};\n};\n\nstruct mgmt_ctrl {\n\tstruct hci_dev *hdev;\n\tu16 opcode;\n};\n\nstruct bt_skb_cb {\n\tu8 pkt_type;\n\tu8 force_active;\n\tu16 expect;\n\tu8 incoming:1;\n\tu8 pkt_status:2;\n\tunion {\n\t\tstruct l2cap_ctrl l2cap;\n\t\tstruct hci_ctrl hci;\n\t\tstruct mgmt_ctrl mgmt;\n\t\tstruct scm_creds creds;\n\t};\n};\n#define bt_cb(skb) ((struct bt_skb_cb *)((skb)->cb))\n\n#define hci_skb_pkt_type(skb) bt_cb((skb))->pkt_type\n#define hci_skb_pkt_status(skb) bt_cb((skb))->pkt_status\n#define hci_skb_expect(skb) bt_cb((skb))->expect\n#define hci_skb_opcode(skb) bt_cb((skb))->hci.opcode\n#define hci_skb_event(skb) bt_cb((skb))->hci.req_event\n#define hci_skb_sk(skb) bt_cb((skb))->hci.sk\n\nstatic inline struct sk_buff *bt_skb_alloc(unsigned int len, gfp_t how)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(len + BT_SKB_RESERVE, how);\n\tif (skb)\n\t\tskb_reserve(skb, BT_SKB_RESERVE);\n\treturn skb;\n}\n\nstatic inline struct sk_buff *bt_skb_send_alloc(struct sock *sk,\n\t\t\t\t\tunsigned long len, int nb, int *err)\n{\n\tstruct sk_buff *skb;\n\n\tskb = sock_alloc_send_skb(sk, len + BT_SKB_RESERVE, nb, err);\n\tif (skb)\n\t\tskb_reserve(skb, BT_SKB_RESERVE);\n\n\tif (!skb && *err)\n\t\treturn NULL;\n\n\t*err = sock_error(sk);\n\tif (*err)\n\t\tgoto out;\n\n\tif (sk->sk_shutdown) {\n\t\t*err = -ECONNRESET;\n\t\tgoto out;\n\t}\n\n\treturn skb;\n\nout:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\n \nstatic inline struct sk_buff *bt_skb_sendmsg(struct sock *sk,\n\t\t\t\t\t     struct msghdr *msg,\n\t\t\t\t\t     size_t len, size_t mtu,\n\t\t\t\t\t     size_t headroom, size_t tailroom)\n{\n\tstruct sk_buff *skb;\n\tsize_t size = min_t(size_t, len, mtu);\n\tint err;\n\n\tskb = bt_skb_send_alloc(sk, size + headroom + tailroom,\n\t\t\t\tmsg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn ERR_PTR(err);\n\n\tskb_reserve(skb, headroom);\n\tskb_tailroom_reserve(skb, mtu, tailroom);\n\n\tif (!copy_from_iter_full(skb_put(skb, size), size, &msg->msg_iter)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\tskb->priority = sk->sk_priority;\n\n\treturn skb;\n}\n\n \nstatic inline struct sk_buff *bt_skb_sendmmsg(struct sock *sk,\n\t\t\t\t\t      struct msghdr *msg,\n\t\t\t\t\t      size_t len, size_t mtu,\n\t\t\t\t\t      size_t headroom, size_t tailroom)\n{\n\tstruct sk_buff *skb, **frag;\n\n\tskb = bt_skb_sendmsg(sk, msg, len, mtu, headroom, tailroom);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\tlen -= skb->len;\n\tif (!len)\n\t\treturn skb;\n\n\t \n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tstruct sk_buff *tmp;\n\n\t\ttmp = bt_skb_sendmsg(sk, msg, len, mtu, headroom, tailroom);\n\t\tif (IS_ERR(tmp)) {\n\t\t\treturn skb;\n\t\t}\n\n\t\tlen -= tmp->len;\n\n\t\t*frag = tmp;\n\t\tfrag = &(*frag)->next;\n\t}\n\n\treturn skb;\n}\n\nint bt_to_errno(u16 code);\n__u8 bt_status(int err);\n\nvoid hci_sock_set_flag(struct sock *sk, int nr);\nvoid hci_sock_clear_flag(struct sock *sk, int nr);\nint hci_sock_test_flag(struct sock *sk, int nr);\nunsigned short hci_sock_get_channel(struct sock *sk);\nu32 hci_sock_get_cookie(struct sock *sk);\n\nint hci_sock_init(void);\nvoid hci_sock_cleanup(void);\n\nint bt_sysfs_init(void);\nvoid bt_sysfs_cleanup(void);\n\nint bt_procfs_init(struct net *net, const char *name,\n\t\t   struct bt_sock_list *sk_list,\n\t\t   int (*seq_show)(struct seq_file *, void *));\nvoid bt_procfs_cleanup(struct net *net, const char *name);\n\nextern struct dentry *bt_debugfs;\n\nint l2cap_init(void);\nvoid l2cap_exit(void);\n\n#if IS_ENABLED(CONFIG_BT_BREDR)\nint sco_init(void);\nvoid sco_exit(void);\n#else\nstatic inline int sco_init(void)\n{\n\treturn 0;\n}\n\nstatic inline void sco_exit(void)\n{\n}\n#endif\n\n#if IS_ENABLED(CONFIG_BT_LE)\nint iso_init(void);\nint iso_exit(void);\nbool iso_enabled(void);\n#else\nstatic inline int iso_init(void)\n{\n\treturn 0;\n}\n\nstatic inline int iso_exit(void)\n{\n\treturn 0;\n}\n\nstatic inline bool iso_enabled(void)\n{\n\treturn false;\n}\n#endif\n\nint mgmt_init(void);\nvoid mgmt_exit(void);\nvoid mgmt_cleanup(struct sock *sk);\n\nvoid bt_sock_reclassify_lock(struct sock *sk, int proto);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}