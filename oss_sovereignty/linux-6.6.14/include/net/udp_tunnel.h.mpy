{
  "module_name": "udp_tunnel.h",
  "hash_id": "cf69401f56ed592e47aba3c08713653706817244cd0e986cfabc3c464e29b145",
  "original_prompt": "Ingested from linux-6.6.14/include/net/udp_tunnel.h",
  "human_readable_source": " \n#ifndef __NET_UDP_TUNNEL_H\n#define __NET_UDP_TUNNEL_H\n\n#include <net/ip_tunnels.h>\n#include <net/udp.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#include <net/ipv6_stubs.h>\n#endif\n\nstruct udp_port_cfg {\n\tu8\t\t\tfamily;\n\n\t \n\tunion {\n\t\tstruct in_addr\t\tlocal_ip;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct in6_addr\t\tlocal_ip6;\n#endif\n\t};\n\n\tunion {\n\t\tstruct in_addr\t\tpeer_ip;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct in6_addr\t\tpeer_ip6;\n#endif\n\t};\n\n\t__be16\t\t\tlocal_udp_port;\n\t__be16\t\t\tpeer_udp_port;\n\tint\t\t\tbind_ifindex;\n\tunsigned int\t\tuse_udp_checksums:1,\n\t\t\t\tuse_udp6_tx_checksums:1,\n\t\t\t\tuse_udp6_rx_checksums:1,\n\t\t\t\tipv6_v6only:1;\n};\n\nint udp_sock_create4(struct net *net, struct udp_port_cfg *cfg,\n\t\t     struct socket **sockp);\n\n#if IS_ENABLED(CONFIG_IPV6)\nint udp_sock_create6(struct net *net, struct udp_port_cfg *cfg,\n\t\t     struct socket **sockp);\n#else\nstatic inline int udp_sock_create6(struct net *net, struct udp_port_cfg *cfg,\n\t\t\t\t   struct socket **sockp)\n{\n\treturn 0;\n}\n#endif\n\nstatic inline int udp_sock_create(struct net *net,\n\t\t\t\t  struct udp_port_cfg *cfg,\n\t\t\t\t  struct socket **sockp)\n{\n\tif (cfg->family == AF_INET)\n\t\treturn udp_sock_create4(net, cfg, sockp);\n\n\tif (cfg->family == AF_INET6)\n\t\treturn udp_sock_create6(net, cfg, sockp);\n\n\treturn -EPFNOSUPPORT;\n}\n\ntypedef int (*udp_tunnel_encap_rcv_t)(struct sock *sk, struct sk_buff *skb);\ntypedef int (*udp_tunnel_encap_err_lookup_t)(struct sock *sk,\n\t\t\t\t\t     struct sk_buff *skb);\ntypedef void (*udp_tunnel_encap_err_rcv_t)(struct sock *sk,\n\t\t\t\t\t   struct sk_buff *skb, int err,\n\t\t\t\t\t   __be16 port, u32 info, u8 *payload);\ntypedef void (*udp_tunnel_encap_destroy_t)(struct sock *sk);\ntypedef struct sk_buff *(*udp_tunnel_gro_receive_t)(struct sock *sk,\n\t\t\t\t\t\t    struct list_head *head,\n\t\t\t\t\t\t    struct sk_buff *skb);\ntypedef int (*udp_tunnel_gro_complete_t)(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t int nhoff);\n\nstruct udp_tunnel_sock_cfg {\n\tvoid *sk_user_data;      \n\t \n\t__u8  encap_type;\n\tudp_tunnel_encap_rcv_t encap_rcv;\n\tudp_tunnel_encap_err_lookup_t encap_err_lookup;\n\tudp_tunnel_encap_err_rcv_t encap_err_rcv;\n\tudp_tunnel_encap_destroy_t encap_destroy;\n\tudp_tunnel_gro_receive_t gro_receive;\n\tudp_tunnel_gro_complete_t gro_complete;\n};\n\n \nvoid setup_udp_tunnel_sock(struct net *net, struct socket *sock,\n\t\t\t   struct udp_tunnel_sock_cfg *sock_cfg);\n\n \nenum udp_parsable_tunnel_type {\n\tUDP_TUNNEL_TYPE_VXLAN\t  = BIT(0),  \n\tUDP_TUNNEL_TYPE_GENEVE\t  = BIT(1),  \n\tUDP_TUNNEL_TYPE_VXLAN_GPE = BIT(2),  \n};\n\nstruct udp_tunnel_info {\n\tunsigned short type;\n\tsa_family_t sa_family;\n\t__be16 port;\n\tu8 hw_priv;\n};\n\n \nvoid udp_tunnel_push_rx_port(struct net_device *dev, struct socket *sock,\n\t\t\t     unsigned short type);\nvoid udp_tunnel_drop_rx_port(struct net_device *dev, struct socket *sock,\n\t\t\t     unsigned short type);\nvoid udp_tunnel_notify_add_rx_port(struct socket *sock, unsigned short type);\nvoid udp_tunnel_notify_del_rx_port(struct socket *sock, unsigned short type);\n\nstatic inline void udp_tunnel_get_rx_info(struct net_device *dev)\n{\n\tASSERT_RTNL();\n\tif (!(dev->features & NETIF_F_RX_UDP_TUNNEL_PORT))\n\t\treturn;\n\tcall_netdevice_notifiers(NETDEV_UDP_TUNNEL_PUSH_INFO, dev);\n}\n\nstatic inline void udp_tunnel_drop_rx_info(struct net_device *dev)\n{\n\tASSERT_RTNL();\n\tif (!(dev->features & NETIF_F_RX_UDP_TUNNEL_PORT))\n\t\treturn;\n\tcall_netdevice_notifiers(NETDEV_UDP_TUNNEL_DROP_INFO, dev);\n}\n\n \nvoid udp_tunnel_xmit_skb(struct rtable *rt, struct sock *sk, struct sk_buff *skb,\n\t\t\t __be32 src, __be32 dst, __u8 tos, __u8 ttl,\n\t\t\t __be16 df, __be16 src_port, __be16 dst_port,\n\t\t\t bool xnet, bool nocheck);\n\nint udp_tunnel6_xmit_skb(struct dst_entry *dst, struct sock *sk,\n\t\t\t struct sk_buff *skb,\n\t\t\t struct net_device *dev, struct in6_addr *saddr,\n\t\t\t struct in6_addr *daddr,\n\t\t\t __u8 prio, __u8 ttl, __be32 label,\n\t\t\t __be16 src_port, __be16 dst_port, bool nocheck);\n\nvoid udp_tunnel_sock_release(struct socket *sock);\n\nstruct metadata_dst *udp_tun_rx_dst(struct sk_buff *skb, unsigned short family,\n\t\t\t\t    __be16 flags, __be64 tunnel_id,\n\t\t\t\t    int md_size);\n\n#ifdef CONFIG_INET\nstatic inline int udp_tunnel_handle_offloads(struct sk_buff *skb, bool udp_csum)\n{\n\tint type = udp_csum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;\n\n\treturn iptunnel_handle_offloads(skb, type);\n}\n#endif\n\nstatic inline void udp_tunnel_encap_enable(struct sock *sk)\n{\n\tif (udp_test_and_set_bit(ENCAP_ENABLED, sk))\n\t\treturn;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (READ_ONCE(sk->sk_family) == PF_INET6)\n\t\tipv6_stub->udpv6_encap_enable();\n#endif\n\tudp_encap_enable();\n}\n\n#define UDP_TUNNEL_NIC_MAX_TABLES\t4\n\nenum udp_tunnel_nic_info_flags {\n\t \n\tUDP_TUNNEL_NIC_INFO_MAY_SLEEP\t= BIT(0),\n\t \n\tUDP_TUNNEL_NIC_INFO_OPEN_ONLY\t= BIT(1),\n\t \n\tUDP_TUNNEL_NIC_INFO_IPV4_ONLY\t= BIT(2),\n\t \n\tUDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN\t= BIT(3),\n};\n\nstruct udp_tunnel_nic;\n\n#define UDP_TUNNEL_NIC_MAX_SHARING_DEVICES\t(U16_MAX / 2)\n\nstruct udp_tunnel_nic_shared {\n\tstruct udp_tunnel_nic *udp_tunnel_nic_info;\n\n\tstruct list_head devices;\n};\n\nstruct udp_tunnel_nic_shared_node {\n\tstruct net_device *dev;\n\tstruct list_head list;\n};\n\n \nstruct udp_tunnel_nic_info {\n\t \n\tint (*set_port)(struct net_device *dev,\n\t\t\tunsigned int table, unsigned int entry,\n\t\t\tstruct udp_tunnel_info *ti);\n\tint (*unset_port)(struct net_device *dev,\n\t\t\t  unsigned int table, unsigned int entry,\n\t\t\t  struct udp_tunnel_info *ti);\n\n\t \n\tint (*sync_table)(struct net_device *dev, unsigned int table);\n\n\tstruct udp_tunnel_nic_shared *shared;\n\n\tunsigned int flags;\n\n\tstruct udp_tunnel_nic_table_info {\n\t\tunsigned int n_entries;\n\t\tunsigned int tunnel_types;\n\t} tables[UDP_TUNNEL_NIC_MAX_TABLES];\n};\n\n \nstruct udp_tunnel_nic_ops {\n\tvoid (*get_port)(struct net_device *dev, unsigned int table,\n\t\t\t unsigned int idx, struct udp_tunnel_info *ti);\n\tvoid (*set_port_priv)(struct net_device *dev, unsigned int table,\n\t\t\t      unsigned int idx, u8 priv);\n\tvoid (*add_port)(struct net_device *dev, struct udp_tunnel_info *ti);\n\tvoid (*del_port)(struct net_device *dev, struct udp_tunnel_info *ti);\n\tvoid (*reset_ntf)(struct net_device *dev);\n\n\tsize_t (*dump_size)(struct net_device *dev, unsigned int table);\n\tint (*dump_write)(struct net_device *dev, unsigned int table,\n\t\t\t  struct sk_buff *skb);\n};\n\n#ifdef CONFIG_INET\nextern const struct udp_tunnel_nic_ops *udp_tunnel_nic_ops;\n#else\n#define udp_tunnel_nic_ops\t((struct udp_tunnel_nic_ops *)NULL)\n#endif\n\nstatic inline void\nudp_tunnel_nic_get_port(struct net_device *dev, unsigned int table,\n\t\t\tunsigned int idx, struct udp_tunnel_info *ti)\n{\n\t \n\tmemset(ti, 0, sizeof(*ti));\n\n\tif (udp_tunnel_nic_ops)\n\t\tudp_tunnel_nic_ops->get_port(dev, table, idx, ti);\n}\n\nstatic inline void\nudp_tunnel_nic_set_port_priv(struct net_device *dev, unsigned int table,\n\t\t\t     unsigned int idx, u8 priv)\n{\n\tif (udp_tunnel_nic_ops)\n\t\tudp_tunnel_nic_ops->set_port_priv(dev, table, idx, priv);\n}\n\nstatic inline void\nudp_tunnel_nic_add_port(struct net_device *dev, struct udp_tunnel_info *ti)\n{\n\tif (!(dev->features & NETIF_F_RX_UDP_TUNNEL_PORT))\n\t\treturn;\n\tif (udp_tunnel_nic_ops)\n\t\tudp_tunnel_nic_ops->add_port(dev, ti);\n}\n\nstatic inline void\nudp_tunnel_nic_del_port(struct net_device *dev, struct udp_tunnel_info *ti)\n{\n\tif (!(dev->features & NETIF_F_RX_UDP_TUNNEL_PORT))\n\t\treturn;\n\tif (udp_tunnel_nic_ops)\n\t\tudp_tunnel_nic_ops->del_port(dev, ti);\n}\n\n \nstatic inline void udp_tunnel_nic_reset_ntf(struct net_device *dev)\n{\n\tif (udp_tunnel_nic_ops)\n\t\tudp_tunnel_nic_ops->reset_ntf(dev);\n}\n\nstatic inline size_t\nudp_tunnel_nic_dump_size(struct net_device *dev, unsigned int table)\n{\n\tif (!udp_tunnel_nic_ops)\n\t\treturn 0;\n\treturn udp_tunnel_nic_ops->dump_size(dev, table);\n}\n\nstatic inline int\nudp_tunnel_nic_dump_write(struct net_device *dev, unsigned int table,\n\t\t\t  struct sk_buff *skb)\n{\n\tif (!udp_tunnel_nic_ops)\n\t\treturn 0;\n\treturn udp_tunnel_nic_ops->dump_write(dev, table, skb);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}