{
  "module_name": "lwtunnel.h",
  "hash_id": "93692a9ad1c75d7a92355a948aa495196773a7007d7066f7ae2bd57ec7dac9cc",
  "original_prompt": "Ingested from linux-6.6.14/include/net/lwtunnel.h",
  "human_readable_source": " \n#ifndef __NET_LWTUNNEL_H\n#define __NET_LWTUNNEL_H 1\n\n#include <linux/lwtunnel.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/types.h>\n#include <net/route.h>\n\n#define LWTUNNEL_HASH_BITS   7\n#define LWTUNNEL_HASH_SIZE   (1 << LWTUNNEL_HASH_BITS)\n\n \n#define LWTUNNEL_STATE_OUTPUT_REDIRECT\tBIT(0)\n#define LWTUNNEL_STATE_INPUT_REDIRECT\tBIT(1)\n#define LWTUNNEL_STATE_XMIT_REDIRECT\tBIT(2)\n\n \nenum {\n\tLWTUNNEL_XMIT_DONE,\n\tLWTUNNEL_XMIT_CONTINUE = 0x100,\n};\n\n\nstruct lwtunnel_state {\n\t__u16\t\ttype;\n\t__u16\t\tflags;\n\t__u16\t\theadroom;\n\tatomic_t\trefcnt;\n\tint\t\t(*orig_output)(struct net *net, struct sock *sk, struct sk_buff *skb);\n\tint\t\t(*orig_input)(struct sk_buff *);\n\tstruct\t\trcu_head rcu;\n\t__u8            data[];\n};\n\nstruct lwtunnel_encap_ops {\n\tint (*build_state)(struct net *net, struct nlattr *encap,\n\t\t\t   unsigned int family, const void *cfg,\n\t\t\t   struct lwtunnel_state **ts,\n\t\t\t   struct netlink_ext_ack *extack);\n\tvoid (*destroy_state)(struct lwtunnel_state *lws);\n\tint (*output)(struct net *net, struct sock *sk, struct sk_buff *skb);\n\tint (*input)(struct sk_buff *skb);\n\tint (*fill_encap)(struct sk_buff *skb,\n\t\t\t  struct lwtunnel_state *lwtstate);\n\tint (*get_encap_size)(struct lwtunnel_state *lwtstate);\n\tint (*cmp_encap)(struct lwtunnel_state *a, struct lwtunnel_state *b);\n\tint (*xmit)(struct sk_buff *skb);\n\n\tstruct module *owner;\n};\n\n#ifdef CONFIG_LWTUNNEL\n\nDECLARE_STATIC_KEY_FALSE(nf_hooks_lwtunnel_enabled);\n\nvoid lwtstate_free(struct lwtunnel_state *lws);\n\nstatic inline struct lwtunnel_state *\nlwtstate_get(struct lwtunnel_state *lws)\n{\n\tif (lws)\n\t\tatomic_inc(&lws->refcnt);\n\n\treturn lws;\n}\n\nstatic inline void lwtstate_put(struct lwtunnel_state *lws)\n{\n\tif (!lws)\n\t\treturn;\n\n\tif (atomic_dec_and_test(&lws->refcnt))\n\t\tlwtstate_free(lws);\n}\n\nstatic inline bool lwtunnel_output_redirect(struct lwtunnel_state *lwtstate)\n{\n\tif (lwtstate && (lwtstate->flags & LWTUNNEL_STATE_OUTPUT_REDIRECT))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool lwtunnel_input_redirect(struct lwtunnel_state *lwtstate)\n{\n\tif (lwtstate && (lwtstate->flags & LWTUNNEL_STATE_INPUT_REDIRECT))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool lwtunnel_xmit_redirect(struct lwtunnel_state *lwtstate)\n{\n\tif (lwtstate && (lwtstate->flags & LWTUNNEL_STATE_XMIT_REDIRECT))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline unsigned int lwtunnel_headroom(struct lwtunnel_state *lwtstate,\n\t\t\t\t\t     unsigned int mtu)\n{\n\tif ((lwtunnel_xmit_redirect(lwtstate) ||\n\t     lwtunnel_output_redirect(lwtstate)) && lwtstate->headroom < mtu)\n\t\treturn lwtstate->headroom;\n\n\treturn 0;\n}\n\nint lwtunnel_encap_add_ops(const struct lwtunnel_encap_ops *op,\n\t\t\t   unsigned int num);\nint lwtunnel_encap_del_ops(const struct lwtunnel_encap_ops *op,\n\t\t\t   unsigned int num);\nint lwtunnel_valid_encap_type(u16 encap_type,\n\t\t\t      struct netlink_ext_ack *extack);\nint lwtunnel_valid_encap_type_attr(struct nlattr *attr, int len,\n\t\t\t\t   struct netlink_ext_ack *extack);\nint lwtunnel_build_state(struct net *net, u16 encap_type,\n\t\t\t struct nlattr *encap,\n\t\t\t unsigned int family, const void *cfg,\n\t\t\t struct lwtunnel_state **lws,\n\t\t\t struct netlink_ext_ack *extack);\nint lwtunnel_fill_encap(struct sk_buff *skb, struct lwtunnel_state *lwtstate,\n\t\t\tint encap_attr, int encap_type_attr);\nint lwtunnel_get_encap_size(struct lwtunnel_state *lwtstate);\nstruct lwtunnel_state *lwtunnel_state_alloc(int hdr_len);\nint lwtunnel_cmp_encap(struct lwtunnel_state *a, struct lwtunnel_state *b);\nint lwtunnel_output(struct net *net, struct sock *sk, struct sk_buff *skb);\nint lwtunnel_input(struct sk_buff *skb);\nint lwtunnel_xmit(struct sk_buff *skb);\nint bpf_lwt_push_ip_encap(struct sk_buff *skb, void *hdr, u32 len,\n\t\t\t  bool ingress);\n\nstatic inline void lwtunnel_set_redirect(struct dst_entry *dst)\n{\n\tif (lwtunnel_output_redirect(dst->lwtstate)) {\n\t\tdst->lwtstate->orig_output = dst->output;\n\t\tdst->output = lwtunnel_output;\n\t}\n\tif (lwtunnel_input_redirect(dst->lwtstate)) {\n\t\tdst->lwtstate->orig_input = dst->input;\n\t\tdst->input = lwtunnel_input;\n\t}\n}\n#else\n\nstatic inline void lwtstate_free(struct lwtunnel_state *lws)\n{\n}\n\nstatic inline struct lwtunnel_state *\nlwtstate_get(struct lwtunnel_state *lws)\n{\n\treturn lws;\n}\n\nstatic inline void lwtstate_put(struct lwtunnel_state *lws)\n{\n}\n\nstatic inline bool lwtunnel_output_redirect(struct lwtunnel_state *lwtstate)\n{\n\treturn false;\n}\n\nstatic inline bool lwtunnel_input_redirect(struct lwtunnel_state *lwtstate)\n{\n\treturn false;\n}\n\nstatic inline bool lwtunnel_xmit_redirect(struct lwtunnel_state *lwtstate)\n{\n\treturn false;\n}\n\nstatic inline void lwtunnel_set_redirect(struct dst_entry *dst)\n{\n}\n\nstatic inline unsigned int lwtunnel_headroom(struct lwtunnel_state *lwtstate,\n\t\t\t\t\t     unsigned int mtu)\n{\n\treturn 0;\n}\n\nstatic inline int lwtunnel_encap_add_ops(const struct lwtunnel_encap_ops *op,\n\t\t\t\t\t unsigned int num)\n{\n\treturn -EOPNOTSUPP;\n\n}\n\nstatic inline int lwtunnel_encap_del_ops(const struct lwtunnel_encap_ops *op,\n\t\t\t\t\t unsigned int num)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int lwtunnel_valid_encap_type(u16 encap_type,\n\t\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tNL_SET_ERR_MSG(extack, \"CONFIG_LWTUNNEL is not enabled in this kernel\");\n\treturn -EOPNOTSUPP;\n}\nstatic inline int lwtunnel_valid_encap_type_attr(struct nlattr *attr, int len,\n\t\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\t \n\treturn 0;\n}\n\nstatic inline int lwtunnel_build_state(struct net *net, u16 encap_type,\n\t\t\t\t       struct nlattr *encap,\n\t\t\t\t       unsigned int family, const void *cfg,\n\t\t\t\t       struct lwtunnel_state **lws,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int lwtunnel_fill_encap(struct sk_buff *skb,\n\t\t\t\t      struct lwtunnel_state *lwtstate,\n\t\t\t\t      int encap_attr, int encap_type_attr)\n{\n\treturn 0;\n}\n\nstatic inline int lwtunnel_get_encap_size(struct lwtunnel_state *lwtstate)\n{\n\treturn 0;\n}\n\nstatic inline struct lwtunnel_state *lwtunnel_state_alloc(int hdr_len)\n{\n\treturn NULL;\n}\n\nstatic inline int lwtunnel_cmp_encap(struct lwtunnel_state *a,\n\t\t\t\t     struct lwtunnel_state *b)\n{\n\treturn 0;\n}\n\nstatic inline int lwtunnel_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int lwtunnel_input(struct sk_buff *skb)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int lwtunnel_xmit(struct sk_buff *skb)\n{\n\treturn -EOPNOTSUPP;\n}\n\n#endif  \n\n#define MODULE_ALIAS_RTNL_LWT(encap_type) MODULE_ALIAS(\"rtnl-lwt-\" __stringify(encap_type))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}