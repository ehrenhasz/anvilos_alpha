{
  "module_name": "netrom.h",
  "hash_id": "fc37f80a3b906ec1146242932a2129b59cb36adfddaf70afe58327f7d3816ced",
  "original_prompt": "Ingested from linux-6.6.14/include/net/netrom.h",
  "human_readable_source": " \n \n\n#ifndef _NETROM_H\n#define _NETROM_H \n\n#include <linux/netrom.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <net/ax25.h>\n\n#define\tNR_NETWORK_LEN\t\t\t15\n#define\tNR_TRANSPORT_LEN\t\t5\n\n#define\tNR_PROTO_IP\t\t\t0x0C\n\n#define\tNR_PROTOEXT\t\t\t0x00\n#define\tNR_CONNREQ\t\t\t0x01\n#define\tNR_CONNACK\t\t\t0x02\n#define\tNR_DISCREQ\t\t\t0x03\n#define\tNR_DISCACK\t\t\t0x04\n#define\tNR_INFO\t\t\t\t0x05\n#define\tNR_INFOACK\t\t\t0x06\n#define\tNR_RESET\t\t\t0x07\n\n#define\tNR_CHOKE_FLAG\t\t\t0x80\n#define\tNR_NAK_FLAG\t\t\t0x40\n#define\tNR_MORE_FLAG\t\t\t0x20\n\n \nenum {\n\tNR_STATE_0,\n\tNR_STATE_1,\n\tNR_STATE_2,\n\tNR_STATE_3\n};\n\n#define\tNR_COND_ACK_PENDING\t\t0x01\n#define\tNR_COND_REJECT\t\t\t0x02\n#define\tNR_COND_PEER_RX_BUSY\t\t0x04\n#define\tNR_COND_OWN_RX_BUSY\t\t0x08\n\n#define NR_DEFAULT_T1\t\t\t120000\t\t \n#define NR_DEFAULT_T2\t\t\t5000\t\t \n#define NR_DEFAULT_N2\t\t\t3\t\t \n#define\tNR_DEFAULT_T4\t\t\t180000\t\t \n#define\tNR_DEFAULT_IDLE\t\t\t0\t\t \n#define\tNR_DEFAULT_WINDOW\t\t4\t\t \n#define\tNR_DEFAULT_OBS\t\t\t6\t\t \n#define\tNR_DEFAULT_QUAL\t\t\t10\t\t \n#define\tNR_DEFAULT_TTL\t\t\t16\t\t \n#define\tNR_DEFAULT_ROUTING\t\t1\t\t \n#define\tNR_DEFAULT_FAILS\t\t2\t\t \n#define\tNR_DEFAULT_RESET\t\t0\t\t \n\n#define NR_MODULUS \t\t\t256\n#define NR_MAX_WINDOW_SIZE\t\t127\t\t\t \n#define\tNR_MAX_PACKET_SIZE\t\t236\t\t\t \n\nstruct nr_sock {\n\tstruct sock\t\tsock;\n\tax25_address\t\tuser_addr, source_addr, dest_addr;\n\tstruct net_device\t\t*device;\n\tunsigned char\t\tmy_index,   my_id;\n\tunsigned char\t\tyour_index, your_id;\n\tunsigned char\t\tstate, condition, bpqext, window;\n\tunsigned short\t\tvs, vr, va, vl;\n\tunsigned char\t\tn2, n2count;\n\tunsigned long\t\tt1, t2, t4, idle;\n\tunsigned short\t\tfraglen;\n\tstruct timer_list\tt1timer;\n\tstruct timer_list\tt2timer;\n\tstruct timer_list\tt4timer;\n\tstruct timer_list\tidletimer;\n\tstruct sk_buff_head\tack_queue;\n\tstruct sk_buff_head\treseq_queue;\n\tstruct sk_buff_head\tfrag_queue;\n};\n\n#define nr_sk(sk) ((struct nr_sock *)(sk))\n\nstruct nr_neigh {\n\tstruct hlist_node\tneigh_node;\n\tax25_address\t\tcallsign;\n\tax25_digi\t\t*digipeat;\n\tax25_cb\t\t\t*ax25;\n\tstruct net_device\t*dev;\n\tunsigned char\t\tquality;\n\tunsigned char\t\tlocked;\n\tunsigned short\t\tcount;\n\tunsigned int\t\tnumber;\n\tunsigned char\t\tfailed;\n\trefcount_t\t\trefcount;\n};\n\nstruct nr_route {\n\tunsigned char   quality;\n\tunsigned char   obs_count;\n\tstruct nr_neigh *neighbour;\n};\n\nstruct nr_node {\n\tstruct hlist_node\tnode_node;\n\tax25_address\t\tcallsign;\n\tchar\t\t\tmnemonic[7];\n\tunsigned char\t\twhich;\n\tunsigned char\t\tcount;\n\tstruct nr_route\t\troutes[3];\n\trefcount_t\t\trefcount;\n\tspinlock_t\t\tnode_lock;\n};\n\n \n\n#define nr_node_hold(__nr_node) \\\n\trefcount_inc(&((__nr_node)->refcount))\n\nstatic __inline__ void nr_node_put(struct nr_node *nr_node)\n{\n\tif (refcount_dec_and_test(&nr_node->refcount)) {\n\t\tkfree(nr_node);\n\t}\n}\n\n#define nr_neigh_hold(__nr_neigh) \\\n\trefcount_inc(&((__nr_neigh)->refcount))\n\nstatic __inline__ void nr_neigh_put(struct nr_neigh *nr_neigh)\n{\n\tif (refcount_dec_and_test(&nr_neigh->refcount)) {\n\t\tif (nr_neigh->ax25)\n\t\t\tax25_cb_put(nr_neigh->ax25);\n\t\tkfree(nr_neigh->digipeat);\n\t\tkfree(nr_neigh);\n\t}\n}\n\n \nstatic __inline__ void nr_node_lock(struct nr_node *nr_node)\n{\n\tnr_node_hold(nr_node);\n\tspin_lock_bh(&nr_node->node_lock);\n}\n\nstatic __inline__ void nr_node_unlock(struct nr_node *nr_node)\n{\n\tspin_unlock_bh(&nr_node->node_lock);\n\tnr_node_put(nr_node);\n}\n\n#define nr_neigh_for_each(__nr_neigh, list) \\\n\thlist_for_each_entry(__nr_neigh, list, neigh_node)\n\n#define nr_neigh_for_each_safe(__nr_neigh, node2, list) \\\n\thlist_for_each_entry_safe(__nr_neigh, node2, list, neigh_node)\n\n#define nr_node_for_each(__nr_node, list) \\\n\thlist_for_each_entry(__nr_node, list, node_node)\n\n#define nr_node_for_each_safe(__nr_node, node2, list) \\\n\thlist_for_each_entry_safe(__nr_node, node2, list, node_node)\n\n\n \n\n \nextern int  sysctl_netrom_default_path_quality;\nextern int  sysctl_netrom_obsolescence_count_initialiser;\nextern int  sysctl_netrom_network_ttl_initialiser;\nextern int  sysctl_netrom_transport_timeout;\nextern int  sysctl_netrom_transport_maximum_tries;\nextern int  sysctl_netrom_transport_acknowledge_delay;\nextern int  sysctl_netrom_transport_busy_delay;\nextern int  sysctl_netrom_transport_requested_window_size;\nextern int  sysctl_netrom_transport_no_activity_timeout;\nextern int  sysctl_netrom_routing_control;\nextern int  sysctl_netrom_link_fails_count;\nextern int  sysctl_netrom_reset_circuit;\n\nint nr_rx_frame(struct sk_buff *, struct net_device *);\nvoid nr_destroy_socket(struct sock *);\n\n \nint nr_rx_ip(struct sk_buff *, struct net_device *);\nvoid nr_setup(struct net_device *);\n\n \nint nr_process_rx_frame(struct sock *, struct sk_buff *);\n\n \nvoid nr_loopback_init(void);\nvoid nr_loopback_clear(void);\nint nr_loopback_queue(struct sk_buff *);\n\n \nvoid nr_output(struct sock *, struct sk_buff *);\nvoid nr_send_nak_frame(struct sock *);\nvoid nr_kick(struct sock *);\nvoid nr_transmit_buffer(struct sock *, struct sk_buff *);\nvoid nr_establish_data_link(struct sock *);\nvoid nr_enquiry_response(struct sock *);\nvoid nr_check_iframes_acked(struct sock *, unsigned short);\n\n \nvoid nr_rt_device_down(struct net_device *);\nstruct net_device *nr_dev_first(void);\nstruct net_device *nr_dev_get(ax25_address *);\nint nr_rt_ioctl(unsigned int, void __user *);\nvoid nr_link_failed(ax25_cb *, int);\nint nr_route_frame(struct sk_buff *, ax25_cb *);\nextern const struct seq_operations nr_node_seqops;\nextern const struct seq_operations nr_neigh_seqops;\nvoid nr_rt_free(void);\n\n \nvoid nr_clear_queues(struct sock *);\nvoid nr_frames_acked(struct sock *, unsigned short);\nvoid nr_requeue_frames(struct sock *);\nint nr_validate_nr(struct sock *, unsigned short);\nint nr_in_rx_window(struct sock *, unsigned short);\nvoid nr_write_internal(struct sock *, int);\n\nvoid __nr_transmit_reply(struct sk_buff *skb, int mine, unsigned char cmdflags);\n\n \n#define nr_transmit_refusal(skb, mine)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t__nr_transmit_reply((skb), (mine), NR_CONNACK | NR_CHOKE_FLAG);\t\\\n} while (0)\n\n \n#define nr_transmit_reset(skb, mine)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t__nr_transmit_reply((skb), (mine), NR_RESET);\t\t\t\\\n} while (0)\n\nvoid nr_disconnect(struct sock *, int);\n\n \nvoid nr_init_timers(struct sock *sk);\nvoid nr_start_heartbeat(struct sock *);\nvoid nr_start_t1timer(struct sock *);\nvoid nr_start_t2timer(struct sock *);\nvoid nr_start_t4timer(struct sock *);\nvoid nr_start_idletimer(struct sock *);\nvoid nr_stop_heartbeat(struct sock *);\nvoid nr_stop_t1timer(struct sock *);\nvoid nr_stop_t2timer(struct sock *);\nvoid nr_stop_t4timer(struct sock *);\nvoid nr_stop_idletimer(struct sock *);\nint nr_t1timer_running(struct sock *);\n\n \nint nr_register_sysctl(void);\nvoid nr_unregister_sysctl(void);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}