{
  "module_name": "6lowpan.h",
  "hash_id": "37655e25a8f38ac42bf3f26af228a839aef92eb42ff35e08f6c7ffda8336ceef",
  "original_prompt": "Ingested from linux-6.6.14/include/net/6lowpan.h",
  "human_readable_source": " \n\n \n\n \n\n#ifndef __6LOWPAN_H__\n#define __6LOWPAN_H__\n\n#include <linux/debugfs.h>\n\n#include <net/ipv6.h>\n#include <net/net_namespace.h>\n\n \n#include <net/mac802154.h>\n\n#define EUI64_ADDR_LEN\t\t8\n\n#define LOWPAN_NHC_MAX_ID_LEN\t1\n \n#define LOWPAN_NHC_MAX_HDR_LEN\t(sizeof(struct udphdr))\n \n#define LOWPAN_IPHC_MAX_HEADER_LEN\t(2 + 1 + LOWPAN_NHC_MAX_ID_LEN)\n \n#define LOWPAN_IPHC_MAX_HC_BUF_LEN\t(sizeof(struct ipv6hdr) +\t\\\n\t\t\t\t\t LOWPAN_IPHC_MAX_HEADER_LEN +\t\\\n\t\t\t\t\t LOWPAN_NHC_MAX_HDR_LEN)\n \n#define LOWPAN_IPHC_CTX_TABLE_SIZE\t(1 << 4)\n\n#define LOWPAN_DISPATCH_IPV6\t\t0x41  \n#define LOWPAN_DISPATCH_IPHC\t\t0x60  \n#define LOWPAN_DISPATCH_IPHC_MASK\t0xe0\n\nstatic inline bool lowpan_is_ipv6(u8 dispatch)\n{\n\treturn dispatch == LOWPAN_DISPATCH_IPV6;\n}\n\nstatic inline bool lowpan_is_iphc(u8 dispatch)\n{\n\treturn (dispatch & LOWPAN_DISPATCH_IPHC_MASK) == LOWPAN_DISPATCH_IPHC;\n}\n\n#define LOWPAN_PRIV_SIZE(llpriv_size)\t\\\n\t(sizeof(struct lowpan_dev) + llpriv_size)\n\nenum lowpan_lltypes {\n\tLOWPAN_LLTYPE_BTLE,\n\tLOWPAN_LLTYPE_IEEE802154,\n};\n\nenum lowpan_iphc_ctx_flags {\n\tLOWPAN_IPHC_CTX_FLAG_ACTIVE,\n\tLOWPAN_IPHC_CTX_FLAG_COMPRESSION,\n};\n\nstruct lowpan_iphc_ctx {\n\tu8 id;\n\tstruct in6_addr pfx;\n\tu8 plen;\n\tunsigned long flags;\n};\n\nstruct lowpan_iphc_ctx_table {\n\tspinlock_t lock;\n\tconst struct lowpan_iphc_ctx_ops *ops;\n\tstruct lowpan_iphc_ctx table[LOWPAN_IPHC_CTX_TABLE_SIZE];\n};\n\nstatic inline bool lowpan_iphc_ctx_is_active(const struct lowpan_iphc_ctx *ctx)\n{\n\treturn test_bit(LOWPAN_IPHC_CTX_FLAG_ACTIVE, &ctx->flags);\n}\n\nstatic inline bool\nlowpan_iphc_ctx_is_compression(const struct lowpan_iphc_ctx *ctx)\n{\n\treturn test_bit(LOWPAN_IPHC_CTX_FLAG_COMPRESSION, &ctx->flags);\n}\n\nstruct lowpan_dev {\n\tenum lowpan_lltypes lltype;\n\tstruct dentry *iface_debugfs;\n\tstruct lowpan_iphc_ctx_table ctx;\n\n\t \n\tu8 priv[] __aligned(sizeof(void *));\n};\n\nstruct lowpan_802154_neigh {\n\t__le16 short_addr;\n};\n\nstatic inline\nstruct lowpan_802154_neigh *lowpan_802154_neigh(void *neigh_priv)\n{\n\treturn neigh_priv;\n}\n\nstatic inline\nstruct lowpan_dev *lowpan_dev(const struct net_device *dev)\n{\n\treturn netdev_priv(dev);\n}\n\n \nstruct lowpan_802154_dev {\n\tstruct net_device\t*wdev;  \n\tu16\t\t\tfragment_tag;\n};\n\nstatic inline struct\nlowpan_802154_dev *lowpan_802154_dev(const struct net_device *dev)\n{\n\treturn (struct lowpan_802154_dev *)lowpan_dev(dev)->priv;\n}\n\nstruct lowpan_802154_cb {\n\tu16 d_tag;\n\tunsigned int d_size;\n\tu8 d_offset;\n};\n\nstatic inline\nstruct lowpan_802154_cb *lowpan_802154_cb(const struct sk_buff *skb)\n{\n\tBUILD_BUG_ON(sizeof(struct lowpan_802154_cb) > sizeof(skb->cb));\n\treturn (struct lowpan_802154_cb *)skb->cb;\n}\n\nstatic inline void lowpan_iphc_uncompress_eui64_lladdr(struct in6_addr *ipaddr,\n\t\t\t\t\t\t       const void *lladdr)\n{\n\t \n\tipaddr->s6_addr[0] = 0xFE;\n\tipaddr->s6_addr[1] = 0x80;\n\tmemcpy(&ipaddr->s6_addr[8], lladdr, EUI64_ADDR_LEN);\n\t \n\tipaddr->s6_addr[8] ^= 0x02;\n}\n\nstatic inline void lowpan_iphc_uncompress_eui48_lladdr(struct in6_addr *ipaddr,\n\t\t\t\t\t\t       const void *lladdr)\n{\n\t \n\tipaddr->s6_addr[0] = 0xFE;\n\tipaddr->s6_addr[1] = 0x80;\n\tmemcpy(&ipaddr->s6_addr[8], lladdr, 3);\n\tipaddr->s6_addr[11] = 0xFF;\n\tipaddr->s6_addr[12] = 0xFE;\n\tmemcpy(&ipaddr->s6_addr[13], lladdr + 3, 3);\n}\n\n#ifdef DEBUG\n \nstatic inline void raw_dump_inline(const char *caller, char *msg,\n\t\t\t\t   const unsigned char *buf, int len)\n{\n\tif (msg)\n\t\tpr_debug(\"%s():%s: \", caller, msg);\n\n\tprint_hex_dump_debug(\"\", DUMP_PREFIX_NONE, 16, 1, buf, len, false);\n}\n\n \nstatic inline void raw_dump_table(const char *caller, char *msg,\n\t\t\t\t  const unsigned char *buf, int len)\n{\n\tif (msg)\n\t\tpr_debug(\"%s():%s:\\n\", caller, msg);\n\n\tprint_hex_dump_debug(\"\\t\", DUMP_PREFIX_OFFSET, 16, 1, buf, len, false);\n}\n#else\nstatic inline void raw_dump_table(const char *caller, char *msg,\n\t\t\t\t  const unsigned char *buf, int len) { }\nstatic inline void raw_dump_inline(const char *caller, char *msg,\n\t\t\t\t   const unsigned char *buf, int len) { }\n#endif\n\n \nstatic inline bool lowpan_fetch_skb(struct sk_buff *skb, void *data,\n\t\t\t\t    unsigned int len)\n{\n\tif (unlikely(!pskb_may_pull(skb, len)))\n\t\treturn true;\n\n\tskb_copy_from_linear_data(skb, data, len);\n\tskb_pull(skb, len);\n\n\treturn false;\n}\n\nstatic inline bool lowpan_802154_is_valid_src_short_addr(__le16 addr)\n{\n\t \n\treturn !(addr & cpu_to_le16(0x8000));\n}\n\nstatic inline void lowpan_push_hc_data(u8 **hc_ptr, const void *data,\n\t\t\t\t       const size_t len)\n{\n\tmemcpy(*hc_ptr, data, len);\n\t*hc_ptr += len;\n}\n\nint lowpan_register_netdevice(struct net_device *dev,\n\t\t\t      enum lowpan_lltypes lltype);\nint lowpan_register_netdev(struct net_device *dev,\n\t\t\t   enum lowpan_lltypes lltype);\nvoid lowpan_unregister_netdevice(struct net_device *dev);\nvoid lowpan_unregister_netdev(struct net_device *dev);\n\n \nint lowpan_header_decompress(struct sk_buff *skb, const struct net_device *dev,\n\t\t\t     const void *daddr, const void *saddr);\n\n \nint lowpan_header_compress(struct sk_buff *skb, const struct net_device *dev,\n\t\t\t   const void *daddr, const void *saddr);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}