{
  "module_name": "gre.h",
  "hash_id": "5bf8d86d0743f3853d19280fc61598464245fce19721557cb027535c39e758ac",
  "original_prompt": "Ingested from linux-6.6.14/include/net/gre.h",
  "human_readable_source": " \n#ifndef __LINUX_GRE_H\n#define __LINUX_GRE_H\n\n#include <linux/skbuff.h>\n#include <net/ip_tunnels.h>\n\nstruct gre_base_hdr {\n\t__be16 flags;\n\t__be16 protocol;\n} __packed;\n\nstruct gre_full_hdr {\n\tstruct gre_base_hdr fixed_header;\n\t__be16 csum;\n\t__be16 reserved1;\n\t__be32 key;\n\t__be32 seq;\n} __packed;\n#define GRE_HEADER_SECTION 4\n\n#define GREPROTO_CISCO\t\t0\n#define GREPROTO_PPTP\t\t1\n#define GREPROTO_MAX\t\t2\n#define GRE_IP_PROTO_MAX\t2\n\nstruct gre_protocol {\n\tint  (*handler)(struct sk_buff *skb);\n\tvoid (*err_handler)(struct sk_buff *skb, u32 info);\n};\n\nint gre_add_protocol(const struct gre_protocol *proto, u8 version);\nint gre_del_protocol(const struct gre_protocol *proto, u8 version);\n\nstruct net_device *gretap_fb_dev_create(struct net *net, const char *name,\n\t\t\t\t       u8 name_assign_type);\nint gre_parse_header(struct sk_buff *skb, struct tnl_ptk_info *tpi,\n\t\t     bool *csum_err, __be16 proto, int nhs);\n\nstatic inline bool netif_is_gretap(const struct net_device *dev)\n{\n\treturn dev->rtnl_link_ops &&\n\t       !strcmp(dev->rtnl_link_ops->kind, \"gretap\");\n}\n\nstatic inline bool netif_is_ip6gretap(const struct net_device *dev)\n{\n\treturn dev->rtnl_link_ops &&\n\t       !strcmp(dev->rtnl_link_ops->kind, \"ip6gretap\");\n}\n\nstatic inline int gre_calc_hlen(__be16 o_flags)\n{\n\tint addend = 4;\n\n\tif (o_flags & TUNNEL_CSUM)\n\t\taddend += 4;\n\tif (o_flags & TUNNEL_KEY)\n\t\taddend += 4;\n\tif (o_flags & TUNNEL_SEQ)\n\t\taddend += 4;\n\treturn addend;\n}\n\nstatic inline __be16 gre_flags_to_tnl_flags(__be16 flags)\n{\n\t__be16 tflags = 0;\n\n\tif (flags & GRE_CSUM)\n\t\ttflags |= TUNNEL_CSUM;\n\tif (flags & GRE_ROUTING)\n\t\ttflags |= TUNNEL_ROUTING;\n\tif (flags & GRE_KEY)\n\t\ttflags |= TUNNEL_KEY;\n\tif (flags & GRE_SEQ)\n\t\ttflags |= TUNNEL_SEQ;\n\tif (flags & GRE_STRICT)\n\t\ttflags |= TUNNEL_STRICT;\n\tif (flags & GRE_REC)\n\t\ttflags |= TUNNEL_REC;\n\tif (flags & GRE_VERSION)\n\t\ttflags |= TUNNEL_VERSION;\n\n\treturn tflags;\n}\n\nstatic inline __be16 gre_tnl_flags_to_gre_flags(__be16 tflags)\n{\n\t__be16 flags = 0;\n\n\tif (tflags & TUNNEL_CSUM)\n\t\tflags |= GRE_CSUM;\n\tif (tflags & TUNNEL_ROUTING)\n\t\tflags |= GRE_ROUTING;\n\tif (tflags & TUNNEL_KEY)\n\t\tflags |= GRE_KEY;\n\tif (tflags & TUNNEL_SEQ)\n\t\tflags |= GRE_SEQ;\n\tif (tflags & TUNNEL_STRICT)\n\t\tflags |= GRE_STRICT;\n\tif (tflags & TUNNEL_REC)\n\t\tflags |= GRE_REC;\n\tif (tflags & TUNNEL_VERSION)\n\t\tflags |= GRE_VERSION;\n\n\treturn flags;\n}\n\nstatic inline void gre_build_header(struct sk_buff *skb, int hdr_len,\n\t\t\t\t    __be16 flags, __be16 proto,\n\t\t\t\t    __be32 key, __be32 seq)\n{\n\tstruct gre_base_hdr *greh;\n\n\tskb_push(skb, hdr_len);\n\n\tskb_set_inner_protocol(skb, proto);\n\tskb_reset_transport_header(skb);\n\tgreh = (struct gre_base_hdr *)skb->data;\n\tgreh->flags = gre_tnl_flags_to_gre_flags(flags);\n\tgreh->protocol = proto;\n\n\tif (flags & (TUNNEL_KEY | TUNNEL_CSUM | TUNNEL_SEQ)) {\n\t\t__be32 *ptr = (__be32 *)(((u8 *)greh) + hdr_len - 4);\n\n\t\tif (flags & TUNNEL_SEQ) {\n\t\t\t*ptr = seq;\n\t\t\tptr--;\n\t\t}\n\t\tif (flags & TUNNEL_KEY) {\n\t\t\t*ptr = key;\n\t\t\tptr--;\n\t\t}\n\t\tif (flags & TUNNEL_CSUM &&\n\t\t    !(skb_shinfo(skb)->gso_type &\n\t\t      (SKB_GSO_GRE | SKB_GSO_GRE_CSUM))) {\n\t\t\t*ptr = 0;\n\t\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\t\t*(__sum16 *)ptr = csum_fold(lco_csum(skb));\n\t\t\t} else {\n\t\t\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\t\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\t\t\tskb->csum_offset = sizeof(*greh);\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}