{
  "module_name": "tc_ct.h",
  "hash_id": "1bf97a00a222459525b63b91c46ae44a33121f141e1ea00d7223687d8c23f1dd",
  "original_prompt": "Ingested from linux-6.6.14/include/net/tc_act/tc_ct.h",
  "human_readable_source": " \n#ifndef __NET_TC_CT_H\n#define __NET_TC_CT_H\n\n#include <net/act_api.h>\n#include <uapi/linux/tc_act/tc_ct.h>\n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_conntrack_labels.h>\n\nstruct tcf_ct_params {\n\tstruct nf_conntrack_helper *helper;\n\tstruct nf_conn *tmpl;\n\tu16 zone;\n\n\tu32 mark;\n\tu32 mark_mask;\n\n\tu32 labels[NF_CT_LABELS_MAX_SIZE / sizeof(u32)];\n\tu32 labels_mask[NF_CT_LABELS_MAX_SIZE / sizeof(u32)];\n\n\tstruct nf_nat_range2 range;\n\tbool ipv4_range;\n\n\tu16 ct_action;\n\n\tstruct rcu_head rcu;\n\n\tstruct tcf_ct_flow_table *ct_ft;\n\tstruct nf_flowtable *nf_ft;\n};\n\nstruct tcf_ct {\n\tstruct tc_action common;\n\tstruct tcf_ct_params __rcu *params;\n};\n\n#define to_ct(a) ((struct tcf_ct *)a)\n#define to_ct_params(a)\t\t\t\t\t\t\t\\\n\t((struct tcf_ct_params *)\t\t\t\t\t\\\n\t rcu_dereference_protected(to_ct(a)->params,\t\t\t\\\n\t\t\t\t   lockdep_is_held(&a->tcfa_lock)))\n\nstatic inline uint16_t tcf_ct_zone(const struct tc_action *a)\n{\n\treturn to_ct_params(a)->zone;\n}\n\nstatic inline int tcf_ct_action(const struct tc_action *a)\n{\n\treturn to_ct_params(a)->ct_action;\n}\n\nstatic inline struct nf_flowtable *tcf_ct_ft(const struct tc_action *a)\n{\n\treturn to_ct_params(a)->nf_ft;\n}\n\nstatic inline struct nf_conntrack_helper *tcf_ct_helper(const struct tc_action *a)\n{\n\treturn to_ct_params(a)->helper;\n}\n\n#else\nstatic inline uint16_t tcf_ct_zone(const struct tc_action *a) { return 0; }\nstatic inline int tcf_ct_action(const struct tc_action *a) { return 0; }\nstatic inline struct nf_flowtable *tcf_ct_ft(const struct tc_action *a)\n{\n\treturn NULL;\n}\nstatic inline struct nf_conntrack_helper *tcf_ct_helper(const struct tc_action *a)\n{\n\treturn NULL;\n}\n#endif  \n\n#if IS_ENABLED(CONFIG_NET_ACT_CT)\nstatic inline void\ntcf_ct_flow_table_restore_skb(struct sk_buff *skb, unsigned long cookie)\n{\n\tenum ip_conntrack_info ctinfo = cookie & NFCT_INFOMASK;\n\tstruct nf_conn *ct;\n\n\tct = (struct nf_conn *)(cookie & NFCT_PTRMASK);\n\tnf_conntrack_get(&ct->ct_general);\n\tnf_ct_set(skb, ct, ctinfo);\n}\n#else\nstatic inline void\ntcf_ct_flow_table_restore_skb(struct sk_buff *skb, unsigned long cookie) { }\n#endif\n\nstatic inline bool is_tcf_ct(const struct tc_action *a)\n{\n#if defined(CONFIG_NET_CLS_ACT) && IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (a->ops && a->ops->id == TCA_ID_CT)\n\t\treturn true;\n#endif\n\treturn false;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}