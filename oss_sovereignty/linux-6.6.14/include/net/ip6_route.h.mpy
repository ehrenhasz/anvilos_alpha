{
  "module_name": "ip6_route.h",
  "hash_id": "5db711a3e50ced3aa7a14f28e47ea7c258661e688d785f79fc8a5a360a3cdb4a",
  "original_prompt": "Ingested from linux-6.6.14/include/net/ip6_route.h",
  "human_readable_source": " \n#ifndef _NET_IP6_ROUTE_H\n#define _NET_IP6_ROUTE_H\n\n#include <net/addrconf.h>\n#include <net/flow.h>\n#include <net/ip6_fib.h>\n#include <net/sock.h>\n#include <net/lwtunnel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/route.h>\n#include <net/nexthop.h>\n\nstruct route_info {\n\t__u8\t\t\ttype;\n\t__u8\t\t\tlength;\n\t__u8\t\t\tprefix_len;\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t__u8\t\t\treserved_h:3,\n\t\t\t\troute_pref:2,\n\t\t\t\treserved_l:3;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\t__u8\t\t\treserved_l:3,\n\t\t\t\troute_pref:2,\n\t\t\t\treserved_h:3;\n#endif\n\t__be32\t\t\tlifetime;\n\t__u8\t\t\tprefix[];\t \n};\n\n#define RT6_LOOKUP_F_IFACE\t\t0x00000001\n#define RT6_LOOKUP_F_REACHABLE\t\t0x00000002\n#define RT6_LOOKUP_F_HAS_SADDR\t\t0x00000004\n#define RT6_LOOKUP_F_SRCPREF_TMP\t0x00000008\n#define RT6_LOOKUP_F_SRCPREF_PUBLIC\t0x00000010\n#define RT6_LOOKUP_F_SRCPREF_COA\t0x00000020\n#define RT6_LOOKUP_F_IGNORE_LINKSTATE\t0x00000040\n#define RT6_LOOKUP_F_DST_NOREF\t\t0x00000080\n\n \n#define IP6_MAX_MTU (0xFFFF + sizeof(struct ipv6hdr))\n\n \nstatic inline int rt6_srcprefs2flags(unsigned int srcprefs)\n{\n\t \n\treturn srcprefs << 3;\n}\n\nstatic inline unsigned int rt6_flags2srcprefs(int flags)\n{\n\treturn (flags >> 3) & 7;\n}\n\nstatic inline bool rt6_need_strict(const struct in6_addr *daddr)\n{\n\treturn ipv6_addr_type(daddr) &\n\t\t(IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL | IPV6_ADDR_LOOPBACK);\n}\n\n \nstatic inline bool rt6_qualify_for_ecmp(const struct fib6_info *f6i)\n{\n\t \n\treturn !(f6i->fib6_flags & RTF_ADDRCONF) && !f6i->nh &&\n\t\tf6i->fib6_nh->fib_nh_gw_family;\n}\n\nvoid ip6_route_input(struct sk_buff *skb);\nstruct dst_entry *ip6_route_input_lookup(struct net *net,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t struct flowi6 *fl6,\n\t\t\t\t\t const struct sk_buff *skb, int flags);\n\nstruct dst_entry *ip6_route_output_flags(struct net *net, const struct sock *sk,\n\t\t\t\t\t struct flowi6 *fl6, int flags);\n\nstatic inline struct dst_entry *ip6_route_output(struct net *net,\n\t\t\t\t\t\t const struct sock *sk,\n\t\t\t\t\t\t struct flowi6 *fl6)\n{\n\treturn ip6_route_output_flags(net, sk, fl6, 0);\n}\n\n \nstatic inline void ip6_rt_put_flags(struct rt6_info *rt, int flags)\n{\n\tif (!(flags & RT6_LOOKUP_F_DST_NOREF) ||\n\t    !list_empty(&rt->dst.rt_uncached))\n\t\tip6_rt_put(rt);\n}\n\nstruct dst_entry *ip6_route_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb, int flags);\nstruct rt6_info *ip6_pol_route(struct net *net, struct fib6_table *table,\n\t\t\t       int ifindex, struct flowi6 *fl6,\n\t\t\t       const struct sk_buff *skb, int flags);\n\nvoid ip6_route_init_special_entries(void);\nint ip6_route_init(void);\nvoid ip6_route_cleanup(void);\n\nint ipv6_route_ioctl(struct net *net, unsigned int cmd,\n\t\tstruct in6_rtmsg *rtmsg);\n\nint ip6_route_add(struct fib6_config *cfg, gfp_t gfp_flags,\n\t\t  struct netlink_ext_ack *extack);\nint ip6_ins_rt(struct net *net, struct fib6_info *f6i);\nint ip6_del_rt(struct net *net, struct fib6_info *f6i, bool skip_notify);\n\nvoid rt6_flush_exceptions(struct fib6_info *f6i);\nvoid rt6_age_exceptions(struct fib6_info *f6i, struct fib6_gc_args *gc_args,\n\t\t\tunsigned long now);\n\nstatic inline int ip6_route_get_saddr(struct net *net, struct fib6_info *f6i,\n\t\t\t\t      const struct in6_addr *daddr,\n\t\t\t\t      unsigned int prefs,\n\t\t\t\t      struct in6_addr *saddr)\n{\n\tint err = 0;\n\n\tif (f6i && f6i->fib6_prefsrc.plen) {\n\t\t*saddr = f6i->fib6_prefsrc.addr;\n\t} else {\n\t\tstruct net_device *dev = f6i ? fib6_info_nh_dev(f6i) : NULL;\n\n\t\terr = ipv6_dev_get_saddr(net, dev, daddr, prefs, saddr);\n\t}\n\n\treturn err;\n}\n\nstruct rt6_info *rt6_lookup(struct net *net, const struct in6_addr *daddr,\n\t\t\t    const struct in6_addr *saddr, int oif,\n\t\t\t    const struct sk_buff *skb, int flags);\nu32 rt6_multipath_hash(const struct net *net, const struct flowi6 *fl6,\n\t\t       const struct sk_buff *skb, struct flow_keys *hkeys);\n\nstruct dst_entry *icmp6_dst_alloc(struct net_device *dev, struct flowi6 *fl6);\n\nvoid fib6_force_start_gc(struct net *net);\n\nstruct fib6_info *addrconf_f6i_alloc(struct net *net, struct inet6_dev *idev,\n\t\t\t\t     const struct in6_addr *addr, bool anycast,\n\t\t\t\t     gfp_t gfp_flags, struct netlink_ext_ack *extack);\n\nstruct rt6_info *ip6_dst_alloc(struct net *net, struct net_device *dev,\n\t\t\t       int flags);\n\n \nstruct fib6_info *rt6_get_dflt_router(struct net *net,\n\t\t\t\t     const struct in6_addr *addr,\n\t\t\t\t     struct net_device *dev);\nstruct fib6_info *rt6_add_dflt_router(struct net *net,\n\t\t\t\t     const struct in6_addr *gwaddr,\n\t\t\t\t     struct net_device *dev, unsigned int pref,\n\t\t\t\t     u32 defrtr_usr_metric);\n\nvoid rt6_purge_dflt_routers(struct net *net);\n\nint rt6_route_rcv(struct net_device *dev, u8 *opt, int len,\n\t\t  const struct in6_addr *gwaddr);\n\nvoid ip6_update_pmtu(struct sk_buff *skb, struct net *net, __be32 mtu, int oif,\n\t\t     u32 mark, kuid_t uid);\nvoid ip6_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, __be32 mtu);\nvoid ip6_redirect(struct sk_buff *skb, struct net *net, int oif, u32 mark,\n\t\t  kuid_t uid);\nvoid ip6_redirect_no_header(struct sk_buff *skb, struct net *net, int oif);\nvoid ip6_sk_redirect(struct sk_buff *skb, struct sock *sk);\n\nstruct netlink_callback;\n\nstruct rt6_rtnl_dump_arg {\n\tstruct sk_buff *skb;\n\tstruct netlink_callback *cb;\n\tstruct net *net;\n\tstruct fib_dump_filter filter;\n};\n\nint rt6_dump_route(struct fib6_info *f6i, void *p_arg, unsigned int skip);\nvoid rt6_mtu_change(struct net_device *dev, unsigned int mtu);\nvoid rt6_remove_prefsrc(struct inet6_ifaddr *ifp);\nvoid rt6_clean_tohost(struct net *net, struct in6_addr *gateway);\nvoid rt6_sync_up(struct net_device *dev, unsigned char nh_flags);\nvoid rt6_disable_ip(struct net_device *dev, unsigned long event);\nvoid rt6_sync_down_dev(struct net_device *dev, unsigned long event);\nvoid rt6_multipath_rebalance(struct fib6_info *f6i);\n\nvoid rt6_uncached_list_add(struct rt6_info *rt);\nvoid rt6_uncached_list_del(struct rt6_info *rt);\n\nstatic inline const struct rt6_info *skb_rt6_info(const struct sk_buff *skb)\n{\n\tconst struct dst_entry *dst = skb_dst(skb);\n\tconst struct rt6_info *rt6 = NULL;\n\n\tif (dst)\n\t\trt6 = container_of(dst, struct rt6_info, dst);\n\n\treturn rt6;\n}\n\n \nstatic inline void ip6_dst_store(struct sock *sk, struct dst_entry *dst,\n\t\t\t\t const struct in6_addr *daddr,\n\t\t\t\t const struct in6_addr *saddr)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\tnp->dst_cookie = rt6_get_cookie((struct rt6_info *)dst);\n\tsk_setup_caps(sk, dst);\n\tnp->daddr_cache = daddr;\n#ifdef CONFIG_IPV6_SUBTREES\n\tnp->saddr_cache = saddr;\n#endif\n}\n\nvoid ip6_sk_dst_store_flow(struct sock *sk, struct dst_entry *dst,\n\t\t\t   const struct flowi6 *fl6);\n\nstatic inline bool ipv6_unicast_destination(const struct sk_buff *skb)\n{\n\tstruct rt6_info *rt = (struct rt6_info *) skb_dst(skb);\n\n\treturn rt->rt6i_flags & RTF_LOCAL;\n}\n\nstatic inline bool ipv6_anycast_destination(const struct dst_entry *dst,\n\t\t\t\t\t    const struct in6_addr *daddr)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\n\treturn rt->rt6i_flags & RTF_ANYCAST ||\n\t\t(rt->rt6i_dst.plen < 127 &&\n\t\t !(rt->rt6i_flags & (RTF_GATEWAY | RTF_NONEXTHOP)) &&\n\t\t ipv6_addr_equal(&rt->rt6i_dst.addr, daddr));\n}\n\nint ip6_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,\n\t\t int (*output)(struct net *, struct sock *, struct sk_buff *));\n\nstatic inline unsigned int ip6_skb_dst_mtu(const struct sk_buff *skb)\n{\n\tconst struct ipv6_pinfo *np = skb->sk && !dev_recursion_level() ?\n\t\t\t\tinet6_sk(skb->sk) : NULL;\n\tconst struct dst_entry *dst = skb_dst(skb);\n\tunsigned int mtu;\n\n\tif (np && np->pmtudisc >= IPV6_PMTUDISC_PROBE) {\n\t\tmtu = READ_ONCE(dst->dev->mtu);\n\t\tmtu -= lwtunnel_headroom(dst->lwtstate, mtu);\n\t} else {\n\t\tmtu = dst_mtu(dst);\n\t}\n\treturn mtu;\n}\n\nstatic inline bool ip6_sk_accept_pmtu(const struct sock *sk)\n{\n\treturn inet6_sk(sk)->pmtudisc != IPV6_PMTUDISC_INTERFACE &&\n\t       inet6_sk(sk)->pmtudisc != IPV6_PMTUDISC_OMIT;\n}\n\nstatic inline bool ip6_sk_ignore_df(const struct sock *sk)\n{\n\treturn inet6_sk(sk)->pmtudisc < IPV6_PMTUDISC_DO ||\n\t       inet6_sk(sk)->pmtudisc == IPV6_PMTUDISC_OMIT;\n}\n\nstatic inline const struct in6_addr *rt6_nexthop(const struct rt6_info *rt,\n\t\t\t\t\t\t const struct in6_addr *daddr)\n{\n\tif (rt->rt6i_flags & RTF_GATEWAY)\n\t\treturn &rt->rt6i_gateway;\n\telse if (unlikely(rt->rt6i_flags & RTF_CACHE))\n\t\treturn &rt->rt6i_dst.addr;\n\telse\n\t\treturn daddr;\n}\n\nstatic inline bool rt6_duplicate_nexthop(struct fib6_info *a, struct fib6_info *b)\n{\n\tstruct fib6_nh *nha, *nhb;\n\n\tif (a->nh || b->nh)\n\t\treturn nexthop_cmp(a->nh, b->nh);\n\n\tnha = a->fib6_nh;\n\tnhb = b->fib6_nh;\n\treturn nha->fib_nh_dev == nhb->fib_nh_dev &&\n\t       ipv6_addr_equal(&nha->fib_nh_gw6, &nhb->fib_nh_gw6) &&\n\t       !lwtunnel_cmp_encap(nha->fib_nh_lws, nhb->fib_nh_lws);\n}\n\nstatic inline unsigned int ip6_dst_mtu_maybe_forward(const struct dst_entry *dst,\n\t\t\t\t\t\t     bool forwarding)\n{\n\tstruct inet6_dev *idev;\n\tunsigned int mtu;\n\n\tif (!forwarding || dst_metric_locked(dst, RTAX_MTU)) {\n\t\tmtu = dst_metric_raw(dst, RTAX_MTU);\n\t\tif (mtu)\n\t\t\tgoto out;\n\t}\n\n\tmtu = IPV6_MIN_MTU;\n\trcu_read_lock();\n\tidev = __in6_dev_get(dst->dev);\n\tif (idev)\n\t\tmtu = idev->cnf.mtu6;\n\trcu_read_unlock();\n\nout:\n\treturn mtu - lwtunnel_headroom(dst->lwtstate, mtu);\n}\n\nu32 ip6_mtu_from_fib6(const struct fib6_result *res,\n\t\t      const struct in6_addr *daddr,\n\t\t      const struct in6_addr *saddr);\n\nstruct neighbour *ip6_neigh_lookup(const struct in6_addr *gw,\n\t\t\t\t   struct net_device *dev, struct sk_buff *skb,\n\t\t\t\t   const void *daddr);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}