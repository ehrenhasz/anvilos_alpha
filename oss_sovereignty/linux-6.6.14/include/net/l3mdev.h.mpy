{
  "module_name": "l3mdev.h",
  "hash_id": "33115bb23267e205f5bdcb4c2c373842492c64fedbfa3869edb1417aadaf6cf2",
  "original_prompt": "Ingested from linux-6.6.14/include/net/l3mdev.h",
  "human_readable_source": " \n \n#ifndef _NET_L3MDEV_H_\n#define _NET_L3MDEV_H_\n\n#include <net/dst.h>\n#include <net/fib_rules.h>\n\nenum l3mdev_type {\n\tL3MDEV_TYPE_UNSPEC,\n\tL3MDEV_TYPE_VRF,\n\t__L3MDEV_TYPE_MAX\n};\n\n#define L3MDEV_TYPE_MAX (__L3MDEV_TYPE_MAX - 1)\n\ntypedef int (*lookup_by_table_id_t)(struct net *net, u32 table_d);\n\n \n\nstruct l3mdev_ops {\n\tu32\t\t(*l3mdev_fib_table)(const struct net_device *dev);\n\tstruct sk_buff * (*l3mdev_l3_rcv)(struct net_device *dev,\n\t\t\t\t\t  struct sk_buff *skb, u16 proto);\n\tstruct sk_buff * (*l3mdev_l3_out)(struct net_device *dev,\n\t\t\t\t\t  struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  u16 proto);\n\n\t \n\tstruct dst_entry * (*l3mdev_link_scope_lookup)(const struct net_device *dev,\n\t\t\t\t\t\t struct flowi6 *fl6);\n};\n\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\nint l3mdev_table_lookup_register(enum l3mdev_type l3type,\n\t\t\t\t lookup_by_table_id_t fn);\n\nvoid l3mdev_table_lookup_unregister(enum l3mdev_type l3type,\n\t\t\t\t    lookup_by_table_id_t fn);\n\nint l3mdev_ifindex_lookup_by_table_id(enum l3mdev_type l3type, struct net *net,\n\t\t\t\t      u32 table_id);\n\nint l3mdev_fib_rule_match(struct net *net, struct flowi *fl,\n\t\t\t  struct fib_lookup_arg *arg);\n\nvoid l3mdev_update_flow(struct net *net, struct flowi *fl);\n\nint l3mdev_master_ifindex_rcu(const struct net_device *dev);\nstatic inline int l3mdev_master_ifindex(struct net_device *dev)\n{\n\tint ifindex;\n\n\trcu_read_lock();\n\tifindex = l3mdev_master_ifindex_rcu(dev);\n\trcu_read_unlock();\n\n\treturn ifindex;\n}\n\nstatic inline int l3mdev_master_ifindex_by_index(struct net *net, int ifindex)\n{\n\tstruct net_device *dev;\n\tint rc = 0;\n\n\tif (likely(ifindex)) {\n\t\trcu_read_lock();\n\n\t\tdev = dev_get_by_index_rcu(net, ifindex);\n\t\tif (dev)\n\t\t\trc = l3mdev_master_ifindex_rcu(dev);\n\n\t\trcu_read_unlock();\n\t}\n\n\treturn rc;\n}\n\nstatic inline\nstruct net_device *l3mdev_master_dev_rcu(const struct net_device *_dev)\n{\n\t \n\tstruct net_device *dev = (struct net_device *)_dev;\n\tstruct net_device *master;\n\n\tif (!dev)\n\t\treturn NULL;\n\n\tif (netif_is_l3_master(dev))\n\t\tmaster = dev;\n\telse if (netif_is_l3_slave(dev))\n\t\tmaster = netdev_master_upper_dev_get_rcu(dev);\n\telse\n\t\tmaster = NULL;\n\n\treturn master;\n}\n\nint l3mdev_master_upper_ifindex_by_index_rcu(struct net *net, int ifindex);\nstatic inline\nint l3mdev_master_upper_ifindex_by_index(struct net *net, int ifindex)\n{\n\trcu_read_lock();\n\tifindex = l3mdev_master_upper_ifindex_by_index_rcu(net, ifindex);\n\trcu_read_unlock();\n\n\treturn ifindex;\n}\n\nu32 l3mdev_fib_table_rcu(const struct net_device *dev);\nu32 l3mdev_fib_table_by_index(struct net *net, int ifindex);\nstatic inline u32 l3mdev_fib_table(const struct net_device *dev)\n{\n\tu32 tb_id;\n\n\trcu_read_lock();\n\ttb_id = l3mdev_fib_table_rcu(dev);\n\trcu_read_unlock();\n\n\treturn tb_id;\n}\n\nstatic inline bool netif_index_is_l3_master(struct net *net, int ifindex)\n{\n\tstruct net_device *dev;\n\tbool rc = false;\n\n\tif (ifindex == 0)\n\t\treturn false;\n\n\trcu_read_lock();\n\n\tdev = dev_get_by_index_rcu(net, ifindex);\n\tif (dev)\n\t\trc = netif_is_l3_master(dev);\n\n\trcu_read_unlock();\n\n\treturn rc;\n}\n\nstruct dst_entry *l3mdev_link_scope_lookup(struct net *net, struct flowi6 *fl6);\n\nstatic inline\nstruct sk_buff *l3mdev_l3_rcv(struct sk_buff *skb, u16 proto)\n{\n\tstruct net_device *master = NULL;\n\n\tif (netif_is_l3_slave(skb->dev))\n\t\tmaster = netdev_master_upper_dev_get_rcu(skb->dev);\n\telse if (netif_is_l3_master(skb->dev) ||\n\t\t netif_has_l3_rx_handler(skb->dev))\n\t\tmaster = skb->dev;\n\n\tif (master && master->l3mdev_ops->l3mdev_l3_rcv)\n\t\tskb = master->l3mdev_ops->l3mdev_l3_rcv(master, skb, proto);\n\n\treturn skb;\n}\n\nstatic inline\nstruct sk_buff *l3mdev_ip_rcv(struct sk_buff *skb)\n{\n\treturn l3mdev_l3_rcv(skb, AF_INET);\n}\n\nstatic inline\nstruct sk_buff *l3mdev_ip6_rcv(struct sk_buff *skb)\n{\n\treturn l3mdev_l3_rcv(skb, AF_INET6);\n}\n\nstatic inline\nstruct sk_buff *l3mdev_l3_out(struct sock *sk, struct sk_buff *skb, u16 proto)\n{\n\tstruct net_device *dev = skb_dst(skb)->dev;\n\n\tif (netif_is_l3_slave(dev)) {\n\t\tstruct net_device *master;\n\n\t\tmaster = netdev_master_upper_dev_get_rcu(dev);\n\t\tif (master && master->l3mdev_ops->l3mdev_l3_out)\n\t\t\tskb = master->l3mdev_ops->l3mdev_l3_out(master, sk,\n\t\t\t\t\t\t\t\tskb, proto);\n\t}\n\n\treturn skb;\n}\n\nstatic inline\nstruct sk_buff *l3mdev_ip_out(struct sock *sk, struct sk_buff *skb)\n{\n\treturn l3mdev_l3_out(sk, skb, AF_INET);\n}\n\nstatic inline\nstruct sk_buff *l3mdev_ip6_out(struct sock *sk, struct sk_buff *skb)\n{\n\treturn l3mdev_l3_out(sk, skb, AF_INET6);\n}\n#else\n\nstatic inline int l3mdev_master_ifindex_rcu(const struct net_device *dev)\n{\n\treturn 0;\n}\nstatic inline int l3mdev_master_ifindex(struct net_device *dev)\n{\n\treturn 0;\n}\n\nstatic inline int l3mdev_master_ifindex_by_index(struct net *net, int ifindex)\n{\n\treturn 0;\n}\n\nstatic inline\nint l3mdev_master_upper_ifindex_by_index_rcu(struct net *net, int ifindex)\n{\n\treturn 0;\n}\nstatic inline\nint l3mdev_master_upper_ifindex_by_index(struct net *net, int ifindex)\n{\n\treturn 0;\n}\n\nstatic inline\nstruct net_device *l3mdev_master_dev_rcu(const struct net_device *dev)\n{\n\treturn NULL;\n}\n\nstatic inline u32 l3mdev_fib_table_rcu(const struct net_device *dev)\n{\n\treturn 0;\n}\nstatic inline u32 l3mdev_fib_table(const struct net_device *dev)\n{\n\treturn 0;\n}\nstatic inline u32 l3mdev_fib_table_by_index(struct net *net, int ifindex)\n{\n\treturn 0;\n}\n\nstatic inline bool netif_index_is_l3_master(struct net *net, int ifindex)\n{\n\treturn false;\n}\n\nstatic inline\nstruct dst_entry *l3mdev_link_scope_lookup(struct net *net, struct flowi6 *fl6)\n{\n\treturn NULL;\n}\n\nstatic inline\nstruct sk_buff *l3mdev_ip_rcv(struct sk_buff *skb)\n{\n\treturn skb;\n}\n\nstatic inline\nstruct sk_buff *l3mdev_ip6_rcv(struct sk_buff *skb)\n{\n\treturn skb;\n}\n\nstatic inline\nstruct sk_buff *l3mdev_ip_out(struct sock *sk, struct sk_buff *skb)\n{\n\treturn skb;\n}\n\nstatic inline\nstruct sk_buff *l3mdev_ip6_out(struct sock *sk, struct sk_buff *skb)\n{\n\treturn skb;\n}\n\nstatic inline\nint l3mdev_table_lookup_register(enum l3mdev_type l3type,\n\t\t\t\t lookup_by_table_id_t fn)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline\nvoid l3mdev_table_lookup_unregister(enum l3mdev_type l3type,\n\t\t\t\t    lookup_by_table_id_t fn)\n{\n}\n\nstatic inline\nint l3mdev_ifindex_lookup_by_table_id(enum l3mdev_type l3type, struct net *net,\n\t\t\t\t      u32 table_id)\n{\n\treturn -ENODEV;\n}\n\nstatic inline\nint l3mdev_fib_rule_match(struct net *net, struct flowi *fl,\n\t\t\t  struct fib_lookup_arg *arg)\n{\n\treturn 1;\n}\nstatic inline\nvoid l3mdev_update_flow(struct net *net, struct flowi *fl)\n{\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}