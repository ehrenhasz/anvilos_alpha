{
  "module_name": "nexthop.h",
  "hash_id": "035943e2c42c61346dfb1e8a9eb2036fc16a472bed8dc703596299ffb8ad1c5d",
  "original_prompt": "Ingested from linux-6.6.14/include/net/nexthop.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_NEXTHOP_H\n#define __LINUX_NEXTHOP_H\n\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/route.h>\n#include <linux/types.h>\n#include <net/ip_fib.h>\n#include <net/ip6_fib.h>\n#include <net/netlink.h>\n\n#define NEXTHOP_VALID_USER_FLAGS RTNH_F_ONLINK\n\nstruct nexthop;\n\nstruct nh_config {\n\tu32\t\tnh_id;\n\n\tu8\t\tnh_family;\n\tu8\t\tnh_protocol;\n\tu8\t\tnh_blackhole;\n\tu8\t\tnh_fdb;\n\tu32\t\tnh_flags;\n\n\tint\t\tnh_ifindex;\n\tstruct net_device *dev;\n\n\tunion {\n\t\t__be32\t\tipv4;\n\t\tstruct in6_addr\tipv6;\n\t} gw;\n\n\tstruct nlattr\t*nh_grp;\n\tu16\t\tnh_grp_type;\n\tu16\t\tnh_grp_res_num_buckets;\n\tunsigned long\tnh_grp_res_idle_timer;\n\tunsigned long\tnh_grp_res_unbalanced_timer;\n\tbool\t\tnh_grp_res_has_num_buckets;\n\tbool\t\tnh_grp_res_has_idle_timer;\n\tbool\t\tnh_grp_res_has_unbalanced_timer;\n\n\tstruct nlattr\t*nh_encap;\n\tu16\t\tnh_encap_type;\n\n\tu32\t\tnlflags;\n\tstruct nl_info\tnlinfo;\n};\n\nstruct nh_info {\n\tstruct hlist_node\tdev_hash;     \n\tstruct nexthop\t\t*nh_parent;\n\n\tu8\t\t\tfamily;\n\tbool\t\t\treject_nh;\n\tbool\t\t\tfdb_nh;\n\n\tunion {\n\t\tstruct fib_nh_common\tfib_nhc;\n\t\tstruct fib_nh\t\tfib_nh;\n\t\tstruct fib6_nh\t\tfib6_nh;\n\t};\n};\n\nstruct nh_res_bucket {\n\tstruct nh_grp_entry __rcu *nh_entry;\n\tatomic_long_t\t\tused_time;\n\tunsigned long\t\tmigrated_time;\n\tbool\t\t\toccupied;\n\tu8\t\t\tnh_flags;\n};\n\nstruct nh_res_table {\n\tstruct net\t\t*net;\n\tu32\t\t\tnhg_id;\n\tstruct delayed_work\tupkeep_dw;\n\n\t \n\tstruct list_head\tuw_nh_entries;\n\tunsigned long\t\tunbalanced_since;\n\n\tu32\t\t\tidle_timer;\n\tu32\t\t\tunbalanced_timer;\n\n\tu16\t\t\tnum_nh_buckets;\n\tstruct nh_res_bucket\tnh_buckets[];\n};\n\nstruct nh_grp_entry {\n\tstruct nexthop\t*nh;\n\tu8\t\tweight;\n\n\tunion {\n\t\tstruct {\n\t\t\tatomic_t\tupper_bound;\n\t\t} hthr;\n\t\tstruct {\n\t\t\t \n\t\t\tstruct list_head\tuw_nh_entry;\n\n\t\t\tu16\t\t\tcount_buckets;\n\t\t\tu16\t\t\twants_buckets;\n\t\t} res;\n\t};\n\n\tstruct list_head nh_list;\n\tstruct nexthop\t*nh_parent;   \n};\n\nstruct nh_group {\n\tstruct nh_group\t\t*spare;  \n\tu16\t\t\tnum_nh;\n\tbool\t\t\tis_multipath;\n\tbool\t\t\thash_threshold;\n\tbool\t\t\tresilient;\n\tbool\t\t\tfdb_nh;\n\tbool\t\t\thas_v4;\n\n\tstruct nh_res_table __rcu *res_table;\n\tstruct nh_grp_entry\tnh_entries[];\n};\n\nstruct nexthop {\n\tstruct rb_node\t\trb_node;     \n\tstruct list_head\tfi_list;     \n\tstruct list_head\tf6i_list;    \n\tstruct list_head        fdb_list;    \n\tstruct list_head\tgrp_list;    \n\tstruct net\t\t*net;\n\n\tu32\t\t\tid;\n\n\tu8\t\t\tprotocol;    \n\tu8\t\t\tnh_flags;\n\tbool\t\t\tis_group;\n\n\trefcount_t\t\trefcnt;\n\tstruct rcu_head\t\trcu;\n\n\tunion {\n\t\tstruct nh_info\t__rcu *nh_info;\n\t\tstruct nh_group __rcu *nh_grp;\n\t};\n};\n\nenum nexthop_event_type {\n\tNEXTHOP_EVENT_DEL,\n\tNEXTHOP_EVENT_REPLACE,\n\tNEXTHOP_EVENT_RES_TABLE_PRE_REPLACE,\n\tNEXTHOP_EVENT_BUCKET_REPLACE,\n};\n\nenum nh_notifier_info_type {\n\tNH_NOTIFIER_INFO_TYPE_SINGLE,\n\tNH_NOTIFIER_INFO_TYPE_GRP,\n\tNH_NOTIFIER_INFO_TYPE_RES_TABLE,\n\tNH_NOTIFIER_INFO_TYPE_RES_BUCKET,\n};\n\nstruct nh_notifier_single_info {\n\tstruct net_device *dev;\n\tu8 gw_family;\n\tunion {\n\t\t__be32 ipv4;\n\t\tstruct in6_addr ipv6;\n\t};\n\tu8 is_reject:1,\n\t   is_fdb:1,\n\t   has_encap:1;\n};\n\nstruct nh_notifier_grp_entry_info {\n\tu8 weight;\n\tu32 id;\n\tstruct nh_notifier_single_info nh;\n};\n\nstruct nh_notifier_grp_info {\n\tu16 num_nh;\n\tbool is_fdb;\n\tstruct nh_notifier_grp_entry_info nh_entries[];\n};\n\nstruct nh_notifier_res_bucket_info {\n\tu16 bucket_index;\n\tunsigned int idle_timer_ms;\n\tbool force;\n\tstruct nh_notifier_single_info old_nh;\n\tstruct nh_notifier_single_info new_nh;\n};\n\nstruct nh_notifier_res_table_info {\n\tu16 num_nh_buckets;\n\tstruct nh_notifier_single_info nhs[];\n};\n\nstruct nh_notifier_info {\n\tstruct net *net;\n\tstruct netlink_ext_ack *extack;\n\tu32 id;\n\tenum nh_notifier_info_type type;\n\tunion {\n\t\tstruct nh_notifier_single_info *nh;\n\t\tstruct nh_notifier_grp_info *nh_grp;\n\t\tstruct nh_notifier_res_table_info *nh_res_table;\n\t\tstruct nh_notifier_res_bucket_info *nh_res_bucket;\n\t};\n};\n\nint register_nexthop_notifier(struct net *net, struct notifier_block *nb,\n\t\t\t      struct netlink_ext_ack *extack);\nint unregister_nexthop_notifier(struct net *net, struct notifier_block *nb);\nvoid nexthop_set_hw_flags(struct net *net, u32 id, bool offload, bool trap);\nvoid nexthop_bucket_set_hw_flags(struct net *net, u32 id, u16 bucket_index,\n\t\t\t\t bool offload, bool trap);\nvoid nexthop_res_grp_activity_update(struct net *net, u32 id, u16 num_buckets,\n\t\t\t\t     unsigned long *activity);\n\n \nstruct nexthop *nexthop_find_by_id(struct net *net, u32 id);\nvoid nexthop_free_rcu(struct rcu_head *head);\n\nstatic inline bool nexthop_get(struct nexthop *nh)\n{\n\treturn refcount_inc_not_zero(&nh->refcnt);\n}\n\nstatic inline void nexthop_put(struct nexthop *nh)\n{\n\tif (refcount_dec_and_test(&nh->refcnt))\n\t\tcall_rcu(&nh->rcu, nexthop_free_rcu);\n}\n\nstatic inline bool nexthop_cmp(const struct nexthop *nh1,\n\t\t\t       const struct nexthop *nh2)\n{\n\treturn nh1 == nh2;\n}\n\nstatic inline bool nexthop_is_fdb(const struct nexthop *nh)\n{\n\tif (nh->is_group) {\n\t\tconst struct nh_group *nh_grp;\n\n\t\tnh_grp = rcu_dereference_rtnl(nh->nh_grp);\n\t\treturn nh_grp->fdb_nh;\n\t} else {\n\t\tconst struct nh_info *nhi;\n\n\t\tnhi = rcu_dereference_rtnl(nh->nh_info);\n\t\treturn nhi->fdb_nh;\n\t}\n}\n\nstatic inline bool nexthop_has_v4(const struct nexthop *nh)\n{\n\tif (nh->is_group) {\n\t\tstruct nh_group *nh_grp;\n\n\t\tnh_grp = rcu_dereference_rtnl(nh->nh_grp);\n\t\treturn nh_grp->has_v4;\n\t}\n\treturn false;\n}\n\nstatic inline bool nexthop_is_multipath(const struct nexthop *nh)\n{\n\tif (nh->is_group) {\n\t\tstruct nh_group *nh_grp;\n\n\t\tnh_grp = rcu_dereference_rtnl(nh->nh_grp);\n\t\treturn nh_grp->is_multipath;\n\t}\n\treturn false;\n}\n\nstruct nexthop *nexthop_select_path(struct nexthop *nh, int hash);\n\nstatic inline unsigned int nexthop_num_path(const struct nexthop *nh)\n{\n\tunsigned int rc = 1;\n\n\tif (nh->is_group) {\n\t\tstruct nh_group *nh_grp;\n\n\t\tnh_grp = rcu_dereference_rtnl(nh->nh_grp);\n\t\tif (nh_grp->is_multipath)\n\t\t\trc = nh_grp->num_nh;\n\t}\n\n\treturn rc;\n}\n\nstatic inline\nstruct nexthop *nexthop_mpath_select(const struct nh_group *nhg, int nhsel)\n{\n\t \n\tif (nhsel >= nhg->num_nh)\n\t\treturn NULL;\n\n\treturn nhg->nh_entries[nhsel].nh;\n}\n\nstatic inline\nint nexthop_mpath_fill_node(struct sk_buff *skb, struct nexthop *nh,\n\t\t\t    u8 rt_family)\n{\n\tstruct nh_group *nhg = rtnl_dereference(nh->nh_grp);\n\tint i;\n\n\tfor (i = 0; i < nhg->num_nh; i++) {\n\t\tstruct nexthop *nhe = nhg->nh_entries[i].nh;\n\t\tstruct nh_info *nhi = rcu_dereference_rtnl(nhe->nh_info);\n\t\tstruct fib_nh_common *nhc = &nhi->fib_nhc;\n\t\tint weight = nhg->nh_entries[i].weight;\n\n\t\tif (fib_add_nexthop(skb, nhc, weight, rt_family, 0) < 0)\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline bool nexthop_is_blackhole(const struct nexthop *nh)\n{\n\tconst struct nh_info *nhi;\n\n\tif (nh->is_group) {\n\t\tstruct nh_group *nh_grp;\n\n\t\tnh_grp = rcu_dereference_rtnl(nh->nh_grp);\n\t\tif (nh_grp->num_nh > 1)\n\t\t\treturn false;\n\n\t\tnh = nh_grp->nh_entries[0].nh;\n\t}\n\n\tnhi = rcu_dereference_rtnl(nh->nh_info);\n\treturn nhi->reject_nh;\n}\n\nstatic inline void nexthop_path_fib_result(struct fib_result *res, int hash)\n{\n\tstruct nh_info *nhi;\n\tstruct nexthop *nh;\n\n\tnh = nexthop_select_path(res->fi->nh, hash);\n\tnhi = rcu_dereference(nh->nh_info);\n\tres->nhc = &nhi->fib_nhc;\n}\n\n \nstatic inline\nstruct fib_nh_common *nexthop_fib_nhc(struct nexthop *nh, int nhsel)\n{\n\tstruct nh_info *nhi;\n\n\tBUILD_BUG_ON(offsetof(struct fib_nh, nh_common) != 0);\n\tBUILD_BUG_ON(offsetof(struct fib6_nh, nh_common) != 0);\n\n\tif (nh->is_group) {\n\t\tstruct nh_group *nh_grp;\n\n\t\tnh_grp = rcu_dereference_rtnl(nh->nh_grp);\n\t\tif (nh_grp->is_multipath) {\n\t\t\tnh = nexthop_mpath_select(nh_grp, nhsel);\n\t\t\tif (!nh)\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tnhi = rcu_dereference_rtnl(nh->nh_info);\n\treturn &nhi->fib_nhc;\n}\n\n \nstatic inline\nstruct fib_nh_common *nexthop_get_nhc_lookup(const struct nexthop *nh,\n\t\t\t\t\t     int fib_flags,\n\t\t\t\t\t     const struct flowi4 *flp,\n\t\t\t\t\t     int *nhsel)\n{\n\tstruct nh_info *nhi;\n\n\tif (nh->is_group) {\n\t\tstruct nh_group *nhg = rcu_dereference(nh->nh_grp);\n\t\tint i;\n\n\t\tfor (i = 0; i < nhg->num_nh; i++) {\n\t\t\tstruct nexthop *nhe = nhg->nh_entries[i].nh;\n\n\t\t\tnhi = rcu_dereference(nhe->nh_info);\n\t\t\tif (fib_lookup_good_nhc(&nhi->fib_nhc, fib_flags, flp)) {\n\t\t\t\t*nhsel = i;\n\t\t\t\treturn &nhi->fib_nhc;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnhi = rcu_dereference(nh->nh_info);\n\t\tif (fib_lookup_good_nhc(&nhi->fib_nhc, fib_flags, flp)) {\n\t\t\t*nhsel = 0;\n\t\t\treturn &nhi->fib_nhc;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic inline bool nexthop_uses_dev(const struct nexthop *nh,\n\t\t\t\t    const struct net_device *dev)\n{\n\tstruct nh_info *nhi;\n\n\tif (nh->is_group) {\n\t\tstruct nh_group *nhg = rcu_dereference(nh->nh_grp);\n\t\tint i;\n\n\t\tfor (i = 0; i < nhg->num_nh; i++) {\n\t\t\tstruct nexthop *nhe = nhg->nh_entries[i].nh;\n\n\t\t\tnhi = rcu_dereference(nhe->nh_info);\n\t\t\tif (nhc_l3mdev_matches_dev(&nhi->fib_nhc, dev))\n\t\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tnhi = rcu_dereference(nh->nh_info);\n\t\tif (nhc_l3mdev_matches_dev(&nhi->fib_nhc, dev))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline unsigned int fib_info_num_path(const struct fib_info *fi)\n{\n\tif (unlikely(fi->nh))\n\t\treturn nexthop_num_path(fi->nh);\n\n\treturn fi->fib_nhs;\n}\n\nint fib_check_nexthop(struct nexthop *nh, u8 scope,\n\t\t      struct netlink_ext_ack *extack);\n\nstatic inline struct fib_nh_common *fib_info_nhc(struct fib_info *fi, int nhsel)\n{\n\tif (unlikely(fi->nh))\n\t\treturn nexthop_fib_nhc(fi->nh, nhsel);\n\n\treturn &fi->fib_nh[nhsel].nh_common;\n}\n\n \nstatic inline struct fib_nh *fib_info_nh(struct fib_info *fi, int nhsel)\n{\n\tWARN_ON(fi->nh);\n\n\treturn &fi->fib_nh[nhsel];\n}\n\n \nint fib6_check_nexthop(struct nexthop *nh, struct fib6_config *cfg,\n\t\t       struct netlink_ext_ack *extack);\n\n \nstatic inline struct fib6_nh *nexthop_fib6_nh(struct nexthop *nh)\n{\n\tstruct nh_info *nhi;\n\n\tif (nh->is_group) {\n\t\tstruct nh_group *nh_grp;\n\n\t\tnh_grp = rcu_dereference_rtnl(nh->nh_grp);\n\t\tnh = nexthop_mpath_select(nh_grp, 0);\n\t\tif (!nh)\n\t\t\treturn NULL;\n\t}\n\n\tnhi = rcu_dereference_rtnl(nh->nh_info);\n\tif (nhi->family == AF_INET6)\n\t\treturn &nhi->fib6_nh;\n\n\treturn NULL;\n}\n\nstatic inline struct net_device *fib6_info_nh_dev(struct fib6_info *f6i)\n{\n\tstruct fib6_nh *fib6_nh;\n\n\tfib6_nh = f6i->nh ? nexthop_fib6_nh(f6i->nh) : f6i->fib6_nh;\n\treturn fib6_nh->fib_nh_dev;\n}\n\nstatic inline void nexthop_path_fib6_result(struct fib6_result *res, int hash)\n{\n\tstruct nexthop *nh = res->f6i->nh;\n\tstruct nh_info *nhi;\n\n\tnh = nexthop_select_path(nh, hash);\n\n\tnhi = rcu_dereference_rtnl(nh->nh_info);\n\tif (nhi->reject_nh) {\n\t\tres->fib6_type = RTN_BLACKHOLE;\n\t\tres->fib6_flags |= RTF_REJECT;\n\t\tres->nh = nexthop_fib6_nh(nh);\n\t} else {\n\t\tres->nh = &nhi->fib6_nh;\n\t}\n}\n\nint nexthop_for_each_fib6_nh(struct nexthop *nh,\n\t\t\t     int (*cb)(struct fib6_nh *nh, void *arg),\n\t\t\t     void *arg);\n\nstatic inline int nexthop_get_family(struct nexthop *nh)\n{\n\tstruct nh_info *nhi = rcu_dereference_rtnl(nh->nh_info);\n\n\treturn nhi->family;\n}\n\nstatic inline\nstruct fib_nh_common *nexthop_fdb_nhc(struct nexthop *nh)\n{\n\tstruct nh_info *nhi = rcu_dereference_rtnl(nh->nh_info);\n\n\treturn &nhi->fib_nhc;\n}\n\nstatic inline struct fib_nh_common *nexthop_path_fdb_result(struct nexthop *nh,\n\t\t\t\t\t\t\t    int hash)\n{\n\tstruct nh_info *nhi;\n\tstruct nexthop *nhp;\n\n\tnhp = nexthop_select_path(nh, hash);\n\tif (unlikely(!nhp))\n\t\treturn NULL;\n\tnhi = rcu_dereference(nhp->nh_info);\n\treturn &nhi->fib_nhc;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}