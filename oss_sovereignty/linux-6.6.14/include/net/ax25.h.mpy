{
  "module_name": "ax25.h",
  "hash_id": "f33d43804f3792984e0912c9f6370db2cf27bc5794db261728ad9a06ae8bfa26",
  "original_prompt": "Ingested from linux-6.6.14/include/net/ax25.h",
  "human_readable_source": " \n \n#ifndef _AX25_H\n#define _AX25_H \n\n#include <linux/ax25.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <net/neighbour.h>\n#include <net/sock.h>\n#include <linux/seq_file.h>\n\n#define\tAX25_T1CLAMPLO  \t\t1\n#define\tAX25_T1CLAMPHI \t\t\t(30 * HZ)\n\n#define\tAX25_BPQ_HEADER_LEN\t\t16\n#define\tAX25_KISS_HEADER_LEN\t\t1\n\n#define\tAX25_HEADER_LEN\t\t\t17\n#define\tAX25_ADDR_LEN\t\t\t7\n#define\tAX25_DIGI_HEADER_LEN\t\t(AX25_MAX_DIGIS * AX25_ADDR_LEN)\n#define\tAX25_MAX_HEADER_LEN\t\t(AX25_HEADER_LEN + AX25_DIGI_HEADER_LEN)\n\n \n#define AX25_P_ROSE\t\t\t0x01\n#define AX25_P_VJCOMP\t\t\t0x06\t \n\t\t\t\t\t\t \n#define AX25_P_VJUNCOMP\t\t\t0x07\t \n\t\t\t\t\t\t \n#define\tAX25_P_SEGMENT\t\t\t0x08\t \n#define AX25_P_TEXNET\t\t\t0xc3\t \n#define AX25_P_LQ\t\t\t0xc4\t \n#define AX25_P_ATALK\t\t\t0xca\t \n#define AX25_P_ATALK_ARP\t\t0xcb\t \n#define AX25_P_IP\t\t\t0xcc\t \n#define AX25_P_ARP\t\t\t0xcd\t \n#define AX25_P_FLEXNET\t\t\t0xce\t \n#define AX25_P_NETROM \t\t\t0xcf\t \n#define AX25_P_TEXT \t\t\t0xF0\t \n\n \n#define\tAX25_SEG_REM\t\t\t0x7F\n#define\tAX25_SEG_FIRST\t\t\t0x80\n\n#define AX25_CBIT\t\t\t0x80\t \n#define AX25_EBIT\t\t\t0x01\t \n#define AX25_HBIT\t\t\t0x80\t \n\n#define AX25_SSSID_SPARE\t\t0x60\t \n#define AX25_ESSID_SPARE\t\t0x20\t \n#define AX25_DAMA_FLAG\t\t\t0x20\t \n\n#define\tAX25_COND_ACK_PENDING\t\t0x01\n#define\tAX25_COND_REJECT\t\t0x02\n#define\tAX25_COND_PEER_RX_BUSY\t\t0x04\n#define\tAX25_COND_OWN_RX_BUSY\t\t0x08\n#define\tAX25_COND_DAMA_MODE\t\t0x10\n\n#ifndef _LINUX_NETDEVICE_H\n#include <linux/netdevice.h>\n#endif\n\n \n\n \n#define\tAX25_I\t\t\t0x00\t \n#define\tAX25_S\t\t\t0x01\t \n#define\tAX25_RR\t\t\t0x01\t \n#define\tAX25_RNR\t\t0x05\t \n#define\tAX25_REJ\t\t0x09\t \n#define\tAX25_U\t\t\t0x03\t \n#define\tAX25_SABM\t\t0x2f\t \n#define\tAX25_SABME\t\t0x6f\t \n#define\tAX25_DISC\t\t0x43\t \n#define\tAX25_DM\t\t\t0x0f\t \n#define\tAX25_UA\t\t\t0x63\t \n#define\tAX25_FRMR\t\t0x87\t \n#define\tAX25_UI\t\t\t0x03\t \n#define\tAX25_XID\t\t0xaf\t \n#define\tAX25_TEST\t\t0xe3\t \n\n#define\tAX25_PF\t\t\t0x10\t \n#define\tAX25_EPF\t\t0x01\t \n\n#define AX25_ILLEGAL\t\t0x100\t \n\n#define\tAX25_POLLOFF\t\t0\n#define\tAX25_POLLON\t\t1\n\n \n#define AX25_COMMAND\t\t1\n#define AX25_RESPONSE\t\t2\n\n \n\nenum { \n\tAX25_STATE_0,\t\t\t \n\tAX25_STATE_1,\t\t\t \n\tAX25_STATE_2,\t\t\t \n\tAX25_STATE_3,\t\t\t \n\tAX25_STATE_4\t\t\t \n};\n\n#define AX25_MODULUS \t\t8\t \n#define\tAX25_EMODULUS\t\t128\t \n\nenum {\n\tAX25_PROTO_STD_SIMPLEX,\n\tAX25_PROTO_STD_DUPLEX,\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\tAX25_PROTO_DAMA_SLAVE,\n#ifdef CONFIG_AX25_DAMA_MASTER\n\tAX25_PROTO_DAMA_MASTER,\n#define AX25_PROTO_MAX AX25_PROTO_DAMA_MASTER\n#endif\n#endif\n\t__AX25_PROTO_MAX,\n\tAX25_PROTO_MAX = __AX25_PROTO_MAX -1\n};\n\nenum {\n\tAX25_VALUES_IPDEFMODE,\t \n\tAX25_VALUES_AXDEFMODE,\t \n\tAX25_VALUES_BACKOFF,\t \n\tAX25_VALUES_CONMODE,\t \n\tAX25_VALUES_WINDOW,\t \n\tAX25_VALUES_EWINDOW,\t \n\tAX25_VALUES_T1,\t\t \n\tAX25_VALUES_T2,\t\t \n\tAX25_VALUES_T3,\t\t \n\tAX25_VALUES_IDLE,\t \n\tAX25_VALUES_N2,\t\t \n\tAX25_VALUES_PACLEN,\t \n\tAX25_VALUES_PROTOCOL,\t \n\tAX25_VALUES_DS_TIMEOUT,\t \n\tAX25_MAX_VALUES\t\t \n};\n\n#define\tAX25_DEF_IPDEFMODE\t0\t\t\t \n#define\tAX25_DEF_AXDEFMODE\t0\t\t\t \n#define\tAX25_DEF_BACKOFF\t1\t\t\t \n#define\tAX25_DEF_CONMODE\t2\t\t\t \n#define\tAX25_DEF_WINDOW\t\t2\t\t\t \n#define\tAX25_DEF_EWINDOW\t32\t\t\t \n#define\tAX25_DEF_T1\t\t10000\t\t\t \n#define\tAX25_DEF_T2\t\t3000\t\t\t \n#define\tAX25_DEF_T3\t\t300000\t\t\t \n#define\tAX25_DEF_N2\t\t10\t\t\t \n#define AX25_DEF_IDLE\t\t0\t\t\t \n#define AX25_DEF_PACLEN\t\t256\t\t\t \n#define\tAX25_DEF_PROTOCOL\tAX25_PROTO_STD_SIMPLEX\t \n#define AX25_DEF_DS_TIMEOUT\t180000\t\t\t \n\ntypedef struct ax25_uid_assoc {\n\tstruct hlist_node\tuid_node;\n\trefcount_t\t\trefcount;\n\tkuid_t\t\t\tuid;\n\tax25_address\t\tcall;\n} ax25_uid_assoc;\n\n#define ax25_uid_for_each(__ax25, list) \\\n\thlist_for_each_entry(__ax25, list, uid_node)\n\n#define ax25_uid_hold(ax25) \\\n\trefcount_inc(&((ax25)->refcount))\n\nstatic inline void ax25_uid_put(ax25_uid_assoc *assoc)\n{\n\tif (refcount_dec_and_test(&assoc->refcount)) {\n\t\tkfree(assoc);\n\t}\n}\n\ntypedef struct {\n\tax25_address\t\tcalls[AX25_MAX_DIGIS];\n\tunsigned char\t\trepeated[AX25_MAX_DIGIS];\n\tunsigned char\t\tndigi;\n\tsigned char\t\tlastrepeat;\n} ax25_digi;\n\ntypedef struct ax25_route {\n\tstruct ax25_route\t*next;\n\tax25_address\t\tcallsign;\n\tstruct net_device\t*dev;\n\tax25_digi\t\t*digipeat;\n\tchar\t\t\tip_mode;\n} ax25_route;\n\nvoid __ax25_put_route(ax25_route *ax25_rt);\n\nextern rwlock_t ax25_route_lock;\n\nstatic inline void ax25_route_lock_use(void)\n{\n\tread_lock(&ax25_route_lock);\n}\n\nstatic inline void ax25_route_lock_unuse(void)\n{\n\tread_unlock(&ax25_route_lock);\n}\n\ntypedef struct {\n\tchar\t\t\tslave;\t\t\t \n\tstruct timer_list\tslave_timer;\t\t \n\tunsigned short\t\tslave_timeout;\t\t \n} ax25_dama_info;\n\nstruct ctl_table;\n\ntypedef struct ax25_dev {\n\tstruct ax25_dev\t\t*next;\n\n\tstruct net_device\t*dev;\n\tnetdevice_tracker\tdev_tracker;\n\n\tstruct net_device\t*forward;\n\tstruct ctl_table_header *sysheader;\n\tint\t\t\tvalues[AX25_MAX_VALUES];\n#if defined(CONFIG_AX25_DAMA_SLAVE) || defined(CONFIG_AX25_DAMA_MASTER)\n\tax25_dama_info\t\tdama;\n#endif\n\trefcount_t\t\trefcount;\n\tbool device_up;\n} ax25_dev;\n\ntypedef struct ax25_cb {\n\tstruct hlist_node\tax25_node;\n\tax25_address\t\tsource_addr, dest_addr;\n\tax25_digi\t\t*digipeat;\n\tax25_dev\t\t*ax25_dev;\n\tnetdevice_tracker\tdev_tracker;\n\tunsigned char\t\tiamdigi;\n\tunsigned char\t\tstate, modulus, pidincl;\n\tunsigned short\t\tvs, vr, va;\n\tunsigned char\t\tcondition, backoff;\n\tunsigned char\t\tn2, n2count;\n\tstruct timer_list\tt1timer, t2timer, t3timer, idletimer;\n\tunsigned long\t\tt1, t2, t3, idle, rtt;\n\tunsigned short\t\tpaclen, fragno, fraglen;\n\tstruct sk_buff_head\twrite_queue;\n\tstruct sk_buff_head\treseq_queue;\n\tstruct sk_buff_head\tack_queue;\n\tstruct sk_buff_head\tfrag_queue;\n\tunsigned char\t\twindow;\n\tstruct timer_list\ttimer, dtimer;\n\tstruct sock\t\t*sk;\t\t \n\trefcount_t\t\trefcount;\n} ax25_cb;\n\nstruct ax25_sock {\n\tstruct sock\t\tsk;\n\tstruct ax25_cb\t\t*cb;\n};\n\n#define ax25_sk(ptr) container_of_const(ptr, struct ax25_sock, sk)\n\nstatic inline struct ax25_cb *sk_to_ax25(const struct sock *sk)\n{\n\treturn ax25_sk(sk)->cb;\n}\n\n#define ax25_for_each(__ax25, list) \\\n\thlist_for_each_entry(__ax25, list, ax25_node)\n\n#define ax25_cb_hold(__ax25) \\\n\trefcount_inc(&((__ax25)->refcount))\n\nstatic __inline__ void ax25_cb_put(ax25_cb *ax25)\n{\n\tif (refcount_dec_and_test(&ax25->refcount)) {\n\t\tkfree(ax25->digipeat);\n\t\tkfree(ax25);\n\t}\n}\n\nstatic inline void ax25_dev_hold(ax25_dev *ax25_dev)\n{\n\trefcount_inc(&ax25_dev->refcount);\n}\n\nstatic inline void ax25_dev_put(ax25_dev *ax25_dev)\n{\n\tif (refcount_dec_and_test(&ax25_dev->refcount)) {\n\t\tkfree(ax25_dev);\n\t}\n}\nstatic inline __be16 ax25_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tskb->dev      = dev;\n\tskb_reset_mac_header(skb);\n\tskb->pkt_type = PACKET_HOST;\n\treturn htons(ETH_P_AX25);\n}\n\n \nextern struct hlist_head ax25_list;\nextern spinlock_t ax25_list_lock;\nvoid ax25_cb_add(ax25_cb *);\nstruct sock *ax25_find_listener(ax25_address *, int, struct net_device *, int);\nstruct sock *ax25_get_socket(ax25_address *, ax25_address *, int);\nax25_cb *ax25_find_cb(const ax25_address *, ax25_address *, ax25_digi *,\n\t\t      struct net_device *);\nvoid ax25_send_to_raw(ax25_address *, struct sk_buff *, int);\nvoid ax25_destroy_socket(ax25_cb *);\nax25_cb * __must_check ax25_create_cb(void);\nvoid ax25_fillin_cb(ax25_cb *, ax25_dev *);\nstruct sock *ax25_make_new(struct sock *, struct ax25_dev *);\n\n \nextern const ax25_address ax25_bcast;\nextern const ax25_address ax25_defaddr;\nextern const ax25_address null_ax25_address;\nchar *ax2asc(char *buf, const ax25_address *);\nvoid asc2ax(ax25_address *addr, const char *callsign);\nint ax25cmp(const ax25_address *, const ax25_address *);\nint ax25digicmp(const ax25_digi *, const ax25_digi *);\nconst unsigned char *ax25_addr_parse(const unsigned char *, int,\n\tax25_address *, ax25_address *, ax25_digi *, int *, int *);\nint ax25_addr_build(unsigned char *, const ax25_address *,\n\t\t    const ax25_address *, const ax25_digi *, int, int);\nint ax25_addr_size(const ax25_digi *);\nvoid ax25_digi_invert(const ax25_digi *, ax25_digi *);\n\n \nextern ax25_dev *ax25_dev_list;\nextern spinlock_t ax25_dev_lock;\n\n#if IS_ENABLED(CONFIG_AX25)\nstatic inline ax25_dev *ax25_dev_ax25dev(struct net_device *dev)\n{\n\treturn dev->ax25_ptr;\n}\n#endif\n\nax25_dev *ax25_addr_ax25dev(ax25_address *);\nvoid ax25_dev_device_up(struct net_device *);\nvoid ax25_dev_device_down(struct net_device *);\nint ax25_fwd_ioctl(unsigned int, struct ax25_fwd_struct *);\nstruct net_device *ax25_fwd_dev(struct net_device *);\nvoid ax25_dev_free(void);\n\n \nint ax25_ds_frame_in(ax25_cb *, struct sk_buff *, int);\n\n \nvoid ax25_ds_nr_error_recovery(ax25_cb *);\nvoid ax25_ds_enquiry_response(ax25_cb *);\nvoid ax25_ds_establish_data_link(ax25_cb *);\nvoid ax25_dev_dama_off(ax25_dev *);\nvoid ax25_dama_on(ax25_cb *);\nvoid ax25_dama_off(ax25_cb *);\n\n \nvoid ax25_ds_setup_timer(ax25_dev *);\nvoid ax25_ds_set_timer(ax25_dev *);\nvoid ax25_ds_del_timer(ax25_dev *);\nvoid ax25_ds_timer(ax25_cb *);\nvoid ax25_ds_t1_timeout(ax25_cb *);\nvoid ax25_ds_heartbeat_expiry(ax25_cb *);\nvoid ax25_ds_t3timer_expiry(ax25_cb *);\nvoid ax25_ds_idletimer_expiry(ax25_cb *);\n\n \n\nstruct ax25_protocol {\n\tstruct ax25_protocol *next;\n\tunsigned int pid;\n\tint (*func)(struct sk_buff *, ax25_cb *);\n};\n\nvoid ax25_register_pid(struct ax25_protocol *ap);\nvoid ax25_protocol_release(unsigned int);\n\nstruct ax25_linkfail {\n\tstruct hlist_node lf_node;\n\tvoid (*func)(ax25_cb *, int);\n};\n\nvoid ax25_linkfail_register(struct ax25_linkfail *lf);\nvoid ax25_linkfail_release(struct ax25_linkfail *lf);\nint __must_check ax25_listen_register(const ax25_address *,\n\t\t\t\t      struct net_device *);\nvoid ax25_listen_release(const ax25_address *, struct net_device *);\nint(*ax25_protocol_function(unsigned int))(struct sk_buff *, ax25_cb *);\nint ax25_listen_mine(const ax25_address *, struct net_device *);\nvoid ax25_link_failed(ax25_cb *, int);\nint ax25_protocol_is_registered(unsigned int);\n\n \nint ax25_rx_iframe(ax25_cb *, struct sk_buff *);\nint ax25_kiss_rcv(struct sk_buff *, struct net_device *, struct packet_type *,\n\t\t  struct net_device *);\n\n \nnetdev_tx_t ax25_ip_xmit(struct sk_buff *skb);\nextern const struct header_ops ax25_header_ops;\n\n \nax25_cb *ax25_send_frame(struct sk_buff *, int, const ax25_address *,\n\t\t\t ax25_address *, ax25_digi *, struct net_device *);\nvoid ax25_output(ax25_cb *, int, struct sk_buff *);\nvoid ax25_kick(ax25_cb *);\nvoid ax25_transmit_buffer(ax25_cb *, struct sk_buff *, int);\nvoid ax25_queue_xmit(struct sk_buff *skb, struct net_device *dev);\nint ax25_check_iframes_acked(ax25_cb *, unsigned short);\n\n \nvoid ax25_rt_device_down(struct net_device *);\nint ax25_rt_ioctl(unsigned int, void __user *);\nextern const struct seq_operations ax25_rt_seqops;\nax25_route *ax25_get_route(ax25_address *addr, struct net_device *dev);\nint ax25_rt_autobind(ax25_cb *, ax25_address *);\nstruct sk_buff *ax25_rt_build_path(struct sk_buff *, ax25_address *,\n\t\t\t\t   ax25_address *, ax25_digi *);\nvoid ax25_rt_free(void);\n\n \nint ax25_std_frame_in(ax25_cb *, struct sk_buff *, int);\n\n \nvoid ax25_std_nr_error_recovery(ax25_cb *);\nvoid ax25_std_establish_data_link(ax25_cb *);\nvoid ax25_std_transmit_enquiry(ax25_cb *);\nvoid ax25_std_enquiry_response(ax25_cb *);\nvoid ax25_std_timeout_response(ax25_cb *);\n\n \nvoid ax25_std_heartbeat_expiry(ax25_cb *);\nvoid ax25_std_t1timer_expiry(ax25_cb *);\nvoid ax25_std_t2timer_expiry(ax25_cb *);\nvoid ax25_std_t3timer_expiry(ax25_cb *);\nvoid ax25_std_idletimer_expiry(ax25_cb *);\n\n \nvoid ax25_clear_queues(ax25_cb *);\nvoid ax25_frames_acked(ax25_cb *, unsigned short);\nvoid ax25_requeue_frames(ax25_cb *);\nint ax25_validate_nr(ax25_cb *, unsigned short);\nint ax25_decode(ax25_cb *, struct sk_buff *, int *, int *, int *);\nvoid ax25_send_control(ax25_cb *, int, int, int);\nvoid ax25_return_dm(struct net_device *, ax25_address *, ax25_address *,\n\t\t    ax25_digi *);\nvoid ax25_calculate_t1(ax25_cb *);\nvoid ax25_calculate_rtt(ax25_cb *);\nvoid ax25_disconnect(ax25_cb *, int);\n\n \nvoid ax25_setup_timers(ax25_cb *);\nvoid ax25_start_heartbeat(ax25_cb *);\nvoid ax25_start_t1timer(ax25_cb *);\nvoid ax25_start_t2timer(ax25_cb *);\nvoid ax25_start_t3timer(ax25_cb *);\nvoid ax25_start_idletimer(ax25_cb *);\nvoid ax25_stop_heartbeat(ax25_cb *);\nvoid ax25_stop_t1timer(ax25_cb *);\nvoid ax25_stop_t2timer(ax25_cb *);\nvoid ax25_stop_t3timer(ax25_cb *);\nvoid ax25_stop_idletimer(ax25_cb *);\nint ax25_t1timer_running(ax25_cb *);\nunsigned long ax25_display_timer(struct timer_list *);\n\n \nextern int  ax25_uid_policy;\nax25_uid_assoc *ax25_findbyuid(kuid_t);\nint __must_check ax25_uid_ioctl(int, struct sockaddr_ax25 *);\nextern const struct seq_operations ax25_uid_seqops;\nvoid ax25_uid_free(void);\n\n \n#ifdef CONFIG_SYSCTL\nint ax25_register_dev_sysctl(ax25_dev *ax25_dev);\nvoid ax25_unregister_dev_sysctl(ax25_dev *ax25_dev);\n#else\nstatic inline int ax25_register_dev_sysctl(ax25_dev *ax25_dev) { return 0; }\nstatic inline void ax25_unregister_dev_sysctl(ax25_dev *ax25_dev) {}\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}