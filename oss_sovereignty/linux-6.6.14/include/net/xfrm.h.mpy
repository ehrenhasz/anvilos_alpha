{
  "module_name": "xfrm.h",
  "hash_id": "49b33b7fc5b5df8b0e2c1adc65d33987a21795de9de4b4fce953f47aa701fd2b",
  "original_prompt": "Ingested from linux-6.6.14/include/net/xfrm.h",
  "human_readable_source": " \n#ifndef _NET_XFRM_H\n#define _NET_XFRM_H\n\n#include <linux/compiler.h>\n#include <linux/xfrm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/pfkeyv2.h>\n#include <linux/ipsec.h>\n#include <linux/in6.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/sockptr.h>\n\n#include <net/sock.h>\n#include <net/dst.h>\n#include <net/ip.h>\n#include <net/route.h>\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/flow.h>\n#include <net/gro_cells.h>\n\n#include <linux/interrupt.h>\n\n#ifdef CONFIG_XFRM_STATISTICS\n#include <net/snmp.h>\n#endif\n\n#define XFRM_PROTO_ESP\t\t50\n#define XFRM_PROTO_AH\t\t51\n#define XFRM_PROTO_COMP\t\t108\n#define XFRM_PROTO_IPIP\t\t4\n#define XFRM_PROTO_IPV6\t\t41\n#define XFRM_PROTO_ROUTING\tIPPROTO_ROUTING\n#define XFRM_PROTO_DSTOPTS\tIPPROTO_DSTOPTS\n\n#define XFRM_ALIGN4(len)\t(((len) + 3) & ~3)\n#define XFRM_ALIGN8(len)\t(((len) + 7) & ~7)\n#define MODULE_ALIAS_XFRM_MODE(family, encap) \\\n\tMODULE_ALIAS(\"xfrm-mode-\" __stringify(family) \"-\" __stringify(encap))\n#define MODULE_ALIAS_XFRM_TYPE(family, proto) \\\n\tMODULE_ALIAS(\"xfrm-type-\" __stringify(family) \"-\" __stringify(proto))\n#define MODULE_ALIAS_XFRM_OFFLOAD_TYPE(family, proto) \\\n\tMODULE_ALIAS(\"xfrm-offload-\" __stringify(family) \"-\" __stringify(proto))\n\n#ifdef CONFIG_XFRM_STATISTICS\n#define XFRM_INC_STATS(net, field)\tSNMP_INC_STATS((net)->mib.xfrm_statistics, field)\n#else\n#define XFRM_INC_STATS(net, field)\t((void)(net))\n#endif\n\n\n \n\nstruct xfrm_state_walk {\n\tstruct list_head\tall;\n\tu8\t\t\tstate;\n\tu8\t\t\tdying;\n\tu8\t\t\tproto;\n\tu32\t\t\tseq;\n\tstruct xfrm_address_filter *filter;\n};\n\nenum {\n\tXFRM_DEV_OFFLOAD_IN = 1,\n\tXFRM_DEV_OFFLOAD_OUT,\n\tXFRM_DEV_OFFLOAD_FWD,\n};\n\nenum {\n\tXFRM_DEV_OFFLOAD_UNSPECIFIED,\n\tXFRM_DEV_OFFLOAD_CRYPTO,\n\tXFRM_DEV_OFFLOAD_PACKET,\n};\n\nenum {\n\tXFRM_DEV_OFFLOAD_FLAG_ACQ = 1,\n};\n\nstruct xfrm_dev_offload {\n\tstruct net_device\t*dev;\n\tnetdevice_tracker\tdev_tracker;\n\tstruct net_device\t*real_dev;\n\tunsigned long\t\toffload_handle;\n\tu8\t\t\tdir : 2;\n\tu8\t\t\ttype : 2;\n\tu8\t\t\tflags : 2;\n};\n\nstruct xfrm_mode {\n\tu8 encap;\n\tu8 family;\n\tu8 flags;\n};\n\n \nenum {\n\tXFRM_MODE_FLAG_TUNNEL = 1,\n};\n\nenum xfrm_replay_mode {\n\tXFRM_REPLAY_MODE_LEGACY,\n\tXFRM_REPLAY_MODE_BMP,\n\tXFRM_REPLAY_MODE_ESN,\n};\n\n \nstruct xfrm_state {\n\tpossible_net_t\t\txs_net;\n\tunion {\n\t\tstruct hlist_node\tgclist;\n\t\tstruct hlist_node\tbydst;\n\t};\n\tstruct hlist_node\tbysrc;\n\tstruct hlist_node\tbyspi;\n\tstruct hlist_node\tbyseq;\n\n\trefcount_t\t\trefcnt;\n\tspinlock_t\t\tlock;\n\n\tstruct xfrm_id\t\tid;\n\tstruct xfrm_selector\tsel;\n\tstruct xfrm_mark\tmark;\n\tu32\t\t\tif_id;\n\tu32\t\t\ttfcpad;\n\n\tu32\t\t\tgenid;\n\n\t \n\tstruct xfrm_state_walk\tkm;\n\n\t \n\tstruct {\n\t\tu32\t\treqid;\n\t\tu8\t\tmode;\n\t\tu8\t\treplay_window;\n\t\tu8\t\taalgo, ealgo, calgo;\n\t\tu8\t\tflags;\n\t\tu16\t\tfamily;\n\t\txfrm_address_t\tsaddr;\n\t\tint\t\theader_len;\n\t\tint\t\ttrailer_len;\n\t\tu32\t\textra_flags;\n\t\tstruct xfrm_mark\tsmark;\n\t} props;\n\n\tstruct xfrm_lifetime_cfg lft;\n\n\t \n\tstruct xfrm_algo_auth\t*aalg;\n\tstruct xfrm_algo\t*ealg;\n\tstruct xfrm_algo\t*calg;\n\tstruct xfrm_algo_aead\t*aead;\n\tconst char\t\t*geniv;\n\n\t \n\t__be16 new_mapping_sport;\n\tu32 new_mapping;\t \n\tu32 mapping_maxage;\t \n\n\t \n\tstruct xfrm_encap_tmpl\t*encap;\n\tstruct sock __rcu\t*encap_sk;\n\n\t \n\txfrm_address_t\t*coaddr;\n\n\t \n\tstruct xfrm_state\t*tunnel;\n\n\t \n\tatomic_t\t\ttunnel_users;\n\n\t \n\tstruct xfrm_replay_state replay;\n\tstruct xfrm_replay_state_esn *replay_esn;\n\n\t \n\tstruct xfrm_replay_state preplay;\n\tstruct xfrm_replay_state_esn *preplay_esn;\n\n\t \n\tenum xfrm_replay_mode    repl_mode;\n\t \n\tu32\t\t\txflags;\n\n\t \n\tu32\t\t\treplay_maxage;\n\tu32\t\t\treplay_maxdiff;\n\n\t \n\tstruct timer_list\trtimer;\n\n\t \n\tstruct xfrm_stats\tstats;\n\n\tstruct xfrm_lifetime_cur curlft;\n\tstruct hrtimer\t\tmtimer;\n\n\tstruct xfrm_dev_offload xso;\n\n\t \n\tlong\t\tsaved_tmo;\n\n\t \n\ttime64_t\t\tlastused;\n\n\tstruct page_frag xfrag;\n\n\t \n\tconst struct xfrm_type\t*type;\n\tstruct xfrm_mode\tinner_mode;\n\tstruct xfrm_mode\tinner_mode_iaf;\n\tstruct xfrm_mode\touter_mode;\n\n\tconst struct xfrm_type_offload\t*type_offload;\n\n\t \n\tstruct xfrm_sec_ctx\t*security;\n\n\t \n\tvoid\t\t\t*data;\n};\n\nstatic inline struct net *xs_net(struct xfrm_state *x)\n{\n\treturn read_pnet(&x->xs_net);\n}\n\n \n#define XFRM_TIME_DEFER\t1\n#define XFRM_SOFT_EXPIRE 2\n\nenum {\n\tXFRM_STATE_VOID,\n\tXFRM_STATE_ACQ,\n\tXFRM_STATE_VALID,\n\tXFRM_STATE_ERROR,\n\tXFRM_STATE_EXPIRED,\n\tXFRM_STATE_DEAD\n};\n\n \nstruct km_event {\n\tunion {\n\t\tu32 hard;\n\t\tu32 proto;\n\t\tu32 byid;\n\t\tu32 aevent;\n\t\tu32 type;\n\t} data;\n\n\tu32\tseq;\n\tu32\tportid;\n\tu32\tevent;\n\tstruct net *net;\n};\n\nstruct xfrm_if_decode_session_result {\n\tstruct net *net;\n\tu32 if_id;\n};\n\nstruct xfrm_if_cb {\n\tbool (*decode_session)(struct sk_buff *skb,\n\t\t\t       unsigned short family,\n\t\t\t       struct xfrm_if_decode_session_result *res);\n};\n\nvoid xfrm_if_register_cb(const struct xfrm_if_cb *ifcb);\nvoid xfrm_if_unregister_cb(void);\n\nstruct net_device;\nstruct xfrm_type;\nstruct xfrm_dst;\nstruct xfrm_policy_afinfo {\n\tstruct dst_ops\t\t*dst_ops;\n\tstruct dst_entry\t*(*dst_lookup)(struct net *net,\n\t\t\t\t\t       int tos, int oif,\n\t\t\t\t\t       const xfrm_address_t *saddr,\n\t\t\t\t\t       const xfrm_address_t *daddr,\n\t\t\t\t\t       u32 mark);\n\tint\t\t\t(*get_saddr)(struct net *net, int oif,\n\t\t\t\t\t     xfrm_address_t *saddr,\n\t\t\t\t\t     xfrm_address_t *daddr,\n\t\t\t\t\t     u32 mark);\n\tint\t\t\t(*fill_dst)(struct xfrm_dst *xdst,\n\t\t\t\t\t    struct net_device *dev,\n\t\t\t\t\t    const struct flowi *fl);\n\tstruct dst_entry\t*(*blackhole_route)(struct net *net, struct dst_entry *orig);\n};\n\nint xfrm_policy_register_afinfo(const struct xfrm_policy_afinfo *afinfo, int family);\nvoid xfrm_policy_unregister_afinfo(const struct xfrm_policy_afinfo *afinfo);\nvoid km_policy_notify(struct xfrm_policy *xp, int dir,\n\t\t      const struct km_event *c);\nvoid km_state_notify(struct xfrm_state *x, const struct km_event *c);\n\nstruct xfrm_tmpl;\nint km_query(struct xfrm_state *x, struct xfrm_tmpl *t,\n\t     struct xfrm_policy *pol);\nvoid km_state_expired(struct xfrm_state *x, int hard, u32 portid);\nint __xfrm_state_delete(struct xfrm_state *x);\n\nstruct xfrm_state_afinfo {\n\tu8\t\t\t\tfamily;\n\tu8\t\t\t\tproto;\n\n\tconst struct xfrm_type_offload *type_offload_esp;\n\n\tconst struct xfrm_type\t\t*type_esp;\n\tconst struct xfrm_type\t\t*type_ipip;\n\tconst struct xfrm_type\t\t*type_ipip6;\n\tconst struct xfrm_type\t\t*type_comp;\n\tconst struct xfrm_type\t\t*type_ah;\n\tconst struct xfrm_type\t\t*type_routing;\n\tconst struct xfrm_type\t\t*type_dstopts;\n\n\tint\t\t\t(*output)(struct net *net, struct sock *sk, struct sk_buff *skb);\n\tint\t\t\t(*transport_finish)(struct sk_buff *skb,\n\t\t\t\t\t\t    int async);\n\tvoid\t\t\t(*local_error)(struct sk_buff *skb, u32 mtu);\n};\n\nint xfrm_state_register_afinfo(struct xfrm_state_afinfo *afinfo);\nint xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo);\nstruct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family);\nstruct xfrm_state_afinfo *xfrm_state_afinfo_get_rcu(unsigned int family);\n\nstruct xfrm_input_afinfo {\n\tu8\t\t\tfamily;\n\tbool\t\t\tis_ipip;\n\tint\t\t\t(*callback)(struct sk_buff *skb, u8 protocol,\n\t\t\t\t\t    int err);\n};\n\nint xfrm_input_register_afinfo(const struct xfrm_input_afinfo *afinfo);\nint xfrm_input_unregister_afinfo(const struct xfrm_input_afinfo *afinfo);\n\nvoid xfrm_flush_gc(void);\nvoid xfrm_state_delete_tunnel(struct xfrm_state *x);\n\nstruct xfrm_type {\n\tstruct module\t\t*owner;\n\tu8\t\t\tproto;\n\tu8\t\t\tflags;\n#define XFRM_TYPE_NON_FRAGMENT\t1\n#define XFRM_TYPE_REPLAY_PROT\t2\n#define XFRM_TYPE_LOCAL_COADDR\t4\n#define XFRM_TYPE_REMOTE_COADDR\t8\n\n\tint\t\t\t(*init_state)(struct xfrm_state *x,\n\t\t\t\t\t      struct netlink_ext_ack *extack);\n\tvoid\t\t\t(*destructor)(struct xfrm_state *);\n\tint\t\t\t(*input)(struct xfrm_state *, struct sk_buff *skb);\n\tint\t\t\t(*output)(struct xfrm_state *, struct sk_buff *pskb);\n\tint\t\t\t(*reject)(struct xfrm_state *, struct sk_buff *,\n\t\t\t\t\t  const struct flowi *);\n};\n\nint xfrm_register_type(const struct xfrm_type *type, unsigned short family);\nvoid xfrm_unregister_type(const struct xfrm_type *type, unsigned short family);\n\nstruct xfrm_type_offload {\n\tstruct module\t*owner;\n\tu8\t\tproto;\n\tvoid\t\t(*encap)(struct xfrm_state *, struct sk_buff *pskb);\n\tint\t\t(*input_tail)(struct xfrm_state *x, struct sk_buff *skb);\n\tint\t\t(*xmit)(struct xfrm_state *, struct sk_buff *pskb, netdev_features_t features);\n};\n\nint xfrm_register_type_offload(const struct xfrm_type_offload *type, unsigned short family);\nvoid xfrm_unregister_type_offload(const struct xfrm_type_offload *type, unsigned short family);\n\nstatic inline int xfrm_af2proto(unsigned int family)\n{\n\tswitch(family) {\n\tcase AF_INET:\n\t\treturn IPPROTO_IPIP;\n\tcase AF_INET6:\n\t\treturn IPPROTO_IPV6;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline const struct xfrm_mode *xfrm_ip2inner_mode(struct xfrm_state *x, int ipproto)\n{\n\tif ((ipproto == IPPROTO_IPIP && x->props.family == AF_INET) ||\n\t    (ipproto == IPPROTO_IPV6 && x->props.family == AF_INET6))\n\t\treturn &x->inner_mode;\n\telse\n\t\treturn &x->inner_mode_iaf;\n}\n\nstruct xfrm_tmpl {\n \n\tstruct xfrm_id\t\tid;\n\n \n\txfrm_address_t\t\tsaddr;\n\n\tunsigned short\t\tencap_family;\n\n\tu32\t\t\treqid;\n\n \n\tu8\t\t\tmode;\n\n \n\tu8\t\t\tshare;\n\n \n\tu8\t\t\toptional;\n\n \n\tu8\t\t\tallalgs;\n\n \n\tu32\t\t\taalgos;\n\tu32\t\t\tealgos;\n\tu32\t\t\tcalgos;\n};\n\n#define XFRM_MAX_DEPTH\t\t6\n#define XFRM_MAX_OFFLOAD_DEPTH\t1\n\nstruct xfrm_policy_walk_entry {\n\tstruct list_head\tall;\n\tu8\t\t\tdead;\n};\n\nstruct xfrm_policy_walk {\n\tstruct xfrm_policy_walk_entry walk;\n\tu8 type;\n\tu32 seq;\n};\n\nstruct xfrm_policy_queue {\n\tstruct sk_buff_head\thold_queue;\n\tstruct timer_list\thold_timer;\n\tunsigned long\t\ttimeout;\n};\n\nstruct xfrm_policy {\n\tpossible_net_t\t\txp_net;\n\tstruct hlist_node\tbydst;\n\tstruct hlist_node\tbyidx;\n\n\t \n\trwlock_t\t\tlock;\n\trefcount_t\t\trefcnt;\n\tu32\t\t\tpos;\n\tstruct timer_list\ttimer;\n\n\tatomic_t\t\tgenid;\n\tu32\t\t\tpriority;\n\tu32\t\t\tindex;\n\tu32\t\t\tif_id;\n\tstruct xfrm_mark\tmark;\n\tstruct xfrm_selector\tselector;\n\tstruct xfrm_lifetime_cfg lft;\n\tstruct xfrm_lifetime_cur curlft;\n\tstruct xfrm_policy_walk_entry walk;\n\tstruct xfrm_policy_queue polq;\n\tbool                    bydst_reinsert;\n\tu8\t\t\ttype;\n\tu8\t\t\taction;\n\tu8\t\t\tflags;\n\tu8\t\t\txfrm_nr;\n\tu16\t\t\tfamily;\n\tstruct xfrm_sec_ctx\t*security;\n\tstruct xfrm_tmpl       \txfrm_vec[XFRM_MAX_DEPTH];\n\tstruct hlist_node\tbydst_inexact_list;\n\tstruct rcu_head\t\trcu;\n\n\tstruct xfrm_dev_offload xdo;\n};\n\nstatic inline struct net *xp_net(const struct xfrm_policy *xp)\n{\n\treturn read_pnet(&xp->xp_net);\n}\n\nstruct xfrm_kmaddress {\n\txfrm_address_t          local;\n\txfrm_address_t          remote;\n\tu32\t\t\treserved;\n\tu16\t\t\tfamily;\n};\n\nstruct xfrm_migrate {\n\txfrm_address_t\t\told_daddr;\n\txfrm_address_t\t\told_saddr;\n\txfrm_address_t\t\tnew_daddr;\n\txfrm_address_t\t\tnew_saddr;\n\tu8\t\t\tproto;\n\tu8\t\t\tmode;\n\tu16\t\t\treserved;\n\tu32\t\t\treqid;\n\tu16\t\t\told_family;\n\tu16\t\t\tnew_family;\n};\n\n#define XFRM_KM_TIMEOUT                30\n \n#define XFRM_REPLAY_UPDATE\tXFRM_AE_CR\n#define XFRM_REPLAY_TIMEOUT\tXFRM_AE_CE\n\n \n#define XFRM_AE_ETIME\t\t\t10\n \n#define XFRM_AE_ETH_M\t\t\t10\n \n#define XFRM_AE_SEQT_SIZE\t\t2\n\nstruct xfrm_mgr {\n\tstruct list_head\tlist;\n\tint\t\t\t(*notify)(struct xfrm_state *x, const struct km_event *c);\n\tint\t\t\t(*acquire)(struct xfrm_state *x, struct xfrm_tmpl *, struct xfrm_policy *xp);\n\tstruct xfrm_policy\t*(*compile_policy)(struct sock *sk, int opt, u8 *data, int len, int *dir);\n\tint\t\t\t(*new_mapping)(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport);\n\tint\t\t\t(*notify_policy)(struct xfrm_policy *x, int dir, const struct km_event *c);\n\tint\t\t\t(*report)(struct net *net, u8 proto, struct xfrm_selector *sel, xfrm_address_t *addr);\n\tint\t\t\t(*migrate)(const struct xfrm_selector *sel,\n\t\t\t\t\t   u8 dir, u8 type,\n\t\t\t\t\t   const struct xfrm_migrate *m,\n\t\t\t\t\t   int num_bundles,\n\t\t\t\t\t   const struct xfrm_kmaddress *k,\n\t\t\t\t\t   const struct xfrm_encap_tmpl *encap);\n\tbool\t\t\t(*is_alive)(const struct km_event *c);\n};\n\nvoid xfrm_register_km(struct xfrm_mgr *km);\nvoid xfrm_unregister_km(struct xfrm_mgr *km);\n\nstruct xfrm_tunnel_skb_cb {\n\tunion {\n\t\tstruct inet_skb_parm h4;\n\t\tstruct inet6_skb_parm h6;\n\t} header;\n\n\tunion {\n\t\tstruct ip_tunnel *ip4;\n\t\tstruct ip6_tnl *ip6;\n\t} tunnel;\n};\n\n#define XFRM_TUNNEL_SKB_CB(__skb) ((struct xfrm_tunnel_skb_cb *)&((__skb)->cb[0]))\n\n \nstruct xfrm_skb_cb {\n\tstruct xfrm_tunnel_skb_cb header;\n\n         \n\tunion {\n\t\tstruct {\n\t\t\t__u32 low;\n\t\t\t__u32 hi;\n\t\t} output;\n\t\tstruct {\n\t\t\t__be32 low;\n\t\t\t__be32 hi;\n\t\t} input;\n\t} seq;\n};\n\n#define XFRM_SKB_CB(__skb) ((struct xfrm_skb_cb *)&((__skb)->cb[0]))\n\n \nstruct xfrm_mode_skb_cb {\n\tstruct xfrm_tunnel_skb_cb header;\n\n\t \n\t__be16 id;\n\t__be16 frag_off;\n\n\t \n\tu8 ihl;\n\n\t \n\tu8 tos;\n\n\t \n\tu8 ttl;\n\n\t \n\tu8 protocol;\n\n\t \n\tu8 optlen;\n\n\t \n\tu8 flow_lbl[3];\n};\n\n#define XFRM_MODE_SKB_CB(__skb) ((struct xfrm_mode_skb_cb *)&((__skb)->cb[0]))\n\n \nstruct xfrm_spi_skb_cb {\n\tstruct xfrm_tunnel_skb_cb header;\n\n\tunsigned int daddroff;\n\tunsigned int family;\n\t__be32 seq;\n};\n\n#define XFRM_SPI_SKB_CB(__skb) ((struct xfrm_spi_skb_cb *)&((__skb)->cb[0]))\n\n#ifdef CONFIG_AUDITSYSCALL\nstatic inline struct audit_buffer *xfrm_audit_start(const char *op)\n{\n\tstruct audit_buffer *audit_buf = NULL;\n\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn NULL;\n\taudit_buf = audit_log_start(audit_context(), GFP_ATOMIC,\n\t\t\t\t    AUDIT_MAC_IPSEC_EVENT);\n\tif (audit_buf == NULL)\n\t\treturn NULL;\n\taudit_log_format(audit_buf, \"op=%s\", op);\n\treturn audit_buf;\n}\n\nstatic inline void xfrm_audit_helper_usrinfo(bool task_valid,\n\t\t\t\t\t     struct audit_buffer *audit_buf)\n{\n\tconst unsigned int auid = from_kuid(&init_user_ns, task_valid ?\n\t\t\t\t\t    audit_get_loginuid(current) :\n\t\t\t\t\t    INVALID_UID);\n\tconst unsigned int ses = task_valid ? audit_get_sessionid(current) :\n\t\tAUDIT_SID_UNSET;\n\n\taudit_log_format(audit_buf, \" auid=%u ses=%u\", auid, ses);\n\taudit_log_task_context(audit_buf);\n}\n\nvoid xfrm_audit_policy_add(struct xfrm_policy *xp, int result, bool task_valid);\nvoid xfrm_audit_policy_delete(struct xfrm_policy *xp, int result,\n\t\t\t      bool task_valid);\nvoid xfrm_audit_state_add(struct xfrm_state *x, int result, bool task_valid);\nvoid xfrm_audit_state_delete(struct xfrm_state *x, int result, bool task_valid);\nvoid xfrm_audit_state_replay_overflow(struct xfrm_state *x,\n\t\t\t\t      struct sk_buff *skb);\nvoid xfrm_audit_state_replay(struct xfrm_state *x, struct sk_buff *skb,\n\t\t\t     __be32 net_seq);\nvoid xfrm_audit_state_notfound_simple(struct sk_buff *skb, u16 family);\nvoid xfrm_audit_state_notfound(struct sk_buff *skb, u16 family, __be32 net_spi,\n\t\t\t       __be32 net_seq);\nvoid xfrm_audit_state_icvfail(struct xfrm_state *x, struct sk_buff *skb,\n\t\t\t      u8 proto);\n#else\n\nstatic inline void xfrm_audit_policy_add(struct xfrm_policy *xp, int result,\n\t\t\t\t\t bool task_valid)\n{\n}\n\nstatic inline void xfrm_audit_policy_delete(struct xfrm_policy *xp, int result,\n\t\t\t\t\t    bool task_valid)\n{\n}\n\nstatic inline void xfrm_audit_state_add(struct xfrm_state *x, int result,\n\t\t\t\t\tbool task_valid)\n{\n}\n\nstatic inline void xfrm_audit_state_delete(struct xfrm_state *x, int result,\n\t\t\t\t\t   bool task_valid)\n{\n}\n\nstatic inline void xfrm_audit_state_replay_overflow(struct xfrm_state *x,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n}\n\nstatic inline void xfrm_audit_state_replay(struct xfrm_state *x,\n\t\t\t\t\t   struct sk_buff *skb, __be32 net_seq)\n{\n}\n\nstatic inline void xfrm_audit_state_notfound_simple(struct sk_buff *skb,\n\t\t\t\t      u16 family)\n{\n}\n\nstatic inline void xfrm_audit_state_notfound(struct sk_buff *skb, u16 family,\n\t\t\t\t      __be32 net_spi, __be32 net_seq)\n{\n}\n\nstatic inline void xfrm_audit_state_icvfail(struct xfrm_state *x,\n\t\t\t\t     struct sk_buff *skb, u8 proto)\n{\n}\n#endif  \n\nstatic inline void xfrm_pol_hold(struct xfrm_policy *policy)\n{\n\tif (likely(policy != NULL))\n\t\trefcount_inc(&policy->refcnt);\n}\n\nvoid xfrm_policy_destroy(struct xfrm_policy *policy);\n\nstatic inline void xfrm_pol_put(struct xfrm_policy *policy)\n{\n\tif (refcount_dec_and_test(&policy->refcnt))\n\t\txfrm_policy_destroy(policy);\n}\n\nstatic inline void xfrm_pols_put(struct xfrm_policy **pols, int npols)\n{\n\tint i;\n\tfor (i = npols - 1; i >= 0; --i)\n\t\txfrm_pol_put(pols[i]);\n}\n\nvoid __xfrm_state_destroy(struct xfrm_state *, bool);\n\nstatic inline void __xfrm_state_put(struct xfrm_state *x)\n{\n\trefcount_dec(&x->refcnt);\n}\n\nstatic inline void xfrm_state_put(struct xfrm_state *x)\n{\n\tif (refcount_dec_and_test(&x->refcnt))\n\t\t__xfrm_state_destroy(x, false);\n}\n\nstatic inline void xfrm_state_put_sync(struct xfrm_state *x)\n{\n\tif (refcount_dec_and_test(&x->refcnt))\n\t\t__xfrm_state_destroy(x, true);\n}\n\nstatic inline void xfrm_state_hold(struct xfrm_state *x)\n{\n\trefcount_inc(&x->refcnt);\n}\n\nstatic inline bool addr_match(const void *token1, const void *token2,\n\t\t\t      unsigned int prefixlen)\n{\n\tconst __be32 *a1 = token1;\n\tconst __be32 *a2 = token2;\n\tunsigned int pdw;\n\tunsigned int pbi;\n\n\tpdw = prefixlen >> 5;\t   \n\tpbi = prefixlen &  0x1f;   \n\n\tif (pdw)\n\t\tif (memcmp(a1, a2, pdw << 2))\n\t\t\treturn false;\n\n\tif (pbi) {\n\t\t__be32 mask;\n\n\t\tmask = htonl((0xffffffff) << (32 - pbi));\n\n\t\tif ((a1[pdw] ^ a2[pdw]) & mask)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline bool addr4_match(__be32 a1, __be32 a2, u8 prefixlen)\n{\n\t \n\tif (sizeof(long) == 4 && prefixlen == 0)\n\t\treturn true;\n\treturn !((a1 ^ a2) & htonl(~0UL << (32 - prefixlen)));\n}\n\nstatic __inline__\n__be16 xfrm_flowi_sport(const struct flowi *fl, const union flowi_uli *uli)\n{\n\t__be16 port;\n\tswitch(fl->flowi_proto) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\tcase IPPROTO_SCTP:\n\t\tport = uli->ports.sport;\n\t\tbreak;\n\tcase IPPROTO_ICMP:\n\tcase IPPROTO_ICMPV6:\n\t\tport = htons(uli->icmpt.type);\n\t\tbreak;\n\tcase IPPROTO_MH:\n\t\tport = htons(uli->mht.type);\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\tport = htons(ntohl(uli->gre_key) >> 16);\n\t\tbreak;\n\tdefault:\n\t\tport = 0;\t \n\t}\n\treturn port;\n}\n\nstatic __inline__\n__be16 xfrm_flowi_dport(const struct flowi *fl, const union flowi_uli *uli)\n{\n\t__be16 port;\n\tswitch(fl->flowi_proto) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\tcase IPPROTO_SCTP:\n\t\tport = uli->ports.dport;\n\t\tbreak;\n\tcase IPPROTO_ICMP:\n\tcase IPPROTO_ICMPV6:\n\t\tport = htons(uli->icmpt.code);\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\tport = htons(ntohl(uli->gre_key) & 0xffff);\n\t\tbreak;\n\tdefault:\n\t\tport = 0;\t \n\t}\n\treturn port;\n}\n\nbool xfrm_selector_match(const struct xfrm_selector *sel,\n\t\t\t const struct flowi *fl, unsigned short family);\n\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n \nstatic inline bool xfrm_sec_ctx_match(struct xfrm_sec_ctx *s1, struct xfrm_sec_ctx *s2)\n{\n\treturn ((!s1 && !s2) ||\n\t\t(s1 && s2 &&\n\t\t (s1->ctx_sid == s2->ctx_sid) &&\n\t\t (s1->ctx_doi == s2->ctx_doi) &&\n\t\t (s1->ctx_alg == s2->ctx_alg)));\n}\n#else\nstatic inline bool xfrm_sec_ctx_match(struct xfrm_sec_ctx *s1, struct xfrm_sec_ctx *s2)\n{\n\treturn true;\n}\n#endif\n\n \nstruct xfrm_dst {\n\tunion {\n\t\tstruct dst_entry\tdst;\n\t\tstruct rtable\t\trt;\n\t\tstruct rt6_info\t\trt6;\n\t} u;\n\tstruct dst_entry *route;\n\tstruct dst_entry *child;\n\tstruct dst_entry *path;\n\tstruct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];\n\tint num_pols, num_xfrms;\n\tu32 xfrm_genid;\n\tu32 policy_genid;\n\tu32 route_mtu_cached;\n\tu32 child_mtu_cached;\n\tu32 route_cookie;\n\tu32 path_cookie;\n};\n\nstatic inline struct dst_entry *xfrm_dst_path(const struct dst_entry *dst)\n{\n#ifdef CONFIG_XFRM\n\tif (dst->xfrm || (dst->flags & DST_XFRM_QUEUE)) {\n\t\tconst struct xfrm_dst *xdst = (const struct xfrm_dst *) dst;\n\n\t\treturn xdst->path;\n\t}\n#endif\n\treturn (struct dst_entry *) dst;\n}\n\nstatic inline struct dst_entry *xfrm_dst_child(const struct dst_entry *dst)\n{\n#ifdef CONFIG_XFRM\n\tif (dst->xfrm || (dst->flags & DST_XFRM_QUEUE)) {\n\t\tstruct xfrm_dst *xdst = (struct xfrm_dst *) dst;\n\t\treturn xdst->child;\n\t}\n#endif\n\treturn NULL;\n}\n\n#ifdef CONFIG_XFRM\nstatic inline void xfrm_dst_set_child(struct xfrm_dst *xdst, struct dst_entry *child)\n{\n\txdst->child = child;\n}\n\nstatic inline void xfrm_dst_destroy(struct xfrm_dst *xdst)\n{\n\txfrm_pols_put(xdst->pols, xdst->num_pols);\n\tdst_release(xdst->route);\n\tif (likely(xdst->u.dst.xfrm))\n\t\txfrm_state_put(xdst->u.dst.xfrm);\n}\n#endif\n\nvoid xfrm_dst_ifdown(struct dst_entry *dst, struct net_device *dev);\n\nstruct xfrm_if_parms {\n\tint link;\t\t \n\tu32 if_id;\t\t \n\tbool collect_md;\n};\n\nstruct xfrm_if {\n\tstruct xfrm_if __rcu *next;\t \n\tstruct net_device *dev;\t\t \n\tstruct net *net;\t\t \n\tstruct xfrm_if_parms p;\t\t \n\n\tstruct gro_cells gro_cells;\n};\n\nstruct xfrm_offload {\n\t \n\tstruct {\n\t\t__u32 low;\n\t\t__u32 hi;\n\t} seq;\n\n\t__u32\t\t\tflags;\n#define\tSA_DELETE_REQ\t\t1\n#define\tCRYPTO_DONE\t\t2\n#define\tCRYPTO_NEXT_DONE\t4\n#define\tCRYPTO_FALLBACK\t\t8\n#define\tXFRM_GSO_SEGMENT\t16\n#define\tXFRM_GRO\t\t32\n \n#define\tXFRM_DEV_RESUME\t\t128\n#define\tXFRM_XMIT\t\t256\n\n\t__u32\t\t\tstatus;\n#define CRYPTO_SUCCESS\t\t\t\t1\n#define CRYPTO_GENERIC_ERROR\t\t\t2\n#define CRYPTO_TRANSPORT_AH_AUTH_FAILED\t\t4\n#define CRYPTO_TRANSPORT_ESP_AUTH_FAILED\t8\n#define CRYPTO_TUNNEL_AH_AUTH_FAILED\t\t16\n#define CRYPTO_TUNNEL_ESP_AUTH_FAILED\t\t32\n#define CRYPTO_INVALID_PACKET_SYNTAX\t\t64\n#define CRYPTO_INVALID_PROTOCOL\t\t\t128\n\n\t__u8\t\t\tproto;\n\t__u8\t\t\tinner_ipproto;\n};\n\nstruct sec_path {\n\tint\t\t\tlen;\n\tint\t\t\tolen;\n\tint\t\t\tverified_cnt;\n\n\tstruct xfrm_state\t*xvec[XFRM_MAX_DEPTH];\n\tstruct xfrm_offload\tovec[XFRM_MAX_OFFLOAD_DEPTH];\n};\n\nstruct sec_path *secpath_set(struct sk_buff *skb);\n\nstatic inline void\nsecpath_reset(struct sk_buff *skb)\n{\n#ifdef CONFIG_XFRM\n\tskb_ext_del(skb, SKB_EXT_SEC_PATH);\n#endif\n}\n\nstatic inline int\nxfrm_addr_any(const xfrm_address_t *addr, unsigned short family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn addr->a4 == 0;\n\tcase AF_INET6:\n\t\treturn ipv6_addr_any(&addr->in6);\n\t}\n\treturn 0;\n}\n\nstatic inline int\n__xfrm4_state_addr_cmp(const struct xfrm_tmpl *tmpl, const struct xfrm_state *x)\n{\n\treturn\t(tmpl->saddr.a4 &&\n\t\t tmpl->saddr.a4 != x->props.saddr.a4);\n}\n\nstatic inline int\n__xfrm6_state_addr_cmp(const struct xfrm_tmpl *tmpl, const struct xfrm_state *x)\n{\n\treturn\t(!ipv6_addr_any((struct in6_addr*)&tmpl->saddr) &&\n\t\t !ipv6_addr_equal((struct in6_addr *)&tmpl->saddr, (struct in6_addr*)&x->props.saddr));\n}\n\nstatic inline int\nxfrm_state_addr_cmp(const struct xfrm_tmpl *tmpl, const struct xfrm_state *x, unsigned short family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn __xfrm4_state_addr_cmp(tmpl, x);\n\tcase AF_INET6:\n\t\treturn __xfrm6_state_addr_cmp(tmpl, x);\n\t}\n\treturn !0;\n}\n\n#ifdef CONFIG_XFRM\nstatic inline struct xfrm_state *xfrm_input_state(struct sk_buff *skb)\n{\n\tstruct sec_path *sp = skb_sec_path(skb);\n\n\treturn sp->xvec[sp->len - 1];\n}\n#endif\n\nstatic inline struct xfrm_offload *xfrm_offload(struct sk_buff *skb)\n{\n#ifdef CONFIG_XFRM\n\tstruct sec_path *sp = skb_sec_path(skb);\n\n\tif (!sp || !sp->olen || sp->len != sp->olen)\n\t\treturn NULL;\n\n\treturn &sp->ovec[sp->olen - 1];\n#else\n\treturn NULL;\n#endif\n}\n\n#ifdef CONFIG_XFRM\nint __xfrm_policy_check(struct sock *, int dir, struct sk_buff *skb,\n\t\t\tunsigned short family);\n\nstatic inline bool __xfrm_check_nopolicy(struct net *net, struct sk_buff *skb,\n\t\t\t\t\t int dir)\n{\n\tif (!net->xfrm.policy_count[dir] && !secpath_exists(skb))\n\t\treturn net->xfrm.policy_default[dir] == XFRM_USERPOLICY_ACCEPT;\n\n\treturn false;\n}\n\nstatic inline bool __xfrm_check_dev_nopolicy(struct sk_buff *skb,\n\t\t\t\t\t     int dir, unsigned short family)\n{\n\tif (dir != XFRM_POLICY_OUT && family == AF_INET) {\n\t\t \n\t\treturn IPCB(skb)->flags & IPSKB_NOPOLICY;\n\t}\n\treturn skb_dst(skb) && (skb_dst(skb)->flags & DST_NOPOLICY);\n}\n\nstatic inline int __xfrm_policy_check2(struct sock *sk, int dir,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       unsigned int family, int reverse)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tint ndir = dir | (reverse ? XFRM_POLICY_MASK + 1 : 0);\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tstruct xfrm_state *x;\n\n\tif (sk && sk->sk_policy[XFRM_POLICY_IN])\n\t\treturn __xfrm_policy_check(sk, ndir, skb, family);\n\n\tif (xo) {\n\t\tx = xfrm_input_state(skb);\n\t\tif (x->xso.type == XFRM_DEV_OFFLOAD_PACKET)\n\t\t\treturn (xo->flags & CRYPTO_DONE) &&\n\t\t\t       (xo->status & CRYPTO_SUCCESS);\n\t}\n\n\treturn __xfrm_check_nopolicy(net, skb, dir) ||\n\t       __xfrm_check_dev_nopolicy(skb, dir, family) ||\n\t       __xfrm_policy_check(sk, ndir, skb, family);\n}\n\nstatic inline int xfrm_policy_check(struct sock *sk, int dir, struct sk_buff *skb, unsigned short family)\n{\n\treturn __xfrm_policy_check2(sk, dir, skb, family, 0);\n}\n\nstatic inline int xfrm4_policy_check(struct sock *sk, int dir, struct sk_buff *skb)\n{\n\treturn xfrm_policy_check(sk, dir, skb, AF_INET);\n}\n\nstatic inline int xfrm6_policy_check(struct sock *sk, int dir, struct sk_buff *skb)\n{\n\treturn xfrm_policy_check(sk, dir, skb, AF_INET6);\n}\n\nstatic inline int xfrm4_policy_check_reverse(struct sock *sk, int dir,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\treturn __xfrm_policy_check2(sk, dir, skb, AF_INET, 1);\n}\n\nstatic inline int xfrm6_policy_check_reverse(struct sock *sk, int dir,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\treturn __xfrm_policy_check2(sk, dir, skb, AF_INET6, 1);\n}\n\nint __xfrm_decode_session(struct sk_buff *skb, struct flowi *fl,\n\t\t\t  unsigned int family, int reverse);\n\nstatic inline int xfrm_decode_session(struct sk_buff *skb, struct flowi *fl,\n\t\t\t\t      unsigned int family)\n{\n\treturn __xfrm_decode_session(skb, fl, family, 0);\n}\n\nstatic inline int xfrm_decode_session_reverse(struct sk_buff *skb,\n\t\t\t\t\t      struct flowi *fl,\n\t\t\t\t\t      unsigned int family)\n{\n\treturn __xfrm_decode_session(skb, fl, family, 1);\n}\n\nint __xfrm_route_forward(struct sk_buff *skb, unsigned short family);\n\nstatic inline int xfrm_route_forward(struct sk_buff *skb, unsigned short family)\n{\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (!net->xfrm.policy_count[XFRM_POLICY_OUT] &&\n\t    net->xfrm.policy_default[XFRM_POLICY_OUT] == XFRM_USERPOLICY_ACCEPT)\n\t\treturn true;\n\n\treturn (skb_dst(skb)->flags & DST_NOXFRM) ||\n\t       __xfrm_route_forward(skb, family);\n}\n\nstatic inline int xfrm4_route_forward(struct sk_buff *skb)\n{\n\treturn xfrm_route_forward(skb, AF_INET);\n}\n\nstatic inline int xfrm6_route_forward(struct sk_buff *skb)\n{\n\treturn xfrm_route_forward(skb, AF_INET6);\n}\n\nint __xfrm_sk_clone_policy(struct sock *sk, const struct sock *osk);\n\nstatic inline int xfrm_sk_clone_policy(struct sock *sk, const struct sock *osk)\n{\n\tif (!sk_fullsock(osk))\n\t\treturn 0;\n\tsk->sk_policy[0] = NULL;\n\tsk->sk_policy[1] = NULL;\n\tif (unlikely(osk->sk_policy[0] || osk->sk_policy[1]))\n\t\treturn __xfrm_sk_clone_policy(sk, osk);\n\treturn 0;\n}\n\nint xfrm_policy_delete(struct xfrm_policy *pol, int dir);\n\nstatic inline void xfrm_sk_free_policy(struct sock *sk)\n{\n\tstruct xfrm_policy *pol;\n\n\tpol = rcu_dereference_protected(sk->sk_policy[0], 1);\n\tif (unlikely(pol != NULL)) {\n\t\txfrm_policy_delete(pol, XFRM_POLICY_MAX);\n\t\tsk->sk_policy[0] = NULL;\n\t}\n\tpol = rcu_dereference_protected(sk->sk_policy[1], 1);\n\tif (unlikely(pol != NULL)) {\n\t\txfrm_policy_delete(pol, XFRM_POLICY_MAX+1);\n\t\tsk->sk_policy[1] = NULL;\n\t}\n}\n\n#else\n\nstatic inline void xfrm_sk_free_policy(struct sock *sk) {}\nstatic inline int xfrm_sk_clone_policy(struct sock *sk, const struct sock *osk) { return 0; }\nstatic inline int xfrm6_route_forward(struct sk_buff *skb) { return 1; }\nstatic inline int xfrm4_route_forward(struct sk_buff *skb) { return 1; }\nstatic inline int xfrm6_policy_check(struct sock *sk, int dir, struct sk_buff *skb)\n{\n\treturn 1;\n}\nstatic inline int xfrm4_policy_check(struct sock *sk, int dir, struct sk_buff *skb)\n{\n\treturn 1;\n}\nstatic inline int xfrm_policy_check(struct sock *sk, int dir, struct sk_buff *skb, unsigned short family)\n{\n\treturn 1;\n}\nstatic inline int xfrm_decode_session_reverse(struct sk_buff *skb,\n\t\t\t\t\t      struct flowi *fl,\n\t\t\t\t\t      unsigned int family)\n{\n\treturn -ENOSYS;\n}\nstatic inline int xfrm4_policy_check_reverse(struct sock *sk, int dir,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\treturn 1;\n}\nstatic inline int xfrm6_policy_check_reverse(struct sock *sk, int dir,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\treturn 1;\n}\n#endif\n\nstatic __inline__\nxfrm_address_t *xfrm_flowi_daddr(const struct flowi *fl, unsigned short family)\n{\n\tswitch (family){\n\tcase AF_INET:\n\t\treturn (xfrm_address_t *)&fl->u.ip4.daddr;\n\tcase AF_INET6:\n\t\treturn (xfrm_address_t *)&fl->u.ip6.daddr;\n\t}\n\treturn NULL;\n}\n\nstatic __inline__\nxfrm_address_t *xfrm_flowi_saddr(const struct flowi *fl, unsigned short family)\n{\n\tswitch (family){\n\tcase AF_INET:\n\t\treturn (xfrm_address_t *)&fl->u.ip4.saddr;\n\tcase AF_INET6:\n\t\treturn (xfrm_address_t *)&fl->u.ip6.saddr;\n\t}\n\treturn NULL;\n}\n\nstatic __inline__\nvoid xfrm_flowi_addr_get(const struct flowi *fl,\n\t\t\t xfrm_address_t *saddr, xfrm_address_t *daddr,\n\t\t\t unsigned short family)\n{\n\tswitch(family) {\n\tcase AF_INET:\n\t\tmemcpy(&saddr->a4, &fl->u.ip4.saddr, sizeof(saddr->a4));\n\t\tmemcpy(&daddr->a4, &fl->u.ip4.daddr, sizeof(daddr->a4));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsaddr->in6 = fl->u.ip6.saddr;\n\t\tdaddr->in6 = fl->u.ip6.daddr;\n\t\tbreak;\n\t}\n}\n\nstatic __inline__ int\n__xfrm4_state_addr_check(const struct xfrm_state *x,\n\t\t\t const xfrm_address_t *daddr, const xfrm_address_t *saddr)\n{\n\tif (daddr->a4 == x->id.daddr.a4 &&\n\t    (saddr->a4 == x->props.saddr.a4 || !saddr->a4 || !x->props.saddr.a4))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic __inline__ int\n__xfrm6_state_addr_check(const struct xfrm_state *x,\n\t\t\t const xfrm_address_t *daddr, const xfrm_address_t *saddr)\n{\n\tif (ipv6_addr_equal((struct in6_addr *)daddr, (struct in6_addr *)&x->id.daddr) &&\n\t    (ipv6_addr_equal((struct in6_addr *)saddr, (struct in6_addr *)&x->props.saddr) ||\n\t     ipv6_addr_any((struct in6_addr *)saddr) ||\n\t     ipv6_addr_any((struct in6_addr *)&x->props.saddr)))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic __inline__ int\nxfrm_state_addr_check(const struct xfrm_state *x,\n\t\t      const xfrm_address_t *daddr, const xfrm_address_t *saddr,\n\t\t      unsigned short family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn __xfrm4_state_addr_check(x, daddr, saddr);\n\tcase AF_INET6:\n\t\treturn __xfrm6_state_addr_check(x, daddr, saddr);\n\t}\n\treturn 0;\n}\n\nstatic __inline__ int\nxfrm_state_addr_flow_check(const struct xfrm_state *x, const struct flowi *fl,\n\t\t\t   unsigned short family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn __xfrm4_state_addr_check(x,\n\t\t\t\t\t\t(const xfrm_address_t *)&fl->u.ip4.daddr,\n\t\t\t\t\t\t(const xfrm_address_t *)&fl->u.ip4.saddr);\n\tcase AF_INET6:\n\t\treturn __xfrm6_state_addr_check(x,\n\t\t\t\t\t\t(const xfrm_address_t *)&fl->u.ip6.daddr,\n\t\t\t\t\t\t(const xfrm_address_t *)&fl->u.ip6.saddr);\n\t}\n\treturn 0;\n}\n\nstatic inline int xfrm_state_kern(const struct xfrm_state *x)\n{\n\treturn atomic_read(&x->tunnel_users);\n}\n\nstatic inline bool xfrm_id_proto_valid(u8 proto)\n{\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\tcase IPPROTO_ESP:\n\tcase IPPROTO_COMP:\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase IPPROTO_ROUTING:\n\tcase IPPROTO_DSTOPTS:\n#endif\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic inline int xfrm_id_proto_match(u8 proto, u8 userproto)\n{\n\treturn (!userproto || proto == userproto ||\n\t\t(userproto == IPSEC_PROTO_ANY && (proto == IPPROTO_AH ||\n\t\t\t\t\t\t  proto == IPPROTO_ESP ||\n\t\t\t\t\t\t  proto == IPPROTO_COMP)));\n}\n\n \nstruct xfrm_algo_aead_info {\n\tchar *geniv;\n\tu16 icv_truncbits;\n};\n\nstruct xfrm_algo_auth_info {\n\tu16 icv_truncbits;\n\tu16 icv_fullbits;\n};\n\nstruct xfrm_algo_encr_info {\n\tchar *geniv;\n\tu16 blockbits;\n\tu16 defkeybits;\n};\n\nstruct xfrm_algo_comp_info {\n\tu16 threshold;\n};\n\nstruct xfrm_algo_desc {\n\tchar *name;\n\tchar *compat;\n\tu8 available:1;\n\tu8 pfkey_supported:1;\n\tunion {\n\t\tstruct xfrm_algo_aead_info aead;\n\t\tstruct xfrm_algo_auth_info auth;\n\t\tstruct xfrm_algo_encr_info encr;\n\t\tstruct xfrm_algo_comp_info comp;\n\t} uinfo;\n\tstruct sadb_alg desc;\n};\n\n \nstruct xfrm4_protocol {\n\tint (*handler)(struct sk_buff *skb);\n\tint (*input_handler)(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t\t     int encap_type);\n\tint (*cb_handler)(struct sk_buff *skb, int err);\n\tint (*err_handler)(struct sk_buff *skb, u32 info);\n\n\tstruct xfrm4_protocol __rcu *next;\n\tint priority;\n};\n\nstruct xfrm6_protocol {\n\tint (*handler)(struct sk_buff *skb);\n\tint (*input_handler)(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t\t     int encap_type);\n\tint (*cb_handler)(struct sk_buff *skb, int err);\n\tint (*err_handler)(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t   u8 type, u8 code, int offset, __be32 info);\n\n\tstruct xfrm6_protocol __rcu *next;\n\tint priority;\n};\n\n \nstruct xfrm_tunnel {\n\tint (*handler)(struct sk_buff *skb);\n\tint (*cb_handler)(struct sk_buff *skb, int err);\n\tint (*err_handler)(struct sk_buff *skb, u32 info);\n\n\tstruct xfrm_tunnel __rcu *next;\n\tint priority;\n};\n\nstruct xfrm6_tunnel {\n\tint (*handler)(struct sk_buff *skb);\n\tint (*cb_handler)(struct sk_buff *skb, int err);\n\tint (*err_handler)(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t   u8 type, u8 code, int offset, __be32 info);\n\tstruct xfrm6_tunnel __rcu *next;\n\tint priority;\n};\n\nvoid xfrm_init(void);\nvoid xfrm4_init(void);\nint xfrm_state_init(struct net *net);\nvoid xfrm_state_fini(struct net *net);\nvoid xfrm4_state_init(void);\nvoid xfrm4_protocol_init(void);\n#ifdef CONFIG_XFRM\nint xfrm6_init(void);\nvoid xfrm6_fini(void);\nint xfrm6_state_init(void);\nvoid xfrm6_state_fini(void);\nint xfrm6_protocol_init(void);\nvoid xfrm6_protocol_fini(void);\n#else\nstatic inline int xfrm6_init(void)\n{\n\treturn 0;\n}\nstatic inline void xfrm6_fini(void)\n{\n\t;\n}\n#endif\n\n#ifdef CONFIG_XFRM_STATISTICS\nint xfrm_proc_init(struct net *net);\nvoid xfrm_proc_fini(struct net *net);\n#endif\n\nint xfrm_sysctl_init(struct net *net);\n#ifdef CONFIG_SYSCTL\nvoid xfrm_sysctl_fini(struct net *net);\n#else\nstatic inline void xfrm_sysctl_fini(struct net *net)\n{\n}\n#endif\n\nvoid xfrm_state_walk_init(struct xfrm_state_walk *walk, u8 proto,\n\t\t\t  struct xfrm_address_filter *filter);\nint xfrm_state_walk(struct net *net, struct xfrm_state_walk *walk,\n\t\t    int (*func)(struct xfrm_state *, int, void*), void *);\nvoid xfrm_state_walk_done(struct xfrm_state_walk *walk, struct net *net);\nstruct xfrm_state *xfrm_state_alloc(struct net *net);\nvoid xfrm_state_free(struct xfrm_state *x);\nstruct xfrm_state *xfrm_state_find(const xfrm_address_t *daddr,\n\t\t\t\t   const xfrm_address_t *saddr,\n\t\t\t\t   const struct flowi *fl,\n\t\t\t\t   struct xfrm_tmpl *tmpl,\n\t\t\t\t   struct xfrm_policy *pol, int *err,\n\t\t\t\t   unsigned short family, u32 if_id);\nstruct xfrm_state *xfrm_stateonly_find(struct net *net, u32 mark, u32 if_id,\n\t\t\t\t       xfrm_address_t *daddr,\n\t\t\t\t       xfrm_address_t *saddr,\n\t\t\t\t       unsigned short family,\n\t\t\t\t       u8 mode, u8 proto, u32 reqid);\nstruct xfrm_state *xfrm_state_lookup_byspi(struct net *net, __be32 spi,\n\t\t\t\t\t      unsigned short family);\nint xfrm_state_check_expire(struct xfrm_state *x);\n#ifdef CONFIG_XFRM_OFFLOAD\nstatic inline void xfrm_dev_state_update_curlft(struct xfrm_state *x)\n{\n\tstruct xfrm_dev_offload *xdo = &x->xso;\n\tstruct net_device *dev = xdo->dev;\n\n\tif (x->xso.type != XFRM_DEV_OFFLOAD_PACKET)\n\t\treturn;\n\n\tif (dev && dev->xfrmdev_ops &&\n\t    dev->xfrmdev_ops->xdo_dev_state_update_curlft)\n\t\tdev->xfrmdev_ops->xdo_dev_state_update_curlft(x);\n\n}\n#else\nstatic inline void xfrm_dev_state_update_curlft(struct xfrm_state *x) {}\n#endif\nvoid xfrm_state_insert(struct xfrm_state *x);\nint xfrm_state_add(struct xfrm_state *x);\nint xfrm_state_update(struct xfrm_state *x);\nstruct xfrm_state *xfrm_state_lookup(struct net *net, u32 mark,\n\t\t\t\t     const xfrm_address_t *daddr, __be32 spi,\n\t\t\t\t     u8 proto, unsigned short family);\nstruct xfrm_state *xfrm_state_lookup_byaddr(struct net *net, u32 mark,\n\t\t\t\t\t    const xfrm_address_t *daddr,\n\t\t\t\t\t    const xfrm_address_t *saddr,\n\t\t\t\t\t    u8 proto,\n\t\t\t\t\t    unsigned short family);\n#ifdef CONFIG_XFRM_SUB_POLICY\nvoid xfrm_tmpl_sort(struct xfrm_tmpl **dst, struct xfrm_tmpl **src, int n,\n\t\t    unsigned short family);\nvoid xfrm_state_sort(struct xfrm_state **dst, struct xfrm_state **src, int n,\n\t\t     unsigned short family);\n#else\nstatic inline void xfrm_tmpl_sort(struct xfrm_tmpl **d, struct xfrm_tmpl **s,\n\t\t\t\t  int n, unsigned short family)\n{\n}\n\nstatic inline void xfrm_state_sort(struct xfrm_state **d, struct xfrm_state **s,\n\t\t\t\t   int n, unsigned short family)\n{\n}\n#endif\n\nstruct xfrmk_sadinfo {\n\tu32 sadhcnt;  \n\tu32 sadhmcnt;  \n\tu32 sadcnt;  \n};\n\nstruct xfrmk_spdinfo {\n\tu32 incnt;\n\tu32 outcnt;\n\tu32 fwdcnt;\n\tu32 inscnt;\n\tu32 outscnt;\n\tu32 fwdscnt;\n\tu32 spdhcnt;\n\tu32 spdhmcnt;\n};\n\nstruct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq);\nint xfrm_state_delete(struct xfrm_state *x);\nint xfrm_state_flush(struct net *net, u8 proto, bool task_valid, bool sync);\nint xfrm_dev_state_flush(struct net *net, struct net_device *dev, bool task_valid);\nint xfrm_dev_policy_flush(struct net *net, struct net_device *dev,\n\t\t\t  bool task_valid);\nvoid xfrm_sad_getinfo(struct net *net, struct xfrmk_sadinfo *si);\nvoid xfrm_spd_getinfo(struct net *net, struct xfrmk_spdinfo *si);\nu32 xfrm_replay_seqhi(struct xfrm_state *x, __be32 net_seq);\nint xfrm_init_replay(struct xfrm_state *x, struct netlink_ext_ack *extack);\nu32 xfrm_state_mtu(struct xfrm_state *x, int mtu);\nint __xfrm_init_state(struct xfrm_state *x, bool init_replay, bool offload,\n\t\t      struct netlink_ext_ack *extack);\nint xfrm_init_state(struct xfrm_state *x);\nint xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type);\nint xfrm_input_resume(struct sk_buff *skb, int nexthdr);\nint xfrm_trans_queue_net(struct net *net, struct sk_buff *skb,\n\t\t\t int (*finish)(struct net *, struct sock *,\n\t\t\t\t       struct sk_buff *));\nint xfrm_trans_queue(struct sk_buff *skb,\n\t\t     int (*finish)(struct net *, struct sock *,\n\t\t\t\t   struct sk_buff *));\nint xfrm_output_resume(struct sock *sk, struct sk_buff *skb, int err);\nint xfrm_output(struct sock *sk, struct sk_buff *skb);\n\n#if IS_ENABLED(CONFIG_NET_PKTGEN)\nint pktgen_xfrm_outer_mode_output(struct xfrm_state *x, struct sk_buff *skb);\n#endif\n\nvoid xfrm_local_error(struct sk_buff *skb, int mtu);\nint xfrm4_extract_input(struct xfrm_state *x, struct sk_buff *skb);\nint xfrm4_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t    int encap_type);\nint xfrm4_transport_finish(struct sk_buff *skb, int async);\nint xfrm4_rcv(struct sk_buff *skb);\n\nstatic inline int xfrm4_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi)\n{\n\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;\n\tXFRM_SPI_SKB_CB(skb)->family = AF_INET;\n\tXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);\n\treturn xfrm_input(skb, nexthdr, spi, 0);\n}\n\nint xfrm4_output(struct net *net, struct sock *sk, struct sk_buff *skb);\nint xfrm4_protocol_register(struct xfrm4_protocol *handler, unsigned char protocol);\nint xfrm4_protocol_deregister(struct xfrm4_protocol *handler, unsigned char protocol);\nint xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);\nint xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);\nvoid xfrm4_local_error(struct sk_buff *skb, u32 mtu);\nint xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);\nint xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t  struct ip6_tnl *t);\nint xfrm6_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t    int encap_type);\nint xfrm6_transport_finish(struct sk_buff *skb, int async);\nint xfrm6_rcv_tnl(struct sk_buff *skb, struct ip6_tnl *t);\nint xfrm6_rcv(struct sk_buff *skb);\nint xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,\n\t\t     xfrm_address_t *saddr, u8 proto);\nvoid xfrm6_local_error(struct sk_buff *skb, u32 mtu);\nint xfrm6_protocol_register(struct xfrm6_protocol *handler, unsigned char protocol);\nint xfrm6_protocol_deregister(struct xfrm6_protocol *handler, unsigned char protocol);\nint xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);\nint xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);\n__be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);\n__be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);\nint xfrm6_output(struct net *net, struct sock *sk, struct sk_buff *skb);\n\n#ifdef CONFIG_XFRM\nvoid xfrm6_local_rxpmtu(struct sk_buff *skb, u32 mtu);\nint xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);\nint xfrm6_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);\nint xfrm_user_policy(struct sock *sk, int optname, sockptr_t optval,\n\t\t     int optlen);\n#else\nstatic inline int xfrm_user_policy(struct sock *sk, int optname,\n\t\t\t\t   sockptr_t optval, int optlen)\n{\n \treturn -ENOPROTOOPT;\n}\n#endif\n\nstruct dst_entry *__xfrm_dst_lookup(struct net *net, int tos, int oif,\n\t\t\t\t    const xfrm_address_t *saddr,\n\t\t\t\t    const xfrm_address_t *daddr,\n\t\t\t\t    int family, u32 mark);\n\nstruct xfrm_policy *xfrm_policy_alloc(struct net *net, gfp_t gfp);\n\nvoid xfrm_policy_walk_init(struct xfrm_policy_walk *walk, u8 type);\nint xfrm_policy_walk(struct net *net, struct xfrm_policy_walk *walk,\n\t\t     int (*func)(struct xfrm_policy *, int, int, void*),\n\t\t     void *);\nvoid xfrm_policy_walk_done(struct xfrm_policy_walk *walk, struct net *net);\nint xfrm_policy_insert(int dir, struct xfrm_policy *policy, int excl);\nstruct xfrm_policy *xfrm_policy_bysel_ctx(struct net *net,\n\t\t\t\t\t  const struct xfrm_mark *mark,\n\t\t\t\t\t  u32 if_id, u8 type, int dir,\n\t\t\t\t\t  struct xfrm_selector *sel,\n\t\t\t\t\t  struct xfrm_sec_ctx *ctx, int delete,\n\t\t\t\t\t  int *err);\nstruct xfrm_policy *xfrm_policy_byid(struct net *net,\n\t\t\t\t     const struct xfrm_mark *mark, u32 if_id,\n\t\t\t\t     u8 type, int dir, u32 id, int delete,\n\t\t\t\t     int *err);\nint xfrm_policy_flush(struct net *net, u8 type, bool task_valid);\nvoid xfrm_policy_hash_rebuild(struct net *net);\nu32 xfrm_get_acqseq(void);\nint verify_spi_info(u8 proto, u32 min, u32 max, struct netlink_ext_ack *extack);\nint xfrm_alloc_spi(struct xfrm_state *x, u32 minspi, u32 maxspi,\n\t\t   struct netlink_ext_ack *extack);\nstruct xfrm_state *xfrm_find_acq(struct net *net, const struct xfrm_mark *mark,\n\t\t\t\t u8 mode, u32 reqid, u32 if_id, u8 proto,\n\t\t\t\t const xfrm_address_t *daddr,\n\t\t\t\t const xfrm_address_t *saddr, int create,\n\t\t\t\t unsigned short family);\nint xfrm_sk_policy_insert(struct sock *sk, int dir, struct xfrm_policy *pol);\n\n#ifdef CONFIG_XFRM_MIGRATE\nint km_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t       const struct xfrm_migrate *m, int num_bundles,\n\t       const struct xfrm_kmaddress *k,\n\t       const struct xfrm_encap_tmpl *encap);\nstruct xfrm_state *xfrm_migrate_state_find(struct xfrm_migrate *m, struct net *net,\n\t\t\t\t\t\tu32 if_id);\nstruct xfrm_state *xfrm_state_migrate(struct xfrm_state *x,\n\t\t\t\t      struct xfrm_migrate *m,\n\t\t\t\t      struct xfrm_encap_tmpl *encap);\nint xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_bundles,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap, u32 if_id,\n\t\t struct netlink_ext_ack *extack);\n#endif\n\nint km_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport);\nvoid km_policy_expired(struct xfrm_policy *pol, int dir, int hard, u32 portid);\nint km_report(struct net *net, u8 proto, struct xfrm_selector *sel,\n\t      xfrm_address_t *addr);\n\nvoid xfrm_input_init(void);\nint xfrm_parse_spi(struct sk_buff *skb, u8 nexthdr, __be32 *spi, __be32 *seq);\n\nvoid xfrm_probe_algs(void);\nint xfrm_count_pfkey_auth_supported(void);\nint xfrm_count_pfkey_enc_supported(void);\nstruct xfrm_algo_desc *xfrm_aalg_get_byidx(unsigned int idx);\nstruct xfrm_algo_desc *xfrm_ealg_get_byidx(unsigned int idx);\nstruct xfrm_algo_desc *xfrm_aalg_get_byid(int alg_id);\nstruct xfrm_algo_desc *xfrm_ealg_get_byid(int alg_id);\nstruct xfrm_algo_desc *xfrm_calg_get_byid(int alg_id);\nstruct xfrm_algo_desc *xfrm_aalg_get_byname(const char *name, int probe);\nstruct xfrm_algo_desc *xfrm_ealg_get_byname(const char *name, int probe);\nstruct xfrm_algo_desc *xfrm_calg_get_byname(const char *name, int probe);\nstruct xfrm_algo_desc *xfrm_aead_get_byname(const char *name, int icv_len,\n\t\t\t\t\t    int probe);\n\nstatic inline bool xfrm6_addr_equal(const xfrm_address_t *a,\n\t\t\t\t    const xfrm_address_t *b)\n{\n\treturn ipv6_addr_equal((const struct in6_addr *)a,\n\t\t\t       (const struct in6_addr *)b);\n}\n\nstatic inline bool xfrm_addr_equal(const xfrm_address_t *a,\n\t\t\t\t   const xfrm_address_t *b,\n\t\t\t\t   sa_family_t family)\n{\n\tswitch (family) {\n\tdefault:\n\tcase AF_INET:\n\t\treturn ((__force u32)a->a4 ^ (__force u32)b->a4) == 0;\n\tcase AF_INET6:\n\t\treturn xfrm6_addr_equal(a, b);\n\t}\n}\n\nstatic inline int xfrm_policy_id2dir(u32 index)\n{\n\treturn index & 7;\n}\n\n#ifdef CONFIG_XFRM\nvoid xfrm_replay_advance(struct xfrm_state *x, __be32 net_seq);\nint xfrm_replay_check(struct xfrm_state *x, struct sk_buff *skb, __be32 net_seq);\nvoid xfrm_replay_notify(struct xfrm_state *x, int event);\nint xfrm_replay_overflow(struct xfrm_state *x, struct sk_buff *skb);\nint xfrm_replay_recheck(struct xfrm_state *x, struct sk_buff *skb, __be32 net_seq);\n\nstatic inline int xfrm_aevent_is_on(struct net *net)\n{\n\tstruct sock *nlsk;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tnlsk = rcu_dereference(net->xfrm.nlsk);\n\tif (nlsk)\n\t\tret = netlink_has_listeners(nlsk, XFRMNLGRP_AEVENTS);\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic inline int xfrm_acquire_is_on(struct net *net)\n{\n\tstruct sock *nlsk;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tnlsk = rcu_dereference(net->xfrm.nlsk);\n\tif (nlsk)\n\t\tret = netlink_has_listeners(nlsk, XFRMNLGRP_ACQUIRE);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n#endif\n\nstatic inline unsigned int aead_len(struct xfrm_algo_aead *alg)\n{\n\treturn sizeof(*alg) + ((alg->alg_key_len + 7) / 8);\n}\n\nstatic inline unsigned int xfrm_alg_len(const struct xfrm_algo *alg)\n{\n\treturn sizeof(*alg) + ((alg->alg_key_len + 7) / 8);\n}\n\nstatic inline unsigned int xfrm_alg_auth_len(const struct xfrm_algo_auth *alg)\n{\n\treturn sizeof(*alg) + ((alg->alg_key_len + 7) / 8);\n}\n\nstatic inline unsigned int xfrm_replay_state_esn_len(struct xfrm_replay_state_esn *replay_esn)\n{\n\treturn sizeof(*replay_esn) + replay_esn->bmp_len * sizeof(__u32);\n}\n\n#ifdef CONFIG_XFRM_MIGRATE\nstatic inline int xfrm_replay_clone(struct xfrm_state *x,\n\t\t\t\t     struct xfrm_state *orig)\n{\n\n\tx->replay_esn = kmemdup(orig->replay_esn,\n\t\t\t\txfrm_replay_state_esn_len(orig->replay_esn),\n\t\t\t\tGFP_KERNEL);\n\tif (!x->replay_esn)\n\t\treturn -ENOMEM;\n\tx->preplay_esn = kmemdup(orig->preplay_esn,\n\t\t\t\t xfrm_replay_state_esn_len(orig->preplay_esn),\n\t\t\t\t GFP_KERNEL);\n\tif (!x->preplay_esn)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic inline struct xfrm_algo_aead *xfrm_algo_aead_clone(struct xfrm_algo_aead *orig)\n{\n\treturn kmemdup(orig, aead_len(orig), GFP_KERNEL);\n}\n\n\nstatic inline struct xfrm_algo *xfrm_algo_clone(struct xfrm_algo *orig)\n{\n\treturn kmemdup(orig, xfrm_alg_len(orig), GFP_KERNEL);\n}\n\nstatic inline struct xfrm_algo_auth *xfrm_algo_auth_clone(struct xfrm_algo_auth *orig)\n{\n\treturn kmemdup(orig, xfrm_alg_auth_len(orig), GFP_KERNEL);\n}\n\nstatic inline void xfrm_states_put(struct xfrm_state **states, int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t\txfrm_state_put(*(states + i));\n}\n\nstatic inline void xfrm_states_delete(struct xfrm_state **states, int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t\txfrm_state_delete(*(states + i));\n}\n#endif\n\nvoid __init xfrm_dev_init(void);\n\n#ifdef CONFIG_XFRM_OFFLOAD\nvoid xfrm_dev_resume(struct sk_buff *skb);\nvoid xfrm_dev_backlog(struct softnet_data *sd);\nstruct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t features, bool *again);\nint xfrm_dev_state_add(struct net *net, struct xfrm_state *x,\n\t\t       struct xfrm_user_offload *xuo,\n\t\t       struct netlink_ext_ack *extack);\nint xfrm_dev_policy_add(struct net *net, struct xfrm_policy *xp,\n\t\t\tstruct xfrm_user_offload *xuo, u8 dir,\n\t\t\tstruct netlink_ext_ack *extack);\nbool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x);\n\nstatic inline void xfrm_dev_state_advance_esn(struct xfrm_state *x)\n{\n\tstruct xfrm_dev_offload *xso = &x->xso;\n\n\tif (xso->dev && xso->dev->xfrmdev_ops->xdo_dev_state_advance_esn)\n\t\txso->dev->xfrmdev_ops->xdo_dev_state_advance_esn(x);\n}\n\nstatic inline bool xfrm_dst_offload_ok(struct dst_entry *dst)\n{\n\tstruct xfrm_state *x = dst->xfrm;\n\tstruct xfrm_dst *xdst;\n\n\tif (!x || !x->type_offload)\n\t\treturn false;\n\n\txdst = (struct xfrm_dst *) dst;\n\tif (!x->xso.offload_handle && !xdst->child->xfrm)\n\t\treturn true;\n\tif (x->xso.offload_handle && (x->xso.dev == xfrm_dst_path(dst)->dev) &&\n\t    !xdst->child->xfrm)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline void xfrm_dev_state_delete(struct xfrm_state *x)\n{\n\tstruct xfrm_dev_offload *xso = &x->xso;\n\n\tif (xso->dev)\n\t\txso->dev->xfrmdev_ops->xdo_dev_state_delete(x);\n}\n\nstatic inline void xfrm_dev_state_free(struct xfrm_state *x)\n{\n\tstruct xfrm_dev_offload *xso = &x->xso;\n\tstruct net_device *dev = xso->dev;\n\n\tif (dev && dev->xfrmdev_ops) {\n\t\tif (dev->xfrmdev_ops->xdo_dev_state_free)\n\t\t\tdev->xfrmdev_ops->xdo_dev_state_free(x);\n\t\txso->dev = NULL;\n\t\txso->type = XFRM_DEV_OFFLOAD_UNSPECIFIED;\n\t\tnetdev_put(dev, &xso->dev_tracker);\n\t}\n}\n\nstatic inline void xfrm_dev_policy_delete(struct xfrm_policy *x)\n{\n\tstruct xfrm_dev_offload *xdo = &x->xdo;\n\tstruct net_device *dev = xdo->dev;\n\n\tif (dev && dev->xfrmdev_ops && dev->xfrmdev_ops->xdo_dev_policy_delete)\n\t\tdev->xfrmdev_ops->xdo_dev_policy_delete(x);\n}\n\nstatic inline void xfrm_dev_policy_free(struct xfrm_policy *x)\n{\n\tstruct xfrm_dev_offload *xdo = &x->xdo;\n\tstruct net_device *dev = xdo->dev;\n\n\tif (dev && dev->xfrmdev_ops) {\n\t\tif (dev->xfrmdev_ops->xdo_dev_policy_free)\n\t\t\tdev->xfrmdev_ops->xdo_dev_policy_free(x);\n\t\txdo->dev = NULL;\n\t\tnetdev_put(dev, &xdo->dev_tracker);\n\t}\n}\n#else\nstatic inline void xfrm_dev_resume(struct sk_buff *skb)\n{\n}\n\nstatic inline void xfrm_dev_backlog(struct softnet_data *sd)\n{\n}\n\nstatic inline struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t features, bool *again)\n{\n\treturn skb;\n}\n\nstatic inline int xfrm_dev_state_add(struct net *net, struct xfrm_state *x, struct xfrm_user_offload *xuo, struct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\n\nstatic inline void xfrm_dev_state_delete(struct xfrm_state *x)\n{\n}\n\nstatic inline void xfrm_dev_state_free(struct xfrm_state *x)\n{\n}\n\nstatic inline int xfrm_dev_policy_add(struct net *net, struct xfrm_policy *xp,\n\t\t\t\t      struct xfrm_user_offload *xuo, u8 dir,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\n\nstatic inline void xfrm_dev_policy_delete(struct xfrm_policy *x)\n{\n}\n\nstatic inline void xfrm_dev_policy_free(struct xfrm_policy *x)\n{\n}\n\nstatic inline bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)\n{\n\treturn false;\n}\n\nstatic inline void xfrm_dev_state_advance_esn(struct xfrm_state *x)\n{\n}\n\nstatic inline bool xfrm_dst_offload_ok(struct dst_entry *dst)\n{\n\treturn false;\n}\n#endif\n\nstatic inline int xfrm_mark_get(struct nlattr **attrs, struct xfrm_mark *m)\n{\n\tif (attrs[XFRMA_MARK])\n\t\tmemcpy(m, nla_data(attrs[XFRMA_MARK]), sizeof(struct xfrm_mark));\n\telse\n\t\tm->v = m->m = 0;\n\n\treturn m->v & m->m;\n}\n\nstatic inline int xfrm_mark_put(struct sk_buff *skb, const struct xfrm_mark *m)\n{\n\tint ret = 0;\n\n\tif (m->m | m->v)\n\t\tret = nla_put(skb, XFRMA_MARK, sizeof(struct xfrm_mark), m);\n\treturn ret;\n}\n\nstatic inline __u32 xfrm_smark_get(__u32 mark, struct xfrm_state *x)\n{\n\tstruct xfrm_mark *m = &x->props.smark;\n\n\treturn (m->v & m->m) | (mark & ~m->m);\n}\n\nstatic inline int xfrm_if_id_put(struct sk_buff *skb, __u32 if_id)\n{\n\tint ret = 0;\n\n\tif (if_id)\n\t\tret = nla_put_u32(skb, XFRMA_IF_ID, if_id);\n\treturn ret;\n}\n\nstatic inline int xfrm_tunnel_check(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\t\t    unsigned int family)\n{\n\tbool tunnel = false;\n\n\tswitch(family) {\n\tcase AF_INET:\n\t\tif (XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4)\n\t\t\ttunnel = true;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6)\n\t\t\ttunnel = true;\n\t\tbreak;\n\t}\n\tif (tunnel && !(x->outer_mode.flags & XFRM_MODE_FLAG_TUNNEL))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nextern const int xfrm_msg_min[XFRM_NR_MSGTYPES];\nextern const struct nla_policy xfrma_policy[XFRMA_MAX+1];\n\nstruct xfrm_translator {\n\t \n\tint (*alloc_compat)(struct sk_buff *skb, const struct nlmsghdr *src);\n\n\t \n\tstruct nlmsghdr *(*rcv_msg_compat)(const struct nlmsghdr *nlh,\n\t\t\tint maxtype, const struct nla_policy *policy,\n\t\t\tstruct netlink_ext_ack *extack);\n\n\t \n\tint (*xlate_user_policy_sockptr)(u8 **pdata32, int optlen);\n\n\tstruct module *owner;\n};\n\n#if IS_ENABLED(CONFIG_XFRM_USER_COMPAT)\nextern int xfrm_register_translator(struct xfrm_translator *xtr);\nextern int xfrm_unregister_translator(struct xfrm_translator *xtr);\nextern struct xfrm_translator *xfrm_get_translator(void);\nextern void xfrm_put_translator(struct xfrm_translator *xtr);\n#else\nstatic inline struct xfrm_translator *xfrm_get_translator(void)\n{\n\treturn NULL;\n}\nstatic inline void xfrm_put_translator(struct xfrm_translator *xtr)\n{\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline bool xfrm6_local_dontfrag(const struct sock *sk)\n{\n\tint proto;\n\n\tif (!sk || sk->sk_family != AF_INET6)\n\t\treturn false;\n\n\tproto = sk->sk_protocol;\n\tif (proto == IPPROTO_UDP || proto == IPPROTO_RAW)\n\t\treturn inet6_sk(sk)->dontfrag;\n\n\treturn false;\n}\n#endif\n\n#if (IS_BUILTIN(CONFIG_XFRM_INTERFACE) && IS_ENABLED(CONFIG_DEBUG_INFO_BTF)) || \\\n    (IS_MODULE(CONFIG_XFRM_INTERFACE) && IS_ENABLED(CONFIG_DEBUG_INFO_BTF_MODULES))\n\nextern struct metadata_dst __percpu *xfrm_bpf_md_dst;\n\nint register_xfrm_interface_bpf(void);\n\n#else\n\nstatic inline int register_xfrm_interface_bpf(void)\n{\n\treturn 0;\n}\n\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}