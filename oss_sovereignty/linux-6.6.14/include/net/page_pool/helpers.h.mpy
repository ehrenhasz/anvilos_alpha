{
  "module_name": "helpers.h",
  "hash_id": "22be546b2bbfaa96d407c7e4ef3fcffffe7184409bb852bf55addd85eb99c562",
  "original_prompt": "Ingested from linux-6.6.14/include/net/page_pool/helpers.h",
  "human_readable_source": " \n\n \n#ifndef _NET_PAGE_POOL_HELPERS_H\n#define _NET_PAGE_POOL_HELPERS_H\n\n#include <net/page_pool/types.h>\n\n#ifdef CONFIG_PAGE_POOL_STATS\nint page_pool_ethtool_stats_get_count(void);\nu8 *page_pool_ethtool_stats_get_strings(u8 *data);\nu64 *page_pool_ethtool_stats_get(u64 *data, void *stats);\n\n \nbool page_pool_get_stats(struct page_pool *pool,\n\t\t\t struct page_pool_stats *stats);\n#else\nstatic inline int page_pool_ethtool_stats_get_count(void)\n{\n\treturn 0;\n}\n\nstatic inline u8 *page_pool_ethtool_stats_get_strings(u8 *data)\n{\n\treturn data;\n}\n\nstatic inline u64 *page_pool_ethtool_stats_get(u64 *data, void *stats)\n{\n\treturn data;\n}\n#endif\n\n \nstatic inline struct page *page_pool_dev_alloc_pages(struct page_pool *pool)\n{\n\tgfp_t gfp = (GFP_ATOMIC | __GFP_NOWARN);\n\n\treturn page_pool_alloc_pages(pool, gfp);\n}\n\nstatic inline struct page *page_pool_dev_alloc_frag(struct page_pool *pool,\n\t\t\t\t\t\t    unsigned int *offset,\n\t\t\t\t\t\t    unsigned int size)\n{\n\tgfp_t gfp = (GFP_ATOMIC | __GFP_NOWARN);\n\n\treturn page_pool_alloc_frag(pool, offset, size, gfp);\n}\n\n \nstatic\ninline enum dma_data_direction page_pool_get_dma_dir(struct page_pool *pool)\n{\n\treturn pool->p.dma_dir;\n}\n\n \nstatic inline void page_pool_fragment_page(struct page *page, long nr)\n{\n\tatomic_long_set(&page->pp_frag_count, nr);\n}\n\nstatic inline long page_pool_defrag_page(struct page *page, long nr)\n{\n\tlong ret;\n\n\t \n\tif (atomic_long_read(&page->pp_frag_count) == nr)\n\t\treturn 0;\n\n\tret = atomic_long_sub_return(nr, &page->pp_frag_count);\n\tWARN_ON(ret < 0);\n\treturn ret;\n}\n\nstatic inline bool page_pool_is_last_frag(struct page_pool *pool,\n\t\t\t\t\t  struct page *page)\n{\n\t \n\treturn !(pool->p.flags & PP_FLAG_PAGE_FRAG) ||\n\t       (page_pool_defrag_page(page, 1) == 0);\n}\n\n \nstatic inline void page_pool_put_page(struct page_pool *pool,\n\t\t\t\t      struct page *page,\n\t\t\t\t      unsigned int dma_sync_size,\n\t\t\t\t      bool allow_direct)\n{\n\t \n#ifdef CONFIG_PAGE_POOL\n\tif (!page_pool_is_last_frag(pool, page))\n\t\treturn;\n\n\tpage_pool_put_defragged_page(pool, page, dma_sync_size, allow_direct);\n#endif\n}\n\n \nstatic inline void page_pool_put_full_page(struct page_pool *pool,\n\t\t\t\t\t   struct page *page, bool allow_direct)\n{\n\tpage_pool_put_page(pool, page, -1, allow_direct);\n}\n\n \nstatic inline void page_pool_recycle_direct(struct page_pool *pool,\n\t\t\t\t\t    struct page *page)\n{\n\tpage_pool_put_full_page(pool, page, true);\n}\n\n#define PAGE_POOL_DMA_USE_PP_FRAG_COUNT\t\\\n\t\t(sizeof(dma_addr_t) > sizeof(unsigned long))\n\n \nstatic inline dma_addr_t page_pool_get_dma_addr(struct page *page)\n{\n\tdma_addr_t ret = page->dma_addr;\n\n\tif (PAGE_POOL_DMA_USE_PP_FRAG_COUNT)\n\t\tret |= (dma_addr_t)page->dma_addr_upper << 16 << 16;\n\n\treturn ret;\n}\n\nstatic inline void page_pool_set_dma_addr(struct page *page, dma_addr_t addr)\n{\n\tpage->dma_addr = addr;\n\tif (PAGE_POOL_DMA_USE_PP_FRAG_COUNT)\n\t\tpage->dma_addr_upper = upper_32_bits(addr);\n}\n\nstatic inline bool page_pool_put(struct page_pool *pool)\n{\n\treturn refcount_dec_and_test(&pool->user_cnt);\n}\n\nstatic inline void page_pool_nid_changed(struct page_pool *pool, int new_nid)\n{\n\tif (unlikely(pool->p.nid != new_nid))\n\t\tpage_pool_update_nid(pool, new_nid);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}