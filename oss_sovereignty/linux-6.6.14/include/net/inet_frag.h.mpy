{
  "module_name": "inet_frag.h",
  "hash_id": "4d0e086b7d47a2f54e3a6bcf039c112beb4a5bd498ab9c744787dffa5a0bc846",
  "original_prompt": "Ingested from linux-6.6.14/include/net/inet_frag.h",
  "human_readable_source": " \n#ifndef __NET_FRAG_H__\n#define __NET_FRAG_H__\n\n#include <linux/rhashtable-types.h>\n#include <linux/completion.h>\n#include <linux/in6.h>\n#include <linux/rbtree_types.h>\n#include <linux/refcount.h>\n#include <net/dropreason-core.h>\n\n \nstruct fqdir {\n\t \n\tlong\t\t\thigh_thresh;\n\tlong\t\t\tlow_thresh;\n\tint\t\t\ttimeout;\n\tint\t\t\tmax_dist;\n\tstruct inet_frags\t*f;\n\tstruct net\t\t*net;\n\tbool\t\t\tdead;\n\n\tstruct rhashtable       rhashtable ____cacheline_aligned_in_smp;\n\n\t \n\tatomic_long_t\t\tmem ____cacheline_aligned_in_smp;\n\tstruct work_struct\tdestroy_work;\n\tstruct llist_node\tfree_list;\n};\n\n \nenum {\n\tINET_FRAG_FIRST_IN\t= BIT(0),\n\tINET_FRAG_LAST_IN\t= BIT(1),\n\tINET_FRAG_COMPLETE\t= BIT(2),\n\tINET_FRAG_HASH_DEAD\t= BIT(3),\n\tINET_FRAG_DROP\t\t= BIT(4),\n};\n\nstruct frag_v4_compare_key {\n\t__be32\t\tsaddr;\n\t__be32\t\tdaddr;\n\tu32\t\tuser;\n\tu32\t\tvif;\n\t__be16\t\tid;\n\tu16\t\tprotocol;\n};\n\nstruct frag_v6_compare_key {\n\tstruct in6_addr\tsaddr;\n\tstruct in6_addr\tdaddr;\n\tu32\t\tuser;\n\t__be32\t\tid;\n\tu32\t\tiif;\n};\n\n \nstruct inet_frag_queue {\n\tstruct rhash_head\tnode;\n\tunion {\n\t\tstruct frag_v4_compare_key v4;\n\t\tstruct frag_v6_compare_key v6;\n\t} key;\n\tstruct timer_list\ttimer;\n\tspinlock_t\t\tlock;\n\trefcount_t\t\trefcnt;\n\tstruct rb_root\t\trb_fragments;\n\tstruct sk_buff\t\t*fragments_tail;\n\tstruct sk_buff\t\t*last_run_head;\n\tktime_t\t\t\tstamp;\n\tint\t\t\tlen;\n\tint\t\t\tmeat;\n\tu8\t\t\tmono_delivery_time;\n\t__u8\t\t\tflags;\n\tu16\t\t\tmax_size;\n\tstruct fqdir\t\t*fqdir;\n\tstruct rcu_head\t\trcu;\n};\n\nstruct inet_frags {\n\tunsigned int\t\tqsize;\n\n\tvoid\t\t\t(*constructor)(struct inet_frag_queue *q,\n\t\t\t\t\t       const void *arg);\n\tvoid\t\t\t(*destructor)(struct inet_frag_queue *);\n\tvoid\t\t\t(*frag_expire)(struct timer_list *t);\n\tstruct kmem_cache\t*frags_cachep;\n\tconst char\t\t*frags_cache_name;\n\tstruct rhashtable_params rhash_params;\n\trefcount_t\t\trefcnt;\n\tstruct completion\tcompletion;\n};\n\nint inet_frags_init(struct inet_frags *);\nvoid inet_frags_fini(struct inet_frags *);\n\nint fqdir_init(struct fqdir **fqdirp, struct inet_frags *f, struct net *net);\n\nstatic inline void fqdir_pre_exit(struct fqdir *fqdir)\n{\n\t \n\tWRITE_ONCE(fqdir->high_thresh, 0);\n\n\t \n\tWRITE_ONCE(fqdir->dead, true);\n}\nvoid fqdir_exit(struct fqdir *fqdir);\n\nvoid inet_frag_kill(struct inet_frag_queue *q);\nvoid inet_frag_destroy(struct inet_frag_queue *q);\nstruct inet_frag_queue *inet_frag_find(struct fqdir *fqdir, void *key);\n\n \nunsigned int inet_frag_rbtree_purge(struct rb_root *root,\n\t\t\t\t    enum skb_drop_reason reason);\n\nstatic inline void inet_frag_put(struct inet_frag_queue *q)\n{\n\tif (refcount_dec_and_test(&q->refcnt))\n\t\tinet_frag_destroy(q);\n}\n\n \n\nstatic inline long frag_mem_limit(const struct fqdir *fqdir)\n{\n\treturn atomic_long_read(&fqdir->mem);\n}\n\nstatic inline void sub_frag_mem_limit(struct fqdir *fqdir, long val)\n{\n\tatomic_long_sub(val, &fqdir->mem);\n}\n\nstatic inline void add_frag_mem_limit(struct fqdir *fqdir, long val)\n{\n\tatomic_long_add(val, &fqdir->mem);\n}\n\n \n#define\tIPFRAG_ECN_NOT_ECT\t0x01  \n#define\tIPFRAG_ECN_ECT_1\t0x02  \n#define\tIPFRAG_ECN_ECT_0\t0x04  \n#define\tIPFRAG_ECN_CE\t\t0x08  \n\nextern const u8 ip_frag_ecn_table[16];\n\n \n#define IPFRAG_OK\t0\n#define IPFRAG_DUP\t1\n#define IPFRAG_OVERLAP\t2\nint inet_frag_queue_insert(struct inet_frag_queue *q, struct sk_buff *skb,\n\t\t\t   int offset, int end);\nvoid *inet_frag_reasm_prepare(struct inet_frag_queue *q, struct sk_buff *skb,\n\t\t\t      struct sk_buff *parent);\nvoid inet_frag_reasm_finish(struct inet_frag_queue *q, struct sk_buff *head,\n\t\t\t    void *reasm_data, bool try_coalesce);\nstruct sk_buff *inet_frag_pull_head(struct inet_frag_queue *q);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}