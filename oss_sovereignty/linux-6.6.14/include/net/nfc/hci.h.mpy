{
  "module_name": "hci.h",
  "hash_id": "71383a4edd18ff272665fb92463e9b87ee428e433f2d9a21a0ed826c6672bfc0",
  "original_prompt": "Ingested from linux-6.6.14/include/net/nfc/hci.h",
  "human_readable_source": " \n \n\n#ifndef __NET_HCI_H\n#define __NET_HCI_H\n\n#include <linux/skbuff.h>\n\n#include <net/nfc/nfc.h>\n\nstruct nfc_hci_dev;\n\nstruct nfc_hci_ops {\n\tint (*open) (struct nfc_hci_dev *hdev);\n\tvoid (*close) (struct nfc_hci_dev *hdev);\n\tint (*load_session) (struct nfc_hci_dev *hdev);\n\tint (*hci_ready) (struct nfc_hci_dev *hdev);\n\t \n\tint (*xmit) (struct nfc_hci_dev *hdev, struct sk_buff *skb);\n\tint (*start_poll) (struct nfc_hci_dev *hdev,\n\t\t\t   u32 im_protocols, u32 tm_protocols);\n\tvoid (*stop_poll) (struct nfc_hci_dev *hdev);\n\tint (*dep_link_up)(struct nfc_hci_dev *hdev, struct nfc_target *target,\n\t\t\t   u8 comm_mode, u8 *gb, size_t gb_len);\n\tint (*dep_link_down)(struct nfc_hci_dev *hdev);\n\tint (*target_from_gate) (struct nfc_hci_dev *hdev, u8 gate,\n\t\t\t\t struct nfc_target *target);\n\tint (*complete_target_discovered) (struct nfc_hci_dev *hdev, u8 gate,\n\t\t\t\t\t   struct nfc_target *target);\n\tint (*im_transceive) (struct nfc_hci_dev *hdev,\n\t\t\t      struct nfc_target *target, struct sk_buff *skb,\n\t\t\t      data_exchange_cb_t cb, void *cb_context);\n\tint (*tm_send)(struct nfc_hci_dev *hdev, struct sk_buff *skb);\n\tint (*check_presence)(struct nfc_hci_dev *hdev,\n\t\t\t      struct nfc_target *target);\n\tint (*event_received)(struct nfc_hci_dev *hdev, u8 pipe, u8 event,\n\t\t\t      struct sk_buff *skb);\n\tvoid (*cmd_received)(struct nfc_hci_dev *hdev, u8 pipe, u8 cmd,\n\t\t\t    struct sk_buff *skb);\n\tint (*fw_download)(struct nfc_hci_dev *hdev, const char *firmware_name);\n\tint (*discover_se)(struct nfc_hci_dev *dev);\n\tint (*enable_se)(struct nfc_hci_dev *dev, u32 se_idx);\n\tint (*disable_se)(struct nfc_hci_dev *dev, u32 se_idx);\n\tint (*se_io)(struct nfc_hci_dev *dev, u32 se_idx,\n\t\t      u8 *apdu, size_t apdu_length,\n\t\t      se_io_cb_t cb, void *cb_context);\n};\n\n \n#define NFC_HCI_DO_NOT_CREATE_PIPE\t0x81\n#define NFC_HCI_INVALID_PIPE\t0x80\n#define NFC_HCI_INVALID_GATE\t0xFF\n#define NFC_HCI_INVALID_HOST\t0x80\n#define NFC_HCI_LINK_MGMT_PIPE\t0x00\n#define NFC_HCI_ADMIN_PIPE\t0x01\n\nstruct nfc_hci_gate {\n\tu8 gate;\n\tu8 pipe;\n};\n\nstruct nfc_hci_pipe {\n\tu8 gate;\n\tu8 dest_host;\n};\n\n#define NFC_HCI_MAX_CUSTOM_GATES\t50\n \n#define NFC_HCI_MAX_PIPES\t\t128\nstruct nfc_hci_init_data {\n\tu8 gate_count;\n\tstruct nfc_hci_gate gates[NFC_HCI_MAX_CUSTOM_GATES];\n\tchar session_id[9];\n};\n\ntypedef int (*xmit) (struct sk_buff *skb, void *cb_data);\n\n#define NFC_HCI_MAX_GATES\t\t256\n\n \nenum {\n\tNFC_HCI_QUIRK_SHORT_CLEAR\t= 0,\n};\n\nstruct nfc_hci_dev {\n\tstruct nfc_dev *ndev;\n\n\tu32 max_data_link_payload;\n\n\tbool shutting_down;\n\n\tstruct mutex msg_tx_mutex;\n\n\tstruct list_head msg_tx_queue;\n\n\tstruct work_struct msg_tx_work;\n\n\tstruct timer_list cmd_timer;\n\tstruct hci_msg *cmd_pending_msg;\n\n\tstruct sk_buff_head rx_hcp_frags;\n\n\tstruct work_struct msg_rx_work;\n\n\tstruct sk_buff_head msg_rx_queue;\n\n\tconst struct nfc_hci_ops *ops;\n\n\tstruct nfc_llc *llc;\n\n\tstruct nfc_hci_init_data init_data;\n\n\tvoid *clientdata;\n\n\tu8 gate2pipe[NFC_HCI_MAX_GATES];\n\tstruct nfc_hci_pipe pipes[NFC_HCI_MAX_PIPES];\n\n\tu8 sw_romlib;\n\tu8 sw_patch;\n\tu8 sw_flashlib_major;\n\tu8 sw_flashlib_minor;\n\n\tu8 hw_derivative;\n\tu8 hw_version;\n\tu8 hw_mpw;\n\tu8 hw_software;\n\tu8 hw_bsid;\n\n\tint async_cb_type;\n\tdata_exchange_cb_t async_cb;\n\tvoid *async_cb_context;\n\n\tu8 *gb;\n\tsize_t gb_len;\n\n\tunsigned long quirks;\n};\n\n \nstruct nfc_hci_dev *nfc_hci_allocate_device(const struct nfc_hci_ops *ops,\n\t\t\t\t\t    struct nfc_hci_init_data *init_data,\n\t\t\t\t\t    unsigned long quirks,\n\t\t\t\t\t    u32 protocols,\n\t\t\t\t\t    const char *llc_name,\n\t\t\t\t\t    int tx_headroom,\n\t\t\t\t\t    int tx_tailroom,\n\t\t\t\t\t    int max_link_payload);\nvoid nfc_hci_free_device(struct nfc_hci_dev *hdev);\n\nint nfc_hci_register_device(struct nfc_hci_dev *hdev);\nvoid nfc_hci_unregister_device(struct nfc_hci_dev *hdev);\n\nvoid nfc_hci_set_clientdata(struct nfc_hci_dev *hdev, void *clientdata);\nvoid *nfc_hci_get_clientdata(struct nfc_hci_dev *hdev);\n\nstatic inline int nfc_hci_set_vendor_cmds(struct nfc_hci_dev *hdev,\n\t\t\t\t\t  const struct nfc_vendor_cmd *cmds,\n\t\t\t\t\t  int n_cmds)\n{\n\treturn nfc_set_vendor_cmds(hdev->ndev, cmds, n_cmds);\n}\n\nvoid nfc_hci_driver_failure(struct nfc_hci_dev *hdev, int err);\n\nint nfc_hci_result_to_errno(u8 result);\nvoid nfc_hci_reset_pipes(struct nfc_hci_dev *dev);\nvoid nfc_hci_reset_pipes_per_host(struct nfc_hci_dev *hdev, u8 host);\n\n \n#define NFC_HCI_HOST_CONTROLLER_ID\t0x00\n#define NFC_HCI_TERMINAL_HOST_ID\t0x01\n#define NFC_HCI_UICC_HOST_ID\t\t0x02\n\n \n#define NFC_HCI_ADMIN_GATE 0x00\n#define NFC_HCI_ADMIN_SESSION_IDENTITY\t0x01\n#define NFC_HCI_ADMIN_MAX_PIPE\t\t0x02\n#define NFC_HCI_ADMIN_WHITELIST\t\t0x03\n#define NFC_HCI_ADMIN_HOST_LIST\t\t0x04\n\n#define NFC_HCI_LOOPBACK_GATE\t\t0x04\n\n#define NFC_HCI_ID_MGMT_GATE\t\t0x05\n#define NFC_HCI_ID_MGMT_VERSION_SW\t0x01\n#define NFC_HCI_ID_MGMT_VERSION_HW\t0x03\n#define NFC_HCI_ID_MGMT_VENDOR_NAME\t0x04\n#define NFC_HCI_ID_MGMT_MODEL_ID\t0x05\n#define NFC_HCI_ID_MGMT_HCI_VERSION\t0x02\n#define NFC_HCI_ID_MGMT_GATES_LIST\t0x06\n\n#define NFC_HCI_LINK_MGMT_GATE\t\t0x06\n#define NFC_HCI_LINK_MGMT_REC_ERROR\t0x01\n\n#define NFC_HCI_RF_READER_B_GATE\t\t\t0x11\n#define NFC_HCI_RF_READER_B_PUPI\t\t\t0x03\n#define NFC_HCI_RF_READER_B_APPLICATION_DATA\t\t0x04\n#define NFC_HCI_RF_READER_B_AFI\t\t\t\t0x02\n#define NFC_HCI_RF_READER_B_HIGHER_LAYER_RESPONSE\t0x01\n#define NFC_HCI_RF_READER_B_HIGHER_LAYER_DATA\t\t0x05\n\n#define NFC_HCI_RF_READER_A_GATE\t\t0x13\n#define NFC_HCI_RF_READER_A_UID\t\t\t0x02\n#define NFC_HCI_RF_READER_A_ATQA\t\t0x04\n#define NFC_HCI_RF_READER_A_APPLICATION_DATA\t0x05\n#define NFC_HCI_RF_READER_A_SAK\t\t\t0x03\n#define NFC_HCI_RF_READER_A_FWI_SFGT\t\t0x06\n#define NFC_HCI_RF_READER_A_DATARATE_MAX\t0x01\n\n#define NFC_HCI_TYPE_A_SEL_PROT(x)\t\t(((x) & 0x60) >> 5)\n#define NFC_HCI_TYPE_A_SEL_PROT_MIFARE\t\t0\n#define NFC_HCI_TYPE_A_SEL_PROT_ISO14443\t1\n#define NFC_HCI_TYPE_A_SEL_PROT_DEP\t\t2\n#define NFC_HCI_TYPE_A_SEL_PROT_ISO14443_DEP\t3\n\n \n#define NFC_HCI_EVT_HCI_END_OF_OPERATION\t0x01\n#define NFC_HCI_EVT_POST_DATA\t\t\t0x02\n#define NFC_HCI_EVT_HOT_PLUG\t\t\t0x03\n\n \n#define NFC_HCI_ANY_SET_PARAMETER\t0x01\n#define NFC_HCI_ANY_GET_PARAMETER\t0x02\n#define NFC_HCI_ANY_OPEN_PIPE\t\t0x03\n#define NFC_HCI_ANY_CLOSE_PIPE\t\t0x04\n\n \n#define NFC_HCI_EVT_READER_REQUESTED\t0x10\n#define NFC_HCI_EVT_END_OPERATION\t0x11\n\n \n#define NFC_HCI_EVT_TARGET_DISCOVERED\t0x10\n\n \nvoid nfc_hci_resp_received(struct nfc_hci_dev *hdev, u8 result,\n\t\t\t   struct sk_buff *skb);\nvoid nfc_hci_cmd_received(struct nfc_hci_dev *hdev, u8 pipe, u8 cmd,\n\t\t\t  struct sk_buff *skb);\nvoid nfc_hci_event_received(struct nfc_hci_dev *hdev, u8 pipe, u8 event,\n\t\t\t    struct sk_buff *skb);\nvoid nfc_hci_recv_frame(struct nfc_hci_dev *hdev, struct sk_buff *skb);\n\n \nint nfc_hci_connect_gate(struct nfc_hci_dev *hdev, u8 dest_host, u8 dest_gate,\n\t\t\t u8 pipe);\nint nfc_hci_disconnect_gate(struct nfc_hci_dev *hdev, u8 gate);\nint nfc_hci_disconnect_all_gates(struct nfc_hci_dev *hdev);\nint nfc_hci_get_param(struct nfc_hci_dev *hdev, u8 gate, u8 idx,\n\t\t      struct sk_buff **skb);\nint nfc_hci_set_param(struct nfc_hci_dev *hdev, u8 gate, u8 idx,\n\t\t      const u8 *param, size_t param_len);\nint nfc_hci_send_cmd(struct nfc_hci_dev *hdev, u8 gate, u8 cmd,\n\t\t     const u8 *param, size_t param_len, struct sk_buff **skb);\nint nfc_hci_send_cmd_async(struct nfc_hci_dev *hdev, u8 gate, u8 cmd,\n\t\t\t   const u8 *param, size_t param_len,\n\t\t\t   data_exchange_cb_t cb, void *cb_context);\nint nfc_hci_send_event(struct nfc_hci_dev *hdev, u8 gate, u8 event,\n\t\t       const u8 *param, size_t param_len);\nint nfc_hci_target_discovered(struct nfc_hci_dev *hdev, u8 gate);\nu32 nfc_hci_sak_to_protocol(u8 sak);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}