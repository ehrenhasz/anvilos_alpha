{
  "module_name": "red.h",
  "hash_id": "3088fbc4c1ef94c92f10219b5be812bcd5e55cd464bd38d083055cfb4d1ee5a7",
  "original_prompt": "Ingested from linux-6.6.14/include/net/red.h",
  "human_readable_source": " \n#ifndef __NET_SCHED_RED_H\n#define __NET_SCHED_RED_H\n\n#include <linux/types.h>\n#include <linux/bug.h>\n#include <net/pkt_sched.h>\n#include <net/inet_ecn.h>\n#include <net/dsfield.h>\n#include <linux/reciprocal_div.h>\n\n \n\n \n#define RED_ONE_PERCENT ((u32)DIV_ROUND_CLOSEST(1ULL<<32, 100))\n\n#define MAX_P_MIN (1 * RED_ONE_PERCENT)\n#define MAX_P_MAX (50 * RED_ONE_PERCENT)\n#define MAX_P_ALPHA(val) min(MAX_P_MIN, val / 4)\n\n#define RED_STAB_SIZE\t256\n#define RED_STAB_MASK\t(RED_STAB_SIZE - 1)\n\nstruct red_stats {\n\tu32\t\tprob_drop;\t \n\tu32\t\tprob_mark;\t \n\tu32\t\tforced_drop;\t \n\tu32\t\tforced_mark;\t \n\tu32\t\tpdrop;           \n};\n\nstruct red_parms {\n\t \n\tu32\t\tqth_min;\t \n\tu32\t\tqth_max;\t \n\tu32\t\tScell_max;\n\tu32\t\tmax_P;\t\t \n\t \n\tstruct reciprocal_value\tmax_P_reciprocal;\n\tu32\t\tqth_delta;\t \n\tu32\t\ttarget_min;\t \n\tu32\t\ttarget_max;\t \n\tu8\t\tScell_log;\n\tu8\t\tWlog;\t\t \n\tu8\t\tPlog;\t\t \n\tu8\t\tStab[RED_STAB_SIZE];\n};\n\nstruct red_vars {\n\t \n\tint\t\tqcount;\t\t \n\tu32\t\tqR;\t\t \n\n\tunsigned long\tqavg;\t\t \n\tktime_t\t\tqidlestart;\t \n};\n\nstatic inline u32 red_maxp(u8 Plog)\n{\n\treturn Plog < 32 ? (~0U >> Plog) : ~0U;\n}\n\nstatic inline void red_set_vars(struct red_vars *v)\n{\n\t \n\tv->qavg\t\t= 0;\n\n\tv->qcount\t= -1;\n}\n\nstatic inline bool red_check_params(u32 qth_min, u32 qth_max, u8 Wlog,\n\t\t\t\t    u8 Scell_log, u8 *stab)\n{\n\tif (fls(qth_min) + Wlog >= 32)\n\t\treturn false;\n\tif (fls(qth_max) + Wlog >= 32)\n\t\treturn false;\n\tif (Scell_log >= 32)\n\t\treturn false;\n\tif (qth_max < qth_min)\n\t\treturn false;\n\tif (stab) {\n\t\tint i;\n\n\t\tfor (i = 0; i < RED_STAB_SIZE; i++)\n\t\t\tif (stab[i] >= 32)\n\t\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic inline int red_get_flags(unsigned char qopt_flags,\n\t\t\t\tunsigned char historic_mask,\n\t\t\t\tstruct nlattr *flags_attr,\n\t\t\t\tunsigned char supported_mask,\n\t\t\t\tstruct nla_bitfield32 *p_flags,\n\t\t\t\tunsigned char *p_userbits,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nla_bitfield32 flags;\n\n\tif (qopt_flags && flags_attr) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"flags should be passed either through qopt, or through a dedicated attribute\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags_attr) {\n\t\tflags = nla_get_bitfield32(flags_attr);\n\t} else {\n\t\tflags.selector = historic_mask;\n\t\tflags.value = qopt_flags & historic_mask;\n\t}\n\n\t*p_flags = flags;\n\t*p_userbits = qopt_flags & ~historic_mask;\n\treturn 0;\n}\n\nstatic inline int red_validate_flags(unsigned char flags,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tif ((flags & TC_RED_NODROP) && !(flags & TC_RED_ECN)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"nodrop mode is only meaningful with ECN\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void red_set_parms(struct red_parms *p,\n\t\t\t\t u32 qth_min, u32 qth_max, u8 Wlog, u8 Plog,\n\t\t\t\t u8 Scell_log, u8 *stab, u32 max_P)\n{\n\tint delta = qth_max - qth_min;\n\tu32 max_p_delta;\n\n\tp->qth_min\t= qth_min << Wlog;\n\tp->qth_max\t= qth_max << Wlog;\n\tp->Wlog\t\t= Wlog;\n\tp->Plog\t\t= Plog;\n\tif (delta <= 0)\n\t\tdelta = 1;\n\tp->qth_delta\t= delta;\n\tif (!max_P) {\n\t\tmax_P = red_maxp(Plog);\n\t\tmax_P *= delta;  \n\t}\n\tp->max_P = max_P;\n\tmax_p_delta = max_P / delta;\n\tmax_p_delta = max(max_p_delta, 1U);\n\tp->max_P_reciprocal  = reciprocal_value(max_p_delta);\n\n\t \n\tdelta /= 5;\n\tp->target_min = qth_min + 2*delta;\n\tp->target_max = qth_min + 3*delta;\n\n\tp->Scell_log\t= Scell_log;\n\tp->Scell_max\t= (255 << Scell_log);\n\n\tif (stab)\n\t\tmemcpy(p->Stab, stab, sizeof(p->Stab));\n}\n\nstatic inline int red_is_idling(const struct red_vars *v)\n{\n\treturn v->qidlestart != 0;\n}\n\nstatic inline void red_start_of_idle_period(struct red_vars *v)\n{\n\tv->qidlestart = ktime_get();\n}\n\nstatic inline void red_end_of_idle_period(struct red_vars *v)\n{\n\tv->qidlestart = 0;\n}\n\nstatic inline void red_restart(struct red_vars *v)\n{\n\tred_end_of_idle_period(v);\n\tv->qavg = 0;\n\tv->qcount = -1;\n}\n\nstatic inline unsigned long red_calc_qavg_from_idle_time(const struct red_parms *p,\n\t\t\t\t\t\t\t const struct red_vars *v)\n{\n\ts64 delta = ktime_us_delta(ktime_get(), v->qidlestart);\n\tlong us_idle = min_t(s64, delta, p->Scell_max);\n\tint  shift;\n\n\t \n\n\tshift = p->Stab[(us_idle >> p->Scell_log) & RED_STAB_MASK];\n\n\tif (shift)\n\t\treturn v->qavg >> shift;\n\telse {\n\t\t \n\t\tus_idle = (v->qavg * (u64)us_idle) >> p->Scell_log;\n\n\t\tif (us_idle < (v->qavg >> 1))\n\t\t\treturn v->qavg - us_idle;\n\t\telse\n\t\t\treturn v->qavg >> 1;\n\t}\n}\n\nstatic inline unsigned long red_calc_qavg_no_idle_time(const struct red_parms *p,\n\t\t\t\t\t\t       const struct red_vars *v,\n\t\t\t\t\t\t       unsigned int backlog)\n{\n\t \n\treturn v->qavg + (backlog - (v->qavg >> p->Wlog));\n}\n\nstatic inline unsigned long red_calc_qavg(const struct red_parms *p,\n\t\t\t\t\t  const struct red_vars *v,\n\t\t\t\t\t  unsigned int backlog)\n{\n\tif (!red_is_idling(v))\n\t\treturn red_calc_qavg_no_idle_time(p, v, backlog);\n\telse\n\t\treturn red_calc_qavg_from_idle_time(p, v);\n}\n\n\nstatic inline u32 red_random(const struct red_parms *p)\n{\n\treturn reciprocal_divide(get_random_u32(), p->max_P_reciprocal);\n}\n\nstatic inline int red_mark_probability(const struct red_parms *p,\n\t\t\t\t       const struct red_vars *v,\n\t\t\t\t       unsigned long qavg)\n{\n\t \n\treturn !(((qavg - p->qth_min) >> p->Wlog) * v->qcount < v->qR);\n}\n\nenum {\n\tRED_BELOW_MIN_THRESH,\n\tRED_BETWEEN_TRESH,\n\tRED_ABOVE_MAX_TRESH,\n};\n\nstatic inline int red_cmp_thresh(const struct red_parms *p, unsigned long qavg)\n{\n\tif (qavg < p->qth_min)\n\t\treturn RED_BELOW_MIN_THRESH;\n\telse if (qavg >= p->qth_max)\n\t\treturn RED_ABOVE_MAX_TRESH;\n\telse\n\t\treturn RED_BETWEEN_TRESH;\n}\n\nenum {\n\tRED_DONT_MARK,\n\tRED_PROB_MARK,\n\tRED_HARD_MARK,\n};\n\nstatic inline int red_action(const struct red_parms *p,\n\t\t\t     struct red_vars *v,\n\t\t\t     unsigned long qavg)\n{\n\tswitch (red_cmp_thresh(p, qavg)) {\n\t\tcase RED_BELOW_MIN_THRESH:\n\t\t\tv->qcount = -1;\n\t\t\treturn RED_DONT_MARK;\n\n\t\tcase RED_BETWEEN_TRESH:\n\t\t\tif (++v->qcount) {\n\t\t\t\tif (red_mark_probability(p, v, qavg)) {\n\t\t\t\t\tv->qcount = 0;\n\t\t\t\t\tv->qR = red_random(p);\n\t\t\t\t\treturn RED_PROB_MARK;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tv->qR = red_random(p);\n\n\t\t\treturn RED_DONT_MARK;\n\n\t\tcase RED_ABOVE_MAX_TRESH:\n\t\t\tv->qcount = -1;\n\t\t\treturn RED_HARD_MARK;\n\t}\n\n\tBUG();\n\treturn RED_DONT_MARK;\n}\n\nstatic inline void red_adaptative_algo(struct red_parms *p, struct red_vars *v)\n{\n\tunsigned long qavg;\n\tu32 max_p_delta;\n\n\tqavg = v->qavg;\n\tif (red_is_idling(v))\n\t\tqavg = red_calc_qavg_from_idle_time(p, v);\n\n\t \n\tqavg >>= p->Wlog;\n\n\tif (qavg > p->target_max && p->max_P <= MAX_P_MAX)\n\t\tp->max_P += MAX_P_ALPHA(p->max_P);  \n\telse if (qavg < p->target_min && p->max_P >= MAX_P_MIN)\n\t\tp->max_P = (p->max_P/10)*9;  \n\n\tmax_p_delta = DIV_ROUND_CLOSEST(p->max_P, p->qth_delta);\n\tmax_p_delta = max(max_p_delta, 1U);\n\tp->max_P_reciprocal = reciprocal_value(max_p_delta);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}