{
  "module_name": "dsa.h",
  "hash_id": "e87363df8d6b322c179e66cc42c844dcd2aed51ffd103613af21558d56eb6845",
  "original_prompt": "Ingested from linux-6.6.14/include/net/dsa.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_NET_DSA_H\n#define __LINUX_NET_DSA_H\n\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/list.h>\n#include <linux/notifier.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/of.h>\n#include <linux/ethtool.h>\n#include <linux/net_tstamp.h>\n#include <linux/phy.h>\n#include <linux/platform_data/dsa.h>\n#include <linux/phylink.h>\n#include <net/devlink.h>\n#include <net/switchdev.h>\n\nstruct dsa_8021q_context;\nstruct tc_action;\nstruct phy_device;\nstruct fixed_phy_status;\nstruct phylink_link_state;\n\n#define DSA_TAG_PROTO_NONE_VALUE\t\t0\n#define DSA_TAG_PROTO_BRCM_VALUE\t\t1\n#define DSA_TAG_PROTO_BRCM_PREPEND_VALUE\t2\n#define DSA_TAG_PROTO_DSA_VALUE\t\t\t3\n#define DSA_TAG_PROTO_EDSA_VALUE\t\t4\n#define DSA_TAG_PROTO_GSWIP_VALUE\t\t5\n#define DSA_TAG_PROTO_KSZ9477_VALUE\t\t6\n#define DSA_TAG_PROTO_KSZ9893_VALUE\t\t7\n#define DSA_TAG_PROTO_LAN9303_VALUE\t\t8\n#define DSA_TAG_PROTO_MTK_VALUE\t\t\t9\n#define DSA_TAG_PROTO_QCA_VALUE\t\t\t10\n#define DSA_TAG_PROTO_TRAILER_VALUE\t\t11\n#define DSA_TAG_PROTO_8021Q_VALUE\t\t12\n#define DSA_TAG_PROTO_SJA1105_VALUE\t\t13\n#define DSA_TAG_PROTO_KSZ8795_VALUE\t\t14\n#define DSA_TAG_PROTO_OCELOT_VALUE\t\t15\n#define DSA_TAG_PROTO_AR9331_VALUE\t\t16\n#define DSA_TAG_PROTO_RTL4_A_VALUE\t\t17\n#define DSA_TAG_PROTO_HELLCREEK_VALUE\t\t18\n#define DSA_TAG_PROTO_XRS700X_VALUE\t\t19\n#define DSA_TAG_PROTO_OCELOT_8021Q_VALUE\t20\n#define DSA_TAG_PROTO_SEVILLE_VALUE\t\t21\n#define DSA_TAG_PROTO_BRCM_LEGACY_VALUE\t\t22\n#define DSA_TAG_PROTO_SJA1110_VALUE\t\t23\n#define DSA_TAG_PROTO_RTL8_4_VALUE\t\t24\n#define DSA_TAG_PROTO_RTL8_4T_VALUE\t\t25\n#define DSA_TAG_PROTO_RZN1_A5PSW_VALUE\t\t26\n#define DSA_TAG_PROTO_LAN937X_VALUE\t\t27\n\nenum dsa_tag_protocol {\n\tDSA_TAG_PROTO_NONE\t\t= DSA_TAG_PROTO_NONE_VALUE,\n\tDSA_TAG_PROTO_BRCM\t\t= DSA_TAG_PROTO_BRCM_VALUE,\n\tDSA_TAG_PROTO_BRCM_LEGACY\t= DSA_TAG_PROTO_BRCM_LEGACY_VALUE,\n\tDSA_TAG_PROTO_BRCM_PREPEND\t= DSA_TAG_PROTO_BRCM_PREPEND_VALUE,\n\tDSA_TAG_PROTO_DSA\t\t= DSA_TAG_PROTO_DSA_VALUE,\n\tDSA_TAG_PROTO_EDSA\t\t= DSA_TAG_PROTO_EDSA_VALUE,\n\tDSA_TAG_PROTO_GSWIP\t\t= DSA_TAG_PROTO_GSWIP_VALUE,\n\tDSA_TAG_PROTO_KSZ9477\t\t= DSA_TAG_PROTO_KSZ9477_VALUE,\n\tDSA_TAG_PROTO_KSZ9893\t\t= DSA_TAG_PROTO_KSZ9893_VALUE,\n\tDSA_TAG_PROTO_LAN9303\t\t= DSA_TAG_PROTO_LAN9303_VALUE,\n\tDSA_TAG_PROTO_MTK\t\t= DSA_TAG_PROTO_MTK_VALUE,\n\tDSA_TAG_PROTO_QCA\t\t= DSA_TAG_PROTO_QCA_VALUE,\n\tDSA_TAG_PROTO_TRAILER\t\t= DSA_TAG_PROTO_TRAILER_VALUE,\n\tDSA_TAG_PROTO_8021Q\t\t= DSA_TAG_PROTO_8021Q_VALUE,\n\tDSA_TAG_PROTO_SJA1105\t\t= DSA_TAG_PROTO_SJA1105_VALUE,\n\tDSA_TAG_PROTO_KSZ8795\t\t= DSA_TAG_PROTO_KSZ8795_VALUE,\n\tDSA_TAG_PROTO_OCELOT\t\t= DSA_TAG_PROTO_OCELOT_VALUE,\n\tDSA_TAG_PROTO_AR9331\t\t= DSA_TAG_PROTO_AR9331_VALUE,\n\tDSA_TAG_PROTO_RTL4_A\t\t= DSA_TAG_PROTO_RTL4_A_VALUE,\n\tDSA_TAG_PROTO_HELLCREEK\t\t= DSA_TAG_PROTO_HELLCREEK_VALUE,\n\tDSA_TAG_PROTO_XRS700X\t\t= DSA_TAG_PROTO_XRS700X_VALUE,\n\tDSA_TAG_PROTO_OCELOT_8021Q\t= DSA_TAG_PROTO_OCELOT_8021Q_VALUE,\n\tDSA_TAG_PROTO_SEVILLE\t\t= DSA_TAG_PROTO_SEVILLE_VALUE,\n\tDSA_TAG_PROTO_SJA1110\t\t= DSA_TAG_PROTO_SJA1110_VALUE,\n\tDSA_TAG_PROTO_RTL8_4\t\t= DSA_TAG_PROTO_RTL8_4_VALUE,\n\tDSA_TAG_PROTO_RTL8_4T\t\t= DSA_TAG_PROTO_RTL8_4T_VALUE,\n\tDSA_TAG_PROTO_RZN1_A5PSW\t= DSA_TAG_PROTO_RZN1_A5PSW_VALUE,\n\tDSA_TAG_PROTO_LAN937X\t\t= DSA_TAG_PROTO_LAN937X_VALUE,\n};\n\nstruct dsa_switch;\n\nstruct dsa_device_ops {\n\tstruct sk_buff *(*xmit)(struct sk_buff *skb, struct net_device *dev);\n\tstruct sk_buff *(*rcv)(struct sk_buff *skb, struct net_device *dev);\n\tvoid (*flow_dissect)(const struct sk_buff *skb, __be16 *proto,\n\t\t\t     int *offset);\n\tint (*connect)(struct dsa_switch *ds);\n\tvoid (*disconnect)(struct dsa_switch *ds);\n\tunsigned int needed_headroom;\n\tunsigned int needed_tailroom;\n\tconst char *name;\n\tenum dsa_tag_protocol proto;\n\t \n\tbool promisc_on_master;\n};\n\nstruct dsa_lag {\n\tstruct net_device *dev;\n\tunsigned int id;\n\tstruct mutex fdb_lock;\n\tstruct list_head fdbs;\n\trefcount_t refcount;\n};\n\nstruct dsa_switch_tree {\n\tstruct list_head\tlist;\n\n\t \n\tstruct list_head ports;\n\n\t \n\tstruct raw_notifier_head\tnh;\n\n\t \n\tunsigned int index;\n\n\t \n\tstruct kref refcount;\n\n\t \n\tstruct dsa_lag **lags;\n\n\t \n\tconst struct dsa_device_ops *tag_ops;\n\n\t \n\tenum dsa_tag_protocol default_proto;\n\n\t \n\tbool setup;\n\n\t \n\tstruct dsa_platform_data\t*pd;\n\n\t \n\tstruct list_head rtable;\n\n\t \n\tunsigned int lags_len;\n\n\t \n\tunsigned int last_switch;\n};\n\n \n#define dsa_lags_foreach_id(_id, _dst)\t\t\t\t\\\n\tfor ((_id) = 1; (_id) <= (_dst)->lags_len; (_id)++)\t\\\n\t\tif ((_dst)->lags[(_id) - 1])\n\n#define dsa_lag_foreach_port(_dp, _dst, _lag)\t\t\t\\\n\tlist_for_each_entry((_dp), &(_dst)->ports, list)\t\\\n\t\tif (dsa_port_offloads_lag((_dp), (_lag)))\n\n#define dsa_hsr_foreach_port(_dp, _ds, _hsr)\t\t\t\\\n\tlist_for_each_entry((_dp), &(_ds)->dst->ports, list)\t\\\n\t\tif ((_dp)->ds == (_ds) && (_dp)->hsr_dev == (_hsr))\n\nstatic inline struct dsa_lag *dsa_lag_by_id(struct dsa_switch_tree *dst,\n\t\t\t\t\t    unsigned int id)\n{\n\t \n\treturn dst->lags[id - 1];\n}\n\nstatic inline int dsa_lag_id(struct dsa_switch_tree *dst,\n\t\t\t     struct net_device *lag_dev)\n{\n\tunsigned int id;\n\n\tdsa_lags_foreach_id(id, dst) {\n\t\tstruct dsa_lag *lag = dsa_lag_by_id(dst, id);\n\n\t\tif (lag->dev == lag_dev)\n\t\t\treturn lag->id;\n\t}\n\n\treturn -ENODEV;\n}\n\n \nenum dsa_port_mall_action_type {\n\tDSA_PORT_MALL_MIRROR,\n\tDSA_PORT_MALL_POLICER,\n};\n\n \nstruct dsa_mall_mirror_tc_entry {\n\tu8 to_local_port;\n\tbool ingress;\n};\n\n \nstruct dsa_mall_policer_tc_entry {\n\tu32 burst;\n\tu64 rate_bytes_per_sec;\n};\n\n \nstruct dsa_mall_tc_entry {\n\tstruct list_head list;\n\tunsigned long cookie;\n\tenum dsa_port_mall_action_type type;\n\tunion {\n\t\tstruct dsa_mall_mirror_tc_entry mirror;\n\t\tstruct dsa_mall_policer_tc_entry policer;\n\t};\n};\n\nstruct dsa_bridge {\n\tstruct net_device *dev;\n\tunsigned int num;\n\tbool tx_fwd_offload;\n\trefcount_t refcount;\n};\n\nstruct dsa_port {\n\t \n\tunion {\n\t\tstruct net_device *master;\n\t\tstruct net_device *slave;\n\t};\n\n\t \n\tconst struct dsa_device_ops *tag_ops;\n\n\t \n\tstruct dsa_switch_tree *dst;\n\tstruct sk_buff *(*rcv)(struct sk_buff *skb, struct net_device *dev);\n\n\tstruct dsa_switch\t*ds;\n\n\tunsigned int\t\tindex;\n\n\tenum {\n\t\tDSA_PORT_TYPE_UNUSED = 0,\n\t\tDSA_PORT_TYPE_CPU,\n\t\tDSA_PORT_TYPE_DSA,\n\t\tDSA_PORT_TYPE_USER,\n\t} type;\n\n\tconst char\t\t*name;\n\tstruct dsa_port\t\t*cpu_dp;\n\tu8\t\t\tmac[ETH_ALEN];\n\n\tu8\t\t\tstp_state;\n\n\t \n\tu8\t\t\tvlan_filtering:1;\n\n\t \n\tu8\t\t\tlearning:1;\n\n\tu8\t\t\tlag_tx_enabled:1;\n\n\t \n\tu8\t\t\tmaster_admin_up:1;\n\tu8\t\t\tmaster_oper_up:1;\n\n\t \n\tu8\t\t\tcpu_port_in_lag:1;\n\n\tu8\t\t\tsetup:1;\n\n\tstruct device_node\t*dn;\n\tunsigned int\t\tageing_time;\n\n\tstruct dsa_bridge\t*bridge;\n\tstruct devlink_port\tdevlink_port;\n\tstruct phylink\t\t*pl;\n\tstruct phylink_config\tpl_config;\n\tstruct dsa_lag\t\t*lag;\n\tstruct net_device\t*hsr_dev;\n\n\tstruct list_head list;\n\n\t \n\tconst struct ethtool_ops *orig_ethtool_ops;\n\n\t \n\tstruct mutex\t\taddr_lists_lock;\n\tstruct list_head\tfdbs;\n\tstruct list_head\tmdbs;\n\n\tstruct mutex\t\tvlans_lock;\n\tunion {\n\t\t \n\t\tstruct list_head\tvlans;\n\t\t \n\t\tstruct list_head\tuser_vlans;\n\t};\n};\n\n \nstruct dsa_link {\n\tstruct dsa_port *dp;\n\tstruct dsa_port *link_dp;\n\tstruct list_head list;\n};\n\nenum dsa_db_type {\n\tDSA_DB_PORT,\n\tDSA_DB_LAG,\n\tDSA_DB_BRIDGE,\n};\n\nstruct dsa_db {\n\tenum dsa_db_type type;\n\n\tunion {\n\t\tconst struct dsa_port *dp;\n\t\tstruct dsa_lag lag;\n\t\tstruct dsa_bridge bridge;\n\t};\n};\n\nstruct dsa_mac_addr {\n\tunsigned char addr[ETH_ALEN];\n\tu16 vid;\n\trefcount_t refcount;\n\tstruct list_head list;\n\tstruct dsa_db db;\n};\n\nstruct dsa_vlan {\n\tu16 vid;\n\trefcount_t refcount;\n\tstruct list_head list;\n};\n\nstruct dsa_switch {\n\tstruct device *dev;\n\n\t \n\tstruct dsa_switch_tree\t*dst;\n\tunsigned int\t\tindex;\n\n\t \n\tu32\t\t\tsetup:1;\n\n\t \n\tu32\t\t\tvlan_filtering_is_global:1;\n\n\t \n\tu32\t\t\tneeds_standalone_vlan_filtering:1;\n\n\t \n\tu32\t\t\tconfigure_vlan_while_not_filtering:1;\n\n\t \n\tu32\t\t\tuntag_bridge_pvid:1;\n\n\t \n\tu32\t\t\tassisted_learning_on_cpu_port:1;\n\n\t \n\tu32\t\t\tvlan_filtering:1;\n\n\t \n\tu32\t\t\tmtu_enforcement_ingress:1;\n\n\t \n\tu32\t\t\tfdb_isolation:1;\n\n\t \n\tstruct notifier_block\tnb;\n\n\t \n\tvoid *priv;\n\n\tvoid *tagger_data;\n\n\t \n\tstruct dsa_chip_data\t*cd;\n\n\t \n\tconst struct dsa_switch_ops\t*ops;\n\n\t \n\tu32\t\t\tphys_mii_mask;\n\tstruct mii_bus\t\t*slave_mii_bus;\n\n\t \n\tunsigned int ageing_time_min;\n\tunsigned int ageing_time_max;\n\n\t \n\tstruct dsa_8021q_context *tag_8021q_ctx;\n\n\t \n\tstruct devlink\t\t*devlink;\n\n\t \n\tunsigned int\t\tnum_tx_queues;\n\n\t \n\tunsigned int\t\tnum_lag_ids;\n\n\t \n\tunsigned int\t\tmax_num_bridges;\n\n\tunsigned int\t\tnum_ports;\n};\n\nstatic inline struct dsa_port *dsa_to_port(struct dsa_switch *ds, int p)\n{\n\tstruct dsa_switch_tree *dst = ds->dst;\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tif (dp->ds == ds && dp->index == p)\n\t\t\treturn dp;\n\n\treturn NULL;\n}\n\nstatic inline bool dsa_port_is_dsa(struct dsa_port *port)\n{\n\treturn port->type == DSA_PORT_TYPE_DSA;\n}\n\nstatic inline bool dsa_port_is_cpu(struct dsa_port *port)\n{\n\treturn port->type == DSA_PORT_TYPE_CPU;\n}\n\nstatic inline bool dsa_port_is_user(struct dsa_port *dp)\n{\n\treturn dp->type == DSA_PORT_TYPE_USER;\n}\n\nstatic inline bool dsa_port_is_unused(struct dsa_port *dp)\n{\n\treturn dp->type == DSA_PORT_TYPE_UNUSED;\n}\n\nstatic inline bool dsa_port_master_is_operational(struct dsa_port *dp)\n{\n\treturn dsa_port_is_cpu(dp) && dp->master_admin_up &&\n\t       dp->master_oper_up;\n}\n\nstatic inline bool dsa_is_unused_port(struct dsa_switch *ds, int p)\n{\n\treturn dsa_to_port(ds, p)->type == DSA_PORT_TYPE_UNUSED;\n}\n\nstatic inline bool dsa_is_cpu_port(struct dsa_switch *ds, int p)\n{\n\treturn dsa_to_port(ds, p)->type == DSA_PORT_TYPE_CPU;\n}\n\nstatic inline bool dsa_is_dsa_port(struct dsa_switch *ds, int p)\n{\n\treturn dsa_to_port(ds, p)->type == DSA_PORT_TYPE_DSA;\n}\n\nstatic inline bool dsa_is_user_port(struct dsa_switch *ds, int p)\n{\n\treturn dsa_to_port(ds, p)->type == DSA_PORT_TYPE_USER;\n}\n\n#define dsa_tree_for_each_user_port(_dp, _dst) \\\n\tlist_for_each_entry((_dp), &(_dst)->ports, list) \\\n\t\tif (dsa_port_is_user((_dp)))\n\n#define dsa_tree_for_each_user_port_continue_reverse(_dp, _dst) \\\n\tlist_for_each_entry_continue_reverse((_dp), &(_dst)->ports, list) \\\n\t\tif (dsa_port_is_user((_dp)))\n\n#define dsa_tree_for_each_cpu_port(_dp, _dst) \\\n\tlist_for_each_entry((_dp), &(_dst)->ports, list) \\\n\t\tif (dsa_port_is_cpu((_dp)))\n\n#define dsa_switch_for_each_port(_dp, _ds) \\\n\tlist_for_each_entry((_dp), &(_ds)->dst->ports, list) \\\n\t\tif ((_dp)->ds == (_ds))\n\n#define dsa_switch_for_each_port_safe(_dp, _next, _ds) \\\n\tlist_for_each_entry_safe((_dp), (_next), &(_ds)->dst->ports, list) \\\n\t\tif ((_dp)->ds == (_ds))\n\n#define dsa_switch_for_each_port_continue_reverse(_dp, _ds) \\\n\tlist_for_each_entry_continue_reverse((_dp), &(_ds)->dst->ports, list) \\\n\t\tif ((_dp)->ds == (_ds))\n\n#define dsa_switch_for_each_available_port(_dp, _ds) \\\n\tdsa_switch_for_each_port((_dp), (_ds)) \\\n\t\tif (!dsa_port_is_unused((_dp)))\n\n#define dsa_switch_for_each_user_port(_dp, _ds) \\\n\tdsa_switch_for_each_port((_dp), (_ds)) \\\n\t\tif (dsa_port_is_user((_dp)))\n\n#define dsa_switch_for_each_cpu_port(_dp, _ds) \\\n\tdsa_switch_for_each_port((_dp), (_ds)) \\\n\t\tif (dsa_port_is_cpu((_dp)))\n\n#define dsa_switch_for_each_cpu_port_continue_reverse(_dp, _ds) \\\n\tdsa_switch_for_each_port_continue_reverse((_dp), (_ds)) \\\n\t\tif (dsa_port_is_cpu((_dp)))\n\nstatic inline u32 dsa_user_ports(struct dsa_switch *ds)\n{\n\tstruct dsa_port *dp;\n\tu32 mask = 0;\n\n\tdsa_switch_for_each_user_port(dp, ds)\n\t\tmask |= BIT(dp->index);\n\n\treturn mask;\n}\n\nstatic inline u32 dsa_cpu_ports(struct dsa_switch *ds)\n{\n\tstruct dsa_port *cpu_dp;\n\tu32 mask = 0;\n\n\tdsa_switch_for_each_cpu_port(cpu_dp, ds)\n\t\tmask |= BIT(cpu_dp->index);\n\n\treturn mask;\n}\n\n \nstatic inline unsigned int dsa_routing_port(struct dsa_switch *ds, int device)\n{\n\tstruct dsa_switch_tree *dst = ds->dst;\n\tstruct dsa_link *dl;\n\n\tlist_for_each_entry(dl, &dst->rtable, list)\n\t\tif (dl->dp->ds == ds && dl->link_dp->ds->index == device)\n\t\t\treturn dl->dp->index;\n\n\treturn ds->num_ports;\n}\n\n \nstatic inline unsigned int dsa_towards_port(struct dsa_switch *ds, int device,\n\t\t\t\t\t    int port)\n{\n\tif (device == ds->index)\n\t\treturn port;\n\telse\n\t\treturn dsa_routing_port(ds, device);\n}\n\n \nstatic inline unsigned int dsa_upstream_port(struct dsa_switch *ds, int port)\n{\n\tconst struct dsa_port *dp = dsa_to_port(ds, port);\n\tconst struct dsa_port *cpu_dp = dp->cpu_dp;\n\n\tif (!cpu_dp)\n\t\treturn port;\n\n\treturn dsa_towards_port(ds, cpu_dp->ds->index, cpu_dp->index);\n}\n\n \nstatic inline bool dsa_is_upstream_port(struct dsa_switch *ds, int port)\n{\n\tif (dsa_is_unused_port(ds, port))\n\t\treturn false;\n\n\treturn port == dsa_upstream_port(ds, port);\n}\n\n \nstatic inline bool dsa_is_downstream_port(struct dsa_switch *ds, int port)\n{\n\treturn dsa_is_dsa_port(ds, port) && !dsa_is_upstream_port(ds, port);\n}\n\n \nstatic inline unsigned int dsa_switch_upstream_port(struct dsa_switch *ds)\n{\n\tstruct dsa_port *dp;\n\n\tdsa_switch_for_each_available_port(dp, ds) {\n\t\treturn dsa_upstream_port(ds, dp->index);\n\t}\n\n\treturn ds->num_ports;\n}\n\n \nstatic inline bool dsa_switch_is_upstream_of(struct dsa_switch *upstream_ds,\n\t\t\t\t\t     struct dsa_switch *downstream_ds)\n{\n\tint routing_port;\n\n\tif (upstream_ds == downstream_ds)\n\t\treturn true;\n\n\trouting_port = dsa_routing_port(downstream_ds, upstream_ds->index);\n\n\treturn dsa_is_upstream_port(downstream_ds, routing_port);\n}\n\nstatic inline bool dsa_port_is_vlan_filtering(const struct dsa_port *dp)\n{\n\tconst struct dsa_switch *ds = dp->ds;\n\n\tif (ds->vlan_filtering_is_global)\n\t\treturn ds->vlan_filtering;\n\telse\n\t\treturn dp->vlan_filtering;\n}\n\nstatic inline unsigned int dsa_port_lag_id_get(struct dsa_port *dp)\n{\n\treturn dp->lag ? dp->lag->id : 0;\n}\n\nstatic inline struct net_device *dsa_port_lag_dev_get(struct dsa_port *dp)\n{\n\treturn dp->lag ? dp->lag->dev : NULL;\n}\n\nstatic inline bool dsa_port_offloads_lag(struct dsa_port *dp,\n\t\t\t\t\t const struct dsa_lag *lag)\n{\n\treturn dsa_port_lag_dev_get(dp) == lag->dev;\n}\n\nstatic inline struct net_device *dsa_port_to_master(const struct dsa_port *dp)\n{\n\tif (dp->cpu_port_in_lag)\n\t\treturn dsa_port_lag_dev_get(dp->cpu_dp);\n\n\treturn dp->cpu_dp->master;\n}\n\nstatic inline\nstruct net_device *dsa_port_to_bridge_port(const struct dsa_port *dp)\n{\n\tif (!dp->bridge)\n\t\treturn NULL;\n\n\tif (dp->lag)\n\t\treturn dp->lag->dev;\n\telse if (dp->hsr_dev)\n\t\treturn dp->hsr_dev;\n\n\treturn dp->slave;\n}\n\nstatic inline struct net_device *\ndsa_port_bridge_dev_get(const struct dsa_port *dp)\n{\n\treturn dp->bridge ? dp->bridge->dev : NULL;\n}\n\nstatic inline unsigned int dsa_port_bridge_num_get(struct dsa_port *dp)\n{\n\treturn dp->bridge ? dp->bridge->num : 0;\n}\n\nstatic inline bool dsa_port_bridge_same(const struct dsa_port *a,\n\t\t\t\t\tconst struct dsa_port *b)\n{\n\tstruct net_device *br_a = dsa_port_bridge_dev_get(a);\n\tstruct net_device *br_b = dsa_port_bridge_dev_get(b);\n\n\t \n\treturn (!br_a || !br_b) ? false : (br_a == br_b);\n}\n\nstatic inline bool dsa_port_offloads_bridge_port(struct dsa_port *dp,\n\t\t\t\t\t\t const struct net_device *dev)\n{\n\treturn dsa_port_to_bridge_port(dp) == dev;\n}\n\nstatic inline bool\ndsa_port_offloads_bridge_dev(struct dsa_port *dp,\n\t\t\t     const struct net_device *bridge_dev)\n{\n\t \n\treturn dsa_port_bridge_dev_get(dp) == bridge_dev;\n}\n\nstatic inline bool dsa_port_offloads_bridge(struct dsa_port *dp,\n\t\t\t\t\t    const struct dsa_bridge *bridge)\n{\n\treturn dsa_port_bridge_dev_get(dp) == bridge->dev;\n}\n\n \nstatic inline bool dsa_tree_offloads_bridge_port(struct dsa_switch_tree *dst,\n\t\t\t\t\t\t const struct net_device *dev)\n{\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tif (dsa_port_offloads_bridge_port(dp, dev))\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic inline bool\ndsa_tree_offloads_bridge_dev(struct dsa_switch_tree *dst,\n\t\t\t     const struct net_device *bridge_dev)\n{\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tif (dsa_port_offloads_bridge_dev(dp, bridge_dev))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool dsa_port_tree_same(const struct dsa_port *a,\n\t\t\t\t      const struct dsa_port *b)\n{\n\treturn a->ds->dst == b->ds->dst;\n}\n\ntypedef int dsa_fdb_dump_cb_t(const unsigned char *addr, u16 vid,\n\t\t\t      bool is_static, void *data);\nstruct dsa_switch_ops {\n\t \n\tenum dsa_tag_protocol (*get_tag_protocol)(struct dsa_switch *ds,\n\t\t\t\t\t\t  int port,\n\t\t\t\t\t\t  enum dsa_tag_protocol mprot);\n\tint\t(*change_tag_protocol)(struct dsa_switch *ds,\n\t\t\t\t       enum dsa_tag_protocol proto);\n\t \n\tint\t(*connect_tag_protocol)(struct dsa_switch *ds,\n\t\t\t\t\tenum dsa_tag_protocol proto);\n\n\tint\t(*port_change_master)(struct dsa_switch *ds, int port,\n\t\t\t\t      struct net_device *master,\n\t\t\t\t      struct netlink_ext_ack *extack);\n\n\t \n\tint\t(*setup)(struct dsa_switch *ds);\n\tvoid\t(*teardown)(struct dsa_switch *ds);\n\n\t \n\tint\t(*port_setup)(struct dsa_switch *ds, int port);\n\tvoid\t(*port_teardown)(struct dsa_switch *ds, int port);\n\n\tu32\t(*get_phy_flags)(struct dsa_switch *ds, int port);\n\n\t \n\tint\t(*phy_read)(struct dsa_switch *ds, int port, int regnum);\n\tint\t(*phy_write)(struct dsa_switch *ds, int port,\n\t\t\t     int regnum, u16 val);\n\n\t \n\tvoid\t(*adjust_link)(struct dsa_switch *ds, int port,\n\t\t\t\tstruct phy_device *phydev);\n\tvoid\t(*fixed_link_update)(struct dsa_switch *ds, int port,\n\t\t\t\tstruct fixed_phy_status *st);\n\n\t \n\tvoid\t(*phylink_get_caps)(struct dsa_switch *ds, int port,\n\t\t\t\t    struct phylink_config *config);\n\tstruct phylink_pcs *(*phylink_mac_select_pcs)(struct dsa_switch *ds,\n\t\t\t\t\t\t      int port,\n\t\t\t\t\t\t      phy_interface_t iface);\n\tint\t(*phylink_mac_prepare)(struct dsa_switch *ds, int port,\n\t\t\t\t       unsigned int mode,\n\t\t\t\t       phy_interface_t interface);\n\tvoid\t(*phylink_mac_config)(struct dsa_switch *ds, int port,\n\t\t\t\t      unsigned int mode,\n\t\t\t\t      const struct phylink_link_state *state);\n\tint\t(*phylink_mac_finish)(struct dsa_switch *ds, int port,\n\t\t\t\t      unsigned int mode,\n\t\t\t\t      phy_interface_t interface);\n\tvoid\t(*phylink_mac_link_down)(struct dsa_switch *ds, int port,\n\t\t\t\t\t unsigned int mode,\n\t\t\t\t\t phy_interface_t interface);\n\tvoid\t(*phylink_mac_link_up)(struct dsa_switch *ds, int port,\n\t\t\t\t       unsigned int mode,\n\t\t\t\t       phy_interface_t interface,\n\t\t\t\t       struct phy_device *phydev,\n\t\t\t\t       int speed, int duplex,\n\t\t\t\t       bool tx_pause, bool rx_pause);\n\tvoid\t(*phylink_fixed_state)(struct dsa_switch *ds, int port,\n\t\t\t\t       struct phylink_link_state *state);\n\t \n\tvoid\t(*get_strings)(struct dsa_switch *ds, int port,\n\t\t\t       u32 stringset, uint8_t *data);\n\tvoid\t(*get_ethtool_stats)(struct dsa_switch *ds,\n\t\t\t\t     int port, uint64_t *data);\n\tint\t(*get_sset_count)(struct dsa_switch *ds, int port, int sset);\n\tvoid\t(*get_ethtool_phy_stats)(struct dsa_switch *ds,\n\t\t\t\t\t int port, uint64_t *data);\n\tvoid\t(*get_eth_phy_stats)(struct dsa_switch *ds, int port,\n\t\t\t\t     struct ethtool_eth_phy_stats *phy_stats);\n\tvoid\t(*get_eth_mac_stats)(struct dsa_switch *ds, int port,\n\t\t\t\t     struct ethtool_eth_mac_stats *mac_stats);\n\tvoid\t(*get_eth_ctrl_stats)(struct dsa_switch *ds, int port,\n\t\t\t\t      struct ethtool_eth_ctrl_stats *ctrl_stats);\n\tvoid\t(*get_rmon_stats)(struct dsa_switch *ds, int port,\n\t\t\t\t  struct ethtool_rmon_stats *rmon_stats,\n\t\t\t\t  const struct ethtool_rmon_hist_range **ranges);\n\tvoid\t(*get_stats64)(struct dsa_switch *ds, int port,\n\t\t\t\t   struct rtnl_link_stats64 *s);\n\tvoid\t(*get_pause_stats)(struct dsa_switch *ds, int port,\n\t\t\t\t   struct ethtool_pause_stats *pause_stats);\n\tvoid\t(*self_test)(struct dsa_switch *ds, int port,\n\t\t\t     struct ethtool_test *etest, u64 *data);\n\n\t \n\tvoid\t(*get_wol)(struct dsa_switch *ds, int port,\n\t\t\t   struct ethtool_wolinfo *w);\n\tint\t(*set_wol)(struct dsa_switch *ds, int port,\n\t\t\t   struct ethtool_wolinfo *w);\n\n\t \n\tint\t(*get_ts_info)(struct dsa_switch *ds, int port,\n\t\t\t       struct ethtool_ts_info *ts);\n\n\t \n\tint\t(*get_mm)(struct dsa_switch *ds, int port,\n\t\t\t  struct ethtool_mm_state *state);\n\tint\t(*set_mm)(struct dsa_switch *ds, int port,\n\t\t\t  struct ethtool_mm_cfg *cfg,\n\t\t\t  struct netlink_ext_ack *extack);\n\tvoid\t(*get_mm_stats)(struct dsa_switch *ds, int port,\n\t\t\t\tstruct ethtool_mm_stats *stats);\n\n\t \n\tint\t(*port_get_default_prio)(struct dsa_switch *ds, int port);\n\tint\t(*port_set_default_prio)(struct dsa_switch *ds, int port,\n\t\t\t\t\t u8 prio);\n\tint\t(*port_get_dscp_prio)(struct dsa_switch *ds, int port, u8 dscp);\n\tint\t(*port_add_dscp_prio)(struct dsa_switch *ds, int port, u8 dscp,\n\t\t\t\t      u8 prio);\n\tint\t(*port_del_dscp_prio)(struct dsa_switch *ds, int port, u8 dscp,\n\t\t\t\t      u8 prio);\n\n\t \n\tint\t(*suspend)(struct dsa_switch *ds);\n\tint\t(*resume)(struct dsa_switch *ds);\n\n\t \n\tint\t(*port_enable)(struct dsa_switch *ds, int port,\n\t\t\t       struct phy_device *phy);\n\tvoid\t(*port_disable)(struct dsa_switch *ds, int port);\n\n\t \n\tstruct dsa_port *(*preferred_default_local_cpu_port)(struct dsa_switch *ds);\n\n\t \n\tint\t(*set_mac_eee)(struct dsa_switch *ds, int port,\n\t\t\t       struct ethtool_eee *e);\n\tint\t(*get_mac_eee)(struct dsa_switch *ds, int port,\n\t\t\t       struct ethtool_eee *e);\n\n\t \n\tint\t(*get_eeprom_len)(struct dsa_switch *ds);\n\tint\t(*get_eeprom)(struct dsa_switch *ds,\n\t\t\t      struct ethtool_eeprom *eeprom, u8 *data);\n\tint\t(*set_eeprom)(struct dsa_switch *ds,\n\t\t\t      struct ethtool_eeprom *eeprom, u8 *data);\n\n\t \n\tint\t(*get_regs_len)(struct dsa_switch *ds, int port);\n\tvoid\t(*get_regs)(struct dsa_switch *ds, int port,\n\t\t\t    struct ethtool_regs *regs, void *p);\n\n\t \n\tint\t(*port_prechangeupper)(struct dsa_switch *ds, int port,\n\t\t\t\t       struct netdev_notifier_changeupper_info *info);\n\n\t \n\tint\t(*set_ageing_time)(struct dsa_switch *ds, unsigned int msecs);\n\tint\t(*port_bridge_join)(struct dsa_switch *ds, int port,\n\t\t\t\t    struct dsa_bridge bridge,\n\t\t\t\t    bool *tx_fwd_offload,\n\t\t\t\t    struct netlink_ext_ack *extack);\n\tvoid\t(*port_bridge_leave)(struct dsa_switch *ds, int port,\n\t\t\t\t     struct dsa_bridge bridge);\n\tvoid\t(*port_stp_state_set)(struct dsa_switch *ds, int port,\n\t\t\t\t      u8 state);\n\tint\t(*port_mst_state_set)(struct dsa_switch *ds, int port,\n\t\t\t\t      const struct switchdev_mst_state *state);\n\tvoid\t(*port_fast_age)(struct dsa_switch *ds, int port);\n\tint\t(*port_vlan_fast_age)(struct dsa_switch *ds, int port, u16 vid);\n\tint\t(*port_pre_bridge_flags)(struct dsa_switch *ds, int port,\n\t\t\t\t\t struct switchdev_brport_flags flags,\n\t\t\t\t\t struct netlink_ext_ack *extack);\n\tint\t(*port_bridge_flags)(struct dsa_switch *ds, int port,\n\t\t\t\t     struct switchdev_brport_flags flags,\n\t\t\t\t     struct netlink_ext_ack *extack);\n\tvoid\t(*port_set_host_flood)(struct dsa_switch *ds, int port,\n\t\t\t\t       bool uc, bool mc);\n\n\t \n\tint\t(*port_vlan_filtering)(struct dsa_switch *ds, int port,\n\t\t\t\t       bool vlan_filtering,\n\t\t\t\t       struct netlink_ext_ack *extack);\n\tint\t(*port_vlan_add)(struct dsa_switch *ds, int port,\n\t\t\t\t const struct switchdev_obj_port_vlan *vlan,\n\t\t\t\t struct netlink_ext_ack *extack);\n\tint\t(*port_vlan_del)(struct dsa_switch *ds, int port,\n\t\t\t\t const struct switchdev_obj_port_vlan *vlan);\n\tint\t(*vlan_msti_set)(struct dsa_switch *ds, struct dsa_bridge bridge,\n\t\t\t\t const struct switchdev_vlan_msti *msti);\n\n\t \n\tint\t(*port_fdb_add)(struct dsa_switch *ds, int port,\n\t\t\t\tconst unsigned char *addr, u16 vid,\n\t\t\t\tstruct dsa_db db);\n\tint\t(*port_fdb_del)(struct dsa_switch *ds, int port,\n\t\t\t\tconst unsigned char *addr, u16 vid,\n\t\t\t\tstruct dsa_db db);\n\tint\t(*port_fdb_dump)(struct dsa_switch *ds, int port,\n\t\t\t\t dsa_fdb_dump_cb_t *cb, void *data);\n\tint\t(*lag_fdb_add)(struct dsa_switch *ds, struct dsa_lag lag,\n\t\t\t       const unsigned char *addr, u16 vid,\n\t\t\t       struct dsa_db db);\n\tint\t(*lag_fdb_del)(struct dsa_switch *ds, struct dsa_lag lag,\n\t\t\t       const unsigned char *addr, u16 vid,\n\t\t\t       struct dsa_db db);\n\n\t \n\tint\t(*port_mdb_add)(struct dsa_switch *ds, int port,\n\t\t\t\tconst struct switchdev_obj_port_mdb *mdb,\n\t\t\t\tstruct dsa_db db);\n\tint\t(*port_mdb_del)(struct dsa_switch *ds, int port,\n\t\t\t\tconst struct switchdev_obj_port_mdb *mdb,\n\t\t\t\tstruct dsa_db db);\n\t \n\tint\t(*get_rxnfc)(struct dsa_switch *ds, int port,\n\t\t\t     struct ethtool_rxnfc *nfc, u32 *rule_locs);\n\tint\t(*set_rxnfc)(struct dsa_switch *ds, int port,\n\t\t\t     struct ethtool_rxnfc *nfc);\n\n\t \n\tint\t(*cls_flower_add)(struct dsa_switch *ds, int port,\n\t\t\t\t  struct flow_cls_offload *cls, bool ingress);\n\tint\t(*cls_flower_del)(struct dsa_switch *ds, int port,\n\t\t\t\t  struct flow_cls_offload *cls, bool ingress);\n\tint\t(*cls_flower_stats)(struct dsa_switch *ds, int port,\n\t\t\t\t    struct flow_cls_offload *cls, bool ingress);\n\tint\t(*port_mirror_add)(struct dsa_switch *ds, int port,\n\t\t\t\t   struct dsa_mall_mirror_tc_entry *mirror,\n\t\t\t\t   bool ingress, struct netlink_ext_ack *extack);\n\tvoid\t(*port_mirror_del)(struct dsa_switch *ds, int port,\n\t\t\t\t   struct dsa_mall_mirror_tc_entry *mirror);\n\tint\t(*port_policer_add)(struct dsa_switch *ds, int port,\n\t\t\t\t    struct dsa_mall_policer_tc_entry *policer);\n\tvoid\t(*port_policer_del)(struct dsa_switch *ds, int port);\n\tint\t(*port_setup_tc)(struct dsa_switch *ds, int port,\n\t\t\t\t enum tc_setup_type type, void *type_data);\n\n\t \n\tint\t(*crosschip_bridge_join)(struct dsa_switch *ds, int tree_index,\n\t\t\t\t\t int sw_index, int port,\n\t\t\t\t\t struct dsa_bridge bridge,\n\t\t\t\t\t struct netlink_ext_ack *extack);\n\tvoid\t(*crosschip_bridge_leave)(struct dsa_switch *ds, int tree_index,\n\t\t\t\t\t  int sw_index, int port,\n\t\t\t\t\t  struct dsa_bridge bridge);\n\tint\t(*crosschip_lag_change)(struct dsa_switch *ds, int sw_index,\n\t\t\t\t\tint port);\n\tint\t(*crosschip_lag_join)(struct dsa_switch *ds, int sw_index,\n\t\t\t\t      int port, struct dsa_lag lag,\n\t\t\t\t      struct netdev_lag_upper_info *info,\n\t\t\t\t      struct netlink_ext_ack *extack);\n\tint\t(*crosschip_lag_leave)(struct dsa_switch *ds, int sw_index,\n\t\t\t\t       int port, struct dsa_lag lag);\n\n\t \n\tint\t(*port_hwtstamp_get)(struct dsa_switch *ds, int port,\n\t\t\t\t     struct ifreq *ifr);\n\tint\t(*port_hwtstamp_set)(struct dsa_switch *ds, int port,\n\t\t\t\t     struct ifreq *ifr);\n\tvoid\t(*port_txtstamp)(struct dsa_switch *ds, int port,\n\t\t\t\t struct sk_buff *skb);\n\tbool\t(*port_rxtstamp)(struct dsa_switch *ds, int port,\n\t\t\t\t struct sk_buff *skb, unsigned int type);\n\n\t \n\tint\t(*devlink_param_get)(struct dsa_switch *ds, u32 id,\n\t\t\t\t     struct devlink_param_gset_ctx *ctx);\n\tint\t(*devlink_param_set)(struct dsa_switch *ds, u32 id,\n\t\t\t\t     struct devlink_param_gset_ctx *ctx);\n\tint\t(*devlink_info_get)(struct dsa_switch *ds,\n\t\t\t\t    struct devlink_info_req *req,\n\t\t\t\t    struct netlink_ext_ack *extack);\n\tint\t(*devlink_sb_pool_get)(struct dsa_switch *ds,\n\t\t\t\t       unsigned int sb_index, u16 pool_index,\n\t\t\t\t       struct devlink_sb_pool_info *pool_info);\n\tint\t(*devlink_sb_pool_set)(struct dsa_switch *ds, unsigned int sb_index,\n\t\t\t\t       u16 pool_index, u32 size,\n\t\t\t\t       enum devlink_sb_threshold_type threshold_type,\n\t\t\t\t       struct netlink_ext_ack *extack);\n\tint\t(*devlink_sb_port_pool_get)(struct dsa_switch *ds, int port,\n\t\t\t\t\t    unsigned int sb_index, u16 pool_index,\n\t\t\t\t\t    u32 *p_threshold);\n\tint\t(*devlink_sb_port_pool_set)(struct dsa_switch *ds, int port,\n\t\t\t\t\t    unsigned int sb_index, u16 pool_index,\n\t\t\t\t\t    u32 threshold,\n\t\t\t\t\t    struct netlink_ext_ack *extack);\n\tint\t(*devlink_sb_tc_pool_bind_get)(struct dsa_switch *ds, int port,\n\t\t\t\t\t       unsigned int sb_index, u16 tc_index,\n\t\t\t\t\t       enum devlink_sb_pool_type pool_type,\n\t\t\t\t\t       u16 *p_pool_index, u32 *p_threshold);\n\tint\t(*devlink_sb_tc_pool_bind_set)(struct dsa_switch *ds, int port,\n\t\t\t\t\t       unsigned int sb_index, u16 tc_index,\n\t\t\t\t\t       enum devlink_sb_pool_type pool_type,\n\t\t\t\t\t       u16 pool_index, u32 threshold,\n\t\t\t\t\t       struct netlink_ext_ack *extack);\n\tint\t(*devlink_sb_occ_snapshot)(struct dsa_switch *ds,\n\t\t\t\t\t   unsigned int sb_index);\n\tint\t(*devlink_sb_occ_max_clear)(struct dsa_switch *ds,\n\t\t\t\t\t    unsigned int sb_index);\n\tint\t(*devlink_sb_occ_port_pool_get)(struct dsa_switch *ds, int port,\n\t\t\t\t\t\tunsigned int sb_index, u16 pool_index,\n\t\t\t\t\t\tu32 *p_cur, u32 *p_max);\n\tint\t(*devlink_sb_occ_tc_port_bind_get)(struct dsa_switch *ds, int port,\n\t\t\t\t\t\t   unsigned int sb_index, u16 tc_index,\n\t\t\t\t\t\t   enum devlink_sb_pool_type pool_type,\n\t\t\t\t\t\t   u32 *p_cur, u32 *p_max);\n\n\t \n\tint\t(*port_change_mtu)(struct dsa_switch *ds, int port,\n\t\t\t\t   int new_mtu);\n\tint\t(*port_max_mtu)(struct dsa_switch *ds, int port);\n\n\t \n\tint\t(*port_lag_change)(struct dsa_switch *ds, int port);\n\tint\t(*port_lag_join)(struct dsa_switch *ds, int port,\n\t\t\t\t struct dsa_lag lag,\n\t\t\t\t struct netdev_lag_upper_info *info,\n\t\t\t\t struct netlink_ext_ack *extack);\n\tint\t(*port_lag_leave)(struct dsa_switch *ds, int port,\n\t\t\t\t  struct dsa_lag lag);\n\n\t \n\tint\t(*port_hsr_join)(struct dsa_switch *ds, int port,\n\t\t\t\t struct net_device *hsr);\n\tint\t(*port_hsr_leave)(struct dsa_switch *ds, int port,\n\t\t\t\t  struct net_device *hsr);\n\n\t \n\tint\t(*port_mrp_add)(struct dsa_switch *ds, int port,\n\t\t\t\tconst struct switchdev_obj_mrp *mrp);\n\tint\t(*port_mrp_del)(struct dsa_switch *ds, int port,\n\t\t\t\tconst struct switchdev_obj_mrp *mrp);\n\tint\t(*port_mrp_add_ring_role)(struct dsa_switch *ds, int port,\n\t\t\t\t\t  const struct switchdev_obj_ring_role_mrp *mrp);\n\tint\t(*port_mrp_del_ring_role)(struct dsa_switch *ds, int port,\n\t\t\t\t\t  const struct switchdev_obj_ring_role_mrp *mrp);\n\n\t \n\tint\t(*tag_8021q_vlan_add)(struct dsa_switch *ds, int port, u16 vid,\n\t\t\t\t      u16 flags);\n\tint\t(*tag_8021q_vlan_del)(struct dsa_switch *ds, int port, u16 vid);\n\n\t \n\tvoid\t(*master_state_change)(struct dsa_switch *ds,\n\t\t\t\t       const struct net_device *master,\n\t\t\t\t       bool operational);\n};\n\n#define DSA_DEVLINK_PARAM_DRIVER(_id, _name, _type, _cmodes)\t\t\\\n\tDEVLINK_PARAM_DRIVER(_id, _name, _type, _cmodes,\t\t\\\n\t\t\t     dsa_devlink_param_get, dsa_devlink_param_set, NULL)\n\nint dsa_devlink_param_get(struct devlink *dl, u32 id,\n\t\t\t  struct devlink_param_gset_ctx *ctx);\nint dsa_devlink_param_set(struct devlink *dl, u32 id,\n\t\t\t  struct devlink_param_gset_ctx *ctx);\nint dsa_devlink_params_register(struct dsa_switch *ds,\n\t\t\t\tconst struct devlink_param *params,\n\t\t\t\tsize_t params_count);\nvoid dsa_devlink_params_unregister(struct dsa_switch *ds,\n\t\t\t\t   const struct devlink_param *params,\n\t\t\t\t   size_t params_count);\nint dsa_devlink_resource_register(struct dsa_switch *ds,\n\t\t\t\t  const char *resource_name,\n\t\t\t\t  u64 resource_size,\n\t\t\t\t  u64 resource_id,\n\t\t\t\t  u64 parent_resource_id,\n\t\t\t\t  const struct devlink_resource_size_params *size_params);\n\nvoid dsa_devlink_resources_unregister(struct dsa_switch *ds);\n\nvoid dsa_devlink_resource_occ_get_register(struct dsa_switch *ds,\n\t\t\t\t\t   u64 resource_id,\n\t\t\t\t\t   devlink_resource_occ_get_t *occ_get,\n\t\t\t\t\t   void *occ_get_priv);\nvoid dsa_devlink_resource_occ_get_unregister(struct dsa_switch *ds,\n\t\t\t\t\t     u64 resource_id);\nstruct devlink_region *\ndsa_devlink_region_create(struct dsa_switch *ds,\n\t\t\t  const struct devlink_region_ops *ops,\n\t\t\t  u32 region_max_snapshots, u64 region_size);\nstruct devlink_region *\ndsa_devlink_port_region_create(struct dsa_switch *ds,\n\t\t\t       int port,\n\t\t\t       const struct devlink_port_region_ops *ops,\n\t\t\t       u32 region_max_snapshots, u64 region_size);\nvoid dsa_devlink_region_destroy(struct devlink_region *region);\n\nstruct dsa_port *dsa_port_from_netdev(struct net_device *netdev);\n\nstruct dsa_devlink_priv {\n\tstruct dsa_switch *ds;\n};\n\nstatic inline struct dsa_switch *dsa_devlink_to_ds(struct devlink *dl)\n{\n\tstruct dsa_devlink_priv *dl_priv = devlink_priv(dl);\n\n\treturn dl_priv->ds;\n}\n\nstatic inline\nstruct dsa_switch *dsa_devlink_port_to_ds(struct devlink_port *port)\n{\n\tstruct devlink *dl = port->devlink;\n\tstruct dsa_devlink_priv *dl_priv = devlink_priv(dl);\n\n\treturn dl_priv->ds;\n}\n\nstatic inline int dsa_devlink_port_to_port(struct devlink_port *port)\n{\n\treturn port->index;\n}\n\nstruct dsa_switch_driver {\n\tstruct list_head\tlist;\n\tconst struct dsa_switch_ops *ops;\n};\n\nbool dsa_fdb_present_in_other_db(struct dsa_switch *ds, int port,\n\t\t\t\t const unsigned char *addr, u16 vid,\n\t\t\t\t struct dsa_db db);\nbool dsa_mdb_present_in_other_db(struct dsa_switch *ds, int port,\n\t\t\t\t const struct switchdev_obj_port_mdb *mdb,\n\t\t\t\t struct dsa_db db);\n\n \nstatic inline bool netdev_uses_dsa(const struct net_device *dev)\n{\n#if IS_ENABLED(CONFIG_NET_DSA)\n\treturn dev->dsa_ptr && dev->dsa_ptr->rcv;\n#endif\n\treturn false;\n}\n\n \nstatic inline void dsa_tag_generic_flow_dissect(const struct sk_buff *skb,\n\t\t\t\t\t\t__be16 *proto, int *offset)\n{\n#if IS_ENABLED(CONFIG_NET_DSA)\n\tconst struct dsa_device_ops *ops = skb->dev->dsa_ptr->tag_ops;\n\tint tag_len = ops->needed_headroom;\n\n\t*offset = tag_len;\n\t*proto = ((__be16 *)skb->data)[(tag_len / 2) - 1];\n#endif\n}\n\nvoid dsa_unregister_switch(struct dsa_switch *ds);\nint dsa_register_switch(struct dsa_switch *ds);\nvoid dsa_switch_shutdown(struct dsa_switch *ds);\nstruct dsa_switch *dsa_switch_find(int tree_index, int sw_index);\nvoid dsa_flush_workqueue(void);\n#ifdef CONFIG_PM_SLEEP\nint dsa_switch_suspend(struct dsa_switch *ds);\nint dsa_switch_resume(struct dsa_switch *ds);\n#else\nstatic inline int dsa_switch_suspend(struct dsa_switch *ds)\n{\n\treturn 0;\n}\nstatic inline int dsa_switch_resume(struct dsa_switch *ds)\n{\n\treturn 0;\n}\n#endif  \n\n#if IS_ENABLED(CONFIG_NET_DSA)\nbool dsa_slave_dev_check(const struct net_device *dev);\n#else\nstatic inline bool dsa_slave_dev_check(const struct net_device *dev)\n{\n\treturn false;\n}\n#endif\n\nnetdev_tx_t dsa_enqueue_skb(struct sk_buff *skb, struct net_device *dev);\nvoid dsa_port_phylink_mac_change(struct dsa_switch *ds, int port, bool up);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}