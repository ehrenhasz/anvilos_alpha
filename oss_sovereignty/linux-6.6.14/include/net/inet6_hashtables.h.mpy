{
  "module_name": "inet6_hashtables.h",
  "hash_id": "6fe14a61aa83e481bed85e80f52975bbda5550fa4a4ecaf3686383f43b3e8014",
  "original_prompt": "Ingested from linux-6.6.14/include/net/inet6_hashtables.h",
  "human_readable_source": " \n \n\n#ifndef _INET6_HASHTABLES_H\n#define _INET6_HASHTABLES_H\n\n\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/types.h>\n#include <linux/jhash.h>\n\n#include <net/inet_sock.h>\n\n#include <net/ipv6.h>\n#include <net/netns/hash.h>\n\nstruct inet_hashinfo;\n\nstatic inline unsigned int __inet6_ehashfn(const u32 lhash,\n\t\t\t\t    const u16 lport,\n\t\t\t\t    const u32 fhash,\n\t\t\t\t    const __be16 fport,\n\t\t\t\t    const u32 initval)\n{\n\tconst u32 ports = (((u32)lport) << 16) | (__force u32)fport;\n\treturn jhash_3words(lhash, fhash, ports, initval);\n}\n\n \nstruct sock *__inet6_lookup_established(struct net *net,\n\t\t\t\t\tstruct inet_hashinfo *hashinfo,\n\t\t\t\t\tconst struct in6_addr *saddr,\n\t\t\t\t\tconst __be16 sport,\n\t\t\t\t\tconst struct in6_addr *daddr,\n\t\t\t\t\tconst u16 hnum, const int dif,\n\t\t\t\t\tconst int sdif);\n\ntypedef u32 (inet6_ehashfn_t)(const struct net *net,\n\t\t\t       const struct in6_addr *laddr, const u16 lport,\n\t\t\t       const struct in6_addr *faddr, const __be16 fport);\n\ninet6_ehashfn_t inet6_ehashfn;\n\nINDIRECT_CALLABLE_DECLARE(inet6_ehashfn_t udp6_ehashfn);\n\nstruct sock *inet6_lookup_reuseport(struct net *net, struct sock *sk,\n\t\t\t\t    struct sk_buff *skb, int doff,\n\t\t\t\t    const struct in6_addr *saddr,\n\t\t\t\t    __be16 sport,\n\t\t\t\t    const struct in6_addr *daddr,\n\t\t\t\t    unsigned short hnum,\n\t\t\t\t    inet6_ehashfn_t *ehashfn);\n\nstruct sock *inet6_lookup_listener(struct net *net,\n\t\t\t\t   struct inet_hashinfo *hashinfo,\n\t\t\t\t   struct sk_buff *skb, int doff,\n\t\t\t\t   const struct in6_addr *saddr,\n\t\t\t\t   const __be16 sport,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   const unsigned short hnum,\n\t\t\t\t   const int dif, const int sdif);\n\nstruct sock *inet6_lookup_run_sk_lookup(struct net *net,\n\t\t\t\t\tint protocol,\n\t\t\t\t\tstruct sk_buff *skb, int doff,\n\t\t\t\t\tconst struct in6_addr *saddr,\n\t\t\t\t\tconst __be16 sport,\n\t\t\t\t\tconst struct in6_addr *daddr,\n\t\t\t\t\tconst u16 hnum, const int dif,\n\t\t\t\t\tinet6_ehashfn_t *ehashfn);\n\nstatic inline struct sock *__inet6_lookup(struct net *net,\n\t\t\t\t\t  struct inet_hashinfo *hashinfo,\n\t\t\t\t\t  struct sk_buff *skb, int doff,\n\t\t\t\t\t  const struct in6_addr *saddr,\n\t\t\t\t\t  const __be16 sport,\n\t\t\t\t\t  const struct in6_addr *daddr,\n\t\t\t\t\t  const u16 hnum,\n\t\t\t\t\t  const int dif, const int sdif,\n\t\t\t\t\t  bool *refcounted)\n{\n\tstruct sock *sk = __inet6_lookup_established(net, hashinfo, saddr,\n\t\t\t\t\t\t     sport, daddr, hnum,\n\t\t\t\t\t\t     dif, sdif);\n\t*refcounted = true;\n\tif (sk)\n\t\treturn sk;\n\t*refcounted = false;\n\treturn inet6_lookup_listener(net, hashinfo, skb, doff, saddr, sport,\n\t\t\t\t     daddr, hnum, dif, sdif);\n}\n\nstatic inline\nstruct sock *inet6_steal_sock(struct net *net, struct sk_buff *skb, int doff,\n\t\t\t      const struct in6_addr *saddr, const __be16 sport,\n\t\t\t      const struct in6_addr *daddr, const __be16 dport,\n\t\t\t      bool *refcounted, inet6_ehashfn_t *ehashfn)\n{\n\tstruct sock *sk, *reuse_sk;\n\tbool prefetched;\n\n\tsk = skb_steal_sock(skb, refcounted, &prefetched);\n\tif (!sk)\n\t\treturn NULL;\n\n\tif (!prefetched || !sk_fullsock(sk))\n\t\treturn sk;\n\n\tif (sk->sk_protocol == IPPROTO_TCP) {\n\t\tif (sk->sk_state != TCP_LISTEN)\n\t\t\treturn sk;\n\t} else if (sk->sk_protocol == IPPROTO_UDP) {\n\t\tif (sk->sk_state != TCP_CLOSE)\n\t\t\treturn sk;\n\t} else {\n\t\treturn sk;\n\t}\n\n\treuse_sk = inet6_lookup_reuseport(net, sk, skb, doff,\n\t\t\t\t\t  saddr, sport, daddr, ntohs(dport),\n\t\t\t\t\t  ehashfn);\n\tif (!reuse_sk)\n\t\treturn sk;\n\n\t \n\tWARN_ON_ONCE(*refcounted);\n\n\treturn reuse_sk;\n}\n\nstatic inline struct sock *__inet6_lookup_skb(struct inet_hashinfo *hashinfo,\n\t\t\t\t\t      struct sk_buff *skb, int doff,\n\t\t\t\t\t      const __be16 sport,\n\t\t\t\t\t      const __be16 dport,\n\t\t\t\t\t      int iif, int sdif,\n\t\t\t\t\t      bool *refcounted)\n{\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tstruct sock *sk;\n\n\tsk = inet6_steal_sock(net, skb, doff, &ip6h->saddr, sport, &ip6h->daddr, dport,\n\t\t\t      refcounted, inet6_ehashfn);\n\tif (IS_ERR(sk))\n\t\treturn NULL;\n\tif (sk)\n\t\treturn sk;\n\n\treturn __inet6_lookup(net, hashinfo, skb,\n\t\t\t      doff, &ip6h->saddr, sport,\n\t\t\t      &ip6h->daddr, ntohs(dport),\n\t\t\t      iif, sdif, refcounted);\n}\n\nstruct sock *inet6_lookup(struct net *net, struct inet_hashinfo *hashinfo,\n\t\t\t  struct sk_buff *skb, int doff,\n\t\t\t  const struct in6_addr *saddr, const __be16 sport,\n\t\t\t  const struct in6_addr *daddr, const __be16 dport,\n\t\t\t  const int dif);\n\nint inet6_hash(struct sock *sk);\n\nstatic inline bool inet6_match(struct net *net, const struct sock *sk,\n\t\t\t       const struct in6_addr *saddr,\n\t\t\t       const struct in6_addr *daddr,\n\t\t\t       const __portpair ports,\n\t\t\t       const int dif, const int sdif)\n{\n\tif (!net_eq(sock_net(sk), net) ||\n\t    sk->sk_family != AF_INET6 ||\n\t    sk->sk_portpair != ports ||\n\t    !ipv6_addr_equal(&sk->sk_v6_daddr, saddr) ||\n\t    !ipv6_addr_equal(&sk->sk_v6_rcv_saddr, daddr))\n\t\treturn false;\n\n\t \n\treturn inet_sk_bound_dev_eq(net, READ_ONCE(sk->sk_bound_dev_if), dif,\n\t\t\t\t    sdif);\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}