{
  "module_name": "sock_reuseport.h",
  "hash_id": "5c11da3489f411ad91b9b712f66445de650d4eb3d9a76d6fbc344ced4d6c2777",
  "original_prompt": "Ingested from linux-6.6.14/include/net/sock_reuseport.h",
  "human_readable_source": " \n#ifndef _SOCK_REUSEPORT_H\n#define _SOCK_REUSEPORT_H\n\n#include <linux/filter.h>\n#include <linux/skbuff.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <net/sock.h>\n\nextern spinlock_t reuseport_lock;\n\nstruct sock_reuseport {\n\tstruct rcu_head\t\trcu;\n\n\tu16\t\t\tmax_socks;\t\t \n\tu16\t\t\tnum_socks;\t\t \n\tu16\t\t\tnum_closed_socks;\t \n\tu16\t\t\tincoming_cpu;\n\t \n\tunsigned int\t\tsynq_overflow_ts;\n\t \n\tunsigned int\t\treuseport_id;\n\tunsigned int\t\tbind_inany:1;\n\tunsigned int\t\thas_conns:1;\n\tstruct bpf_prog __rcu\t*prog;\t\t \n\tstruct sock\t\t*socks[];\t \n};\n\nextern int reuseport_alloc(struct sock *sk, bool bind_inany);\nextern int reuseport_add_sock(struct sock *sk, struct sock *sk2,\n\t\t\t      bool bind_inany);\nextern void reuseport_detach_sock(struct sock *sk);\nvoid reuseport_stop_listen_sock(struct sock *sk);\nextern struct sock *reuseport_select_sock(struct sock *sk,\n\t\t\t\t\t  u32 hash,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  int hdr_len);\nstruct sock *reuseport_migrate_sock(struct sock *sk,\n\t\t\t\t    struct sock *migrating_sk,\n\t\t\t\t    struct sk_buff *skb);\nextern int reuseport_attach_prog(struct sock *sk, struct bpf_prog *prog);\nextern int reuseport_detach_prog(struct sock *sk);\n\nstatic inline bool reuseport_has_conns(struct sock *sk)\n{\n\tstruct sock_reuseport *reuse;\n\tbool ret = false;\n\n\trcu_read_lock();\n\treuse = rcu_dereference(sk->sk_reuseport_cb);\n\tif (reuse && reuse->has_conns)\n\t\tret = true;\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nvoid reuseport_has_conns_set(struct sock *sk);\nvoid reuseport_update_incoming_cpu(struct sock *sk, int val);\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}