{
  "module_name": "ip6_fib.h",
  "hash_id": "f6a3a5b11c3bb4bcf78130523b9523b0b1e72720f0bbf51b40a52fc113e284a6",
  "original_prompt": "Ingested from linux-6.6.14/include/net/ip6_fib.h",
  "human_readable_source": " \n \n\n#ifndef _IP6_FIB_H\n#define _IP6_FIB_H\n\n#include <linux/ipv6_route.h>\n#include <linux/rtnetlink.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <net/dst.h>\n#include <net/flow.h>\n#include <net/ip_fib.h>\n#include <net/netlink.h>\n#include <net/inetpeer.h>\n#include <net/fib_notifier.h>\n#include <linux/indirect_call_wrapper.h>\n#include <uapi/linux/bpf.h>\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n#define FIB6_TABLE_HASHSZ 256\n#else\n#define FIB6_TABLE_HASHSZ 1\n#endif\n\n#define RT6_DEBUG 2\n\n#if RT6_DEBUG >= 3\n#define RT6_TRACE(x...) pr_debug(x)\n#else\n#define RT6_TRACE(x...) do { ; } while (0)\n#endif\n\nstruct rt6_info;\nstruct fib6_info;\n\nstruct fib6_config {\n\tu32\t\tfc_table;\n\tu32\t\tfc_metric;\n\tint\t\tfc_dst_len;\n\tint\t\tfc_src_len;\n\tint\t\tfc_ifindex;\n\tu32\t\tfc_flags;\n\tu32\t\tfc_protocol;\n\tu16\t\tfc_type;         \n\tu16\t\tfc_delete_all_nh : 1,\n\t\t\tfc_ignore_dev_down:1,\n\t\t\t__unused : 14;\n\tu32\t\tfc_nh_id;\n\n\tstruct in6_addr\tfc_dst;\n\tstruct in6_addr\tfc_src;\n\tstruct in6_addr\tfc_prefsrc;\n\tstruct in6_addr\tfc_gateway;\n\n\tunsigned long\tfc_expires;\n\tstruct nlattr\t*fc_mx;\n\tint\t\tfc_mx_len;\n\tint\t\tfc_mp_len;\n\tstruct nlattr\t*fc_mp;\n\n\tstruct nl_info\tfc_nlinfo;\n\tstruct nlattr\t*fc_encap;\n\tu16\t\tfc_encap_type;\n\tbool\t\tfc_is_fdb;\n};\n\nstruct fib6_node {\n\tstruct fib6_node __rcu\t*parent;\n\tstruct fib6_node __rcu\t*left;\n\tstruct fib6_node __rcu\t*right;\n#ifdef CONFIG_IPV6_SUBTREES\n\tstruct fib6_node __rcu\t*subtree;\n#endif\n\tstruct fib6_info __rcu\t*leaf;\n\n\t__u16\t\t\tfn_bit;\t\t \n\t__u16\t\t\tfn_flags;\n\tint\t\t\tfn_sernum;\n\tstruct fib6_info __rcu\t*rr_ptr;\n\tstruct rcu_head\t\trcu;\n};\n\nstruct fib6_gc_args {\n\tint\t\t\ttimeout;\n\tint\t\t\tmore;\n};\n\n#ifndef CONFIG_IPV6_SUBTREES\n#define FIB6_SUBTREE(fn)\tNULL\n\nstatic inline bool fib6_routes_require_src(const struct net *net)\n{\n\treturn false;\n}\n\nstatic inline void fib6_routes_require_src_inc(struct net *net) {}\nstatic inline void fib6_routes_require_src_dec(struct net *net) {}\n\n#else\n\nstatic inline bool fib6_routes_require_src(const struct net *net)\n{\n\treturn net->ipv6.fib6_routes_require_src > 0;\n}\n\nstatic inline void fib6_routes_require_src_inc(struct net *net)\n{\n\tnet->ipv6.fib6_routes_require_src++;\n}\n\nstatic inline void fib6_routes_require_src_dec(struct net *net)\n{\n\tnet->ipv6.fib6_routes_require_src--;\n}\n\n#define FIB6_SUBTREE(fn)\t(rcu_dereference_protected((fn)->subtree, 1))\n#endif\n\n \n\nstruct rt6key {\n\tstruct in6_addr\taddr;\n\tint\t\tplen;\n};\n\nstruct fib6_table;\n\nstruct rt6_exception_bucket {\n\tstruct hlist_head\tchain;\n\tint\t\t\tdepth;\n};\n\nstruct rt6_exception {\n\tstruct hlist_node\thlist;\n\tstruct rt6_info\t\t*rt6i;\n\tunsigned long\t\tstamp;\n\tstruct rcu_head\t\trcu;\n};\n\n#define FIB6_EXCEPTION_BUCKET_SIZE_SHIFT 10\n#define FIB6_EXCEPTION_BUCKET_SIZE (1 << FIB6_EXCEPTION_BUCKET_SIZE_SHIFT)\n#define FIB6_MAX_DEPTH 5\n\nstruct fib6_nh {\n\tstruct fib_nh_common\tnh_common;\n\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\tunsigned long\t\tlast_probe;\n#endif\n\n\tstruct rt6_info * __percpu *rt6i_pcpu;\n\tstruct rt6_exception_bucket __rcu *rt6i_exception_bucket;\n};\n\nstruct fib6_info {\n\tstruct fib6_table\t\t*fib6_table;\n\tstruct fib6_info __rcu\t\t*fib6_next;\n\tstruct fib6_node __rcu\t\t*fib6_node;\n\n\t \n\tunion {\n\t\tstruct list_head\tfib6_siblings;\n\t\tstruct list_head\tnh_list;\n\t};\n\tunsigned int\t\t\tfib6_nsiblings;\n\n\trefcount_t\t\t\tfib6_ref;\n\tunsigned long\t\t\texpires;\n\tstruct dst_metrics\t\t*fib6_metrics;\n#define fib6_pmtu\t\tfib6_metrics->metrics[RTAX_MTU-1]\n\n\tstruct rt6key\t\t\tfib6_dst;\n\tu32\t\t\t\tfib6_flags;\n\tstruct rt6key\t\t\tfib6_src;\n\tstruct rt6key\t\t\tfib6_prefsrc;\n\n\tu32\t\t\t\tfib6_metric;\n\tu8\t\t\t\tfib6_protocol;\n\tu8\t\t\t\tfib6_type;\n\n\tu8\t\t\t\toffload;\n\tu8\t\t\t\ttrap;\n\tu8\t\t\t\toffload_failed;\n\n\tu8\t\t\t\tshould_flush:1,\n\t\t\t\t\tdst_nocount:1,\n\t\t\t\t\tdst_nopolicy:1,\n\t\t\t\t\tfib6_destroying:1,\n\t\t\t\t\tunused:4;\n\n\tstruct rcu_head\t\t\trcu;\n\tstruct nexthop\t\t\t*nh;\n\tstruct fib6_nh\t\t\tfib6_nh[];\n};\n\nstruct rt6_info {\n\tstruct dst_entry\t\tdst;\n\tstruct fib6_info __rcu\t\t*from;\n\tint\t\t\t\tsernum;\n\n\tstruct rt6key\t\t\trt6i_dst;\n\tstruct rt6key\t\t\trt6i_src;\n\tstruct in6_addr\t\t\trt6i_gateway;\n\tstruct inet6_dev\t\t*rt6i_idev;\n\tu32\t\t\t\trt6i_flags;\n\n\t \n\tunsigned short\t\t\trt6i_nfheader_len;\n};\n\nstruct fib6_result {\n\tstruct fib6_nh\t\t*nh;\n\tstruct fib6_info\t*f6i;\n\tu32\t\t\tfib6_flags;\n\tu8\t\t\tfib6_type;\n\tstruct rt6_info\t\t*rt6;\n};\n\n#define for_each_fib6_node_rt_rcu(fn)\t\t\t\t\t\\\n\tfor (rt = rcu_dereference((fn)->leaf); rt;\t\t\t\\\n\t     rt = rcu_dereference(rt->fib6_next))\n\n#define for_each_fib6_walker_rt(w)\t\t\t\t\t\\\n\tfor (rt = (w)->leaf; rt;\t\t\t\t\t\\\n\t     rt = rcu_dereference_protected(rt->fib6_next, 1))\n\nstatic inline struct inet6_dev *ip6_dst_idev(struct dst_entry *dst)\n{\n\treturn ((struct rt6_info *)dst)->rt6i_idev;\n}\n\nstatic inline bool fib6_requires_src(const struct fib6_info *rt)\n{\n\treturn rt->fib6_src.plen > 0;\n}\n\nstatic inline void fib6_clean_expires(struct fib6_info *f6i)\n{\n\tf6i->fib6_flags &= ~RTF_EXPIRES;\n\tf6i->expires = 0;\n}\n\nstatic inline void fib6_set_expires(struct fib6_info *f6i,\n\t\t\t\t    unsigned long expires)\n{\n\tf6i->expires = expires;\n\tf6i->fib6_flags |= RTF_EXPIRES;\n}\n\nstatic inline bool fib6_check_expired(const struct fib6_info *f6i)\n{\n\tif (f6i->fib6_flags & RTF_EXPIRES)\n\t\treturn time_after(jiffies, f6i->expires);\n\treturn false;\n}\n\n \nstatic inline bool fib6_get_cookie_safe(const struct fib6_info *f6i,\n\t\t\t\t\tu32 *cookie)\n{\n\tstruct fib6_node *fn;\n\tbool status = false;\n\n\tfn = rcu_dereference(f6i->fib6_node);\n\n\tif (fn) {\n\t\t*cookie = READ_ONCE(fn->fn_sernum);\n\t\t \n\t\tsmp_rmb();\n\t\tstatus = true;\n\t}\n\n\treturn status;\n}\n\nstatic inline u32 rt6_get_cookie(const struct rt6_info *rt)\n{\n\tstruct fib6_info *from;\n\tu32 cookie = 0;\n\n\tif (rt->sernum)\n\t\treturn rt->sernum;\n\n\trcu_read_lock();\n\n\tfrom = rcu_dereference(rt->from);\n\tif (from)\n\t\tfib6_get_cookie_safe(from, &cookie);\n\n\trcu_read_unlock();\n\n\treturn cookie;\n}\n\nstatic inline void ip6_rt_put(struct rt6_info *rt)\n{\n\t \n\tBUILD_BUG_ON(offsetof(struct rt6_info, dst) != 0);\n\tdst_release(&rt->dst);\n}\n\nstruct fib6_info *fib6_info_alloc(gfp_t gfp_flags, bool with_fib6_nh);\nvoid fib6_info_destroy_rcu(struct rcu_head *head);\n\nstatic inline void fib6_info_hold(struct fib6_info *f6i)\n{\n\trefcount_inc(&f6i->fib6_ref);\n}\n\nstatic inline bool fib6_info_hold_safe(struct fib6_info *f6i)\n{\n\treturn refcount_inc_not_zero(&f6i->fib6_ref);\n}\n\nstatic inline void fib6_info_release(struct fib6_info *f6i)\n{\n\tif (f6i && refcount_dec_and_test(&f6i->fib6_ref))\n\t\tcall_rcu(&f6i->rcu, fib6_info_destroy_rcu);\n}\n\nenum fib6_walk_state {\n#ifdef CONFIG_IPV6_SUBTREES\n\tFWS_S,\n#endif\n\tFWS_L,\n\tFWS_R,\n\tFWS_C,\n\tFWS_U\n};\n\nstruct fib6_walker {\n\tstruct list_head lh;\n\tstruct fib6_node *root, *node;\n\tstruct fib6_info *leaf;\n\tenum fib6_walk_state state;\n\tunsigned int skip;\n\tunsigned int count;\n\tunsigned int skip_in_node;\n\tint (*func)(struct fib6_walker *);\n\tvoid *args;\n};\n\nstruct rt6_statistics {\n\t__u32\t\tfib_nodes;\t\t \n\t__u32\t\tfib_route_nodes;\t \n\t__u32\t\tfib_rt_entries;\t\t \n\t__u32\t\tfib_rt_cache;\t\t \n\t__u32\t\tfib_discarded_routes;\t \n\n\t \n\tatomic_t\tfib_rt_alloc;\t\t \n};\n\n#define RTN_TL_ROOT\t0x0001\n#define RTN_ROOT\t0x0002\t\t \n#define RTN_RTINFO\t0x0004\t\t \n\n \n\n\nstruct fib6_table {\n\tstruct hlist_node\ttb6_hlist;\n\tu32\t\t\ttb6_id;\n\tspinlock_t\t\ttb6_lock;\n\tstruct fib6_node\ttb6_root;\n\tstruct inet_peer_base\ttb6_peers;\n\tunsigned int\t\tflags;\n\tunsigned int\t\tfib_seq;\n#define RT6_TABLE_HAS_DFLT_ROUTER\tBIT(0)\n};\n\n#define RT6_TABLE_UNSPEC\tRT_TABLE_UNSPEC\n#define RT6_TABLE_MAIN\t\tRT_TABLE_MAIN\n#define RT6_TABLE_DFLT\t\tRT6_TABLE_MAIN\n#define RT6_TABLE_INFO\t\tRT6_TABLE_MAIN\n#define RT6_TABLE_PREFIX\tRT6_TABLE_MAIN\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n#define FIB6_TABLE_MIN\t\t1\n#define FIB6_TABLE_MAX\t\tRT_TABLE_MAX\n#define RT6_TABLE_LOCAL\t\tRT_TABLE_LOCAL\n#else\n#define FIB6_TABLE_MIN\t\tRT_TABLE_MAIN\n#define FIB6_TABLE_MAX\t\tFIB6_TABLE_MIN\n#define RT6_TABLE_LOCAL\t\tRT6_TABLE_MAIN\n#endif\n\ntypedef struct rt6_info *(*pol_lookup_t)(struct net *,\n\t\t\t\t\t struct fib6_table *,\n\t\t\t\t\t struct flowi6 *,\n\t\t\t\t\t const struct sk_buff *, int);\n\nstruct fib6_entry_notifier_info {\n\tstruct fib_notifier_info info;  \n\tstruct fib6_info *rt;\n\tunsigned int nsiblings;\n};\n\n \n\nstruct fib6_table *fib6_get_table(struct net *net, u32 id);\nstruct fib6_table *fib6_new_table(struct net *net, u32 id);\nstruct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup);\n\n \nint fib6_lookup(struct net *net, int oif, struct flowi6 *fl6,\n\t\tstruct fib6_result *res, int flags);\n\n \nint fib6_table_lookup(struct net *net, struct fib6_table *table,\n\t\t      int oif, struct flowi6 *fl6, struct fib6_result *res,\n\t\t      int strict);\n\nvoid fib6_select_path(const struct net *net, struct fib6_result *res,\n\t\t      struct flowi6 *fl6, int oif, bool have_oif_match,\n\t\t      const struct sk_buff *skb, int strict);\nstruct fib6_node *fib6_node_lookup(struct fib6_node *root,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   const struct in6_addr *saddr);\n\nstruct fib6_node *fib6_locate(struct fib6_node *root,\n\t\t\t      const struct in6_addr *daddr, int dst_len,\n\t\t\t      const struct in6_addr *saddr, int src_len,\n\t\t\t      bool exact_match);\n\nvoid fib6_clean_all(struct net *net, int (*func)(struct fib6_info *, void *arg),\n\t\t    void *arg);\nvoid fib6_clean_all_skip_notify(struct net *net,\n\t\t\t\tint (*func)(struct fib6_info *, void *arg),\n\t\t\t\tvoid *arg);\n\nint fib6_add(struct fib6_node *root, struct fib6_info *rt,\n\t     struct nl_info *info, struct netlink_ext_ack *extack);\nint fib6_del(struct fib6_info *rt, struct nl_info *info);\n\nstatic inline\nvoid rt6_get_prefsrc(const struct rt6_info *rt, struct in6_addr *addr)\n{\n\tconst struct fib6_info *from;\n\n\trcu_read_lock();\n\n\tfrom = rcu_dereference(rt->from);\n\tif (from)\n\t\t*addr = from->fib6_prefsrc.addr;\n\telse\n\t\t*addr = in6addr_any;\n\n\trcu_read_unlock();\n}\n\nint fib6_nh_init(struct net *net, struct fib6_nh *fib6_nh,\n\t\t struct fib6_config *cfg, gfp_t gfp_flags,\n\t\t struct netlink_ext_ack *extack);\nvoid fib6_nh_release(struct fib6_nh *fib6_nh);\nvoid fib6_nh_release_dsts(struct fib6_nh *fib6_nh);\n\nint call_fib6_entry_notifiers(struct net *net,\n\t\t\t      enum fib_event_type event_type,\n\t\t\t      struct fib6_info *rt,\n\t\t\t      struct netlink_ext_ack *extack);\nint call_fib6_multipath_entry_notifiers(struct net *net,\n\t\t\t\t\tenum fib_event_type event_type,\n\t\t\t\t\tstruct fib6_info *rt,\n\t\t\t\t\tunsigned int nsiblings,\n\t\t\t\t\tstruct netlink_ext_ack *extack);\nint call_fib6_entry_notifiers_replace(struct net *net, struct fib6_info *rt);\nvoid fib6_rt_update(struct net *net, struct fib6_info *rt,\n\t\t    struct nl_info *info);\nvoid inet6_rt_notify(int event, struct fib6_info *rt, struct nl_info *info,\n\t\t     unsigned int flags);\n\nvoid fib6_run_gc(unsigned long expires, struct net *net, bool force);\n\nvoid fib6_gc_cleanup(void);\n\nint fib6_init(void);\n\nstruct ipv6_route_iter {\n\tstruct seq_net_private p;\n\tstruct fib6_walker w;\n\tloff_t skip;\n\tstruct fib6_table *tbl;\n\tint sernum;\n};\n\nextern const struct seq_operations ipv6_route_seq_ops;\n\nint call_fib6_notifier(struct notifier_block *nb,\n\t\t       enum fib_event_type event_type,\n\t\t       struct fib_notifier_info *info);\nint call_fib6_notifiers(struct net *net, enum fib_event_type event_type,\n\t\t\tstruct fib_notifier_info *info);\n\nint __net_init fib6_notifier_init(struct net *net);\nvoid __net_exit fib6_notifier_exit(struct net *net);\n\nunsigned int fib6_tables_seq_read(struct net *net);\nint fib6_tables_dump(struct net *net, struct notifier_block *nb,\n\t\t     struct netlink_ext_ack *extack);\n\nvoid fib6_update_sernum(struct net *net, struct fib6_info *rt);\nvoid fib6_update_sernum_upto_root(struct net *net, struct fib6_info *rt);\nvoid fib6_update_sernum_stub(struct net *net, struct fib6_info *f6i);\n\nvoid fib6_metric_set(struct fib6_info *f6i, int metric, u32 val);\nstatic inline bool fib6_metric_locked(struct fib6_info *f6i, int metric)\n{\n\treturn !!(f6i->fib6_metrics->metrics[RTAX_LOCK - 1] & (1 << metric));\n}\nvoid fib6_info_hw_flags_set(struct net *net, struct fib6_info *f6i,\n\t\t\t    bool offload, bool trap, bool offload_failed);\n\n#if IS_BUILTIN(CONFIG_IPV6) && defined(CONFIG_BPF_SYSCALL)\nstruct bpf_iter__ipv6_route {\n\t__bpf_md_ptr(struct bpf_iter_meta *, meta);\n\t__bpf_md_ptr(struct fib6_info *, rt);\n};\n#endif\n\nINDIRECT_CALLABLE_DECLARE(struct rt6_info *ip6_pol_route_output(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags));\nINDIRECT_CALLABLE_DECLARE(struct rt6_info *ip6_pol_route_input(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags));\nINDIRECT_CALLABLE_DECLARE(struct rt6_info *__ip6_route_redirect(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags));\nINDIRECT_CALLABLE_DECLARE(struct rt6_info *ip6_pol_route_lookup(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags));\nstatic inline struct rt6_info *pol_lookup_func(pol_lookup_t lookup,\n\t\t\t\t\t\tstruct net *net,\n\t\t\t\t\t\tstruct fib6_table *table,\n\t\t\t\t\t\tstruct flowi6 *fl6,\n\t\t\t\t\t\tconst struct sk_buff *skb,\n\t\t\t\t\t\tint flags)\n{\n\treturn INDIRECT_CALL_4(lookup,\n\t\t\t       ip6_pol_route_output,\n\t\t\t       ip6_pol_route_input,\n\t\t\t       ip6_pol_route_lookup,\n\t\t\t       __ip6_route_redirect,\n\t\t\t       net, table, fl6, skb, flags);\n}\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\nstatic inline bool fib6_has_custom_rules(const struct net *net)\n{\n\treturn net->ipv6.fib6_has_custom_rules;\n}\n\nint fib6_rules_init(void);\nvoid fib6_rules_cleanup(void);\nbool fib6_rule_default(const struct fib_rule *rule);\nint fib6_rules_dump(struct net *net, struct notifier_block *nb,\n\t\t    struct netlink_ext_ack *extack);\nunsigned int fib6_rules_seq_read(struct net *net);\n\nstatic inline bool fib6_rules_early_flow_dissect(struct net *net,\n\t\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t\t struct flowi6 *fl6,\n\t\t\t\t\t\t struct flow_keys *flkeys)\n{\n\tunsigned int flag = FLOW_DISSECTOR_F_STOP_AT_ENCAP;\n\n\tif (!net->ipv6.fib6_rules_require_fldissect)\n\t\treturn false;\n\n\tmemset(flkeys, 0, sizeof(*flkeys));\n\t__skb_flow_dissect(net, skb, &flow_keys_dissector,\n\t\t\t   flkeys, NULL, 0, 0, 0, flag);\n\n\tfl6->fl6_sport = flkeys->ports.src;\n\tfl6->fl6_dport = flkeys->ports.dst;\n\tfl6->flowi6_proto = flkeys->basic.ip_proto;\n\n\treturn true;\n}\n#else\nstatic inline bool fib6_has_custom_rules(const struct net *net)\n{\n\treturn false;\n}\nstatic inline int               fib6_rules_init(void)\n{\n\treturn 0;\n}\nstatic inline void              fib6_rules_cleanup(void)\n{\n\treturn ;\n}\nstatic inline bool fib6_rule_default(const struct fib_rule *rule)\n{\n\treturn true;\n}\nstatic inline int fib6_rules_dump(struct net *net, struct notifier_block *nb,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\nstatic inline unsigned int fib6_rules_seq_read(struct net *net)\n{\n\treturn 0;\n}\nstatic inline bool fib6_rules_early_flow_dissect(struct net *net,\n\t\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t\t struct flowi6 *fl6,\n\t\t\t\t\t\t struct flow_keys *flkeys)\n{\n\treturn false;\n}\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}