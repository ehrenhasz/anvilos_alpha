{
  "module_name": "af_unix.h",
  "hash_id": "26d7dab22c4b4ecd9047dbe4fe6f91ce04f5fd50b4cad8479d3c93c2eb725c8d",
  "original_prompt": "Ingested from linux-6.6.14/include/net/af_unix.h",
  "human_readable_source": " \n#ifndef __LINUX_NET_AFUNIX_H\n#define __LINUX_NET_AFUNIX_H\n\n#include <linux/socket.h>\n#include <linux/un.h>\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <net/sock.h>\n\nvoid unix_inflight(struct user_struct *user, struct file *fp);\nvoid unix_notinflight(struct user_struct *user, struct file *fp);\nvoid unix_destruct_scm(struct sk_buff *skb);\nvoid io_uring_destruct_scm(struct sk_buff *skb);\nvoid unix_gc(void);\nvoid wait_for_unix_gc(void);\nstruct sock *unix_get_socket(struct file *filp);\nstruct sock *unix_peer_get(struct sock *sk);\n\n#define UNIX_HASH_MOD\t(256 - 1)\n#define UNIX_HASH_SIZE\t(256 * 2)\n#define UNIX_HASH_BITS\t8\n\nextern unsigned int unix_tot_inflight;\n\nstruct unix_address {\n\trefcount_t\trefcnt;\n\tint\t\tlen;\n\tstruct sockaddr_un name[];\n};\n\nstruct unix_skb_parms {\n\tstruct pid\t\t*pid;\t\t \n\tkuid_t\t\t\tuid;\n\tkgid_t\t\t\tgid;\n\tstruct scm_fp_list\t*fp;\t\t \n#ifdef CONFIG_SECURITY_NETWORK\n\tu32\t\t\tsecid;\t\t \n#endif\n\tu32\t\t\tconsumed;\n} __randomize_layout;\n\nstruct scm_stat {\n\tatomic_t nr_fds;\n};\n\n#define UNIXCB(skb)\t(*(struct unix_skb_parms *)&((skb)->cb))\n\n#define unix_state_lock(s)\tspin_lock(&unix_sk(s)->lock)\n#define unix_state_unlock(s)\tspin_unlock(&unix_sk(s)->lock)\n#define unix_state_lock_nested(s) \\\n\t\t\t\tspin_lock_nested(&unix_sk(s)->lock, \\\n\t\t\t\tSINGLE_DEPTH_NESTING)\n\n \nstruct unix_sock {\n\t \n\tstruct sock\t\tsk;\n\tstruct unix_address\t*addr;\n\tstruct path\t\tpath;\n\tstruct mutex\t\tiolock, bindlock;\n\tstruct sock\t\t*peer;\n\tstruct list_head\tlink;\n\tatomic_long_t\t\tinflight;\n\tspinlock_t\t\tlock;\n\tunsigned long\t\tgc_flags;\n#define UNIX_GC_CANDIDATE\t0\n#define UNIX_GC_MAYBE_CYCLE\t1\n\tstruct socket_wq\tpeer_wq;\n\twait_queue_entry_t\tpeer_wake;\n\tstruct scm_stat\t\tscm_stat;\n#if IS_ENABLED(CONFIG_AF_UNIX_OOB)\n\tstruct sk_buff\t\t*oob_skb;\n#endif\n};\n\n#define unix_sk(ptr) container_of_const(ptr, struct unix_sock, sk)\n#define unix_peer(sk) (unix_sk(sk)->peer)\n\n#define peer_wait peer_wq.wait\n\nlong unix_inq_len(struct sock *sk);\nlong unix_outq_len(struct sock *sk);\n\nint __unix_dgram_recvmsg(struct sock *sk, struct msghdr *msg, size_t size,\n\t\t\t int flags);\nint __unix_stream_recvmsg(struct sock *sk, struct msghdr *msg, size_t size,\n\t\t\t  int flags);\n#ifdef CONFIG_SYSCTL\nint unix_sysctl_register(struct net *net);\nvoid unix_sysctl_unregister(struct net *net);\n#else\nstatic inline int unix_sysctl_register(struct net *net) { return 0; }\nstatic inline void unix_sysctl_unregister(struct net *net) {}\n#endif\n\n#ifdef CONFIG_BPF_SYSCALL\nextern struct proto unix_dgram_proto;\nextern struct proto unix_stream_proto;\n\nint unix_dgram_bpf_update_proto(struct sock *sk, struct sk_psock *psock, bool restore);\nint unix_stream_bpf_update_proto(struct sock *sk, struct sk_psock *psock, bool restore);\nvoid __init unix_bpf_build_proto(void);\n#else\nstatic inline void __init unix_bpf_build_proto(void)\n{}\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}