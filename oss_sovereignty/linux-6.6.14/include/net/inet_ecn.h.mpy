{
  "module_name": "inet_ecn.h",
  "hash_id": "8cf0ab55af7694781e173d984619e14a56e72251b94095d4679eed5d32425b76",
  "original_prompt": "Ingested from linux-6.6.14/include/net/inet_ecn.h",
  "human_readable_source": " \n#ifndef _INET_ECN_H_\n#define _INET_ECN_H_\n\n#include <linux/ip.h>\n#include <linux/skbuff.h>\n#include <linux/if_vlan.h>\n\n#include <net/inet_sock.h>\n#include <net/dsfield.h>\n#include <net/checksum.h>\n\nenum {\n\tINET_ECN_NOT_ECT = 0,\n\tINET_ECN_ECT_1 = 1,\n\tINET_ECN_ECT_0 = 2,\n\tINET_ECN_CE = 3,\n\tINET_ECN_MASK = 3,\n};\n\nextern int sysctl_tunnel_ecn_log;\n\nstatic inline int INET_ECN_is_ce(__u8 dsfield)\n{\n\treturn (dsfield & INET_ECN_MASK) == INET_ECN_CE;\n}\n\nstatic inline int INET_ECN_is_not_ect(__u8 dsfield)\n{\n\treturn (dsfield & INET_ECN_MASK) == INET_ECN_NOT_ECT;\n}\n\nstatic inline int INET_ECN_is_capable(__u8 dsfield)\n{\n\treturn dsfield & INET_ECN_ECT_0;\n}\n\n \nstatic inline __u8 INET_ECN_encapsulate(__u8 outer, __u8 inner)\n{\n\touter &= ~INET_ECN_MASK;\n\touter |= !INET_ECN_is_ce(inner) ? (inner & INET_ECN_MASK) :\n\t\t\t\t\t  INET_ECN_ECT_0;\n\treturn outer;\n}\n\nstatic inline void INET_ECN_xmit(struct sock *sk)\n{\n\tinet_sk(sk)->tos |= INET_ECN_ECT_0;\n\tif (inet6_sk(sk) != NULL)\n\t\tinet6_sk(sk)->tclass |= INET_ECN_ECT_0;\n}\n\nstatic inline void INET_ECN_dontxmit(struct sock *sk)\n{\n\tinet_sk(sk)->tos &= ~INET_ECN_MASK;\n\tif (inet6_sk(sk) != NULL)\n\t\tinet6_sk(sk)->tclass &= ~INET_ECN_MASK;\n}\n\n#define IP6_ECN_flow_init(label) do {\t\t\\\n      (label) &= ~htonl(INET_ECN_MASK << 20);\t\\\n    } while (0)\n\n#define\tIP6_ECN_flow_xmit(sk, label) do {\t\t\t\t\\\n\tif (INET_ECN_is_capable(inet6_sk(sk)->tclass))\t\t\t\\\n\t\t(label) |= htonl(INET_ECN_ECT_0 << 20);\t\t\t\\\n    } while (0)\n\nstatic inline int IP_ECN_set_ce(struct iphdr *iph)\n{\n\tu32 ecn = (iph->tos + 1) & INET_ECN_MASK;\n\t__be16 check_add;\n\n\t \n\tif (!(ecn & 2))\n\t\treturn !ecn;\n\n\t \n\tcheck_add = (__force __be16)((__force u16)htons(0xFFFB) +\n\t\t\t\t     (__force u16)htons(ecn));\n\n\tiph->check = csum16_add(iph->check, check_add);\n\tiph->tos |= INET_ECN_CE;\n\treturn 1;\n}\n\nstatic inline int IP_ECN_set_ect1(struct iphdr *iph)\n{\n\tif ((iph->tos & INET_ECN_MASK) != INET_ECN_ECT_0)\n\t\treturn 0;\n\n\tiph->check = csum16_add(iph->check, htons(0x1));\n\tiph->tos ^= INET_ECN_MASK;\n\treturn 1;\n}\n\nstatic inline void IP_ECN_clear(struct iphdr *iph)\n{\n\tiph->tos &= ~INET_ECN_MASK;\n}\n\nstatic inline void ipv4_copy_dscp(unsigned int dscp, struct iphdr *inner)\n{\n\tdscp &= ~INET_ECN_MASK;\n\tipv4_change_dsfield(inner, INET_ECN_MASK, dscp);\n}\n\nstruct ipv6hdr;\n\n \nstatic inline int IP6_ECN_set_ce(struct sk_buff *skb, struct ipv6hdr *iph)\n{\n\t__be32 from, to;\n\n\tif (INET_ECN_is_not_ect(ipv6_get_dsfield(iph)))\n\t\treturn 0;\n\n\tfrom = *(__be32 *)iph;\n\tto = from | htonl(INET_ECN_CE << 20);\n\t*(__be32 *)iph = to;\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tskb->csum = csum_add(csum_sub(skb->csum, (__force __wsum)from),\n\t\t\t\t     (__force __wsum)to);\n\treturn 1;\n}\n\nstatic inline int IP6_ECN_set_ect1(struct sk_buff *skb, struct ipv6hdr *iph)\n{\n\t__be32 from, to;\n\n\tif ((ipv6_get_dsfield(iph) & INET_ECN_MASK) != INET_ECN_ECT_0)\n\t\treturn 0;\n\n\tfrom = *(__be32 *)iph;\n\tto = from ^ htonl(INET_ECN_MASK << 20);\n\t*(__be32 *)iph = to;\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tskb->csum = csum_add(csum_sub(skb->csum, (__force __wsum)from),\n\t\t\t\t     (__force __wsum)to);\n\treturn 1;\n}\n\nstatic inline void ipv6_copy_dscp(unsigned int dscp, struct ipv6hdr *inner)\n{\n\tdscp &= ~INET_ECN_MASK;\n\tipv6_change_dsfield(inner, INET_ECN_MASK, dscp);\n}\n\nstatic inline int INET_ECN_set_ce(struct sk_buff *skb)\n{\n\tswitch (skb_protocol(skb, true)) {\n\tcase cpu_to_be16(ETH_P_IP):\n\t\tif (skb_network_header(skb) + sizeof(struct iphdr) <=\n\t\t    skb_tail_pointer(skb))\n\t\t\treturn IP_ECN_set_ce(ip_hdr(skb));\n\t\tbreak;\n\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\tif (skb_network_header(skb) + sizeof(struct ipv6hdr) <=\n\t\t    skb_tail_pointer(skb))\n\t\t\treturn IP6_ECN_set_ce(skb, ipv6_hdr(skb));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int skb_get_dsfield(struct sk_buff *skb)\n{\n\tswitch (skb_protocol(skb, true)) {\n\tcase cpu_to_be16(ETH_P_IP):\n\t\tif (!pskb_network_may_pull(skb, sizeof(struct iphdr)))\n\t\t\tbreak;\n\t\treturn ipv4_get_dsfield(ip_hdr(skb));\n\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\tif (!pskb_network_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\t\tbreak;\n\t\treturn ipv6_get_dsfield(ipv6_hdr(skb));\n\t}\n\n\treturn -1;\n}\n\nstatic inline int INET_ECN_set_ect1(struct sk_buff *skb)\n{\n\tswitch (skb_protocol(skb, true)) {\n\tcase cpu_to_be16(ETH_P_IP):\n\t\tif (skb_network_header(skb) + sizeof(struct iphdr) <=\n\t\t    skb_tail_pointer(skb))\n\t\t\treturn IP_ECN_set_ect1(ip_hdr(skb));\n\t\tbreak;\n\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\tif (skb_network_header(skb) + sizeof(struct ipv6hdr) <=\n\t\t    skb_tail_pointer(skb))\n\t\t\treturn IP6_ECN_set_ect1(skb, ipv6_hdr(skb));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int __INET_ECN_decapsulate(__u8 outer, __u8 inner, bool *set_ce)\n{\n\tif (INET_ECN_is_not_ect(inner)) {\n\t\tswitch (outer & INET_ECN_MASK) {\n\t\tcase INET_ECN_NOT_ECT:\n\t\t\treturn 0;\n\t\tcase INET_ECN_ECT_0:\n\t\tcase INET_ECN_ECT_1:\n\t\t\treturn 1;\n\t\tcase INET_ECN_CE:\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t*set_ce = INET_ECN_is_ce(outer);\n\treturn 0;\n}\n\nstatic inline int INET_ECN_decapsulate(struct sk_buff *skb,\n\t\t\t\t       __u8 outer, __u8 inner)\n{\n\tbool set_ce = false;\n\tint rc;\n\n\trc = __INET_ECN_decapsulate(outer, inner, &set_ce);\n\tif (!rc) {\n\t\tif (set_ce)\n\t\t\tINET_ECN_set_ce(skb);\n\t\telse if ((outer & INET_ECN_MASK) == INET_ECN_ECT_1)\n\t\t\tINET_ECN_set_ect1(skb);\n\t}\n\n\treturn rc;\n}\n\nstatic inline int IP_ECN_decapsulate(const struct iphdr *oiph,\n\t\t\t\t     struct sk_buff *skb)\n{\n\t__u8 inner;\n\n\tswitch (skb_protocol(skb, true)) {\n\tcase htons(ETH_P_IP):\n\t\tinner = ip_hdr(skb)->tos;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tinner = ipv6_get_dsfield(ipv6_hdr(skb));\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn INET_ECN_decapsulate(skb, oiph->tos, inner);\n}\n\nstatic inline int IP6_ECN_decapsulate(const struct ipv6hdr *oipv6h,\n\t\t\t\t      struct sk_buff *skb)\n{\n\t__u8 inner;\n\n\tswitch (skb_protocol(skb, true)) {\n\tcase htons(ETH_P_IP):\n\t\tinner = ip_hdr(skb)->tos;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tinner = ipv6_get_dsfield(ipv6_hdr(skb));\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn INET_ECN_decapsulate(skb, ipv6_get_dsfield(oipv6h), inner);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}