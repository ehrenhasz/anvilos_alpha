{
  "module_name": "flow_offload.h",
  "hash_id": "ed24b05fba89f967c4562ba153c708556baf5ece8d0c477b40fc48df741ed21f",
  "original_prompt": "Ingested from linux-6.6.14/include/net/flow_offload.h",
  "human_readable_source": "#ifndef _NET_FLOW_OFFLOAD_H\n#define _NET_FLOW_OFFLOAD_H\n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/netlink.h>\n#include <net/flow_dissector.h>\n\nstruct flow_match {\n\tstruct flow_dissector\t*dissector;\n\tvoid\t\t\t*mask;\n\tvoid\t\t\t*key;\n};\n\nstruct flow_match_meta {\n\tstruct flow_dissector_key_meta *key, *mask;\n};\n\nstruct flow_match_basic {\n\tstruct flow_dissector_key_basic *key, *mask;\n};\n\nstruct flow_match_control {\n\tstruct flow_dissector_key_control *key, *mask;\n};\n\nstruct flow_match_eth_addrs {\n\tstruct flow_dissector_key_eth_addrs *key, *mask;\n};\n\nstruct flow_match_vlan {\n\tstruct flow_dissector_key_vlan *key, *mask;\n};\n\nstruct flow_match_arp {\n\tstruct flow_dissector_key_arp *key, *mask;\n};\n\nstruct flow_match_ipv4_addrs {\n\tstruct flow_dissector_key_ipv4_addrs *key, *mask;\n};\n\nstruct flow_match_ipv6_addrs {\n\tstruct flow_dissector_key_ipv6_addrs *key, *mask;\n};\n\nstruct flow_match_ip {\n\tstruct flow_dissector_key_ip *key, *mask;\n};\n\nstruct flow_match_ports {\n\tstruct flow_dissector_key_ports *key, *mask;\n};\n\nstruct flow_match_ports_range {\n\tstruct flow_dissector_key_ports_range *key, *mask;\n};\n\nstruct flow_match_icmp {\n\tstruct flow_dissector_key_icmp *key, *mask;\n};\n\nstruct flow_match_tcp {\n\tstruct flow_dissector_key_tcp *key, *mask;\n};\n\nstruct flow_match_ipsec {\n\tstruct flow_dissector_key_ipsec *key, *mask;\n};\n\nstruct flow_match_mpls {\n\tstruct flow_dissector_key_mpls *key, *mask;\n};\n\nstruct flow_match_enc_keyid {\n\tstruct flow_dissector_key_keyid *key, *mask;\n};\n\nstruct flow_match_enc_opts {\n\tstruct flow_dissector_key_enc_opts *key, *mask;\n};\n\nstruct flow_match_ct {\n\tstruct flow_dissector_key_ct *key, *mask;\n};\n\nstruct flow_match_pppoe {\n\tstruct flow_dissector_key_pppoe *key, *mask;\n};\n\nstruct flow_match_l2tpv3 {\n\tstruct flow_dissector_key_l2tpv3 *key, *mask;\n};\n\nstruct flow_rule;\n\nvoid flow_rule_match_meta(const struct flow_rule *rule,\n\t\t\t  struct flow_match_meta *out);\nvoid flow_rule_match_basic(const struct flow_rule *rule,\n\t\t\t   struct flow_match_basic *out);\nvoid flow_rule_match_control(const struct flow_rule *rule,\n\t\t\t     struct flow_match_control *out);\nvoid flow_rule_match_eth_addrs(const struct flow_rule *rule,\n\t\t\t       struct flow_match_eth_addrs *out);\nvoid flow_rule_match_vlan(const struct flow_rule *rule,\n\t\t\t  struct flow_match_vlan *out);\nvoid flow_rule_match_cvlan(const struct flow_rule *rule,\n\t\t\t   struct flow_match_vlan *out);\nvoid flow_rule_match_arp(const struct flow_rule *rule,\n\t\t\t struct flow_match_arp *out);\nvoid flow_rule_match_ipv4_addrs(const struct flow_rule *rule,\n\t\t\t\tstruct flow_match_ipv4_addrs *out);\nvoid flow_rule_match_ipv6_addrs(const struct flow_rule *rule,\n\t\t\t\tstruct flow_match_ipv6_addrs *out);\nvoid flow_rule_match_ip(const struct flow_rule *rule,\n\t\t\tstruct flow_match_ip *out);\nvoid flow_rule_match_ports(const struct flow_rule *rule,\n\t\t\t   struct flow_match_ports *out);\nvoid flow_rule_match_ports_range(const struct flow_rule *rule,\n\t\t\t\t struct flow_match_ports_range *out);\nvoid flow_rule_match_tcp(const struct flow_rule *rule,\n\t\t\t struct flow_match_tcp *out);\nvoid flow_rule_match_ipsec(const struct flow_rule *rule,\n\t\t\t   struct flow_match_ipsec *out);\nvoid flow_rule_match_icmp(const struct flow_rule *rule,\n\t\t\t  struct flow_match_icmp *out);\nvoid flow_rule_match_mpls(const struct flow_rule *rule,\n\t\t\t  struct flow_match_mpls *out);\nvoid flow_rule_match_enc_control(const struct flow_rule *rule,\n\t\t\t\t struct flow_match_control *out);\nvoid flow_rule_match_enc_ipv4_addrs(const struct flow_rule *rule,\n\t\t\t\t    struct flow_match_ipv4_addrs *out);\nvoid flow_rule_match_enc_ipv6_addrs(const struct flow_rule *rule,\n\t\t\t\t    struct flow_match_ipv6_addrs *out);\nvoid flow_rule_match_enc_ip(const struct flow_rule *rule,\n\t\t\t    struct flow_match_ip *out);\nvoid flow_rule_match_enc_ports(const struct flow_rule *rule,\n\t\t\t       struct flow_match_ports *out);\nvoid flow_rule_match_enc_keyid(const struct flow_rule *rule,\n\t\t\t       struct flow_match_enc_keyid *out);\nvoid flow_rule_match_enc_opts(const struct flow_rule *rule,\n\t\t\t      struct flow_match_enc_opts *out);\nvoid flow_rule_match_ct(const struct flow_rule *rule,\n\t\t\tstruct flow_match_ct *out);\nvoid flow_rule_match_pppoe(const struct flow_rule *rule,\n\t\t\t   struct flow_match_pppoe *out);\nvoid flow_rule_match_l2tpv3(const struct flow_rule *rule,\n\t\t\t    struct flow_match_l2tpv3 *out);\n\nenum flow_action_id {\n\tFLOW_ACTION_ACCEPT\t\t= 0,\n\tFLOW_ACTION_DROP,\n\tFLOW_ACTION_TRAP,\n\tFLOW_ACTION_GOTO,\n\tFLOW_ACTION_REDIRECT,\n\tFLOW_ACTION_MIRRED,\n\tFLOW_ACTION_REDIRECT_INGRESS,\n\tFLOW_ACTION_MIRRED_INGRESS,\n\tFLOW_ACTION_VLAN_PUSH,\n\tFLOW_ACTION_VLAN_POP,\n\tFLOW_ACTION_VLAN_MANGLE,\n\tFLOW_ACTION_TUNNEL_ENCAP,\n\tFLOW_ACTION_TUNNEL_DECAP,\n\tFLOW_ACTION_MANGLE,\n\tFLOW_ACTION_ADD,\n\tFLOW_ACTION_CSUM,\n\tFLOW_ACTION_MARK,\n\tFLOW_ACTION_PTYPE,\n\tFLOW_ACTION_PRIORITY,\n\tFLOW_ACTION_RX_QUEUE_MAPPING,\n\tFLOW_ACTION_WAKE,\n\tFLOW_ACTION_QUEUE,\n\tFLOW_ACTION_SAMPLE,\n\tFLOW_ACTION_POLICE,\n\tFLOW_ACTION_CT,\n\tFLOW_ACTION_CT_METADATA,\n\tFLOW_ACTION_MPLS_PUSH,\n\tFLOW_ACTION_MPLS_POP,\n\tFLOW_ACTION_MPLS_MANGLE,\n\tFLOW_ACTION_GATE,\n\tFLOW_ACTION_PPPOE_PUSH,\n\tFLOW_ACTION_JUMP,\n\tFLOW_ACTION_PIPE,\n\tFLOW_ACTION_VLAN_PUSH_ETH,\n\tFLOW_ACTION_VLAN_POP_ETH,\n\tFLOW_ACTION_CONTINUE,\n\tNUM_FLOW_ACTIONS,\n};\n\n \nenum flow_action_mangle_base {\n\tFLOW_ACT_MANGLE_UNSPEC\t\t= 0,\n\tFLOW_ACT_MANGLE_HDR_TYPE_ETH,\n\tFLOW_ACT_MANGLE_HDR_TYPE_IP4,\n\tFLOW_ACT_MANGLE_HDR_TYPE_IP6,\n\tFLOW_ACT_MANGLE_HDR_TYPE_TCP,\n\tFLOW_ACT_MANGLE_HDR_TYPE_UDP,\n};\n\nenum flow_action_hw_stats_bit {\n\tFLOW_ACTION_HW_STATS_IMMEDIATE_BIT,\n\tFLOW_ACTION_HW_STATS_DELAYED_BIT,\n\tFLOW_ACTION_HW_STATS_DISABLED_BIT,\n\n\tFLOW_ACTION_HW_STATS_NUM_BITS\n};\n\nenum flow_action_hw_stats {\n\tFLOW_ACTION_HW_STATS_IMMEDIATE =\n\t\tBIT(FLOW_ACTION_HW_STATS_IMMEDIATE_BIT),\n\tFLOW_ACTION_HW_STATS_DELAYED = BIT(FLOW_ACTION_HW_STATS_DELAYED_BIT),\n\tFLOW_ACTION_HW_STATS_ANY = FLOW_ACTION_HW_STATS_IMMEDIATE |\n\t\t\t\t   FLOW_ACTION_HW_STATS_DELAYED,\n\tFLOW_ACTION_HW_STATS_DISABLED =\n\t\tBIT(FLOW_ACTION_HW_STATS_DISABLED_BIT),\n\tFLOW_ACTION_HW_STATS_DONT_CARE = BIT(FLOW_ACTION_HW_STATS_NUM_BITS) - 1,\n};\n\ntypedef void (*action_destr)(void *priv);\n\nstruct flow_action_cookie {\n\tu32 cookie_len;\n\tu8 cookie[];\n};\n\nstruct flow_action_cookie *flow_action_cookie_create(void *data,\n\t\t\t\t\t\t     unsigned int len,\n\t\t\t\t\t\t     gfp_t gfp);\nvoid flow_action_cookie_destroy(struct flow_action_cookie *cookie);\n\nstruct flow_action_entry {\n\tenum flow_action_id\t\tid;\n\tu32\t\t\t\thw_index;\n\tunsigned long\t\t\tcookie;\n\tu64\t\t\t\tmiss_cookie;\n\tenum flow_action_hw_stats\thw_stats;\n\taction_destr\t\t\tdestructor;\n\tvoid\t\t\t\t*destructor_priv;\n\tunion {\n\t\tu32\t\t\tchain_index;\t \n\t\tstruct net_device\t*dev;\t\t \n\t\tstruct {\t\t\t\t \n\t\t\tu16\t\tvid;\n\t\t\t__be16\t\tproto;\n\t\t\tu8\t\tprio;\n\t\t} vlan;\n\t\tstruct {\t\t\t\t \n\t\t\tunsigned char dst[ETH_ALEN];\n\t\t\tunsigned char src[ETH_ALEN];\n\t\t} vlan_push_eth;\n\t\tstruct {\t\t\t\t \n\t\t\t\t\t\t\t \n\t\t\tenum flow_action_mangle_base htype;\n\t\t\tu32\t\toffset;\n\t\t\tu32\t\tmask;\n\t\t\tu32\t\tval;\n\t\t} mangle;\n\t\tstruct ip_tunnel_info\t*tunnel;\t \n\t\tu32\t\t\tcsum_flags;\t \n\t\tu32\t\t\tmark;\t\t \n\t\tu16                     ptype;           \n\t\tu16\t\t\trx_queue;\t \n\t\tu32\t\t\tpriority;\t \n\t\tstruct {\t\t\t\t \n\t\t\tu32\t\tctx;\n\t\t\tu32\t\tindex;\n\t\t\tu8\t\tvf;\n\t\t} queue;\n\t\tstruct {\t\t\t\t \n\t\t\tstruct psample_group\t*psample_group;\n\t\t\tu32\t\t\trate;\n\t\t\tu32\t\t\ttrunc_size;\n\t\t\tbool\t\t\ttruncate;\n\t\t} sample;\n\t\tstruct {\t\t\t\t \n\t\t\tu32\t\t\tburst;\n\t\t\tu64\t\t\trate_bytes_ps;\n\t\t\tu64\t\t\tpeakrate_bytes_ps;\n\t\t\tu32\t\t\tavrate;\n\t\t\tu16\t\t\toverhead;\n\t\t\tu64\t\t\tburst_pkt;\n\t\t\tu64\t\t\trate_pkt_ps;\n\t\t\tu32\t\t\tmtu;\n\t\t\tstruct {\n\t\t\t\tenum flow_action_id\tact_id;\n\t\t\t\tu32\t\t\textval;\n\t\t\t} exceed, notexceed;\n\t\t} police;\n\t\tstruct {\t\t\t\t \n\t\t\tint action;\n\t\t\tu16 zone;\n\t\t\tstruct nf_flowtable *flow_table;\n\t\t} ct;\n\t\tstruct {\n\t\t\tunsigned long cookie;\n\t\t\tu32 mark;\n\t\t\tu32 labels[4];\n\t\t\tbool orig_dir;\n\t\t} ct_metadata;\n\t\tstruct {\t\t\t\t \n\t\t\tu32\t\tlabel;\n\t\t\t__be16\t\tproto;\n\t\t\tu8\t\ttc;\n\t\t\tu8\t\tbos;\n\t\t\tu8\t\tttl;\n\t\t} mpls_push;\n\t\tstruct {\t\t\t\t \n\t\t\t__be16\t\tproto;\n\t\t} mpls_pop;\n\t\tstruct {\t\t\t\t \n\t\t\tu32\t\tlabel;\n\t\t\tu8\t\ttc;\n\t\t\tu8\t\tbos;\n\t\t\tu8\t\tttl;\n\t\t} mpls_mangle;\n\t\tstruct {\n\t\t\ts32\t\tprio;\n\t\t\tu64\t\tbasetime;\n\t\t\tu64\t\tcycletime;\n\t\t\tu64\t\tcycletimeext;\n\t\t\tu32\t\tnum_entries;\n\t\t\tstruct action_gate_entry *entries;\n\t\t} gate;\n\t\tstruct {\t\t\t\t \n\t\t\tu16\t\tsid;\n\t\t} pppoe;\n\t};\n\tstruct flow_action_cookie *user_cookie;  \n};\n\nstruct flow_action {\n\tunsigned int\t\t\tnum_entries;\n\tstruct flow_action_entry\tentries[];\n};\n\nstatic inline bool flow_action_has_entries(const struct flow_action *action)\n{\n\treturn action->num_entries;\n}\n\n \nstatic inline bool flow_offload_has_one_action(const struct flow_action *action)\n{\n\treturn action->num_entries == 1;\n}\n\nstatic inline bool flow_action_is_last_entry(const struct flow_action *action,\n\t\t\t\t\t     const struct flow_action_entry *entry)\n{\n\treturn entry == &action->entries[action->num_entries - 1];\n}\n\n#define flow_action_for_each(__i, __act, __actions)\t\t\t\\\n        for (__i = 0, __act = &(__actions)->entries[0];\t\t\t\\\n\t     __i < (__actions)->num_entries;\t\t\t\t\\\n\t     __act = &(__actions)->entries[++__i])\n\nstatic inline bool\nflow_action_mixed_hw_stats_check(const struct flow_action *action,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tconst struct flow_action_entry *action_entry;\n\tu8 last_hw_stats;\n\tint i;\n\n\tif (flow_offload_has_one_action(action))\n\t\treturn true;\n\n\tflow_action_for_each(i, action_entry, action) {\n\t\tif (i && action_entry->hw_stats != last_hw_stats) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Mixing HW stats types for actions is not supported\");\n\t\t\treturn false;\n\t\t}\n\t\tlast_hw_stats = action_entry->hw_stats;\n\t}\n\treturn true;\n}\n\nstatic inline const struct flow_action_entry *\nflow_action_first_entry_get(const struct flow_action *action)\n{\n\tWARN_ON(!flow_action_has_entries(action));\n\treturn &action->entries[0];\n}\n\nstatic inline bool\n__flow_action_hw_stats_check(const struct flow_action *action,\n\t\t\t     struct netlink_ext_ack *extack,\n\t\t\t     bool check_allow_bit,\n\t\t\t     enum flow_action_hw_stats_bit allow_bit)\n{\n\tconst struct flow_action_entry *action_entry;\n\n\tif (!flow_action_has_entries(action))\n\t\treturn true;\n\tif (!flow_action_mixed_hw_stats_check(action, extack))\n\t\treturn false;\n\n\taction_entry = flow_action_first_entry_get(action);\n\n\t \n\tWARN_ON_ONCE(!action_entry->hw_stats);\n\n\tif (!check_allow_bit &&\n\t    ~action_entry->hw_stats & FLOW_ACTION_HW_STATS_ANY) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Driver supports only default HW stats type \\\"any\\\"\");\n\t\treturn false;\n\t} else if (check_allow_bit &&\n\t\t   !(action_entry->hw_stats & BIT(allow_bit))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Driver does not support selected HW stats type\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic inline bool\nflow_action_hw_stats_check(const struct flow_action *action,\n\t\t\t   struct netlink_ext_ack *extack,\n\t\t\t   enum flow_action_hw_stats_bit allow_bit)\n{\n\treturn __flow_action_hw_stats_check(action, extack, true, allow_bit);\n}\n\nstatic inline bool\nflow_action_basic_hw_stats_check(const struct flow_action *action,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn __flow_action_hw_stats_check(action, extack, false, 0);\n}\n\nstruct flow_rule {\n\tstruct flow_match\tmatch;\n\tstruct flow_action\taction;\n};\n\nstruct flow_rule *flow_rule_alloc(unsigned int num_actions);\n\nstatic inline bool flow_rule_match_key(const struct flow_rule *rule,\n\t\t\t\t       enum flow_dissector_key_id key)\n{\n\treturn dissector_uses_key(rule->match.dissector, key);\n}\n\nstruct flow_stats {\n\tu64\tpkts;\n\tu64\tbytes;\n\tu64\tdrops;\n\tu64\tlastused;\n\tenum flow_action_hw_stats used_hw_stats;\n\tbool used_hw_stats_valid;\n};\n\nstatic inline void flow_stats_update(struct flow_stats *flow_stats,\n\t\t\t\t     u64 bytes, u64 pkts,\n\t\t\t\t     u64 drops, u64 lastused,\n\t\t\t\t     enum flow_action_hw_stats used_hw_stats)\n{\n\tflow_stats->pkts\t+= pkts;\n\tflow_stats->bytes\t+= bytes;\n\tflow_stats->drops\t+= drops;\n\tflow_stats->lastused\t= max_t(u64, flow_stats->lastused, lastused);\n\n\t \n\tWARN_ON(used_hw_stats == FLOW_ACTION_HW_STATS_ANY);\n\tflow_stats->used_hw_stats |= used_hw_stats;\n\tflow_stats->used_hw_stats_valid = true;\n}\n\nenum flow_block_command {\n\tFLOW_BLOCK_BIND,\n\tFLOW_BLOCK_UNBIND,\n};\n\nenum flow_block_binder_type {\n\tFLOW_BLOCK_BINDER_TYPE_UNSPEC,\n\tFLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS,\n\tFLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS,\n\tFLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP,\n\tFLOW_BLOCK_BINDER_TYPE_RED_MARK,\n};\n\nstruct flow_block {\n\tstruct list_head cb_list;\n};\n\nstruct netlink_ext_ack;\n\nstruct flow_block_offload {\n\tenum flow_block_command command;\n\tenum flow_block_binder_type binder_type;\n\tbool block_shared;\n\tbool unlocked_driver_cb;\n\tstruct net *net;\n\tstruct flow_block *block;\n\tstruct list_head cb_list;\n\tstruct list_head *driver_block_list;\n\tstruct netlink_ext_ack *extack;\n\tstruct Qdisc *sch;\n\tstruct list_head *cb_list_head;\n};\n\nenum tc_setup_type;\ntypedef int flow_setup_cb_t(enum tc_setup_type type, void *type_data,\n\t\t\t    void *cb_priv);\n\nstruct flow_block_cb;\n\nstruct flow_block_indr {\n\tstruct list_head\t\tlist;\n\tstruct net_device\t\t*dev;\n\tstruct Qdisc\t\t\t*sch;\n\tenum flow_block_binder_type\tbinder_type;\n\tvoid\t\t\t\t*data;\n\tvoid\t\t\t\t*cb_priv;\n\tvoid\t\t\t\t(*cleanup)(struct flow_block_cb *block_cb);\n};\n\nstruct flow_block_cb {\n\tstruct list_head\tdriver_list;\n\tstruct list_head\tlist;\n\tflow_setup_cb_t\t\t*cb;\n\tvoid\t\t\t*cb_ident;\n\tvoid\t\t\t*cb_priv;\n\tvoid\t\t\t(*release)(void *cb_priv);\n\tstruct flow_block_indr\tindr;\n\tunsigned int\t\trefcnt;\n};\n\nstruct flow_block_cb *flow_block_cb_alloc(flow_setup_cb_t *cb,\n\t\t\t\t\t  void *cb_ident, void *cb_priv,\n\t\t\t\t\t  void (*release)(void *cb_priv));\nstruct flow_block_cb *flow_indr_block_cb_alloc(flow_setup_cb_t *cb,\n\t\t\t\t\t       void *cb_ident, void *cb_priv,\n\t\t\t\t\t       void (*release)(void *cb_priv),\n\t\t\t\t\t       struct flow_block_offload *bo,\n\t\t\t\t\t       struct net_device *dev,\n\t\t\t\t\t       struct Qdisc *sch, void *data,\n\t\t\t\t\t       void *indr_cb_priv,\n\t\t\t\t\t       void (*cleanup)(struct flow_block_cb *block_cb));\nvoid flow_block_cb_free(struct flow_block_cb *block_cb);\n\nstruct flow_block_cb *flow_block_cb_lookup(struct flow_block *block,\n\t\t\t\t\t   flow_setup_cb_t *cb, void *cb_ident);\n\nvoid *flow_block_cb_priv(struct flow_block_cb *block_cb);\nvoid flow_block_cb_incref(struct flow_block_cb *block_cb);\nunsigned int flow_block_cb_decref(struct flow_block_cb *block_cb);\n\nstatic inline void flow_block_cb_add(struct flow_block_cb *block_cb,\n\t\t\t\t     struct flow_block_offload *offload)\n{\n\tlist_add_tail(&block_cb->list, &offload->cb_list);\n}\n\nstatic inline void flow_block_cb_remove(struct flow_block_cb *block_cb,\n\t\t\t\t\tstruct flow_block_offload *offload)\n{\n\tlist_move(&block_cb->list, &offload->cb_list);\n}\n\nstatic inline void flow_indr_block_cb_remove(struct flow_block_cb *block_cb,\n\t\t\t\t\t     struct flow_block_offload *offload)\n{\n\tlist_del(&block_cb->indr.list);\n\tlist_move(&block_cb->list, &offload->cb_list);\n}\n\nbool flow_block_cb_is_busy(flow_setup_cb_t *cb, void *cb_ident,\n\t\t\t   struct list_head *driver_block_list);\n\nint flow_block_cb_setup_simple(struct flow_block_offload *f,\n\t\t\t       struct list_head *driver_list,\n\t\t\t       flow_setup_cb_t *cb,\n\t\t\t       void *cb_ident, void *cb_priv, bool ingress_only);\n\nenum flow_cls_command {\n\tFLOW_CLS_REPLACE,\n\tFLOW_CLS_DESTROY,\n\tFLOW_CLS_STATS,\n\tFLOW_CLS_TMPLT_CREATE,\n\tFLOW_CLS_TMPLT_DESTROY,\n};\n\nstruct flow_cls_common_offload {\n\tu32 chain_index;\n\t__be16 protocol;\n\tu32 prio;\n\tstruct netlink_ext_ack *extack;\n};\n\nstruct flow_cls_offload {\n\tstruct flow_cls_common_offload common;\n\tenum flow_cls_command command;\n\tbool use_act_stats;\n\tunsigned long cookie;\n\tstruct flow_rule *rule;\n\tstruct flow_stats stats;\n\tu32 classid;\n};\n\nenum offload_act_command  {\n\tFLOW_ACT_REPLACE,\n\tFLOW_ACT_DESTROY,\n\tFLOW_ACT_STATS,\n};\n\nstruct flow_offload_action {\n\tstruct netlink_ext_ack *extack;  \n\tenum offload_act_command  command;\n\tenum flow_action_id id;\n\tu32 index;\n\tunsigned long cookie;\n\tstruct flow_stats stats;\n\tstruct flow_action action;\n};\n\nstruct flow_offload_action *offload_action_alloc(unsigned int num_actions);\n\nstatic inline struct flow_rule *\nflow_cls_offload_flow_rule(struct flow_cls_offload *flow_cmd)\n{\n\treturn flow_cmd->rule;\n}\n\nstatic inline void flow_block_init(struct flow_block *flow_block)\n{\n\tINIT_LIST_HEAD(&flow_block->cb_list);\n}\n\ntypedef int flow_indr_block_bind_cb_t(struct net_device *dev, struct Qdisc *sch, void *cb_priv,\n\t\t\t\t      enum tc_setup_type type, void *type_data,\n\t\t\t\t      void *data,\n\t\t\t\t      void (*cleanup)(struct flow_block_cb *block_cb));\n\nint flow_indr_dev_register(flow_indr_block_bind_cb_t *cb, void *cb_priv);\nvoid flow_indr_dev_unregister(flow_indr_block_bind_cb_t *cb, void *cb_priv,\n\t\t\t      void (*release)(void *cb_priv));\nint flow_indr_dev_setup_offload(struct net_device *dev, struct Qdisc *sch,\n\t\t\t\tenum tc_setup_type type, void *data,\n\t\t\t\tstruct flow_block_offload *bo,\n\t\t\t\tvoid (*cleanup)(struct flow_block_cb *block_cb));\nbool flow_indr_dev_exists(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}