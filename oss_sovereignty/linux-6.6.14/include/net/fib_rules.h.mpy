{
  "module_name": "fib_rules.h",
  "hash_id": "e23629ef442e61857dc06f6c8ed359aeea50e0d9dab28de2b33935368691c6a5",
  "original_prompt": "Ingested from linux-6.6.14/include/net/fib_rules.h",
  "human_readable_source": " \n#ifndef __NET_FIB_RULES_H\n#define __NET_FIB_RULES_H\n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/fib_rules.h>\n#include <linux/refcount.h>\n#include <net/flow.h>\n#include <net/rtnetlink.h>\n#include <net/fib_notifier.h>\n#include <linux/indirect_call_wrapper.h>\n\nstruct fib_kuid_range {\n\tkuid_t start;\n\tkuid_t end;\n};\n\nstruct fib_rule {\n\tstruct list_head\tlist;\n\tint\t\t\tiifindex;\n\tint\t\t\toifindex;\n\tu32\t\t\tmark;\n\tu32\t\t\tmark_mask;\n\tu32\t\t\tflags;\n\tu32\t\t\ttable;\n\tu8\t\t\taction;\n\tu8\t\t\tl3mdev;\n\tu8                      proto;\n\tu8\t\t\tip_proto;\n\tu32\t\t\ttarget;\n\t__be64\t\t\ttun_id;\n\tstruct fib_rule __rcu\t*ctarget;\n\tstruct net\t\t*fr_net;\n\n\trefcount_t\t\trefcnt;\n\tu32\t\t\tpref;\n\tint\t\t\tsuppress_ifgroup;\n\tint\t\t\tsuppress_prefixlen;\n\tchar\t\t\tiifname[IFNAMSIZ];\n\tchar\t\t\toifname[IFNAMSIZ];\n\tstruct fib_kuid_range\tuid_range;\n\tstruct fib_rule_port_range\tsport_range;\n\tstruct fib_rule_port_range\tdport_range;\n\tstruct rcu_head\t\trcu;\n};\n\nstruct fib_lookup_arg {\n\tvoid\t\t\t*lookup_ptr;\n\tconst void\t\t*lookup_data;\n\tvoid\t\t\t*result;\n\tstruct fib_rule\t\t*rule;\n\tu32\t\t\ttable;\n\tint\t\t\tflags;\n#define FIB_LOOKUP_NOREF\t\t1\n#define FIB_LOOKUP_IGNORE_LINKSTATE\t2\n};\n\nstruct fib_rules_ops {\n\tint\t\t\tfamily;\n\tstruct list_head\tlist;\n\tint\t\t\trule_size;\n\tint\t\t\taddr_size;\n\tint\t\t\tunresolved_rules;\n\tint\t\t\tnr_goto_rules;\n\tunsigned int\t\tfib_rules_seq;\n\n\tint\t\t\t(*action)(struct fib_rule *,\n\t\t\t\t\t  struct flowi *, int,\n\t\t\t\t\t  struct fib_lookup_arg *);\n\tbool\t\t\t(*suppress)(struct fib_rule *, int,\n\t\t\t\t\t    struct fib_lookup_arg *);\n\tint\t\t\t(*match)(struct fib_rule *,\n\t\t\t\t\t struct flowi *, int);\n\tint\t\t\t(*configure)(struct fib_rule *,\n\t\t\t\t\t     struct sk_buff *,\n\t\t\t\t\t     struct fib_rule_hdr *,\n\t\t\t\t\t     struct nlattr **,\n\t\t\t\t\t     struct netlink_ext_ack *);\n\tint\t\t\t(*delete)(struct fib_rule *);\n\tint\t\t\t(*compare)(struct fib_rule *,\n\t\t\t\t\t   struct fib_rule_hdr *,\n\t\t\t\t\t   struct nlattr **);\n\tint\t\t\t(*fill)(struct fib_rule *, struct sk_buff *,\n\t\t\t\t\tstruct fib_rule_hdr *);\n\tsize_t\t\t\t(*nlmsg_payload)(struct fib_rule *);\n\n\t \n\tvoid\t\t\t(*flush_cache)(struct fib_rules_ops *ops);\n\n\tint\t\t\tnlgroup;\n\tstruct list_head\trules_list;\n\tstruct module\t\t*owner;\n\tstruct net\t\t*fro_net;\n\tstruct rcu_head\t\trcu;\n};\n\nstruct fib_rule_notifier_info {\n\tstruct fib_notifier_info info;  \n\tstruct fib_rule *rule;\n};\n\nstatic inline void fib_rule_get(struct fib_rule *rule)\n{\n\trefcount_inc(&rule->refcnt);\n}\n\nstatic inline void fib_rule_put(struct fib_rule *rule)\n{\n\tif (refcount_dec_and_test(&rule->refcnt))\n\t\tkfree_rcu(rule, rcu);\n}\n\n#ifdef CONFIG_NET_L3_MASTER_DEV\nstatic inline u32 fib_rule_get_table(struct fib_rule *rule,\n\t\t\t\t     struct fib_lookup_arg *arg)\n{\n\treturn rule->l3mdev ? arg->table : rule->table;\n}\n#else\nstatic inline u32 fib_rule_get_table(struct fib_rule *rule,\n\t\t\t\t     struct fib_lookup_arg *arg)\n{\n\treturn rule->table;\n}\n#endif\n\nstatic inline u32 frh_get_table(struct fib_rule_hdr *frh, struct nlattr **nla)\n{\n\tif (nla[FRA_TABLE])\n\t\treturn nla_get_u32(nla[FRA_TABLE]);\n\treturn frh->table;\n}\n\nstatic inline bool fib_rule_port_range_set(const struct fib_rule_port_range *range)\n{\n\treturn range->start != 0 && range->end != 0;\n}\n\nstatic inline bool fib_rule_port_inrange(const struct fib_rule_port_range *a,\n\t\t\t\t\t __be16 port)\n{\n\treturn ntohs(port) >= a->start &&\n\t\tntohs(port) <= a->end;\n}\n\nstatic inline bool fib_rule_port_range_valid(const struct fib_rule_port_range *a)\n{\n\treturn a->start != 0 && a->end != 0 && a->end < 0xffff &&\n\t\ta->start <= a->end;\n}\n\nstatic inline bool fib_rule_port_range_compare(struct fib_rule_port_range *a,\n\t\t\t\t\t       struct fib_rule_port_range *b)\n{\n\treturn a->start == b->start &&\n\t\ta->end == b->end;\n}\n\nstatic inline bool fib_rule_requires_fldissect(struct fib_rule *rule)\n{\n\treturn rule->iifindex != LOOPBACK_IFINDEX && (rule->ip_proto ||\n\t\tfib_rule_port_range_set(&rule->sport_range) ||\n\t\tfib_rule_port_range_set(&rule->dport_range));\n}\n\nstruct fib_rules_ops *fib_rules_register(const struct fib_rules_ops *,\n\t\t\t\t\t struct net *);\nvoid fib_rules_unregister(struct fib_rules_ops *);\n\nint fib_rules_lookup(struct fib_rules_ops *, struct flowi *, int flags,\n\t\t     struct fib_lookup_arg *);\nint fib_default_rule_add(struct fib_rules_ops *, u32 pref, u32 table,\n\t\t\t u32 flags);\nbool fib_rule_matchall(const struct fib_rule *rule);\nint fib_rules_dump(struct net *net, struct notifier_block *nb, int family,\n\t\t   struct netlink_ext_ack *extack);\nunsigned int fib_rules_seq_read(struct net *net, int family);\n\nint fib_nl_newrule(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t   struct netlink_ext_ack *extack);\nint fib_nl_delrule(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t   struct netlink_ext_ack *extack);\n\nINDIRECT_CALLABLE_DECLARE(int fib6_rule_match(struct fib_rule *rule,\n\t\t\t\t\t    struct flowi *fl, int flags));\nINDIRECT_CALLABLE_DECLARE(int fib4_rule_match(struct fib_rule *rule,\n\t\t\t\t\t    struct flowi *fl, int flags));\n\nINDIRECT_CALLABLE_DECLARE(int fib6_rule_action(struct fib_rule *rule,\n\t\t\t    struct flowi *flp, int flags,\n\t\t\t    struct fib_lookup_arg *arg));\nINDIRECT_CALLABLE_DECLARE(int fib4_rule_action(struct fib_rule *rule,\n\t\t\t    struct flowi *flp, int flags,\n\t\t\t    struct fib_lookup_arg *arg));\n\nINDIRECT_CALLABLE_DECLARE(bool fib6_rule_suppress(struct fib_rule *rule,\n\t\t\t\t\t\tint flags,\n\t\t\t\t\t\tstruct fib_lookup_arg *arg));\nINDIRECT_CALLABLE_DECLARE(bool fib4_rule_suppress(struct fib_rule *rule,\n\t\t\t\t\t\tint flags,\n\t\t\t\t\t\tstruct fib_lookup_arg *arg));\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}