{
  "module_name": "vxlan.h",
  "hash_id": "6e8e617ec22baaec36a3c51294b0ed56302f872043ce205615d57b73f1bd4914",
  "original_prompt": "Ingested from linux-6.6.14/include/net/vxlan.h",
  "human_readable_source": " \n#ifndef __NET_VXLAN_H\n#define __NET_VXLAN_H 1\n\n#include <linux/if_vlan.h>\n#include <linux/rhashtable-types.h>\n#include <net/udp_tunnel.h>\n#include <net/dst_metadata.h>\n#include <net/rtnetlink.h>\n#include <net/switchdev.h>\n#include <net/nexthop.h>\n\n#define IANA_VXLAN_UDP_PORT     4789\n#define IANA_VXLAN_GPE_UDP_PORT 4790\n\n \nstruct vxlanhdr {\n\t__be32 vx_flags;\n\t__be32 vx_vni;\n};\n\n \n#define VXLAN_HF_VNI\tcpu_to_be32(BIT(27))\n\n#define VXLAN_N_VID     (1u << 24)\n#define VXLAN_VID_MASK  (VXLAN_N_VID - 1)\n#define VXLAN_VNI_MASK\tcpu_to_be32(VXLAN_VID_MASK << 8)\n#define VXLAN_HLEN (sizeof(struct udphdr) + sizeof(struct vxlanhdr))\n\n#define VNI_HASH_BITS\t10\n#define VNI_HASH_SIZE\t(1<<VNI_HASH_BITS)\n#define FDB_HASH_BITS\t8\n#define FDB_HASH_SIZE\t(1<<FDB_HASH_BITS)\n\n \n\n \n#define VXLAN_HF_RCO\tcpu_to_be32(BIT(21))\n\n \n#define VXLAN_RCO_MASK\tcpu_to_be32(0x7f)   \n#define VXLAN_RCO_UDP\tcpu_to_be32(0x80)   \n#define VXLAN_RCO_SHIFT\t1\t\t    \n#define VXLAN_RCO_SHIFT_MASK ((1 << VXLAN_RCO_SHIFT) - 1)\n#define VXLAN_MAX_REMCSUM_START (0x7f << VXLAN_RCO_SHIFT)\n\n \nstruct vxlanhdr_gbp {\n\tu8\tvx_flags;\n#ifdef __LITTLE_ENDIAN_BITFIELD\n\tu8\treserved_flags1:3,\n\t\tpolicy_applied:1,\n\t\treserved_flags2:2,\n\t\tdont_learn:1,\n\t\treserved_flags3:1;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n\tu8\treserved_flags1:1,\n\t\tdont_learn:1,\n\t\treserved_flags2:2,\n\t\tpolicy_applied:1,\n\t\treserved_flags3:3;\n#else\n#error\t\"Please fix <asm/byteorder.h>\"\n#endif\n\t__be16\tpolicy_id;\n\t__be32\tvx_vni;\n};\n\n \n#define VXLAN_HF_GBP\tcpu_to_be32(BIT(31))\n\n#define VXLAN_GBP_USED_BITS (VXLAN_HF_GBP | cpu_to_be32(0xFFFFFF))\n\n \n#define VXLAN_GBP_DONT_LEARN\t\t(BIT(6) << 16)\n#define VXLAN_GBP_POLICY_APPLIED\t(BIT(3) << 16)\n#define VXLAN_GBP_ID_MASK\t\t(0xFFFF)\n\n#define VXLAN_GBP_MASK (VXLAN_GBP_DONT_LEARN | VXLAN_GBP_POLICY_APPLIED | \\\n\t\t\tVXLAN_GBP_ID_MASK)\n\n \n\nstruct vxlanhdr_gpe {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8\toam_flag:1,\n\t\treserved_flags1:1,\n\t\tnp_applied:1,\n\t\tinstance_applied:1,\n\t\tversion:2,\n\t\treserved_flags2:2;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n\tu8\treserved_flags2:2,\n\t\tversion:2,\n\t\tinstance_applied:1,\n\t\tnp_applied:1,\n\t\treserved_flags1:1,\n\t\toam_flag:1;\n#endif\n\tu8\treserved_flags3;\n\tu8\treserved_flags4;\n\tu8\tnext_protocol;\n\t__be32\tvx_vni;\n};\n\n \n#define VXLAN_HF_VER\tcpu_to_be32(BIT(29) | BIT(28))\n#define VXLAN_HF_NP\tcpu_to_be32(BIT(26))\n#define VXLAN_HF_OAM\tcpu_to_be32(BIT(24))\n\n#define VXLAN_GPE_USED_BITS (VXLAN_HF_VER | VXLAN_HF_NP | VXLAN_HF_OAM | \\\n\t\t\t     cpu_to_be32(0xff))\n\nstruct vxlan_metadata {\n\tu32\t\tgbp;\n};\n\n \nstruct vxlan_sock {\n\tstruct hlist_node hlist;\n\tstruct socket\t *sock;\n\tstruct hlist_head vni_list[VNI_HASH_SIZE];\n\trefcount_t\t  refcnt;\n\tu32\t\t  flags;\n};\n\nunion vxlan_addr {\n\tstruct sockaddr_in sin;\n\tstruct sockaddr_in6 sin6;\n\tstruct sockaddr sa;\n};\n\nstruct vxlan_rdst {\n\tunion vxlan_addr\t remote_ip;\n\t__be16\t\t\t remote_port;\n\tu8\t\t\t offloaded:1;\n\t__be32\t\t\t remote_vni;\n\tu32\t\t\t remote_ifindex;\n\tstruct net_device\t *remote_dev;\n\tstruct list_head\t list;\n\tstruct rcu_head\t\t rcu;\n\tstruct dst_cache\t dst_cache;\n};\n\nstruct vxlan_config {\n\tunion vxlan_addr\tremote_ip;\n\tunion vxlan_addr\tsaddr;\n\t__be32\t\t\tvni;\n\tint\t\t\tremote_ifindex;\n\tint\t\t\tmtu;\n\t__be16\t\t\tdst_port;\n\tu16\t\t\tport_min;\n\tu16\t\t\tport_max;\n\tu8\t\t\ttos;\n\tu8\t\t\tttl;\n\t__be32\t\t\tlabel;\n\tu32\t\t\tflags;\n\tunsigned long\t\tage_interval;\n\tunsigned int\t\taddrmax;\n\tbool\t\t\tno_share;\n\tenum ifla_vxlan_df\tdf;\n};\n\nenum {\n\tVXLAN_VNI_STATS_RX,\n\tVXLAN_VNI_STATS_RX_DROPS,\n\tVXLAN_VNI_STATS_RX_ERRORS,\n\tVXLAN_VNI_STATS_TX,\n\tVXLAN_VNI_STATS_TX_DROPS,\n\tVXLAN_VNI_STATS_TX_ERRORS,\n};\n\nstruct vxlan_vni_stats {\n\tu64 rx_packets;\n\tu64 rx_bytes;\n\tu64 rx_drops;\n\tu64 rx_errors;\n\tu64 tx_packets;\n\tu64 tx_bytes;\n\tu64 tx_drops;\n\tu64 tx_errors;\n};\n\nstruct vxlan_vni_stats_pcpu {\n\tstruct vxlan_vni_stats stats;\n\tstruct u64_stats_sync syncp;\n};\n\nstruct vxlan_dev_node {\n\tstruct hlist_node hlist;\n\tstruct vxlan_dev *vxlan;\n};\n\nstruct vxlan_vni_node {\n\tstruct rhash_head vnode;\n\tstruct vxlan_dev_node hlist4;  \n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct vxlan_dev_node hlist6;  \n#endif\n\tstruct list_head vlist;\n\t__be32 vni;\n\tunion vxlan_addr remote_ip;  \n\tstruct vxlan_vni_stats_pcpu __percpu *stats;\n\n\tstruct rcu_head rcu;\n};\n\nstruct vxlan_vni_group {\n\tstruct rhashtable\tvni_hash;\n\tstruct list_head\tvni_list;\n\tu32\t\t\tnum_vnis;\n};\n\n \nstruct vxlan_dev {\n\tstruct vxlan_dev_node hlist4;\t \n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct vxlan_dev_node hlist6;\t \n#endif\n\tstruct list_head  next;\t\t \n\tstruct vxlan_sock __rcu *vn4_sock;\t \n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct vxlan_sock __rcu *vn6_sock;\t \n#endif\n\tstruct net_device *dev;\n\tstruct net\t  *net;\t\t \n\tstruct vxlan_rdst default_dst;\t \n\n\tstruct timer_list age_timer;\n\tspinlock_t\t  hash_lock[FDB_HASH_SIZE];\n\tunsigned int\t  addrcnt;\n\tstruct gro_cells  gro_cells;\n\n\tstruct vxlan_config\tcfg;\n\n\tstruct vxlan_vni_group  __rcu *vnigrp;\n\n\tstruct hlist_head fdb_head[FDB_HASH_SIZE];\n\n\tstruct rhashtable mdb_tbl;\n\tstruct hlist_head mdb_list;\n\tunsigned int mdb_seq;\n};\n\n#define VXLAN_F_LEARN\t\t\t0x01\n#define VXLAN_F_PROXY\t\t\t0x02\n#define VXLAN_F_RSC\t\t\t0x04\n#define VXLAN_F_L2MISS\t\t\t0x08\n#define VXLAN_F_L3MISS\t\t\t0x10\n#define VXLAN_F_IPV6\t\t\t0x20\n#define VXLAN_F_UDP_ZERO_CSUM_TX\t0x40\n#define VXLAN_F_UDP_ZERO_CSUM6_TX\t0x80\n#define VXLAN_F_UDP_ZERO_CSUM6_RX\t0x100\n#define VXLAN_F_REMCSUM_TX\t\t0x200\n#define VXLAN_F_REMCSUM_RX\t\t0x400\n#define VXLAN_F_GBP\t\t\t0x800\n#define VXLAN_F_REMCSUM_NOPARTIAL\t0x1000\n#define VXLAN_F_COLLECT_METADATA\t0x2000\n#define VXLAN_F_GPE\t\t\t0x4000\n#define VXLAN_F_IPV6_LINKLOCAL\t\t0x8000\n#define VXLAN_F_TTL_INHERIT\t\t0x10000\n#define VXLAN_F_VNIFILTER               0x20000\n#define VXLAN_F_MDB\t\t\t0x40000\n#define VXLAN_F_LOCALBYPASS\t\t0x80000\n\n \n#define VXLAN_F_RCV_FLAGS\t\t(VXLAN_F_GBP |\t\t\t\\\n\t\t\t\t\t VXLAN_F_GPE |\t\t\t\\\n\t\t\t\t\t VXLAN_F_UDP_ZERO_CSUM6_RX |\t\\\n\t\t\t\t\t VXLAN_F_REMCSUM_RX |\t\t\\\n\t\t\t\t\t VXLAN_F_REMCSUM_NOPARTIAL |\t\\\n\t\t\t\t\t VXLAN_F_COLLECT_METADATA |\t\\\n\t\t\t\t\t VXLAN_F_VNIFILTER)\n\n \n#define VXLAN_F_ALLOWED_GPE\t\t(VXLAN_F_GPE |\t\t\t\\\n\t\t\t\t\t VXLAN_F_IPV6 |\t\t\t\\\n\t\t\t\t\t VXLAN_F_IPV6_LINKLOCAL |\t\\\n\t\t\t\t\t VXLAN_F_UDP_ZERO_CSUM_TX |\t\\\n\t\t\t\t\t VXLAN_F_UDP_ZERO_CSUM6_TX |\t\\\n\t\t\t\t\t VXLAN_F_UDP_ZERO_CSUM6_RX |\t\\\n\t\t\t\t\t VXLAN_F_COLLECT_METADATA  |\t\\\n\t\t\t\t\t VXLAN_F_VNIFILTER         |    \\\n\t\t\t\t\t VXLAN_F_LOCALBYPASS)\n\nstruct net_device *vxlan_dev_create(struct net *net, const char *name,\n\t\t\t\t    u8 name_assign_type, struct vxlan_config *conf);\n\nstatic inline netdev_features_t vxlan_features_check(struct sk_buff *skb,\n\t\t\t\t\t\t     netdev_features_t features)\n{\n\tu8 l4_hdr = 0;\n\n\tif (!skb->encapsulation)\n\t\treturn features;\n\n\tswitch (vlan_get_protocol(skb)) {\n\tcase htons(ETH_P_IP):\n\t\tl4_hdr = ip_hdr(skb)->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl4_hdr = ipv6_hdr(skb)->nexthdr;\n\t\tbreak;\n\tdefault:\n\t\treturn features;\n\t}\n\n\tif ((l4_hdr == IPPROTO_UDP) &&\n\t    (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||\n\t     skb->inner_protocol != htons(ETH_P_TEB) ||\n\t     (skb_inner_mac_header(skb) - skb_transport_header(skb) !=\n\t      sizeof(struct udphdr) + sizeof(struct vxlanhdr)) ||\n\t     (skb->ip_summed != CHECKSUM_NONE &&\n\t      !can_checksum_protocol(features, inner_eth_hdr(skb)->h_proto))))\n\t\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n\n\treturn features;\n}\n\nstatic inline int vxlan_headroom(u32 flags)\n{\n\t \n\t \n\treturn (flags & VXLAN_F_IPV6 ? sizeof(struct ipv6hdr) :\n\t\t\t\t       sizeof(struct iphdr)) +\n\t       sizeof(struct udphdr) + sizeof(struct vxlanhdr) +\n\t       (flags & VXLAN_F_GPE ? 0 : ETH_HLEN);\n}\n\nstatic inline struct vxlanhdr *vxlan_hdr(struct sk_buff *skb)\n{\n\treturn (struct vxlanhdr *)(udp_hdr(skb) + 1);\n}\n\nstatic inline __be32 vxlan_vni(__be32 vni_field)\n{\n#if defined(__BIG_ENDIAN)\n\treturn (__force __be32)((__force u32)vni_field >> 8);\n#else\n\treturn (__force __be32)((__force u32)(vni_field & VXLAN_VNI_MASK) << 8);\n#endif\n}\n\nstatic inline __be32 vxlan_vni_field(__be32 vni)\n{\n#if defined(__BIG_ENDIAN)\n\treturn (__force __be32)((__force u32)vni << 8);\n#else\n\treturn (__force __be32)((__force u32)vni >> 8);\n#endif\n}\n\nstatic inline size_t vxlan_rco_start(__be32 vni_field)\n{\n\treturn be32_to_cpu(vni_field & VXLAN_RCO_MASK) << VXLAN_RCO_SHIFT;\n}\n\nstatic inline size_t vxlan_rco_offset(__be32 vni_field)\n{\n\treturn (vni_field & VXLAN_RCO_UDP) ?\n\t\toffsetof(struct udphdr, check) :\n\t\toffsetof(struct tcphdr, check);\n}\n\nstatic inline __be32 vxlan_compute_rco(unsigned int start, unsigned int offset)\n{\n\t__be32 vni_field = cpu_to_be32(start >> VXLAN_RCO_SHIFT);\n\n\tif (offset == offsetof(struct udphdr, check))\n\t\tvni_field |= VXLAN_RCO_UDP;\n\treturn vni_field;\n}\n\nstatic inline unsigned short vxlan_get_sk_family(struct vxlan_sock *vs)\n{\n\treturn vs->sock->sk->sk_family;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\nstatic inline bool vxlan_addr_any(const union vxlan_addr *ipa)\n{\n\tif (ipa->sa.sa_family == AF_INET6)\n\t\treturn ipv6_addr_any(&ipa->sin6.sin6_addr);\n\telse\n\t\treturn ipa->sin.sin_addr.s_addr == htonl(INADDR_ANY);\n}\n\nstatic inline bool vxlan_addr_multicast(const union vxlan_addr *ipa)\n{\n\tif (ipa->sa.sa_family == AF_INET6)\n\t\treturn ipv6_addr_is_multicast(&ipa->sin6.sin6_addr);\n\telse\n\t\treturn ipv4_is_multicast(ipa->sin.sin_addr.s_addr);\n}\n\n#else  \n\nstatic inline bool vxlan_addr_any(const union vxlan_addr *ipa)\n{\n\treturn ipa->sin.sin_addr.s_addr == htonl(INADDR_ANY);\n}\n\nstatic inline bool vxlan_addr_multicast(const union vxlan_addr *ipa)\n{\n\treturn ipv4_is_multicast(ipa->sin.sin_addr.s_addr);\n}\n\n#endif  \n\nstatic inline bool netif_is_vxlan(const struct net_device *dev)\n{\n\treturn dev->rtnl_link_ops &&\n\t       !strcmp(dev->rtnl_link_ops->kind, \"vxlan\");\n}\n\nstruct switchdev_notifier_vxlan_fdb_info {\n\tstruct switchdev_notifier_info info;  \n\tunion vxlan_addr remote_ip;\n\t__be16 remote_port;\n\t__be32 remote_vni;\n\tu32 remote_ifindex;\n\tu8 eth_addr[ETH_ALEN];\n\t__be32 vni;\n\tbool offloaded;\n\tbool added_by_user;\n};\n\n#if IS_ENABLED(CONFIG_VXLAN)\nint vxlan_fdb_find_uc(struct net_device *dev, const u8 *mac, __be32 vni,\n\t\t      struct switchdev_notifier_vxlan_fdb_info *fdb_info);\nint vxlan_fdb_replay(const struct net_device *dev, __be32 vni,\n\t\t     struct notifier_block *nb,\n\t\t     struct netlink_ext_ack *extack);\nvoid vxlan_fdb_clear_offload(const struct net_device *dev, __be32 vni);\n\n#else\nstatic inline int\nvxlan_fdb_find_uc(struct net_device *dev, const u8 *mac, __be32 vni,\n\t\t  struct switchdev_notifier_vxlan_fdb_info *fdb_info)\n{\n\treturn -ENOENT;\n}\n\nstatic inline int vxlan_fdb_replay(const struct net_device *dev, __be32 vni,\n\t\t\t\t   struct notifier_block *nb,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void\nvxlan_fdb_clear_offload(const struct net_device *dev, __be32 vni)\n{\n}\n#endif\n\nstatic inline void vxlan_flag_attr_error(int attrtype,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n#define VXLAN_FLAG(flg) \\\n\tcase IFLA_VXLAN_##flg: \\\n\t\tNL_SET_ERR_MSG_MOD(extack, \\\n\t\t\t\t   \"cannot change \" #flg \" flag\"); \\\n\t\tbreak\n\tswitch (attrtype) {\n\tVXLAN_FLAG(TTL_INHERIT);\n\tVXLAN_FLAG(LEARNING);\n\tVXLAN_FLAG(PROXY);\n\tVXLAN_FLAG(RSC);\n\tVXLAN_FLAG(L2MISS);\n\tVXLAN_FLAG(L3MISS);\n\tVXLAN_FLAG(COLLECT_METADATA);\n\tVXLAN_FLAG(UDP_ZERO_CSUM6_TX);\n\tVXLAN_FLAG(UDP_ZERO_CSUM6_RX);\n\tVXLAN_FLAG(REMCSUM_TX);\n\tVXLAN_FLAG(REMCSUM_RX);\n\tVXLAN_FLAG(GBP);\n\tVXLAN_FLAG(GPE);\n\tVXLAN_FLAG(REMCSUM_NOPARTIAL);\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \\\n\t\t\t\t   \"cannot change flag\");\n\t\tbreak;\n\t}\n#undef VXLAN_FLAG\n}\n\nstatic inline bool vxlan_fdb_nh_path_select(struct nexthop *nh,\n\t\t\t\t\t    u32 hash,\n\t\t\t\t\t    struct vxlan_rdst *rdst)\n{\n\tstruct fib_nh_common *nhc;\n\n\tnhc = nexthop_path_fdb_result(nh, hash >> 1);\n\tif (unlikely(!nhc))\n\t\treturn false;\n\n\tswitch (nhc->nhc_gw_family) {\n\tcase AF_INET:\n\t\trdst->remote_ip.sin.sin_addr.s_addr = nhc->nhc_gw.ipv4;\n\t\trdst->remote_ip.sa.sa_family = AF_INET;\n\t\tbreak;\n\tcase AF_INET6:\n\t\trdst->remote_ip.sin6.sin6_addr = nhc->nhc_gw.ipv6;\n\t\trdst->remote_ip.sa.sa_family = AF_INET6;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic inline void vxlan_build_gbp_hdr(struct vxlanhdr *vxh, const struct vxlan_metadata *md)\n{\n\tstruct vxlanhdr_gbp *gbp;\n\n\tif (!md->gbp)\n\t\treturn;\n\n\tgbp = (struct vxlanhdr_gbp *)vxh;\n\tvxh->vx_flags |= VXLAN_HF_GBP;\n\n\tif (md->gbp & VXLAN_GBP_DONT_LEARN)\n\t\tgbp->dont_learn = 1;\n\n\tif (md->gbp & VXLAN_GBP_POLICY_APPLIED)\n\t\tgbp->policy_applied = 1;\n\n\tgbp->policy_id = htons(md->gbp & VXLAN_GBP_ID_MASK);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}