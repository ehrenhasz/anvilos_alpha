{
  "module_name": "udplite.h",
  "hash_id": "ccae25f0ecbb75bf233f3425efbdce4a9c67debb335a9925d9658b0290427afb",
  "original_prompt": "Ingested from linux-6.6.14/include/net/udplite.h",
  "human_readable_source": " \n \n#ifndef _UDPLITE_H\n#define _UDPLITE_H\n\n#include <net/ip6_checksum.h>\n#include <net/udp.h>\n\n \n#define UDPLITE_SEND_CSCOV   10  \n#define UDPLITE_RECV_CSCOV   11  \n\nextern struct proto \t\tudplite_prot;\nextern struct udp_table\t\tudplite_table;\n\n \nstatic __inline__ int udplite_getfrag(void *from, char *to, int  offset,\n\t\t\t\t      int len, int odd, struct sk_buff *skb)\n{\n\tstruct msghdr *msg = from;\n\treturn copy_from_iter_full(to, len, &msg->msg_iter) ? 0 : -EFAULT;\n}\n\n \nstatic inline int udplite_checksum_init(struct sk_buff *skb, struct udphdr *uh)\n{\n\tu16 cscov;\n\n         \n\tif (uh->check == 0) {\n\t\tnet_dbg_ratelimited(\"UDPLite: zeroed checksum field\\n\");\n\t\treturn 1;\n\t}\n\n\tcscov = ntohs(uh->len);\n\n\tif (cscov == 0)\t\t  \n\t\t;\n\telse if (cscov < 8  || cscov > skb->len) {\n\t\t \n\t\tnet_dbg_ratelimited(\"UDPLite: bad csum coverage %d/%d\\n\",\n\t\t\t\t    cscov, skb->len);\n\t\treturn 1;\n\n\t} else if (cscov < skb->len) {\n        \tUDP_SKB_CB(skb)->partial_cov = 1;\n\t\tUDP_SKB_CB(skb)->cscov = cscov;\n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tskb->csum_valid = 0;\n        }\n\n\treturn 0;\n}\n\n \nstatic inline __wsum udplite_csum(struct sk_buff *skb)\n{\n\tconst int off = skb_transport_offset(skb);\n\tconst struct sock *sk = skb->sk;\n\tint len = skb->len - off;\n\n\tif (udp_test_bit(UDPLITE_SEND_CC, sk)) {\n\t\tu16 pcslen = READ_ONCE(udp_sk(sk)->pcslen);\n\n\t\tif (pcslen < len) {\n\t\t\tif (pcslen > 0)\n\t\t\t\tlen = pcslen;\n\t\t\tudp_hdr(skb)->len = htons(pcslen);\n\t\t}\n\t}\n\tskb->ip_summed = CHECKSUM_NONE;      \n\n\treturn skb_checksum(skb, off, len, 0);\n}\n\nvoid udplite4_register(void);\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}