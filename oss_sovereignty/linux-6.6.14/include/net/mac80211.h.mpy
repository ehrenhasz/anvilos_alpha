{
  "module_name": "mac80211.h",
  "hash_id": "e452aa202093a1b494f770f526c3d35bb3a92e0b28634b891517c6f171ed8fff",
  "original_prompt": "Ingested from linux-6.6.14/include/net/mac80211.h",
  "human_readable_source": " \n \n\n#ifndef MAC80211_H\n#define MAC80211_H\n\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/ieee80211.h>\n#include <linux/lockdep.h>\n#include <net/cfg80211.h>\n#include <net/codel.h>\n#include <net/ieee80211_radiotap.h>\n#include <asm/unaligned.h>\n\n \n\n \n\n \n\n \n\n \n\n \n\n \nstruct device;\n\n \nenum ieee80211_max_queues {\n\tIEEE80211_MAX_QUEUES =\t\t16,\n\tIEEE80211_MAX_QUEUE_MAP =\tBIT(IEEE80211_MAX_QUEUES) - 1,\n};\n\n#define IEEE80211_INVAL_HW_QUEUE\t0xff\n\n \nenum ieee80211_ac_numbers {\n\tIEEE80211_AC_VO\t\t= 0,\n\tIEEE80211_AC_VI\t\t= 1,\n\tIEEE80211_AC_BE\t\t= 2,\n\tIEEE80211_AC_BK\t\t= 3,\n};\n\n \nstruct ieee80211_tx_queue_params {\n\tu16 txop;\n\tu16 cw_min;\n\tu16 cw_max;\n\tu8 aifs;\n\tbool acm;\n\tbool uapsd;\n\tbool mu_edca;\n\tstruct ieee80211_he_mu_edca_param_ac_rec mu_edca_param_rec;\n};\n\nstruct ieee80211_low_level_stats {\n\tunsigned int dot11ACKFailureCount;\n\tunsigned int dot11RTSFailureCount;\n\tunsigned int dot11FCSErrorCount;\n\tunsigned int dot11RTSSuccessCount;\n};\n\n \nenum ieee80211_chanctx_change {\n\tIEEE80211_CHANCTX_CHANGE_WIDTH\t\t= BIT(0),\n\tIEEE80211_CHANCTX_CHANGE_RX_CHAINS\t= BIT(1),\n\tIEEE80211_CHANCTX_CHANGE_RADAR\t\t= BIT(2),\n\tIEEE80211_CHANCTX_CHANGE_CHANNEL\t= BIT(3),\n\tIEEE80211_CHANCTX_CHANGE_MIN_WIDTH\t= BIT(4),\n};\n\n \nstruct ieee80211_chanctx_conf {\n\tstruct cfg80211_chan_def def;\n\tstruct cfg80211_chan_def min_def;\n\n\tu8 rx_chains_static, rx_chains_dynamic;\n\n\tbool radar_enabled;\n\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n \nenum ieee80211_chanctx_switch_mode {\n\tCHANCTX_SWMODE_REASSIGN_VIF,\n\tCHANCTX_SWMODE_SWAP_CONTEXTS,\n};\n\n \nstruct ieee80211_vif_chanctx_switch {\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_bss_conf *link_conf;\n\tstruct ieee80211_chanctx_conf *old_ctx;\n\tstruct ieee80211_chanctx_conf *new_ctx;\n};\n\n \nenum ieee80211_bss_change {\n\tBSS_CHANGED_ASSOC\t\t= 1<<0,\n\tBSS_CHANGED_ERP_CTS_PROT\t= 1<<1,\n\tBSS_CHANGED_ERP_PREAMBLE\t= 1<<2,\n\tBSS_CHANGED_ERP_SLOT\t\t= 1<<3,\n\tBSS_CHANGED_HT\t\t\t= 1<<4,\n\tBSS_CHANGED_BASIC_RATES\t\t= 1<<5,\n\tBSS_CHANGED_BEACON_INT\t\t= 1<<6,\n\tBSS_CHANGED_BSSID\t\t= 1<<7,\n\tBSS_CHANGED_BEACON\t\t= 1<<8,\n\tBSS_CHANGED_BEACON_ENABLED\t= 1<<9,\n\tBSS_CHANGED_CQM\t\t\t= 1<<10,\n\tBSS_CHANGED_IBSS\t\t= 1<<11,\n\tBSS_CHANGED_ARP_FILTER\t\t= 1<<12,\n\tBSS_CHANGED_QOS\t\t\t= 1<<13,\n\tBSS_CHANGED_IDLE\t\t= 1<<14,\n\tBSS_CHANGED_SSID\t\t= 1<<15,\n\tBSS_CHANGED_AP_PROBE_RESP\t= 1<<16,\n\tBSS_CHANGED_PS\t\t\t= 1<<17,\n\tBSS_CHANGED_TXPOWER\t\t= 1<<18,\n\tBSS_CHANGED_P2P_PS\t\t= 1<<19,\n\tBSS_CHANGED_BEACON_INFO\t\t= 1<<20,\n\tBSS_CHANGED_BANDWIDTH\t\t= 1<<21,\n\tBSS_CHANGED_OCB                 = 1<<22,\n\tBSS_CHANGED_MU_GROUPS\t\t= 1<<23,\n\tBSS_CHANGED_KEEP_ALIVE\t\t= 1<<24,\n\tBSS_CHANGED_MCAST_RATE\t\t= 1<<25,\n\tBSS_CHANGED_FTM_RESPONDER\t= 1<<26,\n\tBSS_CHANGED_TWT\t\t\t= 1<<27,\n\tBSS_CHANGED_HE_OBSS_PD\t\t= 1<<28,\n\tBSS_CHANGED_HE_BSS_COLOR\t= 1<<29,\n\tBSS_CHANGED_FILS_DISCOVERY      = 1<<30,\n\tBSS_CHANGED_UNSOL_BCAST_PROBE_RESP = 1<<31,\n\tBSS_CHANGED_EHT_PUNCTURING\t= BIT_ULL(32),\n\n\t \n};\n\n \n#define IEEE80211_BSS_ARP_ADDR_LIST_LEN 4\n\n \nenum ieee80211_event_type {\n\tRSSI_EVENT,\n\tMLME_EVENT,\n\tBAR_RX_EVENT,\n\tBA_FRAME_TIMEOUT,\n};\n\n \nenum ieee80211_rssi_event_data {\n\tRSSI_EVENT_HIGH,\n\tRSSI_EVENT_LOW,\n};\n\n \nstruct ieee80211_rssi_event {\n\tenum ieee80211_rssi_event_data data;\n};\n\n \nenum ieee80211_mlme_event_data {\n\tAUTH_EVENT,\n\tASSOC_EVENT,\n\tDEAUTH_RX_EVENT,\n\tDEAUTH_TX_EVENT,\n};\n\n \nenum ieee80211_mlme_event_status {\n\tMLME_SUCCESS,\n\tMLME_DENIED,\n\tMLME_TIMEOUT,\n};\n\n \nstruct ieee80211_mlme_event {\n\tenum ieee80211_mlme_event_data data;\n\tenum ieee80211_mlme_event_status status;\n\tu16 reason;\n};\n\n \nstruct ieee80211_ba_event {\n\tstruct ieee80211_sta *sta;\n\tu16 tid;\n\tu16 ssn;\n};\n\n \nstruct ieee80211_event {\n\tenum ieee80211_event_type type;\n\tunion {\n\t\tstruct ieee80211_rssi_event rssi;\n\t\tstruct ieee80211_mlme_event mlme;\n\t\tstruct ieee80211_ba_event ba;\n\t} u;\n};\n\n \nstruct ieee80211_mu_group_data {\n\tu8 membership[WLAN_MEMBERSHIP_LEN];\n\tu8 position[WLAN_USER_POSITION_LEN];\n};\n\n \nstruct ieee80211_ftm_responder_params {\n\tconst u8 *lci;\n\tconst u8 *civicloc;\n\tsize_t lci_len;\n\tsize_t civicloc_len;\n};\n\n \nstruct ieee80211_fils_discovery {\n\tu32 min_interval;\n\tu32 max_interval;\n};\n\n \nstruct ieee80211_bss_conf {\n\tstruct ieee80211_vif *vif;\n\n\tconst u8 *bssid;\n\tunsigned int link_id;\n\tu8 addr[ETH_ALEN] __aligned(2);\n\tu8 htc_trig_based_pkt_ext;\n\tbool uora_exists;\n\tu8 uora_ocw_range;\n\tu16 frame_time_rts_th;\n\tbool he_support;\n\tbool twt_requester;\n\tbool twt_responder;\n\tbool twt_protected;\n\tbool twt_broadcast;\n\t \n\tbool use_cts_prot;\n\tbool use_short_preamble;\n\tbool use_short_slot;\n\tbool enable_beacon;\n\tu8 dtim_period;\n\tu16 beacon_int;\n\tu16 assoc_capability;\n\tu64 sync_tsf;\n\tu32 sync_device_ts;\n\tu8 sync_dtim_count;\n\tu32 basic_rates;\n\tstruct ieee80211_rate *beacon_rate;\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tu16 ht_operation_mode;\n\ts32 cqm_rssi_thold;\n\tu32 cqm_rssi_hyst;\n\ts32 cqm_rssi_low;\n\ts32 cqm_rssi_high;\n\tstruct cfg80211_chan_def chandef;\n\tstruct ieee80211_mu_group_data mu_group;\n\tbool qos;\n\tbool hidden_ssid;\n\tint txpower;\n\tenum nl80211_tx_power_setting txpower_type;\n\tstruct ieee80211_p2p_noa_attr p2p_noa_attr;\n\tbool allow_p2p_go_ps;\n\tu16 max_idle_period;\n\tbool protected_keep_alive;\n\tbool ftm_responder;\n\tstruct ieee80211_ftm_responder_params *ftmr_params;\n\t \n\tbool nontransmitted;\n\tu8 transmitter_bssid[ETH_ALEN];\n\tu8 bssid_index;\n\tu8 bssid_indicator;\n\tbool ema_ap;\n\tu8 profile_periodicity;\n\tstruct {\n\t\tu32 params;\n\t\tu16 nss_set;\n\t} he_oper;\n\tstruct ieee80211_he_obss_pd he_obss_pd;\n\tstruct cfg80211_he_bss_color he_bss_color;\n\tstruct ieee80211_fils_discovery fils_discovery;\n\tu32 unsol_bcast_probe_resp_interval;\n\tstruct cfg80211_bitrate_mask beacon_tx_rate;\n\tenum ieee80211_ap_reg_power power_type;\n\tstruct ieee80211_tx_pwr_env tx_pwr_env[IEEE80211_TPE_MAX_IE_COUNT];\n\tu8 tx_pwr_env_num;\n\tu8 pwr_reduction;\n\tbool eht_support;\n\tu16 eht_puncturing;\n\n\tbool csa_active;\n\tu16 csa_punct_bitmap;\n\n\tbool mu_mimo_owner;\n\tstruct ieee80211_chanctx_conf __rcu *chanctx_conf;\n\n\tbool color_change_active;\n\tu8 color_change_color;\n\n\tbool ht_ldpc;\n\tbool vht_ldpc;\n\tbool he_ldpc;\n\tbool vht_su_beamformer;\n\tbool vht_su_beamformee;\n\tbool vht_mu_beamformer;\n\tbool vht_mu_beamformee;\n\tbool he_su_beamformer;\n\tbool he_su_beamformee;\n\tbool he_mu_beamformer;\n\tbool he_full_ul_mumimo;\n\tbool eht_su_beamformer;\n\tbool eht_su_beamformee;\n\tbool eht_mu_beamformer;\n};\n\n \nenum mac80211_tx_info_flags {\n\tIEEE80211_TX_CTL_REQ_TX_STATUS\t\t= BIT(0),\n\tIEEE80211_TX_CTL_ASSIGN_SEQ\t\t= BIT(1),\n\tIEEE80211_TX_CTL_NO_ACK\t\t\t= BIT(2),\n\tIEEE80211_TX_CTL_CLEAR_PS_FILT\t\t= BIT(3),\n\tIEEE80211_TX_CTL_FIRST_FRAGMENT\t\t= BIT(4),\n\tIEEE80211_TX_CTL_SEND_AFTER_DTIM\t= BIT(5),\n\tIEEE80211_TX_CTL_AMPDU\t\t\t= BIT(6),\n\tIEEE80211_TX_CTL_INJECTED\t\t= BIT(7),\n\tIEEE80211_TX_STAT_TX_FILTERED\t\t= BIT(8),\n\tIEEE80211_TX_STAT_ACK\t\t\t= BIT(9),\n\tIEEE80211_TX_STAT_AMPDU\t\t\t= BIT(10),\n\tIEEE80211_TX_STAT_AMPDU_NO_BACK\t\t= BIT(11),\n\tIEEE80211_TX_CTL_RATE_CTRL_PROBE\t= BIT(12),\n\tIEEE80211_TX_INTFL_OFFCHAN_TX_OK\t= BIT(13),\n\tIEEE80211_TX_CTL_HW_80211_ENCAP\t\t= BIT(14),\n\tIEEE80211_TX_INTFL_RETRIED\t\t= BIT(15),\n\tIEEE80211_TX_INTFL_DONT_ENCRYPT\t\t= BIT(16),\n\tIEEE80211_TX_CTL_NO_PS_BUFFER\t\t= BIT(17),\n\tIEEE80211_TX_CTL_MORE_FRAMES\t\t= BIT(18),\n\tIEEE80211_TX_INTFL_RETRANSMISSION\t= BIT(19),\n\tIEEE80211_TX_INTFL_MLME_CONN_TX\t\t= BIT(20),\n\tIEEE80211_TX_INTFL_NL80211_FRAME_TX\t= BIT(21),\n\tIEEE80211_TX_CTL_LDPC\t\t\t= BIT(22),\n\tIEEE80211_TX_CTL_STBC\t\t\t= BIT(23) | BIT(24),\n\tIEEE80211_TX_CTL_TX_OFFCHAN\t\t= BIT(25),\n\tIEEE80211_TX_INTFL_TKIP_MIC_FAILURE\t= BIT(26),\n\tIEEE80211_TX_CTL_NO_CCK_RATE\t\t= BIT(27),\n\tIEEE80211_TX_STATUS_EOSP\t\t= BIT(28),\n\tIEEE80211_TX_CTL_USE_MINRATE\t\t= BIT(29),\n\tIEEE80211_TX_CTL_DONTFRAG\t\t= BIT(30),\n\tIEEE80211_TX_STAT_NOACK_TRANSMITTED\t= BIT(31),\n};\n\n#define IEEE80211_TX_CTL_STBC_SHIFT\t\t23\n\n#define IEEE80211_TX_RC_S1G_MCS IEEE80211_TX_RC_VHT_MCS\n\n \nenum mac80211_tx_control_flags {\n\tIEEE80211_TX_CTRL_PORT_CTRL_PROTO\t= BIT(0),\n\tIEEE80211_TX_CTRL_PS_RESPONSE\t\t= BIT(1),\n\tIEEE80211_TX_CTRL_RATE_INJECT\t\t= BIT(2),\n\tIEEE80211_TX_CTRL_AMSDU\t\t\t= BIT(3),\n\tIEEE80211_TX_CTRL_FAST_XMIT\t\t= BIT(4),\n\tIEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP\t= BIT(5),\n\tIEEE80211_TX_INTCFL_NEED_TXPROCESSING\t= BIT(6),\n\tIEEE80211_TX_CTRL_NO_SEQNO\t\t= BIT(7),\n\tIEEE80211_TX_CTRL_DONT_REORDER\t\t= BIT(8),\n\tIEEE80211_TX_CTRL_MCAST_MLO_FIRST_TX\t= BIT(9),\n\tIEEE80211_TX_CTRL_MLO_LINK\t\t= 0xf0000000,\n};\n\n#define IEEE80211_LINK_UNSPECIFIED\t0xf\n#define IEEE80211_TX_CTRL_MLO_LINK_UNSPEC\t\\\n\tu32_encode_bits(IEEE80211_LINK_UNSPECIFIED, \\\n\t\t\tIEEE80211_TX_CTRL_MLO_LINK)\n\n \nenum mac80211_tx_status_flags {\n\tIEEE80211_TX_STATUS_ACK_SIGNAL_VALID = BIT(0),\n};\n\n \n#define IEEE80211_TX_TEMPORARY_FLAGS (IEEE80211_TX_CTL_NO_ACK |\t\t      \\\n\tIEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT |    \\\n\tIEEE80211_TX_CTL_SEND_AFTER_DTIM | IEEE80211_TX_CTL_AMPDU |\t      \\\n\tIEEE80211_TX_STAT_TX_FILTERED |\tIEEE80211_TX_STAT_ACK |\t\t      \\\n\tIEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |\t      \\\n\tIEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_NO_PS_BUFFER |    \\\n\tIEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |\t\t      \\\n\tIEEE80211_TX_CTL_STBC | IEEE80211_TX_STATUS_EOSP)\n\n \nenum mac80211_rate_control_flags {\n\tIEEE80211_TX_RC_USE_RTS_CTS\t\t= BIT(0),\n\tIEEE80211_TX_RC_USE_CTS_PROTECT\t\t= BIT(1),\n\tIEEE80211_TX_RC_USE_SHORT_PREAMBLE\t= BIT(2),\n\n\t \n\tIEEE80211_TX_RC_MCS\t\t\t= BIT(3),\n\tIEEE80211_TX_RC_GREEN_FIELD\t\t= BIT(4),\n\tIEEE80211_TX_RC_40_MHZ_WIDTH\t\t= BIT(5),\n\tIEEE80211_TX_RC_DUP_DATA\t\t= BIT(6),\n\tIEEE80211_TX_RC_SHORT_GI\t\t= BIT(7),\n\tIEEE80211_TX_RC_VHT_MCS\t\t\t= BIT(8),\n\tIEEE80211_TX_RC_80_MHZ_WIDTH\t\t= BIT(9),\n\tIEEE80211_TX_RC_160_MHZ_WIDTH\t\t= BIT(10),\n};\n\n\n \n#define IEEE80211_TX_INFO_DRIVER_DATA_SIZE 40\n\n \n#define IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE 24\n\n \n#define IEEE80211_TX_MAX_RATES\t4\n\n \n#define IEEE80211_TX_RATE_TABLE_SIZE\t4\n\n \nstruct ieee80211_tx_rate {\n\ts8 idx;\n\tu16 count:5,\n\t    flags:11;\n} __packed;\n\n#define IEEE80211_MAX_TX_RETRY\t\t31\n\nstatic inline void ieee80211_rate_set_vht(struct ieee80211_tx_rate *rate,\n\t\t\t\t\t  u8 mcs, u8 nss)\n{\n\tWARN_ON(mcs & ~0xF);\n\tWARN_ON((nss - 1) & ~0x7);\n\trate->idx = ((nss - 1) << 4) | mcs;\n}\n\nstatic inline u8\nieee80211_rate_get_vht_mcs(const struct ieee80211_tx_rate *rate)\n{\n\treturn rate->idx & 0xF;\n}\n\nstatic inline u8\nieee80211_rate_get_vht_nss(const struct ieee80211_tx_rate *rate)\n{\n\treturn (rate->idx >> 4) + 1;\n}\n\n \nstruct ieee80211_tx_info {\n\t \n\tu32 flags;\n\tu32 band:3,\n\t    ack_frame_id:13,\n\t    hw_queue:4,\n\t    tx_time_est:10;\n\t \n\n\tunion {\n\t\tstruct {\n\t\t\tunion {\n\t\t\t\t \n\t\t\t\tstruct {\n\t\t\t\t\tstruct ieee80211_tx_rate rates[\n\t\t\t\t\t\tIEEE80211_TX_MAX_RATES];\n\t\t\t\t\ts8 rts_cts_rate_idx;\n\t\t\t\t\tu8 use_rts:1;\n\t\t\t\t\tu8 use_cts_prot:1;\n\t\t\t\t\tu8 short_preamble:1;\n\t\t\t\t\tu8 skip_table:1;\n\t\t\t\t\t \n\t\t\t\t};\n\t\t\t\t \n\t\t\t\tunsigned long jiffies;\n\t\t\t};\n\t\t\t \n\t\t\tstruct ieee80211_vif *vif;\n\t\t\tstruct ieee80211_key_conf *hw_key;\n\t\t\tu32 flags;\n\t\t\tcodel_time_t enqueue_time;\n\t\t} control;\n\t\tstruct {\n\t\t\tu64 cookie;\n\t\t} ack;\n\t\tstruct {\n\t\t\tstruct ieee80211_tx_rate rates[IEEE80211_TX_MAX_RATES];\n\t\t\ts32 ack_signal;\n\t\t\tu8 ampdu_ack_len;\n\t\t\tu8 ampdu_len;\n\t\t\tu8 antenna;\n\t\t\tu8 pad;\n\t\t\tu16 tx_time;\n\t\t\tu8 flags;\n\t\t\tu8 pad2;\n\t\t\tvoid *status_driver_data[16 / sizeof(void *)];\n\t\t} status;\n\t\tstruct {\n\t\t\tstruct ieee80211_tx_rate driver_rates[\n\t\t\t\tIEEE80211_TX_MAX_RATES];\n\t\t\tu8 pad[4];\n\n\t\t\tvoid *rate_driver_data[\n\t\t\t\tIEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE / sizeof(void *)];\n\t\t};\n\t\tvoid *driver_data[\n\t\t\tIEEE80211_TX_INFO_DRIVER_DATA_SIZE / sizeof(void *)];\n\t};\n};\n\nstatic inline u16\nieee80211_info_set_tx_time_est(struct ieee80211_tx_info *info, u16 tx_time_est)\n{\n\t \n\tinfo->tx_time_est = min_t(u16, tx_time_est, 4095) >> 2;\n\treturn info->tx_time_est << 2;\n}\n\nstatic inline u16\nieee80211_info_get_tx_time_est(struct ieee80211_tx_info *info)\n{\n\treturn info->tx_time_est << 2;\n}\n\n \nstruct ieee80211_rate_status {\n\tstruct rate_info rate_idx;\n\tu8 try_count;\n\tu8 tx_power_idx;\n};\n\n \nstruct ieee80211_tx_status {\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_rate_status *rates;\n\tktime_t ack_hwtstamp;\n\tu8 n_rates;\n\n\tstruct list_head *free_list;\n};\n\n \nstruct ieee80211_scan_ies {\n\tconst u8 *ies[NUM_NL80211_BANDS];\n\tsize_t len[NUM_NL80211_BANDS];\n\tconst u8 *common_ies;\n\tsize_t common_ie_len;\n};\n\n\nstatic inline struct ieee80211_tx_info *IEEE80211_SKB_CB(struct sk_buff *skb)\n{\n\treturn (struct ieee80211_tx_info *)skb->cb;\n}\n\nstatic inline struct ieee80211_rx_status *IEEE80211_SKB_RXCB(struct sk_buff *skb)\n{\n\treturn (struct ieee80211_rx_status *)skb->cb;\n}\n\n \nstatic inline void\nieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)\n{\n\tint i;\n\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=\n\t\t     offsetof(struct ieee80211_tx_info, control.rates));\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=\n\t\t     offsetof(struct ieee80211_tx_info, driver_rates));\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) != 8);\n\t \n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++)\n\t\tinfo->status.rates[i].count = 0;\n\tmemset_after(&info->status, 0, rates);\n}\n\n\n \nenum mac80211_rx_flags {\n\tRX_FLAG_MMIC_ERROR\t\t= BIT(0),\n\tRX_FLAG_DECRYPTED\t\t= BIT(1),\n\tRX_FLAG_MACTIME_PLCP_START\t= BIT(2),\n\tRX_FLAG_MMIC_STRIPPED\t\t= BIT(3),\n\tRX_FLAG_IV_STRIPPED\t\t= BIT(4),\n\tRX_FLAG_FAILED_FCS_CRC\t\t= BIT(5),\n\tRX_FLAG_FAILED_PLCP_CRC \t= BIT(6),\n\tRX_FLAG_MACTIME_START\t\t= BIT(7),\n\tRX_FLAG_NO_SIGNAL_VAL\t\t= BIT(8),\n\tRX_FLAG_AMPDU_DETAILS\t\t= BIT(9),\n\tRX_FLAG_PN_VALIDATED\t\t= BIT(10),\n\tRX_FLAG_DUP_VALIDATED\t\t= BIT(11),\n\tRX_FLAG_AMPDU_LAST_KNOWN\t= BIT(12),\n\tRX_FLAG_AMPDU_IS_LAST\t\t= BIT(13),\n\tRX_FLAG_AMPDU_DELIM_CRC_ERROR\t= BIT(14),\n\tRX_FLAG_AMPDU_DELIM_CRC_KNOWN\t= BIT(15),\n\tRX_FLAG_MACTIME_END\t\t= BIT(16),\n\tRX_FLAG_ONLY_MONITOR\t\t= BIT(17),\n\tRX_FLAG_SKIP_MONITOR\t\t= BIT(18),\n\tRX_FLAG_AMSDU_MORE\t\t= BIT(19),\n\tRX_FLAG_RADIOTAP_TLV_AT_END\t= BIT(20),\n\tRX_FLAG_MIC_STRIPPED\t\t= BIT(21),\n\tRX_FLAG_ALLOW_SAME_PN\t\t= BIT(22),\n\tRX_FLAG_ICV_STRIPPED\t\t= BIT(23),\n\tRX_FLAG_AMPDU_EOF_BIT\t\t= BIT(24),\n\tRX_FLAG_AMPDU_EOF_BIT_KNOWN\t= BIT(25),\n\tRX_FLAG_RADIOTAP_HE\t\t= BIT(26),\n\tRX_FLAG_RADIOTAP_HE_MU\t\t= BIT(27),\n\tRX_FLAG_RADIOTAP_LSIG\t\t= BIT(28),\n\tRX_FLAG_NO_PSDU\t\t\t= BIT(29),\n\tRX_FLAG_8023\t\t\t= BIT(30),\n};\n\n \nenum mac80211_rx_encoding_flags {\n\tRX_ENC_FLAG_SHORTPRE\t\t= BIT(0),\n\tRX_ENC_FLAG_SHORT_GI\t\t= BIT(2),\n\tRX_ENC_FLAG_HT_GF\t\t= BIT(3),\n\tRX_ENC_FLAG_STBC_MASK\t\t= BIT(4) | BIT(5),\n\tRX_ENC_FLAG_LDPC\t\t= BIT(6),\n\tRX_ENC_FLAG_BF\t\t\t= BIT(7),\n};\n\n#define RX_ENC_FLAG_STBC_SHIFT\t\t4\n\nenum mac80211_rx_encoding {\n\tRX_ENC_LEGACY = 0,\n\tRX_ENC_HT,\n\tRX_ENC_VHT,\n\tRX_ENC_HE,\n\tRX_ENC_EHT,\n};\n\n \nstruct ieee80211_rx_status {\n\tu64 mactime;\n\tunion {\n\t\tu64 boottime_ns;\n\t\tktime_t ack_tx_hwtstamp;\n\t};\n\tu32 device_timestamp;\n\tu32 ampdu_reference;\n\tu32 flag;\n\tu16 freq: 13, freq_offset: 1;\n\tu8 enc_flags;\n\tu8 encoding:3, bw:4;\n\tunion {\n\t\tstruct {\n\t\t\tu8 he_ru:3;\n\t\t\tu8 he_gi:2;\n\t\t\tu8 he_dcm:1;\n\t\t};\n\t\tstruct {\n\t\t\tu8 ru:4;\n\t\t\tu8 gi:2;\n\t\t} eht;\n\t};\n\tu8 rate_idx;\n\tu8 nss;\n\tu8 rx_flags;\n\tu8 band;\n\tu8 antenna;\n\ts8 signal;\n\tu8 chains;\n\ts8 chain_signal[IEEE80211_MAX_CHAINS];\n\tu8 ampdu_delimiter_crc;\n\tu8 zero_length_psdu_type;\n\tu8 link_valid:1, link_id:4;\n};\n\nstatic inline u32\nieee80211_rx_status_to_khz(struct ieee80211_rx_status *rx_status)\n{\n\treturn MHZ_TO_KHZ(rx_status->freq) +\n\t       (rx_status->freq_offset ? 500 : 0);\n}\n\n \nenum ieee80211_conf_flags {\n\tIEEE80211_CONF_MONITOR\t\t= (1<<0),\n\tIEEE80211_CONF_PS\t\t= (1<<1),\n\tIEEE80211_CONF_IDLE\t\t= (1<<2),\n\tIEEE80211_CONF_OFFCHANNEL\t= (1<<3),\n};\n\n\n \nenum ieee80211_conf_changed {\n\tIEEE80211_CONF_CHANGE_SMPS\t\t= BIT(1),\n\tIEEE80211_CONF_CHANGE_LISTEN_INTERVAL\t= BIT(2),\n\tIEEE80211_CONF_CHANGE_MONITOR\t\t= BIT(3),\n\tIEEE80211_CONF_CHANGE_PS\t\t= BIT(4),\n\tIEEE80211_CONF_CHANGE_POWER\t\t= BIT(5),\n\tIEEE80211_CONF_CHANGE_CHANNEL\t\t= BIT(6),\n\tIEEE80211_CONF_CHANGE_RETRY_LIMITS\t= BIT(7),\n\tIEEE80211_CONF_CHANGE_IDLE\t\t= BIT(8),\n};\n\n \nenum ieee80211_smps_mode {\n\tIEEE80211_SMPS_AUTOMATIC,\n\tIEEE80211_SMPS_OFF,\n\tIEEE80211_SMPS_STATIC,\n\tIEEE80211_SMPS_DYNAMIC,\n\n\t \n\tIEEE80211_SMPS_NUM_MODES,\n};\n\n \nstruct ieee80211_conf {\n\tu32 flags;\n\tint power_level, dynamic_ps_timeout;\n\n\tu16 listen_interval;\n\tu8 ps_dtim_period;\n\n\tu8 long_frame_max_tx_count, short_frame_max_tx_count;\n\n\tstruct cfg80211_chan_def chandef;\n\tbool radar_enabled;\n\tenum ieee80211_smps_mode smps_mode;\n};\n\n \nstruct ieee80211_channel_switch {\n\tu64 timestamp;\n\tu32 device_timestamp;\n\tbool block_tx;\n\tstruct cfg80211_chan_def chandef;\n\tu8 count;\n\tu32 delay;\n};\n\n \nenum ieee80211_vif_flags {\n\tIEEE80211_VIF_BEACON_FILTER\t\t= BIT(0),\n\tIEEE80211_VIF_SUPPORTS_CQM_RSSI\t\t= BIT(1),\n\tIEEE80211_VIF_SUPPORTS_UAPSD\t\t= BIT(2),\n\tIEEE80211_VIF_GET_NOA_UPDATE\t\t= BIT(3),\n\tIEEE80211_VIF_DISABLE_SMPS_OVERRIDE\t= BIT(4),\n};\n\n\n \n\nenum ieee80211_offload_flags {\n\tIEEE80211_OFFLOAD_ENCAP_ENABLED\t\t= BIT(0),\n\tIEEE80211_OFFLOAD_ENCAP_4ADDR\t\t= BIT(1),\n\tIEEE80211_OFFLOAD_DECAP_ENABLED\t\t= BIT(2),\n};\n\n \nstruct ieee80211_vif_cfg {\n\t \n\tbool assoc, ibss_joined;\n\tbool ibss_creator;\n\tbool ps;\n\tu16 aid;\n\tu16 eml_cap;\n\tu16 eml_med_sync_delay;\n\n\t__be32 arp_addr_list[IEEE80211_BSS_ARP_ADDR_LIST_LEN];\n\tint arp_addr_cnt;\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tsize_t ssid_len;\n\tbool s1g;\n\tbool idle;\n\tu8 ap_addr[ETH_ALEN] __aligned(2);\n};\n\n \nstruct ieee80211_vif {\n\tenum nl80211_iftype type;\n\tstruct ieee80211_vif_cfg cfg;\n\tstruct ieee80211_bss_conf bss_conf;\n\tstruct ieee80211_bss_conf __rcu *link_conf[IEEE80211_MLD_MAX_NUM_LINKS];\n\tu16 valid_links, active_links, dormant_links;\n\tu8 addr[ETH_ALEN] __aligned(2);\n\tbool p2p;\n\n\tu8 cab_queue;\n\tu8 hw_queue[IEEE80211_NUM_ACS];\n\n\tstruct ieee80211_txq *txq;\n\n\tnetdev_features_t netdev_features;\n\tu32 driver_flags;\n\tu32 offload_flags;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct dentry *debugfs_dir;\n#endif\n\n\tbool probe_req_reg;\n\tbool rx_mcast_action_reg;\n\n\tstruct ieee80211_vif *mbssid_tx_vif;\n\n\t \n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n \nstatic inline u16 ieee80211_vif_usable_links(const struct ieee80211_vif *vif)\n{\n\treturn vif->valid_links & ~vif->dormant_links;\n}\n\n \nstatic inline bool ieee80211_vif_is_mld(const struct ieee80211_vif *vif)\n{\n\t \n\treturn vif->valid_links != 0;\n}\n\n#define for_each_vif_active_link(vif, link, link_id)\t\t\t\t\\\n\tfor (link_id = 0; link_id < ARRAY_SIZE((vif)->link_conf); link_id++)\t\\\n\t\tif ((!(vif)->active_links ||\t\t\t\t\t\\\n\t\t     (vif)->active_links & BIT(link_id)) &&\t\t\t\\\n\t\t    (link = rcu_dereference((vif)->link_conf[link_id])))\n\nstatic inline bool ieee80211_vif_is_mesh(struct ieee80211_vif *vif)\n{\n#ifdef CONFIG_MAC80211_MESH\n\treturn vif->type == NL80211_IFTYPE_MESH_POINT;\n#endif\n\treturn false;\n}\n\n \nstruct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev);\n\n \nstruct wireless_dev *ieee80211_vif_to_wdev(struct ieee80211_vif *vif);\n\n \nstatic inline bool lockdep_vif_mutex_held(struct ieee80211_vif *vif)\n{\n\treturn lockdep_is_held(&ieee80211_vif_to_wdev(vif)->mtx);\n}\n\n#define link_conf_dereference_protected(vif, link_id)\t\t\\\n\trcu_dereference_protected((vif)->link_conf[link_id],\t\\\n\t\t\t\t  lockdep_vif_mutex_held(vif))\n\n#define link_conf_dereference_check(vif, link_id)\t\t\\\n\trcu_dereference_check((vif)->link_conf[link_id],\t\\\n\t\t\t      lockdep_vif_mutex_held(vif))\n\n \nenum ieee80211_key_flags {\n\tIEEE80211_KEY_FLAG_GENERATE_IV_MGMT\t= BIT(0),\n\tIEEE80211_KEY_FLAG_GENERATE_IV\t\t= BIT(1),\n\tIEEE80211_KEY_FLAG_GENERATE_MMIC\t= BIT(2),\n\tIEEE80211_KEY_FLAG_PAIRWISE\t\t= BIT(3),\n\tIEEE80211_KEY_FLAG_SW_MGMT_TX\t\t= BIT(4),\n\tIEEE80211_KEY_FLAG_PUT_IV_SPACE\t\t= BIT(5),\n\tIEEE80211_KEY_FLAG_RX_MGMT\t\t= BIT(6),\n\tIEEE80211_KEY_FLAG_RESERVE_TAILROOM\t= BIT(7),\n\tIEEE80211_KEY_FLAG_PUT_MIC_SPACE\t= BIT(8),\n\tIEEE80211_KEY_FLAG_NO_AUTO_TX\t\t= BIT(9),\n\tIEEE80211_KEY_FLAG_GENERATE_MMIE\t= BIT(10),\n};\n\n \nstruct ieee80211_key_conf {\n\tatomic64_t tx_pn;\n\tu32 cipher;\n\tu8 icv_len;\n\tu8 iv_len;\n\tu8 hw_key_idx;\n\ts8 keyidx;\n\tu16 flags;\n\ts8 link_id;\n\tu8 keylen;\n\tu8 key[];\n};\n\n#define IEEE80211_MAX_PN_LEN\t16\n\n#define TKIP_PN_TO_IV16(pn) ((u16)(pn & 0xffff))\n#define TKIP_PN_TO_IV32(pn) ((u32)((pn >> 16) & 0xffffffff))\n\n \nstruct ieee80211_key_seq {\n\tunion {\n\t\tstruct {\n\t\t\tu32 iv32;\n\t\t\tu16 iv16;\n\t\t} tkip;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} ccmp;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} aes_cmac;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} aes_gmac;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} gcmp;\n\t\tstruct {\n\t\t\tu8 seq[IEEE80211_MAX_PN_LEN];\n\t\t\tu8 seq_len;\n\t\t} hw;\n\t};\n};\n\n \nenum set_key_cmd {\n\tSET_KEY, DISABLE_KEY,\n};\n\n \nenum ieee80211_sta_state {\n\t \n\tIEEE80211_STA_NOTEXIST,\n\tIEEE80211_STA_NONE,\n\tIEEE80211_STA_AUTH,\n\tIEEE80211_STA_ASSOC,\n\tIEEE80211_STA_AUTHORIZED,\n};\n\n \nenum ieee80211_sta_rx_bandwidth {\n\tIEEE80211_STA_RX_BW_20 = 0,\n\tIEEE80211_STA_RX_BW_40,\n\tIEEE80211_STA_RX_BW_80,\n\tIEEE80211_STA_RX_BW_160,\n\tIEEE80211_STA_RX_BW_320,\n};\n\n \nstruct ieee80211_sta_rates {\n\tstruct rcu_head rcu_head;\n\tstruct {\n\t\ts8 idx;\n\t\tu8 count;\n\t\tu8 count_cts;\n\t\tu8 count_rts;\n\t\tu16 flags;\n\t} rate[IEEE80211_TX_RATE_TABLE_SIZE];\n};\n\n \nstruct ieee80211_sta_txpwr {\n\ts16 power;\n\tenum nl80211_tx_power_setting type;\n};\n\n \nstruct ieee80211_sta_aggregates {\n\tu16 max_amsdu_len;\n\n\tu16 max_rc_amsdu_len;\n\tu16 max_tid_amsdu_len[IEEE80211_NUM_TIDS];\n};\n\n \nstruct ieee80211_link_sta {\n\tstruct ieee80211_sta *sta;\n\n\tu8 addr[ETH_ALEN];\n\tu8 link_id;\n\tenum ieee80211_smps_mode smps_mode;\n\n\tu32 supp_rates[NUM_NL80211_BANDS];\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tstruct ieee80211_sta_he_cap he_cap;\n\tstruct ieee80211_he_6ghz_capa he_6ghz_capa;\n\tstruct ieee80211_sta_eht_cap eht_cap;\n\n\tstruct ieee80211_sta_aggregates agg;\n\n\tu8 rx_nss;\n\tenum ieee80211_sta_rx_bandwidth bandwidth;\n\tstruct ieee80211_sta_txpwr txpwr;\n};\n\n \nstruct ieee80211_sta {\n\tu8 addr[ETH_ALEN];\n\tu16 aid;\n\tu16 max_rx_aggregation_subframes;\n\tbool wme;\n\tu8 uapsd_queues;\n\tu8 max_sp;\n\tstruct ieee80211_sta_rates __rcu *rates;\n\tbool tdls;\n\tbool tdls_initiator;\n\tbool mfp;\n\tbool mlo;\n\tu8 max_amsdu_subframes;\n\n\tstruct ieee80211_sta_aggregates *cur;\n\n\tbool support_p2p_ps;\n\n\tstruct ieee80211_txq *txq[IEEE80211_NUM_TIDS + 1];\n\n\tu16 valid_links;\n\tstruct ieee80211_link_sta deflink;\n\tstruct ieee80211_link_sta __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];\n\n\t \n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n#ifdef CONFIG_LOCKDEP\nbool lockdep_sta_mutex_held(struct ieee80211_sta *pubsta);\n#else\nstatic inline bool lockdep_sta_mutex_held(struct ieee80211_sta *pubsta)\n{\n\treturn true;\n}\n#endif\n\n#define link_sta_dereference_protected(sta, link_id)\t\t\\\n\trcu_dereference_protected((sta)->link[link_id],\t\t\\\n\t\t\t\t  lockdep_sta_mutex_held(sta))\n\n#define link_sta_dereference_check(sta, link_id)\t\t\\\n\trcu_dereference_check((sta)->link[link_id],\t\t\\\n\t\t\t      lockdep_sta_mutex_held(sta))\n\n#define for_each_sta_active_link(vif, sta, link_sta, link_id)\t\t\t\\\n\tfor (link_id = 0; link_id < ARRAY_SIZE((sta)->link); link_id++)\t\t\\\n\t\tif ((!(vif)->active_links ||\t\t\t\t\t\\\n\t\t     (vif)->active_links & BIT(link_id)) &&\t\t\t\\\n\t\t    ((link_sta) = link_sta_dereference_protected(sta, link_id)))\n\n \nenum sta_notify_cmd {\n\tSTA_NOTIFY_SLEEP, STA_NOTIFY_AWAKE,\n};\n\n \nstruct ieee80211_tx_control {\n\tstruct ieee80211_sta *sta;\n};\n\n \nstruct ieee80211_txq {\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_sta *sta;\n\tu8 tid;\n\tu8 ac;\n\n\t \n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n \nenum ieee80211_hw_flags {\n\tIEEE80211_HW_HAS_RATE_CONTROL,\n\tIEEE80211_HW_RX_INCLUDES_FCS,\n\tIEEE80211_HW_HOST_BROADCAST_PS_BUFFERING,\n\tIEEE80211_HW_SIGNAL_UNSPEC,\n\tIEEE80211_HW_SIGNAL_DBM,\n\tIEEE80211_HW_NEED_DTIM_BEFORE_ASSOC,\n\tIEEE80211_HW_SPECTRUM_MGMT,\n\tIEEE80211_HW_AMPDU_AGGREGATION,\n\tIEEE80211_HW_SUPPORTS_PS,\n\tIEEE80211_HW_PS_NULLFUNC_STACK,\n\tIEEE80211_HW_SUPPORTS_DYNAMIC_PS,\n\tIEEE80211_HW_MFP_CAPABLE,\n\tIEEE80211_HW_WANT_MONITOR_VIF,\n\tIEEE80211_HW_NO_AUTO_VIF,\n\tIEEE80211_HW_SW_CRYPTO_CONTROL,\n\tIEEE80211_HW_SUPPORT_FAST_XMIT,\n\tIEEE80211_HW_REPORTS_TX_ACK_STATUS,\n\tIEEE80211_HW_CONNECTION_MONITOR,\n\tIEEE80211_HW_QUEUE_CONTROL,\n\tIEEE80211_HW_SUPPORTS_PER_STA_GTK,\n\tIEEE80211_HW_AP_LINK_PS,\n\tIEEE80211_HW_TX_AMPDU_SETUP_IN_HW,\n\tIEEE80211_HW_SUPPORTS_RC_TABLE,\n\tIEEE80211_HW_P2P_DEV_ADDR_FOR_INTF,\n\tIEEE80211_HW_TIMING_BEACON_ONLY,\n\tIEEE80211_HW_SUPPORTS_HT_CCK_RATES,\n\tIEEE80211_HW_CHANCTX_STA_CSA,\n\tIEEE80211_HW_SUPPORTS_CLONED_SKBS,\n\tIEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS,\n\tIEEE80211_HW_TDLS_WIDER_BW,\n\tIEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU,\n\tIEEE80211_HW_BEACON_TX_STATUS,\n\tIEEE80211_HW_NEEDS_UNIQUE_STA_ADDR,\n\tIEEE80211_HW_SUPPORTS_REORDERING_BUFFER,\n\tIEEE80211_HW_USES_RSS,\n\tIEEE80211_HW_TX_AMSDU,\n\tIEEE80211_HW_TX_FRAG_LIST,\n\tIEEE80211_HW_REPORTS_LOW_ACK,\n\tIEEE80211_HW_SUPPORTS_TX_FRAG,\n\tIEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA,\n\tIEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP,\n\tIEEE80211_HW_DOESNT_SUPPORT_QOS_NDP,\n\tIEEE80211_HW_BUFF_MMPDU_TXQ,\n\tIEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW,\n\tIEEE80211_HW_STA_MMPDU_TXQ,\n\tIEEE80211_HW_TX_STATUS_NO_AMPDU_LEN,\n\tIEEE80211_HW_SUPPORTS_MULTI_BSSID,\n\tIEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID,\n\tIEEE80211_HW_AMPDU_KEYBORDER_SUPPORT,\n\tIEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD,\n\tIEEE80211_HW_SUPPORTS_RX_DECAP_OFFLOAD,\n\tIEEE80211_HW_SUPPORTS_CONC_MON_RX_DECAP,\n\tIEEE80211_HW_DETECTS_COLOR_COLLISION,\n\tIEEE80211_HW_MLO_MCAST_MULTI_LINK_TX,\n\n\t \n\tNUM_IEEE80211_HW_FLAGS\n};\n\n \nstruct ieee80211_hw {\n\tstruct ieee80211_conf conf;\n\tstruct wiphy *wiphy;\n\tconst char *rate_control_algorithm;\n\tvoid *priv;\n\tunsigned long flags[BITS_TO_LONGS(NUM_IEEE80211_HW_FLAGS)];\n\tunsigned int extra_tx_headroom;\n\tunsigned int extra_beacon_tailroom;\n\tint vif_data_size;\n\tint sta_data_size;\n\tint chanctx_data_size;\n\tint txq_data_size;\n\tu16 queues;\n\tu16 max_listen_interval;\n\ts8 max_signal;\n\tu8 max_rates;\n\tu8 max_report_rates;\n\tu8 max_rate_tries;\n\tu16 max_rx_aggregation_subframes;\n\tu16 max_tx_aggregation_subframes;\n\tu8 max_tx_fragments;\n\tu8 offchannel_tx_hw_queue;\n\tu8 radiotap_mcs_details;\n\tu16 radiotap_vht_details;\n\tstruct {\n\t\tint units_pos;\n\t\ts16 accuracy;\n\t} radiotap_timestamp;\n\tnetdev_features_t netdev_features;\n\tu8 uapsd_queues;\n\tu8 uapsd_max_sp_len;\n\tu8 max_nan_de_entries;\n\tu8 tx_sk_pacing_shift;\n\tu8 weight_multiplier;\n\tu32 max_mtu;\n\tconst s8 *tx_power_levels;\n\tu8 max_txpwr_levels_idx;\n};\n\nstatic inline bool _ieee80211_hw_check(struct ieee80211_hw *hw,\n\t\t\t\t       enum ieee80211_hw_flags flg)\n{\n\treturn test_bit(flg, hw->flags);\n}\n#define ieee80211_hw_check(hw, flg)\t_ieee80211_hw_check(hw, IEEE80211_HW_##flg)\n\nstatic inline void _ieee80211_hw_set(struct ieee80211_hw *hw,\n\t\t\t\t     enum ieee80211_hw_flags flg)\n{\n\treturn __set_bit(flg, hw->flags);\n}\n#define ieee80211_hw_set(hw, flg)\t_ieee80211_hw_set(hw, IEEE80211_HW_##flg)\n\n \nstruct ieee80211_scan_request {\n\tstruct ieee80211_scan_ies ies;\n\n\t \n\tstruct cfg80211_scan_request req;\n};\n\n \nstruct ieee80211_tdls_ch_sw_params {\n\tstruct ieee80211_sta *sta;\n\tstruct cfg80211_chan_def *chandef;\n\tu8 action_code;\n\tu32 status;\n\tu32 timestamp;\n\tu16 switch_time;\n\tu16 switch_timeout;\n\tstruct sk_buff *tmpl_skb;\n\tu32 ch_sw_tm_ie;\n};\n\n \nstruct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy);\n\n \nstatic inline void SET_IEEE80211_DEV(struct ieee80211_hw *hw, struct device *dev)\n{\n\tset_wiphy_dev(hw->wiphy, dev);\n}\n\n \nstatic inline void SET_IEEE80211_PERM_ADDR(struct ieee80211_hw *hw, const u8 *addr)\n{\n\tmemcpy(hw->wiphy->perm_addr, addr, ETH_ALEN);\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_tx_rate(const struct ieee80211_hw *hw,\n\t\t      const struct ieee80211_tx_info *c)\n{\n\tif (WARN_ON_ONCE(c->control.rates[0].idx < 0))\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rates[0].idx];\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_rts_cts_rate(const struct ieee80211_hw *hw,\n\t\t\t   const struct ieee80211_tx_info *c)\n{\n\tif (c->control.rts_cts_rate_idx < 0)\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rts_cts_rate_idx];\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_alt_retry_rate(const struct ieee80211_hw *hw,\n\t\t\t     const struct ieee80211_tx_info *c, int idx)\n{\n\tif (c->control.rates[idx + 1].idx < 0)\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rates[idx + 1].idx];\n}\n\n \nvoid ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \nenum ieee80211_filter_flags {\n\tFIF_ALLMULTI\t\t= 1<<1,\n\tFIF_FCSFAIL\t\t= 1<<2,\n\tFIF_PLCPFAIL\t\t= 1<<3,\n\tFIF_BCN_PRBRESP_PROMISC\t= 1<<4,\n\tFIF_CONTROL\t\t= 1<<5,\n\tFIF_OTHER_BSS\t\t= 1<<6,\n\tFIF_PSPOLL\t\t= 1<<7,\n\tFIF_PROBE_REQ\t\t= 1<<8,\n\tFIF_MCAST_ACTION\t= 1<<9,\n};\n\n \nenum ieee80211_ampdu_mlme_action {\n\tIEEE80211_AMPDU_RX_START,\n\tIEEE80211_AMPDU_RX_STOP,\n\tIEEE80211_AMPDU_TX_START,\n\tIEEE80211_AMPDU_TX_STOP_CONT,\n\tIEEE80211_AMPDU_TX_STOP_FLUSH,\n\tIEEE80211_AMPDU_TX_STOP_FLUSH_CONT,\n\tIEEE80211_AMPDU_TX_OPERATIONAL,\n};\n\n#define IEEE80211_AMPDU_TX_START_IMMEDIATE 1\n#define IEEE80211_AMPDU_TX_START_DELAY_ADDBA 2\n\n \nstruct ieee80211_ampdu_params {\n\tenum ieee80211_ampdu_mlme_action action;\n\tstruct ieee80211_sta *sta;\n\tu16 tid;\n\tu16 ssn;\n\tu16 buf_size;\n\tbool amsdu;\n\tu16 timeout;\n};\n\n \nenum ieee80211_frame_release_type {\n\tIEEE80211_FRAME_RELEASE_PSPOLL,\n\tIEEE80211_FRAME_RELEASE_UAPSD,\n};\n\n \nenum ieee80211_rate_control_changed {\n\tIEEE80211_RC_BW_CHANGED\t\t= BIT(0),\n\tIEEE80211_RC_SMPS_CHANGED\t= BIT(1),\n\tIEEE80211_RC_SUPP_RATES_CHANGED\t= BIT(2),\n\tIEEE80211_RC_NSS_CHANGED\t= BIT(3),\n};\n\n \nenum ieee80211_roc_type {\n\tIEEE80211_ROC_TYPE_NORMAL = 0,\n\tIEEE80211_ROC_TYPE_MGMT_TX,\n};\n\n \nenum ieee80211_reconfig_type {\n\tIEEE80211_RECONFIG_TYPE_RESTART,\n\tIEEE80211_RECONFIG_TYPE_SUSPEND,\n};\n\n \nstruct ieee80211_prep_tx_info {\n\tu16 duration;\n\tu16 subtype;\n\tu8 success:1;\n};\n\n \nstruct ieee80211_ops {\n\tvoid (*tx)(struct ieee80211_hw *hw,\n\t\t   struct ieee80211_tx_control *control,\n\t\t   struct sk_buff *skb);\n\tint (*start)(struct ieee80211_hw *hw);\n\tvoid (*stop)(struct ieee80211_hw *hw);\n#ifdef CONFIG_PM\n\tint (*suspend)(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);\n\tint (*resume)(struct ieee80211_hw *hw);\n\tvoid (*set_wakeup)(struct ieee80211_hw *hw, bool enabled);\n#endif\n\tint (*add_interface)(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif);\n\tint (*change_interface)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tenum nl80211_iftype new_type, bool p2p);\n\tvoid (*remove_interface)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif);\n\tint (*config)(struct ieee80211_hw *hw, u32 changed);\n\tvoid (*bss_info_changed)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *info,\n\t\t\t\t u64 changed);\n\tvoid (*vif_cfg_changed)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tu64 changed);\n\tvoid (*link_info_changed)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_bss_conf *info,\n\t\t\t\t  u64 changed);\n\n\tint (*start_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_bss_conf *link_conf);\n\tvoid (*stop_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_bss_conf *link_conf);\n\n\tu64 (*prepare_multicast)(struct ieee80211_hw *hw,\n\t\t\t\t struct netdev_hw_addr_list *mc_list);\n\tvoid (*configure_filter)(struct ieee80211_hw *hw,\n\t\t\t\t unsigned int changed_flags,\n\t\t\t\t unsigned int *total_flags,\n\t\t\t\t u64 multicast);\n\tvoid (*config_iface_filter)(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    unsigned int filter_flags,\n\t\t\t\t    unsigned int changed_flags);\n\tint (*set_tim)(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       bool set);\n\tint (*set_key)(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t       struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t       struct ieee80211_key_conf *key);\n\tvoid (*update_tkip_key)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_key_conf *conf,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tu32 iv32, u16 *phase1key);\n\tvoid (*set_rekey_data)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct cfg80211_gtk_rekey_data *data);\n\tvoid (*set_default_unicast_key)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif, int idx);\n\tint (*hw_scan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_scan_request *req);\n\tvoid (*cancel_hw_scan)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif);\n\tint (*sched_scan_start)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct cfg80211_sched_scan_request *req,\n\t\t\t\tstruct ieee80211_scan_ies *ies);\n\tint (*sched_scan_stop)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif);\n\tvoid (*sw_scan_start)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      const u8 *mac_addr);\n\tvoid (*sw_scan_complete)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif);\n\tint (*get_stats)(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_low_level_stats *stats);\n\tvoid (*get_key_seq)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_key_conf *key,\n\t\t\t    struct ieee80211_key_seq *seq);\n\tint (*set_frag_threshold)(struct ieee80211_hw *hw, u32 value);\n\tint (*set_rts_threshold)(struct ieee80211_hw *hw, u32 value);\n\tint (*sta_add)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta);\n\tint (*sta_remove)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta);\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tvoid (*link_add_debugfs)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *link_conf,\n\t\t\t\t struct dentry *dir);\n\tvoid (*sta_add_debugfs)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tstruct dentry *dir);\n\tvoid (*link_sta_add_debugfs)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_link_sta *link_sta,\n\t\t\t\t     struct dentry *dir);\n#endif\n\tvoid (*sta_notify)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tenum sta_notify_cmd, struct ieee80211_sta *sta);\n\tint (*sta_set_txpwr)(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta);\n\tint (*sta_state)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t enum ieee80211_sta_state old_state,\n\t\t\t enum ieee80211_sta_state new_state);\n\tvoid (*sta_pre_rcu_remove)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta);\n\tvoid (*sta_rc_update)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      u32 changed);\n\tvoid (*sta_rate_tbl_update)(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta);\n\tvoid (*sta_statistics)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct station_info *sinfo);\n\tint (*conf_tx)(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif,\n\t\t       unsigned int link_id, u16 ac,\n\t\t       const struct ieee80211_tx_queue_params *params);\n\tu64 (*get_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tvoid (*set_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tu64 tsf);\n\tvoid (*offset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   s64 offset);\n\tvoid (*reset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tint (*tx_last_beacon)(struct ieee80211_hw *hw);\n\n\t \n\tint (*ampdu_action)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_ampdu_params *params);\n\tint (*get_survey)(struct ieee80211_hw *hw, int idx,\n\t\tstruct survey_info *survey);\n\tvoid (*rfkill_poll)(struct ieee80211_hw *hw);\n\tvoid (*set_coverage_class)(struct ieee80211_hw *hw, s16 coverage_class);\n#ifdef CONFIG_NL80211_TESTMODE\n\tint (*testmode_cmd)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    void *data, int len);\n\tint (*testmode_dump)(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb,\n\t\t\t     void *data, int len);\n#endif\n\tvoid (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t      u32 queues, bool drop);\n\tvoid (*flush_sta)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta);\n\tvoid (*channel_switch)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_channel_switch *ch_switch);\n\tint (*set_antenna)(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);\n\tint (*get_antenna)(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);\n\n\tint (*remain_on_channel)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_channel *chan,\n\t\t\t\t int duration,\n\t\t\t\t enum ieee80211_roc_type type);\n\tint (*cancel_remain_on_channel)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif);\n\tint (*set_ringparam)(struct ieee80211_hw *hw, u32 tx, u32 rx);\n\tvoid (*get_ringparam)(struct ieee80211_hw *hw,\n\t\t\t      u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);\n\tbool (*tx_frames_pending)(struct ieee80211_hw *hw);\n\tint (*set_bitrate_mask)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t\tconst struct cfg80211_bitrate_mask *mask);\n\tvoid (*event_callback)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       const struct ieee80211_event *event);\n\n\tvoid (*allow_buffered_frames)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      u16 tids, int num_frames,\n\t\t\t\t      enum ieee80211_frame_release_type reason,\n\t\t\t\t      bool more_data);\n\tvoid (*release_buffered_frames)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tu16 tids, int num_frames,\n\t\t\t\t\tenum ieee80211_frame_release_type reason,\n\t\t\t\t\tbool more_data);\n\n\tint\t(*get_et_sset_count)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif, int sset);\n\tvoid\t(*get_et_stats)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ethtool_stats *stats, u64 *data);\n\tvoid\t(*get_et_strings)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  u32 sset, u8 *data);\n\n\tvoid\t(*mgd_prepare_tx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_prep_tx_info *info);\n\tvoid\t(*mgd_complete_tx)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_prep_tx_info *info);\n\n\tvoid\t(*mgd_protect_tdls_discover)(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif);\n\n\tint (*add_chanctx)(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_chanctx_conf *ctx);\n\tvoid (*remove_chanctx)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_chanctx_conf *ctx);\n\tvoid (*change_chanctx)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_chanctx_conf *ctx,\n\t\t\t       u32 changed);\n\tint (*assign_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_bss_conf *link_conf,\n\t\t\t\t  struct ieee80211_chanctx_conf *ctx);\n\tvoid (*unassign_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *link_conf,\n\t\t\t\t     struct ieee80211_chanctx_conf *ctx);\n\tint (*switch_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\t  int n_vifs,\n\t\t\t\t  enum ieee80211_chanctx_switch_mode mode);\n\n\tvoid (*reconfig_complete)(struct ieee80211_hw *hw,\n\t\t\t\t  enum ieee80211_reconfig_type reconfig_type);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tvoid (*ipv6_addr_change)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct inet6_dev *idev);\n#endif\n\tvoid (*channel_switch_beacon)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct cfg80211_chan_def *chandef);\n\tint (*pre_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_channel_switch *ch_switch);\n\n\tint (*post_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif);\n\tvoid (*abort_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif);\n\tvoid (*channel_switch_rx_beacon)(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_channel_switch *ch_switch);\n\n\tint (*join_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tvoid (*leave_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tu32 (*get_expected_throughput)(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_sta *sta);\n\tint (*get_txpower)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   int *dbm);\n\n\tint (*tdls_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta, u8 oper_class,\n\t\t\t\t   struct cfg80211_chan_def *chandef,\n\t\t\t\t   struct sk_buff *tmpl_skb, u32 ch_sw_tm_ie);\n\tvoid (*tdls_cancel_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_sta *sta);\n\tvoid (*tdls_recv_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_tdls_ch_sw_params *params);\n\n\tvoid (*wake_tx_queue)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_txq *txq);\n\tvoid (*sync_rx_queues)(struct ieee80211_hw *hw);\n\n\tint (*start_nan)(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct cfg80211_nan_conf *conf);\n\tint (*stop_nan)(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif);\n\tint (*nan_change_conf)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct cfg80211_nan_conf *conf, u32 changes);\n\tint (*add_nan_func)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    const struct cfg80211_nan_func *nan_func);\n\tvoid (*del_nan_func)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    u8 instance_id);\n\tbool (*can_aggregate_in_amsdu)(struct ieee80211_hw *hw,\n\t\t\t\t       struct sk_buff *head,\n\t\t\t\t       struct sk_buff *skb);\n\tint (*get_ftm_responder_stats)(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct cfg80211_ftm_responder_stats *ftm_stats);\n\tint (*start_pmsr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct cfg80211_pmsr_request *request);\n\tvoid (*abort_pmsr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct cfg80211_pmsr_request *request);\n\tint (*set_tid_config)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      struct cfg80211_tid_config *tid_conf);\n\tint (*reset_tid_config)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta, u8 tids);\n\tvoid (*update_vif_offload)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif);\n\tvoid (*sta_set_4addr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta, bool enabled);\n\tint (*set_sar_specs)(struct ieee80211_hw *hw,\n\t\t\t     const struct cfg80211_sar_specs *sar);\n\tvoid (*sta_set_decap_offload)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta, bool enabled);\n\tvoid (*add_twt_setup)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      struct ieee80211_twt_setup *twt);\n\tvoid (*twt_teardown_request)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_sta *sta, u8 flowid);\n\tint (*set_radar_background)(struct ieee80211_hw *hw,\n\t\t\t\t    struct cfg80211_chan_def *chandef);\n\tint (*net_fill_forward_path)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     struct net_device_path_ctx *ctx,\n\t\t\t\t     struct net_device_path *path);\n\tint (*change_vif_links)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tu16 old_links, u16 new_links,\n\t\t\t\tstruct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS]);\n\tint (*change_sta_links)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tu16 old_links, u16 new_links);\n\tint (*set_hw_timestamp)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct cfg80211_set_hw_timestamp *hwts);\n\tint (*net_setup_tc)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct net_device *dev,\n\t\t\t    enum tc_setup_type type,\n\t\t\t    void *type_data);\n};\n\n \nstruct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,\n\t\t\t\t\t   const struct ieee80211_ops *ops,\n\t\t\t\t\t   const char *requested_name);\n\n \nstatic inline\nstruct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,\n\t\t\t\t\tconst struct ieee80211_ops *ops)\n{\n\treturn ieee80211_alloc_hw_nm(priv_data_len, ops, NULL);\n}\n\n \nint ieee80211_register_hw(struct ieee80211_hw *hw);\n\n \nstruct ieee80211_tpt_blink {\n\tint throughput;\n\tint blink_time;\n};\n\n \nenum ieee80211_tpt_led_trigger_flags {\n\tIEEE80211_TPT_LEDTRIG_FL_RADIO\t\t= BIT(0),\n\tIEEE80211_TPT_LEDTRIG_FL_WORK\t\t= BIT(1),\n\tIEEE80211_TPT_LEDTRIG_FL_CONNECTED\t= BIT(2),\n};\n\n#ifdef CONFIG_MAC80211_LEDS\nconst char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);\nconst char *\n__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,\n\t\t\t\t   unsigned int flags,\n\t\t\t\t   const struct ieee80211_tpt_blink *blink_table,\n\t\t\t\t   unsigned int blink_table_len);\n#endif\n \nstatic inline const char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_tx_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n \nstatic inline const char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_rx_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n \nstatic inline const char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_assoc_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n \nstatic inline const char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_radio_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n \nstatic inline const char *\nieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,\n\t\t\t\t const struct ieee80211_tpt_blink *blink_table,\n\t\t\t\t unsigned int blink_table_len)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_create_tpt_led_trigger(hw, flags, blink_table,\n\t\t\t\t\t\t  blink_table_len);\n#else\n\treturn NULL;\n#endif\n}\n\n \nvoid ieee80211_unregister_hw(struct ieee80211_hw *hw);\n\n \nvoid ieee80211_free_hw(struct ieee80211_hw *hw);\n\n \nvoid ieee80211_restart_hw(struct ieee80211_hw *hw);\n\n \nvoid ieee80211_rx_list(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       struct sk_buff *skb, struct list_head *list);\n\n \nvoid ieee80211_rx_napi(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       struct sk_buff *skb, struct napi_struct *napi);\n\n \nstatic inline void ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tieee80211_rx_napi(hw, NULL, skb, NULL);\n}\n\n \nvoid ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb);\n\n \nstatic inline void ieee80211_rx_ni(struct ieee80211_hw *hw,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tlocal_bh_disable();\n\tieee80211_rx(hw, skb);\n\tlocal_bh_enable();\n}\n\n \nint ieee80211_sta_ps_transition(struct ieee80211_sta *sta, bool start);\n\n \nstatic inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,\n\t\t\t\t\t\t  bool start)\n{\n\tint ret;\n\n\tlocal_bh_disable();\n\tret = ieee80211_sta_ps_transition(sta, start);\n\tlocal_bh_enable();\n\n\treturn ret;\n}\n\n \nvoid ieee80211_sta_pspoll(struct ieee80211_sta *sta);\n\n \nvoid ieee80211_sta_uapsd_trigger(struct ieee80211_sta *sta, u8 tid);\n\n \n#define IEEE80211_TX_STATUS_HEADROOM\tALIGN(14, 4)\n\n \nvoid ieee80211_sta_set_buffered(struct ieee80211_sta *sta,\n\t\t\t\tu8 tid, bool buffered);\n\n \nvoid ieee80211_get_tx_rates(struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct ieee80211_tx_rate *dest,\n\t\t\t    int max_rates);\n\n \nvoid ieee80211_sta_set_expected_throughput(struct ieee80211_sta *pubsta,\n\t\t\t\t\t   u32 thr);\n\n \nvoid ieee80211_tx_rate_update(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_sta *pubsta,\n\t\t\t      struct ieee80211_tx_info *info);\n\n \nvoid ieee80211_tx_status(struct ieee80211_hw *hw,\n\t\t\t struct sk_buff *skb);\n\n \nvoid ieee80211_tx_status_ext(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_tx_status *status);\n\n \nstatic inline void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t\t     struct ieee80211_tx_info *info)\n{\n\tstruct ieee80211_tx_status status = {\n\t\t.sta = sta,\n\t\t.info = info,\n\t};\n\n\tieee80211_tx_status_ext(hw, &status);\n}\n\n \nstatic inline void ieee80211_tx_status_ni(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tlocal_bh_disable();\n\tieee80211_tx_status(hw, skb);\n\tlocal_bh_enable();\n}\n\n \nvoid ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,\n\t\t\t\t struct sk_buff *skb);\n\n \nvoid ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);\n\n#define IEEE80211_MAX_CNTDWN_COUNTERS_NUM 2\n\n \nstruct ieee80211_mutable_offsets {\n\tu16 tim_offset;\n\tu16 tim_length;\n\n\tu16 cntdwn_counter_offs[IEEE80211_MAX_CNTDWN_COUNTERS_NUM];\n\tu16 mbssid_off;\n};\n\n \nstruct sk_buff *\nieee80211_beacon_get_template(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_mutable_offsets *offs,\n\t\t\t      unsigned int link_id);\n\n \nstruct sk_buff *\nieee80211_beacon_get_template_ema_index(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_mutable_offsets *offs,\n\t\t\t\t\tunsigned int link_id, u8 ema_index);\n\n \nstruct ieee80211_ema_beacons {\n\tu8 cnt;\n\tstruct {\n\t\tstruct sk_buff *skb;\n\t\tstruct ieee80211_mutable_offsets offs;\n\t} bcn[];\n};\n\n \nstruct ieee80211_ema_beacons *\nieee80211_beacon_get_template_ema_list(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       unsigned int link_id);\n\n \nvoid ieee80211_beacon_free_ema_list(struct ieee80211_ema_beacons *ema_beacons);\n\n \nstruct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t u16 *tim_offset, u16 *tim_length,\n\t\t\t\t\t unsigned int link_id);\n\n \nstatic inline struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw,\n\t\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t\t   unsigned int link_id)\n{\n\treturn ieee80211_beacon_get_tim(hw, vif, NULL, NULL, link_id);\n}\n\n \nu8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif);\n\n \nvoid ieee80211_beacon_set_cntdwn(struct ieee80211_vif *vif, u8 counter);\n\n \nvoid ieee80211_csa_finish(struct ieee80211_vif *vif);\n\n \nbool ieee80211_beacon_cntdwn_is_complete(struct ieee80211_vif *vif);\n\n \nvoid ieee80211_color_change_finish(struct ieee80211_vif *vif);\n\n \nstruct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif);\n\n \nstruct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif);\n\n \nstruct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       int link_id, bool qos_ok);\n\n \nstruct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t       const u8 *src_addr,\n\t\t\t\t       const u8 *ssid, size_t ssid_len,\n\t\t\t\t       size_t tailroom);\n\n \nvoid ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       const void *frame, size_t frame_len,\n\t\t       const struct ieee80211_tx_info *frame_txctl,\n\t\t       struct ieee80211_rts *rts);\n\n \n__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, size_t frame_len,\n\t\t\t      const struct ieee80211_tx_info *frame_txctl);\n\n \nvoid ieee80211_ctstoself_get(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     const void *frame, size_t frame_len,\n\t\t\t     const struct ieee80211_tx_info *frame_txctl,\n\t\t\t     struct ieee80211_cts *cts);\n\n \n__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    size_t frame_len,\n\t\t\t\t    const struct ieee80211_tx_info *frame_txctl);\n\n \n__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tenum nl80211_band band,\n\t\t\t\t\tsize_t frame_len,\n\t\t\t\t\tstruct ieee80211_rate *rate);\n\n \nstruct sk_buff *\nieee80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\n \nvoid ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,\n\t\t\t       u32 iv32, u16 *p1k);\n\n \nstatic inline void ieee80211_get_tkip_p1k(struct ieee80211_key_conf *keyconf,\n\t\t\t\t\t  struct sk_buff *skb, u16 *p1k)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tconst u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);\n\tu32 iv32 = get_unaligned_le32(&data[4]);\n\n\tieee80211_get_tkip_p1k_iv(keyconf, iv32, p1k);\n}\n\n \nvoid ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,\n\t\t\t       const u8 *ta, u32 iv32, u16 *p1k);\n\n \nvoid ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,\n\t\t\t    struct sk_buff *skb, u8 *p2k);\n\n \nu8 *ieee80211_tkip_add_iv(u8 *pos, struct ieee80211_key_conf *keyconf, u64 pn);\n\n \nvoid ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,\n\t\t\t      int tid, struct ieee80211_key_seq *seq);\n\n \nvoid ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,\n\t\t\t      int tid, struct ieee80211_key_seq *seq);\n\n \nvoid ieee80211_remove_key(struct ieee80211_key_conf *keyconf);\n\n \nstruct ieee80211_key_conf *\nieee80211_gtk_rekey_add(struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_key_conf *keyconf);\n\n \nvoid ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,\n\t\t\t\tconst u8 *replay_ctr, gfp_t gfp);\n\n \nvoid ieee80211_key_mic_failure(struct ieee80211_key_conf *keyconf);\n\n \nvoid ieee80211_key_replay(struct ieee80211_key_conf *keyconf);\n\n \nvoid ieee80211_wake_queue(struct ieee80211_hw *hw, int queue);\n\n \nvoid ieee80211_stop_queue(struct ieee80211_hw *hw, int queue);\n\n \n\nint ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue);\n\n \nvoid ieee80211_stop_queues(struct ieee80211_hw *hw);\n\n \nvoid ieee80211_wake_queues(struct ieee80211_hw *hw);\n\n \nvoid ieee80211_scan_completed(struct ieee80211_hw *hw,\n\t\t\t      struct cfg80211_scan_info *info);\n\n \nvoid ieee80211_sched_scan_results(struct ieee80211_hw *hw);\n\n \nvoid ieee80211_sched_scan_stopped(struct ieee80211_hw *hw);\n\n \nenum ieee80211_interface_iteration_flags {\n\tIEEE80211_IFACE_ITER_NORMAL\t= 0,\n\tIEEE80211_IFACE_ITER_RESUME_ALL\t= BIT(0),\n\tIEEE80211_IFACE_ITER_ACTIVE\t= BIT(1),\n\tIEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER\t= BIT(2),\n};\n\n \nvoid ieee80211_iterate_interfaces(struct ieee80211_hw *hw, u32 iter_flags,\n\t\t\t\t  void (*iterator)(void *data, u8 *mac,\n\t\t\t\t\t\t   struct ieee80211_vif *vif),\n\t\t\t\t  void *data);\n\n \nstatic inline void\nieee80211_iterate_active_interfaces(struct ieee80211_hw *hw, u32 iter_flags,\n\t\t\t\t    void (*iterator)(void *data, u8 *mac,\n\t\t\t\t\t\t     struct ieee80211_vif *vif),\n\t\t\t\t    void *data)\n{\n\tieee80211_iterate_interfaces(hw,\n\t\t\t\t     iter_flags | IEEE80211_IFACE_ITER_ACTIVE,\n\t\t\t\t     iterator, data);\n}\n\n \nvoid ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,\n\t\t\t\t\t\tu32 iter_flags,\n\t\t\t\t\t\tvoid (*iterator)(void *data,\n\t\t\t\t\t\t    u8 *mac,\n\t\t\t\t\t\t    struct ieee80211_vif *vif),\n\t\t\t\t\t\tvoid *data);\n\n \nvoid ieee80211_iterate_active_interfaces_mtx(struct ieee80211_hw *hw,\n\t\t\t\t\t     u32 iter_flags,\n\t\t\t\t\t     void (*iterator)(void *data,\n\t\t\t\t\t\tu8 *mac,\n\t\t\t\t\t\tstruct ieee80211_vif *vif),\n\t\t\t\t\t     void *data);\n\n \nvoid ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,\n\t\t\t\t       void (*iterator)(void *data,\n\t\t\t\t\t\tstruct ieee80211_sta *sta),\n\t\t\t\t       void *data);\n \nvoid ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work);\n\n \nvoid ieee80211_queue_delayed_work(struct ieee80211_hw *hw,\n\t\t\t\t  struct delayed_work *dwork,\n\t\t\t\t  unsigned long delay);\n\n \nvoid ieee80211_refresh_tx_agg_session_timer(struct ieee80211_sta *sta,\n\t\t\t\t\t    u16 tid);\n\n \nint ieee80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid,\n\t\t\t\t  u16 timeout);\n\n \nvoid ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,\n\t\t\t\t      u16 tid);\n\n \nint ieee80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid);\n\n \nvoid ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,\n\t\t\t\t     u16 tid);\n\n \nstruct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,\n\t\t\t\t\t const u8 *addr);\n\n \nstruct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,\n\t\t\t\t\t       const u8 *addr,\n\t\t\t\t\t       const u8 *localaddr);\n\n \nstruct ieee80211_sta *\nieee80211_find_sta_by_link_addrs(struct ieee80211_hw *hw,\n\t\t\t\t const u8 *addr,\n\t\t\t\t const u8 *localaddr,\n\t\t\t\t unsigned int *link_id);\n\n \nvoid ieee80211_sta_block_awake(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_sta *pubsta, bool block);\n\n \nvoid ieee80211_sta_eosp(struct ieee80211_sta *pubsta);\n\n \nvoid ieee80211_send_eosp_nullfunc(struct ieee80211_sta *pubsta, int tid);\n\n \nvoid ieee80211_sta_recalc_aggregates(struct ieee80211_sta *pubsta);\n\n \nvoid ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,\n\t\t\t\t    u32 tx_airtime, u32 rx_airtime);\n\n \nbool\nieee80211_txq_airtime_check(struct ieee80211_hw *hw, struct ieee80211_txq *txq);\n\n \nvoid ieee80211_iter_keys(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t void (*iter)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t\t      void *data),\n\t\t\t void *iter_data);\n\n \nvoid ieee80211_iter_keys_rcu(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     void (*iter)(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t\t  struct ieee80211_key_conf *key,\n\t\t\t\t\t  void *data),\n\t\t\t     void *iter_data);\n\n \nvoid ieee80211_iter_chan_contexts_atomic(\n\tstruct ieee80211_hw *hw,\n\tvoid (*iter)(struct ieee80211_hw *hw,\n\t\t     struct ieee80211_chanctx_conf *chanctx_conf,\n\t\t     void *data),\n\tvoid *iter_data);\n\n \nstruct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif);\n\n \nvoid ieee80211_beacon_loss(struct ieee80211_vif *vif);\n\n \nvoid ieee80211_connection_loss(struct ieee80211_vif *vif);\n\n \nvoid ieee80211_disconnect(struct ieee80211_vif *vif, bool reconnect);\n\n \nvoid ieee80211_resume_disconnect(struct ieee80211_vif *vif);\n\n \nvoid ieee80211_hw_restart_disconnect(struct ieee80211_vif *vif);\n\n \nvoid ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,\n\t\t\t       enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t       s32 rssi_level,\n\t\t\t       gfp_t gfp);\n\n \nvoid ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp);\n\n \nvoid ieee80211_radar_detected(struct ieee80211_hw *hw);\n\n \nvoid ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success);\n\n \nvoid ieee80211_channel_switch_disconnect(struct ieee80211_vif *vif,\n\t\t\t\t\t bool block_tx);\n\n \nvoid ieee80211_request_smps(struct ieee80211_vif *vif, unsigned int link_id,\n\t\t\t    enum ieee80211_smps_mode smps_mode);\n\n \nvoid ieee80211_ready_on_channel(struct ieee80211_hw *hw);\n\n \nvoid ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw);\n\n \nvoid ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,\n\t\t\t\t  const u8 *addr);\n\n \nvoid ieee80211_mark_rx_ba_filtered_frames(struct ieee80211_sta *pubsta, u8 tid,\n\t\t\t\t\t  u16 ssn, u64 filtered,\n\t\t\t\t\t  u16 received_mpdus);\n\n \nvoid ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);\n\n \nvoid ieee80211_manage_rx_ba_offl(struct ieee80211_vif *vif, const u8 *addr,\n\t\t\t\t unsigned int tid);\n\n \nstatic inline void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,\n\t\t\t\t\t\t      const u8 *addr, u16 tid)\n{\n\tif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\tieee80211_manage_rx_ba_offl(vif, addr, tid);\n}\n\n \nstatic inline void ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif,\n\t\t\t\t\t\t     const u8 *addr, u16 tid)\n{\n\tif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\tieee80211_manage_rx_ba_offl(vif, addr, tid + IEEE80211_NUM_TIDS);\n}\n\n \nvoid ieee80211_rx_ba_timer_expired(struct ieee80211_vif *vif,\n\t\t\t\t   const u8 *addr, unsigned int tid);\n\n \n\n \nstruct ieee80211_tx_rate_control {\n\tstruct ieee80211_hw *hw;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_bss_conf *bss_conf;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_rate reported_rate;\n\tbool rts, short_preamble;\n\tu32 rate_idx_mask;\n\tu8 *rate_idx_mcs_mask;\n\tbool bss;\n};\n\n \nenum rate_control_capabilities {\n\t \n\tRATE_CTRL_CAPA_VHT_EXT_NSS_BW = BIT(0),\n\t \n\tRATE_CTRL_CAPA_AMPDU_TRIGGER = BIT(1),\n};\n\nstruct rate_control_ops {\n\tunsigned long capa;\n\tconst char *name;\n\tvoid *(*alloc)(struct ieee80211_hw *hw);\n\tvoid (*add_debugfs)(struct ieee80211_hw *hw, void *priv,\n\t\t\t    struct dentry *debugfsdir);\n\tvoid (*free)(void *priv);\n\n\tvoid *(*alloc_sta)(void *priv, struct ieee80211_sta *sta, gfp_t gfp);\n\tvoid (*rate_init)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t  struct cfg80211_chan_def *chandef,\n\t\t\t  struct ieee80211_sta *sta, void *priv_sta);\n\tvoid (*rate_update)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t    struct cfg80211_chan_def *chandef,\n\t\t\t    struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t    u32 changed);\n\tvoid (*free_sta)(void *priv, struct ieee80211_sta *sta,\n\t\t\t void *priv_sta);\n\n\tvoid (*tx_status_ext)(void *priv,\n\t\t\t      struct ieee80211_supported_band *sband,\n\t\t\t      void *priv_sta, struct ieee80211_tx_status *st);\n\tvoid (*tx_status)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t  struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t  struct sk_buff *skb);\n\tvoid (*get_rate)(void *priv, struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t struct ieee80211_tx_rate_control *txrc);\n\n\tvoid (*add_sta_debugfs)(void *priv, void *priv_sta,\n\t\t\t\tstruct dentry *dir);\n\n\tu32 (*get_expected_throughput)(void *priv_sta);\n};\n\nstatic inline int rate_supported(struct ieee80211_sta *sta,\n\t\t\t\t enum nl80211_band band,\n\t\t\t\t int index)\n{\n\treturn (sta == NULL || sta->deflink.supp_rates[band] & BIT(index));\n}\n\nstatic inline s8\nrate_lowest_index(struct ieee80211_supported_band *sband,\n\t\t  struct ieee80211_sta *sta)\n{\n\tint i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (rate_supported(sta, sband->band, i))\n\t\t\treturn i;\n\n\t \n\tWARN_ON_ONCE(1);\n\n\t \n\treturn 0;\n}\n\nstatic inline\nbool rate_usable_index_exists(struct ieee80211_supported_band *sband,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (rate_supported(sta, sband->band, i))\n\t\t\treturn true;\n\treturn false;\n}\n\n \nint rate_control_set_rates(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_sta *pubsta,\n\t\t\t   struct ieee80211_sta_rates *rates);\n\nint ieee80211_rate_control_register(const struct rate_control_ops *ops);\nvoid ieee80211_rate_control_unregister(const struct rate_control_ops *ops);\n\nstatic inline bool\nconf_is_ht20(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_20;\n}\n\nstatic inline bool\nconf_is_ht40_minus(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40 &&\n\t       conf->chandef.center_freq1 < conf->chandef.chan->center_freq;\n}\n\nstatic inline bool\nconf_is_ht40_plus(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40 &&\n\t       conf->chandef.center_freq1 > conf->chandef.chan->center_freq;\n}\n\nstatic inline bool\nconf_is_ht40(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40;\n}\n\nstatic inline bool\nconf_is_ht(struct ieee80211_conf *conf)\n{\n\treturn (conf->chandef.width != NL80211_CHAN_WIDTH_5) &&\n\t\t(conf->chandef.width != NL80211_CHAN_WIDTH_10) &&\n\t\t(conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT);\n}\n\nstatic inline enum nl80211_iftype\nieee80211_iftype_p2p(enum nl80211_iftype type, bool p2p)\n{\n\tif (p2p) {\n\t\tswitch (type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\treturn NL80211_IFTYPE_P2P_CLIENT;\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn NL80211_IFTYPE_P2P_GO;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn type;\n}\n\nstatic inline enum nl80211_iftype\nieee80211_vif_type_p2p(struct ieee80211_vif *vif)\n{\n\treturn ieee80211_iftype_p2p(vif->type, vif->p2p);\n}\n\n \nstatic inline const struct ieee80211_sta_he_cap *\nieee80211_get_he_iftype_cap_vif(const struct ieee80211_supported_band *sband,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\treturn ieee80211_get_he_iftype_cap(sband, ieee80211_vif_type_p2p(vif));\n}\n\n \nstatic inline __le16\nieee80211_get_he_6ghz_capa_vif(const struct ieee80211_supported_band *sband,\n\t\t\t       struct ieee80211_vif *vif)\n{\n\treturn ieee80211_get_he_6ghz_capa(sband, ieee80211_vif_type_p2p(vif));\n}\n\n \nstatic inline const struct ieee80211_sta_eht_cap *\nieee80211_get_eht_iftype_cap_vif(const struct ieee80211_supported_band *sband,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\treturn ieee80211_get_eht_iftype_cap(sband, ieee80211_vif_type_p2p(vif));\n}\n\n \nvoid ieee80211_update_mu_groups(struct ieee80211_vif *vif, unsigned int link_id,\n\t\t\t\tconst u8 *membership, const u8 *position);\n\nvoid ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,\n\t\t\t\t   int rssi_min_thold,\n\t\t\t\t   int rssi_max_thold);\n\nvoid ieee80211_disable_rssi_reports(struct ieee80211_vif *vif);\n\n \nint ieee80211_ave_rssi(struct ieee80211_vif *vif);\n\n \nvoid ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,\n\t\t\t\t    struct cfg80211_wowlan_wakeup *wakeup,\n\t\t\t\t    gfp_t gfp);\n\n \nbool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, struct sk_buff *skb,\n\t\t\t      int band, struct ieee80211_sta **sta);\n\n \nbool ieee80211_parse_tx_radiotap(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev);\n\n \nstruct ieee80211_noa_data {\n\tu32 next_tsf;\n\tbool has_next_tsf;\n\n\tu8 absent;\n\n\tu8 count[IEEE80211_P2P_NOA_DESC_MAX];\n\tstruct {\n\t\tu32 start;\n\t\tu32 duration;\n\t\tu32 interval;\n\t} desc[IEEE80211_P2P_NOA_DESC_MAX];\n};\n\n \nint ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,\n\t\t\t    struct ieee80211_noa_data *data, u32 tsf);\n\n \nvoid ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf);\n\n \nvoid ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,\n\t\t\t\t enum nl80211_tdls_operation oper,\n\t\t\t\t u16 reason_code, gfp_t gfp);\n\n \nint ieee80211_reserve_tid(struct ieee80211_sta *sta, u8 tid);\n\n \nvoid ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid);\n\n \nstruct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_txq *txq);\n\n \nstatic inline struct sk_buff *ieee80211_tx_dequeue_ni(struct ieee80211_hw *hw,\n\t\t\t\t\t\t      struct ieee80211_txq *txq)\n{\n\tstruct sk_buff *skb;\n\n\tlocal_bh_disable();\n\tskb = ieee80211_tx_dequeue(hw, txq);\n\tlocal_bh_enable();\n\n\treturn skb;\n}\n\n \nvoid ieee80211_handle_wake_tx_queue(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_txq *txq);\n\n \nstruct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac);\n\n \nvoid ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac);\n\n \nstatic inline void ieee80211_txq_schedule_end(struct ieee80211_hw *hw, u8 ac)\n{\n}\n\nvoid __ieee80211_schedule_txq(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_txq *txq, bool force);\n\n \nstatic inline void\nieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)\n{\n\t__ieee80211_schedule_txq(hw, txq, true);\n}\n\n \nstatic inline void\nieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq,\n\t\t     bool force)\n{\n\t__ieee80211_schedule_txq(hw, txq, force);\n}\n\n \nbool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_txq *txq);\n\n \nvoid ieee80211_txq_get_depth(struct ieee80211_txq *txq,\n\t\t\t     unsigned long *frame_cnt,\n\t\t\t     unsigned long *byte_cnt);\n\n \nvoid ieee80211_nan_func_terminated(struct ieee80211_vif *vif,\n\t\t\t\t   u8 inst_id,\n\t\t\t\t   enum nl80211_nan_func_term_reason reason,\n\t\t\t\t   gfp_t gfp);\n\n \nvoid ieee80211_nan_func_match(struct ieee80211_vif *vif,\n\t\t\t      struct cfg80211_nan_match_params *match,\n\t\t\t      gfp_t gfp);\n\n \nu32 ieee80211_calc_rx_airtime(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_rx_status *status,\n\t\t\t      int len);\n\n \nu32 ieee80211_calc_tx_airtime(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_tx_info *info,\n\t\t\t      int len);\n \nbool ieee80211_set_hw_80211_encap(struct ieee80211_vif *vif, bool enable);\n\n \nstruct sk_buff *ieee80211_get_fils_discovery_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  struct ieee80211_vif *vif);\n\n \nstruct sk_buff *\nieee80211_get_unsol_bcast_probe_resp_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif);\n\n \nvoid\nieee80211_obss_color_collision_notify(struct ieee80211_vif *vif,\n\t\t\t\t      u64 color_bitmap, gfp_t gfp);\n\n \nstatic inline bool ieee80211_is_tx_data(struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *) skb->data;\n\n\treturn info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP ||\n\t       ieee80211_is_data(hdr->frame_control);\n}\n\n \nint ieee80211_set_active_links(struct ieee80211_vif *vif, u16 active_links);\n\n \nvoid ieee80211_set_active_links_async(struct ieee80211_vif *vif,\n\t\t\t\t      u16 active_links);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}