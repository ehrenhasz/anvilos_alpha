{
  "module_name": "macsec.h",
  "hash_id": "d7d1c66077ed22b7198e82fb5998f870b8b670021d3a5400c59cdcd08471dcc0",
  "original_prompt": "Ingested from linux-6.6.14/include/net/macsec.h",
  "human_readable_source": " \n \n#ifndef _NET_MACSEC_H_\n#define _NET_MACSEC_H_\n\n#include <linux/u64_stats_sync.h>\n#include <linux/if_vlan.h>\n#include <uapi/linux/if_link.h>\n#include <uapi/linux/if_macsec.h>\n\n#define MACSEC_DEFAULT_PN_LEN 4\n#define MACSEC_XPN_PN_LEN 8\n\n#define MACSEC_NUM_AN 4  \n\n#define MACSEC_SCI_LEN 8\n#define MACSEC_PORT_ES (htons(0x0001))\n\n#define MACSEC_TCI_VERSION 0x80\n#define MACSEC_TCI_ES      0x40  \n#define MACSEC_TCI_SC      0x20  \n#define MACSEC_TCI_SCB     0x10  \n#define MACSEC_TCI_E       0x08  \n#define MACSEC_TCI_C       0x04  \n#define MACSEC_AN_MASK     0x03  \n#define MACSEC_TCI_CONFID  (MACSEC_TCI_E | MACSEC_TCI_C)\n\n#define MACSEC_DEFAULT_ICV_LEN 16\n\ntypedef u64 __bitwise sci_t;\ntypedef u32 __bitwise ssci_t;\n\nstruct metadata_dst;\n\ntypedef union salt {\n\tstruct {\n\t\tu32 ssci;\n\t\tu64 pn;\n\t} __packed;\n\tu8 bytes[MACSEC_SALT_LEN];\n} __packed salt_t;\n\ntypedef union pn {\n\tstruct {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\t\tu32 lower;\n\t\tu32 upper;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n\t\tu32 upper;\n\t\tu32 lower;\n#else\n#error\t\"Please fix <asm/byteorder.h>\"\n#endif\n\t};\n\tu64 full64;\n} pn_t;\n\n \nstruct macsec_key {\n\tu8 id[MACSEC_KEYID_LEN];\n\tstruct crypto_aead *tfm;\n\tsalt_t salt;\n};\n\nstruct macsec_rx_sc_stats {\n\t__u64 InOctetsValidated;\n\t__u64 InOctetsDecrypted;\n\t__u64 InPktsUnchecked;\n\t__u64 InPktsDelayed;\n\t__u64 InPktsOK;\n\t__u64 InPktsInvalid;\n\t__u64 InPktsLate;\n\t__u64 InPktsNotValid;\n\t__u64 InPktsNotUsingSA;\n\t__u64 InPktsUnusedSA;\n};\n\nstruct macsec_rx_sa_stats {\n\t__u32 InPktsOK;\n\t__u32 InPktsInvalid;\n\t__u32 InPktsNotValid;\n\t__u32 InPktsNotUsingSA;\n\t__u32 InPktsUnusedSA;\n};\n\nstruct macsec_tx_sa_stats {\n\t__u32 OutPktsProtected;\n\t__u32 OutPktsEncrypted;\n};\n\nstruct macsec_tx_sc_stats {\n\t__u64 OutPktsProtected;\n\t__u64 OutPktsEncrypted;\n\t__u64 OutOctetsProtected;\n\t__u64 OutOctetsEncrypted;\n};\n\nstruct macsec_dev_stats {\n\t__u64 OutPktsUntagged;\n\t__u64 InPktsUntagged;\n\t__u64 OutPktsTooLong;\n\t__u64 InPktsNoTag;\n\t__u64 InPktsBadTag;\n\t__u64 InPktsUnknownSCI;\n\t__u64 InPktsNoSCI;\n\t__u64 InPktsOverrun;\n};\n\n \nstruct macsec_rx_sa {\n\tstruct macsec_key key;\n\tssci_t ssci;\n\tspinlock_t lock;\n\tunion {\n\t\tpn_t next_pn_halves;\n\t\tu64 next_pn;\n\t};\n\trefcount_t refcnt;\n\tbool active;\n\tstruct macsec_rx_sa_stats __percpu *stats;\n\tstruct macsec_rx_sc *sc;\n\tstruct rcu_head rcu;\n};\n\nstruct pcpu_rx_sc_stats {\n\tstruct macsec_rx_sc_stats stats;\n\tstruct u64_stats_sync syncp;\n};\n\nstruct pcpu_tx_sc_stats {\n\tstruct macsec_tx_sc_stats stats;\n\tstruct u64_stats_sync syncp;\n};\n\n \nstruct macsec_rx_sc {\n\tstruct macsec_rx_sc __rcu *next;\n\tsci_t sci;\n\tbool active;\n\tstruct macsec_rx_sa __rcu *sa[MACSEC_NUM_AN];\n\tstruct pcpu_rx_sc_stats __percpu *stats;\n\trefcount_t refcnt;\n\tstruct rcu_head rcu_head;\n};\n\n \nstruct macsec_tx_sa {\n\tstruct macsec_key key;\n\tssci_t ssci;\n\tspinlock_t lock;\n\tunion {\n\t\tpn_t next_pn_halves;\n\t\tu64 next_pn;\n\t};\n\trefcount_t refcnt;\n\tbool active;\n\tstruct macsec_tx_sa_stats __percpu *stats;\n\tstruct rcu_head rcu;\n};\n\n \nstruct macsec_tx_sc {\n\tbool active;\n\tu8 encoding_sa;\n\tbool encrypt;\n\tbool send_sci;\n\tbool end_station;\n\tbool scb;\n\tstruct macsec_tx_sa __rcu *sa[MACSEC_NUM_AN];\n\tstruct pcpu_tx_sc_stats __percpu *stats;\n\tstruct metadata_dst *md_dst;\n};\n\n \nstruct macsec_secy {\n\tstruct net_device *netdev;\n\tunsigned int n_rx_sc;\n\tsci_t sci;\n\tu16 key_len;\n\tu16 icv_len;\n\tenum macsec_validation_type validate_frames;\n\tbool xpn;\n\tbool operational;\n\tbool protect_frames;\n\tbool replay_protect;\n\tu32 replay_window;\n\tstruct macsec_tx_sc tx_sc;\n\tstruct macsec_rx_sc __rcu *rx_sc;\n};\n\n \nstruct macsec_context {\n\tunion {\n\t\tstruct net_device *netdev;\n\t\tstruct phy_device *phydev;\n\t};\n\tenum macsec_offload offload;\n\n\tstruct macsec_secy *secy;\n\tstruct macsec_rx_sc *rx_sc;\n\tstruct {\n\t\tbool update_pn;\n\t\tunsigned char assoc_num;\n\t\tu8 key[MACSEC_MAX_KEY_LEN];\n\t\tunion {\n\t\t\tstruct macsec_rx_sa *rx_sa;\n\t\t\tstruct macsec_tx_sa *tx_sa;\n\t\t};\n\t} sa;\n\tunion {\n\t\tstruct macsec_tx_sc_stats *tx_sc_stats;\n\t\tstruct macsec_tx_sa_stats *tx_sa_stats;\n\t\tstruct macsec_rx_sc_stats *rx_sc_stats;\n\t\tstruct macsec_rx_sa_stats *rx_sa_stats;\n\t\tstruct macsec_dev_stats  *dev_stats;\n\t} stats;\n};\n\n \nstruct macsec_ops {\n\t \n\tint (*mdo_dev_open)(struct macsec_context *ctx);\n\tint (*mdo_dev_stop)(struct macsec_context *ctx);\n\t \n\tint (*mdo_add_secy)(struct macsec_context *ctx);\n\tint (*mdo_upd_secy)(struct macsec_context *ctx);\n\tint (*mdo_del_secy)(struct macsec_context *ctx);\n\t \n\tint (*mdo_add_rxsc)(struct macsec_context *ctx);\n\tint (*mdo_upd_rxsc)(struct macsec_context *ctx);\n\tint (*mdo_del_rxsc)(struct macsec_context *ctx);\n\t \n\tint (*mdo_add_rxsa)(struct macsec_context *ctx);\n\tint (*mdo_upd_rxsa)(struct macsec_context *ctx);\n\tint (*mdo_del_rxsa)(struct macsec_context *ctx);\n\tint (*mdo_add_txsa)(struct macsec_context *ctx);\n\tint (*mdo_upd_txsa)(struct macsec_context *ctx);\n\tint (*mdo_del_txsa)(struct macsec_context *ctx);\n\t \n\tint (*mdo_get_dev_stats)(struct macsec_context *ctx);\n\tint (*mdo_get_tx_sc_stats)(struct macsec_context *ctx);\n\tint (*mdo_get_tx_sa_stats)(struct macsec_context *ctx);\n\tint (*mdo_get_rx_sc_stats)(struct macsec_context *ctx);\n\tint (*mdo_get_rx_sa_stats)(struct macsec_context *ctx);\n};\n\nvoid macsec_pn_wrapped(struct macsec_secy *secy, struct macsec_tx_sa *tx_sa);\nstatic inline bool macsec_send_sci(const struct macsec_secy *secy)\n{\n\tconst struct macsec_tx_sc *tx_sc = &secy->tx_sc;\n\n\treturn tx_sc->send_sci ||\n\t\t(secy->n_rx_sc > 1 && !tx_sc->end_station && !tx_sc->scb);\n}\nstruct net_device *macsec_get_real_dev(const struct net_device *dev);\nbool macsec_netdev_is_offloaded(struct net_device *dev);\n\nstatic inline void *macsec_netdev_priv(const struct net_device *dev)\n{\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n\tif (is_vlan_dev(dev))\n\t\treturn netdev_priv(vlan_dev_priv(dev)->real_dev);\n#endif\n\treturn netdev_priv(dev);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}