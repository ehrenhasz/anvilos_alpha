{
  "module_name": "erspan.h",
  "hash_id": "017799263ff50fddd86b76fd88b8e635a20b91a195f62223a982cba70a63b556",
  "original_prompt": "Ingested from linux-6.6.14/include/net/erspan.h",
  "human_readable_source": "#ifndef __LINUX_ERSPAN_H\n#define __LINUX_ERSPAN_H\n\n \n\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/skbuff.h>\n#include <uapi/linux/erspan.h>\n\n#define ERSPAN_VERSION\t0x1\t \n#define VER_MASK\t0xf000\n#define VLAN_MASK\t0x0fff\n#define COS_MASK\t0xe000\n#define EN_MASK\t\t0x1800\n#define T_MASK\t\t0x0400\n#define ID_MASK\t\t0x03ff\n#define INDEX_MASK\t0xfffff\n\n#define ERSPAN_VERSION2\t0x2\t \n#define BSO_MASK\tEN_MASK\n#define SGT_MASK\t0xffff0000\n#define P_MASK\t\t0x8000\n#define FT_MASK\t\t0x7c00\n#define HWID_MASK\t0x03f0\n#define DIR_MASK\t0x0008\n#define GRA_MASK\t0x0006\n#define O_MASK\t\t0x0001\n\n#define HWID_OFFSET    4\n#define DIR_OFFSET     3\n\nenum erspan_encap_type {\n\tERSPAN_ENCAP_NOVLAN = 0x0,\t \n\tERSPAN_ENCAP_ISL = 0x1,\t\t \n\tERSPAN_ENCAP_8021Q = 0x2,\t \n\tERSPAN_ENCAP_INFRAME = 0x3,\t \n};\n\n#define ERSPAN_V1_MDSIZE\t4\n#define ERSPAN_V2_MDSIZE\t8\n\nstruct erspan_base_hdr {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\t__u8\tvlan_upper:4,\n\t\tver:4;\n\t__u8\tvlan:8;\n\t__u8\tsession_id_upper:2,\n\t\tt:1,\n\t\ten:2,\n\t\tcos:3;\n\t__u8\tsession_id:8;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n\t__u8\tver: 4,\n\t\tvlan_upper:4;\n\t__u8\tvlan:8;\n\t__u8\tcos:3,\n\t\ten:2,\n\t\tt:1,\n\t\tsession_id_upper:2;\n\t__u8\tsession_id:8;\n#else\n#error \"Please fix <asm/byteorder.h>\"\n#endif\n};\n\nstatic inline void set_session_id(struct erspan_base_hdr *ershdr, u16 id)\n{\n\tershdr->session_id = id & 0xff;\n\tershdr->session_id_upper = (id >> 8) & 0x3;\n}\n\nstatic inline u16 get_session_id(const struct erspan_base_hdr *ershdr)\n{\n\treturn (ershdr->session_id_upper << 8) + ershdr->session_id;\n}\n\nstatic inline void set_vlan(struct erspan_base_hdr *ershdr, u16 vlan)\n{\n\tershdr->vlan = vlan & 0xff;\n\tershdr->vlan_upper = (vlan >> 8) & 0xf;\n}\n\nstatic inline u16 get_vlan(const struct erspan_base_hdr *ershdr)\n{\n\treturn (ershdr->vlan_upper << 8) + ershdr->vlan;\n}\n\nstatic inline void set_hwid(struct erspan_md2 *md2, u8 hwid)\n{\n\tmd2->hwid = hwid & 0xf;\n\tmd2->hwid_upper = (hwid >> 4) & 0x3;\n}\n\nstatic inline u8 get_hwid(const struct erspan_md2 *md2)\n{\n\treturn (md2->hwid_upper << 4) + md2->hwid;\n}\n\nstatic inline int erspan_hdr_len(int version)\n{\n\tif (version == 0)\n\t\treturn 0;\n\n\treturn sizeof(struct erspan_base_hdr) +\n\t       (version == 1 ? ERSPAN_V1_MDSIZE : ERSPAN_V2_MDSIZE);\n}\n\nstatic inline u8 tos_to_cos(u8 tos)\n{\n\tu8 dscp, cos;\n\n\tdscp = tos >> 2;\n\tcos = dscp >> 3;\n\treturn cos;\n}\n\nstatic inline void erspan_build_header(struct sk_buff *skb,\n\t\t\t\tu32 id, u32 index,\n\t\t\t\tbool truncate, bool is_ipv4)\n{\n\tstruct ethhdr *eth = (struct ethhdr *)skb->data;\n\tenum erspan_encap_type enc_type;\n\tstruct erspan_base_hdr *ershdr;\n\tstruct qtag_prefix {\n\t\t__be16 eth_type;\n\t\t__be16 tci;\n\t} *qp;\n\tu16 vlan_tci = 0;\n\tu8 tos;\n\t__be32 *idx;\n\n\ttos = is_ipv4 ? ip_hdr(skb)->tos :\n\t\t\t(ipv6_hdr(skb)->priority << 4) +\n\t\t\t(ipv6_hdr(skb)->flow_lbl[0] >> 4);\n\n\tenc_type = ERSPAN_ENCAP_NOVLAN;\n\n\t \n\tif (eth->h_proto == htons(ETH_P_8021Q)) {\n\t\tqp = (struct qtag_prefix *)(skb->data + 2 * ETH_ALEN);\n\t\tvlan_tci = ntohs(qp->tci);\n\t\tenc_type = ERSPAN_ENCAP_INFRAME;\n\t}\n\n\tskb_push(skb, sizeof(*ershdr) + ERSPAN_V1_MDSIZE);\n\tershdr = (struct erspan_base_hdr *)skb->data;\n\tmemset(ershdr, 0, sizeof(*ershdr) + ERSPAN_V1_MDSIZE);\n\n\t \n\tershdr->ver = ERSPAN_VERSION;\n\tershdr->cos = tos_to_cos(tos);\n\tershdr->en = enc_type;\n\tershdr->t = truncate;\n\tset_vlan(ershdr, vlan_tci);\n\tset_session_id(ershdr, id);\n\n\t \n\tidx = (__be32 *)(ershdr + 1);\n\t*idx = htonl(index & INDEX_MASK);\n}\n\n \nstatic inline __be32 erspan_get_timestamp(void)\n{\n\tu64 h_usecs;\n\tktime_t kt;\n\n\tkt = ktime_get_real();\n\th_usecs = ktime_divns(kt, 100 * NSEC_PER_USEC);\n\n\t \n\treturn htonl((u32)h_usecs);\n}\n\n \nenum erspan_bso {\n\tBSO_NOERROR = 0x0,\n\tBSO_SHORT = 0x1,\n\tBSO_OVERSIZED = 0x2,\n\tBSO_BAD = 0x3,\n};\n\nstatic inline u8 erspan_detect_bso(struct sk_buff *skb)\n{\n\t \n\tif (skb->len < ETH_ZLEN)\n\t\treturn BSO_SHORT;\n\n\tif (skb->len > ETH_FRAME_LEN)\n\t\treturn BSO_OVERSIZED;\n\n\treturn BSO_NOERROR;\n}\n\nstatic inline void erspan_build_header_v2(struct sk_buff *skb,\n\t\t\t\t\t  u32 id, u8 direction, u16 hwid,\n\t\t\t\t\t  bool truncate, bool is_ipv4)\n{\n\tstruct ethhdr *eth = (struct ethhdr *)skb->data;\n\tstruct erspan_base_hdr *ershdr;\n\tstruct erspan_md2 *md2;\n\tstruct qtag_prefix {\n\t\t__be16 eth_type;\n\t\t__be16 tci;\n\t} *qp;\n\tu16 vlan_tci = 0;\n\tu8 gra = 0;  \n\tu8 bso = 0;  \n\tu8 sgt = 0;\n\tu8 tos;\n\n\ttos = is_ipv4 ? ip_hdr(skb)->tos :\n\t\t\t(ipv6_hdr(skb)->priority << 4) +\n\t\t\t(ipv6_hdr(skb)->flow_lbl[0] >> 4);\n\n\t \n\tif (eth->h_proto == htons(ETH_P_8021Q)) {\n\t\tqp = (struct qtag_prefix *)(skb->data + 2 * ETH_ALEN);\n\t\tvlan_tci = ntohs(qp->tci);\n\t}\n\n\tbso = erspan_detect_bso(skb);\n\tskb_push(skb, sizeof(*ershdr) + ERSPAN_V2_MDSIZE);\n\tershdr = (struct erspan_base_hdr *)skb->data;\n\tmemset(ershdr, 0, sizeof(*ershdr) + ERSPAN_V2_MDSIZE);\n\n\t \n\tershdr->ver = ERSPAN_VERSION2;\n\tershdr->cos = tos_to_cos(tos);\n\tershdr->en = bso;\n\tershdr->t = truncate;\n\tset_vlan(ershdr, vlan_tci);\n\tset_session_id(ershdr, id);\n\n\t \n\tmd2 = (struct erspan_md2 *)(ershdr + 1);\n\tmd2->timestamp = erspan_get_timestamp();\n\tmd2->sgt = htons(sgt);\n\tmd2->p = 1;\n\tmd2->ft = 0;\n\tmd2->dir = direction;\n\tmd2->gra = gra;\n\tmd2->o = 0;\n\tset_hwid(md2, hwid);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}