{
  "module_name": "busy_poll.h",
  "hash_id": "375eb6dfeff5cd247513276b097e0c248c0c3532c3260170923f56b0e0670763",
  "original_prompt": "Ingested from linux-6.6.14/include/net/busy_poll.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_NET_BUSY_POLL_H\n#define _LINUX_NET_BUSY_POLL_H\n\n#include <linux/netdevice.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <net/ip.h>\n#include <net/xdp.h>\n\n \n#define MIN_NAPI_ID ((unsigned int)(NR_CPUS + 1))\n\n#define BUSY_POLL_BUDGET 8\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\nstruct napi_struct;\nextern unsigned int sysctl_net_busy_read __read_mostly;\nextern unsigned int sysctl_net_busy_poll __read_mostly;\n\nstatic inline bool net_busy_loop_on(void)\n{\n\treturn READ_ONCE(sysctl_net_busy_poll);\n}\n\nstatic inline bool sk_can_busy_loop(const struct sock *sk)\n{\n\treturn READ_ONCE(sk->sk_ll_usec) && !signal_pending(current);\n}\n\nbool sk_busy_loop_end(void *p, unsigned long start_time);\n\nvoid napi_busy_loop(unsigned int napi_id,\n\t\t    bool (*loop_end)(void *, unsigned long),\n\t\t    void *loop_end_arg, bool prefer_busy_poll, u16 budget);\n\n#else  \nstatic inline unsigned long net_busy_loop_on(void)\n{\n\treturn 0;\n}\n\nstatic inline bool sk_can_busy_loop(struct sock *sk)\n{\n\treturn false;\n}\n\n#endif  \n\nstatic inline unsigned long busy_loop_current_time(void)\n{\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\treturn (unsigned long)(local_clock() >> 10);\n#else\n\treturn 0;\n#endif\n}\n\n \nstatic inline bool busy_loop_timeout(unsigned long start_time)\n{\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tunsigned long bp_usec = READ_ONCE(sysctl_net_busy_poll);\n\n\tif (bp_usec) {\n\t\tunsigned long end_time = start_time + bp_usec;\n\t\tunsigned long now = busy_loop_current_time();\n\n\t\treturn time_after(now, end_time);\n\t}\n#endif\n\treturn true;\n}\n\nstatic inline bool sk_busy_loop_timeout(struct sock *sk,\n\t\t\t\t\tunsigned long start_time)\n{\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tunsigned long bp_usec = READ_ONCE(sk->sk_ll_usec);\n\n\tif (bp_usec) {\n\t\tunsigned long end_time = start_time + bp_usec;\n\t\tunsigned long now = busy_loop_current_time();\n\n\t\treturn time_after(now, end_time);\n\t}\n#endif\n\treturn true;\n}\n\nstatic inline void sk_busy_loop(struct sock *sk, int nonblock)\n{\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tunsigned int napi_id = READ_ONCE(sk->sk_napi_id);\n\n\tif (napi_id >= MIN_NAPI_ID)\n\t\tnapi_busy_loop(napi_id, nonblock ? NULL : sk_busy_loop_end, sk,\n\t\t\t       READ_ONCE(sk->sk_prefer_busy_poll),\n\t\t\t       READ_ONCE(sk->sk_busy_poll_budget) ?: BUSY_POLL_BUDGET);\n#endif\n}\n\n \nstatic inline void skb_mark_napi_id(struct sk_buff *skb,\n\t\t\t\t    struct napi_struct *napi)\n{\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\t \n\tif (skb->napi_id < MIN_NAPI_ID)\n\t\tskb->napi_id = napi->napi_id;\n#endif\n}\n\n \nstatic inline void sk_mark_napi_id(struct sock *sk, const struct sk_buff *skb)\n{\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tif (unlikely(READ_ONCE(sk->sk_napi_id) != skb->napi_id))\n\t\tWRITE_ONCE(sk->sk_napi_id, skb->napi_id);\n#endif\n\tsk_rx_queue_update(sk, skb);\n}\n\n \nstatic inline void sk_mark_napi_id_set(struct sock *sk,\n\t\t\t\t       const struct sk_buff *skb)\n{\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tWRITE_ONCE(sk->sk_napi_id, skb->napi_id);\n#endif\n\tsk_rx_queue_set(sk, skb);\n}\n\nstatic inline void __sk_mark_napi_id_once(struct sock *sk, unsigned int napi_id)\n{\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tif (!READ_ONCE(sk->sk_napi_id))\n\t\tWRITE_ONCE(sk->sk_napi_id, napi_id);\n#endif\n}\n\n \nstatic inline void sk_mark_napi_id_once(struct sock *sk,\n\t\t\t\t\tconst struct sk_buff *skb)\n{\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\t__sk_mark_napi_id_once(sk, skb->napi_id);\n#endif\n}\n\nstatic inline void sk_mark_napi_id_once_xdp(struct sock *sk,\n\t\t\t\t\t    const struct xdp_buff *xdp)\n{\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\t__sk_mark_napi_id_once(sk, xdp->rxq->napi_id);\n#endif\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}