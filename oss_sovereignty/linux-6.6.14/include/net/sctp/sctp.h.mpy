{
  "module_name": "sctp.h",
  "hash_id": "63c1499bffcffdac57142f5d1cd1a6886027a30cd0876d60d98919642baa56fa",
  "original_prompt": "Ingested from linux-6.6.14/include/net/sctp/sctp.h",
  "human_readable_source": " \n \n\n#ifndef __net_sctp_h__\n#define __net_sctp_h__\n\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/jiffies.h>\n#include <linux/idr.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#endif\n\n#include <linux/uaccess.h>\n#include <asm/page.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/sctp/structs.h>\n#include <net/sctp/constants.h>\n\n#ifdef CONFIG_IP_SCTP_MODULE\n#define SCTP_PROTOSW_FLAG 0\n#else  \n#define SCTP_PROTOSW_FLAG INET_PROTOSW_PERMANENT\n#endif\n\n \n\n \nint sctp_copy_local_addr_list(struct net *net, struct sctp_bind_addr *addr,\n\t\t\t      enum sctp_scope, gfp_t gfp, int flags);\nstruct sctp_pf *sctp_get_pf_specific(sa_family_t family);\nint sctp_register_pf(struct sctp_pf *, sa_family_t);\nvoid sctp_addr_wq_mgmt(struct net *, struct sctp_sockaddr_entry *, int);\nint sctp_udp_sock_start(struct net *net);\nvoid sctp_udp_sock_stop(struct net *net);\n\n \nint sctp_inet_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t      int addr_len, int flags);\nint sctp_backlog_rcv(struct sock *sk, struct sk_buff *skb);\nint sctp_inet_listen(struct socket *sock, int backlog);\nvoid sctp_write_space(struct sock *sk);\nvoid sctp_data_ready(struct sock *sk);\n__poll_t sctp_poll(struct file *file, struct socket *sock,\n\t\tpoll_table *wait);\nvoid sctp_sock_rfree(struct sk_buff *skb);\nvoid sctp_copy_sock(struct sock *newsk, struct sock *sk,\n\t\t    struct sctp_association *asoc);\nextern struct percpu_counter sctp_sockets_allocated;\nint sctp_asconf_mgmt(struct sctp_sock *, struct sctp_sockaddr_entry *);\nstruct sk_buff *sctp_skb_recv_datagram(struct sock *, int, int *);\n\ntypedef int (*sctp_callback_t)(struct sctp_endpoint *, struct sctp_transport *, void *);\nvoid sctp_transport_walk_start(struct rhashtable_iter *iter);\nvoid sctp_transport_walk_stop(struct rhashtable_iter *iter);\nstruct sctp_transport *sctp_transport_get_next(struct net *net,\n\t\t\tstruct rhashtable_iter *iter);\nstruct sctp_transport *sctp_transport_get_idx(struct net *net,\n\t\t\tstruct rhashtable_iter *iter, int pos);\nint sctp_transport_lookup_process(sctp_callback_t cb, struct net *net,\n\t\t\t\t  const union sctp_addr *laddr,\n\t\t\t\t  const union sctp_addr *paddr, void *p, int dif);\nint sctp_transport_traverse_process(sctp_callback_t cb, sctp_callback_t cb_done,\n\t\t\t\t    struct net *net, int *pos, void *p);\nint sctp_for_each_endpoint(int (*cb)(struct sctp_endpoint *, void *), void *p);\nint sctp_get_sctp_info(struct sock *sk, struct sctp_association *asoc,\n\t\t       struct sctp_info *info);\n\n \nint sctp_primitive_ASSOCIATE(struct net *, struct sctp_association *, void *arg);\nint sctp_primitive_SHUTDOWN(struct net *, struct sctp_association *, void *arg);\nint sctp_primitive_ABORT(struct net *, struct sctp_association *, void *arg);\nint sctp_primitive_SEND(struct net *, struct sctp_association *, void *arg);\nint sctp_primitive_REQUESTHEARTBEAT(struct net *, struct sctp_association *, void *arg);\nint sctp_primitive_ASCONF(struct net *, struct sctp_association *, void *arg);\nint sctp_primitive_RECONF(struct net *net, struct sctp_association *asoc,\n\t\t\t  void *arg);\n\n \nint sctp_rcv(struct sk_buff *skb);\nint sctp_v4_err(struct sk_buff *skb, u32 info);\nint sctp_hash_endpoint(struct sctp_endpoint *ep);\nvoid sctp_unhash_endpoint(struct sctp_endpoint *);\nstruct sock *sctp_err_lookup(struct net *net, int family, struct sk_buff *,\n\t\t\t     struct sctphdr *, struct sctp_association **,\n\t\t\t     struct sctp_transport **);\nvoid sctp_err_finish(struct sock *, struct sctp_transport *);\nint sctp_udp_v4_err(struct sock *sk, struct sk_buff *skb);\nint sctp_udp_v6_err(struct sock *sk, struct sk_buff *skb);\nvoid sctp_icmp_frag_needed(struct sock *, struct sctp_association *,\n\t\t\t   struct sctp_transport *t, __u32 pmtu);\nvoid sctp_icmp_redirect(struct sock *, struct sctp_transport *,\n\t\t\tstruct sk_buff *);\nvoid sctp_icmp_proto_unreachable(struct sock *sk,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t struct sctp_transport *t);\nint sctp_transport_hashtable_init(void);\nvoid sctp_transport_hashtable_destroy(void);\nint sctp_hash_transport(struct sctp_transport *t);\nvoid sctp_unhash_transport(struct sctp_transport *t);\nstruct sctp_transport *sctp_addrs_lookup_transport(\n\t\t\t\tstruct net *net,\n\t\t\t\tconst union sctp_addr *laddr,\n\t\t\t\tconst union sctp_addr *paddr,\n\t\t\t\tint dif, int sdif);\nstruct sctp_transport *sctp_epaddr_lookup_transport(\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst union sctp_addr *paddr);\nbool sctp_sk_bound_dev_eq(struct net *net, int bound_dev_if, int dif, int sdif);\n\n \nint __net_init sctp_proc_init(struct net *net);\n\n \nint sctp_offload_init(void);\n\n \nvoid sctp_sched_ops_init(void);\n\n \nint sctp_send_reset_streams(struct sctp_association *asoc,\n\t\t\t    struct sctp_reset_streams *params);\nint sctp_send_reset_assoc(struct sctp_association *asoc);\nint sctp_send_add_streams(struct sctp_association *asoc,\n\t\t\t  struct sctp_add_streams *params);\n\n \n\n  \nextern struct kmem_cache *sctp_chunk_cachep __read_mostly;\nextern struct kmem_cache *sctp_bucket_cachep __read_mostly;\nextern long sysctl_sctp_mem[3];\nextern int sysctl_sctp_rmem[3];\nextern int sysctl_sctp_wmem[3];\n\n \n\n \n#define SCTP_INC_STATS(net, field)\tSNMP_INC_STATS((net)->sctp.sctp_statistics, field)\n#define __SCTP_INC_STATS(net, field)\t__SNMP_INC_STATS((net)->sctp.sctp_statistics, field)\n#define SCTP_DEC_STATS(net, field)\tSNMP_DEC_STATS((net)->sctp.sctp_statistics, field)\n\n \nenum {\n\tSCTP_MIB_NUM = 0,\n\tSCTP_MIB_CURRESTAB,\t\t\t \n\tSCTP_MIB_ACTIVEESTABS,\t\t\t \n\tSCTP_MIB_PASSIVEESTABS,\t\t\t \n\tSCTP_MIB_ABORTEDS,\t\t\t \n\tSCTP_MIB_SHUTDOWNS,\t\t\t \n\tSCTP_MIB_OUTOFBLUES,\t\t\t \n\tSCTP_MIB_CHECKSUMERRORS,\t\t \n\tSCTP_MIB_OUTCTRLCHUNKS,\t\t\t \n\tSCTP_MIB_OUTORDERCHUNKS,\t\t \n\tSCTP_MIB_OUTUNORDERCHUNKS,\t\t \n\tSCTP_MIB_INCTRLCHUNKS,\t\t\t \n\tSCTP_MIB_INORDERCHUNKS,\t\t\t \n\tSCTP_MIB_INUNORDERCHUNKS,\t\t \n\tSCTP_MIB_FRAGUSRMSGS,\t\t\t \n\tSCTP_MIB_REASMUSRMSGS,\t\t\t \n\tSCTP_MIB_OUTSCTPPACKS,\t\t\t \n\tSCTP_MIB_INSCTPPACKS,\t\t\t \n\tSCTP_MIB_T1_INIT_EXPIREDS,\n\tSCTP_MIB_T1_COOKIE_EXPIREDS,\n\tSCTP_MIB_T2_SHUTDOWN_EXPIREDS,\n\tSCTP_MIB_T3_RTX_EXPIREDS,\n\tSCTP_MIB_T4_RTO_EXPIREDS,\n\tSCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS,\n\tSCTP_MIB_DELAY_SACK_EXPIREDS,\n\tSCTP_MIB_AUTOCLOSE_EXPIREDS,\n\tSCTP_MIB_T1_RETRANSMITS,\n\tSCTP_MIB_T3_RETRANSMITS,\n\tSCTP_MIB_PMTUD_RETRANSMITS,\n\tSCTP_MIB_FAST_RETRANSMITS,\n\tSCTP_MIB_IN_PKT_SOFTIRQ,\n\tSCTP_MIB_IN_PKT_BACKLOG,\n\tSCTP_MIB_IN_PKT_DISCARDS,\n\tSCTP_MIB_IN_DATA_CHUNK_DISCARDS,\n\t__SCTP_MIB_MAX\n};\n\n#define SCTP_MIB_MAX    __SCTP_MIB_MAX\nstruct sctp_mib {\n        unsigned long   mibs[SCTP_MIB_MAX];\n};\n\n \nstatic inline void sctp_max_rto(struct sctp_association *asoc,\n\t\t\t\tstruct sctp_transport *trans)\n{\n\tif (asoc->stats.max_obs_rto < (__u64)trans->rto) {\n\t\tasoc->stats.max_obs_rto = trans->rto;\n\t\tmemset(&asoc->stats.obs_rto_ipaddr, 0,\n\t\t\tsizeof(struct sockaddr_storage));\n\t\tmemcpy(&asoc->stats.obs_rto_ipaddr, &trans->ipaddr,\n\t\t\ttrans->af_specific->sockaddr_len);\n\t}\n}\n\n \n#ifdef CONFIG_SCTP_DBG_OBJCNT\n\nextern atomic_t sctp_dbg_objcnt_sock;\nextern atomic_t sctp_dbg_objcnt_ep;\nextern atomic_t sctp_dbg_objcnt_assoc;\nextern atomic_t sctp_dbg_objcnt_transport;\nextern atomic_t sctp_dbg_objcnt_chunk;\nextern atomic_t sctp_dbg_objcnt_bind_addr;\nextern atomic_t sctp_dbg_objcnt_bind_bucket;\nextern atomic_t sctp_dbg_objcnt_addr;\nextern atomic_t sctp_dbg_objcnt_datamsg;\nextern atomic_t sctp_dbg_objcnt_keys;\n\n \n#define SCTP_DBG_OBJCNT_INC(name) \\\natomic_inc(&sctp_dbg_objcnt_## name)\n#define SCTP_DBG_OBJCNT_DEC(name) \\\natomic_dec(&sctp_dbg_objcnt_## name)\n#define SCTP_DBG_OBJCNT(name) \\\natomic_t sctp_dbg_objcnt_## name = ATOMIC_INIT(0)\n\n \n#define SCTP_DBG_OBJCNT_ENTRY(name) \\\n{.label= #name, .counter= &sctp_dbg_objcnt_## name}\n\nvoid sctp_dbg_objcnt_init(struct net *);\n\n#else\n\n#define SCTP_DBG_OBJCNT_INC(name)\n#define SCTP_DBG_OBJCNT_DEC(name)\n\nstatic inline void sctp_dbg_objcnt_init(struct net *net) { return; }\n\n#endif  \n\n#if defined CONFIG_SYSCTL\nvoid sctp_sysctl_register(void);\nvoid sctp_sysctl_unregister(void);\nint sctp_sysctl_net_register(struct net *net);\nvoid sctp_sysctl_net_unregister(struct net *net);\n#else\nstatic inline void sctp_sysctl_register(void) { return; }\nstatic inline void sctp_sysctl_unregister(void) { return; }\nstatic inline int sctp_sysctl_net_register(struct net *net) { return 0; }\nstatic inline void sctp_sysctl_net_unregister(struct net *net) { return; }\n#endif\n\n \n#define SCTP_SAT_LEN(x) (sizeof(struct sctp_paramhdr) + (x) * sizeof(__u16))\n\n#if IS_ENABLED(CONFIG_IPV6)\n\nvoid sctp_v6_pf_init(void);\nvoid sctp_v6_pf_exit(void);\nint sctp_v6_protosw_init(void);\nvoid sctp_v6_protosw_exit(void);\nint sctp_v6_add_protocol(void);\nvoid sctp_v6_del_protocol(void);\n\n#else  \n\nstatic inline void sctp_v6_pf_init(void) { return; }\nstatic inline void sctp_v6_pf_exit(void) { return; }\nstatic inline int sctp_v6_protosw_init(void) { return 0; }\nstatic inline void sctp_v6_protosw_exit(void) { return; }\nstatic inline int sctp_v6_add_protocol(void) { return 0; }\nstatic inline void sctp_v6_del_protocol(void) { return; }\n\n#endif  \n\n\n \nstatic inline sctp_assoc_t sctp_assoc2id(const struct sctp_association *asoc)\n{\n\treturn asoc ? asoc->assoc_id : 0;\n}\n\nstatic inline enum sctp_sstat_state\nsctp_assoc_to_state(const struct sctp_association *asoc)\n{\n\t \n\treturn asoc->state + 1;\n}\n\n \nstruct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id);\n\nint sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp);\n\n \n#define sctp_skb_for_each(pos, head, tmp) \\\n\tskb_queue_walk_safe(head, pos, tmp)\n\n \n\nstatic inline struct list_head *sctp_list_dequeue(struct list_head *list)\n{\n\tstruct list_head *result = NULL;\n\n\tif (!list_empty(list)) {\n\t\tresult = list->next;\n\t\tlist_del_init(result);\n\t}\n\treturn result;\n}\n\n \nstatic inline void sctp_skb_set_owner_r(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sctp_ulpevent *event = sctp_skb2event(skb);\n\n\tskb_orphan(skb);\n\tskb->sk = sk;\n\tskb->destructor = sctp_sock_rfree;\n\tatomic_add(event->rmem_len, &sk->sk_rmem_alloc);\n\t \n\tsk_mem_charge(sk, event->rmem_len);\n}\n\n \nstatic inline int sctp_list_single_entry(struct list_head *head)\n{\n\treturn list_is_singular(head);\n}\n\nstatic inline bool sctp_chunk_pending(const struct sctp_chunk *chunk)\n{\n\treturn !list_empty(&chunk->list);\n}\n\n \n#define sctp_walk_params(pos, chunk)\\\n_sctp_walk_params((pos), (chunk), ntohs((chunk)->chunk_hdr.length))\n\n#define _sctp_walk_params(pos, chunk, end)\\\nfor (pos.v = (u8 *)(chunk + 1);\\\n     (pos.v + offsetof(struct sctp_paramhdr, length) + sizeof(pos.p->length) <=\\\n      (void *)chunk + end) &&\\\n     pos.v <= (void *)chunk + end - ntohs(pos.p->length) &&\\\n     ntohs(pos.p->length) >= sizeof(struct sctp_paramhdr);\\\n     pos.v += SCTP_PAD4(ntohs(pos.p->length)))\n\n#define sctp_walk_errors(err, chunk_hdr)\\\n_sctp_walk_errors((err), (chunk_hdr), ntohs((chunk_hdr)->length))\n\n#define _sctp_walk_errors(err, chunk_hdr, end)\\\nfor (err = (struct sctp_errhdr *)((void *)chunk_hdr + \\\n\t    sizeof(struct sctp_chunkhdr));\\\n     ((void *)err + offsetof(struct sctp_errhdr, length) + sizeof(err->length) <=\\\n      (void *)chunk_hdr + end) &&\\\n     (void *)err <= (void *)chunk_hdr + end - ntohs(err->length) &&\\\n     ntohs(err->length) >= sizeof(struct sctp_errhdr); \\\n     err = (struct sctp_errhdr *)((void *)err + SCTP_PAD4(ntohs(err->length))))\n\n#define sctp_walk_fwdtsn(pos, chunk)\\\n_sctp_walk_fwdtsn((pos), (chunk), ntohs((chunk)->chunk_hdr->length) - sizeof(struct sctp_fwdtsn_chunk))\n\n#define _sctp_walk_fwdtsn(pos, chunk, end)\\\nfor (pos = (void *)(chunk->subh.fwdtsn_hdr + 1);\\\n     (void *)pos <= (void *)(chunk->subh.fwdtsn_hdr + 1) + end - sizeof(struct sctp_fwdtsn_skip);\\\n     pos++)\n\n \n\nextern struct proto sctp_prot;\nextern struct proto sctpv6_prot;\nvoid sctp_put_port(struct sock *sk);\n\nextern struct idr sctp_assocs_id;\nextern spinlock_t sctp_assocs_id_lock;\n\n \n\n \nstatic inline int ipver2af(__u8 ipver)\n{\n\tswitch (ipver) {\n\tcase 4:\n\t        return  AF_INET;\n\tcase 6:\n\t\treturn AF_INET6;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic inline int param_type2af(__be16 type)\n{\n\tswitch (type) {\n\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t        return  AF_INET;\n\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\treturn AF_INET6;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \n \nstatic inline int sctp_phashfn(struct net *net, __u16 lport)\n{\n\treturn (net_hash_mix(net) + lport) & (sctp_port_hashsize - 1);\n}\n\n \nstatic inline int sctp_ep_hashfn(struct net *net, __u16 lport)\n{\n\treturn (net_hash_mix(net) + lport) & (sctp_ep_hashsize - 1);\n}\n\n#define sctp_for_each_hentry(ep, head) \\\n\thlist_for_each_entry(ep, head, node)\n\n \n#define sctp_style(sk, style) __sctp_style((sk), (SCTP_SOCKET_##style))\nstatic inline int __sctp_style(const struct sock *sk,\n\t\t\t       enum sctp_socket_type style)\n{\n\treturn sctp_sk(sk)->type == style;\n}\n\n \n#define sctp_state(asoc, state) __sctp_state((asoc), (SCTP_STATE_##state))\nstatic inline int __sctp_state(const struct sctp_association *asoc,\n\t\t\t       enum sctp_state state)\n{\n\treturn asoc->state == state;\n}\n\n \n#define sctp_sstate(sk, state) __sctp_sstate((sk), (SCTP_SS_##state))\nstatic inline int __sctp_sstate(const struct sock *sk,\n\t\t\t\tenum sctp_sock_state state)\n{\n\treturn sk->sk_state == state;\n}\n\n \nstatic inline void sctp_v6_map_v4(union sctp_addr *addr)\n{\n\taddr->v4.sin_family = AF_INET;\n\taddr->v4.sin_port = addr->v6.sin6_port;\n\taddr->v4.sin_addr.s_addr = addr->v6.sin6_addr.s6_addr32[3];\n}\n\n \nstatic inline void sctp_v4_map_v6(union sctp_addr *addr)\n{\n\t__be16 port;\n\n\tport = addr->v4.sin_port;\n\taddr->v6.sin6_addr.s6_addr32[3] = addr->v4.sin_addr.s_addr;\n\taddr->v6.sin6_port = port;\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_flowinfo = 0;\n\taddr->v6.sin6_scope_id = 0;\n\taddr->v6.sin6_addr.s6_addr32[0] = 0;\n\taddr->v6.sin6_addr.s6_addr32[1] = 0;\n\taddr->v6.sin6_addr.s6_addr32[2] = htonl(0x0000ffff);\n}\n\n \nstatic inline struct dst_entry *sctp_transport_dst_check(struct sctp_transport *t)\n{\n\tif (t->dst && !dst_check(t->dst, t->dst_cookie))\n\t\tsctp_transport_dst_release(t);\n\n\treturn t->dst;\n}\n\n \nstatic inline __u32 __sctp_mtu_payload(const struct sctp_sock *sp,\n\t\t\t\t       const struct sctp_transport *t,\n\t\t\t\t       __u32 mtu, __u32 extra)\n{\n\t__u32 overhead = sizeof(struct sctphdr) + extra;\n\n\tif (sp) {\n\t\toverhead += sp->pf->af->net_header_len;\n\t\tif (sp->udp_port && (!t || t->encap_port))\n\t\t\toverhead += sizeof(struct udphdr);\n\t} else {\n\t\toverhead += sizeof(struct ipv6hdr);\n\t}\n\n\tif (WARN_ON_ONCE(mtu && mtu <= overhead))\n\t\tmtu = overhead;\n\n\treturn mtu ? mtu - overhead : overhead;\n}\n\nstatic inline __u32 sctp_mtu_payload(const struct sctp_sock *sp,\n\t\t\t\t     __u32 mtu, __u32 extra)\n{\n\treturn __sctp_mtu_payload(sp, NULL, mtu, extra);\n}\n\nstatic inline __u32 sctp_dst_mtu(const struct dst_entry *dst)\n{\n\treturn SCTP_TRUNC4(max_t(__u32, dst_mtu(dst),\n\t\t\t\t SCTP_DEFAULT_MINSEGMENT));\n}\n\nstatic inline bool sctp_transport_pmtu_check(struct sctp_transport *t)\n{\n\t__u32 pmtu = sctp_dst_mtu(t->dst);\n\n\tif (t->pathmtu == pmtu)\n\t\treturn true;\n\n\tt->pathmtu = pmtu;\n\n\treturn false;\n}\n\nstatic inline __u32 sctp_min_frag_point(struct sctp_sock *sp, __u16 datasize)\n{\n\treturn sctp_mtu_payload(sp, SCTP_DEFAULT_MINSEGMENT, datasize);\n}\n\nstatic inline int sctp_transport_pl_hlen(struct sctp_transport *t)\n{\n\treturn __sctp_mtu_payload(sctp_sk(t->asoc->base.sk), t, 0, 0) -\n\t       sizeof(struct sctphdr);\n}\n\nstatic inline void sctp_transport_pl_reset(struct sctp_transport *t)\n{\n\tif (t->probe_interval && (t->param_flags & SPP_PMTUD_ENABLE) &&\n\t    (t->state == SCTP_ACTIVE || t->state == SCTP_UNKNOWN)) {\n\t\tif (t->pl.state == SCTP_PL_DISABLED) {\n\t\t\tt->pl.state = SCTP_PL_BASE;\n\t\t\tt->pl.pmtu = SCTP_BASE_PLPMTU;\n\t\t\tt->pl.probe_size = SCTP_BASE_PLPMTU;\n\t\t\tsctp_transport_reset_probe_timer(t);\n\t\t}\n\t} else {\n\t\tif (t->pl.state != SCTP_PL_DISABLED) {\n\t\t\tif (del_timer(&t->probe_timer))\n\t\t\t\tsctp_transport_put(t);\n\t\t\tt->pl.state = SCTP_PL_DISABLED;\n\t\t}\n\t}\n}\n\nstatic inline void sctp_transport_pl_update(struct sctp_transport *t)\n{\n\tif (t->pl.state == SCTP_PL_DISABLED)\n\t\treturn;\n\n\tt->pl.state = SCTP_PL_BASE;\n\tt->pl.pmtu = SCTP_BASE_PLPMTU;\n\tt->pl.probe_size = SCTP_BASE_PLPMTU;\n\tsctp_transport_reset_probe_timer(t);\n}\n\nstatic inline bool sctp_transport_pl_enabled(struct sctp_transport *t)\n{\n\treturn t->pl.state != SCTP_PL_DISABLED;\n}\n\nstatic inline bool sctp_newsk_ready(const struct sock *sk)\n{\n\treturn sock_flag(sk, SOCK_DEAD) || sk->sk_socket;\n}\n\nstatic inline void sctp_sock_set_nodelay(struct sock *sk)\n{\n\tlock_sock(sk);\n\tsctp_sk(sk)->nodelay = true;\n\trelease_sock(sk);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}