{
  "module_name": "command.h",
  "hash_id": "3bdc4439cd545078876fe5979517c5adea5c2755c971890b4ce322c1e96d1ea4",
  "original_prompt": "Ingested from linux-6.6.14/include/net/sctp/command.h",
  "human_readable_source": " \n \n\n#ifndef __net_sctp_command_h__\n#define __net_sctp_command_h__\n\n#include <net/sctp/constants.h>\n#include <net/sctp/structs.h>\n\n\nenum sctp_verb {\n\tSCTP_CMD_NOP = 0,\t \n\tSCTP_CMD_NEW_ASOC,\t \n\tSCTP_CMD_DELETE_TCB,\t \n\tSCTP_CMD_NEW_STATE,\t \n\tSCTP_CMD_REPORT_TSN,\t \n\tSCTP_CMD_GEN_SACK,\t \n\tSCTP_CMD_PROCESS_SACK,\t \n\tSCTP_CMD_GEN_INIT_ACK,\t \n\tSCTP_CMD_PEER_INIT,\t \n\tSCTP_CMD_GEN_COOKIE_ECHO,  \n\tSCTP_CMD_CHUNK_ULP,\t \n\tSCTP_CMD_EVENT_ULP,\t \n\tSCTP_CMD_REPLY,\t\t \n\tSCTP_CMD_SEND_PKT,\t \n\tSCTP_CMD_RETRAN,\t \n\tSCTP_CMD_ECN_CE,         \n\tSCTP_CMD_ECN_ECNE,\t \n\tSCTP_CMD_ECN_CWR,\t \n\tSCTP_CMD_TIMER_START,\t \n\tSCTP_CMD_TIMER_START_ONCE,  \n\tSCTP_CMD_TIMER_RESTART,\t \n\tSCTP_CMD_TIMER_STOP,\t \n\tSCTP_CMD_INIT_CHOOSE_TRANSPORT,  \n\tSCTP_CMD_INIT_COUNTER_RESET,  \n\tSCTP_CMD_INIT_COUNTER_INC,    \n\tSCTP_CMD_INIT_RESTART,   \n\tSCTP_CMD_COOKIEECHO_RESTART,   \n\tSCTP_CMD_INIT_FAILED,    \n\tSCTP_CMD_REPORT_DUP,\t \n\tSCTP_CMD_STRIKE,\t \n\tSCTP_CMD_HB_TIMERS_START,     \n\tSCTP_CMD_HB_TIMER_UPDATE,     \n\tSCTP_CMD_HB_TIMERS_STOP,      \n\tSCTP_CMD_PROBE_TIMER_UPDATE,  \n\tSCTP_CMD_TRANSPORT_HB_SENT,   \n\tSCTP_CMD_TRANSPORT_IDLE,      \n\tSCTP_CMD_TRANSPORT_ON,        \n\tSCTP_CMD_REPORT_ERROR,    \n\tSCTP_CMD_REPORT_BAD_TAG,  \n\tSCTP_CMD_PROCESS_CTSN,    \n\tSCTP_CMD_ASSOC_FAILED,\t  \n\tSCTP_CMD_DISCARD_PACKET,  \n\tSCTP_CMD_GEN_SHUTDOWN,    \n\tSCTP_CMD_PURGE_OUTQUEUE,  \n\tSCTP_CMD_SETUP_T2,        \n\tSCTP_CMD_RTO_PENDING,\t  \n\tSCTP_CMD_PART_DELIVER,\t  \n\tSCTP_CMD_RENEGE,          \n\tSCTP_CMD_SETUP_T4,\t  \n\tSCTP_CMD_PROCESS_OPERR,   \n\tSCTP_CMD_REPORT_FWDTSN,\t  \n\tSCTP_CMD_PROCESS_FWDTSN,  \n\tSCTP_CMD_CLEAR_INIT_TAG,  \n\tSCTP_CMD_DEL_NON_PRIMARY,  \n\tSCTP_CMD_T3_RTX_TIMERS_STOP,  \n\tSCTP_CMD_FORCE_PRIM_RETRAN,   \n\tSCTP_CMD_SET_SK_ERR,\t  \n\tSCTP_CMD_ASSOC_CHANGE,\t  \n\tSCTP_CMD_ADAPTATION_IND,  \n\tSCTP_CMD_PEER_NO_AUTH,    \n\tSCTP_CMD_ASSOC_SHKEY,     \n\tSCTP_CMD_T1_RETRAN,\t  \n\tSCTP_CMD_UPDATE_INITTAG,  \n\tSCTP_CMD_SEND_MSG,\t  \n\tSCTP_CMD_PURGE_ASCONF_QUEUE,  \n\tSCTP_CMD_SET_ASOC,\t  \n\tSCTP_CMD_LAST\n};\n\n \n#define SCTP_MAX_NUM_COMMANDS 20\n\nunion sctp_arg {\n\tvoid *zero_all;\t \n\t__s32 i32;\n\t__u32 u32;\n\t__be32 be32;\n\t__u16 u16;\n\t__u8 u8;\n\tint error;\n\t__be16 err;\n\tenum sctp_state state;\n\tenum sctp_event_timeout to;\n\tstruct sctp_chunk *chunk;\n\tstruct sctp_association *asoc;\n\tstruct sctp_transport *transport;\n\tstruct sctp_bind_addr *bp;\n\tstruct sctp_init_chunk *init;\n\tstruct sctp_ulpevent *ulpevent;\n\tstruct sctp_packet *packet;\n\tstruct sctp_sackhdr *sackh;\n\tstruct sctp_datamsg *msg;\n};\n\n \n\n#define SCTP_ARG_CONSTRUCTOR(name, type, elt) \\\nstatic inline union sctp_arg\t\\\nSCTP_## name (type arg)\t\t\\\n{ union sctp_arg retval;\\\n  retval.zero_all = NULL;\\\n  retval.elt = arg;\\\n  return retval;\\\n}\n\nSCTP_ARG_CONSTRUCTOR(I32,\t__s32, i32)\nSCTP_ARG_CONSTRUCTOR(U32,\t__u32, u32)\nSCTP_ARG_CONSTRUCTOR(BE32,\t__be32, be32)\nSCTP_ARG_CONSTRUCTOR(U16,\t__u16, u16)\nSCTP_ARG_CONSTRUCTOR(U8,\t__u8, u8)\nSCTP_ARG_CONSTRUCTOR(ERROR,     int, error)\nSCTP_ARG_CONSTRUCTOR(PERR,      __be16, err)\t \nSCTP_ARG_CONSTRUCTOR(STATE,\tenum sctp_state, state)\nSCTP_ARG_CONSTRUCTOR(TO,\tenum sctp_event_timeout, to)\nSCTP_ARG_CONSTRUCTOR(CHUNK,\tstruct sctp_chunk *, chunk)\nSCTP_ARG_CONSTRUCTOR(ASOC,\tstruct sctp_association *, asoc)\nSCTP_ARG_CONSTRUCTOR(TRANSPORT,\tstruct sctp_transport *, transport)\nSCTP_ARG_CONSTRUCTOR(BA,\tstruct sctp_bind_addr *, bp)\nSCTP_ARG_CONSTRUCTOR(PEER_INIT,\tstruct sctp_init_chunk *, init)\nSCTP_ARG_CONSTRUCTOR(ULPEVENT,  struct sctp_ulpevent *, ulpevent)\nSCTP_ARG_CONSTRUCTOR(PACKET,\tstruct sctp_packet *, packet)\nSCTP_ARG_CONSTRUCTOR(SACKH,\tstruct sctp_sackhdr *, sackh)\nSCTP_ARG_CONSTRUCTOR(DATAMSG,\tstruct sctp_datamsg *, msg)\n\nstatic inline union sctp_arg SCTP_FORCE(void)\n{\n\treturn SCTP_I32(1);\n}\n\nstatic inline union sctp_arg SCTP_NOFORCE(void)\n{\n\treturn SCTP_I32(0);\n}\n\nstatic inline union sctp_arg SCTP_NULL(void)\n{\n\tunion sctp_arg retval;\n\tretval.zero_all = NULL;\n\treturn retval;\n}\n\nstruct sctp_cmd {\n\tunion sctp_arg obj;\n\tenum sctp_verb verb;\n};\n\nstruct sctp_cmd_seq {\n\tstruct sctp_cmd cmds[SCTP_MAX_NUM_COMMANDS];\n\tstruct sctp_cmd *last_used_slot;\n\tstruct sctp_cmd *next_cmd;\n};\n\n\n \nstatic inline int sctp_init_cmd_seq(struct sctp_cmd_seq *seq)\n{\n\t \n\tseq->last_used_slot = seq->cmds + SCTP_MAX_NUM_COMMANDS;\n\tseq->next_cmd = seq->last_used_slot;\n\treturn 1;\t\t \n}\n\n\n \nstatic inline void sctp_add_cmd_sf(struct sctp_cmd_seq *seq,\n\t\t\t\t   enum sctp_verb verb, union sctp_arg obj)\n{\n\tstruct sctp_cmd *cmd = seq->last_used_slot - 1;\n\n\tBUG_ON(cmd < seq->cmds);\n\n\tcmd->verb = verb;\n\tcmd->obj = obj;\n\tseq->last_used_slot = cmd;\n}\n\n \nstatic inline struct sctp_cmd *sctp_next_cmd(struct sctp_cmd_seq *seq)\n{\n\tif (seq->next_cmd <= seq->last_used_slot)\n\t\treturn NULL;\n\n\treturn --seq->next_cmd;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}