{
  "module_name": "structs.h",
  "hash_id": "a35b5c4ab792866fef52fa04fcfd612d2d5a058ed410add82e8206bca4d3e283",
  "original_prompt": "Ingested from linux-6.6.14/include/net/sctp/structs.h",
  "human_readable_source": " \n \n\n#ifndef __sctp_structs_h__\n#define __sctp_structs_h__\n\n#include <linux/ktime.h>\n#include <linux/generic-radix-tree.h>\n#include <linux/rhashtable-types.h>\n#include <linux/socket.h>\t \n#include <linux/in.h>\t\t \n#include <linux/in6.h>\t\t \n#include <linux/ipv6.h>\n#include <asm/param.h>\t\t \n#include <linux/atomic.h>\t\t \n#include <linux/skbuff.h>\t \n#include <linux/workqueue.h>\t \n#include <linux/sctp.h>\t\t \n#include <net/sctp/auth.h>\t \n#include <net/ip.h>\t\t \n\n \nunion sctp_addr {\n\tstruct sockaddr_in v4;\n\tstruct sockaddr_in6 v6;\n\tstruct sockaddr sa;\n};\n\n \nstruct sctp_globals;\nstruct sctp_endpoint;\nstruct sctp_association;\nstruct sctp_transport;\nstruct sctp_packet;\nstruct sctp_chunk;\nstruct sctp_inq;\nstruct sctp_outq;\nstruct sctp_bind_addr;\nstruct sctp_ulpq;\nstruct sctp_ep_common;\nstruct crypto_shash;\nstruct sctp_stream;\n\n\n#include <net/sctp/tsnmap.h>\n#include <net/sctp/ulpevent.h>\n#include <net/sctp/ulpqueue.h>\n#include <net/sctp/stream_interleave.h>\n\n \n\nstruct sctp_bind_bucket {\n\tunsigned short\tport;\n\tsigned char\tfastreuse;\n\tsigned char\tfastreuseport;\n\tkuid_t\t\tfastuid;\n\tstruct hlist_node\tnode;\n\tstruct hlist_head\towner;\n\tstruct net\t*net;\n};\n\nstruct sctp_bind_hashbucket {\n\tspinlock_t\tlock;\n\tstruct hlist_head\tchain;\n};\n\n \nstruct sctp_hashbucket {\n\trwlock_t\tlock;\n\tstruct hlist_head\tchain;\n} __attribute__((__aligned__(8)));\n\n\n \nextern struct sctp_globals {\n\t \n\tstruct list_head address_families;\n\n\t \n\tstruct sctp_hashbucket *ep_hashtable;\n\t \n\tstruct sctp_bind_hashbucket *port_hashtable;\n\t \n\tstruct rhltable transport_hashtable;\n\n\t \n\tint ep_hashsize;\n\tint port_hashsize;\n\n\t \n\t__u16 max_instreams;\n\t__u16 max_outstreams;\n\n\t \n        bool checksum_disable;\n} sctp_globals;\n\n#define sctp_max_instreams\t\t(sctp_globals.max_instreams)\n#define sctp_max_outstreams\t\t(sctp_globals.max_outstreams)\n#define sctp_address_families\t\t(sctp_globals.address_families)\n#define sctp_ep_hashsize\t\t(sctp_globals.ep_hashsize)\n#define sctp_ep_hashtable\t\t(sctp_globals.ep_hashtable)\n#define sctp_port_hashsize\t\t(sctp_globals.port_hashsize)\n#define sctp_port_hashtable\t\t(sctp_globals.port_hashtable)\n#define sctp_transport_hashtable\t(sctp_globals.transport_hashtable)\n#define sctp_checksum_disable\t\t(sctp_globals.checksum_disable)\n\n \nenum sctp_socket_type {\n\tSCTP_SOCKET_UDP = 0,\n\tSCTP_SOCKET_UDP_HIGH_BANDWIDTH,\n\tSCTP_SOCKET_TCP\n};\n\n \nstruct sctp_sock {\n\t \n\tstruct inet_sock inet;\n\t \n\tenum sctp_socket_type type;\n\n\t \n\tstruct sctp_pf *pf;\n\n\t \n\tstruct crypto_shash *hmac;\n\tchar *sctp_hmac_alg;\n\n\t \n\tstruct sctp_endpoint *ep;\n\n\tstruct sctp_bind_bucket *bind_hash;\n\t \n\t__u16 default_stream;\n\t__u32 default_ppid;\n\t__u16 default_flags;\n\t__u32 default_context;\n\t__u32 default_timetolive;\n\t__u32 default_rcv_context;\n\tint max_burst;\n\n\t \n\t__u32 hbinterval;\n\t__u32 probe_interval;\n\n\t__be16 udp_port;\n\t__be16 encap_port;\n\n\t \n\t__u16 pathmaxrxt;\n\n\t__u32 flowlabel;\n\t__u8  dscp;\n\n\t__u16 pf_retrans;\n\t__u16 ps_retrans;\n\n\t \n\t__u32 pathmtu;\n\n\t \n\t__u32 sackdelay;\n\t__u32 sackfreq;\n\n\t \n\t__u32 param_flags;\n\n\t__u32 default_ss;\n\n\tstruct sctp_rtoinfo rtoinfo;\n\tstruct sctp_paddrparams paddrparam;\n\tstruct sctp_assocparams assocparams;\n\n\t \n\t__u16 subscribe;\n\tstruct sctp_initmsg initmsg;\n\n\tint user_frag;\n\n\t__u32 autoclose;\n\t__u32 adaptation_ind;\n\t__u32 pd_point;\n\t__u16\tnodelay:1,\n\t\tpf_expose:2,\n\t\treuse:1,\n\t\tdisable_fragments:1,\n\t\tv4mapped:1,\n\t\tfrag_interleave:1,\n\t\trecvrcvinfo:1,\n\t\trecvnxtinfo:1,\n\t\tdata_ready_signalled:1;\n\n\tatomic_t pd_mode;\n\n\t \n\n\t \n\tstruct sk_buff_head pd_lobby;\n\n\tstruct list_head auto_asconf_list;\n\tint do_auto_asconf;\n};\n\nstatic inline struct sctp_sock *sctp_sk(const struct sock *sk)\n{\n       return (struct sctp_sock *)sk;\n}\n\nstatic inline struct sock *sctp_opt2sk(const struct sctp_sock *sp)\n{\n       return (struct sock *)sp;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstruct sctp6_sock {\n       struct sctp_sock  sctp;\n       struct ipv6_pinfo inet6;\n};\n#endif  \n\n\n \n \n\nstruct sctp_cookie {\n\n\t \n\t__u32 my_vtag;\n\n\t \n\t__u32 peer_vtag;\n\n\t \n\n\t \n\t__u32 my_ttag;\n\n\t \n\t__u32 peer_ttag;\n\n\t \n\tktime_t expiration;\n\n\t \n\t__u16 sinit_num_ostreams;\n\t__u16 sinit_max_instreams;\n\n\t \n\t__u32 initial_tsn;\n\n\t \n\tunion sctp_addr peer_addr;\n\n\t \n\t__u16\t\tmy_port;\n\n\t__u8 prsctp_capable;\n\n\t \n\t__u8 padding;  \t\t\n\n\t__u32 adaptation_ind;\n\n\t__u8 auth_random[sizeof(struct sctp_paramhdr) +\n\t\t\t SCTP_AUTH_RANDOM_LENGTH];\n\t__u8 auth_hmacs[SCTP_AUTH_NUM_HMACS * sizeof(__u16) + 2];\n\t__u8 auth_chunks[sizeof(struct sctp_paramhdr) + SCTP_AUTH_MAX_CHUNKS];\n\n\t \n\t__u32 raw_addr_list_len;\n\t \n};\n\n\n \nstruct sctp_signed_cookie {\n\t__u8 signature[SCTP_SECRET_SIZE];\n\t__u32 __pad;\t\t \n\tstruct sctp_cookie c;\n} __packed;\n\n \nunion sctp_addr_param {\n\tstruct sctp_paramhdr p;\n\tstruct sctp_ipv4addr_param v4;\n\tstruct sctp_ipv6addr_param v6;\n};\n\n \nunion sctp_params {\n\tvoid *v;\n\tstruct sctp_paramhdr *p;\n\tstruct sctp_cookie_preserve_param *life;\n\tstruct sctp_hostname_param *dns;\n\tstruct sctp_cookie_param *cookie;\n\tstruct sctp_supported_addrs_param *sat;\n\tstruct sctp_ipv4addr_param *v4;\n\tstruct sctp_ipv6addr_param *v6;\n\tunion sctp_addr_param *addr;\n\tstruct sctp_adaptation_ind_param *aind;\n\tstruct sctp_supported_ext_param *ext;\n\tstruct sctp_random_param *random;\n\tstruct sctp_chunks_param *chunks;\n\tstruct sctp_hmac_algo_param *hmac_algo;\n\tstruct sctp_addip_param *addip;\n};\n\n \nstruct sctp_sender_hb_info {\n\tstruct sctp_paramhdr param_hdr;\n\tunion sctp_addr daddr;\n\tunsigned long sent_at;\n\t__u64 hb_nonce;\n\t__u32 probe_size;\n};\n\nint sctp_stream_init(struct sctp_stream *stream, __u16 outcnt, __u16 incnt,\n\t\t     gfp_t gfp);\nint sctp_stream_init_ext(struct sctp_stream *stream, __u16 sid);\nvoid sctp_stream_free(struct sctp_stream *stream);\nvoid sctp_stream_clear(struct sctp_stream *stream);\nvoid sctp_stream_update(struct sctp_stream *stream, struct sctp_stream *new);\n\n \n#define sctp_ssn_peek(stream, type, sid) \\\n\t(sctp_stream_##type((stream), (sid))->ssn)\n\n \n#define sctp_ssn_next(stream, type, sid) \\\n\t(sctp_stream_##type((stream), (sid))->ssn++)\n\n \n#define sctp_ssn_skip(stream, type, sid, ssn) \\\n\t(sctp_stream_##type((stream), (sid))->ssn = ssn + 1)\n\n \n#define sctp_mid_peek(stream, type, sid) \\\n\t(sctp_stream_##type((stream), (sid))->mid)\n\n \n#define sctp_mid_next(stream, type, sid) \\\n\t(sctp_stream_##type((stream), (sid))->mid++)\n\n \n#define sctp_mid_skip(stream, type, sid, mid) \\\n\t(sctp_stream_##type((stream), (sid))->mid = mid + 1)\n\n \n#define sctp_mid_uo_peek(stream, type, sid) \\\n\t(sctp_stream_##type((stream), (sid))->mid_uo)\n\n \n#define sctp_mid_uo_next(stream, type, sid) \\\n\t(sctp_stream_##type((stream), (sid))->mid_uo++)\n\n \nstruct sctp_af {\n\tint\t\t(*sctp_xmit)\t(struct sk_buff *skb,\n\t\t\t\t\t struct sctp_transport *);\n\tint\t\t(*setsockopt)\t(struct sock *sk,\n\t\t\t\t\t int level,\n\t\t\t\t\t int optname,\n\t\t\t\t\t sockptr_t optval,\n\t\t\t\t\t unsigned int optlen);\n\tint\t\t(*getsockopt)\t(struct sock *sk,\n\t\t\t\t\t int level,\n\t\t\t\t\t int optname,\n\t\t\t\t\t char __user *optval,\n\t\t\t\t\t int __user *optlen);\n\tvoid\t\t(*get_dst)\t(struct sctp_transport *t,\n\t\t\t\t\t union sctp_addr *saddr,\n\t\t\t\t\t struct flowi *fl,\n\t\t\t\t\t struct sock *sk);\n\tvoid\t\t(*get_saddr)\t(struct sctp_sock *sk,\n\t\t\t\t\t struct sctp_transport *t,\n\t\t\t\t\t struct flowi *fl);\n\tvoid\t\t(*copy_addrlist) (struct list_head *,\n\t\t\t\t\t  struct net_device *);\n\tint\t\t(*cmp_addr)\t(const union sctp_addr *addr1,\n\t\t\t\t\t const union sctp_addr *addr2);\n\tvoid\t\t(*addr_copy)\t(union sctp_addr *dst,\n\t\t\t\t\t union sctp_addr *src);\n\tvoid\t\t(*from_skb)\t(union sctp_addr *,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t int saddr);\n\tvoid\t\t(*from_sk)\t(union sctp_addr *,\n\t\t\t\t\t struct sock *sk);\n\tbool\t\t(*from_addr_param) (union sctp_addr *,\n\t\t\t\t\t    union sctp_addr_param *,\n\t\t\t\t\t    __be16 port, int iif);\n\tint\t\t(*to_addr_param) (const union sctp_addr *,\n\t\t\t\t\t  union sctp_addr_param *); \n\tint\t\t(*addr_valid)\t(union sctp_addr *,\n\t\t\t\t\t struct sctp_sock *,\n\t\t\t\t\t const struct sk_buff *);\n\tenum sctp_scope\t(*scope)(union sctp_addr *);\n\tvoid\t\t(*inaddr_any)\t(union sctp_addr *, __be16);\n\tint\t\t(*is_any)\t(const union sctp_addr *);\n\tint\t\t(*available)\t(union sctp_addr *,\n\t\t\t\t\t struct sctp_sock *);\n\tint\t\t(*skb_iif)\t(const struct sk_buff *sk);\n\tint\t\t(*skb_sdif)(const struct sk_buff *sk);\n\tint\t\t(*is_ce)\t(const struct sk_buff *sk);\n\tvoid\t\t(*seq_dump_addr)(struct seq_file *seq,\n\t\t\t\t\t union sctp_addr *addr);\n\tvoid\t\t(*ecn_capable)(struct sock *sk);\n\t__u16\t\tnet_header_len;\n\tint\t\tsockaddr_len;\n\tint\t\t(*ip_options_len)(struct sock *sk);\n\tsa_family_t\tsa_family;\n\tstruct list_head list;\n};\n\nstruct sctp_af *sctp_get_af_specific(sa_family_t);\nint sctp_register_af(struct sctp_af *);\n\n \nstruct sctp_pf {\n\tvoid (*event_msgname)(struct sctp_ulpevent *, char *, int *);\n\tvoid (*skb_msgname)  (struct sk_buff *, char *, int *);\n\tint  (*af_supported) (sa_family_t, struct sctp_sock *);\n\tint  (*cmp_addr) (const union sctp_addr *,\n\t\t\t  const union sctp_addr *,\n\t\t\t  struct sctp_sock *);\n\tint  (*bind_verify) (struct sctp_sock *, union sctp_addr *);\n\tint  (*send_verify) (struct sctp_sock *, union sctp_addr *);\n\tint  (*supported_addrs)(const struct sctp_sock *, __be16 *);\n\tstruct sock *(*create_accept_sk) (struct sock *sk,\n\t\t\t\t\t  struct sctp_association *asoc,\n\t\t\t\t\t  bool kern);\n\tint (*addr_to_user)(struct sctp_sock *sk, union sctp_addr *addr);\n\tvoid (*to_sk_saddr)(union sctp_addr *, struct sock *sk);\n\tvoid (*to_sk_daddr)(union sctp_addr *, struct sock *sk);\n\tvoid (*copy_ip_options)(struct sock *sk, struct sock *newsk);\n\tstruct sctp_af *af;\n};\n\n\n \nstruct sctp_datamsg {\n\t \n\tstruct list_head chunks;\n\t \n\trefcount_t refcnt;\n\t \n\tunsigned long expires_at;\n\t \n\tint send_error;\n\tu8 send_failed:1,\n\t   can_delay:1,\t \n\t   abandoned:1;\t \n};\n\nstruct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *,\n\t\t\t\t\t    struct sctp_sndrcvinfo *,\n\t\t\t\t\t    struct iov_iter *);\nvoid sctp_datamsg_free(struct sctp_datamsg *);\nvoid sctp_datamsg_put(struct sctp_datamsg *);\nvoid sctp_chunk_fail(struct sctp_chunk *, int error);\nint sctp_chunk_abandoned(struct sctp_chunk *);\n\n \nstruct sctp_chunk {\n\tstruct list_head list;\n\n\trefcount_t refcnt;\n\n\t \n\tint sent_count;\n\n\tunion {\n\t\t \n\t\tstruct list_head transmitted_list;\n\t\t \n\t\tstruct list_head stream_list;\n\t};\n\n\t \n\tstruct list_head frag_list;\n\n\t \n\tstruct sk_buff *skb;\n\n\tunion {\n\t\t \n\t\tstruct sk_buff *head_skb;\n\t\t \n\t\tstruct sctp_shared_key *shkey;\n\t};\n\n\t \n\n\t \n\tunion sctp_params param_hdr;\n\tunion {\n\t\t__u8 *v;\n\t\tstruct sctp_datahdr *data_hdr;\n\t\tstruct sctp_inithdr *init_hdr;\n\t\tstruct sctp_sackhdr *sack_hdr;\n\t\tstruct sctp_heartbeathdr *hb_hdr;\n\t\tstruct sctp_sender_hb_info *hbs_hdr;\n\t\tstruct sctp_shutdownhdr *shutdown_hdr;\n\t\tstruct sctp_signed_cookie *cookie_hdr;\n\t\tstruct sctp_ecnehdr *ecne_hdr;\n\t\tstruct sctp_cwrhdr *ecn_cwr_hdr;\n\t\tstruct sctp_errhdr *err_hdr;\n\t\tstruct sctp_addiphdr *addip_hdr;\n\t\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\t\tstruct sctp_authhdr *auth_hdr;\n\t\tstruct sctp_idatahdr *idata_hdr;\n\t\tstruct sctp_ifwdtsn_hdr *ifwdtsn_hdr;\n\t} subh;\n\n\t__u8 *chunk_end;\n\n\tstruct sctp_chunkhdr *chunk_hdr;\n\tstruct sctphdr *sctp_hdr;\n\n\t \n\tstruct sctp_sndrcvinfo sinfo;\n\n\t \n\tstruct sctp_association *asoc;\n\n\t \n\tstruct sctp_ep_common *rcvr;\n\n\t \n\tunsigned long sent_at;\n\n\t \n\tunion sctp_addr source;\n\t \n\tunion sctp_addr dest;\n\n\t \n\tstruct sctp_datamsg *msg;\n\n\t \n\tstruct sctp_transport *transport;\n\n\t \n\tstruct sk_buff *auth_chunk;\n\n#define SCTP_CAN_FRTX 0x0\n#define SCTP_NEED_FRTX 0x1\n#define SCTP_DONT_FRTX 0x2\n\t__u16\trtt_in_progress:1,\t \n\t\thas_tsn:1,\t\t \n\t\thas_ssn:1,\t\t \n#define has_mid has_ssn\n\t\tsingleton:1,\t\t \n\t\tend_of_packet:1,\t \n\t\tecn_ce_done:1,\t\t \n\t\tpdiscard:1,\t\t \n\t\ttsn_gap_acked:1,\t \n\t\tdata_accepted:1,\t \n\t\tauth:1,\t\t\t \n\t\thas_asconf:1,\t\t \n\t\tpmtu_probe:1,\t\t \n\t\ttsn_missing_report:2,\t \n\t\tfast_retransmit:2;\t \n};\n\n#define sctp_chunk_retransmitted(chunk)\t(chunk->sent_count > 1)\nvoid sctp_chunk_hold(struct sctp_chunk *);\nvoid sctp_chunk_put(struct sctp_chunk *);\nint sctp_user_addto_chunk(struct sctp_chunk *chunk, int len,\n\t\t\t  struct iov_iter *from);\nvoid sctp_chunk_free(struct sctp_chunk *);\nvoid  *sctp_addto_chunk(struct sctp_chunk *, int len, const void *data);\nstruct sctp_chunk *sctp_chunkify(struct sk_buff *,\n\t\t\t\t const struct sctp_association *,\n\t\t\t\t struct sock *, gfp_t gfp);\nvoid sctp_init_addrs(struct sctp_chunk *, union sctp_addr *,\n\t\t     union sctp_addr *);\nconst union sctp_addr *sctp_source(const struct sctp_chunk *chunk);\n\nstatic inline __u16 sctp_chunk_stream_no(struct sctp_chunk *ch)\n{\n\treturn ntohs(ch->subh.data_hdr->stream);\n}\n\nenum {\n\tSCTP_ADDR_NEW,\t\t \n\tSCTP_ADDR_SRC,\t\t \n\tSCTP_ADDR_DEL,\t\t \n};\n\n \nstruct sctp_sockaddr_entry {\n\tstruct list_head list;\n\tstruct rcu_head\trcu;\n\tunion sctp_addr a;\n\t__u8 state;\n\t__u8 valid;\n};\n\n#define SCTP_ADDRESS_TICK_DELAY\t500\n\n \nstruct sctp_packet {\n\t \n\t__u16 source_port;\n\t__u16 destination_port;\n\t__u32 vtag;\n\n\t \n\tstruct list_head chunk_list;\n\n\t \n\tsize_t overhead;\n\t \n\tsize_t size;\n\t \n\tsize_t max_size;\n\n\t \n\tstruct sctp_transport *transport;\n\n\t \n\tstruct sctp_chunk *auth;\n\n\tu8  has_cookie_echo:1,\t \n\t    has_sack:1,\t\t \n\t    has_auth:1,\t\t \n\t    has_data:1,\t\t \n\t    ipfragok:1;\t\t \n};\n\nvoid sctp_packet_init(struct sctp_packet *, struct sctp_transport *,\n\t\t      __u16 sport, __u16 dport);\nvoid sctp_packet_config(struct sctp_packet *, __u32 vtag, int);\nenum sctp_xmit sctp_packet_transmit_chunk(struct sctp_packet *packet,\n\t\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t\t  int one_packet, gfp_t gfp);\nenum sctp_xmit sctp_packet_append_chunk(struct sctp_packet *packet,\n\t\t\t\t\tstruct sctp_chunk *chunk);\nint sctp_packet_transmit(struct sctp_packet *, gfp_t);\nvoid sctp_packet_free(struct sctp_packet *);\n\nstatic inline int sctp_packet_empty(struct sctp_packet *packet)\n{\n\treturn packet->size == packet->overhead;\n}\n\n \nstruct sctp_transport {\n\t \n\tstruct list_head transports;\n\tstruct rhlist_head node;\n\n\t \n\trefcount_t refcnt;\n\t\t \n\t__u32\trto_pending:1,\n\n\t\t \n\t\thb_sent:1,\n\n\t\t \n\t\tpmtu_pending:1,\n\n\t\tdst_pending_confirm:1,\t \n\n\t\t \n\t\tsack_generation:1;\n\tu32 dst_cookie;\n\n\tstruct flowi fl;\n\n\t \n\tunion sctp_addr ipaddr;\n\n\t \n\tstruct sctp_af *af_specific;\n\n\t \n\tstruct sctp_association *asoc;\n\n\t \n\t \n\tunsigned long rto;\n\n\t__u32 rtt;\t\t \n\n\t \n\t__u32 rttvar;\n\n\t \n\t__u32 srtt;\n\n\t \n\t \n\t__u32 cwnd;\t\t   \n\n\t \n\t__u32 ssthresh;\n\n\t \n\t__u32 partial_bytes_acked;\n\n\t \n\t__u32 flight_size;\n\n\t__u32 burst_limited;\t \n\n\t \n\tstruct dst_entry *dst;\n\t \n\tunion sctp_addr saddr;\n\n\t \n\tunsigned long hbinterval;\n\tunsigned long probe_interval;\n\n\t \n\tunsigned long sackdelay;\n\t__u32 sackfreq;\n\n\tatomic_t mtu_info;\n\n\t \n\tktime_t last_time_heard;\n\n\t \n\tunsigned long last_time_sent;\n\n\t \n\tunsigned long last_time_ecne_reduced;\n\n\t__be16 encap_port;\n\n\t \n\t__u16 pathmaxrxt;\n\n\t__u32 flowlabel;\n\t__u8  dscp;\n\n\t \n\t__u16 pf_retrans;\n\t \n\t__u16 ps_retrans;\n\t \n\t__u32 pathmtu;\n\n\t \n\t__u32 param_flags;\n\n\t \n\tint init_sent_count;\n\n\t \n\tint state;\n\n\t \n\n\t \n\tunsigned short error_count;\n\n\t \n\tstruct timer_list T3_rtx_timer;\n\n\t \n\tstruct timer_list hb_timer;\n\n\t \n\tstruct timer_list proto_unreach_timer;\n\n\t \n\tstruct timer_list reconf_timer;\n\n\t \n\tstruct timer_list probe_timer;\n\n\t \n\tstruct list_head transmitted;\n\n\t \n\tstruct sctp_packet packet;\n\n\t \n\tstruct list_head send_ready;\n\n\t \n\tstruct {\n\t\t \n\t\t__u32 next_tsn_at_change;\n\n\t\t \n\t\tchar changeover_active;\n\n\t\t \n\t\tchar cycling_changeover;\n\n\t\t \n\t\tchar cacc_saw_newack;\n\t} cacc;\n\n\tstruct {\n\t\t__u16 pmtu;\n\t\t__u16 probe_size;\n\t\t__u16 probe_high;\n\t\t__u8 probe_count;\n\t\t__u8 state;\n\t} pl;  \n\n\t \n\t__u64 hb_nonce;\n\n\tstruct rcu_head rcu;\n};\n\nstruct sctp_transport *sctp_transport_new(struct net *, const union sctp_addr *,\n\t\t\t\t\t  gfp_t);\nvoid sctp_transport_set_owner(struct sctp_transport *,\n\t\t\t      struct sctp_association *);\nvoid sctp_transport_route(struct sctp_transport *, union sctp_addr *,\n\t\t\t  struct sctp_sock *);\nvoid sctp_transport_pmtu(struct sctp_transport *, struct sock *sk);\nvoid sctp_transport_free(struct sctp_transport *);\nvoid sctp_transport_reset_t3_rtx(struct sctp_transport *);\nvoid sctp_transport_reset_hb_timer(struct sctp_transport *);\nvoid sctp_transport_reset_reconf_timer(struct sctp_transport *transport);\nvoid sctp_transport_reset_probe_timer(struct sctp_transport *transport);\nvoid sctp_transport_reset_raise_timer(struct sctp_transport *transport);\nint sctp_transport_hold(struct sctp_transport *);\nvoid sctp_transport_put(struct sctp_transport *);\nvoid sctp_transport_update_rto(struct sctp_transport *, __u32);\nvoid sctp_transport_raise_cwnd(struct sctp_transport *, __u32, __u32);\nvoid sctp_transport_lower_cwnd(struct sctp_transport *t,\n\t\t\t       enum sctp_lower_cwnd reason);\nvoid sctp_transport_burst_limited(struct sctp_transport *);\nvoid sctp_transport_burst_reset(struct sctp_transport *);\nunsigned long sctp_transport_timeout(struct sctp_transport *);\nvoid sctp_transport_reset(struct sctp_transport *t);\nbool sctp_transport_update_pmtu(struct sctp_transport *t, u32 pmtu);\nvoid sctp_transport_immediate_rtx(struct sctp_transport *);\nvoid sctp_transport_dst_release(struct sctp_transport *t);\nvoid sctp_transport_dst_confirm(struct sctp_transport *t);\nvoid sctp_transport_pl_send(struct sctp_transport *t);\nbool sctp_transport_pl_recv(struct sctp_transport *t);\n\n\n \nstruct sctp_inq {\n\t \n\tstruct list_head in_chunk_list;\n\t \n\tstruct sctp_chunk *in_progress;\n\n\t \n\tstruct work_struct immediate;\n};\n\nvoid sctp_inq_init(struct sctp_inq *);\nvoid sctp_inq_free(struct sctp_inq *);\nvoid sctp_inq_push(struct sctp_inq *, struct sctp_chunk *packet);\nstruct sctp_chunk *sctp_inq_pop(struct sctp_inq *);\nstruct sctp_chunkhdr *sctp_inq_peek(struct sctp_inq *);\nvoid sctp_inq_set_th_handler(struct sctp_inq *, work_func_t);\n\n \nstruct sctp_outq {\n\tstruct sctp_association *asoc;\n\n\t \n\tstruct list_head out_chunk_list;\n\n\t \n\tstruct sctp_sched_ops *sched;\n\n\tunsigned int out_qlen;\t \n\n\t \n\tunsigned int error;\n\n\t \n\tstruct list_head control_chunk_list;\n\n\t \n\tstruct list_head sacked;\n\n\t \n\tstruct list_head retransmit;\n\n\t \n\tstruct list_head abandoned;\n\n\t \n\t__u32 outstanding_bytes;\n\n\t \n\tchar fast_rtx;\n\n\t \n\tchar cork;\n};\n\nvoid sctp_outq_init(struct sctp_association *, struct sctp_outq *);\nvoid sctp_outq_teardown(struct sctp_outq *);\nvoid sctp_outq_free(struct sctp_outq*);\nvoid sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk, gfp_t);\nint sctp_outq_sack(struct sctp_outq *, struct sctp_chunk *);\nint sctp_outq_is_empty(const struct sctp_outq *);\nvoid sctp_retransmit(struct sctp_outq *q, struct sctp_transport *transport,\n\t\t     enum sctp_retransmit_reason reason);\nvoid sctp_retransmit_mark(struct sctp_outq *, struct sctp_transport *, __u8);\nvoid sctp_outq_uncork(struct sctp_outq *, gfp_t gfp);\nvoid sctp_prsctp_prune(struct sctp_association *asoc,\n\t\t       struct sctp_sndrcvinfo *sinfo, int msg_len);\nvoid sctp_generate_fwdtsn(struct sctp_outq *q, __u32 sack_ctsn);\n \nstatic inline void sctp_outq_cork(struct sctp_outq *q)\n{\n\tq->cork = 1;\n}\n\n \nstruct sctp_input_cb {\n\tunion {\n\t\tstruct inet_skb_parm    h4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct inet6_skb_parm   h6;\n#endif\n\t} header;\n\tstruct sctp_chunk *chunk;\n\tstruct sctp_af *af;\n\t__be16 encap_port;\n};\n#define SCTP_INPUT_CB(__skb)\t((struct sctp_input_cb *)&((__skb)->cb[0]))\n\nstruct sctp_output_cb {\n\tstruct sk_buff *last;\n};\n#define SCTP_OUTPUT_CB(__skb)\t((struct sctp_output_cb *)&((__skb)->cb[0]))\n\nstatic inline const struct sk_buff *sctp_gso_headskb(const struct sk_buff *skb)\n{\n\tconst struct sctp_chunk *chunk = SCTP_INPUT_CB(skb)->chunk;\n\n\treturn chunk->head_skb ? : skb;\n}\n\n \nstruct sctp_bind_addr {\n\n\t \n\t__u16 port;\n\n\t \n\tstruct list_head address_list;\n};\n\nvoid sctp_bind_addr_init(struct sctp_bind_addr *, __u16 port);\nvoid sctp_bind_addr_free(struct sctp_bind_addr *);\nint sctp_bind_addr_copy(struct net *net, struct sctp_bind_addr *dest,\n\t\t\tconst struct sctp_bind_addr *src,\n\t\t\tenum sctp_scope scope, gfp_t gfp,\n\t\t\tint flags);\nint sctp_bind_addr_dup(struct sctp_bind_addr *dest,\n\t\t\tconst struct sctp_bind_addr *src,\n\t\t\tgfp_t gfp);\nint sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,\n\t\t       int new_size, __u8 addr_state, gfp_t gfp);\nint sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);\nint sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,\n\t\t\t struct sctp_sock *);\nint sctp_bind_addr_conflict(struct sctp_bind_addr *, const union sctp_addr *,\n\t\t\t struct sctp_sock *, struct sctp_sock *);\nint sctp_bind_addr_state(const struct sctp_bind_addr *bp,\n\t\t\t const union sctp_addr *addr);\nint sctp_bind_addrs_check(struct sctp_sock *sp,\n\t\t\t  struct sctp_sock *sp2, int cnt2);\nunion sctp_addr *sctp_find_unmatch_addr(struct sctp_bind_addr\t*bp,\n\t\t\t\t\tconst union sctp_addr\t*addrs,\n\t\t\t\t\tint\t\t\taddrcnt,\n\t\t\t\t\tstruct sctp_sock\t*opt);\nunion sctp_params sctp_bind_addrs_to_raw(const struct sctp_bind_addr *bp,\n\t\t\t\t\t int *addrs_len,\n\t\t\t\t\t gfp_t gfp);\nint sctp_raw_to_bind_addrs(struct sctp_bind_addr *bp, __u8 *raw, int len,\n\t\t\t   __u16 port, gfp_t gfp);\n\nenum sctp_scope sctp_scope(const union sctp_addr *addr);\nint sctp_in_scope(struct net *net, const union sctp_addr *addr,\n\t\t  const enum sctp_scope scope);\nint sctp_is_any(struct sock *sk, const union sctp_addr *addr);\nint sctp_is_ep_boundall(struct sock *sk);\n\n\n \nenum sctp_endpoint_type {\n\tSCTP_EP_TYPE_SOCKET,\n\tSCTP_EP_TYPE_ASSOCIATION,\n};\n\n \n\nstruct sctp_ep_common {\n\t \n\tenum sctp_endpoint_type type;\n\n\t \n\trefcount_t    refcnt;\n\tbool\t    dead;\n\n\t \n\tstruct sock *sk;\n\n\t \n\tstruct net *net;\n\n\t \n\tstruct sctp_inq\t  inqueue;\n\n\t \n\tstruct sctp_bind_addr bind_addr;\n};\n\n\n \n\nstruct sctp_endpoint {\n\t \n\tstruct sctp_ep_common base;\n\n\t \n\tstruct hlist_node node;\n\tint hashent;\n\n\t \n\t \n\tstruct list_head asocs;\n\n\t \n\t__u8 secret_key[SCTP_SECRET_SIZE];\n\n \t \n \t__u8 *digest;\n \n\t \n\t__u32 sndbuf_policy;\n\n\t \n\t__u32 rcvbuf_policy;\n\n\t \n\tstruct crypto_shash **auth_hmacs;\n\n\t \n\t struct sctp_hmac_algo_param *auth_hmacs_list;\n\n\t \n\tstruct sctp_chunks_param *auth_chunk_list;\n\n\t \n\tstruct list_head endpoint_shared_keys;\n\t__u16 active_key_id;\n\t__u8  ecn_enable:1,\n\t      auth_enable:1,\n\t      intl_enable:1,\n\t      prsctp_enable:1,\n\t      asconf_enable:1,\n\t      reconf_enable:1;\n\n\t__u8  strreset_enable;\n\tstruct rcu_head rcu;\n};\n\n \nstatic inline struct sctp_endpoint *sctp_ep(struct sctp_ep_common *base)\n{\n\tstruct sctp_endpoint *ep;\n\n\tep = container_of(base, struct sctp_endpoint, base);\n\treturn ep;\n}\n\n \nstruct sctp_endpoint *sctp_endpoint_new(struct sock *, gfp_t);\nvoid sctp_endpoint_free(struct sctp_endpoint *);\nvoid sctp_endpoint_put(struct sctp_endpoint *);\nint sctp_endpoint_hold(struct sctp_endpoint *ep);\nvoid sctp_endpoint_add_asoc(struct sctp_endpoint *, struct sctp_association *);\nstruct sctp_association *sctp_endpoint_lookup_assoc(\n\tconst struct sctp_endpoint *ep,\n\tconst union sctp_addr *paddr,\n\tstruct sctp_transport **);\nbool sctp_endpoint_is_peeled_off(struct sctp_endpoint *ep,\n\t\t\t\t const union sctp_addr *paddr);\nstruct sctp_endpoint *sctp_endpoint_is_match(struct sctp_endpoint *ep,\n\t\t\t\t\t     struct net *net,\n\t\t\t\t\t     const union sctp_addr *laddr,\n\t\t\t\t\t     int dif, int sdif);\nbool sctp_has_association(struct net *net, const union sctp_addr *laddr,\n\t\t\t  const union sctp_addr *paddr, int dif, int sdif);\n\nint sctp_verify_init(struct net *net, const struct sctp_endpoint *ep,\n\t\t     const struct sctp_association *asoc,\n\t\t     enum sctp_cid cid, struct sctp_init_chunk *peer_init,\n\t\t     struct sctp_chunk *chunk, struct sctp_chunk **err_chunk);\nint sctp_process_init(struct sctp_association *, struct sctp_chunk *chunk,\n\t\t      const union sctp_addr *peer,\n\t\t      struct sctp_init_chunk *init, gfp_t gfp);\n__u32 sctp_generate_tag(const struct sctp_endpoint *);\n__u32 sctp_generate_tsn(const struct sctp_endpoint *);\n\nstruct sctp_inithdr_host {\n\t__u32 init_tag;\n\t__u32 a_rwnd;\n\t__u16 num_outbound_streams;\n\t__u16 num_inbound_streams;\n\t__u32 initial_tsn;\n};\n\nstruct sctp_stream_priorities {\n\t \n\tstruct list_head prio_sched;\n\t \n\tstruct list_head active;\n\t \n\tstruct sctp_stream_out_ext *next;\n\t__u16 prio;\n\t__u16 users;\n};\n\nstruct sctp_stream_out_ext {\n\t__u64 abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];\n\t__u64 abandoned_sent[SCTP_PR_INDEX(MAX) + 1];\n\tstruct list_head outq;  \n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\tstruct list_head prio_list;\n\t\t\tstruct sctp_stream_priorities *prio_head;\n\t\t};\n\t\t \n\t\tstruct {\n\t\t\tstruct list_head rr_list;\n\t\t};\n\t\tstruct {\n\t\t\tstruct list_head fc_list;\n\t\t\t__u32 fc_length;\n\t\t\t__u16 fc_weight;\n\t\t};\n\t};\n};\n\nstruct sctp_stream_out {\n\tunion {\n\t\t__u32 mid;\n\t\t__u16 ssn;\n\t};\n\t__u32 mid_uo;\n\tstruct sctp_stream_out_ext *ext;\n\t__u8 state;\n};\n\nstruct sctp_stream_in {\n\tunion {\n\t\t__u32 mid;\n\t\t__u16 ssn;\n\t};\n\t__u32 mid_uo;\n\t__u32 fsn;\n\t__u32 fsn_uo;\n\tchar pd_mode;\n\tchar pd_mode_uo;\n};\n\nstruct sctp_stream {\n\tGENRADIX(struct sctp_stream_out) out;\n\tGENRADIX(struct sctp_stream_in)\tin;\n\n\t__u16 outcnt;\n\t__u16 incnt;\n\t \n\tstruct sctp_stream_out *out_curr;\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tstruct list_head prio_list;\n\t\t};\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tstruct list_head rr_list;\n\t\t\t \n\t\t\tstruct sctp_stream_out_ext *rr_next;\n\t\t};\n\t\tstruct {\n\t\t\tstruct list_head fc_list;\n\t\t};\n\t};\n\tstruct sctp_stream_interleave *si;\n};\n\nstatic inline struct sctp_stream_out *sctp_stream_out(\n\tstruct sctp_stream *stream,\n\t__u16 sid)\n{\n\treturn genradix_ptr(&stream->out, sid);\n}\n\nstatic inline struct sctp_stream_in *sctp_stream_in(\n\tstruct sctp_stream *stream,\n\t__u16 sid)\n{\n\treturn genradix_ptr(&stream->in, sid);\n}\n\n#define SCTP_SO(s, i) sctp_stream_out((s), (i))\n#define SCTP_SI(s, i) sctp_stream_in((s), (i))\n\n#define SCTP_STREAM_CLOSED\t\t0x00\n#define SCTP_STREAM_OPEN\t\t0x01\n\nstatic inline __u16 sctp_datachk_len(const struct sctp_stream *stream)\n{\n\treturn stream->si->data_chunk_len;\n}\n\nstatic inline __u16 sctp_datahdr_len(const struct sctp_stream *stream)\n{\n\treturn stream->si->data_chunk_len - sizeof(struct sctp_chunkhdr);\n}\n\nstatic inline __u16 sctp_ftsnchk_len(const struct sctp_stream *stream)\n{\n\treturn stream->si->ftsn_chunk_len;\n}\n\nstatic inline __u16 sctp_ftsnhdr_len(const struct sctp_stream *stream)\n{\n\treturn stream->si->ftsn_chunk_len - sizeof(struct sctp_chunkhdr);\n}\n\n \nstruct sctp_priv_assoc_stats {\n\t \n\tstruct sockaddr_storage obs_rto_ipaddr;\n\t__u64 max_obs_rto;\n\t \n\t__u64 isacks;\n\t__u64 osacks;\n\t \n\t__u64 opackets;\n\t__u64 ipackets;\n\t \n\t__u64 rtxchunks;\n\t \n\t__u64 outofseqtsns;\n\t \n\t__u64 idupchunks;\n\t \n\t__u64 gapcnt;\n\t \n\t__u64 ouodchunks;\n\t__u64 iuodchunks;\n\t \n\t__u64 oodchunks;\n\t__u64 iodchunks;\n\t \n\t__u64 octrlchunks;\n\t__u64 ictrlchunks;\n};\n\n \n\n\n \nstruct sctp_association {\n\n\t \n\tstruct sctp_ep_common base;\n\n\t \n\tstruct list_head asocs;\n\n\t \n\tsctp_assoc_t assoc_id;\n\n\t \n\tstruct sctp_endpoint *ep;\n\n\t \n\tstruct sctp_cookie c;\n\n\t \n\tstruct {\n\t\t \n\t\tstruct list_head transport_addr_list;\n\n\t\t \n\t\t__u32 rwnd;\n\n\t\t \n\t\t__u16 transport_count;\n\n\t\t \n\t\t__u16 port;\n\n\t\t \n\t\tstruct sctp_transport *primary_path;\n\n\t\t \n\t\tunion sctp_addr primary_addr;\n\n\t\t \n\t\tstruct sctp_transport *active_path;\n\n\t\t \n\t\tstruct sctp_transport *retran_path;\n\n\t\t \n\t\tstruct sctp_transport *last_sent_to;\n\n\t\t \n\t\tstruct sctp_transport *last_data_from;\n\n\t\t \n\t\tstruct sctp_tsnmap tsn_map;\n\n\t\t \n\t\t__be16 addip_disabled_mask;\n\n\t\t \n\t\t__u16\tecn_capable:1,       \n\t\t\tipv4_address:1,      \n\t\t\tipv6_address:1,      \n\t\t\tasconf_capable:1,    \n\t\t\tprsctp_capable:1,    \n\t\t\treconf_capable:1,    \n\t\t\tintl_capable:1,      \n\t\t\tauth_capable:1,      \n\t\t\t \n\t\t\tsack_needed:1,      \n\t\t\tsack_generation:1,\n\t\t\tzero_window_announced:1;\n\n\t\t__u32\tsack_cnt;\n\n\t\t__u32   adaptation_ind;\t  \n\n\t\tstruct sctp_inithdr_host i;\n\t\tvoid *cookie;\n\t\tint cookie_len;\n\n\t\t \n\t\t__u32 addip_serial;\n\n\t\t \n\t\tstruct sctp_random_param *peer_random;\n\t\tstruct sctp_chunks_param *peer_chunks;\n\t\tstruct sctp_hmac_algo_param *peer_hmacs;\n\t} peer;\n\n\t \n\tenum sctp_state state;\n\n\t \n\tint overall_error_count;\n\n\t \n\tktime_t cookie_life;\n\n\t \n\tunsigned long rto_initial;\n\tunsigned long rto_max;\n\tunsigned long rto_min;\n\n\t \n\tint max_burst;\n\n\t \n\tint max_retrans;\n\n\t \n\t__u16 pf_retrans;\n\t \n\t__u16 ps_retrans;\n\n\t \n\t__u16 max_init_attempts;\n\n\t \n\t__u16 init_retries;\n\n\t \n\tunsigned long max_init_timeo;\n\n\t \n\tunsigned long hbinterval;\n\tunsigned long probe_interval;\n\n\t__be16 encap_port;\n\n\t \n\t__u16 pathmaxrxt;\n\n\t__u32 flowlabel;\n\t__u8  dscp;\n\n\t \n\t__u8   pmtu_pending;\n\n\t \n\t__u32 pathmtu;\n\n\t \n\t__u32 param_flags;\n\n\t__u32 sackfreq;\n\t \n\tunsigned long sackdelay;\n\n\tunsigned long timeouts[SCTP_NUM_TIMEOUT_TYPES];\n\tstruct timer_list timers[SCTP_NUM_TIMEOUT_TYPES];\n\n\t \n\tstruct sctp_transport *shutdown_last_sent_to;\n\n\t \n\tstruct sctp_transport *init_last_sent_to;\n\n\t \n\tint shutdown_retries;\n\n\t \n\t__u32 next_tsn;\n\n\t \n\n\t__u32 ctsn_ack_point;\n\n\t \n\t__u32 adv_peer_ack_point;\n\n\t \n\t__u32 highest_sacked;\n\n\t \n\t__u32 fast_recovery_exit;\n\n\t \n\t__u8 fast_recovery;\n\n\t \n\t__u16 unack_data;\n\n\t \n\t__u32 rtx_data_chunks;\n\n\t \n\t__u32 rwnd;\n\n\t \n\t__u32 a_rwnd;\n\n\t \n\t__u32 rwnd_over;\n\n\t \n\t__u32 rwnd_press;\n\n\t \n\tint sndbuf_used;\n\n\t \n\tatomic_t rmem_alloc;\n\n\t \n\twait_queue_head_t\twait;\n\n\t \n\t__u32 frag_point;\n\t__u32 user_frag;\n\n\t \n\tint init_err_counter;\n\n\t \n\tint init_cycle;\n\n\t \n\t__u16 default_stream;\n\t__u16 default_flags;\n\t__u32 default_ppid;\n\t__u32 default_context;\n\t__u32 default_timetolive;\n\n\t \n\t__u32 default_rcv_context;\n\n\t \n\tstruct sctp_stream stream;\n\n\t \n\tstruct sctp_outq outqueue;\n\n\t \n\tstruct sctp_ulpq ulpq;\n\n\t \n\t__u32 last_ecne_tsn;\n\n\t \n\t__u32 last_cwr_tsn;\n\n\t \n\tint numduptsns;\n\n\t \n\n\n\n\t \n\tstruct sctp_chunk *addip_last_asconf;\n\n\t \n\tstruct list_head asconf_ack_list;\n\n\t \n\tstruct list_head addip_chunk_list;\n\n\t \n\t__u32 addip_serial;\n\tint src_out_of_asoc_ok;\n\tunion sctp_addr *asconf_addr_del_pending;\n\tstruct sctp_transport *new_transport;\n\n\t \n\tstruct list_head endpoint_shared_keys;\n\n\t \n\tstruct sctp_auth_bytes *asoc_shared_key;\n\tstruct sctp_shared_key *shkey;\n\n\t \n\t__u16 default_hmac_id;\n\n\t__u16 active_key_id;\n\n\t__u8 need_ecne:1,\t \n\t     temp:1,\t\t \n\t     pf_expose:2,        \n\t     force_delay:1;\n\n\t__u8 strreset_enable;\n\t__u8 strreset_outstanding;  \n\n\t__u32 strreset_outseq;  \n\t__u32 strreset_inseq;  \n\t__u32 strreset_result[2];  \n\n\tstruct sctp_chunk *strreset_chunk;  \n\n\tstruct sctp_priv_assoc_stats stats;\n\n\tint sent_cnt_removable;\n\n\t__u16 subscribe;\n\n\t__u64 abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];\n\t__u64 abandoned_sent[SCTP_PR_INDEX(MAX) + 1];\n\n\t \n\n\tu32 secid;\n\tu32 peer_secid;\n\n\tstruct rcu_head rcu;\n};\n\n\n \nenum {\n\tSCTP_ASSOC_EYECATCHER = 0xa550c123,\n};\n\n \nstatic inline struct sctp_association *sctp_assoc(struct sctp_ep_common *base)\n{\n\tstruct sctp_association *asoc;\n\n\tasoc = container_of(base, struct sctp_association, base);\n\treturn asoc;\n}\n\n \n\n\nstruct sctp_association *\nsctp_association_new(const struct sctp_endpoint *ep, const struct sock *sk,\n\t\t     enum sctp_scope scope, gfp_t gfp);\nvoid sctp_association_free(struct sctp_association *);\nvoid sctp_association_put(struct sctp_association *);\nvoid sctp_association_hold(struct sctp_association *);\n\nstruct sctp_transport *sctp_assoc_choose_alter_transport(\n\tstruct sctp_association *, struct sctp_transport *);\nvoid sctp_assoc_update_retran_path(struct sctp_association *);\nstruct sctp_transport *sctp_assoc_lookup_paddr(const struct sctp_association *,\n\t\t\t\t\t  const union sctp_addr *);\nint sctp_assoc_lookup_laddr(struct sctp_association *asoc,\n\t\t\t    const union sctp_addr *laddr);\nstruct sctp_transport *sctp_assoc_add_peer(struct sctp_association *,\n\t\t\t\t     const union sctp_addr *address,\n\t\t\t\t     const gfp_t gfp,\n\t\t\t\t     const int peer_state);\nvoid sctp_assoc_del_peer(struct sctp_association *asoc,\n\t\t\t const union sctp_addr *addr);\nvoid sctp_assoc_rm_peer(struct sctp_association *asoc,\n\t\t\t struct sctp_transport *peer);\nvoid sctp_assoc_control_transport(struct sctp_association *asoc,\n\t\t\t\t  struct sctp_transport *transport,\n\t\t\t\t  enum sctp_transport_cmd command,\n\t\t\t\t  sctp_sn_error_t error);\nstruct sctp_transport *sctp_assoc_lookup_tsn(struct sctp_association *, __u32);\nvoid sctp_assoc_migrate(struct sctp_association *, struct sock *);\nint sctp_assoc_update(struct sctp_association *old,\n\t\t      struct sctp_association *new);\n\n__u32 sctp_association_get_next_tsn(struct sctp_association *);\n\nvoid sctp_assoc_update_frag_point(struct sctp_association *asoc);\nvoid sctp_assoc_set_pmtu(struct sctp_association *asoc, __u32 pmtu);\nvoid sctp_assoc_sync_pmtu(struct sctp_association *asoc);\nvoid sctp_assoc_rwnd_increase(struct sctp_association *, unsigned int);\nvoid sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned int);\nvoid sctp_assoc_set_primary(struct sctp_association *,\n\t\t\t    struct sctp_transport *);\nvoid sctp_assoc_del_nonprimary_peers(struct sctp_association *,\n\t\t\t\t    struct sctp_transport *);\nint sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,\n\t\t\t\t     enum sctp_scope scope, gfp_t gfp);\nint sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *,\n\t\t\t\t\t struct sctp_cookie*,\n\t\t\t\t\t gfp_t gfp);\nint sctp_assoc_set_id(struct sctp_association *, gfp_t);\nvoid sctp_assoc_clean_asconf_ack_cache(const struct sctp_association *asoc);\nstruct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial);\nvoid sctp_asconf_queue_teardown(struct sctp_association *asoc);\n\nint sctp_cmp_addr_exact(const union sctp_addr *ss1,\n\t\t\tconst union sctp_addr *ss2);\nstruct sctp_chunk *sctp_get_ecne_prepend(struct sctp_association *asoc);\n\n \nstruct sctp_cmsgs {\n\tstruct sctp_initmsg *init;\n\tstruct sctp_sndrcvinfo *srinfo;\n\tstruct sctp_sndinfo *sinfo;\n\tstruct sctp_prinfo *prinfo;\n\tstruct sctp_authinfo *authinfo;\n\tstruct msghdr *addrs_msg;\n};\n\n \nstruct sctp_dbg_objcnt_entry {\n\tchar *label;\n\tatomic_t *counter;\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}