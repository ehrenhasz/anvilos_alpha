{
  "module_name": "scm.h",
  "hash_id": "ef09dfa640d74a4d76b290128bc1a54cdb22feebe0fb2414f0b9d4734cab9b80",
  "original_prompt": "Ingested from linux-6.6.14/include/net/scm.h",
  "human_readable_source": " \n#ifndef __LINUX_NET_SCM_H\n#define __LINUX_NET_SCM_H\n\n#include <linux/limits.h>\n#include <linux/net.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/nsproxy.h>\n#include <linux/sched/signal.h>\n#include <net/compat.h>\n\n \n#define SCM_MAX_FD\t253\n\nstruct scm_creds {\n\tu32\tpid;\n\tkuid_t\tuid;\n\tkgid_t\tgid;\n};\n\nstruct scm_fp_list {\n\tshort\t\t\tcount;\n\tshort\t\t\tmax;\n\tstruct user_struct\t*user;\n\tstruct file\t\t*fp[SCM_MAX_FD];\n};\n\nstruct scm_cookie {\n\tstruct pid\t\t*pid;\t\t \n\tstruct scm_fp_list\t*fp;\t\t \n\tstruct scm_creds\tcreds;\t\t \n#ifdef CONFIG_SECURITY_NETWORK\n\tu32\t\t\tsecid;\t\t \n#endif\n};\n\nvoid scm_detach_fds(struct msghdr *msg, struct scm_cookie *scm);\nvoid scm_detach_fds_compat(struct msghdr *msg, struct scm_cookie *scm);\nint __scm_send(struct socket *sock, struct msghdr *msg, struct scm_cookie *scm);\nvoid __scm_destroy(struct scm_cookie *scm);\nstruct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl);\n\n#ifdef CONFIG_SECURITY_NETWORK\nstatic __inline__ void unix_get_peersec_dgram(struct socket *sock, struct scm_cookie *scm)\n{\n\tsecurity_socket_getpeersec_dgram(sock, NULL, &scm->secid);\n}\n#else\nstatic __inline__ void unix_get_peersec_dgram(struct socket *sock, struct scm_cookie *scm)\n{ }\n#endif  \n\nstatic __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, kuid_t uid, kgid_t gid)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = uid;\n\tscm->creds.gid = gid;\n}\n\nstatic __inline__ void scm_destroy_cred(struct scm_cookie *scm)\n{\n\tput_pid(scm->pid);\n\tscm->pid  = NULL;\n}\n\nstatic __inline__ void scm_destroy(struct scm_cookie *scm)\n{\n\tscm_destroy_cred(scm);\n\tif (scm->fp)\n\t\t__scm_destroy(scm);\n}\n\nstatic __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm, bool forcecreds)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tscm->creds.uid = INVALID_UID;\n\tscm->creds.gid = INVALID_GID;\n\tif (forcecreds)\n\t\tscm_set_cred(scm, task_tgid(current), current_uid(), current_gid());\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}\n\n#ifdef CONFIG_SECURITY_NETWORK\nstatic inline void scm_passec(struct socket *sock, struct msghdr *msg, struct scm_cookie *scm)\n{\n\tchar *secdata;\n\tu32 seclen;\n\tint err;\n\n\tif (test_bit(SOCK_PASSSEC, &sock->flags)) {\n\t\terr = security_secid_to_secctx(scm->secid, &secdata, &seclen);\n\n\t\tif (!err) {\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_SECURITY, seclen, secdata);\n\t\t\tsecurity_release_secctx(secdata, seclen);\n\t\t}\n\t}\n}\n\nstatic inline bool scm_has_secdata(struct socket *sock)\n{\n\treturn test_bit(SOCK_PASSSEC, &sock->flags);\n}\n#else\nstatic inline void scm_passec(struct socket *sock, struct msghdr *msg, struct scm_cookie *scm)\n{ }\n\nstatic inline bool scm_has_secdata(struct socket *sock)\n{\n\treturn false;\n}\n#endif  \n\nstatic __inline__ void scm_pidfd_recv(struct msghdr *msg, struct scm_cookie *scm)\n{\n\tstruct file *pidfd_file = NULL;\n\tint len, pidfd;\n\n\t \n\tif (msg->msg_flags & MSG_CMSG_COMPAT)\n\t\tlen = sizeof(struct compat_cmsghdr) + sizeof(int);\n\telse\n\t\tlen = sizeof(struct cmsghdr) + sizeof(int);\n\n\tif (msg->msg_controllen < len) {\n\t\tmsg->msg_flags |= MSG_CTRUNC;\n\t\treturn;\n\t}\n\n\tif (!scm->pid)\n\t\treturn;\n\n\tpidfd = pidfd_prepare(scm->pid, 0, &pidfd_file);\n\n\tif (put_cmsg(msg, SOL_SOCKET, SCM_PIDFD, sizeof(int), &pidfd)) {\n\t\tif (pidfd_file) {\n\t\t\tput_unused_fd(pidfd);\n\t\t\tfput(pidfd_file);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (pidfd_file)\n\t\tfd_install(pidfd, pidfd_file);\n}\n\nstatic inline bool __scm_recv_common(struct socket *sock, struct msghdr *msg,\n\t\t\t\t     struct scm_cookie *scm, int flags)\n{\n\tif (!msg->msg_control) {\n\t\tif (test_bit(SOCK_PASSCRED, &sock->flags) ||\n\t\t    test_bit(SOCK_PASSPIDFD, &sock->flags) ||\n\t\t    scm->fp || scm_has_secdata(sock))\n\t\t\tmsg->msg_flags |= MSG_CTRUNC;\n\t\tscm_destroy(scm);\n\t\treturn false;\n\t}\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags)) {\n\t\tstruct user_namespace *current_ns = current_user_ns();\n\t\tstruct ucred ucreds = {\n\t\t\t.pid = scm->creds.pid,\n\t\t\t.uid = from_kuid_munged(current_ns, scm->creds.uid),\n\t\t\t.gid = from_kgid_munged(current_ns, scm->creds.gid),\n\t\t};\n\t\tput_cmsg(msg, SOL_SOCKET, SCM_CREDENTIALS, sizeof(ucreds), &ucreds);\n\t}\n\n\tscm_passec(sock, msg, scm);\n\n\tif (scm->fp)\n\t\tscm_detach_fds(msg, scm);\n\n\treturn true;\n}\n\nstatic inline void scm_recv(struct socket *sock, struct msghdr *msg,\n\t\t\t    struct scm_cookie *scm, int flags)\n{\n\tif (!__scm_recv_common(sock, msg, scm, flags))\n\t\treturn;\n\n\tscm_destroy_cred(scm);\n}\n\nstatic inline void scm_recv_unix(struct socket *sock, struct msghdr *msg,\n\t\t\t\t struct scm_cookie *scm, int flags)\n{\n\tif (!__scm_recv_common(sock, msg, scm, flags))\n\t\treturn;\n\n\tif (test_bit(SOCK_PASSPIDFD, &sock->flags))\n\t\tscm_pidfd_recv(msg, scm);\n\n\tscm_destroy_cred(scm);\n}\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}