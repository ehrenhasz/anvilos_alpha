{
  "module_name": "mptcp.h",
  "hash_id": "f0e3835ac408aa71f7059ef6853fe7494760314539718a361a8d3be1fac517c2",
  "original_prompt": "Ingested from linux-6.6.14/include/net/mptcp.h",
  "human_readable_source": " \n \n\n#ifndef __NET_MPTCP_H\n#define __NET_MPTCP_H\n\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n\nstruct mptcp_info;\nstruct mptcp_sock;\nstruct seq_file;\n\n \nstruct mptcp_ext {\n\tunion {\n\t\tu64\tdata_ack;\n\t\tu32\tdata_ack32;\n\t};\n\tu64\t\tdata_seq;\n\tu32\t\tsubflow_seq;\n\tu16\t\tdata_len;\n\t__sum16\t\tcsum;\n\tu8\t\tuse_map:1,\n\t\t\tdsn64:1,\n\t\t\tdata_fin:1,\n\t\t\tuse_ack:1,\n\t\t\tack64:1,\n\t\t\tmpc_map:1,\n\t\t\tfrozen:1,\n\t\t\treset_transient:1;\n\tu8\t\treset_reason:4,\n\t\t\tcsum_reqd:1,\n\t\t\tinfinite_map:1;\n};\n\n#define MPTCPOPT_HMAC_LEN\t20\n#define MPTCP_RM_IDS_MAX\t8\n\nstruct mptcp_rm_list {\n\tu8 ids[MPTCP_RM_IDS_MAX];\n\tu8 nr;\n};\n\nstruct mptcp_addr_info {\n\tu8\t\t\tid;\n\tsa_family_t\t\tfamily;\n\t__be16\t\t\tport;\n\tunion {\n\t\tstruct in_addr\taddr;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t\tstruct in6_addr\taddr6;\n#endif\n\t};\n};\n\nstruct mptcp_out_options {\n#if IS_ENABLED(CONFIG_MPTCP)\n\tu16 suboptions;\n\tstruct mptcp_rm_list rm_list;\n\tu8 join_id;\n\tu8 backup;\n\tu8 reset_reason:4,\n\t   reset_transient:1,\n\t   csum_reqd:1,\n\t   allow_join_id0:1;\n\tunion {\n\t\tstruct {\n\t\t\tu64 sndr_key;\n\t\t\tu64 rcvr_key;\n\t\t\tu64 data_seq;\n\t\t\tu32 subflow_seq;\n\t\t\tu16 data_len;\n\t\t\t__sum16 csum;\n\t\t};\n\t\tstruct {\n\t\t\tstruct mptcp_addr_info addr;\n\t\t\tu64 ahmac;\n\t\t};\n\t\tstruct {\n\t\t\tstruct mptcp_ext ext_copy;\n\t\t\tu64 fail_seq;\n\t\t};\n\t\tstruct {\n\t\t\tu32 nonce;\n\t\t\tu32 token;\n\t\t\tu64 thmac;\n\t\t\tu8 hmac[MPTCPOPT_HMAC_LEN];\n\t\t};\n\t};\n#endif\n};\n\n#define MPTCP_SCHED_NAME_MAX\t16\n#define MPTCP_SUBFLOWS_MAX\t8\n\nstruct mptcp_sched_data {\n\tbool\treinject;\n\tu8\tsubflows;\n\tstruct mptcp_subflow_context *contexts[MPTCP_SUBFLOWS_MAX];\n};\n\nstruct mptcp_sched_ops {\n\tint (*get_subflow)(struct mptcp_sock *msk,\n\t\t\t   struct mptcp_sched_data *data);\n\n\tchar\t\t\tname[MPTCP_SCHED_NAME_MAX];\n\tstruct module\t\t*owner;\n\tstruct list_head\tlist;\n\n\tvoid (*init)(struct mptcp_sock *msk);\n\tvoid (*release)(struct mptcp_sock *msk);\n} ____cacheline_aligned_in_smp;\n\n#ifdef CONFIG_MPTCP\nvoid mptcp_init(void);\n\nstatic inline bool sk_is_mptcp(const struct sock *sk)\n{\n\treturn tcp_sk(sk)->is_mptcp;\n}\n\nstatic inline bool rsk_is_mptcp(const struct request_sock *req)\n{\n\treturn tcp_rsk(req)->is_mptcp;\n}\n\nstatic inline bool rsk_drop_req(const struct request_sock *req)\n{\n\treturn tcp_rsk(req)->is_mptcp && tcp_rsk(req)->drop_req;\n}\n\nvoid mptcp_space(const struct sock *ssk, int *space, int *full_space);\nbool mptcp_syn_options(struct sock *sk, const struct sk_buff *skb,\n\t\t       unsigned int *size, struct mptcp_out_options *opts);\nbool mptcp_synack_options(const struct request_sock *req, unsigned int *size,\n\t\t\t  struct mptcp_out_options *opts);\nbool mptcp_established_options(struct sock *sk, struct sk_buff *skb,\n\t\t\t       unsigned int *size, unsigned int remaining,\n\t\t\t       struct mptcp_out_options *opts);\nbool mptcp_incoming_options(struct sock *sk, struct sk_buff *skb);\n\nvoid mptcp_write_options(struct tcphdr *th, __be32 *ptr, struct tcp_sock *tp,\n\t\t\t struct mptcp_out_options *opts);\n\nvoid mptcp_diag_fill_info(struct mptcp_sock *msk, struct mptcp_info *info);\n\n \nstatic inline void mptcp_skb_ext_move(struct sk_buff *to,\n\t\t\t\t      struct sk_buff *from)\n{\n\tif (!skb_ext_exist(from, SKB_EXT_MPTCP))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(to->active_extensions))\n\t\tskb_ext_put(to);\n\n\tto->active_extensions = from->active_extensions;\n\tto->extensions = from->extensions;\n\tfrom->active_extensions = 0;\n}\n\nstatic inline void mptcp_skb_ext_copy(struct sk_buff *to,\n\t\t\t\t      struct sk_buff *from)\n{\n\tstruct mptcp_ext *from_ext;\n\n\tfrom_ext = skb_ext_find(from, SKB_EXT_MPTCP);\n\tif (!from_ext)\n\t\treturn;\n\n\tfrom_ext->frozen = 1;\n\tskb_ext_copy(to, from);\n}\n\nstatic inline bool mptcp_ext_matches(const struct mptcp_ext *to_ext,\n\t\t\t\t     const struct mptcp_ext *from_ext)\n{\n\t \n\treturn !from_ext ||\n\t       (to_ext && from_ext &&\n\t        !memcmp(from_ext, to_ext, sizeof(struct mptcp_ext)));\n}\n\n \nstatic inline bool mptcp_skb_can_collapse(const struct sk_buff *to,\n\t\t\t\t\t  const struct sk_buff *from)\n{\n\treturn mptcp_ext_matches(skb_ext_find(to, SKB_EXT_MPTCP),\n\t\t\t\t skb_ext_find(from, SKB_EXT_MPTCP));\n}\n\nvoid mptcp_seq_show(struct seq_file *seq);\nint mptcp_subflow_init_cookie_req(struct request_sock *req,\n\t\t\t\t  const struct sock *sk_listener,\n\t\t\t\t  struct sk_buff *skb);\nstruct request_sock *mptcp_subflow_reqsk_alloc(const struct request_sock_ops *ops,\n\t\t\t\t\t       struct sock *sk_listener,\n\t\t\t\t\t       bool attach_listener);\n\n__be32 mptcp_get_reset_option(const struct sk_buff *skb);\n\nstatic inline __be32 mptcp_reset_option(const struct sk_buff *skb)\n{\n\tif (skb_ext_exist(skb, SKB_EXT_MPTCP))\n\t\treturn mptcp_get_reset_option(skb);\n\n\treturn htonl(0u);\n}\n#else\n\nstatic inline void mptcp_init(void)\n{\n}\n\nstatic inline bool sk_is_mptcp(const struct sock *sk)\n{\n\treturn false;\n}\n\nstatic inline bool rsk_is_mptcp(const struct request_sock *req)\n{\n\treturn false;\n}\n\nstatic inline bool rsk_drop_req(const struct request_sock *req)\n{\n\treturn false;\n}\n\nstatic inline bool mptcp_syn_options(struct sock *sk, const struct sk_buff *skb,\n\t\t\t\t     unsigned int *size,\n\t\t\t\t     struct mptcp_out_options *opts)\n{\n\treturn false;\n}\n\nstatic inline bool mptcp_synack_options(const struct request_sock *req,\n\t\t\t\t\tunsigned int *size,\n\t\t\t\t\tstruct mptcp_out_options *opts)\n{\n\treturn false;\n}\n\nstatic inline bool mptcp_established_options(struct sock *sk,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     unsigned int *size,\n\t\t\t\t\t     unsigned int remaining,\n\t\t\t\t\t     struct mptcp_out_options *opts)\n{\n\treturn false;\n}\n\nstatic inline bool mptcp_incoming_options(struct sock *sk,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\treturn true;\n}\n\nstatic inline void mptcp_skb_ext_move(struct sk_buff *to,\n\t\t\t\t      const struct sk_buff *from)\n{\n}\n\nstatic inline void mptcp_skb_ext_copy(struct sk_buff *to,\n\t\t\t\t      struct sk_buff *from)\n{\n}\n\nstatic inline bool mptcp_skb_can_collapse(const struct sk_buff *to,\n\t\t\t\t\t  const struct sk_buff *from)\n{\n\treturn true;\n}\n\nstatic inline void mptcp_space(const struct sock *ssk, int *s, int *fs) { }\nstatic inline void mptcp_seq_show(struct seq_file *seq) { }\n\nstatic inline int mptcp_subflow_init_cookie_req(struct request_sock *req,\n\t\t\t\t\t\tconst struct sock *sk_listener,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\treturn 0;  \n}\n\nstatic inline struct request_sock *mptcp_subflow_reqsk_alloc(const struct request_sock_ops *ops,\n\t\t\t\t\t\t\t     struct sock *sk_listener,\n\t\t\t\t\t\t\t     bool attach_listener)\n{\n\treturn NULL;\n}\n\nstatic inline __be32 mptcp_reset_option(const struct sk_buff *skb)  { return htonl(0u); }\n#endif  \n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\nint mptcpv6_init(void);\nvoid mptcpv6_handle_mapped(struct sock *sk, bool mapped);\n#elif IS_ENABLED(CONFIG_IPV6)\nstatic inline int mptcpv6_init(void) { return 0; }\nstatic inline void mptcpv6_handle_mapped(struct sock *sk, bool mapped) { }\n#endif\n\n#if defined(CONFIG_MPTCP) && defined(CONFIG_BPF_SYSCALL)\nstruct mptcp_sock *bpf_mptcp_sock_from_subflow(struct sock *sk);\n#else\nstatic inline struct mptcp_sock *bpf_mptcp_sock_from_subflow(struct sock *sk) { return NULL; }\n#endif\n\n#if !IS_ENABLED(CONFIG_MPTCP)\nstruct mptcp_sock { };\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}