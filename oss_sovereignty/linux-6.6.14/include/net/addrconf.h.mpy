{
  "module_name": "addrconf.h",
  "hash_id": "dd7de5fbe6a7ff7f4044f0acdb914b2def6fd157af4c5fb54de883a0647f84fb",
  "original_prompt": "Ingested from linux-6.6.14/include/net/addrconf.h",
  "human_readable_source": " \n#ifndef _ADDRCONF_H\n#define _ADDRCONF_H\n\n#define MAX_RTR_SOLICITATIONS\t\t-1\t\t \n#define RTR_SOLICITATION_INTERVAL\t(4*HZ)\n#define RTR_SOLICITATION_MAX_INTERVAL\t(3600*HZ)\t \n\n#define MIN_VALID_LIFETIME\t\t(2*3600)\t \n\n#define TEMP_VALID_LIFETIME\t\t(7*86400)\n#define TEMP_PREFERRED_LIFETIME\t\t(86400)\n#define REGEN_MAX_RETRY\t\t\t(3)\n#define MAX_DESYNC_FACTOR\t\t(600)\n\n#define ADDR_CHECK_FREQUENCY\t\t(120*HZ)\n\n#define IPV6_MAX_ADDRESSES\t\t16\n\n#define ADDRCONF_TIMER_FUZZ_MINUS\t(HZ > 50 ? HZ / 50 : 1)\n#define ADDRCONF_TIMER_FUZZ\t\t(HZ / 4)\n#define ADDRCONF_TIMER_FUZZ_MAX\t\t(HZ)\n\n#define ADDRCONF_NOTIFY_PRIORITY\t0\n\n#include <linux/in.h>\n#include <linux/in6.h>\n\nstruct prefix_info {\n\t__u8\t\t\ttype;\n\t__u8\t\t\tlength;\n\t__u8\t\t\tprefix_len;\n\n\tunion __packed {\n\t\t__u8\t\tflags;\n\t\tstruct __packed {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t\t\t__u8\tonlink : 1,\n\t\t\t \tautoconf : 1,\n\t\t\t\treserved : 6;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\t\t\t__u8\treserved : 6,\n\t\t\t\tautoconf : 1,\n\t\t\t\tonlink : 1;\n#else\n#error \"Please fix <asm/byteorder.h>\"\n#endif\n\t\t};\n\t};\n\t__be32\t\t\tvalid;\n\t__be32\t\t\tprefered;\n\t__be32\t\t\treserved2;\n\n\tstruct in6_addr\t\tprefix;\n};\n\n \nstatic_assert(sizeof(struct prefix_info) == 32);\n\n#include <linux/ipv6.h>\n#include <linux/netdevice.h>\n#include <net/if_inet6.h>\n#include <net/ipv6.h>\n\nstruct in6_validator_info {\n\tstruct in6_addr\t\ti6vi_addr;\n\tstruct inet6_dev\t*i6vi_dev;\n\tstruct netlink_ext_ack\t*extack;\n};\n\nstruct ifa6_config {\n\tconst struct in6_addr\t*pfx;\n\tunsigned int\t\tplen;\n\n\tu8\t\t\tifa_proto;\n\n\tconst struct in6_addr\t*peer_pfx;\n\n\tu32\t\t\trt_priority;\n\tu32\t\t\tifa_flags;\n\tu32\t\t\tpreferred_lft;\n\tu32\t\t\tvalid_lft;\n\tu16\t\t\tscope;\n};\n\nint addrconf_init(void);\nvoid addrconf_cleanup(void);\n\nint addrconf_add_ifaddr(struct net *net, void __user *arg);\nint addrconf_del_ifaddr(struct net *net, void __user *arg);\nint addrconf_set_dstaddr(struct net *net, void __user *arg);\n\nint ipv6_chk_addr(struct net *net, const struct in6_addr *addr,\n\t\t  const struct net_device *dev, int strict);\nint ipv6_chk_addr_and_flags(struct net *net, const struct in6_addr *addr,\n\t\t\t    const struct net_device *dev, bool skip_dev_check,\n\t\t\t    int strict, u32 banned_flags);\n\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\nint ipv6_chk_home_addr(struct net *net, const struct in6_addr *addr);\n#endif\n\nint ipv6_chk_rpl_srh_loop(struct net *net, const struct in6_addr *segs,\n\t\t\t  unsigned char nsegs);\n\nbool ipv6_chk_custom_prefix(const struct in6_addr *addr,\n\t\t\t\t   const unsigned int prefix_len,\n\t\t\t\t   struct net_device *dev);\n\nint ipv6_chk_prefix(const struct in6_addr *addr, struct net_device *dev);\n\nstruct net_device *ipv6_dev_find(struct net *net, const struct in6_addr *addr,\n\t\t\t\t struct net_device *dev);\n\nstruct inet6_ifaddr *ipv6_get_ifaddr(struct net *net,\n\t\t\t\t     const struct in6_addr *addr,\n\t\t\t\t     struct net_device *dev, int strict);\n\nint ipv6_dev_get_saddr(struct net *net, const struct net_device *dev,\n\t\t       const struct in6_addr *daddr, unsigned int srcprefs,\n\t\t       struct in6_addr *saddr);\nint ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,\n\t\t    u32 banned_flags);\nbool inet_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,\n\t\t\t  bool match_wildcard);\nbool inet_rcv_saddr_any(const struct sock *sk);\nvoid addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);\nvoid addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);\n\nvoid addrconf_add_linklocal(struct inet6_dev *idev,\n\t\t\t    const struct in6_addr *addr, u32 flags);\n\nint addrconf_prefix_rcv_add_addr(struct net *net, struct net_device *dev,\n\t\t\t\t const struct prefix_info *pinfo,\n\t\t\t\t struct inet6_dev *in6_dev,\n\t\t\t\t const struct in6_addr *addr, int addr_type,\n\t\t\t\t u32 addr_flags, bool sllao, bool tokenized,\n\t\t\t\t __u32 valid_lft, u32 prefered_lft);\n\nstatic inline void addrconf_addr_eui48_base(u8 *eui, const char *const addr)\n{\n\tmemcpy(eui, addr, 3);\n\teui[3] = 0xFF;\n\teui[4] = 0xFE;\n\tmemcpy(eui + 5, addr + 3, 3);\n}\n\nstatic inline void addrconf_addr_eui48(u8 *eui, const char *const addr)\n{\n\taddrconf_addr_eui48_base(eui, addr);\n\teui[0] ^= 2;\n}\n\nstatic inline int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)\n{\n\tif (dev->addr_len != ETH_ALEN)\n\t\treturn -1;\n\n\t \n\n\taddrconf_addr_eui48_base(eui, dev->dev_addr);\n\n\tif (dev->dev_id) {\n\t\teui[3] = (dev->dev_id >> 8) & 0xFF;\n\t\teui[4] = dev->dev_id & 0xFF;\n\t} else {\n\t\teui[0] ^= 2;\n\t}\n\n\treturn 0;\n}\n\nstatic inline unsigned long addrconf_timeout_fixup(u32 timeout,\n\t\t\t\t\t\t   unsigned int unit)\n{\n\tif (timeout == 0xffffffff)\n\t\treturn ~0UL;\n\n\t \n\tif (0xfffffffe > LONG_MAX / unit && timeout > LONG_MAX / unit)\n\t\treturn LONG_MAX / unit;\n\n\treturn timeout;\n}\n\nstatic inline int addrconf_finite_timeout(unsigned long timeout)\n{\n\treturn ~timeout;\n}\n\n \nint ipv6_addr_label_init(void);\nvoid ipv6_addr_label_cleanup(void);\nint ipv6_addr_label_rtnl_register(void);\nu32 ipv6_addr_label(struct net *net, const struct in6_addr *addr,\n\t\t    int type, int ifindex);\n\n \nstatic inline bool ipv6_mc_may_pull(struct sk_buff *skb,\n\t\t\t\t    unsigned int len)\n{\n\tif (skb_transport_offset(skb) + ipv6_transport_len(skb) < len)\n\t\treturn false;\n\n\treturn pskb_may_pull(skb, len);\n}\n\nint ipv6_sock_mc_join(struct sock *sk, int ifindex,\n\t\t      const struct in6_addr *addr);\nint ipv6_sock_mc_drop(struct sock *sk, int ifindex,\n\t\t      const struct in6_addr *addr);\nvoid __ipv6_sock_mc_close(struct sock *sk);\nvoid ipv6_sock_mc_close(struct sock *sk);\nbool inet6_mc_check(const struct sock *sk, const struct in6_addr *mc_addr,\n\t\t    const struct in6_addr *src_addr);\n\nint ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr);\nint __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr);\nint ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr);\nvoid ipv6_mc_up(struct inet6_dev *idev);\nvoid ipv6_mc_down(struct inet6_dev *idev);\nvoid ipv6_mc_unmap(struct inet6_dev *idev);\nvoid ipv6_mc_remap(struct inet6_dev *idev);\nvoid ipv6_mc_init_dev(struct inet6_dev *idev);\nvoid ipv6_mc_destroy_dev(struct inet6_dev *idev);\nint ipv6_mc_check_mld(struct sk_buff *skb);\nvoid addrconf_dad_failure(struct sk_buff *skb, struct inet6_ifaddr *ifp);\n\nbool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,\n\t\t\t const struct in6_addr *src_addr);\n\nvoid ipv6_mc_dad_complete(struct inet6_dev *idev);\n\n \nstatic inline bool ipv6_is_mld(struct sk_buff *skb, int nexthdr, int offset)\n{\n\tstruct icmp6hdr *hdr;\n\n\tif (nexthdr != IPPROTO_ICMPV6 ||\n\t    !pskb_network_may_pull(skb, offset + sizeof(struct icmp6hdr)))\n\t\treturn false;\n\n\thdr = (struct icmp6hdr *)(skb_network_header(skb) + offset);\n\n\tswitch (hdr->icmp6_type) {\n\tcase ICMPV6_MGM_QUERY:\n\tcase ICMPV6_MGM_REPORT:\n\tcase ICMPV6_MGM_REDUCTION:\n\tcase ICMPV6_MLD2_REPORT:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nvoid addrconf_prefix_rcv(struct net_device *dev,\n\t\t\t u8 *opt, int len, bool sllao);\n\n \nint ipv6_sock_ac_join(struct sock *sk, int ifindex,\n\t\t      const struct in6_addr *addr);\nint ipv6_sock_ac_drop(struct sock *sk, int ifindex,\n\t\t      const struct in6_addr *addr);\nvoid __ipv6_sock_ac_close(struct sock *sk);\nvoid ipv6_sock_ac_close(struct sock *sk);\n\nint __ipv6_dev_ac_inc(struct inet6_dev *idev, const struct in6_addr *addr);\nint __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr);\nvoid ipv6_ac_destroy_dev(struct inet6_dev *idev);\nbool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,\n\t\t\t const struct in6_addr *addr);\nbool ipv6_chk_acast_addr_src(struct net *net, struct net_device *dev,\n\t\t\t     const struct in6_addr *addr);\nint ipv6_anycast_init(void);\nvoid ipv6_anycast_cleanup(void);\n\n \nint register_inet6addr_notifier(struct notifier_block *nb);\nint unregister_inet6addr_notifier(struct notifier_block *nb);\nint inet6addr_notifier_call_chain(unsigned long val, void *v);\n\nint register_inet6addr_validator_notifier(struct notifier_block *nb);\nint unregister_inet6addr_validator_notifier(struct notifier_block *nb);\nint inet6addr_validator_notifier_call_chain(unsigned long val, void *v);\n\nvoid inet6_netconf_notify_devconf(struct net *net, int event, int type,\n\t\t\t\t  int ifindex, struct ipv6_devconf *devconf);\n\n \nstatic inline struct inet6_dev *__in6_dev_get(const struct net_device *dev)\n{\n\treturn rcu_dereference_rtnl(dev->ip6_ptr);\n}\n\n \nstatic inline struct inet6_dev *__in6_dev_stats_get(const struct net_device *dev,\n\t\t\t\t\t\t    const struct sk_buff *skb)\n{\n\tif (netif_is_l3_master(dev))\n\t\tdev = dev_get_by_index_rcu(dev_net(dev), inet6_iif(skb));\n\treturn __in6_dev_get(dev);\n}\n\n \nstatic inline struct inet6_dev *__in6_dev_get_safely(const struct net_device *dev)\n{\n\tif (likely(dev))\n\t\treturn rcu_dereference_rtnl(dev->ip6_ptr);\n\telse\n\t\treturn NULL;\n}\n\n \nstatic inline struct inet6_dev *in6_dev_get(const struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\n\trcu_read_lock();\n\tidev = rcu_dereference(dev->ip6_ptr);\n\tif (idev)\n\t\trefcount_inc(&idev->refcnt);\n\trcu_read_unlock();\n\treturn idev;\n}\n\nstatic inline struct neigh_parms *__in6_dev_nd_parms_get_rcu(const struct net_device *dev)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\n\treturn idev ? idev->nd_parms : NULL;\n}\n\nvoid in6_dev_finish_destroy(struct inet6_dev *idev);\n\nstatic inline void in6_dev_put(struct inet6_dev *idev)\n{\n\tif (refcount_dec_and_test(&idev->refcnt))\n\t\tin6_dev_finish_destroy(idev);\n}\n\nstatic inline void in6_dev_put_clear(struct inet6_dev **pidev)\n{\n\tstruct inet6_dev *idev = *pidev;\n\n\tif (idev) {\n\t\tin6_dev_put(idev);\n\t\t*pidev = NULL;\n\t}\n}\n\nstatic inline void __in6_dev_put(struct inet6_dev *idev)\n{\n\trefcount_dec(&idev->refcnt);\n}\n\nstatic inline void in6_dev_hold(struct inet6_dev *idev)\n{\n\trefcount_inc(&idev->refcnt);\n}\n\n \nstatic inline bool ip6_ignore_linkdown(const struct net_device *dev)\n{\n\tconst struct inet6_dev *idev = __in6_dev_get(dev);\n\n\tif (unlikely(!idev))\n\t\treturn true;\n\n\treturn !!idev->cnf.ignore_routes_with_linkdown;\n}\n\nvoid inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp);\n\nstatic inline void in6_ifa_put(struct inet6_ifaddr *ifp)\n{\n\tif (refcount_dec_and_test(&ifp->refcnt))\n\t\tinet6_ifa_finish_destroy(ifp);\n}\n\nstatic inline void __in6_ifa_put(struct inet6_ifaddr *ifp)\n{\n\trefcount_dec(&ifp->refcnt);\n}\n\nstatic inline void in6_ifa_hold(struct inet6_ifaddr *ifp)\n{\n\trefcount_inc(&ifp->refcnt);\n}\n\n\n \n\nstatic inline void addrconf_addr_solict_mult(const struct in6_addr *addr,\n\t\t\t\t\t     struct in6_addr *solicited)\n{\n\tipv6_addr_set(solicited,\n\t\t      htonl(0xFF020000), 0,\n\t\t      htonl(0x1),\n\t\t      htonl(0xFF000000) | addr->s6_addr32[3]);\n}\n\nstatic inline bool ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\t__be64 *p = (__force __be64 *)addr;\n\treturn ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) | (p[1] ^ cpu_to_be64(1))) == 0UL;\n#else\n\treturn ((addr->s6_addr32[0] ^ htonl(0xff020000)) |\n\t\taddr->s6_addr32[1] | addr->s6_addr32[2] |\n\t\t(addr->s6_addr32[3] ^ htonl(0x00000001))) == 0;\n#endif\n}\n\nstatic inline bool ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\t__be64 *p = (__force __be64 *)addr;\n\treturn ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) | (p[1] ^ cpu_to_be64(2))) == 0UL;\n#else\n\treturn ((addr->s6_addr32[0] ^ htonl(0xff020000)) |\n\t\taddr->s6_addr32[1] | addr->s6_addr32[2] |\n\t\t(addr->s6_addr32[3] ^ htonl(0x00000002))) == 0;\n#endif\n}\n\nstatic inline bool ipv6_addr_is_isatap(const struct in6_addr *addr)\n{\n\treturn (addr->s6_addr32[2] | htonl(0x02000000)) == htonl(0x02005EFE);\n}\n\nstatic inline bool ipv6_addr_is_solict_mult(const struct in6_addr *addr)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\t__be64 *p = (__force __be64 *)addr;\n\treturn ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) |\n\t\t((p[1] ^ cpu_to_be64(0x00000001ff000000UL)) &\n\t\t cpu_to_be64(0xffffffffff000000UL))) == 0UL;\n#else\n\treturn ((addr->s6_addr32[0] ^ htonl(0xff020000)) |\n\t\taddr->s6_addr32[1] |\n\t\t(addr->s6_addr32[2] ^ htonl(0x00000001)) |\n\t\t(addr->s6_addr[12] ^ 0xff)) == 0;\n#endif\n}\n\nstatic inline bool ipv6_addr_is_all_snoopers(const struct in6_addr *addr)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\t__be64 *p = (__force __be64 *)addr;\n\n\treturn ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) |\n\t\t(p[1] ^ cpu_to_be64(0x6a))) == 0UL;\n#else\n\treturn ((addr->s6_addr32[0] ^ htonl(0xff020000)) |\n\t\taddr->s6_addr32[1] | addr->s6_addr32[2] |\n\t\t(addr->s6_addr32[3] ^ htonl(0x0000006a))) == 0;\n#endif\n}\n\n#ifdef CONFIG_PROC_FS\nint if6_proc_init(void);\nvoid if6_proc_exit(void);\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}