{
  "module_name": "inet_sock.h",
  "hash_id": "07801d495dda9605ecf0ed60c146191d42c3966e4e7912207077de4e06c6b411",
  "original_prompt": "Ingested from linux-6.6.14/include/net/inet_sock.h",
  "human_readable_source": " \n \n#ifndef _INET_SOCK_H\n#define _INET_SOCK_H\n\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/jhash.h>\n#include <linux/netdevice.h>\n\n#include <net/flow.h>\n#include <net/sock.h>\n#include <net/request_sock.h>\n#include <net/netns/hash.h>\n#include <net/tcp_states.h>\n#include <net/l3mdev.h>\n\n \nstruct ip_options {\n\t__be32\t\tfaddr;\n\t__be32\t\tnexthop;\n\tunsigned char\toptlen;\n\tunsigned char\tsrr;\n\tunsigned char\trr;\n\tunsigned char\tts;\n\tunsigned char\tis_strictroute:1,\n\t\t\tsrr_is_hit:1,\n\t\t\tis_changed:1,\n\t\t\trr_needaddr:1,\n\t\t\tts_needtime:1,\n\t\t\tts_needaddr:1;\n\tunsigned char\trouter_alert;\n\tunsigned char\tcipso;\n\tunsigned char\t__pad2;\n\tunsigned char\t__data[];\n};\n\nstruct ip_options_rcu {\n\tstruct rcu_head rcu;\n\tstruct ip_options opt;\n};\n\nstruct ip_options_data {\n\tstruct ip_options_rcu\topt;\n\tchar\t\t\tdata[40];\n};\n\nstruct inet_request_sock {\n\tstruct request_sock\treq;\n#define ir_loc_addr\t\treq.__req_common.skc_rcv_saddr\n#define ir_rmt_addr\t\treq.__req_common.skc_daddr\n#define ir_num\t\t\treq.__req_common.skc_num\n#define ir_rmt_port\t\treq.__req_common.skc_dport\n#define ir_v6_rmt_addr\t\treq.__req_common.skc_v6_daddr\n#define ir_v6_loc_addr\t\treq.__req_common.skc_v6_rcv_saddr\n#define ir_iif\t\t\treq.__req_common.skc_bound_dev_if\n#define ir_cookie\t\treq.__req_common.skc_cookie\n#define ireq_net\t\treq.__req_common.skc_net\n#define ireq_state\t\treq.__req_common.skc_state\n#define ireq_family\t\treq.__req_common.skc_family\n\n\tu16\t\t\tsnd_wscale : 4,\n\t\t\t\trcv_wscale : 4,\n\t\t\t\ttstamp_ok  : 1,\n\t\t\t\tsack_ok\t   : 1,\n\t\t\t\twscale_ok  : 1,\n\t\t\t\tecn_ok\t   : 1,\n\t\t\t\tacked\t   : 1,\n\t\t\t\tno_srccheck: 1,\n\t\t\t\tsmc_ok\t   : 1;\n\tu32                     ir_mark;\n\tunion {\n\t\tstruct ip_options_rcu __rcu\t*ireq_opt;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct {\n\t\t\tstruct ipv6_txoptions\t*ipv6_opt;\n\t\t\tstruct sk_buff\t\t*pktopts;\n\t\t};\n#endif\n\t};\n};\n\nstatic inline struct inet_request_sock *inet_rsk(const struct request_sock *sk)\n{\n\treturn (struct inet_request_sock *)sk;\n}\n\nstatic inline u32 inet_request_mark(const struct sock *sk, struct sk_buff *skb)\n{\n\tu32 mark = READ_ONCE(sk->sk_mark);\n\n\tif (!mark && READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_fwmark_accept))\n\t\treturn skb->mark;\n\n\treturn mark;\n}\n\nstatic inline int inet_request_bound_dev_if(const struct sock *sk,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tint bound_dev_if = READ_ONCE(sk->sk_bound_dev_if);\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\tstruct net *net = sock_net(sk);\n\n\tif (!bound_dev_if && READ_ONCE(net->ipv4.sysctl_tcp_l3mdev_accept))\n\t\treturn l3mdev_master_ifindex_by_index(net, skb->skb_iif);\n#endif\n\n\treturn bound_dev_if;\n}\n\nstatic inline int inet_sk_bound_l3mdev(const struct sock *sk)\n{\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\tstruct net *net = sock_net(sk);\n\n\tif (!READ_ONCE(net->ipv4.sysctl_tcp_l3mdev_accept))\n\t\treturn l3mdev_master_ifindex_by_index(net,\n\t\t\t\t\t\t      sk->sk_bound_dev_if);\n#endif\n\n\treturn 0;\n}\n\nstatic inline bool inet_bound_dev_eq(bool l3mdev_accept, int bound_dev_if,\n\t\t\t\t     int dif, int sdif)\n{\n\tif (!bound_dev_if)\n\t\treturn !sdif || l3mdev_accept;\n\treturn bound_dev_if == dif || bound_dev_if == sdif;\n}\n\nstatic inline bool inet_sk_bound_dev_eq(struct net *net, int bound_dev_if,\n\t\t\t\t\tint dif, int sdif)\n{\n#if IS_ENABLED(CONFIG_NET_L3_MASTER_DEV)\n\treturn inet_bound_dev_eq(!!READ_ONCE(net->ipv4.sysctl_tcp_l3mdev_accept),\n\t\t\t\t bound_dev_if, dif, sdif);\n#else\n\treturn inet_bound_dev_eq(true, bound_dev_if, dif, sdif);\n#endif\n}\n\nstruct inet_cork {\n\tunsigned int\t\tflags;\n\t__be32\t\t\taddr;\n\tstruct ip_options\t*opt;\n\tunsigned int\t\tfragsize;\n\tint\t\t\tlength;  \n\tstruct dst_entry\t*dst;\n\tu8\t\t\ttx_flags;\n\t__u8\t\t\tttl;\n\t__s16\t\t\ttos;\n\tchar\t\t\tpriority;\n\t__u16\t\t\tgso_size;\n\tu64\t\t\ttransmit_time;\n\tu32\t\t\tmark;\n};\n\nstruct inet_cork_full {\n\tstruct inet_cork\tbase;\n\tstruct flowi\t\tfl;\n};\n\nstruct ip_mc_socklist;\nstruct ipv6_pinfo;\nstruct rtable;\n\n \nstruct inet_sock {\n\t \n\tstruct sock\t\tsk;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct ipv6_pinfo\t*pinet6;\n#endif\n\t \n#define inet_daddr\t\tsk.__sk_common.skc_daddr\n#define inet_rcv_saddr\t\tsk.__sk_common.skc_rcv_saddr\n#define inet_dport\t\tsk.__sk_common.skc_dport\n#define inet_num\t\tsk.__sk_common.skc_num\n\n\tunsigned long\t\tinet_flags;\n\t__be32\t\t\tinet_saddr;\n\t__s16\t\t\tuc_ttl;\n\t__be16\t\t\tinet_sport;\n\tstruct ip_options_rcu __rcu\t*inet_opt;\n\tatomic_t\t\tinet_id;\n\n\t__u8\t\t\ttos;\n\t__u8\t\t\tmin_ttl;\n\t__u8\t\t\tmc_ttl;\n\t__u8\t\t\tpmtudisc;\n\t__u8\t\t\trcv_tos;\n\t__u8\t\t\tconvert_csum;\n\tint\t\t\tuc_index;\n\tint\t\t\tmc_index;\n\t__be32\t\t\tmc_addr;\n\tstruct {\n\t\t__u16 lo;\n\t\t__u16 hi;\n\t}\t\t\tlocal_port_range;\n\n\tstruct ip_mc_socklist __rcu\t*mc_list;\n\tstruct inet_cork_full\tcork;\n};\n\n#define IPCORK_OPT\t1\t \n#define IPCORK_ALLFRAG\t2\t \n\nenum {\n\tINET_FLAGS_PKTINFO\t= 0,\n\tINET_FLAGS_TTL\t\t= 1,\n\tINET_FLAGS_TOS\t\t= 2,\n\tINET_FLAGS_RECVOPTS\t= 3,\n\tINET_FLAGS_RETOPTS\t= 4,\n\tINET_FLAGS_PASSSEC\t= 5,\n\tINET_FLAGS_ORIGDSTADDR\t= 6,\n\tINET_FLAGS_CHECKSUM\t= 7,\n\tINET_FLAGS_RECVFRAGSIZE\t= 8,\n\n\tINET_FLAGS_RECVERR\t= 9,\n\tINET_FLAGS_RECVERR_RFC4884 = 10,\n\tINET_FLAGS_FREEBIND\t= 11,\n\tINET_FLAGS_HDRINCL\t= 12,\n\tINET_FLAGS_MC_LOOP\t= 13,\n\tINET_FLAGS_MC_ALL\t= 14,\n\tINET_FLAGS_TRANSPARENT\t= 15,\n\tINET_FLAGS_IS_ICSK\t= 16,\n\tINET_FLAGS_NODEFRAG\t= 17,\n\tINET_FLAGS_BIND_ADDRESS_NO_PORT = 18,\n\tINET_FLAGS_DEFER_CONNECT = 19,\n};\n\n \n#define IP_CMSG_PKTINFO\t\tBIT(INET_FLAGS_PKTINFO)\n#define IP_CMSG_TTL\t\tBIT(INET_FLAGS_TTL)\n#define IP_CMSG_TOS\t\tBIT(INET_FLAGS_TOS)\n#define IP_CMSG_RECVOPTS\tBIT(INET_FLAGS_RECVOPTS)\n#define IP_CMSG_RETOPTS\t\tBIT(INET_FLAGS_RETOPTS)\n#define IP_CMSG_PASSSEC\t\tBIT(INET_FLAGS_PASSSEC)\n#define IP_CMSG_ORIGDSTADDR\tBIT(INET_FLAGS_ORIGDSTADDR)\n#define IP_CMSG_CHECKSUM\tBIT(INET_FLAGS_CHECKSUM)\n#define IP_CMSG_RECVFRAGSIZE\tBIT(INET_FLAGS_RECVFRAGSIZE)\n\n#define IP_CMSG_ALL\t(IP_CMSG_PKTINFO | IP_CMSG_TTL |\t\t\\\n\t\t\t IP_CMSG_TOS | IP_CMSG_RECVOPTS |\t\t\\\n\t\t\t IP_CMSG_RETOPTS | IP_CMSG_PASSSEC |\t\t\\\n\t\t\t IP_CMSG_ORIGDSTADDR | IP_CMSG_CHECKSUM |\t\\\n\t\t\t IP_CMSG_RECVFRAGSIZE)\n\nstatic inline unsigned long inet_cmsg_flags(const struct inet_sock *inet)\n{\n\treturn READ_ONCE(inet->inet_flags) & IP_CMSG_ALL;\n}\n\n#define inet_test_bit(nr, sk)\t\t\t\\\n\ttest_bit(INET_FLAGS_##nr, &inet_sk(sk)->inet_flags)\n#define inet_set_bit(nr, sk)\t\t\t\\\n\tset_bit(INET_FLAGS_##nr, &inet_sk(sk)->inet_flags)\n#define inet_clear_bit(nr, sk)\t\t\t\\\n\tclear_bit(INET_FLAGS_##nr, &inet_sk(sk)->inet_flags)\n#define inet_assign_bit(nr, sk, val)\t\t\\\n\tassign_bit(INET_FLAGS_##nr, &inet_sk(sk)->inet_flags, val)\n\nstatic inline bool sk_is_inet(struct sock *sk)\n{\n\treturn sk->sk_family == AF_INET || sk->sk_family == AF_INET6;\n}\n\n \nstatic inline struct sock *sk_to_full_sk(struct sock *sk)\n{\n#ifdef CONFIG_INET\n\tif (sk && sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tsk = inet_reqsk(sk)->rsk_listener;\n#endif\n\treturn sk;\n}\n\n \nstatic inline const struct sock *sk_const_to_full_sk(const struct sock *sk)\n{\n#ifdef CONFIG_INET\n\tif (sk && sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tsk = ((const struct request_sock *)sk)->rsk_listener;\n#endif\n\treturn sk;\n}\n\nstatic inline struct sock *skb_to_full_sk(const struct sk_buff *skb)\n{\n\treturn sk_to_full_sk(skb->sk);\n}\n\n#define inet_sk(ptr) container_of_const(ptr, struct inet_sock, sk)\n\nstatic inline void __inet_sk_copy_descendant(struct sock *sk_to,\n\t\t\t\t\t     const struct sock *sk_from,\n\t\t\t\t\t     const int ancestor_size)\n{\n\tmemcpy(inet_sk(sk_to) + 1, inet_sk(sk_from) + 1,\n\t       sk_from->sk_prot->obj_size - ancestor_size);\n}\n\nint inet_sk_rebuild_header(struct sock *sk);\n\n \nstatic inline int inet_sk_state_load(const struct sock *sk)\n{\n\t \n\treturn smp_load_acquire(&sk->sk_state);\n}\n\n \nvoid inet_sk_state_store(struct sock *sk, int newstate);\n\nvoid inet_sk_set_state(struct sock *sk, int state);\n\nstatic inline unsigned int __inet_ehashfn(const __be32 laddr,\n\t\t\t\t\t  const __u16 lport,\n\t\t\t\t\t  const __be32 faddr,\n\t\t\t\t\t  const __be16 fport,\n\t\t\t\t\t  u32 initval)\n{\n\treturn jhash_3words((__force __u32) laddr,\n\t\t\t    (__force __u32) faddr,\n\t\t\t    ((__u32) lport) << 16 | (__force __u32)fport,\n\t\t\t    initval);\n}\n\nstruct request_sock *inet_reqsk_alloc(const struct request_sock_ops *ops,\n\t\t\t\t      struct sock *sk_listener,\n\t\t\t\t      bool attach_listener);\n\nstatic inline __u8 inet_sk_flowi_flags(const struct sock *sk)\n{\n\t__u8 flags = 0;\n\n\tif (inet_test_bit(TRANSPARENT, sk) || inet_test_bit(HDRINCL, sk))\n\t\tflags |= FLOWI_FLAG_ANYSRC;\n\treturn flags;\n}\n\nstatic inline void inet_inc_convert_csum(struct sock *sk)\n{\n\tinet_sk(sk)->convert_csum++;\n}\n\nstatic inline void inet_dec_convert_csum(struct sock *sk)\n{\n\tif (inet_sk(sk)->convert_csum > 0)\n\t\tinet_sk(sk)->convert_csum--;\n}\n\nstatic inline bool inet_get_convert_csum(struct sock *sk)\n{\n\treturn !!inet_sk(sk)->convert_csum;\n}\n\n\nstatic inline bool inet_can_nonlocal_bind(struct net *net,\n\t\t\t\t\t  struct inet_sock *inet)\n{\n\treturn READ_ONCE(net->ipv4.sysctl_ip_nonlocal_bind) ||\n\t\ttest_bit(INET_FLAGS_FREEBIND, &inet->inet_flags) ||\n\t\ttest_bit(INET_FLAGS_TRANSPARENT, &inet->inet_flags);\n}\n\nstatic inline bool inet_addr_valid_or_nonlocal(struct net *net,\n\t\t\t\t\t       struct inet_sock *inet,\n\t\t\t\t\t       __be32 addr,\n\t\t\t\t\t       int addr_type)\n{\n\treturn inet_can_nonlocal_bind(net, inet) ||\n\t\taddr == htonl(INADDR_ANY) ||\n\t\taddr_type == RTN_LOCAL ||\n\t\taddr_type == RTN_MULTICAST ||\n\t\taddr_type == RTN_BROADCAST;\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}