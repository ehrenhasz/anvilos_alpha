{
  "module_name": "statx.c",
  "hash_id": "fb05d4abb537b4996b688845dbe1473fac71c0a5a80d96cc31364ad163d1cdcd",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/statx.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/io_uring.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"../fs/internal.h\"\n\n#include \"io_uring.h\"\n#include \"statx.h\"\n\nstruct io_statx {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tunsigned int\t\t\tmask;\n\tunsigned int\t\t\tflags;\n\tstruct filename\t\t\t*filename;\n\tstruct statx __user\t\t*buffer;\n};\n\nint io_statx_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_statx *sx = io_kiocb_to_cmd(req, struct io_statx);\n\tconst char __user *path;\n\n\tif (sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (req->flags & REQ_F_FIXED_FILE)\n\t\treturn -EBADF;\n\n\tsx->dfd = READ_ONCE(sqe->fd);\n\tsx->mask = READ_ONCE(sqe->len);\n\tpath = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tsx->buffer = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tsx->flags = READ_ONCE(sqe->statx_flags);\n\n\tsx->filename = getname_flags(path,\n\t\t\t\t     getname_statx_lookup_flags(sx->flags),\n\t\t\t\t     NULL);\n\n\tif (IS_ERR(sx->filename)) {\n\t\tint ret = PTR_ERR(sx->filename);\n\n\t\tsx->filename = NULL;\n\t\treturn ret;\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_statx(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_statx *sx = io_kiocb_to_cmd(req, struct io_statx);\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = do_statx(sx->dfd, sx->filename, sx->flags, sx->mask, sx->buffer);\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nvoid io_statx_cleanup(struct io_kiocb *req)\n{\n\tstruct io_statx *sx = io_kiocb_to_cmd(req, struct io_statx);\n\n\tif (sx->filename)\n\t\tputname(sx->filename);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}