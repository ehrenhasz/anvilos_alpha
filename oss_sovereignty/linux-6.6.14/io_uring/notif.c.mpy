{
  "module_name": "notif.c",
  "hash_id": "fa3451394795fb81dc388b39cbdd38bfe0e8c84eb66ffdfed1d0e3dd34f19778",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/notif.c",
  "human_readable_source": "#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/net.h>\n#include <linux/io_uring.h>\n\n#include \"io_uring.h\"\n#include \"notif.h\"\n#include \"rsrc.h\"\n\nstatic void io_notif_complete_tw_ext(struct io_kiocb *notif, struct io_tw_state *ts)\n{\n\tstruct io_notif_data *nd = io_notif_to_data(notif);\n\tstruct io_ring_ctx *ctx = notif->ctx;\n\n\tif (nd->zc_report && (nd->zc_copied || !nd->zc_used))\n\t\tnotif->cqe.res |= IORING_NOTIF_USAGE_ZC_COPIED;\n\n\tif (nd->account_pages && ctx->user) {\n\t\t__io_unaccount_mem(ctx->user, nd->account_pages);\n\t\tnd->account_pages = 0;\n\t}\n\tio_req_task_complete(notif, ts);\n}\n\nstatic void io_tx_ubuf_callback(struct sk_buff *skb, struct ubuf_info *uarg,\n\t\t\t\tbool success)\n{\n\tstruct io_notif_data *nd = container_of(uarg, struct io_notif_data, uarg);\n\tstruct io_kiocb *notif = cmd_to_io_kiocb(nd);\n\n\tif (refcount_dec_and_test(&uarg->refcnt))\n\t\t__io_req_task_work_add(notif, IOU_F_TWQ_LAZY_WAKE);\n}\n\nstatic void io_tx_ubuf_callback_ext(struct sk_buff *skb, struct ubuf_info *uarg,\n\t\t\t     bool success)\n{\n\tstruct io_notif_data *nd = container_of(uarg, struct io_notif_data, uarg);\n\n\tif (nd->zc_report) {\n\t\tif (success && !nd->zc_used && skb)\n\t\t\tWRITE_ONCE(nd->zc_used, true);\n\t\telse if (!success && !nd->zc_copied)\n\t\t\tWRITE_ONCE(nd->zc_copied, true);\n\t}\n\tio_tx_ubuf_callback(skb, uarg, success);\n}\n\nvoid io_notif_set_extended(struct io_kiocb *notif)\n{\n\tstruct io_notif_data *nd = io_notif_to_data(notif);\n\n\tif (nd->uarg.callback != io_tx_ubuf_callback_ext) {\n\t\tnd->account_pages = 0;\n\t\tnd->zc_report = false;\n\t\tnd->zc_used = false;\n\t\tnd->zc_copied = false;\n\t\tnd->uarg.callback = io_tx_ubuf_callback_ext;\n\t\tnotif->io_task_work.func = io_notif_complete_tw_ext;\n\t}\n}\n\nstruct io_kiocb *io_alloc_notif(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->uring_lock)\n{\n\tstruct io_kiocb *notif;\n\tstruct io_notif_data *nd;\n\n\tif (unlikely(!io_alloc_req(ctx, &notif)))\n\t\treturn NULL;\n\tnotif->opcode = IORING_OP_NOP;\n\tnotif->flags = 0;\n\tnotif->file = NULL;\n\tnotif->task = current;\n\tio_get_task_refs(1);\n\tnotif->rsrc_node = NULL;\n\tnotif->io_task_work.func = io_req_task_complete;\n\n\tnd = io_notif_to_data(notif);\n\tnd->uarg.flags = IO_NOTIF_UBUF_FLAGS;\n\tnd->uarg.callback = io_tx_ubuf_callback;\n\trefcount_set(&nd->uarg.refcnt, 1);\n\treturn notif;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}