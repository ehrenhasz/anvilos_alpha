{
  "module_name": "msg_ring.c",
  "hash_id": "b8a532bbfb86623b480bfb8510097a5aab4261cb9128a51087ccc4000fd32d45",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/msg_ring.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n#include <linux/io_uring.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"io_uring.h\"\n#include \"rsrc.h\"\n#include \"filetable.h\"\n#include \"msg_ring.h\"\n\n\n \n#define IORING_MSG_RING_MASK\t\t(IORING_MSG_RING_CQE_SKIP | \\\n\t\t\t\t\tIORING_MSG_RING_FLAGS_PASS)\n\nstruct io_msg {\n\tstruct file\t\t\t*file;\n\tstruct file\t\t\t*src_file;\n\tstruct callback_head\t\ttw;\n\tu64 user_data;\n\tu32 len;\n\tu32 cmd;\n\tu32 src_fd;\n\tunion {\n\t\tu32 dst_fd;\n\t\tu32 cqe_flags;\n\t};\n\tu32 flags;\n};\n\nstatic void io_double_unlock_ctx(struct io_ring_ctx *octx)\n{\n\tmutex_unlock(&octx->uring_lock);\n}\n\nstatic int io_double_lock_ctx(struct io_ring_ctx *octx,\n\t\t\t      unsigned int issue_flags)\n{\n\t \n\tif (!(issue_flags & IO_URING_F_UNLOCKED)) {\n\t\tif (!mutex_trylock(&octx->uring_lock))\n\t\t\treturn -EAGAIN;\n\t\treturn 0;\n\t}\n\tmutex_lock(&octx->uring_lock);\n\treturn 0;\n}\n\nvoid io_msg_ring_cleanup(struct io_kiocb *req)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\n\tif (WARN_ON_ONCE(!msg->src_file))\n\t\treturn;\n\n\tfput(msg->src_file);\n\tmsg->src_file = NULL;\n}\n\nstatic inline bool io_msg_need_remote(struct io_ring_ctx *target_ctx)\n{\n\tif (!target_ctx->task_complete)\n\t\treturn false;\n\treturn current != target_ctx->submitter_task;\n}\n\nstatic int io_msg_exec_remote(struct io_kiocb *req, task_work_func_t func)\n{\n\tstruct io_ring_ctx *ctx = req->file->private_data;\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tstruct task_struct *task = READ_ONCE(ctx->submitter_task);\n\n\tif (unlikely(!task))\n\t\treturn -EOWNERDEAD;\n\n\tinit_task_work(&msg->tw, func);\n\tif (task_work_add(ctx->submitter_task, &msg->tw, TWA_SIGNAL))\n\t\treturn -EOWNERDEAD;\n\n\treturn IOU_ISSUE_SKIP_COMPLETE;\n}\n\nstatic void io_msg_tw_complete(struct callback_head *head)\n{\n\tstruct io_msg *msg = container_of(head, struct io_msg, tw);\n\tstruct io_kiocb *req = cmd_to_io_kiocb(msg);\n\tstruct io_ring_ctx *target_ctx = req->file->private_data;\n\tint ret = 0;\n\n\tif (current->flags & PF_EXITING) {\n\t\tret = -EOWNERDEAD;\n\t} else {\n\t\tu32 flags = 0;\n\n\t\tif (msg->flags & IORING_MSG_RING_FLAGS_PASS)\n\t\t\tflags = msg->cqe_flags;\n\n\t\t \n\t\tif (target_ctx->flags & IORING_SETUP_IOPOLL)\n\t\t\tmutex_lock(&target_ctx->uring_lock);\n\t\tif (!io_post_aux_cqe(target_ctx, msg->user_data, msg->len, flags))\n\t\t\tret = -EOVERFLOW;\n\t\tif (target_ctx->flags & IORING_SETUP_IOPOLL)\n\t\t\tmutex_unlock(&target_ctx->uring_lock);\n\t}\n\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_queue_tw_complete(req, ret);\n}\n\nstatic int io_msg_ring_data(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *target_ctx = req->file->private_data;\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tu32 flags = 0;\n\tint ret;\n\n\tif (msg->src_fd || msg->flags & ~IORING_MSG_RING_FLAGS_PASS)\n\t\treturn -EINVAL;\n\tif (!(msg->flags & IORING_MSG_RING_FLAGS_PASS) && msg->dst_fd)\n\t\treturn -EINVAL;\n\tif (target_ctx->flags & IORING_SETUP_R_DISABLED)\n\t\treturn -EBADFD;\n\n\tif (io_msg_need_remote(target_ctx))\n\t\treturn io_msg_exec_remote(req, io_msg_tw_complete);\n\n\tif (msg->flags & IORING_MSG_RING_FLAGS_PASS)\n\t\tflags = msg->cqe_flags;\n\n\tret = -EOVERFLOW;\n\tif (target_ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (unlikely(io_double_lock_ctx(target_ctx, issue_flags)))\n\t\t\treturn -EAGAIN;\n\t\tif (io_post_aux_cqe(target_ctx, msg->user_data, msg->len, flags))\n\t\t\tret = 0;\n\t\tio_double_unlock_ctx(target_ctx);\n\t} else {\n\t\tif (io_post_aux_cqe(target_ctx, msg->user_data, msg->len, flags))\n\t\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic struct file *io_msg_grab_file(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = NULL;\n\tint idx = msg->src_fd;\n\n\tio_ring_submit_lock(ctx, issue_flags);\n\tif (likely(idx < ctx->nr_user_files)) {\n\t\tidx = array_index_nospec(idx, ctx->nr_user_files);\n\t\tfile = io_file_from_index(&ctx->file_table, idx);\n\t\tif (file)\n\t\t\tget_file(file);\n\t}\n\tio_ring_submit_unlock(ctx, issue_flags);\n\treturn file;\n}\n\nstatic int io_msg_install_complete(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *target_ctx = req->file->private_data;\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tstruct file *src_file = msg->src_file;\n\tint ret;\n\n\tif (unlikely(io_double_lock_ctx(target_ctx, issue_flags)))\n\t\treturn -EAGAIN;\n\n\tret = __io_fixed_fd_install(target_ctx, src_file, msg->dst_fd);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tmsg->src_file = NULL;\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\n\tif (msg->flags & IORING_MSG_RING_CQE_SKIP)\n\t\tgoto out_unlock;\n\t \n\tif (!io_post_aux_cqe(target_ctx, msg->user_data, ret, 0))\n\t\tret = -EOVERFLOW;\nout_unlock:\n\tio_double_unlock_ctx(target_ctx);\n\treturn ret;\n}\n\nstatic void io_msg_tw_fd_complete(struct callback_head *head)\n{\n\tstruct io_msg *msg = container_of(head, struct io_msg, tw);\n\tstruct io_kiocb *req = cmd_to_io_kiocb(msg);\n\tint ret = -EOWNERDEAD;\n\n\tif (!(current->flags & PF_EXITING))\n\t\tret = io_msg_install_complete(req, IO_URING_F_UNLOCKED);\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_queue_tw_complete(req, ret);\n}\n\nstatic int io_msg_send_fd(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *target_ctx = req->file->private_data;\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *src_file = msg->src_file;\n\n\tif (msg->len)\n\t\treturn -EINVAL;\n\tif (target_ctx == ctx)\n\t\treturn -EINVAL;\n\tif (target_ctx->flags & IORING_SETUP_R_DISABLED)\n\t\treturn -EBADFD;\n\tif (!src_file) {\n\t\tsrc_file = io_msg_grab_file(req, issue_flags);\n\t\tif (!src_file)\n\t\t\treturn -EBADF;\n\t\tmsg->src_file = src_file;\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\t}\n\n\tif (io_msg_need_remote(target_ctx))\n\t\treturn io_msg_exec_remote(req, io_msg_tw_fd_complete);\n\treturn io_msg_install_complete(req, issue_flags);\n}\n\nint io_msg_ring_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\n\tif (unlikely(sqe->buf_index || sqe->personality))\n\t\treturn -EINVAL;\n\n\tmsg->src_file = NULL;\n\tmsg->user_data = READ_ONCE(sqe->off);\n\tmsg->len = READ_ONCE(sqe->len);\n\tmsg->cmd = READ_ONCE(sqe->addr);\n\tmsg->src_fd = READ_ONCE(sqe->addr3);\n\tmsg->dst_fd = READ_ONCE(sqe->file_index);\n\tmsg->flags = READ_ONCE(sqe->msg_ring_flags);\n\tif (msg->flags & ~IORING_MSG_RING_MASK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req, issue_flags);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\ndone:\n\tif (ret < 0) {\n\t\tif (ret == -EAGAIN || ret == IOU_ISSUE_SKIP_COMPLETE)\n\t\t\treturn ret;\n\t\treq_set_fail(req);\n\t}\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}