{
  "module_name": "slist.h",
  "hash_id": "42723587ffa82210fff178741be65fba2ee595e03eb08c176dbc919b6158c31a",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/slist.h",
  "human_readable_source": "#ifndef INTERNAL_IO_SLIST_H\n#define INTERNAL_IO_SLIST_H\n\n#include <linux/io_uring_types.h>\n\n#define __wq_list_for_each(pos, head)\t\t\t\t\\\n\tfor (pos = (head)->first; pos; pos = (pos)->next)\n\n#define wq_list_for_each(pos, prv, head)\t\t\t\\\n\tfor (pos = (head)->first, prv = NULL; pos; prv = pos, pos = (pos)->next)\n\n#define wq_list_for_each_resume(pos, prv)\t\t\t\\\n\tfor (; pos; prv = pos, pos = (pos)->next)\n\n#define wq_list_empty(list)\t(READ_ONCE((list)->first) == NULL)\n\n#define INIT_WQ_LIST(list)\tdo {\t\t\t\t\\\n\t(list)->first = NULL;\t\t\t\t\t\\\n} while (0)\n\nstatic inline void wq_list_add_after(struct io_wq_work_node *node,\n\t\t\t\t     struct io_wq_work_node *pos,\n\t\t\t\t     struct io_wq_work_list *list)\n{\n\tstruct io_wq_work_node *next = pos->next;\n\n\tpos->next = node;\n\tnode->next = next;\n\tif (!next)\n\t\tlist->last = node;\n}\n\nstatic inline void wq_list_add_tail(struct io_wq_work_node *node,\n\t\t\t\t    struct io_wq_work_list *list)\n{\n\tnode->next = NULL;\n\tif (!list->first) {\n\t\tlist->last = node;\n\t\tWRITE_ONCE(list->first, node);\n\t} else {\n\t\tlist->last->next = node;\n\t\tlist->last = node;\n\t}\n}\n\nstatic inline void wq_list_add_head(struct io_wq_work_node *node,\n\t\t\t\t    struct io_wq_work_list *list)\n{\n\tnode->next = list->first;\n\tif (!node->next)\n\t\tlist->last = node;\n\tWRITE_ONCE(list->first, node);\n}\n\nstatic inline void wq_list_cut(struct io_wq_work_list *list,\n\t\t\t       struct io_wq_work_node *last,\n\t\t\t       struct io_wq_work_node *prev)\n{\n\t \n\tif (!prev)\n\t\tWRITE_ONCE(list->first, last->next);\n\telse\n\t\tprev->next = last->next;\n\n\tif (last == list->last)\n\t\tlist->last = prev;\n\tlast->next = NULL;\n}\n\nstatic inline void __wq_list_splice(struct io_wq_work_list *list,\n\t\t\t\t    struct io_wq_work_node *to)\n{\n\tlist->last->next = to->next;\n\tto->next = list->first;\n\tINIT_WQ_LIST(list);\n}\n\nstatic inline bool wq_list_splice(struct io_wq_work_list *list,\n\t\t\t\t  struct io_wq_work_node *to)\n{\n\tif (!wq_list_empty(list)) {\n\t\t__wq_list_splice(list, to);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline void wq_stack_add_head(struct io_wq_work_node *node,\n\t\t\t\t     struct io_wq_work_node *stack)\n{\n\tnode->next = stack->next;\n\tstack->next = node;\n}\n\nstatic inline void wq_list_del(struct io_wq_work_list *list,\n\t\t\t       struct io_wq_work_node *node,\n\t\t\t       struct io_wq_work_node *prev)\n{\n\twq_list_cut(list, node, prev);\n}\n\nstatic inline\nstruct io_wq_work_node *wq_stack_extract(struct io_wq_work_node *stack)\n{\n\tstruct io_wq_work_node *node = stack->next;\n\n\tstack->next = node->next;\n\treturn node;\n}\n\nstatic inline struct io_wq_work *wq_next_work(struct io_wq_work *work)\n{\n\tif (!work->list.next)\n\t\treturn NULL;\n\n\treturn container_of(work->list.next, struct io_wq_work, list);\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}