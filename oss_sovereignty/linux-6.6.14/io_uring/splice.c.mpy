{
  "module_name": "splice.c",
  "hash_id": "93dd85a567d7b2d254c7569d3dabd92a87f769dd9a3175550a29c7d8b967b531",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/splice.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/io_uring.h>\n#include <linux/splice.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"io_uring.h\"\n#include \"splice.h\"\n\nstruct io_splice {\n\tstruct file\t\t\t*file_out;\n\tloff_t\t\t\t\toff_out;\n\tloff_t\t\t\t\toff_in;\n\tu64\t\t\t\tlen;\n\tint\t\t\t\tsplice_fd_in;\n\tunsigned int\t\t\tflags;\n};\n\nstatic int __io_splice_prep(struct io_kiocb *req,\n\t\t\t    const struct io_uring_sqe *sqe)\n{\n\tstruct io_splice *sp = io_kiocb_to_cmd(req, struct io_splice);\n\tunsigned int valid_flags = SPLICE_F_FD_IN_FIXED | SPLICE_F_ALL;\n\n\tsp->len = READ_ONCE(sqe->len);\n\tsp->flags = READ_ONCE(sqe->splice_flags);\n\tif (unlikely(sp->flags & ~valid_flags))\n\t\treturn -EINVAL;\n\tsp->splice_fd_in = READ_ONCE(sqe->splice_fd_in);\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_tee_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tif (READ_ONCE(sqe->splice_off_in) || READ_ONCE(sqe->off))\n\t\treturn -EINVAL;\n\treturn __io_splice_prep(req, sqe);\n}\n\nint io_tee(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_splice *sp = io_kiocb_to_cmd(req, struct io_splice);\n\tstruct file *out = sp->file_out;\n\tunsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED;\n\tstruct file *in;\n\tlong ret = 0;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tif (sp->flags & SPLICE_F_FD_IN_FIXED)\n\t\tin = io_file_get_fixed(req, sp->splice_fd_in, issue_flags);\n\telse\n\t\tin = io_file_get_normal(req, sp->splice_fd_in);\n\tif (!in) {\n\t\tret = -EBADF;\n\t\tgoto done;\n\t}\n\n\tif (sp->len)\n\t\tret = do_tee(in, out, sp->len, flags);\n\n\tif (!(sp->flags & SPLICE_F_FD_IN_FIXED))\n\t\tfput(in);\ndone:\n\tif (ret != sp->len)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nint io_splice_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_splice *sp = io_kiocb_to_cmd(req, struct io_splice);\n\n\tsp->off_in = READ_ONCE(sqe->splice_off_in);\n\tsp->off_out = READ_ONCE(sqe->off);\n\treturn __io_splice_prep(req, sqe);\n}\n\nint io_splice(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_splice *sp = io_kiocb_to_cmd(req, struct io_splice);\n\tstruct file *out = sp->file_out;\n\tunsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED;\n\tloff_t *poff_in, *poff_out;\n\tstruct file *in;\n\tlong ret = 0;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tif (sp->flags & SPLICE_F_FD_IN_FIXED)\n\t\tin = io_file_get_fixed(req, sp->splice_fd_in, issue_flags);\n\telse\n\t\tin = io_file_get_normal(req, sp->splice_fd_in);\n\tif (!in) {\n\t\tret = -EBADF;\n\t\tgoto done;\n\t}\n\n\tpoff_in = (sp->off_in == -1) ? NULL : &sp->off_in;\n\tpoff_out = (sp->off_out == -1) ? NULL : &sp->off_out;\n\n\tif (sp->len)\n\t\tret = do_splice(in, poff_in, out, poff_out, sp->len, flags);\n\n\tif (!(sp->flags & SPLICE_F_FD_IN_FIXED))\n\t\tfput(in);\ndone:\n\tif (ret != sp->len)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}