{
  "module_name": "sync.c",
  "hash_id": "24a1c694705da462c973b5595ea05451d1b702e631328670a3c4eed6f90062aa",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/sync.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/io_uring.h>\n#include <linux/fsnotify.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"io_uring.h\"\n#include \"sync.h\"\n\nstruct io_sync {\n\tstruct file\t\t\t*file;\n\tloff_t\t\t\t\tlen;\n\tloff_t\t\t\t\toff;\n\tint\t\t\t\tflags;\n\tint\t\t\t\tmode;\n};\n\nint io_sfr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_sync *sync = io_kiocb_to_cmd(req, struct io_sync);\n\n\tif (unlikely(sqe->addr || sqe->buf_index || sqe->splice_fd_in))\n\t\treturn -EINVAL;\n\n\tsync->off = READ_ONCE(sqe->off);\n\tsync->len = READ_ONCE(sqe->len);\n\tsync->flags = READ_ONCE(sqe->sync_range_flags);\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\n\treturn 0;\n}\n\nint io_sync_file_range(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_sync *sync = io_kiocb_to_cmd(req, struct io_sync);\n\tint ret;\n\n\t \n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = sync_file_range(req->file, sync->off, sync->len, sync->flags);\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nint io_fsync_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_sync *sync = io_kiocb_to_cmd(req, struct io_sync);\n\n\tif (unlikely(sqe->addr || sqe->buf_index || sqe->splice_fd_in))\n\t\treturn -EINVAL;\n\n\tsync->flags = READ_ONCE(sqe->fsync_flags);\n\tif (unlikely(sync->flags & ~IORING_FSYNC_DATASYNC))\n\t\treturn -EINVAL;\n\n\tsync->off = READ_ONCE(sqe->off);\n\tsync->len = READ_ONCE(sqe->len);\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_fsync(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_sync *sync = io_kiocb_to_cmd(req, struct io_sync);\n\tloff_t end = sync->off + sync->len;\n\tint ret;\n\n\t \n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = vfs_fsync_range(req->file, sync->off, end > 0 ? end : LLONG_MAX,\n\t\t\t\tsync->flags & IORING_FSYNC_DATASYNC);\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nint io_fallocate_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_sync *sync = io_kiocb_to_cmd(req, struct io_sync);\n\n\tif (sqe->buf_index || sqe->rw_flags || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\tsync->off = READ_ONCE(sqe->off);\n\tsync->len = READ_ONCE(sqe->addr);\n\tsync->mode = READ_ONCE(sqe->len);\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_fallocate(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_sync *sync = io_kiocb_to_cmd(req, struct io_sync);\n\tint ret;\n\n\t \n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = vfs_fallocate(req->file, sync->mode, sync->off, sync->len);\n\tif (ret >= 0)\n\t\tfsnotify_modify(req->file);\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}