{
  "module_name": "openclose.c",
  "hash_id": "b3c01141e92c76408023c16ac950935a349cb88f9dacada86558fd0f302a9529",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/openclose.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/io_uring.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"../fs/internal.h\"\n\n#include \"io_uring.h\"\n#include \"rsrc.h\"\n#include \"openclose.h\"\n\nstruct io_open {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tu32\t\t\t\tfile_slot;\n\tstruct filename\t\t\t*filename;\n\tstruct open_how\t\t\thow;\n\tunsigned long\t\t\tnofile;\n};\n\nstruct io_close {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tfd;\n\tu32\t\t\t\tfile_slot;\n};\n\nstatic bool io_openat_force_async(struct io_open *open)\n{\n\t \n\treturn open->how.flags & (O_TRUNC | O_CREAT | __O_TMPFILE);\n}\n\nstatic int __io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_open *open = io_kiocb_to_cmd(req, struct io_open);\n\tconst char __user *fname;\n\tint ret;\n\n\tif (unlikely(sqe->buf_index))\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\t \n\tif (!(open->how.flags & O_PATH) && force_o_largefile())\n\t\topen->how.flags |= O_LARGEFILE;\n\n\topen->dfd = READ_ONCE(sqe->fd);\n\tfname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\topen->filename = getname(fname);\n\tif (IS_ERR(open->filename)) {\n\t\tret = PTR_ERR(open->filename);\n\t\topen->filename = NULL;\n\t\treturn ret;\n\t}\n\n\topen->file_slot = READ_ONCE(sqe->file_index);\n\tif (open->file_slot && (open->how.flags & O_CLOEXEC))\n\t\treturn -EINVAL;\n\n\topen->nofile = rlimit(RLIMIT_NOFILE);\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\tif (io_openat_force_async(open))\n\t\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_open *open = io_kiocb_to_cmd(req, struct io_open);\n\tu64 mode = READ_ONCE(sqe->len);\n\tu64 flags = READ_ONCE(sqe->open_flags);\n\n\topen->how = build_open_how(flags, mode);\n\treturn __io_openat_prep(req, sqe);\n}\n\nint io_openat2_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_open *open = io_kiocb_to_cmd(req, struct io_open);\n\tstruct open_how __user *how;\n\tsize_t len;\n\tint ret;\n\n\thow = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tlen = READ_ONCE(sqe->len);\n\tif (len < OPEN_HOW_SIZE_VER0)\n\t\treturn -EINVAL;\n\n\tret = copy_struct_from_user(&open->how, sizeof(open->how), how, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __io_openat_prep(req, sqe);\n}\n\nint io_openat2(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_open *open = io_kiocb_to_cmd(req, struct io_open);\n\tstruct open_flags op;\n\tstruct file *file;\n\tbool resolve_nonblock, nonblock_set;\n\tbool fixed = !!open->file_slot;\n\tint ret;\n\n\tret = build_open_flags(&open->how, &op);\n\tif (ret)\n\t\tgoto err;\n\tnonblock_set = op.open_flag & O_NONBLOCK;\n\tresolve_nonblock = open->how.resolve & RESOLVE_CACHED;\n\tif (issue_flags & IO_URING_F_NONBLOCK) {\n\t\tWARN_ON_ONCE(io_openat_force_async(open));\n\t\top.lookup_flags |= LOOKUP_CACHED;\n\t\top.open_flag |= O_NONBLOCK;\n\t}\n\n\tif (!fixed) {\n\t\tret = __get_unused_fd_flags(open->how.flags, open->nofile);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tfile = do_filp_open(open->dfd, open->filename, &op);\n\tif (IS_ERR(file)) {\n\t\t \n\t\tif (!fixed)\n\t\t\tput_unused_fd(ret);\n\n\t\tret = PTR_ERR(file);\n\t\t \n\t\tif (ret == -EAGAIN &&\n\t\t    (!resolve_nonblock && (issue_flags & IO_URING_F_NONBLOCK)))\n\t\t\treturn -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tif ((issue_flags & IO_URING_F_NONBLOCK) && !nonblock_set)\n\t\tfile->f_flags &= ~O_NONBLOCK;\n\n\tif (!fixed)\n\t\tfd_install(ret, file);\n\telse\n\t\tret = io_fixed_fd_install(req, issue_flags, file,\n\t\t\t\t\t\topen->file_slot);\nerr:\n\tputname(open->filename);\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nint io_openat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\treturn io_openat2(req, issue_flags);\n}\n\nvoid io_open_cleanup(struct io_kiocb *req)\n{\n\tstruct io_open *open = io_kiocb_to_cmd(req, struct io_open);\n\n\tif (open->filename)\n\t\tputname(open->filename);\n}\n\nint __io_close_fixed(struct io_ring_ctx *ctx, unsigned int issue_flags,\n\t\t     unsigned int offset)\n{\n\tint ret;\n\n\tio_ring_submit_lock(ctx, issue_flags);\n\tret = io_fixed_fd_remove(ctx, offset);\n\tio_ring_submit_unlock(ctx, issue_flags);\n\n\treturn ret;\n}\n\nstatic inline int io_close_fixed(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_close *close = io_kiocb_to_cmd(req, struct io_close);\n\n\treturn __io_close_fixed(req->ctx, issue_flags, close->file_slot - 1);\n}\n\nint io_close_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_close *close = io_kiocb_to_cmd(req, struct io_close);\n\n\tif (sqe->off || sqe->addr || sqe->len || sqe->rw_flags || sqe->buf_index)\n\t\treturn -EINVAL;\n\tif (req->flags & REQ_F_FIXED_FILE)\n\t\treturn -EBADF;\n\n\tclose->fd = READ_ONCE(sqe->fd);\n\tclose->file_slot = READ_ONCE(sqe->file_index);\n\tif (close->file_slot && close->fd)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint io_close(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct files_struct *files = current->files;\n\tstruct io_close *close = io_kiocb_to_cmd(req, struct io_close);\n\tstruct fdtable *fdt;\n\tstruct file *file;\n\tint ret = -EBADF;\n\n\tif (close->file_slot) {\n\t\tret = io_close_fixed(req, issue_flags);\n\t\tgoto err;\n\t}\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (close->fd >= fdt->max_fds) {\n\t\tspin_unlock(&files->file_lock);\n\t\tgoto err;\n\t}\n\tfile = rcu_dereference_protected(fdt->fd[close->fd],\n\t\t\tlockdep_is_held(&files->file_lock));\n\tif (!file || io_is_uring_fops(file)) {\n\t\tspin_unlock(&files->file_lock);\n\t\tgoto err;\n\t}\n\n\t \n\tif (file->f_op->flush && (issue_flags & IO_URING_F_NONBLOCK)) {\n\t\tspin_unlock(&files->file_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tfile = __close_fd_get_file(close->fd);\n\tspin_unlock(&files->file_lock);\n\tif (!file)\n\t\tgoto err;\n\n\t \n\tret = filp_close(file, current->files);\nerr:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}