{
  "module_name": "fs.c",
  "hash_id": "cd8190269c7e5ea8654afc3375b5854256ea7a91c8766ae4a46bc74946de2f6b",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/fs.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/io_uring.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"../fs/internal.h\"\n\n#include \"io_uring.h\"\n#include \"fs.h\"\n\nstruct io_rename {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\told_dfd;\n\tint\t\t\t\tnew_dfd;\n\tstruct filename\t\t\t*oldpath;\n\tstruct filename\t\t\t*newpath;\n\tint\t\t\t\tflags;\n};\n\nstruct io_unlink {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tint\t\t\t\tflags;\n\tstruct filename\t\t\t*filename;\n};\n\nstruct io_mkdir {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdfd;\n\tumode_t\t\t\t\tmode;\n\tstruct filename\t\t\t*filename;\n};\n\nstruct io_link {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\told_dfd;\n\tint\t\t\t\tnew_dfd;\n\tstruct filename\t\t\t*oldpath;\n\tstruct filename\t\t\t*newpath;\n\tint\t\t\t\tflags;\n};\n\nint io_renameat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_rename *ren = io_kiocb_to_cmd(req, struct io_rename);\n\tconst char __user *oldf, *newf;\n\n\tif (sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tren->old_dfd = READ_ONCE(sqe->fd);\n\toldf = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tnewf = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tren->new_dfd = READ_ONCE(sqe->len);\n\tren->flags = READ_ONCE(sqe->rename_flags);\n\n\tren->oldpath = getname(oldf);\n\tif (IS_ERR(ren->oldpath))\n\t\treturn PTR_ERR(ren->oldpath);\n\n\tren->newpath = getname(newf);\n\tif (IS_ERR(ren->newpath)) {\n\t\tputname(ren->oldpath);\n\t\treturn PTR_ERR(ren->newpath);\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_renameat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_rename *ren = io_kiocb_to_cmd(req, struct io_rename);\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = do_renameat2(ren->old_dfd, ren->oldpath, ren->new_dfd,\n\t\t\t\tren->newpath, ren->flags);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nvoid io_renameat_cleanup(struct io_kiocb *req)\n{\n\tstruct io_rename *ren = io_kiocb_to_cmd(req, struct io_rename);\n\n\tputname(ren->oldpath);\n\tputname(ren->newpath);\n}\n\nint io_unlinkat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_unlink *un = io_kiocb_to_cmd(req, struct io_unlink);\n\tconst char __user *fname;\n\n\tif (sqe->off || sqe->len || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tun->dfd = READ_ONCE(sqe->fd);\n\n\tun->flags = READ_ONCE(sqe->unlink_flags);\n\tif (un->flags & ~AT_REMOVEDIR)\n\t\treturn -EINVAL;\n\n\tfname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tun->filename = getname(fname);\n\tif (IS_ERR(un->filename))\n\t\treturn PTR_ERR(un->filename);\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_unlinkat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_unlink *un = io_kiocb_to_cmd(req, struct io_unlink);\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tif (un->flags & AT_REMOVEDIR)\n\t\tret = do_rmdir(un->dfd, un->filename);\n\telse\n\t\tret = do_unlinkat(un->dfd, un->filename);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nvoid io_unlinkat_cleanup(struct io_kiocb *req)\n{\n\tstruct io_unlink *ul = io_kiocb_to_cmd(req, struct io_unlink);\n\n\tputname(ul->filename);\n}\n\nint io_mkdirat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_mkdir *mkd = io_kiocb_to_cmd(req, struct io_mkdir);\n\tconst char __user *fname;\n\n\tif (sqe->off || sqe->rw_flags || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tmkd->dfd = READ_ONCE(sqe->fd);\n\tmkd->mode = READ_ONCE(sqe->len);\n\n\tfname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tmkd->filename = getname(fname);\n\tif (IS_ERR(mkd->filename))\n\t\treturn PTR_ERR(mkd->filename);\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_mkdirat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_mkdir *mkd = io_kiocb_to_cmd(req, struct io_mkdir);\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = do_mkdirat(mkd->dfd, mkd->filename, mkd->mode);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nvoid io_mkdirat_cleanup(struct io_kiocb *req)\n{\n\tstruct io_mkdir *md = io_kiocb_to_cmd(req, struct io_mkdir);\n\n\tputname(md->filename);\n}\n\nint io_symlinkat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_link *sl = io_kiocb_to_cmd(req, struct io_link);\n\tconst char __user *oldpath, *newpath;\n\n\tif (sqe->len || sqe->rw_flags || sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tsl->new_dfd = READ_ONCE(sqe->fd);\n\toldpath = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tnewpath = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\n\tsl->oldpath = getname(oldpath);\n\tif (IS_ERR(sl->oldpath))\n\t\treturn PTR_ERR(sl->oldpath);\n\n\tsl->newpath = getname(newpath);\n\tif (IS_ERR(sl->newpath)) {\n\t\tputname(sl->oldpath);\n\t\treturn PTR_ERR(sl->newpath);\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_symlinkat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_link *sl = io_kiocb_to_cmd(req, struct io_link);\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = do_symlinkat(sl->oldpath, sl->new_dfd, sl->newpath);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nint io_linkat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_link *lnk = io_kiocb_to_cmd(req, struct io_link);\n\tconst char __user *oldf, *newf;\n\n\tif (sqe->buf_index || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tlnk->old_dfd = READ_ONCE(sqe->fd);\n\tlnk->new_dfd = READ_ONCE(sqe->len);\n\toldf = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tnewf = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tlnk->flags = READ_ONCE(sqe->hardlink_flags);\n\n\tlnk->oldpath = getname_uflags(oldf, lnk->flags);\n\tif (IS_ERR(lnk->oldpath))\n\t\treturn PTR_ERR(lnk->oldpath);\n\n\tlnk->newpath = getname(newf);\n\tif (IS_ERR(lnk->newpath)) {\n\t\tputname(lnk->oldpath);\n\t\treturn PTR_ERR(lnk->newpath);\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_linkat(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_link *lnk = io_kiocb_to_cmd(req, struct io_link);\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = do_linkat(lnk->old_dfd, lnk->oldpath, lnk->new_dfd,\n\t\t\t\tlnk->newpath, lnk->flags);\n\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nvoid io_link_cleanup(struct io_kiocb *req)\n{\n\tstruct io_link *sl = io_kiocb_to_cmd(req, struct io_link);\n\n\tputname(sl->oldpath);\n\tputname(sl->newpath);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}