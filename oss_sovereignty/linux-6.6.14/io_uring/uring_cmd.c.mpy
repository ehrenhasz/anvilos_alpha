{
  "module_name": "uring_cmd.c",
  "hash_id": "9829aec7e89d44f4d2cce67f4f6e97a1013cee475c0faaa2e200ef377e8f3701",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/uring_cmd.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/io_uring.h>\n#include <linux/security.h>\n#include <linux/nospec.h>\n\n#include <uapi/linux/io_uring.h>\n#include <asm/ioctls.h>\n\n#include \"io_uring.h\"\n#include \"rsrc.h\"\n#include \"uring_cmd.h\"\n\nstatic void io_uring_cmd_work(struct io_kiocb *req, struct io_tw_state *ts)\n{\n\tstruct io_uring_cmd *ioucmd = io_kiocb_to_cmd(req, struct io_uring_cmd);\n\tunsigned issue_flags = ts->locked ? 0 : IO_URING_F_UNLOCKED;\n\n\tioucmd->task_work_cb(ioucmd, issue_flags);\n}\n\nvoid __io_uring_cmd_do_in_task(struct io_uring_cmd *ioucmd,\n\t\t\tvoid (*task_work_cb)(struct io_uring_cmd *, unsigned),\n\t\t\tunsigned flags)\n{\n\tstruct io_kiocb *req = cmd_to_io_kiocb(ioucmd);\n\n\tioucmd->task_work_cb = task_work_cb;\n\treq->io_task_work.func = io_uring_cmd_work;\n\t__io_req_task_work_add(req, flags);\n}\nEXPORT_SYMBOL_GPL(__io_uring_cmd_do_in_task);\n\nvoid io_uring_cmd_do_in_task_lazy(struct io_uring_cmd *ioucmd,\n\t\t\tvoid (*task_work_cb)(struct io_uring_cmd *, unsigned))\n{\n\t__io_uring_cmd_do_in_task(ioucmd, task_work_cb, IOU_F_TWQ_LAZY_WAKE);\n}\nEXPORT_SYMBOL_GPL(io_uring_cmd_do_in_task_lazy);\n\nstatic inline void io_req_set_cqe32_extra(struct io_kiocb *req,\n\t\t\t\t\t  u64 extra1, u64 extra2)\n{\n\treq->big_cqe.extra1 = extra1;\n\treq->big_cqe.extra2 = extra2;\n}\n\n \nvoid io_uring_cmd_done(struct io_uring_cmd *ioucmd, ssize_t ret, ssize_t res2,\n\t\t       unsigned issue_flags)\n{\n\tstruct io_kiocb *req = cmd_to_io_kiocb(ioucmd);\n\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\n\tio_req_set_res(req, ret, 0);\n\tif (req->ctx->flags & IORING_SETUP_CQE32)\n\t\tio_req_set_cqe32_extra(req, res2, 0);\n\tif (req->ctx->flags & IORING_SETUP_IOPOLL) {\n\t\t \n\t\tsmp_store_release(&req->iopoll_completed, 1);\n\t} else {\n\t\tstruct io_tw_state ts = {\n\t\t\t.locked = !(issue_flags & IO_URING_F_UNLOCKED),\n\t\t};\n\t\tio_req_task_complete(req, &ts);\n\t}\n}\nEXPORT_SYMBOL_GPL(io_uring_cmd_done);\n\nint io_uring_cmd_prep_async(struct io_kiocb *req)\n{\n\tstruct io_uring_cmd *ioucmd = io_kiocb_to_cmd(req, struct io_uring_cmd);\n\n\tmemcpy(req->async_data, ioucmd->sqe, uring_sqe_size(req->ctx));\n\tioucmd->sqe = req->async_data;\n\treturn 0;\n}\n\nint io_uring_cmd_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_uring_cmd *ioucmd = io_kiocb_to_cmd(req, struct io_uring_cmd);\n\n\tif (sqe->__pad1)\n\t\treturn -EINVAL;\n\n\tioucmd->flags = READ_ONCE(sqe->uring_cmd_flags);\n\tif (ioucmd->flags & ~IORING_URING_CMD_FIXED)\n\t\treturn -EINVAL;\n\n\tif (ioucmd->flags & IORING_URING_CMD_FIXED) {\n\t\tstruct io_ring_ctx *ctx = req->ctx;\n\t\tu16 index;\n\n\t\treq->buf_index = READ_ONCE(sqe->buf_index);\n\t\tif (unlikely(req->buf_index >= ctx->nr_user_bufs))\n\t\t\treturn -EFAULT;\n\t\tindex = array_index_nospec(req->buf_index, ctx->nr_user_bufs);\n\t\treq->imu = ctx->user_bufs[index];\n\t\tio_req_set_rsrc_node(req, ctx, 0);\n\t}\n\tioucmd->sqe = sqe;\n\tioucmd->cmd_op = READ_ONCE(sqe->cmd_op);\n\treturn 0;\n}\n\nint io_uring_cmd(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_uring_cmd *ioucmd = io_kiocb_to_cmd(req, struct io_uring_cmd);\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\n\tif (!file->f_op->uring_cmd)\n\t\treturn -EOPNOTSUPP;\n\n\tret = security_uring_cmd(ioucmd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->flags & IORING_SETUP_SQE128)\n\t\tissue_flags |= IO_URING_F_SQE128;\n\tif (ctx->flags & IORING_SETUP_CQE32)\n\t\tissue_flags |= IO_URING_F_CQE32;\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!file->f_op->uring_cmd_iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\t\tissue_flags |= IO_URING_F_IOPOLL;\n\t\treq->iopoll_completed = 0;\n\t\tWRITE_ONCE(ioucmd->cookie, NULL);\n\t}\n\n\tret = file->f_op->uring_cmd(ioucmd, issue_flags);\n\tif (ret == -EAGAIN) {\n\t\tif (!req_has_async_data(req)) {\n\t\t\tif (io_alloc_async_data(req))\n\t\t\t\treturn -ENOMEM;\n\t\t\tio_uring_cmd_prep_async(req);\n\t\t}\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ret != -EIOCBQUEUED) {\n\t\tif (ret < 0)\n\t\t\treq_set_fail(req);\n\t\tio_req_set_res(req, ret, 0);\n\t\treturn ret;\n\t}\n\n\treturn IOU_ISSUE_SKIP_COMPLETE;\n}\n\nint io_uring_cmd_import_fixed(u64 ubuf, unsigned long len, int rw,\n\t\t\t      struct iov_iter *iter, void *ioucmd)\n{\n\tstruct io_kiocb *req = cmd_to_io_kiocb(ioucmd);\n\n\treturn io_import_fixed(rw, iter, req->imu, ubuf, len);\n}\nEXPORT_SYMBOL_GPL(io_uring_cmd_import_fixed);\n\nint io_uring_cmd_sock(struct io_uring_cmd *cmd, unsigned int issue_flags)\n{\n\tstruct socket *sock = cmd->file->private_data;\n\tstruct sock *sk = sock->sk;\n\tstruct proto *prot = READ_ONCE(sk->sk_prot);\n\tint ret, arg = 0;\n\n\tif (!prot || !prot->ioctl)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd->sqe->cmd_op) {\n\tcase SOCKET_URING_OP_SIOCINQ:\n\t\tret = prot->ioctl(sk, SIOCINQ, &arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn arg;\n\tcase SOCKET_URING_OP_SIOCOUTQ:\n\t\tret = prot->ioctl(sk, SIOCOUTQ, &arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn arg;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\nEXPORT_SYMBOL_GPL(io_uring_cmd_sock);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}