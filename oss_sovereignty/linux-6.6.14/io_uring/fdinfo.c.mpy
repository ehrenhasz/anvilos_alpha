{
  "module_name": "fdinfo.c",
  "hash_id": "0d1260936bc653eff28919f8e926a966baa72bc8133f2c31fcd94905bd410424",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/fdinfo.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/io_uring.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"io_uring.h\"\n#include \"sqpoll.h\"\n#include \"fdinfo.h\"\n#include \"cancel.h\"\n#include \"rsrc.h\"\n\n#ifdef CONFIG_PROC_FS\nstatic __cold int io_uring_show_cred(struct seq_file *m, unsigned int id,\n\t\tconst struct cred *cred)\n{\n\tstruct user_namespace *uns = seq_user_ns(m);\n\tstruct group_info *gi;\n\tkernel_cap_t cap;\n\tint g;\n\n\tseq_printf(m, \"%5d\\n\", id);\n\tseq_put_decimal_ull(m, \"\\tUid:\\t\", from_kuid_munged(uns, cred->uid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->euid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->suid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->fsuid));\n\tseq_put_decimal_ull(m, \"\\n\\tGid:\\t\", from_kgid_munged(uns, cred->gid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->egid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->sgid));\n\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->fsgid));\n\tseq_puts(m, \"\\n\\tGroups:\\t\");\n\tgi = cred->group_info;\n\tfor (g = 0; g < gi->ngroups; g++) {\n\t\tseq_put_decimal_ull(m, g ? \" \" : \"\",\n\t\t\t\t\tfrom_kgid_munged(uns, gi->gid[g]));\n\t}\n\tseq_puts(m, \"\\n\\tCapEff:\\t\");\n\tcap = cred->cap_effective;\n\tseq_put_hex_ll(m, NULL, cap.val, 16);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\n \n__cold void io_uring_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct io_ring_ctx *ctx = f->private_data;\n\tstruct io_overflow_cqe *ocqe;\n\tstruct io_rings *r = ctx->rings;\n\tunsigned int sq_mask = ctx->sq_entries - 1, cq_mask = ctx->cq_entries - 1;\n\tunsigned int sq_head = READ_ONCE(r->sq.head);\n\tunsigned int sq_tail = READ_ONCE(r->sq.tail);\n\tunsigned int cq_head = READ_ONCE(r->cq.head);\n\tunsigned int cq_tail = READ_ONCE(r->cq.tail);\n\tunsigned int cq_shift = 0;\n\tunsigned int sq_shift = 0;\n\tunsigned int sq_entries, cq_entries;\n\tint sq_pid = -1, sq_cpu = -1;\n\tbool has_lock;\n\tunsigned int i;\n\n\tif (ctx->flags & IORING_SETUP_CQE32)\n\t\tcq_shift = 1;\n\tif (ctx->flags & IORING_SETUP_SQE128)\n\t\tsq_shift = 1;\n\n\t \n\tseq_printf(m, \"SqMask:\\t0x%x\\n\", sq_mask);\n\tseq_printf(m, \"SqHead:\\t%u\\n\", sq_head);\n\tseq_printf(m, \"SqTail:\\t%u\\n\", sq_tail);\n\tseq_printf(m, \"CachedSqHead:\\t%u\\n\", ctx->cached_sq_head);\n\tseq_printf(m, \"CqMask:\\t0x%x\\n\", cq_mask);\n\tseq_printf(m, \"CqHead:\\t%u\\n\", cq_head);\n\tseq_printf(m, \"CqTail:\\t%u\\n\", cq_tail);\n\tseq_printf(m, \"CachedCqTail:\\t%u\\n\", ctx->cached_cq_tail);\n\tseq_printf(m, \"SQEs:\\t%u\\n\", sq_tail - sq_head);\n\tsq_entries = min(sq_tail - sq_head, ctx->sq_entries);\n\tfor (i = 0; i < sq_entries; i++) {\n\t\tunsigned int entry = i + sq_head;\n\t\tstruct io_uring_sqe *sqe;\n\t\tunsigned int sq_idx;\n\n\t\tif (ctx->flags & IORING_SETUP_NO_SQARRAY)\n\t\t\tbreak;\n\t\tsq_idx = READ_ONCE(ctx->sq_array[entry & sq_mask]);\n\t\tif (sq_idx > sq_mask)\n\t\t\tcontinue;\n\t\tsqe = &ctx->sq_sqes[sq_idx << sq_shift];\n\t\tseq_printf(m, \"%5u: opcode:%s, fd:%d, flags:%x, off:%llu, \"\n\t\t\t      \"addr:0x%llx, rw_flags:0x%x, buf_index:%d \"\n\t\t\t      \"user_data:%llu\",\n\t\t\t   sq_idx, io_uring_get_opcode(sqe->opcode), sqe->fd,\n\t\t\t   sqe->flags, (unsigned long long) sqe->off,\n\t\t\t   (unsigned long long) sqe->addr, sqe->rw_flags,\n\t\t\t   sqe->buf_index, sqe->user_data);\n\t\tif (sq_shift) {\n\t\t\tu64 *sqeb = (void *) (sqe + 1);\n\t\t\tint size = sizeof(struct io_uring_sqe) / sizeof(u64);\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tseq_printf(m, \", e%d:0x%llx\", j,\n\t\t\t\t\t\t(unsigned long long) *sqeb);\n\t\t\t\tsqeb++;\n\t\t\t}\n\t\t}\n\t\tseq_printf(m, \"\\n\");\n\t}\n\tseq_printf(m, \"CQEs:\\t%u\\n\", cq_tail - cq_head);\n\tcq_entries = min(cq_tail - cq_head, ctx->cq_entries);\n\tfor (i = 0; i < cq_entries; i++) {\n\t\tunsigned int entry = i + cq_head;\n\t\tstruct io_uring_cqe *cqe = &r->cqes[(entry & cq_mask) << cq_shift];\n\n\t\tseq_printf(m, \"%5u: user_data:%llu, res:%d, flag:%x\",\n\t\t\t   entry & cq_mask, cqe->user_data, cqe->res,\n\t\t\t   cqe->flags);\n\t\tif (cq_shift)\n\t\t\tseq_printf(m, \", extra1:%llu, extra2:%llu\\n\",\n\t\t\t\t\tcqe->big_cqe[0], cqe->big_cqe[1]);\n\t\tseq_printf(m, \"\\n\");\n\t}\n\n\t \n\thas_lock = mutex_trylock(&ctx->uring_lock);\n\n\tif (has_lock && (ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\tstruct io_sq_data *sq = ctx->sq_data;\n\n\t\tsq_pid = sq->task_pid;\n\t\tsq_cpu = sq->sq_cpu;\n\t}\n\n\tseq_printf(m, \"SqThread:\\t%d\\n\", sq_pid);\n\tseq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq_cpu);\n\tseq_printf(m, \"UserFiles:\\t%u\\n\", ctx->nr_user_files);\n\tfor (i = 0; has_lock && i < ctx->nr_user_files; i++) {\n\t\tstruct file *f = io_file_from_index(&ctx->file_table, i);\n\n\t\tif (f)\n\t\t\tseq_printf(m, \"%5u: %s\\n\", i, file_dentry(f)->d_iname);\n\t\telse\n\t\t\tseq_printf(m, \"%5u: <none>\\n\", i);\n\t}\n\tseq_printf(m, \"UserBufs:\\t%u\\n\", ctx->nr_user_bufs);\n\tfor (i = 0; has_lock && i < ctx->nr_user_bufs; i++) {\n\t\tstruct io_mapped_ubuf *buf = ctx->user_bufs[i];\n\t\tunsigned int len = buf->ubuf_end - buf->ubuf;\n\n\t\tseq_printf(m, \"%5u: 0x%llx/%u\\n\", i, buf->ubuf, len);\n\t}\n\tif (has_lock && !xa_empty(&ctx->personalities)) {\n\t\tunsigned long index;\n\t\tconst struct cred *cred;\n\n\t\tseq_printf(m, \"Personalities:\\n\");\n\t\txa_for_each(&ctx->personalities, index, cred)\n\t\t\tio_uring_show_cred(m, index, cred);\n\t}\n\n\tseq_puts(m, \"PollList:\\n\");\n\tfor (i = 0; i < (1U << ctx->cancel_table.hash_bits); i++) {\n\t\tstruct io_hash_bucket *hb = &ctx->cancel_table.hbs[i];\n\t\tstruct io_hash_bucket *hbl = &ctx->cancel_table_locked.hbs[i];\n\t\tstruct io_kiocb *req;\n\n\t\tspin_lock(&hb->lock);\n\t\thlist_for_each_entry(req, &hb->list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t\tspin_unlock(&hb->lock);\n\n\t\tif (!has_lock)\n\t\t\tcontinue;\n\t\thlist_for_each_entry(req, &hbl->list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t}\n\n\tif (has_lock)\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\tseq_puts(m, \"CqOverflowList:\\n\");\n\tspin_lock(&ctx->completion_lock);\n\tlist_for_each_entry(ocqe, &ctx->cq_overflow_list, list) {\n\t\tstruct io_uring_cqe *cqe = &ocqe->cqe;\n\n\t\tseq_printf(m, \"  user_data=%llu, res=%d, flags=%x\\n\",\n\t\t\t   cqe->user_data, cqe->res, cqe->flags);\n\n\t}\n\n\tspin_unlock(&ctx->completion_lock);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}