{
  "module_name": "io-wq.h",
  "hash_id": "eeae81f0283c84321d18e40be054c9b8186eaee29362f270c6bc83e46b57fa04",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/io-wq.h",
  "human_readable_source": "#ifndef INTERNAL_IO_WQ_H\n#define INTERNAL_IO_WQ_H\n\n#include <linux/refcount.h>\n#include <linux/io_uring_types.h>\n\nstruct io_wq;\n\nenum {\n\tIO_WQ_WORK_CANCEL\t= 1,\n\tIO_WQ_WORK_HASHED\t= 2,\n\tIO_WQ_WORK_UNBOUND\t= 4,\n\tIO_WQ_WORK_CONCURRENT\t= 16,\n\n\tIO_WQ_HASH_SHIFT\t= 24,\t \n};\n\nenum io_wq_cancel {\n\tIO_WQ_CANCEL_OK,\t \n\tIO_WQ_CANCEL_RUNNING,\t \n\tIO_WQ_CANCEL_NOTFOUND,\t \n};\n\ntypedef struct io_wq_work *(free_work_fn)(struct io_wq_work *);\ntypedef void (io_wq_work_fn)(struct io_wq_work *);\n\nstruct io_wq_hash {\n\trefcount_t refs;\n\tunsigned long map;\n\tstruct wait_queue_head wait;\n};\n\nstatic inline void io_wq_put_hash(struct io_wq_hash *hash)\n{\n\tif (refcount_dec_and_test(&hash->refs))\n\t\tkfree(hash);\n}\n\nstruct io_wq_data {\n\tstruct io_wq_hash *hash;\n\tstruct task_struct *task;\n\tio_wq_work_fn *do_work;\n\tfree_work_fn *free_work;\n};\n\nstruct io_wq *io_wq_create(unsigned bounded, struct io_wq_data *data);\nvoid io_wq_exit_start(struct io_wq *wq);\nvoid io_wq_put_and_exit(struct io_wq *wq);\n\nvoid io_wq_enqueue(struct io_wq *wq, struct io_wq_work *work);\nvoid io_wq_hash_work(struct io_wq_work *work, void *val);\n\nint io_wq_cpu_affinity(struct io_uring_task *tctx, cpumask_var_t mask);\nint io_wq_max_workers(struct io_wq *wq, int *new_count);\nbool io_wq_worker_stopped(void);\n\nstatic inline bool io_wq_is_hashed(struct io_wq_work *work)\n{\n\treturn work->flags & IO_WQ_WORK_HASHED;\n}\n\ntypedef bool (work_cancel_fn)(struct io_wq_work *, void *);\n\nenum io_wq_cancel io_wq_cancel_cb(struct io_wq *wq, work_cancel_fn *cancel,\n\t\t\t\t\tvoid *data, bool cancel_all);\n\n#if defined(CONFIG_IO_WQ)\nextern void io_wq_worker_sleeping(struct task_struct *);\nextern void io_wq_worker_running(struct task_struct *);\n#else\nstatic inline void io_wq_worker_sleeping(struct task_struct *tsk)\n{\n}\nstatic inline void io_wq_worker_running(struct task_struct *tsk)\n{\n}\n#endif\n\nstatic inline bool io_wq_current_is_worker(void)\n{\n\treturn in_task() && (current->flags & PF_IO_WORKER) &&\n\t\tcurrent->worker_private;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}