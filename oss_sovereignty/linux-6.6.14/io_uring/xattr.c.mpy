{
  "module_name": "xattr.c",
  "hash_id": "7b3d251d6026409eaf14d0d9a1dcd3ef13a1ad94b19b5fba68038157f164f190",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/xattr.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/io_uring.h>\n#include <linux/xattr.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"../fs/internal.h\"\n\n#include \"io_uring.h\"\n#include \"xattr.h\"\n\nstruct io_xattr {\n\tstruct file\t\t\t*file;\n\tstruct xattr_ctx\t\tctx;\n\tstruct filename\t\t\t*filename;\n};\n\nvoid io_xattr_cleanup(struct io_kiocb *req)\n{\n\tstruct io_xattr *ix = io_kiocb_to_cmd(req, struct io_xattr);\n\n\tif (ix->filename)\n\t\tputname(ix->filename);\n\n\tkfree(ix->ctx.kname);\n\tkvfree(ix->ctx.kvalue);\n}\n\nstatic void io_xattr_finish(struct io_kiocb *req, int ret)\n{\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\n\tio_xattr_cleanup(req);\n\tio_req_set_res(req, ret, 0);\n}\n\nstatic int __io_getxattr_prep(struct io_kiocb *req,\n\t\t\t      const struct io_uring_sqe *sqe)\n{\n\tstruct io_xattr *ix = io_kiocb_to_cmd(req, struct io_xattr);\n\tconst char __user *name;\n\tint ret;\n\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tix->filename = NULL;\n\tix->ctx.kvalue = NULL;\n\tname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tix->ctx.cvalue = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tix->ctx.size = READ_ONCE(sqe->len);\n\tix->ctx.flags = READ_ONCE(sqe->xattr_flags);\n\n\tif (ix->ctx.flags)\n\t\treturn -EINVAL;\n\n\tix->ctx.kname = kmalloc(sizeof(*ix->ctx.kname), GFP_KERNEL);\n\tif (!ix->ctx.kname)\n\t\treturn -ENOMEM;\n\n\tret = strncpy_from_user(ix->ctx.kname->name, name,\n\t\t\t\tsizeof(ix->ctx.kname->name));\n\tif (!ret || ret == sizeof(ix->ctx.kname->name))\n\t\tret = -ERANGE;\n\tif (ret < 0) {\n\t\tkfree(ix->ctx.kname);\n\t\treturn ret;\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_fgetxattr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\treturn __io_getxattr_prep(req, sqe);\n}\n\nint io_getxattr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_xattr *ix = io_kiocb_to_cmd(req, struct io_xattr);\n\tconst char __user *path;\n\tint ret;\n\n\tret = __io_getxattr_prep(req, sqe);\n\tif (ret)\n\t\treturn ret;\n\n\tpath = u64_to_user_ptr(READ_ONCE(sqe->addr3));\n\n\tix->filename = getname_flags(path, LOOKUP_FOLLOW, NULL);\n\tif (IS_ERR(ix->filename)) {\n\t\tret = PTR_ERR(ix->filename);\n\t\tix->filename = NULL;\n\t}\n\n\treturn ret;\n}\n\nint io_fgetxattr(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_xattr *ix = io_kiocb_to_cmd(req, struct io_xattr);\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = do_getxattr(mnt_idmap(req->file->f_path.mnt),\n\t\t\treq->file->f_path.dentry,\n\t\t\t&ix->ctx);\n\n\tio_xattr_finish(req, ret);\n\treturn IOU_OK;\n}\n\nint io_getxattr(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_xattr *ix = io_kiocb_to_cmd(req, struct io_xattr);\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\tstruct path path;\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\nretry:\n\tret = filename_lookup(AT_FDCWD, ix->filename, lookup_flags, &path, NULL);\n\tif (!ret) {\n\t\tret = do_getxattr(mnt_idmap(path.mnt), path.dentry, &ix->ctx);\n\n\t\tpath_put(&path);\n\t\tif (retry_estale(ret, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tio_xattr_finish(req, ret);\n\treturn IOU_OK;\n}\n\nstatic int __io_setxattr_prep(struct io_kiocb *req,\n\t\t\tconst struct io_uring_sqe *sqe)\n{\n\tstruct io_xattr *ix = io_kiocb_to_cmd(req, struct io_xattr);\n\tconst char __user *name;\n\tint ret;\n\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\tix->filename = NULL;\n\tname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tix->ctx.cvalue = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\tix->ctx.kvalue = NULL;\n\tix->ctx.size = READ_ONCE(sqe->len);\n\tix->ctx.flags = READ_ONCE(sqe->xattr_flags);\n\n\tix->ctx.kname = kmalloc(sizeof(*ix->ctx.kname), GFP_KERNEL);\n\tif (!ix->ctx.kname)\n\t\treturn -ENOMEM;\n\n\tret = setxattr_copy(name, &ix->ctx);\n\tif (ret) {\n\t\tkfree(ix->ctx.kname);\n\t\treturn ret;\n\t}\n\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_setxattr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_xattr *ix = io_kiocb_to_cmd(req, struct io_xattr);\n\tconst char __user *path;\n\tint ret;\n\n\tret = __io_setxattr_prep(req, sqe);\n\tif (ret)\n\t\treturn ret;\n\n\tpath = u64_to_user_ptr(READ_ONCE(sqe->addr3));\n\n\tix->filename = getname_flags(path, LOOKUP_FOLLOW, NULL);\n\tif (IS_ERR(ix->filename)) {\n\t\tret = PTR_ERR(ix->filename);\n\t\tix->filename = NULL;\n\t}\n\n\treturn ret;\n}\n\nint io_fsetxattr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\treturn __io_setxattr_prep(req, sqe);\n}\n\nstatic int __io_setxattr(struct io_kiocb *req, unsigned int issue_flags,\n\t\t\tconst struct path *path)\n{\n\tstruct io_xattr *ix = io_kiocb_to_cmd(req, struct io_xattr);\n\tint ret;\n\n\tret = mnt_want_write(path->mnt);\n\tif (!ret) {\n\t\tret = do_setxattr(mnt_idmap(path->mnt), path->dentry, &ix->ctx);\n\t\tmnt_drop_write(path->mnt);\n\t}\n\n\treturn ret;\n}\n\nint io_fsetxattr(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tret = __io_setxattr(req, issue_flags, &req->file->f_path);\n\tio_xattr_finish(req, ret);\n\treturn IOU_OK;\n}\n\nint io_setxattr(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_xattr *ix = io_kiocb_to_cmd(req, struct io_xattr);\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\tstruct path path;\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\nretry:\n\tret = filename_lookup(AT_FDCWD, ix->filename, lookup_flags, &path, NULL);\n\tif (!ret) {\n\t\tret = __io_setxattr(req, issue_flags, &path);\n\t\tpath_put(&path);\n\t\tif (retry_estale(ret, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tio_xattr_finish(req, ret);\n\treturn IOU_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}