{
  "module_name": "net.c",
  "hash_id": "7edae2e783f766ced09465cd9c2bb76e391c79c3ca783bacda443c4e081678e5",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/net.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/net.h>\n#include <linux/compat.h>\n#include <net/compat.h>\n#include <linux/io_uring.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"io_uring.h\"\n#include \"kbuf.h\"\n#include \"alloc_cache.h\"\n#include \"net.h\"\n#include \"notif.h\"\n#include \"rsrc.h\"\n\n#if defined(CONFIG_NET)\nstruct io_shutdown {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\thow;\n};\n\nstruct io_accept {\n\tstruct file\t\t\t*file;\n\tstruct sockaddr __user\t\t*addr;\n\tint __user\t\t\t*addr_len;\n\tint\t\t\t\tflags;\n\tu32\t\t\t\tfile_slot;\n\tunsigned long\t\t\tnofile;\n};\n\nstruct io_socket {\n\tstruct file\t\t\t*file;\n\tint\t\t\t\tdomain;\n\tint\t\t\t\ttype;\n\tint\t\t\t\tprotocol;\n\tint\t\t\t\tflags;\n\tu32\t\t\t\tfile_slot;\n\tunsigned long\t\t\tnofile;\n};\n\nstruct io_connect {\n\tstruct file\t\t\t*file;\n\tstruct sockaddr __user\t\t*addr;\n\tint\t\t\t\taddr_len;\n\tbool\t\t\t\tin_progress;\n\tbool\t\t\t\tseen_econnaborted;\n};\n\nstruct io_sr_msg {\n\tstruct file\t\t\t*file;\n\tunion {\n\t\tstruct compat_msghdr __user\t*umsg_compat;\n\t\tstruct user_msghdr __user\t*umsg;\n\t\tvoid __user\t\t\t*buf;\n\t};\n\tunsigned\t\t\tlen;\n\tunsigned\t\t\tdone_io;\n\tunsigned\t\t\tmsg_flags;\n\tu16\t\t\t\tflags;\n\t \n\tu16\t\t\t\taddr_len;\n\tu16\t\t\t\tbuf_group;\n\tvoid __user\t\t\t*addr;\n\tvoid __user\t\t\t*msg_control;\n\t \n\tstruct io_kiocb \t\t*notif;\n};\n\nstatic inline bool io_check_multishot(struct io_kiocb *req,\n\t\t\t\t      unsigned int issue_flags)\n{\n\t \n\treturn !(issue_flags & IO_URING_F_IOWQ) ||\n\t\t!(issue_flags & IO_URING_F_MULTISHOT) ||\n\t\t!req->ctx->task_complete;\n}\n\nint io_shutdown_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_shutdown *shutdown = io_kiocb_to_cmd(req, struct io_shutdown);\n\n\tif (unlikely(sqe->off || sqe->addr || sqe->rw_flags ||\n\t\t     sqe->buf_index || sqe->splice_fd_in))\n\t\treturn -EINVAL;\n\n\tshutdown->how = READ_ONCE(sqe->len);\n\treq->flags |= REQ_F_FORCE_ASYNC;\n\treturn 0;\n}\n\nint io_shutdown(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_shutdown *shutdown = io_kiocb_to_cmd(req, struct io_shutdown);\n\tstruct socket *sock;\n\tint ret;\n\n\tWARN_ON_ONCE(issue_flags & IO_URING_F_NONBLOCK);\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tret = __sys_shutdown_sock(sock, shutdown->how);\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nstatic bool io_net_retry(struct socket *sock, int flags)\n{\n\tif (!(flags & MSG_WAITALL))\n\t\treturn false;\n\treturn sock->type == SOCK_STREAM || sock->type == SOCK_SEQPACKET;\n}\n\nstatic void io_netmsg_recycle(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_async_msghdr *hdr = req->async_data;\n\n\tif (!req_has_async_data(req) || issue_flags & IO_URING_F_UNLOCKED)\n\t\treturn;\n\n\t \n\tif (io_alloc_cache_put(&req->ctx->netmsg_cache, &hdr->cache)) {\n\t\treq->async_data = NULL;\n\t\treq->flags &= ~REQ_F_ASYNC_DATA;\n\t}\n}\n\nstatic struct io_async_msghdr *io_msg_alloc_async(struct io_kiocb *req,\n\t\t\t\t\t\t  unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_cache_entry *entry;\n\tstruct io_async_msghdr *hdr;\n\n\tif (!(issue_flags & IO_URING_F_UNLOCKED)) {\n\t\tentry = io_alloc_cache_get(&ctx->netmsg_cache);\n\t\tif (entry) {\n\t\t\thdr = container_of(entry, struct io_async_msghdr, cache);\n\t\t\thdr->free_iov = NULL;\n\t\t\treq->flags |= REQ_F_ASYNC_DATA;\n\t\t\treq->async_data = hdr;\n\t\t\treturn hdr;\n\t\t}\n\t}\n\n\tif (!io_alloc_async_data(req)) {\n\t\thdr = req->async_data;\n\t\thdr->free_iov = NULL;\n\t\treturn hdr;\n\t}\n\treturn NULL;\n}\n\nstatic inline struct io_async_msghdr *io_msg_alloc_async_prep(struct io_kiocb *req)\n{\n\t \n\treturn io_msg_alloc_async(req, 0);\n}\n\nstatic int io_setup_async_msg(struct io_kiocb *req,\n\t\t\t      struct io_async_msghdr *kmsg,\n\t\t\t      unsigned int issue_flags)\n{\n\tstruct io_async_msghdr *async_msg;\n\n\tif (req_has_async_data(req))\n\t\treturn -EAGAIN;\n\tasync_msg = io_msg_alloc_async(req, issue_flags);\n\tif (!async_msg) {\n\t\tkfree(kmsg->free_iov);\n\t\treturn -ENOMEM;\n\t}\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\tmemcpy(async_msg, kmsg, sizeof(*kmsg));\n\tif (async_msg->msg.msg_name)\n\t\tasync_msg->msg.msg_name = &async_msg->addr;\n\n\tif ((req->flags & REQ_F_BUFFER_SELECT) && !async_msg->msg.msg_iter.nr_segs)\n\t\treturn -EAGAIN;\n\n\t \n\tif (iter_is_iovec(&kmsg->msg.msg_iter) && !kmsg->free_iov) {\n\t\tsize_t fast_idx = iter_iov(&kmsg->msg.msg_iter) - kmsg->fast_iov;\n\t\tasync_msg->msg.msg_iter.__iov = &async_msg->fast_iov[fast_idx];\n\t}\n\n\treturn -EAGAIN;\n}\n\nstatic int io_sendmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t       struct io_async_msghdr *iomsg)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tint ret;\n\n\tiomsg->msg.msg_name = &iomsg->addr;\n\tiomsg->free_iov = iomsg->fast_iov;\n\tret = sendmsg_copy_msghdr(&iomsg->msg, sr->umsg, sr->msg_flags,\n\t\t\t\t\t&iomsg->free_iov);\n\t \n\tsr->msg_control = iomsg->msg.msg_control_user;\n\treturn ret;\n}\n\nint io_send_prep_async(struct io_kiocb *req)\n{\n\tstruct io_sr_msg *zc = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct io_async_msghdr *io;\n\tint ret;\n\n\tif (!zc->addr || req_has_async_data(req))\n\t\treturn 0;\n\tio = io_msg_alloc_async_prep(req);\n\tif (!io)\n\t\treturn -ENOMEM;\n\tret = move_addr_to_kernel(zc->addr, zc->addr_len, &io->addr);\n\treturn ret;\n}\n\nstatic int io_setup_async_addr(struct io_kiocb *req,\n\t\t\t      struct sockaddr_storage *addr_storage,\n\t\t\t      unsigned int issue_flags)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct io_async_msghdr *io;\n\n\tif (!sr->addr || req_has_async_data(req))\n\t\treturn -EAGAIN;\n\tio = io_msg_alloc_async(req, issue_flags);\n\tif (!io)\n\t\treturn -ENOMEM;\n\tmemcpy(&io->addr, addr_storage, sizeof(io->addr));\n\treturn -EAGAIN;\n}\n\nint io_sendmsg_prep_async(struct io_kiocb *req)\n{\n\tint ret;\n\n\tif (!io_msg_alloc_async_prep(req))\n\t\treturn -ENOMEM;\n\tret = io_sendmsg_copy_hdr(req, req->async_data);\n\tif (!ret)\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn ret;\n}\n\nvoid io_sendmsg_recvmsg_cleanup(struct io_kiocb *req)\n{\n\tstruct io_async_msghdr *io = req->async_data;\n\n\tkfree(io->free_iov);\n}\n\nint io_sendmsg_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\n\tif (req->opcode == IORING_OP_SEND) {\n\t\tif (READ_ONCE(sqe->__pad3[0]))\n\t\t\treturn -EINVAL;\n\t\tsr->addr = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\t\tsr->addr_len = READ_ONCE(sqe->addr_len);\n\t} else if (sqe->addr2 || sqe->file_index) {\n\t\treturn -EINVAL;\n\t}\n\n\tsr->umsg = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tsr->len = READ_ONCE(sqe->len);\n\tsr->flags = READ_ONCE(sqe->ioprio);\n\tif (sr->flags & ~IORING_RECVSEND_POLL_FIRST)\n\t\treturn -EINVAL;\n\tsr->msg_flags = READ_ONCE(sqe->msg_flags) | MSG_NOSIGNAL;\n\tif (sr->msg_flags & MSG_DONTWAIT)\n\t\treq->flags |= REQ_F_NOWAIT;\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\tsr->msg_flags |= MSG_CMSG_COMPAT;\n#endif\n\tsr->done_io = 0;\n\treturn 0;\n}\n\nint io_sendmsg(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct io_async_msghdr iomsg, *kmsg;\n\tstruct socket *sock;\n\tunsigned flags;\n\tint min_ret = 0;\n\tint ret;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tif (req_has_async_data(req)) {\n\t\tkmsg = req->async_data;\n\t\tkmsg->msg.msg_control_user = sr->msg_control;\n\t} else {\n\t\tret = io_sendmsg_copy_hdr(req, &iomsg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tkmsg = &iomsg;\n\t}\n\n\tif (!(req->flags & REQ_F_POLLED) &&\n\t    (sr->flags & IORING_RECVSEND_POLL_FIRST))\n\t\treturn io_setup_async_msg(req, kmsg, issue_flags);\n\n\tflags = sr->msg_flags;\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&kmsg->msg.msg_iter);\n\n\tret = __sys_sendmsg_sock(sock, &kmsg->msg, flags);\n\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && (issue_flags & IO_URING_F_NONBLOCK))\n\t\t\treturn io_setup_async_msg(req, kmsg, issue_flags);\n\t\tif (ret > 0 && io_net_retry(sock, flags)) {\n\t\t\tkmsg->msg.msg_controllen = 0;\n\t\t\tkmsg->msg.msg_control = NULL;\n\t\t\tsr->done_io += ret;\n\t\t\treq->flags |= REQ_F_PARTIAL_IO;\n\t\t\treturn io_setup_async_msg(req, kmsg, issue_flags);\n\t\t}\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t}\n\t \n\tif (kmsg->free_iov)\n\t\tkfree(kmsg->free_iov);\n\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\tio_netmsg_recycle(req, issue_flags);\n\tif (ret >= 0)\n\t\tret += sr->done_io;\n\telse if (sr->done_io)\n\t\tret = sr->done_io;\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nint io_send(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct sockaddr_storage __address;\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct msghdr msg;\n\tstruct socket *sock;\n\tunsigned flags;\n\tint min_ret = 0;\n\tint ret;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_ubuf = NULL;\n\n\tif (sr->addr) {\n\t\tif (req_has_async_data(req)) {\n\t\t\tstruct io_async_msghdr *io = req->async_data;\n\n\t\t\tmsg.msg_name = &io->addr;\n\t\t} else {\n\t\t\tret = move_addr_to_kernel(sr->addr, sr->addr_len, &__address);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\treturn ret;\n\t\t\tmsg.msg_name = (struct sockaddr *)&__address;\n\t\t}\n\t\tmsg.msg_namelen = sr->addr_len;\n\t}\n\n\tif (!(req->flags & REQ_F_POLLED) &&\n\t    (sr->flags & IORING_RECVSEND_POLL_FIRST))\n\t\treturn io_setup_async_addr(req, &__address, issue_flags);\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tret = import_ubuf(ITER_SOURCE, sr->buf, sr->len, &msg.msg_iter);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tflags = sr->msg_flags;\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&msg.msg_iter);\n\n\tflags &= ~MSG_INTERNAL_SENDMSG_FLAGS;\n\tmsg.msg_flags = flags;\n\tret = sock_sendmsg(sock, &msg);\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && (issue_flags & IO_URING_F_NONBLOCK))\n\t\t\treturn io_setup_async_addr(req, &__address, issue_flags);\n\n\t\tif (ret > 0 && io_net_retry(sock, flags)) {\n\t\t\tsr->len -= ret;\n\t\t\tsr->buf += ret;\n\t\t\tsr->done_io += ret;\n\t\t\treq->flags |= REQ_F_PARTIAL_IO;\n\t\t\treturn io_setup_async_addr(req, &__address, issue_flags);\n\t\t}\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t}\n\tif (ret >= 0)\n\t\tret += sr->done_io;\n\telse if (sr->done_io)\n\t\tret = sr->done_io;\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nstatic bool io_recvmsg_multishot_overflow(struct io_async_msghdr *iomsg)\n{\n\tint hdr;\n\n\tif (iomsg->namelen < 0)\n\t\treturn true;\n\tif (check_add_overflow((int)sizeof(struct io_uring_recvmsg_out),\n\t\t\t       iomsg->namelen, &hdr))\n\t\treturn true;\n\tif (check_add_overflow(hdr, (int)iomsg->controllen, &hdr))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int __io_recvmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t\t struct io_async_msghdr *iomsg)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct user_msghdr msg;\n\tint ret;\n\n\tif (copy_from_user(&msg, sr->umsg, sizeof(*sr->umsg)))\n\t\treturn -EFAULT;\n\n\tret = __copy_msghdr(&iomsg->msg, &msg, &iomsg->uaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tif (msg.msg_iovlen == 0) {\n\t\t\tsr->len = iomsg->fast_iov[0].iov_len = 0;\n\t\t\tiomsg->fast_iov[0].iov_base = NULL;\n\t\t\tiomsg->free_iov = NULL;\n\t\t} else if (msg.msg_iovlen > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (copy_from_user(iomsg->fast_iov, msg.msg_iov, sizeof(*msg.msg_iov)))\n\t\t\t\treturn -EFAULT;\n\t\t\tsr->len = iomsg->fast_iov[0].iov_len;\n\t\t\tiomsg->free_iov = NULL;\n\t\t}\n\n\t\tif (req->flags & REQ_F_APOLL_MULTISHOT) {\n\t\t\tiomsg->namelen = msg.msg_namelen;\n\t\t\tiomsg->controllen = msg.msg_controllen;\n\t\t\tif (io_recvmsg_multishot_overflow(iomsg))\n\t\t\t\treturn -EOVERFLOW;\n\t\t}\n\t} else {\n\t\tiomsg->free_iov = iomsg->fast_iov;\n\t\tret = __import_iovec(ITER_DEST, msg.msg_iov, msg.msg_iovlen, UIO_FASTIOV,\n\t\t\t\t     &iomsg->free_iov, &iomsg->msg.msg_iter,\n\t\t\t\t     false);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int __io_compat_recvmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t\t\tstruct io_async_msghdr *iomsg)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct compat_msghdr msg;\n\tstruct compat_iovec __user *uiov;\n\tint ret;\n\n\tif (copy_from_user(&msg, sr->umsg_compat, sizeof(msg)))\n\t\treturn -EFAULT;\n\n\tret = __get_compat_msghdr(&iomsg->msg, &msg, &iomsg->uaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tuiov = compat_ptr(msg.msg_iov);\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tcompat_ssize_t clen;\n\n\t\tiomsg->free_iov = NULL;\n\t\tif (msg.msg_iovlen == 0) {\n\t\t\tsr->len = 0;\n\t\t} else if (msg.msg_iovlen > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (!access_ok(uiov, sizeof(*uiov)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (__get_user(clen, &uiov->iov_len))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (clen < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tsr->len = clen;\n\t\t}\n\n\t\tif (req->flags & REQ_F_APOLL_MULTISHOT) {\n\t\t\tiomsg->namelen = msg.msg_namelen;\n\t\t\tiomsg->controllen = msg.msg_controllen;\n\t\t\tif (io_recvmsg_multishot_overflow(iomsg))\n\t\t\t\treturn -EOVERFLOW;\n\t\t}\n\t} else {\n\t\tiomsg->free_iov = iomsg->fast_iov;\n\t\tret = __import_iovec(ITER_DEST, (struct iovec __user *)uiov, msg.msg_iovlen,\n\t\t\t\t   UIO_FASTIOV, &iomsg->free_iov,\n\t\t\t\t   &iomsg->msg.msg_iter, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int io_recvmsg_copy_hdr(struct io_kiocb *req,\n\t\t\t       struct io_async_msghdr *iomsg)\n{\n\tiomsg->msg.msg_name = &iomsg->addr;\n\tiomsg->msg.msg_iter.nr_segs = 0;\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\treturn __io_compat_recvmsg_copy_hdr(req, iomsg);\n#endif\n\n\treturn __io_recvmsg_copy_hdr(req, iomsg);\n}\n\nint io_recvmsg_prep_async(struct io_kiocb *req)\n{\n\tint ret;\n\n\tif (!io_msg_alloc_async_prep(req))\n\t\treturn -ENOMEM;\n\tret = io_recvmsg_copy_hdr(req, req->async_data);\n\tif (!ret)\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn ret;\n}\n\n#define RECVMSG_FLAGS (IORING_RECVSEND_POLL_FIRST | IORING_RECV_MULTISHOT)\n\nint io_recvmsg_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\n\tif (unlikely(sqe->file_index || sqe->addr2))\n\t\treturn -EINVAL;\n\n\tsr->umsg = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tsr->len = READ_ONCE(sqe->len);\n\tsr->flags = READ_ONCE(sqe->ioprio);\n\tif (sr->flags & ~(RECVMSG_FLAGS))\n\t\treturn -EINVAL;\n\tsr->msg_flags = READ_ONCE(sqe->msg_flags);\n\tif (sr->msg_flags & MSG_DONTWAIT)\n\t\treq->flags |= REQ_F_NOWAIT;\n\tif (sr->msg_flags & MSG_ERRQUEUE)\n\t\treq->flags |= REQ_F_CLEAR_POLLIN;\n\tif (sr->flags & IORING_RECV_MULTISHOT) {\n\t\tif (!(req->flags & REQ_F_BUFFER_SELECT))\n\t\t\treturn -EINVAL;\n\t\tif (sr->msg_flags & MSG_WAITALL)\n\t\t\treturn -EINVAL;\n\t\tif (req->opcode == IORING_OP_RECV && sr->len)\n\t\t\treturn -EINVAL;\n\t\treq->flags |= REQ_F_APOLL_MULTISHOT;\n\t\t \n\t\tsr->buf_group = req->buf_index;\n\t}\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\tsr->msg_flags |= MSG_CMSG_COMPAT;\n#endif\n\tsr->done_io = 0;\n\treturn 0;\n}\n\nstatic inline void io_recv_prep_retry(struct io_kiocb *req)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\n\tsr->done_io = 0;\n\tsr->len = 0;  \n\treq->buf_index = sr->buf_group;\n}\n\n \nstatic inline bool io_recv_finish(struct io_kiocb *req, int *ret,\n\t\t\t\t  struct msghdr *msg, bool mshot_finished,\n\t\t\t\t  unsigned issue_flags)\n{\n\tunsigned int cflags;\n\n\tcflags = io_put_kbuf(req, issue_flags);\n\tif (msg->msg_inq && msg->msg_inq != -1)\n\t\tcflags |= IORING_CQE_F_SOCK_NONEMPTY;\n\n\tif (!(req->flags & REQ_F_APOLL_MULTISHOT)) {\n\t\tio_req_set_res(req, *ret, cflags);\n\t\t*ret = IOU_OK;\n\t\treturn true;\n\t}\n\n\tif (!mshot_finished) {\n\t\tif (io_fill_cqe_req_aux(req, issue_flags & IO_URING_F_COMPLETE_DEFER,\n\t\t\t\t\t*ret, cflags | IORING_CQE_F_MORE)) {\n\t\t\tio_recv_prep_retry(req);\n\t\t\t \n\t\t\tif (cflags & IORING_CQE_F_SOCK_NONEMPTY ||\n\t\t\t    msg->msg_inq == -1)\n\t\t\t\treturn false;\n\t\t\tif (issue_flags & IO_URING_F_MULTISHOT)\n\t\t\t\t*ret = IOU_ISSUE_SKIP_COMPLETE;\n\t\t\telse\n\t\t\t\t*ret = -EAGAIN;\n\t\t\treturn true;\n\t\t}\n\t\t \n\t}\n\n\tio_req_set_res(req, *ret, cflags);\n\n\tif (issue_flags & IO_URING_F_MULTISHOT)\n\t\t*ret = IOU_STOP_MULTISHOT;\n\telse\n\t\t*ret = IOU_OK;\n\treturn true;\n}\n\nstatic int io_recvmsg_prep_multishot(struct io_async_msghdr *kmsg,\n\t\t\t\t     struct io_sr_msg *sr, void __user **buf,\n\t\t\t\t     size_t *len)\n{\n\tunsigned long ubuf = (unsigned long) *buf;\n\tunsigned long hdr;\n\n\thdr = sizeof(struct io_uring_recvmsg_out) + kmsg->namelen +\n\t\tkmsg->controllen;\n\tif (*len < hdr)\n\t\treturn -EFAULT;\n\n\tif (kmsg->controllen) {\n\t\tunsigned long control = ubuf + hdr - kmsg->controllen;\n\n\t\tkmsg->msg.msg_control_user = (void __user *) control;\n\t\tkmsg->msg.msg_controllen = kmsg->controllen;\n\t}\n\n\tsr->buf = *buf;  \n\t*buf = (void __user *) (ubuf + hdr);\n\tkmsg->payloadlen = *len = *len - hdr;\n\treturn 0;\n}\n\nstruct io_recvmsg_multishot_hdr {\n\tstruct io_uring_recvmsg_out msg;\n\tstruct sockaddr_storage addr;\n};\n\nstatic int io_recvmsg_multishot(struct socket *sock, struct io_sr_msg *io,\n\t\t\t\tstruct io_async_msghdr *kmsg,\n\t\t\t\tunsigned int flags, bool *finished)\n{\n\tint err;\n\tint copy_len;\n\tstruct io_recvmsg_multishot_hdr hdr;\n\n\tif (kmsg->namelen)\n\t\tkmsg->msg.msg_name = &hdr.addr;\n\tkmsg->msg.msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n\tkmsg->msg.msg_namelen = 0;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\n\terr = sock_recvmsg(sock, &kmsg->msg, flags);\n\t*finished = err <= 0;\n\tif (err < 0)\n\t\treturn err;\n\n\thdr.msg = (struct io_uring_recvmsg_out) {\n\t\t.controllen = kmsg->controllen - kmsg->msg.msg_controllen,\n\t\t.flags = kmsg->msg.msg_flags & ~MSG_CMSG_COMPAT\n\t};\n\n\thdr.msg.payloadlen = err;\n\tif (err > kmsg->payloadlen)\n\t\terr = kmsg->payloadlen;\n\n\tcopy_len = sizeof(struct io_uring_recvmsg_out);\n\tif (kmsg->msg.msg_namelen > kmsg->namelen)\n\t\tcopy_len += kmsg->namelen;\n\telse\n\t\tcopy_len += kmsg->msg.msg_namelen;\n\n\t \n\thdr.msg.namelen = kmsg->msg.msg_namelen;\n\n\t \n\tBUILD_BUG_ON(offsetof(struct io_recvmsg_multishot_hdr, addr) !=\n\t\t     sizeof(struct io_uring_recvmsg_out));\n\tif (copy_to_user(io->buf, &hdr, copy_len)) {\n\t\t*finished = true;\n\t\treturn -EFAULT;\n\t}\n\n\treturn sizeof(struct io_uring_recvmsg_out) + kmsg->namelen +\n\t\t\tkmsg->controllen + err;\n}\n\nint io_recvmsg(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct io_async_msghdr iomsg, *kmsg;\n\tstruct socket *sock;\n\tunsigned flags;\n\tint ret, min_ret = 0;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tbool mshot_finished = true;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tif (req_has_async_data(req)) {\n\t\tkmsg = req->async_data;\n\t} else {\n\t\tret = io_recvmsg_copy_hdr(req, &iomsg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tkmsg = &iomsg;\n\t}\n\n\tif (!(req->flags & REQ_F_POLLED) &&\n\t    (sr->flags & IORING_RECVSEND_POLL_FIRST))\n\t\treturn io_setup_async_msg(req, kmsg, issue_flags);\n\n\tif (!io_check_multishot(req, issue_flags))\n\t\treturn io_setup_async_msg(req, kmsg, issue_flags);\n\nretry_multishot:\n\tif (io_do_buffer_select(req)) {\n\t\tvoid __user *buf;\n\t\tsize_t len = sr->len;\n\n\t\tbuf = io_buffer_select(req, &len, issue_flags);\n\t\tif (!buf)\n\t\t\treturn -ENOBUFS;\n\n\t\tif (req->flags & REQ_F_APOLL_MULTISHOT) {\n\t\t\tret = io_recvmsg_prep_multishot(kmsg, sr, &buf, &len);\n\t\t\tif (ret) {\n\t\t\t\tio_kbuf_recycle(req, issue_flags);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tiov_iter_ubuf(&kmsg->msg.msg_iter, ITER_DEST, buf, len);\n\t}\n\n\tflags = sr->msg_flags;\n\tif (force_nonblock)\n\t\tflags |= MSG_DONTWAIT;\n\n\tkmsg->msg.msg_get_inq = 1;\n\tkmsg->msg.msg_inq = -1;\n\tif (req->flags & REQ_F_APOLL_MULTISHOT) {\n\t\tret = io_recvmsg_multishot(sock, sr, kmsg, flags,\n\t\t\t\t\t   &mshot_finished);\n\t} else {\n\t\t \n\t\tif (flags & MSG_WAITALL && !kmsg->msg.msg_controllen)\n\t\t\tmin_ret = iov_iter_count(&kmsg->msg.msg_iter);\n\n\t\tret = __sys_recvmsg_sock(sock, &kmsg->msg, sr->umsg,\n\t\t\t\t\t kmsg->uaddr, flags);\n\t}\n\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && force_nonblock) {\n\t\t\tret = io_setup_async_msg(req, kmsg, issue_flags);\n\t\t\tif (ret == -EAGAIN && (issue_flags & IO_URING_F_MULTISHOT)) {\n\t\t\t\tio_kbuf_recycle(req, issue_flags);\n\t\t\t\treturn IOU_ISSUE_SKIP_COMPLETE;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tif (ret > 0 && io_net_retry(sock, flags)) {\n\t\t\tsr->done_io += ret;\n\t\t\treq->flags |= REQ_F_PARTIAL_IO;\n\t\t\treturn io_setup_async_msg(req, kmsg, issue_flags);\n\t\t}\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t} else if ((flags & MSG_WAITALL) && (kmsg->msg.msg_flags & (MSG_TRUNC | MSG_CTRUNC))) {\n\t\treq_set_fail(req);\n\t}\n\n\tif (ret > 0)\n\t\tret += sr->done_io;\n\telse if (sr->done_io)\n\t\tret = sr->done_io;\n\telse\n\t\tio_kbuf_recycle(req, issue_flags);\n\n\tif (!io_recv_finish(req, &ret, &kmsg->msg, mshot_finished, issue_flags))\n\t\tgoto retry_multishot;\n\n\tif (mshot_finished) {\n\t\t \n\t\tif (kmsg->free_iov)\n\t\t\tkfree(kmsg->free_iov);\n\t\tio_netmsg_recycle(req, issue_flags);\n\t\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\t}\n\n\treturn ret;\n}\n\nint io_recv(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct msghdr msg;\n\tstruct socket *sock;\n\tunsigned flags;\n\tint ret, min_ret = 0;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tsize_t len = sr->len;\n\n\tif (!(req->flags & REQ_F_POLLED) &&\n\t    (sr->flags & IORING_RECVSEND_POLL_FIRST))\n\t\treturn -EAGAIN;\n\n\tif (!io_check_multishot(req, issue_flags))\n\t\treturn -EAGAIN;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = NULL;\n\tmsg.msg_get_inq = 1;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_iocb = NULL;\n\tmsg.msg_ubuf = NULL;\n\nretry_multishot:\n\tif (io_do_buffer_select(req)) {\n\t\tvoid __user *buf;\n\n\t\tbuf = io_buffer_select(req, &len, issue_flags);\n\t\tif (!buf)\n\t\t\treturn -ENOBUFS;\n\t\tsr->buf = buf;\n\t}\n\n\tret = import_ubuf(ITER_DEST, sr->buf, len, &msg.msg_iter);\n\tif (unlikely(ret))\n\t\tgoto out_free;\n\n\tmsg.msg_inq = -1;\n\tmsg.msg_flags = 0;\n\n\tflags = sr->msg_flags;\n\tif (force_nonblock)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&msg.msg_iter);\n\n\tret = sock_recvmsg(sock, &msg, flags);\n\tif (ret < min_ret) {\n\t\tif (ret == -EAGAIN && force_nonblock) {\n\t\t\tif (issue_flags & IO_URING_F_MULTISHOT) {\n\t\t\t\tio_kbuf_recycle(req, issue_flags);\n\t\t\t\treturn IOU_ISSUE_SKIP_COMPLETE;\n\t\t\t}\n\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tif (ret > 0 && io_net_retry(sock, flags)) {\n\t\t\tsr->len -= ret;\n\t\t\tsr->buf += ret;\n\t\t\tsr->done_io += ret;\n\t\t\treq->flags |= REQ_F_PARTIAL_IO;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t} else if ((flags & MSG_WAITALL) && (msg.msg_flags & (MSG_TRUNC | MSG_CTRUNC))) {\nout_free:\n\t\treq_set_fail(req);\n\t}\n\n\tif (ret > 0)\n\t\tret += sr->done_io;\n\telse if (sr->done_io)\n\t\tret = sr->done_io;\n\telse\n\t\tio_kbuf_recycle(req, issue_flags);\n\n\tif (!io_recv_finish(req, &ret, &msg, ret <= 0, issue_flags))\n\t\tgoto retry_multishot;\n\n\treturn ret;\n}\n\nvoid io_send_zc_cleanup(struct io_kiocb *req)\n{\n\tstruct io_sr_msg *zc = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct io_async_msghdr *io;\n\n\tif (req_has_async_data(req)) {\n\t\tio = req->async_data;\n\t\t \n\t\tif (io->free_iov != io->fast_iov)\n\t\t\tkfree(io->free_iov);\n\t}\n\tif (zc->notif) {\n\t\tio_notif_flush(zc->notif);\n\t\tzc->notif = NULL;\n\t}\n}\n\n#define IO_ZC_FLAGS_COMMON (IORING_RECVSEND_POLL_FIRST | IORING_RECVSEND_FIXED_BUF)\n#define IO_ZC_FLAGS_VALID  (IO_ZC_FLAGS_COMMON | IORING_SEND_ZC_REPORT_USAGE)\n\nint io_send_zc_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_sr_msg *zc = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_kiocb *notif;\n\n\tif (unlikely(READ_ONCE(sqe->__pad2[0]) || READ_ONCE(sqe->addr3)))\n\t\treturn -EINVAL;\n\t \n\tif (req->flags & REQ_F_CQE_SKIP)\n\t\treturn -EINVAL;\n\n\tnotif = zc->notif = io_alloc_notif(ctx);\n\tif (!notif)\n\t\treturn -ENOMEM;\n\tnotif->cqe.user_data = req->cqe.user_data;\n\tnotif->cqe.res = 0;\n\tnotif->cqe.flags = IORING_CQE_F_NOTIF;\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\n\tzc->flags = READ_ONCE(sqe->ioprio);\n\tif (unlikely(zc->flags & ~IO_ZC_FLAGS_COMMON)) {\n\t\tif (zc->flags & ~IO_ZC_FLAGS_VALID)\n\t\t\treturn -EINVAL;\n\t\tif (zc->flags & IORING_SEND_ZC_REPORT_USAGE) {\n\t\t\tio_notif_set_extended(notif);\n\t\t\tio_notif_to_data(notif)->zc_report = true;\n\t\t}\n\t}\n\n\tif (zc->flags & IORING_RECVSEND_FIXED_BUF) {\n\t\tunsigned idx = READ_ONCE(sqe->buf_index);\n\n\t\tif (unlikely(idx >= ctx->nr_user_bufs))\n\t\t\treturn -EFAULT;\n\t\tidx = array_index_nospec(idx, ctx->nr_user_bufs);\n\t\treq->imu = READ_ONCE(ctx->user_bufs[idx]);\n\t\tio_req_set_rsrc_node(notif, ctx, 0);\n\t}\n\n\tif (req->opcode == IORING_OP_SEND_ZC) {\n\t\tif (READ_ONCE(sqe->__pad3[0]))\n\t\t\treturn -EINVAL;\n\t\tzc->addr = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\t\tzc->addr_len = READ_ONCE(sqe->addr_len);\n\t} else {\n\t\tif (unlikely(sqe->addr2 || sqe->file_index))\n\t\t\treturn -EINVAL;\n\t\tif (unlikely(zc->flags & IORING_RECVSEND_FIXED_BUF))\n\t\t\treturn -EINVAL;\n\t}\n\n\tzc->buf = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tzc->len = READ_ONCE(sqe->len);\n\tzc->msg_flags = READ_ONCE(sqe->msg_flags) | MSG_NOSIGNAL;\n\tif (zc->msg_flags & MSG_DONTWAIT)\n\t\treq->flags |= REQ_F_NOWAIT;\n\n\tzc->done_io = 0;\n\n#ifdef CONFIG_COMPAT\n\tif (req->ctx->compat)\n\t\tzc->msg_flags |= MSG_CMSG_COMPAT;\n#endif\n\treturn 0;\n}\n\nstatic int io_sg_from_iter_iovec(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t struct iov_iter *from, size_t length)\n{\n\tskb_zcopy_downgrade_managed(skb);\n\treturn __zerocopy_sg_from_iter(NULL, sk, skb, from, length);\n}\n\nstatic int io_sg_from_iter(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct iov_iter *from, size_t length)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint frag = shinfo->nr_frags;\n\tint ret = 0;\n\tstruct bvec_iter bi;\n\tssize_t copied = 0;\n\tunsigned long truesize = 0;\n\n\tif (!frag)\n\t\tshinfo->flags |= SKBFL_MANAGED_FRAG_REFS;\n\telse if (unlikely(!skb_zcopy_managed(skb)))\n\t\treturn __zerocopy_sg_from_iter(NULL, sk, skb, from, length);\n\n\tbi.bi_size = min(from->count, length);\n\tbi.bi_bvec_done = from->iov_offset;\n\tbi.bi_idx = 0;\n\n\twhile (bi.bi_size && frag < MAX_SKB_FRAGS) {\n\t\tstruct bio_vec v = mp_bvec_iter_bvec(from->bvec, bi);\n\n\t\tcopied += v.bv_len;\n\t\ttruesize += PAGE_ALIGN(v.bv_len + v.bv_offset);\n\t\t__skb_fill_page_desc_noacc(shinfo, frag++, v.bv_page,\n\t\t\t\t\t   v.bv_offset, v.bv_len);\n\t\tbvec_iter_advance_single(from->bvec, &bi, v.bv_len);\n\t}\n\tif (bi.bi_size)\n\t\tret = -EMSGSIZE;\n\n\tshinfo->nr_frags = frag;\n\tfrom->bvec += bi.bi_idx;\n\tfrom->nr_segs -= bi.bi_idx;\n\tfrom->count -= copied;\n\tfrom->iov_offset = bi.bi_bvec_done;\n\n\tskb->data_len += copied;\n\tskb->len += copied;\n\tskb->truesize += truesize;\n\n\tif (sk && sk->sk_type == SOCK_STREAM) {\n\t\tsk_wmem_queued_add(sk, truesize);\n\t\tif (!skb_zcopy_pure(skb))\n\t\t\tsk_mem_charge(sk, truesize);\n\t} else {\n\t\trefcount_add(truesize, &skb->sk->sk_wmem_alloc);\n\t}\n\treturn ret;\n}\n\nint io_send_zc(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct sockaddr_storage __address;\n\tstruct io_sr_msg *zc = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct msghdr msg;\n\tstruct socket *sock;\n\tunsigned msg_flags;\n\tint ret, min_ret = 0;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\tif (!test_bit(SOCK_SUPPORT_ZC, &sock->flags))\n\t\treturn -EOPNOTSUPP;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\n\tif (zc->addr) {\n\t\tif (req_has_async_data(req)) {\n\t\t\tstruct io_async_msghdr *io = req->async_data;\n\n\t\t\tmsg.msg_name = &io->addr;\n\t\t} else {\n\t\t\tret = move_addr_to_kernel(zc->addr, zc->addr_len, &__address);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\treturn ret;\n\t\t\tmsg.msg_name = (struct sockaddr *)&__address;\n\t\t}\n\t\tmsg.msg_namelen = zc->addr_len;\n\t}\n\n\tif (!(req->flags & REQ_F_POLLED) &&\n\t    (zc->flags & IORING_RECVSEND_POLL_FIRST))\n\t\treturn io_setup_async_addr(req, &__address, issue_flags);\n\n\tif (zc->flags & IORING_RECVSEND_FIXED_BUF) {\n\t\tret = io_import_fixed(ITER_SOURCE, &msg.msg_iter, req->imu,\n\t\t\t\t\t(u64)(uintptr_t)zc->buf, zc->len);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tmsg.sg_from_iter = io_sg_from_iter;\n\t} else {\n\t\tio_notif_set_extended(zc->notif);\n\t\tret = import_ubuf(ITER_SOURCE, zc->buf, zc->len, &msg.msg_iter);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = io_notif_account_mem(zc->notif, zc->len);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tmsg.sg_from_iter = io_sg_from_iter_iovec;\n\t}\n\n\tmsg_flags = zc->msg_flags | MSG_ZEROCOPY;\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\tmsg_flags |= MSG_DONTWAIT;\n\tif (msg_flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&msg.msg_iter);\n\tmsg_flags &= ~MSG_INTERNAL_SENDMSG_FLAGS;\n\n\tmsg.msg_flags = msg_flags;\n\tmsg.msg_ubuf = &io_notif_to_data(zc->notif)->uarg;\n\tret = sock_sendmsg(sock, &msg);\n\n\tif (unlikely(ret < min_ret)) {\n\t\tif (ret == -EAGAIN && (issue_flags & IO_URING_F_NONBLOCK))\n\t\t\treturn io_setup_async_addr(req, &__address, issue_flags);\n\n\t\tif (ret > 0 && io_net_retry(sock, msg.msg_flags)) {\n\t\t\tzc->len -= ret;\n\t\t\tzc->buf += ret;\n\t\t\tzc->done_io += ret;\n\t\t\treq->flags |= REQ_F_PARTIAL_IO;\n\t\t\treturn io_setup_async_addr(req, &__address, issue_flags);\n\t\t}\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t}\n\n\tif (ret >= 0)\n\t\tret += zc->done_io;\n\telse if (zc->done_io)\n\t\tret = zc->done_io;\n\n\t \n\tif (!(issue_flags & IO_URING_F_UNLOCKED)) {\n\t\tio_notif_flush(zc->notif);\n\t\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\t}\n\tio_req_set_res(req, ret, IORING_CQE_F_MORE);\n\treturn IOU_OK;\n}\n\nint io_sendmsg_zc(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\tstruct io_async_msghdr iomsg, *kmsg;\n\tstruct socket *sock;\n\tunsigned flags;\n\tint ret, min_ret = 0;\n\n\tio_notif_set_extended(sr->notif);\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\tif (!test_bit(SOCK_SUPPORT_ZC, &sock->flags))\n\t\treturn -EOPNOTSUPP;\n\n\tif (req_has_async_data(req)) {\n\t\tkmsg = req->async_data;\n\t} else {\n\t\tret = io_sendmsg_copy_hdr(req, &iomsg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tkmsg = &iomsg;\n\t}\n\n\tif (!(req->flags & REQ_F_POLLED) &&\n\t    (sr->flags & IORING_RECVSEND_POLL_FIRST))\n\t\treturn io_setup_async_msg(req, kmsg, issue_flags);\n\n\tflags = sr->msg_flags | MSG_ZEROCOPY;\n\tif (issue_flags & IO_URING_F_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&kmsg->msg.msg_iter);\n\n\tkmsg->msg.msg_ubuf = &io_notif_to_data(sr->notif)->uarg;\n\tkmsg->msg.sg_from_iter = io_sg_from_iter_iovec;\n\tret = __sys_sendmsg_sock(sock, &kmsg->msg, flags);\n\n\tif (unlikely(ret < min_ret)) {\n\t\tif (ret == -EAGAIN && (issue_flags & IO_URING_F_NONBLOCK))\n\t\t\treturn io_setup_async_msg(req, kmsg, issue_flags);\n\n\t\tif (ret > 0 && io_net_retry(sock, flags)) {\n\t\t\tsr->done_io += ret;\n\t\t\treq->flags |= REQ_F_PARTIAL_IO;\n\t\t\treturn io_setup_async_msg(req, kmsg, issue_flags);\n\t\t}\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t}\n\t \n\tif (kmsg->free_iov) {\n\t\tkfree(kmsg->free_iov);\n\t\tkmsg->free_iov = NULL;\n\t}\n\n\tio_netmsg_recycle(req, issue_flags);\n\tif (ret >= 0)\n\t\tret += sr->done_io;\n\telse if (sr->done_io)\n\t\tret = sr->done_io;\n\n\t \n\tif (!(issue_flags & IO_URING_F_UNLOCKED)) {\n\t\tio_notif_flush(sr->notif);\n\t\treq->flags &= ~REQ_F_NEED_CLEANUP;\n\t}\n\tio_req_set_res(req, ret, IORING_CQE_F_MORE);\n\treturn IOU_OK;\n}\n\nvoid io_sendrecv_fail(struct io_kiocb *req)\n{\n\tstruct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);\n\n\tif (req->flags & REQ_F_PARTIAL_IO)\n\t\treq->cqe.res = sr->done_io;\n\n\tif ((req->flags & REQ_F_NEED_CLEANUP) &&\n\t    (req->opcode == IORING_OP_SEND_ZC || req->opcode == IORING_OP_SENDMSG_ZC))\n\t\treq->cqe.flags |= IORING_CQE_F_MORE;\n}\n\nint io_accept_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_accept *accept = io_kiocb_to_cmd(req, struct io_accept);\n\tunsigned flags;\n\n\tif (sqe->len || sqe->buf_index)\n\t\treturn -EINVAL;\n\n\taccept->addr = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\taccept->addr_len = u64_to_user_ptr(READ_ONCE(sqe->addr2));\n\taccept->flags = READ_ONCE(sqe->accept_flags);\n\taccept->nofile = rlimit(RLIMIT_NOFILE);\n\tflags = READ_ONCE(sqe->ioprio);\n\tif (flags & ~IORING_ACCEPT_MULTISHOT)\n\t\treturn -EINVAL;\n\n\taccept->file_slot = READ_ONCE(sqe->file_index);\n\tif (accept->file_slot) {\n\t\tif (accept->flags & SOCK_CLOEXEC)\n\t\t\treturn -EINVAL;\n\t\tif (flags & IORING_ACCEPT_MULTISHOT &&\n\t\t    accept->file_slot != IORING_FILE_INDEX_ALLOC)\n\t\t\treturn -EINVAL;\n\t}\n\tif (accept->flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (accept->flags & SOCK_NONBLOCK))\n\t\taccept->flags = (accept->flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\tif (flags & IORING_ACCEPT_MULTISHOT)\n\t\treq->flags |= REQ_F_APOLL_MULTISHOT;\n\treturn 0;\n}\n\nint io_accept(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_accept *accept = io_kiocb_to_cmd(req, struct io_accept);\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tunsigned int file_flags = force_nonblock ? O_NONBLOCK : 0;\n\tbool fixed = !!accept->file_slot;\n\tstruct file *file;\n\tint ret, fd;\n\n\tif (!io_check_multishot(req, issue_flags))\n\t\treturn -EAGAIN;\nretry:\n\tif (!fixed) {\n\t\tfd = __get_unused_fd_flags(accept->flags, accept->nofile);\n\t\tif (unlikely(fd < 0))\n\t\t\treturn fd;\n\t}\n\tfile = do_accept(req->file, file_flags, accept->addr, accept->addr_len,\n\t\t\t accept->flags);\n\tif (IS_ERR(file)) {\n\t\tif (!fixed)\n\t\t\tput_unused_fd(fd);\n\t\tret = PTR_ERR(file);\n\t\tif (ret == -EAGAIN && force_nonblock) {\n\t\t\t \n\t\t\tif (issue_flags & IO_URING_F_MULTISHOT)\n\t\t\t\tret = IOU_ISSUE_SKIP_COMPLETE;\n\t\t\treturn ret;\n\t\t}\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t} else if (!fixed) {\n\t\tfd_install(fd, file);\n\t\tret = fd;\n\t} else {\n\t\tret = io_fixed_fd_install(req, issue_flags, file,\n\t\t\t\t\t\taccept->file_slot);\n\t}\n\n\tif (!(req->flags & REQ_F_APOLL_MULTISHOT)) {\n\t\tio_req_set_res(req, ret, 0);\n\t\treturn IOU_OK;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\tif (io_fill_cqe_req_aux(req, issue_flags & IO_URING_F_COMPLETE_DEFER,\n\t\t\t\tret, IORING_CQE_F_MORE))\n\t\tgoto retry;\n\n\treturn -ECANCELED;\n}\n\nint io_socket_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_socket *sock = io_kiocb_to_cmd(req, struct io_socket);\n\n\tif (sqe->addr || sqe->rw_flags || sqe->buf_index)\n\t\treturn -EINVAL;\n\n\tsock->domain = READ_ONCE(sqe->fd);\n\tsock->type = READ_ONCE(sqe->off);\n\tsock->protocol = READ_ONCE(sqe->len);\n\tsock->file_slot = READ_ONCE(sqe->file_index);\n\tsock->nofile = rlimit(RLIMIT_NOFILE);\n\n\tsock->flags = sock->type & ~SOCK_TYPE_MASK;\n\tif (sock->file_slot && (sock->flags & SOCK_CLOEXEC))\n\t\treturn -EINVAL;\n\tif (sock->flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint io_socket(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_socket *sock = io_kiocb_to_cmd(req, struct io_socket);\n\tbool fixed = !!sock->file_slot;\n\tstruct file *file;\n\tint ret, fd;\n\n\tif (!fixed) {\n\t\tfd = __get_unused_fd_flags(sock->flags, sock->nofile);\n\t\tif (unlikely(fd < 0))\n\t\t\treturn fd;\n\t}\n\tfile = __sys_socket_file(sock->domain, sock->type, sock->protocol);\n\tif (IS_ERR(file)) {\n\t\tif (!fixed)\n\t\t\tput_unused_fd(fd);\n\t\tret = PTR_ERR(file);\n\t\tif (ret == -EAGAIN && (issue_flags & IO_URING_F_NONBLOCK))\n\t\t\treturn -EAGAIN;\n\t\tif (ret == -ERESTARTSYS)\n\t\t\tret = -EINTR;\n\t\treq_set_fail(req);\n\t} else if (!fixed) {\n\t\tfd_install(fd, file);\n\t\tret = fd;\n\t} else {\n\t\tret = io_fixed_fd_install(req, issue_flags, file,\n\t\t\t\t\t    sock->file_slot);\n\t}\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nint io_connect_prep_async(struct io_kiocb *req)\n{\n\tstruct io_async_connect *io = req->async_data;\n\tstruct io_connect *conn = io_kiocb_to_cmd(req, struct io_connect);\n\n\treturn move_addr_to_kernel(conn->addr, conn->addr_len, &io->address);\n}\n\nint io_connect_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_connect *conn = io_kiocb_to_cmd(req, struct io_connect);\n\n\tif (sqe->len || sqe->buf_index || sqe->rw_flags || sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\n\tconn->addr = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\tconn->addr_len =  READ_ONCE(sqe->addr2);\n\tconn->in_progress = conn->seen_econnaborted = false;\n\treturn 0;\n}\n\nint io_connect(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_connect *connect = io_kiocb_to_cmd(req, struct io_connect);\n\tstruct io_async_connect __io, *io;\n\tunsigned file_flags;\n\tint ret;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tif (req_has_async_data(req)) {\n\t\tio = req->async_data;\n\t} else {\n\t\tret = move_addr_to_kernel(connect->addr,\n\t\t\t\t\t\tconnect->addr_len,\n\t\t\t\t\t\t&__io.address);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tio = &__io;\n\t}\n\n\tfile_flags = force_nonblock ? O_NONBLOCK : 0;\n\n\tret = __sys_connect_file(req->file, &io->address,\n\t\t\t\t\tconnect->addr_len, file_flags);\n\tif ((ret == -EAGAIN || ret == -EINPROGRESS || ret == -ECONNABORTED)\n\t    && force_nonblock) {\n\t\tif (ret == -EINPROGRESS) {\n\t\t\tconnect->in_progress = true;\n\t\t} else if (ret == -ECONNABORTED) {\n\t\t\tif (connect->seen_econnaborted)\n\t\t\t\tgoto out;\n\t\t\tconnect->seen_econnaborted = true;\n\t\t}\n\t\tif (req_has_async_data(req))\n\t\t\treturn -EAGAIN;\n\t\tif (io_alloc_async_data(req)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(req->async_data, &__io, sizeof(__io));\n\t\treturn -EAGAIN;\n\t}\n\tif (connect->in_progress) {\n\t\t \n\t\tif (ret == -EBADFD || ret == -EISCONN)\n\t\t\tret = sock_error(sock_from_file(req->file)->sk);\n\t}\n\tif (ret == -ERESTARTSYS)\n\t\tret = -EINTR;\nout:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\treturn IOU_OK;\n}\n\nvoid io_netmsg_cache_free(struct io_cache_entry *entry)\n{\n\tkfree(container_of(entry, struct io_async_msghdr, cache));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}