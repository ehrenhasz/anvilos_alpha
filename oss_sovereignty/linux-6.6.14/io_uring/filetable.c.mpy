{
  "module_name": "filetable.c",
  "hash_id": "953cf70225be91e769f5aa319d0047a4858afdf8e6f3a7f3e11123a1d27aaecd",
  "original_prompt": "Ingested from linux-6.6.14/io_uring/filetable.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n#include <linux/io_uring.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"io_uring.h\"\n#include \"rsrc.h\"\n#include \"filetable.h\"\n\nstatic int io_file_bitmap_get(struct io_ring_ctx *ctx)\n{\n\tstruct io_file_table *table = &ctx->file_table;\n\tunsigned long nr = ctx->file_alloc_end;\n\tint ret;\n\n\tif (!table->bitmap)\n\t\treturn -ENFILE;\n\n\tdo {\n\t\tret = find_next_zero_bit(table->bitmap, nr, table->alloc_hint);\n\t\tif (ret != nr)\n\t\t\treturn ret;\n\n\t\tif (table->alloc_hint == ctx->file_alloc_start)\n\t\t\tbreak;\n\t\tnr = table->alloc_hint;\n\t\ttable->alloc_hint = ctx->file_alloc_start;\n\t} while (1);\n\n\treturn -ENFILE;\n}\n\nbool io_alloc_file_tables(struct io_file_table *table, unsigned nr_files)\n{\n\ttable->files = kvcalloc(nr_files, sizeof(table->files[0]),\n\t\t\t\tGFP_KERNEL_ACCOUNT);\n\tif (unlikely(!table->files))\n\t\treturn false;\n\n\ttable->bitmap = bitmap_zalloc(nr_files, GFP_KERNEL_ACCOUNT);\n\tif (unlikely(!table->bitmap)) {\n\t\tkvfree(table->files);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid io_free_file_tables(struct io_file_table *table)\n{\n\tkvfree(table->files);\n\tbitmap_free(table->bitmap);\n\ttable->files = NULL;\n\ttable->bitmap = NULL;\n}\n\nstatic int io_install_fixed_file(struct io_ring_ctx *ctx, struct file *file,\n\t\t\t\t u32 slot_index)\n\t__must_hold(&req->ctx->uring_lock)\n{\n\tstruct io_fixed_file *file_slot;\n\tint ret;\n\n\tif (io_is_uring_fops(file))\n\t\treturn -EBADF;\n\tif (!ctx->file_data)\n\t\treturn -ENXIO;\n\tif (slot_index >= ctx->nr_user_files)\n\t\treturn -EINVAL;\n\n\tslot_index = array_index_nospec(slot_index, ctx->nr_user_files);\n\tfile_slot = io_fixed_file_slot(&ctx->file_table, slot_index);\n\n\tif (file_slot->file_ptr) {\n\t\tret = io_queue_rsrc_removal(ctx->file_data, slot_index,\n\t\t\t\t\t    io_slot_file(file_slot));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfile_slot->file_ptr = 0;\n\t\tio_file_bitmap_clear(&ctx->file_table, slot_index);\n\t}\n\n\tret = io_scm_file_account(ctx, file);\n\tif (!ret) {\n\t\t*io_get_tag_slot(ctx->file_data, slot_index) = 0;\n\t\tio_fixed_file_set(file_slot, file);\n\t\tio_file_bitmap_set(&ctx->file_table, slot_index);\n\t}\n\treturn ret;\n}\n\nint __io_fixed_fd_install(struct io_ring_ctx *ctx, struct file *file,\n\t\t\t  unsigned int file_slot)\n{\n\tbool alloc_slot = file_slot == IORING_FILE_INDEX_ALLOC;\n\tint ret;\n\n\tif (alloc_slot) {\n\t\tret = io_file_bitmap_get(ctx);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tfile_slot = ret;\n\t} else {\n\t\tfile_slot--;\n\t}\n\n\tret = io_install_fixed_file(ctx, file, file_slot);\n\tif (!ret && alloc_slot)\n\t\tret = file_slot;\n\treturn ret;\n}\n \nint io_fixed_fd_install(struct io_kiocb *req, unsigned int issue_flags,\n\t\t\tstruct file *file, unsigned int file_slot)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tio_ring_submit_lock(ctx, issue_flags);\n\tret = __io_fixed_fd_install(ctx, file, file_slot);\n\tio_ring_submit_unlock(ctx, issue_flags);\n\n\tif (unlikely(ret < 0))\n\t\tfput(file);\n\treturn ret;\n}\n\nint io_fixed_fd_remove(struct io_ring_ctx *ctx, unsigned int offset)\n{\n\tstruct io_fixed_file *file_slot;\n\tint ret;\n\n\tif (unlikely(!ctx->file_data))\n\t\treturn -ENXIO;\n\tif (offset >= ctx->nr_user_files)\n\t\treturn -EINVAL;\n\n\toffset = array_index_nospec(offset, ctx->nr_user_files);\n\tfile_slot = io_fixed_file_slot(&ctx->file_table, offset);\n\tif (!file_slot->file_ptr)\n\t\treturn -EBADF;\n\n\tret = io_queue_rsrc_removal(ctx->file_data, offset,\n\t\t\t\t    io_slot_file(file_slot));\n\tif (ret)\n\t\treturn ret;\n\n\tfile_slot->file_ptr = 0;\n\tio_file_bitmap_clear(&ctx->file_table, offset);\n\treturn 0;\n}\n\nint io_register_file_alloc_range(struct io_ring_ctx *ctx,\n\t\t\t\t struct io_uring_file_index_range __user *arg)\n{\n\tstruct io_uring_file_index_range range;\n\tu32 end;\n\n\tif (copy_from_user(&range, arg, sizeof(range)))\n\t\treturn -EFAULT;\n\tif (check_add_overflow(range.off, range.len, &end))\n\t\treturn -EOVERFLOW;\n\tif (range.resv || end > ctx->nr_user_files)\n\t\treturn -EINVAL;\n\n\tio_file_table_set_alloc_range(ctx, range.off, range.len);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}