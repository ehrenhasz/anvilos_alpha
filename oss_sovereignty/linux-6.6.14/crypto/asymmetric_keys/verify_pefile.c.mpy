{
  "module_name": "verify_pefile.c",
  "hash_id": "297b1fb2b7dbee1619b6de3daaa1db4d0b6ceb85f73ecc3fbf1254d85688b9fc",
  "original_prompt": "Ingested from linux-6.6.14/crypto/asymmetric_keys/verify_pefile.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"PEFILE: \"fmt\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/pe.h>\n#include <linux/asn1.h>\n#include <linux/verification.h>\n#include <crypto/hash.h>\n#include \"verify_pefile.h\"\n\n \nstatic int pefile_parse_binary(const void *pebuf, unsigned int pelen,\n\t\t\t       struct pefile_context *ctx)\n{\n\tconst struct mz_hdr *mz = pebuf;\n\tconst struct pe_hdr *pe;\n\tconst struct pe32_opt_hdr *pe32;\n\tconst struct pe32plus_opt_hdr *pe64;\n\tconst struct data_directory *ddir;\n\tconst struct data_dirent *dde;\n\tconst struct section_header *secs, *sec;\n\tsize_t cursor, datalen = pelen;\n\n\tkenter(\"\");\n\n#define chkaddr(base, x, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((x) < base || (s) >= datalen || (x) > datalen - (s)) \\\n\t\t\treturn -ELIBBAD;\t\t\t\t\\\n\t} while (0)\n\n\tchkaddr(0, 0, sizeof(*mz));\n\tif (mz->magic != MZ_MAGIC)\n\t\treturn -ELIBBAD;\n\tcursor = sizeof(*mz);\n\n\tchkaddr(cursor, mz->peaddr, sizeof(*pe));\n\tpe = pebuf + mz->peaddr;\n\tif (pe->magic != PE_MAGIC)\n\t\treturn -ELIBBAD;\n\tcursor = mz->peaddr + sizeof(*pe);\n\n\tchkaddr(0, cursor, sizeof(pe32->magic));\n\tpe32 = pebuf + cursor;\n\tpe64 = pebuf + cursor;\n\n\tswitch (pe32->magic) {\n\tcase PE_OPT_MAGIC_PE32:\n\t\tchkaddr(0, cursor, sizeof(*pe32));\n\t\tctx->image_checksum_offset =\n\t\t\t(unsigned long)&pe32->csum - (unsigned long)pebuf;\n\t\tctx->header_size = pe32->header_size;\n\t\tcursor += sizeof(*pe32);\n\t\tctx->n_data_dirents = pe32->data_dirs;\n\t\tbreak;\n\n\tcase PE_OPT_MAGIC_PE32PLUS:\n\t\tchkaddr(0, cursor, sizeof(*pe64));\n\t\tctx->image_checksum_offset =\n\t\t\t(unsigned long)&pe64->csum - (unsigned long)pebuf;\n\t\tctx->header_size = pe64->header_size;\n\t\tcursor += sizeof(*pe64);\n\t\tctx->n_data_dirents = pe64->data_dirs;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"Unknown PEOPT magic = %04hx\\n\", pe32->magic);\n\t\treturn -ELIBBAD;\n\t}\n\n\tpr_debug(\"checksum @ %x\\n\", ctx->image_checksum_offset);\n\tpr_debug(\"header size = %x\\n\", ctx->header_size);\n\n\tif (cursor >= ctx->header_size || ctx->header_size >= datalen)\n\t\treturn -ELIBBAD;\n\n\tif (ctx->n_data_dirents > (ctx->header_size - cursor) / sizeof(*dde))\n\t\treturn -ELIBBAD;\n\n\tddir = pebuf + cursor;\n\tcursor += sizeof(*dde) * ctx->n_data_dirents;\n\n\tctx->cert_dirent_offset =\n\t\t(unsigned long)&ddir->certs - (unsigned long)pebuf;\n\tctx->certs_size = ddir->certs.size;\n\n\tif (!ddir->certs.virtual_address || !ddir->certs.size) {\n\t\tpr_warn(\"Unsigned PE binary\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\tchkaddr(ctx->header_size, ddir->certs.virtual_address,\n\t\tddir->certs.size);\n\tctx->sig_offset = ddir->certs.virtual_address;\n\tctx->sig_len = ddir->certs.size;\n\tpr_debug(\"cert = %x @%x [%*ph]\\n\",\n\t\t ctx->sig_len, ctx->sig_offset,\n\t\t ctx->sig_len, pebuf + ctx->sig_offset);\n\n\tctx->n_sections = pe->sections;\n\tif (ctx->n_sections > (ctx->header_size - cursor) / sizeof(*sec))\n\t\treturn -ELIBBAD;\n\tctx->secs = secs = pebuf + cursor;\n\n\treturn 0;\n}\n\n \nstatic int pefile_strip_sig_wrapper(const void *pebuf,\n\t\t\t\t    struct pefile_context *ctx)\n{\n\tstruct win_certificate wrapper;\n\tconst u8 *pkcs7;\n\tunsigned len;\n\n\tif (ctx->sig_len < sizeof(wrapper)) {\n\t\tpr_warn(\"Signature wrapper too short\\n\");\n\t\treturn -ELIBBAD;\n\t}\n\n\tmemcpy(&wrapper, pebuf + ctx->sig_offset, sizeof(wrapper));\n\tpr_debug(\"sig wrapper = { %x, %x, %x }\\n\",\n\t\t wrapper.length, wrapper.revision, wrapper.cert_type);\n\n\t \n\tif (wrapper.length > ctx->sig_len) {\n\t\tpr_warn(\"Signature wrapper bigger than sig len (%x > %x)\\n\",\n\t\t\tctx->sig_len, wrapper.length);\n\t\treturn -ELIBBAD;\n\t}\n\tif (wrapper.revision != WIN_CERT_REVISION_2_0) {\n\t\tpr_warn(\"Signature is not revision 2.0\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\tif (wrapper.cert_type != WIN_CERT_TYPE_PKCS_SIGNED_DATA) {\n\t\tpr_warn(\"Signature certificate type is not PKCS\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tctx->sig_len = wrapper.length;\n\tctx->sig_offset += sizeof(wrapper);\n\tctx->sig_len -= sizeof(wrapper);\n\tif (ctx->sig_len < 4) {\n\t\tpr_warn(\"Signature data missing\\n\");\n\t\treturn -EKEYREJECTED;\n\t}\n\n\t \n\tpkcs7 = pebuf + ctx->sig_offset;\n\tif (pkcs7[0] != (ASN1_CONS_BIT | ASN1_SEQ))\n\t\tgoto not_pkcs7;\n\n\tswitch (pkcs7[1]) {\n\tcase 0 ... 0x7f:\n\t\tlen = pkcs7[1] + 2;\n\t\tgoto check_len;\n\tcase ASN1_INDEFINITE_LENGTH:\n\t\treturn 0;\n\tcase 0x81:\n\t\tlen = pkcs7[2] + 3;\n\t\tgoto check_len;\n\tcase 0x82:\n\t\tlen = ((pkcs7[2] << 8) | pkcs7[3]) + 4;\n\t\tgoto check_len;\n\tcase 0x83 ... 0xff:\n\t\treturn -EMSGSIZE;\n\tdefault:\n\t\tgoto not_pkcs7;\n\t}\n\ncheck_len:\n\tif (len <= ctx->sig_len) {\n\t\t \n\t\tctx->sig_len = len;\n\t\treturn 0;\n\t}\nnot_pkcs7:\n\tpr_warn(\"Signature data not PKCS#7\\n\");\n\treturn -ELIBBAD;\n}\n\n \nstatic int pefile_compare_shdrs(const void *a, const void *b)\n{\n\tconst struct section_header *shdra = a;\n\tconst struct section_header *shdrb = b;\n\tint rc;\n\n\tif (shdra->data_addr > shdrb->data_addr)\n\t\treturn 1;\n\tif (shdrb->data_addr > shdra->data_addr)\n\t\treturn -1;\n\n\tif (shdra->virtual_address > shdrb->virtual_address)\n\t\treturn 1;\n\tif (shdrb->virtual_address > shdra->virtual_address)\n\t\treturn -1;\n\n\trc = strcmp(shdra->name, shdrb->name);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (shdra->virtual_size > shdrb->virtual_size)\n\t\treturn 1;\n\tif (shdrb->virtual_size > shdra->virtual_size)\n\t\treturn -1;\n\n\tif (shdra->raw_data_size > shdrb->raw_data_size)\n\t\treturn 1;\n\tif (shdrb->raw_data_size > shdra->raw_data_size)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int pefile_digest_pe_contents(const void *pebuf, unsigned int pelen,\n\t\t\t\t     struct pefile_context *ctx,\n\t\t\t\t     struct shash_desc *desc)\n{\n\tunsigned *canon, tmp, loop, i, hashed_bytes;\n\tint ret;\n\n\t \n\tret = crypto_shash_update(desc, pebuf, ctx->image_checksum_offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = ctx->image_checksum_offset + sizeof(uint32_t);\n\tret = crypto_shash_update(desc, pebuf + tmp,\n\t\t\t\t  ctx->cert_dirent_offset - tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = ctx->cert_dirent_offset + sizeof(struct data_dirent);\n\tret = crypto_shash_update(desc, pebuf + tmp, ctx->header_size - tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcanon = kcalloc(ctx->n_sections, sizeof(unsigned), GFP_KERNEL);\n\tif (!canon)\n\t\treturn -ENOMEM;\n\n\t \n\tcanon[0] = 0;\n\tfor (loop = 1; loop < ctx->n_sections; loop++) {\n\t\tfor (i = 0; i < loop; i++) {\n\t\t\tif (pefile_compare_shdrs(&ctx->secs[canon[i]],\n\t\t\t\t\t\t &ctx->secs[loop]) > 0) {\n\t\t\t\tmemmove(&canon[i + 1], &canon[i],\n\t\t\t\t\t(loop - i) * sizeof(canon[0]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcanon[i] = loop;\n\t}\n\n\thashed_bytes = ctx->header_size;\n\tfor (loop = 0; loop < ctx->n_sections; loop++) {\n\t\ti = canon[loop];\n\t\tif (ctx->secs[i].raw_data_size == 0)\n\t\t\tcontinue;\n\t\tret = crypto_shash_update(desc,\n\t\t\t\t\t  pebuf + ctx->secs[i].data_addr,\n\t\t\t\t\t  ctx->secs[i].raw_data_size);\n\t\tif (ret < 0) {\n\t\t\tkfree(canon);\n\t\t\treturn ret;\n\t\t}\n\t\thashed_bytes += ctx->secs[i].raw_data_size;\n\t}\n\tkfree(canon);\n\n\tif (pelen > hashed_bytes) {\n\t\ttmp = hashed_bytes + ctx->certs_size;\n\t\tret = crypto_shash_update(desc,\n\t\t\t\t\t  pebuf + hashed_bytes,\n\t\t\t\t\t  pelen - tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pefile_digest_pe(const void *pebuf, unsigned int pelen,\n\t\t\t    struct pefile_context *ctx)\n{\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *desc;\n\tsize_t digest_size, desc_size;\n\tvoid *digest;\n\tint ret;\n\n\tkenter(\",%s\", ctx->digest_algo);\n\n\t \n\ttfm = crypto_alloc_shash(ctx->digest_algo, 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn (PTR_ERR(tfm) == -ENOENT) ? -ENOPKG : PTR_ERR(tfm);\n\n\tdesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\n\tdigest_size = crypto_shash_digestsize(tfm);\n\n\tif (digest_size != ctx->digest_len) {\n\t\tpr_warn(\"Digest size mismatch (%zx != %x)\\n\",\n\t\t\tdigest_size, ctx->digest_len);\n\t\tret = -EBADMSG;\n\t\tgoto error_no_desc;\n\t}\n\tpr_debug(\"Digest: desc=%zu size=%zu\\n\", desc_size, digest_size);\n\n\tret = -ENOMEM;\n\tdesc = kzalloc(desc_size + digest_size, GFP_KERNEL);\n\tif (!desc)\n\t\tgoto error_no_desc;\n\n\tdesc->tfm   = tfm;\n\tret = crypto_shash_init(desc);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = pefile_digest_pe_contents(pebuf, pelen, ctx, desc);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdigest = (void *)desc + desc_size;\n\tret = crypto_shash_final(desc, digest);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tpr_debug(\"Digest calc = [%*ph]\\n\", ctx->digest_len, digest);\n\n\t \n\tif (memcmp(digest, ctx->digest, ctx->digest_len) != 0) {\n\t\tpr_warn(\"Digest mismatch\\n\");\n\t\tret = -EKEYREJECTED;\n\t} else {\n\t\tpr_debug(\"The digests match!\\n\");\n\t}\n\nerror:\n\tkfree_sensitive(desc);\nerror_no_desc:\n\tcrypto_free_shash(tfm);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nint verify_pefile_signature(const void *pebuf, unsigned pelen,\n\t\t\t    struct key *trusted_keys,\n\t\t\t    enum key_being_used_for usage)\n{\n\tstruct pefile_context ctx;\n\tint ret;\n\n\tkenter(\"\");\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tret = pefile_parse_binary(pebuf, pelen, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pefile_strip_sig_wrapper(pebuf, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = verify_pkcs7_signature(NULL, 0,\n\t\t\t\t     pebuf + ctx.sig_offset, ctx.sig_len,\n\t\t\t\t     trusted_keys, usage,\n\t\t\t\t     mscode_parse, &ctx);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tpr_debug(\"Digest: %u [%*ph]\\n\",\n\t\t ctx.digest_len, ctx.digest_len, ctx.digest);\n\n\t \n\tret = pefile_digest_pe(pebuf, pelen, &ctx);\n\nerror:\n\tkfree_sensitive(ctx.digest);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}