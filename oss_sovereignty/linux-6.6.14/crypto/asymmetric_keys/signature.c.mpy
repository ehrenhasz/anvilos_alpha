{
  "module_name": "signature.c",
  "hash_id": "d1b9f5a43c5bc9d8c92b4666781391925be877dc86b05e27e010902683717b95",
  "original_prompt": "Ingested from linux-6.6.14/crypto/asymmetric_keys/signature.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"SIG: \"fmt\n#include <keys/asymmetric-subtype.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/keyctl.h>\n#include <crypto/public_key.h>\n#include <keys/user-type.h>\n#include \"asymmetric_keys.h\"\n\n \nvoid public_key_signature_free(struct public_key_signature *sig)\n{\n\tint i;\n\n\tif (sig) {\n\t\tfor (i = 0; i < ARRAY_SIZE(sig->auth_ids); i++)\n\t\t\tkfree(sig->auth_ids[i]);\n\t\tkfree(sig->s);\n\t\tkfree(sig->digest);\n\t\tkfree(sig);\n\t}\n}\nEXPORT_SYMBOL_GPL(public_key_signature_free);\n\n \nint query_asymmetric_key(const struct kernel_pkey_params *params,\n\t\t\t struct kernel_pkey_query *info)\n{\n\tconst struct asymmetric_key_subtype *subtype;\n\tstruct key *key = params->key;\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (key->type != &key_type_asymmetric)\n\t\treturn -EINVAL;\n\tsubtype = asymmetric_key_subtype(key);\n\tif (!subtype ||\n\t    !key->payload.data[0])\n\t\treturn -EINVAL;\n\tif (!subtype->query)\n\t\treturn -ENOTSUPP;\n\n\tret = subtype->query(params, info);\n\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(query_asymmetric_key);\n\n \nint encrypt_blob(struct kernel_pkey_params *params,\n\t\t const void *data, void *enc)\n{\n\tparams->op = kernel_pkey_encrypt;\n\treturn asymmetric_key_eds_op(params, data, enc);\n}\nEXPORT_SYMBOL_GPL(encrypt_blob);\n\n \nint decrypt_blob(struct kernel_pkey_params *params,\n\t\t const void *enc, void *data)\n{\n\tparams->op = kernel_pkey_decrypt;\n\treturn asymmetric_key_eds_op(params, enc, data);\n}\nEXPORT_SYMBOL_GPL(decrypt_blob);\n\n \nint create_signature(struct kernel_pkey_params *params,\n\t\t     const void *data, void *enc)\n{\n\tparams->op = kernel_pkey_sign;\n\treturn asymmetric_key_eds_op(params, data, enc);\n}\nEXPORT_SYMBOL_GPL(create_signature);\n\n \nint verify_signature(const struct key *key,\n\t\t     const struct public_key_signature *sig)\n{\n\tconst struct asymmetric_key_subtype *subtype;\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (key->type != &key_type_asymmetric)\n\t\treturn -EINVAL;\n\tsubtype = asymmetric_key_subtype(key);\n\tif (!subtype ||\n\t    !key->payload.data[0])\n\t\treturn -EINVAL;\n\tif (!subtype->verify_signature)\n\t\treturn -ENOTSUPP;\n\n\tret = subtype->verify_signature(key, sig);\n\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(verify_signature);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}