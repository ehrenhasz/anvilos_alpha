{
  "module_name": "asymmetric_type.c",
  "hash_id": "2b3f84e9a718dc251f4ab2e67afa1b02e6d7c2278ac5e9faab694bf621031a72",
  "original_prompt": "Ingested from linux-6.6.14/crypto/asymmetric_keys/asymmetric_type.c",
  "human_readable_source": "\n \n#include <keys/asymmetric-subtype.h>\n#include <keys/asymmetric-parser.h>\n#include <crypto/public_key.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <keys/system_keyring.h>\n#include <keys/user-type.h>\n#include \"asymmetric_keys.h\"\n\n\nconst char *const key_being_used_for[NR__KEY_BEING_USED_FOR] = {\n\t[VERIFYING_MODULE_SIGNATURE]\t\t= \"mod sig\",\n\t[VERIFYING_FIRMWARE_SIGNATURE]\t\t= \"firmware sig\",\n\t[VERIFYING_KEXEC_PE_SIGNATURE]\t\t= \"kexec PE sig\",\n\t[VERIFYING_KEY_SIGNATURE]\t\t= \"key sig\",\n\t[VERIFYING_KEY_SELF_SIGNATURE]\t\t= \"key self sig\",\n\t[VERIFYING_UNSPECIFIED_SIGNATURE]\t= \"unspec sig\",\n};\nEXPORT_SYMBOL_GPL(key_being_used_for);\n\nstatic LIST_HEAD(asymmetric_key_parsers);\nstatic DECLARE_RWSEM(asymmetric_key_parsers_sem);\n\n \nstruct key *find_asymmetric_key(struct key *keyring,\n\t\t\t\tconst struct asymmetric_key_id *id_0,\n\t\t\t\tconst struct asymmetric_key_id *id_1,\n\t\t\t\tconst struct asymmetric_key_id *id_2,\n\t\t\t\tbool partial)\n{\n\tstruct key *key;\n\tkey_ref_t ref;\n\tconst char *lookup;\n\tchar *req, *p;\n\tint len;\n\n\tWARN_ON(!id_0 && !id_1 && !id_2);\n\n\tif (id_0) {\n\t\tlookup = id_0->data;\n\t\tlen = id_0->len;\n\t} else if (id_1) {\n\t\tlookup = id_1->data;\n\t\tlen = id_1->len;\n\t} else {\n\t\tlookup = id_2->data;\n\t\tlen = id_2->len;\n\t}\n\n\t \n\tp = req = kmalloc(2 + 1 + len * 2 + 1, GFP_KERNEL);\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!id_0 && !id_1) {\n\t\t*p++ = 'd';\n\t\t*p++ = 'n';\n\t} else if (partial) {\n\t\t*p++ = 'i';\n\t\t*p++ = 'd';\n\t} else {\n\t\t*p++ = 'e';\n\t\t*p++ = 'x';\n\t}\n\t*p++ = ':';\n\tp = bin2hex(p, lookup, len);\n\t*p = 0;\n\n\tpr_debug(\"Look up: \\\"%s\\\"\\n\", req);\n\n\tref = keyring_search(make_key_ref(keyring, 1),\n\t\t\t     &key_type_asymmetric, req, true);\n\tif (IS_ERR(ref))\n\t\tpr_debug(\"Request for key '%s' err %ld\\n\", req, PTR_ERR(ref));\n\tkfree(req);\n\n\tif (IS_ERR(ref)) {\n\t\tswitch (PTR_ERR(ref)) {\n\t\t\t \n\t\tcase -EACCES:\n\t\tcase -ENOTDIR:\n\t\tcase -EAGAIN:\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\tdefault:\n\t\t\treturn ERR_CAST(ref);\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(ref);\n\tif (id_0 && id_1) {\n\t\tconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\n\n\t\tif (!kids->id[1]) {\n\t\t\tpr_debug(\"First ID matches, but second is missing\\n\");\n\t\t\tgoto reject;\n\t\t}\n\t\tif (!asymmetric_key_id_same(id_1, kids->id[1])) {\n\t\t\tpr_debug(\"First ID matches, but second does not\\n\");\n\t\t\tgoto reject;\n\t\t}\n\t}\n\n\tpr_devel(\"<==%s() = 0 [%x]\\n\", __func__, key_serial(key));\n\treturn key;\n\nreject:\n\tkey_put(key);\n\treturn ERR_PTR(-EKEYREJECTED);\n}\nEXPORT_SYMBOL_GPL(find_asymmetric_key);\n\n \nstruct asymmetric_key_id *asymmetric_key_generate_id(const void *val_1,\n\t\t\t\t\t\t     size_t len_1,\n\t\t\t\t\t\t     const void *val_2,\n\t\t\t\t\t\t     size_t len_2)\n{\n\tstruct asymmetric_key_id *kid;\n\n\tkid = kmalloc(sizeof(struct asymmetric_key_id) + len_1 + len_2,\n\t\t      GFP_KERNEL);\n\tif (!kid)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkid->len = len_1 + len_2;\n\tmemcpy(kid->data, val_1, len_1);\n\tmemcpy(kid->data + len_1, val_2, len_2);\n\treturn kid;\n}\nEXPORT_SYMBOL_GPL(asymmetric_key_generate_id);\n\n \nbool asymmetric_key_id_same(const struct asymmetric_key_id *kid1,\n\t\t\t    const struct asymmetric_key_id *kid2)\n{\n\tif (!kid1 || !kid2)\n\t\treturn false;\n\tif (kid1->len != kid2->len)\n\t\treturn false;\n\treturn memcmp(kid1->data, kid2->data, kid1->len) == 0;\n}\nEXPORT_SYMBOL_GPL(asymmetric_key_id_same);\n\n \nbool asymmetric_key_id_partial(const struct asymmetric_key_id *kid1,\n\t\t\t       const struct asymmetric_key_id *kid2)\n{\n\tif (!kid1 || !kid2)\n\t\treturn false;\n\tif (kid1->len < kid2->len)\n\t\treturn false;\n\treturn memcmp(kid1->data + (kid1->len - kid2->len),\n\t\t      kid2->data, kid2->len) == 0;\n}\nEXPORT_SYMBOL_GPL(asymmetric_key_id_partial);\n\n \nstatic bool asymmetric_match_key_ids(\n\tconst struct asymmetric_key_ids *kids,\n\tconst struct asymmetric_key_id *match_id,\n\tbool (*match)(const struct asymmetric_key_id *kid1,\n\t\t      const struct asymmetric_key_id *kid2))\n{\n\tint i;\n\n\tif (!kids || !match_id)\n\t\treturn false;\n\tfor (i = 0; i < 2; i++)\n\t\tif (match(kids->id[i], match_id))\n\t\t\treturn true;\n\treturn false;\n}\n\n \ninline int __asymmetric_key_hex_to_key_id(const char *id,\n\t\t\t\t   struct asymmetric_key_id *match_id,\n\t\t\t\t   size_t hexlen)\n{\n\tmatch_id->len = hexlen;\n\treturn hex2bin(match_id->data, id, hexlen);\n}\n\n \nstruct asymmetric_key_id *asymmetric_key_hex_to_key_id(const char *id)\n{\n\tstruct asymmetric_key_id *match_id;\n\tsize_t asciihexlen;\n\tint ret;\n\n\tif (!*id)\n\t\treturn ERR_PTR(-EINVAL);\n\tasciihexlen = strlen(id);\n\tif (asciihexlen & 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmatch_id = kmalloc(sizeof(struct asymmetric_key_id) + asciihexlen / 2,\n\t\t\t   GFP_KERNEL);\n\tif (!match_id)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = __asymmetric_key_hex_to_key_id(id, match_id, asciihexlen / 2);\n\tif (ret < 0) {\n\t\tkfree(match_id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\treturn match_id;\n}\n\n \nstatic bool asymmetric_key_cmp(const struct key *key,\n\t\t\t       const struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\n\tconst struct asymmetric_key_id *match_id = match_data->preparsed;\n\n\treturn asymmetric_match_key_ids(kids, match_id,\n\t\t\t\t\tasymmetric_key_id_same);\n}\n\n \nstatic bool asymmetric_key_cmp_partial(const struct key *key,\n\t\t\t\t       const struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\n\tconst struct asymmetric_key_id *match_id = match_data->preparsed;\n\n\treturn asymmetric_match_key_ids(kids, match_id,\n\t\t\t\t\tasymmetric_key_id_partial);\n}\n\n \nstatic bool asymmetric_key_cmp_name(const struct key *key,\n\t\t\t\t    const struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\n\tconst struct asymmetric_key_id *match_id = match_data->preparsed;\n\n\treturn kids && asymmetric_key_id_same(kids->id[2], match_id);\n}\n\n \nstatic int asymmetric_key_match_preparse(struct key_match_data *match_data)\n{\n\tstruct asymmetric_key_id *match_id;\n\tconst char *spec = match_data->raw_data;\n\tconst char *id;\n\tbool (*cmp)(const struct key *, const struct key_match_data *) =\n\t\tasymmetric_key_cmp;\n\n\tif (!spec || !*spec)\n\t\treturn -EINVAL;\n\tif (spec[0] == 'i' &&\n\t    spec[1] == 'd' &&\n\t    spec[2] == ':') {\n\t\tid = spec + 3;\n\t\tcmp = asymmetric_key_cmp_partial;\n\t} else if (spec[0] == 'e' &&\n\t\t   spec[1] == 'x' &&\n\t\t   spec[2] == ':') {\n\t\tid = spec + 3;\n\t} else if (spec[0] == 'd' &&\n\t\t   spec[1] == 'n' &&\n\t\t   spec[2] == ':') {\n\t\tid = spec + 3;\n\t\tcmp = asymmetric_key_cmp_name;\n\t} else {\n\t\tgoto default_match;\n\t}\n\n\tmatch_id = asymmetric_key_hex_to_key_id(id);\n\tif (IS_ERR(match_id))\n\t\treturn PTR_ERR(match_id);\n\n\tmatch_data->preparsed = match_id;\n\tmatch_data->cmp = cmp;\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\treturn 0;\n\ndefault_match:\n\treturn 0;\n}\n\n \nstatic void asymmetric_key_match_free(struct key_match_data *match_data)\n{\n\tkfree(match_data->preparsed);\n}\n\n \nstatic void asymmetric_key_describe(const struct key *key, struct seq_file *m)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\n\tconst struct asymmetric_key_id *kid;\n\tconst unsigned char *p;\n\tint n;\n\n\tseq_puts(m, key->description);\n\n\tif (subtype) {\n\t\tseq_puts(m, \": \");\n\t\tsubtype->describe(key, m);\n\n\t\tif (kids && kids->id[1]) {\n\t\t\tkid = kids->id[1];\n\t\t\tseq_putc(m, ' ');\n\t\t\tn = kid->len;\n\t\t\tp = kid->data;\n\t\t\tif (n > 4) {\n\t\t\t\tp += n - 4;\n\t\t\t\tn = 4;\n\t\t\t}\n\t\t\tseq_printf(m, \"%*phN\", n, p);\n\t\t}\n\n\t\tseq_puts(m, \" [\");\n\t\t \n\t\tseq_putc(m, ']');\n\t}\n}\n\n \nstatic int asymmetric_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct asymmetric_key_parser *parser;\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (prep->datalen == 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&asymmetric_key_parsers_sem);\n\n\tret = -EBADMSG;\n\tlist_for_each_entry(parser, &asymmetric_key_parsers, link) {\n\t\tpr_debug(\"Trying parser '%s'\\n\", parser->name);\n\n\t\tret = parser->parse(prep);\n\t\tif (ret != -EBADMSG) {\n\t\t\tpr_debug(\"Parser recognised the format (ret %d)\\n\",\n\t\t\t\t ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_read(&asymmetric_key_parsers_sem);\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nstatic void asymmetric_key_free_kids(struct asymmetric_key_ids *kids)\n{\n\tint i;\n\n\tif (kids) {\n\t\tfor (i = 0; i < ARRAY_SIZE(kids->id); i++)\n\t\t\tkfree(kids->id[i]);\n\t\tkfree(kids);\n\t}\n}\n\n \nstatic void asymmetric_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct asymmetric_key_subtype *subtype = prep->payload.data[asym_subtype];\n\tstruct asymmetric_key_ids *kids = prep->payload.data[asym_key_ids];\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (subtype) {\n\t\tsubtype->destroy(prep->payload.data[asym_crypto],\n\t\t\t\t prep->payload.data[asym_auth]);\n\t\tmodule_put(subtype->owner);\n\t}\n\tasymmetric_key_free_kids(kids);\n\tkfree(prep->description);\n}\n\n \nstatic void asymmetric_key_destroy(struct key *key)\n{\n\tstruct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tstruct asymmetric_key_ids *kids = key->payload.data[asym_key_ids];\n\tvoid *data = key->payload.data[asym_crypto];\n\tvoid *auth = key->payload.data[asym_auth];\n\n\tkey->payload.data[asym_crypto] = NULL;\n\tkey->payload.data[asym_subtype] = NULL;\n\tkey->payload.data[asym_key_ids] = NULL;\n\tkey->payload.data[asym_auth] = NULL;\n\n\tif (subtype) {\n\t\tsubtype->destroy(data, auth);\n\t\tmodule_put(subtype->owner);\n\t}\n\n\tasymmetric_key_free_kids(kids);\n}\n\nstatic struct key_restriction *asymmetric_restriction_alloc(\n\tkey_restrict_link_func_t check,\n\tstruct key *key)\n{\n\tstruct key_restriction *keyres =\n\t\tkzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\n\tif (!keyres)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkeyres->check = check;\n\tkeyres->key = key;\n\tkeyres->keytype = &key_type_asymmetric;\n\n\treturn keyres;\n}\n\n \nstatic struct key_restriction *asymmetric_lookup_restriction(\n\tconst char *restriction)\n{\n\tchar *restrict_method;\n\tchar *parse_buf;\n\tchar *next;\n\tstruct key_restriction *ret = ERR_PTR(-EINVAL);\n\n\tif (strcmp(\"builtin_trusted\", restriction) == 0)\n\t\treturn asymmetric_restriction_alloc(\n\t\t\trestrict_link_by_builtin_trusted, NULL);\n\n\tif (strcmp(\"builtin_and_secondary_trusted\", restriction) == 0)\n\t\treturn asymmetric_restriction_alloc(\n\t\t\trestrict_link_by_builtin_and_secondary_trusted, NULL);\n\n\tparse_buf = kstrndup(restriction, PAGE_SIZE, GFP_KERNEL);\n\tif (!parse_buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnext = parse_buf;\n\trestrict_method = strsep(&next, \":\");\n\n\tif ((strcmp(restrict_method, \"key_or_keyring\") == 0) && next) {\n\t\tchar *key_text;\n\t\tkey_serial_t serial;\n\t\tstruct key *key;\n\t\tkey_restrict_link_func_t link_fn =\n\t\t\trestrict_link_by_key_or_keyring;\n\t\tbool allow_null_key = false;\n\n\t\tkey_text = strsep(&next, \":\");\n\n\t\tif (next) {\n\t\t\tif (strcmp(next, \"chain\") != 0)\n\t\t\t\tgoto out;\n\n\t\t\tlink_fn = restrict_link_by_key_or_keyring_chain;\n\t\t\tallow_null_key = true;\n\t\t}\n\n\t\tif (kstrtos32(key_text, 0, &serial) < 0)\n\t\t\tgoto out;\n\n\t\tif ((serial == 0) && allow_null_key) {\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\tkey = key_lookup(serial);\n\t\t\tif (IS_ERR(key)) {\n\t\t\t\tret = ERR_CAST(key);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tret = asymmetric_restriction_alloc(link_fn, key);\n\t\tif (IS_ERR(ret))\n\t\t\tkey_put(key);\n\t}\n\nout:\n\tkfree(parse_buf);\n\treturn ret;\n}\n\nint asymmetric_key_eds_op(struct kernel_pkey_params *params,\n\t\t\t  const void *in, void *out)\n{\n\tconst struct asymmetric_key_subtype *subtype;\n\tstruct key *key = params->key;\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (key->type != &key_type_asymmetric)\n\t\treturn -EINVAL;\n\tsubtype = asymmetric_key_subtype(key);\n\tif (!subtype ||\n\t    !key->payload.data[0])\n\t\treturn -EINVAL;\n\tif (!subtype->eds_op)\n\t\treturn -ENOTSUPP;\n\n\tret = subtype->eds_op(params, in, out);\n\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int asymmetric_key_verify_signature(struct kernel_pkey_params *params,\n\t\t\t\t\t   const void *in, const void *in2)\n{\n\tstruct public_key_signature sig = {\n\t\t.s_size\t\t= params->in2_len,\n\t\t.digest_size\t= params->in_len,\n\t\t.encoding\t= params->encoding,\n\t\t.hash_algo\t= params->hash_algo,\n\t\t.digest\t\t= (void *)in,\n\t\t.s\t\t= (void *)in2,\n\t};\n\n\treturn verify_signature(params->key, &sig);\n}\n\nstruct key_type key_type_asymmetric = {\n\t.name\t\t\t= \"asymmetric\",\n\t.preparse\t\t= asymmetric_key_preparse,\n\t.free_preparse\t\t= asymmetric_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.match_preparse\t\t= asymmetric_key_match_preparse,\n\t.match_free\t\t= asymmetric_key_match_free,\n\t.destroy\t\t= asymmetric_key_destroy,\n\t.describe\t\t= asymmetric_key_describe,\n\t.lookup_restriction\t= asymmetric_lookup_restriction,\n\t.asym_query\t\t= query_asymmetric_key,\n\t.asym_eds_op\t\t= asymmetric_key_eds_op,\n\t.asym_verify_signature\t= asymmetric_key_verify_signature,\n};\nEXPORT_SYMBOL_GPL(key_type_asymmetric);\n\n \nint register_asymmetric_key_parser(struct asymmetric_key_parser *parser)\n{\n\tstruct asymmetric_key_parser *cursor;\n\tint ret;\n\n\tdown_write(&asymmetric_key_parsers_sem);\n\n\tlist_for_each_entry(cursor, &asymmetric_key_parsers, link) {\n\t\tif (strcmp(cursor->name, parser->name) == 0) {\n\t\t\tpr_err(\"Asymmetric key parser '%s' already registered\\n\",\n\t\t\t       parser->name);\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add_tail(&parser->link, &asymmetric_key_parsers);\n\n\tpr_notice(\"Asymmetric key parser '%s' registered\\n\", parser->name);\n\tret = 0;\n\nout:\n\tup_write(&asymmetric_key_parsers_sem);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(register_asymmetric_key_parser);\n\n \nvoid unregister_asymmetric_key_parser(struct asymmetric_key_parser *parser)\n{\n\tdown_write(&asymmetric_key_parsers_sem);\n\tlist_del(&parser->link);\n\tup_write(&asymmetric_key_parsers_sem);\n\n\tpr_notice(\"Asymmetric key parser '%s' unregistered\\n\", parser->name);\n}\nEXPORT_SYMBOL_GPL(unregister_asymmetric_key_parser);\n\n \nstatic int __init asymmetric_key_init(void)\n{\n\treturn register_key_type(&key_type_asymmetric);\n}\n\nstatic void __exit asymmetric_key_cleanup(void)\n{\n\tunregister_key_type(&key_type_asymmetric);\n}\n\nmodule_init(asymmetric_key_init);\nmodule_exit(asymmetric_key_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}