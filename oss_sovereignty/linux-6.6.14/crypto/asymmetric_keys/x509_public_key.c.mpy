{
  "module_name": "x509_public_key.c",
  "hash_id": "64adf89cd85e522a2f9b61059d3cefe5de59b0883570446655cb8a84909015af",
  "original_prompt": "Ingested from linux-6.6.14/crypto/asymmetric_keys/x509_public_key.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"X.509: \"fmt\n#include <crypto/hash.h>\n#include <crypto/sm2.h>\n#include <keys/asymmetric-parser.h>\n#include <keys/asymmetric-subtype.h>\n#include <keys/system_keyring.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include \"asymmetric_keys.h\"\n#include \"x509_parser.h\"\n\n \nint x509_get_sig_params(struct x509_certificate *cert)\n{\n\tstruct public_key_signature *sig = cert->sig;\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *desc;\n\tsize_t desc_size;\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tsig->s = kmemdup(cert->raw_sig, cert->raw_sig_size, GFP_KERNEL);\n\tif (!sig->s)\n\t\treturn -ENOMEM;\n\n\tsig->s_size = cert->raw_sig_size;\n\n\t \n\ttfm = crypto_alloc_shash(sig->hash_algo, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tif (PTR_ERR(tfm) == -ENOENT) {\n\t\t\tcert->unsupported_sig = true;\n\t\t\treturn 0;\n\t\t}\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\tdesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\n\tsig->digest_size = crypto_shash_digestsize(tfm);\n\n\tret = -ENOMEM;\n\tsig->digest = kmalloc(sig->digest_size, GFP_KERNEL);\n\tif (!sig->digest)\n\t\tgoto error;\n\n\tdesc = kzalloc(desc_size, GFP_KERNEL);\n\tif (!desc)\n\t\tgoto error;\n\n\tdesc->tfm = tfm;\n\n\tif (strcmp(cert->pub->pkey_algo, \"sm2\") == 0) {\n\t\tret = strcmp(sig->hash_algo, \"sm3\") != 0 ? -EINVAL :\n\t\t      crypto_shash_init(desc) ?:\n\t\t      sm2_compute_z_digest(desc, cert->pub->key,\n\t\t\t\t\t   cert->pub->keylen, sig->digest) ?:\n\t\t      crypto_shash_init(desc) ?:\n\t\t      crypto_shash_update(desc, sig->digest,\n\t\t\t\t\t  sig->digest_size) ?:\n\t\t      crypto_shash_finup(desc, cert->tbs, cert->tbs_size,\n\t\t\t\t\t sig->digest);\n\t} else {\n\t\tret = crypto_shash_digest(desc, cert->tbs, cert->tbs_size,\n\t\t\t\t\t  sig->digest);\n\t}\n\n\tif (ret < 0)\n\t\tgoto error_2;\n\n\tret = is_hash_blacklisted(sig->digest, sig->digest_size,\n\t\t\t\t  BLACKLIST_HASH_X509_TBS);\n\tif (ret == -EKEYREJECTED) {\n\t\tpr_err(\"Cert %*phN is blacklisted\\n\",\n\t\t       sig->digest_size, sig->digest);\n\t\tcert->blacklisted = true;\n\t\tret = 0;\n\t}\n\nerror_2:\n\tkfree(desc);\nerror:\n\tcrypto_free_shash(tfm);\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nint x509_check_for_self_signed(struct x509_certificate *cert)\n{\n\tint ret = 0;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (cert->raw_subject_size != cert->raw_issuer_size ||\n\t    memcmp(cert->raw_subject, cert->raw_issuer,\n\t\t   cert->raw_issuer_size) != 0)\n\t\tgoto not_self_signed;\n\n\tif (cert->sig->auth_ids[0] || cert->sig->auth_ids[1]) {\n\t\t \n\t\tbool a = asymmetric_key_id_same(cert->skid, cert->sig->auth_ids[1]);\n\t\tbool b = asymmetric_key_id_same(cert->id, cert->sig->auth_ids[0]);\n\n\t\tif (!a && !b)\n\t\t\tgoto not_self_signed;\n\n\t\tret = -EKEYREJECTED;\n\t\tif (((a && !b) || (b && !a)) &&\n\t\t    cert->sig->auth_ids[0] && cert->sig->auth_ids[1])\n\t\t\tgoto out;\n\t}\n\n\tif (cert->unsupported_sig) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = public_key_verify_signature(cert->pub, cert->sig);\n\tif (ret < 0) {\n\t\tif (ret == -ENOPKG) {\n\t\t\tcert->unsupported_sig = true;\n\t\t\tret = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tpr_devel(\"Cert Self-signature verified\");\n\tcert->self_signed = true;\n\nout:\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n\nnot_self_signed:\n\tpr_devel(\"<==%s() = 0 [not]\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic int x509_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct asymmetric_key_ids *kids;\n\tstruct x509_certificate *cert;\n\tconst char *q;\n\tsize_t srlen, sulen;\n\tchar *desc = NULL, *p;\n\tint ret;\n\n\tcert = x509_cert_parse(prep->data, prep->datalen);\n\tif (IS_ERR(cert))\n\t\treturn PTR_ERR(cert);\n\n\tpr_devel(\"Cert Issuer: %s\\n\", cert->issuer);\n\tpr_devel(\"Cert Subject: %s\\n\", cert->subject);\n\tpr_devel(\"Cert Key Algo: %s\\n\", cert->pub->pkey_algo);\n\tpr_devel(\"Cert Valid period: %lld-%lld\\n\", cert->valid_from, cert->valid_to);\n\n\tcert->pub->id_type = \"X509\";\n\n\tif (cert->unsupported_sig) {\n\t\tpublic_key_signature_free(cert->sig);\n\t\tcert->sig = NULL;\n\t} else {\n\t\tpr_devel(\"Cert Signature: %s + %s\\n\",\n\t\t\t cert->sig->pkey_algo, cert->sig->hash_algo);\n\t}\n\n\t \n\tret = -EKEYREJECTED;\n\tif (cert->blacklisted)\n\t\tgoto error_free_cert;\n\n\t \n\tsulen = strlen(cert->subject);\n\tif (cert->raw_skid) {\n\t\tsrlen = cert->raw_skid_size;\n\t\tq = cert->raw_skid;\n\t} else {\n\t\tsrlen = cert->raw_serial_size;\n\t\tq = cert->raw_serial;\n\t}\n\n\tret = -ENOMEM;\n\tdesc = kmalloc(sulen + 2 + srlen * 2 + 1, GFP_KERNEL);\n\tif (!desc)\n\t\tgoto error_free_cert;\n\tp = memcpy(desc, cert->subject, sulen);\n\tp += sulen;\n\t*p++ = ':';\n\t*p++ = ' ';\n\tp = bin2hex(p, q, srlen);\n\t*p = 0;\n\n\tkids = kmalloc(sizeof(struct asymmetric_key_ids), GFP_KERNEL);\n\tif (!kids)\n\t\tgoto error_free_desc;\n\tkids->id[0] = cert->id;\n\tkids->id[1] = cert->skid;\n\tkids->id[2] = asymmetric_key_generate_id(cert->raw_subject,\n\t\t\t\t\t\t cert->raw_subject_size,\n\t\t\t\t\t\t \"\", 0);\n\tif (IS_ERR(kids->id[2])) {\n\t\tret = PTR_ERR(kids->id[2]);\n\t\tgoto error_free_kids;\n\t}\n\n\t \n\t__module_get(public_key_subtype.owner);\n\tprep->payload.data[asym_subtype] = &public_key_subtype;\n\tprep->payload.data[asym_key_ids] = kids;\n\tprep->payload.data[asym_crypto] = cert->pub;\n\tprep->payload.data[asym_auth] = cert->sig;\n\tprep->description = desc;\n\tprep->quotalen = 100;\n\n\t \n\tcert->pub = NULL;\n\tcert->id = NULL;\n\tcert->skid = NULL;\n\tcert->sig = NULL;\n\tdesc = NULL;\n\tkids = NULL;\n\tret = 0;\n\nerror_free_kids:\n\tkfree(kids);\nerror_free_desc:\n\tkfree(desc);\nerror_free_cert:\n\tx509_free_certificate(cert);\n\treturn ret;\n}\n\nstatic struct asymmetric_key_parser x509_key_parser = {\n\t.owner\t= THIS_MODULE,\n\t.name\t= \"x509\",\n\t.parse\t= x509_key_preparse,\n};\n\n \nstatic int __init x509_key_init(void)\n{\n\treturn register_asymmetric_key_parser(&x509_key_parser);\n}\n\nstatic void __exit x509_key_exit(void)\n{\n\tunregister_asymmetric_key_parser(&x509_key_parser);\n}\n\nmodule_init(x509_key_init);\nmodule_exit(x509_key_exit);\n\nMODULE_DESCRIPTION(\"X.509 certificate parser\");\nMODULE_AUTHOR(\"Red Hat, Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}