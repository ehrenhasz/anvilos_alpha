{
  "module_name": "restrict.c",
  "hash_id": "bae7fe1d168ee32dc69cbb42782cdb130c82268a42818bfe9531c97520639896",
  "original_prompt": "Ingested from linux-6.6.14/crypto/asymmetric_keys/restrict.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ASYM: \"fmt\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <crypto/public_key.h>\n#include \"asymmetric_keys.h\"\n\nstatic bool use_builtin_keys;\nstatic struct asymmetric_key_id *ca_keyid;\n\n#ifndef MODULE\nstatic struct {\n\tstruct asymmetric_key_id id;\n\tunsigned char data[10];\n} cakey;\n\nstatic int __init ca_keys_setup(char *str)\n{\n\tif (!str)\t\t \n\t\treturn 1;\n\n\tif (strncmp(str, \"id:\", 3) == 0) {\n\t\tstruct asymmetric_key_id *p = &cakey.id;\n\t\tsize_t hexlen = (strlen(str) - 3) / 2;\n\t\tint ret;\n\n\t\tif (hexlen == 0 || hexlen > sizeof(cakey.data)) {\n\t\t\tpr_err(\"Missing or invalid ca_keys id\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tret = __asymmetric_key_hex_to_key_id(str + 3, p, hexlen);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"Unparsable ca_keys id hex string\\n\");\n\t\telse\n\t\t\tca_keyid = p;\t \n\t} else if (strcmp(str, \"builtin\") == 0) {\n\t\tuse_builtin_keys = true;\n\t}\n\n\treturn 1;\n}\n__setup(\"ca_keys=\", ca_keys_setup);\n#endif\n\n \nint restrict_link_by_signature(struct key *dest_keyring,\n\t\t\t       const struct key_type *type,\n\t\t\t       const union key_payload *payload,\n\t\t\t       struct key *trust_keyring)\n{\n\tconst struct public_key_signature *sig;\n\tstruct key *key;\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (!trust_keyring)\n\t\treturn -ENOKEY;\n\n\tif (type != &key_type_asymmetric)\n\t\treturn -EOPNOTSUPP;\n\n\tsig = payload->data[asym_auth];\n\tif (!sig)\n\t\treturn -ENOPKG;\n\tif (!sig->auth_ids[0] && !sig->auth_ids[1] && !sig->auth_ids[2])\n\t\treturn -ENOKEY;\n\n\tif (ca_keyid && !asymmetric_key_id_partial(sig->auth_ids[1], ca_keyid))\n\t\treturn -EPERM;\n\n\t \n\tkey = find_asymmetric_key(trust_keyring,\n\t\t\t\t  sig->auth_ids[0], sig->auth_ids[1],\n\t\t\t\t  sig->auth_ids[2], false);\n\tif (IS_ERR(key))\n\t\treturn -ENOKEY;\n\n\tif (use_builtin_keys && !test_bit(KEY_FLAG_BUILTIN, &key->flags))\n\t\tret = -ENOKEY;\n\telse\n\t\tret = verify_signature(key, sig);\n\tkey_put(key);\n\treturn ret;\n}\n\n \nint restrict_link_by_ca(struct key *dest_keyring,\n\t\t\tconst struct key_type *type,\n\t\t\tconst union key_payload *payload,\n\t\t\tstruct key *trust_keyring)\n{\n\tconst struct public_key *pkey;\n\n\tif (type != &key_type_asymmetric)\n\t\treturn -EOPNOTSUPP;\n\n\tpkey = payload->data[asym_crypto];\n\tif (!pkey)\n\t\treturn -ENOPKG;\n\tif (!test_bit(KEY_EFLAG_CA, &pkey->key_eflags))\n\t\treturn -ENOKEY;\n\tif (!test_bit(KEY_EFLAG_KEYCERTSIGN, &pkey->key_eflags))\n\t\treturn -ENOKEY;\n\tif (!IS_ENABLED(CONFIG_INTEGRITY_CA_MACHINE_KEYRING_MAX))\n\t\treturn 0;\n\tif (test_bit(KEY_EFLAG_DIGITALSIG, &pkey->key_eflags))\n\t\treturn -ENOKEY;\n\n\treturn 0;\n}\n\n \nint restrict_link_by_digsig(struct key *dest_keyring,\n\t\t\t    const struct key_type *type,\n\t\t\t    const union key_payload *payload,\n\t\t\t    struct key *trust_keyring)\n{\n\tconst struct public_key *pkey;\n\n\tif (type != &key_type_asymmetric)\n\t\treturn -EOPNOTSUPP;\n\n\tpkey = payload->data[asym_crypto];\n\n\tif (!pkey)\n\t\treturn -ENOPKG;\n\n\tif (!test_bit(KEY_EFLAG_DIGITALSIG, &pkey->key_eflags))\n\t\treturn -ENOKEY;\n\n\tif (test_bit(KEY_EFLAG_CA, &pkey->key_eflags))\n\t\treturn -ENOKEY;\n\n\tif (test_bit(KEY_EFLAG_KEYCERTSIGN, &pkey->key_eflags))\n\t\treturn -ENOKEY;\n\n\treturn restrict_link_by_signature(dest_keyring, type, payload,\n\t\t\t\t\t  trust_keyring);\n}\n\nstatic bool match_either_id(const struct asymmetric_key_id **pair,\n\t\t\t    const struct asymmetric_key_id *single)\n{\n\treturn (asymmetric_key_id_same(pair[0], single) ||\n\t\tasymmetric_key_id_same(pair[1], single));\n}\n\nstatic int key_or_keyring_common(struct key *dest_keyring,\n\t\t\t\t const struct key_type *type,\n\t\t\t\t const union key_payload *payload,\n\t\t\t\t struct key *trusted, bool check_dest)\n{\n\tconst struct public_key_signature *sig;\n\tstruct key *key = NULL;\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (!dest_keyring)\n\t\treturn -ENOKEY;\n\telse if (dest_keyring->type != &key_type_keyring)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!trusted && !check_dest)\n\t\treturn -ENOKEY;\n\n\tif (type != &key_type_asymmetric)\n\t\treturn -EOPNOTSUPP;\n\n\tsig = payload->data[asym_auth];\n\tif (!sig)\n\t\treturn -ENOPKG;\n\tif (!sig->auth_ids[0] && !sig->auth_ids[1] && !sig->auth_ids[2])\n\t\treturn -ENOKEY;\n\n\tif (trusted) {\n\t\tif (trusted->type == &key_type_keyring) {\n\t\t\t \n\t\t\tkey = find_asymmetric_key(trusted, sig->auth_ids[0],\n\t\t\t\t\t\t  sig->auth_ids[1],\n\t\t\t\t\t\t  sig->auth_ids[2], false);\n\t\t\tif (IS_ERR(key))\n\t\t\t\tkey = NULL;\n\t\t} else if (trusted->type == &key_type_asymmetric) {\n\t\t\tconst struct asymmetric_key_id **signer_ids;\n\n\t\t\tsigner_ids = (const struct asymmetric_key_id **)\n\t\t\t\tasymmetric_key_ids(trusted)->id;\n\n\t\t\t \n\t\t\tif (!sig->auth_ids[0] && !sig->auth_ids[1]) {\n\t\t\t\tif (asymmetric_key_id_same(signer_ids[2],\n\t\t\t\t\t\t\t   sig->auth_ids[2]))\n\t\t\t\t\tkey = __key_get(trusted);\n\n\t\t\t} else if (!sig->auth_ids[0] || !sig->auth_ids[1]) {\n\t\t\t\tconst struct asymmetric_key_id *auth_id;\n\n\t\t\t\tauth_id = sig->auth_ids[0] ?: sig->auth_ids[1];\n\t\t\t\tif (match_either_id(signer_ids, auth_id))\n\t\t\t\t\tkey = __key_get(trusted);\n\n\t\t\t} else if (asymmetric_key_id_same(signer_ids[1],\n\t\t\t\t\t\t\t  sig->auth_ids[1]) &&\n\t\t\t\t   match_either_id(signer_ids,\n\t\t\t\t\t\t   sig->auth_ids[0])) {\n\t\t\t\tkey = __key_get(trusted);\n\t\t\t}\n\t\t} else {\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (check_dest && !key) {\n\t\t \n\t\tkey = find_asymmetric_key(dest_keyring, sig->auth_ids[0],\n\t\t\t\t\t  sig->auth_ids[1], sig->auth_ids[2],\n\t\t\t\t\t  false);\n\t\tif (IS_ERR(key))\n\t\t\tkey = NULL;\n\t}\n\n\tif (!key)\n\t\treturn -ENOKEY;\n\n\tret = key_validate(key);\n\tif (ret == 0)\n\t\tret = verify_signature(key, sig);\n\n\tkey_put(key);\n\treturn ret;\n}\n\n \nint restrict_link_by_key_or_keyring(struct key *dest_keyring,\n\t\t\t\t    const struct key_type *type,\n\t\t\t\t    const union key_payload *payload,\n\t\t\t\t    struct key *trusted)\n{\n\treturn key_or_keyring_common(dest_keyring, type, payload, trusted,\n\t\t\t\t     false);\n}\n\n \nint restrict_link_by_key_or_keyring_chain(struct key *dest_keyring,\n\t\t\t\t\t  const struct key_type *type,\n\t\t\t\t\t  const union key_payload *payload,\n\t\t\t\t\t  struct key *trusted)\n{\n\treturn key_or_keyring_common(dest_keyring, type, payload, trusted,\n\t\t\t\t     true);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}