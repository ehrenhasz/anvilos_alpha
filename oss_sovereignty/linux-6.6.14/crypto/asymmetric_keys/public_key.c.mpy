{
  "module_name": "public_key.c",
  "hash_id": "7ea7ff05ecd90d36710a8ca6be717ec3087f8d9cfe1696eb23e77d616318d685",
  "original_prompt": "Ingested from linux-6.6.14/crypto/asymmetric_keys/public_key.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"PKEY: \"fmt\n#include <crypto/akcipher.h>\n#include <crypto/public_key.h>\n#include <crypto/sig.h>\n#include <keys/asymmetric-subtype.h>\n#include <linux/asn1.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nMODULE_DESCRIPTION(\"In-software asymmetric public-key subtype\");\nMODULE_AUTHOR(\"Red Hat, Inc.\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic void public_key_describe(const struct key *asymmetric_key,\n\t\t\t\tstruct seq_file *m)\n{\n\tstruct public_key *key = asymmetric_key->payload.data[asym_crypto];\n\n\tif (key)\n\t\tseq_printf(m, \"%s.%s\", key->id_type, key->pkey_algo);\n}\n\n \nvoid public_key_free(struct public_key *key)\n{\n\tif (key) {\n\t\tkfree_sensitive(key->key);\n\t\tkfree(key->params);\n\t\tkfree(key);\n\t}\n}\nEXPORT_SYMBOL_GPL(public_key_free);\n\n \nstatic void public_key_destroy(void *payload0, void *payload3)\n{\n\tpublic_key_free(payload0);\n\tpublic_key_signature_free(payload3);\n}\n\n \nstatic int\nsoftware_key_determine_akcipher(const struct public_key *pkey,\n\t\t\t\tconst char *encoding, const char *hash_algo,\n\t\t\t\tchar alg_name[CRYPTO_MAX_ALG_NAME], bool *sig,\n\t\t\t\tenum kernel_pkey_operation op)\n{\n\tint n;\n\n\t*sig = true;\n\n\tif (!encoding)\n\t\treturn -EINVAL;\n\n\tif (strcmp(pkey->pkey_algo, \"rsa\") == 0) {\n\t\t \n\t\tif (strcmp(encoding, \"pkcs1\") == 0) {\n\t\t\t*sig = op == kernel_pkey_sign ||\n\t\t\t       op == kernel_pkey_verify;\n\t\t\tif (!hash_algo) {\n\t\t\t\tn = snprintf(alg_name, CRYPTO_MAX_ALG_NAME,\n\t\t\t\t\t     \"pkcs1pad(%s)\",\n\t\t\t\t\t     pkey->pkey_algo);\n\t\t\t} else {\n\t\t\t\tn = snprintf(alg_name, CRYPTO_MAX_ALG_NAME,\n\t\t\t\t\t     \"pkcs1pad(%s,%s)\",\n\t\t\t\t\t     pkey->pkey_algo, hash_algo);\n\t\t\t}\n\t\t\treturn n >= CRYPTO_MAX_ALG_NAME ? -EINVAL : 0;\n\t\t}\n\t\tif (strcmp(encoding, \"raw\") != 0)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (hash_algo)\n\t\t\treturn -EINVAL;\n\t\t*sig = false;\n\t} else if (strncmp(pkey->pkey_algo, \"ecdsa\", 5) == 0) {\n\t\tif (strcmp(encoding, \"x962\") != 0)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (!hash_algo)\n\t\t\treturn -EINVAL;\n\t\tif (strcmp(hash_algo, \"sha1\") != 0 &&\n\t\t    strcmp(hash_algo, \"sha224\") != 0 &&\n\t\t    strcmp(hash_algo, \"sha256\") != 0 &&\n\t\t    strcmp(hash_algo, \"sha384\") != 0 &&\n\t\t    strcmp(hash_algo, \"sha512\") != 0)\n\t\t\treturn -EINVAL;\n\t} else if (strcmp(pkey->pkey_algo, \"sm2\") == 0) {\n\t\tif (strcmp(encoding, \"raw\") != 0)\n\t\t\treturn -EINVAL;\n\t\tif (!hash_algo)\n\t\t\treturn -EINVAL;\n\t\tif (strcmp(hash_algo, \"sm3\") != 0)\n\t\t\treturn -EINVAL;\n\t} else if (strcmp(pkey->pkey_algo, \"ecrdsa\") == 0) {\n\t\tif (strcmp(encoding, \"raw\") != 0)\n\t\t\treturn -EINVAL;\n\t\tif (!hash_algo)\n\t\t\treturn -EINVAL;\n\t\tif (strcmp(hash_algo, \"streebog256\") != 0 &&\n\t\t    strcmp(hash_algo, \"streebog512\") != 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\treturn -ENOPKG;\n\t}\n\tif (strscpy(alg_name, pkey->pkey_algo, CRYPTO_MAX_ALG_NAME) < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic u8 *pkey_pack_u32(u8 *dst, u32 val)\n{\n\tmemcpy(dst, &val, sizeof(val));\n\treturn dst + sizeof(val);\n}\n\n \nstatic int software_key_query(const struct kernel_pkey_params *params,\n\t\t\t      struct kernel_pkey_query *info)\n{\n\tstruct crypto_akcipher *tfm;\n\tstruct public_key *pkey = params->key->payload.data[asym_crypto];\n\tchar alg_name[CRYPTO_MAX_ALG_NAME];\n\tstruct crypto_sig *sig;\n\tu8 *key, *ptr;\n\tint ret, len;\n\tbool issig;\n\n\tret = software_key_determine_akcipher(pkey, params->encoding,\n\t\t\t\t\t      params->hash_algo, alg_name,\n\t\t\t\t\t      &issig, kernel_pkey_sign);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tkey = kmalloc(pkey->keylen + sizeof(u32) * 2 + pkey->paramlen,\n\t\t      GFP_KERNEL);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\tmemcpy(key, pkey->key, pkey->keylen);\n\tptr = key + pkey->keylen;\n\tptr = pkey_pack_u32(ptr, pkey->algo);\n\tptr = pkey_pack_u32(ptr, pkey->paramlen);\n\tmemcpy(ptr, pkey->params, pkey->paramlen);\n\n\tif (issig) {\n\t\tsig = crypto_alloc_sig(alg_name, 0, 0);\n\t\tif (IS_ERR(sig)) {\n\t\t\tret = PTR_ERR(sig);\n\t\t\tgoto error_free_key;\n\t\t}\n\n\t\tif (pkey->key_is_private)\n\t\t\tret = crypto_sig_set_privkey(sig, key, pkey->keylen);\n\t\telse\n\t\t\tret = crypto_sig_set_pubkey(sig, key, pkey->keylen);\n\t\tif (ret < 0)\n\t\t\tgoto error_free_tfm;\n\n\t\tlen = crypto_sig_maxsize(sig);\n\n\t\tinfo->supported_ops = KEYCTL_SUPPORTS_VERIFY;\n\t\tif (pkey->key_is_private)\n\t\t\tinfo->supported_ops |= KEYCTL_SUPPORTS_SIGN;\n\n\t\tif (strcmp(params->encoding, \"pkcs1\") == 0) {\n\t\t\tinfo->supported_ops |= KEYCTL_SUPPORTS_ENCRYPT;\n\t\t\tif (pkey->key_is_private)\n\t\t\t\tinfo->supported_ops |= KEYCTL_SUPPORTS_DECRYPT;\n\t\t}\n\t} else {\n\t\ttfm = crypto_alloc_akcipher(alg_name, 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\tret = PTR_ERR(tfm);\n\t\t\tgoto error_free_key;\n\t\t}\n\n\t\tif (pkey->key_is_private)\n\t\t\tret = crypto_akcipher_set_priv_key(tfm, key, pkey->keylen);\n\t\telse\n\t\t\tret = crypto_akcipher_set_pub_key(tfm, key, pkey->keylen);\n\t\tif (ret < 0)\n\t\t\tgoto error_free_tfm;\n\n\t\tlen = crypto_akcipher_maxsize(tfm);\n\n\t\tinfo->supported_ops = KEYCTL_SUPPORTS_ENCRYPT;\n\t\tif (pkey->key_is_private)\n\t\t\tinfo->supported_ops |= KEYCTL_SUPPORTS_DECRYPT;\n\t}\n\n\tinfo->key_size = len * 8;\n\n\tif (strncmp(pkey->pkey_algo, \"ecdsa\", 5) == 0) {\n\t\t \n\t\tinfo->max_data_size = 64;\n\n\t\t \n\t\tinfo->max_sig_size = 2 * (len + 3) + 2;\n\t} else {\n\t\tinfo->max_data_size = len;\n\t\tinfo->max_sig_size = len;\n\t}\n\n\tinfo->max_enc_size = len;\n\tinfo->max_dec_size = len;\n\n\tret = 0;\n\nerror_free_tfm:\n\tif (issig)\n\t\tcrypto_free_sig(sig);\n\telse\n\t\tcrypto_free_akcipher(tfm);\nerror_free_key:\n\tkfree_sensitive(key);\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nstatic int software_key_eds_op(struct kernel_pkey_params *params,\n\t\t\t       const void *in, void *out)\n{\n\tconst struct public_key *pkey = params->key->payload.data[asym_crypto];\n\tchar alg_name[CRYPTO_MAX_ALG_NAME];\n\tstruct crypto_akcipher *tfm;\n\tstruct crypto_sig *sig;\n\tchar *key, *ptr;\n\tbool issig;\n\tint ksz;\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tret = software_key_determine_akcipher(pkey, params->encoding,\n\t\t\t\t\t      params->hash_algo, alg_name,\n\t\t\t\t\t      &issig, params->op);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tkey = kmalloc(pkey->keylen + sizeof(u32) * 2 + pkey->paramlen,\n\t\t      GFP_KERNEL);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\tmemcpy(key, pkey->key, pkey->keylen);\n\tptr = key + pkey->keylen;\n\tptr = pkey_pack_u32(ptr, pkey->algo);\n\tptr = pkey_pack_u32(ptr, pkey->paramlen);\n\tmemcpy(ptr, pkey->params, pkey->paramlen);\n\n\tif (issig) {\n\t\tsig = crypto_alloc_sig(alg_name, 0, 0);\n\t\tif (IS_ERR(sig)) {\n\t\t\tret = PTR_ERR(sig);\n\t\t\tgoto error_free_key;\n\t\t}\n\n\t\tif (pkey->key_is_private)\n\t\t\tret = crypto_sig_set_privkey(sig, key, pkey->keylen);\n\t\telse\n\t\t\tret = crypto_sig_set_pubkey(sig, key, pkey->keylen);\n\t\tif (ret)\n\t\t\tgoto error_free_tfm;\n\n\t\tksz = crypto_sig_maxsize(sig);\n\t} else {\n\t\ttfm = crypto_alloc_akcipher(alg_name, 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\tret = PTR_ERR(tfm);\n\t\t\tgoto error_free_key;\n\t\t}\n\n\t\tif (pkey->key_is_private)\n\t\t\tret = crypto_akcipher_set_priv_key(tfm, key, pkey->keylen);\n\t\telse\n\t\t\tret = crypto_akcipher_set_pub_key(tfm, key, pkey->keylen);\n\t\tif (ret)\n\t\t\tgoto error_free_tfm;\n\n\t\tksz = crypto_akcipher_maxsize(tfm);\n\t}\n\n\tret = -EINVAL;\n\n\t \n\tswitch (params->op) {\n\tcase kernel_pkey_encrypt:\n\t\tif (issig)\n\t\t\tbreak;\n\t\tret = crypto_akcipher_sync_encrypt(tfm, in, params->in_len,\n\t\t\t\t\t\t   out, params->out_len);\n\t\tbreak;\n\tcase kernel_pkey_decrypt:\n\t\tif (issig)\n\t\t\tbreak;\n\t\tret = crypto_akcipher_sync_decrypt(tfm, in, params->in_len,\n\t\t\t\t\t\t   out, params->out_len);\n\t\tbreak;\n\tcase kernel_pkey_sign:\n\t\tif (!issig)\n\t\t\tbreak;\n\t\tret = crypto_sig_sign(sig, in, params->in_len,\n\t\t\t\t      out, params->out_len);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (ret == 0)\n\t\tret = ksz;\n\nerror_free_tfm:\n\tif (issig)\n\t\tcrypto_free_sig(sig);\n\telse\n\t\tcrypto_free_akcipher(tfm);\nerror_free_key:\n\tkfree_sensitive(key);\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nint public_key_verify_signature(const struct public_key *pkey,\n\t\t\t\tconst struct public_key_signature *sig)\n{\n\tchar alg_name[CRYPTO_MAX_ALG_NAME];\n\tstruct crypto_sig *tfm;\n\tchar *key, *ptr;\n\tbool issig;\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tBUG_ON(!pkey);\n\tBUG_ON(!sig);\n\tBUG_ON(!sig->s);\n\n\t \n\tif (sig->pkey_algo) {\n\t\tif (strcmp(pkey->pkey_algo, sig->pkey_algo) != 0 &&\n\t\t    (strncmp(pkey->pkey_algo, \"ecdsa-\", 6) != 0 ||\n\t\t     strcmp(sig->pkey_algo, \"ecdsa\") != 0))\n\t\t\treturn -EKEYREJECTED;\n\t}\n\n\tret = software_key_determine_akcipher(pkey, sig->encoding,\n\t\t\t\t\t      sig->hash_algo, alg_name,\n\t\t\t\t\t      &issig, kernel_pkey_verify);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttfm = crypto_alloc_sig(alg_name, 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\tkey = kmalloc(pkey->keylen + sizeof(u32) * 2 + pkey->paramlen,\n\t\t      GFP_KERNEL);\n\tif (!key) {\n\t\tret = -ENOMEM;\n\t\tgoto error_free_tfm;\n\t}\n\n\tmemcpy(key, pkey->key, pkey->keylen);\n\tptr = key + pkey->keylen;\n\tptr = pkey_pack_u32(ptr, pkey->algo);\n\tptr = pkey_pack_u32(ptr, pkey->paramlen);\n\tmemcpy(ptr, pkey->params, pkey->paramlen);\n\n\tif (pkey->key_is_private)\n\t\tret = crypto_sig_set_privkey(tfm, key, pkey->keylen);\n\telse\n\t\tret = crypto_sig_set_pubkey(tfm, key, pkey->keylen);\n\tif (ret)\n\t\tgoto error_free_key;\n\n\tret = crypto_sig_verify(tfm, sig->s, sig->s_size,\n\t\t\t\tsig->digest, sig->digest_size);\n\nerror_free_key:\n\tkfree_sensitive(key);\nerror_free_tfm:\n\tcrypto_free_sig(tfm);\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\tif (WARN_ON_ONCE(ret > 0))\n\t\tret = -EINVAL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(public_key_verify_signature);\n\nstatic int public_key_verify_signature_2(const struct key *key,\n\t\t\t\t\t const struct public_key_signature *sig)\n{\n\tconst struct public_key *pk = key->payload.data[asym_crypto];\n\treturn public_key_verify_signature(pk, sig);\n}\n\n \nstruct asymmetric_key_subtype public_key_subtype = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"public_key\",\n\t.name_len\t\t= sizeof(\"public_key\") - 1,\n\t.describe\t\t= public_key_describe,\n\t.destroy\t\t= public_key_destroy,\n\t.query\t\t\t= software_key_query,\n\t.eds_op\t\t\t= software_key_eds_op,\n\t.verify_signature\t= public_key_verify_signature_2,\n};\nEXPORT_SYMBOL_GPL(public_key_subtype);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}