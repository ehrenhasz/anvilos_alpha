{
  "module_name": "pkcs8_parser.c",
  "hash_id": "130c61ad513b82b183cdd1905a2c192d4e77fe392bda4d58fd62ef4445027922",
  "original_prompt": "Ingested from linux-6.6.14/crypto/asymmetric_keys/pkcs8_parser.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"PKCS8: \"fmt\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/oid_registry.h>\n#include <keys/asymmetric-subtype.h>\n#include <keys/asymmetric-parser.h>\n#include <crypto/public_key.h>\n#include \"pkcs8.asn1.h\"\n\nstruct pkcs8_parse_context {\n\tstruct public_key *pub;\n\tunsigned long\tdata;\t\t\t \n\tenum OID\tlast_oid;\t\t \n\tenum OID\talgo_oid;\t\t \n\tu32\t\tkey_size;\n\tconst void\t*key;\n};\n\n \nint pkcs8_note_OID(void *context, size_t hdrlen,\n\t\t   unsigned char tag,\n\t\t   const void *value, size_t vlen)\n{\n\tstruct pkcs8_parse_context *ctx = context;\n\n\tctx->last_oid = look_up_OID(value, vlen);\n\tif (ctx->last_oid == OID__NR) {\n\t\tchar buffer[50];\n\n\t\tsprint_oid(value, vlen, buffer, sizeof(buffer));\n\t\tpr_info(\"Unknown OID: [%lu] %s\\n\",\n\t\t\t(unsigned long)value - ctx->data, buffer);\n\t}\n\treturn 0;\n}\n\n \nint pkcs8_note_version(void *context, size_t hdrlen,\n\t\t       unsigned char tag,\n\t\t       const void *value, size_t vlen)\n{\n\tif (vlen != 1 || ((const u8 *)value)[0] != 0) {\n\t\tpr_warn(\"Unsupported PKCS#8 version\\n\");\n\t\treturn -EBADMSG;\n\t}\n\treturn 0;\n}\n\n \nint pkcs8_note_algo(void *context, size_t hdrlen,\n\t\t    unsigned char tag,\n\t\t    const void *value, size_t vlen)\n{\n\tstruct pkcs8_parse_context *ctx = context;\n\n\tif (ctx->last_oid != OID_rsaEncryption)\n\t\treturn -ENOPKG;\n\n\tctx->pub->pkey_algo = \"rsa\";\n\treturn 0;\n}\n\n \nint pkcs8_note_key(void *context, size_t hdrlen,\n\t\t   unsigned char tag,\n\t\t   const void *value, size_t vlen)\n{\n\tstruct pkcs8_parse_context *ctx = context;\n\n\tctx->key = value;\n\tctx->key_size = vlen;\n\treturn 0;\n}\n\n \nstatic struct public_key *pkcs8_parse(const void *data, size_t datalen)\n{\n\tstruct pkcs8_parse_context ctx;\n\tstruct public_key *pub;\n\tlong ret;\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\n\tret = -ENOMEM;\n\tctx.pub = kzalloc(sizeof(struct public_key), GFP_KERNEL);\n\tif (!ctx.pub)\n\t\tgoto error;\n\n\tctx.data = (unsigned long)data;\n\n\t \n\tret = asn1_ber_decoder(&pkcs8_decoder, &ctx, data, datalen);\n\tif (ret < 0)\n\t\tgoto error_decode;\n\n\tret = -ENOMEM;\n\tpub = ctx.pub;\n\tpub->key = kmemdup(ctx.key, ctx.key_size, GFP_KERNEL);\n\tif (!pub->key)\n\t\tgoto error_decode;\n\n\tpub->keylen = ctx.key_size;\n\tpub->key_is_private = true;\n\treturn pub;\n\nerror_decode:\n\tkfree(ctx.pub);\nerror:\n\treturn ERR_PTR(ret);\n}\n\n \nstatic int pkcs8_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct public_key *pub;\n\n\tpub = pkcs8_parse(prep->data, prep->datalen);\n\tif (IS_ERR(pub))\n\t\treturn PTR_ERR(pub);\n\n\tpr_devel(\"Cert Key Algo: %s\\n\", pub->pkey_algo);\n\tpub->id_type = \"PKCS8\";\n\n\t \n\t__module_get(public_key_subtype.owner);\n\tprep->payload.data[asym_subtype] = &public_key_subtype;\n\tprep->payload.data[asym_key_ids] = NULL;\n\tprep->payload.data[asym_crypto] = pub;\n\tprep->payload.data[asym_auth] = NULL;\n\tprep->quotalen = 100;\n\treturn 0;\n}\n\nstatic struct asymmetric_key_parser pkcs8_key_parser = {\n\t.owner\t= THIS_MODULE,\n\t.name\t= \"pkcs8\",\n\t.parse\t= pkcs8_key_preparse,\n};\n\n \nstatic int __init pkcs8_key_init(void)\n{\n\treturn register_asymmetric_key_parser(&pkcs8_key_parser);\n}\n\nstatic void __exit pkcs8_key_exit(void)\n{\n\tunregister_asymmetric_key_parser(&pkcs8_key_parser);\n}\n\nmodule_init(pkcs8_key_init);\nmodule_exit(pkcs8_key_exit);\n\nMODULE_DESCRIPTION(\"PKCS#8 certificate parser\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}