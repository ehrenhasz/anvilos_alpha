{
  "module_name": "x509_cert_parser.c",
  "hash_id": "3cbb4eb2bbbc597678b0091c5d6aa63163982626835a220fc8157a35c9babc0d",
  "original_prompt": "Ingested from linux-6.6.14/crypto/asymmetric_keys/x509_cert_parser.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"X.509: \"fmt\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/oid_registry.h>\n#include <crypto/public_key.h>\n#include \"x509_parser.h\"\n#include \"x509.asn1.h\"\n#include \"x509_akid.asn1.h\"\n\nstruct x509_parse_context {\n\tstruct x509_certificate\t*cert;\t\t \n\tunsigned long\tdata;\t\t\t \n\tconst void\t*key;\t\t\t \n\tsize_t\t\tkey_size;\t\t \n\tconst void\t*params;\t\t \n\tsize_t\t\tparams_size;\t\t \n\tenum OID\tkey_algo;\t\t \n\tenum OID\tlast_oid;\t\t \n\tenum OID\tsig_algo;\t\t \n\tu8\t\to_size;\t\t\t \n\tu8\t\tcn_size;\t\t \n\tu8\t\temail_size;\t\t \n\tu16\t\to_offset;\t\t \n\tu16\t\tcn_offset;\t\t \n\tu16\t\temail_offset;\t\t \n\tunsigned\traw_akid_size;\n\tconst void\t*raw_akid;\t\t \n\tconst void\t*akid_raw_issuer;\t \n\tunsigned\takid_raw_issuer_size;\n};\n\n \nvoid x509_free_certificate(struct x509_certificate *cert)\n{\n\tif (cert) {\n\t\tpublic_key_free(cert->pub);\n\t\tpublic_key_signature_free(cert->sig);\n\t\tkfree(cert->issuer);\n\t\tkfree(cert->subject);\n\t\tkfree(cert->id);\n\t\tkfree(cert->skid);\n\t\tkfree(cert);\n\t}\n}\nEXPORT_SYMBOL_GPL(x509_free_certificate);\n\n \nstruct x509_certificate *x509_cert_parse(const void *data, size_t datalen)\n{\n\tstruct x509_certificate *cert;\n\tstruct x509_parse_context *ctx;\n\tstruct asymmetric_key_id *kid;\n\tlong ret;\n\n\tret = -ENOMEM;\n\tcert = kzalloc(sizeof(struct x509_certificate), GFP_KERNEL);\n\tif (!cert)\n\t\tgoto error_no_cert;\n\tcert->pub = kzalloc(sizeof(struct public_key), GFP_KERNEL);\n\tif (!cert->pub)\n\t\tgoto error_no_ctx;\n\tcert->sig = kzalloc(sizeof(struct public_key_signature), GFP_KERNEL);\n\tif (!cert->sig)\n\t\tgoto error_no_ctx;\n\tctx = kzalloc(sizeof(struct x509_parse_context), GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto error_no_ctx;\n\n\tctx->cert = cert;\n\tctx->data = (unsigned long)data;\n\n\t \n\tret = asn1_ber_decoder(&x509_decoder, ctx, data, datalen);\n\tif (ret < 0)\n\t\tgoto error_decode;\n\n\t \n\tif (ctx->raw_akid) {\n\t\tpr_devel(\"AKID: %u %*phN\\n\",\n\t\t\t ctx->raw_akid_size, ctx->raw_akid_size, ctx->raw_akid);\n\t\tret = asn1_ber_decoder(&x509_akid_decoder, ctx,\n\t\t\t\t       ctx->raw_akid, ctx->raw_akid_size);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"Couldn't decode AuthKeyIdentifier\\n\");\n\t\t\tgoto error_decode;\n\t\t}\n\t}\n\n\tret = -ENOMEM;\n\tcert->pub->key = kmemdup(ctx->key, ctx->key_size, GFP_KERNEL);\n\tif (!cert->pub->key)\n\t\tgoto error_decode;\n\n\tcert->pub->keylen = ctx->key_size;\n\n\tcert->pub->params = kmemdup(ctx->params, ctx->params_size, GFP_KERNEL);\n\tif (!cert->pub->params)\n\t\tgoto error_decode;\n\n\tcert->pub->paramlen = ctx->params_size;\n\tcert->pub->algo = ctx->key_algo;\n\n\t \n\tret = x509_get_sig_params(cert);\n\tif (ret < 0)\n\t\tgoto error_decode;\n\n\t \n\tkid = asymmetric_key_generate_id(cert->raw_serial,\n\t\t\t\t\t cert->raw_serial_size,\n\t\t\t\t\t cert->raw_issuer,\n\t\t\t\t\t cert->raw_issuer_size);\n\tif (IS_ERR(kid)) {\n\t\tret = PTR_ERR(kid);\n\t\tgoto error_decode;\n\t}\n\tcert->id = kid;\n\n\t \n\tret = x509_check_for_self_signed(cert);\n\tif (ret < 0)\n\t\tgoto error_decode;\n\n\tkfree(ctx);\n\treturn cert;\n\nerror_decode:\n\tkfree(ctx);\nerror_no_ctx:\n\tx509_free_certificate(cert);\nerror_no_cert:\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(x509_cert_parse);\n\n \nint x509_note_OID(void *context, size_t hdrlen,\n\t     unsigned char tag,\n\t     const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\n\tctx->last_oid = look_up_OID(value, vlen);\n\tif (ctx->last_oid == OID__NR) {\n\t\tchar buffer[50];\n\t\tsprint_oid(value, vlen, buffer, sizeof(buffer));\n\t\tpr_debug(\"Unknown OID: [%lu] %s\\n\",\n\t\t\t (unsigned long)value - ctx->data, buffer);\n\t}\n\treturn 0;\n}\n\n \nint x509_note_tbs_certificate(void *context, size_t hdrlen,\n\t\t\t      unsigned char tag,\n\t\t\t      const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\n\tpr_debug(\"x509_note_tbs_certificate(,%zu,%02x,%ld,%zu)!\\n\",\n\t\t hdrlen, tag, (unsigned long)value - ctx->data, vlen);\n\n\tctx->cert->tbs = value - hdrlen;\n\tctx->cert->tbs_size = vlen + hdrlen;\n\treturn 0;\n}\n\n \nint x509_note_sig_algo(void *context, size_t hdrlen, unsigned char tag,\n\t\t       const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\n\tpr_debug(\"PubKey Algo: %u\\n\", ctx->last_oid);\n\n\tswitch (ctx->last_oid) {\n\tcase OID_md2WithRSAEncryption:\n\tcase OID_md3WithRSAEncryption:\n\tdefault:\n\t\treturn -ENOPKG;  \n\n\tcase OID_md4WithRSAEncryption:\n\t\tctx->cert->sig->hash_algo = \"md4\";\n\t\tgoto rsa_pkcs1;\n\n\tcase OID_sha1WithRSAEncryption:\n\t\tctx->cert->sig->hash_algo = \"sha1\";\n\t\tgoto rsa_pkcs1;\n\n\tcase OID_sha256WithRSAEncryption:\n\t\tctx->cert->sig->hash_algo = \"sha256\";\n\t\tgoto rsa_pkcs1;\n\n\tcase OID_sha384WithRSAEncryption:\n\t\tctx->cert->sig->hash_algo = \"sha384\";\n\t\tgoto rsa_pkcs1;\n\n\tcase OID_sha512WithRSAEncryption:\n\t\tctx->cert->sig->hash_algo = \"sha512\";\n\t\tgoto rsa_pkcs1;\n\n\tcase OID_sha224WithRSAEncryption:\n\t\tctx->cert->sig->hash_algo = \"sha224\";\n\t\tgoto rsa_pkcs1;\n\n\tcase OID_id_ecdsa_with_sha1:\n\t\tctx->cert->sig->hash_algo = \"sha1\";\n\t\tgoto ecdsa;\n\n\tcase OID_id_ecdsa_with_sha224:\n\t\tctx->cert->sig->hash_algo = \"sha224\";\n\t\tgoto ecdsa;\n\n\tcase OID_id_ecdsa_with_sha256:\n\t\tctx->cert->sig->hash_algo = \"sha256\";\n\t\tgoto ecdsa;\n\n\tcase OID_id_ecdsa_with_sha384:\n\t\tctx->cert->sig->hash_algo = \"sha384\";\n\t\tgoto ecdsa;\n\n\tcase OID_id_ecdsa_with_sha512:\n\t\tctx->cert->sig->hash_algo = \"sha512\";\n\t\tgoto ecdsa;\n\n\tcase OID_gost2012Signature256:\n\t\tctx->cert->sig->hash_algo = \"streebog256\";\n\t\tgoto ecrdsa;\n\n\tcase OID_gost2012Signature512:\n\t\tctx->cert->sig->hash_algo = \"streebog512\";\n\t\tgoto ecrdsa;\n\n\tcase OID_SM2_with_SM3:\n\t\tctx->cert->sig->hash_algo = \"sm3\";\n\t\tgoto sm2;\n\t}\n\nrsa_pkcs1:\n\tctx->cert->sig->pkey_algo = \"rsa\";\n\tctx->cert->sig->encoding = \"pkcs1\";\n\tctx->sig_algo = ctx->last_oid;\n\treturn 0;\necrdsa:\n\tctx->cert->sig->pkey_algo = \"ecrdsa\";\n\tctx->cert->sig->encoding = \"raw\";\n\tctx->sig_algo = ctx->last_oid;\n\treturn 0;\nsm2:\n\tctx->cert->sig->pkey_algo = \"sm2\";\n\tctx->cert->sig->encoding = \"raw\";\n\tctx->sig_algo = ctx->last_oid;\n\treturn 0;\necdsa:\n\tctx->cert->sig->pkey_algo = \"ecdsa\";\n\tctx->cert->sig->encoding = \"x962\";\n\tctx->sig_algo = ctx->last_oid;\n\treturn 0;\n}\n\n \nint x509_note_signature(void *context, size_t hdrlen,\n\t\t\tunsigned char tag,\n\t\t\tconst void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\n\tpr_debug(\"Signature: alg=%u, size=%zu\\n\", ctx->last_oid, vlen);\n\n\t \n\tif (ctx->last_oid != ctx->sig_algo) {\n\t\tpr_warn(\"signatureAlgorithm (%u) differs from tbsCertificate.signature (%u)\\n\",\n\t\t\tctx->last_oid, ctx->sig_algo);\n\t\treturn -EINVAL;\n\t}\n\n\tif (strcmp(ctx->cert->sig->pkey_algo, \"rsa\") == 0 ||\n\t    strcmp(ctx->cert->sig->pkey_algo, \"ecrdsa\") == 0 ||\n\t    strcmp(ctx->cert->sig->pkey_algo, \"sm2\") == 0 ||\n\t    strcmp(ctx->cert->sig->pkey_algo, \"ecdsa\") == 0) {\n\t\t \n\t\tif (vlen < 1 || *(const u8 *)value != 0)\n\t\t\treturn -EBADMSG;\n\n\t\tvalue++;\n\t\tvlen--;\n\t}\n\n\tctx->cert->raw_sig = value;\n\tctx->cert->raw_sig_size = vlen;\n\treturn 0;\n}\n\n \nint x509_note_serial(void *context, size_t hdrlen,\n\t\t     unsigned char tag,\n\t\t     const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\tctx->cert->raw_serial = value;\n\tctx->cert->raw_serial_size = vlen;\n\treturn 0;\n}\n\n \nint x509_extract_name_segment(void *context, size_t hdrlen,\n\t\t\t      unsigned char tag,\n\t\t\t      const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\n\tswitch (ctx->last_oid) {\n\tcase OID_commonName:\n\t\tctx->cn_size = vlen;\n\t\tctx->cn_offset = (unsigned long)value - ctx->data;\n\t\tbreak;\n\tcase OID_organizationName:\n\t\tctx->o_size = vlen;\n\t\tctx->o_offset = (unsigned long)value - ctx->data;\n\t\tbreak;\n\tcase OID_email_address:\n\t\tctx->email_size = vlen;\n\t\tctx->email_offset = (unsigned long)value - ctx->data;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int x509_fabricate_name(struct x509_parse_context *ctx, size_t hdrlen,\n\t\t\t       unsigned char tag,\n\t\t\t       char **_name, size_t vlen)\n{\n\tconst void *name, *data = (const void *)ctx->data;\n\tsize_t namesize;\n\tchar *buffer;\n\n\tif (*_name)\n\t\treturn -EINVAL;\n\n\t \n\tif (!ctx->cn_size && !ctx->o_size && !ctx->email_size) {\n\t\tbuffer = kmalloc(1, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t\tbuffer[0] = 0;\n\t\tgoto done;\n\t}\n\n\tif (ctx->cn_size && ctx->o_size) {\n\t\t \n\t\tnamesize = ctx->cn_size;\n\t\tname = data + ctx->cn_offset;\n\t\tif (ctx->cn_size >= ctx->o_size &&\n\t\t    memcmp(data + ctx->cn_offset, data + ctx->o_offset,\n\t\t\t   ctx->o_size) == 0)\n\t\t\tgoto single_component;\n\t\tif (ctx->cn_size >= 7 &&\n\t\t    ctx->o_size >= 7 &&\n\t\t    memcmp(data + ctx->cn_offset, data + ctx->o_offset, 7) == 0)\n\t\t\tgoto single_component;\n\n\t\tbuffer = kmalloc(ctx->o_size + 2 + ctx->cn_size + 1,\n\t\t\t\t GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(buffer,\n\t\t       data + ctx->o_offset, ctx->o_size);\n\t\tbuffer[ctx->o_size + 0] = ':';\n\t\tbuffer[ctx->o_size + 1] = ' ';\n\t\tmemcpy(buffer + ctx->o_size + 2,\n\t\t       data + ctx->cn_offset, ctx->cn_size);\n\t\tbuffer[ctx->o_size + 2 + ctx->cn_size] = 0;\n\t\tgoto done;\n\n\t} else if (ctx->cn_size) {\n\t\tnamesize = ctx->cn_size;\n\t\tname = data + ctx->cn_offset;\n\t} else if (ctx->o_size) {\n\t\tnamesize = ctx->o_size;\n\t\tname = data + ctx->o_offset;\n\t} else {\n\t\tnamesize = ctx->email_size;\n\t\tname = data + ctx->email_offset;\n\t}\n\nsingle_component:\n\tbuffer = kmalloc(namesize + 1, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tmemcpy(buffer, name, namesize);\n\tbuffer[namesize] = 0;\n\ndone:\n\t*_name = buffer;\n\tctx->cn_size = 0;\n\tctx->o_size = 0;\n\tctx->email_size = 0;\n\treturn 0;\n}\n\nint x509_note_issuer(void *context, size_t hdrlen,\n\t\t     unsigned char tag,\n\t\t     const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\tstruct asymmetric_key_id *kid;\n\n\tctx->cert->raw_issuer = value;\n\tctx->cert->raw_issuer_size = vlen;\n\n\tif (!ctx->cert->sig->auth_ids[2]) {\n\t\tkid = asymmetric_key_generate_id(value, vlen, \"\", 0);\n\t\tif (IS_ERR(kid))\n\t\t\treturn PTR_ERR(kid);\n\t\tctx->cert->sig->auth_ids[2] = kid;\n\t}\n\n\treturn x509_fabricate_name(ctx, hdrlen, tag, &ctx->cert->issuer, vlen);\n}\n\nint x509_note_subject(void *context, size_t hdrlen,\n\t\t      unsigned char tag,\n\t\t      const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\tctx->cert->raw_subject = value;\n\tctx->cert->raw_subject_size = vlen;\n\treturn x509_fabricate_name(ctx, hdrlen, tag, &ctx->cert->subject, vlen);\n}\n\n \nint x509_note_params(void *context, size_t hdrlen,\n\t\t     unsigned char tag,\n\t\t     const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\n\t \n\tif (!ctx->cert->raw_subject || ctx->key)\n\t\treturn 0;\n\tctx->params = value - hdrlen;\n\tctx->params_size = vlen + hdrlen;\n\treturn 0;\n}\n\n \nint x509_extract_key_data(void *context, size_t hdrlen,\n\t\t\t  unsigned char tag,\n\t\t\t  const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\tenum OID oid;\n\n\tctx->key_algo = ctx->last_oid;\n\tswitch (ctx->last_oid) {\n\tcase OID_rsaEncryption:\n\t\tctx->cert->pub->pkey_algo = \"rsa\";\n\t\tbreak;\n\tcase OID_gost2012PKey256:\n\tcase OID_gost2012PKey512:\n\t\tctx->cert->pub->pkey_algo = \"ecrdsa\";\n\t\tbreak;\n\tcase OID_sm2:\n\t\tctx->cert->pub->pkey_algo = \"sm2\";\n\t\tbreak;\n\tcase OID_id_ecPublicKey:\n\t\tif (parse_OID(ctx->params, ctx->params_size, &oid) != 0)\n\t\t\treturn -EBADMSG;\n\n\t\tswitch (oid) {\n\t\tcase OID_sm2:\n\t\t\tctx->cert->pub->pkey_algo = \"sm2\";\n\t\t\tbreak;\n\t\tcase OID_id_prime192v1:\n\t\t\tctx->cert->pub->pkey_algo = \"ecdsa-nist-p192\";\n\t\t\tbreak;\n\t\tcase OID_id_prime256v1:\n\t\t\tctx->cert->pub->pkey_algo = \"ecdsa-nist-p256\";\n\t\t\tbreak;\n\t\tcase OID_id_ansip384r1:\n\t\t\tctx->cert->pub->pkey_algo = \"ecdsa-nist-p384\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOPKG;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPKG;\n\t}\n\n\t \n\tif (vlen < 1 || *(const u8 *)value != 0)\n\t\treturn -EBADMSG;\n\tctx->key = value + 1;\n\tctx->key_size = vlen - 1;\n\treturn 0;\n}\n\n \n#define SEQ_TAG_KEYID (ASN1_CONT << 6)\n\n \nint x509_process_extension(void *context, size_t hdrlen,\n\t\t\t   unsigned char tag,\n\t\t\t   const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\tstruct asymmetric_key_id *kid;\n\tconst unsigned char *v = value;\n\n\tpr_debug(\"Extension: %u\\n\", ctx->last_oid);\n\n\tif (ctx->last_oid == OID_subjectKeyIdentifier) {\n\t\t \n\t\tif (ctx->cert->skid || vlen < 3)\n\t\t\treturn -EBADMSG;\n\t\tif (v[0] != ASN1_OTS || v[1] != vlen - 2)\n\t\t\treturn -EBADMSG;\n\t\tv += 2;\n\t\tvlen -= 2;\n\n\t\tctx->cert->raw_skid_size = vlen;\n\t\tctx->cert->raw_skid = v;\n\t\tkid = asymmetric_key_generate_id(v, vlen, \"\", 0);\n\t\tif (IS_ERR(kid))\n\t\t\treturn PTR_ERR(kid);\n\t\tctx->cert->skid = kid;\n\t\tpr_debug(\"subjkeyid %*phN\\n\", kid->len, kid->data);\n\t\treturn 0;\n\t}\n\n\tif (ctx->last_oid == OID_keyUsage) {\n\t\t \n\t\tif (v[0] != ASN1_BTS)\n\t\t\treturn -EBADMSG;\n\t\tif (vlen < 4)\n\t\t\treturn -EBADMSG;\n\t\tif (v[2] >= 8)\n\t\t\treturn -EBADMSG;\n\t\tif (v[3] & 0x80)\n\t\t\tctx->cert->pub->key_eflags |= 1 << KEY_EFLAG_DIGITALSIG;\n\t\tif (v[1] == 0x02 && v[2] <= 2 && (v[3] & 0x04))\n\t\t\tctx->cert->pub->key_eflags |= 1 << KEY_EFLAG_KEYCERTSIGN;\n\t\telse if (vlen > 4 && v[1] == 0x03 && (v[3] & 0x04))\n\t\t\tctx->cert->pub->key_eflags |= 1 << KEY_EFLAG_KEYCERTSIGN;\n\t\treturn 0;\n\t}\n\n\tif (ctx->last_oid == OID_authorityKeyIdentifier) {\n\t\t \n\t\tctx->raw_akid = v;\n\t\tctx->raw_akid_size = vlen;\n\t\treturn 0;\n\t}\n\n\tif (ctx->last_oid == OID_basicConstraints) {\n\t\t \n\t\tif (v[0] != (ASN1_CONS_BIT | ASN1_SEQ))\n\t\t\treturn -EBADMSG;\n\t\tif (vlen < 2)\n\t\t\treturn -EBADMSG;\n\t\tif (v[1] != vlen - 2)\n\t\t\treturn -EBADMSG;\n\t\tif (vlen >= 4 && v[1] != 0 && v[2] == ASN1_BOOL && v[3] == 1)\n\t\t\tctx->cert->pub->key_eflags |= 1 << KEY_EFLAG_CA;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n \nint x509_decode_time(time64_t *_t,  size_t hdrlen,\n\t\t     unsigned char tag,\n\t\t     const unsigned char *value, size_t vlen)\n{\n\tstatic const unsigned char month_lengths[] = { 31, 28, 31, 30, 31, 30,\n\t\t\t\t\t\t       31, 31, 30, 31, 30, 31 };\n\tconst unsigned char *p = value;\n\tunsigned year, mon, day, hour, min, sec, mon_len;\n\n#define dec2bin(X) ({ unsigned char x = (X) - '0'; if (x > 9) goto invalid_time; x; })\n#define DD2bin(P) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })\n\n\tif (tag == ASN1_UNITIM) {\n\t\t \n\t\tif (vlen != 13)\n\t\t\tgoto unsupported_time;\n\t\tyear = DD2bin(p);\n\t\tif (year >= 50)\n\t\t\tyear += 1900;\n\t\telse\n\t\t\tyear += 2000;\n\t} else if (tag == ASN1_GENTIM) {\n\t\t \n\t\tif (vlen != 15)\n\t\t\tgoto unsupported_time;\n\t\tyear = DD2bin(p) * 100 + DD2bin(p);\n\t\tif (year >= 1950 && year <= 2049)\n\t\t\tgoto invalid_time;\n\t} else {\n\t\tgoto unsupported_time;\n\t}\n\n\tmon  = DD2bin(p);\n\tday = DD2bin(p);\n\thour = DD2bin(p);\n\tmin  = DD2bin(p);\n\tsec  = DD2bin(p);\n\n\tif (*p != 'Z')\n\t\tgoto unsupported_time;\n\n\tif (year < 1970 ||\n\t    mon < 1 || mon > 12)\n\t\tgoto invalid_time;\n\n\tmon_len = month_lengths[mon - 1];\n\tif (mon == 2) {\n\t\tif (year % 4 == 0) {\n\t\t\tmon_len = 29;\n\t\t\tif (year % 100 == 0) {\n\t\t\t\tmon_len = 28;\n\t\t\t\tif (year % 400 == 0)\n\t\t\t\t\tmon_len = 29;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (day < 1 || day > mon_len ||\n\t    hour > 24 ||  \n\t    min > 59 ||\n\t    sec > 60)  \n\t\tgoto invalid_time;\n\n\t*_t = mktime64(year, mon, day, hour, min, sec);\n\treturn 0;\n\nunsupported_time:\n\tpr_debug(\"Got unsupported time [tag %02x]: '%*phN'\\n\",\n\t\t tag, (int)vlen, value);\n\treturn -EBADMSG;\ninvalid_time:\n\tpr_debug(\"Got invalid time [tag %02x]: '%*phN'\\n\",\n\t\t tag, (int)vlen, value);\n\treturn -EBADMSG;\n}\nEXPORT_SYMBOL_GPL(x509_decode_time);\n\nint x509_note_not_before(void *context, size_t hdrlen,\n\t\t\t unsigned char tag,\n\t\t\t const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\treturn x509_decode_time(&ctx->cert->valid_from, hdrlen, tag, value, vlen);\n}\n\nint x509_note_not_after(void *context, size_t hdrlen,\n\t\t\tunsigned char tag,\n\t\t\tconst void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\treturn x509_decode_time(&ctx->cert->valid_to, hdrlen, tag, value, vlen);\n}\n\n \nint x509_akid_note_kid(void *context, size_t hdrlen,\n\t\t       unsigned char tag,\n\t\t       const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\tstruct asymmetric_key_id *kid;\n\n\tpr_debug(\"AKID: keyid: %*phN\\n\", (int)vlen, value);\n\n\tif (ctx->cert->sig->auth_ids[1])\n\t\treturn 0;\n\n\tkid = asymmetric_key_generate_id(value, vlen, \"\", 0);\n\tif (IS_ERR(kid))\n\t\treturn PTR_ERR(kid);\n\tpr_debug(\"authkeyid %*phN\\n\", kid->len, kid->data);\n\tctx->cert->sig->auth_ids[1] = kid;\n\treturn 0;\n}\n\n \nint x509_akid_note_name(void *context, size_t hdrlen,\n\t\t\tunsigned char tag,\n\t\t\tconst void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\n\tpr_debug(\"AKID: name: %*phN\\n\", (int)vlen, value);\n\n\tctx->akid_raw_issuer = value;\n\tctx->akid_raw_issuer_size = vlen;\n\treturn 0;\n}\n\n \nint x509_akid_note_serial(void *context, size_t hdrlen,\n\t\t\t  unsigned char tag,\n\t\t\t  const void *value, size_t vlen)\n{\n\tstruct x509_parse_context *ctx = context;\n\tstruct asymmetric_key_id *kid;\n\n\tpr_debug(\"AKID: serial: %*phN\\n\", (int)vlen, value);\n\n\tif (!ctx->akid_raw_issuer || ctx->cert->sig->auth_ids[0])\n\t\treturn 0;\n\n\tkid = asymmetric_key_generate_id(value,\n\t\t\t\t\t vlen,\n\t\t\t\t\t ctx->akid_raw_issuer,\n\t\t\t\t\t ctx->akid_raw_issuer_size);\n\tif (IS_ERR(kid))\n\t\treturn PTR_ERR(kid);\n\n\tpr_debug(\"authkeyid %*phN\\n\", kid->len, kid->data);\n\tctx->cert->sig->auth_ids[0] = kid;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}