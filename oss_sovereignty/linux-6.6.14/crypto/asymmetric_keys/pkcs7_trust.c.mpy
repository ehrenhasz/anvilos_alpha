{
  "module_name": "pkcs7_trust.c",
  "hash_id": "100d8528860ef9036f78079718e6abf0a10ec897517b576ee4a51b04a7865475",
  "original_prompt": "Ingested from linux-6.6.14/crypto/asymmetric_keys/pkcs7_trust.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"PKCS7: \"fmt\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/asn1.h>\n#include <linux/key.h>\n#include <keys/asymmetric-type.h>\n#include <crypto/public_key.h>\n#include \"pkcs7_parser.h\"\n\n \nstatic int pkcs7_validate_trust_one(struct pkcs7_message *pkcs7,\n\t\t\t\t    struct pkcs7_signed_info *sinfo,\n\t\t\t\t    struct key *trust_keyring)\n{\n\tstruct public_key_signature *sig = sinfo->sig;\n\tstruct x509_certificate *x509, *last = NULL, *p;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\",%u,\", sinfo->index);\n\n\tif (sinfo->unsupported_crypto) {\n\t\tkleave(\" = -ENOPKG [cached]\");\n\t\treturn -ENOPKG;\n\t}\n\n\tfor (x509 = sinfo->signer; x509; x509 = x509->signer) {\n\t\tif (x509->seen) {\n\t\t\tif (x509->verified)\n\t\t\t\tgoto verified;\n\t\t\tkleave(\" = -ENOKEY [cached]\");\n\t\t\treturn -ENOKEY;\n\t\t}\n\t\tx509->seen = true;\n\n\t\t \n\t\tkey = find_asymmetric_key(trust_keyring,\n\t\t\t\t\t  x509->id, x509->skid, NULL, false);\n\t\tif (!IS_ERR(key)) {\n\t\t\t \n\t\t\tpr_devel(\"sinfo %u: Cert %u as key %x\\n\",\n\t\t\t\t sinfo->index, x509->index, key_serial(key));\n\t\t\tgoto matched;\n\t\t}\n\t\tif (key == ERR_PTR(-ENOMEM))\n\t\t\treturn -ENOMEM;\n\n\t\t  \n\t\tif (x509->signer == x509) {\n\t\t\tkleave(\" = -ENOKEY [unknown self-signed]\");\n\t\t\treturn -ENOKEY;\n\t\t}\n\n\t\tmight_sleep();\n\t\tlast = x509;\n\t\tsig = last->sig;\n\t}\n\n\t \n\tif (last && (last->sig->auth_ids[0] || last->sig->auth_ids[1])) {\n\t\tkey = find_asymmetric_key(trust_keyring,\n\t\t\t\t\t  last->sig->auth_ids[0],\n\t\t\t\t\t  last->sig->auth_ids[1],\n\t\t\t\t\t  NULL, false);\n\t\tif (!IS_ERR(key)) {\n\t\t\tx509 = last;\n\t\t\tpr_devel(\"sinfo %u: Root cert %u signer is key %x\\n\",\n\t\t\t\t sinfo->index, x509->index, key_serial(key));\n\t\t\tgoto matched;\n\t\t}\n\t\tif (PTR_ERR(key) != -ENOKEY)\n\t\t\treturn PTR_ERR(key);\n\t}\n\n\t \n\tkey = find_asymmetric_key(trust_keyring,\n\t\t\t\t  sinfo->sig->auth_ids[0], NULL, NULL, false);\n\tif (!IS_ERR(key)) {\n\t\tpr_devel(\"sinfo %u: Direct signer is key %x\\n\",\n\t\t\t sinfo->index, key_serial(key));\n\t\tx509 = NULL;\n\t\tsig = sinfo->sig;\n\t\tgoto matched;\n\t}\n\tif (PTR_ERR(key) != -ENOKEY)\n\t\treturn PTR_ERR(key);\n\n\tkleave(\" = -ENOKEY [no backref]\");\n\treturn -ENOKEY;\n\nmatched:\n\tret = verify_signature(key, sig);\n\tkey_put(key);\n\tif (ret < 0) {\n\t\tif (ret == -ENOMEM)\n\t\t\treturn ret;\n\t\tkleave(\" = -EKEYREJECTED [verify %d]\", ret);\n\t\treturn -EKEYREJECTED;\n\t}\n\nverified:\n\tif (x509) {\n\t\tx509->verified = true;\n\t\tfor (p = sinfo->signer; p != x509; p = p->signer)\n\t\t\tp->verified = true;\n\t}\n\tkleave(\" = 0\");\n\treturn 0;\n}\n\n \nint pkcs7_validate_trust(struct pkcs7_message *pkcs7,\n\t\t\t struct key *trust_keyring)\n{\n\tstruct pkcs7_signed_info *sinfo;\n\tstruct x509_certificate *p;\n\tint cached_ret = -ENOKEY;\n\tint ret;\n\n\tfor (p = pkcs7->certs; p; p = p->next)\n\t\tp->seen = false;\n\n\tfor (sinfo = pkcs7->signed_infos; sinfo; sinfo = sinfo->next) {\n\t\tret = pkcs7_validate_trust_one(pkcs7, sinfo, trust_keyring);\n\t\tswitch (ret) {\n\t\tcase -ENOKEY:\n\t\t\tcontinue;\n\t\tcase -ENOPKG:\n\t\t\tif (cached_ret == -ENOKEY)\n\t\t\t\tcached_ret = -ENOPKG;\n\t\t\tcontinue;\n\t\tcase 0:\n\t\t\tcached_ret = 0;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn cached_ret;\n}\nEXPORT_SYMBOL_GPL(pkcs7_validate_trust);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}