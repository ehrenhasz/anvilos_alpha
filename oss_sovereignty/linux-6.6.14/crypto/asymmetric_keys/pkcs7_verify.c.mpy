{
  "module_name": "pkcs7_verify.c",
  "hash_id": "7712110b3e45c650e2a662ea6b271e669a714ef3ae488513491ab13a7cd9e3f1",
  "original_prompt": "Ingested from linux-6.6.14/crypto/asymmetric_keys/pkcs7_verify.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"PKCS7: \"fmt\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/asn1.h>\n#include <crypto/hash.h>\n#include <crypto/hash_info.h>\n#include <crypto/public_key.h>\n#include \"pkcs7_parser.h\"\n\n \nstatic int pkcs7_digest(struct pkcs7_message *pkcs7,\n\t\t\tstruct pkcs7_signed_info *sinfo)\n{\n\tstruct public_key_signature *sig = sinfo->sig;\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *desc;\n\tsize_t desc_size;\n\tint ret;\n\n\tkenter(\",%u,%s\", sinfo->index, sinfo->sig->hash_algo);\n\n\t \n\tif (sig->digest)\n\t\treturn 0;\n\n\tif (!sinfo->sig->hash_algo)\n\t\treturn -ENOPKG;\n\n\t \n\ttfm = crypto_alloc_shash(sinfo->sig->hash_algo, 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn (PTR_ERR(tfm) == -ENOENT) ? -ENOPKG : PTR_ERR(tfm);\n\n\tdesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\n\tsig->digest_size = crypto_shash_digestsize(tfm);\n\n\tret = -ENOMEM;\n\tsig->digest = kmalloc(sig->digest_size, GFP_KERNEL);\n\tif (!sig->digest)\n\t\tgoto error_no_desc;\n\n\tdesc = kzalloc(desc_size, GFP_KERNEL);\n\tif (!desc)\n\t\tgoto error_no_desc;\n\n\tdesc->tfm   = tfm;\n\n\t \n\tret = crypto_shash_digest(desc, pkcs7->data, pkcs7->data_len,\n\t\t\t\t  sig->digest);\n\tif (ret < 0)\n\t\tgoto error;\n\tpr_devel(\"MsgDigest = [%*ph]\\n\", 8, sig->digest);\n\n\t \n\tif (sinfo->authattrs) {\n\t\tu8 tag;\n\n\t\tif (!sinfo->msgdigest) {\n\t\t\tpr_warn(\"Sig %u: No messageDigest\\n\", sinfo->index);\n\t\t\tret = -EKEYREJECTED;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sinfo->msgdigest_len != sig->digest_size) {\n\t\t\tpr_warn(\"Sig %u: Invalid digest size (%u)\\n\",\n\t\t\t\tsinfo->index, sinfo->msgdigest_len);\n\t\t\tret = -EBADMSG;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (memcmp(sig->digest, sinfo->msgdigest,\n\t\t\t   sinfo->msgdigest_len) != 0) {\n\t\t\tpr_warn(\"Sig %u: Message digest doesn't match\\n\",\n\t\t\t\tsinfo->index);\n\t\t\tret = -EKEYREJECTED;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tmemset(sig->digest, 0, sig->digest_size);\n\n\t\tret = crypto_shash_init(desc);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\ttag = ASN1_CONS_BIT | ASN1_SET;\n\t\tret = crypto_shash_update(desc, &tag, 1);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tret = crypto_shash_finup(desc, sinfo->authattrs,\n\t\t\t\t\t sinfo->authattrs_len, sig->digest);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tpr_devel(\"AADigest = [%*ph]\\n\", 8, sig->digest);\n\t}\n\nerror:\n\tkfree(desc);\nerror_no_desc:\n\tcrypto_free_shash(tfm);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\nint pkcs7_get_digest(struct pkcs7_message *pkcs7, const u8 **buf, u32 *len,\n\t\t     enum hash_algo *hash_algo)\n{\n\tstruct pkcs7_signed_info *sinfo = pkcs7->signed_infos;\n\tint i, ret;\n\n\t \n\tif (sinfo == NULL || sinfo->next != NULL)\n\t\treturn -EBADMSG;\n\n\tret = pkcs7_digest(pkcs7, sinfo);\n\tif (ret)\n\t\treturn ret;\n\n\t*buf = sinfo->sig->digest;\n\t*len = sinfo->sig->digest_size;\n\n\ti = match_string(hash_algo_name, HASH_ALGO__LAST,\n\t\t\t sinfo->sig->hash_algo);\n\tif (i >= 0)\n\t\t*hash_algo = i;\n\n\treturn 0;\n}\n\n \nstatic int pkcs7_find_key(struct pkcs7_message *pkcs7,\n\t\t\t  struct pkcs7_signed_info *sinfo)\n{\n\tstruct x509_certificate *x509;\n\tunsigned certix = 1;\n\n\tkenter(\"%u\", sinfo->index);\n\n\tfor (x509 = pkcs7->certs; x509; x509 = x509->next, certix++) {\n\t\t \n\t\tif (!asymmetric_key_id_same(x509->id, sinfo->sig->auth_ids[0]))\n\t\t\tcontinue;\n\t\tpr_devel(\"Sig %u: Found cert serial match X.509[%u]\\n\",\n\t\t\t sinfo->index, certix);\n\n\t\tsinfo->signer = x509;\n\t\treturn 0;\n\t}\n\n\t \n\tpr_debug(\"Sig %u: Issuing X.509 cert not found (#%*phN)\\n\",\n\t\t sinfo->index,\n\t\t sinfo->sig->auth_ids[0]->len, sinfo->sig->auth_ids[0]->data);\n\treturn 0;\n}\n\n \nstatic int pkcs7_verify_sig_chain(struct pkcs7_message *pkcs7,\n\t\t\t\t  struct pkcs7_signed_info *sinfo)\n{\n\tstruct public_key_signature *sig;\n\tstruct x509_certificate *x509 = sinfo->signer, *p;\n\tstruct asymmetric_key_id *auth;\n\tint ret;\n\n\tkenter(\"\");\n\n\tfor (p = pkcs7->certs; p; p = p->next)\n\t\tp->seen = false;\n\n\tfor (;;) {\n\t\tpr_debug(\"verify %s: %*phN\\n\",\n\t\t\t x509->subject,\n\t\t\t x509->raw_serial_size, x509->raw_serial);\n\t\tx509->seen = true;\n\n\t\tif (x509->blacklisted) {\n\t\t\t \n\t\t\tsinfo->blacklisted = true;\n\t\t\tfor (p = sinfo->signer; p != x509; p = p->signer)\n\t\t\t\tp->blacklisted = true;\n\t\t\tpr_debug(\"- blacklisted\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tpr_debug(\"- issuer %s\\n\", x509->issuer);\n\t\tsig = x509->sig;\n\t\tif (sig->auth_ids[0])\n\t\t\tpr_debug(\"- authkeyid.id %*phN\\n\",\n\t\t\t\t sig->auth_ids[0]->len, sig->auth_ids[0]->data);\n\t\tif (sig->auth_ids[1])\n\t\t\tpr_debug(\"- authkeyid.skid %*phN\\n\",\n\t\t\t\t sig->auth_ids[1]->len, sig->auth_ids[1]->data);\n\n\t\tif (x509->self_signed) {\n\t\t\t \n\t\t\tif (x509->unsupported_sig)\n\t\t\t\tgoto unsupported_sig_in_x509;\n\t\t\tx509->signer = x509;\n\t\t\tpr_debug(\"- self-signed\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tauth = sig->auth_ids[0];\n\t\tif (auth) {\n\t\t\tpr_debug(\"- want %*phN\\n\", auth->len, auth->data);\n\t\t\tfor (p = pkcs7->certs; p; p = p->next) {\n\t\t\t\tpr_debug(\"- cmp [%u] %*phN\\n\",\n\t\t\t\t\t p->index, p->id->len, p->id->data);\n\t\t\t\tif (asymmetric_key_id_same(p->id, auth))\n\t\t\t\t\tgoto found_issuer_check_skid;\n\t\t\t}\n\t\t} else if (sig->auth_ids[1]) {\n\t\t\tauth = sig->auth_ids[1];\n\t\t\tpr_debug(\"- want %*phN\\n\", auth->len, auth->data);\n\t\t\tfor (p = pkcs7->certs; p; p = p->next) {\n\t\t\t\tif (!p->skid)\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_debug(\"- cmp [%u] %*phN\\n\",\n\t\t\t\t\t p->index, p->skid->len, p->skid->data);\n\t\t\t\tif (asymmetric_key_id_same(p->skid, auth))\n\t\t\t\t\tgoto found_issuer;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpr_debug(\"- top\\n\");\n\t\treturn 0;\n\n\tfound_issuer_check_skid:\n\t\t \n\t\tif (sig->auth_ids[1] &&\n\t\t    !asymmetric_key_id_same(p->skid, sig->auth_ids[1])) {\n\t\t\tpr_warn(\"Sig %u: X.509 chain contains auth-skid nonmatch (%u->%u)\\n\",\n\t\t\t\tsinfo->index, x509->index, p->index);\n\t\t\treturn -EKEYREJECTED;\n\t\t}\n\tfound_issuer:\n\t\tpr_debug(\"- subject %s\\n\", p->subject);\n\t\tif (p->seen) {\n\t\t\tpr_warn(\"Sig %u: X.509 chain contains loop\\n\",\n\t\t\t\tsinfo->index);\n\t\t\treturn 0;\n\t\t}\n\t\tret = public_key_verify_signature(p->pub, x509->sig);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tx509->signer = p;\n\t\tif (x509 == p) {\n\t\t\tpr_debug(\"- self-signed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tx509 = p;\n\t\tmight_sleep();\n\t}\n\nunsupported_sig_in_x509:\n\t \n\treturn 0;\n}\n\n \nstatic int pkcs7_verify_one(struct pkcs7_message *pkcs7,\n\t\t\t    struct pkcs7_signed_info *sinfo)\n{\n\tint ret;\n\n\tkenter(\",%u\", sinfo->index);\n\n\t \n\tret = pkcs7_digest(pkcs7, sinfo);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = pkcs7_find_key(pkcs7, sinfo);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!sinfo->signer)\n\t\treturn 0;\n\n\tpr_devel(\"Using X.509[%u] for sig %u\\n\",\n\t\t sinfo->signer->index, sinfo->index);\n\n\t \n\tif (test_bit(sinfo_has_signing_time, &sinfo->aa_set)) {\n\t\tif (sinfo->signing_time < sinfo->signer->valid_from ||\n\t\t    sinfo->signing_time > sinfo->signer->valid_to) {\n\t\t\tpr_warn(\"Message signed outside of X.509 validity window\\n\");\n\t\t\treturn -EKEYREJECTED;\n\t\t}\n\t}\n\n\t \n\tret = public_key_verify_signature(sinfo->signer->pub, sinfo->sig);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpr_devel(\"Verified signature %u\\n\", sinfo->index);\n\n\t \n\treturn pkcs7_verify_sig_chain(pkcs7, sinfo);\n}\n\n \nint pkcs7_verify(struct pkcs7_message *pkcs7,\n\t\t enum key_being_used_for usage)\n{\n\tstruct pkcs7_signed_info *sinfo;\n\tint actual_ret = -ENOPKG;\n\tint ret;\n\n\tkenter(\"\");\n\n\tswitch (usage) {\n\tcase VERIFYING_MODULE_SIGNATURE:\n\t\tif (pkcs7->data_type != OID_data) {\n\t\t\tpr_warn(\"Invalid module sig (not pkcs7-data)\\n\");\n\t\t\treturn -EKEYREJECTED;\n\t\t}\n\t\tif (pkcs7->have_authattrs) {\n\t\t\tpr_warn(\"Invalid module sig (has authattrs)\\n\");\n\t\t\treturn -EKEYREJECTED;\n\t\t}\n\t\tbreak;\n\tcase VERIFYING_FIRMWARE_SIGNATURE:\n\t\tif (pkcs7->data_type != OID_data) {\n\t\t\tpr_warn(\"Invalid firmware sig (not pkcs7-data)\\n\");\n\t\t\treturn -EKEYREJECTED;\n\t\t}\n\t\tif (!pkcs7->have_authattrs) {\n\t\t\tpr_warn(\"Invalid firmware sig (missing authattrs)\\n\");\n\t\t\treturn -EKEYREJECTED;\n\t\t}\n\t\tbreak;\n\tcase VERIFYING_KEXEC_PE_SIGNATURE:\n\t\tif (pkcs7->data_type != OID_msIndirectData) {\n\t\t\tpr_warn(\"Invalid kexec sig (not Authenticode)\\n\");\n\t\t\treturn -EKEYREJECTED;\n\t\t}\n\t\t \n\t\tbreak;\n\tcase VERIFYING_UNSPECIFIED_SIGNATURE:\n\t\tif (pkcs7->data_type != OID_data) {\n\t\t\tpr_warn(\"Invalid unspecified sig (not pkcs7-data)\\n\");\n\t\t\treturn -EKEYREJECTED;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (sinfo = pkcs7->signed_infos; sinfo; sinfo = sinfo->next) {\n\t\tret = pkcs7_verify_one(pkcs7, sinfo);\n\t\tif (sinfo->blacklisted) {\n\t\t\tif (actual_ret == -ENOPKG)\n\t\t\t\tactual_ret = -EKEYREJECTED;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENOPKG) {\n\t\t\t\tsinfo->unsupported_crypto = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkleave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tactual_ret = 0;\n\t}\n\n\tkleave(\" = %d\", actual_ret);\n\treturn actual_ret;\n}\nEXPORT_SYMBOL_GPL(pkcs7_verify);\n\n \nint pkcs7_supply_detached_data(struct pkcs7_message *pkcs7,\n\t\t\t       const void *data, size_t datalen)\n{\n\tif (pkcs7->data) {\n\t\tpr_warn(\"Data already supplied\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpkcs7->data = data;\n\tpkcs7->data_len = datalen;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pkcs7_supply_detached_data);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}