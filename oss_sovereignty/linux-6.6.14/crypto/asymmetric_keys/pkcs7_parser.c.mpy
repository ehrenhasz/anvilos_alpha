{
  "module_name": "pkcs7_parser.c",
  "hash_id": "8e3364a7ea4b40afb2a71fcdd5fe6d1beb6e87c79c1efad0a8beff09d277d5b6",
  "original_prompt": "Ingested from linux-6.6.14/crypto/asymmetric_keys/pkcs7_parser.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"PKCS7: \"fmt\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/oid_registry.h>\n#include <crypto/public_key.h>\n#include \"pkcs7_parser.h\"\n#include \"pkcs7.asn1.h\"\n\nMODULE_DESCRIPTION(\"PKCS#7 parser\");\nMODULE_AUTHOR(\"Red Hat, Inc.\");\nMODULE_LICENSE(\"GPL\");\n\nstruct pkcs7_parse_context {\n\tstruct pkcs7_message\t*msg;\t\t \n\tstruct pkcs7_signed_info *sinfo;\t \n\tstruct pkcs7_signed_info **ppsinfo;\n\tstruct x509_certificate *certs;\t\t \n\tstruct x509_certificate **ppcerts;\n\tunsigned long\tdata;\t\t\t \n\tenum OID\tlast_oid;\t\t \n\tunsigned\tx509_index;\n\tunsigned\tsinfo_index;\n\tconst void\t*raw_serial;\n\tunsigned\traw_serial_size;\n\tunsigned\traw_issuer_size;\n\tconst void\t*raw_issuer;\n\tconst void\t*raw_skid;\n\tunsigned\traw_skid_size;\n\tbool\t\texpect_skid;\n};\n\n \nstatic void pkcs7_free_signed_info(struct pkcs7_signed_info *sinfo)\n{\n\tif (sinfo) {\n\t\tpublic_key_signature_free(sinfo->sig);\n\t\tkfree(sinfo);\n\t}\n}\n\n \nvoid pkcs7_free_message(struct pkcs7_message *pkcs7)\n{\n\tstruct x509_certificate *cert;\n\tstruct pkcs7_signed_info *sinfo;\n\n\tif (pkcs7) {\n\t\twhile (pkcs7->certs) {\n\t\t\tcert = pkcs7->certs;\n\t\t\tpkcs7->certs = cert->next;\n\t\t\tx509_free_certificate(cert);\n\t\t}\n\t\twhile (pkcs7->crl) {\n\t\t\tcert = pkcs7->crl;\n\t\t\tpkcs7->crl = cert->next;\n\t\t\tx509_free_certificate(cert);\n\t\t}\n\t\twhile (pkcs7->signed_infos) {\n\t\t\tsinfo = pkcs7->signed_infos;\n\t\t\tpkcs7->signed_infos = sinfo->next;\n\t\t\tpkcs7_free_signed_info(sinfo);\n\t\t}\n\t\tkfree(pkcs7);\n\t}\n}\nEXPORT_SYMBOL_GPL(pkcs7_free_message);\n\n \nstatic int pkcs7_check_authattrs(struct pkcs7_message *msg)\n{\n\tstruct pkcs7_signed_info *sinfo;\n\tbool want = false;\n\n\tsinfo = msg->signed_infos;\n\tif (!sinfo)\n\t\tgoto inconsistent;\n\n\tif (sinfo->authattrs) {\n\t\twant = true;\n\t\tmsg->have_authattrs = true;\n\t}\n\n\tfor (sinfo = sinfo->next; sinfo; sinfo = sinfo->next)\n\t\tif (!!sinfo->authattrs != want)\n\t\t\tgoto inconsistent;\n\treturn 0;\n\ninconsistent:\n\tpr_warn(\"Inconsistently supplied authAttrs\\n\");\n\treturn -EINVAL;\n}\n\n \nstruct pkcs7_message *pkcs7_parse_message(const void *data, size_t datalen)\n{\n\tstruct pkcs7_parse_context *ctx;\n\tstruct pkcs7_message *msg = ERR_PTR(-ENOMEM);\n\tint ret;\n\n\tctx = kzalloc(sizeof(struct pkcs7_parse_context), GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out_no_ctx;\n\tctx->msg = kzalloc(sizeof(struct pkcs7_message), GFP_KERNEL);\n\tif (!ctx->msg)\n\t\tgoto out_no_msg;\n\tctx->sinfo = kzalloc(sizeof(struct pkcs7_signed_info), GFP_KERNEL);\n\tif (!ctx->sinfo)\n\t\tgoto out_no_sinfo;\n\tctx->sinfo->sig = kzalloc(sizeof(struct public_key_signature),\n\t\t\t\t  GFP_KERNEL);\n\tif (!ctx->sinfo->sig)\n\t\tgoto out_no_sig;\n\n\tctx->data = (unsigned long)data;\n\tctx->ppcerts = &ctx->certs;\n\tctx->ppsinfo = &ctx->msg->signed_infos;\n\n\t \n\tret = asn1_ber_decoder(&pkcs7_decoder, ctx, data, datalen);\n\tif (ret < 0) {\n\t\tmsg = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tret = pkcs7_check_authattrs(ctx->msg);\n\tif (ret < 0) {\n\t\tmsg = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tmsg = ctx->msg;\n\tctx->msg = NULL;\n\nout:\n\twhile (ctx->certs) {\n\t\tstruct x509_certificate *cert = ctx->certs;\n\t\tctx->certs = cert->next;\n\t\tx509_free_certificate(cert);\n\t}\nout_no_sig:\n\tpkcs7_free_signed_info(ctx->sinfo);\nout_no_sinfo:\n\tpkcs7_free_message(ctx->msg);\nout_no_msg:\n\tkfree(ctx);\nout_no_ctx:\n\treturn msg;\n}\nEXPORT_SYMBOL_GPL(pkcs7_parse_message);\n\n \nint pkcs7_get_content_data(const struct pkcs7_message *pkcs7,\n\t\t\t   const void **_data, size_t *_data_len,\n\t\t\t   size_t *_headerlen)\n{\n\tif (!pkcs7->data)\n\t\treturn -ENODATA;\n\n\t*_data = pkcs7->data;\n\t*_data_len = pkcs7->data_len;\n\tif (_headerlen)\n\t\t*_headerlen = pkcs7->data_hdrlen;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pkcs7_get_content_data);\n\n \nint pkcs7_note_OID(void *context, size_t hdrlen,\n\t\t   unsigned char tag,\n\t\t   const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\n\tctx->last_oid = look_up_OID(value, vlen);\n\tif (ctx->last_oid == OID__NR) {\n\t\tchar buffer[50];\n\t\tsprint_oid(value, vlen, buffer, sizeof(buffer));\n\t\tprintk(\"PKCS7: Unknown OID: [%lu] %s\\n\",\n\t\t       (unsigned long)value - ctx->data, buffer);\n\t}\n\treturn 0;\n}\n\n \nint pkcs7_sig_note_digest_algo(void *context, size_t hdrlen,\n\t\t\t       unsigned char tag,\n\t\t\t       const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\n\tswitch (ctx->last_oid) {\n\tcase OID_md4:\n\t\tctx->sinfo->sig->hash_algo = \"md4\";\n\t\tbreak;\n\tcase OID_md5:\n\t\tctx->sinfo->sig->hash_algo = \"md5\";\n\t\tbreak;\n\tcase OID_sha1:\n\t\tctx->sinfo->sig->hash_algo = \"sha1\";\n\t\tbreak;\n\tcase OID_sha256:\n\t\tctx->sinfo->sig->hash_algo = \"sha256\";\n\t\tbreak;\n\tcase OID_sha384:\n\t\tctx->sinfo->sig->hash_algo = \"sha384\";\n\t\tbreak;\n\tcase OID_sha512:\n\t\tctx->sinfo->sig->hash_algo = \"sha512\";\n\t\tbreak;\n\tcase OID_sha224:\n\t\tctx->sinfo->sig->hash_algo = \"sha224\";\n\t\tbreak;\n\tcase OID_sm3:\n\t\tctx->sinfo->sig->hash_algo = \"sm3\";\n\t\tbreak;\n\tcase OID_gost2012Digest256:\n\t\tctx->sinfo->sig->hash_algo = \"streebog256\";\n\t\tbreak;\n\tcase OID_gost2012Digest512:\n\t\tctx->sinfo->sig->hash_algo = \"streebog512\";\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"Unsupported digest algo: %u\\n\", ctx->last_oid);\n\t\treturn -ENOPKG;\n\t}\n\treturn 0;\n}\n\n \nint pkcs7_sig_note_pkey_algo(void *context, size_t hdrlen,\n\t\t\t     unsigned char tag,\n\t\t\t     const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\n\tswitch (ctx->last_oid) {\n\tcase OID_rsaEncryption:\n\t\tctx->sinfo->sig->pkey_algo = \"rsa\";\n\t\tctx->sinfo->sig->encoding = \"pkcs1\";\n\t\tbreak;\n\tcase OID_id_ecdsa_with_sha1:\n\tcase OID_id_ecdsa_with_sha224:\n\tcase OID_id_ecdsa_with_sha256:\n\tcase OID_id_ecdsa_with_sha384:\n\tcase OID_id_ecdsa_with_sha512:\n\t\tctx->sinfo->sig->pkey_algo = \"ecdsa\";\n\t\tctx->sinfo->sig->encoding = \"x962\";\n\t\tbreak;\n\tcase OID_SM2_with_SM3:\n\t\tctx->sinfo->sig->pkey_algo = \"sm2\";\n\t\tctx->sinfo->sig->encoding = \"raw\";\n\t\tbreak;\n\tcase OID_gost2012PKey256:\n\tcase OID_gost2012PKey512:\n\t\tctx->sinfo->sig->pkey_algo = \"ecrdsa\";\n\t\tctx->sinfo->sig->encoding = \"raw\";\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"Unsupported pkey algo: %u\\n\", ctx->last_oid);\n\t\treturn -ENOPKG;\n\t}\n\treturn 0;\n}\n\n \nint pkcs7_check_content_type(void *context, size_t hdrlen,\n\t\t\t     unsigned char tag,\n\t\t\t     const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\n\tif (ctx->last_oid != OID_signed_data) {\n\t\tpr_warn(\"Only support pkcs7_signedData type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint pkcs7_note_signeddata_version(void *context, size_t hdrlen,\n\t\t\t\t  unsigned char tag,\n\t\t\t\t  const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\tunsigned version;\n\n\tif (vlen != 1)\n\t\tgoto unsupported;\n\n\tctx->msg->version = version = *(const u8 *)value;\n\tswitch (version) {\n\tcase 1:\n\t\t \n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tgoto unsupported;\n\t}\n\n\treturn 0;\n\nunsupported:\n\tpr_warn(\"Unsupported SignedData version\\n\");\n\treturn -EINVAL;\n}\n\n \nint pkcs7_note_signerinfo_version(void *context, size_t hdrlen,\n\t\t\t\t  unsigned char tag,\n\t\t\t\t  const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\tunsigned version;\n\n\tif (vlen != 1)\n\t\tgoto unsupported;\n\n\tversion = *(const u8 *)value;\n\tswitch (version) {\n\tcase 1:\n\t\t \n\t\tif (ctx->msg->version != 1)\n\t\t\tgoto version_mismatch;\n\t\tctx->expect_skid = false;\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tif (ctx->msg->version == 1)\n\t\t\tgoto version_mismatch;\n\t\tctx->expect_skid = true;\n\t\tbreak;\n\tdefault:\n\t\tgoto unsupported;\n\t}\n\n\treturn 0;\n\nunsupported:\n\tpr_warn(\"Unsupported SignerInfo version\\n\");\n\treturn -EINVAL;\nversion_mismatch:\n\tpr_warn(\"SignedData-SignerInfo version mismatch\\n\");\n\treturn -EBADMSG;\n}\n\n \nint pkcs7_extract_cert(void *context, size_t hdrlen,\n\t\t       unsigned char tag,\n\t\t       const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\tstruct x509_certificate *x509;\n\n\tif (tag != ((ASN1_UNIV << 6) | ASN1_CONS_BIT | ASN1_SEQ)) {\n\t\tpr_debug(\"Cert began with tag %02x at %lu\\n\",\n\t\t\t tag, (unsigned long)ctx - ctx->data);\n\t\treturn -EBADMSG;\n\t}\n\n\t \n\tvalue -= hdrlen;\n\tvlen += hdrlen;\n\n\tif (((u8*)value)[1] == 0x80)\n\t\tvlen += 2;  \n\n\tx509 = x509_cert_parse(value, vlen);\n\tif (IS_ERR(x509))\n\t\treturn PTR_ERR(x509);\n\n\tx509->index = ++ctx->x509_index;\n\tpr_debug(\"Got cert %u for %s\\n\", x509->index, x509->subject);\n\tpr_debug(\"- fingerprint %*phN\\n\", x509->id->len, x509->id->data);\n\n\t*ctx->ppcerts = x509;\n\tctx->ppcerts = &x509->next;\n\treturn 0;\n}\n\n \nint pkcs7_note_certificate_list(void *context, size_t hdrlen,\n\t\t\t\tunsigned char tag,\n\t\t\t\tconst void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\n\tpr_devel(\"Got cert list (%02x)\\n\", tag);\n\n\t*ctx->ppcerts = ctx->msg->certs;\n\tctx->msg->certs = ctx->certs;\n\tctx->certs = NULL;\n\tctx->ppcerts = &ctx->certs;\n\treturn 0;\n}\n\n \nint pkcs7_note_content(void *context, size_t hdrlen,\n\t\t       unsigned char tag,\n\t\t       const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\n\tif (ctx->last_oid != OID_data &&\n\t    ctx->last_oid != OID_msIndirectData) {\n\t\tpr_warn(\"Unsupported data type %d\\n\", ctx->last_oid);\n\t\treturn -EINVAL;\n\t}\n\n\tctx->msg->data_type = ctx->last_oid;\n\treturn 0;\n}\n\n \nint pkcs7_note_data(void *context, size_t hdrlen,\n\t\t    unsigned char tag,\n\t\t    const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\n\tpr_debug(\"Got data\\n\");\n\n\tctx->msg->data = value;\n\tctx->msg->data_len = vlen;\n\tctx->msg->data_hdrlen = hdrlen;\n\treturn 0;\n}\n\n \nint pkcs7_sig_note_authenticated_attr(void *context, size_t hdrlen,\n\t\t\t\t      unsigned char tag,\n\t\t\t\t      const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\tstruct pkcs7_signed_info *sinfo = ctx->sinfo;\n\tenum OID content_type;\n\n\tpr_devel(\"AuthAttr: %02x %zu [%*ph]\\n\", tag, vlen, (unsigned)vlen, value);\n\n\tswitch (ctx->last_oid) {\n\tcase OID_contentType:\n\t\tif (__test_and_set_bit(sinfo_has_content_type, &sinfo->aa_set))\n\t\t\tgoto repeated;\n\t\tcontent_type = look_up_OID(value, vlen);\n\t\tif (content_type != ctx->msg->data_type) {\n\t\t\tpr_warn(\"Mismatch between global data type (%d) and sinfo %u (%d)\\n\",\n\t\t\t\tctx->msg->data_type, sinfo->index,\n\t\t\t\tcontent_type);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\treturn 0;\n\n\tcase OID_signingTime:\n\t\tif (__test_and_set_bit(sinfo_has_signing_time, &sinfo->aa_set))\n\t\t\tgoto repeated;\n\t\t \n\t\treturn x509_decode_time(&sinfo->signing_time,\n\t\t\t\t\thdrlen, tag, value, vlen);\n\n\tcase OID_messageDigest:\n\t\tif (__test_and_set_bit(sinfo_has_message_digest, &sinfo->aa_set))\n\t\t\tgoto repeated;\n\t\tif (tag != ASN1_OTS)\n\t\t\treturn -EBADMSG;\n\t\tsinfo->msgdigest = value;\n\t\tsinfo->msgdigest_len = vlen;\n\t\treturn 0;\n\n\tcase OID_smimeCapabilites:\n\t\tif (__test_and_set_bit(sinfo_has_smime_caps, &sinfo->aa_set))\n\t\t\tgoto repeated;\n\t\tif (ctx->msg->data_type != OID_msIndirectData) {\n\t\t\tpr_warn(\"S/MIME Caps only allowed with Authenticode\\n\");\n\t\t\treturn -EKEYREJECTED;\n\t\t}\n\t\treturn 0;\n\n\t\t \n\tcase OID_msSpOpusInfo:\n\t\tif (__test_and_set_bit(sinfo_has_ms_opus_info, &sinfo->aa_set))\n\t\t\tgoto repeated;\n\t\tgoto authenticode_check;\n\tcase OID_msStatementType:\n\t\tif (__test_and_set_bit(sinfo_has_ms_statement_type, &sinfo->aa_set))\n\t\t\tgoto repeated;\n\tauthenticode_check:\n\t\tif (ctx->msg->data_type != OID_msIndirectData) {\n\t\t\tpr_warn(\"Authenticode AuthAttrs only allowed with Authenticode\\n\");\n\t\t\treturn -EKEYREJECTED;\n\t\t}\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n\nrepeated:\n\t \n\tpr_warn(\"Repeated/multivalue AuthAttrs not permitted\\n\");\n\treturn -EKEYREJECTED;\n}\n\n \nint pkcs7_sig_note_set_of_authattrs(void *context, size_t hdrlen,\n\t\t\t\t    unsigned char tag,\n\t\t\t\t    const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\tstruct pkcs7_signed_info *sinfo = ctx->sinfo;\n\n\tif (!test_bit(sinfo_has_content_type, &sinfo->aa_set) ||\n\t    !test_bit(sinfo_has_message_digest, &sinfo->aa_set)) {\n\t\tpr_warn(\"Missing required AuthAttr\\n\");\n\t\treturn -EBADMSG;\n\t}\n\n\tif (ctx->msg->data_type != OID_msIndirectData &&\n\t    test_bit(sinfo_has_ms_opus_info, &sinfo->aa_set)) {\n\t\tpr_warn(\"Unexpected Authenticode AuthAttr\\n\");\n\t\treturn -EBADMSG;\n\t}\n\n\t \n\tsinfo->authattrs = value - (hdrlen - 1);\n\tsinfo->authattrs_len = vlen + (hdrlen - 1);\n\treturn 0;\n}\n\n \nint pkcs7_sig_note_serial(void *context, size_t hdrlen,\n\t\t\t  unsigned char tag,\n\t\t\t  const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\tctx->raw_serial = value;\n\tctx->raw_serial_size = vlen;\n\treturn 0;\n}\n\n \nint pkcs7_sig_note_issuer(void *context, size_t hdrlen,\n\t\t\t  unsigned char tag,\n\t\t\t  const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\tctx->raw_issuer = value;\n\tctx->raw_issuer_size = vlen;\n\treturn 0;\n}\n\n \nint pkcs7_sig_note_skid(void *context, size_t hdrlen,\n\t\t\tunsigned char tag,\n\t\t\tconst void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\n\tpr_devel(\"SKID: %02x %zu [%*ph]\\n\", tag, vlen, (unsigned)vlen, value);\n\n\tctx->raw_skid = value;\n\tctx->raw_skid_size = vlen;\n\treturn 0;\n}\n\n \nint pkcs7_sig_note_signature(void *context, size_t hdrlen,\n\t\t\t     unsigned char tag,\n\t\t\t     const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\n\tctx->sinfo->sig->s = kmemdup(value, vlen, GFP_KERNEL);\n\tif (!ctx->sinfo->sig->s)\n\t\treturn -ENOMEM;\n\n\tctx->sinfo->sig->s_size = vlen;\n\treturn 0;\n}\n\n \nint pkcs7_note_signed_info(void *context, size_t hdrlen,\n\t\t\t   unsigned char tag,\n\t\t\t   const void *value, size_t vlen)\n{\n\tstruct pkcs7_parse_context *ctx = context;\n\tstruct pkcs7_signed_info *sinfo = ctx->sinfo;\n\tstruct asymmetric_key_id *kid;\n\n\tif (ctx->msg->data_type == OID_msIndirectData && !sinfo->authattrs) {\n\t\tpr_warn(\"Authenticode requires AuthAttrs\\n\");\n\t\treturn -EBADMSG;\n\t}\n\n\t \n\tif (!ctx->expect_skid) {\n\t\tkid = asymmetric_key_generate_id(ctx->raw_serial,\n\t\t\t\t\t\t ctx->raw_serial_size,\n\t\t\t\t\t\t ctx->raw_issuer,\n\t\t\t\t\t\t ctx->raw_issuer_size);\n\t} else {\n\t\tkid = asymmetric_key_generate_id(ctx->raw_skid,\n\t\t\t\t\t\t ctx->raw_skid_size,\n\t\t\t\t\t\t \"\", 0);\n\t}\n\tif (IS_ERR(kid))\n\t\treturn PTR_ERR(kid);\n\n\tpr_devel(\"SINFO KID: %u [%*phN]\\n\", kid->len, kid->len, kid->data);\n\n\tsinfo->sig->auth_ids[0] = kid;\n\tsinfo->index = ++ctx->sinfo_index;\n\t*ctx->ppsinfo = sinfo;\n\tctx->ppsinfo = &sinfo->next;\n\tctx->sinfo = kzalloc(sizeof(struct pkcs7_signed_info), GFP_KERNEL);\n\tif (!ctx->sinfo)\n\t\treturn -ENOMEM;\n\tctx->sinfo->sig = kzalloc(sizeof(struct public_key_signature),\n\t\t\t\t  GFP_KERNEL);\n\tif (!ctx->sinfo->sig)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}