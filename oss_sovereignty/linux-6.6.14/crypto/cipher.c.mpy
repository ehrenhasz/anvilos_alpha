{
  "module_name": "cipher.c",
  "hash_id": "7e60c44c235680652cc36e2b24f3ba3b24990bc9f9cea91b23fc2a998706a3b8",
  "original_prompt": "Ingested from linux-6.6.14/crypto/cipher.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/cipher.h>\n#include <linux/kernel.h>\n#include <linux/crypto.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include \"internal.h\"\n\nstatic int setkey_unaligned(struct crypto_cipher *tfm, const u8 *key,\n\t\t\t    unsigned int keylen)\n{\n\tstruct cipher_alg *cia = crypto_cipher_alg(tfm);\n\tunsigned long alignmask = crypto_cipher_alignmask(tfm);\n\tint ret;\n\tu8 *buffer, *alignbuffer;\n\tunsigned long absize;\n\n\tabsize = keylen + alignmask;\n\tbuffer = kmalloc(absize, GFP_ATOMIC);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\talignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\n\tmemcpy(alignbuffer, key, keylen);\n\tret = cia->cia_setkey(crypto_cipher_tfm(tfm), alignbuffer, keylen);\n\tmemset(alignbuffer, 0, keylen);\n\tkfree(buffer);\n\treturn ret;\n\n}\n\nint crypto_cipher_setkey(struct crypto_cipher *tfm,\n\t\t\t const u8 *key, unsigned int keylen)\n{\n\tstruct cipher_alg *cia = crypto_cipher_alg(tfm);\n\tunsigned long alignmask = crypto_cipher_alignmask(tfm);\n\n\tif (keylen < cia->cia_min_keysize || keylen > cia->cia_max_keysize)\n\t\treturn -EINVAL;\n\n\tif ((unsigned long)key & alignmask)\n\t\treturn setkey_unaligned(tfm, key, keylen);\n\n\treturn cia->cia_setkey(crypto_cipher_tfm(tfm), key, keylen);\n}\nEXPORT_SYMBOL_NS_GPL(crypto_cipher_setkey, CRYPTO_INTERNAL);\n\nstatic inline void cipher_crypt_one(struct crypto_cipher *tfm,\n\t\t\t\t    u8 *dst, const u8 *src, bool enc)\n{\n\tunsigned long alignmask = crypto_cipher_alignmask(tfm);\n\tstruct cipher_alg *cia = crypto_cipher_alg(tfm);\n\tvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *) =\n\t\tenc ? cia->cia_encrypt : cia->cia_decrypt;\n\n\tif (unlikely(((unsigned long)dst | (unsigned long)src) & alignmask)) {\n\t\tunsigned int bs = crypto_cipher_blocksize(tfm);\n\t\tu8 buffer[MAX_CIPHER_BLOCKSIZE + MAX_CIPHER_ALIGNMASK];\n\t\tu8 *tmp = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\n\n\t\tmemcpy(tmp, src, bs);\n\t\tfn(crypto_cipher_tfm(tfm), tmp, tmp);\n\t\tmemcpy(dst, tmp, bs);\n\t} else {\n\t\tfn(crypto_cipher_tfm(tfm), dst, src);\n\t}\n}\n\nvoid crypto_cipher_encrypt_one(struct crypto_cipher *tfm,\n\t\t\t       u8 *dst, const u8 *src)\n{\n\tcipher_crypt_one(tfm, dst, src, true);\n}\nEXPORT_SYMBOL_NS_GPL(crypto_cipher_encrypt_one, CRYPTO_INTERNAL);\n\nvoid crypto_cipher_decrypt_one(struct crypto_cipher *tfm,\n\t\t\t       u8 *dst, const u8 *src)\n{\n\tcipher_crypt_one(tfm, dst, src, false);\n}\nEXPORT_SYMBOL_NS_GPL(crypto_cipher_decrypt_one, CRYPTO_INTERNAL);\n\nstruct crypto_cipher *crypto_clone_cipher(struct crypto_cipher *cipher)\n{\n\tstruct crypto_tfm *tfm = crypto_cipher_tfm(cipher);\n\tstruct crypto_alg *alg = tfm->__crt_alg;\n\tstruct crypto_cipher *ncipher;\n\tstruct crypto_tfm *ntfm;\n\n\tif (alg->cra_init)\n\t\treturn ERR_PTR(-ENOSYS);\n\n\tif (unlikely(!crypto_mod_get(alg)))\n\t\treturn ERR_PTR(-ESTALE);\n\n\tntfm = __crypto_alloc_tfmgfp(alg, CRYPTO_ALG_TYPE_CIPHER,\n\t\t\t\t     CRYPTO_ALG_TYPE_MASK, GFP_ATOMIC);\n\tif (IS_ERR(ntfm)) {\n\t\tcrypto_mod_put(alg);\n\t\treturn ERR_CAST(ntfm);\n\t}\n\n\tntfm->crt_flags = tfm->crt_flags;\n\n\tncipher = __crypto_cipher_cast(ntfm);\n\n\treturn ncipher;\n}\nEXPORT_SYMBOL_GPL(crypto_clone_cipher);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}