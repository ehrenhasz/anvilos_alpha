{
  "module_name": "blake2b_generic.c",
  "hash_id": "32add1554dd6b5a596f035ec8226140daa83c466c34ad5746181958c3ddf4cb2",
  "original_prompt": "Ingested from linux-6.6.14/crypto/blake2b_generic.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <crypto/internal/blake2b.h>\n#include <crypto/internal/hash.h>\n\nstatic const u8 blake2b_sigma[12][16] = {\n\t{  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 },\n\t{ 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 },\n\t{ 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 },\n\t{  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 },\n\t{  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 },\n\t{  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 },\n\t{ 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 },\n\t{ 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 },\n\t{  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 },\n\t{ 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13,  0 },\n\t{  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 },\n\t{ 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 }\n};\n\nstatic void blake2b_increment_counter(struct blake2b_state *S, const u64 inc)\n{\n\tS->t[0] += inc;\n\tS->t[1] += (S->t[0] < inc);\n}\n\n#define G(r,i,a,b,c,d)                                  \\\n\tdo {                                            \\\n\t\ta = a + b + m[blake2b_sigma[r][2*i+0]]; \\\n\t\td = ror64(d ^ a, 32);                   \\\n\t\tc = c + d;                              \\\n\t\tb = ror64(b ^ c, 24);                   \\\n\t\ta = a + b + m[blake2b_sigma[r][2*i+1]]; \\\n\t\td = ror64(d ^ a, 16);                   \\\n\t\tc = c + d;                              \\\n\t\tb = ror64(b ^ c, 63);                   \\\n\t} while (0)\n\n#define ROUND(r)                                \\\n\tdo {                                    \\\n\t\tG(r,0,v[ 0],v[ 4],v[ 8],v[12]); \\\n\t\tG(r,1,v[ 1],v[ 5],v[ 9],v[13]); \\\n\t\tG(r,2,v[ 2],v[ 6],v[10],v[14]); \\\n\t\tG(r,3,v[ 3],v[ 7],v[11],v[15]); \\\n\t\tG(r,4,v[ 0],v[ 5],v[10],v[15]); \\\n\t\tG(r,5,v[ 1],v[ 6],v[11],v[12]); \\\n\t\tG(r,6,v[ 2],v[ 7],v[ 8],v[13]); \\\n\t\tG(r,7,v[ 3],v[ 4],v[ 9],v[14]); \\\n\t} while (0)\n\nstatic void blake2b_compress_one_generic(struct blake2b_state *S,\n\t\t\t\t\t const u8 block[BLAKE2B_BLOCK_SIZE])\n{\n\tu64 m[16];\n\tu64 v[16];\n\tsize_t i;\n\n\tfor (i = 0; i < 16; ++i)\n\t\tm[i] = get_unaligned_le64(block + i * sizeof(m[i]));\n\n\tfor (i = 0; i < 8; ++i)\n\t\tv[i] = S->h[i];\n\n\tv[ 8] = BLAKE2B_IV0;\n\tv[ 9] = BLAKE2B_IV1;\n\tv[10] = BLAKE2B_IV2;\n\tv[11] = BLAKE2B_IV3;\n\tv[12] = BLAKE2B_IV4 ^ S->t[0];\n\tv[13] = BLAKE2B_IV5 ^ S->t[1];\n\tv[14] = BLAKE2B_IV6 ^ S->f[0];\n\tv[15] = BLAKE2B_IV7 ^ S->f[1];\n\n\tROUND(0);\n\tROUND(1);\n\tROUND(2);\n\tROUND(3);\n\tROUND(4);\n\tROUND(5);\n\tROUND(6);\n\tROUND(7);\n\tROUND(8);\n\tROUND(9);\n\tROUND(10);\n\tROUND(11);\n#ifdef CONFIG_CC_IS_CLANG\n#pragma nounroll /* https:\n#endif\n\tfor (i = 0; i < 8; ++i)\n\t\tS->h[i] = S->h[i] ^ v[i] ^ v[i + 8];\n}\n\n#undef G\n#undef ROUND\n\nvoid blake2b_compress_generic(struct blake2b_state *state,\n\t\t\t      const u8 *block, size_t nblocks, u32 inc)\n{\n\tdo {\n\t\tblake2b_increment_counter(state, inc);\n\t\tblake2b_compress_one_generic(state, block);\n\t\tblock += BLAKE2B_BLOCK_SIZE;\n\t} while (--nblocks);\n}\nEXPORT_SYMBOL(blake2b_compress_generic);\n\nstatic int crypto_blake2b_update_generic(struct shash_desc *desc,\n\t\t\t\t\t const u8 *in, unsigned int inlen)\n{\n\treturn crypto_blake2b_update(desc, in, inlen, blake2b_compress_generic);\n}\n\nstatic int crypto_blake2b_final_generic(struct shash_desc *desc, u8 *out)\n{\n\treturn crypto_blake2b_final(desc, out, blake2b_compress_generic);\n}\n\n#define BLAKE2B_ALG(name, driver_name, digest_size)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.base.cra_name\t\t= name,\t\t\t\t\\\n\t\t.base.cra_driver_name\t= driver_name,\t\t\t\\\n\t\t.base.cra_priority\t= 100,\t\t\t\t\\\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_OPTIONAL_KEY,\t\\\n\t\t.base.cra_blocksize\t= BLAKE2B_BLOCK_SIZE,\t\t\\\n\t\t.base.cra_ctxsize\t= sizeof(struct blake2b_tfm_ctx), \\\n\t\t.base.cra_module\t= THIS_MODULE,\t\t\t\\\n\t\t.digestsize\t\t= digest_size,\t\t\t\\\n\t\t.setkey\t\t\t= crypto_blake2b_setkey,\t\\\n\t\t.init\t\t\t= crypto_blake2b_init,\t\t\\\n\t\t.update\t\t\t= crypto_blake2b_update_generic, \\\n\t\t.final\t\t\t= crypto_blake2b_final_generic,\t\\\n\t\t.descsize\t\t= sizeof(struct blake2b_state),\t\\\n\t}\n\nstatic struct shash_alg blake2b_algs[] = {\n\tBLAKE2B_ALG(\"blake2b-160\", \"blake2b-160-generic\",\n\t\t    BLAKE2B_160_HASH_SIZE),\n\tBLAKE2B_ALG(\"blake2b-256\", \"blake2b-256-generic\",\n\t\t    BLAKE2B_256_HASH_SIZE),\n\tBLAKE2B_ALG(\"blake2b-384\", \"blake2b-384-generic\",\n\t\t    BLAKE2B_384_HASH_SIZE),\n\tBLAKE2B_ALG(\"blake2b-512\", \"blake2b-512-generic\",\n\t\t    BLAKE2B_512_HASH_SIZE),\n};\n\nstatic int __init blake2b_mod_init(void)\n{\n\treturn crypto_register_shashes(blake2b_algs, ARRAY_SIZE(blake2b_algs));\n}\n\nstatic void __exit blake2b_mod_fini(void)\n{\n\tcrypto_unregister_shashes(blake2b_algs, ARRAY_SIZE(blake2b_algs));\n}\n\nsubsys_initcall(blake2b_mod_init);\nmodule_exit(blake2b_mod_fini);\n\nMODULE_AUTHOR(\"David Sterba <kdave@kernel.org>\");\nMODULE_DESCRIPTION(\"BLAKE2b generic implementation\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CRYPTO(\"blake2b-160\");\nMODULE_ALIAS_CRYPTO(\"blake2b-160-generic\");\nMODULE_ALIAS_CRYPTO(\"blake2b-256\");\nMODULE_ALIAS_CRYPTO(\"blake2b-256-generic\");\nMODULE_ALIAS_CRYPTO(\"blake2b-384\");\nMODULE_ALIAS_CRYPTO(\"blake2b-384-generic\");\nMODULE_ALIAS_CRYPTO(\"blake2b-512\");\nMODULE_ALIAS_CRYPTO(\"blake2b-512-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}