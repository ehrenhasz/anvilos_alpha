{
  "module_name": "essiv.c",
  "hash_id": "f93bdd367bc4aea5e423da29372222aeba27f25b997655224922ddc145dc1b0a",
  "original_prompt": "Ingested from linux-6.6.14/crypto/essiv.c",
  "human_readable_source": "\n \n\n#include <crypto/authenc.h>\n#include <crypto/internal/aead.h>\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <linux/module.h>\n\n#include \"internal.h\"\n\nstruct essiv_instance_ctx {\n\tunion {\n\t\tstruct crypto_skcipher_spawn\tskcipher_spawn;\n\t\tstruct crypto_aead_spawn\taead_spawn;\n\t} u;\n\tchar\tessiv_cipher_name[CRYPTO_MAX_ALG_NAME];\n\tchar\tshash_driver_name[CRYPTO_MAX_ALG_NAME];\n};\n\nstruct essiv_tfm_ctx {\n\tunion {\n\t\tstruct crypto_skcipher\t*skcipher;\n\t\tstruct crypto_aead\t*aead;\n\t} u;\n\tstruct crypto_cipher\t\t*essiv_cipher;\n\tstruct crypto_shash\t\t*hash;\n\tint\t\t\t\tivoffset;\n};\n\nstruct essiv_aead_request_ctx {\n\tstruct scatterlist\t\tsg[4];\n\tu8\t\t\t\t*assoc;\n\tstruct aead_request\t\taead_req;\n};\n\nstatic int essiv_skcipher_setkey(struct crypto_skcipher *tfm,\n\t\t\t\t const u8 *key, unsigned int keylen)\n{\n\tstruct essiv_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);\n\tu8 salt[HASH_MAX_DIGESTSIZE];\n\tint err;\n\n\tcrypto_skcipher_clear_flags(tctx->u.skcipher, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(tctx->u.skcipher,\n\t\t\t\t  crypto_skcipher_get_flags(tfm) &\n\t\t\t\t  CRYPTO_TFM_REQ_MASK);\n\terr = crypto_skcipher_setkey(tctx->u.skcipher, key, keylen);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_shash_tfm_digest(tctx->hash, key, keylen, salt);\n\tif (err)\n\t\treturn err;\n\n\tcrypto_cipher_clear_flags(tctx->essiv_cipher, CRYPTO_TFM_REQ_MASK);\n\tcrypto_cipher_set_flags(tctx->essiv_cipher,\n\t\t\t\tcrypto_skcipher_get_flags(tfm) &\n\t\t\t\tCRYPTO_TFM_REQ_MASK);\n\treturn crypto_cipher_setkey(tctx->essiv_cipher, salt,\n\t\t\t\t    crypto_shash_digestsize(tctx->hash));\n}\n\nstatic int essiv_aead_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct essiv_tfm_ctx *tctx = crypto_aead_ctx(tfm);\n\tSHASH_DESC_ON_STACK(desc, tctx->hash);\n\tstruct crypto_authenc_keys keys;\n\tu8 salt[HASH_MAX_DIGESTSIZE];\n\tint err;\n\n\tcrypto_aead_clear_flags(tctx->u.aead, CRYPTO_TFM_REQ_MASK);\n\tcrypto_aead_set_flags(tctx->u.aead, crypto_aead_get_flags(tfm) &\n\t\t\t\t\t    CRYPTO_TFM_REQ_MASK);\n\terr = crypto_aead_setkey(tctx->u.aead, key, keylen);\n\tif (err)\n\t\treturn err;\n\n\tif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\n\t\treturn -EINVAL;\n\n\tdesc->tfm = tctx->hash;\n\terr = crypto_shash_init(desc) ?:\n\t      crypto_shash_update(desc, keys.enckey, keys.enckeylen) ?:\n\t      crypto_shash_finup(desc, keys.authkey, keys.authkeylen, salt);\n\tif (err)\n\t\treturn err;\n\n\tcrypto_cipher_clear_flags(tctx->essiv_cipher, CRYPTO_TFM_REQ_MASK);\n\tcrypto_cipher_set_flags(tctx->essiv_cipher, crypto_aead_get_flags(tfm) &\n\t\t\t\t\t\t    CRYPTO_TFM_REQ_MASK);\n\treturn crypto_cipher_setkey(tctx->essiv_cipher, salt,\n\t\t\t\t    crypto_shash_digestsize(tctx->hash));\n}\n\nstatic int essiv_aead_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t  unsigned int authsize)\n{\n\tstruct essiv_tfm_ctx *tctx = crypto_aead_ctx(tfm);\n\n\treturn crypto_aead_setauthsize(tctx->u.aead, authsize);\n}\n\nstatic void essiv_skcipher_done(void *data, int err)\n{\n\tstruct skcipher_request *req = data;\n\n\tskcipher_request_complete(req, err);\n}\n\nstatic int essiv_skcipher_crypt(struct skcipher_request *req, bool enc)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tconst struct essiv_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);\n\tstruct skcipher_request *subreq = skcipher_request_ctx(req);\n\n\tcrypto_cipher_encrypt_one(tctx->essiv_cipher, req->iv, req->iv);\n\n\tskcipher_request_set_tfm(subreq, tctx->u.skcipher);\n\tskcipher_request_set_crypt(subreq, req->src, req->dst, req->cryptlen,\n\t\t\t\t   req->iv);\n\tskcipher_request_set_callback(subreq, skcipher_request_flags(req),\n\t\t\t\t      essiv_skcipher_done, req);\n\n\treturn enc ? crypto_skcipher_encrypt(subreq) :\n\t\t     crypto_skcipher_decrypt(subreq);\n}\n\nstatic int essiv_skcipher_encrypt(struct skcipher_request *req)\n{\n\treturn essiv_skcipher_crypt(req, true);\n}\n\nstatic int essiv_skcipher_decrypt(struct skcipher_request *req)\n{\n\treturn essiv_skcipher_crypt(req, false);\n}\n\nstatic void essiv_aead_done(void *data, int err)\n{\n\tstruct aead_request *req = data;\n\tstruct essiv_aead_request_ctx *rctx = aead_request_ctx(req);\n\n\tif (err == -EINPROGRESS)\n\t\tgoto out;\n\n\tkfree(rctx->assoc);\n\nout:\n\taead_request_complete(req, err);\n}\n\nstatic int essiv_aead_crypt(struct aead_request *req, bool enc)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tconst struct essiv_tfm_ctx *tctx = crypto_aead_ctx(tfm);\n\tstruct essiv_aead_request_ctx *rctx = aead_request_ctx(req);\n\tstruct aead_request *subreq = &rctx->aead_req;\n\tstruct scatterlist *src = req->src;\n\tint err;\n\n\tcrypto_cipher_encrypt_one(tctx->essiv_cipher, req->iv, req->iv);\n\n\t \n\trctx->assoc = NULL;\n\tif (req->src == req->dst || !enc) {\n\t\tscatterwalk_map_and_copy(req->iv, req->dst,\n\t\t\t\t\t req->assoclen - crypto_aead_ivsize(tfm),\n\t\t\t\t\t crypto_aead_ivsize(tfm), 1);\n\t} else {\n\t\tu8 *iv = (u8 *)aead_request_ctx(req) + tctx->ivoffset;\n\t\tint ivsize = crypto_aead_ivsize(tfm);\n\t\tint ssize = req->assoclen - ivsize;\n\t\tstruct scatterlist *sg;\n\t\tint nents;\n\n\t\tif (ssize < 0)\n\t\t\treturn -EINVAL;\n\n\t\tnents = sg_nents_for_len(req->src, ssize);\n\t\tif (nents < 0)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(iv, req->iv, ivsize);\n\t\tsg_init_table(rctx->sg, 4);\n\n\t\tif (unlikely(nents > 1)) {\n\t\t\t \n\t\t\trctx->assoc = kmalloc(ssize, GFP_ATOMIC);\n\t\t\tif (!rctx->assoc)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tscatterwalk_map_and_copy(rctx->assoc, req->src, 0,\n\t\t\t\t\t\t ssize, 0);\n\t\t\tsg_set_buf(rctx->sg, rctx->assoc, ssize);\n\t\t} else {\n\t\t\tsg_set_page(rctx->sg, sg_page(req->src), ssize,\n\t\t\t\t    req->src->offset);\n\t\t}\n\n\t\tsg_set_buf(rctx->sg + 1, iv, ivsize);\n\t\tsg = scatterwalk_ffwd(rctx->sg + 2, req->src, req->assoclen);\n\t\tif (sg != rctx->sg + 2)\n\t\t\tsg_chain(rctx->sg, 3, sg);\n\n\t\tsrc = rctx->sg;\n\t}\n\n\taead_request_set_tfm(subreq, tctx->u.aead);\n\taead_request_set_ad(subreq, req->assoclen);\n\taead_request_set_callback(subreq, aead_request_flags(req),\n\t\t\t\t  essiv_aead_done, req);\n\taead_request_set_crypt(subreq, src, req->dst, req->cryptlen, req->iv);\n\n\terr = enc ? crypto_aead_encrypt(subreq) :\n\t\t    crypto_aead_decrypt(subreq);\n\n\tif (rctx->assoc && err != -EINPROGRESS && err != -EBUSY)\n\t\tkfree(rctx->assoc);\n\treturn err;\n}\n\nstatic int essiv_aead_encrypt(struct aead_request *req)\n{\n\treturn essiv_aead_crypt(req, true);\n}\n\nstatic int essiv_aead_decrypt(struct aead_request *req)\n{\n\treturn essiv_aead_crypt(req, false);\n}\n\nstatic int essiv_init_tfm(struct essiv_instance_ctx *ictx,\n\t\t\t  struct essiv_tfm_ctx *tctx)\n{\n\tstruct crypto_cipher *essiv_cipher;\n\tstruct crypto_shash *hash;\n\tint err;\n\n\tessiv_cipher = crypto_alloc_cipher(ictx->essiv_cipher_name, 0, 0);\n\tif (IS_ERR(essiv_cipher))\n\t\treturn PTR_ERR(essiv_cipher);\n\n\thash = crypto_alloc_shash(ictx->shash_driver_name, 0, 0);\n\tif (IS_ERR(hash)) {\n\t\terr = PTR_ERR(hash);\n\t\tgoto err_free_essiv_cipher;\n\t}\n\n\ttctx->essiv_cipher = essiv_cipher;\n\ttctx->hash = hash;\n\n\treturn 0;\n\nerr_free_essiv_cipher:\n\tcrypto_free_cipher(essiv_cipher);\n\treturn err;\n}\n\nstatic int essiv_skcipher_init_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct skcipher_instance *inst = skcipher_alg_instance(tfm);\n\tstruct essiv_instance_ctx *ictx = skcipher_instance_ctx(inst);\n\tstruct essiv_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);\n\tstruct crypto_skcipher *skcipher;\n\tint err;\n\n\tskcipher = crypto_spawn_skcipher(&ictx->u.skcipher_spawn);\n\tif (IS_ERR(skcipher))\n\t\treturn PTR_ERR(skcipher);\n\n\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct skcipher_request) +\n\t\t\t\t         crypto_skcipher_reqsize(skcipher));\n\n\terr = essiv_init_tfm(ictx, tctx);\n\tif (err) {\n\t\tcrypto_free_skcipher(skcipher);\n\t\treturn err;\n\t}\n\n\ttctx->u.skcipher = skcipher;\n\treturn 0;\n}\n\nstatic int essiv_aead_init_tfm(struct crypto_aead *tfm)\n{\n\tstruct aead_instance *inst = aead_alg_instance(tfm);\n\tstruct essiv_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct essiv_tfm_ctx *tctx = crypto_aead_ctx(tfm);\n\tstruct crypto_aead *aead;\n\tunsigned int subreq_size;\n\tint err;\n\n\tBUILD_BUG_ON(offsetofend(struct essiv_aead_request_ctx, aead_req) !=\n\t\t     sizeof(struct essiv_aead_request_ctx));\n\n\taead = crypto_spawn_aead(&ictx->u.aead_spawn);\n\tif (IS_ERR(aead))\n\t\treturn PTR_ERR(aead);\n\n\tsubreq_size = sizeof_field(struct essiv_aead_request_ctx, aead_req) +\n\t\t      crypto_aead_reqsize(aead);\n\n\ttctx->ivoffset = offsetof(struct essiv_aead_request_ctx, aead_req) +\n\t\t\t subreq_size;\n\tcrypto_aead_set_reqsize(tfm, tctx->ivoffset + crypto_aead_ivsize(aead));\n\n\terr = essiv_init_tfm(ictx, tctx);\n\tif (err) {\n\t\tcrypto_free_aead(aead);\n\t\treturn err;\n\t}\n\n\ttctx->u.aead = aead;\n\treturn 0;\n}\n\nstatic void essiv_skcipher_exit_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct essiv_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);\n\n\tcrypto_free_skcipher(tctx->u.skcipher);\n\tcrypto_free_cipher(tctx->essiv_cipher);\n\tcrypto_free_shash(tctx->hash);\n}\n\nstatic void essiv_aead_exit_tfm(struct crypto_aead *tfm)\n{\n\tstruct essiv_tfm_ctx *tctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_aead(tctx->u.aead);\n\tcrypto_free_cipher(tctx->essiv_cipher);\n\tcrypto_free_shash(tctx->hash);\n}\n\nstatic void essiv_skcipher_free_instance(struct skcipher_instance *inst)\n{\n\tstruct essiv_instance_ctx *ictx = skcipher_instance_ctx(inst);\n\n\tcrypto_drop_skcipher(&ictx->u.skcipher_spawn);\n\tkfree(inst);\n}\n\nstatic void essiv_aead_free_instance(struct aead_instance *inst)\n{\n\tstruct essiv_instance_ctx *ictx = aead_instance_ctx(inst);\n\n\tcrypto_drop_aead(&ictx->u.aead_spawn);\n\tkfree(inst);\n}\n\nstatic bool parse_cipher_name(char *essiv_cipher_name, const char *cra_name)\n{\n\tconst char *p, *q;\n\tint len;\n\n\t \n\tp = strrchr(cra_name, '(');\n\tif (!p++)\n\t\treturn false;\n\n\t \n\tq = strchr(p, ')');\n\tif (!q)\n\t\treturn false;\n\n\tlen = q - p;\n\tif (len >= CRYPTO_MAX_ALG_NAME)\n\t\treturn false;\n\n\tmemcpy(essiv_cipher_name, p, len);\n\tessiv_cipher_name[len] = '\\0';\n\treturn true;\n}\n\nstatic bool essiv_supported_algorithms(const char *essiv_cipher_name,\n\t\t\t\t       struct shash_alg *hash_alg,\n\t\t\t\t       int ivsize)\n{\n\tstruct crypto_alg *alg;\n\tbool ret = false;\n\n\talg = crypto_alg_mod_lookup(essiv_cipher_name,\n\t\t\t\t    CRYPTO_ALG_TYPE_CIPHER,\n\t\t\t\t    CRYPTO_ALG_TYPE_MASK);\n\tif (IS_ERR(alg))\n\t\treturn false;\n\n\tif (hash_alg->digestsize < alg->cra_cipher.cia_min_keysize ||\n\t    hash_alg->digestsize > alg->cra_cipher.cia_max_keysize)\n\t\tgoto out;\n\n\tif (ivsize != alg->cra_blocksize)\n\t\tgoto out;\n\n\tif (crypto_shash_alg_needs_key(hash_alg))\n\t\tgoto out;\n\n\tret = true;\n\nout:\n\tcrypto_mod_put(alg);\n\treturn ret;\n}\n\nstatic int essiv_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct crypto_attr_type *algt;\n\tconst char *inner_cipher_name;\n\tconst char *shash_name;\n\tstruct skcipher_instance *skcipher_inst = NULL;\n\tstruct aead_instance *aead_inst = NULL;\n\tstruct crypto_instance *inst;\n\tstruct crypto_alg *base, *block_base;\n\tstruct essiv_instance_ctx *ictx;\n\tstruct skcipher_alg *skcipher_alg = NULL;\n\tstruct aead_alg *aead_alg = NULL;\n\tstruct crypto_alg *_hash_alg;\n\tstruct shash_alg *hash_alg;\n\tint ivsize;\n\tu32 type;\n\tu32 mask;\n\tint err;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\n\tinner_cipher_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(inner_cipher_name))\n\t\treturn PTR_ERR(inner_cipher_name);\n\n\tshash_name = crypto_attr_alg_name(tb[2]);\n\tif (IS_ERR(shash_name))\n\t\treturn PTR_ERR(shash_name);\n\n\ttype = algt->type & algt->mask;\n\tmask = crypto_algt_inherited_mask(algt);\n\n\tswitch (type) {\n\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\tskcipher_inst = kzalloc(sizeof(*skcipher_inst) +\n\t\t\t\t\tsizeof(*ictx), GFP_KERNEL);\n\t\tif (!skcipher_inst)\n\t\t\treturn -ENOMEM;\n\t\tinst = skcipher_crypto_instance(skcipher_inst);\n\t\tbase = &skcipher_inst->alg.base;\n\t\tictx = crypto_instance_ctx(inst);\n\n\t\t \n\t\terr = crypto_grab_skcipher(&ictx->u.skcipher_spawn, inst,\n\t\t\t\t\t   inner_cipher_name, 0, mask);\n\t\tif (err)\n\t\t\tgoto out_free_inst;\n\t\tskcipher_alg = crypto_spawn_skcipher_alg(&ictx->u.skcipher_spawn);\n\t\tblock_base = &skcipher_alg->base;\n\t\tivsize = crypto_skcipher_alg_ivsize(skcipher_alg);\n\t\tbreak;\n\n\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\taead_inst = kzalloc(sizeof(*aead_inst) +\n\t\t\t\t    sizeof(*ictx), GFP_KERNEL);\n\t\tif (!aead_inst)\n\t\t\treturn -ENOMEM;\n\t\tinst = aead_crypto_instance(aead_inst);\n\t\tbase = &aead_inst->alg.base;\n\t\tictx = crypto_instance_ctx(inst);\n\n\t\t \n\t\terr = crypto_grab_aead(&ictx->u.aead_spawn, inst,\n\t\t\t\t       inner_cipher_name, 0, mask);\n\t\tif (err)\n\t\t\tgoto out_free_inst;\n\t\taead_alg = crypto_spawn_aead_alg(&ictx->u.aead_spawn);\n\t\tblock_base = &aead_alg->base;\n\t\tif (!strstarts(block_base->cra_name, \"authenc(\")) {\n\t\t\tpr_warn(\"Only authenc() type AEADs are supported by ESSIV\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_drop_skcipher;\n\t\t}\n\t\tivsize = aead_alg->ivsize;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parse_cipher_name(ictx->essiv_cipher_name, block_base->cra_name)) {\n\t\tpr_warn(\"Failed to parse ESSIV cipher name from skcipher cra_name\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_drop_skcipher;\n\t}\n\n\t \n\t_hash_alg = crypto_alg_mod_lookup(shash_name,\n\t\t\t\t\t  CRYPTO_ALG_TYPE_SHASH,\n\t\t\t\t\t  CRYPTO_ALG_TYPE_MASK | mask);\n\tif (IS_ERR(_hash_alg)) {\n\t\terr = PTR_ERR(_hash_alg);\n\t\tgoto out_drop_skcipher;\n\t}\n\thash_alg = __crypto_shash_alg(_hash_alg);\n\n\t \n\tif (!essiv_supported_algorithms(ictx->essiv_cipher_name, hash_alg,\n\t\t\t\t\tivsize)) {\n\t\tpr_warn(\"Unsupported essiv instantiation: essiv(%s,%s)\\n\",\n\t\t\tblock_base->cra_name, hash_alg->base.cra_name);\n\t\terr = -EINVAL;\n\t\tgoto out_free_hash;\n\t}\n\n\t \n\tstrscpy(ictx->shash_driver_name, hash_alg->base.cra_driver_name,\n\t\tCRYPTO_MAX_ALG_NAME);\n\n\t \n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(base->cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"essiv(%s,%s)\", block_base->cra_name,\n\t\t     hash_alg->base.cra_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto out_free_hash;\n\tif (snprintf(base->cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"essiv(%s,%s)\", block_base->cra_driver_name,\n\t\t     hash_alg->base.cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto out_free_hash;\n\n\t \n\tbase->cra_flags        |= (hash_alg->base.cra_flags &\n\t\t\t\t   CRYPTO_ALG_INHERITED_FLAGS);\n\tbase->cra_blocksize\t= block_base->cra_blocksize;\n\tbase->cra_ctxsize\t= sizeof(struct essiv_tfm_ctx);\n\tbase->cra_alignmask\t= block_base->cra_alignmask;\n\tbase->cra_priority\t= block_base->cra_priority;\n\n\tif (type == CRYPTO_ALG_TYPE_SKCIPHER) {\n\t\tskcipher_inst->alg.setkey\t= essiv_skcipher_setkey;\n\t\tskcipher_inst->alg.encrypt\t= essiv_skcipher_encrypt;\n\t\tskcipher_inst->alg.decrypt\t= essiv_skcipher_decrypt;\n\t\tskcipher_inst->alg.init\t\t= essiv_skcipher_init_tfm;\n\t\tskcipher_inst->alg.exit\t\t= essiv_skcipher_exit_tfm;\n\n\t\tskcipher_inst->alg.min_keysize\t= crypto_skcipher_alg_min_keysize(skcipher_alg);\n\t\tskcipher_inst->alg.max_keysize\t= crypto_skcipher_alg_max_keysize(skcipher_alg);\n\t\tskcipher_inst->alg.ivsize\t= ivsize;\n\t\tskcipher_inst->alg.chunksize\t= crypto_skcipher_alg_chunksize(skcipher_alg);\n\t\tskcipher_inst->alg.walksize\t= crypto_skcipher_alg_walksize(skcipher_alg);\n\n\t\tskcipher_inst->free\t\t= essiv_skcipher_free_instance;\n\n\t\terr = skcipher_register_instance(tmpl, skcipher_inst);\n\t} else {\n\t\taead_inst->alg.setkey\t\t= essiv_aead_setkey;\n\t\taead_inst->alg.setauthsize\t= essiv_aead_setauthsize;\n\t\taead_inst->alg.encrypt\t\t= essiv_aead_encrypt;\n\t\taead_inst->alg.decrypt\t\t= essiv_aead_decrypt;\n\t\taead_inst->alg.init\t\t= essiv_aead_init_tfm;\n\t\taead_inst->alg.exit\t\t= essiv_aead_exit_tfm;\n\n\t\taead_inst->alg.ivsize\t\t= ivsize;\n\t\taead_inst->alg.maxauthsize\t= crypto_aead_alg_maxauthsize(aead_alg);\n\t\taead_inst->alg.chunksize\t= crypto_aead_alg_chunksize(aead_alg);\n\n\t\taead_inst->free\t\t\t= essiv_aead_free_instance;\n\n\t\terr = aead_register_instance(tmpl, aead_inst);\n\t}\n\n\tif (err)\n\t\tgoto out_free_hash;\n\n\tcrypto_mod_put(_hash_alg);\n\treturn 0;\n\nout_free_hash:\n\tcrypto_mod_put(_hash_alg);\nout_drop_skcipher:\n\tif (type == CRYPTO_ALG_TYPE_SKCIPHER)\n\t\tcrypto_drop_skcipher(&ictx->u.skcipher_spawn);\n\telse\n\t\tcrypto_drop_aead(&ictx->u.aead_spawn);\nout_free_inst:\n\tkfree(skcipher_inst);\n\tkfree(aead_inst);\n\treturn err;\n}\n\n \nstatic struct crypto_template essiv_tmpl = {\n\t.name\t= \"essiv\",\n\t.create\t= essiv_create,\n\t.module\t= THIS_MODULE,\n};\n\nstatic int __init essiv_module_init(void)\n{\n\treturn crypto_register_template(&essiv_tmpl);\n}\n\nstatic void __exit essiv_module_exit(void)\n{\n\tcrypto_unregister_template(&essiv_tmpl);\n}\n\nsubsys_initcall(essiv_module_init);\nmodule_exit(essiv_module_exit);\n\nMODULE_DESCRIPTION(\"ESSIV skcipher/aead wrapper for block encryption\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS_CRYPTO(\"essiv\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}