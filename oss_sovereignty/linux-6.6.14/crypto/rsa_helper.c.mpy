{
  "module_name": "rsa_helper.c",
  "hash_id": "111a88f0e29a57db086793fe85f104d83d8d177362f0a8f70fa715f53051835e",
  "original_prompt": "Ingested from linux-6.6.14/crypto/rsa_helper.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/fips.h>\n#include <crypto/internal/rsa.h>\n#include \"rsapubkey.asn1.h\"\n#include \"rsaprivkey.asn1.h\"\n\nint rsa_get_n(void *context, size_t hdrlen, unsigned char tag,\n\t      const void *value, size_t vlen)\n{\n\tstruct rsa_key *key = context;\n\tconst u8 *ptr = value;\n\tsize_t n_sz = vlen;\n\n\t \n\tif (!value || !vlen)\n\t\treturn -EINVAL;\n\n\tif (fips_enabled) {\n\t\twhile (n_sz && !*ptr) {\n\t\t\tptr++;\n\t\t\tn_sz--;\n\t\t}\n\n\t\t \n\t\tif (n_sz < 256) {\n\t\t\tpr_err(\"RSA: key size not allowed in FIPS mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tkey->n = value;\n\tkey->n_sz = vlen;\n\n\treturn 0;\n}\n\nint rsa_get_e(void *context, size_t hdrlen, unsigned char tag,\n\t      const void *value, size_t vlen)\n{\n\tstruct rsa_key *key = context;\n\n\t \n\tif (!value || !key->n_sz || !vlen || vlen > key->n_sz)\n\t\treturn -EINVAL;\n\n\tkey->e = value;\n\tkey->e_sz = vlen;\n\n\treturn 0;\n}\n\nint rsa_get_d(void *context, size_t hdrlen, unsigned char tag,\n\t      const void *value, size_t vlen)\n{\n\tstruct rsa_key *key = context;\n\n\t \n\tif (!value || !key->n_sz || !vlen || vlen > key->n_sz)\n\t\treturn -EINVAL;\n\n\tkey->d = value;\n\tkey->d_sz = vlen;\n\n\treturn 0;\n}\n\nint rsa_get_p(void *context, size_t hdrlen, unsigned char tag,\n\t      const void *value, size_t vlen)\n{\n\tstruct rsa_key *key = context;\n\n\t \n\tif (!value || !vlen || vlen > key->n_sz)\n\t\treturn -EINVAL;\n\n\tkey->p = value;\n\tkey->p_sz = vlen;\n\n\treturn 0;\n}\n\nint rsa_get_q(void *context, size_t hdrlen, unsigned char tag,\n\t      const void *value, size_t vlen)\n{\n\tstruct rsa_key *key = context;\n\n\t \n\tif (!value || !vlen || vlen > key->n_sz)\n\t\treturn -EINVAL;\n\n\tkey->q = value;\n\tkey->q_sz = vlen;\n\n\treturn 0;\n}\n\nint rsa_get_dp(void *context, size_t hdrlen, unsigned char tag,\n\t       const void *value, size_t vlen)\n{\n\tstruct rsa_key *key = context;\n\n\t \n\tif (!value || !vlen || vlen > key->n_sz)\n\t\treturn -EINVAL;\n\n\tkey->dp = value;\n\tkey->dp_sz = vlen;\n\n\treturn 0;\n}\n\nint rsa_get_dq(void *context, size_t hdrlen, unsigned char tag,\n\t       const void *value, size_t vlen)\n{\n\tstruct rsa_key *key = context;\n\n\t \n\tif (!value || !vlen || vlen > key->n_sz)\n\t\treturn -EINVAL;\n\n\tkey->dq = value;\n\tkey->dq_sz = vlen;\n\n\treturn 0;\n}\n\nint rsa_get_qinv(void *context, size_t hdrlen, unsigned char tag,\n\t\t const void *value, size_t vlen)\n{\n\tstruct rsa_key *key = context;\n\n\t \n\tif (!value || !vlen || vlen > key->n_sz)\n\t\treturn -EINVAL;\n\n\tkey->qinv = value;\n\tkey->qinv_sz = vlen;\n\n\treturn 0;\n}\n\n \nint rsa_parse_pub_key(struct rsa_key *rsa_key, const void *key,\n\t\t      unsigned int key_len)\n{\n\treturn asn1_ber_decoder(&rsapubkey_decoder, rsa_key, key, key_len);\n}\nEXPORT_SYMBOL_GPL(rsa_parse_pub_key);\n\n \nint rsa_parse_priv_key(struct rsa_key *rsa_key, const void *key,\n\t\t       unsigned int key_len)\n{\n\treturn asn1_ber_decoder(&rsaprivkey_decoder, rsa_key, key, key_len);\n}\nEXPORT_SYMBOL_GPL(rsa_parse_priv_key);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}