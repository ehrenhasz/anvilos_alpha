{
  "module_name": "sha3_generic.c",
  "hash_id": "d4ebd5c7199b6cd490eabf460d360187bec09e64267dc1eae5d05736fd96d9fa",
  "original_prompt": "Ingested from linux-6.6.14/crypto/sha3_generic.c",
  "human_readable_source": "\n \n#include <crypto/internal/hash.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <crypto/sha3.h>\n#include <asm/unaligned.h>\n\n \n#ifdef CONFIG_64BIT\n#define SHA3_INLINE\tinline\n#else\n#define SHA3_INLINE\tnoinline\n#endif\n\n#define KECCAK_ROUNDS 24\n\nstatic const u64 keccakf_rndc[24] = {\n\t0x0000000000000001ULL, 0x0000000000008082ULL, 0x800000000000808aULL,\n\t0x8000000080008000ULL, 0x000000000000808bULL, 0x0000000080000001ULL,\n\t0x8000000080008081ULL, 0x8000000000008009ULL, 0x000000000000008aULL,\n\t0x0000000000000088ULL, 0x0000000080008009ULL, 0x000000008000000aULL,\n\t0x000000008000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL,\n\t0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL,\n\t0x000000000000800aULL, 0x800000008000000aULL, 0x8000000080008081ULL,\n\t0x8000000000008080ULL, 0x0000000080000001ULL, 0x8000000080008008ULL\n};\n\n \n\nstatic SHA3_INLINE void keccakf_round(u64 st[25])\n{\n\tu64 t[5], tt, bc[5];\n\n\t \n\tbc[0] = st[0] ^ st[5] ^ st[10] ^ st[15] ^ st[20];\n\tbc[1] = st[1] ^ st[6] ^ st[11] ^ st[16] ^ st[21];\n\tbc[2] = st[2] ^ st[7] ^ st[12] ^ st[17] ^ st[22];\n\tbc[3] = st[3] ^ st[8] ^ st[13] ^ st[18] ^ st[23];\n\tbc[4] = st[4] ^ st[9] ^ st[14] ^ st[19] ^ st[24];\n\n\tt[0] = bc[4] ^ rol64(bc[1], 1);\n\tt[1] = bc[0] ^ rol64(bc[2], 1);\n\tt[2] = bc[1] ^ rol64(bc[3], 1);\n\tt[3] = bc[2] ^ rol64(bc[4], 1);\n\tt[4] = bc[3] ^ rol64(bc[0], 1);\n\n\tst[0] ^= t[0];\n\n\t \n\ttt = st[1];\n\tst[ 1] = rol64(st[ 6] ^ t[1], 44);\n\tst[ 6] = rol64(st[ 9] ^ t[4], 20);\n\tst[ 9] = rol64(st[22] ^ t[2], 61);\n\tst[22] = rol64(st[14] ^ t[4], 39);\n\tst[14] = rol64(st[20] ^ t[0], 18);\n\tst[20] = rol64(st[ 2] ^ t[2], 62);\n\tst[ 2] = rol64(st[12] ^ t[2], 43);\n\tst[12] = rol64(st[13] ^ t[3], 25);\n\tst[13] = rol64(st[19] ^ t[4],  8);\n\tst[19] = rol64(st[23] ^ t[3], 56);\n\tst[23] = rol64(st[15] ^ t[0], 41);\n\tst[15] = rol64(st[ 4] ^ t[4], 27);\n\tst[ 4] = rol64(st[24] ^ t[4], 14);\n\tst[24] = rol64(st[21] ^ t[1],  2);\n\tst[21] = rol64(st[ 8] ^ t[3], 55);\n\tst[ 8] = rol64(st[16] ^ t[1], 45);\n\tst[16] = rol64(st[ 5] ^ t[0], 36);\n\tst[ 5] = rol64(st[ 3] ^ t[3], 28);\n\tst[ 3] = rol64(st[18] ^ t[3], 21);\n\tst[18] = rol64(st[17] ^ t[2], 15);\n\tst[17] = rol64(st[11] ^ t[1], 10);\n\tst[11] = rol64(st[ 7] ^ t[2],  6);\n\tst[ 7] = rol64(st[10] ^ t[0],  3);\n\tst[10] = rol64(    tt ^ t[1],  1);\n\n\t \n\tbc[ 0] = ~st[ 1] & st[ 2];\n\tbc[ 1] = ~st[ 2] & st[ 3];\n\tbc[ 2] = ~st[ 3] & st[ 4];\n\tbc[ 3] = ~st[ 4] & st[ 0];\n\tbc[ 4] = ~st[ 0] & st[ 1];\n\tst[ 0] ^= bc[ 0];\n\tst[ 1] ^= bc[ 1];\n\tst[ 2] ^= bc[ 2];\n\tst[ 3] ^= bc[ 3];\n\tst[ 4] ^= bc[ 4];\n\n\tbc[ 0] = ~st[ 6] & st[ 7];\n\tbc[ 1] = ~st[ 7] & st[ 8];\n\tbc[ 2] = ~st[ 8] & st[ 9];\n\tbc[ 3] = ~st[ 9] & st[ 5];\n\tbc[ 4] = ~st[ 5] & st[ 6];\n\tst[ 5] ^= bc[ 0];\n\tst[ 6] ^= bc[ 1];\n\tst[ 7] ^= bc[ 2];\n\tst[ 8] ^= bc[ 3];\n\tst[ 9] ^= bc[ 4];\n\n\tbc[ 0] = ~st[11] & st[12];\n\tbc[ 1] = ~st[12] & st[13];\n\tbc[ 2] = ~st[13] & st[14];\n\tbc[ 3] = ~st[14] & st[10];\n\tbc[ 4] = ~st[10] & st[11];\n\tst[10] ^= bc[ 0];\n\tst[11] ^= bc[ 1];\n\tst[12] ^= bc[ 2];\n\tst[13] ^= bc[ 3];\n\tst[14] ^= bc[ 4];\n\n\tbc[ 0] = ~st[16] & st[17];\n\tbc[ 1] = ~st[17] & st[18];\n\tbc[ 2] = ~st[18] & st[19];\n\tbc[ 3] = ~st[19] & st[15];\n\tbc[ 4] = ~st[15] & st[16];\n\tst[15] ^= bc[ 0];\n\tst[16] ^= bc[ 1];\n\tst[17] ^= bc[ 2];\n\tst[18] ^= bc[ 3];\n\tst[19] ^= bc[ 4];\n\n\tbc[ 0] = ~st[21] & st[22];\n\tbc[ 1] = ~st[22] & st[23];\n\tbc[ 2] = ~st[23] & st[24];\n\tbc[ 3] = ~st[24] & st[20];\n\tbc[ 4] = ~st[20] & st[21];\n\tst[20] ^= bc[ 0];\n\tst[21] ^= bc[ 1];\n\tst[22] ^= bc[ 2];\n\tst[23] ^= bc[ 3];\n\tst[24] ^= bc[ 4];\n}\n\nstatic void keccakf(u64 st[25])\n{\n\tint round;\n\n\tfor (round = 0; round < KECCAK_ROUNDS; round++) {\n\t\tkeccakf_round(st);\n\t\t \n\t\tst[0] ^= keccakf_rndc[round];\n\t}\n}\n\nint crypto_sha3_init(struct shash_desc *desc)\n{\n\tstruct sha3_state *sctx = shash_desc_ctx(desc);\n\tunsigned int digest_size = crypto_shash_digestsize(desc->tfm);\n\n\tsctx->rsiz = 200 - 2 * digest_size;\n\tsctx->rsizw = sctx->rsiz / 8;\n\tsctx->partial = 0;\n\n\tmemset(sctx->st, 0, sizeof(sctx->st));\n\treturn 0;\n}\nEXPORT_SYMBOL(crypto_sha3_init);\n\nint crypto_sha3_update(struct shash_desc *desc, const u8 *data,\n\t\t       unsigned int len)\n{\n\tstruct sha3_state *sctx = shash_desc_ctx(desc);\n\tunsigned int done;\n\tconst u8 *src;\n\n\tdone = 0;\n\tsrc = data;\n\n\tif ((sctx->partial + len) > (sctx->rsiz - 1)) {\n\t\tif (sctx->partial) {\n\t\t\tdone = -sctx->partial;\n\t\t\tmemcpy(sctx->buf + sctx->partial, data,\n\t\t\t       done + sctx->rsiz);\n\t\t\tsrc = sctx->buf;\n\t\t}\n\n\t\tdo {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i = 0; i < sctx->rsizw; i++)\n\t\t\t\tsctx->st[i] ^= get_unaligned_le64(src + 8 * i);\n\t\t\tkeccakf(sctx->st);\n\n\t\t\tdone += sctx->rsiz;\n\t\t\tsrc = data + done;\n\t\t} while (done + (sctx->rsiz - 1) < len);\n\n\t\tsctx->partial = 0;\n\t}\n\tmemcpy(sctx->buf + sctx->partial, src, len - done);\n\tsctx->partial += (len - done);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(crypto_sha3_update);\n\nint crypto_sha3_final(struct shash_desc *desc, u8 *out)\n{\n\tstruct sha3_state *sctx = shash_desc_ctx(desc);\n\tunsigned int i, inlen = sctx->partial;\n\tunsigned int digest_size = crypto_shash_digestsize(desc->tfm);\n\t__le64 *digest = (__le64 *)out;\n\n\tsctx->buf[inlen++] = 0x06;\n\tmemset(sctx->buf + inlen, 0, sctx->rsiz - inlen);\n\tsctx->buf[sctx->rsiz - 1] |= 0x80;\n\n\tfor (i = 0; i < sctx->rsizw; i++)\n\t\tsctx->st[i] ^= get_unaligned_le64(sctx->buf + 8 * i);\n\n\tkeccakf(sctx->st);\n\n\tfor (i = 0; i < digest_size / 8; i++)\n\t\tput_unaligned_le64(sctx->st[i], digest++);\n\n\tif (digest_size & 4)\n\t\tput_unaligned_le32(sctx->st[i], (__le32 *)digest);\n\n\tmemset(sctx, 0, sizeof(*sctx));\n\treturn 0;\n}\nEXPORT_SYMBOL(crypto_sha3_final);\n\nstatic struct shash_alg algs[] = { {\n\t.digestsize\t\t= SHA3_224_DIGEST_SIZE,\n\t.init\t\t\t= crypto_sha3_init,\n\t.update\t\t\t= crypto_sha3_update,\n\t.final\t\t\t= crypto_sha3_final,\n\t.descsize\t\t= sizeof(struct sha3_state),\n\t.base.cra_name\t\t= \"sha3-224\",\n\t.base.cra_driver_name\t= \"sha3-224-generic\",\n\t.base.cra_blocksize\t= SHA3_224_BLOCK_SIZE,\n\t.base.cra_module\t= THIS_MODULE,\n}, {\n\t.digestsize\t\t= SHA3_256_DIGEST_SIZE,\n\t.init\t\t\t= crypto_sha3_init,\n\t.update\t\t\t= crypto_sha3_update,\n\t.final\t\t\t= crypto_sha3_final,\n\t.descsize\t\t= sizeof(struct sha3_state),\n\t.base.cra_name\t\t= \"sha3-256\",\n\t.base.cra_driver_name\t= \"sha3-256-generic\",\n\t.base.cra_blocksize\t= SHA3_256_BLOCK_SIZE,\n\t.base.cra_module\t= THIS_MODULE,\n}, {\n\t.digestsize\t\t= SHA3_384_DIGEST_SIZE,\n\t.init\t\t\t= crypto_sha3_init,\n\t.update\t\t\t= crypto_sha3_update,\n\t.final\t\t\t= crypto_sha3_final,\n\t.descsize\t\t= sizeof(struct sha3_state),\n\t.base.cra_name\t\t= \"sha3-384\",\n\t.base.cra_driver_name\t= \"sha3-384-generic\",\n\t.base.cra_blocksize\t= SHA3_384_BLOCK_SIZE,\n\t.base.cra_module\t= THIS_MODULE,\n}, {\n\t.digestsize\t\t= SHA3_512_DIGEST_SIZE,\n\t.init\t\t\t= crypto_sha3_init,\n\t.update\t\t\t= crypto_sha3_update,\n\t.final\t\t\t= crypto_sha3_final,\n\t.descsize\t\t= sizeof(struct sha3_state),\n\t.base.cra_name\t\t= \"sha3-512\",\n\t.base.cra_driver_name\t= \"sha3-512-generic\",\n\t.base.cra_blocksize\t= SHA3_512_BLOCK_SIZE,\n\t.base.cra_module\t= THIS_MODULE,\n} };\n\nstatic int __init sha3_generic_mod_init(void)\n{\n\treturn crypto_register_shashes(algs, ARRAY_SIZE(algs));\n}\n\nstatic void __exit sha3_generic_mod_fini(void)\n{\n\tcrypto_unregister_shashes(algs, ARRAY_SIZE(algs));\n}\n\nsubsys_initcall(sha3_generic_mod_init);\nmodule_exit(sha3_generic_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"SHA-3 Secure Hash Algorithm\");\n\nMODULE_ALIAS_CRYPTO(\"sha3-224\");\nMODULE_ALIAS_CRYPTO(\"sha3-224-generic\");\nMODULE_ALIAS_CRYPTO(\"sha3-256\");\nMODULE_ALIAS_CRYPTO(\"sha3-256-generic\");\nMODULE_ALIAS_CRYPTO(\"sha3-384\");\nMODULE_ALIAS_CRYPTO(\"sha3-384-generic\");\nMODULE_ALIAS_CRYPTO(\"sha3-512\");\nMODULE_ALIAS_CRYPTO(\"sha3-512-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}