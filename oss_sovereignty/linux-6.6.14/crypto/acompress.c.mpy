{
  "module_name": "acompress.c",
  "hash_id": "153e104c1cb0169af8defe4788a8280492127c69f183fbf28a7bca776f0b7b71",
  "original_prompt": "Ingested from linux-6.6.14/crypto/acompress.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/acompress.h>\n#include <linux/cryptouser.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <net/netlink.h>\n\n#include \"compress.h\"\n\nstruct crypto_scomp;\n\nstatic const struct crypto_type crypto_acomp_type;\n\nstatic inline struct acomp_alg *__crypto_acomp_alg(struct crypto_alg *alg)\n{\n\treturn container_of(alg, struct acomp_alg, calg.base);\n}\n\nstatic inline struct acomp_alg *crypto_acomp_alg(struct crypto_acomp *tfm)\n{\n\treturn __crypto_acomp_alg(crypto_acomp_tfm(tfm)->__crt_alg);\n}\n\nstatic int __maybe_unused crypto_acomp_report(\n\tstruct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\n\tmemset(&racomp, 0, sizeof(racomp));\n\n\tstrscpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_ACOMP, sizeof(racomp), &racomp);\n}\n\nstatic void crypto_acomp_show(struct seq_file *m, struct crypto_alg *alg)\n\t__maybe_unused;\n\nstatic void crypto_acomp_show(struct seq_file *m, struct crypto_alg *alg)\n{\n\tseq_puts(m, \"type         : acomp\\n\");\n}\n\nstatic void crypto_acomp_exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_acomp *acomp = __crypto_acomp_tfm(tfm);\n\tstruct acomp_alg *alg = crypto_acomp_alg(acomp);\n\n\talg->exit(acomp);\n}\n\nstatic int crypto_acomp_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_acomp *acomp = __crypto_acomp_tfm(tfm);\n\tstruct acomp_alg *alg = crypto_acomp_alg(acomp);\n\n\tif (tfm->__crt_alg->cra_type != &crypto_acomp_type)\n\t\treturn crypto_init_scomp_ops_async(tfm);\n\n\tacomp->compress = alg->compress;\n\tacomp->decompress = alg->decompress;\n\tacomp->dst_free = alg->dst_free;\n\tacomp->reqsize = alg->reqsize;\n\n\tif (alg->exit)\n\t\tacomp->base.exit = crypto_acomp_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(acomp);\n\n\treturn 0;\n}\n\nstatic unsigned int crypto_acomp_extsize(struct crypto_alg *alg)\n{\n\tint extsize = crypto_alg_extsize(alg);\n\n\tif (alg->cra_type != &crypto_acomp_type)\n\t\textsize += sizeof(struct crypto_scomp *);\n\n\treturn extsize;\n}\n\nstatic inline int __crypto_acomp_report_stat(struct sk_buff *skb,\n\t\t\t\t\t     struct crypto_alg *alg)\n{\n\tstruct comp_alg_common *calg = __crypto_comp_alg_common(alg);\n\tstruct crypto_istat_compress *istat = comp_get_stat(calg);\n\tstruct crypto_stat_compress racomp;\n\n\tmemset(&racomp, 0, sizeof(racomp));\n\n\tstrscpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\tracomp.stat_compress_cnt = atomic64_read(&istat->compress_cnt);\n\tracomp.stat_compress_tlen = atomic64_read(&istat->compress_tlen);\n\tracomp.stat_decompress_cnt =  atomic64_read(&istat->decompress_cnt);\n\tracomp.stat_decompress_tlen = atomic64_read(&istat->decompress_tlen);\n\tracomp.stat_err_cnt = atomic64_read(&istat->err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_ACOMP, sizeof(racomp), &racomp);\n}\n\n#ifdef CONFIG_CRYPTO_STATS\nint crypto_acomp_report_stat(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\treturn __crypto_acomp_report_stat(skb, alg);\n}\n#endif\n\nstatic const struct crypto_type crypto_acomp_type = {\n\t.extsize = crypto_acomp_extsize,\n\t.init_tfm = crypto_acomp_init_tfm,\n#ifdef CONFIG_PROC_FS\n\t.show = crypto_acomp_show,\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_USER)\n\t.report = crypto_acomp_report,\n#endif\n#ifdef CONFIG_CRYPTO_STATS\n\t.report_stat = crypto_acomp_report_stat,\n#endif\n\t.maskclear = ~CRYPTO_ALG_TYPE_MASK,\n\t.maskset = CRYPTO_ALG_TYPE_ACOMPRESS_MASK,\n\t.type = CRYPTO_ALG_TYPE_ACOMPRESS,\n\t.tfmsize = offsetof(struct crypto_acomp, base),\n};\n\nstruct crypto_acomp *crypto_alloc_acomp(const char *alg_name, u32 type,\n\t\t\t\t\tu32 mask)\n{\n\treturn crypto_alloc_tfm(alg_name, &crypto_acomp_type, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_alloc_acomp);\n\nstruct crypto_acomp *crypto_alloc_acomp_node(const char *alg_name, u32 type,\n\t\t\t\t\tu32 mask, int node)\n{\n\treturn crypto_alloc_tfm_node(alg_name, &crypto_acomp_type, type, mask,\n\t\t\t\tnode);\n}\nEXPORT_SYMBOL_GPL(crypto_alloc_acomp_node);\n\nstruct acomp_req *acomp_request_alloc(struct crypto_acomp *acomp)\n{\n\tstruct crypto_tfm *tfm = crypto_acomp_tfm(acomp);\n\tstruct acomp_req *req;\n\n\treq = __acomp_request_alloc(acomp);\n\tif (req && (tfm->__crt_alg->cra_type != &crypto_acomp_type))\n\t\treturn crypto_acomp_scomp_alloc_ctx(req);\n\n\treturn req;\n}\nEXPORT_SYMBOL_GPL(acomp_request_alloc);\n\nvoid acomp_request_free(struct acomp_req *req)\n{\n\tstruct crypto_acomp *acomp = crypto_acomp_reqtfm(req);\n\tstruct crypto_tfm *tfm = crypto_acomp_tfm(acomp);\n\n\tif (tfm->__crt_alg->cra_type != &crypto_acomp_type)\n\t\tcrypto_acomp_scomp_free_ctx(req);\n\n\tif (req->flags & CRYPTO_ACOMP_ALLOC_OUTPUT) {\n\t\tacomp->dst_free(req->dst);\n\t\treq->dst = NULL;\n\t}\n\n\t__acomp_request_free(req);\n}\nEXPORT_SYMBOL_GPL(acomp_request_free);\n\nvoid comp_prepare_alg(struct comp_alg_common *alg)\n{\n\tstruct crypto_istat_compress *istat = comp_get_stat(alg);\n\tstruct crypto_alg *base = &alg->base;\n\n\tbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_STATS))\n\t\tmemset(istat, 0, sizeof(*istat));\n}\n\nint crypto_register_acomp(struct acomp_alg *alg)\n{\n\tstruct crypto_alg *base = &alg->calg.base;\n\n\tcomp_prepare_alg(&alg->calg);\n\n\tbase->cra_type = &crypto_acomp_type;\n\tbase->cra_flags |= CRYPTO_ALG_TYPE_ACOMPRESS;\n\n\treturn crypto_register_alg(base);\n}\nEXPORT_SYMBOL_GPL(crypto_register_acomp);\n\nvoid crypto_unregister_acomp(struct acomp_alg *alg)\n{\n\tcrypto_unregister_alg(&alg->base);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_acomp);\n\nint crypto_register_acomps(struct acomp_alg *algs, int count)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = crypto_register_acomp(&algs[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (--i; i >= 0; --i)\n\t\tcrypto_unregister_acomp(&algs[i]);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(crypto_register_acomps);\n\nvoid crypto_unregister_acomps(struct acomp_alg *algs, int count)\n{\n\tint i;\n\n\tfor (i = count - 1; i >= 0; --i)\n\t\tcrypto_unregister_acomp(&algs[i]);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_acomps);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Asynchronous compression type\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}