{
  "module_name": "hmac.c",
  "hash_id": "c7dd5268adc8f7dd7fd60d0aebbe1d52d8ac58184d442844262f4068fe11558d",
  "original_prompt": "Ingested from linux-6.6.14/crypto/hmac.c",
  "human_readable_source": "\n \n\n#include <crypto/hmac.h>\n#include <crypto/internal/hash.h>\n#include <crypto/scatterwalk.h>\n#include <linux/err.h>\n#include <linux/fips.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/string.h>\n\nstruct hmac_ctx {\n\tstruct crypto_shash *hash;\n};\n\nstatic inline void *align_ptr(void *p, unsigned int align)\n{\n\treturn (void *)ALIGN((unsigned long)p, align);\n}\n\nstatic inline struct hmac_ctx *hmac_ctx(struct crypto_shash *tfm)\n{\n\treturn align_ptr(crypto_shash_ctx_aligned(tfm) +\n\t\t\t crypto_shash_statesize(tfm) * 2,\n\t\t\t crypto_tfm_ctx_alignment());\n}\n\nstatic int hmac_setkey(struct crypto_shash *parent,\n\t\t       const u8 *inkey, unsigned int keylen)\n{\n\tint bs = crypto_shash_blocksize(parent);\n\tint ds = crypto_shash_digestsize(parent);\n\tint ss = crypto_shash_statesize(parent);\n\tchar *ipad = crypto_shash_ctx_aligned(parent);\n\tchar *opad = ipad + ss;\n\tstruct hmac_ctx *ctx = align_ptr(opad + ss,\n\t\t\t\t\t crypto_tfm_ctx_alignment());\n\tstruct crypto_shash *hash = ctx->hash;\n\tSHASH_DESC_ON_STACK(shash, hash);\n\tunsigned int i;\n\n\tif (fips_enabled && (keylen < 112 / 8))\n\t\treturn -EINVAL;\n\n\tshash->tfm = hash;\n\n\tif (keylen > bs) {\n\t\tint err;\n\n\t\terr = crypto_shash_digest(shash, inkey, keylen, ipad);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tkeylen = ds;\n\t} else\n\t\tmemcpy(ipad, inkey, keylen);\n\n\tmemset(ipad + keylen, 0, bs - keylen);\n\tmemcpy(opad, ipad, bs);\n\n\tfor (i = 0; i < bs; i++) {\n\t\tipad[i] ^= HMAC_IPAD_VALUE;\n\t\topad[i] ^= HMAC_OPAD_VALUE;\n\t}\n\n\treturn crypto_shash_init(shash) ?:\n\t       crypto_shash_update(shash, ipad, bs) ?:\n\t       crypto_shash_export(shash, ipad) ?:\n\t       crypto_shash_init(shash) ?:\n\t       crypto_shash_update(shash, opad, bs) ?:\n\t       crypto_shash_export(shash, opad);\n}\n\nstatic int hmac_export(struct shash_desc *pdesc, void *out)\n{\n\tstruct shash_desc *desc = shash_desc_ctx(pdesc);\n\n\treturn crypto_shash_export(desc, out);\n}\n\nstatic int hmac_import(struct shash_desc *pdesc, const void *in)\n{\n\tstruct shash_desc *desc = shash_desc_ctx(pdesc);\n\tstruct hmac_ctx *ctx = hmac_ctx(pdesc->tfm);\n\n\tdesc->tfm = ctx->hash;\n\n\treturn crypto_shash_import(desc, in);\n}\n\nstatic int hmac_init(struct shash_desc *pdesc)\n{\n\treturn hmac_import(pdesc, crypto_shash_ctx_aligned(pdesc->tfm));\n}\n\nstatic int hmac_update(struct shash_desc *pdesc,\n\t\t       const u8 *data, unsigned int nbytes)\n{\n\tstruct shash_desc *desc = shash_desc_ctx(pdesc);\n\n\treturn crypto_shash_update(desc, data, nbytes);\n}\n\nstatic int hmac_final(struct shash_desc *pdesc, u8 *out)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tint ds = crypto_shash_digestsize(parent);\n\tint ss = crypto_shash_statesize(parent);\n\tchar *opad = crypto_shash_ctx_aligned(parent) + ss;\n\tstruct shash_desc *desc = shash_desc_ctx(pdesc);\n\n\treturn crypto_shash_final(desc, out) ?:\n\t       crypto_shash_import(desc, opad) ?:\n\t       crypto_shash_finup(desc, out, ds, out);\n}\n\nstatic int hmac_finup(struct shash_desc *pdesc, const u8 *data,\n\t\t      unsigned int nbytes, u8 *out)\n{\n\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tint ds = crypto_shash_digestsize(parent);\n\tint ss = crypto_shash_statesize(parent);\n\tchar *opad = crypto_shash_ctx_aligned(parent) + ss;\n\tstruct shash_desc *desc = shash_desc_ctx(pdesc);\n\n\treturn crypto_shash_finup(desc, data, nbytes, out) ?:\n\t       crypto_shash_import(desc, opad) ?:\n\t       crypto_shash_finup(desc, out, ds, out);\n}\n\nstatic int hmac_init_tfm(struct crypto_shash *parent)\n{\n\tstruct crypto_shash *hash;\n\tstruct shash_instance *inst = shash_alg_instance(parent);\n\tstruct crypto_shash_spawn *spawn = shash_instance_ctx(inst);\n\tstruct hmac_ctx *ctx = hmac_ctx(parent);\n\n\thash = crypto_spawn_shash(spawn);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\n\tparent->descsize = sizeof(struct shash_desc) +\n\t\t\t   crypto_shash_descsize(hash);\n\n\tctx->hash = hash;\n\treturn 0;\n}\n\nstatic int hmac_clone_tfm(struct crypto_shash *dst, struct crypto_shash *src)\n{\n\tstruct hmac_ctx *sctx = hmac_ctx(src);\n\tstruct hmac_ctx *dctx = hmac_ctx(dst);\n\tstruct crypto_shash *hash;\n\n\thash = crypto_clone_shash(sctx->hash);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\n\tdctx->hash = hash;\n\treturn 0;\n}\n\nstatic void hmac_exit_tfm(struct crypto_shash *parent)\n{\n\tstruct hmac_ctx *ctx = hmac_ctx(parent);\n\n\tcrypto_free_shash(ctx->hash);\n}\n\nstatic int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_shash_spawn *spawn;\n\tstruct crypto_alg *alg;\n\tstruct shash_alg *salg;\n\tu32 mask;\n\tint err;\n\tint ds;\n\tint ss;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tspawn = shash_instance_ctx(inst);\n\n\terr = crypto_grab_shash(spawn, shash_crypto_instance(inst),\n\t\t\t\tcrypto_attr_alg_name(tb[1]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\tsalg = crypto_spawn_shash_alg(spawn);\n\talg = &salg->base;\n\n\t \n\terr = -EINVAL;\n\tif (crypto_shash_alg_needs_key(salg))\n\t\tgoto err_free_inst;\n\n\tds = salg->digestsize;\n\tss = salg->statesize;\n\tif (ds > alg->cra_blocksize ||\n\t    ss < alg->cra_blocksize)\n\t\tgoto err_free_inst;\n\n\terr = crypto_inst_setname(shash_crypto_instance(inst), tmpl->name, alg);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = alg->cra_blocksize;\n\tinst->alg.base.cra_alignmask = alg->cra_alignmask;\n\n\tss = ALIGN(ss, alg->cra_alignmask + 1);\n\tinst->alg.digestsize = ds;\n\tinst->alg.statesize = ss;\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +\n\t\t\t\t     ALIGN(ss * 2, crypto_tfm_ctx_alignment());\n\n\tinst->alg.init = hmac_init;\n\tinst->alg.update = hmac_update;\n\tinst->alg.final = hmac_final;\n\tinst->alg.finup = hmac_finup;\n\tinst->alg.export = hmac_export;\n\tinst->alg.import = hmac_import;\n\tinst->alg.setkey = hmac_setkey;\n\tinst->alg.init_tfm = hmac_init_tfm;\n\tinst->alg.clone_tfm = hmac_clone_tfm;\n\tinst->alg.exit_tfm = hmac_exit_tfm;\n\n\tinst->free = shash_free_singlespawn_instance;\n\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tshash_free_singlespawn_instance(inst);\n\t}\n\treturn err;\n}\n\nstatic struct crypto_template hmac_tmpl = {\n\t.name = \"hmac\",\n\t.create = hmac_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init hmac_module_init(void)\n{\n\treturn crypto_register_template(&hmac_tmpl);\n}\n\nstatic void __exit hmac_module_exit(void)\n{\n\tcrypto_unregister_template(&hmac_tmpl);\n}\n\nsubsys_initcall(hmac_module_init);\nmodule_exit(hmac_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"HMAC hash algorithm\");\nMODULE_ALIAS_CRYPTO(\"hmac\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}