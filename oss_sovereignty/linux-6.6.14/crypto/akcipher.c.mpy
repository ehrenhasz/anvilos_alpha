{
  "module_name": "akcipher.c",
  "hash_id": "1e7722ada106025203298283941fb64a218a18deca8a4bee7362502a19074f8d",
  "original_prompt": "Ingested from linux-6.6.14/crypto/akcipher.c",
  "human_readable_source": "\n \n#include <crypto/internal/akcipher.h>\n#include <linux/cryptouser.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <net/netlink.h>\n\n#include \"internal.h\"\n\n#define CRYPTO_ALG_TYPE_AHASH_MASK\t0x0000000e\n\nstatic int __maybe_unused crypto_akcipher_report(\n\tstruct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\n\tmemset(&rakcipher, 0, sizeof(rakcipher));\n\n\tstrscpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t       sizeof(rakcipher), &rakcipher);\n}\n\nstatic void crypto_akcipher_show(struct seq_file *m, struct crypto_alg *alg)\n\t__maybe_unused;\n\nstatic void crypto_akcipher_show(struct seq_file *m, struct crypto_alg *alg)\n{\n\tseq_puts(m, \"type         : akcipher\\n\");\n}\n\nstatic void crypto_akcipher_exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_akcipher *akcipher = __crypto_akcipher_tfm(tfm);\n\tstruct akcipher_alg *alg = crypto_akcipher_alg(akcipher);\n\n\talg->exit(akcipher);\n}\n\nstatic int crypto_akcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_akcipher *akcipher = __crypto_akcipher_tfm(tfm);\n\tstruct akcipher_alg *alg = crypto_akcipher_alg(akcipher);\n\n\tif (alg->exit)\n\t\takcipher->base.exit = crypto_akcipher_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(akcipher);\n\n\treturn 0;\n}\n\nstatic void crypto_akcipher_free_instance(struct crypto_instance *inst)\n{\n\tstruct akcipher_instance *akcipher = akcipher_instance(inst);\n\n\takcipher->free(akcipher);\n}\n\nstatic int __maybe_unused crypto_akcipher_report_stat(\n\tstruct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct akcipher_alg *akcipher = __crypto_akcipher_alg(alg);\n\tstruct crypto_istat_akcipher *istat;\n\tstruct crypto_stat_akcipher rakcipher;\n\n\tistat = akcipher_get_stat(akcipher);\n\n\tmemset(&rakcipher, 0, sizeof(rakcipher));\n\n\tstrscpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\trakcipher.stat_encrypt_cnt = atomic64_read(&istat->encrypt_cnt);\n\trakcipher.stat_encrypt_tlen = atomic64_read(&istat->encrypt_tlen);\n\trakcipher.stat_decrypt_cnt = atomic64_read(&istat->decrypt_cnt);\n\trakcipher.stat_decrypt_tlen = atomic64_read(&istat->decrypt_tlen);\n\trakcipher.stat_sign_cnt = atomic64_read(&istat->sign_cnt);\n\trakcipher.stat_verify_cnt = atomic64_read(&istat->verify_cnt);\n\trakcipher.stat_err_cnt = atomic64_read(&istat->err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_AKCIPHER,\n\t\t       sizeof(rakcipher), &rakcipher);\n}\n\nstatic const struct crypto_type crypto_akcipher_type = {\n\t.extsize = crypto_alg_extsize,\n\t.init_tfm = crypto_akcipher_init_tfm,\n\t.free = crypto_akcipher_free_instance,\n#ifdef CONFIG_PROC_FS\n\t.show = crypto_akcipher_show,\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_USER)\n\t.report = crypto_akcipher_report,\n#endif\n#ifdef CONFIG_CRYPTO_STATS\n\t.report_stat = crypto_akcipher_report_stat,\n#endif\n\t.maskclear = ~CRYPTO_ALG_TYPE_MASK,\n\t.maskset = CRYPTO_ALG_TYPE_AHASH_MASK,\n\t.type = CRYPTO_ALG_TYPE_AKCIPHER,\n\t.tfmsize = offsetof(struct crypto_akcipher, base),\n};\n\nint crypto_grab_akcipher(struct crypto_akcipher_spawn *spawn,\n\t\t\t struct crypto_instance *inst,\n\t\t\t const char *name, u32 type, u32 mask)\n{\n\tspawn->base.frontend = &crypto_akcipher_type;\n\treturn crypto_grab_spawn(&spawn->base, inst, name, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_grab_akcipher);\n\nstruct crypto_akcipher *crypto_alloc_akcipher(const char *alg_name, u32 type,\n\t\t\t\t\t      u32 mask)\n{\n\treturn crypto_alloc_tfm(alg_name, &crypto_akcipher_type, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_alloc_akcipher);\n\nstatic void akcipher_prepare_alg(struct akcipher_alg *alg)\n{\n\tstruct crypto_istat_akcipher *istat = akcipher_get_stat(alg);\n\tstruct crypto_alg *base = &alg->base;\n\n\tbase->cra_type = &crypto_akcipher_type;\n\tbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\n\tbase->cra_flags |= CRYPTO_ALG_TYPE_AKCIPHER;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_STATS))\n\t\tmemset(istat, 0, sizeof(*istat));\n}\n\nstatic int akcipher_default_op(struct akcipher_request *req)\n{\n\treturn -ENOSYS;\n}\n\nstatic int akcipher_default_set_key(struct crypto_akcipher *tfm,\n\t\t\t\t     const void *key, unsigned int keylen)\n{\n\treturn -ENOSYS;\n}\n\nint crypto_register_akcipher(struct akcipher_alg *alg)\n{\n\tstruct crypto_alg *base = &alg->base;\n\n\tif (!alg->sign)\n\t\talg->sign = akcipher_default_op;\n\tif (!alg->verify)\n\t\talg->verify = akcipher_default_op;\n\tif (!alg->encrypt)\n\t\talg->encrypt = akcipher_default_op;\n\tif (!alg->decrypt)\n\t\talg->decrypt = akcipher_default_op;\n\tif (!alg->set_priv_key)\n\t\talg->set_priv_key = akcipher_default_set_key;\n\n\takcipher_prepare_alg(alg);\n\treturn crypto_register_alg(base);\n}\nEXPORT_SYMBOL_GPL(crypto_register_akcipher);\n\nvoid crypto_unregister_akcipher(struct akcipher_alg *alg)\n{\n\tcrypto_unregister_alg(&alg->base);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_akcipher);\n\nint akcipher_register_instance(struct crypto_template *tmpl,\n\t\t\t       struct akcipher_instance *inst)\n{\n\tif (WARN_ON(!inst->free))\n\t\treturn -EINVAL;\n\takcipher_prepare_alg(&inst->alg);\n\treturn crypto_register_instance(tmpl, akcipher_crypto_instance(inst));\n}\nEXPORT_SYMBOL_GPL(akcipher_register_instance);\n\nint crypto_akcipher_sync_prep(struct crypto_akcipher_sync_data *data)\n{\n\tunsigned int reqsize = crypto_akcipher_reqsize(data->tfm);\n\tstruct akcipher_request *req;\n\tstruct scatterlist *sg;\n\tunsigned int mlen;\n\tunsigned int len;\n\tu8 *buf;\n\n\tif (data->dst)\n\t\tmlen = max(data->slen, data->dlen);\n\telse\n\t\tmlen = data->slen + data->dlen;\n\n\tlen = sizeof(*req) + reqsize + mlen;\n\tif (len < mlen)\n\t\treturn -EOVERFLOW;\n\n\treq = kzalloc(len, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tdata->req = req;\n\takcipher_request_set_tfm(req, data->tfm);\n\n\tbuf = (u8 *)(req + 1) + reqsize;\n\tdata->buf = buf;\n\tmemcpy(buf, data->src, data->slen);\n\n\tsg = &data->sg;\n\tsg_init_one(sg, buf, mlen);\n\takcipher_request_set_crypt(req, sg, data->dst ? sg : NULL,\n\t\t\t\t   data->slen, data->dlen);\n\n\tcrypto_init_wait(&data->cwait);\n\takcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t      crypto_req_done, &data->cwait);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(crypto_akcipher_sync_prep);\n\nint crypto_akcipher_sync_post(struct crypto_akcipher_sync_data *data, int err)\n{\n\terr = crypto_wait_req(err, &data->cwait);\n\tif (data->dst)\n\t\tmemcpy(data->dst, data->buf, data->dlen);\n\tdata->dlen = data->req->dst_len;\n\tkfree_sensitive(data->req);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(crypto_akcipher_sync_post);\n\nint crypto_akcipher_sync_encrypt(struct crypto_akcipher *tfm,\n\t\t\t\t const void *src, unsigned int slen,\n\t\t\t\t void *dst, unsigned int dlen)\n{\n\tstruct crypto_akcipher_sync_data data = {\n\t\t.tfm = tfm,\n\t\t.src = src,\n\t\t.dst = dst,\n\t\t.slen = slen,\n\t\t.dlen = dlen,\n\t};\n\n\treturn crypto_akcipher_sync_prep(&data) ?:\n\t       crypto_akcipher_sync_post(&data,\n\t\t\t\t\t crypto_akcipher_encrypt(data.req));\n}\nEXPORT_SYMBOL_GPL(crypto_akcipher_sync_encrypt);\n\nint crypto_akcipher_sync_decrypt(struct crypto_akcipher *tfm,\n\t\t\t\t const void *src, unsigned int slen,\n\t\t\t\t void *dst, unsigned int dlen)\n{\n\tstruct crypto_akcipher_sync_data data = {\n\t\t.tfm = tfm,\n\t\t.src = src,\n\t\t.dst = dst,\n\t\t.slen = slen,\n\t\t.dlen = dlen,\n\t};\n\n\treturn crypto_akcipher_sync_prep(&data) ?:\n\t       crypto_akcipher_sync_post(&data,\n\t\t\t\t\t crypto_akcipher_decrypt(data.req)) ?:\n\t       data.dlen;\n}\nEXPORT_SYMBOL_GPL(crypto_akcipher_sync_decrypt);\n\nstatic void crypto_exit_akcipher_ops_sig(struct crypto_tfm *tfm)\n{\n\tstruct crypto_akcipher **ctx = crypto_tfm_ctx(tfm);\n\n\tcrypto_free_akcipher(*ctx);\n}\n\nint crypto_init_akcipher_ops_sig(struct crypto_tfm *tfm)\n{\n\tstruct crypto_akcipher **ctx = crypto_tfm_ctx(tfm);\n\tstruct crypto_alg *calg = tfm->__crt_alg;\n\tstruct crypto_akcipher *akcipher;\n\n\tif (!crypto_mod_get(calg))\n\t\treturn -EAGAIN;\n\n\takcipher = crypto_create_tfm(calg, &crypto_akcipher_type);\n\tif (IS_ERR(akcipher)) {\n\t\tcrypto_mod_put(calg);\n\t\treturn PTR_ERR(akcipher);\n\t}\n\n\t*ctx = akcipher;\n\ttfm->exit = crypto_exit_akcipher_ops_sig;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(crypto_init_akcipher_ops_sig);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Generic public key cipher type\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}