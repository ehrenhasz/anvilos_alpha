{
  "module_name": "crypto_user_stat.c",
  "hash_id": "302b556bed1d4af45bfa32ff65b98bffcb723ff94e024760049e03527e4ab745",
  "original_prompt": "Ingested from linux-6.6.14/crypto/crypto_user_stat.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/cryptouser.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n\n#define null_terminated(x)\t(strnlen(x, sizeof(x)) < sizeof(x))\n\nstruct crypto_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstatic int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_cipher rcipher;\n\n\tmemset(&rcipher, 0, sizeof(rcipher));\n\n\tstrscpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_CIPHER, sizeof(rcipher), &rcipher);\n}\n\nstatic int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_stat_compress rcomp;\n\n\tmemset(&rcomp, 0, sizeof(rcomp));\n\n\tstrscpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_COMPRESS, sizeof(rcomp), &rcomp);\n}\n\nstatic int crypto_reportstat_one(struct crypto_alg *alg,\n\t\t\t\t struct crypto_user_alg *ualg,\n\t\t\t\t struct sk_buff *skb)\n{\n\tmemset(ualg, 0, sizeof(*ualg));\n\n\tstrscpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrscpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrscpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_stat_larval rl;\n\n\t\tmemset(&rl, 0, sizeof(rl));\n\t\tstrscpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_STAT_LARVAL, sizeof(rl), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report_stat) {\n\t\tif (alg->cra_type->report_stat(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"ERROR: Unhandled alg %d in %s\\n\",\n\t\t       alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL),\n\t\t       __func__);\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_reportstat_alg(struct crypto_alg *alg,\n\t\t\t\t struct crypto_dump_info *info)\n{\n\tstruct sk_buff *in_skb = info->in_skb;\n\tstruct sk_buff *skb = info->out_skb;\n\tstruct nlmsghdr *nlh;\n\tstruct crypto_user_alg *ualg;\n\tint err = 0;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, info->nlmsg_seq,\n\t\t\tCRYPTO_MSG_GETSTAT, sizeof(*ualg), info->nlmsg_flags);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tualg = nlmsg_data(nlh);\n\n\terr = crypto_reportstat_one(alg, ualg, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\nout:\n\treturn err;\n}\n\nint crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_reportstat_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}