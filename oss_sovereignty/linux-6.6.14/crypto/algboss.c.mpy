{
  "module_name": "algboss.c",
  "hash_id": "156580c07dd52dc051bfcedb421a641a0645d5c28202450deff055d3ec8fb1c0",
  "original_prompt": "Ingested from linux-6.6.14/crypto/algboss.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/aead.h>\n#include <linux/completion.h>\n#include <linux/ctype.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/rtnetlink.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include \"internal.h\"\n\nstruct cryptomgr_param {\n\tstruct rtattr *tb[CRYPTO_MAX_ATTRS + 2];\n\n\tstruct {\n\t\tstruct rtattr attr;\n\t\tstruct crypto_attr_type data;\n\t} type;\n\n\tstruct {\n\t\tstruct rtattr attr;\n\t\tstruct crypto_attr_alg data;\n\t} attrs[CRYPTO_MAX_ATTRS];\n\n\tchar template[CRYPTO_MAX_ALG_NAME];\n\n\tstruct crypto_larval *larval;\n\n\tu32 otype;\n\tu32 omask;\n};\n\nstruct crypto_test_param {\n\tchar driver[CRYPTO_MAX_ALG_NAME];\n\tchar alg[CRYPTO_MAX_ALG_NAME];\n\tu32 type;\n};\n\nstatic int cryptomgr_probe(void *data)\n{\n\tstruct cryptomgr_param *param = data;\n\tstruct crypto_template *tmpl;\n\tint err;\n\n\ttmpl = crypto_lookup_template(param->template);\n\tif (!tmpl)\n\t\tgoto out;\n\n\tdo {\n\t\terr = tmpl->create(tmpl, param->tb);\n\t} while (err == -EAGAIN && !signal_pending(current));\n\n\tcrypto_tmpl_put(tmpl);\n\nout:\n\tcomplete_all(&param->larval->completion);\n\tcrypto_alg_put(&param->larval->alg);\n\tkfree(param);\n\tmodule_put_and_kthread_exit(0);\n}\n\nstatic int cryptomgr_schedule_probe(struct crypto_larval *larval)\n{\n\tstruct task_struct *thread;\n\tstruct cryptomgr_param *param;\n\tconst char *name = larval->alg.cra_name;\n\tconst char *p;\n\tunsigned int len;\n\tint i;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\tgoto err;\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\tgoto err_put_module;\n\n\tfor (p = name; isalnum(*p) || *p == '-' || *p == '_'; p++)\n\t\t;\n\n\tlen = p - name;\n\tif (!len || *p != '(')\n\t\tgoto err_free_param;\n\n\tmemcpy(param->template, name, len);\n\n\ti = 0;\n\tfor (;;) {\n\t\tname = ++p;\n\n\t\tfor (; isalnum(*p) || *p == '-' || *p == '_'; p++)\n\t\t\t;\n\n\t\tif (*p == '(') {\n\t\t\tint recursion = 0;\n\n\t\t\tfor (;;) {\n\t\t\t\tif (!*++p)\n\t\t\t\t\tgoto err_free_param;\n\t\t\t\tif (*p == '(')\n\t\t\t\t\trecursion++;\n\t\t\t\telse if (*p == ')' && !recursion--)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tp++;\n\t\t}\n\n\t\tlen = p - name;\n\t\tif (!len)\n\t\t\tgoto err_free_param;\n\n\t\tparam->attrs[i].attr.rta_len = sizeof(param->attrs[i]);\n\t\tparam->attrs[i].attr.rta_type = CRYPTOA_ALG;\n\t\tmemcpy(param->attrs[i].data.name, name, len);\n\n\t\tparam->tb[i + 1] = &param->attrs[i].attr;\n\t\ti++;\n\n\t\tif (i >= CRYPTO_MAX_ATTRS)\n\t\t\tgoto err_free_param;\n\n\t\tif (*p == ')')\n\t\t\tbreak;\n\n\t\tif (*p != ',')\n\t\t\tgoto err_free_param;\n\t}\n\n\tif (!i)\n\t\tgoto err_free_param;\n\n\tparam->tb[i + 1] = NULL;\n\n\tparam->type.attr.rta_len = sizeof(param->type);\n\tparam->type.attr.rta_type = CRYPTOA_TYPE;\n\tparam->type.data.type = larval->alg.cra_flags & ~CRYPTO_ALG_TESTED;\n\tparam->type.data.mask = larval->mask & ~CRYPTO_ALG_TESTED;\n\tparam->tb[0] = &param->type.attr;\n\n\tparam->otype = larval->alg.cra_flags;\n\tparam->omask = larval->mask;\n\n\tcrypto_alg_get(&larval->alg);\n\tparam->larval = larval;\n\n\tthread = kthread_run(cryptomgr_probe, param, \"cryptomgr_probe\");\n\tif (IS_ERR(thread))\n\t\tgoto err_put_larval;\n\n\treturn NOTIFY_STOP;\n\nerr_put_larval:\n\tcrypto_alg_put(&larval->alg);\nerr_free_param:\n\tkfree(param);\nerr_put_module:\n\tmodule_put(THIS_MODULE);\nerr:\n\treturn NOTIFY_OK;\n}\n\nstatic int cryptomgr_test(void *data)\n{\n\tstruct crypto_test_param *param = data;\n\tu32 type = param->type;\n\tint err;\n\n\terr = alg_test(param->driver, param->alg, type, CRYPTO_ALG_TESTED);\n\n\tcrypto_alg_tested(param->driver, err);\n\n\tkfree(param);\n\tmodule_put_and_kthread_exit(0);\n}\n\nstatic int cryptomgr_schedule_test(struct crypto_alg *alg)\n{\n\tstruct task_struct *thread;\n\tstruct crypto_test_param *param;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_MANAGER_DISABLE_TESTS))\n\t\treturn NOTIFY_DONE;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\tgoto err;\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\tgoto err_put_module;\n\n\tmemcpy(param->driver, alg->cra_driver_name, sizeof(param->driver));\n\tmemcpy(param->alg, alg->cra_name, sizeof(param->alg));\n\tparam->type = alg->cra_flags;\n\n\tthread = kthread_run(cryptomgr_test, param, \"cryptomgr_test\");\n\tif (IS_ERR(thread))\n\t\tgoto err_free_param;\n\n\treturn NOTIFY_STOP;\n\nerr_free_param:\n\tkfree(param);\nerr_put_module:\n\tmodule_put(THIS_MODULE);\nerr:\n\treturn NOTIFY_OK;\n}\n\nstatic int cryptomgr_notify(struct notifier_block *this, unsigned long msg,\n\t\t\t    void *data)\n{\n\tswitch (msg) {\n\tcase CRYPTO_MSG_ALG_REQUEST:\n\t\treturn cryptomgr_schedule_probe(data);\n\tcase CRYPTO_MSG_ALG_REGISTER:\n\t\treturn cryptomgr_schedule_test(data);\n\tcase CRYPTO_MSG_ALG_LOADED:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block cryptomgr_notifier = {\n\t.notifier_call = cryptomgr_notify,\n};\n\nstatic int __init cryptomgr_init(void)\n{\n\treturn crypto_register_notifier(&cryptomgr_notifier);\n}\n\nstatic void __exit cryptomgr_exit(void)\n{\n\tint err = crypto_unregister_notifier(&cryptomgr_notifier);\n\tBUG_ON(err);\n}\n\n \narch_initcall(cryptomgr_init);\nmodule_exit(cryptomgr_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Crypto Algorithm Manager\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}