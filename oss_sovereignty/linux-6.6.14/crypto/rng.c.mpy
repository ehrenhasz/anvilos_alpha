{
  "module_name": "rng.c",
  "hash_id": "405ddee8eb6747cadb97423bf67af30639f49f341d011370f4a258715c1be1e4",
  "original_prompt": "Ingested from linux-6.6.14/crypto/rng.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/rng.h>\n#include <linux/atomic.h>\n#include <linux/cryptouser.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/random.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <net/netlink.h>\n\n#include \"internal.h\"\n\nstatic DEFINE_MUTEX(crypto_default_rng_lock);\nstruct crypto_rng *crypto_default_rng;\nEXPORT_SYMBOL_GPL(crypto_default_rng);\nstatic int crypto_default_rng_refcnt;\n\nint crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n{\n\tstruct rng_alg *alg = crypto_rng_alg(tfm);\n\tu8 *buf = NULL;\n\tint err;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_STATS))\n\t\tatomic64_inc(&rng_get_stat(alg)->seed_cnt);\n\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (!buf)\n\t\t\tgoto out;\n\n\t\terr = get_random_bytes_wait(buf, slen);\n\t\tif (err)\n\t\t\tgoto free_buf;\n\t\tseed = buf;\n\t}\n\n\terr = alg->seed(tfm, seed, slen);\nfree_buf:\n\tkfree_sensitive(buf);\nout:\n\treturn crypto_rng_errstat(alg, err);\n}\nEXPORT_SYMBOL_GPL(crypto_rng_reset);\n\nstatic int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\treturn 0;\n}\n\nstatic unsigned int seedsize(struct crypto_alg *alg)\n{\n\tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n\n\treturn ralg->seedsize;\n}\n\nstatic int __maybe_unused crypto_rng_report(\n\tstruct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\n\tmemset(&rrng, 0, sizeof(rrng));\n\n\tstrscpy(rrng.type, \"rng\", sizeof(rrng.type));\n\n\trrng.seedsize = seedsize(alg);\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_RNG, sizeof(rrng), &rrng);\n}\n\nstatic void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n\t__maybe_unused;\nstatic void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n{\n\tseq_printf(m, \"type         : rng\\n\");\n\tseq_printf(m, \"seedsize     : %u\\n\", seedsize(alg));\n}\n\nstatic int __maybe_unused crypto_rng_report_stat(\n\tstruct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct rng_alg *rng = __crypto_rng_alg(alg);\n\tstruct crypto_istat_rng *istat;\n\tstruct crypto_stat_rng rrng;\n\n\tistat = rng_get_stat(rng);\n\n\tmemset(&rrng, 0, sizeof(rrng));\n\n\tstrscpy(rrng.type, \"rng\", sizeof(rrng.type));\n\n\trrng.stat_generate_cnt = atomic64_read(&istat->generate_cnt);\n\trrng.stat_generate_tlen = atomic64_read(&istat->generate_tlen);\n\trrng.stat_seed_cnt = atomic64_read(&istat->seed_cnt);\n\trrng.stat_err_cnt = atomic64_read(&istat->err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_RNG, sizeof(rrng), &rrng);\n}\n\nstatic const struct crypto_type crypto_rng_type = {\n\t.extsize = crypto_alg_extsize,\n\t.init_tfm = crypto_rng_init_tfm,\n#ifdef CONFIG_PROC_FS\n\t.show = crypto_rng_show,\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_USER)\n\t.report = crypto_rng_report,\n#endif\n#ifdef CONFIG_CRYPTO_STATS\n\t.report_stat = crypto_rng_report_stat,\n#endif\n\t.maskclear = ~CRYPTO_ALG_TYPE_MASK,\n\t.maskset = CRYPTO_ALG_TYPE_MASK,\n\t.type = CRYPTO_ALG_TYPE_RNG,\n\t.tfmsize = offsetof(struct crypto_rng, base),\n};\n\nstruct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_tfm(alg_name, &crypto_rng_type, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_alloc_rng);\n\nint crypto_get_default_rng(void)\n{\n\tstruct crypto_rng *rng;\n\tint err;\n\n\tmutex_lock(&crypto_default_rng_lock);\n\tif (!crypto_default_rng) {\n\t\trng = crypto_alloc_rng(\"stdrng\", 0, 0);\n\t\terr = PTR_ERR(rng);\n\t\tif (IS_ERR(rng))\n\t\t\tgoto unlock;\n\n\t\terr = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\n\t\tif (err) {\n\t\t\tcrypto_free_rng(rng);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tcrypto_default_rng = rng;\n\t}\n\n\tcrypto_default_rng_refcnt++;\n\terr = 0;\n\nunlock:\n\tmutex_unlock(&crypto_default_rng_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(crypto_get_default_rng);\n\nvoid crypto_put_default_rng(void)\n{\n\tmutex_lock(&crypto_default_rng_lock);\n\tcrypto_default_rng_refcnt--;\n\tmutex_unlock(&crypto_default_rng_lock);\n}\nEXPORT_SYMBOL_GPL(crypto_put_default_rng);\n\n#if defined(CONFIG_CRYPTO_RNG) || defined(CONFIG_CRYPTO_RNG_MODULE)\nint crypto_del_default_rng(void)\n{\n\tint err = -EBUSY;\n\n\tmutex_lock(&crypto_default_rng_lock);\n\tif (crypto_default_rng_refcnt)\n\t\tgoto out;\n\n\tcrypto_free_rng(crypto_default_rng);\n\tcrypto_default_rng = NULL;\n\n\terr = 0;\n\nout:\n\tmutex_unlock(&crypto_default_rng_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(crypto_del_default_rng);\n#endif\n\nint crypto_register_rng(struct rng_alg *alg)\n{\n\tstruct crypto_istat_rng *istat = rng_get_stat(alg);\n\tstruct crypto_alg *base = &alg->base;\n\n\tif (alg->seedsize > PAGE_SIZE / 8)\n\t\treturn -EINVAL;\n\n\tbase->cra_type = &crypto_rng_type;\n\tbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\n\tbase->cra_flags |= CRYPTO_ALG_TYPE_RNG;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_STATS))\n\t\tmemset(istat, 0, sizeof(*istat));\n\n\treturn crypto_register_alg(base);\n}\nEXPORT_SYMBOL_GPL(crypto_register_rng);\n\nvoid crypto_unregister_rng(struct rng_alg *alg)\n{\n\tcrypto_unregister_alg(&alg->base);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_rng);\n\nint crypto_register_rngs(struct rng_alg *algs, int count)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = crypto_register_rng(algs + i);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (--i; i >= 0; --i)\n\t\tcrypto_unregister_rng(algs + i);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(crypto_register_rngs);\n\nvoid crypto_unregister_rngs(struct rng_alg *algs, int count)\n{\n\tint i;\n\n\tfor (i = count - 1; i >= 0; --i)\n\t\tcrypto_unregister_rng(algs + i);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_rngs);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Random Number Generator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}