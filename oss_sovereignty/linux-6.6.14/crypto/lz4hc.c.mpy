{
  "module_name": "lz4hc.c",
  "hash_id": "5b92f37db2ca814a76d073135066e04a89aea155a4a74a2e103c2d7f2bf810f4",
  "original_prompt": "Ingested from linux-6.6.14/crypto/lz4hc.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <linux/vmalloc.h>\n#include <linux/lz4.h>\n#include <crypto/internal/scompress.h>\n\nstruct lz4hc_ctx {\n\tvoid *lz4hc_comp_mem;\n};\n\nstatic void *lz4hc_alloc_ctx(struct crypto_scomp *tfm)\n{\n\tvoid *ctx;\n\n\tctx = vmalloc(LZ4HC_MEM_COMPRESS);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn ctx;\n}\n\nstatic int lz4hc_init(struct crypto_tfm *tfm)\n{\n\tstruct lz4hc_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tctx->lz4hc_comp_mem = lz4hc_alloc_ctx(NULL);\n\tif (IS_ERR(ctx->lz4hc_comp_mem))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void lz4hc_free_ctx(struct crypto_scomp *tfm, void *ctx)\n{\n\tvfree(ctx);\n}\n\nstatic void lz4hc_exit(struct crypto_tfm *tfm)\n{\n\tstruct lz4hc_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tlz4hc_free_ctx(NULL, ctx->lz4hc_comp_mem);\n}\n\nstatic int __lz4hc_compress_crypto(const u8 *src, unsigned int slen,\n\t\t\t\t   u8 *dst, unsigned int *dlen, void *ctx)\n{\n\tint out_len = LZ4_compress_HC(src, dst, slen,\n\t\t*dlen, LZ4HC_DEFAULT_CLEVEL, ctx);\n\n\tif (!out_len)\n\t\treturn -EINVAL;\n\n\t*dlen = out_len;\n\treturn 0;\n}\n\nstatic int lz4hc_scompress(struct crypto_scomp *tfm, const u8 *src,\n\t\t\t   unsigned int slen, u8 *dst, unsigned int *dlen,\n\t\t\t   void *ctx)\n{\n\treturn __lz4hc_compress_crypto(src, slen, dst, dlen, ctx);\n}\n\nstatic int lz4hc_compress_crypto(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t\t unsigned int slen, u8 *dst,\n\t\t\t\t unsigned int *dlen)\n{\n\tstruct lz4hc_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\treturn __lz4hc_compress_crypto(src, slen, dst, dlen,\n\t\t\t\t\tctx->lz4hc_comp_mem);\n}\n\nstatic int __lz4hc_decompress_crypto(const u8 *src, unsigned int slen,\n\t\t\t\t     u8 *dst, unsigned int *dlen, void *ctx)\n{\n\tint out_len = LZ4_decompress_safe(src, dst, slen, *dlen);\n\n\tif (out_len < 0)\n\t\treturn -EINVAL;\n\n\t*dlen = out_len;\n\treturn 0;\n}\n\nstatic int lz4hc_sdecompress(struct crypto_scomp *tfm, const u8 *src,\n\t\t\t     unsigned int slen, u8 *dst, unsigned int *dlen,\n\t\t\t     void *ctx)\n{\n\treturn __lz4hc_decompress_crypto(src, slen, dst, dlen, NULL);\n}\n\nstatic int lz4hc_decompress_crypto(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t\t   unsigned int slen, u8 *dst,\n\t\t\t\t   unsigned int *dlen)\n{\n\treturn __lz4hc_decompress_crypto(src, slen, dst, dlen, NULL);\n}\n\nstatic struct crypto_alg alg_lz4hc = {\n\t.cra_name\t\t= \"lz4hc\",\n\t.cra_driver_name\t= \"lz4hc-generic\",\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_COMPRESS,\n\t.cra_ctxsize\t\t= sizeof(struct lz4hc_ctx),\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_init\t\t= lz4hc_init,\n\t.cra_exit\t\t= lz4hc_exit,\n\t.cra_u\t\t\t= { .compress = {\n\t.coa_compress\t\t= lz4hc_compress_crypto,\n\t.coa_decompress\t\t= lz4hc_decompress_crypto } }\n};\n\nstatic struct scomp_alg scomp = {\n\t.alloc_ctx\t\t= lz4hc_alloc_ctx,\n\t.free_ctx\t\t= lz4hc_free_ctx,\n\t.compress\t\t= lz4hc_scompress,\n\t.decompress\t\t= lz4hc_sdecompress,\n\t.base\t\t\t= {\n\t\t.cra_name\t= \"lz4hc\",\n\t\t.cra_driver_name = \"lz4hc-scomp\",\n\t\t.cra_module\t = THIS_MODULE,\n\t}\n};\n\nstatic int __init lz4hc_mod_init(void)\n{\n\tint ret;\n\n\tret = crypto_register_alg(&alg_lz4hc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = crypto_register_scomp(&scomp);\n\tif (ret) {\n\t\tcrypto_unregister_alg(&alg_lz4hc);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit lz4hc_mod_fini(void)\n{\n\tcrypto_unregister_alg(&alg_lz4hc);\n\tcrypto_unregister_scomp(&scomp);\n}\n\nsubsys_initcall(lz4hc_mod_init);\nmodule_exit(lz4hc_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"LZ4HC Compression Algorithm\");\nMODULE_ALIAS_CRYPTO(\"lz4hc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}