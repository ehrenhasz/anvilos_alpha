{
  "module_name": "sm3.c",
  "hash_id": "4fc0dc7d6955851ac3e6d6bbcf1c6e6cd49cc3c10bf54f93ae41da56d1dc9ccf",
  "original_prompt": "Ingested from linux-6.6.14/crypto/sm3.c",
  "human_readable_source": " \n \n\n#include <linux/module.h>\n#include <asm/unaligned.h>\n#include <crypto/sm3.h>\n\nstatic const u32 ____cacheline_aligned K[64] = {\n\t0x79cc4519, 0xf3988a32, 0xe7311465, 0xce6228cb,\n\t0x9cc45197, 0x3988a32f, 0x7311465e, 0xe6228cbc,\n\t0xcc451979, 0x988a32f3, 0x311465e7, 0x6228cbce,\n\t0xc451979c, 0x88a32f39, 0x11465e73, 0x228cbce6,\n\t0x9d8a7a87, 0x3b14f50f, 0x7629ea1e, 0xec53d43c,\n\t0xd8a7a879, 0xb14f50f3, 0x629ea1e7, 0xc53d43ce,\n\t0x8a7a879d, 0x14f50f3b, 0x29ea1e76, 0x53d43cec,\n\t0xa7a879d8, 0x4f50f3b1, 0x9ea1e762, 0x3d43cec5,\n\t0x7a879d8a, 0xf50f3b14, 0xea1e7629, 0xd43cec53,\n\t0xa879d8a7, 0x50f3b14f, 0xa1e7629e, 0x43cec53d,\n\t0x879d8a7a, 0x0f3b14f5, 0x1e7629ea, 0x3cec53d4,\n\t0x79d8a7a8, 0xf3b14f50, 0xe7629ea1, 0xcec53d43,\n\t0x9d8a7a87, 0x3b14f50f, 0x7629ea1e, 0xec53d43c,\n\t0xd8a7a879, 0xb14f50f3, 0x629ea1e7, 0xc53d43ce,\n\t0x8a7a879d, 0x14f50f3b, 0x29ea1e76, 0x53d43cec,\n\t0xa7a879d8, 0x4f50f3b1, 0x9ea1e762, 0x3d43cec5\n};\n\n \n#define R(i, a, b, c, d, e, f, g, h, t, w1, w2)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tss1 = rol32((rol32((a), 12) + (e) + (t)), 7);\t\\\n\t\tss2 = ss1 ^ rol32((a), 12);\t\t\t\\\n\t\td += FF ## i(a, b, c) + ss2 + ((w1) ^ (w2));\t\\\n\t\th += GG ## i(e, f, g) + ss1 + (w1);\t\t\\\n\t\tb = rol32((b), 9);\t\t\t\t\\\n\t\tf = rol32((f), 19);\t\t\t\t\\\n\t\th = P0((h));\t\t\t\t\t\\\n\t} while (0)\n\n#define R1(a, b, c, d, e, f, g, h, t, w1, w2) \\\n\tR(1, a, b, c, d, e, f, g, h, t, w1, w2)\n#define R2(a, b, c, d, e, f, g, h, t, w1, w2) \\\n\tR(2, a, b, c, d, e, f, g, h, t, w1, w2)\n\n#define FF1(x, y, z)  (x ^ y ^ z)\n#define FF2(x, y, z)  ((x & y) | (x & z) | (y & z))\n\n#define GG1(x, y, z)  FF1(x, y, z)\n#define GG2(x, y, z)  ((x & y) | (~x & z))\n\n \n#define P0(x) ((x) ^ rol32((x), 9) ^ rol32((x), 17))\n#define P1(x) ((x) ^ rol32((x), 15) ^ rol32((x), 23))\n#define I(i)  (W[i] = get_unaligned_be32(data + i * 4))\n#define W1(i) (W[i & 0x0f])\n#define W2(i) (W[i & 0x0f] =\t\t\t\t\\\n\t\tP1(W[i & 0x0f]\t\t\t\t\\\n\t\t\t^ W[(i-9) & 0x0f]\t\t\\\n\t\t\t^ rol32(W[(i-3) & 0x0f], 15))\t\\\n\t\t^ rol32(W[(i-13) & 0x0f], 7)\t\t\\\n\t\t^ W[(i-6) & 0x0f])\n\nstatic void sm3_transform(struct sm3_state *sctx, u8 const *data, u32 W[16])\n{\n\tu32 a, b, c, d, e, f, g, h, ss1, ss2;\n\n\ta = sctx->state[0];\n\tb = sctx->state[1];\n\tc = sctx->state[2];\n\td = sctx->state[3];\n\te = sctx->state[4];\n\tf = sctx->state[5];\n\tg = sctx->state[6];\n\th = sctx->state[7];\n\n\tR1(a, b, c, d, e, f, g, h, K[0], I(0), I(4));\n\tR1(d, a, b, c, h, e, f, g, K[1], I(1), I(5));\n\tR1(c, d, a, b, g, h, e, f, K[2], I(2), I(6));\n\tR1(b, c, d, a, f, g, h, e, K[3], I(3), I(7));\n\tR1(a, b, c, d, e, f, g, h, K[4], W1(4), I(8));\n\tR1(d, a, b, c, h, e, f, g, K[5], W1(5), I(9));\n\tR1(c, d, a, b, g, h, e, f, K[6], W1(6), I(10));\n\tR1(b, c, d, a, f, g, h, e, K[7], W1(7), I(11));\n\tR1(a, b, c, d, e, f, g, h, K[8], W1(8), I(12));\n\tR1(d, a, b, c, h, e, f, g, K[9], W1(9), I(13));\n\tR1(c, d, a, b, g, h, e, f, K[10], W1(10), I(14));\n\tR1(b, c, d, a, f, g, h, e, K[11], W1(11), I(15));\n\tR1(a, b, c, d, e, f, g, h, K[12], W1(12), W2(16));\n\tR1(d, a, b, c, h, e, f, g, K[13], W1(13), W2(17));\n\tR1(c, d, a, b, g, h, e, f, K[14], W1(14), W2(18));\n\tR1(b, c, d, a, f, g, h, e, K[15], W1(15), W2(19));\n\n\tR2(a, b, c, d, e, f, g, h, K[16], W1(16), W2(20));\n\tR2(d, a, b, c, h, e, f, g, K[17], W1(17), W2(21));\n\tR2(c, d, a, b, g, h, e, f, K[18], W1(18), W2(22));\n\tR2(b, c, d, a, f, g, h, e, K[19], W1(19), W2(23));\n\tR2(a, b, c, d, e, f, g, h, K[20], W1(20), W2(24));\n\tR2(d, a, b, c, h, e, f, g, K[21], W1(21), W2(25));\n\tR2(c, d, a, b, g, h, e, f, K[22], W1(22), W2(26));\n\tR2(b, c, d, a, f, g, h, e, K[23], W1(23), W2(27));\n\tR2(a, b, c, d, e, f, g, h, K[24], W1(24), W2(28));\n\tR2(d, a, b, c, h, e, f, g, K[25], W1(25), W2(29));\n\tR2(c, d, a, b, g, h, e, f, K[26], W1(26), W2(30));\n\tR2(b, c, d, a, f, g, h, e, K[27], W1(27), W2(31));\n\tR2(a, b, c, d, e, f, g, h, K[28], W1(28), W2(32));\n\tR2(d, a, b, c, h, e, f, g, K[29], W1(29), W2(33));\n\tR2(c, d, a, b, g, h, e, f, K[30], W1(30), W2(34));\n\tR2(b, c, d, a, f, g, h, e, K[31], W1(31), W2(35));\n\n\tR2(a, b, c, d, e, f, g, h, K[32], W1(32), W2(36));\n\tR2(d, a, b, c, h, e, f, g, K[33], W1(33), W2(37));\n\tR2(c, d, a, b, g, h, e, f, K[34], W1(34), W2(38));\n\tR2(b, c, d, a, f, g, h, e, K[35], W1(35), W2(39));\n\tR2(a, b, c, d, e, f, g, h, K[36], W1(36), W2(40));\n\tR2(d, a, b, c, h, e, f, g, K[37], W1(37), W2(41));\n\tR2(c, d, a, b, g, h, e, f, K[38], W1(38), W2(42));\n\tR2(b, c, d, a, f, g, h, e, K[39], W1(39), W2(43));\n\tR2(a, b, c, d, e, f, g, h, K[40], W1(40), W2(44));\n\tR2(d, a, b, c, h, e, f, g, K[41], W1(41), W2(45));\n\tR2(c, d, a, b, g, h, e, f, K[42], W1(42), W2(46));\n\tR2(b, c, d, a, f, g, h, e, K[43], W1(43), W2(47));\n\tR2(a, b, c, d, e, f, g, h, K[44], W1(44), W2(48));\n\tR2(d, a, b, c, h, e, f, g, K[45], W1(45), W2(49));\n\tR2(c, d, a, b, g, h, e, f, K[46], W1(46), W2(50));\n\tR2(b, c, d, a, f, g, h, e, K[47], W1(47), W2(51));\n\n\tR2(a, b, c, d, e, f, g, h, K[48], W1(48), W2(52));\n\tR2(d, a, b, c, h, e, f, g, K[49], W1(49), W2(53));\n\tR2(c, d, a, b, g, h, e, f, K[50], W1(50), W2(54));\n\tR2(b, c, d, a, f, g, h, e, K[51], W1(51), W2(55));\n\tR2(a, b, c, d, e, f, g, h, K[52], W1(52), W2(56));\n\tR2(d, a, b, c, h, e, f, g, K[53], W1(53), W2(57));\n\tR2(c, d, a, b, g, h, e, f, K[54], W1(54), W2(58));\n\tR2(b, c, d, a, f, g, h, e, K[55], W1(55), W2(59));\n\tR2(a, b, c, d, e, f, g, h, K[56], W1(56), W2(60));\n\tR2(d, a, b, c, h, e, f, g, K[57], W1(57), W2(61));\n\tR2(c, d, a, b, g, h, e, f, K[58], W1(58), W2(62));\n\tR2(b, c, d, a, f, g, h, e, K[59], W1(59), W2(63));\n\tR2(a, b, c, d, e, f, g, h, K[60], W1(60), W2(64));\n\tR2(d, a, b, c, h, e, f, g, K[61], W1(61), W2(65));\n\tR2(c, d, a, b, g, h, e, f, K[62], W1(62), W2(66));\n\tR2(b, c, d, a, f, g, h, e, K[63], W1(63), W2(67));\n\n\tsctx->state[0] ^= a;\n\tsctx->state[1] ^= b;\n\tsctx->state[2] ^= c;\n\tsctx->state[3] ^= d;\n\tsctx->state[4] ^= e;\n\tsctx->state[5] ^= f;\n\tsctx->state[6] ^= g;\n\tsctx->state[7] ^= h;\n}\n#undef R\n#undef R1\n#undef R2\n#undef I\n#undef W1\n#undef W2\n\nstatic inline void sm3_block(struct sm3_state *sctx,\n\t\tu8 const *data, int blocks, u32 W[16])\n{\n\twhile (blocks--) {\n\t\tsm3_transform(sctx, data, W);\n\t\tdata += SM3_BLOCK_SIZE;\n\t}\n}\n\nvoid sm3_update(struct sm3_state *sctx, const u8 *data, unsigned int len)\n{\n\tunsigned int partial = sctx->count % SM3_BLOCK_SIZE;\n\tu32 W[16];\n\n\tsctx->count += len;\n\n\tif ((partial + len) >= SM3_BLOCK_SIZE) {\n\t\tint blocks;\n\n\t\tif (partial) {\n\t\t\tint p = SM3_BLOCK_SIZE - partial;\n\n\t\t\tmemcpy(sctx->buffer + partial, data, p);\n\t\t\tdata += p;\n\t\t\tlen -= p;\n\n\t\t\tsm3_block(sctx, sctx->buffer, 1, W);\n\t\t}\n\n\t\tblocks = len / SM3_BLOCK_SIZE;\n\t\tlen %= SM3_BLOCK_SIZE;\n\n\t\tif (blocks) {\n\t\t\tsm3_block(sctx, data, blocks, W);\n\t\t\tdata += blocks * SM3_BLOCK_SIZE;\n\t\t}\n\n\t\tmemzero_explicit(W, sizeof(W));\n\n\t\tpartial = 0;\n\t}\n\tif (len)\n\t\tmemcpy(sctx->buffer + partial, data, len);\n}\nEXPORT_SYMBOL_GPL(sm3_update);\n\nvoid sm3_final(struct sm3_state *sctx, u8 *out)\n{\n\tconst int bit_offset = SM3_BLOCK_SIZE - sizeof(u64);\n\t__be64 *bits = (__be64 *)(sctx->buffer + bit_offset);\n\t__be32 *digest = (__be32 *)out;\n\tunsigned int partial = sctx->count % SM3_BLOCK_SIZE;\n\tu32 W[16];\n\tint i;\n\n\tsctx->buffer[partial++] = 0x80;\n\tif (partial > bit_offset) {\n\t\tmemset(sctx->buffer + partial, 0, SM3_BLOCK_SIZE - partial);\n\t\tpartial = 0;\n\n\t\tsm3_block(sctx, sctx->buffer, 1, W);\n\t}\n\n\tmemset(sctx->buffer + partial, 0, bit_offset - partial);\n\t*bits = cpu_to_be64(sctx->count << 3);\n\tsm3_block(sctx, sctx->buffer, 1, W);\n\n\tfor (i = 0; i < 8; i++)\n\t\tput_unaligned_be32(sctx->state[i], digest++);\n\n\t \n\tmemzero_explicit(W, sizeof(W));\n\tmemzero_explicit(sctx, sizeof(*sctx));\n}\nEXPORT_SYMBOL_GPL(sm3_final);\n\nMODULE_DESCRIPTION(\"Generic SM3 library\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}