{
  "module_name": "aegis128-core.c",
  "hash_id": "ce6dcf538ca20ea0171696bcb5b3e44e3a8602ee24dde0752dc83ce5a5b8721e",
  "original_prompt": "Ingested from linux-6.6.14/crypto/aegis128-core.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/aead.h>\n#include <crypto/internal/simd.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/jump_label.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n\n#include <asm/simd.h>\n\n#include \"aegis.h\"\n\n#define AEGIS128_NONCE_SIZE 16\n#define AEGIS128_STATE_BLOCKS 5\n#define AEGIS128_KEY_SIZE 16\n#define AEGIS128_MIN_AUTH_SIZE 8\n#define AEGIS128_MAX_AUTH_SIZE 16\n\nstruct aegis_state {\n\tunion aegis_block blocks[AEGIS128_STATE_BLOCKS];\n};\n\nstruct aegis_ctx {\n\tunion aegis_block key;\n};\n\nstatic __ro_after_init DEFINE_STATIC_KEY_FALSE(have_simd);\n\nstatic const union aegis_block crypto_aegis_const[2] = {\n\t{ .words64 = {\n\t\tcpu_to_le64(U64_C(0x0d08050302010100)),\n\t\tcpu_to_le64(U64_C(0x6279e99059372215)),\n\t} },\n\t{ .words64 = {\n\t\tcpu_to_le64(U64_C(0xf12fc26d55183ddb)),\n\t\tcpu_to_le64(U64_C(0xdd28b57342311120)),\n\t} },\n};\n\nstatic bool aegis128_do_simd(void)\n{\n#ifdef CONFIG_CRYPTO_AEGIS128_SIMD\n\tif (static_branch_likely(&have_simd))\n\t\treturn crypto_simd_usable();\n#endif\n\treturn false;\n}\n\nstatic void crypto_aegis128_update(struct aegis_state *state)\n{\n\tunion aegis_block tmp;\n\tunsigned int i;\n\n\ttmp = state->blocks[AEGIS128_STATE_BLOCKS - 1];\n\tfor (i = AEGIS128_STATE_BLOCKS - 1; i > 0; i--)\n\t\tcrypto_aegis_aesenc(&state->blocks[i], &state->blocks[i - 1],\n\t\t\t\t    &state->blocks[i]);\n\tcrypto_aegis_aesenc(&state->blocks[0], &tmp, &state->blocks[0]);\n}\n\nstatic void crypto_aegis128_update_a(struct aegis_state *state,\n\t\t\t\t     const union aegis_block *msg,\n\t\t\t\t     bool do_simd)\n{\n\tif (IS_ENABLED(CONFIG_CRYPTO_AEGIS128_SIMD) && do_simd) {\n\t\tcrypto_aegis128_update_simd(state, msg);\n\t\treturn;\n\t}\n\n\tcrypto_aegis128_update(state);\n\tcrypto_aegis_block_xor(&state->blocks[0], msg);\n}\n\nstatic void crypto_aegis128_update_u(struct aegis_state *state, const void *msg,\n\t\t\t\t     bool do_simd)\n{\n\tif (IS_ENABLED(CONFIG_CRYPTO_AEGIS128_SIMD) && do_simd) {\n\t\tcrypto_aegis128_update_simd(state, msg);\n\t\treturn;\n\t}\n\n\tcrypto_aegis128_update(state);\n\tcrypto_xor(state->blocks[0].bytes, msg, AEGIS_BLOCK_SIZE);\n}\n\nstatic void crypto_aegis128_init(struct aegis_state *state,\n\t\t\t\t const union aegis_block *key,\n\t\t\t\t const u8 *iv)\n{\n\tunion aegis_block key_iv;\n\tunsigned int i;\n\n\tkey_iv = *key;\n\tcrypto_xor(key_iv.bytes, iv, AEGIS_BLOCK_SIZE);\n\n\tstate->blocks[0] = key_iv;\n\tstate->blocks[1] = crypto_aegis_const[1];\n\tstate->blocks[2] = crypto_aegis_const[0];\n\tstate->blocks[3] = *key;\n\tstate->blocks[4] = *key;\n\n\tcrypto_aegis_block_xor(&state->blocks[3], &crypto_aegis_const[0]);\n\tcrypto_aegis_block_xor(&state->blocks[4], &crypto_aegis_const[1]);\n\n\tfor (i = 0; i < 5; i++) {\n\t\tcrypto_aegis128_update_a(state, key, false);\n\t\tcrypto_aegis128_update_a(state, &key_iv, false);\n\t}\n}\n\nstatic void crypto_aegis128_ad(struct aegis_state *state,\n\t\t\t       const u8 *src, unsigned int size,\n\t\t\t       bool do_simd)\n{\n\tif (AEGIS_ALIGNED(src)) {\n\t\tconst union aegis_block *src_blk =\n\t\t\t\t(const union aegis_block *)src;\n\n\t\twhile (size >= AEGIS_BLOCK_SIZE) {\n\t\t\tcrypto_aegis128_update_a(state, src_blk, do_simd);\n\n\t\t\tsize -= AEGIS_BLOCK_SIZE;\n\t\t\tsrc_blk++;\n\t\t}\n\t} else {\n\t\twhile (size >= AEGIS_BLOCK_SIZE) {\n\t\t\tcrypto_aegis128_update_u(state, src, do_simd);\n\n\t\t\tsize -= AEGIS_BLOCK_SIZE;\n\t\t\tsrc += AEGIS_BLOCK_SIZE;\n\t\t}\n\t}\n}\n\nstatic void crypto_aegis128_wipe_chunk(struct aegis_state *state, u8 *dst,\n\t\t\t\t       const u8 *src, unsigned int size)\n{\n\tmemzero_explicit(dst, size);\n}\n\nstatic void crypto_aegis128_encrypt_chunk(struct aegis_state *state, u8 *dst,\n\t\t\t\t\t  const u8 *src, unsigned int size)\n{\n\tunion aegis_block tmp;\n\n\tif (AEGIS_ALIGNED(src) && AEGIS_ALIGNED(dst)) {\n\t\twhile (size >= AEGIS_BLOCK_SIZE) {\n\t\t\tunion aegis_block *dst_blk =\n\t\t\t\t\t(union aegis_block *)dst;\n\t\t\tconst union aegis_block *src_blk =\n\t\t\t\t\t(const union aegis_block *)src;\n\n\t\t\ttmp = state->blocks[2];\n\t\t\tcrypto_aegis_block_and(&tmp, &state->blocks[3]);\n\t\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[4]);\n\t\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[1]);\n\t\t\tcrypto_aegis_block_xor(&tmp, src_blk);\n\n\t\t\tcrypto_aegis128_update_a(state, src_blk, false);\n\n\t\t\t*dst_blk = tmp;\n\n\t\t\tsize -= AEGIS_BLOCK_SIZE;\n\t\t\tsrc += AEGIS_BLOCK_SIZE;\n\t\t\tdst += AEGIS_BLOCK_SIZE;\n\t\t}\n\t} else {\n\t\twhile (size >= AEGIS_BLOCK_SIZE) {\n\t\t\ttmp = state->blocks[2];\n\t\t\tcrypto_aegis_block_and(&tmp, &state->blocks[3]);\n\t\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[4]);\n\t\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[1]);\n\t\t\tcrypto_xor(tmp.bytes, src, AEGIS_BLOCK_SIZE);\n\n\t\t\tcrypto_aegis128_update_u(state, src, false);\n\n\t\t\tmemcpy(dst, tmp.bytes, AEGIS_BLOCK_SIZE);\n\n\t\t\tsize -= AEGIS_BLOCK_SIZE;\n\t\t\tsrc += AEGIS_BLOCK_SIZE;\n\t\t\tdst += AEGIS_BLOCK_SIZE;\n\t\t}\n\t}\n\n\tif (size > 0) {\n\t\tunion aegis_block msg = {};\n\t\tmemcpy(msg.bytes, src, size);\n\n\t\ttmp = state->blocks[2];\n\t\tcrypto_aegis_block_and(&tmp, &state->blocks[3]);\n\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[4]);\n\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[1]);\n\n\t\tcrypto_aegis128_update_a(state, &msg, false);\n\n\t\tcrypto_aegis_block_xor(&msg, &tmp);\n\n\t\tmemcpy(dst, msg.bytes, size);\n\t}\n}\n\nstatic void crypto_aegis128_decrypt_chunk(struct aegis_state *state, u8 *dst,\n\t\t\t\t\t  const u8 *src, unsigned int size)\n{\n\tunion aegis_block tmp;\n\n\tif (AEGIS_ALIGNED(src) && AEGIS_ALIGNED(dst)) {\n\t\twhile (size >= AEGIS_BLOCK_SIZE) {\n\t\t\tunion aegis_block *dst_blk =\n\t\t\t\t\t(union aegis_block *)dst;\n\t\t\tconst union aegis_block *src_blk =\n\t\t\t\t\t(const union aegis_block *)src;\n\n\t\t\ttmp = state->blocks[2];\n\t\t\tcrypto_aegis_block_and(&tmp, &state->blocks[3]);\n\t\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[4]);\n\t\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[1]);\n\t\t\tcrypto_aegis_block_xor(&tmp, src_blk);\n\n\t\t\tcrypto_aegis128_update_a(state, &tmp, false);\n\n\t\t\t*dst_blk = tmp;\n\n\t\t\tsize -= AEGIS_BLOCK_SIZE;\n\t\t\tsrc += AEGIS_BLOCK_SIZE;\n\t\t\tdst += AEGIS_BLOCK_SIZE;\n\t\t}\n\t} else {\n\t\twhile (size >= AEGIS_BLOCK_SIZE) {\n\t\t\ttmp = state->blocks[2];\n\t\t\tcrypto_aegis_block_and(&tmp, &state->blocks[3]);\n\t\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[4]);\n\t\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[1]);\n\t\t\tcrypto_xor(tmp.bytes, src, AEGIS_BLOCK_SIZE);\n\n\t\t\tcrypto_aegis128_update_a(state, &tmp, false);\n\n\t\t\tmemcpy(dst, tmp.bytes, AEGIS_BLOCK_SIZE);\n\n\t\t\tsize -= AEGIS_BLOCK_SIZE;\n\t\t\tsrc += AEGIS_BLOCK_SIZE;\n\t\t\tdst += AEGIS_BLOCK_SIZE;\n\t\t}\n\t}\n\n\tif (size > 0) {\n\t\tunion aegis_block msg = {};\n\t\tmemcpy(msg.bytes, src, size);\n\n\t\ttmp = state->blocks[2];\n\t\tcrypto_aegis_block_and(&tmp, &state->blocks[3]);\n\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[4]);\n\t\tcrypto_aegis_block_xor(&tmp, &state->blocks[1]);\n\t\tcrypto_aegis_block_xor(&msg, &tmp);\n\n\t\tmemset(msg.bytes + size, 0, AEGIS_BLOCK_SIZE - size);\n\n\t\tcrypto_aegis128_update_a(state, &msg, false);\n\n\t\tmemcpy(dst, msg.bytes, size);\n\t}\n}\n\nstatic void crypto_aegis128_process_ad(struct aegis_state *state,\n\t\t\t\t       struct scatterlist *sg_src,\n\t\t\t\t       unsigned int assoclen,\n\t\t\t\t       bool do_simd)\n{\n\tstruct scatter_walk walk;\n\tunion aegis_block buf;\n\tunsigned int pos = 0;\n\n\tscatterwalk_start(&walk, sg_src);\n\twhile (assoclen != 0) {\n\t\tunsigned int size = scatterwalk_clamp(&walk, assoclen);\n\t\tunsigned int left = size;\n\t\tvoid *mapped = scatterwalk_map(&walk);\n\t\tconst u8 *src = (const u8 *)mapped;\n\n\t\tif (pos + size >= AEGIS_BLOCK_SIZE) {\n\t\t\tif (pos > 0) {\n\t\t\t\tunsigned int fill = AEGIS_BLOCK_SIZE - pos;\n\t\t\t\tmemcpy(buf.bytes + pos, src, fill);\n\t\t\t\tcrypto_aegis128_update_a(state, &buf, do_simd);\n\t\t\t\tpos = 0;\n\t\t\t\tleft -= fill;\n\t\t\t\tsrc += fill;\n\t\t\t}\n\n\t\t\tcrypto_aegis128_ad(state, src, left, do_simd);\n\t\t\tsrc += left & ~(AEGIS_BLOCK_SIZE - 1);\n\t\t\tleft &= AEGIS_BLOCK_SIZE - 1;\n\t\t}\n\n\t\tmemcpy(buf.bytes + pos, src, left);\n\n\t\tpos += left;\n\t\tassoclen -= size;\n\t\tscatterwalk_unmap(mapped);\n\t\tscatterwalk_advance(&walk, size);\n\t\tscatterwalk_done(&walk, 0, assoclen);\n\t}\n\n\tif (pos > 0) {\n\t\tmemset(buf.bytes + pos, 0, AEGIS_BLOCK_SIZE - pos);\n\t\tcrypto_aegis128_update_a(state, &buf, do_simd);\n\t}\n}\n\nstatic __always_inline\nint crypto_aegis128_process_crypt(struct aegis_state *state,\n\t\t\t\t  struct skcipher_walk *walk,\n\t\t\t\t  void (*crypt)(struct aegis_state *state,\n\t\t\t\t\t        u8 *dst, const u8 *src,\n\t\t\t\t\t        unsigned int size))\n{\n\tint err = 0;\n\n\twhile (walk->nbytes) {\n\t\tunsigned int nbytes = walk->nbytes;\n\n\t\tif (nbytes < walk->total)\n\t\t\tnbytes = round_down(nbytes, walk->stride);\n\n\t\tcrypt(state, walk->dst.virt.addr, walk->src.virt.addr, nbytes);\n\n\t\terr = skcipher_walk_done(walk, walk->nbytes - nbytes);\n\t}\n\treturn err;\n}\n\nstatic void crypto_aegis128_final(struct aegis_state *state,\n\t\t\t\t  union aegis_block *tag_xor,\n\t\t\t\t  u64 assoclen, u64 cryptlen)\n{\n\tu64 assocbits = assoclen * 8;\n\tu64 cryptbits = cryptlen * 8;\n\n\tunion aegis_block tmp;\n\tunsigned int i;\n\n\ttmp.words64[0] = cpu_to_le64(assocbits);\n\ttmp.words64[1] = cpu_to_le64(cryptbits);\n\n\tcrypto_aegis_block_xor(&tmp, &state->blocks[3]);\n\n\tfor (i = 0; i < 7; i++)\n\t\tcrypto_aegis128_update_a(state, &tmp, false);\n\n\tfor (i = 0; i < AEGIS128_STATE_BLOCKS; i++)\n\t\tcrypto_aegis_block_xor(tag_xor, &state->blocks[i]);\n}\n\nstatic int crypto_aegis128_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t\t  unsigned int keylen)\n{\n\tstruct aegis_ctx *ctx = crypto_aead_ctx(aead);\n\n\tif (keylen != AEGIS128_KEY_SIZE)\n\t\treturn -EINVAL;\n\n\tmemcpy(ctx->key.bytes, key, AEGIS128_KEY_SIZE);\n\treturn 0;\n}\n\nstatic int crypto_aegis128_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t       unsigned int authsize)\n{\n\tif (authsize > AEGIS128_MAX_AUTH_SIZE)\n\t\treturn -EINVAL;\n\tif (authsize < AEGIS128_MIN_AUTH_SIZE)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int crypto_aegis128_encrypt_generic(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tunion aegis_block tag = {};\n\tunsigned int authsize = crypto_aead_authsize(tfm);\n\tstruct aegis_ctx *ctx = crypto_aead_ctx(tfm);\n\tunsigned int cryptlen = req->cryptlen;\n\tstruct skcipher_walk walk;\n\tstruct aegis_state state;\n\n\tskcipher_walk_aead_encrypt(&walk, req, false);\n\tcrypto_aegis128_init(&state, &ctx->key, req->iv);\n\tcrypto_aegis128_process_ad(&state, req->src, req->assoclen, false);\n\tcrypto_aegis128_process_crypt(&state, &walk,\n\t\t\t\t      crypto_aegis128_encrypt_chunk);\n\tcrypto_aegis128_final(&state, &tag, req->assoclen, cryptlen);\n\n\tscatterwalk_map_and_copy(tag.bytes, req->dst, req->assoclen + cryptlen,\n\t\t\t\t authsize, 1);\n\treturn 0;\n}\n\nstatic int crypto_aegis128_decrypt_generic(struct aead_request *req)\n{\n\tstatic const u8 zeros[AEGIS128_MAX_AUTH_SIZE] = {};\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tunion aegis_block tag;\n\tunsigned int authsize = crypto_aead_authsize(tfm);\n\tunsigned int cryptlen = req->cryptlen - authsize;\n\tstruct aegis_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct skcipher_walk walk;\n\tstruct aegis_state state;\n\n\tscatterwalk_map_and_copy(tag.bytes, req->src, req->assoclen + cryptlen,\n\t\t\t\t authsize, 0);\n\n\tskcipher_walk_aead_decrypt(&walk, req, false);\n\tcrypto_aegis128_init(&state, &ctx->key, req->iv);\n\tcrypto_aegis128_process_ad(&state, req->src, req->assoclen, false);\n\tcrypto_aegis128_process_crypt(&state, &walk,\n\t\t\t\t      crypto_aegis128_decrypt_chunk);\n\tcrypto_aegis128_final(&state, &tag, req->assoclen, cryptlen);\n\n\tif (unlikely(crypto_memneq(tag.bytes, zeros, authsize))) {\n\t\t \n\t\tskcipher_walk_aead_decrypt(&walk, req, false);\n\t\tcrypto_aegis128_process_crypt(NULL, &walk,\n\t\t\t\t\t      crypto_aegis128_wipe_chunk);\n\t\tmemzero_explicit(&tag, sizeof(tag));\n\t\treturn -EBADMSG;\n\t}\n\treturn 0;\n}\n\nstatic int crypto_aegis128_encrypt_simd(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tunion aegis_block tag = {};\n\tunsigned int authsize = crypto_aead_authsize(tfm);\n\tstruct aegis_ctx *ctx = crypto_aead_ctx(tfm);\n\tunsigned int cryptlen = req->cryptlen;\n\tstruct skcipher_walk walk;\n\tstruct aegis_state state;\n\n\tif (!aegis128_do_simd())\n\t\treturn crypto_aegis128_encrypt_generic(req);\n\n\tskcipher_walk_aead_encrypt(&walk, req, false);\n\tcrypto_aegis128_init_simd(&state, &ctx->key, req->iv);\n\tcrypto_aegis128_process_ad(&state, req->src, req->assoclen, true);\n\tcrypto_aegis128_process_crypt(&state, &walk,\n\t\t\t\t      crypto_aegis128_encrypt_chunk_simd);\n\tcrypto_aegis128_final_simd(&state, &tag, req->assoclen, cryptlen, 0);\n\n\tscatterwalk_map_and_copy(tag.bytes, req->dst, req->assoclen + cryptlen,\n\t\t\t\t authsize, 1);\n\treturn 0;\n}\n\nstatic int crypto_aegis128_decrypt_simd(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tunion aegis_block tag;\n\tunsigned int authsize = crypto_aead_authsize(tfm);\n\tunsigned int cryptlen = req->cryptlen - authsize;\n\tstruct aegis_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct skcipher_walk walk;\n\tstruct aegis_state state;\n\n\tif (!aegis128_do_simd())\n\t\treturn crypto_aegis128_decrypt_generic(req);\n\n\tscatterwalk_map_and_copy(tag.bytes, req->src, req->assoclen + cryptlen,\n\t\t\t\t authsize, 0);\n\n\tskcipher_walk_aead_decrypt(&walk, req, false);\n\tcrypto_aegis128_init_simd(&state, &ctx->key, req->iv);\n\tcrypto_aegis128_process_ad(&state, req->src, req->assoclen, true);\n\tcrypto_aegis128_process_crypt(&state, &walk,\n\t\t\t\t      crypto_aegis128_decrypt_chunk_simd);\n\n\tif (unlikely(crypto_aegis128_final_simd(&state, &tag, req->assoclen,\n\t\t\t\t\t\tcryptlen, authsize))) {\n\t\tskcipher_walk_aead_decrypt(&walk, req, false);\n\t\tcrypto_aegis128_process_crypt(NULL, &walk,\n\t\t\t\t\t      crypto_aegis128_wipe_chunk);\n\t\treturn -EBADMSG;\n\t}\n\treturn 0;\n}\n\nstatic struct aead_alg crypto_aegis128_alg_generic = {\n\t.setkey\t\t\t= crypto_aegis128_setkey,\n\t.setauthsize\t\t= crypto_aegis128_setauthsize,\n\t.encrypt\t\t= crypto_aegis128_encrypt_generic,\n\t.decrypt\t\t= crypto_aegis128_decrypt_generic,\n\n\t.ivsize\t\t\t= AEGIS128_NONCE_SIZE,\n\t.maxauthsize\t\t= AEGIS128_MAX_AUTH_SIZE,\n\t.chunksize\t\t= AEGIS_BLOCK_SIZE,\n\n\t.base.cra_blocksize\t= 1,\n\t.base.cra_ctxsize\t= sizeof(struct aegis_ctx),\n\t.base.cra_alignmask\t= 0,\n\t.base.cra_priority\t= 100,\n\t.base.cra_name\t\t= \"aegis128\",\n\t.base.cra_driver_name\t= \"aegis128-generic\",\n\t.base.cra_module\t= THIS_MODULE,\n};\n\nstatic struct aead_alg crypto_aegis128_alg_simd = {\n\t.setkey\t\t\t= crypto_aegis128_setkey,\n\t.setauthsize\t\t= crypto_aegis128_setauthsize,\n\t.encrypt\t\t= crypto_aegis128_encrypt_simd,\n\t.decrypt\t\t= crypto_aegis128_decrypt_simd,\n\n\t.ivsize\t\t\t= AEGIS128_NONCE_SIZE,\n\t.maxauthsize\t\t= AEGIS128_MAX_AUTH_SIZE,\n\t.chunksize\t\t= AEGIS_BLOCK_SIZE,\n\n\t.base.cra_blocksize\t= 1,\n\t.base.cra_ctxsize\t= sizeof(struct aegis_ctx),\n\t.base.cra_alignmask\t= 0,\n\t.base.cra_priority\t= 200,\n\t.base.cra_name\t\t= \"aegis128\",\n\t.base.cra_driver_name\t= \"aegis128-simd\",\n\t.base.cra_module\t= THIS_MODULE,\n};\n\nstatic int __init crypto_aegis128_module_init(void)\n{\n\tint ret;\n\n\tret = crypto_register_aead(&crypto_aegis128_alg_generic);\n\tif (ret)\n\t\treturn ret;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_AEGIS128_SIMD) &&\n\t    crypto_aegis128_have_simd()) {\n\t\tret = crypto_register_aead(&crypto_aegis128_alg_simd);\n\t\tif (ret) {\n\t\t\tcrypto_unregister_aead(&crypto_aegis128_alg_generic);\n\t\t\treturn ret;\n\t\t}\n\t\tstatic_branch_enable(&have_simd);\n\t}\n\treturn 0;\n}\n\nstatic void __exit crypto_aegis128_module_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_CRYPTO_AEGIS128_SIMD) &&\n\t    crypto_aegis128_have_simd())\n\t\tcrypto_unregister_aead(&crypto_aegis128_alg_simd);\n\n\tcrypto_unregister_aead(&crypto_aegis128_alg_generic);\n}\n\nsubsys_initcall(crypto_aegis128_module_init);\nmodule_exit(crypto_aegis128_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ondrej Mosnacek <omosnacek@gmail.com>\");\nMODULE_DESCRIPTION(\"AEGIS-128 AEAD algorithm\");\nMODULE_ALIAS_CRYPTO(\"aegis128\");\nMODULE_ALIAS_CRYPTO(\"aegis128-generic\");\nMODULE_ALIAS_CRYPTO(\"aegis128-simd\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}