{
  "module_name": "ecc.c",
  "hash_id": "21eb0c140922a44e3a00cffe8084dbdbdbd5ec84bc700747d402582889237de9",
  "original_prompt": "Ingested from linux-6.6.14/crypto/ecc.c",
  "human_readable_source": " \n\n#include <crypto/ecc_curve.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/swab.h>\n#include <linux/fips.h>\n#include <crypto/ecdh.h>\n#include <crypto/rng.h>\n#include <crypto/internal/ecc.h>\n#include <asm/unaligned.h>\n#include <linux/ratelimit.h>\n\n#include \"ecc_curve_defs.h\"\n\ntypedef struct {\n\tu64 m_low;\n\tu64 m_high;\n} uint128_t;\n\n \nconst struct ecc_curve *ecc_get_curve25519(void)\n{\n\treturn &ecc_25519;\n}\nEXPORT_SYMBOL(ecc_get_curve25519);\n\nconst struct ecc_curve *ecc_get_curve(unsigned int curve_id)\n{\n\tswitch (curve_id) {\n\t \n\tcase ECC_CURVE_NIST_P192:\n\t\treturn fips_enabled ? NULL : &nist_p192;\n\tcase ECC_CURVE_NIST_P256:\n\t\treturn &nist_p256;\n\tcase ECC_CURVE_NIST_P384:\n\t\treturn &nist_p384;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\nEXPORT_SYMBOL(ecc_get_curve);\n\nstatic u64 *ecc_alloc_digits_space(unsigned int ndigits)\n{\n\tsize_t len = ndigits * sizeof(u64);\n\n\tif (!len)\n\t\treturn NULL;\n\n\treturn kmalloc(len, GFP_KERNEL);\n}\n\nstatic void ecc_free_digits_space(u64 *space)\n{\n\tkfree_sensitive(space);\n}\n\nstruct ecc_point *ecc_alloc_point(unsigned int ndigits)\n{\n\tstruct ecc_point *p = kmalloc(sizeof(*p), GFP_KERNEL);\n\n\tif (!p)\n\t\treturn NULL;\n\n\tp->x = ecc_alloc_digits_space(ndigits);\n\tif (!p->x)\n\t\tgoto err_alloc_x;\n\n\tp->y = ecc_alloc_digits_space(ndigits);\n\tif (!p->y)\n\t\tgoto err_alloc_y;\n\n\tp->ndigits = ndigits;\n\n\treturn p;\n\nerr_alloc_y:\n\tecc_free_digits_space(p->x);\nerr_alloc_x:\n\tkfree(p);\n\treturn NULL;\n}\nEXPORT_SYMBOL(ecc_alloc_point);\n\nvoid ecc_free_point(struct ecc_point *p)\n{\n\tif (!p)\n\t\treturn;\n\n\tkfree_sensitive(p->x);\n\tkfree_sensitive(p->y);\n\tkfree_sensitive(p);\n}\nEXPORT_SYMBOL(ecc_free_point);\n\nstatic void vli_clear(u64 *vli, unsigned int ndigits)\n{\n\tint i;\n\n\tfor (i = 0; i < ndigits; i++)\n\t\tvli[i] = 0;\n}\n\n \nbool vli_is_zero(const u64 *vli, unsigned int ndigits)\n{\n\tint i;\n\n\tfor (i = 0; i < ndigits; i++) {\n\t\tif (vli[i])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(vli_is_zero);\n\n \nstatic u64 vli_test_bit(const u64 *vli, unsigned int bit)\n{\n\treturn (vli[bit / 64] & ((u64)1 << (bit % 64)));\n}\n\nstatic bool vli_is_negative(const u64 *vli, unsigned int ndigits)\n{\n\treturn vli_test_bit(vli, ndigits * 64 - 1);\n}\n\n \nstatic unsigned int vli_num_digits(const u64 *vli, unsigned int ndigits)\n{\n\tint i;\n\n\t \n\tfor (i = ndigits - 1; i >= 0 && vli[i] == 0; i--);\n\n\treturn (i + 1);\n}\n\n \nunsigned int vli_num_bits(const u64 *vli, unsigned int ndigits)\n{\n\tunsigned int i, num_digits;\n\tu64 digit;\n\n\tnum_digits = vli_num_digits(vli, ndigits);\n\tif (num_digits == 0)\n\t\treturn 0;\n\n\tdigit = vli[num_digits - 1];\n\tfor (i = 0; digit; i++)\n\t\tdigit >>= 1;\n\n\treturn ((num_digits - 1) * 64 + i);\n}\nEXPORT_SYMBOL(vli_num_bits);\n\n \nvoid vli_from_be64(u64 *dest, const void *src, unsigned int ndigits)\n{\n\tint i;\n\tconst u64 *from = src;\n\n\tfor (i = 0; i < ndigits; i++)\n\t\tdest[i] = get_unaligned_be64(&from[ndigits - 1 - i]);\n}\nEXPORT_SYMBOL(vli_from_be64);\n\nvoid vli_from_le64(u64 *dest, const void *src, unsigned int ndigits)\n{\n\tint i;\n\tconst u64 *from = src;\n\n\tfor (i = 0; i < ndigits; i++)\n\t\tdest[i] = get_unaligned_le64(&from[i]);\n}\nEXPORT_SYMBOL(vli_from_le64);\n\n \nstatic void vli_set(u64 *dest, const u64 *src, unsigned int ndigits)\n{\n\tint i;\n\n\tfor (i = 0; i < ndigits; i++)\n\t\tdest[i] = src[i];\n}\n\n \nint vli_cmp(const u64 *left, const u64 *right, unsigned int ndigits)\n{\n\tint i;\n\n\tfor (i = ndigits - 1; i >= 0; i--) {\n\t\tif (left[i] > right[i])\n\t\t\treturn 1;\n\t\telse if (left[i] < right[i])\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vli_cmp);\n\n \nstatic u64 vli_lshift(u64 *result, const u64 *in, unsigned int shift,\n\t\t      unsigned int ndigits)\n{\n\tu64 carry = 0;\n\tint i;\n\n\tfor (i = 0; i < ndigits; i++) {\n\t\tu64 temp = in[i];\n\n\t\tresult[i] = (temp << shift) | carry;\n\t\tcarry = temp >> (64 - shift);\n\t}\n\n\treturn carry;\n}\n\n \nstatic void vli_rshift1(u64 *vli, unsigned int ndigits)\n{\n\tu64 *end = vli;\n\tu64 carry = 0;\n\n\tvli += ndigits;\n\n\twhile (vli-- > end) {\n\t\tu64 temp = *vli;\n\t\t*vli = (temp >> 1) | carry;\n\t\tcarry = temp << 63;\n\t}\n}\n\n \nstatic u64 vli_add(u64 *result, const u64 *left, const u64 *right,\n\t\t   unsigned int ndigits)\n{\n\tu64 carry = 0;\n\tint i;\n\n\tfor (i = 0; i < ndigits; i++) {\n\t\tu64 sum;\n\n\t\tsum = left[i] + right[i] + carry;\n\t\tif (sum != left[i])\n\t\t\tcarry = (sum < left[i]);\n\n\t\tresult[i] = sum;\n\t}\n\n\treturn carry;\n}\n\n \nstatic u64 vli_uadd(u64 *result, const u64 *left, u64 right,\n\t\t    unsigned int ndigits)\n{\n\tu64 carry = right;\n\tint i;\n\n\tfor (i = 0; i < ndigits; i++) {\n\t\tu64 sum;\n\n\t\tsum = left[i] + carry;\n\t\tif (sum != left[i])\n\t\t\tcarry = (sum < left[i]);\n\t\telse\n\t\t\tcarry = !!carry;\n\n\t\tresult[i] = sum;\n\t}\n\n\treturn carry;\n}\n\n \nu64 vli_sub(u64 *result, const u64 *left, const u64 *right,\n\t\t   unsigned int ndigits)\n{\n\tu64 borrow = 0;\n\tint i;\n\n\tfor (i = 0; i < ndigits; i++) {\n\t\tu64 diff;\n\n\t\tdiff = left[i] - right[i] - borrow;\n\t\tif (diff != left[i])\n\t\t\tborrow = (diff > left[i]);\n\n\t\tresult[i] = diff;\n\t}\n\n\treturn borrow;\n}\nEXPORT_SYMBOL(vli_sub);\n\n \nstatic u64 vli_usub(u64 *result, const u64 *left, u64 right,\n\t     unsigned int ndigits)\n{\n\tu64 borrow = right;\n\tint i;\n\n\tfor (i = 0; i < ndigits; i++) {\n\t\tu64 diff;\n\n\t\tdiff = left[i] - borrow;\n\t\tif (diff != left[i])\n\t\t\tborrow = (diff > left[i]);\n\n\t\tresult[i] = diff;\n\t}\n\n\treturn borrow;\n}\n\nstatic uint128_t mul_64_64(u64 left, u64 right)\n{\n\tuint128_t result;\n#if defined(CONFIG_ARCH_SUPPORTS_INT128)\n\tunsigned __int128 m = (unsigned __int128)left * right;\n\n\tresult.m_low  = m;\n\tresult.m_high = m >> 64;\n#else\n\tu64 a0 = left & 0xffffffffull;\n\tu64 a1 = left >> 32;\n\tu64 b0 = right & 0xffffffffull;\n\tu64 b1 = right >> 32;\n\tu64 m0 = a0 * b0;\n\tu64 m1 = a0 * b1;\n\tu64 m2 = a1 * b0;\n\tu64 m3 = a1 * b1;\n\n\tm2 += (m0 >> 32);\n\tm2 += m1;\n\n\t \n\tif (m2 < m1)\n\t\tm3 += 0x100000000ull;\n\n\tresult.m_low = (m0 & 0xffffffffull) | (m2 << 32);\n\tresult.m_high = m3 + (m2 >> 32);\n#endif\n\treturn result;\n}\n\nstatic uint128_t add_128_128(uint128_t a, uint128_t b)\n{\n\tuint128_t result;\n\n\tresult.m_low = a.m_low + b.m_low;\n\tresult.m_high = a.m_high + b.m_high + (result.m_low < a.m_low);\n\n\treturn result;\n}\n\nstatic void vli_mult(u64 *result, const u64 *left, const u64 *right,\n\t\t     unsigned int ndigits)\n{\n\tuint128_t r01 = { 0, 0 };\n\tu64 r2 = 0;\n\tunsigned int i, k;\n\n\t \n\tfor (k = 0; k < ndigits * 2 - 1; k++) {\n\t\tunsigned int min;\n\n\t\tif (k < ndigits)\n\t\t\tmin = 0;\n\t\telse\n\t\t\tmin = (k + 1) - ndigits;\n\n\t\tfor (i = min; i <= k && i < ndigits; i++) {\n\t\t\tuint128_t product;\n\n\t\t\tproduct = mul_64_64(left[i], right[k - i]);\n\n\t\t\tr01 = add_128_128(r01, product);\n\t\t\tr2 += (r01.m_high < product.m_high);\n\t\t}\n\n\t\tresult[k] = r01.m_low;\n\t\tr01.m_low = r01.m_high;\n\t\tr01.m_high = r2;\n\t\tr2 = 0;\n\t}\n\n\tresult[ndigits * 2 - 1] = r01.m_low;\n}\n\n \nstatic void vli_umult(u64 *result, const u64 *left, u32 right,\n\t\t      unsigned int ndigits)\n{\n\tuint128_t r01 = { 0 };\n\tunsigned int k;\n\n\tfor (k = 0; k < ndigits; k++) {\n\t\tuint128_t product;\n\n\t\tproduct = mul_64_64(left[k], right);\n\t\tr01 = add_128_128(r01, product);\n\t\t \n\t\tresult[k] = r01.m_low;\n\t\tr01.m_low = r01.m_high;\n\t\tr01.m_high = 0;\n\t}\n\tresult[k] = r01.m_low;\n\tfor (++k; k < ndigits * 2; k++)\n\t\tresult[k] = 0;\n}\n\nstatic void vli_square(u64 *result, const u64 *left, unsigned int ndigits)\n{\n\tuint128_t r01 = { 0, 0 };\n\tu64 r2 = 0;\n\tint i, k;\n\n\tfor (k = 0; k < ndigits * 2 - 1; k++) {\n\t\tunsigned int min;\n\n\t\tif (k < ndigits)\n\t\t\tmin = 0;\n\t\telse\n\t\t\tmin = (k + 1) - ndigits;\n\n\t\tfor (i = min; i <= k && i <= k - i; i++) {\n\t\t\tuint128_t product;\n\n\t\t\tproduct = mul_64_64(left[i], left[k - i]);\n\n\t\t\tif (i < k - i) {\n\t\t\t\tr2 += product.m_high >> 63;\n\t\t\t\tproduct.m_high = (product.m_high << 1) |\n\t\t\t\t\t\t (product.m_low >> 63);\n\t\t\t\tproduct.m_low <<= 1;\n\t\t\t}\n\n\t\t\tr01 = add_128_128(r01, product);\n\t\t\tr2 += (r01.m_high < product.m_high);\n\t\t}\n\n\t\tresult[k] = r01.m_low;\n\t\tr01.m_low = r01.m_high;\n\t\tr01.m_high = r2;\n\t\tr2 = 0;\n\t}\n\n\tresult[ndigits * 2 - 1] = r01.m_low;\n}\n\n \nstatic void vli_mod_add(u64 *result, const u64 *left, const u64 *right,\n\t\t\tconst u64 *mod, unsigned int ndigits)\n{\n\tu64 carry;\n\n\tcarry = vli_add(result, left, right, ndigits);\n\n\t \n\tif (carry || vli_cmp(result, mod, ndigits) >= 0)\n\t\tvli_sub(result, result, mod, ndigits);\n}\n\n \nstatic void vli_mod_sub(u64 *result, const u64 *left, const u64 *right,\n\t\t\tconst u64 *mod, unsigned int ndigits)\n{\n\tu64 borrow = vli_sub(result, left, right, ndigits);\n\n\t \n\tif (borrow)\n\t\tvli_add(result, result, mod, ndigits);\n}\n\n \nstatic void vli_mmod_special(u64 *result, const u64 *product,\n\t\t\t      const u64 *mod, unsigned int ndigits)\n{\n\tu64 c = -mod[0];\n\tu64 t[ECC_MAX_DIGITS * 2];\n\tu64 r[ECC_MAX_DIGITS * 2];\n\n\tvli_set(r, product, ndigits * 2);\n\twhile (!vli_is_zero(r + ndigits, ndigits)) {\n\t\tvli_umult(t, r + ndigits, c, ndigits);\n\t\tvli_clear(r + ndigits, ndigits);\n\t\tvli_add(r, r, t, ndigits * 2);\n\t}\n\tvli_set(t, mod, ndigits);\n\tvli_clear(t + ndigits, ndigits);\n\twhile (vli_cmp(r, t, ndigits * 2) >= 0)\n\t\tvli_sub(r, r, t, ndigits * 2);\n\tvli_set(result, r, ndigits);\n}\n\n \nstatic void vli_mmod_special2(u64 *result, const u64 *product,\n\t\t\t       const u64 *mod, unsigned int ndigits)\n{\n\tu64 c2 = mod[0] * 2;\n\tu64 q[ECC_MAX_DIGITS];\n\tu64 r[ECC_MAX_DIGITS * 2];\n\tu64 m[ECC_MAX_DIGITS * 2];  \n\tint carry;  \n\tint i;\n\n\tvli_set(m, mod, ndigits);\n\tvli_clear(m + ndigits, ndigits);\n\n\tvli_set(r, product, ndigits);\n\t \n\tvli_set(q, product + ndigits, ndigits);\n\tvli_clear(r + ndigits, ndigits);\n\tcarry = vli_is_negative(r, ndigits);\n\tif (carry)\n\t\tr[ndigits - 1] &= (1ull << 63) - 1;\n\tfor (i = 1; carry || !vli_is_zero(q, ndigits); i++) {\n\t\tu64 qc[ECC_MAX_DIGITS * 2];\n\n\t\tvli_umult(qc, q, c2, ndigits);\n\t\tif (carry)\n\t\t\tvli_uadd(qc, qc, mod[0], ndigits * 2);\n\t\tvli_set(q, qc + ndigits, ndigits);\n\t\tvli_clear(qc + ndigits, ndigits);\n\t\tcarry = vli_is_negative(qc, ndigits);\n\t\tif (carry)\n\t\t\tqc[ndigits - 1] &= (1ull << 63) - 1;\n\t\tif (i & 1)\n\t\t\tvli_sub(r, r, qc, ndigits * 2);\n\t\telse\n\t\t\tvli_add(r, r, qc, ndigits * 2);\n\t}\n\twhile (vli_is_negative(r, ndigits * 2))\n\t\tvli_add(r, r, m, ndigits * 2);\n\twhile (vli_cmp(r, m, ndigits * 2) >= 0)\n\t\tvli_sub(r, r, m, ndigits * 2);\n\n\tvli_set(result, r, ndigits);\n}\n\n \nstatic void vli_mmod_slow(u64 *result, u64 *product, const u64 *mod,\n\t\t\t  unsigned int ndigits)\n{\n\tu64 mod_m[2 * ECC_MAX_DIGITS];\n\tu64 tmp[2 * ECC_MAX_DIGITS];\n\tu64 *v[2] = { tmp, product };\n\tu64 carry = 0;\n\tunsigned int i;\n\t \n\tint shift = (ndigits * 2 * 64) - vli_num_bits(mod, ndigits);\n\tint word_shift = shift / 64;\n\tint bit_shift = shift % 64;\n\n\tvli_clear(mod_m, word_shift);\n\tif (bit_shift > 0) {\n\t\tfor (i = 0; i < ndigits; ++i) {\n\t\t\tmod_m[word_shift + i] = (mod[i] << bit_shift) | carry;\n\t\t\tcarry = mod[i] >> (64 - bit_shift);\n\t\t}\n\t} else\n\t\tvli_set(mod_m + word_shift, mod, ndigits);\n\n\tfor (i = 1; shift >= 0; --shift) {\n\t\tu64 borrow = 0;\n\t\tunsigned int j;\n\n\t\tfor (j = 0; j < ndigits * 2; ++j) {\n\t\t\tu64 diff = v[i][j] - mod_m[j] - borrow;\n\n\t\t\tif (diff != v[i][j])\n\t\t\t\tborrow = (diff > v[i][j]);\n\t\t\tv[1 - i][j] = diff;\n\t\t}\n\t\ti = !(i ^ borrow);  \n\t\tvli_rshift1(mod_m, ndigits);\n\t\tmod_m[ndigits - 1] |= mod_m[ndigits] << (64 - 1);\n\t\tvli_rshift1(mod_m + ndigits, ndigits);\n\t}\n\tvli_set(result, v[i], ndigits);\n}\n\n \nstatic void vli_mmod_barrett(u64 *result, u64 *product, const u64 *mod,\n\t\t\t     unsigned int ndigits)\n{\n\tu64 q[ECC_MAX_DIGITS * 2];\n\tu64 r[ECC_MAX_DIGITS * 2];\n\tconst u64 *mu = mod + ndigits;\n\n\tvli_mult(q, product + ndigits, mu, ndigits);\n\tif (mu[ndigits])\n\t\tvli_add(q + ndigits, q + ndigits, product + ndigits, ndigits);\n\tvli_mult(r, mod, q + ndigits, ndigits);\n\tvli_sub(r, product, r, ndigits * 2);\n\twhile (!vli_is_zero(r + ndigits, ndigits) ||\n\t       vli_cmp(r, mod, ndigits) != -1) {\n\t\tu64 carry;\n\n\t\tcarry = vli_sub(r, r, mod, ndigits);\n\t\tvli_usub(r + ndigits, r + ndigits, carry, ndigits);\n\t}\n\tvli_set(result, r, ndigits);\n}\n\n \nstatic void vli_mmod_fast_192(u64 *result, const u64 *product,\n\t\t\t      const u64 *curve_prime, u64 *tmp)\n{\n\tconst unsigned int ndigits = 3;\n\tint carry;\n\n\tvli_set(result, product, ndigits);\n\n\tvli_set(tmp, &product[3], ndigits);\n\tcarry = vli_add(result, result, tmp, ndigits);\n\n\ttmp[0] = 0;\n\ttmp[1] = product[3];\n\ttmp[2] = product[4];\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\ttmp[0] = tmp[1] = product[5];\n\ttmp[2] = 0;\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\twhile (carry || vli_cmp(curve_prime, result, ndigits) != 1)\n\t\tcarry -= vli_sub(result, result, curve_prime, ndigits);\n}\n\n \nstatic void vli_mmod_fast_256(u64 *result, const u64 *product,\n\t\t\t      const u64 *curve_prime, u64 *tmp)\n{\n\tint carry;\n\tconst unsigned int ndigits = 4;\n\n\t \n\tvli_set(result, product, ndigits);\n\n\t \n\ttmp[0] = 0;\n\ttmp[1] = product[5] & 0xffffffff00000000ull;\n\ttmp[2] = product[6];\n\ttmp[3] = product[7];\n\tcarry = vli_lshift(tmp, tmp, 1, ndigits);\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\t \n\ttmp[1] = product[6] << 32;\n\ttmp[2] = (product[6] >> 32) | (product[7] << 32);\n\ttmp[3] = product[7] >> 32;\n\tcarry += vli_lshift(tmp, tmp, 1, ndigits);\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = product[4];\n\ttmp[1] = product[5] & 0xffffffff;\n\ttmp[2] = 0;\n\ttmp[3] = product[7];\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = (product[4] >> 32) | (product[5] << 32);\n\ttmp[1] = (product[5] >> 32) | (product[6] & 0xffffffff00000000ull);\n\ttmp[2] = product[7];\n\ttmp[3] = (product[6] >> 32) | (product[4] << 32);\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = (product[5] >> 32) | (product[6] << 32);\n\ttmp[1] = (product[6] >> 32);\n\ttmp[2] = 0;\n\ttmp[3] = (product[4] & 0xffffffff) | (product[5] << 32);\n\tcarry -= vli_sub(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = product[6];\n\ttmp[1] = product[7];\n\ttmp[2] = 0;\n\ttmp[3] = (product[4] >> 32) | (product[5] & 0xffffffff00000000ull);\n\tcarry -= vli_sub(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = (product[6] >> 32) | (product[7] << 32);\n\ttmp[1] = (product[7] >> 32) | (product[4] << 32);\n\ttmp[2] = (product[4] >> 32) | (product[5] << 32);\n\ttmp[3] = (product[6] << 32);\n\tcarry -= vli_sub(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = product[7];\n\ttmp[1] = product[4] & 0xffffffff00000000ull;\n\ttmp[2] = product[5];\n\ttmp[3] = product[6] & 0xffffffff00000000ull;\n\tcarry -= vli_sub(result, result, tmp, ndigits);\n\n\tif (carry < 0) {\n\t\tdo {\n\t\t\tcarry += vli_add(result, result, curve_prime, ndigits);\n\t\t} while (carry < 0);\n\t} else {\n\t\twhile (carry || vli_cmp(curve_prime, result, ndigits) != 1)\n\t\t\tcarry -= vli_sub(result, result, curve_prime, ndigits);\n\t}\n}\n\n#define SL32OR32(x32, y32) (((u64)x32 << 32) | y32)\n#define AND64H(x64)  (x64 & 0xffFFffFF00000000ull)\n#define AND64L(x64)  (x64 & 0x00000000ffFFffFFull)\n\n \nstatic void vli_mmod_fast_384(u64 *result, const u64 *product,\n\t\t\t\tconst u64 *curve_prime, u64 *tmp)\n{\n\tint carry;\n\tconst unsigned int ndigits = 6;\n\n\t \n\tvli_set(result, product, ndigits);\n\n\t \n\ttmp[0] = 0;\t\t\n\ttmp[1] = 0;\t\t\n\ttmp[2] = SL32OR32(product[11], (product[10]>>32));\t\n\ttmp[3] = product[11]>>32;\t\n\ttmp[4] = 0;\t\t\n\ttmp[5] = 0;\t\t\n\tcarry = vli_lshift(tmp, tmp, 1, ndigits);\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = product[6];\t\n\ttmp[1] = product[7];\t\n\ttmp[2] = product[8];\t\n\ttmp[3] = product[9];\t\n\ttmp[4] = product[10];\t\n\ttmp[5] = product[11];\t\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = SL32OR32(product[11], (product[10]>>32));\t\n\ttmp[1] = SL32OR32(product[6], (product[11]>>32));\t\n\ttmp[2] = SL32OR32(product[7], (product[6])>>32);\t\n\ttmp[3] = SL32OR32(product[8], (product[7]>>32));\t\n\ttmp[4] = SL32OR32(product[9], (product[8]>>32));\t\n\ttmp[5] = SL32OR32(product[10], (product[9]>>32));\t\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = AND64H(product[11]);\t\n\ttmp[1] = (product[10]<<32);\t\n\ttmp[2] = product[6];\t\n\ttmp[3] = product[7];\t\n\ttmp[4] = product[8];\t\n\ttmp[5] = product[9];\t\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = 0;\t\t\n\ttmp[1] = 0;\t\t\n\ttmp[2] = product[10];\t\n\ttmp[3] = product[11];\t\n\ttmp[4] = 0;\t\t\n\ttmp[5] = 0;\t\t\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = AND64L(product[10]);\t\n\ttmp[1] = AND64H(product[10]);\t\n\ttmp[2] = product[11];\t\n\ttmp[3] = 0;\t\t\n\ttmp[4] = 0;\t\t\n\ttmp[5] = 0;\t\t\n\tcarry += vli_add(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = SL32OR32(product[6], (product[11]>>32));\t\n\ttmp[1] = SL32OR32(product[7], (product[6]>>32));\t\n\ttmp[2] = SL32OR32(product[8], (product[7]>>32));\t\n\ttmp[3] = SL32OR32(product[9], (product[8]>>32));\t\n\ttmp[4] = SL32OR32(product[10], (product[9]>>32));\t\n\ttmp[5] = SL32OR32(product[11], (product[10]>>32));\t\n\tcarry -= vli_sub(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = (product[10]<<32);\t\n\ttmp[1] = SL32OR32(product[11], (product[10]>>32));\t\n\ttmp[2] = (product[11]>>32);\t\n\ttmp[3] = 0;\t\t\n\ttmp[4] = 0;\t\t\n\ttmp[5] = 0;\t\t\n\tcarry -= vli_sub(result, result, tmp, ndigits);\n\n\t \n\ttmp[0] = 0;\t\t\n\ttmp[1] = AND64H(product[11]);\t\n\ttmp[2] = product[11]>>32;\t\n\ttmp[3] = 0;\t\t\n\ttmp[4] = 0;\t\t\n\ttmp[5] = 0;\t\t\n\tcarry -= vli_sub(result, result, tmp, ndigits);\n\n\tif (carry < 0) {\n\t\tdo {\n\t\t\tcarry += vli_add(result, result, curve_prime, ndigits);\n\t\t} while (carry < 0);\n\t} else {\n\t\twhile (carry || vli_cmp(curve_prime, result, ndigits) != 1)\n\t\t\tcarry -= vli_sub(result, result, curve_prime, ndigits);\n\t}\n\n}\n\n#undef SL32OR32\n#undef AND64H\n#undef AND64L\n\n \nstatic bool vli_mmod_fast(u64 *result, u64 *product,\n\t\t\t  const struct ecc_curve *curve)\n{\n\tu64 tmp[2 * ECC_MAX_DIGITS];\n\tconst u64 *curve_prime = curve->p;\n\tconst unsigned int ndigits = curve->g.ndigits;\n\n\t \n\tif (strncmp(curve->name, \"nist_\", 5) != 0) {\n\t\t \n\t\tif (curve_prime[ndigits - 1] == -1ull) {\n\t\t\tvli_mmod_special(result, product, curve_prime,\n\t\t\t\t\t ndigits);\n\t\t\treturn true;\n\t\t} else if (curve_prime[ndigits - 1] == 1ull << 63 &&\n\t\t\t   curve_prime[ndigits - 2] == 0) {\n\t\t\tvli_mmod_special2(result, product, curve_prime,\n\t\t\t\t\t  ndigits);\n\t\t\treturn true;\n\t\t}\n\t\tvli_mmod_barrett(result, product, curve_prime, ndigits);\n\t\treturn true;\n\t}\n\n\tswitch (ndigits) {\n\tcase 3:\n\t\tvli_mmod_fast_192(result, product, curve_prime, tmp);\n\t\tbreak;\n\tcase 4:\n\t\tvli_mmod_fast_256(result, product, curve_prime, tmp);\n\t\tbreak;\n\tcase 6:\n\t\tvli_mmod_fast_384(result, product, curve_prime, tmp);\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited(\"ecc: unsupported digits size!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nvoid vli_mod_mult_slow(u64 *result, const u64 *left, const u64 *right,\n\t\t       const u64 *mod, unsigned int ndigits)\n{\n\tu64 product[ECC_MAX_DIGITS * 2];\n\n\tvli_mult(product, left, right, ndigits);\n\tvli_mmod_slow(result, product, mod, ndigits);\n}\nEXPORT_SYMBOL(vli_mod_mult_slow);\n\n \nstatic void vli_mod_mult_fast(u64 *result, const u64 *left, const u64 *right,\n\t\t\t      const struct ecc_curve *curve)\n{\n\tu64 product[2 * ECC_MAX_DIGITS];\n\n\tvli_mult(product, left, right, curve->g.ndigits);\n\tvli_mmod_fast(result, product, curve);\n}\n\n \nstatic void vli_mod_square_fast(u64 *result, const u64 *left,\n\t\t\t\tconst struct ecc_curve *curve)\n{\n\tu64 product[2 * ECC_MAX_DIGITS];\n\n\tvli_square(product, left, curve->g.ndigits);\n\tvli_mmod_fast(result, product, curve);\n}\n\n#define EVEN(vli) (!(vli[0] & 1))\n \nvoid vli_mod_inv(u64 *result, const u64 *input, const u64 *mod,\n\t\t\tunsigned int ndigits)\n{\n\tu64 a[ECC_MAX_DIGITS], b[ECC_MAX_DIGITS];\n\tu64 u[ECC_MAX_DIGITS], v[ECC_MAX_DIGITS];\n\tu64 carry;\n\tint cmp_result;\n\n\tif (vli_is_zero(input, ndigits)) {\n\t\tvli_clear(result, ndigits);\n\t\treturn;\n\t}\n\n\tvli_set(a, input, ndigits);\n\tvli_set(b, mod, ndigits);\n\tvli_clear(u, ndigits);\n\tu[0] = 1;\n\tvli_clear(v, ndigits);\n\n\twhile ((cmp_result = vli_cmp(a, b, ndigits)) != 0) {\n\t\tcarry = 0;\n\n\t\tif (EVEN(a)) {\n\t\t\tvli_rshift1(a, ndigits);\n\n\t\t\tif (!EVEN(u))\n\t\t\t\tcarry = vli_add(u, u, mod, ndigits);\n\n\t\t\tvli_rshift1(u, ndigits);\n\t\t\tif (carry)\n\t\t\t\tu[ndigits - 1] |= 0x8000000000000000ull;\n\t\t} else if (EVEN(b)) {\n\t\t\tvli_rshift1(b, ndigits);\n\n\t\t\tif (!EVEN(v))\n\t\t\t\tcarry = vli_add(v, v, mod, ndigits);\n\n\t\t\tvli_rshift1(v, ndigits);\n\t\t\tif (carry)\n\t\t\t\tv[ndigits - 1] |= 0x8000000000000000ull;\n\t\t} else if (cmp_result > 0) {\n\t\t\tvli_sub(a, a, b, ndigits);\n\t\t\tvli_rshift1(a, ndigits);\n\n\t\t\tif (vli_cmp(u, v, ndigits) < 0)\n\t\t\t\tvli_add(u, u, mod, ndigits);\n\n\t\t\tvli_sub(u, u, v, ndigits);\n\t\t\tif (!EVEN(u))\n\t\t\t\tcarry = vli_add(u, u, mod, ndigits);\n\n\t\t\tvli_rshift1(u, ndigits);\n\t\t\tif (carry)\n\t\t\t\tu[ndigits - 1] |= 0x8000000000000000ull;\n\t\t} else {\n\t\t\tvli_sub(b, b, a, ndigits);\n\t\t\tvli_rshift1(b, ndigits);\n\n\t\t\tif (vli_cmp(v, u, ndigits) < 0)\n\t\t\t\tvli_add(v, v, mod, ndigits);\n\n\t\t\tvli_sub(v, v, u, ndigits);\n\t\t\tif (!EVEN(v))\n\t\t\t\tcarry = vli_add(v, v, mod, ndigits);\n\n\t\t\tvli_rshift1(v, ndigits);\n\t\t\tif (carry)\n\t\t\t\tv[ndigits - 1] |= 0x8000000000000000ull;\n\t\t}\n\t}\n\n\tvli_set(result, u, ndigits);\n}\nEXPORT_SYMBOL(vli_mod_inv);\n\n \n\n \nbool ecc_point_is_zero(const struct ecc_point *point)\n{\n\treturn (vli_is_zero(point->x, point->ndigits) &&\n\t\tvli_is_zero(point->y, point->ndigits));\n}\nEXPORT_SYMBOL(ecc_point_is_zero);\n\n \n\n \nstatic void ecc_point_double_jacobian(u64 *x1, u64 *y1, u64 *z1,\n\t\t\t\t\tconst struct ecc_curve *curve)\n{\n\t \n\tu64 t4[ECC_MAX_DIGITS];\n\tu64 t5[ECC_MAX_DIGITS];\n\tconst u64 *curve_prime = curve->p;\n\tconst unsigned int ndigits = curve->g.ndigits;\n\n\tif (vli_is_zero(z1, ndigits))\n\t\treturn;\n\n\t \n\tvli_mod_square_fast(t4, y1, curve);\n\t \n\tvli_mod_mult_fast(t5, x1, t4, curve);\n\t \n\tvli_mod_square_fast(t4, t4, curve);\n\t \n\tvli_mod_mult_fast(y1, y1, z1, curve);\n\t \n\tvli_mod_square_fast(z1, z1, curve);\n\n\t \n\tvli_mod_add(x1, x1, z1, curve_prime, ndigits);\n\t \n\tvli_mod_add(z1, z1, z1, curve_prime, ndigits);\n\t \n\tvli_mod_sub(z1, x1, z1, curve_prime, ndigits);\n\t \n\tvli_mod_mult_fast(x1, x1, z1, curve);\n\n\t \n\tvli_mod_add(z1, x1, x1, curve_prime, ndigits);\n\t \n\tvli_mod_add(x1, x1, z1, curve_prime, ndigits);\n\tif (vli_test_bit(x1, 0)) {\n\t\tu64 carry = vli_add(x1, x1, curve_prime, ndigits);\n\n\t\tvli_rshift1(x1, ndigits);\n\t\tx1[ndigits - 1] |= carry << 63;\n\t} else {\n\t\tvli_rshift1(x1, ndigits);\n\t}\n\t \n\n\t \n\tvli_mod_square_fast(z1, x1, curve);\n\t \n\tvli_mod_sub(z1, z1, t5, curve_prime, ndigits);\n\t \n\tvli_mod_sub(z1, z1, t5, curve_prime, ndigits);\n\t \n\tvli_mod_sub(t5, t5, z1, curve_prime, ndigits);\n\t \n\tvli_mod_mult_fast(x1, x1, t5, curve);\n\t \n\tvli_mod_sub(t4, x1, t4, curve_prime, ndigits);\n\n\tvli_set(x1, z1, ndigits);\n\tvli_set(z1, y1, ndigits);\n\tvli_set(y1, t4, ndigits);\n}\n\n \nstatic void apply_z(u64 *x1, u64 *y1, u64 *z, const struct ecc_curve *curve)\n{\n\tu64 t1[ECC_MAX_DIGITS];\n\n\tvli_mod_square_fast(t1, z, curve);\t\t \n\tvli_mod_mult_fast(x1, x1, t1, curve);\t \n\tvli_mod_mult_fast(t1, t1, z, curve);\t \n\tvli_mod_mult_fast(y1, y1, t1, curve);\t \n}\n\n \nstatic void xycz_initial_double(u64 *x1, u64 *y1, u64 *x2, u64 *y2,\n\t\t\t\tu64 *p_initial_z, const struct ecc_curve *curve)\n{\n\tu64 z[ECC_MAX_DIGITS];\n\tconst unsigned int ndigits = curve->g.ndigits;\n\n\tvli_set(x2, x1, ndigits);\n\tvli_set(y2, y1, ndigits);\n\n\tvli_clear(z, ndigits);\n\tz[0] = 1;\n\n\tif (p_initial_z)\n\t\tvli_set(z, p_initial_z, ndigits);\n\n\tapply_z(x1, y1, z, curve);\n\n\tecc_point_double_jacobian(x1, y1, z, curve);\n\n\tapply_z(x2, y2, z, curve);\n}\n\n \nstatic void xycz_add(u64 *x1, u64 *y1, u64 *x2, u64 *y2,\n\t\t\tconst struct ecc_curve *curve)\n{\n\t \n\tu64 t5[ECC_MAX_DIGITS];\n\tconst u64 *curve_prime = curve->p;\n\tconst unsigned int ndigits = curve->g.ndigits;\n\n\t \n\tvli_mod_sub(t5, x2, x1, curve_prime, ndigits);\n\t \n\tvli_mod_square_fast(t5, t5, curve);\n\t \n\tvli_mod_mult_fast(x1, x1, t5, curve);\n\t \n\tvli_mod_mult_fast(x2, x2, t5, curve);\n\t \n\tvli_mod_sub(y2, y2, y1, curve_prime, ndigits);\n\t \n\tvli_mod_square_fast(t5, y2, curve);\n\n\t \n\tvli_mod_sub(t5, t5, x1, curve_prime, ndigits);\n\t \n\tvli_mod_sub(t5, t5, x2, curve_prime, ndigits);\n\t \n\tvli_mod_sub(x2, x2, x1, curve_prime, ndigits);\n\t \n\tvli_mod_mult_fast(y1, y1, x2, curve);\n\t \n\tvli_mod_sub(x2, x1, t5, curve_prime, ndigits);\n\t \n\tvli_mod_mult_fast(y2, y2, x2, curve);\n\t \n\tvli_mod_sub(y2, y2, y1, curve_prime, ndigits);\n\n\tvli_set(x2, t5, ndigits);\n}\n\n \nstatic void xycz_add_c(u64 *x1, u64 *y1, u64 *x2, u64 *y2,\n\t\t\tconst struct ecc_curve *curve)\n{\n\t \n\tu64 t5[ECC_MAX_DIGITS];\n\tu64 t6[ECC_MAX_DIGITS];\n\tu64 t7[ECC_MAX_DIGITS];\n\tconst u64 *curve_prime = curve->p;\n\tconst unsigned int ndigits = curve->g.ndigits;\n\n\t \n\tvli_mod_sub(t5, x2, x1, curve_prime, ndigits);\n\t \n\tvli_mod_square_fast(t5, t5, curve);\n\t \n\tvli_mod_mult_fast(x1, x1, t5, curve);\n\t \n\tvli_mod_mult_fast(x2, x2, t5, curve);\n\t \n\tvli_mod_add(t5, y2, y1, curve_prime, ndigits);\n\t \n\tvli_mod_sub(y2, y2, y1, curve_prime, ndigits);\n\n\t \n\tvli_mod_sub(t6, x2, x1, curve_prime, ndigits);\n\t \n\tvli_mod_mult_fast(y1, y1, t6, curve);\n\t \n\tvli_mod_add(t6, x1, x2, curve_prime, ndigits);\n\t \n\tvli_mod_square_fast(x2, y2, curve);\n\t \n\tvli_mod_sub(x2, x2, t6, curve_prime, ndigits);\n\n\t \n\tvli_mod_sub(t7, x1, x2, curve_prime, ndigits);\n\t \n\tvli_mod_mult_fast(y2, y2, t7, curve);\n\t \n\tvli_mod_sub(y2, y2, y1, curve_prime, ndigits);\n\n\t \n\tvli_mod_square_fast(t7, t5, curve);\n\t \n\tvli_mod_sub(t7, t7, t6, curve_prime, ndigits);\n\t \n\tvli_mod_sub(t6, t7, x1, curve_prime, ndigits);\n\t \n\tvli_mod_mult_fast(t6, t6, t5, curve);\n\t \n\tvli_mod_sub(y1, t6, y1, curve_prime, ndigits);\n\n\tvli_set(x1, t7, ndigits);\n}\n\nstatic void ecc_point_mult(struct ecc_point *result,\n\t\t\t   const struct ecc_point *point, const u64 *scalar,\n\t\t\t   u64 *initial_z, const struct ecc_curve *curve,\n\t\t\t   unsigned int ndigits)\n{\n\t \n\tu64 rx[2][ECC_MAX_DIGITS];\n\tu64 ry[2][ECC_MAX_DIGITS];\n\tu64 z[ECC_MAX_DIGITS];\n\tu64 sk[2][ECC_MAX_DIGITS];\n\tu64 *curve_prime = curve->p;\n\tint i, nb;\n\tint num_bits;\n\tint carry;\n\n\tcarry = vli_add(sk[0], scalar, curve->n, ndigits);\n\tvli_add(sk[1], sk[0], curve->n, ndigits);\n\tscalar = sk[!carry];\n\tnum_bits = sizeof(u64) * ndigits * 8 + 1;\n\n\tvli_set(rx[1], point->x, ndigits);\n\tvli_set(ry[1], point->y, ndigits);\n\n\txycz_initial_double(rx[1], ry[1], rx[0], ry[0], initial_z, curve);\n\n\tfor (i = num_bits - 2; i > 0; i--) {\n\t\tnb = !vli_test_bit(scalar, i);\n\t\txycz_add_c(rx[1 - nb], ry[1 - nb], rx[nb], ry[nb], curve);\n\t\txycz_add(rx[nb], ry[nb], rx[1 - nb], ry[1 - nb], curve);\n\t}\n\n\tnb = !vli_test_bit(scalar, 0);\n\txycz_add_c(rx[1 - nb], ry[1 - nb], rx[nb], ry[nb], curve);\n\n\t \n\t \n\tvli_mod_sub(z, rx[1], rx[0], curve_prime, ndigits);\n\t \n\tvli_mod_mult_fast(z, z, ry[1 - nb], curve);\n\t \n\tvli_mod_mult_fast(z, z, point->x, curve);\n\n\t \n\tvli_mod_inv(z, z, curve_prime, point->ndigits);\n\n\t \n\tvli_mod_mult_fast(z, z, point->y, curve);\n\t \n\tvli_mod_mult_fast(z, z, rx[1 - nb], curve);\n\t \n\n\txycz_add(rx[nb], ry[nb], rx[1 - nb], ry[1 - nb], curve);\n\n\tapply_z(rx[0], ry[0], z, curve);\n\n\tvli_set(result->x, rx[0], ndigits);\n\tvli_set(result->y, ry[0], ndigits);\n}\n\n \nstatic void ecc_point_add(const struct ecc_point *result,\n\t\t   const struct ecc_point *p, const struct ecc_point *q,\n\t\t   const struct ecc_curve *curve)\n{\n\tu64 z[ECC_MAX_DIGITS];\n\tu64 px[ECC_MAX_DIGITS];\n\tu64 py[ECC_MAX_DIGITS];\n\tunsigned int ndigits = curve->g.ndigits;\n\n\tvli_set(result->x, q->x, ndigits);\n\tvli_set(result->y, q->y, ndigits);\n\tvli_mod_sub(z, result->x, p->x, curve->p, ndigits);\n\tvli_set(px, p->x, ndigits);\n\tvli_set(py, p->y, ndigits);\n\txycz_add(px, py, result->x, result->y, curve);\n\tvli_mod_inv(z, z, curve->p, ndigits);\n\tapply_z(result->x, result->y, z, curve);\n}\n\n \nvoid ecc_point_mult_shamir(const struct ecc_point *result,\n\t\t\t   const u64 *u1, const struct ecc_point *p,\n\t\t\t   const u64 *u2, const struct ecc_point *q,\n\t\t\t   const struct ecc_curve *curve)\n{\n\tu64 z[ECC_MAX_DIGITS];\n\tu64 sump[2][ECC_MAX_DIGITS];\n\tu64 *rx = result->x;\n\tu64 *ry = result->y;\n\tunsigned int ndigits = curve->g.ndigits;\n\tunsigned int num_bits;\n\tstruct ecc_point sum = ECC_POINT_INIT(sump[0], sump[1], ndigits);\n\tconst struct ecc_point *points[4];\n\tconst struct ecc_point *point;\n\tunsigned int idx;\n\tint i;\n\n\tecc_point_add(&sum, p, q, curve);\n\tpoints[0] = NULL;\n\tpoints[1] = p;\n\tpoints[2] = q;\n\tpoints[3] = &sum;\n\n\tnum_bits = max(vli_num_bits(u1, ndigits), vli_num_bits(u2, ndigits));\n\ti = num_bits - 1;\n\tidx = !!vli_test_bit(u1, i);\n\tidx |= (!!vli_test_bit(u2, i)) << 1;\n\tpoint = points[idx];\n\n\tvli_set(rx, point->x, ndigits);\n\tvli_set(ry, point->y, ndigits);\n\tvli_clear(z + 1, ndigits - 1);\n\tz[0] = 1;\n\n\tfor (--i; i >= 0; i--) {\n\t\tecc_point_double_jacobian(rx, ry, z, curve);\n\t\tidx = !!vli_test_bit(u1, i);\n\t\tidx |= (!!vli_test_bit(u2, i)) << 1;\n\t\tpoint = points[idx];\n\t\tif (point) {\n\t\t\tu64 tx[ECC_MAX_DIGITS];\n\t\t\tu64 ty[ECC_MAX_DIGITS];\n\t\t\tu64 tz[ECC_MAX_DIGITS];\n\n\t\t\tvli_set(tx, point->x, ndigits);\n\t\t\tvli_set(ty, point->y, ndigits);\n\t\t\tapply_z(tx, ty, z, curve);\n\t\t\tvli_mod_sub(tz, rx, tx, curve->p, ndigits);\n\t\t\txycz_add(tx, ty, rx, ry, curve);\n\t\t\tvli_mod_mult_fast(z, z, tz, curve);\n\t\t}\n\t}\n\tvli_mod_inv(z, z, curve->p, ndigits);\n\tapply_z(rx, ry, z, curve);\n}\nEXPORT_SYMBOL(ecc_point_mult_shamir);\n\nstatic int __ecc_is_key_valid(const struct ecc_curve *curve,\n\t\t\t      const u64 *private_key, unsigned int ndigits)\n{\n\tu64 one[ECC_MAX_DIGITS] = { 1, };\n\tu64 res[ECC_MAX_DIGITS];\n\n\tif (!private_key)\n\t\treturn -EINVAL;\n\n\tif (curve->g.ndigits != ndigits)\n\t\treturn -EINVAL;\n\n\t \n\tif (vli_cmp(one, private_key, ndigits) != -1)\n\t\treturn -EINVAL;\n\tvli_sub(res, curve->n, one, ndigits);\n\tvli_sub(res, res, one, ndigits);\n\tif (vli_cmp(res, private_key, ndigits) != 1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint ecc_is_key_valid(unsigned int curve_id, unsigned int ndigits,\n\t\t     const u64 *private_key, unsigned int private_key_len)\n{\n\tint nbytes;\n\tconst struct ecc_curve *curve = ecc_get_curve(curve_id);\n\n\tnbytes = ndigits << ECC_DIGITS_TO_BYTES_SHIFT;\n\n\tif (private_key_len != nbytes)\n\t\treturn -EINVAL;\n\n\treturn __ecc_is_key_valid(curve, private_key, ndigits);\n}\nEXPORT_SYMBOL(ecc_is_key_valid);\n\n \nint ecc_gen_privkey(unsigned int curve_id, unsigned int ndigits, u64 *privkey)\n{\n\tconst struct ecc_curve *curve = ecc_get_curve(curve_id);\n\tu64 priv[ECC_MAX_DIGITS];\n\tunsigned int nbytes = ndigits << ECC_DIGITS_TO_BYTES_SHIFT;\n\tunsigned int nbits = vli_num_bits(curve->n, ndigits);\n\tint err;\n\n\t \n\tif (nbits < 160 || ndigits > ARRAY_SIZE(priv))\n\t\treturn -EINVAL;\n\n\t \n\tif (crypto_get_default_rng())\n\t\treturn -EFAULT;\n\n\terr = crypto_rng_get_bytes(crypto_default_rng, (u8 *)priv, nbytes);\n\tcrypto_put_default_rng();\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (__ecc_is_key_valid(curve, priv, ndigits))\n\t\treturn -EINVAL;\n\n\tecc_swap_digits(priv, privkey, ndigits);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ecc_gen_privkey);\n\nint ecc_make_pub_key(unsigned int curve_id, unsigned int ndigits,\n\t\t     const u64 *private_key, u64 *public_key)\n{\n\tint ret = 0;\n\tstruct ecc_point *pk;\n\tu64 priv[ECC_MAX_DIGITS];\n\tconst struct ecc_curve *curve = ecc_get_curve(curve_id);\n\n\tif (!private_key || !curve || ndigits > ARRAY_SIZE(priv)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tecc_swap_digits(private_key, priv, ndigits);\n\n\tpk = ecc_alloc_point(ndigits);\n\tif (!pk) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tecc_point_mult(pk, &curve->g, priv, NULL, curve, ndigits);\n\n\t \n\tif (ecc_is_pubkey_valid_full(curve, pk)) {\n\t\tret = -EAGAIN;\n\t\tgoto err_free_point;\n\t}\n\n\tecc_swap_digits(pk->x, public_key, ndigits);\n\tecc_swap_digits(pk->y, &public_key[ndigits], ndigits);\n\nerr_free_point:\n\tecc_free_point(pk);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(ecc_make_pub_key);\n\n \nint ecc_is_pubkey_valid_partial(const struct ecc_curve *curve,\n\t\t\t\tstruct ecc_point *pk)\n{\n\tu64 yy[ECC_MAX_DIGITS], xxx[ECC_MAX_DIGITS], w[ECC_MAX_DIGITS];\n\n\tif (WARN_ON(pk->ndigits != curve->g.ndigits))\n\t\treturn -EINVAL;\n\n\t \n\tif (ecc_point_is_zero(pk))\n\t\treturn -EINVAL;\n\n\t \n\tif (vli_cmp(curve->p, pk->x, pk->ndigits) != 1)\n\t\treturn -EINVAL;\n\tif (vli_cmp(curve->p, pk->y, pk->ndigits) != 1)\n\t\treturn -EINVAL;\n\n\t \n\tvli_mod_square_fast(yy, pk->y, curve);  \n\tvli_mod_square_fast(xxx, pk->x, curve);  \n\tvli_mod_mult_fast(xxx, xxx, pk->x, curve);  \n\tvli_mod_mult_fast(w, curve->a, pk->x, curve);  \n\tvli_mod_add(w, w, curve->b, curve->p, pk->ndigits);  \n\tvli_mod_add(w, w, xxx, curve->p, pk->ndigits);  \n\tif (vli_cmp(yy, w, pk->ndigits) != 0)  \n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ecc_is_pubkey_valid_partial);\n\n \nint ecc_is_pubkey_valid_full(const struct ecc_curve *curve,\n\t\t\t     struct ecc_point *pk)\n{\n\tstruct ecc_point *nQ;\n\n\t \n\tint ret = ecc_is_pubkey_valid_partial(curve, pk);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnQ = ecc_alloc_point(pk->ndigits);\n\tif (!nQ)\n\t\treturn -ENOMEM;\n\n\tecc_point_mult(nQ, pk, curve->n, NULL, curve, pk->ndigits);\n\tif (!ecc_point_is_zero(nQ))\n\t\tret = -EINVAL;\n\n\tecc_free_point(nQ);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ecc_is_pubkey_valid_full);\n\nint crypto_ecdh_shared_secret(unsigned int curve_id, unsigned int ndigits,\n\t\t\t      const u64 *private_key, const u64 *public_key,\n\t\t\t      u64 *secret)\n{\n\tint ret = 0;\n\tstruct ecc_point *product, *pk;\n\tu64 priv[ECC_MAX_DIGITS];\n\tu64 rand_z[ECC_MAX_DIGITS];\n\tunsigned int nbytes;\n\tconst struct ecc_curve *curve = ecc_get_curve(curve_id);\n\n\tif (!private_key || !public_key || !curve ||\n\t    ndigits > ARRAY_SIZE(priv) || ndigits > ARRAY_SIZE(rand_z)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnbytes = ndigits << ECC_DIGITS_TO_BYTES_SHIFT;\n\n\tget_random_bytes(rand_z, nbytes);\n\n\tpk = ecc_alloc_point(ndigits);\n\tif (!pk) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tecc_swap_digits(public_key, pk->x, ndigits);\n\tecc_swap_digits(&public_key[ndigits], pk->y, ndigits);\n\tret = ecc_is_pubkey_valid_partial(curve, pk);\n\tif (ret)\n\t\tgoto err_alloc_product;\n\n\tecc_swap_digits(private_key, priv, ndigits);\n\n\tproduct = ecc_alloc_point(ndigits);\n\tif (!product) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_product;\n\t}\n\n\tecc_point_mult(product, pk, priv, rand_z, curve, ndigits);\n\n\tif (ecc_point_is_zero(product)) {\n\t\tret = -EFAULT;\n\t\tgoto err_validity;\n\t}\n\n\tecc_swap_digits(product->x, secret, ndigits);\n\nerr_validity:\n\tmemzero_explicit(priv, sizeof(priv));\n\tmemzero_explicit(rand_z, sizeof(rand_z));\n\tecc_free_point(product);\nerr_alloc_product:\n\tecc_free_point(pk);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(crypto_ecdh_shared_secret);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}