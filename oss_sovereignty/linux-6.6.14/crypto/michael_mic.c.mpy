{
  "module_name": "michael_mic.c",
  "hash_id": "75d60da10a8fce1faec309c9a8321d5dbe243a7256e38e387428ba20cb154fa7",
  "original_prompt": "Ingested from linux-6.6.14/crypto/michael_mic.c",
  "human_readable_source": "\n \n#include <crypto/internal/hash.h>\n#include <asm/unaligned.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n\nstruct michael_mic_ctx {\n\tu32 l, r;\n};\n\nstruct michael_mic_desc_ctx {\n\t__le32 pending;\n\tsize_t pending_len;\n\n\tu32 l, r;\n};\n\nstatic inline u32 xswap(u32 val)\n{\n\treturn ((val & 0x00ff00ff) << 8) | ((val & 0xff00ff00) >> 8);\n}\n\n\n#define michael_block(l, r)\t\\\ndo {\t\t\t\t\\\n\tr ^= rol32(l, 17);\t\\\n\tl += r;\t\t\t\\\n\tr ^= xswap(l);\t\t\\\n\tl += r;\t\t\t\\\n\tr ^= rol32(l, 3);\t\\\n\tl += r;\t\t\t\\\n\tr ^= ror32(l, 2);\t\\\n\tl += r;\t\t\t\\\n} while (0)\n\n\nstatic int michael_init(struct shash_desc *desc)\n{\n\tstruct michael_mic_desc_ctx *mctx = shash_desc_ctx(desc);\n\tstruct michael_mic_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tmctx->pending_len = 0;\n\tmctx->l = ctx->l;\n\tmctx->r = ctx->r;\n\n\treturn 0;\n}\n\n\nstatic int michael_update(struct shash_desc *desc, const u8 *data,\n\t\t\t   unsigned int len)\n{\n\tstruct michael_mic_desc_ctx *mctx = shash_desc_ctx(desc);\n\n\tif (mctx->pending_len) {\n\t\tint flen = 4 - mctx->pending_len;\n\t\tif (flen > len)\n\t\t\tflen = len;\n\t\tmemcpy((u8 *)&mctx->pending + mctx->pending_len, data, flen);\n\t\tmctx->pending_len += flen;\n\t\tdata += flen;\n\t\tlen -= flen;\n\n\t\tif (mctx->pending_len < 4)\n\t\t\treturn 0;\n\n\t\tmctx->l ^= le32_to_cpu(mctx->pending);\n\t\tmichael_block(mctx->l, mctx->r);\n\t\tmctx->pending_len = 0;\n\t}\n\n\twhile (len >= 4) {\n\t\tmctx->l ^= get_unaligned_le32(data);\n\t\tmichael_block(mctx->l, mctx->r);\n\t\tdata += 4;\n\t\tlen -= 4;\n\t}\n\n\tif (len > 0) {\n\t\tmctx->pending_len = len;\n\t\tmemcpy(&mctx->pending, data, len);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int michael_final(struct shash_desc *desc, u8 *out)\n{\n\tstruct michael_mic_desc_ctx *mctx = shash_desc_ctx(desc);\n\tu8 *data = (u8 *)&mctx->pending;\n\n\t \n\tswitch (mctx->pending_len) {\n\tcase 0:\n\t\tmctx->l ^= 0x5a;\n\t\tbreak;\n\tcase 1:\n\t\tmctx->l ^= data[0] | 0x5a00;\n\t\tbreak;\n\tcase 2:\n\t\tmctx->l ^= data[0] | (data[1] << 8) | 0x5a0000;\n\t\tbreak;\n\tcase 3:\n\t\tmctx->l ^= data[0] | (data[1] << 8) | (data[2] << 16) |\n\t\t\t0x5a000000;\n\t\tbreak;\n\t}\n\tmichael_block(mctx->l, mctx->r);\n\t \n\tmichael_block(mctx->l, mctx->r);\n\n\tput_unaligned_le32(mctx->l, out);\n\tput_unaligned_le32(mctx->r, out + 4);\n\n\treturn 0;\n}\n\n\nstatic int michael_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t  unsigned int keylen)\n{\n\tstruct michael_mic_ctx *mctx = crypto_shash_ctx(tfm);\n\n\tif (keylen != 8)\n\t\treturn -EINVAL;\n\n\tmctx->l = get_unaligned_le32(key);\n\tmctx->r = get_unaligned_le32(key + 4);\n\treturn 0;\n}\n\nstatic struct shash_alg alg = {\n\t.digestsize\t\t=\t8,\n\t.setkey\t\t\t=\tmichael_setkey,\n\t.init\t\t\t=\tmichael_init,\n\t.update\t\t\t=\tmichael_update,\n\t.final\t\t\t=\tmichael_final,\n\t.descsize\t\t=\tsizeof(struct michael_mic_desc_ctx),\n\t.base\t\t\t=\t{\n\t\t.cra_name\t\t=\t\"michael_mic\",\n\t\t.cra_driver_name\t=\t\"michael_mic-generic\",\n\t\t.cra_blocksize\t\t=\t8,\n\t\t.cra_ctxsize\t\t=\tsizeof(struct michael_mic_ctx),\n\t\t.cra_module\t\t=\tTHIS_MODULE,\n\t}\n};\n\nstatic int __init michael_mic_init(void)\n{\n\treturn crypto_register_shash(&alg);\n}\n\n\nstatic void __exit michael_mic_exit(void)\n{\n\tcrypto_unregister_shash(&alg);\n}\n\n\nsubsys_initcall(michael_mic_init);\nmodule_exit(michael_mic_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Michael MIC\");\nMODULE_AUTHOR(\"Jouni Malinen <j@w1.fi>\");\nMODULE_ALIAS_CRYPTO(\"michael_mic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}