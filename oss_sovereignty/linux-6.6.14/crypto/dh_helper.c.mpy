{
  "module_name": "dh_helper.c",
  "hash_id": "bca052ac47a60e986e623c8389bcde978e03bc437961cd5b59d1a27c1f209e8c",
  "original_prompt": "Ingested from linux-6.6.14/crypto/dh_helper.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n\n#define DH_KPP_SECRET_MIN_SIZE (sizeof(struct kpp_secret) + 3 * sizeof(int))\n\nstatic inline u8 *dh_pack_data(u8 *dst, u8 *end, const void *src, size_t size)\n{\n\tif (!dst || size > end - dst)\n\t\treturn NULL;\n\tmemcpy(dst, src, size);\n\treturn dst + size;\n}\n\nstatic inline const u8 *dh_unpack_data(void *dst, const void *src, size_t size)\n{\n\tmemcpy(dst, src, size);\n\treturn src + size;\n}\n\nstatic inline unsigned int dh_data_size(const struct dh *p)\n{\n\treturn p->key_size + p->p_size + p->g_size;\n}\n\nunsigned int crypto_dh_key_len(const struct dh *p)\n{\n\treturn DH_KPP_SECRET_MIN_SIZE + dh_data_size(p);\n}\nEXPORT_SYMBOL_GPL(crypto_dh_key_len);\n\nint crypto_dh_encode_key(char *buf, unsigned int len, const struct dh *params)\n{\n\tu8 *ptr = buf;\n\tu8 * const end = ptr + len;\n\tstruct kpp_secret secret = {\n\t\t.type = CRYPTO_KPP_SECRET_TYPE_DH,\n\t\t.len = len\n\t};\n\n\tif (unlikely(!len))\n\t\treturn -EINVAL;\n\n\tptr = dh_pack_data(ptr, end, &secret, sizeof(secret));\n\tptr = dh_pack_data(ptr, end, &params->key_size,\n\t\t\t   sizeof(params->key_size));\n\tptr = dh_pack_data(ptr, end, &params->p_size, sizeof(params->p_size));\n\tptr = dh_pack_data(ptr, end, &params->g_size, sizeof(params->g_size));\n\tptr = dh_pack_data(ptr, end, params->key, params->key_size);\n\tptr = dh_pack_data(ptr, end, params->p, params->p_size);\n\tptr = dh_pack_data(ptr, end, params->g, params->g_size);\n\tif (ptr != end)\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(crypto_dh_encode_key);\n\nint __crypto_dh_decode_key(const char *buf, unsigned int len, struct dh *params)\n{\n\tconst u8 *ptr = buf;\n\tstruct kpp_secret secret;\n\n\tif (unlikely(!buf || len < DH_KPP_SECRET_MIN_SIZE))\n\t\treturn -EINVAL;\n\n\tptr = dh_unpack_data(&secret, ptr, sizeof(secret));\n\tif (secret.type != CRYPTO_KPP_SECRET_TYPE_DH)\n\t\treturn -EINVAL;\n\n\tptr = dh_unpack_data(&params->key_size, ptr, sizeof(params->key_size));\n\tptr = dh_unpack_data(&params->p_size, ptr, sizeof(params->p_size));\n\tptr = dh_unpack_data(&params->g_size, ptr, sizeof(params->g_size));\n\tif (secret.len != crypto_dh_key_len(params))\n\t\treturn -EINVAL;\n\n\t \n\tparams->key = (void *)ptr;\n\tparams->p = (void *)(ptr + params->key_size);\n\tparams->g = (void *)(ptr + params->key_size + params->p_size);\n\n\treturn 0;\n}\n\nint crypto_dh_decode_key(const char *buf, unsigned int len, struct dh *params)\n{\n\tint err;\n\n\terr = __crypto_dh_decode_key(buf, len, params);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (params->key_size > params->p_size ||\n\t    params->g_size > params->p_size)\n\t\treturn -EINVAL;\n\n\t \n\tif (memchr_inv(params->p, 0, params->p_size) == NULL)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(crypto_dh_decode_key);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}