{
  "module_name": "aegis.h",
  "hash_id": "ec11a704c3531b8f4635a5984d026bd7f4d9db0fbbd3d0827b1b13f31ffbf920",
  "original_prompt": "Ingested from linux-6.6.14/crypto/aegis.h",
  "human_readable_source": " \n \n\n#ifndef _CRYPTO_AEGIS_H\n#define _CRYPTO_AEGIS_H\n\n#include <crypto/aes.h>\n#include <linux/bitops.h>\n#include <linux/types.h>\n\n#define AEGIS_BLOCK_SIZE 16\n\nunion aegis_block {\n\t__le64 words64[AEGIS_BLOCK_SIZE / sizeof(__le64)];\n\t__le32 words32[AEGIS_BLOCK_SIZE / sizeof(__le32)];\n\tu8 bytes[AEGIS_BLOCK_SIZE];\n};\n\nstruct aegis_state;\n\nextern int aegis128_have_aes_insn;\n\n#define AEGIS_BLOCK_ALIGN (__alignof__(union aegis_block))\n#define AEGIS_ALIGNED(p) IS_ALIGNED((uintptr_t)p, AEGIS_BLOCK_ALIGN)\n\nbool crypto_aegis128_have_simd(void);\nvoid crypto_aegis128_update_simd(struct aegis_state *state, const void *msg);\nvoid crypto_aegis128_init_simd(struct aegis_state *state,\n\t\t\t       const union aegis_block *key,\n\t\t\t       const u8 *iv);\nvoid crypto_aegis128_encrypt_chunk_simd(struct aegis_state *state, u8 *dst,\n\t\t\t\t\tconst u8 *src, unsigned int size);\nvoid crypto_aegis128_decrypt_chunk_simd(struct aegis_state *state, u8 *dst,\n\t\t\t\t\tconst u8 *src, unsigned int size);\nint crypto_aegis128_final_simd(struct aegis_state *state,\n\t\t\t       union aegis_block *tag_xor,\n\t\t\t       unsigned int assoclen,\n\t\t\t       unsigned int cryptlen,\n\t\t\t       unsigned int authsize);\n\nstatic __always_inline void crypto_aegis_block_xor(union aegis_block *dst,\n\t\t\t\t\t\t   const union aegis_block *src)\n{\n\tdst->words64[0] ^= src->words64[0];\n\tdst->words64[1] ^= src->words64[1];\n}\n\nstatic __always_inline void crypto_aegis_block_and(union aegis_block *dst,\n\t\t\t\t\t\t   const union aegis_block *src)\n{\n\tdst->words64[0] &= src->words64[0];\n\tdst->words64[1] &= src->words64[1];\n}\n\nstatic __always_inline void crypto_aegis_aesenc(union aegis_block *dst,\n\t\t\t\t\t\tconst union aegis_block *src,\n\t\t\t\t\t\tconst union aegis_block *key)\n{\n\tconst u8  *s  = src->bytes;\n\tconst u32 *t = crypto_ft_tab[0];\n\tu32 d0, d1, d2, d3;\n\n\td0 = t[s[ 0]] ^ rol32(t[s[ 5]], 8) ^ rol32(t[s[10]], 16) ^ rol32(t[s[15]], 24);\n\td1 = t[s[ 4]] ^ rol32(t[s[ 9]], 8) ^ rol32(t[s[14]], 16) ^ rol32(t[s[ 3]], 24);\n\td2 = t[s[ 8]] ^ rol32(t[s[13]], 8) ^ rol32(t[s[ 2]], 16) ^ rol32(t[s[ 7]], 24);\n\td3 = t[s[12]] ^ rol32(t[s[ 1]], 8) ^ rol32(t[s[ 6]], 16) ^ rol32(t[s[11]], 24);\n\n\tdst->words32[0] = cpu_to_le32(d0) ^ key->words32[0];\n\tdst->words32[1] = cpu_to_le32(d1) ^ key->words32[1];\n\tdst->words32[2] = cpu_to_le32(d2) ^ key->words32[2];\n\tdst->words32[3] = cpu_to_le32(d3) ^ key->words32[3];\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}