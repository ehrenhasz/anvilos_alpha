{
  "module_name": "ecdh.c",
  "hash_id": "904ada18b92c083dc694b6a03f0ea48d00df3eee30ccb24f71830c35a1dd2259",
  "original_prompt": "Ingested from linux-6.6.14/crypto/ecdh.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <crypto/internal/ecc.h>\n#include <crypto/internal/kpp.h>\n#include <crypto/kpp.h>\n#include <crypto/ecdh.h>\n#include <linux/scatterlist.h>\n\nstruct ecdh_ctx {\n\tunsigned int curve_id;\n\tunsigned int ndigits;\n\tu64 private_key[ECC_MAX_DIGITS];\n};\n\nstatic inline struct ecdh_ctx *ecdh_get_ctx(struct crypto_kpp *tfm)\n{\n\treturn kpp_tfm_ctx(tfm);\n}\n\nstatic int ecdh_set_secret(struct crypto_kpp *tfm, const void *buf,\n\t\t\t   unsigned int len)\n{\n\tstruct ecdh_ctx *ctx = ecdh_get_ctx(tfm);\n\tstruct ecdh params;\n\n\tif (crypto_ecdh_decode_key(buf, len, &params) < 0 ||\n\t    params.key_size > sizeof(u64) * ctx->ndigits)\n\t\treturn -EINVAL;\n\n\tif (!params.key || !params.key_size)\n\t\treturn ecc_gen_privkey(ctx->curve_id, ctx->ndigits,\n\t\t\t\t       ctx->private_key);\n\n\tmemcpy(ctx->private_key, params.key, params.key_size);\n\n\tif (ecc_is_key_valid(ctx->curve_id, ctx->ndigits,\n\t\t\t     ctx->private_key, params.key_size) < 0) {\n\t\tmemzero_explicit(ctx->private_key, params.key_size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ecdh_compute_value(struct kpp_request *req)\n{\n\tstruct crypto_kpp *tfm = crypto_kpp_reqtfm(req);\n\tstruct ecdh_ctx *ctx = ecdh_get_ctx(tfm);\n\tu64 *public_key;\n\tu64 *shared_secret = NULL;\n\tvoid *buf;\n\tsize_t copied, nbytes, public_key_sz;\n\tint ret = -ENOMEM;\n\n\tnbytes = ctx->ndigits << ECC_DIGITS_TO_BYTES_SHIFT;\n\t \n\tpublic_key_sz = 2 * nbytes;\n\n\tpublic_key = kmalloc(public_key_sz, GFP_KERNEL);\n\tif (!public_key)\n\t\treturn -ENOMEM;\n\n\tif (req->src) {\n\t\tshared_secret = kmalloc(nbytes, GFP_KERNEL);\n\t\tif (!shared_secret)\n\t\t\tgoto free_pubkey;\n\n\t\t \n\t\tret = -EINVAL;\n\n\t\t \n\t\tif (public_key_sz != req->src_len)\n\t\t\tgoto free_all;\n\n\t\tcopied = sg_copy_to_buffer(req->src,\n\t\t\t\t\t   sg_nents_for_len(req->src,\n\t\t\t\t\t\t\t    public_key_sz),\n\t\t\t\t\t   public_key, public_key_sz);\n\t\tif (copied != public_key_sz)\n\t\t\tgoto free_all;\n\n\t\tret = crypto_ecdh_shared_secret(ctx->curve_id, ctx->ndigits,\n\t\t\t\t\t\tctx->private_key, public_key,\n\t\t\t\t\t\tshared_secret);\n\n\t\tbuf = shared_secret;\n\t} else {\n\t\tret = ecc_make_pub_key(ctx->curve_id, ctx->ndigits,\n\t\t\t\t       ctx->private_key, public_key);\n\t\tbuf = public_key;\n\t\tnbytes = public_key_sz;\n\t}\n\n\tif (ret < 0)\n\t\tgoto free_all;\n\n\t \n\tnbytes = min_t(size_t, nbytes, req->dst_len);\n\tcopied = sg_copy_from_buffer(req->dst, sg_nents_for_len(req->dst,\n\t\t\t\t\t\t\t\tnbytes),\n\t\t\t\t     buf, nbytes);\n\tif (copied != nbytes)\n\t\tret = -EINVAL;\n\n\t \nfree_all:\n\tkfree_sensitive(shared_secret);\nfree_pubkey:\n\tkfree(public_key);\n\treturn ret;\n}\n\nstatic unsigned int ecdh_max_size(struct crypto_kpp *tfm)\n{\n\tstruct ecdh_ctx *ctx = ecdh_get_ctx(tfm);\n\n\t \n\treturn ctx->ndigits << (ECC_DIGITS_TO_BYTES_SHIFT + 1);\n}\n\nstatic int ecdh_nist_p192_init_tfm(struct crypto_kpp *tfm)\n{\n\tstruct ecdh_ctx *ctx = ecdh_get_ctx(tfm);\n\n\tctx->curve_id = ECC_CURVE_NIST_P192;\n\tctx->ndigits = ECC_CURVE_NIST_P192_DIGITS;\n\n\treturn 0;\n}\n\nstatic struct kpp_alg ecdh_nist_p192 = {\n\t.set_secret = ecdh_set_secret,\n\t.generate_public_key = ecdh_compute_value,\n\t.compute_shared_secret = ecdh_compute_value,\n\t.max_size = ecdh_max_size,\n\t.init = ecdh_nist_p192_init_tfm,\n\t.base = {\n\t\t.cra_name = \"ecdh-nist-p192\",\n\t\t.cra_driver_name = \"ecdh-nist-p192-generic\",\n\t\t.cra_priority = 100,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct ecdh_ctx),\n\t},\n};\n\nstatic int ecdh_nist_p256_init_tfm(struct crypto_kpp *tfm)\n{\n\tstruct ecdh_ctx *ctx = ecdh_get_ctx(tfm);\n\n\tctx->curve_id = ECC_CURVE_NIST_P256;\n\tctx->ndigits = ECC_CURVE_NIST_P256_DIGITS;\n\n\treturn 0;\n}\n\nstatic struct kpp_alg ecdh_nist_p256 = {\n\t.set_secret = ecdh_set_secret,\n\t.generate_public_key = ecdh_compute_value,\n\t.compute_shared_secret = ecdh_compute_value,\n\t.max_size = ecdh_max_size,\n\t.init = ecdh_nist_p256_init_tfm,\n\t.base = {\n\t\t.cra_name = \"ecdh-nist-p256\",\n\t\t.cra_driver_name = \"ecdh-nist-p256-generic\",\n\t\t.cra_priority = 100,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct ecdh_ctx),\n\t},\n};\n\nstatic int ecdh_nist_p384_init_tfm(struct crypto_kpp *tfm)\n{\n\tstruct ecdh_ctx *ctx = ecdh_get_ctx(tfm);\n\n\tctx->curve_id = ECC_CURVE_NIST_P384;\n\tctx->ndigits = ECC_CURVE_NIST_P384_DIGITS;\n\n\treturn 0;\n}\n\nstatic struct kpp_alg ecdh_nist_p384 = {\n\t.set_secret = ecdh_set_secret,\n\t.generate_public_key = ecdh_compute_value,\n\t.compute_shared_secret = ecdh_compute_value,\n\t.max_size = ecdh_max_size,\n\t.init = ecdh_nist_p384_init_tfm,\n\t.base = {\n\t\t.cra_name = \"ecdh-nist-p384\",\n\t\t.cra_driver_name = \"ecdh-nist-p384-generic\",\n\t\t.cra_priority = 100,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct ecdh_ctx),\n\t},\n};\n\nstatic bool ecdh_nist_p192_registered;\n\nstatic int __init ecdh_init(void)\n{\n\tint ret;\n\n\t \n\tret = crypto_register_kpp(&ecdh_nist_p192);\n\tecdh_nist_p192_registered = ret == 0;\n\n\tret = crypto_register_kpp(&ecdh_nist_p256);\n\tif (ret)\n\t\tgoto nist_p256_error;\n\n\tret = crypto_register_kpp(&ecdh_nist_p384);\n\tif (ret)\n\t\tgoto nist_p384_error;\n\n\treturn 0;\n\nnist_p384_error:\n\tcrypto_unregister_kpp(&ecdh_nist_p256);\n\nnist_p256_error:\n\tif (ecdh_nist_p192_registered)\n\t\tcrypto_unregister_kpp(&ecdh_nist_p192);\n\treturn ret;\n}\n\nstatic void __exit ecdh_exit(void)\n{\n\tif (ecdh_nist_p192_registered)\n\t\tcrypto_unregister_kpp(&ecdh_nist_p192);\n\tcrypto_unregister_kpp(&ecdh_nist_p256);\n\tcrypto_unregister_kpp(&ecdh_nist_p384);\n}\n\nsubsys_initcall(ecdh_init);\nmodule_exit(ecdh_exit);\nMODULE_ALIAS_CRYPTO(\"ecdh\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ECDH generic algorithm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}