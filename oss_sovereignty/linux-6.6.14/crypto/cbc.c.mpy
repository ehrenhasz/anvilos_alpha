{
  "module_name": "cbc.c",
  "hash_id": "abdd2f8683b4e79750547a77106b682ac32300dd3a1581b237bcdfaaf549b53f",
  "original_prompt": "Ingested from linux-6.6.14/crypto/cbc.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n\nstatic int crypto_cbc_encrypt_segment(struct skcipher_walk *walk,\n\t\t\t\t      struct crypto_skcipher *skcipher)\n{\n\tunsigned int bsize = crypto_skcipher_blocksize(skcipher);\n\tvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tu8 *dst = walk->dst.virt.addr;\n\tstruct crypto_cipher *cipher;\n\tstruct crypto_tfm *tfm;\n\tu8 *iv = walk->iv;\n\n\tcipher = skcipher_cipher_simple(skcipher);\n\ttfm = crypto_cipher_tfm(cipher);\n\tfn = crypto_cipher_alg(cipher)->cia_encrypt;\n\n\tdo {\n\t\tcrypto_xor(iv, src, bsize);\n\t\tfn(tfm, dst, iv);\n\t\tmemcpy(iv, dst, bsize);\n\n\t\tsrc += bsize;\n\t\tdst += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_cbc_encrypt_inplace(struct skcipher_walk *walk,\n\t\t\t\t      struct crypto_skcipher *skcipher)\n{\n\tunsigned int bsize = crypto_skcipher_blocksize(skcipher);\n\tvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tstruct crypto_cipher *cipher;\n\tstruct crypto_tfm *tfm;\n\tu8 *iv = walk->iv;\n\n\tcipher = skcipher_cipher_simple(skcipher);\n\ttfm = crypto_cipher_tfm(cipher);\n\tfn = crypto_cipher_alg(cipher)->cia_encrypt;\n\n\tdo {\n\t\tcrypto_xor(src, iv, bsize);\n\t\tfn(tfm, src, src);\n\t\tiv = src;\n\n\t\tsrc += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\tmemcpy(walk->iv, iv, bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_cbc_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct skcipher_walk walk;\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile (walk.nbytes) {\n\t\tif (walk.src.virt.addr == walk.dst.virt.addr)\n\t\t\terr = crypto_cbc_encrypt_inplace(&walk, skcipher);\n\t\telse\n\t\t\terr = crypto_cbc_encrypt_segment(&walk, skcipher);\n\t\terr = skcipher_walk_done(&walk, err);\n\t}\n\n\treturn err;\n}\n\nstatic int crypto_cbc_decrypt_segment(struct skcipher_walk *walk,\n\t\t\t\t      struct crypto_skcipher *skcipher)\n{\n\tunsigned int bsize = crypto_skcipher_blocksize(skcipher);\n\tvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tu8 *dst = walk->dst.virt.addr;\n\tstruct crypto_cipher *cipher;\n\tstruct crypto_tfm *tfm;\n\tu8 *iv = walk->iv;\n\n\tcipher = skcipher_cipher_simple(skcipher);\n\ttfm = crypto_cipher_tfm(cipher);\n\tfn = crypto_cipher_alg(cipher)->cia_decrypt;\n\n\tdo {\n\t\tfn(tfm, dst, src);\n\t\tcrypto_xor(dst, iv, bsize);\n\t\tiv = src;\n\n\t\tsrc += bsize;\n\t\tdst += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\tmemcpy(walk->iv, iv, bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_cbc_decrypt_inplace(struct skcipher_walk *walk,\n\t\t\t\t      struct crypto_skcipher *skcipher)\n{\n\tunsigned int bsize = crypto_skcipher_blocksize(skcipher);\n\tvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tu8 last_iv[MAX_CIPHER_BLOCKSIZE];\n\tstruct crypto_cipher *cipher;\n\tstruct crypto_tfm *tfm;\n\n\tcipher = skcipher_cipher_simple(skcipher);\n\ttfm = crypto_cipher_tfm(cipher);\n\tfn = crypto_cipher_alg(cipher)->cia_decrypt;\n\n\t \n\tsrc += nbytes - (nbytes & (bsize - 1)) - bsize;\n\tmemcpy(last_iv, src, bsize);\n\n\tfor (;;) {\n\t\tfn(tfm, src, src);\n\t\tif ((nbytes -= bsize) < bsize)\n\t\t\tbreak;\n\t\tcrypto_xor(src, src - bsize, bsize);\n\t\tsrc -= bsize;\n\t}\n\n\tcrypto_xor(src, walk->iv, bsize);\n\tmemcpy(walk->iv, last_iv, bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_cbc_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct skcipher_walk walk;\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile (walk.nbytes) {\n\t\tif (walk.src.virt.addr == walk.dst.virt.addr)\n\t\t\terr = crypto_cbc_decrypt_inplace(&walk, skcipher);\n\t\telse\n\t\t\terr = crypto_cbc_decrypt_segment(&walk, skcipher);\n\t\terr = skcipher_walk_done(&walk, err);\n\t}\n\n\treturn err;\n}\n\nstatic int crypto_cbc_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct skcipher_instance *inst;\n\tstruct crypto_alg *alg;\n\tint err;\n\n\tinst = skcipher_alloc_instance_simple(tmpl, tb);\n\tif (IS_ERR(inst))\n\t\treturn PTR_ERR(inst);\n\n\talg = skcipher_ialg_simple(inst);\n\n\terr = -EINVAL;\n\tif (!is_power_of_2(alg->cra_blocksize))\n\t\tgoto out_free_inst;\n\n\tinst->alg.encrypt = crypto_cbc_encrypt;\n\tinst->alg.decrypt = crypto_cbc_decrypt;\n\n\terr = skcipher_register_instance(tmpl, inst);\n\tif (err) {\nout_free_inst:\n\t\tinst->free(inst);\n\t}\n\n\treturn err;\n}\n\nstatic struct crypto_template crypto_cbc_tmpl = {\n\t.name = \"cbc\",\n\t.create = crypto_cbc_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_cbc_module_init(void)\n{\n\treturn crypto_register_template(&crypto_cbc_tmpl);\n}\n\nstatic void __exit crypto_cbc_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_cbc_tmpl);\n}\n\nsubsys_initcall(crypto_cbc_module_init);\nmodule_exit(crypto_cbc_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"CBC block cipher mode of operation\");\nMODULE_ALIAS_CRYPTO(\"cbc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}