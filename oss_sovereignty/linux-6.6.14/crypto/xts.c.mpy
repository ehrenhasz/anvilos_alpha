{
  "module_name": "xts.c",
  "hash_id": "71c378e750afc77bf2ead5dcd5eff0ae5e8cf75c19ef6dd03bad8787febec4ab",
  "original_prompt": "Ingested from linux-6.6.14/crypto/xts.c",
  "human_readable_source": "\n \n#include <crypto/internal/cipher.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n\n#include <crypto/xts.h>\n#include <crypto/b128ops.h>\n#include <crypto/gf128mul.h>\n\nstruct xts_tfm_ctx {\n\tstruct crypto_skcipher *child;\n\tstruct crypto_cipher *tweak;\n};\n\nstruct xts_instance_ctx {\n\tstruct crypto_skcipher_spawn spawn;\n\tstruct crypto_cipher_spawn tweak_spawn;\n};\n\nstruct xts_request_ctx {\n\tle128 t;\n\tstruct scatterlist *tail;\n\tstruct scatterlist sg[2];\n\tstruct skcipher_request subreq;\n};\n\nstatic int xts_setkey(struct crypto_skcipher *parent, const u8 *key,\n\t\t      unsigned int keylen)\n{\n\tstruct xts_tfm_ctx *ctx = crypto_skcipher_ctx(parent);\n\tstruct crypto_skcipher *child;\n\tstruct crypto_cipher *tweak;\n\tint err;\n\n\terr = xts_verify_key(parent, key, keylen);\n\tif (err)\n\t\treturn err;\n\n\tkeylen /= 2;\n\n\t \n\n\t \n\ttweak = ctx->tweak;\n\tcrypto_cipher_clear_flags(tweak, CRYPTO_TFM_REQ_MASK);\n\tcrypto_cipher_set_flags(tweak, crypto_skcipher_get_flags(parent) &\n\t\t\t\t       CRYPTO_TFM_REQ_MASK);\n\terr = crypto_cipher_setkey(tweak, key + keylen, keylen);\n\tif (err)\n\t\treturn err;\n\n\t \n\tchild = ctx->child;\n\tcrypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(child, crypto_skcipher_get_flags(parent) &\n\t\t\t\t\t CRYPTO_TFM_REQ_MASK);\n\treturn crypto_skcipher_setkey(child, key, keylen);\n}\n\n \nstatic int xts_xor_tweak(struct skcipher_request *req, bool second_pass,\n\t\t\t bool enc)\n{\n\tstruct xts_request_ctx *rctx = skcipher_request_ctx(req);\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tconst bool cts = (req->cryptlen % XTS_BLOCK_SIZE);\n\tconst int bs = XTS_BLOCK_SIZE;\n\tstruct skcipher_walk w;\n\tle128 t = rctx->t;\n\tint err;\n\n\tif (second_pass) {\n\t\treq = &rctx->subreq;\n\t\t \n\t\tskcipher_request_set_tfm(req, tfm);\n\t}\n\terr = skcipher_walk_virt(&w, req, false);\n\n\twhile (w.nbytes) {\n\t\tunsigned int avail = w.nbytes;\n\t\tle128 *wsrc;\n\t\tle128 *wdst;\n\n\t\twsrc = w.src.virt.addr;\n\t\twdst = w.dst.virt.addr;\n\n\t\tdo {\n\t\t\tif (unlikely(cts) &&\n\t\t\t    w.total - w.nbytes + avail < 2 * XTS_BLOCK_SIZE) {\n\t\t\t\tif (!enc) {\n\t\t\t\t\tif (second_pass)\n\t\t\t\t\t\trctx->t = t;\n\t\t\t\t\tgf128mul_x_ble(&t, &t);\n\t\t\t\t}\n\t\t\t\tle128_xor(wdst, &t, wsrc);\n\t\t\t\tif (enc && second_pass)\n\t\t\t\t\tgf128mul_x_ble(&rctx->t, &t);\n\t\t\t\tskcipher_walk_done(&w, avail - bs);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tle128_xor(wdst++, &t, wsrc++);\n\t\t\tgf128mul_x_ble(&t, &t);\n\t\t} while ((avail -= bs) >= bs);\n\n\t\terr = skcipher_walk_done(&w, avail);\n\t}\n\n\treturn err;\n}\n\nstatic int xts_xor_tweak_pre(struct skcipher_request *req, bool enc)\n{\n\treturn xts_xor_tweak(req, false, enc);\n}\n\nstatic int xts_xor_tweak_post(struct skcipher_request *req, bool enc)\n{\n\treturn xts_xor_tweak(req, true, enc);\n}\n\nstatic void xts_cts_done(void *data, int err)\n{\n\tstruct skcipher_request *req = data;\n\tle128 b;\n\n\tif (!err) {\n\t\tstruct xts_request_ctx *rctx = skcipher_request_ctx(req);\n\n\t\tscatterwalk_map_and_copy(&b, rctx->tail, 0, XTS_BLOCK_SIZE, 0);\n\t\tle128_xor(&b, &rctx->t, &b);\n\t\tscatterwalk_map_and_copy(&b, rctx->tail, 0, XTS_BLOCK_SIZE, 1);\n\t}\n\n\tskcipher_request_complete(req, err);\n}\n\nstatic int xts_cts_final(struct skcipher_request *req,\n\t\t\t int (*crypt)(struct skcipher_request *req))\n{\n\tconst struct xts_tfm_ctx *ctx =\n\t\tcrypto_skcipher_ctx(crypto_skcipher_reqtfm(req));\n\tint offset = req->cryptlen & ~(XTS_BLOCK_SIZE - 1);\n\tstruct xts_request_ctx *rctx = skcipher_request_ctx(req);\n\tstruct skcipher_request *subreq = &rctx->subreq;\n\tint tail = req->cryptlen % XTS_BLOCK_SIZE;\n\tle128 b[2];\n\tint err;\n\n\trctx->tail = scatterwalk_ffwd(rctx->sg, req->dst,\n\t\t\t\t      offset - XTS_BLOCK_SIZE);\n\n\tscatterwalk_map_and_copy(b, rctx->tail, 0, XTS_BLOCK_SIZE, 0);\n\tb[1] = b[0];\n\tscatterwalk_map_and_copy(b, req->src, offset, tail, 0);\n\n\tle128_xor(b, &rctx->t, b);\n\n\tscatterwalk_map_and_copy(b, rctx->tail, 0, XTS_BLOCK_SIZE + tail, 1);\n\n\tskcipher_request_set_tfm(subreq, ctx->child);\n\tskcipher_request_set_callback(subreq, req->base.flags, xts_cts_done,\n\t\t\t\t      req);\n\tskcipher_request_set_crypt(subreq, rctx->tail, rctx->tail,\n\t\t\t\t   XTS_BLOCK_SIZE, NULL);\n\n\terr = crypt(subreq);\n\tif (err)\n\t\treturn err;\n\n\tscatterwalk_map_and_copy(b, rctx->tail, 0, XTS_BLOCK_SIZE, 0);\n\tle128_xor(b, &rctx->t, b);\n\tscatterwalk_map_and_copy(b, rctx->tail, 0, XTS_BLOCK_SIZE, 1);\n\n\treturn 0;\n}\n\nstatic void xts_encrypt_done(void *data, int err)\n{\n\tstruct skcipher_request *req = data;\n\n\tif (!err) {\n\t\tstruct xts_request_ctx *rctx = skcipher_request_ctx(req);\n\n\t\trctx->subreq.base.flags &= CRYPTO_TFM_REQ_MAY_BACKLOG;\n\t\terr = xts_xor_tweak_post(req, true);\n\n\t\tif (!err && unlikely(req->cryptlen % XTS_BLOCK_SIZE)) {\n\t\t\terr = xts_cts_final(req, crypto_skcipher_encrypt);\n\t\t\tif (err == -EINPROGRESS || err == -EBUSY)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tskcipher_request_complete(req, err);\n}\n\nstatic void xts_decrypt_done(void *data, int err)\n{\n\tstruct skcipher_request *req = data;\n\n\tif (!err) {\n\t\tstruct xts_request_ctx *rctx = skcipher_request_ctx(req);\n\n\t\trctx->subreq.base.flags &= CRYPTO_TFM_REQ_MAY_BACKLOG;\n\t\terr = xts_xor_tweak_post(req, false);\n\n\t\tif (!err && unlikely(req->cryptlen % XTS_BLOCK_SIZE)) {\n\t\t\terr = xts_cts_final(req, crypto_skcipher_decrypt);\n\t\t\tif (err == -EINPROGRESS || err == -EBUSY)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tskcipher_request_complete(req, err);\n}\n\nstatic int xts_init_crypt(struct skcipher_request *req,\n\t\t\t  crypto_completion_t compl)\n{\n\tconst struct xts_tfm_ctx *ctx =\n\t\tcrypto_skcipher_ctx(crypto_skcipher_reqtfm(req));\n\tstruct xts_request_ctx *rctx = skcipher_request_ctx(req);\n\tstruct skcipher_request *subreq = &rctx->subreq;\n\n\tif (req->cryptlen < XTS_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tskcipher_request_set_tfm(subreq, ctx->child);\n\tskcipher_request_set_callback(subreq, req->base.flags, compl, req);\n\tskcipher_request_set_crypt(subreq, req->dst, req->dst,\n\t\t\t\t   req->cryptlen & ~(XTS_BLOCK_SIZE - 1), NULL);\n\n\t \n\tcrypto_cipher_encrypt_one(ctx->tweak, (u8 *)&rctx->t, req->iv);\n\n\treturn 0;\n}\n\nstatic int xts_encrypt(struct skcipher_request *req)\n{\n\tstruct xts_request_ctx *rctx = skcipher_request_ctx(req);\n\tstruct skcipher_request *subreq = &rctx->subreq;\n\tint err;\n\n\terr = xts_init_crypt(req, xts_encrypt_done) ?:\n\t      xts_xor_tweak_pre(req, true) ?:\n\t      crypto_skcipher_encrypt(subreq) ?:\n\t      xts_xor_tweak_post(req, true);\n\n\tif (err || likely((req->cryptlen % XTS_BLOCK_SIZE) == 0))\n\t\treturn err;\n\n\treturn xts_cts_final(req, crypto_skcipher_encrypt);\n}\n\nstatic int xts_decrypt(struct skcipher_request *req)\n{\n\tstruct xts_request_ctx *rctx = skcipher_request_ctx(req);\n\tstruct skcipher_request *subreq = &rctx->subreq;\n\tint err;\n\n\terr = xts_init_crypt(req, xts_decrypt_done) ?:\n\t      xts_xor_tweak_pre(req, false) ?:\n\t      crypto_skcipher_decrypt(subreq) ?:\n\t      xts_xor_tweak_post(req, false);\n\n\tif (err || likely((req->cryptlen % XTS_BLOCK_SIZE) == 0))\n\t\treturn err;\n\n\treturn xts_cts_final(req, crypto_skcipher_decrypt);\n}\n\nstatic int xts_init_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct skcipher_instance *inst = skcipher_alg_instance(tfm);\n\tstruct xts_instance_ctx *ictx = skcipher_instance_ctx(inst);\n\tstruct xts_tfm_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct crypto_skcipher *child;\n\tstruct crypto_cipher *tweak;\n\n\tchild = crypto_spawn_skcipher(&ictx->spawn);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\n\tctx->child = child;\n\n\ttweak = crypto_spawn_cipher(&ictx->tweak_spawn);\n\tif (IS_ERR(tweak)) {\n\t\tcrypto_free_skcipher(ctx->child);\n\t\treturn PTR_ERR(tweak);\n\t}\n\n\tctx->tweak = tweak;\n\n\tcrypto_skcipher_set_reqsize(tfm, crypto_skcipher_reqsize(child) +\n\t\t\t\t\t sizeof(struct xts_request_ctx));\n\n\treturn 0;\n}\n\nstatic void xts_exit_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct xts_tfm_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tcrypto_free_skcipher(ctx->child);\n\tcrypto_free_cipher(ctx->tweak);\n}\n\nstatic void xts_free_instance(struct skcipher_instance *inst)\n{\n\tstruct xts_instance_ctx *ictx = skcipher_instance_ctx(inst);\n\n\tcrypto_drop_skcipher(&ictx->spawn);\n\tcrypto_drop_cipher(&ictx->tweak_spawn);\n\tkfree(inst);\n}\n\nstatic int xts_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tchar name[CRYPTO_MAX_ALG_NAME];\n\tstruct skcipher_instance *inst;\n\tstruct xts_instance_ctx *ctx;\n\tstruct skcipher_alg *alg;\n\tconst char *cipher_name;\n\tu32 mask;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SKCIPHER, &mask);\n\tif (err)\n\t\treturn err;\n\n\tcipher_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(cipher_name))\n\t\treturn PTR_ERR(cipher_name);\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tctx = skcipher_instance_ctx(inst);\n\n\terr = crypto_grab_skcipher(&ctx->spawn, skcipher_crypto_instance(inst),\n\t\t\t\t   cipher_name, 0, mask);\n\tif (err == -ENOENT) {\n\t\terr = -ENAMETOOLONG;\n\t\tif (snprintf(name, CRYPTO_MAX_ALG_NAME, \"ecb(%s)\",\n\t\t\t     cipher_name) >= CRYPTO_MAX_ALG_NAME)\n\t\t\tgoto err_free_inst;\n\n\t\terr = crypto_grab_skcipher(&ctx->spawn,\n\t\t\t\t\t   skcipher_crypto_instance(inst),\n\t\t\t\t\t   name, 0, mask);\n\t}\n\n\tif (err)\n\t\tgoto err_free_inst;\n\n\talg = crypto_skcipher_spawn_alg(&ctx->spawn);\n\n\terr = -EINVAL;\n\tif (alg->base.cra_blocksize != XTS_BLOCK_SIZE)\n\t\tgoto err_free_inst;\n\n\tif (crypto_skcipher_alg_ivsize(alg))\n\t\tgoto err_free_inst;\n\n\terr = crypto_inst_setname(skcipher_crypto_instance(inst), \"xts\",\n\t\t\t\t  &alg->base);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\terr = -EINVAL;\n\tcipher_name = alg->base.cra_name;\n\n\t \n\tif (!strncmp(cipher_name, \"ecb(\", 4)) {\n\t\tint len;\n\n\t\tlen = strscpy(name, cipher_name + 4, sizeof(name));\n\t\tif (len < 2)\n\t\t\tgoto err_free_inst;\n\n\t\tif (name[len - 1] != ')')\n\t\t\tgoto err_free_inst;\n\n\t\tname[len - 1] = 0;\n\n\t\tif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t\t     \"xts(%s)\", name) >= CRYPTO_MAX_ALG_NAME) {\n\t\t\terr = -ENAMETOOLONG;\n\t\t\tgoto err_free_inst;\n\t\t}\n\t} else\n\t\tgoto err_free_inst;\n\n\terr = crypto_grab_cipher(&ctx->tweak_spawn,\n\t\t\t\t skcipher_crypto_instance(inst), name, 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\tinst->alg.base.cra_priority = alg->base.cra_priority;\n\tinst->alg.base.cra_blocksize = XTS_BLOCK_SIZE;\n\tinst->alg.base.cra_alignmask = alg->base.cra_alignmask |\n\t\t\t\t       (__alignof__(u64) - 1);\n\n\tinst->alg.ivsize = XTS_BLOCK_SIZE;\n\tinst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg) * 2;\n\tinst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg) * 2;\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct xts_tfm_ctx);\n\n\tinst->alg.init = xts_init_tfm;\n\tinst->alg.exit = xts_exit_tfm;\n\n\tinst->alg.setkey = xts_setkey;\n\tinst->alg.encrypt = xts_encrypt;\n\tinst->alg.decrypt = xts_decrypt;\n\n\tinst->free = xts_free_instance;\n\n\terr = skcipher_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\txts_free_instance(inst);\n\t}\n\treturn err;\n}\n\nstatic struct crypto_template xts_tmpl = {\n\t.name = \"xts\",\n\t.create = xts_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init xts_module_init(void)\n{\n\treturn crypto_register_template(&xts_tmpl);\n}\n\nstatic void __exit xts_module_exit(void)\n{\n\tcrypto_unregister_template(&xts_tmpl);\n}\n\nsubsys_initcall(xts_module_init);\nmodule_exit(xts_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"XTS block cipher mode\");\nMODULE_ALIAS_CRYPTO(\"xts\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\nMODULE_SOFTDEP(\"pre: ecb\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}