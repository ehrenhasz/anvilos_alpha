{
  "module_name": "hctr2.c",
  "hash_id": "fd8e5085bf23a298690d78622675da3137e7eeddb222ab432acd45f5925f839d",
  "original_prompt": "Ingested from linux-6.6.14/crypto/hctr2.c",
  "human_readable_source": "\n \n\n\n \n\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/polyval.h>\n#include <crypto/scatterwalk.h>\n#include <linux/module.h>\n\n#define BLOCKCIPHER_BLOCK_SIZE\t\t16\n\n \n#define TWEAK_SIZE\t\t32\n\nstruct hctr2_instance_ctx {\n\tstruct crypto_cipher_spawn blockcipher_spawn;\n\tstruct crypto_skcipher_spawn xctr_spawn;\n\tstruct crypto_shash_spawn polyval_spawn;\n};\n\nstruct hctr2_tfm_ctx {\n\tstruct crypto_cipher *blockcipher;\n\tstruct crypto_skcipher *xctr;\n\tstruct crypto_shash *polyval;\n\tu8 L[BLOCKCIPHER_BLOCK_SIZE];\n\tint hashed_tweak_offset;\n\t \n};\n\nstruct hctr2_request_ctx {\n\tu8 first_block[BLOCKCIPHER_BLOCK_SIZE];\n\tu8 xctr_iv[BLOCKCIPHER_BLOCK_SIZE];\n\tstruct scatterlist *bulk_part_dst;\n\tstruct scatterlist *bulk_part_src;\n\tstruct scatterlist sg_src[2];\n\tstruct scatterlist sg_dst[2];\n\t \n\tunion {\n\t\tstruct shash_desc hash_desc;\n\t\tstruct skcipher_request xctr_req;\n\t} u;\n\t \n};\n\nstatic inline u8 *hctr2_hashed_tweaklen(const struct hctr2_tfm_ctx *tctx,\n\t\t\t\t\tbool has_remainder)\n{\n\tu8 *p = (u8 *)tctx + sizeof(*tctx);\n\n\tif (has_remainder)  \n\t\tp += crypto_shash_statesize(tctx->polyval);\n\treturn p;\n}\n\nstatic inline u8 *hctr2_hashed_tweak(const struct hctr2_tfm_ctx *tctx,\n\t\t\t\t     struct hctr2_request_ctx *rctx)\n{\n\treturn (u8 *)rctx + tctx->hashed_tweak_offset;\n}\n\n \nstatic int hctr2_hash_tweaklen(struct hctr2_tfm_ctx *tctx, bool has_remainder)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm->polyval);\n\t__le64 tweak_length_block[2];\n\tint err;\n\n\tshash->tfm = tctx->polyval;\n\tmemset(tweak_length_block, 0, sizeof(tweak_length_block));\n\n\ttweak_length_block[0] = cpu_to_le64(TWEAK_SIZE * 8 * 2 + 2 + has_remainder);\n\terr = crypto_shash_init(shash);\n\tif (err)\n\t\treturn err;\n\terr = crypto_shash_update(shash, (u8 *)tweak_length_block,\n\t\t\t\t  POLYVAL_BLOCK_SIZE);\n\tif (err)\n\t\treturn err;\n\treturn crypto_shash_export(shash, hctr2_hashed_tweaklen(tctx, has_remainder));\n}\n\nstatic int hctr2_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\tunsigned int keylen)\n{\n\tstruct hctr2_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);\n\tu8 hbar[BLOCKCIPHER_BLOCK_SIZE];\n\tint err;\n\n\tcrypto_cipher_clear_flags(tctx->blockcipher, CRYPTO_TFM_REQ_MASK);\n\tcrypto_cipher_set_flags(tctx->blockcipher,\n\t\t\t\tcrypto_skcipher_get_flags(tfm) &\n\t\t\t\tCRYPTO_TFM_REQ_MASK);\n\terr = crypto_cipher_setkey(tctx->blockcipher, key, keylen);\n\tif (err)\n\t\treturn err;\n\n\tcrypto_skcipher_clear_flags(tctx->xctr, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(tctx->xctr,\n\t\t\t\t  crypto_skcipher_get_flags(tfm) &\n\t\t\t\t  CRYPTO_TFM_REQ_MASK);\n\terr = crypto_skcipher_setkey(tctx->xctr, key, keylen);\n\tif (err)\n\t\treturn err;\n\n\tmemset(hbar, 0, sizeof(hbar));\n\tcrypto_cipher_encrypt_one(tctx->blockcipher, hbar, hbar);\n\n\tmemset(tctx->L, 0, sizeof(tctx->L));\n\ttctx->L[0] = 0x01;\n\tcrypto_cipher_encrypt_one(tctx->blockcipher, tctx->L, tctx->L);\n\n\tcrypto_shash_clear_flags(tctx->polyval, CRYPTO_TFM_REQ_MASK);\n\tcrypto_shash_set_flags(tctx->polyval, crypto_skcipher_get_flags(tfm) &\n\t\t\t       CRYPTO_TFM_REQ_MASK);\n\terr = crypto_shash_setkey(tctx->polyval, hbar, BLOCKCIPHER_BLOCK_SIZE);\n\tif (err)\n\t\treturn err;\n\tmemzero_explicit(hbar, sizeof(hbar));\n\n\treturn hctr2_hash_tweaklen(tctx, true) ?: hctr2_hash_tweaklen(tctx, false);\n}\n\nstatic int hctr2_hash_tweak(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tconst struct hctr2_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);\n\tstruct hctr2_request_ctx *rctx = skcipher_request_ctx(req);\n\tstruct shash_desc *hash_desc = &rctx->u.hash_desc;\n\tint err;\n\tbool has_remainder = req->cryptlen % POLYVAL_BLOCK_SIZE;\n\n\thash_desc->tfm = tctx->polyval;\n\terr = crypto_shash_import(hash_desc, hctr2_hashed_tweaklen(tctx, has_remainder));\n\tif (err)\n\t\treturn err;\n\terr = crypto_shash_update(hash_desc, req->iv, TWEAK_SIZE);\n\tif (err)\n\t\treturn err;\n\n\t \n\t \n\treturn crypto_shash_export(hash_desc, hctr2_hashed_tweak(tctx, rctx));\n}\n\nstatic int hctr2_hash_message(struct skcipher_request *req,\n\t\t\t      struct scatterlist *sgl,\n\t\t\t      u8 digest[POLYVAL_DIGEST_SIZE])\n{\n\tstatic const u8 padding[BLOCKCIPHER_BLOCK_SIZE] = { 0x1 };\n\tstruct hctr2_request_ctx *rctx = skcipher_request_ctx(req);\n\tstruct shash_desc *hash_desc = &rctx->u.hash_desc;\n\tconst unsigned int bulk_len = req->cryptlen - BLOCKCIPHER_BLOCK_SIZE;\n\tstruct sg_mapping_iter miter;\n\tunsigned int remainder = bulk_len % BLOCKCIPHER_BLOCK_SIZE;\n\tint i;\n\tint err = 0;\n\tint n = 0;\n\n\tsg_miter_start(&miter, sgl, sg_nents(sgl),\n\t\t       SG_MITER_FROM_SG | SG_MITER_ATOMIC);\n\tfor (i = 0; i < bulk_len; i += n) {\n\t\tsg_miter_next(&miter);\n\t\tn = min_t(unsigned int, miter.length, bulk_len - i);\n\t\terr = crypto_shash_update(hash_desc, miter.addr, n);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tsg_miter_stop(&miter);\n\n\tif (err)\n\t\treturn err;\n\n\tif (remainder) {\n\t\terr = crypto_shash_update(hash_desc, padding,\n\t\t\t\t\t  BLOCKCIPHER_BLOCK_SIZE - remainder);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn crypto_shash_final(hash_desc, digest);\n}\n\nstatic int hctr2_finish(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tconst struct hctr2_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);\n\tstruct hctr2_request_ctx *rctx = skcipher_request_ctx(req);\n\tu8 digest[POLYVAL_DIGEST_SIZE];\n\tstruct shash_desc *hash_desc = &rctx->u.hash_desc;\n\tint err;\n\n\t \n\t \n\thash_desc->tfm = tctx->polyval;\n\terr = crypto_shash_import(hash_desc, hctr2_hashed_tweak(tctx, rctx));\n\tif (err)\n\t\treturn err;\n\terr = hctr2_hash_message(req, rctx->bulk_part_dst, digest);\n\tif (err)\n\t\treturn err;\n\tcrypto_xor(rctx->first_block, digest, BLOCKCIPHER_BLOCK_SIZE);\n\n\t \n\tscatterwalk_map_and_copy(rctx->first_block, req->dst,\n\t\t\t\t 0, BLOCKCIPHER_BLOCK_SIZE, 1);\n\treturn 0;\n}\n\nstatic void hctr2_xctr_done(void *data, int err)\n{\n\tstruct skcipher_request *req = data;\n\n\tif (!err)\n\t\terr = hctr2_finish(req);\n\n\tskcipher_request_complete(req, err);\n}\n\nstatic int hctr2_crypt(struct skcipher_request *req, bool enc)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tconst struct hctr2_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);\n\tstruct hctr2_request_ctx *rctx = skcipher_request_ctx(req);\n\tu8 digest[POLYVAL_DIGEST_SIZE];\n\tint bulk_len = req->cryptlen - BLOCKCIPHER_BLOCK_SIZE;\n\tint err;\n\n\t \n\tif (req->cryptlen < BLOCKCIPHER_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tscatterwalk_map_and_copy(rctx->first_block, req->src,\n\t\t\t\t 0, BLOCKCIPHER_BLOCK_SIZE, 0);\n\n\t \n\trctx->bulk_part_src = scatterwalk_ffwd(rctx->sg_src, req->src,\n\t\t\t\t\t       BLOCKCIPHER_BLOCK_SIZE);\n\trctx->bulk_part_dst = scatterwalk_ffwd(rctx->sg_dst, req->dst,\n\t\t\t\t\t       BLOCKCIPHER_BLOCK_SIZE);\n\n\t \n\t \n\terr = hctr2_hash_tweak(req);\n\tif (err)\n\t\treturn err;\n\terr = hctr2_hash_message(req, rctx->bulk_part_src, digest);\n\tif (err)\n\t\treturn err;\n\tcrypto_xor(digest, rctx->first_block, BLOCKCIPHER_BLOCK_SIZE);\n\n\t \n\t \n\tif (enc)\n\t\tcrypto_cipher_encrypt_one(tctx->blockcipher, rctx->first_block,\n\t\t\t\t\t  digest);\n\telse\n\t\tcrypto_cipher_decrypt_one(tctx->blockcipher, rctx->first_block,\n\t\t\t\t\t  digest);\n\n\t \n\tcrypto_xor(digest, rctx->first_block, BLOCKCIPHER_BLOCK_SIZE);\n\tcrypto_xor_cpy(rctx->xctr_iv, digest, tctx->L, BLOCKCIPHER_BLOCK_SIZE);\n\n\t \n\t \n\tskcipher_request_set_tfm(&rctx->u.xctr_req, tctx->xctr);\n\tskcipher_request_set_crypt(&rctx->u.xctr_req, rctx->bulk_part_src,\n\t\t\t\t   rctx->bulk_part_dst, bulk_len,\n\t\t\t\t   rctx->xctr_iv);\n\tskcipher_request_set_callback(&rctx->u.xctr_req,\n\t\t\t\t      req->base.flags,\n\t\t\t\t      hctr2_xctr_done, req);\n\treturn crypto_skcipher_encrypt(&rctx->u.xctr_req) ?:\n\t\thctr2_finish(req);\n}\n\nstatic int hctr2_encrypt(struct skcipher_request *req)\n{\n\treturn hctr2_crypt(req, true);\n}\n\nstatic int hctr2_decrypt(struct skcipher_request *req)\n{\n\treturn hctr2_crypt(req, false);\n}\n\nstatic int hctr2_init_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct skcipher_instance *inst = skcipher_alg_instance(tfm);\n\tstruct hctr2_instance_ctx *ictx = skcipher_instance_ctx(inst);\n\tstruct hctr2_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);\n\tstruct crypto_skcipher *xctr;\n\tstruct crypto_cipher *blockcipher;\n\tstruct crypto_shash *polyval;\n\tunsigned int subreq_size;\n\tint err;\n\n\txctr = crypto_spawn_skcipher(&ictx->xctr_spawn);\n\tif (IS_ERR(xctr))\n\t\treturn PTR_ERR(xctr);\n\n\tblockcipher = crypto_spawn_cipher(&ictx->blockcipher_spawn);\n\tif (IS_ERR(blockcipher)) {\n\t\terr = PTR_ERR(blockcipher);\n\t\tgoto err_free_xctr;\n\t}\n\n\tpolyval = crypto_spawn_shash(&ictx->polyval_spawn);\n\tif (IS_ERR(polyval)) {\n\t\terr = PTR_ERR(polyval);\n\t\tgoto err_free_blockcipher;\n\t}\n\n\ttctx->xctr = xctr;\n\ttctx->blockcipher = blockcipher;\n\ttctx->polyval = polyval;\n\n\tBUILD_BUG_ON(offsetofend(struct hctr2_request_ctx, u) !=\n\t\t\t\t sizeof(struct hctr2_request_ctx));\n\tsubreq_size = max(sizeof_field(struct hctr2_request_ctx, u.hash_desc) +\n\t\t\t  crypto_shash_descsize(polyval),\n\t\t\t  sizeof_field(struct hctr2_request_ctx, u.xctr_req) +\n\t\t\t  crypto_skcipher_reqsize(xctr));\n\n\ttctx->hashed_tweak_offset = offsetof(struct hctr2_request_ctx, u) +\n\t\t\t\t    subreq_size;\n\tcrypto_skcipher_set_reqsize(tfm, tctx->hashed_tweak_offset +\n\t\t\t\t    crypto_shash_statesize(polyval));\n\treturn 0;\n\nerr_free_blockcipher:\n\tcrypto_free_cipher(blockcipher);\nerr_free_xctr:\n\tcrypto_free_skcipher(xctr);\n\treturn err;\n}\n\nstatic void hctr2_exit_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct hctr2_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);\n\n\tcrypto_free_cipher(tctx->blockcipher);\n\tcrypto_free_skcipher(tctx->xctr);\n\tcrypto_free_shash(tctx->polyval);\n}\n\nstatic void hctr2_free_instance(struct skcipher_instance *inst)\n{\n\tstruct hctr2_instance_ctx *ictx = skcipher_instance_ctx(inst);\n\n\tcrypto_drop_cipher(&ictx->blockcipher_spawn);\n\tcrypto_drop_skcipher(&ictx->xctr_spawn);\n\tcrypto_drop_shash(&ictx->polyval_spawn);\n\tkfree(inst);\n}\n\nstatic int hctr2_create_common(struct crypto_template *tmpl,\n\t\t\t       struct rtattr **tb,\n\t\t\t       const char *xctr_name,\n\t\t\t       const char *polyval_name)\n{\n\tu32 mask;\n\tstruct skcipher_instance *inst;\n\tstruct hctr2_instance_ctx *ictx;\n\tstruct skcipher_alg *xctr_alg;\n\tstruct crypto_alg *blockcipher_alg;\n\tstruct shash_alg *polyval_alg;\n\tchar blockcipher_name[CRYPTO_MAX_ALG_NAME];\n\tint len;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SKCIPHER, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ictx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tictx = skcipher_instance_ctx(inst);\n\n\t \n\terr = crypto_grab_skcipher(&ictx->xctr_spawn,\n\t\t\t\t   skcipher_crypto_instance(inst),\n\t\t\t\t   xctr_name, 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\txctr_alg = crypto_spawn_skcipher_alg(&ictx->xctr_spawn);\n\n\terr = -EINVAL;\n\tif (strncmp(xctr_alg->base.cra_name, \"xctr(\", 5))\n\t\tgoto err_free_inst;\n\tlen = strscpy(blockcipher_name, xctr_alg->base.cra_name + 5,\n\t\t      sizeof(blockcipher_name));\n\tif (len < 1)\n\t\tgoto err_free_inst;\n\tif (blockcipher_name[len - 1] != ')')\n\t\tgoto err_free_inst;\n\tblockcipher_name[len - 1] = 0;\n\n\t \n\terr = crypto_grab_cipher(&ictx->blockcipher_spawn,\n\t\t\t\t skcipher_crypto_instance(inst),\n\t\t\t\t blockcipher_name, 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\tblockcipher_alg = crypto_spawn_cipher_alg(&ictx->blockcipher_spawn);\n\n\t \n\terr = -EINVAL;\n\tif (blockcipher_alg->cra_blocksize != BLOCKCIPHER_BLOCK_SIZE)\n\t\tgoto err_free_inst;\n\n\t \n\terr = crypto_grab_shash(&ictx->polyval_spawn,\n\t\t\t\tskcipher_crypto_instance(inst),\n\t\t\t\tpolyval_name, 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\tpolyval_alg = crypto_spawn_shash_alg(&ictx->polyval_spawn);\n\n\t \n\terr = -EINVAL;\n\tif (strcmp(polyval_alg->base.cra_name, \"polyval\") != 0)\n\t\tgoto err_free_inst;\n\n\t \n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME, \"hctr2(%s)\",\n\t\t     blockcipher_alg->cra_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_free_inst;\n\tif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"hctr2_base(%s,%s)\",\n\t\t     xctr_alg->base.cra_driver_name,\n\t\t     polyval_alg->base.cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_free_inst;\n\n\tinst->alg.base.cra_blocksize = BLOCKCIPHER_BLOCK_SIZE;\n\tinst->alg.base.cra_ctxsize = sizeof(struct hctr2_tfm_ctx) +\n\t\t\t\t     polyval_alg->statesize * 2;\n\tinst->alg.base.cra_alignmask = xctr_alg->base.cra_alignmask |\n\t\t\t\t       polyval_alg->base.cra_alignmask;\n\t \n\tinst->alg.base.cra_priority = (2 * xctr_alg->base.cra_priority +\n\t\t\t\t       4 * polyval_alg->base.cra_priority +\n\t\t\t\t       blockcipher_alg->cra_priority) / 7;\n\n\tinst->alg.setkey = hctr2_setkey;\n\tinst->alg.encrypt = hctr2_encrypt;\n\tinst->alg.decrypt = hctr2_decrypt;\n\tinst->alg.init = hctr2_init_tfm;\n\tinst->alg.exit = hctr2_exit_tfm;\n\tinst->alg.min_keysize = crypto_skcipher_alg_min_keysize(xctr_alg);\n\tinst->alg.max_keysize = crypto_skcipher_alg_max_keysize(xctr_alg);\n\tinst->alg.ivsize = TWEAK_SIZE;\n\n\tinst->free = hctr2_free_instance;\n\n\terr = skcipher_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\thctr2_free_instance(inst);\n\t}\n\treturn err;\n}\n\nstatic int hctr2_create_base(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tconst char *xctr_name;\n\tconst char *polyval_name;\n\n\txctr_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(xctr_name))\n\t\treturn PTR_ERR(xctr_name);\n\n\tpolyval_name = crypto_attr_alg_name(tb[2]);\n\tif (IS_ERR(polyval_name))\n\t\treturn PTR_ERR(polyval_name);\n\n\treturn hctr2_create_common(tmpl, tb, xctr_name, polyval_name);\n}\n\nstatic int hctr2_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tconst char *blockcipher_name;\n\tchar xctr_name[CRYPTO_MAX_ALG_NAME];\n\n\tblockcipher_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(blockcipher_name))\n\t\treturn PTR_ERR(blockcipher_name);\n\n\tif (snprintf(xctr_name, CRYPTO_MAX_ALG_NAME, \"xctr(%s)\",\n\t\t    blockcipher_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\treturn hctr2_create_common(tmpl, tb, xctr_name, \"polyval\");\n}\n\nstatic struct crypto_template hctr2_tmpls[] = {\n\t{\n\t\t \n\t\t.name = \"hctr2_base\",\n\t\t.create = hctr2_create_base,\n\t\t.module = THIS_MODULE,\n\t}, {\n\t\t \n\t\t.name = \"hctr2\",\n\t\t.create = hctr2_create,\n\t\t.module = THIS_MODULE,\n\t}\n};\n\nstatic int __init hctr2_module_init(void)\n{\n\treturn crypto_register_templates(hctr2_tmpls, ARRAY_SIZE(hctr2_tmpls));\n}\n\nstatic void __exit hctr2_module_exit(void)\n{\n\treturn crypto_unregister_templates(hctr2_tmpls,\n\t\t\t\t\t   ARRAY_SIZE(hctr2_tmpls));\n}\n\nsubsys_initcall(hctr2_module_init);\nmodule_exit(hctr2_module_exit);\n\nMODULE_DESCRIPTION(\"HCTR2 length-preserving encryption mode\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS_CRYPTO(\"hctr2\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}