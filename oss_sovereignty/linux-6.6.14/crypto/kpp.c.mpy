{
  "module_name": "kpp.c",
  "hash_id": "6a00c10dbe982ca3020d3655e34c3c7fd8e00b991d2e91e36f619bf6e9ac6307",
  "original_prompt": "Ingested from linux-6.6.14/crypto/kpp.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/kpp.h>\n#include <linux/cryptouser.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <net/netlink.h>\n\n#include \"internal.h\"\n\nstatic int __maybe_unused crypto_kpp_report(\n\tstruct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_kpp rkpp;\n\n\tmemset(&rkpp, 0, sizeof(rkpp));\n\n\tstrscpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_KPP, sizeof(rkpp), &rkpp);\n}\n\nstatic void crypto_kpp_show(struct seq_file *m, struct crypto_alg *alg)\n\t__maybe_unused;\n\nstatic void crypto_kpp_show(struct seq_file *m, struct crypto_alg *alg)\n{\n\tseq_puts(m, \"type         : kpp\\n\");\n}\n\nstatic void crypto_kpp_exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_kpp *kpp = __crypto_kpp_tfm(tfm);\n\tstruct kpp_alg *alg = crypto_kpp_alg(kpp);\n\n\talg->exit(kpp);\n}\n\nstatic int crypto_kpp_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_kpp *kpp = __crypto_kpp_tfm(tfm);\n\tstruct kpp_alg *alg = crypto_kpp_alg(kpp);\n\n\tif (alg->exit)\n\t\tkpp->base.exit = crypto_kpp_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(kpp);\n\n\treturn 0;\n}\n\nstatic void crypto_kpp_free_instance(struct crypto_instance *inst)\n{\n\tstruct kpp_instance *kpp = kpp_instance(inst);\n\n\tkpp->free(kpp);\n}\n\nstatic int __maybe_unused crypto_kpp_report_stat(\n\tstruct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct kpp_alg *kpp = __crypto_kpp_alg(alg);\n\tstruct crypto_istat_kpp *istat;\n\tstruct crypto_stat_kpp rkpp;\n\n\tistat = kpp_get_stat(kpp);\n\n\tmemset(&rkpp, 0, sizeof(rkpp));\n\n\tstrscpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\n\trkpp.stat_setsecret_cnt = atomic64_read(&istat->setsecret_cnt);\n\trkpp.stat_generate_public_key_cnt =\n\t\tatomic64_read(&istat->generate_public_key_cnt);\n\trkpp.stat_compute_shared_secret_cnt =\n\t\tatomic64_read(&istat->compute_shared_secret_cnt);\n\trkpp.stat_err_cnt = atomic64_read(&istat->err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_KPP, sizeof(rkpp), &rkpp);\n}\n\nstatic const struct crypto_type crypto_kpp_type = {\n\t.extsize = crypto_alg_extsize,\n\t.init_tfm = crypto_kpp_init_tfm,\n\t.free = crypto_kpp_free_instance,\n#ifdef CONFIG_PROC_FS\n\t.show = crypto_kpp_show,\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_USER)\n\t.report = crypto_kpp_report,\n#endif\n#ifdef CONFIG_CRYPTO_STATS\n\t.report_stat = crypto_kpp_report_stat,\n#endif\n\t.maskclear = ~CRYPTO_ALG_TYPE_MASK,\n\t.maskset = CRYPTO_ALG_TYPE_MASK,\n\t.type = CRYPTO_ALG_TYPE_KPP,\n\t.tfmsize = offsetof(struct crypto_kpp, base),\n};\n\nstruct crypto_kpp *crypto_alloc_kpp(const char *alg_name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_tfm(alg_name, &crypto_kpp_type, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_alloc_kpp);\n\nint crypto_grab_kpp(struct crypto_kpp_spawn *spawn,\n\t\t    struct crypto_instance *inst,\n\t\t    const char *name, u32 type, u32 mask)\n{\n\tspawn->base.frontend = &crypto_kpp_type;\n\treturn crypto_grab_spawn(&spawn->base, inst, name, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_grab_kpp);\n\nint crypto_has_kpp(const char *alg_name, u32 type, u32 mask)\n{\n\treturn crypto_type_has_alg(alg_name, &crypto_kpp_type, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_has_kpp);\n\nstatic void kpp_prepare_alg(struct kpp_alg *alg)\n{\n\tstruct crypto_istat_kpp *istat = kpp_get_stat(alg);\n\tstruct crypto_alg *base = &alg->base;\n\n\tbase->cra_type = &crypto_kpp_type;\n\tbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\n\tbase->cra_flags |= CRYPTO_ALG_TYPE_KPP;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_STATS))\n\t\tmemset(istat, 0, sizeof(*istat));\n}\n\nint crypto_register_kpp(struct kpp_alg *alg)\n{\n\tstruct crypto_alg *base = &alg->base;\n\n\tkpp_prepare_alg(alg);\n\treturn crypto_register_alg(base);\n}\nEXPORT_SYMBOL_GPL(crypto_register_kpp);\n\nvoid crypto_unregister_kpp(struct kpp_alg *alg)\n{\n\tcrypto_unregister_alg(&alg->base);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_kpp);\n\nint kpp_register_instance(struct crypto_template *tmpl,\n\t\t\t  struct kpp_instance *inst)\n{\n\tif (WARN_ON(!inst->free))\n\t\treturn -EINVAL;\n\n\tkpp_prepare_alg(&inst->alg);\n\n\treturn crypto_register_instance(tmpl, kpp_crypto_instance(inst));\n}\nEXPORT_SYMBOL_GPL(kpp_register_instance);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Key-agreement Protocol Primitives\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}