{
  "module_name": "kdf_sp800108.c",
  "hash_id": "1cc1f9870f627071b26921160d926362c4030796f51552589d13b2d252c39c27",
  "original_prompt": "Ingested from linux-6.6.14/crypto/kdf_sp800108.c",
  "human_readable_source": "\n\n \n\n#include <linux/fips.h>\n#include <linux/module.h>\n#include <crypto/kdf_sp800108.h>\n#include <crypto/internal/kdf_selftest.h>\n\n \nint crypto_kdf108_ctr_generate(struct crypto_shash *kmd,\n\t\t\t       const struct kvec *info, unsigned int info_nvec,\n\t\t\t       u8 *dst, unsigned int dlen)\n{\n\tSHASH_DESC_ON_STACK(desc, kmd);\n\t__be32 counter = cpu_to_be32(1);\n\tconst unsigned int h = crypto_shash_digestsize(kmd), dlen_orig = dlen;\n\tunsigned int i;\n\tint err = 0;\n\tu8 *dst_orig = dst;\n\n\tdesc->tfm = kmd;\n\n\twhile (dlen) {\n\t\terr = crypto_shash_init(desc);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = crypto_shash_update(desc, (u8 *)&counter, sizeof(__be32));\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < info_nvec; i++) {\n\t\t\terr = crypto_shash_update(desc, info[i].iov_base,\n\t\t\t\t\t\t  info[i].iov_len);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (dlen < h) {\n\t\t\tu8 tmpbuffer[HASH_MAX_DIGESTSIZE];\n\n\t\t\terr = crypto_shash_final(desc, tmpbuffer);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tmemcpy(dst, tmpbuffer, dlen);\n\t\t\tmemzero_explicit(tmpbuffer, h);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = crypto_shash_final(desc, dst);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdlen -= h;\n\t\tdst += h;\n\t\tcounter = cpu_to_be32(be32_to_cpu(counter) + 1);\n\t}\n\nout:\n\tif (err)\n\t\tmemzero_explicit(dst_orig, dlen_orig);\n\tshash_desc_zero(desc);\n\treturn err;\n}\nEXPORT_SYMBOL(crypto_kdf108_ctr_generate);\n\n \nint crypto_kdf108_setkey(struct crypto_shash *kmd,\n\t\t\t const u8 *key, size_t keylen,\n\t\t\t const u8 *ikm, size_t ikmlen)\n{\n\tunsigned int ds = crypto_shash_digestsize(kmd);\n\n\t \n\tif (ikm || ikmlen)\n\t\treturn -EINVAL;\n\n\t \n\tif (ds > keylen)\n\t\treturn -EINVAL;\n\n\t \n\treturn crypto_shash_setkey(kmd, key, keylen);\n}\nEXPORT_SYMBOL(crypto_kdf108_setkey);\n\n \nstatic const struct kdf_testvec kdf_ctr_hmac_sha256_tv_template[] = {\n\t{\n\t\t.key = \"\\xdd\\x1d\\x91\\xb7\\xd9\\x0b\\x2b\\xd3\"\n\t\t       \"\\x13\\x85\\x33\\xce\\x92\\xb2\\x72\\xfb\"\n\t\t       \"\\xf8\\xa3\\x69\\x31\\x6a\\xef\\xe2\\x42\"\n\t\t       \"\\xe6\\x59\\xcc\\x0a\\xe2\\x38\\xaf\\xe0\",\n\t\t.keylen = 32,\n\t\t.ikm = NULL,\n\t\t.ikmlen = 0,\n\t\t.info = {\n\t\t\t.iov_base = \"\\x01\\x32\\x2b\\x96\\xb3\\x0a\\xcd\\x19\"\n\t\t\t\t    \"\\x79\\x79\\x44\\x4e\\x46\\x8e\\x1c\\x5c\"\n\t\t\t\t    \"\\x68\\x59\\xbf\\x1b\\x1c\\xf9\\x51\\xb7\"\n\t\t\t\t    \"\\xe7\\x25\\x30\\x3e\\x23\\x7e\\x46\\xb8\"\n\t\t\t\t    \"\\x64\\xa1\\x45\\xfa\\xb2\\x5e\\x51\\x7b\"\n\t\t\t\t    \"\\x08\\xf8\\x68\\x3d\\x03\\x15\\xbb\\x29\"\n\t\t\t\t    \"\\x11\\xd8\\x0a\\x0e\\x8a\\xba\\x17\\xf3\"\n\t\t\t\t    \"\\xb4\\x13\\xfa\\xac\",\n\t\t\t.iov_len  = 60\n\t\t},\n\t\t.expected\t  = \"\\x10\\x62\\x13\\x42\\xbf\\xb0\\xfd\\x40\"\n\t\t\t\t    \"\\x04\\x6c\\x0e\\x29\\xf2\\xcf\\xdb\\xf0\",\n\t\t.expectedlen\t  = 16\n\t}\n};\n\nstatic int __init crypto_kdf108_init(void)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_MANAGER_DISABLE_TESTS))\n\t\treturn 0;\n\n\tret = kdf_test(&kdf_ctr_hmac_sha256_tv_template[0], \"hmac(sha256)\",\n\t\t       crypto_kdf108_setkey, crypto_kdf108_ctr_generate);\n\tif (ret) {\n\t\tif (fips_enabled)\n\t\t\tpanic(\"alg: self-tests for CTR-KDF (hmac(sha256)) failed (rc=%d)\\n\",\n\t\t\t      ret);\n\n\t\tWARN(1,\n\t\t     \"alg: self-tests for CTR-KDF (hmac(sha256)) failed (rc=%d)\\n\",\n\t\t     ret);\n\t} else if (fips_enabled) {\n\t\tpr_info(\"alg: self-tests for CTR-KDF (hmac(sha256)) passed\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit crypto_kdf108_exit(void) { }\n\nmodule_init(crypto_kdf108_init);\nmodule_exit(crypto_kdf108_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Stephan Mueller <smueller@chronox.de>\");\nMODULE_DESCRIPTION(\"Key Derivation Function conformant to SP800-108\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}