{
  "module_name": "proc.c",
  "hash_id": "f4c2e7d49cc90a2c46f04213ea34be3722bc6a4e56cfd211d488434dd7e2c69e",
  "original_prompt": "Ingested from linux-6.6.14/crypto/proc.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/init.h>\n#include <linux/crypto.h>\n#include <linux/fips.h>\n#include <linux/module.h>\t \n#include <linux/rwsem.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include \"internal.h\"\n\nstatic void *c_start(struct seq_file *m, loff_t *pos)\n{\n\tdown_read(&crypto_alg_sem);\n\treturn seq_list_start(&crypto_alg_list, *pos);\n}\n\nstatic void *c_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\treturn seq_list_next(p, &crypto_alg_list, pos);\n}\n\nstatic void c_stop(struct seq_file *m, void *p)\n{\n\tup_read(&crypto_alg_sem);\n}\n\nstatic int c_show(struct seq_file *m, void *p)\n{\n\tstruct crypto_alg *alg = list_entry(p, struct crypto_alg, cra_list);\n\n\tseq_printf(m, \"name         : %s\\n\", alg->cra_name);\n\tseq_printf(m, \"driver       : %s\\n\", alg->cra_driver_name);\n\tseq_printf(m, \"module       : %s\\n\", module_name(alg->cra_module));\n\tseq_printf(m, \"priority     : %d\\n\", alg->cra_priority);\n\tseq_printf(m, \"refcnt       : %u\\n\", refcount_read(&alg->cra_refcnt));\n\tseq_printf(m, \"selftest     : %s\\n\",\n\t\t   (alg->cra_flags & CRYPTO_ALG_TESTED) ?\n\t\t   \"passed\" : \"unknown\");\n\tseq_printf(m, \"internal     : %s\\n\",\n\t\t   (alg->cra_flags & CRYPTO_ALG_INTERNAL) ?\n\t\t   \"yes\" : \"no\");\n\tif (fips_enabled) {\n\t\tseq_printf(m, \"fips         : %s\\n\",\n\t\t\t   (alg->cra_flags & CRYPTO_ALG_FIPS_INTERNAL) ?\n\t\t\t   \"no\" : \"yes\");\n\t}\n\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tseq_printf(m, \"type         : larval\\n\");\n\t\tseq_printf(m, \"flags        : 0x%x\\n\", alg->cra_flags);\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->show) {\n\t\talg->cra_type->show(m, alg);\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & CRYPTO_ALG_TYPE_MASK) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tseq_printf(m, \"type         : cipher\\n\");\n\t\tseq_printf(m, \"blocksize    : %u\\n\", alg->cra_blocksize);\n\t\tseq_printf(m, \"min keysize  : %u\\n\",\n\t\t\t\t\talg->cra_cipher.cia_min_keysize);\n\t\tseq_printf(m, \"max keysize  : %u\\n\",\n\t\t\t\t\talg->cra_cipher.cia_max_keysize);\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tseq_printf(m, \"type         : compression\\n\");\n\t\tbreak;\n\tdefault:\n\t\tseq_printf(m, \"type         : unknown\\n\");\n\t\tbreak;\n\t}\n\nout:\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic const struct seq_operations crypto_seq_ops = {\n\t.start\t\t= c_start,\n\t.next\t\t= c_next,\n\t.stop\t\t= c_stop,\n\t.show\t\t= c_show\n};\n\nvoid __init crypto_init_proc(void)\n{\n\tproc_create_seq(\"crypto\", 0, NULL, &crypto_seq_ops);\n}\n\nvoid __exit crypto_exit_proc(void)\n{\n\tremove_proc_entry(\"crypto\", NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}