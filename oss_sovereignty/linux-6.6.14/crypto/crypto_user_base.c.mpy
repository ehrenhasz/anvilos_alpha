{
  "module_name": "crypto_user_base.c",
  "hash_id": "a0f409c36f794d042b1580f6cf245084375bfc7e128151ae72b7d20b5054fa72",
  "original_prompt": "Ingested from linux-6.6.14/crypto/crypto_user_base.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <linux/cryptouser.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <net/netlink.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/internal/rng.h>\n#include <crypto/akcipher.h>\n#include <crypto/kpp.h>\n#include <crypto/internal/cryptouser.h>\n\n#include \"internal.h\"\n\n#define null_terminated(x)\t(strnlen(x, sizeof(x)) < sizeof(x))\n\nstatic DEFINE_MUTEX(crypto_cfg_mutex);\n\nstruct crypto_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstruct crypto_alg *crypto_alg_match(struct crypto_user_alg *p, int exact)\n{\n\tstruct crypto_alg *q, *alg = NULL;\n\n\tdown_read(&crypto_alg_sem);\n\n\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\tint match = 0;\n\n\t\tif (crypto_is_larval(q))\n\t\t\tcontinue;\n\n\t\tif ((q->cra_flags ^ p->cru_type) & p->cru_mask)\n\t\t\tcontinue;\n\n\t\tif (strlen(p->cru_driver_name))\n\t\t\tmatch = !strcmp(q->cra_driver_name,\n\t\t\t\t\tp->cru_driver_name);\n\t\telse if (!exact)\n\t\t\tmatch = !strcmp(q->cra_name, p->cru_name);\n\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (unlikely(!crypto_mod_get(q)))\n\t\t\tcontinue;\n\n\t\talg = q;\n\t\tbreak;\n\t}\n\n\tup_read(&crypto_alg_sem);\n\n\treturn alg;\n}\n\nstatic int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tmemset(&rcipher, 0, sizeof(rcipher));\n\n\tstrscpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t       sizeof(rcipher), &rcipher);\n}\n\nstatic int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tmemset(&rcomp, 0, sizeof(rcomp));\n\n\tstrscpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS, sizeof(rcomp), &rcomp);\n}\n\nstatic int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tmemset(ualg, 0, sizeof(*ualg));\n\n\tstrscpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrscpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrscpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tmemset(&rl, 0, sizeof(rl));\n\t\tstrscpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL, sizeof(rl), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_alg(struct crypto_alg *alg,\n\t\t\t     struct crypto_dump_info *info)\n{\n\tstruct sk_buff *in_skb = info->in_skb;\n\tstruct sk_buff *skb = info->out_skb;\n\tstruct nlmsghdr *nlh;\n\tstruct crypto_user_alg *ualg;\n\tint err = 0;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, info->nlmsg_seq,\n\t\t\tCRYPTO_MSG_GETALG, sizeof(*ualg), info->nlmsg_flags);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tualg = nlmsg_data(nlh);\n\n\terr = crypto_report_one(alg, ualg, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\nout:\n\treturn err;\n}\n\nstatic int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_report_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}\n\nstatic int crypto_dump_report(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst size_t start_pos = cb->args[0];\n\tsize_t pos = 0;\n\tstruct crypto_dump_info info;\n\tstruct crypto_alg *alg;\n\tint res;\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tdown_read(&crypto_alg_sem);\n\tlist_for_each_entry(alg, &crypto_alg_list, cra_list) {\n\t\tif (pos >= start_pos) {\n\t\t\tres = crypto_report_alg(alg, &info);\n\t\t\tif (res == -EMSGSIZE)\n\t\t\t\tbreak;\n\t\t\tif (res)\n\t\t\t\tgoto out;\n\t\t}\n\t\tpos++;\n\t}\n\tcb->args[0] = pos;\n\tres = skb->len;\nout:\n\tup_read(&crypto_alg_sem);\n\treturn res;\n}\n\nstatic int crypto_dump_report_done(struct netlink_callback *cb)\n{\n\treturn 0;\n}\n\nstatic int crypto_update_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct nlattr **attrs)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\n\tLIST_HEAD(list);\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\tif (priority && !strlen(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 1);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\tdown_write(&crypto_alg_sem);\n\n\tcrypto_remove_spawns(alg, &list, NULL);\n\n\tif (priority)\n\t\talg->cra_priority = nla_get_u32(priority);\n\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_mod_put(alg);\n\tcrypto_remove_final(&list);\n\n\treturn 0;\n}\n\nstatic int crypto_del_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tint err;\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 1);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\t \n\terr = -EINVAL;\n\tif (!(alg->cra_flags & CRYPTO_ALG_INSTANCE))\n\t\tgoto drop_alg;\n\n\terr = -EBUSY;\n\tif (refcount_read(&alg->cra_refcnt) > 2)\n\t\tgoto drop_alg;\n\n\tcrypto_unregister_instance((struct crypto_instance *)alg);\n\terr = 0;\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}\n\nstatic int crypto_add_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tint exact = 0;\n\tconst char *name;\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\tif (strlen(p->cru_driver_name))\n\t\texact = 1;\n\n\tif (priority && !exact)\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, exact);\n\tif (alg) {\n\t\tcrypto_mod_put(alg);\n\t\treturn -EEXIST;\n\t}\n\n\tif (strlen(p->cru_driver_name))\n\t\tname = p->cru_driver_name;\n\telse\n\t\tname = p->cru_name;\n\n\talg = crypto_alg_mod_lookup(name, p->cru_type, p->cru_mask);\n\tif (IS_ERR(alg))\n\t\treturn PTR_ERR(alg);\n\n\tdown_write(&crypto_alg_sem);\n\n\tif (priority)\n\t\talg->cra_priority = nla_get_u32(priority);\n\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_mod_put(alg);\n\n\treturn 0;\n}\n\nstatic int crypto_del_rng(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\treturn crypto_del_default_rng();\n}\n\n#define MSGSIZE(type) sizeof(struct type)\n\nstatic const int crypto_msg_min[CRYPTO_NR_MSGTYPES] = {\n\t[CRYPTO_MSG_NEWALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_DELALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_UPDATEALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_GETALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_DELRNG\t- CRYPTO_MSG_BASE] = 0,\n\t[CRYPTO_MSG_GETSTAT\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n};\n\nstatic const struct nla_policy crypto_policy[CRYPTOCFGA_MAX+1] = {\n\t[CRYPTOCFGA_PRIORITY_VAL]   = { .type = NLA_U32},\n};\n\n#undef MSGSIZE\n\nstatic const struct crypto_link {\n\tint (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);\n\tint (*dump)(struct sk_buff *, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n} crypto_dispatch[CRYPTO_NR_MSGTYPES] = {\n\t[CRYPTO_MSG_NEWALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_add_alg},\n\t[CRYPTO_MSG_DELALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_del_alg},\n\t[CRYPTO_MSG_UPDATEALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_update_alg},\n\t[CRYPTO_MSG_GETALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_report,\n\t\t\t\t\t\t       .dump = crypto_dump_report,\n\t\t\t\t\t\t       .done = crypto_dump_report_done},\n\t[CRYPTO_MSG_DELRNG\t- CRYPTO_MSG_BASE] = { .doit = crypto_del_rng },\n\t[CRYPTO_MSG_GETSTAT\t- CRYPTO_MSG_BASE] = { .doit = crypto_reportstat},\n};\n\nstatic int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[CRYPTOCFGA_MAX+1];\n\tconst struct crypto_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > CRYPTO_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= CRYPTO_MSG_BASE;\n\tlink = &crypto_dispatch[type];\n\n\tif ((type == (CRYPTO_MSG_GETALG - CRYPTO_MSG_BASE) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP))) {\n\t\tstruct crypto_alg *alg;\n\t\tunsigned long dump_alloc = 0;\n\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tdown_read(&crypto_alg_sem);\n\t\tlist_for_each_entry(alg, &crypto_alg_list, cra_list)\n\t\t\tdump_alloc += CRYPTO_REPORT_MAXSIZE;\n\t\tup_read(&crypto_alg_sem);\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t\t.min_dump_alloc = min(dump_alloc, 65535UL),\n\t\t\t};\n\t\t\terr = netlink_dump_start(net->crypto_nlsk, skb, nlh, &c);\n\t\t}\n\n\t\treturn err;\n\t}\n\n\terr = nlmsg_parse_deprecated(nlh, crypto_msg_min[type], attrs,\n\t\t\t\t     CRYPTOCFGA_MAX, crypto_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n\nstatic void crypto_netlink_rcv(struct sk_buff *skb)\n{\n\tmutex_lock(&crypto_cfg_mutex);\n\tnetlink_rcv_skb(skb, &crypto_user_rcv_msg);\n\tmutex_unlock(&crypto_cfg_mutex);\n}\n\nstatic int __net_init crypto_netlink_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= crypto_netlink_rcv,\n\t};\n\n\tnet->crypto_nlsk = netlink_kernel_create(net, NETLINK_CRYPTO, &cfg);\n\treturn net->crypto_nlsk == NULL ? -ENOMEM : 0;\n}\n\nstatic void __net_exit crypto_netlink_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->crypto_nlsk);\n\tnet->crypto_nlsk = NULL;\n}\n\nstatic struct pernet_operations crypto_netlink_net_ops = {\n\t.init = crypto_netlink_init,\n\t.exit = crypto_netlink_exit,\n};\n\nstatic int __init crypto_user_init(void)\n{\n\treturn register_pernet_subsys(&crypto_netlink_net_ops);\n}\n\nstatic void __exit crypto_user_exit(void)\n{\n\tunregister_pernet_subsys(&crypto_netlink_net_ops);\n}\n\nmodule_init(crypto_user_init);\nmodule_exit(crypto_user_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Steffen Klassert <steffen.klassert@secunet.com>\");\nMODULE_DESCRIPTION(\"Crypto userspace configuration API\");\nMODULE_ALIAS(\"net-pf-16-proto-21\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}