{
  "module_name": "tea.c",
  "hash_id": "79125421d20b89841690c3a6fe0454323d66ddcfe89775f1730a8d34e64950ae",
  "original_prompt": "Ingested from linux-6.6.14/crypto/tea.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <asm/byteorder.h>\n#include <linux/types.h>\n\n#define TEA_KEY_SIZE\t\t16\n#define TEA_BLOCK_SIZE\t\t8\n#define TEA_ROUNDS\t\t32\n#define TEA_DELTA\t\t0x9e3779b9\n\n#define XTEA_KEY_SIZE\t\t16\n#define XTEA_BLOCK_SIZE\t\t8\n#define XTEA_ROUNDS\t\t32\n#define XTEA_DELTA\t\t0x9e3779b9\n\nstruct tea_ctx {\n\tu32 KEY[4];\n};\n\nstruct xtea_ctx {\n\tu32 KEY[4];\n};\n\nstatic int tea_setkey(struct crypto_tfm *tfm, const u8 *in_key,\n\t\t      unsigned int key_len)\n{\n\tstruct tea_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst __le32 *key = (const __le32 *)in_key;\n\n\tctx->KEY[0] = le32_to_cpu(key[0]);\n\tctx->KEY[1] = le32_to_cpu(key[1]);\n\tctx->KEY[2] = le32_to_cpu(key[2]);\n\tctx->KEY[3] = le32_to_cpu(key[3]);\n\n\treturn 0; \n\n}\n\nstatic void tea_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tu32 y, z, n, sum = 0;\n\tu32 k0, k1, k2, k3;\n\tstruct tea_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst __le32 *in = (const __le32 *)src;\n\t__le32 *out = (__le32 *)dst;\n\n\ty = le32_to_cpu(in[0]);\n\tz = le32_to_cpu(in[1]);\n\n\tk0 = ctx->KEY[0];\n\tk1 = ctx->KEY[1];\n\tk2 = ctx->KEY[2];\n\tk3 = ctx->KEY[3];\n\n\tn = TEA_ROUNDS;\n\n\twhile (n-- > 0) {\n\t\tsum += TEA_DELTA;\n\t\ty += ((z << 4) + k0) ^ (z + sum) ^ ((z >> 5) + k1);\n\t\tz += ((y << 4) + k2) ^ (y + sum) ^ ((y >> 5) + k3);\n\t}\n\t\n\tout[0] = cpu_to_le32(y);\n\tout[1] = cpu_to_le32(z);\n}\n\nstatic void tea_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tu32 y, z, n, sum;\n\tu32 k0, k1, k2, k3;\n\tstruct tea_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst __le32 *in = (const __le32 *)src;\n\t__le32 *out = (__le32 *)dst;\n\n\ty = le32_to_cpu(in[0]);\n\tz = le32_to_cpu(in[1]);\n\n\tk0 = ctx->KEY[0];\n\tk1 = ctx->KEY[1];\n\tk2 = ctx->KEY[2];\n\tk3 = ctx->KEY[3];\n\n\tsum = TEA_DELTA << 5;\n\n\tn = TEA_ROUNDS;\n\n\twhile (n-- > 0) {\n\t\tz -= ((y << 4) + k2) ^ (y + sum) ^ ((y >> 5) + k3);\n\t\ty -= ((z << 4) + k0) ^ (z + sum) ^ ((z >> 5) + k1);\n\t\tsum -= TEA_DELTA;\n\t}\n\t\n\tout[0] = cpu_to_le32(y);\n\tout[1] = cpu_to_le32(z);\n}\n\nstatic int xtea_setkey(struct crypto_tfm *tfm, const u8 *in_key,\n\t\t       unsigned int key_len)\n{\n\tstruct xtea_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst __le32 *key = (const __le32 *)in_key;\n\n\tctx->KEY[0] = le32_to_cpu(key[0]);\n\tctx->KEY[1] = le32_to_cpu(key[1]);\n\tctx->KEY[2] = le32_to_cpu(key[2]);\n\tctx->KEY[3] = le32_to_cpu(key[3]);\n\n\treturn 0; \n\n}\n\nstatic void xtea_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tu32 y, z, sum = 0;\n\tu32 limit = XTEA_DELTA * XTEA_ROUNDS;\n\tstruct xtea_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst __le32 *in = (const __le32 *)src;\n\t__le32 *out = (__le32 *)dst;\n\n\ty = le32_to_cpu(in[0]);\n\tz = le32_to_cpu(in[1]);\n\n\twhile (sum != limit) {\n\t\ty += ((z << 4 ^ z >> 5) + z) ^ (sum + ctx->KEY[sum&3]); \n\t\tsum += XTEA_DELTA;\n\t\tz += ((y << 4 ^ y >> 5) + y) ^ (sum + ctx->KEY[sum>>11 &3]); \n\t}\n\t\n\tout[0] = cpu_to_le32(y);\n\tout[1] = cpu_to_le32(z);\n}\n\nstatic void xtea_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tu32 y, z, sum;\n\tstruct tea_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst __le32 *in = (const __le32 *)src;\n\t__le32 *out = (__le32 *)dst;\n\n\ty = le32_to_cpu(in[0]);\n\tz = le32_to_cpu(in[1]);\n\n\tsum = XTEA_DELTA * XTEA_ROUNDS;\n\n\twhile (sum) {\n\t\tz -= ((y << 4 ^ y >> 5) + y) ^ (sum + ctx->KEY[sum>>11 & 3]);\n\t\tsum -= XTEA_DELTA;\n\t\ty -= ((z << 4 ^ z >> 5) + z) ^ (sum + ctx->KEY[sum & 3]);\n\t}\n\t\n\tout[0] = cpu_to_le32(y);\n\tout[1] = cpu_to_le32(z);\n}\n\n\nstatic void xeta_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tu32 y, z, sum = 0;\n\tu32 limit = XTEA_DELTA * XTEA_ROUNDS;\n\tstruct xtea_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst __le32 *in = (const __le32 *)src;\n\t__le32 *out = (__le32 *)dst;\n\n\ty = le32_to_cpu(in[0]);\n\tz = le32_to_cpu(in[1]);\n\n\twhile (sum != limit) {\n\t\ty += (z << 4 ^ z >> 5) + (z ^ sum) + ctx->KEY[sum&3];\n\t\tsum += XTEA_DELTA;\n\t\tz += (y << 4 ^ y >> 5) + (y ^ sum) + ctx->KEY[sum>>11 &3];\n\t}\n\t\n\tout[0] = cpu_to_le32(y);\n\tout[1] = cpu_to_le32(z);\n}\n\nstatic void xeta_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tu32 y, z, sum;\n\tstruct tea_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst __le32 *in = (const __le32 *)src;\n\t__le32 *out = (__le32 *)dst;\n\n\ty = le32_to_cpu(in[0]);\n\tz = le32_to_cpu(in[1]);\n\n\tsum = XTEA_DELTA * XTEA_ROUNDS;\n\n\twhile (sum) {\n\t\tz -= (y << 4 ^ y >> 5) + (y ^ sum) + ctx->KEY[sum>>11 & 3];\n\t\tsum -= XTEA_DELTA;\n\t\ty -= (z << 4 ^ z >> 5) + (z ^ sum) + ctx->KEY[sum & 3];\n\t}\n\t\n\tout[0] = cpu_to_le32(y);\n\tout[1] = cpu_to_le32(z);\n}\n\nstatic struct crypto_alg tea_algs[3] = { {\n\t.cra_name\t\t=\t\"tea\",\n\t.cra_driver_name\t=\t\"tea-generic\",\n\t.cra_flags\t\t=\tCRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize\t\t=\tTEA_BLOCK_SIZE,\n\t.cra_ctxsize\t\t=\tsizeof (struct tea_ctx),\n\t.cra_alignmask\t\t=\t3,\n\t.cra_module\t\t=\tTHIS_MODULE,\n\t.cra_u\t\t\t=\t{ .cipher = {\n\t.cia_min_keysize\t=\tTEA_KEY_SIZE,\n\t.cia_max_keysize\t=\tTEA_KEY_SIZE,\n\t.cia_setkey\t\t= \ttea_setkey,\n\t.cia_encrypt\t\t=\ttea_encrypt,\n\t.cia_decrypt\t\t=\ttea_decrypt } }\n}, {\n\t.cra_name\t\t=\t\"xtea\",\n\t.cra_driver_name\t=\t\"xtea-generic\",\n\t.cra_flags\t\t=\tCRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize\t\t=\tXTEA_BLOCK_SIZE,\n\t.cra_ctxsize\t\t=\tsizeof (struct xtea_ctx),\n\t.cra_alignmask\t\t=\t3,\n\t.cra_module\t\t=\tTHIS_MODULE,\n\t.cra_u\t\t\t=\t{ .cipher = {\n\t.cia_min_keysize\t=\tXTEA_KEY_SIZE,\n\t.cia_max_keysize\t=\tXTEA_KEY_SIZE,\n\t.cia_setkey\t\t= \txtea_setkey,\n\t.cia_encrypt\t\t=\txtea_encrypt,\n\t.cia_decrypt\t\t=\txtea_decrypt } }\n}, {\n\t.cra_name\t\t=\t\"xeta\",\n\t.cra_driver_name\t=\t\"xeta-generic\",\n\t.cra_flags\t\t=\tCRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize\t\t=\tXTEA_BLOCK_SIZE,\n\t.cra_ctxsize\t\t=\tsizeof (struct xtea_ctx),\n\t.cra_alignmask\t\t=\t3,\n\t.cra_module\t\t=\tTHIS_MODULE,\n\t.cra_u\t\t\t=\t{ .cipher = {\n\t.cia_min_keysize\t=\tXTEA_KEY_SIZE,\n\t.cia_max_keysize\t=\tXTEA_KEY_SIZE,\n\t.cia_setkey\t\t= \txtea_setkey,\n\t.cia_encrypt\t\t=\txeta_encrypt,\n\t.cia_decrypt\t\t=\txeta_decrypt } }\n} };\n\nstatic int __init tea_mod_init(void)\n{\n\treturn crypto_register_algs(tea_algs, ARRAY_SIZE(tea_algs));\n}\n\nstatic void __exit tea_mod_fini(void)\n{\n\tcrypto_unregister_algs(tea_algs, ARRAY_SIZE(tea_algs));\n}\n\nMODULE_ALIAS_CRYPTO(\"tea\");\nMODULE_ALIAS_CRYPTO(\"xtea\");\nMODULE_ALIAS_CRYPTO(\"xeta\");\n\nsubsys_initcall(tea_mod_init);\nmodule_exit(tea_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TEA, XTEA & XETA Cryptographic Algorithms\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}