{
  "module_name": "chacha20poly1305.c",
  "hash_id": "6d55e11c43def6550894d2aa7dae84aa25352ba60e5fd9548270753972f0a919",
  "original_prompt": "Ingested from linux-6.6.14/crypto/chacha20poly1305.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/aead.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/chacha.h>\n#include <crypto/poly1305.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct chachapoly_instance_ctx {\n\tstruct crypto_skcipher_spawn chacha;\n\tstruct crypto_ahash_spawn poly;\n\tunsigned int saltlen;\n};\n\nstruct chachapoly_ctx {\n\tstruct crypto_skcipher *chacha;\n\tstruct crypto_ahash *poly;\n\t \n\tunsigned int saltlen;\n\tu8 salt[];\n};\n\nstruct poly_req {\n\t \n\tu8 pad[POLY1305_BLOCK_SIZE];\n\t \n\tstruct {\n\t\t__le64 assoclen;\n\t\t__le64 cryptlen;\n\t} tail;\n\tstruct scatterlist src[1];\n\tstruct ahash_request req;  \n};\n\nstruct chacha_req {\n\tu8 iv[CHACHA_IV_SIZE];\n\tstruct scatterlist src[1];\n\tstruct skcipher_request req;  \n};\n\nstruct chachapoly_req_ctx {\n\tstruct scatterlist src[2];\n\tstruct scatterlist dst[2];\n\t \n\tu8 key[POLY1305_KEY_SIZE];\n\t \n\tu8 tag[POLY1305_DIGEST_SIZE];\n\t \n\tunsigned int cryptlen;\n\t \n\tunsigned int assoclen;\n\t \n\tu32 flags;\n\tunion {\n\t\tstruct poly_req poly;\n\t\tstruct chacha_req chacha;\n\t} u;\n};\n\nstatic inline void async_done_continue(struct aead_request *req, int err,\n\t\t\t\t       int (*cont)(struct aead_request *))\n{\n\tif (!err) {\n\t\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\n\t\trctx->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\n\t\terr = cont(req);\n\t}\n\n\tif (err != -EINPROGRESS && err != -EBUSY)\n\t\taead_request_complete(req, err);\n}\n\nstatic void chacha_iv(u8 *iv, struct aead_request *req, u32 icb)\n{\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\t__le32 leicb = cpu_to_le32(icb);\n\n\tmemcpy(iv, &leicb, sizeof(leicb));\n\tmemcpy(iv + sizeof(leicb), ctx->salt, ctx->saltlen);\n\tmemcpy(iv + sizeof(leicb) + ctx->saltlen, req->iv,\n\t       CHACHA_IV_SIZE - sizeof(leicb) - ctx->saltlen);\n}\n\nstatic int poly_verify_tag(struct aead_request *req)\n{\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\tu8 tag[sizeof(rctx->tag)];\n\n\tscatterwalk_map_and_copy(tag, req->src,\n\t\t\t\t req->assoclen + rctx->cryptlen,\n\t\t\t\t sizeof(tag), 0);\n\tif (crypto_memneq(tag, rctx->tag, sizeof(tag)))\n\t\treturn -EBADMSG;\n\treturn 0;\n}\n\nstatic int poly_copy_tag(struct aead_request *req)\n{\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\n\tscatterwalk_map_and_copy(rctx->tag, req->dst,\n\t\t\t\t req->assoclen + rctx->cryptlen,\n\t\t\t\t sizeof(rctx->tag), 1);\n\treturn 0;\n}\n\nstatic void chacha_decrypt_done(void *data, int err)\n{\n\tasync_done_continue(data, err, poly_verify_tag);\n}\n\nstatic int chacha_decrypt(struct aead_request *req)\n{\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\tstruct chacha_req *creq = &rctx->u.chacha;\n\tstruct scatterlist *src, *dst;\n\tint err;\n\n\tif (rctx->cryptlen == 0)\n\t\tgoto skip;\n\n\tchacha_iv(creq->iv, req, 1);\n\n\tsrc = scatterwalk_ffwd(rctx->src, req->src, req->assoclen);\n\tdst = src;\n\tif (req->src != req->dst)\n\t\tdst = scatterwalk_ffwd(rctx->dst, req->dst, req->assoclen);\n\n\tskcipher_request_set_callback(&creq->req, rctx->flags,\n\t\t\t\t      chacha_decrypt_done, req);\n\tskcipher_request_set_tfm(&creq->req, ctx->chacha);\n\tskcipher_request_set_crypt(&creq->req, src, dst,\n\t\t\t\t   rctx->cryptlen, creq->iv);\n\terr = crypto_skcipher_decrypt(&creq->req);\n\tif (err)\n\t\treturn err;\n\nskip:\n\treturn poly_verify_tag(req);\n}\n\nstatic int poly_tail_continue(struct aead_request *req)\n{\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\n\tif (rctx->cryptlen == req->cryptlen)  \n\t\treturn poly_copy_tag(req);\n\n\treturn chacha_decrypt(req);\n}\n\nstatic void poly_tail_done(void *data, int err)\n{\n\tasync_done_continue(data, err, poly_tail_continue);\n}\n\nstatic int poly_tail(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\tstruct poly_req *preq = &rctx->u.poly;\n\tint err;\n\n\tpreq->tail.assoclen = cpu_to_le64(rctx->assoclen);\n\tpreq->tail.cryptlen = cpu_to_le64(rctx->cryptlen);\n\tsg_init_one(preq->src, &preq->tail, sizeof(preq->tail));\n\n\tahash_request_set_callback(&preq->req, rctx->flags,\n\t\t\t\t   poly_tail_done, req);\n\tahash_request_set_tfm(&preq->req, ctx->poly);\n\tahash_request_set_crypt(&preq->req, preq->src,\n\t\t\t\trctx->tag, sizeof(preq->tail));\n\n\terr = crypto_ahash_finup(&preq->req);\n\tif (err)\n\t\treturn err;\n\n\treturn poly_tail_continue(req);\n}\n\nstatic void poly_cipherpad_done(void *data, int err)\n{\n\tasync_done_continue(data, err, poly_tail);\n}\n\nstatic int poly_cipherpad(struct aead_request *req)\n{\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\tstruct poly_req *preq = &rctx->u.poly;\n\tunsigned int padlen;\n\tint err;\n\n\tpadlen = -rctx->cryptlen % POLY1305_BLOCK_SIZE;\n\tmemset(preq->pad, 0, sizeof(preq->pad));\n\tsg_init_one(preq->src, preq->pad, padlen);\n\n\tahash_request_set_callback(&preq->req, rctx->flags,\n\t\t\t\t   poly_cipherpad_done, req);\n\tahash_request_set_tfm(&preq->req, ctx->poly);\n\tahash_request_set_crypt(&preq->req, preq->src, NULL, padlen);\n\n\terr = crypto_ahash_update(&preq->req);\n\tif (err)\n\t\treturn err;\n\n\treturn poly_tail(req);\n}\n\nstatic void poly_cipher_done(void *data, int err)\n{\n\tasync_done_continue(data, err, poly_cipherpad);\n}\n\nstatic int poly_cipher(struct aead_request *req)\n{\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\tstruct poly_req *preq = &rctx->u.poly;\n\tstruct scatterlist *crypt = req->src;\n\tint err;\n\n\tif (rctx->cryptlen == req->cryptlen)  \n\t\tcrypt = req->dst;\n\n\tcrypt = scatterwalk_ffwd(rctx->src, crypt, req->assoclen);\n\n\tahash_request_set_callback(&preq->req, rctx->flags,\n\t\t\t\t   poly_cipher_done, req);\n\tahash_request_set_tfm(&preq->req, ctx->poly);\n\tahash_request_set_crypt(&preq->req, crypt, NULL, rctx->cryptlen);\n\n\terr = crypto_ahash_update(&preq->req);\n\tif (err)\n\t\treturn err;\n\n\treturn poly_cipherpad(req);\n}\n\nstatic void poly_adpad_done(void *data, int err)\n{\n\tasync_done_continue(data, err, poly_cipher);\n}\n\nstatic int poly_adpad(struct aead_request *req)\n{\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\tstruct poly_req *preq = &rctx->u.poly;\n\tunsigned int padlen;\n\tint err;\n\n\tpadlen = -rctx->assoclen % POLY1305_BLOCK_SIZE;\n\tmemset(preq->pad, 0, sizeof(preq->pad));\n\tsg_init_one(preq->src, preq->pad, padlen);\n\n\tahash_request_set_callback(&preq->req, rctx->flags,\n\t\t\t\t   poly_adpad_done, req);\n\tahash_request_set_tfm(&preq->req, ctx->poly);\n\tahash_request_set_crypt(&preq->req, preq->src, NULL, padlen);\n\n\terr = crypto_ahash_update(&preq->req);\n\tif (err)\n\t\treturn err;\n\n\treturn poly_cipher(req);\n}\n\nstatic void poly_ad_done(void *data, int err)\n{\n\tasync_done_continue(data, err, poly_adpad);\n}\n\nstatic int poly_ad(struct aead_request *req)\n{\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\tstruct poly_req *preq = &rctx->u.poly;\n\tint err;\n\n\tahash_request_set_callback(&preq->req, rctx->flags,\n\t\t\t\t   poly_ad_done, req);\n\tahash_request_set_tfm(&preq->req, ctx->poly);\n\tahash_request_set_crypt(&preq->req, req->src, NULL, rctx->assoclen);\n\n\terr = crypto_ahash_update(&preq->req);\n\tif (err)\n\t\treturn err;\n\n\treturn poly_adpad(req);\n}\n\nstatic void poly_setkey_done(void *data, int err)\n{\n\tasync_done_continue(data, err, poly_ad);\n}\n\nstatic int poly_setkey(struct aead_request *req)\n{\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\tstruct poly_req *preq = &rctx->u.poly;\n\tint err;\n\n\tsg_init_one(preq->src, rctx->key, sizeof(rctx->key));\n\n\tahash_request_set_callback(&preq->req, rctx->flags,\n\t\t\t\t   poly_setkey_done, req);\n\tahash_request_set_tfm(&preq->req, ctx->poly);\n\tahash_request_set_crypt(&preq->req, preq->src, NULL, sizeof(rctx->key));\n\n\terr = crypto_ahash_update(&preq->req);\n\tif (err)\n\t\treturn err;\n\n\treturn poly_ad(req);\n}\n\nstatic void poly_init_done(void *data, int err)\n{\n\tasync_done_continue(data, err, poly_setkey);\n}\n\nstatic int poly_init(struct aead_request *req)\n{\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\tstruct poly_req *preq = &rctx->u.poly;\n\tint err;\n\n\tahash_request_set_callback(&preq->req, rctx->flags,\n\t\t\t\t   poly_init_done, req);\n\tahash_request_set_tfm(&preq->req, ctx->poly);\n\n\terr = crypto_ahash_init(&preq->req);\n\tif (err)\n\t\treturn err;\n\n\treturn poly_setkey(req);\n}\n\nstatic void poly_genkey_done(void *data, int err)\n{\n\tasync_done_continue(data, err, poly_init);\n}\n\nstatic int poly_genkey(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\tstruct chacha_req *creq = &rctx->u.chacha;\n\tint err;\n\n\trctx->assoclen = req->assoclen;\n\n\tif (crypto_aead_ivsize(tfm) == 8) {\n\t\tif (rctx->assoclen < 8)\n\t\t\treturn -EINVAL;\n\t\trctx->assoclen -= 8;\n\t}\n\n\tmemset(rctx->key, 0, sizeof(rctx->key));\n\tsg_init_one(creq->src, rctx->key, sizeof(rctx->key));\n\n\tchacha_iv(creq->iv, req, 0);\n\n\tskcipher_request_set_callback(&creq->req, rctx->flags,\n\t\t\t\t      poly_genkey_done, req);\n\tskcipher_request_set_tfm(&creq->req, ctx->chacha);\n\tskcipher_request_set_crypt(&creq->req, creq->src, creq->src,\n\t\t\t\t   POLY1305_KEY_SIZE, creq->iv);\n\n\terr = crypto_skcipher_decrypt(&creq->req);\n\tif (err)\n\t\treturn err;\n\n\treturn poly_init(req);\n}\n\nstatic void chacha_encrypt_done(void *data, int err)\n{\n\tasync_done_continue(data, err, poly_genkey);\n}\n\nstatic int chacha_encrypt(struct aead_request *req)\n{\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\tstruct chacha_req *creq = &rctx->u.chacha;\n\tstruct scatterlist *src, *dst;\n\tint err;\n\n\tif (req->cryptlen == 0)\n\t\tgoto skip;\n\n\tchacha_iv(creq->iv, req, 1);\n\n\tsrc = scatterwalk_ffwd(rctx->src, req->src, req->assoclen);\n\tdst = src;\n\tif (req->src != req->dst)\n\t\tdst = scatterwalk_ffwd(rctx->dst, req->dst, req->assoclen);\n\n\tskcipher_request_set_callback(&creq->req, rctx->flags,\n\t\t\t\t      chacha_encrypt_done, req);\n\tskcipher_request_set_tfm(&creq->req, ctx->chacha);\n\tskcipher_request_set_crypt(&creq->req, src, dst,\n\t\t\t\t   req->cryptlen, creq->iv);\n\terr = crypto_skcipher_encrypt(&creq->req);\n\tif (err)\n\t\treturn err;\n\nskip:\n\treturn poly_genkey(req);\n}\n\nstatic int chachapoly_encrypt(struct aead_request *req)\n{\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\n\trctx->cryptlen = req->cryptlen;\n\trctx->flags = aead_request_flags(req);\n\n\t \n\treturn chacha_encrypt(req);\n}\n\nstatic int chachapoly_decrypt(struct aead_request *req)\n{\n\tstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\n\n\trctx->cryptlen = req->cryptlen - POLY1305_DIGEST_SIZE;\n\trctx->flags = aead_request_flags(req);\n\n\t \n\treturn poly_genkey(req);\n}\n\nstatic int chachapoly_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(aead);\n\n\tif (keylen != ctx->saltlen + CHACHA_KEY_SIZE)\n\t\treturn -EINVAL;\n\n\tkeylen -= ctx->saltlen;\n\tmemcpy(ctx->salt, key + keylen, ctx->saltlen);\n\n\tcrypto_skcipher_clear_flags(ctx->chacha, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(ctx->chacha, crypto_aead_get_flags(aead) &\n\t\t\t\t\t       CRYPTO_TFM_REQ_MASK);\n\treturn crypto_skcipher_setkey(ctx->chacha, key, keylen);\n}\n\nstatic int chachapoly_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t  unsigned int authsize)\n{\n\tif (authsize != POLY1305_DIGEST_SIZE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int chachapoly_init(struct crypto_aead *tfm)\n{\n\tstruct aead_instance *inst = aead_alg_instance(tfm);\n\tstruct chachapoly_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_skcipher *chacha;\n\tstruct crypto_ahash *poly;\n\tunsigned long align;\n\n\tpoly = crypto_spawn_ahash(&ictx->poly);\n\tif (IS_ERR(poly))\n\t\treturn PTR_ERR(poly);\n\n\tchacha = crypto_spawn_skcipher(&ictx->chacha);\n\tif (IS_ERR(chacha)) {\n\t\tcrypto_free_ahash(poly);\n\t\treturn PTR_ERR(chacha);\n\t}\n\n\tctx->chacha = chacha;\n\tctx->poly = poly;\n\tctx->saltlen = ictx->saltlen;\n\n\talign = crypto_aead_alignmask(tfm);\n\talign &= ~(crypto_tfm_ctx_alignment() - 1);\n\tcrypto_aead_set_reqsize(\n\t\ttfm,\n\t\talign + offsetof(struct chachapoly_req_ctx, u) +\n\t\tmax(offsetof(struct chacha_req, req) +\n\t\t    sizeof(struct skcipher_request) +\n\t\t    crypto_skcipher_reqsize(chacha),\n\t\t    offsetof(struct poly_req, req) +\n\t\t    sizeof(struct ahash_request) +\n\t\t    crypto_ahash_reqsize(poly)));\n\n\treturn 0;\n}\n\nstatic void chachapoly_exit(struct crypto_aead *tfm)\n{\n\tstruct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_ahash(ctx->poly);\n\tcrypto_free_skcipher(ctx->chacha);\n}\n\nstatic void chachapoly_free(struct aead_instance *inst)\n{\n\tstruct chachapoly_instance_ctx *ctx = aead_instance_ctx(inst);\n\n\tcrypto_drop_skcipher(&ctx->chacha);\n\tcrypto_drop_ahash(&ctx->poly);\n\tkfree(inst);\n}\n\nstatic int chachapoly_create(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t     const char *name, unsigned int ivsize)\n{\n\tu32 mask;\n\tstruct aead_instance *inst;\n\tstruct chachapoly_instance_ctx *ctx;\n\tstruct skcipher_alg *chacha;\n\tstruct hash_alg_common *poly;\n\tint err;\n\n\tif (ivsize > CHACHAPOLY_IV_SIZE)\n\t\treturn -EINVAL;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_AEAD, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tctx = aead_instance_ctx(inst);\n\tctx->saltlen = CHACHAPOLY_IV_SIZE - ivsize;\n\n\terr = crypto_grab_skcipher(&ctx->chacha, aead_crypto_instance(inst),\n\t\t\t\t   crypto_attr_alg_name(tb[1]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\tchacha = crypto_spawn_skcipher_alg(&ctx->chacha);\n\n\terr = crypto_grab_ahash(&ctx->poly, aead_crypto_instance(inst),\n\t\t\t\tcrypto_attr_alg_name(tb[2]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\tpoly = crypto_spawn_ahash_alg(&ctx->poly);\n\n\terr = -EINVAL;\n\tif (poly->digestsize != POLY1305_DIGEST_SIZE)\n\t\tgoto err_free_inst;\n\t \n\tif (crypto_skcipher_alg_ivsize(chacha) != CHACHA_IV_SIZE)\n\t\tgoto err_free_inst;\n\t \n\tif (chacha->base.cra_blocksize != 1)\n\t\tgoto err_free_inst;\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"%s(%s,%s)\", name, chacha->base.cra_name,\n\t\t     poly->base.cra_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_free_inst;\n\tif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"%s(%s,%s)\", name, chacha->base.cra_driver_name,\n\t\t     poly->base.cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_free_inst;\n\n\tinst->alg.base.cra_priority = (chacha->base.cra_priority +\n\t\t\t\t       poly->base.cra_priority) / 2;\n\tinst->alg.base.cra_blocksize = 1;\n\tinst->alg.base.cra_alignmask = chacha->base.cra_alignmask |\n\t\t\t\t       poly->base.cra_alignmask;\n\tinst->alg.base.cra_ctxsize = sizeof(struct chachapoly_ctx) +\n\t\t\t\t     ctx->saltlen;\n\tinst->alg.ivsize = ivsize;\n\tinst->alg.chunksize = crypto_skcipher_alg_chunksize(chacha);\n\tinst->alg.maxauthsize = POLY1305_DIGEST_SIZE;\n\tinst->alg.init = chachapoly_init;\n\tinst->alg.exit = chachapoly_exit;\n\tinst->alg.encrypt = chachapoly_encrypt;\n\tinst->alg.decrypt = chachapoly_decrypt;\n\tinst->alg.setkey = chachapoly_setkey;\n\tinst->alg.setauthsize = chachapoly_setauthsize;\n\n\tinst->free = chachapoly_free;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tchachapoly_free(inst);\n\t}\n\treturn err;\n}\n\nstatic int rfc7539_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\treturn chachapoly_create(tmpl, tb, \"rfc7539\", 12);\n}\n\nstatic int rfc7539esp_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\treturn chachapoly_create(tmpl, tb, \"rfc7539esp\", 8);\n}\n\nstatic struct crypto_template rfc7539_tmpls[] = {\n\t{\n\t\t.name = \"rfc7539\",\n\t\t.create = rfc7539_create,\n\t\t.module = THIS_MODULE,\n\t}, {\n\t\t.name = \"rfc7539esp\",\n\t\t.create = rfc7539esp_create,\n\t\t.module = THIS_MODULE,\n\t},\n};\n\nstatic int __init chacha20poly1305_module_init(void)\n{\n\treturn crypto_register_templates(rfc7539_tmpls,\n\t\t\t\t\t ARRAY_SIZE(rfc7539_tmpls));\n}\n\nstatic void __exit chacha20poly1305_module_exit(void)\n{\n\tcrypto_unregister_templates(rfc7539_tmpls,\n\t\t\t\t    ARRAY_SIZE(rfc7539_tmpls));\n}\n\nsubsys_initcall(chacha20poly1305_module_init);\nmodule_exit(chacha20poly1305_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Martin Willi <martin@strongswan.org>\");\nMODULE_DESCRIPTION(\"ChaCha20-Poly1305 AEAD\");\nMODULE_ALIAS_CRYPTO(\"rfc7539\");\nMODULE_ALIAS_CRYPTO(\"rfc7539esp\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}