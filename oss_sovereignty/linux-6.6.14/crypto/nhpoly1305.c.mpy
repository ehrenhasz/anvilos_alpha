{
  "module_name": "nhpoly1305.c",
  "hash_id": "43d96798fd519417ebb97cc015ae2f5503b6bdf1bf7c0b3cf29a8a818113458b",
  "original_prompt": "Ingested from linux-6.6.14/crypto/nhpoly1305.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/unaligned.h>\n#include <crypto/algapi.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/poly1305.h>\n#include <crypto/nhpoly1305.h>\n#include <linux/crypto.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void nh_generic(const u32 *key, const u8 *message, size_t message_len,\n\t\t       __le64 hash[NH_NUM_PASSES])\n{\n\tu64 sums[4] = { 0, 0, 0, 0 };\n\n\tBUILD_BUG_ON(NH_PAIR_STRIDE != 2);\n\tBUILD_BUG_ON(NH_NUM_PASSES != 4);\n\n\twhile (message_len) {\n\t\tu32 m0 = get_unaligned_le32(message + 0);\n\t\tu32 m1 = get_unaligned_le32(message + 4);\n\t\tu32 m2 = get_unaligned_le32(message + 8);\n\t\tu32 m3 = get_unaligned_le32(message + 12);\n\n\t\tsums[0] += (u64)(u32)(m0 + key[ 0]) * (u32)(m2 + key[ 2]);\n\t\tsums[1] += (u64)(u32)(m0 + key[ 4]) * (u32)(m2 + key[ 6]);\n\t\tsums[2] += (u64)(u32)(m0 + key[ 8]) * (u32)(m2 + key[10]);\n\t\tsums[3] += (u64)(u32)(m0 + key[12]) * (u32)(m2 + key[14]);\n\t\tsums[0] += (u64)(u32)(m1 + key[ 1]) * (u32)(m3 + key[ 3]);\n\t\tsums[1] += (u64)(u32)(m1 + key[ 5]) * (u32)(m3 + key[ 7]);\n\t\tsums[2] += (u64)(u32)(m1 + key[ 9]) * (u32)(m3 + key[11]);\n\t\tsums[3] += (u64)(u32)(m1 + key[13]) * (u32)(m3 + key[15]);\n\t\tkey += NH_MESSAGE_UNIT / sizeof(key[0]);\n\t\tmessage += NH_MESSAGE_UNIT;\n\t\tmessage_len -= NH_MESSAGE_UNIT;\n\t}\n\n\thash[0] = cpu_to_le64(sums[0]);\n\thash[1] = cpu_to_le64(sums[1]);\n\thash[2] = cpu_to_le64(sums[2]);\n\thash[3] = cpu_to_le64(sums[3]);\n}\n\n \nstatic void process_nh_hash_value(struct nhpoly1305_state *state,\n\t\t\t\t  const struct nhpoly1305_key *key)\n{\n\tBUILD_BUG_ON(NH_HASH_BYTES % POLY1305_BLOCK_SIZE != 0);\n\n\tpoly1305_core_blocks(&state->poly_state, &key->poly_key, state->nh_hash,\n\t\t\t     NH_HASH_BYTES / POLY1305_BLOCK_SIZE, 1);\n}\n\n \nstatic void nhpoly1305_units(struct nhpoly1305_state *state,\n\t\t\t     const struct nhpoly1305_key *key,\n\t\t\t     const u8 *src, unsigned int srclen, nh_t nh_fn)\n{\n\tdo {\n\t\tunsigned int bytes;\n\n\t\tif (state->nh_remaining == 0) {\n\t\t\t \n\t\t\tbytes = min_t(unsigned int, srclen, NH_MESSAGE_BYTES);\n\t\t\tnh_fn(key->nh_key, src, bytes, state->nh_hash);\n\t\t\tstate->nh_remaining = NH_MESSAGE_BYTES - bytes;\n\t\t} else {\n\t\t\t \n\t\t\t__le64 tmp_hash[NH_NUM_PASSES];\n\t\t\tunsigned int pos;\n\t\t\tint i;\n\n\t\t\tpos = NH_MESSAGE_BYTES - state->nh_remaining;\n\t\t\tbytes = min(srclen, state->nh_remaining);\n\t\t\tnh_fn(&key->nh_key[pos / 4], src, bytes, tmp_hash);\n\t\t\tfor (i = 0; i < NH_NUM_PASSES; i++)\n\t\t\t\tle64_add_cpu(&state->nh_hash[i],\n\t\t\t\t\t     le64_to_cpu(tmp_hash[i]));\n\t\t\tstate->nh_remaining -= bytes;\n\t\t}\n\t\tif (state->nh_remaining == 0)\n\t\t\tprocess_nh_hash_value(state, key);\n\t\tsrc += bytes;\n\t\tsrclen -= bytes;\n\t} while (srclen);\n}\n\nint crypto_nhpoly1305_setkey(struct crypto_shash *tfm,\n\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tstruct nhpoly1305_key *ctx = crypto_shash_ctx(tfm);\n\tint i;\n\n\tif (keylen != NHPOLY1305_KEY_SIZE)\n\t\treturn -EINVAL;\n\n\tpoly1305_core_setkey(&ctx->poly_key, key);\n\tkey += POLY1305_BLOCK_SIZE;\n\n\tfor (i = 0; i < NH_KEY_WORDS; i++)\n\t\tctx->nh_key[i] = get_unaligned_le32(key + i * sizeof(u32));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(crypto_nhpoly1305_setkey);\n\nint crypto_nhpoly1305_init(struct shash_desc *desc)\n{\n\tstruct nhpoly1305_state *state = shash_desc_ctx(desc);\n\n\tpoly1305_core_init(&state->poly_state);\n\tstate->buflen = 0;\n\tstate->nh_remaining = 0;\n\treturn 0;\n}\nEXPORT_SYMBOL(crypto_nhpoly1305_init);\n\nint crypto_nhpoly1305_update_helper(struct shash_desc *desc,\n\t\t\t\t    const u8 *src, unsigned int srclen,\n\t\t\t\t    nh_t nh_fn)\n{\n\tstruct nhpoly1305_state *state = shash_desc_ctx(desc);\n\tconst struct nhpoly1305_key *key = crypto_shash_ctx(desc->tfm);\n\tunsigned int bytes;\n\n\tif (state->buflen) {\n\t\tbytes = min(srclen, (int)NH_MESSAGE_UNIT - state->buflen);\n\t\tmemcpy(&state->buffer[state->buflen], src, bytes);\n\t\tstate->buflen += bytes;\n\t\tif (state->buflen < NH_MESSAGE_UNIT)\n\t\t\treturn 0;\n\t\tnhpoly1305_units(state, key, state->buffer, NH_MESSAGE_UNIT,\n\t\t\t\t nh_fn);\n\t\tstate->buflen = 0;\n\t\tsrc += bytes;\n\t\tsrclen -= bytes;\n\t}\n\n\tif (srclen >= NH_MESSAGE_UNIT) {\n\t\tbytes = round_down(srclen, NH_MESSAGE_UNIT);\n\t\tnhpoly1305_units(state, key, src, bytes, nh_fn);\n\t\tsrc += bytes;\n\t\tsrclen -= bytes;\n\t}\n\n\tif (srclen) {\n\t\tmemcpy(state->buffer, src, srclen);\n\t\tstate->buflen = srclen;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(crypto_nhpoly1305_update_helper);\n\nint crypto_nhpoly1305_update(struct shash_desc *desc,\n\t\t\t     const u8 *src, unsigned int srclen)\n{\n\treturn crypto_nhpoly1305_update_helper(desc, src, srclen, nh_generic);\n}\nEXPORT_SYMBOL(crypto_nhpoly1305_update);\n\nint crypto_nhpoly1305_final_helper(struct shash_desc *desc, u8 *dst, nh_t nh_fn)\n{\n\tstruct nhpoly1305_state *state = shash_desc_ctx(desc);\n\tconst struct nhpoly1305_key *key = crypto_shash_ctx(desc->tfm);\n\n\tif (state->buflen) {\n\t\tmemset(&state->buffer[state->buflen], 0,\n\t\t       NH_MESSAGE_UNIT - state->buflen);\n\t\tnhpoly1305_units(state, key, state->buffer, NH_MESSAGE_UNIT,\n\t\t\t\t nh_fn);\n\t}\n\n\tif (state->nh_remaining)\n\t\tprocess_nh_hash_value(state, key);\n\n\tpoly1305_core_emit(&state->poly_state, NULL, dst);\n\treturn 0;\n}\nEXPORT_SYMBOL(crypto_nhpoly1305_final_helper);\n\nint crypto_nhpoly1305_final(struct shash_desc *desc, u8 *dst)\n{\n\treturn crypto_nhpoly1305_final_helper(desc, dst, nh_generic);\n}\nEXPORT_SYMBOL(crypto_nhpoly1305_final);\n\nstatic struct shash_alg nhpoly1305_alg = {\n\t.base.cra_name\t\t= \"nhpoly1305\",\n\t.base.cra_driver_name\t= \"nhpoly1305-generic\",\n\t.base.cra_priority\t= 100,\n\t.base.cra_ctxsize\t= sizeof(struct nhpoly1305_key),\n\t.base.cra_module\t= THIS_MODULE,\n\t.digestsize\t\t= POLY1305_DIGEST_SIZE,\n\t.init\t\t\t= crypto_nhpoly1305_init,\n\t.update\t\t\t= crypto_nhpoly1305_update,\n\t.final\t\t\t= crypto_nhpoly1305_final,\n\t.setkey\t\t\t= crypto_nhpoly1305_setkey,\n\t.descsize\t\t= sizeof(struct nhpoly1305_state),\n};\n\nstatic int __init nhpoly1305_mod_init(void)\n{\n\treturn crypto_register_shash(&nhpoly1305_alg);\n}\n\nstatic void __exit nhpoly1305_mod_exit(void)\n{\n\tcrypto_unregister_shash(&nhpoly1305_alg);\n}\n\nsubsys_initcall(nhpoly1305_mod_init);\nmodule_exit(nhpoly1305_mod_exit);\n\nMODULE_DESCRIPTION(\"NHPoly1305 \u03b5-almost-\u2206-universal hash function\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Eric Biggers <ebiggers@google.com>\");\nMODULE_ALIAS_CRYPTO(\"nhpoly1305\");\nMODULE_ALIAS_CRYPTO(\"nhpoly1305-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}