{
  "module_name": "ccm.c",
  "hash_id": "cf7835b77e24449b9584b9329808a73baeb1fa0025452e200dace232cd45f38b",
  "original_prompt": "Ingested from linux-6.6.14/crypto/ccm.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/aead.h>\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstruct ccm_instance_ctx {\n\tstruct crypto_skcipher_spawn ctr;\n\tstruct crypto_ahash_spawn mac;\n};\n\nstruct crypto_ccm_ctx {\n\tstruct crypto_ahash *mac;\n\tstruct crypto_skcipher *ctr;\n};\n\nstruct crypto_rfc4309_ctx {\n\tstruct crypto_aead *child;\n\tu8 nonce[3];\n};\n\nstruct crypto_rfc4309_req_ctx {\n\tstruct scatterlist src[3];\n\tstruct scatterlist dst[3];\n\tstruct aead_request subreq;\n};\n\nstruct crypto_ccm_req_priv_ctx {\n\tu8 odata[16];\n\tu8 idata[16];\n\tu8 auth_tag[16];\n\tu32 flags;\n\tstruct scatterlist src[3];\n\tstruct scatterlist dst[3];\n\tunion {\n\t\tstruct ahash_request ahreq;\n\t\tstruct skcipher_request skreq;\n\t};\n};\n\nstruct cbcmac_tfm_ctx {\n\tstruct crypto_cipher *child;\n};\n\nstruct cbcmac_desc_ctx {\n\tunsigned int len;\n};\n\nstatic inline struct crypto_ccm_req_priv_ctx *crypto_ccm_reqctx(\n\tstruct aead_request *req)\n{\n\tunsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));\n\n\treturn (void *)PTR_ALIGN((u8 *)aead_request_ctx(req), align + 1);\n}\n\nstatic int set_msg_len(u8 *block, unsigned int msglen, int csize)\n{\n\t__be32 data;\n\n\tmemset(block, 0, csize);\n\tblock += csize;\n\n\tif (csize >= 4)\n\t\tcsize = 4;\n\telse if (msglen > (1 << (8 * csize)))\n\t\treturn -EOVERFLOW;\n\n\tdata = cpu_to_be32(msglen);\n\tmemcpy(block - csize, (u8 *)&data + 4 - csize, csize);\n\n\treturn 0;\n}\n\nstatic int crypto_ccm_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_skcipher *ctr = ctx->ctr;\n\tstruct crypto_ahash *mac = ctx->mac;\n\tint err;\n\n\tcrypto_skcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &\n\t\t\t\t       CRYPTO_TFM_REQ_MASK);\n\terr = crypto_skcipher_setkey(ctr, key, keylen);\n\tif (err)\n\t\treturn err;\n\n\tcrypto_ahash_clear_flags(mac, CRYPTO_TFM_REQ_MASK);\n\tcrypto_ahash_set_flags(mac, crypto_aead_get_flags(aead) &\n\t\t\t\t    CRYPTO_TFM_REQ_MASK);\n\treturn crypto_ahash_setkey(mac, key, keylen);\n}\n\nstatic int crypto_ccm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t  unsigned int authsize)\n{\n\tswitch (authsize) {\n\tcase 4:\n\tcase 6:\n\tcase 8:\n\tcase 10:\n\tcase 12:\n\tcase 14:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int format_input(u8 *info, struct aead_request *req,\n\t\t\tunsigned int cryptlen)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tunsigned int lp = req->iv[0];\n\tunsigned int l = lp + 1;\n\tunsigned int m;\n\n\tm = crypto_aead_authsize(aead);\n\n\tmemcpy(info, req->iv, 16);\n\n\t \n\t*info |= (8 * ((m - 2) / 2));\n\tif (req->assoclen)\n\t\t*info |= 64;\n\n\treturn set_msg_len(info + 16 - l, cryptlen, l);\n}\n\nstatic int format_adata(u8 *adata, unsigned int a)\n{\n\tint len = 0;\n\n\t \n\tif (a < 65280) {\n\t\t*(__be16 *)adata = cpu_to_be16(a);\n\t\tlen = 2;\n\t} else  {\n\t\t*(__be16 *)adata = cpu_to_be16(0xfffe);\n\t\t*(__be32 *)&adata[2] = cpu_to_be32(a);\n\t\tlen = 6;\n\t}\n\n\treturn len;\n}\n\nstatic int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct ahash_request *ahreq = &pctx->ahreq;\n\tunsigned int assoclen = req->assoclen;\n\tstruct scatterlist sg[3];\n\tu8 *odata = pctx->odata;\n\tu8 *idata = pctx->idata;\n\tint ilen, err;\n\n\t \n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\n\t \n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\n\tahash_request_set_crypt(ahreq, plain, odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}\n\nstatic void crypto_ccm_encrypt_done(void *data, int err)\n{\n\tstruct aead_request *req = data;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tu8 *odata = pctx->odata;\n\n\tif (!err)\n\t\tscatterwalk_map_and_copy(odata, req->dst,\n\t\t\t\t\t req->assoclen + req->cryptlen,\n\t\t\t\t\t crypto_aead_authsize(aead), 1);\n\taead_request_complete(req, err);\n}\n\nstatic inline int crypto_ccm_check_iv(const u8 *iv)\n{\n\t \n\tif (1 > iv[0] || iv[0] > 7)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int crypto_ccm_init_crypt(struct aead_request *req, u8 *tag)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct scatterlist *sg;\n\tu8 *iv = req->iv;\n\tint err;\n\n\terr = crypto_ccm_check_iv(iv);\n\tif (err)\n\t\treturn err;\n\n\tpctx->flags = aead_request_flags(req);\n\n\t  \n\tmemset(iv + 15 - iv[0], 0, iv[0] + 1);\n\n\tsg_init_table(pctx->src, 3);\n\tsg_set_buf(pctx->src, tag, 16);\n\tsg = scatterwalk_ffwd(pctx->src + 1, req->src, req->assoclen);\n\tif (sg != pctx->src + 1)\n\t\tsg_chain(pctx->src, 2, sg);\n\n\tif (req->src != req->dst) {\n\t\tsg_init_table(pctx->dst, 3);\n\t\tsg_set_buf(pctx->dst, tag, 16);\n\t\tsg = scatterwalk_ffwd(pctx->dst + 1, req->dst, req->assoclen);\n\t\tif (sg != pctx->dst + 1)\n\t\t\tsg_chain(pctx->dst, 2, sg);\n\t}\n\n\treturn 0;\n}\n\nstatic int crypto_ccm_encrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct skcipher_request *skreq = &pctx->skreq;\n\tstruct scatterlist *dst;\n\tunsigned int cryptlen = req->cryptlen;\n\tu8 *odata = pctx->odata;\n\tu8 *iv = req->iv;\n\tint err;\n\n\terr = crypto_ccm_init_crypt(req, odata);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_ccm_auth(req, sg_next(pctx->src), cryptlen);\n\tif (err)\n\t\treturn err;\n\n\tdst = pctx->src;\n\tif (req->src != req->dst)\n\t\tdst = pctx->dst;\n\n\tskcipher_request_set_tfm(skreq, ctx->ctr);\n\tskcipher_request_set_callback(skreq, pctx->flags,\n\t\t\t\t      crypto_ccm_encrypt_done, req);\n\tskcipher_request_set_crypt(skreq, pctx->src, dst, cryptlen + 16, iv);\n\terr = crypto_skcipher_encrypt(skreq);\n\tif (err)\n\t\treturn err;\n\n\t \n\tscatterwalk_map_and_copy(odata, sg_next(dst), cryptlen,\n\t\t\t\t crypto_aead_authsize(aead), 1);\n\treturn err;\n}\n\nstatic void crypto_ccm_decrypt_done(void *data, int err)\n{\n\tstruct aead_request *req = data;\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tunsigned int authsize = crypto_aead_authsize(aead);\n\tunsigned int cryptlen = req->cryptlen - authsize;\n\tstruct scatterlist *dst;\n\n\tpctx->flags = 0;\n\n\tdst = sg_next(req->src == req->dst ? pctx->src : pctx->dst);\n\n\tif (!err) {\n\t\terr = crypto_ccm_auth(req, dst, cryptlen);\n\t\tif (!err && crypto_memneq(pctx->auth_tag, pctx->odata, authsize))\n\t\t\terr = -EBADMSG;\n\t}\n\taead_request_complete(req, err);\n}\n\nstatic int crypto_ccm_decrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct skcipher_request *skreq = &pctx->skreq;\n\tstruct scatterlist *dst;\n\tunsigned int authsize = crypto_aead_authsize(aead);\n\tunsigned int cryptlen = req->cryptlen;\n\tu8 *authtag = pctx->auth_tag;\n\tu8 *odata = pctx->odata;\n\tu8 *iv = pctx->idata;\n\tint err;\n\n\tcryptlen -= authsize;\n\n\terr = crypto_ccm_init_crypt(req, authtag);\n\tif (err)\n\t\treturn err;\n\n\tscatterwalk_map_and_copy(authtag, sg_next(pctx->src), cryptlen,\n\t\t\t\t authsize, 0);\n\n\tdst = pctx->src;\n\tif (req->src != req->dst)\n\t\tdst = pctx->dst;\n\n\tmemcpy(iv, req->iv, 16);\n\n\tskcipher_request_set_tfm(skreq, ctx->ctr);\n\tskcipher_request_set_callback(skreq, pctx->flags,\n\t\t\t\t      crypto_ccm_decrypt_done, req);\n\tskcipher_request_set_crypt(skreq, pctx->src, dst, cryptlen + 16, iv);\n\terr = crypto_skcipher_decrypt(skreq);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_ccm_auth(req, sg_next(dst), cryptlen);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (crypto_memneq(authtag, odata, authsize))\n\t\treturn -EBADMSG;\n\n\treturn err;\n}\n\nstatic int crypto_ccm_init_tfm(struct crypto_aead *tfm)\n{\n\tstruct aead_instance *inst = aead_alg_instance(tfm);\n\tstruct ccm_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_ahash *mac;\n\tstruct crypto_skcipher *ctr;\n\tunsigned long align;\n\tint err;\n\n\tmac = crypto_spawn_ahash(&ictx->mac);\n\tif (IS_ERR(mac))\n\t\treturn PTR_ERR(mac);\n\n\tctr = crypto_spawn_skcipher(&ictx->ctr);\n\terr = PTR_ERR(ctr);\n\tif (IS_ERR(ctr))\n\t\tgoto err_free_mac;\n\n\tctx->mac = mac;\n\tctx->ctr = ctr;\n\n\talign = crypto_aead_alignmask(tfm);\n\talign &= ~(crypto_tfm_ctx_alignment() - 1);\n\tcrypto_aead_set_reqsize(\n\t\ttfm,\n\t\talign + sizeof(struct crypto_ccm_req_priv_ctx) +\n\t\tmax(crypto_ahash_reqsize(mac), crypto_skcipher_reqsize(ctr)));\n\n\treturn 0;\n\nerr_free_mac:\n\tcrypto_free_ahash(mac);\n\treturn err;\n}\n\nstatic void crypto_ccm_exit_tfm(struct crypto_aead *tfm)\n{\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_ahash(ctx->mac);\n\tcrypto_free_skcipher(ctx->ctr);\n}\n\nstatic void crypto_ccm_free(struct aead_instance *inst)\n{\n\tstruct ccm_instance_ctx *ctx = aead_instance_ctx(inst);\n\n\tcrypto_drop_ahash(&ctx->mac);\n\tcrypto_drop_skcipher(&ctx->ctr);\n\tkfree(inst);\n}\n\nstatic int crypto_ccm_create_common(struct crypto_template *tmpl,\n\t\t\t\t    struct rtattr **tb,\n\t\t\t\t    const char *ctr_name,\n\t\t\t\t    const char *mac_name)\n{\n\tu32 mask;\n\tstruct aead_instance *inst;\n\tstruct ccm_instance_ctx *ictx;\n\tstruct skcipher_alg *ctr;\n\tstruct hash_alg_common *mac;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_AEAD, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ictx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tictx = aead_instance_ctx(inst);\n\n\terr = crypto_grab_ahash(&ictx->mac, aead_crypto_instance(inst),\n\t\t\t\tmac_name, 0, mask | CRYPTO_ALG_ASYNC);\n\tif (err)\n\t\tgoto err_free_inst;\n\tmac = crypto_spawn_ahash_alg(&ictx->mac);\n\n\terr = -EINVAL;\n\tif (strncmp(mac->base.cra_name, \"cbcmac(\", 7) != 0 ||\n\t    mac->digestsize != 16)\n\t\tgoto err_free_inst;\n\n\terr = crypto_grab_skcipher(&ictx->ctr, aead_crypto_instance(inst),\n\t\t\t\t   ctr_name, 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\tctr = crypto_spawn_skcipher_alg(&ictx->ctr);\n\n\t \n\terr = -EINVAL;\n\tif (strncmp(ctr->base.cra_name, \"ctr(\", 4) != 0 ||\n\t    crypto_skcipher_alg_ivsize(ctr) != 16 ||\n\t    ctr->base.cra_blocksize != 1)\n\t\tgoto err_free_inst;\n\n\t \n\tif (strcmp(ctr->base.cra_name + 4, mac->base.cra_name + 7) != 0)\n\t\tgoto err_free_inst;\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"ccm(%s\", ctr->base.cra_name + 4) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_free_inst;\n\n\tif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"ccm_base(%s,%s)\", ctr->base.cra_driver_name,\n\t\t     mac->base.cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_free_inst;\n\n\tinst->alg.base.cra_priority = (mac->base.cra_priority +\n\t\t\t\t       ctr->base.cra_priority) / 2;\n\tinst->alg.base.cra_blocksize = 1;\n\tinst->alg.base.cra_alignmask = mac->base.cra_alignmask |\n\t\t\t\t       ctr->base.cra_alignmask;\n\tinst->alg.ivsize = 16;\n\tinst->alg.chunksize = crypto_skcipher_alg_chunksize(ctr);\n\tinst->alg.maxauthsize = 16;\n\tinst->alg.base.cra_ctxsize = sizeof(struct crypto_ccm_ctx);\n\tinst->alg.init = crypto_ccm_init_tfm;\n\tinst->alg.exit = crypto_ccm_exit_tfm;\n\tinst->alg.setkey = crypto_ccm_setkey;\n\tinst->alg.setauthsize = crypto_ccm_setauthsize;\n\tinst->alg.encrypt = crypto_ccm_encrypt;\n\tinst->alg.decrypt = crypto_ccm_decrypt;\n\n\tinst->free = crypto_ccm_free;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tcrypto_ccm_free(inst);\n\t}\n\treturn err;\n}\n\nstatic int crypto_ccm_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tconst char *cipher_name;\n\tchar ctr_name[CRYPTO_MAX_ALG_NAME];\n\tchar mac_name[CRYPTO_MAX_ALG_NAME];\n\n\tcipher_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(cipher_name))\n\t\treturn PTR_ERR(cipher_name);\n\n\tif (snprintf(ctr_name, CRYPTO_MAX_ALG_NAME, \"ctr(%s)\",\n\t\t     cipher_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\tif (snprintf(mac_name, CRYPTO_MAX_ALG_NAME, \"cbcmac(%s)\",\n\t\t     cipher_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\treturn crypto_ccm_create_common(tmpl, tb, ctr_name, mac_name);\n}\n\nstatic int crypto_ccm_base_create(struct crypto_template *tmpl,\n\t\t\t\t  struct rtattr **tb)\n{\n\tconst char *ctr_name;\n\tconst char *mac_name;\n\n\tctr_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(ctr_name))\n\t\treturn PTR_ERR(ctr_name);\n\n\tmac_name = crypto_attr_alg_name(tb[2]);\n\tif (IS_ERR(mac_name))\n\t\treturn PTR_ERR(mac_name);\n\n\treturn crypto_ccm_create_common(tmpl, tb, ctr_name, mac_name);\n}\n\nstatic int crypto_rfc4309_setkey(struct crypto_aead *parent, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\n\tstruct crypto_aead *child = ctx->child;\n\n\tif (keylen < 3)\n\t\treturn -EINVAL;\n\n\tkeylen -= 3;\n\tmemcpy(ctx->nonce, key + keylen, 3);\n\n\tcrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\n\tcrypto_aead_set_flags(child, crypto_aead_get_flags(parent) &\n\t\t\t\t     CRYPTO_TFM_REQ_MASK);\n\treturn crypto_aead_setkey(child, key, keylen);\n}\n\nstatic int crypto_rfc4309_setauthsize(struct crypto_aead *parent,\n\t\t\t\t      unsigned int authsize)\n{\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\n\n\tswitch (authsize) {\n\tcase 8:\n\tcase 12:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn crypto_aead_setauthsize(ctx->child, authsize);\n}\n\nstatic struct aead_request *crypto_rfc4309_crypt(struct aead_request *req)\n{\n\tstruct crypto_rfc4309_req_ctx *rctx = aead_request_ctx(req);\n\tstruct aead_request *subreq = &rctx->subreq;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_aead *child = ctx->child;\n\tstruct scatterlist *sg;\n\tu8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),\n\t\t\t   crypto_aead_alignmask(child) + 1);\n\n\t \n\tiv[0] = 3;\n\n\tmemcpy(iv + 1, ctx->nonce, 3);\n\tmemcpy(iv + 4, req->iv, 8);\n\n\tscatterwalk_map_and_copy(iv + 16, req->src, 0, req->assoclen - 8, 0);\n\n\tsg_init_table(rctx->src, 3);\n\tsg_set_buf(rctx->src, iv + 16, req->assoclen - 8);\n\tsg = scatterwalk_ffwd(rctx->src + 1, req->src, req->assoclen);\n\tif (sg != rctx->src + 1)\n\t\tsg_chain(rctx->src, 2, sg);\n\n\tif (req->src != req->dst) {\n\t\tsg_init_table(rctx->dst, 3);\n\t\tsg_set_buf(rctx->dst, iv + 16, req->assoclen - 8);\n\t\tsg = scatterwalk_ffwd(rctx->dst + 1, req->dst, req->assoclen);\n\t\tif (sg != rctx->dst + 1)\n\t\t\tsg_chain(rctx->dst, 2, sg);\n\t}\n\n\taead_request_set_tfm(subreq, child);\n\taead_request_set_callback(subreq, req->base.flags, req->base.complete,\n\t\t\t\t  req->base.data);\n\taead_request_set_crypt(subreq, rctx->src,\n\t\t\t       req->src == req->dst ? rctx->src : rctx->dst,\n\t\t\t       req->cryptlen, iv);\n\taead_request_set_ad(subreq, req->assoclen - 8);\n\n\treturn subreq;\n}\n\nstatic int crypto_rfc4309_encrypt(struct aead_request *req)\n{\n\tif (req->assoclen != 16 && req->assoclen != 20)\n\t\treturn -EINVAL;\n\n\treq = crypto_rfc4309_crypt(req);\n\n\treturn crypto_aead_encrypt(req);\n}\n\nstatic int crypto_rfc4309_decrypt(struct aead_request *req)\n{\n\tif (req->assoclen != 16 && req->assoclen != 20)\n\t\treturn -EINVAL;\n\n\treq = crypto_rfc4309_crypt(req);\n\n\treturn crypto_aead_decrypt(req);\n}\n\nstatic int crypto_rfc4309_init_tfm(struct crypto_aead *tfm)\n{\n\tstruct aead_instance *inst = aead_alg_instance(tfm);\n\tstruct crypto_aead_spawn *spawn = aead_instance_ctx(inst);\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_aead *aead;\n\tunsigned long align;\n\n\taead = crypto_spawn_aead(spawn);\n\tif (IS_ERR(aead))\n\t\treturn PTR_ERR(aead);\n\n\tctx->child = aead;\n\n\talign = crypto_aead_alignmask(aead);\n\talign &= ~(crypto_tfm_ctx_alignment() - 1);\n\tcrypto_aead_set_reqsize(\n\t\ttfm,\n\t\tsizeof(struct crypto_rfc4309_req_ctx) +\n\t\tALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +\n\t\talign + 32);\n\n\treturn 0;\n}\n\nstatic void crypto_rfc4309_exit_tfm(struct crypto_aead *tfm)\n{\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_aead(ctx->child);\n}\n\nstatic void crypto_rfc4309_free(struct aead_instance *inst)\n{\n\tcrypto_drop_aead(aead_instance_ctx(inst));\n\tkfree(inst);\n}\n\nstatic int crypto_rfc4309_create(struct crypto_template *tmpl,\n\t\t\t\t struct rtattr **tb)\n{\n\tu32 mask;\n\tstruct aead_instance *inst;\n\tstruct crypto_aead_spawn *spawn;\n\tstruct aead_alg *alg;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_AEAD, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tspawn = aead_instance_ctx(inst);\n\terr = crypto_grab_aead(spawn, aead_crypto_instance(inst),\n\t\t\t       crypto_attr_alg_name(tb[1]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\talg = crypto_spawn_aead_alg(spawn);\n\n\terr = -EINVAL;\n\n\t \n\tif (crypto_aead_alg_ivsize(alg) != 16)\n\t\tgoto err_free_inst;\n\n\t \n\tif (alg->base.cra_blocksize != 1)\n\t\tgoto err_free_inst;\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"rfc4309(%s)\", alg->base.cra_name) >=\n\t    CRYPTO_MAX_ALG_NAME ||\n\t    snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"rfc4309(%s)\", alg->base.cra_driver_name) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_free_inst;\n\n\tinst->alg.base.cra_priority = alg->base.cra_priority;\n\tinst->alg.base.cra_blocksize = 1;\n\tinst->alg.base.cra_alignmask = alg->base.cra_alignmask;\n\n\tinst->alg.ivsize = 8;\n\tinst->alg.chunksize = crypto_aead_alg_chunksize(alg);\n\tinst->alg.maxauthsize = 16;\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct crypto_rfc4309_ctx);\n\n\tinst->alg.init = crypto_rfc4309_init_tfm;\n\tinst->alg.exit = crypto_rfc4309_exit_tfm;\n\n\tinst->alg.setkey = crypto_rfc4309_setkey;\n\tinst->alg.setauthsize = crypto_rfc4309_setauthsize;\n\tinst->alg.encrypt = crypto_rfc4309_encrypt;\n\tinst->alg.decrypt = crypto_rfc4309_decrypt;\n\n\tinst->free = crypto_rfc4309_free;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tcrypto_rfc4309_free(inst);\n\t}\n\treturn err;\n}\n\nstatic int crypto_cbcmac_digest_setkey(struct crypto_shash *parent,\n\t\t\t\t     const u8 *inkey, unsigned int keylen)\n{\n\tstruct cbcmac_tfm_ctx *ctx = crypto_shash_ctx(parent);\n\n\treturn crypto_cipher_setkey(ctx->child, inkey, keylen);\n}\n\nstatic int crypto_cbcmac_digest_init(struct shash_desc *pdesc)\n{\n\tstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tint bs = crypto_shash_digestsize(pdesc->tfm);\n\tu8 *dg = (u8 *)ctx + crypto_shash_descsize(pdesc->tfm) - bs;\n\n\tctx->len = 0;\n\tmemset(dg, 0, bs);\n\n\treturn 0;\n}\n\nstatic int crypto_cbcmac_digest_update(struct shash_desc *pdesc, const u8 *p,\n\t\t\t\t       unsigned int len)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tstruct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_digestsize(parent);\n\tu8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;\n\n\twhile (len > 0) {\n\t\tunsigned int l = min(len, bs - ctx->len);\n\n\t\tcrypto_xor(dg + ctx->len, p, l);\n\t\tctx->len +=l;\n\t\tlen -= l;\n\t\tp += l;\n\n\t\tif (ctx->len == bs) {\n\t\t\tcrypto_cipher_encrypt_one(tfm, dg, dg);\n\t\t\tctx->len = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int crypto_cbcmac_digest_final(struct shash_desc *pdesc, u8 *out)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tstruct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_digestsize(parent);\n\tu8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;\n\n\tif (ctx->len)\n\t\tcrypto_cipher_encrypt_one(tfm, dg, dg);\n\n\tmemcpy(out, dg, bs);\n\treturn 0;\n}\n\nstatic int cbcmac_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_cipher *cipher;\n\tstruct crypto_instance *inst = (void *)tfm->__crt_alg;\n\tstruct crypto_cipher_spawn *spawn = crypto_instance_ctx(inst);\n\tstruct cbcmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tcipher = crypto_spawn_cipher(spawn);\n\tif (IS_ERR(cipher))\n\t\treturn PTR_ERR(cipher);\n\n\tctx->child = cipher;\n\n\treturn 0;\n};\n\nstatic void cbcmac_exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct cbcmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\tcrypto_free_cipher(ctx->child);\n}\n\nstatic int cbcmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_cipher_spawn *spawn;\n\tstruct crypto_alg *alg;\n\tu32 mask;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tspawn = shash_instance_ctx(inst);\n\n\terr = crypto_grab_cipher(spawn, shash_crypto_instance(inst),\n\t\t\t\t crypto_attr_alg_name(tb[1]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\talg = crypto_spawn_cipher_alg(spawn);\n\n\terr = crypto_inst_setname(shash_crypto_instance(inst), tmpl->name, alg);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = 1;\n\n\tinst->alg.digestsize = alg->cra_blocksize;\n\tinst->alg.descsize = ALIGN(sizeof(struct cbcmac_desc_ctx),\n\t\t\t\t   alg->cra_alignmask + 1) +\n\t\t\t     alg->cra_blocksize;\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct cbcmac_tfm_ctx);\n\tinst->alg.base.cra_init = cbcmac_init_tfm;\n\tinst->alg.base.cra_exit = cbcmac_exit_tfm;\n\n\tinst->alg.init = crypto_cbcmac_digest_init;\n\tinst->alg.update = crypto_cbcmac_digest_update;\n\tinst->alg.final = crypto_cbcmac_digest_final;\n\tinst->alg.setkey = crypto_cbcmac_digest_setkey;\n\n\tinst->free = shash_free_singlespawn_instance;\n\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tshash_free_singlespawn_instance(inst);\n\t}\n\treturn err;\n}\n\nstatic struct crypto_template crypto_ccm_tmpls[] = {\n\t{\n\t\t.name = \"cbcmac\",\n\t\t.create = cbcmac_create,\n\t\t.module = THIS_MODULE,\n\t}, {\n\t\t.name = \"ccm_base\",\n\t\t.create = crypto_ccm_base_create,\n\t\t.module = THIS_MODULE,\n\t}, {\n\t\t.name = \"ccm\",\n\t\t.create = crypto_ccm_create,\n\t\t.module = THIS_MODULE,\n\t}, {\n\t\t.name = \"rfc4309\",\n\t\t.create = crypto_rfc4309_create,\n\t\t.module = THIS_MODULE,\n\t},\n};\n\nstatic int __init crypto_ccm_module_init(void)\n{\n\treturn crypto_register_templates(crypto_ccm_tmpls,\n\t\t\t\t\t ARRAY_SIZE(crypto_ccm_tmpls));\n}\n\nstatic void __exit crypto_ccm_module_exit(void)\n{\n\tcrypto_unregister_templates(crypto_ccm_tmpls,\n\t\t\t\t    ARRAY_SIZE(crypto_ccm_tmpls));\n}\n\nsubsys_initcall(crypto_ccm_module_init);\nmodule_exit(crypto_ccm_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Counter with CBC MAC\");\nMODULE_ALIAS_CRYPTO(\"ccm_base\");\nMODULE_ALIAS_CRYPTO(\"rfc4309\");\nMODULE_ALIAS_CRYPTO(\"ccm\");\nMODULE_ALIAS_CRYPTO(\"cbcmac\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}