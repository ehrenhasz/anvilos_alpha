{
  "module_name": "des_generic.c",
  "hash_id": "1b3e488b6a26ee8e15d788c0125a5210e06a7d142617652b45e538477aa43628",
  "original_prompt": "Ingested from linux-6.6.14/crypto/des_generic.c",
  "human_readable_source": "\n \n\n#include <asm/byteorder.h>\n#include <crypto/algapi.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n\n#include <crypto/internal/des.h>\n\nstatic int des_setkey(struct crypto_tfm *tfm, const u8 *key,\n\t\t      unsigned int keylen)\n{\n\tstruct des_ctx *dctx = crypto_tfm_ctx(tfm);\n\tint err;\n\n\terr = des_expand_key(dctx, key, keylen);\n\tif (err == -ENOKEY) {\n\t\tif (crypto_tfm_get_flags(tfm) & CRYPTO_TFM_REQ_FORBID_WEAK_KEYS)\n\t\t\terr = -EINVAL;\n\t\telse\n\t\t\terr = 0;\n\t}\n\tif (err)\n\t\tmemset(dctx, 0, sizeof(*dctx));\n\treturn err;\n}\n\nstatic void crypto_des_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tconst struct des_ctx *dctx = crypto_tfm_ctx(tfm);\n\n\tdes_encrypt(dctx, dst, src);\n}\n\nstatic void crypto_des_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tconst struct des_ctx *dctx = crypto_tfm_ctx(tfm);\n\n\tdes_decrypt(dctx, dst, src);\n}\n\nstatic int des3_ede_setkey(struct crypto_tfm *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct des3_ede_ctx *dctx = crypto_tfm_ctx(tfm);\n\tint err;\n\n\terr = des3_ede_expand_key(dctx, key, keylen);\n\tif (err == -ENOKEY) {\n\t\tif (crypto_tfm_get_flags(tfm) & CRYPTO_TFM_REQ_FORBID_WEAK_KEYS)\n\t\t\terr = -EINVAL;\n\t\telse\n\t\t\terr = 0;\n\t}\n\tif (err)\n\t\tmemset(dctx, 0, sizeof(*dctx));\n\treturn err;\n}\n\nstatic void crypto_des3_ede_encrypt(struct crypto_tfm *tfm, u8 *dst,\n\t\t\t\t    const u8 *src)\n{\n\tconst struct des3_ede_ctx *dctx = crypto_tfm_ctx(tfm);\n\n\tdes3_ede_encrypt(dctx, dst, src);\n}\n\nstatic void crypto_des3_ede_decrypt(struct crypto_tfm *tfm, u8 *dst,\n\t\t\t\t    const u8 *src)\n{\n\tconst struct des3_ede_ctx *dctx = crypto_tfm_ctx(tfm);\n\n\tdes3_ede_decrypt(dctx, dst, src);\n}\n\nstatic struct crypto_alg des_algs[2] = { {\n\t.cra_name\t\t=\t\"des\",\n\t.cra_driver_name\t=\t\"des-generic\",\n\t.cra_priority\t\t=\t100,\n\t.cra_flags\t\t=\tCRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize\t\t=\tDES_BLOCK_SIZE,\n\t.cra_ctxsize\t\t=\tsizeof(struct des_ctx),\n\t.cra_module\t\t=\tTHIS_MODULE,\n\t.cra_u\t\t\t=\t{ .cipher = {\n\t.cia_min_keysize\t=\tDES_KEY_SIZE,\n\t.cia_max_keysize\t=\tDES_KEY_SIZE,\n\t.cia_setkey\t\t=\tdes_setkey,\n\t.cia_encrypt\t\t=\tcrypto_des_encrypt,\n\t.cia_decrypt\t\t=\tcrypto_des_decrypt } }\n}, {\n\t.cra_name\t\t=\t\"des3_ede\",\n\t.cra_driver_name\t=\t\"des3_ede-generic\",\n\t.cra_priority\t\t=\t100,\n\t.cra_flags\t\t=\tCRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize\t\t=\tDES3_EDE_BLOCK_SIZE,\n\t.cra_ctxsize\t\t=\tsizeof(struct des3_ede_ctx),\n\t.cra_module\t\t=\tTHIS_MODULE,\n\t.cra_u\t\t\t=\t{ .cipher = {\n\t.cia_min_keysize\t=\tDES3_EDE_KEY_SIZE,\n\t.cia_max_keysize\t=\tDES3_EDE_KEY_SIZE,\n\t.cia_setkey\t\t=\tdes3_ede_setkey,\n\t.cia_encrypt\t\t=\tcrypto_des3_ede_encrypt,\n\t.cia_decrypt\t\t=\tcrypto_des3_ede_decrypt } }\n} };\n\nstatic int __init des_generic_mod_init(void)\n{\n\treturn crypto_register_algs(des_algs, ARRAY_SIZE(des_algs));\n}\n\nstatic void __exit des_generic_mod_fini(void)\n{\n\tcrypto_unregister_algs(des_algs, ARRAY_SIZE(des_algs));\n}\n\nsubsys_initcall(des_generic_mod_init);\nmodule_exit(des_generic_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"DES & Triple DES EDE Cipher Algorithms\");\nMODULE_AUTHOR(\"Dag Arne Osvik <da@osvik.no>\");\nMODULE_ALIAS_CRYPTO(\"des\");\nMODULE_ALIAS_CRYPTO(\"des-generic\");\nMODULE_ALIAS_CRYPTO(\"des3_ede\");\nMODULE_ALIAS_CRYPTO(\"des3_ede-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}