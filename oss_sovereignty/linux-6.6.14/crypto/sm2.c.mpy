{
  "module_name": "sm2.c",
  "hash_id": "f0d7c6d8239f636fda961d2483b5255ae56248cb968e5a4c5ba4ed3bdd3a0116",
  "original_prompt": "Ingested from linux-6.6.14/crypto/sm2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mpi.h>\n#include <crypto/internal/akcipher.h>\n#include <crypto/akcipher.h>\n#include <crypto/hash.h>\n#include <crypto/rng.h>\n#include <crypto/sm2.h>\n#include \"sm2signature.asn1.h\"\n\n \n#define SM2_DEFAULT_USERID \"1234567812345678\"\n#define SM2_DEFAULT_USERID_LEN 16\n\n#define MPI_NBYTES(m)   ((mpi_get_nbits(m) + 7) / 8)\n\nstruct ecc_domain_parms {\n\tconst char *desc;            \n\tunsigned int nbits;          \n\tunsigned int fips:1;  \n\n\t \n\tenum gcry_mpi_ec_models model;\n\n\t \n\tenum ecc_dialects dialect;\n\n\tconst char *p;               \n\tconst char *a, *b;           \n\tconst char *n;               \n\tconst char *g_x, *g_y;       \n\tunsigned int h;              \n};\n\nstatic const struct ecc_domain_parms sm2_ecp = {\n\t.desc = \"sm2p256v1\",\n\t.nbits = 256,\n\t.fips = 0,\n\t.model = MPI_EC_WEIERSTRASS,\n\t.dialect = ECC_DIALECT_STANDARD,\n\t.p   = \"0xfffffffeffffffffffffffffffffffffffffffff00000000ffffffffffffffff\",\n\t.a   = \"0xfffffffeffffffffffffffffffffffffffffffff00000000fffffffffffffffc\",\n\t.b   = \"0x28e9fa9e9d9f5e344d5a9e4bcf6509a7f39789f515ab8f92ddbcbd414d940e93\",\n\t.n   = \"0xfffffffeffffffffffffffffffffffff7203df6b21c6052b53bbf40939d54123\",\n\t.g_x = \"0x32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7\",\n\t.g_y = \"0xbc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0\",\n\t.h = 1\n};\n\nstatic int __sm2_set_pub_key(struct mpi_ec_ctx *ec,\n\t\t\t     const void *key, unsigned int keylen);\n\nstatic int sm2_ec_ctx_init(struct mpi_ec_ctx *ec)\n{\n\tconst struct ecc_domain_parms *ecp = &sm2_ecp;\n\tMPI p, a, b;\n\tMPI x, y;\n\tint rc = -EINVAL;\n\n\tp = mpi_scanval(ecp->p);\n\ta = mpi_scanval(ecp->a);\n\tb = mpi_scanval(ecp->b);\n\tif (!p || !a || !b)\n\t\tgoto free_p;\n\n\tx = mpi_scanval(ecp->g_x);\n\ty = mpi_scanval(ecp->g_y);\n\tif (!x || !y)\n\t\tgoto free;\n\n\trc = -ENOMEM;\n\n\tec->Q = mpi_point_new(0);\n\tif (!ec->Q)\n\t\tgoto free;\n\n\t \n\tec->G = mpi_point_new(0);\n\tif (!ec->G) {\n\t\tmpi_point_release(ec->Q);\n\t\tgoto free;\n\t}\n\n\tmpi_set(ec->G->x, x);\n\tmpi_set(ec->G->y, y);\n\tmpi_set_ui(ec->G->z, 1);\n\n\trc = -EINVAL;\n\tec->n = mpi_scanval(ecp->n);\n\tif (!ec->n) {\n\t\tmpi_point_release(ec->Q);\n\t\tmpi_point_release(ec->G);\n\t\tgoto free;\n\t}\n\n\tec->h = ecp->h;\n\tec->name = ecp->desc;\n\tmpi_ec_init(ec, ecp->model, ecp->dialect, 0, p, a, b);\n\n\trc = 0;\n\nfree:\n\tmpi_free(x);\n\tmpi_free(y);\nfree_p:\n\tmpi_free(p);\n\tmpi_free(a);\n\tmpi_free(b);\n\n\treturn rc;\n}\n\nstatic void sm2_ec_ctx_deinit(struct mpi_ec_ctx *ec)\n{\n\tmpi_ec_deinit(ec);\n\n\tmemset(ec, 0, sizeof(*ec));\n}\n\n \nstatic int sm2_ecc_os2ec(MPI_POINT result, MPI value)\n{\n\tint rc;\n\tsize_t n;\n\tunsigned char *buf;\n\tMPI x, y;\n\n\tn = MPI_NBYTES(value);\n\tbuf = kmalloc(n, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trc = mpi_print(GCRYMPI_FMT_USG, buf, n, &n, value);\n\tif (rc)\n\t\tgoto err_freebuf;\n\n\trc = -EINVAL;\n\tif (n < 1 || ((n - 1) % 2))\n\t\tgoto err_freebuf;\n\t \n\tif (*buf != 0x4)\n\t\tgoto err_freebuf;\n\n\trc = -ENOMEM;\n\tn = (n - 1) / 2;\n\tx = mpi_read_raw_data(buf + 1, n);\n\tif (!x)\n\t\tgoto err_freebuf;\n\ty = mpi_read_raw_data(buf + 1 + n, n);\n\tif (!y)\n\t\tgoto err_freex;\n\n\tmpi_normalize(x);\n\tmpi_normalize(y);\n\tmpi_set(result->x, x);\n\tmpi_set(result->y, y);\n\tmpi_set_ui(result->z, 1);\n\n\trc = 0;\n\n\tmpi_free(y);\nerr_freex:\n\tmpi_free(x);\nerr_freebuf:\n\tkfree(buf);\n\treturn rc;\n}\n\nstruct sm2_signature_ctx {\n\tMPI sig_r;\n\tMPI sig_s;\n};\n\nint sm2_get_signature_r(void *context, size_t hdrlen, unsigned char tag,\n\t\t\t\tconst void *value, size_t vlen)\n{\n\tstruct sm2_signature_ctx *sig = context;\n\n\tif (!value || !vlen)\n\t\treturn -EINVAL;\n\n\tsig->sig_r = mpi_read_raw_data(value, vlen);\n\tif (!sig->sig_r)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint sm2_get_signature_s(void *context, size_t hdrlen, unsigned char tag,\n\t\t\t\tconst void *value, size_t vlen)\n{\n\tstruct sm2_signature_ctx *sig = context;\n\n\tif (!value || !vlen)\n\t\treturn -EINVAL;\n\n\tsig->sig_s = mpi_read_raw_data(value, vlen);\n\tif (!sig->sig_s)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sm2_z_digest_update(struct shash_desc *desc,\n\t\t\t       MPI m, unsigned int pbytes)\n{\n\tstatic const unsigned char zero[32];\n\tunsigned char *in;\n\tunsigned int inlen;\n\tint err;\n\n\tin = mpi_get_buffer(m, &inlen, NULL);\n\tif (!in)\n\t\treturn -EINVAL;\n\n\tif (inlen < pbytes) {\n\t\t \n\t\terr = crypto_shash_update(desc, zero, pbytes - inlen) ?:\n\t\t      crypto_shash_update(desc, in, inlen);\n\t} else if (inlen > pbytes) {\n\t\t \n\t\terr = crypto_shash_update(desc, in + inlen - pbytes, pbytes);\n\t} else {\n\t\terr = crypto_shash_update(desc, in, inlen);\n\t}\n\n\tkfree(in);\n\treturn err;\n}\n\nstatic int sm2_z_digest_update_point(struct shash_desc *desc,\n\t\t\t\t     MPI_POINT point, struct mpi_ec_ctx *ec,\n\t\t\t\t     unsigned int pbytes)\n{\n\tMPI x, y;\n\tint ret = -EINVAL;\n\n\tx = mpi_new(0);\n\ty = mpi_new(0);\n\n\tret = mpi_ec_get_affine(x, y, point, ec) ? -EINVAL :\n\t      sm2_z_digest_update(desc, x, pbytes) ?:\n\t      sm2_z_digest_update(desc, y, pbytes);\n\n\tmpi_free(x);\n\tmpi_free(y);\n\treturn ret;\n}\n\nint sm2_compute_z_digest(struct shash_desc *desc,\n\t\t\t const void *key, unsigned int keylen, void *dgst)\n{\n\tstruct mpi_ec_ctx *ec;\n\tunsigned int bits_len;\n\tunsigned int pbytes;\n\tu8 entl[2];\n\tint err;\n\n\tec = kmalloc(sizeof(*ec), GFP_KERNEL);\n\tif (!ec)\n\t\treturn -ENOMEM;\n\n\terr = sm2_ec_ctx_init(ec);\n\tif (err)\n\t\tgoto out_free_ec;\n\n\terr = __sm2_set_pub_key(ec, key, keylen);\n\tif (err)\n\t\tgoto out_deinit_ec;\n\n\tbits_len = SM2_DEFAULT_USERID_LEN * 8;\n\tentl[0] = bits_len >> 8;\n\tentl[1] = bits_len & 0xff;\n\n\tpbytes = MPI_NBYTES(ec->p);\n\n\t \n\terr = crypto_shash_init(desc);\n\tif (err)\n\t\tgoto out_deinit_ec;\n\n\terr = crypto_shash_update(desc, entl, 2);\n\tif (err)\n\t\tgoto out_deinit_ec;\n\n\terr = crypto_shash_update(desc, SM2_DEFAULT_USERID,\n\t\t\t\t  SM2_DEFAULT_USERID_LEN);\n\tif (err)\n\t\tgoto out_deinit_ec;\n\n\terr = sm2_z_digest_update(desc, ec->a, pbytes) ?:\n\t      sm2_z_digest_update(desc, ec->b, pbytes) ?:\n\t      sm2_z_digest_update_point(desc, ec->G, ec, pbytes) ?:\n\t      sm2_z_digest_update_point(desc, ec->Q, ec, pbytes);\n\tif (err)\n\t\tgoto out_deinit_ec;\n\n\terr = crypto_shash_final(desc, dgst);\n\nout_deinit_ec:\n\tsm2_ec_ctx_deinit(ec);\nout_free_ec:\n\tkfree(ec);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sm2_compute_z_digest);\n\nstatic int _sm2_verify(struct mpi_ec_ctx *ec, MPI hash, MPI sig_r, MPI sig_s)\n{\n\tint rc = -EINVAL;\n\tstruct gcry_mpi_point sG, tP;\n\tMPI t = NULL;\n\tMPI x1 = NULL, y1 = NULL;\n\n\tmpi_point_init(&sG);\n\tmpi_point_init(&tP);\n\tx1 = mpi_new(0);\n\ty1 = mpi_new(0);\n\tt = mpi_new(0);\n\n\t \n\tif (mpi_cmp_ui(sig_r, 1) < 0 || mpi_cmp(sig_r, ec->n) > 0 ||\n\t\tmpi_cmp_ui(sig_s, 1) < 0 || mpi_cmp(sig_s, ec->n) > 0) {\n\t\tgoto leave;\n\t}\n\n\t \n\tmpi_addm(t, sig_r, sig_s, ec->n);\n\tif (mpi_cmp_ui(t, 0) == 0)\n\t\tgoto leave;\n\n\t \n\trc = -EBADMSG;\n\tmpi_ec_mul_point(&sG, sig_s, ec->G, ec);\n\tmpi_ec_mul_point(&tP, t, ec->Q, ec);\n\tmpi_ec_add_points(&sG, &sG, &tP, ec);\n\tif (mpi_ec_get_affine(x1, y1, &sG, ec))\n\t\tgoto leave;\n\n\t \n\tmpi_addm(t, hash, x1, ec->n);\n\n\t \n\trc = -EKEYREJECTED;\n\tif (mpi_cmp(t, sig_r))\n\t\tgoto leave;\n\n\trc = 0;\n\nleave:\n\tmpi_point_free_parts(&sG);\n\tmpi_point_free_parts(&tP);\n\tmpi_free(x1);\n\tmpi_free(y1);\n\tmpi_free(t);\n\n\treturn rc;\n}\n\nstatic int sm2_verify(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct mpi_ec_ctx *ec = akcipher_tfm_ctx(tfm);\n\tunsigned char *buffer;\n\tstruct sm2_signature_ctx sig;\n\tMPI hash;\n\tint ret;\n\n\tif (unlikely(!ec->Q))\n\t\treturn -EINVAL;\n\n\tbuffer = kmalloc(req->src_len + req->dst_len, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tsg_pcopy_to_buffer(req->src,\n\t\tsg_nents_for_len(req->src, req->src_len + req->dst_len),\n\t\tbuffer, req->src_len + req->dst_len, 0);\n\n\tsig.sig_r = NULL;\n\tsig.sig_s = NULL;\n\tret = asn1_ber_decoder(&sm2signature_decoder, &sig,\n\t\t\t\tbuffer, req->src_len);\n\tif (ret)\n\t\tgoto error;\n\n\tret = -ENOMEM;\n\thash = mpi_read_raw_data(buffer + req->src_len, req->dst_len);\n\tif (!hash)\n\t\tgoto error;\n\n\tret = _sm2_verify(ec, hash, sig.sig_r, sig.sig_s);\n\n\tmpi_free(hash);\nerror:\n\tmpi_free(sig.sig_r);\n\tmpi_free(sig.sig_s);\n\tkfree(buffer);\n\treturn ret;\n}\n\nstatic int sm2_set_pub_key(struct crypto_akcipher *tfm,\n\t\t\tconst void *key, unsigned int keylen)\n{\n\tstruct mpi_ec_ctx *ec = akcipher_tfm_ctx(tfm);\n\n\treturn __sm2_set_pub_key(ec, key, keylen);\n\n}\n\nstatic int __sm2_set_pub_key(struct mpi_ec_ctx *ec,\n\t\t\t     const void *key, unsigned int keylen)\n{\n\tMPI a;\n\tint rc;\n\n\t \n\ta = mpi_read_raw_data(key, keylen);\n\tif (!a)\n\t\treturn -ENOMEM;\n\n\tmpi_normalize(a);\n\trc = sm2_ecc_os2ec(ec->Q, a);\n\tmpi_free(a);\n\n\treturn rc;\n}\n\nstatic unsigned int sm2_max_size(struct crypto_akcipher *tfm)\n{\n\t \n\treturn PAGE_SIZE;\n}\n\nstatic int sm2_init_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct mpi_ec_ctx *ec = akcipher_tfm_ctx(tfm);\n\n\treturn sm2_ec_ctx_init(ec);\n}\n\nstatic void sm2_exit_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct mpi_ec_ctx *ec = akcipher_tfm_ctx(tfm);\n\n\tsm2_ec_ctx_deinit(ec);\n}\n\nstatic struct akcipher_alg sm2 = {\n\t.verify = sm2_verify,\n\t.set_pub_key = sm2_set_pub_key,\n\t.max_size = sm2_max_size,\n\t.init = sm2_init_tfm,\n\t.exit = sm2_exit_tfm,\n\t.base = {\n\t\t.cra_name = \"sm2\",\n\t\t.cra_driver_name = \"sm2-generic\",\n\t\t.cra_priority = 100,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct mpi_ec_ctx),\n\t},\n};\n\nstatic int __init sm2_init(void)\n{\n\treturn crypto_register_akcipher(&sm2);\n}\n\nstatic void __exit sm2_exit(void)\n{\n\tcrypto_unregister_akcipher(&sm2);\n}\n\nsubsys_initcall(sm2_init);\nmodule_exit(sm2_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Tianjia Zhang <tianjia.zhang@linux.alibaba.com>\");\nMODULE_DESCRIPTION(\"SM2 generic algorithm\");\nMODULE_ALIAS_CRYPTO(\"sm2-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}