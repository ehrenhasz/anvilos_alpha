{
  "module_name": "cfb.c",
  "hash_id": "d9261595adc0a3307e49f25b85df85bc0270b9a16892f02b075b867e10a5518f",
  "original_prompt": "Ingested from linux-6.6.14/crypto/cfb.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nstatic unsigned int crypto_cfb_bsize(struct crypto_skcipher *tfm)\n{\n\treturn crypto_cipher_blocksize(skcipher_cipher_simple(tfm));\n}\n\nstatic void crypto_cfb_encrypt_one(struct crypto_skcipher *tfm,\n\t\t\t\t\t  const u8 *src, u8 *dst)\n{\n\tcrypto_cipher_encrypt_one(skcipher_cipher_simple(tfm), dst, src);\n}\n\n \nstatic void crypto_cfb_final(struct skcipher_walk *walk,\n\t\t\t     struct crypto_skcipher *tfm)\n{\n\tconst unsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\tu8 tmp[MAX_CIPHER_BLOCKSIZE + MAX_CIPHER_ALIGNMASK];\n\tu8 *stream = PTR_ALIGN(tmp + 0, alignmask + 1);\n\tu8 *src = walk->src.virt.addr;\n\tu8 *dst = walk->dst.virt.addr;\n\tu8 *iv = walk->iv;\n\tunsigned int nbytes = walk->nbytes;\n\n\tcrypto_cfb_encrypt_one(tfm, iv, stream);\n\tcrypto_xor_cpy(dst, stream, src, nbytes);\n}\n\nstatic int crypto_cfb_encrypt_segment(struct skcipher_walk *walk,\n\t\t\t\t      struct crypto_skcipher *tfm)\n{\n\tconst unsigned int bsize = crypto_cfb_bsize(tfm);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tu8 *dst = walk->dst.virt.addr;\n\tu8 *iv = walk->iv;\n\n\tdo {\n\t\tcrypto_cfb_encrypt_one(tfm, iv, dst);\n\t\tcrypto_xor(dst, src, bsize);\n\t\tiv = dst;\n\n\t\tsrc += bsize;\n\t\tdst += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\tmemcpy(walk->iv, iv, bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_cfb_encrypt_inplace(struct skcipher_walk *walk,\n\t\t\t\t      struct crypto_skcipher *tfm)\n{\n\tconst unsigned int bsize = crypto_cfb_bsize(tfm);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tu8 *iv = walk->iv;\n\tu8 tmp[MAX_CIPHER_BLOCKSIZE];\n\n\tdo {\n\t\tcrypto_cfb_encrypt_one(tfm, iv, tmp);\n\t\tcrypto_xor(src, tmp, bsize);\n\t\tiv = src;\n\n\t\tsrc += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\tmemcpy(walk->iv, iv, bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_cfb_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct skcipher_walk walk;\n\tunsigned int bsize = crypto_cfb_bsize(tfm);\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile (walk.nbytes >= bsize) {\n\t\tif (walk.src.virt.addr == walk.dst.virt.addr)\n\t\t\terr = crypto_cfb_encrypt_inplace(&walk, tfm);\n\t\telse\n\t\t\terr = crypto_cfb_encrypt_segment(&walk, tfm);\n\t\terr = skcipher_walk_done(&walk, err);\n\t}\n\n\tif (walk.nbytes) {\n\t\tcrypto_cfb_final(&walk, tfm);\n\t\terr = skcipher_walk_done(&walk, 0);\n\t}\n\n\treturn err;\n}\n\nstatic int crypto_cfb_decrypt_segment(struct skcipher_walk *walk,\n\t\t\t\t      struct crypto_skcipher *tfm)\n{\n\tconst unsigned int bsize = crypto_cfb_bsize(tfm);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tu8 *dst = walk->dst.virt.addr;\n\tu8 *iv = walk->iv;\n\n\tdo {\n\t\tcrypto_cfb_encrypt_one(tfm, iv, dst);\n\t\tcrypto_xor(dst, src, bsize);\n\t\tiv = src;\n\n\t\tsrc += bsize;\n\t\tdst += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\tmemcpy(walk->iv, iv, bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_cfb_decrypt_inplace(struct skcipher_walk *walk,\n\t\t\t\t      struct crypto_skcipher *tfm)\n{\n\tconst unsigned int bsize = crypto_cfb_bsize(tfm);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tu8 * const iv = walk->iv;\n\tu8 tmp[MAX_CIPHER_BLOCKSIZE];\n\n\tdo {\n\t\tcrypto_cfb_encrypt_one(tfm, iv, tmp);\n\t\tmemcpy(iv, src, bsize);\n\t\tcrypto_xor(src, tmp, bsize);\n\t\tsrc += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_cfb_decrypt_blocks(struct skcipher_walk *walk,\n\t\t\t\t     struct crypto_skcipher *tfm)\n{\n\tif (walk->src.virt.addr == walk->dst.virt.addr)\n\t\treturn crypto_cfb_decrypt_inplace(walk, tfm);\n\telse\n\t\treturn crypto_cfb_decrypt_segment(walk, tfm);\n}\n\nstatic int crypto_cfb_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct skcipher_walk walk;\n\tconst unsigned int bsize = crypto_cfb_bsize(tfm);\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile (walk.nbytes >= bsize) {\n\t\terr = crypto_cfb_decrypt_blocks(&walk, tfm);\n\t\terr = skcipher_walk_done(&walk, err);\n\t}\n\n\tif (walk.nbytes) {\n\t\tcrypto_cfb_final(&walk, tfm);\n\t\terr = skcipher_walk_done(&walk, 0);\n\t}\n\n\treturn err;\n}\n\nstatic int crypto_cfb_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct skcipher_instance *inst;\n\tstruct crypto_alg *alg;\n\tint err;\n\n\tinst = skcipher_alloc_instance_simple(tmpl, tb);\n\tif (IS_ERR(inst))\n\t\treturn PTR_ERR(inst);\n\n\talg = skcipher_ialg_simple(inst);\n\n\t \n\tinst->alg.base.cra_blocksize = 1;\n\n\t \n\tinst->alg.chunksize = alg->cra_blocksize;\n\n\tinst->alg.encrypt = crypto_cfb_encrypt;\n\tinst->alg.decrypt = crypto_cfb_decrypt;\n\n\terr = skcipher_register_instance(tmpl, inst);\n\tif (err)\n\t\tinst->free(inst);\n\n\treturn err;\n}\n\nstatic struct crypto_template crypto_cfb_tmpl = {\n\t.name = \"cfb\",\n\t.create = crypto_cfb_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_cfb_module_init(void)\n{\n\treturn crypto_register_template(&crypto_cfb_tmpl);\n}\n\nstatic void __exit crypto_cfb_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_cfb_tmpl);\n}\n\nsubsys_initcall(crypto_cfb_module_init);\nmodule_exit(crypto_cfb_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"CFB block cipher mode of operation\");\nMODULE_ALIAS_CRYPTO(\"cfb\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}