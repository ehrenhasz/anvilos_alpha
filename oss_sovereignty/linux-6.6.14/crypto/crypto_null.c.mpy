{
  "module_name": "crypto_null.c",
  "hash_id": "25840a6715bcb6609dcc3b4bb02e460595c4a163a3e69fc87bf48e23d61dbefc",
  "original_prompt": "Ingested from linux-6.6.14/crypto/crypto_null.c",
  "human_readable_source": "\n \n\n#include <crypto/null.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic DEFINE_MUTEX(crypto_default_null_skcipher_lock);\nstatic struct crypto_sync_skcipher *crypto_default_null_skcipher;\nstatic int crypto_default_null_skcipher_refcnt;\n\nstatic int null_compress(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t unsigned int slen, u8 *dst, unsigned int *dlen)\n{\n\tif (slen > *dlen)\n\t\treturn -EINVAL;\n\tmemcpy(dst, src, slen);\n\t*dlen = slen;\n\treturn 0;\n}\n\nstatic int null_init(struct shash_desc *desc)\n{\n\treturn 0;\n}\n\nstatic int null_update(struct shash_desc *desc, const u8 *data,\n\t\t       unsigned int len)\n{\n\treturn 0;\n}\n\nstatic int null_final(struct shash_desc *desc, u8 *out)\n{\n\treturn 0;\n}\n\nstatic int null_digest(struct shash_desc *desc, const u8 *data,\n\t\t       unsigned int len, u8 *out)\n{\n\treturn 0;\n}\n\nstatic int null_hash_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t    unsigned int keylen)\n{ return 0; }\n\nstatic int null_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t\tunsigned int keylen)\n{ return 0; }\n\nstatic int null_setkey(struct crypto_tfm *tfm, const u8 *key,\n\t\t       unsigned int keylen)\n{ return 0; }\n\nstatic void null_crypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tmemcpy(dst, src, NULL_BLOCK_SIZE);\n}\n\nstatic int null_skcipher_crypt(struct skcipher_request *req)\n{\n\tstruct skcipher_walk walk;\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile (walk.nbytes) {\n\t\tif (walk.src.virt.addr != walk.dst.virt.addr)\n\t\t\tmemcpy(walk.dst.virt.addr, walk.src.virt.addr,\n\t\t\t       walk.nbytes);\n\t\terr = skcipher_walk_done(&walk, 0);\n\t}\n\n\treturn err;\n}\n\nstatic struct shash_alg digest_null = {\n\t.digestsize\t\t=\tNULL_DIGEST_SIZE,\n\t.setkey   \t\t=\tnull_hash_setkey,\n\t.init   \t\t=\tnull_init,\n\t.update \t\t=\tnull_update,\n\t.finup \t\t\t=\tnull_digest,\n\t.digest \t\t=\tnull_digest,\n\t.final  \t\t=\tnull_final,\n\t.base\t\t\t=\t{\n\t\t.cra_name\t\t=\t\"digest_null\",\n\t\t.cra_driver_name\t=\t\"digest_null-generic\",\n\t\t.cra_blocksize\t\t=\tNULL_BLOCK_SIZE,\n\t\t.cra_module\t\t=\tTHIS_MODULE,\n\t}\n};\n\nstatic struct skcipher_alg skcipher_null = {\n\t.base.cra_name\t\t=\t\"ecb(cipher_null)\",\n\t.base.cra_driver_name\t=\t\"ecb-cipher_null\",\n\t.base.cra_priority\t=\t100,\n\t.base.cra_blocksize\t=\tNULL_BLOCK_SIZE,\n\t.base.cra_ctxsize\t=\t0,\n\t.base.cra_module\t=\tTHIS_MODULE,\n\t.min_keysize\t\t=\tNULL_KEY_SIZE,\n\t.max_keysize\t\t=\tNULL_KEY_SIZE,\n\t.ivsize\t\t\t=\tNULL_IV_SIZE,\n\t.setkey\t\t\t=\tnull_skcipher_setkey,\n\t.encrypt\t\t=\tnull_skcipher_crypt,\n\t.decrypt\t\t=\tnull_skcipher_crypt,\n};\n\nstatic struct crypto_alg null_algs[] = { {\n\t.cra_name\t\t=\t\"cipher_null\",\n\t.cra_driver_name\t=\t\"cipher_null-generic\",\n\t.cra_flags\t\t=\tCRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize\t\t=\tNULL_BLOCK_SIZE,\n\t.cra_ctxsize\t\t=\t0,\n\t.cra_module\t\t=\tTHIS_MODULE,\n\t.cra_u\t\t\t=\t{ .cipher = {\n\t.cia_min_keysize\t=\tNULL_KEY_SIZE,\n\t.cia_max_keysize\t=\tNULL_KEY_SIZE,\n\t.cia_setkey\t\t= \tnull_setkey,\n\t.cia_encrypt\t\t=\tnull_crypt,\n\t.cia_decrypt\t\t=\tnull_crypt } }\n}, {\n\t.cra_name\t\t=\t\"compress_null\",\n\t.cra_driver_name\t=\t\"compress_null-generic\",\n\t.cra_flags\t\t=\tCRYPTO_ALG_TYPE_COMPRESS,\n\t.cra_blocksize\t\t=\tNULL_BLOCK_SIZE,\n\t.cra_ctxsize\t\t=\t0,\n\t.cra_module\t\t=\tTHIS_MODULE,\n\t.cra_u\t\t\t=\t{ .compress = {\n\t.coa_compress\t\t=\tnull_compress,\n\t.coa_decompress\t\t=\tnull_compress } }\n} };\n\nMODULE_ALIAS_CRYPTO(\"compress_null\");\nMODULE_ALIAS_CRYPTO(\"digest_null\");\nMODULE_ALIAS_CRYPTO(\"cipher_null\");\n\nstruct crypto_sync_skcipher *crypto_get_default_null_skcipher(void)\n{\n\tstruct crypto_sync_skcipher *tfm;\n\n\tmutex_lock(&crypto_default_null_skcipher_lock);\n\ttfm = crypto_default_null_skcipher;\n\n\tif (!tfm) {\n\t\ttfm = crypto_alloc_sync_skcipher(\"ecb(cipher_null)\", 0, 0);\n\t\tif (IS_ERR(tfm))\n\t\t\tgoto unlock;\n\n\t\tcrypto_default_null_skcipher = tfm;\n\t}\n\n\tcrypto_default_null_skcipher_refcnt++;\n\nunlock:\n\tmutex_unlock(&crypto_default_null_skcipher_lock);\n\n\treturn tfm;\n}\nEXPORT_SYMBOL_GPL(crypto_get_default_null_skcipher);\n\nvoid crypto_put_default_null_skcipher(void)\n{\n\tmutex_lock(&crypto_default_null_skcipher_lock);\n\tif (!--crypto_default_null_skcipher_refcnt) {\n\t\tcrypto_free_sync_skcipher(crypto_default_null_skcipher);\n\t\tcrypto_default_null_skcipher = NULL;\n\t}\n\tmutex_unlock(&crypto_default_null_skcipher_lock);\n}\nEXPORT_SYMBOL_GPL(crypto_put_default_null_skcipher);\n\nstatic int __init crypto_null_mod_init(void)\n{\n\tint ret = 0;\n\n\tret = crypto_register_algs(null_algs, ARRAY_SIZE(null_algs));\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = crypto_register_shash(&digest_null);\n\tif (ret < 0)\n\t\tgoto out_unregister_algs;\n\n\tret = crypto_register_skcipher(&skcipher_null);\n\tif (ret < 0)\n\t\tgoto out_unregister_shash;\n\n\treturn 0;\n\nout_unregister_shash:\n\tcrypto_unregister_shash(&digest_null);\nout_unregister_algs:\n\tcrypto_unregister_algs(null_algs, ARRAY_SIZE(null_algs));\nout:\n\treturn ret;\n}\n\nstatic void __exit crypto_null_mod_fini(void)\n{\n\tcrypto_unregister_algs(null_algs, ARRAY_SIZE(null_algs));\n\tcrypto_unregister_shash(&digest_null);\n\tcrypto_unregister_skcipher(&skcipher_null);\n}\n\nsubsys_initcall(crypto_null_mod_init);\nmodule_exit(crypto_null_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Null Cryptographic Algorithms\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}