{
  "module_name": "simd.c",
  "hash_id": "d3f90fa042440164d33f6261a12b6053dc2e04bf368a9df1673988db3ac872ee",
  "original_prompt": "Ingested from linux-6.6.14/crypto/simd.c",
  "human_readable_source": "\n \n\n \n\n#include <crypto/cryptd.h>\n#include <crypto/internal/aead.h>\n#include <crypto/internal/simd.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <asm/simd.h>\n\n \n\nstruct simd_skcipher_alg {\n\tconst char *ialg_name;\n\tstruct skcipher_alg alg;\n};\n\nstruct simd_skcipher_ctx {\n\tstruct cryptd_skcipher *cryptd_tfm;\n};\n\nstatic int simd_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t\tunsigned int key_len)\n{\n\tstruct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct crypto_skcipher *child = &ctx->cryptd_tfm->base;\n\n\tcrypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(child, crypto_skcipher_get_flags(tfm) &\n\t\t\t\t\t CRYPTO_TFM_REQ_MASK);\n\treturn crypto_skcipher_setkey(child, key, key_len);\n}\n\nstatic int simd_skcipher_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct skcipher_request *subreq;\n\tstruct crypto_skcipher *child;\n\n\tsubreq = skcipher_request_ctx(req);\n\t*subreq = *req;\n\n\tif (!crypto_simd_usable() ||\n\t    (in_atomic() && cryptd_skcipher_queued(ctx->cryptd_tfm)))\n\t\tchild = &ctx->cryptd_tfm->base;\n\telse\n\t\tchild = cryptd_skcipher_child(ctx->cryptd_tfm);\n\n\tskcipher_request_set_tfm(subreq, child);\n\n\treturn crypto_skcipher_encrypt(subreq);\n}\n\nstatic int simd_skcipher_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct skcipher_request *subreq;\n\tstruct crypto_skcipher *child;\n\n\tsubreq = skcipher_request_ctx(req);\n\t*subreq = *req;\n\n\tif (!crypto_simd_usable() ||\n\t    (in_atomic() && cryptd_skcipher_queued(ctx->cryptd_tfm)))\n\t\tchild = &ctx->cryptd_tfm->base;\n\telse\n\t\tchild = cryptd_skcipher_child(ctx->cryptd_tfm);\n\n\tskcipher_request_set_tfm(subreq, child);\n\n\treturn crypto_skcipher_decrypt(subreq);\n}\n\nstatic void simd_skcipher_exit(struct crypto_skcipher *tfm)\n{\n\tstruct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tcryptd_free_skcipher(ctx->cryptd_tfm);\n}\n\nstatic int simd_skcipher_init(struct crypto_skcipher *tfm)\n{\n\tstruct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct cryptd_skcipher *cryptd_tfm;\n\tstruct simd_skcipher_alg *salg;\n\tstruct skcipher_alg *alg;\n\tunsigned reqsize;\n\n\talg = crypto_skcipher_alg(tfm);\n\tsalg = container_of(alg, struct simd_skcipher_alg, alg);\n\n\tcryptd_tfm = cryptd_alloc_skcipher(salg->ialg_name,\n\t\t\t\t\t   CRYPTO_ALG_INTERNAL,\n\t\t\t\t\t   CRYPTO_ALG_INTERNAL);\n\tif (IS_ERR(cryptd_tfm))\n\t\treturn PTR_ERR(cryptd_tfm);\n\n\tctx->cryptd_tfm = cryptd_tfm;\n\n\treqsize = crypto_skcipher_reqsize(cryptd_skcipher_child(cryptd_tfm));\n\treqsize = max(reqsize, crypto_skcipher_reqsize(&cryptd_tfm->base));\n\treqsize += sizeof(struct skcipher_request);\n\n\tcrypto_skcipher_set_reqsize(tfm, reqsize);\n\n\treturn 0;\n}\n\nstruct simd_skcipher_alg *simd_skcipher_create_compat(const char *algname,\n\t\t\t\t\t\t      const char *drvname,\n\t\t\t\t\t\t      const char *basename)\n{\n\tstruct simd_skcipher_alg *salg;\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_alg *ialg;\n\tstruct skcipher_alg *alg;\n\tint err;\n\n\ttfm = crypto_alloc_skcipher(basename, CRYPTO_ALG_INTERNAL,\n\t\t\t\t    CRYPTO_ALG_INTERNAL | CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm))\n\t\treturn ERR_CAST(tfm);\n\n\tialg = crypto_skcipher_alg(tfm);\n\n\tsalg = kzalloc(sizeof(*salg), GFP_KERNEL);\n\tif (!salg) {\n\t\tsalg = ERR_PTR(-ENOMEM);\n\t\tgoto out_put_tfm;\n\t}\n\n\tsalg->ialg_name = basename;\n\talg = &salg->alg;\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(alg->base.cra_name, CRYPTO_MAX_ALG_NAME, \"%s\", algname) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\tgoto out_free_salg;\n\n\tif (snprintf(alg->base.cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t     drvname) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto out_free_salg;\n\n\talg->base.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t(ialg->base.cra_flags & CRYPTO_ALG_INHERITED_FLAGS);\n\talg->base.cra_priority = ialg->base.cra_priority;\n\talg->base.cra_blocksize = ialg->base.cra_blocksize;\n\talg->base.cra_alignmask = ialg->base.cra_alignmask;\n\talg->base.cra_module = ialg->base.cra_module;\n\talg->base.cra_ctxsize = sizeof(struct simd_skcipher_ctx);\n\n\talg->ivsize = ialg->ivsize;\n\talg->chunksize = ialg->chunksize;\n\talg->min_keysize = ialg->min_keysize;\n\talg->max_keysize = ialg->max_keysize;\n\n\talg->init = simd_skcipher_init;\n\talg->exit = simd_skcipher_exit;\n\n\talg->setkey = simd_skcipher_setkey;\n\talg->encrypt = simd_skcipher_encrypt;\n\talg->decrypt = simd_skcipher_decrypt;\n\n\terr = crypto_register_skcipher(alg);\n\tif (err)\n\t\tgoto out_free_salg;\n\nout_put_tfm:\n\tcrypto_free_skcipher(tfm);\n\treturn salg;\n\nout_free_salg:\n\tkfree(salg);\n\tsalg = ERR_PTR(err);\n\tgoto out_put_tfm;\n}\nEXPORT_SYMBOL_GPL(simd_skcipher_create_compat);\n\nstruct simd_skcipher_alg *simd_skcipher_create(const char *algname,\n\t\t\t\t\t       const char *basename)\n{\n\tchar drvname[CRYPTO_MAX_ALG_NAME];\n\n\tif (snprintf(drvname, CRYPTO_MAX_ALG_NAME, \"simd-%s\", basename) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\treturn simd_skcipher_create_compat(algname, drvname, basename);\n}\nEXPORT_SYMBOL_GPL(simd_skcipher_create);\n\nvoid simd_skcipher_free(struct simd_skcipher_alg *salg)\n{\n\tcrypto_unregister_skcipher(&salg->alg);\n\tkfree(salg);\n}\nEXPORT_SYMBOL_GPL(simd_skcipher_free);\n\nint simd_register_skciphers_compat(struct skcipher_alg *algs, int count,\n\t\t\t\t   struct simd_skcipher_alg **simd_algs)\n{\n\tint err;\n\tint i;\n\tconst char *algname;\n\tconst char *drvname;\n\tconst char *basename;\n\tstruct simd_skcipher_alg *simd;\n\n\terr = crypto_register_skciphers(algs, count);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < count; i++) {\n\t\tWARN_ON(strncmp(algs[i].base.cra_name, \"__\", 2));\n\t\tWARN_ON(strncmp(algs[i].base.cra_driver_name, \"__\", 2));\n\t\talgname = algs[i].base.cra_name + 2;\n\t\tdrvname = algs[i].base.cra_driver_name + 2;\n\t\tbasename = algs[i].base.cra_driver_name;\n\t\tsimd = simd_skcipher_create_compat(algname, drvname, basename);\n\t\terr = PTR_ERR(simd);\n\t\tif (IS_ERR(simd))\n\t\t\tgoto err_unregister;\n\t\tsimd_algs[i] = simd;\n\t}\n\treturn 0;\n\nerr_unregister:\n\tsimd_unregister_skciphers(algs, count, simd_algs);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(simd_register_skciphers_compat);\n\nvoid simd_unregister_skciphers(struct skcipher_alg *algs, int count,\n\t\t\t       struct simd_skcipher_alg **simd_algs)\n{\n\tint i;\n\n\tcrypto_unregister_skciphers(algs, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (simd_algs[i]) {\n\t\t\tsimd_skcipher_free(simd_algs[i]);\n\t\t\tsimd_algs[i] = NULL;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(simd_unregister_skciphers);\n\n \n\nstruct simd_aead_alg {\n\tconst char *ialg_name;\n\tstruct aead_alg alg;\n};\n\nstruct simd_aead_ctx {\n\tstruct cryptd_aead *cryptd_tfm;\n};\n\nstatic int simd_aead_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t\tunsigned int key_len)\n{\n\tstruct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_aead *child = &ctx->cryptd_tfm->base;\n\n\tcrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\n\tcrypto_aead_set_flags(child, crypto_aead_get_flags(tfm) &\n\t\t\t\t     CRYPTO_TFM_REQ_MASK);\n\treturn crypto_aead_setkey(child, key, key_len);\n}\n\nstatic int simd_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)\n{\n\tstruct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_aead *child = &ctx->cryptd_tfm->base;\n\n\treturn crypto_aead_setauthsize(child, authsize);\n}\n\nstatic int simd_aead_encrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_request *subreq;\n\tstruct crypto_aead *child;\n\n\tsubreq = aead_request_ctx(req);\n\t*subreq = *req;\n\n\tif (!crypto_simd_usable() ||\n\t    (in_atomic() && cryptd_aead_queued(ctx->cryptd_tfm)))\n\t\tchild = &ctx->cryptd_tfm->base;\n\telse\n\t\tchild = cryptd_aead_child(ctx->cryptd_tfm);\n\n\taead_request_set_tfm(subreq, child);\n\n\treturn crypto_aead_encrypt(subreq);\n}\n\nstatic int simd_aead_decrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_request *subreq;\n\tstruct crypto_aead *child;\n\n\tsubreq = aead_request_ctx(req);\n\t*subreq = *req;\n\n\tif (!crypto_simd_usable() ||\n\t    (in_atomic() && cryptd_aead_queued(ctx->cryptd_tfm)))\n\t\tchild = &ctx->cryptd_tfm->base;\n\telse\n\t\tchild = cryptd_aead_child(ctx->cryptd_tfm);\n\n\taead_request_set_tfm(subreq, child);\n\n\treturn crypto_aead_decrypt(subreq);\n}\n\nstatic void simd_aead_exit(struct crypto_aead *tfm)\n{\n\tstruct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcryptd_free_aead(ctx->cryptd_tfm);\n}\n\nstatic int simd_aead_init(struct crypto_aead *tfm)\n{\n\tstruct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct cryptd_aead *cryptd_tfm;\n\tstruct simd_aead_alg *salg;\n\tstruct aead_alg *alg;\n\tunsigned reqsize;\n\n\talg = crypto_aead_alg(tfm);\n\tsalg = container_of(alg, struct simd_aead_alg, alg);\n\n\tcryptd_tfm = cryptd_alloc_aead(salg->ialg_name, CRYPTO_ALG_INTERNAL,\n\t\t\t\t       CRYPTO_ALG_INTERNAL);\n\tif (IS_ERR(cryptd_tfm))\n\t\treturn PTR_ERR(cryptd_tfm);\n\n\tctx->cryptd_tfm = cryptd_tfm;\n\n\treqsize = crypto_aead_reqsize(cryptd_aead_child(cryptd_tfm));\n\treqsize = max(reqsize, crypto_aead_reqsize(&cryptd_tfm->base));\n\treqsize += sizeof(struct aead_request);\n\n\tcrypto_aead_set_reqsize(tfm, reqsize);\n\n\treturn 0;\n}\n\nstruct simd_aead_alg *simd_aead_create_compat(const char *algname,\n\t\t\t\t\t      const char *drvname,\n\t\t\t\t\t      const char *basename)\n{\n\tstruct simd_aead_alg *salg;\n\tstruct crypto_aead *tfm;\n\tstruct aead_alg *ialg;\n\tstruct aead_alg *alg;\n\tint err;\n\n\ttfm = crypto_alloc_aead(basename, CRYPTO_ALG_INTERNAL,\n\t\t\t\tCRYPTO_ALG_INTERNAL | CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm))\n\t\treturn ERR_CAST(tfm);\n\n\tialg = crypto_aead_alg(tfm);\n\n\tsalg = kzalloc(sizeof(*salg), GFP_KERNEL);\n\tif (!salg) {\n\t\tsalg = ERR_PTR(-ENOMEM);\n\t\tgoto out_put_tfm;\n\t}\n\n\tsalg->ialg_name = basename;\n\talg = &salg->alg;\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(alg->base.cra_name, CRYPTO_MAX_ALG_NAME, \"%s\", algname) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\tgoto out_free_salg;\n\n\tif (snprintf(alg->base.cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t     drvname) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto out_free_salg;\n\n\talg->base.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t(ialg->base.cra_flags & CRYPTO_ALG_INHERITED_FLAGS);\n\talg->base.cra_priority = ialg->base.cra_priority;\n\talg->base.cra_blocksize = ialg->base.cra_blocksize;\n\talg->base.cra_alignmask = ialg->base.cra_alignmask;\n\talg->base.cra_module = ialg->base.cra_module;\n\talg->base.cra_ctxsize = sizeof(struct simd_aead_ctx);\n\n\talg->ivsize = ialg->ivsize;\n\talg->maxauthsize = ialg->maxauthsize;\n\talg->chunksize = ialg->chunksize;\n\n\talg->init = simd_aead_init;\n\talg->exit = simd_aead_exit;\n\n\talg->setkey = simd_aead_setkey;\n\talg->setauthsize = simd_aead_setauthsize;\n\talg->encrypt = simd_aead_encrypt;\n\talg->decrypt = simd_aead_decrypt;\n\n\terr = crypto_register_aead(alg);\n\tif (err)\n\t\tgoto out_free_salg;\n\nout_put_tfm:\n\tcrypto_free_aead(tfm);\n\treturn salg;\n\nout_free_salg:\n\tkfree(salg);\n\tsalg = ERR_PTR(err);\n\tgoto out_put_tfm;\n}\nEXPORT_SYMBOL_GPL(simd_aead_create_compat);\n\nstruct simd_aead_alg *simd_aead_create(const char *algname,\n\t\t\t\t       const char *basename)\n{\n\tchar drvname[CRYPTO_MAX_ALG_NAME];\n\n\tif (snprintf(drvname, CRYPTO_MAX_ALG_NAME, \"simd-%s\", basename) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\treturn simd_aead_create_compat(algname, drvname, basename);\n}\nEXPORT_SYMBOL_GPL(simd_aead_create);\n\nvoid simd_aead_free(struct simd_aead_alg *salg)\n{\n\tcrypto_unregister_aead(&salg->alg);\n\tkfree(salg);\n}\nEXPORT_SYMBOL_GPL(simd_aead_free);\n\nint simd_register_aeads_compat(struct aead_alg *algs, int count,\n\t\t\t       struct simd_aead_alg **simd_algs)\n{\n\tint err;\n\tint i;\n\tconst char *algname;\n\tconst char *drvname;\n\tconst char *basename;\n\tstruct simd_aead_alg *simd;\n\n\terr = crypto_register_aeads(algs, count);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < count; i++) {\n\t\tWARN_ON(strncmp(algs[i].base.cra_name, \"__\", 2));\n\t\tWARN_ON(strncmp(algs[i].base.cra_driver_name, \"__\", 2));\n\t\talgname = algs[i].base.cra_name + 2;\n\t\tdrvname = algs[i].base.cra_driver_name + 2;\n\t\tbasename = algs[i].base.cra_driver_name;\n\t\tsimd = simd_aead_create_compat(algname, drvname, basename);\n\t\terr = PTR_ERR(simd);\n\t\tif (IS_ERR(simd))\n\t\t\tgoto err_unregister;\n\t\tsimd_algs[i] = simd;\n\t}\n\treturn 0;\n\nerr_unregister:\n\tsimd_unregister_aeads(algs, count, simd_algs);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(simd_register_aeads_compat);\n\nvoid simd_unregister_aeads(struct aead_alg *algs, int count,\n\t\t\t   struct simd_aead_alg **simd_algs)\n{\n\tint i;\n\n\tcrypto_unregister_aeads(algs, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (simd_algs[i]) {\n\t\t\tsimd_aead_free(simd_algs[i]);\n\t\t\tsimd_algs[i] = NULL;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(simd_unregister_aeads);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}