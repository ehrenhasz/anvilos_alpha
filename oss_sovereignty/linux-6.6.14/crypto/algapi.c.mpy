{
  "module_name": "algapi.c",
  "hash_id": "8e9bed6c9d85aa94f71701771b1817a9be1abbd0db63b693ba002becd15502d5",
  "original_prompt": "Ingested from linux-6.6.14/crypto/algapi.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/simd.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/fips.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n\n#include \"internal.h\"\n\nstatic LIST_HEAD(crypto_template_list);\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\nDEFINE_PER_CPU(bool, crypto_simd_disabled_for_test);\nEXPORT_PER_CPU_SYMBOL_GPL(crypto_simd_disabled_for_test);\n#endif\n\nstatic inline void crypto_check_module_sig(struct module *mod)\n{\n\tif (fips_enabled && mod && !module_sig_ok(mod))\n\t\tpanic(\"Module %s signature verification failed in FIPS mode\\n\",\n\t\t      module_name(mod));\n}\n\nstatic int crypto_check_alg(struct crypto_alg *alg)\n{\n\tcrypto_check_module_sig(alg->cra_module);\n\n\tif (!alg->cra_name[0] || !alg->cra_driver_name[0])\n\t\treturn -EINVAL;\n\n\tif (alg->cra_alignmask & (alg->cra_alignmask + 1))\n\t\treturn -EINVAL;\n\n\t \n\tif (alg->cra_alignmask > MAX_ALGAPI_ALIGNMASK)\n\t\treturn -EINVAL;\n\n\tif (alg->cra_blocksize > MAX_ALGAPI_BLOCKSIZE)\n\t\treturn -EINVAL;\n\n\t \n\tif (!alg->cra_type && (alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==\n\t\t\t       CRYPTO_ALG_TYPE_CIPHER) {\n\t\tif (alg->cra_alignmask > MAX_CIPHER_ALIGNMASK)\n\t\t\treturn -EINVAL;\n\n\t\tif (alg->cra_blocksize > MAX_CIPHER_BLOCKSIZE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (alg->cra_priority < 0)\n\t\treturn -EINVAL;\n\n\trefcount_set(&alg->cra_refcnt, 1);\n\n\treturn 0;\n}\n\nstatic void crypto_free_instance(struct crypto_instance *inst)\n{\n\tinst->alg.cra_type->free(inst);\n}\n\nstatic void crypto_destroy_instance_workfn(struct work_struct *w)\n{\n\tstruct crypto_instance *inst = container_of(w, struct crypto_instance,\n\t\t\t\t\t\t    free_work);\n\tstruct crypto_template *tmpl = inst->tmpl;\n\n\tcrypto_free_instance(inst);\n\tcrypto_tmpl_put(tmpl);\n}\n\nstatic void crypto_destroy_instance(struct crypto_alg *alg)\n{\n\tstruct crypto_instance *inst = container_of(alg,\n\t\t\t\t\t\t    struct crypto_instance,\n\t\t\t\t\t\t    alg);\n\n\tINIT_WORK(&inst->free_work, crypto_destroy_instance_workfn);\n\tschedule_work(&inst->free_work);\n}\n\n \nstatic struct list_head *crypto_more_spawns(struct crypto_alg *alg,\n\t\t\t\t\t    struct list_head *stack,\n\t\t\t\t\t    struct list_head *top,\n\t\t\t\t\t    struct list_head *secondary_spawns)\n{\n\tstruct crypto_spawn *spawn, *n;\n\n\tspawn = list_first_entry_or_null(stack, struct crypto_spawn, list);\n\tif (!spawn)\n\t\treturn NULL;\n\n\tn = list_prev_entry(spawn, list);\n\tlist_move(&spawn->list, secondary_spawns);\n\n\tif (list_is_last(&n->list, stack))\n\t\treturn top;\n\n\tn = list_next_entry(n, list);\n\tif (!spawn->dead)\n\t\tn->dead = false;\n\n\treturn &n->inst->alg.cra_users;\n}\n\nstatic void crypto_remove_instance(struct crypto_instance *inst,\n\t\t\t\t   struct list_head *list)\n{\n\tstruct crypto_template *tmpl = inst->tmpl;\n\n\tif (crypto_is_dead(&inst->alg))\n\t\treturn;\n\n\tinst->alg.cra_flags |= CRYPTO_ALG_DEAD;\n\n\tif (!tmpl || !crypto_tmpl_get(tmpl))\n\t\treturn;\n\n\tlist_move(&inst->alg.cra_list, list);\n\thlist_del(&inst->list);\n\tinst->alg.cra_destroy = crypto_destroy_instance;\n\n\tBUG_ON(!list_empty(&inst->alg.cra_users));\n}\n\n \nvoid crypto_remove_spawns(struct crypto_alg *alg, struct list_head *list,\n\t\t\t  struct crypto_alg *nalg)\n{\n\tu32 new_type = (nalg ?: alg)->cra_flags;\n\tstruct crypto_spawn *spawn, *n;\n\tLIST_HEAD(secondary_spawns);\n\tstruct list_head *spawns;\n\tLIST_HEAD(stack);\n\tLIST_HEAD(top);\n\n\tspawns = &alg->cra_users;\n\tlist_for_each_entry_safe(spawn, n, spawns, list) {\n\t\tif ((spawn->alg->cra_flags ^ new_type) & spawn->mask)\n\t\t\tcontinue;\n\n\t\tlist_move(&spawn->list, &top);\n\t}\n\n\t \n\tspawns = &top;\n\tdo {\n\t\twhile (!list_empty(spawns)) {\n\t\t\tstruct crypto_instance *inst;\n\n\t\t\tspawn = list_first_entry(spawns, struct crypto_spawn,\n\t\t\t\t\t\t list);\n\t\t\tinst = spawn->inst;\n\n\t\t\tlist_move(&spawn->list, &stack);\n\t\t\tspawn->dead = !spawn->registered || &inst->alg != nalg;\n\n\t\t\tif (!spawn->registered)\n\t\t\t\tbreak;\n\n\t\t\tBUG_ON(&inst->alg == alg);\n\n\t\t\tif (&inst->alg == nalg)\n\t\t\t\tbreak;\n\n\t\t\tspawns = &inst->alg.cra_users;\n\n\t\t\t \n\t\t\tif (spawns->next == NULL)\n\t\t\t\tbreak;\n\t\t}\n\t} while ((spawns = crypto_more_spawns(alg, &stack, &top,\n\t\t\t\t\t      &secondary_spawns)));\n\n\t \n\tlist_for_each_entry_safe(spawn, n, &secondary_spawns, list) {\n\t\tif (!spawn->dead)\n\t\t\tlist_move(&spawn->list, &spawn->alg->cra_users);\n\t\telse if (spawn->registered)\n\t\t\tcrypto_remove_instance(spawn->inst, list);\n\t}\n}\nEXPORT_SYMBOL_GPL(crypto_remove_spawns);\n\nstatic void crypto_alg_finish_registration(struct crypto_alg *alg,\n\t\t\t\t\t   bool fulfill_requests,\n\t\t\t\t\t   struct list_head *algs_to_put)\n{\n\tstruct crypto_alg *q;\n\n\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\tif (q == alg)\n\t\t\tcontinue;\n\n\t\tif (crypto_is_moribund(q))\n\t\t\tcontinue;\n\n\t\tif (crypto_is_larval(q)) {\n\t\t\tstruct crypto_larval *larval = (void *)q;\n\n\t\t\t \n\t\t\tif (strcmp(alg->cra_name, q->cra_name) &&\n\t\t\t    strcmp(alg->cra_driver_name, q->cra_name))\n\t\t\t\tcontinue;\n\n\t\t\tif (larval->adult)\n\t\t\t\tcontinue;\n\t\t\tif ((q->cra_flags ^ alg->cra_flags) & larval->mask)\n\t\t\t\tcontinue;\n\n\t\t\tif (fulfill_requests && crypto_mod_get(alg))\n\t\t\t\tlarval->adult = alg;\n\t\t\telse\n\t\t\t\tlarval->adult = ERR_PTR(-EAGAIN);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(alg->cra_name, q->cra_name))\n\t\t\tcontinue;\n\n\t\tif (strcmp(alg->cra_driver_name, q->cra_driver_name) &&\n\t\t    q->cra_priority > alg->cra_priority)\n\t\t\tcontinue;\n\n\t\tcrypto_remove_spawns(q, algs_to_put, alg);\n\t}\n\n\tcrypto_notify(CRYPTO_MSG_ALG_LOADED, alg);\n}\n\nstatic struct crypto_larval *crypto_alloc_test_larval(struct crypto_alg *alg)\n{\n\tstruct crypto_larval *larval;\n\n\tif (!IS_ENABLED(CONFIG_CRYPTO_MANAGER) ||\n\t    IS_ENABLED(CONFIG_CRYPTO_MANAGER_DISABLE_TESTS) ||\n\t    (alg->cra_flags & CRYPTO_ALG_INTERNAL))\n\t\treturn NULL;  \n\n\tlarval = crypto_larval_alloc(alg->cra_name,\n\t\t\t\t     alg->cra_flags | CRYPTO_ALG_TESTED, 0);\n\tif (IS_ERR(larval))\n\t\treturn larval;\n\n\tlarval->adult = crypto_mod_get(alg);\n\tif (!larval->adult) {\n\t\tkfree(larval);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\trefcount_set(&larval->alg.cra_refcnt, 1);\n\tmemcpy(larval->alg.cra_driver_name, alg->cra_driver_name,\n\t       CRYPTO_MAX_ALG_NAME);\n\tlarval->alg.cra_priority = alg->cra_priority;\n\n\treturn larval;\n}\n\nstatic struct crypto_larval *\n__crypto_register_alg(struct crypto_alg *alg, struct list_head *algs_to_put)\n{\n\tstruct crypto_alg *q;\n\tstruct crypto_larval *larval;\n\tint ret = -EAGAIN;\n\n\tif (crypto_is_dead(alg))\n\t\tgoto err;\n\n\tINIT_LIST_HEAD(&alg->cra_users);\n\n\tret = -EEXIST;\n\n\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\tif (q == alg)\n\t\t\tgoto err;\n\n\t\tif (crypto_is_moribund(q))\n\t\t\tcontinue;\n\n\t\tif (crypto_is_larval(q)) {\n\t\t\tif (!strcmp(alg->cra_driver_name, q->cra_driver_name))\n\t\t\t\tgoto err;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(q->cra_driver_name, alg->cra_name) ||\n\t\t    !strcmp(q->cra_name, alg->cra_driver_name))\n\t\t\tgoto err;\n\t}\n\n\tlarval = crypto_alloc_test_larval(alg);\n\tif (IS_ERR(larval))\n\t\tgoto out;\n\n\tlist_add(&alg->cra_list, &crypto_alg_list);\n\n\tif (larval) {\n\t\t \n\t\talg->cra_flags &= ~CRYPTO_ALG_TESTED;\n\n\t\tlist_add(&larval->alg.cra_list, &crypto_alg_list);\n\t} else {\n\t\talg->cra_flags |= CRYPTO_ALG_TESTED;\n\t\tcrypto_alg_finish_registration(alg, true, algs_to_put);\n\t}\n\nout:\n\treturn larval;\n\nerr:\n\tlarval = ERR_PTR(ret);\n\tgoto out;\n}\n\nvoid crypto_alg_tested(const char *name, int err)\n{\n\tstruct crypto_larval *test;\n\tstruct crypto_alg *alg;\n\tstruct crypto_alg *q;\n\tLIST_HEAD(list);\n\tbool best;\n\n\tdown_write(&crypto_alg_sem);\n\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\tif (crypto_is_moribund(q) || !crypto_is_larval(q))\n\t\t\tcontinue;\n\n\t\ttest = (struct crypto_larval *)q;\n\n\t\tif (!strcmp(q->cra_driver_name, name))\n\t\t\tgoto found;\n\t}\n\n\tpr_err(\"alg: Unexpected test result for %s: %d\\n\", name, err);\n\tgoto unlock;\n\nfound:\n\tq->cra_flags |= CRYPTO_ALG_DEAD;\n\talg = test->adult;\n\n\tif (list_empty(&alg->cra_list))\n\t\tgoto complete;\n\n\tif (err == -ECANCELED)\n\t\talg->cra_flags |= CRYPTO_ALG_FIPS_INTERNAL;\n\telse if (err)\n\t\tgoto complete;\n\telse\n\t\talg->cra_flags &= ~CRYPTO_ALG_FIPS_INTERNAL;\n\n\talg->cra_flags |= CRYPTO_ALG_TESTED;\n\n\t \n\tbest = true;\n\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\tif (crypto_is_moribund(q) || !crypto_is_larval(q))\n\t\t\tcontinue;\n\n\t\tif (strcmp(alg->cra_name, q->cra_name))\n\t\t\tcontinue;\n\n\t\tif (q->cra_priority > alg->cra_priority) {\n\t\t\tbest = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcrypto_alg_finish_registration(alg, best, &list);\n\ncomplete:\n\tcomplete_all(&test->completion);\n\nunlock:\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_remove_final(&list);\n}\nEXPORT_SYMBOL_GPL(crypto_alg_tested);\n\nvoid crypto_remove_final(struct list_head *list)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_alg *n;\n\n\tlist_for_each_entry_safe(alg, n, list, cra_list) {\n\t\tlist_del_init(&alg->cra_list);\n\t\tcrypto_alg_put(alg);\n\t}\n}\nEXPORT_SYMBOL_GPL(crypto_remove_final);\n\nint crypto_register_alg(struct crypto_alg *alg)\n{\n\tstruct crypto_larval *larval;\n\tLIST_HEAD(algs_to_put);\n\tbool test_started = false;\n\tint err;\n\n\talg->cra_flags &= ~CRYPTO_ALG_DEAD;\n\terr = crypto_check_alg(alg);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&crypto_alg_sem);\n\tlarval = __crypto_register_alg(alg, &algs_to_put);\n\tif (!IS_ERR_OR_NULL(larval)) {\n\t\ttest_started = crypto_boot_test_finished();\n\t\tlarval->test_started = test_started;\n\t}\n\tup_write(&crypto_alg_sem);\n\n\tif (IS_ERR(larval))\n\t\treturn PTR_ERR(larval);\n\tif (test_started)\n\t\tcrypto_wait_for_test(larval);\n\tcrypto_remove_final(&algs_to_put);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(crypto_register_alg);\n\nstatic int crypto_remove_alg(struct crypto_alg *alg, struct list_head *list)\n{\n\tif (unlikely(list_empty(&alg->cra_list)))\n\t\treturn -ENOENT;\n\n\talg->cra_flags |= CRYPTO_ALG_DEAD;\n\n\tlist_del_init(&alg->cra_list);\n\tcrypto_remove_spawns(alg, list, NULL);\n\n\treturn 0;\n}\n\nvoid crypto_unregister_alg(struct crypto_alg *alg)\n{\n\tint ret;\n\tLIST_HEAD(list);\n\n\tdown_write(&crypto_alg_sem);\n\tret = crypto_remove_alg(alg, &list);\n\tup_write(&crypto_alg_sem);\n\n\tif (WARN(ret, \"Algorithm %s is not registered\", alg->cra_driver_name))\n\t\treturn;\n\n\tif (WARN_ON(refcount_read(&alg->cra_refcnt) != 1))\n\t\treturn;\n\n\tif (alg->cra_destroy)\n\t\talg->cra_destroy(alg);\n\n\tcrypto_remove_final(&list);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_alg);\n\nint crypto_register_algs(struct crypto_alg *algs, int count)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = crypto_register_alg(&algs[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (--i; i >= 0; --i)\n\t\tcrypto_unregister_alg(&algs[i]);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(crypto_register_algs);\n\nvoid crypto_unregister_algs(struct crypto_alg *algs, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tcrypto_unregister_alg(&algs[i]);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_algs);\n\nint crypto_register_template(struct crypto_template *tmpl)\n{\n\tstruct crypto_template *q;\n\tint err = -EEXIST;\n\n\tdown_write(&crypto_alg_sem);\n\n\tcrypto_check_module_sig(tmpl->module);\n\n\tlist_for_each_entry(q, &crypto_template_list, list) {\n\t\tif (q == tmpl)\n\t\t\tgoto out;\n\t}\n\n\tlist_add(&tmpl->list, &crypto_template_list);\n\terr = 0;\nout:\n\tup_write(&crypto_alg_sem);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(crypto_register_template);\n\nint crypto_register_templates(struct crypto_template *tmpls, int count)\n{\n\tint i, err;\n\n\tfor (i = 0; i < count; i++) {\n\t\terr = crypto_register_template(&tmpls[i]);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\treturn 0;\n\nout:\n\tfor (--i; i >= 0; --i)\n\t\tcrypto_unregister_template(&tmpls[i]);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(crypto_register_templates);\n\nvoid crypto_unregister_template(struct crypto_template *tmpl)\n{\n\tstruct crypto_instance *inst;\n\tstruct hlist_node *n;\n\tstruct hlist_head *list;\n\tLIST_HEAD(users);\n\n\tdown_write(&crypto_alg_sem);\n\n\tBUG_ON(list_empty(&tmpl->list));\n\tlist_del_init(&tmpl->list);\n\n\tlist = &tmpl->instances;\n\thlist_for_each_entry(inst, list, list) {\n\t\tint err = crypto_remove_alg(&inst->alg, &users);\n\n\t\tBUG_ON(err);\n\t}\n\n\tup_write(&crypto_alg_sem);\n\n\thlist_for_each_entry_safe(inst, n, list, list) {\n\t\tBUG_ON(refcount_read(&inst->alg.cra_refcnt) != 1);\n\t\tcrypto_free_instance(inst);\n\t}\n\tcrypto_remove_final(&users);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_template);\n\nvoid crypto_unregister_templates(struct crypto_template *tmpls, int count)\n{\n\tint i;\n\n\tfor (i = count - 1; i >= 0; --i)\n\t\tcrypto_unregister_template(&tmpls[i]);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_templates);\n\nstatic struct crypto_template *__crypto_lookup_template(const char *name)\n{\n\tstruct crypto_template *q, *tmpl = NULL;\n\n\tdown_read(&crypto_alg_sem);\n\tlist_for_each_entry(q, &crypto_template_list, list) {\n\t\tif (strcmp(q->name, name))\n\t\t\tcontinue;\n\t\tif (unlikely(!crypto_tmpl_get(q)))\n\t\t\tcontinue;\n\n\t\ttmpl = q;\n\t\tbreak;\n\t}\n\tup_read(&crypto_alg_sem);\n\n\treturn tmpl;\n}\n\nstruct crypto_template *crypto_lookup_template(const char *name)\n{\n\treturn try_then_request_module(__crypto_lookup_template(name),\n\t\t\t\t       \"crypto-%s\", name);\n}\nEXPORT_SYMBOL_GPL(crypto_lookup_template);\n\nint crypto_register_instance(struct crypto_template *tmpl,\n\t\t\t     struct crypto_instance *inst)\n{\n\tstruct crypto_larval *larval;\n\tstruct crypto_spawn *spawn;\n\tu32 fips_internal = 0;\n\tLIST_HEAD(algs_to_put);\n\tint err;\n\n\terr = crypto_check_alg(&inst->alg);\n\tif (err)\n\t\treturn err;\n\n\tinst->alg.cra_module = tmpl->module;\n\tinst->alg.cra_flags |= CRYPTO_ALG_INSTANCE;\n\n\tdown_write(&crypto_alg_sem);\n\n\tlarval = ERR_PTR(-EAGAIN);\n\tfor (spawn = inst->spawns; spawn;) {\n\t\tstruct crypto_spawn *next;\n\n\t\tif (spawn->dead)\n\t\t\tgoto unlock;\n\n\t\tnext = spawn->next;\n\t\tspawn->inst = inst;\n\t\tspawn->registered = true;\n\n\t\tfips_internal |= spawn->alg->cra_flags;\n\n\t\tcrypto_mod_put(spawn->alg);\n\n\t\tspawn = next;\n\t}\n\n\tinst->alg.cra_flags |= (fips_internal & CRYPTO_ALG_FIPS_INTERNAL);\n\n\tlarval = __crypto_register_alg(&inst->alg, &algs_to_put);\n\tif (IS_ERR(larval))\n\t\tgoto unlock;\n\telse if (larval)\n\t\tlarval->test_started = true;\n\n\thlist_add_head(&inst->list, &tmpl->instances);\n\tinst->tmpl = tmpl;\n\nunlock:\n\tup_write(&crypto_alg_sem);\n\n\tif (IS_ERR(larval))\n\t\treturn PTR_ERR(larval);\n\tif (larval)\n\t\tcrypto_wait_for_test(larval);\n\tcrypto_remove_final(&algs_to_put);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(crypto_register_instance);\n\nvoid crypto_unregister_instance(struct crypto_instance *inst)\n{\n\tLIST_HEAD(list);\n\n\tdown_write(&crypto_alg_sem);\n\n\tcrypto_remove_spawns(&inst->alg, &list, NULL);\n\tcrypto_remove_instance(inst, &list);\n\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_remove_final(&list);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_instance);\n\nint crypto_grab_spawn(struct crypto_spawn *spawn, struct crypto_instance *inst,\n\t\t      const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\tint err = -EAGAIN;\n\n\tif (WARN_ON_ONCE(inst == NULL))\n\t\treturn -EINVAL;\n\n\t \n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\talg = crypto_find_alg(name, spawn->frontend,\n\t\t\t      type | CRYPTO_ALG_FIPS_INTERNAL, mask);\n\tif (IS_ERR(alg))\n\t\treturn PTR_ERR(alg);\n\n\tdown_write(&crypto_alg_sem);\n\tif (!crypto_is_moribund(alg)) {\n\t\tlist_add(&spawn->list, &alg->cra_users);\n\t\tspawn->alg = alg;\n\t\tspawn->mask = mask;\n\t\tspawn->next = inst->spawns;\n\t\tinst->spawns = spawn;\n\t\tinst->alg.cra_flags |=\n\t\t\t(alg->cra_flags & CRYPTO_ALG_INHERITED_FLAGS);\n\t\terr = 0;\n\t}\n\tup_write(&crypto_alg_sem);\n\tif (err)\n\t\tcrypto_mod_put(alg);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(crypto_grab_spawn);\n\nvoid crypto_drop_spawn(struct crypto_spawn *spawn)\n{\n\tif (!spawn->alg)  \n\t\treturn;\n\n\tdown_write(&crypto_alg_sem);\n\tif (!spawn->dead)\n\t\tlist_del(&spawn->list);\n\tup_write(&crypto_alg_sem);\n\n\tif (!spawn->registered)\n\t\tcrypto_mod_put(spawn->alg);\n}\nEXPORT_SYMBOL_GPL(crypto_drop_spawn);\n\nstatic struct crypto_alg *crypto_spawn_alg(struct crypto_spawn *spawn)\n{\n\tstruct crypto_alg *alg = ERR_PTR(-EAGAIN);\n\tstruct crypto_alg *target;\n\tbool shoot = false;\n\n\tdown_read(&crypto_alg_sem);\n\tif (!spawn->dead) {\n\t\talg = spawn->alg;\n\t\tif (!crypto_mod_get(alg)) {\n\t\t\ttarget = crypto_alg_get(alg);\n\t\t\tshoot = true;\n\t\t\talg = ERR_PTR(-EAGAIN);\n\t\t}\n\t}\n\tup_read(&crypto_alg_sem);\n\n\tif (shoot) {\n\t\tcrypto_shoot_alg(target);\n\t\tcrypto_alg_put(target);\n\t}\n\n\treturn alg;\n}\n\nstruct crypto_tfm *crypto_spawn_tfm(struct crypto_spawn *spawn, u32 type,\n\t\t\t\t    u32 mask)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_tfm *tfm;\n\n\talg = crypto_spawn_alg(spawn);\n\tif (IS_ERR(alg))\n\t\treturn ERR_CAST(alg);\n\n\ttfm = ERR_PTR(-EINVAL);\n\tif (unlikely((alg->cra_flags ^ type) & mask))\n\t\tgoto out_put_alg;\n\n\ttfm = __crypto_alloc_tfm(alg, type, mask);\n\tif (IS_ERR(tfm))\n\t\tgoto out_put_alg;\n\n\treturn tfm;\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn tfm;\n}\nEXPORT_SYMBOL_GPL(crypto_spawn_tfm);\n\nvoid *crypto_spawn_tfm2(struct crypto_spawn *spawn)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_tfm *tfm;\n\n\talg = crypto_spawn_alg(spawn);\n\tif (IS_ERR(alg))\n\t\treturn ERR_CAST(alg);\n\n\ttfm = crypto_create_tfm(alg, spawn->frontend);\n\tif (IS_ERR(tfm))\n\t\tgoto out_put_alg;\n\n\treturn tfm;\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn tfm;\n}\nEXPORT_SYMBOL_GPL(crypto_spawn_tfm2);\n\nint crypto_register_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&crypto_chain, nb);\n}\nEXPORT_SYMBOL_GPL(crypto_register_notifier);\n\nint crypto_unregister_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&crypto_chain, nb);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_notifier);\n\nstruct crypto_attr_type *crypto_get_attr_type(struct rtattr **tb)\n{\n\tstruct rtattr *rta = tb[0];\n\tstruct crypto_attr_type *algt;\n\n\tif (!rta)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (RTA_PAYLOAD(rta) < sizeof(*algt))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (rta->rta_type != CRYPTOA_TYPE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\talgt = RTA_DATA(rta);\n\n\treturn algt;\n}\nEXPORT_SYMBOL_GPL(crypto_get_attr_type);\n\n \nint crypto_check_attr_type(struct rtattr **tb, u32 type, u32 *mask_ret)\n{\n\tstruct crypto_attr_type *algt;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\n\tif ((algt->type ^ type) & algt->mask)\n\t\treturn -EINVAL;\n\n\t*mask_ret = crypto_algt_inherited_mask(algt);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(crypto_check_attr_type);\n\nconst char *crypto_attr_alg_name(struct rtattr *rta)\n{\n\tstruct crypto_attr_alg *alga;\n\n\tif (!rta)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (RTA_PAYLOAD(rta) < sizeof(*alga))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (rta->rta_type != CRYPTOA_ALG)\n\t\treturn ERR_PTR(-EINVAL);\n\n\talga = RTA_DATA(rta);\n\talga->name[CRYPTO_MAX_ALG_NAME - 1] = 0;\n\n\treturn alga->name;\n}\nEXPORT_SYMBOL_GPL(crypto_attr_alg_name);\n\nint crypto_inst_setname(struct crypto_instance *inst, const char *name,\n\t\t\tstruct crypto_alg *alg)\n{\n\tif (snprintf(inst->alg.cra_name, CRYPTO_MAX_ALG_NAME, \"%s(%s)\", name,\n\t\t     alg->cra_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\tif (snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s(%s)\",\n\t\t     name, alg->cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(crypto_inst_setname);\n\nvoid crypto_init_queue(struct crypto_queue *queue, unsigned int max_qlen)\n{\n\tINIT_LIST_HEAD(&queue->list);\n\tqueue->backlog = &queue->list;\n\tqueue->qlen = 0;\n\tqueue->max_qlen = max_qlen;\n}\nEXPORT_SYMBOL_GPL(crypto_init_queue);\n\nint crypto_enqueue_request(struct crypto_queue *queue,\n\t\t\t   struct crypto_async_request *request)\n{\n\tint err = -EINPROGRESS;\n\n\tif (unlikely(queue->qlen >= queue->max_qlen)) {\n\t\tif (!(request->flags & CRYPTO_TFM_REQ_MAY_BACKLOG)) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t\terr = -EBUSY;\n\t\tif (queue->backlog == &queue->list)\n\t\t\tqueue->backlog = &request->list;\n\t}\n\n\tqueue->qlen++;\n\tlist_add_tail(&request->list, &queue->list);\n\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(crypto_enqueue_request);\n\nvoid crypto_enqueue_request_head(struct crypto_queue *queue,\n\t\t\t\t struct crypto_async_request *request)\n{\n\tif (unlikely(queue->qlen >= queue->max_qlen))\n\t\tqueue->backlog = queue->backlog->prev;\n\n\tqueue->qlen++;\n\tlist_add(&request->list, &queue->list);\n}\nEXPORT_SYMBOL_GPL(crypto_enqueue_request_head);\n\nstruct crypto_async_request *crypto_dequeue_request(struct crypto_queue *queue)\n{\n\tstruct list_head *request;\n\n\tif (unlikely(!queue->qlen))\n\t\treturn NULL;\n\n\tqueue->qlen--;\n\n\tif (queue->backlog != &queue->list)\n\t\tqueue->backlog = queue->backlog->next;\n\n\trequest = queue->list.next;\n\tlist_del(request);\n\n\treturn list_entry(request, struct crypto_async_request, list);\n}\nEXPORT_SYMBOL_GPL(crypto_dequeue_request);\n\nstatic inline void crypto_inc_byte(u8 *a, unsigned int size)\n{\n\tu8 *b = (a + size);\n\tu8 c;\n\n\tfor (; size; size--) {\n\t\tc = *--b + 1;\n\t\t*b = c;\n\t\tif (c)\n\t\t\tbreak;\n\t}\n}\n\nvoid crypto_inc(u8 *a, unsigned int size)\n{\n\t__be32 *b = (__be32 *)(a + size);\n\tu32 c;\n\n\tif (IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) ||\n\t    IS_ALIGNED((unsigned long)b, __alignof__(*b)))\n\t\tfor (; size >= 4; size -= 4) {\n\t\t\tc = be32_to_cpu(*--b) + 1;\n\t\t\t*b = cpu_to_be32(c);\n\t\t\tif (likely(c))\n\t\t\t\treturn;\n\t\t}\n\n\tcrypto_inc_byte(a, size);\n}\nEXPORT_SYMBOL_GPL(crypto_inc);\n\nunsigned int crypto_alg_extsize(struct crypto_alg *alg)\n{\n\treturn alg->cra_ctxsize +\n\t       (alg->cra_alignmask & ~(crypto_tfm_ctx_alignment() - 1));\n}\nEXPORT_SYMBOL_GPL(crypto_alg_extsize);\n\nint crypto_type_has_alg(const char *name, const struct crypto_type *frontend,\n\t\t\tu32 type, u32 mask)\n{\n\tint ret = 0;\n\tstruct crypto_alg *alg = crypto_find_alg(name, frontend, type, mask);\n\n\tif (!IS_ERR(alg)) {\n\t\tcrypto_mod_put(alg);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(crypto_type_has_alg);\n\nstatic void __init crypto_start_tests(void)\n{\n\tif (IS_ENABLED(CONFIG_CRYPTO_MANAGER_DISABLE_TESTS))\n\t\treturn;\n\n\tfor (;;) {\n\t\tstruct crypto_larval *larval = NULL;\n\t\tstruct crypto_alg *q;\n\n\t\tdown_write(&crypto_alg_sem);\n\n\t\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\t\tstruct crypto_larval *l;\n\n\t\t\tif (!crypto_is_larval(q))\n\t\t\t\tcontinue;\n\n\t\t\tl = (void *)q;\n\n\t\t\tif (!crypto_is_test_larval(l))\n\t\t\t\tcontinue;\n\n\t\t\tif (l->test_started)\n\t\t\t\tcontinue;\n\n\t\t\tl->test_started = true;\n\t\t\tlarval = l;\n\t\t\tbreak;\n\t\t}\n\n\t\tup_write(&crypto_alg_sem);\n\n\t\tif (!larval)\n\t\t\tbreak;\n\n\t\tcrypto_wait_for_test(larval);\n\t}\n\n\tset_crypto_boot_test_finished();\n}\n\nstatic int __init crypto_algapi_init(void)\n{\n\tcrypto_init_proc();\n\tcrypto_start_tests();\n\treturn 0;\n}\n\nstatic void __exit crypto_algapi_exit(void)\n{\n\tcrypto_exit_proc();\n}\n\n \nlate_initcall(crypto_algapi_init);\nmodule_exit(crypto_algapi_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Cryptographic algorithms API\");\nMODULE_SOFTDEP(\"pre: cryptomgr\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}