{
  "module_name": "cmac.c",
  "hash_id": "f3289378c8328d58232040ca73d1fbbb78ea8e4363e90986842a3d6a3f45ac46",
  "original_prompt": "Ingested from linux-6.6.14/crypto/cmac.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/hash.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n \nstruct cmac_tfm_ctx {\n\tstruct crypto_cipher *child;\n\tu8 ctx[];\n};\n\n \nstruct cmac_desc_ctx {\n\tunsigned int len;\n\tu8 ctx[];\n};\n\nstatic int crypto_cmac_digest_setkey(struct crypto_shash *parent,\n\t\t\t\t     const u8 *inkey, unsigned int keylen)\n{\n\tunsigned long alignmask = crypto_shash_alignmask(parent);\n\tstruct cmac_tfm_ctx *ctx = crypto_shash_ctx(parent);\n\tunsigned int bs = crypto_shash_blocksize(parent);\n\t__be64 *consts = PTR_ALIGN((void *)ctx->ctx,\n\t\t\t\t   (alignmask | (__alignof__(__be64) - 1)) + 1);\n\tu64 _const[2];\n\tint i, err = 0;\n\tu8 msb_mask, gfmask;\n\n\terr = crypto_cipher_setkey(ctx->child, inkey, keylen);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmemset(consts, 0, bs);\n\tcrypto_cipher_encrypt_one(ctx->child, (u8 *)consts, (u8 *)consts);\n\n\tswitch (bs) {\n\tcase 16:\n\t\tgfmask = 0x87;\n\t\t_const[0] = be64_to_cpu(consts[1]);\n\t\t_const[1] = be64_to_cpu(consts[0]);\n\n\t\t \n\t\tfor (i = 0; i < 4; i += 2) {\n\t\t\tmsb_mask = ((s64)_const[1] >> 63) & gfmask;\n\t\t\t_const[1] = (_const[1] << 1) | (_const[0] >> 63);\n\t\t\t_const[0] = (_const[0] << 1) ^ msb_mask;\n\n\t\t\tconsts[i + 0] = cpu_to_be64(_const[1]);\n\t\t\tconsts[i + 1] = cpu_to_be64(_const[0]);\n\t\t}\n\n\t\tbreak;\n\tcase 8:\n\t\tgfmask = 0x1B;\n\t\t_const[0] = be64_to_cpu(consts[0]);\n\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tmsb_mask = ((s64)_const[0] >> 63) & gfmask;\n\t\t\t_const[0] = (_const[0] << 1) ^ msb_mask;\n\n\t\t\tconsts[i] = cpu_to_be64(_const[0]);\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int crypto_cmac_digest_init(struct shash_desc *pdesc)\n{\n\tunsigned long alignmask = crypto_shash_alignmask(pdesc->tfm);\n\tstruct cmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tint bs = crypto_shash_blocksize(pdesc->tfm);\n\tu8 *prev = PTR_ALIGN((void *)ctx->ctx, alignmask + 1) + bs;\n\n\tctx->len = 0;\n\tmemset(prev, 0, bs);\n\n\treturn 0;\n}\n\nstatic int crypto_cmac_digest_update(struct shash_desc *pdesc, const u8 *p,\n\t\t\t\t     unsigned int len)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tunsigned long alignmask = crypto_shash_alignmask(parent);\n\tstruct cmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct cmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_blocksize(parent);\n\tu8 *odds = PTR_ALIGN((void *)ctx->ctx, alignmask + 1);\n\tu8 *prev = odds + bs;\n\n\t \n\tif ((ctx->len + len) <= bs) {\n\t\tmemcpy(odds + ctx->len, p, len);\n\t\tctx->len += len;\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(odds + ctx->len, p, bs - ctx->len);\n\tlen -= bs - ctx->len;\n\tp += bs - ctx->len;\n\n\tcrypto_xor(prev, odds, bs);\n\tcrypto_cipher_encrypt_one(tfm, prev, prev);\n\n\t \n\tctx->len = 0;\n\n\t \n\twhile (len > bs) {\n\t\tcrypto_xor(prev, p, bs);\n\t\tcrypto_cipher_encrypt_one(tfm, prev, prev);\n\t\tp += bs;\n\t\tlen -= bs;\n\t}\n\n\t \n\tif (len) {\n\t\tmemcpy(odds, p, len);\n\t\tctx->len = len;\n\t}\n\n\treturn 0;\n}\n\nstatic int crypto_cmac_digest_final(struct shash_desc *pdesc, u8 *out)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tunsigned long alignmask = crypto_shash_alignmask(parent);\n\tstruct cmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct cmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_blocksize(parent);\n\tu8 *consts = PTR_ALIGN((void *)tctx->ctx,\n\t\t\t       (alignmask | (__alignof__(__be64) - 1)) + 1);\n\tu8 *odds = PTR_ALIGN((void *)ctx->ctx, alignmask + 1);\n\tu8 *prev = odds + bs;\n\tunsigned int offset = 0;\n\n\tif (ctx->len != bs) {\n\t\tunsigned int rlen;\n\t\tu8 *p = odds + ctx->len;\n\n\t\t*p = 0x80;\n\t\tp++;\n\n\t\trlen = bs - ctx->len - 1;\n\t\tif (rlen)\n\t\t\tmemset(p, 0, rlen);\n\n\t\toffset += bs;\n\t}\n\n\tcrypto_xor(prev, odds, bs);\n\tcrypto_xor(prev, consts + offset, bs);\n\n\tcrypto_cipher_encrypt_one(tfm, out, prev);\n\n\treturn 0;\n}\n\nstatic int cmac_init_tfm(struct crypto_shash *tfm)\n{\n\tstruct shash_instance *inst = shash_alg_instance(tfm);\n\tstruct cmac_tfm_ctx *ctx = crypto_shash_ctx(tfm);\n\tstruct crypto_cipher_spawn *spawn;\n\tstruct crypto_cipher *cipher;\n\n\tspawn = shash_instance_ctx(inst);\n\tcipher = crypto_spawn_cipher(spawn);\n\tif (IS_ERR(cipher))\n\t\treturn PTR_ERR(cipher);\n\n\tctx->child = cipher;\n\n\treturn 0;\n}\n\nstatic int cmac_clone_tfm(struct crypto_shash *tfm, struct crypto_shash *otfm)\n{\n\tstruct cmac_tfm_ctx *octx = crypto_shash_ctx(otfm);\n\tstruct cmac_tfm_ctx *ctx = crypto_shash_ctx(tfm);\n\tstruct crypto_cipher *cipher;\n\n\tcipher = crypto_clone_cipher(octx->child);\n\tif (IS_ERR(cipher))\n\t\treturn PTR_ERR(cipher);\n\n\tctx->child = cipher;\n\n\treturn 0;\n}\n\nstatic void cmac_exit_tfm(struct crypto_shash *tfm)\n{\n\tstruct cmac_tfm_ctx *ctx = crypto_shash_ctx(tfm);\n\tcrypto_free_cipher(ctx->child);\n}\n\nstatic int cmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_cipher_spawn *spawn;\n\tstruct crypto_alg *alg;\n\tunsigned long alignmask;\n\tu32 mask;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tspawn = shash_instance_ctx(inst);\n\n\terr = crypto_grab_cipher(spawn, shash_crypto_instance(inst),\n\t\t\t\t crypto_attr_alg_name(tb[1]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\talg = crypto_spawn_cipher_alg(spawn);\n\n\tswitch (alg->cra_blocksize) {\n\tcase 16:\n\tcase 8:\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto err_free_inst;\n\t}\n\n\terr = crypto_inst_setname(shash_crypto_instance(inst), tmpl->name, alg);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\talignmask = alg->cra_alignmask;\n\tinst->alg.base.cra_alignmask = alignmask;\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = alg->cra_blocksize;\n\n\tinst->alg.digestsize = alg->cra_blocksize;\n\tinst->alg.descsize =\n\t\tALIGN(sizeof(struct cmac_desc_ctx), crypto_tfm_ctx_alignment())\n\t\t+ (alignmask & ~(crypto_tfm_ctx_alignment() - 1))\n\t\t+ alg->cra_blocksize * 2;\n\n\tinst->alg.base.cra_ctxsize =\n\t\tALIGN(sizeof(struct cmac_tfm_ctx), crypto_tfm_ctx_alignment())\n\t\t+ ((alignmask | (__alignof__(__be64) - 1)) &\n\t\t   ~(crypto_tfm_ctx_alignment() - 1))\n\t\t+ alg->cra_blocksize * 2;\n\n\tinst->alg.init = crypto_cmac_digest_init;\n\tinst->alg.update = crypto_cmac_digest_update;\n\tinst->alg.final = crypto_cmac_digest_final;\n\tinst->alg.setkey = crypto_cmac_digest_setkey;\n\tinst->alg.init_tfm = cmac_init_tfm;\n\tinst->alg.clone_tfm = cmac_clone_tfm;\n\tinst->alg.exit_tfm = cmac_exit_tfm;\n\n\tinst->free = shash_free_singlespawn_instance;\n\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tshash_free_singlespawn_instance(inst);\n\t}\n\treturn err;\n}\n\nstatic struct crypto_template crypto_cmac_tmpl = {\n\t.name = \"cmac\",\n\t.create = cmac_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_cmac_module_init(void)\n{\n\treturn crypto_register_template(&crypto_cmac_tmpl);\n}\n\nstatic void __exit crypto_cmac_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_cmac_tmpl);\n}\n\nsubsys_initcall(crypto_cmac_module_init);\nmodule_exit(crypto_cmac_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"CMAC keyed hash algorithm\");\nMODULE_ALIAS_CRYPTO(\"cmac\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}