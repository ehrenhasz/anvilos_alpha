{
  "module_name": "ghash-generic.c",
  "hash_id": "6460497d4d4c322f635ab2c5d5d7c8aa904289c632621f49d977bb65c2c8526a",
  "original_prompt": "Ingested from linux-6.6.14/crypto/ghash-generic.c",
  "human_readable_source": "\n \n\n \n\n#include <crypto/algapi.h>\n#include <crypto/gf128mul.h>\n#include <crypto/ghash.h>\n#include <crypto/internal/hash.h>\n#include <linux/crypto.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int ghash_init(struct shash_desc *desc)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\tmemset(dctx, 0, sizeof(*dctx));\n\n\treturn 0;\n}\n\nstatic int ghash_setkey(struct crypto_shash *tfm,\n\t\t\tconst u8 *key, unsigned int keylen)\n{\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(tfm);\n\tbe128 k;\n\n\tif (keylen != GHASH_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (ctx->gf128)\n\t\tgf128mul_free_4k(ctx->gf128);\n\n\tBUILD_BUG_ON(sizeof(k) != GHASH_BLOCK_SIZE);\n\tmemcpy(&k, key, GHASH_BLOCK_SIZE);  \n\tctx->gf128 = gf128mul_init_4k_lle(&k);\n\tmemzero_explicit(&k, GHASH_BLOCK_SIZE);\n\n\tif (!ctx->gf128)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int ghash_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *dst = dctx->buffer;\n\n\tif (dctx->bytes) {\n\t\tint n = min(srclen, dctx->bytes);\n\t\tu8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\n\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\n\t\twhile (n--)\n\t\t\t*pos++ ^= *src++;\n\n\t\tif (!dctx->bytes)\n\t\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t}\n\n\twhile (srclen >= GHASH_BLOCK_SIZE) {\n\t\tcrypto_xor(dst, src, GHASH_BLOCK_SIZE);\n\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t\tsrc += GHASH_BLOCK_SIZE;\n\t\tsrclen -= GHASH_BLOCK_SIZE;\n\t}\n\n\tif (srclen) {\n\t\tdctx->bytes = GHASH_BLOCK_SIZE - srclen;\n\t\twhile (srclen--)\n\t\t\t*dst++ ^= *src++;\n\t}\n\n\treturn 0;\n}\n\nstatic void ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)\n{\n\tu8 *dst = dctx->buffer;\n\n\tif (dctx->bytes) {\n\t\tu8 *tmp = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\n\n\t\twhile (dctx->bytes--)\n\t\t\t*tmp++ ^= 0;\n\n\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t}\n\n\tdctx->bytes = 0;\n}\n\nstatic int ghash_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *buf = dctx->buffer;\n\n\tghash_flush(ctx, dctx);\n\tmemcpy(dst, buf, GHASH_BLOCK_SIZE);\n\n\treturn 0;\n}\n\nstatic void ghash_exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct ghash_ctx *ctx = crypto_tfm_ctx(tfm);\n\tif (ctx->gf128)\n\t\tgf128mul_free_4k(ctx->gf128);\n}\n\nstatic struct shash_alg ghash_alg = {\n\t.digestsize\t= GHASH_DIGEST_SIZE,\n\t.init\t\t= ghash_init,\n\t.update\t\t= ghash_update,\n\t.final\t\t= ghash_final,\n\t.setkey\t\t= ghash_setkey,\n\t.descsize\t= sizeof(struct ghash_desc_ctx),\n\t.base\t\t= {\n\t\t.cra_name\t\t= \"ghash\",\n\t\t.cra_driver_name\t= \"ghash-generic\",\n\t\t.cra_priority\t\t= 100,\n\t\t.cra_blocksize\t\t= GHASH_BLOCK_SIZE,\n\t\t.cra_ctxsize\t\t= sizeof(struct ghash_ctx),\n\t\t.cra_module\t\t= THIS_MODULE,\n\t\t.cra_exit\t\t= ghash_exit_tfm,\n\t},\n};\n\nstatic int __init ghash_mod_init(void)\n{\n\treturn crypto_register_shash(&ghash_alg);\n}\n\nstatic void __exit ghash_mod_exit(void)\n{\n\tcrypto_unregister_shash(&ghash_alg);\n}\n\nsubsys_initcall(ghash_mod_init);\nmodule_exit(ghash_mod_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"GHASH hash function\");\nMODULE_ALIAS_CRYPTO(\"ghash\");\nMODULE_ALIAS_CRYPTO(\"ghash-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}