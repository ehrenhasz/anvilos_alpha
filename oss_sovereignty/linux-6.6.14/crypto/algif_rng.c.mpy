{
  "module_name": "algif_rng.c",
  "hash_id": "46b546d4b8536ed2da12c41afe8b90d8e632cdd80878b3b4cfe43edb94bc2173",
  "original_prompt": "Ingested from linux-6.6.14/crypto/algif_rng.c",
  "human_readable_source": " \n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <crypto/rng.h>\n#include <linux/random.h>\n#include <crypto/if_alg.h>\n#include <linux/net.h>\n#include <net/sock.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Stephan Mueller <smueller@chronox.de>\");\nMODULE_DESCRIPTION(\"User-space interface for random number generators\");\n\nstruct rng_ctx {\n#define MAXSIZE 128\n\tunsigned int len;\n\tstruct crypto_rng *drng;\n\tu8 *addtl;\n\tsize_t addtl_len;\n};\n\nstruct rng_parent_ctx {\n\tstruct crypto_rng *drng;\n\tu8 *entropy;\n};\n\nstatic void rng_reset_addtl(struct rng_ctx *ctx)\n{\n\tkfree_sensitive(ctx->addtl);\n\tctx->addtl = NULL;\n\tctx->addtl_len = 0;\n}\n\nstatic int _rng_recvmsg(struct crypto_rng *drng, struct msghdr *msg, size_t len,\n\t\t\tu8 *addtl, size_t addtl_len)\n{\n\tint err = 0;\n\tint genlen = 0;\n\tu8 result[MAXSIZE];\n\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > MAXSIZE)\n\t\tlen = MAXSIZE;\n\n\t \n\tmemset(result, 0, len);\n\n\t \n\tgenlen = crypto_rng_generate(drng, addtl, addtl_len, result, len);\n\tif (genlen < 0)\n\t\treturn genlen;\n\n\terr = memcpy_to_msg(msg, result, len);\n\tmemzero_explicit(result, len);\n\n\treturn err ? err : len;\n}\n\nstatic int rng_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct rng_ctx *ctx = ask->private;\n\n\treturn _rng_recvmsg(ctx->drng, msg, len, NULL, 0);\n}\n\nstatic int rng_test_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct rng_ctx *ctx = ask->private;\n\tint ret;\n\n\tlock_sock(sock->sk);\n\tret = _rng_recvmsg(ctx->drng, msg, len, ctx->addtl, ctx->addtl_len);\n\trng_reset_addtl(ctx);\n\trelease_sock(sock->sk);\n\n\treturn ret;\n}\n\nstatic int rng_test_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tint err;\n\tstruct alg_sock *ask = alg_sk(sock->sk);\n\tstruct rng_ctx *ctx = ask->private;\n\n\tlock_sock(sock->sk);\n\tif (len > MAXSIZE) {\n\t\terr = -EMSGSIZE;\n\t\tgoto unlock;\n\t}\n\n\trng_reset_addtl(ctx);\n\tctx->addtl = kmalloc(len, GFP_KERNEL);\n\tif (!ctx->addtl) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\terr = memcpy_from_msg(ctx->addtl, msg, len);\n\tif (err) {\n\t\trng_reset_addtl(ctx);\n\t\tgoto unlock;\n\t}\n\tctx->addtl_len = len;\n\nunlock:\n\trelease_sock(sock->sk);\n\treturn err ? err : len;\n}\n\nstatic struct proto_ops algif_rng_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.accept\t\t=\tsock_no_accept,\n\t.sendmsg\t=\tsock_no_sendmsg,\n\n\t.release\t=\taf_alg_release,\n\t.recvmsg\t=\trng_recvmsg,\n};\n\nstatic struct proto_ops __maybe_unused algif_rng_test_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.accept\t\t=\tsock_no_accept,\n\n\t.release\t=\taf_alg_release,\n\t.recvmsg\t=\trng_test_recvmsg,\n\t.sendmsg\t=\trng_test_sendmsg,\n};\n\nstatic void *rng_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct rng_parent_ctx *pctx;\n\tstruct crypto_rng *rng;\n\n\tpctx = kzalloc(sizeof(*pctx), GFP_KERNEL);\n\tif (!pctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trng = crypto_alloc_rng(name, type, mask);\n\tif (IS_ERR(rng)) {\n\t\tkfree(pctx);\n\t\treturn ERR_CAST(rng);\n\t}\n\n\tpctx->drng = rng;\n\treturn pctx;\n}\n\nstatic void rng_release(void *private)\n{\n\tstruct rng_parent_ctx *pctx = private;\n\n\tif (unlikely(!pctx))\n\t\treturn;\n\tcrypto_free_rng(pctx->drng);\n\tkfree_sensitive(pctx->entropy);\n\tkfree_sensitive(pctx);\n}\n\nstatic void rng_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct rng_ctx *ctx = ask->private;\n\n\trng_reset_addtl(ctx);\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}\n\nstatic int rng_accept_parent(void *private, struct sock *sk)\n{\n\tstruct rng_ctx *ctx;\n\tstruct rng_parent_ctx *pctx = private;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->len = len;\n\tctx->addtl = NULL;\n\tctx->addtl_len = 0;\n\n\t \n\n\tctx->drng = pctx->drng;\n\task->private = ctx;\n\tsk->sk_destruct = rng_sock_destruct;\n\n\t \n\tif (IS_ENABLED(CONFIG_CRYPTO_USER_API_RNG_CAVP) && pctx->entropy)\n\t\tsk->sk_socket->ops = &algif_rng_test_ops;\n\n\treturn 0;\n}\n\nstatic int rng_setkey(void *private, const u8 *seed, unsigned int seedlen)\n{\n\tstruct rng_parent_ctx *pctx = private;\n\t \n\treturn crypto_rng_reset(pctx->drng, seed, seedlen);\n}\n\nstatic int __maybe_unused rng_setentropy(void *private, sockptr_t entropy,\n\t\t\t\t\t unsigned int len)\n{\n\tstruct rng_parent_ctx *pctx = private;\n\tu8 *kentropy = NULL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (pctx->entropy)\n\t\treturn -EINVAL;\n\n\tif (len > MAXSIZE)\n\t\treturn -EMSGSIZE;\n\n\tif (len) {\n\t\tkentropy = memdup_sockptr(entropy, len);\n\t\tif (IS_ERR(kentropy))\n\t\t\treturn PTR_ERR(kentropy);\n\t}\n\n\tcrypto_rng_alg(pctx->drng)->set_ent(pctx->drng, kentropy, len);\n\t \n\tpctx->entropy = kentropy;\n\treturn 0;\n}\n\nstatic const struct af_alg_type algif_type_rng = {\n\t.bind\t\t=\trng_bind,\n\t.release\t=\trng_release,\n\t.accept\t\t=\trng_accept_parent,\n\t.setkey\t\t=\trng_setkey,\n#ifdef CONFIG_CRYPTO_USER_API_RNG_CAVP\n\t.setentropy\t=\trng_setentropy,\n#endif\n\t.ops\t\t=\t&algif_rng_ops,\n\t.name\t\t=\t\"rng\",\n\t.owner\t\t=\tTHIS_MODULE\n};\n\nstatic int __init rng_init(void)\n{\n\treturn af_alg_register_type(&algif_type_rng);\n}\n\nstatic void __exit rng_exit(void)\n{\n\tint err = af_alg_unregister_type(&algif_type_rng);\n\tBUG_ON(err);\n}\n\nmodule_init(rng_init);\nmodule_exit(rng_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}