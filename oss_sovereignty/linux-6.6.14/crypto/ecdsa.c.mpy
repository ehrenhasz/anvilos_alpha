{
  "module_name": "ecdsa.c",
  "hash_id": "0fee082695ab188683bba7f337aba757951cb8ae7177e22078a1eac8a993668a",
  "original_prompt": "Ingested from linux-6.6.14/crypto/ecdsa.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <crypto/internal/akcipher.h>\n#include <crypto/internal/ecc.h>\n#include <crypto/akcipher.h>\n#include <crypto/ecdh.h>\n#include <linux/asn1_decoder.h>\n#include <linux/scatterlist.h>\n\n#include \"ecdsasignature.asn1.h\"\n\nstruct ecc_ctx {\n\tunsigned int curve_id;\n\tconst struct ecc_curve *curve;\n\n\tbool pub_key_set;\n\tu64 x[ECC_MAX_DIGITS];  \n\tu64 y[ECC_MAX_DIGITS];\n\tstruct ecc_point pub_key;\n};\n\nstruct ecdsa_signature_ctx {\n\tconst struct ecc_curve *curve;\n\tu64 r[ECC_MAX_DIGITS];\n\tu64 s[ECC_MAX_DIGITS];\n};\n\n \nstatic int ecdsa_get_signature_rs(u64 *dest, size_t hdrlen, unsigned char tag,\n\t\t\t\t  const void *value, size_t vlen, unsigned int ndigits)\n{\n\tsize_t keylen = ndigits * sizeof(u64);\n\tssize_t diff = vlen - keylen;\n\tconst char *d = value;\n\tu8 rs[ECC_MAX_BYTES];\n\n\tif (!value || !vlen)\n\t\treturn -EINVAL;\n\n\t \n\tif (diff > 0) {\n\t\t \n\t\tif (*d == 0) {\n\t\t\tvlen -= 1;\n\t\t\tdiff--;\n\t\t\td++;\n\t\t}\n\t\tif (diff)\n\t\t\treturn -EINVAL;\n\t}\n\tif (-diff >= keylen)\n\t\treturn -EINVAL;\n\n\tif (diff) {\n\t\t \n\t\tmemset(rs, 0, -diff);\n\t}\n\n\tmemcpy(&rs[-diff], d, vlen);\n\n\tecc_swap_digits((u64 *)rs, dest, ndigits);\n\n\treturn 0;\n}\n\nint ecdsa_get_signature_r(void *context, size_t hdrlen, unsigned char tag,\n\t\t\t  const void *value, size_t vlen)\n{\n\tstruct ecdsa_signature_ctx *sig = context;\n\n\treturn ecdsa_get_signature_rs(sig->r, hdrlen, tag, value, vlen,\n\t\t\t\t      sig->curve->g.ndigits);\n}\n\nint ecdsa_get_signature_s(void *context, size_t hdrlen, unsigned char tag,\n\t\t\t  const void *value, size_t vlen)\n{\n\tstruct ecdsa_signature_ctx *sig = context;\n\n\treturn ecdsa_get_signature_rs(sig->s, hdrlen, tag, value, vlen,\n\t\t\t\t      sig->curve->g.ndigits);\n}\n\nstatic int _ecdsa_verify(struct ecc_ctx *ctx, const u64 *hash, const u64 *r, const u64 *s)\n{\n\tconst struct ecc_curve *curve = ctx->curve;\n\tunsigned int ndigits = curve->g.ndigits;\n\tu64 s1[ECC_MAX_DIGITS];\n\tu64 u1[ECC_MAX_DIGITS];\n\tu64 u2[ECC_MAX_DIGITS];\n\tu64 x1[ECC_MAX_DIGITS];\n\tu64 y1[ECC_MAX_DIGITS];\n\tstruct ecc_point res = ECC_POINT_INIT(x1, y1, ndigits);\n\n\t \n\tif (vli_is_zero(r, ndigits) || vli_cmp(r, curve->n, ndigits) >= 0 ||\n\t    vli_is_zero(s, ndigits) || vli_cmp(s, curve->n, ndigits) >= 0)\n\t\treturn -EBADMSG;\n\n\t \n\tpr_devel(\"hash : %016llx %016llx ... %016llx\\n\",\n\t\t hash[ndigits - 1], hash[ndigits - 2], hash[0]);\n\n\t \n\tvli_mod_inv(s1, s, curve->n, ndigits);\n\t \n\tvli_mod_mult_slow(u1, hash, s1, curve->n, ndigits);\n\t \n\tvli_mod_mult_slow(u2, r, s1, curve->n, ndigits);\n\t \n\tecc_point_mult_shamir(&res, u1, &curve->g, u2, &ctx->pub_key, curve);\n\n\t \n\tif (unlikely(vli_cmp(res.x, curve->n, ndigits) == 1))\n\t\t \n\t\tvli_sub(res.x, res.x, curve->n, ndigits);\n\n\tif (!vli_cmp(res.x, r, ndigits))\n\t\treturn 0;\n\n\treturn -EKEYREJECTED;\n}\n\n \nstatic int ecdsa_verify(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct ecc_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tsize_t keylen = ctx->curve->g.ndigits * sizeof(u64);\n\tstruct ecdsa_signature_ctx sig_ctx = {\n\t\t.curve = ctx->curve,\n\t};\n\tu8 rawhash[ECC_MAX_BYTES];\n\tu64 hash[ECC_MAX_DIGITS];\n\tunsigned char *buffer;\n\tssize_t diff;\n\tint ret;\n\n\tif (unlikely(!ctx->pub_key_set))\n\t\treturn -EINVAL;\n\n\tbuffer = kmalloc(req->src_len + req->dst_len, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tsg_pcopy_to_buffer(req->src,\n\t\tsg_nents_for_len(req->src, req->src_len + req->dst_len),\n\t\tbuffer, req->src_len + req->dst_len, 0);\n\n\tret = asn1_ber_decoder(&ecdsasignature_decoder, &sig_ctx,\n\t\t\t       buffer, req->src_len);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tdiff = keylen - req->dst_len;\n\tif (diff >= 0) {\n\t\tif (diff)\n\t\t\tmemset(rawhash, 0, diff);\n\t\tmemcpy(&rawhash[diff], buffer + req->src_len, req->dst_len);\n\t} else if (diff < 0) {\n\t\t \n\t\tmemcpy(&rawhash, buffer + req->src_len, keylen);\n\t}\n\n\tecc_swap_digits((u64 *)rawhash, hash, ctx->curve->g.ndigits);\n\n\tret = _ecdsa_verify(ctx, hash, sig_ctx.r, sig_ctx.s);\n\nerror:\n\tkfree(buffer);\n\n\treturn ret;\n}\n\nstatic int ecdsa_ecc_ctx_init(struct ecc_ctx *ctx, unsigned int curve_id)\n{\n\tctx->curve_id = curve_id;\n\tctx->curve = ecc_get_curve(curve_id);\n\tif (!ctx->curve)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n\nstatic void ecdsa_ecc_ctx_deinit(struct ecc_ctx *ctx)\n{\n\tctx->pub_key_set = false;\n}\n\nstatic int ecdsa_ecc_ctx_reset(struct ecc_ctx *ctx)\n{\n\tunsigned int curve_id = ctx->curve_id;\n\tint ret;\n\n\tecdsa_ecc_ctx_deinit(ctx);\n\tret = ecdsa_ecc_ctx_init(ctx, curve_id);\n\tif (ret == 0)\n\t\tctx->pub_key = ECC_POINT_INIT(ctx->x, ctx->y,\n\t\t\t\t\t      ctx->curve->g.ndigits);\n\treturn ret;\n}\n\n \nstatic int ecdsa_set_pub_key(struct crypto_akcipher *tfm, const void *key, unsigned int keylen)\n{\n\tstruct ecc_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tconst unsigned char *d = key;\n\tconst u64 *digits = (const u64 *)&d[1];\n\tunsigned int ndigits;\n\tint ret;\n\n\tret = ecdsa_ecc_ctx_reset(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (keylen < 1 || (((keylen - 1) >> 1) % sizeof(u64)) != 0)\n\t\treturn -EINVAL;\n\t \n\tif (d[0] != 4)\n\t\treturn -EINVAL;\n\n\tkeylen--;\n\tndigits = (keylen >> 1) / sizeof(u64);\n\tif (ndigits != ctx->curve->g.ndigits)\n\t\treturn -EINVAL;\n\n\tecc_swap_digits(digits, ctx->pub_key.x, ndigits);\n\tecc_swap_digits(&digits[ndigits], ctx->pub_key.y, ndigits);\n\tret = ecc_is_pubkey_valid_full(ctx->curve, &ctx->pub_key);\n\n\tctx->pub_key_set = ret == 0;\n\n\treturn ret;\n}\n\nstatic void ecdsa_exit_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct ecc_ctx *ctx = akcipher_tfm_ctx(tfm);\n\n\tecdsa_ecc_ctx_deinit(ctx);\n}\n\nstatic unsigned int ecdsa_max_size(struct crypto_akcipher *tfm)\n{\n\tstruct ecc_ctx *ctx = akcipher_tfm_ctx(tfm);\n\n\treturn ctx->pub_key.ndigits << ECC_DIGITS_TO_BYTES_SHIFT;\n}\n\nstatic int ecdsa_nist_p384_init_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct ecc_ctx *ctx = akcipher_tfm_ctx(tfm);\n\n\treturn ecdsa_ecc_ctx_init(ctx, ECC_CURVE_NIST_P384);\n}\n\nstatic struct akcipher_alg ecdsa_nist_p384 = {\n\t.verify = ecdsa_verify,\n\t.set_pub_key = ecdsa_set_pub_key,\n\t.max_size = ecdsa_max_size,\n\t.init = ecdsa_nist_p384_init_tfm,\n\t.exit = ecdsa_exit_tfm,\n\t.base = {\n\t\t.cra_name = \"ecdsa-nist-p384\",\n\t\t.cra_driver_name = \"ecdsa-nist-p384-generic\",\n\t\t.cra_priority = 100,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct ecc_ctx),\n\t},\n};\n\nstatic int ecdsa_nist_p256_init_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct ecc_ctx *ctx = akcipher_tfm_ctx(tfm);\n\n\treturn ecdsa_ecc_ctx_init(ctx, ECC_CURVE_NIST_P256);\n}\n\nstatic struct akcipher_alg ecdsa_nist_p256 = {\n\t.verify = ecdsa_verify,\n\t.set_pub_key = ecdsa_set_pub_key,\n\t.max_size = ecdsa_max_size,\n\t.init = ecdsa_nist_p256_init_tfm,\n\t.exit = ecdsa_exit_tfm,\n\t.base = {\n\t\t.cra_name = \"ecdsa-nist-p256\",\n\t\t.cra_driver_name = \"ecdsa-nist-p256-generic\",\n\t\t.cra_priority = 100,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct ecc_ctx),\n\t},\n};\n\nstatic int ecdsa_nist_p192_init_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct ecc_ctx *ctx = akcipher_tfm_ctx(tfm);\n\n\treturn ecdsa_ecc_ctx_init(ctx, ECC_CURVE_NIST_P192);\n}\n\nstatic struct akcipher_alg ecdsa_nist_p192 = {\n\t.verify = ecdsa_verify,\n\t.set_pub_key = ecdsa_set_pub_key,\n\t.max_size = ecdsa_max_size,\n\t.init = ecdsa_nist_p192_init_tfm,\n\t.exit = ecdsa_exit_tfm,\n\t.base = {\n\t\t.cra_name = \"ecdsa-nist-p192\",\n\t\t.cra_driver_name = \"ecdsa-nist-p192-generic\",\n\t\t.cra_priority = 100,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct ecc_ctx),\n\t},\n};\nstatic bool ecdsa_nist_p192_registered;\n\nstatic int __init ecdsa_init(void)\n{\n\tint ret;\n\n\t \n\tret = crypto_register_akcipher(&ecdsa_nist_p192);\n\tecdsa_nist_p192_registered = ret == 0;\n\n\tret = crypto_register_akcipher(&ecdsa_nist_p256);\n\tif (ret)\n\t\tgoto nist_p256_error;\n\n\tret = crypto_register_akcipher(&ecdsa_nist_p384);\n\tif (ret)\n\t\tgoto nist_p384_error;\n\n\treturn 0;\n\nnist_p384_error:\n\tcrypto_unregister_akcipher(&ecdsa_nist_p256);\n\nnist_p256_error:\n\tif (ecdsa_nist_p192_registered)\n\t\tcrypto_unregister_akcipher(&ecdsa_nist_p192);\n\treturn ret;\n}\n\nstatic void __exit ecdsa_exit(void)\n{\n\tif (ecdsa_nist_p192_registered)\n\t\tcrypto_unregister_akcipher(&ecdsa_nist_p192);\n\tcrypto_unregister_akcipher(&ecdsa_nist_p256);\n\tcrypto_unregister_akcipher(&ecdsa_nist_p384);\n}\n\nsubsys_initcall(ecdsa_init);\nmodule_exit(ecdsa_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Stefan Berger <stefanb@linux.ibm.com>\");\nMODULE_DESCRIPTION(\"ECDSA generic algorithm\");\nMODULE_ALIAS_CRYPTO(\"ecdsa-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}