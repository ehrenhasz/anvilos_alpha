{
  "module_name": "md5.c",
  "hash_id": "229949f0e9fe16724b42d0dc985f6ff6bb3cf44f0881b68d0e44968852f58413",
  "original_prompt": "Ingested from linux-6.6.14/crypto/md5.c",
  "human_readable_source": " \n#include <crypto/internal/hash.h>\n#include <crypto/md5.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <asm/byteorder.h>\n\nconst u8 md5_zero_message_hash[MD5_DIGEST_SIZE] = {\n\t0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04,\n\t0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e,\n};\nEXPORT_SYMBOL_GPL(md5_zero_message_hash);\n\n#define F1(x, y, z)\t(z ^ (x & (y ^ z)))\n#define F2(x, y, z)\tF1(z, x, y)\n#define F3(x, y, z)\t(x ^ y ^ z)\n#define F4(x, y, z)\t(y ^ (x | ~z))\n\n#define MD5STEP(f, w, x, y, z, in, s) \\\n\t(w += f(x, y, z) + in, w = (w<<s | w>>(32-s)) + x)\n\nstatic void md5_transform(__u32 *hash, __u32 const *in)\n{\n\tu32 a, b, c, d;\n\n\ta = hash[0];\n\tb = hash[1];\n\tc = hash[2];\n\td = hash[3];\n\n\tMD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n\tMD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n\tMD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n\tMD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n\tMD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n\tMD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n\tMD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n\tMD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n\tMD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n\tMD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n\tMD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n\tMD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n\tMD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n\tMD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n\tMD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n\tMD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n\tMD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n\tMD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n\tMD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n\tMD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n\tMD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n\tMD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n\tMD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n\tMD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n\tMD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n\tMD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n\tMD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n\tMD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n\tMD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n\tMD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n\tMD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n\tMD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n\tMD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n\tMD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n\tMD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n\tMD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n\tMD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n\tMD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n\tMD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n\tMD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n\tMD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n\tMD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n\tMD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n\tMD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n\tMD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n\tMD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n\tMD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n\tMD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n\tMD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n\tMD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n\tMD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n\tMD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n\tMD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n\tMD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n\tMD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n\tMD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n\tMD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n\tMD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n\tMD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n\tMD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n\tMD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n\tMD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n\tMD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n\tMD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n\thash[0] += a;\n\thash[1] += b;\n\thash[2] += c;\n\thash[3] += d;\n}\n\nstatic inline void md5_transform_helper(struct md5_state *ctx)\n{\n\tle32_to_cpu_array(ctx->block, sizeof(ctx->block) / sizeof(u32));\n\tmd5_transform(ctx->hash, ctx->block);\n}\n\nstatic int md5_init(struct shash_desc *desc)\n{\n\tstruct md5_state *mctx = shash_desc_ctx(desc);\n\n\tmctx->hash[0] = MD5_H0;\n\tmctx->hash[1] = MD5_H1;\n\tmctx->hash[2] = MD5_H2;\n\tmctx->hash[3] = MD5_H3;\n\tmctx->byte_count = 0;\n\n\treturn 0;\n}\n\nstatic int md5_update(struct shash_desc *desc, const u8 *data, unsigned int len)\n{\n\tstruct md5_state *mctx = shash_desc_ctx(desc);\n\tconst u32 avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);\n\n\tmctx->byte_count += len;\n\n\tif (avail > len) {\n\t\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t\t       data, len);\n\t\treturn 0;\n\t}\n\n\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t       data, avail);\n\n\tmd5_transform_helper(mctx);\n\tdata += avail;\n\tlen -= avail;\n\n\twhile (len >= sizeof(mctx->block)) {\n\t\tmemcpy(mctx->block, data, sizeof(mctx->block));\n\t\tmd5_transform_helper(mctx);\n\t\tdata += sizeof(mctx->block);\n\t\tlen -= sizeof(mctx->block);\n\t}\n\n\tmemcpy(mctx->block, data, len);\n\n\treturn 0;\n}\n\nstatic int md5_final(struct shash_desc *desc, u8 *out)\n{\n\tstruct md5_state *mctx = shash_desc_ctx(desc);\n\tconst unsigned int offset = mctx->byte_count & 0x3f;\n\tchar *p = (char *)mctx->block + offset;\n\tint padding = 56 - (offset + 1);\n\n\t*p++ = 0x80;\n\tif (padding < 0) {\n\t\tmemset(p, 0x00, padding + sizeof (u64));\n\t\tmd5_transform_helper(mctx);\n\t\tp = (char *)mctx->block;\n\t\tpadding = 56;\n\t}\n\n\tmemset(p, 0, padding);\n\tmctx->block[14] = mctx->byte_count << 3;\n\tmctx->block[15] = mctx->byte_count >> 29;\n\tle32_to_cpu_array(mctx->block, (sizeof(mctx->block) -\n\t                  sizeof(u64)) / sizeof(u32));\n\tmd5_transform(mctx->hash, mctx->block);\n\tcpu_to_le32_array(mctx->hash, sizeof(mctx->hash) / sizeof(u32));\n\tmemcpy(out, mctx->hash, sizeof(mctx->hash));\n\tmemset(mctx, 0, sizeof(*mctx));\n\n\treturn 0;\n}\n\nstatic int md5_export(struct shash_desc *desc, void *out)\n{\n\tstruct md5_state *ctx = shash_desc_ctx(desc);\n\n\tmemcpy(out, ctx, sizeof(*ctx));\n\treturn 0;\n}\n\nstatic int md5_import(struct shash_desc *desc, const void *in)\n{\n\tstruct md5_state *ctx = shash_desc_ctx(desc);\n\n\tmemcpy(ctx, in, sizeof(*ctx));\n\treturn 0;\n}\n\nstatic struct shash_alg alg = {\n\t.digestsize\t=\tMD5_DIGEST_SIZE,\n\t.init\t\t=\tmd5_init,\n\t.update\t\t=\tmd5_update,\n\t.final\t\t=\tmd5_final,\n\t.export\t\t=\tmd5_export,\n\t.import\t\t=\tmd5_import,\n\t.descsize\t=\tsizeof(struct md5_state),\n\t.statesize\t=\tsizeof(struct md5_state),\n\t.base\t\t=\t{\n\t\t.cra_name\t =\t\"md5\",\n\t\t.cra_driver_name =\t\"md5-generic\",\n\t\t.cra_blocksize\t =\tMD5_HMAC_BLOCK_SIZE,\n\t\t.cra_module\t =\tTHIS_MODULE,\n\t}\n};\n\nstatic int __init md5_mod_init(void)\n{\n\treturn crypto_register_shash(&alg);\n}\n\nstatic void __exit md5_mod_fini(void)\n{\n\tcrypto_unregister_shash(&alg);\n}\n\nsubsys_initcall(md5_mod_init);\nmodule_exit(md5_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MD5 Message Digest Algorithm\");\nMODULE_ALIAS_CRYPTO(\"md5\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}