{
  "module_name": "internal.h",
  "hash_id": "7f858bdef6108bf291a9784ee40fc4f448c1df9751d660f2bdac1b8a81d4ac90",
  "original_prompt": "Ingested from linux-6.6.14/crypto/internal.h",
  "human_readable_source": " \n \n#ifndef _CRYPTO_INTERNAL_H\n#define _CRYPTO_INTERNAL_H\n\n#include <crypto/algapi.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/jump_label.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/numa.h>\n#include <linux/refcount.h>\n#include <linux/rwsem.h>\n#include <linux/scatterlist.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstruct akcipher_request;\nstruct crypto_akcipher;\nstruct crypto_instance;\nstruct crypto_template;\n\nstruct crypto_larval {\n\tstruct crypto_alg alg;\n\tstruct crypto_alg *adult;\n\tstruct completion completion;\n\tu32 mask;\n\tbool test_started;\n};\n\nstruct crypto_akcipher_sync_data {\n\tstruct crypto_akcipher *tfm;\n\tconst void *src;\n\tvoid *dst;\n\tunsigned int slen;\n\tunsigned int dlen;\n\n\tstruct akcipher_request *req;\n\tstruct crypto_wait cwait;\n\tstruct scatterlist sg;\n\tu8 *buf;\n};\n\nenum {\n\tCRYPTOA_UNSPEC,\n\tCRYPTOA_ALG,\n\tCRYPTOA_TYPE,\n\t__CRYPTOA_MAX,\n};\n\n#define CRYPTOA_MAX (__CRYPTOA_MAX - 1)\n\n \n#define CRYPTO_MAX_ATTRS 32\n\nextern struct list_head crypto_alg_list;\nextern struct rw_semaphore crypto_alg_sem;\nextern struct blocking_notifier_head crypto_chain;\n\nint alg_test(const char *driver, const char *alg, u32 type, u32 mask);\n\n#ifdef CONFIG_CRYPTO_MANAGER_DISABLE_TESTS\nstatic inline bool crypto_boot_test_finished(void)\n{\n\treturn true;\n}\nstatic inline void set_crypto_boot_test_finished(void)\n{\n}\n#else\nDECLARE_STATIC_KEY_FALSE(__crypto_boot_test_finished);\nstatic inline bool crypto_boot_test_finished(void)\n{\n\treturn static_branch_likely(&__crypto_boot_test_finished);\n}\nstatic inline void set_crypto_boot_test_finished(void)\n{\n\tstatic_branch_enable(&__crypto_boot_test_finished);\n}\n#endif  \n\n#ifdef CONFIG_PROC_FS\nvoid __init crypto_init_proc(void);\nvoid __exit crypto_exit_proc(void);\n#else\nstatic inline void crypto_init_proc(void)\n{ }\nstatic inline void crypto_exit_proc(void)\n{ }\n#endif\n\nstatic inline unsigned int crypto_cipher_ctxsize(struct crypto_alg *alg)\n{\n\treturn alg->cra_ctxsize;\n}\n\nstatic inline unsigned int crypto_compress_ctxsize(struct crypto_alg *alg)\n{\n\treturn alg->cra_ctxsize;\n}\n\nstruct crypto_alg *crypto_mod_get(struct crypto_alg *alg);\nstruct crypto_alg *crypto_alg_mod_lookup(const char *name, u32 type, u32 mask);\n\nstruct crypto_larval *crypto_larval_alloc(const char *name, u32 type, u32 mask);\nvoid crypto_larval_kill(struct crypto_alg *alg);\nvoid crypto_wait_for_test(struct crypto_larval *larval);\nvoid crypto_alg_tested(const char *name, int err);\n\nvoid crypto_remove_spawns(struct crypto_alg *alg, struct list_head *list,\n\t\t\t  struct crypto_alg *nalg);\nvoid crypto_remove_final(struct list_head *list);\nvoid crypto_shoot_alg(struct crypto_alg *alg);\nstruct crypto_tfm *__crypto_alloc_tfmgfp(struct crypto_alg *alg, u32 type,\n\t\t\t\t\t u32 mask, gfp_t gfp);\nstruct crypto_tfm *__crypto_alloc_tfm(struct crypto_alg *alg, u32 type,\n\t\t\t\t      u32 mask);\nvoid *crypto_create_tfm_node(struct crypto_alg *alg,\n\t\t\tconst struct crypto_type *frontend, int node);\nvoid *crypto_clone_tfm(const struct crypto_type *frontend,\n\t\t       struct crypto_tfm *otfm);\n\nint crypto_akcipher_sync_prep(struct crypto_akcipher_sync_data *data);\nint crypto_akcipher_sync_post(struct crypto_akcipher_sync_data *data, int err);\nint crypto_init_akcipher_ops_sig(struct crypto_tfm *tfm);\n\nstatic inline void *crypto_create_tfm(struct crypto_alg *alg,\n\t\t\tconst struct crypto_type *frontend)\n{\n\treturn crypto_create_tfm_node(alg, frontend, NUMA_NO_NODE);\n}\n\nstruct crypto_alg *crypto_find_alg(const char *alg_name,\n\t\t\t\t   const struct crypto_type *frontend,\n\t\t\t\t   u32 type, u32 mask);\n\nvoid *crypto_alloc_tfm_node(const char *alg_name,\n\t\t       const struct crypto_type *frontend, u32 type, u32 mask,\n\t\t       int node);\n\nstatic inline void *crypto_alloc_tfm(const char *alg_name,\n\t\t       const struct crypto_type *frontend, u32 type, u32 mask)\n{\n\treturn crypto_alloc_tfm_node(alg_name, frontend, type, mask, NUMA_NO_NODE);\n}\n\nint crypto_probing_notify(unsigned long val, void *v);\n\nunsigned int crypto_alg_extsize(struct crypto_alg *alg);\n\nint crypto_type_has_alg(const char *name, const struct crypto_type *frontend,\n\t\t\tu32 type, u32 mask);\n\nstatic inline struct crypto_alg *crypto_alg_get(struct crypto_alg *alg)\n{\n\trefcount_inc(&alg->cra_refcnt);\n\treturn alg;\n}\n\nstatic inline void crypto_alg_put(struct crypto_alg *alg)\n{\n\tif (refcount_dec_and_test(&alg->cra_refcnt) && alg->cra_destroy)\n\t\talg->cra_destroy(alg);\n}\n\nstatic inline int crypto_tmpl_get(struct crypto_template *tmpl)\n{\n\treturn try_module_get(tmpl->module);\n}\n\nstatic inline void crypto_tmpl_put(struct crypto_template *tmpl)\n{\n\tmodule_put(tmpl->module);\n}\n\nstatic inline int crypto_is_larval(struct crypto_alg *alg)\n{\n\treturn alg->cra_flags & CRYPTO_ALG_LARVAL;\n}\n\nstatic inline int crypto_is_dead(struct crypto_alg *alg)\n{\n\treturn alg->cra_flags & CRYPTO_ALG_DEAD;\n}\n\nstatic inline int crypto_is_moribund(struct crypto_alg *alg)\n{\n\treturn alg->cra_flags & (CRYPTO_ALG_DEAD | CRYPTO_ALG_DYING);\n}\n\nstatic inline void crypto_notify(unsigned long val, void *v)\n{\n\tblocking_notifier_call_chain(&crypto_chain, val, v);\n}\n\nstatic inline void crypto_yield(u32 flags)\n{\n\tif (flags & CRYPTO_TFM_REQ_MAY_SLEEP)\n\t\tcond_resched();\n}\n\nstatic inline int crypto_is_test_larval(struct crypto_larval *larval)\n{\n\treturn larval->alg.cra_driver_name[0];\n}\n\nstatic inline struct crypto_tfm *crypto_tfm_get(struct crypto_tfm *tfm)\n{\n\treturn refcount_inc_not_zero(&tfm->refcnt) ? tfm : ERR_PTR(-EOVERFLOW);\n}\n\n#endif\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}