{
  "module_name": "pcbc.c",
  "hash_id": "051764fd1c3eebdbb808445b01d0a490307831979a646efb06625de1ced540c7",
  "original_prompt": "Ingested from linux-6.6.14/crypto/pcbc.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int crypto_pcbc_encrypt_segment(struct skcipher_request *req,\n\t\t\t\t       struct skcipher_walk *walk,\n\t\t\t\t       struct crypto_cipher *tfm)\n{\n\tint bsize = crypto_cipher_blocksize(tfm);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tu8 *dst = walk->dst.virt.addr;\n\tu8 * const iv = walk->iv;\n\n\tdo {\n\t\tcrypto_xor(iv, src, bsize);\n\t\tcrypto_cipher_encrypt_one(tfm, dst, iv);\n\t\tcrypto_xor_cpy(iv, dst, src, bsize);\n\n\t\tsrc += bsize;\n\t\tdst += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_pcbc_encrypt_inplace(struct skcipher_request *req,\n\t\t\t\t       struct skcipher_walk *walk,\n\t\t\t\t       struct crypto_cipher *tfm)\n{\n\tint bsize = crypto_cipher_blocksize(tfm);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tu8 * const iv = walk->iv;\n\tu8 tmpbuf[MAX_CIPHER_BLOCKSIZE];\n\n\tdo {\n\t\tmemcpy(tmpbuf, src, bsize);\n\t\tcrypto_xor(iv, src, bsize);\n\t\tcrypto_cipher_encrypt_one(tfm, src, iv);\n\t\tcrypto_xor_cpy(iv, tmpbuf, src, bsize);\n\n\t\tsrc += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_pcbc_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct crypto_cipher *cipher = skcipher_cipher_simple(tfm);\n\tstruct skcipher_walk walk;\n\tunsigned int nbytes;\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile ((nbytes = walk.nbytes)) {\n\t\tif (walk.src.virt.addr == walk.dst.virt.addr)\n\t\t\tnbytes = crypto_pcbc_encrypt_inplace(req, &walk,\n\t\t\t\t\t\t\t     cipher);\n\t\telse\n\t\t\tnbytes = crypto_pcbc_encrypt_segment(req, &walk,\n\t\t\t\t\t\t\t     cipher);\n\t\terr = skcipher_walk_done(&walk, nbytes);\n\t}\n\n\treturn err;\n}\n\nstatic int crypto_pcbc_decrypt_segment(struct skcipher_request *req,\n\t\t\t\t       struct skcipher_walk *walk,\n\t\t\t\t       struct crypto_cipher *tfm)\n{\n\tint bsize = crypto_cipher_blocksize(tfm);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tu8 *dst = walk->dst.virt.addr;\n\tu8 * const iv = walk->iv;\n\n\tdo {\n\t\tcrypto_cipher_decrypt_one(tfm, dst, src);\n\t\tcrypto_xor(dst, iv, bsize);\n\t\tcrypto_xor_cpy(iv, dst, src, bsize);\n\n\t\tsrc += bsize;\n\t\tdst += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_pcbc_decrypt_inplace(struct skcipher_request *req,\n\t\t\t\t       struct skcipher_walk *walk,\n\t\t\t\t       struct crypto_cipher *tfm)\n{\n\tint bsize = crypto_cipher_blocksize(tfm);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *src = walk->src.virt.addr;\n\tu8 * const iv = walk->iv;\n\tu8 tmpbuf[MAX_CIPHER_BLOCKSIZE] __aligned(__alignof__(u32));\n\n\tdo {\n\t\tmemcpy(tmpbuf, src, bsize);\n\t\tcrypto_cipher_decrypt_one(tfm, src, src);\n\t\tcrypto_xor(src, iv, bsize);\n\t\tcrypto_xor_cpy(iv, src, tmpbuf, bsize);\n\n\t\tsrc += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\treturn nbytes;\n}\n\nstatic int crypto_pcbc_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct crypto_cipher *cipher = skcipher_cipher_simple(tfm);\n\tstruct skcipher_walk walk;\n\tunsigned int nbytes;\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile ((nbytes = walk.nbytes)) {\n\t\tif (walk.src.virt.addr == walk.dst.virt.addr)\n\t\t\tnbytes = crypto_pcbc_decrypt_inplace(req, &walk,\n\t\t\t\t\t\t\t     cipher);\n\t\telse\n\t\t\tnbytes = crypto_pcbc_decrypt_segment(req, &walk,\n\t\t\t\t\t\t\t     cipher);\n\t\terr = skcipher_walk_done(&walk, nbytes);\n\t}\n\n\treturn err;\n}\n\nstatic int crypto_pcbc_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct skcipher_instance *inst;\n\tint err;\n\n\tinst = skcipher_alloc_instance_simple(tmpl, tb);\n\tif (IS_ERR(inst))\n\t\treturn PTR_ERR(inst);\n\n\tinst->alg.encrypt = crypto_pcbc_encrypt;\n\tinst->alg.decrypt = crypto_pcbc_decrypt;\n\n\terr = skcipher_register_instance(tmpl, inst);\n\tif (err)\n\t\tinst->free(inst);\n\n\treturn err;\n}\n\nstatic struct crypto_template crypto_pcbc_tmpl = {\n\t.name = \"pcbc\",\n\t.create = crypto_pcbc_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_pcbc_module_init(void)\n{\n\treturn crypto_register_template(&crypto_pcbc_tmpl);\n}\n\nstatic void __exit crypto_pcbc_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_pcbc_tmpl);\n}\n\nsubsys_initcall(crypto_pcbc_module_init);\nmodule_exit(crypto_pcbc_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PCBC block cipher mode of operation\");\nMODULE_ALIAS_CRYPTO(\"pcbc\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}