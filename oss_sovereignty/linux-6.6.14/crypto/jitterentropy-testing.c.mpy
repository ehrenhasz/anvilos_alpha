{
  "module_name": "jitterentropy-testing.c",
  "hash_id": "12594f4a5bb3e777dce4ac7242a75513330e598ab6f2511b1b3de7d594d068e3",
  "original_prompt": "Ingested from linux-6.6.14/crypto/jitterentropy-testing.c",
  "human_readable_source": " \n \n\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#include \"jitterentropy.h\"\n\n#define JENT_TEST_RINGBUFFER_SIZE\t(1<<10)\n#define JENT_TEST_RINGBUFFER_MASK\t(JENT_TEST_RINGBUFFER_SIZE - 1)\n\nstruct jent_testing {\n\tu32 jent_testing_rb[JENT_TEST_RINGBUFFER_SIZE];\n\tu32 rb_reader;\n\tatomic_t rb_writer;\n\tatomic_t jent_testing_enabled;\n\tspinlock_t lock;\n\twait_queue_head_t read_wait;\n};\n\nstatic struct dentry *jent_raw_debugfs_root = NULL;\n\n \n\n \n\nstatic void jent_testing_reset(struct jent_testing *data)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\tdata->rb_reader = 0;\n\tatomic_set(&data->rb_writer, 0);\n\tspin_unlock_irqrestore(&data->lock, flags);\n}\n\nstatic void jent_testing_data_init(struct jent_testing *data, u32 boot)\n{\n\t \n\tif (boot)\n\t\treturn;\n\n\tjent_testing_reset(data);\n\tatomic_set(&data->jent_testing_enabled, 1);\n\tpr_warn(\"Enabling data collection\\n\");\n}\n\nstatic void jent_testing_fini(struct jent_testing *data, u32 boot)\n{\n\t \n\tif (boot)\n\t\treturn;\n\n\tatomic_set(&data->jent_testing_enabled, 0);\n\tjent_testing_reset(data);\n\tpr_warn(\"Disabling data collection\\n\");\n}\n\nstatic bool jent_testing_store(struct jent_testing *data, u32 value,\n\t\t\t       u32 *boot)\n{\n\tunsigned long flags;\n\n\tif (!atomic_read(&data->jent_testing_enabled) && (*boot != 1))\n\t\treturn false;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\n\t \n\tif (*boot) {\n\t\tif (((u32)atomic_read(&data->rb_writer)) >\n\t\t     JENT_TEST_RINGBUFFER_SIZE) {\n\t\t\t*boot = 2;\n\t\t\tpr_warn_once(\"One time data collection test disabled\\n\");\n\t\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (atomic_read(&data->rb_writer) == 1)\n\t\t\tpr_warn(\"One time data collection test enabled\\n\");\n\t}\n\n\tdata->jent_testing_rb[((u32)atomic_read(&data->rb_writer)) &\n\t\t\t      JENT_TEST_RINGBUFFER_MASK] = value;\n\tatomic_inc(&data->rb_writer);\n\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\tif (wq_has_sleeper(&data->read_wait))\n\t\twake_up_interruptible(&data->read_wait);\n\n\treturn true;\n}\n\nstatic bool jent_testing_have_data(struct jent_testing *data)\n{\n\treturn ((((u32)atomic_read(&data->rb_writer)) &\n\t\t JENT_TEST_RINGBUFFER_MASK) !=\n\t\t (data->rb_reader & JENT_TEST_RINGBUFFER_MASK));\n}\n\nstatic int jent_testing_reader(struct jent_testing *data, u32 *boot,\n\t\t\t       u8 *outbuf, u32 outbuflen)\n{\n\tunsigned long flags;\n\tint collected_data = 0;\n\n\tjent_testing_data_init(data, *boot);\n\n\twhile (outbuflen) {\n\t\tu32 writer = (u32)atomic_read(&data->rb_writer);\n\n\t\tspin_lock_irqsave(&data->lock, flags);\n\n\t\t \n\t\tif (!writer || (writer == data->rb_reader)) {\n\n\t\t\tspin_unlock_irqrestore(&data->lock, flags);\n\n\t\t\t \n\t\t\tif (*boot) {\n\t\t\t\t*boot = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\twait_event_interruptible(data->read_wait,\n\t\t\t\t\t\t jent_testing_have_data(data));\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tcollected_data = -ERESTARTSYS;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (outbuflen < sizeof(u32)) {\n\t\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(outbuf, &data->jent_testing_rb[data->rb_reader],\n\t\t       sizeof(u32));\n\t\tdata->rb_reader++;\n\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\n\t\toutbuf += sizeof(u32);\n\t\toutbuflen -= sizeof(u32);\n\t\tcollected_data += sizeof(u32);\n\t}\n\nout:\n\tjent_testing_fini(data, *boot);\n\treturn collected_data;\n}\n\nstatic int jent_testing_extract_user(struct file *file, char __user *buf,\n\t\t\t\t     size_t nbytes, loff_t *ppos,\n\t\t\t\t     int (*reader)(u8 *outbuf, u32 outbuflen))\n{\n\tu8 *tmp, *tmp_aligned;\n\tint ret = 0, large_request = (nbytes > 256);\n\n\tif (!nbytes)\n\t\treturn 0;\n\n\t \n\ttmp = kmalloc(JENT_TEST_RINGBUFFER_SIZE + sizeof(u32), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\ttmp_aligned = PTR_ALIGN(tmp, sizeof(u32));\n\n\twhile (nbytes) {\n\t\tint i;\n\n\t\tif (large_request && need_resched()) {\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschedule();\n\t\t}\n\n\t\ti = min_t(int, nbytes, JENT_TEST_RINGBUFFER_SIZE);\n\t\ti = reader(tmp_aligned, i);\n\t\tif (i <= 0) {\n\t\t\tif (i < 0)\n\t\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(buf, tmp_aligned, i)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tnbytes -= i;\n\t\tbuf += i;\n\t\tret += i;\n\t}\n\n\tkfree_sensitive(tmp);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}\n\n \n\nstatic u32 boot_raw_hires_test = 0;\nmodule_param(boot_raw_hires_test, uint, 0644);\nMODULE_PARM_DESC(boot_raw_hires_test,\n\t\t \"Enable gathering boot time high resolution timer entropy of the first Jitter RNG entropy events\");\n\nstatic struct jent_testing jent_raw_hires = {\n\t.rb_reader = 0,\n\t.rb_writer = ATOMIC_INIT(0),\n\t.lock      = __SPIN_LOCK_UNLOCKED(jent_raw_hires.lock),\n\t.read_wait = __WAIT_QUEUE_HEAD_INITIALIZER(jent_raw_hires.read_wait)\n};\n\nint jent_raw_hires_entropy_store(__u32 value)\n{\n\treturn jent_testing_store(&jent_raw_hires, value, &boot_raw_hires_test);\n}\nEXPORT_SYMBOL(jent_raw_hires_entropy_store);\n\nstatic int jent_raw_hires_entropy_reader(u8 *outbuf, u32 outbuflen)\n{\n\treturn jent_testing_reader(&jent_raw_hires, &boot_raw_hires_test,\n\t\t\t\t   outbuf, outbuflen);\n}\n\nstatic ssize_t jent_raw_hires_read(struct file *file, char __user *to,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\treturn jent_testing_extract_user(file, to, count, ppos,\n\t\t\t\t\t jent_raw_hires_entropy_reader);\n}\n\nstatic const struct file_operations jent_raw_hires_fops = {\n\t.owner = THIS_MODULE,\n\t.read = jent_raw_hires_read,\n};\n\n \n\nvoid jent_testing_init(void)\n{\n\tjent_raw_debugfs_root = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\n\tdebugfs_create_file_unsafe(\"jent_raw_hires\", 0400,\n\t\t\t\t   jent_raw_debugfs_root, NULL,\n\t\t\t\t   &jent_raw_hires_fops);\n}\nEXPORT_SYMBOL(jent_testing_init);\n\nvoid jent_testing_exit(void)\n{\n\tdebugfs_remove_recursive(jent_raw_debugfs_root);\n}\nEXPORT_SYMBOL(jent_testing_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}