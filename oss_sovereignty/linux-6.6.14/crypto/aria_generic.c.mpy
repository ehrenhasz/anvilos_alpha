{
  "module_name": "aria_generic.c",
  "hash_id": "994eec263f00e86c08ceb79772ff3a899ccfd3e97da0d938907b925e027c0cc5",
  "original_prompt": "Ingested from linux-6.6.14/crypto/aria_generic.c",
  "human_readable_source": "\n \n\n#include <crypto/aria.h>\n\nstatic const u32 key_rc[20] = {\n\t0x517cc1b7, 0x27220a94, 0xfe13abe8, 0xfa9a6ee0,\n\t0x6db14acc, 0x9e21c820, 0xff28b1d5, 0xef5de2b0,\n\t0xdb92371d, 0x2126e970, 0x03249775, 0x04e8c90e,\n\t0x517cc1b7, 0x27220a94, 0xfe13abe8, 0xfa9a6ee0,\n\t0x6db14acc, 0x9e21c820, 0xff28b1d5, 0xef5de2b0\n};\n\nstatic void aria_set_encrypt_key(struct aria_ctx *ctx, const u8 *in_key,\n\t\t\t\t unsigned int key_len)\n{\n\tconst __be32 *key = (const __be32 *)in_key;\n\tu32 w0[4], w1[4], w2[4], w3[4];\n\tu32 reg0, reg1, reg2, reg3;\n\tconst u32 *ck;\n\tint rkidx = 0;\n\n\tck = &key_rc[(key_len - 16) / 2];\n\n\tw0[0] = be32_to_cpu(key[0]);\n\tw0[1] = be32_to_cpu(key[1]);\n\tw0[2] = be32_to_cpu(key[2]);\n\tw0[3] = be32_to_cpu(key[3]);\n\n\treg0 = w0[0] ^ ck[0];\n\treg1 = w0[1] ^ ck[1];\n\treg2 = w0[2] ^ ck[2];\n\treg3 = w0[3] ^ ck[3];\n\n\taria_subst_diff_odd(&reg0, &reg1, &reg2, &reg3);\n\n\tif (key_len > 16) {\n\t\tw1[0] = be32_to_cpu(key[4]);\n\t\tw1[1] = be32_to_cpu(key[5]);\n\t\tif (key_len > 24) {\n\t\t\tw1[2] = be32_to_cpu(key[6]);\n\t\t\tw1[3] = be32_to_cpu(key[7]);\n\t\t} else {\n\t\t\tw1[2] = 0;\n\t\t\tw1[3] = 0;\n\t\t}\n\t} else {\n\t\tw1[0] = 0;\n\t\tw1[1] = 0;\n\t\tw1[2] = 0;\n\t\tw1[3] = 0;\n\t}\n\n\tw1[0] ^= reg0;\n\tw1[1] ^= reg1;\n\tw1[2] ^= reg2;\n\tw1[3] ^= reg3;\n\n\treg0 = w1[0];\n\treg1 = w1[1];\n\treg2 = w1[2];\n\treg3 = w1[3];\n\n\treg0 ^= ck[4];\n\treg1 ^= ck[5];\n\treg2 ^= ck[6];\n\treg3 ^= ck[7];\n\n\taria_subst_diff_even(&reg0, &reg1, &reg2, &reg3);\n\n\treg0 ^= w0[0];\n\treg1 ^= w0[1];\n\treg2 ^= w0[2];\n\treg3 ^= w0[3];\n\n\tw2[0] = reg0;\n\tw2[1] = reg1;\n\tw2[2] = reg2;\n\tw2[3] = reg3;\n\n\treg0 ^= ck[8];\n\treg1 ^= ck[9];\n\treg2 ^= ck[10];\n\treg3 ^= ck[11];\n\n\taria_subst_diff_odd(&reg0, &reg1, &reg2, &reg3);\n\n\tw3[0] = reg0 ^ w1[0];\n\tw3[1] = reg1 ^ w1[1];\n\tw3[2] = reg2 ^ w1[2];\n\tw3[3] = reg3 ^ w1[3];\n\n\taria_gsrk(ctx->enc_key[rkidx], w0, w1, 19);\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w1, w2, 19);\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w2, w3, 19);\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w3, w0, 19);\n\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w0, w1, 31);\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w1, w2, 31);\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w2, w3, 31);\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w3, w0, 31);\n\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w0, w1, 67);\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w1, w2, 67);\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w2, w3, 67);\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w3, w0, 67);\n\n\trkidx++;\n\taria_gsrk(ctx->enc_key[rkidx], w0, w1, 97);\n\tif (key_len > 16) {\n\t\trkidx++;\n\t\taria_gsrk(ctx->enc_key[rkidx], w1, w2, 97);\n\t\trkidx++;\n\t\taria_gsrk(ctx->enc_key[rkidx], w2, w3, 97);\n\n\t\tif (key_len > 24) {\n\t\t\trkidx++;\n\t\t\taria_gsrk(ctx->enc_key[rkidx], w3, w0, 97);\n\n\t\t\trkidx++;\n\t\t\taria_gsrk(ctx->enc_key[rkidx], w0, w1, 109);\n\t\t}\n\t}\n}\n\nstatic void aria_set_decrypt_key(struct aria_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tctx->dec_key[0][i] = ctx->enc_key[ctx->rounds][i];\n\t\tctx->dec_key[ctx->rounds][i] = ctx->enc_key[0][i];\n\t}\n\n\tfor (i = 1; i < ctx->rounds; i++) {\n\t\tctx->dec_key[i][0] = aria_m(ctx->enc_key[ctx->rounds - i][0]);\n\t\tctx->dec_key[i][1] = aria_m(ctx->enc_key[ctx->rounds - i][1]);\n\t\tctx->dec_key[i][2] = aria_m(ctx->enc_key[ctx->rounds - i][2]);\n\t\tctx->dec_key[i][3] = aria_m(ctx->enc_key[ctx->rounds - i][3]);\n\n\t\taria_diff_word(&ctx->dec_key[i][0], &ctx->dec_key[i][1],\n\t\t\t       &ctx->dec_key[i][2], &ctx->dec_key[i][3]);\n\t\taria_diff_byte(&ctx->dec_key[i][1],\n\t\t\t       &ctx->dec_key[i][2], &ctx->dec_key[i][3]);\n\t\taria_diff_word(&ctx->dec_key[i][0], &ctx->dec_key[i][1],\n\t\t\t       &ctx->dec_key[i][2], &ctx->dec_key[i][3]);\n\t}\n}\n\nint aria_set_key(struct crypto_tfm *tfm, const u8 *in_key, unsigned int key_len)\n{\n\tstruct aria_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tif (key_len != 16 && key_len != 24 && key_len != 32)\n\t\treturn -EINVAL;\n\n\tBUILD_BUG_ON(sizeof(ctx->enc_key) != 272);\n\tBUILD_BUG_ON(sizeof(ctx->dec_key) != 272);\n\tBUILD_BUG_ON(sizeof(int) != sizeof(ctx->rounds));\n\n\tctx->key_length = key_len;\n\tctx->rounds = (key_len + 32) / 4;\n\n\taria_set_encrypt_key(ctx, in_key, key_len);\n\taria_set_decrypt_key(ctx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(aria_set_key);\n\nstatic void __aria_crypt(struct aria_ctx *ctx, u8 *out, const u8 *in,\n\t\t\t u32 key[][ARIA_RD_KEY_WORDS])\n{\n\tconst __be32 *src = (const __be32 *)in;\n\t__be32 *dst = (__be32 *)out;\n\tu32 reg0, reg1, reg2, reg3;\n\tint rounds, rkidx = 0;\n\n\trounds = ctx->rounds;\n\n\treg0 = be32_to_cpu(src[0]);\n\treg1 = be32_to_cpu(src[1]);\n\treg2 = be32_to_cpu(src[2]);\n\treg3 = be32_to_cpu(src[3]);\n\n\taria_add_round_key(key[rkidx], &reg0, &reg1, &reg2, &reg3);\n\trkidx++;\n\n\taria_subst_diff_odd(&reg0, &reg1, &reg2, &reg3);\n\taria_add_round_key(key[rkidx], &reg0, &reg1, &reg2, &reg3);\n\trkidx++;\n\n\twhile ((rounds -= 2) > 0) {\n\t\taria_subst_diff_even(&reg0, &reg1, &reg2, &reg3);\n\t\taria_add_round_key(key[rkidx], &reg0, &reg1, &reg2, &reg3);\n\t\trkidx++;\n\n\t\taria_subst_diff_odd(&reg0, &reg1, &reg2, &reg3);\n\t\taria_add_round_key(key[rkidx], &reg0, &reg1, &reg2, &reg3);\n\t\trkidx++;\n\t}\n\n\treg0 = key[rkidx][0] ^ make_u32((u8)(x1[get_u8(reg0, 0)]),\n\t\t\t\t\t(u8)(x2[get_u8(reg0, 1)] >> 8),\n\t\t\t\t\t(u8)(s1[get_u8(reg0, 2)]),\n\t\t\t\t\t(u8)(s2[get_u8(reg0, 3)]));\n\treg1 = key[rkidx][1] ^ make_u32((u8)(x1[get_u8(reg1, 0)]),\n\t\t\t\t\t(u8)(x2[get_u8(reg1, 1)] >> 8),\n\t\t\t\t\t(u8)(s1[get_u8(reg1, 2)]),\n\t\t\t\t\t(u8)(s2[get_u8(reg1, 3)]));\n\treg2 = key[rkidx][2] ^ make_u32((u8)(x1[get_u8(reg2, 0)]),\n\t\t\t\t\t(u8)(x2[get_u8(reg2, 1)] >> 8),\n\t\t\t\t\t(u8)(s1[get_u8(reg2, 2)]),\n\t\t\t\t\t(u8)(s2[get_u8(reg2, 3)]));\n\treg3 = key[rkidx][3] ^ make_u32((u8)(x1[get_u8(reg3, 0)]),\n\t\t\t\t\t(u8)(x2[get_u8(reg3, 1)] >> 8),\n\t\t\t\t\t(u8)(s1[get_u8(reg3, 2)]),\n\t\t\t\t\t(u8)(s2[get_u8(reg3, 3)]));\n\n\tdst[0] = cpu_to_be32(reg0);\n\tdst[1] = cpu_to_be32(reg1);\n\tdst[2] = cpu_to_be32(reg2);\n\tdst[3] = cpu_to_be32(reg3);\n}\n\nvoid aria_encrypt(void *_ctx, u8 *out, const u8 *in)\n{\n\tstruct aria_ctx *ctx = (struct aria_ctx *)_ctx;\n\n\t__aria_crypt(ctx, out, in, ctx->enc_key);\n}\nEXPORT_SYMBOL_GPL(aria_encrypt);\n\nvoid aria_decrypt(void *_ctx, u8 *out, const u8 *in)\n{\n\tstruct aria_ctx *ctx = (struct aria_ctx *)_ctx;\n\n\t__aria_crypt(ctx, out, in, ctx->dec_key);\n}\nEXPORT_SYMBOL_GPL(aria_decrypt);\n\nstatic void __aria_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\n{\n\tstruct aria_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t__aria_crypt(ctx, out, in, ctx->enc_key);\n}\n\nstatic void __aria_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\n{\n\tstruct aria_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t__aria_crypt(ctx, out, in, ctx->dec_key);\n}\n\nstatic struct crypto_alg aria_alg = {\n\t.cra_name\t\t=\t\"aria\",\n\t.cra_driver_name\t=\t\"aria-generic\",\n\t.cra_priority\t\t=\t100,\n\t.cra_flags\t\t=\tCRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize\t\t=\tARIA_BLOCK_SIZE,\n\t.cra_ctxsize\t\t=\tsizeof(struct aria_ctx),\n\t.cra_alignmask\t\t=\t3,\n\t.cra_module\t\t=\tTHIS_MODULE,\n\t.cra_u\t\t\t=\t{\n\t\t.cipher = {\n\t\t\t.cia_min_keysize\t=\tARIA_MIN_KEY_SIZE,\n\t\t\t.cia_max_keysize\t=\tARIA_MAX_KEY_SIZE,\n\t\t\t.cia_setkey\t\t=\taria_set_key,\n\t\t\t.cia_encrypt\t\t=\t__aria_encrypt,\n\t\t\t.cia_decrypt\t\t=\t__aria_decrypt\n\t\t}\n\t}\n};\n\nstatic int __init aria_init(void)\n{\n\treturn crypto_register_alg(&aria_alg);\n}\n\nstatic void __exit aria_fini(void)\n{\n\tcrypto_unregister_alg(&aria_alg);\n}\n\nsubsys_initcall(aria_init);\nmodule_exit(aria_fini);\n\nMODULE_DESCRIPTION(\"ARIA Cipher Algorithm\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Taehee Yoo <ap420073@gmail.com>\");\nMODULE_ALIAS_CRYPTO(\"aria\");\nMODULE_ALIAS_CRYPTO(\"aria-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}