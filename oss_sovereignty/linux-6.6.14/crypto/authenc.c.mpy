{
  "module_name": "authenc.c",
  "hash_id": "8dcd5623f96fcfaefc1b4d1c06e376e894b703237012bee0418f93d38356d4c1",
  "original_prompt": "Ingested from linux-6.6.14/crypto/authenc.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/aead.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/authenc.h>\n#include <crypto/null.h>\n#include <crypto/scatterwalk.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\nstruct authenc_instance_ctx {\n\tstruct crypto_ahash_spawn auth;\n\tstruct crypto_skcipher_spawn enc;\n\tunsigned int reqoff;\n};\n\nstruct crypto_authenc_ctx {\n\tstruct crypto_ahash *auth;\n\tstruct crypto_skcipher *enc;\n\tstruct crypto_sync_skcipher *null;\n};\n\nstruct authenc_request_ctx {\n\tstruct scatterlist src[2];\n\tstruct scatterlist dst[2];\n\tchar tail[];\n};\n\nstatic void authenc_request_complete(struct aead_request *req, int err)\n{\n\tif (err != -EINPROGRESS)\n\t\taead_request_complete(req, err);\n}\n\nint crypto_authenc_extractkeys(struct crypto_authenc_keys *keys, const u8 *key,\n\t\t\t       unsigned int keylen)\n{\n\tstruct rtattr *rta = (struct rtattr *)key;\n\tstruct crypto_authenc_key_param *param;\n\n\tif (!RTA_OK(rta, keylen))\n\t\treturn -EINVAL;\n\tif (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM)\n\t\treturn -EINVAL;\n\n\t \n\tif (RTA_PAYLOAD(rta) != sizeof(*param))\n\t\treturn -EINVAL;\n\tBUILD_BUG_ON(sizeof(*param) % RTA_ALIGNTO);\n\n\tparam = RTA_DATA(rta);\n\tkeys->enckeylen = be32_to_cpu(param->enckeylen);\n\n\tkey += rta->rta_len;\n\tkeylen -= rta->rta_len;\n\n\tif (keylen < keys->enckeylen)\n\t\treturn -EINVAL;\n\n\tkeys->authkeylen = keylen - keys->enckeylen;\n\tkeys->authkey = key;\n\tkeys->enckey = key + keys->authkeylen;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(crypto_authenc_extractkeys);\n\nstatic int crypto_authenc_setkey(struct crypto_aead *authenc, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct crypto_ahash *auth = ctx->auth;\n\tstruct crypto_skcipher *enc = ctx->enc;\n\tstruct crypto_authenc_keys keys;\n\tint err = -EINVAL;\n\n\tif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\n\t\tgoto out;\n\n\tcrypto_ahash_clear_flags(auth, CRYPTO_TFM_REQ_MASK);\n\tcrypto_ahash_set_flags(auth, crypto_aead_get_flags(authenc) &\n\t\t\t\t    CRYPTO_TFM_REQ_MASK);\n\terr = crypto_ahash_setkey(auth, keys.authkey, keys.authkeylen);\n\tif (err)\n\t\tgoto out;\n\n\tcrypto_skcipher_clear_flags(enc, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(enc, crypto_aead_get_flags(authenc) &\n\t\t\t\t       CRYPTO_TFM_REQ_MASK);\n\terr = crypto_skcipher_setkey(enc, keys.enckey, keys.enckeylen);\nout:\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn err;\n}\n\nstatic void authenc_geniv_ahash_done(void *data, int err)\n{\n\tstruct aead_request *req = data;\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tstruct aead_instance *inst = aead_alg_instance(authenc);\n\tstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ictx->reqoff);\n\n\tif (err)\n\t\tgoto out;\n\n\tscatterwalk_map_and_copy(ahreq->result, req->dst,\n\t\t\t\t req->assoclen + req->cryptlen,\n\t\t\t\t crypto_aead_authsize(authenc), 1);\n\nout:\n\taead_request_complete(req, err);\n}\n\nstatic int crypto_authenc_genicv(struct aead_request *req, unsigned int flags)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tstruct aead_instance *inst = aead_alg_instance(authenc);\n\tstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct crypto_ahash *auth = ctx->auth;\n\tstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ictx->reqoff);\n\tu8 *hash = areq_ctx->tail;\n\tint err;\n\n\thash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),\n\t\t\t   crypto_ahash_alignmask(auth) + 1);\n\n\tahash_request_set_tfm(ahreq, auth);\n\tahash_request_set_crypt(ahreq, req->dst, hash,\n\t\t\t\treq->assoclen + req->cryptlen);\n\tahash_request_set_callback(ahreq, flags,\n\t\t\t\t   authenc_geniv_ahash_done, req);\n\n\terr = crypto_ahash_digest(ahreq);\n\tif (err)\n\t\treturn err;\n\n\tscatterwalk_map_and_copy(hash, req->dst, req->assoclen + req->cryptlen,\n\t\t\t\t crypto_aead_authsize(authenc), 1);\n\n\treturn 0;\n}\n\nstatic void crypto_authenc_encrypt_done(void *data, int err)\n{\n\tstruct aead_request *areq = data;\n\n\tif (err)\n\t\tgoto out;\n\n\terr = crypto_authenc_genicv(areq, 0);\n\nout:\n\tauthenc_request_complete(areq, err);\n}\n\nstatic int crypto_authenc_copy_assoc(struct aead_request *req)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\n\tSYNC_SKCIPHER_REQUEST_ON_STACK(skreq, ctx->null);\n\n\tskcipher_request_set_sync_tfm(skreq, ctx->null);\n\tskcipher_request_set_callback(skreq, aead_request_flags(req),\n\t\t\t\t      NULL, NULL);\n\tskcipher_request_set_crypt(skreq, req->src, req->dst, req->assoclen,\n\t\t\t\t   NULL);\n\n\treturn crypto_skcipher_encrypt(skreq);\n}\n\nstatic int crypto_authenc_encrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tstruct aead_instance *inst = aead_alg_instance(authenc);\n\tstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct crypto_skcipher *enc = ctx->enc;\n\tunsigned int cryptlen = req->cryptlen;\n\tstruct skcipher_request *skreq = (void *)(areq_ctx->tail +\n\t\t\t\t\t\t  ictx->reqoff);\n\tstruct scatterlist *src, *dst;\n\tint err;\n\n\tsrc = scatterwalk_ffwd(areq_ctx->src, req->src, req->assoclen);\n\tdst = src;\n\n\tif (req->src != req->dst) {\n\t\terr = crypto_authenc_copy_assoc(req);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdst = scatterwalk_ffwd(areq_ctx->dst, req->dst, req->assoclen);\n\t}\n\n\tskcipher_request_set_tfm(skreq, enc);\n\tskcipher_request_set_callback(skreq, aead_request_flags(req),\n\t\t\t\t      crypto_authenc_encrypt_done, req);\n\tskcipher_request_set_crypt(skreq, src, dst, cryptlen, req->iv);\n\n\terr = crypto_skcipher_encrypt(skreq);\n\tif (err)\n\t\treturn err;\n\n\treturn crypto_authenc_genicv(req, aead_request_flags(req));\n}\n\nstatic int crypto_authenc_decrypt_tail(struct aead_request *req,\n\t\t\t\t       unsigned int flags)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tstruct aead_instance *inst = aead_alg_instance(authenc);\n\tstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ictx->reqoff);\n\tstruct skcipher_request *skreq = (void *)(areq_ctx->tail +\n\t\t\t\t\t\t  ictx->reqoff);\n\tunsigned int authsize = crypto_aead_authsize(authenc);\n\tu8 *ihash = ahreq->result + authsize;\n\tstruct scatterlist *src, *dst;\n\n\tscatterwalk_map_and_copy(ihash, req->src, ahreq->nbytes, authsize, 0);\n\n\tif (crypto_memneq(ihash, ahreq->result, authsize))\n\t\treturn -EBADMSG;\n\n\tsrc = scatterwalk_ffwd(areq_ctx->src, req->src, req->assoclen);\n\tdst = src;\n\n\tif (req->src != req->dst)\n\t\tdst = scatterwalk_ffwd(areq_ctx->dst, req->dst, req->assoclen);\n\n\tskcipher_request_set_tfm(skreq, ctx->enc);\n\tskcipher_request_set_callback(skreq, flags,\n\t\t\t\t      req->base.complete, req->base.data);\n\tskcipher_request_set_crypt(skreq, src, dst,\n\t\t\t\t   req->cryptlen - authsize, req->iv);\n\n\treturn crypto_skcipher_decrypt(skreq);\n}\n\nstatic void authenc_verify_ahash_done(void *data, int err)\n{\n\tstruct aead_request *req = data;\n\n\tif (err)\n\t\tgoto out;\n\n\terr = crypto_authenc_decrypt_tail(req, 0);\n\nout:\n\tauthenc_request_complete(req, err);\n}\n\nstatic int crypto_authenc_decrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tunsigned int authsize = crypto_aead_authsize(authenc);\n\tstruct aead_instance *inst = aead_alg_instance(authenc);\n\tstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct crypto_ahash *auth = ctx->auth;\n\tstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ictx->reqoff);\n\tu8 *hash = areq_ctx->tail;\n\tint err;\n\n\thash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),\n\t\t\t   crypto_ahash_alignmask(auth) + 1);\n\n\tahash_request_set_tfm(ahreq, auth);\n\tahash_request_set_crypt(ahreq, req->src, hash,\n\t\t\t\treq->assoclen + req->cryptlen - authsize);\n\tahash_request_set_callback(ahreq, aead_request_flags(req),\n\t\t\t\t   authenc_verify_ahash_done, req);\n\n\terr = crypto_ahash_digest(ahreq);\n\tif (err)\n\t\treturn err;\n\n\treturn crypto_authenc_decrypt_tail(req, aead_request_flags(req));\n}\n\nstatic int crypto_authenc_init_tfm(struct crypto_aead *tfm)\n{\n\tstruct aead_instance *inst = aead_alg_instance(tfm);\n\tstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_ahash *auth;\n\tstruct crypto_skcipher *enc;\n\tstruct crypto_sync_skcipher *null;\n\tint err;\n\n\tauth = crypto_spawn_ahash(&ictx->auth);\n\tif (IS_ERR(auth))\n\t\treturn PTR_ERR(auth);\n\n\tenc = crypto_spawn_skcipher(&ictx->enc);\n\terr = PTR_ERR(enc);\n\tif (IS_ERR(enc))\n\t\tgoto err_free_ahash;\n\n\tnull = crypto_get_default_null_skcipher();\n\terr = PTR_ERR(null);\n\tif (IS_ERR(null))\n\t\tgoto err_free_skcipher;\n\n\tctx->auth = auth;\n\tctx->enc = enc;\n\tctx->null = null;\n\n\tcrypto_aead_set_reqsize(\n\t\ttfm,\n\t\tsizeof(struct authenc_request_ctx) +\n\t\tictx->reqoff +\n\t\tmax_t(unsigned int,\n\t\t      crypto_ahash_reqsize(auth) +\n\t\t      sizeof(struct ahash_request),\n\t\t      sizeof(struct skcipher_request) +\n\t\t      crypto_skcipher_reqsize(enc)));\n\n\treturn 0;\n\nerr_free_skcipher:\n\tcrypto_free_skcipher(enc);\nerr_free_ahash:\n\tcrypto_free_ahash(auth);\n\treturn err;\n}\n\nstatic void crypto_authenc_exit_tfm(struct crypto_aead *tfm)\n{\n\tstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_ahash(ctx->auth);\n\tcrypto_free_skcipher(ctx->enc);\n\tcrypto_put_default_null_skcipher();\n}\n\nstatic void crypto_authenc_free(struct aead_instance *inst)\n{\n\tstruct authenc_instance_ctx *ctx = aead_instance_ctx(inst);\n\n\tcrypto_drop_skcipher(&ctx->enc);\n\tcrypto_drop_ahash(&ctx->auth);\n\tkfree(inst);\n}\n\nstatic int crypto_authenc_create(struct crypto_template *tmpl,\n\t\t\t\t struct rtattr **tb)\n{\n\tu32 mask;\n\tstruct aead_instance *inst;\n\tstruct authenc_instance_ctx *ctx;\n\tstruct hash_alg_common *auth;\n\tstruct crypto_alg *auth_base;\n\tstruct skcipher_alg *enc;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_AEAD, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tctx = aead_instance_ctx(inst);\n\n\terr = crypto_grab_ahash(&ctx->auth, aead_crypto_instance(inst),\n\t\t\t\tcrypto_attr_alg_name(tb[1]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\tauth = crypto_spawn_ahash_alg(&ctx->auth);\n\tauth_base = &auth->base;\n\n\terr = crypto_grab_skcipher(&ctx->enc, aead_crypto_instance(inst),\n\t\t\t\t   crypto_attr_alg_name(tb[2]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\tenc = crypto_spawn_skcipher_alg(&ctx->enc);\n\n\tctx->reqoff = ALIGN(2 * auth->digestsize + auth_base->cra_alignmask,\n\t\t\t    auth_base->cra_alignmask + 1);\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"authenc(%s,%s)\", auth_base->cra_name,\n\t\t     enc->base.cra_name) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_free_inst;\n\n\tif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"authenc(%s,%s)\", auth_base->cra_driver_name,\n\t\t     enc->base.cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_free_inst;\n\n\tinst->alg.base.cra_priority = enc->base.cra_priority * 10 +\n\t\t\t\t      auth_base->cra_priority;\n\tinst->alg.base.cra_blocksize = enc->base.cra_blocksize;\n\tinst->alg.base.cra_alignmask = auth_base->cra_alignmask |\n\t\t\t\t       enc->base.cra_alignmask;\n\tinst->alg.base.cra_ctxsize = sizeof(struct crypto_authenc_ctx);\n\n\tinst->alg.ivsize = crypto_skcipher_alg_ivsize(enc);\n\tinst->alg.chunksize = crypto_skcipher_alg_chunksize(enc);\n\tinst->alg.maxauthsize = auth->digestsize;\n\n\tinst->alg.init = crypto_authenc_init_tfm;\n\tinst->alg.exit = crypto_authenc_exit_tfm;\n\n\tinst->alg.setkey = crypto_authenc_setkey;\n\tinst->alg.encrypt = crypto_authenc_encrypt;\n\tinst->alg.decrypt = crypto_authenc_decrypt;\n\n\tinst->free = crypto_authenc_free;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tcrypto_authenc_free(inst);\n\t}\n\treturn err;\n}\n\nstatic struct crypto_template crypto_authenc_tmpl = {\n\t.name = \"authenc\",\n\t.create = crypto_authenc_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_authenc_module_init(void)\n{\n\treturn crypto_register_template(&crypto_authenc_tmpl);\n}\n\nstatic void __exit crypto_authenc_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_authenc_tmpl);\n}\n\nsubsys_initcall(crypto_authenc_module_init);\nmodule_exit(crypto_authenc_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Simple AEAD wrapper for IPsec\");\nMODULE_ALIAS_CRYPTO(\"authenc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}