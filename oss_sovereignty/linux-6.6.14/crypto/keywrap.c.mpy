{
  "module_name": "keywrap.c",
  "hash_id": "b30c7fd75288722f5b8a2acc7777fd136b40ae461096a395bec5f4c9df1b3860",
  "original_prompt": "Ingested from linux-6.6.14/crypto/keywrap.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/skcipher.h>\n\nstruct crypto_kw_block {\n#define SEMIBSIZE 8\n\t__be64 A;\n\t__be64 R;\n};\n\n \nstatic void crypto_kw_scatterlist_ff(struct scatter_walk *walk,\n\t\t\t\t     struct scatterlist *sg,\n\t\t\t\t     unsigned int end)\n{\n\tunsigned int skip = 0;\n\n\t \n\tBUG_ON(end < SEMIBSIZE);\n\n\tskip = end - SEMIBSIZE;\n\twhile (sg) {\n\t\tif (sg->length > skip) {\n\t\t\tscatterwalk_start(walk, sg);\n\t\t\tscatterwalk_advance(walk, skip);\n\t\t\tbreak;\n\t\t}\n\n\t\tskip -= sg->length;\n\t\tsg = sg_next(sg);\n\t}\n}\n\nstatic int crypto_kw_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct crypto_cipher *cipher = skcipher_cipher_simple(tfm);\n\tstruct crypto_kw_block block;\n\tstruct scatterlist *src, *dst;\n\tu64 t = 6 * ((req->cryptlen) >> 3);\n\tunsigned int i;\n\tint ret = 0;\n\n\t \n\tif (req->cryptlen < (2 * SEMIBSIZE) || req->cryptlen % SEMIBSIZE)\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(&block.A, req->iv, SEMIBSIZE);\n\n\t \n\tsrc = req->src;\n\tdst = req->dst;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tstruct scatter_walk src_walk, dst_walk;\n\t\tunsigned int nbytes = req->cryptlen;\n\n\t\twhile (nbytes) {\n\t\t\t \n\t\t\tcrypto_kw_scatterlist_ff(&src_walk, src, nbytes);\n\t\t\t \n\t\t\tscatterwalk_copychunks(&block.R, &src_walk, SEMIBSIZE,\n\t\t\t\t\t       false);\n\n\t\t\t \n\t\t\tblock.A ^= cpu_to_be64(t);\n\t\t\tt--;\n\t\t\t \n\t\t\tcrypto_cipher_decrypt_one(cipher, (u8 *)&block,\n\t\t\t\t\t\t  (u8 *)&block);\n\n\t\t\t \n\t\t\tcrypto_kw_scatterlist_ff(&dst_walk, dst, nbytes);\n\t\t\t \n\t\t\tscatterwalk_copychunks(&block.R, &dst_walk, SEMIBSIZE,\n\t\t\t\t\t       true);\n\n\t\t\tnbytes -= SEMIBSIZE;\n\t\t}\n\n\t\t \n\t\tsrc = req->dst;\n\t\tdst = req->dst;\n\t}\n\n\t \n\tif (block.A != cpu_to_be64(0xa6a6a6a6a6a6a6a6ULL))\n\t\tret = -EBADMSG;\n\n\tmemzero_explicit(&block, sizeof(struct crypto_kw_block));\n\n\treturn ret;\n}\n\nstatic int crypto_kw_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct crypto_cipher *cipher = skcipher_cipher_simple(tfm);\n\tstruct crypto_kw_block block;\n\tstruct scatterlist *src, *dst;\n\tu64 t = 1;\n\tunsigned int i;\n\n\t \n\tif (req->cryptlen < (2 * SEMIBSIZE) || req->cryptlen % SEMIBSIZE)\n\t\treturn -EINVAL;\n\n\t \n\tblock.A = cpu_to_be64(0xa6a6a6a6a6a6a6a6ULL);\n\n\t \n\tsrc = req->src;\n\tdst = req->dst;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tstruct scatter_walk src_walk, dst_walk;\n\t\tunsigned int nbytes = req->cryptlen;\n\n\t\tscatterwalk_start(&src_walk, src);\n\t\tscatterwalk_start(&dst_walk, dst);\n\n\t\twhile (nbytes) {\n\t\t\t \n\t\t\tscatterwalk_copychunks(&block.R, &src_walk, SEMIBSIZE,\n\t\t\t\t\t       false);\n\n\t\t\t \n\t\t\tcrypto_cipher_encrypt_one(cipher, (u8 *)&block,\n\t\t\t\t\t\t  (u8 *)&block);\n\t\t\t \n\t\t\tblock.A ^= cpu_to_be64(t);\n\t\t\tt++;\n\n\t\t\t \n\t\t\tscatterwalk_copychunks(&block.R, &dst_walk, SEMIBSIZE,\n\t\t\t\t\t       true);\n\n\t\t\tnbytes -= SEMIBSIZE;\n\t\t}\n\n\t\t \n\t\tsrc = req->dst;\n\t\tdst = req->dst;\n\t}\n\n\t \n\tmemcpy(req->iv, &block.A, SEMIBSIZE);\n\n\tmemzero_explicit(&block, sizeof(struct crypto_kw_block));\n\n\treturn 0;\n}\n\nstatic int crypto_kw_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct skcipher_instance *inst;\n\tstruct crypto_alg *alg;\n\tint err;\n\n\tinst = skcipher_alloc_instance_simple(tmpl, tb);\n\tif (IS_ERR(inst))\n\t\treturn PTR_ERR(inst);\n\n\talg = skcipher_ialg_simple(inst);\n\n\terr = -EINVAL;\n\t \n\tif (alg->cra_blocksize != sizeof(struct crypto_kw_block))\n\t\tgoto out_free_inst;\n\n\tinst->alg.base.cra_blocksize = SEMIBSIZE;\n\tinst->alg.base.cra_alignmask = 0;\n\tinst->alg.ivsize = SEMIBSIZE;\n\n\tinst->alg.encrypt = crypto_kw_encrypt;\n\tinst->alg.decrypt = crypto_kw_decrypt;\n\n\terr = skcipher_register_instance(tmpl, inst);\n\tif (err) {\nout_free_inst:\n\t\tinst->free(inst);\n\t}\n\n\treturn err;\n}\n\nstatic struct crypto_template crypto_kw_tmpl = {\n\t.name = \"kw\",\n\t.create = crypto_kw_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_kw_init(void)\n{\n\treturn crypto_register_template(&crypto_kw_tmpl);\n}\n\nstatic void __exit crypto_kw_exit(void)\n{\n\tcrypto_unregister_template(&crypto_kw_tmpl);\n}\n\nsubsys_initcall(crypto_kw_init);\nmodule_exit(crypto_kw_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Stephan Mueller <smueller@chronox.de>\");\nMODULE_DESCRIPTION(\"Key Wrapping (RFC3394 / NIST SP800-38F)\");\nMODULE_ALIAS_CRYPTO(\"kw\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}