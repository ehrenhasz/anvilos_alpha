{
  "module_name": "ecb.c",
  "hash_id": "6d6c13088a312cef3fd35a8aca38790214c6ce808a10d847aee9073a8d62ae81",
  "original_prompt": "Ingested from linux-6.6.14/crypto/ecb.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int crypto_ecb_crypt(struct skcipher_request *req,\n\t\t\t    struct crypto_cipher *cipher,\n\t\t\t    void (*fn)(struct crypto_tfm *, u8 *, const u8 *))\n{\n\tconst unsigned int bsize = crypto_cipher_blocksize(cipher);\n\tstruct skcipher_walk walk;\n\tunsigned int nbytes;\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile ((nbytes = walk.nbytes) != 0) {\n\t\tconst u8 *src = walk.src.virt.addr;\n\t\tu8 *dst = walk.dst.virt.addr;\n\n\t\tdo {\n\t\t\tfn(crypto_cipher_tfm(cipher), dst, src);\n\n\t\t\tsrc += bsize;\n\t\t\tdst += bsize;\n\t\t} while ((nbytes -= bsize) >= bsize);\n\n\t\terr = skcipher_walk_done(&walk, nbytes);\n\t}\n\n\treturn err;\n}\n\nstatic int crypto_ecb_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct crypto_cipher *cipher = skcipher_cipher_simple(tfm);\n\n\treturn crypto_ecb_crypt(req, cipher,\n\t\t\t\tcrypto_cipher_alg(cipher)->cia_encrypt);\n}\n\nstatic int crypto_ecb_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct crypto_cipher *cipher = skcipher_cipher_simple(tfm);\n\n\treturn crypto_ecb_crypt(req, cipher,\n\t\t\t\tcrypto_cipher_alg(cipher)->cia_decrypt);\n}\n\nstatic int crypto_ecb_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct skcipher_instance *inst;\n\tint err;\n\n\tinst = skcipher_alloc_instance_simple(tmpl, tb);\n\tif (IS_ERR(inst))\n\t\treturn PTR_ERR(inst);\n\n\tinst->alg.ivsize = 0;  \n\n\tinst->alg.encrypt = crypto_ecb_encrypt;\n\tinst->alg.decrypt = crypto_ecb_decrypt;\n\n\terr = skcipher_register_instance(tmpl, inst);\n\tif (err)\n\t\tinst->free(inst);\n\n\treturn err;\n}\n\nstatic struct crypto_template crypto_ecb_tmpl = {\n\t.name = \"ecb\",\n\t.create = crypto_ecb_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_ecb_module_init(void)\n{\n\treturn crypto_register_template(&crypto_ecb_tmpl);\n}\n\nstatic void __exit crypto_ecb_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_ecb_tmpl);\n}\n\nsubsys_initcall(crypto_ecb_module_init);\nmodule_exit(crypto_ecb_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ECB block cipher mode of operation\");\nMODULE_ALIAS_CRYPTO(\"ecb\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}