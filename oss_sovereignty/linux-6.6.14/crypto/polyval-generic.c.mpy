{
  "module_name": "polyval-generic.c",
  "hash_id": "e84fff65a332c653d5e6e61e1336a8fcece25c6674615112b63984258eac1398",
  "original_prompt": "Ingested from linux-6.6.14/crypto/polyval-generic.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/unaligned.h>\n#include <crypto/algapi.h>\n#include <crypto/gf128mul.h>\n#include <crypto/polyval.h>\n#include <crypto/internal/hash.h>\n#include <linux/crypto.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct polyval_tfm_ctx {\n\tstruct gf128mul_4k *gf128;\n};\n\nstruct polyval_desc_ctx {\n\tunion {\n\t\tu8 buffer[POLYVAL_BLOCK_SIZE];\n\t\tbe128 buffer128;\n\t};\n\tu32 bytes;\n};\n\nstatic void copy_and_reverse(u8 dst[POLYVAL_BLOCK_SIZE],\n\t\t\t     const u8 src[POLYVAL_BLOCK_SIZE])\n{\n\tu64 a = get_unaligned((const u64 *)&src[0]);\n\tu64 b = get_unaligned((const u64 *)&src[8]);\n\n\tput_unaligned(swab64(a), (u64 *)&dst[8]);\n\tput_unaligned(swab64(b), (u64 *)&dst[0]);\n}\n\n \nvoid polyval_mul_non4k(u8 *op1, const u8 *op2)\n{\n\tbe128 a, b;\n\n\t\n\tcopy_and_reverse((u8 *)&a, op1);\n\tcopy_and_reverse((u8 *)&b, op2);\n\tgf128mul_x_lle(&a, &a);\n\tgf128mul_lle(&a, &b);\n\tcopy_and_reverse(op1, (u8 *)&a);\n}\nEXPORT_SYMBOL_GPL(polyval_mul_non4k);\n\n \nvoid polyval_update_non4k(const u8 *key, const u8 *in,\n\t\t\t  size_t nblocks, u8 *accumulator)\n{\n\twhile (nblocks--) {\n\t\tcrypto_xor(accumulator, in, POLYVAL_BLOCK_SIZE);\n\t\tpolyval_mul_non4k(accumulator, key);\n\t\tin += POLYVAL_BLOCK_SIZE;\n\t}\n}\nEXPORT_SYMBOL_GPL(polyval_update_non4k);\n\nstatic int polyval_setkey(struct crypto_shash *tfm,\n\t\t\t  const u8 *key, unsigned int keylen)\n{\n\tstruct polyval_tfm_ctx *ctx = crypto_shash_ctx(tfm);\n\tbe128 k;\n\n\tif (keylen != POLYVAL_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tgf128mul_free_4k(ctx->gf128);\n\n\tBUILD_BUG_ON(sizeof(k) != POLYVAL_BLOCK_SIZE);\n\tcopy_and_reverse((u8 *)&k, key);\n\tgf128mul_x_lle(&k, &k);\n\n\tctx->gf128 = gf128mul_init_4k_lle(&k);\n\tmemzero_explicit(&k, POLYVAL_BLOCK_SIZE);\n\n\tif (!ctx->gf128)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int polyval_init(struct shash_desc *desc)\n{\n\tstruct polyval_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\tmemset(dctx, 0, sizeof(*dctx));\n\n\treturn 0;\n}\n\nstatic int polyval_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct polyval_desc_ctx *dctx = shash_desc_ctx(desc);\n\tconst struct polyval_tfm_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *pos;\n\tu8 tmp[POLYVAL_BLOCK_SIZE];\n\tint n;\n\n\tif (dctx->bytes) {\n\t\tn = min(srclen, dctx->bytes);\n\t\tpos = dctx->buffer + dctx->bytes - 1;\n\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\n\t\twhile (n--)\n\t\t\t*pos-- ^= *src++;\n\n\t\tif (!dctx->bytes)\n\t\t\tgf128mul_4k_lle(&dctx->buffer128, ctx->gf128);\n\t}\n\n\twhile (srclen >= POLYVAL_BLOCK_SIZE) {\n\t\tcopy_and_reverse(tmp, src);\n\t\tcrypto_xor(dctx->buffer, tmp, POLYVAL_BLOCK_SIZE);\n\t\tgf128mul_4k_lle(&dctx->buffer128, ctx->gf128);\n\t\tsrc += POLYVAL_BLOCK_SIZE;\n\t\tsrclen -= POLYVAL_BLOCK_SIZE;\n\t}\n\n\tif (srclen) {\n\t\tdctx->bytes = POLYVAL_BLOCK_SIZE - srclen;\n\t\tpos = dctx->buffer + POLYVAL_BLOCK_SIZE - 1;\n\t\twhile (srclen--)\n\t\t\t*pos-- ^= *src++;\n\t}\n\n\treturn 0;\n}\n\nstatic int polyval_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct polyval_desc_ctx *dctx = shash_desc_ctx(desc);\n\tconst struct polyval_tfm_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\n\tif (dctx->bytes)\n\t\tgf128mul_4k_lle(&dctx->buffer128, ctx->gf128);\n\tcopy_and_reverse(dst, dctx->buffer);\n\treturn 0;\n}\n\nstatic void polyval_exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct polyval_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tgf128mul_free_4k(ctx->gf128);\n}\n\nstatic struct shash_alg polyval_alg = {\n\t.digestsize\t= POLYVAL_DIGEST_SIZE,\n\t.init\t\t= polyval_init,\n\t.update\t\t= polyval_update,\n\t.final\t\t= polyval_final,\n\t.setkey\t\t= polyval_setkey,\n\t.descsize\t= sizeof(struct polyval_desc_ctx),\n\t.base\t\t= {\n\t\t.cra_name\t\t= \"polyval\",\n\t\t.cra_driver_name\t= \"polyval-generic\",\n\t\t.cra_priority\t\t= 100,\n\t\t.cra_blocksize\t\t= POLYVAL_BLOCK_SIZE,\n\t\t.cra_ctxsize\t\t= sizeof(struct polyval_tfm_ctx),\n\t\t.cra_module\t\t= THIS_MODULE,\n\t\t.cra_exit\t\t= polyval_exit_tfm,\n\t},\n};\n\nstatic int __init polyval_mod_init(void)\n{\n\treturn crypto_register_shash(&polyval_alg);\n}\n\nstatic void __exit polyval_mod_exit(void)\n{\n\tcrypto_unregister_shash(&polyval_alg);\n}\n\nsubsys_initcall(polyval_mod_init);\nmodule_exit(polyval_mod_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"POLYVAL hash function\");\nMODULE_ALIAS_CRYPTO(\"polyval\");\nMODULE_ALIAS_CRYPTO(\"polyval-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}