{
  "module_name": "algif_aead.c",
  "hash_id": "15b10ab472e6d56458747533a72a2e0200d4cd2a1cd7700479b6842d0b90ca34",
  "original_prompt": "Ingested from linux-6.6.14/crypto/algif_aead.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/aead.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/if_alg.h>\n#include <crypto/skcipher.h>\n#include <crypto/null.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <net/sock.h>\n\nstruct aead_tfm {\n\tstruct crypto_aead *aead;\n\tstruct crypto_sync_skcipher *null_tfm;\n};\n\nstatic inline bool aead_sufficient_data(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct sock *psk = ask->parent;\n\tstruct alg_sock *pask = alg_sk(psk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tstruct aead_tfm *aeadc = pask->private;\n\tstruct crypto_aead *tfm = aeadc->aead;\n\tunsigned int as = crypto_aead_authsize(tfm);\n\n\t \n\treturn ctx->used >= ctx->aead_assoclen + (ctx->enc ? 0 : as);\n}\n\nstatic int aead_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct sock *psk = ask->parent;\n\tstruct alg_sock *pask = alg_sk(psk);\n\tstruct aead_tfm *aeadc = pask->private;\n\tstruct crypto_aead *tfm = aeadc->aead;\n\tunsigned int ivsize = crypto_aead_ivsize(tfm);\n\n\treturn af_alg_sendmsg(sock, msg, size, ivsize);\n}\n\nstatic int crypto_aead_copy_sgl(struct crypto_sync_skcipher *null_tfm,\n\t\t\t\tstruct scatterlist *src,\n\t\t\t\tstruct scatterlist *dst, unsigned int len)\n{\n\tSYNC_SKCIPHER_REQUEST_ON_STACK(skreq, null_tfm);\n\n\tskcipher_request_set_sync_tfm(skreq, null_tfm);\n\tskcipher_request_set_callback(skreq, CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t      NULL, NULL);\n\tskcipher_request_set_crypt(skreq, src, dst, len, NULL);\n\n\treturn crypto_skcipher_encrypt(skreq);\n}\n\nstatic int _aead_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct sock *psk = ask->parent;\n\tstruct alg_sock *pask = alg_sk(psk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tstruct aead_tfm *aeadc = pask->private;\n\tstruct crypto_aead *tfm = aeadc->aead;\n\tstruct crypto_sync_skcipher *null_tfm = aeadc->null_tfm;\n\tunsigned int i, as = crypto_aead_authsize(tfm);\n\tstruct af_alg_async_req *areq;\n\tstruct af_alg_tsgl *tsgl, *tmp;\n\tstruct scatterlist *rsgl_src, *tsgl_src = NULL;\n\tint err = 0;\n\tsize_t used = 0;\t\t \n\tsize_t outlen = 0;\t\t \n\tsize_t usedpages = 0;\t\t \n\tsize_t processed = 0;\t\t \n\n\tif (!ctx->init || ctx->more) {\n\t\terr = af_alg_wait_for_data(sk, flags, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tused = ctx->used;\n\n\t \n\tif (!aead_sufficient_data(sk))\n\t\treturn -EINVAL;\n\n\t \n\tif (ctx->enc)\n\t\toutlen = used + as;\n\telse\n\t\toutlen = used - as;\n\n\t \n\tused -= ctx->aead_assoclen;\n\n\t \n\tareq = af_alg_alloc_areq(sk, sizeof(struct af_alg_async_req) +\n\t\t\t\t     crypto_aead_reqsize(tfm));\n\tif (IS_ERR(areq))\n\t\treturn PTR_ERR(areq);\n\n\t \n\terr = af_alg_get_rsgl(sk, msg, flags, areq, outlen, &usedpages);\n\tif (err)\n\t\tgoto free;\n\n\t \n\tif (usedpages < outlen) {\n\t\tsize_t less = outlen - usedpages;\n\n\t\tif (used < less) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\tused -= less;\n\t\toutlen -= less;\n\t}\n\n\tprocessed = used + ctx->aead_assoclen;\n\tlist_for_each_entry_safe(tsgl, tmp, &ctx->tsgl_list, list) {\n\t\tfor (i = 0; i < tsgl->cur; i++) {\n\t\t\tstruct scatterlist *process_sg = tsgl->sg + i;\n\n\t\t\tif (!(process_sg->length) || !sg_page(process_sg))\n\t\t\t\tcontinue;\n\t\t\ttsgl_src = process_sg;\n\t\t\tbreak;\n\t\t}\n\t\tif (tsgl_src)\n\t\t\tbreak;\n\t}\n\tif (processed && !tsgl_src) {\n\t\terr = -EFAULT;\n\t\tgoto free;\n\t}\n\n\t \n\n\t \n\trsgl_src = areq->first_rsgl.sgl.sgt.sgl;\n\n\tif (ctx->enc) {\n\t\t \n\t\terr = crypto_aead_copy_sgl(null_tfm, tsgl_src,\n\t\t\t\t\t   areq->first_rsgl.sgl.sgt.sgl,\n\t\t\t\t\t   processed);\n\t\tif (err)\n\t\t\tgoto free;\n\t\taf_alg_pull_tsgl(sk, processed, NULL, 0);\n\t} else {\n\t\t \n\n\t\t  \n\t\terr = crypto_aead_copy_sgl(null_tfm, tsgl_src,\n\t\t\t\t\t   areq->first_rsgl.sgl.sgt.sgl,\n\t\t\t\t\t   outlen);\n\t\tif (err)\n\t\t\tgoto free;\n\n\t\t \n\t\tareq->tsgl_entries = af_alg_count_tsgl(sk, processed,\n\t\t\t\t\t\t       processed - as);\n\t\tif (!areq->tsgl_entries)\n\t\t\tareq->tsgl_entries = 1;\n\t\tareq->tsgl = sock_kmalloc(sk, array_size(sizeof(*areq->tsgl),\n\t\t\t\t\t\t\t areq->tsgl_entries),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!areq->tsgl) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t\tsg_init_table(areq->tsgl, areq->tsgl_entries);\n\n\t\t \n\t\taf_alg_pull_tsgl(sk, processed, areq->tsgl, processed - as);\n\n\t\t \n\t\tif (usedpages) {\n\t\t\t \n\t\t\tstruct af_alg_sgl *sgl_prev = &areq->last_rsgl->sgl;\n\t\t\tstruct scatterlist *sg = sgl_prev->sgt.sgl;\n\n\t\t\tsg_unmark_end(sg + sgl_prev->sgt.nents - 1);\n\t\t\tsg_chain(sg, sgl_prev->sgt.nents + 1, areq->tsgl);\n\t\t} else\n\t\t\t \n\t\t\trsgl_src = areq->tsgl;\n\t}\n\n\t \n\taead_request_set_crypt(&areq->cra_u.aead_req, rsgl_src,\n\t\t\t       areq->first_rsgl.sgl.sgt.sgl, used, ctx->iv);\n\taead_request_set_ad(&areq->cra_u.aead_req, ctx->aead_assoclen);\n\taead_request_set_tfm(&areq->cra_u.aead_req, tfm);\n\n\tif (msg->msg_iocb && !is_sync_kiocb(msg->msg_iocb)) {\n\t\t \n\t\tsock_hold(sk);\n\t\tareq->iocb = msg->msg_iocb;\n\n\t\t \n\t\tareq->outlen = outlen;\n\n\t\taead_request_set_callback(&areq->cra_u.aead_req,\n\t\t\t\t\t  CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t\t  af_alg_async_cb, areq);\n\t\terr = ctx->enc ? crypto_aead_encrypt(&areq->cra_u.aead_req) :\n\t\t\t\t crypto_aead_decrypt(&areq->cra_u.aead_req);\n\n\t\t \n\t\tif (err == -EINPROGRESS)\n\t\t\treturn -EIOCBQUEUED;\n\n\t\tsock_put(sk);\n\t} else {\n\t\t \n\t\taead_request_set_callback(&areq->cra_u.aead_req,\n\t\t\t\t\t  CRYPTO_TFM_REQ_MAY_SLEEP |\n\t\t\t\t\t  CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\t  crypto_req_done, &ctx->wait);\n\t\terr = crypto_wait_req(ctx->enc ?\n\t\t\t\tcrypto_aead_encrypt(&areq->cra_u.aead_req) :\n\t\t\t\tcrypto_aead_decrypt(&areq->cra_u.aead_req),\n\t\t\t\t&ctx->wait);\n\t}\n\n\nfree:\n\taf_alg_free_resources(areq);\n\n\treturn err ? err : outlen;\n}\n\nstatic int aead_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\tsize_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint ret = 0;\n\n\tlock_sock(sk);\n\twhile (msg_data_left(msg)) {\n\t\tint err = _aead_recvmsg(sock, msg, ignored, flags);\n\n\t\t \n\t\tif (err <= 0) {\n\t\t\tif (err == -EIOCBQUEUED || err == -EBADMSG || !ret)\n\t\t\t\tret = err;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += err;\n\t}\n\nout:\n\taf_alg_wmem_wakeup(sk);\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic struct proto_ops algif_aead_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.accept\t\t=\tsock_no_accept,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\taead_sendmsg,\n\t.recvmsg\t=\taead_recvmsg,\n\t.poll\t\t=\taf_alg_poll,\n};\n\nstatic int aead_check_key(struct socket *sock)\n{\n\tint err = 0;\n\tstruct sock *psk;\n\tstruct alg_sock *pask;\n\tstruct aead_tfm *tfm;\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\n\tlock_sock(sk);\n\tif (!atomic_read(&ask->nokey_refcnt))\n\t\tgoto unlock_child;\n\n\tpsk = ask->parent;\n\tpask = alg_sk(ask->parent);\n\ttfm = pask->private;\n\n\terr = -ENOKEY;\n\tlock_sock_nested(psk, SINGLE_DEPTH_NESTING);\n\tif (crypto_aead_get_flags(tfm->aead) & CRYPTO_TFM_NEED_KEY)\n\t\tgoto unlock;\n\n\tatomic_dec(&pask->nokey_refcnt);\n\tatomic_set(&ask->nokey_refcnt, 0);\n\n\terr = 0;\n\nunlock:\n\trelease_sock(psk);\nunlock_child:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int aead_sendmsg_nokey(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  size_t size)\n{\n\tint err;\n\n\terr = aead_check_key(sock);\n\tif (err)\n\t\treturn err;\n\n\treturn aead_sendmsg(sock, msg, size);\n}\n\nstatic int aead_recvmsg_nokey(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  size_t ignored, int flags)\n{\n\tint err;\n\n\terr = aead_check_key(sock);\n\tif (err)\n\t\treturn err;\n\n\treturn aead_recvmsg(sock, msg, ignored, flags);\n}\n\nstatic struct proto_ops algif_aead_ops_nokey = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.accept\t\t=\tsock_no_accept,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\taead_sendmsg_nokey,\n\t.recvmsg\t=\taead_recvmsg_nokey,\n\t.poll\t\t=\taf_alg_poll,\n};\n\nstatic void *aead_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct aead_tfm *tfm;\n\tstruct crypto_aead *aead;\n\tstruct crypto_sync_skcipher *null_tfm;\n\n\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n\tif (!tfm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\taead = crypto_alloc_aead(name, type, mask);\n\tif (IS_ERR(aead)) {\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(aead);\n\t}\n\n\tnull_tfm = crypto_get_default_null_skcipher();\n\tif (IS_ERR(null_tfm)) {\n\t\tcrypto_free_aead(aead);\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(null_tfm);\n\t}\n\n\ttfm->aead = aead;\n\ttfm->null_tfm = null_tfm;\n\n\treturn tfm;\n}\n\nstatic void aead_release(void *private)\n{\n\tstruct aead_tfm *tfm = private;\n\n\tcrypto_free_aead(tfm->aead);\n\tcrypto_put_default_null_skcipher();\n\tkfree(tfm);\n}\n\nstatic int aead_setauthsize(void *private, unsigned int authsize)\n{\n\tstruct aead_tfm *tfm = private;\n\n\treturn crypto_aead_setauthsize(tfm->aead, authsize);\n}\n\nstatic int aead_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\tstruct aead_tfm *tfm = private;\n\n\treturn crypto_aead_setkey(tfm->aead, key, keylen);\n}\n\nstatic void aead_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tstruct sock *psk = ask->parent;\n\tstruct alg_sock *pask = alg_sk(psk);\n\tstruct aead_tfm *aeadc = pask->private;\n\tstruct crypto_aead *tfm = aeadc->aead;\n\tunsigned int ivlen = crypto_aead_ivsize(tfm);\n\n\taf_alg_pull_tsgl(sk, ctx->used, NULL, 0);\n\tsock_kzfree_s(sk, ctx->iv, ivlen);\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}\n\nstatic int aead_accept_parent_nokey(void *private, struct sock *sk)\n{\n\tstruct af_alg_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct aead_tfm *tfm = private;\n\tstruct crypto_aead *aead = tfm->aead;\n\tunsigned int len = sizeof(*ctx);\n\tunsigned int ivlen = crypto_aead_ivsize(aead);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tmemset(ctx, 0, len);\n\n\tctx->iv = sock_kmalloc(sk, ivlen, GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ctx->iv, 0, ivlen);\n\n\tINIT_LIST_HEAD(&ctx->tsgl_list);\n\tctx->len = len;\n\tcrypto_init_wait(&ctx->wait);\n\n\task->private = ctx;\n\n\tsk->sk_destruct = aead_sock_destruct;\n\n\treturn 0;\n}\n\nstatic int aead_accept_parent(void *private, struct sock *sk)\n{\n\tstruct aead_tfm *tfm = private;\n\n\tif (crypto_aead_get_flags(tfm->aead) & CRYPTO_TFM_NEED_KEY)\n\t\treturn -ENOKEY;\n\n\treturn aead_accept_parent_nokey(private, sk);\n}\n\nstatic const struct af_alg_type algif_type_aead = {\n\t.bind\t\t=\taead_bind,\n\t.release\t=\taead_release,\n\t.setkey\t\t=\taead_setkey,\n\t.setauthsize\t=\taead_setauthsize,\n\t.accept\t\t=\taead_accept_parent,\n\t.accept_nokey\t=\taead_accept_parent_nokey,\n\t.ops\t\t=\t&algif_aead_ops,\n\t.ops_nokey\t=\t&algif_aead_ops_nokey,\n\t.name\t\t=\t\"aead\",\n\t.owner\t\t=\tTHIS_MODULE\n};\n\nstatic int __init algif_aead_init(void)\n{\n\treturn af_alg_register_type(&algif_type_aead);\n}\n\nstatic void __exit algif_aead_exit(void)\n{\n\tint err = af_alg_unregister_type(&algif_type_aead);\n\tBUG_ON(err);\n}\n\nmodule_init(algif_aead_init);\nmodule_exit(algif_aead_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Stephan Mueller <smueller@chronox.de>\");\nMODULE_DESCRIPTION(\"AEAD kernel crypto API user space interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}