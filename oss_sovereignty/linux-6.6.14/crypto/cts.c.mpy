{
  "module_name": "cts.c",
  "hash_id": "4405aa0680e937e11a535cf72197d8c459607d5b07560b128fbe5e73ce331877",
  "original_prompt": "Ingested from linux-6.6.14/crypto/cts.c",
  "human_readable_source": " \n\n \n\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <crypto/scatterwalk.h>\n#include <linux/slab.h>\n#include <linux/compiler.h>\n\nstruct crypto_cts_ctx {\n\tstruct crypto_skcipher *child;\n};\n\nstruct crypto_cts_reqctx {\n\tstruct scatterlist sg[2];\n\tunsigned offset;\n\tstruct skcipher_request subreq;\n};\n\nstatic inline u8 *crypto_cts_reqctx_space(struct skcipher_request *req)\n{\n\tstruct crypto_cts_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct crypto_skcipher *child = ctx->child;\n\n\treturn PTR_ALIGN((u8 *)(rctx + 1) + crypto_skcipher_reqsize(child),\n\t\t\t crypto_skcipher_alignmask(tfm) + 1);\n}\n\nstatic int crypto_cts_setkey(struct crypto_skcipher *parent, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct crypto_cts_ctx *ctx = crypto_skcipher_ctx(parent);\n\tstruct crypto_skcipher *child = ctx->child;\n\n\tcrypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(child, crypto_skcipher_get_flags(parent) &\n\t\t\t\t\t CRYPTO_TFM_REQ_MASK);\n\treturn crypto_skcipher_setkey(child, key, keylen);\n}\n\nstatic void cts_cbc_crypt_done(void *data, int err)\n{\n\tstruct skcipher_request *req = data;\n\n\tif (err == -EINPROGRESS)\n\t\treturn;\n\n\tskcipher_request_complete(req, err);\n}\n\nstatic int cts_cbc_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_cts_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct skcipher_request *subreq = &rctx->subreq;\n\tint bsize = crypto_skcipher_blocksize(tfm);\n\tu8 d[MAX_CIPHER_BLOCKSIZE * 2] __aligned(__alignof__(u32));\n\tstruct scatterlist *sg;\n\tunsigned int offset;\n\tint lastn;\n\n\toffset = rctx->offset;\n\tlastn = req->cryptlen - offset;\n\n\tsg = scatterwalk_ffwd(rctx->sg, req->dst, offset - bsize);\n\tscatterwalk_map_and_copy(d + bsize, sg, 0, bsize, 0);\n\n\tmemset(d, 0, bsize);\n\tscatterwalk_map_and_copy(d, req->src, offset, lastn, 0);\n\n\tscatterwalk_map_and_copy(d, sg, 0, bsize + lastn, 1);\n\tmemzero_explicit(d, sizeof(d));\n\n\tskcipher_request_set_callback(subreq, req->base.flags &\n\t\t\t\t\t      CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      cts_cbc_crypt_done, req);\n\tskcipher_request_set_crypt(subreq, sg, sg, bsize, req->iv);\n\treturn crypto_skcipher_encrypt(subreq);\n}\n\nstatic void crypto_cts_encrypt_done(void *data, int err)\n{\n\tstruct skcipher_request *req = data;\n\n\tif (err)\n\t\tgoto out;\n\n\terr = cts_cbc_encrypt(req);\n\tif (err == -EINPROGRESS || err == -EBUSY)\n\t\treturn;\n\nout:\n\tskcipher_request_complete(req, err);\n}\n\nstatic int crypto_cts_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct crypto_cts_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct skcipher_request *subreq = &rctx->subreq;\n\tint bsize = crypto_skcipher_blocksize(tfm);\n\tunsigned int nbytes = req->cryptlen;\n\tunsigned int offset;\n\n\tskcipher_request_set_tfm(subreq, ctx->child);\n\n\tif (nbytes < bsize)\n\t\treturn -EINVAL;\n\n\tif (nbytes == bsize) {\n\t\tskcipher_request_set_callback(subreq, req->base.flags,\n\t\t\t\t\t      req->base.complete,\n\t\t\t\t\t      req->base.data);\n\t\tskcipher_request_set_crypt(subreq, req->src, req->dst, nbytes,\n\t\t\t\t\t   req->iv);\n\t\treturn crypto_skcipher_encrypt(subreq);\n\t}\n\n\toffset = rounddown(nbytes - 1, bsize);\n\trctx->offset = offset;\n\n\tskcipher_request_set_callback(subreq, req->base.flags,\n\t\t\t\t      crypto_cts_encrypt_done, req);\n\tskcipher_request_set_crypt(subreq, req->src, req->dst,\n\t\t\t\t   offset, req->iv);\n\n\treturn crypto_skcipher_encrypt(subreq) ?:\n\t       cts_cbc_encrypt(req);\n}\n\nstatic int cts_cbc_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_cts_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct skcipher_request *subreq = &rctx->subreq;\n\tint bsize = crypto_skcipher_blocksize(tfm);\n\tu8 d[MAX_CIPHER_BLOCKSIZE * 2] __aligned(__alignof__(u32));\n\tstruct scatterlist *sg;\n\tunsigned int offset;\n\tu8 *space;\n\tint lastn;\n\n\toffset = rctx->offset;\n\tlastn = req->cryptlen - offset;\n\n\tsg = scatterwalk_ffwd(rctx->sg, req->dst, offset - bsize);\n\n\t \n\tscatterwalk_map_and_copy(d + bsize, sg, 0, bsize, 0);\n\tspace = crypto_cts_reqctx_space(req);\n\tcrypto_xor(d + bsize, space, bsize);\n\t \n\tmemset(d, 0, bsize);\n\tscatterwalk_map_and_copy(d, req->src, offset, lastn, 0);\n\t \n\t \n\tcrypto_xor(d + bsize, d, lastn);\n\n\t \n\tmemcpy(d + lastn, d + bsize + lastn, bsize - lastn);\n\t \n\n\tscatterwalk_map_and_copy(d, sg, 0, bsize + lastn, 1);\n\tmemzero_explicit(d, sizeof(d));\n\n\tskcipher_request_set_callback(subreq, req->base.flags &\n\t\t\t\t\t      CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      cts_cbc_crypt_done, req);\n\n\tskcipher_request_set_crypt(subreq, sg, sg, bsize, space);\n\treturn crypto_skcipher_decrypt(subreq);\n}\n\nstatic void crypto_cts_decrypt_done(void *data, int err)\n{\n\tstruct skcipher_request *req = data;\n\n\tif (err)\n\t\tgoto out;\n\n\terr = cts_cbc_decrypt(req);\n\tif (err == -EINPROGRESS || err == -EBUSY)\n\t\treturn;\n\nout:\n\tskcipher_request_complete(req, err);\n}\n\nstatic int crypto_cts_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct crypto_cts_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct skcipher_request *subreq = &rctx->subreq;\n\tint bsize = crypto_skcipher_blocksize(tfm);\n\tunsigned int nbytes = req->cryptlen;\n\tunsigned int offset;\n\tu8 *space;\n\n\tskcipher_request_set_tfm(subreq, ctx->child);\n\n\tif (nbytes < bsize)\n\t\treturn -EINVAL;\n\n\tif (nbytes == bsize) {\n\t\tskcipher_request_set_callback(subreq, req->base.flags,\n\t\t\t\t\t      req->base.complete,\n\t\t\t\t\t      req->base.data);\n\t\tskcipher_request_set_crypt(subreq, req->src, req->dst, nbytes,\n\t\t\t\t\t   req->iv);\n\t\treturn crypto_skcipher_decrypt(subreq);\n\t}\n\n\tskcipher_request_set_callback(subreq, req->base.flags,\n\t\t\t\t      crypto_cts_decrypt_done, req);\n\n\tspace = crypto_cts_reqctx_space(req);\n\n\toffset = rounddown(nbytes - 1, bsize);\n\trctx->offset = offset;\n\n\tif (offset <= bsize)\n\t\tmemcpy(space, req->iv, bsize);\n\telse\n\t\tscatterwalk_map_and_copy(space, req->src, offset - 2 * bsize,\n\t\t\t\t\t bsize, 0);\n\n\tskcipher_request_set_crypt(subreq, req->src, req->dst,\n\t\t\t\t   offset, req->iv);\n\n\treturn crypto_skcipher_decrypt(subreq) ?:\n\t       cts_cbc_decrypt(req);\n}\n\nstatic int crypto_cts_init_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct skcipher_instance *inst = skcipher_alg_instance(tfm);\n\tstruct crypto_skcipher_spawn *spawn = skcipher_instance_ctx(inst);\n\tstruct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct crypto_skcipher *cipher;\n\tunsigned reqsize;\n\tunsigned bsize;\n\tunsigned align;\n\n\tcipher = crypto_spawn_skcipher(spawn);\n\tif (IS_ERR(cipher))\n\t\treturn PTR_ERR(cipher);\n\n\tctx->child = cipher;\n\n\talign = crypto_skcipher_alignmask(tfm);\n\tbsize = crypto_skcipher_blocksize(cipher);\n\treqsize = ALIGN(sizeof(struct crypto_cts_reqctx) +\n\t\t\tcrypto_skcipher_reqsize(cipher),\n\t\t\tcrypto_tfm_ctx_alignment()) +\n\t\t  (align & ~(crypto_tfm_ctx_alignment() - 1)) + bsize;\n\n\tcrypto_skcipher_set_reqsize(tfm, reqsize);\n\n\treturn 0;\n}\n\nstatic void crypto_cts_exit_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tcrypto_free_skcipher(ctx->child);\n}\n\nstatic void crypto_cts_free(struct skcipher_instance *inst)\n{\n\tcrypto_drop_skcipher(skcipher_instance_ctx(inst));\n\tkfree(inst);\n}\n\nstatic int crypto_cts_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct crypto_skcipher_spawn *spawn;\n\tstruct skcipher_instance *inst;\n\tstruct skcipher_alg *alg;\n\tu32 mask;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SKCIPHER, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tspawn = skcipher_instance_ctx(inst);\n\n\terr = crypto_grab_skcipher(spawn, skcipher_crypto_instance(inst),\n\t\t\t\t   crypto_attr_alg_name(tb[1]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\talg = crypto_spawn_skcipher_alg(spawn);\n\n\terr = -EINVAL;\n\tif (crypto_skcipher_alg_ivsize(alg) != alg->base.cra_blocksize)\n\t\tgoto err_free_inst;\n\n\tif (strncmp(alg->base.cra_name, \"cbc(\", 4))\n\t\tgoto err_free_inst;\n\n\terr = crypto_inst_setname(skcipher_crypto_instance(inst), \"cts\",\n\t\t\t\t  &alg->base);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\tinst->alg.base.cra_priority = alg->base.cra_priority;\n\tinst->alg.base.cra_blocksize = alg->base.cra_blocksize;\n\tinst->alg.base.cra_alignmask = alg->base.cra_alignmask;\n\n\tinst->alg.ivsize = alg->base.cra_blocksize;\n\tinst->alg.chunksize = crypto_skcipher_alg_chunksize(alg);\n\tinst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg);\n\tinst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg);\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct crypto_cts_ctx);\n\n\tinst->alg.init = crypto_cts_init_tfm;\n\tinst->alg.exit = crypto_cts_exit_tfm;\n\n\tinst->alg.setkey = crypto_cts_setkey;\n\tinst->alg.encrypt = crypto_cts_encrypt;\n\tinst->alg.decrypt = crypto_cts_decrypt;\n\n\tinst->free = crypto_cts_free;\n\n\terr = skcipher_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tcrypto_cts_free(inst);\n\t}\n\treturn err;\n}\n\nstatic struct crypto_template crypto_cts_tmpl = {\n\t.name = \"cts\",\n\t.create = crypto_cts_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_cts_module_init(void)\n{\n\treturn crypto_register_template(&crypto_cts_tmpl);\n}\n\nstatic void __exit crypto_cts_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_cts_tmpl);\n}\n\nsubsys_initcall(crypto_cts_module_init);\nmodule_exit(crypto_cts_module_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"CTS-CBC CipherText Stealing for CBC\");\nMODULE_ALIAS_CRYPTO(\"cts\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}