{
  "module_name": "async_raid6_recov.c",
  "hash_id": "4cc66f2358cb73ac71cf39c6f4e614e14d5e10bbb738f5f46f39dd682da36df1",
  "original_prompt": "Ingested from linux-6.6.14/crypto/async_tx/async_raid6_recov.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/raid/pq.h>\n#include <linux/async_tx.h>\n#include <linux/dmaengine.h>\n\nstatic struct dma_async_tx_descriptor *\nasync_sum_product(struct page *dest, unsigned int d_off,\n\t\tstruct page **srcs, unsigned int *src_offs, unsigned char *coef,\n\t\tsize_t len, struct async_submit_ctl *submit)\n{\n\tstruct dma_chan *chan = async_tx_find_channel(submit, DMA_PQ,\n\t\t\t\t\t\t      &dest, 1, srcs, 2, len);\n\tstruct dma_device *dma = chan ? chan->device : NULL;\n\tstruct dmaengine_unmap_data *unmap = NULL;\n\tconst u8 *amul, *bmul;\n\tu8 ax, bx;\n\tu8 *a, *b, *c;\n\n\tif (dma)\n\t\tunmap = dmaengine_get_unmap_data(dma->dev, 3, GFP_NOWAIT);\n\n\tif (unmap) {\n\t\tstruct device *dev = dma->dev;\n\t\tdma_addr_t pq[2];\n\t\tstruct dma_async_tx_descriptor *tx;\n\t\tenum dma_ctrl_flags dma_flags = DMA_PREP_PQ_DISABLE_P;\n\n\t\tif (submit->flags & ASYNC_TX_FENCE)\n\t\t\tdma_flags |= DMA_PREP_FENCE;\n\t\tunmap->addr[0] = dma_map_page(dev, srcs[0], src_offs[0],\n\t\t\t\t\t\tlen, DMA_TO_DEVICE);\n\t\tunmap->addr[1] = dma_map_page(dev, srcs[1], src_offs[1],\n\t\t\t\t\t\tlen, DMA_TO_DEVICE);\n\t\tunmap->to_cnt = 2;\n\n\t\tunmap->addr[2] = dma_map_page(dev, dest, d_off,\n\t\t\t\t\t\tlen, DMA_BIDIRECTIONAL);\n\t\tunmap->bidi_cnt = 1;\n\t\t \n\t\tpq[1] = unmap->addr[2];\n\n\t\tunmap->len = len;\n\t\ttx = dma->device_prep_dma_pq(chan, pq, unmap->addr, 2, coef,\n\t\t\t\t\t     len, dma_flags);\n\t\tif (tx) {\n\t\t\tdma_set_unmap(tx, unmap);\n\t\t\tasync_tx_submit(chan, tx, submit);\n\t\t\tdmaengine_unmap_put(unmap);\n\t\t\treturn tx;\n\t\t}\n\n\t\t \n\t\tdmaengine_unmap_put(unmap);\n\t}\n\n\t \n\tasync_tx_quiesce(&submit->depend_tx);\n\tamul = raid6_gfmul[coef[0]];\n\tbmul = raid6_gfmul[coef[1]];\n\ta = page_address(srcs[0]) + src_offs[0];\n\tb = page_address(srcs[1]) + src_offs[1];\n\tc = page_address(dest) + d_off;\n\n\twhile (len--) {\n\t\tax    = amul[*a++];\n\t\tbx    = bmul[*b++];\n\t\t*c++ = ax ^ bx;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct dma_async_tx_descriptor *\nasync_mult(struct page *dest, unsigned int d_off, struct page *src,\n\t\tunsigned int s_off, u8 coef, size_t len,\n\t\tstruct async_submit_ctl *submit)\n{\n\tstruct dma_chan *chan = async_tx_find_channel(submit, DMA_PQ,\n\t\t\t\t\t\t      &dest, 1, &src, 1, len);\n\tstruct dma_device *dma = chan ? chan->device : NULL;\n\tstruct dmaengine_unmap_data *unmap = NULL;\n\tconst u8 *qmul;  \n\tu8 *d, *s;\n\n\tif (dma)\n\t\tunmap = dmaengine_get_unmap_data(dma->dev, 3, GFP_NOWAIT);\n\n\tif (unmap) {\n\t\tdma_addr_t dma_dest[2];\n\t\tstruct device *dev = dma->dev;\n\t\tstruct dma_async_tx_descriptor *tx;\n\t\tenum dma_ctrl_flags dma_flags = DMA_PREP_PQ_DISABLE_P;\n\n\t\tif (submit->flags & ASYNC_TX_FENCE)\n\t\t\tdma_flags |= DMA_PREP_FENCE;\n\t\tunmap->addr[0] = dma_map_page(dev, src, s_off,\n\t\t\t\t\t\tlen, DMA_TO_DEVICE);\n\t\tunmap->to_cnt++;\n\t\tunmap->addr[1] = dma_map_page(dev, dest, d_off,\n\t\t\t\t\t\tlen, DMA_BIDIRECTIONAL);\n\t\tdma_dest[1] = unmap->addr[1];\n\t\tunmap->bidi_cnt++;\n\t\tunmap->len = len;\n\n\t\t \n\t\ttx = dma->device_prep_dma_pq(chan, dma_dest, unmap->addr,\n\t\t\t\t\t     1, &coef, len, dma_flags);\n\n\t\tif (tx) {\n\t\t\tdma_set_unmap(tx, unmap);\n\t\t\tdmaengine_unmap_put(unmap);\n\t\t\tasync_tx_submit(chan, tx, submit);\n\t\t\treturn tx;\n\t\t}\n\n\t\t \n\t\tdmaengine_unmap_put(unmap);\n\t}\n\n\t \n\tasync_tx_quiesce(&submit->depend_tx);\n\tqmul  = raid6_gfmul[coef];\n\td = page_address(dest) + d_off;\n\ts = page_address(src) + s_off;\n\n\twhile (len--)\n\t\t*d++ = qmul[*s++];\n\n\treturn NULL;\n}\n\nstatic struct dma_async_tx_descriptor *\n__2data_recov_4(int disks, size_t bytes, int faila, int failb,\n\t\tstruct page **blocks, unsigned int *offs,\n\t\tstruct async_submit_ctl *submit)\n{\n\tstruct dma_async_tx_descriptor *tx = NULL;\n\tstruct page *p, *q, *a, *b;\n\tunsigned int p_off, q_off, a_off, b_off;\n\tstruct page *srcs[2];\n\tunsigned int src_offs[2];\n\tunsigned char coef[2];\n\tenum async_tx_flags flags = submit->flags;\n\tdma_async_tx_callback cb_fn = submit->cb_fn;\n\tvoid *cb_param = submit->cb_param;\n\tvoid *scribble = submit->scribble;\n\n\tp = blocks[disks-2];\n\tp_off = offs[disks-2];\n\tq = blocks[disks-1];\n\tq_off = offs[disks-1];\n\n\ta = blocks[faila];\n\ta_off = offs[faila];\n\tb = blocks[failb];\n\tb_off = offs[failb];\n\n\t \n\t \n\tsrcs[0] = p;\n\tsrc_offs[0] = p_off;\n\tsrcs[1] = q;\n\tsrc_offs[1] = q_off;\n\tcoef[0] = raid6_gfexi[failb-faila];\n\tcoef[1] = raid6_gfinv[raid6_gfexp[faila]^raid6_gfexp[failb]];\n\tinit_async_submit(submit, ASYNC_TX_FENCE, tx, NULL, NULL, scribble);\n\ttx = async_sum_product(b, b_off, srcs, src_offs, coef, bytes, submit);\n\n\t \n\tsrcs[0] = p;\n\tsrc_offs[0] = p_off;\n\tsrcs[1] = b;\n\tsrc_offs[1] = b_off;\n\tinit_async_submit(submit, flags | ASYNC_TX_XOR_ZERO_DST, tx, cb_fn,\n\t\t\t  cb_param, scribble);\n\ttx = async_xor_offs(a, a_off, srcs, src_offs, 2, bytes, submit);\n\n\treturn tx;\n\n}\n\nstatic struct dma_async_tx_descriptor *\n__2data_recov_5(int disks, size_t bytes, int faila, int failb,\n\t\tstruct page **blocks, unsigned int *offs,\n\t\tstruct async_submit_ctl *submit)\n{\n\tstruct dma_async_tx_descriptor *tx = NULL;\n\tstruct page *p, *q, *g, *dp, *dq;\n\tunsigned int p_off, q_off, g_off, dp_off, dq_off;\n\tstruct page *srcs[2];\n\tunsigned int src_offs[2];\n\tunsigned char coef[2];\n\tenum async_tx_flags flags = submit->flags;\n\tdma_async_tx_callback cb_fn = submit->cb_fn;\n\tvoid *cb_param = submit->cb_param;\n\tvoid *scribble = submit->scribble;\n\tint good_srcs, good, i;\n\n\tgood_srcs = 0;\n\tgood = -1;\n\tfor (i = 0; i < disks-2; i++) {\n\t\tif (blocks[i] == NULL)\n\t\t\tcontinue;\n\t\tif (i == faila || i == failb)\n\t\t\tcontinue;\n\t\tgood = i;\n\t\tgood_srcs++;\n\t}\n\tBUG_ON(good_srcs > 1);\n\n\tp = blocks[disks-2];\n\tp_off = offs[disks-2];\n\tq = blocks[disks-1];\n\tq_off = offs[disks-1];\n\tg = blocks[good];\n\tg_off = offs[good];\n\n\t \n\tdp = blocks[faila];\n\tdp_off = offs[faila];\n\tdq = blocks[failb];\n\tdq_off = offs[failb];\n\n\tinit_async_submit(submit, ASYNC_TX_FENCE, tx, NULL, NULL, scribble);\n\ttx = async_memcpy(dp, g, dp_off, g_off, bytes, submit);\n\tinit_async_submit(submit, ASYNC_TX_FENCE, tx, NULL, NULL, scribble);\n\ttx = async_mult(dq, dq_off, g, g_off,\n\t\t\traid6_gfexp[good], bytes, submit);\n\n\t \n\tsrcs[0] = dp;\n\tsrc_offs[0] = dp_off;\n\tsrcs[1] = p;\n\tsrc_offs[1] = p_off;\n\tinit_async_submit(submit, ASYNC_TX_FENCE|ASYNC_TX_XOR_DROP_DST, tx,\n\t\t\t  NULL, NULL, scribble);\n\ttx = async_xor_offs(dp, dp_off, srcs, src_offs, 2, bytes, submit);\n\n\t \n\tsrcs[0] = dq;\n\tsrc_offs[0] = dq_off;\n\tsrcs[1] = q;\n\tsrc_offs[1] = q_off;\n\tinit_async_submit(submit, ASYNC_TX_FENCE|ASYNC_TX_XOR_DROP_DST, tx,\n\t\t\t  NULL, NULL, scribble);\n\ttx = async_xor_offs(dq, dq_off, srcs, src_offs, 2, bytes, submit);\n\n\t \n\tsrcs[0] = dp;\n\tsrc_offs[0] = dp_off;\n\tsrcs[1] = dq;\n\tsrc_offs[1] = dq_off;\n\tcoef[0] = raid6_gfexi[failb-faila];\n\tcoef[1] = raid6_gfinv[raid6_gfexp[faila]^raid6_gfexp[failb]];\n\tinit_async_submit(submit, ASYNC_TX_FENCE, tx, NULL, NULL, scribble);\n\ttx = async_sum_product(dq, dq_off, srcs, src_offs, coef, bytes, submit);\n\n\t \n\tsrcs[0] = dp;\n\tsrc_offs[0] = dp_off;\n\tsrcs[1] = dq;\n\tsrc_offs[1] = dq_off;\n\tinit_async_submit(submit, flags | ASYNC_TX_XOR_DROP_DST, tx, cb_fn,\n\t\t\t  cb_param, scribble);\n\ttx = async_xor_offs(dp, dp_off, srcs, src_offs, 2, bytes, submit);\n\n\treturn tx;\n}\n\nstatic struct dma_async_tx_descriptor *\n__2data_recov_n(int disks, size_t bytes, int faila, int failb,\n\t      struct page **blocks, unsigned int *offs,\n\t\t  struct async_submit_ctl *submit)\n{\n\tstruct dma_async_tx_descriptor *tx = NULL;\n\tstruct page *p, *q, *dp, *dq;\n\tunsigned int p_off, q_off, dp_off, dq_off;\n\tstruct page *srcs[2];\n\tunsigned int src_offs[2];\n\tunsigned char coef[2];\n\tenum async_tx_flags flags = submit->flags;\n\tdma_async_tx_callback cb_fn = submit->cb_fn;\n\tvoid *cb_param = submit->cb_param;\n\tvoid *scribble = submit->scribble;\n\n\tp = blocks[disks-2];\n\tp_off = offs[disks-2];\n\tq = blocks[disks-1];\n\tq_off = offs[disks-1];\n\n\t \n\tdp = blocks[faila];\n\tdp_off = offs[faila];\n\tblocks[faila] = NULL;\n\tblocks[disks-2] = dp;\n\toffs[disks-2] = dp_off;\n\tdq = blocks[failb];\n\tdq_off = offs[failb];\n\tblocks[failb] = NULL;\n\tblocks[disks-1] = dq;\n\toffs[disks-1] = dq_off;\n\n\tinit_async_submit(submit, ASYNC_TX_FENCE, tx, NULL, NULL, scribble);\n\ttx = async_gen_syndrome(blocks, offs, disks, bytes, submit);\n\n\t \n\tblocks[faila]   = dp;\n\toffs[faila] = dp_off;\n\tblocks[failb]   = dq;\n\toffs[failb] = dq_off;\n\tblocks[disks-2] = p;\n\toffs[disks-2] = p_off;\n\tblocks[disks-1] = q;\n\toffs[disks-1] = q_off;\n\n\t \n\tsrcs[0] = dp;\n\tsrc_offs[0] = dp_off;\n\tsrcs[1] = p;\n\tsrc_offs[1] = p_off;\n\tinit_async_submit(submit, ASYNC_TX_FENCE|ASYNC_TX_XOR_DROP_DST, tx,\n\t\t\t  NULL, NULL, scribble);\n\ttx = async_xor_offs(dp, dp_off, srcs, src_offs, 2, bytes, submit);\n\n\t \n\tsrcs[0] = dq;\n\tsrc_offs[0] = dq_off;\n\tsrcs[1] = q;\n\tsrc_offs[1] = q_off;\n\tinit_async_submit(submit, ASYNC_TX_FENCE|ASYNC_TX_XOR_DROP_DST, tx,\n\t\t\t  NULL, NULL, scribble);\n\ttx = async_xor_offs(dq, dq_off, srcs, src_offs, 2, bytes, submit);\n\n\t \n\tsrcs[0] = dp;\n\tsrc_offs[0] = dp_off;\n\tsrcs[1] = dq;\n\tsrc_offs[1] = dq_off;\n\tcoef[0] = raid6_gfexi[failb-faila];\n\tcoef[1] = raid6_gfinv[raid6_gfexp[faila]^raid6_gfexp[failb]];\n\tinit_async_submit(submit, ASYNC_TX_FENCE, tx, NULL, NULL, scribble);\n\ttx = async_sum_product(dq, dq_off, srcs, src_offs, coef, bytes, submit);\n\n\t \n\tsrcs[0] = dp;\n\tsrc_offs[0] = dp_off;\n\tsrcs[1] = dq;\n\tsrc_offs[1] = dq_off;\n\tinit_async_submit(submit, flags | ASYNC_TX_XOR_DROP_DST, tx, cb_fn,\n\t\t\t  cb_param, scribble);\n\ttx = async_xor_offs(dp, dp_off, srcs, src_offs, 2, bytes, submit);\n\n\treturn tx;\n}\n\n \nstruct dma_async_tx_descriptor *\nasync_raid6_2data_recov(int disks, size_t bytes, int faila, int failb,\n\t\t\tstruct page **blocks, unsigned int *offs,\n\t\t\tstruct async_submit_ctl *submit)\n{\n\tvoid *scribble = submit->scribble;\n\tint non_zero_srcs, i;\n\n\tBUG_ON(faila == failb);\n\tif (failb < faila)\n\t\tswap(faila, failb);\n\n\tpr_debug(\"%s: disks: %d len: %zu\\n\", __func__, disks, bytes);\n\n\t \n\tif (!async_dma_find_channel(DMA_PQ) || !scribble) {\n\t\tvoid **ptrs = scribble ? scribble : (void **) blocks;\n\n\t\tasync_tx_quiesce(&submit->depend_tx);\n\t\tfor (i = 0; i < disks; i++)\n\t\t\tif (blocks[i] == NULL)\n\t\t\t\tptrs[i] = (void *) raid6_empty_zero_page;\n\t\t\telse\n\t\t\t\tptrs[i] = page_address(blocks[i]) + offs[i];\n\n\t\traid6_2data_recov(disks, bytes, faila, failb, ptrs);\n\n\t\tasync_tx_sync_epilog(submit);\n\n\t\treturn NULL;\n\t}\n\n\tnon_zero_srcs = 0;\n\tfor (i = 0; i < disks-2 && non_zero_srcs < 4; i++)\n\t\tif (blocks[i])\n\t\t\tnon_zero_srcs++;\n\tswitch (non_zero_srcs) {\n\tcase 0:\n\tcase 1:\n\t\t \n\t\tBUG();\n\n\tcase 2:\n\t\t \n\t\treturn __2data_recov_4(disks, bytes, faila, failb,\n\t\t\t\tblocks, offs, submit);\n\tcase 3:\n\t\t \n\t\treturn __2data_recov_5(disks, bytes, faila, failb,\n\t\t\t\tblocks, offs, submit);\n\tdefault:\n\t\treturn __2data_recov_n(disks, bytes, faila, failb,\n\t\t\t\tblocks, offs, submit);\n\t}\n}\nEXPORT_SYMBOL_GPL(async_raid6_2data_recov);\n\n \nstruct dma_async_tx_descriptor *\nasync_raid6_datap_recov(int disks, size_t bytes, int faila,\n\t\t\tstruct page **blocks, unsigned int *offs,\n\t\t\tstruct async_submit_ctl *submit)\n{\n\tstruct dma_async_tx_descriptor *tx = NULL;\n\tstruct page *p, *q, *dq;\n\tunsigned int p_off, q_off, dq_off;\n\tu8 coef;\n\tenum async_tx_flags flags = submit->flags;\n\tdma_async_tx_callback cb_fn = submit->cb_fn;\n\tvoid *cb_param = submit->cb_param;\n\tvoid *scribble = submit->scribble;\n\tint good_srcs, good, i;\n\tstruct page *srcs[2];\n\tunsigned int src_offs[2];\n\n\tpr_debug(\"%s: disks: %d len: %zu\\n\", __func__, disks, bytes);\n\n\t \n\tif (!async_dma_find_channel(DMA_PQ) || !scribble) {\n\t\tvoid **ptrs = scribble ? scribble : (void **) blocks;\n\n\t\tasync_tx_quiesce(&submit->depend_tx);\n\t\tfor (i = 0; i < disks; i++)\n\t\t\tif (blocks[i] == NULL)\n\t\t\t\tptrs[i] = (void*)raid6_empty_zero_page;\n\t\t\telse\n\t\t\t\tptrs[i] = page_address(blocks[i]) + offs[i];\n\n\t\traid6_datap_recov(disks, bytes, faila, ptrs);\n\n\t\tasync_tx_sync_epilog(submit);\n\n\t\treturn NULL;\n\t}\n\n\tgood_srcs = 0;\n\tgood = -1;\n\tfor (i = 0; i < disks-2; i++) {\n\t\tif (i == faila)\n\t\t\tcontinue;\n\t\tif (blocks[i]) {\n\t\t\tgood = i;\n\t\t\tgood_srcs++;\n\t\t\tif (good_srcs > 1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tBUG_ON(good_srcs == 0);\n\n\tp = blocks[disks-2];\n\tp_off = offs[disks-2];\n\tq = blocks[disks-1];\n\tq_off = offs[disks-1];\n\n\t \n\tdq = blocks[faila];\n\tdq_off = offs[faila];\n\tblocks[faila] = NULL;\n\tblocks[disks-1] = dq;\n\toffs[disks-1] = dq_off;\n\n\t \n\tif (good_srcs == 1) {\n\t\tstruct page *g = blocks[good];\n\t\tunsigned int g_off = offs[good];\n\n\t\tinit_async_submit(submit, ASYNC_TX_FENCE, tx, NULL, NULL,\n\t\t\t\t  scribble);\n\t\ttx = async_memcpy(p, g, p_off, g_off, bytes, submit);\n\n\t\tinit_async_submit(submit, ASYNC_TX_FENCE, tx, NULL, NULL,\n\t\t\t\t  scribble);\n\t\ttx = async_mult(dq, dq_off, g, g_off,\n\t\t\t\traid6_gfexp[good], bytes, submit);\n\t} else {\n\t\tinit_async_submit(submit, ASYNC_TX_FENCE, tx, NULL, NULL,\n\t\t\t\t  scribble);\n\t\ttx = async_gen_syndrome(blocks, offs, disks, bytes, submit);\n\t}\n\n\t \n\tblocks[faila]   = dq;\n\toffs[faila] = dq_off;\n\tblocks[disks-1] = q;\n\toffs[disks-1] = q_off;\n\n\t \n\tcoef = raid6_gfinv[raid6_gfexp[faila]];\n\n\tsrcs[0] = dq;\n\tsrc_offs[0] = dq_off;\n\tsrcs[1] = q;\n\tsrc_offs[1] = q_off;\n\tinit_async_submit(submit, ASYNC_TX_FENCE|ASYNC_TX_XOR_DROP_DST, tx,\n\t\t\t  NULL, NULL, scribble);\n\ttx = async_xor_offs(dq, dq_off, srcs, src_offs, 2, bytes, submit);\n\n\tinit_async_submit(submit, ASYNC_TX_FENCE, tx, NULL, NULL, scribble);\n\ttx = async_mult(dq, dq_off, dq, dq_off, coef, bytes, submit);\n\n\tsrcs[0] = p;\n\tsrc_offs[0] = p_off;\n\tsrcs[1] = dq;\n\tsrc_offs[1] = dq_off;\n\tinit_async_submit(submit, flags | ASYNC_TX_XOR_DROP_DST, tx, cb_fn,\n\t\t\t  cb_param, scribble);\n\ttx = async_xor_offs(p, p_off, srcs, src_offs, 2, bytes, submit);\n\n\treturn tx;\n}\nEXPORT_SYMBOL_GPL(async_raid6_datap_recov);\n\nMODULE_AUTHOR(\"Dan Williams <dan.j.williams@intel.com>\");\nMODULE_DESCRIPTION(\"asynchronous RAID-6 recovery api\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}