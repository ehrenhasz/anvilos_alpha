{
  "module_name": "async_xor.c",
  "hash_id": "828f62612430541fbdb9c93f54ad56a8f35ded800e3b1fd1a7da37577a79f32a",
  "original_prompt": "Ingested from linux-6.6.14/crypto/async_tx/async_xor.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/dma-mapping.h>\n#include <linux/raid/xor.h>\n#include <linux/async_tx.h>\n\n \nstatic __async_inline struct dma_async_tx_descriptor *\ndo_async_xor(struct dma_chan *chan, struct dmaengine_unmap_data *unmap,\n\t     struct async_submit_ctl *submit)\n{\n\tstruct dma_device *dma = chan->device;\n\tstruct dma_async_tx_descriptor *tx = NULL;\n\tdma_async_tx_callback cb_fn_orig = submit->cb_fn;\n\tvoid *cb_param_orig = submit->cb_param;\n\tenum async_tx_flags flags_orig = submit->flags;\n\tenum dma_ctrl_flags dma_flags = 0;\n\tint src_cnt = unmap->to_cnt;\n\tint xor_src_cnt;\n\tdma_addr_t dma_dest = unmap->addr[unmap->to_cnt];\n\tdma_addr_t *src_list = unmap->addr;\n\n\twhile (src_cnt) {\n\t\tdma_addr_t tmp;\n\n\t\tsubmit->flags = flags_orig;\n\t\txor_src_cnt = min(src_cnt, (int)dma->max_xor);\n\t\t \n\t\tif (src_cnt > xor_src_cnt) {\n\t\t\tsubmit->flags &= ~ASYNC_TX_ACK;\n\t\t\tsubmit->flags |= ASYNC_TX_FENCE;\n\t\t\tsubmit->cb_fn = NULL;\n\t\t\tsubmit->cb_param = NULL;\n\t\t} else {\n\t\t\tsubmit->cb_fn = cb_fn_orig;\n\t\t\tsubmit->cb_param = cb_param_orig;\n\t\t}\n\t\tif (submit->cb_fn)\n\t\t\tdma_flags |= DMA_PREP_INTERRUPT;\n\t\tif (submit->flags & ASYNC_TX_FENCE)\n\t\t\tdma_flags |= DMA_PREP_FENCE;\n\n\t\t \n\t\ttmp = src_list[0];\n\t\tif (src_list > unmap->addr)\n\t\t\tsrc_list[0] = dma_dest;\n\t\ttx = dma->device_prep_dma_xor(chan, dma_dest, src_list,\n\t\t\t\t\t      xor_src_cnt, unmap->len,\n\t\t\t\t\t      dma_flags);\n\n\t\tif (unlikely(!tx))\n\t\t\tasync_tx_quiesce(&submit->depend_tx);\n\n\t\t \n\t\twhile (unlikely(!tx)) {\n\t\t\tdma_async_issue_pending(chan);\n\t\t\ttx = dma->device_prep_dma_xor(chan, dma_dest,\n\t\t\t\t\t\t      src_list,\n\t\t\t\t\t\t      xor_src_cnt, unmap->len,\n\t\t\t\t\t\t      dma_flags);\n\t\t}\n\t\tsrc_list[0] = tmp;\n\n\t\tdma_set_unmap(tx, unmap);\n\t\tasync_tx_submit(chan, tx, submit);\n\t\tsubmit->depend_tx = tx;\n\n\t\tif (src_cnt > xor_src_cnt) {\n\t\t\t \n\t\t\tsrc_cnt -= xor_src_cnt;\n\t\t\t \n\t\t\tsrc_cnt++;\n\t\t\tsrc_list += xor_src_cnt - 1;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\treturn tx;\n}\n\nstatic void\ndo_sync_xor_offs(struct page *dest, unsigned int offset,\n\t\tstruct page **src_list, unsigned int *src_offs,\n\t    int src_cnt, size_t len, struct async_submit_ctl *submit)\n{\n\tint i;\n\tint xor_src_cnt = 0;\n\tint src_off = 0;\n\tvoid *dest_buf;\n\tvoid **srcs;\n\n\tif (submit->scribble)\n\t\tsrcs = submit->scribble;\n\telse\n\t\tsrcs = (void **) src_list;\n\n\t \n\tfor (i = 0; i < src_cnt; i++)\n\t\tif (src_list[i])\n\t\t\tsrcs[xor_src_cnt++] = page_address(src_list[i]) +\n\t\t\t\t(src_offs ? src_offs[i] : offset);\n\tsrc_cnt = xor_src_cnt;\n\t \n\tdest_buf = page_address(dest) + offset;\n\n\tif (submit->flags & ASYNC_TX_XOR_ZERO_DST)\n\t\tmemset(dest_buf, 0, len);\n\n\twhile (src_cnt > 0) {\n\t\t \n\t\txor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);\n\t\txor_blocks(xor_src_cnt, len, dest_buf, &srcs[src_off]);\n\n\t\t \n\t\tsrc_cnt -= xor_src_cnt;\n\t\tsrc_off += xor_src_cnt;\n\t}\n\n\tasync_tx_sync_epilog(submit);\n}\n\nstatic inline bool\ndma_xor_aligned_offsets(struct dma_device *device, unsigned int offset,\n\t\tunsigned int *src_offs, int src_cnt, int len)\n{\n\tint i;\n\n\tif (!is_dma_xor_aligned(device, offset, 0, len))\n\t\treturn false;\n\n\tif (!src_offs)\n\t\treturn true;\n\n\tfor (i = 0; i < src_cnt; i++) {\n\t\tif (!is_dma_xor_aligned(device, src_offs[i], 0, len))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstruct dma_async_tx_descriptor *\nasync_xor_offs(struct page *dest, unsigned int offset,\n\t\tstruct page **src_list, unsigned int *src_offs,\n\t\tint src_cnt, size_t len, struct async_submit_ctl *submit)\n{\n\tstruct dma_chan *chan = async_tx_find_channel(submit, DMA_XOR,\n\t\t\t\t\t\t      &dest, 1, src_list,\n\t\t\t\t\t\t      src_cnt, len);\n\tstruct dma_device *device = chan ? chan->device : NULL;\n\tstruct dmaengine_unmap_data *unmap = NULL;\n\n\tBUG_ON(src_cnt <= 1);\n\n\tif (device)\n\t\tunmap = dmaengine_get_unmap_data(device->dev, src_cnt+1, GFP_NOWAIT);\n\n\tif (unmap && dma_xor_aligned_offsets(device, offset,\n\t\t\t\tsrc_offs, src_cnt, len)) {\n\t\tstruct dma_async_tx_descriptor *tx;\n\t\tint i, j;\n\n\t\t \n\t\tpr_debug(\"%s (async): len: %zu\\n\", __func__, len);\n\n\t\tunmap->len = len;\n\t\tfor (i = 0, j = 0; i < src_cnt; i++) {\n\t\t\tif (!src_list[i])\n\t\t\t\tcontinue;\n\t\t\tunmap->to_cnt++;\n\t\t\tunmap->addr[j++] = dma_map_page(device->dev, src_list[i],\n\t\t\t\t\tsrc_offs ? src_offs[i] : offset,\n\t\t\t\t\tlen, DMA_TO_DEVICE);\n\t\t}\n\n\t\t \n\t\tunmap->addr[j] = dma_map_page(device->dev, dest, offset, len,\n\t\t\t\t\t      DMA_BIDIRECTIONAL);\n\t\tunmap->bidi_cnt = 1;\n\n\t\ttx = do_async_xor(chan, unmap, submit);\n\t\tdmaengine_unmap_put(unmap);\n\t\treturn tx;\n\t} else {\n\t\tdmaengine_unmap_put(unmap);\n\t\t \n\t\tpr_debug(\"%s (sync): len: %zu\\n\", __func__, len);\n\t\tWARN_ONCE(chan, \"%s: no space for dma address conversion\\n\",\n\t\t\t  __func__);\n\n\t\t \n\t\tif (submit->flags & ASYNC_TX_XOR_DROP_DST) {\n\t\t\tsrc_cnt--;\n\t\t\tsrc_list++;\n\t\t\tif (src_offs)\n\t\t\t\tsrc_offs++;\n\t\t}\n\n\t\t \n\t\tasync_tx_quiesce(&submit->depend_tx);\n\n\t\tdo_sync_xor_offs(dest, offset, src_list, src_offs,\n\t\t\t\tsrc_cnt, len, submit);\n\n\t\treturn NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(async_xor_offs);\n\n \nstruct dma_async_tx_descriptor *\nasync_xor(struct page *dest, struct page **src_list, unsigned int offset,\n\t  int src_cnt, size_t len, struct async_submit_ctl *submit)\n{\n\treturn async_xor_offs(dest, offset, src_list, NULL,\n\t\t\tsrc_cnt, len, submit);\n}\nEXPORT_SYMBOL_GPL(async_xor);\n\nstatic int page_is_zero(struct page *p, unsigned int offset, size_t len)\n{\n\treturn !memchr_inv(page_address(p) + offset, 0, len);\n}\n\nstatic inline struct dma_chan *\nxor_val_chan(struct async_submit_ctl *submit, struct page *dest,\n\t\t struct page **src_list, int src_cnt, size_t len)\n{\n\t#ifdef CONFIG_ASYNC_TX_DISABLE_XOR_VAL_DMA\n\treturn NULL;\n\t#endif\n\treturn async_tx_find_channel(submit, DMA_XOR_VAL, &dest, 1, src_list,\n\t\t\t\t     src_cnt, len);\n}\n\n \nstruct dma_async_tx_descriptor *\nasync_xor_val_offs(struct page *dest, unsigned int offset,\n\t\tstruct page **src_list, unsigned int *src_offs,\n\t\tint src_cnt, size_t len, enum sum_check_flags *result,\n\t\tstruct async_submit_ctl *submit)\n{\n\tstruct dma_chan *chan = xor_val_chan(submit, dest, src_list, src_cnt, len);\n\tstruct dma_device *device = chan ? chan->device : NULL;\n\tstruct dma_async_tx_descriptor *tx = NULL;\n\tstruct dmaengine_unmap_data *unmap = NULL;\n\n\tBUG_ON(src_cnt <= 1);\n\n\tif (device)\n\t\tunmap = dmaengine_get_unmap_data(device->dev, src_cnt, GFP_NOWAIT);\n\n\tif (unmap && src_cnt <= device->max_xor &&\n\t    dma_xor_aligned_offsets(device, offset, src_offs, src_cnt, len)) {\n\t\tunsigned long dma_prep_flags = 0;\n\t\tint i;\n\n\t\tpr_debug(\"%s: (async) len: %zu\\n\", __func__, len);\n\n\t\tif (submit->cb_fn)\n\t\t\tdma_prep_flags |= DMA_PREP_INTERRUPT;\n\t\tif (submit->flags & ASYNC_TX_FENCE)\n\t\t\tdma_prep_flags |= DMA_PREP_FENCE;\n\n\t\tfor (i = 0; i < src_cnt; i++) {\n\t\t\tunmap->addr[i] = dma_map_page(device->dev, src_list[i],\n\t\t\t\t\tsrc_offs ? src_offs[i] : offset,\n\t\t\t\t\tlen, DMA_TO_DEVICE);\n\t\t\tunmap->to_cnt++;\n\t\t}\n\t\tunmap->len = len;\n\n\t\ttx = device->device_prep_dma_xor_val(chan, unmap->addr, src_cnt,\n\t\t\t\t\t\t     len, result,\n\t\t\t\t\t\t     dma_prep_flags);\n\t\tif (unlikely(!tx)) {\n\t\t\tasync_tx_quiesce(&submit->depend_tx);\n\n\t\t\twhile (!tx) {\n\t\t\t\tdma_async_issue_pending(chan);\n\t\t\t\ttx = device->device_prep_dma_xor_val(chan,\n\t\t\t\t\tunmap->addr, src_cnt, len, result,\n\t\t\t\t\tdma_prep_flags);\n\t\t\t}\n\t\t}\n\t\tdma_set_unmap(tx, unmap);\n\t\tasync_tx_submit(chan, tx, submit);\n\t} else {\n\t\tenum async_tx_flags flags_orig = submit->flags;\n\n\t\tpr_debug(\"%s: (sync) len: %zu\\n\", __func__, len);\n\t\tWARN_ONCE(device && src_cnt <= device->max_xor,\n\t\t\t  \"%s: no space for dma address conversion\\n\",\n\t\t\t  __func__);\n\n\t\tsubmit->flags |= ASYNC_TX_XOR_DROP_DST;\n\t\tsubmit->flags &= ~ASYNC_TX_ACK;\n\n\t\ttx = async_xor_offs(dest, offset, src_list, src_offs,\n\t\t\t\tsrc_cnt, len, submit);\n\n\t\tasync_tx_quiesce(&tx);\n\n\t\t*result = !page_is_zero(dest, offset, len) << SUM_CHECK_P;\n\n\t\tasync_tx_sync_epilog(submit);\n\t\tsubmit->flags = flags_orig;\n\t}\n\tdmaengine_unmap_put(unmap);\n\n\treturn tx;\n}\nEXPORT_SYMBOL_GPL(async_xor_val_offs);\n\n \nstruct dma_async_tx_descriptor *\nasync_xor_val(struct page *dest, struct page **src_list, unsigned int offset,\n\t      int src_cnt, size_t len, enum sum_check_flags *result,\n\t      struct async_submit_ctl *submit)\n{\n\treturn async_xor_val_offs(dest, offset, src_list, NULL, src_cnt,\n\t\t\tlen, result, submit);\n}\nEXPORT_SYMBOL_GPL(async_xor_val);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_DESCRIPTION(\"asynchronous xor/xor-zero-sum api\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}