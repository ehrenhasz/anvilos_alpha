{
  "module_name": "raid6test.c",
  "hash_id": "0cc015553e708e30b9a792c2755777941d6894b3f8b356f3d38d68ef5dfecf62",
  "original_prompt": "Ingested from linux-6.6.14/crypto/async_tx/raid6test.c",
  "human_readable_source": "\n \n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n#include <linux/random.h>\n#include <linux/module.h>\n\n#undef pr\n#define pr(fmt, args...) pr_info(\"raid6test: \" fmt, ##args)\n\n#define NDISKS 64  \n\nstatic struct page *dataptrs[NDISKS];\nunsigned int dataoffs[NDISKS];\nstatic addr_conv_t addr_conv[NDISKS];\nstatic struct page *data[NDISKS+3];\nstatic struct page *spare;\nstatic struct page *recovi;\nstatic struct page *recovj;\n\nstatic void callback(void *param)\n{\n\tstruct completion *cmp = param;\n\n\tcomplete(cmp);\n}\n\nstatic void makedata(int disks)\n{\n\tint i;\n\n\tfor (i = 0; i < disks; i++) {\n\t\tget_random_bytes(page_address(data[i]), PAGE_SIZE);\n\t\tdataptrs[i] = data[i];\n\t\tdataoffs[i] = 0;\n\t}\n}\n\nstatic char disk_type(int d, int disks)\n{\n\tif (d == disks - 2)\n\t\treturn 'P';\n\telse if (d == disks - 1)\n\t\treturn 'Q';\n\telse\n\t\treturn 'D';\n}\n\n \nstatic void raid6_dual_recov(int disks, size_t bytes, int faila, int failb,\n\t\tstruct page **ptrs, unsigned int *offs)\n{\n\tstruct async_submit_ctl submit;\n\tstruct completion cmp;\n\tstruct dma_async_tx_descriptor *tx = NULL;\n\tenum sum_check_flags result = ~0;\n\n\tif (faila > failb)\n\t\tswap(faila, failb);\n\n\tif (failb == disks-1) {\n\t\tif (faila == disks-2) {\n\t\t\t \n\t\t\tinit_async_submit(&submit, 0, NULL, NULL, NULL, addr_conv);\n\t\t\ttx = async_gen_syndrome(ptrs, offs,\n\t\t\t\t\tdisks, bytes, &submit);\n\t\t} else {\n\t\t\tstruct page *blocks[NDISKS];\n\t\t\tstruct page *dest;\n\t\t\tint count = 0;\n\t\t\tint i;\n\n\t\t\tBUG_ON(disks > NDISKS);\n\n\t\t\t \n\t\t\tfor (i = disks; i-- ; ) {\n\t\t\t\tif (i == faila || i == failb)\n\t\t\t\t\tcontinue;\n\t\t\t\tblocks[count++] = ptrs[i];\n\t\t\t}\n\t\t\tdest = ptrs[faila];\n\t\t\tinit_async_submit(&submit, ASYNC_TX_XOR_ZERO_DST, NULL,\n\t\t\t\t\t  NULL, NULL, addr_conv);\n\t\t\ttx = async_xor(dest, blocks, 0, count, bytes, &submit);\n\n\t\t\tinit_async_submit(&submit, 0, tx, NULL, NULL, addr_conv);\n\t\t\ttx = async_gen_syndrome(ptrs, offs,\n\t\t\t\t\tdisks, bytes, &submit);\n\t\t}\n\t} else {\n\t\tif (failb == disks-2) {\n\t\t\t \n\t\t\tinit_async_submit(&submit, 0, NULL, NULL, NULL, addr_conv);\n\t\t\ttx = async_raid6_datap_recov(disks, bytes,\n\t\t\t\t\tfaila, ptrs, offs, &submit);\n\t\t} else {\n\t\t\t \n\t\t\tinit_async_submit(&submit, 0, NULL, NULL, NULL, addr_conv);\n\t\t\ttx = async_raid6_2data_recov(disks, bytes,\n\t\t\t\t\tfaila, failb, ptrs, offs, &submit);\n\t\t}\n\t}\n\tinit_completion(&cmp);\n\tinit_async_submit(&submit, ASYNC_TX_ACK, tx, callback, &cmp, addr_conv);\n\ttx = async_syndrome_val(ptrs, offs,\n\t\t\tdisks, bytes, &result, spare, 0, &submit);\n\tasync_tx_issue_pending(tx);\n\n\tif (wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000)) == 0)\n\t\tpr(\"%s: timeout! (faila: %d failb: %d disks: %d)\\n\",\n\t\t   __func__, faila, failb, disks);\n\n\tif (result != 0)\n\t\tpr(\"%s: validation failure! faila: %d failb: %d sum_check_flags: %x\\n\",\n\t\t   __func__, faila, failb, result);\n}\n\nstatic int test_disks(int i, int j, int disks)\n{\n\tint erra, errb;\n\n\tmemset(page_address(recovi), 0xf0, PAGE_SIZE);\n\tmemset(page_address(recovj), 0xba, PAGE_SIZE);\n\n\tdataptrs[i] = recovi;\n\tdataptrs[j] = recovj;\n\n\traid6_dual_recov(disks, PAGE_SIZE, i, j, dataptrs, dataoffs);\n\n\terra = memcmp(page_address(data[i]), page_address(recovi), PAGE_SIZE);\n\terrb = memcmp(page_address(data[j]), page_address(recovj), PAGE_SIZE);\n\n\tpr(\"%s(%d, %d): faila=%3d(%c)  failb=%3d(%c)  %s\\n\",\n\t   __func__, i, j, i, disk_type(i, disks), j, disk_type(j, disks),\n\t   (!erra && !errb) ? \"OK\" : !erra ? \"ERRB\" : !errb ? \"ERRA\" : \"ERRAB\");\n\n\tdataptrs[i] = data[i];\n\tdataptrs[j] = data[j];\n\n\treturn erra || errb;\n}\n\nstatic int test(int disks, int *tests)\n{\n\tstruct dma_async_tx_descriptor *tx;\n\tstruct async_submit_ctl submit;\n\tstruct completion cmp;\n\tint err = 0;\n\tint i, j;\n\n\trecovi = data[disks];\n\trecovj = data[disks+1];\n\tspare  = data[disks+2];\n\n\tmakedata(disks);\n\n\t \n\tmemset(page_address(data[disks-2]), 0xee, PAGE_SIZE);\n\tmemset(page_address(data[disks-1]), 0xee, PAGE_SIZE);\n\n\t \n\tinit_completion(&cmp);\n\tinit_async_submit(&submit, ASYNC_TX_ACK, NULL, callback, &cmp, addr_conv);\n\ttx = async_gen_syndrome(dataptrs, dataoffs, disks, PAGE_SIZE, &submit);\n\tasync_tx_issue_pending(tx);\n\n\tif (wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000)) == 0) {\n\t\tpr(\"error: initial gen_syndrome(%d) timed out\\n\", disks);\n\t\treturn 1;\n\t}\n\n\tpr(\"testing the %d-disk case...\\n\", disks);\n\tfor (i = 0; i < disks-1; i++)\n\t\tfor (j = i+1; j < disks; j++) {\n\t\t\t(*tests)++;\n\t\t\terr += test_disks(i, j, disks);\n\t\t}\n\n\treturn err;\n}\n\n\nstatic int __init raid6_test(void)\n{\n\tint err = 0;\n\tint tests = 0;\n\tint i;\n\n\tfor (i = 0; i < NDISKS+3; i++) {\n\t\tdata[i] = alloc_page(GFP_KERNEL);\n\t\tif (!data[i]) {\n\t\t\twhile (i--)\n\t\t\t\tput_page(data[i]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tif (NDISKS > 4)\n\t\terr += test(4, &tests);\n\tif (NDISKS > 5)\n\t\terr += test(5, &tests);\n\t \n\tif (NDISKS > 12) {\n\t\terr += test(11, &tests);\n\t\terr += test(12, &tests);\n\t}\n\n\t \n\tif (NDISKS > 24)\n\t\terr += test(24, &tests);\n\n\terr += test(NDISKS, &tests);\n\n\tpr(\"\\n\");\n\tpr(\"complete (%d tests, %d failure%s)\\n\",\n\t   tests, err, err == 1 ? \"\" : \"s\");\n\n\tfor (i = 0; i < NDISKS+3; i++)\n\t\tput_page(data[i]);\n\n\treturn 0;\n}\n\nstatic void __exit raid6_test_exit(void)\n{\n}\n\n \nlate_initcall(raid6_test);\nmodule_exit(raid6_test_exit);\nMODULE_AUTHOR(\"Dan Williams <dan.j.williams@intel.com>\");\nMODULE_DESCRIPTION(\"asynchronous RAID-6 recovery self tests\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}