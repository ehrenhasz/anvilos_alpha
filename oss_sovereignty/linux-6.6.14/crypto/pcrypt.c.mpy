{
  "module_name": "pcrypt.c",
  "hash_id": "1dda0b39c12a16ffd7870b29eee3a5065542880d578e3b44ef406c129c127230",
  "original_prompt": "Ingested from linux-6.6.14/crypto/pcrypt.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/aead.h>\n#include <linux/atomic.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <linux/cpu.h>\n#include <crypto/pcrypt.h>\n\nstatic struct padata_instance *pencrypt;\nstatic struct padata_instance *pdecrypt;\nstatic struct kset           *pcrypt_kset;\n\nstruct pcrypt_instance_ctx {\n\tstruct crypto_aead_spawn spawn;\n\tstruct padata_shell *psenc;\n\tstruct padata_shell *psdec;\n\tatomic_t tfm_count;\n};\n\nstruct pcrypt_aead_ctx {\n\tstruct crypto_aead *child;\n\tunsigned int cb_cpu;\n};\n\nstatic inline struct pcrypt_instance_ctx *pcrypt_tfm_ictx(\n\tstruct crypto_aead *tfm)\n{\n\treturn aead_instance_ctx(aead_alg_instance(tfm));\n}\n\nstatic int pcrypt_aead_setkey(struct crypto_aead *parent,\n\t\t\t      const u8 *key, unsigned int keylen)\n{\n\tstruct pcrypt_aead_ctx *ctx = crypto_aead_ctx(parent);\n\n\treturn crypto_aead_setkey(ctx->child, key, keylen);\n}\n\nstatic int pcrypt_aead_setauthsize(struct crypto_aead *parent,\n\t\t\t\t   unsigned int authsize)\n{\n\tstruct pcrypt_aead_ctx *ctx = crypto_aead_ctx(parent);\n\n\treturn crypto_aead_setauthsize(ctx->child, authsize);\n}\n\nstatic void pcrypt_aead_serial(struct padata_priv *padata)\n{\n\tstruct pcrypt_request *preq = pcrypt_padata_request(padata);\n\tstruct aead_request *req = pcrypt_request_ctx(preq);\n\n\taead_request_complete(req->base.data, padata->info);\n}\n\nstatic void pcrypt_aead_done(void *data, int err)\n{\n\tstruct aead_request *req = data;\n\tstruct pcrypt_request *preq = aead_request_ctx(req);\n\tstruct padata_priv *padata = pcrypt_request_padata(preq);\n\n\tpadata->info = err;\n\n\tpadata_do_serial(padata);\n}\n\nstatic void pcrypt_aead_enc(struct padata_priv *padata)\n{\n\tstruct pcrypt_request *preq = pcrypt_padata_request(padata);\n\tstruct aead_request *req = pcrypt_request_ctx(preq);\n\tint ret;\n\n\tret = crypto_aead_encrypt(req);\n\n\tif (ret == -EINPROGRESS)\n\t\treturn;\n\n\tpadata->info = ret;\n\tpadata_do_serial(padata);\n}\n\nstatic int pcrypt_aead_encrypt(struct aead_request *req)\n{\n\tint err;\n\tstruct pcrypt_request *preq = aead_request_ctx(req);\n\tstruct aead_request *creq = pcrypt_request_ctx(preq);\n\tstruct padata_priv *padata = pcrypt_request_padata(preq);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct pcrypt_aead_ctx *ctx = crypto_aead_ctx(aead);\n\tu32 flags = aead_request_flags(req);\n\tstruct pcrypt_instance_ctx *ictx;\n\n\tictx = pcrypt_tfm_ictx(aead);\n\n\tmemset(padata, 0, sizeof(struct padata_priv));\n\n\tpadata->parallel = pcrypt_aead_enc;\n\tpadata->serial = pcrypt_aead_serial;\n\n\taead_request_set_tfm(creq, ctx->child);\n\taead_request_set_callback(creq, flags & ~CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t  pcrypt_aead_done, req);\n\taead_request_set_crypt(creq, req->src, req->dst,\n\t\t\t       req->cryptlen, req->iv);\n\taead_request_set_ad(creq, req->assoclen);\n\n\terr = padata_do_parallel(ictx->psenc, padata, &ctx->cb_cpu);\n\tif (!err)\n\t\treturn -EINPROGRESS;\n\tif (err == -EBUSY)\n\t\treturn -EAGAIN;\n\n\treturn err;\n}\n\nstatic void pcrypt_aead_dec(struct padata_priv *padata)\n{\n\tstruct pcrypt_request *preq = pcrypt_padata_request(padata);\n\tstruct aead_request *req = pcrypt_request_ctx(preq);\n\tint ret;\n\n\tret = crypto_aead_decrypt(req);\n\n\tif (ret == -EINPROGRESS)\n\t\treturn;\n\n\tpadata->info = ret;\n\tpadata_do_serial(padata);\n}\n\nstatic int pcrypt_aead_decrypt(struct aead_request *req)\n{\n\tint err;\n\tstruct pcrypt_request *preq = aead_request_ctx(req);\n\tstruct aead_request *creq = pcrypt_request_ctx(preq);\n\tstruct padata_priv *padata = pcrypt_request_padata(preq);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct pcrypt_aead_ctx *ctx = crypto_aead_ctx(aead);\n\tu32 flags = aead_request_flags(req);\n\tstruct pcrypt_instance_ctx *ictx;\n\n\tictx = pcrypt_tfm_ictx(aead);\n\n\tmemset(padata, 0, sizeof(struct padata_priv));\n\n\tpadata->parallel = pcrypt_aead_dec;\n\tpadata->serial = pcrypt_aead_serial;\n\n\taead_request_set_tfm(creq, ctx->child);\n\taead_request_set_callback(creq, flags & ~CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t  pcrypt_aead_done, req);\n\taead_request_set_crypt(creq, req->src, req->dst,\n\t\t\t       req->cryptlen, req->iv);\n\taead_request_set_ad(creq, req->assoclen);\n\n\terr = padata_do_parallel(ictx->psdec, padata, &ctx->cb_cpu);\n\tif (!err)\n\t\treturn -EINPROGRESS;\n\tif (err == -EBUSY)\n\t\treturn -EAGAIN;\n\n\treturn err;\n}\n\nstatic int pcrypt_aead_init_tfm(struct crypto_aead *tfm)\n{\n\tint cpu, cpu_index;\n\tstruct aead_instance *inst = aead_alg_instance(tfm);\n\tstruct pcrypt_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct pcrypt_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_aead *cipher;\n\n\tcpu_index = (unsigned int)atomic_inc_return(&ictx->tfm_count) %\n\t\t    cpumask_weight(cpu_online_mask);\n\n\tctx->cb_cpu = cpumask_first(cpu_online_mask);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\tctx->cb_cpu = cpumask_next(ctx->cb_cpu, cpu_online_mask);\n\n\tcipher = crypto_spawn_aead(&ictx->spawn);\n\n\tif (IS_ERR(cipher))\n\t\treturn PTR_ERR(cipher);\n\n\tctx->child = cipher;\n\tcrypto_aead_set_reqsize(tfm, sizeof(struct pcrypt_request) +\n\t\t\t\t     sizeof(struct aead_request) +\n\t\t\t\t     crypto_aead_reqsize(cipher));\n\n\treturn 0;\n}\n\nstatic void pcrypt_aead_exit_tfm(struct crypto_aead *tfm)\n{\n\tstruct pcrypt_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_aead(ctx->child);\n}\n\nstatic void pcrypt_free(struct aead_instance *inst)\n{\n\tstruct pcrypt_instance_ctx *ctx = aead_instance_ctx(inst);\n\n\tcrypto_drop_aead(&ctx->spawn);\n\tpadata_free_shell(ctx->psdec);\n\tpadata_free_shell(ctx->psenc);\n\tkfree(inst);\n}\n\nstatic int pcrypt_init_instance(struct crypto_instance *inst,\n\t\t\t\tstruct crypto_alg *alg)\n{\n\tif (snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"pcrypt(%s)\", alg->cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\tmemcpy(inst->alg.cra_name, alg->cra_name, CRYPTO_MAX_ALG_NAME);\n\n\tinst->alg.cra_priority = alg->cra_priority + 100;\n\tinst->alg.cra_blocksize = alg->cra_blocksize;\n\tinst->alg.cra_alignmask = alg->cra_alignmask;\n\n\treturn 0;\n}\n\nstatic int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct crypto_attr_type *algt)\n{\n\tstruct pcrypt_instance_ctx *ctx;\n\tstruct aead_instance *inst;\n\tstruct aead_alg *alg;\n\tu32 mask = crypto_algt_inherited_mask(algt);\n\tint err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\terr = -ENOMEM;\n\n\tctx = aead_instance_ctx(inst);\n\tctx->psenc = padata_alloc_shell(pencrypt);\n\tif (!ctx->psenc)\n\t\tgoto err_free_inst;\n\n\tctx->psdec = padata_alloc_shell(pdecrypt);\n\tif (!ctx->psdec)\n\t\tgoto err_free_inst;\n\n\terr = crypto_grab_aead(&ctx->spawn, aead_crypto_instance(inst),\n\t\t\t       crypto_attr_alg_name(tb[1]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\talg = crypto_spawn_aead_alg(&ctx->spawn);\n\terr = pcrypt_init_instance(aead_crypto_instance(inst), &alg->base);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\tinst->alg.base.cra_flags |= CRYPTO_ALG_ASYNC;\n\n\tinst->alg.ivsize = crypto_aead_alg_ivsize(alg);\n\tinst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct pcrypt_aead_ctx);\n\n\tinst->alg.init = pcrypt_aead_init_tfm;\n\tinst->alg.exit = pcrypt_aead_exit_tfm;\n\n\tinst->alg.setkey = pcrypt_aead_setkey;\n\tinst->alg.setauthsize = pcrypt_aead_setauthsize;\n\tinst->alg.encrypt = pcrypt_aead_encrypt;\n\tinst->alg.decrypt = pcrypt_aead_decrypt;\n\n\tinst->free = pcrypt_free;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tpcrypt_free(inst);\n\t}\n\treturn err;\n}\n\nstatic int pcrypt_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct crypto_attr_type *algt;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\n\tswitch (algt->type & algt->mask & CRYPTO_ALG_TYPE_MASK) {\n\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\treturn pcrypt_create_aead(tmpl, tb, algt);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int pcrypt_sysfs_add(struct padata_instance *pinst, const char *name)\n{\n\tint ret;\n\n\tpinst->kobj.kset = pcrypt_kset;\n\tret = kobject_add(&pinst->kobj, NULL, \"%s\", name);\n\tif (!ret)\n\t\tkobject_uevent(&pinst->kobj, KOBJ_ADD);\n\n\treturn ret;\n}\n\nstatic int pcrypt_init_padata(struct padata_instance **pinst, const char *name)\n{\n\tint ret = -ENOMEM;\n\n\t*pinst = padata_alloc(name);\n\tif (!*pinst)\n\t\treturn ret;\n\n\tret = pcrypt_sysfs_add(*pinst, name);\n\tif (ret)\n\t\tpadata_free(*pinst);\n\n\treturn ret;\n}\n\nstatic struct crypto_template pcrypt_tmpl = {\n\t.name = \"pcrypt\",\n\t.create = pcrypt_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init pcrypt_init(void)\n{\n\tint err = -ENOMEM;\n\n\tpcrypt_kset = kset_create_and_add(\"pcrypt\", NULL, kernel_kobj);\n\tif (!pcrypt_kset)\n\t\tgoto err;\n\n\terr = pcrypt_init_padata(&pencrypt, \"pencrypt\");\n\tif (err)\n\t\tgoto err_unreg_kset;\n\n\terr = pcrypt_init_padata(&pdecrypt, \"pdecrypt\");\n\tif (err)\n\t\tgoto err_deinit_pencrypt;\n\n\treturn crypto_register_template(&pcrypt_tmpl);\n\nerr_deinit_pencrypt:\n\tpadata_free(pencrypt);\nerr_unreg_kset:\n\tkset_unregister(pcrypt_kset);\nerr:\n\treturn err;\n}\n\nstatic void __exit pcrypt_exit(void)\n{\n\tcrypto_unregister_template(&pcrypt_tmpl);\n\n\tpadata_free(pencrypt);\n\tpadata_free(pdecrypt);\n\n\tkset_unregister(pcrypt_kset);\n}\n\nsubsys_initcall(pcrypt_init);\nmodule_exit(pcrypt_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Steffen Klassert <steffen.klassert@secunet.com>\");\nMODULE_DESCRIPTION(\"Parallel crypto wrapper\");\nMODULE_ALIAS_CRYPTO(\"pcrypt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}