{
  "module_name": "cast6_generic.c",
  "hash_id": "cad091e5a24a25f48386012ee5e6e93c52494ac81a00b0e25de97ad71a6f1dbc",
  "original_prompt": "Ingested from linux-6.6.14/crypto/cast6_generic.c",
  "human_readable_source": "\n \n\n\n#include <asm/unaligned.h>\n#include <crypto/algapi.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <crypto/cast6.h>\n\n#define s1 cast_s1\n#define s2 cast_s2\n#define s3 cast_s3\n#define s4 cast_s4\n\n#define F1(D, r, m)  ((I = ((m) + (D))), (I = rol32(I, (r))),   \\\n\t(((s1[I >> 24] ^ s2[(I>>16)&0xff]) - s3[(I>>8)&0xff]) + s4[I&0xff]))\n#define F2(D, r, m)  ((I = ((m) ^ (D))), (I = rol32(I, (r))),   \\\n\t(((s1[I >> 24] - s2[(I>>16)&0xff]) + s3[(I>>8)&0xff]) ^ s4[I&0xff]))\n#define F3(D, r, m)  ((I = ((m) - (D))), (I = rol32(I, (r))),   \\\n\t(((s1[I >> 24] + s2[(I>>16)&0xff]) ^ s3[(I>>8)&0xff]) - s4[I&0xff]))\n\nstatic const u32 Tm[24][8] = {\n\t{ 0x5a827999, 0xc95c653a, 0x383650db, 0xa7103c7c, 0x15ea281d,\n\t\t0x84c413be, 0xf39dff5f, 0x6277eb00 } ,\n\t{ 0xd151d6a1, 0x402bc242, 0xaf05ade3, 0x1ddf9984, 0x8cb98525,\n\t\t0xfb9370c6, 0x6a6d5c67, 0xd9474808 } ,\n\t{ 0x482133a9, 0xb6fb1f4a, 0x25d50aeb, 0x94aef68c, 0x0388e22d,\n\t\t0x7262cdce, 0xe13cb96f, 0x5016a510 } ,\n\t{ 0xbef090b1, 0x2dca7c52, 0x9ca467f3, 0x0b7e5394, 0x7a583f35,\n\t\t0xe9322ad6, 0x580c1677, 0xc6e60218 } ,\n\t{ 0x35bfedb9, 0xa499d95a, 0x1373c4fb, 0x824db09c, 0xf1279c3d,\n\t\t0x600187de, 0xcedb737f, 0x3db55f20 } ,\n\t{ 0xac8f4ac1, 0x1b693662, 0x8a432203, 0xf91d0da4, 0x67f6f945,\n\t\t0xd6d0e4e6, 0x45aad087, 0xb484bc28 } ,\n\t{ 0x235ea7c9, 0x9238936a, 0x01127f0b, 0x6fec6aac, 0xdec6564d,\n\t\t0x4da041ee, 0xbc7a2d8f, 0x2b541930 } ,\n\t{ 0x9a2e04d1, 0x0907f072, 0x77e1dc13, 0xe6bbc7b4, 0x5595b355,\n\t\t0xc46f9ef6, 0x33498a97, 0xa2237638 } ,\n\t{ 0x10fd61d9, 0x7fd74d7a, 0xeeb1391b, 0x5d8b24bc, 0xcc65105d,\n\t\t0x3b3efbfe, 0xaa18e79f, 0x18f2d340 } ,\n\t{ 0x87ccbee1, 0xf6a6aa82, 0x65809623, 0xd45a81c4, 0x43346d65,\n\t\t0xb20e5906, 0x20e844a7, 0x8fc23048 } ,\n\t{ 0xfe9c1be9, 0x6d76078a, 0xdc4ff32b, 0x4b29decc, 0xba03ca6d,\n\t\t0x28ddb60e, 0x97b7a1af, 0x06918d50 } ,\n\t{ 0x756b78f1, 0xe4456492, 0x531f5033, 0xc1f93bd4, 0x30d32775,\n\t\t0x9fad1316, 0x0e86feb7, 0x7d60ea58 } ,\n\t{ 0xec3ad5f9, 0x5b14c19a, 0xc9eead3b, 0x38c898dc, 0xa7a2847d,\n\t\t0x167c701e, 0x85565bbf, 0xf4304760 } ,\n\t{ 0x630a3301, 0xd1e41ea2, 0x40be0a43, 0xaf97f5e4, 0x1e71e185,\n\t\t0x8d4bcd26, 0xfc25b8c7, 0x6affa468 } ,\n\t{ 0xd9d99009, 0x48b37baa, 0xb78d674b, 0x266752ec, 0x95413e8d,\n\t\t0x041b2a2e, 0x72f515cf, 0xe1cf0170 } ,\n\t{ 0x50a8ed11, 0xbf82d8b2, 0x2e5cc453, 0x9d36aff4, 0x0c109b95,\n\t\t0x7aea8736, 0xe9c472d7, 0x589e5e78 } ,\n\t{ 0xc7784a19, 0x365235ba, 0xa52c215b, 0x14060cfc, 0x82dff89d,\n\t\t0xf1b9e43e, 0x6093cfdf, 0xcf6dbb80 } ,\n\t{ 0x3e47a721, 0xad2192c2, 0x1bfb7e63, 0x8ad56a04, 0xf9af55a5,\n\t\t0x68894146, 0xd7632ce7, 0x463d1888 } ,\n\t{ 0xb5170429, 0x23f0efca, 0x92cadb6b, 0x01a4c70c, 0x707eb2ad,\n\t\t0xdf589e4e, 0x4e3289ef, 0xbd0c7590 } ,\n\t{ 0x2be66131, 0x9ac04cd2, 0x099a3873, 0x78742414, 0xe74e0fb5,\n\t\t0x5627fb56, 0xc501e6f7, 0x33dbd298 } ,\n\t{ 0xa2b5be39, 0x118fa9da, 0x8069957b, 0xef43811c, 0x5e1d6cbd,\n\t\t0xccf7585e, 0x3bd143ff, 0xaaab2fa0 } ,\n\t{ 0x19851b41, 0x885f06e2, 0xf738f283, 0x6612de24, 0xd4ecc9c5,\n\t\t0x43c6b566, 0xb2a0a107, 0x217a8ca8 } ,\n\t{ 0x90547849, 0xff2e63ea, 0x6e084f8b, 0xdce23b2c, 0x4bbc26cd,\n\t\t0xba96126e, 0x296ffe0f, 0x9849e9b0 } ,\n\t{ 0x0723d551, 0x75fdc0f2, 0xe4d7ac93, 0x53b19834, 0xc28b83d5,\n\t\t0x31656f76, 0xa03f5b17, 0x0f1946b8 }\n};\n\nstatic const u8 Tr[4][8] = {\n\t{ 0x13, 0x04, 0x15, 0x06, 0x17, 0x08, 0x19, 0x0a } ,\n\t{ 0x1b, 0x0c, 0x1d, 0x0e, 0x1f, 0x10, 0x01, 0x12 } ,\n\t{ 0x03, 0x14, 0x05, 0x16, 0x07, 0x18, 0x09, 0x1a } ,\n\t{ 0x0b, 0x1c, 0x0d, 0x1e, 0x0f, 0x00, 0x11, 0x02 }\n};\n\n \nstatic inline void W(u32 *key, unsigned int i)\n{\n\tu32 I;\n\tkey[6] ^= F1(key[7], Tr[i % 4][0], Tm[i][0]);\n\tkey[5] ^= F2(key[6], Tr[i % 4][1], Tm[i][1]);\n\tkey[4] ^= F3(key[5], Tr[i % 4][2], Tm[i][2]);\n\tkey[3] ^= F1(key[4], Tr[i % 4][3], Tm[i][3]);\n\tkey[2] ^= F2(key[3], Tr[i % 4][4], Tm[i][4]);\n\tkey[1] ^= F3(key[2], Tr[i % 4][5], Tm[i][5]);\n\tkey[0] ^= F1(key[1], Tr[i % 4][6], Tm[i][6]);\n\tkey[7] ^= F2(key[0], Tr[i % 4][7], Tm[i][7]);\n}\n\nint __cast6_setkey(struct cast6_ctx *c, const u8 *in_key, unsigned int key_len)\n{\n\tint i;\n\tu32 key[8];\n\t__be32 p_key[8];  \n\n\tif (key_len % 4 != 0)\n\t\treturn -EINVAL;\n\n\tmemset(p_key, 0, 32);\n\tmemcpy(p_key, in_key, key_len);\n\n\tkey[0] = be32_to_cpu(p_key[0]);\t\t \n\tkey[1] = be32_to_cpu(p_key[1]);\t\t \n\tkey[2] = be32_to_cpu(p_key[2]);\t\t \n\tkey[3] = be32_to_cpu(p_key[3]);\t\t \n\tkey[4] = be32_to_cpu(p_key[4]);\t\t \n\tkey[5] = be32_to_cpu(p_key[5]);\t\t \n\tkey[6] = be32_to_cpu(p_key[6]);\t\t \n\tkey[7] = be32_to_cpu(p_key[7]);\t\t \n\n\tfor (i = 0; i < 12; i++) {\n\t\tW(key, 2 * i);\n\t\tW(key, 2 * i + 1);\n\n\t\tc->Kr[i][0] = key[0] & 0x1f;\n\t\tc->Kr[i][1] = key[2] & 0x1f;\n\t\tc->Kr[i][2] = key[4] & 0x1f;\n\t\tc->Kr[i][3] = key[6] & 0x1f;\n\n\t\tc->Km[i][0] = key[7];\n\t\tc->Km[i][1] = key[5];\n\t\tc->Km[i][2] = key[3];\n\t\tc->Km[i][3] = key[1];\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__cast6_setkey);\n\nint cast6_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)\n{\n\treturn __cast6_setkey(crypto_tfm_ctx(tfm), key, keylen);\n}\nEXPORT_SYMBOL_GPL(cast6_setkey);\n\n \nstatic inline void Q(u32 *block, const u8 *Kr, const u32 *Km)\n{\n\tu32 I;\n\tblock[2] ^= F1(block[3], Kr[0], Km[0]);\n\tblock[1] ^= F2(block[2], Kr[1], Km[1]);\n\tblock[0] ^= F3(block[1], Kr[2], Km[2]);\n\tblock[3] ^= F1(block[0], Kr[3], Km[3]);\n}\n\n \nstatic inline void QBAR(u32 *block, const u8 *Kr, const u32 *Km)\n{\n\tu32 I;\n\tblock[3] ^= F1(block[0], Kr[3], Km[3]);\n\tblock[0] ^= F3(block[1], Kr[2], Km[2]);\n\tblock[1] ^= F2(block[2], Kr[1], Km[1]);\n\tblock[2] ^= F1(block[3], Kr[0], Km[0]);\n}\n\nvoid __cast6_encrypt(const void *ctx, u8 *outbuf, const u8 *inbuf)\n{\n\tconst struct cast6_ctx *c = ctx;\n\tu32 block[4];\n\tconst u32 *Km;\n\tconst u8 *Kr;\n\n\tblock[0] = get_unaligned_be32(inbuf);\n\tblock[1] = get_unaligned_be32(inbuf + 4);\n\tblock[2] = get_unaligned_be32(inbuf + 8);\n\tblock[3] = get_unaligned_be32(inbuf + 12);\n\n\tKm = c->Km[0]; Kr = c->Kr[0]; Q(block, Kr, Km);\n\tKm = c->Km[1]; Kr = c->Kr[1]; Q(block, Kr, Km);\n\tKm = c->Km[2]; Kr = c->Kr[2]; Q(block, Kr, Km);\n\tKm = c->Km[3]; Kr = c->Kr[3]; Q(block, Kr, Km);\n\tKm = c->Km[4]; Kr = c->Kr[4]; Q(block, Kr, Km);\n\tKm = c->Km[5]; Kr = c->Kr[5]; Q(block, Kr, Km);\n\tKm = c->Km[6]; Kr = c->Kr[6]; QBAR(block, Kr, Km);\n\tKm = c->Km[7]; Kr = c->Kr[7]; QBAR(block, Kr, Km);\n\tKm = c->Km[8]; Kr = c->Kr[8]; QBAR(block, Kr, Km);\n\tKm = c->Km[9]; Kr = c->Kr[9]; QBAR(block, Kr, Km);\n\tKm = c->Km[10]; Kr = c->Kr[10]; QBAR(block, Kr, Km);\n\tKm = c->Km[11]; Kr = c->Kr[11]; QBAR(block, Kr, Km);\n\n\tput_unaligned_be32(block[0], outbuf);\n\tput_unaligned_be32(block[1], outbuf + 4);\n\tput_unaligned_be32(block[2], outbuf + 8);\n\tput_unaligned_be32(block[3], outbuf + 12);\n}\nEXPORT_SYMBOL_GPL(__cast6_encrypt);\n\nstatic void cast6_encrypt(struct crypto_tfm *tfm, u8 *outbuf, const u8 *inbuf)\n{\n\t__cast6_encrypt(crypto_tfm_ctx(tfm), outbuf, inbuf);\n}\n\nvoid __cast6_decrypt(const void *ctx, u8 *outbuf, const u8 *inbuf)\n{\n\tconst struct cast6_ctx *c = ctx;\n\tu32 block[4];\n\tconst u32 *Km;\n\tconst u8 *Kr;\n\n\tblock[0] = get_unaligned_be32(inbuf);\n\tblock[1] = get_unaligned_be32(inbuf + 4);\n\tblock[2] = get_unaligned_be32(inbuf + 8);\n\tblock[3] = get_unaligned_be32(inbuf + 12);\n\n\tKm = c->Km[11]; Kr = c->Kr[11]; Q(block, Kr, Km);\n\tKm = c->Km[10]; Kr = c->Kr[10]; Q(block, Kr, Km);\n\tKm = c->Km[9]; Kr = c->Kr[9]; Q(block, Kr, Km);\n\tKm = c->Km[8]; Kr = c->Kr[8]; Q(block, Kr, Km);\n\tKm = c->Km[7]; Kr = c->Kr[7]; Q(block, Kr, Km);\n\tKm = c->Km[6]; Kr = c->Kr[6]; Q(block, Kr, Km);\n\tKm = c->Km[5]; Kr = c->Kr[5]; QBAR(block, Kr, Km);\n\tKm = c->Km[4]; Kr = c->Kr[4]; QBAR(block, Kr, Km);\n\tKm = c->Km[3]; Kr = c->Kr[3]; QBAR(block, Kr, Km);\n\tKm = c->Km[2]; Kr = c->Kr[2]; QBAR(block, Kr, Km);\n\tKm = c->Km[1]; Kr = c->Kr[1]; QBAR(block, Kr, Km);\n\tKm = c->Km[0]; Kr = c->Kr[0]; QBAR(block, Kr, Km);\n\n\tput_unaligned_be32(block[0], outbuf);\n\tput_unaligned_be32(block[1], outbuf + 4);\n\tput_unaligned_be32(block[2], outbuf + 8);\n\tput_unaligned_be32(block[3], outbuf + 12);\n}\nEXPORT_SYMBOL_GPL(__cast6_decrypt);\n\nstatic void cast6_decrypt(struct crypto_tfm *tfm, u8 *outbuf, const u8 *inbuf)\n{\n\t__cast6_decrypt(crypto_tfm_ctx(tfm), outbuf, inbuf);\n}\n\nstatic struct crypto_alg alg = {\n\t.cra_name = \"cast6\",\n\t.cra_driver_name = \"cast6-generic\",\n\t.cra_priority = 100,\n\t.cra_flags = CRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize = CAST6_BLOCK_SIZE,\n\t.cra_ctxsize = sizeof(struct cast6_ctx),\n\t.cra_module = THIS_MODULE,\n\t.cra_u = {\n\t\t  .cipher = {\n\t\t\t     .cia_min_keysize = CAST6_MIN_KEY_SIZE,\n\t\t\t     .cia_max_keysize = CAST6_MAX_KEY_SIZE,\n\t\t\t     .cia_setkey = cast6_setkey,\n\t\t\t     .cia_encrypt = cast6_encrypt,\n\t\t\t     .cia_decrypt = cast6_decrypt}\n\t\t  }\n};\n\nstatic int __init cast6_mod_init(void)\n{\n\treturn crypto_register_alg(&alg);\n}\n\nstatic void __exit cast6_mod_fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n}\n\nsubsys_initcall(cast6_mod_init);\nmodule_exit(cast6_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Cast6 Cipher Algorithm\");\nMODULE_ALIAS_CRYPTO(\"cast6\");\nMODULE_ALIAS_CRYPTO(\"cast6-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}