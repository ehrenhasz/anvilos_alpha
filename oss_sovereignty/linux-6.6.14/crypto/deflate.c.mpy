{
  "module_name": "deflate.c",
  "hash_id": "56ea3def3650cd8f2f03113ff82e45decd515293b7d4eb0eece8708323959c27",
  "original_prompt": "Ingested from linux-6.6.14/crypto/deflate.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <crypto/internal/scompress.h>\n\n#define DEFLATE_DEF_LEVEL\t\tZ_DEFAULT_COMPRESSION\n#define DEFLATE_DEF_WINBITS\t\t11\n#define DEFLATE_DEF_MEMLEVEL\t\tMAX_MEM_LEVEL\n\nstruct deflate_ctx {\n\tstruct z_stream_s comp_stream;\n\tstruct z_stream_s decomp_stream;\n};\n\nstatic int deflate_comp_init(struct deflate_ctx *ctx, int format)\n{\n\tint ret = 0;\n\tstruct z_stream_s *stream = &ctx->comp_stream;\n\n\tstream->workspace = vzalloc(zlib_deflate_workspacesize(\n\t\t\t\t    MAX_WBITS, MAX_MEM_LEVEL));\n\tif (!stream->workspace) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (format)\n\t\tret = zlib_deflateInit(stream, 3);\n\telse\n\t\tret = zlib_deflateInit2(stream, DEFLATE_DEF_LEVEL, Z_DEFLATED,\n\t\t\t\t\t-DEFLATE_DEF_WINBITS,\n\t\t\t\t\tDEFLATE_DEF_MEMLEVEL,\n\t\t\t\t\tZ_DEFAULT_STRATEGY);\n\tif (ret != Z_OK) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\nout:\n\treturn ret;\nout_free:\n\tvfree(stream->workspace);\n\tgoto out;\n}\n\nstatic int deflate_decomp_init(struct deflate_ctx *ctx, int format)\n{\n\tint ret = 0;\n\tstruct z_stream_s *stream = &ctx->decomp_stream;\n\n\tstream->workspace = vzalloc(zlib_inflate_workspacesize());\n\tif (!stream->workspace) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (format)\n\t\tret = zlib_inflateInit(stream);\n\telse\n\t\tret = zlib_inflateInit2(stream, -DEFLATE_DEF_WINBITS);\n\tif (ret != Z_OK) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\nout:\n\treturn ret;\nout_free:\n\tvfree(stream->workspace);\n\tgoto out;\n}\n\nstatic void deflate_comp_exit(struct deflate_ctx *ctx)\n{\n\tzlib_deflateEnd(&ctx->comp_stream);\n\tvfree(ctx->comp_stream.workspace);\n}\n\nstatic void deflate_decomp_exit(struct deflate_ctx *ctx)\n{\n\tzlib_inflateEnd(&ctx->decomp_stream);\n\tvfree(ctx->decomp_stream.workspace);\n}\n\nstatic int __deflate_init(void *ctx, int format)\n{\n\tint ret;\n\n\tret = deflate_comp_init(ctx, format);\n\tif (ret)\n\t\tgoto out;\n\tret = deflate_decomp_init(ctx, format);\n\tif (ret)\n\t\tdeflate_comp_exit(ctx);\nout:\n\treturn ret;\n}\n\nstatic void *gen_deflate_alloc_ctx(struct crypto_scomp *tfm, int format)\n{\n\tstruct deflate_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = __deflate_init(ctx, format);\n\tif (ret) {\n\t\tkfree(ctx);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn ctx;\n}\n\nstatic void *deflate_alloc_ctx(struct crypto_scomp *tfm)\n{\n\treturn gen_deflate_alloc_ctx(tfm, 0);\n}\n\nstatic void *zlib_deflate_alloc_ctx(struct crypto_scomp *tfm)\n{\n\treturn gen_deflate_alloc_ctx(tfm, 1);\n}\n\nstatic int deflate_init(struct crypto_tfm *tfm)\n{\n\tstruct deflate_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\treturn __deflate_init(ctx, 0);\n}\n\nstatic void __deflate_exit(void *ctx)\n{\n\tdeflate_comp_exit(ctx);\n\tdeflate_decomp_exit(ctx);\n}\n\nstatic void deflate_free_ctx(struct crypto_scomp *tfm, void *ctx)\n{\n\t__deflate_exit(ctx);\n\tkfree_sensitive(ctx);\n}\n\nstatic void deflate_exit(struct crypto_tfm *tfm)\n{\n\tstruct deflate_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t__deflate_exit(ctx);\n}\n\nstatic int __deflate_compress(const u8 *src, unsigned int slen,\n\t\t\t      u8 *dst, unsigned int *dlen, void *ctx)\n{\n\tint ret = 0;\n\tstruct deflate_ctx *dctx = ctx;\n\tstruct z_stream_s *stream = &dctx->comp_stream;\n\n\tret = zlib_deflateReset(stream);\n\tif (ret != Z_OK) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tstream->next_in = (u8 *)src;\n\tstream->avail_in = slen;\n\tstream->next_out = (u8 *)dst;\n\tstream->avail_out = *dlen;\n\n\tret = zlib_deflate(stream, Z_FINISH);\n\tif (ret != Z_STREAM_END) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n\t*dlen = stream->total_out;\nout:\n\treturn ret;\n}\n\nstatic int deflate_compress(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t    unsigned int slen, u8 *dst, unsigned int *dlen)\n{\n\tstruct deflate_ctx *dctx = crypto_tfm_ctx(tfm);\n\n\treturn __deflate_compress(src, slen, dst, dlen, dctx);\n}\n\nstatic int deflate_scompress(struct crypto_scomp *tfm, const u8 *src,\n\t\t\t     unsigned int slen, u8 *dst, unsigned int *dlen,\n\t\t\t     void *ctx)\n{\n\treturn __deflate_compress(src, slen, dst, dlen, ctx);\n}\n\nstatic int __deflate_decompress(const u8 *src, unsigned int slen,\n\t\t\t\tu8 *dst, unsigned int *dlen, void *ctx)\n{\n\n\tint ret = 0;\n\tstruct deflate_ctx *dctx = ctx;\n\tstruct z_stream_s *stream = &dctx->decomp_stream;\n\n\tret = zlib_inflateReset(stream);\n\tif (ret != Z_OK) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tstream->next_in = (u8 *)src;\n\tstream->avail_in = slen;\n\tstream->next_out = (u8 *)dst;\n\tstream->avail_out = *dlen;\n\n\tret = zlib_inflate(stream, Z_SYNC_FLUSH);\n\t \n\tif (ret == Z_OK && !stream->avail_in && stream->avail_out) {\n\t\tu8 zerostuff = 0;\n\t\tstream->next_in = &zerostuff;\n\t\tstream->avail_in = 1;\n\t\tret = zlib_inflate(stream, Z_FINISH);\n\t}\n\tif (ret != Z_STREAM_END) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n\t*dlen = stream->total_out;\nout:\n\treturn ret;\n}\n\nstatic int deflate_decompress(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t      unsigned int slen, u8 *dst, unsigned int *dlen)\n{\n\tstruct deflate_ctx *dctx = crypto_tfm_ctx(tfm);\n\n\treturn __deflate_decompress(src, slen, dst, dlen, dctx);\n}\n\nstatic int deflate_sdecompress(struct crypto_scomp *tfm, const u8 *src,\n\t\t\t       unsigned int slen, u8 *dst, unsigned int *dlen,\n\t\t\t       void *ctx)\n{\n\treturn __deflate_decompress(src, slen, dst, dlen, ctx);\n}\n\nstatic struct crypto_alg alg = {\n\t.cra_name\t\t= \"deflate\",\n\t.cra_driver_name\t= \"deflate-generic\",\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_COMPRESS,\n\t.cra_ctxsize\t\t= sizeof(struct deflate_ctx),\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_init\t\t= deflate_init,\n\t.cra_exit\t\t= deflate_exit,\n\t.cra_u\t\t\t= { .compress = {\n\t.coa_compress \t\t= deflate_compress,\n\t.coa_decompress  \t= deflate_decompress } }\n};\n\nstatic struct scomp_alg scomp[] = { {\n\t.alloc_ctx\t\t= deflate_alloc_ctx,\n\t.free_ctx\t\t= deflate_free_ctx,\n\t.compress\t\t= deflate_scompress,\n\t.decompress\t\t= deflate_sdecompress,\n\t.base\t\t\t= {\n\t\t.cra_name\t= \"deflate\",\n\t\t.cra_driver_name = \"deflate-scomp\",\n\t\t.cra_module\t = THIS_MODULE,\n\t}\n}, {\n\t.alloc_ctx\t\t= zlib_deflate_alloc_ctx,\n\t.free_ctx\t\t= deflate_free_ctx,\n\t.compress\t\t= deflate_scompress,\n\t.decompress\t\t= deflate_sdecompress,\n\t.base\t\t\t= {\n\t\t.cra_name\t= \"zlib-deflate\",\n\t\t.cra_driver_name = \"zlib-deflate-scomp\",\n\t\t.cra_module\t = THIS_MODULE,\n\t}\n} };\n\nstatic int __init deflate_mod_init(void)\n{\n\tint ret;\n\n\tret = crypto_register_alg(&alg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = crypto_register_scomps(scomp, ARRAY_SIZE(scomp));\n\tif (ret) {\n\t\tcrypto_unregister_alg(&alg);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit deflate_mod_fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n\tcrypto_unregister_scomps(scomp, ARRAY_SIZE(scomp));\n}\n\nsubsys_initcall(deflate_mod_init);\nmodule_exit(deflate_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Deflate Compression Algorithm for IPCOMP\");\nMODULE_AUTHOR(\"James Morris <jmorris@intercode.com.au>\");\nMODULE_ALIAS_CRYPTO(\"deflate\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}