{
  "module_name": "xor.c",
  "hash_id": "f654cdbedf2331e4b669c81fb680d12e577198c77c5d284153c03e0dc7496c03",
  "original_prompt": "Ingested from linux-6.6.14/crypto/xor.c",
  "human_readable_source": "\n \n\n#define BH_TRACE 0\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/raid/xor.h>\n#include <linux/jiffies.h>\n#include <linux/preempt.h>\n#include <asm/xor.h>\n\n#ifndef XOR_SELECT_TEMPLATE\n#define XOR_SELECT_TEMPLATE(x) (x)\n#endif\n\n \nstatic struct xor_block_template *active_template;\n\nvoid\nxor_blocks(unsigned int src_count, unsigned int bytes, void *dest, void **srcs)\n{\n\tunsigned long *p1, *p2, *p3, *p4;\n\n\tp1 = (unsigned long *) srcs[0];\n\tif (src_count == 1) {\n\t\tactive_template->do_2(bytes, dest, p1);\n\t\treturn;\n\t}\n\n\tp2 = (unsigned long *) srcs[1];\n\tif (src_count == 2) {\n\t\tactive_template->do_3(bytes, dest, p1, p2);\n\t\treturn;\n\t}\n\n\tp3 = (unsigned long *) srcs[2];\n\tif (src_count == 3) {\n\t\tactive_template->do_4(bytes, dest, p1, p2, p3);\n\t\treturn;\n\t}\n\n\tp4 = (unsigned long *) srcs[3];\n\tactive_template->do_5(bytes, dest, p1, p2, p3, p4);\n}\nEXPORT_SYMBOL(xor_blocks);\n\n \nstatic struct xor_block_template *__initdata template_list;\n\n#ifndef MODULE\nstatic void __init do_xor_register(struct xor_block_template *tmpl)\n{\n\ttmpl->next = template_list;\n\ttemplate_list = tmpl;\n}\n\nstatic int __init register_xor_blocks(void)\n{\n\tactive_template = XOR_SELECT_TEMPLATE(NULL);\n\n\tif (!active_template) {\n#define xor_speed\tdo_xor_register\n\t\t\n\t\tXOR_TRY_TEMPLATES;\n#undef xor_speed\n\t\tactive_template = template_list;\n\t}\n\treturn 0;\n}\n#endif\n\n#define BENCH_SIZE\t4096\n#define REPS\t\t800U\n\nstatic void __init\ndo_xor_speed(struct xor_block_template *tmpl, void *b1, void *b2)\n{\n\tint speed;\n\tint i, j;\n\tktime_t min, start, diff;\n\n\ttmpl->next = template_list;\n\ttemplate_list = tmpl;\n\n\tpreempt_disable();\n\n\tmin = (ktime_t)S64_MAX;\n\tfor (i = 0; i < 3; i++) {\n\t\tstart = ktime_get();\n\t\tfor (j = 0; j < REPS; j++) {\n\t\t\tmb();  \n\t\t\ttmpl->do_2(BENCH_SIZE, b1, b2);\n\t\t\tmb();\n\t\t}\n\t\tdiff = ktime_sub(ktime_get(), start);\n\t\tif (diff < min)\n\t\t\tmin = diff;\n\t}\n\n\tpreempt_enable();\n\n\t\n\tif (!min)\n\t\tmin = 1;\n\tspeed = (1000 * REPS * BENCH_SIZE) / (unsigned int)ktime_to_ns(min);\n\ttmpl->speed = speed;\n\n\tpr_info(\"   %-16s: %5d MB/sec\\n\", tmpl->name, speed);\n}\n\nstatic int __init\ncalibrate_xor_blocks(void)\n{\n\tvoid *b1, *b2;\n\tstruct xor_block_template *f, *fastest;\n\n\tfastest = XOR_SELECT_TEMPLATE(NULL);\n\n\tif (fastest) {\n\t\tprintk(KERN_INFO \"xor: automatically using best \"\n\t\t\t\t \"checksumming function   %-10s\\n\",\n\t\t       fastest->name);\n\t\tgoto out;\n\t}\n\n\tb1 = (void *) __get_free_pages(GFP_KERNEL, 2);\n\tif (!b1) {\n\t\tprintk(KERN_WARNING \"xor: Yikes!  No memory available.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tb2 = b1 + 2*PAGE_SIZE + BENCH_SIZE;\n\n\t \n\n#define xor_speed(templ)\tdo_xor_speed((templ), b1, b2)\n\n\tprintk(KERN_INFO \"xor: measuring software checksum speed\\n\");\n\ttemplate_list = NULL;\n\tXOR_TRY_TEMPLATES;\n\tfastest = template_list;\n\tfor (f = fastest; f; f = f->next)\n\t\tif (f->speed > fastest->speed)\n\t\t\tfastest = f;\n\n\tpr_info(\"xor: using function: %s (%d MB/sec)\\n\",\n\t       fastest->name, fastest->speed);\n\n#undef xor_speed\n\n\tfree_pages((unsigned long)b1, 2);\nout:\n\tactive_template = fastest;\n\treturn 0;\n}\n\nstatic __exit void xor_exit(void) { }\n\nMODULE_LICENSE(\"GPL\");\n\n#ifndef MODULE\n \ncore_initcall(register_xor_blocks);\n#endif\n\nmodule_init(calibrate_xor_blocks);\nmodule_exit(xor_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}