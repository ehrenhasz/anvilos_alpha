{
  "module_name": "Kconfig",
  "hash_id": "cc8febdbf5c6876a78df57a9e848f0bcb2110ea0ab8e8589531168e09d6ff1b2",
  "original_prompt": "Ingested from linux-6.6.14/crypto/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Generic algorithms support\n#\nconfig XOR_BLOCKS\n\ttristate\n\n#\n# async_tx api: hardware offloaded memory transfer/transform support\n#\nsource \"crypto/async_tx/Kconfig\"\n\n#\n# Cryptographic API Configuration\n#\nmenuconfig CRYPTO\n\ttristate \"Cryptographic API\"\n\tselect CRYPTO_LIB_UTILS\n\thelp\n\t  This option provides the core Cryptographic API.\n\nif CRYPTO\n\nmenu \"Crypto core or helper\"\n\nconfig CRYPTO_FIPS\n\tbool \"FIPS 200 compliance\"\n\tdepends on (CRYPTO_ANSI_CPRNG || CRYPTO_DRBG) && !CRYPTO_MANAGER_DISABLE_TESTS\n\tdepends on (MODULE_SIG || !MODULES)\n\thelp\n\t  This option enables the fips boot option which is\n\t  required if you want the system to operate in a FIPS 200\n\t  certification.  You should say no unless you know what\n\t  this is.\n\nconfig CRYPTO_FIPS_NAME\n\tstring \"FIPS Module Name\"\n\tdefault \"Linux Kernel Cryptographic API\"\n\tdepends on CRYPTO_FIPS\n\thelp\n\t  This option sets the FIPS Module name reported by the Crypto API via\n\t  the /proc/sys/crypto/fips_name file.\n\nconfig CRYPTO_FIPS_CUSTOM_VERSION\n\tbool \"Use Custom FIPS Module Version\"\n\tdepends on CRYPTO_FIPS\n\tdefault n\n\nconfig CRYPTO_FIPS_VERSION\n\tstring \"FIPS Module Version\"\n\tdefault \"(none)\"\n\tdepends on CRYPTO_FIPS_CUSTOM_VERSION\n\thelp\n\t  This option provides the ability to override the FIPS Module Version.\n\t  By default the KERNELRELEASE value is used.\n\nconfig CRYPTO_ALGAPI\n\ttristate\n\tselect CRYPTO_ALGAPI2\n\thelp\n\t  This option provides the API for cryptographic algorithms.\n\nconfig CRYPTO_ALGAPI2\n\ttristate\n\nconfig CRYPTO_AEAD\n\ttristate\n\tselect CRYPTO_AEAD2\n\tselect CRYPTO_ALGAPI\n\nconfig CRYPTO_AEAD2\n\ttristate\n\tselect CRYPTO_ALGAPI2\n\nconfig CRYPTO_SIG\n\ttristate\n\tselect CRYPTO_SIG2\n\tselect CRYPTO_ALGAPI\n\nconfig CRYPTO_SIG2\n\ttristate\n\tselect CRYPTO_ALGAPI2\n\nconfig CRYPTO_SKCIPHER\n\ttristate\n\tselect CRYPTO_SKCIPHER2\n\tselect CRYPTO_ALGAPI\n\nconfig CRYPTO_SKCIPHER2\n\ttristate\n\tselect CRYPTO_ALGAPI2\n\nconfig CRYPTO_HASH\n\ttristate\n\tselect CRYPTO_HASH2\n\tselect CRYPTO_ALGAPI\n\nconfig CRYPTO_HASH2\n\ttristate\n\tselect CRYPTO_ALGAPI2\n\nconfig CRYPTO_RNG\n\ttristate\n\tselect CRYPTO_RNG2\n\tselect CRYPTO_ALGAPI\n\nconfig CRYPTO_RNG2\n\ttristate\n\tselect CRYPTO_ALGAPI2\n\nconfig CRYPTO_RNG_DEFAULT\n\ttristate\n\tselect CRYPTO_DRBG_MENU\n\nconfig CRYPTO_AKCIPHER2\n\ttristate\n\tselect CRYPTO_ALGAPI2\n\nconfig CRYPTO_AKCIPHER\n\ttristate\n\tselect CRYPTO_AKCIPHER2\n\tselect CRYPTO_ALGAPI\n\nconfig CRYPTO_KPP2\n\ttristate\n\tselect CRYPTO_ALGAPI2\n\nconfig CRYPTO_KPP\n\ttristate\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_KPP2\n\nconfig CRYPTO_ACOMP2\n\ttristate\n\tselect CRYPTO_ALGAPI2\n\tselect SGL_ALLOC\n\nconfig CRYPTO_ACOMP\n\ttristate\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_ACOMP2\n\nconfig CRYPTO_MANAGER\n\ttristate \"Cryptographic algorithm manager\"\n\tselect CRYPTO_MANAGER2\n\thelp\n\t  Create default cryptographic template instantiations such as\n\t  cbc(aes).\n\nconfig CRYPTO_MANAGER2\n\tdef_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y)\n\tselect CRYPTO_ACOMP2\n\tselect CRYPTO_AEAD2\n\tselect CRYPTO_AKCIPHER2\n\tselect CRYPTO_SIG2\n\tselect CRYPTO_HASH2\n\tselect CRYPTO_KPP2\n\tselect CRYPTO_RNG2\n\tselect CRYPTO_SKCIPHER2\n\nconfig CRYPTO_USER\n\ttristate \"Userspace cryptographic algorithm configuration\"\n\tdepends on NET\n\tselect CRYPTO_MANAGER\n\thelp\n\t  Userspace configuration for cryptographic instantiations such as\n\t  cbc(aes).\n\nconfig CRYPTO_MANAGER_DISABLE_TESTS\n\tbool \"Disable run-time self tests\"\n\tdefault y\n\thelp\n\t  Disable run-time self tests that normally take place at\n\t  algorithm registration.\n\nconfig CRYPTO_MANAGER_EXTRA_TESTS\n\tbool \"Enable extra run-time crypto self tests\"\n\tdepends on DEBUG_KERNEL && !CRYPTO_MANAGER_DISABLE_TESTS && CRYPTO_MANAGER\n\thelp\n\t  Enable extra run-time self tests of registered crypto algorithms,\n\t  including randomized fuzz tests.\n\n\t  This is intended for developer use only, as these tests take much\n\t  longer to run than the normal self tests.\n\nconfig CRYPTO_NULL\n\ttristate \"Null algorithms\"\n\tselect CRYPTO_NULL2\n\thelp\n\t  These are 'Null' algorithms, used by IPsec, which do nothing.\n\nconfig CRYPTO_NULL2\n\ttristate\n\tselect CRYPTO_ALGAPI2\n\tselect CRYPTO_SKCIPHER2\n\tselect CRYPTO_HASH2\n\nconfig CRYPTO_PCRYPT\n\ttristate \"Parallel crypto engine\"\n\tdepends on SMP\n\tselect PADATA\n\tselect CRYPTO_MANAGER\n\tselect CRYPTO_AEAD\n\thelp\n\t  This converts an arbitrary crypto algorithm into a parallel\n\t  algorithm that executes in kernel threads.\n\nconfig CRYPTO_CRYPTD\n\ttristate \"Software async crypto daemon\"\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_HASH\n\tselect CRYPTO_MANAGER\n\thelp\n\t  This is a generic software asynchronous crypto daemon that\n\t  converts an arbitrary synchronous software crypto algorithm\n\t  into an asynchronous algorithm that executes in a kernel thread.\n\nconfig CRYPTO_AUTHENC\n\ttristate \"Authenc support\"\n\tselect CRYPTO_AEAD\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\tselect CRYPTO_HASH\n\tselect CRYPTO_NULL\n\thelp\n\t  Authenc: Combined mode wrapper for IPsec.\n\n\t  This is required for IPSec ESP (XFRM_ESP).\n\nconfig CRYPTO_TEST\n\ttristate \"Testing module\"\n\tdepends on m || EXPERT\n\tselect CRYPTO_MANAGER\n\thelp\n\t  Quick & dirty crypto test module.\n\nconfig CRYPTO_SIMD\n\ttristate\n\tselect CRYPTO_CRYPTD\n\nconfig CRYPTO_ENGINE\n\ttristate\n\nendmenu\n\nmenu \"Public-key cryptography\"\n\nconfig CRYPTO_RSA\n\ttristate \"RSA (Rivest-Shamir-Adleman)\"\n\tselect CRYPTO_AKCIPHER\n\tselect CRYPTO_MANAGER\n\tselect MPILIB\n\tselect ASN1\n\thelp\n\t  RSA (Rivest-Shamir-Adleman) public key algorithm (RFC8017)\n\nconfig CRYPTO_DH\n\ttristate \"DH (Diffie-Hellman)\"\n\tselect CRYPTO_KPP\n\tselect MPILIB\n\thelp\n\t  DH (Diffie-Hellman) key exchange algorithm\n\nconfig CRYPTO_DH_RFC7919_GROUPS\n\tbool \"RFC 7919 FFDHE groups\"\n\tdepends on CRYPTO_DH\n\tselect CRYPTO_RNG_DEFAULT\n\thelp\n\t  FFDHE (Finite-Field-based Diffie-Hellman Ephemeral) groups\n\t  defined in RFC7919.\n\n\t  Support these finite-field groups in DH key exchanges:\n\t  - ffdhe2048, ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192\n\n\t  If unsure, say N.\n\nconfig CRYPTO_ECC\n\ttristate\n\tselect CRYPTO_RNG_DEFAULT\n\nconfig CRYPTO_ECDH\n\ttristate \"ECDH (Elliptic Curve Diffie-Hellman)\"\n\tselect CRYPTO_ECC\n\tselect CRYPTO_KPP\n\thelp\n\t  ECDH (Elliptic Curve Diffie-Hellman) key exchange algorithm\n\t  using curves P-192, P-256, and P-384 (FIPS 186)\n\nconfig CRYPTO_ECDSA\n\ttristate \"ECDSA (Elliptic Curve Digital Signature Algorithm)\"\n\tselect CRYPTO_ECC\n\tselect CRYPTO_AKCIPHER\n\tselect ASN1\n\thelp\n\t  ECDSA (Elliptic Curve Digital Signature Algorithm) (FIPS 186,\n\t  ISO/IEC 14888-3)\n\t  using curves P-192, P-256, and P-384\n\n\t  Only signature verification is implemented.\n\nconfig CRYPTO_ECRDSA\n\ttristate \"EC-RDSA (Elliptic Curve Russian Digital Signature Algorithm)\"\n\tselect CRYPTO_ECC\n\tselect CRYPTO_AKCIPHER\n\tselect CRYPTO_STREEBOG\n\tselect OID_REGISTRY\n\tselect ASN1\n\thelp\n\t  Elliptic Curve Russian Digital Signature Algorithm (GOST R 34.10-2012,\n\t  RFC 7091, ISO/IEC 14888-3)\n\n\t  One of the Russian cryptographic standard algorithms (called GOST\n\t  algorithms). Only signature verification is implemented.\n\nconfig CRYPTO_SM2\n\ttristate \"SM2 (ShangMi 2)\"\n\tselect CRYPTO_SM3\n\tselect CRYPTO_AKCIPHER\n\tselect CRYPTO_MANAGER\n\tselect MPILIB\n\tselect ASN1\n\thelp\n\t  SM2 (ShangMi 2) public key algorithm\n\n\t  Published by State Encryption Management Bureau, China,\n\t  as specified by OSCCA GM/T 0003.1-2012 -- 0003.5-2012.\n\n\t  References:\n\t  https://datatracker.ietf.org/doc/draft-shen-sm2-ecdsa/\n\t  http://www.oscca.gov.cn/sca/xxgk/2010-12/17/content_1002386.shtml\n\t  http://www.gmbz.org.cn/main/bzlb.html\n\nconfig CRYPTO_CURVE25519\n\ttristate \"Curve25519\"\n\tselect CRYPTO_KPP\n\tselect CRYPTO_LIB_CURVE25519_GENERIC\n\thelp\n\t  Curve25519 elliptic curve (RFC7748)\n\nendmenu\n\nmenu \"Block ciphers\"\n\nconfig CRYPTO_AES\n\ttristate \"AES (Advanced Encryption Standard)\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_LIB_AES\n\thelp\n\t  AES cipher algorithms (Rijndael)(FIPS-197, ISO/IEC 18033-3)\n\n\t  Rijndael appears to be consistently a very good performer in\n\t  both hardware and software across a wide range of computing\n\t  environments regardless of its use in feedback or non-feedback\n\t  modes. Its key setup time is excellent, and its key agility is\n\t  good. Rijndael's very low memory requirements make it very well\n\t  suited for restricted-space environments, in which it also\n\t  demonstrates excellent performance. Rijndael's operations are\n\t  among the easiest to defend against power and timing attacks.\n\n\t  The AES specifies three key sizes: 128, 192 and 256 bits\n\nconfig CRYPTO_AES_TI\n\ttristate \"AES (Advanced Encryption Standard) (fixed time)\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_LIB_AES\n\thelp\n\t  AES cipher algorithms (Rijndael)(FIPS-197, ISO/IEC 18033-3)\n\n\t  This is a generic implementation of AES that attempts to eliminate\n\t  data dependent latencies as much as possible without affecting\n\t  performance too much. It is intended for use by the generic CCM\n\t  and GCM drivers, and other CTR or CMAC/XCBC based modes that rely\n\t  solely on encryption (although decryption is supported as well, but\n\t  with a more dramatic performance hit)\n\n\t  Instead of using 16 lookup tables of 1 KB each, (8 for encryption and\n\t  8 for decryption), this implementation only uses just two S-boxes of\n\t  256 bytes each, and attempts to eliminate data dependent latencies by\n\t  prefetching the entire table into the cache at the start of each\n\t  block. Interrupts are also disabled to avoid races where cachelines\n\t  are evicted when the CPU is interrupted to do something else.\n\nconfig CRYPTO_ANUBIS\n\ttristate \"Anubis\"\n\tdepends on CRYPTO_USER_API_ENABLE_OBSOLETE\n\tselect CRYPTO_ALGAPI\n\thelp\n\t  Anubis cipher algorithm\n\n\t  Anubis is a variable key length cipher which can use keys from\n\t  128 bits to 320 bits in length.  It was evaluated as a entrant\n\t  in the NESSIE competition.\n\n\t  See https://web.archive.org/web/20160606112246/http://www.larc.usp.br/~pbarreto/AnubisPage.html\n\t  for further information.\n\nconfig CRYPTO_ARIA\n\ttristate \"ARIA\"\n\tselect CRYPTO_ALGAPI\n\thelp\n\t  ARIA cipher algorithm (RFC5794)\n\n\t  ARIA is a standard encryption algorithm of the Republic of Korea.\n\t  The ARIA specifies three key sizes and rounds.\n\t  128-bit: 12 rounds.\n\t  192-bit: 14 rounds.\n\t  256-bit: 16 rounds.\n\n\t  See:\n\t  https://seed.kisa.or.kr/kisa/algorithm/EgovAriaInfo.do\n\nconfig CRYPTO_BLOWFISH\n\ttristate \"Blowfish\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_BLOWFISH_COMMON\n\thelp\n\t  Blowfish cipher algorithm, by Bruce Schneier\n\n\t  This is a variable key length cipher which can use keys from 32\n\t  bits to 448 bits in length.  It's fast, simple and specifically\n\t  designed for use on \"large microprocessors\".\n\n\t  See https://www.schneier.com/blowfish.html for further information.\n\nconfig CRYPTO_BLOWFISH_COMMON\n\ttristate\n\thelp\n\t  Common parts of the Blowfish cipher algorithm shared by the\n\t  generic c and the assembler implementations.\n\nconfig CRYPTO_CAMELLIA\n\ttristate \"Camellia\"\n\tselect CRYPTO_ALGAPI\n\thelp\n\t  Camellia cipher algorithms (ISO/IEC 18033-3)\n\n\t  Camellia is a symmetric key block cipher developed jointly\n\t  at NTT and Mitsubishi Electric Corporation.\n\n\t  The Camellia specifies three key sizes: 128, 192 and 256 bits.\n\n\t  See https://info.isl.ntt.co.jp/crypt/eng/camellia/ for further information.\n\nconfig CRYPTO_CAST_COMMON\n\ttristate\n\thelp\n\t  Common parts of the CAST cipher algorithms shared by the\n\t  generic c and the assembler implementations.\n\nconfig CRYPTO_CAST5\n\ttristate \"CAST5 (CAST-128)\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_CAST_COMMON\n\thelp\n\t  CAST5 (CAST-128) cipher algorithm (RFC2144, ISO/IEC 18033-3)\n\nconfig CRYPTO_CAST6\n\ttristate \"CAST6 (CAST-256)\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_CAST_COMMON\n\thelp\n\t  CAST6 (CAST-256) encryption algorithm (RFC2612)\n\nconfig CRYPTO_DES\n\ttristate \"DES and Triple DES EDE\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_LIB_DES\n\thelp\n\t  DES (Data Encryption Standard)(FIPS 46-2, ISO/IEC 18033-3) and\n\t  Triple DES EDE (Encrypt/Decrypt/Encrypt) (FIPS 46-3, ISO/IEC 18033-3)\n\t  cipher algorithms\n\nconfig CRYPTO_FCRYPT\n\ttristate \"FCrypt\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_SKCIPHER\n\thelp\n\t  FCrypt algorithm used by RxRPC\n\n\t  See https://ota.polyonymo.us/fcrypt-paper.txt\n\nconfig CRYPTO_KHAZAD\n\ttristate \"Khazad\"\n\tdepends on CRYPTO_USER_API_ENABLE_OBSOLETE\n\tselect CRYPTO_ALGAPI\n\thelp\n\t  Khazad cipher algorithm\n\n\t  Khazad was a finalist in the initial NESSIE competition.  It is\n\t  an algorithm optimized for 64-bit processors with good performance\n\t  on 32-bit processors.  Khazad uses an 128 bit key size.\n\n\t  See https://web.archive.org/web/20171011071731/http://www.larc.usp.br/~pbarreto/KhazadPage.html\n\t  for further information.\n\nconfig CRYPTO_SEED\n\ttristate \"SEED\"\n\tdepends on CRYPTO_USER_API_ENABLE_OBSOLETE\n\tselect CRYPTO_ALGAPI\n\thelp\n\t  SEED cipher algorithm (RFC4269, ISO/IEC 18033-3)\n\n\t  SEED is a 128-bit symmetric key block cipher that has been\n\t  developed by KISA (Korea Information Security Agency) as a\n\t  national standard encryption algorithm of the Republic of Korea.\n\t  It is a 16 round block cipher with the key size of 128 bit.\n\n\t  See https://seed.kisa.or.kr/kisa/algorithm/EgovSeedInfo.do\n\t  for further information.\n\nconfig CRYPTO_SERPENT\n\ttristate \"Serpent\"\n\tselect CRYPTO_ALGAPI\n\thelp\n\t  Serpent cipher algorithm, by Anderson, Biham & Knudsen\n\n\t  Keys are allowed to be from 0 to 256 bits in length, in steps\n\t  of 8 bits.\n\n\t  See https://www.cl.cam.ac.uk/~rja14/serpent.html for further information.\n\nconfig CRYPTO_SM4\n\ttristate\n\nconfig CRYPTO_SM4_GENERIC\n\ttristate \"SM4 (ShangMi 4)\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_SM4\n\thelp\n\t  SM4 cipher algorithms (OSCCA GB/T 32907-2016,\n\t  ISO/IEC 18033-3:2010/Amd 1:2021)\n\n\t  SM4 (GBT.32907-2016) is a cryptographic standard issued by the\n\t  Organization of State Commercial Administration of China (OSCCA)\n\t  as an authorized cryptographic algorithms for the use within China.\n\n\t  SMS4 was originally created for use in protecting wireless\n\t  networks, and is mandated in the Chinese National Standard for\n\t  Wireless LAN WAPI (Wired Authentication and Privacy Infrastructure)\n\t  (GB.15629.11-2003).\n\n\t  The latest SM4 standard (GBT.32907-2016) was proposed by OSCCA and\n\t  standardized through TC 260 of the Standardization Administration\n\t  of the People's Republic of China (SAC).\n\n\t  The input, output, and key of SMS4 are each 128 bits.\n\n\t  See https://eprint.iacr.org/2008/329.pdf for further information.\n\n\t  If unsure, say N.\n\nconfig CRYPTO_TEA\n\ttristate \"TEA, XTEA and XETA\"\n\tdepends on CRYPTO_USER_API_ENABLE_OBSOLETE\n\tselect CRYPTO_ALGAPI\n\thelp\n\t  TEA (Tiny Encryption Algorithm) cipher algorithms\n\n\t  Tiny Encryption Algorithm is a simple cipher that uses\n\t  many rounds for security.  It is very fast and uses\n\t  little memory.\n\n\t  Xtendend Tiny Encryption Algorithm is a modification to\n\t  the TEA algorithm to address a potential key weakness\n\t  in the TEA algorithm.\n\n\t  Xtendend Encryption Tiny Algorithm is a mis-implementation\n\t  of the XTEA algorithm for compatibility purposes.\n\nconfig CRYPTO_TWOFISH\n\ttristate \"Twofish\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_TWOFISH_COMMON\n\thelp\n\t  Twofish cipher algorithm\n\n\t  Twofish was submitted as an AES (Advanced Encryption Standard)\n\t  candidate cipher by researchers at CounterPane Systems.  It is a\n\t  16 round block cipher supporting key sizes of 128, 192, and 256\n\t  bits.\n\n\t  See https://www.schneier.com/twofish.html for further information.\n\nconfig CRYPTO_TWOFISH_COMMON\n\ttristate\n\thelp\n\t  Common parts of the Twofish cipher algorithm shared by the\n\t  generic c and the assembler implementations.\n\nendmenu\n\nmenu \"Length-preserving ciphers and modes\"\n\nconfig CRYPTO_ADIANTUM\n\ttristate \"Adiantum\"\n\tselect CRYPTO_CHACHA20\n\tselect CRYPTO_LIB_POLY1305_GENERIC\n\tselect CRYPTO_NHPOLY1305\n\tselect CRYPTO_MANAGER\n\thelp\n\t  Adiantum tweakable, length-preserving encryption mode\n\n\t  Designed for fast and secure disk encryption, especially on\n\t  CPUs without dedicated crypto instructions.  It encrypts\n\t  each sector using the XChaCha12 stream cipher, two passes of\n\t  an \u03b5-almost-\u2206-universal hash function, and an invocation of\n\t  the AES-256 block cipher on a single 16-byte block.  On CPUs\n\t  without AES instructions, Adiantum is much faster than\n\t  AES-XTS.\n\n\t  Adiantum's security is provably reducible to that of its\n\t  underlying stream and block ciphers, subject to a security\n\t  bound.  Unlike XTS, Adiantum is a true wide-block encryption\n\t  mode, so it actually provides an even stronger notion of\n\t  security than XTS, subject to the security bound.\n\n\t  If unsure, say N.\n\nconfig CRYPTO_ARC4\n\ttristate \"ARC4 (Alleged Rivest Cipher 4)\"\n\tdepends on CRYPTO_USER_API_ENABLE_OBSOLETE\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_LIB_ARC4\n\thelp\n\t  ARC4 cipher algorithm\n\n\t  ARC4 is a stream cipher using keys ranging from 8 bits to 2048\n\t  bits in length.  This algorithm is required for driver-based\n\t  WEP, but it should not be for other purposes because of the\n\t  weakness of the algorithm.\n\nconfig CRYPTO_CHACHA20\n\ttristate \"ChaCha\"\n\tselect CRYPTO_LIB_CHACHA_GENERIC\n\tselect CRYPTO_SKCIPHER\n\thelp\n\t  The ChaCha20, XChaCha20, and XChaCha12 stream cipher algorithms\n\n\t  ChaCha20 is a 256-bit high-speed stream cipher designed by Daniel J.\n\t  Bernstein and further specified in RFC7539 for use in IETF protocols.\n\t  This is the portable C implementation of ChaCha20.  See\n\t  https://cr.yp.to/chacha/chacha-20080128.pdf for further information.\n\n\t  XChaCha20 is the application of the XSalsa20 construction to ChaCha20\n\t  rather than to Salsa20.  XChaCha20 extends ChaCha20's nonce length\n\t  from 64 bits (or 96 bits using the RFC7539 convention) to 192 bits,\n\t  while provably retaining ChaCha20's security.  See\n\t  https://cr.yp.to/snuffle/xsalsa-20081128.pdf for further information.\n\n\t  XChaCha12 is XChaCha20 reduced to 12 rounds, with correspondingly\n\t  reduced security margin but increased performance.  It can be needed\n\t  in some performance-sensitive scenarios.\n\nconfig CRYPTO_CBC\n\ttristate \"CBC (Cipher Block Chaining)\"\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\thelp\n\t  CBC (Cipher Block Chaining) mode (NIST SP800-38A)\n\n\t  This block cipher mode is required for IPSec ESP (XFRM_ESP).\n\nconfig CRYPTO_CFB\n\ttristate \"CFB (Cipher Feedback)\"\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\thelp\n\t  CFB (Cipher Feedback) mode (NIST SP800-38A)\n\n\t  This block cipher mode is required for TPM2 Cryptography.\n\nconfig CRYPTO_CTR\n\ttristate \"CTR (Counter)\"\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\thelp\n\t  CTR (Counter) mode (NIST SP800-38A)\n\nconfig CRYPTO_CTS\n\ttristate \"CTS (Cipher Text Stealing)\"\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\thelp\n\t  CBC-CS3 variant of CTS (Cipher Text Stealing) (NIST\n\t  Addendum to SP800-38A (October 2010))\n\n\t  This mode is required for Kerberos gss mechanism support\n\t  for AES encryption.\n\nconfig CRYPTO_ECB\n\ttristate \"ECB (Electronic Codebook)\"\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\thelp\n\t  ECB (Electronic Codebook) mode (NIST SP800-38A)\n\nconfig CRYPTO_HCTR2\n\ttristate \"HCTR2\"\n\tselect CRYPTO_XCTR\n\tselect CRYPTO_POLYVAL\n\tselect CRYPTO_MANAGER\n\thelp\n\t  HCTR2 length-preserving encryption mode\n\n\t  A mode for storage encryption that is efficient on processors with\n\t  instructions to accelerate AES and carryless multiplication, e.g.\n\t  x86 processors with AES-NI and CLMUL, and ARM processors with the\n\t  ARMv8 crypto extensions.\n\n\t  See https://eprint.iacr.org/2021/1441\n\nconfig CRYPTO_KEYWRAP\n\ttristate \"KW (AES Key Wrap)\"\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\thelp\n\t  KW (AES Key Wrap) authenticated encryption mode (NIST SP800-38F\n\t  and RFC3394) without padding.\n\nconfig CRYPTO_LRW\n\ttristate \"LRW (Liskov Rivest Wagner)\"\n\tselect CRYPTO_LIB_GF128MUL\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\tselect CRYPTO_ECB\n\thelp\n\t  LRW (Liskov Rivest Wagner) mode\n\n\t  A tweakable, non malleable, non movable\n\t  narrow block cipher mode for dm-crypt.  Use it with cipher\n\t  specification string aes-lrw-benbi, the key must be 256, 320 or 384.\n\t  The first 128, 192 or 256 bits in the key are used for AES and the\n\t  rest is used to tie each cipher block to its logical position.\n\n\t  See https://people.csail.mit.edu/rivest/pubs/LRW02.pdf\n\nconfig CRYPTO_OFB\n\ttristate \"OFB (Output Feedback)\"\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\thelp\n\t  OFB (Output Feedback) mode (NIST SP800-38A)\n\n\t  This mode makes a block cipher into a synchronous\n\t  stream cipher. It generates keystream blocks, which are then XORed\n\t  with the plaintext blocks to get the ciphertext. Flipping a bit in the\n\t  ciphertext produces a flipped bit in the plaintext at the same\n\t  location. This property allows many error correcting codes to function\n\t  normally even when applied before encryption.\n\nconfig CRYPTO_PCBC\n\ttristate \"PCBC (Propagating Cipher Block Chaining)\"\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\thelp\n\t  PCBC (Propagating Cipher Block Chaining) mode\n\n\t  This block cipher mode is required for RxRPC.\n\nconfig CRYPTO_XCTR\n\ttristate\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\thelp\n\t  XCTR (XOR Counter) mode for HCTR2\n\n\t  This blockcipher mode is a variant of CTR mode using XORs and little-endian\n\t  addition rather than big-endian arithmetic.\n\n\t  XCTR mode is used to implement HCTR2.\n\nconfig CRYPTO_XTS\n\ttristate \"XTS (XOR Encrypt XOR with ciphertext stealing)\"\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_MANAGER\n\tselect CRYPTO_ECB\n\thelp\n\t  XTS (XOR Encrypt XOR with ciphertext stealing) mode (NIST SP800-38E\n\t  and IEEE 1619)\n\n\t  Use with aes-xts-plain, key size 256, 384 or 512 bits. This\n\t  implementation currently can't handle a sectorsize which is not a\n\t  multiple of 16 bytes.\n\nconfig CRYPTO_NHPOLY1305\n\ttristate\n\tselect CRYPTO_HASH\n\tselect CRYPTO_LIB_POLY1305_GENERIC\n\nendmenu\n\nmenu \"AEAD (authenticated encryption with associated data) ciphers\"\n\nconfig CRYPTO_AEGIS128\n\ttristate \"AEGIS-128\"\n\tselect CRYPTO_AEAD\n\tselect CRYPTO_AES  # for AES S-box tables\n\thelp\n\t  AEGIS-128 AEAD algorithm\n\nconfig CRYPTO_AEGIS128_SIMD\n\tbool \"AEGIS-128 (arm NEON, arm64 NEON)\"\n\tdepends on CRYPTO_AEGIS128 && ((ARM || ARM64) && KERNEL_MODE_NEON)\n\tdefault y\n\thelp\n\t  AEGIS-128 AEAD algorithm\n\n\t  Architecture: arm or arm64 using:\n\t  - NEON (Advanced SIMD) extension\n\nconfig CRYPTO_CHACHA20POLY1305\n\ttristate \"ChaCha20-Poly1305\"\n\tselect CRYPTO_CHACHA20\n\tselect CRYPTO_POLY1305\n\tselect CRYPTO_AEAD\n\tselect CRYPTO_MANAGER\n\thelp\n\t  ChaCha20 stream cipher and Poly1305 authenticator combined\n\t  mode (RFC8439)\n\nconfig CRYPTO_CCM\n\ttristate \"CCM (Counter with Cipher Block Chaining-MAC)\"\n\tselect CRYPTO_CTR\n\tselect CRYPTO_HASH\n\tselect CRYPTO_AEAD\n\tselect CRYPTO_MANAGER\n\thelp\n\t  CCM (Counter with Cipher Block Chaining-Message Authentication Code)\n\t  authenticated encryption mode (NIST SP800-38C)\n\nconfig CRYPTO_GCM\n\ttristate \"GCM (Galois/Counter Mode) and GMAC (GCM MAC)\"\n\tselect CRYPTO_CTR\n\tselect CRYPTO_AEAD\n\tselect CRYPTO_GHASH\n\tselect CRYPTO_NULL\n\tselect CRYPTO_MANAGER\n\thelp\n\t  GCM (Galois/Counter Mode) authenticated encryption mode and GMAC\n\t  (GCM Message Authentication Code) (NIST SP800-38D)\n\n\t  This is required for IPSec ESP (XFRM_ESP).\n\nconfig CRYPTO_GENIV\n\ttristate\n\tselect CRYPTO_AEAD\n\tselect CRYPTO_NULL\n\tselect CRYPTO_MANAGER\n\tselect CRYPTO_RNG_DEFAULT\n\nconfig CRYPTO_SEQIV\n\ttristate \"Sequence Number IV Generator\"\n\tselect CRYPTO_GENIV\n\thelp\n\t  Sequence Number IV generator\n\n\t  This IV generator generates an IV based on a sequence number by\n\t  xoring it with a salt.  This algorithm is mainly useful for CTR.\n\n\t  This is required for IPsec ESP (XFRM_ESP).\n\nconfig CRYPTO_ECHAINIV\n\ttristate \"Encrypted Chain IV Generator\"\n\tselect CRYPTO_GENIV\n\thelp\n\t  Encrypted Chain IV generator\n\n\t  This IV generator generates an IV based on the encryption of\n\t  a sequence number xored with a salt.  This is the default\n\t  algorithm for CBC.\n\nconfig CRYPTO_ESSIV\n\ttristate \"Encrypted Salt-Sector IV Generator\"\n\tselect CRYPTO_AUTHENC\n\thelp\n\t  Encrypted Salt-Sector IV generator\n\n\t  This IV generator is used in some cases by fscrypt and/or\n\t  dm-crypt. It uses the hash of the block encryption key as the\n\t  symmetric key for a block encryption pass applied to the input\n\t  IV, making low entropy IV sources more suitable for block\n\t  encryption.\n\n\t  This driver implements a crypto API template that can be\n\t  instantiated either as an skcipher or as an AEAD (depending on the\n\t  type of the first template argument), and which defers encryption\n\t  and decryption requests to the encapsulated cipher after applying\n\t  ESSIV to the input IV. Note that in the AEAD case, it is assumed\n\t  that the keys are presented in the same format used by the authenc\n\t  template, and that the IV appears at the end of the authenticated\n\t  associated data (AAD) region (which is how dm-crypt uses it.)\n\n\t  Note that the use of ESSIV is not recommended for new deployments,\n\t  and so this only needs to be enabled when interoperability with\n\t  existing encrypted volumes of filesystems is required, or when\n\t  building for a particular system that requires it (e.g., when\n\t  the SoC in question has accelerated CBC but not XTS, making CBC\n\t  combined with ESSIV the only feasible mode for h/w accelerated\n\t  block encryption)\n\nendmenu\n\nmenu \"Hashes, digests, and MACs\"\n\nconfig CRYPTO_BLAKE2B\n\ttristate \"BLAKE2b\"\n\tselect CRYPTO_HASH\n\thelp\n\t  BLAKE2b cryptographic hash function (RFC 7693)\n\n\t  BLAKE2b is optimized for 64-bit platforms and can produce digests\n\t  of any size between 1 and 64 bytes. The keyed hash is also implemented.\n\n\t  This module provides the following algorithms:\n\t  - blake2b-160\n\t  - blake2b-256\n\t  - blake2b-384\n\t  - blake2b-512\n\n\t  Used by the btrfs filesystem.\n\n\t  See https://blake2.net for further information.\n\nconfig CRYPTO_CMAC\n\ttristate \"CMAC (Cipher-based MAC)\"\n\tselect CRYPTO_HASH\n\tselect CRYPTO_MANAGER\n\thelp\n\t  CMAC (Cipher-based Message Authentication Code) authentication\n\t  mode (NIST SP800-38B and IETF RFC4493)\n\nconfig CRYPTO_GHASH\n\ttristate \"GHASH\"\n\tselect CRYPTO_HASH\n\tselect CRYPTO_LIB_GF128MUL\n\thelp\n\t  GCM GHASH function (NIST SP800-38D)\n\nconfig CRYPTO_HMAC\n\ttristate \"HMAC (Keyed-Hash MAC)\"\n\tselect CRYPTO_HASH\n\tselect CRYPTO_MANAGER\n\thelp\n\t  HMAC (Keyed-Hash Message Authentication Code) (FIPS 198 and\n\t  RFC2104)\n\n\t  This is required for IPsec AH (XFRM_AH) and IPsec ESP (XFRM_ESP).\n\nconfig CRYPTO_MD4\n\ttristate \"MD4\"\n\tselect CRYPTO_HASH\n\thelp\n\t  MD4 message digest algorithm (RFC1320)\n\nconfig CRYPTO_MD5\n\ttristate \"MD5\"\n\tselect CRYPTO_HASH\n\thelp\n\t  MD5 message digest algorithm (RFC1321)\n\nconfig CRYPTO_MICHAEL_MIC\n\ttristate \"Michael MIC\"\n\tselect CRYPTO_HASH\n\thelp\n\t  Michael MIC (Message Integrity Code) (IEEE 802.11i)\n\n\t  Defined by the IEEE 802.11i TKIP (Temporal Key Integrity Protocol),\n\t  known as WPA (Wif-Fi Protected Access).\n\n\t  This algorithm is required for TKIP, but it should not be used for\n\t  other purposes because of the weakness of the algorithm.\n\nconfig CRYPTO_POLYVAL\n\ttristate\n\tselect CRYPTO_HASH\n\tselect CRYPTO_LIB_GF128MUL\n\thelp\n\t  POLYVAL hash function for HCTR2\n\n\t  This is used in HCTR2.  It is not a general-purpose\n\t  cryptographic hash function.\n\nconfig CRYPTO_POLY1305\n\ttristate \"Poly1305\"\n\tselect CRYPTO_HASH\n\tselect CRYPTO_LIB_POLY1305_GENERIC\n\thelp\n\t  Poly1305 authenticator algorithm (RFC7539)\n\n\t  Poly1305 is an authenticator algorithm designed by Daniel J. Bernstein.\n\t  It is used for the ChaCha20-Poly1305 AEAD, specified in RFC7539 for use\n\t  in IETF protocols. This is the portable C implementation of Poly1305.\n\nconfig CRYPTO_RMD160\n\ttristate \"RIPEMD-160\"\n\tselect CRYPTO_HASH\n\thelp\n\t  RIPEMD-160 hash function (ISO/IEC 10118-3)\n\n\t  RIPEMD-160 is a 160-bit cryptographic hash function. It is intended\n\t  to be used as a secure replacement for the 128-bit hash functions\n\t  MD4, MD5 and its predecessor RIPEMD\n\t  (not to be confused with RIPEMD-128).\n\n\t  Its speed is comparable to SHA-1 and there are no known attacks\n\t  against RIPEMD-160.\n\n\t  Developed by Hans Dobbertin, Antoon Bosselaers and Bart Preneel.\n\t  See https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n\t  for further information.\n\nconfig CRYPTO_SHA1\n\ttristate \"SHA-1\"\n\tselect CRYPTO_HASH\n\tselect CRYPTO_LIB_SHA1\n\thelp\n\t  SHA-1 secure hash algorithm (FIPS 180, ISO/IEC 10118-3)\n\nconfig CRYPTO_SHA256\n\ttristate \"SHA-224 and SHA-256\"\n\tselect CRYPTO_HASH\n\tselect CRYPTO_LIB_SHA256\n\thelp\n\t  SHA-224 and SHA-256 secure hash algorithms (FIPS 180, ISO/IEC 10118-3)\n\n\t  This is required for IPsec AH (XFRM_AH) and IPsec ESP (XFRM_ESP).\n\t  Used by the btrfs filesystem, Ceph, NFS, and SMB.\n\nconfig CRYPTO_SHA512\n\ttristate \"SHA-384 and SHA-512\"\n\tselect CRYPTO_HASH\n\thelp\n\t  SHA-384 and SHA-512 secure hash algorithms (FIPS 180, ISO/IEC 10118-3)\n\nconfig CRYPTO_SHA3\n\ttristate \"SHA-3\"\n\tselect CRYPTO_HASH\n\thelp\n\t  SHA-3 secure hash algorithms (FIPS 202, ISO/IEC 10118-3)\n\nconfig CRYPTO_SM3\n\ttristate\n\nconfig CRYPTO_SM3_GENERIC\n\ttristate \"SM3 (ShangMi 3)\"\n\tselect CRYPTO_HASH\n\tselect CRYPTO_SM3\n\thelp\n\t  SM3 (ShangMi 3) secure hash function (OSCCA GM/T 0004-2012, ISO/IEC 10118-3)\n\n\t  This is part of the Chinese Commercial Cryptography suite.\n\n\t  References:\n\t  http://www.oscca.gov.cn/UpFile/20101222141857786.pdf\n\t  https://datatracker.ietf.org/doc/html/draft-shen-sm3-hash\n\nconfig CRYPTO_STREEBOG\n\ttristate \"Streebog\"\n\tselect CRYPTO_HASH\n\thelp\n\t  Streebog Hash Function (GOST R 34.11-2012, RFC 6986, ISO/IEC 10118-3)\n\n\t  This is one of the Russian cryptographic standard algorithms (called\n\t  GOST algorithms). This setting enables two hash algorithms with\n\t  256 and 512 bits output.\n\n\t  References:\n\t  https://tc26.ru/upload/iblock/fed/feddbb4d26b685903faa2ba11aea43f6.pdf\n\t  https://tools.ietf.org/html/rfc6986\n\nconfig CRYPTO_VMAC\n\ttristate \"VMAC\"\n\tselect CRYPTO_HASH\n\tselect CRYPTO_MANAGER\n\thelp\n\t  VMAC is a message authentication algorithm designed for\n\t  very high speed on 64-bit architectures.\n\n\t  See https://fastcrypto.org/vmac for further information.\n\nconfig CRYPTO_WP512\n\ttristate \"Whirlpool\"\n\tselect CRYPTO_HASH\n\thelp\n\t  Whirlpool hash function (ISO/IEC 10118-3)\n\n\t  512, 384 and 256-bit hashes.\n\n\t  Whirlpool-512 is part of the NESSIE cryptographic primitives.\n\n\t  See https://web.archive.org/web/20171129084214/http://www.larc.usp.br/~pbarreto/WhirlpoolPage.html\n\t  for further information.\n\nconfig CRYPTO_XCBC\n\ttristate \"XCBC-MAC (Extended Cipher Block Chaining MAC)\"\n\tselect CRYPTO_HASH\n\tselect CRYPTO_MANAGER\n\thelp\n\t  XCBC-MAC (Extended Cipher Block Chaining Message Authentication\n\t  Code) (RFC3566)\n\nconfig CRYPTO_XXHASH\n\ttristate \"xxHash\"\n\tselect CRYPTO_HASH\n\tselect XXHASH\n\thelp\n\t  xxHash non-cryptographic hash algorithm\n\n\t  Extremely fast, working at speeds close to RAM limits.\n\n\t  Used by the btrfs filesystem.\n\nendmenu\n\nmenu \"CRCs (cyclic redundancy checks)\"\n\nconfig CRYPTO_CRC32C\n\ttristate \"CRC32c\"\n\tselect CRYPTO_HASH\n\tselect CRC32\n\thelp\n\t  CRC32c CRC algorithm with the iSCSI polynomial (RFC 3385 and RFC 3720)\n\n\t  A 32-bit CRC (cyclic redundancy check) with a polynomial defined\n\t  by G. Castagnoli, S. Braeuer and M. Herrman in \"Optimization of Cyclic\n\t  Redundancy-Check Codes with 24 and 32 Parity Bits\", IEEE Transactions\n\t  on Communications, Vol. 41, No. 6, June 1993, selected for use with\n\t  iSCSI.\n\n\t  Used by btrfs, ext4, jbd2, NVMeoF/TCP, and iSCSI.\n\nconfig CRYPTO_CRC32\n\ttristate \"CRC32\"\n\tselect CRYPTO_HASH\n\tselect CRC32\n\thelp\n\t  CRC32 CRC algorithm (IEEE 802.3)\n\n\t  Used by RoCEv2 and f2fs.\n\nconfig CRYPTO_CRCT10DIF\n\ttristate \"CRCT10DIF\"\n\tselect CRYPTO_HASH\n\thelp\n\t  CRC16 CRC algorithm used for the T10 (SCSI) Data Integrity Field (DIF)\n\n\t  CRC algorithm used by the SCSI Block Commands standard.\n\nconfig CRYPTO_CRC64_ROCKSOFT\n\ttristate \"CRC64 based on Rocksoft Model algorithm\"\n\tdepends on CRC64\n\tselect CRYPTO_HASH\n\thelp\n\t  CRC64 CRC algorithm based on the Rocksoft Model CRC Algorithm\n\n\t  Used by the NVMe implementation of T10 DIF (BLK_DEV_INTEGRITY)\n\n\t  See https://zlib.net/crc_v3.txt\n\nendmenu\n\nmenu \"Compression\"\n\nconfig CRYPTO_DEFLATE\n\ttristate \"Deflate\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_ACOMP2\n\tselect ZLIB_INFLATE\n\tselect ZLIB_DEFLATE\n\thelp\n\t  Deflate compression algorithm (RFC1951)\n\n\t  Used by IPSec with the IPCOMP protocol (RFC3173, RFC2394)\n\nconfig CRYPTO_LZO\n\ttristate \"LZO\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_ACOMP2\n\tselect LZO_COMPRESS\n\tselect LZO_DECOMPRESS\n\thelp\n\t  LZO compression algorithm\n\n\t  See https://www.oberhumer.com/opensource/lzo/ for further information.\n\nconfig CRYPTO_842\n\ttristate \"842\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_ACOMP2\n\tselect 842_COMPRESS\n\tselect 842_DECOMPRESS\n\thelp\n\t  842 compression algorithm by IBM\n\n\t  See https://github.com/plauth/lib842 for further information.\n\nconfig CRYPTO_LZ4\n\ttristate \"LZ4\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_ACOMP2\n\tselect LZ4_COMPRESS\n\tselect LZ4_DECOMPRESS\n\thelp\n\t  LZ4 compression algorithm\n\n\t  See https://github.com/lz4/lz4 for further information.\n\nconfig CRYPTO_LZ4HC\n\ttristate \"LZ4HC\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_ACOMP2\n\tselect LZ4HC_COMPRESS\n\tselect LZ4_DECOMPRESS\n\thelp\n\t  LZ4 high compression mode algorithm\n\n\t  See https://github.com/lz4/lz4 for further information.\n\nconfig CRYPTO_ZSTD\n\ttristate \"Zstd\"\n\tselect CRYPTO_ALGAPI\n\tselect CRYPTO_ACOMP2\n\tselect ZSTD_COMPRESS\n\tselect ZSTD_DECOMPRESS\n\thelp\n\t  zstd compression algorithm\n\n\t  See https://github.com/facebook/zstd for further information.\n\nendmenu\n\nmenu \"Random number generation\"\n\nconfig CRYPTO_ANSI_CPRNG\n\ttristate \"ANSI PRNG (Pseudo Random Number Generator)\"\n\tselect CRYPTO_AES\n\tselect CRYPTO_RNG\n\thelp\n\t  Pseudo RNG (random number generator) (ANSI X9.31 Appendix A.2.4)\n\n\t  This uses the AES cipher algorithm.\n\n\t  Note that this option must be enabled if CRYPTO_FIPS is selected\n\nmenuconfig CRYPTO_DRBG_MENU\n\ttristate \"NIST SP800-90A DRBG (Deterministic Random Bit Generator)\"\n\thelp\n\t  DRBG (Deterministic Random Bit Generator) (NIST SP800-90A)\n\n\t  In the following submenu, one or more of the DRBG types must be selected.\n\nif CRYPTO_DRBG_MENU\n\nconfig CRYPTO_DRBG_HMAC\n\tbool\n\tdefault y\n\tselect CRYPTO_HMAC\n\tselect CRYPTO_SHA512\n\nconfig CRYPTO_DRBG_HASH\n\tbool \"Hash_DRBG\"\n\tselect CRYPTO_SHA256\n\thelp\n\t  Hash_DRBG variant as defined in NIST SP800-90A.\n\n\t  This uses the SHA-1, SHA-256, SHA-384, or SHA-512 hash algorithms.\n\nconfig CRYPTO_DRBG_CTR\n\tbool \"CTR_DRBG\"\n\tselect CRYPTO_AES\n\tselect CRYPTO_CTR\n\thelp\n\t  CTR_DRBG variant as defined in NIST SP800-90A.\n\n\t  This uses the AES cipher algorithm with the counter block mode.\n\nconfig CRYPTO_DRBG\n\ttristate\n\tdefault CRYPTO_DRBG_MENU\n\tselect CRYPTO_RNG\n\tselect CRYPTO_JITTERENTROPY\n\nendif\t# if CRYPTO_DRBG_MENU\n\nconfig CRYPTO_JITTERENTROPY\n\ttristate \"CPU Jitter Non-Deterministic RNG (Random Number Generator)\"\n\tselect CRYPTO_RNG\n\tselect CRYPTO_SHA3\n\thelp\n\t  CPU Jitter RNG (Random Number Generator) from the Jitterentropy library\n\n\t  A non-physical non-deterministic (\"true\") RNG (e.g., an entropy source\n\t  compliant with NIST SP800-90B) intended to provide a seed to a\n\t  deterministic RNG (e.g.  per NIST SP800-90C).\n\t  This RNG does not perform any cryptographic whitening of the generated\n\n\t  See https://www.chronox.de/jent.html\n\nconfig CRYPTO_JITTERENTROPY_TESTINTERFACE\n\tbool \"CPU Jitter RNG Test Interface\"\n\tdepends on CRYPTO_JITTERENTROPY\n\thelp\n\t  The test interface allows a privileged process to capture\n\t  the raw unconditioned high resolution time stamp noise that\n\t  is collected by the Jitter RNG for statistical analysis. As\n\t  this data is used at the same time to generate random bits,\n\t  the Jitter RNG operates in an insecure mode as long as the\n\t  recording is enabled. This interface therefore is only\n\t  intended for testing purposes and is not suitable for\n\t  production systems.\n\n\t  The raw noise data can be obtained using the jent_raw_hires\n\t  debugfs file. Using the option\n\t  jitterentropy_testing.boot_raw_hires_test=1 the raw noise of\n\t  the first 1000 entropy events since boot can be sampled.\n\n\t  If unsure, select N.\n\nconfig CRYPTO_KDF800108_CTR\n\ttristate\n\tselect CRYPTO_HMAC\n\tselect CRYPTO_SHA256\n\nendmenu\nmenu \"Userspace interface\"\n\nconfig CRYPTO_USER_API\n\ttristate\n\nconfig CRYPTO_USER_API_HASH\n\ttristate \"Hash algorithms\"\n\tdepends on NET\n\tselect CRYPTO_HASH\n\tselect CRYPTO_USER_API\n\thelp\n\t  Enable the userspace interface for hash algorithms.\n\n\t  See Documentation/crypto/userspace-if.rst and\n\t  https://www.chronox.de/libkcapi/html/index.html\n\nconfig CRYPTO_USER_API_SKCIPHER\n\ttristate \"Symmetric key cipher algorithms\"\n\tdepends on NET\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_USER_API\n\thelp\n\t  Enable the userspace interface for symmetric key cipher algorithms.\n\n\t  See Documentation/crypto/userspace-if.rst and\n\t  https://www.chronox.de/libkcapi/html/index.html\n\nconfig CRYPTO_USER_API_RNG\n\ttristate \"RNG (random number generator) algorithms\"\n\tdepends on NET\n\tselect CRYPTO_RNG\n\tselect CRYPTO_USER_API\n\thelp\n\t  Enable the userspace interface for RNG (random number generator)\n\t  algorithms.\n\n\t  See Documentation/crypto/userspace-if.rst and\n\t  https://www.chronox.de/libkcapi/html/index.html\n\nconfig CRYPTO_USER_API_RNG_CAVP\n\tbool \"Enable CAVP testing of DRBG\"\n\tdepends on CRYPTO_USER_API_RNG && CRYPTO_DRBG\n\thelp\n\t  Enable extra APIs in the userspace interface for NIST CAVP\n\t  (Cryptographic Algorithm Validation Program) testing:\n\t  - resetting DRBG entropy\n\t  - providing Additional Data\n\n\t  This should only be enabled for CAVP testing. You should say\n\t  no unless you know what this is.\n\nconfig CRYPTO_USER_API_AEAD\n\ttristate \"AEAD cipher algorithms\"\n\tdepends on NET\n\tselect CRYPTO_AEAD\n\tselect CRYPTO_SKCIPHER\n\tselect CRYPTO_NULL\n\tselect CRYPTO_USER_API\n\thelp\n\t  Enable the userspace interface for AEAD cipher algorithms.\n\n\t  See Documentation/crypto/userspace-if.rst and\n\t  https://www.chronox.de/libkcapi/html/index.html\n\nconfig CRYPTO_USER_API_ENABLE_OBSOLETE\n\tbool \"Obsolete cryptographic algorithms\"\n\tdepends on CRYPTO_USER_API\n\tdefault y\n\thelp\n\t  Allow obsolete cryptographic algorithms to be selected that have\n\t  already been phased out from internal use by the kernel, and are\n\t  only useful for userspace clients that still rely on them.\n\nconfig CRYPTO_STATS\n\tbool \"Crypto usage statistics\"\n\tdepends on CRYPTO_USER\n\thelp\n\t  Enable the gathering of crypto stats.\n\n\t  Enabling this option reduces the performance of the crypto API.  It\n\t  should only be enabled when there is actually a use case for it.\n\n\t  This collects data sizes, numbers of requests, and numbers\n\t  of errors processed by:\n\t  - AEAD ciphers (encrypt, decrypt)\n\t  - asymmetric key ciphers (encrypt, decrypt, verify, sign)\n\t  - symmetric key ciphers (encrypt, decrypt)\n\t  - compression algorithms (compress, decompress)\n\t  - hash algorithms (hash)\n\t  - key-agreement protocol primitives (setsecret, generate\n\t    public key, compute shared secret)\n\t  - RNG (generate, seed)\n\nendmenu\n\nconfig CRYPTO_HASH_INFO\n\tbool\n\nif !KMSAN # avoid false positives from assembly\nif ARM\nsource \"arch/arm/crypto/Kconfig\"\nendif\nif ARM64\nsource \"arch/arm64/crypto/Kconfig\"\nendif\nif LOONGARCH\nsource \"arch/loongarch/crypto/Kconfig\"\nendif\nif MIPS\nsource \"arch/mips/crypto/Kconfig\"\nendif\nif PPC\nsource \"arch/powerpc/crypto/Kconfig\"\nendif\nif S390\nsource \"arch/s390/crypto/Kconfig\"\nendif\nif SPARC\nsource \"arch/sparc/crypto/Kconfig\"\nendif\nif X86\nsource \"arch/x86/crypto/Kconfig\"\nendif\nendif\n\nsource \"drivers/crypto/Kconfig\"\nsource \"crypto/asymmetric_keys/Kconfig\"\nsource \"certs/Kconfig\"\n\nendif\t# if CRYPTO\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}