{
  "module_name": "md4.c",
  "hash_id": "9a0a0f2cf6155f17bf1ee6b0854cfb6c8b924299829c1841746292594c31b926",
  "original_prompt": "Ingested from linux-6.6.14/crypto/md4.c",
  "human_readable_source": " \n#include <crypto/internal/hash.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <asm/byteorder.h>\n\n#define MD4_DIGEST_SIZE\t\t16\n#define MD4_HMAC_BLOCK_SIZE\t64\n#define MD4_BLOCK_WORDS\t\t16\n#define MD4_HASH_WORDS\t\t4\n\nstruct md4_ctx {\n\tu32 hash[MD4_HASH_WORDS];\n\tu32 block[MD4_BLOCK_WORDS];\n\tu64 byte_count;\n};\n\nstatic inline u32 lshift(u32 x, unsigned int s)\n{\n\tx &= 0xFFFFFFFF;\n\treturn ((x << s) & 0xFFFFFFFF) | (x >> (32 - s));\n}\n\nstatic inline u32 F(u32 x, u32 y, u32 z)\n{\n\treturn (x & y) | ((~x) & z);\n}\n\nstatic inline u32 G(u32 x, u32 y, u32 z)\n{\n\treturn (x & y) | (x & z) | (y & z);\n}\n\nstatic inline u32 H(u32 x, u32 y, u32 z)\n{\n\treturn x ^ y ^ z;\n}\n\n#define ROUND1(a,b,c,d,k,s) (a = lshift(a + F(b,c,d) + k, s))\n#define ROUND2(a,b,c,d,k,s) (a = lshift(a + G(b,c,d) + k + (u32)0x5A827999,s))\n#define ROUND3(a,b,c,d,k,s) (a = lshift(a + H(b,c,d) + k + (u32)0x6ED9EBA1,s))\n\nstatic void md4_transform(u32 *hash, u32 const *in)\n{\n\tu32 a, b, c, d;\n\n\ta = hash[0];\n\tb = hash[1];\n\tc = hash[2];\n\td = hash[3];\n\n\tROUND1(a, b, c, d, in[0], 3);\n\tROUND1(d, a, b, c, in[1], 7);\n\tROUND1(c, d, a, b, in[2], 11);\n\tROUND1(b, c, d, a, in[3], 19);\n\tROUND1(a, b, c, d, in[4], 3);\n\tROUND1(d, a, b, c, in[5], 7);\n\tROUND1(c, d, a, b, in[6], 11);\n\tROUND1(b, c, d, a, in[7], 19);\n\tROUND1(a, b, c, d, in[8], 3);\n\tROUND1(d, a, b, c, in[9], 7);\n\tROUND1(c, d, a, b, in[10], 11);\n\tROUND1(b, c, d, a, in[11], 19);\n\tROUND1(a, b, c, d, in[12], 3);\n\tROUND1(d, a, b, c, in[13], 7);\n\tROUND1(c, d, a, b, in[14], 11);\n\tROUND1(b, c, d, a, in[15], 19);\n\n\tROUND2(a, b, c, d,in[ 0], 3);\n\tROUND2(d, a, b, c, in[4], 5);\n\tROUND2(c, d, a, b, in[8], 9);\n\tROUND2(b, c, d, a, in[12], 13);\n\tROUND2(a, b, c, d, in[1], 3);\n\tROUND2(d, a, b, c, in[5], 5);\n\tROUND2(c, d, a, b, in[9], 9);\n\tROUND2(b, c, d, a, in[13], 13);\n\tROUND2(a, b, c, d, in[2], 3);\n\tROUND2(d, a, b, c, in[6], 5);\n\tROUND2(c, d, a, b, in[10], 9);\n\tROUND2(b, c, d, a, in[14], 13);\n\tROUND2(a, b, c, d, in[3], 3);\n\tROUND2(d, a, b, c, in[7], 5);\n\tROUND2(c, d, a, b, in[11], 9);\n\tROUND2(b, c, d, a, in[15], 13);\n\n\tROUND3(a, b, c, d,in[ 0], 3);\n\tROUND3(d, a, b, c, in[8], 9);\n\tROUND3(c, d, a, b, in[4], 11);\n\tROUND3(b, c, d, a, in[12], 15);\n\tROUND3(a, b, c, d, in[2], 3);\n\tROUND3(d, a, b, c, in[10], 9);\n\tROUND3(c, d, a, b, in[6], 11);\n\tROUND3(b, c, d, a, in[14], 15);\n\tROUND3(a, b, c, d, in[1], 3);\n\tROUND3(d, a, b, c, in[9], 9);\n\tROUND3(c, d, a, b, in[5], 11);\n\tROUND3(b, c, d, a, in[13], 15);\n\tROUND3(a, b, c, d, in[3], 3);\n\tROUND3(d, a, b, c, in[11], 9);\n\tROUND3(c, d, a, b, in[7], 11);\n\tROUND3(b, c, d, a, in[15], 15);\n\n\thash[0] += a;\n\thash[1] += b;\n\thash[2] += c;\n\thash[3] += d;\n}\n\nstatic inline void md4_transform_helper(struct md4_ctx *ctx)\n{\n\tle32_to_cpu_array(ctx->block, ARRAY_SIZE(ctx->block));\n\tmd4_transform(ctx->hash, ctx->block);\n}\n\nstatic int md4_init(struct shash_desc *desc)\n{\n\tstruct md4_ctx *mctx = shash_desc_ctx(desc);\n\n\tmctx->hash[0] = 0x67452301;\n\tmctx->hash[1] = 0xefcdab89;\n\tmctx->hash[2] = 0x98badcfe;\n\tmctx->hash[3] = 0x10325476;\n\tmctx->byte_count = 0;\n\n\treturn 0;\n}\n\nstatic int md4_update(struct shash_desc *desc, const u8 *data, unsigned int len)\n{\n\tstruct md4_ctx *mctx = shash_desc_ctx(desc);\n\tconst u32 avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);\n\n\tmctx->byte_count += len;\n\n\tif (avail > len) {\n\t\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t\t       data, len);\n\t\treturn 0;\n\t}\n\n\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t       data, avail);\n\n\tmd4_transform_helper(mctx);\n\tdata += avail;\n\tlen -= avail;\n\n\twhile (len >= sizeof(mctx->block)) {\n\t\tmemcpy(mctx->block, data, sizeof(mctx->block));\n\t\tmd4_transform_helper(mctx);\n\t\tdata += sizeof(mctx->block);\n\t\tlen -= sizeof(mctx->block);\n\t}\n\n\tmemcpy(mctx->block, data, len);\n\n\treturn 0;\n}\n\nstatic int md4_final(struct shash_desc *desc, u8 *out)\n{\n\tstruct md4_ctx *mctx = shash_desc_ctx(desc);\n\tconst unsigned int offset = mctx->byte_count & 0x3f;\n\tchar *p = (char *)mctx->block + offset;\n\tint padding = 56 - (offset + 1);\n\n\t*p++ = 0x80;\n\tif (padding < 0) {\n\t\tmemset(p, 0x00, padding + sizeof (u64));\n\t\tmd4_transform_helper(mctx);\n\t\tp = (char *)mctx->block;\n\t\tpadding = 56;\n\t}\n\n\tmemset(p, 0, padding);\n\tmctx->block[14] = mctx->byte_count << 3;\n\tmctx->block[15] = mctx->byte_count >> 29;\n\tle32_to_cpu_array(mctx->block, (sizeof(mctx->block) -\n\t                  sizeof(u64)) / sizeof(u32));\n\tmd4_transform(mctx->hash, mctx->block);\n\tcpu_to_le32_array(mctx->hash, ARRAY_SIZE(mctx->hash));\n\tmemcpy(out, mctx->hash, sizeof(mctx->hash));\n\tmemset(mctx, 0, sizeof(*mctx));\n\n\treturn 0;\n}\n\nstatic struct shash_alg alg = {\n\t.digestsize\t=\tMD4_DIGEST_SIZE,\n\t.init\t\t=\tmd4_init,\n\t.update\t\t=\tmd4_update,\n\t.final\t\t=\tmd4_final,\n\t.descsize\t=\tsizeof(struct md4_ctx),\n\t.base\t\t=\t{\n\t\t.cra_name\t =\t\"md4\",\n\t\t.cra_driver_name =\t\"md4-generic\",\n\t\t.cra_blocksize\t =\tMD4_HMAC_BLOCK_SIZE,\n\t\t.cra_module\t =\tTHIS_MODULE,\n\t}\n};\n\nstatic int __init md4_mod_init(void)\n{\n\treturn crypto_register_shash(&alg);\n}\n\nstatic void __exit md4_mod_fini(void)\n{\n\tcrypto_unregister_shash(&alg);\n}\n\nsubsys_initcall(md4_mod_init);\nmodule_exit(md4_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MD4 Message Digest Algorithm\");\nMODULE_ALIAS_CRYPTO(\"md4\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}