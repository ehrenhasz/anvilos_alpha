{
  "module_name": "authencesn.c",
  "hash_id": "1a9f41844a436f3ae6f3f09e3cceead999bfc0fed2c78715dd6dff38e0730770",
  "original_prompt": "Ingested from linux-6.6.14/crypto/authencesn.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/aead.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/authenc.h>\n#include <crypto/null.h>\n#include <crypto/scatterwalk.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\nstruct authenc_esn_instance_ctx {\n\tstruct crypto_ahash_spawn auth;\n\tstruct crypto_skcipher_spawn enc;\n};\n\nstruct crypto_authenc_esn_ctx {\n\tunsigned int reqoff;\n\tstruct crypto_ahash *auth;\n\tstruct crypto_skcipher *enc;\n\tstruct crypto_sync_skcipher *null;\n};\n\nstruct authenc_esn_request_ctx {\n\tstruct scatterlist src[2];\n\tstruct scatterlist dst[2];\n\tchar tail[];\n};\n\nstatic void authenc_esn_request_complete(struct aead_request *req, int err)\n{\n\tif (err != -EINPROGRESS)\n\t\taead_request_complete(req, err);\n}\n\nstatic int crypto_authenc_esn_setauthsize(struct crypto_aead *authenc_esn,\n\t\t\t\t\t  unsigned int authsize)\n{\n\tif (authsize > 0 && authsize < 4)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int crypto_authenc_esn_setkey(struct crypto_aead *authenc_esn, const u8 *key,\n\t\t\t\t     unsigned int keylen)\n{\n\tstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\n\tstruct crypto_ahash *auth = ctx->auth;\n\tstruct crypto_skcipher *enc = ctx->enc;\n\tstruct crypto_authenc_keys keys;\n\tint err = -EINVAL;\n\n\tif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\n\t\tgoto out;\n\n\tcrypto_ahash_clear_flags(auth, CRYPTO_TFM_REQ_MASK);\n\tcrypto_ahash_set_flags(auth, crypto_aead_get_flags(authenc_esn) &\n\t\t\t\t     CRYPTO_TFM_REQ_MASK);\n\terr = crypto_ahash_setkey(auth, keys.authkey, keys.authkeylen);\n\tif (err)\n\t\tgoto out;\n\n\tcrypto_skcipher_clear_flags(enc, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(enc, crypto_aead_get_flags(authenc_esn) &\n\t\t\t\t\t CRYPTO_TFM_REQ_MASK);\n\terr = crypto_skcipher_setkey(enc, keys.enckey, keys.enckeylen);\nout:\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn err;\n}\n\nstatic int crypto_authenc_esn_genicv_tail(struct aead_request *req,\n\t\t\t\t\t  unsigned int flags)\n{\n\tstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\n\tstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\n\tstruct authenc_esn_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct crypto_ahash *auth = ctx->auth;\n\tu8 *hash = PTR_ALIGN((u8 *)areq_ctx->tail,\n\t\t\t     crypto_ahash_alignmask(auth) + 1);\n\tunsigned int authsize = crypto_aead_authsize(authenc_esn);\n\tunsigned int assoclen = req->assoclen;\n\tunsigned int cryptlen = req->cryptlen;\n\tstruct scatterlist *dst = req->dst;\n\tu32 tmp[2];\n\n\t \n\tscatterwalk_map_and_copy(tmp, dst, 4, 4, 0);\n\tscatterwalk_map_and_copy(tmp + 1, dst, assoclen + cryptlen, 4, 0);\n\tscatterwalk_map_and_copy(tmp, dst, 0, 8, 1);\n\n\tscatterwalk_map_and_copy(hash, dst, assoclen + cryptlen, authsize, 1);\n\treturn 0;\n}\n\nstatic void authenc_esn_geniv_ahash_done(void *data, int err)\n{\n\tstruct aead_request *req = data;\n\n\terr = err ?: crypto_authenc_esn_genicv_tail(req, 0);\n\taead_request_complete(req, err);\n}\n\nstatic int crypto_authenc_esn_genicv(struct aead_request *req,\n\t\t\t\t     unsigned int flags)\n{\n\tstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\n\tstruct authenc_esn_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\n\tstruct crypto_ahash *auth = ctx->auth;\n\tu8 *hash = PTR_ALIGN((u8 *)areq_ctx->tail,\n\t\t\t     crypto_ahash_alignmask(auth) + 1);\n\tstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\n\tunsigned int authsize = crypto_aead_authsize(authenc_esn);\n\tunsigned int assoclen = req->assoclen;\n\tunsigned int cryptlen = req->cryptlen;\n\tstruct scatterlist *dst = req->dst;\n\tu32 tmp[2];\n\n\tif (!authsize)\n\t\treturn 0;\n\n\t \n\tscatterwalk_map_and_copy(tmp, dst, 0, 8, 0);\n\tscatterwalk_map_and_copy(tmp, dst, 4, 4, 1);\n\tscatterwalk_map_and_copy(tmp + 1, dst, assoclen + cryptlen, 4, 1);\n\n\tsg_init_table(areq_ctx->dst, 2);\n\tdst = scatterwalk_ffwd(areq_ctx->dst, dst, 4);\n\n\tahash_request_set_tfm(ahreq, auth);\n\tahash_request_set_crypt(ahreq, dst, hash, assoclen + cryptlen);\n\tahash_request_set_callback(ahreq, flags,\n\t\t\t\t   authenc_esn_geniv_ahash_done, req);\n\n\treturn crypto_ahash_digest(ahreq) ?:\n\t       crypto_authenc_esn_genicv_tail(req, aead_request_flags(req));\n}\n\n\nstatic void crypto_authenc_esn_encrypt_done(void *data, int err)\n{\n\tstruct aead_request *areq = data;\n\n\tif (!err)\n\t\terr = crypto_authenc_esn_genicv(areq, 0);\n\n\tauthenc_esn_request_complete(areq, err);\n}\n\nstatic int crypto_authenc_esn_copy(struct aead_request *req, unsigned int len)\n{\n\tstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\n\tstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\n\tSYNC_SKCIPHER_REQUEST_ON_STACK(skreq, ctx->null);\n\n\tskcipher_request_set_sync_tfm(skreq, ctx->null);\n\tskcipher_request_set_callback(skreq, aead_request_flags(req),\n\t\t\t\t      NULL, NULL);\n\tskcipher_request_set_crypt(skreq, req->src, req->dst, len, NULL);\n\n\treturn crypto_skcipher_encrypt(skreq);\n}\n\nstatic int crypto_authenc_esn_encrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\n\tstruct authenc_esn_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\n\tstruct skcipher_request *skreq = (void *)(areq_ctx->tail +\n\t\t\t\t\t\t  ctx->reqoff);\n\tstruct crypto_skcipher *enc = ctx->enc;\n\tunsigned int assoclen = req->assoclen;\n\tunsigned int cryptlen = req->cryptlen;\n\tstruct scatterlist *src, *dst;\n\tint err;\n\n\tsg_init_table(areq_ctx->src, 2);\n\tsrc = scatterwalk_ffwd(areq_ctx->src, req->src, assoclen);\n\tdst = src;\n\n\tif (req->src != req->dst) {\n\t\terr = crypto_authenc_esn_copy(req, assoclen);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tsg_init_table(areq_ctx->dst, 2);\n\t\tdst = scatterwalk_ffwd(areq_ctx->dst, req->dst, assoclen);\n\t}\n\n\tskcipher_request_set_tfm(skreq, enc);\n\tskcipher_request_set_callback(skreq, aead_request_flags(req),\n\t\t\t\t      crypto_authenc_esn_encrypt_done, req);\n\tskcipher_request_set_crypt(skreq, src, dst, cryptlen, req->iv);\n\n\terr = crypto_skcipher_encrypt(skreq);\n\tif (err)\n\t\treturn err;\n\n\treturn crypto_authenc_esn_genicv(req, aead_request_flags(req));\n}\n\nstatic int crypto_authenc_esn_decrypt_tail(struct aead_request *req,\n\t\t\t\t\t   unsigned int flags)\n{\n\tstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\n\tunsigned int authsize = crypto_aead_authsize(authenc_esn);\n\tstruct authenc_esn_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\n\tstruct skcipher_request *skreq = (void *)(areq_ctx->tail +\n\t\t\t\t\t\t  ctx->reqoff);\n\tstruct crypto_ahash *auth = ctx->auth;\n\tu8 *ohash = PTR_ALIGN((u8 *)areq_ctx->tail,\n\t\t\t      crypto_ahash_alignmask(auth) + 1);\n\tunsigned int cryptlen = req->cryptlen - authsize;\n\tunsigned int assoclen = req->assoclen;\n\tstruct scatterlist *dst = req->dst;\n\tu8 *ihash = ohash + crypto_ahash_digestsize(auth);\n\tu32 tmp[2];\n\n\tif (!authsize)\n\t\tgoto decrypt;\n\n\t \n\tscatterwalk_map_and_copy(tmp, dst, 4, 4, 0);\n\tscatterwalk_map_and_copy(tmp + 1, dst, assoclen + cryptlen, 4, 0);\n\tscatterwalk_map_and_copy(tmp, dst, 0, 8, 1);\n\n\tif (crypto_memneq(ihash, ohash, authsize))\n\t\treturn -EBADMSG;\n\ndecrypt:\n\n\tsg_init_table(areq_ctx->dst, 2);\n\tdst = scatterwalk_ffwd(areq_ctx->dst, dst, assoclen);\n\n\tskcipher_request_set_tfm(skreq, ctx->enc);\n\tskcipher_request_set_callback(skreq, flags,\n\t\t\t\t      req->base.complete, req->base.data);\n\tskcipher_request_set_crypt(skreq, dst, dst, cryptlen, req->iv);\n\n\treturn crypto_skcipher_decrypt(skreq);\n}\n\nstatic void authenc_esn_verify_ahash_done(void *data, int err)\n{\n\tstruct aead_request *req = data;\n\n\terr = err ?: crypto_authenc_esn_decrypt_tail(req, 0);\n\tauthenc_esn_request_complete(req, err);\n}\n\nstatic int crypto_authenc_esn_decrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\n\tstruct authenc_esn_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\n\tstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\n\tunsigned int authsize = crypto_aead_authsize(authenc_esn);\n\tstruct crypto_ahash *auth = ctx->auth;\n\tu8 *ohash = PTR_ALIGN((u8 *)areq_ctx->tail,\n\t\t\t      crypto_ahash_alignmask(auth) + 1);\n\tunsigned int assoclen = req->assoclen;\n\tunsigned int cryptlen = req->cryptlen;\n\tu8 *ihash = ohash + crypto_ahash_digestsize(auth);\n\tstruct scatterlist *dst = req->dst;\n\tu32 tmp[2];\n\tint err;\n\n\tcryptlen -= authsize;\n\n\tif (req->src != dst) {\n\t\terr = crypto_authenc_esn_copy(req, assoclen + cryptlen);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tscatterwalk_map_and_copy(ihash, req->src, assoclen + cryptlen,\n\t\t\t\t authsize, 0);\n\n\tif (!authsize)\n\t\tgoto tail;\n\n\t \n\tscatterwalk_map_and_copy(tmp, dst, 0, 8, 0);\n\tscatterwalk_map_and_copy(tmp, dst, 4, 4, 1);\n\tscatterwalk_map_and_copy(tmp + 1, dst, assoclen + cryptlen, 4, 1);\n\n\tsg_init_table(areq_ctx->dst, 2);\n\tdst = scatterwalk_ffwd(areq_ctx->dst, dst, 4);\n\n\tahash_request_set_tfm(ahreq, auth);\n\tahash_request_set_crypt(ahreq, dst, ohash, assoclen + cryptlen);\n\tahash_request_set_callback(ahreq, aead_request_flags(req),\n\t\t\t\t   authenc_esn_verify_ahash_done, req);\n\n\terr = crypto_ahash_digest(ahreq);\n\tif (err)\n\t\treturn err;\n\ntail:\n\treturn crypto_authenc_esn_decrypt_tail(req, aead_request_flags(req));\n}\n\nstatic int crypto_authenc_esn_init_tfm(struct crypto_aead *tfm)\n{\n\tstruct aead_instance *inst = aead_alg_instance(tfm);\n\tstruct authenc_esn_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_ahash *auth;\n\tstruct crypto_skcipher *enc;\n\tstruct crypto_sync_skcipher *null;\n\tint err;\n\n\tauth = crypto_spawn_ahash(&ictx->auth);\n\tif (IS_ERR(auth))\n\t\treturn PTR_ERR(auth);\n\n\tenc = crypto_spawn_skcipher(&ictx->enc);\n\terr = PTR_ERR(enc);\n\tif (IS_ERR(enc))\n\t\tgoto err_free_ahash;\n\n\tnull = crypto_get_default_null_skcipher();\n\terr = PTR_ERR(null);\n\tif (IS_ERR(null))\n\t\tgoto err_free_skcipher;\n\n\tctx->auth = auth;\n\tctx->enc = enc;\n\tctx->null = null;\n\n\tctx->reqoff = ALIGN(2 * crypto_ahash_digestsize(auth),\n\t\t\t    crypto_ahash_alignmask(auth) + 1);\n\n\tcrypto_aead_set_reqsize(\n\t\ttfm,\n\t\tsizeof(struct authenc_esn_request_ctx) +\n\t\tctx->reqoff +\n\t\tmax_t(unsigned int,\n\t\t      crypto_ahash_reqsize(auth) +\n\t\t      sizeof(struct ahash_request),\n\t\t      sizeof(struct skcipher_request) +\n\t\t      crypto_skcipher_reqsize(enc)));\n\n\treturn 0;\n\nerr_free_skcipher:\n\tcrypto_free_skcipher(enc);\nerr_free_ahash:\n\tcrypto_free_ahash(auth);\n\treturn err;\n}\n\nstatic void crypto_authenc_esn_exit_tfm(struct crypto_aead *tfm)\n{\n\tstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_ahash(ctx->auth);\n\tcrypto_free_skcipher(ctx->enc);\n\tcrypto_put_default_null_skcipher();\n}\n\nstatic void crypto_authenc_esn_free(struct aead_instance *inst)\n{\n\tstruct authenc_esn_instance_ctx *ctx = aead_instance_ctx(inst);\n\n\tcrypto_drop_skcipher(&ctx->enc);\n\tcrypto_drop_ahash(&ctx->auth);\n\tkfree(inst);\n}\n\nstatic int crypto_authenc_esn_create(struct crypto_template *tmpl,\n\t\t\t\t     struct rtattr **tb)\n{\n\tu32 mask;\n\tstruct aead_instance *inst;\n\tstruct authenc_esn_instance_ctx *ctx;\n\tstruct hash_alg_common *auth;\n\tstruct crypto_alg *auth_base;\n\tstruct skcipher_alg *enc;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_AEAD, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tctx = aead_instance_ctx(inst);\n\n\terr = crypto_grab_ahash(&ctx->auth, aead_crypto_instance(inst),\n\t\t\t\tcrypto_attr_alg_name(tb[1]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\tauth = crypto_spawn_ahash_alg(&ctx->auth);\n\tauth_base = &auth->base;\n\n\terr = crypto_grab_skcipher(&ctx->enc, aead_crypto_instance(inst),\n\t\t\t\t   crypto_attr_alg_name(tb[2]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\tenc = crypto_spawn_skcipher_alg(&ctx->enc);\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"authencesn(%s,%s)\", auth_base->cra_name,\n\t\t     enc->base.cra_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_free_inst;\n\n\tif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"authencesn(%s,%s)\", auth_base->cra_driver_name,\n\t\t     enc->base.cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_free_inst;\n\n\tinst->alg.base.cra_priority = enc->base.cra_priority * 10 +\n\t\t\t\t      auth_base->cra_priority;\n\tinst->alg.base.cra_blocksize = enc->base.cra_blocksize;\n\tinst->alg.base.cra_alignmask = auth_base->cra_alignmask |\n\t\t\t\t       enc->base.cra_alignmask;\n\tinst->alg.base.cra_ctxsize = sizeof(struct crypto_authenc_esn_ctx);\n\n\tinst->alg.ivsize = crypto_skcipher_alg_ivsize(enc);\n\tinst->alg.chunksize = crypto_skcipher_alg_chunksize(enc);\n\tinst->alg.maxauthsize = auth->digestsize;\n\n\tinst->alg.init = crypto_authenc_esn_init_tfm;\n\tinst->alg.exit = crypto_authenc_esn_exit_tfm;\n\n\tinst->alg.setkey = crypto_authenc_esn_setkey;\n\tinst->alg.setauthsize = crypto_authenc_esn_setauthsize;\n\tinst->alg.encrypt = crypto_authenc_esn_encrypt;\n\tinst->alg.decrypt = crypto_authenc_esn_decrypt;\n\n\tinst->free = crypto_authenc_esn_free;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tcrypto_authenc_esn_free(inst);\n\t}\n\treturn err;\n}\n\nstatic struct crypto_template crypto_authenc_esn_tmpl = {\n\t.name = \"authencesn\",\n\t.create = crypto_authenc_esn_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_authenc_esn_module_init(void)\n{\n\treturn crypto_register_template(&crypto_authenc_esn_tmpl);\n}\n\nstatic void __exit crypto_authenc_esn_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_authenc_esn_tmpl);\n}\n\nsubsys_initcall(crypto_authenc_esn_module_init);\nmodule_exit(crypto_authenc_esn_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Steffen Klassert <steffen.klassert@secunet.com>\");\nMODULE_DESCRIPTION(\"AEAD wrapper for IPsec with extended sequence numbers\");\nMODULE_ALIAS_CRYPTO(\"authencesn\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}