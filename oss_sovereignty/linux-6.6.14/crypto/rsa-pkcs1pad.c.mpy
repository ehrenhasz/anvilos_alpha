{
  "module_name": "rsa-pkcs1pad.c",
  "hash_id": "881e2786beb4d515c28a867bf2343e21c0f575d062e0c64905ce90510729ca1e",
  "original_prompt": "Ingested from linux-6.6.14/crypto/rsa-pkcs1pad.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <crypto/akcipher.h>\n#include <crypto/internal/akcipher.h>\n#include <crypto/internal/rsa.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n\n \nstatic const u8 rsa_digest_info_md5[] = {\n\t0x30, 0x20, 0x30, 0x0c, 0x06, 0x08,\n\t0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05,  \n\t0x05, 0x00, 0x04, 0x10\n};\n\nstatic const u8 rsa_digest_info_sha1[] = {\n\t0x30, 0x21, 0x30, 0x09, 0x06, 0x05,\n\t0x2b, 0x0e, 0x03, 0x02, 0x1a,\n\t0x05, 0x00, 0x04, 0x14\n};\n\nstatic const u8 rsa_digest_info_rmd160[] = {\n\t0x30, 0x21, 0x30, 0x09, 0x06, 0x05,\n\t0x2b, 0x24, 0x03, 0x02, 0x01,\n\t0x05, 0x00, 0x04, 0x14\n};\n\nstatic const u8 rsa_digest_info_sha224[] = {\n\t0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09,\n\t0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04,\n\t0x05, 0x00, 0x04, 0x1c\n};\n\nstatic const u8 rsa_digest_info_sha256[] = {\n\t0x30, 0x31, 0x30, 0x0d, 0x06, 0x09,\n\t0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,\n\t0x05, 0x00, 0x04, 0x20\n};\n\nstatic const u8 rsa_digest_info_sha384[] = {\n\t0x30, 0x41, 0x30, 0x0d, 0x06, 0x09,\n\t0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02,\n\t0x05, 0x00, 0x04, 0x30\n};\n\nstatic const u8 rsa_digest_info_sha512[] = {\n\t0x30, 0x51, 0x30, 0x0d, 0x06, 0x09,\n\t0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03,\n\t0x05, 0x00, 0x04, 0x40\n};\n\nstatic const struct rsa_asn1_template {\n\tconst char\t*name;\n\tconst u8\t*data;\n\tsize_t\t\tsize;\n} rsa_asn1_templates[] = {\n#define _(X) { #X, rsa_digest_info_##X, sizeof(rsa_digest_info_##X) }\n\t_(md5),\n\t_(sha1),\n\t_(rmd160),\n\t_(sha256),\n\t_(sha384),\n\t_(sha512),\n\t_(sha224),\n\t{ NULL }\n#undef _\n};\n\nstatic const struct rsa_asn1_template *rsa_lookup_asn1(const char *name)\n{\n\tconst struct rsa_asn1_template *p;\n\n\tfor (p = rsa_asn1_templates; p->name; p++)\n\t\tif (strcmp(name, p->name) == 0)\n\t\t\treturn p;\n\treturn NULL;\n}\n\nstruct pkcs1pad_ctx {\n\tstruct crypto_akcipher *child;\n\tunsigned int key_size;\n};\n\nstruct pkcs1pad_inst_ctx {\n\tstruct crypto_akcipher_spawn spawn;\n\tconst struct rsa_asn1_template *digest_info;\n};\n\nstruct pkcs1pad_request {\n\tstruct scatterlist in_sg[2], out_sg[1];\n\tuint8_t *in_buf, *out_buf;\n\tstruct akcipher_request child_req;\n};\n\nstatic int pkcs1pad_set_pub_key(struct crypto_akcipher *tfm, const void *key,\n\t\tunsigned int keylen)\n{\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tint err;\n\n\tctx->key_size = 0;\n\n\terr = crypto_akcipher_set_pub_key(ctx->child, key, keylen);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = crypto_akcipher_maxsize(ctx->child);\n\tif (err > PAGE_SIZE)\n\t\treturn -ENOTSUPP;\n\n\tctx->key_size = err;\n\treturn 0;\n}\n\nstatic int pkcs1pad_set_priv_key(struct crypto_akcipher *tfm, const void *key,\n\t\tunsigned int keylen)\n{\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tint err;\n\n\tctx->key_size = 0;\n\n\terr = crypto_akcipher_set_priv_key(ctx->child, key, keylen);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = crypto_akcipher_maxsize(ctx->child);\n\tif (err > PAGE_SIZE)\n\t\treturn -ENOTSUPP;\n\n\tctx->key_size = err;\n\treturn 0;\n}\n\nstatic unsigned int pkcs1pad_get_max_size(struct crypto_akcipher *tfm)\n{\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\n\t \n\n\treturn ctx->key_size;\n}\n\nstatic void pkcs1pad_sg_set_buf(struct scatterlist *sg, void *buf, size_t len,\n\t\tstruct scatterlist *next)\n{\n\tint nsegs = next ? 2 : 1;\n\n\tsg_init_table(sg, nsegs);\n\tsg_set_buf(sg, buf, len);\n\n\tif (next)\n\t\tsg_chain(sg, nsegs, next);\n}\n\nstatic int pkcs1pad_encrypt_sign_complete(struct akcipher_request *req, int err)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\n\tunsigned int pad_len;\n\tunsigned int len;\n\tu8 *out_buf;\n\n\tif (err)\n\t\tgoto out;\n\n\tlen = req_ctx->child_req.dst_len;\n\tpad_len = ctx->key_size - len;\n\n\t \n\tif (likely(!pad_len))\n\t\tgoto out;\n\n\tout_buf = kzalloc(ctx->key_size, GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (!out_buf)\n\t\tgoto out;\n\n\tsg_copy_to_buffer(req->dst, sg_nents_for_len(req->dst, len),\n\t\t\t  out_buf + pad_len, len);\n\tsg_copy_from_buffer(req->dst,\n\t\t\t    sg_nents_for_len(req->dst, ctx->key_size),\n\t\t\t    out_buf, ctx->key_size);\n\tkfree_sensitive(out_buf);\n\nout:\n\treq->dst_len = ctx->key_size;\n\n\tkfree(req_ctx->in_buf);\n\n\treturn err;\n}\n\nstatic void pkcs1pad_encrypt_sign_complete_cb(void *data, int err)\n{\n\tstruct akcipher_request *req = data;\n\n\tif (err == -EINPROGRESS)\n\t\tgoto out;\n\n\terr = pkcs1pad_encrypt_sign_complete(req, err);\n\nout:\n\takcipher_request_complete(req, err);\n}\n\nstatic int pkcs1pad_encrypt(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\n\tint err;\n\tunsigned int i, ps_end;\n\n\tif (!ctx->key_size)\n\t\treturn -EINVAL;\n\n\tif (req->src_len > ctx->key_size - 11)\n\t\treturn -EOVERFLOW;\n\n\tif (req->dst_len < ctx->key_size) {\n\t\treq->dst_len = ctx->key_size;\n\t\treturn -EOVERFLOW;\n\t}\n\n\treq_ctx->in_buf = kmalloc(ctx->key_size - 1 - req->src_len,\n\t\t\t\t  GFP_KERNEL);\n\tif (!req_ctx->in_buf)\n\t\treturn -ENOMEM;\n\n\tps_end = ctx->key_size - req->src_len - 2;\n\treq_ctx->in_buf[0] = 0x02;\n\tfor (i = 1; i < ps_end; i++)\n\t\treq_ctx->in_buf[i] = get_random_u32_inclusive(1, 255);\n\treq_ctx->in_buf[ps_end] = 0x00;\n\n\tpkcs1pad_sg_set_buf(req_ctx->in_sg, req_ctx->in_buf,\n\t\t\tctx->key_size - 1 - req->src_len, req->src);\n\n\takcipher_request_set_tfm(&req_ctx->child_req, ctx->child);\n\takcipher_request_set_callback(&req_ctx->child_req, req->base.flags,\n\t\t\tpkcs1pad_encrypt_sign_complete_cb, req);\n\n\t \n\takcipher_request_set_crypt(&req_ctx->child_req, req_ctx->in_sg,\n\t\t\t\t   req->dst, ctx->key_size - 1, req->dst_len);\n\n\terr = crypto_akcipher_encrypt(&req_ctx->child_req);\n\tif (err != -EINPROGRESS && err != -EBUSY)\n\t\treturn pkcs1pad_encrypt_sign_complete(req, err);\n\n\treturn err;\n}\n\nstatic int pkcs1pad_decrypt_complete(struct akcipher_request *req, int err)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\n\tunsigned int dst_len;\n\tunsigned int pos;\n\tu8 *out_buf;\n\n\tif (err)\n\t\tgoto done;\n\n\terr = -EINVAL;\n\tdst_len = req_ctx->child_req.dst_len;\n\tif (dst_len < ctx->key_size - 1)\n\t\tgoto done;\n\n\tout_buf = req_ctx->out_buf;\n\tif (dst_len == ctx->key_size) {\n\t\tif (out_buf[0] != 0x00)\n\t\t\t \n\t\t\tgoto done;\n\n\t\tdst_len--;\n\t\tout_buf++;\n\t}\n\n\tif (out_buf[0] != 0x02)\n\t\tgoto done;\n\n\tfor (pos = 1; pos < dst_len; pos++)\n\t\tif (out_buf[pos] == 0x00)\n\t\t\tbreak;\n\tif (pos < 9 || pos == dst_len)\n\t\tgoto done;\n\tpos++;\n\n\terr = 0;\n\n\tif (req->dst_len < dst_len - pos)\n\t\terr = -EOVERFLOW;\n\treq->dst_len = dst_len - pos;\n\n\tif (!err)\n\t\tsg_copy_from_buffer(req->dst,\n\t\t\t\tsg_nents_for_len(req->dst, req->dst_len),\n\t\t\t\tout_buf + pos, req->dst_len);\n\ndone:\n\tkfree_sensitive(req_ctx->out_buf);\n\n\treturn err;\n}\n\nstatic void pkcs1pad_decrypt_complete_cb(void *data, int err)\n{\n\tstruct akcipher_request *req = data;\n\n\tif (err == -EINPROGRESS)\n\t\tgoto out;\n\n\terr = pkcs1pad_decrypt_complete(req, err);\n\nout:\n\takcipher_request_complete(req, err);\n}\n\nstatic int pkcs1pad_decrypt(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\n\tint err;\n\n\tif (!ctx->key_size || req->src_len != ctx->key_size)\n\t\treturn -EINVAL;\n\n\treq_ctx->out_buf = kmalloc(ctx->key_size, GFP_KERNEL);\n\tif (!req_ctx->out_buf)\n\t\treturn -ENOMEM;\n\n\tpkcs1pad_sg_set_buf(req_ctx->out_sg, req_ctx->out_buf,\n\t\t\t    ctx->key_size, NULL);\n\n\takcipher_request_set_tfm(&req_ctx->child_req, ctx->child);\n\takcipher_request_set_callback(&req_ctx->child_req, req->base.flags,\n\t\t\tpkcs1pad_decrypt_complete_cb, req);\n\n\t \n\takcipher_request_set_crypt(&req_ctx->child_req, req->src,\n\t\t\t\t   req_ctx->out_sg, req->src_len,\n\t\t\t\t   ctx->key_size);\n\n\terr = crypto_akcipher_decrypt(&req_ctx->child_req);\n\tif (err != -EINPROGRESS && err != -EBUSY)\n\t\treturn pkcs1pad_decrypt_complete(req, err);\n\n\treturn err;\n}\n\nstatic int pkcs1pad_sign(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\n\tstruct akcipher_instance *inst = akcipher_alg_instance(tfm);\n\tstruct pkcs1pad_inst_ctx *ictx = akcipher_instance_ctx(inst);\n\tconst struct rsa_asn1_template *digest_info = ictx->digest_info;\n\tint err;\n\tunsigned int ps_end, digest_info_size = 0;\n\n\tif (!ctx->key_size)\n\t\treturn -EINVAL;\n\n\tif (digest_info)\n\t\tdigest_info_size = digest_info->size;\n\n\tif (req->src_len + digest_info_size > ctx->key_size - 11)\n\t\treturn -EOVERFLOW;\n\n\tif (req->dst_len < ctx->key_size) {\n\t\treq->dst_len = ctx->key_size;\n\t\treturn -EOVERFLOW;\n\t}\n\n\treq_ctx->in_buf = kmalloc(ctx->key_size - 1 - req->src_len,\n\t\t\t\t  GFP_KERNEL);\n\tif (!req_ctx->in_buf)\n\t\treturn -ENOMEM;\n\n\tps_end = ctx->key_size - digest_info_size - req->src_len - 2;\n\treq_ctx->in_buf[0] = 0x01;\n\tmemset(req_ctx->in_buf + 1, 0xff, ps_end - 1);\n\treq_ctx->in_buf[ps_end] = 0x00;\n\n\tif (digest_info)\n\t\tmemcpy(req_ctx->in_buf + ps_end + 1, digest_info->data,\n\t\t       digest_info->size);\n\n\tpkcs1pad_sg_set_buf(req_ctx->in_sg, req_ctx->in_buf,\n\t\t\tctx->key_size - 1 - req->src_len, req->src);\n\n\takcipher_request_set_tfm(&req_ctx->child_req, ctx->child);\n\takcipher_request_set_callback(&req_ctx->child_req, req->base.flags,\n\t\t\tpkcs1pad_encrypt_sign_complete_cb, req);\n\n\t \n\takcipher_request_set_crypt(&req_ctx->child_req, req_ctx->in_sg,\n\t\t\t\t   req->dst, ctx->key_size - 1, req->dst_len);\n\n\terr = crypto_akcipher_decrypt(&req_ctx->child_req);\n\tif (err != -EINPROGRESS && err != -EBUSY)\n\t\treturn pkcs1pad_encrypt_sign_complete(req, err);\n\n\treturn err;\n}\n\nstatic int pkcs1pad_verify_complete(struct akcipher_request *req, int err)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\n\tstruct akcipher_instance *inst = akcipher_alg_instance(tfm);\n\tstruct pkcs1pad_inst_ctx *ictx = akcipher_instance_ctx(inst);\n\tconst struct rsa_asn1_template *digest_info = ictx->digest_info;\n\tconst unsigned int sig_size = req->src_len;\n\tconst unsigned int digest_size = req->dst_len;\n\tunsigned int dst_len;\n\tunsigned int pos;\n\tu8 *out_buf;\n\n\tif (err)\n\t\tgoto done;\n\n\terr = -EINVAL;\n\tdst_len = req_ctx->child_req.dst_len;\n\tif (dst_len < ctx->key_size - 1)\n\t\tgoto done;\n\n\tout_buf = req_ctx->out_buf;\n\tif (dst_len == ctx->key_size) {\n\t\tif (out_buf[0] != 0x00)\n\t\t\t \n\t\t\tgoto done;\n\n\t\tdst_len--;\n\t\tout_buf++;\n\t}\n\n\terr = -EBADMSG;\n\tif (out_buf[0] != 0x01)\n\t\tgoto done;\n\n\tfor (pos = 1; pos < dst_len; pos++)\n\t\tif (out_buf[pos] != 0xff)\n\t\t\tbreak;\n\n\tif (pos < 9 || pos == dst_len || out_buf[pos] != 0x00)\n\t\tgoto done;\n\tpos++;\n\n\tif (digest_info) {\n\t\tif (digest_info->size > dst_len - pos)\n\t\t\tgoto done;\n\t\tif (crypto_memneq(out_buf + pos, digest_info->data,\n\t\t\t\t  digest_info->size))\n\t\t\tgoto done;\n\n\t\tpos += digest_info->size;\n\t}\n\n\terr = 0;\n\n\tif (digest_size != dst_len - pos) {\n\t\terr = -EKEYREJECTED;\n\t\treq->dst_len = dst_len - pos;\n\t\tgoto done;\n\t}\n\t \n\tsg_pcopy_to_buffer(req->src,\n\t\t\t   sg_nents_for_len(req->src, sig_size + digest_size),\n\t\t\t   req_ctx->out_buf + ctx->key_size,\n\t\t\t   digest_size, sig_size);\n\t \n\tif (memcmp(req_ctx->out_buf + ctx->key_size, out_buf + pos,\n\t\t   digest_size) != 0)\n\t\terr = -EKEYREJECTED;\ndone:\n\tkfree_sensitive(req_ctx->out_buf);\n\n\treturn err;\n}\n\nstatic void pkcs1pad_verify_complete_cb(void *data, int err)\n{\n\tstruct akcipher_request *req = data;\n\n\tif (err == -EINPROGRESS)\n\t\tgoto out;\n\n\terr = pkcs1pad_verify_complete(req, err);\n\nout:\n\takcipher_request_complete(req, err);\n}\n\n \nstatic int pkcs1pad_verify(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\n\tconst unsigned int sig_size = req->src_len;\n\tconst unsigned int digest_size = req->dst_len;\n\tint err;\n\n\tif (WARN_ON(req->dst) || WARN_ON(!digest_size) ||\n\t    !ctx->key_size || sig_size != ctx->key_size)\n\t\treturn -EINVAL;\n\n\treq_ctx->out_buf = kmalloc(ctx->key_size + digest_size, GFP_KERNEL);\n\tif (!req_ctx->out_buf)\n\t\treturn -ENOMEM;\n\n\tpkcs1pad_sg_set_buf(req_ctx->out_sg, req_ctx->out_buf,\n\t\t\t    ctx->key_size, NULL);\n\n\takcipher_request_set_tfm(&req_ctx->child_req, ctx->child);\n\takcipher_request_set_callback(&req_ctx->child_req, req->base.flags,\n\t\t\tpkcs1pad_verify_complete_cb, req);\n\n\t \n\takcipher_request_set_crypt(&req_ctx->child_req, req->src,\n\t\t\t\t   req_ctx->out_sg, sig_size, ctx->key_size);\n\n\terr = crypto_akcipher_encrypt(&req_ctx->child_req);\n\tif (err != -EINPROGRESS && err != -EBUSY)\n\t\treturn pkcs1pad_verify_complete(req, err);\n\n\treturn err;\n}\n\nstatic int pkcs1pad_init_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct akcipher_instance *inst = akcipher_alg_instance(tfm);\n\tstruct pkcs1pad_inst_ctx *ictx = akcipher_instance_ctx(inst);\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct crypto_akcipher *child_tfm;\n\n\tchild_tfm = crypto_spawn_akcipher(&ictx->spawn);\n\tif (IS_ERR(child_tfm))\n\t\treturn PTR_ERR(child_tfm);\n\n\tctx->child = child_tfm;\n\n\takcipher_set_reqsize(tfm, sizeof(struct pkcs1pad_request) +\n\t\t\t\t  crypto_akcipher_reqsize(child_tfm));\n\n\treturn 0;\n}\n\nstatic void pkcs1pad_exit_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\n\n\tcrypto_free_akcipher(ctx->child);\n}\n\nstatic void pkcs1pad_free(struct akcipher_instance *inst)\n{\n\tstruct pkcs1pad_inst_ctx *ctx = akcipher_instance_ctx(inst);\n\tstruct crypto_akcipher_spawn *spawn = &ctx->spawn;\n\n\tcrypto_drop_akcipher(spawn);\n\tkfree(inst);\n}\n\nstatic int pkcs1pad_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tu32 mask;\n\tstruct akcipher_instance *inst;\n\tstruct pkcs1pad_inst_ctx *ctx;\n\tstruct akcipher_alg *rsa_alg;\n\tconst char *hash_name;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_AKCIPHER, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tctx = akcipher_instance_ctx(inst);\n\n\terr = crypto_grab_akcipher(&ctx->spawn, akcipher_crypto_instance(inst),\n\t\t\t\t   crypto_attr_alg_name(tb[1]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\trsa_alg = crypto_spawn_akcipher_alg(&ctx->spawn);\n\n\tif (strcmp(rsa_alg->base.cra_name, \"rsa\") != 0) {\n\t\terr = -EINVAL;\n\t\tgoto err_free_inst;\n\t}\n\n\terr = -ENAMETOOLONG;\n\thash_name = crypto_attr_alg_name(tb[2]);\n\tif (IS_ERR(hash_name)) {\n\t\tif (snprintf(inst->alg.base.cra_name,\n\t\t\t     CRYPTO_MAX_ALG_NAME, \"pkcs1pad(%s)\",\n\t\t\t     rsa_alg->base.cra_name) >= CRYPTO_MAX_ALG_NAME)\n\t\t\tgoto err_free_inst;\n\n\t\tif (snprintf(inst->alg.base.cra_driver_name,\n\t\t\t     CRYPTO_MAX_ALG_NAME, \"pkcs1pad(%s)\",\n\t\t\t     rsa_alg->base.cra_driver_name) >=\n\t\t\t     CRYPTO_MAX_ALG_NAME)\n\t\t\tgoto err_free_inst;\n\t} else {\n\t\tctx->digest_info = rsa_lookup_asn1(hash_name);\n\t\tif (!ctx->digest_info) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free_inst;\n\t\t}\n\n\t\tif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t\t     \"pkcs1pad(%s,%s)\", rsa_alg->base.cra_name,\n\t\t\t     hash_name) >= CRYPTO_MAX_ALG_NAME)\n\t\t\tgoto err_free_inst;\n\n\t\tif (snprintf(inst->alg.base.cra_driver_name,\n\t\t\t     CRYPTO_MAX_ALG_NAME, \"pkcs1pad(%s,%s)\",\n\t\t\t     rsa_alg->base.cra_driver_name,\n\t\t\t     hash_name) >= CRYPTO_MAX_ALG_NAME)\n\t\t\tgoto err_free_inst;\n\t}\n\n\tinst->alg.base.cra_priority = rsa_alg->base.cra_priority;\n\tinst->alg.base.cra_ctxsize = sizeof(struct pkcs1pad_ctx);\n\n\tinst->alg.init = pkcs1pad_init_tfm;\n\tinst->alg.exit = pkcs1pad_exit_tfm;\n\n\tinst->alg.encrypt = pkcs1pad_encrypt;\n\tinst->alg.decrypt = pkcs1pad_decrypt;\n\tinst->alg.sign = pkcs1pad_sign;\n\tinst->alg.verify = pkcs1pad_verify;\n\tinst->alg.set_pub_key = pkcs1pad_set_pub_key;\n\tinst->alg.set_priv_key = pkcs1pad_set_priv_key;\n\tinst->alg.max_size = pkcs1pad_get_max_size;\n\n\tinst->free = pkcs1pad_free;\n\n\terr = akcipher_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tpkcs1pad_free(inst);\n\t}\n\treturn err;\n}\n\nstruct crypto_template rsa_pkcs1pad_tmpl = {\n\t.name = \"pkcs1pad\",\n\t.create = pkcs1pad_create,\n\t.module = THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}