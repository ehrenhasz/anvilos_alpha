{
  "module_name": "rsa.c",
  "hash_id": "76d72ac67de4d8540802f747312dc234b141d0bac79911ec1f59acda1e9c299d",
  "original_prompt": "Ingested from linux-6.6.14/crypto/rsa.c",
  "human_readable_source": "\n \n\n#include <linux/fips.h>\n#include <linux/module.h>\n#include <linux/mpi.h>\n#include <crypto/internal/rsa.h>\n#include <crypto/internal/akcipher.h>\n#include <crypto/akcipher.h>\n#include <crypto/algapi.h>\n\nstruct rsa_mpi_key {\n\tMPI n;\n\tMPI e;\n\tMPI d;\n\tMPI p;\n\tMPI q;\n\tMPI dp;\n\tMPI dq;\n\tMPI qinv;\n};\n\n \nstatic int _rsa_enc(const struct rsa_mpi_key *key, MPI c, MPI m)\n{\n\t \n\tif (mpi_cmp_ui(m, 0) < 0 || mpi_cmp(m, key->n) >= 0)\n\t\treturn -EINVAL;\n\n\t \n\treturn mpi_powm(c, m, key->e, key->n);\n}\n\n \nstatic int _rsa_dec_crt(const struct rsa_mpi_key *key, MPI m_or_m1_or_h, MPI c)\n{\n\tMPI m2, m12_or_qh;\n\tint ret = -ENOMEM;\n\n\t \n\tif (mpi_cmp_ui(c, 0) < 0 || mpi_cmp(c, key->n) >= 0)\n\t\treturn -EINVAL;\n\n\tm2 = mpi_alloc(0);\n\tm12_or_qh = mpi_alloc(0);\n\tif (!m2 || !m12_or_qh)\n\t\tgoto err_free_mpi;\n\n\t \n\tret = mpi_powm(m_or_m1_or_h, c, key->dp, key->p);\n\tif (ret)\n\t\tgoto err_free_mpi;\n\n\t \n\tret = mpi_powm(m2, c, key->dq, key->q);\n\tif (ret)\n\t\tgoto err_free_mpi;\n\n\t \n\tmpi_sub(m12_or_qh, m_or_m1_or_h, m2);\n\tmpi_mulm(m_or_m1_or_h, m12_or_qh, key->qinv, key->p);\n\n\t \n\tmpi_mul(m12_or_qh, key->q, m_or_m1_or_h);\n\tmpi_addm(m_or_m1_or_h, m2, m12_or_qh, key->n);\n\n\tret = 0;\n\nerr_free_mpi:\n\tmpi_free(m12_or_qh);\n\tmpi_free(m2);\n\treturn ret;\n}\n\nstatic inline struct rsa_mpi_key *rsa_get_key(struct crypto_akcipher *tfm)\n{\n\treturn akcipher_tfm_ctx(tfm);\n}\n\nstatic int rsa_enc(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tconst struct rsa_mpi_key *pkey = rsa_get_key(tfm);\n\tMPI m, c = mpi_alloc(0);\n\tint ret = 0;\n\tint sign;\n\n\tif (!c)\n\t\treturn -ENOMEM;\n\n\tif (unlikely(!pkey->n || !pkey->e)) {\n\t\tret = -EINVAL;\n\t\tgoto err_free_c;\n\t}\n\n\tret = -ENOMEM;\n\tm = mpi_read_raw_from_sgl(req->src, req->src_len);\n\tif (!m)\n\t\tgoto err_free_c;\n\n\tret = _rsa_enc(pkey, c, m);\n\tif (ret)\n\t\tgoto err_free_m;\n\n\tret = mpi_write_to_sgl(c, req->dst, req->dst_len, &sign);\n\tif (ret)\n\t\tgoto err_free_m;\n\n\tif (sign < 0)\n\t\tret = -EBADMSG;\n\nerr_free_m:\n\tmpi_free(m);\nerr_free_c:\n\tmpi_free(c);\n\treturn ret;\n}\n\nstatic int rsa_dec(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tconst struct rsa_mpi_key *pkey = rsa_get_key(tfm);\n\tMPI c, m = mpi_alloc(0);\n\tint ret = 0;\n\tint sign;\n\n\tif (!m)\n\t\treturn -ENOMEM;\n\n\tif (unlikely(!pkey->n || !pkey->d)) {\n\t\tret = -EINVAL;\n\t\tgoto err_free_m;\n\t}\n\n\tret = -ENOMEM;\n\tc = mpi_read_raw_from_sgl(req->src, req->src_len);\n\tif (!c)\n\t\tgoto err_free_m;\n\n\tret = _rsa_dec_crt(pkey, m, c);\n\tif (ret)\n\t\tgoto err_free_c;\n\n\tret = mpi_write_to_sgl(m, req->dst, req->dst_len, &sign);\n\tif (ret)\n\t\tgoto err_free_c;\n\n\tif (sign < 0)\n\t\tret = -EBADMSG;\nerr_free_c:\n\tmpi_free(c);\nerr_free_m:\n\tmpi_free(m);\n\treturn ret;\n}\n\nstatic void rsa_free_mpi_key(struct rsa_mpi_key *key)\n{\n\tmpi_free(key->d);\n\tmpi_free(key->e);\n\tmpi_free(key->n);\n\tmpi_free(key->p);\n\tmpi_free(key->q);\n\tmpi_free(key->dp);\n\tmpi_free(key->dq);\n\tmpi_free(key->qinv);\n\tkey->d = NULL;\n\tkey->e = NULL;\n\tkey->n = NULL;\n\tkey->p = NULL;\n\tkey->q = NULL;\n\tkey->dp = NULL;\n\tkey->dq = NULL;\n\tkey->qinv = NULL;\n}\n\nstatic int rsa_check_key_length(unsigned int len)\n{\n\tswitch (len) {\n\tcase 512:\n\tcase 1024:\n\tcase 1536:\n\t\tif (fips_enabled)\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tcase 2048:\n\tcase 3072:\n\tcase 4096:\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int rsa_check_exponent_fips(MPI e)\n{\n\tMPI e_max = NULL;\n\n\t \n\tif (!mpi_test_bit(e, 0)) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mpi_cmp_ui(e, 65536) <= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\te_max = mpi_alloc(0);\n\tif (!e_max)\n\t\treturn -ENOMEM;\n\tmpi_set_bit(e_max, 256);\n\n\tif (mpi_cmp(e, e_max) >= 0) {\n\t\tmpi_free(e_max);\n\t\treturn -EINVAL;\n\t}\n\n\tmpi_free(e_max);\n\treturn 0;\n}\n\nstatic int rsa_set_pub_key(struct crypto_akcipher *tfm, const void *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct rsa_mpi_key *mpi_key = akcipher_tfm_ctx(tfm);\n\tstruct rsa_key raw_key = {0};\n\tint ret;\n\n\t \n\trsa_free_mpi_key(mpi_key);\n\n\tret = rsa_parse_pub_key(&raw_key, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\tmpi_key->e = mpi_read_raw_data(raw_key.e, raw_key.e_sz);\n\tif (!mpi_key->e)\n\t\tgoto err;\n\n\tmpi_key->n = mpi_read_raw_data(raw_key.n, raw_key.n_sz);\n\tif (!mpi_key->n)\n\t\tgoto err;\n\n\tif (rsa_check_key_length(mpi_get_size(mpi_key->n) << 3)) {\n\t\trsa_free_mpi_key(mpi_key);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fips_enabled && rsa_check_exponent_fips(mpi_key->e)) {\n\t\trsa_free_mpi_key(mpi_key);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\nerr:\n\trsa_free_mpi_key(mpi_key);\n\treturn -ENOMEM;\n}\n\nstatic int rsa_set_priv_key(struct crypto_akcipher *tfm, const void *key,\n\t\t\t    unsigned int keylen)\n{\n\tstruct rsa_mpi_key *mpi_key = akcipher_tfm_ctx(tfm);\n\tstruct rsa_key raw_key = {0};\n\tint ret;\n\n\t \n\trsa_free_mpi_key(mpi_key);\n\n\tret = rsa_parse_priv_key(&raw_key, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\tmpi_key->d = mpi_read_raw_data(raw_key.d, raw_key.d_sz);\n\tif (!mpi_key->d)\n\t\tgoto err;\n\n\tmpi_key->e = mpi_read_raw_data(raw_key.e, raw_key.e_sz);\n\tif (!mpi_key->e)\n\t\tgoto err;\n\n\tmpi_key->n = mpi_read_raw_data(raw_key.n, raw_key.n_sz);\n\tif (!mpi_key->n)\n\t\tgoto err;\n\n\tmpi_key->p = mpi_read_raw_data(raw_key.p, raw_key.p_sz);\n\tif (!mpi_key->p)\n\t\tgoto err;\n\n\tmpi_key->q = mpi_read_raw_data(raw_key.q, raw_key.q_sz);\n\tif (!mpi_key->q)\n\t\tgoto err;\n\n\tmpi_key->dp = mpi_read_raw_data(raw_key.dp, raw_key.dp_sz);\n\tif (!mpi_key->dp)\n\t\tgoto err;\n\n\tmpi_key->dq = mpi_read_raw_data(raw_key.dq, raw_key.dq_sz);\n\tif (!mpi_key->dq)\n\t\tgoto err;\n\n\tmpi_key->qinv = mpi_read_raw_data(raw_key.qinv, raw_key.qinv_sz);\n\tif (!mpi_key->qinv)\n\t\tgoto err;\n\n\tif (rsa_check_key_length(mpi_get_size(mpi_key->n) << 3)) {\n\t\trsa_free_mpi_key(mpi_key);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fips_enabled && rsa_check_exponent_fips(mpi_key->e)) {\n\t\trsa_free_mpi_key(mpi_key);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\nerr:\n\trsa_free_mpi_key(mpi_key);\n\treturn -ENOMEM;\n}\n\nstatic unsigned int rsa_max_size(struct crypto_akcipher *tfm)\n{\n\tstruct rsa_mpi_key *pkey = akcipher_tfm_ctx(tfm);\n\n\treturn mpi_get_size(pkey->n);\n}\n\nstatic void rsa_exit_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct rsa_mpi_key *pkey = akcipher_tfm_ctx(tfm);\n\n\trsa_free_mpi_key(pkey);\n}\n\nstatic struct akcipher_alg rsa = {\n\t.encrypt = rsa_enc,\n\t.decrypt = rsa_dec,\n\t.set_priv_key = rsa_set_priv_key,\n\t.set_pub_key = rsa_set_pub_key,\n\t.max_size = rsa_max_size,\n\t.exit = rsa_exit_tfm,\n\t.base = {\n\t\t.cra_name = \"rsa\",\n\t\t.cra_driver_name = \"rsa-generic\",\n\t\t.cra_priority = 100,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct rsa_mpi_key),\n\t},\n};\n\nstatic int __init rsa_init(void)\n{\n\tint err;\n\n\terr = crypto_register_akcipher(&rsa);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_register_template(&rsa_pkcs1pad_tmpl);\n\tif (err) {\n\t\tcrypto_unregister_akcipher(&rsa);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit rsa_exit(void)\n{\n\tcrypto_unregister_template(&rsa_pkcs1pad_tmpl);\n\tcrypto_unregister_akcipher(&rsa);\n}\n\nsubsys_initcall(rsa_init);\nmodule_exit(rsa_exit);\nMODULE_ALIAS_CRYPTO(\"rsa\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"RSA generic algorithm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}