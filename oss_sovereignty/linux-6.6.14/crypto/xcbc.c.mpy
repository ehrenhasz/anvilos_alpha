{
  "module_name": "xcbc.c",
  "hash_id": "2172685e9b95b4c76e840aa2bb7980864856526f9614679a87954833304a2096",
  "original_prompt": "Ingested from linux-6.6.14/crypto/xcbc.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/hash.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic u_int32_t ks[12] = {0x01010101, 0x01010101, 0x01010101, 0x01010101,\n\t\t\t   0x02020202, 0x02020202, 0x02020202, 0x02020202,\n\t\t\t   0x03030303, 0x03030303, 0x03030303, 0x03030303};\n\n \nstruct xcbc_tfm_ctx {\n\tstruct crypto_cipher *child;\n\tu8 ctx[];\n};\n\n \nstruct xcbc_desc_ctx {\n\tunsigned int len;\n\tu8 ctx[];\n};\n\n#define XCBC_BLOCKSIZE\t16\n\nstatic int crypto_xcbc_digest_setkey(struct crypto_shash *parent,\n\t\t\t\t     const u8 *inkey, unsigned int keylen)\n{\n\tunsigned long alignmask = crypto_shash_alignmask(parent);\n\tstruct xcbc_tfm_ctx *ctx = crypto_shash_ctx(parent);\n\tu8 *consts = PTR_ALIGN(&ctx->ctx[0], alignmask + 1);\n\tint err = 0;\n\tu8 key1[XCBC_BLOCKSIZE];\n\tint bs = sizeof(key1);\n\n\tif ((err = crypto_cipher_setkey(ctx->child, inkey, keylen)))\n\t\treturn err;\n\n\tcrypto_cipher_encrypt_one(ctx->child, consts, (u8 *)ks + bs);\n\tcrypto_cipher_encrypt_one(ctx->child, consts + bs, (u8 *)ks + bs * 2);\n\tcrypto_cipher_encrypt_one(ctx->child, key1, (u8 *)ks);\n\n\treturn crypto_cipher_setkey(ctx->child, key1, bs);\n\n}\n\nstatic int crypto_xcbc_digest_init(struct shash_desc *pdesc)\n{\n\tunsigned long alignmask = crypto_shash_alignmask(pdesc->tfm);\n\tstruct xcbc_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tint bs = crypto_shash_blocksize(pdesc->tfm);\n\tu8 *prev = PTR_ALIGN(&ctx->ctx[0], alignmask + 1) + bs;\n\n\tctx->len = 0;\n\tmemset(prev, 0, bs);\n\n\treturn 0;\n}\n\nstatic int crypto_xcbc_digest_update(struct shash_desc *pdesc, const u8 *p,\n\t\t\t\t     unsigned int len)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tunsigned long alignmask = crypto_shash_alignmask(parent);\n\tstruct xcbc_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct xcbc_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_blocksize(parent);\n\tu8 *odds = PTR_ALIGN(&ctx->ctx[0], alignmask + 1);\n\tu8 *prev = odds + bs;\n\n\t \n\tif ((ctx->len + len) <= bs) {\n\t\tmemcpy(odds + ctx->len, p, len);\n\t\tctx->len += len;\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(odds + ctx->len, p, bs - ctx->len);\n\tlen -= bs - ctx->len;\n\tp += bs - ctx->len;\n\n\tcrypto_xor(prev, odds, bs);\n\tcrypto_cipher_encrypt_one(tfm, prev, prev);\n\n\t \n\tctx->len = 0;\n\n\t \n\twhile (len > bs) {\n\t\tcrypto_xor(prev, p, bs);\n\t\tcrypto_cipher_encrypt_one(tfm, prev, prev);\n\t\tp += bs;\n\t\tlen -= bs;\n\t}\n\n\t \n\tif (len) {\n\t\tmemcpy(odds, p, len);\n\t\tctx->len = len;\n\t}\n\n\treturn 0;\n}\n\nstatic int crypto_xcbc_digest_final(struct shash_desc *pdesc, u8 *out)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tunsigned long alignmask = crypto_shash_alignmask(parent);\n\tstruct xcbc_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct xcbc_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_blocksize(parent);\n\tu8 *consts = PTR_ALIGN(&tctx->ctx[0], alignmask + 1);\n\tu8 *odds = PTR_ALIGN(&ctx->ctx[0], alignmask + 1);\n\tu8 *prev = odds + bs;\n\tunsigned int offset = 0;\n\n\tif (ctx->len != bs) {\n\t\tunsigned int rlen;\n\t\tu8 *p = odds + ctx->len;\n\n\t\t*p = 0x80;\n\t\tp++;\n\n\t\trlen = bs - ctx->len -1;\n\t\tif (rlen)\n\t\t\tmemset(p, 0, rlen);\n\n\t\toffset += bs;\n\t}\n\n\tcrypto_xor(prev, odds, bs);\n\tcrypto_xor(prev, consts + offset, bs);\n\n\tcrypto_cipher_encrypt_one(tfm, out, prev);\n\n\treturn 0;\n}\n\nstatic int xcbc_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_cipher *cipher;\n\tstruct crypto_instance *inst = (void *)tfm->__crt_alg;\n\tstruct crypto_cipher_spawn *spawn = crypto_instance_ctx(inst);\n\tstruct xcbc_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tcipher = crypto_spawn_cipher(spawn);\n\tif (IS_ERR(cipher))\n\t\treturn PTR_ERR(cipher);\n\n\tctx->child = cipher;\n\n\treturn 0;\n};\n\nstatic void xcbc_exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct xcbc_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\tcrypto_free_cipher(ctx->child);\n}\n\nstatic int xcbc_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_cipher_spawn *spawn;\n\tstruct crypto_alg *alg;\n\tunsigned long alignmask;\n\tu32 mask;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH, &mask);\n\tif (err)\n\t\treturn err;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tspawn = shash_instance_ctx(inst);\n\n\terr = crypto_grab_cipher(spawn, shash_crypto_instance(inst),\n\t\t\t\t crypto_attr_alg_name(tb[1]), 0, mask);\n\tif (err)\n\t\tgoto err_free_inst;\n\talg = crypto_spawn_cipher_alg(spawn);\n\n\terr = -EINVAL;\n\tif (alg->cra_blocksize != XCBC_BLOCKSIZE)\n\t\tgoto err_free_inst;\n\n\terr = crypto_inst_setname(shash_crypto_instance(inst), tmpl->name, alg);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\talignmask = alg->cra_alignmask | 3;\n\tinst->alg.base.cra_alignmask = alignmask;\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = alg->cra_blocksize;\n\n\tinst->alg.digestsize = alg->cra_blocksize;\n\tinst->alg.descsize = ALIGN(sizeof(struct xcbc_desc_ctx),\n\t\t\t\t   crypto_tfm_ctx_alignment()) +\n\t\t\t     (alignmask &\n\t\t\t      ~(crypto_tfm_ctx_alignment() - 1)) +\n\t\t\t     alg->cra_blocksize * 2;\n\n\tinst->alg.base.cra_ctxsize = ALIGN(sizeof(struct xcbc_tfm_ctx),\n\t\t\t\t\t   alignmask + 1) +\n\t\t\t\t     alg->cra_blocksize * 2;\n\tinst->alg.base.cra_init = xcbc_init_tfm;\n\tinst->alg.base.cra_exit = xcbc_exit_tfm;\n\n\tinst->alg.init = crypto_xcbc_digest_init;\n\tinst->alg.update = crypto_xcbc_digest_update;\n\tinst->alg.final = crypto_xcbc_digest_final;\n\tinst->alg.setkey = crypto_xcbc_digest_setkey;\n\n\tinst->free = shash_free_singlespawn_instance;\n\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nerr_free_inst:\n\t\tshash_free_singlespawn_instance(inst);\n\t}\n\treturn err;\n}\n\nstatic struct crypto_template crypto_xcbc_tmpl = {\n\t.name = \"xcbc\",\n\t.create = xcbc_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_xcbc_module_init(void)\n{\n\treturn crypto_register_template(&crypto_xcbc_tmpl);\n}\n\nstatic void __exit crypto_xcbc_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_xcbc_tmpl);\n}\n\nsubsys_initcall(crypto_xcbc_module_init);\nmodule_exit(crypto_xcbc_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"XCBC keyed hash algorithm\");\nMODULE_ALIAS_CRYPTO(\"xcbc\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}