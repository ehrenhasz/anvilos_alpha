{
  "module_name": "ecrdsa.c",
  "hash_id": "9aaff8d4bdc076092aa8d24329c8d4fa92e8dcc879275d9b3eae4b3661048ed0",
  "original_prompt": "Ingested from linux-6.6.14/crypto/ecrdsa.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <crypto/streebog.h>\n#include <crypto/internal/akcipher.h>\n#include <crypto/internal/ecc.h>\n#include <crypto/akcipher.h>\n#include <linux/oid_registry.h>\n#include <linux/scatterlist.h>\n#include \"ecrdsa_params.asn1.h\"\n#include \"ecrdsa_pub_key.asn1.h\"\n#include \"ecrdsa_defs.h\"\n\n#define ECRDSA_MAX_SIG_SIZE (2 * 512 / 8)\n#define ECRDSA_MAX_DIGITS (512 / 64)\n\nstruct ecrdsa_ctx {\n\tenum OID algo_oid;  \n\tenum OID curve_oid;  \n\tenum OID digest_oid;  \n\tconst struct ecc_curve *curve;  \n\tunsigned int digest_len;  \n\tconst char *digest;  \n\tunsigned int key_len;  \n\tconst char *key;  \n\tstruct ecc_point pub_key;\n\tu64 _pubp[2][ECRDSA_MAX_DIGITS];  \n};\n\nstatic const struct ecc_curve *get_curve_by_oid(enum OID oid)\n{\n\tswitch (oid) {\n\tcase OID_gostCPSignA:\n\tcase OID_gostTC26Sign256B:\n\t\treturn &gost_cp256a;\n\tcase OID_gostCPSignB:\n\tcase OID_gostTC26Sign256C:\n\t\treturn &gost_cp256b;\n\tcase OID_gostCPSignC:\n\tcase OID_gostTC26Sign256D:\n\t\treturn &gost_cp256c;\n\tcase OID_gostTC26Sign512A:\n\t\treturn &gost_tc512a;\n\tcase OID_gostTC26Sign512B:\n\t\treturn &gost_tc512b;\n\t \n\tcase OID_gostTC26Sign256A:\n\tcase OID_gostTC26Sign512C:\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int ecrdsa_verify(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct ecrdsa_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tunsigned char sig[ECRDSA_MAX_SIG_SIZE];\n\tunsigned char digest[STREEBOG512_DIGEST_SIZE];\n\tunsigned int ndigits = req->dst_len / sizeof(u64);\n\tu64 r[ECRDSA_MAX_DIGITS];  \n\tu64 _r[ECRDSA_MAX_DIGITS];  \n\tu64 s[ECRDSA_MAX_DIGITS];  \n\tu64 e[ECRDSA_MAX_DIGITS];  \n\tu64 *v = e;\t\t   \n\tu64 z1[ECRDSA_MAX_DIGITS];\n\tu64 *z2 = _r;\n\tstruct ecc_point cc = ECC_POINT_INIT(s, e, ndigits);  \n\n\t \n\tif (!ctx->curve ||\n\t    !ctx->digest ||\n\t    !req->src ||\n\t    !ctx->pub_key.x ||\n\t    req->dst_len != ctx->digest_len ||\n\t    req->dst_len != ctx->curve->g.ndigits * sizeof(u64) ||\n\t    ctx->pub_key.ndigits != ctx->curve->g.ndigits ||\n\t    req->dst_len * 2 != req->src_len ||\n\t    WARN_ON(req->src_len > sizeof(sig)) ||\n\t    WARN_ON(req->dst_len > sizeof(digest)))\n\t\treturn -EBADMSG;\n\n\tsg_copy_to_buffer(req->src, sg_nents_for_len(req->src, req->src_len),\n\t\t\t  sig, req->src_len);\n\tsg_pcopy_to_buffer(req->src,\n\t\t\t   sg_nents_for_len(req->src,\n\t\t\t\t\t    req->src_len + req->dst_len),\n\t\t\t   digest, req->dst_len, req->src_len);\n\n\tvli_from_be64(s, sig, ndigits);\n\tvli_from_be64(r, sig + ndigits * sizeof(u64), ndigits);\n\n\t \n\tif (vli_is_zero(r, ndigits) ||\n\t    vli_cmp(r, ctx->curve->n, ndigits) >= 0 ||\n\t    vli_is_zero(s, ndigits) ||\n\t    vli_cmp(s, ctx->curve->n, ndigits) >= 0)\n\t\treturn -EKEYREJECTED;\n\n\t \n\t \n\tvli_from_le64(e, digest, ndigits);\n\tif (vli_cmp(e, ctx->curve->n, ndigits) >= 0)\n\t\tvli_sub(e, e, ctx->curve->n, ndigits);\n\tif (vli_is_zero(e, ndigits))\n\t\te[0] = 1;\n\n\t \n\tvli_mod_inv(v, e, ctx->curve->n, ndigits);\n\n\t \n\tvli_mod_mult_slow(z1, s, v, ctx->curve->n, ndigits);\n\tvli_sub(_r, ctx->curve->n, r, ndigits);\n\tvli_mod_mult_slow(z2, _r, v, ctx->curve->n, ndigits);\n\n\t \n\tecc_point_mult_shamir(&cc, z1, &ctx->curve->g, z2, &ctx->pub_key,\n\t\t\t      ctx->curve);\n\tif (vli_cmp(cc.x, ctx->curve->n, ndigits) >= 0)\n\t\tvli_sub(cc.x, cc.x, ctx->curve->n, ndigits);\n\n\t \n\tif (!vli_cmp(cc.x, r, ndigits))\n\t\treturn 0;\n\telse\n\t\treturn -EKEYREJECTED;\n}\n\nint ecrdsa_param_curve(void *context, size_t hdrlen, unsigned char tag,\n\t\t       const void *value, size_t vlen)\n{\n\tstruct ecrdsa_ctx *ctx = context;\n\n\tctx->curve_oid = look_up_OID(value, vlen);\n\tif (!ctx->curve_oid)\n\t\treturn -EINVAL;\n\tctx->curve = get_curve_by_oid(ctx->curve_oid);\n\treturn 0;\n}\n\n \nint ecrdsa_param_digest(void *context, size_t hdrlen, unsigned char tag,\n\t\t\tconst void *value, size_t vlen)\n{\n\tstruct ecrdsa_ctx *ctx = context;\n\tint digest_oid = look_up_OID(value, vlen);\n\n\tif (digest_oid != ctx->digest_oid)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint ecrdsa_parse_pub_key(void *context, size_t hdrlen, unsigned char tag,\n\t\t\t const void *value, size_t vlen)\n{\n\tstruct ecrdsa_ctx *ctx = context;\n\n\tctx->key = value;\n\tctx->key_len = vlen;\n\treturn 0;\n}\n\nstatic u8 *ecrdsa_unpack_u32(u32 *dst, void *src)\n{\n\tmemcpy(dst, src, sizeof(u32));\n\treturn src + sizeof(u32);\n}\n\n \nstatic int ecrdsa_set_pub_key(struct crypto_akcipher *tfm, const void *key,\n\t\t\t      unsigned int keylen)\n{\n\tstruct ecrdsa_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tunsigned int ndigits;\n\tu32 algo, paramlen;\n\tu8 *params;\n\tint err;\n\n\terr = asn1_ber_decoder(&ecrdsa_pub_key_decoder, ctx, key, keylen);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tparams = ecrdsa_unpack_u32(&paramlen,\n\t\t\t  ecrdsa_unpack_u32(&algo, (u8 *)key + keylen));\n\n\tif (algo == OID_gost2012PKey256) {\n\t\tctx->digest\t= \"streebog256\";\n\t\tctx->digest_oid\t= OID_gost2012Digest256;\n\t\tctx->digest_len\t= 256 / 8;\n\t} else if (algo == OID_gost2012PKey512) {\n\t\tctx->digest\t= \"streebog512\";\n\t\tctx->digest_oid\t= OID_gost2012Digest512;\n\t\tctx->digest_len\t= 512 / 8;\n\t} else\n\t\treturn -ENOPKG;\n\tctx->algo_oid = algo;\n\n\t \n\terr = asn1_ber_decoder(&ecrdsa_params_decoder, ctx, params, paramlen);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (!ctx->curve ||\n\t    ctx->curve->g.ndigits * sizeof(u64) != ctx->digest_len)\n\t\treturn -ENOPKG;\n\t \n\tif ((ctx->key_len != (2 * 256 / 8) &&\n\t     ctx->key_len != (2 * 512 / 8)) ||\n\t    ctx->key_len != ctx->curve->g.ndigits * sizeof(u64) * 2)\n\t\treturn -ENOPKG;\n\n\tndigits = ctx->key_len / sizeof(u64) / 2;\n\tctx->pub_key = ECC_POINT_INIT(ctx->_pubp[0], ctx->_pubp[1], ndigits);\n\tvli_from_le64(ctx->pub_key.x, ctx->key, ndigits);\n\tvli_from_le64(ctx->pub_key.y, ctx->key + ndigits * sizeof(u64),\n\t\t      ndigits);\n\n\tif (ecc_is_pubkey_valid_partial(ctx->curve, &ctx->pub_key))\n\t\treturn -EKEYREJECTED;\n\n\treturn 0;\n}\n\nstatic unsigned int ecrdsa_max_size(struct crypto_akcipher *tfm)\n{\n\tstruct ecrdsa_ctx *ctx = akcipher_tfm_ctx(tfm);\n\n\t \n\treturn ctx->pub_key.ndigits * sizeof(u64);\n}\n\nstatic void ecrdsa_exit_tfm(struct crypto_akcipher *tfm)\n{\n}\n\nstatic struct akcipher_alg ecrdsa_alg = {\n\t.verify\t\t= ecrdsa_verify,\n\t.set_pub_key\t= ecrdsa_set_pub_key,\n\t.max_size\t= ecrdsa_max_size,\n\t.exit\t\t= ecrdsa_exit_tfm,\n\t.base = {\n\t\t.cra_name\t = \"ecrdsa\",\n\t\t.cra_driver_name = \"ecrdsa-generic\",\n\t\t.cra_priority\t = 100,\n\t\t.cra_module\t = THIS_MODULE,\n\t\t.cra_ctxsize\t = sizeof(struct ecrdsa_ctx),\n\t},\n};\n\nstatic int __init ecrdsa_mod_init(void)\n{\n\treturn crypto_register_akcipher(&ecrdsa_alg);\n}\n\nstatic void __exit ecrdsa_mod_fini(void)\n{\n\tcrypto_unregister_akcipher(&ecrdsa_alg);\n}\n\nmodule_init(ecrdsa_mod_init);\nmodule_exit(ecrdsa_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Vitaly Chikunov <vt@altlinux.org>\");\nMODULE_DESCRIPTION(\"EC-RDSA generic algorithm\");\nMODULE_ALIAS_CRYPTO(\"ecrdsa-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}