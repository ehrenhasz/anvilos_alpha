{
  "module_name": "jitterentropy-kcapi.c",
  "hash_id": "01e6d4604918da79fa4b8071d6e4582a66406295ec50a7158cef56f7a93853bc",
  "original_prompt": "Ingested from linux-6.6.14/crypto/jitterentropy-kcapi.c",
  "human_readable_source": " \n\n#include <crypto/hash.h>\n#include <crypto/sha3.h>\n#include <linux/fips.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <crypto/internal/rng.h>\n\n#include \"jitterentropy.h\"\n\n#define JENT_CONDITIONING_HASH\t\"sha3-256-generic\"\n\n \n\nvoid *jent_zalloc(unsigned int len)\n{\n\treturn kzalloc(len, GFP_KERNEL);\n}\n\nvoid jent_zfree(void *ptr)\n{\n\tkfree_sensitive(ptr);\n}\n\n \nvoid jent_get_nstime(__u64 *out)\n{\n\t__u64 tmp = 0;\n\n\ttmp = random_get_entropy();\n\n\t \n\tif (tmp == 0)\n\t\ttmp = ktime_get_ns();\n\n\t*out = tmp;\n\tjent_raw_hires_entropy_store(tmp);\n}\n\nint jent_hash_time(void *hash_state, __u64 time, u8 *addtl,\n\t\t   unsigned int addtl_len, __u64 hash_loop_cnt,\n\t\t   unsigned int stuck)\n{\n\tstruct shash_desc *hash_state_desc = (struct shash_desc *)hash_state;\n\tSHASH_DESC_ON_STACK(desc, hash_state_desc->tfm);\n\tu8 intermediary[SHA3_256_DIGEST_SIZE];\n\t__u64 j = 0;\n\tint ret;\n\n\tdesc->tfm = hash_state_desc->tfm;\n\n\tif (sizeof(intermediary) != crypto_shash_digestsize(desc->tfm)) {\n\t\tpr_warn_ratelimited(\"Unexpected digest size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (j = 0; j < hash_loop_cnt; j++) {\n\t\tret = crypto_shash_init(desc) ?:\n\t\t      crypto_shash_update(desc, intermediary,\n\t\t\t\t\t  sizeof(intermediary)) ?:\n\t\t      crypto_shash_finup(desc, addtl, addtl_len, intermediary);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tret = crypto_shash_update(desc, intermediary, sizeof(intermediary));\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (!stuck) {\n\t\tret = crypto_shash_update(hash_state_desc, (u8 *)&time,\n\t\t\t\t\t  sizeof(__u64));\n\t}\n\nerr:\n\tshash_desc_zero(desc);\n\tmemzero_explicit(intermediary, sizeof(intermediary));\n\n\treturn ret;\n}\n\nint jent_read_random_block(void *hash_state, char *dst, unsigned int dst_len)\n{\n\tstruct shash_desc *hash_state_desc = (struct shash_desc *)hash_state;\n\tu8 jent_block[SHA3_256_DIGEST_SIZE];\n\t \n\tint ret = crypto_shash_final(hash_state_desc, jent_block) ?:\n\t\t  crypto_shash_init(hash_state_desc) ?:\n\t\t  crypto_shash_update(hash_state_desc, jent_block,\n\t\t\t\t      sizeof(jent_block));\n\n\tif (!ret && dst_len)\n\t\tmemcpy(dst, jent_block, dst_len);\n\n\tmemzero_explicit(jent_block, sizeof(jent_block));\n\treturn ret;\n}\n\n \n\nstruct jitterentropy {\n\tspinlock_t jent_lock;\n\tstruct rand_data *entropy_collector;\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *sdesc;\n};\n\nstatic void jent_kcapi_cleanup(struct crypto_tfm *tfm)\n{\n\tstruct jitterentropy *rng = crypto_tfm_ctx(tfm);\n\n\tspin_lock(&rng->jent_lock);\n\n\tif (rng->sdesc) {\n\t\tshash_desc_zero(rng->sdesc);\n\t\tkfree(rng->sdesc);\n\t}\n\trng->sdesc = NULL;\n\n\tif (rng->tfm)\n\t\tcrypto_free_shash(rng->tfm);\n\trng->tfm = NULL;\n\n\tif (rng->entropy_collector)\n\t\tjent_entropy_collector_free(rng->entropy_collector);\n\trng->entropy_collector = NULL;\n\tspin_unlock(&rng->jent_lock);\n}\n\nstatic int jent_kcapi_init(struct crypto_tfm *tfm)\n{\n\tstruct jitterentropy *rng = crypto_tfm_ctx(tfm);\n\tstruct crypto_shash *hash;\n\tstruct shash_desc *sdesc;\n\tint size, ret = 0;\n\n\tspin_lock_init(&rng->jent_lock);\n\n\t \n\thash = crypto_alloc_shash(JENT_CONDITIONING_HASH, 0, 0);\n\tif (IS_ERR(hash)) {\n\t\tpr_err(\"Cannot allocate conditioning digest\\n\");\n\t\treturn PTR_ERR(hash);\n\t}\n\trng->tfm = hash;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(hash);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tsdesc->tfm = hash;\n\tcrypto_shash_init(sdesc);\n\trng->sdesc = sdesc;\n\n\trng->entropy_collector = jent_entropy_collector_alloc(1, 0, sdesc);\n\tif (!rng->entropy_collector) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tspin_lock_init(&rng->jent_lock);\n\treturn 0;\n\nerr:\n\tjent_kcapi_cleanup(tfm);\n\treturn ret;\n}\n\nstatic int jent_kcapi_random(struct crypto_rng *tfm,\n\t\t\t     const u8 *src, unsigned int slen,\n\t\t\t     u8 *rdata, unsigned int dlen)\n{\n\tstruct jitterentropy *rng = crypto_rng_ctx(tfm);\n\tint ret = 0;\n\n\tspin_lock(&rng->jent_lock);\n\n\tret = jent_read_entropy(rng->entropy_collector, rdata, dlen);\n\n\tif (ret == -3) {\n\t\t \n\t\t \n\t\tif (fips_enabled)\n\t\t\tpanic(\"Jitter RNG permanent health test failure\\n\");\n\n\t\tpr_err(\"Jitter RNG permanent health test failure\\n\");\n\t\tret = -EFAULT;\n\t} else if (ret == -2) {\n\t\t \n\t\tpr_warn_ratelimited(\"Reset Jitter RNG due to intermittent health test failure\\n\");\n\t\tret = -EAGAIN;\n\t} else if (ret == -1) {\n\t\t \n\t\tret = -EINVAL;\n\t}\n\n\tspin_unlock(&rng->jent_lock);\n\n\treturn ret;\n}\n\nstatic int jent_kcapi_reset(struct crypto_rng *tfm,\n\t\t\t    const u8 *seed, unsigned int slen)\n{\n\treturn 0;\n}\n\nstatic struct rng_alg jent_alg = {\n\t.generate\t\t= jent_kcapi_random,\n\t.seed\t\t\t= jent_kcapi_reset,\n\t.seedsize\t\t= 0,\n\t.base\t\t\t= {\n\t\t.cra_name               = \"jitterentropy_rng\",\n\t\t.cra_driver_name        = \"jitterentropy_rng\",\n\t\t.cra_priority           = 100,\n\t\t.cra_ctxsize            = sizeof(struct jitterentropy),\n\t\t.cra_module             = THIS_MODULE,\n\t\t.cra_init               = jent_kcapi_init,\n\t\t.cra_exit               = jent_kcapi_cleanup,\n\t}\n};\n\nstatic int __init jent_mod_init(void)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tstruct crypto_shash *tfm;\n\tint ret = 0;\n\n\tjent_testing_init();\n\n\ttfm = crypto_alloc_shash(JENT_CONDITIONING_HASH, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tjent_testing_exit();\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\tdesc->tfm = tfm;\n\tcrypto_shash_init(desc);\n\tret = jent_entropy_init(desc);\n\tshash_desc_zero(desc);\n\tcrypto_free_shash(tfm);\n\tif (ret) {\n\t\t \n\t\tif (fips_enabled)\n\t\t\tpanic(\"jitterentropy: Initialization failed with host not compliant with requirements: %d\\n\", ret);\n\n\t\tjent_testing_exit();\n\t\tpr_info(\"jitterentropy: Initialization failed with host not compliant with requirements: %d\\n\", ret);\n\t\treturn -EFAULT;\n\t}\n\treturn crypto_register_rng(&jent_alg);\n}\n\nstatic void __exit jent_mod_exit(void)\n{\n\tjent_testing_exit();\n\tcrypto_unregister_rng(&jent_alg);\n}\n\nmodule_init(jent_mod_init);\nmodule_exit(jent_mod_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Stephan Mueller <smueller@chronox.de>\");\nMODULE_DESCRIPTION(\"Non-physical True Random Number Generator based on CPU Jitter\");\nMODULE_ALIAS_CRYPTO(\"jitterentropy_rng\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}