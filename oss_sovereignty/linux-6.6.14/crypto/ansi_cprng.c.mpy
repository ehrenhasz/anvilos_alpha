{
  "module_name": "ansi_cprng.c",
  "hash_id": "b22de7a4ccea877d943ef08529bef61e613dba90a757eb1889a779fd1e315cf5",
  "original_prompt": "Ingested from linux-6.6.14/crypto/ansi_cprng.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/rng.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n\n#define DEFAULT_PRNG_KEY \"0123456789abcdef\"\n#define DEFAULT_PRNG_KSZ 16\n#define DEFAULT_BLK_SZ 16\n#define DEFAULT_V_SEED \"zaybxcwdveuftgsh\"\n\n \n\n#define PRNG_FIXED_SIZE 0x1\n#define PRNG_NEED_RESET 0x2\n\n \n\n\nstruct prng_context {\n\tspinlock_t prng_lock;\n\tunsigned char rand_data[DEFAULT_BLK_SZ];\n\tunsigned char last_rand_data[DEFAULT_BLK_SZ];\n\tunsigned char DT[DEFAULT_BLK_SZ];\n\tunsigned char I[DEFAULT_BLK_SZ];\n\tunsigned char V[DEFAULT_BLK_SZ];\n\tu32 rand_data_valid;\n\tstruct crypto_cipher *tfm;\n\tu32 flags;\n};\n\nstatic int dbg;\n\nstatic void hexdump(char *note, unsigned char *buf, unsigned int len)\n{\n\tif (dbg) {\n\t\tprintk(KERN_CRIT \"%s\", note);\n\t\tprint_hex_dump(KERN_CONT, \"\", DUMP_PREFIX_OFFSET,\n\t\t\t\t16, 1,\n\t\t\t\tbuf, len, false);\n\t}\n}\n\n#define dbgprint(format, args...) do {\\\nif (dbg)\\\n\tprintk(format, ##args);\\\n} while (0)\n\nstatic void xor_vectors(unsigned char *in1, unsigned char *in2,\n\t\t\tunsigned char *out, unsigned int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tout[i] = in1[i] ^ in2[i];\n\n}\n \nstatic int _get_more_prng_bytes(struct prng_context *ctx, int cont_test)\n{\n\tint i;\n\tunsigned char tmp[DEFAULT_BLK_SZ];\n\tunsigned char *output = NULL;\n\n\n\tdbgprint(KERN_CRIT \"Calling _get_more_prng_bytes for context %p\\n\",\n\t\tctx);\n\n\thexdump(\"Input DT: \", ctx->DT, DEFAULT_BLK_SZ);\n\thexdump(\"Input I: \", ctx->I, DEFAULT_BLK_SZ);\n\thexdump(\"Input V: \", ctx->V, DEFAULT_BLK_SZ);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\t \n\t\t\tmemcpy(tmp, ctx->DT, DEFAULT_BLK_SZ);\n\t\t\toutput = ctx->I;\n\t\t\thexdump(\"tmp stage 0: \", tmp, DEFAULT_BLK_SZ);\n\t\t\tbreak;\n\t\tcase 1:\n\n\t\t\t \n\t\t\txor_vectors(ctx->I, ctx->V, tmp, DEFAULT_BLK_SZ);\n\t\t\thexdump(\"tmp stage 1: \", tmp, DEFAULT_BLK_SZ);\n\t\t\toutput = ctx->rand_data;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tif (!memcmp(ctx->rand_data, ctx->last_rand_data,\n\t\t\t\t\tDEFAULT_BLK_SZ)) {\n\t\t\t\tif (cont_test) {\n\t\t\t\t\tpanic(\"cprng %p Failed repetition check!\\n\",\n\t\t\t\t\t\tctx);\n\t\t\t\t}\n\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\"ctx %p Failed repetition check!\\n\",\n\t\t\t\t\tctx);\n\n\t\t\t\tctx->flags |= PRNG_NEED_RESET;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmemcpy(ctx->last_rand_data, ctx->rand_data,\n\t\t\t\tDEFAULT_BLK_SZ);\n\n\t\t\t \n\t\t\txor_vectors(ctx->rand_data, ctx->I, tmp,\n\t\t\t\tDEFAULT_BLK_SZ);\n\t\t\toutput = ctx->V;\n\t\t\thexdump(\"tmp stage 2: \", tmp, DEFAULT_BLK_SZ);\n\t\t\tbreak;\n\t\t}\n\n\n\t\t \n\t\tcrypto_cipher_encrypt_one(ctx->tfm, output, tmp);\n\n\t}\n\n\t \n\tfor (i = DEFAULT_BLK_SZ - 1; i >= 0; i--) {\n\t\tctx->DT[i] += 1;\n\t\tif (ctx->DT[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tdbgprint(\"Returning new block for context %p\\n\", ctx);\n\tctx->rand_data_valid = 0;\n\n\thexdump(\"Output DT: \", ctx->DT, DEFAULT_BLK_SZ);\n\thexdump(\"Output I: \", ctx->I, DEFAULT_BLK_SZ);\n\thexdump(\"Output V: \", ctx->V, DEFAULT_BLK_SZ);\n\thexdump(\"New Random Data: \", ctx->rand_data, DEFAULT_BLK_SZ);\n\n\treturn 0;\n}\n\n \nstatic int get_prng_bytes(char *buf, size_t nbytes, struct prng_context *ctx,\n\t\t\t\tint do_cont_test)\n{\n\tunsigned char *ptr = buf;\n\tunsigned int byte_count = (unsigned int)nbytes;\n\tint err;\n\n\n\tspin_lock_bh(&ctx->prng_lock);\n\n\terr = -EINVAL;\n\tif (ctx->flags & PRNG_NEED_RESET)\n\t\tgoto done;\n\n\t \n\terr = -EINVAL;\n\tif (ctx->flags & PRNG_FIXED_SIZE) {\n\t\tif (nbytes < DEFAULT_BLK_SZ)\n\t\t\tgoto done;\n\t\tbyte_count = DEFAULT_BLK_SZ;\n\t}\n\n\t \n\terr = 0;\n\n\tdbgprint(KERN_CRIT \"getting %d random bytes for context %p\\n\",\n\t\tbyte_count, ctx);\n\n\nremainder:\n\tif (ctx->rand_data_valid == DEFAULT_BLK_SZ) {\n\t\tif (_get_more_prng_bytes(ctx, do_cont_test) < 0) {\n\t\t\tmemset(buf, 0, nbytes);\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (byte_count < DEFAULT_BLK_SZ) {\nempty_rbuf:\n\t\twhile (ctx->rand_data_valid < DEFAULT_BLK_SZ) {\n\t\t\t*ptr = ctx->rand_data[ctx->rand_data_valid];\n\t\t\tptr++;\n\t\t\tbyte_count--;\n\t\t\tctx->rand_data_valid++;\n\t\t\tif (byte_count == 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tfor (; byte_count >= DEFAULT_BLK_SZ; byte_count -= DEFAULT_BLK_SZ) {\n\t\tif (ctx->rand_data_valid == DEFAULT_BLK_SZ) {\n\t\t\tif (_get_more_prng_bytes(ctx, do_cont_test) < 0) {\n\t\t\t\tmemset(buf, 0, nbytes);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tif (ctx->rand_data_valid > 0)\n\t\t\tgoto empty_rbuf;\n\t\tmemcpy(ptr, ctx->rand_data, DEFAULT_BLK_SZ);\n\t\tctx->rand_data_valid += DEFAULT_BLK_SZ;\n\t\tptr += DEFAULT_BLK_SZ;\n\t}\n\n\t \n\tif (byte_count)\n\t\tgoto remainder;\n\ndone:\n\tspin_unlock_bh(&ctx->prng_lock);\n\tdbgprint(KERN_CRIT \"returning %d from get_prng_bytes in context %p\\n\",\n\t\terr, ctx);\n\treturn err;\n}\n\nstatic void free_prng_context(struct prng_context *ctx)\n{\n\tcrypto_free_cipher(ctx->tfm);\n}\n\nstatic int reset_prng_context(struct prng_context *ctx,\n\t\t\t      const unsigned char *key, size_t klen,\n\t\t\t      const unsigned char *V, const unsigned char *DT)\n{\n\tint ret;\n\tconst unsigned char *prng_key;\n\n\tspin_lock_bh(&ctx->prng_lock);\n\tctx->flags |= PRNG_NEED_RESET;\n\n\tprng_key = (key != NULL) ? key : (unsigned char *)DEFAULT_PRNG_KEY;\n\n\tif (!key)\n\t\tklen = DEFAULT_PRNG_KSZ;\n\n\tif (V)\n\t\tmemcpy(ctx->V, V, DEFAULT_BLK_SZ);\n\telse\n\t\tmemcpy(ctx->V, DEFAULT_V_SEED, DEFAULT_BLK_SZ);\n\n\tif (DT)\n\t\tmemcpy(ctx->DT, DT, DEFAULT_BLK_SZ);\n\telse\n\t\tmemset(ctx->DT, 0, DEFAULT_BLK_SZ);\n\n\tmemset(ctx->rand_data, 0, DEFAULT_BLK_SZ);\n\tmemset(ctx->last_rand_data, 0, DEFAULT_BLK_SZ);\n\n\tctx->rand_data_valid = DEFAULT_BLK_SZ;\n\n\tret = crypto_cipher_setkey(ctx->tfm, prng_key, klen);\n\tif (ret) {\n\t\tdbgprint(KERN_CRIT \"PRNG: setkey() failed flags=%x\\n\",\n\t\t\tcrypto_cipher_get_flags(ctx->tfm));\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tctx->flags &= ~PRNG_NEED_RESET;\nout:\n\tspin_unlock_bh(&ctx->prng_lock);\n\treturn ret;\n}\n\nstatic int cprng_init(struct crypto_tfm *tfm)\n{\n\tstruct prng_context *ctx = crypto_tfm_ctx(tfm);\n\n\tspin_lock_init(&ctx->prng_lock);\n\tctx->tfm = crypto_alloc_cipher(\"aes\", 0, 0);\n\tif (IS_ERR(ctx->tfm)) {\n\t\tdbgprint(KERN_CRIT \"Failed to alloc tfm for context %p\\n\",\n\t\t\t\tctx);\n\t\treturn PTR_ERR(ctx->tfm);\n\t}\n\n\tif (reset_prng_context(ctx, NULL, DEFAULT_PRNG_KSZ, NULL, NULL) < 0)\n\t\treturn -EINVAL;\n\n\t \n\tctx->flags |= PRNG_NEED_RESET;\n\treturn 0;\n}\n\nstatic void cprng_exit(struct crypto_tfm *tfm)\n{\n\tfree_prng_context(crypto_tfm_ctx(tfm));\n}\n\nstatic int cprng_get_random(struct crypto_rng *tfm,\n\t\t\t    const u8 *src, unsigned int slen,\n\t\t\t    u8 *rdata, unsigned int dlen)\n{\n\tstruct prng_context *prng = crypto_rng_ctx(tfm);\n\n\treturn get_prng_bytes(rdata, dlen, prng, 0);\n}\n\n \nstatic int cprng_reset(struct crypto_rng *tfm,\n\t\t       const u8 *seed, unsigned int slen)\n{\n\tstruct prng_context *prng = crypto_rng_ctx(tfm);\n\tconst u8 *key = seed + DEFAULT_BLK_SZ;\n\tconst u8 *dt = NULL;\n\n\tif (slen < DEFAULT_PRNG_KSZ + DEFAULT_BLK_SZ)\n\t\treturn -EINVAL;\n\n\tif (slen >= (2 * DEFAULT_BLK_SZ + DEFAULT_PRNG_KSZ))\n\t\tdt = key + DEFAULT_PRNG_KSZ;\n\n\treset_prng_context(prng, key, DEFAULT_PRNG_KSZ, seed, dt);\n\n\tif (prng->flags & PRNG_NEED_RESET)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n#ifdef CONFIG_CRYPTO_FIPS\nstatic int fips_cprng_get_random(struct crypto_rng *tfm,\n\t\t\t\t const u8 *src, unsigned int slen,\n\t\t\t\t u8 *rdata, unsigned int dlen)\n{\n\tstruct prng_context *prng = crypto_rng_ctx(tfm);\n\n\treturn get_prng_bytes(rdata, dlen, prng, 1);\n}\n\nstatic int fips_cprng_reset(struct crypto_rng *tfm,\n\t\t\t    const u8 *seed, unsigned int slen)\n{\n\tu8 rdata[DEFAULT_BLK_SZ];\n\tconst u8 *key = seed + DEFAULT_BLK_SZ;\n\tint rc;\n\n\tstruct prng_context *prng = crypto_rng_ctx(tfm);\n\n\tif (slen < DEFAULT_PRNG_KSZ + DEFAULT_BLK_SZ)\n\t\treturn -EINVAL;\n\n\t \n\tif (!memcmp(seed, key, DEFAULT_PRNG_KSZ))\n\t\treturn -EINVAL;\n\n\trc = cprng_reset(tfm, seed, slen);\n\n\tif (!rc)\n\t\tgoto out;\n\n\t \n\trc = get_prng_bytes(rdata, DEFAULT_BLK_SZ, prng, 0);\n\tprng->rand_data_valid = DEFAULT_BLK_SZ;\n\nout:\n\treturn rc;\n}\n#endif\n\nstatic struct rng_alg rng_algs[] = { {\n\t.generate\t\t= cprng_get_random,\n\t.seed\t\t\t= cprng_reset,\n\t.seedsize\t\t= DEFAULT_PRNG_KSZ + 2 * DEFAULT_BLK_SZ,\n\t.base\t\t\t=\t{\n\t\t.cra_name\t\t= \"stdrng\",\n\t\t.cra_driver_name\t= \"ansi_cprng\",\n\t\t.cra_priority\t\t= 100,\n\t\t.cra_ctxsize\t\t= sizeof(struct prng_context),\n\t\t.cra_module\t\t= THIS_MODULE,\n\t\t.cra_init\t\t= cprng_init,\n\t\t.cra_exit\t\t= cprng_exit,\n\t}\n#ifdef CONFIG_CRYPTO_FIPS\n}, {\n\t.generate\t\t= fips_cprng_get_random,\n\t.seed\t\t\t= fips_cprng_reset,\n\t.seedsize\t\t= DEFAULT_PRNG_KSZ + 2 * DEFAULT_BLK_SZ,\n\t.base\t\t\t=\t{\n\t\t.cra_name\t\t= \"fips(ansi_cprng)\",\n\t\t.cra_driver_name\t= \"fips_ansi_cprng\",\n\t\t.cra_priority\t\t= 300,\n\t\t.cra_ctxsize\t\t= sizeof(struct prng_context),\n\t\t.cra_module\t\t= THIS_MODULE,\n\t\t.cra_init\t\t= cprng_init,\n\t\t.cra_exit\t\t= cprng_exit,\n\t}\n#endif\n} };\n\n \nstatic int __init prng_mod_init(void)\n{\n\treturn crypto_register_rngs(rng_algs, ARRAY_SIZE(rng_algs));\n}\n\nstatic void __exit prng_mod_fini(void)\n{\n\tcrypto_unregister_rngs(rng_algs, ARRAY_SIZE(rng_algs));\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Software Pseudo Random Number Generator\");\nMODULE_AUTHOR(\"Neil Horman <nhorman@tuxdriver.com>\");\nmodule_param(dbg, int, 0);\nMODULE_PARM_DESC(dbg, \"Boolean to enable debugging (0/1 == off/on)\");\nsubsys_initcall(prng_mod_init);\nmodule_exit(prng_mod_fini);\nMODULE_ALIAS_CRYPTO(\"stdrng\");\nMODULE_ALIAS_CRYPTO(\"ansi_cprng\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}