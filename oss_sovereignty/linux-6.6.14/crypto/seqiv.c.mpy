{
  "module_name": "seqiv.c",
  "hash_id": "c6e8a278447c06cbd5c4aae9769d611298a93f07c889f475a86253c8d5e6ba5f",
  "original_prompt": "Ingested from linux-6.6.14/crypto/seqiv.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/geniv.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/skcipher.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic void seqiv_aead_encrypt_complete2(struct aead_request *req, int err)\n{\n\tstruct aead_request *subreq = aead_request_ctx(req);\n\tstruct crypto_aead *geniv;\n\n\tif (err == -EINPROGRESS || err == -EBUSY)\n\t\treturn;\n\n\tif (err)\n\t\tgoto out;\n\n\tgeniv = crypto_aead_reqtfm(req);\n\tmemcpy(req->iv, subreq->iv, crypto_aead_ivsize(geniv));\n\nout:\n\tkfree_sensitive(subreq->iv);\n}\n\nstatic void seqiv_aead_encrypt_complete(void *data, int err)\n{\n\tstruct aead_request *req = data;\n\n\tseqiv_aead_encrypt_complete2(req, err);\n\taead_request_complete(req, err);\n}\n\nstatic int seqiv_aead_encrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *geniv = crypto_aead_reqtfm(req);\n\tstruct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);\n\tstruct aead_request *subreq = aead_request_ctx(req);\n\tcrypto_completion_t compl;\n\tvoid *data;\n\tu8 *info;\n\tunsigned int ivsize = 8;\n\tint err;\n\n\tif (req->cryptlen < ivsize)\n\t\treturn -EINVAL;\n\n\taead_request_set_tfm(subreq, ctx->child);\n\n\tcompl = req->base.complete;\n\tdata = req->base.data;\n\tinfo = req->iv;\n\n\tif (req->src != req->dst) {\n\t\tSYNC_SKCIPHER_REQUEST_ON_STACK(nreq, ctx->sknull);\n\n\t\tskcipher_request_set_sync_tfm(nreq, ctx->sknull);\n\t\tskcipher_request_set_callback(nreq, req->base.flags,\n\t\t\t\t\t      NULL, NULL);\n\t\tskcipher_request_set_crypt(nreq, req->src, req->dst,\n\t\t\t\t\t   req->assoclen + req->cryptlen,\n\t\t\t\t\t   NULL);\n\n\t\terr = crypto_skcipher_encrypt(nreq);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (unlikely(!IS_ALIGNED((unsigned long)info,\n\t\t\t\t crypto_aead_alignmask(geniv) + 1))) {\n\t\tinfo = kmemdup(req->iv, ivsize, req->base.flags &\n\t\t\t       CRYPTO_TFM_REQ_MAY_SLEEP ? GFP_KERNEL :\n\t\t\t       GFP_ATOMIC);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\n\t\tcompl = seqiv_aead_encrypt_complete;\n\t\tdata = req;\n\t}\n\n\taead_request_set_callback(subreq, req->base.flags, compl, data);\n\taead_request_set_crypt(subreq, req->dst, req->dst,\n\t\t\t       req->cryptlen - ivsize, info);\n\taead_request_set_ad(subreq, req->assoclen + ivsize);\n\n\tcrypto_xor(info, ctx->salt, ivsize);\n\tscatterwalk_map_and_copy(info, req->dst, req->assoclen, ivsize, 1);\n\n\terr = crypto_aead_encrypt(subreq);\n\tif (unlikely(info != req->iv))\n\t\tseqiv_aead_encrypt_complete2(req, err);\n\treturn err;\n}\n\nstatic int seqiv_aead_decrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *geniv = crypto_aead_reqtfm(req);\n\tstruct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);\n\tstruct aead_request *subreq = aead_request_ctx(req);\n\tcrypto_completion_t compl;\n\tvoid *data;\n\tunsigned int ivsize = 8;\n\n\tif (req->cryptlen < ivsize + crypto_aead_authsize(geniv))\n\t\treturn -EINVAL;\n\n\taead_request_set_tfm(subreq, ctx->child);\n\n\tcompl = req->base.complete;\n\tdata = req->base.data;\n\n\taead_request_set_callback(subreq, req->base.flags, compl, data);\n\taead_request_set_crypt(subreq, req->src, req->dst,\n\t\t\t       req->cryptlen - ivsize, req->iv);\n\taead_request_set_ad(subreq, req->assoclen + ivsize);\n\n\tscatterwalk_map_and_copy(req->iv, req->src, req->assoclen, ivsize, 0);\n\n\treturn crypto_aead_decrypt(subreq);\n}\n\nstatic int seqiv_aead_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct aead_instance *inst;\n\tint err;\n\n\tinst = aead_geniv_alloc(tmpl, tb);\n\n\tif (IS_ERR(inst))\n\t\treturn PTR_ERR(inst);\n\n\terr = -EINVAL;\n\tif (inst->alg.ivsize != sizeof(u64))\n\t\tgoto free_inst;\n\n\tinst->alg.encrypt = seqiv_aead_encrypt;\n\tinst->alg.decrypt = seqiv_aead_decrypt;\n\n\tinst->alg.init = aead_init_geniv;\n\tinst->alg.exit = aead_exit_geniv;\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct aead_geniv_ctx);\n\tinst->alg.base.cra_ctxsize += inst->alg.ivsize;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err) {\nfree_inst:\n\t\tinst->free(inst);\n\t}\n\treturn err;\n}\n\nstatic struct crypto_template seqiv_tmpl = {\n\t.name = \"seqiv\",\n\t.create = seqiv_aead_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init seqiv_module_init(void)\n{\n\treturn crypto_register_template(&seqiv_tmpl);\n}\n\nstatic void __exit seqiv_module_exit(void)\n{\n\tcrypto_unregister_template(&seqiv_tmpl);\n}\n\nsubsys_initcall(seqiv_module_init);\nmodule_exit(seqiv_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Sequence Number IV Generator\");\nMODULE_ALIAS_CRYPTO(\"seqiv\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}