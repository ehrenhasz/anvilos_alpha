{
  "module_name": "api.c",
  "hash_id": "4810855fc34430c27512ee5a1e16a9c48cf910f53235596b7c61b3c664d4eb93",
  "original_prompt": "Ingested from linux-6.6.14/crypto/api.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/jump_label.h>\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/module.h>\n#include <linux/param.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/completion.h>\n#include \"internal.h\"\n\nLIST_HEAD(crypto_alg_list);\nEXPORT_SYMBOL_GPL(crypto_alg_list);\nDECLARE_RWSEM(crypto_alg_sem);\nEXPORT_SYMBOL_GPL(crypto_alg_sem);\n\nBLOCKING_NOTIFIER_HEAD(crypto_chain);\nEXPORT_SYMBOL_GPL(crypto_chain);\n\n#ifndef CONFIG_CRYPTO_MANAGER_DISABLE_TESTS\nDEFINE_STATIC_KEY_FALSE(__crypto_boot_test_finished);\nEXPORT_SYMBOL_GPL(__crypto_boot_test_finished);\n#endif\n\nstatic struct crypto_alg *crypto_larval_wait(struct crypto_alg *alg);\n\nstruct crypto_alg *crypto_mod_get(struct crypto_alg *alg)\n{\n\treturn try_module_get(alg->cra_module) ? crypto_alg_get(alg) : NULL;\n}\nEXPORT_SYMBOL_GPL(crypto_mod_get);\n\nvoid crypto_mod_put(struct crypto_alg *alg)\n{\n\tstruct module *module = alg->cra_module;\n\n\tcrypto_alg_put(alg);\n\tmodule_put(module);\n}\nEXPORT_SYMBOL_GPL(crypto_mod_put);\n\nstatic struct crypto_alg *__crypto_alg_lookup(const char *name, u32 type,\n\t\t\t\t\t      u32 mask)\n{\n\tstruct crypto_alg *q, *alg = NULL;\n\tint best = -2;\n\n\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\tint exact, fuzzy;\n\n\t\tif (crypto_is_moribund(q))\n\t\t\tcontinue;\n\n\t\tif ((q->cra_flags ^ type) & mask)\n\t\t\tcontinue;\n\n\t\tif (crypto_is_larval(q) &&\n\t\t    !crypto_is_test_larval((struct crypto_larval *)q) &&\n\t\t    ((struct crypto_larval *)q)->mask != mask)\n\t\t\tcontinue;\n\n\t\texact = !strcmp(q->cra_driver_name, name);\n\t\tfuzzy = !strcmp(q->cra_name, name);\n\t\tif (!exact && !(fuzzy && q->cra_priority > best))\n\t\t\tcontinue;\n\n\t\tif (unlikely(!crypto_mod_get(q)))\n\t\t\tcontinue;\n\n\t\tbest = q->cra_priority;\n\t\tif (alg)\n\t\t\tcrypto_mod_put(alg);\n\t\talg = q;\n\n\t\tif (exact)\n\t\t\tbreak;\n\t}\n\n\treturn alg;\n}\n\nstatic void crypto_larval_destroy(struct crypto_alg *alg)\n{\n\tstruct crypto_larval *larval = (void *)alg;\n\n\tBUG_ON(!crypto_is_larval(alg));\n\tif (!IS_ERR_OR_NULL(larval->adult))\n\t\tcrypto_mod_put(larval->adult);\n\tkfree(larval);\n}\n\nstruct crypto_larval *crypto_larval_alloc(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_larval *larval;\n\n\tlarval = kzalloc(sizeof(*larval), GFP_KERNEL);\n\tif (!larval)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlarval->mask = mask;\n\tlarval->alg.cra_flags = CRYPTO_ALG_LARVAL | type;\n\tlarval->alg.cra_priority = -1;\n\tlarval->alg.cra_destroy = crypto_larval_destroy;\n\n\tstrscpy(larval->alg.cra_name, name, CRYPTO_MAX_ALG_NAME);\n\tinit_completion(&larval->completion);\n\n\treturn larval;\n}\nEXPORT_SYMBOL_GPL(crypto_larval_alloc);\n\nstatic struct crypto_alg *crypto_larval_add(const char *name, u32 type,\n\t\t\t\t\t    u32 mask)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_larval *larval;\n\n\tlarval = crypto_larval_alloc(name, type, mask);\n\tif (IS_ERR(larval))\n\t\treturn ERR_CAST(larval);\n\n\trefcount_set(&larval->alg.cra_refcnt, 2);\n\n\tdown_write(&crypto_alg_sem);\n\talg = __crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\talg = &larval->alg;\n\t\tlist_add(&alg->cra_list, &crypto_alg_list);\n\t}\n\tup_write(&crypto_alg_sem);\n\n\tif (alg != &larval->alg) {\n\t\tkfree(larval);\n\t\tif (crypto_is_larval(alg))\n\t\t\talg = crypto_larval_wait(alg);\n\t}\n\n\treturn alg;\n}\n\nvoid crypto_larval_kill(struct crypto_alg *alg)\n{\n\tstruct crypto_larval *larval = (void *)alg;\n\n\tdown_write(&crypto_alg_sem);\n\tlist_del(&alg->cra_list);\n\tup_write(&crypto_alg_sem);\n\tcomplete_all(&larval->completion);\n\tcrypto_alg_put(alg);\n}\nEXPORT_SYMBOL_GPL(crypto_larval_kill);\n\nvoid crypto_wait_for_test(struct crypto_larval *larval)\n{\n\tint err;\n\n\terr = crypto_probing_notify(CRYPTO_MSG_ALG_REGISTER, larval->adult);\n\tif (WARN_ON_ONCE(err != NOTIFY_STOP))\n\t\tgoto out;\n\n\terr = wait_for_completion_killable(&larval->completion);\n\tWARN_ON(err);\nout:\n\tcrypto_larval_kill(&larval->alg);\n}\nEXPORT_SYMBOL_GPL(crypto_wait_for_test);\n\nstatic void crypto_start_test(struct crypto_larval *larval)\n{\n\tif (!crypto_is_test_larval(larval))\n\t\treturn;\n\n\tif (larval->test_started)\n\t\treturn;\n\n\tdown_write(&crypto_alg_sem);\n\tif (larval->test_started) {\n\t\tup_write(&crypto_alg_sem);\n\t\treturn;\n\t}\n\n\tlarval->test_started = true;\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_wait_for_test(larval);\n}\n\nstatic struct crypto_alg *crypto_larval_wait(struct crypto_alg *alg)\n{\n\tstruct crypto_larval *larval = (void *)alg;\n\tlong timeout;\n\n\tif (!crypto_boot_test_finished())\n\t\tcrypto_start_test(larval);\n\n\ttimeout = wait_for_completion_killable_timeout(\n\t\t&larval->completion, 60 * HZ);\n\n\talg = larval->adult;\n\tif (timeout < 0)\n\t\talg = ERR_PTR(-EINTR);\n\telse if (!timeout)\n\t\talg = ERR_PTR(-ETIMEDOUT);\n\telse if (!alg)\n\t\talg = ERR_PTR(-ENOENT);\n\telse if (IS_ERR(alg))\n\t\t;\n\telse if (crypto_is_test_larval(larval) &&\n\t\t !(alg->cra_flags & CRYPTO_ALG_TESTED))\n\t\talg = ERR_PTR(-EAGAIN);\n\telse if (alg->cra_flags & CRYPTO_ALG_FIPS_INTERNAL)\n\t\talg = ERR_PTR(-EAGAIN);\n\telse if (!crypto_mod_get(alg))\n\t\talg = ERR_PTR(-EAGAIN);\n\tcrypto_mod_put(&larval->alg);\n\n\treturn alg;\n}\n\nstatic struct crypto_alg *crypto_alg_lookup(const char *name, u32 type,\n\t\t\t\t\t    u32 mask)\n{\n\tconst u32 fips = CRYPTO_ALG_FIPS_INTERNAL;\n\tstruct crypto_alg *alg;\n\tu32 test = 0;\n\n\tif (!((type | mask) & CRYPTO_ALG_TESTED))\n\t\ttest |= CRYPTO_ALG_TESTED;\n\n\tdown_read(&crypto_alg_sem);\n\talg = __crypto_alg_lookup(name, (type | test) & ~fips,\n\t\t\t\t  (mask | test) & ~fips);\n\tif (alg) {\n\t\tif (((type | mask) ^ fips) & fips)\n\t\t\tmask |= fips;\n\t\tmask &= fips;\n\n\t\tif (!crypto_is_larval(alg) &&\n\t\t    ((type ^ alg->cra_flags) & mask)) {\n\t\t\t \n\t\t\tcrypto_mod_put(alg);\n\t\t\talg = ERR_PTR(-ENOENT);\n\t\t}\n\t} else if (test) {\n\t\talg = __crypto_alg_lookup(name, type, mask);\n\t\tif (alg && !crypto_is_larval(alg)) {\n\t\t\t \n\t\t\tcrypto_mod_put(alg);\n\t\t\talg = ERR_PTR(-ELIBBAD);\n\t\t}\n\t}\n\tup_read(&crypto_alg_sem);\n\n\treturn alg;\n}\n\nstatic struct crypto_alg *crypto_larval_lookup(const char *name, u32 type,\n\t\t\t\t\t       u32 mask)\n{\n\tstruct crypto_alg *alg;\n\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\n\ttype &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg && !(mask & CRYPTO_NOLOAD)) {\n\t\trequest_module(\"crypto-%s\", name);\n\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"crypto-%s-all\", name);\n\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\n\tif (!IS_ERR_OR_NULL(alg) && crypto_is_larval(alg))\n\t\talg = crypto_larval_wait(alg);\n\telse if (!alg)\n\t\talg = crypto_larval_add(name, type, mask);\n\n\treturn alg;\n}\n\nint crypto_probing_notify(unsigned long val, void *v)\n{\n\tint ok;\n\n\tok = blocking_notifier_call_chain(&crypto_chain, val, v);\n\tif (ok == NOTIFY_DONE) {\n\t\trequest_module(\"cryptomgr\");\n\t\tok = blocking_notifier_call_chain(&crypto_chain, val, v);\n\t}\n\n\treturn ok;\n}\nEXPORT_SYMBOL_GPL(crypto_probing_notify);\n\nstruct crypto_alg *crypto_alg_mod_lookup(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_alg *larval;\n\tint ok;\n\n\t \n\tif (!((type | mask) & CRYPTO_ALG_INTERNAL))\n\t\tmask |= CRYPTO_ALG_INTERNAL;\n\n\tlarval = crypto_larval_lookup(name, type, mask);\n\tif (IS_ERR(larval) || !crypto_is_larval(larval))\n\t\treturn larval;\n\n\tok = crypto_probing_notify(CRYPTO_MSG_ALG_REQUEST, larval);\n\n\tif (ok == NOTIFY_STOP)\n\t\talg = crypto_larval_wait(larval);\n\telse {\n\t\tcrypto_mod_put(larval);\n\t\talg = ERR_PTR(-ENOENT);\n\t}\n\tcrypto_larval_kill(larval);\n\treturn alg;\n}\nEXPORT_SYMBOL_GPL(crypto_alg_mod_lookup);\n\nstatic void crypto_exit_ops(struct crypto_tfm *tfm)\n{\n\tconst struct crypto_type *type = tfm->__crt_alg->cra_type;\n\n\tif (type && tfm->exit)\n\t\ttfm->exit(tfm);\n}\n\nstatic unsigned int crypto_ctxsize(struct crypto_alg *alg, u32 type, u32 mask)\n{\n\tconst struct crypto_type *type_obj = alg->cra_type;\n\tunsigned int len;\n\n\tlen = alg->cra_alignmask & ~(crypto_tfm_ctx_alignment() - 1);\n\tif (type_obj)\n\t\treturn len + type_obj->ctxsize(alg, type, mask);\n\n\tswitch (alg->cra_flags & CRYPTO_ALG_TYPE_MASK) {\n\tdefault:\n\t\tBUG();\n\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tlen += crypto_cipher_ctxsize(alg);\n\t\tbreak;\n\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tlen += crypto_compress_ctxsize(alg);\n\t\tbreak;\n\t}\n\n\treturn len;\n}\n\nvoid crypto_shoot_alg(struct crypto_alg *alg)\n{\n\tdown_write(&crypto_alg_sem);\n\talg->cra_flags |= CRYPTO_ALG_DYING;\n\tup_write(&crypto_alg_sem);\n}\nEXPORT_SYMBOL_GPL(crypto_shoot_alg);\n\nstruct crypto_tfm *__crypto_alloc_tfmgfp(struct crypto_alg *alg, u32 type,\n\t\t\t\t\t u32 mask, gfp_t gfp)\n{\n\tstruct crypto_tfm *tfm = NULL;\n\tunsigned int tfm_size;\n\tint err = -ENOMEM;\n\n\ttfm_size = sizeof(*tfm) + crypto_ctxsize(alg, type, mask);\n\ttfm = kzalloc(tfm_size, gfp);\n\tif (tfm == NULL)\n\t\tgoto out_err;\n\n\ttfm->__crt_alg = alg;\n\trefcount_set(&tfm->refcnt, 1);\n\n\tif (!tfm->exit && alg->cra_init && (err = alg->cra_init(tfm)))\n\t\tgoto cra_init_failed;\n\n\tgoto out;\n\ncra_init_failed:\n\tcrypto_exit_ops(tfm);\n\tif (err == -EAGAIN)\n\t\tcrypto_shoot_alg(alg);\n\tkfree(tfm);\nout_err:\n\ttfm = ERR_PTR(err);\nout:\n\treturn tfm;\n}\nEXPORT_SYMBOL_GPL(__crypto_alloc_tfmgfp);\n\nstruct crypto_tfm *__crypto_alloc_tfm(struct crypto_alg *alg, u32 type,\n\t\t\t\t      u32 mask)\n{\n\treturn __crypto_alloc_tfmgfp(alg, type, mask, GFP_KERNEL);\n}\nEXPORT_SYMBOL_GPL(__crypto_alloc_tfm);\n\n \nstruct crypto_tfm *crypto_alloc_base(const char *alg_name, u32 type, u32 mask)\n{\n\tstruct crypto_tfm *tfm;\n\tint err;\n\n\tfor (;;) {\n\t\tstruct crypto_alg *alg;\n\n\t\talg = crypto_alg_mod_lookup(alg_name, type, mask);\n\t\tif (IS_ERR(alg)) {\n\t\t\terr = PTR_ERR(alg);\n\t\t\tgoto err;\n\t\t}\n\n\t\ttfm = __crypto_alloc_tfm(alg, type, mask);\n\t\tif (!IS_ERR(tfm))\n\t\t\treturn tfm;\n\n\t\tcrypto_mod_put(alg);\n\t\terr = PTR_ERR(tfm);\n\nerr:\n\t\tif (err != -EAGAIN)\n\t\t\tbreak;\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(crypto_alloc_base);\n\nstatic void *crypto_alloc_tfmmem(struct crypto_alg *alg,\n\t\t\t\t const struct crypto_type *frontend, int node,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct crypto_tfm *tfm;\n\tunsigned int tfmsize;\n\tunsigned int total;\n\tchar *mem;\n\n\ttfmsize = frontend->tfmsize;\n\ttotal = tfmsize + sizeof(*tfm) + frontend->extsize(alg);\n\n\tmem = kzalloc_node(total, gfp, node);\n\tif (mem == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttfm = (struct crypto_tfm *)(mem + tfmsize);\n\ttfm->__crt_alg = alg;\n\ttfm->node = node;\n\trefcount_set(&tfm->refcnt, 1);\n\n\treturn mem;\n}\n\nvoid *crypto_create_tfm_node(struct crypto_alg *alg,\n\t\t\t     const struct crypto_type *frontend,\n\t\t\t     int node)\n{\n\tstruct crypto_tfm *tfm;\n\tchar *mem;\n\tint err;\n\n\tmem = crypto_alloc_tfmmem(alg, frontend, node, GFP_KERNEL);\n\tif (IS_ERR(mem))\n\t\tgoto out;\n\n\ttfm = (struct crypto_tfm *)(mem + frontend->tfmsize);\n\n\terr = frontend->init_tfm(tfm);\n\tif (err)\n\t\tgoto out_free_tfm;\n\n\tif (!tfm->exit && alg->cra_init && (err = alg->cra_init(tfm)))\n\t\tgoto cra_init_failed;\n\n\tgoto out;\n\ncra_init_failed:\n\tcrypto_exit_ops(tfm);\nout_free_tfm:\n\tif (err == -EAGAIN)\n\t\tcrypto_shoot_alg(alg);\n\tkfree(mem);\n\tmem = ERR_PTR(err);\nout:\n\treturn mem;\n}\nEXPORT_SYMBOL_GPL(crypto_create_tfm_node);\n\nvoid *crypto_clone_tfm(const struct crypto_type *frontend,\n\t\t       struct crypto_tfm *otfm)\n{\n\tstruct crypto_alg *alg = otfm->__crt_alg;\n\tstruct crypto_tfm *tfm;\n\tchar *mem;\n\n\tmem = ERR_PTR(-ESTALE);\n\tif (unlikely(!crypto_mod_get(alg)))\n\t\tgoto out;\n\n\tmem = crypto_alloc_tfmmem(alg, frontend, otfm->node, GFP_ATOMIC);\n\tif (IS_ERR(mem)) {\n\t\tcrypto_mod_put(alg);\n\t\tgoto out;\n\t}\n\n\ttfm = (struct crypto_tfm *)(mem + frontend->tfmsize);\n\ttfm->crt_flags = otfm->crt_flags;\n\ttfm->exit = otfm->exit;\n\nout:\n\treturn mem;\n}\nEXPORT_SYMBOL_GPL(crypto_clone_tfm);\n\nstruct crypto_alg *crypto_find_alg(const char *alg_name,\n\t\t\t\t   const struct crypto_type *frontend,\n\t\t\t\t   u32 type, u32 mask)\n{\n\tif (frontend) {\n\t\ttype &= frontend->maskclear;\n\t\tmask &= frontend->maskclear;\n\t\ttype |= frontend->type;\n\t\tmask |= frontend->maskset;\n\t}\n\n\treturn crypto_alg_mod_lookup(alg_name, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_find_alg);\n\n \n\nvoid *crypto_alloc_tfm_node(const char *alg_name,\n\t\t       const struct crypto_type *frontend, u32 type, u32 mask,\n\t\t       int node)\n{\n\tvoid *tfm;\n\tint err;\n\n\tfor (;;) {\n\t\tstruct crypto_alg *alg;\n\n\t\talg = crypto_find_alg(alg_name, frontend, type, mask);\n\t\tif (IS_ERR(alg)) {\n\t\t\terr = PTR_ERR(alg);\n\t\t\tgoto err;\n\t\t}\n\n\t\ttfm = crypto_create_tfm_node(alg, frontend, node);\n\t\tif (!IS_ERR(tfm))\n\t\t\treturn tfm;\n\n\t\tcrypto_mod_put(alg);\n\t\terr = PTR_ERR(tfm);\n\nerr:\n\t\tif (err != -EAGAIN)\n\t\t\tbreak;\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(crypto_alloc_tfm_node);\n\n \nvoid crypto_destroy_tfm(void *mem, struct crypto_tfm *tfm)\n{\n\tstruct crypto_alg *alg;\n\n\tif (IS_ERR_OR_NULL(mem))\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&tfm->refcnt))\n\t\treturn;\n\talg = tfm->__crt_alg;\n\n\tif (!tfm->exit && alg->cra_exit)\n\t\talg->cra_exit(tfm);\n\tcrypto_exit_ops(tfm);\n\tcrypto_mod_put(alg);\n\tkfree_sensitive(mem);\n}\nEXPORT_SYMBOL_GPL(crypto_destroy_tfm);\n\nint crypto_has_alg(const char *name, u32 type, u32 mask)\n{\n\tint ret = 0;\n\tstruct crypto_alg *alg = crypto_alg_mod_lookup(name, type, mask);\n\n\tif (!IS_ERR(alg)) {\n\t\tcrypto_mod_put(alg);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(crypto_has_alg);\n\nvoid crypto_req_done(void *data, int err)\n{\n\tstruct crypto_wait *wait = data;\n\n\tif (err == -EINPROGRESS)\n\t\treturn;\n\n\twait->err = err;\n\tcomplete(&wait->completion);\n}\nEXPORT_SYMBOL_GPL(crypto_req_done);\n\nMODULE_DESCRIPTION(\"Cryptographic core API\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}