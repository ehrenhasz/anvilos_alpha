{
  "module_name": "ofb.c",
  "hash_id": "956f3026b4e3b1f7fdb01a15f14a0dfbcc110d9316efbb05d8207e60bfafd530",
  "original_prompt": "Ingested from linux-6.6.14/crypto/ofb.c",
  "human_readable_source": "\n\n \n\n#include <crypto/algapi.h>\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int crypto_ofb_crypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct crypto_cipher *cipher = skcipher_cipher_simple(tfm);\n\tconst unsigned int bsize = crypto_cipher_blocksize(cipher);\n\tstruct skcipher_walk walk;\n\tint err;\n\n\terr = skcipher_walk_virt(&walk, req, false);\n\n\twhile (walk.nbytes >= bsize) {\n\t\tconst u8 *src = walk.src.virt.addr;\n\t\tu8 *dst = walk.dst.virt.addr;\n\t\tu8 * const iv = walk.iv;\n\t\tunsigned int nbytes = walk.nbytes;\n\n\t\tdo {\n\t\t\tcrypto_cipher_encrypt_one(cipher, iv, iv);\n\t\t\tcrypto_xor_cpy(dst, src, iv, bsize);\n\t\t\tdst += bsize;\n\t\t\tsrc += bsize;\n\t\t} while ((nbytes -= bsize) >= bsize);\n\n\t\terr = skcipher_walk_done(&walk, nbytes);\n\t}\n\n\tif (walk.nbytes) {\n\t\tcrypto_cipher_encrypt_one(cipher, walk.iv, walk.iv);\n\t\tcrypto_xor_cpy(walk.dst.virt.addr, walk.src.virt.addr, walk.iv,\n\t\t\t       walk.nbytes);\n\t\terr = skcipher_walk_done(&walk, 0);\n\t}\n\treturn err;\n}\n\nstatic int crypto_ofb_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct skcipher_instance *inst;\n\tstruct crypto_alg *alg;\n\tint err;\n\n\tinst = skcipher_alloc_instance_simple(tmpl, tb);\n\tif (IS_ERR(inst))\n\t\treturn PTR_ERR(inst);\n\n\talg = skcipher_ialg_simple(inst);\n\n\t \n\tinst->alg.base.cra_blocksize = 1;\n\n\t \n\tinst->alg.chunksize = alg->cra_blocksize;\n\n\tinst->alg.encrypt = crypto_ofb_crypt;\n\tinst->alg.decrypt = crypto_ofb_crypt;\n\n\terr = skcipher_register_instance(tmpl, inst);\n\tif (err)\n\t\tinst->free(inst);\n\n\treturn err;\n}\n\nstatic struct crypto_template crypto_ofb_tmpl = {\n\t.name = \"ofb\",\n\t.create = crypto_ofb_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_ofb_module_init(void)\n{\n\treturn crypto_register_template(&crypto_ofb_tmpl);\n}\n\nstatic void __exit crypto_ofb_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_ofb_tmpl);\n}\n\nsubsys_initcall(crypto_ofb_module_init);\nmodule_exit(crypto_ofb_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"OFB block cipher mode of operation\");\nMODULE_ALIAS_CRYPTO(\"ofb\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}