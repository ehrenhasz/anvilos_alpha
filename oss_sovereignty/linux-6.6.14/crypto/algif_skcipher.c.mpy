{
  "module_name": "algif_skcipher.c",
  "hash_id": "62ea0bb5916e84685e809f4602a9582879333db4b5a60dd6e2ec8e1104cd82f2",
  "original_prompt": "Ingested from linux-6.6.14/crypto/algif_skcipher.c",
  "human_readable_source": "\n \n\n#include <crypto/scatterwalk.h>\n#include <crypto/skcipher.h>\n#include <crypto/if_alg.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <net/sock.h>\n\nstatic int skcipher_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct sock *psk = ask->parent;\n\tstruct alg_sock *pask = alg_sk(psk);\n\tstruct crypto_skcipher *tfm = pask->private;\n\tunsigned ivsize = crypto_skcipher_ivsize(tfm);\n\n\treturn af_alg_sendmsg(sock, msg, size, ivsize);\n}\n\nstatic int _skcipher_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t     size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct sock *psk = ask->parent;\n\tstruct alg_sock *pask = alg_sk(psk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tstruct crypto_skcipher *tfm = pask->private;\n\tunsigned int bs = crypto_skcipher_chunksize(tfm);\n\tstruct af_alg_async_req *areq;\n\tint err = 0;\n\tsize_t len = 0;\n\n\tif (!ctx->init || (ctx->more && ctx->used < bs)) {\n\t\terr = af_alg_wait_for_data(sk, flags, bs);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tareq = af_alg_alloc_areq(sk, sizeof(struct af_alg_async_req) +\n\t\t\t\t     crypto_skcipher_reqsize(tfm));\n\tif (IS_ERR(areq))\n\t\treturn PTR_ERR(areq);\n\n\t \n\terr = af_alg_get_rsgl(sk, msg, flags, areq, ctx->used, &len);\n\tif (err)\n\t\tgoto free;\n\n\t \n\tif (ctx->more || len < ctx->used)\n\t\tlen -= len % bs;\n\n\t \n\tareq->tsgl_entries = af_alg_count_tsgl(sk, len, 0);\n\tif (!areq->tsgl_entries)\n\t\tareq->tsgl_entries = 1;\n\tareq->tsgl = sock_kmalloc(sk, array_size(sizeof(*areq->tsgl),\n\t\t\t\t\t\t areq->tsgl_entries),\n\t\t\t\t  GFP_KERNEL);\n\tif (!areq->tsgl) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\tsg_init_table(areq->tsgl, areq->tsgl_entries);\n\taf_alg_pull_tsgl(sk, len, areq->tsgl, 0);\n\n\t \n\tskcipher_request_set_tfm(&areq->cra_u.skcipher_req, tfm);\n\tskcipher_request_set_crypt(&areq->cra_u.skcipher_req, areq->tsgl,\n\t\t\t\t   areq->first_rsgl.sgl.sgt.sgl, len, ctx->iv);\n\n\tif (msg->msg_iocb && !is_sync_kiocb(msg->msg_iocb)) {\n\t\t \n\t\tsock_hold(sk);\n\t\tareq->iocb = msg->msg_iocb;\n\n\t\t \n\t\tareq->outlen = len;\n\n\t\tskcipher_request_set_callback(&areq->cra_u.skcipher_req,\n\t\t\t\t\t      CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t\t      af_alg_async_cb, areq);\n\t\terr = ctx->enc ?\n\t\t\tcrypto_skcipher_encrypt(&areq->cra_u.skcipher_req) :\n\t\t\tcrypto_skcipher_decrypt(&areq->cra_u.skcipher_req);\n\n\t\t \n\t\tif (err == -EINPROGRESS)\n\t\t\treturn -EIOCBQUEUED;\n\n\t\tsock_put(sk);\n\t} else {\n\t\t \n\t\tskcipher_request_set_callback(&areq->cra_u.skcipher_req,\n\t\t\t\t\t      CRYPTO_TFM_REQ_MAY_SLEEP |\n\t\t\t\t\t      CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\t      crypto_req_done, &ctx->wait);\n\t\terr = crypto_wait_req(ctx->enc ?\n\t\t\tcrypto_skcipher_encrypt(&areq->cra_u.skcipher_req) :\n\t\t\tcrypto_skcipher_decrypt(&areq->cra_u.skcipher_req),\n\t\t\t\t\t\t &ctx->wait);\n\t}\n\n\nfree:\n\taf_alg_free_resources(areq);\n\n\treturn err ? err : len;\n}\n\nstatic int skcipher_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint ret = 0;\n\n\tlock_sock(sk);\n\twhile (msg_data_left(msg)) {\n\t\tint err = _skcipher_recvmsg(sock, msg, ignored, flags);\n\n\t\t \n\t\tif (err <= 0) {\n\t\t\tif (err == -EIOCBQUEUED || !ret)\n\t\t\t\tret = err;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += err;\n\t}\n\nout:\n\taf_alg_wmem_wakeup(sk);\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic struct proto_ops algif_skcipher_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.accept\t\t=\tsock_no_accept,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\tskcipher_sendmsg,\n\t.recvmsg\t=\tskcipher_recvmsg,\n\t.poll\t\t=\taf_alg_poll,\n};\n\nstatic int skcipher_check_key(struct socket *sock)\n{\n\tint err = 0;\n\tstruct sock *psk;\n\tstruct alg_sock *pask;\n\tstruct crypto_skcipher *tfm;\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\n\tlock_sock(sk);\n\tif (!atomic_read(&ask->nokey_refcnt))\n\t\tgoto unlock_child;\n\n\tpsk = ask->parent;\n\tpask = alg_sk(ask->parent);\n\ttfm = pask->private;\n\n\terr = -ENOKEY;\n\tlock_sock_nested(psk, SINGLE_DEPTH_NESTING);\n\tif (crypto_skcipher_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)\n\t\tgoto unlock;\n\n\tatomic_dec(&pask->nokey_refcnt);\n\tatomic_set(&ask->nokey_refcnt, 0);\n\n\terr = 0;\n\nunlock:\n\trelease_sock(psk);\nunlock_child:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int skcipher_sendmsg_nokey(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  size_t size)\n{\n\tint err;\n\n\terr = skcipher_check_key(sock);\n\tif (err)\n\t\treturn err;\n\n\treturn skcipher_sendmsg(sock, msg, size);\n}\n\nstatic int skcipher_recvmsg_nokey(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  size_t ignored, int flags)\n{\n\tint err;\n\n\terr = skcipher_check_key(sock);\n\tif (err)\n\t\treturn err;\n\n\treturn skcipher_recvmsg(sock, msg, ignored, flags);\n}\n\nstatic struct proto_ops algif_skcipher_ops_nokey = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.accept\t\t=\tsock_no_accept,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\tskcipher_sendmsg_nokey,\n\t.recvmsg\t=\tskcipher_recvmsg_nokey,\n\t.poll\t\t=\taf_alg_poll,\n};\n\nstatic void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}\n\nstatic void skcipher_release(void *private)\n{\n\tcrypto_free_skcipher(private);\n}\n\nstatic int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_skcipher_setkey(private, key, keylen);\n}\n\nstatic void skcipher_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tstruct sock *psk = ask->parent;\n\tstruct alg_sock *pask = alg_sk(psk);\n\tstruct crypto_skcipher *tfm = pask->private;\n\n\taf_alg_pull_tsgl(sk, ctx->used, NULL, 0);\n\tsock_kzfree_s(sk, ctx->iv, crypto_skcipher_ivsize(tfm));\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}\n\nstatic int skcipher_accept_parent_nokey(void *private, struct sock *sk)\n{\n\tstruct af_alg_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct crypto_skcipher *tfm = private;\n\tunsigned int len = sizeof(*ctx);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tmemset(ctx, 0, len);\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(tfm),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(tfm));\n\n\tINIT_LIST_HEAD(&ctx->tsgl_list);\n\tctx->len = len;\n\tcrypto_init_wait(&ctx->wait);\n\n\task->private = ctx;\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}\n\nstatic int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct crypto_skcipher *tfm = private;\n\n\tif (crypto_skcipher_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)\n\t\treturn -ENOKEY;\n\n\treturn skcipher_accept_parent_nokey(private, sk);\n}\n\nstatic const struct af_alg_type algif_type_skcipher = {\n\t.bind\t\t=\tskcipher_bind,\n\t.release\t=\tskcipher_release,\n\t.setkey\t\t=\tskcipher_setkey,\n\t.accept\t\t=\tskcipher_accept_parent,\n\t.accept_nokey\t=\tskcipher_accept_parent_nokey,\n\t.ops\t\t=\t&algif_skcipher_ops,\n\t.ops_nokey\t=\t&algif_skcipher_ops_nokey,\n\t.name\t\t=\t\"skcipher\",\n\t.owner\t\t=\tTHIS_MODULE\n};\n\nstatic int __init algif_skcipher_init(void)\n{\n\treturn af_alg_register_type(&algif_type_skcipher);\n}\n\nstatic void __exit algif_skcipher_exit(void)\n{\n\tint err = af_alg_unregister_type(&algif_type_skcipher);\n\tBUG_ON(err);\n}\n\nmodule_init(algif_skcipher_init);\nmodule_exit(algif_skcipher_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}