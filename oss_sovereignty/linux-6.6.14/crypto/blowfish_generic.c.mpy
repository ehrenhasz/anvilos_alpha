{
  "module_name": "blowfish_generic.c",
  "hash_id": "29f773a28d2cd99851cab90a7ff7142d58bdb56df6b8a84f2575616c10f6b9fc",
  "original_prompt": "Ingested from linux-6.6.14/crypto/blowfish_generic.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <asm/unaligned.h>\n#include <linux/types.h>\n#include <crypto/blowfish.h>\n\n \n#define GET32_3(x) (((x) & 0xff))\n#define GET32_2(x) (((x) >> (8)) & (0xff))\n#define GET32_1(x) (((x) >> (16)) & (0xff))\n#define GET32_0(x) (((x) >> (24)) & (0xff))\n\n#define bf_F(x) (((S[GET32_0(x)] + S[256 + GET32_1(x)]) ^ \\\n\t\tS[512 + GET32_2(x)]) + S[768 + GET32_3(x)])\n\n#define ROUND(a, b, n) ({ b ^= P[n]; a ^= bf_F(b); })\n\nstatic void bf_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tstruct bf_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst u32 *P = ctx->p;\n\tconst u32 *S = ctx->s;\n\tu32 yl = get_unaligned_be32(src);\n\tu32 yr = get_unaligned_be32(src + 4);\n\n\tROUND(yr, yl, 0);\n\tROUND(yl, yr, 1);\n\tROUND(yr, yl, 2);\n\tROUND(yl, yr, 3);\n\tROUND(yr, yl, 4);\n\tROUND(yl, yr, 5);\n\tROUND(yr, yl, 6);\n\tROUND(yl, yr, 7);\n\tROUND(yr, yl, 8);\n\tROUND(yl, yr, 9);\n\tROUND(yr, yl, 10);\n\tROUND(yl, yr, 11);\n\tROUND(yr, yl, 12);\n\tROUND(yl, yr, 13);\n\tROUND(yr, yl, 14);\n\tROUND(yl, yr, 15);\n\n\tyl ^= P[16];\n\tyr ^= P[17];\n\n\tput_unaligned_be32(yr, dst);\n\tput_unaligned_be32(yl, dst + 4);\n}\n\nstatic void bf_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tstruct bf_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst u32 *P = ctx->p;\n\tconst u32 *S = ctx->s;\n\tu32 yl = get_unaligned_be32(src);\n\tu32 yr = get_unaligned_be32(src + 4);\n\n\tROUND(yr, yl, 17);\n\tROUND(yl, yr, 16);\n\tROUND(yr, yl, 15);\n\tROUND(yl, yr, 14);\n\tROUND(yr, yl, 13);\n\tROUND(yl, yr, 12);\n\tROUND(yr, yl, 11);\n\tROUND(yl, yr, 10);\n\tROUND(yr, yl, 9);\n\tROUND(yl, yr, 8);\n\tROUND(yr, yl, 7);\n\tROUND(yl, yr, 6);\n\tROUND(yr, yl, 5);\n\tROUND(yl, yr, 4);\n\tROUND(yr, yl, 3);\n\tROUND(yl, yr, 2);\n\n\tyl ^= P[1];\n\tyr ^= P[0];\n\n\tput_unaligned_be32(yr, dst);\n\tput_unaligned_be32(yl, dst + 4);\n}\n\nstatic struct crypto_alg alg = {\n\t.cra_name\t\t=\t\"blowfish\",\n\t.cra_driver_name\t=\t\"blowfish-generic\",\n\t.cra_priority\t\t=\t100,\n\t.cra_flags\t\t=\tCRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize\t\t=\tBF_BLOCK_SIZE,\n\t.cra_ctxsize\t\t=\tsizeof(struct bf_ctx),\n\t.cra_module\t\t=\tTHIS_MODULE,\n\t.cra_u\t\t\t=\t{ .cipher = {\n\t.cia_min_keysize\t=\tBF_MIN_KEY_SIZE,\n\t.cia_max_keysize\t=\tBF_MAX_KEY_SIZE,\n\t.cia_setkey\t\t=\tblowfish_setkey,\n\t.cia_encrypt\t\t=\tbf_encrypt,\n\t.cia_decrypt\t\t=\tbf_decrypt } }\n};\n\nstatic int __init blowfish_mod_init(void)\n{\n\treturn crypto_register_alg(&alg);\n}\n\nstatic void __exit blowfish_mod_fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n}\n\nsubsys_initcall(blowfish_mod_init);\nmodule_exit(blowfish_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Blowfish Cipher Algorithm\");\nMODULE_ALIAS_CRYPTO(\"blowfish\");\nMODULE_ALIAS_CRYPTO(\"blowfish-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}