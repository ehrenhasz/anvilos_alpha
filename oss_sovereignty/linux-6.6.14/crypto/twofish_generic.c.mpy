{
  "module_name": "twofish_generic.c",
  "hash_id": "f20885251b64c77f211a9528eada3565be154dac0f28ef2cdbe9ad6f0ce31793",
  "original_prompt": "Ingested from linux-6.6.14/crypto/twofish_generic.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <crypto/algapi.h>\n#include <crypto/twofish.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n\n \n\n#define G1(a) \\\n     (ctx->s[0][(a) & 0xFF]) ^ (ctx->s[1][((a) >> 8) & 0xFF]) \\\n   ^ (ctx->s[2][((a) >> 16) & 0xFF]) ^ (ctx->s[3][(a) >> 24])\n\n#define G2(b) \\\n     (ctx->s[1][(b) & 0xFF]) ^ (ctx->s[2][((b) >> 8) & 0xFF]) \\\n   ^ (ctx->s[3][((b) >> 16) & 0xFF]) ^ (ctx->s[0][(b) >> 24])\n\n \n\n#define ENCROUND(n, a, b, c, d) \\\n   x = G1 (a); y = G2 (b); \\\n   x += y; y += x + ctx->k[2 * (n) + 1]; \\\n   (c) ^= x + ctx->k[2 * (n)]; \\\n   (c) = ror32((c), 1); \\\n   (d) = rol32((d), 1) ^ y\n\n#define DECROUND(n, a, b, c, d) \\\n   x = G1 (a); y = G2 (b); \\\n   x += y; y += x; \\\n   (d) ^= y + ctx->k[2 * (n) + 1]; \\\n   (d) = ror32((d), 1); \\\n   (c) = rol32((c), 1); \\\n   (c) ^= (x + ctx->k[2 * (n)])\n\n \n\n#define ENCCYCLE(n) \\\n   ENCROUND (2 * (n), a, b, c, d); \\\n   ENCROUND (2 * (n) + 1, c, d, a, b)\n\n#define DECCYCLE(n) \\\n   DECROUND (2 * (n) + 1, c, d, a, b); \\\n   DECROUND (2 * (n), a, b, c, d)\n\n \n\n#define INPACK(n, x, m) \\\n   x = get_unaligned_le32(in + (n) * 4) ^ ctx->w[m]\n\n#define OUTUNPACK(n, x, m) \\\n   x ^= ctx->w[m]; \\\n   put_unaligned_le32(x, out + (n) * 4)\n\n\n\n \nstatic void twofish_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\n{\n\tstruct twofish_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t \n\tu32 a, b, c, d;\n\t\n\t \n\tu32 x, y;\n\n\t \n\tINPACK (0, a, 0);\n\tINPACK (1, b, 1);\n\tINPACK (2, c, 2);\n\tINPACK (3, d, 3);\n\t\n\t \n\tENCCYCLE (0);\n\tENCCYCLE (1);\n\tENCCYCLE (2);\n\tENCCYCLE (3);\n\tENCCYCLE (4);\n\tENCCYCLE (5);\n\tENCCYCLE (6);\n\tENCCYCLE (7);\n\t\n\t \n\tOUTUNPACK (0, c, 4);\n\tOUTUNPACK (1, d, 5);\n\tOUTUNPACK (2, a, 6);\n\tOUTUNPACK (3, b, 7);\n\t\n}\n\n \nstatic void twofish_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\n{\n\tstruct twofish_ctx *ctx = crypto_tfm_ctx(tfm);\n  \n\t \n\tu32 a, b, c, d;\n\t\n\t \n\tu32 x, y;\n\t\n\t \n\tINPACK (0, c, 4);\n\tINPACK (1, d, 5);\n\tINPACK (2, a, 6);\n\tINPACK (3, b, 7);\n\t\n\t \n\tDECCYCLE (7);\n\tDECCYCLE (6);\n\tDECCYCLE (5);\n\tDECCYCLE (4);\n\tDECCYCLE (3);\n\tDECCYCLE (2);\n\tDECCYCLE (1);\n\tDECCYCLE (0);\n\n\t \n\tOUTUNPACK (0, a, 0);\n\tOUTUNPACK (1, b, 1);\n\tOUTUNPACK (2, c, 2);\n\tOUTUNPACK (3, d, 3);\n\n}\n\nstatic struct crypto_alg alg = {\n\t.cra_name           =   \"twofish\",\n\t.cra_driver_name    =   \"twofish-generic\",\n\t.cra_priority       =   100,\n\t.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,\n\t.cra_blocksize      =   TF_BLOCK_SIZE,\n\t.cra_ctxsize        =   sizeof(struct twofish_ctx),\n\t.cra_module         =   THIS_MODULE,\n\t.cra_u              =   { .cipher = {\n\t.cia_min_keysize    =   TF_MIN_KEY_SIZE,\n\t.cia_max_keysize    =   TF_MAX_KEY_SIZE,\n\t.cia_setkey         =   twofish_setkey,\n\t.cia_encrypt        =   twofish_encrypt,\n\t.cia_decrypt        =   twofish_decrypt } }\n};\n\nstatic int __init twofish_mod_init(void)\n{\n\treturn crypto_register_alg(&alg);\n}\n\nstatic void __exit twofish_mod_fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n}\n\nsubsys_initcall(twofish_mod_init);\nmodule_exit(twofish_mod_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION (\"Twofish Cipher Algorithm\");\nMODULE_ALIAS_CRYPTO(\"twofish\");\nMODULE_ALIAS_CRYPTO(\"twofish-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}