{
  "module_name": "aead.c",
  "hash_id": "fc60435299509d1da53ad04458a117be8284ef7d6598ebda902e7f3cf81e190b",
  "original_prompt": "Ingested from linux-6.6.14/crypto/aead.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/aead.h>\n#include <linux/cryptouser.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <net/netlink.h>\n\n#include \"internal.h\"\n\nstatic inline struct crypto_istat_aead *aead_get_stat(struct aead_alg *alg)\n{\n#ifdef CONFIG_CRYPTO_STATS\n\treturn &alg->stat;\n#else\n\treturn NULL;\n#endif\n}\n\nstatic int setkey_unaligned(struct crypto_aead *tfm, const u8 *key,\n\t\t\t    unsigned int keylen)\n{\n\tunsigned long alignmask = crypto_aead_alignmask(tfm);\n\tint ret;\n\tu8 *buffer, *alignbuffer;\n\tunsigned long absize;\n\n\tabsize = keylen + alignmask;\n\tbuffer = kmalloc(absize, GFP_ATOMIC);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\talignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\n\tmemcpy(alignbuffer, key, keylen);\n\tret = crypto_aead_alg(tfm)->setkey(tfm, alignbuffer, keylen);\n\tmemset(alignbuffer, 0, keylen);\n\tkfree(buffer);\n\treturn ret;\n}\n\nint crypto_aead_setkey(struct crypto_aead *tfm,\n\t\t       const u8 *key, unsigned int keylen)\n{\n\tunsigned long alignmask = crypto_aead_alignmask(tfm);\n\tint err;\n\n\tif ((unsigned long)key & alignmask)\n\t\terr = setkey_unaligned(tfm, key, keylen);\n\telse\n\t\terr = crypto_aead_alg(tfm)->setkey(tfm, key, keylen);\n\n\tif (unlikely(err)) {\n\t\tcrypto_aead_set_flags(tfm, CRYPTO_TFM_NEED_KEY);\n\t\treturn err;\n\t}\n\n\tcrypto_aead_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(crypto_aead_setkey);\n\nint crypto_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)\n{\n\tint err;\n\n\tif ((!authsize && crypto_aead_maxauthsize(tfm)) ||\n\t    authsize > crypto_aead_maxauthsize(tfm))\n\t\treturn -EINVAL;\n\n\tif (crypto_aead_alg(tfm)->setauthsize) {\n\t\terr = crypto_aead_alg(tfm)->setauthsize(tfm, authsize);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\ttfm->authsize = authsize;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(crypto_aead_setauthsize);\n\nstatic inline int crypto_aead_errstat(struct crypto_istat_aead *istat, int err)\n{\n\tif (!IS_ENABLED(CONFIG_CRYPTO_STATS))\n\t\treturn err;\n\n\tif (err && err != -EINPROGRESS && err != -EBUSY)\n\t\tatomic64_inc(&istat->err_cnt);\n\n\treturn err;\n}\n\nint crypto_aead_encrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct aead_alg *alg = crypto_aead_alg(aead);\n\tstruct crypto_istat_aead *istat;\n\tint ret;\n\n\tistat = aead_get_stat(alg);\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_STATS)) {\n\t\tatomic64_inc(&istat->encrypt_cnt);\n\t\tatomic64_add(req->cryptlen, &istat->encrypt_tlen);\n\t}\n\n\tif (crypto_aead_get_flags(aead) & CRYPTO_TFM_NEED_KEY)\n\t\tret = -ENOKEY;\n\telse\n\t\tret = alg->encrypt(req);\n\n\treturn crypto_aead_errstat(istat, ret);\n}\nEXPORT_SYMBOL_GPL(crypto_aead_encrypt);\n\nint crypto_aead_decrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct aead_alg *alg = crypto_aead_alg(aead);\n\tstruct crypto_istat_aead *istat;\n\tint ret;\n\n\tistat = aead_get_stat(alg);\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_STATS)) {\n\t\tatomic64_inc(&istat->encrypt_cnt);\n\t\tatomic64_add(req->cryptlen, &istat->encrypt_tlen);\n\t}\n\n\tif (crypto_aead_get_flags(aead) & CRYPTO_TFM_NEED_KEY)\n\t\tret = -ENOKEY;\n\telse if (req->cryptlen < crypto_aead_authsize(aead))\n\t\tret = -EINVAL;\n\telse\n\t\tret = alg->decrypt(req);\n\n\treturn crypto_aead_errstat(istat, ret);\n}\nEXPORT_SYMBOL_GPL(crypto_aead_decrypt);\n\nstatic void crypto_aead_exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_aead *aead = __crypto_aead_cast(tfm);\n\tstruct aead_alg *alg = crypto_aead_alg(aead);\n\n\talg->exit(aead);\n}\n\nstatic int crypto_aead_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_aead *aead = __crypto_aead_cast(tfm);\n\tstruct aead_alg *alg = crypto_aead_alg(aead);\n\n\tcrypto_aead_set_flags(aead, CRYPTO_TFM_NEED_KEY);\n\n\taead->authsize = alg->maxauthsize;\n\n\tif (alg->exit)\n\t\taead->base.exit = crypto_aead_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(aead);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused crypto_aead_report(\n\tstruct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = container_of(alg, struct aead_alg, base);\n\n\tmemset(&raead, 0, sizeof(raead));\n\n\tstrscpy(raead.type, \"aead\", sizeof(raead.type));\n\tstrscpy(raead.geniv, \"<none>\", sizeof(raead.geniv));\n\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_AEAD, sizeof(raead), &raead);\n}\n\nstatic void crypto_aead_show(struct seq_file *m, struct crypto_alg *alg)\n\t__maybe_unused;\nstatic void crypto_aead_show(struct seq_file *m, struct crypto_alg *alg)\n{\n\tstruct aead_alg *aead = container_of(alg, struct aead_alg, base);\n\n\tseq_printf(m, \"type         : aead\\n\");\n\tseq_printf(m, \"async        : %s\\n\", alg->cra_flags & CRYPTO_ALG_ASYNC ?\n\t\t\t\t\t     \"yes\" : \"no\");\n\tseq_printf(m, \"blocksize    : %u\\n\", alg->cra_blocksize);\n\tseq_printf(m, \"ivsize       : %u\\n\", aead->ivsize);\n\tseq_printf(m, \"maxauthsize  : %u\\n\", aead->maxauthsize);\n\tseq_printf(m, \"geniv        : <none>\\n\");\n}\n\nstatic void crypto_aead_free_instance(struct crypto_instance *inst)\n{\n\tstruct aead_instance *aead = aead_instance(inst);\n\n\taead->free(aead);\n}\n\nstatic int __maybe_unused crypto_aead_report_stat(\n\tstruct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct aead_alg *aead = container_of(alg, struct aead_alg, base);\n\tstruct crypto_istat_aead *istat = aead_get_stat(aead);\n\tstruct crypto_stat_aead raead;\n\n\tmemset(&raead, 0, sizeof(raead));\n\n\tstrscpy(raead.type, \"aead\", sizeof(raead.type));\n\n\traead.stat_encrypt_cnt = atomic64_read(&istat->encrypt_cnt);\n\traead.stat_encrypt_tlen = atomic64_read(&istat->encrypt_tlen);\n\traead.stat_decrypt_cnt = atomic64_read(&istat->decrypt_cnt);\n\traead.stat_decrypt_tlen = atomic64_read(&istat->decrypt_tlen);\n\traead.stat_err_cnt = atomic64_read(&istat->err_cnt);\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_AEAD, sizeof(raead), &raead);\n}\n\nstatic const struct crypto_type crypto_aead_type = {\n\t.extsize = crypto_alg_extsize,\n\t.init_tfm = crypto_aead_init_tfm,\n\t.free = crypto_aead_free_instance,\n#ifdef CONFIG_PROC_FS\n\t.show = crypto_aead_show,\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_USER)\n\t.report = crypto_aead_report,\n#endif\n#ifdef CONFIG_CRYPTO_STATS\n\t.report_stat = crypto_aead_report_stat,\n#endif\n\t.maskclear = ~CRYPTO_ALG_TYPE_MASK,\n\t.maskset = CRYPTO_ALG_TYPE_MASK,\n\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t.tfmsize = offsetof(struct crypto_aead, base),\n};\n\nint crypto_grab_aead(struct crypto_aead_spawn *spawn,\n\t\t     struct crypto_instance *inst,\n\t\t     const char *name, u32 type, u32 mask)\n{\n\tspawn->base.frontend = &crypto_aead_type;\n\treturn crypto_grab_spawn(&spawn->base, inst, name, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_grab_aead);\n\nstruct crypto_aead *crypto_alloc_aead(const char *alg_name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_tfm(alg_name, &crypto_aead_type, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_alloc_aead);\n\nstatic int aead_prepare_alg(struct aead_alg *alg)\n{\n\tstruct crypto_istat_aead *istat = aead_get_stat(alg);\n\tstruct crypto_alg *base = &alg->base;\n\n\tif (max3(alg->maxauthsize, alg->ivsize, alg->chunksize) >\n\t    PAGE_SIZE / 8)\n\t\treturn -EINVAL;\n\n\tif (!alg->chunksize)\n\t\talg->chunksize = base->cra_blocksize;\n\n\tbase->cra_type = &crypto_aead_type;\n\tbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\n\tbase->cra_flags |= CRYPTO_ALG_TYPE_AEAD;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_STATS))\n\t\tmemset(istat, 0, sizeof(*istat));\n\n\treturn 0;\n}\n\nint crypto_register_aead(struct aead_alg *alg)\n{\n\tstruct crypto_alg *base = &alg->base;\n\tint err;\n\n\terr = aead_prepare_alg(alg);\n\tif (err)\n\t\treturn err;\n\n\treturn crypto_register_alg(base);\n}\nEXPORT_SYMBOL_GPL(crypto_register_aead);\n\nvoid crypto_unregister_aead(struct aead_alg *alg)\n{\n\tcrypto_unregister_alg(&alg->base);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_aead);\n\nint crypto_register_aeads(struct aead_alg *algs, int count)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = crypto_register_aead(&algs[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (--i; i >= 0; --i)\n\t\tcrypto_unregister_aead(&algs[i]);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(crypto_register_aeads);\n\nvoid crypto_unregister_aeads(struct aead_alg *algs, int count)\n{\n\tint i;\n\n\tfor (i = count - 1; i >= 0; --i)\n\t\tcrypto_unregister_aead(&algs[i]);\n}\nEXPORT_SYMBOL_GPL(crypto_unregister_aeads);\n\nint aead_register_instance(struct crypto_template *tmpl,\n\t\t\t   struct aead_instance *inst)\n{\n\tint err;\n\n\tif (WARN_ON(!inst->free))\n\t\treturn -EINVAL;\n\n\terr = aead_prepare_alg(&inst->alg);\n\tif (err)\n\t\treturn err;\n\n\treturn crypto_register_instance(tmpl, aead_crypto_instance(inst));\n}\nEXPORT_SYMBOL_GPL(aead_register_instance);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Authenticated Encryption with Associated Data (AEAD)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}