{
  "module_name": "af_alg.c",
  "hash_id": "97764ffeae20c17cdefd9eb2c550ec5c61db468318c40e7392a317542d41f15e",
  "original_prompt": "Ingested from linux-6.6.14/crypto/af_alg.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <crypto/if_alg.h>\n#include <linux/crypto.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/key.h>\n#include <linux/key-type.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/rwsem.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <keys/encrypted-type.h>\n\nstruct alg_type_list {\n\tconst struct af_alg_type *type;\n\tstruct list_head list;\n};\n\nstatic struct proto alg_proto = {\n\t.name\t\t\t= \"ALG\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.obj_size\t\t= sizeof(struct alg_sock),\n};\n\nstatic LIST_HEAD(alg_types);\nstatic DECLARE_RWSEM(alg_types_sem);\n\nstatic const struct af_alg_type *alg_get_type(const char *name)\n{\n\tconst struct af_alg_type *type = ERR_PTR(-ENOENT);\n\tstruct alg_type_list *node;\n\n\tdown_read(&alg_types_sem);\n\tlist_for_each_entry(node, &alg_types, list) {\n\t\tif (strcmp(node->type->name, name))\n\t\t\tcontinue;\n\n\t\tif (try_module_get(node->type->owner))\n\t\t\ttype = node->type;\n\t\tbreak;\n\t}\n\tup_read(&alg_types_sem);\n\n\treturn type;\n}\n\nint af_alg_register_type(const struct af_alg_type *type)\n{\n\tstruct alg_type_list *node;\n\tint err = -EEXIST;\n\n\tdown_write(&alg_types_sem);\n\tlist_for_each_entry(node, &alg_types, list) {\n\t\tif (!strcmp(node->type->name, type->name))\n\t\t\tgoto unlock;\n\t}\n\n\tnode = kmalloc(sizeof(*node), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!node)\n\t\tgoto unlock;\n\n\ttype->ops->owner = THIS_MODULE;\n\tif (type->ops_nokey)\n\t\ttype->ops_nokey->owner = THIS_MODULE;\n\tnode->type = type;\n\tlist_add(&node->list, &alg_types);\n\terr = 0;\n\nunlock:\n\tup_write(&alg_types_sem);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_register_type);\n\nint af_alg_unregister_type(const struct af_alg_type *type)\n{\n\tstruct alg_type_list *node;\n\tint err = -ENOENT;\n\n\tdown_write(&alg_types_sem);\n\tlist_for_each_entry(node, &alg_types, list) {\n\t\tif (strcmp(node->type->name, type->name))\n\t\t\tcontinue;\n\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\t\terr = 0;\n\t\tbreak;\n\t}\n\tup_write(&alg_types_sem);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_unregister_type);\n\nstatic void alg_do_release(const struct af_alg_type *type, void *private)\n{\n\tif (!type)\n\t\treturn;\n\n\ttype->release(private);\n\tmodule_put(type->owner);\n}\n\nint af_alg_release(struct socket *sock)\n{\n\tif (sock->sk) {\n\t\tsock_put(sock->sk);\n\t\tsock->sk = NULL;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(af_alg_release);\n\nvoid af_alg_release_parent(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int nokey = atomic_read(&ask->nokey_refcnt);\n\n\tsk = ask->parent;\n\task = alg_sk(sk);\n\n\tif (nokey)\n\t\tatomic_dec(&ask->nokey_refcnt);\n\n\tif (atomic_dec_and_test(&ask->refcnt))\n\t\tsock_put(sk);\n}\nEXPORT_SYMBOL_GPL(af_alg_release_parent);\n\nstatic int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tconst u32 allowed = CRYPTO_ALG_KERN_DRIVER_ONLY;\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct sockaddr_alg_new *sa = (void *)uaddr;\n\tconst struct af_alg_type *type;\n\tvoid *private;\n\tint err;\n\n\tif (sock->state == SS_CONNECTED)\n\t\treturn -EINVAL;\n\n\tBUILD_BUG_ON(offsetof(struct sockaddr_alg_new, salg_name) !=\n\t\t     offsetof(struct sockaddr_alg, salg_name));\n\tBUILD_BUG_ON(offsetof(struct sockaddr_alg, salg_name) != sizeof(*sa));\n\n\tif (addr_len < sizeof(*sa) + 1)\n\t\treturn -EINVAL;\n\n\t \n\tif ((sa->salg_feat & ~allowed) || (sa->salg_mask & ~allowed))\n\t\treturn -EINVAL;\n\n\tsa->salg_type[sizeof(sa->salg_type) - 1] = 0;\n\tsa->salg_name[addr_len - sizeof(*sa) - 1] = 0;\n\n\ttype = alg_get_type(sa->salg_type);\n\tif (PTR_ERR(type) == -ENOENT) {\n\t\trequest_module(\"algif-%s\", sa->salg_type);\n\t\ttype = alg_get_type(sa->salg_type);\n\t}\n\n\tif (IS_ERR(type))\n\t\treturn PTR_ERR(type);\n\n\tprivate = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);\n\tif (IS_ERR(private)) {\n\t\tmodule_put(type->owner);\n\t\treturn PTR_ERR(private);\n\t}\n\n\terr = -EBUSY;\n\tlock_sock(sk);\n\tif (atomic_read(&ask->refcnt))\n\t\tgoto unlock;\n\n\tswap(ask->type, type);\n\tswap(ask->private, private);\n\n\terr = 0;\n\nunlock:\n\trelease_sock(sk);\n\n\talg_do_release(type, private);\n\n\treturn err;\n}\n\nstatic int alg_setkey(struct sock *sk, sockptr_t ukey, unsigned int keylen)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tconst struct af_alg_type *type = ask->type;\n\tu8 *key;\n\tint err;\n\n\tkey = sock_kmalloc(sk, keylen, GFP_KERNEL);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\terr = -EFAULT;\n\tif (copy_from_sockptr(key, ukey, keylen))\n\t\tgoto out;\n\n\terr = type->setkey(ask->private, key, keylen);\n\nout:\n\tsock_kzfree_s(sk, key, keylen);\n\n\treturn err;\n}\n\n#ifdef CONFIG_KEYS\n\nstatic const u8 *key_data_ptr_user(const struct key *key,\n\t\t\t\t   unsigned int *datalen)\n{\n\tconst struct user_key_payload *ukp;\n\n\tukp = user_key_payload_locked(key);\n\tif (IS_ERR_OR_NULL(ukp))\n\t\treturn ERR_PTR(-EKEYREVOKED);\n\n\t*datalen = key->datalen;\n\n\treturn ukp->data;\n}\n\nstatic const u8 *key_data_ptr_encrypted(const struct key *key,\n\t\t\t\t\tunsigned int *datalen)\n{\n\tconst struct encrypted_key_payload *ekp;\n\n\tekp = dereference_key_locked(key);\n\tif (IS_ERR_OR_NULL(ekp))\n\t\treturn ERR_PTR(-EKEYREVOKED);\n\n\t*datalen = ekp->decrypted_datalen;\n\n\treturn ekp->decrypted_data;\n}\n\nstatic const u8 *key_data_ptr_trusted(const struct key *key,\n\t\t\t\t      unsigned int *datalen)\n{\n\tconst struct trusted_key_payload *tkp;\n\n\ttkp = dereference_key_locked(key);\n\tif (IS_ERR_OR_NULL(tkp))\n\t\treturn ERR_PTR(-EKEYREVOKED);\n\n\t*datalen = tkp->key_len;\n\n\treturn tkp->key;\n}\n\nstatic struct key *lookup_key(key_serial_t serial)\n{\n\tkey_ref_t key_ref;\n\n\tkey_ref = lookup_user_key(serial, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref))\n\t\treturn ERR_CAST(key_ref);\n\n\treturn key_ref_to_ptr(key_ref);\n}\n\nstatic int alg_setkey_by_key_serial(struct alg_sock *ask, sockptr_t optval,\n\t\t\t\t    unsigned int optlen)\n{\n\tconst struct af_alg_type *type = ask->type;\n\tu8 *key_data = NULL;\n\tunsigned int key_datalen;\n\tkey_serial_t serial;\n\tstruct key *key;\n\tconst u8 *ret;\n\tint err;\n\n\tif (optlen != sizeof(serial))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&serial, optval, optlen))\n\t\treturn -EFAULT;\n\n\tkey = lookup_key(serial);\n\tif (IS_ERR(key))\n\t\treturn PTR_ERR(key);\n\n\tdown_read(&key->sem);\n\n\tret = ERR_PTR(-ENOPROTOOPT);\n\tif (!strcmp(key->type->name, \"user\") ||\n\t    !strcmp(key->type->name, \"logon\")) {\n\t\tret = key_data_ptr_user(key, &key_datalen);\n\t} else if (IS_REACHABLE(CONFIG_ENCRYPTED_KEYS) &&\n\t\t\t   !strcmp(key->type->name, \"encrypted\")) {\n\t\tret = key_data_ptr_encrypted(key, &key_datalen);\n\t} else if (IS_REACHABLE(CONFIG_TRUSTED_KEYS) &&\n\t\t\t   !strcmp(key->type->name, \"trusted\")) {\n\t\tret = key_data_ptr_trusted(key, &key_datalen);\n\t}\n\n\tif (IS_ERR(ret)) {\n\t\tup_read(&key->sem);\n\t\tkey_put(key);\n\t\treturn PTR_ERR(ret);\n\t}\n\n\tkey_data = sock_kmalloc(&ask->sk, key_datalen, GFP_KERNEL);\n\tif (!key_data) {\n\t\tup_read(&key->sem);\n\t\tkey_put(key);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(key_data, ret, key_datalen);\n\n\tup_read(&key->sem);\n\tkey_put(key);\n\n\terr = type->setkey(ask->private, key_data, key_datalen);\n\n\tsock_kzfree_s(&ask->sk, key_data, key_datalen);\n\n\treturn err;\n}\n\n#else\n\nstatic inline int alg_setkey_by_key_serial(struct alg_sock *ask,\n\t\t\t\t\t   sockptr_t optval,\n\t\t\t\t\t   unsigned int optlen)\n{\n\treturn -ENOPROTOOPT;\n}\n\n#endif\n\nstatic int alg_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tconst struct af_alg_type *type;\n\tint err = -EBUSY;\n\n\tlock_sock(sk);\n\tif (atomic_read(&ask->refcnt) != atomic_read(&ask->nokey_refcnt))\n\t\tgoto unlock;\n\n\ttype = ask->type;\n\n\terr = -ENOPROTOOPT;\n\tif (level != SOL_ALG || !type)\n\t\tgoto unlock;\n\n\tswitch (optname) {\n\tcase ALG_SET_KEY:\n\tcase ALG_SET_KEY_BY_KEY_SERIAL:\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\tgoto unlock;\n\t\tif (!type->setkey)\n\t\t\tgoto unlock;\n\n\t\tif (optname == ALG_SET_KEY_BY_KEY_SERIAL)\n\t\t\terr = alg_setkey_by_key_serial(ask, optval, optlen);\n\t\telse\n\t\t\terr = alg_setkey(sk, optval, optlen);\n\t\tbreak;\n\tcase ALG_SET_AEAD_AUTHSIZE:\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\tgoto unlock;\n\t\tif (!type->setauthsize)\n\t\t\tgoto unlock;\n\t\terr = type->setauthsize(ask->private, optlen);\n\t\tbreak;\n\tcase ALG_SET_DRBG_ENTROPY:\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\tgoto unlock;\n\t\tif (!type->setentropy)\n\t\t\tgoto unlock;\n\n\t\terr = type->setentropy(ask->private, optval, optlen);\n\t}\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nint af_alg_accept(struct sock *sk, struct socket *newsock, bool kern)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tconst struct af_alg_type *type;\n\tstruct sock *sk2;\n\tunsigned int nokey;\n\tint err;\n\n\tlock_sock(sk);\n\ttype = ask->type;\n\n\terr = -EINVAL;\n\tif (!type)\n\t\tgoto unlock;\n\n\tsk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto, kern);\n\terr = -ENOMEM;\n\tif (!sk2)\n\t\tgoto unlock;\n\n\tsock_init_data(newsock, sk2);\n\tsecurity_sock_graft(sk2, newsock);\n\tsecurity_sk_clone(sk, sk2);\n\n\t \n\tnewsock->ops = type->ops;\n\terr = type->accept(ask->private, sk2);\n\n\tnokey = err == -ENOKEY;\n\tif (nokey && type->accept_nokey)\n\t\terr = type->accept_nokey(ask->private, sk2);\n\n\tif (err)\n\t\tgoto unlock;\n\n\tif (atomic_inc_return_relaxed(&ask->refcnt) == 1)\n\t\tsock_hold(sk);\n\tif (nokey) {\n\t\tatomic_inc(&ask->nokey_refcnt);\n\t\tatomic_set(&alg_sk(sk2)->nokey_refcnt, 1);\n\t}\n\talg_sk(sk2)->parent = sk;\n\talg_sk(sk2)->type = type;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tif (nokey)\n\t\tnewsock->ops = type->ops_nokey;\n\n\terr = 0;\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_accept);\n\nstatic int alg_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t      bool kern)\n{\n\treturn af_alg_accept(sock->sk, newsock, kern);\n}\n\nstatic const struct proto_ops alg_proto_ops = {\n\t.family\t\t=\tPF_ALG,\n\t.owner\t\t=\tTHIS_MODULE,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.sendmsg\t=\tsock_no_sendmsg,\n\t.recvmsg\t=\tsock_no_recvmsg,\n\n\t.bind\t\t=\talg_bind,\n\t.release\t=\taf_alg_release,\n\t.setsockopt\t=\talg_setsockopt,\n\t.accept\t\t=\talg_accept,\n};\n\nstatic void alg_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\n\talg_do_release(ask->type, ask->private);\n}\n\nstatic int alg_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tstruct sock *sk;\n\tint err;\n\n\tif (sock->type != SOCK_SEQPACKET)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (protocol != 0)\n\t\treturn -EPROTONOSUPPORT;\n\n\terr = -ENOMEM;\n\tsk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock->ops = &alg_proto_ops;\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = alg_sock_destruct;\n\n\treturn 0;\nout:\n\treturn err;\n}\n\nstatic const struct net_proto_family alg_family = {\n\t.family\t=\tPF_ALG,\n\t.create\t=\talg_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\nstatic void af_alg_link_sg(struct af_alg_sgl *sgl_prev,\n\t\t\t   struct af_alg_sgl *sgl_new)\n{\n\tsg_unmark_end(sgl_prev->sgt.sgl + sgl_prev->sgt.nents - 1);\n\tsg_chain(sgl_prev->sgt.sgl, sgl_prev->sgt.nents + 1, sgl_new->sgt.sgl);\n}\n\nvoid af_alg_free_sg(struct af_alg_sgl *sgl)\n{\n\tint i;\n\n\tif (sgl->sgt.sgl) {\n\t\tif (sgl->need_unpin)\n\t\t\tfor (i = 0; i < sgl->sgt.nents; i++)\n\t\t\t\tunpin_user_page(sg_page(&sgl->sgt.sgl[i]));\n\t\tif (sgl->sgt.sgl != sgl->sgl)\n\t\t\tkvfree(sgl->sgt.sgl);\n\t\tsgl->sgt.sgl = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(af_alg_free_sg);\n\nstatic int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)\n{\n\tstruct cmsghdr *cmsg;\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\treturn -EINVAL;\n\t\tif (cmsg->cmsg_level != SOL_ALG)\n\t\t\tcontinue;\n\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase ALG_SET_IV:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))\n\t\t\t\treturn -EINVAL;\n\t\t\tcon->iv = (void *)CMSG_DATA(cmsg);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +\n\t\t\t\t\t\t      sizeof(*con->iv)))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase ALG_SET_OP:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))\n\t\t\t\treturn -EINVAL;\n\t\t\tcon->op = *(u32 *)CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tcase ALG_SET_AEAD_ASSOCLEN:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))\n\t\t\t\treturn -EINVAL;\n\t\t\tcon->aead_assoclen = *(u32 *)CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int af_alg_alloc_tsgl(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tstruct af_alg_tsgl *sgl;\n\tstruct scatterlist *sg = NULL;\n\n\tsgl = list_entry(ctx->tsgl_list.prev, struct af_alg_tsgl, list);\n\tif (!list_empty(&ctx->tsgl_list))\n\t\tsg = sgl->sg;\n\n\tif (!sg || sgl->cur >= MAX_SGL_ENTS) {\n\t\tsgl = sock_kmalloc(sk,\n\t\t\t\t   struct_size(sgl, sg, (MAX_SGL_ENTS + 1)),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!sgl)\n\t\t\treturn -ENOMEM;\n\n\t\tsg_init_table(sgl->sg, MAX_SGL_ENTS + 1);\n\t\tsgl->cur = 0;\n\n\t\tif (sg)\n\t\t\tsg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);\n\n\t\tlist_add_tail(&sgl->list, &ctx->tsgl_list);\n\t}\n\n\treturn 0;\n}\n\n \nunsigned int af_alg_count_tsgl(struct sock *sk, size_t bytes, size_t offset)\n{\n\tconst struct alg_sock *ask = alg_sk(sk);\n\tconst struct af_alg_ctx *ctx = ask->private;\n\tconst struct af_alg_tsgl *sgl;\n\tunsigned int i;\n\tunsigned int sgl_count = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tlist_for_each_entry(sgl, &ctx->tsgl_list, list) {\n\t\tconst struct scatterlist *sg = sgl->sg;\n\n\t\tfor (i = 0; i < sgl->cur; i++) {\n\t\t\tsize_t bytes_count;\n\n\t\t\t \n\t\t\tif (offset >= sg[i].length) {\n\t\t\t\toffset -= sg[i].length;\n\t\t\t\tbytes -= sg[i].length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbytes_count = sg[i].length - offset;\n\n\t\t\toffset = 0;\n\t\t\tsgl_count++;\n\n\t\t\t \n\t\t\tif (bytes_count >= bytes)\n\t\t\t\treturn sgl_count;\n\n\t\t\tbytes -= bytes_count;\n\t\t}\n\t}\n\n\treturn sgl_count;\n}\nEXPORT_SYMBOL_GPL(af_alg_count_tsgl);\n\n \nvoid af_alg_pull_tsgl(struct sock *sk, size_t used, struct scatterlist *dst,\n\t\t      size_t dst_offset)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tstruct af_alg_tsgl *sgl;\n\tstruct scatterlist *sg;\n\tunsigned int i, j = 0;\n\n\twhile (!list_empty(&ctx->tsgl_list)) {\n\t\tsgl = list_first_entry(&ctx->tsgl_list, struct af_alg_tsgl,\n\t\t\t\t       list);\n\t\tsg = sgl->sg;\n\n\t\tfor (i = 0; i < sgl->cur; i++) {\n\t\t\tsize_t plen = min_t(size_t, used, sg[i].length);\n\t\t\tstruct page *page = sg_page(sg + i);\n\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (dst) {\n\t\t\t\tif (dst_offset >= plen) {\n\t\t\t\t\t \n\t\t\t\t\tdst_offset -= plen;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tget_page(page);\n\t\t\t\t\tsg_set_page(dst + j, page,\n\t\t\t\t\t\t    plen - dst_offset,\n\t\t\t\t\t\t    sg[i].offset + dst_offset);\n\t\t\t\t\tdst_offset = 0;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsg[i].length -= plen;\n\t\t\tsg[i].offset += plen;\n\n\t\t\tused -= plen;\n\t\t\tctx->used -= plen;\n\n\t\t\tif (sg[i].length)\n\t\t\t\treturn;\n\n\t\t\tput_page(page);\n\t\t\tsg_assign_page(sg + i, NULL);\n\t\t}\n\n\t\tlist_del(&sgl->list);\n\t\tsock_kfree_s(sk, sgl, struct_size(sgl, sg, MAX_SGL_ENTS + 1));\n\t}\n\n\tif (!ctx->used)\n\t\tctx->merge = 0;\n\tctx->init = ctx->more;\n}\nEXPORT_SYMBOL_GPL(af_alg_pull_tsgl);\n\n \nstatic void af_alg_free_areq_sgls(struct af_alg_async_req *areq)\n{\n\tstruct sock *sk = areq->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tstruct af_alg_rsgl *rsgl, *tmp;\n\tstruct scatterlist *tsgl;\n\tstruct scatterlist *sg;\n\tunsigned int i;\n\n\tlist_for_each_entry_safe(rsgl, tmp, &areq->rsgl_list, list) {\n\t\tatomic_sub(rsgl->sg_num_bytes, &ctx->rcvused);\n\t\taf_alg_free_sg(&rsgl->sgl);\n\t\tlist_del(&rsgl->list);\n\t\tif (rsgl != &areq->first_rsgl)\n\t\t\tsock_kfree_s(sk, rsgl, sizeof(*rsgl));\n\t}\n\n\ttsgl = areq->tsgl;\n\tif (tsgl) {\n\t\tfor_each_sg(tsgl, sg, areq->tsgl_entries, i) {\n\t\t\tif (!sg_page(sg))\n\t\t\t\tcontinue;\n\t\t\tput_page(sg_page(sg));\n\t\t}\n\n\t\tsock_kfree_s(sk, tsgl, areq->tsgl_entries * sizeof(*tsgl));\n\t}\n}\n\n \nstatic int af_alg_wait_for_wmem(struct sock *sk, unsigned int flags)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint err = -ERESTARTSYS;\n\tlong timeout;\n\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\n\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, af_alg_writable(sk), &wait)) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\treturn err;\n}\n\n \nvoid af_alg_wmem_wakeup(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\tif (!af_alg_writable(sk))\n\t\treturn;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (skwq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, EPOLLIN |\n\t\t\t\t\t\t\t   EPOLLRDNORM |\n\t\t\t\t\t\t\t   EPOLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(af_alg_wmem_wakeup);\n\n \nint af_alg_wait_for_data(struct sock *sk, unsigned flags, unsigned min)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tlong timeout;\n\tint err = -ERESTARTSYS;\n\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\n\tsk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout,\n\t\t\t\t  ctx->init && (!ctx->more ||\n\t\t\t\t\t\t(min && ctx->used >= min)),\n\t\t\t\t  &wait)) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tsk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_wait_for_data);\n\n \nstatic void af_alg_data_wakeup(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tstruct socket_wq *wq;\n\n\tif (!ctx->used)\n\t\treturn;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (skwq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, EPOLLOUT |\n\t\t\t\t\t\t\t   EPOLLRDNORM |\n\t\t\t\t\t\t\t   EPOLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\n\trcu_read_unlock();\n}\n\n \nint af_alg_sendmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t   unsigned int ivsize)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tstruct af_alg_tsgl *sgl;\n\tstruct af_alg_control con = {};\n\tlong copied = 0;\n\tbool enc = false;\n\tbool init = false;\n\tint err = 0;\n\n\tif (msg->msg_controllen) {\n\t\terr = af_alg_cmsg_send(msg, &con);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tinit = true;\n\t\tswitch (con.op) {\n\t\tcase ALG_OP_ENCRYPT:\n\t\t\tenc = true;\n\t\t\tbreak;\n\t\tcase ALG_OP_DECRYPT:\n\t\t\tenc = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (con.iv && con.iv->ivlen != ivsize)\n\t\t\treturn -EINVAL;\n\t}\n\n\tlock_sock(sk);\n\tif (ctx->init && !ctx->more) {\n\t\tif (ctx->used) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tpr_info_once(\n\t\t\t\"%s sent an empty control message without MSG_MORE.\\n\",\n\t\t\tcurrent->comm);\n\t}\n\tctx->init = true;\n\n\tif (init) {\n\t\tctx->enc = enc;\n\t\tif (con.iv)\n\t\t\tmemcpy(ctx->iv, con.iv->iv, ivsize);\n\n\t\tctx->aead_assoclen = con.aead_assoclen;\n\t}\n\n\twhile (size) {\n\t\tstruct scatterlist *sg;\n\t\tsize_t len = size;\n\t\tssize_t plen;\n\n\t\t \n\t\tif (ctx->merge && !(msg->msg_flags & MSG_SPLICE_PAGES)) {\n\t\t\tsgl = list_entry(ctx->tsgl_list.prev,\n\t\t\t\t\t struct af_alg_tsgl, list);\n\t\t\tsg = sgl->sg + sgl->cur - 1;\n\t\t\tlen = min_t(size_t, len,\n\t\t\t\t    PAGE_SIZE - sg->offset - sg->length);\n\n\t\t\terr = memcpy_from_msg(page_address(sg_page(sg)) +\n\t\t\t\t\t      sg->offset + sg->length,\n\t\t\t\t\t      msg, len);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\n\t\t\tsg->length += len;\n\t\t\tctx->merge = (sg->offset + sg->length) &\n\t\t\t\t     (PAGE_SIZE - 1);\n\n\t\t\tctx->used += len;\n\t\t\tcopied += len;\n\t\t\tsize -= len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!af_alg_writable(sk)) {\n\t\t\terr = af_alg_wait_for_wmem(sk, msg->msg_flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\t \n\t\tlen = min_t(unsigned long, len, af_alg_sndbuf(sk));\n\n\t\terr = af_alg_alloc_tsgl(sk);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tsgl = list_entry(ctx->tsgl_list.prev, struct af_alg_tsgl,\n\t\t\t\t list);\n\t\tsg = sgl->sg;\n\t\tif (sgl->cur)\n\t\t\tsg_unmark_end(sg + sgl->cur - 1);\n\n\t\tif (msg->msg_flags & MSG_SPLICE_PAGES) {\n\t\t\tstruct sg_table sgtable = {\n\t\t\t\t.sgl\t\t= sg,\n\t\t\t\t.nents\t\t= sgl->cur,\n\t\t\t\t.orig_nents\t= sgl->cur,\n\t\t\t};\n\n\t\t\tplen = extract_iter_to_sg(&msg->msg_iter, len, &sgtable,\n\t\t\t\t\t\t  MAX_SGL_ENTS - sgl->cur, 0);\n\t\t\tif (plen < 0) {\n\t\t\t\terr = plen;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tfor (; sgl->cur < sgtable.nents; sgl->cur++)\n\t\t\t\tget_page(sg_page(&sg[sgl->cur]));\n\t\t\tlen -= plen;\n\t\t\tctx->used += plen;\n\t\t\tcopied += plen;\n\t\t\tsize -= plen;\n\t\t\tctx->merge = 0;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tstruct page *pg;\n\t\t\t\tunsigned int i = sgl->cur;\n\n\t\t\t\tplen = min_t(size_t, len, PAGE_SIZE);\n\n\t\t\t\tpg = alloc_page(GFP_KERNEL);\n\t\t\t\tif (!pg) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\n\t\t\t\tsg_assign_page(sg + i, pg);\n\n\t\t\t\terr = memcpy_from_msg(\n\t\t\t\t\tpage_address(sg_page(sg + i)),\n\t\t\t\t\tmsg, plen);\n\t\t\t\tif (err) {\n\t\t\t\t\t__free_page(sg_page(sg + i));\n\t\t\t\t\tsg_assign_page(sg + i, NULL);\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\n\t\t\t\tsg[i].length = plen;\n\t\t\t\tlen -= plen;\n\t\t\t\tctx->used += plen;\n\t\t\t\tcopied += plen;\n\t\t\t\tsize -= plen;\n\t\t\t\tsgl->cur++;\n\t\t\t} while (len && sgl->cur < MAX_SGL_ENTS);\n\n\t\t\tctx->merge = plen & (PAGE_SIZE - 1);\n\t\t}\n\n\t\tif (!size)\n\t\t\tsg_mark_end(sg + sgl->cur - 1);\n\t}\n\n\terr = 0;\n\n\tctx->more = msg->msg_flags & MSG_MORE;\n\nunlock:\n\taf_alg_data_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}\nEXPORT_SYMBOL_GPL(af_alg_sendmsg);\n\n \nvoid af_alg_free_resources(struct af_alg_async_req *areq)\n{\n\tstruct sock *sk = areq->sk;\n\tstruct af_alg_ctx *ctx;\n\n\taf_alg_free_areq_sgls(areq);\n\tsock_kfree_s(sk, areq, areq->areqlen);\n\n\tctx = alg_sk(sk)->private;\n\tctx->inflight = false;\n}\nEXPORT_SYMBOL_GPL(af_alg_free_resources);\n\n \nvoid af_alg_async_cb(void *data, int err)\n{\n\tstruct af_alg_async_req *areq = data;\n\tstruct sock *sk = areq->sk;\n\tstruct kiocb *iocb = areq->iocb;\n\tunsigned int resultlen;\n\n\t \n\tresultlen = areq->outlen;\n\n\taf_alg_free_resources(areq);\n\tsock_put(sk);\n\n\tiocb->ki_complete(iocb, err ? err : (int)resultlen);\n}\nEXPORT_SYMBOL_GPL(af_alg_async_cb);\n\n \n__poll_t af_alg_poll(struct file *file, struct socket *sock,\n\t\t\t poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\t__poll_t mask;\n\n\tsock_poll_wait(file, sock, wait);\n\tmask = 0;\n\n\tif (!ctx->more || ctx->used)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tif (af_alg_writable(sk))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;\n\n\treturn mask;\n}\nEXPORT_SYMBOL_GPL(af_alg_poll);\n\n \nstruct af_alg_async_req *af_alg_alloc_areq(struct sock *sk,\n\t\t\t\t\t   unsigned int areqlen)\n{\n\tstruct af_alg_ctx *ctx = alg_sk(sk)->private;\n\tstruct af_alg_async_req *areq;\n\n\t \n\tif (ctx->inflight)\n\t\treturn ERR_PTR(-EBUSY);\n\n\tareq = sock_kmalloc(sk, areqlen, GFP_KERNEL);\n\tif (unlikely(!areq))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->inflight = true;\n\n\tareq->areqlen = areqlen;\n\tareq->sk = sk;\n\tareq->first_rsgl.sgl.sgt.sgl = areq->first_rsgl.sgl.sgl;\n\tareq->last_rsgl = NULL;\n\tINIT_LIST_HEAD(&areq->rsgl_list);\n\tareq->tsgl = NULL;\n\tareq->tsgl_entries = 0;\n\n\treturn areq;\n}\nEXPORT_SYMBOL_GPL(af_alg_alloc_areq);\n\n \nint af_alg_get_rsgl(struct sock *sk, struct msghdr *msg, int flags,\n\t\t    struct af_alg_async_req *areq, size_t maxsize,\n\t\t    size_t *outlen)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct af_alg_ctx *ctx = ask->private;\n\tsize_t len = 0;\n\n\twhile (maxsize > len && msg_data_left(msg)) {\n\t\tstruct af_alg_rsgl *rsgl;\n\t\tssize_t err;\n\t\tsize_t seglen;\n\n\t\t \n\t\tif (!af_alg_readable(sk))\n\t\t\tbreak;\n\n\t\tseglen = min_t(size_t, (maxsize - len),\n\t\t\t       msg_data_left(msg));\n\n\t\tif (list_empty(&areq->rsgl_list)) {\n\t\t\trsgl = &areq->first_rsgl;\n\t\t} else {\n\t\t\trsgl = sock_kmalloc(sk, sizeof(*rsgl), GFP_KERNEL);\n\t\t\tif (unlikely(!rsgl))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trsgl->sgl.need_unpin =\n\t\t\tiov_iter_extract_will_pin(&msg->msg_iter);\n\t\trsgl->sgl.sgt.sgl = rsgl->sgl.sgl;\n\t\trsgl->sgl.sgt.nents = 0;\n\t\trsgl->sgl.sgt.orig_nents = 0;\n\t\tlist_add_tail(&rsgl->list, &areq->rsgl_list);\n\n\t\tsg_init_table(rsgl->sgl.sgt.sgl, ALG_MAX_PAGES);\n\t\terr = extract_iter_to_sg(&msg->msg_iter, seglen, &rsgl->sgl.sgt,\n\t\t\t\t\t ALG_MAX_PAGES, 0);\n\t\tif (err < 0) {\n\t\t\trsgl->sg_num_bytes = 0;\n\t\t\treturn err;\n\t\t}\n\n\t\tsg_mark_end(rsgl->sgl.sgt.sgl + rsgl->sgl.sgt.nents - 1);\n\n\t\t \n\t\tif (areq->last_rsgl)\n\t\t\taf_alg_link_sg(&areq->last_rsgl->sgl, &rsgl->sgl);\n\n\t\tareq->last_rsgl = rsgl;\n\t\tlen += err;\n\t\tatomic_add(err, &ctx->rcvused);\n\t\trsgl->sg_num_bytes = err;\n\t}\n\n\t*outlen = len;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(af_alg_get_rsgl);\n\nstatic int __init af_alg_init(void)\n{\n\tint err = proto_register(&alg_proto, 0);\n\n\tif (err)\n\t\tgoto out;\n\n\terr = sock_register(&alg_family);\n\tif (err != 0)\n\t\tgoto out_unregister_proto;\n\nout:\n\treturn err;\n\nout_unregister_proto:\n\tproto_unregister(&alg_proto);\n\tgoto out;\n}\n\nstatic void __exit af_alg_exit(void)\n{\n\tsock_unregister(PF_ALG);\n\tproto_unregister(&alg_proto);\n}\n\nmodule_init(af_alg_init);\nmodule_exit(af_alg_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(AF_ALG);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}