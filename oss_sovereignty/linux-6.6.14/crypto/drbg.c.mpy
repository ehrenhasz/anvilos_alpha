{
  "module_name": "drbg.c",
  "hash_id": "042a58ee08d97f121aa82281587852d6eba70f0be4536864da2325ffba7dce25",
  "original_prompt": "Ingested from linux-6.6.14/crypto/drbg.c",
  "human_readable_source": " \n\n#include <crypto/drbg.h>\n#include <crypto/internal/cipher.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n\n \n\n \nstatic const struct drbg_core drbg_cores[] = {\n#ifdef CONFIG_CRYPTO_DRBG_CTR\n\t{\n\t\t.flags = DRBG_CTR | DRBG_STRENGTH128,\n\t\t.statelen = 32,  \n\t\t.blocklen_bytes = 16,\n\t\t.cra_name = \"ctr_aes128\",\n\t\t.backend_cra_name = \"aes\",\n\t}, {\n\t\t.flags = DRBG_CTR | DRBG_STRENGTH192,\n\t\t.statelen = 40,  \n\t\t.blocklen_bytes = 16,\n\t\t.cra_name = \"ctr_aes192\",\n\t\t.backend_cra_name = \"aes\",\n\t}, {\n\t\t.flags = DRBG_CTR | DRBG_STRENGTH256,\n\t\t.statelen = 48,  \n\t\t.blocklen_bytes = 16,\n\t\t.cra_name = \"ctr_aes256\",\n\t\t.backend_cra_name = \"aes\",\n\t},\n#endif  \n#ifdef CONFIG_CRYPTO_DRBG_HASH\n\t{\n\t\t.flags = DRBG_HASH | DRBG_STRENGTH128,\n\t\t.statelen = 55,  \n\t\t.blocklen_bytes = 20,\n\t\t.cra_name = \"sha1\",\n\t\t.backend_cra_name = \"sha1\",\n\t}, {\n\t\t.flags = DRBG_HASH | DRBG_STRENGTH256,\n\t\t.statelen = 111,  \n\t\t.blocklen_bytes = 48,\n\t\t.cra_name = \"sha384\",\n\t\t.backend_cra_name = \"sha384\",\n\t}, {\n\t\t.flags = DRBG_HASH | DRBG_STRENGTH256,\n\t\t.statelen = 111,  \n\t\t.blocklen_bytes = 64,\n\t\t.cra_name = \"sha512\",\n\t\t.backend_cra_name = \"sha512\",\n\t}, {\n\t\t.flags = DRBG_HASH | DRBG_STRENGTH256,\n\t\t.statelen = 55,  \n\t\t.blocklen_bytes = 32,\n\t\t.cra_name = \"sha256\",\n\t\t.backend_cra_name = \"sha256\",\n\t},\n#endif  \n#ifdef CONFIG_CRYPTO_DRBG_HMAC\n\t{\n\t\t.flags = DRBG_HMAC | DRBG_STRENGTH128,\n\t\t.statelen = 20,  \n\t\t.blocklen_bytes = 20,\n\t\t.cra_name = \"hmac_sha1\",\n\t\t.backend_cra_name = \"hmac(sha1)\",\n\t}, {\n\t\t.flags = DRBG_HMAC | DRBG_STRENGTH256,\n\t\t.statelen = 48,  \n\t\t.blocklen_bytes = 48,\n\t\t.cra_name = \"hmac_sha384\",\n\t\t.backend_cra_name = \"hmac(sha384)\",\n\t}, {\n\t\t.flags = DRBG_HMAC | DRBG_STRENGTH256,\n\t\t.statelen = 32,  \n\t\t.blocklen_bytes = 32,\n\t\t.cra_name = \"hmac_sha256\",\n\t\t.backend_cra_name = \"hmac(sha256)\",\n\t}, {\n\t\t.flags = DRBG_HMAC | DRBG_STRENGTH256,\n\t\t.statelen = 64,  \n\t\t.blocklen_bytes = 64,\n\t\t.cra_name = \"hmac_sha512\",\n\t\t.backend_cra_name = \"hmac(sha512)\",\n\t},\n#endif  \n};\n\nstatic int drbg_uninstantiate(struct drbg_state *drbg);\n\n \n\n \nstatic inline unsigned short drbg_sec_strength(drbg_flag_t flags)\n{\n\tswitch (flags & DRBG_STRENGTH_MASK) {\n\tcase DRBG_STRENGTH128:\n\t\treturn 16;\n\tcase DRBG_STRENGTH192:\n\t\treturn 24;\n\tcase DRBG_STRENGTH256:\n\t\treturn 32;\n\tdefault:\n\t\treturn 32;\n\t}\n}\n\n \nstatic int drbg_fips_continuous_test(struct drbg_state *drbg,\n\t\t\t\t     const unsigned char *entropy)\n{\n\tunsigned short entropylen = drbg_sec_strength(drbg->core->flags);\n\tint ret = 0;\n\n\tif (!IS_ENABLED(CONFIG_CRYPTO_FIPS))\n\t\treturn 0;\n\n\t \n\tif (list_empty(&drbg->test_data.list))\n\t\treturn 0;\n\t \n\tif (!fips_enabled)\n\t\treturn 0;\n\n\tif (!drbg->fips_primed) {\n\t\t \n\t\tmemcpy(drbg->prev, entropy, entropylen);\n\t\tdrbg->fips_primed = true;\n\t\t \n\t\treturn -EAGAIN;\n\t}\n\tret = memcmp(drbg->prev, entropy, entropylen);\n\tif (!ret)\n\t\tpanic(\"DRBG continuous self test failed\\n\");\n\tmemcpy(drbg->prev, entropy, entropylen);\n\n\t \n\treturn 0;\n}\n\n \n#if (defined(CONFIG_CRYPTO_DRBG_HASH) || defined(CONFIG_CRYPTO_DRBG_CTR))\nstatic inline void drbg_cpu_to_be32(__u32 val, unsigned char *buf)\n{\n\tstruct s {\n\t\t__be32 conv;\n\t};\n\tstruct s *conversion = (struct s *) buf;\n\n\tconversion->conv = cpu_to_be32(val);\n}\n#endif  \n\n \n\n#ifdef CONFIG_CRYPTO_DRBG_CTR\n#define CRYPTO_DRBG_CTR_STRING \"CTR \"\nMODULE_ALIAS_CRYPTO(\"drbg_pr_ctr_aes256\");\nMODULE_ALIAS_CRYPTO(\"drbg_nopr_ctr_aes256\");\nMODULE_ALIAS_CRYPTO(\"drbg_pr_ctr_aes192\");\nMODULE_ALIAS_CRYPTO(\"drbg_nopr_ctr_aes192\");\nMODULE_ALIAS_CRYPTO(\"drbg_pr_ctr_aes128\");\nMODULE_ALIAS_CRYPTO(\"drbg_nopr_ctr_aes128\");\n\nstatic void drbg_kcapi_symsetkey(struct drbg_state *drbg,\n\t\t\t\t const unsigned char *key);\nstatic int drbg_kcapi_sym(struct drbg_state *drbg, unsigned char *outval,\n\t\t\t  const struct drbg_string *in);\nstatic int drbg_init_sym_kernel(struct drbg_state *drbg);\nstatic int drbg_fini_sym_kernel(struct drbg_state *drbg);\nstatic int drbg_kcapi_sym_ctr(struct drbg_state *drbg,\n\t\t\t      u8 *inbuf, u32 inbuflen,\n\t\t\t      u8 *outbuf, u32 outlen);\n#define DRBG_OUTSCRATCHLEN 256\n\n \nstatic int drbg_ctr_bcc(struct drbg_state *drbg,\n\t\t\tunsigned char *out, const unsigned char *key,\n\t\t\tstruct list_head *in)\n{\n\tint ret = 0;\n\tstruct drbg_string *curr = NULL;\n\tstruct drbg_string data;\n\tshort cnt = 0;\n\n\tdrbg_string_fill(&data, out, drbg_blocklen(drbg));\n\n\t \n\tdrbg_kcapi_symsetkey(drbg, key);\n\tlist_for_each_entry(curr, in, list) {\n\t\tconst unsigned char *pos = curr->buf;\n\t\tsize_t len = curr->len;\n\t\t \n\t\twhile (len) {\n\t\t\t \n\t\t\tif (drbg_blocklen(drbg) == cnt) {\n\t\t\t\tcnt = 0;\n\t\t\t\tret = drbg_kcapi_sym(drbg, out, &data);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tout[cnt] ^= *pos;\n\t\t\tpos++;\n\t\t\tcnt++;\n\t\t\tlen--;\n\t\t}\n\t}\n\t \n\tif (cnt)\n\t\tret = drbg_kcapi_sym(drbg, out, &data);\n\n\treturn ret;\n}\n\n \n\n \nstatic int drbg_ctr_df(struct drbg_state *drbg,\n\t\t       unsigned char *df_data, size_t bytes_to_return,\n\t\t       struct list_head *seedlist)\n{\n\tint ret = -EFAULT;\n\tunsigned char L_N[8];\n\t \n\tstruct drbg_string S1, S2, S4, cipherin;\n\tLIST_HEAD(bcc_list);\n\tunsigned char *pad = df_data + drbg_statelen(drbg);\n\tunsigned char *iv = pad + drbg_blocklen(drbg);\n\tunsigned char *temp = iv + drbg_blocklen(drbg);\n\tsize_t padlen = 0;\n\tunsigned int templen = 0;\n\t \n\tunsigned int i = 0;\n\t \n\tconst unsigned char *K = (unsigned char *)\n\t\t\t   \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\"\n\t\t\t   \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\"\n\t\t\t   \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\"\n\t\t\t   \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\";\n\tunsigned char *X;\n\tsize_t generated_len = 0;\n\tsize_t inputlen = 0;\n\tstruct drbg_string *seed = NULL;\n\n\tmemset(pad, 0, drbg_blocklen(drbg));\n\tmemset(iv, 0, drbg_blocklen(drbg));\n\n\t \n\n\t \n\tif ((512/8) < bytes_to_return)\n\t\treturn -EINVAL;\n\n\t \n\tlist_for_each_entry(seed, seedlist, list)\n\t\tinputlen += seed->len;\n\tdrbg_cpu_to_be32(inputlen, &L_N[0]);\n\n\t \n\tdrbg_cpu_to_be32(bytes_to_return, &L_N[4]);\n\n\t \n\tpadlen = (inputlen + sizeof(L_N) + 1) % (drbg_blocklen(drbg));\n\t \n\tif (padlen)\n\t\tpadlen = drbg_blocklen(drbg) - padlen;\n\t \n\tpadlen++;\n\tpad[0] = 0x80;\n\n\t \n\tdrbg_string_fill(&S1, iv, drbg_blocklen(drbg));\n\tlist_add_tail(&S1.list, &bcc_list);\n\tdrbg_string_fill(&S2, L_N, sizeof(L_N));\n\tlist_add_tail(&S2.list, &bcc_list);\n\tlist_splice_tail(seedlist, &bcc_list);\n\tdrbg_string_fill(&S4, pad, padlen);\n\tlist_add_tail(&S4.list, &bcc_list);\n\n\t \n\twhile (templen < (drbg_keylen(drbg) + (drbg_blocklen(drbg)))) {\n\t\t \n\t\tdrbg_cpu_to_be32(i, iv);\n\t\t \n\t\tret = drbg_ctr_bcc(drbg, temp + templen, K, &bcc_list);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t \n\t\ti++;\n\t\ttemplen += drbg_blocklen(drbg);\n\t}\n\n\t \n\tX = temp + (drbg_keylen(drbg));\n\tdrbg_string_fill(&cipherin, X, drbg_blocklen(drbg));\n\n\t \n\n\t \n\tdrbg_kcapi_symsetkey(drbg, temp);\n\twhile (generated_len < bytes_to_return) {\n\t\tshort blocklen = 0;\n\t\t \n\t\tret = drbg_kcapi_sym(drbg, X, &cipherin);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tblocklen = (drbg_blocklen(drbg) <\n\t\t\t\t(bytes_to_return - generated_len)) ?\n\t\t\t    drbg_blocklen(drbg) :\n\t\t\t\t(bytes_to_return - generated_len);\n\t\t \n\t\tmemcpy(df_data + generated_len, X, blocklen);\n\t\tgenerated_len += blocklen;\n\t}\n\n\tret = 0;\n\nout:\n\tmemset(iv, 0, drbg_blocklen(drbg));\n\tmemset(temp, 0, drbg_statelen(drbg) + drbg_blocklen(drbg));\n\tmemset(pad, 0, drbg_blocklen(drbg));\n\treturn ret;\n}\n\n \nstatic int drbg_ctr_update(struct drbg_state *drbg, struct list_head *seed,\n\t\t\t   int reseed)\n{\n\tint ret = -EFAULT;\n\t \n\tunsigned char *temp = drbg->scratchpad;\n\tunsigned char *df_data = drbg->scratchpad + drbg_statelen(drbg) +\n\t\t\t\t drbg_blocklen(drbg);\n\n\tif (3 > reseed)\n\t\tmemset(df_data, 0, drbg_statelen(drbg));\n\n\tif (!reseed) {\n\t\t \n\t\tcrypto_inc(drbg->V, drbg_blocklen(drbg));\n\n\t\tret = crypto_skcipher_setkey(drbg->ctr_handle, drbg->C,\n\t\t\t\t\t     drbg_keylen(drbg));\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (seed) {\n\t\tret = drbg_ctr_df(drbg, df_data, drbg_statelen(drbg), seed);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = drbg_kcapi_sym_ctr(drbg, df_data, drbg_statelen(drbg),\n\t\t\t\t temp, drbg_statelen(drbg));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = crypto_skcipher_setkey(drbg->ctr_handle, temp,\n\t\t\t\t     drbg_keylen(drbg));\n\tif (ret)\n\t\tgoto out;\n\t \n\tmemcpy(drbg->V, temp + drbg_keylen(drbg), drbg_blocklen(drbg));\n\t \n\tcrypto_inc(drbg->V, drbg_blocklen(drbg));\n\tret = 0;\n\nout:\n\tmemset(temp, 0, drbg_statelen(drbg) + drbg_blocklen(drbg));\n\tif (2 != reseed)\n\t\tmemset(df_data, 0, drbg_statelen(drbg));\n\treturn ret;\n}\n\n \n \nstatic int drbg_ctr_generate(struct drbg_state *drbg,\n\t\t\t     unsigned char *buf, unsigned int buflen,\n\t\t\t     struct list_head *addtl)\n{\n\tint ret;\n\tint len = min_t(int, buflen, INT_MAX);\n\n\t \n\tif (addtl && !list_empty(addtl)) {\n\t\tret = drbg_ctr_update(drbg, addtl, 2);\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\t \n\tret = drbg_kcapi_sym_ctr(drbg, NULL, 0, buf, len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = drbg_ctr_update(drbg, NULL, 3);\n\tif (ret)\n\t\tlen = ret;\n\n\treturn len;\n}\n\nstatic const struct drbg_state_ops drbg_ctr_ops = {\n\t.update\t\t= drbg_ctr_update,\n\t.generate\t= drbg_ctr_generate,\n\t.crypto_init\t= drbg_init_sym_kernel,\n\t.crypto_fini\t= drbg_fini_sym_kernel,\n};\n#endif  \n\n \n\n#if defined(CONFIG_CRYPTO_DRBG_HASH) || defined(CONFIG_CRYPTO_DRBG_HMAC)\nstatic int drbg_kcapi_hash(struct drbg_state *drbg, unsigned char *outval,\n\t\t\t   const struct list_head *in);\nstatic void drbg_kcapi_hmacsetkey(struct drbg_state *drbg,\n\t\t\t\t  const unsigned char *key);\nstatic int drbg_init_hash_kernel(struct drbg_state *drbg);\nstatic int drbg_fini_hash_kernel(struct drbg_state *drbg);\n#endif  \n\n#ifdef CONFIG_CRYPTO_DRBG_HMAC\n#define CRYPTO_DRBG_HMAC_STRING \"HMAC \"\nMODULE_ALIAS_CRYPTO(\"drbg_pr_hmac_sha512\");\nMODULE_ALIAS_CRYPTO(\"drbg_nopr_hmac_sha512\");\nMODULE_ALIAS_CRYPTO(\"drbg_pr_hmac_sha384\");\nMODULE_ALIAS_CRYPTO(\"drbg_nopr_hmac_sha384\");\nMODULE_ALIAS_CRYPTO(\"drbg_pr_hmac_sha256\");\nMODULE_ALIAS_CRYPTO(\"drbg_nopr_hmac_sha256\");\nMODULE_ALIAS_CRYPTO(\"drbg_pr_hmac_sha1\");\nMODULE_ALIAS_CRYPTO(\"drbg_nopr_hmac_sha1\");\n\n \nstatic int drbg_hmac_update(struct drbg_state *drbg, struct list_head *seed,\n\t\t\t    int reseed)\n{\n\tint ret = -EFAULT;\n\tint i = 0;\n\tstruct drbg_string seed1, seed2, vdata;\n\tLIST_HEAD(seedlist);\n\tLIST_HEAD(vdatalist);\n\n\tif (!reseed) {\n\t\t \n\t\tmemset(drbg->V, 1, drbg_statelen(drbg));\n\t\tdrbg_kcapi_hmacsetkey(drbg, drbg->C);\n\t}\n\n\tdrbg_string_fill(&seed1, drbg->V, drbg_statelen(drbg));\n\tlist_add_tail(&seed1.list, &seedlist);\n\t \n\tdrbg_string_fill(&seed2, NULL, 1);\n\tlist_add_tail(&seed2.list, &seedlist);\n\t \n\tif (seed)\n\t\tlist_splice_tail(seed, &seedlist);\n\n\tdrbg_string_fill(&vdata, drbg->V, drbg_statelen(drbg));\n\tlist_add_tail(&vdata.list, &vdatalist);\n\tfor (i = 2; 0 < i; i--) {\n\t\t \n\t\tunsigned char prefix = DRBG_PREFIX0;\n\t\tif (1 == i)\n\t\t\tprefix = DRBG_PREFIX1;\n\t\t \n\t\tseed2.buf = &prefix;\n\t\tret = drbg_kcapi_hash(drbg, drbg->C, &seedlist);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdrbg_kcapi_hmacsetkey(drbg, drbg->C);\n\n\t\t \n\t\tret = drbg_kcapi_hash(drbg, drbg->V, &vdatalist);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!seed)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int drbg_hmac_generate(struct drbg_state *drbg,\n\t\t\t      unsigned char *buf,\n\t\t\t      unsigned int buflen,\n\t\t\t      struct list_head *addtl)\n{\n\tint len = 0;\n\tint ret = 0;\n\tstruct drbg_string data;\n\tLIST_HEAD(datalist);\n\n\t \n\tif (addtl && !list_empty(addtl)) {\n\t\tret = drbg_hmac_update(drbg, addtl, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdrbg_string_fill(&data, drbg->V, drbg_statelen(drbg));\n\tlist_add_tail(&data.list, &datalist);\n\twhile (len < buflen) {\n\t\tunsigned int outlen = 0;\n\t\t \n\t\tret = drbg_kcapi_hash(drbg, drbg->V, &datalist);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\toutlen = (drbg_blocklen(drbg) < (buflen - len)) ?\n\t\t\t  drbg_blocklen(drbg) : (buflen - len);\n\n\t\t \n\t\tmemcpy(buf + len, drbg->V, outlen);\n\t\tlen += outlen;\n\t}\n\n\t \n\tif (addtl && !list_empty(addtl))\n\t\tret = drbg_hmac_update(drbg, addtl, 1);\n\telse\n\t\tret = drbg_hmac_update(drbg, NULL, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic const struct drbg_state_ops drbg_hmac_ops = {\n\t.update\t\t= drbg_hmac_update,\n\t.generate\t= drbg_hmac_generate,\n\t.crypto_init\t= drbg_init_hash_kernel,\n\t.crypto_fini\t= drbg_fini_hash_kernel,\n};\n#endif  \n\n \n\n#ifdef CONFIG_CRYPTO_DRBG_HASH\n#define CRYPTO_DRBG_HASH_STRING \"HASH \"\nMODULE_ALIAS_CRYPTO(\"drbg_pr_sha512\");\nMODULE_ALIAS_CRYPTO(\"drbg_nopr_sha512\");\nMODULE_ALIAS_CRYPTO(\"drbg_pr_sha384\");\nMODULE_ALIAS_CRYPTO(\"drbg_nopr_sha384\");\nMODULE_ALIAS_CRYPTO(\"drbg_pr_sha256\");\nMODULE_ALIAS_CRYPTO(\"drbg_nopr_sha256\");\nMODULE_ALIAS_CRYPTO(\"drbg_pr_sha1\");\nMODULE_ALIAS_CRYPTO(\"drbg_nopr_sha1\");\n\n \nstatic inline void drbg_add_buf(unsigned char *dst, size_t dstlen,\n\t\t\t\tconst unsigned char *add, size_t addlen)\n{\n\t \n\tunsigned char *dstptr;\n\tconst unsigned char *addptr;\n\tunsigned int remainder = 0;\n\tsize_t len = addlen;\n\n\tdstptr = dst + (dstlen-1);\n\taddptr = add + (addlen-1);\n\twhile (len) {\n\t\tremainder += *dstptr + *addptr;\n\t\t*dstptr = remainder & 0xff;\n\t\tremainder >>= 8;\n\t\tlen--; dstptr--; addptr--;\n\t}\n\tlen = dstlen - addlen;\n\twhile (len && remainder > 0) {\n\t\tremainder = *dstptr + 1;\n\t\t*dstptr = remainder & 0xff;\n\t\tremainder >>= 8;\n\t\tlen--; dstptr--;\n\t}\n}\n\n \n\n \nstatic int drbg_hash_df(struct drbg_state *drbg,\n\t\t\tunsigned char *outval, size_t outlen,\n\t\t\tstruct list_head *entropylist)\n{\n\tint ret = 0;\n\tsize_t len = 0;\n\tunsigned char input[5];\n\tunsigned char *tmp = drbg->scratchpad + drbg_statelen(drbg);\n\tstruct drbg_string data;\n\n\t \n\tinput[0] = 1;\n\tdrbg_cpu_to_be32((outlen * 8), &input[1]);\n\n\t \n\tdrbg_string_fill(&data, input, 5);\n\tlist_add(&data.list, entropylist);\n\n\t \n\twhile (len < outlen) {\n\t\tshort blocklen = 0;\n\t\t \n\t\tret = drbg_kcapi_hash(drbg, tmp, entropylist);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t \n\t\tinput[0]++;\n\t\tblocklen = (drbg_blocklen(drbg) < (outlen - len)) ?\n\t\t\t    drbg_blocklen(drbg) : (outlen - len);\n\t\tmemcpy(outval + len, tmp, blocklen);\n\t\tlen += blocklen;\n\t}\n\nout:\n\tmemset(tmp, 0, drbg_blocklen(drbg));\n\treturn ret;\n}\n\n \nstatic int drbg_hash_update(struct drbg_state *drbg, struct list_head *seed,\n\t\t\t    int reseed)\n{\n\tint ret = 0;\n\tstruct drbg_string data1, data2;\n\tLIST_HEAD(datalist);\n\tLIST_HEAD(datalist2);\n\tunsigned char *V = drbg->scratchpad;\n\tunsigned char prefix = DRBG_PREFIX1;\n\n\tif (!seed)\n\t\treturn -EINVAL;\n\n\tif (reseed) {\n\t\t \n\t\tmemcpy(V, drbg->V, drbg_statelen(drbg));\n\t\tdrbg_string_fill(&data1, &prefix, 1);\n\t\tlist_add_tail(&data1.list, &datalist);\n\t\tdrbg_string_fill(&data2, V, drbg_statelen(drbg));\n\t\tlist_add_tail(&data2.list, &datalist);\n\t}\n\tlist_splice_tail(seed, &datalist);\n\n\t \n\tret = drbg_hash_df(drbg, drbg->V, drbg_statelen(drbg), &datalist);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tprefix = DRBG_PREFIX0;\n\tdrbg_string_fill(&data1, &prefix, 1);\n\tlist_add_tail(&data1.list, &datalist2);\n\tdrbg_string_fill(&data2, drbg->V, drbg_statelen(drbg));\n\tlist_add_tail(&data2.list, &datalist2);\n\t \n\tret = drbg_hash_df(drbg, drbg->C, drbg_statelen(drbg), &datalist2);\n\nout:\n\tmemset(drbg->scratchpad, 0, drbg_statelen(drbg));\n\treturn ret;\n}\n\n \nstatic int drbg_hash_process_addtl(struct drbg_state *drbg,\n\t\t\t\t   struct list_head *addtl)\n{\n\tint ret = 0;\n\tstruct drbg_string data1, data2;\n\tLIST_HEAD(datalist);\n\tunsigned char prefix = DRBG_PREFIX2;\n\n\t \n\tif (!addtl || list_empty(addtl))\n\t\treturn 0;\n\n\t \n\tdrbg_string_fill(&data1, &prefix, 1);\n\tdrbg_string_fill(&data2, drbg->V, drbg_statelen(drbg));\n\tlist_add_tail(&data1.list, &datalist);\n\tlist_add_tail(&data2.list, &datalist);\n\tlist_splice_tail(addtl, &datalist);\n\tret = drbg_kcapi_hash(drbg, drbg->scratchpad, &datalist);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tdrbg_add_buf(drbg->V, drbg_statelen(drbg),\n\t\t     drbg->scratchpad, drbg_blocklen(drbg));\n\nout:\n\tmemset(drbg->scratchpad, 0, drbg_blocklen(drbg));\n\treturn ret;\n}\n\n \nstatic int drbg_hash_hashgen(struct drbg_state *drbg,\n\t\t\t     unsigned char *buf,\n\t\t\t     unsigned int buflen)\n{\n\tint len = 0;\n\tint ret = 0;\n\tunsigned char *src = drbg->scratchpad;\n\tunsigned char *dst = drbg->scratchpad + drbg_statelen(drbg);\n\tstruct drbg_string data;\n\tLIST_HEAD(datalist);\n\n\t \n\tmemcpy(src, drbg->V, drbg_statelen(drbg));\n\n\tdrbg_string_fill(&data, src, drbg_statelen(drbg));\n\tlist_add_tail(&data.list, &datalist);\n\twhile (len < buflen) {\n\t\tunsigned int outlen = 0;\n\t\t \n\t\tret = drbg_kcapi_hash(drbg, dst, &datalist);\n\t\tif (ret) {\n\t\t\tlen = ret;\n\t\t\tgoto out;\n\t\t}\n\t\toutlen = (drbg_blocklen(drbg) < (buflen - len)) ?\n\t\t\t  drbg_blocklen(drbg) : (buflen - len);\n\t\t \n\t\tmemcpy(buf + len, dst, outlen);\n\t\tlen += outlen;\n\t\t \n\t\tif (len < buflen)\n\t\t\tcrypto_inc(src, drbg_statelen(drbg));\n\t}\n\nout:\n\tmemset(drbg->scratchpad, 0,\n\t       (drbg_statelen(drbg) + drbg_blocklen(drbg)));\n\treturn len;\n}\n\n \nstatic int drbg_hash_generate(struct drbg_state *drbg,\n\t\t\t      unsigned char *buf, unsigned int buflen,\n\t\t\t      struct list_head *addtl)\n{\n\tint len = 0;\n\tint ret = 0;\n\tunion {\n\t\tunsigned char req[8];\n\t\t__be64 req_int;\n\t} u;\n\tunsigned char prefix = DRBG_PREFIX3;\n\tstruct drbg_string data1, data2;\n\tLIST_HEAD(datalist);\n\n\t \n\tret = drbg_hash_process_addtl(drbg, addtl);\n\tif (ret)\n\t\treturn ret;\n\t \n\tlen = drbg_hash_hashgen(drbg, buf, buflen);\n\n\t \n\t \n\tdrbg_string_fill(&data1, &prefix, 1);\n\tlist_add_tail(&data1.list, &datalist);\n\tdrbg_string_fill(&data2, drbg->V, drbg_statelen(drbg));\n\tlist_add_tail(&data2.list, &datalist);\n\tret = drbg_kcapi_hash(drbg, drbg->scratchpad, &datalist);\n\tif (ret) {\n\t\tlen = ret;\n\t\tgoto out;\n\t}\n\n\t \n\tdrbg_add_buf(drbg->V, drbg_statelen(drbg),\n\t\t     drbg->scratchpad, drbg_blocklen(drbg));\n\tdrbg_add_buf(drbg->V, drbg_statelen(drbg),\n\t\t     drbg->C, drbg_statelen(drbg));\n\tu.req_int = cpu_to_be64(drbg->reseed_ctr);\n\tdrbg_add_buf(drbg->V, drbg_statelen(drbg), u.req, 8);\n\nout:\n\tmemset(drbg->scratchpad, 0, drbg_blocklen(drbg));\n\treturn len;\n}\n\n \nstatic const struct drbg_state_ops drbg_hash_ops = {\n\t.update\t\t= drbg_hash_update,\n\t.generate\t= drbg_hash_generate,\n\t.crypto_init\t= drbg_init_hash_kernel,\n\t.crypto_fini\t= drbg_fini_hash_kernel,\n};\n#endif  \n\n \n\nstatic inline int __drbg_seed(struct drbg_state *drbg, struct list_head *seed,\n\t\t\t      int reseed, enum drbg_seed_state new_seed_state)\n{\n\tint ret = drbg->d_ops->update(drbg, seed, reseed);\n\n\tif (ret)\n\t\treturn ret;\n\n\tdrbg->seeded = new_seed_state;\n\tdrbg->last_seed_time = jiffies;\n\t \n\tdrbg->reseed_ctr = 1;\n\n\tswitch (drbg->seeded) {\n\tcase DRBG_SEED_STATE_UNSEEDED:\n\t\t \n\t\tfallthrough;\n\tcase DRBG_SEED_STATE_PARTIAL:\n\t\t \n\t\tdrbg->reseed_threshold = 50;\n\t\tbreak;\n\n\tcase DRBG_SEED_STATE_FULL:\n\t\t \n\t\tdrbg->reseed_threshold = drbg_max_requests(drbg);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic inline int drbg_get_random_bytes(struct drbg_state *drbg,\n\t\t\t\t\tunsigned char *entropy,\n\t\t\t\t\tunsigned int entropylen)\n{\n\tint ret;\n\n\tdo {\n\t\tget_random_bytes(entropy, entropylen);\n\t\tret = drbg_fips_continuous_test(drbg, entropy);\n\t\tif (ret && ret != -EAGAIN)\n\t\t\treturn ret;\n\t} while (ret);\n\n\treturn 0;\n}\n\nstatic int drbg_seed_from_random(struct drbg_state *drbg)\n{\n\tstruct drbg_string data;\n\tLIST_HEAD(seedlist);\n\tunsigned int entropylen = drbg_sec_strength(drbg->core->flags);\n\tunsigned char entropy[32];\n\tint ret;\n\n\tBUG_ON(!entropylen);\n\tBUG_ON(entropylen > sizeof(entropy));\n\n\tdrbg_string_fill(&data, entropy, entropylen);\n\tlist_add_tail(&data.list, &seedlist);\n\n\tret = drbg_get_random_bytes(drbg, entropy, entropylen);\n\tif (ret)\n\t\tgoto out;\n\n\tret = __drbg_seed(drbg, &seedlist, true, DRBG_SEED_STATE_FULL);\n\nout:\n\tmemzero_explicit(entropy, entropylen);\n\treturn ret;\n}\n\nstatic bool drbg_nopr_reseed_interval_elapsed(struct drbg_state *drbg)\n{\n\tunsigned long next_reseed;\n\n\t \n\tif (list_empty(&drbg->test_data.list))\n\t\treturn false;\n\n\t \n\tnext_reseed = drbg->last_seed_time + 300 * HZ;\n\treturn time_after(jiffies, next_reseed);\n}\n\n \nstatic int drbg_seed(struct drbg_state *drbg, struct drbg_string *pers,\n\t\t     bool reseed)\n{\n\tint ret;\n\tunsigned char entropy[((32 + 16) * 2)];\n\tunsigned int entropylen = drbg_sec_strength(drbg->core->flags);\n\tstruct drbg_string data1;\n\tLIST_HEAD(seedlist);\n\tenum drbg_seed_state new_seed_state = DRBG_SEED_STATE_FULL;\n\n\t \n\tif (pers && pers->len > (drbg_max_addtl(drbg))) {\n\t\tpr_devel(\"DRBG: personalization string too long %zu\\n\",\n\t\t\t pers->len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (list_empty(&drbg->test_data.list)) {\n\t\tdrbg_string_fill(&data1, drbg->test_data.buf,\n\t\t\t\t drbg->test_data.len);\n\t\tpr_devel(\"DRBG: using test entropy\\n\");\n\t} else {\n\t\t \n\t\tBUG_ON(!entropylen);\n\t\tif (!reseed)\n\t\t\tentropylen = ((entropylen + 1) / 2) * 3;\n\t\tBUG_ON((entropylen * 2) > sizeof(entropy));\n\n\t\t \n\t\tif (!rng_is_initialized())\n\t\t\tnew_seed_state = DRBG_SEED_STATE_PARTIAL;\n\n\t\tret = drbg_get_random_bytes(drbg, entropy, entropylen);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!drbg->jent) {\n\t\t\tdrbg_string_fill(&data1, entropy, entropylen);\n\t\t\tpr_devel(\"DRBG: (re)seeding with %u bytes of entropy\\n\",\n\t\t\t\t entropylen);\n\t\t} else {\n\t\t\t \n\t\t\tret = crypto_rng_get_bytes(drbg->jent,\n\t\t\t\t\t\t   entropy + entropylen,\n\t\t\t\t\t\t   entropylen);\n\t\t\tif (fips_enabled && ret) {\n\t\t\t\tpr_devel(\"DRBG: jent failed with %d\\n\", ret);\n\n\t\t\t\t \n\t\t\t\tif (!reseed || ret != -EAGAIN)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdrbg_string_fill(&data1, entropy, entropylen * 2);\n\t\t\tpr_devel(\"DRBG: (re)seeding with %u bytes of entropy\\n\",\n\t\t\t\t entropylen * 2);\n\t\t}\n\t}\n\tlist_add_tail(&data1.list, &seedlist);\n\n\t \n\tif (pers && pers->buf && 0 < pers->len) {\n\t\tlist_add_tail(&pers->list, &seedlist);\n\t\tpr_devel(\"DRBG: using personalization string\\n\");\n\t}\n\n\tif (!reseed) {\n\t\tmemset(drbg->V, 0, drbg_statelen(drbg));\n\t\tmemset(drbg->C, 0, drbg_statelen(drbg));\n\t}\n\n\tret = __drbg_seed(drbg, &seedlist, reseed, new_seed_state);\n\nout:\n\tmemzero_explicit(entropy, entropylen * 2);\n\n\treturn ret;\n}\n\n \nstatic inline void drbg_dealloc_state(struct drbg_state *drbg)\n{\n\tif (!drbg)\n\t\treturn;\n\tkfree_sensitive(drbg->Vbuf);\n\tdrbg->Vbuf = NULL;\n\tdrbg->V = NULL;\n\tkfree_sensitive(drbg->Cbuf);\n\tdrbg->Cbuf = NULL;\n\tdrbg->C = NULL;\n\tkfree_sensitive(drbg->scratchpadbuf);\n\tdrbg->scratchpadbuf = NULL;\n\tdrbg->reseed_ctr = 0;\n\tdrbg->d_ops = NULL;\n\tdrbg->core = NULL;\n\tif (IS_ENABLED(CONFIG_CRYPTO_FIPS)) {\n\t\tkfree_sensitive(drbg->prev);\n\t\tdrbg->prev = NULL;\n\t\tdrbg->fips_primed = false;\n\t}\n}\n\n \nstatic inline int drbg_alloc_state(struct drbg_state *drbg)\n{\n\tint ret = -ENOMEM;\n\tunsigned int sb_size = 0;\n\n\tswitch (drbg->core->flags & DRBG_TYPE_MASK) {\n#ifdef CONFIG_CRYPTO_DRBG_HMAC\n\tcase DRBG_HMAC:\n\t\tdrbg->d_ops = &drbg_hmac_ops;\n\t\tbreak;\n#endif  \n#ifdef CONFIG_CRYPTO_DRBG_HASH\n\tcase DRBG_HASH:\n\t\tdrbg->d_ops = &drbg_hash_ops;\n\t\tbreak;\n#endif  \n#ifdef CONFIG_CRYPTO_DRBG_CTR\n\tcase DRBG_CTR:\n\t\tdrbg->d_ops = &drbg_ctr_ops;\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\n\tret = drbg->d_ops->crypto_init(drbg);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdrbg->Vbuf = kmalloc(drbg_statelen(drbg) + ret, GFP_KERNEL);\n\tif (!drbg->Vbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto fini;\n\t}\n\tdrbg->V = PTR_ALIGN(drbg->Vbuf, ret + 1);\n\tdrbg->Cbuf = kmalloc(drbg_statelen(drbg) + ret, GFP_KERNEL);\n\tif (!drbg->Cbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto fini;\n\t}\n\tdrbg->C = PTR_ALIGN(drbg->Cbuf, ret + 1);\n\t \n\tif (drbg->core->flags & DRBG_HMAC)\n\t\tsb_size = 0;\n\telse if (drbg->core->flags & DRBG_CTR)\n\t\tsb_size = drbg_statelen(drbg) + drbg_blocklen(drbg) +  \n\t\t\t  drbg_statelen(drbg) +\t \n\t\t\t  drbg_blocklen(drbg) +\t \n\t\t\t  drbg_blocklen(drbg) +\t \n\t\t\t  drbg_statelen(drbg) + drbg_blocklen(drbg);  \n\telse\n\t\tsb_size = drbg_statelen(drbg) + drbg_blocklen(drbg);\n\n\tif (0 < sb_size) {\n\t\tdrbg->scratchpadbuf = kzalloc(sb_size + ret, GFP_KERNEL);\n\t\tif (!drbg->scratchpadbuf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fini;\n\t\t}\n\t\tdrbg->scratchpad = PTR_ALIGN(drbg->scratchpadbuf, ret + 1);\n\t}\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_FIPS)) {\n\t\tdrbg->prev = kzalloc(drbg_sec_strength(drbg->core->flags),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!drbg->prev) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fini;\n\t\t}\n\t\tdrbg->fips_primed = false;\n\t}\n\n\treturn 0;\n\nfini:\n\tdrbg->d_ops->crypto_fini(drbg);\nerr:\n\tdrbg_dealloc_state(drbg);\n\treturn ret;\n}\n\n \n\n \nstatic int drbg_generate(struct drbg_state *drbg,\n\t\t\t unsigned char *buf, unsigned int buflen,\n\t\t\t struct drbg_string *addtl)\n{\n\tint len = 0;\n\tLIST_HEAD(addtllist);\n\n\tif (!drbg->core) {\n\t\tpr_devel(\"DRBG: not yet seeded\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (0 == buflen || !buf) {\n\t\tpr_devel(\"DRBG: no output buffer provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (addtl && NULL == addtl->buf && 0 < addtl->len) {\n\t\tpr_devel(\"DRBG: wrong format of additional information\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlen = -EINVAL;\n\tif (buflen > (drbg_max_request_bytes(drbg))) {\n\t\tpr_devel(\"DRBG: requested random numbers too large %u\\n\",\n\t\t\t buflen);\n\t\tgoto err;\n\t}\n\n\t \n\n\t \n\tif (addtl && addtl->len > (drbg_max_addtl(drbg))) {\n\t\tpr_devel(\"DRBG: additional information string too long %zu\\n\",\n\t\t\t addtl->len);\n\t\tgoto err;\n\t}\n\t \n\n\t \n\tif (drbg->reseed_threshold < drbg->reseed_ctr)\n\t\tdrbg->seeded = DRBG_SEED_STATE_UNSEEDED;\n\n\tif (drbg->pr || drbg->seeded == DRBG_SEED_STATE_UNSEEDED) {\n\t\tpr_devel(\"DRBG: reseeding before generation (prediction \"\n\t\t\t \"resistance: %s, state %s)\\n\",\n\t\t\t drbg->pr ? \"true\" : \"false\",\n\t\t\t (drbg->seeded ==  DRBG_SEED_STATE_FULL ?\n\t\t\t  \"seeded\" : \"unseeded\"));\n\t\t \n\t\tlen = drbg_seed(drbg, addtl, true);\n\t\tif (len)\n\t\t\tgoto err;\n\t\t \n\t\taddtl = NULL;\n\t} else if (rng_is_initialized() &&\n\t\t   (drbg->seeded == DRBG_SEED_STATE_PARTIAL ||\n\t\t    drbg_nopr_reseed_interval_elapsed(drbg))) {\n\t\tlen = drbg_seed_from_random(drbg);\n\t\tif (len)\n\t\t\tgoto err;\n\t}\n\n\tif (addtl && 0 < addtl->len)\n\t\tlist_add_tail(&addtl->list, &addtllist);\n\t \n\tlen = drbg->d_ops->generate(drbg, buf, buflen, &addtllist);\n\n\t \n\tdrbg->reseed_ctr++;\n\tif (0 >= len)\n\t\tgoto err;\n\n\t \n#if 0\n\tif (drbg->reseed_ctr && !(drbg->reseed_ctr % 4096)) {\n\t\tint err = 0;\n\t\tpr_devel(\"DRBG: start to perform self test\\n\");\n\t\tif (drbg->core->flags & DRBG_HMAC)\n\t\t\terr = alg_test(\"drbg_pr_hmac_sha256\",\n\t\t\t\t       \"drbg_pr_hmac_sha256\", 0, 0);\n\t\telse if (drbg->core->flags & DRBG_CTR)\n\t\t\terr = alg_test(\"drbg_pr_ctr_aes128\",\n\t\t\t\t       \"drbg_pr_ctr_aes128\", 0, 0);\n\t\telse\n\t\t\terr = alg_test(\"drbg_pr_sha256\",\n\t\t\t\t       \"drbg_pr_sha256\", 0, 0);\n\t\tif (err) {\n\t\t\tpr_err(\"DRBG: periodical self test failed\\n\");\n\t\t\t \n\t\t\tdrbg_uninstantiate(drbg);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpr_devel(\"DRBG: self test successful\\n\");\n\t\t}\n\t}\n#endif\n\n\t \n\tlen = 0;\nerr:\n\treturn len;\n}\n\n \nstatic int drbg_generate_long(struct drbg_state *drbg,\n\t\t\t      unsigned char *buf, unsigned int buflen,\n\t\t\t      struct drbg_string *addtl)\n{\n\tunsigned int len = 0;\n\tunsigned int slice = 0;\n\tdo {\n\t\tint err = 0;\n\t\tunsigned int chunk = 0;\n\t\tslice = ((buflen - len) / drbg_max_request_bytes(drbg));\n\t\tchunk = slice ? drbg_max_request_bytes(drbg) : (buflen - len);\n\t\tmutex_lock(&drbg->drbg_mutex);\n\t\terr = drbg_generate(drbg, buf + len, chunk, addtl);\n\t\tmutex_unlock(&drbg->drbg_mutex);\n\t\tif (0 > err)\n\t\t\treturn err;\n\t\tlen += chunk;\n\t} while (slice > 0 && (len < buflen));\n\treturn 0;\n}\n\nstatic int drbg_prepare_hrng(struct drbg_state *drbg)\n{\n\t \n\tif (list_empty(&drbg->test_data.list))\n\t\treturn 0;\n\n\tdrbg->jent = crypto_alloc_rng(\"jitterentropy_rng\", 0, 0);\n\tif (IS_ERR(drbg->jent)) {\n\t\tconst int err = PTR_ERR(drbg->jent);\n\n\t\tdrbg->jent = NULL;\n\t\tif (fips_enabled)\n\t\t\treturn err;\n\t\tpr_info(\"DRBG: Continuing without Jitter RNG\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic int drbg_instantiate(struct drbg_state *drbg, struct drbg_string *pers,\n\t\t\t    int coreref, bool pr)\n{\n\tint ret;\n\tbool reseed = true;\n\n\tpr_devel(\"DRBG: Initializing DRBG core %d with prediction resistance \"\n\t\t \"%s\\n\", coreref, pr ? \"enabled\" : \"disabled\");\n\tmutex_lock(&drbg->drbg_mutex);\n\n\t \n\n\t \n\n\t \n\n\tif (!drbg->core) {\n\t\tdrbg->core = &drbg_cores[coreref];\n\t\tdrbg->pr = pr;\n\t\tdrbg->seeded = DRBG_SEED_STATE_UNSEEDED;\n\t\tdrbg->last_seed_time = 0;\n\t\tdrbg->reseed_threshold = drbg_max_requests(drbg);\n\n\t\tret = drbg_alloc_state(drbg);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tret = drbg_prepare_hrng(drbg);\n\t\tif (ret)\n\t\t\tgoto free_everything;\n\n\t\treseed = false;\n\t}\n\n\tret = drbg_seed(drbg, pers, reseed);\n\n\tif (ret && !reseed)\n\t\tgoto free_everything;\n\n\tmutex_unlock(&drbg->drbg_mutex);\n\treturn ret;\n\nunlock:\n\tmutex_unlock(&drbg->drbg_mutex);\n\treturn ret;\n\nfree_everything:\n\tmutex_unlock(&drbg->drbg_mutex);\n\tdrbg_uninstantiate(drbg);\n\treturn ret;\n}\n\n \nstatic int drbg_uninstantiate(struct drbg_state *drbg)\n{\n\tif (!IS_ERR_OR_NULL(drbg->jent))\n\t\tcrypto_free_rng(drbg->jent);\n\tdrbg->jent = NULL;\n\n\tif (drbg->d_ops)\n\t\tdrbg->d_ops->crypto_fini(drbg);\n\tdrbg_dealloc_state(drbg);\n\t \n\treturn 0;\n}\n\n \nstatic void drbg_kcapi_set_entropy(struct crypto_rng *tfm,\n\t\t\t\t   const u8 *data, unsigned int len)\n{\n\tstruct drbg_state *drbg = crypto_rng_ctx(tfm);\n\n\tmutex_lock(&drbg->drbg_mutex);\n\tdrbg_string_fill(&drbg->test_data, data, len);\n\tmutex_unlock(&drbg->drbg_mutex);\n}\n\n \n\n#if defined(CONFIG_CRYPTO_DRBG_HASH) || defined(CONFIG_CRYPTO_DRBG_HMAC)\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic int drbg_init_hash_kernel(struct drbg_state *drbg)\n{\n\tstruct sdesc *sdesc;\n\tstruct crypto_shash *tfm;\n\n\ttfm = crypto_alloc_shash(drbg->core->backend_cra_name, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tpr_info(\"DRBG: could not allocate digest TFM handle: %s\\n\",\n\t\t\t\tdrbg->core->backend_cra_name);\n\t\treturn PTR_ERR(tfm);\n\t}\n\tBUG_ON(drbg_blocklen(drbg) != crypto_shash_digestsize(tfm));\n\tsdesc = kzalloc(sizeof(struct shash_desc) + crypto_shash_descsize(tfm),\n\t\t\tGFP_KERNEL);\n\tif (!sdesc) {\n\t\tcrypto_free_shash(tfm);\n\t\treturn -ENOMEM;\n\t}\n\n\tsdesc->shash.tfm = tfm;\n\tdrbg->priv_data = sdesc;\n\n\treturn crypto_shash_alignmask(tfm);\n}\n\nstatic int drbg_fini_hash_kernel(struct drbg_state *drbg)\n{\n\tstruct sdesc *sdesc = drbg->priv_data;\n\tif (sdesc) {\n\t\tcrypto_free_shash(sdesc->shash.tfm);\n\t\tkfree_sensitive(sdesc);\n\t}\n\tdrbg->priv_data = NULL;\n\treturn 0;\n}\n\nstatic void drbg_kcapi_hmacsetkey(struct drbg_state *drbg,\n\t\t\t\t  const unsigned char *key)\n{\n\tstruct sdesc *sdesc = drbg->priv_data;\n\n\tcrypto_shash_setkey(sdesc->shash.tfm, key, drbg_statelen(drbg));\n}\n\nstatic int drbg_kcapi_hash(struct drbg_state *drbg, unsigned char *outval,\n\t\t\t   const struct list_head *in)\n{\n\tstruct sdesc *sdesc = drbg->priv_data;\n\tstruct drbg_string *input = NULL;\n\n\tcrypto_shash_init(&sdesc->shash);\n\tlist_for_each_entry(input, in, list)\n\t\tcrypto_shash_update(&sdesc->shash, input->buf, input->len);\n\treturn crypto_shash_final(&sdesc->shash, outval);\n}\n#endif  \n\n#ifdef CONFIG_CRYPTO_DRBG_CTR\nstatic int drbg_fini_sym_kernel(struct drbg_state *drbg)\n{\n\tstruct crypto_cipher *tfm =\n\t\t(struct crypto_cipher *)drbg->priv_data;\n\tif (tfm)\n\t\tcrypto_free_cipher(tfm);\n\tdrbg->priv_data = NULL;\n\n\tif (drbg->ctr_handle)\n\t\tcrypto_free_skcipher(drbg->ctr_handle);\n\tdrbg->ctr_handle = NULL;\n\n\tif (drbg->ctr_req)\n\t\tskcipher_request_free(drbg->ctr_req);\n\tdrbg->ctr_req = NULL;\n\n\tkfree(drbg->outscratchpadbuf);\n\tdrbg->outscratchpadbuf = NULL;\n\n\treturn 0;\n}\n\nstatic int drbg_init_sym_kernel(struct drbg_state *drbg)\n{\n\tstruct crypto_cipher *tfm;\n\tstruct crypto_skcipher *sk_tfm;\n\tstruct skcipher_request *req;\n\tunsigned int alignmask;\n\tchar ctr_name[CRYPTO_MAX_ALG_NAME];\n\n\ttfm = crypto_alloc_cipher(drbg->core->backend_cra_name, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tpr_info(\"DRBG: could not allocate cipher TFM handle: %s\\n\",\n\t\t\t\tdrbg->core->backend_cra_name);\n\t\treturn PTR_ERR(tfm);\n\t}\n\tBUG_ON(drbg_blocklen(drbg) != crypto_cipher_blocksize(tfm));\n\tdrbg->priv_data = tfm;\n\n\tif (snprintf(ctr_name, CRYPTO_MAX_ALG_NAME, \"ctr(%s)\",\n\t    drbg->core->backend_cra_name) >= CRYPTO_MAX_ALG_NAME) {\n\t\tdrbg_fini_sym_kernel(drbg);\n\t\treturn -EINVAL;\n\t}\n\tsk_tfm = crypto_alloc_skcipher(ctr_name, 0, 0);\n\tif (IS_ERR(sk_tfm)) {\n\t\tpr_info(\"DRBG: could not allocate CTR cipher TFM handle: %s\\n\",\n\t\t\t\tctr_name);\n\t\tdrbg_fini_sym_kernel(drbg);\n\t\treturn PTR_ERR(sk_tfm);\n\t}\n\tdrbg->ctr_handle = sk_tfm;\n\tcrypto_init_wait(&drbg->ctr_wait);\n\n\treq = skcipher_request_alloc(sk_tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_info(\"DRBG: could not allocate request queue\\n\");\n\t\tdrbg_fini_sym_kernel(drbg);\n\t\treturn -ENOMEM;\n\t}\n\tdrbg->ctr_req = req;\n\tskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t\t\tCRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t\tcrypto_req_done, &drbg->ctr_wait);\n\n\talignmask = crypto_skcipher_alignmask(sk_tfm);\n\tdrbg->outscratchpadbuf = kmalloc(DRBG_OUTSCRATCHLEN + alignmask,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!drbg->outscratchpadbuf) {\n\t\tdrbg_fini_sym_kernel(drbg);\n\t\treturn -ENOMEM;\n\t}\n\tdrbg->outscratchpad = (u8 *)PTR_ALIGN(drbg->outscratchpadbuf,\n\t\t\t\t\t      alignmask + 1);\n\n\tsg_init_table(&drbg->sg_in, 1);\n\tsg_init_one(&drbg->sg_out, drbg->outscratchpad, DRBG_OUTSCRATCHLEN);\n\n\treturn alignmask;\n}\n\nstatic void drbg_kcapi_symsetkey(struct drbg_state *drbg,\n\t\t\t\t const unsigned char *key)\n{\n\tstruct crypto_cipher *tfm = drbg->priv_data;\n\n\tcrypto_cipher_setkey(tfm, key, (drbg_keylen(drbg)));\n}\n\nstatic int drbg_kcapi_sym(struct drbg_state *drbg, unsigned char *outval,\n\t\t\t  const struct drbg_string *in)\n{\n\tstruct crypto_cipher *tfm = drbg->priv_data;\n\n\t \n\tBUG_ON(in->len < drbg_blocklen(drbg));\n\tcrypto_cipher_encrypt_one(tfm, outval, in->buf);\n\treturn 0;\n}\n\nstatic int drbg_kcapi_sym_ctr(struct drbg_state *drbg,\n\t\t\t      u8 *inbuf, u32 inlen,\n\t\t\t      u8 *outbuf, u32 outlen)\n{\n\tstruct scatterlist *sg_in = &drbg->sg_in, *sg_out = &drbg->sg_out;\n\tu32 scratchpad_use = min_t(u32, outlen, DRBG_OUTSCRATCHLEN);\n\tint ret;\n\n\tif (inbuf) {\n\t\t \n\t\tsg_set_buf(sg_in, inbuf, inlen);\n\t} else {\n\t\t \n\t\tinlen = scratchpad_use;\n\t\tmemset(drbg->outscratchpad, 0, scratchpad_use);\n\t\tsg_set_buf(sg_in, drbg->outscratchpad, scratchpad_use);\n\t}\n\n\twhile (outlen) {\n\t\tu32 cryptlen = min3(inlen, outlen, (u32)DRBG_OUTSCRATCHLEN);\n\n\t\t \n\t\tskcipher_request_set_crypt(drbg->ctr_req, sg_in, sg_out,\n\t\t\t\t\t   cryptlen, drbg->V);\n\t\tret = crypto_wait_req(crypto_skcipher_encrypt(drbg->ctr_req),\n\t\t\t\t\t&drbg->ctr_wait);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tcrypto_init_wait(&drbg->ctr_wait);\n\n\t\tmemcpy(outbuf, drbg->outscratchpad, cryptlen);\n\t\tmemzero_explicit(drbg->outscratchpad, cryptlen);\n\n\t\toutlen -= cryptlen;\n\t\toutbuf += cryptlen;\n\t}\n\tret = 0;\n\nout:\n\treturn ret;\n}\n#endif  \n\n \n\n \nstatic inline void drbg_convert_tfm_core(const char *cra_driver_name,\n\t\t\t\t\t int *coreref, bool *pr)\n{\n\tint i = 0;\n\tsize_t start = 0;\n\tint len = 0;\n\n\t*pr = true;\n\t \n\tif (!memcmp(cra_driver_name, \"drbg_nopr_\", 10)) {\n\t\tstart = 10;\n\t\t*pr = false;\n\t} else if (!memcmp(cra_driver_name, \"drbg_pr_\", 8)) {\n\t\tstart = 8;\n\t} else {\n\t\treturn;\n\t}\n\n\t \n\tlen = strlen(cra_driver_name) - start;\n\tfor (i = 0; ARRAY_SIZE(drbg_cores) > i; i++) {\n\t\tif (!memcmp(cra_driver_name + start, drbg_cores[i].cra_name,\n\t\t\t    len)) {\n\t\t\t*coreref = i;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int drbg_kcapi_init(struct crypto_tfm *tfm)\n{\n\tstruct drbg_state *drbg = crypto_tfm_ctx(tfm);\n\n\tmutex_init(&drbg->drbg_mutex);\n\n\treturn 0;\n}\n\nstatic void drbg_kcapi_cleanup(struct crypto_tfm *tfm)\n{\n\tdrbg_uninstantiate(crypto_tfm_ctx(tfm));\n}\n\n \nstatic int drbg_kcapi_random(struct crypto_rng *tfm,\n\t\t\t     const u8 *src, unsigned int slen,\n\t\t\t     u8 *dst, unsigned int dlen)\n{\n\tstruct drbg_state *drbg = crypto_rng_ctx(tfm);\n\tstruct drbg_string *addtl = NULL;\n\tstruct drbg_string string;\n\n\tif (slen) {\n\t\t \n\t\tdrbg_string_fill(&string, src, slen);\n\t\taddtl = &string;\n\t}\n\n\treturn drbg_generate_long(drbg, dst, dlen, addtl);\n}\n\n \nstatic int drbg_kcapi_seed(struct crypto_rng *tfm,\n\t\t\t   const u8 *seed, unsigned int slen)\n{\n\tstruct drbg_state *drbg = crypto_rng_ctx(tfm);\n\tstruct crypto_tfm *tfm_base = crypto_rng_tfm(tfm);\n\tbool pr = false;\n\tstruct drbg_string string;\n\tstruct drbg_string *seed_string = NULL;\n\tint coreref = 0;\n\n\tdrbg_convert_tfm_core(crypto_tfm_alg_driver_name(tfm_base), &coreref,\n\t\t\t      &pr);\n\tif (0 < slen) {\n\t\tdrbg_string_fill(&string, seed, slen);\n\t\tseed_string = &string;\n\t}\n\n\treturn drbg_instantiate(drbg, seed_string, coreref, pr);\n}\n\n \n\n \nstatic inline int __init drbg_healthcheck_sanity(void)\n{\n\tint len = 0;\n#define OUTBUFLEN 16\n\tunsigned char buf[OUTBUFLEN];\n\tstruct drbg_state *drbg = NULL;\n\tint ret;\n\tint rc = -EFAULT;\n\tbool pr = false;\n\tint coreref = 0;\n\tstruct drbg_string addtl;\n\tsize_t max_addtllen, max_request_bytes;\n\n\t \n\tif (!fips_enabled)\n\t\treturn 0;\n\n#ifdef CONFIG_CRYPTO_DRBG_CTR\n\tdrbg_convert_tfm_core(\"drbg_nopr_ctr_aes128\", &coreref, &pr);\n#elif defined CONFIG_CRYPTO_DRBG_HASH\n\tdrbg_convert_tfm_core(\"drbg_nopr_sha256\", &coreref, &pr);\n#else\n\tdrbg_convert_tfm_core(\"drbg_nopr_hmac_sha256\", &coreref, &pr);\n#endif\n\n\tdrbg = kzalloc(sizeof(struct drbg_state), GFP_KERNEL);\n\tif (!drbg)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&drbg->drbg_mutex);\n\tdrbg->core = &drbg_cores[coreref];\n\tdrbg->reseed_threshold = drbg_max_requests(drbg);\n\n\t \n\n\tmax_addtllen = drbg_max_addtl(drbg);\n\tmax_request_bytes = drbg_max_request_bytes(drbg);\n\tdrbg_string_fill(&addtl, buf, max_addtllen + 1);\n\t \n\tlen = drbg_generate(drbg, buf, OUTBUFLEN, &addtl);\n\tBUG_ON(0 < len);\n\t \n\tlen = drbg_generate(drbg, buf, (max_request_bytes + 1), NULL);\n\tBUG_ON(0 < len);\n\n\t \n\tret = drbg_seed(drbg, &addtl, false);\n\tBUG_ON(0 == ret);\n\t \n\trc = 0;\n\n\tpr_devel(\"DRBG: Sanity tests for failure code paths successfully \"\n\t\t \"completed\\n\");\n\n\tkfree(drbg);\n\treturn rc;\n}\n\nstatic struct rng_alg drbg_algs[22];\n\n \nstatic inline void __init drbg_fill_array(struct rng_alg *alg,\n\t\t\t\t\t  const struct drbg_core *core, int pr)\n{\n\tint pos = 0;\n\tstatic int priority = 200;\n\n\tmemcpy(alg->base.cra_name, \"stdrng\", 6);\n\tif (pr) {\n\t\tmemcpy(alg->base.cra_driver_name, \"drbg_pr_\", 8);\n\t\tpos = 8;\n\t} else {\n\t\tmemcpy(alg->base.cra_driver_name, \"drbg_nopr_\", 10);\n\t\tpos = 10;\n\t}\n\tmemcpy(alg->base.cra_driver_name + pos, core->cra_name,\n\t       strlen(core->cra_name));\n\n\talg->base.cra_priority = priority;\n\tpriority++;\n\t \n\tif (fips_enabled)\n\t\talg->base.cra_priority += 200;\n\n\talg->base.cra_ctxsize \t= sizeof(struct drbg_state);\n\talg->base.cra_module\t= THIS_MODULE;\n\talg->base.cra_init\t= drbg_kcapi_init;\n\talg->base.cra_exit\t= drbg_kcapi_cleanup;\n\talg->generate\t\t= drbg_kcapi_random;\n\talg->seed\t\t= drbg_kcapi_seed;\n\talg->set_ent\t\t= drbg_kcapi_set_entropy;\n\talg->seedsize\t\t= 0;\n}\n\nstatic int __init drbg_init(void)\n{\n\tunsigned int i = 0;  \n\tunsigned int j = 0;  \n\tint ret;\n\n\tret = drbg_healthcheck_sanity();\n\tif (ret)\n\t\treturn ret;\n\n\tif (ARRAY_SIZE(drbg_cores) * 2 > ARRAY_SIZE(drbg_algs)) {\n\t\tpr_info(\"DRBG: Cannot register all DRBG types\"\n\t\t\t\"(slots needed: %zu, slots available: %zu)\\n\",\n\t\t\tARRAY_SIZE(drbg_cores) * 2, ARRAY_SIZE(drbg_algs));\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tfor (j = 0; ARRAY_SIZE(drbg_cores) > j; j++, i++)\n\t\tdrbg_fill_array(&drbg_algs[i], &drbg_cores[j], 1);\n\tfor (j = 0; ARRAY_SIZE(drbg_cores) > j; j++, i++)\n\t\tdrbg_fill_array(&drbg_algs[i], &drbg_cores[j], 0);\n\treturn crypto_register_rngs(drbg_algs, (ARRAY_SIZE(drbg_cores) * 2));\n}\n\nstatic void __exit drbg_exit(void)\n{\n\tcrypto_unregister_rngs(drbg_algs, (ARRAY_SIZE(drbg_cores) * 2));\n}\n\nsubsys_initcall(drbg_init);\nmodule_exit(drbg_exit);\n#ifndef CRYPTO_DRBG_HASH_STRING\n#define CRYPTO_DRBG_HASH_STRING \"\"\n#endif\n#ifndef CRYPTO_DRBG_HMAC_STRING\n#define CRYPTO_DRBG_HMAC_STRING \"\"\n#endif\n#ifndef CRYPTO_DRBG_CTR_STRING\n#define CRYPTO_DRBG_CTR_STRING \"\"\n#endif\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Stephan Mueller <smueller@chronox.de>\");\nMODULE_DESCRIPTION(\"NIST SP800-90A Deterministic Random Bit Generator (DRBG) \"\n\t\t   \"using following cores: \"\n\t\t   CRYPTO_DRBG_HASH_STRING\n\t\t   CRYPTO_DRBG_HMAC_STRING\n\t\t   CRYPTO_DRBG_CTR_STRING);\nMODULE_ALIAS_CRYPTO(\"stdrng\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}