{
  "module_name": "poly1305_generic.c",
  "hash_id": "13c87a4794f950f6f2c9e184279827d12fb94c0a92410a3fbe52372c3f8763e3",
  "original_prompt": "Ingested from linux-6.6.14/crypto/poly1305_generic.c",
  "human_readable_source": " \n\n#include <crypto/algapi.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/poly1305.h>\n#include <linux/crypto.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n\nstatic int crypto_poly1305_init(struct shash_desc *desc)\n{\n\tstruct poly1305_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\tpoly1305_core_init(&dctx->h);\n\tdctx->buflen = 0;\n\tdctx->rset = 0;\n\tdctx->sset = false;\n\n\treturn 0;\n}\n\nstatic unsigned int crypto_poly1305_setdesckey(struct poly1305_desc_ctx *dctx,\n\t\t\t\t\t       const u8 *src, unsigned int srclen)\n{\n\tif (!dctx->sset) {\n\t\tif (!dctx->rset && srclen >= POLY1305_BLOCK_SIZE) {\n\t\t\tpoly1305_core_setkey(&dctx->core_r, src);\n\t\t\tsrc += POLY1305_BLOCK_SIZE;\n\t\t\tsrclen -= POLY1305_BLOCK_SIZE;\n\t\t\tdctx->rset = 2;\n\t\t}\n\t\tif (srclen >= POLY1305_BLOCK_SIZE) {\n\t\t\tdctx->s[0] = get_unaligned_le32(src +  0);\n\t\t\tdctx->s[1] = get_unaligned_le32(src +  4);\n\t\t\tdctx->s[2] = get_unaligned_le32(src +  8);\n\t\t\tdctx->s[3] = get_unaligned_le32(src + 12);\n\t\t\tsrc += POLY1305_BLOCK_SIZE;\n\t\t\tsrclen -= POLY1305_BLOCK_SIZE;\n\t\t\tdctx->sset = true;\n\t\t}\n\t}\n\treturn srclen;\n}\n\nstatic void poly1305_blocks(struct poly1305_desc_ctx *dctx, const u8 *src,\n\t\t\t    unsigned int srclen)\n{\n\tunsigned int datalen;\n\n\tif (unlikely(!dctx->sset)) {\n\t\tdatalen = crypto_poly1305_setdesckey(dctx, src, srclen);\n\t\tsrc += srclen - datalen;\n\t\tsrclen = datalen;\n\t}\n\n\tpoly1305_core_blocks(&dctx->h, &dctx->core_r, src,\n\t\t\t     srclen / POLY1305_BLOCK_SIZE, 1);\n}\n\nstatic int crypto_poly1305_update(struct shash_desc *desc,\n\t\t\t\t  const u8 *src, unsigned int srclen)\n{\n\tstruct poly1305_desc_ctx *dctx = shash_desc_ctx(desc);\n\tunsigned int bytes;\n\n\tif (unlikely(dctx->buflen)) {\n\t\tbytes = min(srclen, POLY1305_BLOCK_SIZE - dctx->buflen);\n\t\tmemcpy(dctx->buf + dctx->buflen, src, bytes);\n\t\tsrc += bytes;\n\t\tsrclen -= bytes;\n\t\tdctx->buflen += bytes;\n\n\t\tif (dctx->buflen == POLY1305_BLOCK_SIZE) {\n\t\t\tpoly1305_blocks(dctx, dctx->buf,\n\t\t\t\t\tPOLY1305_BLOCK_SIZE);\n\t\t\tdctx->buflen = 0;\n\t\t}\n\t}\n\n\tif (likely(srclen >= POLY1305_BLOCK_SIZE)) {\n\t\tpoly1305_blocks(dctx, src, srclen);\n\t\tsrc += srclen - (srclen % POLY1305_BLOCK_SIZE);\n\t\tsrclen %= POLY1305_BLOCK_SIZE;\n\t}\n\n\tif (unlikely(srclen)) {\n\t\tdctx->buflen = srclen;\n\t\tmemcpy(dctx->buf, src, srclen);\n\t}\n\n\treturn 0;\n}\n\nstatic int crypto_poly1305_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct poly1305_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\tif (unlikely(!dctx->sset))\n\t\treturn -ENOKEY;\n\n\tpoly1305_final_generic(dctx, dst);\n\treturn 0;\n}\n\nstatic struct shash_alg poly1305_alg = {\n\t.digestsize\t= POLY1305_DIGEST_SIZE,\n\t.init\t\t= crypto_poly1305_init,\n\t.update\t\t= crypto_poly1305_update,\n\t.final\t\t= crypto_poly1305_final,\n\t.descsize\t= sizeof(struct poly1305_desc_ctx),\n\t.base\t\t= {\n\t\t.cra_name\t\t= \"poly1305\",\n\t\t.cra_driver_name\t= \"poly1305-generic\",\n\t\t.cra_priority\t\t= 100,\n\t\t.cra_blocksize\t\t= POLY1305_BLOCK_SIZE,\n\t\t.cra_module\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init poly1305_mod_init(void)\n{\n\treturn crypto_register_shash(&poly1305_alg);\n}\n\nstatic void __exit poly1305_mod_exit(void)\n{\n\tcrypto_unregister_shash(&poly1305_alg);\n}\n\nsubsys_initcall(poly1305_mod_init);\nmodule_exit(poly1305_mod_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Martin Willi <martin@strongswan.org>\");\nMODULE_DESCRIPTION(\"Poly1305 authenticator\");\nMODULE_ALIAS_CRYPTO(\"poly1305\");\nMODULE_ALIAS_CRYPTO(\"poly1305-generic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}