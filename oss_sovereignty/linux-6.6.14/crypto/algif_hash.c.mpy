{
  "module_name": "algif_hash.c",
  "hash_id": "fd5fe7772c87f7b0b05984c187562d24ec0488c410ea9f7b176b6807ec0d3943",
  "original_prompt": "Ingested from linux-6.6.14/crypto/algif_hash.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <crypto/if_alg.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <net/sock.h>\n\nstruct hash_ctx {\n\tstruct af_alg_sgl sgl;\n\n\tu8 *result;\n\n\tstruct crypto_wait wait;\n\n\tunsigned int len;\n\tbool more;\n\n\tstruct ahash_request req;\n};\n\nstatic int hash_alloc_result(struct sock *sk, struct hash_ctx *ctx)\n{\n\tunsigned ds;\n\n\tif (ctx->result)\n\t\treturn 0;\n\n\tds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\n\tctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);\n\tif (!ctx->result)\n\t\treturn -ENOMEM;\n\n\tmemset(ctx->result, 0, ds);\n\n\treturn 0;\n}\n\nstatic void hash_free_result(struct sock *sk, struct hash_ctx *ctx)\n{\n\tunsigned ds;\n\n\tif (!ctx->result)\n\t\treturn;\n\n\tds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\n\tsock_kzfree_s(sk, ctx->result, ds);\n\tctx->result = NULL;\n}\n\nstatic int hash_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\tsize_t ignored)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tssize_t copied = 0;\n\tsize_t len, max_pages, npages;\n\tbool continuing, need_init = false;\n\tint err;\n\n\tmax_pages = min_t(size_t, ALG_MAX_PAGES,\n\t\t\t  DIV_ROUND_UP(sk->sk_sndbuf, PAGE_SIZE));\n\n\tlock_sock(sk);\n\tcontinuing = ctx->more;\n\n\tif (!continuing) {\n\t\t \n\t\thash_free_result(sk, ctx);\n\t\tif (!msg_data_left(msg))\n\t\t\tgoto done;  \n\t\tneed_init = true;\n\t} else if (!msg_data_left(msg)) {\n\t\t \n\t\tif (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = hash_alloc_result(sk, ctx);\n\t\t\tif (err)\n\t\t\t\tgoto unlock_free;\n\t\t\tahash_request_set_crypt(&ctx->req, NULL,\n\t\t\t\t\t\tctx->result, 0);\n\t\t\terr = crypto_wait_req(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t      &ctx->wait);\n\t\t\tif (err)\n\t\t\t\tgoto unlock_free;\n\t\t}\n\t\tgoto done_more;\n\t}\n\n\twhile (msg_data_left(msg)) {\n\t\tctx->sgl.sgt.sgl = ctx->sgl.sgl;\n\t\tctx->sgl.sgt.nents = 0;\n\t\tctx->sgl.sgt.orig_nents = 0;\n\n\t\terr = -EIO;\n\t\tnpages = iov_iter_npages(&msg->msg_iter, max_pages);\n\t\tif (npages == 0)\n\t\t\tgoto unlock_free;\n\n\t\tsg_init_table(ctx->sgl.sgl, npages);\n\n\t\tctx->sgl.need_unpin = iov_iter_extract_will_pin(&msg->msg_iter);\n\n\t\terr = extract_iter_to_sg(&msg->msg_iter, LONG_MAX,\n\t\t\t\t\t &ctx->sgl.sgt, npages, 0);\n\t\tif (err < 0)\n\t\t\tgoto unlock_free;\n\t\tlen = err;\n\t\tsg_mark_end(ctx->sgl.sgt.sgl + ctx->sgl.sgt.nents - 1);\n\n\t\tif (!msg_data_left(msg)) {\n\t\t\terr = hash_alloc_result(sk, ctx);\n\t\t\tif (err)\n\t\t\t\tgoto unlock_free;\n\t\t}\n\n\t\tahash_request_set_crypt(&ctx->req, ctx->sgl.sgt.sgl,\n\t\t\t\t\tctx->result, len);\n\n\t\tif (!msg_data_left(msg) && !continuing &&\n\t\t    !(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = crypto_ahash_digest(&ctx->req);\n\t\t} else {\n\t\t\tif (need_init) {\n\t\t\t\terr = crypto_wait_req(\n\t\t\t\t\tcrypto_ahash_init(&ctx->req),\n\t\t\t\t\t&ctx->wait);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto unlock_free;\n\t\t\t\tneed_init = false;\n\t\t\t}\n\n\t\t\tif (msg_data_left(msg) || (msg->msg_flags & MSG_MORE))\n\t\t\t\terr = crypto_ahash_update(&ctx->req);\n\t\t\telse\n\t\t\t\terr = crypto_ahash_finup(&ctx->req);\n\t\t\tcontinuing = true;\n\t\t}\n\n\t\terr = crypto_wait_req(err, &ctx->wait);\n\t\tif (err)\n\t\t\tgoto unlock_free;\n\n\t\tcopied += len;\n\t\taf_alg_free_sg(&ctx->sgl);\n\t}\n\ndone_more:\n\tctx->more = msg->msg_flags & MSG_MORE;\ndone:\n\terr = 0;\nunlock:\n\trelease_sock(sk);\n\treturn copied ?: err;\n\nunlock_free:\n\taf_alg_free_sg(&ctx->sgl);\n\thash_free_result(sk, ctx);\n\tctx->more = false;\n\tgoto unlock;\n}\n\nstatic int hash_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\tint flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tbool result;\n\tint err;\n\n\tif (len > ds)\n\t\tlen = ds;\n\telse if (len < ds)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\tlock_sock(sk);\n\tresult = ctx->result;\n\terr = hash_alloc_result(sk, ctx);\n\tif (err)\n\t\tgoto unlock;\n\n\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\n\tif (!result && !ctx->more) {\n\t\terr = crypto_wait_req(crypto_ahash_init(&ctx->req),\n\t\t\t\t      &ctx->wait);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\tif (!result || ctx->more) {\n\t\tctx->more = false;\n\t\terr = crypto_wait_req(crypto_ahash_final(&ctx->req),\n\t\t\t\t      &ctx->wait);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = memcpy_to_msg(msg, ctx->result, len);\n\nunlock:\n\thash_free_result(sk, ctx);\n\trelease_sock(sk);\n\n\treturn err ?: len;\n}\n\nstatic int hash_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t       bool kern)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tstruct crypto_ahash *tfm;\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tchar *state;\n\tbool more;\n\tint err;\n\n\ttfm = crypto_ahash_reqtfm(req);\n\tstate = kmalloc(crypto_ahash_statesize(tfm), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!state)\n\t\tgoto out;\n\n\tlock_sock(sk);\n\tmore = ctx->more;\n\terr = more ? crypto_ahash_export(req, state) : 0;\n\trelease_sock(sk);\n\n\tif (err)\n\t\tgoto out_free_state;\n\n\terr = af_alg_accept(ask->parent, newsock, kern);\n\tif (err)\n\t\tgoto out_free_state;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more)\n\t\tgoto out_free_state;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\nout_free_state:\n\tkfree_sensitive(state);\n\nout:\n\treturn err;\n}\n\nstatic struct proto_ops algif_hash_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\thash_sendmsg,\n\t.recvmsg\t=\thash_recvmsg,\n\t.accept\t\t=\thash_accept,\n};\n\nstatic int hash_check_key(struct socket *sock)\n{\n\tint err = 0;\n\tstruct sock *psk;\n\tstruct alg_sock *pask;\n\tstruct crypto_ahash *tfm;\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\n\tlock_sock(sk);\n\tif (!atomic_read(&ask->nokey_refcnt))\n\t\tgoto unlock_child;\n\n\tpsk = ask->parent;\n\tpask = alg_sk(ask->parent);\n\ttfm = pask->private;\n\n\terr = -ENOKEY;\n\tlock_sock_nested(psk, SINGLE_DEPTH_NESTING);\n\tif (crypto_ahash_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)\n\t\tgoto unlock;\n\n\tatomic_dec(&pask->nokey_refcnt);\n\tatomic_set(&ask->nokey_refcnt, 0);\n\n\terr = 0;\n\nunlock:\n\trelease_sock(psk);\nunlock_child:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int hash_sendmsg_nokey(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t size)\n{\n\tint err;\n\n\terr = hash_check_key(sock);\n\tif (err)\n\t\treturn err;\n\n\treturn hash_sendmsg(sock, msg, size);\n}\n\nstatic int hash_recvmsg_nokey(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t ignored, int flags)\n{\n\tint err;\n\n\terr = hash_check_key(sock);\n\tif (err)\n\t\treturn err;\n\n\treturn hash_recvmsg(sock, msg, ignored, flags);\n}\n\nstatic int hash_accept_nokey(struct socket *sock, struct socket *newsock,\n\t\t\t     int flags, bool kern)\n{\n\tint err;\n\n\terr = hash_check_key(sock);\n\tif (err)\n\t\treturn err;\n\n\treturn hash_accept(sock, newsock, flags, kern);\n}\n\nstatic struct proto_ops algif_hash_ops_nokey = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\thash_sendmsg_nokey,\n\t.recvmsg\t=\thash_recvmsg_nokey,\n\t.accept\t\t=\thash_accept_nokey,\n};\n\nstatic void *hash_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_ahash(name, type, mask);\n}\n\nstatic void hash_release(void *private)\n{\n\tcrypto_free_ahash(private);\n}\n\nstatic int hash_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_ahash_setkey(private, key, keylen);\n}\n\nstatic void hash_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\n\thash_free_result(sk, ctx);\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}\n\nstatic int hash_accept_parent_nokey(void *private, struct sock *sk)\n{\n\tstruct crypto_ahash *tfm = private;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx;\n\tunsigned int len = sizeof(*ctx) + crypto_ahash_reqsize(tfm);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->result = NULL;\n\tctx->len = len;\n\tctx->more = false;\n\tcrypto_init_wait(&ctx->wait);\n\n\task->private = ctx;\n\n\tahash_request_set_tfm(&ctx->req, tfm);\n\tahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t   crypto_req_done, &ctx->wait);\n\n\tsk->sk_destruct = hash_sock_destruct;\n\n\treturn 0;\n}\n\nstatic int hash_accept_parent(void *private, struct sock *sk)\n{\n\tstruct crypto_ahash *tfm = private;\n\n\tif (crypto_ahash_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)\n\t\treturn -ENOKEY;\n\n\treturn hash_accept_parent_nokey(private, sk);\n}\n\nstatic const struct af_alg_type algif_type_hash = {\n\t.bind\t\t=\thash_bind,\n\t.release\t=\thash_release,\n\t.setkey\t\t=\thash_setkey,\n\t.accept\t\t=\thash_accept_parent,\n\t.accept_nokey\t=\thash_accept_parent_nokey,\n\t.ops\t\t=\t&algif_hash_ops,\n\t.ops_nokey\t=\t&algif_hash_ops_nokey,\n\t.name\t\t=\t\"hash\",\n\t.owner\t\t=\tTHIS_MODULE\n};\n\nstatic int __init algif_hash_init(void)\n{\n\treturn af_alg_register_type(&algif_type_hash);\n}\n\nstatic void __exit algif_hash_exit(void)\n{\n\tint err = af_alg_unregister_type(&algif_type_hash);\n\tBUG_ON(err);\n}\n\nmodule_init(algif_hash_init);\nmodule_exit(algif_hash_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}