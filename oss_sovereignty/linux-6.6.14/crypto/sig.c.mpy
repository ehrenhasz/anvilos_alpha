{
  "module_name": "sig.c",
  "hash_id": "f922acd5d445f0fde244a37091dd84bb2a0500733f40b4e44a446d3a156778aa",
  "original_prompt": "Ingested from linux-6.6.14/crypto/sig.c",
  "human_readable_source": " \n \n\n#include <crypto/akcipher.h>\n#include <crypto/internal/sig.h>\n#include <linux/cryptouser.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <net/netlink.h>\n\n#include \"internal.h\"\n\n#define CRYPTO_ALG_TYPE_SIG_MASK\t0x0000000e\n\nstatic const struct crypto_type crypto_sig_type;\n\nstatic int crypto_sig_init_tfm(struct crypto_tfm *tfm)\n{\n\tif (tfm->__crt_alg->cra_type != &crypto_sig_type)\n\t\treturn crypto_init_akcipher_ops_sig(tfm);\n\n\treturn 0;\n}\n\nstatic void __maybe_unused crypto_sig_show(struct seq_file *m,\n\t\t\t\t\t   struct crypto_alg *alg)\n{\n\tseq_puts(m, \"type         : sig\\n\");\n}\n\nstatic int __maybe_unused crypto_sig_report(struct sk_buff *skb,\n\t\t\t\t\t    struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rsig = {};\n\n\tstrscpy(rsig.type, \"sig\", sizeof(rsig.type));\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER, sizeof(rsig), &rsig);\n}\n\nstatic int __maybe_unused crypto_sig_report_stat(struct sk_buff *skb,\n\t\t\t\t\t\t struct crypto_alg *alg)\n{\n\tstruct crypto_stat_akcipher rsig = {};\n\n\tstrscpy(rsig.type, \"sig\", sizeof(rsig.type));\n\n\treturn nla_put(skb, CRYPTOCFGA_STAT_AKCIPHER, sizeof(rsig), &rsig);\n}\n\nstatic const struct crypto_type crypto_sig_type = {\n\t.extsize = crypto_alg_extsize,\n\t.init_tfm = crypto_sig_init_tfm,\n#ifdef CONFIG_PROC_FS\n\t.show = crypto_sig_show,\n#endif\n#if IS_ENABLED(CONFIG_CRYPTO_USER)\n\t.report = crypto_sig_report,\n#endif\n#ifdef CONFIG_CRYPTO_STATS\n\t.report_stat = crypto_sig_report_stat,\n#endif\n\t.maskclear = ~CRYPTO_ALG_TYPE_MASK,\n\t.maskset = CRYPTO_ALG_TYPE_SIG_MASK,\n\t.type = CRYPTO_ALG_TYPE_SIG,\n\t.tfmsize = offsetof(struct crypto_sig, base),\n};\n\nstruct crypto_sig *crypto_alloc_sig(const char *alg_name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_tfm(alg_name, &crypto_sig_type, type, mask);\n}\nEXPORT_SYMBOL_GPL(crypto_alloc_sig);\n\nint crypto_sig_maxsize(struct crypto_sig *tfm)\n{\n\tstruct crypto_akcipher **ctx = crypto_sig_ctx(tfm);\n\n\treturn crypto_akcipher_maxsize(*ctx);\n}\nEXPORT_SYMBOL_GPL(crypto_sig_maxsize);\n\nint crypto_sig_sign(struct crypto_sig *tfm,\n\t\t    const void *src, unsigned int slen,\n\t\t    void *dst, unsigned int dlen)\n{\n\tstruct crypto_akcipher **ctx = crypto_sig_ctx(tfm);\n\tstruct crypto_akcipher_sync_data data = {\n\t\t.tfm = *ctx,\n\t\t.src = src,\n\t\t.dst = dst,\n\t\t.slen = slen,\n\t\t.dlen = dlen,\n\t};\n\n\treturn crypto_akcipher_sync_prep(&data) ?:\n\t       crypto_akcipher_sync_post(&data,\n\t\t\t\t\t crypto_akcipher_sign(data.req));\n}\nEXPORT_SYMBOL_GPL(crypto_sig_sign);\n\nint crypto_sig_verify(struct crypto_sig *tfm,\n\t\t      const void *src, unsigned int slen,\n\t\t      const void *digest, unsigned int dlen)\n{\n\tstruct crypto_akcipher **ctx = crypto_sig_ctx(tfm);\n\tstruct crypto_akcipher_sync_data data = {\n\t\t.tfm = *ctx,\n\t\t.src = src,\n\t\t.slen = slen,\n\t\t.dlen = dlen,\n\t};\n\tint err;\n\n\terr = crypto_akcipher_sync_prep(&data);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(data.buf + slen, digest, dlen);\n\n\treturn crypto_akcipher_sync_post(&data,\n\t\t\t\t\t crypto_akcipher_verify(data.req));\n}\nEXPORT_SYMBOL_GPL(crypto_sig_verify);\n\nint crypto_sig_set_pubkey(struct crypto_sig *tfm,\n\t\t\t  const void *key, unsigned int keylen)\n{\n\tstruct crypto_akcipher **ctx = crypto_sig_ctx(tfm);\n\n\treturn crypto_akcipher_set_pub_key(*ctx, key, keylen);\n}\nEXPORT_SYMBOL_GPL(crypto_sig_set_pubkey);\n\nint crypto_sig_set_privkey(struct crypto_sig *tfm,\n\t\t\t  const void *key, unsigned int keylen)\n{\n\tstruct crypto_akcipher **ctx = crypto_sig_ctx(tfm);\n\n\treturn crypto_akcipher_set_priv_key(*ctx, key, keylen);\n}\nEXPORT_SYMBOL_GPL(crypto_sig_set_privkey);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Public Key Signature Algorithms\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}