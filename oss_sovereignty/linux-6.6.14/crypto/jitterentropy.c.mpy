{
  "module_name": "jitterentropy.c",
  "hash_id": "2ddddc1ad6ea0cccdcc7995d5cb59d0195f232499b176cef87811c023c339d55",
  "original_prompt": "Ingested from linux-6.6.14/crypto/jitterentropy.c",
  "human_readable_source": " \n\n \n\n#ifdef __OPTIMIZE__\n #error \"The CPU Jitter random number generator must not be compiled with optimizations. See documentation. Use the compiler switch -O0 for compiling jitterentropy.c.\"\n#endif\n\ntypedef\tunsigned long long\t__u64;\ntypedef\tlong long\t\t__s64;\ntypedef\tunsigned int\t\t__u32;\ntypedef unsigned char\t\tu8;\n#define NULL    ((void *) 0)\n\n \nstruct rand_data {\n\t \n#define DATA_SIZE_BITS 256\n\t \n\tvoid *hash_state;\t\t \n\t__u64 prev_time;\t\t \n\t__u64 last_delta;\t\t \n\t__s64 last_delta2;\t\t \n\tunsigned int osr;\t\t \n#define JENT_MEMORY_BLOCKS 64\n#define JENT_MEMORY_BLOCKSIZE 32\n#define JENT_MEMORY_ACCESSLOOPS 128\n#define JENT_MEMORY_SIZE (JENT_MEMORY_BLOCKS*JENT_MEMORY_BLOCKSIZE)\n\tunsigned char *mem;\t \n\tunsigned int memlocation;  \n\tunsigned int memblocks;\t \n\tunsigned int memblocksize;  \n\tunsigned int memaccessloops;  \n\n\t \n\tunsigned int rct_count;\t\t\t \n\n\t \n\t \n\t \n#define JENT_RCT_CUTOFF\t\t(31 - 1)\t \n#define JENT_APT_CUTOFF\t\t325\t\t\t \n\t \n\t \n\t \n#define JENT_RCT_CUTOFF_PERMANENT\t(61 - 1)\n#define JENT_APT_CUTOFF_PERMANENT\t355\n#define JENT_APT_WINDOW_SIZE\t512\t \n\t \n#define JENT_APT_LSB\t\t16\n#define JENT_APT_WORD_MASK\t(JENT_APT_LSB - 1)\n\tunsigned int apt_observations;\t \n\tunsigned int apt_count;\t\t \n\tunsigned int apt_base;\t\t \n\tunsigned int apt_base_set:1;\t \n};\n\n \n#define JENT_DISABLE_MEMORY_ACCESS (1<<2)  \n\n \n#define JENT_ENOTIME\t\t1  \n#define JENT_ECOARSETIME\t2  \n#define JENT_ENOMONOTONIC\t3  \n#define JENT_EVARVAR\t\t5  \n#define JENT_ESTUCK\t\t8  \n#define JENT_EHEALTH\t\t9  \n\n \n#define JENT_ENTROPY_SAFETY_FACTOR\t64\n\n#include <linux/fips.h>\n#include \"jitterentropy.h\"\n\n \n\n \nstatic void jent_apt_reset(struct rand_data *ec, unsigned int delta_masked)\n{\n\t \n\tec->apt_count = 0;\n\tec->apt_base = delta_masked;\n\tec->apt_observations = 0;\n}\n\n \nstatic void jent_apt_insert(struct rand_data *ec, unsigned int delta_masked)\n{\n\t \n\tif (!ec->apt_base_set) {\n\t\tec->apt_base = delta_masked;\n\t\tec->apt_base_set = 1;\n\t\treturn;\n\t}\n\n\tif (delta_masked == ec->apt_base)\n\t\tec->apt_count++;\n\n\tec->apt_observations++;\n\n\tif (ec->apt_observations >= JENT_APT_WINDOW_SIZE)\n\t\tjent_apt_reset(ec, delta_masked);\n}\n\n \nstatic int jent_apt_permanent_failure(struct rand_data *ec)\n{\n\treturn (ec->apt_count >= JENT_APT_CUTOFF_PERMANENT) ? 1 : 0;\n}\n\nstatic int jent_apt_failure(struct rand_data *ec)\n{\n\treturn (ec->apt_count >= JENT_APT_CUTOFF) ? 1 : 0;\n}\n\n \n\n \nstatic void jent_rct_insert(struct rand_data *ec, int stuck)\n{\n\tif (stuck) {\n\t\tec->rct_count++;\n\t} else {\n\t\t \n\t\tec->rct_count = 0;\n\t}\n}\n\nstatic inline __u64 jent_delta(__u64 prev, __u64 next)\n{\n#define JENT_UINT64_MAX\t\t(__u64)(~((__u64) 0))\n\treturn (prev < next) ? (next - prev) :\n\t\t\t       (JENT_UINT64_MAX - prev + 1 + next);\n}\n\n \nstatic int jent_stuck(struct rand_data *ec, __u64 current_delta)\n{\n\t__u64 delta2 = jent_delta(ec->last_delta, current_delta);\n\t__u64 delta3 = jent_delta(ec->last_delta2, delta2);\n\n\tec->last_delta = current_delta;\n\tec->last_delta2 = delta2;\n\n\t \n\tjent_apt_insert(ec, current_delta);\n\n\tif (!current_delta || !delta2 || !delta3) {\n\t\t \n\t\tjent_rct_insert(ec, 1);\n\t\treturn 1;\n\t}\n\n\t \n\tjent_rct_insert(ec, 0);\n\n\treturn 0;\n}\n\n \nstatic int jent_rct_permanent_failure(struct rand_data *ec)\n{\n\treturn (ec->rct_count >= JENT_RCT_CUTOFF_PERMANENT) ? 1 : 0;\n}\n\nstatic int jent_rct_failure(struct rand_data *ec)\n{\n\treturn (ec->rct_count >= JENT_RCT_CUTOFF) ? 1 : 0;\n}\n\n \nstatic int jent_health_failure(struct rand_data *ec)\n{\n\treturn jent_rct_failure(ec) | jent_apt_failure(ec);\n}\n\nstatic int jent_permanent_health_failure(struct rand_data *ec)\n{\n\treturn jent_rct_permanent_failure(ec) | jent_apt_permanent_failure(ec);\n}\n\n \n\n \nstatic __u64 jent_loop_shuffle(unsigned int bits, unsigned int min)\n{\n\t__u64 time = 0;\n\t__u64 shuffle = 0;\n\tunsigned int i = 0;\n\tunsigned int mask = (1<<bits) - 1;\n\n\tjent_get_nstime(&time);\n\n\t \n\tfor (i = 0; ((DATA_SIZE_BITS + bits - 1) / bits) > i; i++) {\n\t\tshuffle ^= time & mask;\n\t\ttime = time >> bits;\n\t}\n\n\t \n\treturn (shuffle + (1<<min));\n}\n\n \nstatic int jent_condition_data(struct rand_data *ec, __u64 time, int stuck)\n{\n#define SHA3_HASH_LOOP (1<<3)\n\tstruct {\n\t\tint rct_count;\n\t\tunsigned int apt_observations;\n\t\tunsigned int apt_count;\n\t\tunsigned int apt_base;\n\t} addtl = {\n\t\tec->rct_count,\n\t\tec->apt_observations,\n\t\tec->apt_count,\n\t\tec->apt_base\n\t};\n\n\treturn jent_hash_time(ec->hash_state, time, (u8 *)&addtl, sizeof(addtl),\n\t\t\t      SHA3_HASH_LOOP, stuck);\n}\n\n \nstatic void jent_memaccess(struct rand_data *ec, __u64 loop_cnt)\n{\n\tunsigned int wrap = 0;\n\t__u64 i = 0;\n#define MAX_ACC_LOOP_BIT 7\n#define MIN_ACC_LOOP_BIT 0\n\t__u64 acc_loop_cnt =\n\t\tjent_loop_shuffle(MAX_ACC_LOOP_BIT, MIN_ACC_LOOP_BIT);\n\n\tif (NULL == ec || NULL == ec->mem)\n\t\treturn;\n\twrap = ec->memblocksize * ec->memblocks;\n\n\t \n\tif (loop_cnt)\n\t\tacc_loop_cnt = loop_cnt;\n\n\tfor (i = 0; i < (ec->memaccessloops + acc_loop_cnt); i++) {\n\t\tunsigned char *tmpval = ec->mem + ec->memlocation;\n\t\t \n\t\t*tmpval = (*tmpval + 1) & 0xff;\n\t\t \n\t\tec->memlocation = ec->memlocation + ec->memblocksize - 1;\n\t\tec->memlocation = ec->memlocation % wrap;\n\t}\n}\n\n \n \nstatic int jent_measure_jitter(struct rand_data *ec)\n{\n\t__u64 time = 0;\n\t__u64 current_delta = 0;\n\tint stuck;\n\n\t \n\tjent_memaccess(ec, 0);\n\n\t \n\tjent_get_nstime(&time);\n\tcurrent_delta = jent_delta(ec->prev_time, time);\n\tec->prev_time = time;\n\n\t \n\tstuck = jent_stuck(ec, current_delta);\n\n\t \n\tif (jent_condition_data(ec, current_delta, stuck))\n\t\tstuck = 1;\n\n\treturn stuck;\n}\n\n \nstatic void jent_gen_entropy(struct rand_data *ec)\n{\n\tunsigned int k = 0, safety_factor = 0;\n\n\tif (fips_enabled)\n\t\tsafety_factor = JENT_ENTROPY_SAFETY_FACTOR;\n\n\t \n\tjent_measure_jitter(ec);\n\n\twhile (!jent_health_failure(ec)) {\n\t\t \n\t\tif (jent_measure_jitter(ec))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (++k >= ((DATA_SIZE_BITS + safety_factor) * ec->osr))\n\t\t\tbreak;\n\t}\n}\n\n \nint jent_read_entropy(struct rand_data *ec, unsigned char *data,\n\t\t      unsigned int len)\n{\n\tunsigned char *p = data;\n\n\tif (!ec)\n\t\treturn -1;\n\n\twhile (len > 0) {\n\t\tunsigned int tocopy;\n\n\t\tjent_gen_entropy(ec);\n\n\t\tif (jent_permanent_health_failure(ec)) {\n\t\t\t \n\t\t\treturn -3;\n\t\t} else if (jent_health_failure(ec)) {\n\t\t\t \n\t\t\tif (jent_entropy_init(ec->hash_state))\n\t\t\t\treturn -3;\n\n\t\t\treturn -2;\n\t\t}\n\n\t\tif ((DATA_SIZE_BITS / 8) < len)\n\t\t\ttocopy = (DATA_SIZE_BITS / 8);\n\t\telse\n\t\t\ttocopy = len;\n\t\tif (jent_read_random_block(ec->hash_state, p, tocopy))\n\t\t\treturn -1;\n\n\t\tlen -= tocopy;\n\t\tp += tocopy;\n\t}\n\n\treturn 0;\n}\n\n \n\nstruct rand_data *jent_entropy_collector_alloc(unsigned int osr,\n\t\t\t\t\t       unsigned int flags,\n\t\t\t\t\t       void *hash_state)\n{\n\tstruct rand_data *entropy_collector;\n\n\tentropy_collector = jent_zalloc(sizeof(struct rand_data));\n\tif (!entropy_collector)\n\t\treturn NULL;\n\n\tif (!(flags & JENT_DISABLE_MEMORY_ACCESS)) {\n\t\t \n\t\tentropy_collector->mem = jent_zalloc(JENT_MEMORY_SIZE);\n\t\tif (!entropy_collector->mem) {\n\t\t\tjent_zfree(entropy_collector);\n\t\t\treturn NULL;\n\t\t}\n\t\tentropy_collector->memblocksize = JENT_MEMORY_BLOCKSIZE;\n\t\tentropy_collector->memblocks = JENT_MEMORY_BLOCKS;\n\t\tentropy_collector->memaccessloops = JENT_MEMORY_ACCESSLOOPS;\n\t}\n\n\t \n\tif (osr == 0)\n\t\tosr = 1;  \n\tentropy_collector->osr = osr;\n\n\tentropy_collector->hash_state = hash_state;\n\n\t \n\tjent_gen_entropy(entropy_collector);\n\n\treturn entropy_collector;\n}\n\nvoid jent_entropy_collector_free(struct rand_data *entropy_collector)\n{\n\tjent_zfree(entropy_collector->mem);\n\tentropy_collector->mem = NULL;\n\tjent_zfree(entropy_collector);\n}\n\nint jent_entropy_init(void *hash_state)\n{\n\tint i;\n\t__u64 delta_sum = 0;\n\t__u64 old_delta = 0;\n\tunsigned int nonstuck = 0;\n\tint time_backwards = 0;\n\tint count_mod = 0;\n\tint count_stuck = 0;\n\tstruct rand_data ec = { 0 };\n\n\t \n\tec.osr = 1;\n\tec.hash_state = hash_state;\n\n\t \n\n\t \n\t \n#define TESTLOOPCOUNT 1024\n#define CLEARCACHE 100\n\tfor (i = 0; (TESTLOOPCOUNT + CLEARCACHE) > i; i++) {\n\t\t__u64 time = 0;\n\t\t__u64 time2 = 0;\n\t\t__u64 delta = 0;\n\t\tunsigned int lowdelta = 0;\n\t\tint stuck;\n\n\t\t \n\t\tjent_get_nstime(&time);\n\t\tec.prev_time = time;\n\t\tjent_condition_data(&ec, time, 0);\n\t\tjent_get_nstime(&time2);\n\n\t\t \n\t\tif (!time || !time2)\n\t\t\treturn JENT_ENOTIME;\n\t\tdelta = jent_delta(time, time2);\n\t\t \n\t\tif (!delta)\n\t\t\treturn JENT_ECOARSETIME;\n\n\t\tstuck = jent_stuck(&ec, delta);\n\n\t\t \n\t\tif (i < CLEARCACHE)\n\t\t\tcontinue;\n\n\t\tif (stuck)\n\t\t\tcount_stuck++;\n\t\telse {\n\t\t\tnonstuck++;\n\n\t\t\t \n\t\t\tif ((nonstuck % JENT_APT_WINDOW_SIZE) == 0) {\n\t\t\t\tjent_apt_reset(&ec,\n\t\t\t\t\t       delta & JENT_APT_WORD_MASK);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (jent_health_failure(&ec))\n\t\t\treturn JENT_EHEALTH;\n\n\t\t \n\t\tif (!(time2 > time))\n\t\t\ttime_backwards++;\n\n\t\t \n\t\tlowdelta = time2 - time;\n\t\tif (!(lowdelta % 100))\n\t\t\tcount_mod++;\n\n\t\t \n\t\tif (delta > old_delta)\n\t\t\tdelta_sum += (delta - old_delta);\n\t\telse\n\t\t\tdelta_sum += (old_delta - delta);\n\t\told_delta = delta;\n\t}\n\n\t \n\tif (time_backwards > 3)\n\t\treturn JENT_ENOMONOTONIC;\n\n\t \n\tif ((delta_sum) <= 1)\n\t\treturn JENT_EVARVAR;\n\n\t \n\tif ((TESTLOOPCOUNT/10 * 9) < count_mod)\n\t\treturn JENT_ECOARSETIME;\n\n\t \n\tif ((TESTLOOPCOUNT/10 * 9) < count_stuck)\n\t\treturn JENT_ESTUCK;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}