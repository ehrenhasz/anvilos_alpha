{
  "module_name": "testmgr.c",
  "hash_id": "bf4a5f641ad69b01cdf0ed3535ebfe55044a867af19beb14186c9c62b5e6a3e3",
  "original_prompt": "Ingested from linux-6.6.14/crypto/testmgr.c",
  "human_readable_source": "\n \n\n#include <crypto/aead.h>\n#include <crypto/hash.h>\n#include <crypto/skcipher.h>\n#include <linux/err.h>\n#include <linux/fips.h>\n#include <linux/module.h>\n#include <linux/once.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/uio.h>\n#include <crypto/rng.h>\n#include <crypto/drbg.h>\n#include <crypto/akcipher.h>\n#include <crypto/kpp.h>\n#include <crypto/acompress.h>\n#include <crypto/internal/cipher.h>\n#include <crypto/internal/simd.h>\n\n#include \"internal.h\"\n\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n\nstatic bool notests;\nmodule_param(notests, bool, 0644);\nMODULE_PARM_DESC(notests, \"disable crypto self-tests\");\n\nstatic bool panic_on_fail;\nmodule_param(panic_on_fail, bool, 0444);\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\nstatic bool noextratests;\nmodule_param(noextratests, bool, 0644);\nMODULE_PARM_DESC(noextratests, \"disable expensive crypto self-tests\");\n\nstatic unsigned int fuzz_iterations = 100;\nmodule_param(fuzz_iterations, uint, 0644);\nMODULE_PARM_DESC(fuzz_iterations, \"number of fuzz test iterations\");\n#endif\n\n#ifdef CONFIG_CRYPTO_MANAGER_DISABLE_TESTS\n\n \nint alg_test(const char *driver, const char *alg, u32 type, u32 mask)\n{\n\treturn 0;\n}\n\n#else\n\n#include \"testmgr.h\"\n\n \n#define XBUFSIZE\t8\n\n \n#define ENCRYPT 1\n#define DECRYPT 0\n\nstruct aead_test_suite {\n\tconst struct aead_testvec *vecs;\n\tunsigned int count;\n\n\t \n\tunsigned int einval_allowed : 1;\n\n\t \n\tunsigned int aad_iv : 1;\n};\n\nstruct cipher_test_suite {\n\tconst struct cipher_testvec *vecs;\n\tunsigned int count;\n};\n\nstruct comp_test_suite {\n\tstruct {\n\t\tconst struct comp_testvec *vecs;\n\t\tunsigned int count;\n\t} comp, decomp;\n};\n\nstruct hash_test_suite {\n\tconst struct hash_testvec *vecs;\n\tunsigned int count;\n};\n\nstruct cprng_test_suite {\n\tconst struct cprng_testvec *vecs;\n\tunsigned int count;\n};\n\nstruct drbg_test_suite {\n\tconst struct drbg_testvec *vecs;\n\tunsigned int count;\n};\n\nstruct akcipher_test_suite {\n\tconst struct akcipher_testvec *vecs;\n\tunsigned int count;\n};\n\nstruct kpp_test_suite {\n\tconst struct kpp_testvec *vecs;\n\tunsigned int count;\n};\n\nstruct alg_test_desc {\n\tconst char *alg;\n\tconst char *generic_driver;\n\tint (*test)(const struct alg_test_desc *desc, const char *driver,\n\t\t    u32 type, u32 mask);\n\tint fips_allowed;\t \n\n\tunion {\n\t\tstruct aead_test_suite aead;\n\t\tstruct cipher_test_suite cipher;\n\t\tstruct comp_test_suite comp;\n\t\tstruct hash_test_suite hash;\n\t\tstruct cprng_test_suite cprng;\n\t\tstruct drbg_test_suite drbg;\n\t\tstruct akcipher_test_suite akcipher;\n\t\tstruct kpp_test_suite kpp;\n\t} suite;\n};\n\nstatic void hexdump(unsigned char *buf, unsigned int len)\n{\n\tprint_hex_dump(KERN_CONT, \"\", DUMP_PREFIX_OFFSET,\n\t\t\t16, 1,\n\t\t\tbuf, len, false);\n}\n\nstatic int __testmgr_alloc_buf(char *buf[XBUFSIZE], int order)\n{\n\tint i;\n\n\tfor (i = 0; i < XBUFSIZE; i++) {\n\t\tbuf[i] = (char *)__get_free_pages(GFP_KERNEL, order);\n\t\tif (!buf[i])\n\t\t\tgoto err_free_buf;\n\t}\n\n\treturn 0;\n\nerr_free_buf:\n\twhile (i-- > 0)\n\t\tfree_pages((unsigned long)buf[i], order);\n\n\treturn -ENOMEM;\n}\n\nstatic int testmgr_alloc_buf(char *buf[XBUFSIZE])\n{\n\treturn __testmgr_alloc_buf(buf, 0);\n}\n\nstatic void __testmgr_free_buf(char *buf[XBUFSIZE], int order)\n{\n\tint i;\n\n\tfor (i = 0; i < XBUFSIZE; i++)\n\t\tfree_pages((unsigned long)buf[i], order);\n}\n\nstatic void testmgr_free_buf(char *buf[XBUFSIZE])\n{\n\t__testmgr_free_buf(buf, 0);\n}\n\n#define TESTMGR_POISON_BYTE\t0xfe\n#define TESTMGR_POISON_LEN\t16\n\nstatic inline void testmgr_poison(void *addr, size_t len)\n{\n\tmemset(addr, TESTMGR_POISON_BYTE, len);\n}\n\n \nstatic inline bool testmgr_is_poison(const void *addr, size_t len)\n{\n\treturn memchr_inv(addr, TESTMGR_POISON_BYTE, len) == NULL;\n}\n\n \nenum flush_type {\n\t \n\tFLUSH_TYPE_NONE = 0,\n\n\t \n\tFLUSH_TYPE_FLUSH,\n\n\t \n\tFLUSH_TYPE_REIMPORT,\n};\n\n \nenum finalization_type {\n\tFINALIZATION_TYPE_FINAL,\t \n\tFINALIZATION_TYPE_FINUP,\t \n\tFINALIZATION_TYPE_DIGEST,\t \n};\n\n \nenum inplace_mode {\n\tOUT_OF_PLACE,\n\tINPLACE_ONE_SGLIST,\n\tINPLACE_TWO_SGLISTS,\n};\n\n#define TEST_SG_TOTAL\t10000\n\n \nstruct test_sg_division {\n\tunsigned int proportion_of_total;\n\tunsigned int offset;\n\tbool offset_relative_to_alignmask;\n\tenum flush_type flush_type;\n\tbool nosimd;\n};\n\n \nstruct testvec_config {\n\tconst char *name;\n\tenum inplace_mode inplace_mode;\n\tu32 req_flags;\n\tstruct test_sg_division src_divs[XBUFSIZE];\n\tstruct test_sg_division dst_divs[XBUFSIZE];\n\tunsigned int iv_offset;\n\tunsigned int key_offset;\n\tbool iv_offset_relative_to_alignmask;\n\tbool key_offset_relative_to_alignmask;\n\tenum finalization_type finalization_type;\n\tbool nosimd;\n};\n\n#define TESTVEC_CONFIG_NAMELEN\t192\n\n \n\n \nstatic const struct testvec_config default_cipher_testvec_configs[] = {\n\t{\n\t\t.name = \"in-place (one sglist)\",\n\t\t.inplace_mode = INPLACE_ONE_SGLIST,\n\t\t.src_divs = { { .proportion_of_total = 10000 } },\n\t}, {\n\t\t.name = \"in-place (two sglists)\",\n\t\t.inplace_mode = INPLACE_TWO_SGLISTS,\n\t\t.src_divs = { { .proportion_of_total = 10000 } },\n\t}, {\n\t\t.name = \"out-of-place\",\n\t\t.inplace_mode = OUT_OF_PLACE,\n\t\t.src_divs = { { .proportion_of_total = 10000 } },\n\t}, {\n\t\t.name = \"unaligned buffer, offset=1\",\n\t\t.src_divs = { { .proportion_of_total = 10000, .offset = 1 } },\n\t\t.iv_offset = 1,\n\t\t.key_offset = 1,\n\t}, {\n\t\t.name = \"buffer aligned only to alignmask\",\n\t\t.src_divs = {\n\t\t\t{\n\t\t\t\t.proportion_of_total = 10000,\n\t\t\t\t.offset = 1,\n\t\t\t\t.offset_relative_to_alignmask = true,\n\t\t\t},\n\t\t},\n\t\t.iv_offset = 1,\n\t\t.iv_offset_relative_to_alignmask = true,\n\t\t.key_offset = 1,\n\t\t.key_offset_relative_to_alignmask = true,\n\t}, {\n\t\t.name = \"two even aligned splits\",\n\t\t.src_divs = {\n\t\t\t{ .proportion_of_total = 5000 },\n\t\t\t{ .proportion_of_total = 5000 },\n\t\t},\n\t}, {\n\t\t.name = \"one src, two even splits dst\",\n\t\t.inplace_mode = OUT_OF_PLACE,\n\t\t.src_divs = { { .proportion_of_total = 10000 } },\n\t\t.dst_divs = {\n\t\t\t{ .proportion_of_total = 5000 },\n\t\t\t{ .proportion_of_total = 5000 },\n\t\t },\n\t}, {\n\t\t.name = \"uneven misaligned splits, may sleep\",\n\t\t.req_flags = CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t.src_divs = {\n\t\t\t{ .proportion_of_total = 1900, .offset = 33 },\n\t\t\t{ .proportion_of_total = 3300, .offset = 7  },\n\t\t\t{ .proportion_of_total = 4800, .offset = 18 },\n\t\t},\n\t\t.iv_offset = 3,\n\t\t.key_offset = 3,\n\t}, {\n\t\t.name = \"misaligned splits crossing pages, inplace\",\n\t\t.inplace_mode = INPLACE_ONE_SGLIST,\n\t\t.src_divs = {\n\t\t\t{\n\t\t\t\t.proportion_of_total = 7500,\n\t\t\t\t.offset = PAGE_SIZE - 32\n\t\t\t}, {\n\t\t\t\t.proportion_of_total = 2500,\n\t\t\t\t.offset = PAGE_SIZE - 7\n\t\t\t},\n\t\t},\n\t}\n};\n\nstatic const struct testvec_config default_hash_testvec_configs[] = {\n\t{\n\t\t.name = \"init+update+final aligned buffer\",\n\t\t.src_divs = { { .proportion_of_total = 10000 } },\n\t\t.finalization_type = FINALIZATION_TYPE_FINAL,\n\t}, {\n\t\t.name = \"init+finup aligned buffer\",\n\t\t.src_divs = { { .proportion_of_total = 10000 } },\n\t\t.finalization_type = FINALIZATION_TYPE_FINUP,\n\t}, {\n\t\t.name = \"digest aligned buffer\",\n\t\t.src_divs = { { .proportion_of_total = 10000 } },\n\t\t.finalization_type = FINALIZATION_TYPE_DIGEST,\n\t}, {\n\t\t.name = \"init+update+final misaligned buffer\",\n\t\t.src_divs = { { .proportion_of_total = 10000, .offset = 1 } },\n\t\t.finalization_type = FINALIZATION_TYPE_FINAL,\n\t\t.key_offset = 1,\n\t}, {\n\t\t.name = \"digest buffer aligned only to alignmask\",\n\t\t.src_divs = {\n\t\t\t{\n\t\t\t\t.proportion_of_total = 10000,\n\t\t\t\t.offset = 1,\n\t\t\t\t.offset_relative_to_alignmask = true,\n\t\t\t},\n\t\t},\n\t\t.finalization_type = FINALIZATION_TYPE_DIGEST,\n\t\t.key_offset = 1,\n\t\t.key_offset_relative_to_alignmask = true,\n\t}, {\n\t\t.name = \"init+update+update+final two even splits\",\n\t\t.src_divs = {\n\t\t\t{ .proportion_of_total = 5000 },\n\t\t\t{\n\t\t\t\t.proportion_of_total = 5000,\n\t\t\t\t.flush_type = FLUSH_TYPE_FLUSH,\n\t\t\t},\n\t\t},\n\t\t.finalization_type = FINALIZATION_TYPE_FINAL,\n\t}, {\n\t\t.name = \"digest uneven misaligned splits, may sleep\",\n\t\t.req_flags = CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t.src_divs = {\n\t\t\t{ .proportion_of_total = 1900, .offset = 33 },\n\t\t\t{ .proportion_of_total = 3300, .offset = 7  },\n\t\t\t{ .proportion_of_total = 4800, .offset = 18 },\n\t\t},\n\t\t.finalization_type = FINALIZATION_TYPE_DIGEST,\n\t}, {\n\t\t.name = \"digest misaligned splits crossing pages\",\n\t\t.src_divs = {\n\t\t\t{\n\t\t\t\t.proportion_of_total = 7500,\n\t\t\t\t.offset = PAGE_SIZE - 32,\n\t\t\t}, {\n\t\t\t\t.proportion_of_total = 2500,\n\t\t\t\t.offset = PAGE_SIZE - 7,\n\t\t\t},\n\t\t},\n\t\t.finalization_type = FINALIZATION_TYPE_DIGEST,\n\t}, {\n\t\t.name = \"import/export\",\n\t\t.src_divs = {\n\t\t\t{\n\t\t\t\t.proportion_of_total = 6500,\n\t\t\t\t.flush_type = FLUSH_TYPE_REIMPORT,\n\t\t\t}, {\n\t\t\t\t.proportion_of_total = 3500,\n\t\t\t\t.flush_type = FLUSH_TYPE_REIMPORT,\n\t\t\t},\n\t\t},\n\t\t.finalization_type = FINALIZATION_TYPE_FINAL,\n\t}\n};\n\nstatic unsigned int count_test_sg_divisions(const struct test_sg_division *divs)\n{\n\tunsigned int remaining = TEST_SG_TOTAL;\n\tunsigned int ndivs = 0;\n\n\tdo {\n\t\tremaining -= divs[ndivs++].proportion_of_total;\n\t} while (remaining);\n\n\treturn ndivs;\n}\n\n#define SGDIVS_HAVE_FLUSHES\tBIT(0)\n#define SGDIVS_HAVE_NOSIMD\tBIT(1)\n\nstatic bool valid_sg_divisions(const struct test_sg_division *divs,\n\t\t\t       unsigned int count, int *flags_ret)\n{\n\tunsigned int total = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < count && total != TEST_SG_TOTAL; i++) {\n\t\tif (divs[i].proportion_of_total <= 0 ||\n\t\t    divs[i].proportion_of_total > TEST_SG_TOTAL - total)\n\t\t\treturn false;\n\t\ttotal += divs[i].proportion_of_total;\n\t\tif (divs[i].flush_type != FLUSH_TYPE_NONE)\n\t\t\t*flags_ret |= SGDIVS_HAVE_FLUSHES;\n\t\tif (divs[i].nosimd)\n\t\t\t*flags_ret |= SGDIVS_HAVE_NOSIMD;\n\t}\n\treturn total == TEST_SG_TOTAL &&\n\t\tmemchr_inv(&divs[i], 0, (count - i) * sizeof(divs[0])) == NULL;\n}\n\n \nstatic bool valid_testvec_config(const struct testvec_config *cfg)\n{\n\tint flags = 0;\n\n\tif (cfg->name == NULL)\n\t\treturn false;\n\n\tif (!valid_sg_divisions(cfg->src_divs, ARRAY_SIZE(cfg->src_divs),\n\t\t\t\t&flags))\n\t\treturn false;\n\n\tif (cfg->dst_divs[0].proportion_of_total) {\n\t\tif (!valid_sg_divisions(cfg->dst_divs,\n\t\t\t\t\tARRAY_SIZE(cfg->dst_divs), &flags))\n\t\t\treturn false;\n\t} else {\n\t\tif (memchr_inv(cfg->dst_divs, 0, sizeof(cfg->dst_divs)))\n\t\t\treturn false;\n\t\t \n\t}\n\n\tif (cfg->iv_offset +\n\t    (cfg->iv_offset_relative_to_alignmask ? MAX_ALGAPI_ALIGNMASK : 0) >\n\t    MAX_ALGAPI_ALIGNMASK + 1)\n\t\treturn false;\n\n\tif ((flags & (SGDIVS_HAVE_FLUSHES | SGDIVS_HAVE_NOSIMD)) &&\n\t    cfg->finalization_type == FINALIZATION_TYPE_DIGEST)\n\t\treturn false;\n\n\tif ((cfg->nosimd || (flags & SGDIVS_HAVE_NOSIMD)) &&\n\t    (cfg->req_flags & CRYPTO_TFM_REQ_MAY_SLEEP))\n\t\treturn false;\n\n\treturn true;\n}\n\nstruct test_sglist {\n\tchar *bufs[XBUFSIZE];\n\tstruct scatterlist sgl[XBUFSIZE];\n\tstruct scatterlist sgl_saved[XBUFSIZE];\n\tstruct scatterlist *sgl_ptr;\n\tunsigned int nents;\n};\n\nstatic int init_test_sglist(struct test_sglist *tsgl)\n{\n\treturn __testmgr_alloc_buf(tsgl->bufs, 1  );\n}\n\nstatic void destroy_test_sglist(struct test_sglist *tsgl)\n{\n\treturn __testmgr_free_buf(tsgl->bufs, 1  );\n}\n\n \nstatic int build_test_sglist(struct test_sglist *tsgl,\n\t\t\t     const struct test_sg_division *divs,\n\t\t\t     const unsigned int alignmask,\n\t\t\t     const unsigned int total_len,\n\t\t\t     struct iov_iter *data,\n\t\t\t     const struct test_sg_division *out_divs[XBUFSIZE])\n{\n\tstruct {\n\t\tconst struct test_sg_division *div;\n\t\tsize_t length;\n\t} partitions[XBUFSIZE];\n\tconst unsigned int ndivs = count_test_sg_divisions(divs);\n\tunsigned int len_remaining = total_len;\n\tunsigned int i;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(partitions) != ARRAY_SIZE(tsgl->sgl));\n\tif (WARN_ON(ndivs > ARRAY_SIZE(partitions)))\n\t\treturn -EINVAL;\n\n\t \n\ttsgl->nents = 0;\n\tfor (i = 0; i < ndivs; i++) {\n\t\tunsigned int len_this_sg =\n\t\t\tmin(len_remaining,\n\t\t\t    (total_len * divs[i].proportion_of_total +\n\t\t\t     TEST_SG_TOTAL / 2) / TEST_SG_TOTAL);\n\n\t\tif (len_this_sg != 0) {\n\t\t\tpartitions[tsgl->nents].div = &divs[i];\n\t\t\tpartitions[tsgl->nents].length = len_this_sg;\n\t\t\ttsgl->nents++;\n\t\t\tlen_remaining -= len_this_sg;\n\t\t}\n\t}\n\tif (tsgl->nents == 0) {\n\t\tpartitions[tsgl->nents].div = &divs[0];\n\t\tpartitions[tsgl->nents].length = 0;\n\t\ttsgl->nents++;\n\t}\n\tpartitions[tsgl->nents - 1].length += len_remaining;\n\n\t \n\tsg_init_table(tsgl->sgl, tsgl->nents);\n\tfor (i = 0; i < tsgl->nents; i++) {\n\t\tunsigned int offset = partitions[i].div->offset;\n\t\tvoid *addr;\n\n\t\tif (partitions[i].div->offset_relative_to_alignmask)\n\t\t\toffset += alignmask;\n\n\t\twhile (offset + partitions[i].length + TESTMGR_POISON_LEN >\n\t\t       2 * PAGE_SIZE) {\n\t\t\tif (WARN_ON(offset <= 0))\n\t\t\t\treturn -EINVAL;\n\t\t\toffset /= 2;\n\t\t}\n\n\t\taddr = &tsgl->bufs[i][offset];\n\t\tsg_set_buf(&tsgl->sgl[i], addr, partitions[i].length);\n\n\t\tif (out_divs)\n\t\t\tout_divs[i] = partitions[i].div;\n\n\t\tif (data) {\n\t\t\tsize_t copy_len, copied;\n\n\t\t\tcopy_len = min(partitions[i].length, data->count);\n\t\t\tcopied = copy_from_iter(addr, copy_len, data);\n\t\t\tif (WARN_ON(copied != copy_len))\n\t\t\t\treturn -EINVAL;\n\t\t\ttestmgr_poison(addr + copy_len, partitions[i].length +\n\t\t\t\t       TESTMGR_POISON_LEN - copy_len);\n\t\t} else {\n\t\t\ttestmgr_poison(addr, partitions[i].length +\n\t\t\t\t       TESTMGR_POISON_LEN);\n\t\t}\n\t}\n\n\tsg_mark_end(&tsgl->sgl[tsgl->nents - 1]);\n\ttsgl->sgl_ptr = tsgl->sgl;\n\tmemcpy(tsgl->sgl_saved, tsgl->sgl, tsgl->nents * sizeof(tsgl->sgl[0]));\n\treturn 0;\n}\n\n \nstatic int verify_correct_output(const struct test_sglist *tsgl,\n\t\t\t\t const char *expected_output,\n\t\t\t\t unsigned int len_to_check,\n\t\t\t\t unsigned int unchecked_prefix_len,\n\t\t\t\t bool check_poison)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < tsgl->nents; i++) {\n\t\tstruct scatterlist *sg = &tsgl->sgl_ptr[i];\n\t\tunsigned int len = sg->length;\n\t\tunsigned int offset = sg->offset;\n\t\tconst char *actual_output;\n\n\t\tif (unchecked_prefix_len) {\n\t\t\tif (unchecked_prefix_len >= len) {\n\t\t\t\tunchecked_prefix_len -= len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toffset += unchecked_prefix_len;\n\t\t\tlen -= unchecked_prefix_len;\n\t\t\tunchecked_prefix_len = 0;\n\t\t}\n\t\tlen = min(len, len_to_check);\n\t\tactual_output = page_address(sg_page(sg)) + offset;\n\t\tif (memcmp(expected_output, actual_output, len) != 0)\n\t\t\treturn -EINVAL;\n\t\tif (check_poison &&\n\t\t    !testmgr_is_poison(actual_output + len, TESTMGR_POISON_LEN))\n\t\t\treturn -EOVERFLOW;\n\t\tlen_to_check -= len;\n\t\texpected_output += len;\n\t}\n\tif (WARN_ON(len_to_check != 0))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic bool is_test_sglist_corrupted(const struct test_sglist *tsgl)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < tsgl->nents; i++) {\n\t\tif (tsgl->sgl[i].page_link != tsgl->sgl_saved[i].page_link)\n\t\t\treturn true;\n\t\tif (tsgl->sgl[i].offset != tsgl->sgl_saved[i].offset)\n\t\t\treturn true;\n\t\tif (tsgl->sgl[i].length != tsgl->sgl_saved[i].length)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct cipher_test_sglists {\n\tstruct test_sglist src;\n\tstruct test_sglist dst;\n};\n\nstatic struct cipher_test_sglists *alloc_cipher_test_sglists(void)\n{\n\tstruct cipher_test_sglists *tsgls;\n\n\ttsgls = kmalloc(sizeof(*tsgls), GFP_KERNEL);\n\tif (!tsgls)\n\t\treturn NULL;\n\n\tif (init_test_sglist(&tsgls->src) != 0)\n\t\tgoto fail_kfree;\n\tif (init_test_sglist(&tsgls->dst) != 0)\n\t\tgoto fail_destroy_src;\n\n\treturn tsgls;\n\nfail_destroy_src:\n\tdestroy_test_sglist(&tsgls->src);\nfail_kfree:\n\tkfree(tsgls);\n\treturn NULL;\n}\n\nstatic void free_cipher_test_sglists(struct cipher_test_sglists *tsgls)\n{\n\tif (tsgls) {\n\t\tdestroy_test_sglist(&tsgls->src);\n\t\tdestroy_test_sglist(&tsgls->dst);\n\t\tkfree(tsgls);\n\t}\n}\n\n \nstatic int build_cipher_test_sglists(struct cipher_test_sglists *tsgls,\n\t\t\t\t     const struct testvec_config *cfg,\n\t\t\t\t     unsigned int alignmask,\n\t\t\t\t     unsigned int src_total_len,\n\t\t\t\t     unsigned int dst_total_len,\n\t\t\t\t     const struct kvec *inputs,\n\t\t\t\t     unsigned int nr_inputs)\n{\n\tstruct iov_iter input;\n\tint err;\n\n\tiov_iter_kvec(&input, ITER_SOURCE, inputs, nr_inputs, src_total_len);\n\terr = build_test_sglist(&tsgls->src, cfg->src_divs, alignmask,\n\t\t\t\tcfg->inplace_mode != OUT_OF_PLACE ?\n\t\t\t\t\tmax(dst_total_len, src_total_len) :\n\t\t\t\t\tsrc_total_len,\n\t\t\t\t&input, NULL);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (cfg->inplace_mode == INPLACE_ONE_SGLIST) {\n\t\ttsgls->dst.sgl_ptr = tsgls->src.sgl;\n\t\ttsgls->dst.nents = tsgls->src.nents;\n\t\treturn 0;\n\t}\n\tif (cfg->inplace_mode == INPLACE_TWO_SGLISTS) {\n\t\t \n\t\tmemcpy(tsgls->dst.sgl, tsgls->src.sgl,\n\t\t       tsgls->src.nents * sizeof(tsgls->src.sgl[0]));\n\t\tmemcpy(tsgls->dst.sgl_saved, tsgls->src.sgl,\n\t\t       tsgls->src.nents * sizeof(tsgls->src.sgl[0]));\n\t\ttsgls->dst.sgl_ptr = tsgls->dst.sgl;\n\t\ttsgls->dst.nents = tsgls->src.nents;\n\t\treturn 0;\n\t}\n\t \n\treturn build_test_sglist(&tsgls->dst,\n\t\t\t\t cfg->dst_divs[0].proportion_of_total ?\n\t\t\t\t\tcfg->dst_divs : cfg->src_divs,\n\t\t\t\t alignmask, dst_total_len, NULL, NULL);\n}\n\n \nstatic int prepare_keybuf(const u8 *key, unsigned int ksize,\n\t\t\t  const struct testvec_config *cfg,\n\t\t\t  unsigned int alignmask,\n\t\t\t  const u8 **keybuf_ret, const u8 **keyptr_ret)\n{\n\tunsigned int key_offset = cfg->key_offset;\n\tu8 *keybuf = NULL, *keyptr = (u8 *)key;\n\n\tif (key_offset != 0) {\n\t\tif (cfg->key_offset_relative_to_alignmask)\n\t\t\tkey_offset += alignmask;\n\t\tkeybuf = kmalloc(key_offset + ksize, GFP_KERNEL);\n\t\tif (!keybuf)\n\t\t\treturn -ENOMEM;\n\t\tkeyptr = keybuf + key_offset;\n\t\tmemcpy(keyptr, key, ksize);\n\t}\n\t*keybuf_ret = keybuf;\n\t*keyptr_ret = keyptr;\n\treturn 0;\n}\n\n \n#define do_setkey(setkey_f, tfm, key, ksize, cfg, alignmask)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tconst u8 *keybuf, *keyptr;\t\t\t\t\t\\\n\tint err;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = prepare_keybuf((key), (ksize), (cfg), (alignmask),\t\\\n\t\t\t     &keybuf, &keyptr);\t\t\t\t\\\n\tif (err == 0) {\t\t\t\t\t\t\t\\\n\t\terr = setkey_f((tfm), keyptr, (ksize));\t\t\t\\\n\t\tkfree(keybuf);\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\terr;\t\t\t\t\t\t\t\t\\\n})\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\n\n \n\nstatic inline void init_rnd_state(struct rnd_state *rng)\n{\n\tprandom_seed_state(rng, get_random_u64());\n}\n\nstatic inline u8 prandom_u8(struct rnd_state *rng)\n{\n\treturn prandom_u32_state(rng);\n}\n\nstatic inline u32 prandom_u32_below(struct rnd_state *rng, u32 ceil)\n{\n\t \n\treturn prandom_u32_state(rng) % ceil;\n}\n\nstatic inline bool prandom_bool(struct rnd_state *rng)\n{\n\treturn prandom_u32_below(rng, 2);\n}\n\nstatic inline u32 prandom_u32_inclusive(struct rnd_state *rng,\n\t\t\t\t\tu32 floor, u32 ceil)\n{\n\treturn floor + prandom_u32_below(rng, ceil - floor + 1);\n}\n\n \nstatic unsigned int generate_random_length(struct rnd_state *rng,\n\t\t\t\t\t   unsigned int max_len)\n{\n\tunsigned int len = prandom_u32_below(rng, max_len + 1);\n\n\tswitch (prandom_u32_below(rng, 4)) {\n\tcase 0:\n\t\treturn len % 64;\n\tcase 1:\n\t\treturn len % 256;\n\tcase 2:\n\t\treturn len % 1024;\n\tdefault:\n\t\treturn len;\n\t}\n}\n\n \nstatic void flip_random_bit(struct rnd_state *rng, u8 *buf, size_t size)\n{\n\tsize_t bitpos;\n\n\tbitpos = prandom_u32_below(rng, size * 8);\n\tbuf[bitpos / 8] ^= 1 << (bitpos % 8);\n}\n\n \nstatic void flip_random_byte(struct rnd_state *rng, u8 *buf, size_t size)\n{\n\tbuf[prandom_u32_below(rng, size)] ^= 0xff;\n}\n\n \nstatic void mutate_buffer(struct rnd_state *rng, u8 *buf, size_t size)\n{\n\tsize_t num_flips;\n\tsize_t i;\n\n\t \n\tif (prandom_u32_below(rng, 4) == 0) {\n\t\tnum_flips = min_t(size_t, 1 << prandom_u32_below(rng, 8),\n\t\t\t\t  size * 8);\n\t\tfor (i = 0; i < num_flips; i++)\n\t\t\tflip_random_bit(rng, buf, size);\n\t}\n\n\t \n\tif (prandom_u32_below(rng, 4) == 0) {\n\t\tnum_flips = min_t(size_t, 1 << prandom_u32_below(rng, 8), size);\n\t\tfor (i = 0; i < num_flips; i++)\n\t\t\tflip_random_byte(rng, buf, size);\n\t}\n}\n\n \nstatic void generate_random_bytes(struct rnd_state *rng, u8 *buf, size_t count)\n{\n\tu8 b;\n\tu8 increment;\n\tsize_t i;\n\n\tif (count == 0)\n\t\treturn;\n\n\tswitch (prandom_u32_below(rng, 8)) {  \n\tcase 0:\n\tcase 1:\n\t\t \n\t\tswitch (prandom_u32_below(rng, 4)) {\n\t\tcase 0:\n\t\t\tb = 0x00;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tb = 0xff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tb = prandom_u8(rng);\n\t\t\tbreak;\n\t\t}\n\t\tmemset(buf, b, count);\n\t\tmutate_buffer(rng, buf, count);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tincrement = prandom_u8(rng);\n\t\tb = prandom_u8(rng);\n\t\tfor (i = 0; i < count; i++, b += increment)\n\t\t\tbuf[i] = b;\n\t\tmutate_buffer(rng, buf, count);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tprandom_bytes_state(rng, buf, count);\n\t}\n}\n\nstatic char *generate_random_sgl_divisions(struct rnd_state *rng,\n\t\t\t\t\t   struct test_sg_division *divs,\n\t\t\t\t\t   size_t max_divs, char *p, char *end,\n\t\t\t\t\t   bool gen_flushes, u32 req_flags)\n{\n\tstruct test_sg_division *div = divs;\n\tunsigned int remaining = TEST_SG_TOTAL;\n\n\tdo {\n\t\tunsigned int this_len;\n\t\tconst char *flushtype_str;\n\n\t\tif (div == &divs[max_divs - 1] || prandom_bool(rng))\n\t\t\tthis_len = remaining;\n\t\telse\n\t\t\tthis_len = prandom_u32_inclusive(rng, 1, remaining);\n\t\tdiv->proportion_of_total = this_len;\n\n\t\tif (prandom_u32_below(rng, 4) == 0)\n\t\t\tdiv->offset = prandom_u32_inclusive(rng,\n\t\t\t\t\t\t\t    PAGE_SIZE - 128,\n\t\t\t\t\t\t\t    PAGE_SIZE - 1);\n\t\telse if (prandom_bool(rng))\n\t\t\tdiv->offset = prandom_u32_below(rng, 32);\n\t\telse\n\t\t\tdiv->offset = prandom_u32_below(rng, PAGE_SIZE);\n\t\tif (prandom_u32_below(rng, 8) == 0)\n\t\t\tdiv->offset_relative_to_alignmask = true;\n\n\t\tdiv->flush_type = FLUSH_TYPE_NONE;\n\t\tif (gen_flushes) {\n\t\t\tswitch (prandom_u32_below(rng, 4)) {\n\t\t\tcase 0:\n\t\t\t\tdiv->flush_type = FLUSH_TYPE_REIMPORT;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdiv->flush_type = FLUSH_TYPE_FLUSH;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (div->flush_type != FLUSH_TYPE_NONE &&\n\t\t    !(req_flags & CRYPTO_TFM_REQ_MAY_SLEEP) &&\n\t\t    prandom_bool(rng))\n\t\t\tdiv->nosimd = true;\n\n\t\tswitch (div->flush_type) {\n\t\tcase FLUSH_TYPE_FLUSH:\n\t\t\tif (div->nosimd)\n\t\t\t\tflushtype_str = \"<flush,nosimd>\";\n\t\t\telse\n\t\t\t\tflushtype_str = \"<flush>\";\n\t\t\tbreak;\n\t\tcase FLUSH_TYPE_REIMPORT:\n\t\t\tif (div->nosimd)\n\t\t\t\tflushtype_str = \"<reimport,nosimd>\";\n\t\t\telse\n\t\t\t\tflushtype_str = \"<reimport>\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tflushtype_str = \"\";\n\t\t\tbreak;\n\t\t}\n\n\t\tBUILD_BUG_ON(TEST_SG_TOTAL != 10000);  \n\t\tp += scnprintf(p, end - p, \"%s%u.%u%%@%s+%u%s\", flushtype_str,\n\t\t\t       this_len / 100, this_len % 100,\n\t\t\t       div->offset_relative_to_alignmask ?\n\t\t\t\t\t\"alignmask\" : \"\",\n\t\t\t       div->offset, this_len == remaining ? \"\" : \", \");\n\t\tremaining -= this_len;\n\t\tdiv++;\n\t} while (remaining);\n\n\treturn p;\n}\n\n \nstatic void generate_random_testvec_config(struct rnd_state *rng,\n\t\t\t\t\t   struct testvec_config *cfg,\n\t\t\t\t\t   char *name, size_t max_namelen)\n{\n\tchar *p = name;\n\tchar * const end = name + max_namelen;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\n\tcfg->name = name;\n\n\tp += scnprintf(p, end - p, \"random:\");\n\n\tswitch (prandom_u32_below(rng, 4)) {\n\tcase 0:\n\tcase 1:\n\t\tcfg->inplace_mode = OUT_OF_PLACE;\n\t\tbreak;\n\tcase 2:\n\t\tcfg->inplace_mode = INPLACE_ONE_SGLIST;\n\t\tp += scnprintf(p, end - p, \" inplace_one_sglist\");\n\t\tbreak;\n\tdefault:\n\t\tcfg->inplace_mode = INPLACE_TWO_SGLISTS;\n\t\tp += scnprintf(p, end - p, \" inplace_two_sglists\");\n\t\tbreak;\n\t}\n\n\tif (prandom_bool(rng)) {\n\t\tcfg->req_flags |= CRYPTO_TFM_REQ_MAY_SLEEP;\n\t\tp += scnprintf(p, end - p, \" may_sleep\");\n\t}\n\n\tswitch (prandom_u32_below(rng, 4)) {\n\tcase 0:\n\t\tcfg->finalization_type = FINALIZATION_TYPE_FINAL;\n\t\tp += scnprintf(p, end - p, \" use_final\");\n\t\tbreak;\n\tcase 1:\n\t\tcfg->finalization_type = FINALIZATION_TYPE_FINUP;\n\t\tp += scnprintf(p, end - p, \" use_finup\");\n\t\tbreak;\n\tdefault:\n\t\tcfg->finalization_type = FINALIZATION_TYPE_DIGEST;\n\t\tp += scnprintf(p, end - p, \" use_digest\");\n\t\tbreak;\n\t}\n\n\tif (!(cfg->req_flags & CRYPTO_TFM_REQ_MAY_SLEEP) && prandom_bool(rng)) {\n\t\tcfg->nosimd = true;\n\t\tp += scnprintf(p, end - p, \" nosimd\");\n\t}\n\n\tp += scnprintf(p, end - p, \" src_divs=[\");\n\tp = generate_random_sgl_divisions(rng, cfg->src_divs,\n\t\t\t\t\t  ARRAY_SIZE(cfg->src_divs), p, end,\n\t\t\t\t\t  (cfg->finalization_type !=\n\t\t\t\t\t   FINALIZATION_TYPE_DIGEST),\n\t\t\t\t\t  cfg->req_flags);\n\tp += scnprintf(p, end - p, \"]\");\n\n\tif (cfg->inplace_mode == OUT_OF_PLACE && prandom_bool(rng)) {\n\t\tp += scnprintf(p, end - p, \" dst_divs=[\");\n\t\tp = generate_random_sgl_divisions(rng, cfg->dst_divs,\n\t\t\t\t\t\t  ARRAY_SIZE(cfg->dst_divs),\n\t\t\t\t\t\t  p, end, false,\n\t\t\t\t\t\t  cfg->req_flags);\n\t\tp += scnprintf(p, end - p, \"]\");\n\t}\n\n\tif (prandom_bool(rng)) {\n\t\tcfg->iv_offset = prandom_u32_inclusive(rng, 1,\n\t\t\t\t\t\t       MAX_ALGAPI_ALIGNMASK);\n\t\tp += scnprintf(p, end - p, \" iv_offset=%u\", cfg->iv_offset);\n\t}\n\n\tif (prandom_bool(rng)) {\n\t\tcfg->key_offset = prandom_u32_inclusive(rng, 1,\n\t\t\t\t\t\t\tMAX_ALGAPI_ALIGNMASK);\n\t\tp += scnprintf(p, end - p, \" key_offset=%u\", cfg->key_offset);\n\t}\n\n\tWARN_ON_ONCE(!valid_testvec_config(cfg));\n}\n\nstatic void crypto_disable_simd_for_test(void)\n{\n\tmigrate_disable();\n\t__this_cpu_write(crypto_simd_disabled_for_test, true);\n}\n\nstatic void crypto_reenable_simd_for_test(void)\n{\n\t__this_cpu_write(crypto_simd_disabled_for_test, false);\n\tmigrate_enable();\n}\n\n \nstatic int build_generic_driver_name(const char *algname,\n\t\t\t\t     char driver_name[CRYPTO_MAX_ALG_NAME])\n{\n\tconst char *in = algname;\n\tchar *out = driver_name;\n\tsize_t len = strlen(algname);\n\n\tif (len >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto too_long;\n\tdo {\n\t\tconst char *in_saved = in;\n\n\t\twhile (*in && *in != '(' && *in != ')' && *in != ',')\n\t\t\t*out++ = *in++;\n\t\tif (*in != '(' && in > in_saved) {\n\t\t\tlen += 8;\n\t\t\tif (len >= CRYPTO_MAX_ALG_NAME)\n\t\t\t\tgoto too_long;\n\t\t\tmemcpy(out, \"-generic\", 8);\n\t\t\tout += 8;\n\t\t}\n\t} while ((*out++ = *in++) != '\\0');\n\treturn 0;\n\ntoo_long:\n\tpr_err(\"alg: generic driver name for \\\"%s\\\" would be too long\\n\",\n\t       algname);\n\treturn -ENAMETOOLONG;\n}\n#else  \nstatic void crypto_disable_simd_for_test(void)\n{\n}\n\nstatic void crypto_reenable_simd_for_test(void)\n{\n}\n#endif  \n\nstatic int build_hash_sglist(struct test_sglist *tsgl,\n\t\t\t     const struct hash_testvec *vec,\n\t\t\t     const struct testvec_config *cfg,\n\t\t\t     unsigned int alignmask,\n\t\t\t     const struct test_sg_division *divs[XBUFSIZE])\n{\n\tstruct kvec kv;\n\tstruct iov_iter input;\n\n\tkv.iov_base = (void *)vec->plaintext;\n\tkv.iov_len = vec->psize;\n\tiov_iter_kvec(&input, ITER_SOURCE, &kv, 1, vec->psize);\n\treturn build_test_sglist(tsgl, cfg->src_divs, alignmask, vec->psize,\n\t\t\t\t &input, divs);\n}\n\nstatic int check_hash_result(const char *type,\n\t\t\t     const u8 *result, unsigned int digestsize,\n\t\t\t     const struct hash_testvec *vec,\n\t\t\t     const char *vec_name,\n\t\t\t     const char *driver,\n\t\t\t     const struct testvec_config *cfg)\n{\n\tif (memcmp(result, vec->digest, digestsize) != 0) {\n\t\tpr_err(\"alg: %s: %s test failed (wrong result) on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       type, driver, vec_name, cfg->name);\n\t\treturn -EINVAL;\n\t}\n\tif (!testmgr_is_poison(&result[digestsize], TESTMGR_POISON_LEN)) {\n\t\tpr_err(\"alg: %s: %s overran result buffer on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       type, driver, vec_name, cfg->name);\n\t\treturn -EOVERFLOW;\n\t}\n\treturn 0;\n}\n\nstatic inline int check_shash_op(const char *op, int err,\n\t\t\t\t const char *driver, const char *vec_name,\n\t\t\t\t const struct testvec_config *cfg)\n{\n\tif (err)\n\t\tpr_err(\"alg: shash: %s %s() failed with err %d on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, err, vec_name, cfg->name);\n\treturn err;\n}\n\n \nstatic int test_shash_vec_cfg(const struct hash_testvec *vec,\n\t\t\t      const char *vec_name,\n\t\t\t      const struct testvec_config *cfg,\n\t\t\t      struct shash_desc *desc,\n\t\t\t      struct test_sglist *tsgl,\n\t\t\t      u8 *hashstate)\n{\n\tstruct crypto_shash *tfm = desc->tfm;\n\tconst unsigned int alignmask = crypto_shash_alignmask(tfm);\n\tconst unsigned int digestsize = crypto_shash_digestsize(tfm);\n\tconst unsigned int statesize = crypto_shash_statesize(tfm);\n\tconst char *driver = crypto_shash_driver_name(tfm);\n\tconst struct test_sg_division *divs[XBUFSIZE];\n\tunsigned int i;\n\tu8 result[HASH_MAX_DIGESTSIZE + TESTMGR_POISON_LEN];\n\tint err;\n\n\t \n\tif (vec->ksize) {\n\t\terr = do_setkey(crypto_shash_setkey, tfm, vec->key, vec->ksize,\n\t\t\t\tcfg, alignmask);\n\t\tif (err) {\n\t\t\tif (err == vec->setkey_error)\n\t\t\t\treturn 0;\n\t\t\tpr_err(\"alg: shash: %s setkey failed on test vector %s; expected_error=%d, actual_error=%d, flags=%#x\\n\",\n\t\t\t       driver, vec_name, vec->setkey_error, err,\n\t\t\t       crypto_shash_get_flags(tfm));\n\t\t\treturn err;\n\t\t}\n\t\tif (vec->setkey_error) {\n\t\t\tpr_err(\"alg: shash: %s setkey unexpectedly succeeded on test vector %s; expected_error=%d\\n\",\n\t\t\t       driver, vec_name, vec->setkey_error);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\terr = build_hash_sglist(tsgl, vec, cfg, alignmask, divs);\n\tif (err) {\n\t\tpr_err(\"alg: shash: %s: error preparing scatterlist for test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, vec_name, cfg->name);\n\t\treturn err;\n\t}\n\n\t \n\n\ttestmgr_poison(desc->__ctx, crypto_shash_descsize(tfm));\n\ttestmgr_poison(result, digestsize + TESTMGR_POISON_LEN);\n\n\tif (cfg->finalization_type == FINALIZATION_TYPE_DIGEST ||\n\t    vec->digest_error) {\n\t\t \n\t\tif (tsgl->nents != 1)\n\t\t\treturn 0;\n\t\tif (cfg->nosimd)\n\t\t\tcrypto_disable_simd_for_test();\n\t\terr = crypto_shash_digest(desc, sg_virt(&tsgl->sgl[0]),\n\t\t\t\t\t  tsgl->sgl[0].length, result);\n\t\tif (cfg->nosimd)\n\t\t\tcrypto_reenable_simd_for_test();\n\t\tif (err) {\n\t\t\tif (err == vec->digest_error)\n\t\t\t\treturn 0;\n\t\t\tpr_err(\"alg: shash: %s digest() failed on test vector %s; expected_error=%d, actual_error=%d, cfg=\\\"%s\\\"\\n\",\n\t\t\t       driver, vec_name, vec->digest_error, err,\n\t\t\t       cfg->name);\n\t\t\treturn err;\n\t\t}\n\t\tif (vec->digest_error) {\n\t\t\tpr_err(\"alg: shash: %s digest() unexpectedly succeeded on test vector %s; expected_error=%d, cfg=\\\"%s\\\"\\n\",\n\t\t\t       driver, vec_name, vec->digest_error, cfg->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tgoto result_ready;\n\t}\n\n\t \n\n\tif (cfg->nosimd)\n\t\tcrypto_disable_simd_for_test();\n\terr = crypto_shash_init(desc);\n\tif (cfg->nosimd)\n\t\tcrypto_reenable_simd_for_test();\n\terr = check_shash_op(\"init\", err, driver, vec_name, cfg);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < tsgl->nents; i++) {\n\t\tif (i + 1 == tsgl->nents &&\n\t\t    cfg->finalization_type == FINALIZATION_TYPE_FINUP) {\n\t\t\tif (divs[i]->nosimd)\n\t\t\t\tcrypto_disable_simd_for_test();\n\t\t\terr = crypto_shash_finup(desc, sg_virt(&tsgl->sgl[i]),\n\t\t\t\t\t\t tsgl->sgl[i].length, result);\n\t\t\tif (divs[i]->nosimd)\n\t\t\t\tcrypto_reenable_simd_for_test();\n\t\t\terr = check_shash_op(\"finup\", err, driver, vec_name,\n\t\t\t\t\t     cfg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tgoto result_ready;\n\t\t}\n\t\tif (divs[i]->nosimd)\n\t\t\tcrypto_disable_simd_for_test();\n\t\terr = crypto_shash_update(desc, sg_virt(&tsgl->sgl[i]),\n\t\t\t\t\t  tsgl->sgl[i].length);\n\t\tif (divs[i]->nosimd)\n\t\t\tcrypto_reenable_simd_for_test();\n\t\terr = check_shash_op(\"update\", err, driver, vec_name, cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (divs[i]->flush_type == FLUSH_TYPE_REIMPORT) {\n\t\t\t \n\t\t\ttestmgr_poison(hashstate + statesize,\n\t\t\t\t       TESTMGR_POISON_LEN);\n\t\t\terr = crypto_shash_export(desc, hashstate);\n\t\t\terr = check_shash_op(\"export\", err, driver, vec_name,\n\t\t\t\t\t     cfg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (!testmgr_is_poison(hashstate + statesize,\n\t\t\t\t\t       TESTMGR_POISON_LEN)) {\n\t\t\t\tpr_err(\"alg: shash: %s export() overran state buffer on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t\t\t       driver, vec_name, cfg->name);\n\t\t\t\treturn -EOVERFLOW;\n\t\t\t}\n\t\t\ttestmgr_poison(desc->__ctx, crypto_shash_descsize(tfm));\n\t\t\terr = crypto_shash_import(desc, hashstate);\n\t\t\terr = check_shash_op(\"import\", err, driver, vec_name,\n\t\t\t\t\t     cfg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (cfg->nosimd)\n\t\tcrypto_disable_simd_for_test();\n\terr = crypto_shash_final(desc, result);\n\tif (cfg->nosimd)\n\t\tcrypto_reenable_simd_for_test();\n\terr = check_shash_op(\"final\", err, driver, vec_name, cfg);\n\tif (err)\n\t\treturn err;\nresult_ready:\n\treturn check_hash_result(\"shash\", result, digestsize, vec, vec_name,\n\t\t\t\t driver, cfg);\n}\n\nstatic int do_ahash_op(int (*op)(struct ahash_request *req),\n\t\t       struct ahash_request *req,\n\t\t       struct crypto_wait *wait, bool nosimd)\n{\n\tint err;\n\n\tif (nosimd)\n\t\tcrypto_disable_simd_for_test();\n\n\terr = op(req);\n\n\tif (nosimd)\n\t\tcrypto_reenable_simd_for_test();\n\n\treturn crypto_wait_req(err, wait);\n}\n\nstatic int check_nonfinal_ahash_op(const char *op, int err,\n\t\t\t\t   u8 *result, unsigned int digestsize,\n\t\t\t\t   const char *driver, const char *vec_name,\n\t\t\t\t   const struct testvec_config *cfg)\n{\n\tif (err) {\n\t\tpr_err(\"alg: ahash: %s %s() failed with err %d on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, err, vec_name, cfg->name);\n\t\treturn err;\n\t}\n\tif (!testmgr_is_poison(result, digestsize)) {\n\t\tpr_err(\"alg: ahash: %s %s() used result buffer on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int test_ahash_vec_cfg(const struct hash_testvec *vec,\n\t\t\t      const char *vec_name,\n\t\t\t      const struct testvec_config *cfg,\n\t\t\t      struct ahash_request *req,\n\t\t\t      struct test_sglist *tsgl,\n\t\t\t      u8 *hashstate)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tconst unsigned int alignmask = crypto_ahash_alignmask(tfm);\n\tconst unsigned int digestsize = crypto_ahash_digestsize(tfm);\n\tconst unsigned int statesize = crypto_ahash_statesize(tfm);\n\tconst char *driver = crypto_ahash_driver_name(tfm);\n\tconst u32 req_flags = CRYPTO_TFM_REQ_MAY_BACKLOG | cfg->req_flags;\n\tconst struct test_sg_division *divs[XBUFSIZE];\n\tDECLARE_CRYPTO_WAIT(wait);\n\tunsigned int i;\n\tstruct scatterlist *pending_sgl;\n\tunsigned int pending_len;\n\tu8 result[HASH_MAX_DIGESTSIZE + TESTMGR_POISON_LEN];\n\tint err;\n\n\t \n\tif (vec->ksize) {\n\t\terr = do_setkey(crypto_ahash_setkey, tfm, vec->key, vec->ksize,\n\t\t\t\tcfg, alignmask);\n\t\tif (err) {\n\t\t\tif (err == vec->setkey_error)\n\t\t\t\treturn 0;\n\t\t\tpr_err(\"alg: ahash: %s setkey failed on test vector %s; expected_error=%d, actual_error=%d, flags=%#x\\n\",\n\t\t\t       driver, vec_name, vec->setkey_error, err,\n\t\t\t       crypto_ahash_get_flags(tfm));\n\t\t\treturn err;\n\t\t}\n\t\tif (vec->setkey_error) {\n\t\t\tpr_err(\"alg: ahash: %s setkey unexpectedly succeeded on test vector %s; expected_error=%d\\n\",\n\t\t\t       driver, vec_name, vec->setkey_error);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\terr = build_hash_sglist(tsgl, vec, cfg, alignmask, divs);\n\tif (err) {\n\t\tpr_err(\"alg: ahash: %s: error preparing scatterlist for test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, vec_name, cfg->name);\n\t\treturn err;\n\t}\n\n\t \n\n\ttestmgr_poison(req->__ctx, crypto_ahash_reqsize(tfm));\n\ttestmgr_poison(result, digestsize + TESTMGR_POISON_LEN);\n\n\tif (cfg->finalization_type == FINALIZATION_TYPE_DIGEST ||\n\t    vec->digest_error) {\n\t\t \n\t\tahash_request_set_callback(req, req_flags, crypto_req_done,\n\t\t\t\t\t   &wait);\n\t\tahash_request_set_crypt(req, tsgl->sgl, result, vec->psize);\n\t\terr = do_ahash_op(crypto_ahash_digest, req, &wait, cfg->nosimd);\n\t\tif (err) {\n\t\t\tif (err == vec->digest_error)\n\t\t\t\treturn 0;\n\t\t\tpr_err(\"alg: ahash: %s digest() failed on test vector %s; expected_error=%d, actual_error=%d, cfg=\\\"%s\\\"\\n\",\n\t\t\t       driver, vec_name, vec->digest_error, err,\n\t\t\t       cfg->name);\n\t\t\treturn err;\n\t\t}\n\t\tif (vec->digest_error) {\n\t\t\tpr_err(\"alg: ahash: %s digest() unexpectedly succeeded on test vector %s; expected_error=%d, cfg=\\\"%s\\\"\\n\",\n\t\t\t       driver, vec_name, vec->digest_error, cfg->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tgoto result_ready;\n\t}\n\n\t \n\n\tahash_request_set_callback(req, req_flags, crypto_req_done, &wait);\n\tahash_request_set_crypt(req, NULL, result, 0);\n\terr = do_ahash_op(crypto_ahash_init, req, &wait, cfg->nosimd);\n\terr = check_nonfinal_ahash_op(\"init\", err, result, digestsize,\n\t\t\t\t      driver, vec_name, cfg);\n\tif (err)\n\t\treturn err;\n\n\tpending_sgl = NULL;\n\tpending_len = 0;\n\tfor (i = 0; i < tsgl->nents; i++) {\n\t\tif (divs[i]->flush_type != FLUSH_TYPE_NONE &&\n\t\t    pending_sgl != NULL) {\n\t\t\t \n\t\t\tahash_request_set_callback(req, req_flags,\n\t\t\t\t\t\t   crypto_req_done, &wait);\n\t\t\tahash_request_set_crypt(req, pending_sgl, result,\n\t\t\t\t\t\tpending_len);\n\t\t\terr = do_ahash_op(crypto_ahash_update, req, &wait,\n\t\t\t\t\t  divs[i]->nosimd);\n\t\t\terr = check_nonfinal_ahash_op(\"update\", err,\n\t\t\t\t\t\t      result, digestsize,\n\t\t\t\t\t\t      driver, vec_name, cfg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tpending_sgl = NULL;\n\t\t\tpending_len = 0;\n\t\t}\n\t\tif (divs[i]->flush_type == FLUSH_TYPE_REIMPORT) {\n\t\t\t \n\t\t\ttestmgr_poison(hashstate + statesize,\n\t\t\t\t       TESTMGR_POISON_LEN);\n\t\t\terr = crypto_ahash_export(req, hashstate);\n\t\t\terr = check_nonfinal_ahash_op(\"export\", err,\n\t\t\t\t\t\t      result, digestsize,\n\t\t\t\t\t\t      driver, vec_name, cfg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (!testmgr_is_poison(hashstate + statesize,\n\t\t\t\t\t       TESTMGR_POISON_LEN)) {\n\t\t\t\tpr_err(\"alg: ahash: %s export() overran state buffer on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t\t\t       driver, vec_name, cfg->name);\n\t\t\t\treturn -EOVERFLOW;\n\t\t\t}\n\n\t\t\ttestmgr_poison(req->__ctx, crypto_ahash_reqsize(tfm));\n\t\t\terr = crypto_ahash_import(req, hashstate);\n\t\t\terr = check_nonfinal_ahash_op(\"import\", err,\n\t\t\t\t\t\t      result, digestsize,\n\t\t\t\t\t\t      driver, vec_name, cfg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (pending_sgl == NULL)\n\t\t\tpending_sgl = &tsgl->sgl[i];\n\t\tpending_len += tsgl->sgl[i].length;\n\t}\n\n\tahash_request_set_callback(req, req_flags, crypto_req_done, &wait);\n\tahash_request_set_crypt(req, pending_sgl, result, pending_len);\n\tif (cfg->finalization_type == FINALIZATION_TYPE_FINAL) {\n\t\t \n\t\terr = do_ahash_op(crypto_ahash_update, req, &wait, cfg->nosimd);\n\t\terr = check_nonfinal_ahash_op(\"update\", err, result, digestsize,\n\t\t\t\t\t      driver, vec_name, cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = do_ahash_op(crypto_ahash_final, req, &wait, cfg->nosimd);\n\t\tif (err) {\n\t\t\tpr_err(\"alg: ahash: %s final() failed with err %d on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t\t       driver, err, vec_name, cfg->name);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\t \n\t\terr = do_ahash_op(crypto_ahash_finup, req, &wait, cfg->nosimd);\n\t\tif (err) {\n\t\t\tpr_err(\"alg: ahash: %s finup() failed with err %d on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t\t       driver, err, vec_name, cfg->name);\n\t\t\treturn err;\n\t\t}\n\t}\n\nresult_ready:\n\treturn check_hash_result(\"ahash\", result, digestsize, vec, vec_name,\n\t\t\t\t driver, cfg);\n}\n\nstatic int test_hash_vec_cfg(const struct hash_testvec *vec,\n\t\t\t     const char *vec_name,\n\t\t\t     const struct testvec_config *cfg,\n\t\t\t     struct ahash_request *req,\n\t\t\t     struct shash_desc *desc,\n\t\t\t     struct test_sglist *tsgl,\n\t\t\t     u8 *hashstate)\n{\n\tint err;\n\n\t \n\n\tif (desc) {\n\t\terr = test_shash_vec_cfg(vec, vec_name, cfg, desc, tsgl,\n\t\t\t\t\t hashstate);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn test_ahash_vec_cfg(vec, vec_name, cfg, req, tsgl, hashstate);\n}\n\nstatic int test_hash_vec(const struct hash_testvec *vec, unsigned int vec_num,\n\t\t\t struct ahash_request *req, struct shash_desc *desc,\n\t\t\t struct test_sglist *tsgl, u8 *hashstate)\n{\n\tchar vec_name[16];\n\tunsigned int i;\n\tint err;\n\n\tsprintf(vec_name, \"%u\", vec_num);\n\n\tfor (i = 0; i < ARRAY_SIZE(default_hash_testvec_configs); i++) {\n\t\terr = test_hash_vec_cfg(vec, vec_name,\n\t\t\t\t\t&default_hash_testvec_configs[i],\n\t\t\t\t\treq, desc, tsgl, hashstate);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\n\tif (!noextratests) {\n\t\tstruct rnd_state rng;\n\t\tstruct testvec_config cfg;\n\t\tchar cfgname[TESTVEC_CONFIG_NAMELEN];\n\n\t\tinit_rnd_state(&rng);\n\n\t\tfor (i = 0; i < fuzz_iterations; i++) {\n\t\t\tgenerate_random_testvec_config(&rng, &cfg, cfgname,\n\t\t\t\t\t\t       sizeof(cfgname));\n\t\t\terr = test_hash_vec_cfg(vec, vec_name, &cfg,\n\t\t\t\t\t\treq, desc, tsgl, hashstate);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tcond_resched();\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\n \nstatic void generate_random_hash_testvec(struct rnd_state *rng,\n\t\t\t\t\t struct shash_desc *desc,\n\t\t\t\t\t struct hash_testvec *vec,\n\t\t\t\t\t unsigned int maxkeysize,\n\t\t\t\t\t unsigned int maxdatasize,\n\t\t\t\t\t char *name, size_t max_namelen)\n{\n\t \n\tvec->psize = generate_random_length(rng, maxdatasize);\n\tgenerate_random_bytes(rng, (u8 *)vec->plaintext, vec->psize);\n\n\t \n\tvec->setkey_error = 0;\n\tvec->ksize = 0;\n\tif (maxkeysize) {\n\t\tvec->ksize = maxkeysize;\n\t\tif (prandom_u32_below(rng, 4) == 0)\n\t\t\tvec->ksize = prandom_u32_inclusive(rng, 1, maxkeysize);\n\t\tgenerate_random_bytes(rng, (u8 *)vec->key, vec->ksize);\n\n\t\tvec->setkey_error = crypto_shash_setkey(desc->tfm, vec->key,\n\t\t\t\t\t\t\tvec->ksize);\n\t\t \n\t\tif (vec->setkey_error)\n\t\t\tgoto done;\n\t}\n\n\t \n\tvec->digest_error = crypto_shash_digest(desc, vec->plaintext,\n\t\t\t\t\t\tvec->psize, (u8 *)vec->digest);\ndone:\n\tsnprintf(name, max_namelen, \"\\\"random: psize=%u ksize=%u\\\"\",\n\t\t vec->psize, vec->ksize);\n}\n\n \nstatic int test_hash_vs_generic_impl(const char *generic_driver,\n\t\t\t\t     unsigned int maxkeysize,\n\t\t\t\t     struct ahash_request *req,\n\t\t\t\t     struct shash_desc *desc,\n\t\t\t\t     struct test_sglist *tsgl,\n\t\t\t\t     u8 *hashstate)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tconst unsigned int digestsize = crypto_ahash_digestsize(tfm);\n\tconst unsigned int blocksize = crypto_ahash_blocksize(tfm);\n\tconst unsigned int maxdatasize = (2 * PAGE_SIZE) - TESTMGR_POISON_LEN;\n\tconst char *algname = crypto_hash_alg_common(tfm)->base.cra_name;\n\tconst char *driver = crypto_ahash_driver_name(tfm);\n\tstruct rnd_state rng;\n\tchar _generic_driver[CRYPTO_MAX_ALG_NAME];\n\tstruct crypto_shash *generic_tfm = NULL;\n\tstruct shash_desc *generic_desc = NULL;\n\tunsigned int i;\n\tstruct hash_testvec vec = { 0 };\n\tchar vec_name[64];\n\tstruct testvec_config *cfg;\n\tchar cfgname[TESTVEC_CONFIG_NAMELEN];\n\tint err;\n\n\tif (noextratests)\n\t\treturn 0;\n\n\tinit_rnd_state(&rng);\n\n\tif (!generic_driver) {  \n\t\terr = build_generic_driver_name(algname, _generic_driver);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgeneric_driver = _generic_driver;\n\t}\n\n\tif (strcmp(generic_driver, driver) == 0)  \n\t\treturn 0;\n\n\tgeneric_tfm = crypto_alloc_shash(generic_driver, 0, 0);\n\tif (IS_ERR(generic_tfm)) {\n\t\terr = PTR_ERR(generic_tfm);\n\t\tif (err == -ENOENT) {\n\t\t\tpr_warn(\"alg: hash: skipping comparison tests for %s because %s is unavailable\\n\",\n\t\t\t\tdriver, generic_driver);\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"alg: hash: error allocating %s (generic impl of %s): %d\\n\",\n\t\t       generic_driver, algname, err);\n\t\treturn err;\n\t}\n\n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tgeneric_desc = kzalloc(sizeof(*desc) +\n\t\t\t       crypto_shash_descsize(generic_tfm), GFP_KERNEL);\n\tif (!generic_desc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgeneric_desc->tfm = generic_tfm;\n\n\t \n\n\tif (digestsize != crypto_shash_digestsize(generic_tfm)) {\n\t\tpr_err(\"alg: hash: digestsize for %s (%u) doesn't match generic impl (%u)\\n\",\n\t\t       driver, digestsize,\n\t\t       crypto_shash_digestsize(generic_tfm));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (blocksize != crypto_shash_blocksize(generic_tfm)) {\n\t\tpr_err(\"alg: hash: blocksize for %s (%u) doesn't match generic impl (%u)\\n\",\n\t\t       driver, blocksize, crypto_shash_blocksize(generic_tfm));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\n\tvec.key = kmalloc(maxkeysize, GFP_KERNEL);\n\tvec.plaintext = kmalloc(maxdatasize, GFP_KERNEL);\n\tvec.digest = kmalloc(digestsize, GFP_KERNEL);\n\tif (!vec.key || !vec.plaintext || !vec.digest) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < fuzz_iterations * 8; i++) {\n\t\tgenerate_random_hash_testvec(&rng, generic_desc, &vec,\n\t\t\t\t\t     maxkeysize, maxdatasize,\n\t\t\t\t\t     vec_name, sizeof(vec_name));\n\t\tgenerate_random_testvec_config(&rng, cfg, cfgname,\n\t\t\t\t\t       sizeof(cfgname));\n\n\t\terr = test_hash_vec_cfg(&vec, vec_name, cfg,\n\t\t\t\t\treq, desc, tsgl, hashstate);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tcond_resched();\n\t}\n\terr = 0;\nout:\n\tkfree(cfg);\n\tkfree(vec.key);\n\tkfree(vec.plaintext);\n\tkfree(vec.digest);\n\tcrypto_free_shash(generic_tfm);\n\tkfree_sensitive(generic_desc);\n\treturn err;\n}\n#else  \nstatic int test_hash_vs_generic_impl(const char *generic_driver,\n\t\t\t\t     unsigned int maxkeysize,\n\t\t\t\t     struct ahash_request *req,\n\t\t\t\t     struct shash_desc *desc,\n\t\t\t\t     struct test_sglist *tsgl,\n\t\t\t\t     u8 *hashstate)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int alloc_shash(const char *driver, u32 type, u32 mask,\n\t\t       struct crypto_shash **tfm_ret,\n\t\t       struct shash_desc **desc_ret)\n{\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *desc;\n\n\ttfm = crypto_alloc_shash(driver, type, mask);\n\tif (IS_ERR(tfm)) {\n\t\tif (PTR_ERR(tfm) == -ENOENT) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"alg: hash: failed to allocate shash transform for %s: %ld\\n\",\n\t\t       driver, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tcrypto_free_shash(tfm);\n\t\treturn -ENOMEM;\n\t}\n\tdesc->tfm = tfm;\n\n\t*tfm_ret = tfm;\n\t*desc_ret = desc;\n\treturn 0;\n}\n\nstatic int __alg_test_hash(const struct hash_testvec *vecs,\n\t\t\t   unsigned int num_vecs, const char *driver,\n\t\t\t   u32 type, u32 mask,\n\t\t\t   const char *generic_driver, unsigned int maxkeysize)\n{\n\tstruct crypto_ahash *atfm = NULL;\n\tstruct ahash_request *req = NULL;\n\tstruct crypto_shash *stfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tstruct test_sglist *tsgl = NULL;\n\tu8 *hashstate = NULL;\n\tunsigned int statesize;\n\tunsigned int i;\n\tint err;\n\n\t \n\n\tatfm = crypto_alloc_ahash(driver, type, mask);\n\tif (IS_ERR(atfm)) {\n\t\tpr_err(\"alg: hash: failed to allocate transform for %s: %ld\\n\",\n\t\t       driver, PTR_ERR(atfm));\n\t\treturn PTR_ERR(atfm);\n\t}\n\tdriver = crypto_ahash_driver_name(atfm);\n\n\treq = ahash_request_alloc(atfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"alg: hash: failed to allocate request for %s\\n\",\n\t\t       driver);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\terr = alloc_shash(driver, type, mask, &stfm, &desc);\n\tif (err)\n\t\tgoto out;\n\n\ttsgl = kmalloc(sizeof(*tsgl), GFP_KERNEL);\n\tif (!tsgl || init_test_sglist(tsgl) != 0) {\n\t\tpr_err(\"alg: hash: failed to allocate test buffers for %s\\n\",\n\t\t       driver);\n\t\tkfree(tsgl);\n\t\ttsgl = NULL;\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tstatesize = crypto_ahash_statesize(atfm);\n\tif (stfm)\n\t\tstatesize = max(statesize, crypto_shash_statesize(stfm));\n\thashstate = kmalloc(statesize + TESTMGR_POISON_LEN, GFP_KERNEL);\n\tif (!hashstate) {\n\t\tpr_err(\"alg: hash: failed to allocate hash state buffer for %s\\n\",\n\t\t       driver);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_vecs; i++) {\n\t\tif (fips_enabled && vecs[i].fips_skip)\n\t\t\tcontinue;\n\n\t\terr = test_hash_vec(&vecs[i], i, req, desc, tsgl, hashstate);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tcond_resched();\n\t}\n\terr = test_hash_vs_generic_impl(generic_driver, maxkeysize, req,\n\t\t\t\t\tdesc, tsgl, hashstate);\nout:\n\tkfree(hashstate);\n\tif (tsgl) {\n\t\tdestroy_test_sglist(tsgl);\n\t\tkfree(tsgl);\n\t}\n\tkfree(desc);\n\tcrypto_free_shash(stfm);\n\tahash_request_free(req);\n\tcrypto_free_ahash(atfm);\n\treturn err;\n}\n\nstatic int alg_test_hash(const struct alg_test_desc *desc, const char *driver,\n\t\t\t u32 type, u32 mask)\n{\n\tconst struct hash_testvec *template = desc->suite.hash.vecs;\n\tunsigned int tcount = desc->suite.hash.count;\n\tunsigned int nr_unkeyed, nr_keyed;\n\tunsigned int maxkeysize = 0;\n\tint err;\n\n\t \n\n\tfor (nr_unkeyed = 0; nr_unkeyed < tcount; nr_unkeyed++) {\n\t\tif (template[nr_unkeyed].ksize)\n\t\t\tbreak;\n\t}\n\tfor (nr_keyed = 0; nr_unkeyed + nr_keyed < tcount; nr_keyed++) {\n\t\tif (!template[nr_unkeyed + nr_keyed].ksize) {\n\t\t\tpr_err(\"alg: hash: test vectors for %s out of order, \"\n\t\t\t       \"unkeyed ones must come first\\n\", desc->alg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmaxkeysize = max_t(unsigned int, maxkeysize,\n\t\t\t\t   template[nr_unkeyed + nr_keyed].ksize);\n\t}\n\n\terr = 0;\n\tif (nr_unkeyed) {\n\t\terr = __alg_test_hash(template, nr_unkeyed, driver, type, mask,\n\t\t\t\t      desc->generic_driver, maxkeysize);\n\t\ttemplate += nr_unkeyed;\n\t}\n\n\tif (!err && nr_keyed)\n\t\terr = __alg_test_hash(template, nr_keyed, driver, type, mask,\n\t\t\t\t      desc->generic_driver, maxkeysize);\n\n\treturn err;\n}\n\nstatic int test_aead_vec_cfg(int enc, const struct aead_testvec *vec,\n\t\t\t     const char *vec_name,\n\t\t\t     const struct testvec_config *cfg,\n\t\t\t     struct aead_request *req,\n\t\t\t     struct cipher_test_sglists *tsgls)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tconst unsigned int alignmask = crypto_aead_alignmask(tfm);\n\tconst unsigned int ivsize = crypto_aead_ivsize(tfm);\n\tconst unsigned int authsize = vec->clen - vec->plen;\n\tconst char *driver = crypto_aead_driver_name(tfm);\n\tconst u32 req_flags = CRYPTO_TFM_REQ_MAY_BACKLOG | cfg->req_flags;\n\tconst char *op = enc ? \"encryption\" : \"decryption\";\n\tDECLARE_CRYPTO_WAIT(wait);\n\tu8 _iv[3 * (MAX_ALGAPI_ALIGNMASK + 1) + MAX_IVLEN];\n\tu8 *iv = PTR_ALIGN(&_iv[0], 2 * (MAX_ALGAPI_ALIGNMASK + 1)) +\n\t\t cfg->iv_offset +\n\t\t (cfg->iv_offset_relative_to_alignmask ? alignmask : 0);\n\tstruct kvec input[2];\n\tint err;\n\n\t \n\tif (vec->wk)\n\t\tcrypto_aead_set_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);\n\telse\n\t\tcrypto_aead_clear_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);\n\n\terr = do_setkey(crypto_aead_setkey, tfm, vec->key, vec->klen,\n\t\t\tcfg, alignmask);\n\tif (err && err != vec->setkey_error) {\n\t\tpr_err(\"alg: aead: %s setkey failed on test vector %s; expected_error=%d, actual_error=%d, flags=%#x\\n\",\n\t\t       driver, vec_name, vec->setkey_error, err,\n\t\t       crypto_aead_get_flags(tfm));\n\t\treturn err;\n\t}\n\tif (!err && vec->setkey_error) {\n\t\tpr_err(\"alg: aead: %s setkey unexpectedly succeeded on test vector %s; expected_error=%d\\n\",\n\t\t       driver, vec_name, vec->setkey_error);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = crypto_aead_setauthsize(tfm, authsize);\n\tif (err && err != vec->setauthsize_error) {\n\t\tpr_err(\"alg: aead: %s setauthsize failed on test vector %s; expected_error=%d, actual_error=%d\\n\",\n\t\t       driver, vec_name, vec->setauthsize_error, err);\n\t\treturn err;\n\t}\n\tif (!err && vec->setauthsize_error) {\n\t\tpr_err(\"alg: aead: %s setauthsize unexpectedly succeeded on test vector %s; expected_error=%d\\n\",\n\t\t       driver, vec_name, vec->setauthsize_error);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vec->setkey_error || vec->setauthsize_error)\n\t\treturn 0;\n\n\t \n\tif (WARN_ON(ivsize > MAX_IVLEN))\n\t\treturn -EINVAL;\n\tif (vec->iv)\n\t\tmemcpy(iv, vec->iv, ivsize);\n\telse\n\t\tmemset(iv, 0, ivsize);\n\n\t \n\tinput[0].iov_base = (void *)vec->assoc;\n\tinput[0].iov_len = vec->alen;\n\tinput[1].iov_base = enc ? (void *)vec->ptext : (void *)vec->ctext;\n\tinput[1].iov_len = enc ? vec->plen : vec->clen;\n\terr = build_cipher_test_sglists(tsgls, cfg, alignmask,\n\t\t\t\t\tvec->alen + (enc ? vec->plen :\n\t\t\t\t\t\t     vec->clen),\n\t\t\t\t\tvec->alen + (enc ? vec->clen :\n\t\t\t\t\t\t     vec->plen),\n\t\t\t\t\tinput, 2);\n\tif (err) {\n\t\tpr_err(\"alg: aead: %s %s: error preparing scatterlists for test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\treturn err;\n\t}\n\n\t \n\ttestmgr_poison(req->__ctx, crypto_aead_reqsize(tfm));\n\taead_request_set_callback(req, req_flags, crypto_req_done, &wait);\n\taead_request_set_crypt(req, tsgls->src.sgl_ptr, tsgls->dst.sgl_ptr,\n\t\t\t       enc ? vec->plen : vec->clen, iv);\n\taead_request_set_ad(req, vec->alen);\n\tif (cfg->nosimd)\n\t\tcrypto_disable_simd_for_test();\n\terr = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);\n\tif (cfg->nosimd)\n\t\tcrypto_reenable_simd_for_test();\n\terr = crypto_wait_req(err, &wait);\n\n\t \n\tif (req->cryptlen != (enc ? vec->plen : vec->clen) ||\n\t    req->assoclen != vec->alen ||\n\t    req->iv != iv ||\n\t    req->src != tsgls->src.sgl_ptr ||\n\t    req->dst != tsgls->dst.sgl_ptr ||\n\t    crypto_aead_reqtfm(req) != tfm ||\n\t    req->base.complete != crypto_req_done ||\n\t    req->base.flags != req_flags ||\n\t    req->base.data != &wait) {\n\t\tpr_err(\"alg: aead: %s %s corrupted request struct on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\tif (req->cryptlen != (enc ? vec->plen : vec->clen))\n\t\t\tpr_err(\"alg: aead: changed 'req->cryptlen'\\n\");\n\t\tif (req->assoclen != vec->alen)\n\t\t\tpr_err(\"alg: aead: changed 'req->assoclen'\\n\");\n\t\tif (req->iv != iv)\n\t\t\tpr_err(\"alg: aead: changed 'req->iv'\\n\");\n\t\tif (req->src != tsgls->src.sgl_ptr)\n\t\t\tpr_err(\"alg: aead: changed 'req->src'\\n\");\n\t\tif (req->dst != tsgls->dst.sgl_ptr)\n\t\t\tpr_err(\"alg: aead: changed 'req->dst'\\n\");\n\t\tif (crypto_aead_reqtfm(req) != tfm)\n\t\t\tpr_err(\"alg: aead: changed 'req->base.tfm'\\n\");\n\t\tif (req->base.complete != crypto_req_done)\n\t\t\tpr_err(\"alg: aead: changed 'req->base.complete'\\n\");\n\t\tif (req->base.flags != req_flags)\n\t\t\tpr_err(\"alg: aead: changed 'req->base.flags'\\n\");\n\t\tif (req->base.data != &wait)\n\t\t\tpr_err(\"alg: aead: changed 'req->base.data'\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (is_test_sglist_corrupted(&tsgls->src)) {\n\t\tpr_err(\"alg: aead: %s %s corrupted src sgl on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\treturn -EINVAL;\n\t}\n\tif (tsgls->dst.sgl_ptr != tsgls->src.sgl &&\n\t    is_test_sglist_corrupted(&tsgls->dst)) {\n\t\tpr_err(\"alg: aead: %s %s corrupted dst sgl on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((err == 0 && vec->novrfy) ||\n\t    (err != vec->crypt_error && !(err == -EBADMSG && vec->novrfy))) {\n\t\tchar expected_error[32];\n\n\t\tif (vec->novrfy &&\n\t\t    vec->crypt_error != 0 && vec->crypt_error != -EBADMSG)\n\t\t\tsprintf(expected_error, \"-EBADMSG or %d\",\n\t\t\t\tvec->crypt_error);\n\t\telse if (vec->novrfy)\n\t\t\tsprintf(expected_error, \"-EBADMSG\");\n\t\telse\n\t\t\tsprintf(expected_error, \"%d\", vec->crypt_error);\n\t\tif (err) {\n\t\t\tpr_err(\"alg: aead: %s %s failed on test vector %s; expected_error=%s, actual_error=%d, cfg=\\\"%s\\\"\\n\",\n\t\t\t       driver, op, vec_name, expected_error, err,\n\t\t\t       cfg->name);\n\t\t\treturn err;\n\t\t}\n\t\tpr_err(\"alg: aead: %s %s unexpectedly succeeded on test vector %s; expected_error=%s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, expected_error, cfg->name);\n\t\treturn -EINVAL;\n\t}\n\tif (err)  \n\t\treturn 0;\n\n\t \n\terr = verify_correct_output(&tsgls->dst, enc ? vec->ctext : vec->ptext,\n\t\t\t\t    enc ? vec->clen : vec->plen,\n\t\t\t\t    vec->alen,\n\t\t\t\t    enc || cfg->inplace_mode == OUT_OF_PLACE);\n\tif (err == -EOVERFLOW) {\n\t\tpr_err(\"alg: aead: %s %s overran dst buffer on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\treturn err;\n\t}\n\tif (err) {\n\t\tpr_err(\"alg: aead: %s %s test failed (wrong result) on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int test_aead_vec(int enc, const struct aead_testvec *vec,\n\t\t\t unsigned int vec_num, struct aead_request *req,\n\t\t\t struct cipher_test_sglists *tsgls)\n{\n\tchar vec_name[16];\n\tunsigned int i;\n\tint err;\n\n\tif (enc && vec->novrfy)\n\t\treturn 0;\n\n\tsprintf(vec_name, \"%u\", vec_num);\n\n\tfor (i = 0; i < ARRAY_SIZE(default_cipher_testvec_configs); i++) {\n\t\terr = test_aead_vec_cfg(enc, vec, vec_name,\n\t\t\t\t\t&default_cipher_testvec_configs[i],\n\t\t\t\t\treq, tsgls);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\n\tif (!noextratests) {\n\t\tstruct rnd_state rng;\n\t\tstruct testvec_config cfg;\n\t\tchar cfgname[TESTVEC_CONFIG_NAMELEN];\n\n\t\tinit_rnd_state(&rng);\n\n\t\tfor (i = 0; i < fuzz_iterations; i++) {\n\t\t\tgenerate_random_testvec_config(&rng, &cfg, cfgname,\n\t\t\t\t\t\t       sizeof(cfgname));\n\t\t\terr = test_aead_vec_cfg(enc, vec, vec_name,\n\t\t\t\t\t\t&cfg, req, tsgls);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tcond_resched();\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\n\nstruct aead_extra_tests_ctx {\n\tstruct rnd_state rng;\n\tstruct aead_request *req;\n\tstruct crypto_aead *tfm;\n\tconst struct alg_test_desc *test_desc;\n\tstruct cipher_test_sglists *tsgls;\n\tunsigned int maxdatasize;\n\tunsigned int maxkeysize;\n\n\tstruct aead_testvec vec;\n\tchar vec_name[64];\n\tchar cfgname[TESTVEC_CONFIG_NAMELEN];\n\tstruct testvec_config cfg;\n};\n\n \nstatic void mutate_aead_message(struct rnd_state *rng,\n\t\t\t\tstruct aead_testvec *vec, bool aad_iv,\n\t\t\t\tunsigned int ivsize)\n{\n\tconst unsigned int aad_tail_size = aad_iv ? ivsize : 0;\n\tconst unsigned int authsize = vec->clen - vec->plen;\n\n\tif (prandom_bool(rng) && vec->alen > aad_tail_size) {\n\t\t  \n\t\tflip_random_bit(rng, (u8 *)vec->assoc,\n\t\t\t\tvec->alen - aad_tail_size);\n\t\tif (prandom_bool(rng))\n\t\t\treturn;\n\t}\n\tif (prandom_bool(rng)) {\n\t\t \n\t\tflip_random_bit(rng, (u8 *)vec->ctext + vec->plen, authsize);\n\t} else {\n\t\t \n\t\tflip_random_bit(rng, (u8 *)vec->ctext, vec->clen);\n\t}\n}\n\n \n#define MIN_COLLISION_FREE_AUTHSIZE 8\n\nstatic void generate_aead_message(struct rnd_state *rng,\n\t\t\t\t  struct aead_request *req,\n\t\t\t\t  const struct aead_test_suite *suite,\n\t\t\t\t  struct aead_testvec *vec,\n\t\t\t\t  bool prefer_inauthentic)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tconst unsigned int ivsize = crypto_aead_ivsize(tfm);\n\tconst unsigned int authsize = vec->clen - vec->plen;\n\tconst bool inauthentic = (authsize >= MIN_COLLISION_FREE_AUTHSIZE) &&\n\t\t\t\t (prefer_inauthentic ||\n\t\t\t\t  prandom_u32_below(rng, 4) == 0);\n\n\t \n\tgenerate_random_bytes(rng, (u8 *)vec->assoc, vec->alen);\n\tif (suite->aad_iv && vec->alen >= ivsize)\n\t\t \n\t\tmemcpy((u8 *)vec->assoc + vec->alen - ivsize, vec->iv, ivsize);\n\n\tif (inauthentic && prandom_bool(rng)) {\n\t\t \n\t\tgenerate_random_bytes(rng, (u8 *)vec->ctext, vec->clen);\n\t} else {\n\t\tint i = 0;\n\t\tstruct scatterlist src[2], dst;\n\t\tu8 iv[MAX_IVLEN];\n\t\tDECLARE_CRYPTO_WAIT(wait);\n\n\t\t \n\t\tsg_init_table(src, 2);\n\t\tif (vec->alen)\n\t\t\tsg_set_buf(&src[i++], vec->assoc, vec->alen);\n\t\tif (vec->plen) {\n\t\t\tgenerate_random_bytes(rng, (u8 *)vec->ptext, vec->plen);\n\t\t\tsg_set_buf(&src[i++], vec->ptext, vec->plen);\n\t\t}\n\t\tsg_init_one(&dst, vec->ctext, vec->alen + vec->clen);\n\t\tmemcpy(iv, vec->iv, ivsize);\n\t\taead_request_set_callback(req, 0, crypto_req_done, &wait);\n\t\taead_request_set_crypt(req, src, &dst, vec->plen, iv);\n\t\taead_request_set_ad(req, vec->alen);\n\t\tvec->crypt_error = crypto_wait_req(crypto_aead_encrypt(req),\n\t\t\t\t\t\t   &wait);\n\t\t \n\t\tif (vec->crypt_error != 0)\n\t\t\treturn;\n\t\tmemmove((u8 *)vec->ctext, vec->ctext + vec->alen, vec->clen);\n\t\tif (!inauthentic)\n\t\t\treturn;\n\t\t \n\t\tmutate_aead_message(rng, vec, suite->aad_iv, ivsize);\n\t}\n\tvec->novrfy = 1;\n\tif (suite->einval_allowed)\n\t\tvec->crypt_error = -EINVAL;\n}\n\n \nstatic void generate_random_aead_testvec(struct rnd_state *rng,\n\t\t\t\t\t struct aead_request *req,\n\t\t\t\t\t struct aead_testvec *vec,\n\t\t\t\t\t const struct aead_test_suite *suite,\n\t\t\t\t\t unsigned int maxkeysize,\n\t\t\t\t\t unsigned int maxdatasize,\n\t\t\t\t\t char *name, size_t max_namelen,\n\t\t\t\t\t bool prefer_inauthentic)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tconst unsigned int ivsize = crypto_aead_ivsize(tfm);\n\tconst unsigned int maxauthsize = crypto_aead_maxauthsize(tfm);\n\tunsigned int authsize;\n\tunsigned int total_len;\n\n\t \n\tvec->klen = maxkeysize;\n\tif (prandom_u32_below(rng, 4) == 0)\n\t\tvec->klen = prandom_u32_below(rng, maxkeysize + 1);\n\tgenerate_random_bytes(rng, (u8 *)vec->key, vec->klen);\n\tvec->setkey_error = crypto_aead_setkey(tfm, vec->key, vec->klen);\n\n\t \n\tgenerate_random_bytes(rng, (u8 *)vec->iv, ivsize);\n\n\t \n\tauthsize = maxauthsize;\n\tif (prandom_u32_below(rng, 4) == 0)\n\t\tauthsize = prandom_u32_below(rng, maxauthsize + 1);\n\tif (prefer_inauthentic && authsize < MIN_COLLISION_FREE_AUTHSIZE)\n\t\tauthsize = MIN_COLLISION_FREE_AUTHSIZE;\n\tif (WARN_ON(authsize > maxdatasize))\n\t\tauthsize = maxdatasize;\n\tmaxdatasize -= authsize;\n\tvec->setauthsize_error = crypto_aead_setauthsize(tfm, authsize);\n\n\t \n\ttotal_len = generate_random_length(rng, maxdatasize);\n\tif (prandom_u32_below(rng, 4) == 0)\n\t\tvec->alen = 0;\n\telse\n\t\tvec->alen = generate_random_length(rng, total_len);\n\tvec->plen = total_len - vec->alen;\n\tvec->clen = vec->plen + authsize;\n\n\t \n\tvec->novrfy = 0;\n\tvec->crypt_error = 0;\n\tif (vec->setkey_error == 0 && vec->setauthsize_error == 0)\n\t\tgenerate_aead_message(rng, req, suite, vec, prefer_inauthentic);\n\tsnprintf(name, max_namelen,\n\t\t \"\\\"random: alen=%u plen=%u authsize=%u klen=%u novrfy=%d\\\"\",\n\t\t vec->alen, vec->plen, authsize, vec->klen, vec->novrfy);\n}\n\nstatic void try_to_generate_inauthentic_testvec(\n\t\t\t\t\tstruct aead_extra_tests_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tgenerate_random_aead_testvec(&ctx->rng, ctx->req, &ctx->vec,\n\t\t\t\t\t     &ctx->test_desc->suite.aead,\n\t\t\t\t\t     ctx->maxkeysize, ctx->maxdatasize,\n\t\t\t\t\t     ctx->vec_name,\n\t\t\t\t\t     sizeof(ctx->vec_name), true);\n\t\tif (ctx->vec.novrfy)\n\t\t\treturn;\n\t}\n}\n\n \nstatic int test_aead_inauthentic_inputs(struct aead_extra_tests_ctx *ctx)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < fuzz_iterations * 8; i++) {\n\t\t \n\t\ttry_to_generate_inauthentic_testvec(ctx);\n\t\tif (ctx->vec.novrfy) {\n\t\t\tgenerate_random_testvec_config(&ctx->rng, &ctx->cfg,\n\t\t\t\t\t\t       ctx->cfgname,\n\t\t\t\t\t\t       sizeof(ctx->cfgname));\n\t\t\terr = test_aead_vec_cfg(DECRYPT, &ctx->vec,\n\t\t\t\t\t\tctx->vec_name, &ctx->cfg,\n\t\t\t\t\t\tctx->req, ctx->tsgls);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tcond_resched();\n\t}\n\treturn 0;\n}\n\n \nstatic int test_aead_vs_generic_impl(struct aead_extra_tests_ctx *ctx)\n{\n\tstruct crypto_aead *tfm = ctx->tfm;\n\tconst char *algname = crypto_aead_alg(tfm)->base.cra_name;\n\tconst char *driver = crypto_aead_driver_name(tfm);\n\tconst char *generic_driver = ctx->test_desc->generic_driver;\n\tchar _generic_driver[CRYPTO_MAX_ALG_NAME];\n\tstruct crypto_aead *generic_tfm = NULL;\n\tstruct aead_request *generic_req = NULL;\n\tunsigned int i;\n\tint err;\n\n\tif (!generic_driver) {  \n\t\terr = build_generic_driver_name(algname, _generic_driver);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgeneric_driver = _generic_driver;\n\t}\n\n\tif (strcmp(generic_driver, driver) == 0)  \n\t\treturn 0;\n\n\tgeneric_tfm = crypto_alloc_aead(generic_driver, 0, 0);\n\tif (IS_ERR(generic_tfm)) {\n\t\terr = PTR_ERR(generic_tfm);\n\t\tif (err == -ENOENT) {\n\t\t\tpr_warn(\"alg: aead: skipping comparison tests for %s because %s is unavailable\\n\",\n\t\t\t\tdriver, generic_driver);\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"alg: aead: error allocating %s (generic impl of %s): %d\\n\",\n\t\t       generic_driver, algname, err);\n\t\treturn err;\n\t}\n\n\tgeneric_req = aead_request_alloc(generic_tfm, GFP_KERNEL);\n\tif (!generic_req) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (crypto_aead_maxauthsize(tfm) !=\n\t    crypto_aead_maxauthsize(generic_tfm)) {\n\t\tpr_err(\"alg: aead: maxauthsize for %s (%u) doesn't match generic impl (%u)\\n\",\n\t\t       driver, crypto_aead_maxauthsize(tfm),\n\t\t       crypto_aead_maxauthsize(generic_tfm));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (crypto_aead_ivsize(tfm) != crypto_aead_ivsize(generic_tfm)) {\n\t\tpr_err(\"alg: aead: ivsize for %s (%u) doesn't match generic impl (%u)\\n\",\n\t\t       driver, crypto_aead_ivsize(tfm),\n\t\t       crypto_aead_ivsize(generic_tfm));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (crypto_aead_blocksize(tfm) != crypto_aead_blocksize(generic_tfm)) {\n\t\tpr_err(\"alg: aead: blocksize for %s (%u) doesn't match generic impl (%u)\\n\",\n\t\t       driver, crypto_aead_blocksize(tfm),\n\t\t       crypto_aead_blocksize(generic_tfm));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < fuzz_iterations * 8; i++) {\n\t\tgenerate_random_aead_testvec(&ctx->rng, generic_req, &ctx->vec,\n\t\t\t\t\t     &ctx->test_desc->suite.aead,\n\t\t\t\t\t     ctx->maxkeysize, ctx->maxdatasize,\n\t\t\t\t\t     ctx->vec_name,\n\t\t\t\t\t     sizeof(ctx->vec_name), false);\n\t\tgenerate_random_testvec_config(&ctx->rng, &ctx->cfg,\n\t\t\t\t\t       ctx->cfgname,\n\t\t\t\t\t       sizeof(ctx->cfgname));\n\t\tif (!ctx->vec.novrfy) {\n\t\t\terr = test_aead_vec_cfg(ENCRYPT, &ctx->vec,\n\t\t\t\t\t\tctx->vec_name, &ctx->cfg,\n\t\t\t\t\t\tctx->req, ctx->tsgls);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (ctx->vec.crypt_error == 0 || ctx->vec.novrfy) {\n\t\t\terr = test_aead_vec_cfg(DECRYPT, &ctx->vec,\n\t\t\t\t\t\tctx->vec_name, &ctx->cfg,\n\t\t\t\t\t\tctx->req, ctx->tsgls);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tcond_resched();\n\t}\n\terr = 0;\nout:\n\tcrypto_free_aead(generic_tfm);\n\taead_request_free(generic_req);\n\treturn err;\n}\n\nstatic int test_aead_extra(const struct alg_test_desc *test_desc,\n\t\t\t   struct aead_request *req,\n\t\t\t   struct cipher_test_sglists *tsgls)\n{\n\tstruct aead_extra_tests_ctx *ctx;\n\tunsigned int i;\n\tint err;\n\n\tif (noextratests)\n\t\treturn 0;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tinit_rnd_state(&ctx->rng);\n\tctx->req = req;\n\tctx->tfm = crypto_aead_reqtfm(req);\n\tctx->test_desc = test_desc;\n\tctx->tsgls = tsgls;\n\tctx->maxdatasize = (2 * PAGE_SIZE) - TESTMGR_POISON_LEN;\n\tctx->maxkeysize = 0;\n\tfor (i = 0; i < test_desc->suite.aead.count; i++)\n\t\tctx->maxkeysize = max_t(unsigned int, ctx->maxkeysize,\n\t\t\t\t\ttest_desc->suite.aead.vecs[i].klen);\n\n\tctx->vec.key = kmalloc(ctx->maxkeysize, GFP_KERNEL);\n\tctx->vec.iv = kmalloc(crypto_aead_ivsize(ctx->tfm), GFP_KERNEL);\n\tctx->vec.assoc = kmalloc(ctx->maxdatasize, GFP_KERNEL);\n\tctx->vec.ptext = kmalloc(ctx->maxdatasize, GFP_KERNEL);\n\tctx->vec.ctext = kmalloc(ctx->maxdatasize, GFP_KERNEL);\n\tif (!ctx->vec.key || !ctx->vec.iv || !ctx->vec.assoc ||\n\t    !ctx->vec.ptext || !ctx->vec.ctext) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = test_aead_vs_generic_impl(ctx);\n\tif (err)\n\t\tgoto out;\n\n\terr = test_aead_inauthentic_inputs(ctx);\nout:\n\tkfree(ctx->vec.key);\n\tkfree(ctx->vec.iv);\n\tkfree(ctx->vec.assoc);\n\tkfree(ctx->vec.ptext);\n\tkfree(ctx->vec.ctext);\n\tkfree(ctx);\n\treturn err;\n}\n#else  \nstatic int test_aead_extra(const struct alg_test_desc *test_desc,\n\t\t\t   struct aead_request *req,\n\t\t\t   struct cipher_test_sglists *tsgls)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int test_aead(int enc, const struct aead_test_suite *suite,\n\t\t     struct aead_request *req,\n\t\t     struct cipher_test_sglists *tsgls)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < suite->count; i++) {\n\t\terr = test_aead_vec(enc, &suite->vecs[i], i, req, tsgls);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}\n\nstatic int alg_test_aead(const struct alg_test_desc *desc, const char *driver,\n\t\t\t u32 type, u32 mask)\n{\n\tconst struct aead_test_suite *suite = &desc->suite.aead;\n\tstruct crypto_aead *tfm;\n\tstruct aead_request *req = NULL;\n\tstruct cipher_test_sglists *tsgls = NULL;\n\tint err;\n\n\tif (suite->count <= 0) {\n\t\tpr_err(\"alg: aead: empty test suite for %s\\n\", driver);\n\t\treturn -EINVAL;\n\t}\n\n\ttfm = crypto_alloc_aead(driver, type, mask);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"alg: aead: failed to allocate transform for %s: %ld\\n\",\n\t\t       driver, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tdriver = crypto_aead_driver_name(tfm);\n\n\treq = aead_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"alg: aead: failed to allocate request for %s\\n\",\n\t\t       driver);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttsgls = alloc_cipher_test_sglists();\n\tif (!tsgls) {\n\t\tpr_err(\"alg: aead: failed to allocate test buffers for %s\\n\",\n\t\t       driver);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = test_aead(ENCRYPT, suite, req, tsgls);\n\tif (err)\n\t\tgoto out;\n\n\terr = test_aead(DECRYPT, suite, req, tsgls);\n\tif (err)\n\t\tgoto out;\n\n\terr = test_aead_extra(desc, req, tsgls);\nout:\n\tfree_cipher_test_sglists(tsgls);\n\taead_request_free(req);\n\tcrypto_free_aead(tfm);\n\treturn err;\n}\n\nstatic int test_cipher(struct crypto_cipher *tfm, int enc,\n\t\t       const struct cipher_testvec *template,\n\t\t       unsigned int tcount)\n{\n\tconst char *algo = crypto_tfm_alg_driver_name(crypto_cipher_tfm(tfm));\n\tunsigned int i, j, k;\n\tchar *q;\n\tconst char *e;\n\tconst char *input, *result;\n\tvoid *data;\n\tchar *xbuf[XBUFSIZE];\n\tint ret = -ENOMEM;\n\n\tif (testmgr_alloc_buf(xbuf))\n\t\tgoto out_nobuf;\n\n\tif (enc == ENCRYPT)\n\t        e = \"encryption\";\n\telse\n\t\te = \"decryption\";\n\n\tj = 0;\n\tfor (i = 0; i < tcount; i++) {\n\n\t\tif (fips_enabled && template[i].fips_skip)\n\t\t\tcontinue;\n\n\t\tinput  = enc ? template[i].ptext : template[i].ctext;\n\t\tresult = enc ? template[i].ctext : template[i].ptext;\n\t\tj++;\n\n\t\tret = -EINVAL;\n\t\tif (WARN_ON(template[i].len > PAGE_SIZE))\n\t\t\tgoto out;\n\n\t\tdata = xbuf[0];\n\t\tmemcpy(data, input, template[i].len);\n\n\t\tcrypto_cipher_clear_flags(tfm, ~0);\n\t\tif (template[i].wk)\n\t\t\tcrypto_cipher_set_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);\n\n\t\tret = crypto_cipher_setkey(tfm, template[i].key,\n\t\t\t\t\t   template[i].klen);\n\t\tif (ret) {\n\t\t\tif (ret == template[i].setkey_error)\n\t\t\t\tcontinue;\n\t\t\tpr_err(\"alg: cipher: %s setkey failed on test vector %u; expected_error=%d, actual_error=%d, flags=%#x\\n\",\n\t\t\t       algo, j, template[i].setkey_error, ret,\n\t\t\t       crypto_cipher_get_flags(tfm));\n\t\t\tgoto out;\n\t\t}\n\t\tif (template[i].setkey_error) {\n\t\t\tpr_err(\"alg: cipher: %s setkey unexpectedly succeeded on test vector %u; expected_error=%d\\n\",\n\t\t\t       algo, j, template[i].setkey_error);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (k = 0; k < template[i].len;\n\t\t     k += crypto_cipher_blocksize(tfm)) {\n\t\t\tif (enc)\n\t\t\t\tcrypto_cipher_encrypt_one(tfm, data + k,\n\t\t\t\t\t\t\t  data + k);\n\t\t\telse\n\t\t\t\tcrypto_cipher_decrypt_one(tfm, data + k,\n\t\t\t\t\t\t\t  data + k);\n\t\t}\n\n\t\tq = data;\n\t\tif (memcmp(q, result, template[i].len)) {\n\t\t\tprintk(KERN_ERR \"alg: cipher: Test %d failed \"\n\t\t\t       \"on %s for %s\\n\", j, e, algo);\n\t\t\thexdump(q, template[i].len);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\nout:\n\ttestmgr_free_buf(xbuf);\nout_nobuf:\n\treturn ret;\n}\n\nstatic int test_skcipher_vec_cfg(int enc, const struct cipher_testvec *vec,\n\t\t\t\t const char *vec_name,\n\t\t\t\t const struct testvec_config *cfg,\n\t\t\t\t struct skcipher_request *req,\n\t\t\t\t struct cipher_test_sglists *tsgls)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tconst unsigned int alignmask = crypto_skcipher_alignmask(tfm);\n\tconst unsigned int ivsize = crypto_skcipher_ivsize(tfm);\n\tconst char *driver = crypto_skcipher_driver_name(tfm);\n\tconst u32 req_flags = CRYPTO_TFM_REQ_MAY_BACKLOG | cfg->req_flags;\n\tconst char *op = enc ? \"encryption\" : \"decryption\";\n\tDECLARE_CRYPTO_WAIT(wait);\n\tu8 _iv[3 * (MAX_ALGAPI_ALIGNMASK + 1) + MAX_IVLEN];\n\tu8 *iv = PTR_ALIGN(&_iv[0], 2 * (MAX_ALGAPI_ALIGNMASK + 1)) +\n\t\t cfg->iv_offset +\n\t\t (cfg->iv_offset_relative_to_alignmask ? alignmask : 0);\n\tstruct kvec input;\n\tint err;\n\n\t \n\tif (vec->wk)\n\t\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);\n\telse\n\t\tcrypto_skcipher_clear_flags(tfm,\n\t\t\t\t\t    CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);\n\terr = do_setkey(crypto_skcipher_setkey, tfm, vec->key, vec->klen,\n\t\t\tcfg, alignmask);\n\tif (err) {\n\t\tif (err == vec->setkey_error)\n\t\t\treturn 0;\n\t\tpr_err(\"alg: skcipher: %s setkey failed on test vector %s; expected_error=%d, actual_error=%d, flags=%#x\\n\",\n\t\t       driver, vec_name, vec->setkey_error, err,\n\t\t       crypto_skcipher_get_flags(tfm));\n\t\treturn err;\n\t}\n\tif (vec->setkey_error) {\n\t\tpr_err(\"alg: skcipher: %s setkey unexpectedly succeeded on test vector %s; expected_error=%d\\n\",\n\t\t       driver, vec_name, vec->setkey_error);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ivsize) {\n\t\tif (WARN_ON(ivsize > MAX_IVLEN))\n\t\t\treturn -EINVAL;\n\t\tif (vec->generates_iv && !enc)\n\t\t\tmemcpy(iv, vec->iv_out, ivsize);\n\t\telse if (vec->iv)\n\t\t\tmemcpy(iv, vec->iv, ivsize);\n\t\telse\n\t\t\tmemset(iv, 0, ivsize);\n\t} else {\n\t\tif (vec->generates_iv) {\n\t\t\tpr_err(\"alg: skcipher: %s has ivsize=0 but test vector %s generates IV!\\n\",\n\t\t\t       driver, vec_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tiv = NULL;\n\t}\n\n\t \n\tinput.iov_base = enc ? (void *)vec->ptext : (void *)vec->ctext;\n\tinput.iov_len = vec->len;\n\terr = build_cipher_test_sglists(tsgls, cfg, alignmask,\n\t\t\t\t\tvec->len, vec->len, &input, 1);\n\tif (err) {\n\t\tpr_err(\"alg: skcipher: %s %s: error preparing scatterlists for test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\treturn err;\n\t}\n\n\t \n\ttestmgr_poison(req->__ctx, crypto_skcipher_reqsize(tfm));\n\tskcipher_request_set_callback(req, req_flags, crypto_req_done, &wait);\n\tskcipher_request_set_crypt(req, tsgls->src.sgl_ptr, tsgls->dst.sgl_ptr,\n\t\t\t\t   vec->len, iv);\n\tif (cfg->nosimd)\n\t\tcrypto_disable_simd_for_test();\n\terr = enc ? crypto_skcipher_encrypt(req) : crypto_skcipher_decrypt(req);\n\tif (cfg->nosimd)\n\t\tcrypto_reenable_simd_for_test();\n\terr = crypto_wait_req(err, &wait);\n\n\t \n\tif (req->cryptlen != vec->len ||\n\t    req->iv != iv ||\n\t    req->src != tsgls->src.sgl_ptr ||\n\t    req->dst != tsgls->dst.sgl_ptr ||\n\t    crypto_skcipher_reqtfm(req) != tfm ||\n\t    req->base.complete != crypto_req_done ||\n\t    req->base.flags != req_flags ||\n\t    req->base.data != &wait) {\n\t\tpr_err(\"alg: skcipher: %s %s corrupted request struct on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\tif (req->cryptlen != vec->len)\n\t\t\tpr_err(\"alg: skcipher: changed 'req->cryptlen'\\n\");\n\t\tif (req->iv != iv)\n\t\t\tpr_err(\"alg: skcipher: changed 'req->iv'\\n\");\n\t\tif (req->src != tsgls->src.sgl_ptr)\n\t\t\tpr_err(\"alg: skcipher: changed 'req->src'\\n\");\n\t\tif (req->dst != tsgls->dst.sgl_ptr)\n\t\t\tpr_err(\"alg: skcipher: changed 'req->dst'\\n\");\n\t\tif (crypto_skcipher_reqtfm(req) != tfm)\n\t\t\tpr_err(\"alg: skcipher: changed 'req->base.tfm'\\n\");\n\t\tif (req->base.complete != crypto_req_done)\n\t\t\tpr_err(\"alg: skcipher: changed 'req->base.complete'\\n\");\n\t\tif (req->base.flags != req_flags)\n\t\t\tpr_err(\"alg: skcipher: changed 'req->base.flags'\\n\");\n\t\tif (req->base.data != &wait)\n\t\t\tpr_err(\"alg: skcipher: changed 'req->base.data'\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (is_test_sglist_corrupted(&tsgls->src)) {\n\t\tpr_err(\"alg: skcipher: %s %s corrupted src sgl on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\treturn -EINVAL;\n\t}\n\tif (tsgls->dst.sgl_ptr != tsgls->src.sgl &&\n\t    is_test_sglist_corrupted(&tsgls->dst)) {\n\t\tpr_err(\"alg: skcipher: %s %s corrupted dst sgl on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (err) {\n\t\tif (err == vec->crypt_error)\n\t\t\treturn 0;\n\t\tpr_err(\"alg: skcipher: %s %s failed on test vector %s; expected_error=%d, actual_error=%d, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, vec->crypt_error, err, cfg->name);\n\t\treturn err;\n\t}\n\tif (vec->crypt_error) {\n\t\tpr_err(\"alg: skcipher: %s %s unexpectedly succeeded on test vector %s; expected_error=%d, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, vec->crypt_error, cfg->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = verify_correct_output(&tsgls->dst, enc ? vec->ctext : vec->ptext,\n\t\t\t\t    vec->len, 0, true);\n\tif (err == -EOVERFLOW) {\n\t\tpr_err(\"alg: skcipher: %s %s overran dst buffer on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\treturn err;\n\t}\n\tif (err) {\n\t\tpr_err(\"alg: skcipher: %s %s test failed (wrong result) on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\treturn err;\n\t}\n\n\t \n\tif (vec->iv_out && memcmp(iv, vec->iv_out, ivsize) != 0) {\n\t\tpr_err(\"alg: skcipher: %s %s test failed (wrong output IV) on test vector %s, cfg=\\\"%s\\\"\\n\",\n\t\t       driver, op, vec_name, cfg->name);\n\t\thexdump(iv, ivsize);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int test_skcipher_vec(int enc, const struct cipher_testvec *vec,\n\t\t\t     unsigned int vec_num,\n\t\t\t     struct skcipher_request *req,\n\t\t\t     struct cipher_test_sglists *tsgls)\n{\n\tchar vec_name[16];\n\tunsigned int i;\n\tint err;\n\n\tif (fips_enabled && vec->fips_skip)\n\t\treturn 0;\n\n\tsprintf(vec_name, \"%u\", vec_num);\n\n\tfor (i = 0; i < ARRAY_SIZE(default_cipher_testvec_configs); i++) {\n\t\terr = test_skcipher_vec_cfg(enc, vec, vec_name,\n\t\t\t\t\t    &default_cipher_testvec_configs[i],\n\t\t\t\t\t    req, tsgls);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\n\tif (!noextratests) {\n\t\tstruct rnd_state rng;\n\t\tstruct testvec_config cfg;\n\t\tchar cfgname[TESTVEC_CONFIG_NAMELEN];\n\n\t\tinit_rnd_state(&rng);\n\n\t\tfor (i = 0; i < fuzz_iterations; i++) {\n\t\t\tgenerate_random_testvec_config(&rng, &cfg, cfgname,\n\t\t\t\t\t\t       sizeof(cfgname));\n\t\t\terr = test_skcipher_vec_cfg(enc, vec, vec_name,\n\t\t\t\t\t\t    &cfg, req, tsgls);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tcond_resched();\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\n \nstatic void generate_random_cipher_testvec(struct rnd_state *rng,\n\t\t\t\t\t   struct skcipher_request *req,\n\t\t\t\t\t   struct cipher_testvec *vec,\n\t\t\t\t\t   unsigned int maxdatasize,\n\t\t\t\t\t   char *name, size_t max_namelen)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tconst unsigned int maxkeysize = crypto_skcipher_max_keysize(tfm);\n\tconst unsigned int ivsize = crypto_skcipher_ivsize(tfm);\n\tstruct scatterlist src, dst;\n\tu8 iv[MAX_IVLEN];\n\tDECLARE_CRYPTO_WAIT(wait);\n\n\t \n\tvec->klen = maxkeysize;\n\tif (prandom_u32_below(rng, 4) == 0)\n\t\tvec->klen = prandom_u32_below(rng, maxkeysize + 1);\n\tgenerate_random_bytes(rng, (u8 *)vec->key, vec->klen);\n\tvec->setkey_error = crypto_skcipher_setkey(tfm, vec->key, vec->klen);\n\n\t \n\tgenerate_random_bytes(rng, (u8 *)vec->iv, ivsize);\n\n\t \n\tvec->len = generate_random_length(rng, maxdatasize);\n\tgenerate_random_bytes(rng, (u8 *)vec->ptext, vec->len);\n\n\t \n\tif (vec->setkey_error)\n\t\tgoto done;\n\n\t \n\tsg_init_one(&src, vec->ptext, vec->len);\n\tsg_init_one(&dst, vec->ctext, vec->len);\n\tmemcpy(iv, vec->iv, ivsize);\n\tskcipher_request_set_callback(req, 0, crypto_req_done, &wait);\n\tskcipher_request_set_crypt(req, &src, &dst, vec->len, iv);\n\tvec->crypt_error = crypto_wait_req(crypto_skcipher_encrypt(req), &wait);\n\tif (vec->crypt_error != 0) {\n\t\t \n\t\tmemset((u8 *)vec->ctext, 0, vec->len);\n\t}\ndone:\n\tsnprintf(name, max_namelen, \"\\\"random: len=%u klen=%u\\\"\",\n\t\t vec->len, vec->klen);\n}\n\n \nstatic int test_skcipher_vs_generic_impl(const char *generic_driver,\n\t\t\t\t\t struct skcipher_request *req,\n\t\t\t\t\t struct cipher_test_sglists *tsgls)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tconst unsigned int maxkeysize = crypto_skcipher_max_keysize(tfm);\n\tconst unsigned int ivsize = crypto_skcipher_ivsize(tfm);\n\tconst unsigned int blocksize = crypto_skcipher_blocksize(tfm);\n\tconst unsigned int maxdatasize = (2 * PAGE_SIZE) - TESTMGR_POISON_LEN;\n\tconst char *algname = crypto_skcipher_alg(tfm)->base.cra_name;\n\tconst char *driver = crypto_skcipher_driver_name(tfm);\n\tstruct rnd_state rng;\n\tchar _generic_driver[CRYPTO_MAX_ALG_NAME];\n\tstruct crypto_skcipher *generic_tfm = NULL;\n\tstruct skcipher_request *generic_req = NULL;\n\tunsigned int i;\n\tstruct cipher_testvec vec = { 0 };\n\tchar vec_name[64];\n\tstruct testvec_config *cfg;\n\tchar cfgname[TESTVEC_CONFIG_NAMELEN];\n\tint err;\n\n\tif (noextratests)\n\t\treturn 0;\n\n\t \n\tif (strncmp(algname, \"kw(\", 3) == 0)\n\t\treturn 0;\n\n\tinit_rnd_state(&rng);\n\n\tif (!generic_driver) {  \n\t\terr = build_generic_driver_name(algname, _generic_driver);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgeneric_driver = _generic_driver;\n\t}\n\n\tif (strcmp(generic_driver, driver) == 0)  \n\t\treturn 0;\n\n\tgeneric_tfm = crypto_alloc_skcipher(generic_driver, 0, 0);\n\tif (IS_ERR(generic_tfm)) {\n\t\terr = PTR_ERR(generic_tfm);\n\t\tif (err == -ENOENT) {\n\t\t\tpr_warn(\"alg: skcipher: skipping comparison tests for %s because %s is unavailable\\n\",\n\t\t\t\tdriver, generic_driver);\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"alg: skcipher: error allocating %s (generic impl of %s): %d\\n\",\n\t\t       generic_driver, algname, err);\n\t\treturn err;\n\t}\n\n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tgeneric_req = skcipher_request_alloc(generic_tfm, GFP_KERNEL);\n\tif (!generic_req) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (crypto_skcipher_min_keysize(tfm) !=\n\t    crypto_skcipher_min_keysize(generic_tfm)) {\n\t\tpr_err(\"alg: skcipher: min keysize for %s (%u) doesn't match generic impl (%u)\\n\",\n\t\t       driver, crypto_skcipher_min_keysize(tfm),\n\t\t       crypto_skcipher_min_keysize(generic_tfm));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (maxkeysize != crypto_skcipher_max_keysize(generic_tfm)) {\n\t\tpr_err(\"alg: skcipher: max keysize for %s (%u) doesn't match generic impl (%u)\\n\",\n\t\t       driver, maxkeysize,\n\t\t       crypto_skcipher_max_keysize(generic_tfm));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ivsize != crypto_skcipher_ivsize(generic_tfm)) {\n\t\tpr_err(\"alg: skcipher: ivsize for %s (%u) doesn't match generic impl (%u)\\n\",\n\t\t       driver, ivsize, crypto_skcipher_ivsize(generic_tfm));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (blocksize != crypto_skcipher_blocksize(generic_tfm)) {\n\t\tpr_err(\"alg: skcipher: blocksize for %s (%u) doesn't match generic impl (%u)\\n\",\n\t\t       driver, blocksize,\n\t\t       crypto_skcipher_blocksize(generic_tfm));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\n\tvec.key = kmalloc(maxkeysize, GFP_KERNEL);\n\tvec.iv = kmalloc(ivsize, GFP_KERNEL);\n\tvec.ptext = kmalloc(maxdatasize, GFP_KERNEL);\n\tvec.ctext = kmalloc(maxdatasize, GFP_KERNEL);\n\tif (!vec.key || !vec.iv || !vec.ptext || !vec.ctext) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < fuzz_iterations * 8; i++) {\n\t\tgenerate_random_cipher_testvec(&rng, generic_req, &vec,\n\t\t\t\t\t       maxdatasize,\n\t\t\t\t\t       vec_name, sizeof(vec_name));\n\t\tgenerate_random_testvec_config(&rng, cfg, cfgname,\n\t\t\t\t\t       sizeof(cfgname));\n\n\t\terr = test_skcipher_vec_cfg(ENCRYPT, &vec, vec_name,\n\t\t\t\t\t    cfg, req, tsgls);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = test_skcipher_vec_cfg(DECRYPT, &vec, vec_name,\n\t\t\t\t\t    cfg, req, tsgls);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tcond_resched();\n\t}\n\terr = 0;\nout:\n\tkfree(cfg);\n\tkfree(vec.key);\n\tkfree(vec.iv);\n\tkfree(vec.ptext);\n\tkfree(vec.ctext);\n\tcrypto_free_skcipher(generic_tfm);\n\tskcipher_request_free(generic_req);\n\treturn err;\n}\n#else  \nstatic int test_skcipher_vs_generic_impl(const char *generic_driver,\n\t\t\t\t\t struct skcipher_request *req,\n\t\t\t\t\t struct cipher_test_sglists *tsgls)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int test_skcipher(int enc, const struct cipher_test_suite *suite,\n\t\t\t struct skcipher_request *req,\n\t\t\t struct cipher_test_sglists *tsgls)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < suite->count; i++) {\n\t\terr = test_skcipher_vec(enc, &suite->vecs[i], i, req, tsgls);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}\n\nstatic int alg_test_skcipher(const struct alg_test_desc *desc,\n\t\t\t     const char *driver, u32 type, u32 mask)\n{\n\tconst struct cipher_test_suite *suite = &desc->suite.cipher;\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req = NULL;\n\tstruct cipher_test_sglists *tsgls = NULL;\n\tint err;\n\n\tif (suite->count <= 0) {\n\t\tpr_err(\"alg: skcipher: empty test suite for %s\\n\", driver);\n\t\treturn -EINVAL;\n\t}\n\n\ttfm = crypto_alloc_skcipher(driver, type, mask);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"alg: skcipher: failed to allocate transform for %s: %ld\\n\",\n\t\t       driver, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tdriver = crypto_skcipher_driver_name(tfm);\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"alg: skcipher: failed to allocate request for %s\\n\",\n\t\t       driver);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttsgls = alloc_cipher_test_sglists();\n\tif (!tsgls) {\n\t\tpr_err(\"alg: skcipher: failed to allocate test buffers for %s\\n\",\n\t\t       driver);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = test_skcipher(ENCRYPT, suite, req, tsgls);\n\tif (err)\n\t\tgoto out;\n\n\terr = test_skcipher(DECRYPT, suite, req, tsgls);\n\tif (err)\n\t\tgoto out;\n\n\terr = test_skcipher_vs_generic_impl(desc->generic_driver, req, tsgls);\nout:\n\tfree_cipher_test_sglists(tsgls);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\treturn err;\n}\n\nstatic int test_comp(struct crypto_comp *tfm,\n\t\t     const struct comp_testvec *ctemplate,\n\t\t     const struct comp_testvec *dtemplate,\n\t\t     int ctcount, int dtcount)\n{\n\tconst char *algo = crypto_tfm_alg_driver_name(crypto_comp_tfm(tfm));\n\tchar *output, *decomp_output;\n\tunsigned int i;\n\tint ret;\n\n\toutput = kmalloc(COMP_BUF_SIZE, GFP_KERNEL);\n\tif (!output)\n\t\treturn -ENOMEM;\n\n\tdecomp_output = kmalloc(COMP_BUF_SIZE, GFP_KERNEL);\n\tif (!decomp_output) {\n\t\tkfree(output);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < ctcount; i++) {\n\t\tint ilen;\n\t\tunsigned int dlen = COMP_BUF_SIZE;\n\n\t\tmemset(output, 0, COMP_BUF_SIZE);\n\t\tmemset(decomp_output, 0, COMP_BUF_SIZE);\n\n\t\tilen = ctemplate[i].inlen;\n\t\tret = crypto_comp_compress(tfm, ctemplate[i].input,\n\t\t\t\t\t   ilen, output, &dlen);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"alg: comp: compression failed \"\n\t\t\t       \"on test %d for %s: ret=%d\\n\", i + 1, algo,\n\t\t\t       -ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tilen = dlen;\n\t\tdlen = COMP_BUF_SIZE;\n\t\tret = crypto_comp_decompress(tfm, output,\n\t\t\t\t\t     ilen, decomp_output, &dlen);\n\t\tif (ret) {\n\t\t\tpr_err(\"alg: comp: compression failed: decompress: on test %d for %s failed: ret=%d\\n\",\n\t\t\t       i + 1, algo, -ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (dlen != ctemplate[i].inlen) {\n\t\t\tprintk(KERN_ERR \"alg: comp: Compression test %d \"\n\t\t\t       \"failed for %s: output len = %d\\n\", i + 1, algo,\n\t\t\t       dlen);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (memcmp(decomp_output, ctemplate[i].input,\n\t\t\t   ctemplate[i].inlen)) {\n\t\t\tpr_err(\"alg: comp: compression failed: output differs: on test %d for %s\\n\",\n\t\t\t       i + 1, algo);\n\t\t\thexdump(decomp_output, dlen);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; i < dtcount; i++) {\n\t\tint ilen;\n\t\tunsigned int dlen = COMP_BUF_SIZE;\n\n\t\tmemset(decomp_output, 0, COMP_BUF_SIZE);\n\n\t\tilen = dtemplate[i].inlen;\n\t\tret = crypto_comp_decompress(tfm, dtemplate[i].input,\n\t\t\t\t\t     ilen, decomp_output, &dlen);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"alg: comp: decompression failed \"\n\t\t\t       \"on test %d for %s: ret=%d\\n\", i + 1, algo,\n\t\t\t       -ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (dlen != dtemplate[i].outlen) {\n\t\t\tprintk(KERN_ERR \"alg: comp: Decompression test %d \"\n\t\t\t       \"failed for %s: output len = %d\\n\", i + 1, algo,\n\t\t\t       dlen);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (memcmp(decomp_output, dtemplate[i].output, dlen)) {\n\t\t\tprintk(KERN_ERR \"alg: comp: Decompression test %d \"\n\t\t\t       \"failed for %s\\n\", i + 1, algo);\n\t\t\thexdump(decomp_output, dlen);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\n\nout:\n\tkfree(decomp_output);\n\tkfree(output);\n\treturn ret;\n}\n\nstatic int test_acomp(struct crypto_acomp *tfm,\n\t\t      const struct comp_testvec *ctemplate,\n\t\t      const struct comp_testvec *dtemplate,\n\t\t      int ctcount, int dtcount)\n{\n\tconst char *algo = crypto_tfm_alg_driver_name(crypto_acomp_tfm(tfm));\n\tunsigned int i;\n\tchar *output, *decomp_out;\n\tint ret;\n\tstruct scatterlist src, dst;\n\tstruct acomp_req *req;\n\tstruct crypto_wait wait;\n\n\toutput = kmalloc(COMP_BUF_SIZE, GFP_KERNEL);\n\tif (!output)\n\t\treturn -ENOMEM;\n\n\tdecomp_out = kmalloc(COMP_BUF_SIZE, GFP_KERNEL);\n\tif (!decomp_out) {\n\t\tkfree(output);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < ctcount; i++) {\n\t\tunsigned int dlen = COMP_BUF_SIZE;\n\t\tint ilen = ctemplate[i].inlen;\n\t\tvoid *input_vec;\n\n\t\tinput_vec = kmemdup(ctemplate[i].input, ilen, GFP_KERNEL);\n\t\tif (!input_vec) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemset(output, 0, dlen);\n\t\tcrypto_init_wait(&wait);\n\t\tsg_init_one(&src, input_vec, ilen);\n\t\tsg_init_one(&dst, output, dlen);\n\n\t\treq = acomp_request_alloc(tfm);\n\t\tif (!req) {\n\t\t\tpr_err(\"alg: acomp: request alloc failed for %s\\n\",\n\t\t\t       algo);\n\t\t\tkfree(input_vec);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tacomp_request_set_params(req, &src, &dst, ilen, dlen);\n\t\tacomp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\t   crypto_req_done, &wait);\n\n\t\tret = crypto_wait_req(crypto_acomp_compress(req), &wait);\n\t\tif (ret) {\n\t\t\tpr_err(\"alg: acomp: compression failed on test %d for %s: ret=%d\\n\",\n\t\t\t       i + 1, algo, -ret);\n\t\t\tkfree(input_vec);\n\t\t\tacomp_request_free(req);\n\t\t\tgoto out;\n\t\t}\n\n\t\tilen = req->dlen;\n\t\tdlen = COMP_BUF_SIZE;\n\t\tsg_init_one(&src, output, ilen);\n\t\tsg_init_one(&dst, decomp_out, dlen);\n\t\tcrypto_init_wait(&wait);\n\t\tacomp_request_set_params(req, &src, &dst, ilen, dlen);\n\n\t\tret = crypto_wait_req(crypto_acomp_decompress(req), &wait);\n\t\tif (ret) {\n\t\t\tpr_err(\"alg: acomp: compression failed on test %d for %s: ret=%d\\n\",\n\t\t\t       i + 1, algo, -ret);\n\t\t\tkfree(input_vec);\n\t\t\tacomp_request_free(req);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (req->dlen != ctemplate[i].inlen) {\n\t\t\tpr_err(\"alg: acomp: Compression test %d failed for %s: output len = %d\\n\",\n\t\t\t       i + 1, algo, req->dlen);\n\t\t\tret = -EINVAL;\n\t\t\tkfree(input_vec);\n\t\t\tacomp_request_free(req);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (memcmp(input_vec, decomp_out, req->dlen)) {\n\t\t\tpr_err(\"alg: acomp: Compression test %d failed for %s\\n\",\n\t\t\t       i + 1, algo);\n\t\t\thexdump(output, req->dlen);\n\t\t\tret = -EINVAL;\n\t\t\tkfree(input_vec);\n\t\t\tacomp_request_free(req);\n\t\t\tgoto out;\n\t\t}\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\n\t\tcrypto_init_wait(&wait);\n\t\tsg_init_one(&src, input_vec, ilen);\n\t\tacomp_request_set_params(req, &src, NULL, ilen, 0);\n\n\t\tret = crypto_wait_req(crypto_acomp_compress(req), &wait);\n\t\tif (ret) {\n\t\t\tpr_err(\"alg: acomp: compression failed on NULL dst buffer test %d for %s: ret=%d\\n\",\n\t\t\t       i + 1, algo, -ret);\n\t\t\tkfree(input_vec);\n\t\t\tacomp_request_free(req);\n\t\t\tgoto out;\n\t\t}\n#endif\n\n\t\tkfree(input_vec);\n\t\tacomp_request_free(req);\n\t}\n\n\tfor (i = 0; i < dtcount; i++) {\n\t\tunsigned int dlen = COMP_BUF_SIZE;\n\t\tint ilen = dtemplate[i].inlen;\n\t\tvoid *input_vec;\n\n\t\tinput_vec = kmemdup(dtemplate[i].input, ilen, GFP_KERNEL);\n\t\tif (!input_vec) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemset(output, 0, dlen);\n\t\tcrypto_init_wait(&wait);\n\t\tsg_init_one(&src, input_vec, ilen);\n\t\tsg_init_one(&dst, output, dlen);\n\n\t\treq = acomp_request_alloc(tfm);\n\t\tif (!req) {\n\t\t\tpr_err(\"alg: acomp: request alloc failed for %s\\n\",\n\t\t\t       algo);\n\t\t\tkfree(input_vec);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tacomp_request_set_params(req, &src, &dst, ilen, dlen);\n\t\tacomp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\t   crypto_req_done, &wait);\n\n\t\tret = crypto_wait_req(crypto_acomp_decompress(req), &wait);\n\t\tif (ret) {\n\t\t\tpr_err(\"alg: acomp: decompression failed on test %d for %s: ret=%d\\n\",\n\t\t\t       i + 1, algo, -ret);\n\t\t\tkfree(input_vec);\n\t\t\tacomp_request_free(req);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (req->dlen != dtemplate[i].outlen) {\n\t\t\tpr_err(\"alg: acomp: Decompression test %d failed for %s: output len = %d\\n\",\n\t\t\t       i + 1, algo, req->dlen);\n\t\t\tret = -EINVAL;\n\t\t\tkfree(input_vec);\n\t\t\tacomp_request_free(req);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (memcmp(output, dtemplate[i].output, req->dlen)) {\n\t\t\tpr_err(\"alg: acomp: Decompression test %d failed for %s\\n\",\n\t\t\t       i + 1, algo);\n\t\t\thexdump(output, req->dlen);\n\t\t\tret = -EINVAL;\n\t\t\tkfree(input_vec);\n\t\t\tacomp_request_free(req);\n\t\t\tgoto out;\n\t\t}\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\n\t\tcrypto_init_wait(&wait);\n\t\tacomp_request_set_params(req, &src, NULL, ilen, 0);\n\n\t\tret = crypto_wait_req(crypto_acomp_decompress(req), &wait);\n\t\tif (ret) {\n\t\t\tpr_err(\"alg: acomp: decompression failed on NULL dst buffer test %d for %s: ret=%d\\n\",\n\t\t\t       i + 1, algo, -ret);\n\t\t\tkfree(input_vec);\n\t\t\tacomp_request_free(req);\n\t\t\tgoto out;\n\t\t}\n#endif\n\n\t\tkfree(input_vec);\n\t\tacomp_request_free(req);\n\t}\n\n\tret = 0;\n\nout:\n\tkfree(decomp_out);\n\tkfree(output);\n\treturn ret;\n}\n\nstatic int test_cprng(struct crypto_rng *tfm,\n\t\t      const struct cprng_testvec *template,\n\t\t      unsigned int tcount)\n{\n\tconst char *algo = crypto_tfm_alg_driver_name(crypto_rng_tfm(tfm));\n\tint err = 0, i, j, seedsize;\n\tu8 *seed;\n\tchar result[32];\n\n\tseedsize = crypto_rng_seedsize(tfm);\n\n\tseed = kmalloc(seedsize, GFP_KERNEL);\n\tif (!seed) {\n\t\tprintk(KERN_ERR \"alg: cprng: Failed to allocate seed space \"\n\t\t       \"for %s\\n\", algo);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < tcount; i++) {\n\t\tmemset(result, 0, 32);\n\n\t\tmemcpy(seed, template[i].v, template[i].vlen);\n\t\tmemcpy(seed + template[i].vlen, template[i].key,\n\t\t       template[i].klen);\n\t\tmemcpy(seed + template[i].vlen + template[i].klen,\n\t\t       template[i].dt, template[i].dtlen);\n\n\t\terr = crypto_rng_reset(tfm, seed, seedsize);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"alg: cprng: Failed to reset rng \"\n\t\t\t       \"for %s\\n\", algo);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (j = 0; j < template[i].loops; j++) {\n\t\t\terr = crypto_rng_get_bytes(tfm, result,\n\t\t\t\t\t\t   template[i].rlen);\n\t\t\tif (err < 0) {\n\t\t\t\tprintk(KERN_ERR \"alg: cprng: Failed to obtain \"\n\t\t\t\t       \"the correct amount of random data for \"\n\t\t\t\t       \"%s (requested %d)\\n\", algo,\n\t\t\t\t       template[i].rlen);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\terr = memcmp(result, template[i].result,\n\t\t\t     template[i].rlen);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"alg: cprng: Test %d failed for %s\\n\",\n\t\t\t       i, algo);\n\t\t\thexdump(result, template[i].rlen);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tkfree(seed);\n\treturn err;\n}\n\nstatic int alg_test_cipher(const struct alg_test_desc *desc,\n\t\t\t   const char *driver, u32 type, u32 mask)\n{\n\tconst struct cipher_test_suite *suite = &desc->suite.cipher;\n\tstruct crypto_cipher *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_cipher(driver, type, mask);\n\tif (IS_ERR(tfm)) {\n\t\tprintk(KERN_ERR \"alg: cipher: Failed to load transform for \"\n\t\t       \"%s: %ld\\n\", driver, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = test_cipher(tfm, ENCRYPT, suite->vecs, suite->count);\n\tif (!err)\n\t\terr = test_cipher(tfm, DECRYPT, suite->vecs, suite->count);\n\n\tcrypto_free_cipher(tfm);\n\treturn err;\n}\n\nstatic int alg_test_comp(const struct alg_test_desc *desc, const char *driver,\n\t\t\t u32 type, u32 mask)\n{\n\tstruct crypto_comp *comp;\n\tstruct crypto_acomp *acomp;\n\tint err;\n\tu32 algo_type = type & CRYPTO_ALG_TYPE_ACOMPRESS_MASK;\n\n\tif (algo_type == CRYPTO_ALG_TYPE_ACOMPRESS) {\n\t\tacomp = crypto_alloc_acomp(driver, type, mask);\n\t\tif (IS_ERR(acomp)) {\n\t\t\tpr_err(\"alg: acomp: Failed to load transform for %s: %ld\\n\",\n\t\t\t       driver, PTR_ERR(acomp));\n\t\t\treturn PTR_ERR(acomp);\n\t\t}\n\t\terr = test_acomp(acomp, desc->suite.comp.comp.vecs,\n\t\t\t\t desc->suite.comp.decomp.vecs,\n\t\t\t\t desc->suite.comp.comp.count,\n\t\t\t\t desc->suite.comp.decomp.count);\n\t\tcrypto_free_acomp(acomp);\n\t} else {\n\t\tcomp = crypto_alloc_comp(driver, type, mask);\n\t\tif (IS_ERR(comp)) {\n\t\t\tpr_err(\"alg: comp: Failed to load transform for %s: %ld\\n\",\n\t\t\t       driver, PTR_ERR(comp));\n\t\t\treturn PTR_ERR(comp);\n\t\t}\n\n\t\terr = test_comp(comp, desc->suite.comp.comp.vecs,\n\t\t\t\tdesc->suite.comp.decomp.vecs,\n\t\t\t\tdesc->suite.comp.comp.count,\n\t\t\t\tdesc->suite.comp.decomp.count);\n\n\t\tcrypto_free_comp(comp);\n\t}\n\treturn err;\n}\n\nstatic int alg_test_crc32c(const struct alg_test_desc *desc,\n\t\t\t   const char *driver, u32 type, u32 mask)\n{\n\tstruct crypto_shash *tfm;\n\t__le32 val;\n\tint err;\n\n\terr = alg_test_hash(desc, driver, type, mask);\n\tif (err)\n\t\treturn err;\n\n\ttfm = crypto_alloc_shash(driver, type, mask);\n\tif (IS_ERR(tfm)) {\n\t\tif (PTR_ERR(tfm) == -ENOENT) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tprintk(KERN_ERR \"alg: crc32c: Failed to load transform for %s: \"\n\t\t       \"%ld\\n\", driver, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tdriver = crypto_shash_driver_name(tfm);\n\n\tdo {\n\t\tSHASH_DESC_ON_STACK(shash, tfm);\n\t\tu32 *ctx = (u32 *)shash_desc_ctx(shash);\n\n\t\tshash->tfm = tfm;\n\n\t\t*ctx = 420553207;\n\t\terr = crypto_shash_final(shash, (u8 *)&val);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"alg: crc32c: Operation failed for \"\n\t\t\t       \"%s: %d\\n\", driver, err);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val != cpu_to_le32(~420553207)) {\n\t\t\tpr_err(\"alg: crc32c: Test failed for %s: %u\\n\",\n\t\t\t       driver, le32_to_cpu(val));\n\t\t\terr = -EINVAL;\n\t\t}\n\t} while (0);\n\n\tcrypto_free_shash(tfm);\n\n\treturn err;\n}\n\nstatic int alg_test_cprng(const struct alg_test_desc *desc, const char *driver,\n\t\t\t  u32 type, u32 mask)\n{\n\tstruct crypto_rng *rng;\n\tint err;\n\n\trng = crypto_alloc_rng(driver, type, mask);\n\tif (IS_ERR(rng)) {\n\t\tprintk(KERN_ERR \"alg: cprng: Failed to load transform for %s: \"\n\t\t       \"%ld\\n\", driver, PTR_ERR(rng));\n\t\treturn PTR_ERR(rng);\n\t}\n\n\terr = test_cprng(rng, desc->suite.cprng.vecs, desc->suite.cprng.count);\n\n\tcrypto_free_rng(rng);\n\n\treturn err;\n}\n\n\nstatic int drbg_cavs_test(const struct drbg_testvec *test, int pr,\n\t\t\t  const char *driver, u32 type, u32 mask)\n{\n\tint ret = -EAGAIN;\n\tstruct crypto_rng *drng;\n\tstruct drbg_test_data test_data;\n\tstruct drbg_string addtl, pers, testentropy;\n\tunsigned char *buf = kzalloc(test->expectedlen, GFP_KERNEL);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdrng = crypto_alloc_rng(driver, type, mask);\n\tif (IS_ERR(drng)) {\n\t\tprintk(KERN_ERR \"alg: drbg: could not allocate DRNG handle for \"\n\t\t       \"%s\\n\", driver);\n\t\tkfree_sensitive(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\ttest_data.testentropy = &testentropy;\n\tdrbg_string_fill(&testentropy, test->entropy, test->entropylen);\n\tdrbg_string_fill(&pers, test->pers, test->perslen);\n\tret = crypto_drbg_reset_test(drng, &pers, &test_data);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"alg: drbg: Failed to reset rng\\n\");\n\t\tgoto outbuf;\n\t}\n\n\tdrbg_string_fill(&addtl, test->addtla, test->addtllen);\n\tif (pr) {\n\t\tdrbg_string_fill(&testentropy, test->entpra, test->entprlen);\n\t\tret = crypto_drbg_get_bytes_addtl_test(drng,\n\t\t\tbuf, test->expectedlen, &addtl,\t&test_data);\n\t} else {\n\t\tret = crypto_drbg_get_bytes_addtl(drng,\n\t\t\tbuf, test->expectedlen, &addtl);\n\t}\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"alg: drbg: could not obtain random data for \"\n\t\t       \"driver %s\\n\", driver);\n\t\tgoto outbuf;\n\t}\n\n\tdrbg_string_fill(&addtl, test->addtlb, test->addtllen);\n\tif (pr) {\n\t\tdrbg_string_fill(&testentropy, test->entprb, test->entprlen);\n\t\tret = crypto_drbg_get_bytes_addtl_test(drng,\n\t\t\tbuf, test->expectedlen, &addtl, &test_data);\n\t} else {\n\t\tret = crypto_drbg_get_bytes_addtl(drng,\n\t\t\tbuf, test->expectedlen, &addtl);\n\t}\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"alg: drbg: could not obtain random data for \"\n\t\t       \"driver %s\\n\", driver);\n\t\tgoto outbuf;\n\t}\n\n\tret = memcmp(test->expected, buf, test->expectedlen);\n\noutbuf:\n\tcrypto_free_rng(drng);\n\tkfree_sensitive(buf);\n\treturn ret;\n}\n\n\nstatic int alg_test_drbg(const struct alg_test_desc *desc, const char *driver,\n\t\t\t u32 type, u32 mask)\n{\n\tint err = 0;\n\tint pr = 0;\n\tint i = 0;\n\tconst struct drbg_testvec *template = desc->suite.drbg.vecs;\n\tunsigned int tcount = desc->suite.drbg.count;\n\n\tif (0 == memcmp(driver, \"drbg_pr_\", 8))\n\t\tpr = 1;\n\n\tfor (i = 0; i < tcount; i++) {\n\t\terr = drbg_cavs_test(&template[i], pr, driver, type, mask);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"alg: drbg: Test %d failed for %s\\n\",\n\t\t\t       i, driver);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n\n}\n\nstatic int do_test_kpp(struct crypto_kpp *tfm, const struct kpp_testvec *vec,\n\t\t       const char *alg)\n{\n\tstruct kpp_request *req;\n\tvoid *input_buf = NULL;\n\tvoid *output_buf = NULL;\n\tvoid *a_public = NULL;\n\tvoid *a_ss = NULL;\n\tvoid *shared_secret = NULL;\n\tstruct crypto_wait wait;\n\tunsigned int out_len_max;\n\tint err = -ENOMEM;\n\tstruct scatterlist src, dst;\n\n\treq = kpp_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn err;\n\n\tcrypto_init_wait(&wait);\n\n\terr = crypto_kpp_set_secret(tfm, vec->secret, vec->secret_size);\n\tif (err < 0)\n\t\tgoto free_req;\n\n\tout_len_max = crypto_kpp_maxsize(tfm);\n\toutput_buf = kzalloc(out_len_max, GFP_KERNEL);\n\tif (!output_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto free_req;\n\t}\n\n\t \n\tkpp_request_set_input(req, NULL, 0);\n\tsg_init_one(&dst, output_buf, out_len_max);\n\tkpp_request_set_output(req, &dst, out_len_max);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t crypto_req_done, &wait);\n\n\t \n\terr = crypto_wait_req(crypto_kpp_generate_public_key(req), &wait);\n\tif (err) {\n\t\tpr_err(\"alg: %s: Party A: generate public key test failed. err %d\\n\",\n\t\t       alg, err);\n\t\tgoto free_output;\n\t}\n\n\tif (vec->genkey) {\n\t\t \n\t\ta_public = kmemdup(sg_virt(req->dst), out_len_max, GFP_KERNEL);\n\t\tif (!a_public) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_output;\n\t\t}\n\t} else {\n\t\t \n\t\tif (memcmp(vec->expected_a_public, sg_virt(req->dst),\n\t\t\t   vec->expected_a_public_size)) {\n\t\t\tpr_err(\"alg: %s: Party A: generate public key test failed. Invalid output\\n\",\n\t\t\t       alg);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free_output;\n\t\t}\n\t}\n\n\t \n\tinput_buf = kmemdup(vec->b_public, vec->b_public_size, GFP_KERNEL);\n\tif (!input_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto free_output;\n\t}\n\n\tsg_init_one(&src, input_buf, vec->b_public_size);\n\tsg_init_one(&dst, output_buf, out_len_max);\n\tkpp_request_set_input(req, &src, vec->b_public_size);\n\tkpp_request_set_output(req, &dst, out_len_max);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t crypto_req_done, &wait);\n\terr = crypto_wait_req(crypto_kpp_compute_shared_secret(req), &wait);\n\tif (err) {\n\t\tpr_err(\"alg: %s: Party A: compute shared secret test failed. err %d\\n\",\n\t\t       alg, err);\n\t\tgoto free_all;\n\t}\n\n\tif (vec->genkey) {\n\t\t \n\t\ta_ss = kmemdup(sg_virt(req->dst), vec->expected_ss_size, GFP_KERNEL);\n\t\tif (!a_ss) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_all;\n\t\t}\n\n\t\t \n\t\terr = crypto_kpp_set_secret(tfm, vec->b_secret,\n\t\t\t\t\t    vec->b_secret_size);\n\t\tif (err < 0)\n\t\t\tgoto free_all;\n\n\t\tsg_init_one(&src, a_public, vec->expected_a_public_size);\n\t\tsg_init_one(&dst, output_buf, out_len_max);\n\t\tkpp_request_set_input(req, &src, vec->expected_a_public_size);\n\t\tkpp_request_set_output(req, &dst, out_len_max);\n\t\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\t crypto_req_done, &wait);\n\t\terr = crypto_wait_req(crypto_kpp_compute_shared_secret(req),\n\t\t\t\t      &wait);\n\t\tif (err) {\n\t\t\tpr_err(\"alg: %s: Party B: compute shared secret failed. err %d\\n\",\n\t\t\t       alg, err);\n\t\t\tgoto free_all;\n\t\t}\n\n\t\tshared_secret = a_ss;\n\t} else {\n\t\tshared_secret = (void *)vec->expected_ss;\n\t}\n\n\t \n\tif (memcmp(shared_secret, sg_virt(req->dst),\n\t\t   vec->expected_ss_size)) {\n\t\tpr_err(\"alg: %s: compute shared secret test failed. Invalid output\\n\",\n\t\t       alg);\n\t\terr = -EINVAL;\n\t}\n\nfree_all:\n\tkfree(a_ss);\n\tkfree(input_buf);\nfree_output:\n\tkfree(a_public);\n\tkfree(output_buf);\nfree_req:\n\tkpp_request_free(req);\n\treturn err;\n}\n\nstatic int test_kpp(struct crypto_kpp *tfm, const char *alg,\n\t\t    const struct kpp_testvec *vecs, unsigned int tcount)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < tcount; i++) {\n\t\tret = do_test_kpp(tfm, vecs++, alg);\n\t\tif (ret) {\n\t\t\tpr_err(\"alg: %s: test failed on vector %d, err=%d\\n\",\n\t\t\t       alg, i + 1, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int alg_test_kpp(const struct alg_test_desc *desc, const char *driver,\n\t\t\tu32 type, u32 mask)\n{\n\tstruct crypto_kpp *tfm;\n\tint err = 0;\n\n\ttfm = crypto_alloc_kpp(driver, type, mask);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"alg: kpp: Failed to load tfm for %s: %ld\\n\",\n\t\t       driver, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tif (desc->suite.kpp.vecs)\n\t\terr = test_kpp(tfm, desc->alg, desc->suite.kpp.vecs,\n\t\t\t       desc->suite.kpp.count);\n\n\tcrypto_free_kpp(tfm);\n\treturn err;\n}\n\nstatic u8 *test_pack_u32(u8 *dst, u32 val)\n{\n\tmemcpy(dst, &val, sizeof(val));\n\treturn dst + sizeof(val);\n}\n\nstatic int test_akcipher_one(struct crypto_akcipher *tfm,\n\t\t\t     const struct akcipher_testvec *vecs)\n{\n\tchar *xbuf[XBUFSIZE];\n\tstruct akcipher_request *req;\n\tvoid *outbuf_enc = NULL;\n\tvoid *outbuf_dec = NULL;\n\tstruct crypto_wait wait;\n\tunsigned int out_len_max, out_len = 0;\n\tint err = -ENOMEM;\n\tstruct scatterlist src, dst, src_tab[3];\n\tconst char *m, *c;\n\tunsigned int m_size, c_size;\n\tconst char *op;\n\tu8 *key, *ptr;\n\n\tif (testmgr_alloc_buf(xbuf))\n\t\treturn err;\n\n\treq = akcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\tgoto free_xbuf;\n\n\tcrypto_init_wait(&wait);\n\n\tkey = kmalloc(vecs->key_len + sizeof(u32) * 2 + vecs->param_len,\n\t\t      GFP_KERNEL);\n\tif (!key)\n\t\tgoto free_req;\n\tmemcpy(key, vecs->key, vecs->key_len);\n\tptr = key + vecs->key_len;\n\tptr = test_pack_u32(ptr, vecs->algo);\n\tptr = test_pack_u32(ptr, vecs->param_len);\n\tmemcpy(ptr, vecs->params, vecs->param_len);\n\n\tif (vecs->public_key_vec)\n\t\terr = crypto_akcipher_set_pub_key(tfm, key, vecs->key_len);\n\telse\n\t\terr = crypto_akcipher_set_priv_key(tfm, key, vecs->key_len);\n\tif (err)\n\t\tgoto free_key;\n\n\t \n\terr = -ENOMEM;\n\tout_len_max = crypto_akcipher_maxsize(tfm);\n\toutbuf_enc = kzalloc(out_len_max, GFP_KERNEL);\n\tif (!outbuf_enc)\n\t\tgoto free_key;\n\n\tif (!vecs->siggen_sigver_test) {\n\t\tm = vecs->m;\n\t\tm_size = vecs->m_size;\n\t\tc = vecs->c;\n\t\tc_size = vecs->c_size;\n\t\top = \"encrypt\";\n\t} else {\n\t\t \n\t\tm = vecs->c;  \n\t\tm_size = vecs->c_size;\n\t\tc = vecs->m;  \n\t\tc_size = vecs->m_size;\n\t\top = \"verify\";\n\t}\n\n\terr = -E2BIG;\n\tif (WARN_ON(m_size > PAGE_SIZE))\n\t\tgoto free_all;\n\tmemcpy(xbuf[0], m, m_size);\n\n\tsg_init_table(src_tab, 3);\n\tsg_set_buf(&src_tab[0], xbuf[0], 8);\n\tsg_set_buf(&src_tab[1], xbuf[0] + 8, m_size - 8);\n\tif (vecs->siggen_sigver_test) {\n\t\tif (WARN_ON(c_size > PAGE_SIZE))\n\t\t\tgoto free_all;\n\t\tmemcpy(xbuf[1], c, c_size);\n\t\tsg_set_buf(&src_tab[2], xbuf[1], c_size);\n\t\takcipher_request_set_crypt(req, src_tab, NULL, m_size, c_size);\n\t} else {\n\t\tsg_init_one(&dst, outbuf_enc, out_len_max);\n\t\takcipher_request_set_crypt(req, src_tab, &dst, m_size,\n\t\t\t\t\t   out_len_max);\n\t}\n\takcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      crypto_req_done, &wait);\n\n\terr = crypto_wait_req(vecs->siggen_sigver_test ?\n\t\t\t       \n\t\t\t      crypto_akcipher_verify(req) :\n\t\t\t       \n\t\t\t      crypto_akcipher_encrypt(req), &wait);\n\tif (err) {\n\t\tpr_err(\"alg: akcipher: %s test failed. err %d\\n\", op, err);\n\t\tgoto free_all;\n\t}\n\tif (!vecs->siggen_sigver_test && c) {\n\t\tif (req->dst_len != c_size) {\n\t\t\tpr_err(\"alg: akcipher: %s test failed. Invalid output len\\n\",\n\t\t\t       op);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free_all;\n\t\t}\n\t\t \n\t\tif (memcmp(c, outbuf_enc, c_size) != 0) {\n\t\t\tpr_err(\"alg: akcipher: %s test failed. Invalid output\\n\",\n\t\t\t       op);\n\t\t\thexdump(outbuf_enc, c_size);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free_all;\n\t\t}\n\t}\n\n\t \n\tif (vecs->public_key_vec) {\n\t\terr = 0;\n\t\tgoto free_all;\n\t}\n\toutbuf_dec = kzalloc(out_len_max, GFP_KERNEL);\n\tif (!outbuf_dec) {\n\t\terr = -ENOMEM;\n\t\tgoto free_all;\n\t}\n\n\tif (!vecs->siggen_sigver_test && !c) {\n\t\tc = outbuf_enc;\n\t\tc_size = req->dst_len;\n\t}\n\n\terr = -E2BIG;\n\top = vecs->siggen_sigver_test ? \"sign\" : \"decrypt\";\n\tif (WARN_ON(c_size > PAGE_SIZE))\n\t\tgoto free_all;\n\tmemcpy(xbuf[0], c, c_size);\n\n\tsg_init_one(&src, xbuf[0], c_size);\n\tsg_init_one(&dst, outbuf_dec, out_len_max);\n\tcrypto_init_wait(&wait);\n\takcipher_request_set_crypt(req, &src, &dst, c_size, out_len_max);\n\n\terr = crypto_wait_req(vecs->siggen_sigver_test ?\n\t\t\t       \n\t\t\t      crypto_akcipher_sign(req) :\n\t\t\t       \n\t\t\t      crypto_akcipher_decrypt(req), &wait);\n\tif (err) {\n\t\tpr_err(\"alg: akcipher: %s test failed. err %d\\n\", op, err);\n\t\tgoto free_all;\n\t}\n\tout_len = req->dst_len;\n\tif (out_len < m_size) {\n\t\tpr_err(\"alg: akcipher: %s test failed. Invalid output len %u\\n\",\n\t\t       op, out_len);\n\t\terr = -EINVAL;\n\t\tgoto free_all;\n\t}\n\t \n\tif (memchr_inv(outbuf_dec, 0, out_len - m_size) ||\n\t    memcmp(m, outbuf_dec + out_len - m_size, m_size)) {\n\t\tpr_err(\"alg: akcipher: %s test failed. Invalid output\\n\", op);\n\t\thexdump(outbuf_dec, out_len);\n\t\terr = -EINVAL;\n\t}\nfree_all:\n\tkfree(outbuf_dec);\n\tkfree(outbuf_enc);\nfree_key:\n\tkfree(key);\nfree_req:\n\takcipher_request_free(req);\nfree_xbuf:\n\ttestmgr_free_buf(xbuf);\n\treturn err;\n}\n\nstatic int test_akcipher(struct crypto_akcipher *tfm, const char *alg,\n\t\t\t const struct akcipher_testvec *vecs,\n\t\t\t unsigned int tcount)\n{\n\tconst char *algo =\n\t\tcrypto_tfm_alg_driver_name(crypto_akcipher_tfm(tfm));\n\tint ret, i;\n\n\tfor (i = 0; i < tcount; i++) {\n\t\tret = test_akcipher_one(tfm, vecs++);\n\t\tif (!ret)\n\t\t\tcontinue;\n\n\t\tpr_err(\"alg: akcipher: test %d failed for %s, err=%d\\n\",\n\t\t       i + 1, algo, ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int alg_test_akcipher(const struct alg_test_desc *desc,\n\t\t\t     const char *driver, u32 type, u32 mask)\n{\n\tstruct crypto_akcipher *tfm;\n\tint err = 0;\n\n\ttfm = crypto_alloc_akcipher(driver, type, mask);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"alg: akcipher: Failed to load tfm for %s: %ld\\n\",\n\t\t       driver, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tif (desc->suite.akcipher.vecs)\n\t\terr = test_akcipher(tfm, desc->alg, desc->suite.akcipher.vecs,\n\t\t\t\t    desc->suite.akcipher.count);\n\n\tcrypto_free_akcipher(tfm);\n\treturn err;\n}\n\nstatic int alg_test_null(const struct alg_test_desc *desc,\n\t\t\t     const char *driver, u32 type, u32 mask)\n{\n\treturn 0;\n}\n\n#define ____VECS(tv)\t.vecs = tv, .count = ARRAY_SIZE(tv)\n#define __VECS(tv)\t{ ____VECS(tv) }\n\n \nstatic const struct alg_test_desc alg_test_descs[] = {\n\t{\n\t\t.alg = \"adiantum(xchacha12,aes)\",\n\t\t.generic_driver = \"adiantum(xchacha12-generic,aes-generic,nhpoly1305-generic)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(adiantum_xchacha12_aes_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"adiantum(xchacha20,aes)\",\n\t\t.generic_driver = \"adiantum(xchacha20-generic,aes-generic,nhpoly1305-generic)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(adiantum_xchacha20_aes_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"aegis128\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(aegis128_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ansi_cprng\",\n\t\t.test = alg_test_cprng,\n\t\t.suite = {\n\t\t\t.cprng = __VECS(ansi_cprng_aes_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(md5),ecb(cipher_null))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_md5_ecb_cipher_null_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha1),cbc(aes))\",\n\t\t.test = alg_test_aead,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha1_aes_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha1),cbc(des))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha1_des_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha1),cbc(des3_ede))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha1_des3_ede_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha1),ctr(aes))\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"authenc(hmac(sha1),ecb(cipher_null))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha1_ecb_cipher_null_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha1),rfc3686(ctr(aes)))\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"authenc(hmac(sha224),cbc(des))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha224_des_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha224),cbc(des3_ede))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha224_des3_ede_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha256),cbc(aes))\",\n\t\t.test = alg_test_aead,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha256_aes_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha256),cbc(des))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha256_des_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha256),cbc(des3_ede))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha256_des3_ede_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha256),ctr(aes))\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"authenc(hmac(sha256),rfc3686(ctr(aes)))\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"authenc(hmac(sha384),cbc(des))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha384_des_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha384),cbc(des3_ede))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha384_des3_ede_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha384),ctr(aes))\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"authenc(hmac(sha384),rfc3686(ctr(aes)))\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"authenc(hmac(sha512),cbc(aes))\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha512_aes_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha512),cbc(des))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha512_des_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha512),cbc(des3_ede))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(hmac_sha512_des3_ede_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"authenc(hmac(sha512),ctr(aes))\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"authenc(hmac(sha512),rfc3686(ctr(aes)))\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"blake2b-160\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 0,\n\t\t.suite = {\n\t\t\t.hash = __VECS(blake2b_160_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"blake2b-256\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 0,\n\t\t.suite = {\n\t\t\t.hash = __VECS(blake2b_256_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"blake2b-384\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 0,\n\t\t.suite = {\n\t\t\t.hash = __VECS(blake2b_384_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"blake2b-512\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 0,\n\t\t.suite = {\n\t\t\t.hash = __VECS(blake2b_512_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"cbc(aes)\",\n\t\t.test = alg_test_skcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_cbc_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cbc(anubis)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(anubis_cbc_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cbc(aria)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aria_cbc_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cbc(blowfish)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(bf_cbc_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cbc(camellia)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(camellia_cbc_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cbc(cast5)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(cast5_cbc_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cbc(cast6)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(cast6_cbc_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cbc(des)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(des_cbc_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cbc(des3_ede)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(des3_ede_cbc_tv_template)\n\t\t},\n\t}, {\n\t\t \n\t\t.alg = \"cbc(paes)\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t \n\t\t.alg = \"cbc(psm4)\",\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"cbc(serpent)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(serpent_cbc_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cbc(sm4)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(sm4_cbc_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"cbc(twofish)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(tf_cbc_tv_template)\n\t\t},\n\t}, {\n#if IS_ENABLED(CONFIG_CRYPTO_PAES_S390)\n\t\t.alg = \"cbc-paes-s390\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_cbc_tv_template)\n\t\t}\n\t}, {\n#endif\n\t\t.alg = \"cbcmac(aes)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(aes_cbcmac_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"cbcmac(sm4)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sm4_cbcmac_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ccm(aes)\",\n\t\t.generic_driver = \"ccm_base(ctr(aes-generic),cbcmac(aes-generic))\",\n\t\t.test = alg_test_aead,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.aead = {\n\t\t\t\t____VECS(aes_ccm_tv_template),\n\t\t\t\t.einval_allowed = 1,\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"ccm(sm4)\",\n\t\t.generic_driver = \"ccm_base(ctr(sm4-generic),cbcmac(sm4-generic))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = {\n\t\t\t\t____VECS(sm4_ccm_tv_template),\n\t\t\t\t.einval_allowed = 1,\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"cfb(aes)\",\n\t\t.test = alg_test_skcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_cfb_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cfb(aria)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aria_cfb_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cfb(sm4)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(sm4_cfb_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"chacha20\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(chacha20_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"cmac(aes)\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(aes_cmac128_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"cmac(camellia)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(camellia_cmac128_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"cmac(des3_ede)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(des3_ede_cmac64_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"cmac(sm4)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sm4_cmac128_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"compress_null\",\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"crc32\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(crc32_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"crc32c\",\n\t\t.test = alg_test_crc32c,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(crc32c_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"crc64-rocksoft\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(crc64_rocksoft_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"crct10dif\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(crct10dif_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ctr(aes)\",\n\t\t.test = alg_test_skcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_ctr_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ctr(aria)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aria_ctr_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ctr(blowfish)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(bf_ctr_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ctr(camellia)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(camellia_ctr_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ctr(cast5)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(cast5_ctr_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ctr(cast6)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(cast6_ctr_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ctr(des)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(des_ctr_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ctr(des3_ede)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(des3_ede_ctr_tv_template)\n\t\t}\n\t}, {\n\t\t \n\t\t.alg = \"ctr(paes)\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\n\t\t \n\t\t.alg = \"ctr(psm4)\",\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"ctr(serpent)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(serpent_ctr_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ctr(sm4)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(sm4_ctr_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ctr(twofish)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(tf_ctr_tv_template)\n\t\t}\n\t}, {\n#if IS_ENABLED(CONFIG_CRYPTO_PAES_S390)\n\t\t.alg = \"ctr-paes-s390\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_ctr_tv_template)\n\t\t}\n\t}, {\n#endif\n\t\t.alg = \"cts(cbc(aes))\",\n\t\t.test = alg_test_skcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(cts_mode_tv_template)\n\t\t}\n\t}, {\n\t\t \n\t\t.alg = \"cts(cbc(paes))\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"cts(cbc(sm4))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(sm4_cts_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"curve25519\",\n\t\t.test = alg_test_kpp,\n\t\t.suite = {\n\t\t\t.kpp = __VECS(curve25519_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"deflate\",\n\t\t.test = alg_test_comp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.comp = {\n\t\t\t\t.comp = __VECS(deflate_comp_tv_template),\n\t\t\t\t.decomp = __VECS(deflate_decomp_tv_template)\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"dh\",\n\t\t.test = alg_test_kpp,\n\t\t.suite = {\n\t\t\t.kpp = __VECS(dh_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"digest_null\",\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_nopr_ctr_aes128\",\n\t\t.test = alg_test_drbg,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.drbg = __VECS(drbg_nopr_ctr_aes128_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"drbg_nopr_ctr_aes192\",\n\t\t.test = alg_test_drbg,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.drbg = __VECS(drbg_nopr_ctr_aes192_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"drbg_nopr_ctr_aes256\",\n\t\t.test = alg_test_drbg,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.drbg = __VECS(drbg_nopr_ctr_aes256_tv_template)\n\t\t}\n\t}, {\n\t\t \n\t\t.alg = \"drbg_nopr_hmac_sha1\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_nopr_hmac_sha256\",\n\t\t.test = alg_test_drbg,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.drbg = __VECS(drbg_nopr_hmac_sha256_tv_template)\n\t\t}\n\t}, {\n\t\t \n\t\t.alg = \"drbg_nopr_hmac_sha384\",\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_nopr_hmac_sha512\",\n\t\t.test = alg_test_drbg,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.drbg = __VECS(drbg_nopr_hmac_sha512_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"drbg_nopr_sha1\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_nopr_sha256\",\n\t\t.test = alg_test_drbg,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.drbg = __VECS(drbg_nopr_sha256_tv_template)\n\t\t}\n\t}, {\n\t\t \n\t\t.alg = \"drbg_nopr_sha384\",\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_nopr_sha512\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_pr_ctr_aes128\",\n\t\t.test = alg_test_drbg,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.drbg = __VECS(drbg_pr_ctr_aes128_tv_template)\n\t\t}\n\t}, {\n\t\t \n\t\t.alg = \"drbg_pr_ctr_aes192\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_pr_ctr_aes256\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_pr_hmac_sha1\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_pr_hmac_sha256\",\n\t\t.test = alg_test_drbg,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.drbg = __VECS(drbg_pr_hmac_sha256_tv_template)\n\t\t}\n\t}, {\n\t\t \n\t\t.alg = \"drbg_pr_hmac_sha384\",\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_pr_hmac_sha512\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"drbg_pr_sha1\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_pr_sha256\",\n\t\t.test = alg_test_drbg,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.drbg = __VECS(drbg_pr_sha256_tv_template)\n\t\t}\n\t}, {\n\t\t \n\t\t.alg = \"drbg_pr_sha384\",\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"drbg_pr_sha512\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"ecb(aes)\",\n\t\t.test = alg_test_skcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(anubis)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(anubis_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(arc4)\",\n\t\t.generic_driver = \"ecb(arc4)-generic\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(arc4_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(aria)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aria_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(blowfish)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(bf_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(camellia)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(camellia_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(cast5)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(cast5_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(cast6)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(cast6_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(cipher_null)\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"ecb(des)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(des_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(des3_ede)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(des3_ede_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(fcrypt)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = {\n\t\t\t\t.vecs = fcrypt_pcbc_tv_template,\n\t\t\t\t.count = 1\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(khazad)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(khazad_tv_template)\n\t\t}\n\t}, {\n\t\t \n\t\t.alg = \"ecb(paes)\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"ecb(seed)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(seed_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(serpent)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(serpent_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(sm4)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(sm4_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(tea)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(tea_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(twofish)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(tf_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(xeta)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(xeta_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecb(xtea)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(xtea_tv_template)\n\t\t}\n\t}, {\n#if IS_ENABLED(CONFIG_CRYPTO_PAES_S390)\n\t\t.alg = \"ecb-paes-s390\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_tv_template)\n\t\t}\n\t}, {\n#endif\n\t\t.alg = \"ecdh-nist-p192\",\n\t\t.test = alg_test_kpp,\n\t\t.suite = {\n\t\t\t.kpp = __VECS(ecdh_p192_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecdh-nist-p256\",\n\t\t.test = alg_test_kpp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.kpp = __VECS(ecdh_p256_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecdh-nist-p384\",\n\t\t.test = alg_test_kpp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.kpp = __VECS(ecdh_p384_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecdsa-nist-p192\",\n\t\t.test = alg_test_akcipher,\n\t\t.suite = {\n\t\t\t.akcipher = __VECS(ecdsa_nist_p192_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecdsa-nist-p256\",\n\t\t.test = alg_test_akcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.akcipher = __VECS(ecdsa_nist_p256_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecdsa-nist-p384\",\n\t\t.test = alg_test_akcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.akcipher = __VECS(ecdsa_nist_p384_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ecrdsa\",\n\t\t.test = alg_test_akcipher,\n\t\t.suite = {\n\t\t\t.akcipher = __VECS(ecrdsa_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"essiv(authenc(hmac(sha256),cbc(aes)),sha256)\",\n\t\t.test = alg_test_aead,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.aead = __VECS(essiv_hmac_sha256_aes_cbc_tv_temp)\n\t\t}\n\t}, {\n\t\t.alg = \"essiv(cbc(aes),sha256)\",\n\t\t.test = alg_test_skcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(essiv_aes_cbc_tv_template)\n\t\t}\n\t}, {\n#if IS_ENABLED(CONFIG_CRYPTO_DH_RFC7919_GROUPS)\n\t\t.alg = \"ffdhe2048(dh)\",\n\t\t.test = alg_test_kpp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.kpp = __VECS(ffdhe2048_dh_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ffdhe3072(dh)\",\n\t\t.test = alg_test_kpp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.kpp = __VECS(ffdhe3072_dh_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ffdhe4096(dh)\",\n\t\t.test = alg_test_kpp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.kpp = __VECS(ffdhe4096_dh_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ffdhe6144(dh)\",\n\t\t.test = alg_test_kpp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.kpp = __VECS(ffdhe6144_dh_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ffdhe8192(dh)\",\n\t\t.test = alg_test_kpp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.kpp = __VECS(ffdhe8192_dh_tv_template)\n\t\t}\n\t}, {\n#endif  \n\t\t.alg = \"gcm(aes)\",\n\t\t.generic_driver = \"gcm_base(ctr(aes-generic),ghash-generic)\",\n\t\t.test = alg_test_aead,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.aead = __VECS(aes_gcm_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"gcm(aria)\",\n\t\t.generic_driver = \"gcm_base(ctr(aria-generic),ghash-generic)\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(aria_gcm_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"gcm(sm4)\",\n\t\t.generic_driver = \"gcm_base(ctr(sm4-generic),ghash-generic)\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(sm4_gcm_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ghash\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(ghash_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hctr2(aes)\",\n\t\t.generic_driver =\n\t\t    \"hctr2_base(xctr(aes-generic),polyval-generic)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_hctr2_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(md5)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_md5_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(rmd160)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_rmd160_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(sha1)\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_sha1_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(sha224)\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_sha224_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(sha256)\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_sha256_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(sha3-224)\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_sha3_224_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(sha3-256)\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_sha3_256_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(sha3-384)\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_sha3_384_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(sha3-512)\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_sha3_512_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(sha384)\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_sha384_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(sha512)\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_sha512_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(sm3)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_sm3_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(streebog256)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_streebog256_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"hmac(streebog512)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(hmac_streebog512_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"jitterentropy_rng\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_null,\n\t}, {\n\t\t.alg = \"kw(aes)\",\n\t\t.test = alg_test_skcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_kw_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"lrw(aes)\",\n\t\t.generic_driver = \"lrw(ecb(aes-generic))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_lrw_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"lrw(camellia)\",\n\t\t.generic_driver = \"lrw(ecb(camellia-generic))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(camellia_lrw_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"lrw(cast6)\",\n\t\t.generic_driver = \"lrw(ecb(cast6-generic))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(cast6_lrw_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"lrw(serpent)\",\n\t\t.generic_driver = \"lrw(ecb(serpent-generic))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(serpent_lrw_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"lrw(twofish)\",\n\t\t.generic_driver = \"lrw(ecb(twofish-generic))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(tf_lrw_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"lz4\",\n\t\t.test = alg_test_comp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.comp = {\n\t\t\t\t.comp = __VECS(lz4_comp_tv_template),\n\t\t\t\t.decomp = __VECS(lz4_decomp_tv_template)\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"lz4hc\",\n\t\t.test = alg_test_comp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.comp = {\n\t\t\t\t.comp = __VECS(lz4hc_comp_tv_template),\n\t\t\t\t.decomp = __VECS(lz4hc_decomp_tv_template)\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"lzo\",\n\t\t.test = alg_test_comp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.comp = {\n\t\t\t\t.comp = __VECS(lzo_comp_tv_template),\n\t\t\t\t.decomp = __VECS(lzo_decomp_tv_template)\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"lzo-rle\",\n\t\t.test = alg_test_comp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.comp = {\n\t\t\t\t.comp = __VECS(lzorle_comp_tv_template),\n\t\t\t\t.decomp = __VECS(lzorle_decomp_tv_template)\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"md4\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(md4_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"md5\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(md5_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"michael_mic\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(michael_mic_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"nhpoly1305\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(nhpoly1305_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"ofb(aes)\",\n\t\t.test = alg_test_skcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_ofb_tv_template)\n\t\t}\n\t}, {\n\t\t \n\t\t.alg = \"ofb(paes)\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"ofb(sm4)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(sm4_ofb_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"pcbc(fcrypt)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(fcrypt_pcbc_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"pkcs1pad(rsa,sha224)\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"pkcs1pad(rsa,sha256)\",\n\t\t.test = alg_test_akcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.akcipher = __VECS(pkcs1pad_rsa_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"pkcs1pad(rsa,sha384)\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"pkcs1pad(rsa,sha512)\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"poly1305\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(poly1305_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"polyval\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(polyval_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"rfc3686(ctr(aes))\",\n\t\t.test = alg_test_skcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_ctr_rfc3686_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"rfc3686(ctr(sm4))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(sm4_ctr_rfc3686_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"rfc4106(gcm(aes))\",\n\t\t.generic_driver = \"rfc4106(gcm_base(ctr(aes-generic),ghash-generic))\",\n\t\t.test = alg_test_aead,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.aead = {\n\t\t\t\t____VECS(aes_gcm_rfc4106_tv_template),\n\t\t\t\t.einval_allowed = 1,\n\t\t\t\t.aad_iv = 1,\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"rfc4309(ccm(aes))\",\n\t\t.generic_driver = \"rfc4309(ccm_base(ctr(aes-generic),cbcmac(aes-generic)))\",\n\t\t.test = alg_test_aead,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.aead = {\n\t\t\t\t____VECS(aes_ccm_rfc4309_tv_template),\n\t\t\t\t.einval_allowed = 1,\n\t\t\t\t.aad_iv = 1,\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"rfc4543(gcm(aes))\",\n\t\t.generic_driver = \"rfc4543(gcm_base(ctr(aes-generic),ghash-generic))\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = {\n\t\t\t\t____VECS(aes_gcm_rfc4543_tv_template),\n\t\t\t\t.einval_allowed = 1,\n\t\t\t\t.aad_iv = 1,\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"rfc7539(chacha20,poly1305)\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = __VECS(rfc7539_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"rfc7539esp(chacha20,poly1305)\",\n\t\t.test = alg_test_aead,\n\t\t.suite = {\n\t\t\t.aead = {\n\t\t\t\t____VECS(rfc7539esp_tv_template),\n\t\t\t\t.einval_allowed = 1,\n\t\t\t\t.aad_iv = 1,\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"rmd160\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(rmd160_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"rsa\",\n\t\t.test = alg_test_akcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.akcipher = __VECS(rsa_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"sha1\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sha1_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"sha224\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sha224_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"sha256\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sha256_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"sha3-224\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sha3_224_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"sha3-256\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sha3_256_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"sha3-384\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sha3_384_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"sha3-512\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sha3_512_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"sha384\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sha384_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"sha512\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sha512_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"sm2\",\n\t\t.test = alg_test_akcipher,\n\t\t.suite = {\n\t\t\t.akcipher = __VECS(sm2_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"sm3\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sm3_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"streebog256\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(streebog256_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"streebog512\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(streebog512_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"vmac64(aes)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(vmac64_aes_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"wp256\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(wp256_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"wp384\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(wp384_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"wp512\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(wp512_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"xcbc(aes)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(aes_xcbc128_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"xcbc(sm4)\",\n\t\t.test = alg_test_hash,\n\t\t.suite = {\n\t\t\t.hash = __VECS(sm4_xcbc128_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"xchacha12\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(xchacha12_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"xchacha20\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(xchacha20_tv_template)\n\t\t},\n\t}, {\n\t\t.alg = \"xctr(aes)\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_xctr_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"xts(aes)\",\n\t\t.generic_driver = \"xts(ecb(aes-generic))\",\n\t\t.test = alg_test_skcipher,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_xts_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"xts(camellia)\",\n\t\t.generic_driver = \"xts(ecb(camellia-generic))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(camellia_xts_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"xts(cast6)\",\n\t\t.generic_driver = \"xts(ecb(cast6-generic))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(cast6_xts_tv_template)\n\t\t}\n\t}, {\n\t\t \n\t\t.alg = \"xts(paes)\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"xts(serpent)\",\n\t\t.generic_driver = \"xts(ecb(serpent-generic))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(serpent_xts_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"xts(sm4)\",\n\t\t.generic_driver = \"xts(ecb(sm4-generic))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(sm4_xts_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"xts(twofish)\",\n\t\t.generic_driver = \"xts(ecb(twofish-generic))\",\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(tf_xts_tv_template)\n\t\t}\n\t}, {\n#if IS_ENABLED(CONFIG_CRYPTO_PAES_S390)\n\t\t.alg = \"xts-paes-s390\",\n\t\t.fips_allowed = 1,\n\t\t.test = alg_test_skcipher,\n\t\t.suite = {\n\t\t\t.cipher = __VECS(aes_xts_tv_template)\n\t\t}\n\t}, {\n#endif\n\t\t.alg = \"xts4096(paes)\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"xts512(paes)\",\n\t\t.test = alg_test_null,\n\t\t.fips_allowed = 1,\n\t}, {\n\t\t.alg = \"xxhash64\",\n\t\t.test = alg_test_hash,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.hash = __VECS(xxhash64_tv_template)\n\t\t}\n\t}, {\n\t\t.alg = \"zlib-deflate\",\n\t\t.test = alg_test_comp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.comp = {\n\t\t\t\t.comp = __VECS(zlib_deflate_comp_tv_template),\n\t\t\t\t.decomp = __VECS(zlib_deflate_decomp_tv_template)\n\t\t\t}\n\t\t}\n\t}, {\n\t\t.alg = \"zstd\",\n\t\t.test = alg_test_comp,\n\t\t.fips_allowed = 1,\n\t\t.suite = {\n\t\t\t.comp = {\n\t\t\t\t.comp = __VECS(zstd_comp_tv_template),\n\t\t\t\t.decomp = __VECS(zstd_decomp_tv_template)\n\t\t\t}\n\t\t}\n\t}\n};\n\nstatic void alg_check_test_descs_order(void)\n{\n\tint i;\n\n\tfor (i = 1; i < ARRAY_SIZE(alg_test_descs); i++) {\n\t\tint diff = strcmp(alg_test_descs[i - 1].alg,\n\t\t\t\t  alg_test_descs[i].alg);\n\n\t\tif (WARN_ON(diff > 0)) {\n\t\t\tpr_warn(\"testmgr: alg_test_descs entries in wrong order: '%s' before '%s'\\n\",\n\t\t\t\talg_test_descs[i - 1].alg,\n\t\t\t\talg_test_descs[i].alg);\n\t\t}\n\n\t\tif (WARN_ON(diff == 0)) {\n\t\t\tpr_warn(\"testmgr: duplicate alg_test_descs entry: '%s'\\n\",\n\t\t\t\talg_test_descs[i].alg);\n\t\t}\n\t}\n}\n\nstatic void alg_check_testvec_configs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_cipher_testvec_configs); i++)\n\t\tWARN_ON(!valid_testvec_config(\n\t\t\t\t&default_cipher_testvec_configs[i]));\n\n\tfor (i = 0; i < ARRAY_SIZE(default_hash_testvec_configs); i++)\n\t\tWARN_ON(!valid_testvec_config(\n\t\t\t\t&default_hash_testvec_configs[i]));\n}\n\nstatic void testmgr_onetime_init(void)\n{\n\talg_check_test_descs_order();\n\talg_check_testvec_configs();\n\n#ifdef CONFIG_CRYPTO_MANAGER_EXTRA_TESTS\n\tpr_warn(\"alg: extra crypto tests enabled.  This is intended for developer use only.\\n\");\n#endif\n}\n\nstatic int alg_find_test(const char *alg)\n{\n\tint start = 0;\n\tint end = ARRAY_SIZE(alg_test_descs);\n\n\twhile (start < end) {\n\t\tint i = (start + end) / 2;\n\t\tint diff = strcmp(alg_test_descs[i].alg, alg);\n\n\t\tif (diff > 0) {\n\t\t\tend = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (diff < 0) {\n\t\t\tstart = i + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nstatic int alg_fips_disabled(const char *driver, const char *alg)\n{\n\tpr_info(\"alg: %s (%s) is disabled due to FIPS\\n\", alg, driver);\n\n\treturn -ECANCELED;\n}\n\nint alg_test(const char *driver, const char *alg, u32 type, u32 mask)\n{\n\tint i;\n\tint j;\n\tint rc;\n\n\tif (!fips_enabled && notests) {\n\t\tprintk_once(KERN_INFO \"alg: self-tests disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tDO_ONCE(testmgr_onetime_init);\n\n\tif ((type & CRYPTO_ALG_TYPE_MASK) == CRYPTO_ALG_TYPE_CIPHER) {\n\t\tchar nalg[CRYPTO_MAX_ALG_NAME];\n\n\t\tif (snprintf(nalg, sizeof(nalg), \"ecb(%s)\", alg) >=\n\t\t    sizeof(nalg))\n\t\t\treturn -ENAMETOOLONG;\n\n\t\ti = alg_find_test(nalg);\n\t\tif (i < 0)\n\t\t\tgoto notest;\n\n\t\tif (fips_enabled && !alg_test_descs[i].fips_allowed)\n\t\t\tgoto non_fips_alg;\n\n\t\trc = alg_test_cipher(alg_test_descs + i, driver, type, mask);\n\t\tgoto test_done;\n\t}\n\n\ti = alg_find_test(alg);\n\tj = alg_find_test(driver);\n\tif (i < 0 && j < 0)\n\t\tgoto notest;\n\n\tif (fips_enabled) {\n\t\tif (j >= 0 && !alg_test_descs[j].fips_allowed)\n\t\t\treturn -EINVAL;\n\n\t\tif (i >= 0 && !alg_test_descs[i].fips_allowed)\n\t\t\tgoto non_fips_alg;\n\t}\n\n\trc = 0;\n\tif (i >= 0)\n\t\trc |= alg_test_descs[i].test(alg_test_descs + i, driver,\n\t\t\t\t\t     type, mask);\n\tif (j >= 0 && j != i)\n\t\trc |= alg_test_descs[j].test(alg_test_descs + j, driver,\n\t\t\t\t\t     type, mask);\n\ntest_done:\n\tif (rc) {\n\t\tif (fips_enabled || panic_on_fail) {\n\t\t\tfips_fail_notify();\n\t\t\tpanic(\"alg: self-tests for %s (%s) failed in %s mode!\\n\",\n\t\t\t      driver, alg,\n\t\t\t      fips_enabled ? \"fips\" : \"panic_on_fail\");\n\t\t}\n\t\tpr_warn(\"alg: self-tests for %s using %s failed (rc=%d)\",\n\t\t\talg, driver, rc);\n\t\tWARN(rc != -ENOENT,\n\t\t     \"alg: self-tests for %s using %s failed (rc=%d)\",\n\t\t     alg, driver, rc);\n\t} else {\n\t\tif (fips_enabled)\n\t\t\tpr_info(\"alg: self-tests for %s (%s) passed\\n\",\n\t\t\t\tdriver, alg);\n\t}\n\n\treturn rc;\n\nnotest:\n\tprintk(KERN_INFO \"alg: No test for %s (%s)\\n\", alg, driver);\n\n\tif (type & CRYPTO_ALG_FIPS_INTERNAL)\n\t\treturn alg_fips_disabled(driver, alg);\n\n\treturn 0;\nnon_fips_alg:\n\treturn alg_fips_disabled(driver, alg);\n}\n\n#endif  \n\nEXPORT_SYMBOL_GPL(alg_test);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}