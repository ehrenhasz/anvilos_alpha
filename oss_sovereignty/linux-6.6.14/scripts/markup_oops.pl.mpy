{
  "module_name": "markup_oops.pl",
  "hash_id": "9cd9d4f4111cb192b582b2026476ced516db824a90a340d4070d0adb1a0f054a",
  "original_prompt": "Ingested from linux-6.6.14/scripts/markup_oops.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0-only\n\nuse File::Basename;\nuse Math::BigInt;\nuse Getopt::Long;\n\n# Copyright 2008, Intel Corporation\n#\n# This file is part of the Linux kernel\n#\n# Authors:\n# \tArjan van de Ven <arjan@linux.intel.com>\n\n\nmy $cross_compile = \"\";\nmy $vmlinux_name = \"\";\nmy $modulefile = \"\";\n\n# Get options\nGetopt::Long::GetOptions(\n\t'cross-compile|c=s'\t=> \\$cross_compile,\n\t'module|m=s'\t\t=> \\$modulefile,\n\t'help|h'\t\t=> \\&usage,\n) || usage ();\nmy $vmlinux_name = $ARGV[0];\nif (!defined($vmlinux_name)) {\n\tmy $kerver = `uname -r`;\n\tchomp($kerver);\n\t$vmlinux_name = \"/lib/modules/$kerver/build/vmlinux\";\n\tprint \"No vmlinux specified, assuming $vmlinux_name\\n\";\n}\nmy $filename = $vmlinux_name;\n\n# Parse the oops to find the EIP value\n\nmy $target = \"0\";\nmy $function;\nmy $module = \"\";\nmy $func_offset = 0;\nmy $vmaoffset = 0;\n\nmy %regs;\n\n\nsub parse_x86_regs\n{\n\tmy ($line) = @_;\n\tif ($line =~ /EAX: ([0-9a-f]+) EBX: ([0-9a-f]+) ECX: ([0-9a-f]+) EDX: ([0-9a-f]+)/) {\n\t\t$regs{\"%eax\"} = $1;\n\t\t$regs{\"%ebx\"} = $2;\n\t\t$regs{\"%ecx\"} = $3;\n\t\t$regs{\"%edx\"} = $4;\n\t}\n\tif ($line =~ /ESI: ([0-9a-f]+) EDI: ([0-9a-f]+) EBP: ([0-9a-f]+) ESP: ([0-9a-f]+)/) {\n\t\t$regs{\"%esi\"} = $1;\n\t\t$regs{\"%edi\"} = $2;\n\t\t$regs{\"%esp\"} = $4;\n\t}\n\tif ($line =~ /RAX: ([0-9a-f]+) RBX: ([0-9a-f]+) RCX: ([0-9a-f]+)/) {\n\t\t$regs{\"%eax\"} = $1;\n\t\t$regs{\"%ebx\"} = $2;\n\t\t$regs{\"%ecx\"} = $3;\n\t}\n\tif ($line =~ /RDX: ([0-9a-f]+) RSI: ([0-9a-f]+) RDI: ([0-9a-f]+)/) {\n\t\t$regs{\"%edx\"} = $1;\n\t\t$regs{\"%esi\"} = $2;\n\t\t$regs{\"%edi\"} = $3;\n\t}\n\tif ($line =~ /RBP: ([0-9a-f]+) R08: ([0-9a-f]+) R09: ([0-9a-f]+)/) {\n\t\t$regs{\"%r08\"} = $2;\n\t\t$regs{\"%r09\"} = $3;\n\t}\n\tif ($line =~ /R10: ([0-9a-f]+) R11: ([0-9a-f]+) R12: ([0-9a-f]+)/) {\n\t\t$regs{\"%r10\"} = $1;\n\t\t$regs{\"%r11\"} = $2;\n\t\t$regs{\"%r12\"} = $3;\n\t}\n\tif ($line =~ /R13: ([0-9a-f]+) R14: ([0-9a-f]+) R15: ([0-9a-f]+)/) {\n\t\t$regs{\"%r13\"} = $1;\n\t\t$regs{\"%r14\"} = $2;\n\t\t$regs{\"%r15\"} = $3;\n\t}\n}\n\nsub reg_name\n{\n\tmy ($reg) = @_;\n\t$reg =~ s/r(.)x/e\\1x/;\n\t$reg =~ s/r(.)i/e\\1i/;\n\t$reg =~ s/r(.)p/e\\1p/;\n\treturn $reg;\n}\n\nsub process_x86_regs\n{\n\tmy ($line, $cntr) = @_;\n\tmy $str = \"\";\n\tif (length($line) < 40) {\n\t\treturn \"\"; # not an asm istruction\n\t}\n\n\t# find the arguments to the instruction\n\tif ($line =~ /([0-9a-zA-Z\\,\\%\\(\\)\\-\\+]+)$/) {\n\t\t$lastword = $1;\n\t} else {\n\t\treturn \"\";\n\t}\n\n\t# we need to find the registers that get clobbered,\n\t# since their value is no longer relevant for previous\n\t# instructions in the stream.\n\n\t$clobber = $lastword;\n\t# first, remove all memory operands, they're read only\n\t$clobber =~ s/\\([a-z0-9\\%\\,]+\\)//g;\n\t# then, remove everything before the comma, thats the read part\n\t$clobber =~ s/.*\\,//g;\n\n\t# if this is the instruction that faulted, we haven't actually done\n\t# the write yet... nothing is clobbered.\n\tif ($cntr == 0) {\n\t\t$clobber = \"\";\n\t}\n\n\tforeach $reg (keys(%regs)) {\n\t\tmy $clobberprime = reg_name($clobber);\n\t\tmy $lastwordprime = reg_name($lastword);\n\t\tmy $val = $regs{$reg};\n\t\tif ($val =~ /^[0]+$/) {\n\t\t\t$val = \"0\";\n\t\t} else {\n\t\t\t$val =~ s/^0*//;\n\t\t}\n\n\t\t# first check if we're clobbering this register; if we do\n\t\t# we print it with a =>, and then delete its value\n\t\tif ($clobber =~ /$reg/ || $clobberprime =~ /$reg/) {\n\t\t\tif (length($val) > 0) {\n\t\t\t\t$str = $str . \" $reg => $val \";\n\t\t\t}\n\t\t\t$regs{$reg} = \"\";\n\t\t\t$val = \"\";\n\t\t}\n\t\t# now check if we're reading this register\n\t\tif ($lastword =~ /$reg/ || $lastwordprime =~ /$reg/) {\n\t\t\tif (length($val) > 0) {\n\t\t\t\t$str = $str . \" $reg = $val \";\n\t\t\t}\n\t\t}\n\t}\n\treturn $str;\n}\n\n# parse the oops\nwhile (<STDIN>) {\n\tmy $line = $_;\n\tif ($line =~ /EIP: 0060:\\[\\<([a-z0-9]+)\\>\\]/) {\n\t\t$target = $1;\n\t}\n\tif ($line =~ /RIP: 0010:\\[\\<([a-z0-9]+)\\>\\]/) {\n\t\t$target = $1;\n\t}\n\tif ($line =~ /EIP is at ([a-zA-Z0-9\\_]+)\\+0x([0-9a-f]+)\\/0x[a-f0-9]/) {\n\t\t$function = $1;\n\t\t$func_offset = $2;\n\t}\n\tif ($line =~ /RIP: 0010:\\[\\<[0-9a-f]+\\>\\]  \\[\\<[0-9a-f]+\\>\\] ([a-zA-Z0-9\\_]+)\\+0x([0-9a-f]+)\\/0x[a-f0-9]/) {\n\t\t$function = $1;\n\t\t$func_offset = $2;\n\t}\n\n\t# check if it's a module\n\tif ($line =~ /EIP is at ([a-zA-Z0-9\\_]+)\\+(0x[0-9a-f]+)\\/0x[a-f0-9]+\\W\\[([a-zA-Z0-9\\_\\-]+)\\]/) {\n\t\t$module = $3;\n\t}\n\tif ($line =~ /RIP: 0010:\\[\\<[0-9a-f]+\\>\\]  \\[\\<[0-9a-f]+\\>\\] ([a-zA-Z0-9\\_]+)\\+(0x[0-9a-f]+)\\/0x[a-f0-9]+\\W\\[([a-zA-Z0-9\\_\\-]+)\\]/) {\n\t\t$module = $3;\n\t}\n\tparse_x86_regs($line);\n}\n\nmy $decodestart = Math::BigInt->from_hex(\"0x$target\") - Math::BigInt->from_hex(\"0x$func_offset\");\nmy $decodestop = Math::BigInt->from_hex(\"0x$target\") + 8192;\nif ($target eq \"0\") {\n\tprint \"No oops found!\\n\";\n\tusage();\n}\n\n# if it's a module, we need to find the .ko file and calculate a load offset\nif ($module ne \"\") {\n\tif ($modulefile eq \"\") {\n\t\t$modulefile = `modinfo -F filename $module`;\n\t\tchomp($modulefile);\n\t}\n\t$filename = $modulefile;\n\tif ($filename eq \"\") {\n\t\tprint \"Module .ko file for $module not found. Aborting\\n\";\n\t\texit;\n\t}\n\t# ok so we found the module, now we need to calculate the vma offset\n\topen(FILE, $cross_compile.\"objdump -dS $filename |\") || die \"Cannot start objdump\";\n\twhile (<FILE>) {\n\t\tif ($_ =~ /^([0-9a-f]+) \\<$function\\>\\:/) {\n\t\t\tmy $fu = $1;\n\t\t\t$vmaoffset = Math::BigInt->from_hex(\"0x$target\") - Math::BigInt->from_hex(\"0x$fu\") - Math::BigInt->from_hex(\"0x$func_offset\");\n\t\t}\n\t}\n\tclose(FILE);\n}\n\nmy $counter = 0;\nmy $state   = 0;\nmy $center  = -1;\nmy @lines;\nmy @reglines;\n\nsub InRange {\n\tmy ($address, $target) = @_;\n\tmy $ad = \"0x\".$address;\n\tmy $ta = \"0x\".$target;\n\tmy $delta = Math::BigInt->from_hex($ad) - Math::BigInt->from_hex($ta);\n\n\tif (($delta > -4096) && ($delta < 4096)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\n\n# first, parse the input into the lines array, but to keep size down,\n# we only do this for 4Kb around the sweet spot\n\nopen(FILE, $cross_compile.\"objdump -dS --adjust-vma=$vmaoffset --start-address=$decodestart --stop-address=$decodestop $filename |\") || die \"Cannot start objdump\";\n\nwhile (<FILE>) {\n\tmy $line = $_;\n\tchomp($line);\n\tif ($state == 0) {\n\t\tif ($line =~ /^([a-f0-9]+)\\:/) {\n\t\t\tif (InRange($1, $target)) {\n\t\t\t\t$state = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif ($state == 1) {\n\t\tif ($line =~ /^([a-f0-9][a-f0-9][a-f0-9][a-f0-9][a-f0-9][a-f0-9]+)\\:/) {\n\t\t\tmy $val = $1;\n\t\t\tif (!InRange($val, $target)) {\n\t\t\t\tlast;\n\t\t\t}\n\t\t\tif ($val eq $target) {\n\t\t\t\t$center = $counter;\n\t\t\t}\n\t\t}\n\t\t$lines[$counter] = $line;\n\n\t\t$counter = $counter + 1;\n\t}\n}\n\nclose(FILE);\n\nif ($counter == 0) {\n\tprint \"No matching code found \\n\";\n\texit;\n}\n\nif ($center == -1) {\n\tprint \"No matching code found \\n\";\n\texit;\n}\n\nmy $start;\nmy $finish;\nmy $codelines = 0;\nmy $binarylines = 0;\n# now we go up and down in the array to find how much we want to print\n\n$start = $center;\n\nwhile ($start > 1) {\n\t$start = $start - 1;\n\tmy $line = $lines[$start];\n\tif ($line =~ /^([a-f0-9]+)\\:/) {\n\t\t$binarylines = $binarylines + 1;\n\t} else {\n\t\t$codelines = $codelines + 1;\n\t}\n\tif ($codelines > 10) {\n\t\tlast;\n\t}\n\tif ($binarylines > 20) {\n\t\tlast;\n\t}\n}\n\n\n$finish = $center;\n$codelines = 0;\n$binarylines = 0;\nwhile ($finish < $counter) {\n\t$finish = $finish + 1;\n\tmy $line = $lines[$finish];\n\tif ($line =~ /^([a-f0-9]+)\\:/) {\n\t\t$binarylines = $binarylines + 1;\n\t} else {\n\t\t$codelines = $codelines + 1;\n\t}\n\tif ($codelines > 10) {\n\t\tlast;\n\t}\n\tif ($binarylines > 20) {\n\t\tlast;\n\t}\n}\n\n\nmy $i;\n\n\n# start annotating the registers in the asm.\n# this goes from the oopsing point back, so that the annotator\n# can track (opportunistically) which registers got written and\n# whos value no longer is relevant.\n\n$i = $center;\nwhile ($i >= $start) {\n\t$reglines[$i] = process_x86_regs($lines[$i], $center - $i);\n\t$i = $i - 1;\n}\n\n$i = $start;\nwhile ($i < $finish) {\n\tmy $line;\n\tif ($i == $center) {\n\t\t$line =  \"*$lines[$i] \";\n\t} else {\n\t\t$line =  \" $lines[$i] \";\n\t}\n\tprint $line;\n\tif (defined($reglines[$i]) && length($reglines[$i]) > 0) {\n\t\tmy $c = 60 - length($line);\n\t\twhile ($c > 0) { print \" \"; $c = $c - 1; };\n\t\tprint \"| $reglines[$i]\";\n\t}\n\tif ($i == $center) {\n\t\tprint \"<--- faulting instruction\";\n\t}\n\tprint \"\\n\";\n\t$i = $i +1;\n}\n\nsub usage {\n\tprint <<EOT;\nUsage:\n  dmesg | perl $0 [OPTION] [VMLINUX]\n\nOPTION:\n  -c, --cross-compile CROSS_COMPILE\tSpecify the prefix used for toolchain.\n  -m, --module MODULE_DIRNAME\t\tSpecify the module filename.\n  -h, --help\t\t\t\tHelp.\nEOT\n\texit;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}