{
  "module_name": "parse-maintainers.pl",
  "hash_id": "f17ca3099bf5cd36b7f62104c5c6a0e9b5fc96f583c4679132c0469c096cc50d",
  "original_prompt": "Ingested from linux-6.6.14/scripts/parse-maintainers.pl",
  "human_readable_source": "#!/usr/bin/perl -w\n# SPDX-License-Identifier: GPL-2.0\n\nuse strict;\nuse Getopt::Long qw(:config no_auto_abbrev);\n\nmy $input_file = \"MAINTAINERS\";\nmy $output_file = \"MAINTAINERS.new\";\nmy $output_section = \"SECTION.new\";\nmy $help = 0;\nmy $order = 0;\nmy $P = $0;\n\nif (!GetOptions(\n\t\t'input=s' => \\$input_file,\n\t\t'output=s' => \\$output_file,\n\t\t'section=s' => \\$output_section,\n\t\t'order!' => \\$order,\n\t\t'h|help|usage' => \\$help,\n\t    )) {\n    die \"$P: invalid argument - use --help if necessary\\n\";\n}\n\nif ($help != 0) {\n    usage();\n    exit 0;\n}\n\nsub usage {\n    print <<EOT;\nusage: $P [options] <pattern matching regexes>\n\n  --input => MAINTAINERS file to read (default: MAINTAINERS)\n  --output => sorted MAINTAINERS file to write (default: MAINTAINERS.new)\n  --section => new sorted MAINTAINERS file to write to (default: SECTION.new)\n  --order => Use the preferred section content output ordering (default: 0)\n    Preferred ordering of section output is:\n      M:  Person acting as a maintainer\n      R:  Person acting as a patch reviewer\n      L:  Mailing list where patches should be sent\n      S:  Maintenance status\n      W:  URI for general information\n      Q:  URI for patchwork tracking\n      B:  URI for bug tracking/submission\n      C:  URI for chat\n      P:  URI or file for subsystem specific coding styles\n      T:  SCM tree type and location\n      F:  File and directory pattern\n      X:  File and directory exclusion pattern\n      N:  File glob\n      K:  Keyword - patch content regex\n\nIf <pattern match regexes> exist, then the sections that match the\nregexes are not written to the output file but are written to the\nsection file.\n\nEOT\n}\n\n# sort comparison functions\nsub by_category($$) {\n    my ($a, $b) = @_;\n\n    $a = uc $a;\n    $b = uc $b;\n\n    # This always sorts last\n    $a =~ s/THE REST/ZZZZZZ/g;\n    $b =~ s/THE REST/ZZZZZZ/g;\n\n    return $a cmp $b;\n}\n\nsub by_pattern($$) {\n    my ($a, $b) = @_;\n    my $preferred_order = 'MRLSWQBCPTFXNK';\n\n    my $a1 = uc(substr($a, 0, 1));\n    my $b1 = uc(substr($b, 0, 1));\n\n    my $a_index = index($preferred_order, $a1);\n    my $b_index = index($preferred_order, $b1);\n\n    $a_index = 1000 if ($a_index == -1);\n    $b_index = 1000 if ($b_index == -1);\n\n    if (($a1 =~ /^F$/ && $b1 =~ /^F$/) ||\n\t($a1 =~ /^X$/ && $b1 =~ /^X$/)) {\n\treturn $a cmp $b;\n    }\n\n    if ($a_index < $b_index) {\n\treturn -1;\n    } elsif ($a_index == $b_index) {\n\treturn 0;\n    } else {\n\treturn 1;\n    }\n}\n\nsub trim {\n    my $s = shift;\n    $s =~ s/\\s+$//;\n    $s =~ s/^\\s+//;\n    return $s;\n}\n\nsub alpha_output {\n    my ($hashref, $filename) = (@_);\n\n    return if ! scalar(keys %$hashref);\n\n    open(my $file, '>', \"$filename\") or die \"$P: $filename: open failed - $!\\n\";\n    my $separator;\n    foreach my $key (sort by_category keys %$hashref) {\n\tif ($key eq \" \") {\n\t    print $file $$hashref{$key};\n\t} else {\n\t    if (! defined $separator) {\n\t\t$separator = \"\\n\";\n\t    } else {\n\t\tprint $file $separator;\n\t    }\n\t    print $file $key . \"\\n\";\n\t    if ($order) {\n\t\tforeach my $pattern (sort by_pattern split('\\n', %$hashref{$key})) {\n\t\t    print $file ($pattern . \"\\n\");\n\t\t}\n\t    } else {\n\t\tforeach my $pattern (split('\\n', %$hashref{$key})) {\n\t\t    print $file ($pattern . \"\\n\");\n\t\t}\n\t    }\n\t}\n    }\n    close($file);\n}\n\nsub file_input {\n    my ($hashref, $filename) = (@_);\n\n    my $lastline = \"\";\n    my $case = \" \";\n    $$hashref{$case} = \"\";\n\n    open(my $file, '<', \"$filename\") or die \"$P: $filename: open failed - $!\\n\";\n\n    while (<$file>) {\n        my $line = $_;\n\n        # Pattern line?\n        if ($line =~ m/^([A-Z]):\\s*(.*)/) {\n            $line = $1 . \":\\t\" . trim($2) . \"\\n\";\n            if ($lastline eq \"\") {\n                $$hashref{$case} = $$hashref{$case} . $line;\n                next;\n            }\n            $case = trim($lastline);\n            exists $$hashref{$case} and die \"Header '$case' already exists\";\n            $$hashref{$case} = $line;\n            $lastline = \"\";\n            next;\n        }\n\n        if ($case eq \" \") {\n            $$hashref{$case} = $$hashref{$case} . $lastline;\n            $lastline = $line;\n            next;\n        }\n        trim($lastline) eq \"\" or die (\"Odd non-pattern line '$lastline' for '$case'\");\n        $lastline = $line;\n    }\n    $$hashref{$case} = $$hashref{$case} . $lastline;\n    close($file);\n}\n\nmy %hash;\nmy %new_hash;\n\nfile_input(\\%hash, $input_file);\n\nforeach my $type (@ARGV) {\n    foreach my $key (keys %hash) {\n\tif ($key =~ /$type/ || $hash{$key} =~ /$type/) {\n\t    $new_hash{$key} = $hash{$key};\n\t    delete $hash{$key};\n\t}\n    }\n}\n\nalpha_output(\\%hash, $output_file);\nalpha_output(\\%new_hash, $output_section);\n\nexit(0);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}