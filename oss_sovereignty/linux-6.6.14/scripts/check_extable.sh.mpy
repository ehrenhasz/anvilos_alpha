{
  "module_name": "check_extable.sh",
  "hash_id": "9d910b324e38dc6f138238a53112fdc182d72e51815d257f77ebef5c258d9fe9",
  "original_prompt": "Ingested from linux-6.6.14/scripts/check_extable.sh",
  "human_readable_source": "#! /bin/bash\n# SPDX-License-Identifier: GPL-2.0\n# (c) 2015, Quentin Casasnovas <quentin.casasnovas@oracle.com>\n\nobj=$1\n\nfile ${obj} | grep -q ELF || (echo \"${obj} is not an ELF file.\" 1>&2 ; exit 0)\n\n# Bail out early if there isn't an __ex_table section in this object file.\nobjdump -hj __ex_table ${obj} 2> /dev/null > /dev/null\n[ $? -ne 0 ] && exit 0\n\nwhite_list=.text,.fixup\n\nsuspicious_relocs=$(objdump -rj __ex_table ${obj}  | tail -n +6 |\n\t\t\tgrep -v $(eval echo -e{${white_list}}) | awk '{print $3}')\n\n# No suspicious relocs in __ex_table, jobs a good'un\n[ -z \"${suspicious_relocs}\" ] && exit 0\n\n\n# After this point, something is seriously wrong since we just found out we\n# have some relocations in __ex_table which point to sections which aren't\n# white listed.  If you're adding a new section in the Linux kernel, and\n# you're expecting this section to contain code which can fault (i.e. the\n# __ex_table relocation to your new section is expected), simply add your\n# new section to the white_list variable above.  If not, you're probably\n# doing something wrong and the rest of this code is just trying to print\n# you more information about it.\n\nfunction find_section_offset_from_symbol()\n{\n    eval $(objdump -t ${obj} | grep ${1} | sed 's/\\([0-9a-f]\\+\\) .\\{7\\} \\([^ \\t]\\+\\).*/section=\"\\2\"; section_offset=\"0x\\1\" /')\n\n    # addr2line takes addresses in hexadecimal...\n    section_offset=$(printf \"0x%016x\" $(( ${section_offset} + $2 )) )\n}\n\nfunction find_symbol_and_offset_from_reloc()\n{\n    # Extract symbol and offset from the objdump output\n    eval $(echo $reloc | sed 's/\\([^+]\\+\\)+\\?\\(0x[0-9a-f]\\+\\)\\?/symbol=\"\\1\"; symbol_offset=\"\\2\"/')\n\n    # When the relocation points to the begining of a symbol or section, it\n    # won't print the offset since it is zero.\n    if [ -z \"${symbol_offset}\" ]; then\n\tsymbol_offset=0x0\n    fi\n}\n\nfunction find_alt_replacement_target()\n{\n    # The target of the .altinstr_replacement is the relocation just before\n    # the .altinstr_replacement one.\n    eval $(objdump -rj .altinstructions ${obj} | grep -B1 \"${section}+${section_offset}\" | head -n1 | awk '{print $3}' |\n\t   sed 's/\\([^+]\\+\\)+\\(0x[0-9a-f]\\+\\)/alt_target_section=\"\\1\"; alt_target_offset=\"\\2\"/')\n}\n\nfunction handle_alt_replacement_reloc()\n{\n    # This will define alt_target_section and alt_target_section_offset\n    find_alt_replacement_target ${section} ${section_offset}\n\n    echo \"Error: found a reference to .altinstr_replacement in __ex_table:\"\n    addr2line -fip -j ${alt_target_section} -e ${obj} ${alt_target_offset} | awk '{print \"\\t\" $0}'\n\n    error=true\n}\n\nfunction is_executable_section()\n{\n    objdump -hwj ${section} ${obj} | grep -q CODE\n    return $?\n}\n\nfunction handle_suspicious_generic_reloc()\n{\n    if is_executable_section ${section}; then\n\t# We've got a relocation to a non white listed _executable_\n\t# section, print a warning so the developper adds the section to\n\t# the white list or fix his code.  We try to pretty-print the file\n\t# and line number where that relocation was added.\n\techo \"Warning: found a reference to section \\\"${section}\\\" in __ex_table:\"\n\taddr2line -fip -j ${section} -e ${obj} ${section_offset} | awk '{print \"\\t\" $0}'\n    else\n\t# Something is definitively wrong here since we've got a relocation\n\t# to a non-executable section, there's no way this would ever be\n\t# running in the kernel.\n\techo \"Error: found a reference to non-executable section \\\"${section}\\\" in __ex_table at offset ${section_offset}\"\n\terror=true\n    fi\n}\n\nfunction handle_suspicious_reloc()\n{\n    case \"${section}\" in\n\t\".altinstr_replacement\")\n\t    handle_alt_replacement_reloc ${section} ${section_offset}\n\t    ;;\n\t*)\n\t    handle_suspicious_generic_reloc ${section} ${section_offset}\n\t    ;;\n    esac\n}\n\nfunction diagnose()\n{\n\n    for reloc in ${suspicious_relocs}; do\n\t# Let's find out where the target of the relocation in __ex_table\n\t# is, this will define ${symbol} and ${symbol_offset}\n\tfind_symbol_and_offset_from_reloc ${reloc}\n\n\t# When there's a global symbol at the place of the relocation,\n\t# objdump will use it instead of giving us a section+offset, so\n\t# let's find out which section is this symbol in and the total\n\t# offset withing that section.\n\tfind_section_offset_from_symbol ${symbol} ${symbol_offset}\n\n\t# In this case objdump was presenting us with a reloc to a symbol\n\t# rather than a section. Now that we've got the actual section,\n\t# we can skip it if it's in the white_list.\n\tif [ -z \"$( echo $section | grep -v $(eval echo -e{${white_list}}))\" ]; then\n\t    continue;\n\tfi\n\n\t# Will either print a warning if the relocation happens to be in a\n\t# section we do not know but has executable bit set, or error out.\n\thandle_suspicious_reloc\n    done\n}\n\nfunction check_debug_info() {\n    objdump -hj .debug_info ${obj} 2> /dev/null > /dev/null ||\n\techo -e \"${obj} does not contain debug information, the addr2line output will be limited.\\n\" \\\n\t     \"Recompile ${obj} with CONFIG_DEBUG_INFO to get a more useful output.\"\n}\n\ncheck_debug_info\n\ndiagnose\n\nif [ \"${error}\" ]; then\n    exit 1\nfi\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}