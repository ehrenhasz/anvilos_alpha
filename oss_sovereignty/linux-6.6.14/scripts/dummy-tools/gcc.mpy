{
  "module_name": "gcc",
  "hash_id": "c5759bb2e5dbdee3965ff3ccad3b8ab6980a279d91f379d5b0966aed5e904053",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dummy-tools/gcc",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# Staring v4.18, Kconfig evaluates compiler capabilities, and hides CONFIG\n# options your compiler does not support. This works well if you configure and\n# build the kernel on the same host machine.\n#\n# It is inconvenient if you prepare the .config that is carried to a different\n# build environment (typically this happens when you package the kernel for\n# distros) because using a different compiler potentially produces different\n# CONFIG options than the real build environment. So, you probably want to make\n# as many options visible as possible. In other words, you need to create a\n# super-set of CONFIG options that cover any build environment. If some of the\n# CONFIG options turned out to be unsupported on the build machine, they are\n# automatically disabled by the nature of Kconfig.\n#\n# However, it is not feasible to get a full-featured compiler for every arch.\n# Hence these dummy toolchains to make all compiler tests pass.\n#\n# Usage:\n#\n# From the top directory of the source tree, run\n#\n#   $ make CROSS_COMPILE=scripts/dummy-tools/ oldconfig\n#\n# Most of compiler features are tested by cc-option, which simply checks the\n# exit code of $(CC). This script does nothing and just exits with 0 in most\n# cases. So, $(cc-option, ...) is evaluated as 'y'.\n#\n# This scripts caters to more checks; handle --version and pre-process __GNUC__\n# etc. to pretend to be GCC, and also do right things to satisfy some scripts.\n\n# Check if the first parameter appears in the rest. Succeeds if found.\n# This helper is useful if a particular option was passed to this script.\n# Typically used like this:\n#   arg_contain <word-you-are-searching-for> \"$@\"\narg_contain ()\n{\n\tsearch=\"$1\"\n\tshift\n\n\twhile [ $# -gt 0 ]\n\tdo\n\t\tif [ \"$search\" = \"$1\" ]; then\n\t\t\treturn 0\n\t\tfi\n\t\tshift\n\tdone\n\n\treturn 1\n}\n\n# To set CONFIG_CC_IS_GCC=y\nif arg_contain --version \"$@\"; then\n\techo \"gcc (scripts/dummy-tools/gcc)\"\n\texit 0\nfi\n\nif arg_contain -E \"$@\"; then\n\t# For scripts/cc-version.sh; This emulates GCC 20.0.0\n\tif arg_contain - \"$@\"; then\n\t\tsed -n '/^GCC/{s/__GNUC__/20/; s/__GNUC_MINOR__/0/; s/__GNUC_PATCHLEVEL__/0/; p;}; s/__LONG_DOUBLE_128__/1/ p'\n\t\texit 0\n\telse\n\t\techo \"no input files\" >&2\n\t\texit 1\n\tfi\nfi\n\n# To set CONFIG_AS_IS_GNU\nif arg_contain -Wa,--version \"$@\"; then\n\techo \"GNU assembler (scripts/dummy-tools) 2.50\"\n\texit 0\nfi\n\nif arg_contain -S \"$@\"; then\n\t# For scripts/gcc-x86-*-has-stack-protector.sh\n\tif arg_contain -fstack-protector \"$@\"; then\n\t\tif arg_contain -mstack-protector-guard-reg=fs \"$@\"; then\n\t\t\techo \"%fs\"\n\t\telse\n\t\t\techo \"%gs\"\n\t\tfi\n\t\texit 0\n\tfi\n\n\t# For arch/powerpc/tools/gcc-check-mprofile-kernel.sh\n\tif arg_contain -m64 \"$@\" && arg_contain -mprofile-kernel \"$@\"; then\n\t\tif ! test -t 0 && ! grep -q notrace; then\n\t\t\techo \"_mcount\"\n\t\tfi\n\t\texit 0\n\tfi\nfi\n\n# To set GCC_PLUGINS\nif arg_contain -print-file-name=plugin \"$@\"; then\n\t# Use $0 to find the in-tree dummy directory\n\techo \"$(dirname \"$(readlink -f \"$0\")\")/dummy-plugin-dir\"\n\texit 0\nfi\n\n# inverted return value\nif arg_contain -D__SIZEOF_INT128__=0 \"$@\"; then\n\texit 1\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}