{
  "module_name": "generate_rust_target.rs",
  "hash_id": "bcbdfc3012f6a95d67e210ae71295510205f97b8e1c2363fc5948f2be1ce3508",
  "original_prompt": "Ingested from linux-6.6.14/scripts/generate_rust_target.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! The custom target specification file generator for `rustc`.\n//!\n//! To configure a target from scratch, a JSON-encoded file has to be passed\n//! to `rustc` (introduced in [RFC 131]). These options and the file itself are\n//! unstable. Eventually, `rustc` should provide a way to do this in a stable\n//! manner. For instance, via command-line arguments. Therefore, this file\n//! should avoid using keys which can be set via `-C` or `-Z` options.\n//!\n//! [RFC 131]: https://rust-lang.github.io/rfcs/0131-target-specification.html\n\nuse std::{\n    collections::HashMap,\n    fmt::{Display, Formatter, Result},\n    io::BufRead,\n};\n\nenum Value {\n    Boolean(bool),\n    Number(i32),\n    String(String),\n    Object(Object),\n}\n\ntype Object = Vec<(String, Value)>;\n\n/// Minimal \"almost JSON\" generator (e.g. no `null`s, no arrays, no escaping),\n/// enough for this purpose.\nimpl Display for Value {\n    fn fmt(&self, formatter: &mut Formatter<'_>) -> Result {\n        match self {\n            Value::Boolean(boolean) => write!(formatter, \"{}\", boolean),\n            Value::Number(number) => write!(formatter, \"{}\", number),\n            Value::String(string) => write!(formatter, \"\\\"{}\\\"\", string),\n            Value::Object(object) => {\n                formatter.write_str(\"{\")?;\n                if let [ref rest @ .., ref last] = object[..] {\n                    for (key, value) in rest {\n                        write!(formatter, \"\\\"{}\\\": {},\", key, value)?;\n                    }\n                    write!(formatter, \"\\\"{}\\\": {}\", last.0, last.1)?;\n                }\n                formatter.write_str(\"}\")\n            }\n        }\n    }\n}\n\nstruct TargetSpec(Object);\n\nimpl TargetSpec {\n    fn new() -> TargetSpec {\n        TargetSpec(Vec::new())\n    }\n}\n\ntrait Push<T> {\n    fn push(&mut self, key: &str, value: T);\n}\n\nimpl Push<bool> for TargetSpec {\n    fn push(&mut self, key: &str, value: bool) {\n        self.0.push((key.to_string(), Value::Boolean(value)));\n    }\n}\n\nimpl Push<i32> for TargetSpec {\n    fn push(&mut self, key: &str, value: i32) {\n        self.0.push((key.to_string(), Value::Number(value)));\n    }\n}\n\nimpl Push<String> for TargetSpec {\n    fn push(&mut self, key: &str, value: String) {\n        self.0.push((key.to_string(), Value::String(value)));\n    }\n}\n\nimpl Push<&str> for TargetSpec {\n    fn push(&mut self, key: &str, value: &str) {\n        self.push(key, value.to_string());\n    }\n}\n\nimpl Push<Object> for TargetSpec {\n    fn push(&mut self, key: &str, value: Object) {\n        self.0.push((key.to_string(), Value::Object(value)));\n    }\n}\n\nimpl Display for TargetSpec {\n    fn fmt(&self, formatter: &mut Formatter<'_>) -> Result {\n        // We add some newlines for clarity.\n        formatter.write_str(\"{\\n\")?;\n        if let [ref rest @ .., ref last] = self.0[..] {\n            for (key, value) in rest {\n                write!(formatter, \"    \\\"{}\\\": {},\\n\", key, value)?;\n            }\n            write!(formatter, \"    \\\"{}\\\": {}\\n\", last.0, last.1)?;\n        }\n        formatter.write_str(\"}\")\n    }\n}\n\nstruct KernelConfig(HashMap<String, String>);\n\nimpl KernelConfig {\n    /// Parses `include/config/auto.conf` from `stdin`.\n    fn from_stdin() -> KernelConfig {\n        let mut result = HashMap::new();\n\n        let stdin = std::io::stdin();\n        let mut handle = stdin.lock();\n        let mut line = String::new();\n\n        loop {\n            line.clear();\n\n            if handle.read_line(&mut line).unwrap() == 0 {\n                break;\n            }\n\n            if line.starts_with('#') {\n                continue;\n            }\n\n            let (key, value) = line.split_once('=').expect(\"Missing `=` in line.\");\n            result.insert(key.to_string(), value.trim_end_matches('\\n').to_string());\n        }\n\n        KernelConfig(result)\n    }\n\n    /// Does the option exist in the configuration (any value)?\n    ///\n    /// The argument must be passed without the `CONFIG_` prefix.\n    /// This avoids repetition and it also avoids `fixdep` making us\n    /// depend on it.\n    fn has(&self, option: &str) -> bool {\n        let option = \"CONFIG_\".to_owned() + option;\n        self.0.contains_key(&option)\n    }\n}\n\nfn main() {\n    let cfg = KernelConfig::from_stdin();\n    let mut ts = TargetSpec::new();\n\n    // `llvm-target`s are taken from `scripts/Makefile.clang`.\n    if cfg.has(\"X86_64\") {\n        ts.push(\"arch\", \"x86_64\");\n        ts.push(\n            \"data-layout\",\n            \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\",\n        );\n        let mut features = \"-3dnow,-3dnowa,-mmx,+soft-float\".to_string();\n        if cfg.has(\"RETPOLINE\") {\n            features += \",+retpoline-external-thunk\";\n        }\n        ts.push(\"features\", features);\n        ts.push(\"llvm-target\", \"x86_64-linux-gnu\");\n        ts.push(\"target-pointer-width\", \"64\");\n    } else {\n        panic!(\"Unsupported architecture\");\n    }\n\n    ts.push(\"emit-debug-gdb-scripts\", false);\n    ts.push(\"frame-pointer\", \"may-omit\");\n    ts.push(\n        \"stack-probes\",\n        vec![(\"kind\".to_string(), Value::String(\"none\".to_string()))],\n    );\n\n    // Everything else is LE, whether `CPU_LITTLE_ENDIAN` is declared or not\n    // (e.g. x86). It is also `rustc`'s default.\n    if cfg.has(\"CPU_BIG_ENDIAN\") {\n        ts.push(\"target-endian\", \"big\");\n    }\n\n    println!(\"{}\", ts);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}