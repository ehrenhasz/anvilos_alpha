{
  "module_name": "asn1_compiler.c",
  "hash_id": "888d124f3b198cb6db44e85d79687f6c9ed4374a76c3c74d17a918cf24cce6bf",
  "original_prompt": "Ingested from linux-6.6.14/scripts/asn1_compiler.c",
  "human_readable_source": "\n \n\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <linux/asn1_ber_bytecode.h>\n\nenum token_type {\n\tDIRECTIVE_ABSENT,\n\tDIRECTIVE_ALL,\n\tDIRECTIVE_ANY,\n\tDIRECTIVE_APPLICATION,\n\tDIRECTIVE_AUTOMATIC,\n\tDIRECTIVE_BEGIN,\n\tDIRECTIVE_BIT,\n\tDIRECTIVE_BMPString,\n\tDIRECTIVE_BOOLEAN,\n\tDIRECTIVE_BY,\n\tDIRECTIVE_CHARACTER,\n\tDIRECTIVE_CHOICE,\n\tDIRECTIVE_CLASS,\n\tDIRECTIVE_COMPONENT,\n\tDIRECTIVE_COMPONENTS,\n\tDIRECTIVE_CONSTRAINED,\n\tDIRECTIVE_CONTAINING,\n\tDIRECTIVE_DEFAULT,\n\tDIRECTIVE_DEFINED,\n\tDIRECTIVE_DEFINITIONS,\n\tDIRECTIVE_EMBEDDED,\n\tDIRECTIVE_ENCODED,\n\tDIRECTIVE_ENCODING_CONTROL,\n\tDIRECTIVE_END,\n\tDIRECTIVE_ENUMERATED,\n\tDIRECTIVE_EXCEPT,\n\tDIRECTIVE_EXPLICIT,\n\tDIRECTIVE_EXPORTS,\n\tDIRECTIVE_EXTENSIBILITY,\n\tDIRECTIVE_EXTERNAL,\n\tDIRECTIVE_FALSE,\n\tDIRECTIVE_FROM,\n\tDIRECTIVE_GeneralString,\n\tDIRECTIVE_GeneralizedTime,\n\tDIRECTIVE_GraphicString,\n\tDIRECTIVE_IA5String,\n\tDIRECTIVE_IDENTIFIER,\n\tDIRECTIVE_IMPLICIT,\n\tDIRECTIVE_IMPLIED,\n\tDIRECTIVE_IMPORTS,\n\tDIRECTIVE_INCLUDES,\n\tDIRECTIVE_INSTANCE,\n\tDIRECTIVE_INSTRUCTIONS,\n\tDIRECTIVE_INTEGER,\n\tDIRECTIVE_INTERSECTION,\n\tDIRECTIVE_ISO646String,\n\tDIRECTIVE_MAX,\n\tDIRECTIVE_MIN,\n\tDIRECTIVE_MINUS_INFINITY,\n\tDIRECTIVE_NULL,\n\tDIRECTIVE_NumericString,\n\tDIRECTIVE_OBJECT,\n\tDIRECTIVE_OCTET,\n\tDIRECTIVE_OF,\n\tDIRECTIVE_OPTIONAL,\n\tDIRECTIVE_ObjectDescriptor,\n\tDIRECTIVE_PATTERN,\n\tDIRECTIVE_PDV,\n\tDIRECTIVE_PLUS_INFINITY,\n\tDIRECTIVE_PRESENT,\n\tDIRECTIVE_PRIVATE,\n\tDIRECTIVE_PrintableString,\n\tDIRECTIVE_REAL,\n\tDIRECTIVE_RELATIVE_OID,\n\tDIRECTIVE_SEQUENCE,\n\tDIRECTIVE_SET,\n\tDIRECTIVE_SIZE,\n\tDIRECTIVE_STRING,\n\tDIRECTIVE_SYNTAX,\n\tDIRECTIVE_T61String,\n\tDIRECTIVE_TAGS,\n\tDIRECTIVE_TRUE,\n\tDIRECTIVE_TeletexString,\n\tDIRECTIVE_UNION,\n\tDIRECTIVE_UNIQUE,\n\tDIRECTIVE_UNIVERSAL,\n\tDIRECTIVE_UTCTime,\n\tDIRECTIVE_UTF8String,\n\tDIRECTIVE_UniversalString,\n\tDIRECTIVE_VideotexString,\n\tDIRECTIVE_VisibleString,\n\tDIRECTIVE_WITH,\n\tNR__DIRECTIVES,\n\tTOKEN_ASSIGNMENT = NR__DIRECTIVES,\n\tTOKEN_OPEN_CURLY,\n\tTOKEN_CLOSE_CURLY,\n\tTOKEN_OPEN_SQUARE,\n\tTOKEN_CLOSE_SQUARE,\n\tTOKEN_OPEN_ACTION,\n\tTOKEN_CLOSE_ACTION,\n\tTOKEN_COMMA,\n\tTOKEN_NUMBER,\n\tTOKEN_TYPE_NAME,\n\tTOKEN_ELEMENT_NAME,\n\tNR__TOKENS\n};\n\nstatic const unsigned char token_to_tag[NR__TOKENS] = {\n\t \n\t[DIRECTIVE_BOOLEAN]\t\t= ASN1_BOOL,\n\t[DIRECTIVE_INTEGER]\t\t= ASN1_INT,\n\t[DIRECTIVE_BIT]\t\t\t= ASN1_BTS,\n\t[DIRECTIVE_OCTET]\t\t= ASN1_OTS,\n\t[DIRECTIVE_NULL]\t\t= ASN1_NULL,\n\t[DIRECTIVE_OBJECT]\t\t= ASN1_OID,\n\t[DIRECTIVE_ObjectDescriptor]\t= ASN1_ODE,\n\t[DIRECTIVE_EXTERNAL]\t\t= ASN1_EXT,\n\t[DIRECTIVE_REAL]\t\t= ASN1_REAL,\n\t[DIRECTIVE_ENUMERATED]\t\t= ASN1_ENUM,\n\t[DIRECTIVE_EMBEDDED]\t\t= 0,\n\t[DIRECTIVE_UTF8String]\t\t= ASN1_UTF8STR,\n\t[DIRECTIVE_RELATIVE_OID]\t= ASN1_RELOID,\n\t \n\t \n\t[DIRECTIVE_SEQUENCE]\t\t= ASN1_SEQ,\n\t[DIRECTIVE_SET]\t\t\t= ASN1_SET,\n\t[DIRECTIVE_NumericString]\t= ASN1_NUMSTR,\n\t[DIRECTIVE_PrintableString]\t= ASN1_PRNSTR,\n\t[DIRECTIVE_T61String]\t\t= ASN1_TEXSTR,\n\t[DIRECTIVE_TeletexString]\t= ASN1_TEXSTR,\n\t[DIRECTIVE_VideotexString]\t= ASN1_VIDSTR,\n\t[DIRECTIVE_IA5String]\t\t= ASN1_IA5STR,\n\t[DIRECTIVE_UTCTime]\t\t= ASN1_UNITIM,\n\t[DIRECTIVE_GeneralizedTime]\t= ASN1_GENTIM,\n\t[DIRECTIVE_GraphicString]\t= ASN1_GRASTR,\n\t[DIRECTIVE_VisibleString]\t= ASN1_VISSTR,\n\t[DIRECTIVE_GeneralString]\t= ASN1_GENSTR,\n\t[DIRECTIVE_UniversalString]\t= ASN1_UNITIM,\n\t[DIRECTIVE_CHARACTER]\t\t= ASN1_CHRSTR,\n\t[DIRECTIVE_BMPString]\t\t= ASN1_BMPSTR,\n};\n\nstatic const char asn1_classes[4][5] = {\n\t[ASN1_UNIV]\t= \"UNIV\",\n\t[ASN1_APPL]\t= \"APPL\",\n\t[ASN1_CONT]\t= \"CONT\",\n\t[ASN1_PRIV]\t= \"PRIV\"\n};\n\nstatic const char asn1_methods[2][5] = {\n\t[ASN1_UNIV]\t= \"PRIM\",\n\t[ASN1_APPL]\t= \"CONS\"\n};\n\nstatic const char *const asn1_universal_tags[32] = {\n\t\"EOC\",\n\t\"BOOL\",\n\t\"INT\",\n\t\"BTS\",\n\t\"OTS\",\n\t\"NULL\",\n\t\"OID\",\n\t\"ODE\",\n\t\"EXT\",\n\t\"REAL\",\n\t\"ENUM\",\n\t\"EPDV\",\n\t\"UTF8STR\",\n\t\"RELOID\",\n\tNULL,\t\t \n\tNULL,\t\t \n\t\"SEQ\",\n\t\"SET\",\n\t\"NUMSTR\",\n\t\"PRNSTR\",\n\t\"TEXSTR\",\n\t\"VIDSTR\",\n\t\"IA5STR\",\n\t\"UNITIM\",\n\t\"GENTIM\",\n\t\"GRASTR\",\n\t\"VISSTR\",\n\t\"GENSTR\",\n\t\"UNISTR\",\n\t\"CHRSTR\",\n\t\"BMPSTR\",\n\tNULL\t\t \n};\n\nstatic const char *filename;\nstatic const char *grammar_name;\nstatic const char *outputname;\nstatic const char *headername;\n\nstatic const char *const directives[NR__DIRECTIVES] = {\n#define _(X) [DIRECTIVE_##X] = #X\n\t_(ABSENT),\n\t_(ALL),\n\t_(ANY),\n\t_(APPLICATION),\n\t_(AUTOMATIC),\n\t_(BEGIN),\n\t_(BIT),\n\t_(BMPString),\n\t_(BOOLEAN),\n\t_(BY),\n\t_(CHARACTER),\n\t_(CHOICE),\n\t_(CLASS),\n\t_(COMPONENT),\n\t_(COMPONENTS),\n\t_(CONSTRAINED),\n\t_(CONTAINING),\n\t_(DEFAULT),\n\t_(DEFINED),\n\t_(DEFINITIONS),\n\t_(EMBEDDED),\n\t_(ENCODED),\n\t[DIRECTIVE_ENCODING_CONTROL] = \"ENCODING-CONTROL\",\n\t_(END),\n\t_(ENUMERATED),\n\t_(EXCEPT),\n\t_(EXPLICIT),\n\t_(EXPORTS),\n\t_(EXTENSIBILITY),\n\t_(EXTERNAL),\n\t_(FALSE),\n\t_(FROM),\n\t_(GeneralString),\n\t_(GeneralizedTime),\n\t_(GraphicString),\n\t_(IA5String),\n\t_(IDENTIFIER),\n\t_(IMPLICIT),\n\t_(IMPLIED),\n\t_(IMPORTS),\n\t_(INCLUDES),\n\t_(INSTANCE),\n\t_(INSTRUCTIONS),\n\t_(INTEGER),\n\t_(INTERSECTION),\n\t_(ISO646String),\n\t_(MAX),\n\t_(MIN),\n\t[DIRECTIVE_MINUS_INFINITY] = \"MINUS-INFINITY\",\n\t[DIRECTIVE_NULL] = \"NULL\",\n\t_(NumericString),\n\t_(OBJECT),\n\t_(OCTET),\n\t_(OF),\n\t_(OPTIONAL),\n\t_(ObjectDescriptor),\n\t_(PATTERN),\n\t_(PDV),\n\t[DIRECTIVE_PLUS_INFINITY] = \"PLUS-INFINITY\",\n\t_(PRESENT),\n\t_(PRIVATE),\n\t_(PrintableString),\n\t_(REAL),\n\t[DIRECTIVE_RELATIVE_OID] = \"RELATIVE-OID\",\n\t_(SEQUENCE),\n\t_(SET),\n\t_(SIZE),\n\t_(STRING),\n\t_(SYNTAX),\n\t_(T61String),\n\t_(TAGS),\n\t_(TRUE),\n\t_(TeletexString),\n\t_(UNION),\n\t_(UNIQUE),\n\t_(UNIVERSAL),\n\t_(UTCTime),\n\t_(UTF8String),\n\t_(UniversalString),\n\t_(VideotexString),\n\t_(VisibleString),\n\t_(WITH)\n};\n\nstruct action {\n\tstruct action\t*next;\n\tchar\t\t*name;\n\tunsigned char\tindex;\n};\n\nstatic struct action *action_list;\nstatic unsigned nr_actions;\n\nstruct token {\n\tunsigned short\tline;\n\tenum token_type\ttoken_type : 8;\n\tunsigned char\tsize;\n\tstruct action\t*action;\n\tchar\t\t*content;\n\tstruct type\t*type;\n};\n\nstatic struct token *token_list;\nstatic unsigned nr_tokens;\nstatic bool verbose_opt;\nstatic bool debug_opt;\n\n#define verbose(fmt, ...) do { if (verbose_opt) printf(fmt, ## __VA_ARGS__); } while (0)\n#define debug(fmt, ...) do { if (debug_opt) printf(fmt, ## __VA_ARGS__); } while (0)\n\nstatic int directive_compare(const void *_key, const void *_pdir)\n{\n\tconst struct token *token = _key;\n\tconst char *const *pdir = _pdir, *dir = *pdir;\n\tsize_t dlen, clen;\n\tint val;\n\n\tdlen = strlen(dir);\n\tclen = (dlen < token->size) ? dlen : token->size;\n\n\t\n\n\tval = memcmp(token->content, dir, clen);\n\tif (val != 0) {\n\t\t\n\t\treturn val;\n\t}\n\n\tif (dlen == token->size) {\n\t\t\n\t\treturn 0;\n\t}\n\t\n\treturn dlen - token->size;  \n}\n\n \nstatic void tokenise(char *buffer, char *end)\n{\n\tstruct token *tokens;\n\tchar *line, *nl, *start, *p, *q;\n\tunsigned tix, lineno;\n\n\t \n\ttoken_list = tokens = calloc((end - buffer) / 2, sizeof(struct token));\n\tif (!tokens) {\n\t\tperror(NULL);\n\t\texit(1);\n\t}\n\ttix = 0;\n\n\tlineno = 0;\n\twhile (buffer < end) {\n\t\t \n\t\tlineno++;\n\t\tline = buffer;\n\t\tnl = memchr(line, '\\n', end - buffer);\n\t\tif (!nl) {\n\t\t\tbuffer = nl = end;\n\t\t} else {\n\t\t\tbuffer = nl + 1;\n\t\t\t*nl = '\\0';\n\t\t}\n\n\t\t \n\t\tp = line;\n\tnext_comment:\n\t\twhile ((p = memchr(p, '-', nl - p))) {\n\t\t\tif (p[1] == '-') {\n\t\t\t\t \n\t\t\t\tq = p + 2;\n\t\t\t\twhile ((q = memchr(q, '-', nl - q))) {\n\t\t\t\t\tif (q[1] == '-') {\n\t\t\t\t\t\t \n\t\t\t\t\t\tq += 2;\n\t\t\t\t\t\tmemmove(p, q, nl - q);\n\t\t\t\t\t\tgoto next_comment;\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t\t*p = '\\0';\n\t\t\t\tnl = p;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tp = line;\n\t\twhile (p < nl) {\n\t\t\t \n\t\t\twhile (p < nl && isspace(*p))\n\t\t\t\t*(p++) = 0;\n\t\t\tif (p >= nl)\n\t\t\t\tbreak;\n\n\t\t\ttokens[tix].line = lineno;\n\t\t\tstart = p;\n\n\t\t\t \n\t\t\tif (isalpha(*p)) {\n\t\t\t\tconst char **dir;\n\n\t\t\t\t \n\t\t\t\tq = p + 1;\n\t\t\t\twhile (q < nl && (isalnum(*q) || *q == '-' || *q == '_'))\n\t\t\t\t\tq++;\n\t\t\t\ttokens[tix].size = q - p;\n\t\t\t\tp = q;\n\n\t\t\t\ttokens[tix].content = malloc(tokens[tix].size + 1);\n\t\t\t\tif (!tokens[tix].content) {\n\t\t\t\t\tperror(NULL);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tmemcpy(tokens[tix].content, start, tokens[tix].size);\n\t\t\t\ttokens[tix].content[tokens[tix].size] = 0;\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tif (islower(tokens[tix].content[0])) {\n\t\t\t\t\ttokens[tix++].token_type = TOKEN_ELEMENT_NAME;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tdir = bsearch(&tokens[tix], directives,\n\t\t\t\t\t      sizeof(directives) / sizeof(directives[1]),\n\t\t\t\t\t      sizeof(directives[1]),\n\t\t\t\t\t      directive_compare);\n\t\t\t\tif (dir) {\n\t\t\t\t\ttokens[tix++].token_type = dir - directives;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttokens[tix++].token_type = TOKEN_TYPE_NAME;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (isdigit(*p)) {\n\t\t\t\t \n\t\t\t\tq = p + 1;\n\t\t\t\twhile (q < nl && (isdigit(*q)))\n\t\t\t\t\tq++;\n\t\t\t\ttokens[tix].size = q - p;\n\t\t\t\tp = q;\n\t\t\t\ttokens[tix].content = malloc(tokens[tix].size + 1);\n\t\t\t\tif (!tokens[tix].content) {\n\t\t\t\t\tperror(NULL);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tmemcpy(tokens[tix].content, start, tokens[tix].size);\n\t\t\t\ttokens[tix].content[tokens[tix].size] = 0;\n\t\t\t\ttokens[tix++].token_type = TOKEN_NUMBER;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (nl - p >= 3) {\n\t\t\t\tif (memcmp(p, \"::=\", 3) == 0) {\n\t\t\t\t\tp += 3;\n\t\t\t\t\ttokens[tix].size = 3;\n\t\t\t\t\ttokens[tix].content = \"::=\";\n\t\t\t\t\ttokens[tix++].token_type = TOKEN_ASSIGNMENT;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nl - p >= 2) {\n\t\t\t\tif (memcmp(p, \"({\", 2) == 0) {\n\t\t\t\t\tp += 2;\n\t\t\t\t\ttokens[tix].size = 2;\n\t\t\t\t\ttokens[tix].content = \"({\";\n\t\t\t\t\ttokens[tix++].token_type = TOKEN_OPEN_ACTION;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (memcmp(p, \"})\", 2) == 0) {\n\t\t\t\t\tp += 2;\n\t\t\t\t\ttokens[tix].size = 2;\n\t\t\t\t\ttokens[tix].content = \"})\";\n\t\t\t\t\ttokens[tix++].token_type = TOKEN_CLOSE_ACTION;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nl - p >= 1) {\n\t\t\t\ttokens[tix].size = 1;\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase '{':\n\t\t\t\t\tp += 1;\n\t\t\t\t\ttokens[tix].content = \"{\";\n\t\t\t\t\ttokens[tix++].token_type = TOKEN_OPEN_CURLY;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '}':\n\t\t\t\t\tp += 1;\n\t\t\t\t\ttokens[tix].content = \"}\";\n\t\t\t\t\ttokens[tix++].token_type = TOKEN_CLOSE_CURLY;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '[':\n\t\t\t\t\tp += 1;\n\t\t\t\t\ttokens[tix].content = \"[\";\n\t\t\t\t\ttokens[tix++].token_type = TOKEN_OPEN_SQUARE;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase ']':\n\t\t\t\t\tp += 1;\n\t\t\t\t\ttokens[tix].content = \"]\";\n\t\t\t\t\ttokens[tix++].token_type = TOKEN_CLOSE_SQUARE;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase ',':\n\t\t\t\t\tp += 1;\n\t\t\t\t\ttokens[tix].content = \",\";\n\t\t\t\t\ttokens[tix++].token_type = TOKEN_COMMA;\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfprintf(stderr, \"%s:%u: Unknown character in grammar: '%c'\\n\",\n\t\t\t\tfilename, lineno, *p);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tnr_tokens = tix;\n\tverbose(\"Extracted %u tokens\\n\", nr_tokens);\n\n#if 0\n\t{\n\t\tint n;\n\t\tfor (n = 0; n < nr_tokens; n++)\n\t\t\tdebug(\"Token %3u: '%s'\\n\", n, token_list[n].content);\n\t}\n#endif\n}\n\nstatic void build_type_list(void);\nstatic void parse(void);\nstatic void dump_elements(void);\nstatic void render(FILE *out, FILE *hdr);\n\n \nint main(int argc, char **argv)\n{\n\tstruct stat st;\n\tssize_t readlen;\n\tFILE *out, *hdr;\n\tchar *buffer, *p;\n\tchar *kbuild_verbose;\n\tint fd;\n\n\tkbuild_verbose = getenv(\"KBUILD_VERBOSE\");\n\tif (kbuild_verbose && strchr(kbuild_verbose, '1'))\n\t\tverbose_opt = true;\n\n\twhile (argc > 4) {\n\t\tif (strcmp(argv[1], \"-v\") == 0)\n\t\t\tverbose_opt = true;\n\t\telse if (strcmp(argv[1], \"-d\") == 0)\n\t\t\tdebug_opt = true;\n\t\telse\n\t\t\tbreak;\n\t\tmemmove(&argv[1], &argv[2], (argc - 2) * sizeof(char *));\n\t\targc--;\n\t}\n\n\tif (argc != 4) {\n\t\tfprintf(stderr, \"Format: %s [-v] [-d] <grammar-file> <c-file> <hdr-file>\\n\",\n\t\t\targv[0]);\n\t\texit(2);\n\t}\n\n\tfilename = argv[1];\n\toutputname = argv[2];\n\theadername = argv[3];\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\n\tif (!(buffer = malloc(st.st_size + 1))) {\n\t\tperror(NULL);\n\t\texit(1);\n\t}\n\n\tif ((readlen = read(fd, buffer, st.st_size)) < 0) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\n\tif (close(fd) < 0) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\n\tif (readlen != st.st_size) {\n\t\tfprintf(stderr, \"%s: Short read\\n\", filename);\n\t\texit(1);\n\t}\n\n\tp = strrchr(argv[1], '/');\n\tp = p ? p + 1 : argv[1];\n\tgrammar_name = strdup(p);\n\tif (!grammar_name) {\n\t\tperror(NULL);\n\t\texit(1);\n\t}\n\tp = strchr(grammar_name, '.');\n\tif (p)\n\t\t*p = '\\0';\n\n\tbuffer[readlen] = 0;\n\ttokenise(buffer, buffer + readlen);\n\tbuild_type_list();\n\tparse();\n\tdump_elements();\n\n\tout = fopen(outputname, \"w\");\n\tif (!out) {\n\t\tperror(outputname);\n\t\texit(1);\n\t}\n\n\thdr = fopen(headername, \"w\");\n\tif (!hdr) {\n\t\tperror(headername);\n\t\texit(1);\n\t}\n\n\trender(out, hdr);\n\n\tif (fclose(out) < 0) {\n\t\tperror(outputname);\n\t\texit(1);\n\t}\n\n\tif (fclose(hdr) < 0) {\n\t\tperror(headername);\n\t\texit(1);\n\t}\n\n\treturn 0;\n}\n\nenum compound {\n\tNOT_COMPOUND,\n\tSET,\n\tSET_OF,\n\tSEQUENCE,\n\tSEQUENCE_OF,\n\tCHOICE,\n\tANY,\n\tTYPE_REF,\n\tTAG_OVERRIDE\n};\n\nstruct element {\n\tstruct type\t*type_def;\n\tstruct token\t*name;\n\tstruct token\t*type;\n\tstruct action\t*action;\n\tstruct element\t*children;\n\tstruct element\t*next;\n\tstruct element\t*render_next;\n\tstruct element\t*list_next;\n\tuint8_t\t\tn_elements;\n\tenum compound\tcompound : 8;\n\tenum asn1_class\tclass : 8;\n\tenum asn1_method method : 8;\n\tuint8_t\t\ttag;\n\tunsigned\tentry_index;\n\tunsigned\tflags;\n#define ELEMENT_IMPLICIT\t0x0001\n#define ELEMENT_EXPLICIT\t0x0002\n#define ELEMENT_TAG_SPECIFIED\t0x0004\n#define ELEMENT_RENDERED\t0x0008\n#define ELEMENT_SKIPPABLE\t0x0010\n#define ELEMENT_CONDITIONAL\t0x0020\n};\n\nstruct type {\n\tstruct token\t*name;\n\tstruct token\t*def;\n\tstruct element\t*element;\n\tunsigned\tref_count;\n\tunsigned\tflags;\n#define TYPE_STOP_MARKER\t0x0001\n#define TYPE_BEGIN\t\t0x0002\n};\n\nstatic struct type *type_list;\nstatic struct type **type_index;\nstatic unsigned nr_types;\n\nstatic int type_index_compare(const void *_a, const void *_b)\n{\n\tconst struct type *const *a = _a, *const *b = _b;\n\n\tif ((*a)->name->size != (*b)->name->size)\n\t\treturn (*a)->name->size - (*b)->name->size;\n\telse\n\t\treturn memcmp((*a)->name->content, (*b)->name->content,\n\t\t\t      (*a)->name->size);\n}\n\nstatic int type_finder(const void *_key, const void *_ti)\n{\n\tconst struct token *token = _key;\n\tconst struct type *const *ti = _ti;\n\tconst struct type *type = *ti;\n\n\tif (token->size != type->name->size)\n\t\treturn token->size - type->name->size;\n\telse\n\t\treturn memcmp(token->content, type->name->content,\n\t\t\t      token->size);\n}\n\n \nstatic void build_type_list(void)\n{\n\tstruct type *types;\n\tunsigned nr, t, n;\n\n\tnr = 0;\n\tfor (n = 0; n < nr_tokens - 1; n++)\n\t\tif (token_list[n + 0].token_type == TOKEN_TYPE_NAME &&\n\t\t    token_list[n + 1].token_type == TOKEN_ASSIGNMENT)\n\t\t\tnr++;\n\n\tif (nr == 0) {\n\t\tfprintf(stderr, \"%s: No defined types\\n\", filename);\n\t\texit(1);\n\t}\n\n\tnr_types = nr;\n\ttypes = type_list = calloc(nr + 1, sizeof(type_list[0]));\n\tif (!type_list) {\n\t\tperror(NULL);\n\t\texit(1);\n\t}\n\ttype_index = calloc(nr, sizeof(type_index[0]));\n\tif (!type_index) {\n\t\tperror(NULL);\n\t\texit(1);\n\t}\n\n\tt = 0;\n\ttypes[t].flags |= TYPE_BEGIN;\n\tfor (n = 0; n < nr_tokens - 1; n++) {\n\t\tif (token_list[n + 0].token_type == TOKEN_TYPE_NAME &&\n\t\t    token_list[n + 1].token_type == TOKEN_ASSIGNMENT) {\n\t\t\ttypes[t].name = &token_list[n];\n\t\t\ttype_index[t] = &types[t];\n\t\t\tt++;\n\t\t}\n\t}\n\ttypes[t].name = &token_list[n + 1];\n\ttypes[t].flags |= TYPE_STOP_MARKER;\n\n\tqsort(type_index, nr, sizeof(type_index[0]), type_index_compare);\n\n\tverbose(\"Extracted %u types\\n\", nr_types);\n#if 0\n\tfor (n = 0; n < nr_types; n++) {\n\t\tstruct type *type = type_index[n];\n\t\tdebug(\"- %*.*s\\n\", type->name->content);\n\t}\n#endif\n}\n\nstatic struct element *parse_type(struct token **_cursor, struct token *stop,\n\t\t\t\t  struct token *name);\n\n \nstatic void parse(void)\n{\n\tstruct token *cursor;\n\tstruct type *type;\n\n\t \n\ttype = type_list;\n\tdo {\n\t\tcursor = type->name;\n\n\t\tif (cursor[0].token_type != TOKEN_TYPE_NAME ||\n\t\t    cursor[1].token_type != TOKEN_ASSIGNMENT)\n\t\t\tabort();\n\t\tcursor += 2;\n\n\t\ttype->element = parse_type(&cursor, type[1].name, NULL);\n\t\ttype->element->type_def = type;\n\n\t\tif (cursor != type[1].name) {\n\t\t\tfprintf(stderr, \"%s:%d: Parse error at token '%s'\\n\",\n\t\t\t\tfilename, cursor->line, cursor->content);\n\t\t\texit(1);\n\t\t}\n\n\t} while (type++, !(type->flags & TYPE_STOP_MARKER));\n\n\tverbose(\"Extracted %u actions\\n\", nr_actions);\n}\n\nstatic struct element *element_list;\n\nstatic struct element *alloc_elem(void)\n{\n\tstruct element *e = calloc(1, sizeof(*e));\n\tif (!e) {\n\t\tperror(NULL);\n\t\texit(1);\n\t}\n\te->list_next = element_list;\n\telement_list = e;\n\treturn e;\n}\n\nstatic struct element *parse_compound(struct token **_cursor, struct token *end,\n\t\t\t\t      int alternates);\n\n \nstatic struct element *parse_type(struct token **_cursor, struct token *end,\n\t\t\t\t  struct token *name)\n{\n\tstruct element *top, *element;\n\tstruct action *action, **ppaction;\n\tstruct token *cursor = *_cursor;\n\tstruct type **ref;\n\tchar *p;\n\tint labelled = 0, implicit = 0;\n\n\ttop = element = alloc_elem();\n\telement->class = ASN1_UNIV;\n\telement->method = ASN1_PRIM;\n\telement->tag = token_to_tag[cursor->token_type];\n\telement->name = name;\n\n\t \n\tif (cursor->token_type == TOKEN_OPEN_SQUARE) {\n\t\tcursor++;\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t\tswitch (cursor->token_type) {\n\t\tcase DIRECTIVE_UNIVERSAL:\n\t\t\telement->class = ASN1_UNIV;\n\t\t\tcursor++;\n\t\t\tbreak;\n\t\tcase DIRECTIVE_APPLICATION:\n\t\t\telement->class = ASN1_APPL;\n\t\t\tcursor++;\n\t\t\tbreak;\n\t\tcase TOKEN_NUMBER:\n\t\t\telement->class = ASN1_CONT;\n\t\t\tbreak;\n\t\tcase DIRECTIVE_PRIVATE:\n\t\t\telement->class = ASN1_PRIV;\n\t\t\tcursor++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"%s:%d: Unrecognised tag class token '%s'\\n\",\n\t\t\t\tfilename, cursor->line, cursor->content);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t\tif (cursor->token_type != TOKEN_NUMBER) {\n\t\t\tfprintf(stderr, \"%s:%d: Missing tag number '%s'\\n\",\n\t\t\t\tfilename, cursor->line, cursor->content);\n\t\t\texit(1);\n\t\t}\n\n\t\telement->tag &= ~0x1f;\n\t\telement->tag |= strtoul(cursor->content, &p, 10);\n\t\telement->flags |= ELEMENT_TAG_SPECIFIED;\n\t\tif (p - cursor->content != cursor->size)\n\t\t\tabort();\n\t\tcursor++;\n\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t\tif (cursor->token_type != TOKEN_CLOSE_SQUARE) {\n\t\t\tfprintf(stderr, \"%s:%d: Missing closing square bracket '%s'\\n\",\n\t\t\t\tfilename, cursor->line, cursor->content);\n\t\t\texit(1);\n\t\t}\n\t\tcursor++;\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t\tlabelled = 1;\n\t}\n\n\t \n\tif (cursor->token_type == DIRECTIVE_IMPLICIT) {\n\t\telement->flags |= ELEMENT_IMPLICIT;\n\t\timplicit = 1;\n\t\tcursor++;\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t} else if (cursor->token_type == DIRECTIVE_EXPLICIT) {\n\t\telement->flags |= ELEMENT_EXPLICIT;\n\t\tcursor++;\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t}\n\n\tif (labelled) {\n\t\tif (!implicit)\n\t\t\telement->method |= ASN1_CONS;\n\t\telement->compound = implicit ? TAG_OVERRIDE : SEQUENCE;\n\t\telement->children = alloc_elem();\n\t\telement = element->children;\n\t\telement->class = ASN1_UNIV;\n\t\telement->method = ASN1_PRIM;\n\t\telement->tag = token_to_tag[cursor->token_type];\n\t\telement->name = name;\n\t}\n\n\t \n\telement->type = cursor;\n\tswitch (cursor->token_type) {\n\tcase DIRECTIVE_ANY:\n\t\telement->compound = ANY;\n\t\tcursor++;\n\t\tbreak;\n\n\tcase DIRECTIVE_NULL:\n\tcase DIRECTIVE_BOOLEAN:\n\tcase DIRECTIVE_ENUMERATED:\n\tcase DIRECTIVE_INTEGER:\n\t\telement->compound = NOT_COMPOUND;\n\t\tcursor++;\n\t\tbreak;\n\n\tcase DIRECTIVE_EXTERNAL:\n\t\telement->method = ASN1_CONS;\n\n\tcase DIRECTIVE_BMPString:\n\tcase DIRECTIVE_GeneralString:\n\tcase DIRECTIVE_GraphicString:\n\tcase DIRECTIVE_IA5String:\n\tcase DIRECTIVE_ISO646String:\n\tcase DIRECTIVE_NumericString:\n\tcase DIRECTIVE_PrintableString:\n\tcase DIRECTIVE_T61String:\n\tcase DIRECTIVE_TeletexString:\n\tcase DIRECTIVE_UniversalString:\n\tcase DIRECTIVE_UTF8String:\n\tcase DIRECTIVE_VideotexString:\n\tcase DIRECTIVE_VisibleString:\n\tcase DIRECTIVE_ObjectDescriptor:\n\tcase DIRECTIVE_GeneralizedTime:\n\tcase DIRECTIVE_UTCTime:\n\t\telement->compound = NOT_COMPOUND;\n\t\tcursor++;\n\t\tbreak;\n\n\tcase DIRECTIVE_BIT:\n\tcase DIRECTIVE_OCTET:\n\t\telement->compound = NOT_COMPOUND;\n\t\tcursor++;\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t\tif (cursor->token_type != DIRECTIVE_STRING)\n\t\t\tgoto parse_error;\n\t\tcursor++;\n\t\tbreak;\n\n\tcase DIRECTIVE_OBJECT:\n\t\telement->compound = NOT_COMPOUND;\n\t\tcursor++;\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t\tif (cursor->token_type != DIRECTIVE_IDENTIFIER)\n\t\t\tgoto parse_error;\n\t\tcursor++;\n\t\tbreak;\n\n\tcase TOKEN_TYPE_NAME:\n\t\telement->compound = TYPE_REF;\n\t\tref = bsearch(cursor, type_index, nr_types, sizeof(type_index[0]),\n\t\t\t      type_finder);\n\t\tif (!ref) {\n\t\t\tfprintf(stderr, \"%s:%d: Type '%s' undefined\\n\",\n\t\t\t\tfilename, cursor->line, cursor->content);\n\t\t\texit(1);\n\t\t}\n\t\tcursor->type = *ref;\n\t\t(*ref)->ref_count++;\n\t\tcursor++;\n\t\tbreak;\n\n\tcase DIRECTIVE_CHOICE:\n\t\telement->compound = CHOICE;\n\t\tcursor++;\n\t\telement->children = parse_compound(&cursor, end, 1);\n\t\tbreak;\n\n\tcase DIRECTIVE_SEQUENCE:\n\t\telement->compound = SEQUENCE;\n\t\telement->method = ASN1_CONS;\n\t\tcursor++;\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t\tif (cursor->token_type == DIRECTIVE_OF) {\n\t\t\telement->compound = SEQUENCE_OF;\n\t\t\tcursor++;\n\t\t\tif (cursor >= end)\n\t\t\t\tgoto overrun_error;\n\t\t\telement->children = parse_type(&cursor, end, NULL);\n\t\t} else {\n\t\t\telement->children = parse_compound(&cursor, end, 0);\n\t\t}\n\t\tbreak;\n\n\tcase DIRECTIVE_SET:\n\t\telement->compound = SET;\n\t\telement->method = ASN1_CONS;\n\t\tcursor++;\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t\tif (cursor->token_type == DIRECTIVE_OF) {\n\t\t\telement->compound = SET_OF;\n\t\t\tcursor++;\n\t\t\tif (cursor >= end)\n\t\t\t\tgoto parse_error;\n\t\t\telement->children = parse_type(&cursor, end, NULL);\n\t\t} else {\n\t\t\telement->children = parse_compound(&cursor, end, 1);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tfprintf(stderr, \"%s:%d: Token '%s' does not introduce a type\\n\",\n\t\t\tfilename, cursor->line, cursor->content);\n\t\texit(1);\n\t}\n\n\t \n\tif (cursor < end && (cursor->token_type == DIRECTIVE_OPTIONAL ||\n\t\t\t     cursor->token_type == DIRECTIVE_DEFAULT)\n\t    ) {\n\t\tcursor++;\n\t\ttop->flags |= ELEMENT_SKIPPABLE;\n\t}\n\n\tif (cursor < end && cursor->token_type == TOKEN_OPEN_ACTION) {\n\t\tcursor++;\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t\tif (cursor->token_type != TOKEN_ELEMENT_NAME) {\n\t\t\tfprintf(stderr, \"%s:%d: Token '%s' is not an action function name\\n\",\n\t\t\t\tfilename, cursor->line, cursor->content);\n\t\t\texit(1);\n\t\t}\n\n\t\taction = malloc(sizeof(struct action));\n\t\tif (!action) {\n\t\t\tperror(NULL);\n\t\t\texit(1);\n\t\t}\n\t\taction->index = 0;\n\t\taction->name = cursor->content;\n\n\t\tfor (ppaction = &action_list;\n\t\t     *ppaction;\n\t\t     ppaction = &(*ppaction)->next\n\t\t     ) {\n\t\t\tint cmp = strcmp(action->name, (*ppaction)->name);\n\t\t\tif (cmp == 0) {\n\t\t\t\tfree(action);\n\t\t\t\taction = *ppaction;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tif (cmp < 0) {\n\t\t\t\taction->next = *ppaction;\n\t\t\t\t*ppaction = action;\n\t\t\t\tnr_actions++;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\taction->next = NULL;\n\t\t*ppaction = action;\n\t\tnr_actions++;\n\tfound:\n\n\t\telement->action = action;\n\t\tcursor->action = action;\n\t\tcursor++;\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t\tif (cursor->token_type != TOKEN_CLOSE_ACTION) {\n\t\t\tfprintf(stderr, \"%s:%d: Missing close action, got '%s'\\n\",\n\t\t\t\tfilename, cursor->line, cursor->content);\n\t\t\texit(1);\n\t\t}\n\t\tcursor++;\n\t}\n\n\t*_cursor = cursor;\n\treturn top;\n\nparse_error:\n\tfprintf(stderr, \"%s:%d: Unexpected token '%s'\\n\",\n\t\tfilename, cursor->line, cursor->content);\n\texit(1);\n\noverrun_error:\n\tfprintf(stderr, \"%s: Unexpectedly hit EOF\\n\", filename);\n\texit(1);\n}\n\n \nstatic struct element *parse_compound(struct token **_cursor, struct token *end,\n\t\t\t\t      int alternates)\n{\n\tstruct element *children, **child_p = &children, *element;\n\tstruct token *cursor = *_cursor, *name;\n\n\tif (cursor->token_type != TOKEN_OPEN_CURLY) {\n\t\tfprintf(stderr, \"%s:%d: Expected compound to start with brace not '%s'\\n\",\n\t\t\tfilename, cursor->line, cursor->content);\n\t\texit(1);\n\t}\n\tcursor++;\n\tif (cursor >= end)\n\t\tgoto overrun_error;\n\n\tif (cursor->token_type == TOKEN_OPEN_CURLY) {\n\t\tfprintf(stderr, \"%s:%d: Empty compound\\n\",\n\t\t\tfilename, cursor->line);\n\t\texit(1);\n\t}\n\n\tfor (;;) {\n\t\tname = NULL;\n\t\tif (cursor->token_type == TOKEN_ELEMENT_NAME) {\n\t\t\tname = cursor;\n\t\t\tcursor++;\n\t\t\tif (cursor >= end)\n\t\t\t\tgoto overrun_error;\n\t\t}\n\n\t\telement = parse_type(&cursor, end, name);\n\t\tif (alternates)\n\t\t\telement->flags |= ELEMENT_SKIPPABLE | ELEMENT_CONDITIONAL;\n\n\t\t*child_p = element;\n\t\tchild_p = &element->next;\n\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t\tif (cursor->token_type != TOKEN_COMMA)\n\t\t\tbreak;\n\t\tcursor++;\n\t\tif (cursor >= end)\n\t\t\tgoto overrun_error;\n\t}\n\n\tchildren->flags &= ~ELEMENT_CONDITIONAL;\n\n\tif (cursor->token_type != TOKEN_CLOSE_CURLY) {\n\t\tfprintf(stderr, \"%s:%d: Expected compound closure, got '%s'\\n\",\n\t\t\tfilename, cursor->line, cursor->content);\n\t\texit(1);\n\t}\n\tcursor++;\n\n\t*_cursor = cursor;\n\treturn children;\n\noverrun_error:\n\tfprintf(stderr, \"%s: Unexpectedly hit EOF\\n\", filename);\n\texit(1);\n}\n\nstatic void dump_element(const struct element *e, int level)\n{\n\tconst struct element *c;\n\tconst struct type *t = e->type_def;\n\tconst char *name = e->name ? e->name->content : \".\";\n\tconst char *tname = t && t->name ? t->name->content : \".\";\n\tchar tag[32];\n\n\tif (e->class == 0 && e->method == 0 && e->tag == 0)\n\t\tstrcpy(tag, \"<...>\");\n\telse if (e->class == ASN1_UNIV)\n\t\tsprintf(tag, \"%s %s %s\",\n\t\t\tasn1_classes[e->class],\n\t\t\tasn1_methods[e->method],\n\t\t\tasn1_universal_tags[e->tag]);\n\telse\n\t\tsprintf(tag, \"%s %s %u\",\n\t\t\tasn1_classes[e->class],\n\t\t\tasn1_methods[e->method],\n\t\t\te->tag);\n\n\tprintf(\"%c%c%c%c%c %c %*s[*] \\e[33m%s\\e[m %s %s \\e[35m%s\\e[m\\n\",\n\t       e->flags & ELEMENT_IMPLICIT ? 'I' : '-',\n\t       e->flags & ELEMENT_EXPLICIT ? 'E' : '-',\n\t       e->flags & ELEMENT_TAG_SPECIFIED ? 'T' : '-',\n\t       e->flags & ELEMENT_SKIPPABLE ? 'S' : '-',\n\t       e->flags & ELEMENT_CONDITIONAL ? 'C' : '-',\n\t       \"-tTqQcaro\"[e->compound],\n\t       level, \"\",\n\t       tag,\n\t       tname,\n\t       name,\n\t       e->action ? e->action->name : \"\");\n\tif (e->compound == TYPE_REF)\n\t\tdump_element(e->type->type->element, level + 3);\n\telse\n\t\tfor (c = e->children; c; c = c->next)\n\t\t\tdump_element(c, level + 3);\n}\n\nstatic void dump_elements(void)\n{\n\tif (debug_opt)\n\t\tdump_element(type_list[0].element, 0);\n}\n\nstatic void render_element(FILE *out, struct element *e, struct element *tag);\nstatic void render_out_of_line_list(FILE *out);\n\nstatic int nr_entries;\nstatic int render_depth = 1;\nstatic struct element *render_list, **render_list_p = &render_list;\n\n__attribute__((format(printf, 2, 3)))\nstatic void render_opcode(FILE *out, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (out) {\n\t\tfprintf(out, \"\\t[%4d] =%*s\", nr_entries, render_depth, \"\");\n\t\tva_start(va, fmt);\n\t\tvfprintf(out, fmt, va);\n\t\tva_end(va);\n\t}\n\tnr_entries++;\n}\n\n__attribute__((format(printf, 2, 3)))\nstatic void render_more(FILE *out, const char *fmt, ...)\n{\n\tva_list va;\n\n\tif (out) {\n\t\tva_start(va, fmt);\n\t\tvfprintf(out, fmt, va);\n\t\tva_end(va);\n\t}\n}\n\n \nstatic void render(FILE *out, FILE *hdr)\n{\n\tstruct element *e;\n\tstruct action *action;\n\tstruct type *root;\n\tint index;\n\n\tfprintf(hdr, \"/*\\n\");\n\tfprintf(hdr, \" * Automatically generated by asn1_compiler.  Do not edit\\n\");\n\tfprintf(hdr, \" *\\n\");\n\tfprintf(hdr, \" * ASN.1 parser for %s\\n\", grammar_name);\n\tfprintf(hdr, \" */\\n\");\n\tfprintf(hdr, \"#include <linux/asn1_decoder.h>\\n\");\n\tfprintf(hdr, \"\\n\");\n\tfprintf(hdr, \"extern const struct asn1_decoder %s_decoder;\\n\", grammar_name);\n\tif (ferror(hdr)) {\n\t\tperror(headername);\n\t\texit(1);\n\t}\n\n\tfprintf(out, \"/*\\n\");\n\tfprintf(out, \" * Automatically generated by asn1_compiler.  Do not edit\\n\");\n\tfprintf(out, \" *\\n\");\n\tfprintf(out, \" * ASN.1 parser for %s\\n\", grammar_name);\n\tfprintf(out, \" */\\n\");\n\tfprintf(out, \"#include <linux/asn1_ber_bytecode.h>\\n\");\n\tfprintf(out, \"#include \\\"%s.asn1.h\\\"\\n\", grammar_name);\n\tfprintf(out, \"\\n\");\n\tif (ferror(out)) {\n\t\tperror(outputname);\n\t\texit(1);\n\t}\n\n\t \n\tfprintf(hdr, \"\\n\");\n\tindex = 0;\n\tfor (action = action_list; action; action = action->next) {\n\t\taction->index = index++;\n\t\tfprintf(hdr,\n\t\t\t\"extern int %s(void *, size_t, unsigned char,\"\n\t\t\t\" const void *, size_t);\\n\",\n\t\t\taction->name);\n\t}\n\tfprintf(hdr, \"\\n\");\n\n\tfprintf(out, \"enum %s_actions {\\n\", grammar_name);\n\tfor (action = action_list; action; action = action->next)\n\t\tfprintf(out, \"\\tACT_%s = %u,\\n\",\n\t\t\taction->name, action->index);\n\tfprintf(out, \"\\tNR__%s_actions = %u\\n\", grammar_name, nr_actions);\n\tfprintf(out, \"};\\n\");\n\n\tfprintf(out, \"\\n\");\n\tfprintf(out, \"static const asn1_action_t %s_action_table[NR__%s_actions] = {\\n\",\n\t\tgrammar_name, grammar_name);\n\tfor (action = action_list; action; action = action->next)\n\t\tfprintf(out, \"\\t[%4u] = %s,\\n\", action->index, action->name);\n\tfprintf(out, \"};\\n\");\n\n\tif (ferror(out)) {\n\t\tperror(outputname);\n\t\texit(1);\n\t}\n\n\t \n\tverbose(\"Pass 1\\n\");\n\tnr_entries = 0;\n\troot = &type_list[0];\n\trender_element(NULL, root->element, NULL);\n\trender_opcode(NULL, \"ASN1_OP_COMPLETE,\\n\");\n\trender_out_of_line_list(NULL);\n\n\tfor (e = element_list; e; e = e->list_next)\n\t\te->flags &= ~ELEMENT_RENDERED;\n\n\t \n\tverbose(\"Pass 2\\n\");\n\tfprintf(out, \"\\n\");\n\tfprintf(out, \"static const unsigned char %s_machine[] = {\\n\",\n\t\tgrammar_name);\n\n\tnr_entries = 0;\n\troot = &type_list[0];\n\trender_element(out, root->element, NULL);\n\trender_opcode(out, \"ASN1_OP_COMPLETE,\\n\");\n\trender_out_of_line_list(out);\n\n\tfprintf(out, \"};\\n\");\n\n\tfprintf(out, \"\\n\");\n\tfprintf(out, \"const struct asn1_decoder %s_decoder = {\\n\", grammar_name);\n\tfprintf(out, \"\\t.machine = %s_machine,\\n\", grammar_name);\n\tfprintf(out, \"\\t.machlen = sizeof(%s_machine),\\n\", grammar_name);\n\tfprintf(out, \"\\t.actions = %s_action_table,\\n\", grammar_name);\n\tfprintf(out, \"};\\n\");\n}\n\n \nstatic void render_out_of_line_list(FILE *out)\n{\n\tstruct element *e, *ce;\n\tconst char *act;\n\tint entry;\n\n\twhile ((e = render_list)) {\n\t\trender_list = e->render_next;\n\t\tif (!render_list)\n\t\t\trender_list_p = &render_list;\n\n\t\trender_more(out, \"\\n\");\n\t\te->entry_index = entry = nr_entries;\n\t\trender_depth++;\n\t\tfor (ce = e->children; ce; ce = ce->next)\n\t\t\trender_element(out, ce, NULL);\n\t\trender_depth--;\n\n\t\tact = e->action ? \"_ACT\" : \"\";\n\t\tswitch (e->compound) {\n\t\tcase SEQUENCE:\n\t\t\trender_opcode(out, \"ASN1_OP_END_SEQ%s,\\n\", act);\n\t\t\tbreak;\n\t\tcase SEQUENCE_OF:\n\t\t\trender_opcode(out, \"ASN1_OP_END_SEQ_OF%s,\\n\", act);\n\t\t\trender_opcode(out, \"_jump_target(%u),\\n\", entry);\n\t\t\tbreak;\n\t\tcase SET:\n\t\t\trender_opcode(out, \"ASN1_OP_END_SET%s,\\n\", act);\n\t\t\tbreak;\n\t\tcase SET_OF:\n\t\t\trender_opcode(out, \"ASN1_OP_END_SET_OF%s,\\n\", act);\n\t\t\trender_opcode(out, \"_jump_target(%u),\\n\", entry);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (e->action)\n\t\t\trender_opcode(out, \"_action(ACT_%s),\\n\",\n\t\t\t\t      e->action->name);\n\t\trender_opcode(out, \"ASN1_OP_RETURN,\\n\");\n\t}\n}\n\n \nstatic void render_element(FILE *out, struct element *e, struct element *tag)\n{\n\tstruct element *ec, *x;\n\tconst char *cond, *act;\n\tint entry, skippable = 0, outofline = 0;\n\n\tif (e->flags & ELEMENT_SKIPPABLE ||\n\t    (tag && tag->flags & ELEMENT_SKIPPABLE))\n\t\tskippable = 1;\n\n\tif ((e->type_def && e->type_def->ref_count > 1) ||\n\t    skippable)\n\t\toutofline = 1;\n\n\tif (e->type_def && out) {\n\t\trender_more(out, \"\\t// %s\\n\", e->type_def->name->content);\n\t}\n\n\t \n\tcond = (e->flags & ELEMENT_CONDITIONAL ||\n\t\t(tag && tag->flags & ELEMENT_CONDITIONAL)) ? \"COND_\" : \"\";\n\tact = e->action ? \"_ACT\" : \"\";\n\tswitch (e->compound) {\n\tcase ANY:\n\t\trender_opcode(out, \"ASN1_OP_%sMATCH_ANY%s%s,\",\n\t\t\t      cond, act, skippable ? \"_OR_SKIP\" : \"\");\n\t\tif (e->name)\n\t\t\trender_more(out, \"\\t\\t// %s\", e->name->content);\n\t\trender_more(out, \"\\n\");\n\t\tgoto dont_render_tag;\n\n\tcase TAG_OVERRIDE:\n\t\trender_element(out, e->children, e);\n\t\treturn;\n\n\tcase SEQUENCE:\n\tcase SEQUENCE_OF:\n\tcase SET:\n\tcase SET_OF:\n\t\trender_opcode(out, \"ASN1_OP_%sMATCH%s%s,\",\n\t\t\t      cond,\n\t\t\t      outofline ? \"_JUMP\" : \"\",\n\t\t\t      skippable ? \"_OR_SKIP\" : \"\");\n\t\tbreak;\n\n\tcase CHOICE:\n\t\tgoto dont_render_tag;\n\n\tcase TYPE_REF:\n\t\tif (e->class == ASN1_UNIV && e->method == ASN1_PRIM && e->tag == 0)\n\t\t\tgoto dont_render_tag;\n\tdefault:\n\t\trender_opcode(out, \"ASN1_OP_%sMATCH%s%s,\",\n\t\t\t      cond, act,\n\t\t\t      skippable ? \"_OR_SKIP\" : \"\");\n\t\tbreak;\n\t}\n\n\tx = tag ?: e;\n\tif (x->name)\n\t\trender_more(out, \"\\t\\t// %s\", x->name->content);\n\trender_more(out, \"\\n\");\n\n\t \n\tif (!tag || !(tag->flags & ELEMENT_TAG_SPECIFIED))\n\t\ttag = e;\n\n\tif (tag->class == ASN1_UNIV &&\n\t    tag->tag != 14 &&\n\t    tag->tag != 15 &&\n\t    tag->tag != 31)\n\t\trender_opcode(out, \"_tag(%s, %s, %s),\\n\",\n\t\t\t      asn1_classes[tag->class],\n\t\t\t      asn1_methods[tag->method | e->method],\n\t\t\t      asn1_universal_tags[tag->tag]);\n\telse\n\t\trender_opcode(out, \"_tagn(%s, %s, %2u),\\n\",\n\t\t\t      asn1_classes[tag->class],\n\t\t\t      asn1_methods[tag->method | e->method],\n\t\t\t      tag->tag);\n\ttag = NULL;\ndont_render_tag:\n\n\t \n\tswitch (e->compound) {\n\tcase TYPE_REF:\n\t\trender_element(out, e->type->type->element, tag);\n\t\tif (e->action)\n\t\t\trender_opcode(out, \"ASN1_OP_%sACT,\\n\",\n\t\t\t\t      skippable ? \"MAYBE_\" : \"\");\n\t\tbreak;\n\n\tcase SEQUENCE:\n\t\tif (outofline) {\n\t\t\t \n\t\t\trender_opcode(out, \"_jump_target(%u),\", e->entry_index);\n\t\t\tif (e->type_def && e->type_def->name)\n\t\t\t\trender_more(out, \"\\t\\t// --> %s\",\n\t\t\t\t\t    e->type_def->name->content);\n\t\t\trender_more(out, \"\\n\");\n\t\t\tif (!(e->flags & ELEMENT_RENDERED)) {\n\t\t\t\te->flags |= ELEMENT_RENDERED;\n\t\t\t\t*render_list_p = e;\n\t\t\t\trender_list_p = &e->render_next;\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\t \n\t\t\trender_depth++;\n\t\t\tfor (ec = e->children; ec; ec = ec->next)\n\t\t\t\trender_element(out, ec, NULL);\n\t\t\trender_depth--;\n\t\t\trender_opcode(out, \"ASN1_OP_END_SEQ%s,\\n\", act);\n\t\t}\n\t\tbreak;\n\n\tcase SEQUENCE_OF:\n\tcase SET_OF:\n\t\tif (outofline) {\n\t\t\t \n\t\t\trender_opcode(out, \"_jump_target(%u),\", e->entry_index);\n\t\t\tif (e->type_def && e->type_def->name)\n\t\t\t\trender_more(out, \"\\t\\t// --> %s\",\n\t\t\t\t\t    e->type_def->name->content);\n\t\t\trender_more(out, \"\\n\");\n\t\t\tif (!(e->flags & ELEMENT_RENDERED)) {\n\t\t\t\te->flags |= ELEMENT_RENDERED;\n\t\t\t\t*render_list_p = e;\n\t\t\t\trender_list_p = &e->render_next;\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\t \n\t\t\tentry = nr_entries;\n\t\t\trender_depth++;\n\t\t\trender_element(out, e->children, NULL);\n\t\t\trender_depth--;\n\t\t\tif (e->compound == SEQUENCE_OF)\n\t\t\t\trender_opcode(out, \"ASN1_OP_END_SEQ_OF%s,\\n\", act);\n\t\t\telse\n\t\t\t\trender_opcode(out, \"ASN1_OP_END_SET_OF%s,\\n\", act);\n\t\t\trender_opcode(out, \"_jump_target(%u),\\n\", entry);\n\t\t}\n\t\tbreak;\n\n\tcase SET:\n\t\t \n\t\tfprintf(stderr, \"The ASN.1 SET type is not currently supported.\\n\");\n\t\texit(1);\n\n\tcase CHOICE:\n\t\tfor (ec = e->children; ec; ec = ec->next)\n\t\t\trender_element(out, ec, ec);\n\t\tif (!skippable)\n\t\t\trender_opcode(out, \"ASN1_OP_COND_FAIL,\\n\");\n\t\tif (e->action)\n\t\t\trender_opcode(out, \"ASN1_OP_ACT,\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (e->action)\n\t\trender_opcode(out, \"_action(ACT_%s),\\n\", e->action->name);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}