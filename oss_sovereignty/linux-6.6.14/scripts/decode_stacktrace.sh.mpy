{
  "module_name": "decode_stacktrace.sh",
  "hash_id": "cc96d8a12af5658f71379b28bf31927c943c9676f1ab1b6aa46033d8cc64251b",
  "original_prompt": "Ingested from linux-6.6.14/scripts/decode_stacktrace.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n# (c) 2014, Sasha Levin <sasha.levin@oracle.com>\n#set -x\n\nusage() {\n\techo \"Usage:\"\n\techo \"\t$0 -r <release> | <vmlinux> [<base path>|auto] [<modules path>]\"\n}\n\n# Try to find a Rust demangler\nif type llvm-cxxfilt >/dev/null 2>&1 ; then\n\tcppfilt=llvm-cxxfilt\nelif type c++filt >/dev/null 2>&1 ; then\n\tcppfilt=c++filt\n\tcppfilt_opts=-i\nfi\n\nUTIL_SUFFIX=\nif [[ -z ${LLVM:-} ]]; then\n\tUTIL_PREFIX=${CROSS_COMPILE:-}\nelse\n\tUTIL_PREFIX=llvm-\n\tif [[ ${LLVM} == */ ]]; then\n\t\tUTIL_PREFIX=${LLVM}${UTIL_PREFIX}\n\telif [[ ${LLVM} == -* ]]; then\n\t\tUTIL_SUFFIX=${LLVM}\n\tfi\nfi\n\nREADELF=${UTIL_PREFIX}readelf${UTIL_SUFFIX}\nADDR2LINE=${UTIL_PREFIX}addr2line${UTIL_SUFFIX}\n\nif [[ $1 == \"-r\" ]] ; then\n\tvmlinux=\"\"\n\tbasepath=\"auto\"\n\tmodpath=\"\"\n\trelease=$2\n\n\tfor fn in {,/usr/lib/debug}/boot/vmlinux-$release{,.debug} /lib/modules/$release{,/build}/vmlinux ; do\n\t\tif [ -e \"$fn\" ] ; then\n\t\t\tvmlinux=$fn\n\t\t\tbreak\n\t\tfi\n\tdone\n\n\tif [[ $vmlinux == \"\" ]] ; then\n\t\techo \"ERROR! vmlinux image for release $release is not found\" >&2\n\t\tusage\n\t\texit 2\n\tfi\nelse\n\tvmlinux=$1\n\tbasepath=${2-auto}\n\tmodpath=$3\n\trelease=\"\"\n\tdebuginfod=\n\n\t# Can we use debuginfod-find?\n\tif type debuginfod-find >/dev/null 2>&1 ; then\n\t\tdebuginfod=${1-only}\n\tfi\n\n\tif [[ $vmlinux == \"\" && -z $debuginfod ]] ; then\n\t\techo \"ERROR! vmlinux image must be specified\" >&2\n\t\tusage\n\t\texit 1\n\tfi\nfi\n\ndeclare aarray_support=true\ndeclare -A cache 2>/dev/null\nif [[ $? != 0 ]]; then\n\taarray_support=false\nelse\n\tdeclare -A modcache\nfi\n\nfind_module() {\n\tif [[ -n $debuginfod ]] ; then\n\t\tif [[ -n $modbuildid ]] ; then\n\t\t\tdebuginfod-find debuginfo $modbuildid && return\n\t\tfi\n\n\t\t# Only using debuginfod so don't try to find vmlinux module path\n\t\tif [[ $debuginfod == \"only\" ]] ; then\n\t\t\treturn\n\t\tfi\n\tfi\n\n\tif [[ \"$modpath\" != \"\" ]] ; then\n\t\tfor fn in $(find \"$modpath\" -name \"${module//_/[-_]}.ko*\") ; do\n\t\t\tif ${READELF} -WS \"$fn\" | grep -qwF .debug_line ; then\n\t\t\t\techo $fn\n\t\t\t\treturn\n\t\t\tfi\n\t\tdone\n\t\treturn 1\n\tfi\n\n\tmodpath=$(dirname \"$vmlinux\")\n\tfind_module && return\n\n\tif [[ $release == \"\" ]] ; then\n\t\trelease=$(gdb -ex 'print init_uts_ns.name.release' -ex 'quit' -quiet -batch \"$vmlinux\" 2>/dev/null | sed -n 's/\\$1 = \"\\(.*\\)\".*/\\1/p')\n\tfi\n\n\tfor dn in {/usr/lib/debug,}/lib/modules/$release ; do\n\t\tif [ -e \"$dn\" ] ; then\n\t\t\tmodpath=\"$dn\"\n\t\t\tfind_module && return\n\t\tfi\n\tdone\n\n\tmodpath=\"\"\n\treturn 1\n}\n\nparse_symbol() {\n\t# The structure of symbol at this point is:\n\t#   ([name]+[offset]/[total length])\n\t#\n\t# For example:\n\t#   do_basic_setup+0x9c/0xbf\n\n\tif [[ $module == \"\" ]] ; then\n\t\tlocal objfile=$vmlinux\n\telif [[ $aarray_support == true && \"${modcache[$module]+isset}\" == \"isset\" ]]; then\n\t\tlocal objfile=${modcache[$module]}\n\telse\n\t\tlocal objfile=$(find_module)\n\t\tif [[ $objfile == \"\" ]] ; then\n\t\t\techo \"WARNING! Modules path isn't set, but is needed to parse this symbol\" >&2\n\t\t\treturn\n\t\tfi\n\t\tif [[ $aarray_support == true ]]; then\n\t\t\tmodcache[$module]=$objfile\n\t\tfi\n\tfi\n\n\t# Remove the englobing parenthesis\n\tsymbol=${symbol#\\(}\n\tsymbol=${symbol%\\)}\n\n\t# Strip segment\n\tlocal segment\n\tif [[ $symbol == *:* ]] ; then\n\t\tsegment=${symbol%%:*}:\n\t\tsymbol=${symbol#*:}\n\tfi\n\n\t# Strip the symbol name so that we could look it up\n\tlocal name=${symbol%+*}\n\n\t# Use 'nm vmlinux' to figure out the base address of said symbol.\n\t# It's actually faster to call it every time than to load it\n\t# all into bash.\n\tif [[ $aarray_support == true && \"${cache[$module,$name]+isset}\" == \"isset\" ]]; then\n\t\tlocal base_addr=${cache[$module,$name]}\n\telse\n\t\tlocal base_addr=$(nm \"$objfile\" 2>/dev/null | awk '$3 == \"'$name'\" && ($2 == \"t\" || $2 == \"T\") {print $1; exit}')\n\t\tif [[ $base_addr == \"\" ]] ; then\n\t\t\t# address not found\n\t\t\treturn\n\t\tfi\n\t\tif [[ $aarray_support == true ]]; then\n\t\t\tcache[$module,$name]=\"$base_addr\"\n\t\tfi\n\tfi\n\t# Let's start doing the math to get the exact address into the\n\t# symbol. First, strip out the symbol total length.\n\tlocal expr=${symbol%/*}\n\n\t# Now, replace the symbol name with the base address we found\n\t# before.\n\texpr=${expr/$name/0x$base_addr}\n\n\t# Evaluate it to find the actual address\n\texpr=$((expr))\n\tlocal address=$(printf \"%x\\n\" \"$expr\")\n\n\t# Pass it to addr2line to get filename and line number\n\t# Could get more than one result\n\tif [[ $aarray_support == true && \"${cache[$module,$address]+isset}\" == \"isset\" ]]; then\n\t\tlocal code=${cache[$module,$address]}\n\telse\n\t\tlocal code=$(${ADDR2LINE} -i -e \"$objfile\" \"$address\" 2>/dev/null)\n\t\tif [[ $aarray_support == true ]]; then\n\t\t\tcache[$module,$address]=$code\n\t\tfi\n\tfi\n\n\t# addr2line doesn't return a proper error code if it fails, so\n\t# we detect it using the value it prints so that we could preserve\n\t# the offset/size into the function and bail out\n\tif [[ $code == \"??:0\" ]]; then\n\t\treturn\n\tfi\n\n\t# Strip out the base of the path on each line\n\tcode=$(while read -r line; do echo \"${line#$basepath/}\"; done <<< \"$code\")\n\n\t# In the case of inlines, move everything to same line\n\tcode=${code//$'\\n'/' '}\n\n\t# Demangle if the name looks like a Rust symbol and if\n\t# we got a Rust demangler\n\tif [[ $name =~ ^_R && $cppfilt != \"\" ]] ; then\n\t\tname=$(\"$cppfilt\" \"$cppfilt_opts\" \"$name\")\n\tfi\n\n\t# Replace old address with pretty line numbers\n\tsymbol=\"$segment$name ($code)\"\n}\n\ndebuginfod_get_vmlinux() {\n\tlocal vmlinux_buildid=${1##* }\n\n\tif [[ $vmlinux != \"\" ]]; then\n\t\treturn\n\tfi\n\n\tif [[ $vmlinux_buildid =~ ^[0-9a-f]+ ]]; then\n\t\tvmlinux=$(debuginfod-find debuginfo $vmlinux_buildid)\n\t\tif [[ $? -ne 0 ]] ; then\n\t\t\techo \"ERROR! vmlinux image not found via debuginfod-find\" >&2\n\t\t\tusage\n\t\t\texit 2\n\t\tfi\n\t\treturn\n\tfi\n\techo \"ERROR! Build ID for vmlinux not found. Try passing -r or specifying vmlinux\" >&2\n\tusage\n\texit 2\n}\n\ndecode_code() {\n\tlocal scripts=`dirname \"${BASH_SOURCE[0]}\"`\n\n\techo \"$1\" | $scripts/decodecode\n}\n\nhandle_line() {\n\tif [[ $basepath == \"auto\" && $vmlinux != \"\" ]] ; then\n\t\tmodule=\"\"\n\t\tsymbol=\"kernel_init+0x0/0x0\"\n\t\tparse_symbol\n\t\tbasepath=${symbol#kernel_init (}\n\t\tbasepath=${basepath%/init/main.c:*)}\n\tfi\n\n\tlocal words\n\n\t# Tokenize\n\tread -a words <<<\"$1\"\n\n\t# Remove hex numbers. Do it ourselves until it happens in the\n\t# kernel\n\n\t# We need to know the index of the last element before we\n\t# remove elements because arrays are sparse\n\tlocal last=$(( ${#words[@]} - 1 ))\n\n\tfor i in \"${!words[@]}\"; do\n\t\t# Remove the address\n\t\tif [[ ${words[$i]} =~ \\[\\<([^]]+)\\>\\] ]]; then\n\t\t\tunset words[$i]\n\t\tfi\n\n\t\t# Format timestamps with tabs\n\t\tif [[ ${words[$i]} == \\[ && ${words[$i+1]} == *\\] ]]; then\n\t\t\tunset words[$i]\n\t\t\twords[$i+1]=$(printf \"[%13s\\n\" \"${words[$i+1]}\")\n\t\tfi\n\tdone\n\n\tif [[ ${words[$last]} =~ ^[0-9a-f]+\\] ]]; then\n\t\twords[$last-1]=\"${words[$last-1]} ${words[$last]}\"\n\t\tunset words[$last]\n\t\tlast=$(( $last - 1 ))\n\tfi\n\n\tif [[ ${words[$last]} =~ \\[([^]]+)\\] ]]; then\n\t\tmodule=${words[$last]}\n\t\tmodule=${module#\\[}\n\t\tmodule=${module%\\]}\n\t\tmodbuildid=${module#* }\n\t\tmodule=${module% *}\n\t\tif [[ $modbuildid == $module ]]; then\n\t\t\tmodbuildid=\n\t\tfi\n\t\tsymbol=${words[$last-1]}\n\t\tunset words[$last-1]\n\telse\n\t\t# The symbol is the last element, process it\n\t\tsymbol=${words[$last]}\n\t\tmodule=\n\t\tmodbuildid=\n\tfi\n\n\tunset words[$last]\n\tparse_symbol # modifies $symbol\n\n\t# Add up the line number to the symbol\n\techo \"${words[@]}\" \"$symbol $module\"\n}\n\nwhile read line; do\n\t# Let's see if we have an address in the line\n\tif [[ $line =~ \\[\\<([^]]+)\\>\\] ]] ||\n\t   [[ $line =~ [^+\\ ]+\\+0x[0-9a-f]+/0x[0-9a-f]+ ]]; then\n\t\t# Translate address to line numbers\n\t\thandle_line \"$line\"\n\t# Is it a code line?\n\telif [[ $line == *Code:* ]]; then\n\t\tdecode_code \"$line\"\n\t# Is it a version line?\n\telif [[ -n $debuginfod && $line =~ PID:\\ [0-9]+\\ Comm: ]]; then\n\t\tdebuginfod_get_vmlinux \"$line\"\n\telse\n\t\t# Nothing special in this line, show it as is\n\t\techo \"$line\"\n\tfi\ndone\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}