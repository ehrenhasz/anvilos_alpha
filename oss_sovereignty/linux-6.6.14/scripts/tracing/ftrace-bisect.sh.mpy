{
  "module_name": "ftrace-bisect.sh",
  "hash_id": "8146d2ea5a7fdaad45242c9ee907eb1e235b359ed5b19cb9b5d361fa532ed6a2",
  "original_prompt": "Ingested from linux-6.6.14/scripts/tracing/ftrace-bisect.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Here's how to use this:\n#\n# This script is used to help find functions that are being traced by function\n# tracer or function graph tracing that causes the machine to reboot, hang, or\n# crash. Here's the steps to take.\n#\n# First, determine if function tracing is working with a single function:\n#\n#   (note, if this is a problem with function_graph tracing, then simply\n#    replace \"function\" with \"function_graph\" in the following steps).\n#\n#  # cd /sys/kernel/tracing\n#  # echo schedule > set_ftrace_filter\n#  # echo function > current_tracer\n#\n# If this works, then we know that something is being traced that shouldn't be.\n#\n#  # echo nop > current_tracer\n#\n# Starting with v5.1 this can be done with numbers, making it much faster:\n#\n# The old (slow) way, for kernels before v5.1.\n#\n# [old-way] # cat available_filter_functions > ~/full-file\n#\n# [old-way] *** Note ***  this process will take several minutes to update the\n# [old-way] filters. Setting multiple functions is an O(n^2) operation, and we\n# [old-way] are dealing with thousands of functions. So go have coffee, talk\n# [old-way] with your coworkers, read facebook. And eventually, this operation\n# [old-way] will end.\n#\n# The new way (using numbers) is an O(n) operation, and usually takes less than a second.\n#\n# seq `wc -l available_filter_functions | cut -d' ' -f1` > ~/full-file\n#\n# This will create a sequence of numbers that match the functions in\n# available_filter_functions, and when echoing in a number into the\n# set_ftrace_filter file, it will enable the corresponding function in\n# O(1) time. Making enabling all functions O(n) where n is the number of\n# functions to enable.\n#\n# For either the new or old way, the rest of the operations remain the same.\n#\n#  # ftrace-bisect ~/full-file ~/test-file ~/non-test-file\n#  # cat ~/test-file > set_ftrace_filter\n#\n#  # echo function > current_tracer\n#\n# If it crashes, we know that ~/test-file has a bad function.\n#\n#   Reboot back to test kernel.\n#\n#     # cd /sys/kernel/tracing\n#     # mv ~/test-file ~/full-file\n#\n# If it didn't crash.\n#\n#     # echo nop > current_tracer\n#     # mv ~/non-test-file ~/full-file\n#\n# Get rid of the other test file from previous run (or save them off somewhere).\n#  # rm -f ~/test-file ~/non-test-file\n#\n# And start again:\n#\n#  # ftrace-bisect ~/full-file ~/test-file ~/non-test-file\n#\n# The good thing is, because this cuts the number of functions in ~/test-file\n# by half, the cat of it into set_ftrace_filter takes half as long each\n# iteration, so don't talk so much at the water cooler the second time.\n#\n# Eventually, if you did this correctly, you will get down to the problem\n# function, and all we need to do is to notrace it.\n#\n# The way to figure out if the problem function is bad, just do:\n#\n#  # echo <problem-function> > set_ftrace_notrace\n#  # echo > set_ftrace_filter\n#  # echo function > current_tracer\n#\n# And if it doesn't crash, we are done.\n#\n# If it does crash, do this again (there's more than one problem function)\n# but you need to echo the problem function(s) into set_ftrace_notrace before\n# enabling function tracing in the above steps. Or if you can compile the\n# kernel, annotate the problem functions with \"notrace\" and start again.\n#\n\n\nif [ $# -ne 3 ]; then\n  echo 'usage: ftrace-bisect full-file test-file  non-test-file'\n  exit\nfi\n\nfull=$1\ntest=$2\nnontest=$3\n\nx=`cat $full | wc -l`\nif [ $x -eq 1 ]; then\n\techo \"There's only one function left, must be the bad one\"\n\tcat $full\n\texit 0\nfi\n\nlet x=$x/2\nlet y=$x+1\n\nif [ ! -f $full ]; then\n\techo \"$full does not exist\"\n\texit 1\nfi\n\nif [ -f $test ]; then\n\techo -n \"$test exists, delete it? [y/N]\"\n\tread a\n\tif [ \"$a\" != \"y\" -a \"$a\" != \"Y\" ]; then\n\t\texit 1\n\tfi\nfi\n\nif [ -f $nontest ]; then\n\techo -n \"$nontest exists, delete it? [y/N]\"\n\tread a\n\tif [ \"$a\" != \"y\" -a \"$a\" != \"Y\" ]; then\n\t\texit 1\n\tfi\nfi\n\nsed -ne \"1,${x}p\" $full > $test\nsed -ne \"$y,\\$p\" $full > $nontest\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}