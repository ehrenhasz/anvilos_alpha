{
  "module_name": "sorttable.c",
  "hash_id": "9c0699647a5a2311c4a8d00bec0464d42a580e24fc9a56e006759e15e1b36e1b",
  "original_prompt": "Ingested from linux-6.6.14/scripts/sorttable.c",
  "human_readable_source": "\n \n\n \n\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <getopt.h>\n#include <elf.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <pthread.h>\n\n#include <tools/be_byteshift.h>\n#include <tools/le_byteshift.h>\n\n#ifndef EM_ARCOMPACT\n#define EM_ARCOMPACT\t93\n#endif\n\n#ifndef EM_XTENSA\n#define EM_XTENSA\t94\n#endif\n\n#ifndef EM_AARCH64\n#define EM_AARCH64\t183\n#endif\n\n#ifndef EM_MICROBLAZE\n#define EM_MICROBLAZE\t189\n#endif\n\n#ifndef EM_ARCV2\n#define EM_ARCV2\t195\n#endif\n\n#ifndef EM_RISCV\n#define EM_RISCV\t243\n#endif\n\n#ifndef EM_LOONGARCH\n#define EM_LOONGARCH\t258\n#endif\n\nstatic uint32_t (*r)(const uint32_t *);\nstatic uint16_t (*r2)(const uint16_t *);\nstatic uint64_t (*r8)(const uint64_t *);\nstatic void (*w)(uint32_t, uint32_t *);\nstatic void (*w2)(uint16_t, uint16_t *);\nstatic void (*w8)(uint64_t, uint64_t *);\ntypedef void (*table_sort_t)(char *, int);\n\n \nstatic void *mmap_file(char const *fname, size_t *size)\n{\n\tint fd;\n\tstruct stat sb;\n\tvoid *addr = NULL;\n\n\tfd = open(fname, O_RDWR);\n\tif (fd < 0) {\n\t\tperror(fname);\n\t\treturn NULL;\n\t}\n\tif (fstat(fd, &sb) < 0) {\n\t\tperror(fname);\n\t\tgoto out;\n\t}\n\tif (!S_ISREG(sb.st_mode)) {\n\t\tfprintf(stderr, \"not a regular file: %s\\n\", fname);\n\t\tgoto out;\n\t}\n\n\taddr = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (addr == MAP_FAILED) {\n\t\tfprintf(stderr, \"Could not mmap file: %s\\n\", fname);\n\t\tgoto out;\n\t}\n\n\t*size = sb.st_size;\n\nout:\n\tclose(fd);\n\treturn addr;\n}\n\nstatic uint32_t rbe(const uint32_t *x)\n{\n\treturn get_unaligned_be32(x);\n}\n\nstatic uint16_t r2be(const uint16_t *x)\n{\n\treturn get_unaligned_be16(x);\n}\n\nstatic uint64_t r8be(const uint64_t *x)\n{\n\treturn get_unaligned_be64(x);\n}\n\nstatic uint32_t rle(const uint32_t *x)\n{\n\treturn get_unaligned_le32(x);\n}\n\nstatic uint16_t r2le(const uint16_t *x)\n{\n\treturn get_unaligned_le16(x);\n}\n\nstatic uint64_t r8le(const uint64_t *x)\n{\n\treturn get_unaligned_le64(x);\n}\n\nstatic void wbe(uint32_t val, uint32_t *x)\n{\n\tput_unaligned_be32(val, x);\n}\n\nstatic void w2be(uint16_t val, uint16_t *x)\n{\n\tput_unaligned_be16(val, x);\n}\n\nstatic void w8be(uint64_t val, uint64_t *x)\n{\n\tput_unaligned_be64(val, x);\n}\n\nstatic void wle(uint32_t val, uint32_t *x)\n{\n\tput_unaligned_le32(val, x);\n}\n\nstatic void w2le(uint16_t val, uint16_t *x)\n{\n\tput_unaligned_le16(val, x);\n}\n\nstatic void w8le(uint64_t val, uint64_t *x)\n{\n\tput_unaligned_le64(val, x);\n}\n\n \n#define SPECIAL(i) ((i) - (SHN_HIRESERVE + 1))\n\nstatic inline int is_shndx_special(unsigned int i)\n{\n\treturn i != SHN_XINDEX && i >= SHN_LORESERVE && i <= SHN_HIRESERVE;\n}\n\n \nstatic inline unsigned int get_secindex(unsigned int shndx,\n\t\t\t\t\tunsigned int sym_offs,\n\t\t\t\t\tconst Elf32_Word *symtab_shndx_start)\n{\n\tif (is_shndx_special(shndx))\n\t\treturn SPECIAL(shndx);\n\tif (shndx != SHN_XINDEX)\n\t\treturn shndx;\n\treturn r(&symtab_shndx_start[sym_offs]);\n}\n\n \n#include \"sorttable.h\"\n#define SORTTABLE_64\n#include \"sorttable.h\"\n\nstatic int compare_relative_table(const void *a, const void *b)\n{\n\tint32_t av = (int32_t)r(a);\n\tint32_t bv = (int32_t)r(b);\n\n\tif (av < bv)\n\t\treturn -1;\n\tif (av > bv)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void sort_relative_table(char *extab_image, int image_size)\n{\n\tint i = 0;\n\n\t \n\twhile (i < image_size) {\n\t\tuint32_t *loc = (uint32_t *)(extab_image + i);\n\t\tw(r(loc) + i, loc);\n\t\ti += 4;\n\t}\n\n\tqsort(extab_image, image_size / 8, 8, compare_relative_table);\n\n\t \n\ti = 0;\n\twhile (i < image_size) {\n\t\tuint32_t *loc = (uint32_t *)(extab_image + i);\n\t\tw(r(loc) - i, loc);\n\t\ti += 4;\n\t}\n}\n\nstatic void sort_relative_table_with_data(char *extab_image, int image_size)\n{\n\tint i = 0;\n\n\twhile (i < image_size) {\n\t\tuint32_t *loc = (uint32_t *)(extab_image + i);\n\n\t\tw(r(loc) + i, loc);\n\t\tw(r(loc + 1) + i + 4, loc + 1);\n\t\t \n\n\t\ti += sizeof(uint32_t) * 3;\n\t}\n\n\tqsort(extab_image, image_size / 12, 12, compare_relative_table);\n\n\ti = 0;\n\twhile (i < image_size) {\n\t\tuint32_t *loc = (uint32_t *)(extab_image + i);\n\n\t\tw(r(loc) - i, loc);\n\t\tw(r(loc + 1) - (i + 4), loc + 1);\n\t\t \n\n\t\ti += sizeof(uint32_t) * 3;\n\t}\n}\n\nstatic int do_file(char const *const fname, void *addr)\n{\n\tint rc = -1;\n\tElf32_Ehdr *ehdr = addr;\n\ttable_sort_t custom_sort = NULL;\n\n\tswitch (ehdr->e_ident[EI_DATA]) {\n\tcase ELFDATA2LSB:\n\t\tr\t= rle;\n\t\tr2\t= r2le;\n\t\tr8\t= r8le;\n\t\tw\t= wle;\n\t\tw2\t= w2le;\n\t\tw8\t= w8le;\n\t\tbreak;\n\tcase ELFDATA2MSB:\n\t\tr\t= rbe;\n\t\tr2\t= r2be;\n\t\tr8\t= r8be;\n\t\tw\t= wbe;\n\t\tw2\t= w2be;\n\t\tw8\t= w8be;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"unrecognized ELF data encoding %d: %s\\n\",\n\t\t\tehdr->e_ident[EI_DATA], fname);\n\t\treturn -1;\n\t}\n\n\tif (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0 ||\n\t    (r2(&ehdr->e_type) != ET_EXEC && r2(&ehdr->e_type) != ET_DYN) ||\n\t    ehdr->e_ident[EI_VERSION] != EV_CURRENT) {\n\t\tfprintf(stderr, \"unrecognized ET_EXEC/ET_DYN file %s\\n\", fname);\n\t\treturn -1;\n\t}\n\n\tswitch (r2(&ehdr->e_machine)) {\n\tcase EM_386:\n\tcase EM_AARCH64:\n\tcase EM_LOONGARCH:\n\tcase EM_RISCV:\n\tcase EM_S390:\n\tcase EM_X86_64:\n\t\tcustom_sort = sort_relative_table_with_data;\n\t\tbreak;\n\tcase EM_PARISC:\n\tcase EM_PPC:\n\tcase EM_PPC64:\n\t\tcustom_sort = sort_relative_table;\n\t\tbreak;\n\tcase EM_ARCOMPACT:\n\tcase EM_ARCV2:\n\tcase EM_ARM:\n\tcase EM_MICROBLAZE:\n\tcase EM_MIPS:\n\tcase EM_XTENSA:\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"unrecognized e_machine %d %s\\n\",\n\t\t\tr2(&ehdr->e_machine), fname);\n\t\treturn -1;\n\t}\n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tcase ELFCLASS32:\n\t\tif (r2(&ehdr->e_ehsize) != sizeof(Elf32_Ehdr) ||\n\t\t    r2(&ehdr->e_shentsize) != sizeof(Elf32_Shdr)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"unrecognized ET_EXEC/ET_DYN file: %s\\n\", fname);\n\t\t\tbreak;\n\t\t}\n\t\trc = do_sort_32(ehdr, fname, custom_sort);\n\t\tbreak;\n\tcase ELFCLASS64:\n\t\t{\n\t\tElf64_Ehdr *const ghdr = (Elf64_Ehdr *)ehdr;\n\t\tif (r2(&ghdr->e_ehsize) != sizeof(Elf64_Ehdr) ||\n\t\t    r2(&ghdr->e_shentsize) != sizeof(Elf64_Shdr)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"unrecognized ET_EXEC/ET_DYN file: %s\\n\",\n\t\t\t\tfname);\n\t\t\tbreak;\n\t\t}\n\t\trc = do_sort_64(ghdr, fname, custom_sort);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"unrecognized ELF class %d %s\\n\",\n\t\t\tehdr->e_ident[EI_CLASS], fname);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nint main(int argc, char *argv[])\n{\n\tint i, n_error = 0;   \n\tsize_t size = 0;\n\tvoid *addr = NULL;\n\n\tif (argc < 2) {\n\t\tfprintf(stderr, \"usage: sorttable vmlinux...\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 1; i < argc; i++) {\n\t\taddr = mmap_file(argv[i], &size);\n\t\tif (!addr) {\n\t\t\t++n_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (do_file(argv[i], addr))\n\t\t\t++n_error;\n\n\t\tmunmap(addr, size);\n\t}\n\n\treturn !!n_error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}