{
  "module_name": "checkpatch.pl",
  "hash_id": "8dfc07ec73f56963ee6bd3217885f63e20224ac5cdda1d385538f0576dca1b7b",
  "original_prompt": "Ingested from linux-6.6.14/scripts/checkpatch.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n#\n# (c) 2001, Dave Jones. (the file handling bit)\n# (c) 2005, Joel Schopp <jschopp@austin.ibm.com> (the ugly bit)\n# (c) 2007,2008, Andy Whitcroft <apw@uk.ibm.com> (new conditions, test suite)\n# (c) 2008-2010 Andy Whitcroft <apw@canonical.com>\n# (c) 2010-2018 Joe Perches <joe@perches.com>\n\nuse strict;\nuse warnings;\nuse POSIX;\nuse File::Basename;\nuse Cwd 'abs_path';\nuse Term::ANSIColor qw(:constants);\nuse Encode qw(decode encode);\n\nmy $P = $0;\nmy $D = dirname(abs_path($P));\n\nmy $V = '0.32';\n\nuse Getopt::Long qw(:config no_auto_abbrev);\n\nmy $quiet = 0;\nmy $verbose = 0;\nmy %verbose_messages = ();\nmy %verbose_emitted = ();\nmy $tree = 1;\nmy $chk_signoff = 1;\nmy $chk_patch = 1;\nmy $tst_only;\nmy $emacs = 0;\nmy $terse = 0;\nmy $showfile = 0;\nmy $file = 0;\nmy $git = 0;\nmy %git_commits = ();\nmy $check = 0;\nmy $check_orig = 0;\nmy $summary = 1;\nmy $mailback = 0;\nmy $summary_file = 0;\nmy $show_types = 0;\nmy $list_types = 0;\nmy $fix = 0;\nmy $fix_inplace = 0;\nmy $root;\nmy $gitroot = $ENV{'GIT_DIR'};\n$gitroot = \".git\" if !defined($gitroot);\nmy %debug;\nmy %camelcase = ();\nmy %use_type = ();\nmy @use = ();\nmy %ignore_type = ();\nmy @ignore = ();\nmy $help = 0;\nmy $configuration_file = \".checkpatch.conf\";\nmy $max_line_length = 100;\nmy $ignore_perl_version = 0;\nmy $minimum_perl_version = 5.10.0;\nmy $min_conf_desc_length = 4;\nmy $spelling_file = \"$D/spelling.txt\";\nmy $codespell = 0;\nmy $codespellfile = \"/usr/share/codespell/dictionary.txt\";\nmy $user_codespellfile = \"\";\nmy $conststructsfile = \"$D/const_structs.checkpatch\";\nmy $docsfile = \"$D/../Documentation/dev-tools/checkpatch.rst\";\nmy $typedefsfile;\nmy $color = \"auto\";\nmy $allow_c99_comments = 1; # Can be overridden by --ignore C99_COMMENT_TOLERANCE\n# git output parsing needs US English output, so first set backtick child process LANGUAGE\nmy $git_command ='export LANGUAGE=en_US.UTF-8; git';\nmy $tabsize = 8;\nmy ${CONFIG_} = \"CONFIG_\";\n\nmy %maybe_linker_symbol; # for externs in c exceptions, when seen in *vmlinux.lds.h\n\nsub help {\n\tmy ($exitcode) = @_;\n\n\tprint << \"EOM\";\nUsage: $P [OPTION]... [FILE]...\nVersion: $V\n\nOptions:\n  -q, --quiet                quiet\n  -v, --verbose              verbose mode\n  --no-tree                  run without a kernel tree\n  --no-signoff               do not check for 'Signed-off-by' line\n  --patch                    treat FILE as patchfile (default)\n  --emacs                    emacs compile window format\n  --terse                    one line per report\n  --showfile                 emit diffed file position, not input file position\n  -g, --git                  treat FILE as a single commit or git revision range\n                             single git commit with:\n                               <rev>\n                               <rev>^\n                               <rev>~n\n                             multiple git commits with:\n                               <rev1>..<rev2>\n                               <rev1>...<rev2>\n                               <rev>-<count>\n                             git merges are ignored\n  -f, --file                 treat FILE as regular source file\n  --subjective, --strict     enable more subjective tests\n  --list-types               list the possible message types\n  --types TYPE(,TYPE2...)    show only these comma separated message types\n  --ignore TYPE(,TYPE2...)   ignore various comma separated message types\n  --show-types               show the specific message type in the output\n  --max-line-length=n        set the maximum line length, (default $max_line_length)\n                             if exceeded, warn on patches\n                             requires --strict for use with --file\n  --min-conf-desc-length=n   set the min description length, if shorter, warn\n  --tab-size=n               set the number of spaces for tab (default $tabsize)\n  --root=PATH                PATH to the kernel tree root\n  --no-summary               suppress the per-file summary\n  --mailback                 only produce a report in case of warnings/errors\n  --summary-file             include the filename in summary\n  --debug KEY=[0|1]          turn on/off debugging of KEY, where KEY is one of\n                             'values', 'possible', 'type', and 'attr' (default\n                             is all off)\n  --test-only=WORD           report only warnings/errors containing WORD\n                             literally\n  --fix                      EXPERIMENTAL - may create horrible results\n                             If correctable single-line errors exist, create\n                             \"<inputfile>.EXPERIMENTAL-checkpatch-fixes\"\n                             with potential errors corrected to the preferred\n                             checkpatch style\n  --fix-inplace              EXPERIMENTAL - may create horrible results\n                             Is the same as --fix, but overwrites the input\n                             file.  It's your fault if there's no backup or git\n  --ignore-perl-version      override checking of perl version.  expect\n                             runtime errors.\n  --codespell                Use the codespell dictionary for spelling/typos\n                             (default:$codespellfile)\n  --codespellfile            Use this codespell dictionary\n  --typedefsfile             Read additional types from this file\n  --color[=WHEN]             Use colors 'always', 'never', or only when output\n                             is a terminal ('auto'). Default is 'auto'.\n  --kconfig-prefix=WORD      use WORD as a prefix for Kconfig symbols (default\n                             ${CONFIG_})\n  -h, --help, --version      display this help and exit\n\nWhen FILE is - read standard input.\nEOM\n\n\texit($exitcode);\n}\n\nsub uniq {\n\tmy %seen;\n\treturn grep { !$seen{$_}++ } @_;\n}\n\nsub list_types {\n\tmy ($exitcode) = @_;\n\n\tmy $count = 0;\n\n\tlocal $/ = undef;\n\n\topen(my $script, '<', abs_path($P)) or\n\t    die \"$P: Can't read '$P' $!\\n\";\n\n\tmy $text = <$script>;\n\tclose($script);\n\n\tmy %types = ();\n\t# Also catch when type or level is passed through a variable\n\twhile ($text =~ /(?:(\\bCHK|\\bWARN|\\bERROR|&\\{\\$msg_level})\\s*\\(|\\$msg_type\\s*=)\\s*\"([^\"]+)\"/g) {\n\t\tif (defined($1)) {\n\t\t\tif (exists($types{$2})) {\n\t\t\t\t$types{$2} .= \",$1\" if ($types{$2} ne $1);\n\t\t\t} else {\n\t\t\t\t$types{$2} = $1;\n\t\t\t}\n\t\t} else {\n\t\t\t$types{$2} = \"UNDETERMINED\";\n\t\t}\n\t}\n\n\tprint(\"#\\tMessage type\\n\\n\");\n\tif ($color) {\n\t\tprint(\" ( Color coding: \");\n\t\tprint(RED . \"ERROR\" . RESET);\n\t\tprint(\" | \");\n\t\tprint(YELLOW . \"WARNING\" . RESET);\n\t\tprint(\" | \");\n\t\tprint(GREEN . \"CHECK\" . RESET);\n\t\tprint(\" | \");\n\t\tprint(\"Multiple levels / Undetermined\");\n\t\tprint(\" )\\n\\n\");\n\t}\n\n\tforeach my $type (sort keys %types) {\n\t\tmy $orig_type = $type;\n\t\tif ($color) {\n\t\t\tmy $level = $types{$type};\n\t\t\tif ($level eq \"ERROR\") {\n\t\t\t\t$type = RED . $type . RESET;\n\t\t\t} elsif ($level eq \"WARN\") {\n\t\t\t\t$type = YELLOW . $type . RESET;\n\t\t\t} elsif ($level eq \"CHK\") {\n\t\t\t\t$type = GREEN . $type . RESET;\n\t\t\t}\n\t\t}\n\t\tprint(++$count . \"\\t\" . $type . \"\\n\");\n\t\tif ($verbose && exists($verbose_messages{$orig_type})) {\n\t\t\tmy $message = $verbose_messages{$orig_type};\n\t\t\t$message =~ s/\\n/\\n\\t/g;\n\t\t\tprint(\"\\t\" . $message . \"\\n\\n\");\n\t\t}\n\t}\n\n\texit($exitcode);\n}\n\nmy $conf = which_conf($configuration_file);\nif (-f $conf) {\n\tmy @conf_args;\n\topen(my $conffile, '<', \"$conf\")\n\t    or warn \"$P: Can't find a readable $configuration_file file $!\\n\";\n\n\twhile (<$conffile>) {\n\t\tmy $line = $_;\n\n\t\t$line =~ s/\\s*\\n?$//g;\n\t\t$line =~ s/^\\s*//g;\n\t\t$line =~ s/\\s+/ /g;\n\n\t\tnext if ($line =~ m/^\\s*#/);\n\t\tnext if ($line =~ m/^\\s*$/);\n\n\t\tmy @words = split(\" \", $line);\n\t\tforeach my $word (@words) {\n\t\t\tlast if ($word =~ m/^#/);\n\t\t\tpush (@conf_args, $word);\n\t\t}\n\t}\n\tclose($conffile);\n\tunshift(@ARGV, @conf_args) if @conf_args;\n}\n\nsub load_docs {\n\topen(my $docs, '<', \"$docsfile\")\n\t    or warn \"$P: Can't read the documentation file $docsfile $!\\n\";\n\n\tmy $type = '';\n\tmy $desc = '';\n\tmy $in_desc = 0;\n\n\twhile (<$docs>) {\n\t\tchomp;\n\t\tmy $line = $_;\n\t\t$line =~ s/\\s+$//;\n\n\t\tif ($line =~ /^\\s*\\*\\*(.+)\\*\\*$/) {\n\t\t\tif ($desc ne '') {\n\t\t\t\t$verbose_messages{$type} = trim($desc);\n\t\t\t}\n\t\t\t$type = $1;\n\t\t\t$desc = '';\n\t\t\t$in_desc = 1;\n\t\t} elsif ($in_desc) {\n\t\t\tif ($line =~ /^(?:\\s{4,}|$)/) {\n\t\t\t\t$line =~ s/^\\s{4}//;\n\t\t\t\t$desc .= $line;\n\t\t\t\t$desc .= \"\\n\";\n\t\t\t} else {\n\t\t\t\t$verbose_messages{$type} = trim($desc);\n\t\t\t\t$type = '';\n\t\t\t\t$desc = '';\n\t\t\t\t$in_desc = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ($desc ne '') {\n\t\t$verbose_messages{$type} = trim($desc);\n\t}\n\tclose($docs);\n}\n\n# Perl's Getopt::Long allows options to take optional arguments after a space.\n# Prevent --color by itself from consuming other arguments\nforeach (@ARGV) {\n\tif ($_ eq \"--color\" || $_ eq \"-color\") {\n\t\t$_ = \"--color=$color\";\n\t}\n}\n\nGetOptions(\n\t'q|quiet+'\t=> \\$quiet,\n\t'v|verbose!'\t=> \\$verbose,\n\t'tree!'\t\t=> \\$tree,\n\t'signoff!'\t=> \\$chk_signoff,\n\t'patch!'\t=> \\$chk_patch,\n\t'emacs!'\t=> \\$emacs,\n\t'terse!'\t=> \\$terse,\n\t'showfile!'\t=> \\$showfile,\n\t'f|file!'\t=> \\$file,\n\t'g|git!'\t=> \\$git,\n\t'subjective!'\t=> \\$check,\n\t'strict!'\t=> \\$check,\n\t'ignore=s'\t=> \\@ignore,\n\t'types=s'\t=> \\@use,\n\t'show-types!'\t=> \\$show_types,\n\t'list-types!'\t=> \\$list_types,\n\t'max-line-length=i' => \\$max_line_length,\n\t'min-conf-desc-length=i' => \\$min_conf_desc_length,\n\t'tab-size=i'\t=> \\$tabsize,\n\t'root=s'\t=> \\$root,\n\t'summary!'\t=> \\$summary,\n\t'mailback!'\t=> \\$mailback,\n\t'summary-file!'\t=> \\$summary_file,\n\t'fix!'\t\t=> \\$fix,\n\t'fix-inplace!'\t=> \\$fix_inplace,\n\t'ignore-perl-version!' => \\$ignore_perl_version,\n\t'debug=s'\t=> \\%debug,\n\t'test-only=s'\t=> \\$tst_only,\n\t'codespell!'\t=> \\$codespell,\n\t'codespellfile=s'\t=> \\$user_codespellfile,\n\t'typedefsfile=s'\t=> \\$typedefsfile,\n\t'color=s'\t=> \\$color,\n\t'no-color'\t=> \\$color,\t#keep old behaviors of -nocolor\n\t'nocolor'\t=> \\$color,\t#keep old behaviors of -nocolor\n\t'kconfig-prefix=s'\t=> \\${CONFIG_},\n\t'h|help'\t=> \\$help,\n\t'version'\t=> \\$help\n) or $help = 2;\n\nif ($user_codespellfile) {\n\t# Use the user provided codespell file unconditionally\n\t$codespellfile = $user_codespellfile;\n} elsif (!(-f $codespellfile)) {\n\t# If /usr/share/codespell/dictionary.txt is not present, try to find it\n\t# under codespell's install directory: <codespell_root>/data/dictionary.txt\n\tif (($codespell || $help) && which(\"python3\") ne \"\") {\n\t\tmy $python_codespell_dict = << \"EOF\";\n\nimport os.path as op\nimport codespell_lib\ncodespell_dir = op.dirname(codespell_lib.__file__)\ncodespell_file = op.join(codespell_dir, 'data', 'dictionary.txt')\nprint(codespell_file, end='')\nEOF\n\n\t\tmy $codespell_dict = `python3 -c \"$python_codespell_dict\" 2> /dev/null`;\n\t\t$codespellfile = $codespell_dict if (-f $codespell_dict);\n\t}\n}\n\n# $help is 1 if either -h, --help or --version is passed as option - exitcode: 0\n# $help is 2 if invalid option is passed - exitcode: 1\nhelp($help - 1) if ($help);\n\ndie \"$P: --git cannot be used with --file or --fix\\n\" if ($git && ($file || $fix));\ndie \"$P: --verbose cannot be used with --terse\\n\" if ($verbose && $terse);\n\nif ($color =~ /^[01]$/) {\n\t$color = !$color;\n} elsif ($color =~ /^always$/i) {\n\t$color = 1;\n} elsif ($color =~ /^never$/i) {\n\t$color = 0;\n} elsif ($color =~ /^auto$/i) {\n\t$color = (-t STDOUT);\n} else {\n\tdie \"$P: Invalid color mode: $color\\n\";\n}\n\nload_docs() if ($verbose);\nlist_types(0) if ($list_types);\n\n$fix = 1 if ($fix_inplace);\n$check_orig = $check;\n\nmy $exit = 0;\n\nmy $perl_version_ok = 1;\nif ($^V && $^V lt $minimum_perl_version) {\n\t$perl_version_ok = 0;\n\tprintf \"$P: requires at least perl version %vd\\n\", $minimum_perl_version;\n\texit(1) if (!$ignore_perl_version);\n}\n\n#if no filenames are given, push '-' to read patch from stdin\nif ($#ARGV < 0) {\n\tpush(@ARGV, '-');\n}\n\n# skip TAB size 1 to avoid additional checks on $tabsize - 1\ndie \"$P: Invalid TAB size: $tabsize\\n\" if ($tabsize < 2);\n\nsub hash_save_array_words {\n\tmy ($hashRef, $arrayRef) = @_;\n\n\tmy @array = split(/,/, join(',', @$arrayRef));\n\tforeach my $word (@array) {\n\t\t$word =~ s/\\s*\\n?$//g;\n\t\t$word =~ s/^\\s*//g;\n\t\t$word =~ s/\\s+/ /g;\n\t\t$word =~ tr/[a-z]/[A-Z]/;\n\n\t\tnext if ($word =~ m/^\\s*#/);\n\t\tnext if ($word =~ m/^\\s*$/);\n\n\t\t$hashRef->{$word}++;\n\t}\n}\n\nsub hash_show_words {\n\tmy ($hashRef, $prefix) = @_;\n\n\tif (keys %$hashRef) {\n\t\tprint \"\\nNOTE: $prefix message types:\";\n\t\tforeach my $word (sort keys %$hashRef) {\n\t\t\tprint \" $word\";\n\t\t}\n\t\tprint \"\\n\";\n\t}\n}\n\nhash_save_array_words(\\%ignore_type, \\@ignore);\nhash_save_array_words(\\%use_type, \\@use);\n\nmy $dbg_values = 0;\nmy $dbg_possible = 0;\nmy $dbg_type = 0;\nmy $dbg_attr = 0;\nfor my $key (keys %debug) {\n\t## no critic\n\teval \"\\${dbg_$key} = '$debug{$key}';\";\n\tdie \"$@\" if ($@);\n}\n\nmy $rpt_cleaners = 0;\n\nif ($terse) {\n\t$emacs = 1;\n\t$quiet++;\n}\n\nif ($tree) {\n\tif (defined $root) {\n\t\tif (!top_of_kernel_tree($root)) {\n\t\t\tdie \"$P: $root: --root does not point at a valid tree\\n\";\n\t\t}\n\t} else {\n\t\tif (top_of_kernel_tree('.')) {\n\t\t\t$root = '.';\n\t\t} elsif ($0 =~ m@(.*)/scripts/[^/]*$@ &&\n\t\t\t\t\t\ttop_of_kernel_tree($1)) {\n\t\t\t$root = $1;\n\t\t}\n\t}\n\n\tif (!defined $root) {\n\t\tprint \"Must be run from the top-level dir. of a kernel tree\\n\";\n\t\texit(2);\n\t}\n}\n\nmy $emitted_corrupt = 0;\n\nour $Ident\t= qr{\n\t\t\t[A-Za-z_][A-Za-z\\d_]*\n\t\t\t(?:\\s*\\#\\#\\s*[A-Za-z_][A-Za-z\\d_]*)*\n\t\t}x;\nour $Storage\t= qr{extern|static|asmlinkage};\nour $Sparse\t= qr{\n\t\t\t__user|\n\t\t\t__kernel|\n\t\t\t__force|\n\t\t\t__iomem|\n\t\t\t__must_check|\n\t\t\t__kprobes|\n\t\t\t__ref|\n\t\t\t__refconst|\n\t\t\t__refdata|\n\t\t\t__rcu|\n\t\t\t__private\n\t\t}x;\nour $InitAttributePrefix = qr{__(?:mem|cpu|dev|net_|)};\nour $InitAttributeData = qr{$InitAttributePrefix(?:initdata\\b)};\nour $InitAttributeConst = qr{$InitAttributePrefix(?:initconst\\b)};\nour $InitAttributeInit = qr{$InitAttributePrefix(?:init\\b)};\nour $InitAttribute = qr{$InitAttributeData|$InitAttributeConst|$InitAttributeInit};\n\n# Notes to $Attribute:\n# We need \\b after 'init' otherwise 'initconst' will cause a false positive in a check\nour $Attribute\t= qr{\n\t\t\tconst|\n\t\t\tvolatile|\n\t\t\t__percpu|\n\t\t\t__nocast|\n\t\t\t__safe|\n\t\t\t__bitwise|\n\t\t\t__packed__|\n\t\t\t__packed2__|\n\t\t\t__naked|\n\t\t\t__maybe_unused|\n\t\t\t__always_unused|\n\t\t\t__noreturn|\n\t\t\t__used|\n\t\t\t__cold|\n\t\t\t__pure|\n\t\t\t__noclone|\n\t\t\t__deprecated|\n\t\t\t__read_mostly|\n\t\t\t__ro_after_init|\n\t\t\t__kprobes|\n\t\t\t$InitAttribute|\n\t\t\t____cacheline_aligned|\n\t\t\t____cacheline_aligned_in_smp|\n\t\t\t____cacheline_internodealigned_in_smp|\n\t\t\t__weak|\n\t\t\t__alloc_size\\s*\\(\\s*\\d+\\s*(?:,\\s*\\d+\\s*)?\\)\n\t\t  }x;\nour $Modifier;\nour $Inline\t= qr{inline|__always_inline|noinline|__inline|__inline__};\nour $Member\t= qr{->$Ident|\\.$Ident|\\[[^]]*\\]};\nour $Lval\t= qr{$Ident(?:$Member)*};\n\nour $Int_type\t= qr{(?i)llu|ull|ll|lu|ul|l|u};\nour $Binary\t= qr{(?i)0b[01]+$Int_type?};\nour $Hex\t= qr{(?i)0x[0-9a-f]+$Int_type?};\nour $Int\t= qr{[0-9]+$Int_type?};\nour $Octal\t= qr{0[0-7]+$Int_type?};\nour $String\t= qr{(?:\\b[Lu])?\"[X\\t]*\"};\nour $Float_hex\t= qr{(?i)0x[0-9a-f]+p-?[0-9]+[fl]?};\nour $Float_dec\t= qr{(?i)(?:[0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)(?:e-?[0-9]+)?[fl]?};\nour $Float_int\t= qr{(?i)[0-9]+e-?[0-9]+[fl]?};\nour $Float\t= qr{$Float_hex|$Float_dec|$Float_int};\nour $Constant\t= qr{$Float|$Binary|$Octal|$Hex|$Int};\nour $Assignment\t= qr{\\*\\=|/=|%=|\\+=|-=|<<=|>>=|&=|\\^=|\\|=|=};\nour $Compare    = qr{<=|>=|==|!=|<|(?<!-)>};\nour $Arithmetic = qr{\\+|-|\\*|\\/|%};\nour $Operators\t= qr{\n\t\t\t<=|>=|==|!=|\n\t\t\t=>|->|<<|>>|<|>|!|~|\n\t\t\t&&|\\|\\||,|\\^|\\+\\+|--|&|\\||$Arithmetic\n\t\t  }x;\n\nour $c90_Keywords = qr{do|for|while|if|else|return|goto|continue|switch|default|case|break}x;\n\nour $BasicType;\nour $NonptrType;\nour $NonptrTypeMisordered;\nour $NonptrTypeWithAttr;\nour $Type;\nour $TypeMisordered;\nour $Declare;\nour $DeclareMisordered;\n\nour $NON_ASCII_UTF8\t= qr{\n\t[\\xC2-\\xDF][\\x80-\\xBF]               # non-overlong 2-byte\n\t|  \\xE0[\\xA0-\\xBF][\\x80-\\xBF]        # excluding overlongs\n\t| [\\xE1-\\xEC\\xEE\\xEF][\\x80-\\xBF]{2}  # straight 3-byte\n\t|  \\xED[\\x80-\\x9F][\\x80-\\xBF]        # excluding surrogates\n\t|  \\xF0[\\x90-\\xBF][\\x80-\\xBF]{2}     # planes 1-3\n\t| [\\xF1-\\xF3][\\x80-\\xBF]{3}          # planes 4-15\n\t|  \\xF4[\\x80-\\x8F][\\x80-\\xBF]{2}     # plane 16\n}x;\n\nour $UTF8\t= qr{\n\t[\\x09\\x0A\\x0D\\x20-\\x7E]              # ASCII\n\t| $NON_ASCII_UTF8\n}x;\n\nour $typeC99Typedefs = qr{(?:__)?(?:[us]_?)?int_?(?:8|16|32|64)_t};\nour $typeOtherOSTypedefs = qr{(?x:\n\tu_(?:char|short|int|long) |          # bsd\n\tu(?:nchar|short|int|long)            # sysv\n)};\nour $typeKernelTypedefs = qr{(?x:\n\t(?:__)?(?:u|s|be|le)(?:8|16|32|64)|\n\tatomic_t\n)};\nour $typeStdioTypedefs = qr{(?x:\n\tFILE\n)};\nour $typeTypedefs = qr{(?x:\n\t$typeC99Typedefs\\b|\n\t$typeOtherOSTypedefs\\b|\n\t$typeKernelTypedefs\\b|\n\t$typeStdioTypedefs\\b\n)};\n\nour $zero_initializer = qr{(?:(?:0[xX])?0+$Int_type?|NULL|false)\\b};\n\nour $logFunctions = qr{(?x:\n\tprintk(?:_ratelimited|_once|_deferred_once|_deferred|)|\n\t(?:[a-z0-9]+_){1,2}(?:printk|emerg|alert|crit|err|warning|warn|notice|info|debug|dbg|vdbg|devel|cont|WARN)(?:_ratelimited|_once|)|\n\tTP_printk|\n\tWARN(?:_RATELIMIT|_ONCE|)|\n\tpanic|\n\tMODULE_[A-Z_]+|\n\tseq_vprintf|seq_printf|seq_puts\n)};\n\nour $allocFunctions = qr{(?x:\n\t(?:(?:devm_)?\n\t\t(?:kv|k|v)[czm]alloc(?:_array)?(?:_node)? |\n\t\tkstrdup(?:_const)? |\n\t\tkmemdup(?:_nul)?) |\n\t(?:\\w+)?alloc_skb(?:_ip_align)? |\n\t\t\t\t# dev_alloc_skb/netdev_alloc_skb, et al\n\tdma_alloc_coherent\n)};\n\nour $signature_tags = qr{(?xi:\n\tSigned-off-by:|\n\tCo-developed-by:|\n\tAcked-by:|\n\tTested-by:|\n\tReviewed-by:|\n\tReported-by:|\n\tSuggested-by:|\n\tTo:|\n\tCc:\n)};\n\nour @link_tags = qw(Link Closes);\n\n#Create a search and print patterns for all these strings to be used directly below\nour $link_tags_search = \"\";\nour $link_tags_print = \"\";\nforeach my $entry (@link_tags) {\n\tif ($link_tags_search ne \"\") {\n\t\t$link_tags_search .= '|';\n\t\t$link_tags_print .= ' or ';\n\t}\n\t$entry .= ':';\n\t$link_tags_search .= $entry;\n\t$link_tags_print .= \"'$entry'\";\n}\n$link_tags_search = \"(?:${link_tags_search})\";\n\nour $tracing_logging_tags = qr{(?xi:\n\t[=-]*> |\n\t<[=-]* |\n\t\\[ |\n\t\\] |\n\tstart |\n\tcalled |\n\tentered |\n\tentry |\n\tenter |\n\tin |\n\tinside |\n\there |\n\tbegin |\n\texit |\n\tend |\n\tdone |\n\tleave |\n\tcompleted |\n\tout |\n\treturn |\n\t[\\.\\!:\\s]*\n)};\n\nsub edit_distance_min {\n\tmy (@arr) = @_;\n\tmy $len = scalar @arr;\n\tif ((scalar @arr) < 1) {\n\t\t# if underflow, return\n\t\treturn;\n\t}\n\tmy $min = $arr[0];\n\tfor my $i (0 .. ($len-1)) {\n\t\tif ($arr[$i] < $min) {\n\t\t\t$min = $arr[$i];\n\t\t}\n\t}\n\treturn $min;\n}\n\nsub get_edit_distance {\n\tmy ($str1, $str2) = @_;\n\t$str1 = lc($str1);\n\t$str2 = lc($str2);\n\t$str1 =~ s/-//g;\n\t$str2 =~ s/-//g;\n\tmy $len1 = length($str1);\n\tmy $len2 = length($str2);\n\t# two dimensional array storing minimum edit distance\n\tmy @distance;\n\tfor my $i (0 .. $len1) {\n\t\tfor my $j (0 .. $len2) {\n\t\t\tif ($i == 0) {\n\t\t\t\t$distance[$i][$j] = $j;\n\t\t\t} elsif ($j == 0) {\n\t\t\t\t$distance[$i][$j] = $i;\n\t\t\t} elsif (substr($str1, $i-1, 1) eq substr($str2, $j-1, 1)) {\n\t\t\t\t$distance[$i][$j] = $distance[$i - 1][$j - 1];\n\t\t\t} else {\n\t\t\t\tmy $dist1 = $distance[$i][$j - 1]; #insert distance\n\t\t\t\tmy $dist2 = $distance[$i - 1][$j]; # remove\n\t\t\t\tmy $dist3 = $distance[$i - 1][$j - 1]; #replace\n\t\t\t\t$distance[$i][$j] = 1 + edit_distance_min($dist1, $dist2, $dist3);\n\t\t\t}\n\t\t}\n\t}\n\treturn $distance[$len1][$len2];\n}\n\nsub find_standard_signature {\n\tmy ($sign_off) = @_;\n\tmy @standard_signature_tags = (\n\t\t'Signed-off-by:', 'Co-developed-by:', 'Acked-by:', 'Tested-by:',\n\t\t'Reviewed-by:', 'Reported-by:', 'Suggested-by:'\n\t);\n\tforeach my $signature (@standard_signature_tags) {\n\t\treturn $signature if (get_edit_distance($sign_off, $signature) <= 2);\n\t}\n\n\treturn \"\";\n}\n\nour $obsolete_archives = qr{(?xi:\n\t\\Qfreedesktop.org/archives/dri-devel\\E |\n\t\\Qlists.infradead.org\\E |\n\t\\Qlkml.org\\E |\n\t\\Qmail-archive.com\\E |\n\t\\Qmailman.alsa-project.org/pipermail\\E |\n\t\\Qmarc.info\\E |\n\t\\Qozlabs.org/pipermail\\E |\n\t\\Qspinics.net\\E\n)};\n\nour @typeListMisordered = (\n\tqr{char\\s+(?:un)?signed},\n\tqr{int\\s+(?:(?:un)?signed\\s+)?short\\s},\n\tqr{int\\s+short(?:\\s+(?:un)?signed)},\n\tqr{short\\s+int(?:\\s+(?:un)?signed)},\n\tqr{(?:un)?signed\\s+int\\s+short},\n\tqr{short\\s+(?:un)?signed},\n\tqr{long\\s+int\\s+(?:un)?signed},\n\tqr{int\\s+long\\s+(?:un)?signed},\n\tqr{long\\s+(?:un)?signed\\s+int},\n\tqr{int\\s+(?:un)?signed\\s+long},\n\tqr{int\\s+(?:un)?signed},\n\tqr{int\\s+long\\s+long\\s+(?:un)?signed},\n\tqr{long\\s+long\\s+int\\s+(?:un)?signed},\n\tqr{long\\s+long\\s+(?:un)?signed\\s+int},\n\tqr{long\\s+long\\s+(?:un)?signed},\n\tqr{long\\s+(?:un)?signed},\n);\n\nour @typeList = (\n\tqr{void},\n\tqr{(?:(?:un)?signed\\s+)?char},\n\tqr{(?:(?:un)?signed\\s+)?short\\s+int},\n\tqr{(?:(?:un)?signed\\s+)?short},\n\tqr{(?:(?:un)?signed\\s+)?int},\n\tqr{(?:(?:un)?signed\\s+)?long\\s+int},\n\tqr{(?:(?:un)?signed\\s+)?long\\s+long\\s+int},\n\tqr{(?:(?:un)?signed\\s+)?long\\s+long},\n\tqr{(?:(?:un)?signed\\s+)?long},\n\tqr{(?:un)?signed},\n\tqr{float},\n\tqr{double},\n\tqr{bool},\n\tqr{struct\\s+$Ident},\n\tqr{union\\s+$Ident},\n\tqr{enum\\s+$Ident},\n\tqr{${Ident}_t},\n\tqr{${Ident}_handler},\n\tqr{${Ident}_handler_fn},\n\t@typeListMisordered,\n);\n\nour $C90_int_types = qr{(?x:\n\tlong\\s+long\\s+int\\s+(?:un)?signed|\n\tlong\\s+long\\s+(?:un)?signed\\s+int|\n\tlong\\s+long\\s+(?:un)?signed|\n\t(?:(?:un)?signed\\s+)?long\\s+long\\s+int|\n\t(?:(?:un)?signed\\s+)?long\\s+long|\n\tint\\s+long\\s+long\\s+(?:un)?signed|\n\tint\\s+(?:(?:un)?signed\\s+)?long\\s+long|\n\n\tlong\\s+int\\s+(?:un)?signed|\n\tlong\\s+(?:un)?signed\\s+int|\n\tlong\\s+(?:un)?signed|\n\t(?:(?:un)?signed\\s+)?long\\s+int|\n\t(?:(?:un)?signed\\s+)?long|\n\tint\\s+long\\s+(?:un)?signed|\n\tint\\s+(?:(?:un)?signed\\s+)?long|\n\n\tint\\s+(?:un)?signed|\n\t(?:(?:un)?signed\\s+)?int\n)};\n\nour @typeListFile = ();\nour @typeListWithAttr = (\n\t@typeList,\n\tqr{struct\\s+$InitAttribute\\s+$Ident},\n\tqr{union\\s+$InitAttribute\\s+$Ident},\n);\n\nour @modifierList = (\n\tqr{fastcall},\n);\nour @modifierListFile = ();\n\nour @mode_permission_funcs = (\n\t[\"module_param\", 3],\n\t[\"module_param_(?:array|named|string)\", 4],\n\t[\"module_param_array_named\", 5],\n\t[\"debugfs_create_(?:file|u8|u16|u32|u64|x8|x16|x32|x64|size_t|atomic_t|bool|blob|regset32|u32_array)\", 2],\n\t[\"proc_create(?:_data|)\", 2],\n\t[\"(?:CLASS|DEVICE|SENSOR|SENSOR_DEVICE|IIO_DEVICE)_ATTR\", 2],\n\t[\"IIO_DEV_ATTR_[A-Z_]+\", 1],\n\t[\"SENSOR_(?:DEVICE_|)ATTR_2\", 2],\n\t[\"SENSOR_TEMPLATE(?:_2|)\", 3],\n\t[\"__ATTR\", 2],\n);\n\nmy $word_pattern = '\\b[A-Z]?[a-z]{2,}\\b';\n\n#Create a search pattern for all these functions to speed up a loop below\nour $mode_perms_search = \"\";\nforeach my $entry (@mode_permission_funcs) {\n\t$mode_perms_search .= '|' if ($mode_perms_search ne \"\");\n\t$mode_perms_search .= $entry->[0];\n}\n$mode_perms_search = \"(?:${mode_perms_search})\";\n\nour %deprecated_apis = (\n\t\"synchronize_rcu_bh\"\t\t\t=> \"synchronize_rcu\",\n\t\"synchronize_rcu_bh_expedited\"\t\t=> \"synchronize_rcu_expedited\",\n\t\"call_rcu_bh\"\t\t\t\t=> \"call_rcu\",\n\t\"rcu_barrier_bh\"\t\t\t=> \"rcu_barrier\",\n\t\"synchronize_sched\"\t\t\t=> \"synchronize_rcu\",\n\t\"synchronize_sched_expedited\"\t\t=> \"synchronize_rcu_expedited\",\n\t\"call_rcu_sched\"\t\t\t=> \"call_rcu\",\n\t\"rcu_barrier_sched\"\t\t\t=> \"rcu_barrier\",\n\t\"get_state_synchronize_sched\"\t\t=> \"get_state_synchronize_rcu\",\n\t\"cond_synchronize_sched\"\t\t=> \"cond_synchronize_rcu\",\n\t\"kmap\"\t\t\t\t\t=> \"kmap_local_page\",\n\t\"kunmap\"\t\t\t\t=> \"kunmap_local\",\n\t\"kmap_atomic\"\t\t\t\t=> \"kmap_local_page\",\n\t\"kunmap_atomic\"\t\t\t\t=> \"kunmap_local\",\n);\n\n#Create a search pattern for all these strings to speed up a loop below\nour $deprecated_apis_search = \"\";\nforeach my $entry (keys %deprecated_apis) {\n\t$deprecated_apis_search .= '|' if ($deprecated_apis_search ne \"\");\n\t$deprecated_apis_search .= $entry;\n}\n$deprecated_apis_search = \"(?:${deprecated_apis_search})\";\n\nour $mode_perms_world_writable = qr{\n\tS_IWUGO\t\t|\n\tS_IWOTH\t\t|\n\tS_IRWXUGO\t|\n\tS_IALLUGO\t|\n\t0[0-7][0-7][2367]\n}x;\n\nour %mode_permission_string_types = (\n\t\"S_IRWXU\" => 0700,\n\t\"S_IRUSR\" => 0400,\n\t\"S_IWUSR\" => 0200,\n\t\"S_IXUSR\" => 0100,\n\t\"S_IRWXG\" => 0070,\n\t\"S_IRGRP\" => 0040,\n\t\"S_IWGRP\" => 0020,\n\t\"S_IXGRP\" => 0010,\n\t\"S_IRWXO\" => 0007,\n\t\"S_IROTH\" => 0004,\n\t\"S_IWOTH\" => 0002,\n\t\"S_IXOTH\" => 0001,\n\t\"S_IRWXUGO\" => 0777,\n\t\"S_IRUGO\" => 0444,\n\t\"S_IWUGO\" => 0222,\n\t\"S_IXUGO\" => 0111,\n);\n\n#Create a search pattern for all these strings to speed up a loop below\nour $mode_perms_string_search = \"\";\nforeach my $entry (keys %mode_permission_string_types) {\n\t$mode_perms_string_search .= '|' if ($mode_perms_string_search ne \"\");\n\t$mode_perms_string_search .= $entry;\n}\nour $single_mode_perms_string_search = \"(?:${mode_perms_string_search})\";\nour $multi_mode_perms_string_search = qr{\n\t${single_mode_perms_string_search}\n\t(?:\\s*\\|\\s*${single_mode_perms_string_search})*\n}x;\n\nsub perms_to_octal {\n\tmy ($string) = @_;\n\n\treturn trim($string) if ($string =~ /^\\s*0[0-7]{3,3}\\s*$/);\n\n\tmy $val = \"\";\n\tmy $oval = \"\";\n\tmy $to = 0;\n\tmy $curpos = 0;\n\tmy $lastpos = 0;\n\twhile ($string =~ /\\b(($single_mode_perms_string_search)\\b(?:\\s*\\|\\s*)?\\s*)/g) {\n\t\t$curpos = pos($string);\n\t\tmy $match = $2;\n\t\tmy $omatch = $1;\n\t\tlast if ($lastpos > 0 && ($curpos - length($omatch) != $lastpos));\n\t\t$lastpos = $curpos;\n\t\t$to |= $mode_permission_string_types{$match};\n\t\t$val .= '\\s*\\|\\s*' if ($val ne \"\");\n\t\t$val .= $match;\n\t\t$oval .= $omatch;\n\t}\n\t$oval =~ s/^\\s*\\|\\s*//;\n\t$oval =~ s/\\s*\\|\\s*$//;\n\treturn sprintf(\"%04o\", $to);\n}\n\nour $allowed_asm_includes = qr{(?x:\n\tirq|\n\tmemory|\n\ttime|\n\treboot\n)};\n# memory.h: ARM has a custom one\n\n# Load common spelling mistakes and build regular expression list.\nmy $misspellings;\nmy %spelling_fix;\n\nif (open(my $spelling, '<', $spelling_file)) {\n\twhile (<$spelling>) {\n\t\tmy $line = $_;\n\n\t\t$line =~ s/\\s*\\n?$//g;\n\t\t$line =~ s/^\\s*//g;\n\n\t\tnext if ($line =~ m/^\\s*#/);\n\t\tnext if ($line =~ m/^\\s*$/);\n\n\t\tmy ($suspect, $fix) = split(/\\|\\|/, $line);\n\n\t\t$spelling_fix{$suspect} = $fix;\n\t}\n\tclose($spelling);\n} else {\n\twarn \"No typos will be found - file '$spelling_file': $!\\n\";\n}\n\nif ($codespell) {\n\tif (open(my $spelling, '<', $codespellfile)) {\n\t\twhile (<$spelling>) {\n\t\t\tmy $line = $_;\n\n\t\t\t$line =~ s/\\s*\\n?$//g;\n\t\t\t$line =~ s/^\\s*//g;\n\n\t\t\tnext if ($line =~ m/^\\s*#/);\n\t\t\tnext if ($line =~ m/^\\s*$/);\n\t\t\tnext if ($line =~ m/, disabled/i);\n\n\t\t\t$line =~ s/,.*$//;\n\n\t\t\tmy ($suspect, $fix) = split(/->/, $line);\n\n\t\t\t$spelling_fix{$suspect} = $fix;\n\t\t}\n\t\tclose($spelling);\n\t} else {\n\t\twarn \"No codespell typos will be found - file '$codespellfile': $!\\n\";\n\t}\n}\n\n$misspellings = join(\"|\", sort keys %spelling_fix) if keys %spelling_fix;\n\nsub read_words {\n\tmy ($wordsRef, $file) = @_;\n\n\tif (open(my $words, '<', $file)) {\n\t\twhile (<$words>) {\n\t\t\tmy $line = $_;\n\n\t\t\t$line =~ s/\\s*\\n?$//g;\n\t\t\t$line =~ s/^\\s*//g;\n\n\t\t\tnext if ($line =~ m/^\\s*#/);\n\t\t\tnext if ($line =~ m/^\\s*$/);\n\t\t\tif ($line =~ /\\s/) {\n\t\t\t\tprint(\"$file: '$line' invalid - ignored\\n\");\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\t$$wordsRef .= '|' if (defined $$wordsRef);\n\t\t\t$$wordsRef .= $line;\n\t\t}\n\t\tclose($file);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nmy $const_structs;\nif (show_type(\"CONST_STRUCT\")) {\n\tread_words(\\$const_structs, $conststructsfile)\n\t    or warn \"No structs that should be const will be found - file '$conststructsfile': $!\\n\";\n}\n\nif (defined($typedefsfile)) {\n\tmy $typeOtherTypedefs;\n\tread_words(\\$typeOtherTypedefs, $typedefsfile)\n\t    or warn \"No additional types will be considered - file '$typedefsfile': $!\\n\";\n\t$typeTypedefs .= '|' . $typeOtherTypedefs if (defined $typeOtherTypedefs);\n}\n\nsub build_types {\n\tmy $mods = \"(?x:  \\n\" . join(\"|\\n  \", (@modifierList, @modifierListFile)) . \"\\n)\";\n\tmy $all = \"(?x:  \\n\" . join(\"|\\n  \", (@typeList, @typeListFile)) . \"\\n)\";\n\tmy $Misordered = \"(?x:  \\n\" . join(\"|\\n  \", @typeListMisordered) . \"\\n)\";\n\tmy $allWithAttr = \"(?x:  \\n\" . join(\"|\\n  \", @typeListWithAttr) . \"\\n)\";\n\t$Modifier\t= qr{(?:$Attribute|$Sparse|$mods)};\n\t$BasicType\t= qr{\n\t\t\t\t(?:$typeTypedefs\\b)|\n\t\t\t\t(?:${all}\\b)\n\t\t}x;\n\t$NonptrType\t= qr{\n\t\t\t(?:$Modifier\\s+|const\\s+)*\n\t\t\t(?:\n\t\t\t\t(?:typeof|__typeof__)\\s*\\([^\\)]*\\)|\n\t\t\t\t(?:$typeTypedefs\\b)|\n\t\t\t\t(?:${all}\\b)\n\t\t\t)\n\t\t\t(?:\\s+$Modifier|\\s+const)*\n\t\t  }x;\n\t$NonptrTypeMisordered\t= qr{\n\t\t\t(?:$Modifier\\s+|const\\s+)*\n\t\t\t(?:\n\t\t\t\t(?:${Misordered}\\b)\n\t\t\t)\n\t\t\t(?:\\s+$Modifier|\\s+const)*\n\t\t  }x;\n\t$NonptrTypeWithAttr\t= qr{\n\t\t\t(?:$Modifier\\s+|const\\s+)*\n\t\t\t(?:\n\t\t\t\t(?:typeof|__typeof__)\\s*\\([^\\)]*\\)|\n\t\t\t\t(?:$typeTypedefs\\b)|\n\t\t\t\t(?:${allWithAttr}\\b)\n\t\t\t)\n\t\t\t(?:\\s+$Modifier|\\s+const)*\n\t\t  }x;\n\t$Type\t= qr{\n\t\t\t$NonptrType\n\t\t\t(?:(?:\\s|\\*|\\[\\])+\\s*const|(?:\\s|\\*\\s*(?:const\\s*)?|\\[\\])+|(?:\\s*\\[\\s*\\])+){0,4}\n\t\t\t(?:\\s+$Inline|\\s+$Modifier)*\n\t\t  }x;\n\t$TypeMisordered\t= qr{\n\t\t\t$NonptrTypeMisordered\n\t\t\t(?:(?:\\s|\\*|\\[\\])+\\s*const|(?:\\s|\\*\\s*(?:const\\s*)?|\\[\\])+|(?:\\s*\\[\\s*\\])+){0,4}\n\t\t\t(?:\\s+$Inline|\\s+$Modifier)*\n\t\t  }x;\n\t$Declare\t= qr{(?:$Storage\\s+(?:$Inline\\s+)?)?$Type};\n\t$DeclareMisordered\t= qr{(?:$Storage\\s+(?:$Inline\\s+)?)?$TypeMisordered};\n}\nbuild_types();\n\nour $Typecast\t= qr{\\s*(\\(\\s*$NonptrType\\s*\\)){0,1}\\s*};\n\n# Using $balanced_parens, $LvalOrFunc, or $FuncArg\n# requires at least perl version v5.10.0\n# Any use must be runtime checked with $^V\n\nour $balanced_parens = qr/(\\((?:[^\\(\\)]++|(?-1))*\\))/;\nour $LvalOrFunc\t= qr{((?:[\\&\\*]\\s*)?$Lval)\\s*($balanced_parens{0,1})\\s*};\nour $FuncArg = qr{$Typecast{0,1}($LvalOrFunc|$Constant|$String)};\n\nour $declaration_macros = qr{(?x:\n\t(?:$Storage\\s+)?(?:[A-Z_][A-Z0-9]*_){0,2}(?:DEFINE|DECLARE)(?:_[A-Z0-9]+){1,6}\\s*\\(|\n\t(?:$Storage\\s+)?[HLP]?LIST_HEAD\\s*\\(|\n\t(?:SKCIPHER_REQUEST|SHASH_DESC|AHASH_REQUEST)_ON_STACK\\s*\\(|\n\t(?:$Storage\\s+)?(?:XA_STATE|XA_STATE_ORDER)\\s*\\(\n)};\n\nour %allow_repeated_words = (\n\tadd => '',\n\tadded => '',\n\tbad => '',\n\tbe => '',\n);\n\nsub deparenthesize {\n\tmy ($string) = @_;\n\treturn \"\" if (!defined($string));\n\n\twhile ($string =~ /^\\s*\\(.*\\)\\s*$/) {\n\t\t$string =~ s@^\\s*\\(\\s*@@;\n\t\t$string =~ s@\\s*\\)\\s*$@@;\n\t}\n\n\t$string =~ s@\\s+@ @g;\n\n\treturn $string;\n}\n\nsub seed_camelcase_file {\n\tmy ($file) = @_;\n\n\treturn if (!(-f $file));\n\n\tlocal $/;\n\n\topen(my $include_file, '<', \"$file\")\n\t    or warn \"$P: Can't read '$file' $!\\n\";\n\tmy $text = <$include_file>;\n\tclose($include_file);\n\n\tmy @lines = split('\\n', $text);\n\n\tforeach my $line (@lines) {\n\t\tnext if ($line !~ /(?:[A-Z][a-z]|[a-z][A-Z])/);\n\t\tif ($line =~ /^[ \\t]*(?:#[ \\t]*define|typedef\\s+$Type)\\s+(\\w*(?:[A-Z][a-z]|[a-z][A-Z])\\w*)/) {\n\t\t\t$camelcase{$1} = 1;\n\t\t} elsif ($line =~ /^\\s*$Declare\\s+(\\w*(?:[A-Z][a-z]|[a-z][A-Z])\\w*)\\s*[\\(\\[,;]/) {\n\t\t\t$camelcase{$1} = 1;\n\t\t} elsif ($line =~ /^\\s*(?:union|struct|enum)\\s+(\\w*(?:[A-Z][a-z]|[a-z][A-Z])\\w*)\\s*[;\\{]/) {\n\t\t\t$camelcase{$1} = 1;\n\t\t}\n\t}\n}\n\nour %maintained_status = ();\n\nsub is_maintained_obsolete {\n\tmy ($filename) = @_;\n\n\treturn 0 if (!$tree || !(-e \"$root/scripts/get_maintainer.pl\"));\n\n\tif (!exists($maintained_status{$filename})) {\n\t\t$maintained_status{$filename} = `perl $root/scripts/get_maintainer.pl --status --nom --nol --nogit --nogit-fallback -f $filename 2>&1`;\n\t}\n\n\treturn $maintained_status{$filename} =~ /obsolete/i;\n}\n\nsub is_SPDX_License_valid {\n\tmy ($license) = @_;\n\n\treturn 1 if (!$tree || which(\"python3\") eq \"\" || !(-x \"$root/scripts/spdxcheck.py\") || !(-e \"$gitroot\"));\n\n\tmy $root_path = abs_path($root);\n\tmy $status = `cd \"$root_path\"; echo \"$license\" | scripts/spdxcheck.py -`;\n\treturn 0 if ($status ne \"\");\n\treturn 1;\n}\n\nmy $camelcase_seeded = 0;\nsub seed_camelcase_includes {\n\treturn if ($camelcase_seeded);\n\n\tmy $files;\n\tmy $camelcase_cache = \"\";\n\tmy @include_files = ();\n\n\t$camelcase_seeded = 1;\n\n\tif (-e \"$gitroot\") {\n\t\tmy $git_last_include_commit = `${git_command} log --no-merges --pretty=format:\"%h%n\" -1 -- include`;\n\t\tchomp $git_last_include_commit;\n\t\t$camelcase_cache = \".checkpatch-camelcase.git.$git_last_include_commit\";\n\t} else {\n\t\tmy $last_mod_date = 0;\n\t\t$files = `find $root/include -name \"*.h\"`;\n\t\t@include_files = split('\\n', $files);\n\t\tforeach my $file (@include_files) {\n\t\t\tmy $date = POSIX::strftime(\"%Y%m%d%H%M\",\n\t\t\t\t\t\t   localtime((stat $file)[9]));\n\t\t\t$last_mod_date = $date if ($last_mod_date < $date);\n\t\t}\n\t\t$camelcase_cache = \".checkpatch-camelcase.date.$last_mod_date\";\n\t}\n\n\tif ($camelcase_cache ne \"\" && -f $camelcase_cache) {\n\t\topen(my $camelcase_file, '<', \"$camelcase_cache\")\n\t\t    or warn \"$P: Can't read '$camelcase_cache' $!\\n\";\n\t\twhile (<$camelcase_file>) {\n\t\t\tchomp;\n\t\t\t$camelcase{$_} = 1;\n\t\t}\n\t\tclose($camelcase_file);\n\n\t\treturn;\n\t}\n\n\tif (-e \"$gitroot\") {\n\t\t$files = `${git_command} ls-files \"include/*.h\"`;\n\t\t@include_files = split('\\n', $files);\n\t}\n\n\tforeach my $file (@include_files) {\n\t\tseed_camelcase_file($file);\n\t}\n\n\tif ($camelcase_cache ne \"\") {\n\t\tunlink glob \".checkpatch-camelcase.*\";\n\t\topen(my $camelcase_file, '>', \"$camelcase_cache\")\n\t\t    or warn \"$P: Can't write '$camelcase_cache' $!\\n\";\n\t\tforeach (sort { lc($a) cmp lc($b) } keys(%camelcase)) {\n\t\t\tprint $camelcase_file (\"$_\\n\");\n\t\t}\n\t\tclose($camelcase_file);\n\t}\n}\n\nsub git_is_single_file {\n\tmy ($filename) = @_;\n\n\treturn 0 if ((which(\"git\") eq \"\") || !(-e \"$gitroot\"));\n\n\tmy $output = `${git_command} ls-files -- $filename 2>/dev/null`;\n\tmy $count = $output =~ tr/\\n//;\n\treturn $count eq 1 && $output =~ m{^${filename}$};\n}\n\nsub git_commit_info {\n\tmy ($commit, $id, $desc) = @_;\n\n\treturn ($id, $desc) if ((which(\"git\") eq \"\") || !(-e \"$gitroot\"));\n\n\tmy $output = `${git_command} log --no-color --format='%H %s' -1 $commit 2>&1`;\n\t$output =~ s/^\\s*//gm;\n\tmy @lines = split(\"\\n\", $output);\n\n\treturn ($id, $desc) if ($#lines < 0);\n\n\tif ($lines[0] =~ /^error: short SHA1 $commit is ambiguous/) {\n# Maybe one day convert this block of bash into something that returns\n# all matching commit ids, but it's very slow...\n#\n#\t\techo \"checking commits $1...\"\n#\t\tgit rev-list --remotes | grep -i \"^$1\" |\n#\t\twhile read line ; do\n#\t\t    git log --format='%H %s' -1 $line |\n#\t\t    echo \"commit $(cut -c 1-12,41-)\"\n#\t\tdone\n\t} elsif ($lines[0] =~ /^fatal: ambiguous argument '$commit': unknown revision or path not in the working tree\\./ ||\n\t\t $lines[0] =~ /^fatal: bad object $commit/) {\n\t\t$id = undef;\n\t} else {\n\t\t$id = substr($lines[0], 0, 12);\n\t\t$desc = substr($lines[0], 41);\n\t}\n\n\treturn ($id, $desc);\n}\n\n$chk_signoff = 0 if ($file);\n\nmy @rawlines = ();\nmy @lines = ();\nmy @fixed = ();\nmy @fixed_inserted = ();\nmy @fixed_deleted = ();\nmy $fixlinenr = -1;\n\n# If input is git commits, extract all commits from the commit expressions.\n# For example, HEAD-3 means we need check 'HEAD, HEAD~1, HEAD~2'.\ndie \"$P: No git repository found\\n\" if ($git && !-e \"$gitroot\");\n\nif ($git) {\n\tmy @commits = ();\n\tforeach my $commit_expr (@ARGV) {\n\t\tmy $git_range;\n\t\tif ($commit_expr =~ m/^(.*)-(\\d+)$/) {\n\t\t\t$git_range = \"-$2 $1\";\n\t\t} elsif ($commit_expr =~ m/\\.\\./) {\n\t\t\t$git_range = \"$commit_expr\";\n\t\t} else {\n\t\t\t$git_range = \"-1 $commit_expr\";\n\t\t}\n\t\tmy $lines = `${git_command} log --no-color --no-merges --pretty=format:'%H %s' $git_range`;\n\t\tforeach my $line (split(/\\n/, $lines)) {\n\t\t\t$line =~ /^([0-9a-fA-F]{40,40}) (.*)$/;\n\t\t\tnext if (!defined($1) || !defined($2));\n\t\t\tmy $sha1 = $1;\n\t\t\tmy $subject = $2;\n\t\t\tunshift(@commits, $sha1);\n\t\t\t$git_commits{$sha1} = $subject;\n\t\t}\n\t}\n\tdie \"$P: no git commits after extraction!\\n\" if (@commits == 0);\n\t@ARGV = @commits;\n}\n\nmy $vname;\n$allow_c99_comments = !defined $ignore_type{\"C99_COMMENT_TOLERANCE\"};\nfor my $filename (@ARGV) {\n\tmy $FILE;\n\tmy $is_git_file = git_is_single_file($filename);\n\tmy $oldfile = $file;\n\t$file = 1 if ($is_git_file);\n\tif ($git) {\n\t\topen($FILE, '-|', \"git format-patch -M --stdout -1 $filename\") ||\n\t\t\tdie \"$P: $filename: git format-patch failed - $!\\n\";\n\t} elsif ($file) {\n\t\topen($FILE, '-|', \"diff -u /dev/null $filename\") ||\n\t\t\tdie \"$P: $filename: diff failed - $!\\n\";\n\t} elsif ($filename eq '-') {\n\t\topen($FILE, '<&STDIN');\n\t} else {\n\t\topen($FILE, '<', \"$filename\") ||\n\t\t\tdie \"$P: $filename: open failed - $!\\n\";\n\t}\n\tif ($filename eq '-') {\n\t\t$vname = 'Your patch';\n\t} elsif ($git) {\n\t\t$vname = \"Commit \" . substr($filename, 0, 12) . ' (\"' . $git_commits{$filename} . '\")';\n\t} else {\n\t\t$vname = $filename;\n\t}\n\twhile (<$FILE>) {\n\t\tchomp;\n\t\tpush(@rawlines, $_);\n\t\t$vname = qq(\"$1\") if ($filename eq '-' && $_ =~ m/^Subject:\\s+(.+)/i);\n\t}\n\tclose($FILE);\n\n\tif ($#ARGV > 0 && $quiet == 0) {\n\t\tprint '-' x length($vname) . \"\\n\";\n\t\tprint \"$vname\\n\";\n\t\tprint '-' x length($vname) . \"\\n\";\n\t}\n\n\tif (!process($filename)) {\n\t\t$exit = 1;\n\t}\n\t@rawlines = ();\n\t@lines = ();\n\t@fixed = ();\n\t@fixed_inserted = ();\n\t@fixed_deleted = ();\n\t$fixlinenr = -1;\n\t@modifierListFile = ();\n\t@typeListFile = ();\n\tbuild_types();\n\t$file = $oldfile if ($is_git_file);\n}\n\nif (!$quiet) {\n\thash_show_words(\\%use_type, \"Used\");\n\thash_show_words(\\%ignore_type, \"Ignored\");\n\n\tif (!$perl_version_ok) {\n\t\tprint << \"EOM\"\n\nNOTE: perl $^V is not modern enough to detect all possible issues.\n      An upgrade to at least perl $minimum_perl_version is suggested.\nEOM\n\t}\n\tif ($exit) {\n\t\tprint << \"EOM\"\n\nNOTE: If any of the errors are false positives, please report\n      them to the maintainer, see CHECKPATCH in MAINTAINERS.\nEOM\n\t}\n}\n\nexit($exit);\n\nsub top_of_kernel_tree {\n\tmy ($root) = @_;\n\n\tmy @tree_check = (\n\t\t\"COPYING\", \"CREDITS\", \"Kbuild\", \"MAINTAINERS\", \"Makefile\",\n\t\t\"README\", \"Documentation\", \"arch\", \"include\", \"drivers\",\n\t\t\"fs\", \"init\", \"ipc\", \"kernel\", \"lib\", \"scripts\",\n\t);\n\n\tforeach my $check (@tree_check) {\n\t\tif (! -e $root . '/' . $check) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nsub parse_email {\n\tmy ($formatted_email) = @_;\n\n\tmy $name = \"\";\n\tmy $quoted = \"\";\n\tmy $name_comment = \"\";\n\tmy $address = \"\";\n\tmy $comment = \"\";\n\n\tif ($formatted_email =~ /^(.*)<(\\S+\\@\\S+)>(.*)$/) {\n\t\t$name = $1;\n\t\t$address = $2;\n\t\t$comment = $3 if defined $3;\n\t} elsif ($formatted_email =~ /^\\s*<(\\S+\\@\\S+)>(.*)$/) {\n\t\t$address = $1;\n\t\t$comment = $2 if defined $2;\n\t} elsif ($formatted_email =~ /(\\S+\\@\\S+)(.*)$/) {\n\t\t$address = $1;\n\t\t$comment = $2 if defined $2;\n\t\t$formatted_email =~ s/\\Q$address\\E.*$//;\n\t\t$name = $formatted_email;\n\t\t$name = trim($name);\n\t\t$name =~ s/^\\\"|\\\"$//g;\n\t\t# If there's a name left after stripping spaces and\n\t\t# leading quotes, and the address doesn't have both\n\t\t# leading and trailing angle brackets, the address\n\t\t# is invalid. ie:\n\t\t#   \"joe smith joe@smith.com\" bad\n\t\t#   \"joe smith <joe@smith.com\" bad\n\t\tif ($name ne \"\" && $address !~ /^<[^>]+>$/) {\n\t\t\t$name = \"\";\n\t\t\t$address = \"\";\n\t\t\t$comment = \"\";\n\t\t}\n\t}\n\n\t# Extract comments from names excluding quoted parts\n\t# \"John D. (Doe)\" - Do not extract\n\tif ($name =~ s/\\\"(.+)\\\"//) {\n\t\t$quoted = $1;\n\t}\n\twhile ($name =~ s/\\s*($balanced_parens)\\s*/ /) {\n\t\t$name_comment .= trim($1);\n\t}\n\t$name =~ s/^[ \\\"]+|[ \\\"]+$//g;\n\t$name = trim(\"$quoted $name\");\n\n\t$address = trim($address);\n\t$address =~ s/^\\<|\\>$//g;\n\t$comment = trim($comment);\n\n\tif ($name =~ /[^\\w \\-]/i) { ##has \"must quote\" chars\n\t\t$name =~ s/(?<!\\\\)\"/\\\\\"/g; ##escape quotes\n\t\t$name = \"\\\"$name\\\"\";\n\t}\n\n\treturn ($name, $name_comment, $address, $comment);\n}\n\nsub format_email {\n\tmy ($name, $name_comment, $address, $comment) = @_;\n\n\tmy $formatted_email;\n\n\t$name =~ s/^[ \\\"]+|[ \\\"]+$//g;\n\t$address = trim($address);\n\t$address =~ s/(?:\\.|\\,|\\\")+$//; ##trailing commas, dots or quotes\n\n\tif ($name =~ /[^\\w \\-]/i) { ##has \"must quote\" chars\n\t\t$name =~ s/(?<!\\\\)\"/\\\\\"/g; ##escape quotes\n\t\t$name = \"\\\"$name\\\"\";\n\t}\n\n\t$name_comment = trim($name_comment);\n\t$name_comment = \" $name_comment\" if ($name_comment ne \"\");\n\t$comment = trim($comment);\n\t$comment = \" $comment\" if ($comment ne \"\");\n\n\tif (\"$name\" eq \"\") {\n\t\t$formatted_email = \"$address\";\n\t} else {\n\t\t$formatted_email = \"$name$name_comment <$address>\";\n\t}\n\t$formatted_email .= \"$comment\";\n\treturn $formatted_email;\n}\n\nsub reformat_email {\n\tmy ($email) = @_;\n\n\tmy ($email_name, $name_comment, $email_address, $comment) = parse_email($email);\n\treturn format_email($email_name, $name_comment, $email_address, $comment);\n}\n\nsub same_email_addresses {\n\tmy ($email1, $email2) = @_;\n\n\tmy ($email1_name, $name1_comment, $email1_address, $comment1) = parse_email($email1);\n\tmy ($email2_name, $name2_comment, $email2_address, $comment2) = parse_email($email2);\n\n\treturn $email1_name eq $email2_name &&\n\t       $email1_address eq $email2_address &&\n\t       $name1_comment eq $name2_comment &&\n\t       $comment1 eq $comment2;\n}\n\nsub which {\n\tmy ($bin) = @_;\n\n\tforeach my $path (split(/:/, $ENV{PATH})) {\n\t\tif (-e \"$path/$bin\") {\n\t\t\treturn \"$path/$bin\";\n\t\t}\n\t}\n\n\treturn \"\";\n}\n\nsub which_conf {\n\tmy ($conf) = @_;\n\n\tforeach my $path (split(/:/, \".:$ENV{HOME}:.scripts\")) {\n\t\tif (-e \"$path/$conf\") {\n\t\t\treturn \"$path/$conf\";\n\t\t}\n\t}\n\n\treturn \"\";\n}\n\nsub expand_tabs {\n\tmy ($str) = @_;\n\n\tmy $res = '';\n\tmy $n = 0;\n\tfor my $c (split(//, $str)) {\n\t\tif ($c eq \"\\t\") {\n\t\t\t$res .= ' ';\n\t\t\t$n++;\n\t\t\tfor (; ($n % $tabsize) != 0; $n++) {\n\t\t\t\t$res .= ' ';\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\t\t$res .= $c;\n\t\t$n++;\n\t}\n\n\treturn $res;\n}\nsub copy_spacing {\n\t(my $res = shift) =~ tr/\\t/ /c;\n\treturn $res;\n}\n\nsub line_stats {\n\tmy ($line) = @_;\n\n\t# Drop the diff line leader and expand tabs\n\t$line =~ s/^.//;\n\t$line = expand_tabs($line);\n\n\t# Pick the indent from the front of the line.\n\tmy ($white) = ($line =~ /^(\\s*)/);\n\n\treturn (length($line), length($white));\n}\n\nmy $sanitise_quote = '';\n\nsub sanitise_line_reset {\n\tmy ($in_comment) = @_;\n\n\tif ($in_comment) {\n\t\t$sanitise_quote = '*/';\n\t} else {\n\t\t$sanitise_quote = '';\n\t}\n}\nsub sanitise_line {\n\tmy ($line) = @_;\n\n\tmy $res = '';\n\tmy $l = '';\n\n\tmy $qlen = 0;\n\tmy $off = 0;\n\tmy $c;\n\n\t# Always copy over the diff marker.\n\t$res = substr($line, 0, 1);\n\n\tfor ($off = 1; $off < length($line); $off++) {\n\t\t$c = substr($line, $off, 1);\n\n\t\t# Comments we are whacking completely including the begin\n\t\t# and end, all to $;.\n\t\tif ($sanitise_quote eq '' && substr($line, $off, 2) eq '/*') {\n\t\t\t$sanitise_quote = '*/';\n\n\t\t\tsubstr($res, $off, 2, \"$;$;\");\n\t\t\t$off++;\n\t\t\tnext;\n\t\t}\n\t\tif ($sanitise_quote eq '*/' && substr($line, $off, 2) eq '*/') {\n\t\t\t$sanitise_quote = '';\n\t\t\tsubstr($res, $off, 2, \"$;$;\");\n\t\t\t$off++;\n\t\t\tnext;\n\t\t}\n\t\tif ($sanitise_quote eq '' && substr($line, $off, 2) eq '//') {\n\t\t\t$sanitise_quote = '//';\n\n\t\t\tsubstr($res, $off, 2, $sanitise_quote);\n\t\t\t$off++;\n\t\t\tnext;\n\t\t}\n\n\t\t# A \\ in a string means ignore the next character.\n\t\tif (($sanitise_quote eq \"'\" || $sanitise_quote eq '\"') &&\n\t\t    $c eq \"\\\\\") {\n\t\t\tsubstr($res, $off, 2, 'XX');\n\t\t\t$off++;\n\t\t\tnext;\n\t\t}\n\t\t# Regular quotes.\n\t\tif ($c eq \"'\" || $c eq '\"') {\n\t\t\tif ($sanitise_quote eq '') {\n\t\t\t\t$sanitise_quote = $c;\n\n\t\t\t\tsubstr($res, $off, 1, $c);\n\t\t\t\tnext;\n\t\t\t} elsif ($sanitise_quote eq $c) {\n\t\t\t\t$sanitise_quote = '';\n\t\t\t}\n\t\t}\n\n\t\t#print \"c<$c> SQ<$sanitise_quote>\\n\";\n\t\tif ($off != 0 && $sanitise_quote eq '*/' && $c ne \"\\t\") {\n\t\t\tsubstr($res, $off, 1, $;);\n\t\t} elsif ($off != 0 && $sanitise_quote eq '//' && $c ne \"\\t\") {\n\t\t\tsubstr($res, $off, 1, $;);\n\t\t} elsif ($off != 0 && $sanitise_quote && $c ne \"\\t\") {\n\t\t\tsubstr($res, $off, 1, 'X');\n\t\t} else {\n\t\t\tsubstr($res, $off, 1, $c);\n\t\t}\n\t}\n\n\tif ($sanitise_quote eq '//') {\n\t\t$sanitise_quote = '';\n\t}\n\n\t# The pathname on a #include may be surrounded by '<' and '>'.\n\tif ($res =~ /^.\\s*\\#\\s*include\\s+\\<(.*)\\>/) {\n\t\tmy $clean = 'X' x length($1);\n\t\t$res =~ s@\\<.*\\>@<$clean>@;\n\n\t# The whole of a #error is a string.\n\t} elsif ($res =~ /^.\\s*\\#\\s*(?:error|warning)\\s+(.*)\\b/) {\n\t\tmy $clean = 'X' x length($1);\n\t\t$res =~ s@(\\#\\s*(?:error|warning)\\s+).*@$1$clean@;\n\t}\n\n\tif ($allow_c99_comments && $res =~ m@(//.*$)@) {\n\t\tmy $match = $1;\n\t\t$res =~ s/\\Q$match\\E/\"$;\" x length($match)/e;\n\t}\n\n\treturn $res;\n}\n\nsub get_quoted_string {\n\tmy ($line, $rawline) = @_;\n\n\treturn \"\" if (!defined($line) || !defined($rawline));\n\treturn \"\" if ($line !~ m/($String)/g);\n\treturn substr($rawline, $-[0], $+[0] - $-[0]);\n}\n\nsub ctx_statement_block {\n\tmy ($linenr, $remain, $off) = @_;\n\tmy $line = $linenr - 1;\n\tmy $blk = '';\n\tmy $soff = $off;\n\tmy $coff = $off - 1;\n\tmy $coff_set = 0;\n\n\tmy $loff = 0;\n\n\tmy $type = '';\n\tmy $level = 0;\n\tmy @stack = ();\n\tmy $p;\n\tmy $c;\n\tmy $len = 0;\n\n\tmy $remainder;\n\twhile (1) {\n\t\t@stack = (['', 0]) if ($#stack == -1);\n\n\t\t#warn \"CSB: blk<$blk> remain<$remain>\\n\";\n\t\t# If we are about to drop off the end, pull in more\n\t\t# context.\n\t\tif ($off >= $len) {\n\t\t\tfor (; $remain > 0; $line++) {\n\t\t\t\tlast if (!defined $lines[$line]);\n\t\t\t\tnext if ($lines[$line] =~ /^-/);\n\t\t\t\t$remain--;\n\t\t\t\t$loff = $len;\n\t\t\t\t$blk .= $lines[$line] . \"\\n\";\n\t\t\t\t$len = length($blk);\n\t\t\t\t$line++;\n\t\t\t\tlast;\n\t\t\t}\n\t\t\t# Bail if there is no further context.\n\t\t\t#warn \"CSB: blk<$blk> off<$off> len<$len>\\n\";\n\t\t\tif ($off >= $len) {\n\t\t\t\tlast;\n\t\t\t}\n\t\t\tif ($level == 0 && substr($blk, $off) =~ /^.\\s*#\\s*define/) {\n\t\t\t\t$level++;\n\t\t\t\t$type = '#';\n\t\t\t}\n\t\t}\n\t\t$p = $c;\n\t\t$c = substr($blk, $off, 1);\n\t\t$remainder = substr($blk, $off);\n\n\t\t#warn \"CSB: c<$c> type<$type> level<$level> remainder<$remainder> coff_set<$coff_set>\\n\";\n\n\t\t# Handle nested #if/#else.\n\t\tif ($remainder =~ /^#\\s*(?:ifndef|ifdef|if)\\s/) {\n\t\t\tpush(@stack, [ $type, $level ]);\n\t\t} elsif ($remainder =~ /^#\\s*(?:else|elif)\\b/) {\n\t\t\t($type, $level) = @{$stack[$#stack - 1]};\n\t\t} elsif ($remainder =~ /^#\\s*endif\\b/) {\n\t\t\t($type, $level) = @{pop(@stack)};\n\t\t}\n\n\t\t# Statement ends at the ';' or a close '}' at the\n\t\t# outermost level.\n\t\tif ($level == 0 && $c eq ';') {\n\t\t\tlast;\n\t\t}\n\n\t\t# An else is really a conditional as long as its not else if\n\t\tif ($level == 0 && $coff_set == 0 &&\n\t\t\t\t(!defined($p) || $p =~ /(?:\\s|\\}|\\+)/) &&\n\t\t\t\t$remainder =~ /^(else)(?:\\s|{)/ &&\n\t\t\t\t$remainder !~ /^else\\s+if\\b/) {\n\t\t\t$coff = $off + length($1) - 1;\n\t\t\t$coff_set = 1;\n\t\t\t#warn \"CSB: mark coff<$coff> soff<$soff> 1<$1>\\n\";\n\t\t\t#warn \"[\" . substr($blk, $soff, $coff - $soff + 1) . \"]\\n\";\n\t\t}\n\n\t\tif (($type eq '' || $type eq '(') && $c eq '(') {\n\t\t\t$level++;\n\t\t\t$type = '(';\n\t\t}\n\t\tif ($type eq '(' && $c eq ')') {\n\t\t\t$level--;\n\t\t\t$type = ($level != 0)? '(' : '';\n\n\t\t\tif ($level == 0 && $coff < $soff) {\n\t\t\t\t$coff = $off;\n\t\t\t\t$coff_set = 1;\n\t\t\t\t#warn \"CSB: mark coff<$coff>\\n\";\n\t\t\t}\n\t\t}\n\t\tif (($type eq '' || $type eq '{') && $c eq '{') {\n\t\t\t$level++;\n\t\t\t$type = '{';\n\t\t}\n\t\tif ($type eq '{' && $c eq '}') {\n\t\t\t$level--;\n\t\t\t$type = ($level != 0)? '{' : '';\n\n\t\t\tif ($level == 0) {\n\t\t\t\tif (substr($blk, $off + 1, 1) eq ';') {\n\t\t\t\t\t$off++;\n\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\t# Preprocessor commands end at the newline unless escaped.\n\t\tif ($type eq '#' && $c eq \"\\n\" && $p ne \"\\\\\") {\n\t\t\t$level--;\n\t\t\t$type = '';\n\t\t\t$off++;\n\t\t\tlast;\n\t\t}\n\t\t$off++;\n\t}\n\t# We are truly at the end, so shuffle to the next line.\n\tif ($off == $len) {\n\t\t$loff = $len + 1;\n\t\t$line++;\n\t\t$remain--;\n\t}\n\n\tmy $statement = substr($blk, $soff, $off - $soff + 1);\n\tmy $condition = substr($blk, $soff, $coff - $soff + 1);\n\n\t#warn \"STATEMENT<$statement>\\n\";\n\t#warn \"CONDITION<$condition>\\n\";\n\n\t#print \"coff<$coff> soff<$off> loff<$loff>\\n\";\n\n\treturn ($statement, $condition,\n\t\t\t$line, $remain + 1, $off - $loff + 1, $level);\n}\n\nsub statement_lines {\n\tmy ($stmt) = @_;\n\n\t# Strip the diff line prefixes and rip blank lines at start and end.\n\t$stmt =~ s/(^|\\n)./$1/g;\n\t$stmt =~ s/^\\s*//;\n\t$stmt =~ s/\\s*$//;\n\n\tmy @stmt_lines = ($stmt =~ /\\n/g);\n\n\treturn $#stmt_lines + 2;\n}\n\nsub statement_rawlines {\n\tmy ($stmt) = @_;\n\n\tmy @stmt_lines = ($stmt =~ /\\n/g);\n\n\treturn $#stmt_lines + 2;\n}\n\nsub statement_block_size {\n\tmy ($stmt) = @_;\n\n\t$stmt =~ s/(^|\\n)./$1/g;\n\t$stmt =~ s/^\\s*{//;\n\t$stmt =~ s/}\\s*$//;\n\t$stmt =~ s/^\\s*//;\n\t$stmt =~ s/\\s*$//;\n\n\tmy @stmt_lines = ($stmt =~ /\\n/g);\n\tmy @stmt_statements = ($stmt =~ /;/g);\n\n\tmy $stmt_lines = $#stmt_lines + 2;\n\tmy $stmt_statements = $#stmt_statements + 1;\n\n\tif ($stmt_lines > $stmt_statements) {\n\t\treturn $stmt_lines;\n\t} else {\n\t\treturn $stmt_statements;\n\t}\n}\n\nsub ctx_statement_full {\n\tmy ($linenr, $remain, $off) = @_;\n\tmy ($statement, $condition, $level);\n\n\tmy (@chunks);\n\n\t# Grab the first conditional/block pair.\n\t($statement, $condition, $linenr, $remain, $off, $level) =\n\t\t\t\tctx_statement_block($linenr, $remain, $off);\n\t#print \"F: c<$condition> s<$statement> remain<$remain>\\n\";\n\tpush(@chunks, [ $condition, $statement ]);\n\tif (!($remain > 0 && $condition =~ /^\\s*(?:\\n[+-])?\\s*(?:if|else|do)\\b/s)) {\n\t\treturn ($level, $linenr, @chunks);\n\t}\n\n\t# Pull in the following conditional/block pairs and see if they\n\t# could continue the statement.\n\tfor (;;) {\n\t\t($statement, $condition, $linenr, $remain, $off, $level) =\n\t\t\t\tctx_statement_block($linenr, $remain, $off);\n\t\t#print \"C: c<$condition> s<$statement> remain<$remain>\\n\";\n\t\tlast if (!($remain > 0 && $condition =~ /^(?:\\s*\\n[+-])*\\s*(?:else|do)\\b/s));\n\t\t#print \"C: push\\n\";\n\t\tpush(@chunks, [ $condition, $statement ]);\n\t}\n\n\treturn ($level, $linenr, @chunks);\n}\n\nsub ctx_block_get {\n\tmy ($linenr, $remain, $outer, $open, $close, $off) = @_;\n\tmy $line;\n\tmy $start = $linenr - 1;\n\tmy $blk = '';\n\tmy @o;\n\tmy @c;\n\tmy @res = ();\n\n\tmy $level = 0;\n\tmy @stack = ($level);\n\tfor ($line = $start; $remain > 0; $line++) {\n\t\tnext if ($rawlines[$line] =~ /^-/);\n\t\t$remain--;\n\n\t\t$blk .= $rawlines[$line];\n\n\t\t# Handle nested #if/#else.\n\t\tif ($lines[$line] =~ /^.\\s*#\\s*(?:ifndef|ifdef|if)\\s/) {\n\t\t\tpush(@stack, $level);\n\t\t} elsif ($lines[$line] =~ /^.\\s*#\\s*(?:else|elif)\\b/) {\n\t\t\t$level = $stack[$#stack - 1];\n\t\t} elsif ($lines[$line] =~ /^.\\s*#\\s*endif\\b/) {\n\t\t\t$level = pop(@stack);\n\t\t}\n\n\t\tforeach my $c (split(//, $lines[$line])) {\n\t\t\t##print \"C<$c>L<$level><$open$close>O<$off>\\n\";\n\t\t\tif ($off > 0) {\n\t\t\t\t$off--;\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\tif ($c eq $close && $level > 0) {\n\t\t\t\t$level--;\n\t\t\t\tlast if ($level == 0);\n\t\t\t} elsif ($c eq $open) {\n\t\t\t\t$level++;\n\t\t\t}\n\t\t}\n\n\t\tif (!$outer || $level <= 1) {\n\t\t\tpush(@res, $rawlines[$line]);\n\t\t}\n\n\t\tlast if ($level == 0);\n\t}\n\n\treturn ($level, @res);\n}\nsub ctx_block_outer {\n\tmy ($linenr, $remain) = @_;\n\n\tmy ($level, @r) = ctx_block_get($linenr, $remain, 1, '{', '}', 0);\n\treturn @r;\n}\nsub ctx_block {\n\tmy ($linenr, $remain) = @_;\n\n\tmy ($level, @r) = ctx_block_get($linenr, $remain, 0, '{', '}', 0);\n\treturn @r;\n}\nsub ctx_statement {\n\tmy ($linenr, $remain, $off) = @_;\n\n\tmy ($level, @r) = ctx_block_get($linenr, $remain, 0, '(', ')', $off);\n\treturn @r;\n}\nsub ctx_block_level {\n\tmy ($linenr, $remain) = @_;\n\n\treturn ctx_block_get($linenr, $remain, 0, '{', '}', 0);\n}\nsub ctx_statement_level {\n\tmy ($linenr, $remain, $off) = @_;\n\n\treturn ctx_block_get($linenr, $remain, 0, '(', ')', $off);\n}\n\nsub ctx_locate_comment {\n\tmy ($first_line, $end_line) = @_;\n\n\t# If c99 comment on the current line, or the line before or after\n\tmy ($current_comment) = ($rawlines[$end_line - 1] =~ m@^\\+.*(//.*$)@);\n\treturn $current_comment if (defined $current_comment);\n\t($current_comment) = ($rawlines[$end_line - 2] =~ m@^[\\+ ].*(//.*$)@);\n\treturn $current_comment if (defined $current_comment);\n\t($current_comment) = ($rawlines[$end_line] =~ m@^[\\+ ].*(//.*$)@);\n\treturn $current_comment if (defined $current_comment);\n\n\t# Catch a comment on the end of the line itself.\n\t($current_comment) = ($rawlines[$end_line - 1] =~ m@.*(/\\*.*\\*/)\\s*(?:\\\\\\s*)?$@);\n\treturn $current_comment if (defined $current_comment);\n\n\t# Look through the context and try and figure out if there is a\n\t# comment.\n\tmy $in_comment = 0;\n\t$current_comment = '';\n\tfor (my $linenr = $first_line; $linenr < $end_line; $linenr++) {\n\t\tmy $line = $rawlines[$linenr - 1];\n\t\t#warn \"           $line\\n\";\n\t\tif ($linenr == $first_line and $line =~ m@^.\\s*\\*@) {\n\t\t\t$in_comment = 1;\n\t\t}\n\t\tif ($line =~ m@/\\*@) {\n\t\t\t$in_comment = 1;\n\t\t}\n\t\tif (!$in_comment && $current_comment ne '') {\n\t\t\t$current_comment = '';\n\t\t}\n\t\t$current_comment .= $line . \"\\n\" if ($in_comment);\n\t\tif ($line =~ m@\\*/@) {\n\t\t\t$in_comment = 0;\n\t\t}\n\t}\n\n\tchomp($current_comment);\n\treturn($current_comment);\n}\nsub ctx_has_comment {\n\tmy ($first_line, $end_line) = @_;\n\tmy $cmt = ctx_locate_comment($first_line, $end_line);\n\n\t##print \"LINE: $rawlines[$end_line - 1 ]\\n\";\n\t##print \"CMMT: $cmt\\n\";\n\n\treturn ($cmt ne '');\n}\n\nsub raw_line {\n\tmy ($linenr, $cnt) = @_;\n\n\tmy $offset = $linenr - 1;\n\t$cnt++;\n\n\tmy $line;\n\twhile ($cnt) {\n\t\t$line = $rawlines[$offset++];\n\t\tnext if (defined($line) && $line =~ /^-/);\n\t\t$cnt--;\n\t}\n\n\treturn $line;\n}\n\nsub get_stat_real {\n\tmy ($linenr, $lc) = @_;\n\n\tmy $stat_real = raw_line($linenr, 0);\n\tfor (my $count = $linenr + 1; $count <= $lc; $count++) {\n\t\t$stat_real = $stat_real . \"\\n\" . raw_line($count, 0);\n\t}\n\n\treturn $stat_real;\n}\n\nsub get_stat_here {\n\tmy ($linenr, $cnt, $here) = @_;\n\n\tmy $herectx = $here . \"\\n\";\n\tfor (my $n = 0; $n < $cnt; $n++) {\n\t\t$herectx .= raw_line($linenr, $n) . \"\\n\";\n\t}\n\n\treturn $herectx;\n}\n\nsub cat_vet {\n\tmy ($vet) = @_;\n\tmy ($res, $coded);\n\n\t$res = '';\n\twhile ($vet =~ /([^[:cntrl:]]*)([[:cntrl:]]|$)/g) {\n\t\t$res .= $1;\n\t\tif ($2 ne '') {\n\t\t\t$coded = sprintf(\"^%c\", unpack('C', $2) + 64);\n\t\t\t$res .= $coded;\n\t\t}\n\t}\n\t$res =~ s/$/\\$/;\n\n\treturn $res;\n}\n\nmy $av_preprocessor = 0;\nmy $av_pending;\nmy @av_paren_type;\nmy $av_pend_colon;\n\nsub annotate_reset {\n\t$av_preprocessor = 0;\n\t$av_pending = '_';\n\t@av_paren_type = ('E');\n\t$av_pend_colon = 'O';\n}\n\nsub annotate_values {\n\tmy ($stream, $type) = @_;\n\n\tmy $res;\n\tmy $var = '_' x length($stream);\n\tmy $cur = $stream;\n\n\tprint \"$stream\\n\" if ($dbg_values > 1);\n\n\twhile (length($cur)) {\n\t\t@av_paren_type = ('E') if ($#av_paren_type < 0);\n\t\tprint \" <\" . join('', @av_paren_type) .\n\t\t\t\t\"> <$type> <$av_pending>\" if ($dbg_values > 1);\n\t\tif ($cur =~ /^(\\s+)/o) {\n\t\t\tprint \"WS($1)\\n\" if ($dbg_values > 1);\n\t\t\tif ($1 =~ /\\n/ && $av_preprocessor) {\n\t\t\t\t$type = pop(@av_paren_type);\n\t\t\t\t$av_preprocessor = 0;\n\t\t\t}\n\n\t\t} elsif ($cur =~ /^(\\(\\s*$Type\\s*)\\)/ && $av_pending eq '_') {\n\t\t\tprint \"CAST($1)\\n\" if ($dbg_values > 1);\n\t\t\tpush(@av_paren_type, $type);\n\t\t\t$type = 'c';\n\n\t\t} elsif ($cur =~ /^($Type)\\s*(?:$Ident|,|\\)|\\(|\\s*$)/) {\n\t\t\tprint \"DECLARE($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'T';\n\n\t\t} elsif ($cur =~ /^($Modifier)\\s*/) {\n\t\t\tprint \"MODIFIER($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'T';\n\n\t\t} elsif ($cur =~ /^(\\#\\s*define\\s*$Ident)(\\(?)/o) {\n\t\t\tprint \"DEFINE($1,$2)\\n\" if ($dbg_values > 1);\n\t\t\t$av_preprocessor = 1;\n\t\t\tpush(@av_paren_type, $type);\n\t\t\tif ($2 ne '') {\n\t\t\t\t$av_pending = 'N';\n\t\t\t}\n\t\t\t$type = 'E';\n\n\t\t} elsif ($cur =~ /^(\\#\\s*(?:undef\\s*$Ident|include\\b))/o) {\n\t\t\tprint \"UNDEF($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_preprocessor = 1;\n\t\t\tpush(@av_paren_type, $type);\n\n\t\t} elsif ($cur =~ /^(\\#\\s*(?:ifdef|ifndef|if))/o) {\n\t\t\tprint \"PRE_START($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_preprocessor = 1;\n\n\t\t\tpush(@av_paren_type, $type);\n\t\t\tpush(@av_paren_type, $type);\n\t\t\t$type = 'E';\n\n\t\t} elsif ($cur =~ /^(\\#\\s*(?:else|elif))/o) {\n\t\t\tprint \"PRE_RESTART($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_preprocessor = 1;\n\n\t\t\tpush(@av_paren_type, $av_paren_type[$#av_paren_type]);\n\n\t\t\t$type = 'E';\n\n\t\t} elsif ($cur =~ /^(\\#\\s*(?:endif))/o) {\n\t\t\tprint \"PRE_END($1)\\n\" if ($dbg_values > 1);\n\n\t\t\t$av_preprocessor = 1;\n\n\t\t\t# Assume all arms of the conditional end as this\n\t\t\t# one does, and continue as if the #endif was not here.\n\t\t\tpop(@av_paren_type);\n\t\t\tpush(@av_paren_type, $type);\n\t\t\t$type = 'E';\n\n\t\t} elsif ($cur =~ /^(\\\\\\n)/o) {\n\t\t\tprint \"PRECONT($1)\\n\" if ($dbg_values > 1);\n\n\t\t} elsif ($cur =~ /^(__attribute__)\\s*\\(?/o) {\n\t\t\tprint \"ATTR($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_pending = $type;\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(sizeof)\\s*(\\()?/o) {\n\t\t\tprint \"SIZEOF($1)\\n\" if ($dbg_values > 1);\n\t\t\tif (defined $2) {\n\t\t\t\t$av_pending = 'V';\n\t\t\t}\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(if|while|for)\\b/o) {\n\t\t\tprint \"COND($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_pending = 'E';\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~/^(case)/o) {\n\t\t\tprint \"CASE($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_pend_colon = 'C';\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~/^(return|else|goto|typeof|__typeof__)\\b/o) {\n\t\t\tprint \"KEYWORD($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(\\()/o) {\n\t\t\tprint \"PAREN('$1')\\n\" if ($dbg_values > 1);\n\t\t\tpush(@av_paren_type, $av_pending);\n\t\t\t$av_pending = '_';\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(\\))/o) {\n\t\t\tmy $new_type = pop(@av_paren_type);\n\t\t\tif ($new_type ne '_') {\n\t\t\t\t$type = $new_type;\n\t\t\t\tprint \"PAREN('$1') -> $type\\n\"\n\t\t\t\t\t\t\tif ($dbg_values > 1);\n\t\t\t} else {\n\t\t\t\tprint \"PAREN('$1')\\n\" if ($dbg_values > 1);\n\t\t\t}\n\n\t\t} elsif ($cur =~ /^($Ident)\\s*\\(/o) {\n\t\t\tprint \"FUNC($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'V';\n\t\t\t$av_pending = 'V';\n\n\t\t} elsif ($cur =~ /^($Ident\\s*):(?:\\s*\\d+\\s*(,|=|;))?/) {\n\t\t\tif (defined $2 && $type eq 'C' || $type eq 'T') {\n\t\t\t\t$av_pend_colon = 'B';\n\t\t\t} elsif ($type eq 'E') {\n\t\t\t\t$av_pend_colon = 'L';\n\t\t\t}\n\t\t\tprint \"IDENT_COLON($1,$type>$av_pend_colon)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'V';\n\n\t\t} elsif ($cur =~ /^($Ident|$Constant)/o) {\n\t\t\tprint \"IDENT($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'V';\n\n\t\t} elsif ($cur =~ /^($Assignment)/o) {\n\t\t\tprint \"ASSIGN($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~/^(;|{|})/) {\n\t\t\tprint \"END($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'E';\n\t\t\t$av_pend_colon = 'O';\n\n\t\t} elsif ($cur =~/^(,)/) {\n\t\t\tprint \"COMMA($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'C';\n\n\t\t} elsif ($cur =~ /^(\\?)/o) {\n\t\t\tprint \"QUESTION($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(:)/o) {\n\t\t\tprint \"COLON($1,$av_pend_colon)\\n\" if ($dbg_values > 1);\n\n\t\t\tsubstr($var, length($res), 1, $av_pend_colon);\n\t\t\tif ($av_pend_colon eq 'C' || $av_pend_colon eq 'L') {\n\t\t\t\t$type = 'E';\n\t\t\t} else {\n\t\t\t\t$type = 'N';\n\t\t\t}\n\t\t\t$av_pend_colon = 'O';\n\n\t\t} elsif ($cur =~ /^(\\[)/o) {\n\t\t\tprint \"CLOSE($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(-(?![->])|\\+(?!\\+)|\\*|\\&\\&|\\&)/o) {\n\t\t\tmy $variant;\n\n\t\t\tprint \"OPV($1)\\n\" if ($dbg_values > 1);\n\t\t\tif ($type eq 'V') {\n\t\t\t\t$variant = 'B';\n\t\t\t} else {\n\t\t\t\t$variant = 'U';\n\t\t\t}\n\n\t\t\tsubstr($var, length($res), 1, $variant);\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^($Operators)/o) {\n\t\t\tprint \"OP($1)\\n\" if ($dbg_values > 1);\n\t\t\tif ($1 ne '++' && $1 ne '--') {\n\t\t\t\t$type = 'N';\n\t\t\t}\n\n\t\t} elsif ($cur =~ /(^.)/o) {\n\t\t\tprint \"C($1)\\n\" if ($dbg_values > 1);\n\t\t}\n\t\tif (defined $1) {\n\t\t\t$cur = substr($cur, length($1));\n\t\t\t$res .= $type x length($1);\n\t\t}\n\t}\n\n\treturn ($res, $var);\n}\n\nsub possible {\n\tmy ($possible, $line) = @_;\n\tmy $notPermitted = qr{(?:\n\t\t^(?:\n\t\t\t$Modifier|\n\t\t\t$Storage|\n\t\t\t$Type|\n\t\t\tDEFINE_\\S+\n\t\t)$|\n\t\t^(?:\n\t\t\tgoto|\n\t\t\treturn|\n\t\t\tcase|\n\t\t\telse|\n\t\t\tasm|__asm__|\n\t\t\tdo|\n\t\t\t\\#|\n\t\t\t\\#\\#|\n\t\t)(?:\\s|$)|\n\t\t^(?:typedef|struct|enum)\\b\n\t    )}x;\n\twarn \"CHECK<$possible> ($line)\\n\" if ($dbg_possible > 2);\n\tif ($possible !~ $notPermitted) {\n\t\t# Check for modifiers.\n\t\t$possible =~ s/\\s*$Storage\\s*//g;\n\t\t$possible =~ s/\\s*$Sparse\\s*//g;\n\t\tif ($possible =~ /^\\s*$/) {\n\n\t\t} elsif ($possible =~ /\\s/) {\n\t\t\t$possible =~ s/\\s*$Type\\s*//g;\n\t\t\tfor my $modifier (split(' ', $possible)) {\n\t\t\t\tif ($modifier !~ $notPermitted) {\n\t\t\t\t\twarn \"MODIFIER: $modifier ($possible) ($line)\\n\" if ($dbg_possible);\n\t\t\t\t\tpush(@modifierListFile, $modifier);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\twarn \"POSSIBLE: $possible ($line)\\n\" if ($dbg_possible);\n\t\t\tpush(@typeListFile, $possible);\n\t\t}\n\t\tbuild_types();\n\t} else {\n\t\twarn \"NOTPOSS: $possible ($line)\\n\" if ($dbg_possible > 1);\n\t}\n}\n\nmy $prefix = '';\n\nsub show_type {\n\tmy ($type) = @_;\n\n\t$type =~ tr/[a-z]/[A-Z]/;\n\n\treturn defined $use_type{$type} if (scalar keys %use_type > 0);\n\n\treturn !defined $ignore_type{$type};\n}\n\nsub report {\n\tmy ($level, $type, $msg) = @_;\n\n\tif (!show_type($type) ||\n\t    (defined $tst_only && $msg !~ /\\Q$tst_only\\E/)) {\n\t\treturn 0;\n\t}\n\tmy $output = '';\n\tif ($color) {\n\t\tif ($level eq 'ERROR') {\n\t\t\t$output .= RED;\n\t\t} elsif ($level eq 'WARNING') {\n\t\t\t$output .= YELLOW;\n\t\t} else {\n\t\t\t$output .= GREEN;\n\t\t}\n\t}\n\t$output .= $prefix . $level . ':';\n\tif ($show_types) {\n\t\t$output .= BLUE if ($color);\n\t\t$output .= \"$type:\";\n\t}\n\t$output .= RESET if ($color);\n\t$output .= ' ' . $msg . \"\\n\";\n\n\tif ($showfile) {\n\t\tmy @lines = split(\"\\n\", $output, -1);\n\t\tsplice(@lines, 1, 1);\n\t\t$output = join(\"\\n\", @lines);\n\t}\n\n\tif ($terse) {\n\t\t$output = (split('\\n', $output))[0] . \"\\n\";\n\t}\n\n\tif ($verbose && exists($verbose_messages{$type}) &&\n\t    !exists($verbose_emitted{$type})) {\n\t\t$output .= $verbose_messages{$type} . \"\\n\\n\";\n\t\t$verbose_emitted{$type} = 1;\n\t}\n\n\tpush(our @report, $output);\n\n\treturn 1;\n}\n\nsub report_dump {\n\tour @report;\n}\n\nsub fixup_current_range {\n\tmy ($lineRef, $offset, $length) = @_;\n\n\tif ($$lineRef =~ /^\\@\\@ -\\d+,\\d+ \\+(\\d+),(\\d+) \\@\\@/) {\n\t\tmy $o = $1;\n\t\tmy $l = $2;\n\t\tmy $no = $o + $offset;\n\t\tmy $nl = $l + $length;\n\t\t$$lineRef =~ s/\\+$o,$l \\@\\@/\\+$no,$nl \\@\\@/;\n\t}\n}\n\nsub fix_inserted_deleted_lines {\n\tmy ($linesRef, $insertedRef, $deletedRef) = @_;\n\n\tmy $range_last_linenr = 0;\n\tmy $delta_offset = 0;\n\n\tmy $old_linenr = 0;\n\tmy $new_linenr = 0;\n\n\tmy $next_insert = 0;\n\tmy $next_delete = 0;\n\n\tmy @lines = ();\n\n\tmy $inserted = @{$insertedRef}[$next_insert++];\n\tmy $deleted = @{$deletedRef}[$next_delete++];\n\n\tforeach my $old_line (@{$linesRef}) {\n\t\tmy $save_line = 1;\n\t\tmy $line = $old_line;\t#don't modify the array\n\t\tif ($line =~ /^(?:\\+\\+\\+|\\-\\-\\-)\\s+\\S+/) {\t#new filename\n\t\t\t$delta_offset = 0;\n\t\t} elsif ($line =~ /^\\@\\@ -\\d+,\\d+ \\+\\d+,\\d+ \\@\\@/) {\t#new hunk\n\t\t\t$range_last_linenr = $new_linenr;\n\t\t\tfixup_current_range(\\$line, $delta_offset, 0);\n\t\t}\n\n\t\twhile (defined($deleted) && ${$deleted}{'LINENR'} == $old_linenr) {\n\t\t\t$deleted = @{$deletedRef}[$next_delete++];\n\t\t\t$save_line = 0;\n\t\t\tfixup_current_range(\\$lines[$range_last_linenr], $delta_offset--, -1);\n\t\t}\n\n\t\twhile (defined($inserted) && ${$inserted}{'LINENR'} == $old_linenr) {\n\t\t\tpush(@lines, ${$inserted}{'LINE'});\n\t\t\t$inserted = @{$insertedRef}[$next_insert++];\n\t\t\t$new_linenr++;\n\t\t\tfixup_current_range(\\$lines[$range_last_linenr], $delta_offset++, 1);\n\t\t}\n\n\t\tif ($save_line) {\n\t\t\tpush(@lines, $line);\n\t\t\t$new_linenr++;\n\t\t}\n\n\t\t$old_linenr++;\n\t}\n\n\treturn @lines;\n}\n\nsub fix_insert_line {\n\tmy ($linenr, $line) = @_;\n\n\tmy $inserted = {\n\t\tLINENR => $linenr,\n\t\tLINE => $line,\n\t};\n\tpush(@fixed_inserted, $inserted);\n}\n\nsub fix_delete_line {\n\tmy ($linenr, $line) = @_;\n\n\tmy $deleted = {\n\t\tLINENR => $linenr,\n\t\tLINE => $line,\n\t};\n\n\tpush(@fixed_deleted, $deleted);\n}\n\nsub ERROR {\n\tmy ($type, $msg) = @_;\n\n\tif (report(\"ERROR\", $type, $msg)) {\n\t\tour $clean = 0;\n\t\tour $cnt_error++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nsub WARN {\n\tmy ($type, $msg) = @_;\n\n\tif (report(\"WARNING\", $type, $msg)) {\n\t\tour $clean = 0;\n\t\tour $cnt_warn++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nsub CHK {\n\tmy ($type, $msg) = @_;\n\n\tif ($check && report(\"CHECK\", $type, $msg)) {\n\t\tour $clean = 0;\n\t\tour $cnt_chk++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nsub check_absolute_file {\n\tmy ($absolute, $herecurr) = @_;\n\tmy $file = $absolute;\n\n\t##print \"absolute<$absolute>\\n\";\n\n\t# See if any suffix of this path is a path within the tree.\n\twhile ($file =~ s@^[^/]*/@@) {\n\t\tif (-f \"$root/$file\") {\n\t\t\t##print \"file<$file>\\n\";\n\t\t\tlast;\n\t\t}\n\t}\n\tif (! -f _)  {\n\t\treturn 0;\n\t}\n\n\t# It is, so see if the prefix is acceptable.\n\tmy $prefix = $absolute;\n\tsubstr($prefix, -length($file)) = '';\n\n\t##print \"prefix<$prefix>\\n\";\n\tif ($prefix ne \".../\") {\n\t\tWARN(\"USE_RELATIVE_PATH\",\n\t\t     \"use relative pathname instead of absolute in changelog text\\n\" . $herecurr);\n\t}\n}\n\nsub trim {\n\tmy ($string) = @_;\n\n\t$string =~ s/^\\s+|\\s+$//g;\n\n\treturn $string;\n}\n\nsub ltrim {\n\tmy ($string) = @_;\n\n\t$string =~ s/^\\s+//;\n\n\treturn $string;\n}\n\nsub rtrim {\n\tmy ($string) = @_;\n\n\t$string =~ s/\\s+$//;\n\n\treturn $string;\n}\n\nsub string_find_replace {\n\tmy ($string, $find, $replace) = @_;\n\n\t$string =~ s/$find/$replace/g;\n\n\treturn $string;\n}\n\nsub tabify {\n\tmy ($leading) = @_;\n\n\tmy $source_indent = $tabsize;\n\tmy $max_spaces_before_tab = $source_indent - 1;\n\tmy $spaces_to_tab = \" \" x $source_indent;\n\n\t#convert leading spaces to tabs\n\t1 while $leading =~ s@^([\\t]*)$spaces_to_tab@$1\\t@g;\n\t#Remove spaces before a tab\n\t1 while $leading =~ s@^([\\t]*)( {1,$max_spaces_before_tab})\\t@$1\\t@g;\n\n\treturn \"$leading\";\n}\n\nsub pos_last_openparen {\n\tmy ($line) = @_;\n\n\tmy $pos = 0;\n\n\tmy $opens = $line =~ tr/\\(/\\(/;\n\tmy $closes = $line =~ tr/\\)/\\)/;\n\n\tmy $last_openparen = 0;\n\n\tif (($opens == 0) || ($closes >= $opens)) {\n\t\treturn -1;\n\t}\n\n\tmy $len = length($line);\n\n\tfor ($pos = 0; $pos < $len; $pos++) {\n\t\tmy $string = substr($line, $pos);\n\t\tif ($string =~ /^($FuncArg|$balanced_parens)/) {\n\t\t\t$pos += length($1) - 1;\n\t\t} elsif (substr($line, $pos, 1) eq '(') {\n\t\t\t$last_openparen = $pos;\n\t\t} elsif (index($string, '(') == -1) {\n\t\t\tlast;\n\t\t}\n\t}\n\n\treturn length(expand_tabs(substr($line, 0, $last_openparen))) + 1;\n}\n\nsub get_raw_comment {\n\tmy ($line, $rawline) = @_;\n\tmy $comment = '';\n\n\tfor my $i (0 .. (length($line) - 1)) {\n\t\tif (substr($line, $i, 1) eq \"$;\") {\n\t\t\t$comment .= substr($rawline, $i, 1);\n\t\t}\n\t}\n\n\treturn $comment;\n}\n\nsub exclude_global_initialisers {\n\tmy ($realfile) = @_;\n\n\t# Do not check for BPF programs (tools/testing/selftests/bpf/progs/*.c, samples/bpf/*_kern.c, *.bpf.c).\n\treturn $realfile =~ m@^tools/testing/selftests/bpf/progs/.*\\.c$@ ||\n\t\t$realfile =~ m@^samples/bpf/.*_kern\\.c$@ ||\n\t\t$realfile =~ m@/bpf/.*\\.bpf\\.c$@;\n}\n\nsub process {\n\tmy $filename = shift;\n\n\tmy $linenr=0;\n\tmy $prevline=\"\";\n\tmy $prevrawline=\"\";\n\tmy $stashline=\"\";\n\tmy $stashrawline=\"\";\n\n\tmy $length;\n\tmy $indent;\n\tmy $previndent=0;\n\tmy $stashindent=0;\n\n\tour $clean = 1;\n\tmy $signoff = 0;\n\tmy $author = '';\n\tmy $authorsignoff = 0;\n\tmy $author_sob = '';\n\tmy $is_patch = 0;\n\tmy $is_binding_patch = -1;\n\tmy $in_header_lines = $file ? 0 : 1;\n\tmy $in_commit_log = 0;\t\t#Scanning lines before patch\n\tmy $has_patch_separator = 0;\t#Found a --- line\n\tmy $has_commit_log = 0;\t\t#Encountered lines before patch\n\tmy $commit_log_lines = 0;\t#Number of commit log lines\n\tmy $commit_log_possible_stack_dump = 0;\n\tmy $commit_log_long_line = 0;\n\tmy $commit_log_has_diff = 0;\n\tmy $reported_maintainer_file = 0;\n\tmy $non_utf8_charset = 0;\n\n\tmy $last_git_commit_id_linenr = -1;\n\n\tmy $last_blank_line = 0;\n\tmy $last_coalesced_string_linenr = -1;\n\n\tour @report = ();\n\tour $cnt_lines = 0;\n\tour $cnt_error = 0;\n\tour $cnt_warn = 0;\n\tour $cnt_chk = 0;\n\n\t# Trace the real file/line as we go.\n\tmy $realfile = '';\n\tmy $realline = 0;\n\tmy $realcnt = 0;\n\tmy $here = '';\n\tmy $context_function;\t\t#undef'd unless there's a known function\n\tmy $in_comment = 0;\n\tmy $comment_edge = 0;\n\tmy $first_line = 0;\n\tmy $p1_prefix = '';\n\n\tmy $prev_values = 'E';\n\n\t# suppression flags\n\tmy %suppress_ifbraces;\n\tmy %suppress_whiletrailers;\n\tmy %suppress_export;\n\tmy $suppress_statement = 0;\n\n\tmy %signatures = ();\n\n\t# Pre-scan the patch sanitizing the lines.\n\t# Pre-scan the patch looking for any __setup documentation.\n\t#\n\tmy @setup_docs = ();\n\tmy $setup_docs = 0;\n\n\tmy $camelcase_file_seeded = 0;\n\n\tmy $checklicenseline = 1;\n\n\tsanitise_line_reset();\n\tmy $line;\n\tforeach my $rawline (@rawlines) {\n\t\t$linenr++;\n\t\t$line = $rawline;\n\n\t\tpush(@fixed, $rawline) if ($fix);\n\n\t\tif ($rawline=~/^\\+\\+\\+\\s+(\\S+)/) {\n\t\t\t$setup_docs = 0;\n\t\t\tif ($1 =~ m@Documentation/admin-guide/kernel-parameters.txt$@) {\n\t\t\t\t$setup_docs = 1;\n\t\t\t}\n\t\t\t#next;\n\t\t}\n\t\tif ($rawline =~ /^\\@\\@ -\\d+(?:,\\d+)? \\+(\\d+)(,(\\d+))? \\@\\@/) {\n\t\t\t$realline=$1-1;\n\t\t\tif (defined $2) {\n\t\t\t\t$realcnt=$3+1;\n\t\t\t} else {\n\t\t\t\t$realcnt=1+1;\n\t\t\t}\n\t\t\t$in_comment = 0;\n\n\t\t\t# Guestimate if this is a continuing comment.  Run\n\t\t\t# the context looking for a comment \"edge\".  If this\n\t\t\t# edge is a close comment then we must be in a comment\n\t\t\t# at context start.\n\t\t\tmy $edge;\n\t\t\tmy $cnt = $realcnt;\n\t\t\tfor (my $ln = $linenr + 1; $cnt > 0; $ln++) {\n\t\t\t\tnext if (defined $rawlines[$ln - 1] &&\n\t\t\t\t\t $rawlines[$ln - 1] =~ /^-/);\n\t\t\t\t$cnt--;\n\t\t\t\t#print \"RAW<$rawlines[$ln - 1]>\\n\";\n\t\t\t\tlast if (!defined $rawlines[$ln - 1]);\n\t\t\t\tif ($rawlines[$ln - 1] =~ m@(/\\*|\\*/)@ &&\n\t\t\t\t    $rawlines[$ln - 1] !~ m@\"[^\"]*(?:/\\*|\\*/)[^\"]*\"@) {\n\t\t\t\t\t($edge) = $1;\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (defined $edge && $edge eq '*/') {\n\t\t\t\t$in_comment = 1;\n\t\t\t}\n\n\t\t\t# Guestimate if this is a continuing comment.  If this\n\t\t\t# is the start of a diff block and this line starts\n\t\t\t# ' *' then it is very likely a comment.\n\t\t\tif (!defined $edge &&\n\t\t\t    $rawlines[$linenr] =~ m@^.\\s*(?:\\*\\*+| \\*)(?:\\s|$)@)\n\t\t\t{\n\t\t\t\t$in_comment = 1;\n\t\t\t}\n\n\t\t\t##print \"COMMENT:$in_comment edge<$edge> $rawline\\n\";\n\t\t\tsanitise_line_reset($in_comment);\n\n\t\t} elsif ($realcnt && $rawline =~ /^(?:\\+| |$)/) {\n\t\t\t# Standardise the strings and chars within the input to\n\t\t\t# simplify matching -- only bother with positive lines.\n\t\t\t$line = sanitise_line($rawline);\n\t\t}\n\t\tpush(@lines, $line);\n\n\t\tif ($realcnt > 1) {\n\t\t\t$realcnt-- if ($line =~ /^(?:\\+| |$)/);\n\t\t} else {\n\t\t\t$realcnt = 0;\n\t\t}\n\n\t\t#print \"==>$rawline\\n\";\n\t\t#print \"-->$line\\n\";\n\n\t\tif ($setup_docs && $line =~ /^\\+/) {\n\t\t\tpush(@setup_docs, $line);\n\t\t}\n\t}\n\n\t$prefix = '';\n\n\t$realcnt = 0;\n\t$linenr = 0;\n\t$fixlinenr = -1;\n\tforeach my $line (@lines) {\n\t\t$linenr++;\n\t\t$fixlinenr++;\n\t\tmy $sline = $line;\t#copy of $line\n\t\t$sline =~ s/$;/ /g;\t#with comments as spaces\n\n\t\tmy $rawline = $rawlines[$linenr - 1];\n\t\tmy $raw_comment = get_raw_comment($line, $rawline);\n\n# check if it's a mode change, rename or start of a patch\n\t\tif (!$in_commit_log &&\n\t\t    ($line =~ /^ mode change [0-7]+ => [0-7]+ \\S+\\s*$/ ||\n\t\t    ($line =~ /^rename (?:from|to) \\S+\\s*$/ ||\n\t\t     $line =~ /^diff --git a\\/[\\w\\/\\.\\_\\-]+ b\\/\\S+\\s*$/))) {\n\t\t\t$is_patch = 1;\n\t\t}\n\n#extract the line range in the file after the patch is applied\n\t\tif (!$in_commit_log &&\n\t\t    $line =~ /^\\@\\@ -\\d+(?:,\\d+)? \\+(\\d+)(,(\\d+))? \\@\\@(.*)/) {\n\t\t\tmy $context = $4;\n\t\t\t$is_patch = 1;\n\t\t\t$first_line = $linenr + 1;\n\t\t\t$realline=$1-1;\n\t\t\tif (defined $2) {\n\t\t\t\t$realcnt=$3+1;\n\t\t\t} else {\n\t\t\t\t$realcnt=1+1;\n\t\t\t}\n\t\t\tannotate_reset();\n\t\t\t$prev_values = 'E';\n\n\t\t\t%suppress_ifbraces = ();\n\t\t\t%suppress_whiletrailers = ();\n\t\t\t%suppress_export = ();\n\t\t\t$suppress_statement = 0;\n\t\t\tif ($context =~ /\\b(\\w+)\\s*\\(/) {\n\t\t\t\t$context_function = $1;\n\t\t\t} else {\n\t\t\t\tundef $context_function;\n\t\t\t}\n\t\t\tnext;\n\n# track the line number as we move through the hunk, note that\n# new versions of GNU diff omit the leading space on completely\n# blank context lines so we need to count that too.\n\t\t} elsif ($line =~ /^( |\\+|$)/) {\n\t\t\t$realline++;\n\t\t\t$realcnt-- if ($realcnt != 0);\n\n\t\t\t# Measure the line length and indent.\n\t\t\t($length, $indent) = line_stats($rawline);\n\n\t\t\t# Track the previous line.\n\t\t\t($prevline, $stashline) = ($stashline, $line);\n\t\t\t($previndent, $stashindent) = ($stashindent, $indent);\n\t\t\t($prevrawline, $stashrawline) = ($stashrawline, $rawline);\n\n\t\t\t#warn \"line<$line>\\n\";\n\n\t\t} elsif ($realcnt == 1) {\n\t\t\t$realcnt--;\n\t\t}\n\n\t\tmy $hunk_line = ($realcnt != 0);\n\n\t\t$here = \"#$linenr: \" if (!$file);\n\t\t$here = \"#$realline: \" if ($file);\n\n\t\tmy $found_file = 0;\n\t\t# extract the filename as it passes\n\t\tif ($line =~ /^diff --git.*?(\\S+)$/) {\n\t\t\t$realfile = $1;\n\t\t\t$realfile =~ s@^([^/]*)/@@ if (!$file);\n\t\t\t$in_commit_log = 0;\n\t\t\t$found_file = 1;\n\t\t} elsif ($line =~ /^\\+\\+\\+\\s+(\\S+)/) {\n\t\t\t$realfile = $1;\n\t\t\t$realfile =~ s@^([^/]*)/@@ if (!$file);\n\t\t\t$in_commit_log = 0;\n\n\t\t\t$p1_prefix = $1;\n\t\t\tif (!$file && $tree && $p1_prefix ne '' &&\n\t\t\t    -e \"$root/$p1_prefix\") {\n\t\t\t\tWARN(\"PATCH_PREFIX\",\n\t\t\t\t     \"patch prefix '$p1_prefix' exists, appears to be a -p0 patch\\n\");\n\t\t\t}\n\n\t\t\tif ($realfile =~ m@^include/asm/@) {\n\t\t\t\tERROR(\"MODIFIED_INCLUDE_ASM\",\n\t\t\t\t      \"do not modify files in include/asm, change architecture specific files in include/asm-<architecture>\\n\" . \"$here$rawline\\n\");\n\t\t\t}\n\t\t\t$found_file = 1;\n\t\t}\n\n#make up the handle for any error we report on this line\n\t\tif ($showfile) {\n\t\t\t$prefix = \"$realfile:$realline: \"\n\t\t} elsif ($emacs) {\n\t\t\tif ($file) {\n\t\t\t\t$prefix = \"$filename:$realline: \";\n\t\t\t} else {\n\t\t\t\t$prefix = \"$filename:$linenr: \";\n\t\t\t}\n\t\t}\n\n\t\tif ($found_file) {\n\t\t\tif (is_maintained_obsolete($realfile)) {\n\t\t\t\tWARN(\"OBSOLETE\",\n\t\t\t\t     \"$realfile is marked as 'obsolete' in the MAINTAINERS hierarchy.  No unnecessary modifications please.\\n\");\n\t\t\t}\n\t\t\tif ($realfile =~ m@^(?:drivers/net/|net/|drivers/staging/)@) {\n\t\t\t\t$check = 1;\n\t\t\t} else {\n\t\t\t\t$check = $check_orig;\n\t\t\t}\n\t\t\t$checklicenseline = 1;\n\n\t\t\tif ($realfile !~ /^MAINTAINERS/) {\n\t\t\t\tmy $last_binding_patch = $is_binding_patch;\n\n\t\t\t\t$is_binding_patch = () = $realfile =~ m@^(?:Documentation/devicetree/|include/dt-bindings/)@;\n\n\t\t\t\tif (($last_binding_patch != -1) &&\n\t\t\t\t    ($last_binding_patch ^ $is_binding_patch)) {\n\t\t\t\t\tWARN(\"DT_SPLIT_BINDING_PATCH\",\n\t\t\t\t\t     \"DT binding docs and includes should be a separate patch. See: Documentation/devicetree/bindings/submitting-patches.rst\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext;\n\t\t}\n\n\t\t$here .= \"FILE: $realfile:$realline:\" if ($realcnt != 0);\n\n\t\tmy $hereline = \"$here\\n$rawline\\n\";\n\t\tmy $herecurr = \"$here\\n$rawline\\n\";\n\t\tmy $hereprev = \"$here\\n$prevrawline\\n$rawline\\n\";\n\n\t\t$cnt_lines++ if ($realcnt != 0);\n\n# Verify the existence of a commit log if appropriate\n# 2 is used because a $signature is counted in $commit_log_lines\n\t\tif ($in_commit_log) {\n\t\t\tif ($line !~ /^\\s*$/) {\n\t\t\t\t$commit_log_lines++;\t#could be a $signature\n\t\t\t}\n\t\t} elsif ($has_commit_log && $commit_log_lines < 2) {\n\t\t\tWARN(\"COMMIT_MESSAGE\",\n\t\t\t     \"Missing commit description - Add an appropriate one\\n\");\n\t\t\t$commit_log_lines = 2;\t#warn only once\n\t\t}\n\n# Check if the commit log has what seems like a diff which can confuse patch\n\t\tif ($in_commit_log && !$commit_log_has_diff &&\n\t\t    (($line =~ m@^\\s+diff\\b.*a/([\\w/]+)@ &&\n\t\t      $line =~ m@^\\s+diff\\b.*a/[\\w/]+\\s+b/$1\\b@) ||\n\t\t     $line =~ m@^\\s*(?:\\-\\-\\-\\s+a/|\\+\\+\\+\\s+b/)@ ||\n\t\t     $line =~ m/^\\s*\\@\\@ \\-\\d+,\\d+ \\+\\d+,\\d+ \\@\\@/)) {\n\t\t\tERROR(\"DIFF_IN_COMMIT_MSG\",\n\t\t\t      \"Avoid using diff content in the commit message - patch(1) might not work\\n\" . $herecurr);\n\t\t\t$commit_log_has_diff = 1;\n\t\t}\n\n# Check for incorrect file permissions\n\t\tif ($line =~ /^new (file )?mode.*[7531]\\d{0,2}$/) {\n\t\t\tmy $permhere = $here . \"FILE: $realfile\\n\";\n\t\t\tif ($realfile !~ m@scripts/@ &&\n\t\t\t    $realfile !~ /\\.(py|pl|awk|sh)$/) {\n\t\t\t\tERROR(\"EXECUTE_PERMISSIONS\",\n\t\t\t\t      \"do not set execute permissions for source files\\n\" . $permhere);\n\t\t\t}\n\t\t}\n\n# Check the patch for a From:\n\t\tif (decode(\"MIME-Header\", $line) =~ /^From:\\s*(.*)/) {\n\t\t\t$author = $1;\n\t\t\tmy $curline = $linenr;\n\t\t\twhile(defined($rawlines[$curline]) && ($rawlines[$curline++] =~ /^[ \\t]\\s*(.*)/)) {\n\t\t\t\t$author .= $1;\n\t\t\t}\n\t\t\t$author = encode(\"utf8\", $author) if ($line =~ /=\\?utf-8\\?/i);\n\t\t\t$author =~ s/\"//g;\n\t\t\t$author = reformat_email($author);\n\t\t}\n\n# Check the patch for a signoff:\n\t\tif ($line =~ /^\\s*signed-off-by:\\s*(.*)/i) {\n\t\t\t$signoff++;\n\t\t\t$in_commit_log = 0;\n\t\t\tif ($author ne ''  && $authorsignoff != 1) {\n\t\t\t\tif (same_email_addresses($1, $author)) {\n\t\t\t\t\t$authorsignoff = 1;\n\t\t\t\t} else {\n\t\t\t\t\tmy $ctx = $1;\n\t\t\t\t\tmy ($email_name, $email_comment, $email_address, $comment1) = parse_email($ctx);\n\t\t\t\t\tmy ($author_name, $author_comment, $author_address, $comment2) = parse_email($author);\n\n\t\t\t\t\tif (lc $email_address eq lc $author_address && $email_name eq $author_name) {\n\t\t\t\t\t\t$author_sob = $ctx;\n\t\t\t\t\t\t$authorsignoff = 2;\n\t\t\t\t\t} elsif (lc $email_address eq lc $author_address) {\n\t\t\t\t\t\t$author_sob = $ctx;\n\t\t\t\t\t\t$authorsignoff = 3;\n\t\t\t\t\t} elsif ($email_name eq $author_name) {\n\t\t\t\t\t\t$author_sob = $ctx;\n\t\t\t\t\t\t$authorsignoff = 4;\n\n\t\t\t\t\t\tmy $address1 = $email_address;\n\t\t\t\t\t\tmy $address2 = $author_address;\n\n\t\t\t\t\t\tif ($address1 =~ /(\\S+)\\+\\S+(\\@.*)/) {\n\t\t\t\t\t\t\t$address1 = \"$1$2\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($address2 =~ /(\\S+)\\+\\S+(\\@.*)/) {\n\t\t\t\t\t\t\t$address2 = \"$1$2\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($address1 eq $address2) {\n\t\t\t\t\t\t\t$authorsignoff = 5;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check for patch separator\n\t\tif ($line =~ /^---$/) {\n\t\t\t$has_patch_separator = 1;\n\t\t\t$in_commit_log = 0;\n\t\t}\n\n# Check if MAINTAINERS is being updated.  If so, there's probably no need to\n# emit the \"does MAINTAINERS need updating?\" message on file add/move/delete\n\t\tif ($line =~ /^\\s*MAINTAINERS\\s*\\|/) {\n\t\t\t$reported_maintainer_file = 1;\n\t\t}\n\n# Check signature styles\n\t\tif (!$in_header_lines &&\n\t\t    $line =~ /^(\\s*)([a-z0-9_-]+by:|$signature_tags)(\\s*)(.*)/i) {\n\t\t\tmy $space_before = $1;\n\t\t\tmy $sign_off = $2;\n\t\t\tmy $space_after = $3;\n\t\t\tmy $email = $4;\n\t\t\tmy $ucfirst_sign_off = ucfirst(lc($sign_off));\n\n\t\t\tif ($sign_off !~ /$signature_tags/) {\n\t\t\t\tmy $suggested_signature = find_standard_signature($sign_off);\n\t\t\t\tif ($suggested_signature eq \"\") {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t     \"Non-standard signature: $sign_off\\n\" . $herecurr);\n\t\t\t\t} else {\n\t\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t\t \"Non-standard signature: '$sign_off' - perhaps '$suggested_signature'?\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/$sign_off/$suggested_signature/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (defined $space_before && $space_before ne \"\") {\n\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t \"Do not use whitespace before $ucfirst_sign_off\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =\n\t\t\t\t\t    \"$ucfirst_sign_off $email\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($sign_off =~ /-by:$/i && $sign_off ne $ucfirst_sign_off) {\n\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t \"'$ucfirst_sign_off' is the preferred signature form\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =\n\t\t\t\t\t    \"$ucfirst_sign_off $email\";\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (!defined $space_after || $space_after ne \" \") {\n\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t \"Use a single space after $ucfirst_sign_off\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =\n\t\t\t\t\t    \"$ucfirst_sign_off $email\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmy ($email_name, $name_comment, $email_address, $comment) = parse_email($email);\n\t\t\tmy $suggested_email = format_email(($email_name, $name_comment, $email_address, $comment));\n\t\t\tif ($suggested_email eq \"\") {\n\t\t\t\tERROR(\"BAD_SIGN_OFF\",\n\t\t\t\t      \"Unrecognized email address: '$email'\\n\" . $herecurr);\n\t\t\t} else {\n\t\t\t\tmy $dequoted = $suggested_email;\n\t\t\t\t$dequoted =~ s/^\"//;\n\t\t\t\t$dequoted =~ s/\" </ </;\n\t\t\t\t# Don't force email to have quotes\n\t\t\t\t# Allow just an angle bracketed address\n\t\t\t\tif (!same_email_addresses($email, $suggested_email)) {\n\t\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t\t \"email address '$email' might be better as '$suggested_email'\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$email\\E/$suggested_email/;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t# Address part shouldn't have comments\n\t\t\t\tmy $stripped_address = $email_address;\n\t\t\t\t$stripped_address =~ s/\\([^\\(\\)]*\\)//g;\n\t\t\t\tif ($email_address ne $stripped_address) {\n\t\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t\t \"address part of email should not have comments: '$email_address'\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$email_address\\E/$stripped_address/;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t# Only one name comment should be allowed\n\t\t\t\tmy $comment_count = () = $name_comment =~ /\\([^\\)]+\\)/g;\n\t\t\t\tif ($comment_count > 1) {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t     \"Use a single name comment in email: '$email'\\n\" . $herecurr);\n\t\t\t\t}\n\n\n\t\t\t\t# stable@vger.kernel.org or stable@kernel.org shouldn't\n\t\t\t\t# have an email name. In addition comments should strictly\n\t\t\t\t# begin with a #\n\t\t\t\tif ($email =~ /^.*stable\\@(?:vger\\.)?kernel\\.org/i) {\n\t\t\t\t\tif (($comment ne \"\" && $comment !~ /^#.+/) ||\n\t\t\t\t\t    ($email_name ne \"\")) {\n\t\t\t\t\t\tmy $cur_name = $email_name;\n\t\t\t\t\t\tmy $new_comment = $comment;\n\t\t\t\t\t\t$cur_name =~ s/[a-zA-Z\\s\\-\\\"]+//g;\n\n\t\t\t\t\t\t# Remove brackets enclosing comment text\n\t\t\t\t\t\t# and # from start of comments to get comment text\n\t\t\t\t\t\t$new_comment =~ s/^\\((.*)\\)$/$1/;\n\t\t\t\t\t\t$new_comment =~ s/^\\[(.*)\\]$/$1/;\n\t\t\t\t\t\t$new_comment =~ s/^[\\s\\#]+|\\s+$//g;\n\n\t\t\t\t\t\t$new_comment = trim(\"$new_comment $cur_name\") if ($cur_name ne $new_comment);\n\t\t\t\t\t\t$new_comment = \" # $new_comment\" if ($new_comment ne \"\");\n\t\t\t\t\t\tmy $new_email = \"$email_address$new_comment\";\n\n\t\t\t\t\t\tif (WARN(\"BAD_STABLE_ADDRESS_STYLE\",\n\t\t\t\t\t\t\t \"Invalid email format for stable: '$email', prefer '$new_email'\\n\" . $herecurr) &&\n\t\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$email\\E/$new_email/;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} elsif ($comment ne \"\" && $comment !~ /^(?:#.+|\\(.+\\))$/) {\n\t\t\t\t\tmy $new_comment = $comment;\n\n\t\t\t\t\t# Extract comment text from within brackets or\n\t\t\t\t\t# c89 style /*...*/ comments\n\t\t\t\t\t$new_comment =~ s/^\\[(.*)\\]$/$1/;\n\t\t\t\t\t$new_comment =~ s/^\\/\\*(.*)\\*\\/$/$1/;\n\n\t\t\t\t\t$new_comment = trim($new_comment);\n\t\t\t\t\t$new_comment =~ s/^[^\\w]$//; # Single lettered comment with non word character is usually a typo\n\t\t\t\t\t$new_comment = \"($new_comment)\" if ($new_comment ne \"\");\n\t\t\t\t\tmy $new_email = format_email($email_name, $name_comment, $email_address, $new_comment);\n\n\t\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t\t \"Unexpected content after email: '$email', should be: '$new_email'\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$email\\E/$new_email/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n# Check for duplicate signatures\n\t\t\tmy $sig_nospace = $line;\n\t\t\t$sig_nospace =~ s/\\s//g;\n\t\t\t$sig_nospace = lc($sig_nospace);\n\t\t\tif (defined $signatures{$sig_nospace}) {\n\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t     \"Duplicate signature\\n\" . $herecurr);\n\t\t\t} else {\n\t\t\t\t$signatures{$sig_nospace} = 1;\n\t\t\t}\n\n# Check Co-developed-by: immediately followed by Signed-off-by: with same name and email\n\t\t\tif ($sign_off =~ /^co-developed-by:$/i) {\n\t\t\t\tif ($email eq $author) {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t      \"Co-developed-by: should not be used to attribute nominal patch author '$author'\\n\" . $herecurr);\n\t\t\t\t}\n\t\t\t\tif (!defined $lines[$linenr]) {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t     \"Co-developed-by: must be immediately followed by Signed-off-by:\\n\" . $herecurr);\n\t\t\t\t} elsif ($rawlines[$linenr] !~ /^signed-off-by:\\s*(.*)/i) {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t     \"Co-developed-by: must be immediately followed by Signed-off-by:\\n\" . $herecurr . $rawlines[$linenr] . \"\\n\");\n\t\t\t\t} elsif ($1 ne $email) {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t     \"Co-developed-by and Signed-off-by: name/email do not match\\n\" . $herecurr . $rawlines[$linenr] . \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\n# check if Reported-by: is followed by a Closes: tag\n\t\t\tif ($sign_off =~ /^reported(?:|-and-tested)-by:$/i) {\n\t\t\t\tif (!defined $lines[$linenr]) {\n\t\t\t\t\tWARN(\"BAD_REPORTED_BY_LINK\",\n\t\t\t\t\t     \"Reported-by: should be immediately followed by Closes: with a URL to the report\\n\" . $herecurr . \"\\n\");\n\t\t\t\t} elsif ($rawlines[$linenr] !~ /^closes:\\s*/i) {\n\t\t\t\t\tWARN(\"BAD_REPORTED_BY_LINK\",\n\t\t\t\t\t     \"Reported-by: should be immediately followed by Closes: with a URL to the report\\n\" . $herecurr . $rawlines[$linenr] . \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n# Check Fixes: styles is correct\n\t\tif (!$in_header_lines &&\n\t\t    $line =~ /^\\s*fixes:?\\s*(?:commit\\s*)?[0-9a-f]{5,}\\b/i) {\n\t\t\tmy $orig_commit = \"\";\n\t\t\tmy $id = \"0123456789ab\";\n\t\t\tmy $title = \"commit title\";\n\t\t\tmy $tag_case = 1;\n\t\t\tmy $tag_space = 1;\n\t\t\tmy $id_length = 1;\n\t\t\tmy $id_case = 1;\n\t\t\tmy $title_has_quotes = 0;\n\n\t\t\tif ($line =~ /(\\s*fixes:?)\\s+([0-9a-f]{5,})\\s+($balanced_parens)/i) {\n\t\t\t\tmy $tag = $1;\n\t\t\t\t$orig_commit = $2;\n\t\t\t\t$title = $3;\n\n\t\t\t\t$tag_case = 0 if $tag eq \"Fixes:\";\n\t\t\t\t$tag_space = 0 if ($line =~ /^fixes:? [0-9a-f]{5,} ($balanced_parens)/i);\n\n\t\t\t\t$id_length = 0 if ($orig_commit =~ /^[0-9a-f]{12}$/i);\n\t\t\t\t$id_case = 0 if ($orig_commit !~ /[A-F]/);\n\n\t\t\t\t# Always strip leading/trailing parens then double quotes if existing\n\t\t\t\t$title = substr($title, 1, -1);\n\t\t\t\tif ($title =~ /^\".*\"$/) {\n\t\t\t\t\t$title = substr($title, 1, -1);\n\t\t\t\t\t$title_has_quotes = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmy ($cid, $ctitle) = git_commit_info($orig_commit, $id,\n\t\t\t\t\t\t\t     $title);\n\n\t\t\tif ($ctitle ne $title || $tag_case || $tag_space ||\n\t\t\t    $id_length || $id_case || !$title_has_quotes) {\n\t\t\t\tif (WARN(\"BAD_FIXES_TAG\",\n\t\t\t\t     \"Please use correct Fixes: style 'Fixes: <12 chars of sha1> (\\\"<title line>\\\")' - ie: 'Fixes: $cid (\\\"$ctitle\\\")'\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] = \"Fixes: $cid (\\\"$ctitle\\\")\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check email subject for common tools that don't need to be mentioned\n\t\tif ($in_header_lines &&\n\t\t    $line =~ /^Subject:.*\\b(?:checkpatch|sparse|smatch)\\b[^:]/i) {\n\t\t\tWARN(\"EMAIL_SUBJECT\",\n\t\t\t     \"A patch subject line should describe the change not the tool that found it\\n\" . $herecurr);\n\t\t}\n\n# Check for Gerrit Change-Ids not in any patch context\n\t\tif ($realfile eq '' && !$has_patch_separator && $line =~ /^\\s*change-id:/i) {\n\t\t\tif (ERROR(\"GERRIT_CHANGE_ID\",\n\t\t\t          \"Remove Gerrit Change-Id's before submitting upstream\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t}\n\t\t}\n\n# Check if the commit log is in a possible stack dump\n\t\tif ($in_commit_log && !$commit_log_possible_stack_dump &&\n\t\t    ($line =~ /^\\s*(?:WARNING:|BUG:)/ ||\n\t\t     $line =~ /^\\s*\\[\\s*\\d+\\.\\d{6,6}\\s*\\]/ ||\n\t\t\t\t\t# timestamp\n\t\t     $line =~ /^\\s*\\[\\<[0-9a-fA-F]{8,}\\>\\]/) ||\n\t\t     $line =~ /^(?:\\s+\\w+:\\s+[0-9a-fA-F]+){3,3}/ ||\n\t\t     $line =~ /^\\s*\\#\\d+\\s*\\[[0-9a-fA-F]+\\]\\s*\\w+ at [0-9a-fA-F]+/) {\n\t\t\t\t\t# stack dump address styles\n\t\t\t$commit_log_possible_stack_dump = 1;\n\t\t}\n\n# Check for line lengths > 75 in commit log, warn once\n\t\tif ($in_commit_log && !$commit_log_long_line &&\n\t\t    length($line) > 75 &&\n\t\t    !($line =~ /^\\s*[a-zA-Z0-9_\\/\\.]+\\s+\\|\\s+\\d+/ ||\n\t\t\t\t\t# file delta changes\n\t\t      $line =~ /^\\s*(?:[\\w\\.\\-\\+]*\\/)++[\\w\\.\\-\\+]+:/ ||\n\t\t\t\t\t# filename then :\n\t\t      $line =~ /^\\s*(?:Fixes:|$link_tags_search|$signature_tags)/i ||\n\t\t\t\t\t# A Fixes:, link or signature tag line\n\t\t      $commit_log_possible_stack_dump)) {\n\t\t\tWARN(\"COMMIT_LOG_LONG_LINE\",\n\t\t\t     \"Prefer a maximum 75 chars per line (possible unwrapped commit description?)\\n\" . $herecurr);\n\t\t\t$commit_log_long_line = 1;\n\t\t}\n\n# Reset possible stack dump if a blank line is found\n\t\tif ($in_commit_log && $commit_log_possible_stack_dump &&\n\t\t    $line =~ /^\\s*$/) {\n\t\t\t$commit_log_possible_stack_dump = 0;\n\t\t}\n\n# Check for odd tags before a URI/URL\n\t\tif ($in_commit_log &&\n\t\t    $line =~ /^\\s*(\\w+:)\\s*http/ && $1 !~ /^$link_tags_search$/) {\n\t\t\tif ($1 =~ /^v(?:ersion)?\\d+/i) {\n\t\t\t\tWARN(\"COMMIT_LOG_VERSIONING\",\n\t\t\t\t     \"Patch version information should be after the --- line\\n\" . $herecurr);\n\t\t\t} else {\n\t\t\t\tWARN(\"COMMIT_LOG_USE_LINK\",\n\t\t\t\t     \"Unknown link reference '$1', use $link_tags_print instead\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Check for misuse of the link tags\n\t\tif ($in_commit_log &&\n\t\t    $line =~ /^\\s*(\\w+:)\\s*(\\S+)/) {\n\t\t\tmy $tag = $1;\n\t\t\tmy $value = $2;\n\t\t\tif ($tag =~ /^$link_tags_search$/ && $value !~ m{^https?://}) {\n\t\t\t\tWARN(\"COMMIT_LOG_WRONG_LINK\",\n\t\t\t\t     \"'$tag' should be followed by a public http(s) link\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Check for lines starting with a #\n\t\tif ($in_commit_log && $line =~ /^#/) {\n\t\t\tif (WARN(\"COMMIT_COMMENT_SYMBOL\",\n\t\t\t\t \"Commit log lines starting with '#' are dropped by git as comments\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/^/ /;\n\t\t\t}\n\t\t}\n\n# Check for git id commit length and improperly formed commit descriptions\n# A correctly formed commit description is:\n#    commit <SHA-1 hash length 12+ chars> (\"Complete commit subject\")\n# with the commit subject '(\"' prefix and '\")' suffix\n# This is a fairly compilicated block as it tests for what appears to be\n# bare SHA-1 hash with  minimum length of 5.  It also avoids several types of\n# possible SHA-1 matches.\n# A commit match can span multiple lines so this block attempts to find a\n# complete typical commit on a maximum of 3 lines\n\t\tif ($perl_version_ok &&\n\t\t    $in_commit_log && !$commit_log_possible_stack_dump &&\n\t\t    $line !~ /^\\s*(?:Link|Patchwork|http|https|BugLink|base-commit):/i &&\n\t\t    $line !~ /^This reverts commit [0-9a-f]{7,40}/ &&\n\t\t    (($line =~ /\\bcommit\\s+[0-9a-f]{5,}\\b/i ||\n\t\t      ($line =~ /\\bcommit\\s*$/i && defined($rawlines[$linenr]) && $rawlines[$linenr] =~ /^\\s*[0-9a-f]{5,}\\b/i)) ||\n\t\t     ($line =~ /(?:\\s|^)[0-9a-f]{12,40}(?:[\\s\"'\\(\\[]|$)/i &&\n\t\t      $line !~ /[\\<\\[][0-9a-f]{12,40}[\\>\\]]/i &&\n\t\t      $line !~ /\\bfixes:\\s*[0-9a-f]{12,40}/i))) {\n\t\t\tmy $init_char = \"c\";\n\t\t\tmy $orig_commit = \"\";\n\t\t\tmy $short = 1;\n\t\t\tmy $long = 0;\n\t\t\tmy $case = 1;\n\t\t\tmy $space = 1;\n\t\t\tmy $id = '0123456789ab';\n\t\t\tmy $orig_desc = \"commit description\";\n\t\t\tmy $description = \"\";\n\t\t\tmy $herectx = $herecurr;\n\t\t\tmy $has_parens = 0;\n\t\t\tmy $has_quotes = 0;\n\n\t\t\tmy $input = $line;\n\t\t\tif ($line =~ /(?:\\bcommit\\s+[0-9a-f]{5,}|\\bcommit\\s*$)/i) {\n\t\t\t\tfor (my $n = 0; $n < 2; $n++) {\n\t\t\t\t\tif ($input =~ /\\bcommit\\s+[0-9a-f]{5,}\\s*($balanced_parens)/i) {\n\t\t\t\t\t\t$orig_desc = $1;\n\t\t\t\t\t\t$has_parens = 1;\n\t\t\t\t\t\t# Always strip leading/trailing parens then double quotes if existing\n\t\t\t\t\t\t$orig_desc = substr($orig_desc, 1, -1);\n\t\t\t\t\t\tif ($orig_desc =~ /^\".*\"$/) {\n\t\t\t\t\t\t\t$orig_desc = substr($orig_desc, 1, -1);\n\t\t\t\t\t\t\t$has_quotes = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t\tlast if ($#lines < $linenr + $n);\n\t\t\t\t\t$input .= \" \" . trim($rawlines[$linenr + $n]);\n\t\t\t\t\t$herectx .= \"$rawlines[$linenr + $n]\\n\";\n\t\t\t\t}\n\t\t\t\t$herectx = $herecurr if (!$has_parens);\n\t\t\t}\n\n\t\t\tif ($input =~ /\\b(c)ommit\\s+([0-9a-f]{5,})\\b/i) {\n\t\t\t\t$init_char = $1;\n\t\t\t\t$orig_commit = lc($2);\n\t\t\t\t$short = 0 if ($input =~ /\\bcommit\\s+[0-9a-f]{12,40}/i);\n\t\t\t\t$long = 1 if ($input =~ /\\bcommit\\s+[0-9a-f]{41,}/i);\n\t\t\t\t$space = 0 if ($input =~ /\\bcommit [0-9a-f]/i);\n\t\t\t\t$case = 0 if ($input =~ /\\b[Cc]ommit\\s+[0-9a-f]{5,40}[^A-F]/);\n\t\t\t} elsif ($input =~ /\\b([0-9a-f]{12,40})\\b/i) {\n\t\t\t\t$orig_commit = lc($1);\n\t\t\t}\n\n\t\t\t($id, $description) = git_commit_info($orig_commit,\n\t\t\t\t\t\t\t      $id, $orig_desc);\n\n\t\t\tif (defined($id) &&\n\t\t\t    ($short || $long || $space || $case || ($orig_desc ne $description) || !$has_quotes) &&\n\t\t\t    $last_git_commit_id_linenr != $linenr - 1) {\n\t\t\t\tERROR(\"GIT_COMMIT_ID\",\n\t\t\t\t      \"Please use git commit description style 'commit <12+ chars of sha1> (\\\"<title line>\\\")' - ie: '${init_char}ommit $id (\\\"$description\\\")'\\n\" . $herectx);\n\t\t\t}\n\t\t\t#don't report the next line if this line ends in commit and the sha1 hash is the next line\n\t\t\t$last_git_commit_id_linenr = $linenr if ($line =~ /\\bcommit\\s*$/i);\n\t\t}\n\n# Check for mailing list archives other than lore.kernel.org\n\t\tif ($rawline =~ m{http.*\\b$obsolete_archives}) {\n\t\t\tWARN(\"PREFER_LORE_ARCHIVE\",\n\t\t\t     \"Use lore.kernel.org archive links when possible - see https://lore.kernel.org/lists.html\\n\" . $herecurr);\n\t\t}\n\n# Check for added, moved or deleted files\n\t\tif (!$reported_maintainer_file && !$in_commit_log &&\n\t\t    ($line =~ /^(?:new|deleted) file mode\\s*\\d+\\s*$/ ||\n\t\t     $line =~ /^rename (?:from|to) [\\w\\/\\.\\-]+\\s*$/ ||\n\t\t     ($line =~ /\\{\\s*([\\w\\/\\.\\-]*)\\s*\\=\\>\\s*([\\w\\/\\.\\-]*)\\s*\\}/ &&\n\t\t      (defined($1) || defined($2))))) {\n\t\t\t$is_patch = 1;\n\t\t\t$reported_maintainer_file = 1;\n\t\t\tWARN(\"FILE_PATH_CHANGES\",\n\t\t\t     \"added, moved or deleted file(s), does MAINTAINERS need updating?\\n\" . $herecurr);\n\t\t}\n\n# Check for adding new DT bindings not in schema format\n\t\tif (!$in_commit_log &&\n\t\t    ($line =~ /^new file mode\\s*\\d+\\s*$/) &&\n\t\t    ($realfile =~ m@^Documentation/devicetree/bindings/.*\\.txt$@)) {\n\t\t\tWARN(\"DT_SCHEMA_BINDING_PATCH\",\n\t\t\t     \"DT bindings should be in DT schema format. See: Documentation/devicetree/bindings/writing-schema.rst\\n\");\n\t\t}\n\n# Check for wrappage within a valid hunk of the file\n\t\tif ($realcnt != 0 && $line !~ m{^(?:\\+|-| |\\\\ No newline|$)}) {\n\t\t\tERROR(\"CORRUPTED_PATCH\",\n\t\t\t      \"patch seems to be corrupt (line wrapped?)\\n\" .\n\t\t\t\t$herecurr) if (!$emitted_corrupt++);\n\t\t}\n\n# UTF-8 regex found at http://www.w3.org/International/questions/qa-forms-utf-8.en.php\n\t\tif (($realfile =~ /^$/ || $line =~ /^\\+/) &&\n\t\t    $rawline !~ m/^$UTF8*$/) {\n\t\t\tmy ($utf8_prefix) = ($rawline =~ /^($UTF8*)/);\n\n\t\t\tmy $blank = copy_spacing($rawline);\n\t\t\tmy $ptr = substr($blank, 0, length($utf8_prefix)) . \"^\";\n\t\t\tmy $hereptr = \"$hereline$ptr\\n\";\n\n\t\t\tCHK(\"INVALID_UTF8\",\n\t\t\t    \"Invalid UTF-8, patch and commit message should be encoded in UTF-8\\n\" . $hereptr);\n\t\t}\n\n# Check if it's the start of a commit log\n# (not a header line and we haven't seen the patch filename)\n\t\tif ($in_header_lines && $realfile =~ /^$/ &&\n\t\t    !($rawline =~ /^\\s+(?:\\S|$)/ ||\n\t\t      $rawline =~ /^(?:commit\\b|from\\b|[\\w-]+:)/i)) {\n\t\t\t$in_header_lines = 0;\n\t\t\t$in_commit_log = 1;\n\t\t\t$has_commit_log = 1;\n\t\t}\n\n# Check if there is UTF-8 in a commit log when a mail header has explicitly\n# declined it, i.e defined some charset where it is missing.\n\t\tif ($in_header_lines &&\n\t\t    $rawline =~ /^Content-Type:.+charset=\"(.+)\".*$/ &&\n\t\t    $1 !~ /utf-8/i) {\n\t\t\t$non_utf8_charset = 1;\n\t\t}\n\n\t\tif ($in_commit_log && $non_utf8_charset && $realfile =~ /^$/ &&\n\t\t    $rawline =~ /$NON_ASCII_UTF8/) {\n\t\t\tWARN(\"UTF8_BEFORE_PATCH\",\n\t\t\t    \"8-bit UTF-8 used in possible commit log\\n\" . $herecurr);\n\t\t}\n\n# Check for absolute kernel paths in commit message\n\t\tif ($tree && $in_commit_log) {\n\t\t\twhile ($line =~ m{(?:^|\\s)(/\\S*)}g) {\n\t\t\t\tmy $file = $1;\n\n\t\t\t\tif ($file =~ m{^(.*?)(?::\\d+)+:?$} &&\n\t\t\t\t    check_absolute_file($1, $herecurr)) {\n\t\t\t\t\t#\n\t\t\t\t} else {\n\t\t\t\t\tcheck_absolute_file($file, $herecurr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check for various typo / spelling mistakes\n\t\tif (defined($misspellings) &&\n\t\t    ($in_commit_log || $line =~ /^(?:\\+|Subject:)/i)) {\n\t\t\twhile ($rawline =~ /(?:^|[^\\w\\-'`])($misspellings)(?:[^\\w\\-'`]|$)/gi) {\n\t\t\t\tmy $typo = $1;\n\t\t\t\tmy $blank = copy_spacing($rawline);\n\t\t\t\tmy $ptr = substr($blank, 0, $-[1]) . \"^\" x length($typo);\n\t\t\t\tmy $hereptr = \"$hereline$ptr\\n\";\n\t\t\t\tmy $typo_fix = $spelling_fix{lc($typo)};\n\t\t\t\t$typo_fix = ucfirst($typo_fix) if ($typo =~ /^[A-Z]/);\n\t\t\t\t$typo_fix = uc($typo_fix) if ($typo =~ /^[A-Z]+$/);\n\t\t\t\tmy $msg_level = \\&WARN;\n\t\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t\tif (&{$msg_level}(\"TYPO_SPELLING\",\n\t\t\t\t\t\t  \"'$typo' may be misspelled - perhaps '$typo_fix'?\\n\" . $hereptr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/(^|[^A-Za-z@])($typo)($|[^A-Za-z@])/$1$typo_fix$3/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for invalid commit id\n\t\tif ($in_commit_log && $line =~ /(^fixes:|\\bcommit)\\s+([0-9a-f]{6,40})\\b/i) {\n\t\t\tmy $id;\n\t\t\tmy $description;\n\t\t\t($id, $description) = git_commit_info($2, undef, undef);\n\t\t\tif (!defined($id)) {\n\t\t\t\tWARN(\"UNKNOWN_COMMIT_ID\",\n\t\t\t\t     \"Unknown commit id '$2', maybe rebased or not pulled?\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for repeated words separated by a single space\n# avoid false positive from list command eg, '-rw-r--r-- 1 root root'\n\t\tif (($rawline =~ /^\\+/ || $in_commit_log) &&\n\t\t    $rawline !~ /[bcCdDlMnpPs\\?-][rwxsStT-]{9}/) {\n\t\t\tpos($rawline) = 1 if (!$in_commit_log);\n\t\t\twhile ($rawline =~ /\\b($word_pattern) (?=($word_pattern))/g) {\n\n\t\t\t\tmy $first = $1;\n\t\t\t\tmy $second = $2;\n\t\t\t\tmy $start_pos = $-[1];\n\t\t\t\tmy $end_pos = $+[2];\n\t\t\t\tif ($first =~ /(?:struct|union|enum)/) {\n\t\t\t\t\tpos($rawline) += length($first) + length($second) + 1;\n\t\t\t\t\tnext;\n\t\t\t\t}\n\n\t\t\t\tnext if (lc($first) ne lc($second));\n\t\t\t\tnext if ($first eq 'long');\n\n\t\t\t\t# check for character before and after the word matches\n\t\t\t\tmy $start_char = '';\n\t\t\t\tmy $end_char = '';\n\t\t\t\t$start_char = substr($rawline, $start_pos - 1, 1) if ($start_pos > ($in_commit_log ? 0 : 1));\n\t\t\t\t$end_char = substr($rawline, $end_pos, 1) if ($end_pos < length($rawline));\n\n\t\t\t\tnext if ($start_char =~ /^\\S$/);\n\t\t\t\tnext if (index(\" \\t.,;?!\", $end_char) == -1);\n\n\t\t\t\t# avoid repeating hex occurrences like 'ff ff fe 09 ...'\n\t\t\t\tif ($first =~ /\\b[0-9a-f]{2,}\\b/i) {\n\t\t\t\t\tnext if (!exists($allow_repeated_words{lc($first)}));\n\t\t\t\t}\n\n\t\t\t\tif (WARN(\"REPEATED_WORD\",\n\t\t\t\t\t \"Possible repeated word: '$first'\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\b$first $second\\b/$first/;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# if it's a repeated word on consecutive lines in a comment block\n\t\t\tif ($prevline =~ /$;+\\s*$/ &&\n\t\t\t    $prevrawline =~ /($word_pattern)\\s*$/) {\n\t\t\t\tmy $last_word = $1;\n\t\t\t\tif ($rawline =~ /^\\+\\s*\\*\\s*$last_word /) {\n\t\t\t\t\tif (WARN(\"REPEATED_WORD\",\n\t\t\t\t\t\t \"Possible repeated word: '$last_word'\\n\" . $hereprev) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/(\\+\\s*\\*\\s*)$last_word /$1/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# ignore non-hunk lines and lines being removed\n\t\tnext if (!$hunk_line || $line =~ /^-/);\n\n#trailing whitespace\n\t\tif ($line =~ /^\\+.*\\015/) {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\tif (ERROR(\"DOS_LINE_ENDINGS\",\n\t\t\t\t  \"DOS line endings\\n\" . $herevet) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/[\\s\\015]+$//;\n\t\t\t}\n\t\t} elsif ($rawline =~ /^\\+.*\\S\\s+$/ || $rawline =~ /^\\+\\s+$/) {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\tif (ERROR(\"TRAILING_WHITESPACE\",\n\t\t\t\t  \"trailing whitespace\\n\" . $herevet) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\s+$//;\n\t\t\t}\n\n\t\t\t$rpt_cleaners = 1;\n\t\t}\n\n# Check for FSF mailing addresses.\n\t\tif ($rawline =~ /\\bwrite to the Free/i ||\n\t\t    $rawline =~ /\\b675\\s+Mass\\s+Ave/i ||\n\t\t    $rawline =~ /\\b59\\s+Temple\\s+Pl/i ||\n\t\t    $rawline =~ /\\b51\\s+Franklin\\s+St/i) {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\tmy $msg_level = \\&ERROR;\n\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t&{$msg_level}(\"FSF_MAILING_ADDRESS\",\n\t\t\t\t      \"Do not include the paragraph about writing to the Free Software Foundation's mailing address from the sample GPL notice. The FSF has changed addresses in the past, and may do so again. Linux already includes a copy of the GPL.\\n\" . $herevet)\n\t\t}\n\n# check for Kconfig help text having a real description\n# Only applies when adding the entry originally, after that we do not have\n# sufficient context to determine whether it is indeed long enough.\n\t\tif ($realfile =~ /Kconfig/ &&\n\t\t    # 'choice' is usually the last thing on the line (though\n\t\t    # Kconfig supports named choices), so use a word boundary\n\t\t    # (\\b) rather than a whitespace character (\\s)\n\t\t    $line =~ /^\\+\\s*(?:config|menuconfig|choice)\\b/) {\n\t\t\tmy $ln = $linenr;\n\t\t\tmy $needs_help = 0;\n\t\t\tmy $has_help = 0;\n\t\t\tmy $help_length = 0;\n\t\t\twhile (defined $lines[$ln]) {\n\t\t\t\tmy $f = $lines[$ln++];\n\n\t\t\t\tnext if ($f =~ /^-/);\n\t\t\t\tlast if ($f !~ /^[\\+ ]/);\t# !patch context\n\n\t\t\t\tif ($f =~ /^\\+\\s*(?:bool|tristate|prompt)\\s*[\"']/) {\n\t\t\t\t\t$needs_help = 1;\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tif ($f =~ /^\\+\\s*help\\s*$/) {\n\t\t\t\t\t$has_help = 1;\n\t\t\t\t\tnext;\n\t\t\t\t}\n\n\t\t\t\t$f =~ s/^.//;\t# strip patch context [+ ]\n\t\t\t\t$f =~ s/#.*//;\t# strip # directives\n\t\t\t\t$f =~ s/^\\s+//;\t# strip leading blanks\n\t\t\t\tnext if ($f =~ /^$/);\t# skip blank lines\n\n\t\t\t\t# At the end of this Kconfig block:\n\t\t\t\t# This only checks context lines in the patch\n\t\t\t\t# and so hopefully shouldn't trigger false\n\t\t\t\t# positives, even though some of these are\n\t\t\t\t# common words in help texts\n\t\t\t\tif ($f =~ /^(?:config|menuconfig|choice|endchoice|\n\t\t\t\t\t       if|endif|menu|endmenu|source)\\b/x) {\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t\t$help_length++ if ($has_help);\n\t\t\t}\n\t\t\tif ($needs_help &&\n\t\t\t    $help_length < $min_conf_desc_length) {\n\t\t\t\tmy $stat_real = get_stat_real($linenr, $ln - 1);\n\t\t\t\tWARN(\"CONFIG_DESCRIPTION\",\n\t\t\t\t     \"please write a help paragraph that fully describes the config symbol\\n\" . \"$here\\n$stat_real\\n\");\n\t\t\t}\n\t\t}\n\n# check MAINTAINERS entries\n\t\tif ($realfile =~ /^MAINTAINERS$/) {\n# check MAINTAINERS entries for the right form\n\t\t\tif ($rawline =~ /^\\+[A-Z]:/ &&\n\t\t\t    $rawline !~ /^\\+[A-Z]:\\t\\S/) {\n\t\t\t\tif (WARN(\"MAINTAINERS_STYLE\",\n\t\t\t\t\t \"MAINTAINERS entries use one tab after TYPE:\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/^(\\+[A-Z]):\\s*/$1:\\t/;\n\t\t\t\t}\n\t\t\t}\n# check MAINTAINERS entries for the right ordering too\n\t\t\tmy $preferred_order = 'MRLSWQBCPTFXNK';\n\t\t\tif ($rawline =~ /^\\+[A-Z]:/ &&\n\t\t\t    $prevrawline =~ /^[\\+ ][A-Z]:/) {\n\t\t\t\t$rawline =~ /^\\+([A-Z]):\\s*(.*)/;\n\t\t\t\tmy $cur = $1;\n\t\t\t\tmy $curval = $2;\n\t\t\t\t$prevrawline =~ /^[\\+ ]([A-Z]):\\s*(.*)/;\n\t\t\t\tmy $prev = $1;\n\t\t\t\tmy $prevval = $2;\n\t\t\t\tmy $curindex = index($preferred_order, $cur);\n\t\t\t\tmy $previndex = index($preferred_order, $prev);\n\t\t\t\tif ($curindex < 0) {\n\t\t\t\t\tWARN(\"MAINTAINERS_STYLE\",\n\t\t\t\t\t     \"Unknown MAINTAINERS entry type: '$cur'\\n\" . $herecurr);\n\t\t\t\t} else {\n\t\t\t\t\tif ($previndex >= 0 && $curindex < $previndex) {\n\t\t\t\t\t\tWARN(\"MAINTAINERS_STYLE\",\n\t\t\t\t\t\t     \"Misordered MAINTAINERS entry - list '$cur:' before '$prev:'\\n\" . $hereprev);\n\t\t\t\t\t} elsif ((($prev eq 'F' && $cur eq 'F') ||\n\t\t\t\t\t\t  ($prev eq 'X' && $cur eq 'X')) &&\n\t\t\t\t\t\t ($prevval cmp $curval) > 0) {\n\t\t\t\t\t\tWARN(\"MAINTAINERS_STYLE\",\n\t\t\t\t\t\t     \"Misordered MAINTAINERS entry - list file patterns in alphabetic order\\n\" . $hereprev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (($realfile =~ /Makefile.*/ || $realfile =~ /Kbuild.*/) &&\n\t\t    ($line =~ /\\+(EXTRA_[A-Z]+FLAGS).*/)) {\n\t\t\tmy $flag = $1;\n\t\t\tmy $replacement = {\n\t\t\t\t'EXTRA_AFLAGS' =>   'asflags-y',\n\t\t\t\t'EXTRA_CFLAGS' =>   'ccflags-y',\n\t\t\t\t'EXTRA_CPPFLAGS' => 'cppflags-y',\n\t\t\t\t'EXTRA_LDFLAGS' =>  'ldflags-y',\n\t\t\t};\n\n\t\t\tWARN(\"DEPRECATED_VARIABLE\",\n\t\t\t     \"Use of $flag is deprecated, please use \\`$replacement->{$flag} instead.\\n\" . $herecurr) if ($replacement->{$flag});\n\t\t}\n\n# check for DT compatible documentation\n\t\tif (defined $root &&\n\t\t\t(($realfile =~ /\\.dtsi?$/ && $line =~ /^\\+\\s*compatible\\s*=\\s*\\\"/) ||\n\t\t\t ($realfile =~ /\\.[ch]$/ && $line =~ /^\\+.*\\.compatible\\s*=\\s*\\\"/))) {\n\n\t\t\tmy @compats = $rawline =~ /\\\"([a-zA-Z0-9\\-\\,\\.\\+_]+)\\\"/g;\n\n\t\t\tmy $dt_path = $root . \"/Documentation/devicetree/bindings/\";\n\t\t\tmy $vp_file = $dt_path . \"vendor-prefixes.yaml\";\n\n\t\t\tforeach my $compat (@compats) {\n\t\t\t\tmy $compat2 = $compat;\n\t\t\t\t$compat2 =~ s/\\,[a-zA-Z0-9]*\\-/\\,<\\.\\*>\\-/;\n\t\t\t\tmy $compat3 = $compat;\n\t\t\t\t$compat3 =~ s/\\,([a-z]*)[0-9]*\\-/\\,$1<\\.\\*>\\-/;\n\t\t\t\t`grep -Erq \"$compat|$compat2|$compat3\" $dt_path`;\n\t\t\t\tif ( $? >> 8 ) {\n\t\t\t\t\tWARN(\"UNDOCUMENTED_DT_STRING\",\n\t\t\t\t\t     \"DT compatible string \\\"$compat\\\" appears un-documented -- check $dt_path\\n\" . $herecurr);\n\t\t\t\t}\n\n\t\t\t\tnext if $compat !~ /^([a-zA-Z0-9\\-]+)\\,/;\n\t\t\t\tmy $vendor = $1;\n\t\t\t\t`grep -Eq \"\\\\\"\\\\^\\Q$vendor\\E,\\\\.\\\\*\\\\\":\" $vp_file`;\n\t\t\t\tif ( $? >> 8 ) {\n\t\t\t\t\tWARN(\"UNDOCUMENTED_DT_STRING\",\n\t\t\t\t\t     \"DT compatible string vendor \\\"$vendor\\\" appears un-documented -- check $vp_file\\n\" . $herecurr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for using SPDX license tag at beginning of files\n\t\tif ($realline == $checklicenseline) {\n\t\t\tif ($rawline =~ /^[ \\+]\\s*\\#\\!\\s*\\//) {\n\t\t\t\t$checklicenseline = 2;\n\t\t\t} elsif ($rawline =~ /^\\+/) {\n\t\t\t\tmy $comment = \"\";\n\t\t\t\tif ($realfile =~ /\\.(h|s|S)$/) {\n\t\t\t\t\t$comment = '/*';\n\t\t\t\t} elsif ($realfile =~ /\\.(c|rs|dts|dtsi)$/) {\n\t\t\t\t\t$comment = '//';\n\t\t\t\t} elsif (($checklicenseline == 2) || $realfile =~ /\\.(sh|pl|py|awk|tc|yaml)$/) {\n\t\t\t\t\t$comment = '#';\n\t\t\t\t} elsif ($realfile =~ /\\.rst$/) {\n\t\t\t\t\t$comment = '..';\n\t\t\t\t}\n\n# check SPDX comment style for .[chsS] files\n\t\t\t\tif ($realfile =~ /\\.[chsS]$/ &&\n\t\t\t\t    $rawline =~ /SPDX-License-Identifier:/ &&\n\t\t\t\t    $rawline !~ m@^\\+\\s*\\Q$comment\\E\\s*@) {\n\t\t\t\t\tWARN(\"SPDX_LICENSE_TAG\",\n\t\t\t\t\t     \"Improper SPDX comment style for '$realfile', please use '$comment' instead\\n\" . $herecurr);\n\t\t\t\t}\n\n\t\t\t\tif ($comment !~ /^$/ &&\n\t\t\t\t    $rawline !~ m@^\\+\\Q$comment\\E SPDX-License-Identifier: @) {\n\t\t\t\t\tWARN(\"SPDX_LICENSE_TAG\",\n\t\t\t\t\t     \"Missing or malformed SPDX-License-Identifier tag in line $checklicenseline\\n\" . $herecurr);\n\t\t\t\t} elsif ($rawline =~ /(SPDX-License-Identifier: .*)/) {\n\t\t\t\t\tmy $spdx_license = $1;\n\t\t\t\t\tif (!is_SPDX_License_valid($spdx_license)) {\n\t\t\t\t\t\tWARN(\"SPDX_LICENSE_TAG\",\n\t\t\t\t\t\t     \"'$spdx_license' is not supported in LICENSES/...\\n\" . $herecurr);\n\t\t\t\t\t}\n\t\t\t\t\tif ($realfile =~ m@^Documentation/devicetree/bindings/@ &&\n\t\t\t\t\t    $spdx_license !~ /GPL-2\\.0(?:-only)? OR BSD-2-Clause/) {\n\t\t\t\t\t\tmy $msg_level = \\&WARN;\n\t\t\t\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t\t\t\tif (&{$msg_level}(\"SPDX_LICENSE_TAG\",\n\n\t\t\t\t\t\t\t\t  \"DT binding documents should be licensed (GPL-2.0-only OR BSD-2-Clause)\\n\" . $herecurr) &&\n\t\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/SPDX-License-Identifier: .*/SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)/;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($realfile =~ m@^include/dt-bindings/@ &&\n\t\t\t\t\t    $spdx_license !~ /GPL-2\\.0(?:-only)? OR \\S+/) {\n\t\t\t\t\t\tWARN(\"SPDX_LICENSE_TAG\",\n\t\t\t\t\t\t     \"DT binding headers should be licensed (GPL-2.0-only OR .*)\\n\" . $herecurr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for embedded filenames\n\t\tif ($rawline =~ /^\\+.*\\b\\Q$realfile\\E\\b/) {\n\t\t\tWARN(\"EMBEDDED_FILENAME\",\n\t\t\t     \"It's generally not useful to have the filename in the file\\n\" . $herecurr);\n\t\t}\n\n# check we are in a valid source file if not then ignore this hunk\n\t\tnext if ($realfile !~ /\\.(h|c|rs|s|S|sh|dtsi|dts)$/);\n\n# check for using SPDX-License-Identifier on the wrong line number\n\t\tif ($realline != $checklicenseline &&\n\t\t    $rawline =~ /\\bSPDX-License-Identifier:/ &&\n\t\t    substr($line, @-, @+ - @-) eq \"$;\" x (@+ - @-)) {\n\t\t\tWARN(\"SPDX_LICENSE_TAG\",\n\t\t\t     \"Misplaced SPDX-License-Identifier tag - use line $checklicenseline instead\\n\" . $herecurr);\n\t\t}\n\n# line length limit (with some exclusions)\n#\n# There are a few types of lines that may extend beyond $max_line_length:\n#\tlogging functions like pr_info that end in a string\n#\tlines with a single string\n#\t#defines that are a single string\n#\tlines with an RFC3986 like URL\n#\n# There are 3 different line length message types:\n# LONG_LINE_COMMENT\ta comment starts before but extends beyond $max_line_length\n# LONG_LINE_STRING\ta string starts before but extends beyond $max_line_length\n# LONG_LINE\t\tall other lines longer than $max_line_length\n#\n# if LONG_LINE is ignored, the other 2 types are also ignored\n#\n\n\t\tif ($line =~ /^\\+/ && $length > $max_line_length) {\n\t\t\tmy $msg_type = \"LONG_LINE\";\n\n\t\t\t# Check the allowed long line types first\n\n\t\t\t# logging functions that end in a string that starts\n\t\t\t# before $max_line_length\n\t\t\tif ($line =~ /^\\+\\s*$logFunctions\\s*\\(\\s*(?:(?:KERN_\\S+\\s*|[^\"]*))?($String\\s*(?:|,|\\)\\s*;)\\s*)$/ &&\n\t\t\t    length(expand_tabs(substr($line, 1, length($line) - length($1) - 1))) <= $max_line_length) {\n\t\t\t\t$msg_type = \"\";\n\n\t\t\t# lines with only strings (w/ possible termination)\n\t\t\t# #defines with only strings\n\t\t\t} elsif ($line =~ /^\\+\\s*$String\\s*(?:\\s*|,|\\)\\s*;)\\s*$/ ||\n\t\t\t\t $line =~ /^\\+\\s*#\\s*define\\s+\\w+\\s+$String$/) {\n\t\t\t\t$msg_type = \"\";\n\n\t\t\t# More special cases\n\t\t\t} elsif ($line =~ /^\\+.*\\bEFI_GUID\\s*\\(/ ||\n\t\t\t\t $line =~ /^\\+\\s*(?:\\w+)?\\s*DEFINE_PER_CPU/) {\n\t\t\t\t$msg_type = \"\";\n\n\t\t\t# URL ($rawline is used in case the URL is in a comment)\n\t\t\t} elsif ($rawline =~ /^\\+.*\\b[a-z][\\w\\.\\+\\-]*:\\/\\/\\S+/i) {\n\t\t\t\t$msg_type = \"\";\n\n\t\t\t# Otherwise set the alternate message types\n\n\t\t\t# a comment starts before $max_line_length\n\t\t\t} elsif ($line =~ /($;[\\s$;]*)$/ &&\n\t\t\t\t length(expand_tabs(substr($line, 1, length($line) - length($1) - 1))) <= $max_line_length) {\n\t\t\t\t$msg_type = \"LONG_LINE_COMMENT\"\n\n\t\t\t# a quoted string starts before $max_line_length\n\t\t\t} elsif ($sline =~ /\\s*($String(?:\\s*(?:\\\\|,\\s*|\\)\\s*;\\s*))?)$/ &&\n\t\t\t\t length(expand_tabs(substr($line, 1, length($line) - length($1) - 1))) <= $max_line_length) {\n\t\t\t\t$msg_type = \"LONG_LINE_STRING\"\n\t\t\t}\n\n\t\t\tif ($msg_type ne \"\" &&\n\t\t\t    (show_type(\"LONG_LINE\") || show_type($msg_type))) {\n\t\t\t\tmy $msg_level = \\&WARN;\n\t\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t\t&{$msg_level}($msg_type,\n\t\t\t\t\t      \"line length of $length exceeds $max_line_length columns\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for adding lines without a newline.\n\t\tif ($line =~ /^\\+/ && defined $lines[$linenr] && $lines[$linenr] =~ /^\\\\ No newline at end of file/) {\n\t\t\tif (WARN(\"MISSING_EOF_NEWLINE\",\n\t\t\t         \"adding a line without newline at end of file\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_delete_line($fixlinenr+1, \"No newline at end of file\");\n\t\t\t}\n\t\t}\n\n# check for .L prefix local symbols in .S files\n\t\tif ($realfile =~ /\\.S$/ &&\n\t\t    $line =~ /^\\+\\s*(?:[A-Z]+_)?SYM_[A-Z]+_(?:START|END)(?:_[A-Z_]+)?\\s*\\(\\s*\\.L/) {\n\t\t\tWARN(\"AVOID_L_PREFIX\",\n\t\t\t     \"Avoid using '.L' prefixed local symbol names for denoting a range of code via 'SYM_*_START/END' annotations; see Documentation/core-api/asm-annotations.rst\\n\" . $herecurr);\n\t\t}\n\n# check we are in a valid source file C or perl if not then ignore this hunk\n\t\tnext if ($realfile !~ /\\.(h|c|pl|dtsi|dts)$/);\n\n# at the beginning of a line any tabs must come first and anything\n# more than $tabsize must use tabs.\n\t\tif ($rawline =~ /^\\+\\s* \\t\\s*\\S/ ||\n\t\t    $rawline =~ /^\\+\\s*        \\s*/) {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\t$rpt_cleaners = 1;\n\t\t\tif (ERROR(\"CODE_INDENT\",\n\t\t\t\t  \"code indent should use tabs where possible\\n\" . $herevet) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/^\\+([ \\t]+)/\"\\+\" . tabify($1)/e;\n\t\t\t}\n\t\t}\n\n# check for space before tabs.\n\t\tif ($rawline =~ /^\\+/ && $rawline =~ / \\t/) {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\tif (WARN(\"SPACE_BEFORE_TAB\",\n\t\t\t\t\"please, no space before tabs\\n\" . $herevet) &&\n\t\t\t    $fix) {\n\t\t\t\twhile ($fixed[$fixlinenr] =~\n\t\t\t\t\t   s/(^\\+.*) {$tabsize,$tabsize}\\t/$1\\t\\t/) {}\n\t\t\t\twhile ($fixed[$fixlinenr] =~\n\t\t\t\t\t   s/(^\\+.*) +\\t/$1\\t/) {}\n\t\t\t}\n\t\t}\n\n# check for assignments on the start of a line\n\t\tif ($sline =~ /^\\+\\s+($Assignment)[^=]/) {\n\t\t\tmy $operator = $1;\n\t\t\tif (CHK(\"ASSIGNMENT_CONTINUATIONS\",\n\t\t\t\t\"Assignment operator '$1' should be on the previous line\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevrawline =~ /^\\+/) {\n\t\t\t\t# add assignment operator to the previous line, remove from current line\n\t\t\t\t$fixed[$fixlinenr - 1] .= \" $operator\";\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$operator\\E\\s*//;\n\t\t\t}\n\t\t}\n\n# check for && or || at the start of a line\n\t\tif ($rawline =~ /^\\+\\s*(&&|\\|\\|)/) {\n\t\t\tmy $operator = $1;\n\t\t\tif (CHK(\"LOGICAL_CONTINUATIONS\",\n\t\t\t\t\"Logical continuations should be on the previous line\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevrawline =~ /^\\+/) {\n\t\t\t\t# insert logical operator at last non-comment, non-whitepsace char on previous line\n\t\t\t\t$prevline =~ /[\\s$;]*$/;\n\t\t\t\tmy $line_end = substr($prevrawline, $-[0]);\n\t\t\t\t$fixed[$fixlinenr - 1] =~ s/\\Q$line_end\\E$/ $operator$line_end/;\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$operator\\E\\s*//;\n\t\t\t}\n\t\t}\n\n# check indentation starts on a tab stop\n\t\tif ($perl_version_ok &&\n\t\t    $sline =~ /^\\+\\t+( +)(?:$c90_Keywords\\b|\\{\\s*$|\\}\\s*(?:else\\b|while\\b|\\s*$)|$Declare\\s*$Ident\\s*[;=])/) {\n\t\t\tmy $indent = length($1);\n\t\t\tif ($indent % $tabsize) {\n\t\t\t\tif (WARN(\"TABSTOP\",\n\t\t\t\t\t \"Statements should start on a tabstop\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s@(^\\+\\t+) +@$1 . \"\\t\" x ($indent/$tabsize)@e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check multi-line statement indentation matches previous line\n\t\tif ($perl_version_ok &&\n\t\t    $prevline =~ /^\\+([ \\t]*)((?:$c90_Keywords(?:\\s+if)\\s*)|(?:$Declare\\s*)?(?:$Ident|\\(\\s*\\*\\s*$Ident\\s*\\))\\s*|(?:\\*\\s*)*$Lval\\s*=\\s*$Ident\\s*)\\(.*(\\&\\&|\\|\\||,)\\s*$/) {\n\t\t\t$prevline =~ /^\\+(\\t*)(.*)$/;\n\t\t\tmy $oldindent = $1;\n\t\t\tmy $rest = $2;\n\n\t\t\tmy $pos = pos_last_openparen($rest);\n\t\t\tif ($pos >= 0) {\n\t\t\t\t$line =~ /^(\\+| )([ \\t]*)/;\n\t\t\t\tmy $newindent = $2;\n\n\t\t\t\tmy $goodtabindent = $oldindent .\n\t\t\t\t\t\"\\t\" x ($pos / $tabsize) .\n\t\t\t\t\t\" \"  x ($pos % $tabsize);\n\t\t\t\tmy $goodspaceindent = $oldindent . \" \"  x $pos;\n\n\t\t\t\tif ($newindent ne $goodtabindent &&\n\t\t\t\t    $newindent ne $goodspaceindent) {\n\n\t\t\t\t\tif (CHK(\"PARENTHESIS_ALIGNMENT\",\n\t\t\t\t\t\t\"Alignment should match open parenthesis\\n\" . $hereprev) &&\n\t\t\t\t\t    $fix && $line =~ /^\\+/) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t\t\t    s/^\\+[ \\t]*/\\+$goodtabindent/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for space after cast like \"(int) foo\" or \"(struct foo) bar\"\n# avoid checking a few false positives:\n#   \"sizeof(<type>)\" or \"__alignof__(<type>)\"\n#   function pointer declarations like \"(*foo)(int) = bar;\"\n#   structure definitions like \"(struct foo) { 0 };\"\n#   multiline macros that define functions\n#   known attributes or the __attribute__ keyword\n\t\tif ($line =~ /^\\+(.*)\\(\\s*$Type\\s*\\)([ \\t]++)((?![={]|\\\\$|$Attribute|__attribute__))/ &&\n\t\t    (!defined($1) || $1 !~ /\\b(?:sizeof|__alignof__)\\s*$/)) {\n\t\t\tif (CHK(\"SPACING\",\n\t\t\t\t\"No space is necessary after a cast\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/(\\(\\s*$Type\\s*\\))[ \\t]+/$1/;\n\t\t\t}\n\t\t}\n\n# Block comment styles\n# Networking with an initial /*\n\t\tif ($realfile =~ m@^(drivers/net/|net/)@ &&\n\t\t    $prevrawline =~ /^\\+[ \\t]*\\/\\*[ \\t]*$/ &&\n\t\t    $rawline =~ /^\\+[ \\t]*\\*/ &&\n\t\t    $realline > 3) { # Do not warn about the initial copyright comment block after SPDX-License-Identifier\n\t\t\tWARN(\"NETWORKING_BLOCK_COMMENT_STYLE\",\n\t\t\t     \"networking block comments don't use an empty /* line, use /* Comment...\\n\" . $hereprev);\n\t\t}\n\n# Block comments use * on subsequent lines\n\t\tif ($prevline =~ /$;[ \\t]*$/ &&\t\t\t#ends in comment\n\t\t    $prevrawline =~ /^\\+.*?\\/\\*/ &&\t\t#starting /*\n\t\t    $prevrawline !~ /\\*\\/[ \\t]*$/ &&\t\t#no trailing */\n\t\t    $rawline =~ /^\\+/ &&\t\t\t#line is new\n\t\t    $rawline !~ /^\\+[ \\t]*\\*/) {\t\t#no leading *\n\t\t\tWARN(\"BLOCK_COMMENT_STYLE\",\n\t\t\t     \"Block comments use * on subsequent lines\\n\" . $hereprev);\n\t\t}\n\n# Block comments use */ on trailing lines\n\t\tif ($rawline !~ m@^\\+[ \\t]*\\*/[ \\t]*$@ &&\t#trailing */\n\t\t    $rawline !~ m@^\\+.*/\\*.*\\*/[ \\t]*$@ &&\t#inline /*...*/\n\t\t    $rawline !~ m@^\\+.*\\*{2,}/[ \\t]*$@ &&\t#trailing **/\n\t\t    $rawline =~ m@^\\+[ \\t]*.+\\*\\/[ \\t]*$@) {\t#non blank */\n\t\t\tWARN(\"BLOCK_COMMENT_STYLE\",\n\t\t\t     \"Block comments use a trailing */ on a separate line\\n\" . $herecurr);\n\t\t}\n\n# Block comment * alignment\n\t\tif ($prevline =~ /$;[ \\t]*$/ &&\t\t\t#ends in comment\n\t\t    $line =~ /^\\+[ \\t]*$;/ &&\t\t\t#leading comment\n\t\t    $rawline =~ /^\\+[ \\t]*\\*/ &&\t\t#leading *\n\t\t    (($prevrawline =~ /^\\+.*?\\/\\*/ &&\t\t#leading /*\n\t\t      $prevrawline !~ /\\*\\/[ \\t]*$/) ||\t\t#no trailing */\n\t\t     $prevrawline =~ /^\\+[ \\t]*\\*/)) {\t\t#leading *\n\t\t\tmy $oldindent;\n\t\t\t$prevrawline =~ m@^\\+([ \\t]*/?)\\*@;\n\t\t\tif (defined($1)) {\n\t\t\t\t$oldindent = expand_tabs($1);\n\t\t\t} else {\n\t\t\t\t$prevrawline =~ m@^\\+(.*/?)\\*@;\n\t\t\t\t$oldindent = expand_tabs($1);\n\t\t\t}\n\t\t\t$rawline =~ m@^\\+([ \\t]*)\\*@;\n\t\t\tmy $newindent = $1;\n\t\t\t$newindent = expand_tabs($newindent);\n\t\t\tif (length($oldindent) ne length($newindent)) {\n\t\t\t\tWARN(\"BLOCK_COMMENT_STYLE\",\n\t\t\t\t     \"Block comments should align the * on each line\\n\" . $hereprev);\n\t\t\t}\n\t\t}\n\n# check for missing blank lines after struct/union declarations\n# with exceptions for various attributes and macros\n\t\tif ($prevline =~ /^[\\+ ]};?\\s*$/ &&\n\t\t    $line =~ /^\\+/ &&\n\t\t    !($line =~ /^\\+\\s*$/ ||\n\t\t      $line =~ /^\\+\\s*(?:EXPORT_SYMBOL|early_param)/ ||\n\t\t      $line =~ /^\\+\\s*MODULE_/i ||\n\t\t      $line =~ /^\\+\\s*\\#\\s*(?:end|elif|else)/ ||\n\t\t      $line =~ /^\\+[a-z_]*init/ ||\n\t\t      $line =~ /^\\+\\s*(?:static\\s+)?[A-Z_]*ATTR/ ||\n\t\t      $line =~ /^\\+\\s*DECLARE/ ||\n\t\t      $line =~ /^\\+\\s*builtin_[\\w_]*driver/ ||\n\t\t      $line =~ /^\\+\\s*__setup/)) {\n\t\t\tif (CHK(\"LINE_SPACING\",\n\t\t\t\t\"Please use a blank line after function/struct/union/enum declarations\\n\" . $hereprev) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_insert_line($fixlinenr, \"\\+\");\n\t\t\t}\n\t\t}\n\n# check for multiple consecutive blank lines\n\t\tif ($prevline =~ /^[\\+ ]\\s*$/ &&\n\t\t    $line =~ /^\\+\\s*$/ &&\n\t\t    $last_blank_line != ($linenr - 1)) {\n\t\t\tif (CHK(\"LINE_SPACING\",\n\t\t\t\t\"Please don't use multiple blank lines\\n\" . $hereprev) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t}\n\n\t\t\t$last_blank_line = $linenr;\n\t\t}\n\n# check for missing blank lines after declarations\n# (declarations must have the same indentation and not be at the start of line)\n\t\tif (($prevline =~ /\\+(\\s+)\\S/) && $sline =~ /^\\+$1\\S/) {\n\t\t\t# use temporaries\n\t\t\tmy $sl = $sline;\n\t\t\tmy $pl = $prevline;\n\t\t\t# remove $Attribute/$Sparse uses to simplify comparisons\n\t\t\t$sl =~ s/\\b(?:$Attribute|$Sparse)\\b//g;\n\t\t\t$pl =~ s/\\b(?:$Attribute|$Sparse)\\b//g;\n\t\t\tif (($pl =~ /^\\+\\s+$Declare\\s*$Ident\\s*[=,;:\\[]/ ||\n\t\t\t# function pointer declarations\n\t\t\t     $pl =~ /^\\+\\s+$Declare\\s*\\(\\s*\\*\\s*$Ident\\s*\\)\\s*[=,;:\\[\\(]/ ||\n\t\t\t# foo bar; where foo is some local typedef or #define\n\t\t\t     $pl =~ /^\\+\\s+$Ident(?:\\s+|\\s*\\*\\s*)$Ident\\s*[=,;\\[]/ ||\n\t\t\t# known declaration macros\n\t\t\t     $pl =~ /^\\+\\s+$declaration_macros/) &&\n\t\t\t# for \"else if\" which can look like \"$Ident $Ident\"\n\t\t\t    !($pl =~ /^\\+\\s+$c90_Keywords\\b/ ||\n\t\t\t# other possible extensions of declaration lines\n\t\t\t      $pl =~ /(?:$Compare|$Assignment|$Operators)\\s*$/ ||\n\t\t\t# not starting a section or a macro \"\\\" extended line\n\t\t\t      $pl =~ /(?:\\{\\s*|\\\\)$/) &&\n\t\t\t# looks like a declaration\n\t\t\t    !($sl =~ /^\\+\\s+$Declare\\s*$Ident\\s*[=,;:\\[]/ ||\n\t\t\t# function pointer declarations\n\t\t\t      $sl =~ /^\\+\\s+$Declare\\s*\\(\\s*\\*\\s*$Ident\\s*\\)\\s*[=,;:\\[\\(]/ ||\n\t\t\t# foo bar; where foo is some local typedef or #define\n\t\t\t      $sl =~ /^\\+\\s+$Ident(?:\\s+|\\s*\\*\\s*)$Ident\\s*[=,;\\[]/ ||\n\t\t\t# known declaration macros\n\t\t\t      $sl =~ /^\\+\\s+$declaration_macros/ ||\n\t\t\t# start of struct or union or enum\n\t\t\t      $sl =~ /^\\+\\s+(?:static\\s+)?(?:const\\s+)?(?:union|struct|enum|typedef)\\b/ ||\n\t\t\t# start or end of block or continuation of declaration\n\t\t\t      $sl =~ /^\\+\\s+(?:$|[\\{\\}\\.\\#\\\"\\?\\:\\(\\[])/ ||\n\t\t\t# bitfield continuation\n\t\t\t      $sl =~ /^\\+\\s+$Ident\\s*:\\s*\\d+\\s*[,;]/ ||\n\t\t\t# other possible extensions of declaration lines\n\t\t\t      $sl =~ /^\\+\\s+\\(?\\s*(?:$Compare|$Assignment|$Operators)/)) {\n\t\t\t\tif (WARN(\"LINE_SPACING\",\n\t\t\t\t\t \"Missing a blank line after declarations\\n\" . $hereprev) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\tfix_insert_line($fixlinenr, \"\\+\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for spaces at the beginning of a line.\n# Exceptions:\n#  1) within comments\n#  2) indented preprocessor commands\n#  3) hanging labels\n\t\tif ($rawline =~ /^\\+ / && $line !~ /^\\+ *(?:$;|#|$Ident:)/)  {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\tif (WARN(\"LEADING_SPACE\",\n\t\t\t\t \"please, no spaces at the start of a line\\n\" . $herevet) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/^\\+([ \\t]+)/\"\\+\" . tabify($1)/e;\n\t\t\t}\n\t\t}\n\n# check we are in a valid C source file if not then ignore this hunk\n\t\tnext if ($realfile !~ /\\.(h|c)$/);\n\n# check for unusual line ending [ or (\n\t\tif ($line =~ /^\\+.*([\\[\\(])\\s*$/) {\n\t\t\tCHK(\"OPEN_ENDED_LINE\",\n\t\t\t    \"Lines should not end with a '$1'\\n\" . $herecurr);\n\t\t}\n\n# check if this appears to be the start function declaration, save the name\n\t\tif ($sline =~ /^\\+\\{\\s*$/ &&\n\t\t    $prevline =~ /^\\+(?:(?:(?:$Storage|$Inline)\\s*)*\\s*$Type\\s*)?($Ident)\\(/) {\n\t\t\t$context_function = $1;\n\t\t}\n\n# check if this appears to be the end of function declaration\n\t\tif ($sline =~ /^\\+\\}\\s*$/) {\n\t\t\tundef $context_function;\n\t\t}\n\n# check indentation of any line with a bare else\n# (but not if it is a multiple line \"if (foo) return bar; else return baz;\")\n# if the previous line is a break or return and is indented 1 tab more...\n\t\tif ($sline =~ /^\\+([\\t]+)(?:}[ \\t]*)?else(?:[ \\t]*{)?\\s*$/) {\n\t\t\tmy $tabs = length($1) + 1;\n\t\t\tif ($prevline =~ /^\\+\\t{$tabs,$tabs}break\\b/ ||\n\t\t\t    ($prevline =~ /^\\+\\t{$tabs,$tabs}return\\b/ &&\n\t\t\t     defined $lines[$linenr] &&\n\t\t\t     $lines[$linenr] !~ /^[ \\+]\\t{$tabs,$tabs}return/)) {\n\t\t\t\tWARN(\"UNNECESSARY_ELSE\",\n\t\t\t\t     \"else is not generally useful after a break or return\\n\" . $hereprev);\n\t\t\t}\n\t\t}\n\n# check indentation of a line with a break;\n# if the previous line is a goto, return or break\n# and is indented the same # of tabs\n\t\tif ($sline =~ /^\\+([\\t]+)break\\s*;\\s*$/) {\n\t\t\tmy $tabs = $1;\n\t\t\tif ($prevline =~ /^\\+$tabs(goto|return|break)\\b/) {\n\t\t\t\tif (WARN(\"UNNECESSARY_BREAK\",\n\t\t\t\t\t \"break is not useful after a $1\\n\" . $hereprev) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for RCS/CVS revision markers\n\t\tif ($rawline =~ /^\\+.*\\$(Revision|Log|Id)(?:\\$|)/) {\n\t\t\tWARN(\"CVS_KEYWORD\",\n\t\t\t     \"CVS style keyword markers, these will _not_ be updated\\n\". $herecurr);\n\t\t}\n\n# check for old HOTPLUG __dev<foo> section markings\n\t\tif ($line =~ /\\b(__dev(init|exit)(data|const|))\\b/) {\n\t\t\tWARN(\"HOTPLUG_SECTION\",\n\t\t\t     \"Using $1 is unnecessary\\n\" . $herecurr);\n\t\t}\n\n# Check for potential 'bare' types\n\t\tmy ($stat, $cond, $line_nr_next, $remain_next, $off_next,\n\t\t    $realline_next);\n#print \"LINE<$line>\\n\";\n\t\tif ($linenr > $suppress_statement &&\n\t\t    $realcnt && $sline =~ /.\\s*\\S/) {\n\t\t\t($stat, $cond, $line_nr_next, $remain_next, $off_next) =\n\t\t\t\tctx_statement_block($linenr, $realcnt, 0);\n\t\t\t$stat =~ s/\\n./\\n /g;\n\t\t\t$cond =~ s/\\n./\\n /g;\n\n#print \"linenr<$linenr> <$stat>\\n\";\n\t\t\t# If this statement has no statement boundaries within\n\t\t\t# it there is no point in retrying a statement scan\n\t\t\t# until we hit end of it.\n\t\t\tmy $frag = $stat; $frag =~ s/;+\\s*$//;\n\t\t\tif ($frag !~ /(?:{|;)/) {\n#print \"skip<$line_nr_next>\\n\";\n\t\t\t\t$suppress_statement = $line_nr_next;\n\t\t\t}\n\n\t\t\t# Find the real next line.\n\t\t\t$realline_next = $line_nr_next;\n\t\t\tif (defined $realline_next &&\n\t\t\t    (!defined $lines[$realline_next - 1] ||\n\t\t\t     substr($lines[$realline_next - 1], $off_next) =~ /^\\s*$/)) {\n\t\t\t\t$realline_next++;\n\t\t\t}\n\n\t\t\tmy $s = $stat;\n\t\t\t$s =~ s/{.*$//s;\n\n\t\t\t# Ignore goto labels.\n\t\t\tif ($s =~ /$Ident:\\*$/s) {\n\n\t\t\t# Ignore functions being called\n\t\t\t} elsif ($s =~ /^.\\s*$Ident\\s*\\(/s) {\n\n\t\t\t} elsif ($s =~ /^.\\s*else\\b/s) {\n\n\t\t\t# declarations always start with types\n\t\t\t} elsif ($prev_values eq 'E' && $s =~ /^.\\s*(?:$Storage\\s+)?(?:$Inline\\s+)?(?:const\\s+)?((?:\\s*$Ident)+?)\\b(?:\\s+$Sparse)?\\s*\\**\\s*(?:$Ident|\\(\\*[^\\)]*\\))(?:\\s*$Modifier)?\\s*(?:;|=|,|\\()/s) {\n\t\t\t\tmy $type = $1;\n\t\t\t\t$type =~ s/\\s+/ /g;\n\t\t\t\tpossible($type, \"A:\" . $s);\n\n\t\t\t# definitions in global scope can only start with types\n\t\t\t} elsif ($s =~ /^.(?:$Storage\\s+)?(?:$Inline\\s+)?(?:const\\s+)?($Ident)\\b\\s*(?!:)/s) {\n\t\t\t\tpossible($1, \"B:\" . $s);\n\t\t\t}\n\n\t\t\t# any (foo ... *) is a pointer cast, and foo is a type\n\t\t\twhile ($s =~ /\\(($Ident)(?:\\s+$Sparse)*[\\s\\*]+\\s*\\)/sg) {\n\t\t\t\tpossible($1, \"C:\" . $s);\n\t\t\t}\n\n\t\t\t# Check for any sort of function declaration.\n\t\t\t# int foo(something bar, other baz);\n\t\t\t# void (*store_gdt)(x86_descr_ptr *);\n\t\t\tif ($prev_values eq 'E' && $s =~ /^(.(?:typedef\\s*)?(?:(?:$Storage|$Inline)\\s*)*\\s*$Type\\s*(?:\\b$Ident|\\(\\*\\s*$Ident\\))\\s*)\\(/s) {\n\t\t\t\tmy ($name_len) = length($1);\n\n\t\t\t\tmy $ctx = $s;\n\t\t\t\tsubstr($ctx, 0, $name_len + 1, '');\n\t\t\t\t$ctx =~ s/\\)[^\\)]*$//;\n\n\t\t\t\tfor my $arg (split(/\\s*,\\s*/, $ctx)) {\n\t\t\t\t\tif ($arg =~ /^(?:const\\s+)?($Ident)(?:\\s+$Sparse)*\\s*\\**\\s*(:?\\b$Ident)?$/s || $arg =~ /^($Ident)$/s) {\n\n\t\t\t\t\t\tpossible($1, \"D:\" . $s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n#\n# Checks which may be anchored in the context.\n#\n\n# Check for switch () and associated case and default\n# statements should be at the same indent.\n\t\tif ($line=~/\\bswitch\\s*\\(.*\\)/) {\n\t\t\tmy $err = '';\n\t\t\tmy $sep = '';\n\t\t\tmy @ctx = ctx_block_outer($linenr, $realcnt);\n\t\t\tshift(@ctx);\n\t\t\tfor my $ctx (@ctx) {\n\t\t\t\tmy ($clen, $cindent) = line_stats($ctx);\n\t\t\t\tif ($ctx =~ /^\\+\\s*(case\\s+|default:)/ &&\n\t\t\t\t\t\t\t$indent != $cindent) {\n\t\t\t\t\t$err .= \"$sep$ctx\\n\";\n\t\t\t\t\t$sep = '';\n\t\t\t\t} else {\n\t\t\t\t\t$sep = \"[...]\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($err ne '') {\n\t\t\t\tERROR(\"SWITCH_CASE_INDENT_LEVEL\",\n\t\t\t\t      \"switch and case should be at the same indent\\n$hereline$err\");\n\t\t\t}\n\t\t}\n\n# if/while/etc brace do not go on next line, unless defining a do while loop,\n# or if that brace on the next line is for something else\n\t\tif ($line =~ /(.*)\\b((?:if|while|for|switch|(?:[a-z_]+|)for_each[a-z_]+)\\s*\\(|do\\b|else\\b)/ && $line !~ /^.\\s*\\#/) {\n\t\t\tmy $pre_ctx = \"$1$2\";\n\n\t\t\tmy ($level, @ctx) = ctx_statement_level($linenr, $realcnt, 0);\n\n\t\t\tif ($line =~ /^\\+\\t{6,}/) {\n\t\t\t\tWARN(\"DEEP_INDENTATION\",\n\t\t\t\t     \"Too many leading tabs - consider code refactoring\\n\" . $herecurr);\n\t\t\t}\n\n\t\t\tmy $ctx_cnt = $realcnt - $#ctx - 1;\n\t\t\tmy $ctx = join(\"\\n\", @ctx);\n\n\t\t\tmy $ctx_ln = $linenr;\n\t\t\tmy $ctx_skip = $realcnt;\n\n\t\t\twhile ($ctx_skip > $ctx_cnt || ($ctx_skip == $ctx_cnt &&\n\t\t\t\t\tdefined $lines[$ctx_ln - 1] &&\n\t\t\t\t\t$lines[$ctx_ln - 1] =~ /^-/)) {\n\t\t\t\t##print \"SKIP<$ctx_skip> CNT<$ctx_cnt>\\n\";\n\t\t\t\t$ctx_skip-- if (!defined $lines[$ctx_ln - 1] || $lines[$ctx_ln - 1] !~ /^-/);\n\t\t\t\t$ctx_ln++;\n\t\t\t}\n\n\t\t\t#print \"realcnt<$realcnt> ctx_cnt<$ctx_cnt>\\n\";\n\t\t\t#print \"pre<$pre_ctx>\\nline<$line>\\nctx<$ctx>\\nnext<$lines[$ctx_ln - 1]>\\n\";\n\n\t\t\tif ($ctx !~ /{\\s*/ && defined($lines[$ctx_ln - 1]) && $lines[$ctx_ln - 1] =~ /^\\+\\s*{/) {\n\t\t\t\tERROR(\"OPEN_BRACE\",\n\t\t\t\t      \"that open brace { should be on the previous line\\n\" .\n\t\t\t\t\t\"$here\\n$ctx\\n$rawlines[$ctx_ln - 1]\\n\");\n\t\t\t}\n\t\t\tif ($level == 0 && $pre_ctx !~ /}\\s*while\\s*\\($/ &&\n\t\t\t    $ctx =~ /\\)\\s*\\;\\s*$/ &&\n\t\t\t    defined $lines[$ctx_ln - 1])\n\t\t\t{\n\t\t\t\tmy ($nlength, $nindent) = line_stats($lines[$ctx_ln - 1]);\n\t\t\t\tif ($nindent > $indent) {\n\t\t\t\t\tWARN(\"TRAILING_SEMICOLON\",\n\t\t\t\t\t     \"trailing semicolon indicates no statements, indent implies otherwise\\n\" .\n\t\t\t\t\t\t\"$here\\n$ctx\\n$rawlines[$ctx_ln - 1]\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check relative indent for conditionals and blocks.\n\t\tif ($line =~ /\\b(?:(?:if|while|for|(?:[a-z_]+|)for_each[a-z_]+)\\s*\\(|(?:do|else)\\b)/ && $line !~ /^.\\s*#/ && $line !~ /\\}\\s*while\\s*/) {\n\t\t\t($stat, $cond, $line_nr_next, $remain_next, $off_next) =\n\t\t\t\tctx_statement_block($linenr, $realcnt, 0)\n\t\t\t\t\tif (!defined $stat);\n\t\t\tmy ($s, $c) = ($stat, $cond);\n\n\t\t\tsubstr($s, 0, length($c), '');\n\n\t\t\t# remove inline comments\n\t\t\t$s =~ s/$;/ /g;\n\t\t\t$c =~ s/$;/ /g;\n\n\t\t\t# Find out how long the conditional actually is.\n\t\t\tmy @newlines = ($c =~ /\\n/gs);\n\t\t\tmy $cond_lines = 1 + $#newlines;\n\n\t\t\t# Make sure we remove the line prefixes as we have\n\t\t\t# none on the first line, and are going to readd them\n\t\t\t# where necessary.\n\t\t\t$s =~ s/\\n./\\n/gs;\n\t\t\twhile ($s =~ /\\n\\s+\\\\\\n/) {\n\t\t\t\t$cond_lines += $s =~ s/\\n\\s+\\\\\\n/\\n/g;\n\t\t\t}\n\n\t\t\t# We want to check the first line inside the block\n\t\t\t# starting at the end of the conditional, so remove:\n\t\t\t#  1) any blank line termination\n\t\t\t#  2) any opening brace { on end of the line\n\t\t\t#  3) any do (...) {\n\t\t\tmy $continuation = 0;\n\t\t\tmy $check = 0;\n\t\t\t$s =~ s/^.*\\bdo\\b//;\n\t\t\t$s =~ s/^\\s*{//;\n\t\t\tif ($s =~ s/^\\s*\\\\//) {\n\t\t\t\t$continuation = 1;\n\t\t\t}\n\t\t\tif ($s =~ s/^\\s*?\\n//) {\n\t\t\t\t$check = 1;\n\t\t\t\t$cond_lines++;\n\t\t\t}\n\n\t\t\t# Also ignore a loop construct at the end of a\n\t\t\t# preprocessor statement.\n\t\t\tif (($prevline =~ /^.\\s*#\\s*define\\s/ ||\n\t\t\t    $prevline =~ /\\\\\\s*$/) && $continuation == 0) {\n\t\t\t\t$check = 0;\n\t\t\t}\n\n\t\t\tmy $cond_ptr = -1;\n\t\t\t$continuation = 0;\n\t\t\twhile ($cond_ptr != $cond_lines) {\n\t\t\t\t$cond_ptr = $cond_lines;\n\n\t\t\t\t# If we see an #else/#elif then the code\n\t\t\t\t# is not linear.\n\t\t\t\tif ($s =~ /^\\s*\\#\\s*(?:else|elif)/) {\n\t\t\t\t\t$check = 0;\n\t\t\t\t}\n\n\t\t\t\t# Ignore:\n\t\t\t\t#  1) blank lines, they should be at 0,\n\t\t\t\t#  2) preprocessor lines, and\n\t\t\t\t#  3) labels.\n\t\t\t\tif ($continuation ||\n\t\t\t\t    $s =~ /^\\s*?\\n/ ||\n\t\t\t\t    $s =~ /^\\s*#\\s*?/ ||\n\t\t\t\t    $s =~ /^\\s*$Ident\\s*:/) {\n\t\t\t\t\t$continuation = ($s =~ /^.*?\\\\\\n/) ? 1 : 0;\n\t\t\t\t\tif ($s =~ s/^.*?\\n//) {\n\t\t\t\t\t\t$cond_lines++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmy (undef, $sindent) = line_stats(\"+\" . $s);\n\t\t\tmy $stat_real = raw_line($linenr, $cond_lines);\n\n\t\t\t# Check if either of these lines are modified, else\n\t\t\t# this is not this patch's fault.\n\t\t\tif (!defined($stat_real) ||\n\t\t\t    $stat !~ /^\\+/ && $stat_real !~ /^\\+/) {\n\t\t\t\t$check = 0;\n\t\t\t}\n\t\t\tif (defined($stat_real) && $cond_lines > 1) {\n\t\t\t\t$stat_real = \"[...]\\n$stat_real\";\n\t\t\t}\n\n\t\t\t#print \"line<$line> prevline<$prevline> indent<$indent> sindent<$sindent> check<$check> continuation<$continuation> s<$s> cond_lines<$cond_lines> stat_real<$stat_real> stat<$stat>\\n\";\n\n\t\t\tif ($check && $s ne '' &&\n\t\t\t    (($sindent % $tabsize) != 0 ||\n\t\t\t     ($sindent < $indent) ||\n\t\t\t     ($sindent == $indent &&\n\t\t\t      ($s !~ /^\\s*(?:\\}|\\{|else\\b)/)) ||\n\t\t\t     ($sindent > $indent + $tabsize))) {\n\t\t\t\tWARN(\"SUSPECT_CODE_INDENT\",\n\t\t\t\t     \"suspect code indent for conditional statements ($indent, $sindent)\\n\" . $herecurr . \"$stat_real\\n\");\n\t\t\t}\n\t\t}\n\n\t\t# Track the 'values' across context and added lines.\n\t\tmy $opline = $line; $opline =~ s/^./ /;\n\t\tmy ($curr_values, $curr_vars) =\n\t\t\t\tannotate_values($opline . \"\\n\", $prev_values);\n\t\t$curr_values = $prev_values . $curr_values;\n\t\tif ($dbg_values) {\n\t\t\tmy $outline = $opline; $outline =~ s/\\t/ /g;\n\t\t\tprint \"$linenr > .$outline\\n\";\n\t\t\tprint \"$linenr > $curr_values\\n\";\n\t\t\tprint \"$linenr >  $curr_vars\\n\";\n\t\t}\n\t\t$prev_values = substr($curr_values, -1);\n\n#ignore lines not being added\n\t\tnext if ($line =~ /^[^\\+]/);\n\n# check for self assignments used to avoid compiler warnings\n# e.g.:\tint foo = foo, *bar = NULL;\n#\tstruct foo bar = *(&(bar));\n\t\tif ($line =~ /^\\+\\s*(?:$Declare)?([A-Za-z_][A-Za-z\\d_]*)\\s*=/) {\n\t\t\tmy $var = $1;\n\t\t\tif ($line =~ /^\\+\\s*(?:$Declare)?$var\\s*=\\s*(?:$var|\\*\\s*\\(?\\s*&\\s*\\(?\\s*$var\\s*\\)?\\s*\\)?)\\s*[;,]/) {\n\t\t\t\tWARN(\"SELF_ASSIGNMENT\",\n\t\t\t\t     \"Do not use self-assignments to avoid compiler warnings\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for dereferences that span multiple lines\n\t\tif ($prevline =~ /^\\+.*$Lval\\s*(?:\\.|->)\\s*$/ &&\n\t\t    $line =~ /^\\+\\s*(?!\\#\\s*(?!define\\s+|if))\\s*$Lval/) {\n\t\t\t$prevline =~ /($Lval\\s*(?:\\.|->))\\s*$/;\n\t\t\tmy $ref = $1;\n\t\t\t$line =~ /^.\\s*($Lval)/;\n\t\t\t$ref .= $1;\n\t\t\t$ref =~ s/\\s//g;\n\t\t\tWARN(\"MULTILINE_DEREFERENCE\",\n\t\t\t     \"Avoid multiple line dereference - prefer '$ref'\\n\" . $hereprev);\n\t\t}\n\n# check for declarations of signed or unsigned without int\n\t\twhile ($line =~ m{\\b($Declare)\\s*(?!char\\b|short\\b|int\\b|long\\b)\\s*($Ident)?\\s*[=,;\\[\\)\\(]}g) {\n\t\t\tmy $type = $1;\n\t\t\tmy $var = $2;\n\t\t\t$var = \"\" if (!defined $var);\n\t\t\tif ($type =~ /^(?:(?:$Storage|$Inline|$Attribute)\\s+)*((?:un)?signed)((?:\\s*\\*)*)\\s*$/) {\n\t\t\t\tmy $sign = $1;\n\t\t\t\tmy $pointer = $2;\n\n\t\t\t\t$pointer = \"\" if (!defined $pointer);\n\n\t\t\t\tif (WARN(\"UNSPECIFIED_INT\",\n\t\t\t\t\t \"Prefer '\" . trim($sign) . \" int\" . rtrim($pointer) . \"' to bare use of '$sign\" . rtrim($pointer) . \"'\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\tmy $decl = trim($sign) . \" int \";\n\t\t\t\t\tmy $comp_pointer = $pointer;\n\t\t\t\t\t$comp_pointer =~ s/\\s//g;\n\t\t\t\t\t$decl .= $comp_pointer;\n\t\t\t\t\t$decl = rtrim($decl) if ($var eq \"\");\n\t\t\t\t\t$fixed[$fixlinenr] =~ s@\\b$sign\\s*\\Q$pointer\\E\\s*$var\\b@$decl$var@;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# TEST: allow direct testing of the type matcher.\n\t\tif ($dbg_type) {\n\t\t\tif ($line =~ /^.\\s*$Declare\\s*$/) {\n\t\t\t\tERROR(\"TEST_TYPE\",\n\t\t\t\t      \"TEST: is type\\n\" . $herecurr);\n\t\t\t} elsif ($dbg_type > 1 && $line =~ /^.+($Declare)/) {\n\t\t\t\tERROR(\"TEST_NOT_TYPE\",\n\t\t\t\t      \"TEST: is not type ($1 is)\\n\". $herecurr);\n\t\t\t}\n\t\t\tnext;\n\t\t}\n# TEST: allow direct testing of the attribute matcher.\n\t\tif ($dbg_attr) {\n\t\t\tif ($line =~ /^.\\s*$Modifier\\s*$/) {\n\t\t\t\tERROR(\"TEST_ATTR\",\n\t\t\t\t      \"TEST: is attr\\n\" . $herecurr);\n\t\t\t} elsif ($dbg_attr > 1 && $line =~ /^.+($Modifier)/) {\n\t\t\t\tERROR(\"TEST_NOT_ATTR\",\n\t\t\t\t      \"TEST: is not attr ($1 is)\\n\". $herecurr);\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\n# check for initialisation to aggregates open brace on the next line\n\t\tif ($line =~ /^.\\s*{/ &&\n\t\t    $prevline =~ /(?:^|[^=])=\\s*$/) {\n\t\t\tif (ERROR(\"OPEN_BRACE\",\n\t\t\t\t  \"that open brace { should be on the previous line\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevline =~ /^\\+/ && $line =~ /^\\+/) {\n\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\tmy $fixedline = $prevrawline;\n\t\t\t\t$fixedline =~ s/\\s*=\\s*$/ = {/;\n\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t$fixedline = $line;\n\t\t\t\t$fixedline =~ s/^(.\\s*)\\{\\s*/$1/;\n\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t}\n\t\t}\n\n#\n# Checks which are anchored on the added line.\n#\n\n# check for malformed paths in #include statements (uses RAW line)\n\t\tif ($rawline =~ m{^.\\s*\\#\\s*include\\s+[<\"](.*)[\">]}) {\n\t\t\tmy $path = $1;\n\t\t\tif ($path =~ m{//}) {\n\t\t\t\tERROR(\"MALFORMED_INCLUDE\",\n\t\t\t\t      \"malformed #include filename\\n\" . $herecurr);\n\t\t\t}\n\t\t\tif ($path =~ \"^uapi/\" && $realfile =~ m@\\binclude/uapi/@) {\n\t\t\t\tERROR(\"UAPI_INCLUDE\",\n\t\t\t\t      \"No #include in ...include/uapi/... should use a uapi/ path prefix\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# no C99 // comments\n\t\tif ($line =~ m{//}) {\n\t\t\tif (ERROR(\"C99_COMMENTS\",\n\t\t\t\t  \"do not use C99 // comments\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tmy $line = $fixed[$fixlinenr];\n\t\t\t\tif ($line =~ /\\/\\/(.*)$/) {\n\t\t\t\t\tmy $comment = trim($1);\n\t\t\t\t\t$fixed[$fixlinenr] =~ s@\\/\\/(.*)$@/\\* $comment \\*/@;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t# Remove C99 comments.\n\t\t$line =~ s@//.*@@;\n\t\t$opline =~ s@//.*@@;\n\n# EXPORT_SYMBOL should immediately follow the thing it is exporting, consider\n# the whole statement.\n#print \"APW <$lines[$realline_next - 1]>\\n\";\n\t\tif (defined $realline_next &&\n\t\t    exists $lines[$realline_next - 1] &&\n\t\t    !defined $suppress_export{$realline_next} &&\n\t\t    ($lines[$realline_next - 1] =~ /EXPORT_SYMBOL.*\\((.*)\\)/)) {\n\t\t\t# Handle definitions which produce identifiers with\n\t\t\t# a prefix:\n\t\t\t#   XXX(foo);\n\t\t\t#   EXPORT_SYMBOL(something_foo);\n\t\t\tmy $name = $1;\n\t\t\t$name =~ s/^\\s*($Ident).*/$1/;\n\t\t\tif ($stat =~ /^(?:.\\s*}\\s*\\n)?.([A-Z_]+)\\s*\\(\\s*($Ident)/ &&\n\t\t\t    $name =~ /^${Ident}_$2/) {\n#print \"FOO C name<$name>\\n\";\n\t\t\t\t$suppress_export{$realline_next} = 1;\n\n\t\t\t} elsif ($stat !~ /(?:\n\t\t\t\t\\n.}\\s*$|\n\t\t\t\t^.DEFINE_$Ident\\(\\Q$name\\E\\)|\n\t\t\t\t^.DECLARE_$Ident\\(\\Q$name\\E\\)|\n\t\t\t\t^.LIST_HEAD\\(\\Q$name\\E\\)|\n\t\t\t\t^.(?:$Storage\\s+)?$Type\\s*\\(\\s*\\*\\s*\\Q$name\\E\\s*\\)\\s*\\(|\n\t\t\t\t\\b\\Q$name\\E(?:\\s+$Attribute)*\\s*(?:;|=|\\[|\\()\n\t\t\t    )/x) {\n#print \"FOO A<$lines[$realline_next - 1]> stat<$stat> name<$name>\\n\";\n\t\t\t\t$suppress_export{$realline_next} = 2;\n\t\t\t} else {\n\t\t\t\t$suppress_export{$realline_next} = 1;\n\t\t\t}\n\t\t}\n\t\tif (!defined $suppress_export{$linenr} &&\n\t\t    $prevline =~ /^.\\s*$/ &&\n\t\t    ($line =~ /EXPORT_SYMBOL.*\\((.*)\\)/)) {\n#print \"FOO B <$lines[$linenr - 1]>\\n\";\n\t\t\t$suppress_export{$linenr} = 2;\n\t\t}\n\t\tif (defined $suppress_export{$linenr} &&\n\t\t    $suppress_export{$linenr} == 2) {\n\t\t\tWARN(\"EXPORT_SYMBOL\",\n\t\t\t     \"EXPORT_SYMBOL(foo); should immediately follow its function/variable\\n\" . $herecurr);\n\t\t}\n\n# check for global initialisers.\n\t\tif ($line =~ /^\\+$Type\\s*$Ident(?:\\s+$Modifier)*\\s*=\\s*($zero_initializer)\\s*;/ &&\n\t\t    !exclude_global_initialisers($realfile)) {\n\t\t\tif (ERROR(\"GLOBAL_INITIALISERS\",\n\t\t\t\t  \"do not initialise globals to $1\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(^.$Type\\s*$Ident(?:\\s+$Modifier)*)\\s*=\\s*$zero_initializer\\s*;/$1;/;\n\t\t\t}\n\t\t}\n# check for static initialisers.\n\t\tif ($line =~ /^\\+.*\\bstatic\\s.*=\\s*($zero_initializer)\\s*;/) {\n\t\t\tif (ERROR(\"INITIALISED_STATIC\",\n\t\t\t\t  \"do not initialise statics to $1\\n\" .\n\t\t\t\t      $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(\\bstatic\\s.*?)\\s*=\\s*$zero_initializer\\s*;/$1;/;\n\t\t\t}\n\t\t}\n\n# check for misordered declarations of char/short/int/long with signed/unsigned\n\t\twhile ($sline =~ m{(\\b$TypeMisordered\\b)}g) {\n\t\t\tmy $tmp = trim($1);\n\t\t\tWARN(\"MISORDERED_TYPE\",\n\t\t\t     \"type '$tmp' should be specified in [[un]signed] [short|int|long|long long] order\\n\" . $herecurr);\n\t\t}\n\n# check for unnecessary <signed> int declarations of short/long/long long\n\t\twhile ($sline =~ m{\\b($TypeMisordered(\\s*\\*)*|$C90_int_types)\\b}g) {\n\t\t\tmy $type = trim($1);\n\t\t\tnext if ($type !~ /\\bint\\b/);\n\t\t\tnext if ($type !~ /\\b(?:short|long\\s+long|long)\\b/);\n\t\t\tmy $new_type = $type;\n\t\t\t$new_type =~ s/\\b\\s*int\\s*\\b/ /;\n\t\t\t$new_type =~ s/\\b\\s*(?:un)?signed\\b\\s*/ /;\n\t\t\t$new_type =~ s/^const\\s+//;\n\t\t\t$new_type = \"unsigned $new_type\" if ($type =~ /\\bunsigned\\b/);\n\t\t\t$new_type = \"const $new_type\" if ($type =~ /^const\\b/);\n\t\t\t$new_type =~ s/\\s+/ /g;\n\t\t\t$new_type = trim($new_type);\n\t\t\tif (WARN(\"UNNECESSARY_INT\",\n\t\t\t\t \"Prefer '$new_type' over '$type' as the int is unnecessary\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\b\\Q$type\\E\\b/$new_type/;\n\t\t\t}\n\t\t}\n\n# check for static const char * arrays.\n\t\tif ($line =~ /\\bstatic\\s+const\\s+char\\s*\\*\\s*(\\w+)\\s*\\[\\s*\\]\\s*=\\s*/) {\n\t\t\tWARN(\"STATIC_CONST_CHAR_ARRAY\",\n\t\t\t     \"static const char * array should probably be static const char * const\\n\" .\n\t\t\t\t$herecurr);\n\t\t}\n\n# check for initialized const char arrays that should be static const\n\t\tif ($line =~ /^\\+\\s*const\\s+(char|unsigned\\s+char|_*u8|(?:[us]_)?int8_t)\\s+\\w+\\s*\\[\\s*(?:\\w+\\s*)?\\]\\s*=\\s*\"/) {\n\t\t\tif (WARN(\"STATIC_CONST_CHAR_ARRAY\",\n\t\t\t\t \"const array should probably be static const\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(^.\\s*)const\\b/${1}static const/;\n\t\t\t}\n\t\t}\n\n# check for static char foo[] = \"bar\" declarations.\n\t\tif ($line =~ /\\bstatic\\s+char\\s+(\\w+)\\s*\\[\\s*\\]\\s*=\\s*\"/) {\n\t\t\tWARN(\"STATIC_CONST_CHAR_ARRAY\",\n\t\t\t     \"static char array declaration should probably be static const char\\n\" .\n\t\t\t\t$herecurr);\n\t\t}\n\n# check for const <foo> const where <foo> is not a pointer or array type\n\t\tif ($sline =~ /\\bconst\\s+($BasicType)\\s+const\\b/) {\n\t\t\tmy $found = $1;\n\t\t\tif ($sline =~ /\\bconst\\s+\\Q$found\\E\\s+const\\b\\s*\\*/) {\n\t\t\t\tWARN(\"CONST_CONST\",\n\t\t\t\t     \"'const $found const *' should probably be 'const $found * const'\\n\" . $herecurr);\n\t\t\t} elsif ($sline !~ /\\bconst\\s+\\Q$found\\E\\s+const\\s+\\w+\\s*\\[/) {\n\t\t\t\tWARN(\"CONST_CONST\",\n\t\t\t\t     \"'const $found const' should probably be 'const $found'\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for const static or static <non ptr type> const declarations\n# prefer 'static const <foo>' over 'const static <foo>' and 'static <foo> const'\n\t\tif ($sline =~ /^\\+\\s*const\\s+static\\s+($Type)\\b/ ||\n\t\t    $sline =~ /^\\+\\s*static\\s+($BasicType)\\s+const\\b/) {\n\t\t\tif (WARN(\"STATIC_CONST\",\n\t\t\t\t \"Move const after static - use 'static const $1'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\bconst\\s+static\\b/static const/;\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\bstatic\\s+($BasicType)\\s+const\\b/static const $1/;\n\t\t\t}\n\t\t}\n\n# check for non-global char *foo[] = {\"bar\", ...} declarations.\n\t\tif ($line =~ /^.\\s+(?:static\\s+|const\\s+)?char\\s+\\*\\s*\\w+\\s*\\[\\s*\\]\\s*=\\s*\\{/) {\n\t\t\tWARN(\"STATIC_CONST_CHAR_ARRAY\",\n\t\t\t     \"char * array declaration might be better as static const\\n\" .\n\t\t\t\t$herecurr);\n\t\t}\n\n# check for sizeof(foo)/sizeof(foo[0]) that could be ARRAY_SIZE(foo)\n\t\tif ($line =~ m@\\bsizeof\\s*\\(\\s*($Lval)\\s*\\)@) {\n\t\t\tmy $array = $1;\n\t\t\tif ($line =~ m@\\b(sizeof\\s*\\(\\s*\\Q$array\\E\\s*\\)\\s*/\\s*sizeof\\s*\\(\\s*\\Q$array\\E\\s*\\[\\s*0\\s*\\]\\s*\\))@) {\n\t\t\t\tmy $array_div = $1;\n\t\t\t\tif (WARN(\"ARRAY_SIZE\",\n\t\t\t\t\t \"Prefer ARRAY_SIZE($array)\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$array_div\\E/ARRAY_SIZE($array)/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for function declarations without arguments like \"int foo()\"\n\t\tif ($line =~ /(\\b$Type\\s*$Ident)\\s*\\(\\s*\\)/) {\n\t\t\tif (ERROR(\"FUNCTION_WITHOUT_ARGS\",\n\t\t\t\t  \"Bad function definition - $1() should probably be $1(void)\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(\\b($Type)\\s+($Ident))\\s*\\(\\s*\\)/$2 $3(void)/;\n\t\t\t}\n\t\t}\n\n# check for new typedefs, only function parameters and sparse annotations\n# make sense.\n\t\tif ($line =~ /\\btypedef\\s/ &&\n\t\t    $line !~ /\\btypedef\\s+$Type\\s*\\(\\s*\\*?$Ident\\s*\\)\\s*\\(/ &&\n\t\t    $line !~ /\\btypedef\\s+$Type\\s+$Ident\\s*\\(/ &&\n\t\t    $line !~ /\\b$typeTypedefs\\b/ &&\n\t\t    $line !~ /\\b__bitwise\\b/) {\n\t\t\tWARN(\"NEW_TYPEDEFS\",\n\t\t\t     \"do not add new typedefs\\n\" . $herecurr);\n\t\t}\n\n# * goes on variable not on type\n\t\t# (char*[ const])\n\t\twhile ($line =~ m{(\\($NonptrType(\\s*(?:$Modifier\\b\\s*|\\*\\s*)+)\\))}g) {\n\t\t\t#print \"AA<$1>\\n\";\n\t\t\tmy ($ident, $from, $to) = ($1, $2, $2);\n\n\t\t\t# Should start with a space.\n\t\t\t$to =~ s/^(\\S)/ $1/;\n\t\t\t# Should not end with a space.\n\t\t\t$to =~ s/\\s+$//;\n\t\t\t# '*'s should not have spaces between.\n\t\t\twhile ($to =~ s/\\*\\s+\\*/\\*\\*/) {\n\t\t\t}\n\n##\t\t\tprint \"1: from<$from> to<$to> ident<$ident>\\n\";\n\t\t\tif ($from ne $to) {\n\t\t\t\tif (ERROR(\"POINTER_LOCATION\",\n\t\t\t\t\t  \"\\\"(foo$from)\\\" should be \\\"(foo$to)\\\"\\n\" .  $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\tmy $sub_from = $ident;\n\t\t\t\t\tmy $sub_to = $ident;\n\t\t\t\t\t$sub_to =~ s/\\Q$from\\E/$to/;\n\t\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t\t    s@\\Q$sub_from\\E@$sub_to@;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile ($line =~ m{(\\b$NonptrType(\\s*(?:$Modifier\\b\\s*|\\*\\s*)+)($Ident))}g) {\n\t\t\t#print \"BB<$1>\\n\";\n\t\t\tmy ($match, $from, $to, $ident) = ($1, $2, $2, $3);\n\n\t\t\t# Should start with a space.\n\t\t\t$to =~ s/^(\\S)/ $1/;\n\t\t\t# Should not end with a space.\n\t\t\t$to =~ s/\\s+$//;\n\t\t\t# '*'s should not have spaces between.\n\t\t\twhile ($to =~ s/\\*\\s+\\*/\\*\\*/) {\n\t\t\t}\n\t\t\t# Modifiers should have spaces.\n\t\t\t$to =~ s/(\\b$Modifier$)/$1 /;\n\n##\t\t\tprint \"2: from<$from> to<$to> ident<$ident>\\n\";\n\t\t\tif ($from ne $to && $ident !~ /^$Modifier$/) {\n\t\t\t\tif (ERROR(\"POINTER_LOCATION\",\n\t\t\t\t\t  \"\\\"foo${from}bar\\\" should be \\\"foo${to}bar\\\"\\n\" .  $herecurr) &&\n\t\t\t\t    $fix) {\n\n\t\t\t\t\tmy $sub_from = $match;\n\t\t\t\t\tmy $sub_to = $match;\n\t\t\t\t\t$sub_to =~ s/\\Q$from\\E/$to/;\n\t\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t\t    s@\\Q$sub_from\\E@$sub_to@;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# do not use BUG() or variants\n\t\tif ($line =~ /\\b(?!AA_|BUILD_|DCCP_|IDA_|KVM_|RWLOCK_|snd_|SPIN_)(?:[a-zA-Z_]*_)?BUG(?:_ON)?(?:_[A-Z_]+)?\\s*\\(/) {\n\t\t\tmy $msg_level = \\&WARN;\n\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t&{$msg_level}(\"AVOID_BUG\",\n\t\t\t\t      \"Do not crash the kernel unless it is absolutely unavoidable--use WARN_ON_ONCE() plus recovery code (if feasible) instead of BUG() or variants\\n\" . $herecurr);\n\t\t}\n\n# avoid LINUX_VERSION_CODE\n\t\tif ($line =~ /\\bLINUX_VERSION_CODE\\b/) {\n\t\t\tWARN(\"LINUX_VERSION_CODE\",\n\t\t\t     \"LINUX_VERSION_CODE should be avoided, code should be for the version to which it is merged\\n\" . $herecurr);\n\t\t}\n\n# check for uses of printk_ratelimit\n\t\tif ($line =~ /\\bprintk_ratelimit\\s*\\(/) {\n\t\t\tWARN(\"PRINTK_RATELIMITED\",\n\t\t\t     \"Prefer printk_ratelimited or pr_<level>_ratelimited to printk_ratelimit\\n\" . $herecurr);\n\t\t}\n\n# printk should use KERN_* levels\n\t\tif ($line =~ /\\bprintk\\s*\\(\\s*(?!KERN_[A-Z]+\\b)/) {\n\t\t\tWARN(\"PRINTK_WITHOUT_KERN_LEVEL\",\n\t\t\t     \"printk() should include KERN_<LEVEL> facility level\\n\" . $herecurr);\n\t\t}\n\n# prefer variants of (subsystem|netdev|dev|pr)_<level> to printk(KERN_<LEVEL>\n\t\tif ($line =~ /\\b(printk(_once|_ratelimited)?)\\s*\\(\\s*KERN_([A-Z]+)/) {\n\t\t\tmy $printk = $1;\n\t\t\tmy $modifier = $2;\n\t\t\tmy $orig = $3;\n\t\t\t$modifier = \"\" if (!defined($modifier));\n\t\t\tmy $level = lc($orig);\n\t\t\t$level = \"warn\" if ($level eq \"warning\");\n\t\t\tmy $level2 = $level;\n\t\t\t$level2 = \"dbg\" if ($level eq \"debug\");\n\t\t\t$level .= $modifier;\n\t\t\t$level2 .= $modifier;\n\t\t\tWARN(\"PREFER_PR_LEVEL\",\n\t\t\t     \"Prefer [subsystem eg: netdev]_$level2([subsystem]dev, ... then dev_$level2(dev, ... then pr_$level(...  to $printk(KERN_$orig ...\\n\" . $herecurr);\n\t\t}\n\n# prefer dev_<level> to dev_printk(KERN_<LEVEL>\n\t\tif ($line =~ /\\bdev_printk\\s*\\(\\s*KERN_([A-Z]+)/) {\n\t\t\tmy $orig = $1;\n\t\t\tmy $level = lc($orig);\n\t\t\t$level = \"warn\" if ($level eq \"warning\");\n\t\t\t$level = \"dbg\" if ($level eq \"debug\");\n\t\t\tWARN(\"PREFER_DEV_LEVEL\",\n\t\t\t     \"Prefer dev_$level(... to dev_printk(KERN_$orig, ...\\n\" . $herecurr);\n\t\t}\n\n# trace_printk should not be used in production code.\n\t\tif ($line =~ /\\b(trace_printk|trace_puts|ftrace_vprintk)\\s*\\(/) {\n\t\t\tWARN(\"TRACE_PRINTK\",\n\t\t\t     \"Do not use $1() in production code (this can be ignored if built only with a debug config option)\\n\" . $herecurr);\n\t\t}\n\n# ENOSYS means \"bad syscall nr\" and nothing else.  This will have a small\n# number of false positives, but assembly files are not checked, so at\n# least the arch entry code will not trigger this warning.\n\t\tif ($line =~ /\\bENOSYS\\b/) {\n\t\t\tWARN(\"ENOSYS\",\n\t\t\t     \"ENOSYS means 'invalid syscall nr' and nothing else\\n\" . $herecurr);\n\t\t}\n\n# ENOTSUPP is not a standard error code and should be avoided in new patches.\n# Folks usually mean EOPNOTSUPP (also called ENOTSUP), when they type ENOTSUPP.\n# Similarly to ENOSYS warning a small number of false positives is expected.\n\t\tif (!$file && $line =~ /\\bENOTSUPP\\b/) {\n\t\t\tif (WARN(\"ENOTSUPP\",\n\t\t\t\t \"ENOTSUPP is not a SUSV4 error code, prefer EOPNOTSUPP\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\bENOTSUPP\\b/EOPNOTSUPP/;\n\t\t\t}\n\t\t}\n\n# function brace can't be on same line, except for #defines of do while,\n# or if closed on same line\n\t\tif ($perl_version_ok &&\n\t\t    $sline =~ /$Type\\s*$Ident\\s*$balanced_parens\\s*\\{/ &&\n\t\t    $sline !~ /\\#\\s*define\\b.*do\\s*\\{/ &&\n\t\t    $sline !~ /}/) {\n\t\t\tif (ERROR(\"OPEN_BRACE\",\n\t\t\t\t  \"open brace '{' following function definitions go on the next line\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\tmy $fixed_line = $rawline;\n\t\t\t\t$fixed_line =~ /(^..*$Type\\s*$Ident\\(.*\\)\\s*)\\{(.*)$/;\n\t\t\t\tmy $line1 = $1;\n\t\t\t\tmy $line2 = $2;\n\t\t\t\tfix_insert_line($fixlinenr, ltrim($line1));\n\t\t\t\tfix_insert_line($fixlinenr, \"\\+{\");\n\t\t\t\tif ($line2 !~ /^\\s*$/) {\n\t\t\t\t\tfix_insert_line($fixlinenr, \"\\+\\t\" . trim($line2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# open braces for enum, union and struct go on the same line.\n\t\tif ($line =~ /^.\\s*{/ &&\n\t\t    $prevline =~ /^.\\s*(?:typedef\\s+)?(enum|union|struct)(?:\\s+$Ident)?\\s*$/) {\n\t\t\tif (ERROR(\"OPEN_BRACE\",\n\t\t\t\t  \"open brace '{' following $1 go on the same line\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevline =~ /^\\+/ && $line =~ /^\\+/) {\n\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\tmy $fixedline = rtrim($prevrawline) . \" {\";\n\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t$fixedline = $rawline;\n\t\t\t\t$fixedline =~ s/^(.\\s*)\\{\\s*/$1\\t/;\n\t\t\t\tif ($fixedline !~ /^\\+\\s*$/) {\n\t\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# missing space after union, struct or enum definition\n\t\tif ($line =~ /^.\\s*(?:typedef\\s+)?(enum|union|struct)(?:\\s+$Ident){1,2}[=\\{]/) {\n\t\t\tif (WARN(\"SPACING\",\n\t\t\t\t \"missing space after $1 definition\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/^(.\\s*(?:typedef\\s+)?(?:enum|union|struct)(?:\\s+$Ident){1,2})([=\\{])/$1 $2/;\n\t\t\t}\n\t\t}\n\n# Function pointer declarations\n# check spacing between type, funcptr, and args\n# canonical declaration is \"type (*funcptr)(args...)\"\n\t\tif ($line =~ /^.\\s*($Declare)\\((\\s*)\\*(\\s*)($Ident)(\\s*)\\)(\\s*)\\(/) {\n\t\t\tmy $declare = $1;\n\t\t\tmy $pre_pointer_space = $2;\n\t\t\tmy $post_pointer_space = $3;\n\t\t\tmy $funcname = $4;\n\t\t\tmy $post_funcname_space = $5;\n\t\t\tmy $pre_args_space = $6;\n\n# the $Declare variable will capture all spaces after the type\n# so check it for a missing trailing missing space but pointer return types\n# don't need a space so don't warn for those.\n\t\t\tmy $post_declare_space = \"\";\n\t\t\tif ($declare =~ /(\\s+)$/) {\n\t\t\t\t$post_declare_space = $1;\n\t\t\t\t$declare = rtrim($declare);\n\t\t\t}\n\t\t\tif ($declare !~ /\\*$/ && $post_declare_space =~ /^$/) {\n\t\t\t\tWARN(\"SPACING\",\n\t\t\t\t     \"missing space after return type\\n\" . $herecurr);\n\t\t\t\t$post_declare_space = \" \";\n\t\t\t}\n\n# unnecessary space \"type  (*funcptr)(args...)\"\n# This test is not currently implemented because these declarations are\n# equivalent to\n#\tint  foo(int bar, ...)\n# and this is form shouldn't/doesn't generate a checkpatch warning.\n#\n#\t\t\telsif ($declare =~ /\\s{2,}$/) {\n#\t\t\t\tWARN(\"SPACING\",\n#\t\t\t\t     \"Multiple spaces after return type\\n\" . $herecurr);\n#\t\t\t}\n\n# unnecessary space \"type ( *funcptr)(args...)\"\n\t\t\tif (defined $pre_pointer_space &&\n\t\t\t    $pre_pointer_space =~ /^\\s/) {\n\t\t\t\tWARN(\"SPACING\",\n\t\t\t\t     \"Unnecessary space after function pointer open parenthesis\\n\" . $herecurr);\n\t\t\t}\n\n# unnecessary space \"type (* funcptr)(args...)\"\n\t\t\tif (defined $post_pointer_space &&\n\t\t\t    $post_pointer_space =~ /^\\s/) {\n\t\t\t\tWARN(\"SPACING\",\n\t\t\t\t     \"Unnecessary space before function pointer name\\n\" . $herecurr);\n\t\t\t}\n\n# unnecessary space \"type (*funcptr )(args...)\"\n\t\t\tif (defined $post_funcname_space &&\n\t\t\t    $post_funcname_space =~ /^\\s/) {\n\t\t\t\tWARN(\"SPACING\",\n\t\t\t\t     \"Unnecessary space after function pointer name\\n\" . $herecurr);\n\t\t\t}\n\n# unnecessary space \"type (*funcptr) (args...)\"\n\t\t\tif (defined $pre_args_space &&\n\t\t\t    $pre_args_space =~ /^\\s/) {\n\t\t\t\tWARN(\"SPACING\",\n\t\t\t\t     \"Unnecessary space before function pointer arguments\\n\" . $herecurr);\n\t\t\t}\n\n\t\t\tif (show_type(\"SPACING\") && $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/^(.\\s*)$Declare\\s*\\(\\s*\\*\\s*$Ident\\s*\\)\\s*\\(/$1 . $declare . $post_declare_space . '(*' . $funcname . ')('/ex;\n\t\t\t}\n\t\t}\n\n# check for spacing round square brackets; allowed:\n#  1. with a type on the left -- int [] a;\n#  2. at the beginning of a line for slice initialisers -- [0...10] = 5,\n#  3. inside a curly brace -- = { [0...10] = 5 }\n\t\twhile ($line =~ /(.*?\\s)\\[/g) {\n\t\t\tmy ($where, $prefix) = ($-[1], $1);\n\t\t\tif ($prefix !~ /$Type\\s+$/ &&\n\t\t\t    ($where != 0 || $prefix !~ /^.\\s+$/) &&\n\t\t\t    $prefix !~ /[{,:]\\s+$/) {\n\t\t\t\tif (ERROR(\"BRACKET_SPACE\",\n\t\t\t\t\t  \"space prohibited before open square bracket '['\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t    $fixed[$fixlinenr] =~\n\t\t\t\t\ts/^(\\+.*?)\\s+\\[/$1\\[/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for spaces between functions and their parentheses.\n\t\twhile ($line =~ /($Ident)\\s+\\(/g) {\n\t\t\tmy $name = $1;\n\t\t\tmy $ctx_before = substr($line, 0, $-[1]);\n\t\t\tmy $ctx = \"$ctx_before$name\";\n\n\t\t\t# Ignore those directives where spaces _are_ permitted.\n\t\t\tif ($name =~ /^(?:\n\t\t\t\tif|for|while|switch|return|case|\n\t\t\t\tvolatile|__volatile__|\n\t\t\t\t__attribute__|format|__extension__|\n\t\t\t\tasm|__asm__|scoped_guard)$/x)\n\t\t\t{\n\t\t\t# cpp #define statements have non-optional spaces, ie\n\t\t\t# if there is a space between the name and the open\n\t\t\t# parenthesis it is simply not a parameter group.\n\t\t\t} elsif ($ctx_before =~ /^.\\s*\\#\\s*define\\s*$/) {\n\n\t\t\t# cpp #elif statement condition may start with a (\n\t\t\t} elsif ($ctx =~ /^.\\s*\\#\\s*elif\\s*$/) {\n\n\t\t\t# If this whole things ends with a type its most\n\t\t\t# likely a typedef for a function.\n\t\t\t} elsif ($ctx =~ /$Type$/) {\n\n\t\t\t} else {\n\t\t\t\tif (WARN(\"SPACING\",\n\t\t\t\t\t \"space prohibited between function name and open parenthesis '('\\n\" . $herecurr) &&\n\t\t\t\t\t     $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t\t    s/\\b$name\\s+\\(/$name\\(/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check operator spacing.\n\t\tif (!($line=~/\\#\\s*include/)) {\n\t\t\tmy $fixed_line = \"\";\n\t\t\tmy $line_fixed = 0;\n\n\t\t\tmy $ops = qr{\n\t\t\t\t<<=|>>=|<=|>=|==|!=|\n\t\t\t\t\\+=|-=|\\*=|\\/=|%=|\\^=|\\|=|&=|\n\t\t\t\t=>|->|<<|>>|<|>|=|!|~|\n\t\t\t\t&&|\\|\\||,|\\^|\\+\\+|--|&|\\||\\+|-|\\*|\\/|%|\n\t\t\t\t\\?:|\\?|:\n\t\t\t}x;\n\t\t\tmy @elements = split(/($ops|;)/, $opline);\n\n##\t\t\tprint(\"element count: <\" . $#elements . \">\\n\");\n##\t\t\tforeach my $el (@elements) {\n##\t\t\t\tprint(\"el: <$el>\\n\");\n##\t\t\t}\n\n\t\t\tmy @fix_elements = ();\n\t\t\tmy $off = 0;\n\n\t\t\tforeach my $el (@elements) {\n\t\t\t\tpush(@fix_elements, substr($rawline, $off, length($el)));\n\t\t\t\t$off += length($el);\n\t\t\t}\n\n\t\t\t$off = 0;\n\n\t\t\tmy $blank = copy_spacing($opline);\n\t\t\tmy $last_after = -1;\n\n\t\t\tfor (my $n = 0; $n < $#elements; $n += 2) {\n\n\t\t\t\tmy $good = $fix_elements[$n] . $fix_elements[$n + 1];\n\n##\t\t\t\tprint(\"n: <$n> good: <$good>\\n\");\n\n\t\t\t\t$off += length($elements[$n]);\n\n\t\t\t\t# Pick up the preceding and succeeding characters.\n\t\t\t\tmy $ca = substr($opline, 0, $off);\n\t\t\t\tmy $cc = '';\n\t\t\t\tif (length($opline) >= ($off + length($elements[$n + 1]))) {\n\t\t\t\t\t$cc = substr($opline, $off + length($elements[$n + 1]));\n\t\t\t\t}\n\t\t\t\tmy $cb = \"$ca$;$cc\";\n\n\t\t\t\tmy $a = '';\n\t\t\t\t$a = 'V' if ($elements[$n] ne '');\n\t\t\t\t$a = 'W' if ($elements[$n] =~ /\\s$/);\n\t\t\t\t$a = 'C' if ($elements[$n] =~ /$;$/);\n\t\t\t\t$a = 'B' if ($elements[$n] =~ /(\\[|\\()$/);\n\t\t\t\t$a = 'O' if ($elements[$n] eq '');\n\t\t\t\t$a = 'E' if ($ca =~ /^\\s*$/);\n\n\t\t\t\tmy $op = $elements[$n + 1];\n\n\t\t\t\tmy $c = '';\n\t\t\t\tif (defined $elements[$n + 2]) {\n\t\t\t\t\t$c = 'V' if ($elements[$n + 2] ne '');\n\t\t\t\t\t$c = 'W' if ($elements[$n + 2] =~ /^\\s/);\n\t\t\t\t\t$c = 'C' if ($elements[$n + 2] =~ /^$;/);\n\t\t\t\t\t$c = 'B' if ($elements[$n + 2] =~ /^(\\)|\\]|;)/);\n\t\t\t\t\t$c = 'O' if ($elements[$n + 2] eq '');\n\t\t\t\t\t$c = 'E' if ($elements[$n + 2] =~ /^\\s*\\\\$/);\n\t\t\t\t} else {\n\t\t\t\t\t$c = 'E';\n\t\t\t\t}\n\n\t\t\t\tmy $ctx = \"${a}x${c}\";\n\n\t\t\t\tmy $at = \"(ctx:$ctx)\";\n\n\t\t\t\tmy $ptr = substr($blank, 0, $off) . \"^\";\n\t\t\t\tmy $hereptr = \"$hereline$ptr\\n\";\n\n\t\t\t\t# Pull out the value of this operator.\n\t\t\t\tmy $op_type = substr($curr_values, $off + 1, 1);\n\n\t\t\t\t# Get the full operator variant.\n\t\t\t\tmy $opv = $op . substr($curr_vars, $off, 1);\n\n\t\t\t\t# Ignore operators passed as parameters.\n\t\t\t\tif ($op_type ne 'V' &&\n\t\t\t\t    $ca =~ /\\s$/ && $cc =~ /^\\s*[,\\)]/) {\n\n#\t\t\t\t# Ignore comments\n#\t\t\t\t} elsif ($op =~ /^$;+$/) {\n\n\t\t\t\t# ; should have either the end of line or a space or \\ after it\n\t\t\t\t} elsif ($op eq ';') {\n\t\t\t\t\tif ($ctx !~ /.x[WEBC]/ &&\n\t\t\t\t\t    $cc !~ /^\\\\/ && $cc !~ /^;/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space required after that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = $fix_elements[$n] . trim($fix_elements[$n + 1]) . \" \";\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# // is a comment\n\t\t\t\t} elsif ($op eq '//') {\n\n\t\t\t\t#   :   when part of a bitfield\n\t\t\t\t} elsif ($opv eq ':B') {\n\t\t\t\t\t# skip the bitfield test for now\n\n\t\t\t\t# No spaces for:\n\t\t\t\t#   ->\n\t\t\t\t} elsif ($op eq '->') {\n\t\t\t\t\tif ($ctx =~ /Wx.|.xW/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"spaces prohibited around that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\tif (defined $fix_elements[$n + 2]) {\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# , must not have a space before and must have a space on the right.\n\t\t\t\t} elsif ($op eq ',') {\n\t\t\t\t\tmy $rtrim_before = 0;\n\t\t\t\t\tmy $space_after = 0;\n\t\t\t\t\tif ($ctx =~ /Wx./) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space prohibited before that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t\t$rtrim_before = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($ctx !~ /.x[WEC]/ && $cc !~ /^}/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space required after that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t\t$last_after = $n;\n\t\t\t\t\t\t\t$space_after = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($rtrim_before || $space_after) {\n\t\t\t\t\t\tif ($rtrim_before) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$good = $fix_elements[$n] . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($space_after) {\n\t\t\t\t\t\t\t$good .= \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# '*' as part of a type definition -- reported already.\n\t\t\t\t} elsif ($opv eq '*_') {\n\t\t\t\t\t#warn \"'*' is part of type\\n\";\n\n\t\t\t\t# unary operators should have a space before and\n\t\t\t\t# none after.  May be left adjacent to another\n\t\t\t\t# unary operator, or a cast\n\t\t\t\t} elsif ($op eq '!' || $op eq '~' ||\n\t\t\t\t\t $opv eq '*U' || $opv eq '-U' ||\n\t\t\t\t\t $opv eq '&U' || $opv eq '&&U') {\n\t\t\t\t\tif ($ctx !~ /[WEBC]x./ && $ca !~ /(?:\\)|!|~|\\*|-|\\&|\\||\\+\\+|\\-\\-|\\{)$/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space required before that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\tif ($n != $last_after + 2) {\n\t\t\t\t\t\t\t\t$good = $fix_elements[$n] . \" \" . ltrim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($op eq '*' && $cc =~/\\s*$Modifier\\b/) {\n\t\t\t\t\t\t# A unary '*' may be const\n\n\t\t\t\t\t} elsif ($ctx =~ /.xW/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space prohibited after that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = $fix_elements[$n] . rtrim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\tif (defined $fix_elements[$n + 2]) {\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# unary ++ and unary -- are allowed no space on one side.\n\t\t\t\t} elsif ($op eq '++' or $op eq '--') {\n\t\t\t\t\tif ($ctx !~ /[WEOBC]x[^W]/ && $ctx !~ /[^W]x[WOBEC]/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space required one side of that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = $fix_elements[$n] . trim($fix_elements[$n + 1]) . \" \";\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($ctx =~ /Wx[BE]/ ||\n\t\t\t\t\t    ($ctx =~ /Wx./ && $cc =~ /^;/)) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space prohibited before that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($ctx =~ /ExW/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space prohibited after that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = $fix_elements[$n] . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\tif (defined $fix_elements[$n + 2]) {\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# << and >> may either have or not have spaces both sides\n\t\t\t\t} elsif ($op eq '<<' or $op eq '>>' or\n\t\t\t\t\t $op eq '&' or $op eq '^' or $op eq '|' or\n\t\t\t\t\t $op eq '+' or $op eq '-' or\n\t\t\t\t\t $op eq '*' or $op eq '/' or\n\t\t\t\t\t $op eq '%')\n\t\t\t\t{\n\t\t\t\t\tif ($check) {\n\t\t\t\t\t\tif (defined $fix_elements[$n + 2] && $ctx !~ /[EW]x[EW]/) {\n\t\t\t\t\t\t\tif (CHK(\"SPACING\",\n\t\t\t\t\t\t\t\t\"spaces preferred around that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . \" \" . trim($fix_elements[$n + 1]) . \" \";\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} elsif (!defined $fix_elements[$n + 2] && $ctx !~ /Wx[OE]/) {\n\t\t\t\t\t\t\tif (CHK(\"SPACING\",\n\t\t\t\t\t\t\t\t\"space preferred before that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . \" \" . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} elsif ($ctx =~ /Wx[^WCE]|[^WCE]xW/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"need consistent spacing around '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . \" \" . trim($fix_elements[$n + 1]) . \" \";\n\t\t\t\t\t\t\tif (defined $fix_elements[$n + 2]) {\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# A colon needs no spaces before when it is\n\t\t\t\t# terminating a case value or a label.\n\t\t\t\t} elsif ($opv eq ':C' || $opv eq ':L') {\n\t\t\t\t\tif ($ctx =~ /Wx./ and $realfile !~ m@.*\\.lds\\.h$@) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space prohibited before that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# All the others need spaces both sides.\n\t\t\t\t} elsif ($ctx !~ /[EWC]x[CWE]/) {\n\t\t\t\t\tmy $ok = 0;\n\n\t\t\t\t\t# Ignore email addresses <foo@bar>\n\t\t\t\t\tif (($op eq '<' &&\n\t\t\t\t\t     $cc =~ /^\\S+\\@\\S+>/) ||\n\t\t\t\t\t    ($op eq '>' &&\n\t\t\t\t\t     $ca =~ /<\\S+\\@\\S+$/))\n\t\t\t\t\t{\n\t\t\t\t\t\t$ok = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t# for asm volatile statements\n\t\t\t\t\t# ignore a colon with another\n\t\t\t\t\t# colon immediately before or after\n\t\t\t\t\tif (($op eq ':') &&\n\t\t\t\t\t    ($ca =~ /:$/ || $cc =~ /^:/)) {\n\t\t\t\t\t\t$ok = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t# messages are ERROR, but ?: are CHK\n\t\t\t\t\tif ($ok == 0) {\n\t\t\t\t\t\tmy $msg_level = \\&ERROR;\n\t\t\t\t\t\t$msg_level = \\&CHK if (($op eq '?:' || $op eq '?' || $op eq ':') && $ctx =~ /VxV/);\n\n\t\t\t\t\t\tif (&{$msg_level}(\"SPACING\",\n\t\t\t\t\t\t\t\t  \"spaces required around that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . \" \" . trim($fix_elements[$n + 1]) . \" \";\n\t\t\t\t\t\t\tif (defined $fix_elements[$n + 2]) {\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$off += length($elements[$n + 1]);\n\n##\t\t\t\tprint(\"n: <$n> GOOD: <$good>\\n\");\n\n\t\t\t\t$fixed_line = $fixed_line . $good;\n\t\t\t}\n\n\t\t\tif (($#elements % 2) == 0) {\n\t\t\t\t$fixed_line = $fixed_line . $fix_elements[$#elements];\n\t\t\t}\n\n\t\t\tif ($fix && $line_fixed && $fixed_line ne $fixed[$fixlinenr]) {\n\t\t\t\t$fixed[$fixlinenr] = $fixed_line;\n\t\t\t}\n\n\n\t\t}\n\n# check for whitespace before a non-naked semicolon\n\t\tif ($line =~ /^\\+.*\\S\\s+;\\s*$/) {\n\t\t\tif (WARN(\"SPACING\",\n\t\t\t\t \"space prohibited before semicolon\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t1 while $fixed[$fixlinenr] =~\n\t\t\t\t    s/^(\\+.*\\S)\\s+;/$1;/;\n\t\t\t}\n\t\t}\n\n# check for multiple assignments\n\t\tif ($line =~ /^.\\s*$Lval\\s*=\\s*$Lval\\s*=(?!=)/) {\n\t\t\tCHK(\"MULTIPLE_ASSIGNMENTS\",\n\t\t\t    \"multiple assignments should be avoided\\n\" . $herecurr);\n\t\t}\n\n## # check for multiple declarations, allowing for a function declaration\n## # continuation.\n## \t\tif ($line =~ /^.\\s*$Type\\s+$Ident(?:\\s*=[^,{]*)?\\s*,\\s*$Ident.*/ &&\n## \t\t    $line !~ /^.\\s*$Type\\s+$Ident(?:\\s*=[^,{]*)?\\s*,\\s*$Type\\s*$Ident.*/) {\n##\n## \t\t\t# Remove any bracketed sections to ensure we do not\n## \t\t\t# falsely report the parameters of functions.\n## \t\t\tmy $ln = $line;\n## \t\t\twhile ($ln =~ s/\\([^\\(\\)]*\\)//g) {\n## \t\t\t}\n## \t\t\tif ($ln =~ /,/) {\n## \t\t\t\tWARN(\"MULTIPLE_DECLARATION\",\n##\t\t\t\t     \"declaring multiple variables together should be avoided\\n\" . $herecurr);\n## \t\t\t}\n## \t\t}\n\n#need space before brace following if, while, etc\n\t\tif (($line =~ /\\(.*\\)\\{/ && $line !~ /\\($Type\\)\\{/) ||\n\t\t    $line =~ /\\b(?:else|do)\\{/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space required before the open brace '{'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/^(\\+.*(?:do|else|\\)))\\{/$1 {/;\n\t\t\t}\n\t\t}\n\n## # check for blank lines before declarations\n##\t\tif ($line =~ /^.\\t+$Type\\s+$Ident(?:\\s*=.*)?;/ &&\n##\t\t    $prevrawline =~ /^.\\s*$/) {\n##\t\t\tWARN(\"SPACING\",\n##\t\t\t     \"No blank lines before declarations\\n\" . $hereprev);\n##\t\t}\n##\n\n# closing brace should have a space following it when it has anything\n# on the line\n\t\tif ($line =~ /}(?!(?:,|;|\\)|\\}))\\S/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space required after that close brace '}'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/}((?!(?:,|;|\\)))\\S)/} $1/;\n\t\t\t}\n\t\t}\n\n# check spacing on square brackets\n\t\tif ($line =~ /\\[\\s/ && $line !~ /\\[\\s*$/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space prohibited after that open square bracket '['\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/\\[\\s+/\\[/;\n\t\t\t}\n\t\t}\n\t\tif ($line =~ /\\s\\]/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space prohibited before that close square bracket ']'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/\\s+\\]/\\]/;\n\t\t\t}\n\t\t}\n\n# check spacing on parentheses\n\t\tif ($line =~ /\\(\\s/ && $line !~ /\\(\\s*(?:\\\\)?$/ &&\n\t\t    $line !~ /for\\s*\\(\\s+;/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space prohibited after that open parenthesis '('\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/\\(\\s+/\\(/;\n\t\t\t}\n\t\t}\n\t\tif ($line =~ /(\\s+)\\)/ && $line !~ /^.\\s*\\)/ &&\n\t\t    $line !~ /for\\s*\\(.*;\\s+\\)/ &&\n\t\t    $line !~ /:\\s+\\)/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space prohibited before that close parenthesis ')'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/\\s+\\)/\\)/;\n\t\t\t}\n\t\t}\n\n# check unnecessary parentheses around addressof/dereference single $Lvals\n# ie: &(foo->bar) should be &foo->bar and *(foo->bar) should be *foo->bar\n\n\t\twhile ($line =~ /(?:[^&]&\\s*|\\*)\\(\\s*($Ident\\s*(?:$Member\\s*)+)\\s*\\)/g) {\n\t\t\tmy $var = $1;\n\t\t\tif (CHK(\"UNNECESSARY_PARENTHESES\",\n\t\t\t\t\"Unnecessary parentheses around $var\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\(\\s*\\Q$var\\E\\s*\\)/$var/;\n\t\t\t}\n\t\t}\n\n# check for unnecessary parentheses around function pointer uses\n# ie: (foo->bar)(); should be foo->bar();\n# but not \"if (foo->bar) (\" to avoid some false positives\n\t\tif ($line =~ /(\\bif\\s*|)(\\(\\s*$Ident\\s*(?:$Member\\s*)+\\))[ \\t]*\\(/ && $1 !~ /^if/) {\n\t\t\tmy $var = $2;\n\t\t\tif (CHK(\"UNNECESSARY_PARENTHESES\",\n\t\t\t\t\"Unnecessary parentheses around function pointer $var\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tmy $var2 = deparenthesize($var);\n\t\t\t\t$var2 =~ s/\\s//g;\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$var\\E/$var2/;\n\t\t\t}\n\t\t}\n\n# check for unnecessary parentheses around comparisons in if uses\n# when !drivers/staging or command-line uses --strict\n\t\tif (($realfile !~ m@^(?:drivers/staging/)@ || $check_orig) &&\n\t\t    $perl_version_ok && defined($stat) &&\n\t\t    $stat =~ /(^.\\s*if\\s*($balanced_parens))/) {\n\t\t\tmy $if_stat = $1;\n\t\t\tmy $test = substr($2, 1, -1);\n\t\t\tmy $herectx;\n\t\t\twhile ($test =~ /(?:^|[^\\w\\&\\!\\~])+\\s*\\(\\s*([\\&\\!\\~]?\\s*$Lval\\s*(?:$Compare\\s*$FuncArg)?)\\s*\\)/g) {\n\t\t\t\tmy $match = $1;\n\t\t\t\t# avoid parentheses around potential macro args\n\t\t\t\tnext if ($match =~ /^\\s*\\w+\\s*$/);\n\t\t\t\tif (!defined($herectx)) {\n\t\t\t\t\t$herectx = $here . \"\\n\";\n\t\t\t\t\tmy $cnt = statement_rawlines($if_stat);\n\t\t\t\t\tfor (my $n = 0; $n < $cnt; $n++) {\n\t\t\t\t\t\tmy $rl = raw_line($linenr, $n);\n\t\t\t\t\t\t$herectx .=  $rl . \"\\n\";\n\t\t\t\t\t\tlast if $rl =~ /^[ \\+].*\\{/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCHK(\"UNNECESSARY_PARENTHESES\",\n\t\t\t\t    \"Unnecessary parentheses around '$match'\\n\" . $herectx);\n\t\t\t}\n\t\t}\n\n# check that goto labels aren't indented (allow a single space indentation)\n# and ignore bitfield definitions like foo:1\n# Strictly, labels can have whitespace after the identifier and before the :\n# but this is not allowed here as many ?: uses would appear to be labels\n\t\tif ($sline =~ /^.\\s+[A-Za-z_][A-Za-z\\d_]*:(?!\\s*\\d+)/ &&\n\t\t    $sline !~ /^. [A-Za-z\\d_][A-Za-z\\d_]*:/ &&\n\t\t    $sline !~ /^.\\s+default:/) {\n\t\t\tif (WARN(\"INDENTED_LABEL\",\n\t\t\t\t \"labels should not be indented\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/^(.)\\s+/$1/;\n\t\t\t}\n\t\t}\n\n# check if a statement with a comma should be two statements like:\n#\tfoo = bar(),\t/* comma should be semicolon */\n#\tbar = baz();\n\t\tif (defined($stat) &&\n\t\t    $stat =~ /^\\+\\s*(?:$Lval\\s*$Assignment\\s*)?$FuncArg\\s*,\\s*(?:$Lval\\s*$Assignment\\s*)?$FuncArg\\s*;\\s*$/) {\n\t\t\tmy $cnt = statement_rawlines($stat);\n\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\t\t\tWARN(\"SUSPECT_COMMA_SEMICOLON\",\n\t\t\t     \"Possible comma where semicolon could be used\\n\" . $herectx);\n\t\t}\n\n# return is not a function\n\t\tif (defined($stat) && $stat =~ /^.\\s*return(\\s*)\\(/s) {\n\t\t\tmy $spacing = $1;\n\t\t\tif ($perl_version_ok &&\n\t\t\t    $stat =~ /^.\\s*return\\s*($balanced_parens)\\s*;\\s*$/) {\n\t\t\t\tmy $value = $1;\n\t\t\t\t$value = deparenthesize($value);\n\t\t\t\tif ($value =~ m/^\\s*$FuncArg\\s*(?:\\?|$)/) {\n\t\t\t\t\tERROR(\"RETURN_PARENTHESES\",\n\t\t\t\t\t      \"return is not a function, parentheses are not required\\n\" . $herecurr);\n\t\t\t\t}\n\t\t\t} elsif ($spacing !~ /\\s+/) {\n\t\t\t\tERROR(\"SPACING\",\n\t\t\t\t      \"space required before the open parenthesis '('\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# unnecessary return in a void function\n# at end-of-function, with the previous line a single leading tab, then return;\n# and the line before that not a goto label target like \"out:\"\n\t\tif ($sline =~ /^[ \\+]}\\s*$/ &&\n\t\t    $prevline =~ /^\\+\\treturn\\s*;\\s*$/ &&\n\t\t    $linenr >= 3 &&\n\t\t    $lines[$linenr - 3] =~ /^[ +]/ &&\n\t\t    $lines[$linenr - 3] !~ /^[ +]\\s*$Ident\\s*:/) {\n\t\t\tWARN(\"RETURN_VOID\",\n\t\t\t     \"void function return statements are not generally useful\\n\" . $hereprev);\n\t\t}\n\n# if statements using unnecessary parentheses - ie: if ((foo == bar))\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /\\bif\\s*((?:\\(\\s*){2,})/) {\n\t\t\tmy $openparens = $1;\n\t\t\tmy $count = $openparens =~ tr@\\(@\\(@;\n\t\t\tmy $msg = \"\";\n\t\t\tif ($line =~ /\\bif\\s*(?:\\(\\s*){$count,$count}$LvalOrFunc\\s*($Compare)\\s*$LvalOrFunc(?:\\s*\\)){$count,$count}/) {\n\t\t\t\tmy $comp = $4;\t#Not $1 because of $LvalOrFunc\n\t\t\t\t$msg = \" - maybe == should be = ?\" if ($comp eq \"==\");\n\t\t\t\tWARN(\"UNNECESSARY_PARENTHESES\",\n\t\t\t\t     \"Unnecessary parentheses$msg\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# comparisons with a constant or upper case identifier on the left\n#\tavoid cases like \"foo + BAR < baz\"\n#\tonly fix matches surrounded by parentheses to avoid incorrect\n#\tconversions like \"FOO < baz() + 5\" being \"misfixed\" to \"baz() > FOO + 5\"\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /^\\+(.*)\\b($Constant|[A-Z_][A-Z0-9_]*)\\s*($Compare)\\s*($LvalOrFunc)/) {\n\t\t\tmy $lead = $1;\n\t\t\tmy $const = $2;\n\t\t\tmy $comp = $3;\n\t\t\tmy $to = $4;\n\t\t\tmy $newcomp = $comp;\n\t\t\tif ($lead !~ /(?:$Operators|\\.)\\s*$/ &&\n\t\t\t    $to !~ /^(?:Constant|[A-Z_][A-Z0-9_]*)$/ &&\n\t\t\t    WARN(\"CONSTANT_COMPARISON\",\n\t\t\t\t \"Comparisons should place the constant on the right side of the test\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tif ($comp eq \"<\") {\n\t\t\t\t\t$newcomp = \">\";\n\t\t\t\t} elsif ($comp eq \"<=\") {\n\t\t\t\t\t$newcomp = \">=\";\n\t\t\t\t} elsif ($comp eq \">\") {\n\t\t\t\t\t$newcomp = \"<\";\n\t\t\t\t} elsif ($comp eq \">=\") {\n\t\t\t\t\t$newcomp = \"<=\";\n\t\t\t\t}\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\(\\s*\\Q$const\\E\\s*$Compare\\s*\\Q$to\\E\\s*\\)/($to $newcomp $const)/;\n\t\t\t}\n\t\t}\n\n# Return of what appears to be an errno should normally be negative\n\t\tif ($sline =~ /\\breturn(?:\\s*\\(+\\s*|\\s+)(E[A-Z]+)(?:\\s*\\)+\\s*|\\s*)[;:,]/) {\n\t\t\tmy $name = $1;\n\t\t\tif ($name ne 'EOF' && $name ne 'ERROR' && $name !~ /^EPOLL/) {\n\t\t\t\tWARN(\"USE_NEGATIVE_ERRNO\",\n\t\t\t\t     \"return of an errno should typically be negative (ie: return -$1)\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Need a space before open parenthesis after if, while etc\n\t\tif ($line =~ /\\b(if|while|for|switch)\\(/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space required before the open parenthesis '('\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/\\b(if|while|for|switch)\\(/$1 \\(/;\n\t\t\t}\n\t\t}\n\n# Check for illegal assignment in if conditional -- and check for trailing\n# statements after the conditional.\n\t\tif ($line =~ /do\\s*(?!{)/) {\n\t\t\t($stat, $cond, $line_nr_next, $remain_next, $off_next) =\n\t\t\t\tctx_statement_block($linenr, $realcnt, 0)\n\t\t\t\t\tif (!defined $stat);\n\t\t\tmy ($stat_next) = ctx_statement_block($line_nr_next,\n\t\t\t\t\t\t$remain_next, $off_next);\n\t\t\t$stat_next =~ s/\\n./\\n /g;\n\t\t\t##print \"stat<$stat> stat_next<$stat_next>\\n\";\n\n\t\t\tif ($stat_next =~ /^\\s*while\\b/) {\n\t\t\t\t# If the statement carries leading newlines,\n\t\t\t\t# then count those as offsets.\n\t\t\t\tmy ($whitespace) =\n\t\t\t\t\t($stat_next =~ /^((?:\\s*\\n[+-])*\\s*)/s);\n\t\t\t\tmy $offset =\n\t\t\t\t\tstatement_rawlines($whitespace) - 1;\n\n\t\t\t\t$suppress_whiletrailers{$line_nr_next +\n\t\t\t\t\t\t\t\t$offset} = 1;\n\t\t\t}\n\t\t}\n\t\tif (!defined $suppress_whiletrailers{$linenr} &&\n\t\t    defined($stat) && defined($cond) &&\n\t\t    $line =~ /\\b(?:if|while|for)\\s*\\(/ && $line !~ /^.\\s*#/) {\n\t\t\tmy ($s, $c) = ($stat, $cond);\n\t\t\tmy $fixed_assign_in_if = 0;\n\n\t\t\tif ($c =~ /\\bif\\s*\\(.*[^<>!=]=[^=].*/s) {\n\t\t\t\tif (ERROR(\"ASSIGN_IN_IF\",\n\t\t\t\t\t  \"do not use assignment in if condition\\n\" . $herecurr) &&\n\t\t\t\t    $fix && $perl_version_ok) {\n\t\t\t\t\tif ($rawline =~ /^\\+(\\s+)if\\s*\\(\\s*(\\!)?\\s*\\(\\s*(($Lval)\\s*=\\s*$LvalOrFunc)\\s*\\)\\s*(?:($Compare)\\s*($FuncArg))?\\s*\\)\\s*(\\{)?\\s*$/) {\n\t\t\t\t\t\tmy $space = $1;\n\t\t\t\t\t\tmy $not = $2;\n\t\t\t\t\t\tmy $statement = $3;\n\t\t\t\t\t\tmy $assigned = $4;\n\t\t\t\t\t\tmy $test = $8;\n\t\t\t\t\t\tmy $against = $9;\n\t\t\t\t\t\tmy $brace = $15;\n\t\t\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\t\t\tfix_insert_line($fixlinenr, \"$space$statement;\");\n\t\t\t\t\t\tmy $newline = \"${space}if (\";\n\t\t\t\t\t\t$newline .= '!' if defined($not);\n\t\t\t\t\t\t$newline .= '(' if (defined $not && defined($test) && defined($against));\n\t\t\t\t\t\t$newline .= \"$assigned\";\n\t\t\t\t\t\t$newline .= \" $test $against\" if (defined($test) && defined($against));\n\t\t\t\t\t\t$newline .= ')' if (defined $not && defined($test) && defined($against));\n\t\t\t\t\t\t$newline .= ')';\n\t\t\t\t\t\t$newline .= \" {\" if (defined($brace));\n\t\t\t\t\t\tfix_insert_line($fixlinenr + 1, $newline);\n\t\t\t\t\t\t$fixed_assign_in_if = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# Find out what is on the end of the line after the\n\t\t\t# conditional.\n\t\t\tsubstr($s, 0, length($c), '');\n\t\t\t$s =~ s/\\n.*//g;\n\t\t\t$s =~ s/$;//g;\t# Remove any comments\n\t\t\tif (length($c) && $s !~ /^\\s*{?\\s*\\\\*\\s*$/ &&\n\t\t\t    $c !~ /}\\s*while\\s*/)\n\t\t\t{\n\t\t\t\t# Find out how long the conditional actually is.\n\t\t\t\tmy @newlines = ($c =~ /\\n/gs);\n\t\t\t\tmy $cond_lines = 1 + $#newlines;\n\t\t\t\tmy $stat_real = '';\n\n\t\t\t\t$stat_real = raw_line($linenr, $cond_lines)\n\t\t\t\t\t\t\t. \"\\n\" if ($cond_lines);\n\t\t\t\tif (defined($stat_real) && $cond_lines > 1) {\n\t\t\t\t\t$stat_real = \"[...]\\n$stat_real\";\n\t\t\t\t}\n\n\t\t\t\tif (ERROR(\"TRAILING_STATEMENTS\",\n\t\t\t\t\t  \"trailing statements should be on next line\\n\" . $herecurr . $stat_real) &&\n\t\t\t\t    !$fixed_assign_in_if &&\n\t\t\t\t    $cond_lines == 0 &&\n\t\t\t\t    $fix && $perl_version_ok &&\n\t\t\t\t    $fixed[$fixlinenr] =~ /^\\+(\\s*)((?:if|while|for)\\s*$balanced_parens)\\s*(.*)$/) {\n\t\t\t\t\tmy $indent = $1;\n\t\t\t\t\tmy $test = $2;\n\t\t\t\t\tmy $rest = rtrim($4);\n\t\t\t\t\tif ($rest =~ /;$/) {\n\t\t\t\t\t\t$fixed[$fixlinenr] = \"\\+$indent$test\";\n\t\t\t\t\t\tfix_insert_line($fixlinenr + 1, \"$indent\\t$rest\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check for bitwise tests written as boolean\n\t\tif ($line =~ /\n\t\t\t(?:\n\t\t\t\t(?:\\[|\\(|\\&\\&|\\|\\|)\n\t\t\t\t\\s*0[xX][0-9]+\\s*\n\t\t\t\t(?:\\&\\&|\\|\\|)\n\t\t\t|\n\t\t\t\t(?:\\&\\&|\\|\\|)\n\t\t\t\t\\s*0[xX][0-9]+\\s*\n\t\t\t\t(?:\\&\\&|\\|\\||\\)|\\])\n\t\t\t)/x)\n\t\t{\n\t\t\tWARN(\"HEXADECIMAL_BOOLEAN_TEST\",\n\t\t\t     \"boolean test with hexadecimal, perhaps just 1 \\& or \\|?\\n\" . $herecurr);\n\t\t}\n\n# if and else should not have general statements after it\n\t\tif ($line =~ /^.\\s*(?:}\\s*)?else\\b(.*)/) {\n\t\t\tmy $s = $1;\n\t\t\t$s =~ s/$;//g;\t# Remove any comments\n\t\t\tif ($s !~ /^\\s*(?:\\sif|(?:{|)\\s*\\\\?\\s*$)/) {\n\t\t\t\tERROR(\"TRAILING_STATEMENTS\",\n\t\t\t\t      \"trailing statements should be on next line\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n# if should not continue a brace\n\t\tif ($line =~ /}\\s*if\\b/) {\n\t\t\tERROR(\"TRAILING_STATEMENTS\",\n\t\t\t      \"trailing statements should be on next line (or did you mean 'else if'?)\\n\" .\n\t\t\t\t$herecurr);\n\t\t}\n# case and default should not have general statements after them\n\t\tif ($line =~ /^.\\s*(?:case\\s*.*|default\\s*):/g &&\n\t\t    $line !~ /\\G(?:\n\t\t\t(?:\\s*$;*)(?:\\s*{)?(?:\\s*$;*)(?:\\s*\\\\)?\\s*$|\n\t\t\t\\s*return\\s+\n\t\t    )/xg)\n\t\t{\n\t\t\tERROR(\"TRAILING_STATEMENTS\",\n\t\t\t      \"trailing statements should be on next line\\n\" . $herecurr);\n\t\t}\n\n\t\t# Check for }<nl>else {, these must be at the same\n\t\t# indent level to be relevant to each other.\n\t\tif ($prevline=~/}\\s*$/ and $line=~/^.\\s*else\\s*/ &&\n\t\t    $previndent == $indent) {\n\t\t\tif (ERROR(\"ELSE_AFTER_BRACE\",\n\t\t\t\t  \"else should follow close brace '}'\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevline =~ /^\\+/ && $line =~ /^\\+/) {\n\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\tmy $fixedline = $prevrawline;\n\t\t\t\t$fixedline =~ s/}\\s*$//;\n\t\t\t\tif ($fixedline !~ /^\\+\\s*$/) {\n\t\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t}\n\t\t\t\t$fixedline = $rawline;\n\t\t\t\t$fixedline =~ s/^(.\\s*)else/$1} else/;\n\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t}\n\t\t}\n\n\t\tif ($prevline=~/}\\s*$/ and $line=~/^.\\s*while\\s*/ &&\n\t\t    $previndent == $indent) {\n\t\t\tmy ($s, $c) = ctx_statement_block($linenr, $realcnt, 0);\n\n\t\t\t# Find out what is on the end of the line after the\n\t\t\t# conditional.\n\t\t\tsubstr($s, 0, length($c), '');\n\t\t\t$s =~ s/\\n.*//g;\n\n\t\t\tif ($s =~ /^\\s*;/) {\n\t\t\t\tif (ERROR(\"WHILE_AFTER_BRACE\",\n\t\t\t\t\t  \"while should follow close brace '}'\\n\" . $hereprev) &&\n\t\t\t\t    $fix && $prevline =~ /^\\+/ && $line =~ /^\\+/) {\n\t\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\t\tmy $fixedline = $prevrawline;\n\t\t\t\t\tmy $trailing = $rawline;\n\t\t\t\t\t$trailing =~ s/^\\+//;\n\t\t\t\t\t$trailing = trim($trailing);\n\t\t\t\t\t$fixedline =~ s/}\\s*$/} $trailing/;\n\t\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#Specific variable tests\n\t\twhile ($line =~ m{($Constant|$Lval)}g) {\n\t\t\tmy $var = $1;\n\n#CamelCase\n\t\t\tif ($var !~ /^$Constant$/ &&\n\t\t\t    $var =~ /[A-Z][a-z]|[a-z][A-Z]/ &&\n#Ignore some autogenerated defines and enum values\n\t\t\t    $var !~ /^(?:[A-Z]+_){1,5}[A-Z]{1,3}[a-z]/ &&\n#Ignore Page<foo> variants\n\t\t\t    $var !~ /^(?:Clear|Set|TestClear|TestSet|)Page[A-Z]/ &&\n#Ignore ETHTOOL_LINK_MODE_<foo> variants\n\t\t\t    $var !~ /^ETHTOOL_LINK_MODE_/ &&\n#Ignore SI style variants like nS, mV and dB\n#(ie: max_uV, regulator_min_uA_show, RANGE_mA_VALUE)\n\t\t\t    $var !~ /^(?:[a-z0-9_]*|[A-Z0-9_]*)?_?[a-z][A-Z](?:_[a-z0-9_]+|_[A-Z0-9_]+)?$/ &&\n#Ignore some three character SI units explicitly, like MiB and KHz\n\t\t\t    $var !~ /^(?:[a-z_]*?)_?(?:[KMGT]iB|[KMGT]?Hz)(?:_[a-z_]+)?$/) {\n\t\t\t\twhile ($var =~ m{\\b($Ident)}g) {\n\t\t\t\t\tmy $word = $1;\n\t\t\t\t\tnext if ($word !~ /[A-Z][a-z]|[a-z][A-Z]/);\n\t\t\t\t\tif ($check) {\n\t\t\t\t\t\tseed_camelcase_includes();\n\t\t\t\t\t\tif (!$file && !$camelcase_file_seeded) {\n\t\t\t\t\t\t\tseed_camelcase_file($realfile);\n\t\t\t\t\t\t\t$camelcase_file_seeded = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!defined $camelcase{$word}) {\n\t\t\t\t\t\t$camelcase{$word} = 1;\n\t\t\t\t\t\tCHK(\"CAMELCASE\",\n\t\t\t\t\t\t    \"Avoid CamelCase: <$word>\\n\" . $herecurr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#no spaces allowed after \\ in define\n\t\tif ($line =~ /\\#\\s*define.*\\\\\\s+$/) {\n\t\t\tif (WARN(\"WHITESPACE_AFTER_LINE_CONTINUATION\",\n\t\t\t\t \"Whitespace after \\\\ makes next lines useless\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\s+$//;\n\t\t\t}\n\t\t}\n\n# warn if <asm/foo.h> is #included and <linux/foo.h> is available and includes\n# itself <asm/foo.h> (uses RAW line)\n\t\tif ($tree && $rawline =~ m{^.\\s*\\#\\s*include\\s*\\<asm\\/(.*)\\.h\\>}) {\n\t\t\tmy $file = \"$1.h\";\n\t\t\tmy $checkfile = \"include/linux/$file\";\n\t\t\tif (-f \"$root/$checkfile\" &&\n\t\t\t    $realfile ne $checkfile &&\n\t\t\t    $1 !~ /$allowed_asm_includes/)\n\t\t\t{\n\t\t\t\tmy $asminclude = `grep -Ec \"#include\\\\s+<asm/$file>\" $root/$checkfile`;\n\t\t\t\tif ($asminclude > 0) {\n\t\t\t\t\tif ($realfile =~ m{^arch/}) {\n\t\t\t\t\t\tCHK(\"ARCH_INCLUDE_LINUX\",\n\t\t\t\t\t\t    \"Consider using #include <linux/$file> instead of <asm/$file>\\n\" . $herecurr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tWARN(\"INCLUDE_LINUX\",\n\t\t\t\t\t\t     \"Use #include <linux/$file> instead of <asm/$file>\\n\" . $herecurr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# multi-statement macros should be enclosed in a do while loop, grab the\n# first statement and ensure its the whole macro if its not enclosed\n# in a known good container\n\t\tif ($realfile !~ m@/vmlinux.lds.h$@ &&\n\t\t    $line =~ /^.\\s*\\#\\s*define\\s*$Ident(\\()?/) {\n\t\t\tmy $ln = $linenr;\n\t\t\tmy $cnt = $realcnt;\n\t\t\tmy ($off, $dstat, $dcond, $rest);\n\t\t\tmy $ctx = '';\n\t\t\tmy $has_flow_statement = 0;\n\t\t\tmy $has_arg_concat = 0;\n\t\t\t($dstat, $dcond, $ln, $cnt, $off) =\n\t\t\t\tctx_statement_block($linenr, $realcnt, 0);\n\t\t\t$ctx = $dstat;\n\t\t\t#print \"dstat<$dstat> dcond<$dcond> cnt<$cnt> off<$off>\\n\";\n\t\t\t#print \"LINE<$lines[$ln-1]> len<\" . length($lines[$ln-1]) . \"\\n\";\n\n\t\t\t$has_flow_statement = 1 if ($ctx =~ /\\b(goto|return)\\b/);\n\t\t\t$has_arg_concat = 1 if ($ctx =~ /\\#\\#/ && $ctx !~ /\\#\\#\\s*(?:__VA_ARGS__|args)\\b/);\n\n\t\t\t$dstat =~ s/^.\\s*\\#\\s*define\\s+$Ident(\\([^\\)]*\\))?\\s*//;\n\t\t\tmy $define_args = $1;\n\t\t\tmy $define_stmt = $dstat;\n\t\t\tmy @def_args = ();\n\n\t\t\tif (defined $define_args && $define_args ne \"\") {\n\t\t\t\t$define_args = substr($define_args, 1, length($define_args) - 2);\n\t\t\t\t$define_args =~ s/\\s*//g;\n\t\t\t\t$define_args =~ s/\\\\\\+?//g;\n\t\t\t\t@def_args = split(\",\", $define_args);\n\t\t\t}\n\n\t\t\t$dstat =~ s/$;//g;\n\t\t\t$dstat =~ s/\\\\\\n.//g;\n\t\t\t$dstat =~ s/^\\s*//s;\n\t\t\t$dstat =~ s/\\s*$//s;\n\n\t\t\t# Flatten any parentheses and braces\n\t\t\twhile ($dstat =~ s/\\([^\\(\\)]*\\)/1u/ ||\n\t\t\t       $dstat =~ s/\\{[^\\{\\}]*\\}/1u/ ||\n\t\t\t       $dstat =~ s/.\\[[^\\[\\]]*\\]/1u/)\n\t\t\t{\n\t\t\t}\n\n\t\t\t# Flatten any obvious string concatenation.\n\t\t\twhile ($dstat =~ s/($String)\\s*$Ident/$1/ ||\n\t\t\t       $dstat =~ s/$Ident\\s*($String)/$1/)\n\t\t\t{\n\t\t\t}\n\n\t\t\t# Make asm volatile uses seem like a generic function\n\t\t\t$dstat =~ s/\\b_*asm_*\\s+_*volatile_*\\b/asm_volatile/g;\n\n\t\t\tmy $exceptions = qr{\n\t\t\t\t$Declare|\n\t\t\t\tmodule_param_named|\n\t\t\t\tMODULE_PARM_DESC|\n\t\t\t\tDECLARE_PER_CPU|\n\t\t\t\tDEFINE_PER_CPU|\n\t\t\t\t__typeof__\\(|\n\t\t\t\tunion|\n\t\t\t\tstruct|\n\t\t\t\t\\.$Ident\\s*=\\s*|\n\t\t\t\t^\\\"|\\\"$|\n\t\t\t\t^\\[\n\t\t\t}x;\n\t\t\t#print \"REST<$rest> dstat<$dstat> ctx<$ctx>\\n\";\n\n\t\t\t$ctx =~ s/\\n*$//;\n\t\t\tmy $stmt_cnt = statement_rawlines($ctx);\n\t\t\tmy $herectx = get_stat_here($linenr, $stmt_cnt, $here);\n\n\t\t\tif ($dstat ne '' &&\n\t\t\t    $dstat !~ /^(?:$Ident|-?$Constant),$/ &&\t\t\t# 10, // foo(),\n\t\t\t    $dstat !~ /^(?:$Ident|-?$Constant);$/ &&\t\t\t# foo();\n\t\t\t    $dstat !~ /^[!~-]?(?:$Lval|$Constant)$/ &&\t\t# 10 // foo() // !foo // ~foo // -foo // foo->bar // foo.bar->baz\n\t\t\t    $dstat !~ /^'X'$/ && $dstat !~ /^'XX'$/ &&\t\t\t# character constants\n\t\t\t    $dstat !~ /$exceptions/ &&\n\t\t\t    $dstat !~ /^\\.$Ident\\s*=/ &&\t\t\t\t# .foo =\n\t\t\t    $dstat !~ /^(?:\\#\\s*$Ident|\\#\\s*$Constant)\\s*$/ &&\t\t# stringification #foo\n\t\t\t    $dstat !~ /^case\\b/ &&\t\t\t\t\t# case ...\n\t\t\t    $dstat !~ /^do\\s*$Constant\\s*while\\s*$Constant;?$/ &&\t# do {...} while (...); // do {...} while (...)\n\t\t\t    $dstat !~ /^while\\s*$Constant\\s*$Constant\\s*$/ &&\t\t# while (...) {...}\n\t\t\t    $dstat !~ /^for\\s*$Constant$/ &&\t\t\t\t# for (...)\n\t\t\t    $dstat !~ /^for\\s*$Constant\\s+(?:$Ident|-?$Constant)$/ &&\t# for (...) bar()\n\t\t\t    $dstat !~ /^do\\s*{/ &&\t\t\t\t\t# do {...\n\t\t\t    $dstat !~ /^\\(\\{/ &&\t\t\t\t\t\t# ({...\n\t\t\t    $ctx !~ /^.\\s*#\\s*define\\s+TRACE_(?:SYSTEM|INCLUDE_FILE|INCLUDE_PATH)\\b/)\n\t\t\t{\n\t\t\t\tif ($dstat =~ /^\\s*if\\b/) {\n\t\t\t\t\tERROR(\"MULTISTATEMENT_MACRO_USE_DO_WHILE\",\n\t\t\t\t\t      \"Macros starting with if should be enclosed by a do - while loop to avoid possible if/else logic defects\\n\" . \"$herectx\");\n\t\t\t\t} elsif ($dstat =~ /;/) {\n\t\t\t\t\tERROR(\"MULTISTATEMENT_MACRO_USE_DO_WHILE\",\n\t\t\t\t\t      \"Macros with multiple statements should be enclosed in a do - while loop\\n\" . \"$herectx\");\n\t\t\t\t} else {\n\t\t\t\t\tERROR(\"COMPLEX_MACRO\",\n\t\t\t\t\t      \"Macros with complex values should be enclosed in parentheses\\n\" . \"$herectx\");\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t# Make $define_stmt single line, comment-free, etc\n\t\t\tmy @stmt_array = split('\\n', $define_stmt);\n\t\t\tmy $first = 1;\n\t\t\t$define_stmt = \"\";\n\t\t\tforeach my $l (@stmt_array) {\n\t\t\t\t$l =~ s/\\\\$//;\n\t\t\t\tif ($first) {\n\t\t\t\t\t$define_stmt = $l;\n\t\t\t\t\t$first = 0;\n\t\t\t\t} elsif ($l =~ /^[\\+ ]/) {\n\t\t\t\t\t$define_stmt .= substr($l, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$define_stmt =~ s/$;//g;\n\t\t\t$define_stmt =~ s/\\s+/ /g;\n\t\t\t$define_stmt = trim($define_stmt);\n\n# check if any macro arguments are reused (ignore '...' and 'type')\n\t\t\tforeach my $arg (@def_args) {\n\t\t\t        next if ($arg =~ /\\.\\.\\./);\n\t\t\t        next if ($arg =~ /^type$/i);\n\t\t\t\tmy $tmp_stmt = $define_stmt;\n\t\t\t\t$tmp_stmt =~ s/\\b(__must_be_array|offsetof|sizeof|sizeof_field|__stringify|typeof|__typeof__|__builtin\\w+|typecheck\\s*\\(\\s*$Type\\s*,|\\#+)\\s*\\(*\\s*$arg\\s*\\)*\\b//g;\n\t\t\t\t$tmp_stmt =~ s/\\#+\\s*$arg\\b//g;\n\t\t\t\t$tmp_stmt =~ s/\\b$arg\\s*\\#\\#//g;\n\t\t\t\tmy $use_cnt = () = $tmp_stmt =~ /\\b$arg\\b/g;\n\t\t\t\tif ($use_cnt > 1) {\n\t\t\t\t\tCHK(\"MACRO_ARG_REUSE\",\n\t\t\t\t\t    \"Macro argument reuse '$arg' - possible side-effects?\\n\" . \"$herectx\");\n\t\t\t\t    }\n# check if any macro arguments may have other precedence issues\n\t\t\t\tif ($tmp_stmt =~ m/($Operators)?\\s*\\b$arg\\b\\s*($Operators)?/m &&\n\t\t\t\t    ((defined($1) && $1 ne ',') ||\n\t\t\t\t     (defined($2) && $2 ne ','))) {\n\t\t\t\t\tCHK(\"MACRO_ARG_PRECEDENCE\",\n\t\t\t\t\t    \"Macro argument '$arg' may be better as '($arg)' to avoid precedence issues\\n\" . \"$herectx\");\n\t\t\t\t}\n\t\t\t}\n\n# check for macros with flow control, but without ## concatenation\n# ## concatenation is commonly a macro that defines a function so ignore those\n\t\t\tif ($has_flow_statement && !$has_arg_concat) {\n\t\t\t\tmy $cnt = statement_rawlines($ctx);\n\t\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\t\tWARN(\"MACRO_WITH_FLOW_CONTROL\",\n\t\t\t\t     \"Macros with flow control statements should be avoided\\n\" . \"$herectx\");\n\t\t\t}\n\n# check for line continuations outside of #defines, preprocessor #, and asm\n\n\t\t} elsif ($realfile =~ m@/vmlinux.lds.h$@) {\n\t\t    $line =~ s/(\\w+)/$maybe_linker_symbol{$1}++/ge;\n\t\t    #print \"REAL: $realfile\\nln: $line\\nkeys:\", sort keys %maybe_linker_symbol;\n\t\t} else {\n\t\t\tif ($prevline !~ /^..*\\\\$/ &&\n\t\t\t    $line !~ /^\\+\\s*\\#.*\\\\$/ &&\t\t# preprocessor\n\t\t\t    $line !~ /^\\+.*\\b(__asm__|asm)\\b.*\\\\$/ &&\t# asm\n\t\t\t    $line =~ /^\\+.*\\\\$/) {\n\t\t\t\tWARN(\"LINE_CONTINUATIONS\",\n\t\t\t\t     \"Avoid unnecessary line continuations\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# do {} while (0) macro tests:\n# single-statement macros do not need to be enclosed in do while (0) loop,\n# macro should not end with a semicolon\n\t\tif ($perl_version_ok &&\n\t\t    $realfile !~ m@/vmlinux.lds.h$@ &&\n\t\t    $line =~ /^.\\s*\\#\\s*define\\s+$Ident(\\()?/) {\n\t\t\tmy $ln = $linenr;\n\t\t\tmy $cnt = $realcnt;\n\t\t\tmy ($off, $dstat, $dcond, $rest);\n\t\t\tmy $ctx = '';\n\t\t\t($dstat, $dcond, $ln, $cnt, $off) =\n\t\t\t\tctx_statement_block($linenr, $realcnt, 0);\n\t\t\t$ctx = $dstat;\n\n\t\t\t$dstat =~ s/\\\\\\n.//g;\n\t\t\t$dstat =~ s/$;/ /g;\n\n\t\t\tif ($dstat =~ /^\\+\\s*#\\s*define\\s+$Ident\\s*${balanced_parens}\\s*do\\s*{(.*)\\s*}\\s*while\\s*\\(\\s*0\\s*\\)\\s*([;\\s]*)\\s*$/) {\n\t\t\t\tmy $stmts = $2;\n\t\t\t\tmy $semis = $3;\n\n\t\t\t\t$ctx =~ s/\\n*$//;\n\t\t\t\tmy $cnt = statement_rawlines($ctx);\n\t\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\t\tif (($stmts =~ tr/;/;/) == 1 &&\n\t\t\t\t    $stmts !~ /^\\s*(if|while|for|switch)\\b/) {\n\t\t\t\t\tWARN(\"SINGLE_STATEMENT_DO_WHILE_MACRO\",\n\t\t\t\t\t     \"Single statement macros should not use a do {} while (0) loop\\n\" . \"$herectx\");\n\t\t\t\t}\n\t\t\t\tif (defined $semis && $semis ne \"\") {\n\t\t\t\t\tWARN(\"DO_WHILE_MACRO_WITH_TRAILING_SEMICOLON\",\n\t\t\t\t\t     \"do {} while (0) macros should not be semicolon terminated\\n\" . \"$herectx\");\n\t\t\t\t}\n\t\t\t} elsif ($dstat =~ /^\\+\\s*#\\s*define\\s+$Ident.*;\\s*$/) {\n\t\t\t\t$ctx =~ s/\\n*$//;\n\t\t\t\tmy $cnt = statement_rawlines($ctx);\n\t\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\t\tWARN(\"TRAILING_SEMICOLON\",\n\t\t\t\t     \"macros should not use a trailing semicolon\\n\" . \"$herectx\");\n\t\t\t}\n\t\t}\n\n# check for redundant bracing round if etc\n\t\tif ($line =~ /(^.*)\\bif\\b/ && $1 !~ /else\\s*$/) {\n\t\t\tmy ($level, $endln, @chunks) =\n\t\t\t\tctx_statement_full($linenr, $realcnt, 1);\n\t\t\t#print \"chunks<$#chunks> linenr<$linenr> endln<$endln> level<$level>\\n\";\n\t\t\t#print \"APW: <<$chunks[1][0]>><<$chunks[1][1]>>\\n\";\n\t\t\tif ($#chunks > 0 && $level == 0) {\n\t\t\t\tmy @allowed = ();\n\t\t\t\tmy $allow = 0;\n\t\t\t\tmy $seen = 0;\n\t\t\t\tmy $herectx = $here . \"\\n\";\n\t\t\t\tmy $ln = $linenr - 1;\n\t\t\t\tfor my $chunk (@chunks) {\n\t\t\t\t\tmy ($cond, $block) = @{$chunk};\n\n\t\t\t\t\t# If the condition carries leading newlines, then count those as offsets.\n\t\t\t\t\tmy ($whitespace) = ($cond =~ /^((?:\\s*\\n[+-])*\\s*)/s);\n\t\t\t\t\tmy $offset = statement_rawlines($whitespace) - 1;\n\n\t\t\t\t\t$allowed[$allow] = 0;\n\t\t\t\t\t#print \"COND<$cond> whitespace<$whitespace> offset<$offset>\\n\";\n\n\t\t\t\t\t# We have looked at and allowed this specific line.\n\t\t\t\t\t$suppress_ifbraces{$ln + $offset} = 1;\n\n\t\t\t\t\t$herectx .= \"$rawlines[$ln + $offset]\\n[...]\\n\";\n\t\t\t\t\t$ln += statement_rawlines($block) - 1;\n\n\t\t\t\t\tsubstr($block, 0, length($cond), '');\n\n\t\t\t\t\t$seen++ if ($block =~ /^\\s*{/);\n\n\t\t\t\t\t#print \"cond<$cond> block<$block> allowed<$allowed[$allow]>\\n\";\n\t\t\t\t\tif (statement_lines($cond) > 1) {\n\t\t\t\t\t\t#print \"APW: ALLOWED: cond<$cond>\\n\";\n\t\t\t\t\t\t$allowed[$allow] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif ($block =~/\\b(?:if|for|while)\\b/) {\n\t\t\t\t\t\t#print \"APW: ALLOWED: block<$block>\\n\";\n\t\t\t\t\t\t$allowed[$allow] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (statement_block_size($block) > 1) {\n\t\t\t\t\t\t#print \"APW: ALLOWED: lines block<$block>\\n\";\n\t\t\t\t\t\t$allowed[$allow] = 1;\n\t\t\t\t\t}\n\t\t\t\t\t$allow++;\n\t\t\t\t}\n\t\t\t\tif ($seen) {\n\t\t\t\t\tmy $sum_allowed = 0;\n\t\t\t\t\tforeach (@allowed) {\n\t\t\t\t\t\t$sum_allowed += $_;\n\t\t\t\t\t}\n\t\t\t\t\tif ($sum_allowed == 0) {\n\t\t\t\t\t\tWARN(\"BRACES\",\n\t\t\t\t\t\t     \"braces {} are not necessary for any arm of this statement\\n\" . $herectx);\n\t\t\t\t\t} elsif ($sum_allowed != $allow &&\n\t\t\t\t\t\t $seen != $allow) {\n\t\t\t\t\t\tCHK(\"BRACES\",\n\t\t\t\t\t\t    \"braces {} should be used on all arms of this statement\\n\" . $herectx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!defined $suppress_ifbraces{$linenr - 1} &&\n\t\t\t\t\t$line =~ /\\b(if|while|for|else)\\b/) {\n\t\t\tmy $allowed = 0;\n\n\t\t\t# Check the pre-context.\n\t\t\tif (substr($line, 0, $-[0]) =~ /(\\}\\s*)$/) {\n\t\t\t\t#print \"APW: ALLOWED: pre<$1>\\n\";\n\t\t\t\t$allowed = 1;\n\t\t\t}\n\n\t\t\tmy ($level, $endln, @chunks) =\n\t\t\t\tctx_statement_full($linenr, $realcnt, $-[0]);\n\n\t\t\t# Check the condition.\n\t\t\tmy ($cond, $block) = @{$chunks[0]};\n\t\t\t#print \"CHECKING<$linenr> cond<$cond> block<$block>\\n\";\n\t\t\tif (defined $cond) {\n\t\t\t\tsubstr($block, 0, length($cond), '');\n\t\t\t}\n\t\t\tif (statement_lines($cond) > 1) {\n\t\t\t\t#print \"APW: ALLOWED: cond<$cond>\\n\";\n\t\t\t\t$allowed = 1;\n\t\t\t}\n\t\t\tif ($block =~/\\b(?:if|for|while)\\b/) {\n\t\t\t\t#print \"APW: ALLOWED: block<$block>\\n\";\n\t\t\t\t$allowed = 1;\n\t\t\t}\n\t\t\tif (statement_block_size($block) > 1) {\n\t\t\t\t#print \"APW: ALLOWED: lines block<$block>\\n\";\n\t\t\t\t$allowed = 1;\n\t\t\t}\n\t\t\t# Check the post-context.\n\t\t\tif (defined $chunks[1]) {\n\t\t\t\tmy ($cond, $block) = @{$chunks[1]};\n\t\t\t\tif (defined $cond) {\n\t\t\t\t\tsubstr($block, 0, length($cond), '');\n\t\t\t\t}\n\t\t\t\tif ($block =~ /^\\s*\\{/) {\n\t\t\t\t\t#print \"APW: ALLOWED: chunk-1 block<$block>\\n\";\n\t\t\t\t\t$allowed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($level == 0 && $block =~ /^\\s*\\{/ && !$allowed) {\n\t\t\t\tmy $cnt = statement_rawlines($block);\n\t\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\t\tWARN(\"BRACES\",\n\t\t\t\t     \"braces {} are not necessary for single statement blocks\\n\" . $herectx);\n\t\t\t}\n\t\t}\n\n# check for single line unbalanced braces\n\t\tif ($sline =~ /^.\\s*\\}\\s*else\\s*$/ ||\n\t\t    $sline =~ /^.\\s*else\\s*\\{\\s*$/) {\n\t\t\tCHK(\"BRACES\", \"Unbalanced braces around else statement\\n\" . $herecurr);\n\t\t}\n\n# check for unnecessary blank lines around braces\n\t\tif (($line =~ /^.\\s*}\\s*$/ && $prevrawline =~ /^.\\s*$/)) {\n\t\t\tif (CHK(\"BRACES\",\n\t\t\t\t\"Blank lines aren't necessary before a close brace '}'\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevrawline =~ /^\\+/) {\n\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t}\n\t\t}\n\t\tif (($rawline =~ /^.\\s*$/ && $prevline =~ /^..*{\\s*$/)) {\n\t\t\tif (CHK(\"BRACES\",\n\t\t\t\t\"Blank lines aren't necessary after an open brace '{'\\n\" . $hereprev) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t}\n\t\t}\n\n# no volatiles please\n\t\tmy $asm_volatile = qr{\\b(__asm__|asm)\\s+(__volatile__|volatile)\\b};\n\t\tif ($line =~ /\\bvolatile\\b/ && $line !~ /$asm_volatile/) {\n\t\t\tWARN(\"VOLATILE\",\n\t\t\t     \"Use of volatile is usually wrong: see Documentation/process/volatile-considered-harmful.rst\\n\" . $herecurr);\n\t\t}\n\n# Check for user-visible strings broken across lines, which breaks the ability\n# to grep for the string.  Make exceptions when the previous string ends in a\n# newline (multiple lines in one string constant) or '\\t', '\\r', ';', or '{'\n# (common in inline assembly) or is a octal \\123 or hexadecimal \\xaf value\n\t\tif ($line =~ /^\\+\\s*$String/ &&\n\t\t    $prevline =~ /\"\\s*$/ &&\n\t\t    $prevrawline !~ /(?:\\\\(?:[ntr]|[0-7]{1,3}|x[0-9a-fA-F]{1,2})|;\\s*|\\{\\s*)\"\\s*$/) {\n\t\t\tif (WARN(\"SPLIT_STRING\",\n\t\t\t\t \"quoted string split across lines\\n\" . $hereprev) &&\n\t\t\t\t     $fix &&\n\t\t\t\t     $prevrawline =~ /^\\+.*\"\\s*$/ &&\n\t\t\t\t     $last_coalesced_string_linenr != $linenr - 1) {\n\t\t\t\tmy $extracted_string = get_quoted_string($line, $rawline);\n\t\t\t\tmy $comma_close = \"\";\n\t\t\t\tif ($rawline =~ /\\Q$extracted_string\\E(\\s*\\)\\s*;\\s*$|\\s*,\\s*)/) {\n\t\t\t\t\t$comma_close = $1;\n\t\t\t\t}\n\n\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\tmy $fixedline = $prevrawline;\n\t\t\t\t$fixedline =~ s/\"\\s*$//;\n\t\t\t\t$fixedline .= substr($extracted_string, 1) . trim($comma_close);\n\t\t\t\tfix_insert_line($fixlinenr - 1, $fixedline);\n\t\t\t\t$fixedline = $rawline;\n\t\t\t\t$fixedline =~ s/\\Q$extracted_string\\E\\Q$comma_close\\E//;\n\t\t\t\tif ($fixedline !~ /\\+\\s*$/) {\n\t\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t}\n\t\t\t\t$last_coalesced_string_linenr = $linenr;\n\t\t\t}\n\t\t}\n\n# check for missing a space in a string concatenation\n\t\tif ($prevrawline =~ /[^\\\\]\\w\"$/ && $rawline =~ /^\\+[\\t ]+\"\\w/) {\n\t\t\tWARN('MISSING_SPACE',\n\t\t\t     \"break quoted strings at a space character\\n\" . $hereprev);\n\t\t}\n\n# check for an embedded function name in a string when the function is known\n# This does not work very well for -f --file checking as it depends on patch\n# context providing the function name or a single line form for in-file\n# function declarations\n\t\tif ($line =~ /^\\+.*$String/ &&\n\t\t    defined($context_function) &&\n\t\t    get_quoted_string($line, $rawline) =~ /\\b$context_function\\b/ &&\n\t\t    length(get_quoted_string($line, $rawline)) != (length($context_function) + 2)) {\n\t\t\tWARN(\"EMBEDDED_FUNCTION_NAME\",\n\t\t\t     \"Prefer using '\\\"%s...\\\", __func__' to using '$context_function', this function's name, in a string\\n\" . $herecurr);\n\t\t}\n\n# check for unnecessary function tracing like uses\n# This does not use $logFunctions because there are many instances like\n# 'dprintk(FOO, \"%s()\\n\", __func__);' which do not match $logFunctions\n\t\tif ($rawline =~ /^\\+.*\\([^\"]*\"$tracing_logging_tags{0,3}%s(?:\\s*\\(\\s*\\)\\s*)?$tracing_logging_tags{0,3}(?:\\\\n)?\"\\s*,\\s*__func__\\s*\\)\\s*;/) {\n\t\t\tif (WARN(\"TRACING_LOGGING\",\n\t\t\t\t \"Unnecessary ftrace-like logging - prefer using ftrace\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n                                fix_delete_line($fixlinenr, $rawline);\n\t\t\t}\n\t\t}\n\n# check for spaces before a quoted newline\n\t\tif ($rawline =~ /^.*\\\".*\\s\\\\n/) {\n\t\t\tif (WARN(\"QUOTED_WHITESPACE_BEFORE_NEWLINE\",\n\t\t\t\t \"unnecessary whitespace before a quoted newline\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/^(\\+.*\\\".*)\\s+\\\\n/$1\\\\n/;\n\t\t\t}\n\n\t\t}\n\n# concatenated string without spaces between elements\n\t\tif ($line =~ /$String[A-Z_]/ ||\n\t\t    ($line =~ /([A-Za-z0-9_]+)$String/ && $1 !~ /^[Lu]$/)) {\n\t\t\tif (CHK(\"CONCATENATED_STRING\",\n\t\t\t\t\"Concatenated strings should use spaces between elements\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\twhile ($line =~ /($String)/g) {\n\t\t\t\t\tmy $extracted_string = substr($rawline, $-[0], $+[0] - $-[0]);\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$extracted_string\\E([A-Za-z0-9_])/$extracted_string $1/;\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/([A-Za-z0-9_])\\Q$extracted_string\\E/$1 $extracted_string/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# uncoalesced string fragments\n\t\tif ($line =~ /$String\\s*[Lu]?\"/) {\n\t\t\tif (WARN(\"STRING_FRAGMENTS\",\n\t\t\t\t \"Consecutive strings are generally better as a single string\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\twhile ($line =~ /($String)(?=\\s*\")/g) {\n\t\t\t\t\tmy $extracted_string = substr($rawline, $-[0], $+[0] - $-[0]);\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$extracted_string\\E\\s*\"/substr($extracted_string, 0, -1)/e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for non-standard and hex prefixed decimal printf formats\n\t\tmy $show_L = 1;\t#don't show the same defect twice\n\t\tmy $show_Z = 1;\n\t\twhile ($line =~ /(?:^|\")([X\\t]*)(?:\"|$)/g) {\n\t\t\tmy $string = substr($rawline, $-[1], $+[1] - $-[1]);\n\t\t\t$string =~ s/%%/__/g;\n\t\t\t# check for %L\n\t\t\tif ($show_L && $string =~ /%[\\*\\d\\.\\$]*L([diouxX])/) {\n\t\t\t\tWARN(\"PRINTF_L\",\n\t\t\t\t     \"\\%L$1 is non-standard C, use %ll$1\\n\" . $herecurr);\n\t\t\t\t$show_L = 0;\n\t\t\t}\n\t\t\t# check for %Z\n\t\t\tif ($show_Z && $string =~ /%[\\*\\d\\.\\$]*Z([diouxX])/) {\n\t\t\t\tWARN(\"PRINTF_Z\",\n\t\t\t\t     \"%Z$1 is non-standard C, use %z$1\\n\" . $herecurr);\n\t\t\t\t$show_Z = 0;\n\t\t\t}\n\t\t\t# check for 0x<decimal>\n\t\t\tif ($string =~ /0x%[\\*\\d\\.\\$\\Llzth]*[diou]/) {\n\t\t\t\tERROR(\"PRINTF_0XDECIMAL\",\n\t\t\t\t      \"Prefixing 0x with decimal output is defective\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for line continuations in quoted strings with odd counts of \"\n\t\tif ($rawline =~ /\\\\$/ && $sline =~ tr/\"/\"/ % 2) {\n\t\t\tWARN(\"LINE_CONTINUATIONS\",\n\t\t\t     \"Avoid line continuations in quoted strings\\n\" . $herecurr);\n\t\t}\n\n# warn about #if 0\n\t\tif ($line =~ /^.\\s*\\#\\s*if\\s+0\\b/) {\n\t\t\tWARN(\"IF_0\",\n\t\t\t     \"Consider removing the code enclosed by this #if 0 and its #endif\\n\" . $herecurr);\n\t\t}\n\n# warn about #if 1\n\t\tif ($line =~ /^.\\s*\\#\\s*if\\s+1\\b/) {\n\t\t\tWARN(\"IF_1\",\n\t\t\t     \"Consider removing the #if 1 and its #endif\\n\" . $herecurr);\n\t\t}\n\n# check for needless \"if (<foo>) fn(<foo>)\" uses\n\t\tif ($prevline =~ /\\bif\\s*\\(\\s*($Lval)\\s*\\)/) {\n\t\t\tmy $tested = quotemeta($1);\n\t\t\tmy $expr = '\\s*\\(\\s*' . $tested . '\\s*\\)\\s*;';\n\t\t\tif ($line =~ /\\b(kfree|usb_free_urb|debugfs_remove(?:_recursive)?|(?:kmem_cache|mempool|dma_pool)_destroy)$expr/) {\n\t\t\t\tmy $func = $1;\n\t\t\t\tif (WARN('NEEDLESS_IF',\n\t\t\t\t\t \"$func(NULL) is safe and this check is probably not required\\n\" . $hereprev) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\tmy $do_fix = 1;\n\t\t\t\t\tmy $leading_tabs = \"\";\n\t\t\t\t\tmy $new_leading_tabs = \"\";\n\t\t\t\t\tif ($lines[$linenr - 2] =~ /^\\+(\\t*)if\\s*\\(\\s*$tested\\s*\\)\\s*$/) {\n\t\t\t\t\t\t$leading_tabs = $1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$do_fix = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif ($lines[$linenr - 1] =~ /^\\+(\\t+)$func\\s*\\(\\s*$tested\\s*\\)\\s*;\\s*$/) {\n\t\t\t\t\t\t$new_leading_tabs = $1;\n\t\t\t\t\t\tif (length($leading_tabs) + 1 ne length($new_leading_tabs)) {\n\t\t\t\t\t\t\t$do_fix = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$do_fix = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif ($do_fix) {\n\t\t\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/^\\+$new_leading_tabs/\\+$leading_tabs/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for soon-to-be-deprecated single-argument k[v]free_rcu() API\n\t\tif ($line =~ /\\bk[v]?free_rcu\\s*\\([^(]+\\)/) {\n\t\t\tif ($line =~ /\\bk[v]?free_rcu\\s*\\([^,]+\\)/) {\n\t\t\t\tERROR(\"DEPRECATED_API\",\n\t\t\t\t      \"Single-argument k[v]free_rcu() API is deprecated, please pass rcu_head object or call k[v]free_rcu_mightsleep().\" . $herecurr);\n\t\t\t}\n\t\t}\n\n\n# check for unnecessary \"Out of Memory\" messages\n\t\tif ($line =~ /^\\+.*\\b$logFunctions\\s*\\(/ &&\n\t\t    $prevline =~ /^[ \\+]\\s*if\\s*\\(\\s*(\\!\\s*|NULL\\s*==\\s*)?($Lval)(\\s*==\\s*NULL\\s*)?\\s*\\)/ &&\n\t\t    (defined $1 || defined $3) &&\n\t\t    $linenr > 3) {\n\t\t\tmy $testval = $2;\n\t\t\tmy $testline = $lines[$linenr - 3];\n\n\t\t\tmy ($s, $c) = ctx_statement_block($linenr - 3, $realcnt, 0);\n#\t\t\tprint(\"line: <$line>\\nprevline: <$prevline>\\ns: <$s>\\nc: <$c>\\n\\n\\n\");\n\n\t\t\tif ($s =~ /(?:^|\\n)[ \\+]\\s*(?:$Type\\s*)?\\Q$testval\\E\\s*=\\s*(?:\\([^\\)]*\\)\\s*)?\\s*$allocFunctions\\s*\\(/ &&\n\t\t\t    $s !~ /\\b__GFP_NOWARN\\b/ ) {\n\t\t\t\tWARN(\"OOM_MESSAGE\",\n\t\t\t\t     \"Possible unnecessary 'out of memory' message\\n\" . $hereprev);\n\t\t\t}\n\t\t}\n\n# check for logging functions with KERN_<LEVEL>\n\t\tif ($line !~ /printk(?:_ratelimited|_once)?\\s*\\(/ &&\n\t\t    $line =~ /\\b$logFunctions\\s*\\(.*\\b(KERN_[A-Z]+)\\b/) {\n\t\t\tmy $level = $1;\n\t\t\tif (WARN(\"UNNECESSARY_KERN_LEVEL\",\n\t\t\t\t \"Possible unnecessary $level\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\s*$level\\s*//;\n\t\t\t}\n\t\t}\n\n# check for logging continuations\n\t\tif ($line =~ /\\bprintk\\s*\\(\\s*KERN_CONT\\b|\\bpr_cont\\s*\\(/) {\n\t\t\tWARN(\"LOGGING_CONTINUATION\",\n\t\t\t     \"Avoid logging continuation uses where feasible\\n\" . $herecurr);\n\t\t}\n\n# check for unnecessary use of %h[xudi] and %hh[xudi] in logging functions\n\t\tif (defined $stat &&\n\t\t    $line =~ /\\b$logFunctions\\s*\\(/ &&\n\t\t    index($stat, '\"') >= 0) {\n\t\t\tmy $lc = $stat =~ tr@\\n@@;\n\t\t\t$lc = $lc + $linenr;\n\t\t\tmy $stat_real = get_stat_real($linenr, $lc);\n\t\t\tpos($stat_real) = index($stat_real, '\"');\n\t\t\twhile ($stat_real =~ /[^\\\"%]*(%[\\#\\d\\.\\*\\-]*(h+)[idux])/g) {\n\t\t\t\tmy $pspec = $1;\n\t\t\t\tmy $h = $2;\n\t\t\t\tmy $lineoff = substr($stat_real, 0, $-[1]) =~ tr@\\n@@;\n\t\t\t\tif (WARN(\"UNNECESSARY_MODIFIER\",\n\t\t\t\t\t \"Integer promotion: Using '$h' in '$pspec' is unnecessary\\n\" . \"$here\\n$stat_real\\n\") &&\n\t\t\t\t    $fix && $fixed[$fixlinenr + $lineoff] =~ /^\\+/) {\n\t\t\t\t\tmy $nspec = $pspec;\n\t\t\t\t\t$nspec =~ s/h//g;\n\t\t\t\t\t$fixed[$fixlinenr + $lineoff] =~ s/\\Q$pspec\\E/$nspec/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for mask then right shift without a parentheses\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /$LvalOrFunc\\s*\\&\\s*($LvalOrFunc)\\s*>>/ &&\n\t\t    $4 !~ /^\\&/) { # $LvalOrFunc may be &foo, ignore if so\n\t\t\tWARN(\"MASK_THEN_SHIFT\",\n\t\t\t     \"Possible precedence defect with mask then right shift - may need parentheses\\n\" . $herecurr);\n\t\t}\n\n# check for pointer comparisons to NULL\n\t\tif ($perl_version_ok) {\n\t\t\twhile ($line =~ /\\b$LvalOrFunc\\s*(==|\\!=)\\s*NULL\\b/g) {\n\t\t\t\tmy $val = $1;\n\t\t\t\tmy $equal = \"!\";\n\t\t\t\t$equal = \"\" if ($4 eq \"!=\");\n\t\t\t\tif (CHK(\"COMPARISON_TO_NULL\",\n\t\t\t\t\t\"Comparison to NULL could be written \\\"${equal}${val}\\\"\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\b\\Q$val\\E\\s*(?:==|\\!=)\\s*NULL\\b/$equal$val/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for bad placement of section $InitAttribute (e.g.: __initdata)\n\t\tif ($line =~ /(\\b$InitAttribute\\b)/) {\n\t\t\tmy $attr = $1;\n\t\t\tif ($line =~ /^\\+\\s*static\\s+(?:const\\s+)?(?:$attr\\s+)?($NonptrTypeWithAttr)\\s+(?:$attr\\s+)?($Ident(?:\\[[^]]*\\])?)\\s*[=;]/) {\n\t\t\t\tmy $ptr = $1;\n\t\t\t\tmy $var = $2;\n\t\t\t\tif ((($ptr =~ /\\b(union|struct)\\s+$attr\\b/ &&\n\t\t\t\t      ERROR(\"MISPLACED_INIT\",\n\t\t\t\t\t    \"$attr should be placed after $var\\n\" . $herecurr)) ||\n\t\t\t\t     ($ptr !~ /\\b(union|struct)\\s+$attr\\b/ &&\n\t\t\t\t      WARN(\"MISPLACED_INIT\",\n\t\t\t\t\t   \"$attr should be placed after $var\\n\" . $herecurr))) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/(\\bstatic\\s+(?:const\\s+)?)(?:$attr\\s+)?($NonptrTypeWithAttr)\\s+(?:$attr\\s+)?($Ident(?:\\[[^]]*\\])?)\\s*([=;])\\s*/\"$1\" . trim(string_find_replace($2, \"\\\\s*$attr\\\\s*\", \" \")) . \" \" . trim(string_find_replace($3, \"\\\\s*$attr\\\\s*\", \"\")) . \" $attr\" . (\"$4\" eq \";\" ? \";\" : \" = \")/e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for $InitAttributeData (ie: __initdata) with const\n\t\tif ($line =~ /\\bconst\\b/ && $line =~ /($InitAttributeData)/) {\n\t\t\tmy $attr = $1;\n\t\t\t$attr =~ /($InitAttributePrefix)(.*)/;\n\t\t\tmy $attr_prefix = $1;\n\t\t\tmy $attr_type = $2;\n\t\t\tif (ERROR(\"INIT_ATTRIBUTE\",\n\t\t\t\t  \"Use of const init definition must use ${attr_prefix}initconst\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/$InitAttributeData/${attr_prefix}initconst/;\n\t\t\t}\n\t\t}\n\n# check for $InitAttributeConst (ie: __initconst) without const\n\t\tif ($line !~ /\\bconst\\b/ && $line =~ /($InitAttributeConst)/) {\n\t\t\tmy $attr = $1;\n\t\t\tif (ERROR(\"INIT_ATTRIBUTE\",\n\t\t\t\t  \"Use of $attr requires a separate use of const\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tmy $lead = $fixed[$fixlinenr] =~\n\t\t\t\t    /(^\\+\\s*(?:static\\s+))/;\n\t\t\t\t$lead = rtrim($1);\n\t\t\t\t$lead = \"$lead \" if ($lead !~ /^\\+$/);\n\t\t\t\t$lead = \"${lead}const \";\n\t\t\t\t$fixed[$fixlinenr] =~ s/(^\\+\\s*(?:static\\s+))/$lead/;\n\t\t\t}\n\t\t}\n\n# check for __read_mostly with const non-pointer (should just be const)\n\t\tif ($line =~ /\\b__read_mostly\\b/ &&\n\t\t    $line =~ /($Type)\\s*$Ident/ && $1 !~ /\\*\\s*$/ && $1 =~ /\\bconst\\b/) {\n\t\t\tif (ERROR(\"CONST_READ_MOSTLY\",\n\t\t\t\t  \"Invalid use of __read_mostly with const type\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\s+__read_mostly\\b//;\n\t\t\t}\n\t\t}\n\n# don't use __constant_<foo> functions outside of include/uapi/\n\t\tif ($realfile !~ m@^include/uapi/@ &&\n\t\t    $line =~ /(__constant_(?:htons|ntohs|[bl]e(?:16|32|64)_to_cpu|cpu_to_[bl]e(?:16|32|64)))\\s*\\(/) {\n\t\t\tmy $constant_func = $1;\n\t\t\tmy $func = $constant_func;\n\t\t\t$func =~ s/^__constant_//;\n\t\t\tif (WARN(\"CONSTANT_CONVERSION\",\n\t\t\t\t \"$constant_func should be $func\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\b$constant_func\\b/$func/g;\n\t\t\t}\n\t\t}\n\n# prefer usleep_range over udelay\n\t\tif ($line =~ /\\budelay\\s*\\(\\s*(\\d+)\\s*\\)/) {\n\t\t\tmy $delay = $1;\n\t\t\t# ignore udelay's < 10, however\n\t\t\tif (! ($delay < 10) ) {\n\t\t\t\tCHK(\"USLEEP_RANGE\",\n\t\t\t\t    \"usleep_range is preferred over udelay; see Documentation/timers/timers-howto.rst\\n\" . $herecurr);\n\t\t\t}\n\t\t\tif ($delay > 2000) {\n\t\t\t\tWARN(\"LONG_UDELAY\",\n\t\t\t\t     \"long udelay - prefer mdelay; see arch/arm/include/asm/delay.h\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# warn about unexpectedly long msleep's\n\t\tif ($line =~ /\\bmsleep\\s*\\((\\d+)\\);/) {\n\t\t\tif ($1 < 20) {\n\t\t\t\tWARN(\"MSLEEP\",\n\t\t\t\t     \"msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.rst\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for comparisons of jiffies\n\t\tif ($line =~ /\\bjiffies\\s*$Compare|$Compare\\s*jiffies\\b/) {\n\t\t\tWARN(\"JIFFIES_COMPARISON\",\n\t\t\t     \"Comparing jiffies is almost always wrong; prefer time_after, time_before and friends\\n\" . $herecurr);\n\t\t}\n\n# check for comparisons of get_jiffies_64()\n\t\tif ($line =~ /\\bget_jiffies_64\\s*\\(\\s*\\)\\s*$Compare|$Compare\\s*get_jiffies_64\\s*\\(\\s*\\)/) {\n\t\t\tWARN(\"JIFFIES_COMPARISON\",\n\t\t\t     \"Comparing get_jiffies_64() is almost always wrong; prefer time_after64, time_before64 and friends\\n\" . $herecurr);\n\t\t}\n\n# warn about #ifdefs in C files\n#\t\tif ($line =~ /^.\\s*\\#\\s*if(|n)def/ && ($realfile =~ /\\.c$/)) {\n#\t\t\tprint \"#ifdef in C files should be avoided\\n\";\n#\t\t\tprint \"$herecurr\";\n#\t\t\t$clean = 0;\n#\t\t}\n\n# warn about spacing in #ifdefs\n\t\tif ($line =~ /^.\\s*\\#\\s*(ifdef|ifndef|elif)\\s\\s+/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"exactly one space required after that #$1\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/^(.\\s*\\#\\s*(ifdef|ifndef|elif))\\s{2,}/$1 /;\n\t\t\t}\n\n\t\t}\n\n# check for spinlock_t definitions without a comment.\n\t\tif ($line =~ /^.\\s*(struct\\s+mutex|spinlock_t)\\s+\\S+;/ ||\n\t\t    $line =~ /^.\\s*(DEFINE_MUTEX)\\s*\\(/) {\n\t\t\tmy $which = $1;\n\t\t\tif (!ctx_has_comment($first_line, $linenr)) {\n\t\t\t\tCHK(\"UNCOMMENTED_DEFINITION\",\n\t\t\t\t    \"$1 definition without comment\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n# check for memory barriers without a comment.\n\n\t\tmy $barriers = qr{\n\t\t\tmb|\n\t\t\trmb|\n\t\t\twmb\n\t\t}x;\n\t\tmy $barrier_stems = qr{\n\t\t\tmb__before_atomic|\n\t\t\tmb__after_atomic|\n\t\t\tstore_release|\n\t\t\tload_acquire|\n\t\t\tstore_mb|\n\t\t\t(?:$barriers)\n\t\t}x;\n\t\tmy $all_barriers = qr{\n\t\t\t(?:$barriers)|\n\t\t\tsmp_(?:$barrier_stems)|\n\t\t\tvirt_(?:$barrier_stems)\n\t\t}x;\n\n\t\tif ($line =~ /\\b(?:$all_barriers)\\s*\\(/) {\n\t\t\tif (!ctx_has_comment($first_line, $linenr)) {\n\t\t\t\tWARN(\"MEMORY_BARRIER\",\n\t\t\t\t     \"memory barrier without comment\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n\t\tmy $underscore_smp_barriers = qr{__smp_(?:$barrier_stems)}x;\n\n\t\tif ($realfile !~ m@^include/asm-generic/@ &&\n\t\t    $realfile !~ m@/barrier\\.h$@ &&\n\t\t    $line =~ m/\\b(?:$underscore_smp_barriers)\\s*\\(/ &&\n\t\t    $line !~ m/^.\\s*\\#\\s*define\\s+(?:$underscore_smp_barriers)\\s*\\(/) {\n\t\t\tWARN(\"MEMORY_BARRIER\",\n\t\t\t     \"__smp memory barriers shouldn't be used outside barrier.h and asm-generic\\n\" . $herecurr);\n\t\t}\n\n# check for waitqueue_active without a comment.\n\t\tif ($line =~ /\\bwaitqueue_active\\s*\\(/) {\n\t\t\tif (!ctx_has_comment($first_line, $linenr)) {\n\t\t\t\tWARN(\"WAITQUEUE_ACTIVE\",\n\t\t\t\t     \"waitqueue_active without comment\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for data_race without a comment.\n\t\tif ($line =~ /\\bdata_race\\s*\\(/) {\n\t\t\tif (!ctx_has_comment($first_line, $linenr)) {\n\t\t\t\tWARN(\"DATA_RACE\",\n\t\t\t\t     \"data_race without comment\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check of hardware specific defines\n\t\tif ($line =~ m@^.\\s*\\#\\s*if.*\\b(__i386__|__powerpc64__|__sun__|__s390x__)\\b@ && $realfile !~ m@include/asm-@) {\n\t\t\tCHK(\"ARCH_DEFINES\",\n\t\t\t    \"architecture specific defines should be avoided\\n\" .  $herecurr);\n\t\t}\n\n# check that the storage class is not after a type\n\t\tif ($line =~ /\\b($Type)\\s+($Storage)\\b/) {\n\t\t\tWARN(\"STORAGE_CLASS\",\n\t\t\t     \"storage class '$2' should be located before type '$1'\\n\" . $herecurr);\n\t\t}\n# Check that the storage class is at the beginning of a declaration\n\t\tif ($line =~ /\\b$Storage\\b/ &&\n\t\t    $line !~ /^.\\s*$Storage/ &&\n\t\t    $line =~ /^.\\s*(.+?)\\$Storage\\s/ &&\n\t\t    $1 !~ /[\\,\\)]\\s*$/) {\n\t\t\tWARN(\"STORAGE_CLASS\",\n\t\t\t     \"storage class should be at the beginning of the declaration\\n\" . $herecurr);\n\t\t}\n\n# check the location of the inline attribute, that it is between\n# storage class and type.\n\t\tif ($line =~ /\\b$Type\\s+$Inline\\b/ ||\n\t\t    $line =~ /\\b$Inline\\s+$Storage\\b/) {\n\t\t\tERROR(\"INLINE_LOCATION\",\n\t\t\t      \"inline keyword should sit between storage class and type\\n\" . $herecurr);\n\t\t}\n\n# Check for __inline__ and __inline, prefer inline\n\t\tif ($realfile !~ m@\\binclude/uapi/@ &&\n\t\t    $line =~ /\\b(__inline__|__inline)\\b/) {\n\t\t\tif (WARN(\"INLINE\",\n\t\t\t\t \"plain inline is preferred over $1\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\b(__inline__|__inline)\\b/inline/;\n\n\t\t\t}\n\t\t}\n\n# Check for compiler attributes\n\t\tif ($realfile !~ m@\\binclude/uapi/@ &&\n\t\t    $rawline =~ /\\b__attribute__\\s*\\(\\s*($balanced_parens)\\s*\\)/) {\n\t\t\tmy $attr = $1;\n\t\t\t$attr =~ s/\\s*\\(\\s*(.*)\\)\\s*/$1/;\n\n\t\t\tmy %attr_list = (\n\t\t\t\t\"alias\"\t\t\t\t=> \"__alias\",\n\t\t\t\t\"aligned\"\t\t\t=> \"__aligned\",\n\t\t\t\t\"always_inline\"\t\t\t=> \"__always_inline\",\n\t\t\t\t\"assume_aligned\"\t\t=> \"__assume_aligned\",\n\t\t\t\t\"cold\"\t\t\t\t=> \"__cold\",\n\t\t\t\t\"const\"\t\t\t\t=> \"__attribute_const__\",\n\t\t\t\t\"copy\"\t\t\t\t=> \"__copy\",\n\t\t\t\t\"designated_init\"\t\t=> \"__designated_init\",\n\t\t\t\t\"externally_visible\"\t\t=> \"__visible\",\n\t\t\t\t\"format\"\t\t\t=> \"printf|scanf\",\n\t\t\t\t\"gnu_inline\"\t\t\t=> \"__gnu_inline\",\n\t\t\t\t\"malloc\"\t\t\t=> \"__malloc\",\n\t\t\t\t\"mode\"\t\t\t\t=> \"__mode\",\n\t\t\t\t\"no_caller_saved_registers\"\t=> \"__no_caller_saved_registers\",\n\t\t\t\t\"noclone\"\t\t\t=> \"__noclone\",\n\t\t\t\t\"noinline\"\t\t\t=> \"noinline\",\n\t\t\t\t\"nonstring\"\t\t\t=> \"__nonstring\",\n\t\t\t\t\"noreturn\"\t\t\t=> \"__noreturn\",\n\t\t\t\t\"packed\"\t\t\t=> \"__packed\",\n\t\t\t\t\"pure\"\t\t\t\t=> \"__pure\",\n\t\t\t\t\"section\"\t\t\t=> \"__section\",\n\t\t\t\t\"used\"\t\t\t\t=> \"__used\",\n\t\t\t\t\"weak\"\t\t\t\t=> \"__weak\"\n\t\t\t);\n\n\t\t\twhile ($attr =~ /\\s*(\\w+)\\s*(${balanced_parens})?/g) {\n\t\t\t\tmy $orig_attr = $1;\n\t\t\t\tmy $params = '';\n\t\t\t\t$params = $2 if defined($2);\n\t\t\t\tmy $curr_attr = $orig_attr;\n\t\t\t\t$curr_attr =~ s/^[\\s_]+|[\\s_]+$//g;\n\t\t\t\tif (exists($attr_list{$curr_attr})) {\n\t\t\t\t\tmy $new = $attr_list{$curr_attr};\n\t\t\t\t\tif ($curr_attr eq \"format\" && $params) {\n\t\t\t\t\t\t$params =~ /^\\s*\\(\\s*(\\w+)\\s*,\\s*(.*)/;\n\t\t\t\t\t\t$new = \"__$1\\($2\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$new = \"$new$params\";\n\t\t\t\t\t}\n\t\t\t\t\tif (WARN(\"PREFER_DEFINED_ATTRIBUTE_MACRO\",\n\t\t\t\t\t\t \"Prefer $new over __attribute__(($orig_attr$params))\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\tmy $remove = \"\\Q$orig_attr\\E\" . '\\s*' . \"\\Q$params\\E\" . '(?:\\s*,\\s*)?';\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/$remove//;\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\b__attribute__/$new __attribute__/;\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\}\\Q$new\\E/} $new/;\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/ __attribute__\\s*\\(\\s*\\(\\s*\\)\\s*\\)//;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# Check for __attribute__ unused, prefer __always_unused or __maybe_unused\n\t\t\tif ($attr =~ /^_*unused/) {\n\t\t\t\tWARN(\"PREFER_DEFINED_ATTRIBUTE_MACRO\",\n\t\t\t\t     \"__always_unused or __maybe_unused is preferred over __attribute__((__unused__))\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Check for __attribute__ weak, or __weak declarations (may have link issues)\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /(?:$Declare|$DeclareMisordered)\\s*$Ident\\s*$balanced_parens\\s*(?:$Attribute)?\\s*;/ &&\n\t\t    ($line =~ /\\b__attribute__\\s*\\(\\s*\\(.*\\bweak\\b/ ||\n\t\t     $line =~ /\\b__weak\\b/)) {\n\t\t\tERROR(\"WEAK_DECLARATION\",\n\t\t\t      \"Using weak declarations can have unintended link defects\\n\" . $herecurr);\n\t\t}\n\n# check for c99 types like uint8_t used outside of uapi/ and tools/\n\t\tif ($realfile !~ m@\\binclude/uapi/@ &&\n\t\t    $realfile !~ m@\\btools/@ &&\n\t\t    $line =~ /\\b($Declare)\\s*$Ident\\s*[=;,\\[]/) {\n\t\t\tmy $type = $1;\n\t\t\tif ($type =~ /\\b($typeC99Typedefs)\\b/) {\n\t\t\t\t$type = $1;\n\t\t\t\tmy $kernel_type = 'u';\n\t\t\t\t$kernel_type = 's' if ($type =~ /^_*[si]/);\n\t\t\t\t$type =~ /(\\d+)/;\n\t\t\t\t$kernel_type .= $1;\n\t\t\t\tif (CHK(\"PREFER_KERNEL_TYPES\",\n\t\t\t\t\t\"Prefer kernel type '$kernel_type' over '$type'\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\b$type\\b/$kernel_type/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for cast of C90 native int or longer types constants\n\t\tif ($line =~ /(\\(\\s*$C90_int_types\\s*\\)\\s*)($Constant)\\b/) {\n\t\t\tmy $cast = $1;\n\t\t\tmy $const = $2;\n\t\t\tmy $suffix = \"\";\n\t\t\tmy $newconst = $const;\n\t\t\t$newconst =~ s/${Int_type}$//;\n\t\t\t$suffix .= 'U' if ($cast =~ /\\bunsigned\\b/);\n\t\t\tif ($cast =~ /\\blong\\s+long\\b/) {\n\t\t\t    $suffix .= 'LL';\n\t\t\t} elsif ($cast =~ /\\blong\\b/) {\n\t\t\t    $suffix .= 'L';\n\t\t\t}\n\t\t\tif (WARN(\"TYPECAST_INT_CONSTANT\",\n\t\t\t\t \"Unnecessary typecast of c90 int constant - '$cast$const' could be '$const$suffix'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$cast\\E$const\\b/$newconst$suffix/;\n\t\t\t}\n\t\t}\n\n# check for sizeof(&)\n\t\tif ($line =~ /\\bsizeof\\s*\\(\\s*\\&/) {\n\t\t\tWARN(\"SIZEOF_ADDRESS\",\n\t\t\t     \"sizeof(& should be avoided\\n\" . $herecurr);\n\t\t}\n\n# check for sizeof without parenthesis\n\t\tif ($line =~ /\\bsizeof\\s+((?:\\*\\s*|)$Lval|$Type(?:\\s+$Lval|))/) {\n\t\t\tif (WARN(\"SIZEOF_PARENTHESIS\",\n\t\t\t\t \"sizeof $1 should be sizeof($1)\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\bsizeof\\s+((?:\\*\\s*|)$Lval|$Type(?:\\s+$Lval|))/\"sizeof(\" . trim($1) . \")\"/ex;\n\t\t\t}\n\t\t}\n\n# check for struct spinlock declarations\n\t\tif ($line =~ /^.\\s*\\bstruct\\s+spinlock\\s+\\w+\\s*;/) {\n\t\t\tWARN(\"USE_SPINLOCK_T\",\n\t\t\t     \"struct spinlock should be spinlock_t\\n\" . $herecurr);\n\t\t}\n\n# check for seq_printf uses that could be seq_puts\n\t\tif ($sline =~ /\\bseq_printf\\s*\\(.*\"\\s*\\)\\s*;\\s*$/) {\n\t\t\tmy $fmt = get_quoted_string($line, $rawline);\n\t\t\t$fmt =~ s/%%//g;\n\t\t\tif ($fmt !~ /%/) {\n\t\t\t\tif (WARN(\"PREFER_SEQ_PUTS\",\n\t\t\t\t\t \"Prefer seq_puts to seq_printf\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bseq_printf\\b/seq_puts/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for vsprintf extension %p<foo> misuses\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+(?![^\\{]*\\{\\s*).*\\b(\\w+)\\s*\\(.*$String\\s*,/s &&\n\t\t    $1 !~ /^_*volatile_*$/) {\n\t\t\tmy $stat_real;\n\n\t\t\tmy $lc = $stat =~ tr@\\n@@;\n\t\t\t$lc = $lc + $linenr;\n\t\t        for (my $count = $linenr; $count <= $lc; $count++) {\n\t\t\t\tmy $specifier;\n\t\t\t\tmy $extension;\n\t\t\t\tmy $qualifier;\n\t\t\t\tmy $bad_specifier = \"\";\n\t\t\t\tmy $fmt = get_quoted_string($lines[$count - 1], raw_line($count, 0));\n\t\t\t\t$fmt =~ s/%%//g;\n\n\t\t\t\twhile ($fmt =~ /(\\%[\\*\\d\\.]*p(\\w)(\\w*))/g) {\n\t\t\t\t\t$specifier = $1;\n\t\t\t\t\t$extension = $2;\n\t\t\t\t\t$qualifier = $3;\n\t\t\t\t\tif ($extension !~ /[4SsBKRraEehMmIiUDdgVCbGNOxtf]/ ||\n\t\t\t\t\t    ($extension eq \"f\" &&\n\t\t\t\t\t     defined $qualifier && $qualifier !~ /^w/) ||\n\t\t\t\t\t    ($extension eq \"4\" &&\n\t\t\t\t\t     defined $qualifier && $qualifier !~ /^cc/)) {\n\t\t\t\t\t\t$bad_specifier = $specifier;\n\t\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t\tif ($extension eq \"x\" && !defined($stat_real)) {\n\t\t\t\t\t\tif (!defined($stat_real)) {\n\t\t\t\t\t\t\t$stat_real = get_stat_real($linenr, $lc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tWARN(\"VSPRINTF_SPECIFIER_PX\",\n\t\t\t\t\t\t     \"Using vsprintf specifier '\\%px' potentially exposes the kernel memory layout, if you don't really need the address please consider using '\\%p'.\\n\" . \"$here\\n$stat_real\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($bad_specifier ne \"\") {\n\t\t\t\t\tmy $stat_real = get_stat_real($linenr, $lc);\n\t\t\t\t\tmy $msg_level = \\&WARN;\n\t\t\t\t\tmy $ext_type = \"Invalid\";\n\t\t\t\t\tmy $use = \"\";\n\t\t\t\t\tif ($bad_specifier =~ /p[Ff]/) {\n\t\t\t\t\t\t$use = \" - use %pS instead\";\n\t\t\t\t\t\t$use =~ s/pS/ps/ if ($bad_specifier =~ /pf/);\n\t\t\t\t\t} elsif ($bad_specifier =~ /pA/) {\n\t\t\t\t\t\t$use =  \" - '%pA' is only intended to be used from Rust code\";\n\t\t\t\t\t\t$msg_level = \\&ERROR;\n\t\t\t\t\t}\n\n\t\t\t\t\t&{$msg_level}(\"VSPRINTF_POINTER_EXTENSION\",\n\t\t\t\t\t\t      \"$ext_type vsprintf pointer extension '$bad_specifier'$use\\n\" . \"$here\\n$stat_real\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check for misused memsets\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+(?:.*?)\\bmemset\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\,\\s*$FuncArg\\s*\\)/) {\n\n\t\t\tmy $ms_addr = $2;\n\t\t\tmy $ms_val = $7;\n\t\t\tmy $ms_size = $12;\n\n\t\t\tif ($ms_size =~ /^(0x|)0$/i) {\n\t\t\t\tERROR(\"MEMSET\",\n\t\t\t\t      \"memset to 0's uses 0 as the 2nd argument, not the 3rd\\n\" . \"$here\\n$stat\\n\");\n\t\t\t} elsif ($ms_size =~ /^(0x|)1$/i) {\n\t\t\t\tWARN(\"MEMSET\",\n\t\t\t\t     \"single byte memset is suspicious. Swapped 2nd/3rd argument?\\n\" . \"$here\\n$stat\\n\");\n\t\t\t}\n\t\t}\n\n# Check for memcpy(foo, bar, ETH_ALEN) that could be ether_addr_copy(foo, bar)\n#\t\tif ($perl_version_ok &&\n#\t\t    defined $stat &&\n#\t\t    $stat =~ /^\\+(?:.*?)\\bmemcpy\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\,\\s*ETH_ALEN\\s*\\)/) {\n#\t\t\tif (WARN(\"PREFER_ETHER_ADDR_COPY\",\n#\t\t\t\t \"Prefer ether_addr_copy() over memcpy() if the Ethernet addresses are __aligned(2)\\n\" . \"$here\\n$stat\\n\") &&\n#\t\t\t    $fix) {\n#\t\t\t\t$fixed[$fixlinenr] =~ s/\\bmemcpy\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\,\\s*ETH_ALEN\\s*\\)/ether_addr_copy($2, $7)/;\n#\t\t\t}\n#\t\t}\n\n# Check for memcmp(foo, bar, ETH_ALEN) that could be ether_addr_equal*(foo, bar)\n#\t\tif ($perl_version_ok &&\n#\t\t    defined $stat &&\n#\t\t    $stat =~ /^\\+(?:.*?)\\bmemcmp\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\,\\s*ETH_ALEN\\s*\\)/) {\n#\t\t\tWARN(\"PREFER_ETHER_ADDR_EQUAL\",\n#\t\t\t     \"Prefer ether_addr_equal() or ether_addr_equal_unaligned() over memcmp()\\n\" . \"$here\\n$stat\\n\")\n#\t\t}\n\n# check for memset(foo, 0x0, ETH_ALEN) that could be eth_zero_addr\n# check for memset(foo, 0xFF, ETH_ALEN) that could be eth_broadcast_addr\n#\t\tif ($perl_version_ok &&\n#\t\t    defined $stat &&\n#\t\t    $stat =~ /^\\+(?:.*?)\\bmemset\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\,\\s*ETH_ALEN\\s*\\)/) {\n#\n#\t\t\tmy $ms_val = $7;\n#\n#\t\t\tif ($ms_val =~ /^(?:0x|)0+$/i) {\n#\t\t\t\tif (WARN(\"PREFER_ETH_ZERO_ADDR\",\n#\t\t\t\t\t \"Prefer eth_zero_addr over memset()\\n\" . \"$here\\n$stat\\n\") &&\n#\t\t\t\t    $fix) {\n#\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bmemset\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*,\\s*ETH_ALEN\\s*\\)/eth_zero_addr($2)/;\n#\t\t\t\t}\n#\t\t\t} elsif ($ms_val =~ /^(?:0xff|255)$/i) {\n#\t\t\t\tif (WARN(\"PREFER_ETH_BROADCAST_ADDR\",\n#\t\t\t\t\t \"Prefer eth_broadcast_addr() over memset()\\n\" . \"$here\\n$stat\\n\") &&\n#\t\t\t\t    $fix) {\n#\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bmemset\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*,\\s*ETH_ALEN\\s*\\)/eth_broadcast_addr($2)/;\n#\t\t\t\t}\n#\t\t\t}\n#\t\t}\n\n# strcpy uses that should likely be strscpy\n\t\tif ($line =~ /\\bstrcpy\\s*\\(/) {\n\t\t\tWARN(\"STRCPY\",\n\t\t\t     \"Prefer strscpy over strcpy - see: https://github.com/KSPP/linux/issues/88\\n\" . $herecurr);\n\t\t}\n\n# strlcpy uses that should likely be strscpy\n\t\tif ($line =~ /\\bstrlcpy\\s*\\(/) {\n\t\t\tWARN(\"STRLCPY\",\n\t\t\t     \"Prefer strscpy over strlcpy - see: https://github.com/KSPP/linux/issues/89\\n\" . $herecurr);\n\t\t}\n\n# strncpy uses that should likely be strscpy or strscpy_pad\n\t\tif ($line =~ /\\bstrncpy\\s*\\(/) {\n\t\t\tWARN(\"STRNCPY\",\n\t\t\t     \"Prefer strscpy, strscpy_pad, or __nonstring over strncpy - see: https://github.com/KSPP/linux/issues/90\\n\" . $herecurr);\n\t\t}\n\n# typecasts on min/max could be min_t/max_t\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+(?:.*?)\\b(min|max)\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\)/) {\n\t\t\tif (defined $2 || defined $7) {\n\t\t\t\tmy $call = $1;\n\t\t\t\tmy $cast1 = deparenthesize($2);\n\t\t\t\tmy $arg1 = $3;\n\t\t\t\tmy $cast2 = deparenthesize($7);\n\t\t\t\tmy $arg2 = $8;\n\t\t\t\tmy $cast;\n\n\t\t\t\tif ($cast1 ne \"\" && $cast2 ne \"\" && $cast1 ne $cast2) {\n\t\t\t\t\t$cast = \"$cast1 or $cast2\";\n\t\t\t\t} elsif ($cast1 ne \"\") {\n\t\t\t\t\t$cast = $cast1;\n\t\t\t\t} else {\n\t\t\t\t\t$cast = $cast2;\n\t\t\t\t}\n\t\t\t\tWARN(\"MINMAX\",\n\t\t\t\t     \"$call() should probably be ${call}_t($cast, $arg1, $arg2)\\n\" . \"$here\\n$stat\\n\");\n\t\t\t}\n\t\t}\n\n# check usleep_range arguments\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+(?:.*?)\\busleep_range\\s*\\(\\s*($FuncArg)\\s*,\\s*($FuncArg)\\s*\\)/) {\n\t\t\tmy $min = $1;\n\t\t\tmy $max = $7;\n\t\t\tif ($min eq $max) {\n\t\t\t\tWARN(\"USLEEP_RANGE\",\n\t\t\t\t     \"usleep_range should not use min == max args; see Documentation/timers/timers-howto.rst\\n\" . \"$here\\n$stat\\n\");\n\t\t\t} elsif ($min =~ /^\\d+$/ && $max =~ /^\\d+$/ &&\n\t\t\t\t $min > $max) {\n\t\t\t\tWARN(\"USLEEP_RANGE\",\n\t\t\t\t     \"usleep_range args reversed, use min then max; see Documentation/timers/timers-howto.rst\\n\" . \"$here\\n$stat\\n\");\n\t\t\t}\n\t\t}\n\n# check for naked sscanf\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $line =~ /\\bsscanf\\b/ &&\n\t\t    ($stat !~ /$Ident\\s*=\\s*sscanf\\s*$balanced_parens/ &&\n\t\t     $stat !~ /\\bsscanf\\s*$balanced_parens\\s*(?:$Compare)/ &&\n\t\t     $stat !~ /(?:$Compare)\\s*\\bsscanf\\s*$balanced_parens/)) {\n\t\t\tmy $lc = $stat =~ tr@\\n@@;\n\t\t\t$lc = $lc + $linenr;\n\t\t\tmy $stat_real = get_stat_real($linenr, $lc);\n\t\t\tWARN(\"NAKED_SSCANF\",\n\t\t\t     \"unchecked sscanf return value\\n\" . \"$here\\n$stat_real\\n\");\n\t\t}\n\n# check for simple sscanf that should be kstrto<foo>\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $line =~ /\\bsscanf\\b/) {\n\t\t\tmy $lc = $stat =~ tr@\\n@@;\n\t\t\t$lc = $lc + $linenr;\n\t\t\tmy $stat_real = get_stat_real($linenr, $lc);\n\t\t\tif ($stat_real =~ /\\bsscanf\\b\\s*\\(\\s*$FuncArg\\s*,\\s*(\"[^\"]+\")/) {\n\t\t\t\tmy $format = $6;\n\t\t\t\tmy $count = $format =~ tr@%@%@;\n\t\t\t\tif ($count == 1 &&\n\t\t\t\t    $format =~ /^\"\\%(?i:ll[udxi]|[udxi]ll|ll|[hl]h?[udxi]|[udxi][hl]h?|[hl]h?|[udxi])\"$/) {\n\t\t\t\t\tWARN(\"SSCANF_TO_KSTRTO\",\n\t\t\t\t\t     \"Prefer kstrto<type> to single variable sscanf\\n\" . \"$here\\n$stat_real\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for new externs in .h files.\n\t\tif ($realfile =~ /\\.h$/ &&\n\t\t    $line =~ /^\\+\\s*(extern\\s+)$Type\\s*$Ident\\s*\\(/s) {\n\t\t\tif (CHK(\"AVOID_EXTERNS\",\n\t\t\t\t\"extern prototypes should be avoided in .h files\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(.*)\\bextern\\b\\s*(.*)/$1$2/;\n\t\t\t}\n\t\t}\n\n# check for new externs in .c files.\n\t\tif ($realfile =~ /\\.c$/ && defined $stat &&\n\t\t    $stat =~ /^.\\s*(?:extern\\s+)?$Type\\s+($Ident)(\\s*)\\(/s)\n\t\t{\n\t\t\tmy $function_name = $1;\n\t\t\tmy $paren_space = $2;\n\n\t\t\tmy $s = $stat;\n\t\t\tif (defined $cond) {\n\t\t\t\tsubstr($s, 0, length($cond), '');\n\t\t\t}\n\t\t\tif ($s =~ /^\\s*;/)\n\t\t\t{\n\t\t\t\tWARN(\"AVOID_EXTERNS\",\n\t\t\t\t     \"externs should be avoided in .c files\\n\" .  $herecurr);\n\t\t\t}\n\n\t\t\tif ($paren_space =~ /\\n/) {\n\t\t\t\tWARN(\"FUNCTION_ARGUMENTS\",\n\t\t\t\t     \"arguments for function declarations should follow identifier\\n\" . $herecurr);\n\t\t\t}\n\n\t\t} elsif ($realfile =~ /\\.c$/ && defined $stat &&\n\t\t    $stat =~ /^\\+extern struct\\s+(\\w+)\\s+(\\w+)\\[\\];/)\n\t\t{\n\t\t\tmy ($st_type, $st_name) = ($1, $2);\n\n\t\t\tfor my $s (keys %maybe_linker_symbol) {\n\t\t\t    #print \"Linker symbol? $st_name : $s\\n\";\n\t\t\t    goto LIKELY_LINKER_SYMBOL\n\t\t\t\tif $st_name =~ /$s/;\n\t\t\t}\n\t\t\tWARN(\"AVOID_EXTERNS\",\n\t\t\t     \"found a file-scoped extern type:$st_type name:$st_name in .c file\\n\"\n\t\t\t     . \"is this a linker symbol ?\\n\" . $herecurr);\n\t\t  LIKELY_LINKER_SYMBOL:\n\n\t\t} elsif ($realfile =~ /\\.c$/ && defined $stat &&\n\t\t    $stat =~ /^.\\s*extern\\s+/)\n\t\t{\n\t\t\tWARN(\"AVOID_EXTERNS\",\n\t\t\t     \"externs should be avoided in .c files\\n\" .  $herecurr);\n\t\t}\n\n# check for function declarations that have arguments without identifier names\n\t\tif (defined $stat &&\n\t\t    $stat =~ /^.\\s*(?:extern\\s+)?$Type\\s*(?:$Ident|\\(\\s*\\*\\s*$Ident\\s*\\))\\s*\\(\\s*([^{]+)\\s*\\)\\s*;/s &&\n\t\t    $1 ne \"void\") {\n\t\t\tmy $args = trim($1);\n\t\t\twhile ($args =~ m/\\s*($Type\\s*(?:$Ident|\\(\\s*\\*\\s*$Ident?\\s*\\)\\s*$balanced_parens)?)/g) {\n\t\t\t\tmy $arg = trim($1);\n\t\t\t\tif ($arg =~ /^$Type$/ && $arg !~ /enum\\s+$Ident$/) {\n\t\t\t\t\tWARN(\"FUNCTION_ARGUMENTS\",\n\t\t\t\t\t     \"function definition argument '$arg' should also have an identifier name\\n\" . $herecurr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for function definitions\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^.\\s*(?:$Storage\\s+)?$Type\\s*($Ident)\\s*$balanced_parens\\s*{/s) {\n\t\t\t$context_function = $1;\n\n# check for multiline function definition with misplaced open brace\n\t\t\tmy $ok = 0;\n\t\t\tmy $cnt = statement_rawlines($stat);\n\t\t\tmy $herectx = $here . \"\\n\";\n\t\t\tfor (my $n = 0; $n < $cnt; $n++) {\n\t\t\t\tmy $rl = raw_line($linenr, $n);\n\t\t\t\t$herectx .=  $rl . \"\\n\";\n\t\t\t\t$ok = 1 if ($rl =~ /^[ \\+]\\{/);\n\t\t\t\t$ok = 1 if ($rl =~ /\\{/ && $n == 0);\n\t\t\t\tlast if $rl =~ /^[ \\+].*\\{/;\n\t\t\t}\n\t\t\tif (!$ok) {\n\t\t\t\tERROR(\"OPEN_BRACE\",\n\t\t\t\t      \"open brace '{' following function definitions go on the next line\\n\" . $herectx);\n\t\t\t}\n\t\t}\n\n# checks for new __setup's\n\t\tif ($rawline =~ /\\b__setup\\(\"([^\"]*)\"/) {\n\t\t\tmy $name = $1;\n\n\t\t\tif (!grep(/$name/, @setup_docs)) {\n\t\t\t\tCHK(\"UNDOCUMENTED_SETUP\",\n\t\t\t\t    \"__setup appears un-documented -- check Documentation/admin-guide/kernel-parameters.txt\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for pointless casting of alloc functions\n\t\tif ($line =~ /\\*\\s*\\)\\s*$allocFunctions\\b/) {\n\t\t\tWARN(\"UNNECESSARY_CASTS\",\n\t\t\t     \"unnecessary cast may hide bugs, see http://c-faq.com/malloc/mallocnocast.html\\n\" . $herecurr);\n\t\t}\n\n# alloc style\n# p = alloc(sizeof(struct foo), ...) should be p = alloc(sizeof(*p), ...)\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /\\b($Lval)\\s*\\=\\s*(?:$balanced_parens)?\\s*((?:kv|k|v)[mz]alloc(?:_node)?)\\s*\\(\\s*(sizeof\\s*\\(\\s*struct\\s+$Lval\\s*\\))/) {\n\t\t\tCHK(\"ALLOC_SIZEOF_STRUCT\",\n\t\t\t    \"Prefer $3(sizeof(*$1)...) over $3($4...)\\n\" . $herecurr);\n\t\t}\n\n# check for (kv|k)[mz]alloc with multiplies that could be kmalloc_array/kvmalloc_array/kvcalloc/kcalloc\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+\\s*($Lval)\\s*\\=\\s*(?:$balanced_parens)?\\s*((?:kv|k)[mz]alloc)\\s*\\(\\s*($FuncArg)\\s*\\*\\s*($FuncArg)\\s*,/) {\n\t\t\tmy $oldfunc = $3;\n\t\t\tmy $a1 = $4;\n\t\t\tmy $a2 = $10;\n\t\t\tmy $newfunc = \"kmalloc_array\";\n\t\t\t$newfunc = \"kvmalloc_array\" if ($oldfunc eq \"kvmalloc\");\n\t\t\t$newfunc = \"kvcalloc\" if ($oldfunc eq \"kvzalloc\");\n\t\t\t$newfunc = \"kcalloc\" if ($oldfunc eq \"kzalloc\");\n\t\t\tmy $r1 = $a1;\n\t\t\tmy $r2 = $a2;\n\t\t\tif ($a1 =~ /^sizeof\\s*\\S/) {\n\t\t\t\t$r1 = $a2;\n\t\t\t\t$r2 = $a1;\n\t\t\t}\n\t\t\tif ($r1 !~ /^sizeof\\b/ && $r2 =~ /^sizeof\\s*\\S/ &&\n\t\t\t    !($r1 =~ /^$Constant$/ || $r1 =~ /^[A-Z_][A-Z0-9_]*$/)) {\n\t\t\t\tmy $cnt = statement_rawlines($stat);\n\t\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\t\tif (WARN(\"ALLOC_WITH_MULTIPLY\",\n\t\t\t\t\t \"Prefer $newfunc over $oldfunc with multiply\\n\" . $herectx) &&\n\t\t\t\t    $cnt == 1 &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\b($Lval)\\s*\\=\\s*(?:$balanced_parens)?\\s*((?:kv|k)[mz]alloc)\\s*\\(\\s*($FuncArg)\\s*\\*\\s*($FuncArg)/$1 . ' = ' . \"$newfunc(\" . trim($r1) . ', ' . trim($r2)/e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for krealloc arg reuse\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /\\b($Lval)\\s*\\=\\s*(?:$balanced_parens)?\\s*krealloc\\s*\\(\\s*($Lval)\\s*,/ &&\n\t\t    $1 eq $3) {\n\t\t\tWARN(\"KREALLOC_ARG_REUSE\",\n\t\t\t     \"Reusing the krealloc arg is almost always a bug\\n\" . $herecurr);\n\t\t}\n\n# check for alloc argument mismatch\n\t\tif ($line =~ /\\b((?:devm_)?((?:k|kv)?(calloc|malloc_array)(?:_node)?))\\s*\\(\\s*sizeof\\b/) {\n\t\t\tWARN(\"ALLOC_ARRAY_ARGS\",\n\t\t\t     \"$1 uses number as first arg, sizeof is generally wrong\\n\" . $herecurr);\n\t\t}\n\n# check for multiple semicolons\n\t\tif ($line =~ /;\\s*;\\s*$/) {\n\t\t\tif (WARN(\"ONE_SEMICOLON\",\n\t\t\t\t \"Statements terminations use 1 semicolon\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(\\s*;\\s*){2,}$/;/g;\n\t\t\t}\n\t\t}\n\n# check for #defines like: 1 << <digit> that could be BIT(digit), it is not exported to uapi\n\t\tif ($realfile !~ m@^include/uapi/@ &&\n\t\t    $line =~ /#\\s*define\\s+\\w+\\s+\\(?\\s*1\\s*([ulUL]*)\\s*\\<\\<\\s*(?:\\d+|$Ident)\\s*\\)?/) {\n\t\t\tmy $ull = \"\";\n\t\t\t$ull = \"_ULL\" if (defined($1) && $1 =~ /ll/i);\n\t\t\tif (CHK(\"BIT_MACRO\",\n\t\t\t\t\"Prefer using the BIT$ull macro\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\(?\\s*1\\s*[ulUL]*\\s*<<\\s*(\\d+|$Ident)\\s*\\)?/BIT${ull}($1)/;\n\t\t\t}\n\t\t}\n\n# check for IS_ENABLED() without CONFIG_<FOO> ($rawline for comments too)\n\t\tif ($rawline =~ /\\bIS_ENABLED\\s*\\(\\s*(\\w+)\\s*\\)/ && $1 !~ /^${CONFIG_}/) {\n\t\t\tWARN(\"IS_ENABLED_CONFIG\",\n\t\t\t     \"IS_ENABLED($1) is normally used as IS_ENABLED(${CONFIG_}$1)\\n\" . $herecurr);\n\t\t}\n\n# check for #if defined CONFIG_<FOO> || defined CONFIG_<FOO>_MODULE\n\t\tif ($line =~ /^\\+\\s*#\\s*if\\s+defined(?:\\s*\\(?\\s*|\\s+)(${CONFIG_}[A-Z_]+)\\s*\\)?\\s*\\|\\|\\s*defined(?:\\s*\\(?\\s*|\\s+)\\1_MODULE\\s*\\)?\\s*$/) {\n\t\t\tmy $config = $1;\n\t\t\tif (WARN(\"PREFER_IS_ENABLED\",\n\t\t\t\t \"Prefer IS_ENABLED(<FOO>) to ${CONFIG_}<FOO> || ${CONFIG_}<FOO>_MODULE\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] = \"\\+#if IS_ENABLED($config)\";\n\t\t\t}\n\t\t}\n\n# check for /* fallthrough */ like comment, prefer fallthrough;\n\t\tmy @fallthroughs = (\n\t\t\t'fallthrough',\n\t\t\t'@fallthrough@',\n\t\t\t'lint -fallthrough[ \\t]*',\n\t\t\t'intentional(?:ly)?[ \\t]*fall(?:(?:s | |-)[Tt]|t)hr(?:ough|u|ew)',\n\t\t\t'(?:else,?\\s*)?FALL(?:S | |-)?THR(?:OUGH|U|EW)[ \\t.!]*(?:-[^\\n\\r]*)?',\n\t\t\t'Fall(?:(?:s | |-)[Tt]|t)hr(?:ough|u|ew)[ \\t.!]*(?:-[^\\n\\r]*)?',\n\t\t\t'fall(?:s | |-)?thr(?:ough|u|ew)[ \\t.!]*(?:-[^\\n\\r]*)?',\n\t\t    );\n\t\tif ($raw_comment ne '') {\n\t\t\tforeach my $ft (@fallthroughs) {\n\t\t\t\tif ($raw_comment =~ /$ft/) {\n\t\t\t\t\tmy $msg_level = \\&WARN;\n\t\t\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t\t\t&{$msg_level}(\"PREFER_FALLTHROUGH\",\n\t\t\t\t\t\t      \"Prefer 'fallthrough;' over fallthrough comment\\n\" . $herecurr);\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for switch/default statements without a break;\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+[$;\\s]*(?:case[$;\\s]+\\w+[$;\\s]*:[$;\\s]*|)*[$;\\s]*\\bdefault[$;\\s]*:[$;\\s]*;/g) {\n\t\t\tmy $cnt = statement_rawlines($stat);\n\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\tWARN(\"DEFAULT_NO_BREAK\",\n\t\t\t     \"switch default: should use break\\n\" . $herectx);\n\t\t}\n\n# check for gcc specific __FUNCTION__\n\t\tif ($line =~ /\\b__FUNCTION__\\b/) {\n\t\t\tif (WARN(\"USE_FUNC\",\n\t\t\t\t \"__func__ should be used instead of gcc specific __FUNCTION__\\n\"  . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\b__FUNCTION__\\b/__func__/g;\n\t\t\t}\n\t\t}\n\n# check for uses of __DATE__, __TIME__, __TIMESTAMP__\n\t\twhile ($line =~ /\\b(__(?:DATE|TIME|TIMESTAMP)__)\\b/g) {\n\t\t\tERROR(\"DATE_TIME\",\n\t\t\t      \"Use of the '$1' macro makes the build non-deterministic\\n\" . $herecurr);\n\t\t}\n\n# check for use of yield()\n\t\tif ($line =~ /\\byield\\s*\\(\\s*\\)/) {\n\t\t\tWARN(\"YIELD\",\n\t\t\t     \"Using yield() is generally wrong. See yield() kernel-doc (sched/core.c)\\n\"  . $herecurr);\n\t\t}\n\n# check for comparisons against true and false\n\t\tif ($line =~ /\\+\\s*(.*?)\\b(true|false|$Lval)\\s*(==|\\!=)\\s*(true|false|$Lval)\\b(.*)$/i) {\n\t\t\tmy $lead = $1;\n\t\t\tmy $arg = $2;\n\t\t\tmy $test = $3;\n\t\t\tmy $otype = $4;\n\t\t\tmy $trail = $5;\n\t\t\tmy $op = \"!\";\n\n\t\t\t($arg, $otype) = ($otype, $arg) if ($arg =~ /^(?:true|false)$/i);\n\n\t\t\tmy $type = lc($otype);\n\t\t\tif ($type =~ /^(?:true|false)$/) {\n\t\t\t\tif ((\"$test\" eq \"==\" && \"$type\" eq \"true\") ||\n\t\t\t\t    (\"$test\" eq \"!=\" && \"$type\" eq \"false\")) {\n\t\t\t\t\t$op = \"\";\n\t\t\t\t}\n\n\t\t\t\tCHK(\"BOOL_COMPARISON\",\n\t\t\t\t    \"Using comparison to $otype is error prone\\n\" . $herecurr);\n\n## maybe suggesting a correct construct would better\n##\t\t\t\t    \"Using comparison to $otype is error prone.  Perhaps use '${lead}${op}${arg}${trail}'\\n\" . $herecurr);\n\n\t\t\t}\n\t\t}\n\n# check for semaphores initialized locked\n\t\tif ($line =~ /^.\\s*sema_init.+,\\W?0\\W?\\)/) {\n\t\t\tWARN(\"CONSIDER_COMPLETION\",\n\t\t\t     \"consider using a completion\\n\" . $herecurr);\n\t\t}\n\n# recommend kstrto* over simple_strto* and strict_strto*\n\t\tif ($line =~ /\\b((simple|strict)_(strto(l|ll|ul|ull)))\\s*\\(/) {\n\t\t\tWARN(\"CONSIDER_KSTRTO\",\n\t\t\t     \"$1 is obsolete, use k$3 instead\\n\" . $herecurr);\n\t\t}\n\n# check for __initcall(), use device_initcall() explicitly or more appropriate function please\n\t\tif ($line =~ /^.\\s*__initcall\\s*\\(/) {\n\t\t\tWARN(\"USE_DEVICE_INITCALL\",\n\t\t\t     \"please use device_initcall() or more appropriate function instead of __initcall() (see include/linux/init.h)\\n\" . $herecurr);\n\t\t}\n\n# check for spin_is_locked(), suggest lockdep instead\n\t\tif ($line =~ /\\bspin_is_locked\\(/) {\n\t\t\tWARN(\"USE_LOCKDEP\",\n\t\t\t     \"Where possible, use lockdep_assert_held instead of assertions based on spin_is_locked\\n\" . $herecurr);\n\t\t}\n\n# check for deprecated apis\n\t\tif ($line =~ /\\b($deprecated_apis_search)\\b\\s*\\(/) {\n\t\t\tmy $deprecated_api = $1;\n\t\t\tmy $new_api = $deprecated_apis{$deprecated_api};\n\t\t\tWARN(\"DEPRECATED_API\",\n\t\t\t     \"Deprecated use of '$deprecated_api', prefer '$new_api' instead\\n\" . $herecurr);\n\t\t}\n\n# check for various structs that are normally const (ops, kgdb, device_tree)\n# and avoid what seem like struct definitions 'struct foo {'\n\t\tif (defined($const_structs) &&\n\t\t    $line !~ /\\bconst\\b/ &&\n\t\t    $line =~ /\\bstruct\\s+($const_structs)\\b(?!\\s*\\{)/) {\n\t\t\tWARN(\"CONST_STRUCT\",\n\t\t\t     \"struct $1 should normally be const\\n\" . $herecurr);\n\t\t}\n\n# use of NR_CPUS is usually wrong\n# ignore definitions of NR_CPUS and usage to define arrays as likely right\n# ignore designated initializers using NR_CPUS\n\t\tif ($line =~ /\\bNR_CPUS\\b/ &&\n\t\t    $line !~ /^.\\s*\\s*#\\s*if\\b.*\\bNR_CPUS\\b/ &&\n\t\t    $line !~ /^.\\s*\\s*#\\s*define\\b.*\\bNR_CPUS\\b/ &&\n\t\t    $line !~ /^.\\s*$Declare\\s.*\\[[^\\]]*NR_CPUS[^\\]]*\\]/ &&\n\t\t    $line !~ /\\[[^\\]]*\\.\\.\\.[^\\]]*NR_CPUS[^\\]]*\\]/ &&\n\t\t    $line !~ /\\[[^\\]]*NR_CPUS[^\\]]*\\.\\.\\.[^\\]]*\\]/ &&\n\t\t    $line !~ /^.\\s*\\.\\w+\\s*=\\s*.*\\bNR_CPUS\\b/)\n\t\t{\n\t\t\tWARN(\"NR_CPUS\",\n\t\t\t     \"usage of NR_CPUS is often wrong - consider using cpu_possible(), num_possible_cpus(), for_each_possible_cpu(), etc\\n\" . $herecurr);\n\t\t}\n\n# Use of __ARCH_HAS_<FOO> or ARCH_HAVE_<BAR> is wrong.\n\t\tif ($line =~ /\\+\\s*#\\s*define\\s+((?:__)?ARCH_(?:HAS|HAVE)\\w*)\\b/) {\n\t\t\tERROR(\"DEFINE_ARCH_HAS\",\n\t\t\t      \"#define of '$1' is wrong - use Kconfig variables or standard guards instead\\n\" . $herecurr);\n\t\t}\n\n# likely/unlikely comparisons similar to \"(likely(foo) > 0)\"\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /\\b((?:un)?likely)\\s*\\(\\s*$FuncArg\\s*\\)\\s*$Compare/) {\n\t\t\tWARN(\"LIKELY_MISUSE\",\n\t\t\t     \"Using $1 should generally have parentheses around the comparison\\n\" . $herecurr);\n\t\t}\n\n# return sysfs_emit(foo, fmt, ...) fmt without newline\n\t\tif ($line =~ /\\breturn\\s+sysfs_emit\\s*\\(\\s*$FuncArg\\s*,\\s*($String)/ &&\n\t\t    substr($rawline, $-[6], $+[6] - $-[6]) !~ /\\\\n\"$/) {\n\t\t\tmy $offset = $+[6] - 1;\n\t\t\tif (WARN(\"SYSFS_EMIT\",\n\t\t\t\t \"return sysfs_emit(...) formats should include a terminating newline\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tsubstr($fixed[$fixlinenr], $offset, 0) = '\\\\n';\n\t\t\t}\n\t\t}\n\n# check for array definition/declarations that should use flexible arrays instead\n\t\tif ($sline =~ /^[\\+ ]\\s*\\}(?:\\s*__packed)?\\s*;\\s*$/ &&\n\t\t    $prevline =~ /^\\+\\s*(?:\\}(?:\\s*__packed\\s*)?|$Type)\\s*$Ident\\s*\\[\\s*(0|1)\\s*\\]\\s*;\\s*$/) {\n\t\t\tif (ERROR(\"FLEXIBLE_ARRAY\",\n\t\t\t\t  \"Use C99 flexible arrays - see https://docs.kernel.org/process/deprecated.html#zero-length-and-one-element-arrays\\n\" . $hereprev) &&\n\t\t\t    $1 == '0' && $fix) {\n\t\t\t\t$fixed[$fixlinenr - 1] =~ s/\\[\\s*0\\s*\\]/[]/;\n\t\t\t}\n\t\t}\n\n# nested likely/unlikely calls\n\t\tif ($line =~ /\\b(?:(?:un)?likely)\\s*\\(\\s*!?\\s*(IS_ERR(?:_OR_NULL|_VALUE)?|WARN)/) {\n\t\t\tWARN(\"LIKELY_MISUSE\",\n\t\t\t     \"nested (un)?likely() calls, $1 already uses unlikely() internally\\n\" . $herecurr);\n\t\t}\n\n# whine mightly about in_atomic\n\t\tif ($line =~ /\\bin_atomic\\s*\\(/) {\n\t\t\tif ($realfile =~ m@^drivers/@) {\n\t\t\t\tERROR(\"IN_ATOMIC\",\n\t\t\t\t      \"do not use in_atomic in drivers\\n\" . $herecurr);\n\t\t\t} elsif ($realfile !~ m@^kernel/@) {\n\t\t\t\tWARN(\"IN_ATOMIC\",\n\t\t\t\t     \"use of in_atomic() is incorrect outside core kernel code\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Complain about RCU Tasks Trace used outside of BPF (and of course, RCU).\n\t\tour $rcu_trace_funcs = qr{(?x:\n\t\t\trcu_read_lock_trace |\n\t\t\trcu_read_lock_trace_held |\n\t\t\trcu_read_unlock_trace |\n\t\t\tcall_rcu_tasks_trace |\n\t\t\tsynchronize_rcu_tasks_trace |\n\t\t\trcu_barrier_tasks_trace |\n\t\t\trcu_request_urgent_qs_task\n\t\t)};\n\t\tour $rcu_trace_paths = qr{(?x:\n\t\t\tkernel/bpf/ |\n\t\t\tinclude/linux/bpf |\n\t\t\tnet/bpf/ |\n\t\t\tkernel/rcu/ |\n\t\t\tinclude/linux/rcu\n\t\t)};\n\t\tif ($line =~ /\\b($rcu_trace_funcs)\\s*\\(/) {\n\t\t\tif ($realfile !~ m{^$rcu_trace_paths}) {\n\t\t\t\tWARN(\"RCU_TASKS_TRACE\",\n\t\t\t\t     \"use of RCU tasks trace is incorrect outside BPF or core RCU code\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for lockdep_set_novalidate_class\n\t\tif ($line =~ /^.\\s*lockdep_set_novalidate_class\\s*\\(/ ||\n\t\t    $line =~ /__lockdep_no_validate__\\s*\\)/ ) {\n\t\t\tif ($realfile !~ m@^kernel/lockdep@ &&\n\t\t\t    $realfile !~ m@^include/linux/lockdep@ &&\n\t\t\t    $realfile !~ m@^drivers/base/core@) {\n\t\t\t\tERROR(\"LOCKDEP\",\n\t\t\t\t      \"lockdep_no_validate class is reserved for device->mutex.\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n\t\tif ($line =~ /debugfs_create_\\w+.*\\b$mode_perms_world_writable\\b/ ||\n\t\t    $line =~ /DEVICE_ATTR.*\\b$mode_perms_world_writable\\b/) {\n\t\t\tWARN(\"EXPORTED_WORLD_WRITABLE\",\n\t\t\t     \"Exporting world writable files is usually an error. Consider more restrictive permissions.\\n\" . $herecurr);\n\t\t}\n\n# check for DEVICE_ATTR uses that could be DEVICE_ATTR_<FOO>\n# and whether or not function naming is typical and if\n# DEVICE_ATTR permissions uses are unusual too\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /\\bDEVICE_ATTR\\s*\\(\\s*(\\w+)\\s*,\\s*\\(?\\s*(\\s*(?:${multi_mode_perms_string_search}|0[0-7]{3,3})\\s*)\\s*\\)?\\s*,\\s*(\\w+)\\s*,\\s*(\\w+)\\s*\\)/) {\n\t\t\tmy $var = $1;\n\t\t\tmy $perms = $2;\n\t\t\tmy $show = $3;\n\t\t\tmy $store = $4;\n\t\t\tmy $octal_perms = perms_to_octal($perms);\n\t\t\tif ($show =~ /^${var}_show$/ &&\n\t\t\t    $store =~ /^${var}_store$/ &&\n\t\t\t    $octal_perms eq \"0644\") {\n\t\t\t\tif (WARN(\"DEVICE_ATTR_RW\",\n\t\t\t\t\t \"Use DEVICE_ATTR_RW\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bDEVICE_ATTR\\s*\\(\\s*$var\\s*,\\s*\\Q$perms\\E\\s*,\\s*$show\\s*,\\s*$store\\s*\\)/DEVICE_ATTR_RW(${var})/;\n\t\t\t\t}\n\t\t\t} elsif ($show =~ /^${var}_show$/ &&\n\t\t\t\t $store =~ /^NULL$/ &&\n\t\t\t\t $octal_perms eq \"0444\") {\n\t\t\t\tif (WARN(\"DEVICE_ATTR_RO\",\n\t\t\t\t\t \"Use DEVICE_ATTR_RO\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bDEVICE_ATTR\\s*\\(\\s*$var\\s*,\\s*\\Q$perms\\E\\s*,\\s*$show\\s*,\\s*NULL\\s*\\)/DEVICE_ATTR_RO(${var})/;\n\t\t\t\t}\n\t\t\t} elsif ($show =~ /^NULL$/ &&\n\t\t\t\t $store =~ /^${var}_store$/ &&\n\t\t\t\t $octal_perms eq \"0200\") {\n\t\t\t\tif (WARN(\"DEVICE_ATTR_WO\",\n\t\t\t\t\t \"Use DEVICE_ATTR_WO\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bDEVICE_ATTR\\s*\\(\\s*$var\\s*,\\s*\\Q$perms\\E\\s*,\\s*NULL\\s*,\\s*$store\\s*\\)/DEVICE_ATTR_WO(${var})/;\n\t\t\t\t}\n\t\t\t} elsif ($octal_perms eq \"0644\" ||\n\t\t\t\t $octal_perms eq \"0444\" ||\n\t\t\t\t $octal_perms eq \"0200\") {\n\t\t\t\tmy $newshow = \"$show\";\n\t\t\t\t$newshow = \"${var}_show\" if ($show ne \"NULL\" && $show ne \"${var}_show\");\n\t\t\t\tmy $newstore = $store;\n\t\t\t\t$newstore = \"${var}_store\" if ($store ne \"NULL\" && $store ne \"${var}_store\");\n\t\t\t\tmy $rename = \"\";\n\t\t\t\tif ($show ne $newshow) {\n\t\t\t\t\t$rename .= \" '$show' to '$newshow'\";\n\t\t\t\t}\n\t\t\t\tif ($store ne $newstore) {\n\t\t\t\t\t$rename .= \" '$store' to '$newstore'\";\n\t\t\t\t}\n\t\t\t\tWARN(\"DEVICE_ATTR_FUNCTIONS\",\n\t\t\t\t     \"Consider renaming function(s)$rename\\n\" . $herecurr);\n\t\t\t} else {\n\t\t\t\tWARN(\"DEVICE_ATTR_PERMS\",\n\t\t\t\t     \"DEVICE_ATTR unusual permissions '$perms' used\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Mode permission misuses where it seems decimal should be octal\n# This uses a shortcut match to avoid unnecessary uses of a slow foreach loop\n# o Ignore module_param*(...) uses with a decimal 0 permission as that has a\n#   specific definition of not visible in sysfs.\n# o Ignore proc_create*(...) uses with a decimal 0 permission as that means\n#   use the default permissions\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $line =~ /$mode_perms_search/) {\n\t\t\tforeach my $entry (@mode_permission_funcs) {\n\t\t\t\tmy $func = $entry->[0];\n\t\t\t\tmy $arg_pos = $entry->[1];\n\n\t\t\t\tmy $lc = $stat =~ tr@\\n@@;\n\t\t\t\t$lc = $lc + $linenr;\n\t\t\t\tmy $stat_real = get_stat_real($linenr, $lc);\n\n\t\t\t\tmy $skip_args = \"\";\n\t\t\t\tif ($arg_pos > 1) {\n\t\t\t\t\t$arg_pos--;\n\t\t\t\t\t$skip_args = \"(?:\\\\s*$FuncArg\\\\s*,\\\\s*){$arg_pos,$arg_pos}\";\n\t\t\t\t}\n\t\t\t\tmy $test = \"\\\\b$func\\\\s*\\\\(${skip_args}($FuncArg(?:\\\\|\\\\s*$FuncArg)*)\\\\s*[,\\\\)]\";\n\t\t\t\tif ($stat =~ /$test/) {\n\t\t\t\t\tmy $val = $1;\n\t\t\t\t\t$val = $6 if ($skip_args ne \"\");\n\t\t\t\t\tif (!($func =~ /^(?:module_param|proc_create)/ && $val eq \"0\") &&\n\t\t\t\t\t    (($val =~ /^$Int$/ && $val !~ /^$Octal$/) ||\n\t\t\t\t\t     ($val =~ /^$Octal$/ && length($val) ne 4))) {\n\t\t\t\t\t\tERROR(\"NON_OCTAL_PERMISSIONS\",\n\t\t\t\t\t\t      \"Use 4 digit octal (0777) not decimal permissions\\n\" . \"$here\\n\" . $stat_real);\n\t\t\t\t\t}\n\t\t\t\t\tif ($val =~ /^$Octal$/ && (oct($val) & 02)) {\n\t\t\t\t\t\tERROR(\"EXPORTED_WORLD_WRITABLE\",\n\t\t\t\t\t\t      \"Exporting writable files is usually an error. Consider more restrictive permissions.\\n\" . \"$here\\n\" . $stat_real);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for uses of S_<PERMS> that could be octal for readability\n\t\twhile ($line =~ m{\\b($multi_mode_perms_string_search)\\b}g) {\n\t\t\tmy $oval = $1;\n\t\t\tmy $octal = perms_to_octal($oval);\n\t\t\tif (WARN(\"SYMBOLIC_PERMS\",\n\t\t\t\t \"Symbolic permissions '$oval' are not preferred. Consider using octal permissions '$octal'.\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$oval\\E/$octal/;\n\t\t\t}\n\t\t}\n\n# validate content of MODULE_LICENSE against list from include/linux/module.h\n\t\tif ($line =~ /\\bMODULE_LICENSE\\s*\\(\\s*($String)\\s*\\)/) {\n\t\t\tmy $extracted_string = get_quoted_string($line, $rawline);\n\t\t\tmy $valid_licenses = qr{\n\t\t\t\t\t\tGPL|\n\t\t\t\t\t\tGPL\\ v2|\n\t\t\t\t\t\tGPL\\ and\\ additional\\ rights|\n\t\t\t\t\t\tDual\\ BSD/GPL|\n\t\t\t\t\t\tDual\\ MIT/GPL|\n\t\t\t\t\t\tDual\\ MPL/GPL|\n\t\t\t\t\t\tProprietary\n\t\t\t\t\t}x;\n\t\t\tif ($extracted_string !~ /^\"(?:$valid_licenses)\"$/x) {\n\t\t\t\tWARN(\"MODULE_LICENSE\",\n\t\t\t\t     \"unknown module license \" . $extracted_string . \"\\n\" . $herecurr);\n\t\t\t}\n\t\t\tif (!$file && $extracted_string eq '\"GPL v2\"') {\n\t\t\t\tif (WARN(\"MODULE_LICENSE\",\n\t\t\t\t     \"Prefer \\\"GPL\\\" over \\\"GPL v2\\\" - see commit bf7fbeeae6db (\\\"module: Cure the MODULE_LICENSE \\\"GPL\\\" vs. \\\"GPL v2\\\" bogosity\\\")\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bMODULE_LICENSE\\s*\\(\\s*\"GPL v2\"\\s*\\)/MODULE_LICENSE(\"GPL\")/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for sysctl duplicate constants\n\t\tif ($line =~ /\\.extra[12]\\s*=\\s*&(zero|one|int_max)\\b/) {\n\t\t\tWARN(\"DUPLICATED_SYSCTL_CONST\",\n\t\t\t\t\"duplicated sysctl range checking value '$1', consider using the shared one in include/linux/sysctl.h\\n\" . $herecurr);\n\t\t}\n\t}\n\n\t# If we have no input at all, then there is nothing to report on\n\t# so just keep quiet.\n\tif ($#rawlines == -1) {\n\t\texit(0);\n\t}\n\n\t# In mailback mode only produce a report in the negative, for\n\t# things that appear to be patches.\n\tif ($mailback && ($clean == 1 || !$is_patch)) {\n\t\texit(0);\n\t}\n\n\t# This is not a patch, and we are in 'no-patch' mode so\n\t# just keep quiet.\n\tif (!$chk_patch && !$is_patch) {\n\t\texit(0);\n\t}\n\n\tif (!$is_patch && $filename !~ /cover-letter\\.patch$/) {\n\t\tERROR(\"NOT_UNIFIED_DIFF\",\n\t\t      \"Does not appear to be a unified-diff format patch\\n\");\n\t}\n\tif ($is_patch && $has_commit_log && $chk_signoff) {\n\t\tif ($signoff == 0) {\n\t\t\tERROR(\"MISSING_SIGN_OFF\",\n\t\t\t      \"Missing Signed-off-by: line(s)\\n\");\n\t\t} elsif ($authorsignoff != 1) {\n\t\t\t# authorsignoff values:\n\t\t\t# 0 -> missing sign off\n\t\t\t# 1 -> sign off identical\n\t\t\t# 2 -> names and addresses match, comments mismatch\n\t\t\t# 3 -> addresses match, names different\n\t\t\t# 4 -> names match, addresses different\n\t\t\t# 5 -> names match, addresses excluding subaddress details (refer RFC 5233) match\n\n\t\t\tmy $sob_msg = \"'From: $author' != 'Signed-off-by: $author_sob'\";\n\n\t\t\tif ($authorsignoff == 0) {\n\t\t\t\tERROR(\"NO_AUTHOR_SIGN_OFF\",\n\t\t\t\t      \"Missing Signed-off-by: line by nominal patch author '$author'\\n\");\n\t\t\t} elsif ($authorsignoff == 2) {\n\t\t\t\tCHK(\"FROM_SIGN_OFF_MISMATCH\",\n\t\t\t\t    \"From:/Signed-off-by: email comments mismatch: $sob_msg\\n\");\n\t\t\t} elsif ($authorsignoff == 3) {\n\t\t\t\tWARN(\"FROM_SIGN_OFF_MISMATCH\",\n\t\t\t\t     \"From:/Signed-off-by: email name mismatch: $sob_msg\\n\");\n\t\t\t} elsif ($authorsignoff == 4) {\n\t\t\t\tWARN(\"FROM_SIGN_OFF_MISMATCH\",\n\t\t\t\t     \"From:/Signed-off-by: email address mismatch: $sob_msg\\n\");\n\t\t\t} elsif ($authorsignoff == 5) {\n\t\t\t\tWARN(\"FROM_SIGN_OFF_MISMATCH\",\n\t\t\t\t     \"From:/Signed-off-by: email subaddress mismatch: $sob_msg\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprint report_dump();\n\tif ($summary && !($clean == 1 && $quiet == 1)) {\n\t\tprint \"$filename \" if ($summary_file);\n\t\tprint \"total: $cnt_error errors, $cnt_warn warnings, \" .\n\t\t\t(($check)? \"$cnt_chk checks, \" : \"\") .\n\t\t\t\"$cnt_lines lines checked\\n\";\n\t}\n\n\tif ($quiet == 0) {\n\t\t# If there were any defects found and not already fixing them\n\t\tif (!$clean and !$fix) {\n\t\t\tprint << \"EOM\"\n\nNOTE: For some of the reported defects, checkpatch may be able to\n      mechanically convert to the typical style using --fix or --fix-inplace.\nEOM\n\t\t}\n\t\t# If there were whitespace errors which cleanpatch can fix\n\t\t# then suggest that.\n\t\tif ($rpt_cleaners) {\n\t\t\t$rpt_cleaners = 0;\n\t\t\tprint << \"EOM\"\n\nNOTE: Whitespace errors detected.\n      You may wish to use scripts/cleanpatch or scripts/cleanfile\nEOM\n\t\t}\n\t}\n\n\tif ($clean == 0 && $fix &&\n\t    (\"@rawlines\" ne \"@fixed\" ||\n\t     $#fixed_inserted >= 0 || $#fixed_deleted >= 0)) {\n\t\tmy $newfile = $filename;\n\t\t$newfile .= \".EXPERIMENTAL-checkpatch-fixes\" if (!$fix_inplace);\n\t\tmy $linecount = 0;\n\t\tmy $f;\n\n\t\t@fixed = fix_inserted_deleted_lines(\\@fixed, \\@fixed_inserted, \\@fixed_deleted);\n\n\t\topen($f, '>', $newfile)\n\t\t    or die \"$P: Can't open $newfile for write\\n\";\n\t\tforeach my $fixed_line (@fixed) {\n\t\t\t$linecount++;\n\t\t\tif ($file) {\n\t\t\t\tif ($linecount > 3) {\n\t\t\t\t\t$fixed_line =~ s/^\\+//;\n\t\t\t\t\tprint $f $fixed_line . \"\\n\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint $f $fixed_line . \"\\n\";\n\t\t\t}\n\t\t}\n\t\tclose($f);\n\n\t\tif (!$quiet) {\n\t\t\tprint << \"EOM\";\n\nWrote EXPERIMENTAL --fix correction(s) to '$newfile'\n\nDo _NOT_ trust the results written to this file.\nDo _NOT_ submit these changes without inspecting them for correctness.\n\nThis EXPERIMENTAL file is simply a convenience to help rewrite patches.\nNo warranties, expressed or implied...\nEOM\n\t\t}\n\t}\n\n\tif ($quiet == 0) {\n\t\tprint \"\\n\";\n\t\tif ($clean == 1) {\n\t\t\tprint \"$vname has no obvious style problems and is ready for submission.\\n\";\n\t\t} else {\n\t\t\tprint \"$vname has style problems, please review.\\n\";\n\t\t}\n\t}\n\treturn $clean;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}