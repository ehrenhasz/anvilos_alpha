{
  "module_name": "get_abi.pl",
  "hash_id": "acaa0fbca7028f19abf188dc740d2660aa2eab6f821901c1bbe43c68b2da6cf6",
  "original_prompt": "Ingested from linux-6.6.14/scripts/get_abi.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n\nBEGIN { $Pod::Usage::Formatter = 'Pod::Text::Termcap'; }\n\nuse strict;\nuse warnings;\nuse utf8;\nuse Pod::Usage qw(pod2usage);\nuse Getopt::Long;\nuse File::Find;\nuse IO::Handle;\nuse Fcntl ':mode';\nuse Cwd 'abs_path';\nuse Data::Dumper;\n\nmy $help = 0;\nmy $hint = 0;\nmy $man = 0;\nmy $debug = 0;\nmy $enable_lineno = 0;\nmy $show_warnings = 1;\nmy $prefix=\"Documentation/ABI\";\nmy $sysfs_prefix=\"/sys\";\nmy $search_string;\n\n# Debug options\nmy $dbg_what_parsing = 1;\nmy $dbg_what_open = 2;\nmy $dbg_dump_abi_structs = 4;\nmy $dbg_undefined = 8;\n\n$Data::Dumper::Indent = 1;\n$Data::Dumper::Terse = 1;\n\n#\n# If true, assumes that the description is formatted with ReST\n#\nmy $description_is_rst = 1;\n\nGetOptions(\n\t\"debug=i\" => \\$debug,\n\t\"enable-lineno\" => \\$enable_lineno,\n\t\"rst-source!\" => \\$description_is_rst,\n\t\"dir=s\" => \\$prefix,\n\t'help|?' => \\$help,\n\t\"show-hints\" => \\$hint,\n\t\"search-string=s\" => \\$search_string,\n\tman => \\$man\n) or pod2usage(2);\n\npod2usage(1) if $help;\npod2usage(-exitstatus => 0, -noperldoc, -verbose => 2) if $man;\n\npod2usage(2) if (scalar @ARGV < 1 || @ARGV > 2);\n\nmy ($cmd, $arg) = @ARGV;\n\npod2usage(2) if ($cmd ne \"search\" && $cmd ne \"rest\" && $cmd ne \"validate\" && $cmd ne \"undefined\");\npod2usage(2) if ($cmd eq \"search\" && !$arg);\n\nrequire Data::Dumper if ($debug & $dbg_dump_abi_structs);\n\nmy %data;\nmy %symbols;\n\n#\n# Displays an error message, printing file name and line\n#\nsub parse_error($$$$) {\n\tmy ($file, $ln, $msg, $data) = @_;\n\n\treturn if (!$show_warnings);\n\n\t$data =~ s/\\s+$/\\n/;\n\n\tprint STDERR \"Warning: file $file#$ln:\\n\\t$msg\";\n\n\tif ($data ne \"\") {\n\t\tprint STDERR \". Line\\n\\t\\t$data\";\n\t} else {\n\t    print STDERR \"\\n\";\n\t}\n}\n\n#\n# Parse an ABI file, storing its contents at %data\n#\nsub parse_abi {\n\tmy $file = $File::Find::name;\n\n\tmy $mode = (stat($file))[2];\n\treturn if ($mode & S_IFDIR);\n\treturn if ($file =~ m,/README,);\n\treturn if ($file =~ m,/\\.,);\n\n\tmy $name = $file;\n\t$name =~ s,.*/,,;\n\n\tmy $fn = $file;\n\t$fn =~ s,Documentation/ABI/,,;\n\n\tmy $nametag = \"File $fn\";\n\t$data{$nametag}->{what} = \"File $name\";\n\t$data{$nametag}->{type} = \"File\";\n\t$data{$nametag}->{file} = $name;\n\t$data{$nametag}->{filepath} = $file;\n\t$data{$nametag}->{is_file} = 1;\n\t$data{$nametag}->{line_no} = 1;\n\n\tmy $type = $file;\n\t$type =~ s,.*/(.*)/.*,$1,;\n\n\tmy $what;\n\tmy $new_what;\n\tmy $tag = \"\";\n\tmy $ln;\n\tmy $xrefs;\n\tmy $space;\n\tmy @labels;\n\tmy $label = \"\";\n\n\tprint STDERR \"Opening $file\\n\" if ($debug & $dbg_what_open);\n\topen IN, $file;\n\twhile(<IN>) {\n\t\t$ln++;\n\t\tif (m/^(\\S+)(:\\s*)(.*)/i) {\n\t\t\tmy $new_tag = lc($1);\n\t\t\tmy $sep = $2;\n\t\t\tmy $content = $3;\n\n\t\t\tif (!($new_tag =~ m/(what|where|date|kernelversion|contact|description|users)/)) {\n\t\t\t\tif ($tag eq \"description\") {\n\t\t\t\t\t# New \"tag\" is actually part of\n\t\t\t\t\t# description. Don't consider it a tag\n\t\t\t\t\t$new_tag = \"\";\n\t\t\t\t} elsif ($tag ne \"\") {\n\t\t\t\t\tparse_error($file, $ln, \"tag '$tag' is invalid\", $_);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# Invalid, but it is a common mistake\n\t\t\tif ($new_tag eq \"where\") {\n\t\t\t\tparse_error($file, $ln, \"tag 'Where' is invalid. Should be 'What:' instead\", \"\");\n\t\t\t\t$new_tag = \"what\";\n\t\t\t}\n\n\t\t\tif ($new_tag =~ m/what/) {\n\t\t\t\t$space = \"\";\n\t\t\t\t$content =~ s/[,.;]$//;\n\n\t\t\t\tpush @{$symbols{$content}->{file}}, \" $file:\" . ($ln - 1);\n\n\t\t\t\tif ($tag =~ m/what/) {\n\t\t\t\t\t$what .= \"\\xac\" . $content;\n\t\t\t\t} else {\n\t\t\t\t\tif ($what) {\n\t\t\t\t\t\tparse_error($file, $ln, \"What '$what' doesn't have a description\", \"\") if (!$data{$what}->{description});\n\n\t\t\t\t\t\tforeach my $w(split /\\xac/, $what) {\n\t\t\t\t\t\t\t$symbols{$w}->{xref} = $what;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t$what = $content;\n\t\t\t\t\t$label = $content;\n\t\t\t\t\t$new_what = 1;\n\t\t\t\t}\n\t\t\t\tpush @labels, [($content, $label)];\n\t\t\t\t$tag = $new_tag;\n\n\t\t\t\tpush @{$data{$nametag}->{symbols}}, $content if ($data{$nametag}->{what});\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\tif ($tag ne \"\" && $new_tag) {\n\t\t\t\t$tag = $new_tag;\n\n\t\t\t\tif ($new_what) {\n\t\t\t\t\t@{$data{$what}->{label_list}} = @labels if ($data{$nametag}->{what});\n\t\t\t\t\t@labels = ();\n\t\t\t\t\t$label = \"\";\n\t\t\t\t\t$new_what = 0;\n\n\t\t\t\t\t$data{$what}->{type} = $type;\n\t\t\t\t\tif (!defined($data{$what}->{file})) {\n\t\t\t\t\t\t$data{$what}->{file} = $name;\n\t\t\t\t\t\t$data{$what}->{filepath} = $file;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$data{$what}->{description} .= \"\\n\\n\" if (defined($data{$what}->{description}));\n\t\t\t\t\t\tif ($name ne $data{$what}->{file}) {\n\t\t\t\t\t\t\t$data{$what}->{file} .= \" \" . $name;\n\t\t\t\t\t\t\t$data{$what}->{filepath} .= \" \" . $file;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprint STDERR \"\\twhat: $what\\n\" if ($debug & $dbg_what_parsing);\n\t\t\t\t\t$data{$what}->{line_no} = $ln;\n\t\t\t\t} else {\n\t\t\t\t\t$data{$what}->{line_no} = $ln if (!defined($data{$what}->{line_no}));\n\t\t\t\t}\n\n\t\t\t\tif (!$what) {\n\t\t\t\t\tparse_error($file, $ln, \"'What:' should come first:\", $_);\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tif ($new_tag eq \"description\") {\n\t\t\t\t\t$sep =~ s,:, ,;\n\t\t\t\t\t$content = ' ' x length($new_tag) . $sep . $content;\n\t\t\t\t\twhile ($content =~ s/\\t+/' ' x (length($&) * 8 - length($`) % 8)/e) {}\n\t\t\t\t\tif ($content =~ m/^(\\s*)(\\S.*)$/) {\n\t\t\t\t\t\t# Preserve initial spaces for the first line\n\t\t\t\t\t\t$space = $1;\n\t\t\t\t\t\t$content = \"$2\\n\";\n\t\t\t\t\t\t$data{$what}->{$tag} .= $content;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tundef($space);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t$data{$what}->{$tag} = $content;\n\t\t\t\t}\n\t\t\t\tnext;\n\t\t\t}\n\t\t}\n\n\t\t# Store any contents before tags at the database\n\t\tif (!$tag && $data{$nametag}->{what}) {\n\t\t\t$data{$nametag}->{description} .= $_;\n\t\t\tnext;\n\t\t}\n\n\t\tif ($tag eq \"description\") {\n\t\t\tmy $content = $_;\n\t\t\twhile ($content =~ s/\\t+/' ' x (length($&) * 8 - length($`) % 8)/e) {}\n\t\t\tif (m/^\\s*\\n/) {\n\t\t\t\t$data{$what}->{$tag} .= \"\\n\";\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\tif (!defined($space)) {\n\t\t\t\t# Preserve initial spaces for the first line\n\t\t\t\tif ($content =~ m/^(\\s*)(\\S.*)$/) {\n\t\t\t\t\t$space = $1;\n\t\t\t\t\t$content = \"$2\\n\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$space = \"\" if (!($content =~ s/^($space)//));\n\t\t\t}\n\t\t\t$data{$what}->{$tag} .= $content;\n\n\t\t\tnext;\n\t\t}\n\t\tif (m/^\\s*(.*)/) {\n\t\t\t$data{$what}->{$tag} .= \"\\n$1\";\n\t\t\t$data{$what}->{$tag} =~ s/\\n+$//;\n\t\t\tnext;\n\t\t}\n\n\t\t# Everything else is error\n\t\tparse_error($file, $ln, \"Unexpected content\", $_);\n\t}\n\t$data{$nametag}->{description} =~ s/^\\n+// if ($data{$nametag}->{description});\n\tif ($what) {\n\t\tparse_error($file, $ln, \"What '$what' doesn't have a description\", \"\") if (!$data{$what}->{description});\n\n\t\tforeach my $w(split /\\xac/,$what) {\n\t\t\t$symbols{$w}->{xref} = $what;\n\t\t};\n\t}\n\tclose IN;\n}\n\nsub create_labels {\n\tmy %labels;\n\n\tforeach my $what (keys %data) {\n\t\tnext if ($data{$what}->{file} eq \"File\");\n\n\t\tforeach my $p (@{$data{$what}->{label_list}}) {\n\t\t\tmy ($content, $label) = @{$p};\n\t\t\t$label = \"abi_\" . $label . \" \";\n\t\t\t$label =~ tr/A-Z/a-z/;\n\n\t\t\t# Convert special chars to \"_\"\n\t\t\t$label =~s/([\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xff])/_/g;\n\t\t\t$label =~ s,_+,_,g;\n\t\t\t$label =~ s,_$,,;\n\n\t\t\t# Avoid duplicated labels\n\t\t\twhile (defined($labels{$label})) {\n\t\t\t    my @chars = (\"A\"..\"Z\", \"a\"..\"z\");\n\t\t\t    $label .= $chars[rand @chars];\n\t\t\t}\n\t\t\t$labels{$label} = 1;\n\n\t\t\t$data{$what}->{label} = $label;\n\n\t\t\t# only one label is enough\n\t\t\tlast;\n\t\t}\n\t}\n}\n\n#\n# Outputs the book on ReST format\n#\n\n# \\b doesn't work well with paths. So, we need to define something else:\n# Boundaries are punct characters, spaces and end-of-line\nmy $start = qr {(^|\\s|\\() }x;\nmy $bondary = qr { ([,.:;\\)\\s]|\\z) }x;\nmy $xref_match = qr { $start(\\/(sys|config|proc|dev|kvd)\\/[^,.:;\\)\\s]+)$bondary }x;\nmy $symbols = qr { ([\\x01-\\x08\\x0e-\\x1f\\x21-\\x2f\\x3a-\\x40\\x7b-\\xff]) }x;\n\nsub output_rest {\n\tcreate_labels();\n\n\tmy $part = \"\";\n\n\tforeach my $what (sort {\n\t\t\t\t($data{$a}->{type} eq \"File\") cmp ($data{$b}->{type} eq \"File\") ||\n\t\t\t\t$a cmp $b\n\t\t\t       } keys %data) {\n\t\tmy $type = $data{$what}->{type};\n\n\t\tmy @file = split / /, $data{$what}->{file};\n\t\tmy @filepath = split / /, $data{$what}->{filepath};\n\n\t\tif ($enable_lineno) {\n\t\t\tprintf \".. LINENO %s%s#%s\\n\\n\",\n\t\t\t       $prefix, $file[0],\n\t\t\t       $data{$what}->{line_no};\n\t\t}\n\n\t\tmy $w = $what;\n\n\t\tif ($type ne \"File\") {\n\t\t\tmy $cur_part = $what;\n\t\t\tif ($what =~ '/') {\n\t\t\t\tif ($what =~ m#^(\\/?(?:[\\w\\-]+\\/?){1,2})#) {\n\t\t\t\t\t$cur_part = \"Symbols under $1\";\n\t\t\t\t\t$cur_part =~ s,/$,,;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($cur_part ne \"\" && $part ne $cur_part) {\n\t\t\t    $part = $cur_part;\n\t\t\t    my $bar = $part;\n\t\t\t    $bar =~ s/./-/g;\n\t\t\t    print \"$part\\n$bar\\n\\n\";\n\t\t\t}\n\n\t\t\tprintf \".. _%s:\\n\\n\", $data{$what}->{label};\n\n\t\t\tmy @names = split /\\xac/,$w;\n\t\t\tmy $len = 0;\n\n\t\t\tforeach my $name (@names) {\n\t\t\t\t$name =~ s/$symbols/\\\\$1/g;\n\t\t\t\t$name = \"**$name**\";\n\t\t\t\t$len = length($name) if (length($name) > $len);\n\t\t\t}\n\n\t\t\tprint \"+-\" . \"-\" x $len . \"-+\\n\";\n\t\t\tforeach my $name (@names) {\n\t\t\t\tprintf \"| %s\", $name . \" \" x ($len - length($name)) . \" |\\n\";\n\t\t\t\tprint \"+-\" . \"-\" x $len . \"-+\\n\";\n\t\t\t}\n\n\t\t\tprint \"\\n\";\n\t\t}\n\n\t\tfor (my $i = 0; $i < scalar(@filepath); $i++) {\n\t\t\tmy $path = $filepath[$i];\n\t\t\tmy $f = $file[$i];\n\n\t\t\t$path =~ s,.*/(.*/.*),$1,;;\n\t\t\t$path =~ s,[/\\-],_,g;;\n\t\t\tmy $fileref = \"abi_file_\".$path;\n\n\t\t\tif ($type eq \"File\") {\n\t\t\t\tprint \".. _$fileref:\\n\\n\";\n\t\t\t} else {\n\t\t\t\tprint \"Defined on file :ref:`$f <$fileref>`\\n\\n\";\n\t\t\t}\n\t\t}\n\n\t\tif ($type eq \"File\") {\n\t\t\tmy $bar = $w;\n\t\t\t$bar =~ s/./-/g;\n\t\t\tprint \"$w\\n$bar\\n\\n\";\n\t\t}\n\n\t\tmy $desc = \"\";\n\t\t$desc = $data{$what}->{description} if (defined($data{$what}->{description}));\n\t\t$desc =~ s/\\s+$/\\n/;\n\n\t\tif (!($desc =~ /^\\s*$/)) {\n\t\t\tif ($description_is_rst) {\n\t\t\t\t# Remove title markups from the description\n\t\t\t\t# Having titles inside ABI files will only work if extra\n\t\t\t\t# care would be taken in order to strictly follow the same\n\t\t\t\t# level order for each markup.\n\t\t\t\t$desc =~ s/\\n[\\-\\*\\=\\^\\~]+\\n/\\n\\n/g;\n\n\t\t\t\t# Enrich text by creating cross-references\n\n\t\t\t\tmy $new_desc = \"\";\n\t\t\t\tmy $init_indent = -1;\n\t\t\t\tmy $literal_indent = -1;\n\n\t\t\t\topen(my $fh, \"+<\", \\$desc);\n\t\t\t\twhile (my $d = <$fh>) {\n\t\t\t\t\tmy $indent = $d =~ m/^(\\s+)/;\n\t\t\t\t\tmy $spaces = length($indent);\n\t\t\t\t\t$init_indent = $indent if ($init_indent < 0);\n\t\t\t\t\tif ($literal_indent >= 0) {\n\t\t\t\t\t\tif ($spaces > $literal_indent) {\n\t\t\t\t\t\t\t$new_desc .= $d;\n\t\t\t\t\t\t\tnext;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$literal_indent = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ($d =~ /()::$/ && !($d =~ /^\\s*\\.\\./)) {\n\t\t\t\t\t\t\t$literal_indent = $spaces;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$d =~ s,Documentation/(?!devicetree)(\\S+)\\.rst,:doc:`/$1`,g;\n\n\t\t\t\t\tmy @matches = $d =~ m,Documentation/ABI/([\\w\\/\\-]+),g;\n\t\t\t\t\tforeach my $f (@matches) {\n\t\t\t\t\t\tmy $xref = $f;\n\t\t\t\t\t\tmy $path = $f;\n\t\t\t\t\t\t$path =~ s,.*/(.*/.*),$1,;;\n\t\t\t\t\t\t$path =~ s,[/\\-],_,g;;\n\t\t\t\t\t\t$xref .= \" <abi_file_\" . $path . \">\";\n\t\t\t\t\t\t$d =~ s,\\bDocumentation/ABI/$f\\b,:ref:`$xref`,g;\n\t\t\t\t\t}\n\n\t\t\t\t\t# Seek for cross reference symbols like /sys/...\n\t\t\t\t\t@matches = $d =~ m/$xref_match/g;\n\n\t\t\t\t\tforeach my $s (@matches) {\n\t\t\t\t\t\tnext if (!($s =~ m,/,));\n\t\t\t\t\t\tif (defined($data{$s}) && defined($data{$s}->{label})) {\n\t\t\t\t\t\t\tmy $xref = $s;\n\n\t\t\t\t\t\t\t$xref =~ s/$symbols/\\\\$1/g;\n\t\t\t\t\t\t\t$xref = \":ref:`$xref <\" . $data{$s}->{label} . \">`\";\n\n\t\t\t\t\t\t\t$d =~ s,$start$s$bondary,$1$xref$2,g;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$new_desc .= $d;\n\t\t\t\t}\n\t\t\t\tclose $fh;\n\n\n\t\t\t\tprint \"$new_desc\\n\\n\";\n\t\t\t} else {\n\t\t\t\t$desc =~ s/^\\s+//;\n\n\t\t\t\t# Remove title markups from the description, as they won't work\n\t\t\t\t$desc =~ s/\\n[\\-\\*\\=\\^\\~]+\\n/\\n\\n/g;\n\n\t\t\t\tif ($desc =~ m/\\:\\n/ || $desc =~ m/\\n[\\t ]+/  || $desc =~ m/[\\x00-\\x08\\x0b-\\x1f\\x7b-\\xff]/) {\n\t\t\t\t\t# put everything inside a code block\n\t\t\t\t\t$desc =~ s/\\n/\\n /g;\n\n\t\t\t\t\tprint \"::\\n\\n\";\n\t\t\t\t\tprint \" $desc\\n\\n\";\n\t\t\t\t} else {\n\t\t\t\t\t# Escape any special chars from description\n\t\t\t\t\t$desc =~s/([\\x00-\\x08\\x0b-\\x1f\\x21-\\x2a\\x2d\\x2f\\x3c-\\x40\\x5c\\x5e-\\x60\\x7b-\\xff])/\\\\$1/g;\n\t\t\t\t\tprint \"$desc\\n\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tprint \"DESCRIPTION MISSING for $what\\n\\n\" if (!$data{$what}->{is_file});\n\t\t}\n\n\t\tif ($data{$what}->{symbols}) {\n\t\t\tprintf \"Has the following ABI:\\n\\n\";\n\n\t\t\tforeach my $content(@{$data{$what}->{symbols}}) {\n\t\t\t\tmy $label = $data{$symbols{$content}->{xref}}->{label};\n\n\t\t\t\t# Escape special chars from content\n\t\t\t\t$content =~s/([\\x00-\\x1f\\x21-\\x2f\\x3a-\\x40\\x7b-\\xff])/\\\\$1/g;\n\n\t\t\t\tprint \"- :ref:`$content <$label>`\\n\\n\";\n\t\t\t}\n\t\t}\n\n\t\tif (defined($data{$what}->{users})) {\n\t\t\tmy $users = $data{$what}->{users};\n\n\t\t\t$users =~ s/\\n/\\n\\t/g;\n\t\t\tprintf \"Users:\\n\\t%s\\n\\n\", $users if ($users ne \"\");\n\t\t}\n\n\t}\n}\n\n#\n# Searches for ABI symbols\n#\nsub search_symbols {\n\tforeach my $what (sort keys %data) {\n\t\tnext if (!($what =~ m/($arg)/));\n\n\t\tmy $type = $data{$what}->{type};\n\t\tnext if ($type eq \"File\");\n\n\t\tmy $file = $data{$what}->{filepath};\n\n\t\t$what =~ s/\\xac/, /g;\n\t\tmy $bar = $what;\n\t\t$bar =~ s/./-/g;\n\n\t\tprint \"\\n$what\\n$bar\\n\\n\";\n\n\t\tmy $kernelversion = $data{$what}->{kernelversion} if (defined($data{$what}->{kernelversion}));\n\t\tmy $contact = $data{$what}->{contact} if (defined($data{$what}->{contact}));\n\t\tmy $users = $data{$what}->{users} if (defined($data{$what}->{users}));\n\t\tmy $date = $data{$what}->{date} if (defined($data{$what}->{date}));\n\t\tmy $desc = $data{$what}->{description} if (defined($data{$what}->{description}));\n\n\t\t$kernelversion =~ s/^\\s+// if ($kernelversion);\n\t\t$contact =~ s/^\\s+// if ($contact);\n\t\tif ($users) {\n\t\t\t$users =~ s/^\\s+//;\n\t\t\t$users =~ s/\\n//g;\n\t\t}\n\t\t$date =~ s/^\\s+// if ($date);\n\t\t$desc =~ s/^\\s+// if ($desc);\n\n\t\tprintf \"Kernel version:\\t\\t%s\\n\", $kernelversion if ($kernelversion);\n\t\tprintf \"Date:\\t\\t\\t%s\\n\", $date if ($date);\n\t\tprintf \"Contact:\\t\\t%s\\n\", $contact if ($contact);\n\t\tprintf \"Users:\\t\\t\\t%s\\n\", $users if ($users);\n\t\tprint \"Defined on file(s):\\t$file\\n\\n\";\n\t\tprint \"Description:\\n\\n$desc\";\n\t}\n}\n\n# Exclude /sys/kernel/debug and /sys/kernel/tracing from the search path\nsub dont_parse_special_attributes {\n\tif (($File::Find::dir =~ m,^/sys/kernel,)) {\n\t\treturn grep {!/(debug|tracing)/ } @_;\n\t}\n\n\tif (($File::Find::dir =~ m,^/sys/fs,)) {\n\t\treturn grep {!/(pstore|bpf|fuse)/ } @_;\n\t}\n\n\treturn @_\n}\n\nmy %leaf;\nmy %aliases;\nmy @files;\nmy %root;\n\nsub graph_add_file {\n\tmy $file = shift;\n\tmy $type = shift;\n\n\tmy $dir = $file;\n\t$dir =~ s,^(.*/).*,$1,;\n\t$file =~ s,.*/,,;\n\n\tmy $name;\n\tmy $file_ref = \\%root;\n\tforeach my $edge(split \"/\", $dir) {\n\t\t$name .= \"$edge/\";\n\t\tif (!defined ${$file_ref}{$edge}) {\n\t\t\t${$file_ref}{$edge} = { };\n\t\t}\n\t\t$file_ref = \\%{$$file_ref{$edge}};\n\t\t${$file_ref}{\"__name\"} = [ $name ];\n\t}\n\t$name .= \"$file\";\n\t${$file_ref}{$file} = {\n\t\t\"__name\" => [ $name ]\n\t};\n\n\treturn \\%{$$file_ref{$file}};\n}\n\nsub graph_add_link {\n\tmy $file = shift;\n\tmy $link = shift;\n\n\t# Traverse graph to find the reference\n\tmy $file_ref = \\%root;\n\tforeach my $edge(split \"/\", $file) {\n\t\t$file_ref = \\%{$$file_ref{$edge}} || die \"Missing node!\";\n\t}\n\n\t# do a BFS\n\n\tmy @queue;\n\tmy %seen;\n\tmy $st;\n\n\tpush @queue, $file_ref;\n\t$seen{$start}++;\n\n\twhile (@queue) {\n\t\tmy $v = shift @queue;\n\t\tmy @child = keys(%{$v});\n\n\t\tforeach my $c(@child) {\n\t\t\tnext if $seen{$$v{$c}};\n\t\t\tnext if ($c eq \"__name\");\n\n\t\t\tif (!defined($$v{$c}{\"__name\"})) {\n\t\t\t\tprintf STDERR \"Error: Couldn't find a non-empty name on a children of $file/.*: \";\n\t\t\t\tprint STDERR Dumper(%{$v});\n\t\t\t\texit;\n\t\t\t}\n\n\t\t\t# Add new name\n\t\t\tmy $name = @{$$v{$c}{\"__name\"}}[0];\n\t\t\tif ($name =~ s#^$file/#$link/#) {\n\t\t\t\tpush @{$$v{$c}{\"__name\"}}, $name;\n\t\t\t}\n\t\t\t# Add child to the queue and mark as seen\n\t\t\tpush @queue, $$v{$c};\n\t\t\t$seen{$c}++;\n\t\t}\n\t}\n}\n\nmy $escape_symbols = qr { ([\\x01-\\x08\\x0e-\\x1f\\x21-\\x29\\x2b-\\x2d\\x3a-\\x40\\x7b-\\xfe]) }x;\nsub parse_existing_sysfs {\n\tmy $file = $File::Find::name;\n\n\tmy $mode = (lstat($file))[2];\n\tmy $abs_file = abs_path($file);\n\n\tmy @tmp;\n\tpush @tmp, $file;\n\tpush @tmp, $abs_file if ($abs_file ne $file);\n\n\tforeach my $f(@tmp) {\n\t\t# Ignore cgroup, as this is big and has zero docs under ABI\n\t\treturn if ($f =~ m#^/sys/fs/cgroup/#);\n\n\t\t# Ignore firmware as it is documented elsewhere\n\t\t# Either ACPI or under Documentation/devicetree/bindings/\n\t\treturn if ($f =~ m#^/sys/firmware/#);\n\n\t\t# Ignore some sysfs nodes that aren't actually part of ABI\n\t\treturn if ($f =~ m#/sections|notes/#);\n\n\t\t# Would need to check at\n\t\t# Documentation/admin-guide/kernel-parameters.txt, but this\n\t\t# is not easily parseable.\n\t\treturn if ($f =~ m#/parameters/#);\n\t}\n\n\tif (S_ISLNK($mode)) {\n\t\t$aliases{$file} = $abs_file;\n\t\treturn;\n\t}\n\n\treturn if (S_ISDIR($mode));\n\n\t# Trivial: file is defined exactly the same way at ABI What:\n\treturn if (defined($data{$file}));\n\treturn if (defined($data{$abs_file}));\n\n\tpush @files, graph_add_file($abs_file, \"file\");\n}\n\nsub get_leave($)\n{\n\tmy $what = shift;\n\tmy $leave;\n\n\tmy $l = $what;\n\tmy $stop = 1;\n\n\t$leave = $l;\n\t$leave =~ s,/$,,;\n\t$leave =~ s,.*/,,;\n\t$leave =~ s/[\\(\\)]//g;\n\n\t# $leave is used to improve search performance at\n\t# check_undefined_symbols, as the algorithm there can seek\n\t# for a small number of \"what\". It also allows giving a\n\t# hint about a leave with the same name somewhere else.\n\t# However, there are a few occurences where the leave is\n\t# either a wildcard or a number. Just group such cases\n\t# altogether.\n\tif ($leave =~ m/\\.\\*/ || $leave eq \"\" || $leave =~ /\\\\d/) {\n\t\t$leave = \"others\";\n\t}\n\n\treturn $leave;\n}\n\nmy @not_found;\n\nsub check_file($$)\n{\n\tmy $file_ref = shift;\n\tmy $names_ref = shift;\n\tmy @names = @{$names_ref};\n\tmy $file = $names[0];\n\n\tmy $found_string;\n\n\tmy $leave = get_leave($file);\n\tif (!defined($leaf{$leave})) {\n\t\t$leave = \"others\";\n\t}\n\tmy @expr = @{$leaf{$leave}->{expr}};\n\tdie (\"\\rmissing rules for $leave\") if (!defined($leaf{$leave}));\n\n\tmy $path = $file;\n\t$path =~ s,(.*/).*,$1,;\n\n\tif ($search_string) {\n\t\treturn if (!($file =~ m#$search_string#));\n\t\t$found_string = 1;\n\t}\n\n\tfor (my $i = 0; $i < @names; $i++) {\n\t\tif ($found_string && $hint) {\n\t\t\tif (!$i) {\n\t\t\t\tprint STDERR \"--> $names[$i]\\n\";\n\t\t\t} else {\n\t\t\t\tprint STDERR \"    $names[$i]\\n\";\n\t\t\t}\n\t\t}\n\t\tforeach my $re (@expr) {\n\t\t\tprint STDERR \"$names[$i] =~ /^$re\\$/\\n\" if ($debug && $dbg_undefined);\n\t\t\tif ($names[$i] =~ $re) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ($leave ne \"others\") {\n\t\tmy @expr = @{$leaf{\"others\"}->{expr}};\n\t\tfor (my $i = 0; $i < @names; $i++) {\n\t\t\tforeach my $re (@expr) {\n\t\t\t\tprint STDERR \"$names[$i] =~ /^$re\\$/\\n\" if ($debug && $dbg_undefined);\n\t\t\t\tif ($names[$i] =~ $re) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpush @not_found, $file if (!$search_string || $found_string);\n\n\tif ($hint && (!$search_string || $found_string)) {\n\t\tmy $what = $leaf{$leave}->{what};\n\t\t$what =~ s/\\xac/\\n\\t/g;\n\t\tif ($leave ne \"others\") {\n\t\t\tprint STDERR \"\\r    more likely regexes:\\n\\t$what\\n\";\n\t\t} else {\n\t\t\tprint STDERR \"\\r    tested regexes:\\n\\t$what\\n\";\n\t\t}\n\t}\n}\n\nsub check_undefined_symbols {\n\tmy $num_files = scalar @files;\n\tmy $next_i = 0;\n\tmy $start_time = times;\n\n\t@files = sort @files;\n\n\tmy $last_time = $start_time;\n\n\t# When either debug or hint is enabled, there's no sense showing\n\t# progress, as the progress will be overriden.\n\tif ($hint || ($debug && $dbg_undefined)) {\n\t\t$next_i = $num_files;\n\t}\n\n\tmy $is_console;\n\t$is_console = 1 if (-t STDERR);\n\n\tfor (my $i = 0; $i < $num_files; $i++) {\n\t\tmy $file_ref = $files[$i];\n\t\tmy @names = @{$$file_ref{\"__name\"}};\n\n\t\tcheck_file($file_ref, \\@names);\n\n\t\tmy $cur_time = times;\n\n\t\tif ($i == $next_i || $cur_time > $last_time + 1) {\n\t\t\tmy $percent = $i * 100 / $num_files;\n\n\t\t\tmy $tm = $cur_time - $start_time;\n\t\t\tmy $time = sprintf \"%d:%02d\", int($tm), 60 * ($tm - int($tm));\n\n\t\t\tprintf STDERR \"\\33[2K\\r\", if ($is_console);\n\t\t\tprintf STDERR \"%s: processing sysfs files... %i%%: $names[0]\", $time, $percent;\n\t\t\tprintf STDERR \"\\n\", if (!$is_console);\n\t\t\tSTDERR->flush();\n\n\t\t\t$next_i = int (($percent + 1) * $num_files / 100);\n\t\t\t$last_time = $cur_time;\n\t\t}\n\t}\n\n\tmy $cur_time = times;\n\tmy $tm = $cur_time - $start_time;\n\tmy $time = sprintf \"%d:%02d\", int($tm), 60 * ($tm - int($tm));\n\n\tprintf STDERR \"\\33[2K\\r\", if ($is_console);\n\tprintf STDERR \"%s: processing sysfs files... done\\n\", $time;\n\n\tforeach my $file (@not_found) {\n\t\tprint \"$file not found.\\n\";\n\t}\n}\n\nsub undefined_symbols {\n\tprint STDERR \"Reading $sysfs_prefix directory contents...\";\n\tfind({\n\t\twanted =>\\&parse_existing_sysfs,\n\t\tpreprocess =>\\&dont_parse_special_attributes,\n\t\tno_chdir => 1\n\t     }, $sysfs_prefix);\n\tprint STDERR \"done.\\n\";\n\n\t$leaf{\"others\"}->{what} = \"\";\n\n\tprint STDERR \"Converting ABI What fields into regexes...\";\n\tforeach my $w (sort keys %data) {\n\t\tforeach my $what (split /\\xac/,$w) {\n\t\t\tnext if (!($what =~ m/^$sysfs_prefix/));\n\n\t\t\t# Convert what into regular expressions\n\n\t\t\t# Escape dot characters\n\t\t\t$what =~ s/\\./\\xf6/g;\n\n\t\t\t# Temporarily change [0-9]+ type of patterns\n\t\t\t$what =~ s/\\[0\\-9\\]\\+/\\xff/g;\n\n\t\t\t# Temporarily change [\\d+-\\d+] type of patterns\n\t\t\t$what =~ s/\\[0\\-\\d+\\]/\\xff/g;\n\t\t\t$what =~ s/\\[(\\d+)\\]/\\xf4$1\\xf5/g;\n\n\t\t\t# Temporarily change [0-9] type of patterns\n\t\t\t$what =~ s/\\[(\\d)\\-(\\d)\\]/\\xf4$1-$2\\xf5/g;\n\n\t\t\t# Handle multiple option patterns\n\t\t\t$what =~ s/[\\{\\<\\[]([\\w_]+)(?:[,|]+([\\w_]+)){1,}[\\}\\>\\]]/($1|$2)/g;\n\n\t\t\t# Handle wildcards\n\t\t\t$what =~ s,\\*,.*,g;\n\t\t\t$what =~ s,/\\xf6..,/.*,g;\n\t\t\t$what =~ s/\\<[^\\>]+\\>/.*/g;\n\t\t\t$what =~ s/\\{[^\\}]+\\}/.*/g;\n\t\t\t$what =~ s/\\[[^\\]]+\\]/.*/g;\n\n\t\t\t$what =~ s/[XYZ]/.*/g;\n\n\t\t\t# Recover [0-9] type of patterns\n\t\t\t$what =~ s/\\xf4/[/g;\n\t\t\t$what =~ s/\\xf5/]/g;\n\n\t\t\t# Remove duplicated spaces\n\t\t\t$what =~ s/\\s+/ /g;\n\n\t\t\t# Special case: this ABI has a parenthesis on it\n\t\t\t$what =~ s/sqrt\\(x^2\\+y^2\\+z^2\\)/sqrt\\(x^2\\+y^2\\+z^2\\)/;\n\n\t\t\t# Special case: drop comparition as in:\n\t\t\t#\tWhat: foo = <something>\n\t\t\t# (this happens on a few IIO definitions)\n\t\t\t$what =~ s,\\s*\\=.*$,,;\n\n\t\t\t# Escape all other symbols\n\t\t\t$what =~ s/$escape_symbols/\\\\$1/g;\n\t\t\t$what =~ s/\\\\\\\\/\\\\/g;\n\t\t\t$what =~ s/\\\\([\\[\\]\\(\\)\\|])/$1/g;\n\t\t\t$what =~ s/(\\d+)\\\\(-\\d+)/$1$2/g;\n\n\t\t\t$what =~ s/\\xff/\\\\d+/g;\n\n\t\t\t# Special case: IIO ABI which a parenthesis.\n\t\t\t$what =~ s/sqrt(.*)/sqrt\\(.*\\)/;\n\n\t\t\t# Simplify regexes with multiple .*\n\t\t\t$what =~ s#(?:\\.\\*){2,}##g;\n#\t\t\t$what =~ s#\\.\\*/\\.\\*#.*#g;\n\n\t\t\t# Recover dot characters\n\t\t\t$what =~ s/\\xf6/\\./g;\n\n\t\t\tmy $leave = get_leave($what);\n\n\t\t\tmy $added = 0;\n\t\t\tforeach my $l (split /\\|/, $leave) {\n\t\t\t\tif (defined($leaf{$l})) {\n\t\t\t\t\tnext if ($leaf{$l}->{what} =~ m/\\b$what\\b/);\n\t\t\t\t\t$leaf{$l}->{what} .= \"\\xac\" . $what;\n\t\t\t\t\t$added = 1;\n\t\t\t\t} else {\n\t\t\t\t\t$leaf{$l}->{what} = $what;\n\t\t\t\t\t$added = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($search_string && $added) {\n\t\t\t\tprint STDERR \"What: $what\\n\" if ($what =~ m#$search_string#);\n\t\t\t}\n\n\t\t}\n\t}\n\t# Compile regexes\n\tforeach my $l (sort keys %leaf) {\n\t\tmy @expr;\n\t\tforeach my $w(sort split /\\xac/, $leaf{$l}->{what}) {\n\t\t\tpush @expr, qr /^$w$/;\n\t\t}\n\t\t$leaf{$l}->{expr} = \\@expr;\n\t}\n\n\t# Take links into account\n\tforeach my $link (sort keys %aliases) {\n\t\tmy $abs_file = $aliases{$link};\n\t\tgraph_add_link($abs_file, $link);\n\t}\n\tprint STDERR \"done.\\n\";\n\n\tcheck_undefined_symbols;\n}\n\n# Ensure that the prefix will always end with a slash\n# While this is not needed for find, it makes the patch nicer\n# with --enable-lineno\n$prefix =~ s,/?$,/,;\n\nif ($cmd eq \"undefined\" || $cmd eq \"search\") {\n\t$show_warnings = 0;\n}\n#\n# Parses all ABI files located at $prefix dir\n#\nfind({wanted =>\\&parse_abi, no_chdir => 1}, $prefix);\n\nprint STDERR Data::Dumper->Dump([\\%data], [qw(*data)]) if ($debug & $dbg_dump_abi_structs);\n\n#\n# Handles the command\n#\nif ($cmd eq \"undefined\") {\n\tundefined_symbols;\n} elsif ($cmd eq \"search\") {\n\tsearch_symbols;\n} else {\n\tif ($cmd eq \"rest\") {\n\t\toutput_rest;\n\t}\n\n\t# Warn about duplicated ABI entries\n\tforeach my $what(sort keys %symbols) {\n\t\tmy @files = @{$symbols{$what}->{file}};\n\n\t\tnext if (scalar(@files) == 1);\n\n\t\tprintf STDERR \"Warning: $what is defined %d times: @files\\n\",\n\t\t    scalar(@files);\n\t}\n}\n\n__END__\n\n=head1 NAME\n\nget_abi.pl - parse the Linux ABI files and produce a ReST book.\n\n=head1 SYNOPSIS\n\nB<get_abi.pl> [--debug <level>] [--enable-lineno] [--man] [--help]\n\t       [--(no-)rst-source] [--dir=<dir>] [--show-hints]\n\t       [--search-string <regex>]\n\t       <COMMAND> [<ARGUMENT>]\n\nWhere B<COMMAND> can be:\n\n=over 8\n\nB<search> I<SEARCH_REGEX> - search for I<SEARCH_REGEX> inside ABI\n\nB<rest>                   - output the ABI in ReST markup language\n\nB<validate>               - validate the ABI contents\n\nB<undefined>              - existing symbols at the system that aren't\n                            defined at Documentation/ABI\n\n=back\n\n=head1 OPTIONS\n\n=over 8\n\n=item B<--dir>\n\nChanges the location of the ABI search. By default, it uses\nthe Documentation/ABI directory.\n\n=item B<--rst-source> and B<--no-rst-source>\n\nThe input file may be using ReST syntax or not. Those two options allow\nselecting between a rst-compliant source ABI (B<--rst-source>), or a\nplain text that may be violating ReST spec, so it requres some escaping\nlogic (B<--no-rst-source>).\n\n=item B<--enable-lineno>\n\nEnable output of .. LINENO lines.\n\n=item B<--debug> I<debug level>\n\nPrint debug information according with the level, which is given by the\nfollowing bitmask:\n\n    -  1: Debug parsing What entries from ABI files;\n    -  2: Shows what files are opened from ABI files;\n    -  4: Dump the structs used to store the contents of the ABI files.\n\n=item B<--show-hints>\n\nShow hints about possible definitions for the missing ABI symbols.\nUsed only when B<undefined>.\n\n=item B<--search-string> I<regex string>\n\nShow only occurences that match a search string.\nUsed only when B<undefined>.\n\n=item B<--help>\n\nPrints a brief help message and exits.\n\n=item B<--man>\n\nPrints the manual page and exits.\n\n=back\n\n=head1 DESCRIPTION\n\nParse the Linux ABI files from ABI DIR (usually located at Documentation/ABI),\nallowing to search for ABI symbols or to produce a ReST book containing\nthe Linux ABI documentation.\n\n=head1 EXAMPLES\n\nSearch for all stable symbols with the word \"usb\":\n\n=over 8\n\n$ scripts/get_abi.pl search usb --dir Documentation/ABI/stable\n\n=back\n\nSearch for all symbols that match the regex expression \"usb.*cap\":\n\n=over 8\n\n$ scripts/get_abi.pl search usb.*cap\n\n=back\n\nOutput all obsoleted symbols in ReST format\n\n=over 8\n\n$ scripts/get_abi.pl rest --dir Documentation/ABI/obsolete\n\n=back\n\n=head1 BUGS\n\nReport bugs to Mauro Carvalho Chehab <mchehab+huawei@kernel.org>\n\n=head1 COPYRIGHT\n\nCopyright (c) 2016-2021 by Mauro Carvalho Chehab <mchehab+huawei@kernel.org>.\n\nLicense GPLv2: GNU GPL version 2 <http://gnu.org/licenses/gpl.html>.\n\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n=cut\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}