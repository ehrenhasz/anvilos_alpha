{
  "module_name": "proc.py",
  "hash_id": "958a097413cc78164375e0d800bd427ed8919c8303030c2b98bcbab4b4c03155",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/proc.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# gdb helper commands and functions for Linux kernel debugging\n#\n#  Kernel proc information reader\n#\n# Copyright (c) 2016 Linaro Ltd\n#\n# Authors:\n#  Kieran Bingham <kieran.bingham@linaro.org>\n#\n# This work is licensed under the terms of the GNU GPL version 2.\n#\n\nimport gdb\nfrom linux import constants\nfrom linux import utils\nfrom linux import tasks\nfrom linux import lists\nfrom linux import vfs\nfrom struct import *\n\n\nclass LxCmdLine(gdb.Command):\n    \"\"\" Report the Linux Commandline used in the current kernel.\n        Equivalent to cat /proc/cmdline on a running target\"\"\"\n\n    def __init__(self):\n        super(LxCmdLine, self).__init__(\"lx-cmdline\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        gdb.write(gdb.parse_and_eval(\"saved_command_line\").string() + \"\\n\")\n\n\nLxCmdLine()\n\n\nclass LxVersion(gdb.Command):\n    \"\"\" Report the Linux Version of the current kernel.\n        Equivalent to cat /proc/version on a running target\"\"\"\n\n    def __init__(self):\n        super(LxVersion, self).__init__(\"lx-version\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        # linux_banner should contain a newline\n        gdb.write(gdb.parse_and_eval(\"(char *)linux_banner\").string())\n\n\nLxVersion()\n\n\n# Resource Structure Printers\n#  /proc/iomem\n#  /proc/ioports\n\ndef get_resources(resource, depth):\n    while resource:\n        yield resource, depth\n\n        child = resource['child']\n        if child:\n            for res, deep in get_resources(child, depth + 1):\n                yield res, deep\n\n        resource = resource['sibling']\n\n\ndef show_lx_resources(resource_str):\n        resource = gdb.parse_and_eval(resource_str)\n        width = 4 if resource['end'] < 0x10000 else 8\n        # Iterate straight to the first child\n        for res, depth in get_resources(resource['child'], 0):\n            start = int(res['start'])\n            end = int(res['end'])\n            gdb.write(\" \" * depth * 2 +\n                      \"{0:0{1}x}-\".format(start, width) +\n                      \"{0:0{1}x} : \".format(end, width) +\n                      res['name'].string() + \"\\n\")\n\n\nclass LxIOMem(gdb.Command):\n    \"\"\"Identify the IO memory resource locations defined by the kernel\n\nEquivalent to cat /proc/iomem on a running target\"\"\"\n\n    def __init__(self):\n        super(LxIOMem, self).__init__(\"lx-iomem\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        return show_lx_resources(\"iomem_resource\")\n\n\nLxIOMem()\n\n\nclass LxIOPorts(gdb.Command):\n    \"\"\"Identify the IO port resource locations defined by the kernel\n\nEquivalent to cat /proc/ioports on a running target\"\"\"\n\n    def __init__(self):\n        super(LxIOPorts, self).__init__(\"lx-ioports\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        return show_lx_resources(\"ioport_resource\")\n\n\nLxIOPorts()\n\n\n# Mount namespace viewer\n#  /proc/mounts\n\ndef info_opts(lst, opt):\n    opts = \"\"\n    for key, string in lst.items():\n        if opt & key:\n            opts += string\n    return opts\n\n\nFS_INFO = {constants.LX_SB_SYNCHRONOUS: \",sync\",\n           constants.LX_SB_MANDLOCK: \",mand\",\n           constants.LX_SB_DIRSYNC: \",dirsync\",\n           constants.LX_SB_NOATIME: \",noatime\",\n           constants.LX_SB_NODIRATIME: \",nodiratime\"}\n\nMNT_INFO = {constants.LX_MNT_NOSUID: \",nosuid\",\n            constants.LX_MNT_NODEV: \",nodev\",\n            constants.LX_MNT_NOEXEC: \",noexec\",\n            constants.LX_MNT_NOATIME: \",noatime\",\n            constants.LX_MNT_NODIRATIME: \",nodiratime\",\n            constants.LX_MNT_RELATIME: \",relatime\"}\n\nmount_type = utils.CachedType(\"struct mount\")\nmount_ptr_type = mount_type.get_type().pointer()\n\n\nclass LxMounts(gdb.Command):\n    \"\"\"Report the VFS mounts of the current process namespace.\n\nEquivalent to cat /proc/mounts on a running target\nAn integer value can be supplied to display the mount\nvalues of that process namespace\"\"\"\n\n    def __init__(self):\n        super(LxMounts, self).__init__(\"lx-mounts\", gdb.COMMAND_DATA)\n\n    # Equivalent to proc_namespace.c:show_vfsmnt\n    # However, that has the ability to call into s_op functions\n    # whereas we cannot and must make do with the information we can obtain.\n    def invoke(self, arg, from_tty):\n        argv = gdb.string_to_argv(arg)\n        if len(argv) >= 1:\n            try:\n                pid = int(argv[0])\n            except gdb.error:\n                raise gdb.GdbError(\"Provide a PID as integer value\")\n        else:\n            pid = 1\n\n        task = tasks.get_task_by_pid(pid)\n        if not task:\n            raise gdb.GdbError(\"Couldn't find a process with PID {}\"\n                               .format(pid))\n\n        namespace = task['nsproxy']['mnt_ns']\n        if not namespace:\n            raise gdb.GdbError(\"No namespace for current process\")\n\n        gdb.write(\"{:^18} {:^15} {:>9} {} {} options\\n\".format(\n                  \"mount\", \"super_block\", \"devname\", \"pathname\", \"fstype\"))\n\n        for mnt in lists.list_for_each_entry(namespace['list'],\n                                             mount_ptr_type, \"mnt_list\"):\n            devname = mnt['mnt_devname'].string()\n            devname = devname if devname else \"none\"\n\n            pathname = \"\"\n            parent = mnt\n            while True:\n                mntpoint = parent['mnt_mountpoint']\n                pathname = vfs.dentry_name(mntpoint) + pathname\n                if (parent == parent['mnt_parent']):\n                    break\n                parent = parent['mnt_parent']\n\n            if (pathname == \"\"):\n                pathname = \"/\"\n\n            superblock = mnt['mnt']['mnt_sb']\n            fstype = superblock['s_type']['name'].string()\n            s_flags = int(superblock['s_flags'])\n            m_flags = int(mnt['mnt']['mnt_flags'])\n            rd = \"ro\" if (s_flags & constants.LX_SB_RDONLY) else \"rw\"\n\n            gdb.write(\"{} {} {} {} {} {}{}{} 0 0\\n\".format(\n                      mnt.format_string(), superblock.format_string(), devname,\n                      pathname, fstype, rd, info_opts(FS_INFO, s_flags),\n                      info_opts(MNT_INFO, m_flags)))\n\n\nLxMounts()\n\n\nclass LxFdtDump(gdb.Command):\n    \"\"\"Output Flattened Device Tree header and dump FDT blob to the filename\n       specified as the command argument. Equivalent to\n       'cat /proc/fdt > fdtdump.dtb' on a running target\"\"\"\n\n    def __init__(self):\n        super(LxFdtDump, self).__init__(\"lx-fdtdump\", gdb.COMMAND_DATA,\n                                        gdb.COMPLETE_FILENAME)\n\n    def fdthdr_to_cpu(self, fdt_header):\n\n        fdt_header_be = \">IIIIIII\"\n        fdt_header_le = \"<IIIIIII\"\n\n        if utils.get_target_endianness() == 1:\n            output_fmt = fdt_header_le\n        else:\n            output_fmt = fdt_header_be\n\n        return unpack(output_fmt, pack(fdt_header_be,\n                                       fdt_header['magic'],\n                                       fdt_header['totalsize'],\n                                       fdt_header['off_dt_struct'],\n                                       fdt_header['off_dt_strings'],\n                                       fdt_header['off_mem_rsvmap'],\n                                       fdt_header['version'],\n                                       fdt_header['last_comp_version']))\n\n    def invoke(self, arg, from_tty):\n\n        if not constants.LX_CONFIG_OF:\n            raise gdb.GdbError(\"Kernel not compiled with CONFIG_OF\\n\")\n\n        if len(arg) == 0:\n            filename = \"fdtdump.dtb\"\n        else:\n            filename = arg\n\n        py_fdt_header_ptr = gdb.parse_and_eval(\n            \"(const struct fdt_header *) initial_boot_params\")\n        py_fdt_header = py_fdt_header_ptr.dereference()\n\n        fdt_header = self.fdthdr_to_cpu(py_fdt_header)\n\n        if fdt_header[0] != constants.LX_OF_DT_HEADER:\n            raise gdb.GdbError(\"No flattened device tree magic found\\n\")\n\n        gdb.write(\"fdt_magic:         0x{:02X}\\n\".format(fdt_header[0]))\n        gdb.write(\"fdt_totalsize:     0x{:02X}\\n\".format(fdt_header[1]))\n        gdb.write(\"off_dt_struct:     0x{:02X}\\n\".format(fdt_header[2]))\n        gdb.write(\"off_dt_strings:    0x{:02X}\\n\".format(fdt_header[3]))\n        gdb.write(\"off_mem_rsvmap:    0x{:02X}\\n\".format(fdt_header[4]))\n        gdb.write(\"version:           {}\\n\".format(fdt_header[5]))\n        gdb.write(\"last_comp_version: {}\\n\".format(fdt_header[6]))\n\n        inf = gdb.inferiors()[0]\n        fdt_buf = utils.read_memoryview(inf, py_fdt_header_ptr,\n                                        fdt_header[1]).tobytes()\n\n        try:\n            f = open(filename, 'wb')\n        except gdb.error:\n            raise gdb.GdbError(\"Could not open file to dump fdt\")\n\n        f.write(fdt_buf)\n        f.close()\n\n        gdb.write(\"Dumped fdt blob to \" + filename + \"\\n\")\n\n\nLxFdtDump()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}