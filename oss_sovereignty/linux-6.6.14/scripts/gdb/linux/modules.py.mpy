{
  "module_name": "modules.py",
  "hash_id": "adaf40b69dacf38552b8ab3421ef2b368dde7e1cf60e296837e34a172086027c",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/modules.py",
  "human_readable_source": "#\n# gdb helper commands and functions for Linux kernel debugging\n#\n#  module tools\n#\n# Copyright (c) Siemens AG, 2013\n#\n# Authors:\n#  Jan Kiszka <jan.kiszka@siemens.com>\n#\n# This work is licensed under the terms of the GNU GPL version 2.\n#\n\nimport gdb\n\nfrom linux import cpus, utils, lists, constants\n\n\nmodule_type = utils.CachedType(\"struct module\")\n\n\ndef module_list():\n    global module_type\n    modules = utils.gdb_eval_or_none(\"modules\")\n    if modules is None:\n        return\n\n    module_ptr_type = module_type.get_type().pointer()\n\n    for module in lists.list_for_each_entry(modules, module_ptr_type, \"list\"):\n        yield module\n\n\ndef find_module_by_name(name):\n    for module in module_list():\n        if module['name'].string() == name:\n            return module\n    return None\n\n\nclass LxModule(gdb.Function):\n    \"\"\"Find module by name and return the module variable.\n\n$lx_module(\"MODULE\"): Given the name MODULE, iterate over all loaded modules\nof the target and return that module variable which MODULE matches.\"\"\"\n\n    def __init__(self):\n        super(LxModule, self).__init__(\"lx_module\")\n\n    def invoke(self, mod_name):\n        mod_name = mod_name.string()\n        module = find_module_by_name(mod_name)\n        if module:\n            return module.dereference()\n        else:\n            raise gdb.GdbError(\"Unable to find MODULE \" + mod_name)\n\n\nLxModule()\n\n\nclass LxLsmod(gdb.Command):\n    \"\"\"List currently loaded modules.\"\"\"\n\n    _module_use_type = utils.CachedType(\"struct module_use\")\n\n    def __init__(self):\n        super(LxLsmod, self).__init__(\"lx-lsmod\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        gdb.write(\n            \"Address{0}    Module                  Size  Used by\\n\".format(\n                \"        \" if utils.get_long_type().sizeof == 8 else \"\"))\n\n        for module in module_list():\n            text = module['mem'][constants.LX_MOD_TEXT]\n            text_addr = str(text['base']).split()[0]\n            total_size = 0\n\n            for i in range(constants.LX_MOD_TEXT, constants.LX_MOD_RO_AFTER_INIT + 1):\n                total_size += module['mem'][i]['size']\n\n            gdb.write(\"{address} {name:<19} {size:>8}  {ref}\".format(\n                address=text_addr,\n                name=module['name'].string(),\n                size=str(total_size),\n                ref=str(module['refcnt']['counter'] - 1)))\n\n            t = self._module_use_type.get_type().pointer()\n            first = True\n            sources = module['source_list']\n            for use in lists.list_for_each_entry(sources, t, \"source_list\"):\n                gdb.write(\"{separator}{name}\".format(\n                    separator=\" \" if first else \",\",\n                    name=use['source']['name'].string()))\n                first = False\n\n            gdb.write(\"\\n\")\n\nLxLsmod()\n\ndef help():\n    t = \"\"\"Usage: lx-getmod-by-textaddr [Heximal Address]\n    Example: lx-getmod-by-textaddr 0xffff800002d305ac\\n\"\"\"\n    gdb.write(\"Unrecognized command\\n\")\n    raise gdb.GdbError(t)\n\nclass LxFindTextAddrinMod(gdb.Command):\n    '''Look up loaded kernel module by text address.'''\n\n    def __init__(self):\n        super(LxFindTextAddrinMod, self).__init__('lx-getmod-by-textaddr', gdb.COMMAND_SUPPORT)\n\n    def invoke(self, arg, from_tty):\n        args = gdb.string_to_argv(arg)\n\n        if len(args) != 1:\n            help()\n\n        addr = gdb.Value(int(args[0], 16)).cast(utils.get_ulong_type())\n        for mod in module_list():\n            mod_text_start = mod['mem'][constants.LX_MOD_TEXT]['base']\n            mod_text_end = mod_text_start + mod['mem'][constants.LX_MOD_TEXT]['size'].cast(utils.get_ulong_type())\n\n            if addr >= mod_text_start and addr < mod_text_end:\n                s = \"0x%x\" % addr + \" is in \" + mod['name'].string() + \".ko\\n\"\n                gdb.write(s)\n                return\n        gdb.write(\"0x%x is not in any module text section\\n\" % addr)\n\nLxFindTextAddrinMod()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}