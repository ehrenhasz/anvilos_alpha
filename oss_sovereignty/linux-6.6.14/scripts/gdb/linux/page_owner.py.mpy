{
  "module_name": "page_owner.py",
  "hash_id": "3e82b3a685b5283ca2f7b6344b80a95ed73b2b8ce9ddcee5004c3a1e2438619e",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/page_owner.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright (c) 2023 MediaTek Inc.\n#\n# Authors:\n#  Kuan-Ying Lee <Kuan-Ying.Lee@mediatek.com>\n#\n\nimport gdb\nfrom linux import utils, stackdepot, constants, mm\n\nif constants.LX_CONFIG_PAGE_OWNER:\n    page_ext_t = utils.CachedType('struct page_ext')\n    page_owner_t = utils.CachedType('struct page_owner')\n\n    PAGE_OWNER_STACK_DEPTH = 16\n    PAGE_EXT_OWNER = constants.LX_PAGE_EXT_OWNER\n    PAGE_EXT_INVALID = 0x1\n    PAGE_EXT_OWNER_ALLOCATED = constants.LX_PAGE_EXT_OWNER_ALLOCATED\n\ndef help():\n    t = \"\"\"Usage: lx-dump-page-owner [Option]\n    Option:\n        --pfn [Decimal pfn]\n    Example:\n        lx-dump-page-owner --pfn 655360\\n\"\"\"\n    gdb.write(\"Unrecognized command\\n\")\n    raise gdb.GdbError(t)\n\nclass DumpPageOwner(gdb.Command):\n    \"\"\"Dump page owner\"\"\"\n\n    min_pfn = None\n    max_pfn = None\n    p_ops = None\n    migrate_reason_names = None\n\n    def __init__(self):\n        super(DumpPageOwner, self).__init__(\"lx-dump-page-owner\", gdb.COMMAND_SUPPORT)\n\n    def invoke(self, args, from_tty):\n        if not constants.LX_CONFIG_PAGE_OWNER:\n            raise gdb.GdbError('CONFIG_PAGE_OWNER does not enable')\n\n        page_owner_inited = gdb.parse_and_eval('page_owner_inited')\n        if page_owner_inited['key']['enabled']['counter'] != 0x1:\n            raise gdb.GdbError('page_owner_inited is not enabled')\n\n        self.p_ops = mm.page_ops().ops\n        self.get_page_owner_info()\n        argv = gdb.string_to_argv(args)\n        if len(argv) == 0:\n              self.read_page_owner()\n        elif len(argv) == 2:\n            if argv[0] == \"--pfn\":\n                pfn = int(argv[1])\n                self.read_page_owner_by_addr(self.p_ops.pfn_to_page(pfn))\n            else:\n                help()\n        else:\n            help()\n\n    def get_page_owner_info(self):\n        self.min_pfn = int(gdb.parse_and_eval(\"min_low_pfn\"))\n        self.max_pfn = int(gdb.parse_and_eval(\"max_pfn\"))\n        self.page_ext_size = int(gdb.parse_and_eval(\"page_ext_size\"))\n        self.migrate_reason_names = gdb.parse_and_eval('migrate_reason_names')\n\n    def page_ext_invalid(self, page_ext):\n        if page_ext == gdb.Value(0):\n            return True\n        if page_ext.cast(utils.get_ulong_type()) & PAGE_EXT_INVALID == PAGE_EXT_INVALID:\n            return True\n        return False\n\n    def get_entry(self, base, index):\n        return (base.cast(utils.get_ulong_type()) + self.page_ext_size * index).cast(page_ext_t.get_type().pointer())\n\n    def lookup_page_ext(self, page):\n        pfn = self.p_ops.page_to_pfn(page)\n        section = self.p_ops.pfn_to_section(pfn)\n        page_ext = section[\"page_ext\"]\n        if self.page_ext_invalid(page_ext):\n            return gdb.Value(0)\n        return self.get_entry(page_ext, pfn)\n\n    def page_ext_get(self, page):\n        page_ext = self.lookup_page_ext(page)\n        if page_ext != gdb.Value(0):\n            return page_ext\n        else:\n            return gdb.Value(0)\n\n    def get_page_owner(self, page_ext):\n        addr = page_ext.cast(utils.get_ulong_type()) + gdb.parse_and_eval(\"page_owner_ops\")[\"offset\"].cast(utils.get_ulong_type())\n        return addr.cast(page_owner_t.get_type().pointer())\n\n    def read_page_owner_by_addr(self, struct_page_addr):\n        page = gdb.Value(struct_page_addr).cast(utils.get_page_type().pointer())\n        pfn = self.p_ops.page_to_pfn(page)\n\n        if pfn < self.min_pfn or pfn > self.max_pfn or (not self.p_ops.pfn_valid(pfn)):\n            gdb.write(\"pfn is invalid\\n\")\n            return\n\n        page = self.p_ops.pfn_to_page(pfn)\n        page_ext = self.page_ext_get(page)\n\n        if page_ext == gdb.Value(0):\n            gdb.write(\"page_ext is null\\n\")\n            return\n\n        if not (page_ext['flags'] & (1 << PAGE_EXT_OWNER)):\n            gdb.write(\"page_owner flag is invalid\\n\")\n            raise gdb.GdbError('page_owner info is not present (never set?)\\n')\n\n        if mm.test_bit(PAGE_EXT_OWNER_ALLOCATED, page_ext['flags'].address):\n            gdb.write('page_owner tracks the page as allocated\\n')\n        else:\n            gdb.write('page_owner tracks the page as freed\\n')\n\n        if not (page_ext['flags'] & (1 << PAGE_EXT_OWNER_ALLOCATED)):\n            gdb.write(\"page_owner is not allocated\\n\")\n\n        try:\n            page_owner = self.get_page_owner(page_ext)\n            gdb.write(\"Page last allocated via order %d, gfp_mask: 0x%x, pid: %d, tgid: %d (%s), ts %u ns, free_ts %u ns\\n\" %\\\n                    (page_owner[\"order\"], page_owner[\"gfp_mask\"],\\\n                    page_owner[\"pid\"], page_owner[\"tgid\"], page_owner[\"comm\"],\\\n                    page_owner[\"ts_nsec\"], page_owner[\"free_ts_nsec\"]))\n            gdb.write(\"PFN: %d, Flags: 0x%x\\n\" % (pfn, page['flags']))\n            if page_owner[\"handle\"] == 0:\n                gdb.write('page_owner allocation stack trace missing\\n')\n            else:\n                stackdepot.stack_depot_print(page_owner[\"handle\"])\n\n            if page_owner[\"free_handle\"] == 0:\n                gdb.write('page_owner free stack trace missing\\n')\n            else:\n                gdb.write('page last free stack trace:\\n')\n                stackdepot.stack_depot_print(page_owner[\"free_handle\"])\n            if page_owner['last_migrate_reason'] != -1:\n                gdb.write('page has been migrated, last migrate reason: %s\\n' % self.migrate_reason_names[page_owner['last_migrate_reason']])\n        except:\n            gdb.write(\"\\n\")\n\n    def read_page_owner(self):\n        pfn = self.min_pfn\n\n        # Find a valid PFN or the start of a MAX_ORDER_NR_PAGES area\n        while ((not self.p_ops.pfn_valid(pfn)) and (pfn & (self.p_ops.MAX_ORDER_NR_PAGES - 1))) != 0:\n            pfn += 1\n\n        while pfn < self.max_pfn:\n            #\n            # If the new page is in a new MAX_ORDER_NR_PAGES area,\n            # validate the area as existing, skip it if not\n            #\n            if ((pfn & (self.p_ops.MAX_ORDER_NR_PAGES - 1)) == 0) and (not self.p_ops.pfn_valid(pfn)):\n                pfn += (self.p_ops.MAX_ORDER_NR_PAGES - 1)\n                continue;\n\n            page = self.p_ops.pfn_to_page(pfn)\n            page_ext = self.page_ext_get(page)\n            if page_ext == gdb.Value(0):\n                pfn += 1\n                continue\n\n            if not (page_ext['flags'] & (1 << PAGE_EXT_OWNER)):\n                pfn += 1\n                continue\n            if not (page_ext['flags'] & (1 << PAGE_EXT_OWNER_ALLOCATED)):\n                pfn += 1\n                continue\n\n            try:\n                page_owner = self.get_page_owner(page_ext)\n                gdb.write(\"Page allocated via order %d, gfp_mask: 0x%x, pid: %d, tgid: %d (%s), ts %u ns, free_ts %u ns\\n\" %\\\n                        (page_owner[\"order\"], page_owner[\"gfp_mask\"],\\\n                        page_owner[\"pid\"], page_owner[\"tgid\"], page_owner[\"comm\"],\\\n                        page_owner[\"ts_nsec\"], page_owner[\"free_ts_nsec\"]))\n                gdb.write(\"PFN: %d, Flags: 0x%x\\n\" % (pfn, page['flags']))\n                stackdepot.stack_depot_print(page_owner[\"handle\"])\n                pfn += (1 << page_owner[\"order\"])\n                continue\n            except:\n                gdb.write(\"\\n\")\n            pfn += 1\n\nDumpPageOwner()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}