{
  "module_name": "symbols.py",
  "hash_id": "98b76435e89567a8e58683e77f1e3dd481b913679048d385ca6684f4b3f35187",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/symbols.py",
  "human_readable_source": "#\n# gdb helper commands and functions for Linux kernel debugging\n#\n#  load kernel and module symbols\n#\n# Copyright (c) Siemens AG, 2011-2013\n#\n# Authors:\n#  Jan Kiszka <jan.kiszka@siemens.com>\n#\n# This work is licensed under the terms of the GNU GPL version 2.\n#\n\nimport gdb\nimport os\nimport re\n\nfrom linux import modules, utils, constants\n\n\nif hasattr(gdb, 'Breakpoint'):\n    class LoadModuleBreakpoint(gdb.Breakpoint):\n        def __init__(self, spec, gdb_command):\n            super(LoadModuleBreakpoint, self).__init__(spec, internal=True)\n            self.silent = True\n            self.gdb_command = gdb_command\n\n        def stop(self):\n            module = gdb.parse_and_eval(\"mod\")\n            module_name = module['name'].string()\n            cmd = self.gdb_command\n\n            # enforce update if object file is not found\n            cmd.module_files_updated = False\n\n            # Disable pagination while reporting symbol (re-)loading.\n            # The console input is blocked in this context so that we would\n            # get stuck waiting for the user to acknowledge paged output.\n            show_pagination = gdb.execute(\"show pagination\", to_string=True)\n            pagination = show_pagination.endswith(\"on.\\n\")\n            gdb.execute(\"set pagination off\")\n\n            if module_name in cmd.loaded_modules:\n                gdb.write(\"refreshing all symbols to reload module \"\n                          \"'{0}'\\n\".format(module_name))\n                cmd.load_all_symbols()\n            else:\n                cmd.load_module_symbols(module)\n\n            # restore pagination state\n            gdb.execute(\"set pagination %s\" % (\"on\" if pagination else \"off\"))\n\n            return False\n\n\nclass LxSymbols(gdb.Command):\n    \"\"\"(Re-)load symbols of Linux kernel and currently loaded modules.\n\nThe kernel (vmlinux) is taken from the current working directly. Modules (.ko)\nare scanned recursively, starting in the same directory. Optionally, the module\nsearch path can be extended by a space separated list of paths passed to the\nlx-symbols command.\"\"\"\n\n    module_paths = []\n    module_files = []\n    module_files_updated = False\n    loaded_modules = []\n    breakpoint = None\n\n    def __init__(self):\n        super(LxSymbols, self).__init__(\"lx-symbols\", gdb.COMMAND_FILES,\n                                        gdb.COMPLETE_FILENAME)\n\n    def _update_module_files(self):\n        self.module_files = []\n        for path in self.module_paths:\n            gdb.write(\"scanning for modules in {0}\\n\".format(path))\n            for root, dirs, files in os.walk(path):\n                for name in files:\n                    if name.endswith(\".ko\") or name.endswith(\".ko.debug\"):\n                        self.module_files.append(root + \"/\" + name)\n        self.module_files_updated = True\n\n    def _get_module_file(self, module_name):\n        module_pattern = \".*/{0}\\.ko(?:.debug)?$\".format(\n            module_name.replace(\"_\", r\"[_\\-]\"))\n        for name in self.module_files:\n            if re.match(module_pattern, name) and os.path.exists(name):\n                return name\n        return None\n\n    def _section_arguments(self, module, module_addr):\n        try:\n            sect_attrs = module['sect_attrs'].dereference()\n        except gdb.error:\n            return str(module_addr)\n\n        attrs = sect_attrs['attrs']\n        section_name_to_address = {\n            attrs[n]['battr']['attr']['name'].string(): attrs[n]['address']\n            for n in range(int(sect_attrs['nsections']))}\n\n        textaddr = section_name_to_address.get(\".text\", module_addr)\n        args = []\n        for section_name in [\".data\", \".data..read_mostly\", \".rodata\", \".bss\",\n                             \".text.hot\", \".text.unlikely\"]:\n            address = section_name_to_address.get(section_name)\n            if address:\n                args.append(\" -s {name} {addr}\".format(\n                    name=section_name, addr=str(address)))\n        return \"{textaddr} {sections}\".format(\n            textaddr=textaddr, sections=\"\".join(args))\n\n    def load_module_symbols(self, module):\n        module_name = module['name'].string()\n        module_addr = str(module['mem'][constants.LX_MOD_TEXT]['base']).split()[0]\n\n        module_file = self._get_module_file(module_name)\n        if not module_file and not self.module_files_updated:\n            self._update_module_files()\n            module_file = self._get_module_file(module_name)\n\n        if module_file:\n            if utils.is_target_arch('s390'):\n                # Module text is preceded by PLT stubs on s390.\n                module_arch = module['arch']\n                plt_offset = int(module_arch['plt_offset'])\n                plt_size = int(module_arch['plt_size'])\n                module_addr = hex(int(module_addr, 0) + plt_offset + plt_size)\n            gdb.write(\"loading @{addr}: {filename}\\n\".format(\n                addr=module_addr, filename=module_file))\n            cmdline = \"add-symbol-file {filename} {sections}\".format(\n                filename=module_file,\n                sections=self._section_arguments(module, module_addr))\n            gdb.execute(cmdline, to_string=True)\n            if module_name not in self.loaded_modules:\n                self.loaded_modules.append(module_name)\n        else:\n            gdb.write(\"no module object found for '{0}'\\n\".format(module_name))\n\n    def load_all_symbols(self):\n        gdb.write(\"loading vmlinux\\n\")\n\n        # Dropping symbols will disable all breakpoints. So save their states\n        # and restore them afterward.\n        saved_states = []\n        if hasattr(gdb, 'breakpoints') and not gdb.breakpoints() is None:\n            for bp in gdb.breakpoints():\n                saved_states.append({'breakpoint': bp, 'enabled': bp.enabled})\n\n        # drop all current symbols and reload vmlinux\n        orig_vmlinux = 'vmlinux'\n        for obj in gdb.objfiles():\n            if (obj.filename.endswith('vmlinux') or\n                obj.filename.endswith('vmlinux.debug')):\n                orig_vmlinux = obj.filename\n        gdb.execute(\"symbol-file\", to_string=True)\n        gdb.execute(\"symbol-file {0}\".format(orig_vmlinux))\n\n        self.loaded_modules = []\n        module_list = modules.module_list()\n        if not module_list:\n            gdb.write(\"no modules found\\n\")\n        else:\n            [self.load_module_symbols(module) for module in module_list]\n\n        for saved_state in saved_states:\n            saved_state['breakpoint'].enabled = saved_state['enabled']\n\n    def invoke(self, arg, from_tty):\n        self.module_paths = [os.path.abspath(os.path.expanduser(p))\n                             for p in arg.split()]\n        self.module_paths.append(os.getcwd())\n\n        # enforce update\n        self.module_files = []\n        self.module_files_updated = False\n\n        self.load_all_symbols()\n\n        if hasattr(gdb, 'Breakpoint'):\n            if self.breakpoint is not None:\n                self.breakpoint.delete()\n                self.breakpoint = None\n            self.breakpoint = LoadModuleBreakpoint(\n                \"kernel/module/main.c:do_init_module\", self)\n        else:\n            gdb.write(\"Note: symbol update on module loading not supported \"\n                      \"with this gdb version\\n\")\n\n\nLxSymbols()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}