{
  "module_name": "tasks.py",
  "hash_id": "9e50be144a6383e1a644f9eba2c00a63ede22aefec255771344ffbcb7c1d0857",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/tasks.py",
  "human_readable_source": "#\n# gdb helper commands and functions for Linux kernel debugging\n#\n#  task & thread tools\n#\n# Copyright (c) Siemens AG, 2011-2013\n#\n# Authors:\n#  Jan Kiszka <jan.kiszka@siemens.com>\n#\n# This work is licensed under the terms of the GNU GPL version 2.\n#\n\nimport gdb\n\nfrom linux import utils\n\n\ntask_type = utils.CachedType(\"struct task_struct\")\n\n\ndef task_lists():\n    task_ptr_type = task_type.get_type().pointer()\n    init_task = gdb.parse_and_eval(\"init_task\").address\n    t = g = init_task\n\n    while True:\n        while True:\n            yield t\n\n            t = utils.container_of(t['thread_group']['next'],\n                                   task_ptr_type, \"thread_group\")\n            if t == g:\n                break\n\n        t = g = utils.container_of(g['tasks']['next'],\n                                   task_ptr_type, \"tasks\")\n        if t == init_task:\n            return\n\n\ndef get_task_by_pid(pid):\n    for task in task_lists():\n        if int(task['pid']) == pid:\n            return task\n    return None\n\n\nclass LxTaskByPidFunc(gdb.Function):\n    \"\"\"Find Linux task by PID and return the task_struct variable.\n\n$lx_task_by_pid(PID): Given PID, iterate over all tasks of the target and\nreturn that task_struct variable which PID matches.\"\"\"\n\n    def __init__(self):\n        super(LxTaskByPidFunc, self).__init__(\"lx_task_by_pid\")\n\n    def invoke(self, pid):\n        task = get_task_by_pid(pid)\n        if task:\n            return task.dereference()\n        else:\n            raise gdb.GdbError(\"No task of PID \" + str(pid))\n\n\nLxTaskByPidFunc()\n\n\nclass LxPs(gdb.Command):\n    \"\"\"Dump Linux tasks.\"\"\"\n\n    def __init__(self):\n        super(LxPs, self).__init__(\"lx-ps\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        gdb.write(\"{:>10} {:>12} {:>7}\\n\".format(\"TASK\", \"PID\", \"COMM\"))\n        for task in task_lists():\n            gdb.write(\"{} {:^5} {}\\n\".format(\n                task.format_string().split()[0],\n                task[\"pid\"].format_string(),\n                task[\"comm\"].string()))\n\n\nLxPs()\n\n\nthread_info_type = utils.CachedType(\"struct thread_info\")\n\nia64_task_size = None\n\n\ndef get_thread_info(task):\n    thread_info_ptr_type = thread_info_type.get_type().pointer()\n    if utils.is_target_arch(\"ia64\"):\n        global ia64_task_size\n        if ia64_task_size is None:\n            ia64_task_size = gdb.parse_and_eval(\"sizeof(struct task_struct)\")\n        thread_info_addr = task.address + ia64_task_size\n        thread_info = thread_info_addr.cast(thread_info_ptr_type)\n    else:\n        if task.type.fields()[0].type == thread_info_type.get_type():\n            return task['thread_info']\n        thread_info = task['stack'].cast(thread_info_ptr_type)\n    return thread_info.dereference()\n\n\nclass LxThreadInfoFunc (gdb.Function):\n    \"\"\"Calculate Linux thread_info from task variable.\n\n$lx_thread_info(TASK): Given TASK, return the corresponding thread_info\nvariable.\"\"\"\n\n    def __init__(self):\n        super(LxThreadInfoFunc, self).__init__(\"lx_thread_info\")\n\n    def invoke(self, task):\n        return get_thread_info(task)\n\n\nLxThreadInfoFunc()\n\n\nclass LxThreadInfoByPidFunc (gdb.Function):\n    \"\"\"Calculate Linux thread_info from task variable found by pid\n\n$lx_thread_info_by_pid(PID): Given PID, return the corresponding thread_info\nvariable.\"\"\"\n\n    def __init__(self):\n        super(LxThreadInfoByPidFunc, self).__init__(\"lx_thread_info_by_pid\")\n\n    def invoke(self, pid):\n        task = get_task_by_pid(pid)\n        if task:\n            return get_thread_info(task.dereference())\n        else:\n            raise gdb.GdbError(\"No task of PID \" + str(pid))\n\n\nLxThreadInfoByPidFunc()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}