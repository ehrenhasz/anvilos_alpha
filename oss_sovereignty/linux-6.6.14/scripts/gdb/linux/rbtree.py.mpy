{
  "module_name": "rbtree.py",
  "hash_id": "c7b5ff39f44bd0b30dd7cd11a83a9726591f554b49f3e1f2f10e9ae9f97355d5",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/rbtree.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright 2019 Google LLC.\n\nimport gdb\n\nfrom linux import utils\n\nrb_root_type = utils.CachedType(\"struct rb_root\")\nrb_node_type = utils.CachedType(\"struct rb_node\")\n\n\ndef rb_first(root):\n    if root.type == rb_root_type.get_type():\n        node = root.address.cast(rb_root_type.get_type().pointer())\n    elif root.type != rb_root_type.get_type().pointer():\n        raise gdb.GdbError(\"Must be struct rb_root not {}\".format(root.type))\n\n    node = root['rb_node']\n    if node == 0:\n        return None\n\n    while node['rb_left']:\n        node = node['rb_left']\n\n    return node\n\n\ndef rb_last(root):\n    if root.type == rb_root_type.get_type():\n        node = root.address.cast(rb_root_type.get_type().pointer())\n    elif root.type != rb_root_type.get_type().pointer():\n        raise gdb.GdbError(\"Must be struct rb_root not {}\".format(root.type))\n\n    node = root['rb_node']\n    if node == 0:\n        return None\n\n    while node['rb_right']:\n        node = node['rb_right']\n\n    return node\n\n\ndef rb_parent(node):\n    parent = gdb.Value(node['__rb_parent_color'] & ~3)\n    return parent.cast(rb_node_type.get_type().pointer())\n\n\ndef rb_empty_node(node):\n    return node['__rb_parent_color'] == node.address\n\n\ndef rb_next(node):\n    if node.type == rb_node_type.get_type():\n        node = node.address.cast(rb_node_type.get_type().pointer())\n    elif node.type != rb_node_type.get_type().pointer():\n        raise gdb.GdbError(\"Must be struct rb_node not {}\".format(node.type))\n\n    if rb_empty_node(node):\n        return None\n\n    if node['rb_right']:\n        node = node['rb_right']\n        while node['rb_left']:\n            node = node['rb_left']\n        return node\n\n    parent = rb_parent(node)\n    while parent and node == parent['rb_right']:\n            node = parent\n            parent = rb_parent(node)\n\n    return parent\n\n\ndef rb_prev(node):\n    if node.type == rb_node_type.get_type():\n        node = node.address.cast(rb_node_type.get_type().pointer())\n    elif node.type != rb_node_type.get_type().pointer():\n        raise gdb.GdbError(\"Must be struct rb_node not {}\".format(node.type))\n\n    if rb_empty_node(node):\n        return None\n\n    if node['rb_left']:\n        node = node['rb_left']\n        while node['rb_right']:\n            node = node['rb_right']\n        return node.dereference()\n\n    parent = rb_parent(node)\n    while parent and node == parent['rb_left'].dereference():\n            node = parent\n            parent = rb_parent(node)\n\n    return parent\n\n\nclass LxRbFirst(gdb.Function):\n    \"\"\"Lookup and return a node from an RBTree\n\n$lx_rb_first(root): Return the node at the given index.\nIf index is omitted, the root node is dereferenced and returned.\"\"\"\n\n    def __init__(self):\n        super(LxRbFirst, self).__init__(\"lx_rb_first\")\n\n    def invoke(self, root):\n        result = rb_first(root)\n        if result is None:\n            raise gdb.GdbError(\"No entry in tree\")\n\n        return result\n\n\nLxRbFirst()\n\n\nclass LxRbLast(gdb.Function):\n    \"\"\"Lookup and return a node from an RBTree.\n\n$lx_rb_last(root): Return the node at the given index.\nIf index is omitted, the root node is dereferenced and returned.\"\"\"\n\n    def __init__(self):\n        super(LxRbLast, self).__init__(\"lx_rb_last\")\n\n    def invoke(self, root):\n        result = rb_last(root)\n        if result is None:\n            raise gdb.GdbError(\"No entry in tree\")\n\n        return result\n\n\nLxRbLast()\n\n\nclass LxRbNext(gdb.Function):\n    \"\"\"Lookup and return a node from an RBTree.\n\n$lx_rb_next(node): Return the node at the given index.\nIf index is omitted, the root node is dereferenced and returned.\"\"\"\n\n    def __init__(self):\n        super(LxRbNext, self).__init__(\"lx_rb_next\")\n\n    def invoke(self, node):\n        result = rb_next(node)\n        if result is None:\n            raise gdb.GdbError(\"No entry in tree\")\n\n        return result\n\n\nLxRbNext()\n\n\nclass LxRbPrev(gdb.Function):\n    \"\"\"Lookup and return a node from an RBTree.\n\n$lx_rb_prev(node): Return the node at the given index.\nIf index is omitted, the root node is dereferenced and returned.\"\"\"\n\n    def __init__(self):\n        super(LxRbPrev, self).__init__(\"lx_rb_prev\")\n\n    def invoke(self, node):\n        result = rb_prev(node)\n        if result is None:\n            raise gdb.GdbError(\"No entry in tree\")\n\n        return result\n\n\nLxRbPrev()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}