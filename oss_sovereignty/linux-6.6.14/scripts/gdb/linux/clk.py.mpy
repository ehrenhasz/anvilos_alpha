{
  "module_name": "clk.py",
  "hash_id": "e823210d605f39bbb5b83a380621665cb9725a87e939b321981670701dced4ef",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/clk.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright (c) NXP 2019\n\nimport gdb\nimport sys\n\nfrom linux import utils, lists, constants\n\nclk_core_type = utils.CachedType(\"struct clk_core\")\n\n\ndef clk_core_for_each_child(hlist_head):\n    return lists.hlist_for_each_entry(hlist_head,\n            clk_core_type.get_type().pointer(), \"child_node\")\n\n\nclass LxClkSummary(gdb.Command):\n    \"\"\"Print clk tree summary\n\nOutput is a subset of /sys/kernel/debug/clk/clk_summary\n\nNo calls are made during printing, instead a (c) if printed after values which\nare cached and potentially out of date\"\"\"\n\n    def __init__(self):\n        super(LxClkSummary, self).__init__(\"lx-clk-summary\", gdb.COMMAND_DATA)\n\n    def show_subtree(self, clk, level):\n        gdb.write(\"%*s%-*s %7d %8d %8d %11lu%s\\n\" % (\n                level * 3 + 1, \"\",\n                30 - level * 3,\n                clk['name'].string(),\n                clk['enable_count'],\n                clk['prepare_count'],\n                clk['protect_count'],\n                clk['rate'],\n                '(c)' if clk['flags'] & constants.LX_CLK_GET_RATE_NOCACHE else '   '))\n\n        for child in clk_core_for_each_child(clk['children']):\n            self.show_subtree(child, level + 1)\n\n    def invoke(self, arg, from_tty):\n        if utils.gdb_eval_or_none(\"clk_root_list\") is None:\n            raise gdb.GdbError(\"No clocks registered\")\n        gdb.write(\"                                 enable  prepare  protect               \\n\")\n        gdb.write(\"   clock                          count    count    count        rate   \\n\")\n        gdb.write(\"------------------------------------------------------------------------\\n\")\n        for clk in clk_core_for_each_child(gdb.parse_and_eval(\"clk_root_list\")):\n            self.show_subtree(clk, 0)\n        for clk in clk_core_for_each_child(gdb.parse_and_eval(\"clk_orphan_list\")):\n            self.show_subtree(clk, 0)\n\n\nLxClkSummary()\n\n\nclass LxClkCoreLookup(gdb.Function):\n    \"\"\"Find struct clk_core by name\"\"\"\n\n    def __init__(self):\n        super(LxClkCoreLookup, self).__init__(\"lx_clk_core_lookup\")\n\n    def lookup_hlist(self, hlist_head, name):\n        for child in clk_core_for_each_child(hlist_head):\n            if child['name'].string() == name:\n                return child\n            result = self.lookup_hlist(child['children'], name)\n            if result:\n                return result\n\n    def invoke(self, name):\n        name = name.string()\n        return (self.lookup_hlist(gdb.parse_and_eval(\"clk_root_list\"), name) or\n                self.lookup_hlist(gdb.parse_and_eval(\"clk_orphan_list\"), name))\n\n\nLxClkCoreLookup()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}