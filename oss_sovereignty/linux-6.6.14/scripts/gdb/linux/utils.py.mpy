{
  "module_name": "utils.py",
  "hash_id": "4dbdac93b97e8ecf65ed0870686bf2c910ce1074d4db9b85ba5823a88b60a0fa",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/utils.py",
  "human_readable_source": "#\n# gdb helper commands and functions for Linux kernel debugging\n#\n#  common utilities\n#\n# Copyright (c) Siemens AG, 2011-2013\n#\n# Authors:\n#  Jan Kiszka <jan.kiszka@siemens.com>\n#\n# This work is licensed under the terms of the GNU GPL version 2.\n#\n\nimport gdb\n\n\nclass CachedType:\n    def __init__(self, name):\n        self._type = None\n        self._name = name\n\n    def _new_objfile_handler(self, event):\n        self._type = None\n        gdb.events.new_objfile.disconnect(self._new_objfile_handler)\n\n    def get_type(self):\n        if self._type is None:\n            self._type = gdb.lookup_type(self._name)\n            if self._type is None:\n                raise gdb.GdbError(\n                    \"cannot resolve type '{0}'\".format(self._name))\n            if hasattr(gdb, 'events') and hasattr(gdb.events, 'new_objfile'):\n                gdb.events.new_objfile.connect(self._new_objfile_handler)\n        return self._type\n\n\nlong_type = CachedType(\"long\")\nulong_type = CachedType(\"unsigned long\")\nuint_type = CachedType(\"unsigned int\")\natomic_long_type = CachedType(\"atomic_long_t\")\nsize_t_type = CachedType(\"size_t\")\nstruct_page_type = CachedType(\"struct page\")\n\ndef get_uint_type():\n    global uint_type\n    return uint_type.get_type()\n\ndef get_page_type():\n    global struct_page_type\n    return struct_page_type.get_type()\n\ndef get_long_type():\n    global long_type\n    return long_type.get_type()\n\ndef get_ulong_type():\n    global ulong_type\n    return ulong_type.get_type()\n\ndef get_size_t_type():\n    global size_t_type\n    return size_t_type.get_type()\n\ndef offset_of(typeobj, field):\n    element = gdb.Value(0).cast(typeobj)\n    return int(str(element[field].address).split()[0], 16)\n\n\ndef container_of(ptr, typeobj, member):\n    return (ptr.cast(get_long_type()) -\n            offset_of(typeobj, member)).cast(typeobj)\n\n\nclass ContainerOf(gdb.Function):\n    \"\"\"Return pointer to containing data structure.\n\n$container_of(PTR, \"TYPE\", \"ELEMENT\"): Given PTR, return a pointer to the\ndata structure of the type TYPE in which PTR is the address of ELEMENT.\nNote that TYPE and ELEMENT have to be quoted as strings.\"\"\"\n\n    def __init__(self):\n        super(ContainerOf, self).__init__(\"container_of\")\n\n    def invoke(self, ptr, typename, elementname):\n        return container_of(ptr, gdb.lookup_type(typename.string()).pointer(),\n                            elementname.string())\n\n\nContainerOf()\n\n\nBIG_ENDIAN = 0\nLITTLE_ENDIAN = 1\ntarget_endianness = None\n\n\ndef get_target_endianness():\n    global target_endianness\n    if target_endianness is None:\n        endian = gdb.execute(\"show endian\", to_string=True)\n        if \"little endian\" in endian:\n            target_endianness = LITTLE_ENDIAN\n        elif \"big endian\" in endian:\n            target_endianness = BIG_ENDIAN\n        else:\n            raise gdb.GdbError(\"unknown endianness '{0}'\".format(str(endian)))\n    return target_endianness\n\n\ndef read_memoryview(inf, start, length):\n    m = inf.read_memory(start, length)\n    if type(m) is memoryview:\n        return m\n    return memoryview(m)\n\n\ndef read_u16(buffer, offset):\n    buffer_val = buffer[offset:offset + 2]\n    value = [0, 0]\n\n    if type(buffer_val[0]) is str:\n        value[0] = ord(buffer_val[0])\n        value[1] = ord(buffer_val[1])\n    else:\n        value[0] = buffer_val[0]\n        value[1] = buffer_val[1]\n\n    if get_target_endianness() == LITTLE_ENDIAN:\n        return value[0] + (value[1] << 8)\n    else:\n        return value[1] + (value[0] << 8)\n\n\ndef read_u32(buffer, offset):\n    if get_target_endianness() == LITTLE_ENDIAN:\n        return read_u16(buffer, offset) + (read_u16(buffer, offset + 2) << 16)\n    else:\n        return read_u16(buffer, offset + 2) + (read_u16(buffer, offset) << 16)\n\n\ndef read_u64(buffer, offset):\n    if get_target_endianness() == LITTLE_ENDIAN:\n        return read_u32(buffer, offset) + (read_u32(buffer, offset + 4) << 32)\n    else:\n        return read_u32(buffer, offset + 4) + (read_u32(buffer, offset) << 32)\n\n\ndef read_ulong(buffer, offset):\n    if get_long_type().sizeof == 8:\n        return read_u64(buffer, offset)\n    else:\n        return read_u32(buffer, offset)\n\natomic_long_counter_offset = atomic_long_type.get_type()['counter'].bitpos\natomic_long_counter_sizeof = atomic_long_type.get_type()['counter'].type.sizeof\n\ndef read_atomic_long(buffer, offset):\n    global atomic_long_counter_offset\n    global atomic_long_counter_sizeof\n\n    if atomic_long_counter_sizeof == 8:\n        return read_u64(buffer, offset + atomic_long_counter_offset)\n    else:\n        return read_u32(buffer, offset + atomic_long_counter_offset)\n\ntarget_arch = None\n\n\ndef is_target_arch(arch):\n    if hasattr(gdb.Frame, 'architecture'):\n        return arch in gdb.newest_frame().architecture().name()\n    else:\n        global target_arch\n        if target_arch is None:\n            target_arch = gdb.execute(\"show architecture\", to_string=True)\n        return arch in target_arch\n\n\nGDBSERVER_QEMU = 0\nGDBSERVER_KGDB = 1\ngdbserver_type = None\n\n\ndef get_gdbserver_type():\n    def exit_handler(event):\n        global gdbserver_type\n        gdbserver_type = None\n        gdb.events.exited.disconnect(exit_handler)\n\n    def probe_qemu():\n        try:\n            return gdb.execute(\"monitor info version\", to_string=True) != \"\"\n        except gdb.error:\n            return False\n\n    def probe_kgdb():\n        try:\n            thread_info = gdb.execute(\"info thread 2\", to_string=True)\n            return \"shadowCPU0\" in thread_info\n        except gdb.error:\n            return False\n\n    global gdbserver_type\n    if gdbserver_type is None:\n        if probe_qemu():\n            gdbserver_type = GDBSERVER_QEMU\n        elif probe_kgdb():\n            gdbserver_type = GDBSERVER_KGDB\n        if gdbserver_type is not None and hasattr(gdb, 'events'):\n            gdb.events.exited.connect(exit_handler)\n    return gdbserver_type\n\n\ndef gdb_eval_or_none(expresssion):\n    try:\n        return gdb.parse_and_eval(expresssion)\n    except gdb.error:\n        return None\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}