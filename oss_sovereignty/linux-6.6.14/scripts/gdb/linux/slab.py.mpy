{
  "module_name": "slab.py",
  "hash_id": "3ebd91acea438203174bcb12c5aaccb95dcc84726aeac83f131ac97f4bbe7ca8",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/slab.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright (c) 2023 MediaTek Inc.\n#\n# Authors:\n#  Kuan-Ying Lee <Kuan-Ying.Lee@mediatek.com>\n#\n\nimport gdb\nimport re\nimport traceback\nfrom linux import lists, utils, stackdepot, constants, mm\n\nSLAB_RED_ZONE       = constants.LX_SLAB_RED_ZONE\nSLAB_POISON         = constants.LX_SLAB_POISON\nSLAB_KMALLOC        = constants.LX_SLAB_KMALLOC\nSLAB_HWCACHE_ALIGN  = constants.LX_SLAB_HWCACHE_ALIGN\nSLAB_CACHE_DMA      = constants.LX_SLAB_CACHE_DMA\nSLAB_CACHE_DMA32    = constants.LX_SLAB_CACHE_DMA32\nSLAB_STORE_USER     = constants.LX_SLAB_STORE_USER\nSLAB_PANIC          = constants.LX_SLAB_PANIC\n\nOO_SHIFT = 16\nOO_MASK = (1 << OO_SHIFT) - 1\n\nif constants.LX_CONFIG_SLUB_DEBUG:\n    slab_type = utils.CachedType(\"struct slab\")\n    slab_ptr_type = slab_type.get_type().pointer()\n    kmem_cache_type = utils.CachedType(\"struct kmem_cache\")\n    kmem_cache_ptr_type = kmem_cache_type.get_type().pointer()\n    freeptr_t = utils.CachedType(\"freeptr_t\")\n    freeptr_t_ptr = freeptr_t.get_type().pointer()\n\n    track_type = gdb.lookup_type('struct track')\n    track_alloc = int(gdb.parse_and_eval('TRACK_ALLOC'))\n    track_free = int(gdb.parse_and_eval('TRACK_FREE'))\n\ndef slab_folio(slab):\n    return slab.cast(gdb.lookup_type(\"struct folio\").pointer())\n\ndef slab_address(slab):\n    p_ops = mm.page_ops().ops\n    folio = slab_folio(slab)\n    return p_ops.folio_address(folio)\n\ndef for_each_object(cache, addr, slab_objects):\n    p = addr\n    if cache['flags'] & SLAB_RED_ZONE:\n        p += int(cache['red_left_pad'])\n    while p < addr + (slab_objects * cache['size']):\n        yield p\n        p = p + int(cache['size'])\n\ndef get_info_end(cache):\n    if (cache['offset'] >= cache['inuse']):\n        return cache['inuse'] + gdb.lookup_type(\"void\").pointer().sizeof\n    else:\n        return cache['inuse']\n\ndef get_orig_size(cache, obj):\n    if cache['flags'] & SLAB_STORE_USER and cache['flags'] & SLAB_KMALLOC:\n        p = mm.page_ops().ops.kasan_reset_tag(obj)\n        p += get_info_end(cache)\n        p += gdb.lookup_type('struct track').sizeof * 2\n        p = p.cast(utils.get_uint_type().pointer())\n        return p.dereference()\n    else:\n        return cache['object_size']\n\ndef get_track(cache, object_pointer, alloc):\n    p = object_pointer + get_info_end(cache)\n    p += (alloc * track_type.sizeof)\n    return p\n\ndef oo_objects(x):\n    return int(x['x']) & OO_MASK\n\ndef oo_order(x):\n    return int(x['x']) >> OO_SHIFT\n\ndef reciprocal_divide(a, R):\n    t = (a * int(R['m'])) >> 32\n    return (t + ((a - t) >> int(R['sh1']))) >> int(R['sh2'])\n\ndef __obj_to_index(cache, addr, obj):\n    return reciprocal_divide(int(mm.page_ops().ops.kasan_reset_tag(obj)) - addr, cache['reciprocal_size'])\n\ndef swab64(x):\n    result = (((x & 0x00000000000000ff) << 56) |   \\\n    ((x & 0x000000000000ff00) << 40) |   \\\n    ((x & 0x0000000000ff0000) << 24) |   \\\n    ((x & 0x00000000ff000000) <<  8) |   \\\n    ((x & 0x000000ff00000000) >>  8) |   \\\n    ((x & 0x0000ff0000000000) >> 24) |   \\\n    ((x & 0x00ff000000000000) >> 40) |   \\\n    ((x & 0xff00000000000000) >> 56))\n    return result\n\ndef freelist_ptr_decode(cache, ptr, ptr_addr):\n    if constants.LX_CONFIG_SLAB_FREELIST_HARDENED:\n        return ptr['v'] ^ cache['random'] ^ swab64(int(ptr_addr))\n    else:\n        return ptr['v']\n\ndef get_freepointer(cache, obj):\n    obj = mm.page_ops().ops.kasan_reset_tag(obj)\n    ptr_addr = obj + cache['offset']\n    p = ptr_addr.cast(freeptr_t_ptr).dereference()\n    return freelist_ptr_decode(cache, p, ptr_addr)\n\ndef loc_exist(loc_track, addr, handle, waste):\n    for loc in loc_track:\n        if loc['addr'] == addr and loc['handle'] == handle and loc['waste'] == waste:\n            return loc\n    return None\n\ndef add_location(loc_track, cache, track, orig_size):\n    jiffies = gdb.parse_and_eval(\"jiffies_64\")\n    age = jiffies - track['when']\n    handle = 0\n    waste = cache['object_size'] - int(orig_size)\n    pid = int(track['pid'])\n    cpuid = int(track['cpu'])\n    addr = track['addr']\n    if constants.LX_CONFIG_STACKDEPOT:\n        handle = track['handle']\n\n    loc = loc_exist(loc_track, addr, handle, waste)\n    if loc:\n        loc['count'] += 1\n        if track['when']:\n            loc['sum_time'] += age\n            loc['min_time'] = min(loc['min_time'], age)\n            loc['max_time'] = max(loc['max_time'], age)\n            loc['min_pid'] = min(loc['min_pid'], pid)\n            loc['max_pid'] = max(loc['max_pid'], pid)\n            loc['cpus'].add(cpuid)\n    else:\n        loc_track.append({\n            'count' : 1,\n            'addr' : addr,\n            'sum_time' : age,\n            'min_time' : age,\n            'max_time' : age,\n            'min_pid' : pid,\n            'max_pid' : pid,\n            'handle' : handle,\n            'waste' : waste,\n            'cpus' : {cpuid}\n            }\n        )\n\ndef slabtrace(alloc, cache_name):\n\n    def __fill_map(obj_map, cache, slab):\n        p = slab['freelist']\n        addr = slab_address(slab)\n        while p != gdb.Value(0):\n            index = __obj_to_index(cache, addr, p)\n            obj_map[index] = True # free objects\n            p = get_freepointer(cache, p)\n\n    # process every slab page on the slab_list (partial and full list)\n    def process_slab(loc_track, slab_list, alloc, cache):\n        for slab in lists.list_for_each_entry(slab_list, slab_ptr_type, \"slab_list\"):\n            obj_map[:] = [False] * oo_objects(cache['oo'])\n            __fill_map(obj_map, cache, slab)\n            addr = slab_address(slab)\n            for object_pointer in for_each_object(cache, addr, slab['objects']):\n                if obj_map[__obj_to_index(cache, addr, object_pointer)] == True:\n                    continue\n                p = get_track(cache, object_pointer, alloc)\n                track = gdb.Value(p).cast(track_type.pointer())\n                if alloc == track_alloc:\n                    size = get_orig_size(cache, object_pointer)\n                else:\n                    size = cache['object_size']\n                add_location(loc_track, cache, track, size)\n                continue\n\n    slab_caches = gdb.parse_and_eval(\"slab_caches\")\n    if mm.page_ops().ops.MAX_NUMNODES > 1:\n        nr_node_ids = int(gdb.parse_and_eval(\"nr_node_ids\"))\n    else:\n        nr_node_ids = 1\n\n    target_cache = None\n    loc_track = []\n\n    for cache in lists.list_for_each_entry(slab_caches, kmem_cache_ptr_type, 'list'):\n        if cache['name'].string() == cache_name:\n            target_cache = cache\n            break\n\n    obj_map = [False] * oo_objects(target_cache['oo'])\n\n    if target_cache['flags'] & SLAB_STORE_USER:\n        for i in range(0, nr_node_ids):\n            cache_node = target_cache['node'][i]\n            if cache_node['nr_slabs']['counter'] == 0:\n                continue\n            process_slab(loc_track, cache_node['partial'], alloc, target_cache)\n            process_slab(loc_track, cache_node['full'], alloc, target_cache)\n    else:\n        raise gdb.GdbError(\"SLAB_STORE_USER is not set in %s\" % target_cache['name'].string())\n\n    for loc in sorted(loc_track, key=lambda x:x['count'], reverse=True):\n        if loc['addr']:\n            addr = loc['addr'].cast(utils.get_ulong_type().pointer())\n            gdb.write(\"%d %s\" % (loc['count'], str(addr).split(' ')[-1]))\n        else:\n            gdb.write(\"%d <not-available>\" % loc['count'])\n\n        if loc['waste']:\n            gdb.write(\" waste=%d/%d\" % (loc['count'] * loc['waste'], loc['waste']))\n\n        if loc['sum_time'] != loc['min_time']:\n            gdb.write(\" age=%d/%d/%d\" % (loc['min_time'], loc['sum_time']/loc['count'], loc['max_time']))\n        else:\n            gdb.write(\" age=%d\" % loc['min_time'])\n\n        if loc['min_pid'] != loc['max_pid']:\n            gdb.write(\" pid=%d-%d\" % (loc['min_pid'], loc['max_pid']))\n        else:\n            gdb.write(\" pid=%d\" % loc['min_pid'])\n\n        if constants.LX_NR_CPUS > 1:\n            nr_cpu = gdb.parse_and_eval('__num_online_cpus')['counter']\n            if nr_cpu > 1:\n                gdb.write(\" cpus=\")\n                for i in loc['cpus']:\n                    gdb.write(\"%d,\" % i)\n        gdb.write(\"\\n\")\n        if constants.LX_CONFIG_STACKDEPOT:\n            if loc['handle']:\n                stackdepot.stack_depot_print(loc['handle'])\n        gdb.write(\"\\n\")\n\ndef help():\n    t = \"\"\"Usage: lx-slabtrace --cache_name [cache_name] [Options]\n    Options:\n        --alloc\n            print information of allocation trace of the allocated objects\n        --free\n            print information of freeing trace of the allocated objects\n    Example:\n        lx-slabtrace --cache_name kmalloc-1k --alloc\n        lx-slabtrace --cache_name kmalloc-1k --free\\n\"\"\"\n    gdb.write(\"Unrecognized command\\n\")\n    raise gdb.GdbError(t)\n\nclass LxSlabTrace(gdb.Command):\n    \"\"\"Show specific cache slabtrace\"\"\"\n\n    def __init__(self):\n        super(LxSlabTrace, self).__init__(\"lx-slabtrace\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        if not constants.LX_CONFIG_SLUB_DEBUG:\n            raise gdb.GdbError(\"CONFIG_SLUB_DEBUG is not enabled\")\n\n        argv = gdb.string_to_argv(arg)\n        alloc = track_alloc # default show alloc_traces\n\n        if len(argv) == 3:\n            if argv[2] == '--alloc':\n                alloc = track_alloc\n            elif argv[2] == '--free':\n                alloc = track_free\n            else:\n                help()\n        if len(argv) >= 2 and argv[0] == '--cache_name':\n            slabtrace(alloc, argv[1])\n        else:\n            help()\nLxSlabTrace()\n\ndef slabinfo():\n    nr_node_ids = None\n\n    if not constants.LX_CONFIG_SLUB_DEBUG:\n        raise gdb.GdbError(\"CONFIG_SLUB_DEBUG is not enabled\")\n\n    def count_free(slab):\n        total_free = 0\n        for slab in lists.list_for_each_entry(slab, slab_ptr_type, 'slab_list'):\n            total_free += int(slab['objects'] - slab['inuse'])\n        return total_free\n\n    gdb.write(\"{:^18} | {:^20} | {:^12} | {:^12} | {:^8} | {:^11} | {:^13}\\n\".format('Pointer', 'name', 'active_objs', 'num_objs', 'objsize', 'objperslab', 'pagesperslab'))\n    gdb.write(\"{:-^18} | {:-^20} | {:-^12} | {:-^12} | {:-^8} | {:-^11} | {:-^13}\\n\".format('', '', '', '', '', '', ''))\n\n    slab_caches = gdb.parse_and_eval(\"slab_caches\")\n    if mm.page_ops().ops.MAX_NUMNODES > 1:\n        nr_node_ids = int(gdb.parse_and_eval(\"nr_node_ids\"))\n    else:\n        nr_node_ids = 1\n\n    for cache in lists.list_for_each_entry(slab_caches, kmem_cache_ptr_type, 'list'):\n        nr_objs = 0\n        nr_free = 0\n        nr_slabs = 0\n        for i in range(0, nr_node_ids):\n            cache_node = cache['node'][i]\n            try:\n                nr_slabs += cache_node['nr_slabs']['counter']\n                nr_objs = int(cache_node['total_objects']['counter'])\n                nr_free = count_free(cache_node['partial'])\n            except:\n                raise gdb.GdbError(traceback.format_exc())\n        active_objs = nr_objs - nr_free\n        num_objs = nr_objs\n        active_slabs = nr_slabs\n        objects_per_slab = oo_objects(cache['oo'])\n        cache_order = oo_order(cache['oo'])\n        gdb.write(\"{:18s} | {:20.19s} | {:12} | {:12} | {:8} | {:11} | {:13}\\n\".format(hex(cache), cache['name'].string(), str(active_objs), str(num_objs), str(cache['size']), str(objects_per_slab), str(1 << cache_order)))\n\nclass LxSlabInfo(gdb.Command):\n    \"\"\"Show slabinfo\"\"\"\n\n    def __init__(self):\n        super(LxSlabInfo, self).__init__(\"lx-slabinfo\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        slabinfo()\nLxSlabInfo()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}