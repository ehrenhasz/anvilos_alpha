{
  "module_name": "interrupts.py",
  "hash_id": "2eab7282f31041550b845b97394ef1c82e0575f1d7391b803af6bb1466256f3a",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/interrupts.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright 2023 Broadcom\n\nimport gdb\n\nfrom linux import constants\nfrom linux import cpus\nfrom linux import utils\nfrom linux import radixtree\n\nirq_desc_type = utils.CachedType(\"struct irq_desc\")\n\ndef irq_settings_is_hidden(desc):\n    return desc['status_use_accessors'] & constants.LX_IRQ_HIDDEN\n\ndef irq_desc_is_chained(desc):\n    return desc['action'] and desc['action'] == gdb.parse_and_eval(\"&chained_action\")\n\ndef irqd_is_level(desc):\n    return desc['irq_data']['common']['state_use_accessors'] & constants.LX_IRQD_LEVEL\n\ndef show_irq_desc(prec, irq):\n    text = \"\"\n\n    desc = radixtree.lookup(gdb.parse_and_eval(\"&irq_desc_tree\"), irq)\n    if desc is None:\n        return text\n\n    desc = desc.cast(irq_desc_type.get_type())\n    if desc is None:\n        return text\n\n    if irq_settings_is_hidden(desc):\n        return text\n\n    any_count = 0\n    if desc['kstat_irqs']:\n        for cpu in cpus.each_online_cpu():\n            any_count += cpus.per_cpu(desc['kstat_irqs'], cpu)\n\n    if (desc['action'] == 0 or irq_desc_is_chained(desc)) and any_count == 0:\n        return text;\n\n    text += \"%*d: \" % (prec, irq)\n    for cpu in cpus.each_online_cpu():\n        if desc['kstat_irqs']:\n            count = cpus.per_cpu(desc['kstat_irqs'], cpu)\n        else:\n            count = 0\n        text += \"%10u\" % (count)\n\n    name = \"None\"\n    if desc['irq_data']['chip']:\n        chip = desc['irq_data']['chip']\n        if chip['name']:\n            name = chip['name'].string()\n        else:\n            name = \"-\"\n\n    text += \"  %8s\" % (name)\n\n    if desc['irq_data']['domain']:\n        text += \"  %*lu\" % (prec, desc['irq_data']['hwirq'])\n    else:\n        text += \"  %*s\" % (prec, \"\")\n\n    if constants.LX_CONFIG_GENERIC_IRQ_SHOW_LEVEL:\n        text += \" %-8s\" % (\"Level\" if irqd_is_level(desc) else \"Edge\")\n\n    if desc['name']:\n        text += \"-%-8s\" % (desc['name'].string())\n\n    \"\"\" Some toolchains may not be able to provide information about irqaction \"\"\"\n    try:\n        gdb.lookup_type(\"struct irqaction\")\n        action = desc['action']\n        if action is not None:\n            text += \"  %s\" % (action['name'].string())\n            while True:\n                action = action['next']\n                if action is not None:\n                    break\n                if action['name']:\n                    text += \", %s\" % (action['name'].string())\n    except:\n        pass\n\n    text += \"\\n\"\n\n    return text\n\ndef show_irq_err_count(prec):\n    cnt = utils.gdb_eval_or_none(\"irq_err_count\")\n    text = \"\"\n    if cnt is not None:\n        text += \"%*s: %10u\\n\" % (prec, \"ERR\", cnt['counter'])\n    return text\n\ndef x86_show_irqstat(prec, pfx, field, desc):\n    irq_stat = gdb.parse_and_eval(\"&irq_stat\")\n    text = \"%*s: \" % (prec, pfx)\n    for cpu in cpus.each_online_cpu():\n        stat = cpus.per_cpu(irq_stat, cpu)\n        text += \"%10u \" % (stat[field])\n    text += \"  %s\\n\" % (desc)\n    return text\n\ndef x86_show_mce(prec, var, pfx, desc):\n    pvar = gdb.parse_and_eval(var)\n    text = \"%*s: \" % (prec, pfx)\n    for cpu in cpus.each_online_cpu():\n        text += \"%10u \" % (cpus.per_cpu(pvar, cpu))\n    text += \"  %s\\n\" % (desc)\n    return text\n\ndef x86_show_interupts(prec):\n    text = x86_show_irqstat(prec, \"NMI\", '__nmi_count', 'Non-maskable interrupts')\n\n    if constants.LX_CONFIG_X86_LOCAL_APIC:\n        text += x86_show_irqstat(prec, \"LOC\", 'apic_timer_irqs', \"Local timer interrupts\")\n        text += x86_show_irqstat(prec, \"SPU\", 'irq_spurious_count', \"Spurious interrupts\")\n        text += x86_show_irqstat(prec, \"PMI\", 'apic_perf_irqs', \"Performance monitoring interrupts\")\n        text += x86_show_irqstat(prec, \"IWI\", 'apic_irq_work_irqs', \"IRQ work interrupts\")\n        text += x86_show_irqstat(prec, \"RTR\", 'icr_read_retry_count', \"APIC ICR read retries\")\n        if utils.gdb_eval_or_none(\"x86_platform_ipi_callback\") is not None:\n            text += x86_show_irqstat(prec, \"PLT\", 'x86_platform_ipis', \"Platform interrupts\")\n\n    if constants.LX_CONFIG_SMP:\n        text += x86_show_irqstat(prec, \"RES\", 'irq_resched_count', \"Rescheduling interrupts\")\n        text += x86_show_irqstat(prec, \"CAL\", 'irq_call_count', \"Function call interrupts\")\n        text += x86_show_irqstat(prec, \"TLB\", 'irq_tlb_count', \"TLB shootdowns\")\n\n    if constants.LX_CONFIG_X86_THERMAL_VECTOR:\n        text += x86_show_irqstat(prec, \"TRM\", 'irq_thermal_count', \"Thermal events interrupts\")\n\n    if constants.LX_CONFIG_X86_MCE_THRESHOLD:\n        text += x86_show_irqstat(prec, \"THR\", 'irq_threshold_count', \"Threshold APIC interrupts\")\n\n    if constants.LX_CONFIG_X86_MCE_AMD:\n        text += x86_show_irqstat(prec, \"DFR\", 'irq_deferred_error_count', \"Deferred Error APIC interrupts\")\n\n    if constants.LX_CONFIG_X86_MCE:\n        text += x86_show_mce(prec, \"&mce_exception_count\", \"MCE\", \"Machine check exceptions\")\n        text == x86_show_mce(prec, \"&mce_poll_count\", \"MCP\", \"Machine check polls\")\n\n    text += show_irq_err_count(prec)\n\n    if constants.LX_CONFIG_X86_IO_APIC:\n        cnt = utils.gdb_eval_or_none(\"irq_mis_count\")\n        if cnt is not None:\n            text += \"%*s: %10u\\n\" % (prec, \"MIS\", cnt['counter'])\n\n    if constants.LX_CONFIG_HAVE_KVM:\n        text += x86_show_irqstat(prec, \"PIN\", 'kvm_posted_intr_ipis', 'Posted-interrupt notification event')\n        text += x86_show_irqstat(prec, \"NPI\", 'kvm_posted_intr_nested_ipis', 'Nested posted-interrupt event')\n        text += x86_show_irqstat(prec, \"PIW\", 'kvm_posted_intr_wakeup_ipis', 'Posted-interrupt wakeup event')\n\n    return text\n\ndef arm_common_show_interrupts(prec):\n    text = \"\"\n    nr_ipi = utils.gdb_eval_or_none(\"nr_ipi\")\n    ipi_desc = utils.gdb_eval_or_none(\"ipi_desc\")\n    ipi_types = utils.gdb_eval_or_none(\"ipi_types\")\n    if nr_ipi is None or ipi_desc is None or ipi_types is None:\n        return text\n\n    if prec >= 4:\n        sep = \" \"\n    else:\n        sep = \"\"\n\n    for ipi in range(nr_ipi):\n        text += \"%*s%u:%s\" % (prec - 1, \"IPI\", ipi, sep)\n        desc = ipi_desc[ipi].cast(irq_desc_type.get_type().pointer())\n        if desc == 0:\n            continue\n        for cpu in cpus.each_online_cpu():\n            text += \"%10u\" % (cpus.per_cpu(desc['kstat_irqs'], cpu))\n        text += \"      %s\" % (ipi_types[ipi].string())\n        text += \"\\n\"\n    return text\n\ndef aarch64_show_interrupts(prec):\n    text = arm_common_show_interrupts(prec)\n    text += \"%*s: %10lu\\n\" % (prec, \"ERR\", gdb.parse_and_eval(\"irq_err_count\"))\n    return text\n\ndef arch_show_interrupts(prec):\n    text = \"\"\n    if utils.is_target_arch(\"x86\"):\n        text += x86_show_interupts(prec)\n    elif utils.is_target_arch(\"aarch64\"):\n        text += aarch64_show_interrupts(prec)\n    elif utils.is_target_arch(\"arm\"):\n        text += arm_common_show_interrupts(prec)\n    elif utils.is_target_arch(\"mips\"):\n        text += show_irq_err_count(prec)\n    else:\n        raise gdb.GdbError(\"Unsupported architecture: {}\".format(target_arch))\n\n    return text\n\nclass LxInterruptList(gdb.Command):\n    \"\"\"Print /proc/interrupts\"\"\"\n\n    def __init__(self):\n        super(LxInterruptList, self).__init__(\"lx-interruptlist\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        nr_irqs = gdb.parse_and_eval(\"nr_irqs\")\n        prec = 3\n        j = 1000\n        while prec < 10 and j <= nr_irqs:\n            prec += 1\n            j *= 10\n\n        gdb.write(\"%*s\" % (prec + 8, \"\"))\n        for cpu in cpus.each_online_cpu():\n            gdb.write(\"CPU%-8d\" % cpu)\n        gdb.write(\"\\n\")\n\n        if utils.gdb_eval_or_none(\"&irq_desc_tree\") is None:\n            return\n\n        for irq in range(nr_irqs):\n            gdb.write(show_irq_desc(prec, irq))\n        gdb.write(arch_show_interrupts(prec))\n\n\nLxInterruptList()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}