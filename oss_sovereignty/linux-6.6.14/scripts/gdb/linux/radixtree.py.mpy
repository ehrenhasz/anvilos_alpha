{
  "module_name": "radixtree.py",
  "hash_id": "f511d9cf7a9710c715b708d7a118589d55020eb89c34883bb47650165787bceb",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/radixtree.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n#  Radix Tree Parser\n#\n# Copyright (c) 2016 Linaro Ltd\n# Copyright (c) 2023 Broadcom\n#\n# Authors:\n#  Kieran Bingham <kieran.bingham@linaro.org>\n#  Florian Fainelli <f.fainelli@gmail.com>\n\nimport gdb\n\nfrom linux import utils\nfrom linux import constants\n\nradix_tree_root_type = utils.CachedType(\"struct xarray\")\nradix_tree_node_type = utils.CachedType(\"struct xa_node\")\n\ndef is_internal_node(node):\n    long_type = utils.get_long_type()\n    return ((node.cast(long_type) & constants.LX_RADIX_TREE_ENTRY_MASK) == constants.LX_RADIX_TREE_INTERNAL_NODE)\n\ndef entry_to_node(node):\n    long_type = utils.get_long_type()\n    node_type = node.type\n    indirect_ptr = node.cast(long_type) & ~constants.LX_RADIX_TREE_INTERNAL_NODE\n    return indirect_ptr.cast(radix_tree_node_type.get_type().pointer())\n\ndef node_maxindex(node):\n    return (constants.LX_RADIX_TREE_MAP_SIZE << node['shift']) - 1\n\ndef lookup(root, index):\n    if root.type == radix_tree_root_type.get_type().pointer():\n        node = root.dereference()\n    elif root.type != radix_tree_root_type.get_type():\n        raise gdb.GdbError(\"must be {} not {}\"\n                           .format(radix_tree_root_type.get_type(), root.type))\n\n    node = root['xa_head']\n    if node == 0:\n        return None\n\n    if not (is_internal_node(node)):\n        if (index > 0):\n            return None\n        return node\n\n    node = entry_to_node(node)\n    maxindex = node_maxindex(node)\n\n    if (index > maxindex):\n        return None\n\n    shift = node['shift'] + constants.LX_RADIX_TREE_MAP_SHIFT\n\n    while True:\n        offset = (index >> node['shift']) & constants.LX_RADIX_TREE_MAP_MASK\n        slot = node['slots'][offset]\n\n        if slot == 0:\n            return None\n\n        node = slot.cast(node.type.pointer()).dereference()\n        if node == 0:\n            return None\n\n        shift -= constants.LX_RADIX_TREE_MAP_SHIFT\n        if (shift <= 0):\n            break\n\n    return node\n\nclass LxRadixTree(gdb.Function):\n    \"\"\" Lookup and return a node from a RadixTree.\n\n$lx_radix_tree_lookup(root_node [, index]): Return the node at the given index.\nIf index is omitted, the root node is dereference and returned.\"\"\"\n\n    def __init__(self):\n        super(LxRadixTree, self).__init__(\"lx_radix_tree_lookup\")\n\n    def invoke(self, root, index=0):\n        result = lookup(root, index)\n        if result is None:\n            raise gdb.GdbError(\"No entry in tree at index {}\".format(index))\n\n        return result\n\nLxRadixTree()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}