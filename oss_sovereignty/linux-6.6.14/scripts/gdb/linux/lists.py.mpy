{
  "module_name": "lists.py",
  "hash_id": "775d8c343da1dfbcf2a4adddf88439a202ff34e90c868f8d3a1f0e379a22a788",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/lists.py",
  "human_readable_source": "#\n# gdb helper commands and functions for Linux kernel debugging\n#\n#  list tools\n#\n# Copyright (c) Thiebaud Weksteen, 2015\n#\n# Authors:\n#  Thiebaud Weksteen <thiebaud@weksteen.fr>\n#\n# This work is licensed under the terms of the GNU GPL version 2.\n#\n\nimport gdb\n\nfrom linux import utils\n\nlist_head = utils.CachedType(\"struct list_head\")\nhlist_head = utils.CachedType(\"struct hlist_head\")\nhlist_node = utils.CachedType(\"struct hlist_node\")\n\n\ndef list_for_each(head):\n    if head.type == list_head.get_type().pointer():\n        head = head.dereference()\n    elif head.type != list_head.get_type():\n        raise TypeError(\"Must be struct list_head not {}\"\n                           .format(head.type))\n\n    if head['next'] == 0:\n        gdb.write(\"list_for_each: Uninitialized list '{}' treated as empty\\n\"\n                     .format(head.address))\n        return\n\n    node = head['next'].dereference()\n    while node.address != head.address:\n        yield node.address\n        node = node['next'].dereference()\n\n\ndef list_for_each_entry(head, gdbtype, member):\n    for node in list_for_each(head):\n        yield utils.container_of(node, gdbtype, member)\n\n\ndef hlist_for_each(head):\n    if head.type == hlist_head.get_type().pointer():\n        head = head.dereference()\n    elif head.type != hlist_head.get_type():\n        raise TypeError(\"Must be struct hlist_head not {}\"\n                           .format(head.type))\n\n    node = head['first'].dereference()\n    while node.address:\n        yield node.address\n        node = node['next'].dereference()\n\n\ndef hlist_for_each_entry(head, gdbtype, member):\n    for node in hlist_for_each(head):\n        yield utils.container_of(node, gdbtype, member)\n\n\ndef list_check(head):\n    nb = 0\n    if (head.type == list_head.get_type().pointer()):\n        head = head.dereference()\n    elif (head.type != list_head.get_type()):\n        raise gdb.GdbError('argument must be of type (struct list_head [*])')\n    c = head\n    try:\n        gdb.write(\"Starting with: {}\\n\".format(c))\n    except gdb.MemoryError:\n        gdb.write('head is not accessible\\n')\n        return\n    while True:\n        p = c['prev'].dereference()\n        n = c['next'].dereference()\n        try:\n            if p['next'] != c.address:\n                gdb.write('prev.next != current: '\n                          'current@{current_addr}={current} '\n                          'prev@{p_addr}={p}\\n'.format(\n                              current_addr=c.address,\n                              current=c,\n                              p_addr=p.address,\n                              p=p,\n                          ))\n                return\n        except gdb.MemoryError:\n            gdb.write('prev is not accessible: '\n                      'current@{current_addr}={current}\\n'.format(\n                          current_addr=c.address,\n                          current=c\n                      ))\n            return\n        try:\n            if n['prev'] != c.address:\n                gdb.write('next.prev != current: '\n                          'current@{current_addr}={current} '\n                          'next@{n_addr}={n}\\n'.format(\n                              current_addr=c.address,\n                              current=c,\n                              n_addr=n.address,\n                              n=n,\n                          ))\n                return\n        except gdb.MemoryError:\n            gdb.write('next is not accessible: '\n                      'current@{current_addr}={current}\\n'.format(\n                          current_addr=c.address,\n                          current=c\n                      ))\n            return\n        c = n\n        nb += 1\n        if c == head:\n            gdb.write(\"list is consistent: {} node(s)\\n\".format(nb))\n            return\n\n\nclass LxListChk(gdb.Command):\n    \"\"\"Verify a list consistency\"\"\"\n\n    def __init__(self):\n        super(LxListChk, self).__init__(\"lx-list-check\", gdb.COMMAND_DATA,\n                                        gdb.COMPLETE_EXPRESSION)\n\n    def invoke(self, arg, from_tty):\n        argv = gdb.string_to_argv(arg)\n        if len(argv) != 1:\n            raise gdb.GdbError(\"lx-list-check takes one argument\")\n        list_check(gdb.parse_and_eval(argv[0]))\n\n\nLxListChk()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}