{
  "module_name": "pgtable.py",
  "hash_id": "628eb8b943a883dee2cf21d4663a17813ccf050820044d6a58b3472b97b445b3",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/pgtable.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# gdb helper commands and functions for Linux kernel debugging\n#\n#  routines to introspect page table\n#\n# Authors:\n#  Dmitrii Bundin <dmitrii.bundin.a@gmail.com>\n#\n\nimport gdb\n\nfrom linux import utils\n\nPHYSICAL_ADDRESS_MASK = gdb.parse_and_eval('0xfffffffffffff')\n\n\ndef page_mask(level=1):\n    # 4KB\n    if level == 1:\n        return gdb.parse_and_eval('(u64) ~0xfff')\n    # 2MB\n    elif level == 2:\n        return gdb.parse_and_eval('(u64) ~0x1fffff')\n    # 1GB\n    elif level == 3:\n        return gdb.parse_and_eval('(u64) ~0x3fffffff')\n    else:\n        raise Exception(f'Unknown page level: {level}')\n\n\n#page_offset_base in case CONFIG_DYNAMIC_MEMORY_LAYOUT is disabled\nPOB_NO_DYNAMIC_MEM_LAYOUT = '0xffff888000000000'\ndef _page_offset_base():\n    pob_symbol = gdb.lookup_global_symbol('page_offset_base')\n    pob = pob_symbol.name if pob_symbol else POB_NO_DYNAMIC_MEM_LAYOUT\n    return gdb.parse_and_eval(pob)\n\n\ndef is_bit_defined_tupled(data, offset):\n    return offset, bool(data >> offset & 1)\n\ndef content_tupled(data, bit_start, bit_end):\n    return (bit_start, bit_end), data >> bit_start & ((1 << (1 + bit_end - bit_start)) - 1)\n\ndef entry_va(level, phys_addr, translating_va):\n        def start_bit(level):\n            if level == 5:\n                return 48\n            elif level == 4:\n                return 39\n            elif level == 3:\n                return 30\n            elif level == 2:\n                return 21\n            elif level == 1:\n                return 12\n            else:\n                raise Exception(f'Unknown level {level}')\n\n        entry_offset =  ((translating_va >> start_bit(level)) & 511) * 8\n        entry_va = _page_offset_base() + phys_addr + entry_offset\n        return entry_va\n\nclass Cr3():\n    def __init__(self, cr3, page_levels):\n        self.cr3 = cr3\n        self.page_levels = page_levels\n        self.page_level_write_through = is_bit_defined_tupled(cr3, 3)\n        self.page_level_cache_disabled = is_bit_defined_tupled(cr3, 4)\n        self.next_entry_physical_address = cr3 & PHYSICAL_ADDRESS_MASK & page_mask()\n\n    def next_entry(self, va):\n        next_level = self.page_levels\n        return PageHierarchyEntry(entry_va(next_level, self.next_entry_physical_address, va), next_level)\n\n    def mk_string(self):\n            return f\"\"\"\\\ncr3:\n    {'cr3 binary data': <30} {hex(self.cr3)}\n    {'next entry physical address': <30} {hex(self.next_entry_physical_address)}\n    ---\n    {'bit' : <4} {self.page_level_write_through[0]: <10} {'page level write through': <30} {self.page_level_write_through[1]}\n    {'bit' : <4} {self.page_level_cache_disabled[0]: <10} {'page level cache disabled': <30} {self.page_level_cache_disabled[1]}\n\"\"\"\n\n\nclass PageHierarchyEntry():\n    def __init__(self, address, level):\n        data = int.from_bytes(\n            memoryview(gdb.selected_inferior().read_memory(address, 8)),\n            \"little\"\n        )\n        if level == 1:\n            self.is_page = True\n            self.entry_present = is_bit_defined_tupled(data, 0)\n            self.read_write = is_bit_defined_tupled(data, 1)\n            self.user_access_allowed = is_bit_defined_tupled(data, 2)\n            self.page_level_write_through = is_bit_defined_tupled(data, 3)\n            self.page_level_cache_disabled = is_bit_defined_tupled(data, 4)\n            self.entry_was_accessed = is_bit_defined_tupled(data, 5)\n            self.dirty = is_bit_defined_tupled(data, 6)\n            self.pat = is_bit_defined_tupled(data, 7)\n            self.global_translation = is_bit_defined_tupled(data, 8)\n            self.page_physical_address = data & PHYSICAL_ADDRESS_MASK & page_mask(level)\n            self.next_entry_physical_address = None\n            self.hlat_restart_with_ordinary = is_bit_defined_tupled(data, 11)\n            self.protection_key = content_tupled(data, 59, 62)\n            self.executed_disable = is_bit_defined_tupled(data, 63)\n        else:\n            page_size = is_bit_defined_tupled(data, 7)\n            page_size_bit = page_size[1]\n            self.is_page = page_size_bit\n            self.entry_present = is_bit_defined_tupled(data, 0)\n            self.read_write = is_bit_defined_tupled(data, 1)\n            self.user_access_allowed = is_bit_defined_tupled(data, 2)\n            self.page_level_write_through = is_bit_defined_tupled(data, 3)\n            self.page_level_cache_disabled = is_bit_defined_tupled(data, 4)\n            self.entry_was_accessed = is_bit_defined_tupled(data, 5)\n            self.page_size = page_size\n            self.dirty = is_bit_defined_tupled(\n                data, 6) if page_size_bit else None\n            self.global_translation = is_bit_defined_tupled(\n                data, 8) if page_size_bit else None\n            self.pat = is_bit_defined_tupled(\n                data, 12) if page_size_bit else None\n            self.page_physical_address = data & PHYSICAL_ADDRESS_MASK & page_mask(level) if page_size_bit else None\n            self.next_entry_physical_address = None if page_size_bit else data & PHYSICAL_ADDRESS_MASK & page_mask()\n            self.hlat_restart_with_ordinary = is_bit_defined_tupled(data, 11)\n            self.protection_key = content_tupled(data, 59, 62) if page_size_bit else None\n            self.executed_disable = is_bit_defined_tupled(data, 63)\n        self.address = address\n        self.page_entry_binary_data = data\n        self.page_hierarchy_level = level\n\n    def next_entry(self, va):\n        if self.is_page or not self.entry_present[1]:\n            return None\n\n        next_level = self.page_hierarchy_level - 1\n        return PageHierarchyEntry(entry_va(next_level, self.next_entry_physical_address, va), next_level)\n\n\n    def mk_string(self):\n        if not self.entry_present[1]:\n            return f\"\"\"\\\nlevel {self.page_hierarchy_level}:\n    {'entry address': <30} {hex(self.address)}\n    {'page entry binary data': <30} {hex(self.page_entry_binary_data)}\n    ---\n    PAGE ENTRY IS NOT PRESENT!\n\"\"\"\n        elif self.is_page:\n            def page_size_line(ps_bit, ps, level):\n                return \"\" if level == 1 else f\"{'bit': <3} {ps_bit: <5} {'page size': <30} {ps}\"\n\n            return f\"\"\"\\\nlevel {self.page_hierarchy_level}:\n    {'entry address': <30} {hex(self.address)}\n    {'page entry binary data': <30} {hex(self.page_entry_binary_data)}\n    {'page size': <30} {'1GB' if self.page_hierarchy_level == 3 else '2MB' if self.page_hierarchy_level == 2 else '4KB' if self.page_hierarchy_level == 1 else 'Unknown page size for level:' + self.page_hierarchy_level}\n    {'page physical address': <30} {hex(self.page_physical_address)}\n    ---\n    {'bit': <4} {self.entry_present[0]: <10} {'entry present': <30} {self.entry_present[1]}\n    {'bit': <4} {self.read_write[0]: <10} {'read/write access allowed': <30} {self.read_write[1]}\n    {'bit': <4} {self.user_access_allowed[0]: <10} {'user access allowed': <30} {self.user_access_allowed[1]}\n    {'bit': <4} {self.page_level_write_through[0]: <10} {'page level write through': <30} {self.page_level_write_through[1]}\n    {'bit': <4} {self.page_level_cache_disabled[0]: <10} {'page level cache disabled': <30} {self.page_level_cache_disabled[1]}\n    {'bit': <4} {self.entry_was_accessed[0]: <10} {'entry has been accessed': <30} {self.entry_was_accessed[1]}\n    {\"\" if self.page_hierarchy_level == 1 else f\"{'bit': <4} {self.page_size[0]: <10} {'page size': <30} {self.page_size[1]}\"}\n    {'bit': <4} {self.dirty[0]: <10} {'page dirty': <30} {self.dirty[1]}\n    {'bit': <4} {self.global_translation[0]: <10} {'global translation': <30} {self.global_translation[1]}\n    {'bit': <4} {self.hlat_restart_with_ordinary[0]: <10} {'restart to ordinary': <30} {self.hlat_restart_with_ordinary[1]}\n    {'bit': <4} {self.pat[0]: <10} {'pat': <30} {self.pat[1]}\n    {'bits': <4} {str(self.protection_key[0]): <10} {'protection key': <30} {self.protection_key[1]}\n    {'bit': <4} {self.executed_disable[0]: <10} {'execute disable': <30} {self.executed_disable[1]}\n\"\"\"\n        else:\n            return f\"\"\"\\\nlevel {self.page_hierarchy_level}:\n    {'entry address': <30} {hex(self.address)}\n    {'page entry binary data': <30} {hex(self.page_entry_binary_data)}\n    {'next entry physical address': <30} {hex(self.next_entry_physical_address)}\n    ---\n    {'bit': <4} {self.entry_present[0]: <10} {'entry present': <30} {self.entry_present[1]}\n    {'bit': <4} {self.read_write[0]: <10} {'read/write access allowed': <30} {self.read_write[1]}\n    {'bit': <4} {self.user_access_allowed[0]: <10} {'user access allowed': <30} {self.user_access_allowed[1]}\n    {'bit': <4} {self.page_level_write_through[0]: <10} {'page level write through': <30} {self.page_level_write_through[1]}\n    {'bit': <4} {self.page_level_cache_disabled[0]: <10} {'page level cache disabled': <30} {self.page_level_cache_disabled[1]}\n    {'bit': <4} {self.entry_was_accessed[0]: <10} {'entry has been accessed': <30} {self.entry_was_accessed[1]}\n    {'bit': <4} {self.page_size[0]: <10} {'page size': <30} {self.page_size[1]}\n    {'bit': <4} {self.hlat_restart_with_ordinary[0]: <10} {'restart to ordinary': <30} {self.hlat_restart_with_ordinary[1]}\n    {'bit': <4} {self.executed_disable[0]: <10} {'execute disable': <30} {self.executed_disable[1]}\n\"\"\"\n\n\nclass TranslateVM(gdb.Command):\n    \"\"\"Prints the entire paging structure used to translate a given virtual address.\n\nHaving an address space of the currently executed process translates the virtual address\nand prints detailed information of all paging structure levels used for the transaltion.\nCurrently supported arch: x86\"\"\"\n\n    def __init__(self):\n        super(TranslateVM, self).__init__('translate-vm', gdb.COMMAND_USER)\n\n    def invoke(self, arg, from_tty):\n        if utils.is_target_arch(\"x86\"):\n            vm_address = gdb.parse_and_eval(f'{arg}')\n            cr3_data = gdb.parse_and_eval('$cr3')\n            cr4 = gdb.parse_and_eval('$cr4')\n            page_levels = 5 if cr4 & (1 << 12) else 4\n            page_entry = Cr3(cr3_data, page_levels)\n            while page_entry:\n                gdb.write(page_entry.mk_string())\n                page_entry = page_entry.next_entry(vm_address)\n        else:\n            gdb.GdbError(\"Virtual address translation is not\"\n                         \"supported for this arch\")\n\n\nTranslateVM()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}