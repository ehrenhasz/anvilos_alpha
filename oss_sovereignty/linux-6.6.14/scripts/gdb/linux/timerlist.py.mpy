{
  "module_name": "timerlist.py",
  "hash_id": "41855c64eb5105853b2b41d00f52adccc98e326267b321bbf395c27abd681331",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/timerlist.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright 2019 Google LLC.\n\nimport binascii\nimport gdb\n\nfrom linux import constants\nfrom linux import cpus\nfrom linux import rbtree\nfrom linux import utils\n\ntimerqueue_node_type = utils.CachedType(\"struct timerqueue_node\").get_type()\nhrtimer_type = utils.CachedType(\"struct hrtimer\").get_type()\n\n\ndef ktime_get():\n    \"\"\"Returns the current time, but not very accurately\n\n    We can't read the hardware timer itself to add any nanoseconds\n    that need to be added since we last stored the time in the\n    timekeeper. But this is probably good enough for debug purposes.\"\"\"\n    tk_core = gdb.parse_and_eval(\"&tk_core\")\n\n    return tk_core['timekeeper']['tkr_mono']['base']\n\n\ndef print_timer(rb_node, idx):\n    timerqueue = utils.container_of(rb_node, timerqueue_node_type.pointer(),\n                                    \"node\")\n    timer = utils.container_of(timerqueue, hrtimer_type.pointer(), \"node\")\n\n    function = str(timer['function']).split(\" \")[1].strip(\"<>\")\n    softexpires = timer['_softexpires']\n    expires = timer['node']['expires']\n    now = ktime_get()\n\n    text = \" #{}: <{}>, {}, \".format(idx, timer, function)\n    text += \"S:{:02x}\\n\".format(int(timer['state']))\n    text += \" # expires at {}-{} nsecs [in {} to {} nsecs]\\n\".format(\n            softexpires, expires, softexpires - now, expires - now)\n    return text\n\n\ndef print_active_timers(base):\n    curr = base['active']['rb_root']['rb_leftmost']\n    idx = 0\n    while curr:\n        yield print_timer(curr, idx)\n        curr = rbtree.rb_next(curr)\n        idx += 1\n\n\ndef print_base(base):\n    text = \" .base:       {}\\n\".format(base.address)\n    text += \" .index:      {}\\n\".format(base['index'])\n\n    text += \" .resolution: {} nsecs\\n\".format(constants.LX_hrtimer_resolution)\n\n    text += \" .get_time:   {}\\n\".format(base['get_time'])\n    if constants.LX_CONFIG_HIGH_RES_TIMERS:\n        text += \"  .offset:     {} nsecs\\n\".format(base['offset'])\n    text += \"active timers:\\n\"\n    text += \"\".join([x for x in print_active_timers(base)])\n    return text\n\n\ndef print_cpu(hrtimer_bases, cpu, max_clock_bases):\n    cpu_base = cpus.per_cpu(hrtimer_bases, cpu)\n    jiffies = gdb.parse_and_eval(\"jiffies_64\")\n    tick_sched_ptr = gdb.parse_and_eval(\"&tick_cpu_sched\")\n    ts = cpus.per_cpu(tick_sched_ptr, cpu)\n\n    text = \"cpu: {}\\n\".format(cpu)\n    for i in range(max_clock_bases):\n        text += \" clock {}:\\n\".format(i)\n        text += print_base(cpu_base['clock_base'][i])\n\n        if constants.LX_CONFIG_HIGH_RES_TIMERS:\n            fmts = [(\"  .{}   : {} nsecs\", 'expires_next'),\n                    (\"  .{}    : {}\", 'hres_active'),\n                    (\"  .{}      : {}\", 'nr_events'),\n                    (\"  .{}     : {}\", 'nr_retries'),\n                    (\"  .{}       : {}\", 'nr_hangs'),\n                    (\"  .{}  : {}\", 'max_hang_time')]\n            text += \"\\n\".join([s.format(f, cpu_base[f]) for s, f in fmts])\n            text += \"\\n\"\n\n        if constants.LX_CONFIG_TICK_ONESHOT:\n            fmts = [(\"  .{}      : {}\", 'nohz_mode'),\n                    (\"  .{}      : {} nsecs\", 'last_tick'),\n                    (\"  .{}   : {}\", 'tick_stopped'),\n                    (\"  .{}   : {}\", 'idle_jiffies'),\n                    (\"  .{}     : {}\", 'idle_calls'),\n                    (\"  .{}    : {}\", 'idle_sleeps'),\n                    (\"  .{} : {} nsecs\", 'idle_entrytime'),\n                    (\"  .{}  : {} nsecs\", 'idle_waketime'),\n                    (\"  .{}  : {} nsecs\", 'idle_exittime'),\n                    (\"  .{} : {} nsecs\", 'idle_sleeptime'),\n                    (\"  .{}: {} nsecs\", 'iowait_sleeptime'),\n                    (\"  .{}   : {}\", 'last_jiffies'),\n                    (\"  .{}     : {}\", 'next_timer'),\n                    (\"  .{}   : {} nsecs\", 'idle_expires')]\n            text += \"\\n\".join([s.format(f, ts[f]) for s, f in fmts])\n            text += \"\\njiffies: {}\\n\".format(jiffies)\n\n        text += \"\\n\"\n\n    return text\n\n\ndef print_tickdevice(td, cpu):\n    dev = td['evtdev']\n    text = \"Tick Device: mode:     {}\\n\".format(td['mode'])\n    if cpu < 0:\n            text += \"Broadcast device\\n\"\n    else:\n            text += \"Per CPU device: {}\\n\".format(cpu)\n\n    text += \"Clock Event Device: \"\n    if dev == 0:\n            text += \"<NULL>\\n\"\n            return text\n\n    text += \"{}\\n\".format(dev['name'])\n    text += \" max_delta_ns:   {}\\n\".format(dev['max_delta_ns'])\n    text += \" min_delta_ns:   {}\\n\".format(dev['min_delta_ns'])\n    text += \" mult:           {}\\n\".format(dev['mult'])\n    text += \" shift:          {}\\n\".format(dev['shift'])\n    text += \" mode:           {}\\n\".format(dev['state_use_accessors'])\n    text += \" next_event:     {} nsecs\\n\".format(dev['next_event'])\n\n    text += \" set_next_event: {}\\n\".format(dev['set_next_event'])\n\n    members = [('set_state_shutdown', \" shutdown: {}\\n\"),\n               ('set_state_periodic', \" periodic: {}\\n\"),\n               ('set_state_oneshot', \" oneshot:  {}\\n\"),\n               ('set_state_oneshot_stopped', \" oneshot stopped: {}\\n\"),\n               ('tick_resume', \" resume:   {}\\n\")]\n    for member, fmt in members:\n        if dev[member]:\n            text += fmt.format(dev[member])\n\n    text += \" event_handler:  {}\\n\".format(dev['event_handler'])\n    text += \" retries:        {}\\n\".format(dev['retries'])\n\n    return text\n\n\ndef pr_cpumask(mask):\n    nr_cpu_ids = 1\n    if constants.LX_NR_CPUS > 1:\n        nr_cpu_ids = gdb.parse_and_eval(\"nr_cpu_ids\")\n\n    inf = gdb.inferiors()[0]\n    bits = mask['bits']\n    num_bytes = (nr_cpu_ids + 7) / 8\n    buf = utils.read_memoryview(inf, bits, num_bytes).tobytes()\n    buf = binascii.b2a_hex(buf)\n    if type(buf) is not str:\n        buf=buf.decode()\n\n    chunks = []\n    i = num_bytes\n    while i > 0:\n        i -= 1\n        start = i * 2\n        end = start + 2\n        chunks.append(buf[start:end])\n        if i != 0 and i % 4 == 0:\n            chunks.append(',')\n\n    extra = nr_cpu_ids % 8\n    if 0 < extra <= 4:\n        chunks[0] = chunks[0][0]  # Cut off the first 0\n\n    return \"\".join(str(chunks))\n\n\nclass LxTimerList(gdb.Command):\n    \"\"\"Print /proc/timer_list\"\"\"\n\n    def __init__(self):\n        super(LxTimerList, self).__init__(\"lx-timerlist\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        hrtimer_bases = gdb.parse_and_eval(\"&hrtimer_bases\")\n        max_clock_bases = gdb.parse_and_eval(\"HRTIMER_MAX_CLOCK_BASES\")\n\n        text = \"Timer List Version: gdb scripts\\n\"\n        text += \"HRTIMER_MAX_CLOCK_BASES: {}\\n\".format(\n            max_clock_bases.type.fields()[max_clock_bases].enumval)\n        text += \"now at {} nsecs\\n\".format(ktime_get())\n\n        for cpu in cpus.each_online_cpu():\n            text += print_cpu(hrtimer_bases, cpu, max_clock_bases)\n\n        if constants.LX_CONFIG_GENERIC_CLOCKEVENTS:\n            if constants.LX_CONFIG_GENERIC_CLOCKEVENTS_BROADCAST:\n                bc_dev = gdb.parse_and_eval(\"&tick_broadcast_device\")\n                text += print_tickdevice(bc_dev, -1)\n                text += \"\\n\"\n                mask = gdb.parse_and_eval(\"tick_broadcast_mask\")\n                mask = pr_cpumask(mask)\n                text += \"tick_broadcast_mask: {}\\n\".format(mask)\n                if constants.LX_CONFIG_TICK_ONESHOT:\n                    mask = gdb.parse_and_eval(\"tick_broadcast_oneshot_mask\")\n                    mask = pr_cpumask(mask)\n                    text += \"tick_broadcast_oneshot_mask: {}\\n\".format(mask)\n                text += \"\\n\"\n\n            tick_cpu_devices = gdb.parse_and_eval(\"&tick_cpu_device\")\n            for cpu in cpus.each_online_cpu():\n                tick_dev = cpus.per_cpu(tick_cpu_devices, cpu)\n                text += print_tickdevice(tick_dev, cpu)\n                text += \"\\n\"\n\n        gdb.write(text)\n\n\nLxTimerList()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}