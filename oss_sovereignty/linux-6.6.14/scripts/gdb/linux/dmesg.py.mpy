{
  "module_name": "dmesg.py",
  "hash_id": "a817fd262a2f80c3ef5d1a0438b5c621158b2127946e473f9a1b0dbafae2b4b3",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/dmesg.py",
  "human_readable_source": "#\n# gdb helper commands and functions for Linux kernel debugging\n#\n#  kernel log buffer dump\n#\n# Copyright (c) Siemens AG, 2011, 2012\n#\n# Authors:\n#  Jan Kiszka <jan.kiszka@siemens.com>\n#\n# This work is licensed under the terms of the GNU GPL version 2.\n#\n\nimport gdb\nimport sys\n\nfrom linux import utils\n\nprintk_info_type = utils.CachedType(\"struct printk_info\")\nprb_data_blk_lpos_type = utils.CachedType(\"struct prb_data_blk_lpos\")\nprb_desc_type = utils.CachedType(\"struct prb_desc\")\nprb_desc_ring_type = utils.CachedType(\"struct prb_desc_ring\")\nprb_data_ring_type = utils.CachedType(\"struct prb_data_ring\")\nprintk_ringbuffer_type = utils.CachedType(\"struct printk_ringbuffer\")\n\nclass LxDmesg(gdb.Command):\n    \"\"\"Print Linux kernel log buffer.\"\"\"\n\n    def __init__(self):\n        super(LxDmesg, self).__init__(\"lx-dmesg\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        inf = gdb.inferiors()[0]\n\n        # read in prb structure\n        prb_addr = int(str(gdb.parse_and_eval(\"(void *)'printk.c'::prb\")).split()[0], 16)\n        sz = printk_ringbuffer_type.get_type().sizeof\n        prb = utils.read_memoryview(inf, prb_addr, sz).tobytes()\n\n        # read in descriptor ring structure\n        off = printk_ringbuffer_type.get_type()['desc_ring'].bitpos // 8\n        addr = prb_addr + off\n        sz = prb_desc_ring_type.get_type().sizeof\n        desc_ring = utils.read_memoryview(inf, addr, sz).tobytes()\n\n        # read in descriptor count, size, and address\n        off = prb_desc_ring_type.get_type()['count_bits'].bitpos // 8\n        desc_ring_count = 1 << utils.read_u32(desc_ring, off)\n        desc_sz = prb_desc_type.get_type().sizeof\n        off = prb_desc_ring_type.get_type()['descs'].bitpos // 8\n        desc_addr = utils.read_ulong(desc_ring, off)\n\n        # read in info size and address\n        info_sz = printk_info_type.get_type().sizeof\n        off = prb_desc_ring_type.get_type()['infos'].bitpos // 8\n        info_addr = utils.read_ulong(desc_ring, off)\n\n        # read in text data ring structure\n        off = printk_ringbuffer_type.get_type()['text_data_ring'].bitpos // 8\n        addr = prb_addr + off\n        sz = prb_data_ring_type.get_type().sizeof\n        text_data_ring = utils.read_memoryview(inf, addr, sz).tobytes()\n\n        # read in text data size and address\n        off = prb_data_ring_type.get_type()['size_bits'].bitpos // 8\n        text_data_sz = 1 << utils.read_u32(text_data_ring, off)\n        off = prb_data_ring_type.get_type()['data'].bitpos // 8\n        text_data_addr = utils.read_ulong(text_data_ring, off)\n\n        sv_off = prb_desc_type.get_type()['state_var'].bitpos // 8\n\n        off = prb_desc_type.get_type()['text_blk_lpos'].bitpos // 8\n        begin_off = off + (prb_data_blk_lpos_type.get_type()['begin'].bitpos // 8)\n        next_off = off + (prb_data_blk_lpos_type.get_type()['next'].bitpos // 8)\n\n        ts_off = printk_info_type.get_type()['ts_nsec'].bitpos // 8\n        len_off = printk_info_type.get_type()['text_len'].bitpos // 8\n\n        # definitions from kernel/printk/printk_ringbuffer.h\n        desc_committed = 1\n        desc_finalized = 2\n        desc_sv_bits = utils.get_long_type().sizeof * 8\n        desc_flags_shift = desc_sv_bits - 2\n        desc_flags_mask = 3 << desc_flags_shift\n        desc_id_mask = ~desc_flags_mask\n\n        # read in tail and head descriptor ids\n        off = prb_desc_ring_type.get_type()['tail_id'].bitpos // 8\n        tail_id = utils.read_atomic_long(desc_ring, off)\n        off = prb_desc_ring_type.get_type()['head_id'].bitpos // 8\n        head_id = utils.read_atomic_long(desc_ring, off)\n\n        did = tail_id\n        while True:\n            ind = did % desc_ring_count\n            desc_off = desc_sz * ind\n            info_off = info_sz * ind\n\n            desc = utils.read_memoryview(inf, desc_addr + desc_off, desc_sz).tobytes()\n\n            # skip non-committed record\n            state = 3 & (utils.read_atomic_long(desc, sv_off) >> desc_flags_shift)\n            if state != desc_committed and state != desc_finalized:\n                if did == head_id:\n                    break\n                did = (did + 1) & desc_id_mask\n                continue\n\n            begin = utils.read_ulong(desc, begin_off) % text_data_sz\n            end = utils.read_ulong(desc, next_off) % text_data_sz\n\n            info = utils.read_memoryview(inf, info_addr + info_off, info_sz).tobytes()\n\n            # handle data-less record\n            if begin & 1 == 1:\n                text = \"\"\n            else:\n                # handle wrapping data block\n                if begin > end:\n                    begin = 0\n\n                # skip over descriptor id\n                text_start = begin + utils.get_long_type().sizeof\n\n                text_len = utils.read_u16(info, len_off)\n\n                # handle truncated message\n                if end - text_start < text_len:\n                    text_len = end - text_start\n\n                text_data = utils.read_memoryview(inf, text_data_addr + text_start,\n                                                  text_len).tobytes()\n                text = text_data[0:text_len].decode(encoding='utf8', errors='replace')\n\n            time_stamp = utils.read_u64(info, ts_off)\n\n            for line in text.splitlines():\n                msg = u\"[{time:12.6f}] {line}\\n\".format(\n                    time=time_stamp / 1000000000.0,\n                    line=line)\n                # With python2 gdb.write will attempt to convert unicode to\n                # ascii and might fail so pass an utf8-encoded str instead.\n                if sys.hexversion < 0x03000000:\n                    msg = msg.encode(encoding='utf8', errors='replace')\n                gdb.write(msg)\n\n            if did == head_id:\n                break\n            did = (did + 1) & desc_id_mask\n\n\nLxDmesg()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}