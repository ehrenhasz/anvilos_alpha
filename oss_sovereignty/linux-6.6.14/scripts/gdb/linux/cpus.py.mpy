{
  "module_name": "cpus.py",
  "hash_id": "d87daea66395c8317682a519b4792341f83d01efa14ea4c04b03b071dc084487",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gdb/linux/cpus.py",
  "human_readable_source": "#\n# gdb helper commands and functions for Linux kernel debugging\n#\n#  per-cpu tools\n#\n# Copyright (c) Siemens AG, 2011-2013\n#\n# Authors:\n#  Jan Kiszka <jan.kiszka@siemens.com>\n#\n# This work is licensed under the terms of the GNU GPL version 2.\n#\n\nimport gdb\n\nfrom linux import tasks, utils\n\n\ntask_type = utils.CachedType(\"struct task_struct\")\n\n\nMAX_CPUS = 4096\n\n\ndef get_current_cpu():\n    if utils.get_gdbserver_type() == utils.GDBSERVER_QEMU:\n        return gdb.selected_thread().num - 1\n    elif utils.get_gdbserver_type() == utils.GDBSERVER_KGDB:\n        tid = gdb.selected_thread().ptid[2]\n        if tid > (0x100000000 - MAX_CPUS - 2):\n            return 0x100000000 - tid - 2\n        else:\n            return tasks.get_thread_info(tasks.get_task_by_pid(tid))['cpu']\n    else:\n        raise gdb.GdbError(\"Sorry, obtaining the current CPU is not yet \"\n                           \"supported with this gdb server.\")\n\n\ndef per_cpu(var_ptr, cpu):\n    if cpu == -1:\n        cpu = get_current_cpu()\n    if utils.is_target_arch(\"sparc:v9\"):\n        offset = gdb.parse_and_eval(\n            \"trap_block[{0}].__per_cpu_base\".format(str(cpu)))\n    else:\n        try:\n            offset = gdb.parse_and_eval(\n                \"__per_cpu_offset[{0}]\".format(str(cpu)))\n        except gdb.error:\n            # !CONFIG_SMP case\n            offset = 0\n    pointer = var_ptr.cast(utils.get_long_type()) + offset\n    return pointer.cast(var_ptr.type).dereference()\n\n\ncpu_mask = {}\n\n\ndef cpu_mask_invalidate(event):\n    global cpu_mask\n    cpu_mask = {}\n    gdb.events.stop.disconnect(cpu_mask_invalidate)\n    if hasattr(gdb.events, 'new_objfile'):\n        gdb.events.new_objfile.disconnect(cpu_mask_invalidate)\n\n\ndef cpu_list(mask_name):\n    global cpu_mask\n    mask = None\n    if mask_name in cpu_mask:\n        mask = cpu_mask[mask_name]\n    if mask is None:\n        mask = gdb.parse_and_eval(mask_name + \".bits\")\n        if hasattr(gdb, 'events'):\n            cpu_mask[mask_name] = mask\n            gdb.events.stop.connect(cpu_mask_invalidate)\n            if hasattr(gdb.events, 'new_objfile'):\n                gdb.events.new_objfile.connect(cpu_mask_invalidate)\n    bits_per_entry = mask[0].type.sizeof * 8\n    num_entries = mask.type.sizeof * 8 / bits_per_entry\n    entry = -1\n    bits = 0\n\n    while True:\n        while bits == 0:\n            entry += 1\n            if entry == num_entries:\n                return\n            bits = mask[entry]\n            if bits != 0:\n                bit = 0\n                break\n\n        while bits & 1 == 0:\n            bits >>= 1\n            bit += 1\n\n        cpu = entry * bits_per_entry + bit\n\n        bits >>= 1\n        bit += 1\n\n        yield int(cpu)\n\n\ndef each_online_cpu():\n    for cpu in cpu_list(\"__cpu_online_mask\"):\n        yield cpu\n\n\ndef each_present_cpu():\n    for cpu in cpu_list(\"__cpu_present_mask\"):\n        yield cpu\n\n\ndef each_possible_cpu():\n    for cpu in cpu_list(\"__cpu_possible_mask\"):\n        yield cpu\n\n\ndef each_active_cpu():\n    for cpu in cpu_list(\"__cpu_active_mask\"):\n        yield cpu\n\n\nclass LxCpus(gdb.Command):\n    \"\"\"List CPU status arrays\n\nDisplays the known state of each CPU based on the kernel masks\nand can help identify the state of hotplugged CPUs\"\"\"\n\n    def __init__(self):\n        super(LxCpus, self).__init__(\"lx-cpus\", gdb.COMMAND_DATA)\n\n    def invoke(self, arg, from_tty):\n        gdb.write(\"Possible CPUs : {}\\n\".format(list(each_possible_cpu())))\n        gdb.write(\"Present CPUs  : {}\\n\".format(list(each_present_cpu())))\n        gdb.write(\"Online CPUs   : {}\\n\".format(list(each_online_cpu())))\n        gdb.write(\"Active CPUs   : {}\\n\".format(list(each_active_cpu())))\n\n\nLxCpus()\n\n\nclass PerCpu(gdb.Function):\n    \"\"\"Return per-cpu variable.\n\n$lx_per_cpu(\"VAR\"[, CPU]): Return the per-cpu variable called VAR for the\ngiven CPU number. If CPU is omitted, the CPU of the current context is used.\nNote that VAR has to be quoted as string.\"\"\"\n\n    def __init__(self):\n        super(PerCpu, self).__init__(\"lx_per_cpu\")\n\n    def invoke(self, var_name, cpu=-1):\n        var_ptr = gdb.parse_and_eval(\"&\" + var_name.string())\n        return per_cpu(var_ptr, cpu)\n\n\nPerCpu()\n\ndef get_current_task(cpu):\n    task_ptr_type = task_type.get_type().pointer()\n\n    if utils.is_target_arch(\"x86\"):\n        if gdb.lookup_global_symbol(\"cpu_tasks\"):\n            # This is a UML kernel, which stores the current task\n            # differently than other x86 sub architectures\n            var_ptr = gdb.parse_and_eval(\"(struct task_struct *)cpu_tasks[0].task\")\n            return var_ptr.dereference()\n        else:\n            var_ptr = gdb.parse_and_eval(\"&pcpu_hot.current_task\")\n            return per_cpu(var_ptr, cpu).dereference()\n    elif utils.is_target_arch(\"aarch64\"):\n        current_task_addr = gdb.parse_and_eval(\"$SP_EL0\")\n        if (current_task_addr >> 63) != 0:\n            current_task = current_task_addr.cast(task_ptr_type)\n            return current_task.dereference()\n        else:\n            raise gdb.GdbError(\"Sorry, obtaining the current task is not allowed \"\n                               \"while running in userspace(EL0)\")\n    else:\n        raise gdb.GdbError(\"Sorry, obtaining the current task is not yet \"\n                           \"supported with this arch\")\n\nclass LxCurrentFunc(gdb.Function):\n    \"\"\"Return current task.\n\n$lx_current([CPU]): Return the per-cpu task variable for the given CPU\nnumber. If CPU is omitted, the CPU of the current context is used.\"\"\"\n\n    def __init__(self):\n        super(LxCurrentFunc, self).__init__(\"lx_current\")\n\n    def invoke(self, cpu=-1):\n        return get_current_task(cpu)\n\n\nLxCurrentFunc()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}