{
  "module_name": "Kbuild.include",
  "hash_id": "1c1781e3b4715263db145b420c701a1b563a5a61f394b753f64a756d6d568298",
  "original_prompt": "Ingested from linux-6.6.14/scripts/Kbuild.include",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n####\n# kbuild: Generic definitions\n\n# Convenient variables\ncomma   := ,\nquote   := \"\nsquote  := '\nempty   :=\nspace   := $(empty) $(empty)\nspace_escape := _-_SPACE_-_\npound := \\#\ndefine newline\n\n\nendef\n\n###\n# Comparison macros.\n# Usage: $(call test-lt, $(CONFIG_LLD_VERSION), 150000)\n#\n# Use $(intcmp ...) if supported. (Make >= 4.4)\n# Otherwise, fall back to the 'test' shell command.\nifeq ($(intcmp 1,0,,,y),y)\ntest-ge = $(intcmp $(strip $1)0, $(strip $2)0,,y,y)\ntest-gt = $(intcmp $(strip $1)0, $(strip $2)0,,,y)\nelse\ntest-ge = $(shell test $(strip $1)0 -ge $(strip $2)0 && echo y)\ntest-gt = $(shell test $(strip $1)0 -gt $(strip $2)0 && echo y)\nendif\ntest-le = $(call test-ge, $2, $1)\ntest-lt = $(call test-gt, $2, $1)\n\n###\n# Name of target with a '.' as filename prefix. foo/bar.o => foo/.bar.o\ndot-target = $(dir $@).$(notdir $@)\n\n###\n# Name of target with a '.tmp_' as filename prefix. foo/bar.o => foo/.tmp_bar.o\ntmp-target = $(dir $@).tmp_$(notdir $@)\n\n###\n# The temporary file to save gcc -MMD generated dependencies must not\n# contain a comma\ndepfile = $(subst $(comma),_,$(dot-target).d)\n\n###\n# filename of target with directory and extension stripped\nbasetarget = $(basename $(notdir $@))\n\n###\n# real prerequisites without phony targets\nreal-prereqs = $(filter-out $(PHONY), $^)\n\n###\n# Escape single quote for use in echo statements\nescsq = $(subst $(squote),'\\$(squote)',$1)\n\n###\n# Quote a string to pass it to C files. foo => '\"foo\"'\nstringify = $(squote)$(quote)$1$(quote)$(squote)\n\n###\n# The path to Kbuild or Makefile. Kbuild has precedence over Makefile.\nkbuild-dir = $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))\nkbuild-file = $(or $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Makefile)\n\n###\n# Read a file, replacing newlines with spaces\n#\n# Make 4.2 or later can read a file by using its builtin function.\nifneq ($(filter-out 3.% 4.0 4.1, $(MAKE_VERSION)),)\nread-file = $(subst $(newline),$(space),$(file < $1))\nelse\nread-file = $(shell cat $1 2>/dev/null)\nendif\n\n###\n# Easy method for doing a status message\n       kecho := :\n quiet_kecho := echo\nsilent_kecho := :\nkecho := $($(quiet)kecho)\n\n###\n# filechk is used to check if the content of a generated file is updated.\n# Sample usage:\n#\n# filechk_sample = echo $(KERNELRELEASE)\n# version.h: FORCE\n#\t$(call filechk,sample)\n#\n# The rule defined shall write to stdout the content of the new file.\n# The existing file will be compared with the new one.\n# - If no file exist it is created\n# - If the content differ the new file is used\n# - If they are equal no change, and no timestamp update\ndefine filechk\n\t$(check-FORCE)\n\t$(Q)set -e;\t\t\t\t\t\t\\\n\tmkdir -p $(dir $@);\t\t\t\t\t\\\n\ttrap \"rm -f $(tmp-target)\" EXIT;\t\t\t\\\n\t{ $(filechk_$(1)); } > $(tmp-target);\t\t\t\\\n\tif [ ! -r $@ ] || ! cmp -s $@ $(tmp-target); then\t\\\n\t\t$(kecho) '  UPD     $@';\t\t\t\\\n\t\tmv -f $(tmp-target) $@;\t\t\t\t\\\n\tfi\nendef\n\n###\n# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj=\n# Usage:\n# $(Q)$(MAKE) $(build)=dir\nbuild := -f $(srctree)/scripts/Makefile.build obj\n\n###\n# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.dtbinst obj=\n# Usage:\n# $(Q)$(MAKE) $(dtbinst)=dir\ndtbinst := -f $(srctree)/scripts/Makefile.dtbinst obj\n\n###\n# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.clean obj=\n# Usage:\n# $(Q)$(MAKE) $(clean)=dir\nclean := -f $(srctree)/scripts/Makefile.clean obj\n\n# pring log\n#\n# If quiet is \"silent_\", print nothing and sink stdout\n# If quiet is \"quiet_\", print short log\n# If quiet is empty, print short log and whole command\nsilent_log_print = exec >/dev/null;\n quiet_log_print = $(if $(quiet_cmd_$1), echo '  $(call escsq,$(quiet_cmd_$1)$(why))';)\n       log_print = echo '$(pound) $(call escsq,$(or $(quiet_cmd_$1),cmd_$1 $@)$(why))'; \\\n                   echo '  $(call escsq,$(cmd_$1))';\n\n# Delete the target on interruption\n#\n# GNU Make automatically deletes the target if it has already been changed by\n# the interrupted recipe. So, you can safely stop the build by Ctrl-C (Make\n# will delete incomplete targets), and resume it later.\n#\n# However, this does not work when the stderr is piped to another program, like\n#  $ make >&2 | tee log\n# Make dies with SIGPIPE before cleaning the targets.\n#\n# To address it, we clean the target in signal traps.\n#\n# Make deletes the target when it catches SIGHUP, SIGINT, SIGQUIT, SIGTERM.\n# So, we cover them, and also SIGPIPE just in case.\n#\n# Of course, this is unneeded for phony targets.\ndelete-on-interrupt = \\\n\t$(if $(filter-out $(PHONY), $@), \\\n\t\t$(foreach sig, HUP INT QUIT TERM PIPE, \\\n\t\t\ttrap 'rm -f $@; trap - $(sig); kill -s $(sig) $$$$' $(sig);))\n\n# print and execute commands\ncmd = @$(if $(cmd_$(1)),set -e; $($(quiet)log_print) $(delete-on-interrupt) $(cmd_$(1)),:)\n\n###\n# if_changed      - execute command if any prerequisite is newer than\n#                   target, or command line has changed\n# if_changed_dep  - as if_changed, but uses fixdep to reveal dependencies\n#                   including used config symbols\n# if_changed_rule - as if_changed but execute rule instead\n# See Documentation/kbuild/makefiles.rst for more info\n\nifneq ($(KBUILD_NOCMDDEP),1)\n# Check if both commands are the same including their order. Result is empty\n# string if equal. User may override this check using make KBUILD_NOCMDDEP=1\n# If the target does not exist, the *.cmd file should not be included so\n# $(savedcmd_$@) gets empty. Then, target will be built even if $(newer-prereqs)\n# happens to become empty.\ncmd-check = $(filter-out $(subst $(space),$(space_escape),$(strip $(savedcmd_$@))), \\\n                         $(subst $(space),$(space_escape),$(strip $(cmd_$1))))\nelse\n# We still need to detect missing targets.\ncmd-check = $(if $(strip $(savedcmd_$@)),,1)\nendif\n\n# Replace >$< with >$$< to preserve $ when reloading the .cmd file\n# (needed for make)\n# Replace >#< with >$(pound)< to avoid starting a comment in the .cmd file\n# (needed for make)\n# Replace >'< with >'\\''< to be able to enclose the whole string in '...'\n# (needed for the shell)\nmake-cmd = $(call escsq,$(subst $(pound),$$(pound),$(subst $$,$$$$,$(cmd_$(1)))))\n\n# Find any prerequisites that are newer than target or that do not exist.\n# PHONY targets skipped in both cases.\n# If there is no prerequisite other than phony targets, $(newer-prereqs) becomes\n# empty even if the target does not exist. cmd-check saves this corner case.\nnewer-prereqs = $(filter-out $(PHONY),$?)\n\n# It is a typical mistake to forget the FORCE prerequisite. Check it here so\n# no more breakage will slip in.\ncheck-FORCE = $(if $(filter FORCE, $^),,$(warning FORCE prerequisite is missing))\n\nif-changed-cond = $(newer-prereqs)$(cmd-check)$(check-FORCE)\n\n# Execute command if command has changed or prerequisite(s) are updated.\nif_changed = $(if $(if-changed-cond),$(cmd_and_savecmd),@:)\n\ncmd_and_savecmd =                                                            \\\n\t$(cmd);                                                              \\\n\tprintf '%s\\n' 'savedcmd_$@ := $(make-cmd)' > $(dot-target).cmd\n\n# Execute the command and also postprocess generated .d dependencies file.\nif_changed_dep = $(if $(if-changed-cond),$(cmd_and_fixdep),@:)\n\ncmd_and_fixdep =                                                             \\\n\t$(cmd);                                                              \\\n\tscripts/basic/fixdep $(depfile) $@ '$(make-cmd)' > $(dot-target).cmd;\\\n\trm -f $(depfile)\n\n# Usage: $(call if_changed_rule,foo)\n# Will check if $(cmd_foo) or any of the prerequisites changed,\n# and if so will execute $(rule_foo).\nif_changed_rule = $(if $(if-changed-cond),$(rule_$(1)),@:)\n\n###\n# why - tell why a target got built\n#       enabled by make V=2\n#       Output (listed in the order they are checked):\n#          (1) - due to target is PHONY\n#          (2) - due to target missing\n#          (3) - due to: file1.h file2.h\n#          (4) - due to command line change\n#          (5) - due to missing .cmd file\n#          (6) - due to target not in $(targets)\n# (1) PHONY targets are always build\n# (2) No target, so we better build it\n# (3) Prerequisite is newer than target\n# (4) The command line stored in the file named dir/.target.cmd\n#     differed from actual command line. This happens when compiler\n#     options changes\n# (5) No dir/.target.cmd file (used to store command line)\n# (6) No dir/.target.cmd file and target not listed in $(targets)\n#     This is a good hint that there is a bug in the kbuild file\nifneq ($(findstring 2, $(KBUILD_VERBOSE)),)\n_why =                                                                        \\\n    $(if $(filter $@, $(PHONY)),- due to target is PHONY,                    \\\n        $(if $(wildcard $@),                                                 \\\n            $(if $(newer-prereqs),- due to: $(newer-prereqs),                \\\n                $(if $(cmd-check),                                           \\\n                    $(if $(savedcmd_$@),- due to command line change,        \\\n                        $(if $(filter $@, $(targets)),                       \\\n                            - due to missing .cmd file,                      \\\n                            - due to $(notdir $@) not in $$(targets)         \\\n                         )                                                   \\\n                     )                                                       \\\n                 )                                                           \\\n             ),                                                              \\\n             - due to target missing                                         \\\n         )                                                                   \\\n     )\n\nwhy = $(space)$(strip $(_why))\nendif\n\n###############################################################################\n\n# delete partially updated (i.e. corrupted) files on error\n.DELETE_ON_ERROR:\n\n# do not delete intermediate files automatically\n#\n# .NOTINTERMEDIATE is more correct, but only available on newer Make versions.\n# Make 4.4 introduced .NOTINTERMEDIATE, and it appears in .FEATURES, but the\n# global .NOTINTERMEDIATE does not work. We can use it on Make > 4.4.\n# Use .SECONDARY for older Make versions, but \"newer-prereq\" cannot detect\n# deleted files.\nifneq ($(and $(filter notintermediate, $(.FEATURES)),$(filter-out 4.4,$(MAKE_VERSION))),)\n.NOTINTERMEDIATE:\nelse\n.SECONDARY:\nendif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}