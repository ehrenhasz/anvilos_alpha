{
  "module_name": "cleanfile",
  "hash_id": "5009a7f98935025658b56f6a04bbcb3197a102b133b72493d1e027fa68fd2627",
  "original_prompt": "Ingested from linux-6.6.14/scripts/cleanfile",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n#\n# Clean a text file -- or directory of text files -- of stealth whitespace.\n# WARNING: this can be a highly destructive operation.  Use with caution.\n#\n\nuse warnings;\nuse bytes;\nuse File::Basename;\n\n# Default options\n$max_width = 79;\n\n# Clean up space-tab sequences, either by removing spaces or\n# replacing them with tabs.\nsub clean_space_tabs($)\n{\n    no bytes;\t\t\t# Tab alignment depends on characters\n\n    my($li) = @_;\n    my($lo) = '';\n    my $pos = 0;\n    my $nsp = 0;\n    my($i, $c);\n\n    for ($i = 0; $i < length($li); $i++) {\n\t$c = substr($li, $i, 1);\n\tif ($c eq \"\\t\") {\n\t    my $npos = ($pos+$nsp+8) & ~7;\n\t    my $ntab = ($npos >> 3) - ($pos >> 3);\n\t    $lo .= \"\\t\" x $ntab;\n\t    $pos = $npos;\n\t    $nsp = 0;\n\t} elsif ($c eq \"\\n\" || $c eq \"\\r\") {\n\t    $lo .= \" \" x $nsp;\n\t    $pos += $nsp;\n\t    $nsp = 0;\n\t    $lo .= $c;\n\t    $pos = 0;\n\t} elsif ($c eq \" \") {\n\t    $nsp++;\n\t} else {\n\t    $lo .= \" \" x $nsp;\n\t    $pos += $nsp;\n\t    $nsp = 0;\n\t    $lo .= $c;\n\t    $pos++;\n\t}\n    }\n    $lo .= \" \" x $nsp;\n    return $lo;\n}\n\n# Compute the visual width of a string\nsub strwidth($) {\n    no bytes;\t\t\t# Tab alignment depends on characters\n\n    my($li) = @_;\n    my($c, $i);\n    my $pos = 0;\n    my $mlen = 0;\n\n    for ($i = 0; $i < length($li); $i++) {\n\t$c = substr($li,$i,1);\n\tif ($c eq \"\\t\") {\n\t    $pos = ($pos+8) & ~7;\n\t} elsif ($c eq \"\\n\") {\n\t    $mlen = $pos if ($pos > $mlen);\n\t    $pos = 0;\n\t} else {\n\t    $pos++;\n\t}\n    }\n\n    $mlen = $pos if ($pos > $mlen);\n    return $mlen;\n}\n\n$name = basename($0);\n\n@files = ();\n\nwhile (defined($a = shift(@ARGV))) {\n    if ($a =~ /^-/) {\n\tif ($a eq '-width' || $a eq '-w') {\n\t    $max_width = shift(@ARGV)+0;\n\t} else {\n\t    print STDERR \"Usage: $name [-width #] files...\\n\";\n\t    exit 1;\n\t}\n    } else {\n\tpush(@files, $a);\n    }\n}\n\nforeach $f ( @files ) {\n    print STDERR \"$name: $f\\n\";\n\n    if (! -f $f) {\n\tprint STDERR \"$f: not a file\\n\";\n\tnext;\n    }\n\n    if (!open(FILE, '+<', $f)) {\n\tprint STDERR \"$name: Cannot open file: $f: $!\\n\";\n\tnext;\n    }\n\n    binmode FILE;\n\n    # First, verify that it is not a binary file; consider any file\n    # with a zero byte to be a binary file.  Is there any better, or\n    # additional, heuristic that should be applied?\n    $is_binary = 0;\n\n    while (read(FILE, $data, 65536) > 0) {\n\tif ($data =~ /\\0/) {\n\t    $is_binary = 1;\n\t    last;\n\t}\n    }\n\n    if ($is_binary) {\n\tprint STDERR \"$name: $f: binary file\\n\";\n\tnext;\n    }\n\n    seek(FILE, 0, 0);\n\n    $in_bytes = 0;\n    $out_bytes = 0;\n    $blank_bytes = 0;\n\n    @blanks = ();\n    @lines  = ();\n    $lineno = 0;\n\n    while ( defined($line = <FILE>) ) {\n\t$lineno++;\n\t$in_bytes += length($line);\n\t$line =~ s/[ \\t\\r]*$//;\t\t# Remove trailing spaces\n\t$line = clean_space_tabs($line);\n\n\tif ( $line eq \"\\n\" ) {\n\t    push(@blanks, $line);\n\t    $blank_bytes += length($line);\n\t} else {\n\t    push(@lines, @blanks);\n\t    $out_bytes += $blank_bytes;\n\t    push(@lines, $line);\n\t    $out_bytes += length($line);\n\t    @blanks = ();\n\t    $blank_bytes = 0;\n\t}\n\n\t$l_width = strwidth($line);\n\tif ($max_width && $l_width > $max_width) {\n\t    print STDERR\n\t\t\"$f:$lineno: line exceeds $max_width characters ($l_width)\\n\";\n\t}\n    }\n\n    # Any blanks at the end of the file are discarded\n\n    if ($in_bytes != $out_bytes) {\n\t# Only write to the file if changed\n\tseek(FILE, 0, 0);\n\tprint FILE @lines;\n\n\tif ( !defined($where = tell(FILE)) ||\n\t     !truncate(FILE, $where) ) {\n\t    die \"$name: Failed to truncate modified file: $f: $!\\n\";\n\t}\n    }\n\n    close(FILE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}