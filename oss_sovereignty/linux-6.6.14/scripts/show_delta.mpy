{
  "module_name": "show_delta",
  "hash_id": "539b91306880328b97f20a19acab9fb6efb4329374019d2fbf8dbd72a928942c",
  "original_prompt": "Ingested from linux-6.6.14/scripts/show_delta",
  "human_readable_source": "#!/usr/bin/env python\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# show_deltas: Read list of printk messages instrumented with\n# time data, and format with time deltas.\n#\n# Also, you can show the times relative to a fixed point.\n#\n# Copyright 2003 Sony Corporation\n#\n\nimport sys\nimport string\n\ndef usage():\n\tprint (\"\"\"usage: show_delta [<options>] <filename>\n\nThis program parses the output from a set of printk message lines which\nhave time data prefixed because the CONFIG_PRINTK_TIME option is set, or\nthe kernel command line option \"time\" is specified. When run with no\noptions, the time information is converted to show the time delta between\neach printk line and the next.  When run with the '-b' option, all times\nare relative to a single (base) point in time.\n\nOptions:\n  -h            Show this usage help.\n  -b <base>\tSpecify a base for time references.\n\t\t<base> can be a number or a string.\n\t\tIf it is a string, the first message line\n\t\twhich matches (at the beginning of the\n\t\tline) is used as the time reference.\n\nex: $ dmesg >timefile\n    $ show_delta -b NET4 timefile\n\nwill show times relative to the line in the kernel output\nstarting with \"NET4\".\n\"\"\")\n\tsys.exit(1)\n\n# returns a tuple containing the seconds and text for each message line\n# seconds is returned as a float\n# raise an exception if no timing data was found\ndef get_time(line):\n\tif line[0]!=\"[\":\n\t\traise ValueError\n\n\t# split on closing bracket\n\t(time_str, rest) = string.split(line[1:],']',1)\n\ttime = string.atof(time_str)\n\n\t#print \"time=\", time\n\treturn (time, rest)\n\n\n# average line looks like:\n# [    0.084282] VFS: Mounted root (romfs filesystem) readonly\n# time data is expressed in seconds.useconds,\n# convert_line adds a delta for each line\nlast_time = 0.0\ndef convert_line(line, base_time):\n\tglobal last_time\n\n\ttry:\n\t\t(time, rest) = get_time(line)\n\texcept:\n\t\t# if any problem parsing time, don't convert anything\n\t\treturn line\n\n\tif base_time:\n\t\t# show time from base\n\t\tdelta = time - base_time\n\telse:\n\t\t# just show time from last line\n\t\tdelta = time - last_time\n\t\tlast_time = time\n\n\treturn (\"[%5.6f < %5.6f >]\" % (time, delta)) + rest\n\ndef main():\n\tbase_str = \"\"\n\tfilein = \"\"\n\tfor arg in sys.argv[1:]:\n\t\tif arg==\"-b\":\n\t\t\tbase_str = sys.argv[sys.argv.index(\"-b\")+1]\n\t\telif arg==\"-h\":\n\t\t\tusage()\n\t\telse:\n\t\t\tfilein = arg\n\n\tif not filein:\n\t\tusage()\n\n\ttry:\n\t\tlines = open(filein,\"r\").readlines()\n\texcept:\n\t\tprint (\"Problem opening file: %s\" % filein)\n\t\tsys.exit(1)\n\n\tif base_str:\n\t\tprint ('base= \"%s\"' % base_str)\n\t\t# assume a numeric base.  If that fails, try searching\n\t\t# for a matching line.\n\t\ttry:\n\t\t\tbase_time = float(base_str)\n\t\texcept:\n\t\t\t# search for line matching <base> string\n\t\t\tfound = 0\n\t\t\tfor line in lines:\n\t\t\t\ttry:\n\t\t\t\t\t(time, rest) = get_time(line)\n\t\t\t\texcept:\n\t\t\t\t\tcontinue\n\t\t\t\tif string.find(rest, base_str)==1:\n\t\t\t\t\tbase_time = time\n\t\t\t\t\tfound = 1\n\t\t\t\t\t# stop at first match\n\t\t\t\t\tbreak\n\t\t\tif not found:\n\t\t\t\tprint ('Couldn\\'t find line matching base pattern \"%s\"' % base_str)\n\t\t\t\tsys.exit(1)\n\telse:\n\t\tbase_time = 0.0\n\n\tfor line in lines:\n\t\tprint (convert_line(line, base_time),)\n\nmain()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}