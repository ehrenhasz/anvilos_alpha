{
  "module_name": "mini_lock.cocci",
  "hash_id": "06939f3e52f6bb5ec905bf1798aa5ce7f2b4605781f37790a74bdee5d7b7b3e4",
  "original_prompt": "Ingested from linux-6.6.14/scripts/coccinelle/locks/mini_lock.cocci",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0-only\n/// Find missing unlocks.  This semantic match considers the specific case\n/// where the unlock is missing from an if branch, and there is a lock\n/// before the if and an unlock after the if.  False positives are due to\n/// cases where the if branch represents a case where the function is\n/// supposed to exit with the lock held, or where there is some preceding\n/// function call that releases the lock.\n///\n// Confidence: Moderate\n// Copyright: (C) 2010-2012 Nicolas Palix.\n// Copyright: (C) 2010-2012 Julia Lawall, INRIA/LIP6.\n// Copyright: (C) 2010-2012 Gilles Muller, INRIA/LiP6.\n// URL: https://coccinelle.gitlabpages.inria.fr/website\n// Comments:\n// Options: --no-includes --include-headers\n\nvirtual context\nvirtual org\nvirtual report\n\n@prelocked@\nposition p1,p;\nexpression E1;\n@@\n\n(\nmutex_lock@p1\n|\nmutex_trylock@p1\n|\nspin_lock@p1\n|\nspin_trylock@p1\n|\nread_lock@p1\n|\nread_trylock@p1\n|\nwrite_lock@p1\n|\nwrite_trylock@p1\n|\nread_lock_irq@p1\n|\nwrite_lock_irq@p1\n|\nread_lock_irqsave@p1\n|\nwrite_lock_irqsave@p1\n|\nspin_lock_irq@p1\n|\nspin_lock_irqsave@p1\n) (E1@p,...);\n\n@looped@\nposition r;\n@@\n\nfor(...;...;...) { <+... return@r ...; ...+> }\n\n@err exists@\nexpression E1;\nposition prelocked.p;\nposition up != prelocked.p1;\nposition r!=looped.r;\nidentifier lock,unlock;\n@@\n\n*lock(E1@p,...);\n... when != E1\n    when any\nif (...) {\n  ... when != E1\n*  return@r ...;\n}\n... when != E1\n    when any\n*unlock@up(E1,...);\n\n@script:python depends on org@\np << prelocked.p1;\nlock << err.lock;\nunlock << err.unlock;\np2 << err.r;\n@@\n\ncocci.print_main(lock,p)\ncocci.print_secs(unlock,p2)\n\n@script:python depends on report@\np << prelocked.p1;\nlock << err.lock;\nunlock << err.unlock;\np2 << err.r;\n@@\n\nmsg = \"preceding lock on line %s\" % (p[0].line)\ncoccilib.report.print_report(p2[0],msg)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}