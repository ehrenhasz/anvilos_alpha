{
  "module_name": "double_lock.cocci",
  "hash_id": "703ef58ce7f44db0b1e78d89a7c02ed69b5371c0b21fd11ab2cbdd41a25658bf",
  "original_prompt": "Ingested from linux-6.6.14/scripts/coccinelle/locks/double_lock.cocci",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0-only\n/// Find double locks.  False positives may occur when some paths cannot\n/// occur at execution, due to the values of variables, and when there is\n/// an intervening function call that releases the lock.\n///\n// Confidence: Moderate\n// Copyright: (C) 2010 Nicolas Palix, DIKU.\n// Copyright: (C) 2010 Julia Lawall, DIKU.\n// Copyright: (C) 2010 Gilles Muller, INRIA/LiP6.\n// URL: https://coccinelle.gitlabpages.inria.fr/website\n// Comments:\n// Options: --no-includes --include-headers\n\nvirtual org\nvirtual report\n\n@locked@\nposition p1;\nexpression E1;\nposition p;\n@@\n\n(\nmutex_lock@p1\n|\nmutex_trylock@p1\n|\nspin_lock@p1\n|\nspin_trylock@p1\n|\nread_lock@p1\n|\nread_trylock@p1\n|\nwrite_lock@p1\n|\nwrite_trylock@p1\n) (E1@p,...);\n\n@balanced@\nposition p1 != locked.p1;\nposition locked.p;\nidentifier lock,unlock;\nexpression x <= locked.E1;\nexpression E,locked.E1;\nexpression E2;\n@@\n\nif (E) {\n <+... when != E1\n lock(E1@p,...)\n ...+>\n}\n... when != E1\n    when != \\(x = E2\\|&x\\)\n    when forall\nif (E) {\n <+... when != E1\n unlock@p1(E1,...)\n ...+>\n}\n\n@r depends on !balanced exists@\nexpression x <= locked.E1;\nexpression locked.E1;\nexpression E2;\nidentifier lock;\nposition locked.p,p1,p2;\n@@\n\nlock@p1 (E1@p,...);\n... when != E1\n    when != \\(x = E2\\|&x\\)\nlock@p2 (E1,...);\n\n@script:python depends on org@\np1 << r.p1;\np2 << r.p2;\nlock << r.lock;\n@@\n\ncocci.print_main(lock,p1)\ncocci.print_secs(\"second lock\",p2)\n\n@script:python depends on report@\np1 << r.p1;\np2 << r.p2;\nlock << r.lock;\n@@\n\nmsg = \"second lock on line %s\" % (p2[0].line)\ncoccilib.report.print_report(p1[0],msg)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}