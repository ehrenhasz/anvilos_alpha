{
  "module_name": "flags.cocci",
  "hash_id": "cf1f82da14e6373b9b44b57805a1d789ad0a53cc4547448c907d82bf8fae4e47",
  "original_prompt": "Ingested from linux-6.6.14/scripts/coccinelle/locks/flags.cocci",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0-only\n/// Find nested lock+irqsave functions that use the same flags variables\n///\n// Confidence: High\n// Copyright: (C) 2010-2012 Nicolas Palix.\n// Copyright: (C) 2010-2012 Julia Lawall, INRIA/LIP6.\n// Copyright: (C) 2010-2012 Gilles Muller, INRIA/LiP6.\n// URL: https://coccinelle.gitlabpages.inria.fr/website\n// Comments:\n// Options: --no-includes --include-headers\n\nvirtual context\nvirtual org\nvirtual report\n\n@r exists@\nexpression lock1,lock2,flags;\nposition p1,p2;\n@@\n\n(\nspin_lock_irqsave@p1(lock1,flags)\n|\nread_lock_irqsave@p1(lock1,flags)\n|\nwrite_lock_irqsave@p1(lock1,flags)\n)\n... when != flags\n(\nspin_lock_irqsave(lock1,flags)\n|\nread_lock_irqsave(lock1,flags)\n|\nwrite_lock_irqsave(lock1,flags)\n|\nspin_lock_irqsave@p2(lock2,flags)\n|\nread_lock_irqsave@p2(lock2,flags)\n|\nwrite_lock_irqsave@p2(lock2,flags)\n)\n\n@d exists@\nexpression f <= r.flags;\nexpression lock1,lock2,flags;\nposition r.p1, r.p2;\n@@\n\n(\n*spin_lock_irqsave@p1(lock1,flags)\n|\n*read_lock_irqsave@p1(lock1,flags)\n|\n*write_lock_irqsave@p1(lock1,flags)\n)\n... when != f\n(\n*spin_lock_irqsave@p2(lock2,flags)\n|\n*read_lock_irqsave@p2(lock2,flags)\n|\n*write_lock_irqsave@p2(lock2,flags)\n)\n\n// ----------------------------------------------------------------------\n\n@script:python depends on d && org@\np1 << r.p1;\np2 << r.p2;\n@@\n\ncocci.print_main(\"original lock\",p1)\ncocci.print_secs(\"nested lock+irqsave that reuses flags\",p2)\n\n@script:python depends on d && report@\np1 << r.p1;\np2 << r.p2;\n@@\n\nmsg=\"ERROR: nested lock+irqsave that reuses flags from line %s.\" % (p1[0].line)\ncoccilib.report.print_report(p2[0], msg)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}