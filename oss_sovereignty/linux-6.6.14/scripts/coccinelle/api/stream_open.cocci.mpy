{
  "module_name": "stream_open.cocci",
  "hash_id": "136659e5ea3eb25d7a42a6885c295040ff3d35c0686b98f0ed5b7dfc004459f0",
  "original_prompt": "Ingested from linux-6.6.14/scripts/coccinelle/api/stream_open.cocci",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n// Author: Kirill Smelkov (kirr@nexedi.com)\n//\n// Search for stream-like files that are using nonseekable_open and convert\n// them to stream_open. A stream-like file is a file that does not use ppos in\n// its read and write. Rationale for the conversion is to avoid deadlock in\n// between read and write.\n\nvirtual report\nvirtual patch\nvirtual explain  // explain decisions in the patch (SPFLAGS=\"-D explain\")\n\n// stream-like reader & writer - ones that do not depend on f_pos.\n@ stream_reader @\nidentifier readstream, ppos;\nidentifier f, buf, len;\ntype loff_t;\n@@\n  ssize_t readstream(struct file *f, char *buf, size_t len, loff_t *ppos)\n  {\n    ... when != ppos\n  }\n\n@ stream_writer @\nidentifier writestream, ppos;\nidentifier f, buf, len;\ntype loff_t;\n@@\n  ssize_t writestream(struct file *f, const char *buf, size_t len, loff_t *ppos)\n  {\n    ... when != ppos\n  }\n\n\n// a function that blocks\n@ blocks @\nidentifier block_f;\nidentifier wait =~ \"^wait_.*\";\n@@\n  block_f(...) {\n    ... when exists\n    wait(...)\n    ... when exists\n  }\n\n// stream_reader that can block inside.\n//\n// XXX wait_* can be called not directly from current function (e.g. func -> f -> g -> wait())\n// XXX currently reader_blocks supports only direct and 1-level indirect cases.\n@ reader_blocks_direct @\nidentifier stream_reader.readstream;\nidentifier wait =~ \"^wait_.*\";\n@@\n  readstream(...)\n  {\n    ... when exists\n    wait(...)\n    ... when exists\n  }\n\n@ reader_blocks_1 @\nidentifier stream_reader.readstream;\nidentifier blocks.block_f;\n@@\n  readstream(...)\n  {\n    ... when exists\n    block_f(...)\n    ... when exists\n  }\n\n@ reader_blocks depends on reader_blocks_direct || reader_blocks_1 @\nidentifier stream_reader.readstream;\n@@\n  readstream(...) {\n    ...\n  }\n\n\n// file_operations + whether they have _any_ .read, .write, .llseek ... at all.\n//\n// XXX add support for file_operations xxx[N] = ...\t(sound/core/pcm_native.c)\n@ fops0 @\nidentifier fops;\n@@\n  struct file_operations fops = {\n    ...\n  };\n\n@ has_read @\nidentifier fops0.fops;\nidentifier read_f;\n@@\n  struct file_operations fops = {\n    .read = read_f,\n  };\n\n@ has_read_iter @\nidentifier fops0.fops;\nidentifier read_iter_f;\n@@\n  struct file_operations fops = {\n    .read_iter = read_iter_f,\n  };\n\n@ has_write @\nidentifier fops0.fops;\nidentifier write_f;\n@@\n  struct file_operations fops = {\n    .write = write_f,\n  };\n\n@ has_write_iter @\nidentifier fops0.fops;\nidentifier write_iter_f;\n@@\n  struct file_operations fops = {\n    .write_iter = write_iter_f,\n  };\n\n@ has_llseek @\nidentifier fops0.fops;\nidentifier llseek_f;\n@@\n  struct file_operations fops = {\n    .llseek = llseek_f,\n  };\n\n@ has_no_llseek @\nidentifier fops0.fops;\n@@\n  struct file_operations fops = {\n    .llseek = no_llseek,\n  };\n\n@ has_noop_llseek @\nidentifier fops0.fops;\n@@\n  struct file_operations fops = {\n    .llseek = noop_llseek,\n  };\n\n@ has_mmap @\nidentifier fops0.fops;\nidentifier mmap_f;\n@@\n  struct file_operations fops = {\n    .mmap = mmap_f,\n  };\n\n@ has_copy_file_range @\nidentifier fops0.fops;\nidentifier copy_file_range_f;\n@@\n  struct file_operations fops = {\n    .copy_file_range = copy_file_range_f,\n  };\n\n@ has_remap_file_range @\nidentifier fops0.fops;\nidentifier remap_file_range_f;\n@@\n  struct file_operations fops = {\n    .remap_file_range = remap_file_range_f,\n  };\n\n@ has_splice_read @\nidentifier fops0.fops;\nidentifier splice_read_f;\n@@\n  struct file_operations fops = {\n    .splice_read = splice_read_f,\n  };\n\n@ has_splice_write @\nidentifier fops0.fops;\nidentifier splice_write_f;\n@@\n  struct file_operations fops = {\n    .splice_write = splice_write_f,\n  };\n\n\n// file_operations that is candidate for stream_open conversion - it does not\n// use mmap and other methods that assume @offset access to file.\n//\n// XXX for simplicity require no .{read/write}_iter and no .splice_{read/write} for now.\n// XXX maybe_steam.fops cannot be used in other rules - it gives \"bad rule maybe_stream or bad variable fops\".\n@ maybe_stream depends on (!has_llseek || has_no_llseek || has_noop_llseek) && !has_mmap && !has_copy_file_range && !has_remap_file_range && !has_read_iter && !has_write_iter && !has_splice_read && !has_splice_write @\nidentifier fops0.fops;\n@@\n  struct file_operations fops = {\n  };\n\n\n// ---- conversions ----\n\n// XXX .open = nonseekable_open -> .open = stream_open\n// XXX .open = func -> openfunc -> nonseekable_open\n\n// read & write\n//\n// if both are used in the same file_operations together with an opener -\n// under that conditions we can use stream_open instead of nonseekable_open.\n@ fops_rw depends on maybe_stream @\nidentifier fops0.fops, openfunc;\nidentifier stream_reader.readstream;\nidentifier stream_writer.writestream;\n@@\n  struct file_operations fops = {\n      .open  = openfunc,\n      .read  = readstream,\n      .write = writestream,\n  };\n\n@ report_rw depends on report @\nidentifier fops_rw.openfunc;\nposition p1;\n@@\n  openfunc(...) {\n    <...\n     nonseekable_open@p1\n    ...>\n  }\n\n@ script:python depends on report && reader_blocks @\nfops << fops0.fops;\np << report_rw.p1;\n@@\ncoccilib.report.print_report(p[0],\n  \"ERROR: %s: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.\" % (fops,))\n\n@ script:python depends on report && !reader_blocks @\nfops << fops0.fops;\np << report_rw.p1;\n@@\ncoccilib.report.print_report(p[0],\n  \"WARNING: %s: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.\" % (fops,))\n\n\n@ explain_rw_deadlocked depends on explain && reader_blocks @\nidentifier fops_rw.openfunc;\n@@\n  openfunc(...) {\n    <...\n-    nonseekable_open\n+    nonseekable_open /* read & write (was deadlock) */\n    ...>\n  }\n\n\n@ explain_rw_nodeadlock depends on explain && !reader_blocks @\nidentifier fops_rw.openfunc;\n@@\n  openfunc(...) {\n    <...\n-    nonseekable_open\n+    nonseekable_open /* read & write (no direct deadlock) */\n    ...>\n  }\n\n@ patch_rw depends on patch @\nidentifier fops_rw.openfunc;\n@@\n  openfunc(...) {\n    <...\n-   nonseekable_open\n+   stream_open\n    ...>\n  }\n\n\n// read, but not write\n@ fops_r depends on maybe_stream && !has_write @\nidentifier fops0.fops, openfunc;\nidentifier stream_reader.readstream;\n@@\n  struct file_operations fops = {\n      .open  = openfunc,\n      .read  = readstream,\n  };\n\n@ report_r depends on report @\nidentifier fops_r.openfunc;\nposition p1;\n@@\n  openfunc(...) {\n    <...\n    nonseekable_open@p1\n    ...>\n  }\n\n@ script:python depends on report @\nfops << fops0.fops;\np << report_r.p1;\n@@\ncoccilib.report.print_report(p[0],\n  \"WARNING: %s: .read() has stream semantic; safe to change nonseekable_open -> stream_open.\" % (fops,))\n\n@ explain_r depends on explain @\nidentifier fops_r.openfunc;\n@@\n  openfunc(...) {\n    <...\n-   nonseekable_open\n+   nonseekable_open /* read only */\n    ...>\n  }\n\n@ patch_r depends on patch @\nidentifier fops_r.openfunc;\n@@\n  openfunc(...) {\n    <...\n-   nonseekable_open\n+   stream_open\n    ...>\n  }\n\n\n// write, but not read\n@ fops_w depends on maybe_stream && !has_read @\nidentifier fops0.fops, openfunc;\nidentifier stream_writer.writestream;\n@@\n  struct file_operations fops = {\n      .open  = openfunc,\n      .write = writestream,\n  };\n\n@ report_w depends on report @\nidentifier fops_w.openfunc;\nposition p1;\n@@\n  openfunc(...) {\n    <...\n    nonseekable_open@p1\n    ...>\n  }\n\n@ script:python depends on report @\nfops << fops0.fops;\np << report_w.p1;\n@@\ncoccilib.report.print_report(p[0],\n  \"WARNING: %s: .write() has stream semantic; safe to change nonseekable_open -> stream_open.\" % (fops,))\n\n@ explain_w depends on explain @\nidentifier fops_w.openfunc;\n@@\n  openfunc(...) {\n    <...\n-   nonseekable_open\n+   nonseekable_open /* write only */\n    ...>\n  }\n\n@ patch_w depends on patch @\nidentifier fops_w.openfunc;\n@@\n  openfunc(...) {\n    <...\n-   nonseekable_open\n+   stream_open\n    ...>\n  }\n\n\n// no read, no write - don't change anything\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}