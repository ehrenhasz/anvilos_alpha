{
  "module_name": "memdup_user.cocci",
  "hash_id": "6fec80cf1a7b50e9985276c3de7786f32eceec906d0270cefb48b571faad8d5f",
  "original_prompt": "Ingested from linux-6.6.14/scripts/coccinelle/api/memdup_user.cocci",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0-only\n/// Use memdup_user rather than duplicating its implementation\n/// This is a little bit restricted to reduce false positives\n///\n// Confidence: High\n// Copyright: (C) 2010-2012 Nicolas Palix.\n// Copyright: (C) 2010-2012 Julia Lawall, INRIA/LIP6.\n// Copyright: (C) 2010-2012 Gilles Muller, INRIA/LiP6.\n// URL: https://coccinelle.gitlabpages.inria.fr/website\n// Comments:\n// Options: --no-includes --include-headers\n\nvirtual patch\nvirtual context\nvirtual org\nvirtual report\n\n@initialize:python@\n@@\nfilter = frozenset(['memdup_user', 'vmemdup_user'])\n\ndef relevant(p):\n    return not (filter & {el.current_element for el in p})\n\n@depends on patch@\nexpression from,to,size;\nidentifier l1,l2;\nposition p : script:python() { relevant(p) };\n@@\n\n-  to = \\(kmalloc@p\\|kzalloc@p\\)\n-\t\t(size,\\(GFP_KERNEL\\|GFP_USER\\|\n-\t\t      \\(GFP_KERNEL\\|GFP_USER\\)|__GFP_NOWARN\\));\n+  to = memdup_user(from,size);\n   if (\n-      to==NULL\n+      IS_ERR(to)\n                 || ...) {\n   <+... when != goto l1;\n-  -ENOMEM\n+  PTR_ERR(to)\n   ...+>\n   }\n-  if (copy_from_user(to, from, size) != 0) {\n-    <+... when != goto l2;\n-    -EFAULT\n-    ...+>\n-  }\n\n@depends on patch@\nexpression from,to,size;\nidentifier l1,l2;\nposition p : script:python() { relevant(p) };\n@@\n\n-  to = \\(kvmalloc@p\\|kvzalloc@p\\)(size,\\(GFP_KERNEL\\|GFP_USER\\));\n+  to = vmemdup_user(from,size);\n   if (\n-      to==NULL\n+      IS_ERR(to)\n                 || ...) {\n   <+... when != goto l1;\n-  -ENOMEM\n+  PTR_ERR(to)\n   ...+>\n   }\n-  if (copy_from_user(to, from, size) != 0) {\n-    <+... when != goto l2;\n-    -EFAULT\n-    ...+>\n-  }\n\n@r depends on !patch@\nexpression from,to,size;\nposition p : script:python() { relevant(p) };\nstatement S1,S2;\n@@\n\n*  to = \\(kmalloc@p\\|kzalloc@p\\)\n\t\t(size,\\(GFP_KERNEL\\|GFP_USER\\|\n\t\t      \\(GFP_KERNEL\\|GFP_USER\\)|__GFP_NOWARN\\));\n   if (to==NULL || ...) S1\n   if (copy_from_user(to, from, size) != 0)\n   S2\n\n@rv depends on !patch@\nexpression from,to,size;\nposition p : script:python() { relevant(p) };\nstatement S1,S2;\n@@\n\n*  to = \\(kvmalloc@p\\|kvzalloc@p\\)(size,\\(GFP_KERNEL\\|GFP_USER\\));\n   if (to==NULL || ...) S1\n   if (copy_from_user(to, from, size) != 0)\n   S2\n\n@script:python depends on org@\np << r.p;\n@@\n\ncoccilib.org.print_todo(p[0], \"WARNING opportunity for memdup_user\")\n\n@script:python depends on report@\np << r.p;\n@@\n\ncoccilib.report.print_report(p[0], \"WARNING opportunity for memdup_user\")\n\n@script:python depends on org@\np << rv.p;\n@@\n\ncoccilib.org.print_todo(p[0], \"WARNING opportunity for vmemdup_user\")\n\n@script:python depends on report@\np << rv.p;\n@@\n\ncoccilib.report.print_report(p[0], \"WARNING opportunity for vmemdup_user\")\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}