{
  "module_name": "kfree_mismatch.cocci",
  "hash_id": "0e96e513bec0a7b39266e045d8415517b82ee610c420e20c1095bcdf1cf0cf50",
  "original_prompt": "Ingested from linux-6.6.14/scripts/coccinelle/api/kfree_mismatch.cocci",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0-only\n///\n/// Check that kvmalloc'ed memory is freed by kfree functions,\n/// vmalloc'ed by vfree functions and kvmalloc'ed by kvfree\n/// functions.\n///\n// Confidence: High\n// Copyright: (C) 2020 Denis Efremov ISPRAS\n// Options: --no-includes --include-headers\n//\n\nvirtual patch\nvirtual report\nvirtual org\nvirtual context\n\n@alloc@\nexpression E, E1;\nposition kok, vok;\n@@\n\n(\n  if (...) {\n    ...\n    E = \\(kmalloc\\|kzalloc\\|krealloc\\|kcalloc\\|\n          kmalloc_node\\|kzalloc_node\\|kmalloc_array\\|\n          kmalloc_array_node\\|kcalloc_node\\)(...)@kok\n    ...\n  } else {\n    ...\n    E = \\(vmalloc\\|vzalloc\\|vmalloc_user\\|vmalloc_node\\|\n          vzalloc_node\\|vmalloc_exec\\|vmalloc_32\\|\n          vmalloc_32_user\\|__vmalloc\\|__vmalloc_node_range\\|\n          __vmalloc_node\\)(...)@vok\n    ...\n  }\n|\n  E = \\(kmalloc\\|kzalloc\\|krealloc\\|kcalloc\\|kmalloc_node\\|kzalloc_node\\|\n        kmalloc_array\\|kmalloc_array_node\\|kcalloc_node\\)(...)@kok\n  ... when != E = E1\n      when any\n  if (E == NULL) {\n    ...\n    E = \\(vmalloc\\|vzalloc\\|vmalloc_user\\|vmalloc_node\\|\n          vzalloc_node\\|vmalloc_exec\\|vmalloc_32\\|\n          vmalloc_32_user\\|__vmalloc\\|__vmalloc_node_range\\|\n          __vmalloc_node\\)(...)@vok\n    ...\n  }\n)\n\n@free@\nexpression E;\nposition fok;\n@@\n\n  E = \\(kvmalloc\\|kvzalloc\\|kvcalloc\\|kvzalloc_node\\|kvmalloc_node\\|\n        kvmalloc_array\\)(...)\n  ...\n  kvfree(E)@fok\n\n@vfree depends on !patch@\nexpression E;\nposition a != alloc.kok;\nposition f != free.fok;\n@@\n\n* E = \\(kmalloc\\|kzalloc\\|krealloc\\|kcalloc\\|kmalloc_node\\|\n*       kzalloc_node\\|kmalloc_array\\|kmalloc_array_node\\|\n*       kcalloc_node\\)(...)@a\n  ... when != if (...) { ... E = \\(vmalloc\\|vzalloc\\|vmalloc_user\\|vmalloc_node\\|vzalloc_node\\|vmalloc_exec\\|vmalloc_32\\|vmalloc_32_user\\|__vmalloc\\|__vmalloc_node_range\\|__vmalloc_node\\)(...); ... }\n      when != is_vmalloc_addr(E)\n      when any\n* \\(vfree\\|vfree_atomic\\|kvfree\\)(E)@f\n\n@depends on patch exists@\nexpression E;\nposition a != alloc.kok;\nposition f != free.fok;\n@@\n\n  E = \\(kmalloc\\|kzalloc\\|krealloc\\|kcalloc\\|kmalloc_node\\|\n        kzalloc_node\\|kmalloc_array\\|kmalloc_array_node\\|\n        kcalloc_node\\)(...)@a\n  ... when != if (...) { ... E = \\(vmalloc\\|vzalloc\\|vmalloc_user\\|vmalloc_node\\|vzalloc_node\\|vmalloc_exec\\|vmalloc_32\\|vmalloc_32_user\\|__vmalloc\\|__vmalloc_node_range\\|__vmalloc_node\\)(...); ... }\n      when != is_vmalloc_addr(E)\n      when any\n- \\(vfree\\|vfree_atomic\\|kvfree\\)(E)@f\n+ kfree(E)\n\n@kfree depends on !patch@\nexpression E;\nposition a != alloc.vok;\nposition f != free.fok;\n@@\n\n* E = \\(vmalloc\\|vzalloc\\|vmalloc_user\\|vmalloc_node\\|vzalloc_node\\|\n*       vmalloc_exec\\|vmalloc_32\\|vmalloc_32_user\\|__vmalloc\\|\n*       __vmalloc_node_range\\|__vmalloc_node\\)(...)@a\n  ... when != is_vmalloc_addr(E)\n      when any\n* \\(kfree\\|kfree_sensitive\\|kvfree\\)(E)@f\n\n@depends on patch exists@\nexpression E;\nposition a != alloc.vok;\nposition f != free.fok;\n@@\n\n  E = \\(vmalloc\\|vzalloc\\|vmalloc_user\\|vmalloc_node\\|vzalloc_node\\|\n        vmalloc_exec\\|vmalloc_32\\|vmalloc_32_user\\|__vmalloc\\|\n        __vmalloc_node_range\\|__vmalloc_node\\)(...)@a\n  ... when != is_vmalloc_addr(E)\n      when any\n- \\(kfree\\|kvfree\\)(E)@f\n+ vfree(E)\n\n@kvfree depends on !patch@\nexpression E;\nposition a, f;\n@@\n\n* E = \\(kvmalloc\\|kvzalloc\\|kvcalloc\\|kvzalloc_node\\|kvmalloc_node\\|\n*       kvmalloc_array\\)(...)@a\n  ... when != is_vmalloc_addr(E)\n      when any\n* \\(kfree\\|kfree_sensitive\\|vfree\\|vfree_atomic\\)(E)@f\n\n@depends on patch exists@\nexpression E;\n@@\n\n  E = \\(kvmalloc\\|kvzalloc\\|kvcalloc\\|kvzalloc_node\\|kvmalloc_node\\|\n        kvmalloc_array\\)(...)\n  ... when != is_vmalloc_addr(E)\n      when any\n- \\(kfree\\|vfree\\)(E)\n+ kvfree(E)\n\n@kvfree_switch depends on !patch@\nexpression alloc.E;\nposition f;\n@@\n\n  ... when != is_vmalloc_addr(E)\n      when any\n* \\(kfree\\|kfree_sensitive\\|vfree\\|vfree_atomic\\)(E)@f\n\n@depends on patch exists@\nexpression alloc.E;\nposition f;\n@@\n\n  ... when != is_vmalloc_addr(E)\n      when any\n(\n- \\(kfree\\|vfree\\)(E)@f\n+ kvfree(E)\n|\n- kfree_sensitive(E)@f\n+ kvfree_sensitive(E)\n)\n\n@script: python depends on report@\na << vfree.a;\nf << vfree.f;\n@@\n\nmsg = \"WARNING kmalloc is used to allocate this memory at line %s\" % (a[0].line)\ncoccilib.report.print_report(f[0], msg)\n\n@script: python depends on org@\na << vfree.a;\nf << vfree.f;\n@@\n\nmsg = \"WARNING kmalloc is used to allocate this memory at line %s\" % (a[0].line)\ncoccilib.org.print_todo(f[0], msg)\n\n@script: python depends on report@\na << kfree.a;\nf << kfree.f;\n@@\n\nmsg = \"WARNING vmalloc is used to allocate this memory at line %s\" % (a[0].line)\ncoccilib.report.print_report(f[0], msg)\n\n@script: python depends on org@\na << kfree.a;\nf << kfree.f;\n@@\n\nmsg = \"WARNING vmalloc is used to allocate this memory at line %s\" % (a[0].line)\ncoccilib.org.print_todo(f[0], msg)\n\n@script: python depends on report@\na << kvfree.a;\nf << kvfree.f;\n@@\n\nmsg = \"WARNING kvmalloc is used to allocate this memory at line %s\" % (a[0].line)\ncoccilib.report.print_report(f[0], msg)\n\n@script: python depends on org@\na << kvfree.a;\nf << kvfree.f;\n@@\n\nmsg = \"WARNING kvmalloc is used to allocate this memory at line %s\" % (a[0].line)\ncoccilib.org.print_todo(f[0], msg)\n\n@script: python depends on report@\nka << alloc.kok;\nva << alloc.vok;\nf << kvfree_switch.f;\n@@\n\nmsg = \"WARNING kmalloc (line %s) && vmalloc (line %s) are used to allocate this memory\" % (ka[0].line, va[0].line)\ncoccilib.report.print_report(f[0], msg)\n\n@script: python depends on org@\nka << alloc.kok;\nva << alloc.vok;\nf << kvfree_switch.f;\n@@\n\nmsg = \"WARNING kmalloc (line %s) && vmalloc (line %s) are used to allocate this memory\" % (ka[0].line, va[0].line)\ncoccilib.org.print_todo(f[0], msg)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}