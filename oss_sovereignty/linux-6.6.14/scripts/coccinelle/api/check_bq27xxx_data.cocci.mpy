{
  "module_name": "check_bq27xxx_data.cocci",
  "hash_id": "47a42630565e6361bd95eb3e3142b11770c81c77e606cf55e809d0e4bf1c8b25",
  "original_prompt": "Ingested from linux-6.6.14/scripts/coccinelle/api/check_bq27xxx_data.cocci",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0-only\n/// Detect BQ27XXX_DATA structures with identical registers, dm registers or\n/// properties.\n//# Doesn't unfold macros used in register or property fields.\n//# Requires OCaml scripting\n///\n// Confidence: High\n// Copyright: (C) 2017 Julia Lawall, Inria/LIP6,\n// URL: https://coccinelle.gitlabpages.inria.fr/website\n// Requires: 1.0.7\n// Keywords: BQ27XXX_DATA\n\nvirtual report\n\n@initialize:ocaml@\n@@\n\nlet print_report p msg =\n  let p = List.hd p in\n  Printf.printf \"%s:%d:%d-%d: %s\" p.file p.line p.col p.col_end msg\n\n@str depends on report@\ntype t;\nidentifier i,i1,i2;\nexpression e1,e2;\n@@\n\nt i[] = {\n  ...,\n  [e1] = BQ27XXX_DATA(i1,...),\n  ...,\n  [e2] = BQ27XXX_DATA(i2,...),\n  ...,\n};\n\n@script:ocaml tocheck@\ni1 << str.i1;\ni2 << str.i2;\ni1regs; i2regs;\ni1dmregs; i2dmregs;\ni1props; i2props;\n@@\n\nif not(i1 = i2)\nthen\n  begin\n    i1regs := make_ident (i1 ^ \"_regs\");\n    i2regs := make_ident (i2 ^ \"_regs\");\n    i1dmregs := make_ident (i1 ^ \"_dm_regs\");\n    i2dmregs := make_ident (i2 ^ \"_dm_regs\");\n    i1props := make_ident (i1 ^ \"_props\");\n    i2props := make_ident (i2 ^ \"_props\")\n  end\n\n(* ---------------------------------------------------------------- *)\n\n@getregs1@\ntypedef u8;\nidentifier tocheck.i1regs;\ninitializer list i1regs_vals;\nposition p1;\n@@\n\nu8 i1regs@p1[...] = { i1regs_vals, };\n\n@getregs2@\nidentifier tocheck.i2regs;\ninitializer list i2regs_vals;\nposition p2;\n@@\n\nu8 i2regs@p2[...] = { i2regs_vals, };\n\n@script:ocaml@\n(_,i1regs_vals) << getregs1.i1regs_vals;\n(_,i2regs_vals) << getregs2.i2regs_vals;\ni1regs << tocheck.i1regs;\ni2regs << tocheck.i2regs;\np1 << getregs1.p1;\np2 << getregs2.p2;\n@@\n\nif i1regs < i2regs &&\n   List.sort compare i1regs_vals = List.sort compare i2regs_vals\nthen\n  let msg =\n    Printf.sprintf\n      \"WARNING %s and %s (line %d) are identical\\n\"\n      i1regs i2regs (List.hd p2).line in\n  print_report p1 msg\n\n(* ---------------------------------------------------------------- *)\n\n@getdmregs1@\nidentifier tocheck.i1dmregs;\ninitializer list i1dmregs_vals;\nposition p1;\n@@\n\nstruct bq27xxx_dm_reg i1dmregs@p1[] = { i1dmregs_vals, };\n\n@getdmregs2@\nidentifier tocheck.i2dmregs;\ninitializer list i2dmregs_vals;\nposition p2;\n@@\n\nstruct bq27xxx_dm_reg i2dmregs@p2[] = { i2dmregs_vals, };\n\n@script:ocaml@\n(_,i1dmregs_vals) << getdmregs1.i1dmregs_vals;\n(_,i2dmregs_vals) << getdmregs2.i2dmregs_vals;\ni1dmregs << tocheck.i1dmregs;\ni2dmregs << tocheck.i2dmregs;\np1 << getdmregs1.p1;\np2 << getdmregs2.p2;\n@@\n\nif i1dmregs < i2dmregs &&\n   List.sort compare i1dmregs_vals = List.sort compare i2dmregs_vals\nthen\n  let msg =\n    Printf.sprintf\n      \"WARNING %s and %s (line %d) are identical\\n\"\n      i1dmregs i2dmregs (List.hd p2).line in\n  print_report p1 msg\n\n(* ---------------------------------------------------------------- *)\n\n@getprops1@\nidentifier tocheck.i1props;\ninitializer list[n1] i1props_vals;\nposition p1;\n@@\n\nenum power_supply_property i1props@p1[] = { i1props_vals, };\n\n@getprops2@\nidentifier tocheck.i2props;\ninitializer list[n2] i2props_vals;\nposition p2;\n@@\n\nenum power_supply_property i2props@p2[] = { i2props_vals, };\n\n@script:ocaml@\n(_,i1props_vals) << getprops1.i1props_vals;\n(_,i2props_vals) << getprops2.i2props_vals;\ni1props << tocheck.i1props;\ni2props << tocheck.i2props;\np1 << getprops1.p1;\np2 << getprops2.p2;\n@@\n\nif i1props < i2props &&\n   List.sort compare i1props_vals = List.sort compare i2props_vals\nthen\n  let msg =\n    Printf.sprintf\n      \"WARNING %s and %s (line %d) are identical\\n\"\n      i1props i2props (List.hd p2).line in\n  print_report p1 msg\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}