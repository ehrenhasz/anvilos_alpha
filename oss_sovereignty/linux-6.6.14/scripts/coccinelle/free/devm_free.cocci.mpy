{
  "module_name": "devm_free.cocci",
  "hash_id": "8d5619a3226f07cd141ceac6567b425dbdfabdd96f601d6ba47d393d1bffc826",
  "original_prompt": "Ingested from linux-6.6.14/scripts/coccinelle/free/devm_free.cocci",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0-only\n/// Find uses of standard freeing functons on values allocated using devm_\n/// functions.  Values allocated using the devm_functions are freed when\n/// the device is detached, and thus the use of the standard freeing\n/// function would cause a double free.\n/// See Documentation/driver-api/driver-model/devres.rst for more information.\n///\n/// A difficulty of detecting this problem is that the standard freeing\n/// function might be called from a different function than the one\n/// containing the allocation function.  It is thus necessary to make the\n/// connection between the allocation function and the freeing function.\n/// Here this is done using the specific argument text, which is prone to\n/// false positives.  There is no rule for the request_region and\n/// request_mem_region variants because this heuristic seems to be a bit\n/// less reliable in these cases.\n///\n// Confidence: Moderate\n// Copyright: (C) 2011 Julia Lawall, INRIA/LIP6.\n// Copyright: (C) 2011 Gilles Muller, INRIA/LiP6.\n// URL: https://coccinelle.gitlabpages.inria.fr/website\n// Comments:\n// Options: --no-includes --include-headers\n\nvirtual org\nvirtual report\nvirtual context\n\n@r depends on context || org || report@\nexpression x;\n@@\n\n(\n x = devm_kmalloc(...)\n|\n x = devm_kvasprintf(...)\n|\n x = devm_kasprintf(...)\n|\n x = devm_kzalloc(...)\n|\n x = devm_kmalloc_array(...)\n|\n x = devm_kcalloc(...)\n|\n x = devm_kstrdup(...)\n|\n x = devm_kmemdup(...)\n|\n x = devm_get_free_pages(...)\n|\n x = devm_request_irq(...)\n|\n x = devm_ioremap(...)\n|\n x = devm_ioport_map(...)\n)\n\n@safe depends on context || org || report exists@\nexpression x;\nposition p;\n@@\n\n(\n x = kmalloc(...)\n|\n x = kvasprintf(...)\n|\n x = kasprintf(...)\n|\n x = kzalloc(...)\n|\n x = kmalloc_array(...)\n|\n x = kcalloc(...)\n|\n x = kstrdup(...)\n|\n x = kmemdup(...)\n|\n x = get_free_pages(...)\n|\n x = request_irq(...)\n|\n x = ioremap(...)\n|\n x = ioport_map(...)\n)\n...\n(\n kfree@p(x)\n|\n kfree_sensitive@p(x)\n|\n krealloc@p(x, ...)\n|\n free_pages@p(x, ...)\n|\n free_page@p(x)\n|\n free_irq@p(x)\n|\n iounmap@p(x)\n|\n ioport_unmap@p(x)\n)\n\n@pb@\nexpression r.x;\nposition p != safe.p;\n@@\n\n(\n* kfree@p(x)\n|\n* kfree_sensitive@p(x)\n|\n* krealloc@p(x, ...)\n|\n* free_pages@p(x, ...)\n|\n* free_page@p(x)\n|\n* free_irq@p(x)\n|\n* iounmap@p(x)\n|\n* ioport_unmap@p(x)\n)\n\n@script:python depends on org@\np << pb.p;\n@@\n\nmsg=\"WARNING: invalid free of devm_ allocated data\"\ncoccilib.org.print_todo(p[0], msg)\n\n@script:python depends on report@\np << pb.p;\n@@\n\nmsg=\"WARNING: invalid free of devm_ allocated data\"\ncoccilib.report.print_report(p[0], msg)\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}