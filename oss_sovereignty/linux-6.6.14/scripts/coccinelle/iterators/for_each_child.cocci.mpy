{
  "module_name": "for_each_child.cocci",
  "hash_id": "61916aabfa616243a86348f70be54ddd58254dd878fcc06dd9c5b7d003d1954e",
  "original_prompt": "Ingested from linux-6.6.14/scripts/coccinelle/iterators/for_each_child.cocci",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0-only\n// Adds missing of_node_put() before return/break/goto statement within a for_each iterator for child nodes.\n//# False positives can be due to function calls within the for_each\n//# loop that may encapsulate an of_node_put.\n///\n// Confidence: High\n// Copyright: (C) 2020 Sumera Priyadarsini\n// URL: https://coccinelle.gitlabpages.inria.fr/website\n// Options: --no-includes --include-headers\n\nvirtual patch\nvirtual context\nvirtual org\nvirtual report\n\n@r@\nlocal idexpression n;\nexpression e1,e2;\niterator name for_each_node_by_name, for_each_node_by_type,\nfor_each_compatible_node, for_each_matching_node,\nfor_each_matching_node_and_match, for_each_child_of_node,\nfor_each_available_child_of_node, for_each_node_with_property;\niterator i;\nstatement S;\nexpression list [n1] es;\n@@\n\n(\n(\nfor_each_node_by_name(n,e1) S\n|\nfor_each_node_by_type(n,e1) S\n|\nfor_each_compatible_node(n,e1,e2) S\n|\nfor_each_matching_node(n,e1) S\n|\nfor_each_matching_node_and_match(n,e1,e2) S\n|\nfor_each_child_of_node(e1,n) S\n|\nfor_each_available_child_of_node(e1,n) S\n|\nfor_each_node_with_property(n,e1) S\n)\n&\ni(es,n,...) S\n)\n\n@ruleone depends on patch && !context && !org && !report@\n\nlocal idexpression r.n;\niterator r.i,i1;\nexpression e;\nexpression list [r.n1] es;\nstatement S;\n@@\n\n i(es,n,...) {\n   ...\n(\n   of_node_put(n);\n|\n   e = n\n|\n   return n;\n|\n   i1(...,n,...) S\n|\n- return of_node_get(n);\n+ return n;\n|\n+  of_node_put(n);\n?  return ...;\n)\n   ... when any\n }\n\n@ruletwo depends on patch && !context && !org && !report@\n\nlocal idexpression r.n;\niterator r.i,i1,i2;\nexpression e,e1;\nexpression list [r.n1] es;\nstatement S,S2;\n@@\n\n i(es,n,...) {\n   ...\n(\n   of_node_put(n);\n|\n   e = n\n|\n   i1(...,n,...) S\n|\n+  of_node_put(n);\n?  break;\n)\n   ... when any\n }\n... when != n\n    when strict\n    when forall\n(\n n = e1;\n|\n?i2(...,n,...) S2\n)\n\n@rulethree depends on patch && !context && !org && !report exists@\n\nlocal idexpression r.n;\niterator r.i,i1,i2;\nexpression e,e1;\nidentifier l;\nexpression list [r.n1] es;\nstatement S,S2;\n@@\n\n i(es,n,...) {\n   ...\n(\n   of_node_put(n);\n|\n   e = n\n|\n   i1(...,n,...) S\n|\n+  of_node_put(n);\n?  goto l;\n)\n   ... when any\n }\n... when exists\nl: ... when != n\n       when strict\n       when forall\n(\n n = e1;\n|\n?i2(...,n,...) S2\n)\n\n// ----------------------------------------------------------------------------\n\n@ruleone_context depends on !patch && (context || org || report) exists@\nstatement S;\nexpression e;\nexpression list[r.n1] es;\niterator r.i, i1;\nlocal idexpression r.n;\nposition j0, j1;\n@@\n\n i@j0(es,n,...) {\n   ...\n(\n   of_node_put(n);\n|\n   e = n\n|\n   return n;\n|\n   i1(...,n,...) S\n|\n  return @j1 ...;\n)\n   ... when any\n }\n\n@ruleone_disj depends on !patch && (context || org || report)@\nexpression list[r.n1] es;\niterator r.i;\nlocal idexpression r.n;\nposition ruleone_context.j0, ruleone_context.j1;\n@@\n\n*  i@j0(es,n,...) {\n   ...\n*return  @j1...;\n   ... when any\n }\n\n@ruletwo_context depends on !patch && (context || org || report) exists@\nstatement S, S2;\nexpression e, e1;\nexpression list[r.n1] es;\niterator r.i, i1, i2;\nlocal idexpression r.n;\nposition j0, j2;\n@@\n\n i@j0(es,n,...) {\n   ...\n(\n   of_node_put(n);\n|\n   e = n\n|\n   i1(...,n,...) S\n|\n  break@j2;\n)\n   ... when any\n }\n... when != n\n    when strict\n    when forall\n(\n n = e1;\n|\n?i2(...,n,...) S2\n)\n\n@ruletwo_disj depends on !patch && (context || org || report)@\nstatement S2;\nexpression e1;\nexpression list[r.n1] es;\niterator r.i, i2;\nlocal idexpression r.n;\nposition ruletwo_context.j0, ruletwo_context.j2;\n@@\n\n*  i@j0(es,n,...) {\n   ...\n*break @j2;\n   ... when any\n }\n... when != n\n    when strict\n    when forall\n(\n  n = e1;\n|\n?i2(...,n,...) S2\n)\n\n@rulethree_context depends on !patch && (context || org || report) exists@\nidentifier l;\nstatement S,S2;\nexpression e, e1;\nexpression list[r.n1] es;\niterator r.i, i1, i2;\nlocal idexpression r.n;\nposition j0, j3;\n@@\n\n i@j0(es,n,...) {\n   ...\n(\n   of_node_put(n);\n|\n   e = n\n|\n   i1(...,n,...) S\n|\n  goto l@j3;\n)\n  ... when any\n }\n... when exists\nl:\n... when != n\n    when strict\n    when forall\n(\n n = e1;\n|\n?i2(...,n,...) S2\n)\n\n@rulethree_disj depends on !patch && (context || org || report) exists@\nidentifier l;\nstatement S2;\nexpression e1;\nexpression list[r.n1] es;\niterator r.i, i2;\nlocal idexpression r.n;\nposition rulethree_context.j0, rulethree_context.j3;\n@@\n\n*  i@j0(es,n,...) {\n   ...\n*goto l@j3;\n   ... when any\n }\n... when exists\n l:\n ... when != n\n     when strict\n     when forall\n(\n n = e1;\n|\n?i2(...,n,...) S2\n)\n\n// ----------------------------------------------------------------------------\n\n@script:python ruleone_org depends on org@\ni << r.i;\nj0 << ruleone_context.j0;\nj1 << ruleone_context. j1;\n@@\n\nmsg = \"WARNING: Function \\\"%s\\\" should have of_node_put() before return \" % (i)\ncoccilib.org.print_safe_todo(j0[0], msg)\ncoccilib.org.print_link(j1[0], \"\")\n\n@script:python ruletwo_org depends on org@\ni << r.i;\nj0 << ruletwo_context.j0;\nj2 << ruletwo_context.j2;\n@@\n\nmsg = \"WARNING: Function \\\"%s\\\" should have of_node_put() before break \" % (i)\ncoccilib.org.print_safe_todo(j0[0], msg)\ncoccilib.org.print_link(j2[0], \"\")\n\n@script:python rulethree_org depends on org@\ni << r.i;\nj0 << rulethree_context.j0;\nj3 << rulethree_context.j3;\n@@\n\nmsg = \"WARNING: Function \\\"%s\\\" should have of_node_put() before goto \" % (i)\ncoccilib.org.print_safe_todo(j0[0], msg)\ncoccilib.org.print_link(j3[0], \"\")\n\n// ----------------------------------------------------------------------------\n\n@script:python ruleone_report depends on report@\ni << r.i;\nj0 << ruleone_context.j0;\nj1 << ruleone_context.j1;\n@@\n\nmsg = \"WARNING: Function \\\"%s\\\" should have of_node_put() before return around line %s.\" % (i, j1[0].line)\ncoccilib.report.print_report(j0[0], msg)\n\n@script:python ruletwo_report depends on report@\ni << r.i;\nj0 << ruletwo_context.j0;\nj2 << ruletwo_context.j2;\n@@\n\nmsg = \"WARNING: Function \\\"%s\\\" should have of_node_put() before break around line %s.\" % (i,j2[0].line)\ncoccilib.report.print_report(j0[0], msg)\n\n@script:python rulethree_report depends on report@\ni << r.i;\nj0 << rulethree_context.j0;\nj3 << rulethree_context.j3;\n@@\n\nmsg = \"WARNING: Function \\\"%s\\\" should have of_node_put() before goto around lines %s.\" % (i,j3[0].line)\ncoccilib.report.print_report(j0[0], msg)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}