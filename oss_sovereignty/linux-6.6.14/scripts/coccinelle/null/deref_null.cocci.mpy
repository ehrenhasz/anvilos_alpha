{
  "module_name": "deref_null.cocci",
  "hash_id": "a6d36acadaddda94005685dbd12e639524bb671a08498cc57bf2a97d9d6897c5",
  "original_prompt": "Ingested from linux-6.6.14/scripts/coccinelle/null/deref_null.cocci",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0-only\n///\n/// A variable is dereferenced under a NULL test.\n/// Even though it is known to be NULL.\n///\n// Confidence: Moderate\n// Copyright: (C) 2010 Nicolas Palix, DIKU.\n// Copyright: (C) 2010 Julia Lawall, DIKU.\n// Copyright: (C) 2010 Gilles Muller, INRIA/LiP6.\n// URL: https://coccinelle.gitlabpages.inria.fr/website\n// Comments: -I ... -all_includes can give more complete results\n// Options:\n\nvirtual context\nvirtual org\nvirtual report\n\n// The following two rules are separate, because both can match a single\n// expression in different ways\n@pr1 expression@\nexpression E;\nidentifier f;\nposition p1;\n@@\n\n (E != NULL && ...) ? <+...E->f@p1...+> : ...\n\n@pr2 expression@\nexpression E;\nidentifier f;\nposition p2;\n@@\n\n(\n  (E != NULL) && ... && <+...E->f@p2...+>\n|\n  (E == NULL) || ... || <+...E->f@p2...+>\n|\n sizeof(<+...E->f@p2...+>)\n)\n\n@ifm@\nexpression *E;\nstatement S1,S2;\nposition p1;\n@@\n\nif@p1 ((E == NULL && ...) || ...) S1 else S2\n\n// For org and report modes\n\n@r depends on !context && (org || report) exists@\nexpression subE <= ifm.E;\nexpression *ifm.E;\nexpression E1,E2;\nidentifier f;\nstatement S1,S2,S3,S4;\niterator iter;\nposition p!={pr1.p1,pr2.p2};\nposition ifm.p1;\n@@\n\nif@p1 ((E == NULL && ...) || ...)\n{\n  ... when != if (...) S1 else S2\n(\n iter(subE,...) S4 // no use\n|\n list_remove_head(E2,subE,...)\n|\n subE = E1\n|\n for(subE = E1;...;...) S4\n|\n subE++\n|\n ++subE\n|\n --subE\n|\n subE--\n|\n &subE\n|\n E->f@p // bad use\n)\n  ... when any\n  return ...;\n}\nelse S3\n\n@script:python depends on !context && !org && report@\np << r.p;\np1 << ifm.p1;\nx << ifm.E;\n@@\n\nmsg=\"ERROR: %s is NULL but dereferenced.\" % (x)\ncoccilib.report.print_report(p[0], msg)\ncocci.include_match(False)\n\n@script:python depends on !context && org && !report@\np << r.p;\np1 << ifm.p1;\nx << ifm.E;\n@@\n\nmsg=\"ERROR: %s is NULL but dereferenced.\" % (x)\nmsg_safe=msg.replace(\"[\",\"@(\").replace(\"]\",\")\")\ncocci.print_main(msg_safe,p)\ncocci.include_match(False)\n\n@s depends on !context && (org || report) exists@\nexpression subE <= ifm.E;\nexpression *ifm.E;\nexpression E1,E2;\nidentifier f;\nstatement S1,S2,S3,S4;\niterator iter;\nposition p!={pr1.p1,pr2.p2};\nposition ifm.p1;\n@@\n\nif@p1 ((E == NULL && ...) || ...)\n{\n  ... when != if (...) S1 else S2\n(\n iter(subE,...) S4 // no use\n|\n list_remove_head(E2,subE,...)\n|\n subE = E1\n|\n for(subE = E1;...;...) S4\n|\n subE++\n|\n ++subE\n|\n --subE\n|\n subE--\n|\n &subE\n|\n E->f@p // bad use\n)\n  ... when any\n}\nelse S3\n\n@script:python depends on !context && !org && report@\np << s.p;\np1 << ifm.p1;\nx << ifm.E;\n@@\n\nmsg=\"ERROR: %s is NULL but dereferenced.\" % (x)\ncoccilib.report.print_report(p[0], msg)\n\n@script:python depends on !context && org && !report@\np << s.p;\np1 << ifm.p1;\nx << ifm.E;\n@@\n\nmsg=\"ERROR: %s is NULL but dereferenced.\" % (x)\nmsg_safe=msg.replace(\"[\",\"@(\").replace(\"]\",\")\")\ncocci.print_main(msg_safe,p)\n\n// For context mode\n\n@depends on context && !org && !report exists@\nexpression subE <= ifm.E;\nexpression *ifm.E;\nexpression E1,E2;\nidentifier f;\nstatement S1,S2,S3,S4;\niterator iter;\nposition p!={pr1.p1,pr2.p2};\nposition ifm.p1;\n@@\n\nif@p1 ((E == NULL && ...) || ...)\n{\n  ... when != if (...) S1 else S2\n(\n iter(subE,...) S4 // no use\n|\n list_remove_head(E2,subE,...)\n|\n subE = E1\n|\n for(subE = E1;...;...) S4\n|\n subE++\n|\n ++subE\n|\n --subE\n|\n subE--\n|\n &subE\n|\n* E->f@p // bad use\n)\n  ... when any\n  return ...;\n}\nelse S3\n\n// The following three rules are duplicates of ifm, pr1 and pr2 respectively.\n// It is need because the previous rule as already made a \"change\".\n\n@pr11 depends on context && !org && !report expression@\nexpression E;\nidentifier f;\nposition p1;\n@@\n\n (E != NULL && ...) ? <+...E->f@p1...+> : ...\n\n@pr12 depends on context && !org && !report expression@\nexpression E;\nidentifier f;\nposition p2;\n@@\n\n(\n  (E != NULL) && ... && <+...E->f@p2...+>\n|\n  (E == NULL) || ... || <+...E->f@p2...+>\n|\n sizeof(<+...E->f@p2...+>)\n)\n\n@ifm1 depends on context && !org && !report@\nexpression *E;\nstatement S1,S2;\nposition p1;\n@@\n\nif@p1 ((E == NULL && ...) || ...) S1 else S2\n\n@depends on context && !org && !report exists@\nexpression subE <= ifm1.E;\nexpression *ifm1.E;\nexpression E1,E2;\nidentifier f;\nstatement S1,S2,S3,S4;\niterator iter;\nposition p!={pr11.p1,pr12.p2};\nposition ifm1.p1;\n@@\n\nif@p1 ((E == NULL && ...) || ...)\n{\n  ... when != if (...) S1 else S2\n(\n iter(subE,...) S4 // no use\n|\n list_remove_head(E2,subE,...)\n|\n subE = E1\n|\n for(subE = E1;...;...) S4\n|\n subE++\n|\n ++subE\n|\n --subE\n|\n subE--\n|\n &subE\n|\n* E->f@p // bad use\n)\n  ... when any\n}\nelse S3\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}