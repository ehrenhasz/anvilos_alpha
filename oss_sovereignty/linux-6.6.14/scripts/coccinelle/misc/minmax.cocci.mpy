{
  "module_name": "minmax.cocci",
  "hash_id": "c8620b30c54e23f5bbd7c0de195707b8a18b451e813c75c0f8f8ee436b7b810f",
  "original_prompt": "Ingested from linux-6.6.14/scripts/coccinelle/misc/minmax.cocci",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0-only\n///\n/// Check for opencoded min(), max() implementations.\n/// Generated patches sometimes require adding a cast to fix compile warning.\n/// Warnings/patches scope intentionally limited to a function body.\n///\n// Confidence: Medium\n// Copyright: (C) 2021 Denis Efremov ISPRAS\n// Options: --no-includes --include-headers\n//\n// Keywords: min, max\n//\n\n\nvirtual report\nvirtual org\nvirtual context\nvirtual patch\n\n@rmax depends on !patch@\nidentifier func;\nexpression x, y;\nbinary operator cmp = {>, >=};\nposition p;\n@@\n\nfunc(...)\n{\n\t<...\n*\t((x) cmp@p (y) ? (x) : (y))\n\t...>\n}\n\n@rmaxif depends on !patch@\nidentifier func;\nexpression x, y;\nexpression max_val;\nbinary operator cmp = {>, >=};\nposition p;\n@@\n\nfunc(...)\n{\n\t<...\n*\tif ((x) cmp@p (y)) {\n*\t\tmax_val = (x);\n*\t} else {\n*\t\tmax_val = (y);\n*\t}\n\t...>\n}\n\n@rmin depends on !patch@\nidentifier func;\nexpression x, y;\nbinary operator cmp = {<, <=};\nposition p;\n@@\n\nfunc(...)\n{\n\t<...\n*\t((x) cmp@p (y) ? (x) : (y))\n\t...>\n}\n\n@rminif depends on !patch@\nidentifier func;\nexpression x, y;\nexpression min_val;\nbinary operator cmp = {<, <=};\nposition p;\n@@\n\nfunc(...)\n{\n\t<...\n*\tif ((x) cmp@p (y)) {\n*\t\tmin_val = (x);\n*\t} else {\n*\t\tmin_val = (y);\n*\t}\n\t...>\n}\n\n@pmax depends on patch@\nidentifier func;\nexpression x, y;\nbinary operator cmp = {>=, >};\n@@\n\nfunc(...)\n{\n\t<...\n-\t((x) cmp (y) ? (x) : (y))\n+\tmax(x, y)\n\t...>\n}\n\n@pmaxif depends on patch@\nidentifier func;\nexpression x, y;\nexpression max_val;\nbinary operator cmp = {>=, >};\n@@\n\nfunc(...)\n{\n\t<...\n-\tif ((x) cmp (y)) {\n-\t\tmax_val = x;\n-\t} else {\n-\t\tmax_val = y;\n-\t}\n+\tmax_val = max(x, y);\n\t...>\n}\n\n// Don't generate patches for errcode returns.\n@errcode depends on patch@\nposition p;\nidentifier func;\nexpression x;\nbinary operator cmp = {<, <=};\n@@\n\nfunc(...)\n{\n\t<...\n\treturn ((x) cmp@p 0 ? (x) : 0);\n\t...>\n}\n\n@pmin depends on patch@\nidentifier func;\nexpression x, y;\nbinary operator cmp = {<=, <};\nposition p != errcode.p;\n@@\n\nfunc(...)\n{\n\t<...\n-\t((x) cmp@p (y) ? (x) : (y))\n+\tmin(x, y)\n\t...>\n}\n\n@pminif depends on patch@\nidentifier func;\nexpression x, y;\nexpression min_val;\nbinary operator cmp = {<=, <};\n@@\n\nfunc(...)\n{\n\t<...\n-\tif ((x) cmp (y)) {\n-\t\tmin_val = x;\n-\t} else {\n-\t\tmin_val = y;\n-\t}\n+\tmin_val = min(x, y);\n\t...>\n}\n\n@script:python depends on report@\np << rmax.p;\n@@\n\nfor p0 in p:\n\tcoccilib.report.print_report(p0, \"WARNING opportunity for max()\")\n\n@script:python depends on org@\np << rmax.p;\n@@\n\nfor p0 in p:\n\tcoccilib.org.print_todo(p0, \"WARNING opportunity for max()\")\n\n@script:python depends on report@\np << rmaxif.p;\n@@\n\nfor p0 in p:\n\tcoccilib.report.print_report(p0, \"WARNING opportunity for max()\")\n\n@script:python depends on org@\np << rmaxif.p;\n@@\n\nfor p0 in p:\n\tcoccilib.org.print_todo(p0, \"WARNING opportunity for max()\")\n\n@script:python depends on report@\np << rmin.p;\n@@\n\nfor p0 in p:\n\tcoccilib.report.print_report(p0, \"WARNING opportunity for min()\")\n\n@script:python depends on org@\np << rmin.p;\n@@\n\nfor p0 in p:\n\tcoccilib.org.print_todo(p0, \"WARNING opportunity for min()\")\n\n@script:python depends on report@\np << rminif.p;\n@@\n\nfor p0 in p:\n\tcoccilib.report.print_report(p0, \"WARNING opportunity for min()\")\n\n@script:python depends on org@\np << rminif.p;\n@@\n\nfor p0 in p:\n\tcoccilib.org.print_todo(p0, \"WARNING opportunity for min()\")\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}