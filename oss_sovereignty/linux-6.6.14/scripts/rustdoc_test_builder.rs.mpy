{
  "module_name": "rustdoc_test_builder.rs",
  "hash_id": "106cd392bf89ee6573df268ae14623379a57d969422cebff855c7c3d2171bf59",
  "original_prompt": "Ingested from linux-6.6.14/scripts/rustdoc_test_builder.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! Test builder for `rustdoc`-generated tests.\n//!\n//! This script is a hack to extract the test from `rustdoc`'s output. Ideally, `rustdoc` would\n//! have an option to generate this information instead, e.g. as JSON output.\n//!\n//! The `rustdoc`-generated test names look like `{file}_{line}_{number}`, e.g.\n//! `...path_rust_kernel_sync_arc_rs_42_0`. `number` is the \"test number\", needed in cases like\n//! a macro that expands into items with doctests is invoked several times within the same line.\n//!\n//! However, since these names are used for bisection in CI, the line number makes it not stable\n//! at all. In the future, we would like `rustdoc` to give us the Rust item path associated with\n//! the test, plus a \"test number\" (for cases with several examples per item) and generate a name\n//! from that. For the moment, we generate ourselves a new name, `{file}_{number}` instead, in\n//! the `gen` script (done there since we need to be aware of all the tests in a given file).\n\nuse std::io::Read;\n\nfn main() {\n    let mut stdin = std::io::stdin().lock();\n    let mut body = String::new();\n    stdin.read_to_string(&mut body).unwrap();\n\n    // Find the generated function name looking for the inner function inside `main()`.\n    //\n    // The line we are looking for looks like one of the following:\n    //\n    // ```\n    // fn main() { #[allow(non_snake_case)] fn _doctest_main_rust_kernel_file_rs_28_0() {\n    // fn main() { #[allow(non_snake_case)] fn _doctest_main_rust_kernel_file_rs_37_0() -> Result<(), impl core::fmt::Debug> {\n    // ```\n    //\n    // It should be unlikely that doctest code matches such lines (when code is formatted properly).\n    let rustdoc_function_name = body\n        .lines()\n        .find_map(|line| {\n            Some(\n                line.split_once(\"fn main() {\")?\n                    .1\n                    .split_once(\"fn \")?\n                    .1\n                    .split_once(\"()\")?\n                    .0,\n            )\n            .filter(|x| x.chars().all(|c| c.is_alphanumeric() || c == '_'))\n        })\n        .expect(\"No test function found in `rustdoc`'s output.\");\n\n    // Qualify `Result` to avoid the collision with our own `Result` coming from the prelude.\n    let body = body.replace(\n        &format!(\"{rustdoc_function_name}() -> Result<(), impl core::fmt::Debug> {{\"),\n        &format!(\"{rustdoc_function_name}() -> core::result::Result<(), impl core::fmt::Debug> {{\"),\n    );\n\n    // For tests that get generated with `Result`, like above, `rustdoc` generates an `unwrap()` on\n    // the return value to check there were no returned errors. Instead, we use our assert macro\n    // since we want to just fail the test, not panic the kernel.\n    //\n    // We save the result in a variable so that the failed assertion message looks nicer.\n    let body = body.replace(\n        &format!(\"}} {rustdoc_function_name}().unwrap() }}\"),\n        &format!(\"}} let test_return_value = {rustdoc_function_name}(); assert!(test_return_value.is_ok()); }}\"),\n    );\n\n    // Figure out a smaller test name based on the generated function name.\n    let name = rustdoc_function_name.split_once(\"_rust_kernel_\").unwrap().1;\n\n    let path = format!(\"rust/test/doctests/kernel/{name}\");\n\n    std::fs::write(path, body.as_bytes()).unwrap();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}