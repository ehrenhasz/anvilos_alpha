{
  "module_name": "kernel-doc",
  "hash_id": "048498bc56230b91f24b589f8d62e3dc9d52bc909ac11296334099eef93065e1",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kernel-doc",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n\nuse warnings;\nuse strict;\n\n## Copyright (c) 1998 Michael Zucchi, All Rights Reserved        ##\n## Copyright (C) 2000, 1  Tim Waugh <twaugh@redhat.com>          ##\n## Copyright (C) 2001  Simon Huggins                             ##\n## Copyright (C) 2005-2012  Randy Dunlap                         ##\n## Copyright (C) 2012  Dan Luedtke                               ##\n## \t\t\t\t\t\t\t\t ##\n## #define enhancements by Armin Kuster <akuster@mvista.com>\t ##\n## Copyright (c) 2000 MontaVista Software, Inc.\t\t\t ##\n#\n# Copyright (C) 2022 Tomasz Warnie\u0142\u0142o (POD)\n\nuse Pod::Usage qw/pod2usage/;\n\n=head1 NAME\n\nkernel-doc - Print formatted kernel documentation to stdout\n\n=head1 SYNOPSIS\n\n kernel-doc [-h] [-v] [-Werror] [-Wall] [-Wreturn] [-Wshort-description] [-Wcontents-before-sections]\n   [ -man |\n     -rst [-sphinx-version VERSION] [-enable-lineno] |\n     -none\n   ]\n   [\n     -export |\n     -internal |\n     [-function NAME] ... |\n     [-nosymbol NAME] ...\n   ]\n   [-no-doc-sections]\n   [-export-file FILE] ...\n   FILE ...\n\nRun `kernel-doc -h` for details.\n\n=head1 DESCRIPTION\n\nRead C language source or header FILEs, extract embedded documentation comments,\nand print formatted documentation to standard output.\n\nThe documentation comments are identified by the \"/**\" opening comment mark.\n\nSee Documentation/doc-guide/kernel-doc.rst for the documentation comment syntax.\n\n=cut\n\n# more perldoc at the end of the file\n\n## init lots of data\n\nmy $errors = 0;\nmy $warnings = 0;\nmy $anon_struct_union = 0;\n\n# match expressions used to find embedded type information\nmy $type_constant = '\\b``([^\\`]+)``\\b';\nmy $type_constant2 = '\\%([-_\\w]+)';\nmy $type_func = '(\\w+)\\(\\)';\nmy $type_param = '\\@(\\w*((\\.\\w+)|(->\\w+))*(\\.\\.\\.)?)';\nmy $type_param_ref = '([\\!~]?)\\@(\\w*((\\.\\w+)|(->\\w+))*(\\.\\.\\.)?)';\nmy $type_fp_param = '\\@(\\w+)\\(\\)';  # Special RST handling for func ptr params\nmy $type_fp_param2 = '\\@(\\w+->\\S+)\\(\\)';  # Special RST handling for structs with func ptr params\nmy $type_env = '(\\$\\w+)';\nmy $type_enum = '\\&(enum\\s*([_\\w]+))';\nmy $type_struct = '\\&(struct\\s*([_\\w]+))';\nmy $type_typedef = '\\&(typedef\\s*([_\\w]+))';\nmy $type_union = '\\&(union\\s*([_\\w]+))';\nmy $type_member = '\\&([_\\w]+)(\\.|->)([_\\w]+)';\nmy $type_fallback = '\\&([_\\w]+)';\nmy $type_member_func = $type_member . '\\(\\)';\n\n# Output conversion substitutions.\n#  One for each output format\n\n# these are pretty rough\nmy @highlights_man = (\n                      [$type_constant, \"\\$1\"],\n                      [$type_constant2, \"\\$1\"],\n                      [$type_func, \"\\\\\\\\fB\\$1\\\\\\\\fP\"],\n                      [$type_enum, \"\\\\\\\\fI\\$1\\\\\\\\fP\"],\n                      [$type_struct, \"\\\\\\\\fI\\$1\\\\\\\\fP\"],\n                      [$type_typedef, \"\\\\\\\\fI\\$1\\\\\\\\fP\"],\n                      [$type_union, \"\\\\\\\\fI\\$1\\\\\\\\fP\"],\n                      [$type_param, \"\\\\\\\\fI\\$1\\\\\\\\fP\"],\n                      [$type_param_ref, \"\\\\\\\\fI\\$1\\$2\\\\\\\\fP\"],\n                      [$type_member, \"\\\\\\\\fI\\$1\\$2\\$3\\\\\\\\fP\"],\n                      [$type_fallback, \"\\\\\\\\fI\\$1\\\\\\\\fP\"]\n\t\t     );\nmy $blankline_man = \"\";\n\n# rst-mode\nmy @highlights_rst = (\n                       [$type_constant, \"``\\$1``\"],\n                       [$type_constant2, \"``\\$1``\"],\n                       # Note: need to escape () to avoid func matching later\n                       [$type_member_func, \"\\\\:c\\\\:type\\\\:`\\$1\\$2\\$3\\\\\\\\(\\\\\\\\) <\\$1>`\"],\n                       [$type_member, \"\\\\:c\\\\:type\\\\:`\\$1\\$2\\$3 <\\$1>`\"],\n\t\t       [$type_fp_param, \"**\\$1\\\\\\\\(\\\\\\\\)**\"],\n\t\t       [$type_fp_param2, \"**\\$1\\\\\\\\(\\\\\\\\)**\"],\n                       [$type_func, \"\\$1()\"],\n                       [$type_enum, \"\\\\:c\\\\:type\\\\:`\\$1 <\\$2>`\"],\n                       [$type_struct, \"\\\\:c\\\\:type\\\\:`\\$1 <\\$2>`\"],\n                       [$type_typedef, \"\\\\:c\\\\:type\\\\:`\\$1 <\\$2>`\"],\n                       [$type_union, \"\\\\:c\\\\:type\\\\:`\\$1 <\\$2>`\"],\n                       # in rst this can refer to any type\n                       [$type_fallback, \"\\\\:c\\\\:type\\\\:`\\$1`\"],\n                       [$type_param_ref, \"**\\$1\\$2**\"]\n\t\t      );\nmy $blankline_rst = \"\\n\";\n\n# read arguments\nif ($#ARGV == -1) {\n\tpod2usage(\n\t\t-message => \"No arguments!\\n\",\n\t\t-exitval => 1,\n\t\t-verbose => 99,\n\t\t-sections => 'SYNOPSIS',\n\t\t-output => \\*STDERR,\n\t);\n}\n\nmy $kernelversion;\nmy ($sphinx_major, $sphinx_minor, $sphinx_patch);\n\nmy $dohighlight = \"\";\n\nmy $verbose = 0;\nmy $Werror = 0;\nmy $Wreturn = 0;\nmy $Wshort_desc = 0;\nmy $Wcontents_before_sections = 0;\nmy $output_mode = \"rst\";\nmy $output_preformatted = 0;\nmy $no_doc_sections = 0;\nmy $enable_lineno = 0;\nmy @highlights = @highlights_rst;\nmy $blankline = $blankline_rst;\nmy $modulename = \"Kernel API\";\n\nuse constant {\n    OUTPUT_ALL          => 0, # output all symbols and doc sections\n    OUTPUT_INCLUDE      => 1, # output only specified symbols\n    OUTPUT_EXPORTED     => 2, # output exported symbols\n    OUTPUT_INTERNAL     => 3, # output non-exported symbols\n};\nmy $output_selection = OUTPUT_ALL;\nmy $show_not_found = 0;\t# No longer used\n\nmy @export_file_list;\n\nmy @build_time;\nif (defined($ENV{'KBUILD_BUILD_TIMESTAMP'}) &&\n    (my $seconds = `date -d\"${ENV{'KBUILD_BUILD_TIMESTAMP'}}\" +%s`) ne '') {\n    @build_time = gmtime($seconds);\n} else {\n    @build_time = localtime;\n}\n\nmy $man_date = ('January', 'February', 'March', 'April', 'May', 'June',\n\t\t'July', 'August', 'September', 'October',\n\t\t'November', 'December')[$build_time[4]] .\n  \" \" . ($build_time[5]+1900);\n\n# Essentially these are globals.\n# They probably want to be tidied up, made more localised or something.\n# CAVEAT EMPTOR!  Some of the others I localised may not want to be, which\n# could cause \"use of undefined value\" or other bugs.\nmy ($function, %function_table, %parametertypes, $declaration_purpose);\nmy %nosymbol_table = ();\nmy $declaration_start_line;\nmy ($type, $declaration_name, $return_type);\nmy ($newsection, $newcontents, $prototype, $brcount, %source_map);\n\nif (defined($ENV{'KBUILD_VERBOSE'}) && $ENV{'KBUILD_VERBOSE'} =~ '1') {\n\t$verbose = 1;\n}\n\nif (defined($ENV{'KCFLAGS'})) {\n\tmy $kcflags = \"$ENV{'KCFLAGS'}\";\n\n\tif ($kcflags =~ /Werror/) {\n\t\t$Werror = 1;\n\t}\n}\n\n# reading this variable is for backwards compat just in case\n# someone was calling it with the variable from outside the\n# kernel's build system\nif (defined($ENV{'KDOC_WERROR'})) {\n\t$Werror = \"$ENV{'KDOC_WERROR'}\";\n}\n# other environment variables are converted to command-line\n# arguments in cmd_checkdoc in the build system\n\n# Generated docbook code is inserted in a template at a point where\n# docbook v3.1 requires a non-zero sequence of RefEntry's; see:\n# https://www.oasis-open.org/docbook/documentation/reference/html/refentry.html\n# We keep track of number of generated entries and generate a dummy\n# if needs be to ensure the expanded template can be postprocessed\n# into html.\nmy $section_counter = 0;\n\nmy $lineprefix=\"\";\n\n# Parser states\nuse constant {\n    STATE_NORMAL        => 0,        # normal code\n    STATE_NAME          => 1,        # looking for function name\n    STATE_BODY_MAYBE    => 2,        # body - or maybe more description\n    STATE_BODY          => 3,        # the body of the comment\n    STATE_BODY_WITH_BLANK_LINE => 4, # the body, which has a blank line\n    STATE_PROTO         => 5,        # scanning prototype\n    STATE_DOCBLOCK      => 6,        # documentation block\n    STATE_INLINE        => 7,        # gathering doc outside main block\n};\nmy $state;\nmy $in_doc_sect;\nmy $leading_space;\n\n# Inline documentation state\nuse constant {\n    STATE_INLINE_NA     => 0, # not applicable ($state != STATE_INLINE)\n    STATE_INLINE_NAME   => 1, # looking for member name (@foo:)\n    STATE_INLINE_TEXT   => 2, # looking for member documentation\n    STATE_INLINE_END    => 3, # done\n    STATE_INLINE_ERROR  => 4, # error - Comment without header was found.\n                              # Spit a warning as it's not\n                              # proper kernel-doc and ignore the rest.\n};\nmy $inline_doc_state;\n\n#declaration types: can be\n# 'function', 'struct', 'union', 'enum', 'typedef'\nmy $decl_type;\n\n# Name of the kernel-doc identifier for non-DOC markups\nmy $identifier;\n\nmy $doc_start = '^/\\*\\*\\s*$'; # Allow whitespace at end of comment start.\nmy $doc_end = '\\*/';\nmy $doc_com = '\\s*\\*\\s*';\nmy $doc_com_body = '\\s*\\* ?';\nmy $doc_decl = $doc_com . '(\\w+)';\n# @params and a strictly limited set of supported section names\n# Specifically:\n#   Match @word:\n#\t  @...:\n#         @{section-name}:\n# while trying to not match literal block starts like \"example::\"\n#\nmy $doc_sect = $doc_com .\n    '\\s*(\\@[.\\w]+|\\@\\.\\.\\.|description|context|returns?|notes?|examples?)\\s*:([^:].*)?$';\nmy $doc_content = $doc_com_body . '(.*)';\nmy $doc_block = $doc_com . 'DOC:\\s*(.*)?';\nmy $doc_inline_start = '^\\s*/\\*\\*\\s*$';\nmy $doc_inline_sect = '\\s*\\*\\s*(@\\s*[\\w][\\w\\.]*\\s*):(.*)';\nmy $doc_inline_end = '^\\s*\\*/\\s*$';\nmy $doc_inline_oneline = '^\\s*/\\*\\*\\s*(@[\\w\\s]+):\\s*(.*)\\s*\\*/\\s*$';\nmy $export_symbol = '^\\s*EXPORT_SYMBOL(_GPL)?\\s*\\(\\s*(\\w+)\\s*\\)\\s*;';\nmy $export_symbol_ns = '^\\s*EXPORT_SYMBOL_NS(_GPL)?\\s*\\(\\s*(\\w+)\\s*,\\s*\\w+\\)\\s*;';\nmy $function_pointer = qr{([^\\(]*\\(\\*)\\s*\\)\\s*\\(([^\\)]*)\\)};\nmy $attribute = qr{__attribute__\\s*\\(\\([a-z0-9,_\\*\\s\\(\\)]*\\)\\)}i;\n\nmy %parameterdescs;\nmy %parameterdesc_start_lines;\nmy @parameterlist;\nmy %sections;\nmy @sectionlist;\nmy %section_start_lines;\nmy $sectcheck;\nmy $struct_actual;\n\nmy $contents = \"\";\nmy $new_start_line = 0;\n\n# the canonical section names. see also $doc_sect above.\nmy $section_default = \"Description\";\t# default section\nmy $section_intro = \"Introduction\";\nmy $section = $section_default;\nmy $section_context = \"Context\";\nmy $section_return = \"Return\";\n\nmy $undescribed = \"-- undescribed --\";\n\nreset_state();\n\nwhile ($ARGV[0] =~ m/^--?(.*)/) {\n    my $cmd = $1;\n    shift @ARGV;\n    if ($cmd eq \"man\") {\n\t$output_mode = \"man\";\n\t@highlights = @highlights_man;\n\t$blankline = $blankline_man;\n    } elsif ($cmd eq \"rst\") {\n\t$output_mode = \"rst\";\n\t@highlights = @highlights_rst;\n\t$blankline = $blankline_rst;\n    } elsif ($cmd eq \"none\") {\n\t$output_mode = \"none\";\n    } elsif ($cmd eq \"module\") { # not needed for XML, inherits from calling document\n\t$modulename = shift @ARGV;\n    } elsif ($cmd eq \"function\") { # to only output specific functions\n\t$output_selection = OUTPUT_INCLUDE;\n\t$function = shift @ARGV;\n\t$function_table{$function} = 1;\n    } elsif ($cmd eq \"nosymbol\") { # Exclude specific symbols\n\tmy $symbol = shift @ARGV;\n\t$nosymbol_table{$symbol} = 1;\n    } elsif ($cmd eq \"export\") { # only exported symbols\n\t$output_selection = OUTPUT_EXPORTED;\n\t%function_table = ();\n    } elsif ($cmd eq \"internal\") { # only non-exported symbols\n\t$output_selection = OUTPUT_INTERNAL;\n\t%function_table = ();\n    } elsif ($cmd eq \"export-file\") {\n\tmy $file = shift @ARGV;\n\tpush(@export_file_list, $file);\n    } elsif ($cmd eq \"v\") {\n\t$verbose = 1;\n    } elsif ($cmd eq \"Werror\") {\n\t$Werror = 1;\n    } elsif ($cmd eq \"Wreturn\") {\n\t$Wreturn = 1;\n    } elsif ($cmd eq \"Wshort-desc\") {\n\t$Wshort_desc = 1;\n    } elsif ($cmd eq \"Wcontents-before-sections\") {\n\t$Wcontents_before_sections = 1;\n    } elsif ($cmd eq \"Wall\") {\n        $Wreturn = 1;\n        $Wshort_desc = 1;\n        $Wcontents_before_sections = 1;\n    } elsif (($cmd eq \"h\") || ($cmd eq \"help\")) {\n\t\tpod2usage(-exitval => 0, -verbose => 2);\n    } elsif ($cmd eq 'no-doc-sections') {\n\t    $no_doc_sections = 1;\n    } elsif ($cmd eq 'enable-lineno') {\n\t    $enable_lineno = 1;\n    } elsif ($cmd eq 'show-not-found') {\n\t$show_not_found = 1;  # A no-op but don't fail\n    } elsif ($cmd eq \"sphinx-version\") {\n\tmy $ver_string = shift @ARGV;\n\tif ($ver_string =~ m/^(\\d+)(\\.\\d+)?(\\.\\d+)?/) {\n\t    $sphinx_major = $1;\n\t    if (defined($2)) {\n\t\t$sphinx_minor = substr($2,1);\n\t    } else {\n\t\t$sphinx_minor = 0;\n\t    }\n\t    if (defined($3)) {\n\t\t$sphinx_patch = substr($3,1)\n\t    } else {\n\t\t$sphinx_patch = 0;\n\t    }\n\t} else {\n\t    die \"Sphinx version should either major.minor or major.minor.patch format\\n\";\n\t}\n    } else {\n\t# Unknown argument\n\tpod2usage(\n\t    -message => \"Argument unknown!\\n\",\n\t    -exitval => 1,\n\t    -verbose => 99,\n\t    -sections => 'SYNOPSIS',\n\t    -output => \\*STDERR,\n\t    );\n    }\n    if ($#ARGV < 0){\n\tpod2usage(\n\t    -message => \"FILE argument missing\\n\",\n\t    -exitval => 1,\n\t    -verbose => 99,\n\t    -sections => 'SYNOPSIS',\n\t    -output => \\*STDERR,\n\t    );\n    }\n}\n\n# continue execution near EOF;\n\n# The C domain dialect changed on Sphinx 3. So, we need to check the\n# version in order to produce the right tags.\nsub findprog($)\n{\n\tforeach(split(/:/, $ENV{PATH})) {\n\t\treturn \"$_/$_[0]\" if(-x \"$_/$_[0]\");\n\t}\n}\n\nsub get_sphinx_version()\n{\n\tmy $ver;\n\n\tmy $cmd = \"sphinx-build\";\n\tif (!findprog($cmd)) {\n\t\tmy $cmd = \"sphinx-build3\";\n\t\tif (!findprog($cmd)) {\n\t\t\t$sphinx_major = 1;\n\t\t\t$sphinx_minor = 2;\n\t\t\t$sphinx_patch = 0;\n\t\t\tprintf STDERR \"Warning: Sphinx version not found. Using default (Sphinx version %d.%d.%d)\\n\",\n\t\t\t       $sphinx_major, $sphinx_minor, $sphinx_patch;\n\t\t\treturn;\n\t\t}\n\t}\n\n\topen IN, \"$cmd --version 2>&1 |\";\n\twhile (<IN>) {\n\t\tif (m/^\\s*sphinx-build\\s+([\\d]+)\\.([\\d\\.]+)(\\+\\/[\\da-f]+)?$/) {\n\t\t\t$sphinx_major = $1;\n\t\t\t$sphinx_minor = $2;\n\t\t\t$sphinx_patch = $3;\n\t\t\tlast;\n\t\t}\n\t\t# Sphinx 1.2.x uses a different format\n\t\tif (m/^\\s*Sphinx.*\\s+([\\d]+)\\.([\\d\\.]+)$/) {\n\t\t\t$sphinx_major = $1;\n\t\t\t$sphinx_minor = $2;\n\t\t\t$sphinx_patch = $3;\n\t\t\tlast;\n\t\t}\n\t}\n\tclose IN;\n}\n\n# get kernel version from env\nsub get_kernel_version() {\n    my $version = 'unknown kernel version';\n\n    if (defined($ENV{'KERNELVERSION'})) {\n\t$version = $ENV{'KERNELVERSION'};\n    }\n    return $version;\n}\n\n#\nsub print_lineno {\n    my $lineno = shift;\n    if ($enable_lineno && defined($lineno)) {\n        print \".. LINENO \" . $lineno . \"\\n\";\n    }\n}\n\nsub emit_warning {\n    my $location = shift;\n    my $msg = shift;\n    print STDERR \"$location: warning: $msg\";\n    ++$warnings;\n}\n##\n# dumps section contents to arrays/hashes intended for that purpose.\n#\nsub dump_section {\n    my $file = shift;\n    my $name = shift;\n    my $contents = join \"\\n\", @_;\n\n    if ($name =~ m/$type_param/) {\n\t$name = $1;\n\t$parameterdescs{$name} = $contents;\n\t$sectcheck = $sectcheck . $name . \" \";\n        $parameterdesc_start_lines{$name} = $new_start_line;\n        $new_start_line = 0;\n    } elsif ($name eq \"@\\.\\.\\.\") {\n\t$name = \"...\";\n\t$parameterdescs{$name} = $contents;\n\t$sectcheck = $sectcheck . $name . \" \";\n        $parameterdesc_start_lines{$name} = $new_start_line;\n        $new_start_line = 0;\n    } else {\n\tif (defined($sections{$name}) && ($sections{$name} ne \"\")) {\n\t    # Only warn on user specified duplicate section names.\n\t    if ($name ne $section_default) {\n\t\temit_warning(\"${file}:$.\", \"duplicate section name '$name'\\n\");\n\t    }\n\t    $sections{$name} .= $contents;\n\t} else {\n\t    $sections{$name} = $contents;\n\t    push @sectionlist, $name;\n            $section_start_lines{$name} = $new_start_line;\n            $new_start_line = 0;\n\t}\n    }\n}\n\n##\n# dump DOC: section after checking that it should go out\n#\nsub dump_doc_section {\n    my $file = shift;\n    my $name = shift;\n    my $contents = join \"\\n\", @_;\n\n    if ($no_doc_sections) {\n        return;\n    }\n\n    return if (defined($nosymbol_table{$name}));\n\n    if (($output_selection == OUTPUT_ALL) ||\n\t(($output_selection == OUTPUT_INCLUDE) &&\n\t defined($function_table{$name})))\n    {\n\tdump_section($file, $name, $contents);\n\toutput_blockhead({'sectionlist' => \\@sectionlist,\n\t\t\t  'sections' => \\%sections,\n\t\t\t  'module' => $modulename,\n\t\t\t  'content-only' => ($output_selection != OUTPUT_ALL), });\n    }\n}\n\n##\n# output function\n#\n# parameterdescs, a hash.\n#  function => \"function name\"\n#  parameterlist => @list of parameters\n#  parameterdescs => %parameter descriptions\n#  sectionlist => @list of sections\n#  sections => %section descriptions\n#\n\nsub output_highlight {\n    my $contents = join \"\\n\",@_;\n    my $line;\n\n#   DEBUG\n#   if (!defined $contents) {\n#\tuse Carp;\n#\tconfess \"output_highlight got called with no args?\\n\";\n#   }\n\n#   print STDERR \"contents b4:$contents\\n\";\n    eval $dohighlight;\n    die $@ if $@;\n#   print STDERR \"contents af:$contents\\n\";\n\n    foreach $line (split \"\\n\", $contents) {\n\tif (! $output_preformatted) {\n\t    $line =~ s/^\\s*//;\n\t}\n\tif ($line eq \"\"){\n\t    if (! $output_preformatted) {\n\t\tprint $lineprefix, $blankline;\n\t    }\n\t} else {\n\t    if ($output_mode eq \"man\" && substr($line, 0, 1) eq \".\") {\n\t\tprint \"\\\\&$line\";\n\t    } else {\n\t\tprint $lineprefix, $line;\n\t    }\n\t}\n\tprint \"\\n\";\n    }\n}\n\n##\n# output function in man\nsub output_function_man(%) {\n    my %args = %{$_[0]};\n    my ($parameter, $section);\n    my $count;\n\n    print \".TH \\\"$args{'function'}\\\" 9 \\\"$args{'function'}\\\" \\\"$man_date\\\" \\\"Kernel Hacker's Manual\\\" LINUX\\n\";\n\n    print \".SH NAME\\n\";\n    print $args{'function'} . \" \\\\- \" . $args{'purpose'} . \"\\n\";\n\n    print \".SH SYNOPSIS\\n\";\n    if ($args{'functiontype'} ne \"\") {\n\tprint \".B \\\"\" . $args{'functiontype'} . \"\\\" \" . $args{'function'} . \"\\n\";\n    } else {\n\tprint \".B \\\"\" . $args{'function'} . \"\\n\";\n    }\n    $count = 0;\n    my $parenth = \"(\";\n    my $post = \",\";\n    foreach my $parameter (@{$args{'parameterlist'}}) {\n\tif ($count == $#{$args{'parameterlist'}}) {\n\t    $post = \");\";\n\t}\n\t$type = $args{'parametertypes'}{$parameter};\n\tif ($type =~ m/$function_pointer/) {\n\t    # pointer-to-function\n\t    print \".BI \\\"\" . $parenth . $1 . \"\\\" \" . \" \\\") (\" . $2 . \")\" . $post . \"\\\"\\n\";\n\t} else {\n\t    $type =~ s/([^\\*])$/$1 /;\n\t    print \".BI \\\"\" . $parenth . $type . \"\\\" \" . \" \\\"\" . $post . \"\\\"\\n\";\n\t}\n\t$count++;\n\t$parenth = \"\";\n    }\n\n    print \".SH ARGUMENTS\\n\";\n    foreach $parameter (@{$args{'parameterlist'}}) {\n\tmy $parameter_name = $parameter;\n\t$parameter_name =~ s/\\[.*//;\n\n\tprint \".IP \\\"\" . $parameter . \"\\\" 12\\n\";\n\toutput_highlight($args{'parameterdescs'}{$parameter_name});\n    }\n    foreach $section (@{$args{'sectionlist'}}) {\n\tprint \".SH \\\"\", uc $section, \"\\\"\\n\";\n\toutput_highlight($args{'sections'}{$section});\n    }\n}\n\n##\n# output enum in man\nsub output_enum_man(%) {\n    my %args = %{$_[0]};\n    my ($parameter, $section);\n    my $count;\n\n    print \".TH \\\"$args{'module'}\\\" 9 \\\"enum $args{'enum'}\\\" \\\"$man_date\\\" \\\"API Manual\\\" LINUX\\n\";\n\n    print \".SH NAME\\n\";\n    print \"enum \" . $args{'enum'} . \" \\\\- \" . $args{'purpose'} . \"\\n\";\n\n    print \".SH SYNOPSIS\\n\";\n    print \"enum \" . $args{'enum'} . \" {\\n\";\n    $count = 0;\n    foreach my $parameter (@{$args{'parameterlist'}}) {\n\tprint \".br\\n.BI \\\"    $parameter\\\"\\n\";\n\tif ($count == $#{$args{'parameterlist'}}) {\n\t    print \"\\n};\\n\";\n\t    last;\n\t}\n\telse {\n\t    print \", \\n.br\\n\";\n\t}\n\t$count++;\n    }\n\n    print \".SH Constants\\n\";\n    foreach $parameter (@{$args{'parameterlist'}}) {\n\tmy $parameter_name = $parameter;\n\t$parameter_name =~ s/\\[.*//;\n\n\tprint \".IP \\\"\" . $parameter . \"\\\" 12\\n\";\n\toutput_highlight($args{'parameterdescs'}{$parameter_name});\n    }\n    foreach $section (@{$args{'sectionlist'}}) {\n\tprint \".SH \\\"$section\\\"\\n\";\n\toutput_highlight($args{'sections'}{$section});\n    }\n}\n\n##\n# output struct in man\nsub output_struct_man(%) {\n    my %args = %{$_[0]};\n    my ($parameter, $section);\n\n    print \".TH \\\"$args{'module'}\\\" 9 \\\"\" . $args{'type'} . \" \" . $args{'struct'} . \"\\\" \\\"$man_date\\\" \\\"API Manual\\\" LINUX\\n\";\n\n    print \".SH NAME\\n\";\n    print $args{'type'} . \" \" . $args{'struct'} . \" \\\\- \" . $args{'purpose'} . \"\\n\";\n\n    my $declaration = $args{'definition'};\n    $declaration =~ s/\\t/  /g;\n    $declaration =~ s/\\n/\"\\n.br\\n.BI \\\"/g;\n    print \".SH SYNOPSIS\\n\";\n    print $args{'type'} . \" \" . $args{'struct'} . \" {\\n.br\\n\";\n    print \".BI \\\"$declaration\\n};\\n.br\\n\\n\";\n\n    print \".SH Members\\n\";\n    foreach $parameter (@{$args{'parameterlist'}}) {\n\t($parameter =~ /^#/) && next;\n\n\tmy $parameter_name = $parameter;\n\t$parameter_name =~ s/\\[.*//;\n\n\t($args{'parameterdescs'}{$parameter_name} ne $undescribed) || next;\n\tprint \".IP \\\"\" . $parameter . \"\\\" 12\\n\";\n\toutput_highlight($args{'parameterdescs'}{$parameter_name});\n    }\n    foreach $section (@{$args{'sectionlist'}}) {\n\tprint \".SH \\\"$section\\\"\\n\";\n\toutput_highlight($args{'sections'}{$section});\n    }\n}\n\n##\n# output typedef in man\nsub output_typedef_man(%) {\n    my %args = %{$_[0]};\n    my ($parameter, $section);\n\n    print \".TH \\\"$args{'module'}\\\" 9 \\\"$args{'typedef'}\\\" \\\"$man_date\\\" \\\"API Manual\\\" LINUX\\n\";\n\n    print \".SH NAME\\n\";\n    print \"typedef \" . $args{'typedef'} . \" \\\\- \" . $args{'purpose'} . \"\\n\";\n\n    foreach $section (@{$args{'sectionlist'}}) {\n\tprint \".SH \\\"$section\\\"\\n\";\n\toutput_highlight($args{'sections'}{$section});\n    }\n}\n\nsub output_blockhead_man(%) {\n    my %args = %{$_[0]};\n    my ($parameter, $section);\n    my $count;\n\n    print \".TH \\\"$args{'module'}\\\" 9 \\\"$args{'module'}\\\" \\\"$man_date\\\" \\\"API Manual\\\" LINUX\\n\";\n\n    foreach $section (@{$args{'sectionlist'}}) {\n\tprint \".SH \\\"$section\\\"\\n\";\n\toutput_highlight($args{'sections'}{$section});\n    }\n}\n\n##\n# output in restructured text\n#\n\n#\n# This could use some work; it's used to output the DOC: sections, and\n# starts by putting out the name of the doc section itself, but that tends\n# to duplicate a header already in the template file.\n#\nsub output_blockhead_rst(%) {\n    my %args = %{$_[0]};\n    my ($parameter, $section);\n\n    foreach $section (@{$args{'sectionlist'}}) {\n\tnext if (defined($nosymbol_table{$section}));\n\n\tif ($output_selection != OUTPUT_INCLUDE) {\n\t    print \".. _$section:\\n\\n\";\n\t    print \"**$section**\\n\\n\";\n\t}\n        print_lineno($section_start_lines{$section});\n\toutput_highlight_rst($args{'sections'}{$section});\n\tprint \"\\n\";\n    }\n}\n\n#\n# Apply the RST highlights to a sub-block of text.\n#\nsub highlight_block($) {\n    # The dohighlight kludge requires the text be called $contents\n    my $contents = shift;\n    eval $dohighlight;\n    die $@ if $@;\n    return $contents;\n}\n\n#\n# Regexes used only here.\n#\nmy $sphinx_literal = '^[^.].*::$';\nmy $sphinx_cblock = '^\\.\\.\\ +code-block::';\n\nsub output_highlight_rst {\n    my $input = join \"\\n\",@_;\n    my $output = \"\";\n    my $line;\n    my $in_literal = 0;\n    my $litprefix;\n    my $block = \"\";\n\n    foreach $line (split \"\\n\",$input) {\n\t#\n\t# If we're in a literal block, see if we should drop out\n\t# of it.  Otherwise pass the line straight through unmunged.\n\t#\n\tif ($in_literal) {\n\t    if (! ($line =~ /^\\s*$/)) {\n\t\t#\n\t\t# If this is the first non-blank line in a literal\n\t\t# block we need to figure out what the proper indent is.\n\t\t#\n\t\tif ($litprefix eq \"\") {\n\t\t    $line =~ /^(\\s*)/;\n\t\t    $litprefix = '^' . $1;\n\t\t    $output .= $line . \"\\n\";\n\t\t} elsif (! ($line =~ /$litprefix/)) {\n\t\t    $in_literal = 0;\n\t\t} else {\n\t\t    $output .= $line . \"\\n\";\n\t\t}\n\t    } else {\n\t\t$output .= $line . \"\\n\";\n\t    }\n\t}\n\t#\n\t# Not in a literal block (or just dropped out)\n\t#\n\tif (! $in_literal) {\n\t    $block .= $line . \"\\n\";\n\t    if (($line =~ /$sphinx_literal/) || ($line =~ /$sphinx_cblock/)) {\n\t\t$in_literal = 1;\n\t\t$litprefix = \"\";\n\t\t$output .= highlight_block($block);\n\t\t$block = \"\"\n\t    }\n\t}\n    }\n\n    if ($block) {\n\t$output .= highlight_block($block);\n    }\n    foreach $line (split \"\\n\", $output) {\n\tprint $lineprefix . $line . \"\\n\";\n    }\n}\n\nsub output_function_rst(%) {\n    my %args = %{$_[0]};\n    my ($parameter, $section);\n    my $oldprefix = $lineprefix;\n    my $start = \"\";\n    my $is_macro = 0;\n\n    if ($sphinx_major < 3) {\n\tif ($args{'typedef'}) {\n\t    print \".. c:type:: \". $args{'function'} . \"\\n\\n\";\n\t    print_lineno($declaration_start_line);\n\t    print \"   **Typedef**: \";\n\t    $lineprefix = \"\";\n\t    output_highlight_rst($args{'purpose'});\n\t    $start = \"\\n\\n**Syntax**\\n\\n  ``\";\n\t    $is_macro = 1;\n\t} else {\n\t    print \".. c:function:: \";\n\t}\n    } else {\n\tif ($args{'typedef'} || $args{'functiontype'} eq \"\") {\n\t    $is_macro = 1;\n\t    print \".. c:macro:: \". $args{'function'} . \"\\n\\n\";\n\t} else {\n\t    print \".. c:function:: \";\n\t}\n\n\tif ($args{'typedef'}) {\n\t    print_lineno($declaration_start_line);\n\t    print \"   **Typedef**: \";\n\t    $lineprefix = \"\";\n\t    output_highlight_rst($args{'purpose'});\n\t    $start = \"\\n\\n**Syntax**\\n\\n  ``\";\n\t} else {\n\t    print \"``\" if ($is_macro);\n\t}\n    }\n    if ($args{'functiontype'} ne \"\") {\n\t$start .= $args{'functiontype'} . \" \" . $args{'function'} . \" (\";\n    } else {\n\t$start .= $args{'function'} . \" (\";\n    }\n    print $start;\n\n    my $count = 0;\n    foreach my $parameter (@{$args{'parameterlist'}}) {\n\tif ($count ne 0) {\n\t    print \", \";\n\t}\n\t$count++;\n\t$type = $args{'parametertypes'}{$parameter};\n\n\tif ($type =~ m/$function_pointer/) {\n\t    # pointer-to-function\n\t    print $1 . $parameter . \") (\" . $2 . \")\";\n\t} else {\n\t    print $type;\n\t}\n    }\n    if ($is_macro) {\n\tprint \")``\\n\\n\";\n    } else {\n\tprint \")\\n\\n\";\n    }\n    if (!$args{'typedef'}) {\n\tprint_lineno($declaration_start_line);\n\t$lineprefix = \"   \";\n\toutput_highlight_rst($args{'purpose'});\n\tprint \"\\n\";\n    }\n\n    #\n    # Put our descriptive text into a container (thus an HTML <div>) to help\n    # set the function prototypes apart.\n    #\n    print \".. container:: kernelindent\\n\\n\";\n    $lineprefix = \"  \";\n    print $lineprefix . \"**Parameters**\\n\\n\";\n    foreach $parameter (@{$args{'parameterlist'}}) {\n\tmy $parameter_name = $parameter;\n\t$parameter_name =~ s/\\[.*//;\n\t$type = $args{'parametertypes'}{$parameter};\n\n\tif ($type ne \"\") {\n\t    print $lineprefix . \"``$type``\\n\";\n\t} else {\n\t    print $lineprefix . \"``$parameter``\\n\";\n\t}\n\n        print_lineno($parameterdesc_start_lines{$parameter_name});\n\n\t$lineprefix = \"    \";\n\tif (defined($args{'parameterdescs'}{$parameter_name}) &&\n\t    $args{'parameterdescs'}{$parameter_name} ne $undescribed) {\n\t    output_highlight_rst($args{'parameterdescs'}{$parameter_name});\n\t} else {\n\t    print $lineprefix . \"*undescribed*\\n\";\n\t}\n\t$lineprefix = \"  \";\n\tprint \"\\n\";\n    }\n\n    output_section_rst(@_);\n    $lineprefix = $oldprefix;\n}\n\nsub output_section_rst(%) {\n    my %args = %{$_[0]};\n    my $section;\n    my $oldprefix = $lineprefix;\n\n    foreach $section (@{$args{'sectionlist'}}) {\n\tprint $lineprefix . \"**$section**\\n\\n\";\n        print_lineno($section_start_lines{$section});\n\toutput_highlight_rst($args{'sections'}{$section});\n\tprint \"\\n\";\n    }\n    print \"\\n\";\n}\n\nsub output_enum_rst(%) {\n    my %args = %{$_[0]};\n    my ($parameter);\n    my $oldprefix = $lineprefix;\n    my $count;\n    my $outer;\n\n    if ($sphinx_major < 3) {\n\tmy $name = \"enum \" . $args{'enum'};\n\tprint \"\\n\\n.. c:type:: \" . $name . \"\\n\\n\";\n    } else {\n\tmy $name = $args{'enum'};\n\tprint \"\\n\\n.. c:enum:: \" . $name . \"\\n\\n\";\n    }\n    print_lineno($declaration_start_line);\n    $lineprefix = \"  \";\n    output_highlight_rst($args{'purpose'});\n    print \"\\n\";\n\n    print \".. container:: kernelindent\\n\\n\";\n    $outer = $lineprefix . \"  \";\n    $lineprefix = $outer . \"  \";\n    print $outer . \"**Constants**\\n\\n\";\n    foreach $parameter (@{$args{'parameterlist'}}) {\n\tprint $outer . \"``$parameter``\\n\";\n\n\tif ($args{'parameterdescs'}{$parameter} ne $undescribed) {\n\t    output_highlight_rst($args{'parameterdescs'}{$parameter});\n\t} else {\n\t    print $lineprefix . \"*undescribed*\\n\";\n\t}\n\tprint \"\\n\";\n    }\n    print \"\\n\";\n    $lineprefix = $oldprefix;\n    output_section_rst(@_);\n}\n\nsub output_typedef_rst(%) {\n    my %args = %{$_[0]};\n    my ($parameter);\n    my $oldprefix = $lineprefix;\n    my $name;\n\n    if ($sphinx_major < 3) {\n\t$name = \"typedef \" . $args{'typedef'};\n    } else {\n\t$name = $args{'typedef'};\n    }\n    print \"\\n\\n.. c:type:: \" . $name . \"\\n\\n\";\n    print_lineno($declaration_start_line);\n    $lineprefix = \"   \";\n    output_highlight_rst($args{'purpose'});\n    print \"\\n\";\n\n    $lineprefix = $oldprefix;\n    output_section_rst(@_);\n}\n\nsub output_struct_rst(%) {\n    my %args = %{$_[0]};\n    my ($parameter);\n    my $oldprefix = $lineprefix;\n\n    if ($sphinx_major < 3) {\n\tmy $name = $args{'type'} . \" \" . $args{'struct'};\n\tprint \"\\n\\n.. c:type:: \" . $name . \"\\n\\n\";\n    } else {\n\tmy $name = $args{'struct'};\n\tif ($args{'type'} eq 'union') {\n\t    print \"\\n\\n.. c:union:: \" . $name . \"\\n\\n\";\n\t} else {\n\t    print \"\\n\\n.. c:struct:: \" . $name . \"\\n\\n\";\n\t}\n    }\n    print_lineno($declaration_start_line);\n    $lineprefix = \"  \";\n    output_highlight_rst($args{'purpose'});\n    print \"\\n\";\n\n    print \".. container:: kernelindent\\n\\n\";\n    print $lineprefix . \"**Definition**::\\n\\n\";\n    my $declaration = $args{'definition'};\n    $lineprefix = $lineprefix . \"  \";\n    $declaration =~ s/\\t/$lineprefix/g;\n    print $lineprefix . $args{'type'} . \" \" . $args{'struct'} . \" {\\n$declaration\" . $lineprefix . \"};\\n\\n\";\n\n    $lineprefix = \"  \";\n    print $lineprefix . \"**Members**\\n\\n\";\n    foreach $parameter (@{$args{'parameterlist'}}) {\n\t($parameter =~ /^#/) && next;\n\n\tmy $parameter_name = $parameter;\n\t$parameter_name =~ s/\\[.*//;\n\n\t($args{'parameterdescs'}{$parameter_name} ne $undescribed) || next;\n\t$type = $args{'parametertypes'}{$parameter};\n        print_lineno($parameterdesc_start_lines{$parameter_name});\n\tprint $lineprefix . \"``\" . $parameter . \"``\\n\";\n\t$lineprefix = \"    \";\n\toutput_highlight_rst($args{'parameterdescs'}{$parameter_name});\n\t$lineprefix = \"  \";\n\tprint \"\\n\";\n    }\n    print \"\\n\";\n\n    $lineprefix = $oldprefix;\n    output_section_rst(@_);\n}\n\n## none mode output functions\n\nsub output_function_none(%) {\n}\n\nsub output_enum_none(%) {\n}\n\nsub output_typedef_none(%) {\n}\n\nsub output_struct_none(%) {\n}\n\nsub output_blockhead_none(%) {\n}\n\n##\n# generic output function for all types (function, struct/union, typedef, enum);\n# calls the generated, variable output_ function name based on\n# functype and output_mode\nsub output_declaration {\n    no strict 'refs';\n    my $name = shift;\n    my $functype = shift;\n    my $func = \"output_${functype}_$output_mode\";\n\n    return if (defined($nosymbol_table{$name}));\n\n    if (($output_selection == OUTPUT_ALL) ||\n\t(($output_selection == OUTPUT_INCLUDE ||\n\t  $output_selection == OUTPUT_EXPORTED) &&\n\t defined($function_table{$name})) ||\n\t($output_selection == OUTPUT_INTERNAL &&\n\t !($functype eq \"function\" && defined($function_table{$name}))))\n    {\n\t&$func(@_);\n\t$section_counter++;\n    }\n}\n\n##\n# generic output function - calls the right one based on current output mode.\nsub output_blockhead {\n    no strict 'refs';\n    my $func = \"output_blockhead_\" . $output_mode;\n    &$func(@_);\n    $section_counter++;\n}\n\n##\n# takes a declaration (struct, union, enum, typedef) and\n# invokes the right handler. NOT called for functions.\nsub dump_declaration($$) {\n    no strict 'refs';\n    my ($prototype, $file) = @_;\n    my $func = \"dump_\" . $decl_type;\n    &$func(@_);\n}\n\nsub dump_union($$) {\n    dump_struct(@_);\n}\n\nsub dump_struct($$) {\n    my $x = shift;\n    my $file = shift;\n    my $decl_type;\n    my $members;\n    my $type = qr{struct|union};\n    # For capturing struct/union definition body, i.e. \"{members*}qualifiers*\"\n    my $qualifiers = qr{$attribute|__packed|__aligned|____cacheline_aligned_in_smp|____cacheline_aligned};\n    my $definition_body = qr{\\{(.*)\\}\\s*$qualifiers*};\n    my $struct_members = qr{($type)([^\\{\\};]+)\\{([^\\{\\}]*)\\}([^\\{\\}\\;]*)\\;};\n\n    if ($x =~ /($type)\\s+(\\w+)\\s*$definition_body/) {\n\t$decl_type = $1;\n\t$declaration_name = $2;\n\t$members = $3;\n    } elsif ($x =~ /typedef\\s+($type)\\s*$definition_body\\s*(\\w+)\\s*;/) {\n\t$decl_type = $1;\n\t$declaration_name = $3;\n\t$members = $2;\n    }\n\n    if ($members) {\n\tif ($identifier ne $declaration_name) {\n\t    emit_warning(\"${file}:$.\", \"expecting prototype for $decl_type $identifier. Prototype was for $decl_type $declaration_name instead\\n\");\n\t    return;\n\t}\n\n\t# ignore members marked private:\n\t$members =~ s/\\/\\*\\s*private:.*?\\/\\*\\s*public:.*?\\*\\///gosi;\n\t$members =~ s/\\/\\*\\s*private:.*//gosi;\n\t# strip comments:\n\t$members =~ s/\\/\\*.*?\\*\\///gos;\n\t# strip attributes\n\t$members =~ s/\\s*$attribute/ /gi;\n\t$members =~ s/\\s*__aligned\\s*\\([^;]*\\)/ /gos;\n\t$members =~ s/\\s*__packed\\s*/ /gos;\n\t$members =~ s/\\s*CRYPTO_MINALIGN_ATTR/ /gos;\n\t$members =~ s/\\s*____cacheline_aligned_in_smp/ /gos;\n\t$members =~ s/\\s*____cacheline_aligned/ /gos;\n\t# unwrap struct_group():\n\t# - first eat non-declaration parameters and rewrite for final match\n\t# - then remove macro, outer parens, and trailing semicolon\n\t$members =~ s/\\bstruct_group\\s*\\(([^,]*,)/STRUCT_GROUP(/gos;\n\t$members =~ s/\\bstruct_group_(attr|tagged)\\s*\\(([^,]*,){2}/STRUCT_GROUP(/gos;\n\t$members =~ s/\\b__struct_group\\s*\\(([^,]*,){3}/STRUCT_GROUP(/gos;\n\t$members =~ s/\\bSTRUCT_GROUP(\\(((?:(?>[^)(]+)|(?1))*)\\))[^;]*;/$2/gos;\n\n\tmy $args = qr{([^,)]+)};\n\t# replace DECLARE_BITMAP\n\t$members =~ s/__ETHTOOL_DECLARE_LINK_MODE_MASK\\s*\\(([^\\)]+)\\)/DECLARE_BITMAP($1, __ETHTOOL_LINK_MODE_MASK_NBITS)/gos;\n\t$members =~ s/DECLARE_PHY_INTERFACE_MASK\\s*\\(([^\\)]+)\\)/DECLARE_BITMAP($1, PHY_INTERFACE_MODE_MAX)/gos;\n\t$members =~ s/DECLARE_BITMAP\\s*\\($args,\\s*$args\\)/unsigned long $1\\[BITS_TO_LONGS($2)\\]/gos;\n\t# replace DECLARE_HASHTABLE\n\t$members =~ s/DECLARE_HASHTABLE\\s*\\($args,\\s*$args\\)/unsigned long $1\\[1 << (($2) - 1)\\]/gos;\n\t# replace DECLARE_KFIFO\n\t$members =~ s/DECLARE_KFIFO\\s*\\($args,\\s*$args,\\s*$args\\)/$2 \\*$1/gos;\n\t# replace DECLARE_KFIFO_PTR\n\t$members =~ s/DECLARE_KFIFO_PTR\\s*\\($args,\\s*$args\\)/$2 \\*$1/gos;\n\t# replace DECLARE_FLEX_ARRAY\n\t$members =~ s/(?:__)?DECLARE_FLEX_ARRAY\\s*\\($args,\\s*$args\\)/$1 $2\\[\\]/gos;\n\t#replace DEFINE_DMA_UNMAP_ADDR\n\t$members =~ s/DEFINE_DMA_UNMAP_ADDR\\s*\\($args\\)/dma_addr_t $1/gos;\n\t#replace DEFINE_DMA_UNMAP_LEN\n\t$members =~ s/DEFINE_DMA_UNMAP_LEN\\s*\\($args\\)/__u32 $1/gos;\n\tmy $declaration = $members;\n\n\t# Split nested struct/union elements as newer ones\n\twhile ($members =~ m/$struct_members/) {\n\t\tmy $newmember;\n\t\tmy $maintype = $1;\n\t\tmy $ids = $4;\n\t\tmy $content = $3;\n\t\tforeach my $id(split /,/, $ids) {\n\t\t\t$newmember .= \"$maintype $id; \";\n\n\t\t\t$id =~ s/[:\\[].*//;\n\t\t\t$id =~ s/^\\s*\\**(\\S+)\\s*/$1/;\n\t\t\tforeach my $arg (split /;/, $content) {\n\t\t\t\tnext if ($arg =~ m/^\\s*$/);\n\t\t\t\tif ($arg =~ m/^([^\\(]+\\(\\*?\\s*)([\\w\\.]*)(\\s*\\).*)/) {\n\t\t\t\t\t# pointer-to-function\n\t\t\t\t\tmy $type = $1;\n\t\t\t\t\tmy $name = $2;\n\t\t\t\t\tmy $extra = $3;\n\t\t\t\t\tnext if (!$name);\n\t\t\t\t\tif ($id =~ m/^\\s*$/) {\n\t\t\t\t\t\t# anonymous struct/union\n\t\t\t\t\t\t$newmember .= \"$type$name$extra; \";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$newmember .= \"$type$id.$name$extra; \";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmy $type;\n\t\t\t\t\tmy $names;\n\t\t\t\t\t$arg =~ s/^\\s+//;\n\t\t\t\t\t$arg =~ s/\\s+$//;\n\t\t\t\t\t# Handle bitmaps\n\t\t\t\t\t$arg =~ s/:\\s*\\d+\\s*//g;\n\t\t\t\t\t# Handle arrays\n\t\t\t\t\t$arg =~ s/\\[.*\\]//g;\n\t\t\t\t\t# The type may have multiple words,\n\t\t\t\t\t# and multiple IDs can be defined, like:\n\t\t\t\t\t#\tconst struct foo, *bar, foobar\n\t\t\t\t\t# So, we remove spaces when parsing the\n\t\t\t\t\t# names, in order to match just names\n\t\t\t\t\t# and commas for the names\n\t\t\t\t\t$arg =~ s/\\s*,\\s*/,/g;\n\t\t\t\t\tif ($arg =~ m/(.*)\\s+([\\S+,]+)/) {\n\t\t\t\t\t\t$type = $1;\n\t\t\t\t\t\t$names = $2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$newmember .= \"$arg; \";\n\t\t\t\t\t\tnext;\n\t\t\t\t\t}\n\t\t\t\t\tforeach my $name (split /,/, $names) {\n\t\t\t\t\t\t$name =~ s/^\\s*\\**(\\S+)\\s*/$1/;\n\t\t\t\t\t\tnext if (($name =~ m/^\\s*$/));\n\t\t\t\t\t\tif ($id =~ m/^\\s*$/) {\n\t\t\t\t\t\t\t# anonymous struct/union\n\t\t\t\t\t\t\t$newmember .= \"$type $name; \";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$newmember .= \"$type $id.$name; \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$members =~ s/$struct_members/$newmember/;\n\t}\n\n\t# Ignore other nested elements, like enums\n\t$members =~ s/(\\{[^\\{\\}]*\\})//g;\n\n\tcreate_parameterlist($members, ';', $file, $declaration_name);\n\tcheck_sections($file, $declaration_name, $decl_type, $sectcheck, $struct_actual);\n\n\t# Adjust declaration for better display\n\t$declaration =~ s/([\\{;])/$1\\n/g;\n\t$declaration =~ s/\\}\\s+;/};/g;\n\t# Better handle inlined enums\n\tdo {} while ($declaration =~ s/(enum\\s+\\{[^\\}]+),([^\\n])/$1,\\n$2/);\n\n\tmy @def_args = split /\\n/, $declaration;\n\tmy $level = 1;\n\t$declaration = \"\";\n\tforeach my $clause (@def_args) {\n\t\t$clause =~ s/^\\s+//;\n\t\t$clause =~ s/\\s+$//;\n\t\t$clause =~ s/\\s+/ /;\n\t\tnext if (!$clause);\n\t\t$level-- if ($clause =~ m/(\\})/ && $level > 1);\n\t\tif (!($clause =~ m/^\\s*#/)) {\n\t\t\t$declaration .= \"\\t\" x $level;\n\t\t}\n\t\t$declaration .= \"\\t\" . $clause . \"\\n\";\n\t\t$level++ if ($clause =~ m/(\\{)/ && !($clause =~m/\\}/));\n\t}\n\toutput_declaration($declaration_name,\n\t\t\t   'struct',\n\t\t\t   {'struct' => $declaration_name,\n\t\t\t    'module' => $modulename,\n\t\t\t    'definition' => $declaration,\n\t\t\t    'parameterlist' => \\@parameterlist,\n\t\t\t    'parameterdescs' => \\%parameterdescs,\n\t\t\t    'parametertypes' => \\%parametertypes,\n\t\t\t    'sectionlist' => \\@sectionlist,\n\t\t\t    'sections' => \\%sections,\n\t\t\t    'purpose' => $declaration_purpose,\n\t\t\t    'type' => $decl_type\n\t\t\t   });\n    }\n    else {\n\tprint STDERR \"${file}:$.: error: Cannot parse struct or union!\\n\";\n\t++$errors;\n    }\n}\n\n\nsub show_warnings($$) {\n\tmy $functype = shift;\n\tmy $name = shift;\n\n\treturn 0 if (defined($nosymbol_table{$name}));\n\n\treturn 1 if ($output_selection == OUTPUT_ALL);\n\n\tif ($output_selection == OUTPUT_EXPORTED) {\n\t\tif (defined($function_table{$name})) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n        if ($output_selection == OUTPUT_INTERNAL) {\n\t\tif (!($functype eq \"function\" && defined($function_table{$name}))) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif ($output_selection == OUTPUT_INCLUDE) {\n\t\tif (defined($function_table{$name})) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdie(\"Please add the new output type at show_warnings()\");\n}\n\nsub dump_enum($$) {\n    my $x = shift;\n    my $file = shift;\n    my $members;\n\n    # ignore members marked private:\n    $x =~ s/\\/\\*\\s*private:.*?\\/\\*\\s*public:.*?\\*\\///gosi;\n    $x =~ s/\\/\\*\\s*private:.*}/}/gosi;\n\n    $x =~ s@/\\*.*?\\*/@@gos;\t# strip comments.\n    # strip #define macros inside enums\n    $x =~ s@#\\s*((define|ifdef)\\s+|endif)[^;]*;@@gos;\n\n    if ($x =~ /typedef\\s+enum\\s*\\{(.*)\\}\\s*(\\w*)\\s*;/) {\n\t$declaration_name = $2;\n\t$members = $1;\n    } elsif ($x =~ /enum\\s+(\\w*)\\s*\\{(.*)\\}/) {\n\t$declaration_name = $1;\n\t$members = $2;\n    }\n\n    if ($members) {\n\tif ($identifier ne $declaration_name) {\n\t    if ($identifier eq \"\") {\n\t\temit_warning(\"${file}:$.\", \"wrong kernel-doc identifier on line:\\n\");\n\t    } else {\n\t\temit_warning(\"${file}:$.\", \"expecting prototype for enum $identifier. Prototype was for enum $declaration_name instead\\n\");\n\t    }\n\t    return;\n\t}\n\t$declaration_name = \"(anonymous)\" if ($declaration_name eq \"\");\n\n\tmy %_members;\n\n\t$members =~ s/\\s+$//;\n\t$members =~ s/\\([^;]*?[\\)]//g;\n\n\tforeach my $arg (split ',', $members) {\n\t    $arg =~ s/^\\s*(\\w+).*/$1/;\n\t    push @parameterlist, $arg;\n\t    if (!$parameterdescs{$arg}) {\n\t\t$parameterdescs{$arg} = $undescribed;\n\t        if (show_warnings(\"enum\", $declaration_name)) {\n\t\t\temit_warning(\"${file}:$.\", \"Enum value '$arg' not described in enum '$declaration_name'\\n\");\n\t\t}\n\t    }\n\t    $_members{$arg} = 1;\n\t}\n\n\twhile (my ($k, $v) = each %parameterdescs) {\n\t    if (!exists($_members{$k})) {\n\t        if (show_warnings(\"enum\", $declaration_name)) {\n\t\t     emit_warning(\"${file}:$.\", \"Excess enum value '$k' description in '$declaration_name'\\n\");\n\t\t}\n\t    }\n        }\n\n\toutput_declaration($declaration_name,\n\t\t\t   'enum',\n\t\t\t   {'enum' => $declaration_name,\n\t\t\t    'module' => $modulename,\n\t\t\t    'parameterlist' => \\@parameterlist,\n\t\t\t    'parameterdescs' => \\%parameterdescs,\n\t\t\t    'sectionlist' => \\@sectionlist,\n\t\t\t    'sections' => \\%sections,\n\t\t\t    'purpose' => $declaration_purpose\n\t\t\t   });\n    } else {\n\tprint STDERR \"${file}:$.: error: Cannot parse enum!\\n\";\n\t++$errors;\n    }\n}\n\nmy $typedef_type = qr { ((?:\\s+[\\w\\*]+\\b){1,8})\\s* }x;\nmy $typedef_ident = qr { \\*?\\s*(\\w\\S+)\\s* }x;\nmy $typedef_args = qr { \\s*\\((.*)\\); }x;\n\nmy $typedef1 = qr { typedef$typedef_type\\($typedef_ident\\)$typedef_args }x;\nmy $typedef2 = qr { typedef$typedef_type$typedef_ident$typedef_args }x;\n\nsub dump_typedef($$) {\n    my $x = shift;\n    my $file = shift;\n\n    $x =~ s@/\\*.*?\\*/@@gos;\t# strip comments.\n\n    # Parse function typedef prototypes\n    if ($x =~ $typedef1 || $x =~ $typedef2) {\n\t$return_type = $1;\n\t$declaration_name = $2;\n\tmy $args = $3;\n\t$return_type =~ s/^\\s+//;\n\n\tif ($identifier ne $declaration_name) {\n\t    emit_warning(\"${file}:$.\", \"expecting prototype for typedef $identifier. Prototype was for typedef $declaration_name instead\\n\");\n\t    return;\n\t}\n\n\tcreate_parameterlist($args, ',', $file, $declaration_name);\n\n\toutput_declaration($declaration_name,\n\t\t\t   'function',\n\t\t\t   {'function' => $declaration_name,\n\t\t\t    'typedef' => 1,\n\t\t\t    'module' => $modulename,\n\t\t\t    'functiontype' => $return_type,\n\t\t\t    'parameterlist' => \\@parameterlist,\n\t\t\t    'parameterdescs' => \\%parameterdescs,\n\t\t\t    'parametertypes' => \\%parametertypes,\n\t\t\t    'sectionlist' => \\@sectionlist,\n\t\t\t    'sections' => \\%sections,\n\t\t\t    'purpose' => $declaration_purpose\n\t\t\t   });\n\treturn;\n    }\n\n    while (($x =~ /\\(*.\\)\\s*;$/) || ($x =~ /\\[*.\\]\\s*;$/)) {\n\t$x =~ s/\\(*.\\)\\s*;$/;/;\n\t$x =~ s/\\[*.\\]\\s*;$/;/;\n    }\n\n    if ($x =~ /typedef.*\\s+(\\w+)\\s*;/) {\n\t$declaration_name = $1;\n\n\tif ($identifier ne $declaration_name) {\n\t    emit_warning(\"${file}:$.\", \"expecting prototype for typedef $identifier. Prototype was for typedef $declaration_name instead\\n\");\n\t    return;\n\t}\n\n\toutput_declaration($declaration_name,\n\t\t\t   'typedef',\n\t\t\t   {'typedef' => $declaration_name,\n\t\t\t    'module' => $modulename,\n\t\t\t    'sectionlist' => \\@sectionlist,\n\t\t\t    'sections' => \\%sections,\n\t\t\t    'purpose' => $declaration_purpose\n\t\t\t   });\n    }\n    else {\n\tprint STDERR \"${file}:$.: error: Cannot parse typedef!\\n\";\n\t++$errors;\n    }\n}\n\nsub save_struct_actual($) {\n    my $actual = shift;\n\n    # strip all spaces from the actual param so that it looks like one string item\n    $actual =~ s/\\s*//g;\n    $struct_actual = $struct_actual . $actual . \" \";\n}\n\nsub create_parameterlist($$$$) {\n    my $args = shift;\n    my $splitter = shift;\n    my $file = shift;\n    my $declaration_name = shift;\n    my $type;\n    my $param;\n\n    # temporarily replace commas inside function pointer definition\n    my $arg_expr = qr{\\([^\\),]+};\n    while ($args =~ /$arg_expr,/) {\n\t$args =~ s/($arg_expr),/$1#/g;\n    }\n\n    foreach my $arg (split($splitter, $args)) {\n\t# strip comments\n\t$arg =~ s/\\/\\*.*\\*\\///;\n\t# ignore argument attributes\n\t$arg =~ s/\\sPOS0?\\s/ /;\n\t# strip leading/trailing spaces\n\t$arg =~ s/^\\s*//;\n\t$arg =~ s/\\s*$//;\n\t$arg =~ s/\\s+/ /;\n\n\tif ($arg =~ /^#/) {\n\t    # Treat preprocessor directive as a typeless variable just to fill\n\t    # corresponding data structures \"correctly\". Catch it later in\n\t    # output_* subs.\n\t    push_parameter($arg, \"\", \"\", $file);\n\t} elsif ($arg =~ m/\\(.+\\)\\s*\\(/) {\n\t    # pointer-to-function\n\t    $arg =~ tr/#/,/;\n\t    $arg =~ m/[^\\(]+\\(\\*?\\s*([\\w\\[\\]\\.]*)\\s*\\)/;\n\t    $param = $1;\n\t    $type = $arg;\n\t    $type =~ s/([^\\(]+\\(\\*?)\\s*$param/$1/;\n\t    save_struct_actual($param);\n\t    push_parameter($param, $type, $arg, $file, $declaration_name);\n\t} elsif ($arg) {\n\t    $arg =~ s/\\s*:\\s*/:/g;\n\t    $arg =~ s/\\s*\\[/\\[/g;\n\n\t    my @args = split('\\s*,\\s*', $arg);\n\t    if ($args[0] =~ m/\\*/) {\n\t\t$args[0] =~ s/(\\*+)\\s*/ $1/;\n\t    }\n\n\t    my @first_arg;\n\t    if ($args[0] =~ /^(.*\\s+)(.*?\\[.*\\].*)$/) {\n\t\t    shift @args;\n\t\t    push(@first_arg, split('\\s+', $1));\n\t\t    push(@first_arg, $2);\n\t    } else {\n\t\t    @first_arg = split('\\s+', shift @args);\n\t    }\n\n\t    unshift(@args, pop @first_arg);\n\t    $type = join \" \", @first_arg;\n\n\t    foreach $param (@args) {\n\t\tif ($param =~ m/^(\\*+)\\s*(.*)/) {\n\t\t    save_struct_actual($2);\n\n\t\t    push_parameter($2, \"$type $1\", $arg, $file, $declaration_name);\n\t\t}\n\t\telsif ($param =~ m/(.*?):(\\d+)/) {\n\t\t    if ($type ne \"\") { # skip unnamed bit-fields\n\t\t\tsave_struct_actual($1);\n\t\t\tpush_parameter($1, \"$type:$2\", $arg, $file, $declaration_name)\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    save_struct_actual($param);\n\t\t    push_parameter($param, $type, $arg, $file, $declaration_name);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nsub push_parameter($$$$$) {\n\tmy $param = shift;\n\tmy $type = shift;\n\tmy $org_arg = shift;\n\tmy $file = shift;\n\tmy $declaration_name = shift;\n\n\tif (($anon_struct_union == 1) && ($type eq \"\") &&\n\t    ($param eq \"}\")) {\n\t\treturn;\t\t# ignore the ending }; from anon. struct/union\n\t}\n\n\t$anon_struct_union = 0;\n\t$param =~ s/[\\[\\)].*//;\n\n\tif ($type eq \"\" && $param =~ /\\.\\.\\.$/)\n\t{\n\t    if (!$param =~ /\\w\\.\\.\\.$/) {\n\t      # handles unnamed variable parameters\n\t      $param = \"...\";\n\t    }\n\t    elsif ($param =~ /\\w\\.\\.\\.$/) {\n\t      # for named variable parameters of the form `x...`, remove the dots\n\t      $param =~ s/\\.\\.\\.$//;\n\t    }\n\t    if (!defined $parameterdescs{$param} || $parameterdescs{$param} eq \"\") {\n\t\t$parameterdescs{$param} = \"variable arguments\";\n\t    }\n\t}\n\telsif ($type eq \"\" && ($param eq \"\" or $param eq \"void\"))\n\t{\n\t    $param=\"void\";\n\t    $parameterdescs{void} = \"no arguments\";\n\t}\n\telsif ($type eq \"\" && ($param eq \"struct\" or $param eq \"union\"))\n\t# handle unnamed (anonymous) union or struct:\n\t{\n\t\t$type = $param;\n\t\t$param = \"{unnamed_\" . $param . \"}\";\n\t\t$parameterdescs{$param} = \"anonymous\\n\";\n\t\t$anon_struct_union = 1;\n\t}\n\n\t# warn if parameter has no description\n\t# (but ignore ones starting with # as these are not parameters\n\t# but inline preprocessor statements);\n\t# Note: It will also ignore void params and unnamed structs/unions\n\tif (!defined $parameterdescs{$param} && $param !~ /^#/) {\n\t\t$parameterdescs{$param} = $undescribed;\n\n\t        if (show_warnings($type, $declaration_name) && $param !~ /\\./) {\n\t\t\temit_warning(\"${file}:$.\", \"Function parameter or member '$param' not described in '$declaration_name'\\n\");\n\t\t}\n\t}\n\n\t# strip spaces from $param so that it is one continuous string\n\t# on @parameterlist;\n\t# this fixes a problem where check_sections() cannot find\n\t# a parameter like \"addr[6 + 2]\" because it actually appears\n\t# as \"addr[6\", \"+\", \"2]\" on the parameter list;\n\t# but it's better to maintain the param string unchanged for output,\n\t# so just weaken the string compare in check_sections() to ignore\n\t# \"[blah\" in a parameter string;\n\t###$param =~ s/\\s*//g;\n\tpush @parameterlist, $param;\n\t$org_arg =~ s/\\s\\s+/ /g;\n\t$parametertypes{$param} = $org_arg;\n}\n\nsub check_sections($$$$$) {\n\tmy ($file, $decl_name, $decl_type, $sectcheck, $prmscheck) = @_;\n\tmy @sects = split ' ', $sectcheck;\n\tmy @prms = split ' ', $prmscheck;\n\tmy $err;\n\tmy ($px, $sx);\n\tmy $prm_clean;\t\t# strip trailing \"[array size]\" and/or beginning \"*\"\n\n\tforeach $sx (0 .. $#sects) {\n\t\t$err = 1;\n\t\tforeach $px (0 .. $#prms) {\n\t\t\t$prm_clean = $prms[$px];\n\t\t\t$prm_clean =~ s/\\[.*\\]//;\n\t\t\t$prm_clean =~ s/$attribute//i;\n\t\t\t# ignore array size in a parameter string;\n\t\t\t# however, the original param string may contain\n\t\t\t# spaces, e.g.:  addr[6 + 2]\n\t\t\t# and this appears in @prms as \"addr[6\" since the\n\t\t\t# parameter list is split at spaces;\n\t\t\t# hence just ignore \"[...\" for the sections check;\n\t\t\t$prm_clean =~ s/\\[.*//;\n\n\t\t\t##$prm_clean =~ s/^\\**//;\n\t\t\tif ($prm_clean eq $sects[$sx]) {\n\t\t\t\t$err = 0;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\tif ($err) {\n\t\t\tif ($decl_type eq \"function\") {\n\t\t\t\temit_warning(\"${file}:$.\",\n\t\t\t\t\t\"Excess function parameter \" .\n\t\t\t\t\t\"'$sects[$sx]' \" .\n\t\t\t\t\t\"description in '$decl_name'\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n##\n# Checks the section describing the return value of a function.\nsub check_return_section {\n        my $file = shift;\n        my $declaration_name = shift;\n        my $return_type = shift;\n\n        # Ignore an empty return type (It's a macro)\n        # Ignore functions with a \"void\" return type. (But don't ignore \"void *\")\n        if (($return_type eq \"\") || ($return_type =~ /void\\s*\\w*\\s*$/)) {\n                return;\n        }\n\n        if (!defined($sections{$section_return}) ||\n            $sections{$section_return} eq \"\") {\n                emit_warning(\"${file}:$.\",\n                        \"No description found for return value of \" .\n                        \"'$declaration_name'\\n\");\n        }\n}\n\n##\n# takes a function prototype and the name of the current file being\n# processed and spits out all the details stored in the global\n# arrays/hashes.\nsub dump_function($$) {\n    my $prototype = shift;\n    my $file = shift;\n    my $noret = 0;\n\n    print_lineno($new_start_line);\n\n    $prototype =~ s/^static +//;\n    $prototype =~ s/^extern +//;\n    $prototype =~ s/^asmlinkage +//;\n    $prototype =~ s/^inline +//;\n    $prototype =~ s/^__inline__ +//;\n    $prototype =~ s/^__inline +//;\n    $prototype =~ s/^__always_inline +//;\n    $prototype =~ s/^noinline +//;\n    $prototype =~ s/^__FORTIFY_INLINE +//;\n    $prototype =~ s/__init +//;\n    $prototype =~ s/__init_or_module +//;\n    $prototype =~ s/__deprecated +//;\n    $prototype =~ s/__flatten +//;\n    $prototype =~ s/__meminit +//;\n    $prototype =~ s/__must_check +//;\n    $prototype =~ s/__weak +//;\n    $prototype =~ s/__sched +//;\n    $prototype =~ s/__printf\\s*\\(\\s*\\d*\\s*,\\s*\\d*\\s*\\) +//;\n    $prototype =~ s/__(?:re)?alloc_size\\s*\\(\\s*\\d+\\s*(?:,\\s*\\d+\\s*)?\\) +//;\n    $prototype =~ s/__diagnose_as\\s*\\(\\s*\\S+\\s*(?:,\\s*\\d+\\s*)*\\) +//;\n    my $define = $prototype =~ s/^#\\s*define\\s+//; #ak added\n    $prototype =~ s/__attribute_const__ +//;\n    $prototype =~ s/__attribute__\\s*\\(\\(\n            (?:\n                 [\\w\\s]++          # attribute name\n                 (?:\\([^)]*+\\))?   # attribute arguments\n                 \\s*+,?            # optional comma at the end\n            )+\n          \\)\\)\\s+//x;\n\n    # Yes, this truly is vile.  We are looking for:\n    # 1. Return type (may be nothing if we're looking at a macro)\n    # 2. Function name\n    # 3. Function parameters.\n    #\n    # All the while we have to watch out for function pointer parameters\n    # (which IIRC is what the two sections are for), C types (these\n    # regexps don't even start to express all the possibilities), and\n    # so on.\n    #\n    # If you mess with these regexps, it's a good idea to check that\n    # the following functions' documentation still comes out right:\n    # - parport_register_device (function pointer parameters)\n    # - atomic_set (macro)\n    # - pci_match_device, __copy_to_user (long return type)\n    my $name = qr{[a-zA-Z0-9_~:]+};\n    my $prototype_end1 = qr{[^\\(]*};\n    my $prototype_end2 = qr{[^\\{]*};\n    my $prototype_end = qr{\\(($prototype_end1|$prototype_end2)\\)};\n    my $type1 = qr{[\\w\\s]+};\n    my $type2 = qr{$type1\\*+};\n\n    if ($define && $prototype =~ m/^()($name)\\s+/) {\n        # This is an object-like macro, it has no return type and no parameter\n        # list.\n        # Function-like macros are not allowed to have spaces between\n        # declaration_name and opening parenthesis (notice the \\s+).\n        $return_type = $1;\n        $declaration_name = $2;\n        $noret = 1;\n    } elsif ($prototype =~ m/^()($name)\\s*$prototype_end/ ||\n\t$prototype =~ m/^($type1)\\s+($name)\\s*$prototype_end/ ||\n\t$prototype =~ m/^($type2+)\\s*($name)\\s*$prototype_end/)  {\n\t$return_type = $1;\n\t$declaration_name = $2;\n\tmy $args = $3;\n\n\tcreate_parameterlist($args, ',', $file, $declaration_name);\n    } else {\n\temit_warning(\"${file}:$.\", \"cannot understand function prototype: '$prototype'\\n\");\n\treturn;\n    }\n\n    if ($identifier ne $declaration_name) {\n\temit_warning(\"${file}:$.\", \"expecting prototype for $identifier(). Prototype was for $declaration_name() instead\\n\");\n\treturn;\n    }\n\n    my $prms = join \" \", @parameterlist;\n    check_sections($file, $declaration_name, \"function\", $sectcheck, $prms);\n\n    # This check emits a lot of warnings at the moment, because many\n    # functions don't have a 'Return' doc section. So until the number\n    # of warnings goes sufficiently down, the check is only performed in\n    # -Wreturn mode.\n    # TODO: always perform the check.\n    if ($Wreturn && !$noret) {\n\t    check_return_section($file, $declaration_name, $return_type);\n    }\n\n    # The function parser can be called with a typedef parameter.\n    # Handle it.\n    if ($return_type =~ /typedef/) {\n\toutput_declaration($declaration_name,\n\t\t\t   'function',\n\t\t\t   {'function' => $declaration_name,\n\t\t\t    'typedef' => 1,\n\t\t\t    'module' => $modulename,\n\t\t\t    'functiontype' => $return_type,\n\t\t\t    'parameterlist' => \\@parameterlist,\n\t\t\t    'parameterdescs' => \\%parameterdescs,\n\t\t\t    'parametertypes' => \\%parametertypes,\n\t\t\t    'sectionlist' => \\@sectionlist,\n\t\t\t    'sections' => \\%sections,\n\t\t\t    'purpose' => $declaration_purpose\n\t\t\t   });\n    } else {\n\toutput_declaration($declaration_name,\n\t\t\t   'function',\n\t\t\t   {'function' => $declaration_name,\n\t\t\t    'module' => $modulename,\n\t\t\t    'functiontype' => $return_type,\n\t\t\t    'parameterlist' => \\@parameterlist,\n\t\t\t    'parameterdescs' => \\%parameterdescs,\n\t\t\t    'parametertypes' => \\%parametertypes,\n\t\t\t    'sectionlist' => \\@sectionlist,\n\t\t\t    'sections' => \\%sections,\n\t\t\t    'purpose' => $declaration_purpose\n\t\t\t   });\n    }\n}\n\nsub reset_state {\n    $function = \"\";\n    %parameterdescs = ();\n    %parametertypes = ();\n    @parameterlist = ();\n    %sections = ();\n    @sectionlist = ();\n    $sectcheck = \"\";\n    $struct_actual = \"\";\n    $prototype = \"\";\n\n    $state = STATE_NORMAL;\n    $inline_doc_state = STATE_INLINE_NA;\n}\n\nsub tracepoint_munge($) {\n\tmy $file = shift;\n\tmy $tracepointname = 0;\n\tmy $tracepointargs = 0;\n\n\tif ($prototype =~ m/TRACE_EVENT\\((.*?),/) {\n\t\t$tracepointname = $1;\n\t}\n\tif ($prototype =~ m/DEFINE_SINGLE_EVENT\\((.*?),/) {\n\t\t$tracepointname = $1;\n\t}\n\tif ($prototype =~ m/DEFINE_EVENT\\((.*?),(.*?),/) {\n\t\t$tracepointname = $2;\n\t}\n\t$tracepointname =~ s/^\\s+//; #strip leading whitespace\n\tif ($prototype =~ m/TP_PROTO\\((.*?)\\)/) {\n\t\t$tracepointargs = $1;\n\t}\n\tif (($tracepointname eq 0) || ($tracepointargs eq 0)) {\n\t\temit_warning(\"${file}:$.\", \"Unrecognized tracepoint format: \\n\".\n\t\t\t     \"$prototype\\n\");\n\t} else {\n\t\t$prototype = \"static inline void trace_$tracepointname($tracepointargs)\";\n\t\t$identifier = \"trace_$identifier\";\n\t}\n}\n\nsub syscall_munge() {\n\tmy $void = 0;\n\n\t$prototype =~ s@[\\r\\n]+@ @gos; # strip newlines/CR's\n##\tif ($prototype =~ m/SYSCALL_DEFINE0\\s*\\(\\s*(a-zA-Z0-9_)*\\s*\\)/) {\n\tif ($prototype =~ m/SYSCALL_DEFINE0/) {\n\t\t$void = 1;\n##\t\t$prototype = \"long sys_$1(void)\";\n\t}\n\n\t$prototype =~ s/SYSCALL_DEFINE.*\\(/long sys_/; # fix return type & func name\n\tif ($prototype =~ m/long (sys_.*?),/) {\n\t\t$prototype =~ s/,/\\(/;\n\t} elsif ($void) {\n\t\t$prototype =~ s/\\)/\\(void\\)/;\n\t}\n\n\t# now delete all of the odd-number commas in $prototype\n\t# so that arg types & arg names don't have a comma between them\n\tmy $count = 0;\n\tmy $len = length($prototype);\n\tif ($void) {\n\t\t$len = 0;\t# skip the for-loop\n\t}\n\tfor (my $ix = 0; $ix < $len; $ix++) {\n\t\tif (substr($prototype, $ix, 1) eq ',') {\n\t\t\t$count++;\n\t\t\tif ($count % 2 == 1) {\n\t\t\t\tsubstr($prototype, $ix, 1) = ' ';\n\t\t\t}\n\t\t}\n\t}\n}\n\nsub process_proto_function($$) {\n    my $x = shift;\n    my $file = shift;\n\n    $x =~ s@\\/\\/.*$@@gos; # strip C99-style comments to end of line\n\n    if ($x =~ m#\\s*/\\*\\s+MACDOC\\s*#io || ($x =~ /^#/ && $x !~ /^#\\s*define/)) {\n\t# do nothing\n    }\n    elsif ($x =~ /([^\\{]*)/) {\n\t$prototype .= $1;\n    }\n\n    if (($x =~ /\\{/) || ($x =~ /\\#\\s*define/) || ($x =~ /;/)) {\n\t$prototype =~ s@/\\*.*?\\*/@@gos;\t# strip comments.\n\t$prototype =~ s@[\\r\\n]+@ @gos; # strip newlines/cr's.\n\t$prototype =~ s@^\\s+@@gos; # strip leading spaces\n\n\t # Handle prototypes for function pointers like:\n\t # int (*pcs_config)(struct foo)\n\t$prototype =~ s@^(\\S+\\s+)\\(\\s*\\*(\\S+)\\)@$1$2@gos;\n\n\tif ($prototype =~ /SYSCALL_DEFINE/) {\n\t\tsyscall_munge();\n\t}\n\tif ($prototype =~ /TRACE_EVENT/ || $prototype =~ /DEFINE_EVENT/ ||\n\t    $prototype =~ /DEFINE_SINGLE_EVENT/)\n\t{\n\t\ttracepoint_munge($file);\n\t}\n\tdump_function($prototype, $file);\n\treset_state();\n    }\n}\n\nsub process_proto_type($$) {\n    my $x = shift;\n    my $file = shift;\n\n    $x =~ s@[\\r\\n]+@ @gos; # strip newlines/cr's.\n    $x =~ s@^\\s+@@gos; # strip leading spaces\n    $x =~ s@\\s+$@@gos; # strip trailing spaces\n    $x =~ s@\\/\\/.*$@@gos; # strip C99-style comments to end of line\n\n    if ($x =~ /^#/) {\n\t# To distinguish preprocessor directive from regular declaration later.\n\t$x .= \";\";\n    }\n\n    while (1) {\n\tif ( $x =~ /([^\\{\\};]*)([\\{\\};])(.*)/ ) {\n            if( length $prototype ) {\n                $prototype .= \" \"\n            }\n\t    $prototype .= $1 . $2;\n\t    ($2 eq '{') && $brcount++;\n\t    ($2 eq '}') && $brcount--;\n\t    if (($2 eq ';') && ($brcount == 0)) {\n\t\tdump_declaration($prototype, $file);\n\t\treset_state();\n\t\tlast;\n\t    }\n\t    $x = $3;\n\t} else {\n\t    $prototype .= $x;\n\t    last;\n\t}\n    }\n}\n\n\nsub map_filename($) {\n    my $file;\n    my ($orig_file) = @_;\n\n    if (defined($ENV{'SRCTREE'})) {\n\t$file = \"$ENV{'SRCTREE'}\" . \"/\" . $orig_file;\n    } else {\n\t$file = $orig_file;\n    }\n\n    if (defined($source_map{$file})) {\n\t$file = $source_map{$file};\n    }\n\n    return $file;\n}\n\nsub process_export_file($) {\n    my ($orig_file) = @_;\n    my $file = map_filename($orig_file);\n\n    if (!open(IN,\"<$file\")) {\n\tprint STDERR \"Error: Cannot open file $file\\n\";\n\t++$errors;\n\treturn;\n    }\n\n    while (<IN>) {\n\tif (/$export_symbol/) {\n\t    next if (defined($nosymbol_table{$2}));\n\t    $function_table{$2} = 1;\n\t}\n\tif (/$export_symbol_ns/) {\n\t    next if (defined($nosymbol_table{$2}));\n\t    $function_table{$2} = 1;\n\t}\n    }\n\n    close(IN);\n}\n\n#\n# Parsers for the various processing states.\n#\n# STATE_NORMAL: looking for the /** to begin everything.\n#\nsub process_normal() {\n    if (/$doc_start/o) {\n\t$state = STATE_NAME;\t# next line is always the function name\n\t$in_doc_sect = 0;\n\t$declaration_start_line = $. + 1;\n    }\n}\n\n#\n# STATE_NAME: Looking for the \"name - description\" line\n#\nsub process_name($$) {\n    my $file = shift;\n    my $descr;\n\n    if (/$doc_block/o) {\n\t$state = STATE_DOCBLOCK;\n\t$contents = \"\";\n\t$new_start_line = $.;\n\n\tif ( $1 eq \"\" ) {\n\t    $section = $section_intro;\n\t} else {\n\t    $section = $1;\n\t}\n    } elsif (/$doc_decl/o) {\n\t$identifier = $1;\n\tmy $is_kernel_comment = 0;\n\tmy $decl_start = qr{$doc_com};\n\t# test for pointer declaration type, foo * bar() - desc\n\tmy $fn_type = qr{\\w+\\s*\\*\\s*}; \n\tmy $parenthesis = qr{\\(\\w*\\)};\n\tmy $decl_end = qr{[-:].*};\n\tif (/^$decl_start([\\w\\s]+?)$parenthesis?\\s*$decl_end?$/) {\n\t    $identifier = $1;\n\t}\n\tif ($identifier =~ m/^(struct|union|enum|typedef)\\b\\s*(\\S*)/) {\n\t    $decl_type = $1;\n\t    $identifier = $2;\n\t    $is_kernel_comment = 1;\n\t}\n\t# Look for foo() or static void foo() - description; or misspelt\n\t# identifier\n\telsif (/^$decl_start$fn_type?(\\w+)\\s*$parenthesis?\\s*$decl_end?$/ ||\n\t    /^$decl_start$fn_type?(\\w+.*)$parenthesis?\\s*$decl_end$/) {\n\t    $identifier = $1;\n\t    $decl_type = 'function';\n\t    $identifier =~ s/^define\\s+//;\n\t    $is_kernel_comment = 1;\n\t}\n\t$identifier =~ s/\\s+$//;\n\n\t$state = STATE_BODY;\n\t# if there's no @param blocks need to set up default section\n\t# here\n\t$contents = \"\";\n\t$section = $section_default;\n\t$new_start_line = $. + 1;\n\tif (/[-:](.*)/) {\n\t    # strip leading/trailing/multiple spaces\n\t    $descr= $1;\n\t    $descr =~ s/^\\s*//;\n\t    $descr =~ s/\\s*$//;\n\t    $descr =~ s/\\s+/ /g;\n\t    $declaration_purpose = $descr;\n\t    $state = STATE_BODY_MAYBE;\n\t} else {\n\t    $declaration_purpose = \"\";\n\t}\n\n\tif (!$is_kernel_comment) {\n\t    emit_warning(\"${file}:$.\", \"This comment starts with '/**', but isn't a kernel-doc comment. Refer Documentation/doc-guide/kernel-doc.rst\\n$_\");\n\t    $state = STATE_NORMAL;\n\t}\n\n\tif (($declaration_purpose eq \"\") && $Wshort_desc) {\n\t    emit_warning(\"${file}:$.\", \"missing initial short description on line:\\n$_\");\n\t}\n\n\tif ($identifier eq \"\" && $decl_type ne \"enum\") {\n\t    emit_warning(\"${file}:$.\", \"wrong kernel-doc identifier on line:\\n$_\");\n\t    $state = STATE_NORMAL;\n\t}\n\n\tif ($verbose) {\n\t    print STDERR \"${file}:$.: info: Scanning doc for $decl_type $identifier\\n\";\n\t}\n    } else {\n\temit_warning(\"${file}:$.\", \"Cannot understand $_ on line $. - I thought it was a doc line\\n\");\n\t$state = STATE_NORMAL;\n    }\n}\n\n\n#\n# STATE_BODY and STATE_BODY_MAYBE: the bulk of a kerneldoc comment.\n#\nsub process_body($$) {\n    my $file = shift;\n\n    if ($state == STATE_BODY_WITH_BLANK_LINE && /^\\s*\\*\\s?\\S/) {\n\tdump_section($file, $section, $contents);\n\t$section = $section_default;\n\t$new_start_line = $.;\n\t$contents = \"\";\n    }\n\n    if (/$doc_sect/i) { # case insensitive for supported section names\n\t$newsection = $1;\n\t$newcontents = $2;\n\n\t# map the supported section names to the canonical names\n\tif ($newsection =~ m/^description$/i) {\n\t    $newsection = $section_default;\n\t} elsif ($newsection =~ m/^context$/i) {\n\t    $newsection = $section_context;\n\t} elsif ($newsection =~ m/^returns?$/i) {\n\t    $newsection = $section_return;\n\t} elsif ($newsection =~ m/^\\@return$/) {\n\t    # special: @return is a section, not a param description\n\t    $newsection = $section_return;\n\t}\n\n\tif (($contents ne \"\") && ($contents ne \"\\n\")) {\n\t    if (!$in_doc_sect && $Wcontents_before_sections) {\n\t\temit_warning(\"${file}:$.\", \"contents before sections\\n\");\n\t    }\n\t    dump_section($file, $section, $contents);\n\t    $section = $section_default;\n\t}\n\n\t$in_doc_sect = 1;\n\t$state = STATE_BODY;\n\t$contents = $newcontents;\n\t$new_start_line = $.;\n\twhile (substr($contents, 0, 1) eq \" \") {\n\t    $contents = substr($contents, 1);\n\t}\n\tif ($contents ne \"\") {\n\t    $contents .= \"\\n\";\n\t}\n\t$section = $newsection;\n\t$leading_space = undef;\n    } elsif (/$doc_end/) {\n\tif (($contents ne \"\") && ($contents ne \"\\n\")) {\n\t    dump_section($file, $section, $contents);\n\t    $section = $section_default;\n\t    $contents = \"\";\n\t}\n\t# look for doc_com + <text> + doc_end:\n\tif ($_ =~ m'\\s*\\*\\s*[a-zA-Z_0-9:\\.]+\\*/') {\n\t    emit_warning(\"${file}:$.\", \"suspicious ending line: $_\");\n\t}\n\n\t$prototype = \"\";\n\t$state = STATE_PROTO;\n\t$brcount = 0;\n        $new_start_line = $. + 1;\n    } elsif (/$doc_content/) {\n\tif ($1 eq \"\") {\n\t    if ($section eq $section_context) {\n\t\tdump_section($file, $section, $contents);\n\t\t$section = $section_default;\n\t\t$contents = \"\";\n\t\t$new_start_line = $.;\n\t\t$state = STATE_BODY;\n\t    } else {\n\t\tif ($section ne $section_default) {\n\t\t    $state = STATE_BODY_WITH_BLANK_LINE;\n\t\t} else {\n\t\t    $state = STATE_BODY;\n\t\t}\n\t\t$contents .= \"\\n\";\n\t    }\n\t} elsif ($state == STATE_BODY_MAYBE) {\n\t    # Continued declaration purpose\n\t    chomp($declaration_purpose);\n\t    $declaration_purpose .= \" \" . $1;\n\t    $declaration_purpose =~ s/\\s+/ /g;\n\t} else {\n\t    my $cont = $1;\n\t    if ($section =~ m/^@/ || $section eq $section_context) {\n\t\tif (!defined $leading_space) {\n\t\t    if ($cont =~ m/^(\\s+)/) {\n\t\t\t$leading_space = $1;\n\t\t    } else {\n\t\t\t$leading_space = \"\";\n\t\t    }\n\t\t}\n\t\t$cont =~ s/^$leading_space//;\n\t    }\n\t    $contents .= $cont . \"\\n\";\n\t}\n    } else {\n\t# i dont know - bad line?  ignore.\n\temit_warning(\"${file}:$.\", \"bad line: $_\");\n    }\n}\n\n\n#\n# STATE_PROTO: reading a function/whatever prototype.\n#\nsub process_proto($$) {\n    my $file = shift;\n\n    if (/$doc_inline_oneline/) {\n\t$section = $1;\n\t$contents = $2;\n\tif ($contents ne \"\") {\n\t    $contents .= \"\\n\";\n\t    dump_section($file, $section, $contents);\n\t    $section = $section_default;\n\t    $contents = \"\";\n\t}\n    } elsif (/$doc_inline_start/) {\n\t$state = STATE_INLINE;\n\t$inline_doc_state = STATE_INLINE_NAME;\n    } elsif ($decl_type eq 'function') {\n\tprocess_proto_function($_, $file);\n    } else {\n\tprocess_proto_type($_, $file);\n    }\n}\n\n#\n# STATE_DOCBLOCK: within a DOC: block.\n#\nsub process_docblock($$) {\n    my $file = shift;\n\n    if (/$doc_end/) {\n\tdump_doc_section($file, $section, $contents);\n\t$section = $section_default;\n\t$contents = \"\";\n\t$function = \"\";\n\t%parameterdescs = ();\n\t%parametertypes = ();\n\t@parameterlist = ();\n\t%sections = ();\n\t@sectionlist = ();\n\t$prototype = \"\";\n\t$state = STATE_NORMAL;\n    } elsif (/$doc_content/) {\n\tif ( $1 eq \"\" )\t{\n\t    $contents .= $blankline;\n\t} else {\n\t    $contents .= $1 . \"\\n\";\n\t}\n    }\n}\n\n#\n# STATE_INLINE: docbook comments within a prototype.\n#\nsub process_inline($$) {\n    my $file = shift;\n\n    # First line (state 1) needs to be a @parameter\n    if ($inline_doc_state == STATE_INLINE_NAME && /$doc_inline_sect/o) {\n\t$section = $1;\n\t$contents = $2;\n\t$new_start_line = $.;\n\tif ($contents ne \"\") {\n\t    while (substr($contents, 0, 1) eq \" \") {\n\t\t$contents = substr($contents, 1);\n\t    }\n\t    $contents .= \"\\n\";\n\t}\n\t$inline_doc_state = STATE_INLINE_TEXT;\n\t# Documentation block end */\n    } elsif (/$doc_inline_end/) {\n\tif (($contents ne \"\") && ($contents ne \"\\n\")) {\n\t    dump_section($file, $section, $contents);\n\t    $section = $section_default;\n\t    $contents = \"\";\n\t}\n\t$state = STATE_PROTO;\n\t$inline_doc_state = STATE_INLINE_NA;\n\t# Regular text\n    } elsif (/$doc_content/) {\n\tif ($inline_doc_state == STATE_INLINE_TEXT) {\n\t    $contents .= $1 . \"\\n\";\n\t    # nuke leading blank lines\n\t    if ($contents =~ /^\\s*$/) {\n\t\t$contents = \"\";\n\t    }\n\t} elsif ($inline_doc_state == STATE_INLINE_NAME) {\n\t    $inline_doc_state = STATE_INLINE_ERROR;\n\t    emit_warning(\"${file}:$.\", \"Incorrect use of kernel-doc format: $_\");\n\t}\n    }\n}\n\n\nsub process_file($) {\n    my $file;\n    my $initial_section_counter = $section_counter;\n    my ($orig_file) = @_;\n\n    $file = map_filename($orig_file);\n\n    if (!open(IN_FILE,\"<$file\")) {\n\tprint STDERR \"Error: Cannot open file $file\\n\";\n\t++$errors;\n\treturn;\n    }\n\n    $. = 1;\n\n    $section_counter = 0;\n    while (<IN_FILE>) {\n\twhile (s/\\\\\\s*$//) {\n\t    $_ .= <IN_FILE>;\n\t}\n\t# Replace tabs by spaces\n        while ($_ =~ s/\\t+/' ' x (length($&) * 8 - length($`) % 8)/e) {};\n\t# Hand this line to the appropriate state handler\n\tif ($state == STATE_NORMAL) {\n\t    process_normal();\n\t} elsif ($state == STATE_NAME) {\n\t    process_name($file, $_);\n\t} elsif ($state == STATE_BODY || $state == STATE_BODY_MAYBE ||\n\t\t $state == STATE_BODY_WITH_BLANK_LINE) {\n\t    process_body($file, $_);\n\t} elsif ($state == STATE_INLINE) { # scanning for inline parameters\n\t    process_inline($file, $_);\n\t} elsif ($state == STATE_PROTO) {\n\t    process_proto($file, $_);\n\t} elsif ($state == STATE_DOCBLOCK) {\n\t    process_docblock($file, $_);\n\t}\n    }\n\n    # Make sure we got something interesting.\n    if ($initial_section_counter == $section_counter && $\n\toutput_mode ne \"none\") {\n\tif ($output_selection == OUTPUT_INCLUDE) {\n\t    emit_warning(\"${file}:1\", \"'$_' not found\\n\")\n\t\tfor keys %function_table;\n\t}\n\telse {\n\t    emit_warning(\"${file}:1\", \"no structured comments found\\n\");\n\t}\n    }\n    close IN_FILE;\n}\n\n\nif ($output_mode eq \"rst\") {\n\tget_sphinx_version() if (!$sphinx_major);\n}\n\n$kernelversion = get_kernel_version();\n\n# generate a sequence of code that will splice in highlighting information\n# using the s// operator.\nfor (my $k = 0; $k < @highlights; $k++) {\n    my $pattern = $highlights[$k][0];\n    my $result = $highlights[$k][1];\n#   print STDERR \"scanning pattern:$pattern, highlight:($result)\\n\";\n    $dohighlight .=  \"\\$contents =~ s:$pattern:$result:gs;\\n\";\n}\n\n# Read the file that maps relative names to absolute names for\n# separate source and object directories and for shadow trees.\nif (open(SOURCE_MAP, \"<.tmp_filelist.txt\")) {\n\tmy ($relname, $absname);\n\twhile(<SOURCE_MAP>) {\n\t\tchop();\n\t\t($relname, $absname) = (split())[0..1];\n\t\t$relname =~ s:^/+::;\n\t\t$source_map{$relname} = $absname;\n\t}\n\tclose(SOURCE_MAP);\n}\n\nif ($output_selection == OUTPUT_EXPORTED ||\n    $output_selection == OUTPUT_INTERNAL) {\n\n    push(@export_file_list, @ARGV);\n\n    foreach (@export_file_list) {\n\tchomp;\n\tprocess_export_file($_);\n    }\n}\n\nforeach (@ARGV) {\n    chomp;\n    process_file($_);\n}\nif ($verbose && $errors) {\n  print STDERR \"$errors errors\\n\";\n}\nif ($verbose && $warnings) {\n  print STDERR \"$warnings warnings\\n\";\n}\n\nif ($Werror && $warnings) {\n    print STDERR \"$warnings warnings as Errors\\n\";\n    exit($warnings);\n} else {\n    exit($output_mode eq \"none\" ? 0 : $errors)\n}\n\n__END__\n\n=head1 OPTIONS\n\n=head2 Output format selection (mutually exclusive):\n\n=over 8\n\n=item -man\n\nOutput troff manual page format.\n\n=item -rst\n\nOutput reStructuredText format. This is the default.\n\n=item -none\n\nDo not output documentation, only warnings.\n\n=back\n\n=head2 Output format modifiers\n\n=head3 reStructuredText only\n\n=over 8\n\n=item -sphinx-version VERSION\n\nUse the ReST C domain dialect compatible with a specific Sphinx Version.\n\nIf not specified, kernel-doc will auto-detect using the sphinx-build version\nfound on PATH.\n\n=back\n\n=head2 Output selection (mutually exclusive):\n\n=over 8\n\n=item -export\n\nOnly output documentation for the symbols that have been exported using\nEXPORT_SYMBOL() and related macros in any input FILE or -export-file FILE.\n\n=item -internal\n\nOnly output documentation for the symbols that have NOT been exported using\nEXPORT_SYMBOL() and related macros in any input FILE or -export-file FILE.\n\n=item -function NAME\n\nOnly output documentation for the given function or DOC: section title.\nAll other functions and DOC: sections are ignored.\n\nMay be specified multiple times.\n\n=item -nosymbol NAME\n\nExclude the specified symbol from the output documentation.\n\nMay be specified multiple times.\n\n=back\n\n=head2 Output selection modifiers:\n\n=over 8\n\n=item -no-doc-sections\n\nDo not output DOC: sections.\n\n=item -export-file FILE\n\nSpecify an additional FILE in which to look for EXPORT_SYMBOL information.\n\nTo be used with -export or -internal.\n\nMay be specified multiple times.\n\n=back\n\n=head3 reStructuredText only\n\n=over 8\n\n=item -enable-lineno\n\nEnable output of .. LINENO lines.\n\n=back\n\n=head2 Other parameters:\n\n=over 8\n\n=item -h, -help\n\nPrint this help.\n\n=item -v\n\nVerbose output, more warnings and other information.\n\n=item -Werror\n\nTreat warnings as errors.\n\n=back\n\n=cut\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}