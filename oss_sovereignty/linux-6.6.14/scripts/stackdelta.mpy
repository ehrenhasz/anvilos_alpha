{
  "module_name": "stackdelta",
  "hash_id": "847ea973c362779682b419895043e08fccbd1d0a8a30bf64ed46e0bbd92944c3",
  "original_prompt": "Ingested from linux-6.6.14/scripts/stackdelta",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n\n# Read two files produced by the stackusage script, and show the\n# delta between them.\n#\n# Currently, only shows changes for functions listed in both files. We\n# could add an option to show also functions which have vanished or\n# appeared (which would often be due to gcc making other inlining\n# decisions).\n#\n# Another possible option would be a minimum absolute value for the\n# delta.\n#\n# A third possibility is for sorting by delta, but that can be\n# achieved by piping to sort -k5,5g.\n\nsub read_stack_usage_file {\n    my %su;\n    my $f = shift;\n    open(my $fh, '<', $f)\n\tor die \"cannot open $f: $!\";\n    while (<$fh>) {\n\tchomp;\n\tmy ($file, $func, $size, $type) = split;\n\t# Old versions of gcc (at least 4.7) have an annoying quirk in\n\t# that a (static) function whose name has been changed into\n\t# for example ext4_find_unwritten_pgoff.isra.11 will show up\n\t# in the .su file with a name of just \"11\". Since such a\n\t# numeric suffix is likely to change across different\n\t# commits/compilers/.configs or whatever else we're trying to\n\t# tweak, we can't really track those functions, so we just\n\t# silently skip them.\n\t#\n\t# Newer gcc (at least 5.0) report the full name, so again,\n\t# since the suffix is likely to change, we strip it.\n\tnext if $func =~ m/^[0-9]+$/;\n\t$func =~ s/\\..*$//;\n\t# Line numbers are likely to change; strip those.\n\t$file =~ s/:[0-9]+$//;\n\t$su{\"${file}\\t${func}\"} = {size => $size, type => $type};\n    }\n    close($fh);\n    return \\%su;\n}\n\n@ARGV == 2\n    or die \"usage: $0 <old> <new>\";\n\nmy $old = read_stack_usage_file($ARGV[0]);\nmy $new = read_stack_usage_file($ARGV[1]);\nmy @common = sort grep {exists $new->{$_}} keys %$old;\nfor (@common) {\n    my $x = $old->{$_}{size};\n    my $y = $new->{$_}{size};\n    my $delta = $y - $x;\n    if ($delta) {\n\tprintf \"%s\\t%d\\t%d\\t%+d\\n\", $_, $x, $y, $delta;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}