{
  "module_name": "run-clang-tools.py",
  "hash_id": "67bced60d154cc24cf544ab935a776011aa61f71f80b16237075568379151eed",
  "original_prompt": "Ingested from linux-6.6.14/scripts/clang-tools/run-clang-tools.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright (C) Google LLC, 2020\n#\n# Author: Nathan Huckleberry <nhuck@google.com>\n#\n\"\"\"A helper routine run clang-tidy and the clang static-analyzer on\ncompile_commands.json.\n\"\"\"\n\nimport argparse\nimport json\nimport multiprocessing\nimport subprocess\nimport sys\n\n\ndef parse_arguments():\n    \"\"\"Set up and parses command-line arguments.\n    Returns:\n        args: Dict of parsed args\n        Has keys: [path, type]\n    \"\"\"\n    usage = \"\"\"Run clang-tidy or the clang static-analyzer on a\n        compilation database.\"\"\"\n    parser = argparse.ArgumentParser(description=usage)\n\n    type_help = \"Type of analysis to be performed\"\n    parser.add_argument(\"type\",\n                        choices=[\"clang-tidy\", \"clang-analyzer\"],\n                        help=type_help)\n    path_help = \"Path to the compilation database to parse\"\n    parser.add_argument(\"path\", type=str, help=path_help)\n\n    return parser.parse_args()\n\n\ndef init(l, a):\n    global lock\n    global args\n    lock = l\n    args = a\n\n\ndef run_analysis(entry):\n    # Disable all checks, then re-enable the ones we want\n    checks = []\n    checks.append(\"-checks=-*\")\n    if args.type == \"clang-tidy\":\n        checks.append(\"linuxkernel-*\")\n    else:\n        checks.append(\"clang-analyzer-*\")\n        checks.append(\"-clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling\")\n    p = subprocess.run([\"clang-tidy\", \"-p\", args.path, \",\".join(checks), entry[\"file\"]],\n                       stdout=subprocess.PIPE,\n                       stderr=subprocess.STDOUT,\n                       cwd=entry[\"directory\"])\n    with lock:\n        sys.stderr.buffer.write(p.stdout)\n\n\ndef main():\n    try:\n        args = parse_arguments()\n\n        lock = multiprocessing.Lock()\n        pool = multiprocessing.Pool(initializer=init, initargs=(lock, args))\n        # Read JSON data into the datastore variable\n        with open(args.path, \"r\") as f:\n            datastore = json.load(f)\n            pool.map(run_analysis, datastore)\n    except BrokenPipeError:\n        # Python flushes standard streams on exit; redirect remaining output\n        # to devnull to avoid another BrokenPipeError at shutdown\n        devnull = os.open(os.devnull, os.O_WRONLY)\n        os.dup2(devnull, sys.stdout.fileno())\n        sys.exit(1)  # Python exits with error code 1 on EPIPE\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}