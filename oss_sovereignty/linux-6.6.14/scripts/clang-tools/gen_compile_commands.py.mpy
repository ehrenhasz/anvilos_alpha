{
  "module_name": "gen_compile_commands.py",
  "hash_id": "40b213ea4f582b1c12363a648b7361605cae97397a1bae203a58626404aa38f8",
  "original_prompt": "Ingested from linux-6.6.14/scripts/clang-tools/gen_compile_commands.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright (C) Google LLC, 2018\n#\n# Author: Tom Roeder <tmroeder@google.com>\n#\n\"\"\"A tool for generating compile_commands.json in the Linux kernel.\"\"\"\n\nimport argparse\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport sys\n\n_DEFAULT_OUTPUT = 'compile_commands.json'\n_DEFAULT_LOG_LEVEL = 'WARNING'\n\n_FILENAME_PATTERN = r'^\\..*\\.cmd$'\n_LINE_PATTERN = r'^savedcmd_[^ ]*\\.o := (.* )([^ ]*\\.[cS]) *(;|$)'\n_VALID_LOG_LEVELS = ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']\n# The tools/ directory adopts a different build system, and produces .cmd\n# files in a different format. Do not support it.\n_EXCLUDE_DIRS = ['.git', 'Documentation', 'include', 'tools']\n\ndef parse_arguments():\n    \"\"\"Sets up and parses command-line arguments.\n\n    Returns:\n        log_level: A logging level to filter log output.\n        directory: The work directory where the objects were built.\n        ar: Command used for parsing .a archives.\n        output: Where to write the compile-commands JSON file.\n        paths: The list of files/directories to handle to find .cmd files.\n    \"\"\"\n    usage = 'Creates a compile_commands.json database from kernel .cmd files'\n    parser = argparse.ArgumentParser(description=usage)\n\n    directory_help = ('specify the output directory used for the kernel build '\n                      '(defaults to the working directory)')\n    parser.add_argument('-d', '--directory', type=str, default='.',\n                        help=directory_help)\n\n    output_help = ('path to the output command database (defaults to ' +\n                   _DEFAULT_OUTPUT + ')')\n    parser.add_argument('-o', '--output', type=str, default=_DEFAULT_OUTPUT,\n                        help=output_help)\n\n    log_level_help = ('the level of log messages to produce (defaults to ' +\n                      _DEFAULT_LOG_LEVEL + ')')\n    parser.add_argument('--log_level', choices=_VALID_LOG_LEVELS,\n                        default=_DEFAULT_LOG_LEVEL, help=log_level_help)\n\n    ar_help = 'command used for parsing .a archives'\n    parser.add_argument('-a', '--ar', type=str, default='llvm-ar', help=ar_help)\n\n    paths_help = ('directories to search or files to parse '\n                  '(files should be *.o, *.a, or modules.order). '\n                  'If nothing is specified, the current directory is searched')\n    parser.add_argument('paths', type=str, nargs='*', help=paths_help)\n\n    args = parser.parse_args()\n\n    return (args.log_level,\n            os.path.abspath(args.directory),\n            args.output,\n            args.ar,\n            args.paths if len(args.paths) > 0 else [args.directory])\n\n\ndef cmdfiles_in_dir(directory):\n    \"\"\"Generate the iterator of .cmd files found under the directory.\n\n    Walk under the given directory, and yield every .cmd file found.\n\n    Args:\n        directory: The directory to search for .cmd files.\n\n    Yields:\n        The path to a .cmd file.\n    \"\"\"\n\n    filename_matcher = re.compile(_FILENAME_PATTERN)\n    exclude_dirs = [ os.path.join(directory, d) for d in _EXCLUDE_DIRS ]\n\n    for dirpath, dirnames, filenames in os.walk(directory, topdown=True):\n        # Prune unwanted directories.\n        if dirpath in exclude_dirs:\n            dirnames[:] = []\n            continue\n\n        for filename in filenames:\n            if filename_matcher.match(filename):\n                yield os.path.join(dirpath, filename)\n\n\ndef to_cmdfile(path):\n    \"\"\"Return the path of .cmd file used for the given build artifact\n\n    Args:\n        Path: file path\n\n    Returns:\n        The path to .cmd file\n    \"\"\"\n    dir, base = os.path.split(path)\n    return os.path.join(dir, '.' + base + '.cmd')\n\n\ndef cmdfiles_for_a(archive, ar):\n    \"\"\"Generate the iterator of .cmd files associated with the archive.\n\n    Parse the given archive, and yield every .cmd file used to build it.\n\n    Args:\n        archive: The archive to parse\n\n    Yields:\n        The path to every .cmd file found\n    \"\"\"\n    for obj in subprocess.check_output([ar, '-t', archive]).decode().split():\n        yield to_cmdfile(obj)\n\n\ndef cmdfiles_for_modorder(modorder):\n    \"\"\"Generate the iterator of .cmd files associated with the modules.order.\n\n    Parse the given modules.order, and yield every .cmd file used to build the\n    contained modules.\n\n    Args:\n        modorder: The modules.order file to parse\n\n    Yields:\n        The path to every .cmd file found\n    \"\"\"\n    with open(modorder) as f:\n        for line in f:\n            obj = line.rstrip()\n            base, ext = os.path.splitext(obj)\n            if ext != '.o':\n                sys.exit('{}: module path must end with .o'.format(obj))\n            mod = base + '.mod'\n            # Read from *.mod, to get a list of objects that compose the module.\n            with open(mod) as m:\n                for mod_line in m:\n                    yield to_cmdfile(mod_line.rstrip())\n\n\ndef process_line(root_directory, command_prefix, file_path):\n    \"\"\"Extracts information from a .cmd line and creates an entry from it.\n\n    Args:\n        root_directory: The directory that was searched for .cmd files. Usually\n            used directly in the \"directory\" entry in compile_commands.json.\n        command_prefix: The extracted command line, up to the last element.\n        file_path: The .c file from the end of the extracted command.\n            Usually relative to root_directory, but sometimes absolute.\n\n    Returns:\n        An entry to append to compile_commands.\n\n    Raises:\n        ValueError: Could not find the extracted file based on file_path and\n            root_directory or file_directory.\n    \"\"\"\n    # The .cmd files are intended to be included directly by Make, so they\n    # escape the pound sign '#', either as '\\#' or '$(pound)' (depending on the\n    # kernel version). The compile_commands.json file is not interepreted\n    # by Make, so this code replaces the escaped version with '#'.\n    prefix = command_prefix.replace('\\#', '#').replace('$(pound)', '#')\n\n    # Use os.path.abspath() to normalize the path resolving '.' and '..' .\n    abs_path = os.path.abspath(os.path.join(root_directory, file_path))\n    if not os.path.exists(abs_path):\n        raise ValueError('File %s not found' % abs_path)\n    return {\n        'directory': root_directory,\n        'file': abs_path,\n        'command': prefix + file_path,\n    }\n\n\ndef main():\n    \"\"\"Walks through the directory and finds and parses .cmd files.\"\"\"\n    log_level, directory, output, ar, paths = parse_arguments()\n\n    level = getattr(logging, log_level)\n    logging.basicConfig(format='%(levelname)s: %(message)s', level=level)\n\n    line_matcher = re.compile(_LINE_PATTERN)\n\n    compile_commands = []\n\n    for path in paths:\n        # If 'path' is a directory, handle all .cmd files under it.\n        # Otherwise, handle .cmd files associated with the file.\n        # built-in objects are linked via vmlinux.a\n        # Modules are listed in modules.order.\n        if os.path.isdir(path):\n            cmdfiles = cmdfiles_in_dir(path)\n        elif path.endswith('.a'):\n            cmdfiles = cmdfiles_for_a(path, ar)\n        elif path.endswith('modules.order'):\n            cmdfiles = cmdfiles_for_modorder(path)\n        else:\n            sys.exit('{}: unknown file type'.format(path))\n\n        for cmdfile in cmdfiles:\n            with open(cmdfile, 'rt') as f:\n                result = line_matcher.match(f.readline())\n                if result:\n                    try:\n                        entry = process_line(directory, result.group(1),\n                                             result.group(2))\n                        compile_commands.append(entry)\n                    except ValueError as err:\n                        logging.info('Could not add line from %s: %s',\n                                     cmdfile, err)\n\n    with open(output, 'wt') as f:\n        json.dump(compile_commands, f, indent=2, sort_keys=True)\n\n\nif __name__ == '__main__':\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}