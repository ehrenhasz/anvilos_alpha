{
  "module_name": "dtc.h",
  "hash_id": "20a41b8c993b362d456a77fbaa8007eced7bfbe4625ef274b150c47659cacf34",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/dtc.h",
  "human_readable_source": " \n#ifndef DTC_H\n#define DTC_H\n\n \n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <unistd.h>\n#include <inttypes.h>\n\n#include <libfdt_env.h>\n#include <fdt.h>\n\n#include \"util.h\"\n\n#ifdef DEBUG\n#define debug(...)\tprintf(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#define DEFAULT_FDT_VERSION\t17\n\n \nextern int quiet;\t\t \nextern unsigned int reservenum;\t \nextern int minsize;\t\t \nextern int padsize;\t\t \nextern int alignsize;\t\t \nextern int phandle_format;\t \nextern int generate_symbols;\t \nextern int generate_fixups;\t \nextern int auto_label_aliases;\t \nextern int annotate;\t\t \n\n#define PHANDLE_LEGACY\t0x1\n#define PHANDLE_EPAPR\t0x2\n#define PHANDLE_BOTH\t0x3\n\ntypedef uint32_t cell_t;\n\nstatic inline bool phandle_is_valid(cell_t phandle)\n{\n\treturn phandle != 0 && phandle != ~0U;\n}\n\nstatic inline uint16_t dtb_ld16(const void *p)\n{\n\tconst uint8_t *bp = (const uint8_t *)p;\n\n\treturn ((uint16_t)bp[0] << 8)\n\t\t| bp[1];\n}\n\nstatic inline uint32_t dtb_ld32(const void *p)\n{\n\tconst uint8_t *bp = (const uint8_t *)p;\n\n\treturn ((uint32_t)bp[0] << 24)\n\t\t| ((uint32_t)bp[1] << 16)\n\t\t| ((uint32_t)bp[2] << 8)\n\t\t| bp[3];\n}\n\nstatic inline uint64_t dtb_ld64(const void *p)\n{\n\tconst uint8_t *bp = (const uint8_t *)p;\n\n\treturn ((uint64_t)bp[0] << 56)\n\t\t| ((uint64_t)bp[1] << 48)\n\t\t| ((uint64_t)bp[2] << 40)\n\t\t| ((uint64_t)bp[3] << 32)\n\t\t| ((uint64_t)bp[4] << 24)\n\t\t| ((uint64_t)bp[5] << 16)\n\t\t| ((uint64_t)bp[6] << 8)\n\t\t| bp[7];\n}\n\n#define streq(a, b)\t(strcmp((a), (b)) == 0)\n#define strstarts(s, prefix)\t(strncmp((s), (prefix), strlen(prefix)) == 0)\n#define strprefixeq(a, n, b)\t(strlen(b) == (n) && (memcmp(a, b, n) == 0))\nstatic inline bool strends(const char *str, const char *suffix)\n{\n\tunsigned int len, suffix_len;\n\n\tlen = strlen(str);\n\tsuffix_len = strlen(suffix);\n\tif (len < suffix_len)\n\t\treturn false;\n\treturn streq(str + len - suffix_len, suffix);\n}\n\n#define ALIGN(x, a)\t(((x) + (a) - 1) & ~((a) - 1))\n\n \nenum markertype {\n\tTYPE_NONE,\n\tREF_PHANDLE,\n\tREF_PATH,\n\tLABEL,\n\tTYPE_UINT8,\n\tTYPE_UINT16,\n\tTYPE_UINT32,\n\tTYPE_UINT64,\n\tTYPE_STRING,\n};\n\nstatic inline bool is_type_marker(enum markertype type)\n{\n\treturn type >= TYPE_UINT8;\n}\n\nextern const char *markername(enum markertype markertype);\n\nstruct  marker {\n\tenum markertype type;\n\tunsigned int offset;\n\tchar *ref;\n\tstruct marker *next;\n};\n\nstruct data {\n\tunsigned int len;\n\tchar *val;\n\tstruct marker *markers;\n};\n\n\n#define empty_data ((struct data){ 0   })\n\n#define for_each_marker(m) \\\n\tfor (; (m); (m) = (m)->next)\n#define for_each_marker_of_type(m, t) \\\n\tfor_each_marker(m) \\\n\t\tif ((m)->type == (t))\n\nstatic inline struct marker *next_type_marker(struct marker *m)\n{\n\tfor_each_marker(m)\n\t\tif (is_type_marker(m->type))\n\t\t\tbreak;\n\treturn m;\n}\n\nstatic inline size_t type_marker_length(struct marker *m)\n{\n\tstruct marker *next = next_type_marker(m->next);\n\n\tif (next)\n\t\treturn next->offset - m->offset;\n\treturn 0;\n}\n\nvoid data_free(struct data d);\n\nstruct data data_grow_for(struct data d, unsigned int xlen);\n\nstruct data data_copy_mem(const char *mem, int len);\nstruct data data_copy_escape_string(const char *s, int len);\nstruct data data_copy_file(FILE *f, size_t len);\n\nstruct data data_append_data(struct data d, const void *p, int len);\nstruct data data_insert_at_marker(struct data d, struct marker *m,\n\t\t\t\t  const void *p, int len);\nstruct data data_merge(struct data d1, struct data d2);\nstruct data data_append_cell(struct data d, cell_t word);\nstruct data data_append_integer(struct data d, uint64_t word, int bits);\nstruct data data_append_re(struct data d, uint64_t address, uint64_t size);\nstruct data data_append_addr(struct data d, uint64_t addr);\nstruct data data_append_byte(struct data d, uint8_t byte);\nstruct data data_append_zeroes(struct data d, int len);\nstruct data data_append_align(struct data d, int align);\n\nstruct data data_add_marker(struct data d, enum markertype type, char *ref);\n\nbool data_is_one_string(struct data d);\n\n \n\n#define MAX_PROPNAME_LEN\t31\n#define MAX_NODENAME_LEN\t31\n\n \nstruct label {\n\tbool deleted;\n\tchar *label;\n\tstruct label *next;\n};\n\nstruct bus_type {\n\tconst char *name;\n};\n\nstruct property {\n\tbool deleted;\n\tchar *name;\n\tstruct data val;\n\n\tstruct property *next;\n\n\tstruct label *labels;\n\tstruct srcpos *srcpos;\n};\n\nstruct node {\n\tbool deleted;\n\tchar *name;\n\tstruct property *proplist;\n\tstruct node *children;\n\n\tstruct node *parent;\n\tstruct node *next_sibling;\n\n\tchar *fullpath;\n\tint basenamelen;\n\n\tcell_t phandle;\n\tint addr_cells, size_cells;\n\n\tstruct label *labels;\n\tconst struct bus_type *bus;\n\tstruct srcpos *srcpos;\n\n\tbool omit_if_unused, is_referenced;\n};\n\n#define for_each_label_withdel(l0, l) \\\n\tfor ((l) = (l0); (l); (l) = (l)->next)\n\n#define for_each_label(l0, l) \\\n\tfor_each_label_withdel(l0, l) \\\n\t\tif (!(l)->deleted)\n\n#define for_each_property_withdel(n, p) \\\n\tfor ((p) = (n)->proplist; (p); (p) = (p)->next)\n\n#define for_each_property(n, p) \\\n\tfor_each_property_withdel(n, p) \\\n\t\tif (!(p)->deleted)\n\n#define for_each_child_withdel(n, c) \\\n\tfor ((c) = (n)->children; (c); (c) = (c)->next_sibling)\n\n#define for_each_child(n, c) \\\n\tfor_each_child_withdel(n, c) \\\n\t\tif (!(c)->deleted)\n\nvoid add_label(struct label **labels, char *label);\nvoid delete_labels(struct label **labels);\n\nstruct property *build_property(char *name, struct data val,\n\t\t\t\tstruct srcpos *srcpos);\nstruct property *build_property_delete(char *name);\nstruct property *chain_property(struct property *first, struct property *list);\nstruct property *reverse_properties(struct property *first);\n\nstruct node *build_node(struct property *proplist, struct node *children,\n\t\t\tstruct srcpos *srcpos);\nstruct node *build_node_delete(struct srcpos *srcpos);\nstruct node *name_node(struct node *node, char *name);\nstruct node *omit_node_if_unused(struct node *node);\nstruct node *reference_node(struct node *node);\nstruct node *chain_node(struct node *first, struct node *list);\nstruct node *merge_nodes(struct node *old_node, struct node *new_node);\nstruct node *add_orphan_node(struct node *old_node, struct node *new_node, char *ref);\n\nvoid add_property(struct node *node, struct property *prop);\nvoid delete_property_by_name(struct node *node, char *name);\nvoid delete_property(struct property *prop);\nvoid add_child(struct node *parent, struct node *child);\nvoid delete_node_by_name(struct node *parent, char *name);\nvoid delete_node(struct node *node);\nvoid append_to_property(struct node *node,\n\t\t\tchar *name, const void *data, int len,\n\t\t\tenum markertype type);\n\nconst char *get_unitname(struct node *node);\nstruct property *get_property(struct node *node, const char *propname);\ncell_t propval_cell(struct property *prop);\ncell_t propval_cell_n(struct property *prop, unsigned int n);\nstruct property *get_property_by_label(struct node *tree, const char *label,\n\t\t\t\t       struct node **node);\nstruct marker *get_marker_label(struct node *tree, const char *label,\n\t\t\t\tstruct node **node, struct property **prop);\nstruct node *get_subnode(struct node *node, const char *nodename);\nstruct node *get_node_by_path(struct node *tree, const char *path);\nstruct node *get_node_by_label(struct node *tree, const char *label);\nstruct node *get_node_by_phandle(struct node *tree, cell_t phandle);\nstruct node *get_node_by_ref(struct node *tree, const char *ref);\ncell_t get_node_phandle(struct node *root, struct node *node);\n\nuint32_t guess_boot_cpuid(struct node *tree);\n\n \n\nstruct reserve_info {\n\tuint64_t address, size;\n\n\tstruct reserve_info *next;\n\n\tstruct label *labels;\n};\n\nstruct reserve_info *build_reserve_entry(uint64_t start, uint64_t len);\nstruct reserve_info *chain_reserve_entry(struct reserve_info *first,\n\t\t\t\t\t struct reserve_info *list);\nstruct reserve_info *add_reserve_entry(struct reserve_info *list,\n\t\t\t\t       struct reserve_info *new);\n\n\nstruct dt_info {\n\tunsigned int dtsflags;\n\tstruct reserve_info *reservelist;\n\tuint32_t boot_cpuid_phys;\n\tstruct node *dt;\t\t \n\tconst char *outname;\t\t \n};\n\n \n#define DTSF_V1\t\t0x0001\t \n#define DTSF_PLUGIN\t0x0002\t \n\nstruct dt_info *build_dt_info(unsigned int dtsflags,\n\t\t\t      struct reserve_info *reservelist,\n\t\t\t      struct node *tree, uint32_t boot_cpuid_phys);\nvoid sort_tree(struct dt_info *dti);\nvoid generate_label_tree(struct dt_info *dti, char *name, bool allocph);\nvoid generate_fixups_tree(struct dt_info *dti, char *name);\nvoid generate_local_fixups_tree(struct dt_info *dti, char *name);\n\n \n\nvoid parse_checks_option(bool warn, bool error, const char *arg);\nvoid process_checks(bool force, struct dt_info *dti);\n\n \n\nvoid dt_to_blob(FILE *f, struct dt_info *dti, int version);\nvoid dt_to_asm(FILE *f, struct dt_info *dti, int version);\n\nstruct dt_info *dt_from_blob(const char *fname);\n\n \n\nvoid dt_to_source(FILE *f, struct dt_info *dti);\nstruct dt_info *dt_from_source(const char *f);\n\n \n\nvoid dt_to_yaml(FILE *f, struct dt_info *dti);\n\n \n\nstruct dt_info *dt_from_fs(const char *dirname);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}