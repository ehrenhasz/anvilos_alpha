{
  "module_name": "util.c",
  "hash_id": "34e00e9e760027b2a2727e95a653222c1b657cf04ee4f55d573001a6546e9131",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/util.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <assert.h>\n#include <inttypes.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"libfdt.h\"\n#include \"util.h\"\n#include \"version_gen.h\"\n\nchar *xstrdup(const char *s)\n{\n\tint len = strlen(s) + 1;\n\tchar *d = xmalloc(len);\n\n\tmemcpy(d, s, len);\n\n\treturn d;\n}\n\nchar *xstrndup(const char *s, size_t n)\n{\n\tsize_t len = strnlen(s, n) + 1;\n\tchar *d = xmalloc(len);\n\n\tmemcpy(d, s, len - 1);\n\td[len - 1] = '\\0';\n\n\treturn d;\n}\n\nint xavsprintf_append(char **strp, const char *fmt, va_list ap)\n{\n\tint n, size = 0;\t \n\tchar *p;\n\tva_list ap_copy;\n\n\tp = *strp;\n\tif (p)\n\t\tsize = strlen(p);\n\n\tva_copy(ap_copy, ap);\n\tn = vsnprintf(NULL, 0, fmt, ap_copy) + 1;\n\tva_end(ap_copy);\n\n\tp = xrealloc(p, size + n);\n\n\tn = vsnprintf(p + size, n, fmt, ap);\n\n\t*strp = p;\n\treturn strlen(p);\n}\n\nint xasprintf_append(char **strp, const char *fmt, ...)\n{\n\tint n;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tn = xavsprintf_append(strp, fmt, ap);\n\tva_end(ap);\n\n\treturn n;\n}\n\nint xasprintf(char **strp, const char *fmt, ...)\n{\n\tint n;\n\tva_list ap;\n\n\t*strp = NULL;\n\n\tva_start(ap, fmt);\n\tn = xavsprintf_append(strp, fmt, ap);\n\tva_end(ap);\n\n\treturn n;\n}\n\nchar *join_path(const char *path, const char *name)\n{\n\tint lenp = strlen(path);\n\tint lenn = strlen(name);\n\tint len;\n\tint needslash = 1;\n\tchar *str;\n\n\tlen = lenp + lenn + 2;\n\tif ((lenp > 0) && (path[lenp-1] == '/')) {\n\t\tneedslash = 0;\n\t\tlen--;\n\t}\n\n\tstr = xmalloc(len);\n\tmemcpy(str, path, lenp);\n\tif (needslash) {\n\t\tstr[lenp] = '/';\n\t\tlenp++;\n\t}\n\tmemcpy(str+lenp, name, lenn+1);\n\treturn str;\n}\n\nbool util_is_printable_string(const void *data, int len)\n{\n\tconst char *s = data;\n\tconst char *ss, *se;\n\n\t \n\tif (len == 0)\n\t\treturn 0;\n\n\t \n\tif (s[len - 1] != '\\0')\n\t\treturn 0;\n\n\tse = s + len;\n\n\twhile (s < se) {\n\t\tss = s;\n\t\twhile (s < se && *s && isprint((unsigned char)*s))\n\t\t\ts++;\n\n\t\t \n\t\tif (*s != '\\0' || s == ss)\n\t\t\treturn 0;\n\n\t\ts++;\n\t}\n\n\treturn 1;\n}\n\n \nstatic char get_oct_char(const char *s, int *i)\n{\n\tchar x[4];\n\tchar *endx;\n\tlong val;\n\n\tx[3] = '\\0';\n\tstrncpy(x, s + *i, 3);\n\n\tval = strtol(x, &endx, 8);\n\n\tassert(endx > x);\n\n\t(*i) += endx - x;\n\treturn val;\n}\n\n \nstatic char get_hex_char(const char *s, int *i)\n{\n\tchar x[3];\n\tchar *endx;\n\tlong val;\n\n\tx[2] = '\\0';\n\tstrncpy(x, s + *i, 2);\n\n\tval = strtol(x, &endx, 16);\n\tif (!(endx  > x))\n\t\tdie(\"\\\\x used with no following hex digits\\n\");\n\n\t(*i) += endx - x;\n\treturn val;\n}\n\nchar get_escape_char(const char *s, int *i)\n{\n\tchar\tc = s[*i];\n\tint\tj = *i + 1;\n\tchar\tval;\n\n\tswitch (c) {\n\tcase 'a':\n\t\tval = '\\a';\n\t\tbreak;\n\tcase 'b':\n\t\tval = '\\b';\n\t\tbreak;\n\tcase 't':\n\t\tval = '\\t';\n\t\tbreak;\n\tcase 'n':\n\t\tval = '\\n';\n\t\tbreak;\n\tcase 'v':\n\t\tval = '\\v';\n\t\tbreak;\n\tcase 'f':\n\t\tval = '\\f';\n\t\tbreak;\n\tcase 'r':\n\t\tval = '\\r';\n\t\tbreak;\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\t\tj--;  \n\t\tval = get_oct_char(s, &j);\n\t\tbreak;\n\tcase 'x':\n\t\tval = get_hex_char(s, &j);\n\t\tbreak;\n\tdefault:\n\t\tval = c;\n\t}\n\n\t(*i) = j;\n\treturn val;\n}\n\nint utilfdt_read_err(const char *filename, char **buffp, size_t *len)\n{\n\tint fd = 0;\t \n\tchar *buf = NULL;\n\tsize_t bufsize = 1024, offset = 0;\n\tint ret = 0;\n\n\t*buffp = NULL;\n\tif (strcmp(filename, \"-\") != 0) {\n\t\tfd = open(filename, O_RDONLY);\n\t\tif (fd < 0)\n\t\t\treturn errno;\n\t}\n\n\t \n\tbuf = xmalloc(bufsize);\n\tdo {\n\t\t \n\t\tif (offset == bufsize) {\n\t\t\tbufsize *= 2;\n\t\t\tbuf = xrealloc(buf, bufsize);\n\t\t}\n\n\t\tret = read(fd, &buf[offset], bufsize - offset);\n\t\tif (ret < 0) {\n\t\t\tret = errno;\n\t\t\tbreak;\n\t\t}\n\t\toffset += ret;\n\t} while (ret != 0);\n\n\t \n\tclose(fd);\n\tif (ret)\n\t\tfree(buf);\n\telse\n\t\t*buffp = buf;\n\tif (len)\n\t\t*len = bufsize;\n\treturn ret;\n}\n\nchar *utilfdt_read(const char *filename, size_t *len)\n{\n\tchar *buff;\n\tint ret = utilfdt_read_err(filename, &buff, len);\n\n\tif (ret) {\n\t\tfprintf(stderr, \"Couldn't open blob from '%s': %s\\n\", filename,\n\t\t\tstrerror(ret));\n\t\treturn NULL;\n\t}\n\t \n\treturn buff;\n}\n\nint utilfdt_write_err(const char *filename, const void *blob)\n{\n\tint fd = 1;\t \n\tint totalsize;\n\tint offset;\n\tint ret = 0;\n\tconst char *ptr = blob;\n\n\tif (strcmp(filename, \"-\") != 0) {\n\t\tfd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n\t\tif (fd < 0)\n\t\t\treturn errno;\n\t}\n\n\ttotalsize = fdt_totalsize(blob);\n\toffset = 0;\n\n\twhile (offset < totalsize) {\n\t\tret = write(fd, ptr + offset, totalsize - offset);\n\t\tif (ret < 0) {\n\t\t\tret = -errno;\n\t\t\tbreak;\n\t\t}\n\t\toffset += ret;\n\t}\n\t \n\tif (fd != 1)\n\t\tclose(fd);\n\treturn ret < 0 ? -ret : 0;\n}\n\n\nint utilfdt_write(const char *filename, const void *blob)\n{\n\tint ret = utilfdt_write_err(filename, blob);\n\n\tif (ret) {\n\t\tfprintf(stderr, \"Couldn't write blob to '%s': %s\\n\", filename,\n\t\t\tstrerror(ret));\n\t}\n\treturn ret ? -1 : 0;\n}\n\nint utilfdt_decode_type(const char *fmt, int *type, int *size)\n{\n\tint qualifier = 0;\n\n\tif (!*fmt)\n\t\treturn -1;\n\n\t \n\t*size = -1;\n\tif (strchr(\"hlLb\", *fmt)) {\n\t\tqualifier = *fmt++;\n\t\tif (qualifier == *fmt) {\n\t\t\tswitch (*fmt++) {\n \n\t\t\tcase 'h':\n\t\t\t\tqualifier = 'b';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((*fmt == '\\0') || !strchr(\"iuxsr\", *fmt))\n\t\treturn -1;\n\n\t \n\tif (*fmt != 's' && *fmt != 'r')\n\t\t*size = qualifier == 'b' ? 1 :\n\t\t\t\tqualifier == 'h' ? 2 :\n\t\t\t\tqualifier == 'l' ? 4 : -1;\n\t*type = *fmt++;\n\n\t \n\tif (*fmt)\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid utilfdt_print_data(const char *data, int len)\n{\n\tint i;\n\tconst char *s;\n\n\t \n\tif (len == 0)\n\t\treturn;\n\n\tif (util_is_printable_string(data, len)) {\n\t\tprintf(\" = \");\n\n\t\ts = data;\n\t\tdo {\n\t\t\tprintf(\"\\\"%s\\\"\", s);\n\t\t\ts += strlen(s) + 1;\n\t\t\tif (s < data + len)\n\t\t\t\tprintf(\", \");\n\t\t} while (s < data + len);\n\n\t} else if ((len % 4) == 0) {\n\t\tconst fdt32_t *cell = (const fdt32_t *)data;\n\n\t\tprintf(\" = <\");\n\t\tfor (i = 0, len /= 4; i < len; i++)\n\t\t\tprintf(\"0x%08\" PRIx32 \"%s\", fdt32_to_cpu(cell[i]),\n\t\t\t       i < (len - 1) ? \" \" : \"\");\n\t\tprintf(\">\");\n\t} else {\n\t\tconst unsigned char *p = (const unsigned char *)data;\n\t\tprintf(\" = [\");\n\t\tfor (i = 0; i < len; i++)\n\t\t\tprintf(\"%02x%s\", *p++, i < len - 1 ? \" \" : \"\");\n\t\tprintf(\"]\");\n\t}\n}\n\nvoid NORETURN util_version(void)\n{\n\tprintf(\"Version: %s\\n\", DTC_VERSION);\n\texit(0);\n}\n\nvoid NORETURN util_usage(const char *errmsg, const char *synopsis,\n\t\t\t const char *short_opts,\n\t\t\t struct option const long_opts[],\n\t\t\t const char * const opts_help[])\n{\n\tFILE *fp = errmsg ? stderr : stdout;\n\tconst char a_arg[] = \"<arg>\";\n\tsize_t a_arg_len = strlen(a_arg) + 1;\n\tsize_t i;\n\tint optlen;\n\n\tfprintf(fp,\n\t\t\"Usage: %s\\n\"\n\t\t\"\\n\"\n\t\t\"Options: -[%s]\\n\", synopsis, short_opts);\n\n\t \n\toptlen = 0;\n\tfor (i = 0; long_opts[i].name; ++i) {\n\t\t \n\t\tint l = strlen(long_opts[i].name) + 1;\n\t\tif (long_opts[i].has_arg == a_argument)\n\t\t\tl += a_arg_len;\n\t\tif (optlen < l)\n\t\t\toptlen = l;\n\t}\n\n\tfor (i = 0; long_opts[i].name; ++i) {\n\t\t \n\t\tassert(opts_help[i] != NULL);\n\n\t\t \n\t\tif (long_opts[i].val > '~')\n\t\t\tfprintf(fp, \"      \");\n\t\telse\n\t\t\tfprintf(fp, \"  -%c, \", long_opts[i].val);\n\n\t\t \n\t\tif (long_opts[i].has_arg == no_argument)\n\t\t\tfprintf(fp, \"--%-*s\", optlen, long_opts[i].name);\n\t\telse\n\t\t\tfprintf(fp, \"--%s %s%*s\", long_opts[i].name, a_arg,\n\t\t\t\t(int)(optlen - strlen(long_opts[i].name) - a_arg_len), \"\");\n\n\t\t \n\t\tfprintf(fp, \"%s\\n\", opts_help[i]);\n\t}\n\n\tif (errmsg) {\n\t\tfprintf(fp, \"\\nError: %s\\n\", errmsg);\n\t\texit(EXIT_FAILURE);\n\t} else\n\t\texit(EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}