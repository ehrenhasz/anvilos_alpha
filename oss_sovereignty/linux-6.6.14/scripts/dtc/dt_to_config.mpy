{
  "module_name": "dt_to_config",
  "hash_id": "ea6f50c20e54282129c0d1c802cc506572b17fbe0805fa0cdbf15ab20ce528a2",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/dt_to_config",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0-only\n\n# Copyright 2016 by Frank Rowand\n# Copyright 2016 by Gaurav Minocha\n#\n\nuse strict 'refs';\nuse strict subs;\n\nuse Getopt::Long;\n\n$VUFX = \"160610a\";\n\n$script_name = $0;\n$script_name =~ s|^.*/||;\n\n\n# ----- constants for print_flags()\n\n# Position in string $pr_flags.  Range of 0..($num_pr_flags - 1).\n$pr_flag_pos_mcompatible       = 0;\n$pr_flag_pos_driver            = 1;\n$pr_flag_pos_mdriver           = 2;\n$pr_flag_pos_config            = 3;\n$pr_flag_pos_mconfig           = 4;\n$pr_flag_pos_node_not_enabled  = 5;\n$pr_flag_pos_white_list        = 6;\n$pr_flag_pos_hard_coded        = 7;\n$pr_flag_pos_config_hard_coded = 8;\n$pr_flag_pos_config_none       = 9;\n$pr_flag_pos_config_m          = 10;\n$pr_flag_pos_config_y          = 11;\n$pr_flag_pos_config_test_fail  = 12;\n\n$num_pr_flags = $pr_flag_pos_config_test_fail + 1;\n\n# flags in @pr_flag_value must be unique values to allow simple regular\n# expessions to work for --include_flags and --exclude_flags.\n# Convention: use upper case letters for potential issues or problems.\n\n@pr_flag_value = ('M', 'd', 'D', 'c', 'C', 'E', 'W', 'H', 'x', 'n', 'm', 'y', 'F');\n\n@pr_flag_help = (\n    \"multiple compatibles found for this node\",\n    \"driver found for this compatible\",\n    \"multiple drivers found for this compatible\",\n    \"kernel config found for this driver\",\n    \"multiple config options found for this driver\",\n    \"node is not enabled\",\n    \"compatible is white listed\",\n    \"matching driver and/or kernel config is hard coded\",\n    \"kernel config hard coded in Makefile\",\n    \"one or more kernel config file options is not set\",\n    \"one or more kernel config file options is set to 'm'\",\n    \"one or more kernel config file options is set to 'y'\",\n    \"one of more kernel config file options fails to have correct value\"\n);\n\n\n# -----\n\n%driver_config = ();   # driver config array, indexed by driver source file\n%driver_count = ();    # driver_cnt, indexed by compatible\n%compat_driver = ();   # compatible driver array, indexed by compatible\n%existing_config = (); # existing config symbols present in given config file\n                       # expected values are: \"y\", \"m\", a decimal number, a\n                       # hex number, or a string\n\n# ----- magic compatibles, do not have a driver\n#\n# Will not search for drivers for these compatibles.\n\n%compat_white_list = (\n       'none'                  => '1',\n       'pci'                   => '1',\n       'simple-bus'            => '1',\n);\n\n# Will not search for drivers for these compatibles.\n#\n# These compatibles have a very large number of false positives.\n#\n# 'hardcoded_no_driver' is a magic value.  Other code knows this\n# magic value.  Do not use 'no_driver' here!\n#\n# Revisit each 'hardcoded_no_driver' to see how the compatible\n# is used.  Are there drivers that can be provided?\n\n%driver_hard_code_list = (\n       'cache'                 => ['hardcoded_no_driver'],\n       'eeprom'                => ['hardcoded_no_driver'],\n       'gpio'                  => ['hardcoded_no_driver'],\n       'gpio-keys'             => ['drivers/input/keyboard/gpio_keys.c'],\n       'i2c-gpio'              => ['drivers/i2c/busses/i2c-gpio.c'],\n       'isa'                   => ['arch/mips/mti-malta/malta-dt.c',\n                                    'arch/x86/kernel/devicetree.c'],\n       'led'                   => ['hardcoded_no_driver'],\n       'm25p32'                => ['hardcoded_no_driver'],\n       'm25p64'                => ['hardcoded_no_driver'],\n       'm25p80'                => ['hardcoded_no_driver'],\n       'mtd-ram'               => ['drivers/mtd/maps/physmap_of.c'],\n       'pwm-backlight'         => ['drivers/video/backlight/pwm_bl.c'],\n       'spidev'                => ['hardcoded_no_driver'],\n       'syscon'                => ['drivers/mfd/syscon.c'],\n       'tlv320aic23'           => ['hardcoded_no_driver'],\n       'wm8731'                => ['hardcoded_no_driver'],\n);\n\n# Use these config options instead of searching makefiles\n\n%driver_config_hard_code_list = (\n\n       # this one needed even if %driver_hard_code_list is empty\n       'no_driver'                             => ['no_config'],\n       'hardcoded_no_driver'                   => ['no_config'],\n\n       # drivers/usb/host/ehci-ppc-of.c\n       # drivers/usb/host/ehci-xilinx-of.c\n       #  are included from:\n       #    drivers/usb/host/ehci-hcd.c\n       #  thus the search of Makefile for the included .c files is incorrect\n       # ehci-hcd.c wraps the includes with ifdef CONFIG_USB_EHCI_HCD_..._OF\n       #\n       # similar model for ohci-hcd.c (but no ohci-xilinx-of.c)\n       #\n       # similarly, uhci-hcd.c includes uhci-platform.c\n\n       'drivers/usb/host/ehci-ppc-of.c'        => ['CONFIG_USB_EHCI_HCD',\n                                                   'CONFIG_USB_EHCI_HCD_PPC_OF'],\n       'drivers/usb/host/ohci-ppc-of.c'        => ['CONFIG_USB_OHCI_HCD',\n                                                   'CONFIG_USB_OHCI_HCD_PPC_OF'],\n\n       'drivers/usb/host/ehci-xilinx-of.c'     => ['CONFIG_USB_EHCI_HCD',\n                                                   'CONFIG_USB_EHCI_HCD_XILINX'],\n\n       'drivers/usb/host/uhci-platform.c'      => ['CONFIG_USB_UHCI_HCD',\n                                                   'CONFIG_USB_UHCI_PLATFORM'],\n\n       # scan_makefile will find only one of these config options:\n       #    ifneq ($(CONFIG_SOC_IMX6)$(CONFIG_SOC_LS1021A),)\n       'arch/arm/mach-imx/platsmp.c'           => ['CONFIG_SOC_IMX6 && CONFIG_SMP',\n                                                   'CONFIG_SOC_LS1021A && CONFIG_SMP'],\n);\n\n\n# 'virt/kvm/arm/.*' are controlled by makefiles in other directories,\n# using relative paths, such as 'KVM := ../../../virt/kvm'.  Do not\n# add complexity to find_kconfig() to deal with this.  There is a long\n# term intent to change the kvm related makefiles to the normal kernel\n# style.  After that is done, this entry can be removed from the\n# black_list_driver.\n\n@black_list_driver = (\n       # kvm no longer a problem after commit 503a62862e8f in 4.7-rc1\n       # 'virt/kvm/arm/.*',\n);\n\n\nsub usage()\n{\n       print\n\"\nUsage: $script_name [options] device-tree...\n\n    device_tree is: dts_file | dtb_file | proc_device-tree\n\n\nValid options:\n     -c FILE             Read kernel config options from FILE\n    --config FILE        synonym for 'c'\n    --config-format      config file friendly output format\n    --exclude-flag FLAG  exclude entries with a matching flag\n     -h                  Display this message and exit\n    --help               synonym for 'h'\n    --black-list-driver  use driver black list\n    --white-list-config  use config white list\n    --white-list-driver  use driver white list\n    --include-flag FLAG  include only entries with a matching flag\n    --include-suspect    include only entries with an uppercase flag\n    --short-name         do not show the path portion of the node name\n    --show-lists         report of white and black lists\n    --version            Display program version and exit\n\n\n  Report driver source files that match the compatibles in the device\n  tree file and the kernel config options that enable the driver source\n  files.\n\n  This program must be run in the root directory of a Linux kernel\n  source tree.\n\n  The default format is a report that is intended to be easily human\n  scannable.\n\n  An alternate format can be selected by --config-format.  This will\n  create output that can easily be edited to create a fragment that can\n  be appended to the existing kernel config file.  Each entry consists of\n  multiple lines.  The first line reports flags, the node path, compatible\n  value, driver file matching the compatible, configuration options, and\n  current values of the configuration options.  For each configuration\n  option, the following lines report the current value and the value that\n  is required for the driver file to be included in the kernel.\n\n  If a large number of drivers or config options is listed for a node,\n  and the '$pr_flag_value[$pr_flag_pos_hard_coded]' flag is set consider using --white-list-config and/or\n  --white-list-driver.  If the white list option suppresses the correct\n  entry please report that as a bug.\n\n  CAUTION:\n     This program uses heuristics to guess which driver(s) support each\n     compatible string and which config option(s) enables the driver(s).\n     Do not believe that the reported information is fully correct.\n     This program is intended to aid the process of determining the\n     proper kernel configuration for a device tree, but this is not\n     a fully automated process -- human involvement may still be\n     required!\n\n     The driver match heuristic used is to search for source files\n     containing the compatible string enclosed in quotes.\n\n     This program might not be able to find all drivers matching a\n     compatible string.\n\n     Some makefiles are overly clever.  This program was not made\n     complex enough to handle them.  If no config option is listed\n     for a driver, look at the makefile for the driver source file.\n     Even if a config option is listed for a driver, some other\n     available config options may not be listed.\n\n  FLAG values:\n\";\n\n       for ($k = 0; $k < $num_pr_flags; $k++) {\n               printf \"     %s   %s\\n\", $pr_flag_value[$k], $pr_flag_help[$k];\n       }\n\n       print\n\"\n     Upper case letters indicate potential issues or problems.\n\n  The flag:\n\n\";\n\n       $k = $pr_flag_pos_hard_coded;\n       printf \"     %s   %s\\n\", $pr_flag_value[$k], $pr_flag_help[$k];\n\n       print\n\"\n  will be set if the config or driver is in the white lists, even if\n  --white-list-config and --white-list-driver are not specified.\n  This is a hint that 1) many of these reported lines are likely to\n  be incorrect, and 2) using those options will reduce the number of\n  drivers and/or config options reported.\n\n  --white-list-config and --white-list-driver may not be accurate if this\n  program is not well maintained.  Use them with appropriate skepticism.\n  Use the --show-lists option to report the values in the list.\n\n  Return value:\n    0   if no error\n    1   error processing command line\n    2   unable to open or read kernel config file\n    3   unable to open or process input device tree file(s)\n\n  EXAMPLES:\n\n     dt_to_config arch/arm/boot/dts/my_dts_file.dts\n\n       Basic report.\n\n     dt_to_config \\\\\n        --config \\${KBUILD_OUTPUT}/.config \\\\\n        arch/\\${ARCH}/boot/dts/my_dts_file.dts\n\n       Full report, with config file issues noted.\n\n     dt_to_config --include-suspect \\\\\n        --config \\${KBUILD_OUTPUT}/.config \\\\\n        arch/\\${ARCH}/boot/dts/my_dts_file.dts\n\n       Report of node / compatible string / driver tuples that should\n       be further investigated.  A node may have multiple compatible\n       strings.  A compatible string may be matched by multiple drivers.\n       A driver may have config file issues noted.  The compatible string\n       and/or driver may be in the white lists.\n\n     dt_to_config --include-suspect --config-format \\\\\n        --config ${KBUILD_OUTPUT}/.config \\\\\n        arch/\\${ARCH}/boot/dts/my_dts_file.dts\n\n       Report of node / compatible string / driver tuples that should\n       be further investigated.  The report can be edited to uncomment\n       the config options to select the desired tuple for a given node.\n       A node may have multiple compatible strings.  A compatible string\n       may be matched by multiple drivers.  A driver may have config file\n       issues noted.  The compatible string and/or driver may be in the\n       white lists.\n\n\";\n}\n\nsub set_flag()\n{\n       # pr_flags_ref is a reference to $pr_flags\n\n       my $pr_flags_ref = shift;\n       my $pos          = shift;\n\n       substr $$pr_flags_ref, $pos, 1, $pr_flag_value[$pos];\n\n       return $pr_flags;\n}\n\nsub print_flags()\n{\n       # return 1 if anything printed, else 0\n\n       # some fields of pn_arg_ref might not be used in this function, but\n       # extract all of them anyway.\n       my $pn_arg_ref     = shift;\n\n       my $compat         = $pn_arg_ref->{compat};\n       my $compatible_cnt = $pn_arg_ref->{compatible_cnt};\n       my $config         = $pn_arg_ref->{config};\n       my $config_cnt     = $pn_arg_ref->{config_cnt};\n       my $driver         = $pn_arg_ref->{driver};\n       my $driver_cnt     = $pn_arg_ref->{driver_cnt};\n       my $full_node      = $pn_arg_ref->{full_node};\n       my $node           = $pn_arg_ref->{node};\n       my $node_enabled   = $pn_arg_ref->{node_enabled};\n       my $white_list     = $pn_arg_ref->{white_list};\n\n       my $pr_flags       = '-' x $num_pr_flags;\n\n\n       # ----- set flags in $pr_flags\n\n       if ($compatible_cnt > 1) {\n               &set_flag(\\$pr_flags, $pr_flag_pos_mcompatible);\n       }\n\n       if ($config_cnt > 1) {\n               &set_flag(\\$pr_flags, $pr_flag_pos_mconfig);\n       }\n\n       if ($driver_cnt >= 1) {\n               &set_flag(\\$pr_flags, $pr_flag_pos_driver);\n       }\n\n       if ($driver_cnt > 1) {\n               &set_flag(\\$pr_flags, $pr_flag_pos_mdriver);\n       }\n\n       # These strings are the same way the linux kernel tests.\n       # The ePapr lists of values is slightly different.\n       if (!(\n             ($node_enabled eq \"\") ||\n             ($node_enabled eq \"ok\") ||\n             ($node_enabled eq \"okay\")\n            )) {\n               &set_flag(\\$pr_flags, $pr_flag_pos_node_not_enabled);\n       }\n\n       if ($white_list) {\n               &set_flag(\\$pr_flags, $pr_flag_pos_white_list);\n       }\n\n       if (exists($driver_hard_code_list{$compat}) ||\n           (exists($driver_config_hard_code_list{$driver}) &&\n            ($driver ne \"no_driver\"))) {\n               &set_flag(\\$pr_flags, $pr_flag_pos_hard_coded);\n       }\n\n       my @configs = split(' && ', $config);\n       for $configs (@configs) {\n               $not = $configs =~ /^!/;\n               $configs =~ s/^!//;\n\n               if (($configs ne \"no_config\") && ($configs ne \"no_makefile\")) {\n                       &set_flag(\\$pr_flags, $pr_flag_pos_config);\n               }\n\n               if (($config_cnt >= 1) &&\n                   ($configs !~ /CONFIG_/) &&\n                   (($configs ne \"no_config\") && ($configs ne \"no_makefile\"))) {\n                       &set_flag(\\$pr_flags, $pr_flag_pos_config_hard_coded);\n               }\n\n               my $existing_config = $existing_config{$configs};\n               if ($existing_config eq \"m\") {\n                       &set_flag(\\$pr_flags, $pr_flag_pos_config_m);\n                       # Possible fail, depends on whether built in or\n                       # module is desired.\n                       &set_flag(\\$pr_flags, $pr_flag_pos_config_test_fail);\n               } elsif ($existing_config eq \"y\") {\n                       &set_flag(\\$pr_flags, $pr_flag_pos_config_y);\n                       if ($not) {\n                               &set_flag(\\$pr_flags, $pr_flag_pos_config_test_fail);\n                       }\n               } elsif (($config_file) && ($configs =~ /CONFIG_/)) {\n                       &set_flag(\\$pr_flags, $pr_flag_pos_config_none);\n                       if (!$not) {\n                               &set_flag(\\$pr_flags, $pr_flag_pos_config_test_fail);\n                       }\n               }\n       }\n\n       # ----- include / exclude filters\n\n       if ($include_flag_pattern && ($pr_flags !~ m/$include_flag_pattern/)) {\n               return 0;\n       }\n\n       if ($exclude_flag_pattern && ($pr_flags =~ m/$exclude_flag_pattern/)) {\n               return 0;\n       }\n\n       if ($config_format) {\n               print \"# \";\n       }\n       print \"$pr_flags : \";\n\n       return 1;\n}\n\n\nsub print_node()\n{\n       # return number of lines printed\n\n       # some fields of pn_arg_ref might not be used in this function, but\n       # extract all of them anyway.\n       my $pn_arg_ref     = shift;\n\n       my $compat         = $pn_arg_ref->{compat};\n       my $compatible_cnt = $pn_arg_ref->{compatible_cnt};\n       my $config         = $pn_arg_ref->{config};\n       my $config_cnt     = $pn_arg_ref->{config_cnt};\n       my $driver         = $pn_arg_ref->{driver};\n       my $driver_cnt     = $pn_arg_ref->{driver_cnt};\n       my $full_node      = $pn_arg_ref->{full_node};\n       my $node           = $pn_arg_ref->{node};\n       my $node_enabled   = $pn_arg_ref->{node_enabled};\n       my $white_list     = $pn_arg_ref->{white_list};\n\n       my $separator;\n\n       if (! &print_flags($pn_arg_ref)) {\n               return 0;\n       }\n\n\n       if ($short_name) {\n               print \"$node\";\n       } else {\n               print \"$full_node\";\n       }\n       print \" : $compat : $driver : $config : \";\n\n       my @configs = split(' && ', $config);\n\n       if ($config_file) {\n               for $configs (@configs) {\n                       $configs =~ s/^!//;\n                       my $existing_config = $existing_config{$configs};\n                       if (!$existing_config) {\n                               # check for /-m/, /-y/, or /-objs/\n                               if ($configs !~ /CONFIG_/) {\n                                       $existing_config = \"x\";\n                               };\n                       };\n                       if ($existing_config) {\n                               print \"$separator\", \"$existing_config\";\n                               $separator = \", \";\n                       } else {\n                               print \"$separator\", \"n\";\n                               $separator = \", \";\n                       }\n               }\n       } else {\n               print \"none\";\n       }\n\n       print \"\\n\";\n\n       if ($config_format) {\n               for $configs (@configs) {\n                       $not = $configs =~ /^!/;\n                       $configs =~ s/^!//;\n                       my $existing_config = $existing_config{$configs};\n\n                       if ($not) {\n                               if ($configs !~ /CONFIG_/) {\n                                       print \"# $configs\\n\";\n                               } elsif ($existing_config eq \"m\") {\n                                       print \"# $configs is m\\n\";\n                                       print \"# $configs=n\\n\";\n                               } elsif ($existing_config eq \"y\") {\n                                       print \"# $configs is set\\n\";\n                                       print \"# $configs=n\\n\";\n                               } else {\n                                       print \"# $configs is not set\\n\";\n                                       print \"# $configs=n\\n\";\n                               }\n\n                       } else {\n                               if ($configs !~ /CONFIG_/) {\n                                       print \"# $configs\\n\";\n                               } elsif ($existing_config eq \"m\") {\n                                       print \"# $configs is m\\n\";\n                                       print \"# $configs=y\\n\";\n                               } elsif ($existing_config eq \"y\") {\n                                       print \"# $configs is set\\n\";\n                                       print \"# $configs=y\\n\";\n                               } else {\n                                       print \"# $configs is not set\\n\";\n                                       print \"# $configs=y\\n\";\n                               }\n                       }\n               }\n       }\n\n       return 1;\n}\n\n\nsub scan_makefile\n{\n       my $pn_arg_ref    = shift;\n       my $driver        = shift;\n\n       # ----- Find Kconfig symbols that enable driver\n\n       my ($dir, $base) = $driver =~ m{(.*)/(.*).c};\n\n       my $makefile = $dir . \"/Makefile\";\n       if (! -r $makefile) {\n               $makefile = $dir . \"/Kbuild\";\n       }\n       if (! -r $makefile) {\n               my $config;\n\n               $config = 'no_makefile';\n               push @{ $driver_config{$driver} }, $config;\n               return;\n       }\n\n       if (!open(MAKEFILE_FILE, \"<\", \"$makefile\")) {\n               return;\n       }\n\n       my $line;\n       my @config;\n       my @if_config;\n       my @make_var;\n\n       NEXT_LINE:\n       while ($next_line = <MAKEFILE_FILE>) {\n               my $config;\n               my $if_config;\n               my $ifdef;\n               my $ifeq;\n               my $ifndef;\n               my $ifneq;\n               my $ifdef_config;\n               my $ifeq_config;\n               my $ifndef_config;\n               my $ifneq_config;\n\n               chomp($next_line);\n               $line = $line . $next_line;\n               if ($next_line =~ /\\\\$/) {\n                       $line =~ s/\\\\$/ /;\n                       next NEXT_LINE;\n               }\n               if ($line =~ /^\\s*#/) {\n                       $line = \"\";\n                       next NEXT_LINE;\n               }\n\n               # -----  condition ... else ... endif\n\n               if ($line =~ /^([ ]\\s*|)else\\b/) {\n                       $if_config = \"!\" . pop @if_config;\n                       $if_config =~ s/^!!//;\n                       push @if_config, $if_config;\n                       $line =~ s/^([ ]\\s*|)else\\b//;\n               }\n\n               ($null, $ifeq_config,  $ifeq_config_val )  = $line =~ /^([ ]\\s*|)ifeq\\b.*\\b(CONFIG_[A-Za-z0-9_]*)(.*)/;\n               ($null, $ifneq_config, $ifneq_config_val)  = $line =~ /^([ ]\\s*|)ifneq\\b.*\\b(CONFIG_[A-Za-z0-9_]*)(.*)/;\n               ($null, $ifdef_config)                     = $line =~ /^([ ]\\s*|)ifdef\\b.*\\b(CONFIG_[A-Za-z0-9_]*)/;\n               ($null, $ifndef_config)                    = $line =~ /^([ ]\\s*|)ifndef\\b.*\\b(CONFIG_[A-Za-z0-9_]*)/;\n\n               ($null, $ifeq)   = $line =~ /^([ ]\\s*|)ifeq\\b\\s*(.*)/;\n               ($null, $ifneq)  = $line =~ /^([ ]\\s*|)ifneq\\b\\s*(.*)/;\n               ($null, $ifdef)  = $line =~ /^([ ]\\s*|)ifdef\\b\\s*(.*)/;\n               ($null, $ifndef) = $line =~ /^([ ]\\s*|)ifndef\\b\\s*(.*)/;\n\n               # Order of tests is important.  Prefer \"CONFIG_*\" regex match over\n               # less specific regex match.\n               if ($ifdef_config) {\n                       $if_config = $ifdef_config;\n               } elsif ($ifeq_config) {\n                       if ($ifeq_config_val =~ /y/) {\n                               $if_config = $ifeq_config;\n                       } else {\n                               $if_config = \"!\" . $ifeq_config;\n                       }\n               } elsif ($ifndef_config) {\n                       $if_config = \"!\" . $ifndef_config;\n               } elsif ($ifneq_config) {\n                       if ($ifneq_config_val =~ /y/) {\n                               $if_config = \"!\" . $ifneq_config;\n                       } else {\n                               $if_config = $ifneq_config;\n                       }\n               } elsif ($ifdef) {\n                       $if_config = $ifdef;\n               } elsif ($ifeq) {\n                       $if_config = $ifeq;\n               } elsif ($ifndef) {\n                       $if_config = \"!\" . $ifndef;\n               } elsif ($ifneq) {\n                       $if_config = \"!\" . $ifneq;\n               } else {\n                       $if_config = \"\";\n               }\n               $if_config =~ s/^!!//;\n\n               if ($if_config) {\n                       push @if_config, $if_config;\n                       $line = \"\";\n                       next NEXT_LINE;\n               }\n\n               if ($line =~ /^([ ]\\s*|)endif\\b/) {\n                       pop @if_config;\n                       $line = \"\";\n                       next NEXT_LINE;\n               }\n\n               # ----- simple CONFIG_* = *.[co]  or  xxx [+:?]*= *.[co]\n               # Most makefiles select on *.o, but\n               # arch/powerpc/boot/Makefile selects on *.c\n\n               ($config) = $line =~ /(CONFIG_[A-Za-z0-9_]+).*\\b$base.[co]\\b/;\n\n               # ----- match a make variable instead of *.[co]\n               # Recursively expanded variables are not handled.\n\n               if (!$config) {\n                       my $make_var;\n                       ($make_var) = $line =~ /\\s*(\\S+?)\\s*[+:\\?]*=.*\\b$base.[co]\\b/;\n                       if ($make_var) {\n                               if ($make_var =~ /[a-zA-Z0-9]+-[ym]/) {\n                                       $config = $make_var;\n                               } elsif ($make_var =~ /[a-zA-Z0-9]+-objs/) {\n                                       $config = $make_var;\n                               } else {\n                                       push @make_var, $make_var;\n                               }\n                       }\n               }\n\n               if (!$config) {\n                       for $make_var (@make_var) {\n                               ($config) = $line =~ /(CONFIG_[A-Za-z0-9_]+).*\\b$make_var\\b/;\n                               last if ($config);\n                       }\n               }\n\n               if (!$config) {\n                       for $make_var (@make_var) {\n                               ($config) = $line =~ /\\s*(\\S+?)\\s*[+:\\?]*=.*\\b$make_var\\b/;\n                               last if ($config);\n                       }\n               }\n\n               # ----- next if no config found\n\n               if (!$config) {\n                       $line = \"\";\n                       next NEXT_LINE;\n               }\n\n               for $if_config (@if_config) {\n                       $config = $if_config . \" && \" . $config;\n               }\n\n               push @{ $driver_config{$driver} }, $config;\n\n               $line = \"\";\n       }\n\n       close(MAKEFILE_FILE);\n\n}\n\n\nsub find_kconfig\n{\n       my $pn_arg_ref    = shift;\n       my $driver        = shift;\n\n       my $lines_printed = 0;\n       my @configs;\n\n       if (!@{ $driver_config{$driver} }) {\n               &scan_makefile($pn_arg_ref, $driver);\n               if (!@{ $driver_config{$driver} }) {\n                       push @{ $driver_config{$driver} }, \"no_config\";\n               }\n       }\n\n       @configs = @{ $driver_config{$driver} };\n\n       $$pn_arg_ref{config_cnt} = $#configs + 1;\n       for my $config (@configs) {\n               $$pn_arg_ref{config} = $config;\n               $lines_printed += &print_node($pn_arg_ref);\n       }\n\n       return $lines_printed;\n}\n\n\nsub handle_compatible()\n{\n       my $full_node     = shift;\n       my $node          = shift;\n       my $compatible    = shift;\n       my $node_enabled  = shift;\n\n       my $compat;\n       my $lines_printed = 0;\n       my %pn_arg        = ();\n\n       return if (!$node or !$compatible);\n\n       # Do not process compatible property of root node,\n       # it is used to match board, not to bind a driver.\n       return if ($node eq \"/\");\n\n       $pn_arg{full_node}    = $full_node;\n       $pn_arg{node}         = $node;\n       $pn_arg{node_enabled} = $node_enabled;\n\n       my @compatibles = split('\", \"', $compatible);\n\n       $compatibles[0] =~ s/^\"//;\n       $compatibles[$#compatibles] =~ s/\"$//;\n\n       $pn_arg{compatible_cnt} = $#compatibles + 1;\n\n       COMPAT:\n       for $compat (@compatibles) {\n\n               $pn_arg{compat}     = $compat;\n               $pn_arg{driver_cnt} = 0;\n               $pn_arg{white_list} = 0;\n\n               if (exists($compat_white_list{$compat})) {\n                       $pn_arg{white_list} = 1;\n                       $pn_arg{driver}     = \"no_driver\";\n                       $pn_arg{config_cnt} = 1;\n                       $pn_arg{config}     = \"no_config\";\n                       $lines_printed += &print_node(\\%pn_arg);\n                       next COMPAT;\n               }\n\n               # ----- if compat previously seen, use cached info\n\n               if (exists($compat_driver{$compat})) {\n                       for my $driver (@{ $compat_driver{$compat} }) {\n                               $pn_arg{driver}     = $driver;\n                               $pn_arg{driver_cnt} = $driver_count{$compat};\n                               $pn_arg{config_cnt} = $#{ $driver_config{$driver}} + 1;\n\n                               for my $config (@{ $driver_config{$driver} }) {\n                                       $pn_arg{config} = $config;\n                                       $lines_printed += &print_node(\\%pn_arg);\n                               }\n\n                               if (!@{ $driver_config{$driver} }) {\n                                       # no config cached yet\n                                       # $driver in %driver_hard_code_list\n                                       # but not %driver_config_hard_code_list\n                                       $lines_printed += &find_kconfig(\\%pn_arg, $driver);\n                               }\n                       }\n                       next COMPAT;\n               }\n\n\n               # ----- Find drivers (source files that contain compatible)\n\n               # this will miss arch/sparc/include/asm/parport.h\n               # It is better to move the compatible out of the .h\n               # than to add *.h. to the files list, because *.h generates\n               # a lot of false negatives.\n               my $files = '\"*.c\"';\n               my $drivers = `git grep -l '\"$compat\"' -- $files`;\n               chomp($drivers);\n               if ($drivers eq \"\") {\n                       $pn_arg{driver} = \"no_driver\";\n                       $pn_arg{config_cnt} = 1;\n                       $pn_arg{config} = \"no_config\";\n                       push @{ $compat_driver{$compat} }, \"no_driver\";\n                       $lines_printed += &print_node(\\%pn_arg);\n                       next COMPAT;\n               }\n\n               my @drivers = split(\"\\n\", $drivers);\n               $driver_count{$compat} = $#drivers + 1;\n               $pn_arg{driver_cnt}    = $#drivers + 1;\n\n               DRIVER:\n               for my $driver (@drivers) {\n                       push @{ $compat_driver{$compat} }, $driver;\n                       $pn_arg{driver} = $driver;\n\n                       # ----- if driver previously seen, use cached info\n\n                       $pn_arg{config_cnt} = $#{ $driver_config{$driver} } + 1;\n                       for my $config (@{ $driver_config{$driver} }) {\n                               $pn_arg{config} = $config;\n                               $lines_printed += &print_node(\\%pn_arg);\n                       }\n                       if (@{ $driver_config{$driver} }) {\n                               next DRIVER;\n                       }\n\n                       if ($black_list_driver) {\n                               for $black (@black_list_driver) {\n                                       next DRIVER if ($driver =~ /^$black$/);\n                               }\n                       }\n\n\n                       # ----- Find Kconfig symbols that enable driver\n\n                       $lines_printed += &find_kconfig(\\%pn_arg, $driver);\n\n               }\n       }\n\n       # White space (line) between nodes for readability.\n       # Each node may report several compatibles.\n       # For each compatible, multiple drivers may be reported.\n       # For each driver, multiple CONFIG_ options may be reported.\n       if ($lines_printed) {\n               print \"\\n\";\n       }\n}\n\nsub read_dts()\n{\n       my $file         = shift;\n\n       my $compatible   = \"\";\n       my $line;\n       my $node         = \"\";\n       my $node_enabled = \"\";\n\n       if (! -r $file) {\n               print STDERR \"file '$file' is not readable or does not exist\\n\";\n               exit 3;\n       }\n\n       if (!open(DT_FILE, \"-|\", \"$dtx_diff $file\")) {\n               print STDERR \"\\n\";\n               print STDERR \"shell command failed:\\n\";\n               print STDERR \"   $dtx_diff $file\\n\";\n               print STDERR \"\\n\";\n               exit 3;\n       }\n\n       FILE:\n       while ($line = <DT_FILE>) {\n               chomp($line);\n\n               if ($line =~ /{/) {\n\n                       &handle_compatible($full_node, $node, $compatible,\n                                          $node_enabled);\n\n                       while ($end_node_count-- > 0) {\n                               pop @full_node;\n                       };\n                       $end_node_count = 0;\n                       $full_node = @full_node[-1];\n\n                       $node = $line;\n                       $node =~ s/^\\s*(.*)\\s+\\{.*/$1/;\n                       $node =~ s/.*: //;\n                       if ($node eq '/' ) {\n                               $full_node = '/';\n                       } elsif ($full_node ne '/') {\n                               $full_node = $full_node . '/' . $node;\n                       } else {\n                               $full_node = '/' . $node;\n                       }\n                       push @full_node, $full_node;\n\n                       $compatible = \"\";\n                       $node_enabled = \"\";\n                       next FILE;\n               }\n\n               if ($line =~ /}/) {\n                       $end_node_count++;\n               }\n\n               if ($line =~ /(\\s+|^)status =/) {\n                       $node_enabled = $line;\n                       $node_enabled =~ s/^\\t*//;\n                       $node_enabled =~ s/^status = \"//;\n                       $node_enabled =~ s/\";$//;\n                       next FILE;\n               }\n\n               if ($line =~ /(\\s+|^)compatible =/) {\n                       # Extract all compatible entries for this device\n                       # White space matching here and in handle_compatible() is\n                       # precise, because input format is the output of dtc,\n                       # which is invoked by dtx_diff.\n                       $compatible = $line;\n                       $compatible =~ s/^\\t*//;\n                       $compatible =~ s/^compatible = //;\n                       $compatible =~ s/;$//;\n               }\n       }\n\n       &handle_compatible($full_node, $node, $compatible, $node_enabled);\n\n       close(DT_FILE);\n}\n\n\nsub read_config_file()\n{\n       if (! -r $config_file) {\n               print STDERR \"file '$config_file' is not readable or does not exist\\n\";\n               exit 2;\n       }\n\n       if (!open(CONFIG_FILE, \"<\", \"$config_file\")) {\n               print STDERR \"open $config_file failed\\n\";\n               exit 2;\n       }\n\n       my @line;\n\n       LINE:\n       while ($line = <CONFIG_FILE>) {\n               chomp($line);\n               next LINE if ($line =~ /^\\s*#/);\n               next LINE if ($line =~ /^\\s*$/);\n               @line = split /=/, $line;\n               $existing_config{@line[0]} = @line[1];\n       }\n\n       close(CONFIG_FILE);\n}\n\n\nsub cmd_line_err()\n{\n       my $msg = shift;\n\n       print STDERR \"\\n\";\n       print STDERR \"   ERROR processing command line options\\n\";\n       print STDERR \"         $msg\\n\" if ($msg ne \"\");\n       print STDERR \"\\n\";\n       print STDERR \"   For help, type '$script_name --help'\\n\";\n       print STDERR \"\\n\";\n}\n\n\n# -----------------------------------------------------------------------------\n# program entry point\n\nGetopt::Long::Configure(\"no_ignore_case\", \"bundling\");\n\nif (!GetOptions(\n       \"c=s\"               => \\$config_file,\n       \"config=s\"          => \\$config_file,\n       \"config-format\"     => \\$config_format,\n       \"exclude-flag=s\"    => \\@exclude_flag,\n       \"h\"                 => \\$help,\n       \"help\"              => \\$help,\n       \"black-list-driver\" => \\$black_list_driver,\n       \"white-list-config\" => \\$white_list_config,\n       \"white-list-driver\" => \\$white_list_driver,\n       \"include-flag=s\"    => \\@include_flag,\n       \"include-suspect\"   => \\$include_suspect,\n       \"short-name\"        => \\$short_name,\n       \"show-lists\"        => \\$show_lists,\n       \"version\"           => \\$version,\n       )) {\n\n       &cmd_line_err();\n\n       exit 1;\n}\n\n\nmy $exit_after_messages = 0;\n\nif ($version) {\n       print STDERR \"\\n$script_name  $VUFX\\n\\n\";\n       $exit_after_messages = 1;\n}\n\n\nif ($help) {\n       &usage;\n       $exit_after_messages = 1;\n}\n\n\nif ($show_lists) {\n\n       print \"\\n\";\n       print \"These compatibles are hard coded to have no driver.\\n\";\n       print \"\\n\";\n       for my $compat (sort keys %compat_white_list) {\n               print \"   $compat\\n\";\n       }\n\n\n       print \"\\n\\n\";\n       print \"The driver for these compatibles is hard coded (white list).\\n\";\n       print \"\\n\";\n       my $max_compat_len = 0;\n       for my $compat (sort keys %driver_hard_code_list) {\n               if (length $compat > $max_compat_len) {\n                       $max_compat_len = length $compat;\n               }\n       }\n       for my $compat (sort keys %driver_hard_code_list) {\n               if (($driver ne \"hardcoded_no_driver\") && ($driver ne \"no_driver\")) {\n                       my $first = 1;\n                       for my $driver (@{ $driver_hard_code_list{$compat} }) {\n                               if ($first) {\n                                       print \"   $compat\";\n                                       print \" \" x ($max_compat_len - length $compat);\n                                       $first = 0;\n                               } else {\n                                       print \"   \", \" \" x $max_compat_len;\n                               }\n                               print \"  $driver\\n\";\n                       }\n               }\n       }\n\n\n       print \"\\n\\n\";\n       print \"The configuration option for these drivers is hard coded (white list).\\n\";\n       print \"\\n\";\n       my $max_driver_len = 0;\n       for my $driver (sort keys %driver_config_hard_code_list) {\n               if (length $driver > $max_driver_len) {\n                       $max_driver_len = length $driver;\n               }\n       }\n       for my $driver (sort keys %driver_config_hard_code_list) {\n               if (($driver ne \"hardcoded_no_driver\") && ($driver ne \"no_driver\")) {\n                       my $first = 1;\n                       for my $config (@{ $driver_config_hard_code_list{$driver} }) {\n                               if ($first) {\n                                       print \"   $driver\";\n                                       print \" \" x ($max_driver_len - length $driver);\n                                       $first = 0;\n                               } else {\n                                       print \"   \", \" \" x $max_driver_len;\n                               }\n                               print \"  $config\\n\";\n                       }\n               }\n       }\n\n\n       print \"\\n\\n\";\n       print \"These drivers are black listed.\\n\";\n       print \"\\n\";\n       for my $driver (@black_list_driver) {\n               print \"   $driver\\n\";\n       }\n\n       print \"\\n\";\n\n       $exit_after_messages = 1;\n}\n\n\nif ($exit_after_messages) {\n       exit 0;\n}\n\n\n$exclude_flag_pattern = \"[\";\nfor my $exclude_flag (@exclude_flag) {\n       $exclude_flag_pattern = $exclude_flag_pattern . $exclude_flag;\n}\n$exclude_flag_pattern = $exclude_flag_pattern . \"]\";\n# clean up if empty\n$exclude_flag_pattern =~ s/^\\[\\]$//;\n\n\n$include_flag_pattern = \"[\";\nfor my $include_flag (@include_flag) {\n       $include_flag_pattern = $include_flag_pattern . $include_flag;\n}\n$include_flag_pattern = $include_flag_pattern . \"]\";\n# clean up if empty\n$include_flag_pattern =~ s/^\\[\\]$//;\n\n\nif ($exclude_flag_pattern) {\n       my $found = 0;\n       for $pr_flag_value (@pr_flag_value) {\n               if ($exclude_flag_pattern =~ m/$pr_flag_value/) {\n                       $found = 1;\n               }\n       }\n       if (!$found) {\n               &cmd_line_err(\"invalid value for FLAG in --exclude-flag\\n\");\n               exit 1\n       }\n}\n\nif ($include_flag_pattern) {\n       my $found = 0;\n       for $pr_flag_value (@pr_flag_value) {\n               if ($include_flag_pattern =~ m/$pr_flag_value/) {\n                       $found = 1;\n               }\n       }\n       if (!$found) {\n               &cmd_line_err(\"invalid value for FLAG in --include-flag\\n\");\n               exit 1\n       }\n}\n\nif ($include_suspect) {\n       $include_flag_pattern =~ s/\\[//;\n       $include_flag_pattern =~ s/\\]//;\n       $include_flag_pattern = \"[\" . $include_flag_pattern . \"A-Z]\";\n}\n\nif ($exclude_flag_pattern =~ m/$include_flag_pattern/) {\n       &cmd_line_err(\"the same flag appears in both --exclude-flag and --include-flag or --include-suspect\\n\");\n       exit 1\n}\n\n\n# ($#ARGV < 0) is valid for --help, --version\nif ($#ARGV < 0) {\n       &cmd_line_err(\"device-tree... is required\");\n       exit 1\n}\n\n\nif ($config_file) {\n       &read_config_file();\n}\n\n\n# avoid pushing duplicates for this value\n$driver = \"hardcoded_no_driver\";\nfor $config ( @{ $driver_config_hard_code_list{$driver} } ) {\n       push @{ $driver_config{$driver} }, $config;\n}\n\nif ($white_list_driver) {\n       for my $compat (keys %driver_hard_code_list) {\n               for my $driver (@{ $driver_hard_code_list{$compat} }) {\n                       push @{ $compat_driver{$compat} }, $driver;\n                       if ($driver ne \"hardcoded_no_driver\") {\n                               $driver_count{$compat} = scalar @{ $compat_driver{$compat} };\n                       }\n               }\n       }\n}\n\nif ($white_list_config) {\n       for my $driver (keys %driver_config_hard_code_list) {\n               if ($driver ne \"hardcoded_no_driver\") {\n                       for $config ( @{ $driver_config_hard_code_list{$driver} } ) {\n                               push @{ $driver_config{$driver} }, $config;\n                       }\n               }\n       }\n}\n\nif (-x \"scripts/dtc/dtx_diff\") {\n       $dtx_diff = \"scripts/dtc/dtx_diff\";\n} else {\n\n       print STDERR \"\\n\";\n       print STDERR \"$script_name must be run from the root directory of a Linux kernel tree\\n\";\n       print STDERR \"\\n\";\n       exit 3;\n}\n\nfor $file (@ARGV) {\n       &read_dts($file);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}