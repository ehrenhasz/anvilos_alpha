{
  "module_name": "libfdt_internal.h",
  "hash_id": "4e5a3868b92403063d2367d9c22fa57de82da69742b8ca714763a662275c7c7d",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/libfdt/libfdt_internal.h",
  "human_readable_source": " \n#ifndef LIBFDT_INTERNAL_H\n#define LIBFDT_INTERNAL_H\n \n#include <fdt.h>\n\n#define FDT_ALIGN(x, a)\t\t(((x) + (a) - 1) & ~((a) - 1))\n#define FDT_TAGALIGN(x)\t\t(FDT_ALIGN((x), FDT_TAGSIZE))\n\nint32_t fdt_ro_probe_(const void *fdt);\n#define FDT_RO_PROBE(fdt)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\tint32_t totalsize_;\t\t\t\t\\\n\t\tif ((totalsize_ = fdt_ro_probe_(fdt)) < 0)\t\\\n\t\t\treturn totalsize_;\t\t\t\\\n\t}\n\nint fdt_check_node_offset_(const void *fdt, int offset);\nint fdt_check_prop_offset_(const void *fdt, int offset);\nconst char *fdt_find_string_(const char *strtab, int tabsize, const char *s);\nint fdt_node_end_offset_(void *fdt, int nodeoffset);\n\nstatic inline const void *fdt_offset_ptr_(const void *fdt, int offset)\n{\n\treturn (const char *)fdt + fdt_off_dt_struct(fdt) + offset;\n}\n\nstatic inline void *fdt_offset_ptr_w_(void *fdt, int offset)\n{\n\treturn (void *)(uintptr_t)fdt_offset_ptr_(fdt, offset);\n}\n\nstatic inline const struct fdt_reserve_entry *fdt_mem_rsv_(const void *fdt, int n)\n{\n\tconst struct fdt_reserve_entry *rsv_table =\n\t\t(const struct fdt_reserve_entry *)\n\t\t((const char *)fdt + fdt_off_mem_rsvmap(fdt));\n\n\treturn rsv_table + n;\n}\nstatic inline struct fdt_reserve_entry *fdt_mem_rsv_w_(void *fdt, int n)\n{\n\treturn (void *)(uintptr_t)fdt_mem_rsv_(fdt, n);\n}\n\n \nstatic inline uint32_t fdt32_ld_(const fdt32_t *p)\n{\n\treturn fdt32_to_cpu(*p);\n}\n\nstatic inline uint64_t fdt64_ld_(const fdt64_t *p)\n{\n\treturn fdt64_to_cpu(*p);\n}\n\n#define FDT_SW_MAGIC\t\t(~FDT_MAGIC)\n\n \n \n \n\n#ifndef FDT_ASSUME_MASK\n#define FDT_ASSUME_MASK 0\n#endif\n\n \nenum {\n\t \n\tASSUME_PERFECT\t\t= 0xff,\n\n\t \n\tASSUME_VALID_DTB\t= 1 << 0,\n\n\t \n\tASSUME_VALID_INPUT\t= 1 << 1,\n\n\t \n\tASSUME_LATEST\t\t= 1 << 2,\n\n\t \n\tASSUME_NO_ROLLBACK\t= 1 << 3,\n\n\t \n\tASSUME_LIBFDT_ORDER\t= 1 << 4,\n\n\t \n\tASSUME_LIBFDT_FLAWLESS\t= 1 << 5,\n};\n\n \nstatic inline bool can_assume_(int mask)\n{\n\treturn FDT_ASSUME_MASK & mask;\n}\n\n \n#define can_assume(_assume)\tcan_assume_(ASSUME_ ## _assume)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}