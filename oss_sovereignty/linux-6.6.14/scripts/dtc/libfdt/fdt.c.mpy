{
  "module_name": "fdt.c",
  "hash_id": "86c2410f1a4c6055ae87a8b5a2d3a1c02eb7fb32787566dfcdb1ef5f5ddb5fb6",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/libfdt/fdt.c",
  "human_readable_source": "\n \n#include \"libfdt_env.h\"\n\n#include <fdt.h>\n#include <libfdt.h>\n\n#include \"libfdt_internal.h\"\n\n \nint32_t fdt_ro_probe_(const void *fdt)\n{\n\tuint32_t totalsize = fdt_totalsize(fdt);\n\n\tif (can_assume(VALID_DTB))\n\t\treturn totalsize;\n\n\t \n\tif ((uintptr_t)fdt & 7)\n\t\treturn -FDT_ERR_ALIGNMENT;\n\n\tif (fdt_magic(fdt) == FDT_MAGIC) {\n\t\t \n\t\tif (!can_assume(LATEST)) {\n\t\t\tif (fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)\n\t\t\t\treturn -FDT_ERR_BADVERSION;\n\t\t\tif (fdt_last_comp_version(fdt) >\n\t\t\t\t\tFDT_LAST_SUPPORTED_VERSION)\n\t\t\t\treturn -FDT_ERR_BADVERSION;\n\t\t}\n\t} else if (fdt_magic(fdt) == FDT_SW_MAGIC) {\n\t\t \n\t\tif (!can_assume(VALID_INPUT) && fdt_size_dt_struct(fdt) == 0)\n\t\t\treturn -FDT_ERR_BADSTATE;\n\t} else {\n\t\treturn -FDT_ERR_BADMAGIC;\n\t}\n\n\tif (totalsize < INT32_MAX)\n\t\treturn totalsize;\n\telse\n\t\treturn -FDT_ERR_TRUNCATED;\n}\n\nstatic int check_off_(uint32_t hdrsize, uint32_t totalsize, uint32_t off)\n{\n\treturn (off >= hdrsize) && (off <= totalsize);\n}\n\nstatic int check_block_(uint32_t hdrsize, uint32_t totalsize,\n\t\t\tuint32_t base, uint32_t size)\n{\n\tif (!check_off_(hdrsize, totalsize, base))\n\t\treturn 0;  \n\tif ((base + size) < base)\n\t\treturn 0;  \n\tif (!check_off_(hdrsize, totalsize, base + size))\n\t\treturn 0;  \n\treturn 1;\n}\n\nsize_t fdt_header_size_(uint32_t version)\n{\n\tif (version <= 1)\n\t\treturn FDT_V1_SIZE;\n\telse if (version <= 2)\n\t\treturn FDT_V2_SIZE;\n\telse if (version <= 3)\n\t\treturn FDT_V3_SIZE;\n\telse if (version <= 16)\n\t\treturn FDT_V16_SIZE;\n\telse\n\t\treturn FDT_V17_SIZE;\n}\n\nsize_t fdt_header_size(const void *fdt)\n{\n\treturn can_assume(LATEST) ? FDT_V17_SIZE :\n\t\tfdt_header_size_(fdt_version(fdt));\n}\n\nint fdt_check_header(const void *fdt)\n{\n\tsize_t hdrsize;\n\n\t \n\tif ((uintptr_t)fdt & 7)\n\t\treturn -FDT_ERR_ALIGNMENT;\n\n\tif (fdt_magic(fdt) != FDT_MAGIC)\n\t\treturn -FDT_ERR_BADMAGIC;\n\tif (!can_assume(LATEST)) {\n\t\tif ((fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)\n\t\t    || (fdt_last_comp_version(fdt) >\n\t\t\tFDT_LAST_SUPPORTED_VERSION))\n\t\t\treturn -FDT_ERR_BADVERSION;\n\t\tif (fdt_version(fdt) < fdt_last_comp_version(fdt))\n\t\t\treturn -FDT_ERR_BADVERSION;\n\t}\n\thdrsize = fdt_header_size(fdt);\n\tif (!can_assume(VALID_DTB)) {\n\t\tif ((fdt_totalsize(fdt) < hdrsize)\n\t\t    || (fdt_totalsize(fdt) > INT_MAX))\n\t\t\treturn -FDT_ERR_TRUNCATED;\n\n\t\t \n\t\tif (!check_off_(hdrsize, fdt_totalsize(fdt),\n\t\t\t\tfdt_off_mem_rsvmap(fdt)))\n\t\t\treturn -FDT_ERR_TRUNCATED;\n\n\t\t \n\t\tif (!can_assume(LATEST) && fdt_version(fdt) < 17) {\n\t\t\tif (!check_off_(hdrsize, fdt_totalsize(fdt),\n\t\t\t\t\tfdt_off_dt_struct(fdt)))\n\t\t\t\treturn -FDT_ERR_TRUNCATED;\n\t\t} else {\n\t\t\tif (!check_block_(hdrsize, fdt_totalsize(fdt),\n\t\t\t\t\t  fdt_off_dt_struct(fdt),\n\t\t\t\t\t  fdt_size_dt_struct(fdt)))\n\t\t\t\treturn -FDT_ERR_TRUNCATED;\n\t\t}\n\n\t\t \n\t\tif (!check_block_(hdrsize, fdt_totalsize(fdt),\n\t\t\t\t  fdt_off_dt_strings(fdt),\n\t\t\t\t  fdt_size_dt_strings(fdt)))\n\t\t\treturn -FDT_ERR_TRUNCATED;\n\t}\n\n\treturn 0;\n}\n\nconst void *fdt_offset_ptr(const void *fdt, int offset, unsigned int len)\n{\n\tunsigned int uoffset = offset;\n\tunsigned int absoffset = offset + fdt_off_dt_struct(fdt);\n\n\tif (offset < 0)\n\t\treturn NULL;\n\n\tif (!can_assume(VALID_INPUT))\n\t\tif ((absoffset < uoffset)\n\t\t    || ((absoffset + len) < absoffset)\n\t\t    || (absoffset + len) > fdt_totalsize(fdt))\n\t\t\treturn NULL;\n\n\tif (can_assume(LATEST) || fdt_version(fdt) >= 0x11)\n\t\tif (((uoffset + len) < uoffset)\n\t\t    || ((offset + len) > fdt_size_dt_struct(fdt)))\n\t\t\treturn NULL;\n\n\treturn fdt_offset_ptr_(fdt, offset);\n}\n\nuint32_t fdt_next_tag(const void *fdt, int startoffset, int *nextoffset)\n{\n\tconst fdt32_t *tagp, *lenp;\n\tuint32_t tag, len, sum;\n\tint offset = startoffset;\n\tconst char *p;\n\n\t*nextoffset = -FDT_ERR_TRUNCATED;\n\ttagp = fdt_offset_ptr(fdt, offset, FDT_TAGSIZE);\n\tif (!can_assume(VALID_DTB) && !tagp)\n\t\treturn FDT_END;  \n\ttag = fdt32_to_cpu(*tagp);\n\toffset += FDT_TAGSIZE;\n\n\t*nextoffset = -FDT_ERR_BADSTRUCTURE;\n\tswitch (tag) {\n\tcase FDT_BEGIN_NODE:\n\t\t \n\t\tdo {\n\t\t\tp = fdt_offset_ptr(fdt, offset++, 1);\n\t\t} while (p && (*p != '\\0'));\n\t\tif (!can_assume(VALID_DTB) && !p)\n\t\t\treturn FDT_END;  \n\t\tbreak;\n\n\tcase FDT_PROP:\n\t\tlenp = fdt_offset_ptr(fdt, offset, sizeof(*lenp));\n\t\tif (!can_assume(VALID_DTB) && !lenp)\n\t\t\treturn FDT_END;  \n\n\t\tlen = fdt32_to_cpu(*lenp);\n\t\tsum = len + offset;\n\t\tif (!can_assume(VALID_DTB) &&\n\t\t    (INT_MAX <= sum || sum < (uint32_t) offset))\n\t\t\treturn FDT_END;  \n\n\t\t \n\t\toffset += sizeof(struct fdt_property) - FDT_TAGSIZE + len;\n\n\t\tif (!can_assume(LATEST) &&\n\t\t    fdt_version(fdt) < 0x10 && len >= 8 &&\n\t\t    ((offset - len) % 8) != 0)\n\t\t\toffset += 4;\n\t\tbreak;\n\n\tcase FDT_END:\n\tcase FDT_END_NODE:\n\tcase FDT_NOP:\n\t\tbreak;\n\n\tdefault:\n\t\treturn FDT_END;\n\t}\n\n\tif (!fdt_offset_ptr(fdt, startoffset, offset - startoffset))\n\t\treturn FDT_END;  \n\n\t*nextoffset = FDT_TAGALIGN(offset);\n\treturn tag;\n}\n\nint fdt_check_node_offset_(const void *fdt, int offset)\n{\n\tif (!can_assume(VALID_INPUT)\n\t    && ((offset < 0) || (offset % FDT_TAGSIZE)))\n\t\treturn -FDT_ERR_BADOFFSET;\n\n\tif (fdt_next_tag(fdt, offset, &offset) != FDT_BEGIN_NODE)\n\t\treturn -FDT_ERR_BADOFFSET;\n\n\treturn offset;\n}\n\nint fdt_check_prop_offset_(const void *fdt, int offset)\n{\n\tif (!can_assume(VALID_INPUT)\n\t    && ((offset < 0) || (offset % FDT_TAGSIZE)))\n\t\treturn -FDT_ERR_BADOFFSET;\n\n\tif (fdt_next_tag(fdt, offset, &offset) != FDT_PROP)\n\t\treturn -FDT_ERR_BADOFFSET;\n\n\treturn offset;\n}\n\nint fdt_next_node(const void *fdt, int offset, int *depth)\n{\n\tint nextoffset = 0;\n\tuint32_t tag;\n\n\tif (offset >= 0)\n\t\tif ((nextoffset = fdt_check_node_offset_(fdt, offset)) < 0)\n\t\t\treturn nextoffset;\n\n\tdo {\n\t\toffset = nextoffset;\n\t\ttag = fdt_next_tag(fdt, offset, &nextoffset);\n\n\t\tswitch (tag) {\n\t\tcase FDT_PROP:\n\t\tcase FDT_NOP:\n\t\t\tbreak;\n\n\t\tcase FDT_BEGIN_NODE:\n\t\t\tif (depth)\n\t\t\t\t(*depth)++;\n\t\t\tbreak;\n\n\t\tcase FDT_END_NODE:\n\t\t\tif (depth && ((--(*depth)) < 0))\n\t\t\t\treturn nextoffset;\n\t\t\tbreak;\n\n\t\tcase FDT_END:\n\t\t\tif ((nextoffset >= 0)\n\t\t\t    || ((nextoffset == -FDT_ERR_TRUNCATED) && !depth))\n\t\t\t\treturn -FDT_ERR_NOTFOUND;\n\t\t\telse\n\t\t\t\treturn nextoffset;\n\t\t}\n\t} while (tag != FDT_BEGIN_NODE);\n\n\treturn offset;\n}\n\nint fdt_first_subnode(const void *fdt, int offset)\n{\n\tint depth = 0;\n\n\toffset = fdt_next_node(fdt, offset, &depth);\n\tif (offset < 0 || depth != 1)\n\t\treturn -FDT_ERR_NOTFOUND;\n\n\treturn offset;\n}\n\nint fdt_next_subnode(const void *fdt, int offset)\n{\n\tint depth = 1;\n\n\t \n\tdo {\n\t\toffset = fdt_next_node(fdt, offset, &depth);\n\t\tif (offset < 0 || depth < 1)\n\t\t\treturn -FDT_ERR_NOTFOUND;\n\t} while (depth > 1);\n\n\treturn offset;\n}\n\nconst char *fdt_find_string_(const char *strtab, int tabsize, const char *s)\n{\n\tint len = strlen(s) + 1;\n\tconst char *last = strtab + tabsize - len;\n\tconst char *p;\n\n\tfor (p = strtab; p <= last; p++)\n\t\tif (memcmp(p, s, len) == 0)\n\t\t\treturn p;\n\treturn NULL;\n}\n\nint fdt_move(const void *fdt, void *buf, int bufsize)\n{\n\tif (!can_assume(VALID_INPUT) && bufsize < 0)\n\t\treturn -FDT_ERR_NOSPACE;\n\n\tFDT_RO_PROBE(fdt);\n\n\tif (fdt_totalsize(fdt) > (unsigned int)bufsize)\n\t\treturn -FDT_ERR_NOSPACE;\n\n\tmemmove(buf, fdt, fdt_totalsize(fdt));\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}