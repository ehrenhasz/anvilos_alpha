{
  "module_name": "fdt_overlay.c",
  "hash_id": "e9c1a8a102a9214e7e351f47d735760c66944d0ef8da89d9fa891e7d79a29a11",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/libfdt/fdt_overlay.c",
  "human_readable_source": "\n \n#include \"libfdt_env.h\"\n\n#include <fdt.h>\n#include <libfdt.h>\n\n#include \"libfdt_internal.h\"\n\n \nstatic uint32_t overlay_get_target_phandle(const void *fdto, int fragment)\n{\n\tconst fdt32_t *val;\n\tint len;\n\n\tval = fdt_getprop(fdto, fragment, \"target\", &len);\n\tif (!val)\n\t\treturn 0;\n\n\tif ((len != sizeof(*val)) || (fdt32_to_cpu(*val) == (uint32_t)-1))\n\t\treturn (uint32_t)-1;\n\n\treturn fdt32_to_cpu(*val);\n}\n\nint fdt_overlay_target_offset(const void *fdt, const void *fdto,\n\t\t\t      int fragment_offset, char const **pathp)\n{\n\tuint32_t phandle;\n\tconst char *path = NULL;\n\tint path_len = 0, ret;\n\n\t \n\tphandle = overlay_get_target_phandle(fdto, fragment_offset);\n\tif (phandle == (uint32_t)-1)\n\t\treturn -FDT_ERR_BADPHANDLE;\n\n\t \n\tif (!phandle) {\n\t\t \n\t\tpath = fdt_getprop(fdto, fragment_offset, \"target-path\", &path_len);\n\t\tif (path)\n\t\t\tret = fdt_path_offset(fdt, path);\n\t\telse\n\t\t\tret = path_len;\n\t} else\n\t\tret = fdt_node_offset_by_phandle(fdt, phandle);\n\n\t \n\tif (ret < 0 && path_len == -FDT_ERR_NOTFOUND)\n\t\tret = -FDT_ERR_BADOVERLAY;\n\n\t \n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (pathp)\n\t\t*pathp = path ? path : NULL;\n\n\treturn ret;\n}\n\n \nstatic int overlay_phandle_add_offset(void *fdt, int node,\n\t\t\t\t      const char *name, uint32_t delta)\n{\n\tconst fdt32_t *val;\n\tuint32_t adj_val;\n\tint len;\n\n\tval = fdt_getprop(fdt, node, name, &len);\n\tif (!val)\n\t\treturn len;\n\n\tif (len != sizeof(*val))\n\t\treturn -FDT_ERR_BADPHANDLE;\n\n\tadj_val = fdt32_to_cpu(*val);\n\tif ((adj_val + delta) < adj_val)\n\t\treturn -FDT_ERR_NOPHANDLES;\n\n\tadj_val += delta;\n\tif (adj_val == (uint32_t)-1)\n\t\treturn -FDT_ERR_NOPHANDLES;\n\n\treturn fdt_setprop_inplace_u32(fdt, node, name, adj_val);\n}\n\n \nstatic int overlay_adjust_node_phandles(void *fdto, int node,\n\t\t\t\t\tuint32_t delta)\n{\n\tint child;\n\tint ret;\n\n\tret = overlay_phandle_add_offset(fdto, node, \"phandle\", delta);\n\tif (ret && ret != -FDT_ERR_NOTFOUND)\n\t\treturn ret;\n\n\tret = overlay_phandle_add_offset(fdto, node, \"linux,phandle\", delta);\n\tif (ret && ret != -FDT_ERR_NOTFOUND)\n\t\treturn ret;\n\n\tfdt_for_each_subnode(child, fdto, node) {\n\t\tret = overlay_adjust_node_phandles(fdto, child, delta);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int overlay_adjust_local_phandles(void *fdto, uint32_t delta)\n{\n\t \n\treturn overlay_adjust_node_phandles(fdto, 0, delta);\n}\n\n \nstatic int overlay_update_local_node_references(void *fdto,\n\t\t\t\t\t\tint tree_node,\n\t\t\t\t\t\tint fixup_node,\n\t\t\t\t\t\tuint32_t delta)\n{\n\tint fixup_prop;\n\tint fixup_child;\n\tint ret;\n\n\tfdt_for_each_property_offset(fixup_prop, fdto, fixup_node) {\n\t\tconst fdt32_t *fixup_val;\n\t\tconst char *tree_val;\n\t\tconst char *name;\n\t\tint fixup_len;\n\t\tint tree_len;\n\t\tint i;\n\n\t\tfixup_val = fdt_getprop_by_offset(fdto, fixup_prop,\n\t\t\t\t\t\t  &name, &fixup_len);\n\t\tif (!fixup_val)\n\t\t\treturn fixup_len;\n\n\t\tif (fixup_len % sizeof(uint32_t))\n\t\t\treturn -FDT_ERR_BADOVERLAY;\n\t\tfixup_len /= sizeof(uint32_t);\n\n\t\ttree_val = fdt_getprop(fdto, tree_node, name, &tree_len);\n\t\tif (!tree_val) {\n\t\t\tif (tree_len == -FDT_ERR_NOTFOUND)\n\t\t\t\treturn -FDT_ERR_BADOVERLAY;\n\n\t\t\treturn tree_len;\n\t\t}\n\n\t\tfor (i = 0; i < fixup_len; i++) {\n\t\t\tfdt32_t adj_val;\n\t\t\tuint32_t poffset;\n\n\t\t\tpoffset = fdt32_to_cpu(fixup_val[i]);\n\n\t\t\t \n\t\t\tmemcpy(&adj_val, tree_val + poffset, sizeof(adj_val));\n\n\t\t\tadj_val = cpu_to_fdt32(fdt32_to_cpu(adj_val) + delta);\n\n\t\t\tret = fdt_setprop_inplace_namelen_partial(fdto,\n\t\t\t\t\t\t\t\t  tree_node,\n\t\t\t\t\t\t\t\t  name,\n\t\t\t\t\t\t\t\t  strlen(name),\n\t\t\t\t\t\t\t\t  poffset,\n\t\t\t\t\t\t\t\t  &adj_val,\n\t\t\t\t\t\t\t\t  sizeof(adj_val));\n\t\t\tif (ret == -FDT_ERR_NOSPACE)\n\t\t\t\treturn -FDT_ERR_BADOVERLAY;\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfdt_for_each_subnode(fixup_child, fdto, fixup_node) {\n\t\tconst char *fixup_child_name = fdt_get_name(fdto, fixup_child,\n\t\t\t\t\t\t\t    NULL);\n\t\tint tree_child;\n\n\t\ttree_child = fdt_subnode_offset(fdto, tree_node,\n\t\t\t\t\t\tfixup_child_name);\n\t\tif (tree_child == -FDT_ERR_NOTFOUND)\n\t\t\treturn -FDT_ERR_BADOVERLAY;\n\t\tif (tree_child < 0)\n\t\t\treturn tree_child;\n\n\t\tret = overlay_update_local_node_references(fdto,\n\t\t\t\t\t\t\t   tree_child,\n\t\t\t\t\t\t\t   fixup_child,\n\t\t\t\t\t\t\t   delta);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int overlay_update_local_references(void *fdto, uint32_t delta)\n{\n\tint fixups;\n\n\tfixups = fdt_path_offset(fdto, \"/__local_fixups__\");\n\tif (fixups < 0) {\n\t\t \n\t\tif (fixups == -FDT_ERR_NOTFOUND)\n\t\t\treturn 0;\n\n\t\treturn fixups;\n\t}\n\n\t \n\treturn overlay_update_local_node_references(fdto, 0, fixups,\n\t\t\t\t\t\t    delta);\n}\n\n \nstatic int overlay_fixup_one_phandle(void *fdt, void *fdto,\n\t\t\t\t     int symbols_off,\n\t\t\t\t     const char *path, uint32_t path_len,\n\t\t\t\t     const char *name, uint32_t name_len,\n\t\t\t\t     int poffset, const char *label)\n{\n\tconst char *symbol_path;\n\tuint32_t phandle;\n\tfdt32_t phandle_prop;\n\tint symbol_off, fixup_off;\n\tint prop_len;\n\n\tif (symbols_off < 0)\n\t\treturn symbols_off;\n\n\tsymbol_path = fdt_getprop(fdt, symbols_off, label,\n\t\t\t\t  &prop_len);\n\tif (!symbol_path)\n\t\treturn prop_len;\n\n\tsymbol_off = fdt_path_offset(fdt, symbol_path);\n\tif (symbol_off < 0)\n\t\treturn symbol_off;\n\n\tphandle = fdt_get_phandle(fdt, symbol_off);\n\tif (!phandle)\n\t\treturn -FDT_ERR_NOTFOUND;\n\n\tfixup_off = fdt_path_offset_namelen(fdto, path, path_len);\n\tif (fixup_off == -FDT_ERR_NOTFOUND)\n\t\treturn -FDT_ERR_BADOVERLAY;\n\tif (fixup_off < 0)\n\t\treturn fixup_off;\n\n\tphandle_prop = cpu_to_fdt32(phandle);\n\treturn fdt_setprop_inplace_namelen_partial(fdto, fixup_off,\n\t\t\t\t\t\t   name, name_len, poffset,\n\t\t\t\t\t\t   &phandle_prop,\n\t\t\t\t\t\t   sizeof(phandle_prop));\n};\n\n \nstatic int overlay_fixup_phandle(void *fdt, void *fdto, int symbols_off,\n\t\t\t\t int property)\n{\n\tconst char *value;\n\tconst char *label;\n\tint len;\n\n\tvalue = fdt_getprop_by_offset(fdto, property,\n\t\t\t\t      &label, &len);\n\tif (!value) {\n\t\tif (len == -FDT_ERR_NOTFOUND)\n\t\t\treturn -FDT_ERR_INTERNAL;\n\n\t\treturn len;\n\t}\n\n\tdo {\n\t\tconst char *path, *name, *fixup_end;\n\t\tconst char *fixup_str = value;\n\t\tuint32_t path_len, name_len;\n\t\tuint32_t fixup_len;\n\t\tchar *sep, *endptr;\n\t\tint poffset, ret;\n\n\t\tfixup_end = memchr(value, '\\0', len);\n\t\tif (!fixup_end)\n\t\t\treturn -FDT_ERR_BADOVERLAY;\n\t\tfixup_len = fixup_end - fixup_str;\n\n\t\tlen -= fixup_len + 1;\n\t\tvalue += fixup_len + 1;\n\n\t\tpath = fixup_str;\n\t\tsep = memchr(fixup_str, ':', fixup_len);\n\t\tif (!sep || *sep != ':')\n\t\t\treturn -FDT_ERR_BADOVERLAY;\n\n\t\tpath_len = sep - path;\n\t\tif (path_len == (fixup_len - 1))\n\t\t\treturn -FDT_ERR_BADOVERLAY;\n\n\t\tfixup_len -= path_len + 1;\n\t\tname = sep + 1;\n\t\tsep = memchr(name, ':', fixup_len);\n\t\tif (!sep || *sep != ':')\n\t\t\treturn -FDT_ERR_BADOVERLAY;\n\n\t\tname_len = sep - name;\n\t\tif (!name_len)\n\t\t\treturn -FDT_ERR_BADOVERLAY;\n\n\t\tpoffset = strtoul(sep + 1, &endptr, 10);\n\t\tif ((*endptr != '\\0') || (endptr <= (sep + 1)))\n\t\t\treturn -FDT_ERR_BADOVERLAY;\n\n\t\tret = overlay_fixup_one_phandle(fdt, fdto, symbols_off,\n\t\t\t\t\t\tpath, path_len, name, name_len,\n\t\t\t\t\t\tpoffset, label);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (len > 0);\n\n\treturn 0;\n}\n\n \nstatic int overlay_fixup_phandles(void *fdt, void *fdto)\n{\n\tint fixups_off, symbols_off;\n\tint property;\n\n\t \n\tfixups_off = fdt_path_offset(fdto, \"/__fixups__\");\n\tif (fixups_off == -FDT_ERR_NOTFOUND)\n\t\treturn 0;  \n\tif (fixups_off < 0)\n\t\treturn fixups_off;\n\n\t \n\tsymbols_off = fdt_path_offset(fdt, \"/__symbols__\");\n\tif ((symbols_off < 0 && (symbols_off != -FDT_ERR_NOTFOUND)))\n\t\treturn symbols_off;\n\n\tfdt_for_each_property_offset(property, fdto, fixups_off) {\n\t\tint ret;\n\n\t\tret = overlay_fixup_phandle(fdt, fdto, symbols_off, property);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int overlay_apply_node(void *fdt, int target,\n\t\t\t      void *fdto, int node)\n{\n\tint property;\n\tint subnode;\n\n\tfdt_for_each_property_offset(property, fdto, node) {\n\t\tconst char *name;\n\t\tconst void *prop;\n\t\tint prop_len;\n\t\tint ret;\n\n\t\tprop = fdt_getprop_by_offset(fdto, property, &name,\n\t\t\t\t\t     &prop_len);\n\t\tif (prop_len == -FDT_ERR_NOTFOUND)\n\t\t\treturn -FDT_ERR_INTERNAL;\n\t\tif (prop_len < 0)\n\t\t\treturn prop_len;\n\n\t\tret = fdt_setprop(fdt, target, name, prop, prop_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfdt_for_each_subnode(subnode, fdto, node) {\n\t\tconst char *name = fdt_get_name(fdto, subnode, NULL);\n\t\tint nnode;\n\t\tint ret;\n\n\t\tnnode = fdt_add_subnode(fdt, target, name);\n\t\tif (nnode == -FDT_ERR_EXISTS) {\n\t\t\tnnode = fdt_subnode_offset(fdt, target, name);\n\t\t\tif (nnode == -FDT_ERR_NOTFOUND)\n\t\t\t\treturn -FDT_ERR_INTERNAL;\n\t\t}\n\n\t\tif (nnode < 0)\n\t\t\treturn nnode;\n\n\t\tret = overlay_apply_node(fdt, nnode, fdto, subnode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int overlay_merge(void *fdt, void *fdto)\n{\n\tint fragment;\n\n\tfdt_for_each_subnode(fragment, fdto, 0) {\n\t\tint overlay;\n\t\tint target;\n\t\tint ret;\n\n\t\t \n\t\toverlay = fdt_subnode_offset(fdto, fragment, \"__overlay__\");\n\t\tif (overlay == -FDT_ERR_NOTFOUND)\n\t\t\tcontinue;\n\n\t\tif (overlay < 0)\n\t\t\treturn overlay;\n\n\t\ttarget = fdt_overlay_target_offset(fdt, fdto, fragment, NULL);\n\t\tif (target < 0)\n\t\t\treturn target;\n\n\t\tret = overlay_apply_node(fdt, target, fdto, overlay);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_path_len(const void *fdt, int nodeoffset)\n{\n\tint len = 0, namelen;\n\tconst char *name;\n\n\tFDT_RO_PROBE(fdt);\n\n\tfor (;;) {\n\t\tname = fdt_get_name(fdt, nodeoffset, &namelen);\n\t\tif (!name)\n\t\t\treturn namelen;\n\n\t\t \n\t\tif (namelen == 0)\n\t\t\tbreak;\n\n\t\tnodeoffset = fdt_parent_offset(fdt, nodeoffset);\n\t\tif (nodeoffset < 0)\n\t\t\treturn nodeoffset;\n\t\tlen += namelen + 1;\n\t}\n\n\t \n\tif (len == 0)\n\t\tlen++;\n\treturn len;\n}\n\n \nstatic int overlay_symbol_update(void *fdt, void *fdto)\n{\n\tint root_sym, ov_sym, prop, path_len, fragment, target;\n\tint len, frag_name_len, ret, rel_path_len;\n\tconst char *s, *e;\n\tconst char *path;\n\tconst char *name;\n\tconst char *frag_name;\n\tconst char *rel_path;\n\tconst char *target_path;\n\tchar *buf;\n\tvoid *p;\n\n\tov_sym = fdt_subnode_offset(fdto, 0, \"__symbols__\");\n\n\t \n\tif (ov_sym < 0)\n\t\treturn 0;\n\n\troot_sym = fdt_subnode_offset(fdt, 0, \"__symbols__\");\n\n\t \n\tif (root_sym == -FDT_ERR_NOTFOUND)\n\t\troot_sym = fdt_add_subnode(fdt, 0, \"__symbols__\");\n\n\t \n\tif (root_sym < 0)\n\t\treturn root_sym;\n\n\t \n\tfdt_for_each_property_offset(prop, fdto, ov_sym) {\n\t\tpath = fdt_getprop_by_offset(fdto, prop, &name, &path_len);\n\t\tif (!path)\n\t\t\treturn path_len;\n\n\t\t \n\t\tif (path_len < 1 || memchr(path, '\\0', path_len) != &path[path_len - 1])\n\t\t\treturn -FDT_ERR_BADVALUE;\n\n\t\t \n\t\te = path + path_len;\n\n\t\tif (*path != '/')\n\t\t\treturn -FDT_ERR_BADVALUE;\n\n\t\t \n\t\ts = strchr(path + 1, '/');\n\t\tif (!s) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tfrag_name = path + 1;\n\t\tfrag_name_len = s - path - 1;\n\n\t\t \n\t\tlen = sizeof(\"/__overlay__/\") - 1;\n\t\tif ((e - s) > len && (memcmp(s, \"/__overlay__/\", len) == 0)) {\n\t\t\t \n\t\t\trel_path = s + len;\n\t\t\trel_path_len = e - rel_path - 1;\n\t\t} else if ((e - s) == len\n\t\t\t   && (memcmp(s, \"/__overlay__\", len - 1) == 0)) {\n\t\t\t \n\t\t\trel_path = \"\";\n\t\t\trel_path_len = 0;\n\t\t} else {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = fdt_subnode_offset_namelen(fdto, 0, frag_name,\n\t\t\t\t\t       frag_name_len);\n\t\t \n\t\tif (ret < 0)\n\t\t\treturn -FDT_ERR_BADOVERLAY;\n\t\tfragment = ret;\n\n\t\t \n\t\tret = fdt_subnode_offset(fdto, fragment, \"__overlay__\");\n\t\tif (ret < 0)\n\t\t\treturn -FDT_ERR_BADOVERLAY;\n\n\t\t \n\t\tret = fdt_overlay_target_offset(fdt, fdto, fragment, &target_path);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ttarget = ret;\n\n\t\t \n\t\tif (!target_path) {\n\t\t\tret = get_path_len(fdt, target);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tlen = ret;\n\t\t} else {\n\t\t\tlen = strlen(target_path);\n\t\t}\n\n\t\tret = fdt_setprop_placeholder(fdt, root_sym, name,\n\t\t\t\tlen + (len > 1) + rel_path_len + 1, &p);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!target_path) {\n\t\t\t \n\t\t\tret = fdt_overlay_target_offset(fdt, fdto, fragment, &target_path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\ttarget = ret;\n\t\t}\n\n\t\tbuf = p;\n\t\tif (len > 1) {  \n\t\t\tif (!target_path) {\n\t\t\t\tret = fdt_get_path(fdt, target, buf, len + 1);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\tmemcpy(buf, target_path, len + 1);\n\n\t\t} else\n\t\t\tlen--;\n\n\t\tbuf[len] = '/';\n\t\tmemcpy(buf + len + 1, rel_path, rel_path_len);\n\t\tbuf[len + 1 + rel_path_len] = '\\0';\n\t}\n\n\treturn 0;\n}\n\nint fdt_overlay_apply(void *fdt, void *fdto)\n{\n\tuint32_t delta;\n\tint ret;\n\n\tFDT_RO_PROBE(fdt);\n\tFDT_RO_PROBE(fdto);\n\n\tret = fdt_find_max_phandle(fdt, &delta);\n\tif (ret)\n\t\tgoto err;\n\n\tret = overlay_adjust_local_phandles(fdto, delta);\n\tif (ret)\n\t\tgoto err;\n\n\tret = overlay_update_local_references(fdto, delta);\n\tif (ret)\n\t\tgoto err;\n\n\tret = overlay_fixup_phandles(fdt, fdto);\n\tif (ret)\n\t\tgoto err;\n\n\tret = overlay_merge(fdt, fdto);\n\tif (ret)\n\t\tgoto err;\n\n\tret = overlay_symbol_update(fdt, fdto);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tfdt_set_magic(fdto, ~0);\n\n\treturn 0;\n\nerr:\n\t \n\tfdt_set_magic(fdto, ~0);\n\n\t \n\tfdt_set_magic(fdt, ~0);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}