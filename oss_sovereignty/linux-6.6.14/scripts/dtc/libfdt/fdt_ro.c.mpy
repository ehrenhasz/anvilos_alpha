{
  "module_name": "fdt_ro.c",
  "hash_id": "2da708dc173f72092e84028c6636a6a5964aadb8fb2eb66ab67b644c6d4c99a3",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/libfdt/fdt_ro.c",
  "human_readable_source": "\n \n#include \"libfdt_env.h\"\n\n#include <fdt.h>\n#include <libfdt.h>\n\n#include \"libfdt_internal.h\"\n\nstatic int fdt_nodename_eq_(const void *fdt, int offset,\n\t\t\t    const char *s, int len)\n{\n\tint olen;\n\tconst char *p = fdt_get_name(fdt, offset, &olen);\n\n\tif (!p || olen < len)\n\t\t \n\t\treturn 0;\n\n\tif (memcmp(p, s, len) != 0)\n\t\treturn 0;\n\n\tif (p[len] == '\\0')\n\t\treturn 1;\n\telse if (!memchr(s, '@', len) && (p[len] == '@'))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nconst char *fdt_get_string(const void *fdt, int stroffset, int *lenp)\n{\n\tint32_t totalsize;\n\tuint32_t absoffset;\n\tsize_t len;\n\tint err;\n\tconst char *s, *n;\n\n\tif (can_assume(VALID_INPUT)) {\n\t\ts = (const char *)fdt + fdt_off_dt_strings(fdt) + stroffset;\n\n\t\tif (lenp)\n\t\t\t*lenp = strlen(s);\n\t\treturn s;\n\t}\n\ttotalsize = fdt_ro_probe_(fdt);\n\terr = totalsize;\n\tif (totalsize < 0)\n\t\tgoto fail;\n\n\terr = -FDT_ERR_BADOFFSET;\n\tabsoffset = stroffset + fdt_off_dt_strings(fdt);\n\tif (absoffset >= (unsigned)totalsize)\n\t\tgoto fail;\n\tlen = totalsize - absoffset;\n\n\tif (fdt_magic(fdt) == FDT_MAGIC) {\n\t\tif (stroffset < 0)\n\t\t\tgoto fail;\n\t\tif (can_assume(LATEST) || fdt_version(fdt) >= 17) {\n\t\t\tif ((unsigned)stroffset >= fdt_size_dt_strings(fdt))\n\t\t\t\tgoto fail;\n\t\t\tif ((fdt_size_dt_strings(fdt) - stroffset) < len)\n\t\t\t\tlen = fdt_size_dt_strings(fdt) - stroffset;\n\t\t}\n\t} else if (fdt_magic(fdt) == FDT_SW_MAGIC) {\n\t\tunsigned int sw_stroffset = -stroffset;\n\n\t\tif ((stroffset >= 0) ||\n\t\t    (sw_stroffset > fdt_size_dt_strings(fdt)))\n\t\t\tgoto fail;\n\t\tif (sw_stroffset < len)\n\t\t\tlen = sw_stroffset;\n\t} else {\n\t\terr = -FDT_ERR_INTERNAL;\n\t\tgoto fail;\n\t}\n\n\ts = (const char *)fdt + absoffset;\n\tn = memchr(s, '\\0', len);\n\tif (!n) {\n\t\t \n\t\terr = -FDT_ERR_TRUNCATED;\n\t\tgoto fail;\n\t}\n\n\tif (lenp)\n\t\t*lenp = n - s;\n\treturn s;\n\nfail:\n\tif (lenp)\n\t\t*lenp = err;\n\treturn NULL;\n}\n\nconst char *fdt_string(const void *fdt, int stroffset)\n{\n\treturn fdt_get_string(fdt, stroffset, NULL);\n}\n\nstatic int fdt_string_eq_(const void *fdt, int stroffset,\n\t\t\t  const char *s, int len)\n{\n\tint slen;\n\tconst char *p = fdt_get_string(fdt, stroffset, &slen);\n\n\treturn p && (slen == len) && (memcmp(p, s, len) == 0);\n}\n\nint fdt_find_max_phandle(const void *fdt, uint32_t *phandle)\n{\n\tuint32_t max = 0;\n\tint offset = -1;\n\n\twhile (true) {\n\t\tuint32_t value;\n\n\t\toffset = fdt_next_node(fdt, offset, NULL);\n\t\tif (offset < 0) {\n\t\t\tif (offset == -FDT_ERR_NOTFOUND)\n\t\t\t\tbreak;\n\n\t\t\treturn offset;\n\t\t}\n\n\t\tvalue = fdt_get_phandle(fdt, offset);\n\n\t\tif (value > max)\n\t\t\tmax = value;\n\t}\n\n\tif (phandle)\n\t\t*phandle = max;\n\n\treturn 0;\n}\n\nint fdt_generate_phandle(const void *fdt, uint32_t *phandle)\n{\n\tuint32_t max;\n\tint err;\n\n\terr = fdt_find_max_phandle(fdt, &max);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (max == FDT_MAX_PHANDLE)\n\t\treturn -FDT_ERR_NOPHANDLES;\n\n\tif (phandle)\n\t\t*phandle = max + 1;\n\n\treturn 0;\n}\n\nstatic const struct fdt_reserve_entry *fdt_mem_rsv(const void *fdt, int n)\n{\n\tunsigned int offset = n * sizeof(struct fdt_reserve_entry);\n\tunsigned int absoffset = fdt_off_mem_rsvmap(fdt) + offset;\n\n\tif (!can_assume(VALID_INPUT)) {\n\t\tif (absoffset < fdt_off_mem_rsvmap(fdt))\n\t\t\treturn NULL;\n\t\tif (absoffset > fdt_totalsize(fdt) -\n\t\t    sizeof(struct fdt_reserve_entry))\n\t\t\treturn NULL;\n\t}\n\treturn fdt_mem_rsv_(fdt, n);\n}\n\nint fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size)\n{\n\tconst struct fdt_reserve_entry *re;\n\n\tFDT_RO_PROBE(fdt);\n\tre = fdt_mem_rsv(fdt, n);\n\tif (!can_assume(VALID_INPUT) && !re)\n\t\treturn -FDT_ERR_BADOFFSET;\n\n\t*address = fdt64_ld_(&re->address);\n\t*size = fdt64_ld_(&re->size);\n\treturn 0;\n}\n\nint fdt_num_mem_rsv(const void *fdt)\n{\n\tint i;\n\tconst struct fdt_reserve_entry *re;\n\n\tfor (i = 0; (re = fdt_mem_rsv(fdt, i)) != NULL; i++) {\n\t\tif (fdt64_ld_(&re->size) == 0)\n\t\t\treturn i;\n\t}\n\treturn -FDT_ERR_TRUNCATED;\n}\n\nstatic int nextprop_(const void *fdt, int offset)\n{\n\tuint32_t tag;\n\tint nextoffset;\n\n\tdo {\n\t\ttag = fdt_next_tag(fdt, offset, &nextoffset);\n\n\t\tswitch (tag) {\n\t\tcase FDT_END:\n\t\t\tif (nextoffset >= 0)\n\t\t\t\treturn -FDT_ERR_BADSTRUCTURE;\n\t\t\telse\n\t\t\t\treturn nextoffset;\n\n\t\tcase FDT_PROP:\n\t\t\treturn offset;\n\t\t}\n\t\toffset = nextoffset;\n\t} while (tag == FDT_NOP);\n\n\treturn -FDT_ERR_NOTFOUND;\n}\n\nint fdt_subnode_offset_namelen(const void *fdt, int offset,\n\t\t\t       const char *name, int namelen)\n{\n\tint depth;\n\n\tFDT_RO_PROBE(fdt);\n\n\tfor (depth = 0;\n\t     (offset >= 0) && (depth >= 0);\n\t     offset = fdt_next_node(fdt, offset, &depth))\n\t\tif ((depth == 1)\n\t\t    && fdt_nodename_eq_(fdt, offset, name, namelen))\n\t\t\treturn offset;\n\n\tif (depth < 0)\n\t\treturn -FDT_ERR_NOTFOUND;\n\treturn offset;  \n}\n\nint fdt_subnode_offset(const void *fdt, int parentoffset,\n\t\t       const char *name)\n{\n\treturn fdt_subnode_offset_namelen(fdt, parentoffset, name, strlen(name));\n}\n\nint fdt_path_offset_namelen(const void *fdt, const char *path, int namelen)\n{\n\tconst char *end = path + namelen;\n\tconst char *p = path;\n\tint offset = 0;\n\n\tFDT_RO_PROBE(fdt);\n\n\t \n\tif (*path != '/') {\n\t\tconst char *q = memchr(path, '/', end - p);\n\n\t\tif (!q)\n\t\t\tq = end;\n\n\t\tp = fdt_get_alias_namelen(fdt, p, q - p);\n\t\tif (!p)\n\t\t\treturn -FDT_ERR_BADPATH;\n\t\toffset = fdt_path_offset(fdt, p);\n\n\t\tp = q;\n\t}\n\n\twhile (p < end) {\n\t\tconst char *q;\n\n\t\twhile (*p == '/') {\n\t\t\tp++;\n\t\t\tif (p == end)\n\t\t\t\treturn offset;\n\t\t}\n\t\tq = memchr(p, '/', end - p);\n\t\tif (! q)\n\t\t\tq = end;\n\n\t\toffset = fdt_subnode_offset_namelen(fdt, offset, p, q-p);\n\t\tif (offset < 0)\n\t\t\treturn offset;\n\n\t\tp = q;\n\t}\n\n\treturn offset;\n}\n\nint fdt_path_offset(const void *fdt, const char *path)\n{\n\treturn fdt_path_offset_namelen(fdt, path, strlen(path));\n}\n\nconst char *fdt_get_name(const void *fdt, int nodeoffset, int *len)\n{\n\tconst struct fdt_node_header *nh = fdt_offset_ptr_(fdt, nodeoffset);\n\tconst char *nameptr;\n\tint err;\n\n\tif (((err = fdt_ro_probe_(fdt)) < 0)\n\t    || ((err = fdt_check_node_offset_(fdt, nodeoffset)) < 0))\n\t\t\tgoto fail;\n\n\tnameptr = nh->name;\n\n\tif (!can_assume(LATEST) && fdt_version(fdt) < 0x10) {\n\t\t \n\t\tconst char *leaf;\n\t\tleaf = strrchr(nameptr, '/');\n\t\tif (leaf == NULL) {\n\t\t\terr = -FDT_ERR_BADSTRUCTURE;\n\t\t\tgoto fail;\n\t\t}\n\t\tnameptr = leaf+1;\n\t}\n\n\tif (len)\n\t\t*len = strlen(nameptr);\n\n\treturn nameptr;\n\n fail:\n\tif (len)\n\t\t*len = err;\n\treturn NULL;\n}\n\nint fdt_first_property_offset(const void *fdt, int nodeoffset)\n{\n\tint offset;\n\n\tif ((offset = fdt_check_node_offset_(fdt, nodeoffset)) < 0)\n\t\treturn offset;\n\n\treturn nextprop_(fdt, offset);\n}\n\nint fdt_next_property_offset(const void *fdt, int offset)\n{\n\tif ((offset = fdt_check_prop_offset_(fdt, offset)) < 0)\n\t\treturn offset;\n\n\treturn nextprop_(fdt, offset);\n}\n\nstatic const struct fdt_property *fdt_get_property_by_offset_(const void *fdt,\n\t\t\t\t\t\t              int offset,\n\t\t\t\t\t\t              int *lenp)\n{\n\tint err;\n\tconst struct fdt_property *prop;\n\n\tif (!can_assume(VALID_INPUT) &&\n\t    (err = fdt_check_prop_offset_(fdt, offset)) < 0) {\n\t\tif (lenp)\n\t\t\t*lenp = err;\n\t\treturn NULL;\n\t}\n\n\tprop = fdt_offset_ptr_(fdt, offset);\n\n\tif (lenp)\n\t\t*lenp = fdt32_ld_(&prop->len);\n\n\treturn prop;\n}\n\nconst struct fdt_property *fdt_get_property_by_offset(const void *fdt,\n\t\t\t\t\t\t      int offset,\n\t\t\t\t\t\t      int *lenp)\n{\n\t \n\n\tif (!can_assume(LATEST) && fdt_version(fdt) < 0x10) {\n\t\tif (lenp)\n\t\t\t*lenp = -FDT_ERR_BADVERSION;\n\t\treturn NULL;\n\t}\n\n\treturn fdt_get_property_by_offset_(fdt, offset, lenp);\n}\n\nstatic const struct fdt_property *fdt_get_property_namelen_(const void *fdt,\n\t\t\t\t\t\t            int offset,\n\t\t\t\t\t\t            const char *name,\n\t\t\t\t\t\t            int namelen,\n\t\t\t\t\t\t\t    int *lenp,\n\t\t\t\t\t\t\t    int *poffset)\n{\n\tfor (offset = fdt_first_property_offset(fdt, offset);\n\t     (offset >= 0);\n\t     (offset = fdt_next_property_offset(fdt, offset))) {\n\t\tconst struct fdt_property *prop;\n\n\t\tprop = fdt_get_property_by_offset_(fdt, offset, lenp);\n\t\tif (!can_assume(LIBFDT_FLAWLESS) && !prop) {\n\t\t\toffset = -FDT_ERR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (fdt_string_eq_(fdt, fdt32_ld_(&prop->nameoff),\n\t\t\t\t   name, namelen)) {\n\t\t\tif (poffset)\n\t\t\t\t*poffset = offset;\n\t\t\treturn prop;\n\t\t}\n\t}\n\n\tif (lenp)\n\t\t*lenp = offset;\n\treturn NULL;\n}\n\n\nconst struct fdt_property *fdt_get_property_namelen(const void *fdt,\n\t\t\t\t\t\t    int offset,\n\t\t\t\t\t\t    const char *name,\n\t\t\t\t\t\t    int namelen, int *lenp)\n{\n\t \n\tif (!can_assume(LATEST) && fdt_version(fdt) < 0x10) {\n\t\tif (lenp)\n\t\t\t*lenp = -FDT_ERR_BADVERSION;\n\t\treturn NULL;\n\t}\n\n\treturn fdt_get_property_namelen_(fdt, offset, name, namelen, lenp,\n\t\t\t\t\t NULL);\n}\n\n\nconst struct fdt_property *fdt_get_property(const void *fdt,\n\t\t\t\t\t    int nodeoffset,\n\t\t\t\t\t    const char *name, int *lenp)\n{\n\treturn fdt_get_property_namelen(fdt, nodeoffset, name,\n\t\t\t\t\tstrlen(name), lenp);\n}\n\nconst void *fdt_getprop_namelen(const void *fdt, int nodeoffset,\n\t\t\t\tconst char *name, int namelen, int *lenp)\n{\n\tint poffset;\n\tconst struct fdt_property *prop;\n\n\tprop = fdt_get_property_namelen_(fdt, nodeoffset, name, namelen, lenp,\n\t\t\t\t\t &poffset);\n\tif (!prop)\n\t\treturn NULL;\n\n\t \n\tif (!can_assume(LATEST) && fdt_version(fdt) < 0x10 &&\n\t    (poffset + sizeof(*prop)) % 8 && fdt32_ld_(&prop->len) >= 8)\n\t\treturn prop->data + 4;\n\treturn prop->data;\n}\n\nconst void *fdt_getprop_by_offset(const void *fdt, int offset,\n\t\t\t\t  const char **namep, int *lenp)\n{\n\tconst struct fdt_property *prop;\n\n\tprop = fdt_get_property_by_offset_(fdt, offset, lenp);\n\tif (!prop)\n\t\treturn NULL;\n\tif (namep) {\n\t\tconst char *name;\n\t\tint namelen;\n\n\t\tif (!can_assume(VALID_INPUT)) {\n\t\t\tname = fdt_get_string(fdt, fdt32_ld_(&prop->nameoff),\n\t\t\t\t\t      &namelen);\n\t\t\t*namep = name;\n\t\t\tif (!name) {\n\t\t\t\tif (lenp)\n\t\t\t\t\t*lenp = namelen;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t*namep = fdt_string(fdt, fdt32_ld_(&prop->nameoff));\n\t\t}\n\t}\n\n\t \n\tif (!can_assume(LATEST) && fdt_version(fdt) < 0x10 &&\n\t    (offset + sizeof(*prop)) % 8 && fdt32_ld_(&prop->len) >= 8)\n\t\treturn prop->data + 4;\n\treturn prop->data;\n}\n\nconst void *fdt_getprop(const void *fdt, int nodeoffset,\n\t\t\tconst char *name, int *lenp)\n{\n\treturn fdt_getprop_namelen(fdt, nodeoffset, name, strlen(name), lenp);\n}\n\nuint32_t fdt_get_phandle(const void *fdt, int nodeoffset)\n{\n\tconst fdt32_t *php;\n\tint len;\n\n\t \n\tphp = fdt_getprop(fdt, nodeoffset, \"phandle\", &len);\n\tif (!php || (len != sizeof(*php))) {\n\t\tphp = fdt_getprop(fdt, nodeoffset, \"linux,phandle\", &len);\n\t\tif (!php || (len != sizeof(*php)))\n\t\t\treturn 0;\n\t}\n\n\treturn fdt32_ld_(php);\n}\n\nconst char *fdt_get_alias_namelen(const void *fdt,\n\t\t\t\t  const char *name, int namelen)\n{\n\tint aliasoffset;\n\n\taliasoffset = fdt_path_offset(fdt, \"/aliases\");\n\tif (aliasoffset < 0)\n\t\treturn NULL;\n\n\treturn fdt_getprop_namelen(fdt, aliasoffset, name, namelen, NULL);\n}\n\nconst char *fdt_get_alias(const void *fdt, const char *name)\n{\n\treturn fdt_get_alias_namelen(fdt, name, strlen(name));\n}\n\nint fdt_get_path(const void *fdt, int nodeoffset, char *buf, int buflen)\n{\n\tint pdepth = 0, p = 0;\n\tint offset, depth, namelen;\n\tconst char *name;\n\n\tFDT_RO_PROBE(fdt);\n\n\tif (buflen < 2)\n\t\treturn -FDT_ERR_NOSPACE;\n\n\tfor (offset = 0, depth = 0;\n\t     (offset >= 0) && (offset <= nodeoffset);\n\t     offset = fdt_next_node(fdt, offset, &depth)) {\n\t\twhile (pdepth > depth) {\n\t\t\tdo {\n\t\t\t\tp--;\n\t\t\t} while (buf[p-1] != '/');\n\t\t\tpdepth--;\n\t\t}\n\n\t\tif (pdepth >= depth) {\n\t\t\tname = fdt_get_name(fdt, offset, &namelen);\n\t\t\tif (!name)\n\t\t\t\treturn namelen;\n\t\t\tif ((p + namelen + 1) <= buflen) {\n\t\t\t\tmemcpy(buf + p, name, namelen);\n\t\t\t\tp += namelen;\n\t\t\t\tbuf[p++] = '/';\n\t\t\t\tpdepth++;\n\t\t\t}\n\t\t}\n\n\t\tif (offset == nodeoffset) {\n\t\t\tif (pdepth < (depth + 1))\n\t\t\t\treturn -FDT_ERR_NOSPACE;\n\n\t\t\tif (p > 1)  \n\t\t\t\tp--;\n\t\t\tbuf[p] = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))\n\t\treturn -FDT_ERR_BADOFFSET;\n\telse if (offset == -FDT_ERR_BADOFFSET)\n\t\treturn -FDT_ERR_BADSTRUCTURE;\n\n\treturn offset;  \n}\n\nint fdt_supernode_atdepth_offset(const void *fdt, int nodeoffset,\n\t\t\t\t int supernodedepth, int *nodedepth)\n{\n\tint offset, depth;\n\tint supernodeoffset = -FDT_ERR_INTERNAL;\n\n\tFDT_RO_PROBE(fdt);\n\n\tif (supernodedepth < 0)\n\t\treturn -FDT_ERR_NOTFOUND;\n\n\tfor (offset = 0, depth = 0;\n\t     (offset >= 0) && (offset <= nodeoffset);\n\t     offset = fdt_next_node(fdt, offset, &depth)) {\n\t\tif (depth == supernodedepth)\n\t\t\tsupernodeoffset = offset;\n\n\t\tif (offset == nodeoffset) {\n\t\t\tif (nodedepth)\n\t\t\t\t*nodedepth = depth;\n\n\t\t\tif (supernodedepth > depth)\n\t\t\t\treturn -FDT_ERR_NOTFOUND;\n\t\t\telse\n\t\t\t\treturn supernodeoffset;\n\t\t}\n\t}\n\n\tif (!can_assume(VALID_INPUT)) {\n\t\tif ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))\n\t\t\treturn -FDT_ERR_BADOFFSET;\n\t\telse if (offset == -FDT_ERR_BADOFFSET)\n\t\t\treturn -FDT_ERR_BADSTRUCTURE;\n\t}\n\n\treturn offset;  \n}\n\nint fdt_node_depth(const void *fdt, int nodeoffset)\n{\n\tint nodedepth;\n\tint err;\n\n\terr = fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, &nodedepth);\n\tif (err)\n\t\treturn (can_assume(LIBFDT_FLAWLESS) || err < 0) ? err :\n\t\t\t-FDT_ERR_INTERNAL;\n\treturn nodedepth;\n}\n\nint fdt_parent_offset(const void *fdt, int nodeoffset)\n{\n\tint nodedepth = fdt_node_depth(fdt, nodeoffset);\n\n\tif (nodedepth < 0)\n\t\treturn nodedepth;\n\treturn fdt_supernode_atdepth_offset(fdt, nodeoffset,\n\t\t\t\t\t    nodedepth - 1, NULL);\n}\n\nint fdt_node_offset_by_prop_value(const void *fdt, int startoffset,\n\t\t\t\t  const char *propname,\n\t\t\t\t  const void *propval, int proplen)\n{\n\tint offset;\n\tconst void *val;\n\tint len;\n\n\tFDT_RO_PROBE(fdt);\n\n\t \n\tfor (offset = fdt_next_node(fdt, startoffset, NULL);\n\t     offset >= 0;\n\t     offset = fdt_next_node(fdt, offset, NULL)) {\n\t\tval = fdt_getprop(fdt, offset, propname, &len);\n\t\tif (val && (len == proplen)\n\t\t    && (memcmp(val, propval, len) == 0))\n\t\t\treturn offset;\n\t}\n\n\treturn offset;  \n}\n\nint fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle)\n{\n\tint offset;\n\n\tif ((phandle == 0) || (phandle == ~0U))\n\t\treturn -FDT_ERR_BADPHANDLE;\n\n\tFDT_RO_PROBE(fdt);\n\n\t \n\tfor (offset = fdt_next_node(fdt, -1, NULL);\n\t     offset >= 0;\n\t     offset = fdt_next_node(fdt, offset, NULL)) {\n\t\tif (fdt_get_phandle(fdt, offset) == phandle)\n\t\t\treturn offset;\n\t}\n\n\treturn offset;  \n}\n\nint fdt_stringlist_contains(const char *strlist, int listlen, const char *str)\n{\n\tint len = strlen(str);\n\tconst char *p;\n\n\twhile (listlen >= len) {\n\t\tif (memcmp(str, strlist, len+1) == 0)\n\t\t\treturn 1;\n\t\tp = memchr(strlist, '\\0', listlen);\n\t\tif (!p)\n\t\t\treturn 0;  \n\t\tlistlen -= (p-strlist) + 1;\n\t\tstrlist = p + 1;\n\t}\n\treturn 0;\n}\n\nint fdt_stringlist_count(const void *fdt, int nodeoffset, const char *property)\n{\n\tconst char *list, *end;\n\tint length, count = 0;\n\n\tlist = fdt_getprop(fdt, nodeoffset, property, &length);\n\tif (!list)\n\t\treturn length;\n\n\tend = list + length;\n\n\twhile (list < end) {\n\t\tlength = strnlen(list, end - list) + 1;\n\n\t\t \n\t\tif (list + length > end)\n\t\t\treturn -FDT_ERR_BADVALUE;\n\n\t\tlist += length;\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint fdt_stringlist_search(const void *fdt, int nodeoffset, const char *property,\n\t\t\t  const char *string)\n{\n\tint length, len, idx = 0;\n\tconst char *list, *end;\n\n\tlist = fdt_getprop(fdt, nodeoffset, property, &length);\n\tif (!list)\n\t\treturn length;\n\n\tlen = strlen(string) + 1;\n\tend = list + length;\n\n\twhile (list < end) {\n\t\tlength = strnlen(list, end - list) + 1;\n\n\t\t \n\t\tif (list + length > end)\n\t\t\treturn -FDT_ERR_BADVALUE;\n\n\t\tif (length == len && memcmp(list, string, length) == 0)\n\t\t\treturn idx;\n\n\t\tlist += length;\n\t\tidx++;\n\t}\n\n\treturn -FDT_ERR_NOTFOUND;\n}\n\nconst char *fdt_stringlist_get(const void *fdt, int nodeoffset,\n\t\t\t       const char *property, int idx,\n\t\t\t       int *lenp)\n{\n\tconst char *list, *end;\n\tint length;\n\n\tlist = fdt_getprop(fdt, nodeoffset, property, &length);\n\tif (!list) {\n\t\tif (lenp)\n\t\t\t*lenp = length;\n\n\t\treturn NULL;\n\t}\n\n\tend = list + length;\n\n\twhile (list < end) {\n\t\tlength = strnlen(list, end - list) + 1;\n\n\t\t \n\t\tif (list + length > end) {\n\t\t\tif (lenp)\n\t\t\t\t*lenp = -FDT_ERR_BADVALUE;\n\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (idx == 0) {\n\t\t\tif (lenp)\n\t\t\t\t*lenp = length - 1;\n\n\t\t\treturn list;\n\t\t}\n\n\t\tlist += length;\n\t\tidx--;\n\t}\n\n\tif (lenp)\n\t\t*lenp = -FDT_ERR_NOTFOUND;\n\n\treturn NULL;\n}\n\nint fdt_node_check_compatible(const void *fdt, int nodeoffset,\n\t\t\t      const char *compatible)\n{\n\tconst void *prop;\n\tint len;\n\n\tprop = fdt_getprop(fdt, nodeoffset, \"compatible\", &len);\n\tif (!prop)\n\t\treturn len;\n\n\treturn !fdt_stringlist_contains(prop, len, compatible);\n}\n\nint fdt_node_offset_by_compatible(const void *fdt, int startoffset,\n\t\t\t\t  const char *compatible)\n{\n\tint offset, err;\n\n\tFDT_RO_PROBE(fdt);\n\n\t \n\tfor (offset = fdt_next_node(fdt, startoffset, NULL);\n\t     offset >= 0;\n\t     offset = fdt_next_node(fdt, offset, NULL)) {\n\t\terr = fdt_node_check_compatible(fdt, offset, compatible);\n\t\tif ((err < 0) && (err != -FDT_ERR_NOTFOUND))\n\t\t\treturn err;\n\t\telse if (err == 0)\n\t\t\treturn offset;\n\t}\n\n\treturn offset;  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}