{
  "module_name": "fdt_sw.c",
  "hash_id": "ffe0cf9b7c5fcb7c13ceeaa8310358e3f514717df38692b2a1d65de6691d3d9d",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/libfdt/fdt_sw.c",
  "human_readable_source": "\n \n#include \"libfdt_env.h\"\n\n#include <fdt.h>\n#include <libfdt.h>\n\n#include \"libfdt_internal.h\"\n\nstatic int fdt_sw_probe_(void *fdt)\n{\n\tif (!can_assume(VALID_INPUT)) {\n\t\tif (fdt_magic(fdt) == FDT_MAGIC)\n\t\t\treturn -FDT_ERR_BADSTATE;\n\t\telse if (fdt_magic(fdt) != FDT_SW_MAGIC)\n\t\t\treturn -FDT_ERR_BADMAGIC;\n\t}\n\n\treturn 0;\n}\n\n#define FDT_SW_PROBE(fdt) \\\n\t{ \\\n\t\tint err; \\\n\t\tif ((err = fdt_sw_probe_(fdt)) != 0) \\\n\t\t\treturn err; \\\n\t}\n\n \nstatic int fdt_sw_probe_memrsv_(void *fdt)\n{\n\tint err = fdt_sw_probe_(fdt);\n\tif (err)\n\t\treturn err;\n\n\tif (!can_assume(VALID_INPUT) && fdt_off_dt_strings(fdt) != 0)\n\t\treturn -FDT_ERR_BADSTATE;\n\treturn 0;\n}\n\n#define FDT_SW_PROBE_MEMRSV(fdt) \\\n\t{ \\\n\t\tint err; \\\n\t\tif ((err = fdt_sw_probe_memrsv_(fdt)) != 0) \\\n\t\t\treturn err; \\\n\t}\n\n \nstatic int fdt_sw_probe_struct_(void *fdt)\n{\n\tint err = fdt_sw_probe_(fdt);\n\tif (err)\n\t\treturn err;\n\n\tif (!can_assume(VALID_INPUT) &&\n\t    fdt_off_dt_strings(fdt) != fdt_totalsize(fdt))\n\t\treturn -FDT_ERR_BADSTATE;\n\treturn 0;\n}\n\n#define FDT_SW_PROBE_STRUCT(fdt) \\\n\t{ \\\n\t\tint err; \\\n\t\tif ((err = fdt_sw_probe_struct_(fdt)) != 0) \\\n\t\t\treturn err; \\\n\t}\n\nstatic inline uint32_t sw_flags(void *fdt)\n{\n\t \n\treturn fdt_last_comp_version(fdt);\n}\n\n \n\nstatic void *fdt_grab_space_(void *fdt, size_t len)\n{\n\tunsigned int offset = fdt_size_dt_struct(fdt);\n\tunsigned int spaceleft;\n\n\tspaceleft = fdt_totalsize(fdt) - fdt_off_dt_struct(fdt)\n\t\t- fdt_size_dt_strings(fdt);\n\n\tif ((offset + len < offset) || (offset + len > spaceleft))\n\t\treturn NULL;\n\n\tfdt_set_size_dt_struct(fdt, offset + len);\n\treturn fdt_offset_ptr_w_(fdt, offset);\n}\n\nint fdt_create_with_flags(void *buf, int bufsize, uint32_t flags)\n{\n\tconst int hdrsize = FDT_ALIGN(sizeof(struct fdt_header),\n\t\t\t\t      sizeof(struct fdt_reserve_entry));\n\tvoid *fdt = buf;\n\n\tif (bufsize < hdrsize)\n\t\treturn -FDT_ERR_NOSPACE;\n\n\tif (flags & ~FDT_CREATE_FLAGS_ALL)\n\t\treturn -FDT_ERR_BADFLAGS;\n\n\tmemset(buf, 0, bufsize);\n\n\t \n\tfdt_set_magic(fdt, FDT_SW_MAGIC);\n\tfdt_set_version(fdt, FDT_LAST_SUPPORTED_VERSION);\n\tfdt_set_last_comp_version(fdt, flags);\n\n\tfdt_set_totalsize(fdt,  bufsize);\n\n\tfdt_set_off_mem_rsvmap(fdt, hdrsize);\n\tfdt_set_off_dt_struct(fdt, fdt_off_mem_rsvmap(fdt));\n\tfdt_set_off_dt_strings(fdt, 0);\n\n\treturn 0;\n}\n\nint fdt_create(void *buf, int bufsize)\n{\n\treturn fdt_create_with_flags(buf, bufsize, 0);\n}\n\nint fdt_resize(void *fdt, void *buf, int bufsize)\n{\n\tsize_t headsize, tailsize;\n\tchar *oldtail, *newtail;\n\n\tFDT_SW_PROBE(fdt);\n\n\tif (bufsize < 0)\n\t\treturn -FDT_ERR_NOSPACE;\n\n\theadsize = fdt_off_dt_struct(fdt) + fdt_size_dt_struct(fdt);\n\ttailsize = fdt_size_dt_strings(fdt);\n\n\tif (!can_assume(VALID_DTB) &&\n\t    headsize + tailsize > fdt_totalsize(fdt))\n\t\treturn -FDT_ERR_INTERNAL;\n\n\tif ((headsize + tailsize) > (unsigned)bufsize)\n\t\treturn -FDT_ERR_NOSPACE;\n\n\toldtail = (char *)fdt + fdt_totalsize(fdt) - tailsize;\n\tnewtail = (char *)buf + bufsize - tailsize;\n\n\t \n\tif (buf <= fdt) {\n\t\tmemmove(buf, fdt, headsize);\n\t\tmemmove(newtail, oldtail, tailsize);\n\t} else {\n\t\tmemmove(newtail, oldtail, tailsize);\n\t\tmemmove(buf, fdt, headsize);\n\t}\n\n\tfdt_set_totalsize(buf, bufsize);\n\tif (fdt_off_dt_strings(buf))\n\t\tfdt_set_off_dt_strings(buf, bufsize);\n\n\treturn 0;\n}\n\nint fdt_add_reservemap_entry(void *fdt, uint64_t addr, uint64_t size)\n{\n\tstruct fdt_reserve_entry *re;\n\tint offset;\n\n\tFDT_SW_PROBE_MEMRSV(fdt);\n\n\toffset = fdt_off_dt_struct(fdt);\n\tif ((offset + sizeof(*re)) > fdt_totalsize(fdt))\n\t\treturn -FDT_ERR_NOSPACE;\n\n\tre = (struct fdt_reserve_entry *)((char *)fdt + offset);\n\tre->address = cpu_to_fdt64(addr);\n\tre->size = cpu_to_fdt64(size);\n\n\tfdt_set_off_dt_struct(fdt, offset + sizeof(*re));\n\n\treturn 0;\n}\n\nint fdt_finish_reservemap(void *fdt)\n{\n\tint err = fdt_add_reservemap_entry(fdt, 0, 0);\n\n\tif (err)\n\t\treturn err;\n\n\tfdt_set_off_dt_strings(fdt, fdt_totalsize(fdt));\n\treturn 0;\n}\n\nint fdt_begin_node(void *fdt, const char *name)\n{\n\tstruct fdt_node_header *nh;\n\tint namelen;\n\n\tFDT_SW_PROBE_STRUCT(fdt);\n\n\tnamelen = strlen(name) + 1;\n\tnh = fdt_grab_space_(fdt, sizeof(*nh) + FDT_TAGALIGN(namelen));\n\tif (! nh)\n\t\treturn -FDT_ERR_NOSPACE;\n\n\tnh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);\n\tmemcpy(nh->name, name, namelen);\n\treturn 0;\n}\n\nint fdt_end_node(void *fdt)\n{\n\tfdt32_t *en;\n\n\tFDT_SW_PROBE_STRUCT(fdt);\n\n\ten = fdt_grab_space_(fdt, FDT_TAGSIZE);\n\tif (! en)\n\t\treturn -FDT_ERR_NOSPACE;\n\n\t*en = cpu_to_fdt32(FDT_END_NODE);\n\treturn 0;\n}\n\nstatic int fdt_add_string_(void *fdt, const char *s)\n{\n\tchar *strtab = (char *)fdt + fdt_totalsize(fdt);\n\tunsigned int strtabsize = fdt_size_dt_strings(fdt);\n\tunsigned int len = strlen(s) + 1;\n\tunsigned int struct_top, offset;\n\n\toffset = strtabsize + len;\n\tstruct_top = fdt_off_dt_struct(fdt) + fdt_size_dt_struct(fdt);\n\tif (fdt_totalsize(fdt) - offset < struct_top)\n\t\treturn 0;  \n\n\tmemcpy(strtab - offset, s, len);\n\tfdt_set_size_dt_strings(fdt, strtabsize + len);\n\treturn -offset;\n}\n\n \nstatic void fdt_del_last_string_(void *fdt, const char *s)\n{\n\tint strtabsize = fdt_size_dt_strings(fdt);\n\tint len = strlen(s) + 1;\n\n\tfdt_set_size_dt_strings(fdt, strtabsize - len);\n}\n\nstatic int fdt_find_add_string_(void *fdt, const char *s, int *allocated)\n{\n\tchar *strtab = (char *)fdt + fdt_totalsize(fdt);\n\tint strtabsize = fdt_size_dt_strings(fdt);\n\tconst char *p;\n\n\t*allocated = 0;\n\n\tp = fdt_find_string_(strtab - strtabsize, strtabsize, s);\n\tif (p)\n\t\treturn p - strtab;\n\n\t*allocated = 1;\n\n\treturn fdt_add_string_(fdt, s);\n}\n\nint fdt_property_placeholder(void *fdt, const char *name, int len, void **valp)\n{\n\tstruct fdt_property *prop;\n\tint nameoff;\n\tint allocated;\n\n\tFDT_SW_PROBE_STRUCT(fdt);\n\n\t \n\tif (sw_flags(fdt) & FDT_CREATE_FLAG_NO_NAME_DEDUP) {\n\t\tallocated = 1;\n\t\tnameoff = fdt_add_string_(fdt, name);\n\t} else {\n\t\tnameoff = fdt_find_add_string_(fdt, name, &allocated);\n\t}\n\tif (nameoff == 0)\n\t\treturn -FDT_ERR_NOSPACE;\n\n\tprop = fdt_grab_space_(fdt, sizeof(*prop) + FDT_TAGALIGN(len));\n\tif (! prop) {\n\t\tif (allocated)\n\t\t\tfdt_del_last_string_(fdt, name);\n\t\treturn -FDT_ERR_NOSPACE;\n\t}\n\n\tprop->tag = cpu_to_fdt32(FDT_PROP);\n\tprop->nameoff = cpu_to_fdt32(nameoff);\n\tprop->len = cpu_to_fdt32(len);\n\t*valp = prop->data;\n\treturn 0;\n}\n\nint fdt_property(void *fdt, const char *name, const void *val, int len)\n{\n\tvoid *ptr;\n\tint ret;\n\n\tret = fdt_property_placeholder(fdt, name, len, &ptr);\n\tif (ret)\n\t\treturn ret;\n\tmemcpy(ptr, val, len);\n\treturn 0;\n}\n\nint fdt_finish(void *fdt)\n{\n\tchar *p = (char *)fdt;\n\tfdt32_t *end;\n\tint oldstroffset, newstroffset;\n\tuint32_t tag;\n\tint offset, nextoffset;\n\n\tFDT_SW_PROBE_STRUCT(fdt);\n\n\t \n\tend = fdt_grab_space_(fdt, sizeof(*end));\n\tif (! end)\n\t\treturn -FDT_ERR_NOSPACE;\n\t*end = cpu_to_fdt32(FDT_END);\n\n\t \n\toldstroffset = fdt_totalsize(fdt) - fdt_size_dt_strings(fdt);\n\tnewstroffset = fdt_off_dt_struct(fdt) + fdt_size_dt_struct(fdt);\n\tmemmove(p + newstroffset, p + oldstroffset, fdt_size_dt_strings(fdt));\n\tfdt_set_off_dt_strings(fdt, newstroffset);\n\n\t \n\toffset = 0;\n\twhile ((tag = fdt_next_tag(fdt, offset, &nextoffset)) != FDT_END) {\n\t\tif (tag == FDT_PROP) {\n\t\t\tstruct fdt_property *prop =\n\t\t\t\tfdt_offset_ptr_w_(fdt, offset);\n\t\t\tint nameoff;\n\n\t\t\tnameoff = fdt32_to_cpu(prop->nameoff);\n\t\t\tnameoff += fdt_size_dt_strings(fdt);\n\t\t\tprop->nameoff = cpu_to_fdt32(nameoff);\n\t\t}\n\t\toffset = nextoffset;\n\t}\n\tif (nextoffset < 0)\n\t\treturn nextoffset;\n\n\t \n\tfdt_set_totalsize(fdt, newstroffset + fdt_size_dt_strings(fdt));\n\n\t \n\tfdt_set_last_comp_version(fdt, FDT_LAST_COMPATIBLE_VERSION);\n\tfdt_set_magic(fdt, FDT_MAGIC);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}