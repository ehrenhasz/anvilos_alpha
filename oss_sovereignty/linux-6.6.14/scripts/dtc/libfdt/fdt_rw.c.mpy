{
  "module_name": "fdt_rw.c",
  "hash_id": "49f3263a8faa94dd88162290758255d90e4bd102e424c0cc5dbd7ff2c529dd01",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/libfdt/fdt_rw.c",
  "human_readable_source": "\n \n#include \"libfdt_env.h\"\n\n#include <fdt.h>\n#include <libfdt.h>\n\n#include \"libfdt_internal.h\"\n\nstatic int fdt_blocks_misordered_(const void *fdt,\n\t\t\t\t  int mem_rsv_size, int struct_size)\n{\n\treturn (fdt_off_mem_rsvmap(fdt) < FDT_ALIGN(sizeof(struct fdt_header), 8))\n\t\t|| (fdt_off_dt_struct(fdt) <\n\t\t    (fdt_off_mem_rsvmap(fdt) + mem_rsv_size))\n\t\t|| (fdt_off_dt_strings(fdt) <\n\t\t    (fdt_off_dt_struct(fdt) + struct_size))\n\t\t|| (fdt_totalsize(fdt) <\n\t\t    (fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));\n}\n\nstatic int fdt_rw_probe_(void *fdt)\n{\n\tif (can_assume(VALID_DTB))\n\t\treturn 0;\n\tFDT_RO_PROBE(fdt);\n\n\tif (!can_assume(LATEST) && fdt_version(fdt) < 17)\n\t\treturn -FDT_ERR_BADVERSION;\n\tif (fdt_blocks_misordered_(fdt, sizeof(struct fdt_reserve_entry),\n\t\t\t\t   fdt_size_dt_struct(fdt)))\n\t\treturn -FDT_ERR_BADLAYOUT;\n\tif (!can_assume(LATEST) && fdt_version(fdt) > 17)\n\t\tfdt_set_version(fdt, 17);\n\n\treturn 0;\n}\n\n#define FDT_RW_PROBE(fdt) \\\n\t{ \\\n\t\tint err_; \\\n\t\tif ((err_ = fdt_rw_probe_(fdt)) != 0) \\\n\t\t\treturn err_; \\\n\t}\n\nstatic inline unsigned int fdt_data_size_(void *fdt)\n{\n\treturn fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);\n}\n\nstatic int fdt_splice_(void *fdt, void *splicepoint, int oldlen, int newlen)\n{\n\tchar *p = splicepoint;\n\tunsigned int dsize = fdt_data_size_(fdt);\n\tsize_t soff = p - (char *)fdt;\n\n\tif ((oldlen < 0) || (soff + oldlen < soff) || (soff + oldlen > dsize))\n\t\treturn -FDT_ERR_BADOFFSET;\n\tif ((p < (char *)fdt) || (dsize + newlen < (unsigned)oldlen))\n\t\treturn -FDT_ERR_BADOFFSET;\n\tif (dsize - oldlen + newlen > fdt_totalsize(fdt))\n\t\treturn -FDT_ERR_NOSPACE;\n\tmemmove(p + newlen, p + oldlen, ((char *)fdt + dsize) - (p + oldlen));\n\treturn 0;\n}\n\nstatic int fdt_splice_mem_rsv_(void *fdt, struct fdt_reserve_entry *p,\n\t\t\t       int oldn, int newn)\n{\n\tint delta = (newn - oldn) * sizeof(*p);\n\tint err;\n\terr = fdt_splice_(fdt, p, oldn * sizeof(*p), newn * sizeof(*p));\n\tif (err)\n\t\treturn err;\n\tfdt_set_off_dt_struct(fdt, fdt_off_dt_struct(fdt) + delta);\n\tfdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);\n\treturn 0;\n}\n\nstatic int fdt_splice_struct_(void *fdt, void *p,\n\t\t\t      int oldlen, int newlen)\n{\n\tint delta = newlen - oldlen;\n\tint err;\n\n\tif ((err = fdt_splice_(fdt, p, oldlen, newlen)))\n\t\treturn err;\n\n\tfdt_set_size_dt_struct(fdt, fdt_size_dt_struct(fdt) + delta);\n\tfdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);\n\treturn 0;\n}\n\n \nstatic void fdt_del_last_string_(void *fdt, const char *s)\n{\n\tint newlen = strlen(s) + 1;\n\n\tfdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) - newlen);\n}\n\nstatic int fdt_splice_string_(void *fdt, int newlen)\n{\n\tvoid *p = (char *)fdt\n\t\t+ fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);\n\tint err;\n\n\tif ((err = fdt_splice_(fdt, p, 0, newlen)))\n\t\treturn err;\n\n\tfdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) + newlen);\n\treturn 0;\n}\n\n \nstatic int fdt_find_add_string_(void *fdt, const char *s, int *allocated)\n{\n\tchar *strtab = (char *)fdt + fdt_off_dt_strings(fdt);\n\tconst char *p;\n\tchar *new;\n\tint len = strlen(s) + 1;\n\tint err;\n\n\tif (!can_assume(NO_ROLLBACK))\n\t\t*allocated = 0;\n\n\tp = fdt_find_string_(strtab, fdt_size_dt_strings(fdt), s);\n\tif (p)\n\t\t \n\t\treturn (p - strtab);\n\n\tnew = strtab + fdt_size_dt_strings(fdt);\n\terr = fdt_splice_string_(fdt, len);\n\tif (err)\n\t\treturn err;\n\n\tif (!can_assume(NO_ROLLBACK))\n\t\t*allocated = 1;\n\n\tmemcpy(new, s, len);\n\treturn (new - strtab);\n}\n\nint fdt_add_mem_rsv(void *fdt, uint64_t address, uint64_t size)\n{\n\tstruct fdt_reserve_entry *re;\n\tint err;\n\n\tFDT_RW_PROBE(fdt);\n\n\tre = fdt_mem_rsv_w_(fdt, fdt_num_mem_rsv(fdt));\n\terr = fdt_splice_mem_rsv_(fdt, re, 0, 1);\n\tif (err)\n\t\treturn err;\n\n\tre->address = cpu_to_fdt64(address);\n\tre->size = cpu_to_fdt64(size);\n\treturn 0;\n}\n\nint fdt_del_mem_rsv(void *fdt, int n)\n{\n\tstruct fdt_reserve_entry *re = fdt_mem_rsv_w_(fdt, n);\n\n\tFDT_RW_PROBE(fdt);\n\n\tif (n >= fdt_num_mem_rsv(fdt))\n\t\treturn -FDT_ERR_NOTFOUND;\n\n\treturn fdt_splice_mem_rsv_(fdt, re, 1, 0);\n}\n\nstatic int fdt_resize_property_(void *fdt, int nodeoffset, const char *name,\n\t\t\t\tint len, struct fdt_property **prop)\n{\n\tint oldlen;\n\tint err;\n\n\t*prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);\n\tif (!*prop)\n\t\treturn oldlen;\n\n\tif ((err = fdt_splice_struct_(fdt, (*prop)->data, FDT_TAGALIGN(oldlen),\n\t\t\t\t      FDT_TAGALIGN(len))))\n\t\treturn err;\n\n\t(*prop)->len = cpu_to_fdt32(len);\n\treturn 0;\n}\n\nstatic int fdt_add_property_(void *fdt, int nodeoffset, const char *name,\n\t\t\t     int len, struct fdt_property **prop)\n{\n\tint proplen;\n\tint nextoffset;\n\tint namestroff;\n\tint err;\n\tint allocated;\n\n\tif ((nextoffset = fdt_check_node_offset_(fdt, nodeoffset)) < 0)\n\t\treturn nextoffset;\n\n\tnamestroff = fdt_find_add_string_(fdt, name, &allocated);\n\tif (namestroff < 0)\n\t\treturn namestroff;\n\n\t*prop = fdt_offset_ptr_w_(fdt, nextoffset);\n\tproplen = sizeof(**prop) + FDT_TAGALIGN(len);\n\n\terr = fdt_splice_struct_(fdt, *prop, 0, proplen);\n\tif (err) {\n\t\t \n\t\tif (!can_assume(NO_ROLLBACK) && allocated)\n\t\t\tfdt_del_last_string_(fdt, name);\n\t\treturn err;\n\t}\n\n\t(*prop)->tag = cpu_to_fdt32(FDT_PROP);\n\t(*prop)->nameoff = cpu_to_fdt32(namestroff);\n\t(*prop)->len = cpu_to_fdt32(len);\n\treturn 0;\n}\n\nint fdt_set_name(void *fdt, int nodeoffset, const char *name)\n{\n\tchar *namep;\n\tint oldlen, newlen;\n\tint err;\n\n\tFDT_RW_PROBE(fdt);\n\n\tnamep = (char *)(uintptr_t)fdt_get_name(fdt, nodeoffset, &oldlen);\n\tif (!namep)\n\t\treturn oldlen;\n\n\tnewlen = strlen(name);\n\n\terr = fdt_splice_struct_(fdt, namep, FDT_TAGALIGN(oldlen+1),\n\t\t\t\t FDT_TAGALIGN(newlen+1));\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(namep, name, newlen+1);\n\treturn 0;\n}\n\nint fdt_setprop_placeholder(void *fdt, int nodeoffset, const char *name,\n\t\t\t    int len, void **prop_data)\n{\n\tstruct fdt_property *prop;\n\tint err;\n\n\tFDT_RW_PROBE(fdt);\n\n\terr = fdt_resize_property_(fdt, nodeoffset, name, len, &prop);\n\tif (err == -FDT_ERR_NOTFOUND)\n\t\terr = fdt_add_property_(fdt, nodeoffset, name, len, &prop);\n\tif (err)\n\t\treturn err;\n\n\t*prop_data = prop->data;\n\treturn 0;\n}\n\nint fdt_setprop(void *fdt, int nodeoffset, const char *name,\n\t\tconst void *val, int len)\n{\n\tvoid *prop_data;\n\tint err;\n\n\terr = fdt_setprop_placeholder(fdt, nodeoffset, name, len, &prop_data);\n\tif (err)\n\t\treturn err;\n\n\tif (len)\n\t\tmemcpy(prop_data, val, len);\n\treturn 0;\n}\n\nint fdt_appendprop(void *fdt, int nodeoffset, const char *name,\n\t\t   const void *val, int len)\n{\n\tstruct fdt_property *prop;\n\tint err, oldlen, newlen;\n\n\tFDT_RW_PROBE(fdt);\n\n\tprop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);\n\tif (prop) {\n\t\tnewlen = len + oldlen;\n\t\terr = fdt_splice_struct_(fdt, prop->data,\n\t\t\t\t\t FDT_TAGALIGN(oldlen),\n\t\t\t\t\t FDT_TAGALIGN(newlen));\n\t\tif (err)\n\t\t\treturn err;\n\t\tprop->len = cpu_to_fdt32(newlen);\n\t\tmemcpy(prop->data + oldlen, val, len);\n\t} else {\n\t\terr = fdt_add_property_(fdt, nodeoffset, name, len, &prop);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmemcpy(prop->data, val, len);\n\t}\n\treturn 0;\n}\n\nint fdt_delprop(void *fdt, int nodeoffset, const char *name)\n{\n\tstruct fdt_property *prop;\n\tint len, proplen;\n\n\tFDT_RW_PROBE(fdt);\n\n\tprop = fdt_get_property_w(fdt, nodeoffset, name, &len);\n\tif (!prop)\n\t\treturn len;\n\n\tproplen = sizeof(*prop) + FDT_TAGALIGN(len);\n\treturn fdt_splice_struct_(fdt, prop, proplen, 0);\n}\n\nint fdt_add_subnode_namelen(void *fdt, int parentoffset,\n\t\t\t    const char *name, int namelen)\n{\n\tstruct fdt_node_header *nh;\n\tint offset, nextoffset;\n\tint nodelen;\n\tint err;\n\tuint32_t tag;\n\tfdt32_t *endtag;\n\n\tFDT_RW_PROBE(fdt);\n\n\toffset = fdt_subnode_offset_namelen(fdt, parentoffset, name, namelen);\n\tif (offset >= 0)\n\t\treturn -FDT_ERR_EXISTS;\n\telse if (offset != -FDT_ERR_NOTFOUND)\n\t\treturn offset;\n\n\t \n\ttag = fdt_next_tag(fdt, parentoffset, &nextoffset);\n\t \n\tif (!can_assume(LIBFDT_FLAWLESS) && (tag != FDT_BEGIN_NODE))\n\t\treturn -FDT_ERR_INTERNAL;\n\tdo {\n\t\toffset = nextoffset;\n\t\ttag = fdt_next_tag(fdt, offset, &nextoffset);\n\t} while ((tag == FDT_PROP) || (tag == FDT_NOP));\n\n\tnh = fdt_offset_ptr_w_(fdt, offset);\n\tnodelen = sizeof(*nh) + FDT_TAGALIGN(namelen+1) + FDT_TAGSIZE;\n\n\terr = fdt_splice_struct_(fdt, nh, 0, nodelen);\n\tif (err)\n\t\treturn err;\n\n\tnh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);\n\tmemset(nh->name, 0, FDT_TAGALIGN(namelen+1));\n\tmemcpy(nh->name, name, namelen);\n\tendtag = (fdt32_t *)((char *)nh + nodelen - FDT_TAGSIZE);\n\t*endtag = cpu_to_fdt32(FDT_END_NODE);\n\n\treturn offset;\n}\n\nint fdt_add_subnode(void *fdt, int parentoffset, const char *name)\n{\n\treturn fdt_add_subnode_namelen(fdt, parentoffset, name, strlen(name));\n}\n\nint fdt_del_node(void *fdt, int nodeoffset)\n{\n\tint endoffset;\n\n\tFDT_RW_PROBE(fdt);\n\n\tendoffset = fdt_node_end_offset_(fdt, nodeoffset);\n\tif (endoffset < 0)\n\t\treturn endoffset;\n\n\treturn fdt_splice_struct_(fdt, fdt_offset_ptr_w_(fdt, nodeoffset),\n\t\t\t\t  endoffset - nodeoffset, 0);\n}\n\nstatic void fdt_packblocks_(const char *old, char *new,\n\t\t\t    int mem_rsv_size,\n\t\t\t    int struct_size,\n\t\t\t    int strings_size)\n{\n\tint mem_rsv_off, struct_off, strings_off;\n\n\tmem_rsv_off = FDT_ALIGN(sizeof(struct fdt_header), 8);\n\tstruct_off = mem_rsv_off + mem_rsv_size;\n\tstrings_off = struct_off + struct_size;\n\n\tmemmove(new + mem_rsv_off, old + fdt_off_mem_rsvmap(old), mem_rsv_size);\n\tfdt_set_off_mem_rsvmap(new, mem_rsv_off);\n\n\tmemmove(new + struct_off, old + fdt_off_dt_struct(old), struct_size);\n\tfdt_set_off_dt_struct(new, struct_off);\n\tfdt_set_size_dt_struct(new, struct_size);\n\n\tmemmove(new + strings_off, old + fdt_off_dt_strings(old), strings_size);\n\tfdt_set_off_dt_strings(new, strings_off);\n\tfdt_set_size_dt_strings(new, fdt_size_dt_strings(old));\n}\n\nint fdt_open_into(const void *fdt, void *buf, int bufsize)\n{\n\tint err;\n\tint mem_rsv_size, struct_size;\n\tint newsize;\n\tconst char *fdtstart = fdt;\n\tconst char *fdtend = fdtstart + fdt_totalsize(fdt);\n\tchar *tmp;\n\n\tFDT_RO_PROBE(fdt);\n\n\tmem_rsv_size = (fdt_num_mem_rsv(fdt)+1)\n\t\t* sizeof(struct fdt_reserve_entry);\n\n\tif (can_assume(LATEST) || fdt_version(fdt) >= 17) {\n\t\tstruct_size = fdt_size_dt_struct(fdt);\n\t} else if (fdt_version(fdt) == 16) {\n\t\tstruct_size = 0;\n\t\twhile (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)\n\t\t\t;\n\t\tif (struct_size < 0)\n\t\t\treturn struct_size;\n\t} else {\n\t\treturn -FDT_ERR_BADVERSION;\n\t}\n\n\tif (can_assume(LIBFDT_ORDER) ||\n\t    !fdt_blocks_misordered_(fdt, mem_rsv_size, struct_size)) {\n\t\t \n\t\terr = fdt_move(fdt, buf, bufsize);\n\t\tif (err)\n\t\t\treturn err;\n\t\tfdt_set_version(buf, 17);\n\t\tfdt_set_size_dt_struct(buf, struct_size);\n\t\tfdt_set_totalsize(buf, bufsize);\n\t\treturn 0;\n\t}\n\n\t \n\tnewsize = FDT_ALIGN(sizeof(struct fdt_header), 8) + mem_rsv_size\n\t\t+ struct_size + fdt_size_dt_strings(fdt);\n\n\tif (bufsize < newsize)\n\t\treturn -FDT_ERR_NOSPACE;\n\n\t \n\ttmp = buf;\n\t \n\tif (((tmp + newsize) > fdtstart) && (tmp < fdtend)) {\n\t\t \n\t\ttmp = (char *)(uintptr_t)fdtend;\n\t\tif ((tmp + newsize) > ((char *)buf + bufsize))\n\t\t\treturn -FDT_ERR_NOSPACE;\n\t}\n\n\tfdt_packblocks_(fdt, tmp, mem_rsv_size, struct_size,\n\t\t\tfdt_size_dt_strings(fdt));\n\tmemmove(buf, tmp, newsize);\n\n\tfdt_set_magic(buf, FDT_MAGIC);\n\tfdt_set_totalsize(buf, bufsize);\n\tfdt_set_version(buf, 17);\n\tfdt_set_last_comp_version(buf, 16);\n\tfdt_set_boot_cpuid_phys(buf, fdt_boot_cpuid_phys(fdt));\n\n\treturn 0;\n}\n\nint fdt_pack(void *fdt)\n{\n\tint mem_rsv_size;\n\n\tFDT_RW_PROBE(fdt);\n\n\tmem_rsv_size = (fdt_num_mem_rsv(fdt)+1)\n\t\t* sizeof(struct fdt_reserve_entry);\n\tfdt_packblocks_(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt),\n\t\t\tfdt_size_dt_strings(fdt));\n\tfdt_set_totalsize(fdt, fdt_data_size_(fdt));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}